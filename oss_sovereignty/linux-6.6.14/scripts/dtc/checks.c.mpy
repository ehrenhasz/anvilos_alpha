{
  "module_name": "checks.c",
  "hash_id": "d1e881ef8897a65122fb4e980a9870aef53c3b01cea90426ba4657ab0a7f8d41",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/checks.c",
  "human_readable_source": "\n \n\n#include \"dtc.h\"\n#include \"srcpos.h\"\n\n#ifdef TRACE_CHECKS\n#define TRACE(c, ...) \\\n\tdo { \\\n\t\tfprintf(stderr, \"=== %s: \", (c)->name); \\\n\t\tfprintf(stderr, __VA_ARGS__); \\\n\t\tfprintf(stderr, \"\\n\"); \\\n\t} while (0)\n#else\n#define TRACE(c, fmt, ...)\tdo { } while (0)\n#endif\n\nenum checkstatus {\n\tUNCHECKED = 0,\n\tPREREQ,\n\tPASSED,\n\tFAILED,\n};\n\nstruct check;\n\ntypedef void (*check_fn)(struct check *c, struct dt_info *dti, struct node *node);\n\nstruct check {\n\tconst char *name;\n\tcheck_fn fn;\n\tvoid *data;\n\tbool warn, error;\n\tenum checkstatus status;\n\tbool inprogress;\n\tint num_prereqs;\n\tstruct check **prereq;\n};\n\n#define CHECK_ENTRY(nm_, fn_, d_, w_, e_, ...)\t       \\\n\tstatic struct check *nm_##_prereqs[] = { __VA_ARGS__ }; \\\n\tstatic struct check nm_ = { \\\n\t\t.name = #nm_, \\\n\t\t.fn = (fn_), \\\n\t\t.data = (d_), \\\n\t\t.warn = (w_), \\\n\t\t.error = (e_), \\\n\t\t.status = UNCHECKED, \\\n\t\t.num_prereqs = ARRAY_SIZE(nm_##_prereqs), \\\n\t\t.prereq = nm_##_prereqs, \\\n\t};\n#define WARNING(nm_, fn_, d_, ...) \\\n\tCHECK_ENTRY(nm_, fn_, d_, true, false, __VA_ARGS__)\n#define ERROR(nm_, fn_, d_, ...) \\\n\tCHECK_ENTRY(nm_, fn_, d_, false, true, __VA_ARGS__)\n#define CHECK(nm_, fn_, d_, ...) \\\n\tCHECK_ENTRY(nm_, fn_, d_, false, false, __VA_ARGS__)\n\nstatic inline void  PRINTF(5, 6) check_msg(struct check *c, struct dt_info *dti,\n\t\t\t\t\t   struct node *node,\n\t\t\t\t\t   struct property *prop,\n\t\t\t\t\t   const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *str = NULL;\n\tstruct srcpos *pos = NULL;\n\tchar *file_str;\n\n\tif (!(c->warn && (quiet < 1)) && !(c->error && (quiet < 2)))\n\t\treturn;\n\n\tif (prop && prop->srcpos)\n\t\tpos = prop->srcpos;\n\telse if (node && node->srcpos)\n\t\tpos = node->srcpos;\n\n\tif (pos) {\n\t\tfile_str = srcpos_string(pos);\n\t\txasprintf(&str, \"%s\", file_str);\n\t\tfree(file_str);\n\t} else if (streq(dti->outname, \"-\")) {\n\t\txasprintf(&str, \"<stdout>\");\n\t} else {\n\t\txasprintf(&str, \"%s\", dti->outname);\n\t}\n\n\txasprintf_append(&str, \": %s (%s): \",\n\t\t\t(c->error) ? \"ERROR\" : \"Warning\", c->name);\n\n\tif (node) {\n\t\tif (prop)\n\t\t\txasprintf_append(&str, \"%s:%s: \", node->fullpath, prop->name);\n\t\telse\n\t\t\txasprintf_append(&str, \"%s: \", node->fullpath);\n\t}\n\n\tva_start(ap, fmt);\n\txavsprintf_append(&str, fmt, ap);\n\tva_end(ap);\n\n\txasprintf_append(&str, \"\\n\");\n\n\tif (!prop && pos) {\n\t\tpos = node->srcpos;\n\t\twhile (pos->next) {\n\t\t\tpos = pos->next;\n\n\t\t\tfile_str = srcpos_string(pos);\n\t\t\txasprintf_append(&str, \"  also defined at %s\\n\", file_str);\n\t\t\tfree(file_str);\n\t\t}\n\t}\n\n\tfputs(str, stderr);\n}\n\n#define FAIL(c, dti, node, ...)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tTRACE((c), \"\\t\\tFAILED at %s:%d\", __FILE__, __LINE__);\t\\\n\t\t(c)->status = FAILED;\t\t\t\t\t\\\n\t\tcheck_msg((c), dti, node, NULL, __VA_ARGS__);\t\t\\\n\t} while (0)\n\n#define FAIL_PROP(c, dti, node, prop, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tTRACE((c), \"\\t\\tFAILED at %s:%d\", __FILE__, __LINE__);\t\\\n\t\t(c)->status = FAILED;\t\t\t\t\t\\\n\t\tcheck_msg((c), dti, node, prop, __VA_ARGS__);\t\t\\\n\t} while (0)\n\n\nstatic void check_nodes_props(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tstruct node *child;\n\n\tTRACE(c, \"%s\", node->fullpath);\n\tif (c->fn)\n\t\tc->fn(c, dti, node);\n\n\tfor_each_child(node, child)\n\t\tcheck_nodes_props(c, dti, child);\n}\n\nstatic bool is_multiple_of(int multiple, int divisor)\n{\n\tif (divisor == 0)\n\t\treturn multiple == 0;\n\telse\n\t\treturn (multiple % divisor) == 0;\n}\n\nstatic bool run_check(struct check *c, struct dt_info *dti)\n{\n\tstruct node *dt = dti->dt;\n\tbool error = false;\n\tint i;\n\n\tassert(!c->inprogress);\n\n\tif (c->status != UNCHECKED)\n\t\tgoto out;\n\n\tc->inprogress = true;\n\n\tfor (i = 0; i < c->num_prereqs; i++) {\n\t\tstruct check *prq = c->prereq[i];\n\t\terror = error || run_check(prq, dti);\n\t\tif (prq->status != PASSED) {\n\t\t\tc->status = PREREQ;\n\t\t\tcheck_msg(c, dti, NULL, NULL, \"Failed prerequisite '%s'\",\n\t\t\t\t  c->prereq[i]->name);\n\t\t}\n\t}\n\n\tif (c->status != UNCHECKED)\n\t\tgoto out;\n\n\tcheck_nodes_props(c, dti, dt);\n\n\tif (c->status == UNCHECKED)\n\t\tc->status = PASSED;\n\n\tTRACE(c, \"\\tCompleted, status %d\", c->status);\n\nout:\n\tc->inprogress = false;\n\tif ((c->status != PASSED) && (c->error))\n\t\terror = true;\n\treturn error;\n}\n\n \n\n \nstatic inline void check_always_fail(struct check *c, struct dt_info *dti,\n\t\t\t\t     struct node *node)\n{\n\tFAIL(c, dti, node, \"always_fail check\");\n}\nCHECK(always_fail, check_always_fail, NULL);\n\nstatic void check_is_string(struct check *c, struct dt_info *dti,\n\t\t\t    struct node *node)\n{\n\tstruct property *prop;\n\tchar *propname = c->data;\n\n\tprop = get_property(node, propname);\n\tif (!prop)\n\t\treturn;  \n\n\tif (!data_is_one_string(prop->val))\n\t\tFAIL_PROP(c, dti, node, prop, \"property is not a string\");\n}\n#define WARNING_IF_NOT_STRING(nm, propname) \\\n\tWARNING(nm, check_is_string, (propname))\n#define ERROR_IF_NOT_STRING(nm, propname) \\\n\tERROR(nm, check_is_string, (propname))\n\nstatic void check_is_string_list(struct check *c, struct dt_info *dti,\n\t\t\t\t struct node *node)\n{\n\tint rem, l;\n\tstruct property *prop;\n\tchar *propname = c->data;\n\tchar *str;\n\n\tprop = get_property(node, propname);\n\tif (!prop)\n\t\treturn;  \n\n\tstr = prop->val.val;\n\trem = prop->val.len;\n\twhile (rem > 0) {\n\t\tl = strnlen(str, rem);\n\t\tif (l == rem) {\n\t\t\tFAIL_PROP(c, dti, node, prop, \"property is not a string list\");\n\t\t\tbreak;\n\t\t}\n\t\trem -= l + 1;\n\t\tstr += l + 1;\n\t}\n}\n#define WARNING_IF_NOT_STRING_LIST(nm, propname) \\\n\tWARNING(nm, check_is_string_list, (propname))\n#define ERROR_IF_NOT_STRING_LIST(nm, propname) \\\n\tERROR(nm, check_is_string_list, (propname))\n\nstatic void check_is_cell(struct check *c, struct dt_info *dti,\n\t\t\t  struct node *node)\n{\n\tstruct property *prop;\n\tchar *propname = c->data;\n\n\tprop = get_property(node, propname);\n\tif (!prop)\n\t\treturn;  \n\n\tif (prop->val.len != sizeof(cell_t))\n\t\tFAIL_PROP(c, dti, node, prop, \"property is not a single cell\");\n}\n#define WARNING_IF_NOT_CELL(nm, propname) \\\n\tWARNING(nm, check_is_cell, (propname))\n#define ERROR_IF_NOT_CELL(nm, propname) \\\n\tERROR(nm, check_is_cell, (propname))\n\n \n\nstatic void check_duplicate_node_names(struct check *c, struct dt_info *dti,\n\t\t\t\t       struct node *node)\n{\n\tstruct node *child, *child2;\n\n\tfor_each_child(node, child)\n\t\tfor (child2 = child->next_sibling;\n\t\t     child2;\n\t\t     child2 = child2->next_sibling)\n\t\t\tif (streq(child->name, child2->name))\n\t\t\t\tFAIL(c, dti, child2, \"Duplicate node name\");\n}\nERROR(duplicate_node_names, check_duplicate_node_names, NULL);\n\nstatic void check_duplicate_property_names(struct check *c, struct dt_info *dti,\n\t\t\t\t\t   struct node *node)\n{\n\tstruct property *prop, *prop2;\n\n\tfor_each_property(node, prop) {\n\t\tfor (prop2 = prop->next; prop2; prop2 = prop2->next) {\n\t\t\tif (prop2->deleted)\n\t\t\t\tcontinue;\n\t\t\tif (streq(prop->name, prop2->name))\n\t\t\t\tFAIL_PROP(c, dti, node, prop, \"Duplicate property name\");\n\t\t}\n\t}\n}\nERROR(duplicate_property_names, check_duplicate_property_names, NULL);\n\n#define LOWERCASE\t\"abcdefghijklmnopqrstuvwxyz\"\n#define UPPERCASE\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n#define DIGITS\t\t\"0123456789\"\n#define NODECHARS\tLOWERCASE UPPERCASE DIGITS \",._+-@\"\n#define PROPCHARS\tLOWERCASE UPPERCASE DIGITS \",._+*#?-\"\n#define PROPNODECHARSSTRICT\tLOWERCASE UPPERCASE DIGITS \",-\"\n\nstatic void check_node_name_chars(struct check *c, struct dt_info *dti,\n\t\t\t\t  struct node *node)\n{\n\tsize_t n = strspn(node->name, c->data);\n\n\tif (n < strlen(node->name))\n\t\tFAIL(c, dti, node, \"Bad character '%c' in node name\",\n\t\t     node->name[n]);\n}\nERROR(node_name_chars, check_node_name_chars, NODECHARS);\n\nstatic void check_node_name_chars_strict(struct check *c, struct dt_info *dti,\n\t\t\t\t\t struct node *node)\n{\n\tint n = strspn(node->name, c->data);\n\n\tif (n < node->basenamelen)\n\t\tFAIL(c, dti, node, \"Character '%c' not recommended in node name\",\n\t\t     node->name[n]);\n}\nCHECK(node_name_chars_strict, check_node_name_chars_strict, PROPNODECHARSSTRICT);\n\nstatic void check_node_name_format(struct check *c, struct dt_info *dti,\n\t\t\t\t   struct node *node)\n{\n\tif (strchr(get_unitname(node), '@'))\n\t\tFAIL(c, dti, node, \"multiple '@' characters in node name\");\n}\nERROR(node_name_format, check_node_name_format, NULL, &node_name_chars);\n\nstatic void check_node_name_vs_property_name(struct check *c,\n\t\t\t\t\t     struct dt_info *dti,\n\t\t\t\t\t     struct node *node)\n{\n\tif (!node->parent)\n\t\treturn;\n\n\tif (get_property(node->parent, node->name)) {\n\t\tFAIL(c, dti, node, \"node name and property name conflict\");\n\t}\n}\nWARNING(node_name_vs_property_name, check_node_name_vs_property_name,\n\tNULL, &node_name_chars);\n\nstatic void check_unit_address_vs_reg(struct check *c, struct dt_info *dti,\n\t\t\t\t      struct node *node)\n{\n\tconst char *unitname = get_unitname(node);\n\tstruct property *prop = get_property(node, \"reg\");\n\n\tif (get_subnode(node, \"__overlay__\")) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (!prop) {\n\t\tprop = get_property(node, \"ranges\");\n\t\tif (prop && !prop->val.len)\n\t\t\tprop = NULL;\n\t}\n\n\tif (prop) {\n\t\tif (!unitname[0])\n\t\t\tFAIL(c, dti, node, \"node has a reg or ranges property, but no unit name\");\n\t} else {\n\t\tif (unitname[0])\n\t\t\tFAIL(c, dti, node, \"node has a unit name, but no reg or ranges property\");\n\t}\n}\nWARNING(unit_address_vs_reg, check_unit_address_vs_reg, NULL);\n\nstatic void check_property_name_chars(struct check *c, struct dt_info *dti,\n\t\t\t\t      struct node *node)\n{\n\tstruct property *prop;\n\n\tfor_each_property(node, prop) {\n\t\tsize_t n = strspn(prop->name, c->data);\n\n\t\tif (n < strlen(prop->name))\n\t\t\tFAIL_PROP(c, dti, node, prop, \"Bad character '%c' in property name\",\n\t\t\t\t  prop->name[n]);\n\t}\n}\nERROR(property_name_chars, check_property_name_chars, PROPCHARS);\n\nstatic void check_property_name_chars_strict(struct check *c,\n\t\t\t\t\t     struct dt_info *dti,\n\t\t\t\t\t     struct node *node)\n{\n\tstruct property *prop;\n\n\tfor_each_property(node, prop) {\n\t\tconst char *name = prop->name;\n\t\tsize_t n = strspn(name, c->data);\n\n\t\tif (n == strlen(prop->name))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (streq(name, \"device_type\"))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (name[n] == '#' && ((n == 0) || (name[n-1] == ','))) {\n\t\t\tname += n + 1;\n\t\t\tn = strspn(name, c->data);\n\t\t}\n\t\tif (n < strlen(name))\n\t\t\tFAIL_PROP(c, dti, node, prop, \"Character '%c' not recommended in property name\",\n\t\t\t\t  name[n]);\n\t}\n}\nCHECK(property_name_chars_strict, check_property_name_chars_strict, PROPNODECHARSSTRICT);\n\n#define DESCLABEL_FMT\t\"%s%s%s%s%s\"\n#define DESCLABEL_ARGS(node,prop,mark)\t\t\\\n\t((mark) ? \"value of \" : \"\"),\t\t\\\n\t((prop) ? \"'\" : \"\"), \\\n\t((prop) ? (prop)->name : \"\"), \\\n\t((prop) ? \"' in \" : \"\"), (node)->fullpath\n\nstatic void check_duplicate_label(struct check *c, struct dt_info *dti,\n\t\t\t\t  const char *label, struct node *node,\n\t\t\t\t  struct property *prop, struct marker *mark)\n{\n\tstruct node *dt = dti->dt;\n\tstruct node *othernode = NULL;\n\tstruct property *otherprop = NULL;\n\tstruct marker *othermark = NULL;\n\n\tothernode = get_node_by_label(dt, label);\n\n\tif (!othernode)\n\t\totherprop = get_property_by_label(dt, label, &othernode);\n\tif (!othernode)\n\t\tothermark = get_marker_label(dt, label, &othernode,\n\t\t\t\t\t       &otherprop);\n\n\tif (!othernode)\n\t\treturn;\n\n\tif ((othernode != node) || (otherprop != prop) || (othermark != mark))\n\t\tFAIL(c, dti, node, \"Duplicate label '%s' on \" DESCLABEL_FMT\n\t\t     \" and \" DESCLABEL_FMT,\n\t\t     label, DESCLABEL_ARGS(node, prop, mark),\n\t\t     DESCLABEL_ARGS(othernode, otherprop, othermark));\n}\n\nstatic void check_duplicate_label_node(struct check *c, struct dt_info *dti,\n\t\t\t\t       struct node *node)\n{\n\tstruct label *l;\n\tstruct property *prop;\n\n\tfor_each_label(node->labels, l)\n\t\tcheck_duplicate_label(c, dti, l->label, node, NULL, NULL);\n\n\tfor_each_property(node, prop) {\n\t\tstruct marker *m = prop->val.markers;\n\n\t\tfor_each_label(prop->labels, l)\n\t\t\tcheck_duplicate_label(c, dti, l->label, node, prop, NULL);\n\n\t\tfor_each_marker_of_type(m, LABEL)\n\t\t\tcheck_duplicate_label(c, dti, m->ref, node, prop, m);\n\t}\n}\nERROR(duplicate_label, check_duplicate_label_node, NULL);\n\nstatic cell_t check_phandle_prop(struct check *c, struct dt_info *dti,\n\t\t\t\t struct node *node, const char *propname)\n{\n\tstruct node *root = dti->dt;\n\tstruct property *prop;\n\tstruct marker *m;\n\tcell_t phandle;\n\n\tprop = get_property(node, propname);\n\tif (!prop)\n\t\treturn 0;\n\n\tif (prop->val.len != sizeof(cell_t)) {\n\t\tFAIL_PROP(c, dti, node, prop, \"bad length (%d) %s property\",\n\t\t\t  prop->val.len, prop->name);\n\t\treturn 0;\n\t}\n\n\tm = prop->val.markers;\n\tfor_each_marker_of_type(m, REF_PHANDLE) {\n\t\tassert(m->offset == 0);\n\t\tif (node != get_node_by_ref(root, m->ref))\n\t\t\t  {\n\t\t\tFAIL(c, dti, node, \"%s is a reference to another node\",\n\t\t\t     prop->name);\n\t\t}\n\t\t \n\t\treturn 0;\n\t}\n\n\tphandle = propval_cell(prop);\n\n\tif (!phandle_is_valid(phandle)) {\n\t\tFAIL_PROP(c, dti, node, prop, \"bad value (0x%x) in %s property\",\n\t\t     phandle, prop->name);\n\t\treturn 0;\n\t}\n\n\treturn phandle;\n}\n\nstatic void check_explicit_phandles(struct check *c, struct dt_info *dti,\n\t\t\t\t    struct node *node)\n{\n\tstruct node *root = dti->dt;\n\tstruct node *other;\n\tcell_t phandle, linux_phandle;\n\n\t \n\tassert(!node->phandle);\n\n\tphandle = check_phandle_prop(c, dti, node, \"phandle\");\n\n\tlinux_phandle = check_phandle_prop(c, dti, node, \"linux,phandle\");\n\n\tif (!phandle && !linux_phandle)\n\t\t \n\t\treturn;\n\n\tif (linux_phandle && phandle && (phandle != linux_phandle))\n\t\tFAIL(c, dti, node, \"mismatching 'phandle' and 'linux,phandle'\"\n\t\t     \" properties\");\n\n\tif (linux_phandle && !phandle)\n\t\tphandle = linux_phandle;\n\n\tother = get_node_by_phandle(root, phandle);\n\tif (other && (other != node)) {\n\t\tFAIL(c, dti, node, \"duplicated phandle 0x%x (seen before at %s)\",\n\t\t     phandle, other->fullpath);\n\t\treturn;\n\t}\n\n\tnode->phandle = phandle;\n}\nERROR(explicit_phandles, check_explicit_phandles, NULL);\n\nstatic void check_name_properties(struct check *c, struct dt_info *dti,\n\t\t\t\t  struct node *node)\n{\n\tstruct property **pp, *prop = NULL;\n\n\tfor (pp = &node->proplist; *pp; pp = &((*pp)->next))\n\t\tif (streq((*pp)->name, \"name\")) {\n\t\t\tprop = *pp;\n\t\t\tbreak;\n\t\t}\n\n\tif (!prop)\n\t\treturn;  \n\n\tif ((prop->val.len != node->basenamelen + 1U)\n\t    || (memcmp(prop->val.val, node->name, node->basenamelen) != 0)) {\n\t\tFAIL(c, dti, node, \"\\\"name\\\" property is incorrect (\\\"%s\\\" instead\"\n\t\t     \" of base node name)\", prop->val.val);\n\t} else {\n\t\t \n\t\t*pp = prop->next;\n\t\tfree(prop->name);\n\t\tdata_free(prop->val);\n\t\tfree(prop);\n\t}\n}\nERROR_IF_NOT_STRING(name_is_string, \"name\");\nERROR(name_properties, check_name_properties, NULL, &name_is_string);\n\n \n\nstatic void fixup_phandle_references(struct check *c, struct dt_info *dti,\n\t\t\t\t     struct node *node)\n{\n\tstruct node *dt = dti->dt;\n\tstruct property *prop;\n\n\tfor_each_property(node, prop) {\n\t\tstruct marker *m = prop->val.markers;\n\t\tstruct node *refnode;\n\t\tcell_t phandle;\n\n\t\tfor_each_marker_of_type(m, REF_PHANDLE) {\n\t\t\tassert(m->offset + sizeof(cell_t) <= prop->val.len);\n\n\t\t\trefnode = get_node_by_ref(dt, m->ref);\n\t\t\tif (! refnode) {\n\t\t\t\tif (!(dti->dtsflags & DTSF_PLUGIN))\n\t\t\t\t\tFAIL(c, dti, node, \"Reference to non-existent node or \"\n\t\t\t\t\t\t\t\"label \\\"%s\\\"\\n\", m->ref);\n\t\t\t\telse  \n\t\t\t\t\t*((fdt32_t *)(prop->val.val + m->offset)) =\n\t\t\t\t\t\tcpu_to_fdt32(0xffffffff);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tphandle = get_node_phandle(dt, refnode);\n\t\t\t*((fdt32_t *)(prop->val.val + m->offset)) = cpu_to_fdt32(phandle);\n\n\t\t\treference_node(refnode);\n\t\t}\n\t}\n}\nERROR(phandle_references, fixup_phandle_references, NULL,\n      &duplicate_node_names, &explicit_phandles);\n\nstatic void fixup_path_references(struct check *c, struct dt_info *dti,\n\t\t\t\t  struct node *node)\n{\n\tstruct node *dt = dti->dt;\n\tstruct property *prop;\n\n\tfor_each_property(node, prop) {\n\t\tstruct marker *m = prop->val.markers;\n\t\tstruct node *refnode;\n\t\tchar *path;\n\n\t\tfor_each_marker_of_type(m, REF_PATH) {\n\t\t\tassert(m->offset <= prop->val.len);\n\n\t\t\trefnode = get_node_by_ref(dt, m->ref);\n\t\t\tif (!refnode) {\n\t\t\t\tFAIL(c, dti, node, \"Reference to non-existent node or label \\\"%s\\\"\\n\",\n\t\t\t\t     m->ref);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpath = refnode->fullpath;\n\t\t\tprop->val = data_insert_at_marker(prop->val, m, path,\n\t\t\t\t\t\t\t  strlen(path) + 1);\n\n\t\t\treference_node(refnode);\n\t\t}\n\t}\n}\nERROR(path_references, fixup_path_references, NULL, &duplicate_node_names);\n\nstatic void fixup_omit_unused_nodes(struct check *c, struct dt_info *dti,\n\t\t\t\t    struct node *node)\n{\n\tif (generate_symbols && node->labels)\n\t\treturn;\n\tif (node->omit_if_unused && !node->is_referenced)\n\t\tdelete_node(node);\n}\nERROR(omit_unused_nodes, fixup_omit_unused_nodes, NULL, &phandle_references, &path_references);\n\n \nWARNING_IF_NOT_CELL(address_cells_is_cell, \"#address-cells\");\nWARNING_IF_NOT_CELL(size_cells_is_cell, \"#size-cells\");\n\nWARNING_IF_NOT_STRING(device_type_is_string, \"device_type\");\nWARNING_IF_NOT_STRING(model_is_string, \"model\");\nWARNING_IF_NOT_STRING(status_is_string, \"status\");\nWARNING_IF_NOT_STRING(label_is_string, \"label\");\n\nWARNING_IF_NOT_STRING_LIST(compatible_is_string_list, \"compatible\");\n\nstatic void check_names_is_string_list(struct check *c, struct dt_info *dti,\n\t\t\t\t       struct node *node)\n{\n\tstruct property *prop;\n\n\tfor_each_property(node, prop) {\n\t\tif (!strends(prop->name, \"-names\"))\n\t\t\tcontinue;\n\n\t\tc->data = prop->name;\n\t\tcheck_is_string_list(c, dti, node);\n\t}\n}\nWARNING(names_is_string_list, check_names_is_string_list, NULL);\n\nstatic void check_alias_paths(struct check *c, struct dt_info *dti,\n\t\t\t\t    struct node *node)\n{\n\tstruct property *prop;\n\n\tif (!streq(node->name, \"aliases\"))\n\t\treturn;\n\n\tfor_each_property(node, prop) {\n\t\tif (streq(prop->name, \"phandle\")\n\t\t    || streq(prop->name, \"linux,phandle\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!prop->val.val || !get_node_by_path(dti->dt, prop->val.val)) {\n\t\t\tFAIL_PROP(c, dti, node, prop, \"aliases property is not a valid node (%s)\",\n\t\t\t\t  prop->val.val);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strspn(prop->name, LOWERCASE DIGITS \"-\") != strlen(prop->name))\n\t\t\tFAIL(c, dti, node, \"aliases property name must include only lowercase and '-'\");\n\t}\n}\nWARNING(alias_paths, check_alias_paths, NULL);\n\nstatic void fixup_addr_size_cells(struct check *c, struct dt_info *dti,\n\t\t\t\t  struct node *node)\n{\n\tstruct property *prop;\n\n\tnode->addr_cells = -1;\n\tnode->size_cells = -1;\n\n\tprop = get_property(node, \"#address-cells\");\n\tif (prop)\n\t\tnode->addr_cells = propval_cell(prop);\n\n\tprop = get_property(node, \"#size-cells\");\n\tif (prop)\n\t\tnode->size_cells = propval_cell(prop);\n}\nWARNING(addr_size_cells, fixup_addr_size_cells, NULL,\n\t&address_cells_is_cell, &size_cells_is_cell);\n\n#define node_addr_cells(n) \\\n\t(((n)->addr_cells == -1) ? 2 : (n)->addr_cells)\n#define node_size_cells(n) \\\n\t(((n)->size_cells == -1) ? 1 : (n)->size_cells)\n\nstatic void check_reg_format(struct check *c, struct dt_info *dti,\n\t\t\t     struct node *node)\n{\n\tstruct property *prop;\n\tint addr_cells, size_cells, entrylen;\n\n\tprop = get_property(node, \"reg\");\n\tif (!prop)\n\t\treturn;  \n\n\tif (!node->parent) {\n\t\tFAIL(c, dti, node, \"Root node has a \\\"reg\\\" property\");\n\t\treturn;\n\t}\n\n\tif (prop->val.len == 0)\n\t\tFAIL_PROP(c, dti, node, prop, \"property is empty\");\n\n\taddr_cells = node_addr_cells(node->parent);\n\tsize_cells = node_size_cells(node->parent);\n\tentrylen = (addr_cells + size_cells) * sizeof(cell_t);\n\n\tif (!is_multiple_of(prop->val.len, entrylen))\n\t\tFAIL_PROP(c, dti, node, prop, \"property has invalid length (%d bytes) \"\n\t\t\t  \"(#address-cells == %d, #size-cells == %d)\",\n\t\t\t  prop->val.len, addr_cells, size_cells);\n}\nWARNING(reg_format, check_reg_format, NULL, &addr_size_cells);\n\nstatic void check_ranges_format(struct check *c, struct dt_info *dti,\n\t\t\t\tstruct node *node)\n{\n\tstruct property *prop;\n\tint c_addr_cells, p_addr_cells, c_size_cells, p_size_cells, entrylen;\n\tconst char *ranges = c->data;\n\n\tprop = get_property(node, ranges);\n\tif (!prop)\n\t\treturn;\n\n\tif (!node->parent) {\n\t\tFAIL_PROP(c, dti, node, prop, \"Root node has a \\\"%s\\\" property\",\n\t\t\t  ranges);\n\t\treturn;\n\t}\n\n\tp_addr_cells = node_addr_cells(node->parent);\n\tp_size_cells = node_size_cells(node->parent);\n\tc_addr_cells = node_addr_cells(node);\n\tc_size_cells = node_size_cells(node);\n\tentrylen = (p_addr_cells + c_addr_cells + c_size_cells) * sizeof(cell_t);\n\n\tif (prop->val.len == 0) {\n\t\tif (p_addr_cells != c_addr_cells)\n\t\t\tFAIL_PROP(c, dti, node, prop, \"empty \\\"%s\\\" property but its \"\n\t\t\t\t  \"#address-cells (%d) differs from %s (%d)\",\n\t\t\t\t  ranges, c_addr_cells, node->parent->fullpath,\n\t\t\t\t  p_addr_cells);\n\t\tif (p_size_cells != c_size_cells)\n\t\t\tFAIL_PROP(c, dti, node, prop, \"empty \\\"%s\\\" property but its \"\n\t\t\t\t  \"#size-cells (%d) differs from %s (%d)\",\n\t\t\t\t  ranges, c_size_cells, node->parent->fullpath,\n\t\t\t\t  p_size_cells);\n\t} else if (!is_multiple_of(prop->val.len, entrylen)) {\n\t\tFAIL_PROP(c, dti, node, prop, \"\\\"%s\\\" property has invalid length (%d bytes) \"\n\t\t\t  \"(parent #address-cells == %d, child #address-cells == %d, \"\n\t\t\t  \"#size-cells == %d)\", ranges, prop->val.len,\n\t\t\t  p_addr_cells, c_addr_cells, c_size_cells);\n\t}\n}\nWARNING(ranges_format, check_ranges_format, \"ranges\", &addr_size_cells);\nWARNING(dma_ranges_format, check_ranges_format, \"dma-ranges\", &addr_size_cells);\n\nstatic const struct bus_type pci_bus = {\n\t.name = \"PCI\",\n};\n\nstatic void check_pci_bridge(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tstruct property *prop;\n\tcell_t *cells;\n\n\tprop = get_property(node, \"device_type\");\n\tif (!prop || !streq(prop->val.val, \"pci\"))\n\t\treturn;\n\n\tnode->bus = &pci_bus;\n\n\tif (!strprefixeq(node->name, node->basenamelen, \"pci\") &&\n\t    !strprefixeq(node->name, node->basenamelen, \"pcie\"))\n\t\tFAIL(c, dti, node, \"node name is not \\\"pci\\\" or \\\"pcie\\\"\");\n\n\tprop = get_property(node, \"ranges\");\n\tif (!prop)\n\t\tFAIL(c, dti, node, \"missing ranges for PCI bridge (or not a bridge)\");\n\n\tif (node_addr_cells(node) != 3)\n\t\tFAIL(c, dti, node, \"incorrect #address-cells for PCI bridge\");\n\tif (node_size_cells(node) != 2)\n\t\tFAIL(c, dti, node, \"incorrect #size-cells for PCI bridge\");\n\n\tprop = get_property(node, \"bus-range\");\n\tif (!prop)\n\t\treturn;\n\n\tif (prop->val.len != (sizeof(cell_t) * 2)) {\n\t\tFAIL_PROP(c, dti, node, prop, \"value must be 2 cells\");\n\t\treturn;\n\t}\n\tcells = (cell_t *)prop->val.val;\n\tif (fdt32_to_cpu(cells[0]) > fdt32_to_cpu(cells[1]))\n\t\tFAIL_PROP(c, dti, node, prop, \"1st cell must be less than or equal to 2nd cell\");\n\tif (fdt32_to_cpu(cells[1]) > 0xff)\n\t\tFAIL_PROP(c, dti, node, prop, \"maximum bus number must be less than 256\");\n}\nWARNING(pci_bridge, check_pci_bridge, NULL,\n\t&device_type_is_string, &addr_size_cells);\n\nstatic void check_pci_device_bus_num(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tstruct property *prop;\n\tunsigned int bus_num, min_bus, max_bus;\n\tcell_t *cells;\n\n\tif (!node->parent || (node->parent->bus != &pci_bus))\n\t\treturn;\n\n\tprop = get_property(node, \"reg\");\n\tif (!prop)\n\t\treturn;\n\n\tcells = (cell_t *)prop->val.val;\n\tbus_num = (fdt32_to_cpu(cells[0]) & 0x00ff0000) >> 16;\n\n\tprop = get_property(node->parent, \"bus-range\");\n\tif (!prop) {\n\t\tmin_bus = max_bus = 0;\n\t} else {\n\t\tcells = (cell_t *)prop->val.val;\n\t\tmin_bus = fdt32_to_cpu(cells[0]);\n\t\tmax_bus = fdt32_to_cpu(cells[1]);\n\t}\n\tif ((bus_num < min_bus) || (bus_num > max_bus))\n\t\tFAIL_PROP(c, dti, node, prop, \"PCI bus number %d out of range, expected (%d - %d)\",\n\t\t\t  bus_num, min_bus, max_bus);\n}\nWARNING(pci_device_bus_num, check_pci_device_bus_num, NULL, &reg_format, &pci_bridge);\n\nstatic void check_pci_device_reg(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tstruct property *prop;\n\tconst char *unitname = get_unitname(node);\n\tchar unit_addr[5];\n\tunsigned int dev, func, reg;\n\tcell_t *cells;\n\n\tif (!node->parent || (node->parent->bus != &pci_bus))\n\t\treturn;\n\n\tprop = get_property(node, \"reg\");\n\tif (!prop)\n\t\treturn;\n\n\tcells = (cell_t *)prop->val.val;\n\tif (cells[1] || cells[2])\n\t\tFAIL_PROP(c, dti, node, prop, \"PCI reg config space address cells 2 and 3 must be 0\");\n\n\treg = fdt32_to_cpu(cells[0]);\n\tdev = (reg & 0xf800) >> 11;\n\tfunc = (reg & 0x700) >> 8;\n\n\tif (reg & 0xff000000)\n\t\tFAIL_PROP(c, dti, node, prop, \"PCI reg address is not configuration space\");\n\tif (reg & 0x000000ff)\n\t\tFAIL_PROP(c, dti, node, prop, \"PCI reg config space address register number must be 0\");\n\n\tif (func == 0) {\n\t\tsnprintf(unit_addr, sizeof(unit_addr), \"%x\", dev);\n\t\tif (streq(unitname, unit_addr))\n\t\t\treturn;\n\t}\n\n\tsnprintf(unit_addr, sizeof(unit_addr), \"%x,%x\", dev, func);\n\tif (streq(unitname, unit_addr))\n\t\treturn;\n\n\tFAIL(c, dti, node, \"PCI unit address format error, expected \\\"%s\\\"\",\n\t     unit_addr);\n}\nWARNING(pci_device_reg, check_pci_device_reg, NULL, &reg_format, &pci_bridge);\n\nstatic const struct bus_type simple_bus = {\n\t.name = \"simple-bus\",\n};\n\nstatic bool node_is_compatible(struct node *node, const char *compat)\n{\n\tstruct property *prop;\n\tconst char *str, *end;\n\n\tprop = get_property(node, \"compatible\");\n\tif (!prop)\n\t\treturn false;\n\n\tfor (str = prop->val.val, end = str + prop->val.len; str < end;\n\t     str += strnlen(str, end - str) + 1) {\n\t\tif (streq(str, compat))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void check_simple_bus_bridge(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tif (node_is_compatible(node, \"simple-bus\"))\n\t\tnode->bus = &simple_bus;\n}\nWARNING(simple_bus_bridge, check_simple_bus_bridge, NULL,\n\t&addr_size_cells, &compatible_is_string_list);\n\nstatic void check_simple_bus_reg(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tstruct property *prop;\n\tconst char *unitname = get_unitname(node);\n\tchar unit_addr[17];\n\tunsigned int size;\n\tuint64_t reg = 0;\n\tcell_t *cells = NULL;\n\n\tif (!node->parent || (node->parent->bus != &simple_bus))\n\t\treturn;\n\n\tprop = get_property(node, \"reg\");\n\tif (prop)\n\t\tcells = (cell_t *)prop->val.val;\n\telse {\n\t\tprop = get_property(node, \"ranges\");\n\t\tif (prop && prop->val.len)\n\t\t\t \n\t\t\tcells = ((cell_t *)prop->val.val) + node_addr_cells(node);\n\t}\n\n\tif (!cells) {\n\t\tif (node->parent->parent && !(node->bus == &simple_bus))\n\t\t\tFAIL(c, dti, node, \"missing or empty reg/ranges property\");\n\t\treturn;\n\t}\n\n\tsize = node_addr_cells(node->parent);\n\twhile (size--)\n\t\treg = (reg << 32) | fdt32_to_cpu(*(cells++));\n\n\tsnprintf(unit_addr, sizeof(unit_addr), \"%\"PRIx64, reg);\n\tif (!streq(unitname, unit_addr))\n\t\tFAIL(c, dti, node, \"simple-bus unit address format error, expected \\\"%s\\\"\",\n\t\t     unit_addr);\n}\nWARNING(simple_bus_reg, check_simple_bus_reg, NULL, &reg_format, &simple_bus_bridge);\n\nstatic const struct bus_type i2c_bus = {\n\t.name = \"i2c-bus\",\n};\n\nstatic void check_i2c_bus_bridge(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tif (strprefixeq(node->name, node->basenamelen, \"i2c-bus\") ||\n\t    strprefixeq(node->name, node->basenamelen, \"i2c-arb\")) {\n\t\tnode->bus = &i2c_bus;\n\t} else if (strprefixeq(node->name, node->basenamelen, \"i2c\")) {\n\t\tstruct node *child;\n\t\tfor_each_child(node, child) {\n\t\t\tif (strprefixeq(child->name, node->basenamelen, \"i2c-bus\"))\n\t\t\t\treturn;\n\t\t}\n\t\tnode->bus = &i2c_bus;\n\t} else\n\t\treturn;\n\n\tif (!node->children)\n\t\treturn;\n\n\tif (node_addr_cells(node) != 1)\n\t\tFAIL(c, dti, node, \"incorrect #address-cells for I2C bus\");\n\tif (node_size_cells(node) != 0)\n\t\tFAIL(c, dti, node, \"incorrect #size-cells for I2C bus\");\n\n}\nWARNING(i2c_bus_bridge, check_i2c_bus_bridge, NULL, &addr_size_cells);\n\n#define I2C_OWN_SLAVE_ADDRESS\t(1U << 30)\n#define I2C_TEN_BIT_ADDRESS\t(1U << 31)\n\nstatic void check_i2c_bus_reg(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tstruct property *prop;\n\tconst char *unitname = get_unitname(node);\n\tchar unit_addr[17];\n\tuint32_t reg = 0;\n\tint len;\n\tcell_t *cells = NULL;\n\n\tif (!node->parent || (node->parent->bus != &i2c_bus))\n\t\treturn;\n\n\tprop = get_property(node, \"reg\");\n\tif (prop)\n\t\tcells = (cell_t *)prop->val.val;\n\n\tif (!cells) {\n\t\tFAIL(c, dti, node, \"missing or empty reg property\");\n\t\treturn;\n\t}\n\n\treg = fdt32_to_cpu(*cells);\n\t \n\treg &= ~I2C_OWN_SLAVE_ADDRESS;\n\tsnprintf(unit_addr, sizeof(unit_addr), \"%x\", reg);\n\tif (!streq(unitname, unit_addr))\n\t\tFAIL(c, dti, node, \"I2C bus unit address format error, expected \\\"%s\\\"\",\n\t\t     unit_addr);\n\n\tfor (len = prop->val.len; len > 0; len -= 4) {\n\t\treg = fdt32_to_cpu(*(cells++));\n\t\t \n\t\treg &= ~I2C_OWN_SLAVE_ADDRESS;\n\n\t\tif ((reg & I2C_TEN_BIT_ADDRESS) && ((reg & ~I2C_TEN_BIT_ADDRESS) > 0x3ff))\n\t\t\tFAIL_PROP(c, dti, node, prop, \"I2C address must be less than 10-bits, got \\\"0x%x\\\"\",\n\t\t\t\t  reg);\n\t\telse if (reg > 0x7f)\n\t\t\tFAIL_PROP(c, dti, node, prop, \"I2C address must be less than 7-bits, got \\\"0x%x\\\". Set I2C_TEN_BIT_ADDRESS for 10 bit addresses or fix the property\",\n\t\t\t\t  reg);\n\t}\n}\nWARNING(i2c_bus_reg, check_i2c_bus_reg, NULL, &reg_format, &i2c_bus_bridge);\n\nstatic const struct bus_type spi_bus = {\n\t.name = \"spi-bus\",\n};\n\nstatic void check_spi_bus_bridge(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tint spi_addr_cells = 1;\n\n\tif (strprefixeq(node->name, node->basenamelen, \"spi\")) {\n\t\tnode->bus = &spi_bus;\n\t} else {\n\t\t \n\t\tstruct node *child;\n\n\t\tif (node_addr_cells(node) != 1 || node_size_cells(node) != 0)\n\t\t\treturn;\n\n\t\tfor_each_child(node, child) {\n\t\t\tstruct property *prop;\n\t\t\tfor_each_property(child, prop) {\n\t\t\t\tif (strprefixeq(prop->name, 4, \"spi-\")) {\n\t\t\t\t\tnode->bus = &spi_bus;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node->bus == &spi_bus)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (node->bus == &spi_bus && get_property(node, \"reg\"))\n\t\t\tFAIL(c, dti, node, \"node name for SPI buses should be 'spi'\");\n\t}\n\tif (node->bus != &spi_bus || !node->children)\n\t\treturn;\n\n\tif (get_property(node, \"spi-slave\"))\n\t\tspi_addr_cells = 0;\n\tif (node_addr_cells(node) != spi_addr_cells)\n\t\tFAIL(c, dti, node, \"incorrect #address-cells for SPI bus\");\n\tif (node_size_cells(node) != 0)\n\t\tFAIL(c, dti, node, \"incorrect #size-cells for SPI bus\");\n\n}\nWARNING(spi_bus_bridge, check_spi_bus_bridge, NULL, &addr_size_cells);\n\nstatic void check_spi_bus_reg(struct check *c, struct dt_info *dti, struct node *node)\n{\n\tstruct property *prop;\n\tconst char *unitname = get_unitname(node);\n\tchar unit_addr[9];\n\tuint32_t reg = 0;\n\tcell_t *cells = NULL;\n\n\tif (!node->parent || (node->parent->bus != &spi_bus))\n\t\treturn;\n\n\tif (get_property(node->parent, \"spi-slave\"))\n\t\treturn;\n\n\tprop = get_property(node, \"reg\");\n\tif (prop)\n\t\tcells = (cell_t *)prop->val.val;\n\n\tif (!cells) {\n\t\tFAIL(c, dti, node, \"missing or empty reg property\");\n\t\treturn;\n\t}\n\n\treg = fdt32_to_cpu(*cells);\n\tsnprintf(unit_addr, sizeof(unit_addr), \"%x\", reg);\n\tif (!streq(unitname, unit_addr))\n\t\tFAIL(c, dti, node, \"SPI bus unit address format error, expected \\\"%s\\\"\",\n\t\t     unit_addr);\n}\nWARNING(spi_bus_reg, check_spi_bus_reg, NULL, &reg_format, &spi_bus_bridge);\n\nstatic void check_unit_address_format(struct check *c, struct dt_info *dti,\n\t\t\t\t      struct node *node)\n{\n\tconst char *unitname = get_unitname(node);\n\n\tif (node->parent && node->parent->bus)\n\t\treturn;\n\n\tif (!unitname[0])\n\t\treturn;\n\n\tif (!strncmp(unitname, \"0x\", 2)) {\n\t\tFAIL(c, dti, node, \"unit name should not have leading \\\"0x\\\"\");\n\t\t \n\t\tunitname += 2;\n\t}\n\tif (unitname[0] == '0' && isxdigit(unitname[1]))\n\t\tFAIL(c, dti, node, \"unit name should not have leading 0s\");\n}\nWARNING(unit_address_format, check_unit_address_format, NULL,\n\t&node_name_format, &pci_bridge, &simple_bus_bridge);\n\n \nstatic void check_avoid_default_addr_size(struct check *c, struct dt_info *dti,\n\t\t\t\t\t  struct node *node)\n{\n\tstruct property *reg, *ranges;\n\n\tif (!node->parent)\n\t\treturn;  \n\n\treg = get_property(node, \"reg\");\n\tranges = get_property(node, \"ranges\");\n\n\tif (!reg && !ranges)\n\t\treturn;\n\n\tif (node->parent->addr_cells == -1)\n\t\tFAIL(c, dti, node, \"Relying on default #address-cells value\");\n\n\tif (node->parent->size_cells == -1)\n\t\tFAIL(c, dti, node, \"Relying on default #size-cells value\");\n}\nWARNING(avoid_default_addr_size, check_avoid_default_addr_size, NULL,\n\t&addr_size_cells);\n\nstatic void check_avoid_unnecessary_addr_size(struct check *c, struct dt_info *dti,\n\t\t\t\t\t      struct node *node)\n{\n\tstruct property *prop;\n\tstruct node *child;\n\tbool has_reg = false;\n\n\tif (!node->parent || node->addr_cells < 0 || node->size_cells < 0)\n\t\treturn;\n\n\tif (get_property(node, \"ranges\") || !node->children)\n\t\treturn;\n\n\tfor_each_child(node, child) {\n\t\tprop = get_property(child, \"reg\");\n\t\tif (prop)\n\t\t\thas_reg = true;\n\t}\n\n\tif (!has_reg)\n\t\tFAIL(c, dti, node, \"unnecessary #address-cells/#size-cells without \\\"ranges\\\" or child \\\"reg\\\" property\");\n}\nWARNING(avoid_unnecessary_addr_size, check_avoid_unnecessary_addr_size, NULL, &avoid_default_addr_size);\n\nstatic bool node_is_disabled(struct node *node)\n{\n\tstruct property *prop;\n\n\tprop = get_property(node, \"status\");\n\tif (prop) {\n\t\tchar *str = prop->val.val;\n\t\tif (streq(\"disabled\", str))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void check_unique_unit_address_common(struct check *c,\n\t\t\t\t\t\tstruct dt_info *dti,\n\t\t\t\t\t\tstruct node *node,\n\t\t\t\t\t\tbool disable_check)\n{\n\tstruct node *childa;\n\n\tif (node->addr_cells < 0 || node->size_cells < 0)\n\t\treturn;\n\n\tif (!node->children)\n\t\treturn;\n\n\tfor_each_child(node, childa) {\n\t\tstruct node *childb;\n\t\tconst char *addr_a = get_unitname(childa);\n\n\t\tif (!strlen(addr_a))\n\t\t\tcontinue;\n\n\t\tif (disable_check && node_is_disabled(childa))\n\t\t\tcontinue;\n\n\t\tfor_each_child(node, childb) {\n\t\t\tconst char *addr_b = get_unitname(childb);\n\t\t\tif (childa == childb)\n\t\t\t\tbreak;\n\n\t\t\tif (disable_check && node_is_disabled(childb))\n\t\t\t\tcontinue;\n\n\t\t\tif (streq(addr_a, addr_b))\n\t\t\t\tFAIL(c, dti, childb, \"duplicate unit-address (also used in node %s)\", childa->fullpath);\n\t\t}\n\t}\n}\n\nstatic void check_unique_unit_address(struct check *c, struct dt_info *dti,\n\t\t\t\t\t      struct node *node)\n{\n\tcheck_unique_unit_address_common(c, dti, node, false);\n}\nWARNING(unique_unit_address, check_unique_unit_address, NULL, &avoid_default_addr_size);\n\nstatic void check_unique_unit_address_if_enabled(struct check *c, struct dt_info *dti,\n\t\t\t\t\t      struct node *node)\n{\n\tcheck_unique_unit_address_common(c, dti, node, true);\n}\nCHECK_ENTRY(unique_unit_address_if_enabled, check_unique_unit_address_if_enabled,\n\t    NULL, false, false, &avoid_default_addr_size);\n\nstatic void check_obsolete_chosen_interrupt_controller(struct check *c,\n\t\t\t\t\t\t       struct dt_info *dti,\n\t\t\t\t\t\t       struct node *node)\n{\n\tstruct node *dt = dti->dt;\n\tstruct node *chosen;\n\tstruct property *prop;\n\n\tif (node != dt)\n\t\treturn;\n\n\n\tchosen = get_node_by_path(dt, \"/chosen\");\n\tif (!chosen)\n\t\treturn;\n\n\tprop = get_property(chosen, \"interrupt-controller\");\n\tif (prop)\n\t\tFAIL_PROP(c, dti, node, prop,\n\t\t\t  \"/chosen has obsolete \\\"interrupt-controller\\\" property\");\n}\nWARNING(obsolete_chosen_interrupt_controller,\n\tcheck_obsolete_chosen_interrupt_controller, NULL);\n\nstatic void check_chosen_node_is_root(struct check *c, struct dt_info *dti,\n\t\t\t\t      struct node *node)\n{\n\tif (!streq(node->name, \"chosen\"))\n\t\treturn;\n\n\tif (node->parent != dti->dt)\n\t\tFAIL(c, dti, node, \"chosen node must be at root node\");\n}\nWARNING(chosen_node_is_root, check_chosen_node_is_root, NULL);\n\nstatic void check_chosen_node_bootargs(struct check *c, struct dt_info *dti,\n\t\t\t\t       struct node *node)\n{\n\tstruct property *prop;\n\n\tif (!streq(node->name, \"chosen\"))\n\t\treturn;\n\n\tprop = get_property(node, \"bootargs\");\n\tif (!prop)\n\t\treturn;\n\n\tc->data = prop->name;\n\tcheck_is_string(c, dti, node);\n}\nWARNING(chosen_node_bootargs, check_chosen_node_bootargs, NULL);\n\nstatic void check_chosen_node_stdout_path(struct check *c, struct dt_info *dti,\n\t\t\t\t\t  struct node *node)\n{\n\tstruct property *prop;\n\n\tif (!streq(node->name, \"chosen\"))\n\t\treturn;\n\n\tprop = get_property(node, \"stdout-path\");\n\tif (!prop) {\n\t\tprop = get_property(node, \"linux,stdout-path\");\n\t\tif (!prop)\n\t\t\treturn;\n\t\tFAIL_PROP(c, dti, node, prop, \"Use 'stdout-path' instead\");\n\t}\n\n\tc->data = prop->name;\n\tcheck_is_string(c, dti, node);\n}\nWARNING(chosen_node_stdout_path, check_chosen_node_stdout_path, NULL);\n\nstruct provider {\n\tconst char *prop_name;\n\tconst char *cell_name;\n\tbool optional;\n};\n\nstatic void check_property_phandle_args(struct check *c,\n\t\t\t\t\tstruct dt_info *dti,\n\t\t\t\t\tstruct node *node,\n\t\t\t\t\tstruct property *prop,\n\t\t\t\t\tconst struct provider *provider)\n{\n\tstruct node *root = dti->dt;\n\tunsigned int cell, cellsize = 0;\n\n\tif (!is_multiple_of(prop->val.len, sizeof(cell_t))) {\n\t\tFAIL_PROP(c, dti, node, prop,\n\t\t\t  \"property size (%d) is invalid, expected multiple of %zu\",\n\t\t\t  prop->val.len, sizeof(cell_t));\n\t\treturn;\n\t}\n\n\tfor (cell = 0; cell < prop->val.len / sizeof(cell_t); cell += cellsize + 1) {\n\t\tstruct node *provider_node;\n\t\tstruct property *cellprop;\n\t\tcell_t phandle;\n\t\tunsigned int expected;\n\n\t\tphandle = propval_cell_n(prop, cell);\n\t\t \n\t\tif (!phandle_is_valid(phandle)) {\n\t\t\t \n\t\t\tif (dti->dtsflags & DTSF_PLUGIN)\n\t\t\t\tbreak;\n\n\t\t\tcellsize = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (prop->val.markers) {\n\t\t\tstruct marker *m = prop->val.markers;\n\t\t\tfor_each_marker_of_type(m, REF_PHANDLE) {\n\t\t\t\tif (m->offset == (cell * sizeof(cell_t)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!m)\n\t\t\t\tFAIL_PROP(c, dti, node, prop,\n\t\t\t\t\t  \"cell %d is not a phandle reference\",\n\t\t\t\t\t  cell);\n\t\t}\n\n\t\tprovider_node = get_node_by_phandle(root, phandle);\n\t\tif (!provider_node) {\n\t\t\tFAIL_PROP(c, dti, node, prop,\n\t\t\t\t  \"Could not get phandle node for (cell %d)\",\n\t\t\t\t  cell);\n\t\t\tbreak;\n\t\t}\n\n\t\tcellprop = get_property(provider_node, provider->cell_name);\n\t\tif (cellprop) {\n\t\t\tcellsize = propval_cell(cellprop);\n\t\t} else if (provider->optional) {\n\t\t\tcellsize = 0;\n\t\t} else {\n\t\t\tFAIL(c, dti, node, \"Missing property '%s' in node %s or bad phandle (referred from %s[%d])\",\n\t\t\t     provider->cell_name,\n\t\t\t     provider_node->fullpath,\n\t\t\t     prop->name, cell);\n\t\t\tbreak;\n\t\t}\n\n\t\texpected = (cell + cellsize + 1) * sizeof(cell_t);\n\t\tif ((expected <= cell) || prop->val.len < expected) {\n\t\t\tFAIL_PROP(c, dti, node, prop,\n\t\t\t\t  \"property size (%d) too small for cell size %u\",\n\t\t\t\t  prop->val.len, cellsize);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void check_provider_cells_property(struct check *c,\n\t\t\t\t\t  struct dt_info *dti,\n\t\t\t\t          struct node *node)\n{\n\tstruct provider *provider = c->data;\n\tstruct property *prop;\n\n\tprop = get_property(node, provider->prop_name);\n\tif (!prop)\n\t\treturn;\n\n\tcheck_property_phandle_args(c, dti, node, prop, provider);\n}\n#define WARNING_PROPERTY_PHANDLE_CELLS(nm, propname, cells_name, ...) \\\n\tstatic struct provider nm##_provider = { (propname), (cells_name), __VA_ARGS__ }; \\\n\tWARNING_IF_NOT_CELL(nm##_is_cell, cells_name); \\\n\tWARNING(nm##_property, check_provider_cells_property, &nm##_provider, &nm##_is_cell, &phandle_references);\n\nWARNING_PROPERTY_PHANDLE_CELLS(clocks, \"clocks\", \"#clock-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(cooling_device, \"cooling-device\", \"#cooling-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(dmas, \"dmas\", \"#dma-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(hwlocks, \"hwlocks\", \"#hwlock-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(interrupts_extended, \"interrupts-extended\", \"#interrupt-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(io_channels, \"io-channels\", \"#io-channel-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(iommus, \"iommus\", \"#iommu-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(mboxes, \"mboxes\", \"#mbox-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(msi_parent, \"msi-parent\", \"#msi-cells\", true);\nWARNING_PROPERTY_PHANDLE_CELLS(mux_controls, \"mux-controls\", \"#mux-control-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(phys, \"phys\", \"#phy-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(power_domains, \"power-domains\", \"#power-domain-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(pwms, \"pwms\", \"#pwm-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(resets, \"resets\", \"#reset-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(sound_dai, \"sound-dai\", \"#sound-dai-cells\");\nWARNING_PROPERTY_PHANDLE_CELLS(thermal_sensors, \"thermal-sensors\", \"#thermal-sensor-cells\");\n\nstatic bool prop_is_gpio(struct property *prop)\n{\n\t \n\tif (strends(prop->name, \",nr-gpios\"))\n\t\treturn false;\n\n\treturn strends(prop->name, \"-gpios\") ||\n\t\tstreq(prop->name, \"gpios\") ||\n\t\tstrends(prop->name, \"-gpio\") ||\n\t\tstreq(prop->name, \"gpio\");\n}\n\nstatic void check_gpios_property(struct check *c,\n\t\t\t\t\t  struct dt_info *dti,\n\t\t\t\t          struct node *node)\n{\n\tstruct property *prop;\n\n\t \n\tif (get_property(node, \"gpio-hog\"))\n\t\treturn;\n\n\tfor_each_property(node, prop) {\n\t\tstruct provider provider;\n\n\t\tif (!prop_is_gpio(prop))\n\t\t\tcontinue;\n\n\t\tprovider.prop_name = prop->name;\n\t\tprovider.cell_name = \"#gpio-cells\";\n\t\tprovider.optional = false;\n\t\tcheck_property_phandle_args(c, dti, node, prop, &provider);\n\t}\n\n}\nWARNING(gpios_property, check_gpios_property, NULL, &phandle_references);\n\nstatic void check_deprecated_gpio_property(struct check *c,\n\t\t\t\t\t   struct dt_info *dti,\n\t\t\t\t           struct node *node)\n{\n\tstruct property *prop;\n\n\tfor_each_property(node, prop) {\n\t\tif (!prop_is_gpio(prop))\n\t\t\tcontinue;\n\n\t\tif (!strends(prop->name, \"gpio\"))\n\t\t\tcontinue;\n\n\t\tFAIL_PROP(c, dti, node, prop,\n\t\t\t  \"'[*-]gpio' is deprecated, use '[*-]gpios' instead\");\n\t}\n\n}\nCHECK(deprecated_gpio_property, check_deprecated_gpio_property, NULL);\n\nstatic bool node_is_interrupt_provider(struct node *node)\n{\n\tstruct property *prop;\n\n\tprop = get_property(node, \"interrupt-controller\");\n\tif (prop)\n\t\treturn true;\n\n\tprop = get_property(node, \"interrupt-map\");\n\tif (prop)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void check_interrupt_provider(struct check *c,\n\t\t\t\t     struct dt_info *dti,\n\t\t\t\t     struct node *node)\n{\n\tstruct property *prop;\n\tbool irq_provider = node_is_interrupt_provider(node);\n\n\tprop = get_property(node, \"#interrupt-cells\");\n\tif (irq_provider && !prop) {\n\t\tFAIL(c, dti, node,\n\t\t     \"Missing '#interrupt-cells' in interrupt provider\");\n\t\treturn;\n\t}\n\n\tif (!irq_provider && prop) {\n\t\tFAIL(c, dti, node,\n\t\t     \"'#interrupt-cells' found, but node is not an interrupt provider\");\n\t\treturn;\n\t}\n}\nWARNING(interrupt_provider, check_interrupt_provider, NULL, &interrupts_extended_is_cell);\n\nstatic void check_interrupt_map(struct check *c,\n\t\t\t\tstruct dt_info *dti,\n\t\t\t\tstruct node *node)\n{\n\tstruct node *root = dti->dt;\n\tstruct property *prop, *irq_map_prop;\n\tsize_t cellsize, cell, map_cells;\n\n\tirq_map_prop = get_property(node, \"interrupt-map\");\n\tif (!irq_map_prop)\n\t\treturn;\n\n\tif (node->addr_cells < 0) {\n\t\tFAIL(c, dti, node,\n\t\t     \"Missing '#address-cells' in interrupt-map provider\");\n\t\treturn;\n\t}\n\tcellsize = node_addr_cells(node);\n\tcellsize += propval_cell(get_property(node, \"#interrupt-cells\"));\n\n\tprop = get_property(node, \"interrupt-map-mask\");\n\tif (prop && (prop->val.len != (cellsize * sizeof(cell_t))))\n\t\tFAIL_PROP(c, dti, node, prop,\n\t\t\t  \"property size (%d) is invalid, expected %zu\",\n\t\t\t  prop->val.len, cellsize * sizeof(cell_t));\n\n\tif (!is_multiple_of(irq_map_prop->val.len, sizeof(cell_t))) {\n\t\tFAIL_PROP(c, dti, node, irq_map_prop,\n\t\t\t  \"property size (%d) is invalid, expected multiple of %zu\",\n\t\t\t  irq_map_prop->val.len, sizeof(cell_t));\n\t\treturn;\n\t}\n\n\tmap_cells = irq_map_prop->val.len / sizeof(cell_t);\n\tfor (cell = 0; cell < map_cells; ) {\n\t\tstruct node *provider_node;\n\t\tstruct property *cellprop;\n\t\tint phandle;\n\t\tsize_t parent_cellsize;\n\n\t\tif ((cell + cellsize) >= map_cells) {\n\t\t\tFAIL_PROP(c, dti, node, irq_map_prop,\n\t\t\t\t  \"property size (%d) too small, expected > %zu\",\n\t\t\t\t  irq_map_prop->val.len, (cell + cellsize) * sizeof(cell_t));\n\t\t\tbreak;\n\t\t}\n\t\tcell += cellsize;\n\n\t\tphandle = propval_cell_n(irq_map_prop, cell);\n\t\tif (!phandle_is_valid(phandle)) {\n\t\t\t \n\t\t\tif (!(dti->dtsflags & DTSF_PLUGIN))\n\t\t\t\tFAIL_PROP(c, dti, node, irq_map_prop,\n\t\t\t\t\t  \"Cell %zu is not a phandle(%d)\",\n\t\t\t\t\t  cell, phandle);\n\t\t\tbreak;\n\t\t}\n\n\t\tprovider_node = get_node_by_phandle(root, phandle);\n\t\tif (!provider_node) {\n\t\t\tFAIL_PROP(c, dti, node, irq_map_prop,\n\t\t\t\t  \"Could not get phandle(%d) node for (cell %zu)\",\n\t\t\t\t  phandle, cell);\n\t\t\tbreak;\n\t\t}\n\n\t\tcellprop = get_property(provider_node, \"#interrupt-cells\");\n\t\tif (cellprop) {\n\t\t\tparent_cellsize = propval_cell(cellprop);\n\t\t} else {\n\t\t\tFAIL(c, dti, node, \"Missing property '#interrupt-cells' in node %s or bad phandle (referred from interrupt-map[%zu])\",\n\t\t\t     provider_node->fullpath, cell);\n\t\t\tbreak;\n\t\t}\n\n\t\tcellprop = get_property(provider_node, \"#address-cells\");\n\t\tif (cellprop)\n\t\t\tparent_cellsize += propval_cell(cellprop);\n\n\t\tcell += 1 + parent_cellsize;\n\t}\n}\nWARNING(interrupt_map, check_interrupt_map, NULL, &phandle_references, &addr_size_cells, &interrupt_provider);\n\nstatic void check_interrupts_property(struct check *c,\n\t\t\t\t      struct dt_info *dti,\n\t\t\t\t      struct node *node)\n{\n\tstruct node *root = dti->dt;\n\tstruct node *irq_node = NULL, *parent = node;\n\tstruct property *irq_prop, *prop = NULL;\n\tcell_t irq_cells, phandle;\n\n\tirq_prop = get_property(node, \"interrupts\");\n\tif (!irq_prop)\n\t\treturn;\n\n\tif (!is_multiple_of(irq_prop->val.len, sizeof(cell_t)))\n\t\tFAIL_PROP(c, dti, node, irq_prop, \"size (%d) is invalid, expected multiple of %zu\",\n\t\t     irq_prop->val.len, sizeof(cell_t));\n\n\twhile (parent && !prop) {\n\t\tif (parent != node && node_is_interrupt_provider(parent)) {\n\t\t\tirq_node = parent;\n\t\t\tbreak;\n\t\t}\n\n\t\tprop = get_property(parent, \"interrupt-parent\");\n\t\tif (prop) {\n\t\t\tphandle = propval_cell(prop);\n\t\t\tif (!phandle_is_valid(phandle)) {\n\t\t\t\t \n\t\t\t\tif (dti->dtsflags & DTSF_PLUGIN)\n\t\t\t\t\treturn;\n\t\t\t\tFAIL_PROP(c, dti, parent, prop, \"Invalid phandle\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tirq_node = get_node_by_phandle(root, phandle);\n\t\t\tif (!irq_node) {\n\t\t\t\tFAIL_PROP(c, dti, parent, prop, \"Bad phandle\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!node_is_interrupt_provider(irq_node))\n\t\t\t\tFAIL(c, dti, irq_node,\n\t\t\t\t     \"Missing interrupt-controller or interrupt-map property\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tparent = parent->parent;\n\t}\n\n\tif (!irq_node) {\n\t\tFAIL(c, dti, node, \"Missing interrupt-parent\");\n\t\treturn;\n\t}\n\n\tprop = get_property(irq_node, \"#interrupt-cells\");\n\tif (!prop) {\n\t\t \n\t\treturn;\n\t}\n\n\tirq_cells = propval_cell(prop);\n\tif (!is_multiple_of(irq_prop->val.len, irq_cells * sizeof(cell_t))) {\n\t\tFAIL_PROP(c, dti, node, prop,\n\t\t\t  \"size is (%d), expected multiple of %d\",\n\t\t\t  irq_prop->val.len, (int)(irq_cells * sizeof(cell_t)));\n\t}\n}\nWARNING(interrupts_property, check_interrupts_property, &phandle_references);\n\nstatic const struct bus_type graph_port_bus = {\n\t.name = \"graph-port\",\n};\n\nstatic const struct bus_type graph_ports_bus = {\n\t.name = \"graph-ports\",\n};\n\nstatic void check_graph_nodes(struct check *c, struct dt_info *dti,\n\t\t\t      struct node *node)\n{\n\tstruct node *child;\n\n\tfor_each_child(node, child) {\n\t\tif (!(strprefixeq(child->name, child->basenamelen, \"endpoint\") ||\n\t\t      get_property(child, \"remote-endpoint\")))\n\t\t\tcontinue;\n\n\t\tnode->bus = &graph_port_bus;\n\n\t\t \n\t\tif (!node->parent->bus &&\n\t\t    (streq(node->parent->name, \"ports\") || get_property(node, \"reg\")))\n\t\t\tnode->parent->bus = &graph_ports_bus;\n\n\t\tbreak;\n\t}\n\n}\nWARNING(graph_nodes, check_graph_nodes, NULL);\n\nstatic void check_graph_child_address(struct check *c, struct dt_info *dti,\n\t\t\t\t      struct node *node)\n{\n\tint cnt = 0;\n\tstruct node *child;\n\n\tif (node->bus != &graph_ports_bus && node->bus != &graph_port_bus)\n\t\treturn;\n\n\tfor_each_child(node, child) {\n\t\tstruct property *prop = get_property(child, \"reg\");\n\n\t\t \n\t\tif (prop && propval_cell(prop) != 0)\n\t\t\treturn;\n\n\t\tcnt++;\n\t}\n\n\tif (cnt == 1 && node->addr_cells != -1)\n\t\tFAIL(c, dti, node, \"graph node has single child node '%s', #address-cells/#size-cells are not necessary\",\n\t\t     node->children->name);\n}\nWARNING(graph_child_address, check_graph_child_address, NULL, &graph_nodes);\n\nstatic void check_graph_reg(struct check *c, struct dt_info *dti,\n\t\t\t    struct node *node)\n{\n\tchar unit_addr[9];\n\tconst char *unitname = get_unitname(node);\n\tstruct property *prop;\n\n\tprop = get_property(node, \"reg\");\n\tif (!prop || !unitname)\n\t\treturn;\n\n\tif (!(prop->val.val && prop->val.len == sizeof(cell_t))) {\n\t\tFAIL(c, dti, node, \"graph node malformed 'reg' property\");\n\t\treturn;\n\t}\n\n\tsnprintf(unit_addr, sizeof(unit_addr), \"%x\", propval_cell(prop));\n\tif (!streq(unitname, unit_addr))\n\t\tFAIL(c, dti, node, \"graph node unit address error, expected \\\"%s\\\"\",\n\t\t     unit_addr);\n\n\tif (node->parent->addr_cells != 1)\n\t\tFAIL_PROP(c, dti, node, get_property(node, \"#address-cells\"),\n\t\t\t  \"graph node '#address-cells' is %d, must be 1\",\n\t\t\t  node->parent->addr_cells);\n\tif (node->parent->size_cells != 0)\n\t\tFAIL_PROP(c, dti, node, get_property(node, \"#size-cells\"),\n\t\t\t  \"graph node '#size-cells' is %d, must be 0\",\n\t\t\t  node->parent->size_cells);\n}\n\nstatic void check_graph_port(struct check *c, struct dt_info *dti,\n\t\t\t     struct node *node)\n{\n\tif (node->bus != &graph_port_bus)\n\t\treturn;\n\n\tif (!strprefixeq(node->name, node->basenamelen, \"port\"))\n\t\tFAIL(c, dti, node, \"graph port node name should be 'port'\");\n\n\tcheck_graph_reg(c, dti, node);\n}\nWARNING(graph_port, check_graph_port, NULL, &graph_nodes);\n\nstatic struct node *get_remote_endpoint(struct check *c, struct dt_info *dti,\n\t\t\t\t\tstruct node *endpoint)\n{\n\tcell_t phandle;\n\tstruct node *node;\n\tstruct property *prop;\n\n\tprop = get_property(endpoint, \"remote-endpoint\");\n\tif (!prop)\n\t\treturn NULL;\n\n\tphandle = propval_cell(prop);\n\t \n\tif (!phandle_is_valid(phandle))\n\t\treturn NULL;\n\n\tnode = get_node_by_phandle(dti->dt, phandle);\n\tif (!node)\n\t\tFAIL_PROP(c, dti, endpoint, prop, \"graph phandle is not valid\");\n\n\treturn node;\n}\n\nstatic void check_graph_endpoint(struct check *c, struct dt_info *dti,\n\t\t\t\t struct node *node)\n{\n\tstruct node *remote_node;\n\n\tif (!node->parent || node->parent->bus != &graph_port_bus)\n\t\treturn;\n\n\tif (!strprefixeq(node->name, node->basenamelen, \"endpoint\"))\n\t\tFAIL(c, dti, node, \"graph endpoint node name should be 'endpoint'\");\n\n\tcheck_graph_reg(c, dti, node);\n\n\tremote_node = get_remote_endpoint(c, dti, node);\n\tif (!remote_node)\n\t\treturn;\n\n\tif (get_remote_endpoint(c, dti, remote_node) != node)\n\t\tFAIL(c, dti, node, \"graph connection to node '%s' is not bidirectional\",\n\t\t     remote_node->fullpath);\n}\nWARNING(graph_endpoint, check_graph_endpoint, NULL, &graph_nodes);\n\nstatic struct check *check_table[] = {\n\t&duplicate_node_names, &duplicate_property_names,\n\t&node_name_chars, &node_name_format, &property_name_chars,\n\t&name_is_string, &name_properties, &node_name_vs_property_name,\n\n\t&duplicate_label,\n\n\t&explicit_phandles,\n\t&phandle_references, &path_references,\n\t&omit_unused_nodes,\n\n\t&address_cells_is_cell, &size_cells_is_cell,\n\t&device_type_is_string, &model_is_string, &status_is_string,\n\t&label_is_string,\n\n\t&compatible_is_string_list, &names_is_string_list,\n\n\t&property_name_chars_strict,\n\t&node_name_chars_strict,\n\n\t&addr_size_cells, &reg_format, &ranges_format, &dma_ranges_format,\n\n\t&unit_address_vs_reg,\n\t&unit_address_format,\n\n\t&pci_bridge,\n\t&pci_device_reg,\n\t&pci_device_bus_num,\n\n\t&simple_bus_bridge,\n\t&simple_bus_reg,\n\n\t&i2c_bus_bridge,\n\t&i2c_bus_reg,\n\n\t&spi_bus_bridge,\n\t&spi_bus_reg,\n\n\t&avoid_default_addr_size,\n\t&avoid_unnecessary_addr_size,\n\t&unique_unit_address,\n\t&unique_unit_address_if_enabled,\n\t&obsolete_chosen_interrupt_controller,\n\t&chosen_node_is_root, &chosen_node_bootargs, &chosen_node_stdout_path,\n\n\t&clocks_property,\n\t&clocks_is_cell,\n\t&cooling_device_property,\n\t&cooling_device_is_cell,\n\t&dmas_property,\n\t&dmas_is_cell,\n\t&hwlocks_property,\n\t&hwlocks_is_cell,\n\t&interrupts_extended_property,\n\t&interrupts_extended_is_cell,\n\t&io_channels_property,\n\t&io_channels_is_cell,\n\t&iommus_property,\n\t&iommus_is_cell,\n\t&mboxes_property,\n\t&mboxes_is_cell,\n\t&msi_parent_property,\n\t&msi_parent_is_cell,\n\t&mux_controls_property,\n\t&mux_controls_is_cell,\n\t&phys_property,\n\t&phys_is_cell,\n\t&power_domains_property,\n\t&power_domains_is_cell,\n\t&pwms_property,\n\t&pwms_is_cell,\n\t&resets_property,\n\t&resets_is_cell,\n\t&sound_dai_property,\n\t&sound_dai_is_cell,\n\t&thermal_sensors_property,\n\t&thermal_sensors_is_cell,\n\n\t&deprecated_gpio_property,\n\t&gpios_property,\n\t&interrupts_property,\n\t&interrupt_provider,\n\t&interrupt_map,\n\n\t&alias_paths,\n\n\t&graph_nodes, &graph_child_address, &graph_port, &graph_endpoint,\n\n\t&always_fail,\n};\n\nstatic void enable_warning_error(struct check *c, bool warn, bool error)\n{\n\tint i;\n\n\t \n\tif ((warn && !c->warn) || (error && !c->error))\n\t\tfor (i = 0; i < c->num_prereqs; i++)\n\t\t\tenable_warning_error(c->prereq[i], warn, error);\n\n\tc->warn = c->warn || warn;\n\tc->error = c->error || error;\n}\n\nstatic void disable_warning_error(struct check *c, bool warn, bool error)\n{\n\tunsigned int i;\n\n\t \n\tif ((warn && c->warn) || (error && c->error)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\n\t\t\tstruct check *cc = check_table[i];\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < cc->num_prereqs; j++)\n\t\t\t\tif (cc->prereq[j] == c)\n\t\t\t\t\tdisable_warning_error(cc, warn, error);\n\t\t}\n\t}\n\n\tc->warn = c->warn && !warn;\n\tc->error = c->error && !error;\n}\n\nvoid parse_checks_option(bool warn, bool error, const char *arg)\n{\n\tunsigned int i;\n\tconst char *name = arg;\n\tbool enable = true;\n\n\tif ((strncmp(arg, \"no-\", 3) == 0)\n\t    || (strncmp(arg, \"no_\", 3) == 0)) {\n\t\tname = arg + 3;\n\t\tenable = false;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\n\t\tstruct check *c = check_table[i];\n\n\t\tif (streq(c->name, name)) {\n\t\t\tif (enable)\n\t\t\t\tenable_warning_error(c, warn, error);\n\t\t\telse\n\t\t\t\tdisable_warning_error(c, warn, error);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdie(\"Unrecognized check name \\\"%s\\\"\\n\", name);\n}\n\nvoid process_checks(bool force, struct dt_info *dti)\n{\n\tunsigned int i;\n\tint error = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\n\t\tstruct check *c = check_table[i];\n\n\t\tif (c->warn || c->error)\n\t\t\terror = error || run_check(c, dti);\n\t}\n\n\tif (error) {\n\t\tif (!force) {\n\t\t\tfprintf(stderr, \"ERROR: Input tree has errors, aborting \"\n\t\t\t\t\"(use -f to force output)\\n\");\n\t\t\texit(2);\n\t\t} else if (quiet < 3) {\n\t\t\tfprintf(stderr, \"Warning: Input tree has errors, \"\n\t\t\t\t\"output forced\\n\");\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}