{
  "module_name": "flattree.c",
  "hash_id": "e52ffc3f639c7f1f054ec036ba6860d7e162a2fa2b41490474b1215e8399d85a",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/flattree.c",
  "human_readable_source": "\n \n\n#include \"dtc.h\"\n#include \"srcpos.h\"\n\n#define FTF_FULLPATH\t0x1\n#define FTF_VARALIGN\t0x2\n#define FTF_NAMEPROPS\t0x4\n#define FTF_BOOTCPUID\t0x8\n#define FTF_STRTABSIZE\t0x10\n#define FTF_STRUCTSIZE\t0x20\n#define FTF_NOPS\t0x40\n\nstatic struct version_info {\n\tint version;\n\tint last_comp_version;\n\tint hdr_size;\n\tint flags;\n} version_table[] = {\n\t{1, 1, FDT_V1_SIZE,\n\t FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS},\n\t{2, 1, FDT_V2_SIZE,\n\t FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS|FTF_BOOTCPUID},\n\t{3, 1, FDT_V3_SIZE,\n\t FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS|FTF_BOOTCPUID|FTF_STRTABSIZE},\n\t{16, 16, FDT_V3_SIZE,\n\t FTF_BOOTCPUID|FTF_STRTABSIZE|FTF_NOPS},\n\t{17, 16, FDT_V17_SIZE,\n\t FTF_BOOTCPUID|FTF_STRTABSIZE|FTF_STRUCTSIZE|FTF_NOPS},\n};\n\nstruct emitter {\n\tvoid (*cell)(void *, cell_t);\n\tvoid (*string)(void *, const char *, int);\n\tvoid (*align)(void *, int);\n\tvoid (*data)(void *, struct data);\n\tvoid (*beginnode)(void *, struct label *labels);\n\tvoid (*endnode)(void *, struct label *labels);\n\tvoid (*property)(void *, struct label *labels);\n};\n\nstatic void bin_emit_cell(void *e, cell_t val)\n{\n\tstruct data *dtbuf = e;\n\n\t*dtbuf = data_append_cell(*dtbuf, val);\n}\n\nstatic void bin_emit_string(void *e, const char *str, int len)\n{\n\tstruct data *dtbuf = e;\n\n\tif (len == 0)\n\t\tlen = strlen(str);\n\n\t*dtbuf = data_append_data(*dtbuf, str, len);\n\t*dtbuf = data_append_byte(*dtbuf, '\\0');\n}\n\nstatic void bin_emit_align(void *e, int a)\n{\n\tstruct data *dtbuf = e;\n\n\t*dtbuf = data_append_align(*dtbuf, a);\n}\n\nstatic void bin_emit_data(void *e, struct data d)\n{\n\tstruct data *dtbuf = e;\n\n\t*dtbuf = data_append_data(*dtbuf, d.val, d.len);\n}\n\nstatic void bin_emit_beginnode(void *e, struct label *labels)\n{\n\tbin_emit_cell(e, FDT_BEGIN_NODE);\n}\n\nstatic void bin_emit_endnode(void *e, struct label *labels)\n{\n\tbin_emit_cell(e, FDT_END_NODE);\n}\n\nstatic void bin_emit_property(void *e, struct label *labels)\n{\n\tbin_emit_cell(e, FDT_PROP);\n}\n\nstatic struct emitter bin_emitter = {\n\t.cell = bin_emit_cell,\n\t.string = bin_emit_string,\n\t.align = bin_emit_align,\n\t.data = bin_emit_data,\n\t.beginnode = bin_emit_beginnode,\n\t.endnode = bin_emit_endnode,\n\t.property = bin_emit_property,\n};\n\nstatic void emit_label(FILE *f, const char *prefix, const char *label)\n{\n\tfprintf(f, \"\\t.globl\\t%s_%s\\n\", prefix, label);\n\tfprintf(f, \"%s_%s:\\n\", prefix, label);\n\tfprintf(f, \"_%s_%s:\\n\", prefix, label);\n}\n\nstatic void emit_offset_label(FILE *f, const char *label, int offset)\n{\n\tfprintf(f, \"\\t.globl\\t%s\\n\", label);\n\tfprintf(f, \"%s\\t= . + %d\\n\", label, offset);\n}\n\n#define ASM_EMIT_BELONG(f, fmt, ...) \\\n\t{ \\\n\t\tfprintf((f), \"\\t.byte\\t((\" fmt \") >> 24) & 0xff\\n\", __VA_ARGS__); \\\n\t\tfprintf((f), \"\\t.byte\\t((\" fmt \") >> 16) & 0xff\\n\", __VA_ARGS__); \\\n\t\tfprintf((f), \"\\t.byte\\t((\" fmt \") >> 8) & 0xff\\n\", __VA_ARGS__); \\\n\t\tfprintf((f), \"\\t.byte\\t(\" fmt \") & 0xff\\n\", __VA_ARGS__); \\\n\t}\n\nstatic void asm_emit_cell(void *e, cell_t val)\n{\n\tFILE *f = e;\n\n\tfprintf(f, \"\\t.byte\\t0x%02x\\n\" \"\\t.byte\\t0x%02x\\n\"\n\t\t\"\\t.byte\\t0x%02x\\n\" \"\\t.byte\\t0x%02x\\n\",\n\t\t(val >> 24) & 0xff, (val >> 16) & 0xff,\n\t\t(val >> 8) & 0xff, val & 0xff);\n}\n\nstatic void asm_emit_string(void *e, const char *str, int len)\n{\n\tFILE *f = e;\n\n\tif (len != 0)\n\t\tfprintf(f, \"\\t.asciz\\t\\\"%.*s\\\"\\n\", len, str);\n\telse\n\t\tfprintf(f, \"\\t.asciz\\t\\\"%s\\\"\\n\", str);\n}\n\nstatic void asm_emit_align(void *e, int a)\n{\n\tFILE *f = e;\n\n\tfprintf(f, \"\\t.balign\\t%d, 0\\n\", a);\n}\n\nstatic void asm_emit_data(void *e, struct data d)\n{\n\tFILE *f = e;\n\tunsigned int off = 0;\n\tstruct marker *m = d.markers;\n\n\tfor_each_marker_of_type(m, LABEL)\n\t\temit_offset_label(f, m->ref, m->offset);\n\n\twhile ((d.len - off) >= sizeof(uint32_t)) {\n\t\tasm_emit_cell(e, dtb_ld32(d.val + off));\n\t\toff += sizeof(uint32_t);\n\t}\n\n\twhile ((d.len - off) >= 1) {\n\t\tfprintf(f, \"\\t.byte\\t0x%hhx\\n\", d.val[off]);\n\t\toff += 1;\n\t}\n\n\tassert(off == d.len);\n}\n\nstatic void asm_emit_beginnode(void *e, struct label *labels)\n{\n\tFILE *f = e;\n\tstruct label *l;\n\n\tfor_each_label(labels, l) {\n\t\tfprintf(f, \"\\t.globl\\t%s\\n\", l->label);\n\t\tfprintf(f, \"%s:\\n\", l->label);\n\t}\n\tfprintf(f, \"\\t/* FDT_BEGIN_NODE */\\n\");\n\tasm_emit_cell(e, FDT_BEGIN_NODE);\n}\n\nstatic void asm_emit_endnode(void *e, struct label *labels)\n{\n\tFILE *f = e;\n\tstruct label *l;\n\n\tfprintf(f, \"\\t/* FDT_END_NODE */\\n\");\n\tasm_emit_cell(e, FDT_END_NODE);\n\tfor_each_label(labels, l) {\n\t\tfprintf(f, \"\\t.globl\\t%s_end\\n\", l->label);\n\t\tfprintf(f, \"%s_end:\\n\", l->label);\n\t}\n}\n\nstatic void asm_emit_property(void *e, struct label *labels)\n{\n\tFILE *f = e;\n\tstruct label *l;\n\n\tfor_each_label(labels, l) {\n\t\tfprintf(f, \"\\t.globl\\t%s\\n\", l->label);\n\t\tfprintf(f, \"%s:\\n\", l->label);\n\t}\n\tfprintf(f, \"\\t/* FDT_PROP */\\n\");\n\tasm_emit_cell(e, FDT_PROP);\n}\n\nstatic struct emitter asm_emitter = {\n\t.cell = asm_emit_cell,\n\t.string = asm_emit_string,\n\t.align = asm_emit_align,\n\t.data = asm_emit_data,\n\t.beginnode = asm_emit_beginnode,\n\t.endnode = asm_emit_endnode,\n\t.property = asm_emit_property,\n};\n\nstatic int stringtable_insert(struct data *d, const char *str)\n{\n\tunsigned int i;\n\n\t \n\n\tfor (i = 0; i < d->len; i++) {\n\t\tif (streq(str, d->val + i))\n\t\t\treturn i;\n\t}\n\n\t*d = data_append_data(*d, str, strlen(str)+1);\n\treturn i;\n}\n\nstatic void flatten_tree(struct node *tree, struct emitter *emit,\n\t\t\t void *etarget, struct data *strbuf,\n\t\t\t struct version_info *vi)\n{\n\tstruct property *prop;\n\tstruct node *child;\n\tbool seen_name_prop = false;\n\n\tif (tree->deleted)\n\t\treturn;\n\n\temit->beginnode(etarget, tree->labels);\n\n\tif (vi->flags & FTF_FULLPATH)\n\t\temit->string(etarget, tree->fullpath, 0);\n\telse\n\t\temit->string(etarget, tree->name, 0);\n\n\temit->align(etarget, sizeof(cell_t));\n\n\tfor_each_property(tree, prop) {\n\t\tint nameoff;\n\n\t\tif (streq(prop->name, \"name\"))\n\t\t\tseen_name_prop = true;\n\n\t\tnameoff = stringtable_insert(strbuf, prop->name);\n\n\t\temit->property(etarget, prop->labels);\n\t\temit->cell(etarget, prop->val.len);\n\t\temit->cell(etarget, nameoff);\n\n\t\tif ((vi->flags & FTF_VARALIGN) && (prop->val.len >= 8))\n\t\t\temit->align(etarget, 8);\n\n\t\temit->data(etarget, prop->val);\n\t\temit->align(etarget, sizeof(cell_t));\n\t}\n\n\tif ((vi->flags & FTF_NAMEPROPS) && !seen_name_prop) {\n\t\temit->property(etarget, NULL);\n\t\temit->cell(etarget, tree->basenamelen+1);\n\t\temit->cell(etarget, stringtable_insert(strbuf, \"name\"));\n\n\t\tif ((vi->flags & FTF_VARALIGN) && ((tree->basenamelen+1) >= 8))\n\t\t\temit->align(etarget, 8);\n\n\t\temit->string(etarget, tree->name, tree->basenamelen);\n\t\temit->align(etarget, sizeof(cell_t));\n\t}\n\n\tfor_each_child(tree, child) {\n\t\tflatten_tree(child, emit, etarget, strbuf, vi);\n\t}\n\n\temit->endnode(etarget, tree->labels);\n}\n\nstatic struct data flatten_reserve_list(struct reserve_info *reservelist,\n\t\t\t\t struct version_info *vi)\n{\n\tstruct reserve_info *re;\n\tstruct data d = empty_data;\n\tunsigned int j;\n\n\tfor (re = reservelist; re; re = re->next) {\n\t\td = data_append_re(d, re->address, re->size);\n\t}\n\t \n\tfor (j = 0; j < reservenum; j++) {\n\t\td = data_append_re(d, 0, 0);\n\t}\n\n\treturn d;\n}\n\nstatic void make_fdt_header(struct fdt_header *fdt,\n\t\t\t    struct version_info *vi,\n\t\t\t    int reservesize, int dtsize, int strsize,\n\t\t\t    int boot_cpuid_phys)\n{\n\tint reserve_off;\n\n\treservesize += sizeof(struct fdt_reserve_entry);\n\n\tmemset(fdt, 0xff, sizeof(*fdt));\n\n\tfdt->magic = cpu_to_fdt32(FDT_MAGIC);\n\tfdt->version = cpu_to_fdt32(vi->version);\n\tfdt->last_comp_version = cpu_to_fdt32(vi->last_comp_version);\n\n\t \n\treserve_off = ALIGN(vi->hdr_size, 8);\n\n\tfdt->off_mem_rsvmap = cpu_to_fdt32(reserve_off);\n\tfdt->off_dt_struct = cpu_to_fdt32(reserve_off + reservesize);\n\tfdt->off_dt_strings = cpu_to_fdt32(reserve_off + reservesize\n\t\t\t\t\t  + dtsize);\n\tfdt->totalsize = cpu_to_fdt32(reserve_off + reservesize + dtsize + strsize);\n\n\tif (vi->flags & FTF_BOOTCPUID)\n\t\tfdt->boot_cpuid_phys = cpu_to_fdt32(boot_cpuid_phys);\n\tif (vi->flags & FTF_STRTABSIZE)\n\t\tfdt->size_dt_strings = cpu_to_fdt32(strsize);\n\tif (vi->flags & FTF_STRUCTSIZE)\n\t\tfdt->size_dt_struct = cpu_to_fdt32(dtsize);\n}\n\nvoid dt_to_blob(FILE *f, struct dt_info *dti, int version)\n{\n\tstruct version_info *vi = NULL;\n\tunsigned int i;\n\tstruct data blob       = empty_data;\n\tstruct data reservebuf = empty_data;\n\tstruct data dtbuf      = empty_data;\n\tstruct data strbuf     = empty_data;\n\tstruct fdt_header fdt;\n\tint padlen = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(version_table); i++) {\n\t\tif (version_table[i].version == version)\n\t\t\tvi = &version_table[i];\n\t}\n\tif (!vi)\n\t\tdie(\"Unknown device tree blob version %d\\n\", version);\n\n\tflatten_tree(dti->dt, &bin_emitter, &dtbuf, &strbuf, vi);\n\tbin_emit_cell(&dtbuf, FDT_END);\n\n\treservebuf = flatten_reserve_list(dti->reservelist, vi);\n\n\t \n\tmake_fdt_header(&fdt, vi, reservebuf.len, dtbuf.len, strbuf.len,\n\t\t\tdti->boot_cpuid_phys);\n\n\t \n\tif (minsize > 0) {\n\t\tpadlen = minsize - fdt32_to_cpu(fdt.totalsize);\n\t\tif (padlen < 0) {\n\t\t\tpadlen = 0;\n\t\t\tif (quiet < 1)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Warning: blob size %\"PRIu32\" >= minimum size %d\\n\",\n\t\t\t\t\tfdt32_to_cpu(fdt.totalsize), minsize);\n\t\t}\n\t}\n\n\tif (padsize > 0)\n\t\tpadlen = padsize;\n\n\tif (alignsize > 0)\n\t\tpadlen = ALIGN(fdt32_to_cpu(fdt.totalsize) + padlen, alignsize)\n\t\t\t- fdt32_to_cpu(fdt.totalsize);\n\n\tif (padlen > 0) {\n\t\tint tsize = fdt32_to_cpu(fdt.totalsize);\n\t\ttsize += padlen;\n\t\tfdt.totalsize = cpu_to_fdt32(tsize);\n\t}\n\n\t \n\tblob = data_append_data(blob, &fdt, vi->hdr_size);\n\tblob = data_append_align(blob, 8);\n\tblob = data_merge(blob, reservebuf);\n\tblob = data_append_zeroes(blob, sizeof(struct fdt_reserve_entry));\n\tblob = data_merge(blob, dtbuf);\n\tblob = data_merge(blob, strbuf);\n\n\t \n\tif (padlen > 0)\n\t\tblob = data_append_zeroes(blob, padlen);\n\n\tif (fwrite(blob.val, blob.len, 1, f) != 1) {\n\t\tif (ferror(f))\n\t\t\tdie(\"Error writing device tree blob: %s\\n\",\n\t\t\t    strerror(errno));\n\t\telse\n\t\t\tdie(\"Short write on device tree blob\\n\");\n\t}\n\n\t \n\tdata_free(blob);\n}\n\nstatic void dump_stringtable_asm(FILE *f, struct data strbuf)\n{\n\tconst char *p;\n\tint len;\n\n\tp = strbuf.val;\n\n\twhile (p < (strbuf.val + strbuf.len)) {\n\t\tlen = strlen(p);\n\t\tfprintf(f, \"\\t.asciz \\\"%s\\\"\\n\", p);\n\t\tp += len+1;\n\t}\n}\n\nvoid dt_to_asm(FILE *f, struct dt_info *dti, int version)\n{\n\tstruct version_info *vi = NULL;\n\tunsigned int i;\n\tstruct data strbuf = empty_data;\n\tstruct reserve_info *re;\n\tconst char *symprefix = \"dt\";\n\n\tfor (i = 0; i < ARRAY_SIZE(version_table); i++) {\n\t\tif (version_table[i].version == version)\n\t\t\tvi = &version_table[i];\n\t}\n\tif (!vi)\n\t\tdie(\"Unknown device tree blob version %d\\n\", version);\n\n\tfprintf(f, \"/* autogenerated by dtc, do not edit */\\n\\n\");\n\n\temit_label(f, symprefix, \"blob_start\");\n\temit_label(f, symprefix, \"header\");\n\tfprintf(f, \"\\t/* magic */\\n\");\n\tasm_emit_cell(f, FDT_MAGIC);\n\tfprintf(f, \"\\t/* totalsize */\\n\");\n\tASM_EMIT_BELONG(f, \"_%s_blob_abs_end - _%s_blob_start\",\n\t\t\tsymprefix, symprefix);\n\tfprintf(f, \"\\t/* off_dt_struct */\\n\");\n\tASM_EMIT_BELONG(f, \"_%s_struct_start - _%s_blob_start\",\n\t\tsymprefix, symprefix);\n\tfprintf(f, \"\\t/* off_dt_strings */\\n\");\n\tASM_EMIT_BELONG(f, \"_%s_strings_start - _%s_blob_start\",\n\t\tsymprefix, symprefix);\n\tfprintf(f, \"\\t/* off_mem_rsvmap */\\n\");\n\tASM_EMIT_BELONG(f, \"_%s_reserve_map - _%s_blob_start\",\n\t\tsymprefix, symprefix);\n\tfprintf(f, \"\\t/* version */\\n\");\n\tasm_emit_cell(f, vi->version);\n\tfprintf(f, \"\\t/* last_comp_version */\\n\");\n\tasm_emit_cell(f, vi->last_comp_version);\n\n\tif (vi->flags & FTF_BOOTCPUID) {\n\t\tfprintf(f, \"\\t/* boot_cpuid_phys */\\n\");\n\t\tasm_emit_cell(f, dti->boot_cpuid_phys);\n\t}\n\n\tif (vi->flags & FTF_STRTABSIZE) {\n\t\tfprintf(f, \"\\t/* size_dt_strings */\\n\");\n\t\tASM_EMIT_BELONG(f, \"_%s_strings_end - _%s_strings_start\",\n\t\t\t\tsymprefix, symprefix);\n\t}\n\n\tif (vi->flags & FTF_STRUCTSIZE) {\n\t\tfprintf(f, \"\\t/* size_dt_struct */\\n\");\n\t\tASM_EMIT_BELONG(f, \"_%s_struct_end - _%s_struct_start\",\n\t\t\tsymprefix, symprefix);\n\t}\n\n\t \n\tasm_emit_align(f, 8);\n\temit_label(f, symprefix, \"reserve_map\");\n\n\tfprintf(f, \"/* Memory reserve map from source file */\\n\");\n\n\t \n\tfor (re = dti->reservelist; re; re = re->next) {\n\t\tstruct label *l;\n\n\t\tfor_each_label(re->labels, l) {\n\t\t\tfprintf(f, \"\\t.globl\\t%s\\n\", l->label);\n\t\t\tfprintf(f, \"%s:\\n\", l->label);\n\t\t}\n\t\tASM_EMIT_BELONG(f, \"0x%08x\", (unsigned int)(re->address >> 32));\n\t\tASM_EMIT_BELONG(f, \"0x%08x\",\n\t\t\t\t(unsigned int)(re->address & 0xffffffff));\n\t\tASM_EMIT_BELONG(f, \"0x%08x\", (unsigned int)(re->size >> 32));\n\t\tASM_EMIT_BELONG(f, \"0x%08x\", (unsigned int)(re->size & 0xffffffff));\n\t}\n\tfor (i = 0; i < reservenum; i++) {\n\t\tfprintf(f, \"\\t.long\\t0, 0\\n\\t.long\\t0, 0\\n\");\n\t}\n\n\tfprintf(f, \"\\t.long\\t0, 0\\n\\t.long\\t0, 0\\n\");\n\n\temit_label(f, symprefix, \"struct_start\");\n\tflatten_tree(dti->dt, &asm_emitter, f, &strbuf, vi);\n\n\tfprintf(f, \"\\t/* FDT_END */\\n\");\n\tasm_emit_cell(f, FDT_END);\n\temit_label(f, symprefix, \"struct_end\");\n\n\temit_label(f, symprefix, \"strings_start\");\n\tdump_stringtable_asm(f, strbuf);\n\temit_label(f, symprefix, \"strings_end\");\n\n\temit_label(f, symprefix, \"blob_end\");\n\n\t \n\tif (minsize > 0) {\n\t\tfprintf(f, \"\\t.space\\t%d - (_%s_blob_end - _%s_blob_start), 0\\n\",\n\t\t\tminsize, symprefix, symprefix);\n\t}\n\tif (padsize > 0) {\n\t\tfprintf(f, \"\\t.space\\t%d, 0\\n\", padsize);\n\t}\n\tif (alignsize > 0)\n\t\tasm_emit_align(f, alignsize);\n\temit_label(f, symprefix, \"blob_abs_end\");\n\n\tdata_free(strbuf);\n}\n\nstruct inbuf {\n\tchar *base, *limit, *ptr;\n};\n\nstatic void inbuf_init(struct inbuf *inb, void *base, void *limit)\n{\n\tinb->base = base;\n\tinb->limit = limit;\n\tinb->ptr = inb->base;\n}\n\nstatic void flat_read_chunk(struct inbuf *inb, void *p, int len)\n{\n\tif ((inb->ptr + len) > inb->limit)\n\t\tdie(\"Premature end of data parsing flat device tree\\n\");\n\n\tmemcpy(p, inb->ptr, len);\n\n\tinb->ptr += len;\n}\n\nstatic uint32_t flat_read_word(struct inbuf *inb)\n{\n\tfdt32_t val;\n\n\tassert(((inb->ptr - inb->base) % sizeof(val)) == 0);\n\n\tflat_read_chunk(inb, &val, sizeof(val));\n\n\treturn fdt32_to_cpu(val);\n}\n\nstatic void flat_realign(struct inbuf *inb, int align)\n{\n\tint off = inb->ptr - inb->base;\n\n\tinb->ptr = inb->base + ALIGN(off, align);\n\tif (inb->ptr > inb->limit)\n\t\tdie(\"Premature end of data parsing flat device tree\\n\");\n}\n\nstatic char *flat_read_string(struct inbuf *inb)\n{\n\tint len = 0;\n\tconst char *p = inb->ptr;\n\tchar *str;\n\n\tdo {\n\t\tif (p >= inb->limit)\n\t\t\tdie(\"Premature end of data parsing flat device tree\\n\");\n\t\tlen++;\n\t} while ((*p++) != '\\0');\n\n\tstr = xstrdup(inb->ptr);\n\n\tinb->ptr += len;\n\n\tflat_realign(inb, sizeof(uint32_t));\n\n\treturn str;\n}\n\nstatic struct data flat_read_data(struct inbuf *inb, int len)\n{\n\tstruct data d = empty_data;\n\n\tif (len == 0)\n\t\treturn empty_data;\n\n\td = data_grow_for(d, len);\n\td.len = len;\n\n\tflat_read_chunk(inb, d.val, len);\n\n\tflat_realign(inb, sizeof(uint32_t));\n\n\treturn d;\n}\n\nstatic char *flat_read_stringtable(struct inbuf *inb, int offset)\n{\n\tconst char *p;\n\n\tp = inb->base + offset;\n\twhile (1) {\n\t\tif (p >= inb->limit || p < inb->base)\n\t\t\tdie(\"String offset %d overruns string table\\n\",\n\t\t\t    offset);\n\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\n\t\tp++;\n\t}\n\n\treturn xstrdup(inb->base + offset);\n}\n\nstatic struct property *flat_read_property(struct inbuf *dtbuf,\n\t\t\t\t\t   struct inbuf *strbuf, int flags)\n{\n\tuint32_t proplen, stroff;\n\tchar *name;\n\tstruct data val;\n\n\tproplen = flat_read_word(dtbuf);\n\tstroff = flat_read_word(dtbuf);\n\n\tname = flat_read_stringtable(strbuf, stroff);\n\n\tif ((flags & FTF_VARALIGN) && (proplen >= 8))\n\t\tflat_realign(dtbuf, 8);\n\n\tval = flat_read_data(dtbuf, proplen);\n\n\treturn build_property(name, val, NULL);\n}\n\n\nstatic struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)\n{\n\tstruct reserve_info *reservelist = NULL;\n\tstruct reserve_info *new;\n\tstruct fdt_reserve_entry re;\n\n\t \n\twhile (1) {\n\t\tuint64_t address, size;\n\n\t\tflat_read_chunk(inb, &re, sizeof(re));\n\t\taddress  = fdt64_to_cpu(re.address);\n\t\tsize = fdt64_to_cpu(re.size);\n\t\tif (size == 0)\n\t\t\tbreak;\n\n\t\tnew = build_reserve_entry(address, size);\n\t\treservelist = add_reserve_entry(reservelist, new);\n\t}\n\n\treturn reservelist;\n}\n\n\nstatic char *nodename_from_path(const char *ppath, const char *cpath)\n{\n\tint plen;\n\n\tplen = strlen(ppath);\n\n\tif (!strstarts(cpath, ppath))\n\t\tdie(\"Path \\\"%s\\\" is not valid as a child of \\\"%s\\\"\\n\",\n\t\t    cpath, ppath);\n\n\t \n\tif (!streq(ppath, \"/\"))\n\t\tplen++;\n\n\treturn xstrdup(cpath + plen);\n}\n\nstatic struct node *unflatten_tree(struct inbuf *dtbuf,\n\t\t\t\t   struct inbuf *strbuf,\n\t\t\t\t   const char *parent_flatname, int flags)\n{\n\tstruct node *node;\n\tchar *flatname;\n\tuint32_t val;\n\n\tnode = build_node(NULL, NULL, NULL);\n\n\tflatname = flat_read_string(dtbuf);\n\n\tif (flags & FTF_FULLPATH)\n\t\tnode->name = nodename_from_path(parent_flatname, flatname);\n\telse\n\t\tnode->name = flatname;\n\n\tdo {\n\t\tstruct property *prop;\n\t\tstruct node *child;\n\n\t\tval = flat_read_word(dtbuf);\n\t\tswitch (val) {\n\t\tcase FDT_PROP:\n\t\t\tif (node->children)\n\t\t\t\tfprintf(stderr, \"Warning: Flat tree input has \"\n\t\t\t\t\t\"subnodes preceding a property.\\n\");\n\t\t\tprop = flat_read_property(dtbuf, strbuf, flags);\n\t\t\tadd_property(node, prop);\n\t\t\tbreak;\n\n\t\tcase FDT_BEGIN_NODE:\n\t\t\tchild = unflatten_tree(dtbuf,strbuf, flatname, flags);\n\t\t\tadd_child(node, child);\n\t\t\tbreak;\n\n\t\tcase FDT_END_NODE:\n\t\t\tbreak;\n\n\t\tcase FDT_END:\n\t\t\tdie(\"Premature FDT_END in device tree blob\\n\");\n\t\t\tbreak;\n\n\t\tcase FDT_NOP:\n\t\t\tif (!(flags & FTF_NOPS))\n\t\t\t\tfprintf(stderr, \"Warning: NOP tag found in flat tree\"\n\t\t\t\t\t\" version <16\\n\");\n\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdie(\"Invalid opcode word %08x in device tree blob\\n\",\n\t\t\t    val);\n\t\t}\n\t} while (val != FDT_END_NODE);\n\n\tif (node->name != flatname) {\n\t\tfree(flatname);\n\t}\n\n\treturn node;\n}\n\n\nstruct dt_info *dt_from_blob(const char *fname)\n{\n\tFILE *f;\n\tfdt32_t magic_buf, totalsize_buf;\n\tuint32_t magic, totalsize, version, size_dt, boot_cpuid_phys;\n\tuint32_t off_dt, off_str, off_mem_rsvmap;\n\tint rc;\n\tchar *blob;\n\tstruct fdt_header *fdt;\n\tchar *p;\n\tstruct inbuf dtbuf, strbuf;\n\tstruct inbuf memresvbuf;\n\tint sizeleft;\n\tstruct reserve_info *reservelist;\n\tstruct node *tree;\n\tuint32_t val;\n\tint flags = 0;\n\n\tf = srcfile_relative_open(fname, NULL);\n\n\trc = fread(&magic_buf, sizeof(magic_buf), 1, f);\n\tif (ferror(f))\n\t\tdie(\"Error reading DT blob magic number: %s\\n\",\n\t\t    strerror(errno));\n\tif (rc < 1) {\n\t\tif (feof(f))\n\t\t\tdie(\"EOF reading DT blob magic number\\n\");\n\t\telse\n\t\t\tdie(\"Mysterious short read reading magic number\\n\");\n\t}\n\n\tmagic = fdt32_to_cpu(magic_buf);\n\tif (magic != FDT_MAGIC)\n\t\tdie(\"Blob has incorrect magic number\\n\");\n\n\trc = fread(&totalsize_buf, sizeof(totalsize_buf), 1, f);\n\tif (ferror(f))\n\t\tdie(\"Error reading DT blob size: %s\\n\", strerror(errno));\n\tif (rc < 1) {\n\t\tif (feof(f))\n\t\t\tdie(\"EOF reading DT blob size\\n\");\n\t\telse\n\t\t\tdie(\"Mysterious short read reading blob size\\n\");\n\t}\n\n\ttotalsize = fdt32_to_cpu(totalsize_buf);\n\tif (totalsize < FDT_V1_SIZE)\n\t\tdie(\"DT blob size (%d) is too small\\n\", totalsize);\n\n\tblob = xmalloc(totalsize);\n\n\tfdt = (struct fdt_header *)blob;\n\tfdt->magic = cpu_to_fdt32(magic);\n\tfdt->totalsize = cpu_to_fdt32(totalsize);\n\n\tsizeleft = totalsize - sizeof(magic) - sizeof(totalsize);\n\tp = blob + sizeof(magic)  + sizeof(totalsize);\n\n\twhile (sizeleft) {\n\t\tif (feof(f))\n\t\t\tdie(\"EOF before reading %d bytes of DT blob\\n\",\n\t\t\t    totalsize);\n\n\t\trc = fread(p, 1, sizeleft, f);\n\t\tif (ferror(f))\n\t\t\tdie(\"Error reading DT blob: %s\\n\",\n\t\t\t    strerror(errno));\n\n\t\tsizeleft -= rc;\n\t\tp += rc;\n\t}\n\n\toff_dt = fdt32_to_cpu(fdt->off_dt_struct);\n\toff_str = fdt32_to_cpu(fdt->off_dt_strings);\n\toff_mem_rsvmap = fdt32_to_cpu(fdt->off_mem_rsvmap);\n\tversion = fdt32_to_cpu(fdt->version);\n\tboot_cpuid_phys = fdt32_to_cpu(fdt->boot_cpuid_phys);\n\n\tif (off_mem_rsvmap >= totalsize)\n\t\tdie(\"Mem Reserve structure offset exceeds total size\\n\");\n\n\tif (off_dt >= totalsize)\n\t\tdie(\"DT structure offset exceeds total size\\n\");\n\n\tif (off_str > totalsize)\n\t\tdie(\"String table offset exceeds total size\\n\");\n\n\tif (version >= 3) {\n\t\tuint32_t size_str = fdt32_to_cpu(fdt->size_dt_strings);\n\t\tif ((off_str+size_str < off_str) || (off_str+size_str > totalsize))\n\t\t\tdie(\"String table extends past total size\\n\");\n\t\tinbuf_init(&strbuf, blob + off_str, blob + off_str + size_str);\n\t} else {\n\t\tinbuf_init(&strbuf, blob + off_str, blob + totalsize);\n\t}\n\n\tif (version >= 17) {\n\t\tsize_dt = fdt32_to_cpu(fdt->size_dt_struct);\n\t\tif ((off_dt+size_dt < off_dt) || (off_dt+size_dt > totalsize))\n\t\t\tdie(\"Structure block extends past total size\\n\");\n\t}\n\n\tif (version < 16) {\n\t\tflags |= FTF_FULLPATH | FTF_NAMEPROPS | FTF_VARALIGN;\n\t} else {\n\t\tflags |= FTF_NOPS;\n\t}\n\n\tinbuf_init(&memresvbuf,\n\t\t   blob + off_mem_rsvmap, blob + totalsize);\n\tinbuf_init(&dtbuf, blob + off_dt, blob + totalsize);\n\n\treservelist = flat_read_mem_reserve(&memresvbuf);\n\n\tval = flat_read_word(&dtbuf);\n\n\tif (val != FDT_BEGIN_NODE)\n\t\tdie(\"Device tree blob doesn't begin with FDT_BEGIN_NODE (begins with 0x%08x)\\n\", val);\n\n\ttree = unflatten_tree(&dtbuf, &strbuf, \"\", flags);\n\n\tval = flat_read_word(&dtbuf);\n\tif (val != FDT_END)\n\t\tdie(\"Device tree blob doesn't end with FDT_END\\n\");\n\n\tfree(blob);\n\n\tfclose(f);\n\n\treturn build_dt_info(DTSF_V1, reservelist, tree, boot_cpuid_phys);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}