{
  "module_name": "util.h",
  "hash_id": "e468bdef88f58a241f2fa360ff12009082f03f5f9acf17088eb0437ea4ac7092",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/util.h",
  "human_readable_source": " \n#ifndef UTIL_H\n#define UTIL_H\n\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <getopt.h>\n\n \n\n#ifdef __GNUC__\n#if __GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)\n#define PRINTF(i, j)\t__attribute__((format (gnu_printf, i, j)))\n#else\n#define PRINTF(i, j)\t__attribute__((format (printf, i, j)))\n#endif\n#define NORETURN\t__attribute__((noreturn))\n#else\n#define PRINTF(i, j)\n#define NORETURN\n#endif\n\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n\n#define stringify(s)\tstringify_(s)\n#define stringify_(s)\t#s\n\nstatic inline void NORETURN PRINTF(1, 2) die(const char *str, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, str);\n\tfprintf(stderr, \"FATAL ERROR: \");\n\tvfprintf(stderr, str, ap);\n\tva_end(ap);\n\texit(1);\n}\n\nstatic inline void *xmalloc(size_t len)\n{\n\tvoid *new = malloc(len);\n\n\tif (!new)\n\t\tdie(\"malloc() failed\\n\");\n\n\treturn new;\n}\n\nstatic inline void *xrealloc(void *p, size_t len)\n{\n\tvoid *new = realloc(p, len);\n\n\tif (!new)\n\t\tdie(\"realloc() failed (len=%zd)\\n\", len);\n\n\treturn new;\n}\n\nextern char *xstrdup(const char *s);\nextern char *xstrndup(const char *s, size_t len);\n\nextern int PRINTF(2, 3) xasprintf(char **strp, const char *fmt, ...);\nextern int PRINTF(2, 3) xasprintf_append(char **strp, const char *fmt, ...);\nextern int xavsprintf_append(char **strp, const char *fmt, va_list ap);\nextern char *join_path(const char *path, const char *name);\n\n \nbool util_is_printable_string(const void *data, int len);\n\n \nchar get_escape_char(const char *s, int *i);\n\n \nchar *utilfdt_read(const char *filename, size_t *len);\n\n \nint utilfdt_read_err(const char *filename, char **buffp, size_t *len);\n\n \nint utilfdt_write(const char *filename, const void *blob);\n\n \nint utilfdt_write_err(const char *filename, const void *blob);\n\n \nint utilfdt_decode_type(const char *fmt, int *type, int *size);\n\n \n\n#define USAGE_TYPE_MSG \\\n\t\"<type>\\ts=string, i=int, u=unsigned, x=hex, r=raw\\n\" \\\n\t\"\\tOptional modifier prefix:\\n\" \\\n\t\"\\t\\thh or b=byte, h=2 byte, l=4 byte (default)\";\n\n \nvoid utilfdt_print_data(const char *data, int len);\n\n \nvoid NORETURN util_version(void);\n\n \nvoid NORETURN util_usage(const char *errmsg, const char *synopsis,\n\t\t\t const char *short_opts,\n\t\t\t struct option const long_opts[],\n\t\t\t const char * const opts_help[]);\n\n \n#define usage(errmsg) \\\n\tutil_usage(errmsg, usage_synopsis, usage_short_opts, \\\n\t\t   usage_long_opts, usage_opts_help)\n\n \n#define util_getopt_long() getopt_long(argc, argv, usage_short_opts, \\\n\t\t\t\t       usage_long_opts, NULL)\n\n \n#define a_argument required_argument\n\n \n#define USAGE_COMMON_SHORT_OPTS \"hV\"\n\n \n#define USAGE_COMMON_LONG_OPTS \\\n\t{\"help\",      no_argument, NULL, 'h'}, \\\n\t{\"version\",   no_argument, NULL, 'V'}, \\\n\t{NULL,        no_argument, NULL, 0x0}\n\n \n#define USAGE_COMMON_OPTS_HELP \\\n\t\"Print this help and exit\", \\\n\t\"Print version and exit\", \\\n\tNULL\n\n \n#define case_USAGE_COMMON_FLAGS \\\n\tcase 'h': usage(NULL); \\\n\tcase 'V': util_version(); \\\n\tcase '?': usage(\"unknown option\");\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}