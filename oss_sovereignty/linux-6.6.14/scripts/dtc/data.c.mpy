{
  "module_name": "data.c",
  "hash_id": "9aa81a1aad19ef6a31724aeb6931e113a166427c50b918953522f9c3a69edfcc",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/data.c",
  "human_readable_source": "\n \n\n#include \"dtc.h\"\n\nvoid data_free(struct data d)\n{\n\tstruct marker *m, *nm;\n\n\tm = d.markers;\n\twhile (m) {\n\t\tnm = m->next;\n\t\tfree(m->ref);\n\t\tfree(m);\n\t\tm = nm;\n\t}\n\n\tif (d.val)\n\t\tfree(d.val);\n}\n\nstruct data data_grow_for(struct data d, unsigned int xlen)\n{\n\tstruct data nd;\n\tunsigned int newsize;\n\n\tif (xlen == 0)\n\t\treturn d;\n\n\tnd = d;\n\n\tnewsize = xlen;\n\n\twhile ((d.len + xlen) > newsize)\n\t\tnewsize *= 2;\n\n\tnd.val = xrealloc(d.val, newsize);\n\n\treturn nd;\n}\n\nstruct data data_copy_mem(const char *mem, int len)\n{\n\tstruct data d;\n\n\td = data_grow_for(empty_data, len);\n\n\td.len = len;\n\tmemcpy(d.val, mem, len);\n\n\treturn d;\n}\n\nstruct data data_copy_escape_string(const char *s, int len)\n{\n\tint i = 0;\n\tstruct data d;\n\tchar *q;\n\n\td = data_add_marker(empty_data, TYPE_STRING, NULL);\n\td = data_grow_for(d, len + 1);\n\n\tq = d.val;\n\twhile (i < len) {\n\t\tchar c = s[i++];\n\n\t\tif (c == '\\\\')\n\t\t\tc = get_escape_char(s, &i);\n\n\t\tq[d.len++] = c;\n\t}\n\n\tq[d.len++] = '\\0';\n\treturn d;\n}\n\nstruct data data_copy_file(FILE *f, size_t maxlen)\n{\n\tstruct data d = empty_data;\n\n\td = data_add_marker(d, TYPE_NONE, NULL);\n\twhile (!feof(f) && (d.len < maxlen)) {\n\t\tsize_t chunksize, ret;\n\n\t\tif (maxlen == (size_t)-1)\n\t\t\tchunksize = 4096;\n\t\telse\n\t\t\tchunksize = maxlen - d.len;\n\n\t\td = data_grow_for(d, chunksize);\n\t\tret = fread(d.val + d.len, 1, chunksize, f);\n\n\t\tif (ferror(f))\n\t\t\tdie(\"Error reading file into data: %s\", strerror(errno));\n\n\t\tif (d.len + ret < d.len)\n\t\t\tdie(\"Overflow reading file into data\\n\");\n\n\t\td.len += ret;\n\t}\n\n\treturn d;\n}\n\nstruct data data_append_data(struct data d, const void *p, int len)\n{\n\td = data_grow_for(d, len);\n\tmemcpy(d.val + d.len, p, len);\n\td.len += len;\n\treturn d;\n}\n\nstruct data data_insert_at_marker(struct data d, struct marker *m,\n\t\t\t\t  const void *p, int len)\n{\n\td = data_grow_for(d, len);\n\tmemmove(d.val + m->offset + len, d.val + m->offset, d.len - m->offset);\n\tmemcpy(d.val + m->offset, p, len);\n\td.len += len;\n\n\t \n\tm = m->next;\n\tfor_each_marker(m)\n\t\tm->offset += len;\n\treturn d;\n}\n\nstatic struct data data_append_markers(struct data d, struct marker *m)\n{\n\tstruct marker **mp = &d.markers;\n\n\t \n\twhile (*mp)\n\t\tmp = &((*mp)->next);\n\t*mp = m;\n\treturn d;\n}\n\nstruct data data_merge(struct data d1, struct data d2)\n{\n\tstruct data d;\n\tstruct marker *m2 = d2.markers;\n\n\td = data_append_markers(data_append_data(d1, d2.val, d2.len), m2);\n\n\t \n\tfor_each_marker(m2)\n\t\tm2->offset += d1.len;\n\n\td2.markers = NULL;  \n\tdata_free(d2);\n\n\treturn d;\n}\n\nstruct data data_append_integer(struct data d, uint64_t value, int bits)\n{\n\tuint8_t value_8;\n\tfdt16_t value_16;\n\tfdt32_t value_32;\n\tfdt64_t value_64;\n\n\tswitch (bits) {\n\tcase 8:\n\t\tvalue_8 = value;\n\t\treturn data_append_data(d, &value_8, 1);\n\n\tcase 16:\n\t\tvalue_16 = cpu_to_fdt16(value);\n\t\treturn data_append_data(d, &value_16, 2);\n\n\tcase 32:\n\t\tvalue_32 = cpu_to_fdt32(value);\n\t\treturn data_append_data(d, &value_32, 4);\n\n\tcase 64:\n\t\tvalue_64 = cpu_to_fdt64(value);\n\t\treturn data_append_data(d, &value_64, 8);\n\n\tdefault:\n\t\tdie(\"Invalid literal size (%d)\\n\", bits);\n\t}\n}\n\nstruct data data_append_re(struct data d, uint64_t address, uint64_t size)\n{\n\tstruct fdt_reserve_entry re;\n\n\tre.address = cpu_to_fdt64(address);\n\tre.size = cpu_to_fdt64(size);\n\n\treturn data_append_data(d, &re, sizeof(re));\n}\n\nstruct data data_append_cell(struct data d, cell_t word)\n{\n\treturn data_append_integer(d, word, sizeof(word) * 8);\n}\n\nstruct data data_append_addr(struct data d, uint64_t addr)\n{\n\treturn data_append_integer(d, addr, sizeof(addr) * 8);\n}\n\nstruct data data_append_byte(struct data d, uint8_t byte)\n{\n\treturn data_append_data(d, &byte, 1);\n}\n\nstruct data data_append_zeroes(struct data d, int len)\n{\n\td = data_grow_for(d, len);\n\n\tmemset(d.val + d.len, 0, len);\n\td.len += len;\n\treturn d;\n}\n\nstruct data data_append_align(struct data d, int align)\n{\n\tint newlen = ALIGN(d.len, align);\n\treturn data_append_zeroes(d, newlen - d.len);\n}\n\nstruct data data_add_marker(struct data d, enum markertype type, char *ref)\n{\n\tstruct marker *m;\n\n\tm = xmalloc(sizeof(*m));\n\tm->offset = d.len;\n\tm->type = type;\n\tm->ref = ref;\n\tm->next = NULL;\n\n\treturn data_append_markers(d, m);\n}\n\nbool data_is_one_string(struct data d)\n{\n\tint i;\n\tint len = d.len;\n\n\tif (len == 0)\n\t\treturn false;\n\n\tfor (i = 0; i < len-1; i++)\n\t\tif (d.val[i] == '\\0')\n\t\t\treturn false;\n\n\tif (d.val[len-1] != '\\0')\n\t\treturn false;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}