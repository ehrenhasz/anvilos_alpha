{
  "module_name": "dt-extract-compatibles",
  "hash_id": "e72dc99625eb11cc5a021719435c5c05016e81cfcea07aa54e31ecd3339eecb0",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/dt-extract-compatibles",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n\nimport fnmatch\nimport os\nimport re\nimport argparse\n\n\ndef parse_of_declare_macros(data):\n\t\"\"\" Find all compatible strings in OF_DECLARE() style macros \"\"\"\n\tcompat_list = []\n\t# CPU_METHOD_OF_DECLARE does not have a compatible string\n\tfor m in re.finditer(r'(?<!CPU_METHOD_)(IRQCHIP|OF)_(DECLARE|MATCH)(_DRIVER)?\\(.*?\\)', data):\n\t\ttry:\n\t\t\tcompat = re.search(r'\"(.*?)\"', m[0])[1]\n\t\texcept:\n\t\t\t# Fails on compatible strings in #define, so just skip\n\t\t\tcontinue\n\t\tcompat_list += [compat]\n\n\treturn compat_list\n\n\ndef parse_of_device_id(data):\n\t\"\"\" Find all compatible strings in of_device_id structs \"\"\"\n\tcompat_list = []\n\tfor m in re.finditer(r'of_device_id(\\s+\\S+)?\\s+\\S+\\[\\](\\s+\\S+)?\\s*=\\s*({.*?);', data):\n\t\tcompat_list += re.findall(r'\\.compatible\\s+=\\s+\"(\\S+)\"', m[3])\n\n\treturn compat_list\n\n\ndef parse_compatibles(file):\n\twith open(file, 'r', encoding='utf-8') as f:\n\t\tdata = f.read().replace('\\n', '')\n\n\tcompat_list = parse_of_declare_macros(data)\n\tcompat_list += parse_of_device_id(data)\n\n\treturn compat_list\n\ndef print_compat(filename, compatibles):\n\tif not compatibles:\n\t\treturn\n\tif show_filename:\n\t\tcompat_str = ' '.join(compatibles)\n\t\tprint(filename + \": compatible(s): \" + compat_str)\n\telse:\n\t\tprint(*compatibles, sep='\\n')\n\ndef glob_without_symlinks(root, glob):\n\tfor path, dirs, files in os.walk(root):\n\t\t# Ignore hidden directories\n\t\tfor d in dirs:\n\t\t\tif fnmatch.fnmatch(d, \".*\"):\n\t\t\t\tdirs.remove(d)\n\t\tfor f in files:\n\t\t\tif fnmatch.fnmatch(f, glob):\n\t\t\t\tyield os.path.join(path, f)\n\ndef files_to_parse(path_args):\n\tfor f in path_args:\n\t\tif os.path.isdir(f):\n\t\t\tfor filename in glob_without_symlinks(f, \"*.c\"):\n\t\t\t\tyield filename\n\t\telse:\n\t\t\tyield f\n\nshow_filename = False\n\nif __name__ == \"__main__\":\n\tap = argparse.ArgumentParser()\n\tap.add_argument(\"cfile\", type=str, nargs='*', help=\"C source files or directories to parse\")\n\tap.add_argument('-H', '--with-filename', help=\"Print filename with compatibles\", action=\"store_true\")\n\targs = ap.parse_args()\n\n\tshow_filename = args.with_filename\n\n\tfor f in files_to_parse(args.cfile):\n\t\tcompat_list = parse_compatibles(f)\n\t\tprint_compat(f, compat_list)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}