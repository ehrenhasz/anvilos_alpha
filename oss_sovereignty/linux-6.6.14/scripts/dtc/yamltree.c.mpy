{
  "module_name": "yamltree.c",
  "hash_id": "afb6aa85e95104ba04fbe862ee252da7fb9e94035bca784886a976090f08b180",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/yamltree.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <yaml.h>\n#include \"dtc.h\"\n#include \"srcpos.h\"\n\nchar *yaml_error_name[] = {\n\t[YAML_NO_ERROR] = \"no error\",\n\t[YAML_MEMORY_ERROR] = \"memory error\",\n\t[YAML_READER_ERROR] = \"reader error\",\n\t[YAML_SCANNER_ERROR] = \"scanner error\",\n\t[YAML_PARSER_ERROR] = \"parser error\",\n\t[YAML_COMPOSER_ERROR] = \"composer error\",\n\t[YAML_WRITER_ERROR] = \"writer error\",\n\t[YAML_EMITTER_ERROR] = \"emitter error\",\n};\n\n#define yaml_emitter_emit_or_die(emitter, event) (\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (!yaml_emitter_emit(emitter, event))\t\t\t\t\\\n\t\tdie(\"yaml '%s': %s in %s, line %i\\n\",\t\t\t\\\n\t\t    yaml_error_name[(emitter)->error], \t\t\t\\\n\t\t    (emitter)->problem, __func__, __LINE__);\t\t\\\n})\n\nstatic void yaml_propval_int(yaml_emitter_t *emitter, struct marker *markers,\n\tchar *data, unsigned int seq_offset, unsigned int len, int width)\n{\n\tyaml_event_t event;\n\tvoid *tag;\n\tunsigned int off;\n\n\tswitch(width) {\n\t\tcase 1: tag = \"!u8\"; break;\n\t\tcase 2: tag = \"!u16\"; break;\n\t\tcase 4: tag = \"!u32\"; break;\n\t\tcase 8: tag = \"!u64\"; break;\n\t\tdefault:\n\t\t\tdie(\"Invalid width %i\", width);\n\t}\n\tassert(len % width == 0);\n\n\tyaml_sequence_start_event_initialize(&event, NULL,\n\t\t(yaml_char_t *)tag, width == 4, YAML_FLOW_SEQUENCE_STYLE);\n\tyaml_emitter_emit_or_die(emitter, &event);\n\n\tfor (off = 0; off < len; off += width) {\n\t\tchar buf[32];\n\t\tstruct marker *m;\n\t\tbool is_phandle = false;\n\n\t\tswitch(width) {\n\t\tcase 1:\n\t\t\tsprintf(buf, \"0x%\"PRIx8, *(uint8_t*)(data + off));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsprintf(buf, \"0x%\"PRIx16, dtb_ld16(data + off));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tsprintf(buf, \"0x%\"PRIx32, dtb_ld32(data + off));\n\t\t\tm = markers;\n\t\t\tis_phandle = false;\n\t\t\tfor_each_marker_of_type(m, REF_PHANDLE) {\n\t\t\t\tif (m->offset == (seq_offset + off)) {\n\t\t\t\t\tis_phandle = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsprintf(buf, \"0x%\"PRIx64, dtb_ld64(data + off));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_phandle)\n\t\t\tyaml_scalar_event_initialize(&event, NULL,\n\t\t\t\t(yaml_char_t*)\"!phandle\", (yaml_char_t *)buf,\n\t\t\t\tstrlen(buf), 0, 0, YAML_PLAIN_SCALAR_STYLE);\n\t\telse\n\t\t\tyaml_scalar_event_initialize(&event, NULL,\n\t\t\t\t(yaml_char_t*)YAML_INT_TAG, (yaml_char_t *)buf,\n\t\t\t\tstrlen(buf), 1, 1, YAML_PLAIN_SCALAR_STYLE);\n\t\tyaml_emitter_emit_or_die(emitter, &event);\n\t}\n\n\tyaml_sequence_end_event_initialize(&event);\n\tyaml_emitter_emit_or_die(emitter, &event);\n}\n\nstatic void yaml_propval_string(yaml_emitter_t *emitter, char *str, int len)\n{\n\tyaml_event_t event;\n\tint i;\n\n\tassert(str[len-1] == '\\0');\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tassert(isascii(str[i]));\n\n\tyaml_scalar_event_initialize(&event, NULL,\n\t\t(yaml_char_t *)YAML_STR_TAG, (yaml_char_t*)str,\n\t\tlen-1, 0, 1, YAML_DOUBLE_QUOTED_SCALAR_STYLE);\n\tyaml_emitter_emit_or_die(emitter, &event);\n}\n\nstatic void yaml_propval(yaml_emitter_t *emitter, struct property *prop)\n{\n\tyaml_event_t event;\n\tunsigned int len = prop->val.len;\n\tstruct marker *m = prop->val.markers;\n\tstruct marker *markers = prop->val.markers;\n\n\t \n\tyaml_scalar_event_initialize(&event, NULL,\n\t\t(yaml_char_t *)YAML_STR_TAG, (yaml_char_t*)prop->name,\n\t\tstrlen(prop->name), 1, 1, YAML_PLAIN_SCALAR_STYLE);\n\tyaml_emitter_emit_or_die(emitter, &event);\n\n\t \n\tif (len == 0) {\n\t\tyaml_scalar_event_initialize(&event, NULL,\n\t\t\t(yaml_char_t *)YAML_BOOL_TAG,\n\t\t\t(yaml_char_t*)\"true\",\n\t\t\tstrlen(\"true\"), 1, 0, YAML_PLAIN_SCALAR_STYLE);\n\t\tyaml_emitter_emit_or_die(emitter, &event);\n\t\treturn;\n\t}\n\n\tif (!m)\n\t\tdie(\"No markers present in property '%s' value\\n\", prop->name);\n\n\tyaml_sequence_start_event_initialize(&event, NULL,\n\t\t(yaml_char_t *)YAML_SEQ_TAG, 1, YAML_FLOW_SEQUENCE_STYLE);\n\tyaml_emitter_emit_or_die(emitter, &event);\n\n\tfor_each_marker(m) {\n\t\tint chunk_len;\n\t\tchar *data = &prop->val.val[m->offset];\n\n\t\tif (m->type < TYPE_UINT8)\n\t\t\tcontinue;\n\n\t\tchunk_len = type_marker_length(m) ? : len;\n\t\tassert(chunk_len > 0);\n\t\tlen -= chunk_len;\n\n\t\tswitch(m->type) {\n\t\tcase TYPE_UINT16:\n\t\t\tyaml_propval_int(emitter, markers, data, m->offset, chunk_len, 2);\n\t\t\tbreak;\n\t\tcase TYPE_UINT32:\n\t\t\tyaml_propval_int(emitter, markers, data, m->offset, chunk_len, 4);\n\t\t\tbreak;\n\t\tcase TYPE_UINT64:\n\t\t\tyaml_propval_int(emitter, markers, data, m->offset, chunk_len, 8);\n\t\t\tbreak;\n\t\tcase TYPE_STRING:\n\t\t\tyaml_propval_string(emitter, data, chunk_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tyaml_propval_int(emitter, markers, data, m->offset, chunk_len, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tyaml_sequence_end_event_initialize(&event);\n\tyaml_emitter_emit_or_die(emitter, &event);\n}\n\n\nstatic void yaml_tree(struct node *tree, yaml_emitter_t *emitter)\n{\n\tstruct property *prop;\n\tstruct node *child;\n\tyaml_event_t event;\n\n\tif (tree->deleted)\n\t\treturn;\n\n\tyaml_mapping_start_event_initialize(&event, NULL,\n\t\t(yaml_char_t *)YAML_MAP_TAG, 1, YAML_ANY_MAPPING_STYLE);\n\tyaml_emitter_emit_or_die(emitter, &event);\n\n\tfor_each_property(tree, prop)\n\t\tyaml_propval(emitter, prop);\n\n\t \n\tfor_each_child(tree, child) {\n\t\tyaml_scalar_event_initialize(&event, NULL,\n\t\t\t(yaml_char_t *)YAML_STR_TAG, (yaml_char_t*)child->name,\n\t\t\tstrlen(child->name), 1, 0, YAML_PLAIN_SCALAR_STYLE);\n\t\tyaml_emitter_emit_or_die(emitter, &event);\n\t\tyaml_tree(child, emitter);\n\t}\n\n\tyaml_mapping_end_event_initialize(&event);\n\tyaml_emitter_emit_or_die(emitter, &event);\n}\n\nvoid dt_to_yaml(FILE *f, struct dt_info *dti)\n{\n\tyaml_emitter_t emitter;\n\tyaml_event_t event;\n\n\tyaml_emitter_initialize(&emitter);\n\tyaml_emitter_set_output_file(&emitter, f);\n\tyaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);\n\tyaml_emitter_emit_or_die(&emitter, &event);\n\n\tyaml_document_start_event_initialize(&event, NULL, NULL, NULL, 0);\n\tyaml_emitter_emit_or_die(&emitter, &event);\n\n\tyaml_sequence_start_event_initialize(&event, NULL, (yaml_char_t *)YAML_SEQ_TAG, 1, YAML_ANY_SEQUENCE_STYLE);\n\tyaml_emitter_emit_or_die(&emitter, &event);\n\n\tyaml_tree(dti->dt, &emitter);\n\n\tyaml_sequence_end_event_initialize(&event);\n\tyaml_emitter_emit_or_die(&emitter, &event);\n\n\tyaml_document_end_event_initialize(&event, 0);\n\tyaml_emitter_emit_or_die(&emitter, &event);\n\n\tyaml_stream_end_event_initialize(&event);\n\tyaml_emitter_emit_or_die(&emitter, &event);\n\n\tyaml_emitter_delete(&emitter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}