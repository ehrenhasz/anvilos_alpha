{
  "module_name": "livetree.c",
  "hash_id": "9036129b478d5f18c3c7dbe518052100dc80e7fceabc6a2075e410e88b21a066",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/livetree.c",
  "human_readable_source": "\n \n\n#include \"dtc.h\"\n#include \"srcpos.h\"\n\n \n\nvoid add_label(struct label **labels, char *label)\n{\n\tstruct label *new;\n\n\t \n\tfor_each_label_withdel(*labels, new)\n\t\tif (streq(new->label, label)) {\n\t\t\tnew->deleted = 0;\n\t\t\treturn;\n\t\t}\n\n\tnew = xmalloc(sizeof(*new));\n\tmemset(new, 0, sizeof(*new));\n\tnew->label = label;\n\tnew->next = *labels;\n\t*labels = new;\n}\n\nvoid delete_labels(struct label **labels)\n{\n\tstruct label *label;\n\n\tfor_each_label(*labels, label)\n\t\tlabel->deleted = 1;\n}\n\nstruct property *build_property(char *name, struct data val,\n\t\t\t\tstruct srcpos *srcpos)\n{\n\tstruct property *new = xmalloc(sizeof(*new));\n\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->name = name;\n\tnew->val = val;\n\tnew->srcpos = srcpos_copy(srcpos);\n\n\treturn new;\n}\n\nstruct property *build_property_delete(char *name)\n{\n\tstruct property *new = xmalloc(sizeof(*new));\n\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->name = name;\n\tnew->deleted = 1;\n\n\treturn new;\n}\n\nstruct property *chain_property(struct property *first, struct property *list)\n{\n\tassert(first->next == NULL);\n\n\tfirst->next = list;\n\treturn first;\n}\n\nstruct property *reverse_properties(struct property *first)\n{\n\tstruct property *p = first;\n\tstruct property *head = NULL;\n\tstruct property *next;\n\n\twhile (p) {\n\t\tnext = p->next;\n\t\tp->next = head;\n\t\thead = p;\n\t\tp = next;\n\t}\n\treturn head;\n}\n\nstruct node *build_node(struct property *proplist, struct node *children,\n\t\t\tstruct srcpos *srcpos)\n{\n\tstruct node *new = xmalloc(sizeof(*new));\n\tstruct node *child;\n\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->proplist = reverse_properties(proplist);\n\tnew->children = children;\n\tnew->srcpos = srcpos_copy(srcpos);\n\n\tfor_each_child(new, child) {\n\t\tchild->parent = new;\n\t}\n\n\treturn new;\n}\n\nstruct node *build_node_delete(struct srcpos *srcpos)\n{\n\tstruct node *new = xmalloc(sizeof(*new));\n\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->deleted = 1;\n\tnew->srcpos = srcpos_copy(srcpos);\n\n\treturn new;\n}\n\nstruct node *name_node(struct node *node, char *name)\n{\n\tassert(node->name == NULL);\n\n\tnode->name = name;\n\n\treturn node;\n}\n\nstruct node *omit_node_if_unused(struct node *node)\n{\n\tnode->omit_if_unused = 1;\n\n\treturn node;\n}\n\nstruct node *reference_node(struct node *node)\n{\n\tnode->is_referenced = 1;\n\n\treturn node;\n}\n\nstruct node *merge_nodes(struct node *old_node, struct node *new_node)\n{\n\tstruct property *new_prop, *old_prop;\n\tstruct node *new_child, *old_child;\n\tstruct label *l;\n\n\told_node->deleted = 0;\n\n\t \n\tfor_each_label_withdel(new_node->labels, l)\n\t\tadd_label(&old_node->labels, l->label);\n\n\t \n\twhile (new_node->proplist) {\n\t\t \n\t\tnew_prop = new_node->proplist;\n\t\tnew_node->proplist = new_prop->next;\n\t\tnew_prop->next = NULL;\n\n\t\tif (new_prop->deleted) {\n\t\t\tdelete_property_by_name(old_node, new_prop->name);\n\t\t\tfree(new_prop);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor_each_property_withdel(old_node, old_prop) {\n\t\t\tif (streq(old_prop->name, new_prop->name)) {\n\t\t\t\t \n\t\t\t\tfor_each_label_withdel(new_prop->labels, l)\n\t\t\t\t\tadd_label(&old_prop->labels, l->label);\n\n\t\t\t\told_prop->val = new_prop->val;\n\t\t\t\told_prop->deleted = 0;\n\t\t\t\tfree(old_prop->srcpos);\n\t\t\t\told_prop->srcpos = new_prop->srcpos;\n\t\t\t\tfree(new_prop);\n\t\t\t\tnew_prop = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (new_prop)\n\t\t\tadd_property(old_node, new_prop);\n\t}\n\n\t \n\twhile (new_node->children) {\n\t\t \n\t\tnew_child = new_node->children;\n\t\tnew_node->children = new_child->next_sibling;\n\t\tnew_child->parent = NULL;\n\t\tnew_child->next_sibling = NULL;\n\n\t\tif (new_child->deleted) {\n\t\t\tdelete_node_by_name(old_node, new_child->name);\n\t\t\tfree(new_child);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor_each_child_withdel(old_node, old_child) {\n\t\t\tif (streq(old_child->name, new_child->name)) {\n\t\t\t\tmerge_nodes(old_child, new_child);\n\t\t\t\tnew_child = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (new_child)\n\t\t\tadd_child(old_node, new_child);\n\t}\n\n\told_node->srcpos = srcpos_extend(old_node->srcpos, new_node->srcpos);\n\n\t \n\tfree(new_node);\n\n\treturn old_node;\n}\n\nstruct node * add_orphan_node(struct node *dt, struct node *new_node, char *ref)\n{\n\tstatic unsigned int next_orphan_fragment = 0;\n\tstruct node *node;\n\tstruct property *p;\n\tstruct data d = empty_data;\n\tchar *name;\n\n\tif (ref[0] == '/') {\n\t\td = data_add_marker(d, TYPE_STRING, ref);\n\t\td = data_append_data(d, ref, strlen(ref) + 1);\n\n\t\tp = build_property(\"target-path\", d, NULL);\n\t} else {\n\t\td = data_add_marker(d, REF_PHANDLE, ref);\n\t\td = data_append_integer(d, 0xffffffff, 32);\n\n\t\tp = build_property(\"target\", d, NULL);\n\t}\n\n\txasprintf(&name, \"fragment@%u\",\n\t\t\tnext_orphan_fragment++);\n\tname_node(new_node, \"__overlay__\");\n\tnode = build_node(p, new_node, NULL);\n\tname_node(node, name);\n\n\tadd_child(dt, node);\n\treturn dt;\n}\n\nstruct node *chain_node(struct node *first, struct node *list)\n{\n\tassert(first->next_sibling == NULL);\n\n\tfirst->next_sibling = list;\n\treturn first;\n}\n\nvoid add_property(struct node *node, struct property *prop)\n{\n\tstruct property **p;\n\n\tprop->next = NULL;\n\n\tp = &node->proplist;\n\twhile (*p)\n\t\tp = &((*p)->next);\n\n\t*p = prop;\n}\n\nvoid delete_property_by_name(struct node *node, char *name)\n{\n\tstruct property *prop = node->proplist;\n\n\twhile (prop) {\n\t\tif (streq(prop->name, name)) {\n\t\t\tdelete_property(prop);\n\t\t\treturn;\n\t\t}\n\t\tprop = prop->next;\n\t}\n}\n\nvoid delete_property(struct property *prop)\n{\n\tprop->deleted = 1;\n\tdelete_labels(&prop->labels);\n}\n\nvoid add_child(struct node *parent, struct node *child)\n{\n\tstruct node **p;\n\n\tchild->next_sibling = NULL;\n\tchild->parent = parent;\n\n\tp = &parent->children;\n\twhile (*p)\n\t\tp = &((*p)->next_sibling);\n\n\t*p = child;\n}\n\nvoid delete_node_by_name(struct node *parent, char *name)\n{\n\tstruct node *node = parent->children;\n\n\twhile (node) {\n\t\tif (streq(node->name, name)) {\n\t\t\tdelete_node(node);\n\t\t\treturn;\n\t\t}\n\t\tnode = node->next_sibling;\n\t}\n}\n\nvoid delete_node(struct node *node)\n{\n\tstruct property *prop;\n\tstruct node *child;\n\n\tnode->deleted = 1;\n\tfor_each_child(node, child)\n\t\tdelete_node(child);\n\tfor_each_property(node, prop)\n\t\tdelete_property(prop);\n\tdelete_labels(&node->labels);\n}\n\nvoid append_to_property(struct node *node,\n\t\t\tchar *name, const void *data, int len,\n\t\t\tenum markertype type)\n{\n\tstruct data d;\n\tstruct property *p;\n\n\tp = get_property(node, name);\n\tif (p) {\n\t\td = data_add_marker(p->val, type, name);\n\t\td = data_append_data(d, data, len);\n\t\tp->val = d;\n\t} else {\n\t\td = data_add_marker(empty_data, type, name);\n\t\td = data_append_data(d, data, len);\n\t\tp = build_property(name, d, NULL);\n\t\tadd_property(node, p);\n\t}\n}\n\nstruct reserve_info *build_reserve_entry(uint64_t address, uint64_t size)\n{\n\tstruct reserve_info *new = xmalloc(sizeof(*new));\n\n\tmemset(new, 0, sizeof(*new));\n\n\tnew->address = address;\n\tnew->size = size;\n\n\treturn new;\n}\n\nstruct reserve_info *chain_reserve_entry(struct reserve_info *first,\n\t\t\t\t\tstruct reserve_info *list)\n{\n\tassert(first->next == NULL);\n\n\tfirst->next = list;\n\treturn first;\n}\n\nstruct reserve_info *add_reserve_entry(struct reserve_info *list,\n\t\t\t\t      struct reserve_info *new)\n{\n\tstruct reserve_info *last;\n\n\tnew->next = NULL;\n\n\tif (! list)\n\t\treturn new;\n\n\tfor (last = list; last->next; last = last->next)\n\t\t;\n\n\tlast->next = new;\n\n\treturn list;\n}\n\nstruct dt_info *build_dt_info(unsigned int dtsflags,\n\t\t\t      struct reserve_info *reservelist,\n\t\t\t      struct node *tree, uint32_t boot_cpuid_phys)\n{\n\tstruct dt_info *dti;\n\n\tdti = xmalloc(sizeof(*dti));\n\tdti->dtsflags = dtsflags;\n\tdti->reservelist = reservelist;\n\tdti->dt = tree;\n\tdti->boot_cpuid_phys = boot_cpuid_phys;\n\n\treturn dti;\n}\n\n \n\nconst char *get_unitname(struct node *node)\n{\n\tif (node->name[node->basenamelen] == '\\0')\n\t\treturn \"\";\n\telse\n\t\treturn node->name + node->basenamelen + 1;\n}\n\nstruct property *get_property(struct node *node, const char *propname)\n{\n\tstruct property *prop;\n\n\tfor_each_property(node, prop)\n\t\tif (streq(prop->name, propname))\n\t\t\treturn prop;\n\n\treturn NULL;\n}\n\ncell_t propval_cell(struct property *prop)\n{\n\tassert(prop->val.len == sizeof(cell_t));\n\treturn fdt32_to_cpu(*((fdt32_t *)prop->val.val));\n}\n\ncell_t propval_cell_n(struct property *prop, unsigned int n)\n{\n\tassert(prop->val.len / sizeof(cell_t) >= n);\n\treturn fdt32_to_cpu(*((fdt32_t *)prop->val.val + n));\n}\n\nstruct property *get_property_by_label(struct node *tree, const char *label,\n\t\t\t\t       struct node **node)\n{\n\tstruct property *prop;\n\tstruct node *c;\n\n\t*node = tree;\n\n\tfor_each_property(tree, prop) {\n\t\tstruct label *l;\n\n\t\tfor_each_label(prop->labels, l)\n\t\t\tif (streq(l->label, label))\n\t\t\t\treturn prop;\n\t}\n\n\tfor_each_child(tree, c) {\n\t\tprop = get_property_by_label(c, label, node);\n\t\tif (prop)\n\t\t\treturn prop;\n\t}\n\n\t*node = NULL;\n\treturn NULL;\n}\n\nstruct marker *get_marker_label(struct node *tree, const char *label,\n\t\t\t\tstruct node **node, struct property **prop)\n{\n\tstruct marker *m;\n\tstruct property *p;\n\tstruct node *c;\n\n\t*node = tree;\n\n\tfor_each_property(tree, p) {\n\t\t*prop = p;\n\t\tm = p->val.markers;\n\t\tfor_each_marker_of_type(m, LABEL)\n\t\t\tif (streq(m->ref, label))\n\t\t\t\treturn m;\n\t}\n\n\tfor_each_child(tree, c) {\n\t\tm = get_marker_label(c, label, node, prop);\n\t\tif (m)\n\t\t\treturn m;\n\t}\n\n\t*prop = NULL;\n\t*node = NULL;\n\treturn NULL;\n}\n\nstruct node *get_subnode(struct node *node, const char *nodename)\n{\n\tstruct node *child;\n\n\tfor_each_child(node, child)\n\t\tif (streq(child->name, nodename))\n\t\t\treturn child;\n\n\treturn NULL;\n}\n\nstruct node *get_node_by_path(struct node *tree, const char *path)\n{\n\tconst char *p;\n\tstruct node *child;\n\n\tif (!path || ! (*path)) {\n\t\tif (tree->deleted)\n\t\t\treturn NULL;\n\t\treturn tree;\n\t}\n\n\twhile (path[0] == '/')\n\t\tpath++;\n\n\tp = strchr(path, '/');\n\n\tfor_each_child(tree, child) {\n\t\tif (p && strprefixeq(path, (size_t)(p - path), child->name))\n\t\t\treturn get_node_by_path(child, p+1);\n\t\telse if (!p && streq(path, child->name))\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}\n\nstruct node *get_node_by_label(struct node *tree, const char *label)\n{\n\tstruct node *child, *node;\n\tstruct label *l;\n\n\tassert(label && (strlen(label) > 0));\n\n\tfor_each_label(tree->labels, l)\n\t\tif (streq(l->label, label))\n\t\t\treturn tree;\n\n\tfor_each_child(tree, child) {\n\t\tnode = get_node_by_label(child, label);\n\t\tif (node)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\nstruct node *get_node_by_phandle(struct node *tree, cell_t phandle)\n{\n\tstruct node *child, *node;\n\n\tif (!phandle_is_valid(phandle)) {\n\t\tassert(generate_fixups);\n\t\treturn NULL;\n\t}\n\n\tif (tree->phandle == phandle) {\n\t\tif (tree->deleted)\n\t\t\treturn NULL;\n\t\treturn tree;\n\t}\n\n\tfor_each_child(tree, child) {\n\t\tnode = get_node_by_phandle(child, phandle);\n\t\tif (node)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\nstruct node *get_node_by_ref(struct node *tree, const char *ref)\n{\n\tstruct node *target = tree;\n\tconst char *label = NULL, *path = NULL;\n\n\tif (streq(ref, \"/\"))\n\t\treturn tree;\n\n\tif (ref[0] == '/')\n\t\tpath = ref;\n\telse\n\t\tlabel = ref;\n\n\tif (label) {\n\t\tconst char *slash = strchr(label, '/');\n\t\tchar *buf = NULL;\n\n\t\tif (slash) {\n\t\t\tbuf = xstrndup(label, slash - label);\n\t\t\tlabel = buf;\n\t\t\tpath = slash + 1;\n\t\t}\n\n\t\ttarget = get_node_by_label(tree, label);\n\n\t\tfree(buf);\n\n\t\tif (!target)\n\t\t\treturn NULL;\n\t}\n\n\tif (path)\n\t\ttarget = get_node_by_path(target, path);\n\n\treturn target;\n}\n\ncell_t get_node_phandle(struct node *root, struct node *node)\n{\n\tstatic cell_t phandle = 1;  \n\tstruct data d = empty_data;\n\n\tif (phandle_is_valid(node->phandle))\n\t\treturn node->phandle;\n\n\twhile (get_node_by_phandle(root, phandle))\n\t\tphandle++;\n\n\tnode->phandle = phandle;\n\n\td = data_add_marker(d, TYPE_UINT32, NULL);\n\td = data_append_cell(d, phandle);\n\n\tif (!get_property(node, \"linux,phandle\")\n\t    && (phandle_format & PHANDLE_LEGACY))\n\t\tadd_property(node, build_property(\"linux,phandle\", d, NULL));\n\n\tif (!get_property(node, \"phandle\")\n\t    && (phandle_format & PHANDLE_EPAPR))\n\t\tadd_property(node, build_property(\"phandle\", d, NULL));\n\n\t \n\n\treturn node->phandle;\n}\n\nuint32_t guess_boot_cpuid(struct node *tree)\n{\n\tstruct node *cpus, *bootcpu;\n\tstruct property *reg;\n\n\tcpus = get_node_by_path(tree, \"/cpus\");\n\tif (!cpus)\n\t\treturn 0;\n\n\n\tbootcpu = cpus->children;\n\tif (!bootcpu)\n\t\treturn 0;\n\n\treg = get_property(bootcpu, \"reg\");\n\tif (!reg || (reg->val.len != sizeof(uint32_t)))\n\t\treturn 0;\n\n\t \n\n\treturn propval_cell(reg);\n}\n\nstatic int cmp_reserve_info(const void *ax, const void *bx)\n{\n\tconst struct reserve_info *a, *b;\n\n\ta = *((const struct reserve_info * const *)ax);\n\tb = *((const struct reserve_info * const *)bx);\n\n\tif (a->address < b->address)\n\t\treturn -1;\n\telse if (a->address > b->address)\n\t\treturn 1;\n\telse if (a->size < b->size)\n\t\treturn -1;\n\telse if (a->size > b->size)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void sort_reserve_entries(struct dt_info *dti)\n{\n\tstruct reserve_info *ri, **tbl;\n\tint n = 0, i = 0;\n\n\tfor (ri = dti->reservelist;\n\t     ri;\n\t     ri = ri->next)\n\t\tn++;\n\n\tif (n == 0)\n\t\treturn;\n\n\ttbl = xmalloc(n * sizeof(*tbl));\n\n\tfor (ri = dti->reservelist;\n\t     ri;\n\t     ri = ri->next)\n\t\ttbl[i++] = ri;\n\n\tqsort(tbl, n, sizeof(*tbl), cmp_reserve_info);\n\n\tdti->reservelist = tbl[0];\n\tfor (i = 0; i < (n-1); i++)\n\t\ttbl[i]->next = tbl[i+1];\n\ttbl[n-1]->next = NULL;\n\n\tfree(tbl);\n}\n\nstatic int cmp_prop(const void *ax, const void *bx)\n{\n\tconst struct property *a, *b;\n\n\ta = *((const struct property * const *)ax);\n\tb = *((const struct property * const *)bx);\n\n\treturn strcmp(a->name, b->name);\n}\n\nstatic void sort_properties(struct node *node)\n{\n\tint n = 0, i = 0;\n\tstruct property *prop, **tbl;\n\n\tfor_each_property_withdel(node, prop)\n\t\tn++;\n\n\tif (n == 0)\n\t\treturn;\n\n\ttbl = xmalloc(n * sizeof(*tbl));\n\n\tfor_each_property_withdel(node, prop)\n\t\ttbl[i++] = prop;\n\n\tqsort(tbl, n, sizeof(*tbl), cmp_prop);\n\n\tnode->proplist = tbl[0];\n\tfor (i = 0; i < (n-1); i++)\n\t\ttbl[i]->next = tbl[i+1];\n\ttbl[n-1]->next = NULL;\n\n\tfree(tbl);\n}\n\nstatic int cmp_subnode(const void *ax, const void *bx)\n{\n\tconst struct node *a, *b;\n\n\ta = *((const struct node * const *)ax);\n\tb = *((const struct node * const *)bx);\n\n\treturn strcmp(a->name, b->name);\n}\n\nstatic void sort_subnodes(struct node *node)\n{\n\tint n = 0, i = 0;\n\tstruct node *subnode, **tbl;\n\n\tfor_each_child_withdel(node, subnode)\n\t\tn++;\n\n\tif (n == 0)\n\t\treturn;\n\n\ttbl = xmalloc(n * sizeof(*tbl));\n\n\tfor_each_child_withdel(node, subnode)\n\t\ttbl[i++] = subnode;\n\n\tqsort(tbl, n, sizeof(*tbl), cmp_subnode);\n\n\tnode->children = tbl[0];\n\tfor (i = 0; i < (n-1); i++)\n\t\ttbl[i]->next_sibling = tbl[i+1];\n\ttbl[n-1]->next_sibling = NULL;\n\n\tfree(tbl);\n}\n\nstatic void sort_node(struct node *node)\n{\n\tstruct node *c;\n\n\tsort_properties(node);\n\tsort_subnodes(node);\n\tfor_each_child_withdel(node, c)\n\t\tsort_node(c);\n}\n\nvoid sort_tree(struct dt_info *dti)\n{\n\tsort_reserve_entries(dti);\n\tsort_node(dti->dt);\n}\n\n \nstatic struct node *build_and_name_child_node(struct node *parent, char *name)\n{\n\tstruct node *node;\n\n\tnode = build_node(NULL, NULL, NULL);\n\tname_node(node, xstrdup(name));\n\tadd_child(parent, node);\n\n\treturn node;\n}\n\nstatic struct node *build_root_node(struct node *dt, char *name)\n{\n\tstruct node *an;\n\n\tan = get_subnode(dt, name);\n\tif (!an)\n\t\tan = build_and_name_child_node(dt, name);\n\n\tif (!an)\n\t\tdie(\"Could not build root node /%s\\n\", name);\n\n\treturn an;\n}\n\nstatic bool any_label_tree(struct dt_info *dti, struct node *node)\n{\n\tstruct node *c;\n\n\tif (node->labels)\n\t\treturn true;\n\n\tfor_each_child(node, c)\n\t\tif (any_label_tree(dti, c))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void generate_label_tree_internal(struct dt_info *dti,\n\t\t\t\t\t struct node *an, struct node *node,\n\t\t\t\t\t bool allocph)\n{\n\tstruct node *dt = dti->dt;\n\tstruct node *c;\n\tstruct property *p;\n\tstruct label *l;\n\n\t \n\tif (node->labels) {\n\n\t\t \n\t\tfor_each_label(node->labels, l) {\n\n\t\t\t \n\t\t\tp = get_property(an, l->label);\n\t\t\tif (p) {\n\t\t\t\tfprintf(stderr, \"WARNING: label %s already\"\n\t\t\t\t\t\" exists in /%s\", l->label,\n\t\t\t\t\tan->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tp = build_property(l->label,\n\t\t\t\tdata_copy_escape_string(node->fullpath,\n\t\t\t\t\t\tstrlen(node->fullpath)),\n\t\t\t\tNULL);\n\t\t\tadd_property(an, p);\n\t\t}\n\n\t\t \n\t\tif (allocph)\n\t\t\t(void)get_node_phandle(dt, node);\n\t}\n\n\tfor_each_child(node, c)\n\t\tgenerate_label_tree_internal(dti, an, c, allocph);\n}\n\nstatic bool any_fixup_tree(struct dt_info *dti, struct node *node)\n{\n\tstruct node *c;\n\tstruct property *prop;\n\tstruct marker *m;\n\n\tfor_each_property(node, prop) {\n\t\tm = prop->val.markers;\n\t\tfor_each_marker_of_type(m, REF_PHANDLE) {\n\t\t\tif (!get_node_by_ref(dti->dt, m->ref))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor_each_child(node, c) {\n\t\tif (any_fixup_tree(dti, c))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void add_fixup_entry(struct dt_info *dti, struct node *fn,\n\t\t\t    struct node *node, struct property *prop,\n\t\t\t    struct marker *m)\n{\n\tchar *entry;\n\n\t \n\tassert(m->type == REF_PHANDLE);\n\n\t \n\tif (strchr(m->ref, '/'))\n\t\tdie(\"Can't generate fixup for reference to path &{%s}\\n\",\n\t\t    m->ref);\n\n\t \n\tif (strchr(node->fullpath, ':') || strchr(prop->name, ':'))\n\t\tdie(\"arguments should not contain ':'\\n\");\n\n\txasprintf(&entry, \"%s:%s:%u\",\n\t\t\tnode->fullpath, prop->name, m->offset);\n\tappend_to_property(fn, m->ref, entry, strlen(entry) + 1, TYPE_STRING);\n\n\tfree(entry);\n}\n\nstatic void generate_fixups_tree_internal(struct dt_info *dti,\n\t\t\t\t\t  struct node *fn,\n\t\t\t\t\t  struct node *node)\n{\n\tstruct node *dt = dti->dt;\n\tstruct node *c;\n\tstruct property *prop;\n\tstruct marker *m;\n\tstruct node *refnode;\n\n\tfor_each_property(node, prop) {\n\t\tm = prop->val.markers;\n\t\tfor_each_marker_of_type(m, REF_PHANDLE) {\n\t\t\trefnode = get_node_by_ref(dt, m->ref);\n\t\t\tif (!refnode)\n\t\t\t\tadd_fixup_entry(dti, fn, node, prop, m);\n\t\t}\n\t}\n\n\tfor_each_child(node, c)\n\t\tgenerate_fixups_tree_internal(dti, fn, c);\n}\n\nstatic bool any_local_fixup_tree(struct dt_info *dti, struct node *node)\n{\n\tstruct node *c;\n\tstruct property *prop;\n\tstruct marker *m;\n\n\tfor_each_property(node, prop) {\n\t\tm = prop->val.markers;\n\t\tfor_each_marker_of_type(m, REF_PHANDLE) {\n\t\t\tif (get_node_by_ref(dti->dt, m->ref))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor_each_child(node, c) {\n\t\tif (any_local_fixup_tree(dti, c))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void add_local_fixup_entry(struct dt_info *dti,\n\t\tstruct node *lfn, struct node *node,\n\t\tstruct property *prop, struct marker *m,\n\t\tstruct node *refnode)\n{\n\tstruct node *wn, *nwn;\t \n\tfdt32_t value_32;\n\tchar **compp;\n\tint i, depth;\n\n\t \n\tdepth = 0;\n\tfor (wn = node; wn; wn = wn->parent)\n\t\tdepth++;\n\n\t \n\tcompp = xmalloc(sizeof(*compp) * depth);\n\n\t \n\tfor (wn = node, i = depth - 1; wn; wn = wn->parent, i--)\n\t\tcompp[i] = wn->name;\n\n\t \n\tfor (wn = lfn, i = 1; i < depth; i++, wn = nwn) {\n\t\t \n\t\tnwn = get_subnode(wn, compp[i]);\n\t\tif (!nwn)\n\t\t\tnwn = build_and_name_child_node(wn, compp[i]);\n\t}\n\n\tfree(compp);\n\n\tvalue_32 = cpu_to_fdt32(m->offset);\n\tappend_to_property(wn, prop->name, &value_32, sizeof(value_32), TYPE_UINT32);\n}\n\nstatic void generate_local_fixups_tree_internal(struct dt_info *dti,\n\t\t\t\t\t\tstruct node *lfn,\n\t\t\t\t\t\tstruct node *node)\n{\n\tstruct node *dt = dti->dt;\n\tstruct node *c;\n\tstruct property *prop;\n\tstruct marker *m;\n\tstruct node *refnode;\n\n\tfor_each_property(node, prop) {\n\t\tm = prop->val.markers;\n\t\tfor_each_marker_of_type(m, REF_PHANDLE) {\n\t\t\trefnode = get_node_by_ref(dt, m->ref);\n\t\t\tif (refnode)\n\t\t\t\tadd_local_fixup_entry(dti, lfn, node, prop, m, refnode);\n\t\t}\n\t}\n\n\tfor_each_child(node, c)\n\t\tgenerate_local_fixups_tree_internal(dti, lfn, c);\n}\n\nvoid generate_label_tree(struct dt_info *dti, char *name, bool allocph)\n{\n\tif (!any_label_tree(dti, dti->dt))\n\t\treturn;\n\tgenerate_label_tree_internal(dti, build_root_node(dti->dt, name),\n\t\t\t\t     dti->dt, allocph);\n}\n\nvoid generate_fixups_tree(struct dt_info *dti, char *name)\n{\n\tif (!any_fixup_tree(dti, dti->dt))\n\t\treturn;\n\tgenerate_fixups_tree_internal(dti, build_root_node(dti->dt, name),\n\t\t\t\t      dti->dt);\n}\n\nvoid generate_local_fixups_tree(struct dt_info *dti, char *name)\n{\n\tif (!any_local_fixup_tree(dti, dti->dt))\n\t\treturn;\n\tgenerate_local_fixups_tree_internal(dti, build_root_node(dti->dt, name),\n\t\t\t\t\t    dti->dt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}