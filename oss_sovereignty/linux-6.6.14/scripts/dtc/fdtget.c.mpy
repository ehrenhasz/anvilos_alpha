{
  "module_name": "fdtget.c",
  "hash_id": "303eae8bb1c155326295494d94bca913abca3822d20617d836f5944a4ab2f99c",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/fdtget.c",
  "human_readable_source": "\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <libfdt.h>\n\n#include \"util.h\"\n\nenum display_mode {\n\tMODE_SHOW_VALUE,\t \n\tMODE_LIST_PROPS,\t \n\tMODE_LIST_SUBNODES,\t \n};\n\n \nstruct display_info {\n\tint type;\t\t \n\tint size;\t\t \n\tenum display_mode mode;\t \n\tconst char *default_val;  \n};\n\nstatic void report_error(const char *where, int err)\n{\n\tfprintf(stderr, \"Error at '%s': %s\\n\", where, fdt_strerror(err));\n}\n\n \nstatic int show_data(struct display_info *disp, const char *data, int len)\n{\n\tint i, size;\n\tconst uint8_t *p = (const uint8_t *)data;\n\tconst char *s;\n\tint value;\n\tint is_string;\n\tchar fmt[3];\n\n\t \n\tif (len == 0)\n\t\treturn 0;\n\n\tis_string = (disp->type) == 's' ||\n\t\t(!disp->type && util_is_printable_string(data, len));\n\tif (is_string) {\n\t\tif (data[len - 1] != '\\0') {\n\t\t\tfprintf(stderr, \"Unterminated string\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tfor (s = data; s - data < len; s += strlen(s) + 1) {\n\t\t\tif (s != data)\n\t\t\t\tprintf(\" \");\n\t\t\tprintf(\"%s\", (const char *)s);\n\t\t}\n\t\treturn 0;\n\t}\n\tsize = disp->size;\n\tif (size == -1) {\n\t\tsize = (len % 4) == 0 ? 4 : 1;\n\t} else if (len % size) {\n\t\tfprintf(stderr, \"Property length must be a multiple of \"\n\t\t\t\t\"selected data size\\n\");\n\t\treturn -1;\n\t}\n\tfmt[0] = '%';\n\tfmt[1] = disp->type ? disp->type : 'd';\n\tfmt[2] = '\\0';\n\tfor (i = 0; i < len; i += size, p += size) {\n\t\tif (i)\n\t\t\tprintf(\" \");\n\t\tvalue = size == 4 ? fdt32_to_cpu(*(const uint32_t *)p) :\n\t\t\tsize == 2 ? (*p << 8) | p[1] : *p;\n\t\tprintf(fmt, value);\n\t}\n\treturn 0;\n}\n\n \nstatic int list_properties(const void *blob, int node)\n{\n\tconst struct fdt_property *data;\n\tconst char *name;\n\tint prop;\n\n\tprop = fdt_first_property_offset(blob, node);\n\tdo {\n\t\t \n\t\tif (prop < 0)\n\t\t\treturn prop == -FDT_ERR_NOTFOUND ? 0 : prop;\n\t\tdata = fdt_get_property_by_offset(blob, prop, NULL);\n\t\tname = fdt_string(blob, fdt32_to_cpu(data->nameoff));\n\t\tif (name)\n\t\t\tputs(name);\n\t\tprop = fdt_next_property_offset(blob, prop);\n\t} while (1);\n}\n\n#define MAX_LEVEL\t32\t\t \n\n \nstatic int list_subnodes(const void *blob, int node)\n{\n\tint nextoffset;\t\t \n\tuint32_t tag;\t\t \n\tint level = 0;\t\t \n\tconst char *pathp;\n\tint depth = 1;\t\t \n\n\twhile (level >= 0) {\n\t\ttag = fdt_next_tag(blob, node, &nextoffset);\n\t\tswitch (tag) {\n\t\tcase FDT_BEGIN_NODE:\n\t\t\tpathp = fdt_get_name(blob, node, NULL);\n\t\t\tif (level <= depth) {\n\t\t\t\tif (pathp == NULL)\n\t\t\t\t\tpathp = \"/* NULL pointer error */\";\n\t\t\t\tif (*pathp == '\\0')\n\t\t\t\t\tpathp = \"/\";\t \n\t\t\t\tif (level == 1)\n\t\t\t\t\tputs(pathp);\n\t\t\t}\n\t\t\tlevel++;\n\t\t\tif (level >= MAX_LEVEL) {\n\t\t\t\tprintf(\"Nested too deep, aborting.\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FDT_END_NODE:\n\t\t\tlevel--;\n\t\t\tif (level == 0)\n\t\t\t\tlevel = -1;\t\t \n\t\t\tbreak;\n\t\tcase FDT_END:\n\t\t\treturn 1;\n\t\tcase FDT_PROP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (level <= depth)\n\t\t\t\tprintf(\"Unknown tag 0x%08X\\n\", tag);\n\t\t\treturn 1;\n\t\t}\n\t\tnode = nextoffset;\n\t}\n\treturn 0;\n}\n\n \nstatic int show_data_for_item(const void *blob, struct display_info *disp,\n\t\tint node, const char *property)\n{\n\tconst void *value = NULL;\n\tint len, err = 0;\n\n\tswitch (disp->mode) {\n\tcase MODE_LIST_PROPS:\n\t\terr = list_properties(blob, node);\n\t\tbreak;\n\n\tcase MODE_LIST_SUBNODES:\n\t\terr = list_subnodes(blob, node);\n\t\tbreak;\n\n\tdefault:\n\t\tassert(property);\n\t\tvalue = fdt_getprop(blob, node, property, &len);\n\t\tif (value) {\n\t\t\tif (show_data(disp, value, len))\n\t\t\t\terr = -1;\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t} else if (disp->default_val) {\n\t\t\tputs(disp->default_val);\n\t\t} else {\n\t\t\treport_error(property, len);\n\t\t\terr = -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int do_fdtget(struct display_info *disp, const char *filename,\n\t\t     char **arg, int arg_count, int args_per_step)\n{\n\tchar *blob;\n\tconst char *prop;\n\tint i, node;\n\n\tblob = utilfdt_read(filename);\n\tif (!blob)\n\t\treturn -1;\n\n\tfor (i = 0; i + args_per_step <= arg_count; i += args_per_step) {\n\t\tnode = fdt_path_offset(blob, arg[i]);\n\t\tif (node < 0) {\n\t\t\tif (disp->default_val) {\n\t\t\t\tputs(disp->default_val);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treport_error(arg[i], node);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tprop = args_per_step == 1 ? NULL : arg[i + 1];\n\n\t\tif (show_data_for_item(blob, disp, node, prop))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic const char *usage_msg =\n\t\"fdtget - read values from device tree\\n\"\n\t\"\\n\"\n\t\"Each value is printed on a new line.\\n\\n\"\n\t\"Usage:\\n\"\n\t\"\tfdtget <options> <dt file> [<node> <property>]...\\n\"\n\t\"\tfdtget -p <options> <dt file> [<node> ]...\\n\"\n\t\"Options:\\n\"\n\t\"\\t-t <type>\\tType of data\\n\"\n\t\"\\t-p\\t\\tList properties for each node\\n\"\n\t\"\\t-l\\t\\tList subnodes for each node\\n\"\n\t\"\\t-d\\t\\tDefault value to display when the property is \"\n\t\t\t\"missing\\n\"\n\t\"\\t-h\\t\\tPrint this help\\n\\n\"\n\tUSAGE_TYPE_MSG;\n\nstatic void usage(const char *msg)\n{\n\tif (msg)\n\t\tfprintf(stderr, \"Error: %s\\n\\n\", msg);\n\n\tfprintf(stderr, \"%s\", usage_msg);\n\texit(2);\n}\n\nint main(int argc, char *argv[])\n{\n\tchar *filename = NULL;\n\tstruct display_info disp;\n\tint args_per_step = 2;\n\n\t \n\tmemset(&disp, '\\0', sizeof(disp));\n\tdisp.size = -1;\n\tdisp.mode = MODE_SHOW_VALUE;\n\tfor (;;) {\n\t\tint c = getopt(argc, argv, \"d:hlpt:\");\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tusage(NULL);\n\n\t\tcase 't':\n\t\t\tif (utilfdt_decode_type(optarg, &disp.type,\n\t\t\t\t\t&disp.size))\n\t\t\t\tusage(\"Invalid type string\");\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tdisp.mode = MODE_LIST_PROPS;\n\t\t\targs_per_step = 1;\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tdisp.mode = MODE_LIST_SUBNODES;\n\t\t\targs_per_step = 1;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdisp.default_val = optarg;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind < argc)\n\t\tfilename = argv[optind++];\n\tif (!filename)\n\t\tusage(\"Missing filename\");\n\n\targv += optind;\n\targc -= optind;\n\n\t \n\tif (!argc)\n\t\treturn 0;\n\n\t \n\tif (args_per_step == 2 && (argc % 2))\n\t\tusage(\"Must have an even number of arguments\");\n\n\tif (do_fdtget(&disp, filename, argv, argc, args_per_step))\n\t\treturn 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}