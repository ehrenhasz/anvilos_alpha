{
  "module_name": "treesource.c",
  "hash_id": "6ed7745c3042eaf19c07965d6b42614086364c16ab62f54e4b5b98c76f81e0dd",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/treesource.c",
  "human_readable_source": "\n \n\n#include \"dtc.h\"\n#include \"srcpos.h\"\n\nextern FILE *yyin;\nextern int yyparse(void);\nextern YYLTYPE yylloc;\n\nstruct dt_info *parser_output;\nbool treesource_error;\n\nstruct dt_info *dt_from_source(const char *fname)\n{\n\tparser_output = NULL;\n\ttreesource_error = false;\n\n\tsrcfile_push(fname);\n\tyyin = current_srcfile->f;\n\tyylloc.file = current_srcfile;\n\n\tif (yyparse() != 0)\n\t\tdie(\"Unable to parse input tree\\n\");\n\n\tif (treesource_error)\n\t\tdie(\"Syntax error parsing input tree\\n\");\n\n\treturn parser_output;\n}\n\nstatic void write_prefix(FILE *f, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < level; i++)\n\t\tfputc('\\t', f);\n}\n\nstatic bool isstring(char c)\n{\n\treturn (isprint((unsigned char)c)\n\t\t|| (c == '\\0')\n\t\t|| strchr(\"\\a\\b\\t\\n\\v\\f\\r\", c));\n}\n\nstatic void write_propval_string(FILE *f, const char *s, size_t len)\n{\n\tconst char *end = s + len - 1;\n\n\tif (!len)\n\t\treturn;\n\n\tassert(*end == '\\0');\n\n\tfprintf(f, \"\\\"\");\n\twhile (s < end) {\n\t\tchar c = *s++;\n\t\tswitch (c) {\n\t\tcase '\\a':\n\t\t\tfprintf(f, \"\\\\a\");\n\t\t\tbreak;\n\t\tcase '\\b':\n\t\t\tfprintf(f, \"\\\\b\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tfprintf(f, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tfprintf(f, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\v':\n\t\t\tfprintf(f, \"\\\\v\");\n\t\t\tbreak;\n\t\tcase '\\f':\n\t\t\tfprintf(f, \"\\\\f\");\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tfprintf(f, \"\\\\r\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tfprintf(f, \"\\\\\\\\\");\n\t\t\tbreak;\n\t\tcase '\\\"':\n\t\t\tfprintf(f, \"\\\\\\\"\");\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tfprintf(f, \"\\\\0\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (isprint((unsigned char)c))\n\t\t\t\tfprintf(f, \"%c\", c);\n\t\t\telse\n\t\t\t\tfprintf(f, \"\\\\x%02\"PRIx8, c);\n\t\t}\n\t}\n\tfprintf(f, \"\\\"\");\n}\n\nstatic void write_propval_int(FILE *f, const char *p, size_t len, size_t width)\n{\n\tconst char *end = p + len;\n\tassert(len % width == 0);\n\n\tfor (; p < end; p += width) {\n\t\tswitch (width) {\n\t\tcase 1:\n\t\t\tfprintf(f, \"%02\"PRIx8, *(const uint8_t*)p);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(f, \"0x%02\"PRIx16, dtb_ld16(p));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tfprintf(f, \"0x%02\"PRIx32, dtb_ld32(p));\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tfprintf(f, \"0x%02\"PRIx64, dtb_ld64(p));\n\t\t\tbreak;\n\t\t}\n\t\tif (p + width < end)\n\t\t\tfputc(' ', f);\n\t}\n}\n\nstatic const char *delim_start[] = {\n\t[TYPE_UINT8] = \"[\",\n\t[TYPE_UINT16] = \"/bits/ 16 <\",\n\t[TYPE_UINT32] = \"<\",\n\t[TYPE_UINT64] = \"/bits/ 64 <\",\n\t[TYPE_STRING] = \"\",\n};\nstatic const char *delim_end[] = {\n\t[TYPE_UINT8] = \"]\",\n\t[TYPE_UINT16] = \">\",\n\t[TYPE_UINT32] = \">\",\n\t[TYPE_UINT64] = \">\",\n\t[TYPE_STRING] = \"\",\n};\n\nstatic enum markertype guess_value_type(struct property *prop)\n{\n\tint len = prop->val.len;\n\tconst char *p = prop->val.val;\n\tstruct marker *m = prop->val.markers;\n\tint nnotstring = 0, nnul = 0;\n\tint nnotstringlbl = 0, nnotcelllbl = 0;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (! isstring(p[i]))\n\t\t\tnnotstring++;\n\t\tif (p[i] == '\\0')\n\t\t\tnnul++;\n\t}\n\n\tfor_each_marker_of_type(m, LABEL) {\n\t\tif ((m->offset > 0) && (prop->val.val[m->offset - 1] != '\\0'))\n\t\t\tnnotstringlbl++;\n\t\tif ((m->offset % sizeof(cell_t)) != 0)\n\t\t\tnnotcelllbl++;\n\t}\n\n\tif ((p[len-1] == '\\0') && (nnotstring == 0) && (nnul <= (len-nnul))\n\t    && (nnotstringlbl == 0)) {\n\t\treturn TYPE_STRING;\n\t} else if (((len % sizeof(cell_t)) == 0) && (nnotcelllbl == 0)) {\n\t\treturn TYPE_UINT32;\n\t}\n\n\treturn TYPE_UINT8;\n}\n\nstatic void write_propval(FILE *f, struct property *prop)\n{\n\tsize_t len = prop->val.len;\n\tstruct marker *m = prop->val.markers;\n\tstruct marker dummy_marker;\n\tenum markertype emit_type = TYPE_NONE;\n\tchar *srcstr;\n\n\tif (len == 0) {\n\t\tfprintf(f, \";\");\n\t\tif (annotate) {\n\t\t\tsrcstr = srcpos_string_first(prop->srcpos, annotate);\n\t\t\tif (srcstr) {\n\t\t\t\tfprintf(f, \" /* %s */\", srcstr);\n\t\t\t\tfree(srcstr);\n\t\t\t}\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(f, \" =\");\n\n\tif (!next_type_marker(m)) {\n\t\t \n\t\tdummy_marker.type = guess_value_type(prop);\n\t\tdummy_marker.next = prop->val.markers;\n\t\tdummy_marker.offset = 0;\n\t\tdummy_marker.ref = NULL;\n\t\tm = &dummy_marker;\n\t}\n\n\tfor_each_marker(m) {\n\t\tsize_t chunk_len = (m->next ? m->next->offset : len) - m->offset;\n\t\tsize_t data_len = type_marker_length(m) ? : len - m->offset;\n\t\tconst char *p = &prop->val.val[m->offset];\n\t\tstruct marker *m_phandle;\n\n\t\tif (is_type_marker(m->type)) {\n\t\t\temit_type = m->type;\n\t\t\tfprintf(f, \" %s\", delim_start[emit_type]);\n\t\t} else if (m->type == LABEL)\n\t\t\tfprintf(f, \" %s:\", m->ref);\n\n\t\tif (emit_type == TYPE_NONE || chunk_len == 0)\n\t\t\tcontinue;\n\n\t\tswitch(emit_type) {\n\t\tcase TYPE_UINT16:\n\t\t\twrite_propval_int(f, p, chunk_len, 2);\n\t\t\tbreak;\n\t\tcase TYPE_UINT32:\n\t\t\tm_phandle = prop->val.markers;\n\t\t\tfor_each_marker_of_type(m_phandle, REF_PHANDLE)\n\t\t\t\tif (m->offset == m_phandle->offset)\n\t\t\t\t\tbreak;\n\n\t\t\tif (m_phandle) {\n\t\t\t\tif (m_phandle->ref[0] == '/')\n\t\t\t\t\tfprintf(f, \"&{%s}\", m_phandle->ref);\n\t\t\t\telse\n\t\t\t\t\tfprintf(f, \"&%s\", m_phandle->ref);\n\t\t\t\tif (chunk_len > 4) {\n\t\t\t\t\tfputc(' ', f);\n\t\t\t\t\twrite_propval_int(f, p + 4, chunk_len - 4, 4);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twrite_propval_int(f, p, chunk_len, 4);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TYPE_UINT64:\n\t\t\twrite_propval_int(f, p, chunk_len, 8);\n\t\t\tbreak;\n\t\tcase TYPE_STRING:\n\t\t\twrite_propval_string(f, p, chunk_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twrite_propval_int(f, p, chunk_len, 1);\n\t\t}\n\n\t\tif (chunk_len == data_len) {\n\t\t\tsize_t pos = m->offset + chunk_len;\n\t\t\tfprintf(f, pos == len ? \"%s\" : \"%s,\",\n\t\t\t        delim_end[emit_type] ? : \"\");\n\t\t\temit_type = TYPE_NONE;\n\t\t}\n\t}\n\tfprintf(f, \";\");\n\tif (annotate) {\n\t\tsrcstr = srcpos_string_first(prop->srcpos, annotate);\n\t\tif (srcstr) {\n\t\t\tfprintf(f, \" /* %s */\", srcstr);\n\t\t\tfree(srcstr);\n\t\t}\n\t}\n\tfprintf(f, \"\\n\");\n}\n\nstatic void write_tree_source_node(FILE *f, struct node *tree, int level)\n{\n\tstruct property *prop;\n\tstruct node *child;\n\tstruct label *l;\n\tchar *srcstr;\n\n\twrite_prefix(f, level);\n\tfor_each_label(tree->labels, l)\n\t\tfprintf(f, \"%s: \", l->label);\n\tif (tree->name && (*tree->name))\n\t\tfprintf(f, \"%s {\", tree->name);\n\telse\n\t\tfprintf(f, \"/ {\");\n\n\tif (annotate) {\n\t\tsrcstr = srcpos_string_first(tree->srcpos, annotate);\n\t\tif (srcstr) {\n\t\t\tfprintf(f, \" /* %s */\", srcstr);\n\t\t\tfree(srcstr);\n\t\t}\n\t}\n\tfprintf(f, \"\\n\");\n\n\tfor_each_property(tree, prop) {\n\t\twrite_prefix(f, level+1);\n\t\tfor_each_label(prop->labels, l)\n\t\t\tfprintf(f, \"%s: \", l->label);\n\t\tfprintf(f, \"%s\", prop->name);\n\t\twrite_propval(f, prop);\n\t}\n\tfor_each_child(tree, child) {\n\t\tfprintf(f, \"\\n\");\n\t\twrite_tree_source_node(f, child, level+1);\n\t}\n\twrite_prefix(f, level);\n\tfprintf(f, \"};\");\n\tif (annotate) {\n\t\tsrcstr = srcpos_string_last(tree->srcpos, annotate);\n\t\tif (srcstr) {\n\t\t\tfprintf(f, \" /* %s */\", srcstr);\n\t\t\tfree(srcstr);\n\t\t}\n\t}\n\tfprintf(f, \"\\n\");\n}\n\nvoid dt_to_source(FILE *f, struct dt_info *dti)\n{\n\tstruct reserve_info *re;\n\n\tfprintf(f, \"/dts-v1/;\\n\\n\");\n\n\tfor (re = dti->reservelist; re; re = re->next) {\n\t\tstruct label *l;\n\n\t\tfor_each_label(re->labels, l)\n\t\t\tfprintf(f, \"%s: \", l->label);\n\t\tfprintf(f, \"/memreserve/\\t0x%016llx 0x%016llx;\\n\",\n\t\t\t(unsigned long long)re->address,\n\t\t\t(unsigned long long)re->size);\n\t}\n\n\twrite_tree_source_node(f, dti->dt, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}