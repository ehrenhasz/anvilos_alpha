{
  "module_name": "fdtput.c",
  "hash_id": "a3a579b290c36c721af0017ec0eab4a76258eb46f5e8a75f08b8cc76a962ce21",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/fdtput.c",
  "human_readable_source": "\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <libfdt.h>\n\n#include \"util.h\"\n\n \nenum oper_type {\n\tOPER_WRITE_PROP,\t\t \n\tOPER_CREATE_NODE,\t\t \n};\n\nstruct display_info {\n\tenum oper_type oper;\t \n\tint type;\t\t \n\tint size;\t\t \n\tint verbose;\t\t \n\tint auto_path;\t\t \n};\n\n\n \nstatic void report_error(const char *name, int namelen, int err)\n{\n\tif (namelen == -1)\n\t\tnamelen = strlen(name);\n\tfprintf(stderr, \"Error at '%1.*s': %s\\n\", namelen, name,\n\t\tfdt_strerror(err));\n}\n\n \nstatic int encode_value(struct display_info *disp, char **arg, int arg_count,\n\t\t\tchar **valuep, int *value_len)\n{\n\tchar *value = NULL;\t \n\tint value_size = 0;\t \n\tchar *ptr;\t\t \n\tint len;\t\t \n\tint ival;\n\tint upto;\t \n\tchar fmt[3];\n\n\tupto = 0;\n\n\tif (disp->verbose)\n\t\tfprintf(stderr, \"Decoding value:\\n\");\n\n\tfmt[0] = '%';\n\tfmt[1] = disp->type ? disp->type : 'd';\n\tfmt[2] = '\\0';\n\tfor (; arg_count > 0; arg++, arg_count--, upto += len) {\n\t\t \n\t\tif (disp->type == 's')\n\t\t\tlen = strlen(*arg) + 1;\n\t\telse\n\t\t\tlen = disp->size == -1 ? 4 : disp->size;\n\n\t\t \n\t\tif (upto + len > value_size) {\n\t\t\tvalue_size = (upto + len) + 500;\n\t\t\tvalue = realloc(value, value_size);\n\t\t\tif (!value) {\n\t\t\t\tfprintf(stderr, \"Out of mmory: cannot alloc \"\n\t\t\t\t\t\"%d bytes\\n\", value_size);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tptr = value + upto;\n\t\tif (disp->type == 's') {\n\t\t\tmemcpy(ptr, *arg, len);\n\t\t\tif (disp->verbose)\n\t\t\t\tfprintf(stderr, \"\\tstring: '%s'\\n\", ptr);\n\t\t} else {\n\t\t\tint *iptr = (int *)ptr;\n\t\t\tsscanf(*arg, fmt, &ival);\n\t\t\tif (len == 4)\n\t\t\t\t*iptr = cpu_to_fdt32(ival);\n\t\t\telse\n\t\t\t\t*ptr = (uint8_t)ival;\n\t\t\tif (disp->verbose) {\n\t\t\t\tfprintf(stderr, \"\\t%s: %d\\n\",\n\t\t\t\t\tdisp->size == 1 ? \"byte\" :\n\t\t\t\t\tdisp->size == 2 ? \"short\" : \"int\",\n\t\t\t\t\tival);\n\t\t\t}\n\t\t}\n\t}\n\t*value_len = upto;\n\t*valuep = value;\n\tif (disp->verbose)\n\t\tfprintf(stderr, \"Value size %d\\n\", upto);\n\treturn 0;\n}\n\nstatic int store_key_value(void *blob, const char *node_name,\n\t\tconst char *property, const char *buf, int len)\n{\n\tint node;\n\tint err;\n\n\tnode = fdt_path_offset(blob, node_name);\n\tif (node < 0) {\n\t\treport_error(node_name, -1, node);\n\t\treturn -1;\n\t}\n\n\terr = fdt_setprop(blob, node, property, buf, len);\n\tif (err) {\n\t\treport_error(property, -1, err);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int create_paths(void *blob, const char *in_path)\n{\n\tconst char *path = in_path;\n\tconst char *sep;\n\tint node, offset = 0;\n\n\t \n\twhile (*path == '/')\n\t\tpath++;\n\n\tfor (sep = path; *sep; path = sep + 1, offset = node) {\n\t\t \n\t\tsep = strchr(path, '/');\n\t\tif (!sep)\n\t\t\tsep = path + strlen(path);\n\n\t\tnode = fdt_subnode_offset_namelen(blob, offset, path,\n\t\t\t\tsep - path);\n\t\tif (node == -FDT_ERR_NOTFOUND) {\n\t\t\tnode = fdt_add_subnode_namelen(blob, offset, path,\n\t\t\t\t\t\t       sep - path);\n\t\t}\n\t\tif (node < 0) {\n\t\t\treport_error(path, sep - path, node);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int create_node(void *blob, const char *node_name)\n{\n\tint node = 0;\n\tchar *p;\n\n\tp = strrchr(node_name, '/');\n\tif (!p) {\n\t\treport_error(node_name, -1, -FDT_ERR_BADPATH);\n\t\treturn -1;\n\t}\n\t*p = '\\0';\n\n\tif (p > node_name) {\n\t\tnode = fdt_path_offset(blob, node_name);\n\t\tif (node < 0) {\n\t\t\treport_error(node_name, -1, node);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tnode = fdt_add_subnode(blob, node, p + 1);\n\tif (node < 0) {\n\t\treport_error(p + 1, -1, node);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_fdtput(struct display_info *disp, const char *filename,\n\t\t    char **arg, int arg_count)\n{\n\tchar *value;\n\tchar *blob;\n\tint len, ret = 0;\n\n\tblob = utilfdt_read(filename);\n\tif (!blob)\n\t\treturn -1;\n\n\tswitch (disp->oper) {\n\tcase OPER_WRITE_PROP:\n\t\t \n\t\tassert(arg_count >= 2);\n\t\tif (disp->auto_path && create_paths(blob, *arg))\n\t\t\treturn -1;\n\t\tif (encode_value(disp, arg + 2, arg_count - 2, &value, &len) ||\n\t\t\tstore_key_value(blob, *arg, arg[1], value, len))\n\t\t\tret = -1;\n\t\tbreak;\n\tcase OPER_CREATE_NODE:\n\t\tfor (; ret >= 0 && arg_count--; arg++) {\n\t\t\tif (disp->auto_path)\n\t\t\t\tret = create_paths(blob, *arg);\n\t\t\telse\n\t\t\t\tret = create_node(blob, *arg);\n\t\t}\n\t\tbreak;\n\t}\n\tif (ret >= 0)\n\t\tret = utilfdt_write(filename, blob);\n\n\tfree(blob);\n\treturn ret;\n}\n\nstatic const char *usage_msg =\n\t\"fdtput - write a property value to a device tree\\n\"\n\t\"\\n\"\n\t\"The command line arguments are joined together into a single value.\\n\"\n\t\"\\n\"\n\t\"Usage:\\n\"\n\t\"\tfdtput <options> <dt file> <node> <property> [<value>...]\\n\"\n\t\"\tfdtput -c <options> <dt file> [<node>...]\\n\"\n\t\"Options:\\n\"\n\t\"\\t-c\\t\\tCreate nodes if they don't already exist\\n\"\n\t\"\\t-p\\t\\tAutomatically create nodes as needed for the node path\\n\"\n\t\"\\t-t <type>\\tType of data\\n\"\n\t\"\\t-v\\t\\tVerbose: display each value decoded from command line\\n\"\n\t\"\\t-h\\t\\tPrint this help\\n\\n\"\n\tUSAGE_TYPE_MSG;\n\nstatic void usage(const char *msg)\n{\n\tif (msg)\n\t\tfprintf(stderr, \"Error: %s\\n\\n\", msg);\n\n\tfprintf(stderr, \"%s\", usage_msg);\n\texit(2);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct display_info disp;\n\tchar *filename = NULL;\n\n\tmemset(&disp, '\\0', sizeof(disp));\n\tdisp.size = -1;\n\tdisp.oper = OPER_WRITE_PROP;\n\tfor (;;) {\n\t\tint c = getopt(argc, argv, \"chpt:v\");\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\t \n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tdisp.oper = OPER_CREATE_NODE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tusage(NULL);\n\t\tcase 'p':\n\t\t\tdisp.auto_path = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (utilfdt_decode_type(optarg, &disp.type,\n\t\t\t\t\t&disp.size))\n\t\t\t\tusage(\"Invalid type string\");\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tdisp.verbose = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind < argc)\n\t\tfilename = argv[optind++];\n\tif (!filename)\n\t\tusage(\"Missing filename\");\n\n\targv += optind;\n\targc -= optind;\n\n\tif (disp.oper == OPER_WRITE_PROP) {\n\t\tif (argc < 1)\n\t\t\tusage(\"Missing node\");\n\t\tif (argc < 2)\n\t\t\tusage(\"Missing property\");\n\t}\n\n\tif (do_fdtput(&disp, filename, argv, argc))\n\t\treturn 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}