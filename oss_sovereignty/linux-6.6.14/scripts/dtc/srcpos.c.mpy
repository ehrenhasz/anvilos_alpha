{
  "module_name": "srcpos.c",
  "hash_id": "dc96aba19acd7d5af84cf6b1256d22474c8330eb7f278ee94ce6593f5aa0fd6b",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/srcpos.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n\n#include \"dtc.h\"\n#include \"srcpos.h\"\n\n \nstruct search_path {\n\tstruct search_path *next;\t \n\tconst char *dirname;\t\t \n};\n\n \nstatic struct search_path *search_path_head, **search_path_tail;\n\n \n#define MAX_SRCFILE_DEPTH     (200)\nstatic int srcfile_depth;  \n\nstatic char *get_dirname(const char *path)\n{\n\tconst char *slash = strrchr(path, '/');\n\n\tif (slash) {\n\t\tint len = slash - path;\n\t\tchar *dir = xmalloc(len + 1);\n\n\t\tmemcpy(dir, path, len);\n\t\tdir[len] = '\\0';\n\t\treturn dir;\n\t}\n\treturn NULL;\n}\n\nFILE *depfile;  \nstruct srcfile_state *current_srcfile;  \nstatic char *initial_path;  \nstatic int initial_pathlen;  \nstatic bool initial_cpp = true;\n\nstatic void set_initial_path(char *fname)\n{\n\tint i, len = strlen(fname);\n\n\txasprintf(&initial_path, \"%s\", fname);\n\tinitial_pathlen = 0;\n\tfor (i = 0; i != len; i++)\n\t\tif (initial_path[i] == '/')\n\t\t\tinitial_pathlen++;\n}\n\nstatic char *shorten_to_initial_path(char *fname)\n{\n\tchar *p1, *p2, *prevslash1 = NULL;\n\tint slashes = 0;\n\n\tfor (p1 = fname, p2 = initial_path; *p1 && *p2; p1++, p2++) {\n\t\tif (*p1 != *p2)\n\t\t\tbreak;\n\t\tif (*p1 == '/') {\n\t\t\tprevslash1 = p1;\n\t\t\tslashes++;\n\t\t}\n\t}\n\tp1 = prevslash1 + 1;\n\tif (prevslash1) {\n\t\tint diff = initial_pathlen - slashes, i, j;\n\t\tint restlen = strlen(fname) - (p1 - fname);\n\t\tchar *res;\n\n\t\tres = xmalloc((3 * diff) + restlen + 1);\n\t\tfor (i = 0, j = 0; i != diff; i++) {\n\t\t\tres[j++] = '.';\n\t\t\tres[j++] = '.';\n\t\t\tres[j++] = '/';\n\t\t}\n\t\tstrcpy(res + j, p1);\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\n \nstatic char *try_open(const char *dirname, const char *fname, FILE **fp)\n{\n\tchar *fullname;\n\n\tif (!dirname || fname[0] == '/')\n\t\tfullname = xstrdup(fname);\n\telse\n\t\tfullname = join_path(dirname, fname);\n\n\t*fp = fopen(fullname, \"rb\");\n\tif (!*fp) {\n\t\tfree(fullname);\n\t\tfullname = NULL;\n\t}\n\n\treturn fullname;\n}\n\n \nstatic char *fopen_any_on_path(const char *fname, FILE **fp)\n{\n\tconst char *cur_dir = NULL;\n\tstruct search_path *node;\n\tchar *fullname;\n\n\t \n\tassert(fp);\n\tif (current_srcfile)\n\t\tcur_dir = current_srcfile->dir;\n\tfullname = try_open(cur_dir, fname, fp);\n\n\t \n\tfor (node = search_path_head; !*fp && node; node = node->next)\n\t\tfullname = try_open(node->dirname, fname, fp);\n\n\treturn fullname;\n}\n\nFILE *srcfile_relative_open(const char *fname, char **fullnamep)\n{\n\tFILE *f;\n\tchar *fullname;\n\n\tif (streq(fname, \"-\")) {\n\t\tf = stdin;\n\t\tfullname = xstrdup(\"<stdin>\");\n\t} else {\n\t\tfullname = fopen_any_on_path(fname, &f);\n\t\tif (!f)\n\t\t\tdie(\"Couldn't open \\\"%s\\\": %s\\n\", fname,\n\t\t\t    strerror(errno));\n\t}\n\n\tif (depfile)\n\t\tfprintf(depfile, \" %s\", fullname);\n\n\tif (fullnamep)\n\t\t*fullnamep = fullname;\n\telse\n\t\tfree(fullname);\n\n\treturn f;\n}\n\nvoid srcfile_push(const char *fname)\n{\n\tstruct srcfile_state *srcfile;\n\n\tif (srcfile_depth++ >= MAX_SRCFILE_DEPTH)\n\t\tdie(\"Includes nested too deeply\");\n\n\tsrcfile = xmalloc(sizeof(*srcfile));\n\n\tsrcfile->f = srcfile_relative_open(fname, &srcfile->name);\n\tsrcfile->dir = get_dirname(srcfile->name);\n\tsrcfile->prev = current_srcfile;\n\n\tsrcfile->lineno = 1;\n\tsrcfile->colno = 1;\n\n\tcurrent_srcfile = srcfile;\n\n\tif (srcfile_depth == 1)\n\t\tset_initial_path(srcfile->name);\n}\n\nbool srcfile_pop(void)\n{\n\tstruct srcfile_state *srcfile = current_srcfile;\n\n\tassert(srcfile);\n\n\tcurrent_srcfile = srcfile->prev;\n\n\tif (fclose(srcfile->f))\n\t\tdie(\"Error closing \\\"%s\\\": %s\\n\", srcfile->name,\n\t\t    strerror(errno));\n\n\t \n\n\treturn current_srcfile ? true : false;\n}\n\nvoid srcfile_add_search_path(const char *dirname)\n{\n\tstruct search_path *node;\n\n\t \n\tnode = xmalloc(sizeof(*node));\n\tnode->next = NULL;\n\tnode->dirname = xstrdup(dirname);\n\n\t \n\tif (search_path_tail)\n\t\t*search_path_tail = node;\n\telse\n\t\tsearch_path_head = node;\n\tsearch_path_tail = &node->next;\n}\n\nvoid srcpos_update(struct srcpos *pos, const char *text, int len)\n{\n\tint i;\n\n\tpos->file = current_srcfile;\n\n\tpos->first_line = current_srcfile->lineno;\n\tpos->first_column = current_srcfile->colno;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (text[i] == '\\n') {\n\t\t\tcurrent_srcfile->lineno++;\n\t\t\tcurrent_srcfile->colno = 1;\n\t\t} else {\n\t\t\tcurrent_srcfile->colno++;\n\t\t}\n\n\tpos->last_line = current_srcfile->lineno;\n\tpos->last_column = current_srcfile->colno;\n}\n\nstruct srcpos *\nsrcpos_copy(struct srcpos *pos)\n{\n\tstruct srcpos *pos_new;\n\tstruct srcfile_state *srcfile_state;\n\n\tif (!pos)\n\t\treturn NULL;\n\n\tpos_new = xmalloc(sizeof(struct srcpos));\n\tassert(pos->next == NULL);\n\tmemcpy(pos_new, pos, sizeof(struct srcpos));\n\n\t \n\tsrcfile_state = xmalloc(sizeof(struct srcfile_state));\n\tmemcpy(srcfile_state, pos->file, sizeof(struct srcfile_state));\n\tpos_new->file = srcfile_state;\n\n\treturn pos_new;\n}\n\nstruct srcpos *srcpos_extend(struct srcpos *pos, struct srcpos *newtail)\n{\n\tstruct srcpos *p;\n\n\tif (!pos)\n\t\treturn newtail;\n\n\tfor (p = pos; p->next != NULL; p = p->next);\n\tp->next = newtail;\n\treturn pos;\n}\n\nchar *\nsrcpos_string(struct srcpos *pos)\n{\n\tconst char *fname = \"<no-file>\";\n\tchar *pos_str;\n\n\tif (pos->file && pos->file->name)\n\t\tfname = pos->file->name;\n\n\n\tif (pos->first_line != pos->last_line)\n\t\txasprintf(&pos_str, \"%s:%d.%d-%d.%d\", fname,\n\t\t\t  pos->first_line, pos->first_column,\n\t\t\t  pos->last_line, pos->last_column);\n\telse if (pos->first_column != pos->last_column)\n\t\txasprintf(&pos_str, \"%s:%d.%d-%d\", fname,\n\t\t\t  pos->first_line, pos->first_column,\n\t\t\t  pos->last_column);\n\telse\n\t\txasprintf(&pos_str, \"%s:%d.%d\", fname,\n\t\t\t  pos->first_line, pos->first_column);\n\n\treturn pos_str;\n}\n\nstatic char *\nsrcpos_string_comment(struct srcpos *pos, bool first_line, int level)\n{\n\tchar *pos_str, *fname, *first, *rest;\n\tbool fresh_fname = false;\n\n\tif (!pos) {\n\t\tif (level > 1) {\n\t\t\txasprintf(&pos_str, \"<no-file>:<no-line>\");\n\t\t\treturn pos_str;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!pos->file)\n\t\tfname = \"<no-file>\";\n\telse if (!pos->file->name)\n\t\tfname = \"<no-filename>\";\n\telse if (level > 1)\n\t\tfname = pos->file->name;\n\telse {\n\t\tfname = shorten_to_initial_path(pos->file->name);\n\t\tif (fname)\n\t\t\tfresh_fname = true;\n\t\telse\n\t\t\tfname = pos->file->name;\n\t}\n\n\tif (level > 1)\n\t\txasprintf(&first, \"%s:%d:%d-%d:%d\", fname,\n\t\t\t  pos->first_line, pos->first_column,\n\t\t\t  pos->last_line, pos->last_column);\n\telse\n\t\txasprintf(&first, \"%s:%d\", fname,\n\t\t\t  first_line ? pos->first_line : pos->last_line);\n\n\tif (fresh_fname)\n\t\tfree(fname);\n\n\tif (pos->next != NULL) {\n\t\trest = srcpos_string_comment(pos->next, first_line, level);\n\t\txasprintf(&pos_str, \"%s, %s\", first, rest);\n\t\tfree(first);\n\t\tfree(rest);\n\t} else {\n\t\tpos_str = first;\n\t}\n\n\treturn pos_str;\n}\n\nchar *srcpos_string_first(struct srcpos *pos, int level)\n{\n\treturn srcpos_string_comment(pos, true, level);\n}\n\nchar *srcpos_string_last(struct srcpos *pos, int level)\n{\n\treturn srcpos_string_comment(pos, false, level);\n}\n\nvoid srcpos_verror(struct srcpos *pos, const char *prefix,\n\t\t   const char *fmt, va_list va)\n{\n\tchar *srcstr;\n\n\tsrcstr = srcpos_string(pos);\n\n\tfprintf(stderr, \"%s: %s \", prefix, srcstr);\n\tvfprintf(stderr, fmt, va);\n\tfprintf(stderr, \"\\n\");\n\n\tfree(srcstr);\n}\n\nvoid srcpos_error(struct srcpos *pos, const char *prefix,\n\t\t  const char *fmt, ...)\n{\n\tva_list va;\n\n\tva_start(va, fmt);\n\tsrcpos_verror(pos, prefix, fmt, va);\n\tva_end(va);\n}\n\nvoid srcpos_set_line(char *f, int l)\n{\n\tcurrent_srcfile->name = f;\n\tcurrent_srcfile->lineno = l;\n\n\tif (initial_cpp) {\n\t\tinitial_cpp = false;\n\t\tset_initial_path(f);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}