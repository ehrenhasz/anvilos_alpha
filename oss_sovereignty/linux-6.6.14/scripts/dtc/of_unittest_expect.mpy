{
  "module_name": "of_unittest_expect",
  "hash_id": "f26719d0ac456d1ce93ab9bd7e1ce7bf227d68f98e16862326167b425cd03e82",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/of_unittest_expect",
  "human_readable_source": "#!/usr/bin/perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright 2020, 2022 Sony Corporation\n#\n# Author: Frank Rowand\n\n# This program is meant to be an aid to reading the verbose output of\n# on the console log that results from executing the Linux kernel\n# devicetree unittest (drivers/of/unitest.c).\n\n$VUFX = \"230211a\";\n\nuse strict 'refs';\nuse strict subs;\n\nuse Getopt::Long;\nuse Text::Wrap;\n\n# strip off everything before final \"/\"\n(undef, $script_name) = split(/^.*\\//, $0);\n\n# following /usr/include/sysexits.h\n$EX_OK=0;\n$EX_USAGE=64;\n\n\n#______________________________________________________________________________\nsub compare {\n\tmy ($expect, $got) = @_;\n\tmy $expect_next;\n\tmy $expect_next_lit;\n\tmy $got_next;\n\tmy $type;\n\n\twhile ($expect) {\n\n\t\t($expect_next, $type) = split(/<</, $expect);\n\t\t($type) = split(/>>/, $type);\n\t\t$expect =~ s/^.*?>>//;\t# '?' is non-greedy, minimal match\n\n\t\t# literal, ignore all metacharacters when used in a regex\n\t\t$expect_next_lit = quotemeta($expect_next);\n\n\t\t$got_next = $got;\n\t\t$got_next =~ s/^($expect_next_lit).*/\\1/;\n\t\t$got       =~ s/^$expect_next_lit//;\n\n\t\tif ($expect_next ne $got_next) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ($type eq \"int\") {\n\t\t\tif ($got =~ /^[+-]*[0-9]+/) {\n\t\t\t\t$got =~ s/^[+-]*[0-9]+//;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} elsif ($type eq \"hex\") {\n\t\t\tif ($got =~ /^(0x)*[0-9a-f]+/) {\n\t\t\t\t$got =~ s/^(0x)*[0-9a-f]+//;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} elsif ($type eq \"all\") {\n\t\t\treturn 1;\n\t\t} elsif ($type eq \"\") {\n\t\t\tif ($expect_next ne $got_next) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\t$internal_err++;\n\t\t\tprint \"** ERROR: special pattern not recognized: <<$type>>, CONSOLE_LOG line: $.\\n\";\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\t# should not get here\n\t$internal_err++;\n\tprint \"** ERROR: $script_name internal error, at end of compare(), CONSOLE_LOG line: $.\\n\";\n\n\treturn 0;\n}\n\n\n#______________________________________________________________________________\nsub usage {\n\n# ***** when editing, be careful to not put tabs in the string printed:\n\n\tprint STDERR\n\"\nusage:\n\n  $script_name CONSOLE_LOG\n\n     -h                print program usage\n    --help             print program usage\n    --hide-expect      suppress output of EXPECTed lines\n    --line-num         report line number of CONSOLE_LOG\n    --no-expect-stats  do not report EXPECT statistics\n    --no-strip-ts      do not strip leading console timestamps\n    --verbose          do not suppress EXPECT begin and end lines\n    --version          print program version and exit\n\n\n  Process a console log for EXPECTed test related messages to either\n  highlight expected devicetree unittest related messages or suppress\n  the messages.  Leading console timestamps will be stripped.\n\n  Various unittests may trigger kernel messages from outside the\n  unittest code.  The unittest annotates that it expects the message\n  to occur with an 'EXPECT \\\\ : text' (begin) before triggering the\n  message, and an 'EXPECT / : text' (end) after triggering the message.\n\n  If an expected message does not occur, that will be reported.\n\n  For each expected message, the 'EXPECT \\\\ : text' (begin) and\n  'EXPECT / : text' (end), 'text' will contain the message text.\n\n  If 'EXPECT \\\\' (begin) and 'EXPECT /' (end) lines do not contain\n  matching 'text', that will be reported.\n\n  If EXPECT lines are nested, 'EXPECT /' (end) lines must be in the\n  reverse order of the corresponding 'EXPECT \\\\' (begin) lines.\n\n  'EXPECT \\\\ : text' (begin) and 'EXPECT / : text' (end) lines can\n  contain special patterns in 'text':\n\n     <<int>> matches: [+-]*[0-9]+\n     <<hex>> matches: (0x)*[0-9a-f]+\n     <<all>> matches: anything to end of line\n\n  'EXPECT \\\\' (begin) and 'EXPECT /' (end) lines are suppressed.\n\n  A prefix is added to every line of output:\n\n    'ok ' Line matches an enclosing EXPECT begin/end pair\n\n    '** ' Line reports $script_name warning or error\n\n    '-> ' Line reports start or end of the unittests\n\n    '>> ' Line reports a unittest test FAIL\n\n    '   ' Lines that are not otherwise prefixed\n\n  Issues detected in CONSOLE_LOG are reported to STDOUT, not to STDERR.\n\n  Known Issues:\n\n    --line-num causes the CONSOLE_LOG line number to be printed in 4 columns.\n       If CONSOLE_LOG contains more than 9999 lines then more columns will be\n       used to report the line number for lines greater than 9999 (eg for\n       lines 10000 - 99999, 5 columns will be used).\n\";\n\n\treturn {};\n}\n\n#______________________________________________________________________________\n#______________________________________________________________________________\n\nif (!GetOptions(\n\t\"h\"               => \\$help,\n\t\"help\"            => \\$help,\n\t\"hide-expect\"     => \\$hide_expect,\n\t\"line-num\"        => \\$print_line_num,\n\t\"no-expect-stats\" => \\$no_expect_stats,\n\t\"no-strip-ts\"     => \\$no_strip_ts,\n\t\"verbose\"         => \\$verbose,\n\t\"version\"         => \\$version,\n\t)) {\n\tprint STDERR \"\\n\";\n\tprint STDERR \"ERROR processing command line options\\n\";\n\tprint STDERR \"\\n\";\n\tprint STDERR \"For help, type '$script_name --help'\\n\";\n\tprint STDERR \"\\n\";\n\n\texit $EX_OK;\n}\n\n\nif ($no_strip_ts) {\n\t$strip_ts = 1;\n\t$no_strip_ts = 0;\n} else {\n\t$strip_ts = 0;\n\t$no_strip_ts = 1;\n}\n\n\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nif ($help){\n\n\t&usage;\n\n\texit $EX_OK;\n}\n\n\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nif ($version) {\n\tprint STDERR \"\\n$script_name  $VUFX\\n\\n\";\n\tprint STDERR \"\\n\";\n\n\texit $EX_OK;\n}\n\n\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nif ($#ARGV != 0) {\n\n\t# Limit input files to exactly one.\n\t#\n\t# 'while ($line = <ARGV>) {' in the code below supports multiple file\n\t# names on the command line, but the EXPECT statistics are reported\n\t# once for all input - it is not an expected use case to generate one\n\t# set of statistics for multiple input files.\n\n\tprint STDERR \"\\n\";\n\tprint STDERR \"Required arguments: CONSOLE_LOG\\n\";\n\tprint STDERR \"\\n\";\n\n\texit $EX_USAGE;\n}\n\n\n#______________________________________________________________________________\n\n# Patterns to match 'EXPECT \\ : ' (begin) and 'EXPECT / : ' (end)\n#\n# $exp_* are used as regex match patterns,\n# so '\\\\\\\\' in $exp_begin matches a single '\\'\n# quotemeta() does not do the right thing in this case\n#\n# $pr_fmt is the prefix that unittest prints for every message\n\n$pr_fmt = \"### dt-test ### \";\n$exp_begin = \"${pr_fmt}EXPECT \\\\\\\\ : \";\n$exp_end   = \"${pr_fmt}EXPECT / : \";\n$expnot_begin = \"${pr_fmt}EXPECT_NOT \\\\\\\\ : \";\n$expnot_end   = \"${pr_fmt}EXPECT_NOT / : \";\n\n\n$line_num = \"\";\n$timestamp = \"\";\n\nLINE:\nwhile ($line = <ARGV>) {\n\n\tchomp $line;\n\n\t$suppress_line = 0;\n\n\t$prefix = \"  \";  ## 2 characters\n\n\n\tif ($strip_ts) {\n\n\t\t$timestamp = $line;\n\n\t\tif ($timestamp =~ /^\\[\\s*[0-9]+\\.[0-9]*\\] /) {\n\t\t\t($timestamp, $null) = split(/]/, $line);\n\t\t\t$timestamp = $timestamp . \"] \";\n\n\t\t} else {\n\t\t\t$timestamp = \"\";\n\t\t}\n\t}\n\n\t$line =~ s/^\\[\\s*[0-9]+\\.[0-9]*\\] //;\n\n\n\t# -----  find EXPECT begin\n\n\tif ($line =~ /^\\s*$exp_begin/) {\n\t\t$data = $line;\n\t\t$data =~ s/^\\s*$exp_begin//;\n\t\tpush @exp_begin_stack, $data;\n\n\t\tif ($verbose) {\n\t\t\tif ($print_line_num) {\n\t\t\t\t$line_num = sprintf(\"%4s \", $.);\n\t\t\t}\n\t\t\tprintf \"%s %s%s%s\\n\", $prefix, $line_num,  $timestamp, $line;\n\t\t}\n\n\t\tnext LINE;\n\t}\n\n\n\t# -----  find EXPECT end\n\n\tif ($line =~ /^\\s*$exp_end/) {\n\t\t$data = $line;\n\t\t$data =~ s/^\\s*$exp_end//;\n\n\t\tif ($verbose) {\n\t\t\tif ($print_line_num) {\n\t\t\t\t$line_num = sprintf(\"%4s \", $.);\n\t\t\t}\n\t\t\tprintf \"%s %s%s%s\\n\", $prefix, $line_num,  $timestamp, $line;\n\t\t}\n\n\t\t$found = 0;\n\t\t$no_begin = 0;\n\t\tif (@exp_found_or_begin > 0) {\n\t\t\t$begin = pop @exp_found_or_begin;\n\t\t\tif (compare($data, $begin)) {\n\t\t\t\t$found = 1;\n\t\t\t\t$exp_found++;\n\t\t\t}\n\t\t} elsif (@begin > 0) {\n\t\t\t$begin = pop @exp_begin_stack;\n\t\t} else {\n\t\t\t$no_begin = 1;\n\t\t}\n\n\t\tif ($no_begin) {\n\n\t\t\t$exp_missing_begin++;\n\t\t\tprint \"** ERROR: EXPECT end without matching EXPECT begin:\\n\";\n\t\t\tprint \"       end ---> $line\\n\";\n\n\t\t} elsif (! $found) {\n\n\t\t\tif ($print_line_num) {\n\t\t\t\t$line_num = sprintf(\"%4s \", $.);\n\t\t\t}\n\n\t\t\t$exp_missing++;\n\t\t\tprintf \"** %s%s$script_name WARNING - not found ---> %s\\n\",\n\t\t\t\t\t$line_num,  $timestamp, $data;\n\n\t\t} elsif (! compare($data, $begin) and ($data ne $begin)) {\n\n\t\t\t$exp_missing_end++;\n\t\t\tprint \"** ERROR: EXPECT end does not match EXPECT begin:\\n\";\n\t\t\tprint \"       begin -> $begin\\n\";\n\t\t\tprint \"       end ---> $line\\n\";\n\n\t\t}\n\n\t\tnext LINE;\n\t}\n\n\n\t# -----  find EXPECT_NOT begin\n\n\tif ($line =~ /^\\s*$expnot_begin/) {\n\t\t$data = $line;\n\t\t$data =~ s/^\\s*$expnot_begin//;\n\t\tpush @expnot_begin_stack, $data;\n\n\t\tif ($verbose) {\n\t\t\tif ($print_line_num) {\n\t\t\t\t$line_num = sprintf(\"%4s \", $.);\n\t\t\t}\n\t\t\tprintf \"%s %s%s%s\\n\", $prefix, $line_num,  $timestamp, $line;\n\t\t}\n\n\t\tnext LINE;\n\t}\n\n\n\t# -----  find EXPECT_NOT end\n\n\tif ($line =~ /^\\s*$expnot_end/) {\n\t\t$data = $line;\n\t\t$data =~ s/^\\s*$expnot_end//;\n\n\t\tif ($verbose) {\n\t\t\tif ($print_line_num) {\n\t\t\t\t$line_num = sprintf(\"%4s \", $.);\n\t\t\t}\n\t\t\tprintf \"%s %s%s%s\\n\", $prefix, $line_num,  $timestamp, $line;\n\t\t}\n\n\t\t$found = 0;\n\t\t$no_begin = 0;\n\t\tif (@expnot_found_or_begin > 0) {\n\t\t\t$begin = pop @expnot_found_or_begin;\n\t\t\tif (compare($data, $begin)) {\n\t\t\t\t$found = 1;\n\t\t\t\t$expnot_found++;\n\t\t\t}\n\t\t} elsif (@expnot_begin_stack <= 0) {\n\t\t\t$no_begin = 1;\n\t\t}\n\n\t\tif ($no_begin) {\n\n\t\t\t$expnot_missing_begin++;\n\t\t\tprint \"** ERROR: EXPECT_NOT end without matching EXPECT_NOT begin:\\n\";\n\t\t\tprint \"       end ---> $line\\n\";\n\n\t\t}\n\n\t\tif ($found) {\n\n\t\t\tif ($print_line_num) {\n\t\t\t\t$line_num = sprintf(\"%4s \", $.);\n\t\t\t}\n\n\t\t\tprintf \"** %s%s$script_name WARNING - next line matches EXPECT_NOT\\n\",\n\t\t\t\t\t$line_num,  $timestamp;\n\t\t\tprintf \"** %s%s%s\\n\", $line_num,  $timestamp, $line;\n\n\t\t} else {\n\n\t\t\t$expnot_missing++;\n\n\t\t}\n\n\t\tif (@expnot_begin_stack > 0) {\n\t\t\t$begin = pop @expnot_begin_stack;\n\n\t\t\tif (! compare($data, $begin) and ($data ne $begin)) {\n\n\t\t\t\t$expnot_missing_end++;\n\t\t\t\tprint \"** ERROR: EXPECT_NOT end does not match EXPECT_NOT begin:\\n\";\n\t\t\t\tprint \"       begin -> $begin\\n\";\n\t\t\t\tprint \"       end ---> $line\\n\";\n\n\t\t\t}\n\t\t}\n\n\t\tnext LINE;\n\t}\n\n\n\t# -----  not an EXPECT line\n\n\tif (($line =~ /^${pr_fmt}start of unittest - you will see error messages$/) ||\n\t    ($line =~ /^${pr_fmt}end of unittest - [0-9]+ passed, [0-9]+ failed$/ )   ) {\n\t\t$prefix = \"->\"; # 2 characters\n\t} elsif ($line =~ /^${pr_fmt}FAIL /) {\n\t\t$unittest_fail++;\n\t\t$prefix = \">>\"; # 2 characters\n\t}\n\n\t$found = 0;\n\tforeach $begin (@exp_begin_stack) {\n\t\tif (compare($begin, $line)) {\n\t\t\t$found = 1;\n\t\t\tlast;\n\t\t}\n\t}\n\n\tif ($found) {\n\t\t$begin = shift @exp_begin_stack;\n\t\twhile (! compare($begin, $line)) {\n\t\t\tpush @exp_found_or_begin, $begin;\n\t\t\t$begin = shift @exp_begin_stack;\n\t\t}\n\t\tpush @exp_found_or_begin, $line;\n\n\t\tif ($hide_expect) {\n\t\t\t$suppress_line = 1;\n\t\t}\n\t\t$prefix = \"ok\"; # 2 characters\n\t}\n\n\n\t$found = 0;\n\tforeach $begin (@expnot_begin_stack) {\n\t\tif (compare($begin, $line)) {\n\t\t\t$found = 1;\n\t\t\tlast;\n\t\t}\n\t}\n\n\tif ($found) {\n\t\t$begin = shift @begin;\n\t\twhile (! compare($begin, $line)) {\n\t\t\tpush @expnot_found_or_begin, $begin;\n\t\t\t$begin = shift @begin;\n\t\t}\n\t\tpush @expnot_found_or_begin, $line;\n\n\t\tif ($hide_expect) {\n\t\t\t$suppress_line = 1;\n\t\t}\n\t\t$prefix = \"**\"; # 2 characters\n\t}\n\n\n\tif ($suppress_line) {\n\t\tnext LINE;\n\t}\n\n\tif ($print_line_num) {\n\t\t$line_num = sprintf(\"%4s \", $.);\n\t}\n\n\tprintf \"%s %s%s%s\\n\", $prefix, $line_num,  $timestamp, $line;\n}\n\nif (! $no_expect_stats) {\n\tprint  \"\\n\";\n\tprint  \"** EXPECT statistics:\\n\";\n\tprint  \"**\\n\";\n\tprintf \"**   non-zero values expected:\\n\";\n\tprint  \"**\\n\";\n\tprintf \"**     EXPECT found              : %4i\\n\", $exp_found;\n\tprintf \"**     EXPECT_NOT not found      : %4i\\n\", $expnot_missing;\n\tprint  \"**\\n\";\n\tprintf \"**   zero values expected:\\n\";\n\tprint  \"**\\n\";\n\tprintf \"**     EXPECT not found          : %4i\\n\", $exp_missing;\n\tprintf \"**     missing EXPECT begin      : %4i\\n\", $exp_missing_begin;\n\tprintf \"**     missing EXPECT end        : %4i\\n\", $exp_missing_end;\n\tprint  \"**\\n\";\n\tprintf \"**     EXPECT_NOT found          : %4i\\n\", $expnot_found;\n\tprintf \"**     missing EXPECT_NOT begin  : %4i\\n\", $expnot_missing_begin;\n\tprintf \"**     missing EXPECT_NOT end    : %4i\\n\", $expnot_missing_end;\n\tprint  \"**\\n\";\n\tprintf \"**     unittest FAIL             : %4i\\n\", $unittest_fail;\n\tprintf \"**     internal error            : %4i\\n\", $internal_err;\n}\n\nif (@exp_begin_stack) {\n\tprint \"** ERROR: EXPECT begin without matching EXPECT end:\\n\";\n\tprint \"          This list may be misleading.\\n\";\n\tforeach $begin (@exp_begin_stack) {\n\t\tprint \"       begin ---> $begin\\n\";\n\t}\n}\n\nif (@expnot_begin_stack) {\n\tprint \"** ERROR: EXPECT_NOT begin without matching EXPECT_NOT end:\\n\";\n\tprint \"          This list may be misleading.\\n\";\n\tforeach $begin (@expnot_begin_stack) {\n\t\tprint \"       begin ---> $begin\\n\";\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}