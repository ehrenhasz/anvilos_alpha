{
  "module_name": "fdtoverlay.c",
  "hash_id": "839fa5069dfbc27a33f98ecea9c1f3bab9eeabf6b728ea64b0fd5b5965fd5285",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/fdtoverlay.c",
  "human_readable_source": "\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n\n#include <libfdt.h>\n\n#include \"util.h\"\n\n#define BUF_INCREMENT\t65536\n\n \nstatic const char usage_synopsis[] =\n\t\"apply a number of overlays to a base blob\\n\"\n\t\"\tfdtoverlay <options> [<overlay.dtbo> [<overlay.dtbo>]]\\n\"\n\t\"\\n\"\n\tUSAGE_TYPE_MSG;\nstatic const char usage_short_opts[] = \"i:o:v\" USAGE_COMMON_SHORT_OPTS;\nstatic struct option const usage_long_opts[] = {\n\t{\"input\",            required_argument, NULL, 'i'},\n\t{\"output\",\t     required_argument, NULL, 'o'},\n\t{\"verbose\",\t           no_argument, NULL, 'v'},\n\tUSAGE_COMMON_LONG_OPTS,\n};\nstatic const char * const usage_opts_help[] = {\n\t\"Input base DT blob\",\n\t\"Output DT blob\",\n\t\"Verbose messages\",\n\tUSAGE_COMMON_OPTS_HELP\n};\n\nint verbose = 0;\n\nstatic void *apply_one(char *base, const char *overlay, size_t *buf_len,\n\t\t       const char *name)\n{\n\tchar *tmp = NULL;\n\tchar *tmpo;\n\tint ret;\n\n\t \n\ttmpo = xmalloc(fdt_totalsize(overlay));\n\n\tdo {\n\t\ttmp = xrealloc(tmp, *buf_len);\n\t\tret = fdt_open_into(base, tmp, *buf_len);\n\t\tif (ret) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"\\nFailed to make temporary copy: %s\\n\",\n\t\t\t\tfdt_strerror(ret));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tmemcpy(tmpo, overlay, fdt_totalsize(overlay));\n\n\t\tret = fdt_overlay_apply(tmp, tmpo);\n\t\tif (ret == -FDT_ERR_NOSPACE) {\n\t\t\t*buf_len += BUF_INCREMENT;\n\t\t}\n\t} while (ret == -FDT_ERR_NOSPACE);\n\n\tif (ret) {\n\t\tfprintf(stderr, \"\\nFailed to apply '%s': %s\\n\",\n\t\t\tname, fdt_strerror(ret));\n\t\tgoto fail;\n\t}\n\n\tfree(base);\n\tfree(tmpo);\n\treturn tmp;\n\nfail:\n\tfree(tmpo);\n\tif (tmp)\n\t\tfree(tmp);\n\n\treturn NULL;\n}\nstatic int do_fdtoverlay(const char *input_filename,\n\t\t\t const char *output_filename,\n\t\t\t int argc, char *argv[])\n{\n\tchar *blob = NULL;\n\tchar **ovblob = NULL;\n\tsize_t buf_len;\n\tint i, ret = -1;\n\n\tblob = utilfdt_read(input_filename, &buf_len);\n\tif (!blob) {\n\t\tfprintf(stderr, \"\\nFailed to read '%s'\\n\", input_filename);\n\t\tgoto out_err;\n\t}\n\tif (fdt_totalsize(blob) > buf_len) {\n\t\tfprintf(stderr,\n \"\\nBase blob is incomplete (%lu / %\" PRIu32 \" bytes read)\\n\",\n\t\t\t(unsigned long)buf_len, fdt_totalsize(blob));\n\t\tgoto out_err;\n\t}\n\n\t \n\tovblob = xmalloc(sizeof(*ovblob) * argc);\n\tmemset(ovblob, 0, sizeof(*ovblob) * argc);\n\n\t \n\tfor (i = 0; i < argc; i++) {\n\t\tsize_t ov_len;\n\t\tovblob[i] = utilfdt_read(argv[i], &ov_len);\n\t\tif (!ovblob[i]) {\n\t\t\tfprintf(stderr, \"\\nFailed to read '%s'\\n\", argv[i]);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (fdt_totalsize(ovblob[i]) > ov_len) {\n\t\t\tfprintf(stderr,\n\"\\nOverlay '%s' is incomplete (%lu / %\" PRIu32 \" bytes read)\\n\",\n\t\t\t\targv[i], (unsigned long)ov_len,\n\t\t\t\tfdt_totalsize(ovblob[i]));\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tbuf_len = fdt_totalsize(blob);\n\n\t \n\tfor (i = 0; i < argc; i++) {\n\t\tblob = apply_one(blob, ovblob[i], &buf_len, argv[i]);\n\t\tif (!blob)\n\t\t\tgoto out_err;\n\t}\n\n\tfdt_pack(blob);\n\tret = utilfdt_write(output_filename, blob);\n\tif (ret)\n\t\tfprintf(stderr, \"\\nFailed to write '%s'\\n\",\n\t\t\toutput_filename);\n\nout_err:\n\tif (ovblob) {\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (ovblob[i])\n\t\t\t\tfree(ovblob[i]);\n\t\t}\n\t\tfree(ovblob);\n\t}\n\tfree(blob);\n\n\treturn ret;\n}\n\nint main(int argc, char *argv[])\n{\n\tint opt, i;\n\tchar *input_filename = NULL;\n\tchar *output_filename = NULL;\n\n\twhile ((opt = util_getopt_long()) != EOF) {\n\t\tswitch (opt) {\n\t\tcase_USAGE_COMMON_FLAGS\n\n\t\tcase 'i':\n\t\t\tinput_filename = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutput_filename = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!input_filename)\n\t\tusage(\"missing input file\");\n\n\tif (!output_filename)\n\t\tusage(\"missing output file\");\n\n\targv += optind;\n\targc -= optind;\n\n\tif (argc <= 0)\n\t\tusage(\"missing overlay file(s)\");\n\n\tif (verbose) {\n\t\tprintf(\"input  = %s\\n\", input_filename);\n\t\tprintf(\"output = %s\\n\", output_filename);\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tprintf(\"overlay[%d] = %s\\n\", i, argv[i]);\n\t}\n\n\tif (do_fdtoverlay(input_filename, output_filename, argc, argv))\n\t\treturn 1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}