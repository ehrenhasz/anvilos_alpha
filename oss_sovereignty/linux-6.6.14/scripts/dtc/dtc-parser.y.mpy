{
  "module_name": "dtc-parser.y",
  "hash_id": "94c6cc126a196d22d9a2feea20e5a7e6be0a5d7645be8e29766187c60092199e",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/dtc-parser.y",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.\n */\n%locations\n\n%{\n#include <stdio.h>\n#include <inttypes.h>\n\n#include \"dtc.h\"\n#include \"srcpos.h\"\n\nextern int yylex(void);\nextern void yyerror(char const *s);\n#define ERROR(loc, ...) \\\n\tdo { \\\n\t\tsrcpos_error((loc), \"Error\", __VA_ARGS__); \\\n\t\ttreesource_error = true; \\\n\t} while (0)\n\n#define YYERROR_CALL(msg) yyerror(msg)\n\nextern struct dt_info *parser_output;\nextern bool treesource_error;\n\nstatic bool is_ref_relative(const char *ref)\n{\n\treturn ref[0] != '/' && strchr(&ref[1], '/');\n}\n\n%}\n\n%union {\n\tchar *propnodename;\n\tchar *labelref;\n\tuint8_t byte;\n\tstruct data data;\n\n\tstruct {\n\t\tstruct data\tdata;\n\t\tint\t\tbits;\n\t} array;\n\n\tstruct property *prop;\n\tstruct property *proplist;\n\tstruct node *node;\n\tstruct node *nodelist;\n\tstruct reserve_info *re;\n\tuint64_t integer;\n\tunsigned int flags;\n}\n\n%token DT_V1\n%token DT_PLUGIN\n%token DT_MEMRESERVE\n%token DT_LSHIFT DT_RSHIFT DT_LE DT_GE DT_EQ DT_NE DT_AND DT_OR\n%token DT_BITS\n%token DT_DEL_PROP\n%token DT_DEL_NODE\n%token DT_OMIT_NO_REF\n%token <propnodename> DT_PROPNODENAME\n%token <integer> DT_LITERAL\n%token <integer> DT_CHAR_LITERAL\n%token <byte> DT_BYTE\n%token <data> DT_STRING\n%token <labelref> DT_LABEL\n%token <labelref> DT_LABEL_REF\n%token <labelref> DT_PATH_REF\n%token DT_INCBIN\n\n%type <data> propdata\n%type <data> propdataprefix\n%type <flags> header\n%type <flags> headers\n%type <re> memreserve\n%type <re> memreserves\n%type <array> arrayprefix\n%type <data> bytestring\n%type <prop> propdef\n%type <proplist> proplist\n%type <labelref> dt_ref\n\n%type <node> devicetree\n%type <node> nodedef\n%type <node> subnode\n%type <nodelist> subnodes\n\n%type <integer> integer_prim\n%type <integer> integer_unary\n%type <integer> integer_mul\n%type <integer> integer_add\n%type <integer> integer_shift\n%type <integer> integer_rela\n%type <integer> integer_eq\n%type <integer> integer_bitand\n%type <integer> integer_bitxor\n%type <integer> integer_bitor\n%type <integer> integer_and\n%type <integer> integer_or\n%type <integer> integer_trinary\n%type <integer> integer_expr\n\n%%\n\nsourcefile:\n\t  headers memreserves devicetree\n\t\t{\n\t\t\tparser_output = build_dt_info($1, $2, $3,\n\t\t\t                              guess_boot_cpuid($3));\n\t\t}\n\t;\n\nheader:\n\t  DT_V1 ';'\n\t\t{\n\t\t\t$$ = DTSF_V1;\n\t\t}\n\t| DT_V1 ';' DT_PLUGIN ';'\n\t\t{\n\t\t\t$$ = DTSF_V1 | DTSF_PLUGIN;\n\t\t}\n\t;\n\nheaders:\n\t  header\n\t| header headers\n\t\t{\n\t\t\tif ($2 != $1)\n\t\t\t\tERROR(&@2, \"Header flags don't match earlier ones\");\n\t\t\t$$ = $1;\n\t\t}\n\t;\n\nmemreserves:\n\t  /* empty */\n\t\t{\n\t\t\t$$ = NULL;\n\t\t}\n\t| memreserve memreserves\n\t\t{\n\t\t\t$$ = chain_reserve_entry($1, $2);\n\t\t}\n\t;\n\nmemreserve:\n\t  DT_MEMRESERVE integer_prim integer_prim ';'\n\t\t{\n\t\t\t$$ = build_reserve_entry($2, $3);\n\t\t}\n\t| DT_LABEL memreserve\n\t\t{\n\t\t\tadd_label(&$2->labels, $1);\n\t\t\t$$ = $2;\n\t\t}\n\t;\n\ndt_ref: DT_LABEL_REF | DT_PATH_REF;\n\ndevicetree:\n\t  '/' nodedef\n\t\t{\n\t\t\t$$ = name_node($2, \"\");\n\t\t}\n\t| devicetree '/' nodedef\n\t\t{\n\t\t\t$$ = merge_nodes($1, $3);\n\t\t}\n\t| dt_ref nodedef\n\t\t{\n\t\t\t/*\n\t\t\t * We rely on the rule being always:\n\t\t\t *   versioninfo plugindecl memreserves devicetree\n\t\t\t * so $-1 is what we want (plugindecl)\n\t\t\t */\n\t\t\tif (!($<flags>-1 & DTSF_PLUGIN))\n\t\t\t\tERROR(&@2, \"Label or path %s not found\", $1);\n\t\t\telse if (is_ref_relative($1))\n\t\t\t\tERROR(&@2, \"Label-relative reference %s not supported in plugin\", $1);\n\t\t\t$$ = add_orphan_node(\n\t\t\t\t\tname_node(build_node(NULL, NULL, NULL),\n\t\t\t\t\t\t  \"\"),\n\t\t\t\t\t$2, $1);\n\t\t}\n\t| devicetree DT_LABEL dt_ref nodedef\n\t\t{\n\t\t\tstruct node *target = get_node_by_ref($1, $3);\n\n\t\t\tif (($<flags>-1 & DTSF_PLUGIN) && is_ref_relative($3))\n\t\t\t\tERROR(&@2, \"Label-relative reference %s not supported in plugin\", $3);\n\n\t\t\tif (target) {\n\t\t\t\tadd_label(&target->labels, $2);\n\t\t\t\tmerge_nodes(target, $4);\n\t\t\t} else\n\t\t\t\tERROR(&@3, \"Label or path %s not found\", $3);\n\t\t\t$$ = $1;\n\t\t}\n\t| devicetree DT_PATH_REF nodedef\n\t\t{\n\t\t\t/*\n\t\t\t * We rely on the rule being always:\n\t\t\t *   versioninfo plugindecl memreserves devicetree\n\t\t\t * so $-1 is what we want (plugindecl)\n\t\t\t */\n\t\t\tif ($<flags>-1 & DTSF_PLUGIN) {\n\t\t\t\tif (is_ref_relative($2))\n\t\t\t\t\tERROR(&@2, \"Label-relative reference %s not supported in plugin\", $2);\n\t\t\t\tadd_orphan_node($1, $3, $2);\n\t\t\t} else {\n\t\t\t\tstruct node *target = get_node_by_ref($1, $2);\n\n\t\t\t\tif (target)\n\t\t\t\t\tmerge_nodes(target, $3);\n\t\t\t\telse\n\t\t\t\t\tERROR(&@2, \"Label or path %s not found\", $2);\n\t\t\t}\n\t\t\t$$ = $1;\n\t\t}\n\t| devicetree DT_LABEL_REF nodedef\n\t\t{\n\t\t\tstruct node *target = get_node_by_ref($1, $2);\n\n\t\t\tif (target) {\n\t\t\t\tmerge_nodes(target, $3);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We rely on the rule being always:\n\t\t\t\t *   versioninfo plugindecl memreserves devicetree\n\t\t\t\t * so $-1 is what we want (plugindecl)\n\t\t\t\t */\n\t\t\t\tif ($<flags>-1 & DTSF_PLUGIN)\n\t\t\t\t\tadd_orphan_node($1, $3, $2);\n\t\t\t\telse\n\t\t\t\t\tERROR(&@2, \"Label or path %s not found\", $2);\n\t\t\t}\n\t\t\t$$ = $1;\n\t\t}\n\t| devicetree DT_DEL_NODE dt_ref ';'\n\t\t{\n\t\t\tstruct node *target = get_node_by_ref($1, $3);\n\n\t\t\tif (target)\n\t\t\t\tdelete_node(target);\n\t\t\telse\n\t\t\t\tERROR(&@3, \"Label or path %s not found\", $3);\n\n\n\t\t\t$$ = $1;\n\t\t}\n\t| devicetree DT_OMIT_NO_REF dt_ref ';'\n\t\t{\n\t\t\tstruct node *target = get_node_by_ref($1, $3);\n\n\t\t\tif (target)\n\t\t\t\tomit_node_if_unused(target);\n\t\t\telse\n\t\t\t\tERROR(&@3, \"Label or path %s not found\", $3);\n\n\n\t\t\t$$ = $1;\n\t\t}\n\t;\n\nnodedef:\n\t  '{' proplist subnodes '}' ';'\n\t\t{\n\t\t\t$$ = build_node($2, $3, &@$);\n\t\t}\n\t;\n\nproplist:\n\t  /* empty */\n\t\t{\n\t\t\t$$ = NULL;\n\t\t}\n\t| proplist propdef\n\t\t{\n\t\t\t$$ = chain_property($2, $1);\n\t\t}\n\t;\n\npropdef:\n\t  DT_PROPNODENAME '=' propdata ';'\n\t\t{\n\t\t\t$$ = build_property($1, $3, &@$);\n\t\t}\n\t| DT_PROPNODENAME ';'\n\t\t{\n\t\t\t$$ = build_property($1, empty_data, &@$);\n\t\t}\n\t| DT_DEL_PROP DT_PROPNODENAME ';'\n\t\t{\n\t\t\t$$ = build_property_delete($2);\n\t\t}\n\t| DT_LABEL propdef\n\t\t{\n\t\t\tadd_label(&$2->labels, $1);\n\t\t\t$$ = $2;\n\t\t}\n\t;\n\npropdata:\n\t  propdataprefix DT_STRING\n\t\t{\n\t\t\t$$ = data_merge($1, $2);\n\t\t}\n\t| propdataprefix arrayprefix '>'\n\t\t{\n\t\t\t$$ = data_merge($1, $2.data);\n\t\t}\n\t| propdataprefix '[' bytestring ']'\n\t\t{\n\t\t\t$$ = data_merge($1, $3);\n\t\t}\n\t| propdataprefix dt_ref\n\t\t{\n\t\t\t$1 = data_add_marker($1, TYPE_STRING, $2);\n\t\t\t$$ = data_add_marker($1, REF_PATH, $2);\n\t\t}\n\t| propdataprefix DT_INCBIN '(' DT_STRING ',' integer_prim ',' integer_prim ')'\n\t\t{\n\t\t\tFILE *f = srcfile_relative_open($4.val, NULL);\n\t\t\tstruct data d;\n\n\t\t\tif ($6 != 0)\n\t\t\t\tif (fseek(f, $6, SEEK_SET) != 0)\n\t\t\t\t\tdie(\"Couldn't seek to offset %llu in \\\"%s\\\": %s\",\n\t\t\t\t\t    (unsigned long long)$6, $4.val,\n\t\t\t\t\t    strerror(errno));\n\n\t\t\td = data_copy_file(f, $8);\n\n\t\t\t$$ = data_merge($1, d);\n\t\t\tfclose(f);\n\t\t}\n\t| propdataprefix DT_INCBIN '(' DT_STRING ')'\n\t\t{\n\t\t\tFILE *f = srcfile_relative_open($4.val, NULL);\n\t\t\tstruct data d = empty_data;\n\n\t\t\td = data_copy_file(f, -1);\n\n\t\t\t$$ = data_merge($1, d);\n\t\t\tfclose(f);\n\t\t}\n\t| propdata DT_LABEL\n\t\t{\n\t\t\t$$ = data_add_marker($1, LABEL, $2);\n\t\t}\n\t;\n\npropdataprefix:\n\t  /* empty */\n\t\t{\n\t\t\t$$ = empty_data;\n\t\t}\n\t| propdata ','\n\t\t{\n\t\t\t$$ = $1;\n\t\t}\n\t| propdataprefix DT_LABEL\n\t\t{\n\t\t\t$$ = data_add_marker($1, LABEL, $2);\n\t\t}\n\t;\n\narrayprefix:\n\tDT_BITS DT_LITERAL '<'\n\t\t{\n\t\t\tunsigned long long bits;\n\t\t\tenum markertype type = TYPE_UINT32;\n\n\t\t\tbits = $2;\n\n\t\t\tswitch (bits) {\n\t\t\tcase 8: type = TYPE_UINT8; break;\n\t\t\tcase 16: type = TYPE_UINT16; break;\n\t\t\tcase 32: type = TYPE_UINT32; break;\n\t\t\tcase 64: type = TYPE_UINT64; break;\n\t\t\tdefault:\n\t\t\t\tERROR(&@2, \"Array elements must be\"\n\t\t\t\t      \" 8, 16, 32 or 64-bits\");\n\t\t\t\tbits = 32;\n\t\t\t}\n\n\t\t\t$$.data = data_add_marker(empty_data, type, NULL);\n\t\t\t$$.bits = bits;\n\t\t}\n\t| '<'\n\t\t{\n\t\t\t$$.data = data_add_marker(empty_data, TYPE_UINT32, NULL);\n\t\t\t$$.bits = 32;\n\t\t}\n\t| arrayprefix integer_prim\n\t\t{\n\t\t\tif ($1.bits < 64) {\n\t\t\t\tuint64_t mask = (1ULL << $1.bits) - 1;\n\t\t\t\t/*\n\t\t\t\t * Bits above mask must either be all zero\n\t\t\t\t * (positive within range of mask) or all one\n\t\t\t\t * (negative and sign-extended). The second\n\t\t\t\t * condition is true if when we set all bits\n\t\t\t\t * within the mask to one (i.e. | in the\n\t\t\t\t * mask), all bits are one.\n\t\t\t\t */\n\t\t\t\tif (($2 > mask) && (($2 | mask) != -1ULL)) {\n\t\t\t\t\tchar *loc = srcpos_string(&@2);\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"WARNING: %s: Value 0x%016\" PRIx64\n\t\t\t\t\t\t\" truncated to 0x%0*\" PRIx64 \"\\n\",\n\t\t\t\t\t\tloc, $2, $1.bits / 4, ($2 & mask));\n\t\t\t\t\tfree(loc);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$$.data = data_append_integer($1.data, $2, $1.bits);\n\t\t}\n\t| arrayprefix dt_ref\n\t\t{\n\t\t\tuint64_t val = ~0ULL >> (64 - $1.bits);\n\n\t\t\tif ($1.bits == 32)\n\t\t\t\t$1.data = data_add_marker($1.data,\n\t\t\t\t\t\t\t  REF_PHANDLE,\n\t\t\t\t\t\t\t  $2);\n\t\t\telse\n\t\t\t\tERROR(&@2, \"References are only allowed in \"\n\t\t\t\t\t    \"arrays with 32-bit elements.\");\n\n\t\t\t$$.data = data_append_integer($1.data, val, $1.bits);\n\t\t}\n\t| arrayprefix DT_LABEL\n\t\t{\n\t\t\t$$.data = data_add_marker($1.data, LABEL, $2);\n\t\t}\n\t;\n\ninteger_prim:\n\t  DT_LITERAL\n\t| DT_CHAR_LITERAL\n\t| '(' integer_expr ')'\n\t\t{\n\t\t\t$$ = $2;\n\t\t}\n\t;\n\ninteger_expr:\n\tinteger_trinary\n\t;\n\ninteger_trinary:\n\t  integer_or\n\t| integer_or '?' integer_expr ':' integer_trinary { $$ = $1 ? $3 : $5; }\n\t;\n\ninteger_or:\n\t  integer_and\n\t| integer_or DT_OR integer_and { $$ = $1 || $3; }\n\t;\n\ninteger_and:\n\t  integer_bitor\n\t| integer_and DT_AND integer_bitor { $$ = $1 && $3; }\n\t;\n\ninteger_bitor:\n\t  integer_bitxor\n\t| integer_bitor '|' integer_bitxor { $$ = $1 | $3; }\n\t;\n\ninteger_bitxor:\n\t  integer_bitand\n\t| integer_bitxor '^' integer_bitand { $$ = $1 ^ $3; }\n\t;\n\ninteger_bitand:\n\t  integer_eq\n\t| integer_bitand '&' integer_eq { $$ = $1 & $3; }\n\t;\n\ninteger_eq:\n\t  integer_rela\n\t| integer_eq DT_EQ integer_rela { $$ = $1 == $3; }\n\t| integer_eq DT_NE integer_rela { $$ = $1 != $3; }\n\t;\n\ninteger_rela:\n\t  integer_shift\n\t| integer_rela '<' integer_shift { $$ = $1 < $3; }\n\t| integer_rela '>' integer_shift { $$ = $1 > $3; }\n\t| integer_rela DT_LE integer_shift { $$ = $1 <= $3; }\n\t| integer_rela DT_GE integer_shift { $$ = $1 >= $3; }\n\t;\n\ninteger_shift:\n\t  integer_shift DT_LSHIFT integer_add { $$ = ($3 < 64) ? ($1 << $3) : 0; }\n\t| integer_shift DT_RSHIFT integer_add { $$ = ($3 < 64) ? ($1 >> $3) : 0; }\n\t| integer_add\n\t;\n\ninteger_add:\n\t  integer_add '+' integer_mul { $$ = $1 + $3; }\n\t| integer_add '-' integer_mul { $$ = $1 - $3; }\n\t| integer_mul\n\t;\n\ninteger_mul:\n\t  integer_mul '*' integer_unary { $$ = $1 * $3; }\n\t| integer_mul '/' integer_unary\n\t\t{\n\t\t\tif ($3 != 0) {\n\t\t\t\t$$ = $1 / $3;\n\t\t\t} else {\n\t\t\t\tERROR(&@$, \"Division by zero\");\n\t\t\t\t$$ = 0;\n\t\t\t}\n\t\t}\n\t| integer_mul '%' integer_unary\n\t\t{\n\t\t\tif ($3 != 0) {\n\t\t\t\t$$ = $1 % $3;\n\t\t\t} else {\n\t\t\t\tERROR(&@$, \"Division by zero\");\n\t\t\t\t$$ = 0;\n\t\t\t}\n\t\t}\n\t| integer_unary\n\t;\n\ninteger_unary:\n\t  integer_prim\n\t| '-' integer_unary { $$ = -$2; }\n\t| '~' integer_unary { $$ = ~$2; }\n\t| '!' integer_unary { $$ = !$2; }\n\t;\n\nbytestring:\n\t  /* empty */\n\t\t{\n\t\t\t$$ = data_add_marker(empty_data, TYPE_UINT8, NULL);\n\t\t}\n\t| bytestring DT_BYTE\n\t\t{\n\t\t\t$$ = data_append_byte($1, $2);\n\t\t}\n\t| bytestring DT_LABEL\n\t\t{\n\t\t\t$$ = data_add_marker($1, LABEL, $2);\n\t\t}\n\t;\n\nsubnodes:\n\t  /* empty */\n\t\t{\n\t\t\t$$ = NULL;\n\t\t}\n\t| subnode subnodes\n\t\t{\n\t\t\t$$ = chain_node($1, $2);\n\t\t}\n\t| subnode propdef\n\t\t{\n\t\t\tERROR(&@2, \"Properties must precede subnodes\");\n\t\t\tYYERROR;\n\t\t}\n\t;\n\nsubnode:\n\t  DT_PROPNODENAME nodedef\n\t\t{\n\t\t\t$$ = name_node($2, $1);\n\t\t}\n\t| DT_DEL_NODE DT_PROPNODENAME ';'\n\t\t{\n\t\t\t$$ = name_node(build_node_delete(&@$), $2);\n\t\t}\n\t| DT_OMIT_NO_REF subnode\n\t\t{\n\t\t\t$$ = omit_node_if_unused($2);\n\t\t}\n\t| DT_LABEL subnode\n\t\t{\n\t\t\tadd_label(&$2->labels, $1);\n\t\t\t$$ = $2;\n\t\t}\n\t;\n\n%%\n\nvoid yyerror(char const *s)\n{\n\tERROR(&yylloc, \"%s\", s);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}