{
  "module_name": "dtc-lexer.l",
  "hash_id": "250a56c3f55ce15b3d65b9e9382baf6bcbb346e328c74805b9a24f1ec2d17bb8",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dtc/dtc-lexer.l",
  "human_readable_source": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.\n */\n\n%option noyywrap nounput noinput never-interactive\n\n%x BYTESTRING\n%x PROPNODENAME\n%s V1\n\nPROPNODECHAR\t[a-zA-Z0-9,._+*#?@-]\nPATHCHAR\t({PROPNODECHAR}|[/])\nLABEL\t\t[a-zA-Z_][a-zA-Z0-9_]*\nSTRING\t\t\\\"([^\\\\\"]|\\\\.)*\\\"\nCHAR_LITERAL\t'([^']|\\\\')*'\nWS\t\t[[:space:]]\nCOMMENT\t\t\"/*\"([^*]|\\*+[^*/])*\\*+\"/\"\nLINECOMMENT\t\"//\".*\\n\n\n%{\n#include \"dtc.h\"\n#include \"srcpos.h\"\n#include \"dtc-parser.tab.h\"\n\nextern bool treesource_error;\n\n/* CAUTION: this will stop working if we ever use yyless() or yyunput() */\n#define\tYY_USER_ACTION \\\n\t{ \\\n\t\tsrcpos_update(&yylloc, yytext, yyleng); \\\n\t}\n\n/*#define LEXDEBUG\t1*/\n\n#ifdef LEXDEBUG\n#define DPRINT(fmt, ...)\tfprintf(stderr, fmt, ##__VA_ARGS__)\n#else\n#define DPRINT(fmt, ...)\tdo { } while (0)\n#endif\n\nstatic int dts_version = 1;\n\n#define BEGIN_DEFAULT()\t\tDPRINT(\"<V1>\\n\"); \\\n\t\t\t\tBEGIN(V1); \\\n\nstatic void push_input_file(const char *filename);\nstatic bool pop_input_file(void);\nstatic void PRINTF(1, 2) lexical_error(const char *fmt, ...);\n\n%}\n\n%%\n<*>\"/include/\"{WS}*{STRING} {\n\t\t\tchar *name = strchr(yytext, '\\\"') + 1;\n\t\t\tyytext[yyleng-1] = '\\0';\n\t\t\tpush_input_file(name);\n\t\t}\n\n<*>^\"#\"(line)?[ \\t]+[0-9]+[ \\t]+{STRING}([ \\t]+[0-9]+)* {\n\t\t\tchar *line, *fnstart, *fnend;\n\t\t\tstruct data fn;\n\t\t\t/* skip text before line # */\n\t\t\tline = yytext;\n\t\t\twhile (!isdigit((unsigned char)*line))\n\t\t\t\tline++;\n\n\t\t\t/* regexp ensures that first and list \"\n\t\t\t * in the whole yytext are those at\n\t\t\t * beginning and end of the filename string */\n\t\t\tfnstart = memchr(yytext, '\"', yyleng);\n\t\t\tfor (fnend = yytext + yyleng - 1;\n\t\t\t     *fnend != '\"'; fnend--)\n\t\t\t\t;\n\t\t\tassert(fnstart && fnend && (fnend > fnstart));\n\n\t\t\tfn = data_copy_escape_string(fnstart + 1,\n\t\t\t\t\t\t     fnend - fnstart - 1);\n\n\t\t\t/* Don't allow nuls in filenames */\n\t\t\tif (memchr(fn.val, '\\0', fn.len - 1))\n\t\t\t\tlexical_error(\"nul in line number directive\");\n\n\t\t\t/* -1 since #line is the number of the next line */\n\t\t\tsrcpos_set_line(xstrdup(fn.val), atoi(line) - 1);\n\t\t\tdata_free(fn);\n\t\t}\n\n<*><<EOF>>\t\t{\n\t\t\tif (!pop_input_file()) {\n\t\t\t\tyyterminate();\n\t\t\t}\n\t\t}\n\n<*>{STRING}\t{\n\t\t\tDPRINT(\"String: %s\\n\", yytext);\n\t\t\tyylval.data = data_copy_escape_string(yytext+1,\n\t\t\t\t\tyyleng-2);\n\t\t\treturn DT_STRING;\n\t\t}\n\n<*>\"/dts-v1/\"\t{\n\t\t\tDPRINT(\"Keyword: /dts-v1/\\n\");\n\t\t\tdts_version = 1;\n\t\t\tBEGIN_DEFAULT();\n\t\t\treturn DT_V1;\n\t\t}\n\n<*>\"/plugin/\"\t{\n\t\t\tDPRINT(\"Keyword: /plugin/\\n\");\n\t\t\treturn DT_PLUGIN;\n\t\t}\n\n<*>\"/memreserve/\"\t{\n\t\t\tDPRINT(\"Keyword: /memreserve/\\n\");\n\t\t\tBEGIN_DEFAULT();\n\t\t\treturn DT_MEMRESERVE;\n\t\t}\n\n<*>\"/bits/\"\t{\n\t\t\tDPRINT(\"Keyword: /bits/\\n\");\n\t\t\tBEGIN_DEFAULT();\n\t\t\treturn DT_BITS;\n\t\t}\n\n<*>\"/delete-property/\"\t{\n\t\t\tDPRINT(\"Keyword: /delete-property/\\n\");\n\t\t\tDPRINT(\"<PROPNODENAME>\\n\");\n\t\t\tBEGIN(PROPNODENAME);\n\t\t\treturn DT_DEL_PROP;\n\t\t}\n\n<*>\"/delete-node/\"\t{\n\t\t\tDPRINT(\"Keyword: /delete-node/\\n\");\n\t\t\tDPRINT(\"<PROPNODENAME>\\n\");\n\t\t\tBEGIN(PROPNODENAME);\n\t\t\treturn DT_DEL_NODE;\n\t\t}\n\n<*>\"/omit-if-no-ref/\"\t{\n\t\t\tDPRINT(\"Keyword: /omit-if-no-ref/\\n\");\n\t\t\tDPRINT(\"<PROPNODENAME>\\n\");\n\t\t\tBEGIN(PROPNODENAME);\n\t\t\treturn DT_OMIT_NO_REF;\n\t\t}\n\n<*>{LABEL}:\t{\n\t\t\tDPRINT(\"Label: %s\\n\", yytext);\n\t\t\tyylval.labelref = xstrdup(yytext);\n\t\t\tyylval.labelref[yyleng-1] = '\\0';\n\t\t\treturn DT_LABEL;\n\t\t}\n\n<V1>([0-9]+|0[xX][0-9a-fA-F]+)(U|L|UL|LL|ULL)? {\n\t\t\tchar *e;\n\t\t\tDPRINT(\"Integer Literal: '%s'\\n\", yytext);\n\n\t\t\terrno = 0;\n\t\t\tyylval.integer = strtoull(yytext, &e, 0);\n\n\t\t\tif (*e && e[strspn(e, \"UL\")]) {\n\t\t\t\tlexical_error(\"Bad integer literal '%s'\",\n\t\t\t\t\t      yytext);\n\t\t\t}\n\n\t\t\tif (errno == ERANGE)\n\t\t\t\tlexical_error(\"Integer literal '%s' out of range\",\n\t\t\t\t\t      yytext);\n\t\t\telse\n\t\t\t\t/* ERANGE is the only strtoull error triggerable\n\t\t\t\t *  by strings matching the pattern */\n\t\t\t\tassert(errno == 0);\n\t\t\treturn DT_LITERAL;\n\t\t}\n\n<*>{CHAR_LITERAL}\t{\n\t\t\tstruct data d;\n\t\t\tDPRINT(\"Character literal: %s\\n\", yytext);\n\n\t\t\td = data_copy_escape_string(yytext+1, yyleng-2);\n\t\t\tif (d.len == 1) {\n\t\t\t\tlexical_error(\"Empty character literal\");\n\t\t\t\tyylval.integer = 0;\n\t\t\t} else {\n\t\t\t\tyylval.integer = (unsigned char)d.val[0];\n\n\t\t\t\tif (d.len > 2)\n\t\t\t\t\tlexical_error(\"Character literal has %d\"\n\t\t\t\t\t\t      \" characters instead of 1\",\n\t\t\t\t\t\t      d.len - 1);\n\t\t\t}\n\n\t\t\tdata_free(d);\n\t\t\treturn DT_CHAR_LITERAL;\n\t\t}\n\n<*>\\&{LABEL}\t{\t/* label reference */\n\t\t\tDPRINT(\"Ref: %s\\n\", yytext+1);\n\t\t\tyylval.labelref = xstrdup(yytext+1);\n\t\t\treturn DT_LABEL_REF;\n\t\t}\n\n<*>\"&{\"{PATHCHAR}*\\}\t{\t/* new-style path reference */\n\t\t\tyytext[yyleng-1] = '\\0';\n\t\t\tDPRINT(\"Ref: %s\\n\", yytext+2);\n\t\t\tyylval.labelref = xstrdup(yytext+2);\n\t\t\treturn DT_PATH_REF;\n\t\t}\n\n<BYTESTRING>[0-9a-fA-F]{2} {\n\t\t\tyylval.byte = strtol(yytext, NULL, 16);\n\t\t\tDPRINT(\"Byte: %02x\\n\", (int)yylval.byte);\n\t\t\treturn DT_BYTE;\n\t\t}\n\n<BYTESTRING>\"]\"\t{\n\t\t\tDPRINT(\"/BYTESTRING\\n\");\n\t\t\tBEGIN_DEFAULT();\n\t\t\treturn ']';\n\t\t}\n\n<PROPNODENAME>\\\\?{PROPNODECHAR}+ {\n\t\t\tDPRINT(\"PropNodeName: %s\\n\", yytext);\n\t\t\tyylval.propnodename = xstrdup((yytext[0] == '\\\\') ?\n\t\t\t\t\t\t\tyytext + 1 : yytext);\n\t\t\tBEGIN_DEFAULT();\n\t\t\treturn DT_PROPNODENAME;\n\t\t}\n\n\"/incbin/\"\t{\n\t\t\tDPRINT(\"Binary Include\\n\");\n\t\t\treturn DT_INCBIN;\n\t\t}\n\n<*>{WS}+\t/* eat whitespace */\n<*>{COMMENT}+\t/* eat C-style comments */\n<*>{LINECOMMENT}+ /* eat C++-style comments */\n\n<*>\"<<\"\t\t{ return DT_LSHIFT; };\n<*>\">>\"\t\t{ return DT_RSHIFT; };\n<*>\"<=\"\t\t{ return DT_LE; };\n<*>\">=\"\t\t{ return DT_GE; };\n<*>\"==\"\t\t{ return DT_EQ; };\n<*>\"!=\"\t\t{ return DT_NE; };\n<*>\"&&\"\t\t{ return DT_AND; };\n<*>\"||\"\t\t{ return DT_OR; };\n\n<*>.\t\t{\n\t\t\tDPRINT(\"Char: %c (\\\\x%02x)\\n\", yytext[0],\n\t\t\t\t(unsigned)yytext[0]);\n\t\t\tif (yytext[0] == '[') {\n\t\t\t\tDPRINT(\"<BYTESTRING>\\n\");\n\t\t\t\tBEGIN(BYTESTRING);\n\t\t\t}\n\t\t\tif ((yytext[0] == '{')\n\t\t\t    || (yytext[0] == ';')) {\n\t\t\t\tDPRINT(\"<PROPNODENAME>\\n\");\n\t\t\t\tBEGIN(PROPNODENAME);\n\t\t\t}\n\t\t\treturn yytext[0];\n\t\t}\n\n%%\n\nstatic void push_input_file(const char *filename)\n{\n\tassert(filename);\n\n\tsrcfile_push(filename);\n\n\tyyin = current_srcfile->f;\n\n\tyypush_buffer_state(yy_create_buffer(yyin, YY_BUF_SIZE));\n}\n\n\nstatic bool pop_input_file(void)\n{\n\tif (srcfile_pop() == 0)\n\t\treturn false;\n\n\tyypop_buffer_state();\n\tyyin = current_srcfile->f;\n\n\treturn true;\n}\n\nstatic void lexical_error(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tsrcpos_verror(&yylloc, \"Lexical error\", fmt, ap);\n\tva_end(ap);\n\n\ttreesource_error = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}