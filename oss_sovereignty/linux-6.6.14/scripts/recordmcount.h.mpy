{
  "module_name": "recordmcount.h",
  "hash_id": "2fae50d887ed375c69ca44fbd18f92588dc29a44ed497cbb7489cb79912ca208",
  "original_prompt": "Ingested from linux-6.6.14/scripts/recordmcount.h",
  "human_readable_source": " \n \n#undef append_func\n#undef is_fake_mcount\n#undef fn_is_fake_mcount\n#undef MIPS_is_fake_mcount\n#undef mcount_adjust\n#undef sift_rel_mcount\n#undef nop_mcount\n#undef find_secsym_ndx\n#undef __has_rel_mcount\n#undef has_rel_mcount\n#undef tot_relsize\n#undef get_mcountsym\n#undef find_symtab\n#undef get_shnum\n#undef set_shnum\n#undef get_shstrndx\n#undef get_symindex\n#undef get_sym_str_and_relp\n#undef do_func\n#undef Elf_Addr\n#undef Elf_Ehdr\n#undef Elf_Shdr\n#undef Elf_Rel\n#undef Elf_Rela\n#undef Elf_Sym\n#undef ELF_R_SYM\n#undef Elf_r_sym\n#undef ELF_R_INFO\n#undef Elf_r_info\n#undef ELF_ST_BIND\n#undef ELF_ST_TYPE\n#undef fn_ELF_R_SYM\n#undef fn_ELF_R_INFO\n#undef uint_t\n#undef _w\n#undef _align\n#undef _size\n\n#ifdef RECORD_MCOUNT_64\n# define append_func\t\tappend64\n# define sift_rel_mcount\tsift64_rel_mcount\n# define nop_mcount\t\tnop_mcount_64\n# define find_secsym_ndx\tfind64_secsym_ndx\n# define __has_rel_mcount\t__has64_rel_mcount\n# define has_rel_mcount\t\thas64_rel_mcount\n# define tot_relsize\t\ttot64_relsize\n# define find_symtab\t\tfind_symtab64\n# define get_shnum\t\tget_shnum64\n# define set_shnum\t\tset_shnum64\n# define get_shstrndx\t\tget_shstrndx64\n# define get_symindex\t\tget_symindex64\n# define get_sym_str_and_relp\tget_sym_str_and_relp_64\n# define do_func\t\tdo64\n# define get_mcountsym\t\tget_mcountsym_64\n# define is_fake_mcount\t\tis_fake_mcount64\n# define fn_is_fake_mcount\tfn_is_fake_mcount64\n# define MIPS_is_fake_mcount\tMIPS64_is_fake_mcount\n# define mcount_adjust\t\tmcount_adjust_64\n# define Elf_Addr\t\tElf64_Addr\n# define Elf_Ehdr\t\tElf64_Ehdr\n# define Elf_Shdr\t\tElf64_Shdr\n# define Elf_Rel\t\tElf64_Rel\n# define Elf_Rela\t\tElf64_Rela\n# define Elf_Sym\t\tElf64_Sym\n# define ELF_R_SYM\t\tELF64_R_SYM\n# define Elf_r_sym\t\tElf64_r_sym\n# define ELF_R_INFO\t\tELF64_R_INFO\n# define Elf_r_info\t\tElf64_r_info\n# define ELF_ST_BIND\t\tELF64_ST_BIND\n# define ELF_ST_TYPE\t\tELF64_ST_TYPE\n# define fn_ELF_R_SYM\t\tfn_ELF64_R_SYM\n# define fn_ELF_R_INFO\t\tfn_ELF64_R_INFO\n# define uint_t\t\t\tuint64_t\n# define _w\t\t\tw8\n# define _align\t\t\t7u\n# define _size\t\t\t8\n#else\n# define append_func\t\tappend32\n# define sift_rel_mcount\tsift32_rel_mcount\n# define nop_mcount\t\tnop_mcount_32\n# define find_secsym_ndx\tfind32_secsym_ndx\n# define __has_rel_mcount\t__has32_rel_mcount\n# define has_rel_mcount\t\thas32_rel_mcount\n# define tot_relsize\t\ttot32_relsize\n# define find_symtab\t\tfind_symtab32\n# define get_shnum\t\tget_shnum32\n# define set_shnum\t\tset_shnum32\n# define get_shstrndx\t\tget_shstrndx32\n# define get_symindex\t\tget_symindex32\n# define get_sym_str_and_relp\tget_sym_str_and_relp_32\n# define do_func\t\tdo32\n# define get_mcountsym\t\tget_mcountsym_32\n# define is_fake_mcount\t\tis_fake_mcount32\n# define fn_is_fake_mcount\tfn_is_fake_mcount32\n# define MIPS_is_fake_mcount\tMIPS32_is_fake_mcount\n# define mcount_adjust\t\tmcount_adjust_32\n# define Elf_Addr\t\tElf32_Addr\n# define Elf_Ehdr\t\tElf32_Ehdr\n# define Elf_Shdr\t\tElf32_Shdr\n# define Elf_Rel\t\tElf32_Rel\n# define Elf_Rela\t\tElf32_Rela\n# define Elf_Sym\t\tElf32_Sym\n# define ELF_R_SYM\t\tELF32_R_SYM\n# define Elf_r_sym\t\tElf32_r_sym\n# define ELF_R_INFO\t\tELF32_R_INFO\n# define Elf_r_info\t\tElf32_r_info\n# define ELF_ST_BIND\t\tELF32_ST_BIND\n# define ELF_ST_TYPE\t\tELF32_ST_TYPE\n# define fn_ELF_R_SYM\t\tfn_ELF32_R_SYM\n# define fn_ELF_R_INFO\t\tfn_ELF32_R_INFO\n# define uint_t\t\t\tuint32_t\n# define _w\t\t\tw\n# define _align\t\t\t3u\n# define _size\t\t\t4\n#endif\n\n \nstatic int fn_is_fake_mcount(Elf_Rel const *rp)\n{\n\treturn 0;\n}\nstatic int (*is_fake_mcount)(Elf_Rel const *rp) = fn_is_fake_mcount;\n\nstatic uint_t fn_ELF_R_SYM(Elf_Rel const *rp)\n{\n\treturn ELF_R_SYM(_w(rp->r_info));\n}\nstatic uint_t (*Elf_r_sym)(Elf_Rel const *rp) = fn_ELF_R_SYM;\n\nstatic void fn_ELF_R_INFO(Elf_Rel *const rp, unsigned sym, unsigned type)\n{\n\trp->r_info = _w(ELF_R_INFO(sym, type));\n}\nstatic void (*Elf_r_info)(Elf_Rel *const rp, unsigned sym, unsigned type) = fn_ELF_R_INFO;\n\nstatic int mcount_adjust = 0;\n\n \n#define MIPS_FAKEMCOUNT_OFFSET\t4\n\nstatic int MIPS_is_fake_mcount(Elf_Rel const *rp)\n{\n\tstatic Elf_Addr old_r_offset = ~(Elf_Addr)0;\n\tElf_Addr current_r_offset = _w(rp->r_offset);\n\tint is_fake;\n\n\tis_fake = (old_r_offset != ~(Elf_Addr)0) &&\n\t\t(current_r_offset - old_r_offset == MIPS_FAKEMCOUNT_OFFSET);\n\told_r_offset = current_r_offset;\n\n\treturn is_fake;\n}\n\nstatic unsigned int get_symindex(Elf_Sym const *sym, Elf32_Word const *symtab,\n\t\t\t\t Elf32_Word const *symtab_shndx)\n{\n\tunsigned long offset;\n\tunsigned short shndx = w2(sym->st_shndx);\n\tint index;\n\n\tif (shndx > SHN_UNDEF && shndx < SHN_LORESERVE)\n\t\treturn shndx;\n\n\tif (shndx == SHN_XINDEX) {\n\t\toffset = (unsigned long)sym - (unsigned long)symtab;\n\t\tindex = offset / sizeof(*sym);\n\n\t\treturn w(symtab_shndx[index]);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int get_shnum(Elf_Ehdr const *ehdr, Elf_Shdr const *shdr0)\n{\n\tif (shdr0 && !ehdr->e_shnum)\n\t\treturn w(shdr0->sh_size);\n\n\treturn w2(ehdr->e_shnum);\n}\n\nstatic void set_shnum(Elf_Ehdr *ehdr, Elf_Shdr *shdr0, unsigned int new_shnum)\n{\n\tif (new_shnum >= SHN_LORESERVE) {\n\t\tehdr->e_shnum = 0;\n\t\tshdr0->sh_size = w(new_shnum);\n\t} else\n\t\tehdr->e_shnum = w2(new_shnum);\n}\n\nstatic int get_shstrndx(Elf_Ehdr const *ehdr, Elf_Shdr const *shdr0)\n{\n\tif (ehdr->e_shstrndx != SHN_XINDEX)\n\t\treturn w2(ehdr->e_shstrndx);\n\n\treturn w(shdr0->sh_link);\n}\n\nstatic void find_symtab(Elf_Ehdr *const ehdr, Elf_Shdr const *shdr0,\n\t\t\tunsigned const nhdr, Elf32_Word **symtab,\n\t\t\tElf32_Word **symtab_shndx)\n{\n\tElf_Shdr const *relhdr;\n\tunsigned k;\n\n\t*symtab = NULL;\n\t*symtab_shndx = NULL;\n\n\tfor (relhdr = shdr0, k = nhdr; k; --k, ++relhdr) {\n\t\tif (relhdr->sh_type == SHT_SYMTAB)\n\t\t\t*symtab = (void *)ehdr + relhdr->sh_offset;\n\t\telse if (relhdr->sh_type == SHT_SYMTAB_SHNDX)\n\t\t\t*symtab_shndx = (void *)ehdr + relhdr->sh_offset;\n\n\t\tif (*symtab && *symtab_shndx)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic int append_func(Elf_Ehdr *const ehdr,\n\t\t\tElf_Shdr *const shstr,\n\t\t\tuint_t const *const mloc0,\n\t\t\tuint_t const *const mlocp,\n\t\t\tElf_Rel const *const mrel0,\n\t\t\tElf_Rel const *const mrelp,\n\t\t\tunsigned int const rel_entsize,\n\t\t\tunsigned int const symsec_sh_link)\n{\n\t \n\tElf_Shdr mcsec;\n\tchar const *mc_name = (sizeof(Elf_Rela) == rel_entsize)\n\t\t? \".rela__mcount_loc\"\n\t\t:  \".rel__mcount_loc\";\n\tuint_t const old_shoff = _w(ehdr->e_shoff);\n\tuint_t const old_shstr_sh_size   = _w(shstr->sh_size);\n\tuint_t const old_shstr_sh_offset = _w(shstr->sh_offset);\n\tElf_Shdr *const shdr0 = (Elf_Shdr *)(old_shoff + (void *)ehdr);\n\tunsigned int const old_shnum = get_shnum(ehdr, shdr0);\n\tunsigned int const new_shnum = 2 + old_shnum;  \n\tuint_t t = 1 + strlen(mc_name) + _w(shstr->sh_size);\n\tuint_t new_e_shoff;\n\n\tshstr->sh_size = _w(t);\n\tshstr->sh_offset = _w(sb.st_size);\n\tt += sb.st_size;\n\tt += (_align & -t);   \n\tnew_e_shoff = t;\n\n\tset_shnum(ehdr, shdr0, new_shnum);\n\n\t \n\tif (ulseek(sb.st_size, SEEK_SET) < 0)\n\t\treturn -1;\n\tif (uwrite(old_shstr_sh_offset + (void *)ehdr, old_shstr_sh_size) < 0)\n\t\treturn -1;\n\tif (uwrite(mc_name, 1 + strlen(mc_name)) < 0)\n\t\treturn -1;\n\n\t \n\tif (ulseek(t, SEEK_SET) < 0)\n\t\treturn -1;\n\tt += sizeof(Elf_Shdr) * old_shnum;\n\tif (uwrite(old_shoff + (void *)ehdr,\n\t       sizeof(Elf_Shdr) * old_shnum) < 0)\n\t\treturn -1;\n\n\t \n\tt += 2*sizeof(mcsec);\n\tmcsec.sh_name = w((sizeof(Elf_Rela) == rel_entsize) + strlen(\".rel\")\n\t\t+ old_shstr_sh_size);\n\tmcsec.sh_type = w(SHT_PROGBITS);\n\tmcsec.sh_flags = _w(SHF_ALLOC);\n\tmcsec.sh_addr = 0;\n\tmcsec.sh_offset = _w(t);\n\tmcsec.sh_size = _w((void *)mlocp - (void *)mloc0);\n\tmcsec.sh_link = 0;\n\tmcsec.sh_info = 0;\n\tmcsec.sh_addralign = _w(_size);\n\tmcsec.sh_entsize = _w(_size);\n\tif (uwrite(&mcsec, sizeof(mcsec)) < 0)\n\t\treturn -1;\n\n\tmcsec.sh_name = w(old_shstr_sh_size);\n\tmcsec.sh_type = (sizeof(Elf_Rela) == rel_entsize)\n\t\t? w(SHT_RELA)\n\t\t: w(SHT_REL);\n\tmcsec.sh_flags = 0;\n\tmcsec.sh_addr = 0;\n\tmcsec.sh_offset = _w((void *)mlocp - (void *)mloc0 + t);\n\tmcsec.sh_size   = _w((void *)mrelp - (void *)mrel0);\n\tmcsec.sh_link = w(symsec_sh_link);\n\tmcsec.sh_info = w(old_shnum);\n\tmcsec.sh_addralign = _w(_size);\n\tmcsec.sh_entsize = _w(rel_entsize);\n\n\tif (uwrite(&mcsec, sizeof(mcsec)) < 0)\n\t\treturn -1;\n\n\tif (uwrite(mloc0, (void *)mlocp - (void *)mloc0) < 0)\n\t\treturn -1;\n\tif (uwrite(mrel0, (void *)mrelp - (void *)mrel0) < 0)\n\t\treturn -1;\n\n\tehdr->e_shoff = _w(new_e_shoff);\n\tif (ulseek(0, SEEK_SET) < 0)\n\t\treturn -1;\n\tif (uwrite(ehdr, sizeof(*ehdr)) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic unsigned get_mcountsym(Elf_Sym const *const sym0,\n\t\t\t      Elf_Rel const *relp,\n\t\t\t      char const *const str0)\n{\n\tunsigned mcountsym = 0;\n\n\tElf_Sym const *const symp =\n\t\t&sym0[Elf_r_sym(relp)];\n\tchar const *symname = &str0[w(symp->st_name)];\n\tchar const *mcount = gpfx == '_' ? \"_mcount\" : \"mcount\";\n\tchar const *fentry = \"__fentry__\";\n\n\tif (symname[0] == '.')\n\t\t++symname;   \n\tif (strcmp(mcount, symname) == 0 ||\n\t    (altmcount && strcmp(altmcount, symname) == 0) ||\n\t    (strcmp(fentry, symname) == 0))\n\t\tmcountsym = Elf_r_sym(relp);\n\n\treturn mcountsym;\n}\n\nstatic void get_sym_str_and_relp(Elf_Shdr const *const relhdr,\n\t\t\t\t Elf_Ehdr const *const ehdr,\n\t\t\t\t Elf_Sym const **sym0,\n\t\t\t\t char const **str0,\n\t\t\t\t Elf_Rel const **relp)\n{\n\tElf_Shdr *const shdr0 = (Elf_Shdr *)(_w(ehdr->e_shoff)\n\t\t+ (void *)ehdr);\n\tunsigned const symsec_sh_link = w(relhdr->sh_link);\n\tElf_Shdr const *const symsec = &shdr0[symsec_sh_link];\n\tElf_Shdr const *const strsec = &shdr0[w(symsec->sh_link)];\n\tElf_Rel const *const rel0 = (Elf_Rel const *)(_w(relhdr->sh_offset)\n\t\t+ (void *)ehdr);\n\n\t*sym0 = (Elf_Sym const *)(_w(symsec->sh_offset)\n\t\t\t\t  + (void *)ehdr);\n\n\t*str0 = (char const *)(_w(strsec->sh_offset)\n\t\t\t       + (void *)ehdr);\n\n\t*relp = rel0;\n}\n\n \nstatic uint_t *sift_rel_mcount(uint_t *mlocp,\n\t\t\t       unsigned const offbase,\n\t\t\t       Elf_Rel **const mrelpp,\n\t\t\t       Elf_Shdr const *const relhdr,\n\t\t\t       Elf_Ehdr const *const ehdr,\n\t\t\t       unsigned const recsym,\n\t\t\t       uint_t const recval,\n\t\t\t       unsigned const reltype)\n{\n\tuint_t *const mloc0 = mlocp;\n\tElf_Rel *mrelp = *mrelpp;\n\tElf_Sym const *sym0;\n\tchar const *str0;\n\tElf_Rel const *relp;\n\tunsigned rel_entsize = _w(relhdr->sh_entsize);\n\tunsigned const nrel = _w(relhdr->sh_size) / rel_entsize;\n\tunsigned mcountsym = 0;\n\tunsigned t;\n\n\tget_sym_str_and_relp(relhdr, ehdr, &sym0, &str0, &relp);\n\n\tfor (t = nrel; t; --t) {\n\t\tif (!mcountsym)\n\t\t\tmcountsym = get_mcountsym(sym0, relp, str0);\n\n\t\tif (mcountsym && mcountsym == Elf_r_sym(relp) &&\n\t\t\t\t!is_fake_mcount(relp)) {\n\t\t\tuint_t const addend =\n\t\t\t\t_w(_w(relp->r_offset) - recval + mcount_adjust);\n\t\t\tmrelp->r_offset = _w(offbase\n\t\t\t\t+ ((void *)mlocp - (void *)mloc0));\n\t\t\tElf_r_info(mrelp, recsym, reltype);\n\t\t\tif (rel_entsize == sizeof(Elf_Rela)) {\n\t\t\t\t((Elf_Rela *)mrelp)->r_addend = addend;\n\t\t\t\t*mlocp++ = 0;\n\t\t\t} else\n\t\t\t\t*mlocp++ = addend;\n\n\t\t\tmrelp = (Elf_Rel *)(rel_entsize + (void *)mrelp);\n\t\t}\n\t\trelp = (Elf_Rel const *)(rel_entsize + (void *)relp);\n\t}\n\t*mrelpp = mrelp;\n\treturn mlocp;\n}\n\n \nstatic int nop_mcount(Elf_Shdr const *const relhdr,\n\t\t      Elf_Ehdr const *const ehdr,\n\t\t      const char *const txtname)\n{\n\tElf_Shdr *const shdr0 = (Elf_Shdr *)(_w(ehdr->e_shoff)\n\t\t+ (void *)ehdr);\n\tElf_Sym const *sym0;\n\tchar const *str0;\n\tElf_Rel const *relp;\n\tElf_Shdr const *const shdr = &shdr0[w(relhdr->sh_info)];\n\tunsigned rel_entsize = _w(relhdr->sh_entsize);\n\tunsigned const nrel = _w(relhdr->sh_size) / rel_entsize;\n\tunsigned mcountsym = 0;\n\tunsigned t;\n\tint once = 0;\n\n\tget_sym_str_and_relp(relhdr, ehdr, &sym0, &str0, &relp);\n\n\tfor (t = nrel; t; --t) {\n\t\tint ret = -1;\n\n\t\tif (!mcountsym)\n\t\t\tmcountsym = get_mcountsym(sym0, relp, str0);\n\n\t\tif (mcountsym == Elf_r_sym(relp) && !is_fake_mcount(relp)) {\n\t\t\tif (make_nop)\n\t\t\t\tret = make_nop((void *)ehdr, _w(shdr->sh_offset) + _w(relp->r_offset));\n\t\t\tif (warn_on_notrace_sect && !once) {\n\t\t\t\tprintf(\"Section %s has mcount callers being ignored\\n\",\n\t\t\t\t       txtname);\n\t\t\t\tonce = 1;\n\t\t\t\t \n\t\t\t\tif (!make_nop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!ret) {\n\t\t\tElf_Rel rel;\n\t\t\trel = *(Elf_Rel *)relp;\n\t\t\tElf_r_info(&rel, Elf_r_sym(relp), rel_type_nop);\n\t\t\tif (ulseek((void *)relp - (void *)ehdr, SEEK_SET) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (uwrite(&rel, sizeof(rel)) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\trelp = (Elf_Rel const *)(rel_entsize + (void *)relp);\n\t}\n\treturn 0;\n}\n\n \nstatic int find_secsym_ndx(unsigned const txtndx,\n\t\t\t\tchar const *const txtname,\n\t\t\t\tuint_t *const recvalp,\n\t\t\t\tunsigned int *sym_index,\n\t\t\t\tElf_Shdr const *const symhdr,\n\t\t\t\tElf32_Word const *symtab,\n\t\t\t\tElf32_Word const *symtab_shndx,\n\t\t\t\tElf_Ehdr const *const ehdr)\n{\n\tElf_Sym const *const sym0 = (Elf_Sym const *)(_w(symhdr->sh_offset)\n\t\t+ (void *)ehdr);\n\tunsigned const nsym = _w(symhdr->sh_size) / _w(symhdr->sh_entsize);\n\tElf_Sym const *symp;\n\tunsigned t;\n\n\tfor (symp = sym0, t = nsym; t; --t, ++symp) {\n\t\tunsigned int const st_bind = ELF_ST_BIND(symp->st_info);\n\n\t\tif (txtndx == get_symindex(symp, symtab, symtab_shndx)\n\t\t\t \n\t\t    && (STB_LOCAL == st_bind || STB_GLOBAL == st_bind)) {\n\t\t\t \n\t\t\tif (w2(ehdr->e_machine) == EM_ARM\n\t\t\t    && ELF_ST_TYPE(symp->st_info) == STT_FUNC)\n\t\t\t\tcontinue;\n\n\t\t\t*recvalp = _w(symp->st_value);\n\t\t\t*sym_index = symp - sym0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfprintf(stderr, \"Cannot find symbol for section %u: %s.\\n\",\n\t\ttxtndx, txtname);\n\treturn -1;\n}\n\n \nstatic char const * __has_rel_mcount(Elf_Shdr const *const relhdr,  \n\t\t\t\t     Elf_Shdr const *const shdr0,\n\t\t\t\t     char const *const shstrtab,\n\t\t\t\t     char const *const fname)\n{\n\t \n\tElf_Shdr const *const txthdr = &shdr0[w(relhdr->sh_info)];\n\tchar const *const txtname = &shstrtab[w(txthdr->sh_name)];\n\n\tif (strcmp(\"__mcount_loc\", txtname) == 0) {\n\t\tfprintf(stderr, \"warning: __mcount_loc already exists: %s\\n\",\n\t\t\tfname);\n\t\treturn already_has_rel_mcount;\n\t}\n\tif (w(txthdr->sh_type) != SHT_PROGBITS ||\n\t    !(_w(txthdr->sh_flags) & SHF_EXECINSTR))\n\t\treturn NULL;\n\treturn txtname;\n}\n\nstatic char const *has_rel_mcount(Elf_Shdr const *const relhdr,\n\t\t\t\t  Elf_Shdr const *const shdr0,\n\t\t\t\t  char const *const shstrtab,\n\t\t\t\t  char const *const fname)\n{\n\tif (w(relhdr->sh_type) != SHT_REL && w(relhdr->sh_type) != SHT_RELA)\n\t\treturn NULL;\n\treturn __has_rel_mcount(relhdr, shdr0, shstrtab, fname);\n}\n\n\nstatic unsigned tot_relsize(Elf_Shdr const *const shdr0,\n\t\t\t    unsigned nhdr,\n\t\t\t    const char *const shstrtab,\n\t\t\t    const char *const fname)\n{\n\tunsigned totrelsz = 0;\n\tElf_Shdr const *shdrp = shdr0;\n\tchar const *txtname;\n\n\tfor (; nhdr; --nhdr, ++shdrp) {\n\t\ttxtname = has_rel_mcount(shdrp, shdr0, shstrtab, fname);\n\t\tif (txtname == already_has_rel_mcount) {\n\t\t\ttotrelsz = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (txtname && is_mcounted_section_name(txtname))\n\t\t\ttotrelsz += _w(shdrp->sh_size);\n\t}\n\treturn totrelsz;\n}\n\n \nstatic int do_func(Elf_Ehdr *const ehdr, char const *const fname,\n\t\t   unsigned const reltype)\n{\n\tElf_Shdr *const shdr0 = (Elf_Shdr *)(_w(ehdr->e_shoff)\n\t\t+ (void *)ehdr);\n\tunsigned const nhdr = get_shnum(ehdr, shdr0);\n\tElf_Shdr *const shstr = &shdr0[get_shstrndx(ehdr, shdr0)];\n\tchar const *const shstrtab = (char const *)(_w(shstr->sh_offset)\n\t\t+ (void *)ehdr);\n\n\tElf_Shdr const *relhdr;\n\tunsigned k;\n\n\tElf32_Word *symtab;\n\tElf32_Word *symtab_shndx;\n\n\t \n\tunsigned       totrelsz;\n\n\tElf_Rel *      mrel0;\n\tElf_Rel *      mrelp;\n\n\tuint_t *      mloc0;\n\tuint_t *      mlocp;\n\n\tunsigned rel_entsize = 0;\n\tunsigned symsec_sh_link = 0;\n\n\tint result = 0;\n\n\ttotrelsz = tot_relsize(shdr0, nhdr, shstrtab, fname);\n\tif (totrelsz == 0)\n\t\treturn 0;\n\tmrel0 = umalloc(totrelsz);\n\tmrelp = mrel0;\n\tif (!mrel0)\n\t\treturn -1;\n\n\t \n\tmloc0 = umalloc(totrelsz>>1);\n\tmlocp = mloc0;\n\tif (!mloc0) {\n\t\tfree(mrel0);\n\t\treturn -1;\n\t}\n\n\tfind_symtab(ehdr, shdr0, nhdr, &symtab, &symtab_shndx);\n\n\tfor (relhdr = shdr0, k = nhdr; k; --k, ++relhdr) {\n\t\tchar const *const txtname = has_rel_mcount(relhdr, shdr0,\n\t\t\tshstrtab, fname);\n\t\tif (txtname == already_has_rel_mcount) {\n\t\t\tresult = 0;\n\t\t\tfile_updated = 0;\n\t\t\tgoto out;  \n\t\t}\n\t\tif (txtname && is_mcounted_section_name(txtname)) {\n\t\t\tunsigned int recsym;\n\t\t\tuint_t recval = 0;\n\n\t\t\tsymsec_sh_link = w(relhdr->sh_link);\n\t\t\tresult = find_secsym_ndx(w(relhdr->sh_info), txtname,\n\t\t\t\t\t\t&recval, &recsym,\n\t\t\t\t\t\t&shdr0[symsec_sh_link],\n\t\t\t\t\t\tsymtab, symtab_shndx,\n\t\t\t\t\t\tehdr);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\n\t\t\trel_entsize = _w(relhdr->sh_entsize);\n\t\t\tmlocp = sift_rel_mcount(mlocp,\n\t\t\t\t(void *)mlocp - (void *)mloc0, &mrelp,\n\t\t\t\trelhdr, ehdr, recsym, recval, reltype);\n\t\t} else if (txtname && (warn_on_notrace_sect || make_nop)) {\n\t\t\t \n\t\t\tif (nop_mcount(relhdr, ehdr, txtname) < 0) {\n\t\t\t\tresult = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif (!result && mloc0 != mlocp)\n\t\tresult = append_func(ehdr, shstr, mloc0, mlocp, mrel0, mrelp,\n\t\t\t\t     rel_entsize, symsec_sh_link);\nout:\n\tfree(mrel0);\n\tfree(mloc0);\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}