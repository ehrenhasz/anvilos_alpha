{
  "module_name": "dev-needs.sh",
  "hash_id": "39275dfa12daad2647d53fcf87f2d342e58c3e7c3d378c1677f59ac1b199fb92",
  "original_prompt": "Ingested from linux-6.6.14/scripts/dev-needs.sh",
  "human_readable_source": "#! /bin/sh\n# SPDX-License-Identifier: GPL-2.0\n# Copyright (c) 2020, Google LLC. All rights reserved.\n# Author: Saravana Kannan <saravanak@google.com>\n\nfunction help() {\n\tcat << EOF\nUsage: $(basename $0) [-c|-d|-m|-f] [filter options] <list of devices>\n\nThis script needs to be run on the target device once it has booted to a\nshell.\n\nThe script takes as input a list of one or more device directories under\n/sys/devices and then lists the probe dependency chain (suppliers and\nparents) of these devices. It does a breadth first search of the dependency\nchain, so the last entry in the output is close to the root of the\ndependency chain.\n\nBy default it lists the full path to the devices under /sys/devices.\n\nIt also takes an optional modifier flag as the first parameter to change\nwhat information is listed in the output. If the requested information is\nnot available, the device name is printed.\n\n  -c\tlists the compatible string of the dependencies\n  -d\tlists the driver name of the dependencies that have probed\n  -m\tlists the module name of the dependencies that have a module\n  -f\tlist the firmware node path of the dependencies\n  -g\tlist the dependencies as edges and nodes for graphviz\n  -t\tlist the dependencies as edges for tsort\n\nThe filter options provide a way to filter out some dependencies:\n  --allow-no-driver\tBy default dependencies that don't have a driver\n\t\t\tattached are ignored. This is to avoid following\n\t\t\tdevice links to \"class\" devices that are created\n\t\t\twhen the consumer probes (as in, not a probe\n\t\t\tdependency). If you want to follow these links\n\t\t\tanyway, use this flag.\n\n  --exclude-devlinks\tDon't follow device links when tracking probe\n\t\t\tdependencies.\n\n  --exclude-parents\tDon't follow parent devices when tracking probe\n\t\t\tdependencies.\n\nEOF\n}\n\nfunction dev_to_detail() {\n\tlocal i=0\n\twhile [ $i -lt ${#OUT_LIST[@]} ]\n\tdo\n\t\tlocal C=${OUT_LIST[i]}\n\t\tlocal S=${OUT_LIST[i+1]}\n\t\tlocal D=\"'$(detail_chosen $C $S)'\"\n\t\tif [ ! -z \"$D\" ]\n\t\tthen\n\t\t\t# This weirdness is needed to work with toybox when\n\t\t\t# using the -t option.\n\t\t\tprintf '%05u\\t%s\\n' ${i} \"$D\" | tr -d \\'\n\t\tfi\n\t\ti=$((i+2))\n\tdone\n}\n\nfunction already_seen() {\n\tlocal i=0\n\twhile [ $i -lt ${#OUT_LIST[@]} ]\n\tdo\n\t\tif [ \"$1\" = \"${OUT_LIST[$i]}\" ]\n\t\tthen\n\t\t\t# if-statement treats 0 (no-error) as true\n\t\t\treturn 0\n\t\tfi\n\t\ti=$(($i+2))\n\tdone\n\n\t# if-statement treats 1 (error) as false\n\treturn 1\n}\n\n# Return 0 (no-error/true) if parent was added\nfunction add_parent() {\n\n\tif [ ${ALLOW_PARENTS} -eq 0 ]\n\tthen\n\t\treturn 1\n\tfi\n\n\tlocal CON=$1\n\t# $CON could be a symlink path. So, we need to find the real path and\n\t# then go up one level to find the real parent.\n\tlocal PARENT=$(realpath $CON/..)\n\n\twhile [ ! -e ${PARENT}/driver ]\n\tdo\n\t\tif [ \"$PARENT\" = \"/sys/devices\" ]\n\t\tthen\n\t\t\treturn 1\n\t\tfi\n\t\tPARENT=$(realpath $PARENT/..)\n\tdone\n\n\tCONSUMERS+=($PARENT)\n\tOUT_LIST+=(${CON} ${PARENT})\n\treturn 0\n}\n\n# Return 0 (no-error/true) if one or more suppliers were added\nfunction add_suppliers() {\n\tlocal CON=$1\n\tlocal RET=1\n\n\tif [ ${ALLOW_DEVLINKS} -eq 0 ]\n\tthen\n\t\treturn 1\n\tfi\n\n\tSUPPLIER_LINKS=$(ls -1d $CON/supplier:* 2>/dev/null)\n\tfor SL in $SUPPLIER_LINKS;\n\tdo\n\t\tSYNC_STATE=$(cat $SL/sync_state_only)\n\n\t\t# sync_state_only links are proxy dependencies.\n\t\t# They can also have cycles. So, don't follow them.\n\t\tif [ \"$SYNC_STATE\" != '0' ]\n\t\tthen\n\t\t\tcontinue\n\t\tfi\n\n\t\tSUPPLIER=$(realpath $SL/supplier)\n\n\t\tif [ ! -e $SUPPLIER/driver -a ${ALLOW_NO_DRIVER} -eq 0 ]\n\t\tthen\n\t\t\tcontinue\n\t\tfi\n\n\t\tCONSUMERS+=($SUPPLIER)\n\t\tOUT_LIST+=(${CON} ${SUPPLIER})\n\t\tRET=0\n\tdone\n\n\treturn $RET\n}\n\nfunction detail_compat() {\n\tf=$1/of_node/compatible\n\tif [ -e $f ]\n\tthen\n\t\techo -n $(cat $f)\n\telse\n\t\techo -n $1\n\tfi\n}\n\nfunction detail_module() {\n\tf=$1/driver/module\n\tif [ -e $f ]\n\tthen\n\t\techo -n $(basename $(realpath $f))\n\telse\n\t\techo -n $1\n\tfi\n}\n\nfunction detail_driver() {\n\tf=$1/driver\n\tif [ -e $f ]\n\tthen\n\t\techo -n $(basename $(realpath $f))\n\telse\n\t\techo -n $1\n\tfi\n}\n\nfunction detail_fwnode() {\n\tf=$1/firmware_node\n\tif [ ! -e $f ]\n\tthen\n\t\tf=$1/of_node\n\tfi\n\n\tif [ -e $f ]\n\tthen\n\t\techo -n $(realpath $f)\n\telse\n\t\techo -n $1\n\tfi\n}\n\nfunction detail_graphviz() {\n\tif [ \"$2\" != \"ROOT\" ]\n\tthen\n\t\techo -n \"\\\"$(basename $2)\\\"->\\\"$(basename $1)\\\"\"\n\telse\n\t\techo -n \"\\\"$(basename $1)\\\"\"\n\tfi\n}\n\nfunction detail_tsort() {\n\techo -n \"\\\"$2\\\" \\\"$1\\\"\"\n}\n\nfunction detail_device() { echo -n $1; }\n\nalias detail=detail_device\nALLOW_NO_DRIVER=0\nALLOW_DEVLINKS=1\nALLOW_PARENTS=1\n\nwhile [ $# -gt 0 ]\ndo\n\tARG=$1\n\tcase $ARG in\n\t\t--help)\n\t\t\thelp\n\t\t\texit 0\n\t\t\t;;\n\t\t-c)\n\t\t\talias detail=detail_compat\n\t\t\t;;\n\t\t-m)\n\t\t\talias detail=detail_module\n\t\t\t;;\n\t\t-d)\n\t\t\talias detail=detail_driver\n\t\t\t;;\n\t\t-f)\n\t\t\talias detail=detail_fwnode\n\t\t\t;;\n\t\t-g)\n\t\t\talias detail=detail_graphviz\n\t\t\t;;\n\t\t-t)\n\t\t\talias detail=detail_tsort\n\t\t\t;;\n\t\t--allow-no-driver)\n\t\t\tALLOW_NO_DRIVER=1\n\t\t\t;;\n\t\t--exclude-devlinks)\n\t\t\tALLOW_DEVLINKS=0\n\t\t\t;;\n\t\t--exclude-parents)\n\t\t\tALLOW_PARENTS=0\n\t\t\t;;\n\t\t*)\n\t\t\t# Stop at the first argument that's not an option.\n\t\t\tbreak\n\t\t\t;;\n\tesac\n\tshift\ndone\n\nfunction detail_chosen() {\n\tdetail $1 $2\n}\n\nif [ $# -eq 0 ]\nthen\n\thelp\n\texit 1\nfi\n\nCONSUMERS=($@)\nOUT_LIST=()\n\n# Do a breadth first, non-recursive tracking of suppliers. The parent is also\n# considered a \"supplier\" as a device can't probe without its parent.\ni=0\nwhile [ $i -lt ${#CONSUMERS[@]} ]\ndo\n\tCONSUMER=$(realpath ${CONSUMERS[$i]})\n\ti=$(($i+1))\n\n\tif already_seen ${CONSUMER}\n\tthen\n\t\tcontinue\n\tfi\n\n\t# If this is not a device with a driver, we don't care about its\n\t# suppliers.\n\tif [ ! -e ${CONSUMER}/driver -a ${ALLOW_NO_DRIVER} -eq 0 ]\n\tthen\n\t\tcontinue\n\tfi\n\n\tROOT=1\n\n\t# Add suppliers to CONSUMERS list and output the consumer details.\n\t#\n\t# We don't need to worry about a cycle in the dependency chain causing\n\t# infinite loops. That's because the kernel doesn't allow cycles in\n\t# device links unless it's a sync_state_only device link. And we ignore\n\t# sync_state_only device links inside add_suppliers.\n\tif add_suppliers ${CONSUMER}\n\tthen\n\t\tROOT=0\n\tfi\n\n\tif add_parent ${CONSUMER}\n\tthen\n\t\tROOT=0\n\tfi\n\n\tif [ $ROOT -eq 1 ]\n\tthen\n\t\tOUT_LIST+=(${CONSUMER} \"ROOT\")\n\tfi\ndone\n\n# Can NOT combine sort and uniq using sort -suk2 because stable sort in toybox\n# isn't really stable.\ndev_to_detail | sort -k2 -k1 | uniq -f 1 | sort | cut -f2-\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}