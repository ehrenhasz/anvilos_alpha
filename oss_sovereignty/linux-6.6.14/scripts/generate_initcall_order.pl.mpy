{
  "module_name": "generate_initcall_order.pl",
  "hash_id": "f2518d006cb495bb34305a556fd68bafe97e7b9785958cc52cd331fc4d649ce9",
  "original_prompt": "Ingested from linux-6.6.14/scripts/generate_initcall_order.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# Generates a linker script that specifies the correct initcall order.\n#\n# Copyright (C) 2019 Google LLC\n\nuse strict;\nuse warnings;\nuse IO::Handle;\nuse IO::Select;\nuse POSIX \":sys_wait_h\";\n\nmy $nm = $ENV{'NM'} || die \"$0: ERROR: NM not set?\";\nmy $objtree = $ENV{'objtree'} || '.';\n\n## currently active child processes\nmy $jobs = {};\t\t# child process pid -> file handle\n## results from child processes\nmy $results = {};\t# object index -> [ { level, secname }, ... ]\n\n## reads _NPROCESSORS_ONLN to determine the maximum number of processes to\n## start\nsub get_online_processors {\n\topen(my $fh, \"getconf _NPROCESSORS_ONLN 2>/dev/null |\")\n\t\tor die \"$0: ERROR: failed to execute getconf: $!\";\n\tmy $procs = <$fh>;\n\tclose($fh);\n\n\tif (!($procs =~ /^\\d+$/)) {\n\t\treturn 1;\n\t}\n\n\treturn int($procs);\n}\n\n## writes results to the parent process\n## format: <file index> <initcall level> <base initcall section name>\nsub write_results {\n\tmy ($index, $initcalls) = @_;\n\n\t# sort by the counter value to ensure the order of initcalls within\n\t# each object file is correct\n\tforeach my $counter (sort { $a <=> $b } keys(%{$initcalls})) {\n\t\tmy $level = $initcalls->{$counter}->{'level'};\n\n\t\t# section name for the initcall function\n\t\tmy $secname = $initcalls->{$counter}->{'module'} . '__' .\n\t\t\t      $counter . '_' .\n\t\t\t      $initcalls->{$counter}->{'line'} . '_' .\n\t\t\t      $initcalls->{$counter}->{'function'};\n\n\t\tprint \"$index $level $secname\\n\";\n\t}\n}\n\n## reads a result line from a child process and adds it to the $results array\nsub read_results{\n\tmy ($fh) = @_;\n\n\t# each child prints out a full line w/ autoflush and exits after the\n\t# last line, so even if buffered I/O blocks here, it shouldn't block\n\t# very long\n\tmy $data = <$fh>;\n\n\tif (!defined($data)) {\n\t\treturn 0;\n\t}\n\n\tchomp($data);\n\n\tmy ($index, $level, $secname) = $data =~\n\t\t/^(\\d+)\\ ([^\\ ]+)\\ (.*)$/;\n\n\tif (!defined($index) ||\n\t\t!defined($level) ||\n\t\t!defined($secname)) {\n\t\tdie \"$0: ERROR: child process returned invalid data: $data\\n\";\n\t}\n\n\t$index = int($index);\n\n\tif (!exists($results->{$index})) {\n\t\t$results->{$index} = [];\n\t}\n\n\tpush (@{$results->{$index}}, {\n\t\t'level'   => $level,\n\t\t'secname' => $secname\n\t});\n\n\treturn 1;\n}\n\n## finds initcalls from an object file or all object files in an archive, and\n## writes results back to the parent process\nsub find_initcalls {\n\tmy ($index, $file) = @_;\n\n\tdie \"$0: ERROR: file $file doesn't exist?\" if (! -f $file);\n\n\topen(my $fh, \"\\\"$nm\\\" --defined-only \\\"$file\\\" 2>/dev/null |\")\n\t\tor die \"$0: ERROR: failed to execute \\\"$nm\\\": $!\";\n\n\tmy $initcalls = {};\n\n\twhile (<$fh>) {\n\t\tchomp;\n\n\t\t# check for the start of a new object file (if processing an\n\t\t# archive)\n\t\tmy ($path)= $_ =~ /^(.+)\\:$/;\n\n\t\tif (defined($path)) {\n\t\t\twrite_results($index, $initcalls);\n\t\t\t$initcalls = {};\n\t\t\tnext;\n\t\t}\n\n\t\t# look for an initcall\n\t\tmy ($module, $counter, $line, $symbol) = $_ =~\n\t\t\t/[a-z]\\s+__initcall__(\\S*)__(\\d+)_(\\d+)_(.*)$/;\n\n\t\tif (!defined($module)) {\n\t\t\t$module = ''\n\t\t}\n\n\t\tif (!defined($counter) ||\n\t\t\t!defined($line) ||\n\t\t\t!defined($symbol)) {\n\t\t\tnext;\n\t\t}\n\n\t\t# parse initcall level\n\t\tmy ($function, $level) = $symbol =~\n\t\t\t/^(.*)((early|rootfs|con|[0-9])s?)$/;\n\n\t\tdie \"$0: ERROR: invalid initcall name $symbol in $file($path)\"\n\t\t\tif (!defined($function) || !defined($level));\n\n\t\t$initcalls->{$counter} = {\n\t\t\t'module'   => $module,\n\t\t\t'line'     => $line,\n\t\t\t'function' => $function,\n\t\t\t'level'    => $level,\n\t\t};\n\t}\n\n\tclose($fh);\n\twrite_results($index, $initcalls);\n}\n\n## waits for any child process to complete, reads the results, and adds them to\n## the $results array for later processing\nsub wait_for_results {\n\tmy ($select) = @_;\n\n\tmy $pid = 0;\n\tdo {\n\t\t# unblock children that may have a full write buffer\n\t\tforeach my $fh ($select->can_read(0)) {\n\t\t\tread_results($fh);\n\t\t}\n\n\t\t# check for children that have exited, read the remaining data\n\t\t# from them, and clean up\n\t\t$pid = waitpid(-1, WNOHANG);\n\t\tif ($pid > 0) {\n\t\t\tif (!exists($jobs->{$pid})) {\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tmy $fh = $jobs->{$pid};\n\t\t\t$select->remove($fh);\n\n\t\t\twhile (read_results($fh)) {\n\t\t\t\t# until eof\n\t\t\t}\n\n\t\t\tclose($fh);\n\t\t\tdelete($jobs->{$pid});\n\t\t}\n\t} while ($pid > 0);\n}\n\n## forks a child to process each file passed in the command line and collects\n## the results\nsub process_files {\n\tmy $index = 0;\n\tmy $njobs = $ENV{'PARALLELISM'} || get_online_processors();\n\tmy $select = IO::Select->new();\n\n\twhile (my $file = shift(@ARGV)) {\n\t\t# fork a child process and read it's stdout\n\t\tmy $pid = open(my $fh, '-|');\n\n\t\tif (!defined($pid)) {\n\t\t\tdie \"$0: ERROR: failed to fork: $!\";\n\t\t} elsif ($pid) {\n\t\t\t# save the child process pid and the file handle\n\t\t\t$select->add($fh);\n\t\t\t$jobs->{$pid} = $fh;\n\t\t} else {\n\t\t\t# in the child process\n\t\t\tSTDOUT->autoflush(1);\n\t\t\tfind_initcalls($index, \"$objtree/$file\");\n\t\t\texit;\n\t\t}\n\n\t\t$index++;\n\n\t\t# limit the number of children to $njobs\n\t\tif (scalar(keys(%{$jobs})) >= $njobs) {\n\t\t\twait_for_results($select);\n\t\t}\n\t}\n\n\t# wait for the remaining children to complete\n\twhile (scalar(keys(%{$jobs})) > 0) {\n\t\twait_for_results($select);\n\t}\n}\n\nsub generate_initcall_lds() {\n\tprocess_files();\n\n\tmy $sections = {};\t# level -> [ secname, ...]\n\n\t# sort results to retain link order and split to sections per\n\t# initcall level\n\tforeach my $index (sort { $a <=> $b } keys(%{$results})) {\n\t\tforeach my $result (@{$results->{$index}}) {\n\t\t\tmy $level = $result->{'level'};\n\n\t\t\tif (!exists($sections->{$level})) {\n\t\t\t\t$sections->{$level} = [];\n\t\t\t}\n\n\t\t\tpush(@{$sections->{$level}}, $result->{'secname'});\n\t\t}\n\t}\n\n\tdie \"$0: ERROR: no initcalls?\" if (!keys(%{$sections}));\n\n\t# print out a linker script that defines the order of initcalls for\n\t# each level\n\tprint \"SECTIONS {\\n\";\n\n\tforeach my $level (sort(keys(%{$sections}))) {\n\t\tmy $section;\n\n\t\tif ($level eq 'con') {\n\t\t\t$section = '.con_initcall.init';\n\t\t} else {\n\t\t\t$section = \".initcall${level}.init\";\n\t\t}\n\n\t\tprint \"\\t${section} : {\\n\";\n\n\t\tforeach my $secname (@{$sections->{$level}}) {\n\t\t\tprint \"\\t\\t*(${section}..${secname}) ;\\n\";\n\t\t}\n\n\t\tprint \"\\t}\\n\";\n\t}\n\n\tprint \"}\\n\";\n}\n\ngenerate_initcall_lds();\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}