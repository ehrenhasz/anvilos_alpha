{
  "module_name": "expr.h",
  "hash_id": "14a6c25ed4570971672814feb9aa025651045d41c7219a965e02ea33405382ab",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/expr.h",
  "human_readable_source": " \n \n\n#ifndef EXPR_H\n#define EXPR_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <assert.h>\n#include <stdio.h>\n#include \"list.h\"\n#ifndef __cplusplus\n#include <stdbool.h>\n#endif\n\nstruct file {\n\tstruct file *next;\n\tstruct file *parent;\n\tconst char *name;\n\tint lineno;\n};\n\ntypedef enum tristate {\n\tno, mod, yes\n} tristate;\n\nenum expr_type {\n\tE_NONE, E_OR, E_AND, E_NOT,\n\tE_EQUAL, E_UNEQUAL, E_LTH, E_LEQ, E_GTH, E_GEQ,\n\tE_LIST, E_SYMBOL, E_RANGE\n};\n\nunion expr_data {\n\tstruct expr *expr;\n\tstruct symbol *sym;\n};\n\nstruct expr {\n\tenum expr_type type;\n\tunion expr_data left, right;\n};\n\n#define EXPR_OR(dep1, dep2)\t(((dep1)>(dep2))?(dep1):(dep2))\n#define EXPR_AND(dep1, dep2)\t(((dep1)<(dep2))?(dep1):(dep2))\n#define EXPR_NOT(dep)\t\t(2-(dep))\n\n#define expr_list_for_each_sym(l, e, s) \\\n\tfor (e = (l); e && (s = e->right.sym); e = e->left.expr)\n\nstruct expr_value {\n\tstruct expr *expr;\n\ttristate tri;\n};\n\nstruct symbol_value {\n\tvoid *val;\n\ttristate tri;\n};\n\nenum symbol_type {\n\tS_UNKNOWN, S_BOOLEAN, S_TRISTATE, S_INT, S_HEX, S_STRING\n};\n\n \nenum {\n\tS_DEF_USER,\t\t \n\tS_DEF_AUTO,\t\t \n\tS_DEF_DEF3,\t\t \n\tS_DEF_DEF4,\t\t \n\tS_DEF_COUNT\n};\n\n \nstruct symbol {\n\t \n\tstruct symbol *next;\n\n\t \n\tchar *name;\n\n\t \n\tenum symbol_type type;\n\n\t \n\tstruct symbol_value curr;\n\n\t \n\tstruct symbol_value def[S_DEF_COUNT];\n\n\t \n\ttristate visible;\n\n\t \n\tint flags;\n\n\t \n\tstruct property *prop;\n\n\t \n\tstruct expr_value dir_dep;\n\n\t \n\tstruct expr_value rev_dep;\n\n\t \n\tstruct expr_value implied;\n};\n\n#define for_all_symbols(i, sym) for (i = 0; i < SYMBOL_HASHSIZE; i++) for (sym = symbol_hash[i]; sym; sym = sym->next)\n\n#define SYMBOL_CONST      0x0001   \n#define SYMBOL_CHECK      0x0008   \n#define SYMBOL_CHOICE     0x0010   \n#define SYMBOL_CHOICEVAL  0x0020   \n#define SYMBOL_VALID      0x0080   \n#define SYMBOL_OPTIONAL   0x0100   \n#define SYMBOL_WRITE      0x0200   \n#define SYMBOL_CHANGED    0x0400   \n#define SYMBOL_WRITTEN    0x0800   \n#define SYMBOL_NO_WRITE   0x1000   \n#define SYMBOL_CHECKED    0x2000   \n#define SYMBOL_WARNED     0x8000   \n\n \n#define SYMBOL_DEF        0x10000   \n#define SYMBOL_DEF_USER   0x10000   \n#define SYMBOL_DEF_AUTO   0x20000   \n#define SYMBOL_DEF3       0x40000   \n#define SYMBOL_DEF4       0x80000   \n\n \n#define SYMBOL_NEED_SET_CHOICE_VALUES  0x100000\n\n#define SYMBOL_MAXLENGTH\t256\n#define SYMBOL_HASHSIZE\t\t9973\n\n \nenum prop_type {\n\tP_UNKNOWN,\n\tP_PROMPT,    \n\tP_COMMENT,   \n\tP_MENU,      \n\tP_DEFAULT,   \n\tP_CHOICE,    \n\tP_SELECT,    \n\tP_IMPLY,     \n\tP_RANGE,     \n\tP_SYMBOL,    \n};\n\nstruct property {\n\tstruct property *next;      \n\tenum prop_type type;        \n\tconst char *text;           \n\tstruct expr_value visible;\n\tstruct expr *expr;          \n\tstruct menu *menu;          \n\tstruct file *file;          \n\tint lineno;                 \n};\n\n#define for_all_properties(sym, st, tok) \\\n\tfor (st = sym->prop; st; st = st->next) \\\n\t\tif (st->type == (tok))\n#define for_all_defaults(sym, st) for_all_properties(sym, st, P_DEFAULT)\n#define for_all_choices(sym, st) for_all_properties(sym, st, P_CHOICE)\n#define for_all_prompts(sym, st) \\\n\tfor (st = sym->prop; st; st = st->next) \\\n\t\tif (st->text)\n\n \nstruct menu {\n\t \n\tstruct menu *next;\n\n\t \n\tstruct menu *parent;\n\n\t \n\tstruct menu *list;\n\n\t \n\tstruct symbol *sym;\n\n\t \n\tstruct property *prompt;\n\n\t \n\tstruct expr *visibility;\n\n\t \n\tstruct expr *dep;\n\n\t \n\tunsigned int flags;\n\n\t \n\tchar *help;\n\n\t \n\tstruct file *file;\n\tint lineno;\n\n\t \n\tvoid *data;\n};\n\n \n#define MENU_CHANGED\t\t0x0001\n\n#define MENU_ROOT\t\t0x0002\n\nstruct jump_key {\n\tstruct list_head entries;\n\tsize_t offset;\n\tstruct menu *target;\n};\n\nextern struct file *file_list;\nextern struct file *current_file;\nstruct file *lookup_file(const char *name);\n\nextern struct symbol symbol_yes, symbol_no, symbol_mod;\nextern struct symbol *modules_sym;\nextern int cdebug;\nstruct expr *expr_alloc_symbol(struct symbol *sym);\nstruct expr *expr_alloc_one(enum expr_type type, struct expr *ce);\nstruct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2);\nstruct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2);\nstruct expr *expr_alloc_and(struct expr *e1, struct expr *e2);\nstruct expr *expr_alloc_or(struct expr *e1, struct expr *e2);\nstruct expr *expr_copy(const struct expr *org);\nvoid expr_free(struct expr *e);\nvoid expr_eliminate_eq(struct expr **ep1, struct expr **ep2);\nint expr_eq(struct expr *e1, struct expr *e2);\ntristate expr_calc_value(struct expr *e);\nstruct expr *expr_trans_bool(struct expr *e);\nstruct expr *expr_eliminate_dups(struct expr *e);\nstruct expr *expr_transform(struct expr *e);\nint expr_contains_symbol(struct expr *dep, struct symbol *sym);\nbool expr_depends_symbol(struct expr *dep, struct symbol *sym);\nstruct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symbol *sym);\n\nvoid expr_fprint(struct expr *e, FILE *out);\nstruct gstr;  \nvoid expr_gstr_print(struct expr *e, struct gstr *gs);\nvoid expr_gstr_print_revdep(struct expr *e, struct gstr *gs,\n\t\t\t    tristate pr_type, const char *title);\n\nstatic inline int expr_is_yes(struct expr *e)\n{\n\treturn !e || (e->type == E_SYMBOL && e->left.sym == &symbol_yes);\n}\n\nstatic inline int expr_is_no(struct expr *e)\n{\n\treturn e && (e->type == E_SYMBOL && e->left.sym == &symbol_no);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}