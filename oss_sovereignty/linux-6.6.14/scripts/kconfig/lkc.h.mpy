{
  "module_name": "lkc.h",
  "hash_id": "906e9acdf38c2e736ef22ccbaef699897eef6e3140d4cb87d7a18e2ef3e09f3b",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/lkc.h",
  "human_readable_source": " \n \n\n#ifndef LKC_H\n#define LKC_H\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"expr.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"lkc_proto.h\"\n\n#define SRCTREE \"srctree\"\n\n#ifndef CONFIG_\n#define CONFIG_ \"CONFIG_\"\n#endif\nstatic inline const char *CONFIG_prefix(void)\n{\n\treturn getenv( \"CONFIG_\" ) ?: CONFIG_;\n}\n#undef CONFIG_\n#define CONFIG_ CONFIG_prefix()\n\nextern int yylineno;\nvoid zconfdump(FILE *out);\nvoid zconf_starthelp(void);\nFILE *zconf_fopen(const char *name);\nvoid zconf_initscan(const char *name);\nvoid zconf_nextfile(const char *name);\nint zconf_lineno(void);\nconst char *zconf_curname(void);\n\n \nconst char *conf_get_configname(void);\nvoid set_all_choice_values(struct symbol *csym);\n\n \nstatic inline void xfwrite(const void *str, size_t len, size_t count, FILE *out)\n{\n\tassert(len != 0);\n\n\tif (fwrite(str, len, count, out) != count)\n\t\tfprintf(stderr, \"Error in writing or end of file.\\n\");\n}\n\n \nstruct file *file_lookup(const char *name);\nvoid *xmalloc(size_t size);\nvoid *xcalloc(size_t nmemb, size_t size);\nvoid *xrealloc(void *p, size_t size);\nchar *xstrdup(const char *s);\nchar *xstrndup(const char *s, size_t n);\n\n \nint yylex(void);\n\nstruct gstr {\n\tsize_t len;\n\tchar  *s;\n\t \n\tint max_width;\n};\nstruct gstr str_new(void);\nvoid str_free(struct gstr *gs);\nvoid str_append(struct gstr *gs, const char *s);\nvoid str_printf(struct gstr *gs, const char *fmt, ...);\nchar *str_get(struct gstr *gs);\n\n \nvoid _menu_init(void);\nvoid menu_warn(struct menu *menu, const char *fmt, ...);\nstruct menu *menu_add_menu(void);\nvoid menu_end_menu(void);\nvoid menu_add_entry(struct symbol *sym);\nvoid menu_add_dep(struct expr *dep);\nvoid menu_add_visibility(struct expr *dep);\nstruct property *menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep);\nvoid menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep);\nvoid menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep);\nvoid menu_finalize(struct menu *parent);\nvoid menu_set_type(int type);\n\nextern struct menu rootmenu;\n\nbool menu_is_empty(struct menu *menu);\nbool menu_is_visible(struct menu *menu);\nbool menu_has_prompt(struct menu *menu);\nconst char *menu_get_prompt(struct menu *menu);\nstruct menu *menu_get_parent_menu(struct menu *menu);\nbool menu_has_help(struct menu *menu);\nconst char *menu_get_help(struct menu *menu);\nint get_jump_key_char(void);\nstruct gstr get_relations_str(struct symbol **sym_arr, struct list_head *head);\nvoid menu_get_ext_help(struct menu *menu, struct gstr *help);\n\n \nvoid sym_clear_all_valid(void);\nstruct symbol *sym_choice_default(struct symbol *sym);\nstruct property *sym_get_range_prop(struct symbol *sym);\nconst char *sym_get_string_default(struct symbol *sym);\nstruct symbol *sym_check_deps(struct symbol *sym);\nstruct symbol *prop_get_symbol(struct property *prop);\n\nstatic inline tristate sym_get_tristate_value(struct symbol *sym)\n{\n\treturn sym->curr.tri;\n}\n\n\nstatic inline struct symbol *sym_get_choice_value(struct symbol *sym)\n{\n\treturn (struct symbol *)sym->curr.val;\n}\n\nstatic inline bool sym_is_choice(struct symbol *sym)\n{\n\treturn sym->flags & SYMBOL_CHOICE ? true : false;\n}\n\nstatic inline bool sym_is_choice_value(struct symbol *sym)\n{\n\treturn sym->flags & SYMBOL_CHOICEVAL ? true : false;\n}\n\nstatic inline bool sym_is_optional(struct symbol *sym)\n{\n\treturn sym->flags & SYMBOL_OPTIONAL ? true : false;\n}\n\nstatic inline bool sym_has_value(struct symbol *sym)\n{\n\treturn sym->flags & SYMBOL_DEF_USER ? true : false;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}