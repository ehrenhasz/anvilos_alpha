{
  "module_name": "parser.y",
  "hash_id": "eaac0845e3d3d62a64fe73e8eb4adf70326436bae67e90d2f4045df90cc8ae89",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/parser.y",
  "human_readable_source": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>\n */\n%{\n\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#include \"lkc.h\"\n#include \"internal.h\"\n\n#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)\n\n#define PRINTD\t\t0x0001\n#define DEBUG_PARSE\t0x0002\n\nint cdebug = PRINTD;\n\nstatic void yyerror(const char *err);\nstatic void zconfprint(const char *err, ...);\nstatic void zconf_error(const char *err, ...);\nstatic bool zconf_endtoken(const char *tokenname,\n\t\t\t   const char *expected_tokenname);\n\nstruct symbol *symbol_hash[SYMBOL_HASHSIZE];\n\nstruct menu *current_menu, *current_entry;\n\n%}\n\n%union\n{\n\tchar *string;\n\tstruct symbol *symbol;\n\tstruct expr *expr;\n\tstruct menu *menu;\n\tenum symbol_type type;\n\tenum variable_flavor flavor;\n}\n\n%token <string> T_HELPTEXT\n%token <string> T_WORD\n%token <string> T_WORD_QUOTE\n%token T_BOOL\n%token T_CHOICE\n%token T_CLOSE_PAREN\n%token T_COLON_EQUAL\n%token T_COMMENT\n%token T_CONFIG\n%token T_DEFAULT\n%token T_DEF_BOOL\n%token T_DEF_TRISTATE\n%token T_DEPENDS\n%token T_ENDCHOICE\n%token T_ENDIF\n%token T_ENDMENU\n%token T_HELP\n%token T_HEX\n%token T_IF\n%token T_IMPLY\n%token T_INT\n%token T_MAINMENU\n%token T_MENU\n%token T_MENUCONFIG\n%token T_MODULES\n%token T_ON\n%token T_OPEN_PAREN\n%token T_OPTIONAL\n%token T_PLUS_EQUAL\n%token T_PROMPT\n%token T_RANGE\n%token T_SELECT\n%token T_SOURCE\n%token T_STRING\n%token T_TRISTATE\n%token T_VISIBLE\n%token T_EOL\n%token <string> T_ASSIGN_VAL\n\n%left T_OR\n%left T_AND\n%left T_EQUAL T_UNEQUAL\n%left T_LESS T_LESS_EQUAL T_GREATER T_GREATER_EQUAL\n%nonassoc T_NOT\n\n%type <symbol> nonconst_symbol\n%type <symbol> symbol\n%type <type> type logic_type default\n%type <expr> expr\n%type <expr> if_expr\n%type <string> end\n%type <menu> if_entry menu_entry choice_entry\n%type <string> word_opt assign_val\n%type <flavor> assign_op\n\n%destructor {\n\tfprintf(stderr, \"%s:%d: missing end statement for this entry\\n\",\n\t\t$$->file->name, $$->lineno);\n\tif (current_menu == $$)\n\t\tmenu_end_menu();\n} if_entry menu_entry choice_entry\n\n%%\ninput: mainmenu_stmt stmt_list | stmt_list;\n\n/* mainmenu entry */\n\nmainmenu_stmt: T_MAINMENU T_WORD_QUOTE T_EOL\n{\n\tmenu_add_prompt(P_MENU, $2, NULL);\n};\n\nstmt_list:\n\t  /* empty */\n\t| stmt_list assignment_stmt\n\t| stmt_list choice_stmt\n\t| stmt_list comment_stmt\n\t| stmt_list config_stmt\n\t| stmt_list if_stmt\n\t| stmt_list menu_stmt\n\t| stmt_list menuconfig_stmt\n\t| stmt_list source_stmt\n\t| stmt_list T_WORD error T_EOL\t{ zconf_error(\"unknown statement \\\"%s\\\"\", $2); }\n\t| stmt_list error T_EOL\t\t{ zconf_error(\"invalid statement\"); }\n;\n\nstmt_list_in_choice:\n\t  /* empty */\n\t| stmt_list_in_choice comment_stmt\n\t| stmt_list_in_choice config_stmt\n\t| stmt_list_in_choice if_stmt_in_choice\n\t| stmt_list_in_choice error T_EOL\t{ zconf_error(\"invalid statement\"); }\n;\n\n/* config/menuconfig entry */\n\nconfig_entry_start: T_CONFIG nonconst_symbol T_EOL\n{\n\t$2->flags |= SYMBOL_OPTIONAL;\n\tmenu_add_entry($2);\n\tprintd(DEBUG_PARSE, \"%s:%d:config %s\\n\", zconf_curname(), zconf_lineno(), $2->name);\n};\n\nconfig_stmt: config_entry_start config_option_list\n{\n\tprintd(DEBUG_PARSE, \"%s:%d:endconfig\\n\", zconf_curname(), zconf_lineno());\n};\n\nmenuconfig_entry_start: T_MENUCONFIG nonconst_symbol T_EOL\n{\n\t$2->flags |= SYMBOL_OPTIONAL;\n\tmenu_add_entry($2);\n\tprintd(DEBUG_PARSE, \"%s:%d:menuconfig %s\\n\", zconf_curname(), zconf_lineno(), $2->name);\n};\n\nmenuconfig_stmt: menuconfig_entry_start config_option_list\n{\n\tif (current_entry->prompt)\n\t\tcurrent_entry->prompt->type = P_MENU;\n\telse\n\t\tzconfprint(\"warning: menuconfig statement without prompt\");\n\tprintd(DEBUG_PARSE, \"%s:%d:endconfig\\n\", zconf_curname(), zconf_lineno());\n};\n\nconfig_option_list:\n\t  /* empty */\n\t| config_option_list config_option\n\t| config_option_list depends\n\t| config_option_list help\n;\n\nconfig_option: type prompt_stmt_opt T_EOL\n{\n\tmenu_set_type($1);\n\tprintd(DEBUG_PARSE, \"%s:%d:type(%u)\\n\",\n\t\tzconf_curname(), zconf_lineno(),\n\t\t$1);\n};\n\nconfig_option: T_PROMPT T_WORD_QUOTE if_expr T_EOL\n{\n\tmenu_add_prompt(P_PROMPT, $2, $3);\n\tprintd(DEBUG_PARSE, \"%s:%d:prompt\\n\", zconf_curname(), zconf_lineno());\n};\n\nconfig_option: default expr if_expr T_EOL\n{\n\tmenu_add_expr(P_DEFAULT, $2, $3);\n\tif ($1 != S_UNKNOWN)\n\t\tmenu_set_type($1);\n\tprintd(DEBUG_PARSE, \"%s:%d:default(%u)\\n\",\n\t\tzconf_curname(), zconf_lineno(),\n\t\t$1);\n};\n\nconfig_option: T_SELECT nonconst_symbol if_expr T_EOL\n{\n\tmenu_add_symbol(P_SELECT, $2, $3);\n\tprintd(DEBUG_PARSE, \"%s:%d:select\\n\", zconf_curname(), zconf_lineno());\n};\n\nconfig_option: T_IMPLY nonconst_symbol if_expr T_EOL\n{\n\tmenu_add_symbol(P_IMPLY, $2, $3);\n\tprintd(DEBUG_PARSE, \"%s:%d:imply\\n\", zconf_curname(), zconf_lineno());\n};\n\nconfig_option: T_RANGE symbol symbol if_expr T_EOL\n{\n\tmenu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,$2, $3), $4);\n\tprintd(DEBUG_PARSE, \"%s:%d:range\\n\", zconf_curname(), zconf_lineno());\n};\n\nconfig_option: T_MODULES T_EOL\n{\n\tif (modules_sym)\n\t\tzconf_error(\"symbol '%s' redefines option 'modules' already defined by symbol '%s'\",\n\t\t\t    current_entry->sym->name, modules_sym->name);\n\tmodules_sym = current_entry->sym;\n};\n\n/* choice entry */\n\nchoice: T_CHOICE word_opt T_EOL\n{\n\tstruct symbol *sym = sym_lookup($2, SYMBOL_CHOICE);\n\tsym->flags |= SYMBOL_NO_WRITE;\n\tmenu_add_entry(sym);\n\tmenu_add_expr(P_CHOICE, NULL, NULL);\n\tfree($2);\n\tprintd(DEBUG_PARSE, \"%s:%d:choice\\n\", zconf_curname(), zconf_lineno());\n};\n\nchoice_entry: choice choice_option_list\n{\n\t$$ = menu_add_menu();\n};\n\nchoice_end: end\n{\n\tif (zconf_endtoken($1, \"choice\")) {\n\t\tmenu_end_menu();\n\t\tprintd(DEBUG_PARSE, \"%s:%d:endchoice\\n\", zconf_curname(), zconf_lineno());\n\t}\n};\n\nchoice_stmt: choice_entry stmt_list_in_choice choice_end\n;\n\nchoice_option_list:\n\t  /* empty */\n\t| choice_option_list choice_option\n\t| choice_option_list depends\n\t| choice_option_list help\n;\n\nchoice_option: T_PROMPT T_WORD_QUOTE if_expr T_EOL\n{\n\tmenu_add_prompt(P_PROMPT, $2, $3);\n\tprintd(DEBUG_PARSE, \"%s:%d:prompt\\n\", zconf_curname(), zconf_lineno());\n};\n\nchoice_option: logic_type prompt_stmt_opt T_EOL\n{\n\tmenu_set_type($1);\n\tprintd(DEBUG_PARSE, \"%s:%d:type(%u)\\n\",\n\t       zconf_curname(), zconf_lineno(), $1);\n};\n\nchoice_option: T_OPTIONAL T_EOL\n{\n\tcurrent_entry->sym->flags |= SYMBOL_OPTIONAL;\n\tprintd(DEBUG_PARSE, \"%s:%d:optional\\n\", zconf_curname(), zconf_lineno());\n};\n\nchoice_option: T_DEFAULT nonconst_symbol if_expr T_EOL\n{\n\tmenu_add_symbol(P_DEFAULT, $2, $3);\n\tprintd(DEBUG_PARSE, \"%s:%d:default\\n\",\n\t       zconf_curname(), zconf_lineno());\n};\n\ntype:\n\t  logic_type\n\t| T_INT\t\t\t{ $$ = S_INT; }\n\t| T_HEX\t\t\t{ $$ = S_HEX; }\n\t| T_STRING\t\t{ $$ = S_STRING; }\n\nlogic_type:\n\t  T_BOOL\t\t{ $$ = S_BOOLEAN; }\n\t| T_TRISTATE\t\t{ $$ = S_TRISTATE; }\n\ndefault:\n\t  T_DEFAULT\t\t{ $$ = S_UNKNOWN; }\n\t| T_DEF_BOOL\t\t{ $$ = S_BOOLEAN; }\n\t| T_DEF_TRISTATE\t{ $$ = S_TRISTATE; }\n\n/* if entry */\n\nif_entry: T_IF expr T_EOL\n{\n\tprintd(DEBUG_PARSE, \"%s:%d:if\\n\", zconf_curname(), zconf_lineno());\n\tmenu_add_entry(NULL);\n\tmenu_add_dep($2);\n\t$$ = menu_add_menu();\n};\n\nif_end: end\n{\n\tif (zconf_endtoken($1, \"if\")) {\n\t\tmenu_end_menu();\n\t\tprintd(DEBUG_PARSE, \"%s:%d:endif\\n\", zconf_curname(), zconf_lineno());\n\t}\n};\n\nif_stmt: if_entry stmt_list if_end\n;\n\nif_stmt_in_choice: if_entry stmt_list_in_choice if_end\n;\n\n/* menu entry */\n\nmenu: T_MENU T_WORD_QUOTE T_EOL\n{\n\tmenu_add_entry(NULL);\n\tmenu_add_prompt(P_MENU, $2, NULL);\n\tprintd(DEBUG_PARSE, \"%s:%d:menu\\n\", zconf_curname(), zconf_lineno());\n};\n\nmenu_entry: menu menu_option_list\n{\n\t$$ = menu_add_menu();\n};\n\nmenu_end: end\n{\n\tif (zconf_endtoken($1, \"menu\")) {\n\t\tmenu_end_menu();\n\t\tprintd(DEBUG_PARSE, \"%s:%d:endmenu\\n\", zconf_curname(), zconf_lineno());\n\t}\n};\n\nmenu_stmt: menu_entry stmt_list menu_end\n;\n\nmenu_option_list:\n\t  /* empty */\n\t| menu_option_list visible\n\t| menu_option_list depends\n;\n\nsource_stmt: T_SOURCE T_WORD_QUOTE T_EOL\n{\n\tprintd(DEBUG_PARSE, \"%s:%d:source %s\\n\", zconf_curname(), zconf_lineno(), $2);\n\tzconf_nextfile($2);\n\tfree($2);\n};\n\n/* comment entry */\n\ncomment: T_COMMENT T_WORD_QUOTE T_EOL\n{\n\tmenu_add_entry(NULL);\n\tmenu_add_prompt(P_COMMENT, $2, NULL);\n\tprintd(DEBUG_PARSE, \"%s:%d:comment\\n\", zconf_curname(), zconf_lineno());\n};\n\ncomment_stmt: comment comment_option_list\n;\n\ncomment_option_list:\n\t  /* empty */\n\t| comment_option_list depends\n;\n\n/* help option */\n\nhelp_start: T_HELP T_EOL\n{\n\tprintd(DEBUG_PARSE, \"%s:%d:help\\n\", zconf_curname(), zconf_lineno());\n\tzconf_starthelp();\n};\n\nhelp: help_start T_HELPTEXT\n{\n\tif (current_entry->help) {\n\t\tfree(current_entry->help);\n\t\tzconfprint(\"warning: '%s' defined with more than one help text -- only the last one will be used\",\n\t\t\t   current_entry->sym->name ?: \"<choice>\");\n\t}\n\n\t/* Is the help text empty or all whitespace? */\n\tif ($2[strspn($2, \" \\f\\n\\r\\t\\v\")] == '\\0')\n\t\tzconfprint(\"warning: '%s' defined with blank help text\",\n\t\t\t   current_entry->sym->name ?: \"<choice>\");\n\n\tcurrent_entry->help = $2;\n};\n\n/* depends option */\n\ndepends: T_DEPENDS T_ON expr T_EOL\n{\n\tmenu_add_dep($3);\n\tprintd(DEBUG_PARSE, \"%s:%d:depends on\\n\", zconf_curname(), zconf_lineno());\n};\n\n/* visibility option */\nvisible: T_VISIBLE if_expr T_EOL\n{\n\tmenu_add_visibility($2);\n};\n\n/* prompt statement */\n\nprompt_stmt_opt:\n\t  /* empty */\n\t| T_WORD_QUOTE if_expr\n{\n\tmenu_add_prompt(P_PROMPT, $1, $2);\n};\n\nend:\t  T_ENDMENU T_EOL\t{ $$ = \"menu\"; }\n\t| T_ENDCHOICE T_EOL\t{ $$ = \"choice\"; }\n\t| T_ENDIF T_EOL\t\t{ $$ = \"if\"; }\n;\n\nif_expr:  /* empty */\t\t\t{ $$ = NULL; }\n\t| T_IF expr\t\t\t{ $$ = $2; }\n;\n\nexpr:\t  symbol\t\t\t\t{ $$ = expr_alloc_symbol($1); }\n\t| symbol T_LESS symbol\t\t\t{ $$ = expr_alloc_comp(E_LTH, $1, $3); }\n\t| symbol T_LESS_EQUAL symbol\t\t{ $$ = expr_alloc_comp(E_LEQ, $1, $3); }\n\t| symbol T_GREATER symbol\t\t{ $$ = expr_alloc_comp(E_GTH, $1, $3); }\n\t| symbol T_GREATER_EQUAL symbol\t\t{ $$ = expr_alloc_comp(E_GEQ, $1, $3); }\n\t| symbol T_EQUAL symbol\t\t\t{ $$ = expr_alloc_comp(E_EQUAL, $1, $3); }\n\t| symbol T_UNEQUAL symbol\t\t{ $$ = expr_alloc_comp(E_UNEQUAL, $1, $3); }\n\t| T_OPEN_PAREN expr T_CLOSE_PAREN\t{ $$ = $2; }\n\t| T_NOT expr\t\t\t\t{ $$ = expr_alloc_one(E_NOT, $2); }\n\t| expr T_OR expr\t\t\t{ $$ = expr_alloc_two(E_OR, $1, $3); }\n\t| expr T_AND expr\t\t\t{ $$ = expr_alloc_two(E_AND, $1, $3); }\n;\n\n/* For symbol definitions, selects, etc., where quotes are not accepted */\nnonconst_symbol: T_WORD { $$ = sym_lookup($1, 0); free($1); };\n\nsymbol:\t  nonconst_symbol\n\t| T_WORD_QUOTE\t{ $$ = sym_lookup($1, SYMBOL_CONST); free($1); }\n;\n\nword_opt: /* empty */\t\t\t{ $$ = NULL; }\n\t| T_WORD\n\n/* assignment statement */\n\nassignment_stmt:  T_WORD assign_op assign_val T_EOL\t{ variable_add($1, $3, $2); free($1); free($3); }\n\nassign_op:\n\t  T_EQUAL\t{ $$ = VAR_RECURSIVE; }\n\t| T_COLON_EQUAL\t{ $$ = VAR_SIMPLE; }\n\t| T_PLUS_EQUAL\t{ $$ = VAR_APPEND; }\n;\n\nassign_val:\n\t/* empty */\t\t{ $$ = xstrdup(\"\"); };\n\t| T_ASSIGN_VAL\n;\n\n%%\n\nvoid conf_parse(const char *name)\n{\n\tstruct symbol *sym;\n\tint i;\n\n\tzconf_initscan(name);\n\n\t_menu_init();\n\n\tif (getenv(\"ZCONF_DEBUG\"))\n\t\tyydebug = 1;\n\tyyparse();\n\n\t/* Variables are expanded in the parse phase. We can free them here. */\n\tvariable_all_del();\n\n\tif (yynerrs)\n\t\texit(1);\n\tif (!modules_sym)\n\t\tmodules_sym = sym_find( \"n\" );\n\n\tif (!menu_has_prompt(&rootmenu)) {\n\t\tcurrent_entry = &rootmenu;\n\t\tmenu_add_prompt(P_MENU, \"Main menu\", NULL);\n\t}\n\n\tmenu_finalize(&rootmenu);\n\tfor_all_symbols(i, sym) {\n\t\tif (sym_check_deps(sym))\n\t\t\tyynerrs++;\n\t}\n\tif (yynerrs)\n\t\texit(1);\n\tconf_set_changed(true);\n}\n\nstatic bool zconf_endtoken(const char *tokenname,\n\t\t\t   const char *expected_tokenname)\n{\n\tif (strcmp(tokenname, expected_tokenname)) {\n\t\tzconf_error(\"unexpected '%s' within %s block\",\n\t\t\t    tokenname, expected_tokenname);\n\t\tyynerrs++;\n\t\treturn false;\n\t}\n\tif (current_menu->file != current_file) {\n\t\tzconf_error(\"'%s' in different file than '%s'\",\n\t\t\t    tokenname, expected_tokenname);\n\t\tfprintf(stderr, \"%s:%d: location of the '%s'\\n\",\n\t\t\tcurrent_menu->file->name, current_menu->lineno,\n\t\t\texpected_tokenname);\n\t\tyynerrs++;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void zconfprint(const char *err, ...)\n{\n\tva_list ap;\n\n\tfprintf(stderr, \"%s:%d: \", zconf_curname(), zconf_lineno());\n\tva_start(ap, err);\n\tvfprintf(stderr, err, ap);\n\tva_end(ap);\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic void zconf_error(const char *err, ...)\n{\n\tva_list ap;\n\n\tyynerrs++;\n\tfprintf(stderr, \"%s:%d: \", zconf_curname(), zconf_lineno());\n\tva_start(ap, err);\n\tvfprintf(stderr, err, ap);\n\tva_end(ap);\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic void yyerror(const char *err)\n{\n\tfprintf(stderr, \"%s:%d: %s\\n\", zconf_curname(), zconf_lineno() + 1, err);\n}\n\nstatic void print_quoted_string(FILE *out, const char *str)\n{\n\tconst char *p;\n\tint len;\n\n\tputc('\"', out);\n\twhile ((p = strchr(str, '\"'))) {\n\t\tlen = p - str;\n\t\tif (len)\n\t\t\tfprintf(out, \"%.*s\", len, str);\n\t\tfputs(\"\\\\\\\"\", out);\n\t\tstr = p + 1;\n\t}\n\tfputs(str, out);\n\tputc('\"', out);\n}\n\nstatic void print_symbol(FILE *out, struct menu *menu)\n{\n\tstruct symbol *sym = menu->sym;\n\tstruct property *prop;\n\n\tif (sym_is_choice(sym))\n\t\tfprintf(out, \"\\nchoice\\n\");\n\telse\n\t\tfprintf(out, \"\\nconfig %s\\n\", sym->name);\n\tswitch (sym->type) {\n\tcase S_BOOLEAN:\n\t\tfputs(\"  bool\\n\", out);\n\t\tbreak;\n\tcase S_TRISTATE:\n\t\tfputs(\"  tristate\\n\", out);\n\t\tbreak;\n\tcase S_STRING:\n\t\tfputs(\"  string\\n\", out);\n\t\tbreak;\n\tcase S_INT:\n\t\tfputs(\"  integer\\n\", out);\n\t\tbreak;\n\tcase S_HEX:\n\t\tfputs(\"  hex\\n\", out);\n\t\tbreak;\n\tdefault:\n\t\tfputs(\"  ???\\n\", out);\n\t\tbreak;\n\t}\n\tfor (prop = sym->prop; prop; prop = prop->next) {\n\t\tif (prop->menu != menu)\n\t\t\tcontinue;\n\t\tswitch (prop->type) {\n\t\tcase P_PROMPT:\n\t\t\tfputs(\"  prompt \", out);\n\t\t\tprint_quoted_string(out, prop->text);\n\t\t\tif (!expr_is_yes(prop->visible.expr)) {\n\t\t\t\tfputs(\" if \", out);\n\t\t\t\texpr_fprint(prop->visible.expr, out);\n\t\t\t}\n\t\t\tfputc('\\n', out);\n\t\t\tbreak;\n\t\tcase P_DEFAULT:\n\t\t\tfputs( \"  default \", out);\n\t\t\texpr_fprint(prop->expr, out);\n\t\t\tif (!expr_is_yes(prop->visible.expr)) {\n\t\t\t\tfputs(\" if \", out);\n\t\t\t\texpr_fprint(prop->visible.expr, out);\n\t\t\t}\n\t\t\tfputc('\\n', out);\n\t\t\tbreak;\n\t\tcase P_CHOICE:\n\t\t\tfputs(\"  #choice value\\n\", out);\n\t\t\tbreak;\n\t\tcase P_SELECT:\n\t\t\tfputs( \"  select \", out);\n\t\t\texpr_fprint(prop->expr, out);\n\t\t\tfputc('\\n', out);\n\t\t\tbreak;\n\t\tcase P_IMPLY:\n\t\t\tfputs( \"  imply \", out);\n\t\t\texpr_fprint(prop->expr, out);\n\t\t\tfputc('\\n', out);\n\t\t\tbreak;\n\t\tcase P_RANGE:\n\t\t\tfputs( \"  range \", out);\n\t\t\texpr_fprint(prop->expr, out);\n\t\t\tfputc('\\n', out);\n\t\t\tbreak;\n\t\tcase P_MENU:\n\t\t\tfputs( \"  menu \", out);\n\t\t\tprint_quoted_string(out, prop->text);\n\t\t\tfputc('\\n', out);\n\t\t\tbreak;\n\t\tcase P_SYMBOL:\n\t\t\tfputs( \"  symbol \", out);\n\t\t\tfprintf(out, \"%s\\n\", prop->menu->sym->name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(out, \"  unknown prop %d!\\n\", prop->type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (menu->help) {\n\t\tint len = strlen(menu->help);\n\t\twhile (menu->help[--len] == '\\n')\n\t\t\tmenu->help[len] = 0;\n\t\tfprintf(out, \"  help\\n%s\\n\", menu->help);\n\t}\n}\n\nvoid zconfdump(FILE *out)\n{\n\tstruct property *prop;\n\tstruct symbol *sym;\n\tstruct menu *menu;\n\n\tmenu = rootmenu.list;\n\twhile (menu) {\n\t\tif ((sym = menu->sym))\n\t\t\tprint_symbol(out, menu);\n\t\telse if ((prop = menu->prompt)) {\n\t\t\tswitch (prop->type) {\n\t\t\tcase P_COMMENT:\n\t\t\t\tfputs(\"\\ncomment \", out);\n\t\t\t\tprint_quoted_string(out, prop->text);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbreak;\n\t\t\tcase P_MENU:\n\t\t\t\tfputs(\"\\nmenu \", out);\n\t\t\t\tprint_quoted_string(out, prop->text);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t\t}\n\t\t\tif (!expr_is_yes(prop->visible.expr)) {\n\t\t\t\tfputs(\"  depends \", out);\n\t\t\t\texpr_fprint(prop->visible.expr, out);\n\t\t\t\tfputc('\\n', out);\n\t\t\t}\n\t\t}\n\n\t\tif (menu->list)\n\t\t\tmenu = menu->list;\n\t\telse if (menu->next)\n\t\t\tmenu = menu->next;\n\t\telse while ((menu = menu->parent)) {\n\t\t\tif (menu->prompt && menu->prompt->type == P_MENU)\n\t\t\t\tfputs(\"\\nendmenu\\n\", out);\n\t\t\tif (menu->next) {\n\t\t\t\tmenu = menu->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}