{
  "module_name": "nconf.gui.c",
  "hash_id": "22dd2b9468b038cde600133e2fedd8e516d939777fb85038459d2ead3525cf8f",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/nconf.gui.c",
  "human_readable_source": "\n \n#include \"nconf.h\"\n#include \"lkc.h\"\n\nint attr_normal;\nint attr_main_heading;\nint attr_main_menu_box;\nint attr_main_menu_fore;\nint attr_main_menu_back;\nint attr_main_menu_grey;\nint attr_main_menu_heading;\nint attr_scrollwin_text;\nint attr_scrollwin_heading;\nint attr_scrollwin_box;\nint attr_dialog_text;\nint attr_dialog_menu_fore;\nint attr_dialog_menu_back;\nint attr_dialog_box;\nint attr_input_box;\nint attr_input_heading;\nint attr_input_text;\nint attr_input_field;\nint attr_function_text;\nint attr_function_highlight;\n\n#define COLOR_ATTR(_at, _fg, _bg, _hl) \\\n\t{ .attr = &(_at), .has_color = true, .color_fg = _fg, .color_bg = _bg, .highlight = _hl }\n#define NO_COLOR_ATTR(_at, _hl) \\\n\t{ .attr = &(_at), .has_color = false, .highlight = _hl }\n#define COLOR_DEFAULT\t\t-1\n\nstruct nconf_attr_param {\n\tint *attr;\n\tbool has_color;\n\tint color_fg;\n\tint color_bg;\n\tint highlight;\n};\n\nstatic const struct nconf_attr_param color_theme_params[] = {\n\tCOLOR_ATTR(attr_normal,\t\t\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_NORMAL),\n\tCOLOR_ATTR(attr_main_heading,\t\tCOLOR_MAGENTA,\tCOLOR_DEFAULT,\tA_BOLD | A_UNDERLINE),\n\tCOLOR_ATTR(attr_main_menu_box,\t\tCOLOR_YELLOW,\tCOLOR_DEFAULT,\tA_NORMAL),\n\tCOLOR_ATTR(attr_main_menu_fore,\t\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_REVERSE),\n\tCOLOR_ATTR(attr_main_menu_back,\t\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_NORMAL),\n\tCOLOR_ATTR(attr_main_menu_grey,\t\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_NORMAL),\n\tCOLOR_ATTR(attr_main_menu_heading,\tCOLOR_GREEN,\tCOLOR_DEFAULT,\tA_BOLD),\n\tCOLOR_ATTR(attr_scrollwin_text,\t\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_NORMAL),\n\tCOLOR_ATTR(attr_scrollwin_heading,\tCOLOR_GREEN,\tCOLOR_DEFAULT,\tA_BOLD),\n\tCOLOR_ATTR(attr_scrollwin_box,\t\tCOLOR_YELLOW,\tCOLOR_DEFAULT,\tA_BOLD),\n\tCOLOR_ATTR(attr_dialog_text,\t\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_BOLD),\n\tCOLOR_ATTR(attr_dialog_menu_fore,\tCOLOR_RED,\tCOLOR_DEFAULT,\tA_STANDOUT),\n\tCOLOR_ATTR(attr_dialog_menu_back,\tCOLOR_YELLOW,\tCOLOR_DEFAULT,\tA_NORMAL),\n\tCOLOR_ATTR(attr_dialog_box,\t\tCOLOR_YELLOW,\tCOLOR_DEFAULT,\tA_BOLD),\n\tCOLOR_ATTR(attr_input_box,\t\tCOLOR_YELLOW,\tCOLOR_DEFAULT,\tA_NORMAL),\n\tCOLOR_ATTR(attr_input_heading,\t\tCOLOR_GREEN,\tCOLOR_DEFAULT,\tA_BOLD),\n\tCOLOR_ATTR(attr_input_text,\t\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_NORMAL),\n\tCOLOR_ATTR(attr_input_field,\t\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_UNDERLINE),\n\tCOLOR_ATTR(attr_function_text,\t\tCOLOR_YELLOW,\tCOLOR_DEFAULT,\tA_REVERSE),\n\tCOLOR_ATTR(attr_function_highlight,\tCOLOR_DEFAULT,\tCOLOR_DEFAULT,\tA_BOLD),\n\t{   }\n};\n\nstatic const struct nconf_attr_param no_color_theme_params[] = {\n\tNO_COLOR_ATTR(attr_normal,\t\tA_NORMAL),\n\tNO_COLOR_ATTR(attr_main_heading,\tA_BOLD | A_UNDERLINE),\n\tNO_COLOR_ATTR(attr_main_menu_box,\tA_NORMAL),\n\tNO_COLOR_ATTR(attr_main_menu_fore,\tA_STANDOUT),\n\tNO_COLOR_ATTR(attr_main_menu_back,\tA_NORMAL),\n\tNO_COLOR_ATTR(attr_main_menu_grey,\tA_NORMAL),\n\tNO_COLOR_ATTR(attr_main_menu_heading,\tA_BOLD),\n\tNO_COLOR_ATTR(attr_scrollwin_text,\tA_NORMAL),\n\tNO_COLOR_ATTR(attr_scrollwin_heading,\tA_BOLD),\n\tNO_COLOR_ATTR(attr_scrollwin_box,\tA_BOLD),\n\tNO_COLOR_ATTR(attr_dialog_text,\t\tA_NORMAL),\n\tNO_COLOR_ATTR(attr_dialog_menu_fore,\tA_STANDOUT),\n\tNO_COLOR_ATTR(attr_dialog_menu_back,\tA_NORMAL),\n\tNO_COLOR_ATTR(attr_dialog_box,\t\tA_BOLD),\n\tNO_COLOR_ATTR(attr_input_box,\t\tA_BOLD),\n\tNO_COLOR_ATTR(attr_input_heading,\tA_BOLD),\n\tNO_COLOR_ATTR(attr_input_text,\t\tA_NORMAL),\n\tNO_COLOR_ATTR(attr_input_field,\t\tA_UNDERLINE),\n\tNO_COLOR_ATTR(attr_function_text,\tA_REVERSE),\n\tNO_COLOR_ATTR(attr_function_highlight,\tA_BOLD),\n\t{   }\n};\n\nvoid set_colors(void)\n{\n\tconst struct nconf_attr_param *p;\n\tint pair = 0;\n\n\tif (has_colors()) {\n\t\tstart_color();\n\t\tuse_default_colors();\n\t\tp = color_theme_params;\n\t} else {\n\t\tp = no_color_theme_params;\n\t}\n\n\tfor (; p->attr; p++) {\n\t\tint attr = p->highlight;\n\n\t\tif (p->has_color) {\n\t\t\tpair++;\n\t\t\tinit_pair(pair, p->color_fg, p->color_bg);\n\t\t\tattr |= COLOR_PAIR(pair);\n\t\t}\n\n\t\t*p->attr = attr;\n\t}\n}\n\n \nvoid print_in_middle(WINDOW *win, int y, int width, const char *str, int attrs)\n{\n\twattrset(win, attrs);\n\tmvwprintw(win, y, (width - strlen(str)) / 2, \"%s\", str);\n}\n\nint get_line_no(const char *text)\n{\n\tint i;\n\tint total = 1;\n\n\tif (!text)\n\t\treturn 0;\n\n\tfor (i = 0; text[i] != '\\0'; i++)\n\t\tif (text[i] == '\\n')\n\t\t\ttotal++;\n\treturn total;\n}\n\nconst char *get_line(const char *text, int line_no)\n{\n\tint i;\n\tint lines = 0;\n\n\tif (!text)\n\t\treturn NULL;\n\n\tfor (i = 0; text[i] != '\\0' && lines < line_no; i++)\n\t\tif (text[i] == '\\n')\n\t\t\tlines++;\n\treturn text+i;\n}\n\nint get_line_length(const char *line)\n{\n\tint res = 0;\n\twhile (*line != '\\0' && *line != '\\n') {\n\t\tline++;\n\t\tres++;\n\t}\n\treturn res;\n}\n\n \nvoid fill_window(WINDOW *win, const char *text)\n{\n\tint x, y;\n\tint total_lines = get_line_no(text);\n\tint i;\n\n\tgetmaxyx(win, y, x);\n\t \n\ttotal_lines = min(total_lines, y);\n\tfor (i = 0; i < total_lines; i++) {\n\t\tchar tmp[x+10];\n\t\tconst char *line = get_line(text, i);\n\t\tint len = get_line_length(line);\n\t\tstrncpy(tmp, line, min(len, x));\n\t\ttmp[len] = '\\0';\n\t\tmvwprintw(win, i, 0, \"%s\", tmp);\n\t}\n}\n\n \nint btn_dialog(WINDOW *main_window, const char *msg, int btn_num, ...)\n{\n\tva_list ap;\n\tchar *btn;\n\tint btns_width = 0;\n\tint msg_lines = 0;\n\tint msg_width = 0;\n\tint total_width;\n\tint win_rows = 0;\n\tWINDOW *win;\n\tWINDOW *msg_win;\n\tWINDOW *menu_win;\n\tMENU *menu;\n\tITEM *btns[btn_num+1];\n\tint i, x, y;\n\tint res = -1;\n\n\n\tva_start(ap, btn_num);\n\tfor (i = 0; i < btn_num; i++) {\n\t\tbtn = va_arg(ap, char *);\n\t\tbtns[i] = new_item(btn, \"\");\n\t\tbtns_width += strlen(btn)+1;\n\t}\n\tva_end(ap);\n\tbtns[btn_num] = NULL;\n\n\t \n\tmsg_lines = get_line_no(msg);\n\tfor (i = 0; i < msg_lines; i++) {\n\t\tconst char *line = get_line(msg, i);\n\t\tint len = get_line_length(line);\n\t\tif (msg_width < len)\n\t\t\tmsg_width = len;\n\t}\n\n\ttotal_width = max(msg_width, btns_width);\n\t \n\ty = (getmaxy(stdscr)-(msg_lines+4))/2;\n\tx = (getmaxx(stdscr)-(total_width+4))/2;\n\n\n\t \n\tif (btn_num > 0)\n\t\twin_rows = msg_lines+4;\n\telse\n\t\twin_rows = msg_lines+2;\n\n\twin = newwin(win_rows, total_width+4, y, x);\n\tkeypad(win, TRUE);\n\tmenu_win = derwin(win, 1, btns_width, win_rows-2,\n\t\t\t1+(total_width+2-btns_width)/2);\n\tmenu = new_menu(btns);\n\tmsg_win = derwin(win, win_rows-2, msg_width, 1,\n\t\t\t1+(total_width+2-msg_width)/2);\n\n\tset_menu_fore(menu, attr_dialog_menu_fore);\n\tset_menu_back(menu, attr_dialog_menu_back);\n\n\twattrset(win, attr_dialog_box);\n\tbox(win, 0, 0);\n\n\t \n\twattrset(msg_win, attr_dialog_text);\n\tfill_window(msg_win, msg);\n\n\tset_menu_win(menu, win);\n\tset_menu_sub(menu, menu_win);\n\tset_menu_format(menu, 1, btn_num);\n\tmenu_opts_off(menu, O_SHOWDESC);\n\tmenu_opts_off(menu, O_SHOWMATCH);\n\tmenu_opts_on(menu, O_ONEVALUE);\n\tmenu_opts_on(menu, O_NONCYCLIC);\n\tset_menu_mark(menu, \"\");\n\tpost_menu(menu);\n\n\n\ttouchwin(win);\n\trefresh_all_windows(main_window);\n\twhile ((res = wgetch(win))) {\n\t\tswitch (res) {\n\t\tcase KEY_LEFT:\n\t\t\tmenu_driver(menu, REQ_LEFT_ITEM);\n\t\t\tbreak;\n\t\tcase KEY_RIGHT:\n\t\t\tmenu_driver(menu, REQ_RIGHT_ITEM);\n\t\t\tbreak;\n\t\tcase 10:  \n\t\tcase 27:  \n\t\tcase ' ':\n\t\tcase KEY_F(F_BACK):\n\t\tcase KEY_F(F_EXIT):\n\t\t\tbreak;\n\t\t}\n\t\ttouchwin(win);\n\t\trefresh_all_windows(main_window);\n\n\t\tif (res == 10 || res == ' ') {\n\t\t\tres = item_index(current_item(menu));\n\t\t\tbreak;\n\t\t} else if (res == 27 || res == KEY_F(F_BACK) ||\n\t\t\t\tres == KEY_F(F_EXIT)) {\n\t\t\tres = KEY_EXIT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tunpost_menu(menu);\n\tfree_menu(menu);\n\tfor (i = 0; i < btn_num; i++)\n\t\tfree_item(btns[i]);\n\n\tdelwin(win);\n\treturn res;\n}\n\nint dialog_inputbox(WINDOW *main_window,\n\t\tconst char *title, const char *prompt,\n\t\tconst char *init, char **resultp, int *result_len)\n{\n\tint prompt_lines = 0;\n\tint prompt_width = 0;\n\tWINDOW *win;\n\tWINDOW *prompt_win;\n\tWINDOW *form_win;\n\tPANEL *panel;\n\tint i, x, y, lines, columns, win_lines, win_cols;\n\tint res = -1;\n\tint cursor_position = strlen(init);\n\tint cursor_form_win;\n\tchar *result = *resultp;\n\n\tgetmaxyx(stdscr, lines, columns);\n\n\tif (strlen(init)+1 > *result_len) {\n\t\t*result_len = strlen(init)+1;\n\t\t*resultp = result = xrealloc(result, *result_len);\n\t}\n\n\t \n\tprompt_lines = get_line_no(prompt);\n\tfor (i = 0; i < prompt_lines; i++) {\n\t\tconst char *line = get_line(prompt, i);\n\t\tint len = get_line_length(line);\n\t\tprompt_width = max(prompt_width, len);\n\t}\n\n\tif (title)\n\t\tprompt_width = max(prompt_width, strlen(title));\n\n\twin_lines = min(prompt_lines+6, lines-2);\n\twin_cols = min(prompt_width+7, columns-2);\n\tprompt_lines = max(win_lines-6, 0);\n\tprompt_width = max(win_cols-7, 0);\n\n\t \n\ty = (lines-win_lines)/2;\n\tx = (columns-win_cols)/2;\n\n\tstrncpy(result, init, *result_len);\n\n\t \n\twin = newwin(win_lines, win_cols, y, x);\n\tprompt_win = derwin(win, prompt_lines+1, prompt_width, 2, 2);\n\tform_win = derwin(win, 1, prompt_width, prompt_lines+3, 2);\n\tkeypad(form_win, TRUE);\n\n\twattrset(form_win, attr_input_field);\n\n\twattrset(win, attr_input_box);\n\tbox(win, 0, 0);\n\twattrset(win, attr_input_heading);\n\tif (title)\n\t\tmvwprintw(win, 0, 3, \"%s\", title);\n\n\t \n\twattrset(prompt_win, attr_input_text);\n\tfill_window(prompt_win, prompt);\n\n\tmvwprintw(form_win, 0, 0, \"%*s\", prompt_width, \" \");\n\tcursor_form_win = min(cursor_position, prompt_width-1);\n\tmvwprintw(form_win, 0, 0, \"%s\",\n\t\t  result + cursor_position-cursor_form_win);\n\n\t \n\tpanel = new_panel(win);\n\n\t \n\tcurs_set(1);\n\n\ttouchwin(win);\n\trefresh_all_windows(main_window);\n\twhile ((res = wgetch(form_win))) {\n\t\tint len = strlen(result);\n\t\tswitch (res) {\n\t\tcase 10:  \n\t\tcase 27:  \n\t\tcase KEY_F(F_HELP):\n\t\tcase KEY_F(F_EXIT):\n\t\tcase KEY_F(F_BACK):\n\t\t\tbreak;\n\t\tcase 8:    \n\t\tcase 127:  \n\t\tcase KEY_BACKSPACE:\n\t\t\tif (cursor_position > 0) {\n\t\t\t\tmemmove(&result[cursor_position-1],\n\t\t\t\t\t\t&result[cursor_position],\n\t\t\t\t\t\tlen-cursor_position+1);\n\t\t\t\tcursor_position--;\n\t\t\t\tcursor_form_win--;\n\t\t\t\tlen--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KEY_DC:\n\t\t\tif (cursor_position >= 0 && cursor_position < len) {\n\t\t\t\tmemmove(&result[cursor_position],\n\t\t\t\t\t\t&result[cursor_position+1],\n\t\t\t\t\t\tlen-cursor_position+1);\n\t\t\t\tlen--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KEY_UP:\n\t\tcase KEY_RIGHT:\n\t\t\tif (cursor_position < len) {\n\t\t\t\tcursor_position++;\n\t\t\t\tcursor_form_win++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KEY_DOWN:\n\t\tcase KEY_LEFT:\n\t\t\tif (cursor_position > 0) {\n\t\t\t\tcursor_position--;\n\t\t\t\tcursor_form_win--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KEY_HOME:\n\t\t\tcursor_position = 0;\n\t\t\tcursor_form_win = 0;\n\t\t\tbreak;\n\t\tcase KEY_END:\n\t\t\tcursor_position = len;\n\t\t\tcursor_form_win = min(cursor_position, prompt_width-1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((isgraph(res) || isspace(res))) {\n\t\t\t\t \n\t\t\t\tif (len+2 > *result_len) {\n\t\t\t\t\t*result_len = len+2;\n\t\t\t\t\t*resultp = result = realloc(result,\n\t\t\t\t\t\t\t\t*result_len);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tmemmove(&result[cursor_position+1],\n\t\t\t\t\t\t&result[cursor_position],\n\t\t\t\t\t\tlen-cursor_position+1);\n\t\t\t\tresult[cursor_position] = res;\n\t\t\t\tcursor_position++;\n\t\t\t\tcursor_form_win++;\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tmvprintw(0, 0, \"unknown key: %d\\n\", res);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (cursor_form_win < 0)\n\t\t\tcursor_form_win = 0;\n\t\telse if (cursor_form_win > prompt_width-1)\n\t\t\tcursor_form_win = prompt_width-1;\n\n\t\twmove(form_win, 0, 0);\n\t\twclrtoeol(form_win);\n\t\tmvwprintw(form_win, 0, 0, \"%*s\", prompt_width, \" \");\n\t\tmvwprintw(form_win, 0, 0, \"%s\",\n\t\t\tresult + cursor_position-cursor_form_win);\n\t\twmove(form_win, 0, cursor_form_win);\n\t\ttouchwin(win);\n\t\trefresh_all_windows(main_window);\n\n\t\tif (res == 10) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t} else if (res == 27 || res == KEY_F(F_BACK) ||\n\t\t\t\tres == KEY_F(F_EXIT)) {\n\t\t\tres = KEY_EXIT;\n\t\t\tbreak;\n\t\t} else if (res == KEY_F(F_HELP)) {\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tcurs_set(0);\n\tdel_panel(panel);\n\tdelwin(prompt_win);\n\tdelwin(form_win);\n\tdelwin(win);\n\treturn res;\n}\n\n \nvoid refresh_all_windows(WINDOW *main_window)\n{\n\tupdate_panels();\n\ttouchwin(main_window);\n\trefresh();\n}\n\nvoid show_scroll_win(WINDOW *main_window,\n\t\tconst char *title,\n\t\tconst char *text)\n{\n\t(void)show_scroll_win_ext(main_window, title, (char *)text, NULL, NULL, NULL, NULL);\n}\n\n \nint show_scroll_win_ext(WINDOW *main_window, const char *title, char *text,\n\t\t\tint *vscroll, int *hscroll,\n\t\t\textra_key_cb_fn extra_key_cb, void *data)\n{\n\tint res;\n\tint total_lines = get_line_no(text);\n\tint x, y, lines, columns;\n\tint start_x = 0, start_y = 0;\n\tint text_lines = 0, text_cols = 0;\n\tint total_cols = 0;\n\tint win_cols = 0;\n\tint win_lines = 0;\n\tint i = 0;\n\tWINDOW *win;\n\tWINDOW *pad;\n\tPANEL *panel;\n\tbool done = false;\n\n\tif (hscroll)\n\t\tstart_x = *hscroll;\n\tif (vscroll)\n\t\tstart_y = *vscroll;\n\n\tgetmaxyx(stdscr, lines, columns);\n\n\t \n\ttotal_lines = get_line_no(text);\n\tfor (i = 0; i < total_lines; i++) {\n\t\tconst char *line = get_line(text, i);\n\t\tint len = get_line_length(line);\n\t\ttotal_cols = max(total_cols, len+2);\n\t}\n\n\t \n\tpad = newpad(total_lines+10, total_cols+10);\n\twattrset(pad, attr_scrollwin_text);\n\tfill_window(pad, text);\n\n\twin_lines = min(total_lines+4, lines-2);\n\twin_cols = min(total_cols+2, columns-2);\n\ttext_lines = max(win_lines-4, 0);\n\ttext_cols = max(win_cols-2, 0);\n\n\t \n\ty = (lines-win_lines)/2;\n\tx = (columns-win_cols)/2;\n\n\twin = newwin(win_lines, win_cols, y, x);\n\tkeypad(win, TRUE);\n\t \n\twattrset(win, attr_scrollwin_box);\n\tbox(win, 0, 0);\n\twattrset(win, attr_scrollwin_heading);\n\tmvwprintw(win, 0, 3, \" %s \", title);\n\tpanel = new_panel(win);\n\n\t \n\twhile (!done) {\n\t\tcopywin(pad, win, start_y, start_x, 2, 2, text_lines,\n\t\t\t\ttext_cols, 0);\n\t\tprint_in_middle(win,\n\t\t\t\ttext_lines+2,\n\t\t\t\ttext_cols,\n\t\t\t\t\"<OK>\",\n\t\t\t\tattr_dialog_menu_fore);\n\t\twrefresh(win);\n\n\t\tres = wgetch(win);\n\t\tswitch (res) {\n\t\tcase KEY_NPAGE:\n\t\tcase ' ':\n\t\tcase 'd':\n\t\t\tstart_y += text_lines-2;\n\t\t\tbreak;\n\t\tcase KEY_PPAGE:\n\t\tcase 'u':\n\t\t\tstart_y -= text_lines+2;\n\t\t\tbreak;\n\t\tcase KEY_HOME:\n\t\t\tstart_y = 0;\n\t\t\tbreak;\n\t\tcase KEY_END:\n\t\t\tstart_y = total_lines-text_lines;\n\t\t\tbreak;\n\t\tcase KEY_DOWN:\n\t\tcase 'j':\n\t\t\tstart_y++;\n\t\t\tbreak;\n\t\tcase KEY_UP:\n\t\tcase 'k':\n\t\t\tstart_y--;\n\t\t\tbreak;\n\t\tcase KEY_LEFT:\n\t\tcase 'h':\n\t\t\tstart_x--;\n\t\t\tbreak;\n\t\tcase KEY_RIGHT:\n\t\tcase 'l':\n\t\t\tstart_x++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (extra_key_cb) {\n\t\t\t\tsize_t start = (get_line(text, start_y) - text);\n\t\t\t\tsize_t end = (get_line(text, start_y + text_lines) - text);\n\n\t\t\t\tif (extra_key_cb(res, start, end, data)) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (res == 0 || res == 10 || res == 27 || res == 'q' ||\n\t\t\tres == KEY_F(F_HELP) || res == KEY_F(F_BACK) ||\n\t\t\tres == KEY_F(F_EXIT))\n\t\t\tbreak;\n\t\tif (start_y < 0)\n\t\t\tstart_y = 0;\n\t\tif (start_y >= total_lines-text_lines)\n\t\t\tstart_y = total_lines-text_lines;\n\t\tif (start_x < 0)\n\t\t\tstart_x = 0;\n\t\tif (start_x >= total_cols-text_cols)\n\t\t\tstart_x = total_cols-text_cols;\n\t}\n\n\tif (hscroll)\n\t\t*hscroll = start_x;\n\tif (vscroll)\n\t\t*vscroll = start_y;\n\tdel_panel(panel);\n\tdelwin(win);\n\trefresh_all_windows(main_window);\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}