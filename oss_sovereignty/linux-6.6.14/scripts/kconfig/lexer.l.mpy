{
  "module_name": "lexer.l",
  "hash_id": "e8b1d08e29cb09f6d76094111cd905d5f8c92364a8c7ba25bda18bf65e1a9090",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/lexer.l",
  "human_readable_source": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>\n */\n%option nostdinit noyywrap never-interactive full ecs\n%option 8bit nodefault yylineno\n%x ASSIGN_VAL HELP STRING\n%{\n\n#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lkc.h\"\n#include \"parser.tab.h\"\n\n#define YY_DECL\t\tstatic int yylex1(void)\n\n#define START_STRSIZE\t16\n\nstatic struct {\n\tstruct file *file;\n\tint lineno;\n} current_pos;\n\nstatic int prev_prev_token = T_EOL;\nstatic int prev_token = T_EOL;\nstatic char *text;\nstatic int text_size, text_asize;\n\nstruct buffer {\n\tstruct buffer *parent;\n\tYY_BUFFER_STATE state;\n};\n\nstatic struct buffer *current_buf;\n\nstatic int last_ts, first_ts;\n\nstatic char *expand_token(const char *in, size_t n);\nstatic void append_expanded_string(const char *in);\nstatic void zconf_endhelp(void);\nstatic void zconf_endfile(void);\n\nstatic void new_string(void)\n{\n\ttext = xmalloc(START_STRSIZE);\n\ttext_asize = START_STRSIZE;\n\ttext_size = 0;\n\t*text = 0;\n}\n\nstatic void append_string(const char *str, int size)\n{\n\tint new_size = text_size + size + 1;\n\tif (new_size > text_asize) {\n\t\tnew_size += START_STRSIZE - 1;\n\t\tnew_size &= -START_STRSIZE;\n\t\ttext = xrealloc(text, new_size);\n\t\ttext_asize = new_size;\n\t}\n\tmemcpy(text + text_size, str, size);\n\ttext_size += size;\n\ttext[text_size] = 0;\n}\n\nstatic void alloc_string(const char *str, int size)\n{\n\ttext = xmalloc(size + 1);\n\tmemcpy(text, str, size);\n\ttext[size] = 0;\n}\n\nstatic void warn_ignored_character(char chr)\n{\n\tfprintf(stderr,\n\t        \"%s:%d:warning: ignoring unsupported character '%c'\\n\",\n\t        current_file->name, yylineno, chr);\n}\n%}\n\nn\t[A-Za-z0-9_-]\n\n%%\n\tchar open_quote = 0;\n\n#.*\t\t\t/* ignore comment */\n[ \\t]*\t\t\t/* whitespaces */\n\\\\\\n\t\t\t/* escaped new line */\n\\n\t\t\treturn T_EOL;\n\"bool\"\t\t\treturn T_BOOL;\n\"choice\"\t\treturn T_CHOICE;\n\"comment\"\t\treturn T_COMMENT;\n\"config\"\t\treturn T_CONFIG;\n\"def_bool\"\t\treturn T_DEF_BOOL;\n\"def_tristate\"\t\treturn T_DEF_TRISTATE;\n\"default\"\t\treturn T_DEFAULT;\n\"depends\"\t\treturn T_DEPENDS;\n\"endchoice\"\t\treturn T_ENDCHOICE;\n\"endif\"\t\t\treturn T_ENDIF;\n\"endmenu\"\t\treturn T_ENDMENU;\n\"help\"\t\t\treturn T_HELP;\n\"hex\"\t\t\treturn T_HEX;\n\"if\"\t\t\treturn T_IF;\n\"imply\"\t\t\treturn T_IMPLY;\n\"int\"\t\t\treturn T_INT;\n\"mainmenu\"\t\treturn T_MAINMENU;\n\"menu\"\t\t\treturn T_MENU;\n\"menuconfig\"\t\treturn T_MENUCONFIG;\n\"modules\"\t\treturn T_MODULES;\n\"on\"\t\t\treturn T_ON;\n\"optional\"\t\treturn T_OPTIONAL;\n\"prompt\"\t\treturn T_PROMPT;\n\"range\"\t\t\treturn T_RANGE;\n\"select\"\t\treturn T_SELECT;\n\"source\"\t\treturn T_SOURCE;\n\"string\"\t\treturn T_STRING;\n\"tristate\"\t\treturn T_TRISTATE;\n\"visible\"\t\treturn T_VISIBLE;\n\"||\"\t\t\treturn T_OR;\n\"&&\"\t\t\treturn T_AND;\n\"=\"\t\t\treturn T_EQUAL;\n\"!=\"\t\t\treturn T_UNEQUAL;\n\"<\"\t\t\treturn T_LESS;\n\"<=\"\t\t\treturn T_LESS_EQUAL;\n\">\"\t\t\treturn T_GREATER;\n\">=\"\t\t\treturn T_GREATER_EQUAL;\n\"!\"\t\t\treturn T_NOT;\n\"(\"\t\t\treturn T_OPEN_PAREN;\n\")\"\t\t\treturn T_CLOSE_PAREN;\n\":=\"\t\t\treturn T_COLON_EQUAL;\n\"+=\"\t\t\treturn T_PLUS_EQUAL;\n\\\"|\\'\t\t\t{\n\t\t\t\topen_quote = yytext[0];\n\t\t\t\tnew_string();\n\t\t\t\tBEGIN(STRING);\n\t\t\t}\n{n}+\t\t\t{\n\t\t\t\talloc_string(yytext, yyleng);\n\t\t\t\tyylval.string = text;\n\t\t\t\treturn T_WORD;\n\t\t\t}\n({n}|$)+\t\t{\n\t\t\t\t/* this token includes at least one '$' */\n\t\t\t\tyylval.string = expand_token(yytext, yyleng);\n\t\t\t\tif (strlen(yylval.string))\n\t\t\t\t\treturn T_WORD;\n\t\t\t\tfree(yylval.string);\n\t\t\t}\n.\t\t\twarn_ignored_character(*yytext);\n\n<ASSIGN_VAL>{\n\t[^[:blank:]\\n]+.*\t{\n\t\talloc_string(yytext, yyleng);\n\t\tyylval.string = text;\n\t\treturn T_ASSIGN_VAL;\n\t}\n\t\\n\t{ BEGIN(INITIAL); return T_EOL; }\n\t.\n}\n\n<STRING>{\n\t\"$\".*\tappend_expanded_string(yytext);\n\t[^$'\"\\\\\\n]+\t{\n\t\tappend_string(yytext, yyleng);\n\t}\n\t\\\\.?\t{\n\t\tappend_string(yytext + 1, yyleng - 1);\n\t}\n\t\\'|\\\"\t{\n\t\tif (open_quote == yytext[0]) {\n\t\t\tBEGIN(INITIAL);\n\t\t\tyylval.string = text;\n\t\t\treturn T_WORD_QUOTE;\n\t\t} else\n\t\t\tappend_string(yytext, 1);\n\t}\n\t\\n\t{\n\t\tfprintf(stderr,\n\t\t\t\"%s:%d:warning: multi-line strings not supported\\n\",\n\t\t\tzconf_curname(), zconf_lineno());\n\t\tunput('\\n');\n\t\tBEGIN(INITIAL);\n\t\tyylval.string = text;\n\t\treturn T_WORD_QUOTE;\n\t}\n\t<<EOF>>\t{\n\t\tBEGIN(INITIAL);\n\t\tyylval.string = text;\n\t\treturn T_WORD_QUOTE;\n\t}\n}\n\n<HELP>{\n\t[ \\t]+\t{\n\t\tint ts, i;\n\n\t\tts = 0;\n\t\tfor (i = 0; i < yyleng; i++) {\n\t\t\tif (yytext[i] == '\\t')\n\t\t\t\tts = (ts & ~7) + 8;\n\t\t\telse\n\t\t\t\tts++;\n\t\t}\n\t\tlast_ts = ts;\n\t\tif (first_ts) {\n\t\t\tif (ts < first_ts) {\n\t\t\t\tzconf_endhelp();\n\t\t\t\treturn T_HELPTEXT;\n\t\t\t}\n\t\t\tts -= first_ts;\n\t\t\twhile (ts > 8) {\n\t\t\t\tappend_string(\"        \", 8);\n\t\t\t\tts -= 8;\n\t\t\t}\n\t\t\tappend_string(\"        \", ts);\n\t\t}\n\t}\n\t[ \\t]*\\n/[^ \\t\\n] {\n\t\tzconf_endhelp();\n\t\treturn T_HELPTEXT;\n\t}\n\t[ \\t]*\\n\t{\n\t\tappend_string(\"\\n\", 1);\n\t}\n\t[^ \\t\\n].* {\n\t\twhile (yyleng) {\n\t\t\tif ((yytext[yyleng-1] != ' ') && (yytext[yyleng-1] != '\\t'))\n\t\t\t\tbreak;\n\t\t\tyyleng--;\n\t\t}\n\t\tappend_string(yytext, yyleng);\n\t\tif (!first_ts)\n\t\t\tfirst_ts = last_ts;\n\t}\n\t<<EOF>>\t{\n\t\tzconf_endhelp();\n\t\treturn T_HELPTEXT;\n\t}\n}\n\n<<EOF>>\t{\n\tBEGIN(INITIAL);\n\n\tif (prev_token != T_EOL && prev_token != T_HELPTEXT)\n\t\tfprintf(stderr, \"%s:%d:warning: no new line at end of file\\n\",\n\t\t\tcurrent_file->name, yylineno);\n\n\tif (current_file) {\n\t\tzconf_endfile();\n\t\treturn T_EOL;\n\t}\n\tfclose(yyin);\n\tyyterminate();\n}\n\n%%\n\n/* second stage lexer */\nint yylex(void)\n{\n\tint token;\n\nrepeat:\n\ttoken = yylex1();\n\n\tif (prev_token == T_EOL || prev_token == T_HELPTEXT) {\n\t\tif (token == T_EOL) {\n\t\t\t/* Do not pass unneeded T_EOL to the parser. */\n\t\t\tgoto repeat;\n\t\t} else {\n\t\t\t/*\n\t\t\t * For the parser, update file/lineno at the first token\n\t\t\t * of each statement. Generally, \\n is a statement\n\t\t\t * terminator in Kconfig, but it is not always true\n\t\t\t * because \\n could be escaped by a backslash.\n\t\t\t */\n\t\t\tcurrent_pos.file = current_file;\n\t\t\tcurrent_pos.lineno = yylineno;\n\t\t}\n\t}\n\n\tif (prev_prev_token == T_EOL && prev_token == T_WORD &&\n\t    (token == T_EQUAL || token == T_COLON_EQUAL || token == T_PLUS_EQUAL))\n\t\tBEGIN(ASSIGN_VAL);\n\n\tprev_prev_token = prev_token;\n\tprev_token = token;\n\n\treturn token;\n}\n\nstatic char *expand_token(const char *in, size_t n)\n{\n\tchar *out;\n\tint c;\n\tchar c2;\n\tconst char *rest, *end;\n\n\tnew_string();\n\tappend_string(in, n);\n\n\t/* get the whole line because we do not know the end of token. */\n\twhile ((c = input()) != EOF) {\n\t\tif (c == '\\n') {\n\t\t\tunput(c);\n\t\t\tbreak;\n\t\t}\n\t\tc2 = c;\n\t\tappend_string(&c2, 1);\n\t}\n\n\trest = text;\n\tout = expand_one_token(&rest);\n\n\t/* push back unused characters to the input stream */\n\tend = rest + strlen(rest);\n\twhile (end > rest)\n\t\tunput(*--end);\n\n\tfree(text);\n\n\treturn out;\n}\n\nstatic void append_expanded_string(const char *str)\n{\n\tconst char *end;\n\tchar *res;\n\n\tstr++;\n\n\tres = expand_dollar(&str);\n\n\t/* push back unused characters to the input stream */\n\tend = str + strlen(str);\n\twhile (end > str)\n\t\tunput(*--end);\n\n\tappend_string(res, strlen(res));\n\n\tfree(res);\n}\n\nvoid zconf_starthelp(void)\n{\n\tnew_string();\n\tlast_ts = first_ts = 0;\n\tBEGIN(HELP);\n}\n\nstatic void zconf_endhelp(void)\n{\n\tyylval.string = text;\n\tBEGIN(INITIAL);\n}\n\n\n/*\n * Try to open specified file with following names:\n * ./name\n * $(srctree)/name\n * The latter is used when srctree is separate from objtree\n * when compiling the kernel.\n * Return NULL if file is not found.\n */\nFILE *zconf_fopen(const char *name)\n{\n\tchar *env, fullname[PATH_MAX+1];\n\tFILE *f;\n\n\tf = fopen(name, \"r\");\n\tif (!f && name != NULL && name[0] != '/') {\n\t\tenv = getenv(SRCTREE);\n\t\tif (env) {\n\t\t\tsnprintf(fullname, sizeof(fullname),\n\t\t\t\t \"%s/%s\", env, name);\n\t\t\tf = fopen(fullname, \"r\");\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid zconf_initscan(const char *name)\n{\n\tyyin = zconf_fopen(name);\n\tif (!yyin) {\n\t\tfprintf(stderr, \"can't find file %s\\n\", name);\n\t\texit(1);\n\t}\n\n\tcurrent_buf = xmalloc(sizeof(*current_buf));\n\tmemset(current_buf, 0, sizeof(*current_buf));\n\n\tcurrent_file = file_lookup(name);\n\tyylineno = 1;\n}\n\nvoid zconf_nextfile(const char *name)\n{\n\tstruct file *iter;\n\tstruct file *file = file_lookup(name);\n\tstruct buffer *buf = xmalloc(sizeof(*buf));\n\tmemset(buf, 0, sizeof(*buf));\n\n\tcurrent_buf->state = YY_CURRENT_BUFFER;\n\tyyin = zconf_fopen(file->name);\n\tif (!yyin) {\n\t\tfprintf(stderr, \"%s:%d: can't open file \\\"%s\\\"\\n\",\n\t\t\tzconf_curname(), zconf_lineno(), file->name);\n\t\texit(1);\n\t}\n\tyy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));\n\tbuf->parent = current_buf;\n\tcurrent_buf = buf;\n\n\tcurrent_file->lineno = yylineno;\n\tfile->parent = current_file;\n\n\tfor (iter = current_file; iter; iter = iter->parent) {\n\t\tif (!strcmp(iter->name, file->name)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Recursive inclusion detected.\\n\"\n\t\t\t\t\"Inclusion path:\\n\"\n\t\t\t\t\"  current file : %s\\n\", file->name);\n\t\t\titer = file;\n\t\t\tdo {\n\t\t\t\titer = iter->parent;\n\t\t\t\tfprintf(stderr, \"  included from: %s:%d\\n\",\n\t\t\t\t\titer->name, iter->lineno - 1);\n\t\t\t} while (strcmp(iter->name, file->name));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tyylineno = 1;\n\tcurrent_file = file;\n}\n\nstatic void zconf_endfile(void)\n{\n\tstruct buffer *parent;\n\n\tcurrent_file = current_file->parent;\n\tif (current_file)\n\t\tyylineno = current_file->lineno;\n\n\tparent = current_buf->parent;\n\tif (parent) {\n\t\tfclose(yyin);\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER);\n\t\tyy_switch_to_buffer(parent->state);\n\t}\n\tfree(current_buf);\n\tcurrent_buf = parent;\n}\n\nint zconf_lineno(void)\n{\n\treturn current_pos.lineno;\n}\n\nconst char *zconf_curname(void)\n{\n\treturn current_pos.file ? current_pos.file->name : \"<none>\";\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}