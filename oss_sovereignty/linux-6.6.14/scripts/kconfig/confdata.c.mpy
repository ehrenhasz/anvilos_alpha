{
  "module_name": "confdata.c",
  "hash_id": "e33a6ab44abe544d6c37af93b3ebd732f2fc8a0d04e62c89fd1a1b9828fa6de3",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/confdata.c",
  "human_readable_source": "\n \n\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"lkc.h\"\n\n \nstatic bool is_present(const char *path)\n{\n\tstruct stat st;\n\n\treturn !stat(path, &st);\n}\n\n \nstatic bool is_dir(const char *path)\n{\n\tstruct stat st;\n\n\tif (stat(path, &st))\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode);\n}\n\n \nstatic bool is_same(const char *file1, const char *file2)\n{\n\tint fd1, fd2;\n\tstruct stat st1, st2;\n\tvoid *map1, *map2;\n\tbool ret = false;\n\n\tfd1 = open(file1, O_RDONLY);\n\tif (fd1 < 0)\n\t\treturn ret;\n\n\tfd2 = open(file2, O_RDONLY);\n\tif (fd2 < 0)\n\t\tgoto close1;\n\n\tret = fstat(fd1, &st1);\n\tif (ret)\n\t\tgoto close2;\n\tret = fstat(fd2, &st2);\n\tif (ret)\n\t\tgoto close2;\n\n\tif (st1.st_size != st2.st_size)\n\t\tgoto close2;\n\n\tmap1 = mmap(NULL, st1.st_size, PROT_READ, MAP_PRIVATE, fd1, 0);\n\tif (map1 == MAP_FAILED)\n\t\tgoto close2;\n\n\tmap2 = mmap(NULL, st2.st_size, PROT_READ, MAP_PRIVATE, fd2, 0);\n\tif (map2 == MAP_FAILED)\n\t\tgoto close2;\n\n\tif (bcmp(map1, map2, st1.st_size))\n\t\tgoto close2;\n\n\tret = true;\nclose2:\n\tclose(fd2);\nclose1:\n\tclose(fd1);\n\n\treturn ret;\n}\n\n \nstatic int make_parent_dir(const char *path)\n{\n\tchar tmp[PATH_MAX + 1];\n\tchar *p;\n\n\tstrncpy(tmp, path, sizeof(tmp));\n\ttmp[sizeof(tmp) - 1] = 0;\n\n\t \n\tp = strrchr(tmp, '/');\n\tif (!p)\n\t\treturn 0;\n\t*(p + 1) = 0;\n\n\t \n\tp = tmp;\n\twhile (*p == '/')\n\t\tp++;\n\n\twhile ((p = strchr(p, '/'))) {\n\t\t*p = 0;\n\n\t\t \n\t\tif (!is_dir(tmp) && mkdir(tmp, 0755))\n\t\t\treturn -1;\n\n\t\t*p = '/';\n\t\twhile (*p == '/')\n\t\t\tp++;\n\t}\n\n\treturn 0;\n}\n\nstatic char depfile_path[PATH_MAX];\nstatic size_t depfile_prefix_len;\n\n \nstatic int conf_touch_dep(const char *name)\n{\n\tint fd;\n\n\t \n\tif (depfile_prefix_len + strlen(name) + 1 > sizeof(depfile_path))\n\t\treturn -1;\n\n\tstrcpy(depfile_path + depfile_prefix_len, name);\n\n\tfd = open(depfile_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd == -1)\n\t\treturn -1;\n\tclose(fd);\n\n\treturn 0;\n}\n\nstatic void conf_warning(const char *fmt, ...)\n\t__attribute__ ((format (printf, 1, 2)));\n\nstatic void conf_message(const char *fmt, ...)\n\t__attribute__ ((format (printf, 1, 2)));\n\nstatic const char *conf_filename;\nstatic int conf_lineno, conf_warnings;\n\nstatic void conf_warning(const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"%s:%d:warning: \", conf_filename, conf_lineno);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n\tconf_warnings++;\n}\n\nstatic void conf_default_message_callback(const char *s)\n{\n\tprintf(\"#\\n# \");\n\tprintf(\"%s\", s);\n\tprintf(\"\\n#\\n\");\n}\n\nstatic void (*conf_message_callback)(const char *s) =\n\tconf_default_message_callback;\nvoid conf_set_message_callback(void (*fn)(const char *s))\n{\n\tconf_message_callback = fn;\n}\n\nstatic void conf_message(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\n\tif (!conf_message_callback)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\n\tvsnprintf(buf, sizeof(buf), fmt, ap);\n\tconf_message_callback(buf);\n\tva_end(ap);\n}\n\nconst char *conf_get_configname(void)\n{\n\tchar *name = getenv(\"KCONFIG_CONFIG\");\n\n\treturn name ? name : \".config\";\n}\n\nstatic const char *conf_get_autoconfig_name(void)\n{\n\tchar *name = getenv(\"KCONFIG_AUTOCONFIG\");\n\n\treturn name ? name : \"include/config/auto.conf\";\n}\n\nstatic const char *conf_get_autoheader_name(void)\n{\n\tchar *name = getenv(\"KCONFIG_AUTOHEADER\");\n\n\treturn name ? name : \"include/generated/autoconf.h\";\n}\n\nstatic const char *conf_get_rustccfg_name(void)\n{\n\tchar *name = getenv(\"KCONFIG_RUSTCCFG\");\n\n\treturn name ? name : \"include/generated/rustc_cfg\";\n}\n\nstatic int conf_set_sym_val(struct symbol *sym, int def, int def_flags, char *p)\n{\n\tchar *p2;\n\n\tswitch (sym->type) {\n\tcase S_TRISTATE:\n\t\tif (p[0] == 'm') {\n\t\t\tsym->def[def].tri = mod;\n\t\t\tsym->flags |= def_flags;\n\t\t\tbreak;\n\t\t}\n\t\t \n\tcase S_BOOLEAN:\n\t\tif (p[0] == 'y') {\n\t\t\tsym->def[def].tri = yes;\n\t\t\tsym->flags |= def_flags;\n\t\t\tbreak;\n\t\t}\n\t\tif (p[0] == 'n') {\n\t\t\tsym->def[def].tri = no;\n\t\t\tsym->flags |= def_flags;\n\t\t\tbreak;\n\t\t}\n\t\tif (def != S_DEF_AUTO)\n\t\t\tconf_warning(\"symbol value '%s' invalid for %s\",\n\t\t\t\t     p, sym->name);\n\t\treturn 1;\n\tcase S_STRING:\n\t\t \n\t\tif (def != S_DEF_AUTO) {\n\t\t\tif (*p++ != '\"')\n\t\t\t\tbreak;\n\t\t\tfor (p2 = p; (p2 = strpbrk(p2, \"\\\"\\\\\")); p2++) {\n\t\t\t\tif (*p2 == '\"') {\n\t\t\t\t\t*p2 = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmemmove(p2, p2 + 1, strlen(p2));\n\t\t\t}\n\t\t\tif (!p2) {\n\t\t\t\tconf_warning(\"invalid string found\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t \n\tcase S_INT:\n\tcase S_HEX:\n\t\tif (sym_string_valid(sym, p)) {\n\t\t\tsym->def[def].val = xstrdup(p);\n\t\t\tsym->flags |= def_flags;\n\t\t} else {\n\t\t\tif (def != S_DEF_AUTO)\n\t\t\t\tconf_warning(\"symbol value '%s' invalid for %s\",\n\t\t\t\t\t     p, sym->name);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n\treturn 0;\n}\n\n#define LINE_GROWTH 16\nstatic int add_byte(int c, char **lineptr, size_t slen, size_t *n)\n{\n\tchar *nline;\n\tsize_t new_size = slen + 1;\n\tif (new_size > *n) {\n\t\tnew_size += LINE_GROWTH - 1;\n\t\tnew_size *= 2;\n\t\tnline = xrealloc(*lineptr, new_size);\n\t\tif (!nline)\n\t\t\treturn -1;\n\n\t\t*lineptr = nline;\n\t\t*n = new_size;\n\t}\n\n\t(*lineptr)[slen] = c;\n\n\treturn 0;\n}\n\nstatic ssize_t compat_getline(char **lineptr, size_t *n, FILE *stream)\n{\n\tchar *line = *lineptr;\n\tsize_t slen = 0;\n\n\tfor (;;) {\n\t\tint c = getc(stream);\n\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (add_byte(c, &line, slen, n) < 0)\n\t\t\t\tgoto e_out;\n\t\t\tslen++;\n\t\t\t \n\t\tcase EOF:\n\t\t\tif (add_byte('\\0', &line, slen, n) < 0)\n\t\t\t\tgoto e_out;\n\t\t\t*lineptr = line;\n\t\t\tif (slen == 0)\n\t\t\t\treturn -1;\n\t\t\treturn slen;\n\t\tdefault:\n\t\t\tif (add_byte(c, &line, slen, n) < 0)\n\t\t\t\tgoto e_out;\n\t\t\tslen++;\n\t\t}\n\t}\n\ne_out:\n\tline[slen-1] = '\\0';\n\t*lineptr = line;\n\treturn -1;\n}\n\nint conf_read_simple(const char *name, int def)\n{\n\tFILE *in = NULL;\n\tchar   *line = NULL;\n\tsize_t  line_asize = 0;\n\tchar *p, *p2;\n\tstruct symbol *sym;\n\tint i, def_flags;\n\tconst char *warn_unknown;\n\tconst char *werror;\n\n\twarn_unknown = getenv(\"KCONFIG_WARN_UNKNOWN_SYMBOLS\");\n\twerror = getenv(\"KCONFIG_WERROR\");\n\tif (name) {\n\t\tin = zconf_fopen(name);\n\t} else {\n\t\tchar *env;\n\n\t\tname = conf_get_configname();\n\t\tin = zconf_fopen(name);\n\t\tif (in)\n\t\t\tgoto load;\n\t\tconf_set_changed(true);\n\n\t\tenv = getenv(\"KCONFIG_DEFCONFIG_LIST\");\n\t\tif (!env)\n\t\t\treturn 1;\n\n\t\twhile (1) {\n\t\t\tbool is_last;\n\n\t\t\twhile (isspace(*env))\n\t\t\t\tenv++;\n\n\t\t\tif (!*env)\n\t\t\t\tbreak;\n\n\t\t\tp = env;\n\t\t\twhile (*p && !isspace(*p))\n\t\t\t\tp++;\n\n\t\t\tis_last = (*p == '\\0');\n\n\t\t\t*p = '\\0';\n\n\t\t\tin = zconf_fopen(env);\n\t\t\tif (in) {\n\t\t\t\tconf_message(\"using defaults found in %s\",\n\t\t\t\t\t     env);\n\t\t\t\tgoto load;\n\t\t\t}\n\n\t\t\tif (is_last)\n\t\t\t\tbreak;\n\n\t\t\tenv = p + 1;\n\t\t}\n\t}\n\tif (!in)\n\t\treturn 1;\n\nload:\n\tconf_filename = name;\n\tconf_lineno = 0;\n\tconf_warnings = 0;\n\n\tdef_flags = SYMBOL_DEF << def;\n\tfor_all_symbols(i, sym) {\n\t\tsym->flags |= SYMBOL_CHANGED;\n\t\tsym->flags &= ~(def_flags|SYMBOL_VALID);\n\t\tif (sym_is_choice(sym))\n\t\t\tsym->flags |= def_flags;\n\t\tswitch (sym->type) {\n\t\tcase S_INT:\n\t\tcase S_HEX:\n\t\tcase S_STRING:\n\t\t\tif (sym->def[def].val)\n\t\t\t\tfree(sym->def[def].val);\n\t\t\t \n\t\tdefault:\n\t\t\tsym->def[def].val = NULL;\n\t\t\tsym->def[def].tri = no;\n\t\t}\n\t}\n\n\twhile (compat_getline(&line, &line_asize, in) != -1) {\n\t\tconf_lineno++;\n\t\tsym = NULL;\n\t\tif (line[0] == '#') {\n\t\t\tif (memcmp(line + 2, CONFIG_, strlen(CONFIG_)))\n\t\t\t\tcontinue;\n\t\t\tp = strchr(line + 2 + strlen(CONFIG_), ' ');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t*p++ = 0;\n\t\t\tif (strncmp(p, \"is not set\", 10))\n\t\t\t\tcontinue;\n\t\t\tif (def == S_DEF_USER) {\n\t\t\t\tsym = sym_find(line + 2 + strlen(CONFIG_));\n\t\t\t\tif (!sym) {\n\t\t\t\t\tif (warn_unknown)\n\t\t\t\t\t\tconf_warning(\"unknown symbol: %s\",\n\t\t\t\t\t\t\t     line + 2 + strlen(CONFIG_));\n\n\t\t\t\t\tconf_set_changed(true);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym = sym_lookup(line + 2 + strlen(CONFIG_), 0);\n\t\t\t\tif (sym->type == S_UNKNOWN)\n\t\t\t\t\tsym->type = S_BOOLEAN;\n\t\t\t}\n\t\t\tif (sym->flags & def_flags) {\n\t\t\t\tconf_warning(\"override: reassigning to symbol %s\", sym->name);\n\t\t\t}\n\t\t\tswitch (sym->type) {\n\t\t\tcase S_BOOLEAN:\n\t\t\tcase S_TRISTATE:\n\t\t\t\tsym->def[def].tri = no;\n\t\t\t\tsym->flags |= def_flags;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t\t}\n\t\t} else if (memcmp(line, CONFIG_, strlen(CONFIG_)) == 0) {\n\t\t\tp = strchr(line + strlen(CONFIG_), '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t*p++ = 0;\n\t\t\tp2 = strchr(p, '\\n');\n\t\t\tif (p2) {\n\t\t\t\t*p2-- = 0;\n\t\t\t\tif (*p2 == '\\r')\n\t\t\t\t\t*p2 = 0;\n\t\t\t}\n\n\t\t\tsym = sym_find(line + strlen(CONFIG_));\n\t\t\tif (!sym) {\n\t\t\t\tif (def == S_DEF_AUTO) {\n\t\t\t\t\t \n\t\t\t\t\tconf_touch_dep(line + strlen(CONFIG_));\n\t\t\t\t} else {\n\t\t\t\t\tif (warn_unknown)\n\t\t\t\t\t\tconf_warning(\"unknown symbol: %s\",\n\t\t\t\t\t\t\t     line + strlen(CONFIG_));\n\n\t\t\t\t\tconf_set_changed(true);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sym->flags & def_flags) {\n\t\t\t\tconf_warning(\"override: reassigning to symbol %s\", sym->name);\n\t\t\t}\n\t\t\tif (conf_set_sym_val(sym, def, def_flags, p))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (line[0] != '\\r' && line[0] != '\\n')\n\t\t\t\tconf_warning(\"unexpected data: %.*s\",\n\t\t\t\t\t     (int)strcspn(line, \"\\r\\n\"), line);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sym && sym_is_choice_value(sym)) {\n\t\t\tstruct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));\n\t\t\tswitch (sym->def[def].tri) {\n\t\t\tcase no:\n\t\t\t\tbreak;\n\t\t\tcase mod:\n\t\t\t\tif (cs->def[def].tri == yes) {\n\t\t\t\t\tconf_warning(\"%s creates inconsistent choice state\", sym->name);\n\t\t\t\t\tcs->flags &= ~def_flags;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase yes:\n\t\t\t\tif (cs->def[def].tri != no)\n\t\t\t\t\tconf_warning(\"override: %s changes choice state\", sym->name);\n\t\t\t\tcs->def[def].val = sym;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcs->def[def].tri = EXPR_OR(cs->def[def].tri, sym->def[def].tri);\n\t\t}\n\t}\n\tfree(line);\n\tfclose(in);\n\n\tif (conf_warnings && werror)\n\t\texit(1);\n\n\treturn 0;\n}\n\nint conf_read(const char *name)\n{\n\tstruct symbol *sym;\n\tint conf_unsaved = 0;\n\tint i;\n\n\tconf_set_changed(false);\n\n\tif (conf_read_simple(name, S_DEF_USER)) {\n\t\tsym_calc_value(modules_sym);\n\t\treturn 1;\n\t}\n\n\tsym_calc_value(modules_sym);\n\n\tfor_all_symbols(i, sym) {\n\t\tsym_calc_value(sym);\n\t\tif (sym_is_choice(sym) || (sym->flags & SYMBOL_NO_WRITE))\n\t\t\tcontinue;\n\t\tif (sym_has_value(sym) && (sym->flags & SYMBOL_WRITE)) {\n\t\t\t \n\t\t\tswitch (sym->type) {\n\t\t\tcase S_BOOLEAN:\n\t\t\tcase S_TRISTATE:\n\t\t\t\tif (sym->def[S_DEF_USER].tri == sym_get_tristate_value(sym))\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!strcmp(sym->curr.val, sym->def[S_DEF_USER].val))\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!sym_has_value(sym) && !(sym->flags & SYMBOL_WRITE))\n\t\t\t \n\t\t\tcontinue;\n\t\tconf_unsaved++;\n\t\t \n\t}\n\n\tfor_all_symbols(i, sym) {\n\t\tif (sym_has_value(sym) && !sym_is_choice_value(sym)) {\n\t\t\t \n\t\t\tif (sym->visible == no && !conf_unsaved)\n\t\t\t\tsym->flags &= ~SYMBOL_DEF_USER;\n\t\t\tswitch (sym->type) {\n\t\t\tcase S_STRING:\n\t\t\tcase S_INT:\n\t\t\tcase S_HEX:\n\t\t\t\t \n\t\t\t\tif (sym_string_within_range(sym, sym->def[S_DEF_USER].val))\n\t\t\t\t\tbreak;\n\t\t\t\tsym->flags &= ~(SYMBOL_VALID|SYMBOL_DEF_USER);\n\t\t\t\tconf_unsaved++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (conf_warnings || conf_unsaved)\n\t\tconf_set_changed(true);\n\n\treturn 0;\n}\n\nstruct comment_style {\n\tconst char *decoration;\n\tconst char *prefix;\n\tconst char *postfix;\n};\n\nstatic const struct comment_style comment_style_pound = {\n\t.decoration = \"#\",\n\t.prefix = \"#\",\n\t.postfix = \"#\",\n};\n\nstatic const struct comment_style comment_style_c = {\n\t.decoration = \" *\",\n\t.prefix = \"/*\",\n\t.postfix = \" */\",\n};\n\nstatic void conf_write_heading(FILE *fp, const struct comment_style *cs)\n{\n\tif (!cs)\n\t\treturn;\n\n\tfprintf(fp, \"%s\\n\", cs->prefix);\n\n\tfprintf(fp, \"%s Automatically generated file; DO NOT EDIT.\\n\",\n\t\tcs->decoration);\n\n\tfprintf(fp, \"%s %s\\n\", cs->decoration, rootmenu.prompt->text);\n\n\tfprintf(fp, \"%s\\n\", cs->postfix);\n}\n\n \nstatic char *escape_string_value(const char *in)\n{\n\tconst char *p;\n\tchar *out;\n\tsize_t len;\n\n\tlen = strlen(in) + strlen(\"\\\"\\\"\") + 1;\n\n\tp = in;\n\twhile (1) {\n\t\tp += strcspn(p, \"\\\"\\\\\");\n\n\t\tif (p[0] == '\\0')\n\t\t\tbreak;\n\n\t\tlen++;\n\t\tp++;\n\t}\n\n\tout = xmalloc(len);\n\tout[0] = '\\0';\n\n\tstrcat(out, \"\\\"\");\n\n\tp = in;\n\twhile (1) {\n\t\tlen = strcspn(p, \"\\\"\\\\\");\n\t\tstrncat(out, p, len);\n\t\tp += len;\n\n\t\tif (p[0] == '\\0')\n\t\t\tbreak;\n\n\t\tstrcat(out, \"\\\\\");\n\t\tstrncat(out, p++, 1);\n\t}\n\n\tstrcat(out, \"\\\"\");\n\n\treturn out;\n}\n\nenum output_n { OUTPUT_N, OUTPUT_N_AS_UNSET, OUTPUT_N_NONE };\n\nstatic void __print_symbol(FILE *fp, struct symbol *sym, enum output_n output_n,\n\t\t\t   bool escape_string)\n{\n\tconst char *val;\n\tchar *escaped = NULL;\n\n\tif (sym->type == S_UNKNOWN)\n\t\treturn;\n\n\tval = sym_get_string_value(sym);\n\n\tif ((sym->type == S_BOOLEAN || sym->type == S_TRISTATE) &&\n\t    output_n != OUTPUT_N && *val == 'n') {\n\t\tif (output_n == OUTPUT_N_AS_UNSET)\n\t\t\tfprintf(fp, \"# %s%s is not set\\n\", CONFIG_, sym->name);\n\t\treturn;\n\t}\n\n\tif (sym->type == S_STRING && escape_string) {\n\t\tescaped = escape_string_value(val);\n\t\tval = escaped;\n\t}\n\n\tfprintf(fp, \"%s%s=%s\\n\", CONFIG_, sym->name, val);\n\n\tfree(escaped);\n}\n\nstatic void print_symbol_for_dotconfig(FILE *fp, struct symbol *sym)\n{\n\t__print_symbol(fp, sym, OUTPUT_N_AS_UNSET, true);\n}\n\nstatic void print_symbol_for_autoconf(FILE *fp, struct symbol *sym)\n{\n\t__print_symbol(fp, sym, OUTPUT_N_NONE, false);\n}\n\nvoid print_symbol_for_listconfig(struct symbol *sym)\n{\n\t__print_symbol(stdout, sym, OUTPUT_N, true);\n}\n\nstatic void print_symbol_for_c(FILE *fp, struct symbol *sym)\n{\n\tconst char *val;\n\tconst char *sym_suffix = \"\";\n\tconst char *val_prefix = \"\";\n\tchar *escaped = NULL;\n\n\tif (sym->type == S_UNKNOWN)\n\t\treturn;\n\n\tval = sym_get_string_value(sym);\n\n\tswitch (sym->type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tswitch (*val) {\n\t\tcase 'n':\n\t\t\treturn;\n\t\tcase 'm':\n\t\t\tsym_suffix = \"_MODULE\";\n\t\t\t \n\t\tdefault:\n\t\t\tval = \"1\";\n\t\t}\n\t\tbreak;\n\tcase S_HEX:\n\t\tif (val[0] != '0' || (val[1] != 'x' && val[1] != 'X'))\n\t\t\tval_prefix = \"0x\";\n\t\tbreak;\n\tcase S_STRING:\n\t\tescaped = escape_string_value(val);\n\t\tval = escaped;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfprintf(fp, \"#define %s%s%s %s%s\\n\", CONFIG_, sym->name, sym_suffix,\n\t\tval_prefix, val);\n\n\tfree(escaped);\n}\n\nstatic void print_symbol_for_rustccfg(FILE *fp, struct symbol *sym)\n{\n\tconst char *val;\n\tconst char *val_prefix = \"\";\n\tchar *val_prefixed = NULL;\n\tsize_t val_prefixed_len;\n\tchar *escaped = NULL;\n\n\tif (sym->type == S_UNKNOWN)\n\t\treturn;\n\n\tval = sym_get_string_value(sym);\n\n\tswitch (sym->type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\t \n\t\tif (*val == 'n')\n\t\t\treturn;\n\n\t\t \n\t\tfprintf(fp, \"--cfg=%s%s\\n\", CONFIG_, sym->name);\n\t\tbreak;\n\tcase S_HEX:\n\t\tif (val[0] != '0' || (val[1] != 'x' && val[1] != 'X'))\n\t\t\tval_prefix = \"0x\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (strlen(val_prefix) > 0) {\n\t\tval_prefixed_len = strlen(val) + strlen(val_prefix) + 1;\n\t\tval_prefixed = xmalloc(val_prefixed_len);\n\t\tsnprintf(val_prefixed, val_prefixed_len, \"%s%s\", val_prefix, val);\n\t\tval = val_prefixed;\n\t}\n\n\t \n\tescaped = escape_string_value(val);\n\tval = escaped;\n\n\tfprintf(fp, \"--cfg=%s%s=%s\\n\", CONFIG_, sym->name, val);\n\n\tfree(escaped);\n\tfree(val_prefixed);\n}\n\n \nint conf_write_defconfig(const char *filename)\n{\n\tstruct symbol *sym;\n\tstruct menu *menu;\n\tFILE *out;\n\n\tout = fopen(filename, \"w\");\n\tif (!out)\n\t\treturn 1;\n\n\tsym_clear_all_valid();\n\n\t \n\tmenu = rootmenu.list;\n\n\twhile (menu != NULL)\n\t{\n\t\tsym = menu->sym;\n\t\tif (sym == NULL) {\n\t\t\tif (!menu_is_visible(menu))\n\t\t\t\tgoto next_menu;\n\t\t} else if (!sym_is_choice(sym)) {\n\t\t\tsym_calc_value(sym);\n\t\t\tif (!(sym->flags & SYMBOL_WRITE))\n\t\t\t\tgoto next_menu;\n\t\t\tsym->flags &= ~SYMBOL_WRITE;\n\t\t\t \n\t\t\tif (!sym_is_changeable(sym))\n\t\t\t\tgoto next_menu;\n\t\t\t \n\t\t\tif (strcmp(sym_get_string_value(sym), sym_get_string_default(sym)) == 0)\n\t\t\t\tgoto next_menu;\n\n\t\t\t \n\t\t\tif (sym_is_choice_value(sym)) {\n\t\t\t\tstruct symbol *cs;\n\t\t\t\tstruct symbol *ds;\n\n\t\t\t\tcs = prop_get_symbol(sym_get_choice_prop(sym));\n\t\t\t\tds = sym_choice_default(cs);\n\t\t\t\tif (!sym_is_optional(cs) && sym == ds) {\n\t\t\t\t\tif ((sym->type == S_BOOLEAN) &&\n\t\t\t\t\t    sym_get_tristate_value(sym) == yes)\n\t\t\t\t\t\tgoto next_menu;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprint_symbol_for_dotconfig(out, sym);\n\t\t}\nnext_menu:\n\t\tif (menu->list != NULL) {\n\t\t\tmenu = menu->list;\n\t\t}\n\t\telse if (menu->next != NULL) {\n\t\t\tmenu = menu->next;\n\t\t} else {\n\t\t\twhile ((menu = menu->parent)) {\n\t\t\t\tif (menu->next != NULL) {\n\t\t\t\t\tmenu = menu->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(out);\n\treturn 0;\n}\n\nint conf_write(const char *name)\n{\n\tFILE *out;\n\tstruct symbol *sym;\n\tstruct menu *menu;\n\tconst char *str;\n\tchar tmpname[PATH_MAX + 1], oldname[PATH_MAX + 1];\n\tchar *env;\n\tint i;\n\tbool need_newline = false;\n\n\tif (!name)\n\t\tname = conf_get_configname();\n\n\tif (!*name) {\n\t\tfprintf(stderr, \"config name is empty\\n\");\n\t\treturn -1;\n\t}\n\n\tif (is_dir(name)) {\n\t\tfprintf(stderr, \"%s: Is a directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (make_parent_dir(name))\n\t\treturn -1;\n\n\tenv = getenv(\"KCONFIG_OVERWRITECONFIG\");\n\tif (env && *env) {\n\t\t*tmpname = 0;\n\t\tout = fopen(name, \"w\");\n\t} else {\n\t\tsnprintf(tmpname, sizeof(tmpname), \"%s.%d.tmp\",\n\t\t\t name, (int)getpid());\n\t\tout = fopen(tmpname, \"w\");\n\t}\n\tif (!out)\n\t\treturn 1;\n\n\tconf_write_heading(out, &comment_style_pound);\n\n\tif (!conf_get_changed())\n\t\tsym_clear_all_valid();\n\n\tmenu = rootmenu.list;\n\twhile (menu) {\n\t\tsym = menu->sym;\n\t\tif (!sym) {\n\t\t\tif (!menu_is_visible(menu))\n\t\t\t\tgoto next;\n\t\t\tstr = menu_get_prompt(menu);\n\t\t\tfprintf(out, \"\\n\"\n\t\t\t\t     \"#\\n\"\n\t\t\t\t     \"# %s\\n\"\n\t\t\t\t     \"#\\n\", str);\n\t\t\tneed_newline = false;\n\t\t} else if (!(sym->flags & SYMBOL_CHOICE) &&\n\t\t\t   !(sym->flags & SYMBOL_WRITTEN)) {\n\t\t\tsym_calc_value(sym);\n\t\t\tif (!(sym->flags & SYMBOL_WRITE))\n\t\t\t\tgoto next;\n\t\t\tif (need_newline) {\n\t\t\t\tfprintf(out, \"\\n\");\n\t\t\t\tneed_newline = false;\n\t\t\t}\n\t\t\tsym->flags |= SYMBOL_WRITTEN;\n\t\t\tprint_symbol_for_dotconfig(out, sym);\n\t\t}\n\nnext:\n\t\tif (menu->list) {\n\t\t\tmenu = menu->list;\n\t\t\tcontinue;\n\t\t}\n\nend_check:\n\t\tif (!menu->sym && menu_is_visible(menu) && menu != &rootmenu &&\n\t\t    menu->prompt->type == P_MENU) {\n\t\t\tfprintf(out, \"# end of %s\\n\", menu_get_prompt(menu));\n\t\t\tneed_newline = true;\n\t\t}\n\n\t\tif (menu->next) {\n\t\t\tmenu = menu->next;\n\t\t} else {\n\t\t\tmenu = menu->parent;\n\t\t\tif (menu)\n\t\t\t\tgoto end_check;\n\t\t}\n\t}\n\tfclose(out);\n\n\tfor_all_symbols(i, sym)\n\t\tsym->flags &= ~SYMBOL_WRITTEN;\n\n\tif (*tmpname) {\n\t\tif (is_same(name, tmpname)) {\n\t\t\tconf_message(\"No change to %s\", name);\n\t\t\tunlink(tmpname);\n\t\t\tconf_set_changed(false);\n\t\t\treturn 0;\n\t\t}\n\n\t\tsnprintf(oldname, sizeof(oldname), \"%s.old\", name);\n\t\trename(name, oldname);\n\t\tif (rename(tmpname, name))\n\t\t\treturn 1;\n\t}\n\n\tconf_message(\"configuration written to %s\", name);\n\n\tconf_set_changed(false);\n\n\treturn 0;\n}\n\n \nstatic int conf_write_autoconf_cmd(const char *autoconf_name)\n{\n\tchar name[PATH_MAX], tmp[PATH_MAX];\n\tstruct file *file;\n\tFILE *out;\n\tint ret;\n\n\tret = snprintf(name, sizeof(name), \"%s.cmd\", autoconf_name);\n\tif (ret >= sizeof(name))  \n\t\treturn -1;\n\n\tif (make_parent_dir(name))\n\t\treturn -1;\n\n\tret = snprintf(tmp, sizeof(tmp), \"%s.cmd.tmp\", autoconf_name);\n\tif (ret >= sizeof(tmp))  \n\t\treturn -1;\n\n\tout = fopen(tmp, \"w\");\n\tif (!out) {\n\t\tperror(\"fopen\");\n\t\treturn -1;\n\t}\n\n\tfprintf(out, \"deps_config := \\\\\\n\");\n\tfor (file = file_list; file; file = file->next)\n\t\tfprintf(out, \"\\t%s \\\\\\n\", file->name);\n\n\tfprintf(out, \"\\n%s: $(deps_config)\\n\\n\", autoconf_name);\n\n\tenv_write_dep(out, autoconf_name);\n\n\tfprintf(out, \"\\n$(deps_config): ;\\n\");\n\n\tfflush(out);\n\tret = ferror(out);  \n\tfclose(out);\n\tif (ret)\n\t\treturn -1;\n\n\tif (rename(tmp, name)) {\n\t\tperror(\"rename\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int conf_touch_deps(void)\n{\n\tconst char *name, *tmp;\n\tstruct symbol *sym;\n\tint res, i;\n\n\tname = conf_get_autoconfig_name();\n\ttmp = strrchr(name, '/');\n\tdepfile_prefix_len = tmp ? tmp - name + 1 : 0;\n\tif (depfile_prefix_len + 1 > sizeof(depfile_path))\n\t\treturn -1;\n\n\tstrncpy(depfile_path, name, depfile_prefix_len);\n\tdepfile_path[depfile_prefix_len] = 0;\n\n\tconf_read_simple(name, S_DEF_AUTO);\n\tsym_calc_value(modules_sym);\n\n\tfor_all_symbols(i, sym) {\n\t\tsym_calc_value(sym);\n\t\tif ((sym->flags & SYMBOL_NO_WRITE) || !sym->name)\n\t\t\tcontinue;\n\t\tif (sym->flags & SYMBOL_WRITE) {\n\t\t\tif (sym->flags & SYMBOL_DEF_AUTO) {\n\t\t\t\t \n\t\t\t\tswitch (sym->type) {\n\t\t\t\tcase S_BOOLEAN:\n\t\t\t\tcase S_TRISTATE:\n\t\t\t\t\tif (sym_get_tristate_value(sym) ==\n\t\t\t\t\t    sym->def[S_DEF_AUTO].tri)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_STRING:\n\t\t\t\tcase S_HEX:\n\t\t\t\tcase S_INT:\n\t\t\t\t\tif (!strcmp(sym_get_string_value(sym),\n\t\t\t\t\t\t    sym->def[S_DEF_AUTO].val))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tswitch (sym->type) {\n\t\t\t\tcase S_BOOLEAN:\n\t\t\t\tcase S_TRISTATE:\n\t\t\t\t\tif (sym_get_tristate_value(sym) == no)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!(sym->flags & SYMBOL_DEF_AUTO))\n\t\t\t \n\t\t\tcontinue;\n\t\t \n\n\t\tres = conf_touch_dep(sym->name);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic int __conf_write_autoconf(const char *filename,\n\t\t\t\t void (*print_symbol)(FILE *, struct symbol *),\n\t\t\t\t const struct comment_style *comment_style)\n{\n\tchar tmp[PATH_MAX];\n\tFILE *file;\n\tstruct symbol *sym;\n\tint ret, i;\n\n\tif (make_parent_dir(filename))\n\t\treturn -1;\n\n\tret = snprintf(tmp, sizeof(tmp), \"%s.tmp\", filename);\n\tif (ret >= sizeof(tmp))  \n\t\treturn -1;\n\n\tfile = fopen(tmp, \"w\");\n\tif (!file) {\n\t\tperror(\"fopen\");\n\t\treturn -1;\n\t}\n\n\tconf_write_heading(file, comment_style);\n\n\tfor_all_symbols(i, sym)\n\t\tif ((sym->flags & SYMBOL_WRITE) && sym->name)\n\t\t\tprint_symbol(file, sym);\n\n\tfflush(file);\n\t \n\tret = ferror(file);\n\tfclose(file);\n\tif (ret)\n\t\treturn -1;\n\n\tif (rename(tmp, filename)) {\n\t\tperror(\"rename\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint conf_write_autoconf(int overwrite)\n{\n\tstruct symbol *sym;\n\tconst char *autoconf_name = conf_get_autoconfig_name();\n\tint ret, i;\n\n\tif (!overwrite && is_present(autoconf_name))\n\t\treturn 0;\n\n\tret = conf_write_autoconf_cmd(autoconf_name);\n\tif (ret)\n\t\treturn -1;\n\n\tif (conf_touch_deps())\n\t\treturn 1;\n\n\tfor_all_symbols(i, sym)\n\t\tsym_calc_value(sym);\n\n\tret = __conf_write_autoconf(conf_get_autoheader_name(),\n\t\t\t\t    print_symbol_for_c,\n\t\t\t\t    &comment_style_c);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __conf_write_autoconf(conf_get_rustccfg_name(),\n\t\t\t\t    print_symbol_for_rustccfg,\n\t\t\t\t    NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __conf_write_autoconf(conf_get_autoconfig_name(),\n\t\t\t\t    print_symbol_for_autoconf,\n\t\t\t\t    &comment_style_pound);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic bool conf_changed;\nstatic void (*conf_changed_callback)(void);\n\nvoid conf_set_changed(bool val)\n{\n\tbool changed = conf_changed != val;\n\n\tconf_changed = val;\n\n\tif (conf_changed_callback && changed)\n\t\tconf_changed_callback();\n}\n\nbool conf_get_changed(void)\n{\n\treturn conf_changed;\n}\n\nvoid conf_set_changed_callback(void (*fn)(void))\n{\n\tconf_changed_callback = fn;\n}\n\nvoid set_all_choice_values(struct symbol *csym)\n{\n\tstruct property *prop;\n\tstruct symbol *sym;\n\tstruct expr *e;\n\n\tprop = sym_get_choice_prop(csym);\n\n\t \n\texpr_list_for_each_sym(prop->expr, e, sym) {\n\t\tif (!sym_has_value(sym))\n\t\t\tsym->def[S_DEF_USER].tri = no;\n\t}\n\tcsym->flags |= SYMBOL_DEF_USER;\n\t \n\tcsym->flags &= ~(SYMBOL_VALID | SYMBOL_NEED_SET_CHOICE_VALUES);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}