{
  "module_name": "symbol.c",
  "hash_id": "fd4ca76933aaed640cb81447d41897db834726cf809efabcedd80576747bc586",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/symbol.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <regex.h>\n\n#include \"lkc.h\"\n\nstruct symbol symbol_yes = {\n\t.name = \"y\",\n\t.curr = { \"y\", yes },\n\t.flags = SYMBOL_CONST|SYMBOL_VALID,\n};\n\nstruct symbol symbol_mod = {\n\t.name = \"m\",\n\t.curr = { \"m\", mod },\n\t.flags = SYMBOL_CONST|SYMBOL_VALID,\n};\n\nstruct symbol symbol_no = {\n\t.name = \"n\",\n\t.curr = { \"n\", no },\n\t.flags = SYMBOL_CONST|SYMBOL_VALID,\n};\n\nstatic struct symbol symbol_empty = {\n\t.name = \"\",\n\t.curr = { \"\", no },\n\t.flags = SYMBOL_VALID,\n};\n\nstruct symbol *modules_sym;\nstatic tristate modules_val;\n\nenum symbol_type sym_get_type(struct symbol *sym)\n{\n\tenum symbol_type type = sym->type;\n\n\tif (type == S_TRISTATE) {\n\t\tif (sym_is_choice_value(sym) && sym->visible == yes)\n\t\t\ttype = S_BOOLEAN;\n\t\telse if (modules_val == no)\n\t\t\ttype = S_BOOLEAN;\n\t}\n\treturn type;\n}\n\nconst char *sym_type_name(enum symbol_type type)\n{\n\tswitch (type) {\n\tcase S_BOOLEAN:\n\t\treturn \"bool\";\n\tcase S_TRISTATE:\n\t\treturn \"tristate\";\n\tcase S_INT:\n\t\treturn \"integer\";\n\tcase S_HEX:\n\t\treturn \"hex\";\n\tcase S_STRING:\n\t\treturn \"string\";\n\tcase S_UNKNOWN:\n\t\treturn \"unknown\";\n\t}\n\treturn \"???\";\n}\n\nstruct property *sym_get_choice_prop(struct symbol *sym)\n{\n\tstruct property *prop;\n\n\tfor_all_choices(sym, prop)\n\t\treturn prop;\n\treturn NULL;\n}\n\nstatic struct property *sym_get_default_prop(struct symbol *sym)\n{\n\tstruct property *prop;\n\n\tfor_all_defaults(sym, prop) {\n\t\tprop->visible.tri = expr_calc_value(prop->visible.expr);\n\t\tif (prop->visible.tri != no)\n\t\t\treturn prop;\n\t}\n\treturn NULL;\n}\n\nstruct property *sym_get_range_prop(struct symbol *sym)\n{\n\tstruct property *prop;\n\n\tfor_all_properties(sym, prop, P_RANGE) {\n\t\tprop->visible.tri = expr_calc_value(prop->visible.expr);\n\t\tif (prop->visible.tri != no)\n\t\t\treturn prop;\n\t}\n\treturn NULL;\n}\n\nstatic long long sym_get_range_val(struct symbol *sym, int base)\n{\n\tsym_calc_value(sym);\n\tswitch (sym->type) {\n\tcase S_INT:\n\t\tbase = 10;\n\t\tbreak;\n\tcase S_HEX:\n\t\tbase = 16;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn strtoll(sym->curr.val, NULL, base);\n}\n\nstatic void sym_validate_range(struct symbol *sym)\n{\n\tstruct property *prop;\n\tstruct symbol *range_sym;\n\tint base;\n\tlong long val, val2;\n\n\tswitch (sym->type) {\n\tcase S_INT:\n\t\tbase = 10;\n\t\tbreak;\n\tcase S_HEX:\n\t\tbase = 16;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tprop = sym_get_range_prop(sym);\n\tif (!prop)\n\t\treturn;\n\tval = strtoll(sym->curr.val, NULL, base);\n\trange_sym = prop->expr->left.sym;\n\tval2 = sym_get_range_val(range_sym, base);\n\tif (val >= val2) {\n\t\trange_sym = prop->expr->right.sym;\n\t\tval2 = sym_get_range_val(range_sym, base);\n\t\tif (val <= val2)\n\t\t\treturn;\n\t}\n\tsym->curr.val = range_sym->curr.val;\n}\n\nstatic void sym_set_changed(struct symbol *sym)\n{\n\tstruct property *prop;\n\n\tsym->flags |= SYMBOL_CHANGED;\n\tfor (prop = sym->prop; prop; prop = prop->next) {\n\t\tif (prop->menu)\n\t\t\tprop->menu->flags |= MENU_CHANGED;\n\t}\n}\n\nstatic void sym_set_all_changed(void)\n{\n\tstruct symbol *sym;\n\tint i;\n\n\tfor_all_symbols(i, sym)\n\t\tsym_set_changed(sym);\n}\n\nstatic void sym_calc_visibility(struct symbol *sym)\n{\n\tstruct property *prop;\n\tstruct symbol *choice_sym = NULL;\n\ttristate tri;\n\n\t \n\ttri = no;\n\n\tif (sym_is_choice_value(sym))\n\t\tchoice_sym = prop_get_symbol(sym_get_choice_prop(sym));\n\n\tfor_all_prompts(sym, prop) {\n\t\tprop->visible.tri = expr_calc_value(prop->visible.expr);\n\t\t \n\t\tif (choice_sym && sym->type == S_TRISTATE &&\n\t\t    prop->visible.tri == mod && choice_sym->curr.tri == yes)\n\t\t\tprop->visible.tri = no;\n\n\t\ttri = EXPR_OR(tri, prop->visible.tri);\n\t}\n\tif (tri == mod && (sym->type != S_TRISTATE || modules_val == no))\n\t\ttri = yes;\n\tif (sym->visible != tri) {\n\t\tsym->visible = tri;\n\t\tsym_set_changed(sym);\n\t}\n\tif (sym_is_choice_value(sym))\n\t\treturn;\n\t \n\ttri = yes;\n\tif (sym->dir_dep.expr)\n\t\ttri = expr_calc_value(sym->dir_dep.expr);\n\tif (tri == mod && sym_get_type(sym) == S_BOOLEAN)\n\t\ttri = yes;\n\tif (sym->dir_dep.tri != tri) {\n\t\tsym->dir_dep.tri = tri;\n\t\tsym_set_changed(sym);\n\t}\n\ttri = no;\n\tif (sym->rev_dep.expr)\n\t\ttri = expr_calc_value(sym->rev_dep.expr);\n\tif (tri == mod && sym_get_type(sym) == S_BOOLEAN)\n\t\ttri = yes;\n\tif (sym->rev_dep.tri != tri) {\n\t\tsym->rev_dep.tri = tri;\n\t\tsym_set_changed(sym);\n\t}\n\ttri = no;\n\tif (sym->implied.expr)\n\t\ttri = expr_calc_value(sym->implied.expr);\n\tif (tri == mod && sym_get_type(sym) == S_BOOLEAN)\n\t\ttri = yes;\n\tif (sym->implied.tri != tri) {\n\t\tsym->implied.tri = tri;\n\t\tsym_set_changed(sym);\n\t}\n}\n\n \nstruct symbol *sym_choice_default(struct symbol *sym)\n{\n\tstruct symbol *def_sym;\n\tstruct property *prop;\n\tstruct expr *e;\n\n\t \n\tfor_all_defaults(sym, prop) {\n\t\tprop->visible.tri = expr_calc_value(prop->visible.expr);\n\t\tif (prop->visible.tri == no)\n\t\t\tcontinue;\n\t\tdef_sym = prop_get_symbol(prop);\n\t\tif (def_sym->visible != no)\n\t\t\treturn def_sym;\n\t}\n\n\t \n\tprop = sym_get_choice_prop(sym);\n\texpr_list_for_each_sym(prop->expr, e, def_sym)\n\t\tif (def_sym->visible != no)\n\t\t\treturn def_sym;\n\n\t \n\treturn NULL;\n}\n\nstatic struct symbol *sym_calc_choice(struct symbol *sym)\n{\n\tstruct symbol *def_sym;\n\tstruct property *prop;\n\tstruct expr *e;\n\tint flags;\n\n\t \n\tflags = sym->flags;\n\tprop = sym_get_choice_prop(sym);\n\texpr_list_for_each_sym(prop->expr, e, def_sym) {\n\t\tsym_calc_visibility(def_sym);\n\t\tif (def_sym->visible != no)\n\t\t\tflags &= def_sym->flags;\n\t}\n\n\tsym->flags &= flags | ~SYMBOL_DEF_USER;\n\n\t \n\tdef_sym = sym->def[S_DEF_USER].val;\n\tif (def_sym && def_sym->visible != no)\n\t\treturn def_sym;\n\n\tdef_sym = sym_choice_default(sym);\n\n\tif (def_sym == NULL)\n\t\t \n\t\tsym->curr.tri = no;\n\n\treturn def_sym;\n}\n\nstatic void sym_warn_unmet_dep(struct symbol *sym)\n{\n\tstruct gstr gs = str_new();\n\n\tstr_printf(&gs,\n\t\t   \"\\nWARNING: unmet direct dependencies detected for %s\\n\",\n\t\t   sym->name);\n\tstr_printf(&gs,\n\t\t   \"  Depends on [%c]: \",\n\t\t   sym->dir_dep.tri == mod ? 'm' : 'n');\n\texpr_gstr_print(sym->dir_dep.expr, &gs);\n\tstr_printf(&gs, \"\\n\");\n\n\texpr_gstr_print_revdep(sym->rev_dep.expr, &gs, yes,\n\t\t\t       \"  Selected by [y]:\\n\");\n\texpr_gstr_print_revdep(sym->rev_dep.expr, &gs, mod,\n\t\t\t       \"  Selected by [m]:\\n\");\n\n\tfputs(str_get(&gs), stderr);\n}\n\nvoid sym_calc_value(struct symbol *sym)\n{\n\tstruct symbol_value newval, oldval;\n\tstruct property *prop;\n\tstruct expr *e;\n\n\tif (!sym)\n\t\treturn;\n\n\tif (sym->flags & SYMBOL_VALID)\n\t\treturn;\n\n\tif (sym_is_choice_value(sym) &&\n\t    sym->flags & SYMBOL_NEED_SET_CHOICE_VALUES) {\n\t\tsym->flags &= ~SYMBOL_NEED_SET_CHOICE_VALUES;\n\t\tprop = sym_get_choice_prop(sym);\n\t\tsym_calc_value(prop_get_symbol(prop));\n\t}\n\n\tsym->flags |= SYMBOL_VALID;\n\n\toldval = sym->curr;\n\n\tswitch (sym->type) {\n\tcase S_INT:\n\tcase S_HEX:\n\tcase S_STRING:\n\t\tnewval = symbol_empty.curr;\n\t\tbreak;\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tnewval = symbol_no.curr;\n\t\tbreak;\n\tdefault:\n\t\tsym->curr.val = sym->name;\n\t\tsym->curr.tri = no;\n\t\treturn;\n\t}\n\tsym->flags &= ~SYMBOL_WRITE;\n\n\tsym_calc_visibility(sym);\n\n\tif (sym->visible != no)\n\t\tsym->flags |= SYMBOL_WRITE;\n\n\t \n\tsym->curr = newval;\n\n\tswitch (sym_get_type(sym)) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tif (sym_is_choice_value(sym) && sym->visible == yes) {\n\t\t\tprop = sym_get_choice_prop(sym);\n\t\t\tnewval.tri = (prop_get_symbol(prop)->curr.val == sym) ? yes : no;\n\t\t} else {\n\t\t\tif (sym->visible != no) {\n\t\t\t\t \n\t\t\t\tif (sym_has_value(sym)) {\n\t\t\t\t\tnewval.tri = EXPR_AND(sym->def[S_DEF_USER].tri,\n\t\t\t\t\t\t\t      sym->visible);\n\t\t\t\t\tgoto calc_newval;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sym->rev_dep.tri != no)\n\t\t\t\tsym->flags |= SYMBOL_WRITE;\n\t\t\tif (!sym_is_choice(sym)) {\n\t\t\t\tprop = sym_get_default_prop(sym);\n\t\t\t\tif (prop) {\n\t\t\t\t\tnewval.tri = EXPR_AND(expr_calc_value(prop->expr),\n\t\t\t\t\t\t\t      prop->visible.tri);\n\t\t\t\t\tif (newval.tri != no)\n\t\t\t\t\t\tsym->flags |= SYMBOL_WRITE;\n\t\t\t\t}\n\t\t\t\tif (sym->implied.tri != no) {\n\t\t\t\t\tsym->flags |= SYMBOL_WRITE;\n\t\t\t\t\tnewval.tri = EXPR_OR(newval.tri, sym->implied.tri);\n\t\t\t\t\tnewval.tri = EXPR_AND(newval.tri,\n\t\t\t\t\t\t\t      sym->dir_dep.tri);\n\t\t\t\t}\n\t\t\t}\n\t\tcalc_newval:\n\t\t\tif (sym->dir_dep.tri < sym->rev_dep.tri)\n\t\t\t\tsym_warn_unmet_dep(sym);\n\t\t\tnewval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);\n\t\t}\n\t\tif (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)\n\t\t\tnewval.tri = yes;\n\t\tbreak;\n\tcase S_STRING:\n\tcase S_HEX:\n\tcase S_INT:\n\t\tif (sym->visible != no && sym_has_value(sym)) {\n\t\t\tnewval.val = sym->def[S_DEF_USER].val;\n\t\t\tbreak;\n\t\t}\n\t\tprop = sym_get_default_prop(sym);\n\t\tif (prop) {\n\t\t\tstruct symbol *ds = prop_get_symbol(prop);\n\t\t\tif (ds) {\n\t\t\t\tsym->flags |= SYMBOL_WRITE;\n\t\t\t\tsym_calc_value(ds);\n\t\t\t\tnewval.val = ds->curr.val;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n\n\tsym->curr = newval;\n\tif (sym_is_choice(sym) && newval.tri == yes)\n\t\tsym->curr.val = sym_calc_choice(sym);\n\tsym_validate_range(sym);\n\n\tif (memcmp(&oldval, &sym->curr, sizeof(oldval))) {\n\t\tsym_set_changed(sym);\n\t\tif (modules_sym == sym) {\n\t\t\tsym_set_all_changed();\n\t\t\tmodules_val = modules_sym->curr.tri;\n\t\t}\n\t}\n\n\tif (sym_is_choice(sym)) {\n\t\tstruct symbol *choice_sym;\n\n\t\tprop = sym_get_choice_prop(sym);\n\t\texpr_list_for_each_sym(prop->expr, e, choice_sym) {\n\t\t\tif ((sym->flags & SYMBOL_WRITE) &&\n\t\t\t    choice_sym->visible != no)\n\t\t\t\tchoice_sym->flags |= SYMBOL_WRITE;\n\t\t\tif (sym->flags & SYMBOL_CHANGED)\n\t\t\t\tsym_set_changed(choice_sym);\n\t\t}\n\t}\n\n\tif (sym->flags & SYMBOL_NO_WRITE)\n\t\tsym->flags &= ~SYMBOL_WRITE;\n\n\tif (sym->flags & SYMBOL_NEED_SET_CHOICE_VALUES)\n\t\tset_all_choice_values(sym);\n}\n\nvoid sym_clear_all_valid(void)\n{\n\tstruct symbol *sym;\n\tint i;\n\n\tfor_all_symbols(i, sym)\n\t\tsym->flags &= ~SYMBOL_VALID;\n\tconf_set_changed(true);\n\tsym_calc_value(modules_sym);\n}\n\nbool sym_tristate_within_range(struct symbol *sym, tristate val)\n{\n\tint type = sym_get_type(sym);\n\n\tif (sym->visible == no)\n\t\treturn false;\n\n\tif (type != S_BOOLEAN && type != S_TRISTATE)\n\t\treturn false;\n\n\tif (type == S_BOOLEAN && val == mod)\n\t\treturn false;\n\tif (sym->visible <= sym->rev_dep.tri)\n\t\treturn false;\n\tif (sym_is_choice_value(sym) && sym->visible == yes)\n\t\treturn val == yes;\n\treturn val >= sym->rev_dep.tri && val <= sym->visible;\n}\n\nbool sym_set_tristate_value(struct symbol *sym, tristate val)\n{\n\ttristate oldval = sym_get_tristate_value(sym);\n\n\tif (oldval != val && !sym_tristate_within_range(sym, val))\n\t\treturn false;\n\n\tif (!(sym->flags & SYMBOL_DEF_USER)) {\n\t\tsym->flags |= SYMBOL_DEF_USER;\n\t\tsym_set_changed(sym);\n\t}\n\t \n\tif (sym_is_choice_value(sym) && val == yes) {\n\t\tstruct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));\n\t\tstruct property *prop;\n\t\tstruct expr *e;\n\n\t\tcs->def[S_DEF_USER].val = sym;\n\t\tcs->flags |= SYMBOL_DEF_USER;\n\t\tprop = sym_get_choice_prop(cs);\n\t\tfor (e = prop->expr; e; e = e->left.expr) {\n\t\t\tif (e->right.sym->visible != no)\n\t\t\t\te->right.sym->flags |= SYMBOL_DEF_USER;\n\t\t}\n\t}\n\n\tsym->def[S_DEF_USER].tri = val;\n\tif (oldval != val)\n\t\tsym_clear_all_valid();\n\n\treturn true;\n}\n\ntristate sym_toggle_tristate_value(struct symbol *sym)\n{\n\ttristate oldval, newval;\n\n\toldval = newval = sym_get_tristate_value(sym);\n\tdo {\n\t\tswitch (newval) {\n\t\tcase no:\n\t\t\tnewval = mod;\n\t\t\tbreak;\n\t\tcase mod:\n\t\t\tnewval = yes;\n\t\t\tbreak;\n\t\tcase yes:\n\t\t\tnewval = no;\n\t\t\tbreak;\n\t\t}\n\t\tif (sym_set_tristate_value(sym, newval))\n\t\t\tbreak;\n\t} while (oldval != newval);\n\treturn newval;\n}\n\nbool sym_string_valid(struct symbol *sym, const char *str)\n{\n\tsigned char ch;\n\n\tswitch (sym->type) {\n\tcase S_STRING:\n\t\treturn true;\n\tcase S_INT:\n\t\tch = *str++;\n\t\tif (ch == '-')\n\t\t\tch = *str++;\n\t\tif (!isdigit(ch))\n\t\t\treturn false;\n\t\tif (ch == '0' && *str != 0)\n\t\t\treturn false;\n\t\twhile ((ch = *str++)) {\n\t\t\tif (!isdigit(ch))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\tcase S_HEX:\n\t\tif (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))\n\t\t\tstr += 2;\n\t\tch = *str++;\n\t\tdo {\n\t\t\tif (!isxdigit(ch))\n\t\t\t\treturn false;\n\t\t} while ((ch = *str++));\n\t\treturn true;\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tswitch (str[0]) {\n\t\tcase 'y': case 'Y':\n\t\tcase 'm': case 'M':\n\t\tcase 'n': case 'N':\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nbool sym_string_within_range(struct symbol *sym, const char *str)\n{\n\tstruct property *prop;\n\tlong long val;\n\n\tswitch (sym->type) {\n\tcase S_STRING:\n\t\treturn sym_string_valid(sym, str);\n\tcase S_INT:\n\t\tif (!sym_string_valid(sym, str))\n\t\t\treturn false;\n\t\tprop = sym_get_range_prop(sym);\n\t\tif (!prop)\n\t\t\treturn true;\n\t\tval = strtoll(str, NULL, 10);\n\t\treturn val >= sym_get_range_val(prop->expr->left.sym, 10) &&\n\t\t       val <= sym_get_range_val(prop->expr->right.sym, 10);\n\tcase S_HEX:\n\t\tif (!sym_string_valid(sym, str))\n\t\t\treturn false;\n\t\tprop = sym_get_range_prop(sym);\n\t\tif (!prop)\n\t\t\treturn true;\n\t\tval = strtoll(str, NULL, 16);\n\t\treturn val >= sym_get_range_val(prop->expr->left.sym, 16) &&\n\t\t       val <= sym_get_range_val(prop->expr->right.sym, 16);\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tswitch (str[0]) {\n\t\tcase 'y': case 'Y':\n\t\t\treturn sym_tristate_within_range(sym, yes);\n\t\tcase 'm': case 'M':\n\t\t\treturn sym_tristate_within_range(sym, mod);\n\t\tcase 'n': case 'N':\n\t\t\treturn sym_tristate_within_range(sym, no);\n\t\t}\n\t\treturn false;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nbool sym_set_string_value(struct symbol *sym, const char *newval)\n{\n\tconst char *oldval;\n\tchar *val;\n\tint size;\n\n\tswitch (sym->type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tswitch (newval[0]) {\n\t\tcase 'y': case 'Y':\n\t\t\treturn sym_set_tristate_value(sym, yes);\n\t\tcase 'm': case 'M':\n\t\t\treturn sym_set_tristate_value(sym, mod);\n\t\tcase 'n': case 'N':\n\t\t\treturn sym_set_tristate_value(sym, no);\n\t\t}\n\t\treturn false;\n\tdefault:\n\t\t;\n\t}\n\n\tif (!sym_string_within_range(sym, newval))\n\t\treturn false;\n\n\tif (!(sym->flags & SYMBOL_DEF_USER)) {\n\t\tsym->flags |= SYMBOL_DEF_USER;\n\t\tsym_set_changed(sym);\n\t}\n\n\toldval = sym->def[S_DEF_USER].val;\n\tsize = strlen(newval) + 1;\n\tif (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {\n\t\tsize += 2;\n\t\tsym->def[S_DEF_USER].val = val = xmalloc(size);\n\t\t*val++ = '0';\n\t\t*val++ = 'x';\n\t} else if (!oldval || strcmp(oldval, newval))\n\t\tsym->def[S_DEF_USER].val = val = xmalloc(size);\n\telse\n\t\treturn true;\n\n\tstrcpy(val, newval);\n\tfree((void *)oldval);\n\tsym_clear_all_valid();\n\n\treturn true;\n}\n\n \nconst char *sym_get_string_default(struct symbol *sym)\n{\n\tstruct property *prop;\n\tstruct symbol *ds;\n\tconst char *str;\n\ttristate val;\n\n\tsym_calc_visibility(sym);\n\tsym_calc_value(modules_sym);\n\tval = symbol_no.curr.tri;\n\tstr = symbol_empty.curr.val;\n\n\t \n\tprop = sym_get_default_prop(sym);\n\tif (prop != NULL) {\n\t\tswitch (sym->type) {\n\t\tcase S_BOOLEAN:\n\t\tcase S_TRISTATE:\n\t\t\t \n\t\t\tval = EXPR_AND(expr_calc_value(prop->expr), prop->visible.tri);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tds = prop_get_symbol(prop);\n\t\t\tif (ds != NULL) {\n\t\t\t\tsym_calc_value(ds);\n\t\t\t\tstr = (const char *)ds->curr.val;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tval = EXPR_OR(val, sym->rev_dep.tri);\n\n\t \n\tif (val == mod)\n\t\tif (!sym_is_choice_value(sym) && modules_sym->curr.tri == no)\n\t\t\tval = yes;\n\n\t \n\tif (sym->type == S_BOOLEAN && val == mod)\n\t\tval = yes;\n\n\t \n\tif (val < sym->implied.tri)\n\t\tval = sym->implied.tri;\n\n\tswitch (sym->type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tswitch (val) {\n\t\tcase no: return \"n\";\n\t\tcase mod: return \"m\";\n\t\tcase yes: return \"y\";\n\t\t}\n\tcase S_INT:\n\tcase S_HEX:\n\t\treturn str;\n\tcase S_STRING:\n\t\treturn str;\n\tcase S_UNKNOWN:\n\t\tbreak;\n\t}\n\treturn \"\";\n}\n\nconst char *sym_get_string_value(struct symbol *sym)\n{\n\ttristate val;\n\n\tswitch (sym->type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tval = sym_get_tristate_value(sym);\n\t\tswitch (val) {\n\t\tcase no:\n\t\t\treturn \"n\";\n\t\tcase mod:\n\t\t\tsym_calc_value(modules_sym);\n\t\t\treturn (modules_sym->curr.tri == no) ? \"n\" : \"m\";\n\t\tcase yes:\n\t\t\treturn \"y\";\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n\treturn (const char *)sym->curr.val;\n}\n\nbool sym_is_changeable(struct symbol *sym)\n{\n\treturn sym->visible > sym->rev_dep.tri;\n}\n\nstatic unsigned strhash(const char *s)\n{\n\t \n\tunsigned hash = 2166136261U;\n\tfor (; *s; s++)\n\t\thash = (hash ^ *s) * 0x01000193;\n\treturn hash;\n}\n\nstruct symbol *sym_lookup(const char *name, int flags)\n{\n\tstruct symbol *symbol;\n\tchar *new_name;\n\tint hash;\n\n\tif (name) {\n\t\tif (name[0] && !name[1]) {\n\t\t\tswitch (name[0]) {\n\t\t\tcase 'y': return &symbol_yes;\n\t\t\tcase 'm': return &symbol_mod;\n\t\t\tcase 'n': return &symbol_no;\n\t\t\t}\n\t\t}\n\t\thash = strhash(name) % SYMBOL_HASHSIZE;\n\n\t\tfor (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {\n\t\t\tif (symbol->name &&\n\t\t\t    !strcmp(symbol->name, name) &&\n\t\t\t    (flags ? symbol->flags & flags\n\t\t\t\t   : !(symbol->flags & (SYMBOL_CONST|SYMBOL_CHOICE))))\n\t\t\t\treturn symbol;\n\t\t}\n\t\tnew_name = xstrdup(name);\n\t} else {\n\t\tnew_name = NULL;\n\t\thash = 0;\n\t}\n\n\tsymbol = xmalloc(sizeof(*symbol));\n\tmemset(symbol, 0, sizeof(*symbol));\n\tsymbol->name = new_name;\n\tsymbol->type = S_UNKNOWN;\n\tsymbol->flags = flags;\n\n\tsymbol->next = symbol_hash[hash];\n\tsymbol_hash[hash] = symbol;\n\n\treturn symbol;\n}\n\nstruct symbol *sym_find(const char *name)\n{\n\tstruct symbol *symbol = NULL;\n\tint hash = 0;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tif (name[0] && !name[1]) {\n\t\tswitch (name[0]) {\n\t\tcase 'y': return &symbol_yes;\n\t\tcase 'm': return &symbol_mod;\n\t\tcase 'n': return &symbol_no;\n\t\t}\n\t}\n\thash = strhash(name) % SYMBOL_HASHSIZE;\n\n\tfor (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {\n\t\tif (symbol->name &&\n\t\t    !strcmp(symbol->name, name) &&\n\t\t    !(symbol->flags & SYMBOL_CONST))\n\t\t\t\tbreak;\n\t}\n\n\treturn symbol;\n}\n\nstruct sym_match {\n\tstruct symbol\t*sym;\n\toff_t\t\tso, eo;\n};\n\n \nstatic int sym_rel_comp(const void *sym1, const void *sym2)\n{\n\tconst struct sym_match *s1 = sym1;\n\tconst struct sym_match *s2 = sym2;\n\tint exact1, exact2;\n\n\t \n\texact1 = (s1->eo - s1->so) == strlen(s1->sym->name);\n\texact2 = (s2->eo - s2->so) == strlen(s2->sym->name);\n\tif (exact1 && !exact2)\n\t\treturn -1;\n\tif (!exact1 && exact2)\n\t\treturn 1;\n\n\t \n\treturn strcmp(s1->sym->name, s2->sym->name);\n}\n\nstruct symbol **sym_re_search(const char *pattern)\n{\n\tstruct symbol *sym, **sym_arr = NULL;\n\tstruct sym_match *sym_match_arr = NULL;\n\tint i, cnt, size;\n\tregex_t re;\n\tregmatch_t match[1];\n\n\tcnt = size = 0;\n\t \n\tif (strlen(pattern) == 0)\n\t\treturn NULL;\n\tif (regcomp(&re, pattern, REG_EXTENDED|REG_ICASE))\n\t\treturn NULL;\n\n\tfor_all_symbols(i, sym) {\n\t\tif (sym->flags & SYMBOL_CONST || !sym->name)\n\t\t\tcontinue;\n\t\tif (regexec(&re, sym->name, 1, match, 0))\n\t\t\tcontinue;\n\t\tif (cnt >= size) {\n\t\t\tvoid *tmp;\n\t\t\tsize += 16;\n\t\t\ttmp = realloc(sym_match_arr, size * sizeof(struct sym_match));\n\t\t\tif (!tmp)\n\t\t\t\tgoto sym_re_search_free;\n\t\t\tsym_match_arr = tmp;\n\t\t}\n\t\tsym_calc_value(sym);\n\t\t \n\t\tsym_match_arr[cnt].so = match[0].rm_so;\n\t\tsym_match_arr[cnt].eo = match[0].rm_eo;\n\t\tsym_match_arr[cnt++].sym = sym;\n\t}\n\tif (sym_match_arr) {\n\t\tqsort(sym_match_arr, cnt, sizeof(struct sym_match), sym_rel_comp);\n\t\tsym_arr = malloc((cnt+1) * sizeof(struct symbol *));\n\t\tif (!sym_arr)\n\t\t\tgoto sym_re_search_free;\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tsym_arr[i] = sym_match_arr[i].sym;\n\t\tsym_arr[cnt] = NULL;\n\t}\nsym_re_search_free:\n\t \n\tfree(sym_match_arr);\n\tregfree(&re);\n\n\treturn sym_arr;\n}\n\n \nstatic struct dep_stack {\n\tstruct dep_stack *prev, *next;\n\tstruct symbol *sym;\n\tstruct property *prop;\n\tstruct expr **expr;\n} *check_top;\n\nstatic void dep_stack_insert(struct dep_stack *stack, struct symbol *sym)\n{\n\tmemset(stack, 0, sizeof(*stack));\n\tif (check_top)\n\t\tcheck_top->next = stack;\n\tstack->prev = check_top;\n\tstack->sym = sym;\n\tcheck_top = stack;\n}\n\nstatic void dep_stack_remove(void)\n{\n\tcheck_top = check_top->prev;\n\tif (check_top)\n\t\tcheck_top->next = NULL;\n}\n\n \nstatic void sym_check_print_recursive(struct symbol *last_sym)\n{\n\tstruct dep_stack *stack;\n\tstruct symbol *sym, *next_sym;\n\tstruct menu *menu = NULL;\n\tstruct property *prop;\n\tstruct dep_stack cv_stack;\n\n\tif (sym_is_choice_value(last_sym)) {\n\t\tdep_stack_insert(&cv_stack, last_sym);\n\t\tlast_sym = prop_get_symbol(sym_get_choice_prop(last_sym));\n\t}\n\n\tfor (stack = check_top; stack != NULL; stack = stack->prev)\n\t\tif (stack->sym == last_sym)\n\t\t\tbreak;\n\tif (!stack) {\n\t\tfprintf(stderr, \"unexpected recursive dependency error\\n\");\n\t\treturn;\n\t}\n\n\tfor (; stack; stack = stack->next) {\n\t\tsym = stack->sym;\n\t\tnext_sym = stack->next ? stack->next->sym : last_sym;\n\t\tprop = stack->prop;\n\t\tif (prop == NULL)\n\t\t\tprop = stack->sym->prop;\n\n\t\t \n\t\tif (sym_is_choice(sym) || sym_is_choice_value(sym)) {\n\t\t\tfor (prop = sym->prop; prop; prop = prop->next) {\n\t\t\t\tmenu = prop->menu;\n\t\t\t\tif (prop->menu)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (stack->sym == last_sym)\n\t\t\tfprintf(stderr, \"%s:%d:error: recursive dependency detected!\\n\",\n\t\t\t\tprop->file->name, prop->lineno);\n\n\t\tif (sym_is_choice(sym)) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tchoice %s contains symbol %s\\n\",\n\t\t\t\tmenu->file->name, menu->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else if (sym_is_choice_value(sym)) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s is part of choice %s\\n\",\n\t\t\t\tmenu->file->name, menu->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else if (stack->expr == &sym->dir_dep.expr) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s depends on %s\\n\",\n\t\t\t\tprop->file->name, prop->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else if (stack->expr == &sym->rev_dep.expr) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s is selected by %s\\n\",\n\t\t\t\tprop->file->name, prop->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else if (stack->expr == &sym->implied.expr) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s is implied by %s\\n\",\n\t\t\t\tprop->file->name, prop->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else if (stack->expr) {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s %s value contains %s\\n\",\n\t\t\t\tprop->file->name, prop->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tprop_get_type_name(prop->type),\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"%s:%d:\\tsymbol %s %s is visible depending on %s\\n\",\n\t\t\t\tprop->file->name, prop->lineno,\n\t\t\t\tsym->name ? sym->name : \"<choice>\",\n\t\t\t\tprop_get_type_name(prop->type),\n\t\t\t\tnext_sym->name ? next_sym->name : \"<choice>\");\n\t\t}\n\t}\n\n\tfprintf(stderr,\n\t\t\"For a resolution refer to Documentation/kbuild/kconfig-language.rst\\n\"\n\t\t\"subsection \\\"Kconfig recursive dependency limitations\\\"\\n\"\n\t\t\"\\n\");\n\n\tif (check_top == &cv_stack)\n\t\tdep_stack_remove();\n}\n\nstatic struct symbol *sym_check_expr_deps(struct expr *e)\n{\n\tstruct symbol *sym;\n\n\tif (!e)\n\t\treturn NULL;\n\tswitch (e->type) {\n\tcase E_OR:\n\tcase E_AND:\n\t\tsym = sym_check_expr_deps(e->left.expr);\n\t\tif (sym)\n\t\t\treturn sym;\n\t\treturn sym_check_expr_deps(e->right.expr);\n\tcase E_NOT:\n\t\treturn sym_check_expr_deps(e->left.expr);\n\tcase E_EQUAL:\n\tcase E_GEQ:\n\tcase E_GTH:\n\tcase E_LEQ:\n\tcase E_LTH:\n\tcase E_UNEQUAL:\n\t\tsym = sym_check_deps(e->left.sym);\n\t\tif (sym)\n\t\t\treturn sym;\n\t\treturn sym_check_deps(e->right.sym);\n\tcase E_SYMBOL:\n\t\treturn sym_check_deps(e->left.sym);\n\tdefault:\n\t\tbreak;\n\t}\n\tfprintf(stderr, \"Oops! How to check %d?\\n\", e->type);\n\treturn NULL;\n}\n\n \nstatic struct symbol *sym_check_sym_deps(struct symbol *sym)\n{\n\tstruct symbol *sym2;\n\tstruct property *prop;\n\tstruct dep_stack stack;\n\n\tdep_stack_insert(&stack, sym);\n\n\tstack.expr = &sym->dir_dep.expr;\n\tsym2 = sym_check_expr_deps(sym->dir_dep.expr);\n\tif (sym2)\n\t\tgoto out;\n\n\tstack.expr = &sym->rev_dep.expr;\n\tsym2 = sym_check_expr_deps(sym->rev_dep.expr);\n\tif (sym2)\n\t\tgoto out;\n\n\tstack.expr = &sym->implied.expr;\n\tsym2 = sym_check_expr_deps(sym->implied.expr);\n\tif (sym2)\n\t\tgoto out;\n\n\tstack.expr = NULL;\n\n\tfor (prop = sym->prop; prop; prop = prop->next) {\n\t\tif (prop->type == P_CHOICE || prop->type == P_SELECT ||\n\t\t    prop->type == P_IMPLY)\n\t\t\tcontinue;\n\t\tstack.prop = prop;\n\t\tsym2 = sym_check_expr_deps(prop->visible.expr);\n\t\tif (sym2)\n\t\t\tbreak;\n\t\tif (prop->type != P_DEFAULT || sym_is_choice(sym))\n\t\t\tcontinue;\n\t\tstack.expr = &prop->expr;\n\t\tsym2 = sym_check_expr_deps(prop->expr);\n\t\tif (sym2)\n\t\t\tbreak;\n\t\tstack.expr = NULL;\n\t}\n\nout:\n\tdep_stack_remove();\n\n\treturn sym2;\n}\n\nstatic struct symbol *sym_check_choice_deps(struct symbol *choice)\n{\n\tstruct symbol *sym, *sym2;\n\tstruct property *prop;\n\tstruct expr *e;\n\tstruct dep_stack stack;\n\n\tdep_stack_insert(&stack, choice);\n\n\tprop = sym_get_choice_prop(choice);\n\texpr_list_for_each_sym(prop->expr, e, sym)\n\t\tsym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);\n\n\tchoice->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);\n\tsym2 = sym_check_sym_deps(choice);\n\tchoice->flags &= ~SYMBOL_CHECK;\n\tif (sym2)\n\t\tgoto out;\n\n\texpr_list_for_each_sym(prop->expr, e, sym) {\n\t\tsym2 = sym_check_sym_deps(sym);\n\t\tif (sym2)\n\t\t\tbreak;\n\t}\nout:\n\texpr_list_for_each_sym(prop->expr, e, sym)\n\t\tsym->flags &= ~SYMBOL_CHECK;\n\n\tif (sym2 && sym_is_choice_value(sym2) &&\n\t    prop_get_symbol(sym_get_choice_prop(sym2)) == choice)\n\t\tsym2 = choice;\n\n\tdep_stack_remove();\n\n\treturn sym2;\n}\n\nstruct symbol *sym_check_deps(struct symbol *sym)\n{\n\tstruct symbol *sym2;\n\tstruct property *prop;\n\n\tif (sym->flags & SYMBOL_CHECK) {\n\t\tsym_check_print_recursive(sym);\n\t\treturn sym;\n\t}\n\tif (sym->flags & SYMBOL_CHECKED)\n\t\treturn NULL;\n\n\tif (sym_is_choice_value(sym)) {\n\t\tstruct dep_stack stack;\n\n\t\t \n\t\tdep_stack_insert(&stack, sym);\n\t\tprop = sym_get_choice_prop(sym);\n\t\tsym2 = sym_check_deps(prop_get_symbol(prop));\n\t\tdep_stack_remove();\n\t} else if (sym_is_choice(sym)) {\n\t\tsym2 = sym_check_choice_deps(sym);\n\t} else {\n\t\tsym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);\n\t\tsym2 = sym_check_sym_deps(sym);\n\t\tsym->flags &= ~SYMBOL_CHECK;\n\t}\n\n\treturn sym2;\n}\n\nstruct symbol *prop_get_symbol(struct property *prop)\n{\n\tif (prop->expr && (prop->expr->type == E_SYMBOL ||\n\t\t\t   prop->expr->type == E_LIST))\n\t\treturn prop->expr->left.sym;\n\treturn NULL;\n}\n\nconst char *prop_get_type_name(enum prop_type type)\n{\n\tswitch (type) {\n\tcase P_PROMPT:\n\t\treturn \"prompt\";\n\tcase P_COMMENT:\n\t\treturn \"comment\";\n\tcase P_MENU:\n\t\treturn \"menu\";\n\tcase P_DEFAULT:\n\t\treturn \"default\";\n\tcase P_CHOICE:\n\t\treturn \"choice\";\n\tcase P_SELECT:\n\t\treturn \"select\";\n\tcase P_IMPLY:\n\t\treturn \"imply\";\n\tcase P_RANGE:\n\t\treturn \"range\";\n\tcase P_SYMBOL:\n\t\treturn \"symbol\";\n\tcase P_UNKNOWN:\n\t\tbreak;\n\t}\n\treturn \"unknown\";\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}