{
  "module_name": "util.c",
  "hash_id": "54cbccc1f8495538d1994194bb75397c5755b95dcb695c825d5b5b59998062b1",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/lxdialog/util.c",
  "human_readable_source": "\n \n\n#include <stdarg.h>\n\n#include \"dialog.h\"\n\n \nint saved_x, saved_y;\n\nstruct dialog_info dlg;\n\nstatic void set_mono_theme(void)\n{\n\tdlg.screen.atr = A_NORMAL;\n\tdlg.shadow.atr = A_NORMAL;\n\tdlg.dialog.atr = A_NORMAL;\n\tdlg.title.atr = A_BOLD;\n\tdlg.border.atr = A_NORMAL;\n\tdlg.button_active.atr = A_REVERSE;\n\tdlg.button_inactive.atr = A_DIM;\n\tdlg.button_key_active.atr = A_REVERSE;\n\tdlg.button_key_inactive.atr = A_BOLD;\n\tdlg.button_label_active.atr = A_REVERSE;\n\tdlg.button_label_inactive.atr = A_NORMAL;\n\tdlg.inputbox.atr = A_NORMAL;\n\tdlg.inputbox_border.atr = A_NORMAL;\n\tdlg.searchbox.atr = A_NORMAL;\n\tdlg.searchbox_title.atr = A_BOLD;\n\tdlg.searchbox_border.atr = A_NORMAL;\n\tdlg.position_indicator.atr = A_BOLD;\n\tdlg.menubox.atr = A_NORMAL;\n\tdlg.menubox_border.atr = A_NORMAL;\n\tdlg.item.atr = A_NORMAL;\n\tdlg.item_selected.atr = A_REVERSE;\n\tdlg.tag.atr = A_BOLD;\n\tdlg.tag_selected.atr = A_REVERSE;\n\tdlg.tag_key.atr = A_BOLD;\n\tdlg.tag_key_selected.atr = A_REVERSE;\n\tdlg.check.atr = A_BOLD;\n\tdlg.check_selected.atr = A_REVERSE;\n\tdlg.uarrow.atr = A_BOLD;\n\tdlg.darrow.atr = A_BOLD;\n}\n\n#define DLG_COLOR(dialog, f, b, h) \\\ndo {                               \\\n\tdlg.dialog.fg = (f);       \\\n\tdlg.dialog.bg = (b);       \\\n\tdlg.dialog.hl = (h);       \\\n} while (0)\n\nstatic void set_classic_theme(void)\n{\n\tDLG_COLOR(screen,                COLOR_CYAN,   COLOR_BLUE,   true);\n\tDLG_COLOR(shadow,                COLOR_BLACK,  COLOR_BLACK,  true);\n\tDLG_COLOR(dialog,                COLOR_BLACK,  COLOR_WHITE,  false);\n\tDLG_COLOR(title,                 COLOR_YELLOW, COLOR_WHITE,  true);\n\tDLG_COLOR(border,                COLOR_WHITE,  COLOR_WHITE,  true);\n\tDLG_COLOR(button_active,         COLOR_WHITE,  COLOR_BLUE,   true);\n\tDLG_COLOR(button_inactive,       COLOR_BLACK,  COLOR_WHITE,  false);\n\tDLG_COLOR(button_key_active,     COLOR_WHITE,  COLOR_BLUE,   true);\n\tDLG_COLOR(button_key_inactive,   COLOR_RED,    COLOR_WHITE,  false);\n\tDLG_COLOR(button_label_active,   COLOR_YELLOW, COLOR_BLUE,   true);\n\tDLG_COLOR(button_label_inactive, COLOR_BLACK,  COLOR_WHITE,  true);\n\tDLG_COLOR(inputbox,              COLOR_BLACK,  COLOR_WHITE,  false);\n\tDLG_COLOR(inputbox_border,       COLOR_BLACK,  COLOR_WHITE,  false);\n\tDLG_COLOR(searchbox,             COLOR_BLACK,  COLOR_WHITE,  false);\n\tDLG_COLOR(searchbox_title,       COLOR_YELLOW, COLOR_WHITE,  true);\n\tDLG_COLOR(searchbox_border,      COLOR_WHITE,  COLOR_WHITE,  true);\n\tDLG_COLOR(position_indicator,    COLOR_YELLOW, COLOR_WHITE,  true);\n\tDLG_COLOR(menubox,               COLOR_BLACK,  COLOR_WHITE,  false);\n\tDLG_COLOR(menubox_border,        COLOR_WHITE,  COLOR_WHITE,  true);\n\tDLG_COLOR(item,                  COLOR_BLACK,  COLOR_WHITE,  false);\n\tDLG_COLOR(item_selected,         COLOR_WHITE,  COLOR_BLUE,   true);\n\tDLG_COLOR(tag,                   COLOR_YELLOW, COLOR_WHITE,  true);\n\tDLG_COLOR(tag_selected,          COLOR_YELLOW, COLOR_BLUE,   true);\n\tDLG_COLOR(tag_key,               COLOR_YELLOW, COLOR_WHITE,  true);\n\tDLG_COLOR(tag_key_selected,      COLOR_YELLOW, COLOR_BLUE,   true);\n\tDLG_COLOR(check,                 COLOR_BLACK,  COLOR_WHITE,  false);\n\tDLG_COLOR(check_selected,        COLOR_WHITE,  COLOR_BLUE,   true);\n\tDLG_COLOR(uarrow,                COLOR_GREEN,  COLOR_WHITE,  true);\n\tDLG_COLOR(darrow,                COLOR_GREEN,  COLOR_WHITE,  true);\n}\n\nstatic void set_blackbg_theme(void)\n{\n\tDLG_COLOR(screen, COLOR_RED,   COLOR_BLACK, true);\n\tDLG_COLOR(shadow, COLOR_BLACK, COLOR_BLACK, false);\n\tDLG_COLOR(dialog, COLOR_WHITE, COLOR_BLACK, false);\n\tDLG_COLOR(title,  COLOR_RED,   COLOR_BLACK, false);\n\tDLG_COLOR(border, COLOR_BLACK, COLOR_BLACK, true);\n\n\tDLG_COLOR(button_active,         COLOR_YELLOW, COLOR_RED,   false);\n\tDLG_COLOR(button_inactive,       COLOR_YELLOW, COLOR_BLACK, false);\n\tDLG_COLOR(button_key_active,     COLOR_YELLOW, COLOR_RED,   true);\n\tDLG_COLOR(button_key_inactive,   COLOR_RED,    COLOR_BLACK, false);\n\tDLG_COLOR(button_label_active,   COLOR_WHITE,  COLOR_RED,   false);\n\tDLG_COLOR(button_label_inactive, COLOR_BLACK,  COLOR_BLACK, true);\n\n\tDLG_COLOR(inputbox,         COLOR_YELLOW, COLOR_BLACK, false);\n\tDLG_COLOR(inputbox_border,  COLOR_YELLOW, COLOR_BLACK, false);\n\n\tDLG_COLOR(searchbox,        COLOR_YELLOW, COLOR_BLACK, false);\n\tDLG_COLOR(searchbox_title,  COLOR_YELLOW, COLOR_BLACK, true);\n\tDLG_COLOR(searchbox_border, COLOR_BLACK,  COLOR_BLACK, true);\n\n\tDLG_COLOR(position_indicator, COLOR_RED, COLOR_BLACK,  false);\n\n\tDLG_COLOR(menubox,          COLOR_YELLOW, COLOR_BLACK, false);\n\tDLG_COLOR(menubox_border,   COLOR_BLACK,  COLOR_BLACK, true);\n\n\tDLG_COLOR(item,             COLOR_WHITE, COLOR_BLACK, false);\n\tDLG_COLOR(item_selected,    COLOR_WHITE, COLOR_RED,   false);\n\n\tDLG_COLOR(tag,              COLOR_RED,    COLOR_BLACK, false);\n\tDLG_COLOR(tag_selected,     COLOR_YELLOW, COLOR_RED,   true);\n\tDLG_COLOR(tag_key,          COLOR_RED,    COLOR_BLACK, false);\n\tDLG_COLOR(tag_key_selected, COLOR_YELLOW, COLOR_RED,   true);\n\n\tDLG_COLOR(check,            COLOR_YELLOW, COLOR_BLACK, false);\n\tDLG_COLOR(check_selected,   COLOR_YELLOW, COLOR_RED,   true);\n\n\tDLG_COLOR(uarrow, COLOR_RED, COLOR_BLACK, false);\n\tDLG_COLOR(darrow, COLOR_RED, COLOR_BLACK, false);\n}\n\nstatic void set_bluetitle_theme(void)\n{\n\tset_classic_theme();\n\tDLG_COLOR(title,               COLOR_BLUE,   COLOR_WHITE, true);\n\tDLG_COLOR(button_key_active,   COLOR_YELLOW, COLOR_BLUE,  true);\n\tDLG_COLOR(button_label_active, COLOR_WHITE,  COLOR_BLUE,  true);\n\tDLG_COLOR(searchbox_title,     COLOR_BLUE,   COLOR_WHITE, true);\n\tDLG_COLOR(position_indicator,  COLOR_BLUE,   COLOR_WHITE, true);\n\tDLG_COLOR(tag,                 COLOR_BLUE,   COLOR_WHITE, true);\n\tDLG_COLOR(tag_key,             COLOR_BLUE,   COLOR_WHITE, true);\n\n}\n\n \nstatic int set_theme(const char *theme)\n{\n\tint use_color = 1;\n\tif (!theme)\n\t\tset_bluetitle_theme();\n\telse if (strcmp(theme, \"classic\") == 0)\n\t\tset_classic_theme();\n\telse if (strcmp(theme, \"bluetitle\") == 0)\n\t\tset_bluetitle_theme();\n\telse if (strcmp(theme, \"blackbg\") == 0)\n\t\tset_blackbg_theme();\n\telse if (strcmp(theme, \"mono\") == 0)\n\t\tuse_color = 0;\n\n\treturn use_color;\n}\n\nstatic void init_one_color(struct dialog_color *color)\n{\n\tstatic int pair = 0;\n\n\tpair++;\n\tinit_pair(pair, color->fg, color->bg);\n\tif (color->hl)\n\t\tcolor->atr = A_BOLD | COLOR_PAIR(pair);\n\telse\n\t\tcolor->atr = COLOR_PAIR(pair);\n}\n\nstatic void init_dialog_colors(void)\n{\n\tinit_one_color(&dlg.screen);\n\tinit_one_color(&dlg.shadow);\n\tinit_one_color(&dlg.dialog);\n\tinit_one_color(&dlg.title);\n\tinit_one_color(&dlg.border);\n\tinit_one_color(&dlg.button_active);\n\tinit_one_color(&dlg.button_inactive);\n\tinit_one_color(&dlg.button_key_active);\n\tinit_one_color(&dlg.button_key_inactive);\n\tinit_one_color(&dlg.button_label_active);\n\tinit_one_color(&dlg.button_label_inactive);\n\tinit_one_color(&dlg.inputbox);\n\tinit_one_color(&dlg.inputbox_border);\n\tinit_one_color(&dlg.searchbox);\n\tinit_one_color(&dlg.searchbox_title);\n\tinit_one_color(&dlg.searchbox_border);\n\tinit_one_color(&dlg.position_indicator);\n\tinit_one_color(&dlg.menubox);\n\tinit_one_color(&dlg.menubox_border);\n\tinit_one_color(&dlg.item);\n\tinit_one_color(&dlg.item_selected);\n\tinit_one_color(&dlg.tag);\n\tinit_one_color(&dlg.tag_selected);\n\tinit_one_color(&dlg.tag_key);\n\tinit_one_color(&dlg.tag_key_selected);\n\tinit_one_color(&dlg.check);\n\tinit_one_color(&dlg.check_selected);\n\tinit_one_color(&dlg.uarrow);\n\tinit_one_color(&dlg.darrow);\n}\n\n \nstatic void color_setup(const char *theme)\n{\n\tint use_color;\n\n\tuse_color = set_theme(theme);\n\tif (use_color && has_colors()) {\n\t\tstart_color();\n\t\tinit_dialog_colors();\n\t} else\n\t\tset_mono_theme();\n}\n\n \nvoid attr_clear(WINDOW * win, int height, int width, chtype attr)\n{\n\tint i, j;\n\n\twattrset(win, attr);\n\tfor (i = 0; i < height; i++) {\n\t\twmove(win, i, 0);\n\t\tfor (j = 0; j < width; j++)\n\t\t\twaddch(win, ' ');\n\t}\n\ttouchwin(win);\n}\n\nvoid dialog_clear(void)\n{\n\tint lines, columns;\n\n\tlines = getmaxy(stdscr);\n\tcolumns = getmaxx(stdscr);\n\n\tattr_clear(stdscr, lines, columns, dlg.screen.atr);\n\t \n\tif (dlg.backtitle != NULL) {\n\t\tint i, len = 0, skip = 0;\n\t\tstruct subtitle_list *pos;\n\n\t\twattrset(stdscr, dlg.screen.atr);\n\t\tmvwaddstr(stdscr, 0, 1, (char *)dlg.backtitle);\n\n\t\tfor (pos = dlg.subtitles; pos != NULL; pos = pos->next) {\n\t\t\t \n\t\t\tlen += strlen(pos->text) + 3;\n\t\t}\n\n\t\twmove(stdscr, 1, 1);\n\t\tif (len > columns - 2) {\n\t\t\tconst char *ellipsis = \"[...] \";\n\t\t\twaddstr(stdscr, ellipsis);\n\t\t\tskip = len - (columns - 2 - strlen(ellipsis));\n\t\t}\n\n\t\tfor (pos = dlg.subtitles; pos != NULL; pos = pos->next) {\n\t\t\tif (skip == 0)\n\t\t\t\twaddch(stdscr, ACS_RARROW);\n\t\t\telse\n\t\t\t\tskip--;\n\n\t\t\tif (skip == 0)\n\t\t\t\twaddch(stdscr, ' ');\n\t\t\telse\n\t\t\t\tskip--;\n\n\t\t\tif (skip < strlen(pos->text)) {\n\t\t\t\twaddstr(stdscr, pos->text + skip);\n\t\t\t\tskip = 0;\n\t\t\t} else\n\t\t\t\tskip -= strlen(pos->text);\n\n\t\t\tif (skip == 0)\n\t\t\t\twaddch(stdscr, ' ');\n\t\t\telse\n\t\t\t\tskip--;\n\t\t}\n\n\t\tfor (i = len + 1; i < columns - 1; i++)\n\t\t\twaddch(stdscr, ACS_HLINE);\n\t}\n\twnoutrefresh(stdscr);\n}\n\n \nint init_dialog(const char *backtitle)\n{\n\tint height, width;\n\n\tinitscr();\t\t \n\n\t \n\tgetyx(stdscr, saved_y, saved_x);\n\n\tgetmaxyx(stdscr, height, width);\n\tif (height < WINDOW_HEIGTH_MIN || width < WINDOW_WIDTH_MIN) {\n\t\tendwin();\n\t\treturn -ERRDISPLAYTOOSMALL;\n\t}\n\n\tdlg.backtitle = backtitle;\n\tcolor_setup(getenv(\"MENUCONFIG_COLOR\"));\n\n\tkeypad(stdscr, TRUE);\n\tcbreak();\n\tnoecho();\n\tdialog_clear();\n\n\treturn 0;\n}\n\nvoid set_dialog_backtitle(const char *backtitle)\n{\n\tdlg.backtitle = backtitle;\n}\n\nvoid set_dialog_subtitles(struct subtitle_list *subtitles)\n{\n\tdlg.subtitles = subtitles;\n}\n\n \nvoid end_dialog(int x, int y)\n{\n\t \n\tmove(y, x);\n\trefresh();\n\tendwin();\n}\n\n \nvoid print_title(WINDOW *dialog, const char *title, int width)\n{\n\tif (title) {\n\t\tint tlen = MIN(width - 2, strlen(title));\n\t\twattrset(dialog, dlg.title.atr);\n\t\tmvwaddch(dialog, 0, (width - tlen) / 2 - 1, ' ');\n\t\tmvwaddnstr(dialog, 0, (width - tlen)/2, title, tlen);\n\t\twaddch(dialog, ' ');\n\t}\n}\n\n \nvoid print_autowrap(WINDOW * win, const char *prompt, int width, int y, int x)\n{\n\tint newl, cur_x, cur_y;\n\tint prompt_len, room, wlen;\n\tchar tempstr[MAX_LEN + 1], *word, *sp, *sp2, *newline_separator = 0;\n\n\tstrcpy(tempstr, prompt);\n\n\tprompt_len = strlen(tempstr);\n\n\tif (prompt_len <= width - x * 2) {\t \n\t\twmove(win, y, (width - prompt_len) / 2);\n\t\twaddstr(win, tempstr);\n\t} else {\n\t\tcur_x = x;\n\t\tcur_y = y;\n\t\tnewl = 1;\n\t\tword = tempstr;\n\t\twhile (word && *word) {\n\t\t\tsp = strpbrk(word, \"\\n \");\n\t\t\tif (sp && *sp == '\\n')\n\t\t\t\tnewline_separator = sp;\n\n\t\t\tif (sp)\n\t\t\t\t*sp++ = 0;\n\n\t\t\t \n\t\t\troom = width - cur_x;\n\t\t\twlen = strlen(word);\n\t\t\tif (wlen > room ||\n\t\t\t    (newl && wlen < 4 && sp\n\t\t\t     && wlen + 1 + strlen(sp) > room\n\t\t\t     && (!(sp2 = strpbrk(sp, \"\\n \"))\n\t\t\t\t || wlen + 1 + (sp2 - sp) > room))) {\n\t\t\t\tcur_y++;\n\t\t\t\tcur_x = x;\n\t\t\t}\n\t\t\twmove(win, cur_y, cur_x);\n\t\t\twaddstr(win, word);\n\t\t\tgetyx(win, cur_y, cur_x);\n\n\t\t\t \n\t\t\tif (newline_separator) {\n\t\t\t\tcur_y++;\n\t\t\t\tcur_x = x;\n\t\t\t\tnewline_separator = 0;\n\t\t\t} else\n\t\t\t\tcur_x++;\n\n\t\t\tif (sp && *sp == ' ') {\n\t\t\t\tcur_x++;\t \n\t\t\t\twhile (*++sp == ' ') ;\n\t\t\t\tnewl = 1;\n\t\t\t} else\n\t\t\t\tnewl = 0;\n\t\t\tword = sp;\n\t\t}\n\t}\n}\n\n \nvoid print_button(WINDOW * win, const char *label, int y, int x, int selected)\n{\n\tint i, temp;\n\n\twmove(win, y, x);\n\twattrset(win, selected ? dlg.button_active.atr\n\t\t : dlg.button_inactive.atr);\n\twaddstr(win, \"<\");\n\ttemp = strspn(label, \" \");\n\tlabel += temp;\n\twattrset(win, selected ? dlg.button_label_active.atr\n\t\t : dlg.button_label_inactive.atr);\n\tfor (i = 0; i < temp; i++)\n\t\twaddch(win, ' ');\n\twattrset(win, selected ? dlg.button_key_active.atr\n\t\t : dlg.button_key_inactive.atr);\n\twaddch(win, label[0]);\n\twattrset(win, selected ? dlg.button_label_active.atr\n\t\t : dlg.button_label_inactive.atr);\n\twaddstr(win, (char *)label + 1);\n\twattrset(win, selected ? dlg.button_active.atr\n\t\t : dlg.button_inactive.atr);\n\twaddstr(win, \">\");\n\twmove(win, y, x + temp + 1);\n}\n\n \nvoid\ndraw_box(WINDOW * win, int y, int x, int height, int width,\n\t chtype box, chtype border)\n{\n\tint i, j;\n\n\twattrset(win, 0);\n\tfor (i = 0; i < height; i++) {\n\t\twmove(win, y + i, x);\n\t\tfor (j = 0; j < width; j++)\n\t\t\tif (!i && !j)\n\t\t\t\twaddch(win, border | ACS_ULCORNER);\n\t\t\telse if (i == height - 1 && !j)\n\t\t\t\twaddch(win, border | ACS_LLCORNER);\n\t\t\telse if (!i && j == width - 1)\n\t\t\t\twaddch(win, box | ACS_URCORNER);\n\t\t\telse if (i == height - 1 && j == width - 1)\n\t\t\t\twaddch(win, box | ACS_LRCORNER);\n\t\t\telse if (!i)\n\t\t\t\twaddch(win, border | ACS_HLINE);\n\t\t\telse if (i == height - 1)\n\t\t\t\twaddch(win, box | ACS_HLINE);\n\t\t\telse if (!j)\n\t\t\t\twaddch(win, border | ACS_VLINE);\n\t\t\telse if (j == width - 1)\n\t\t\t\twaddch(win, box | ACS_VLINE);\n\t\t\telse\n\t\t\t\twaddch(win, box | ' ');\n\t}\n}\n\n \nvoid draw_shadow(WINDOW * win, int y, int x, int height, int width)\n{\n\tint i;\n\n\tif (has_colors()) {\t \n\t\twattrset(win, dlg.shadow.atr);\n\t\twmove(win, y + height, x + 2);\n\t\tfor (i = 0; i < width; i++)\n\t\t\twaddch(win, winch(win) & A_CHARTEXT);\n\t\tfor (i = y + 1; i < y + height + 1; i++) {\n\t\t\twmove(win, i, x + width);\n\t\t\twaddch(win, winch(win) & A_CHARTEXT);\n\t\t\twaddch(win, winch(win) & A_CHARTEXT);\n\t\t}\n\t\twnoutrefresh(win);\n\t}\n}\n\n \nint first_alpha(const char *string, const char *exempt)\n{\n\tint i, in_paren = 0, c;\n\n\tfor (i = 0; i < strlen(string); i++) {\n\t\tc = tolower(string[i]);\n\n\t\tif (strchr(\"<[(\", c))\n\t\t\t++in_paren;\n\t\tif (strchr(\">])\", c) && in_paren > 0)\n\t\t\t--in_paren;\n\n\t\tif ((!in_paren) && isalpha(c) && strchr(exempt, c) == 0)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\n \nint on_key_esc(WINDOW *win)\n{\n\tint key;\n\tint key2;\n\tint key3;\n\n\tnodelay(win, TRUE);\n\tkeypad(win, FALSE);\n\tkey = wgetch(win);\n\tkey2 = wgetch(win);\n\tdo {\n\t\tkey3 = wgetch(win);\n\t} while (key3 != ERR);\n\tnodelay(win, FALSE);\n\tkeypad(win, TRUE);\n\tif (key == KEY_ESC && key2 == ERR)\n\t\treturn KEY_ESC;\n\telse if (key != ERR && key != KEY_ESC && key2 == ERR)\n\t\tungetch(key);\n\n\treturn -1;\n}\n\n \nint on_key_resize(void)\n{\n\tdialog_clear();\n\treturn KEY_RESIZE;\n}\n\nstruct dialog_list *item_cur;\nstruct dialog_list item_nil;\nstruct dialog_list *item_head;\n\nvoid item_reset(void)\n{\n\tstruct dialog_list *p, *next;\n\n\tfor (p = item_head; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n\titem_head = NULL;\n\titem_cur = &item_nil;\n}\n\nvoid item_make(const char *fmt, ...)\n{\n\tva_list ap;\n\tstruct dialog_list *p = malloc(sizeof(*p));\n\n\tif (item_head)\n\t\titem_cur->next = p;\n\telse\n\t\titem_head = p;\n\titem_cur = p;\n\tmemset(p, 0, sizeof(*p));\n\n\tva_start(ap, fmt);\n\tvsnprintf(item_cur->node.str, sizeof(item_cur->node.str), fmt, ap);\n\tva_end(ap);\n}\n\nvoid item_add_str(const char *fmt, ...)\n{\n\tva_list ap;\n\tsize_t avail;\n\n\tavail = sizeof(item_cur->node.str) - strlen(item_cur->node.str);\n\n\tva_start(ap, fmt);\n\tvsnprintf(item_cur->node.str + strlen(item_cur->node.str),\n\t\t  avail, fmt, ap);\n\titem_cur->node.str[sizeof(item_cur->node.str) - 1] = '\\0';\n\tva_end(ap);\n}\n\nvoid item_set_tag(char tag)\n{\n\titem_cur->node.tag = tag;\n}\nvoid item_set_data(void *ptr)\n{\n\titem_cur->node.data = ptr;\n}\n\nvoid item_set_selected(int val)\n{\n\titem_cur->node.selected = val;\n}\n\nint item_activate_selected(void)\n{\n\titem_foreach()\n\t\tif (item_is_selected())\n\t\t\treturn 1;\n\treturn 0;\n}\n\nvoid *item_data(void)\n{\n\treturn item_cur->node.data;\n}\n\nchar item_tag(void)\n{\n\treturn item_cur->node.tag;\n}\n\nint item_count(void)\n{\n\tint n = 0;\n\tstruct dialog_list *p;\n\n\tfor (p = item_head; p; p = p->next)\n\t\tn++;\n\treturn n;\n}\n\nvoid item_set(int n)\n{\n\tint i = 0;\n\titem_foreach()\n\t\tif (i++ == n)\n\t\t\treturn;\n}\n\nint item_n(void)\n{\n\tint n = 0;\n\tstruct dialog_list *p;\n\n\tfor (p = item_head; p; p = p->next) {\n\t\tif (p == item_cur)\n\t\t\treturn n;\n\t\tn++;\n\t}\n\treturn 0;\n}\n\nconst char *item_str(void)\n{\n\treturn item_cur->node.str;\n}\n\nint item_is_selected(void)\n{\n\treturn (item_cur->node.selected != 0);\n}\n\nint item_is_tag(char tag)\n{\n\treturn (item_cur->node.tag == tag);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}