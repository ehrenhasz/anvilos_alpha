{
  "module_name": "textbox.c",
  "hash_id": "67fec81f995404a79debb920df628e5b906f57042416fdb7ef2ba3cbcc92c687",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/lxdialog/textbox.c",
  "human_readable_source": "\n \n\n#include \"dialog.h\"\n\nstatic int hscroll;\nstatic int begin_reached, end_reached, page_length;\nstatic const char *buf, *page;\nstatic size_t start, end;\n\n \nstatic void back_lines(int n)\n{\n\tint i;\n\n\tbegin_reached = 0;\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tif (*page == '\\0') {\n\t\t\tif (end_reached) {\n\t\t\t\tend_reached = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (page == buf) {\n\t\t\tbegin_reached = 1;\n\t\t\treturn;\n\t\t}\n\t\tpage--;\n\t\tdo {\n\t\t\tif (page == buf) {\n\t\t\t\tbegin_reached = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpage--;\n\t\t} while (*page != '\\n');\n\t\tpage++;\n\t}\n}\n\n \nstatic char *get_line(void)\n{\n\tint i = 0;\n\tstatic char line[MAX_LEN + 1];\n\n\tend_reached = 0;\n\twhile (*page != '\\n') {\n\t\tif (*page == '\\0') {\n\t\t\tend_reached = 1;\n\t\t\tbreak;\n\t\t} else if (i < MAX_LEN)\n\t\t\tline[i++] = *(page++);\n\t\telse {\n\t\t\t \n\t\t\tif (i == MAX_LEN)\n\t\t\t\tline[i++] = '\\0';\n\t\t\tpage++;\n\t\t}\n\t}\n\tif (i <= MAX_LEN)\n\t\tline[i] = '\\0';\n\tif (!end_reached)\n\t\tpage++;\t\t \n\n\treturn line;\n}\n\n \nstatic void print_line(WINDOW *win, int row, int width)\n{\n\tchar *line;\n\n\tline = get_line();\n\tline += MIN(strlen(line), hscroll);\t \n\twmove(win, row, 0);\t \n\twaddch(win, ' ');\n\twaddnstr(win, line, MIN(strlen(line), width - 2));\n\n\t \n\twclrtoeol(win);\n}\n\n \nstatic void print_page(WINDOW *win, int height, int width)\n{\n\tint i, passed_end = 0;\n\n\tpage_length = 0;\n\tfor (i = 0; i < height; i++) {\n\t\tprint_line(win, i, width);\n\t\tif (!passed_end)\n\t\t\tpage_length++;\n\t\tif (end_reached && !passed_end)\n\t\t\tpassed_end = 1;\n\t}\n\twnoutrefresh(win);\n}\n\n \nstatic void print_position(WINDOW *win)\n{\n\tint percent;\n\n\twattrset(win, dlg.position_indicator.atr);\n\twbkgdset(win, dlg.position_indicator.atr & A_COLOR);\n\tpercent = (page - buf) * 100 / strlen(buf);\n\twmove(win, getmaxy(win) - 3, getmaxx(win) - 9);\n\twprintw(win, \"(%3d%%)\", percent);\n}\n\n \nstatic void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,\n\t\t\t     int cur_y, int cur_x)\n{\n\tstart = page - buf;\n\n\tprint_page(box, boxh, boxw);\n\tprint_position(dialog);\n\twmove(dialog, cur_y, cur_x);\t \n\twrefresh(dialog);\n\n\tend = page - buf;\n}\n\n \nint dialog_textbox(const char *title, const char *tbuf, int initial_height,\n\t\t   int initial_width, int *_vscroll, int *_hscroll,\n\t\t   int (*extra_key_cb)(int, size_t, size_t, void *), void *data)\n{\n\tint i, x, y, cur_x, cur_y, key = 0;\n\tint height, width, boxh, boxw;\n\tWINDOW *dialog, *box;\n\tbool done = false;\n\n\tbegin_reached = 1;\n\tend_reached = 0;\n\tpage_length = 0;\n\thscroll = 0;\n\tbuf = tbuf;\n\tpage = buf;\t \n\n\tif (_vscroll && *_vscroll) {\n\t\tbegin_reached = 0;\n\n\t\tfor (i = 0; i < *_vscroll; i++)\n\t\t\tget_line();\n\t}\n\tif (_hscroll)\n\t\thscroll = *_hscroll;\n\ndo_resize:\n\tgetmaxyx(stdscr, height, width);\n\tif (height < TEXTBOX_HEIGTH_MIN || width < TEXTBOX_WIDTH_MIN)\n\t\treturn -ERRDISPLAYTOOSMALL;\n\tif (initial_height != 0)\n\t\theight = initial_height;\n\telse\n\t\tif (height > 4)\n\t\t\theight -= 4;\n\t\telse\n\t\t\theight = 0;\n\tif (initial_width != 0)\n\t\twidth = initial_width;\n\telse\n\t\tif (width > 5)\n\t\t\twidth -= 5;\n\t\telse\n\t\t\twidth = 0;\n\n\t \n\tx = (getmaxx(stdscr) - width) / 2;\n\ty = (getmaxy(stdscr) - height) / 2;\n\n\tdraw_shadow(stdscr, y, x, height, width);\n\n\tdialog = newwin(height, width, y, x);\n\tkeypad(dialog, TRUE);\n\n\t \n\tboxh = height - 4;\n\tboxw = width - 2;\n\tbox = subwin(dialog, boxh, boxw, y + 1, x + 1);\n\twattrset(box, dlg.dialog.atr);\n\twbkgdset(box, dlg.dialog.atr & A_COLOR);\n\n\tkeypad(box, TRUE);\n\n\t \n\tdraw_box(dialog, 0, 0, height, width,\n\t\t dlg.dialog.atr, dlg.border.atr);\n\n\twattrset(dialog, dlg.border.atr);\n\tmvwaddch(dialog, height - 3, 0, ACS_LTEE);\n\tfor (i = 0; i < width - 2; i++)\n\t\twaddch(dialog, ACS_HLINE);\n\twattrset(dialog, dlg.dialog.atr);\n\twbkgdset(dialog, dlg.dialog.atr & A_COLOR);\n\twaddch(dialog, ACS_RTEE);\n\n\tprint_title(dialog, title, width);\n\n\tprint_button(dialog, \" Exit \", height - 2, width / 2 - 4, TRUE);\n\twnoutrefresh(dialog);\n\tgetyx(dialog, cur_y, cur_x);\t \n\n\t \n\tattr_clear(box, boxh, boxw, dlg.dialog.atr);\n\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\n\twhile (!done) {\n\t\tkey = wgetch(dialog);\n\t\tswitch (key) {\n\t\tcase 'E':\t \n\t\tcase 'e':\n\t\tcase 'X':\n\t\tcase 'x':\n\t\tcase 'q':\n\t\tcase '\\n':\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase 'g':\t \n\t\tcase KEY_HOME:\n\t\t\tif (!begin_reached) {\n\t\t\t\tbegin_reached = 1;\n\t\t\t\tpage = buf;\n\t\t\t\trefresh_text_box(dialog, box, boxh, boxw,\n\t\t\t\t\t\t cur_y, cur_x);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'G':\t \n\t\tcase KEY_END:\n\n\t\t\tend_reached = 1;\n\t\t\t \n\t\t\tpage = buf + strlen(buf);\n\t\t\tback_lines(boxh);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'K':\t \n\t\tcase 'k':\n\t\tcase KEY_UP:\n\t\t\tif (begin_reached)\n\t\t\t\tbreak;\n\n\t\t\tback_lines(page_length + 1);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'B':\t \n\t\tcase 'b':\n\t\tcase 'u':\n\t\tcase KEY_PPAGE:\n\t\t\tif (begin_reached)\n\t\t\t\tbreak;\n\t\t\tback_lines(page_length + boxh);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'J':\t \n\t\tcase 'j':\n\t\tcase KEY_DOWN:\n\t\t\tif (end_reached)\n\t\t\t\tbreak;\n\n\t\t\tback_lines(page_length - 1);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase KEY_NPAGE:\t \n\t\tcase ' ':\n\t\tcase 'd':\n\t\t\tif (end_reached)\n\t\t\t\tbreak;\n\n\t\t\tbegin_reached = 0;\n\t\t\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase '0':\t \n\t\tcase 'H':\t \n\t\tcase 'h':\n\t\tcase KEY_LEFT:\n\t\t\tif (hscroll <= 0)\n\t\t\t\tbreak;\n\n\t\t\tif (key == '0')\n\t\t\t\thscroll = 0;\n\t\t\telse\n\t\t\t\thscroll--;\n\t\t\t \n\t\t\tback_lines(page_length);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase 'L':\t \n\t\tcase 'l':\n\t\tcase KEY_RIGHT:\n\t\t\tif (hscroll >= MAX_LEN)\n\t\t\t\tbreak;\n\t\t\thscroll++;\n\t\t\t \n\t\t\tback_lines(page_length);\n\t\t\trefresh_text_box(dialog, box, boxh, boxw, cur_y, cur_x);\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\tif (on_key_esc(dialog) == KEY_ESC)\n\t\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase KEY_RESIZE:\n\t\t\tback_lines(height);\n\t\t\tdelwin(box);\n\t\t\tdelwin(dialog);\n\t\t\ton_key_resize();\n\t\t\tgoto do_resize;\n\t\tdefault:\n\t\t\tif (extra_key_cb && extra_key_cb(key, start, end, data)) {\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdelwin(box);\n\tdelwin(dialog);\n\tif (_vscroll) {\n\t\tconst char *s;\n\n\t\ts = buf;\n\t\t*_vscroll = 0;\n\t\tback_lines(page_length);\n\t\twhile (s < page && (s = strchr(s, '\\n'))) {\n\t\t\t(*_vscroll)++;\n\t\t\ts++;\n\t\t}\n\t}\n\tif (_hscroll)\n\t\t*_hscroll = hscroll;\n\treturn key;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}