{
  "module_name": "gconf.c",
  "hash_id": "be96c12801a40817e4cd4a9d059482b4e7351f1dae1e20ba6aa29590ae0d6be9",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/gconf.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include \"lkc.h\"\n#include \"images.h\"\n\n#include <glade/glade.h>\n#include <gtk/gtk.h>\n#include <glib.h>\n#include <gdk/gdkkeysyms.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <unistd.h>\n#include <time.h>\n\n\n\nenum {\n\tSINGLE_VIEW, SPLIT_VIEW, FULL_VIEW\n};\n\nenum {\n\tOPT_NORMAL, OPT_ALL, OPT_PROMPT\n};\n\nstatic gint view_mode = FULL_VIEW;\nstatic gboolean show_name = TRUE;\nstatic gboolean show_range = TRUE;\nstatic gboolean show_value = TRUE;\nstatic gboolean resizeable = FALSE;\nstatic int opt_mode = OPT_NORMAL;\n\nGtkWidget *main_wnd = NULL;\nGtkWidget *tree1_w = NULL;\t\nGtkWidget *tree2_w = NULL;\t\nGtkWidget *text_w = NULL;\nGtkWidget *hpaned = NULL;\nGtkWidget *vpaned = NULL;\nGtkWidget *back_btn = NULL;\nGtkWidget *save_btn = NULL;\nGtkWidget *save_menu_item = NULL;\n\nGtkTextTag *tag1, *tag2;\nGdkColor color;\n\nGtkTreeStore *tree1, *tree2, *tree;\nGtkTreeModel *model1, *model2;\nstatic GtkTreeIter *parents[256];\nstatic gint indent;\n\nstatic struct menu *current; \nstatic struct menu *browsed; \n\nenum {\n\tCOL_OPTION, COL_NAME, COL_NO, COL_MOD, COL_YES, COL_VALUE,\n\tCOL_MENU, COL_COLOR, COL_EDIT, COL_PIXBUF,\n\tCOL_PIXVIS, COL_BTNVIS, COL_BTNACT, COL_BTNINC, COL_BTNRAD,\n\tCOL_NUMBER\n};\n\nstatic void display_list(void);\nstatic void display_tree(struct menu *menu);\nstatic void display_tree_part(void);\nstatic void update_tree(struct menu *src, GtkTreeIter * dst);\nstatic void set_node(GtkTreeIter * node, struct menu *menu, gchar ** row);\nstatic gchar **fill_row(struct menu *menu);\nstatic void conf_changed(void);\n\n \n#ifdef DEBUG\nstatic const char *dbg_sym_flags(int val)\n{\n\tstatic char buf[256];\n\n\tbzero(buf, 256);\n\n\tif (val & SYMBOL_CONST)\n\t\tstrcat(buf, \"const/\");\n\tif (val & SYMBOL_CHECK)\n\t\tstrcat(buf, \"check/\");\n\tif (val & SYMBOL_CHOICE)\n\t\tstrcat(buf, \"choice/\");\n\tif (val & SYMBOL_CHOICEVAL)\n\t\tstrcat(buf, \"choiceval/\");\n\tif (val & SYMBOL_VALID)\n\t\tstrcat(buf, \"valid/\");\n\tif (val & SYMBOL_OPTIONAL)\n\t\tstrcat(buf, \"optional/\");\n\tif (val & SYMBOL_WRITE)\n\t\tstrcat(buf, \"write/\");\n\tif (val & SYMBOL_CHANGED)\n\t\tstrcat(buf, \"changed/\");\n\tif (val & SYMBOL_NO_WRITE)\n\t\tstrcat(buf, \"no_write/\");\n\n\tbuf[strlen(buf) - 1] = '\\0';\n\n\treturn buf;\n}\n#endif\n\nstatic void replace_button_icon(GladeXML *xml, GdkDrawable *window,\n\t\t\t\tGtkStyle *style, gchar *btn_name, gchar **xpm)\n{\n\tGdkPixmap *pixmap;\n\tGdkBitmap *mask;\n\tGtkToolButton *button;\n\tGtkWidget *image;\n\n\tpixmap = gdk_pixmap_create_from_xpm_d(window, &mask,\n\t\t\t\t\t      &style->bg[GTK_STATE_NORMAL],\n\t\t\t\t\t      xpm);\n\n\tbutton = GTK_TOOL_BUTTON(glade_xml_get_widget(xml, btn_name));\n\timage = gtk_image_new_from_pixmap(pixmap, mask);\n\tgtk_widget_show(image);\n\tgtk_tool_button_set_icon_widget(button, image);\n}\n\n \nstatic void init_main_window(const gchar *glade_file)\n{\n\tGladeXML *xml;\n\tGtkWidget *widget;\n\tGtkTextBuffer *txtbuf;\n\tGtkStyle *style;\n\n\txml = glade_xml_new(glade_file, \"window1\", NULL);\n\tif (!xml)\n\t\tg_error(\"GUI loading failed !\\n\");\n\tglade_xml_signal_autoconnect(xml);\n\n\tmain_wnd = glade_xml_get_widget(xml, \"window1\");\n\thpaned = glade_xml_get_widget(xml, \"hpaned1\");\n\tvpaned = glade_xml_get_widget(xml, \"vpaned1\");\n\ttree1_w = glade_xml_get_widget(xml, \"treeview1\");\n\ttree2_w = glade_xml_get_widget(xml, \"treeview2\");\n\ttext_w = glade_xml_get_widget(xml, \"textview3\");\n\n\tback_btn = glade_xml_get_widget(xml, \"button1\");\n\tgtk_widget_set_sensitive(back_btn, FALSE);\n\n\twidget = glade_xml_get_widget(xml, \"show_name1\");\n\tgtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\n\t\t\t\t       show_name);\n\n\twidget = glade_xml_get_widget(xml, \"show_range1\");\n\tgtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\n\t\t\t\t       show_range);\n\n\twidget = glade_xml_get_widget(xml, \"show_data1\");\n\tgtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\n\t\t\t\t       show_value);\n\n\tsave_btn = glade_xml_get_widget(xml, \"button3\");\n\tsave_menu_item = glade_xml_get_widget(xml, \"save1\");\n\tconf_set_changed_callback(conf_changed);\n\n\tstyle = gtk_widget_get_style(main_wnd);\n\twidget = glade_xml_get_widget(xml, \"toolbar1\");\n\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button4\", (gchar **) xpm_single_view);\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button5\", (gchar **) xpm_split_view);\n\treplace_button_icon(xml, main_wnd->window, style,\n\t\t\t    \"button6\", (gchar **) xpm_tree_view);\n\n\ttxtbuf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_w));\n\ttag1 = gtk_text_buffer_create_tag(txtbuf, \"mytag1\",\n\t\t\t\t\t  \"foreground\", \"red\",\n\t\t\t\t\t  \"weight\", PANGO_WEIGHT_BOLD,\n\t\t\t\t\t  NULL);\n\ttag2 = gtk_text_buffer_create_tag(txtbuf, \"mytag2\",\n\t\t\t\t\t   \n\t\t\t\t\t  NULL);\n\n\tgtk_window_set_title(GTK_WINDOW(main_wnd), rootmenu.prompt->text);\n\n\tgtk_widget_show(main_wnd);\n}\n\nstatic void init_tree_model(void)\n{\n\tgint i;\n\n\ttree = tree2 = gtk_tree_store_new(COL_NUMBER,\n\t\t\t\t\t  G_TYPE_STRING, G_TYPE_STRING,\n\t\t\t\t\t  G_TYPE_STRING, G_TYPE_STRING,\n\t\t\t\t\t  G_TYPE_STRING, G_TYPE_STRING,\n\t\t\t\t\t  G_TYPE_POINTER, GDK_TYPE_COLOR,\n\t\t\t\t\t  G_TYPE_BOOLEAN, GDK_TYPE_PIXBUF,\n\t\t\t\t\t  G_TYPE_BOOLEAN, G_TYPE_BOOLEAN,\n\t\t\t\t\t  G_TYPE_BOOLEAN, G_TYPE_BOOLEAN,\n\t\t\t\t\t  G_TYPE_BOOLEAN);\n\tmodel2 = GTK_TREE_MODEL(tree2);\n\n\tfor (parents[0] = NULL, i = 1; i < 256; i++)\n\t\tparents[i] = (GtkTreeIter *) g_malloc(sizeof(GtkTreeIter));\n\n\ttree1 = gtk_tree_store_new(COL_NUMBER,\n\t\t\t\t   G_TYPE_STRING, G_TYPE_STRING,\n\t\t\t\t   G_TYPE_STRING, G_TYPE_STRING,\n\t\t\t\t   G_TYPE_STRING, G_TYPE_STRING,\n\t\t\t\t   G_TYPE_POINTER, GDK_TYPE_COLOR,\n\t\t\t\t   G_TYPE_BOOLEAN, GDK_TYPE_PIXBUF,\n\t\t\t\t   G_TYPE_BOOLEAN, G_TYPE_BOOLEAN,\n\t\t\t\t   G_TYPE_BOOLEAN, G_TYPE_BOOLEAN,\n\t\t\t\t   G_TYPE_BOOLEAN);\n\tmodel1 = GTK_TREE_MODEL(tree1);\n}\n\nstatic void init_left_tree(void)\n{\n\tGtkTreeView *view = GTK_TREE_VIEW(tree1_w);\n\tGtkCellRenderer *renderer;\n\tGtkTreeSelection *sel;\n\tGtkTreeViewColumn *column;\n\n\tgtk_tree_view_set_model(view, model1);\n\tgtk_tree_view_set_headers_visible(view, TRUE);\n\tgtk_tree_view_set_rules_hint(view, TRUE);\n\n\tcolumn = gtk_tree_view_column_new();\n\tgtk_tree_view_append_column(view, column);\n\tgtk_tree_view_column_set_title(column, \"Options\");\n\n\trenderer = gtk_cell_renderer_toggle_new();\n\tgtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\trenderer, FALSE);\n\tgtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\t    renderer,\n\t\t\t\t\t    \"active\", COL_BTNACT,\n\t\t\t\t\t    \"inconsistent\", COL_BTNINC,\n\t\t\t\t\t    \"visible\", COL_BTNVIS,\n\t\t\t\t\t    \"radio\", COL_BTNRAD, NULL);\n\trenderer = gtk_cell_renderer_text_new();\n\tgtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\trenderer, FALSE);\n\tgtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\t    renderer,\n\t\t\t\t\t    \"text\", COL_OPTION,\n\t\t\t\t\t    \"foreground-gdk\",\n\t\t\t\t\t    COL_COLOR, NULL);\n\n\tsel = gtk_tree_view_get_selection(view);\n\tgtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\n\tgtk_widget_realize(tree1_w);\n}\n\nstatic void renderer_edited(GtkCellRendererText * cell,\n\t\t\t    const gchar * path_string,\n\t\t\t    const gchar * new_text, gpointer user_data);\n\nstatic void init_right_tree(void)\n{\n\tGtkTreeView *view = GTK_TREE_VIEW(tree2_w);\n\tGtkCellRenderer *renderer;\n\tGtkTreeSelection *sel;\n\tGtkTreeViewColumn *column;\n\tgint i;\n\n\tgtk_tree_view_set_model(view, model2);\n\tgtk_tree_view_set_headers_visible(view, TRUE);\n\tgtk_tree_view_set_rules_hint(view, TRUE);\n\n\tcolumn = gtk_tree_view_column_new();\n\tgtk_tree_view_append_column(view, column);\n\tgtk_tree_view_column_set_title(column, \"Options\");\n\n\trenderer = gtk_cell_renderer_pixbuf_new();\n\tgtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\trenderer, FALSE);\n\tgtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\t    renderer,\n\t\t\t\t\t    \"pixbuf\", COL_PIXBUF,\n\t\t\t\t\t    \"visible\", COL_PIXVIS, NULL);\n\trenderer = gtk_cell_renderer_toggle_new();\n\tgtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\trenderer, FALSE);\n\tgtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\t    renderer,\n\t\t\t\t\t    \"active\", COL_BTNACT,\n\t\t\t\t\t    \"inconsistent\", COL_BTNINC,\n\t\t\t\t\t    \"visible\", COL_BTNVIS,\n\t\t\t\t\t    \"radio\", COL_BTNRAD, NULL);\n\trenderer = gtk_cell_renderer_text_new();\n\tgtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\trenderer, FALSE);\n\tgtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\n\t\t\t\t\t    renderer,\n\t\t\t\t\t    \"text\", COL_OPTION,\n\t\t\t\t\t    \"foreground-gdk\",\n\t\t\t\t\t    COL_COLOR, NULL);\n\n\trenderer = gtk_cell_renderer_text_new();\n\tgtk_tree_view_insert_column_with_attributes(view, -1,\n\t\t\t\t\t\t    \"Name\", renderer,\n\t\t\t\t\t\t    \"text\", COL_NAME,\n\t\t\t\t\t\t    \"foreground-gdk\",\n\t\t\t\t\t\t    COL_COLOR, NULL);\n\trenderer = gtk_cell_renderer_text_new();\n\tgtk_tree_view_insert_column_with_attributes(view, -1,\n\t\t\t\t\t\t    \"N\", renderer,\n\t\t\t\t\t\t    \"text\", COL_NO,\n\t\t\t\t\t\t    \"foreground-gdk\",\n\t\t\t\t\t\t    COL_COLOR, NULL);\n\trenderer = gtk_cell_renderer_text_new();\n\tgtk_tree_view_insert_column_with_attributes(view, -1,\n\t\t\t\t\t\t    \"M\", renderer,\n\t\t\t\t\t\t    \"text\", COL_MOD,\n\t\t\t\t\t\t    \"foreground-gdk\",\n\t\t\t\t\t\t    COL_COLOR, NULL);\n\trenderer = gtk_cell_renderer_text_new();\n\tgtk_tree_view_insert_column_with_attributes(view, -1,\n\t\t\t\t\t\t    \"Y\", renderer,\n\t\t\t\t\t\t    \"text\", COL_YES,\n\t\t\t\t\t\t    \"foreground-gdk\",\n\t\t\t\t\t\t    COL_COLOR, NULL);\n\trenderer = gtk_cell_renderer_text_new();\n\tgtk_tree_view_insert_column_with_attributes(view, -1,\n\t\t\t\t\t\t    \"Value\", renderer,\n\t\t\t\t\t\t    \"text\", COL_VALUE,\n\t\t\t\t\t\t    \"editable\",\n\t\t\t\t\t\t    COL_EDIT,\n\t\t\t\t\t\t    \"foreground-gdk\",\n\t\t\t\t\t\t    COL_COLOR, NULL);\n\tg_signal_connect(G_OBJECT(renderer), \"edited\",\n\t\t\t G_CALLBACK(renderer_edited), NULL);\n\n\tcolumn = gtk_tree_view_get_column(view, COL_NAME);\n\tgtk_tree_view_column_set_visible(column, show_name);\n\tcolumn = gtk_tree_view_get_column(view, COL_NO);\n\tgtk_tree_view_column_set_visible(column, show_range);\n\tcolumn = gtk_tree_view_get_column(view, COL_MOD);\n\tgtk_tree_view_column_set_visible(column, show_range);\n\tcolumn = gtk_tree_view_get_column(view, COL_YES);\n\tgtk_tree_view_column_set_visible(column, show_range);\n\tcolumn = gtk_tree_view_get_column(view, COL_VALUE);\n\tgtk_tree_view_column_set_visible(column, show_value);\n\n\tif (resizeable) {\n\t\tfor (i = 0; i < COL_VALUE; i++) {\n\t\t\tcolumn = gtk_tree_view_get_column(view, i);\n\t\t\tgtk_tree_view_column_set_resizable(column, TRUE);\n\t\t}\n\t}\n\n\tsel = gtk_tree_view_get_selection(view);\n\tgtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\n}\n\n\n \n\n\nstatic void text_insert_help(struct menu *menu)\n{\n\tGtkTextBuffer *buffer;\n\tGtkTextIter start, end;\n\tconst char *prompt = menu_get_prompt(menu);\n\tstruct gstr help = str_new();\n\n\tmenu_get_ext_help(menu, &help);\n\n\tbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_w));\n\tgtk_text_buffer_get_bounds(buffer, &start, &end);\n\tgtk_text_buffer_delete(buffer, &start, &end);\n\tgtk_text_view_set_left_margin(GTK_TEXT_VIEW(text_w), 15);\n\n\tgtk_text_buffer_get_end_iter(buffer, &end);\n\tgtk_text_buffer_insert_with_tags(buffer, &end, prompt, -1, tag1,\n\t\t\t\t\t NULL);\n\tgtk_text_buffer_insert_at_cursor(buffer, \"\\n\\n\", 2);\n\tgtk_text_buffer_get_end_iter(buffer, &end);\n\tgtk_text_buffer_insert_with_tags(buffer, &end, str_get(&help), -1, tag2,\n\t\t\t\t\t NULL);\n\tstr_free(&help);\n}\n\n\nstatic void text_insert_msg(const char *title, const char *message)\n{\n\tGtkTextBuffer *buffer;\n\tGtkTextIter start, end;\n\tconst char *msg = message;\n\n\tbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_w));\n\tgtk_text_buffer_get_bounds(buffer, &start, &end);\n\tgtk_text_buffer_delete(buffer, &start, &end);\n\tgtk_text_view_set_left_margin(GTK_TEXT_VIEW(text_w), 15);\n\n\tgtk_text_buffer_get_end_iter(buffer, &end);\n\tgtk_text_buffer_insert_with_tags(buffer, &end, title, -1, tag1,\n\t\t\t\t\t NULL);\n\tgtk_text_buffer_insert_at_cursor(buffer, \"\\n\\n\", 2);\n\tgtk_text_buffer_get_end_iter(buffer, &end);\n\tgtk_text_buffer_insert_with_tags(buffer, &end, msg, -1, tag2,\n\t\t\t\t\t NULL);\n}\n\n\n \n\nvoid on_save_activate(GtkMenuItem * menuitem, gpointer user_data);\ngboolean on_window1_delete_event(GtkWidget * widget, GdkEvent * event,\n\t\t\t\t gpointer user_data)\n{\n\tGtkWidget *dialog, *label;\n\tgint result;\n\n\tif (!conf_get_changed())\n\t\treturn FALSE;\n\n\tdialog = gtk_dialog_new_with_buttons(\"Warning !\",\n\t\t\t\t\t     GTK_WINDOW(main_wnd),\n\t\t\t\t\t     (GtkDialogFlags)\n\t\t\t\t\t     (GTK_DIALOG_MODAL |\n\t\t\t\t\t      GTK_DIALOG_DESTROY_WITH_PARENT),\n\t\t\t\t\t     GTK_STOCK_OK,\n\t\t\t\t\t     GTK_RESPONSE_YES,\n\t\t\t\t\t     GTK_STOCK_NO,\n\t\t\t\t\t     GTK_RESPONSE_NO,\n\t\t\t\t\t     GTK_STOCK_CANCEL,\n\t\t\t\t\t     GTK_RESPONSE_CANCEL, NULL);\n\tgtk_dialog_set_default_response(GTK_DIALOG(dialog),\n\t\t\t\t\tGTK_RESPONSE_CANCEL);\n\n\tlabel = gtk_label_new(\"\\nSave configuration ?\\n\");\n\tgtk_container_add(GTK_CONTAINER(GTK_DIALOG(dialog)->vbox), label);\n\tgtk_widget_show(label);\n\n\tresult = gtk_dialog_run(GTK_DIALOG(dialog));\n\tswitch (result) {\n\tcase GTK_RESPONSE_YES:\n\t\ton_save_activate(NULL, NULL);\n\t\treturn FALSE;\n\tcase GTK_RESPONSE_NO:\n\t\treturn FALSE;\n\tcase GTK_RESPONSE_CANCEL:\n\tcase GTK_RESPONSE_DELETE_EVENT:\n\tdefault:\n\t\tgtk_widget_destroy(dialog);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\n\nvoid on_window1_destroy(GtkObject * object, gpointer user_data)\n{\n\tgtk_main_quit();\n}\n\n\nvoid\non_window1_size_request(GtkWidget * widget,\n\t\t\tGtkRequisition * requisition, gpointer user_data)\n{\n\tstatic gint old_h;\n\tgint w, h;\n\n\tif (widget->window == NULL)\n\t\tgtk_window_get_default_size(GTK_WINDOW(main_wnd), &w, &h);\n\telse\n\t\tgdk_window_get_size(widget->window, &w, &h);\n\n\tif (h == old_h)\n\t\treturn;\n\told_h = h;\n\n\tgtk_paned_set_position(GTK_PANED(vpaned), 2 * h / 3);\n}\n\n\n \n\n\nstatic void\nload_filename(GtkFileSelection * file_selector, gpointer user_data)\n{\n\tconst gchar *fn;\n\n\tfn = gtk_file_selection_get_filename(GTK_FILE_SELECTION\n\t\t\t\t\t     (user_data));\n\n\tif (conf_read(fn))\n\t\ttext_insert_msg(\"Error\", \"Unable to load configuration !\");\n\telse\n\t\tdisplay_tree(&rootmenu);\n}\n\nvoid on_load1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tGtkWidget *fs;\n\n\tfs = gtk_file_selection_new(\"Load file...\");\n\tg_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(fs)->ok_button),\n\t\t\t \"clicked\",\n\t\t\t G_CALLBACK(load_filename), (gpointer) fs);\n\tg_signal_connect_swapped(GTK_OBJECT\n\t\t\t\t (GTK_FILE_SELECTION(fs)->ok_button),\n\t\t\t\t \"clicked\", G_CALLBACK(gtk_widget_destroy),\n\t\t\t\t (gpointer) fs);\n\tg_signal_connect_swapped(GTK_OBJECT\n\t\t\t\t (GTK_FILE_SELECTION(fs)->cancel_button),\n\t\t\t\t \"clicked\", G_CALLBACK(gtk_widget_destroy),\n\t\t\t\t (gpointer) fs);\n\tgtk_widget_show(fs);\n}\n\n\nvoid on_save_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tif (conf_write(NULL))\n\t\ttext_insert_msg(\"Error\", \"Unable to save configuration !\");\n\tconf_write_autoconf(0);\n}\n\n\nstatic void\nstore_filename(GtkFileSelection * file_selector, gpointer user_data)\n{\n\tconst gchar *fn;\n\n\tfn = gtk_file_selection_get_filename(GTK_FILE_SELECTION\n\t\t\t\t\t     (user_data));\n\n\tif (conf_write(fn))\n\t\ttext_insert_msg(\"Error\", \"Unable to save configuration !\");\n\n\tgtk_widget_destroy(GTK_WIDGET(user_data));\n}\n\nvoid on_save_as1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tGtkWidget *fs;\n\n\tfs = gtk_file_selection_new(\"Save file as...\");\n\tg_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(fs)->ok_button),\n\t\t\t \"clicked\",\n\t\t\t G_CALLBACK(store_filename), (gpointer) fs);\n\tg_signal_connect_swapped(GTK_OBJECT\n\t\t\t\t (GTK_FILE_SELECTION(fs)->ok_button),\n\t\t\t\t \"clicked\", G_CALLBACK(gtk_widget_destroy),\n\t\t\t\t (gpointer) fs);\n\tg_signal_connect_swapped(GTK_OBJECT\n\t\t\t\t (GTK_FILE_SELECTION(fs)->cancel_button),\n\t\t\t\t \"clicked\", G_CALLBACK(gtk_widget_destroy),\n\t\t\t\t (gpointer) fs);\n\tgtk_widget_show(fs);\n}\n\n\nvoid on_quit1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tif (!on_window1_delete_event(NULL, NULL, NULL))\n\t\tgtk_widget_destroy(GTK_WIDGET(main_wnd));\n}\n\n\nvoid on_show_name1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tGtkTreeViewColumn *col;\n\n\tshow_name = GTK_CHECK_MENU_ITEM(menuitem)->active;\n\tcol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_NAME);\n\tif (col)\n\t\tgtk_tree_view_column_set_visible(col, show_name);\n}\n\n\nvoid on_show_range1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tGtkTreeViewColumn *col;\n\n\tshow_range = GTK_CHECK_MENU_ITEM(menuitem)->active;\n\tcol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_NO);\n\tif (col)\n\t\tgtk_tree_view_column_set_visible(col, show_range);\n\tcol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_MOD);\n\tif (col)\n\t\tgtk_tree_view_column_set_visible(col, show_range);\n\tcol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_YES);\n\tif (col)\n\t\tgtk_tree_view_column_set_visible(col, show_range);\n\n}\n\n\nvoid on_show_data1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tGtkTreeViewColumn *col;\n\n\tshow_value = GTK_CHECK_MENU_ITEM(menuitem)->active;\n\tcol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_VALUE);\n\tif (col)\n\t\tgtk_tree_view_column_set_visible(col, show_value);\n}\n\n\nvoid\non_set_option_mode1_activate(GtkMenuItem *menuitem, gpointer user_data)\n{\n\topt_mode = OPT_NORMAL;\n\tgtk_tree_store_clear(tree2);\n\tdisplay_tree(&rootmenu);\t \n}\n\n\nvoid\non_set_option_mode2_activate(GtkMenuItem *menuitem, gpointer user_data)\n{\n\topt_mode = OPT_ALL;\n\tgtk_tree_store_clear(tree2);\n\tdisplay_tree(&rootmenu);\t \n}\n\n\nvoid\non_set_option_mode3_activate(GtkMenuItem *menuitem, gpointer user_data)\n{\n\topt_mode = OPT_PROMPT;\n\tgtk_tree_store_clear(tree2);\n\tdisplay_tree(&rootmenu);\t \n}\n\n\nvoid on_introduction1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tGtkWidget *dialog;\n\tconst gchar *intro_text =\n\t    \"Welcome to gconfig, the GTK+ graphical configuration tool.\\n\"\n\t    \"For each option, a blank box indicates the feature is disabled, a\\n\"\n\t    \"check indicates it is enabled, and a dot indicates that it is to\\n\"\n\t    \"be compiled as a module.  Clicking on the box will cycle through the three states.\\n\"\n\t    \"\\n\"\n\t    \"If you do not see an option (e.g., a device driver) that you\\n\"\n\t    \"believe should be present, try turning on Show All Options\\n\"\n\t    \"under the Options menu.\\n\"\n\t    \"Although there is no cross reference yet to help you figure out\\n\"\n\t    \"what other options must be enabled to support the option you\\n\"\n\t    \"are interested in, you can still view the help of a grayed-out\\n\"\n\t    \"option.\";\n\n\tdialog = gtk_message_dialog_new(GTK_WINDOW(main_wnd),\n\t\t\t\t\tGTK_DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\tGTK_MESSAGE_INFO,\n\t\t\t\t\tGTK_BUTTONS_CLOSE, \"%s\", intro_text);\n\tg_signal_connect_swapped(GTK_OBJECT(dialog), \"response\",\n\t\t\t\t G_CALLBACK(gtk_widget_destroy),\n\t\t\t\t GTK_OBJECT(dialog));\n\tgtk_widget_show_all(dialog);\n}\n\n\nvoid on_about1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tGtkWidget *dialog;\n\tconst gchar *about_text =\n\t    \"gconfig is copyright (c) 2002 Romain Lievin <roms@lpg.ticalc.org>.\\n\"\n\t      \"Based on the source code from Roman Zippel.\\n\";\n\n\tdialog = gtk_message_dialog_new(GTK_WINDOW(main_wnd),\n\t\t\t\t\tGTK_DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\tGTK_MESSAGE_INFO,\n\t\t\t\t\tGTK_BUTTONS_CLOSE, \"%s\", about_text);\n\tg_signal_connect_swapped(GTK_OBJECT(dialog), \"response\",\n\t\t\t\t G_CALLBACK(gtk_widget_destroy),\n\t\t\t\t GTK_OBJECT(dialog));\n\tgtk_widget_show_all(dialog);\n}\n\n\nvoid on_license1_activate(GtkMenuItem * menuitem, gpointer user_data)\n{\n\tGtkWidget *dialog;\n\tconst gchar *license_text =\n\t    \"gconfig is released under the terms of the GNU GPL v2.\\n\"\n\t      \"For more information, please see the source code or\\n\"\n\t      \"visit http://www.fsf.org/licenses/licenses.html\\n\";\n\n\tdialog = gtk_message_dialog_new(GTK_WINDOW(main_wnd),\n\t\t\t\t\tGTK_DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\tGTK_MESSAGE_INFO,\n\t\t\t\t\tGTK_BUTTONS_CLOSE, \"%s\", license_text);\n\tg_signal_connect_swapped(GTK_OBJECT(dialog), \"response\",\n\t\t\t\t G_CALLBACK(gtk_widget_destroy),\n\t\t\t\t GTK_OBJECT(dialog));\n\tgtk_widget_show_all(dialog);\n}\n\n\nvoid on_back_clicked(GtkButton * button, gpointer user_data)\n{\n\tenum prop_type ptype;\n\n\tcurrent = current->parent;\n\tptype = current->prompt ? current->prompt->type : P_UNKNOWN;\n\tif (ptype != P_MENU)\n\t\tcurrent = current->parent;\n\tdisplay_tree_part();\n\n\tif (current == &rootmenu)\n\t\tgtk_widget_set_sensitive(back_btn, FALSE);\n}\n\n\nvoid on_load_clicked(GtkButton * button, gpointer user_data)\n{\n\ton_load1_activate(NULL, user_data);\n}\n\n\nvoid on_single_clicked(GtkButton * button, gpointer user_data)\n{\n\tview_mode = SINGLE_VIEW;\n\tgtk_widget_hide(tree1_w);\n\tcurrent = &rootmenu;\n\tdisplay_tree_part();\n}\n\n\nvoid on_split_clicked(GtkButton * button, gpointer user_data)\n{\n\tgint w, h;\n\tview_mode = SPLIT_VIEW;\n\tgtk_widget_show(tree1_w);\n\tgtk_window_get_default_size(GTK_WINDOW(main_wnd), &w, &h);\n\tgtk_paned_set_position(GTK_PANED(hpaned), w / 2);\n\tif (tree2)\n\t\tgtk_tree_store_clear(tree2);\n\tdisplay_list();\n\n\t \n\tgtk_widget_set_sensitive(back_btn, FALSE);\n}\n\n\nvoid on_full_clicked(GtkButton * button, gpointer user_data)\n{\n\tview_mode = FULL_VIEW;\n\tgtk_widget_hide(tree1_w);\n\tif (tree2)\n\t\tgtk_tree_store_clear(tree2);\n\tdisplay_tree(&rootmenu);\n\tgtk_widget_set_sensitive(back_btn, FALSE);\n}\n\n\nvoid on_collapse_clicked(GtkButton * button, gpointer user_data)\n{\n\tgtk_tree_view_collapse_all(GTK_TREE_VIEW(tree2_w));\n}\n\n\nvoid on_expand_clicked(GtkButton * button, gpointer user_data)\n{\n\tgtk_tree_view_expand_all(GTK_TREE_VIEW(tree2_w));\n}\n\n\n \n\n \nstatic void renderer_edited(GtkCellRendererText * cell,\n\t\t\t    const gchar * path_string,\n\t\t\t    const gchar * new_text, gpointer user_data)\n{\n\tGtkTreePath *path = gtk_tree_path_new_from_string(path_string);\n\tGtkTreeIter iter;\n\tconst char *old_def, *new_def;\n\tstruct menu *menu;\n\tstruct symbol *sym;\n\n\tif (!gtk_tree_model_get_iter(model2, &iter, path))\n\t\treturn;\n\n\tgtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\n\tsym = menu->sym;\n\n\tgtk_tree_model_get(model2, &iter, COL_VALUE, &old_def, -1);\n\tnew_def = new_text;\n\n\tsym_set_string_value(sym, new_def);\n\n\tupdate_tree(&rootmenu, NULL);\n\n\tgtk_tree_path_free(path);\n}\n\n \nstatic void change_sym_value(struct menu *menu, gint col)\n{\n\tstruct symbol *sym = menu->sym;\n\ttristate newval;\n\n\tif (!sym)\n\t\treturn;\n\n\tif (col == COL_NO)\n\t\tnewval = no;\n\telse if (col == COL_MOD)\n\t\tnewval = mod;\n\telse if (col == COL_YES)\n\t\tnewval = yes;\n\telse\n\t\treturn;\n\n\tswitch (sym_get_type(sym)) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tif (!sym_tristate_within_range(sym, newval))\n\t\t\tnewval = yes;\n\t\tsym_set_tristate_value(sym, newval);\n\t\tif (view_mode == FULL_VIEW)\n\t\t\tupdate_tree(&rootmenu, NULL);\n\t\telse if (view_mode == SPLIT_VIEW) {\n\t\t\tupdate_tree(browsed, NULL);\n\t\t\tdisplay_list();\n\t\t}\n\t\telse if (view_mode == SINGLE_VIEW)\n\t\t\tdisplay_tree_part();\t\n\t\tbreak;\n\tcase S_INT:\n\tcase S_HEX:\n\tcase S_STRING:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void toggle_sym_value(struct menu *menu)\n{\n\tif (!menu->sym)\n\t\treturn;\n\n\tsym_toggle_tristate_value(menu->sym);\n\tif (view_mode == FULL_VIEW)\n\t\tupdate_tree(&rootmenu, NULL);\n\telse if (view_mode == SPLIT_VIEW) {\n\t\tupdate_tree(browsed, NULL);\n\t\tdisplay_list();\n\t}\n\telse if (view_mode == SINGLE_VIEW)\n\t\tdisplay_tree_part();\t\n}\n\nstatic gint column2index(GtkTreeViewColumn * column)\n{\n\tgint i;\n\n\tfor (i = 0; i < COL_NUMBER; i++) {\n\t\tGtkTreeViewColumn *col;\n\n\t\tcol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), i);\n\t\tif (col == column)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\n\n \ngboolean\non_treeview2_button_press_event(GtkWidget * widget,\n\t\t\t\tGdkEventButton * event, gpointer user_data)\n{\n\tGtkTreeView *view = GTK_TREE_VIEW(widget);\n\tGtkTreePath *path;\n\tGtkTreeViewColumn *column;\n\tGtkTreeIter iter;\n\tstruct menu *menu;\n\tgint col;\n\n#if GTK_CHECK_VERSION(2,1,4) \n\tgint tx = (gint) event->x;\n\tgint ty = (gint) event->y;\n\tgint cx, cy;\n\n\tgtk_tree_view_get_path_at_pos(view, tx, ty, &path, &column, &cx,\n\t\t\t\t      &cy);\n#else\n\tgtk_tree_view_get_cursor(view, &path, &column);\n#endif\n\tif (path == NULL)\n\t\treturn FALSE;\n\n\tif (!gtk_tree_model_get_iter(model2, &iter, path))\n\t\treturn FALSE;\n\tgtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\n\n\tcol = column2index(column);\n\tif (event->type == GDK_2BUTTON_PRESS) {\n\t\tenum prop_type ptype;\n\t\tptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\n\t\tif (ptype == P_MENU && view_mode != FULL_VIEW && col == COL_OPTION) {\n\t\t\t\n\t\t\tcurrent = menu;\n\t\t\tdisplay_tree_part();\n\t\t\tgtk_widget_set_sensitive(back_btn, TRUE);\n\t\t} else if (col == COL_OPTION) {\n\t\t\ttoggle_sym_value(menu);\n\t\t\tgtk_tree_view_expand_row(view, path, TRUE);\n\t\t}\n\t} else {\n\t\tif (col == COL_VALUE) {\n\t\t\ttoggle_sym_value(menu);\n\t\t\tgtk_tree_view_expand_row(view, path, TRUE);\n\t\t} else if (col == COL_NO || col == COL_MOD\n\t\t\t   || col == COL_YES) {\n\t\t\tchange_sym_value(menu, col);\n\t\t\tgtk_tree_view_expand_row(view, path, TRUE);\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n \ngboolean\non_treeview2_key_press_event(GtkWidget * widget,\n\t\t\t     GdkEventKey * event, gpointer user_data)\n{\n\tGtkTreeView *view = GTK_TREE_VIEW(widget);\n\tGtkTreePath *path;\n\tGtkTreeViewColumn *column;\n\tGtkTreeIter iter;\n\tstruct menu *menu;\n\tgint col;\n\n\tgtk_tree_view_get_cursor(view, &path, &column);\n\tif (path == NULL)\n\t\treturn FALSE;\n\n\tif (event->keyval == GDK_space) {\n\t\tif (gtk_tree_view_row_expanded(view, path))\n\t\t\tgtk_tree_view_collapse_row(view, path);\n\t\telse\n\t\t\tgtk_tree_view_expand_row(view, path, FALSE);\n\t\treturn TRUE;\n\t}\n\tif (event->keyval == GDK_KP_Enter) {\n\t}\n\tif (widget == tree1_w)\n\t\treturn FALSE;\n\n\tgtk_tree_model_get_iter(model2, &iter, path);\n\tgtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\n\n\tif (!strcasecmp(event->string, \"n\"))\n\t\tcol = COL_NO;\n\telse if (!strcasecmp(event->string, \"m\"))\n\t\tcol = COL_MOD;\n\telse if (!strcasecmp(event->string, \"y\"))\n\t\tcol = COL_YES;\n\telse\n\t\tcol = -1;\n\tchange_sym_value(menu, col);\n\n\treturn FALSE;\n}\n\n\n \nvoid\non_treeview2_cursor_changed(GtkTreeView * treeview, gpointer user_data)\n{\n\tGtkTreeSelection *selection;\n\tGtkTreeIter iter;\n\tstruct menu *menu;\n\n\tselection = gtk_tree_view_get_selection(treeview);\n\tif (gtk_tree_selection_get_selected(selection, &model2, &iter)) {\n\t\tgtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\n\t\ttext_insert_help(menu);\n\t}\n}\n\n\n \ngboolean\non_treeview1_button_press_event(GtkWidget * widget,\n\t\t\t\tGdkEventButton * event, gpointer user_data)\n{\n\tGtkTreeView *view = GTK_TREE_VIEW(widget);\n\tGtkTreePath *path;\n\tGtkTreeViewColumn *column;\n\tGtkTreeIter iter;\n\tstruct menu *menu;\n\n\tgint tx = (gint) event->x;\n\tgint ty = (gint) event->y;\n\tgint cx, cy;\n\n\tgtk_tree_view_get_path_at_pos(view, tx, ty, &path, &column, &cx,\n\t\t\t\t      &cy);\n\tif (path == NULL)\n\t\treturn FALSE;\n\n\tgtk_tree_model_get_iter(model1, &iter, path);\n\tgtk_tree_model_get(model1, &iter, COL_MENU, &menu, -1);\n\n\tif (event->type == GDK_2BUTTON_PRESS) {\n\t\ttoggle_sym_value(menu);\n\t\tcurrent = menu;\n\t\tdisplay_tree_part();\n\t} else {\n\t\tbrowsed = menu;\n\t\tdisplay_tree_part();\n\t}\n\n\tgtk_widget_realize(tree2_w);\n\tgtk_tree_view_set_cursor(view, path, NULL, FALSE);\n\tgtk_widget_grab_focus(tree2_w);\n\n\treturn FALSE;\n}\n\n\n \nstatic gchar **fill_row(struct menu *menu)\n{\n\tstatic gchar *row[COL_NUMBER];\n\tstruct symbol *sym = menu->sym;\n\tconst char *def;\n\tint stype;\n\ttristate val;\n\tenum prop_type ptype;\n\tint i;\n\n\tfor (i = COL_OPTION; i <= COL_COLOR; i++)\n\t\tg_free(row[i]);\n\tbzero(row, sizeof(row));\n\n\tptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\n\trow[COL_OPTION] =\n\t    g_strdup_printf(\"%s %s %s %s\",\n\t\t\t    ptype == P_COMMENT ? \"***\" : \"\",\n\t\t\t    menu_get_prompt(menu),\n\t\t\t    ptype == P_COMMENT ? \"***\" : \"\",\n\t\t\t    sym && !sym_has_value(sym) ? \"(NEW)\" : \"\");\n\n\tif (opt_mode == OPT_ALL && !menu_is_visible(menu))\n\t\trow[COL_COLOR] = g_strdup(\"DarkGray\");\n\telse if (opt_mode == OPT_PROMPT &&\n\t\t\tmenu_has_prompt(menu) && !menu_is_visible(menu))\n\t\trow[COL_COLOR] = g_strdup(\"DarkGray\");\n\telse\n\t\trow[COL_COLOR] = g_strdup(\"Black\");\n\n\tswitch (ptype) {\n\tcase P_MENU:\n\t\trow[COL_PIXBUF] = (gchar *) xpm_menu;\n\t\tif (view_mode == SINGLE_VIEW)\n\t\t\trow[COL_PIXVIS] = GINT_TO_POINTER(TRUE);\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\n\t\tbreak;\n\tcase P_COMMENT:\n\t\trow[COL_PIXBUF] = (gchar *) xpm_void;\n\t\trow[COL_PIXVIS] = GINT_TO_POINTER(FALSE);\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\n\t\tbreak;\n\tdefault:\n\t\trow[COL_PIXBUF] = (gchar *) xpm_void;\n\t\trow[COL_PIXVIS] = GINT_TO_POINTER(FALSE);\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(TRUE);\n\t\tbreak;\n\t}\n\n\tif (!sym)\n\t\treturn row;\n\trow[COL_NAME] = g_strdup(sym->name);\n\n\tsym_calc_value(sym);\n\tsym->flags &= ~SYMBOL_CHANGED;\n\n\tif (sym_is_choice(sym)) {\t\n\t\tstruct menu *child;\n\t\tstruct symbol *def_sym = sym_get_choice_value(sym);\n\t\tstruct menu *def_menu = NULL;\n\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\n\n\t\tfor (child = menu->list; child; child = child->next) {\n\t\t\tif (menu_is_visible(child)\n\t\t\t    && child->sym == def_sym)\n\t\t\t\tdef_menu = child;\n\t\t}\n\n\t\tif (def_menu)\n\t\t\trow[COL_VALUE] =\n\t\t\t    g_strdup(menu_get_prompt(def_menu));\n\t}\n\tif (sym->flags & SYMBOL_CHOICEVAL)\n\t\trow[COL_BTNRAD] = GINT_TO_POINTER(TRUE);\n\n\tstype = sym_get_type(sym);\n\tswitch (stype) {\n\tcase S_BOOLEAN:\n\t\tif (GPOINTER_TO_INT(row[COL_PIXVIS]) == FALSE)\n\t\t\trow[COL_BTNVIS] = GINT_TO_POINTER(TRUE);\n\t\tif (sym_is_choice(sym))\n\t\t\tbreak;\n\t\t \n\tcase S_TRISTATE:\n\t\tval = sym_get_tristate_value(sym);\n\t\tswitch (val) {\n\t\tcase no:\n\t\t\trow[COL_NO] = g_strdup(\"N\");\n\t\t\trow[COL_VALUE] = g_strdup(\"N\");\n\t\t\trow[COL_BTNACT] = GINT_TO_POINTER(FALSE);\n\t\t\trow[COL_BTNINC] = GINT_TO_POINTER(FALSE);\n\t\t\tbreak;\n\t\tcase mod:\n\t\t\trow[COL_MOD] = g_strdup(\"M\");\n\t\t\trow[COL_VALUE] = g_strdup(\"M\");\n\t\t\trow[COL_BTNINC] = GINT_TO_POINTER(TRUE);\n\t\t\tbreak;\n\t\tcase yes:\n\t\t\trow[COL_YES] = g_strdup(\"Y\");\n\t\t\trow[COL_VALUE] = g_strdup(\"Y\");\n\t\t\trow[COL_BTNACT] = GINT_TO_POINTER(TRUE);\n\t\t\trow[COL_BTNINC] = GINT_TO_POINTER(FALSE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val != no && sym_tristate_within_range(sym, no))\n\t\t\trow[COL_NO] = g_strdup(\"_\");\n\t\tif (val != mod && sym_tristate_within_range(sym, mod))\n\t\t\trow[COL_MOD] = g_strdup(\"_\");\n\t\tif (val != yes && sym_tristate_within_range(sym, yes))\n\t\t\trow[COL_YES] = g_strdup(\"_\");\n\t\tbreak;\n\tcase S_INT:\n\tcase S_HEX:\n\tcase S_STRING:\n\t\tdef = sym_get_string_value(sym);\n\t\trow[COL_VALUE] = g_strdup(def);\n\t\trow[COL_EDIT] = GINT_TO_POINTER(TRUE);\n\t\trow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\n\t\tbreak;\n\t}\n\n\treturn row;\n}\n\n\n \nstatic void set_node(GtkTreeIter * node, struct menu *menu, gchar ** row)\n{\n\tGdkColor color;\n\tgboolean success;\n\tGdkPixbuf *pix;\n\n\tpix = gdk_pixbuf_new_from_xpm_data((const char **)\n\t\t\t\t\t   row[COL_PIXBUF]);\n\n\tgdk_color_parse(row[COL_COLOR], &color);\n\tgdk_colormap_alloc_colors(gdk_colormap_get_system(), &color, 1,\n\t\t\t\t  FALSE, FALSE, &success);\n\n\tgtk_tree_store_set(tree, node,\n\t\t\t   COL_OPTION, row[COL_OPTION],\n\t\t\t   COL_NAME, row[COL_NAME],\n\t\t\t   COL_NO, row[COL_NO],\n\t\t\t   COL_MOD, row[COL_MOD],\n\t\t\t   COL_YES, row[COL_YES],\n\t\t\t   COL_VALUE, row[COL_VALUE],\n\t\t\t   COL_MENU, (gpointer) menu,\n\t\t\t   COL_COLOR, &color,\n\t\t\t   COL_EDIT, GPOINTER_TO_INT(row[COL_EDIT]),\n\t\t\t   COL_PIXBUF, pix,\n\t\t\t   COL_PIXVIS, GPOINTER_TO_INT(row[COL_PIXVIS]),\n\t\t\t   COL_BTNVIS, GPOINTER_TO_INT(row[COL_BTNVIS]),\n\t\t\t   COL_BTNACT, GPOINTER_TO_INT(row[COL_BTNACT]),\n\t\t\t   COL_BTNINC, GPOINTER_TO_INT(row[COL_BTNINC]),\n\t\t\t   COL_BTNRAD, GPOINTER_TO_INT(row[COL_BTNRAD]),\n\t\t\t   -1);\n\n\tg_object_unref(pix);\n}\n\n\n \nstatic void place_node(struct menu *menu, char **row)\n{\n\tGtkTreeIter *parent = parents[indent - 1];\n\tGtkTreeIter *node = parents[indent];\n\n\tgtk_tree_store_append(tree, node, parent);\n\tset_node(node, menu, row);\n}\n\n\n \nstatic GtkTreeIter found;\n\n \nstatic GtkTreeIter *gtktree_iter_find_node(GtkTreeIter *parent,\n\t\t\t\t\t   struct menu *tofind)\n{\n\tGtkTreeIter iter;\n\tGtkTreeIter *child = &iter;\n\tgboolean valid;\n\tGtkTreeIter *ret;\n\n\tvalid = gtk_tree_model_iter_children(model2, child, parent);\n\twhile (valid) {\n\t\tstruct menu *menu;\n\n\t\tgtk_tree_model_get(model2, child, 6, &menu, -1);\n\n\t\tif (menu == tofind) {\n\t\t\tmemcpy(&found, child, sizeof(GtkTreeIter));\n\t\t\treturn &found;\n\t\t}\n\n\t\tret = gtktree_iter_find_node(child, tofind);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvalid = gtk_tree_model_iter_next(model2, child);\n\t}\n\n\treturn NULL;\n}\n\n\n \nstatic void update_tree(struct menu *src, GtkTreeIter * dst)\n{\n\tstruct menu *child1;\n\tGtkTreeIter iter, tmp;\n\tGtkTreeIter *child2 = &iter;\n\tgboolean valid;\n\tGtkTreeIter *sibling;\n\tstruct symbol *sym;\n\tstruct menu *menu1, *menu2;\n\n\tif (src == &rootmenu)\n\t\tindent = 1;\n\n\tvalid = gtk_tree_model_iter_children(model2, child2, dst);\n\tfor (child1 = src->list; child1; child1 = child1->next) {\n\n\t\tsym = child1->sym;\n\n\t      reparse:\n\t\tmenu1 = child1;\n\t\tif (valid)\n\t\t\tgtk_tree_model_get(model2, child2, COL_MENU,\n\t\t\t\t\t   &menu2, -1);\n\t\telse\n\t\t\tmenu2 = NULL;\t\n\n#ifdef DEBUG\n\t\tprintf(\"%*c%s | %s\\n\", indent, ' ',\n\t\t       menu1 ? menu_get_prompt(menu1) : \"nil\",\n\t\t       menu2 ? menu_get_prompt(menu2) : \"nil\");\n#endif\n\n\t\tif ((opt_mode == OPT_NORMAL && !menu_is_visible(child1)) ||\n\t\t    (opt_mode == OPT_PROMPT && !menu_has_prompt(child1)) ||\n\t\t    (opt_mode == OPT_ALL    && !menu_get_prompt(child1))) {\n\n\t\t\t \n\t\t\tif (gtktree_iter_find_node(dst, menu1) != NULL) {\n\t\t\t\tmemcpy(&tmp, child2, sizeof(GtkTreeIter));\n\t\t\t\tvalid = gtk_tree_model_iter_next(model2,\n\t\t\t\t\t\t\t\t child2);\n\t\t\t\tgtk_tree_store_remove(tree2, &tmp);\n\t\t\t\tif (!valid)\n\t\t\t\t\treturn;\t\t \n\t\t\t\telse\n\t\t\t\t\tgoto reparse;\t \n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (menu1 != menu2) {\n\t\t\tif (gtktree_iter_find_node(dst, menu1) == NULL) {\t\n\t\t\t\tif (!valid && !menu2)\n\t\t\t\t\tsibling = NULL;\n\t\t\t\telse\n\t\t\t\t\tsibling = child2;\n\t\t\t\tgtk_tree_store_insert_before(tree2,\n\t\t\t\t\t\t\t     child2,\n\t\t\t\t\t\t\t     dst, sibling);\n\t\t\t\tset_node(child2, menu1, fill_row(menu1));\n\t\t\t\tif (menu2 == NULL)\n\t\t\t\t\tvalid = TRUE;\n\t\t\t} else {\t\n\t\t\t\tmemcpy(&tmp, child2, sizeof(GtkTreeIter));\n\t\t\t\tvalid = gtk_tree_model_iter_next(model2,\n\t\t\t\t\t\t\t\t child2);\n\t\t\t\tgtk_tree_store_remove(tree2, &tmp);\n\t\t\t\tif (!valid)\n\t\t\t\t\treturn;\t\n\t\t\t\telse\n\t\t\t\t\tgoto reparse;\t\n\t\t\t}\n\t\t} else if (sym && (sym->flags & SYMBOL_CHANGED)) {\n\t\t\tset_node(child2, menu1, fill_row(menu1));\n\t\t}\n\n\t\tindent++;\n\t\tupdate_tree(child1, child2);\n\t\tindent--;\n\n\t\tvalid = gtk_tree_model_iter_next(model2, child2);\n\t}\n}\n\n\n \nstatic void display_tree(struct menu *menu)\n{\n\tstruct symbol *sym;\n\tstruct property *prop;\n\tstruct menu *child;\n\tenum prop_type ptype;\n\n\tif (menu == &rootmenu) {\n\t\tindent = 1;\n\t\tcurrent = &rootmenu;\n\t}\n\n\tfor (child = menu->list; child; child = child->next) {\n\t\tprop = child->prompt;\n\t\tsym = child->sym;\n\t\tptype = prop ? prop->type : P_UNKNOWN;\n\n\t\tif (sym)\n\t\t\tsym->flags &= ~SYMBOL_CHANGED;\n\n\t\tif ((view_mode == SPLIT_VIEW)\n\t\t    && !(child->flags & MENU_ROOT) && (tree == tree1))\n\t\t\tcontinue;\n\n\t\tif ((view_mode == SPLIT_VIEW) && (child->flags & MENU_ROOT)\n\t\t    && (tree == tree2))\n\t\t\tcontinue;\n\n\t\tif ((opt_mode == OPT_NORMAL && menu_is_visible(child)) ||\n\t\t    (opt_mode == OPT_PROMPT && menu_has_prompt(child)) ||\n\t\t    (opt_mode == OPT_ALL    && menu_get_prompt(child)))\n\t\t\tplace_node(child, fill_row(child));\n#ifdef DEBUG\n\t\tprintf(\"%*c%s: \", indent, ' ', menu_get_prompt(child));\n\t\tprintf(\"%s\", child->flags & MENU_ROOT ? \"rootmenu | \" : \"\");\n\t\tprintf(\"%s\", prop_get_type_name(ptype));\n\t\tprintf(\" | \");\n\t\tif (sym) {\n\t\t\tprintf(\"%s\", sym_type_name(sym->type));\n\t\t\tprintf(\" | \");\n\t\t\tprintf(\"%s\", dbg_sym_flags(sym->flags));\n\t\t\tprintf(\"\\n\");\n\t\t} else\n\t\t\tprintf(\"\\n\");\n#endif\n\t\tif ((view_mode != FULL_VIEW) && (ptype == P_MENU)\n\t\t    && (tree == tree2))\n\t\t\tcontinue;\n \n\n\t\t \n\t\tif (view_mode == SINGLE_VIEW || view_mode == FULL_VIEW) {\n\t\t\tgtk_paned_set_position(GTK_PANED(hpaned), 0);\n\t\t}\n\n\t\tif (((view_mode == SINGLE_VIEW) && (menu->flags & MENU_ROOT))\n\t\t    || (view_mode == FULL_VIEW)\n\t\t    || (view_mode == SPLIT_VIEW)) {\n\t\t\tindent++;\n\t\t\tdisplay_tree(child);\n\t\t\tindent--;\n\t\t}\n\t}\n}\n\n \nstatic void display_tree_part(void)\n{\n\tif (tree2)\n\t\tgtk_tree_store_clear(tree2);\n\tif (view_mode == SINGLE_VIEW)\n\t\tdisplay_tree(current);\n\telse if (view_mode == SPLIT_VIEW)\n\t\tdisplay_tree(browsed);\n\tgtk_tree_view_expand_all(GTK_TREE_VIEW(tree2_w));\n}\n\n \nstatic void display_list(void)\n{\n\tif (tree1)\n\t\tgtk_tree_store_clear(tree1);\n\n\ttree = tree1;\n\tdisplay_tree(&rootmenu);\n\tgtk_tree_view_expand_all(GTK_TREE_VIEW(tree1_w));\n\ttree = tree2;\n}\n\nstatic void fixup_rootmenu(struct menu *menu)\n{\n\tstruct menu *child;\n\tstatic int menu_cnt = 0;\n\n\tmenu->flags |= MENU_ROOT;\n\tfor (child = menu->list; child; child = child->next) {\n\t\tif (child->prompt && child->prompt->type == P_MENU) {\n\t\t\tmenu_cnt++;\n\t\t\tfixup_rootmenu(child);\n\t\t\tmenu_cnt--;\n\t\t} else if (!menu_cnt)\n\t\t\tfixup_rootmenu(child);\n\t}\n}\n\n\n \nint main(int ac, char *av[])\n{\n\tconst char *name;\n\tchar *env;\n\tgchar *glade_file;\n\n\t \n\tgtk_set_locale();\n\tgtk_init(&ac, &av);\n\tglade_init();\n\n\t \n\tenv = getenv(SRCTREE);\n\tif (env)\n\t\tglade_file = g_strconcat(env, \"/scripts/kconfig/gconf.glade\", NULL);\n\telse if (av[0][0] == '/')\n\t\tglade_file = g_strconcat(av[0], \".glade\", NULL);\n\telse\n\t\tglade_file = g_strconcat(g_get_current_dir(), \"/\", av[0], \".glade\", NULL);\n\n\t \n\tif (ac > 1 && av[1][0] == '-') {\n\t\tswitch (av[1][1]) {\n\t\tcase 'a':\n\t\t\t\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tconf_set_message_callback(NULL);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tprintf(\"%s [-s] <config>\\n\", av[0]);\n\t\t\texit(0);\n\t\t}\n\t\tname = av[2];\n\t} else\n\t\tname = av[1];\n\n\tconf_parse(name);\n\tfixup_rootmenu(&rootmenu);\n\tconf_read(NULL);\n\n\t \n\tinit_main_window(glade_file);\n\tinit_tree_model();\n\tinit_left_tree();\n\tinit_right_tree();\n\n\tswitch (view_mode) {\n\tcase SINGLE_VIEW:\n\t\tdisplay_tree_part();\n\t\tbreak;\n\tcase SPLIT_VIEW:\n\t\tdisplay_list();\n\t\tbreak;\n\tcase FULL_VIEW:\n\t\tdisplay_tree(&rootmenu);\n\t\tbreak;\n\t}\n\n\tgtk_main();\n\n\treturn 0;\n}\n\nstatic void conf_changed(void)\n{\n\tbool changed = conf_get_changed();\n\tgtk_widget_set_sensitive(save_btn, changed);\n\tgtk_widget_set_sensitive(save_menu_item, changed);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}