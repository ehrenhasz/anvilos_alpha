{
  "module_name": "streamline_config.pl",
  "hash_id": "d9ad51d5b4ee2357b9818ca33ddbeb96198a066257f12336f8545a4b6f856a6f",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/streamline_config.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright 2005-2009 - Steven Rostedt\n#\n#  It's simple enough to figure out how this works.\n#  If not, then you can ask me at stripconfig@goodmis.org\n#\n# What it does?\n#\n#   If you have installed a Linux kernel from a distribution\n#   that turns on way too many modules than you need, and\n#   you only want the modules you use, then this program\n#   is perfect for you.\n#\n#   It gives you the ability to turn off all the modules that are\n#   not loaded on your system.\n#\n# Howto:\n#\n#  1. Boot up the kernel that you want to stream line the config on.\n#  2. Change directory to the directory holding the source of the\n#       kernel that you just booted.\n#  3. Copy the configuration file to this directory as .config\n#  4. Have all your devices that you need modules for connected and\n#      operational (make sure that their corresponding modules are loaded)\n#  5. Run this script redirecting the output to some other file\n#       like config_strip.\n#  6. Back up your old config (if you want too).\n#  7. copy the config_strip file to .config\n#  8. Run \"make oldconfig\"\n#\n#  Now your kernel is ready to be built with only the modules that\n#  are loaded.\n#\n# Here's what I did with my Debian distribution.\n#\n#    cd /usr/src/linux-2.6.10\n#    cp /boot/config-2.6.10-1-686-smp .config\n#    ~/bin/streamline_config > config_strip\n#    mv .config config_sav\n#    mv config_strip .config\n#    make oldconfig\n#\nuse warnings;\nuse strict;\nuse Getopt::Long;\n\n# set the environment variable LOCALMODCONFIG_DEBUG to get\n# debug output.\nmy $debugprint = 0;\n$debugprint = 1 if (defined($ENV{LOCALMODCONFIG_DEBUG}));\n\nsub dprint {\n    return if (!$debugprint);\n    print STDERR @_;\n}\n\nmy $uname = `uname -r`;\nchomp $uname;\n\nmy @searchconfigs = (\n\t{\n\t    \"file\" => \".config\",\n\t    \"exec\" => \"cat\",\n\t},\n\t{\n\t    \"file\" => \"/proc/config.gz\",\n\t    \"exec\" => \"zcat\",\n\t},\n\t{\n\t    \"file\" => \"/boot/config-$uname\",\n\t    \"exec\" => \"cat\",\n\t},\n\t{\n\t    \"file\" => \"/boot/vmlinuz-$uname\",\n\t    \"exec\" => \"scripts/extract-ikconfig\",\n\t    \"test\" => \"scripts/extract-ikconfig\",\n\t},\n\t{\n\t    \"file\" => \"vmlinux\",\n\t    \"exec\" => \"scripts/extract-ikconfig\",\n\t    \"test\" => \"scripts/extract-ikconfig\",\n\t},\n\t{\n\t    \"file\" => \"/lib/modules/$uname/kernel/kernel/configs.ko\",\n\t    \"exec\" => \"scripts/extract-ikconfig\",\n\t    \"test\" => \"scripts/extract-ikconfig\",\n\t},\n\t{\n\t    \"file\" => \"kernel/configs.ko\",\n\t    \"exec\" => \"scripts/extract-ikconfig\",\n\t    \"test\" => \"scripts/extract-ikconfig\",\n\t},\n\t{\n\t    \"file\" => \"kernel/configs.o\",\n\t    \"exec\" => \"scripts/extract-ikconfig\",\n\t    \"test\" => \"scripts/extract-ikconfig\",\n\t},\n);\n\nsub read_config {\n    foreach my $conf (@searchconfigs) {\n\tmy $file = $conf->{\"file\"};\n\n\tnext if ( ! -f \"$file\");\n\n\tif (defined($conf->{\"test\"})) {\n\t    `$conf->{\"test\"} $conf->{\"file\"} 2>/dev/null`;\n\t    next if ($?);\n\t}\n\n\tmy $exec = $conf->{\"exec\"};\n\n\tprint STDERR \"using config: '$file'\\n\";\n\n\topen(my $infile, '-|', \"$exec $file\") || die \"Failed to run $exec $file\";\n\tmy @x = <$infile>;\n\tclose $infile;\n\treturn @x;\n    }\n    die \"No config file found\";\n}\n\nmy @config_file = read_config;\n\n# Parse options\nmy $localmodconfig = 0;\nmy $localyesconfig = 0;\n\nGetOptions(\"localmodconfig\" => \\$localmodconfig,\n\t   \"localyesconfig\" => \\$localyesconfig);\n\n# Get the build source and top level Kconfig file (passed in)\nmy $ksource = ($ARGV[0] ? $ARGV[0] : '.');\nmy $kconfig = $ARGV[1];\nmy $lsmod_file = $ENV{'LSMOD'};\n\nmy @makefiles = `find $ksource -name Makefile -or -name Kbuild 2>/dev/null`;\nchomp @makefiles;\n\nmy %depends;\nmy %selects;\nmy %prompts;\nmy %objects;\nmy %config2kfile;\nmy $var;\nmy $iflevel = 0;\nmy @ifdeps;\n\n# prevent recursion\nmy %read_kconfigs;\n\nsub read_kconfig {\n    my ($kconfig) = @_;\n\n    my $state = \"NONE\";\n    my $config;\n\n    my $cont = 0;\n    my $line;\n\n    my $source = \"$ksource/$kconfig\";\n    my $last_source = \"\";\n\n    # Check for any environment variables used\n    while ($source =~ /\\$\\((\\w+)\\)/ && $last_source ne $source) {\n\tmy $env = $1;\n\t$last_source = $source;\n\t$source =~ s/\\$\\($env\\)/$ENV{$env}/;\n    }\n\n    open(my $kinfile, '<', $source) || die \"Can't open $source\";\n    while (<$kinfile>) {\n\tchomp;\n\n\t# Make sure that lines ending with \\ continue\n\tif ($cont) {\n\t    $_ = $line . \" \" . $_;\n\t}\n\n\tif (s/\\\\$//) {\n\t    $cont = 1;\n\t    $line = $_;\n\t    next;\n\t}\n\n\t$cont = 0;\n\n\t# collect any Kconfig sources\n\tif (/^source\\s+\"?([^\"]+)/) {\n\t    my $kconfig = $1;\n\t    # prevent reading twice.\n\t    if (!defined($read_kconfigs{$kconfig})) {\n\t\t$read_kconfigs{$kconfig} = 1;\n\t\tread_kconfig($kconfig);\n\t    }\n\t    next;\n\t}\n\n\t# configs found\n\tif (/^\\s*(menu)?config\\s+(\\S+)\\s*$/) {\n\t    $state = \"NEW\";\n\t    $config = $2;\n\t    $config2kfile{\"CONFIG_$config\"} = $kconfig;\n\n\t    # Add depends for 'if' nesting\n\t    for (my $i = 0; $i < $iflevel; $i++) {\n\t\tif ($i) {\n\t\t    $depends{$config} .= \" \" . $ifdeps[$i];\n\t\t} else {\n\t\t    $depends{$config} = $ifdeps[$i];\n\t\t}\n\t\t$state = \"DEP\";\n\t    }\n\n\t# collect the depends for the config\n\t} elsif ($state eq \"NEW\" && /^\\s*depends\\s+on\\s+(.*)$/) {\n\t    $state = \"DEP\";\n\t    $depends{$config} = $1;\n\t} elsif ($state eq \"DEP\" && /^\\s*depends\\s+on\\s+(.*)$/) {\n\t    $depends{$config} .= \" \" . $1;\n\t} elsif ($state eq \"DEP\" && /^\\s*def(_(bool|tristate)|ault)\\s+(\\S.*)$/) {\n\t    my $dep = $3;\n\t    if ($dep !~ /^\\s*(y|m|n)\\s*$/) {\n\t\t$dep =~ s/.*\\sif\\s+//;\n\t\t$depends{$config} .= \" \" . $dep;\n\t\tdprint \"Added default depends $dep to $config\\n\";\n\t    }\n\n\t# Get the configs that select this config\n\t} elsif ($state ne \"NONE\" && /^\\s*select\\s+(\\S+)/) {\n\t    my $conf = $1;\n\t    if (defined($selects{$conf})) {\n\t\t$selects{$conf} .= \" \" . $config;\n\t    } else {\n\t\t$selects{$conf} = $config;\n\t    }\n\n\t# configs without prompts must be selected\n\t} elsif ($state ne \"NONE\" && /^\\s*(tristate\\s+\\S|prompt\\b)/) {\n\t    # note if the config has a prompt\n\t    $prompts{$config} = 1;\n\n\t# Check for if statements\n\t} elsif (/^if\\s+(.*\\S)\\s*$/) {\n\t    my $deps = $1;\n\t    # remove beginning and ending non text\n\t    $deps =~ s/^[^a-zA-Z0-9_]*//;\n\t    $deps =~ s/[^a-zA-Z0-9_]*$//;\n\n\t    my @deps = split /[^a-zA-Z0-9_]+/, $deps;\n\n\t    $ifdeps[$iflevel++] = join ':', @deps;\n\n\t} elsif (/^endif/) {\n\n\t    $iflevel-- if ($iflevel);\n\n\t# stop on \"help\" and keywords that end a menu entry\n\t} elsif (/^\\s*(---)?help(---)?\\s*$/ || /^(comment|choice|menu)\\b/) {\n\t    $state = \"NONE\";\n\t}\n    }\n    close($kinfile);\n}\n\nif ($kconfig) {\n    read_kconfig($kconfig);\n}\n\n# Makefiles can use variables to define their dependencies\nsub convert_vars {\n    my ($line, %vars) = @_;\n\n    my $process = \"\";\n\n    while ($line =~ s/^(.*?)(\\$\\((.*?)\\))//) {\n\tmy $start = $1;\n\tmy $variable = $2;\n\tmy $var = $3;\n\n\tif (defined($vars{$var})) {\n\t    $process .= $start . $vars{$var};\n\t} else {\n\t    $process .= $start . $variable;\n\t}\n    }\n\n    $process .= $line;\n\n    return $process;\n}\n\n# Read all Makefiles to map the configs to the objects\nforeach my $makefile (@makefiles) {\n\n    my $line = \"\";\n    my %make_vars;\n\n    open(my $infile, '<', $makefile) || die \"Can't open $makefile\";\n    while (<$infile>) {\n\t# if this line ends with a backslash, continue\n\tchomp;\n\tif (/^(.*)\\\\$/) {\n\t    $line .= $1;\n\t    next;\n\t}\n\n\t$line .= $_;\n\t$_ = $line;\n\t$line = \"\";\n\n\tmy $objs;\n\n\t# Convert variables in a line (could define configs)\n\t$_ = convert_vars($_, %make_vars);\n\n\t# collect objects after obj-$(CONFIG_FOO_BAR)\n\tif (/obj-\\$[({](CONFIG_[^})]*)[)}]\\s*[+:]?=\\s*(.*)/) {\n\t    $var = $1;\n\t    $objs = $2;\n\n\t# check if variables are set\n\t} elsif (/^\\s*(\\S+)\\s*[:]?=\\s*(.*\\S)/) {\n\t    $make_vars{$1} = $2;\n\t}\n\tif (defined($objs)) {\n\t    foreach my $obj (split /\\s+/,$objs) {\n\t\t$obj =~ s/-/_/g;\n\t\tif ($obj =~ /(.*)\\.o$/) {\n\t\t    # Objects may be enabled by more than one config.\n\t\t    # Store configs in an array.\n\t\t    my @arr;\n\n\t\t    if (defined($objects{$1})) {\n\t\t\t@arr = @{$objects{$1}};\n\t\t    }\n\n\t\t    $arr[$#arr+1] = $var;\n\n\t\t    # The objects have a hash mapping to a reference\n\t\t    # of an array of configs.\n\t\t    $objects{$1} = \\@arr;\n\t\t}\n\t    }\n\t}\n    }\n    close($infile);\n}\n\nmy %modules;\nmy $linfile;\n\nif (defined($lsmod_file)) {\n    if ( ! -f $lsmod_file) {\n\tif ( -f $ENV{'objtree'}.\"/\".$lsmod_file) {\n\t    $lsmod_file = $ENV{'objtree'}.\"/\".$lsmod_file;\n\t} else {\n\t\tdie \"$lsmod_file not found\";\n\t}\n    }\n\n    my $otype = ( -x $lsmod_file) ? '-|' : '<';\n    open($linfile, $otype, $lsmod_file);\n\n} else {\n\n    # see what modules are loaded on this system\n    my $lsmod;\n\n    foreach my $dir ( (\"/sbin\", \"/bin\", \"/usr/sbin\", \"/usr/bin\") ) {\n\tif ( -x \"$dir/lsmod\" ) {\n\t    $lsmod = \"$dir/lsmod\";\n\t    last;\n\t}\n    }\n    if (!defined($lsmod)) {\n\t# try just the path\n\t$lsmod = \"lsmod\";\n    }\n\n    open($linfile, '-|', $lsmod) || die \"Can not call lsmod with $lsmod\";\n}\n\nwhile (<$linfile>) {\n\tnext if (/^Module/);  # Skip the first line.\n\tif (/^(\\S+)/) {\n\t\t$modules{$1} = 1;\n\t}\n}\nclose ($linfile);\n\n# add to the configs hash all configs that are needed to enable\n# a loaded module. This is a direct obj-${CONFIG_FOO} += bar.o\n# where we know we need bar.o so we add FOO to the list.\nmy %configs;\nforeach my $module (keys(%modules)) {\n    if (defined($objects{$module})) {\n\tmy @arr = @{$objects{$module}};\n\tforeach my $conf (@arr) {\n\t    $configs{$conf} = $module;\n\t    dprint \"$conf added by direct ($module)\\n\";\n\t    if ($debugprint) {\n\t\tmy $c=$conf;\n\t\t$c =~ s/^CONFIG_//;\n\t\tif (defined($depends{$c})) {\n\t\t    dprint \" deps = $depends{$c}\\n\";\n\t\t} else {\n\t\t    dprint \" no deps\\n\";\n\t\t}\n\t    }\n\t}\n    } else {\n\t# Most likely, someone has a custom (binary?) module loaded.\n\tprint STDERR \"$module config not found!!\\n\";\n    }\n}\n\n# Read the current config, and see what is enabled. We want to\n# ignore configs that we would not enable anyway.\n\nmy %orig_configs;\nmy $valid = \"A-Za-z_0-9\";\n\nforeach my $line (@config_file) {\n    $_ = $line;\n\n    if (/(CONFIG_[$valid]*)=(m|y)/) {\n\t$orig_configs{$1} = $2;\n    }\n}\n\nmy $repeat = 1;\n\nmy $depconfig;\n\n#\n# Note, we do not care about operands (like: &&, ||, !) we want to add any\n# config that is in the depend list of another config. This script does\n# not enable configs that are not already enabled. If we come across a\n# config A that depends on !B, we can still add B to the list of depends\n# to keep on. If A was on in the original config, B would not have been\n# and B would not be turned on by this script.\n#\nsub parse_config_depends\n{\n    my ($p) = @_;\n\n    while ($p =~ /[$valid]/) {\n\n\tif ($p =~ /^[^$valid]*([$valid]+)/) {\n\t    my $conf = \"CONFIG_\" . $1;\n\n\t    $p =~ s/^[^$valid]*[$valid]+//;\n\n\t    # We only need to process if the depend config is a module\n\t    if (!defined($orig_configs{$conf}) || $orig_configs{$conf} eq \"y\") {\n\t\tnext;\n\t    }\n\n\t    if (!defined($configs{$conf})) {\n\t\t# We must make sure that this config has its\n\t\t# dependencies met.\n\t\t$repeat = 1; # do again\n\t\tdprint \"$conf selected by depend $depconfig\\n\";\n\t\t$configs{$conf} = 1;\n\t    }\n\t} else {\n\t    die \"this should never happen\";\n\t}\n    }\n}\n\n# Select is treated a bit differently than depends. We call this\n# when a config has no prompt and requires another config to be\n# selected. We use to just select all configs that selected this\n# config, but found that that can balloon into enabling hundreds\n# of configs that we do not care about.\n#\n# The idea is we look at all the configs that select it. If one\n# is already in our list of configs to enable, then there's nothing\n# else to do. If there isn't, we pick the first config that was\n# enabled in the original config and use that.\nsub parse_config_selects\n{\n    my ($config, $p) = @_;\n\n    my $next_config;\n\n    while ($p =~ /[$valid]/) {\n\n\tif ($p =~ /^[^$valid]*([$valid]+)/) {\n\t    my $conf = \"CONFIG_\" . $1;\n\n\t    $p =~ s/^[^$valid]*[$valid]+//;\n\n\t    # Make sure that this config exists in the current .config file\n\t    if (!defined($orig_configs{$conf})) {\n\t\tdprint \"$conf not set for $config select\\n\";\n\t\tnext;\n\t    }\n\n\t    # Check if something other than a module selects this config\n\t    if (defined($orig_configs{$conf}) && $orig_configs{$conf} ne \"m\") {\n\t\tdprint \"$conf (non module) selects config, we are good\\n\";\n\t\t# we are good with this\n\t\treturn;\n\t    }\n\t    if (defined($configs{$conf})) {\n\t\tdprint \"$conf selects $config so we are good\\n\";\n\t\t# A set config selects this config, we are good\n\t\treturn;\n\t    }\n\t    # Set this config to be selected\n\t    if (!defined($next_config)) {\n\t\t$next_config = $conf;\n\t    }\n\t} else {\n\t    die \"this should never happen\";\n\t}\n    }\n\n    # If no possible config selected this, then something happened.\n    if (!defined($next_config)) {\n\tprint STDERR \"WARNING: $config is required, but nothing in the\\n\";\n\tprint STDERR \"  current config selects it.\\n\";\n\treturn;\n    }\n\n    # If we are here, then we found no config that is set and\n    # selects this config. Repeat.\n    $repeat = 1;\n    # Make this config need to be selected\n    $configs{$next_config} = 1;\n    dprint \"$next_config selected by select $config\\n\";\n}\n\nmy %process_selects;\n\n# loop through all configs, select their dependencies.\nsub loop_depend {\n    $repeat = 1;\n\n    while ($repeat) {\n\t$repeat = 0;\n\n      forloop:\n\tforeach my $config (keys %configs) {\n\n\t    # If this config is not a module, we do not need to process it\n\t    if (defined($orig_configs{$config}) && $orig_configs{$config} ne \"m\") {\n\t\tnext forloop;\n\t    }\n\n\t    $config =~ s/^CONFIG_//;\n\t    $depconfig = $config;\n\n\t    if (defined($depends{$config})) {\n\t\t# This config has dependencies. Make sure they are also included\n\t\tparse_config_depends $depends{$config};\n\t    }\n\n\t    # If the config has no prompt, then we need to check if a config\n\t    # that is enabled selected it. Or if we need to enable one.\n\t    if (!defined($prompts{$config}) && defined($selects{$config})) {\n\t\t$process_selects{$config} = 1;\n\t    }\n\t}\n    }\n}\n\nsub loop_select {\n\n    foreach my $config (keys %process_selects) {\n\t$config =~ s/^CONFIG_//;\n\n\tdprint \"Process select $config\\n\";\n\n\t# config has no prompt and must be selected.\n\tparse_config_selects $config, $selects{$config};\n    }\n}\n\nwhile ($repeat) {\n    # Get the first set of configs and their dependencies.\n    loop_depend;\n\n    $repeat = 0;\n\n    # Now we need to see if we have to check selects;\n    loop_select;\n}\n\nmy %setconfigs;\nmy @preserved_kconfigs;\nif (defined($ENV{'LMC_KEEP'})) {\n\t@preserved_kconfigs = split(/:/,$ENV{LMC_KEEP});\n}\n\nsub in_preserved_kconfigs {\n    my $kconfig = $config2kfile{$_[0]};\n    if (!defined($kconfig)) {\n\treturn 0;\n    }\n    foreach my $excl (@preserved_kconfigs) {\n\tif($kconfig =~ /^$excl/) {\n\t    return 1;\n\t}\n    }\n    return 0;\n}\n\n# Finally, read the .config file and turn off any module enabled that\n# we could not find a reason to keep enabled.\nforeach my $line (@config_file) {\n    $_ = $line;\n\n    if (/CONFIG_IKCONFIG/) {\n\tif (/# CONFIG_IKCONFIG is not set/) {\n\t    # enable IKCONFIG at least as a module\n\t    print \"CONFIG_IKCONFIG=m\\n\";\n\t    # don't ask about PROC\n\t    print \"# CONFIG_IKCONFIG_PROC is not set\\n\";\n\t} else {\n\t    print;\n\t}\n\tnext;\n    }\n\n    if (/CONFIG_MODULE_SIG_KEY=\"(.+)\"/) {\n\tmy $orig_cert = $1;\n\tmy $default_cert = \"certs/signing_key.pem\";\n\n\t# Check that the logic in this script still matches the one in Kconfig\n\tif (!defined($depends{\"MODULE_SIG_KEY\"}) ||\n\t    $depends{\"MODULE_SIG_KEY\"} !~ /\"\\Q$default_cert\\E\"/) {\n\t    print STDERR \"WARNING: MODULE_SIG_KEY assertion failure, \",\n\t\t\"update needed to \", __FILE__, \" line \", __LINE__, \"\\n\";\n\t    print;\n\t} elsif ($orig_cert ne $default_cert && ! -f $orig_cert) {\n\t    print STDERR \"Module signature verification enabled but \",\n\t\t\"module signing key \\\"$orig_cert\\\" not found. Resetting \",\n\t\t\"signing key to default value.\\n\";\n\t    print \"CONFIG_MODULE_SIG_KEY=\\\"$default_cert\\\"\\n\";\n\t} else {\n\t    print;\n\t}\n\tnext;\n    }\n\n    if (/CONFIG_SYSTEM_TRUSTED_KEYS=\"(.+)\"/) {\n\tmy $orig_keys = $1;\n\n\tif (! -f $orig_keys) {\n\t    print STDERR \"System keyring enabled but keys \\\"$orig_keys\\\" \",\n\t\t\"not found. Resetting keys to default value.\\n\";\n\t    print \"CONFIG_SYSTEM_TRUSTED_KEYS=\\\"\\\"\\n\";\n\t} else {\n\t    print;\n\t}\n\tnext;\n    }\n\n    if (/^(CONFIG.*)=(m|y)/) {\n\tif (in_preserved_kconfigs($1)) {\n\t    dprint \"Preserve config $1\";\n\t    print;\n\t    next;\n\t}\n\tif (defined($configs{$1})) {\n\t    if ($localyesconfig) {\n\t\t$setconfigs{$1} = 'y';\n\t\tprint \"$1=y\\n\";\n\t\tnext;\n\t    } else {\n\t\t$setconfigs{$1} = $2;\n\t    }\n\t} elsif ($2 eq \"m\") {\n\t    print \"# $1 is not set\\n\";\n\t    next;\n\t}\n    }\n    print;\n}\n\n# Integrity check, make sure all modules that we want enabled do\n# indeed have their configs set.\nloop:\nforeach my $module (keys(%modules)) {\n    if (defined($objects{$module})) {\n\tmy @arr = @{$objects{$module}};\n\tforeach my $conf (@arr) {\n\t    if (defined($setconfigs{$conf})) {\n\t\tnext loop;\n\t    }\n\t}\n\tprint STDERR \"module $module did not have configs\";\n\tforeach my $conf (@arr) {\n\t    print STDERR \" \" , $conf;\n\t}\n\tprint STDERR \"\\n\";\n    }\n}\n\n# vim: softtabstop=4\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}