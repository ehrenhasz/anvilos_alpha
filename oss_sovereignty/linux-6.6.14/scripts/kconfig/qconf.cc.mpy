{
  "module_name": "qconf.cc",
  "hash_id": "6a7d5773fb6c1515813d7b3a33c3efc08c0465231a7477ca1c11dffe0fddb87e",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/qconf.cc",
  "human_readable_source": "\n \n\n#include <QAction>\n#include <QActionGroup>\n#include <QApplication>\n#include <QCloseEvent>\n#include <QDebug>\n#include <QFileDialog>\n#include <QLabel>\n#include <QLayout>\n#include <QList>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMessageBox>\n#include <QRegularExpression>\n#include <QScreen>\n#include <QToolBar>\n\n#include <stdlib.h>\n\n#include \"lkc.h\"\n#include \"qconf.h\"\n\n#include \"images.h\"\n\n\nstatic QApplication *configApp;\nstatic ConfigSettings *configSettings;\n\nQAction *ConfigMainWindow::saveAction;\n\nConfigSettings::ConfigSettings()\n\t: QSettings(\"kernel.org\", \"qconf\")\n{\n}\n\n \nQList<int> ConfigSettings::readSizes(const QString& key, bool *ok)\n{\n\tQList<int> result;\n\n\tif (contains(key))\n\t{\n\t\tQStringList entryList = value(key).toStringList();\n\t\tQStringList::Iterator it;\n\n\t\tfor (it = entryList.begin(); it != entryList.end(); ++it)\n\t\t\tresult.push_back((*it).toInt());\n\n\t\t*ok = true;\n\t}\n\telse\n\t\t*ok = false;\n\n\treturn result;\n}\n\n \nbool ConfigSettings::writeSizes(const QString& key, const QList<int>& value)\n{\n\tQStringList stringList;\n\tQList<int>::ConstIterator it;\n\n\tfor (it = value.begin(); it != value.end(); ++it)\n\t\tstringList.push_back(QString::number(*it));\n\tsetValue(key, stringList);\n\n\treturn true;\n}\n\nQIcon ConfigItem::symbolYesIcon;\nQIcon ConfigItem::symbolModIcon;\nQIcon ConfigItem::symbolNoIcon;\nQIcon ConfigItem::choiceYesIcon;\nQIcon ConfigItem::choiceNoIcon;\nQIcon ConfigItem::menuIcon;\nQIcon ConfigItem::menubackIcon;\n\n \nvoid ConfigItem::updateMenu(void)\n{\n\tConfigList* list;\n\tstruct symbol* sym;\n\tstruct property *prop;\n\tQString prompt;\n\tint type;\n\ttristate expr;\n\n\tlist = listView();\n\tif (goParent) {\n\t\tsetIcon(promptColIdx, menubackIcon);\n\t\tprompt = \"..\";\n\t\tgoto set_prompt;\n\t}\n\n\tsym = menu->sym;\n\tprop = menu->prompt;\n\tprompt = menu_get_prompt(menu);\n\n\tif (prop) switch (prop->type) {\n\tcase P_MENU:\n\t\tif (list->mode == singleMode || list->mode == symbolMode) {\n\t\t\t \n\t\t\tif (sym && list->rootEntry == menu)\n\t\t\t\tbreak;\n\t\t\tsetIcon(promptColIdx, menuIcon);\n\t\t} else {\n\t\t\tif (sym)\n\t\t\t\tbreak;\n\t\t\tsetIcon(promptColIdx, QIcon());\n\t\t}\n\t\tgoto set_prompt;\n\tcase P_COMMENT:\n\t\tsetIcon(promptColIdx, QIcon());\n\t\tprompt = \"*** \" + prompt + \" ***\";\n\t\tgoto set_prompt;\n\tdefault:\n\t\t;\n\t}\n\tif (!sym)\n\t\tgoto set_prompt;\n\n\tsetText(nameColIdx, sym->name);\n\n\ttype = sym_get_type(sym);\n\tswitch (type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tchar ch;\n\n\t\tif (!sym_is_changeable(sym) && list->optMode == normalOpt) {\n\t\t\tsetIcon(promptColIdx, QIcon());\n\t\t\tbreak;\n\t\t}\n\t\texpr = sym_get_tristate_value(sym);\n\t\tswitch (expr) {\n\t\tcase yes:\n\t\t\tif (sym_is_choice_value(sym) && type == S_BOOLEAN)\n\t\t\t\tsetIcon(promptColIdx, choiceYesIcon);\n\t\t\telse\n\t\t\t\tsetIcon(promptColIdx, symbolYesIcon);\n\t\t\tch = 'Y';\n\t\t\tbreak;\n\t\tcase mod:\n\t\t\tsetIcon(promptColIdx, symbolModIcon);\n\t\t\tch = 'M';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (sym_is_choice_value(sym) && type == S_BOOLEAN)\n\t\t\t\tsetIcon(promptColIdx, choiceNoIcon);\n\t\t\telse\n\t\t\t\tsetIcon(promptColIdx, symbolNoIcon);\n\t\t\tch = 'N';\n\t\t\tbreak;\n\t\t}\n\n\t\tsetText(dataColIdx, QChar(ch));\n\t\tbreak;\n\tcase S_INT:\n\tcase S_HEX:\n\tcase S_STRING:\n\t\tsetText(dataColIdx, sym_get_string_value(sym));\n\t\tbreak;\n\t}\n\tif (!sym_has_value(sym) && visible)\n\t\tprompt += \" (NEW)\";\nset_prompt:\n\tsetText(promptColIdx, prompt);\n}\n\nvoid ConfigItem::testUpdateMenu(bool v)\n{\n\tConfigItem* i;\n\n\tvisible = v;\n\tif (!menu)\n\t\treturn;\n\n\tsym_calc_value(menu->sym);\n\tif (menu->flags & MENU_CHANGED) {\n\t\t \n\t\tmenu->flags &= ~MENU_CHANGED;\n\t\tfor (i = (ConfigItem*)menu->data; i; i = i->nextItem)\n\t\t\ti->updateMenu();\n\t} else if (listView()->updateAll)\n\t\tupdateMenu();\n}\n\n\n \nvoid ConfigItem::init(void)\n{\n\tif (menu) {\n\t\tConfigList* list = listView();\n\t\tnextItem = (ConfigItem*)menu->data;\n\t\tmenu->data = this;\n\n\t\tif (list->mode != fullMode)\n\t\t\tsetExpanded(true);\n\t\tsym_calc_value(menu->sym);\n\n\t\tif (menu->sym) {\n\t\t\tenum symbol_type type = menu->sym->type;\n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tif (type == S_INT || type == S_HEX || type == S_STRING)\n\t\t\t\tsetFlags(flags() | Qt::ItemIsEditable);\n\t\t}\n\t}\n\tupdateMenu();\n}\n\n \nConfigItem::~ConfigItem(void)\n{\n\tif (menu) {\n\t\tConfigItem** ip = (ConfigItem**)&menu->data;\n\t\tfor (; *ip; ip = &(*ip)->nextItem) {\n\t\t\tif (*ip == this) {\n\t\t\t\t*ip = nextItem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nQWidget *ConfigItemDelegate::createEditor(QWidget *parent,\n\t\t\t\t\t  const QStyleOptionViewItem &option,\n\t\t\t\t\t  const QModelIndex &index) const\n{\n\tConfigItem *item;\n\n\t \n\tif (index.column() != dataColIdx)\n\t\treturn nullptr;\n\n\t \n\titem = static_cast<ConfigItem *>(index.internalPointer());\n\tif (!item || !item->menu || !menu_is_visible(item->menu))\n\t\treturn nullptr;\n\n\treturn QStyledItemDelegate::createEditor(parent, option, index);\n}\n\nvoid ConfigItemDelegate::setModelData(QWidget *editor,\n\t\t\t\t      QAbstractItemModel *model,\n\t\t\t\t      const QModelIndex &index) const\n{\n\tQLineEdit *lineEdit;\n\tConfigItem *item;\n\tstruct symbol *sym;\n\tbool success;\n\n\tlineEdit = qobject_cast<QLineEdit *>(editor);\n\t \n\t\n\tif (!lineEdit)\n\t\tgoto parent;\n\n\titem = static_cast<ConfigItem *>(index.internalPointer());\n\tif (!item || !item->menu)\n\t\tgoto parent;\n\n\tsym = item->menu->sym;\n\tif (!sym)\n\t\tgoto parent;\n\n\tsuccess = sym_set_string_value(sym, lineEdit->text().toUtf8().data());\n\tif (success) {\n\t\tConfigList::updateListForAll();\n\t} else {\n\t\tQMessageBox::information(editor, \"qconf\",\n\t\t\t\"Cannot set the data (maybe due to out of range).\\n\"\n\t\t\t\"Setting the old value.\");\n\t\tlineEdit->setText(sym_get_string_value(sym));\n\t}\n\nparent:\n\tQStyledItemDelegate::setModelData(editor, model, index);\n}\n\nConfigList::ConfigList(QWidget *parent, const char *name)\n\t: QTreeWidget(parent),\n\t  updateAll(false),\n\t  showName(false), mode(singleMode), optMode(normalOpt),\n\t  rootEntry(0), headerPopup(0)\n{\n\tsetObjectName(name);\n\tsetSortingEnabled(false);\n\tsetRootIsDecorated(true);\n\n\tsetVerticalScrollMode(ScrollPerPixel);\n\tsetHorizontalScrollMode(ScrollPerPixel);\n\n\tsetHeaderLabels(QStringList() << \"Option\" << \"Name\" << \"Value\");\n\n\tconnect(this, &ConfigList::itemSelectionChanged,\n\t\tthis, &ConfigList::updateSelection);\n\n\tif (name) {\n\t\tconfigSettings->beginGroup(name);\n\t\tshowName = configSettings->value(\"/showName\", false).toBool();\n\t\toptMode = (enum optionMode)configSettings->value(\"/optionMode\", 0).toInt();\n\t\tconfigSettings->endGroup();\n\t\tconnect(configApp, &QApplication::aboutToQuit,\n\t\t\tthis, &ConfigList::saveSettings);\n\t}\n\n\tshowColumn(promptColIdx);\n\n\tsetItemDelegate(new ConfigItemDelegate(this));\n\n\tallLists.append(this);\n\n\treinit();\n}\n\nConfigList::~ConfigList()\n{\n\tallLists.removeOne(this);\n}\n\nbool ConfigList::menuSkip(struct menu *menu)\n{\n\tif (optMode == normalOpt && menu_is_visible(menu))\n\t\treturn false;\n\tif (optMode == promptOpt && menu_has_prompt(menu))\n\t\treturn false;\n\tif (optMode == allOpt)\n\t\treturn false;\n\treturn true;\n}\n\nvoid ConfigList::reinit(void)\n{\n\thideColumn(nameColIdx);\n\n\tif (showName)\n\t\tshowColumn(nameColIdx);\n\n\tupdateListAll();\n}\n\nvoid ConfigList::setOptionMode(QAction *action)\n{\n\tif (action == showNormalAction)\n\t\toptMode = normalOpt;\n\telse if (action == showAllAction)\n\t\toptMode = allOpt;\n\telse\n\t\toptMode = promptOpt;\n\n\tupdateListAll();\n}\n\nvoid ConfigList::saveSettings(void)\n{\n\tif (!objectName().isEmpty()) {\n\t\tconfigSettings->beginGroup(objectName());\n\t\tconfigSettings->setValue(\"/showName\", showName);\n\t\tconfigSettings->setValue(\"/optionMode\", (int)optMode);\n\t\tconfigSettings->endGroup();\n\t}\n}\n\nConfigItem* ConfigList::findConfigItem(struct menu *menu)\n{\n\tConfigItem* item = (ConfigItem*)menu->data;\n\n\tfor (; item; item = item->nextItem) {\n\t\tif (this == item->listView())\n\t\t\tbreak;\n\t}\n\n\treturn item;\n}\n\nvoid ConfigList::updateSelection(void)\n{\n\tstruct menu *menu;\n\tenum prop_type type;\n\n\tif (selectedItems().count() == 0)\n\t\treturn;\n\n\tConfigItem* item = (ConfigItem*)selectedItems().first();\n\tif (!item)\n\t\treturn;\n\n\tmenu = item->menu;\n\temit menuChanged(menu);\n\tif (!menu)\n\t\treturn;\n\ttype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\tif (mode == menuMode && type == P_MENU)\n\t\temit menuSelected(menu);\n}\n\nvoid ConfigList::updateList()\n{\n\tConfigItem* last = 0;\n\tConfigItem *item;\n\n\tif (!rootEntry) {\n\t\tif (mode != listMode)\n\t\t\tgoto update;\n\t\tQTreeWidgetItemIterator it(this);\n\n\t\twhile (*it) {\n\t\t\titem = (ConfigItem*)(*it);\n\t\t\tif (!item->menu)\n\t\t\t\tcontinue;\n\t\t\titem->testUpdateMenu(menu_is_visible(item->menu));\n\n\t\t\t++it;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (rootEntry != &rootmenu && (mode == singleMode ||\n\t    (mode == symbolMode && rootEntry->parent != &rootmenu))) {\n\t\titem = (ConfigItem *)topLevelItem(0);\n\t\tif (!item)\n\t\t\titem = new ConfigItem(this, 0, true);\n\t\tlast = item;\n\t}\n\tif ((mode == singleMode || (mode == symbolMode && !(rootEntry->flags & MENU_ROOT))) &&\n\t    rootEntry->sym && rootEntry->prompt) {\n\t\titem = last ? last->nextSibling() : nullptr;\n\t\tif (!item)\n\t\t\titem = new ConfigItem(this, last, rootEntry, true);\n\t\telse\n\t\t\titem->testUpdateMenu(true);\n\n\t\tupdateMenuList(item, rootEntry);\n\t\tupdate();\n\t\tresizeColumnToContents(0);\n\t\treturn;\n\t}\nupdate:\n\tupdateMenuList(rootEntry);\n\tupdate();\n\tresizeColumnToContents(0);\n}\n\nvoid ConfigList::updateListForAll()\n{\n\tQListIterator<ConfigList *> it(allLists);\n\n\twhile (it.hasNext()) {\n\t\tConfigList *list = it.next();\n\n\t\tlist->updateList();\n\t}\n}\n\nvoid ConfigList::updateListAllForAll()\n{\n\tQListIterator<ConfigList *> it(allLists);\n\n\twhile (it.hasNext()) {\n\t\tConfigList *list = it.next();\n\n\t\tlist->updateList();\n\t}\n}\n\nvoid ConfigList::setValue(ConfigItem* item, tristate val)\n{\n\tstruct symbol* sym;\n\tint type;\n\ttristate oldval;\n\n\tsym = item->menu ? item->menu->sym : 0;\n\tif (!sym)\n\t\treturn;\n\n\ttype = sym_get_type(sym);\n\tswitch (type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\toldval = sym_get_tristate_value(sym);\n\n\t\tif (!sym_set_tristate_value(sym, val))\n\t\t\treturn;\n\t\tif (oldval == no && item->menu->list)\n\t\t\titem->setExpanded(true);\n\t\tConfigList::updateListForAll();\n\t\tbreak;\n\t}\n}\n\nvoid ConfigList::changeValue(ConfigItem* item)\n{\n\tstruct symbol* sym;\n\tstruct menu* menu;\n\tint type, oldexpr, newexpr;\n\n\tmenu = item->menu;\n\tif (!menu)\n\t\treturn;\n\tsym = menu->sym;\n\tif (!sym) {\n\t\tif (item->menu->list)\n\t\t\titem->setExpanded(!item->isExpanded());\n\t\treturn;\n\t}\n\n\ttype = sym_get_type(sym);\n\tswitch (type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\toldexpr = sym_get_tristate_value(sym);\n\t\tnewexpr = sym_toggle_tristate_value(sym);\n\t\tif (item->menu->list) {\n\t\t\tif (oldexpr == newexpr)\n\t\t\t\titem->setExpanded(!item->isExpanded());\n\t\t\telse if (oldexpr == no)\n\t\t\t\titem->setExpanded(true);\n\t\t}\n\t\tif (oldexpr != newexpr)\n\t\t\tConfigList::updateListForAll();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid ConfigList::setRootMenu(struct menu *menu)\n{\n\tenum prop_type type;\n\n\tif (rootEntry == menu)\n\t\treturn;\n\ttype = menu && menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\tif (type != P_MENU)\n\t\treturn;\n\tupdateMenuList(0);\n\trootEntry = menu;\n\tupdateListAll();\n\tif (currentItem()) {\n\t\tsetSelected(currentItem(), hasFocus());\n\t\tscrollToItem(currentItem());\n\t}\n}\n\nvoid ConfigList::setParentMenu(void)\n{\n\tConfigItem* item;\n\tstruct menu *oldroot;\n\n\toldroot = rootEntry;\n\tif (rootEntry == &rootmenu)\n\t\treturn;\n\tsetRootMenu(menu_get_parent_menu(rootEntry->parent));\n\n\tQTreeWidgetItemIterator it(this);\n\twhile (*it) {\n\t\titem = (ConfigItem *)(*it);\n\t\tif (item->menu == oldroot) {\n\t\t\tsetCurrentItem(item);\n\t\t\tscrollToItem(item);\n\t\t\tbreak;\n\t\t}\n\n\t\t++it;\n\t}\n}\n\n \nvoid ConfigList::updateMenuList(ConfigItem *parent, struct menu* menu)\n{\n\tstruct menu* child;\n\tConfigItem* item;\n\tConfigItem* last;\n\tbool visible;\n\tenum prop_type type;\n\n\tif (!menu) {\n\t\twhile (parent->childCount() > 0)\n\t\t{\n\t\t\tdelete parent->takeChild(0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tlast = parent->firstChild();\n\tif (last && !last->goParent)\n\t\tlast = 0;\n\tfor (child = menu->list; child; child = child->next) {\n\t\titem = last ? last->nextSibling() : parent->firstChild();\n\t\ttype = child->prompt ? child->prompt->type : P_UNKNOWN;\n\n\t\tswitch (mode) {\n\t\tcase menuMode:\n\t\t\tif (!(child->flags & MENU_ROOT))\n\t\t\t\tgoto hide;\n\t\t\tbreak;\n\t\tcase symbolMode:\n\t\t\tif (child->flags & MENU_ROOT)\n\t\t\t\tgoto hide;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tvisible = menu_is_visible(child);\n\t\tif (!menuSkip(child)) {\n\t\t\tif (!child->sym && !child->list && !child->prompt)\n\t\t\t\tcontinue;\n\t\t\tif (!item || item->menu != child)\n\t\t\t\titem = new ConfigItem(parent, last, child, visible);\n\t\t\telse\n\t\t\t\titem->testUpdateMenu(visible);\n\n\t\t\tif (mode == fullMode || mode == menuMode || type != P_MENU)\n\t\t\t\tupdateMenuList(item, child);\n\t\t\telse\n\t\t\t\tupdateMenuList(item, 0);\n\t\t\tlast = item;\n\t\t\tcontinue;\n\t\t}\nhide:\n\t\tif (item && item->menu == child) {\n\t\t\tlast = parent->firstChild();\n\t\t\tif (last == item)\n\t\t\t\tlast = 0;\n\t\t\telse while (last->nextSibling() != item)\n\t\t\t\tlast = last->nextSibling();\n\t\t\tdelete item;\n\t\t}\n\t}\n}\n\nvoid ConfigList::updateMenuList(struct menu *menu)\n{\n\tstruct menu* child;\n\tConfigItem* item;\n\tConfigItem* last;\n\tbool visible;\n\tenum prop_type type;\n\n\tif (!menu) {\n\t\twhile (topLevelItemCount() > 0)\n\t\t{\n\t\t\tdelete takeTopLevelItem(0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tlast = (ConfigItem *)topLevelItem(0);\n\tif (last && !last->goParent)\n\t\tlast = 0;\n\tfor (child = menu->list; child; child = child->next) {\n\t\titem = last ? last->nextSibling() : (ConfigItem *)topLevelItem(0);\n\t\ttype = child->prompt ? child->prompt->type : P_UNKNOWN;\n\n\t\tswitch (mode) {\n\t\tcase menuMode:\n\t\t\tif (!(child->flags & MENU_ROOT))\n\t\t\t\tgoto hide;\n\t\t\tbreak;\n\t\tcase symbolMode:\n\t\t\tif (child->flags & MENU_ROOT)\n\t\t\t\tgoto hide;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tvisible = menu_is_visible(child);\n\t\tif (!menuSkip(child)) {\n\t\t\tif (!child->sym && !child->list && !child->prompt)\n\t\t\t\tcontinue;\n\t\t\tif (!item || item->menu != child)\n\t\t\t\titem = new ConfigItem(this, last, child, visible);\n\t\t\telse\n\t\t\t\titem->testUpdateMenu(visible);\n\n\t\t\tif (mode == fullMode || mode == menuMode || type != P_MENU)\n\t\t\t\tupdateMenuList(item, child);\n\t\t\telse\n\t\t\t\tupdateMenuList(item, 0);\n\t\t\tlast = item;\n\t\t\tcontinue;\n\t\t}\nhide:\n\t\tif (item && item->menu == child) {\n\t\t\tlast = (ConfigItem *)topLevelItem(0);\n\t\t\tif (last == item)\n\t\t\t\tlast = 0;\n\t\t\telse while (last->nextSibling() != item)\n\t\t\t\tlast = last->nextSibling();\n\t\t\tdelete item;\n\t\t}\n\t}\n}\n\nvoid ConfigList::keyPressEvent(QKeyEvent* ev)\n{\n\tQTreeWidgetItem* i = currentItem();\n\tConfigItem* item;\n\tstruct menu *menu;\n\tenum prop_type type;\n\n\tif (ev->key() == Qt::Key_Escape && mode != fullMode && mode != listMode) {\n\t\temit parentSelected();\n\t\tev->accept();\n\t\treturn;\n\t}\n\n\tif (!i) {\n\t\tParent::keyPressEvent(ev);\n\t\treturn;\n\t}\n\titem = (ConfigItem*)i;\n\n\tswitch (ev->key()) {\n\tcase Qt::Key_Return:\n\tcase Qt::Key_Enter:\n\t\tif (item->goParent) {\n\t\t\temit parentSelected();\n\t\t\tbreak;\n\t\t}\n\t\tmenu = item->menu;\n\t\tif (!menu)\n\t\t\tbreak;\n\t\ttype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\t\tif (type == P_MENU && rootEntry != menu &&\n\t\t    mode != fullMode && mode != menuMode) {\n\t\t\tif (mode == menuMode)\n\t\t\t\temit menuSelected(menu);\n\t\t\telse\n\t\t\t\temit itemSelected(menu);\n\t\t\tbreak;\n\t\t}\n\tcase Qt::Key_Space:\n\t\tchangeValue(item);\n\t\tbreak;\n\tcase Qt::Key_N:\n\t\tsetValue(item, no);\n\t\tbreak;\n\tcase Qt::Key_M:\n\t\tsetValue(item, mod);\n\t\tbreak;\n\tcase Qt::Key_Y:\n\t\tsetValue(item, yes);\n\t\tbreak;\n\tdefault:\n\t\tParent::keyPressEvent(ev);\n\t\treturn;\n\t}\n\tev->accept();\n}\n\nvoid ConfigList::mousePressEvent(QMouseEvent* e)\n{\n\t\n\t\n\tParent::mousePressEvent(e);\n}\n\nvoid ConfigList::mouseReleaseEvent(QMouseEvent* e)\n{\n\tQPoint p = e->pos();\n\tConfigItem* item = (ConfigItem*)itemAt(p);\n\tstruct menu *menu;\n\tenum prop_type ptype;\n\tQIcon icon;\n\tint idx, x;\n\n\tif (!item)\n\t\tgoto skip;\n\n\tmenu = item->menu;\n\tx = header()->offset() + p.x();\n\tidx = header()->logicalIndexAt(x);\n\tswitch (idx) {\n\tcase promptColIdx:\n\t\ticon = item->icon(promptColIdx);\n\t\tif (!icon.isNull()) {\n\t\t\tint off = header()->sectionPosition(0) + visualRect(indexAt(p)).x() + 4; \n\t\t\tif (x >= off && x < off + icon.availableSizes().first().width()) {\n\t\t\t\tif (item->goParent) {\n\t\t\t\t\temit parentSelected();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!menu)\n\t\t\t\t\tbreak;\n\t\t\t\tptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\t\t\t\tif (ptype == P_MENU && rootEntry != menu &&\n\t\t\t\t    mode != fullMode && mode != menuMode &&\n                                    mode != listMode)\n\t\t\t\t\temit menuSelected(menu);\n\t\t\t\telse\n\t\t\t\t\tchangeValue(item);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase dataColIdx:\n\t\tchangeValue(item);\n\t\tbreak;\n\t}\n\nskip:\n\t\n\tParent::mouseReleaseEvent(e);\n}\n\nvoid ConfigList::mouseMoveEvent(QMouseEvent* e)\n{\n\t\n\t\n\tParent::mouseMoveEvent(e);\n}\n\nvoid ConfigList::mouseDoubleClickEvent(QMouseEvent* e)\n{\n\tQPoint p = e->pos();\n\tConfigItem* item = (ConfigItem*)itemAt(p);\n\tstruct menu *menu;\n\tenum prop_type ptype;\n\n\tif (!item)\n\t\tgoto skip;\n\tif (item->goParent) {\n\t\temit parentSelected();\n\t\tgoto skip;\n\t}\n\tmenu = item->menu;\n\tif (!menu)\n\t\tgoto skip;\n\tptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\tif (ptype == P_MENU && mode != listMode) {\n\t\tif (mode == singleMode)\n\t\t\temit itemSelected(menu);\n\t\telse if (mode == symbolMode)\n\t\t\temit menuSelected(menu);\n\t} else if (menu->sym)\n\t\tchangeValue(item);\n\nskip:\n\t\n\tParent::mouseDoubleClickEvent(e);\n}\n\nvoid ConfigList::focusInEvent(QFocusEvent *e)\n{\n\tstruct menu *menu = NULL;\n\n\tParent::focusInEvent(e);\n\n\tConfigItem* item = (ConfigItem *)currentItem();\n\tif (item) {\n\t\tsetSelected(item, true);\n\t\tmenu = item->menu;\n\t}\n\temit gotFocus(menu);\n}\n\nvoid ConfigList::contextMenuEvent(QContextMenuEvent *e)\n{\n\tif (!headerPopup) {\n\t\tQAction *action;\n\n\t\theaderPopup = new QMenu(this);\n\t\taction = new QAction(\"Show Name\", this);\n\t\taction->setCheckable(true);\n\t\tconnect(action, &QAction::toggled,\n\t\t\tthis, &ConfigList::setShowName);\n\t\tconnect(this, &ConfigList::showNameChanged,\n\t\t\taction, &QAction::setChecked);\n\t\taction->setChecked(showName);\n\t\theaderPopup->addAction(action);\n\t}\n\n\theaderPopup->exec(e->globalPos());\n\te->accept();\n}\n\nvoid ConfigList::setShowName(bool on)\n{\n\tif (showName == on)\n\t\treturn;\n\n\tshowName = on;\n\treinit();\n\temit showNameChanged(on);\n}\n\nQList<ConfigList *> ConfigList::allLists;\nQAction *ConfigList::showNormalAction;\nQAction *ConfigList::showAllAction;\nQAction *ConfigList::showPromptAction;\n\nvoid ConfigList::setAllOpen(bool open)\n{\n\tQTreeWidgetItemIterator it(this);\n\n\twhile (*it) {\n\t\t(*it)->setExpanded(open);\n\n\t\t++it;\n\t}\n}\n\nConfigInfoView::ConfigInfoView(QWidget* parent, const char *name)\n\t: Parent(parent), sym(0), _menu(0)\n{\n\tsetObjectName(name);\n\tsetOpenLinks(false);\n\n\tif (!objectName().isEmpty()) {\n\t\tconfigSettings->beginGroup(objectName());\n\t\tsetShowDebug(configSettings->value(\"/showDebug\", false).toBool());\n\t\tconfigSettings->endGroup();\n\t\tconnect(configApp, &QApplication::aboutToQuit,\n\t\t\tthis, &ConfigInfoView::saveSettings);\n\t}\n\n\tcontextMenu = createStandardContextMenu();\n\tQAction *action = new QAction(\"Show Debug Info\", contextMenu);\n\n\taction->setCheckable(true);\n\tconnect(action, &QAction::toggled,\n\t\tthis, &ConfigInfoView::setShowDebug);\n\tconnect(this, &ConfigInfoView::showDebugChanged,\n\t\taction, &QAction::setChecked);\n\taction->setChecked(showDebug());\n\tcontextMenu->addSeparator();\n\tcontextMenu->addAction(action);\n}\n\nvoid ConfigInfoView::saveSettings(void)\n{\n\tif (!objectName().isEmpty()) {\n\t\tconfigSettings->beginGroup(objectName());\n\t\tconfigSettings->setValue(\"/showDebug\", showDebug());\n\t\tconfigSettings->endGroup();\n\t}\n}\n\nvoid ConfigInfoView::setShowDebug(bool b)\n{\n\tif (_showDebug != b) {\n\t\t_showDebug = b;\n\t\tif (_menu)\n\t\t\tmenuInfo();\n\t\telse if (sym)\n\t\t\tsymbolInfo();\n\t\temit showDebugChanged(b);\n\t}\n}\n\nvoid ConfigInfoView::setInfo(struct menu *m)\n{\n\tif (_menu == m)\n\t\treturn;\n\t_menu = m;\n\tsym = NULL;\n\tif (!_menu)\n\t\tclear();\n\telse\n\t\tmenuInfo();\n}\n\nvoid ConfigInfoView::symbolInfo(void)\n{\n\tQString str;\n\n\tstr += \"<big>Symbol: <b>\";\n\tstr += print_filter(sym->name);\n\tstr += \"</b></big><br><br>value: \";\n\tstr += print_filter(sym_get_string_value(sym));\n\tstr += \"<br>visibility: \";\n\tstr += sym->visible == yes ? \"y\" : sym->visible == mod ? \"m\" : \"n\";\n\tstr += \"<br>\";\n\tstr += debug_info(sym);\n\n\tsetText(str);\n}\n\nvoid ConfigInfoView::menuInfo(void)\n{\n\tstruct symbol* sym;\n\tQString info;\n\tQTextStream stream(&info);\n\n\tsym = _menu->sym;\n\tif (sym) {\n\t\tif (_menu->prompt) {\n\t\t\tstream << \"<big><b>\";\n\t\t\tstream << print_filter(_menu->prompt->text);\n\t\t\tstream << \"</b></big>\";\n\t\t\tif (sym->name) {\n\t\t\t\tstream << \" (\";\n\t\t\t\tif (showDebug())\n\t\t\t\t\tstream << \"<a href=\\\"s\" << sym->name << \"\\\">\";\n\t\t\t\tstream << print_filter(sym->name);\n\t\t\t\tif (showDebug())\n\t\t\t\t\tstream << \"</a>\";\n\t\t\t\tstream << \")\";\n\t\t\t}\n\t\t} else if (sym->name) {\n\t\t\tstream << \"<big><b>\";\n\t\t\tif (showDebug())\n\t\t\t\tstream << \"<a href=\\\"s\" << sym->name << \"\\\">\";\n\t\t\tstream << print_filter(sym->name);\n\t\t\tif (showDebug())\n\t\t\t\tstream << \"</a>\";\n\t\t\tstream << \"</b></big>\";\n\t\t}\n\t\tstream << \"<br><br>\";\n\n\t\tif (showDebug())\n\t\t\tstream << debug_info(sym);\n\n\t\tstruct gstr help_gstr = str_new();\n\n\t\tmenu_get_ext_help(_menu, &help_gstr);\n\t\tstream << print_filter(str_get(&help_gstr));\n\t\tstr_free(&help_gstr);\n\t} else if (_menu->prompt) {\n\t\tstream << \"<big><b>\";\n\t\tstream << print_filter(_menu->prompt->text);\n\t\tstream << \"</b></big><br><br>\";\n\t\tif (showDebug()) {\n\t\t\tif (_menu->prompt->visible.expr) {\n\t\t\t\tstream << \"&nbsp;&nbsp;dep: \";\n\t\t\t\texpr_print(_menu->prompt->visible.expr,\n\t\t\t\t\t   expr_print_help, &stream, E_NONE);\n\t\t\t\tstream << \"<br><br>\";\n\t\t\t}\n\n\t\t\tstream << \"defined at \" << _menu->file->name << \":\"\n\t\t\t       << _menu->lineno << \"<br><br>\";\n\t\t}\n\t}\n\n\tsetText(info);\n}\n\nQString ConfigInfoView::debug_info(struct symbol *sym)\n{\n\tQString debug;\n\tQTextStream stream(&debug);\n\n\tstream << \"type: \";\n\tstream << print_filter(sym_type_name(sym->type));\n\tif (sym_is_choice(sym))\n\t\tstream << \" (choice)\";\n\tdebug += \"<br>\";\n\tif (sym->rev_dep.expr) {\n\t\tstream << \"reverse dep: \";\n\t\texpr_print(sym->rev_dep.expr, expr_print_help, &stream, E_NONE);\n\t\tstream << \"<br>\";\n\t}\n\tfor (struct property *prop = sym->prop; prop; prop = prop->next) {\n\t\tswitch (prop->type) {\n\t\tcase P_PROMPT:\n\t\tcase P_MENU:\n\t\t\tstream << \"prompt: <a href=\\\"m\" << sym->name << \"\\\">\";\n\t\t\tstream << print_filter(prop->text);\n\t\t\tstream << \"</a><br>\";\n\t\t\tbreak;\n\t\tcase P_DEFAULT:\n\t\tcase P_SELECT:\n\t\tcase P_RANGE:\n\t\tcase P_COMMENT:\n\t\tcase P_IMPLY:\n\t\tcase P_SYMBOL:\n\t\t\tstream << prop_get_type_name(prop->type);\n\t\t\tstream << \": \";\n\t\t\texpr_print(prop->expr, expr_print_help,\n\t\t\t\t   &stream, E_NONE);\n\t\t\tstream << \"<br>\";\n\t\t\tbreak;\n\t\tcase P_CHOICE:\n\t\t\tif (sym_is_choice(sym)) {\n\t\t\t\tstream << \"choice: \";\n\t\t\t\texpr_print(prop->expr, expr_print_help,\n\t\t\t\t\t   &stream, E_NONE);\n\t\t\t\tstream << \"<br>\";\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstream << \"unknown property: \";\n\t\t\tstream << prop_get_type_name(prop->type);\n\t\t\tstream << \"<br>\";\n\t\t}\n\t\tif (prop->visible.expr) {\n\t\t\tstream << \"&nbsp;&nbsp;&nbsp;&nbsp;dep: \";\n\t\t\texpr_print(prop->visible.expr, expr_print_help,\n\t\t\t\t   &stream, E_NONE);\n\t\t\tstream << \"<br>\";\n\t\t}\n\t}\n\tstream << \"<br>\";\n\n\treturn debug;\n}\n\nQString ConfigInfoView::print_filter(const QString &str)\n{\n\tQRegularExpression re(\"[<>&\\\"\\\\n]\");\n\tQString res = str;\n\tfor (int i = 0; (i = res.indexOf(re, i)) >= 0;) {\n\t\tswitch (res[i].toLatin1()) {\n\t\tcase '<':\n\t\t\tres.replace(i, 1, \"&lt;\");\n\t\t\ti += 4;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tres.replace(i, 1, \"&gt;\");\n\t\t\ti += 4;\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tres.replace(i, 1, \"&amp;\");\n\t\t\ti += 5;\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tres.replace(i, 1, \"&quot;\");\n\t\t\ti += 6;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tres.replace(i, 1, \"<br>\");\n\t\t\ti += 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid ConfigInfoView::expr_print_help(void *data, struct symbol *sym, const char *str)\n{\n\tQTextStream *stream = reinterpret_cast<QTextStream *>(data);\n\n\tif (sym && sym->name && !(sym->flags & SYMBOL_CONST)) {\n\t\t*stream << \"<a href=\\\"s\" << sym->name << \"\\\">\";\n\t\t*stream << print_filter(str);\n\t\t*stream << \"</a>\";\n\t} else {\n\t\t*stream << print_filter(str);\n\t}\n}\n\nvoid ConfigInfoView::clicked(const QUrl &url)\n{\n\tQByteArray str = url.toEncoded();\n\tconst std::size_t count = str.size();\n\tchar *data = new char[count + 1];\n\tstruct symbol **result;\n\tstruct menu *m = NULL;\n\n\tif (count < 1) {\n\t\tdelete[] data;\n\t\treturn;\n\t}\n\n\tmemcpy(data, str.constData(), count);\n\tdata[count] = '\\0';\n\n\t \n\tdata[0] = '^';\n\tstrcat(data, \"$\");\n\tresult = sym_re_search(data);\n\tif (!result) {\n\t\tdelete[] data;\n\t\treturn;\n\t}\n\n\tsym = *result;\n\n\t \n\tfor (struct property *prop = sym->prop; prop; prop = prop->next) {\n\t\t    if (prop->type != P_PROMPT && prop->type != P_MENU)\n\t\t\t    continue;\n\t\t    m = prop->menu;\n\t\t    break;\n\t}\n\n\tif (!m) {\n\t\t \n\t\tsymbolInfo();\n\t\temit showDebugChanged(true);\n\t} else {\n\t\temit menuSelected(m);\n\t}\n\n\tfree(result);\n\tdelete[] data;\n}\n\nvoid ConfigInfoView::contextMenuEvent(QContextMenuEvent *event)\n{\n\tcontextMenu->popup(event->globalPos());\n\tevent->accept();\n}\n\nConfigSearchWindow::ConfigSearchWindow(ConfigMainWindow *parent)\n\t: Parent(parent), result(NULL)\n{\n\tsetObjectName(\"search\");\n\tsetWindowTitle(\"Search Config\");\n\n\tQVBoxLayout* layout1 = new QVBoxLayout(this);\n\tlayout1->setContentsMargins(11, 11, 11, 11);\n\tlayout1->setSpacing(6);\n\n\tQHBoxLayout* layout2 = new QHBoxLayout();\n\tlayout2->setContentsMargins(0, 0, 0, 0);\n\tlayout2->setSpacing(6);\n\tlayout2->addWidget(new QLabel(\"Find:\", this));\n\teditField = new QLineEdit(this);\n\tconnect(editField, &QLineEdit::returnPressed,\n\t\tthis, &ConfigSearchWindow::search);\n\tlayout2->addWidget(editField);\n\tsearchButton = new QPushButton(\"Search\", this);\n\tsearchButton->setAutoDefault(false);\n\tconnect(searchButton, &QPushButton::clicked,\n\t\tthis, &ConfigSearchWindow::search);\n\tlayout2->addWidget(searchButton);\n\tlayout1->addLayout(layout2);\n\n\tsplit = new QSplitter(this);\n\tsplit->setOrientation(Qt::Vertical);\n\tlist = new ConfigList(split, \"search\");\n\tlist->mode = listMode;\n\tinfo = new ConfigInfoView(split, \"search\");\n\tconnect(list, &ConfigList::menuChanged,\n\t\tinfo, &ConfigInfoView::setInfo);\n\tconnect(list, &ConfigList::menuChanged,\n\t\tparent, &ConfigMainWindow::setMenuLink);\n\n\tlayout1->addWidget(split);\n\n\tQVariant x, y;\n\tint width, height;\n\tbool ok;\n\n\tconfigSettings->beginGroup(\"search\");\n\twidth = configSettings->value(\"/window width\", parent->width() / 2).toInt();\n\theight = configSettings->value(\"/window height\", parent->height() / 2).toInt();\n\tresize(width, height);\n\tx = configSettings->value(\"/window x\");\n\ty = configSettings->value(\"/window y\");\n\tif (x.isValid() && y.isValid())\n\t\tmove(x.toInt(), y.toInt());\n\tQList<int> sizes = configSettings->readSizes(\"/split\", &ok);\n\tif (ok)\n\t\tsplit->setSizes(sizes);\n\tconfigSettings->endGroup();\n\tconnect(configApp, &QApplication::aboutToQuit,\n\t\tthis, &ConfigSearchWindow::saveSettings);\n}\n\nvoid ConfigSearchWindow::saveSettings(void)\n{\n\tif (!objectName().isEmpty()) {\n\t\tconfigSettings->beginGroup(objectName());\n\t\tconfigSettings->setValue(\"/window x\", pos().x());\n\t\tconfigSettings->setValue(\"/window y\", pos().y());\n\t\tconfigSettings->setValue(\"/window width\", size().width());\n\t\tconfigSettings->setValue(\"/window height\", size().height());\n\t\tconfigSettings->writeSizes(\"/split\", split->sizes());\n\t\tconfigSettings->endGroup();\n\t}\n}\n\nvoid ConfigSearchWindow::search(void)\n{\n\tstruct symbol **p;\n\tstruct property *prop;\n\tConfigItem *lastItem = NULL;\n\n\tfree(result);\n\tlist->clear();\n\tinfo->clear();\n\n\tresult = sym_re_search(editField->text().toLatin1());\n\tif (!result)\n\t\treturn;\n\tfor (p = result; *p; p++) {\n\t\tfor_all_prompts((*p), prop)\n\t\t\tlastItem = new ConfigItem(list, lastItem, prop->menu,\n\t\t\t\t\t\t  menu_is_visible(prop->menu));\n\t}\n}\n\n \nConfigMainWindow::ConfigMainWindow(void)\n\t: searchWindow(0)\n{\n\tbool ok = true;\n\tQVariant x, y;\n\tint width, height;\n\tchar title[256];\n\n\tsnprintf(title, sizeof(title), \"%s%s\",\n\t\trootmenu.prompt->text,\n\t\t\"\"\n\t\t);\n\tsetWindowTitle(title);\n\n\tQRect g = configApp->primaryScreen()->geometry();\n\twidth = configSettings->value(\"/window width\", g.width() - 64).toInt();\n\theight = configSettings->value(\"/window height\", g.height() - 64).toInt();\n\tresize(width, height);\n\tx = configSettings->value(\"/window x\");\n\ty = configSettings->value(\"/window y\");\n\tif ((x.isValid())&&(y.isValid()))\n\t\tmove(x.toInt(), y.toInt());\n\n\t\n\tConfigItem::symbolYesIcon = QIcon(QPixmap(xpm_symbol_yes));\n\tConfigItem::symbolModIcon = QIcon(QPixmap(xpm_symbol_mod));\n\tConfigItem::symbolNoIcon = QIcon(QPixmap(xpm_symbol_no));\n\tConfigItem::choiceYesIcon = QIcon(QPixmap(xpm_choice_yes));\n\tConfigItem::choiceNoIcon = QIcon(QPixmap(xpm_choice_no));\n\tConfigItem::menuIcon = QIcon(QPixmap(xpm_menu));\n\tConfigItem::menubackIcon = QIcon(QPixmap(xpm_menuback));\n\n\tQWidget *widget = new QWidget(this);\n\tQVBoxLayout *layout = new QVBoxLayout(widget);\n\tsetCentralWidget(widget);\n\n\tsplit1 = new QSplitter(widget);\n\tsplit1->setOrientation(Qt::Horizontal);\n\tsplit1->setChildrenCollapsible(false);\n\n\tmenuList = new ConfigList(widget, \"menu\");\n\n\tsplit2 = new QSplitter(widget);\n\tsplit2->setChildrenCollapsible(false);\n\tsplit2->setOrientation(Qt::Vertical);\n\n\t\n\tconfigList = new ConfigList(widget, \"config\");\n\n\thelpText = new ConfigInfoView(widget, \"help\");\n\n\tlayout->addWidget(split2);\n\tsplit2->addWidget(split1);\n\tsplit1->addWidget(configList);\n\tsplit1->addWidget(menuList);\n\tsplit2->addWidget(helpText);\n\n\tsetTabOrder(configList, helpText);\n\tconfigList->setFocus();\n\n\tbackAction = new QAction(QPixmap(xpm_back), \"Back\", this);\n\tconnect(backAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::goBack);\n\n\tQAction *quitAction = new QAction(\"&Quit\", this);\n\tquitAction->setShortcut(Qt::CTRL | Qt::Key_Q);\n\tconnect(quitAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::close);\n\n\tQAction *loadAction = new QAction(QPixmap(xpm_load), \"&Load\", this);\n\tloadAction->setShortcut(Qt::CTRL | Qt::Key_L);\n\tconnect(loadAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::loadConfig);\n\n\tsaveAction = new QAction(QPixmap(xpm_save), \"&Save\", this);\n\tsaveAction->setShortcut(Qt::CTRL | Qt::Key_S);\n\tconnect(saveAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::saveConfig);\n\n\tconf_set_changed_callback(conf_changed);\n\n\t\n\tconf_changed();\n\tconfigname = xstrdup(conf_get_configname());\n\n\tQAction *saveAsAction = new QAction(\"Save &As...\", this);\n\tconnect(saveAsAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::saveConfigAs);\n\tQAction *searchAction = new QAction(\"&Find\", this);\n\tsearchAction->setShortcut(Qt::CTRL | Qt::Key_F);\n\tconnect(searchAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::searchConfig);\n\tsingleViewAction = new QAction(QPixmap(xpm_single_view), \"Single View\", this);\n\tsingleViewAction->setCheckable(true);\n\tconnect(singleViewAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::showSingleView);\n\tsplitViewAction = new QAction(QPixmap(xpm_split_view), \"Split View\", this);\n\tsplitViewAction->setCheckable(true);\n\tconnect(splitViewAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::showSplitView);\n\tfullViewAction = new QAction(QPixmap(xpm_tree_view), \"Full View\", this);\n\tfullViewAction->setCheckable(true);\n\tconnect(fullViewAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::showFullView);\n\n\tQAction *showNameAction = new QAction(\"Show Name\", this);\n\t  showNameAction->setCheckable(true);\n\tconnect(showNameAction, &QAction::toggled,\n\t\tconfigList, &ConfigList::setShowName);\n\tshowNameAction->setChecked(configList->showName);\n\n\tQActionGroup *optGroup = new QActionGroup(this);\n\toptGroup->setExclusive(true);\n\tconnect(optGroup, &QActionGroup::triggered,\n\t\tconfigList, &ConfigList::setOptionMode);\n\tconnect(optGroup, &QActionGroup::triggered,\n\t\tmenuList, &ConfigList::setOptionMode);\n\n\tConfigList::showNormalAction = new QAction(\"Show Normal Options\", optGroup);\n\tConfigList::showNormalAction->setCheckable(true);\n\tConfigList::showAllAction = new QAction(\"Show All Options\", optGroup);\n\tConfigList::showAllAction->setCheckable(true);\n\tConfigList::showPromptAction = new QAction(\"Show Prompt Options\", optGroup);\n\tConfigList::showPromptAction->setCheckable(true);\n\n\tQAction *showDebugAction = new QAction(\"Show Debug Info\", this);\n\t  showDebugAction->setCheckable(true);\n\tconnect(showDebugAction, &QAction::toggled,\n\t\thelpText, &ConfigInfoView::setShowDebug);\n\t  showDebugAction->setChecked(helpText->showDebug());\n\n\tQAction *showIntroAction = new QAction(\"Introduction\", this);\n\tconnect(showIntroAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::showIntro);\n\tQAction *showAboutAction = new QAction(\"About\", this);\n\tconnect(showAboutAction, &QAction::triggered,\n\t\tthis, &ConfigMainWindow::showAbout);\n\n\t\n\tQToolBar *toolBar = addToolBar(\"Tools\");\n\ttoolBar->addAction(backAction);\n\ttoolBar->addSeparator();\n\ttoolBar->addAction(loadAction);\n\ttoolBar->addAction(saveAction);\n\ttoolBar->addSeparator();\n\ttoolBar->addAction(singleViewAction);\n\ttoolBar->addAction(splitViewAction);\n\ttoolBar->addAction(fullViewAction);\n\n\t\n\tQMenu *menu = menuBar()->addMenu(\"&File\");\n\tmenu->addAction(loadAction);\n\tmenu->addAction(saveAction);\n\tmenu->addAction(saveAsAction);\n\tmenu->addSeparator();\n\tmenu->addAction(quitAction);\n\n\t\n\tmenu = menuBar()->addMenu(\"&Edit\");\n\tmenu->addAction(searchAction);\n\n\t\n\tmenu = menuBar()->addMenu(\"&Option\");\n\tmenu->addAction(showNameAction);\n\tmenu->addSeparator();\n\tmenu->addActions(optGroup->actions());\n\tmenu->addSeparator();\n\tmenu->addAction(showDebugAction);\n\n\t\n\tmenu = menuBar()->addMenu(\"&Help\");\n\tmenu->addAction(showIntroAction);\n\tmenu->addAction(showAboutAction);\n\n\tconnect(helpText, &ConfigInfoView::anchorClicked,\n\t\thelpText, &ConfigInfoView::clicked);\n\n\tconnect(configList, &ConfigList::menuChanged,\n\t\thelpText, &ConfigInfoView::setInfo);\n\tconnect(configList, &ConfigList::menuSelected,\n\t\tthis, &ConfigMainWindow::changeMenu);\n\tconnect(configList, &ConfigList::itemSelected,\n\t\tthis, &ConfigMainWindow::changeItens);\n\tconnect(configList, &ConfigList::parentSelected,\n\t\tthis, &ConfigMainWindow::goBack);\n\tconnect(menuList, &ConfigList::menuChanged,\n\t\thelpText, &ConfigInfoView::setInfo);\n\tconnect(menuList, &ConfigList::menuSelected,\n\t\tthis, &ConfigMainWindow::changeMenu);\n\n\tconnect(configList, &ConfigList::gotFocus,\n\t\thelpText, &ConfigInfoView::setInfo);\n\tconnect(menuList, &ConfigList::gotFocus,\n\t\thelpText, &ConfigInfoView::setInfo);\n\tconnect(menuList, &ConfigList::gotFocus,\n\t\tthis, &ConfigMainWindow::listFocusChanged);\n\tconnect(helpText, &ConfigInfoView::menuSelected,\n\t\tthis, &ConfigMainWindow::setMenuLink);\n\n\tQString listMode = configSettings->value(\"/listMode\", \"symbol\").toString();\n\tif (listMode == \"single\")\n\t\tshowSingleView();\n\telse if (listMode == \"full\")\n\t\tshowFullView();\n\telse  \n\t\tshowSplitView();\n\n\t\n\tQList<int> sizes = configSettings->readSizes(\"/split1\", &ok);\n\tif (ok)\n\t\tsplit1->setSizes(sizes);\n\n\tsizes = configSettings->readSizes(\"/split2\", &ok);\n\tif (ok)\n\t\tsplit2->setSizes(sizes);\n}\n\nvoid ConfigMainWindow::loadConfig(void)\n{\n\tQString str;\n\tQByteArray ba;\n\tconst char *name;\n\n\tstr = QFileDialog::getOpenFileName(this, \"\", configname);\n\tif (str.isNull())\n\t\treturn;\n\n\tba = str.toLocal8Bit();\n\tname = ba.data();\n\n\tif (conf_read(name))\n\t\tQMessageBox::information(this, \"qconf\", \"Unable to load configuration!\");\n\n\tfree(configname);\n\tconfigname = xstrdup(name);\n\n\tConfigList::updateListAllForAll();\n}\n\nbool ConfigMainWindow::saveConfig(void)\n{\n\tif (conf_write(configname)) {\n\t\tQMessageBox::information(this, \"qconf\", \"Unable to save configuration!\");\n\t\treturn false;\n\t}\n\tconf_write_autoconf(0);\n\n\treturn true;\n}\n\nvoid ConfigMainWindow::saveConfigAs(void)\n{\n\tQString str;\n\tQByteArray ba;\n\tconst char *name;\n\n\tstr = QFileDialog::getSaveFileName(this, \"\", configname);\n\tif (str.isNull())\n\t\treturn;\n\n\tba = str.toLocal8Bit();\n\tname = ba.data();\n\n\tif (conf_write(name)) {\n\t\tQMessageBox::information(this, \"qconf\", \"Unable to save configuration!\");\n\t}\n\tconf_write_autoconf(0);\n\n\tfree(configname);\n\tconfigname = xstrdup(name);\n}\n\nvoid ConfigMainWindow::searchConfig(void)\n{\n\tif (!searchWindow)\n\t\tsearchWindow = new ConfigSearchWindow(this);\n\tsearchWindow->show();\n}\n\nvoid ConfigMainWindow::changeItens(struct menu *menu)\n{\n\tconfigList->setRootMenu(menu);\n}\n\nvoid ConfigMainWindow::changeMenu(struct menu *menu)\n{\n\tmenuList->setRootMenu(menu);\n}\n\nvoid ConfigMainWindow::setMenuLink(struct menu *menu)\n{\n\tstruct menu *parent;\n\tConfigList* list = NULL;\n\tConfigItem* item;\n\n\tif (configList->menuSkip(menu))\n\t\treturn;\n\n\tswitch (configList->mode) {\n\tcase singleMode:\n\t\tlist = configList;\n\t\tparent = menu_get_parent_menu(menu);\n\t\tif (!parent)\n\t\t\treturn;\n\t\tlist->setRootMenu(parent);\n\t\tbreak;\n\tcase menuMode:\n\t\tif (menu->flags & MENU_ROOT) {\n\t\t\tmenuList->setRootMenu(menu);\n\t\t\tconfigList->clearSelection();\n\t\t\tlist = configList;\n\t\t} else {\n\t\t\tparent = menu_get_parent_menu(menu->parent);\n\t\t\tif (!parent)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\titem = configList->findConfigItem(parent);\n\t\t\tif (item) {\n\t\t\t\tconfigList->setSelected(item, true);\n\t\t\t\tconfigList->scrollToItem(item);\n\t\t\t}\n\n\t\t\tmenuList->setRootMenu(parent);\n\t\t\tmenuList->clearSelection();\n\t\t\tlist = menuList;\n\t\t}\n\t\tbreak;\n\tcase fullMode:\n\t\tlist = configList;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (list) {\n\t\titem = list->findConfigItem(menu);\n\t\tif (item) {\n\t\t\tlist->setSelected(item, true);\n\t\t\tlist->scrollToItem(item);\n\t\t\tlist->setFocus();\n\t\t\thelpText->setInfo(menu);\n\t\t}\n\t}\n}\n\nvoid ConfigMainWindow::listFocusChanged(void)\n{\n\tif (menuList->mode == menuMode)\n\t\tconfigList->clearSelection();\n}\n\nvoid ConfigMainWindow::goBack(void)\n{\n\tif (configList->rootEntry == &rootmenu)\n\t\treturn;\n\n\tconfigList->setParentMenu();\n}\n\nvoid ConfigMainWindow::showSingleView(void)\n{\n\tsingleViewAction->setEnabled(false);\n\tsingleViewAction->setChecked(true);\n\tsplitViewAction->setEnabled(true);\n\tsplitViewAction->setChecked(false);\n\tfullViewAction->setEnabled(true);\n\tfullViewAction->setChecked(false);\n\n\tbackAction->setEnabled(true);\n\n\tmenuList->hide();\n\tmenuList->setRootMenu(0);\n\tconfigList->mode = singleMode;\n\tif (configList->rootEntry == &rootmenu)\n\t\tconfigList->updateListAll();\n\telse\n\t\tconfigList->setRootMenu(&rootmenu);\n\tconfigList->setFocus();\n}\n\nvoid ConfigMainWindow::showSplitView(void)\n{\n\tsingleViewAction->setEnabled(true);\n\tsingleViewAction->setChecked(false);\n\tsplitViewAction->setEnabled(false);\n\tsplitViewAction->setChecked(true);\n\tfullViewAction->setEnabled(true);\n\tfullViewAction->setChecked(false);\n\n\tbackAction->setEnabled(false);\n\n\tconfigList->mode = menuMode;\n\tif (configList->rootEntry == &rootmenu)\n\t\tconfigList->updateListAll();\n\telse\n\t\tconfigList->setRootMenu(&rootmenu);\n\tconfigList->setAllOpen(true);\n\tconfigApp->processEvents();\n\tmenuList->mode = symbolMode;\n\tmenuList->setRootMenu(&rootmenu);\n\tmenuList->setAllOpen(true);\n\tmenuList->show();\n\tmenuList->setFocus();\n}\n\nvoid ConfigMainWindow::showFullView(void)\n{\n\tsingleViewAction->setEnabled(true);\n\tsingleViewAction->setChecked(false);\n\tsplitViewAction->setEnabled(true);\n\tsplitViewAction->setChecked(false);\n\tfullViewAction->setEnabled(false);\n\tfullViewAction->setChecked(true);\n\n\tbackAction->setEnabled(false);\n\n\tmenuList->hide();\n\tmenuList->setRootMenu(0);\n\tconfigList->mode = fullMode;\n\tif (configList->rootEntry == &rootmenu)\n\t\tconfigList->updateListAll();\n\telse\n\t\tconfigList->setRootMenu(&rootmenu);\n\tconfigList->setFocus();\n}\n\n \nvoid ConfigMainWindow::closeEvent(QCloseEvent* e)\n{\n\tif (!conf_get_changed()) {\n\t\te->accept();\n\t\treturn;\n\t}\n\n\tQMessageBox mb(QMessageBox::Icon::Warning, \"qconf\",\n\t\t       \"Save configuration?\");\n\n\tQPushButton *yb = mb.addButton(QMessageBox::Yes);\n\tQPushButton *db = mb.addButton(QMessageBox::No);\n\tQPushButton *cb = mb.addButton(QMessageBox::Cancel);\n\n\tyb->setText(\"&Save Changes\");\n\tdb->setText(\"&Discard Changes\");\n\tcb->setText(\"Cancel Exit\");\n\n\tmb.setDefaultButton(yb);\n\tmb.setEscapeButton(cb);\n\n\tswitch (mb.exec()) {\n\tcase QMessageBox::Yes:\n\t\tif (saveConfig())\n\t\t\te->accept();\n\t\telse\n\t\t\te->ignore();\n\t\tbreak;\n\tcase QMessageBox::No:\n\t\te->accept();\n\t\tbreak;\n\tcase QMessageBox::Cancel:\n\t\te->ignore();\n\t\tbreak;\n\t}\n}\n\nvoid ConfigMainWindow::showIntro(void)\n{\n\tstatic const QString str =\n\t\t\"Welcome to the qconf graphical configuration tool.\\n\"\n\t\t\"\\n\"\n\t\t\"For bool and tristate options, a blank box indicates the \"\n\t\t\"feature is disabled, a check indicates it is enabled, and a \"\n\t\t\"dot indicates that it is to be compiled as a module. Clicking \"\n\t\t\"on the box will cycle through the three states. For int, hex, \"\n\t\t\"and string options, double-clicking or pressing F2 on the \"\n\t\t\"Value cell will allow you to edit the value.\\n\"\n\t\t\"\\n\"\n\t\t\"If you do not see an option (e.g., a device driver) that you \"\n\t\t\"believe should be present, try turning on Show All Options \"\n\t\t\"under the Options menu. Enabling Show Debug Info will help you\"\n\t\t\"figure out what other options must be enabled to support the \"\n\t\t\"option you are interested in, and hyperlinks will navigate to \"\n\t\t\"them.\\n\"\n\t\t\"\\n\"\n\t\t\"Toggling Show Debug Info under the Options menu will show the \"\n\t\t\"dependencies, which you can then match by examining other \"\n\t\t\"options.\\n\";\n\n\tQMessageBox::information(this, \"qconf\", str);\n}\n\nvoid ConfigMainWindow::showAbout(void)\n{\n\tstatic const QString str = \"qconf is Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>.\\n\"\n\t\t\"Copyright (C) 2015 Boris Barbulovski <bbarbulovski@gmail.com>.\\n\"\n\t\t\"\\n\"\n\t\t\"Bug reports and feature request can also be entered at http://bugzilla.kernel.org/\\n\"\n\t\t\"\\n\"\n\t\t\"Qt Version: \";\n\n\tQMessageBox::information(this, \"qconf\", str + qVersion());\n}\n\nvoid ConfigMainWindow::saveSettings(void)\n{\n\tconfigSettings->setValue(\"/window x\", pos().x());\n\tconfigSettings->setValue(\"/window y\", pos().y());\n\tconfigSettings->setValue(\"/window width\", size().width());\n\tconfigSettings->setValue(\"/window height\", size().height());\n\n\tQString entry;\n\tswitch(configList->mode) {\n\tcase singleMode :\n\t\tentry = \"single\";\n\t\tbreak;\n\n\tcase symbolMode :\n\t\tentry = \"split\";\n\t\tbreak;\n\n\tcase fullMode :\n\t\tentry = \"full\";\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tconfigSettings->setValue(\"/listMode\", entry);\n\n\tconfigSettings->writeSizes(\"/split1\", split1->sizes());\n\tconfigSettings->writeSizes(\"/split2\", split2->sizes());\n}\n\nvoid ConfigMainWindow::conf_changed(void)\n{\n\tif (saveAction)\n\t\tsaveAction->setEnabled(conf_get_changed());\n}\n\nvoid fixup_rootmenu(struct menu *menu)\n{\n\tstruct menu *child;\n\tstatic int menu_cnt = 0;\n\n\tmenu->flags |= MENU_ROOT;\n\tfor (child = menu->list; child; child = child->next) {\n\t\tif (child->prompt && child->prompt->type == P_MENU) {\n\t\t\tmenu_cnt++;\n\t\t\tfixup_rootmenu(child);\n\t\t\tmenu_cnt--;\n\t\t} else if (!menu_cnt)\n\t\t\tfixup_rootmenu(child);\n\t}\n}\n\nstatic const char *progname;\n\nstatic void usage(void)\n{\n\tprintf(\"%s [-s] <config>\\n\", progname);\n\texit(0);\n}\n\nint main(int ac, char** av)\n{\n\tConfigMainWindow* v;\n\tconst char *name;\n\n\tprogname = av[0];\n\tif (ac > 1 && av[1][0] == '-') {\n\t\tswitch (av[1][1]) {\n\t\tcase 's':\n\t\t\tconf_set_message_callback(NULL);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tusage();\n\t\t}\n\t\tname = av[2];\n\t} else\n\t\tname = av[1];\n\tif (!name)\n\t\tusage();\n\n\tconf_parse(name);\n\tfixup_rootmenu(&rootmenu);\n\tconf_read(NULL);\n\t\n\n\tconfigApp = new QApplication(ac, av);\n\n\tconfigSettings = new ConfigSettings();\n\tconfigSettings->beginGroup(\"/kconfig/qconf\");\n\tv = new ConfigMainWindow();\n\n\t\n\tconfigApp->connect(configApp, SIGNAL(lastWindowClosed()), SLOT(quit()));\n\tconfigApp->connect(configApp, SIGNAL(aboutToQuit()), v, SLOT(saveSettings()));\n\tv->show();\n\tconfigApp->exec();\n\n\tconfigSettings->endGroup();\n\tdelete configSettings;\n\tdelete v;\n\tdelete configApp;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}