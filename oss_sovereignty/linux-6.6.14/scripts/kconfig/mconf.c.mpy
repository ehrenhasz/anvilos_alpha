{
  "module_name": "mconf.c",
  "hash_id": "25d91ffb05b47660434ce637154b889a50b332f1431224443684584cd8d2f439",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/mconf.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <signal.h>\n#include <unistd.h>\n\n#include \"lkc.h\"\n#include \"lxdialog/dialog.h\"\n\nstatic const char mconf_readme[] =\n\"Overview\\n\"\n\"--------\\n\"\n\"This interface lets you select features and parameters for the build.\\n\"\n\"Features can either be built-in, modularized, or ignored. Parameters\\n\"\n\"must be entered in as decimal or hexadecimal numbers or text.\\n\"\n\"\\n\"\n\"Menu items beginning with following braces represent features that\\n\"\n\"  [ ] can be built in or removed\\n\"\n\"  < > can be built in, modularized or removed\\n\"\n\"  { } can be built in or modularized (selected by other feature)\\n\"\n\"  - - are selected by other feature,\\n\"\n\"while *, M or whitespace inside braces means to build in, build as\\n\"\n\"a module or to exclude the feature respectively.\\n\"\n\"\\n\"\n\"To change any of these features, highlight it with the cursor\\n\"\n\"keys and press <Y> to build it in, <M> to make it a module or\\n\"\n\"<N> to remove it.  You may also press the <Space Bar> to cycle\\n\"\n\"through the available options (i.e. Y->N->M->Y).\\n\"\n\"\\n\"\n\"Some additional keyboard hints:\\n\"\n\"\\n\"\n\"Menus\\n\"\n\"----------\\n\"\n\"o  Use the Up/Down arrow keys (cursor keys) to highlight the item you\\n\"\n\"   wish to change or the submenu you wish to select and press <Enter>.\\n\"\n\"   Submenus are designated by \\\"--->\\\", empty ones by \\\"----\\\".\\n\"\n\"\\n\"\n\"   Shortcut: Press the option's highlighted letter (hotkey).\\n\"\n\"             Pressing a hotkey more than once will sequence\\n\"\n\"             through all visible items which use that hotkey.\\n\"\n\"\\n\"\n\"   You may also use the <PAGE UP> and <PAGE DOWN> keys to scroll\\n\"\n\"   unseen options into view.\\n\"\n\"\\n\"\n\"o  To exit a menu use the cursor keys to highlight the <Exit> button\\n\"\n\"   and press <ENTER>.\\n\"\n\"\\n\"\n\"   Shortcut: Press <ESC><ESC> or <E> or <X> if there is no hotkey\\n\"\n\"             using those letters.  You may press a single <ESC>, but\\n\"\n\"             there is a delayed response which you may find annoying.\\n\"\n\"\\n\"\n\"   Also, the <TAB> and cursor keys will cycle between <Select>,\\n\"\n\"   <Exit>, <Help>, <Save>, and <Load>.\\n\"\n\"\\n\"\n\"o  To get help with an item, use the cursor keys to highlight <Help>\\n\"\n\"   and press <ENTER>.\\n\"\n\"\\n\"\n\"   Shortcut: Press <H> or <?>.\\n\"\n\"\\n\"\n\"o  To toggle the display of hidden options, press <Z>.\\n\"\n\"\\n\"\n\"\\n\"\n\"Radiolists  (Choice lists)\\n\"\n\"-----------\\n\"\n\"o  Use the cursor keys to select the option you wish to set and press\\n\"\n\"   <S> or the <SPACE BAR>.\\n\"\n\"\\n\"\n\"   Shortcut: Press the first letter of the option you wish to set then\\n\"\n\"             press <S> or <SPACE BAR>.\\n\"\n\"\\n\"\n\"o  To see available help for the item, use the cursor keys to highlight\\n\"\n\"   <Help> and Press <ENTER>.\\n\"\n\"\\n\"\n\"   Shortcut: Press <H> or <?>.\\n\"\n\"\\n\"\n\"   Also, the <TAB> and cursor keys will cycle between <Select> and\\n\"\n\"   <Help>\\n\"\n\"\\n\"\n\"\\n\"\n\"Data Entry\\n\"\n\"-----------\\n\"\n\"o  Enter the requested information and press <ENTER>\\n\"\n\"   If you are entering hexadecimal values, it is not necessary to\\n\"\n\"   add the '0x' prefix to the entry.\\n\"\n\"\\n\"\n\"o  For help, use the <TAB> or cursor keys to highlight the help option\\n\"\n\"   and press <ENTER>.  You can try <TAB><H> as well.\\n\"\n\"\\n\"\n\"\\n\"\n\"Text Box    (Help Window)\\n\"\n\"--------\\n\"\n\"o  Use the cursor keys to scroll up/down/left/right.  The VI editor\\n\"\n\"   keys h,j,k,l function here as do <u>, <d>, <SPACE BAR> and <B> for\\n\"\n\"   those who are familiar with less and lynx.\\n\"\n\"\\n\"\n\"o  Press <E>, <X>, <q>, <Enter> or <Esc><Esc> to exit.\\n\"\n\"\\n\"\n\"\\n\"\n\"Alternate Configuration Files\\n\"\n\"-----------------------------\\n\"\n\"Menuconfig supports the use of alternate configuration files for\\n\"\n\"those who, for various reasons, find it necessary to switch\\n\"\n\"between different configurations.\\n\"\n\"\\n\"\n\"The <Save> button will let you save the current configuration to\\n\"\n\"a file of your choosing.  Use the <Load> button to load a previously\\n\"\n\"saved alternate configuration.\\n\"\n\"\\n\"\n\"Even if you don't use alternate configuration files, but you find\\n\"\n\"during a Menuconfig session that you have completely messed up your\\n\"\n\"settings, you may use the <Load> button to restore your previously\\n\"\n\"saved settings from \\\".config\\\" without restarting Menuconfig.\\n\"\n\"\\n\"\n\"Other information\\n\"\n\"-----------------\\n\"\n\"If you use Menuconfig in an XTERM window, make sure you have your\\n\"\n\"$TERM variable set to point to an xterm definition which supports\\n\"\n\"color.  Otherwise, Menuconfig will look rather bad.  Menuconfig will\\n\"\n\"not display correctly in an RXVT window because rxvt displays only one\\n\"\n\"intensity of color, bright.\\n\"\n\"\\n\"\n\"Menuconfig will display larger menus on screens or xterms which are\\n\"\n\"set to display more than the standard 25 row by 80 column geometry.\\n\"\n\"In order for this to work, the \\\"stty size\\\" command must be able to\\n\"\n\"display the screen's current row and column geometry.  I STRONGLY\\n\"\n\"RECOMMEND that you make sure you do NOT have the shell variables\\n\"\n\"LINES and COLUMNS exported into your environment.  Some distributions\\n\"\n\"export those variables via /etc/profile.  Some ncurses programs can\\n\"\n\"become confused when those variables (LINES & COLUMNS) don't reflect\\n\"\n\"the true screen size.\\n\"\n\"\\n\"\n\"Optional personality available\\n\"\n\"------------------------------\\n\"\n\"If you prefer to have all of the options listed in a single menu,\\n\"\n\"rather than the default multimenu hierarchy, run the menuconfig with\\n\"\n\"MENUCONFIG_MODE environment variable set to single_menu. Example:\\n\"\n\"\\n\"\n\"make MENUCONFIG_MODE=single_menu menuconfig\\n\"\n\"\\n\"\n\"<Enter> will then unroll the appropriate category, or enfold it if it\\n\"\n\"is already unrolled.\\n\"\n\"\\n\"\n\"Note that this mode can eventually be a little more CPU expensive\\n\"\n\"(especially with a larger number of unrolled categories) than the\\n\"\n\"default mode.\\n\"\n\"\\n\"\n\n\"Search\\n\"\n\"-------\\n\"\n\"Pressing the forward-slash (/) anywhere brings up a search dialog box.\\n\"\n\"\\n\"\n\n\"Different color themes available\\n\"\n\"--------------------------------\\n\"\n\"It is possible to select different color themes using the variable\\n\"\n\"MENUCONFIG_COLOR. To select a theme use:\\n\"\n\"\\n\"\n\"make MENUCONFIG_COLOR=<theme> menuconfig\\n\"\n\"\\n\"\n\"Available themes are\\n\"\n\" mono       => selects colors suitable for monochrome displays\\n\"\n\" blackbg    => selects a color scheme with black background\\n\"\n\" classic    => theme with blue background. The classic look\\n\"\n\" bluetitle  => an LCD friendly version of classic. (default)\\n\"\n\"\\n\",\nmenu_instructions[] =\n\t\"Arrow keys navigate the menu.  \"\n\t\"<Enter> selects submenus ---> (or empty submenus ----).  \"\n\t\"Highlighted letters are hotkeys.  \"\n\t\"Pressing <Y> includes, <N> excludes, <M> modularizes features.  \"\n\t\"Press <Esc><Esc> to exit, <?> for Help, </> for Search.  \"\n\t\"Legend: [*] built-in  [ ] excluded  <M> module  < > module capable\",\nradiolist_instructions[] =\n\t\"Use the arrow keys to navigate this window or \"\n\t\"press the hotkey of the item you wish to select \"\n\t\"followed by the <SPACE BAR>. \"\n\t\"Press <?> for additional information about this option.\",\ninputbox_instructions_int[] =\n\t\"Please enter a decimal value. \"\n\t\"Fractions will not be accepted.  \"\n\t\"Use the <TAB> key to move from the input field to the buttons below it.\",\ninputbox_instructions_hex[] =\n\t\"Please enter a hexadecimal value. \"\n\t\"Use the <TAB> key to move from the input field to the buttons below it.\",\ninputbox_instructions_string[] =\n\t\"Please enter a string value. \"\n\t\"Use the <TAB> key to move from the input field to the buttons below it.\",\nsetmod_text[] =\n\t\"This feature depends on another which has been configured as a module.\\n\"\n\t\"As a result, this feature will be built as a module.\",\nload_config_text[] =\n\t\"Enter the name of the configuration file you wish to load.  \"\n\t\"Accept the name shown to restore the configuration you \"\n\t\"last retrieved.  Leave blank to abort.\",\nload_config_help[] =\n\t\"\\n\"\n\t\"For various reasons, one may wish to keep several different\\n\"\n\t\"configurations available on a single machine.\\n\"\n\t\"\\n\"\n\t\"If you have saved a previous configuration in a file other than the\\n\"\n\t\"default one, entering its name here will allow you to modify that\\n\"\n\t\"configuration.\\n\"\n\t\"\\n\"\n\t\"If you are uncertain, then you have probably never used alternate\\n\"\n\t\"configuration files. You should therefore leave this blank to abort.\\n\",\nsave_config_text[] =\n\t\"Enter a filename to which this configuration should be saved \"\n\t\"as an alternate.  Leave blank to abort.\",\nsave_config_help[] =\n\t\"\\n\"\n\t\"For various reasons, one may wish to keep different configurations\\n\"\n\t\"available on a single machine.\\n\"\n\t\"\\n\"\n\t\"Entering a file name here will allow you to later retrieve, modify\\n\"\n\t\"and use the current configuration as an alternate to whatever\\n\"\n\t\"configuration options you have selected at that time.\\n\"\n\t\"\\n\"\n\t\"If you are uncertain what all this means then you should probably\\n\"\n\t\"leave this blank.\\n\",\nsearch_help[] =\n\t\"\\n\"\n\t\"Search for symbols and display their relations.\\n\"\n\t\"Regular expressions are allowed.\\n\"\n\t\"Example: search for \\\"^FOO\\\"\\n\"\n\t\"Result:\\n\"\n\t\"-----------------------------------------------------------------\\n\"\n\t\"Symbol: FOO [=m]\\n\"\n\t\"Type  : tristate\\n\"\n\t\"Prompt: Foo bus is used to drive the bar HW\\n\"\n\t\"  Location:\\n\"\n\t\"    -> Bus options (PCI, PCMCIA, EISA, ISA)\\n\"\n\t\"      -> PCI support (PCI [=y])\\n\"\n\t\"(1)     -> PCI access mode (<choice> [=y])\\n\"\n\t\"  Defined at drivers/pci/Kconfig:47\\n\"\n\t\"  Depends on: X86_LOCAL_APIC && X86_IO_APIC || IA64\\n\"\n\t\"  Selects: LIBCRC32\\n\"\n\t\"  Selected by: BAR [=n]\\n\"\n\t\"-----------------------------------------------------------------\\n\"\n\t\"o The line 'Type:' shows the type of the configuration option for\\n\"\n\t\"  this symbol (bool, tristate, string, ...)\\n\"\n\t\"o The line 'Prompt:' shows the text used in the menu structure for\\n\"\n\t\"  this symbol\\n\"\n\t\"o The 'Defined at' line tells at what file / line number the symbol\\n\"\n\t\"  is defined\\n\"\n\t\"o The 'Depends on:' line tells what symbols need to be defined for\\n\"\n\t\"  this symbol to be visible in the menu (selectable)\\n\"\n\t\"o The 'Location:' lines tells where in the menu structure this symbol\\n\"\n\t\"  is located\\n\"\n\t\"    A location followed by a [=y] indicates that this is a\\n\"\n\t\"    selectable menu item - and the current value is displayed inside\\n\"\n\t\"    brackets.\\n\"\n\t\"    Press the key in the (#) prefix to jump directly to that\\n\"\n\t\"    location. You will be returned to the current search results\\n\"\n\t\"    after exiting this new menu.\\n\"\n\t\"o The 'Selects:' line tells what symbols will be automatically\\n\"\n\t\"  selected if this symbol is selected (y or m)\\n\"\n\t\"o The 'Selected by' line tells what symbol has selected this symbol\\n\"\n\t\"\\n\"\n\t\"Only relevant lines are shown.\\n\"\n\t\"\\n\\n\"\n\t\"Search examples:\\n\"\n\t\"Examples: USB\t=> find all symbols containing USB\\n\"\n\t\"          ^USB => find all symbols starting with USB\\n\"\n\t\"          USB$ => find all symbols ending with USB\\n\"\n\t\"\\n\";\n\nstatic int indent;\nstatic struct menu *current_menu;\nstatic int child_count;\nstatic int single_menu_mode;\nstatic int show_all_options;\nstatic int save_and_exit;\nstatic int silent;\nstatic int jump_key_char;\n\nstatic void conf(struct menu *menu, struct menu *active_menu);\n\nstatic char filename[PATH_MAX+1];\nstatic void set_config_filename(const char *config_filename)\n{\n\tstatic char menu_backtitle[PATH_MAX+128];\n\n\tsnprintf(menu_backtitle, sizeof(menu_backtitle), \"%s - %s\",\n\t\t config_filename, rootmenu.prompt->text);\n\tset_dialog_backtitle(menu_backtitle);\n\n\tsnprintf(filename, sizeof(filename), \"%s\", config_filename);\n}\n\nstruct subtitle_part {\n\tstruct list_head entries;\n\tconst char *text;\n};\nstatic LIST_HEAD(trail);\n\nstatic struct subtitle_list *subtitles;\nstatic void set_subtitle(void)\n{\n\tstruct subtitle_part *sp;\n\tstruct subtitle_list *pos, *tmp;\n\n\tfor (pos = subtitles; pos != NULL; pos = tmp) {\n\t\ttmp = pos->next;\n\t\tfree(pos);\n\t}\n\n\tsubtitles = NULL;\n\tlist_for_each_entry(sp, &trail, entries) {\n\t\tif (sp->text) {\n\t\t\tif (pos) {\n\t\t\t\tpos->next = xcalloc(1, sizeof(*pos));\n\t\t\t\tpos = pos->next;\n\t\t\t} else {\n\t\t\t\tsubtitles = pos = xcalloc(1, sizeof(*pos));\n\t\t\t}\n\t\t\tpos->text = sp->text;\n\t\t}\n\t}\n\n\tset_dialog_subtitles(subtitles);\n}\n\nstatic void reset_subtitle(void)\n{\n\tstruct subtitle_list *pos, *tmp;\n\n\tfor (pos = subtitles; pos != NULL; pos = tmp) {\n\t\ttmp = pos->next;\n\t\tfree(pos);\n\t}\n\tsubtitles = NULL;\n\tset_dialog_subtitles(subtitles);\n}\n\nstatic int show_textbox_ext(const char *title, const char *text, int r, int c,\n\t\t\t    int *vscroll, int *hscroll,\n\t\t\t    int (*extra_key_cb)(int, size_t, size_t, void *),\n\t\t\t    void *data)\n{\n\tdialog_clear();\n\treturn dialog_textbox(title, text, r, c, vscroll, hscroll,\n\t\t\t      extra_key_cb, data);\n}\n\nstatic void show_textbox(const char *title, const char *text, int r, int c)\n{\n\tshow_textbox_ext(title, text, r, c, NULL, NULL, NULL, NULL);\n}\n\nstatic void show_helptext(const char *title, const char *text)\n{\n\tshow_textbox(title, text, 0, 0);\n}\n\nstatic void show_help(struct menu *menu)\n{\n\tstruct gstr help = str_new();\n\n\thelp.max_width = getmaxx(stdscr) - 10;\n\tmenu_get_ext_help(menu, &help);\n\n\tshow_helptext(menu_get_prompt(menu), str_get(&help));\n\tstr_free(&help);\n}\n\nstruct search_data {\n\tstruct list_head *head;\n\tstruct menu *target;\n};\n\nstatic int next_jump_key(int key)\n{\n\tif (key < '1' || key > '9')\n\t\treturn '1';\n\n\tkey++;\n\n\tif (key > '9')\n\t\tkey = '1';\n\n\treturn key;\n}\n\nstatic int handle_search_keys(int key, size_t start, size_t end, void *_data)\n{\n\tstruct search_data *data = _data;\n\tstruct jump_key *pos;\n\tint index = 0;\n\n\tif (key < '1' || key > '9')\n\t\treturn 0;\n\n\tlist_for_each_entry(pos, data->head, entries) {\n\t\tindex = next_jump_key(index);\n\n\t\tif (pos->offset < start)\n\t\t\tcontinue;\n\n\t\tif (pos->offset >= end)\n\t\t\tbreak;\n\n\t\tif (key == index) {\n\t\t\tdata->target = pos->target;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint get_jump_key_char(void)\n{\n\tjump_key_char = next_jump_key(jump_key_char);\n\n\treturn jump_key_char;\n}\n\nstatic void search_conf(void)\n{\n\tstruct symbol **sym_arr;\n\tstruct gstr res;\n\tstruct gstr title;\n\tchar *dialog_input;\n\tint dres, vscroll = 0, hscroll = 0;\n\tbool again;\n\tstruct gstr sttext;\n\tstruct subtitle_part stpart;\n\n\ttitle = str_new();\n\tstr_printf( &title, \"Enter (sub)string or regexp to search for \"\n\t\t\t      \"(with or without \\\"%s\\\")\", CONFIG_);\n\nagain:\n\tdialog_clear();\n\tdres = dialog_inputbox(\"Search Configuration Parameter\",\n\t\t\t      str_get(&title),\n\t\t\t      10, 75, \"\");\n\tswitch (dres) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tshow_helptext(\"Search Configuration\", search_help);\n\t\tgoto again;\n\tdefault:\n\t\tstr_free(&title);\n\t\treturn;\n\t}\n\n\t \n\tdialog_input = dialog_input_result;\n\tif (strncasecmp(dialog_input_result, CONFIG_, strlen(CONFIG_)) == 0)\n\t\tdialog_input += strlen(CONFIG_);\n\n\tsttext = str_new();\n\tstr_printf(&sttext, \"Search (%s)\", dialog_input_result);\n\tstpart.text = str_get(&sttext);\n\tlist_add_tail(&stpart.entries, &trail);\n\n\tsym_arr = sym_re_search(dialog_input);\n\tdo {\n\t\tLIST_HEAD(head);\n\t\tstruct search_data data = {\n\t\t\t.head = &head,\n\t\t};\n\t\tstruct jump_key *pos, *tmp;\n\n\t\tjump_key_char = 0;\n\t\tres = get_relations_str(sym_arr, &head);\n\t\tset_subtitle();\n\t\tdres = show_textbox_ext(\"Search Results\", str_get(&res), 0, 0,\n\t\t\t\t\t&vscroll, &hscroll,\n\t\t\t\t\thandle_search_keys, &data);\n\t\tagain = false;\n\t\tif (dres >= '1' && dres <= '9') {\n\t\t\tassert(data.target != NULL);\n\t\t\tconf(data.target->parent, data.target);\n\t\t\tagain = true;\n\t\t}\n\t\tstr_free(&res);\n\t\tlist_for_each_entry_safe(pos, tmp, &head, entries)\n\t\t\tfree(pos);\n\t} while (again);\n\tfree(sym_arr);\n\tstr_free(&title);\n\tlist_del(trail.prev);\n\tstr_free(&sttext);\n}\n\nstatic void build_conf(struct menu *menu)\n{\n\tstruct symbol *sym;\n\tstruct property *prop;\n\tstruct menu *child;\n\tint type, tmp, doint = 2;\n\ttristate val;\n\tchar ch;\n\tbool visible;\n\n\t \n\tvisible = menu_is_visible(menu);\n\tif (show_all_options && !menu_has_prompt(menu))\n\t\treturn;\n\telse if (!show_all_options && !visible)\n\t\treturn;\n\n\tsym = menu->sym;\n\tprop = menu->prompt;\n\tif (!sym) {\n\t\tif (prop && menu != current_menu) {\n\t\t\tconst char *prompt = menu_get_prompt(menu);\n\t\t\tswitch (prop->type) {\n\t\t\tcase P_MENU:\n\t\t\t\tchild_count++;\n\t\t\t\tif (single_menu_mode) {\n\t\t\t\t\titem_make(\"%s%*c%s\",\n\t\t\t\t\t\t  menu->data ? \"-->\" : \"++>\",\n\t\t\t\t\t\t  indent + 1, ' ', prompt);\n\t\t\t\t} else\n\t\t\t\t\titem_make(\"   %*c%s  %s\",\n\t\t\t\t\t\t  indent + 1, ' ', prompt,\n\t\t\t\t\t\t  menu_is_empty(menu) ? \"----\" : \"--->\");\n\t\t\t\titem_set_tag('m');\n\t\t\t\titem_set_data(menu);\n\t\t\t\tif (single_menu_mode && menu->data)\n\t\t\t\t\tgoto conf_childs;\n\t\t\t\treturn;\n\t\t\tcase P_COMMENT:\n\t\t\t\tif (prompt) {\n\t\t\t\t\tchild_count++;\n\t\t\t\t\titem_make(\"   %*c*** %s ***\", indent + 1, ' ', prompt);\n\t\t\t\t\titem_set_tag(':');\n\t\t\t\t\titem_set_data(menu);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (prompt) {\n\t\t\t\t\tchild_count++;\n\t\t\t\t\titem_make(\"---%*c%s\", indent + 1, ' ', prompt);\n\t\t\t\t\titem_set_tag(':');\n\t\t\t\t\titem_set_data(menu);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tdoint = 0;\n\t\tgoto conf_childs;\n\t}\n\n\ttype = sym_get_type(sym);\n\tif (sym_is_choice(sym)) {\n\t\tstruct symbol *def_sym = sym_get_choice_value(sym);\n\t\tstruct menu *def_menu = NULL;\n\n\t\tchild_count++;\n\t\tfor (child = menu->list; child; child = child->next) {\n\t\t\tif (menu_is_visible(child) && child->sym == def_sym)\n\t\t\t\tdef_menu = child;\n\t\t}\n\n\t\tval = sym_get_tristate_value(sym);\n\t\tif (sym_is_changeable(sym)) {\n\t\t\tswitch (type) {\n\t\t\tcase S_BOOLEAN:\n\t\t\t\titem_make(\"[%c]\", val == no ? ' ' : '*');\n\t\t\t\tbreak;\n\t\t\tcase S_TRISTATE:\n\t\t\t\tswitch (val) {\n\t\t\t\tcase yes: ch = '*'; break;\n\t\t\t\tcase mod: ch = 'M'; break;\n\t\t\t\tdefault:  ch = ' '; break;\n\t\t\t\t}\n\t\t\t\titem_make(\"<%c>\", ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem_set_tag('t');\n\t\t\titem_set_data(menu);\n\t\t} else {\n\t\t\titem_make(\"   \");\n\t\t\titem_set_tag(def_menu ? 't' : ':');\n\t\t\titem_set_data(menu);\n\t\t}\n\n\t\titem_add_str(\"%*c%s\", indent + 1, ' ', menu_get_prompt(menu));\n\t\tif (val == yes) {\n\t\t\tif (def_menu) {\n\t\t\t\titem_add_str(\" (%s)\", menu_get_prompt(def_menu));\n\t\t\t\titem_add_str(\"  --->\");\n\t\t\t\tif (def_menu->list) {\n\t\t\t\t\tindent += 2;\n\t\t\t\t\tbuild_conf(def_menu);\n\t\t\t\t\tindent -= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (menu == current_menu) {\n\t\t\titem_make(\"---%*c%s\", indent + 1, ' ', menu_get_prompt(menu));\n\t\t\titem_set_tag(':');\n\t\t\titem_set_data(menu);\n\t\t\tgoto conf_childs;\n\t\t}\n\t\tchild_count++;\n\t\tval = sym_get_tristate_value(sym);\n\t\tif (sym_is_choice_value(sym) && val == yes) {\n\t\t\titem_make(\"   \");\n\t\t\titem_set_tag(':');\n\t\t\titem_set_data(menu);\n\t\t} else {\n\t\t\tswitch (type) {\n\t\t\tcase S_BOOLEAN:\n\t\t\t\tif (sym_is_changeable(sym))\n\t\t\t\t\titem_make(\"[%c]\", val == no ? ' ' : '*');\n\t\t\t\telse\n\t\t\t\t\titem_make(\"-%c-\", val == no ? ' ' : '*');\n\t\t\t\titem_set_tag('t');\n\t\t\t\titem_set_data(menu);\n\t\t\t\tbreak;\n\t\t\tcase S_TRISTATE:\n\t\t\t\tswitch (val) {\n\t\t\t\tcase yes: ch = '*'; break;\n\t\t\t\tcase mod: ch = 'M'; break;\n\t\t\t\tdefault:  ch = ' '; break;\n\t\t\t\t}\n\t\t\t\tif (sym_is_changeable(sym)) {\n\t\t\t\t\tif (sym->rev_dep.tri == mod)\n\t\t\t\t\t\titem_make(\"{%c}\", ch);\n\t\t\t\t\telse\n\t\t\t\t\t\titem_make(\"<%c>\", ch);\n\t\t\t\t} else\n\t\t\t\t\titem_make(\"-%c-\", ch);\n\t\t\t\titem_set_tag('t');\n\t\t\t\titem_set_data(menu);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttmp = 2 + strlen(sym_get_string_value(sym));  \n\t\t\t\titem_make(\"(%s)\", sym_get_string_value(sym));\n\t\t\t\ttmp = indent - tmp + 4;\n\t\t\t\tif (tmp < 0)\n\t\t\t\t\ttmp = 0;\n\t\t\t\titem_add_str(\"%*c%s%s\", tmp, ' ', menu_get_prompt(menu),\n\t\t\t\t\t     (sym_has_value(sym) || !sym_is_changeable(sym)) ?\n\t\t\t\t\t     \"\" : \" (NEW)\");\n\t\t\t\titem_set_tag('s');\n\t\t\t\titem_set_data(menu);\n\t\t\t\tgoto conf_childs;\n\t\t\t}\n\t\t}\n\t\titem_add_str(\"%*c%s%s\", indent + 1, ' ', menu_get_prompt(menu),\n\t\t\t  (sym_has_value(sym) || !sym_is_changeable(sym)) ?\n\t\t\t  \"\" : \" (NEW)\");\n\t\tif (menu->prompt->type == P_MENU) {\n\t\t\titem_add_str(\"  %s\", menu_is_empty(menu) ? \"----\" : \"--->\");\n\t\t\treturn;\n\t\t}\n\t}\n\nconf_childs:\n\tindent += doint;\n\tfor (child = menu->list; child; child = child->next)\n\t\tbuild_conf(child);\n\tindent -= doint;\n}\n\nstatic void conf_choice(struct menu *menu)\n{\n\tconst char *prompt = menu_get_prompt(menu);\n\tstruct menu *child;\n\tstruct symbol *active;\n\n\tactive = sym_get_choice_value(menu->sym);\n\twhile (1) {\n\t\tint res;\n\t\tint selected;\n\t\titem_reset();\n\n\t\tcurrent_menu = menu;\n\t\tfor (child = menu->list; child; child = child->next) {\n\t\t\tif (!menu_is_visible(child))\n\t\t\t\tcontinue;\n\t\t\tif (child->sym)\n\t\t\t\titem_make(\"%s\", menu_get_prompt(child));\n\t\t\telse {\n\t\t\t\titem_make(\"*** %s ***\", menu_get_prompt(child));\n\t\t\t\titem_set_tag(':');\n\t\t\t}\n\t\t\titem_set_data(child);\n\t\t\tif (child->sym == active)\n\t\t\t\titem_set_selected(1);\n\t\t\tif (child->sym == sym_get_choice_value(menu->sym))\n\t\t\t\titem_set_tag('X');\n\t\t}\n\t\tdialog_clear();\n\t\tres = dialog_checklist(prompt ? prompt : \"Main Menu\",\n\t\t\t\t\tradiolist_instructions,\n\t\t\t\t\tMENUBOX_HEIGTH_MIN,\n\t\t\t\t\tMENUBOX_WIDTH_MIN,\n\t\t\t\t\tCHECKLIST_HEIGTH_MIN);\n\t\tselected = item_activate_selected();\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tif (selected) {\n\t\t\t\tchild = item_data();\n\t\t\t\tif (!child->sym)\n\t\t\t\t\tbreak;\n\n\t\t\t\tsym_set_tristate_value(child->sym, yes);\n\t\t\t}\n\t\t\treturn;\n\t\tcase 1:\n\t\t\tif (selected) {\n\t\t\t\tchild = item_data();\n\t\t\t\tshow_help(child);\n\t\t\t\tactive = child->sym;\n\t\t\t} else\n\t\t\t\tshow_help(menu);\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\treturn;\n\t\tcase -ERRDISPLAYTOOSMALL:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void conf_string(struct menu *menu)\n{\n\tconst char *prompt = menu_get_prompt(menu);\n\n\twhile (1) {\n\t\tint res;\n\t\tconst char *heading;\n\n\t\tswitch (sym_get_type(menu->sym)) {\n\t\tcase S_INT:\n\t\t\theading = inputbox_instructions_int;\n\t\t\tbreak;\n\t\tcase S_HEX:\n\t\t\theading = inputbox_instructions_hex;\n\t\t\tbreak;\n\t\tcase S_STRING:\n\t\t\theading = inputbox_instructions_string;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\theading = \"Internal mconf error!\";\n\t\t}\n\t\tdialog_clear();\n\t\tres = dialog_inputbox(prompt ? prompt : \"Main Menu\",\n\t\t\t\t      heading, 10, 75,\n\t\t\t\t      sym_get_string_value(menu->sym));\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tif (sym_set_string_value(menu->sym, dialog_input_result))\n\t\t\t\treturn;\n\t\t\tshow_textbox(NULL, \"You have made an invalid entry.\", 5, 43);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tshow_help(menu);\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void conf_load(void)\n{\n\n\twhile (1) {\n\t\tint res;\n\t\tdialog_clear();\n\t\tres = dialog_inputbox(NULL, load_config_text,\n\t\t\t\t      11, 55, filename);\n\t\tswitch(res) {\n\t\tcase 0:\n\t\t\tif (!dialog_input_result[0])\n\t\t\t\treturn;\n\t\t\tif (!conf_read(dialog_input_result)) {\n\t\t\t\tset_config_filename(dialog_input_result);\n\t\t\t\tconf_set_changed(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tshow_textbox(NULL, \"File does not exist!\", 5, 38);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tshow_helptext(\"Load Alternate Configuration\", load_config_help);\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void conf_save(void)\n{\n\twhile (1) {\n\t\tint res;\n\t\tdialog_clear();\n\t\tres = dialog_inputbox(NULL, save_config_text,\n\t\t\t\t      11, 55, filename);\n\t\tswitch(res) {\n\t\tcase 0:\n\t\t\tif (!dialog_input_result[0])\n\t\t\t\treturn;\n\t\t\tif (!conf_write(dialog_input_result)) {\n\t\t\t\tset_config_filename(dialog_input_result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tshow_textbox(NULL, \"Can't create file!\", 5, 60);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tshow_helptext(\"Save Alternate Configuration\", save_config_help);\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void conf(struct menu *menu, struct menu *active_menu)\n{\n\tstruct menu *submenu;\n\tconst char *prompt = menu_get_prompt(menu);\n\tstruct subtitle_part stpart;\n\tstruct symbol *sym;\n\tint res;\n\tint s_scroll = 0;\n\n\tif (menu != &rootmenu)\n\t\tstpart.text = menu_get_prompt(menu);\n\telse\n\t\tstpart.text = NULL;\n\tlist_add_tail(&stpart.entries, &trail);\n\n\twhile (1) {\n\t\titem_reset();\n\t\tcurrent_menu = menu;\n\t\tbuild_conf(menu);\n\t\tif (!child_count)\n\t\t\tbreak;\n\t\tset_subtitle();\n\t\tdialog_clear();\n\t\tres = dialog_menu(prompt ? prompt : \"Main Menu\",\n\t\t\t\t  menu_instructions,\n\t\t\t\t  active_menu, &s_scroll);\n\t\tif (res == 1 || res == KEY_ESC || res == -ERRDISPLAYTOOSMALL)\n\t\t\tbreak;\n\t\tif (item_count() != 0) {\n\t\t\tif (!item_activate_selected())\n\t\t\t\tcontinue;\n\t\t\tif (!item_tag())\n\t\t\t\tcontinue;\n\t\t}\n\t\tsubmenu = item_data();\n\t\tactive_menu = item_data();\n\t\tif (submenu)\n\t\t\tsym = submenu->sym;\n\t\telse\n\t\t\tsym = NULL;\n\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tswitch (item_tag()) {\n\t\t\tcase 'm':\n\t\t\t\tif (single_menu_mode)\n\t\t\t\t\tsubmenu->data = (void *) (long) !submenu->data;\n\t\t\t\telse\n\t\t\t\t\tconf(submenu, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tif (sym_is_choice(sym) && sym_get_tristate_value(sym) == yes)\n\t\t\t\t\tconf_choice(submenu);\n\t\t\t\telse if (submenu->prompt->type == P_MENU)\n\t\t\t\t\tconf(submenu, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tconf_string(submenu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (sym)\n\t\t\t\tshow_help(submenu);\n\t\t\telse {\n\t\t\t\treset_subtitle();\n\t\t\t\tshow_helptext(\"README\", mconf_readme);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\treset_subtitle();\n\t\t\tconf_save();\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\treset_subtitle();\n\t\t\tconf_load();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif (item_is_tag('t')) {\n\t\t\t\tif (sym_set_tristate_value(sym, yes))\n\t\t\t\t\tbreak;\n\t\t\t\tif (sym_set_tristate_value(sym, mod))\n\t\t\t\t\tshow_textbox(NULL, setmod_text, 6, 74);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tif (item_is_tag('t'))\n\t\t\t\tsym_set_tristate_value(sym, no);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif (item_is_tag('t'))\n\t\t\t\tsym_set_tristate_value(sym, mod);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (item_is_tag('t'))\n\t\t\t\tsym_toggle_tristate_value(sym);\n\t\t\telse if (item_is_tag('m'))\n\t\t\t\tconf(submenu, NULL);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tsearch_conf();\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tshow_all_options = !show_all_options;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_del(trail.prev);\n}\n\nstatic void conf_message_callback(const char *s)\n{\n\tif (save_and_exit) {\n\t\tif (!silent)\n\t\t\tprintf(\"%s\", s);\n\t} else {\n\t\tshow_textbox(NULL, s, 6, 60);\n\t}\n}\n\nstatic int handle_exit(void)\n{\n\tint res;\n\n\tsave_and_exit = 1;\n\treset_subtitle();\n\tdialog_clear();\n\tif (conf_get_changed())\n\t\tres = dialog_yesno(NULL,\n\t\t\t\t   \"Do you wish to save your new configuration?\\n\"\n\t\t\t\t     \"(Press <ESC><ESC> to continue kernel configuration.)\",\n\t\t\t\t   6, 60);\n\telse\n\t\tres = -1;\n\n\tend_dialog(saved_x, saved_y);\n\n\tswitch (res) {\n\tcase 0:\n\t\tif (conf_write(filename)) {\n\t\t\tfprintf(stderr, \"\\n\\n\"\n\t\t\t\t\t  \"Error while writing of the configuration.\\n\"\n\t\t\t\t\t  \"Your configuration changes were NOT saved.\"\n\t\t\t\t\t  \"\\n\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tconf_write_autoconf(0);\n\t\t \n\tcase -1:\n\t\tif (!silent)\n\t\t\tprintf(\"\\n\\n\"\n\t\t\t\t \"*** End of the configuration.\\n\"\n\t\t\t\t \"*** Execute 'make' to start the build or try 'make help'.\"\n\t\t\t\t \"\\n\\n\");\n\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tif (!silent)\n\t\t\tfprintf(stderr, \"\\n\\n\"\n\t\t\t\t\t  \"Your configuration changes were NOT saved.\"\n\t\t\t\t\t  \"\\n\\n\");\n\t\tif (res != KEY_ESC)\n\t\t\tres = 0;\n\t}\n\n\treturn res;\n}\n\nstatic void sig_handler(int signo)\n{\n\texit(handle_exit());\n}\n\nint main(int ac, char **av)\n{\n\tchar *mode;\n\tint res;\n\n\tsignal(SIGINT, sig_handler);\n\n\tif (ac > 1 && strcmp(av[1], \"-s\") == 0) {\n\t\tsilent = 1;\n\t\t \n\t\tconf_set_message_callback(NULL);\n\t\tav++;\n\t}\n\tconf_parse(av[1]);\n\tconf_read(NULL);\n\n\tmode = getenv(\"MENUCONFIG_MODE\");\n\tif (mode) {\n\t\tif (!strcasecmp(mode, \"single_menu\"))\n\t\t\tsingle_menu_mode = 1;\n\t}\n\n\tif (init_dialog(NULL)) {\n\t\tfprintf(stderr, \"Your display is too small to run Menuconfig!\\n\");\n\t\tfprintf(stderr, \"It must be at least 19 lines by 80 columns.\\n\");\n\t\treturn 1;\n\t}\n\n\tset_config_filename(conf_get_configname());\n\tconf_set_message_callback(conf_message_callback);\n\tdo {\n\t\tconf(&rootmenu, NULL);\n\t\tres = handle_exit();\n\t} while (res == KEY_ESC);\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}