{
  "module_name": "menu.c",
  "hash_id": "0ddfe3110ab7dd1bcc3a77d4ddcb03120be958f2dfc6eb82dbacfb544e1d5743",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/menu.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lkc.h\"\n#include \"internal.h\"\n\nstatic const char nohelp_text[] = \"There is no help available for this option.\";\n\nstruct menu rootmenu;\nstatic struct menu **last_entry_ptr;\n\nstruct file *file_list;\nstruct file *current_file;\n\nvoid menu_warn(struct menu *menu, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"%s:%d:warning: \", menu->file->name, menu->lineno);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n\nstatic void prop_warn(struct property *prop, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"%s:%d:warning: \", prop->file->name, prop->lineno);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\tva_end(ap);\n}\n\nvoid _menu_init(void)\n{\n\tcurrent_entry = current_menu = &rootmenu;\n\tlast_entry_ptr = &rootmenu.list;\n}\n\nvoid menu_add_entry(struct symbol *sym)\n{\n\tstruct menu *menu;\n\n\tmenu = xmalloc(sizeof(*menu));\n\tmemset(menu, 0, sizeof(*menu));\n\tmenu->sym = sym;\n\tmenu->parent = current_menu;\n\tmenu->file = current_file;\n\tmenu->lineno = zconf_lineno();\n\n\t*last_entry_ptr = menu;\n\tlast_entry_ptr = &menu->next;\n\tcurrent_entry = menu;\n\tif (sym)\n\t\tmenu_add_symbol(P_SYMBOL, sym, NULL);\n}\n\nstruct menu *menu_add_menu(void)\n{\n\tlast_entry_ptr = &current_entry->list;\n\tcurrent_menu = current_entry;\n\treturn current_menu;\n}\n\nvoid menu_end_menu(void)\n{\n\tlast_entry_ptr = &current_menu->next;\n\tcurrent_menu = current_menu->parent;\n}\n\n \nstatic struct expr *rewrite_m(struct expr *e)\n{\n\tif (!e)\n\t\treturn e;\n\n\tswitch (e->type) {\n\tcase E_NOT:\n\t\te->left.expr = rewrite_m(e->left.expr);\n\t\tbreak;\n\tcase E_OR:\n\tcase E_AND:\n\t\te->left.expr = rewrite_m(e->left.expr);\n\t\te->right.expr = rewrite_m(e->right.expr);\n\t\tbreak;\n\tcase E_SYMBOL:\n\t\t \n\t\tif (e->left.sym == &symbol_mod)\n\t\t\treturn expr_alloc_and(e, expr_alloc_symbol(modules_sym));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn e;\n}\n\nvoid menu_add_dep(struct expr *dep)\n{\n\tcurrent_entry->dep = expr_alloc_and(current_entry->dep, dep);\n}\n\nvoid menu_set_type(int type)\n{\n\tstruct symbol *sym = current_entry->sym;\n\n\tif (sym->type == type)\n\t\treturn;\n\tif (sym->type == S_UNKNOWN) {\n\t\tsym->type = type;\n\t\treturn;\n\t}\n\tmenu_warn(current_entry,\n\t\t\"ignoring type redefinition of '%s' from '%s' to '%s'\",\n\t\tsym->name ? sym->name : \"<choice>\",\n\t\tsym_type_name(sym->type), sym_type_name(type));\n}\n\nstatic struct property *menu_add_prop(enum prop_type type, struct expr *expr,\n\t\t\t\t      struct expr *dep)\n{\n\tstruct property *prop;\n\n\tprop = xmalloc(sizeof(*prop));\n\tmemset(prop, 0, sizeof(*prop));\n\tprop->type = type;\n\tprop->file = current_file;\n\tprop->lineno = zconf_lineno();\n\tprop->menu = current_entry;\n\tprop->expr = expr;\n\tprop->visible.expr = dep;\n\n\t \n\tif (current_entry->sym) {\n\t\tstruct property **propp;\n\n\t\tfor (propp = &current_entry->sym->prop;\n\t\t     *propp;\n\t\t     propp = &(*propp)->next)\n\t\t\t;\n\t\t*propp = prop;\n\t}\n\n\treturn prop;\n}\n\nstruct property *menu_add_prompt(enum prop_type type, char *prompt,\n\t\t\t\t struct expr *dep)\n{\n\tstruct property *prop = menu_add_prop(type, NULL, dep);\n\n\tif (isspace(*prompt)) {\n\t\tprop_warn(prop, \"leading whitespace ignored\");\n\t\twhile (isspace(*prompt))\n\t\t\tprompt++;\n\t}\n\tif (current_entry->prompt)\n\t\tprop_warn(prop, \"prompt redefined\");\n\n\t \n\tif (type == P_PROMPT) {\n\t\tstruct menu *menu = current_entry;\n\n\t\twhile ((menu = menu->parent) != NULL) {\n\t\t\tstruct expr *dup_expr;\n\n\t\t\tif (!menu->visibility)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tdup_expr = expr_copy(menu->visibility);\n\n\t\t\tprop->visible.expr = expr_alloc_and(prop->visible.expr,\n\t\t\t\t\t\t\t    dup_expr);\n\t\t}\n\t}\n\n\tcurrent_entry->prompt = prop;\n\tprop->text = prompt;\n\n\treturn prop;\n}\n\nvoid menu_add_visibility(struct expr *expr)\n{\n\tcurrent_entry->visibility = expr_alloc_and(current_entry->visibility,\n\t    expr);\n}\n\nvoid menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)\n{\n\tmenu_add_prop(type, expr, dep);\n}\n\nvoid menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)\n{\n\tmenu_add_prop(type, expr_alloc_symbol(sym), dep);\n}\n\nstatic int menu_validate_number(struct symbol *sym, struct symbol *sym2)\n{\n\treturn sym2->type == S_INT || sym2->type == S_HEX ||\n\t       (sym2->type == S_UNKNOWN && sym_string_valid(sym, sym2->name));\n}\n\nstatic void sym_check_prop(struct symbol *sym)\n{\n\tstruct property *prop;\n\tstruct symbol *sym2;\n\tchar *use;\n\n\tfor (prop = sym->prop; prop; prop = prop->next) {\n\t\tswitch (prop->type) {\n\t\tcase P_DEFAULT:\n\t\t\tif ((sym->type == S_STRING || sym->type == S_INT || sym->type == S_HEX) &&\n\t\t\t    prop->expr->type != E_SYMBOL)\n\t\t\t\tprop_warn(prop,\n\t\t\t\t    \"default for config symbol '%s'\"\n\t\t\t\t    \" must be a single symbol\", sym->name);\n\t\t\tif (prop->expr->type != E_SYMBOL)\n\t\t\t\tbreak;\n\t\t\tsym2 = prop_get_symbol(prop);\n\t\t\tif (sym->type == S_HEX || sym->type == S_INT) {\n\t\t\t\tif (!menu_validate_number(sym, sym2))\n\t\t\t\t\tprop_warn(prop,\n\t\t\t\t\t    \"'%s': number is invalid\",\n\t\t\t\t\t    sym->name);\n\t\t\t}\n\t\t\tif (sym_is_choice(sym)) {\n\t\t\t\tstruct property *choice_prop =\n\t\t\t\t\tsym_get_choice_prop(sym2);\n\n\t\t\t\tif (!choice_prop ||\n\t\t\t\t    prop_get_symbol(choice_prop) != sym)\n\t\t\t\t\tprop_warn(prop,\n\t\t\t\t\t\t  \"choice default symbol '%s' is not contained in the choice\",\n\t\t\t\t\t\t  sym2->name);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase P_SELECT:\n\t\tcase P_IMPLY:\n\t\t\tuse = prop->type == P_SELECT ? \"select\" : \"imply\";\n\t\t\tsym2 = prop_get_symbol(prop);\n\t\t\tif (sym->type != S_BOOLEAN && sym->type != S_TRISTATE)\n\t\t\t\tprop_warn(prop,\n\t\t\t\t    \"config symbol '%s' uses %s, but is \"\n\t\t\t\t    \"not bool or tristate\", sym->name, use);\n\t\t\telse if (sym2->type != S_UNKNOWN &&\n\t\t\t\t sym2->type != S_BOOLEAN &&\n\t\t\t\t sym2->type != S_TRISTATE)\n\t\t\t\tprop_warn(prop,\n\t\t\t\t    \"'%s' has wrong type. '%s' only \"\n\t\t\t\t    \"accept arguments of bool and \"\n\t\t\t\t    \"tristate type\", sym2->name, use);\n\t\t\tbreak;\n\t\tcase P_RANGE:\n\t\t\tif (sym->type != S_INT && sym->type != S_HEX)\n\t\t\t\tprop_warn(prop, \"range is only allowed \"\n\t\t\t\t\t\t\"for int or hex symbols\");\n\t\t\tif (!menu_validate_number(sym, prop->expr->left.sym) ||\n\t\t\t    !menu_validate_number(sym, prop->expr->right.sym))\n\t\t\t\tprop_warn(prop, \"range is invalid\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\t}\n}\n\nvoid menu_finalize(struct menu *parent)\n{\n\tstruct menu *menu, *last_menu;\n\tstruct symbol *sym;\n\tstruct property *prop;\n\tstruct expr *parentdep, *basedep, *dep, *dep2, **ep;\n\n\tsym = parent->sym;\n\tif (parent->list) {\n\t\t \n\n\t\tif (sym && sym_is_choice(sym)) {\n\t\t\tif (sym->type == S_UNKNOWN) {\n\t\t\t\t \n\t\t\t\tcurrent_entry = parent;\n\t\t\t\tfor (menu = parent->list; menu; menu = menu->next) {\n\t\t\t\t\tif (menu->sym && menu->sym->type != S_UNKNOWN) {\n\t\t\t\t\t\tmenu_set_type(menu->sym->type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tfor (menu = parent->list; menu; menu = menu->next) {\n\t\t\t\tcurrent_entry = menu;\n\t\t\t\tif (menu->sym && menu->sym->type == S_UNKNOWN)\n\t\t\t\t\tmenu_set_type(sym->type);\n\t\t\t}\n\n\t\t\t \n\t\t\tparentdep = expr_alloc_symbol(sym);\n\t\t} else {\n\t\t\t \n\t\t\tparentdep = parent->dep;\n\t\t}\n\n\t\t \n\t\tfor (menu = parent->list; menu; menu = menu->next) {\n\t\t\t \n\t\t\tbasedep = rewrite_m(menu->dep);\n\t\t\tbasedep = expr_transform(basedep);\n\t\t\tbasedep = expr_alloc_and(expr_copy(parentdep), basedep);\n\t\t\tbasedep = expr_eliminate_dups(basedep);\n\t\t\tmenu->dep = basedep;\n\n\t\t\tif (menu->sym)\n\t\t\t\t \n\t\t\t\tprop = menu->sym->prop;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tprop = menu->prompt;\n\n\t\t\t \n\t\t\tfor (; prop; prop = prop->next) {\n\t\t\t\tif (prop->menu != menu)\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tdep = rewrite_m(prop->visible.expr);\n\t\t\t\tdep = expr_transform(dep);\n\t\t\t\tdep = expr_alloc_and(expr_copy(basedep), dep);\n\t\t\t\tdep = expr_eliminate_dups(dep);\n\t\t\t\tif (menu->sym && menu->sym->type != S_TRISTATE)\n\t\t\t\t\tdep = expr_trans_bool(dep);\n\t\t\t\tprop->visible.expr = dep;\n\n\t\t\t\t \n\t\t\t\tif (prop->type == P_SELECT) {\n\t\t\t\t\tstruct symbol *es = prop_get_symbol(prop);\n\t\t\t\t\tes->rev_dep.expr = expr_alloc_or(es->rev_dep.expr,\n\t\t\t\t\t\t\texpr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));\n\t\t\t\t} else if (prop->type == P_IMPLY) {\n\t\t\t\t\tstruct symbol *es = prop_get_symbol(prop);\n\t\t\t\t\tes->implied.expr = expr_alloc_or(es->implied.expr,\n\t\t\t\t\t\t\texpr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (sym && sym_is_choice(sym))\n\t\t\texpr_free(parentdep);\n\n\t\t \n\t\tfor (menu = parent->list; menu; menu = menu->next)\n\t\t\tmenu_finalize(menu);\n\t} else if (sym) {\n\t\t \n\n\t\tbasedep = parent->prompt ? parent->prompt->visible.expr : NULL;\n\t\tbasedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);\n\t\tbasedep = expr_eliminate_dups(expr_transform(basedep));\n\n\t\t \n\t\tlast_menu = NULL;\n\t\tfor (menu = parent->next; menu; menu = menu->next) {\n\t\t\tdep = menu->prompt ? menu->prompt->visible.expr : menu->dep;\n\t\t\tif (!expr_contains_symbol(dep, sym))\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tif (expr_depends_symbol(dep, sym))\n\t\t\t\t \n\t\t\t\tgoto next;\n\n\t\t\t \n\t\t\tdep = expr_trans_compare(dep, E_UNEQUAL, &symbol_no);\n\t\t\tdep = expr_eliminate_dups(expr_transform(dep));\n\t\t\tdep2 = expr_copy(basedep);\n\t\t\texpr_eliminate_eq(&dep, &dep2);\n\t\t\texpr_free(dep);\n\t\t\tif (!expr_is_yes(dep2)) {\n\t\t\t\t \n\t\t\t\texpr_free(dep2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\texpr_free(dep2);\n\t\tnext:\n\t\t\tmenu_finalize(menu);\n\t\t\tmenu->parent = parent;\n\t\t\tlast_menu = menu;\n\t\t}\n\t\texpr_free(basedep);\n\t\tif (last_menu) {\n\t\t\tparent->list = parent->next;\n\t\t\tparent->next = last_menu->next;\n\t\t\tlast_menu->next = NULL;\n\t\t}\n\n\t\tsym->dir_dep.expr = expr_alloc_or(sym->dir_dep.expr, parent->dep);\n\t}\n\tfor (menu = parent->list; menu; menu = menu->next) {\n\t\tif (sym && sym_is_choice(sym) &&\n\t\t    menu->sym && !sym_is_choice_value(menu->sym)) {\n\t\t\tcurrent_entry = menu;\n\t\t\tmenu->sym->flags |= SYMBOL_CHOICEVAL;\n\t\t\tif (!menu->prompt)\n\t\t\t\tmenu_warn(menu, \"choice value must have a prompt\");\n\t\t\tfor (prop = menu->sym->prop; prop; prop = prop->next) {\n\t\t\t\tif (prop->type == P_DEFAULT)\n\t\t\t\t\tprop_warn(prop, \"defaults for choice \"\n\t\t\t\t\t\t  \"values not supported\");\n\t\t\t\tif (prop->menu == menu)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (prop->type == P_PROMPT &&\n\t\t\t\t    prop->menu->parent->sym != sym)\n\t\t\t\t\tprop_warn(prop, \"choice value used outside its choice group\");\n\t\t\t}\n\t\t\t \n\t\t\tif (sym->type == S_TRISTATE && menu->sym->type != S_TRISTATE) {\n\t\t\t\tbasedep = expr_alloc_comp(E_EQUAL, sym, &symbol_yes);\n\t\t\t\tmenu->dep = expr_alloc_and(basedep, menu->dep);\n\t\t\t\tfor (prop = menu->sym->prop; prop; prop = prop->next) {\n\t\t\t\t\tif (prop->menu != menu)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tprop->visible.expr = expr_alloc_and(expr_copy(basedep),\n\t\t\t\t\t\t\t\t\t    prop->visible.expr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmenu_add_symbol(P_CHOICE, sym, NULL);\n\t\t\tprop = sym_get_choice_prop(sym);\n\t\t\tfor (ep = &prop->expr; *ep; ep = &(*ep)->left.expr)\n\t\t\t\t;\n\t\t\t*ep = expr_alloc_one(E_LIST, NULL);\n\t\t\t(*ep)->right.sym = menu->sym;\n\t\t}\n\n\t\t \n\t\tif (menu->list && (!menu->prompt || !menu->prompt->text)) {\n\t\t\tfor (last_menu = menu->list; ; last_menu = last_menu->next) {\n\t\t\t\tlast_menu->parent = parent;\n\t\t\t\tif (!last_menu->next)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_menu->next = menu->next;\n\t\t\tmenu->next = menu->list;\n\t\t\tmenu->list = NULL;\n\t\t}\n\t}\n\n\tif (sym && !(sym->flags & SYMBOL_WARNED)) {\n\t\tif (sym->type == S_UNKNOWN)\n\t\t\tmenu_warn(parent, \"config symbol defined without type\");\n\n\t\tif (sym_is_choice(sym) && !parent->prompt)\n\t\t\tmenu_warn(parent, \"choice must have a prompt\");\n\n\t\t \n\t\tsym_check_prop(sym);\n\t\tsym->flags |= SYMBOL_WARNED;\n\t}\n\n\t \n\tif (sym && !sym_is_optional(sym) && parent->prompt) {\n\t\tsym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr,\n\t\t\t\texpr_alloc_and(parent->prompt->visible.expr,\n\t\t\t\t\texpr_alloc_symbol(&symbol_mod)));\n\t}\n}\n\nbool menu_has_prompt(struct menu *menu)\n{\n\tif (!menu->prompt)\n\t\treturn false;\n\treturn true;\n}\n\n \nbool menu_is_empty(struct menu *menu)\n{\n\tstruct menu *child;\n\n\tfor (child = menu->list; child; child = child->next) {\n\t\tif (menu_is_visible(child))\n\t\t\treturn(false);\n\t}\n\treturn(true);\n}\n\nbool menu_is_visible(struct menu *menu)\n{\n\tstruct menu *child;\n\tstruct symbol *sym;\n\ttristate visible;\n\n\tif (!menu->prompt)\n\t\treturn false;\n\n\tif (menu->visibility) {\n\t\tif (expr_calc_value(menu->visibility) == no)\n\t\t\treturn false;\n\t}\n\n\tsym = menu->sym;\n\tif (sym) {\n\t\tsym_calc_value(sym);\n\t\tvisible = menu->prompt->visible.tri;\n\t} else\n\t\tvisible = menu->prompt->visible.tri = expr_calc_value(menu->prompt->visible.expr);\n\n\tif (visible != no)\n\t\treturn true;\n\n\tif (!sym || sym_get_tristate_value(menu->sym) == no)\n\t\treturn false;\n\n\tfor (child = menu->list; child; child = child->next) {\n\t\tif (menu_is_visible(child)) {\n\t\t\tif (sym)\n\t\t\t\tsym->flags |= SYMBOL_DEF_USER;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nconst char *menu_get_prompt(struct menu *menu)\n{\n\tif (menu->prompt)\n\t\treturn menu->prompt->text;\n\telse if (menu->sym)\n\t\treturn menu->sym->name;\n\treturn NULL;\n}\n\nstruct menu *menu_get_parent_menu(struct menu *menu)\n{\n\tenum prop_type type;\n\n\tfor (; menu != &rootmenu; menu = menu->parent) {\n\t\ttype = menu->prompt ? menu->prompt->type : 0;\n\t\tif (type == P_MENU)\n\t\t\tbreak;\n\t}\n\treturn menu;\n}\n\nbool menu_has_help(struct menu *menu)\n{\n\treturn menu->help != NULL;\n}\n\nconst char *menu_get_help(struct menu *menu)\n{\n\tif (menu->help)\n\t\treturn menu->help;\n\telse\n\t\treturn \"\";\n}\n\nstatic void get_def_str(struct gstr *r, struct menu *menu)\n{\n\tstr_printf(r, \"Defined at %s:%d\\n\",\n\t\t   menu->file->name, menu->lineno);\n}\n\nstatic void get_dep_str(struct gstr *r, struct expr *expr, const char *prefix)\n{\n\tif (!expr_is_yes(expr)) {\n\t\tstr_append(r, prefix);\n\t\texpr_gstr_print(expr, r);\n\t\tstr_append(r, \"\\n\");\n\t}\n}\n\nint __attribute__((weak)) get_jump_key_char(void)\n{\n\treturn -1;\n}\n\nstatic void get_prompt_str(struct gstr *r, struct property *prop,\n\t\t\t   struct list_head *head)\n{\n\tint i, j;\n\tstruct menu *submenu[8], *menu, *location = NULL;\n\tstruct jump_key *jump = NULL;\n\n\tstr_printf(r, \"  Prompt: %s\\n\", prop->text);\n\n\tget_dep_str(r, prop->menu->dep, \"  Depends on: \");\n\t \n\tif (!expr_eq(prop->menu->dep, prop->visible.expr))\n\t\tget_dep_str(r, prop->visible.expr, \"  Visible if: \");\n\n\tmenu = prop->menu;\n\tfor (i = 0; menu != &rootmenu && i < 8; menu = menu->parent) {\n\t\tsubmenu[i++] = menu;\n\t\tif (location == NULL && menu_is_visible(menu))\n\t\t\tlocation = menu;\n\t}\n\tif (head && location) {\n\t\tjump = xmalloc(sizeof(struct jump_key));\n\t\tjump->target = location;\n\t\tlist_add_tail(&jump->entries, head);\n\t}\n\n\tstr_printf(r, \"  Location:\\n\");\n\tfor (j = 0; --i >= 0; j++) {\n\t\tint jk = -1;\n\t\tint indent = 2 * j + 4;\n\n\t\tmenu = submenu[i];\n\t\tif (jump && menu == location) {\n\t\t\tjump->offset = strlen(r->s);\n\t\t\tjk = get_jump_key_char();\n\t\t}\n\n\t\tif (jk >= 0) {\n\t\t\tstr_printf(r, \"(%c)\", jk);\n\t\t\tindent -= 3;\n\t\t}\n\n\t\tstr_printf(r, \"%*c-> %s\", indent, ' ', menu_get_prompt(menu));\n\t\tif (menu->sym) {\n\t\t\tstr_printf(r, \" (%s [=%s])\", menu->sym->name ?\n\t\t\t\tmenu->sym->name : \"<choice>\",\n\t\t\t\tsym_get_string_value(menu->sym));\n\t\t}\n\t\tstr_append(r, \"\\n\");\n\t}\n}\n\nstatic void get_symbol_props_str(struct gstr *r, struct symbol *sym,\n\t\t\t\t enum prop_type tok, const char *prefix)\n{\n\tbool hit = false;\n\tstruct property *prop;\n\n\tfor_all_properties(sym, prop, tok) {\n\t\tif (!hit) {\n\t\t\tstr_append(r, prefix);\n\t\t\thit = true;\n\t\t} else\n\t\t\tstr_printf(r, \" && \");\n\t\texpr_gstr_print(prop->expr, r);\n\t}\n\tif (hit)\n\t\tstr_append(r, \"\\n\");\n}\n\n \nstatic void get_symbol_str(struct gstr *r, struct symbol *sym,\n\t\t    struct list_head *head)\n{\n\tstruct property *prop;\n\n\tif (sym && sym->name) {\n\t\tstr_printf(r, \"Symbol: %s [=%s]\\n\", sym->name,\n\t\t\t   sym_get_string_value(sym));\n\t\tstr_printf(r, \"Type  : %s\\n\", sym_type_name(sym->type));\n\t\tif (sym->type == S_INT || sym->type == S_HEX) {\n\t\t\tprop = sym_get_range_prop(sym);\n\t\t\tif (prop) {\n\t\t\t\tstr_printf(r, \"Range : \");\n\t\t\t\texpr_gstr_print(prop->expr, r);\n\t\t\t\tstr_append(r, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor_all_properties(sym, prop, P_SYMBOL) {\n\t\tif (prop->menu->prompt) {\n\t\t\tget_def_str(r, prop->menu);\n\t\t\tget_prompt_str(r, prop->menu->prompt, head);\n\t\t}\n\t}\n\n\tfor_all_properties(sym, prop, P_SYMBOL) {\n\t\tif (!prop->menu->prompt) {\n\t\t\tget_def_str(r, prop->menu);\n\t\t\tget_dep_str(r, prop->menu->dep, \"  Depends on: \");\n\t\t}\n\t}\n\n\tget_symbol_props_str(r, sym, P_SELECT, \"Selects: \");\n\tif (sym->rev_dep.expr) {\n\t\texpr_gstr_print_revdep(sym->rev_dep.expr, r, yes, \"Selected by [y]:\\n\");\n\t\texpr_gstr_print_revdep(sym->rev_dep.expr, r, mod, \"Selected by [m]:\\n\");\n\t\texpr_gstr_print_revdep(sym->rev_dep.expr, r, no, \"Selected by [n]:\\n\");\n\t}\n\n\tget_symbol_props_str(r, sym, P_IMPLY, \"Implies: \");\n\tif (sym->implied.expr) {\n\t\texpr_gstr_print_revdep(sym->implied.expr, r, yes, \"Implied by [y]:\\n\");\n\t\texpr_gstr_print_revdep(sym->implied.expr, r, mod, \"Implied by [m]:\\n\");\n\t\texpr_gstr_print_revdep(sym->implied.expr, r, no, \"Implied by [n]:\\n\");\n\t}\n\n\tstr_append(r, \"\\n\\n\");\n}\n\nstruct gstr get_relations_str(struct symbol **sym_arr, struct list_head *head)\n{\n\tstruct symbol *sym;\n\tstruct gstr res = str_new();\n\tint i;\n\n\tfor (i = 0; sym_arr && (sym = sym_arr[i]); i++)\n\t\tget_symbol_str(&res, sym, head);\n\tif (!i)\n\t\tstr_append(&res, \"No matches found.\\n\");\n\treturn res;\n}\n\n\nvoid menu_get_ext_help(struct menu *menu, struct gstr *help)\n{\n\tstruct symbol *sym = menu->sym;\n\tconst char *help_text = nohelp_text;\n\n\tif (menu_has_help(menu)) {\n\t\tif (sym->name)\n\t\t\tstr_printf(help, \"%s%s:\\n\\n\", CONFIG_, sym->name);\n\t\thelp_text = menu_get_help(menu);\n\t}\n\tstr_printf(help, \"%s\\n\", help_text);\n\tif (sym)\n\t\tget_symbol_str(help, sym, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}