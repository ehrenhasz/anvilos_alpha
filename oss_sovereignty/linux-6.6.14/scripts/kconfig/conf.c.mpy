{
  "module_name": "conf.c",
  "hash_id": "8b66204909764291fa638942998ddb1c7bd64f994c7ee892103ca53b55d887e4",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/conf.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <sys/time.h>\n#include <errno.h>\n\n#include \"lkc.h\"\n\nstatic void conf(struct menu *menu);\nstatic void check_conf(struct menu *menu);\n\nenum input_mode {\n\toldaskconfig,\n\tsyncconfig,\n\toldconfig,\n\tallnoconfig,\n\tallyesconfig,\n\tallmodconfig,\n\talldefconfig,\n\trandconfig,\n\tdefconfig,\n\tsavedefconfig,\n\tlistnewconfig,\n\thelpnewconfig,\n\tolddefconfig,\n\tyes2modconfig,\n\tmod2yesconfig,\n\tmod2noconfig,\n};\nstatic enum input_mode input_mode = oldaskconfig;\nstatic int input_mode_opt;\nstatic int indent = 1;\nstatic int tty_stdio;\nstatic int sync_kconfig;\nstatic int conf_cnt;\nstatic char line[PATH_MAX];\nstatic struct menu *rootEntry;\n\nstatic void print_help(struct menu *menu)\n{\n\tstruct gstr help = str_new();\n\n\tmenu_get_ext_help(menu, &help);\n\n\tprintf(\"\\n%s\\n\", str_get(&help));\n\tstr_free(&help);\n}\n\nstatic void strip(char *str)\n{\n\tchar *p = str;\n\tint l;\n\n\twhile ((isspace(*p)))\n\t\tp++;\n\tl = strlen(p);\n\tif (p != str)\n\t\tmemmove(str, p, l + 1);\n\tif (!l)\n\t\treturn;\n\tp = str + l - 1;\n\twhile ((isspace(*p)))\n\t\t*p-- = 0;\n}\n\n \nstatic void xfgets(char *str, int size, FILE *in)\n{\n\tif (!fgets(str, size, in))\n\t\tfprintf(stderr, \"\\nError in reading or end of file.\\n\");\n\n\tif (!tty_stdio)\n\t\tprintf(\"%s\", str);\n}\n\nstatic void set_randconfig_seed(void)\n{\n\tunsigned int seed;\n\tchar *env;\n\tbool seed_set = false;\n\n\tenv = getenv(\"KCONFIG_SEED\");\n\tif (env && *env) {\n\t\tchar *endp;\n\n\t\tseed = strtol(env, &endp, 0);\n\t\tif (*endp == '\\0')\n\t\t\tseed_set = true;\n\t}\n\n\tif (!seed_set) {\n\t\tstruct timeval now;\n\n\t\t \n\t\tgettimeofday(&now, NULL);\n\t\tseed = (now.tv_sec + 1) * (now.tv_usec + 1);\n\t}\n\n\tprintf(\"KCONFIG_SEED=0x%X\\n\", seed);\n\tsrand(seed);\n}\n\nstatic bool randomize_choice_values(struct symbol *csym)\n{\n\tstruct property *prop;\n\tstruct symbol *sym;\n\tstruct expr *e;\n\tint cnt, def;\n\n\t \n\tif (csym->curr.tri != yes)\n\t\treturn false;\n\n\tprop = sym_get_choice_prop(csym);\n\n\t \n\tcnt = 0;\n\texpr_list_for_each_sym(prop->expr, e, sym)\n\t\tcnt++;\n\n\t \n\tdef = rand() % cnt;\n\n\tcnt = 0;\n\texpr_list_for_each_sym(prop->expr, e, sym) {\n\t\tif (def == cnt++) {\n\t\t\tsym->def[S_DEF_USER].tri = yes;\n\t\t\tcsym->def[S_DEF_USER].val = sym;\n\t\t} else {\n\t\t\tsym->def[S_DEF_USER].tri = no;\n\t\t}\n\t\tsym->flags |= SYMBOL_DEF_USER;\n\t\t \n\t\tsym->flags &= ~SYMBOL_VALID;\n\t}\n\tcsym->flags |= SYMBOL_DEF_USER;\n\t \n\tcsym->flags &= ~SYMBOL_VALID;\n\n\treturn true;\n}\n\nenum conf_def_mode {\n\tdef_default,\n\tdef_yes,\n\tdef_mod,\n\tdef_no,\n\tdef_random\n};\n\nstatic bool conf_set_all_new_symbols(enum conf_def_mode mode)\n{\n\tstruct symbol *sym, *csym;\n\tint i, cnt;\n\t \n\tint pby = 50;  \n\tint pty = 33;  \n\tint ptm = 33;  \n\tbool has_changed = false;\n\n\tif (mode == def_random) {\n\t\tint n, p[3];\n\t\tchar *env = getenv(\"KCONFIG_PROBABILITY\");\n\n\t\tn = 0;\n\t\twhile (env && *env) {\n\t\t\tchar *endp;\n\t\t\tint tmp = strtol(env, &endp, 10);\n\n\t\t\tif (tmp >= 0 && tmp <= 100) {\n\t\t\t\tp[n++] = tmp;\n\t\t\t} else {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tperror(\"KCONFIG_PROBABILITY\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tenv = (*endp == ':') ? endp + 1 : endp;\n\t\t\tif (n >= 3)\n\t\t\t\tbreak;\n\t\t}\n\t\tswitch (n) {\n\t\tcase 1:\n\t\t\tpby = p[0];\n\t\t\tptm = pby / 2;\n\t\t\tpty = pby - ptm;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpty = p[0];\n\t\t\tptm = p[1];\n\t\t\tpby = pty + ptm;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpby = p[0];\n\t\t\tpty = p[1];\n\t\t\tptm = p[2];\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pty + ptm > 100) {\n\t\t\terrno = ERANGE;\n\t\t\tperror(\"KCONFIG_PROBABILITY\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfor_all_symbols(i, sym) {\n\t\tif (sym_has_value(sym) || sym->flags & SYMBOL_VALID)\n\t\t\tcontinue;\n\t\tswitch (sym_get_type(sym)) {\n\t\tcase S_BOOLEAN:\n\t\tcase S_TRISTATE:\n\t\t\thas_changed = true;\n\t\t\tswitch (mode) {\n\t\t\tcase def_yes:\n\t\t\t\tsym->def[S_DEF_USER].tri = yes;\n\t\t\t\tbreak;\n\t\t\tcase def_mod:\n\t\t\t\tsym->def[S_DEF_USER].tri = mod;\n\t\t\t\tbreak;\n\t\t\tcase def_no:\n\t\t\t\tsym->def[S_DEF_USER].tri = no;\n\t\t\t\tbreak;\n\t\t\tcase def_random:\n\t\t\t\tsym->def[S_DEF_USER].tri = no;\n\t\t\t\tcnt = rand() % 100;\n\t\t\t\tif (sym->type == S_TRISTATE) {\n\t\t\t\t\tif (cnt < pty)\n\t\t\t\t\t\tsym->def[S_DEF_USER].tri = yes;\n\t\t\t\t\telse if (cnt < pty + ptm)\n\t\t\t\t\t\tsym->def[S_DEF_USER].tri = mod;\n\t\t\t\t} else if (cnt < pby)\n\t\t\t\t\tsym->def[S_DEF_USER].tri = yes;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(sym_is_choice(sym) && mode == def_random))\n\t\t\t\tsym->flags |= SYMBOL_DEF_USER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tsym_clear_all_valid();\n\n\t \n\tif (mode != def_random) {\n\t\tfor_all_symbols(i, csym) {\n\t\t\tif ((sym_is_choice(csym) && !sym_has_value(csym)) ||\n\t\t\t    sym_is_choice_value(csym))\n\t\t\t\tcsym->flags |= SYMBOL_NEED_SET_CHOICE_VALUES;\n\t\t}\n\t}\n\n\tfor_all_symbols(i, csym) {\n\t\tif (sym_has_value(csym) || !sym_is_choice(csym))\n\t\t\tcontinue;\n\n\t\tsym_calc_value(csym);\n\t\tif (mode == def_random)\n\t\t\thas_changed |= randomize_choice_values(csym);\n\t\telse {\n\t\t\tset_all_choice_values(csym);\n\t\t\thas_changed = true;\n\t\t}\n\t}\n\n\treturn has_changed;\n}\n\nstatic void conf_rewrite_tristates(tristate old_val, tristate new_val)\n{\n\tstruct symbol *sym;\n\tint i;\n\n\tfor_all_symbols(i, sym) {\n\t\tif (sym_get_type(sym) == S_TRISTATE &&\n\t\t    sym->def[S_DEF_USER].tri == old_val)\n\t\t\tsym->def[S_DEF_USER].tri = new_val;\n\t}\n\tsym_clear_all_valid();\n}\n\nstatic int conf_askvalue(struct symbol *sym, const char *def)\n{\n\tif (!sym_has_value(sym))\n\t\tprintf(\"(NEW) \");\n\n\tline[0] = '\\n';\n\tline[1] = 0;\n\n\tif (!sym_is_changeable(sym)) {\n\t\tprintf(\"%s\\n\", def);\n\t\tline[0] = '\\n';\n\t\tline[1] = 0;\n\t\treturn 0;\n\t}\n\n\tswitch (input_mode) {\n\tcase oldconfig:\n\tcase syncconfig:\n\t\tif (sym_has_value(sym)) {\n\t\t\tprintf(\"%s\\n\", def);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\tdefault:\n\t\tfflush(stdout);\n\t\txfgets(line, sizeof(line), stdin);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic int conf_string(struct menu *menu)\n{\n\tstruct symbol *sym = menu->sym;\n\tconst char *def;\n\n\twhile (1) {\n\t\tprintf(\"%*s%s \", indent - 1, \"\", menu->prompt->text);\n\t\tprintf(\"(%s) \", sym->name);\n\t\tdef = sym_get_string_value(sym);\n\t\tif (def)\n\t\t\tprintf(\"[%s] \", def);\n\t\tif (!conf_askvalue(sym, def))\n\t\t\treturn 0;\n\t\tswitch (line[0]) {\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t \n\t\t\tif (line[1] == '\\n') {\n\t\t\t\tprint_help(menu);\n\t\t\t\tdef = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\tdefault:\n\t\t\tline[strlen(line)-1] = 0;\n\t\t\tdef = line;\n\t\t}\n\t\tif (def && sym_set_string_value(sym, def))\n\t\t\treturn 0;\n\t}\n}\n\nstatic int conf_sym(struct menu *menu)\n{\n\tstruct symbol *sym = menu->sym;\n\ttristate oldval, newval;\n\n\twhile (1) {\n\t\tprintf(\"%*s%s \", indent - 1, \"\", menu->prompt->text);\n\t\tif (sym->name)\n\t\t\tprintf(\"(%s) \", sym->name);\n\t\tputchar('[');\n\t\toldval = sym_get_tristate_value(sym);\n\t\tswitch (oldval) {\n\t\tcase no:\n\t\t\tputchar('N');\n\t\t\tbreak;\n\t\tcase mod:\n\t\t\tputchar('M');\n\t\t\tbreak;\n\t\tcase yes:\n\t\t\tputchar('Y');\n\t\t\tbreak;\n\t\t}\n\t\tif (oldval != no && sym_tristate_within_range(sym, no))\n\t\t\tprintf(\"/n\");\n\t\tif (oldval != mod && sym_tristate_within_range(sym, mod))\n\t\t\tprintf(\"/m\");\n\t\tif (oldval != yes && sym_tristate_within_range(sym, yes))\n\t\t\tprintf(\"/y\");\n\t\tprintf(\"/?] \");\n\t\tif (!conf_askvalue(sym, sym_get_string_value(sym)))\n\t\t\treturn 0;\n\t\tstrip(line);\n\n\t\tswitch (line[0]) {\n\t\tcase 'n':\n\t\tcase 'N':\n\t\t\tnewval = no;\n\t\t\tif (!line[1] || !strcmp(&line[1], \"o\"))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tnewval = mod;\n\t\t\tif (!line[1])\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\tcase 'y':\n\t\tcase 'Y':\n\t\t\tnewval = yes;\n\t\t\tif (!line[1] || !strcmp(&line[1], \"es\"))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\tcase 0:\n\t\t\tnewval = oldval;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tgoto help;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (sym_set_tristate_value(sym, newval))\n\t\t\treturn 0;\nhelp:\n\t\tprint_help(menu);\n\t}\n}\n\nstatic int conf_choice(struct menu *menu)\n{\n\tstruct symbol *sym, *def_sym;\n\tstruct menu *child;\n\tbool is_new;\n\n\tsym = menu->sym;\n\tis_new = !sym_has_value(sym);\n\tif (sym_is_changeable(sym)) {\n\t\tconf_sym(menu);\n\t\tsym_calc_value(sym);\n\t\tswitch (sym_get_tristate_value(sym)) {\n\t\tcase no:\n\t\t\treturn 1;\n\t\tcase mod:\n\t\t\treturn 0;\n\t\tcase yes:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (sym_get_tristate_value(sym)) {\n\t\tcase no:\n\t\t\treturn 1;\n\t\tcase mod:\n\t\t\tprintf(\"%*s%s\\n\", indent - 1, \"\", menu_get_prompt(menu));\n\t\t\treturn 0;\n\t\tcase yes:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint cnt, def;\n\n\t\tprintf(\"%*s%s\\n\", indent - 1, \"\", menu_get_prompt(menu));\n\t\tdef_sym = sym_get_choice_value(sym);\n\t\tcnt = def = 0;\n\t\tline[0] = 0;\n\t\tfor (child = menu->list; child; child = child->next) {\n\t\t\tif (!menu_is_visible(child))\n\t\t\t\tcontinue;\n\t\t\tif (!child->sym) {\n\t\t\t\tprintf(\"%*c %s\\n\", indent, '*', menu_get_prompt(child));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (child->sym == def_sym) {\n\t\t\t\tdef = cnt;\n\t\t\t\tprintf(\"%*c\", indent, '>');\n\t\t\t} else\n\t\t\t\tprintf(\"%*c\", indent, ' ');\n\t\t\tprintf(\" %d. %s\", cnt, menu_get_prompt(child));\n\t\t\tif (child->sym->name)\n\t\t\t\tprintf(\" (%s)\", child->sym->name);\n\t\t\tif (!sym_has_value(child->sym))\n\t\t\t\tprintf(\" (NEW)\");\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"%*schoice\", indent - 1, \"\");\n\t\tif (cnt == 1) {\n\t\t\tprintf(\"[1]: 1\\n\");\n\t\t\tgoto conf_childs;\n\t\t}\n\t\tprintf(\"[1-%d?]: \", cnt);\n\t\tswitch (input_mode) {\n\t\tcase oldconfig:\n\t\tcase syncconfig:\n\t\t\tif (!is_new) {\n\t\t\t\tcnt = def;\n\t\t\t\tprintf(\"%d\\n\", cnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\tcase oldaskconfig:\n\t\t\tfflush(stdout);\n\t\t\txfgets(line, sizeof(line), stdin);\n\t\t\tstrip(line);\n\t\t\tif (line[0] == '?') {\n\t\t\t\tprint_help(menu);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!line[0])\n\t\t\t\tcnt = def;\n\t\t\telse if (isdigit(line[0]))\n\t\t\t\tcnt = atoi(line);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\tconf_childs:\n\t\tfor (child = menu->list; child; child = child->next) {\n\t\t\tif (!child->sym || !menu_is_visible(child))\n\t\t\t\tcontinue;\n\t\t\tif (!--cnt)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!child)\n\t\t\tcontinue;\n\t\tif (line[0] && line[strlen(line) - 1] == '?') {\n\t\t\tprint_help(child);\n\t\t\tcontinue;\n\t\t}\n\t\tsym_set_tristate_value(child->sym, yes);\n\t\tfor (child = child->list; child; child = child->next) {\n\t\t\tindent += 2;\n\t\t\tconf(child);\n\t\t\tindent -= 2;\n\t\t}\n\t\treturn 1;\n\t}\n}\n\nstatic void conf(struct menu *menu)\n{\n\tstruct symbol *sym;\n\tstruct property *prop;\n\tstruct menu *child;\n\n\tif (!menu_is_visible(menu))\n\t\treturn;\n\n\tsym = menu->sym;\n\tprop = menu->prompt;\n\tif (prop) {\n\t\tconst char *prompt;\n\n\t\tswitch (prop->type) {\n\t\tcase P_MENU:\n\t\t\t \n\t\t\tif (input_mode != oldaskconfig && rootEntry != menu) {\n\t\t\t\tcheck_conf(menu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\tcase P_COMMENT:\n\t\t\tprompt = menu_get_prompt(menu);\n\t\t\tif (prompt)\n\t\t\t\tprintf(\"%*c\\n%*c %s\\n%*c\\n\",\n\t\t\t\t\tindent, '*',\n\t\t\t\t\tindent, '*', prompt,\n\t\t\t\t\tindent, '*');\n\t\tdefault:\n\t\t\t;\n\t\t}\n\t}\n\n\tif (!sym)\n\t\tgoto conf_childs;\n\n\tif (sym_is_choice(sym)) {\n\t\tconf_choice(menu);\n\t\tif (sym->curr.tri != mod)\n\t\t\treturn;\n\t\tgoto conf_childs;\n\t}\n\n\tswitch (sym->type) {\n\tcase S_INT:\n\tcase S_HEX:\n\tcase S_STRING:\n\t\tconf_string(menu);\n\t\tbreak;\n\tdefault:\n\t\tconf_sym(menu);\n\t\tbreak;\n\t}\n\nconf_childs:\n\tif (sym)\n\t\tindent += 2;\n\tfor (child = menu->list; child; child = child->next)\n\t\tconf(child);\n\tif (sym)\n\t\tindent -= 2;\n}\n\nstatic void check_conf(struct menu *menu)\n{\n\tstruct symbol *sym;\n\tstruct menu *child;\n\n\tif (!menu_is_visible(menu))\n\t\treturn;\n\n\tsym = menu->sym;\n\tif (sym && !sym_has_value(sym) &&\n\t    (sym_is_changeable(sym) ||\n\t     (sym_is_choice(sym) && sym_get_tristate_value(sym) == yes))) {\n\n\t\tswitch (input_mode) {\n\t\tcase listnewconfig:\n\t\t\tif (sym->name)\n\t\t\t\tprint_symbol_for_listconfig(sym);\n\t\t\tbreak;\n\t\tcase helpnewconfig:\n\t\t\tprintf(\"-----\\n\");\n\t\t\tprint_help(menu);\n\t\t\tprintf(\"-----\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!conf_cnt++)\n\t\t\t\tprintf(\"*\\n* Restart config...\\n*\\n\");\n\t\t\trootEntry = menu_get_parent_menu(menu);\n\t\t\tconf(rootEntry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (child = menu->list; child; child = child->next)\n\t\tcheck_conf(child);\n}\n\nstatic const struct option long_opts[] = {\n\t{\"help\",          no_argument,       NULL,            'h'},\n\t{\"silent\",        no_argument,       NULL,            's'},\n\t{\"oldaskconfig\",  no_argument,       &input_mode_opt, oldaskconfig},\n\t{\"oldconfig\",     no_argument,       &input_mode_opt, oldconfig},\n\t{\"syncconfig\",    no_argument,       &input_mode_opt, syncconfig},\n\t{\"defconfig\",     required_argument, &input_mode_opt, defconfig},\n\t{\"savedefconfig\", required_argument, &input_mode_opt, savedefconfig},\n\t{\"allnoconfig\",   no_argument,       &input_mode_opt, allnoconfig},\n\t{\"allyesconfig\",  no_argument,       &input_mode_opt, allyesconfig},\n\t{\"allmodconfig\",  no_argument,       &input_mode_opt, allmodconfig},\n\t{\"alldefconfig\",  no_argument,       &input_mode_opt, alldefconfig},\n\t{\"randconfig\",    no_argument,       &input_mode_opt, randconfig},\n\t{\"listnewconfig\", no_argument,       &input_mode_opt, listnewconfig},\n\t{\"helpnewconfig\", no_argument,       &input_mode_opt, helpnewconfig},\n\t{\"olddefconfig\",  no_argument,       &input_mode_opt, olddefconfig},\n\t{\"yes2modconfig\", no_argument,       &input_mode_opt, yes2modconfig},\n\t{\"mod2yesconfig\", no_argument,       &input_mode_opt, mod2yesconfig},\n\t{\"mod2noconfig\",  no_argument,       &input_mode_opt, mod2noconfig},\n\t{NULL, 0, NULL, 0}\n};\n\nstatic void conf_usage(const char *progname)\n{\n\tprintf(\"Usage: %s [options] <kconfig-file>\\n\", progname);\n\tprintf(\"\\n\");\n\tprintf(\"Generic options:\\n\");\n\tprintf(\"  -h, --help              Print this message and exit.\\n\");\n\tprintf(\"  -s, --silent            Do not print log.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Mode options:\\n\");\n\tprintf(\"  --listnewconfig         List new options\\n\");\n\tprintf(\"  --helpnewconfig         List new options and help text\\n\");\n\tprintf(\"  --oldaskconfig          Start a new configuration using a line-oriented program\\n\");\n\tprintf(\"  --oldconfig             Update a configuration using a provided .config as base\\n\");\n\tprintf(\"  --syncconfig            Similar to oldconfig but generates configuration in\\n\"\n\t       \"                          include/{generated/,config/}\\n\");\n\tprintf(\"  --olddefconfig          Same as oldconfig but sets new symbols to their default value\\n\");\n\tprintf(\"  --defconfig <file>      New config with default defined in <file>\\n\");\n\tprintf(\"  --savedefconfig <file>  Save the minimal current configuration to <file>\\n\");\n\tprintf(\"  --allnoconfig           New config where all options are answered with no\\n\");\n\tprintf(\"  --allyesconfig          New config where all options are answered with yes\\n\");\n\tprintf(\"  --allmodconfig          New config where all options are answered with mod\\n\");\n\tprintf(\"  --alldefconfig          New config with all symbols set to default\\n\");\n\tprintf(\"  --randconfig            New config with random answer to all options\\n\");\n\tprintf(\"  --yes2modconfig         Change answers from yes to mod if possible\\n\");\n\tprintf(\"  --mod2yesconfig         Change answers from mod to yes if possible\\n\");\n\tprintf(\"  --mod2noconfig          Change answers from mod to no if possible\\n\");\n\tprintf(\"  (If none of the above is given, --oldaskconfig is the default)\\n\");\n}\n\nint main(int ac, char **av)\n{\n\tconst char *progname = av[0];\n\tint opt;\n\tconst char *name, *defconfig_file = NULL  ;\n\tint no_conf_write = 0;\n\n\ttty_stdio = isatty(0) && isatty(1);\n\n\twhile ((opt = getopt_long(ac, av, \"hs\", long_opts, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'h':\n\t\t\tconf_usage(progname);\n\t\t\texit(1);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tconf_set_message_callback(NULL);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tinput_mode = input_mode_opt;\n\t\t\tswitch (input_mode) {\n\t\t\tcase syncconfig:\n\t\t\t\t \n\t\t\t\tconf_set_message_callback(NULL);\n\t\t\t\tsync_kconfig = 1;\n\t\t\t\tbreak;\n\t\t\tcase defconfig:\n\t\t\tcase savedefconfig:\n\t\t\t\tdefconfig_file = optarg;\n\t\t\t\tbreak;\n\t\t\tcase randconfig:\n\t\t\t\tset_randconfig_seed();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ac == optind) {\n\t\tfprintf(stderr, \"%s: Kconfig file missing\\n\", av[0]);\n\t\tconf_usage(progname);\n\t\texit(1);\n\t}\n\tconf_parse(av[optind]);\n\t \n\n\tswitch (input_mode) {\n\tcase defconfig:\n\t\tif (conf_read(defconfig_file)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"***\\n\"\n\t\t\t\t  \"*** Can't find default configuration \\\"%s\\\"!\\n\"\n\t\t\t\t  \"***\\n\",\n\t\t\t\tdefconfig_file);\n\t\t\texit(1);\n\t\t}\n\t\tbreak;\n\tcase savedefconfig:\n\tcase syncconfig:\n\tcase oldaskconfig:\n\tcase oldconfig:\n\tcase listnewconfig:\n\tcase helpnewconfig:\n\tcase olddefconfig:\n\tcase yes2modconfig:\n\tcase mod2yesconfig:\n\tcase mod2noconfig:\n\t\tconf_read(NULL);\n\t\tbreak;\n\tcase allnoconfig:\n\tcase allyesconfig:\n\tcase allmodconfig:\n\tcase alldefconfig:\n\tcase randconfig:\n\t\tname = getenv(\"KCONFIG_ALLCONFIG\");\n\t\tif (!name)\n\t\t\tbreak;\n\t\tif ((strcmp(name, \"\") != 0) && (strcmp(name, \"1\") != 0)) {\n\t\t\tif (conf_read_simple(name, S_DEF_USER)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"*** Can't read seed configuration \\\"%s\\\"!\\n\",\n\t\t\t\t\tname);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tswitch (input_mode) {\n\t\tcase allnoconfig:\tname = \"allno.config\"; break;\n\t\tcase allyesconfig:\tname = \"allyes.config\"; break;\n\t\tcase allmodconfig:\tname = \"allmod.config\"; break;\n\t\tcase alldefconfig:\tname = \"alldef.config\"; break;\n\t\tcase randconfig:\tname = \"allrandom.config\"; break;\n\t\tdefault: break;\n\t\t}\n\t\tif (conf_read_simple(name, S_DEF_USER) &&\n\t\t    conf_read_simple(\"all.config\", S_DEF_USER)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"*** KCONFIG_ALLCONFIG set, but no \\\"%s\\\" or \\\"all.config\\\" file found\\n\",\n\t\t\t\tname);\n\t\t\texit(1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sync_kconfig) {\n\t\tname = getenv(\"KCONFIG_NOSILENTUPDATE\");\n\t\tif (name && *name) {\n\t\t\tif (conf_get_changed()) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"\\n*** The configuration requires explicit update.\\n\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tno_conf_write = 1;\n\t\t}\n\t}\n\n\tswitch (input_mode) {\n\tcase allnoconfig:\n\t\tconf_set_all_new_symbols(def_no);\n\t\tbreak;\n\tcase allyesconfig:\n\t\tconf_set_all_new_symbols(def_yes);\n\t\tbreak;\n\tcase allmodconfig:\n\t\tconf_set_all_new_symbols(def_mod);\n\t\tbreak;\n\tcase alldefconfig:\n\t\tconf_set_all_new_symbols(def_default);\n\t\tbreak;\n\tcase randconfig:\n\t\t \n\t\twhile (conf_set_all_new_symbols(def_random)) ;\n\t\tbreak;\n\tcase defconfig:\n\t\tconf_set_all_new_symbols(def_default);\n\t\tbreak;\n\tcase savedefconfig:\n\t\tbreak;\n\tcase yes2modconfig:\n\t\tconf_rewrite_tristates(yes, mod);\n\t\tbreak;\n\tcase mod2yesconfig:\n\t\tconf_rewrite_tristates(mod, yes);\n\t\tbreak;\n\tcase mod2noconfig:\n\t\tconf_rewrite_tristates(mod, no);\n\t\tbreak;\n\tcase oldaskconfig:\n\t\trootEntry = &rootmenu;\n\t\tconf(&rootmenu);\n\t\tinput_mode = oldconfig;\n\t\t \n\tcase oldconfig:\n\tcase listnewconfig:\n\tcase helpnewconfig:\n\tcase syncconfig:\n\t\t \n\t\tdo {\n\t\t\tconf_cnt = 0;\n\t\t\tcheck_conf(&rootmenu);\n\t\t} while (conf_cnt);\n\t\tbreak;\n\tcase olddefconfig:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (input_mode == savedefconfig) {\n\t\tif (conf_write_defconfig(defconfig_file)) {\n\t\t\tfprintf(stderr, \"n*** Error while saving defconfig to: %s\\n\\n\",\n\t\t\t\tdefconfig_file);\n\t\t\treturn 1;\n\t\t}\n\t} else if (input_mode != listnewconfig && input_mode != helpnewconfig) {\n\t\tif (!no_conf_write && conf_write(NULL)) {\n\t\t\tfprintf(stderr, \"\\n*** Error during writing of the configuration.\\n\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\tif (conf_write_autoconf(sync_kconfig) && sync_kconfig) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"\\n*** Error during sync of the configuration.\\n\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}