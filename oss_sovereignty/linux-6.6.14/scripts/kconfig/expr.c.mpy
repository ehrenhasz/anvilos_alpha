{
  "module_name": "expr.c",
  "hash_id": "3f85c10764d3d5f5c0309808693a965bd9c5a66c0f4a4cc0d38afe4062ff4aec",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/expr.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lkc.h\"\n\n#define DEBUG_EXPR\t0\n\nstatic struct expr *expr_eliminate_yn(struct expr *e);\n\nstruct expr *expr_alloc_symbol(struct symbol *sym)\n{\n\tstruct expr *e = xcalloc(1, sizeof(*e));\n\te->type = E_SYMBOL;\n\te->left.sym = sym;\n\treturn e;\n}\n\nstruct expr *expr_alloc_one(enum expr_type type, struct expr *ce)\n{\n\tstruct expr *e = xcalloc(1, sizeof(*e));\n\te->type = type;\n\te->left.expr = ce;\n\treturn e;\n}\n\nstruct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2)\n{\n\tstruct expr *e = xcalloc(1, sizeof(*e));\n\te->type = type;\n\te->left.expr = e1;\n\te->right.expr = e2;\n\treturn e;\n}\n\nstruct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2)\n{\n\tstruct expr *e = xcalloc(1, sizeof(*e));\n\te->type = type;\n\te->left.sym = s1;\n\te->right.sym = s2;\n\treturn e;\n}\n\nstruct expr *expr_alloc_and(struct expr *e1, struct expr *e2)\n{\n\tif (!e1)\n\t\treturn e2;\n\treturn e2 ? expr_alloc_two(E_AND, e1, e2) : e1;\n}\n\nstruct expr *expr_alloc_or(struct expr *e1, struct expr *e2)\n{\n\tif (!e1)\n\t\treturn e2;\n\treturn e2 ? expr_alloc_two(E_OR, e1, e2) : e1;\n}\n\nstruct expr *expr_copy(const struct expr *org)\n{\n\tstruct expr *e;\n\n\tif (!org)\n\t\treturn NULL;\n\n\te = xmalloc(sizeof(*org));\n\tmemcpy(e, org, sizeof(*org));\n\tswitch (org->type) {\n\tcase E_SYMBOL:\n\t\te->left = org->left;\n\t\tbreak;\n\tcase E_NOT:\n\t\te->left.expr = expr_copy(org->left.expr);\n\t\tbreak;\n\tcase E_EQUAL:\n\tcase E_GEQ:\n\tcase E_GTH:\n\tcase E_LEQ:\n\tcase E_LTH:\n\tcase E_UNEQUAL:\n\t\te->left.sym = org->left.sym;\n\t\te->right.sym = org->right.sym;\n\t\tbreak;\n\tcase E_AND:\n\tcase E_OR:\n\tcase E_LIST:\n\t\te->left.expr = expr_copy(org->left.expr);\n\t\te->right.expr = expr_copy(org->right.expr);\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"can't copy type %d\\n\", e->type);\n\t\tfree(e);\n\t\te = NULL;\n\t\tbreak;\n\t}\n\n\treturn e;\n}\n\nvoid expr_free(struct expr *e)\n{\n\tif (!e)\n\t\treturn;\n\n\tswitch (e->type) {\n\tcase E_SYMBOL:\n\t\tbreak;\n\tcase E_NOT:\n\t\texpr_free(e->left.expr);\n\t\tbreak;\n\tcase E_EQUAL:\n\tcase E_GEQ:\n\tcase E_GTH:\n\tcase E_LEQ:\n\tcase E_LTH:\n\tcase E_UNEQUAL:\n\t\tbreak;\n\tcase E_OR:\n\tcase E_AND:\n\t\texpr_free(e->left.expr);\n\t\texpr_free(e->right.expr);\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"how to free type %d?\\n\", e->type);\n\t\tbreak;\n\t}\n\tfree(e);\n}\n\nstatic int trans_count;\n\n#define e1 (*ep1)\n#define e2 (*ep2)\n\n \nstatic void __expr_eliminate_eq(enum expr_type type, struct expr **ep1, struct expr **ep2)\n{\n\t \n\n\tif (e1->type == type) {\n\t\t__expr_eliminate_eq(type, &e1->left.expr, &e2);\n\t\t__expr_eliminate_eq(type, &e1->right.expr, &e2);\n\t\treturn;\n\t}\n\tif (e2->type == type) {\n\t\t__expr_eliminate_eq(type, &e1, &e2->left.expr);\n\t\t__expr_eliminate_eq(type, &e1, &e2->right.expr);\n\t\treturn;\n\t}\n\n\t \n\n\tif (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&\n\t    e1->left.sym == e2->left.sym &&\n\t    (e1->left.sym == &symbol_yes || e1->left.sym == &symbol_no))\n\t\treturn;\n\tif (!expr_eq(e1, e2))\n\t\treturn;\n\n\t \n\n\ttrans_count++;\n\texpr_free(e1); expr_free(e2);\n\tswitch (type) {\n\tcase E_OR:\n\t\te1 = expr_alloc_symbol(&symbol_no);\n\t\te2 = expr_alloc_symbol(&symbol_no);\n\t\tbreak;\n\tcase E_AND:\n\t\te1 = expr_alloc_symbol(&symbol_yes);\n\t\te2 = expr_alloc_symbol(&symbol_yes);\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n}\n\n \nvoid expr_eliminate_eq(struct expr **ep1, struct expr **ep2)\n{\n\tif (!e1 || !e2)\n\t\treturn;\n\tswitch (e1->type) {\n\tcase E_OR:\n\tcase E_AND:\n\t\t__expr_eliminate_eq(e1->type, ep1, ep2);\n\tdefault:\n\t\t;\n\t}\n\tif (e1->type != e2->type) switch (e2->type) {\n\tcase E_OR:\n\tcase E_AND:\n\t\t__expr_eliminate_eq(e2->type, ep1, ep2);\n\tdefault:\n\t\t;\n\t}\n\te1 = expr_eliminate_yn(e1);\n\te2 = expr_eliminate_yn(e2);\n}\n\n#undef e1\n#undef e2\n\n \nint expr_eq(struct expr *e1, struct expr *e2)\n{\n\tint res, old_count;\n\n\t \n\tif (!e1 || !e2)\n\t\treturn expr_is_yes(e1) && expr_is_yes(e2);\n\n\tif (e1->type != e2->type)\n\t\treturn 0;\n\tswitch (e1->type) {\n\tcase E_EQUAL:\n\tcase E_GEQ:\n\tcase E_GTH:\n\tcase E_LEQ:\n\tcase E_LTH:\n\tcase E_UNEQUAL:\n\t\treturn e1->left.sym == e2->left.sym && e1->right.sym == e2->right.sym;\n\tcase E_SYMBOL:\n\t\treturn e1->left.sym == e2->left.sym;\n\tcase E_NOT:\n\t\treturn expr_eq(e1->left.expr, e2->left.expr);\n\tcase E_AND:\n\tcase E_OR:\n\t\te1 = expr_copy(e1);\n\t\te2 = expr_copy(e2);\n\t\told_count = trans_count;\n\t\texpr_eliminate_eq(&e1, &e2);\n\t\tres = (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&\n\t\t       e1->left.sym == e2->left.sym);\n\t\texpr_free(e1);\n\t\texpr_free(e2);\n\t\ttrans_count = old_count;\n\t\treturn res;\n\tcase E_LIST:\n\tcase E_RANGE:\n\tcase E_NONE:\n\t\t ;\n\t}\n\n\tif (DEBUG_EXPR) {\n\t\texpr_fprint(e1, stdout);\n\t\tprintf(\" = \");\n\t\texpr_fprint(e2, stdout);\n\t\tprintf(\" ?\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct expr *expr_eliminate_yn(struct expr *e)\n{\n\tstruct expr *tmp;\n\n\tif (e) switch (e->type) {\n\tcase E_AND:\n\t\te->left.expr = expr_eliminate_yn(e->left.expr);\n\t\te->right.expr = expr_eliminate_yn(e->right.expr);\n\t\tif (e->left.expr->type == E_SYMBOL) {\n\t\t\tif (e->left.expr->left.sym == &symbol_no) {\n\t\t\t\texpr_free(e->left.expr);\n\t\t\t\texpr_free(e->right.expr);\n\t\t\t\te->type = E_SYMBOL;\n\t\t\t\te->left.sym = &symbol_no;\n\t\t\t\te->right.expr = NULL;\n\t\t\t\treturn e;\n\t\t\t} else if (e->left.expr->left.sym == &symbol_yes) {\n\t\t\t\tfree(e->left.expr);\n\t\t\t\ttmp = e->right.expr;\n\t\t\t\t*e = *(e->right.expr);\n\t\t\t\tfree(tmp);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\tif (e->right.expr->type == E_SYMBOL) {\n\t\t\tif (e->right.expr->left.sym == &symbol_no) {\n\t\t\t\texpr_free(e->left.expr);\n\t\t\t\texpr_free(e->right.expr);\n\t\t\t\te->type = E_SYMBOL;\n\t\t\t\te->left.sym = &symbol_no;\n\t\t\t\te->right.expr = NULL;\n\t\t\t\treturn e;\n\t\t\t} else if (e->right.expr->left.sym == &symbol_yes) {\n\t\t\t\tfree(e->right.expr);\n\t\t\t\ttmp = e->left.expr;\n\t\t\t\t*e = *(e->left.expr);\n\t\t\t\tfree(tmp);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase E_OR:\n\t\te->left.expr = expr_eliminate_yn(e->left.expr);\n\t\te->right.expr = expr_eliminate_yn(e->right.expr);\n\t\tif (e->left.expr->type == E_SYMBOL) {\n\t\t\tif (e->left.expr->left.sym == &symbol_no) {\n\t\t\t\tfree(e->left.expr);\n\t\t\t\ttmp = e->right.expr;\n\t\t\t\t*e = *(e->right.expr);\n\t\t\t\tfree(tmp);\n\t\t\t\treturn e;\n\t\t\t} else if (e->left.expr->left.sym == &symbol_yes) {\n\t\t\t\texpr_free(e->left.expr);\n\t\t\t\texpr_free(e->right.expr);\n\t\t\t\te->type = E_SYMBOL;\n\t\t\t\te->left.sym = &symbol_yes;\n\t\t\t\te->right.expr = NULL;\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\tif (e->right.expr->type == E_SYMBOL) {\n\t\t\tif (e->right.expr->left.sym == &symbol_no) {\n\t\t\t\tfree(e->right.expr);\n\t\t\t\ttmp = e->left.expr;\n\t\t\t\t*e = *(e->left.expr);\n\t\t\t\tfree(tmp);\n\t\t\t\treturn e;\n\t\t\t} else if (e->right.expr->left.sym == &symbol_yes) {\n\t\t\t\texpr_free(e->left.expr);\n\t\t\t\texpr_free(e->right.expr);\n\t\t\t\te->type = E_SYMBOL;\n\t\t\t\te->left.sym = &symbol_yes;\n\t\t\t\te->right.expr = NULL;\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n\treturn e;\n}\n\n \nstruct expr *expr_trans_bool(struct expr *e)\n{\n\tif (!e)\n\t\treturn NULL;\n\tswitch (e->type) {\n\tcase E_AND:\n\tcase E_OR:\n\tcase E_NOT:\n\t\te->left.expr = expr_trans_bool(e->left.expr);\n\t\te->right.expr = expr_trans_bool(e->right.expr);\n\t\tbreak;\n\tcase E_UNEQUAL:\n\t\t \n\t\tif (e->left.sym->type == S_TRISTATE) {\n\t\t\tif (e->right.sym == &symbol_no) {\n\t\t\t\te->type = E_SYMBOL;\n\t\t\t\te->right.sym = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n\treturn e;\n}\n\n \nstatic struct expr *expr_join_or(struct expr *e1, struct expr *e2)\n{\n\tstruct expr *tmp;\n\tstruct symbol *sym1, *sym2;\n\n\tif (expr_eq(e1, e2))\n\t\treturn expr_copy(e1);\n\tif (e1->type != E_EQUAL && e1->type != E_UNEQUAL && e1->type != E_SYMBOL && e1->type != E_NOT)\n\t\treturn NULL;\n\tif (e2->type != E_EQUAL && e2->type != E_UNEQUAL && e2->type != E_SYMBOL && e2->type != E_NOT)\n\t\treturn NULL;\n\tif (e1->type == E_NOT) {\n\t\ttmp = e1->left.expr;\n\t\tif (tmp->type != E_EQUAL && tmp->type != E_UNEQUAL && tmp->type != E_SYMBOL)\n\t\t\treturn NULL;\n\t\tsym1 = tmp->left.sym;\n\t} else\n\t\tsym1 = e1->left.sym;\n\tif (e2->type == E_NOT) {\n\t\tif (e2->left.expr->type != E_SYMBOL)\n\t\t\treturn NULL;\n\t\tsym2 = e2->left.expr->left.sym;\n\t} else\n\t\tsym2 = e2->left.sym;\n\tif (sym1 != sym2)\n\t\treturn NULL;\n\tif (sym1->type != S_BOOLEAN && sym1->type != S_TRISTATE)\n\t\treturn NULL;\n\tif (sym1->type == S_TRISTATE) {\n\t\tif (e1->type == E_EQUAL && e2->type == E_EQUAL &&\n\t\t    ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_mod) ||\n\t\t     (e1->right.sym == &symbol_mod && e2->right.sym == &symbol_yes))) {\n\t\t\t \n\t\t\treturn expr_alloc_comp(E_UNEQUAL, sym1, &symbol_no);\n\t\t}\n\t\tif (e1->type == E_EQUAL && e2->type == E_EQUAL &&\n\t\t    ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_no) ||\n\t\t     (e1->right.sym == &symbol_no && e2->right.sym == &symbol_yes))) {\n\t\t\t \n\t\t\treturn expr_alloc_comp(E_UNEQUAL, sym1, &symbol_mod);\n\t\t}\n\t\tif (e1->type == E_EQUAL && e2->type == E_EQUAL &&\n\t\t    ((e1->right.sym == &symbol_mod && e2->right.sym == &symbol_no) ||\n\t\t     (e1->right.sym == &symbol_no && e2->right.sym == &symbol_mod))) {\n\t\t\t \n\t\t\treturn expr_alloc_comp(E_UNEQUAL, sym1, &symbol_yes);\n\t\t}\n\t}\n\tif (sym1->type == S_BOOLEAN && sym1 == sym2) {\n\t\tif ((e1->type == E_NOT && e1->left.expr->type == E_SYMBOL && e2->type == E_SYMBOL) ||\n\t\t    (e2->type == E_NOT && e2->left.expr->type == E_SYMBOL && e1->type == E_SYMBOL))\n\t\t\treturn expr_alloc_symbol(&symbol_yes);\n\t}\n\n\tif (DEBUG_EXPR) {\n\t\tprintf(\"optimize (\");\n\t\texpr_fprint(e1, stdout);\n\t\tprintf(\") || (\");\n\t\texpr_fprint(e2, stdout);\n\t\tprintf(\")?\\n\");\n\t}\n\treturn NULL;\n}\n\nstatic struct expr *expr_join_and(struct expr *e1, struct expr *e2)\n{\n\tstruct expr *tmp;\n\tstruct symbol *sym1, *sym2;\n\n\tif (expr_eq(e1, e2))\n\t\treturn expr_copy(e1);\n\tif (e1->type != E_EQUAL && e1->type != E_UNEQUAL && e1->type != E_SYMBOL && e1->type != E_NOT)\n\t\treturn NULL;\n\tif (e2->type != E_EQUAL && e2->type != E_UNEQUAL && e2->type != E_SYMBOL && e2->type != E_NOT)\n\t\treturn NULL;\n\tif (e1->type == E_NOT) {\n\t\ttmp = e1->left.expr;\n\t\tif (tmp->type != E_EQUAL && tmp->type != E_UNEQUAL && tmp->type != E_SYMBOL)\n\t\t\treturn NULL;\n\t\tsym1 = tmp->left.sym;\n\t} else\n\t\tsym1 = e1->left.sym;\n\tif (e2->type == E_NOT) {\n\t\tif (e2->left.expr->type != E_SYMBOL)\n\t\t\treturn NULL;\n\t\tsym2 = e2->left.expr->left.sym;\n\t} else\n\t\tsym2 = e2->left.sym;\n\tif (sym1 != sym2)\n\t\treturn NULL;\n\tif (sym1->type != S_BOOLEAN && sym1->type != S_TRISTATE)\n\t\treturn NULL;\n\n\tif ((e1->type == E_SYMBOL && e2->type == E_EQUAL && e2->right.sym == &symbol_yes) ||\n\t    (e2->type == E_SYMBOL && e1->type == E_EQUAL && e1->right.sym == &symbol_yes))\n\t\t \n\t\treturn expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);\n\n\tif ((e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_no) ||\n\t    (e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_no))\n\t\t \n\t\treturn expr_alloc_symbol(sym1);\n\n\tif ((e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_mod) ||\n\t    (e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_mod))\n\t\t \n\t\treturn expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);\n\n\tif (sym1->type == S_TRISTATE) {\n\t\tif (e1->type == E_EQUAL && e2->type == E_UNEQUAL) {\n\t\t\t \n\t\t\tsym2 = e1->right.sym;\n\t\t\tif ((e2->right.sym->flags & SYMBOL_CONST) && (sym2->flags & SYMBOL_CONST))\n\t\t\t\treturn sym2 != e2->right.sym ? expr_alloc_comp(E_EQUAL, sym1, sym2)\n\t\t\t\t\t\t\t     : expr_alloc_symbol(&symbol_no);\n\t\t}\n\t\tif (e1->type == E_UNEQUAL && e2->type == E_EQUAL) {\n\t\t\t \n\t\t\tsym2 = e2->right.sym;\n\t\t\tif ((e1->right.sym->flags & SYMBOL_CONST) && (sym2->flags & SYMBOL_CONST))\n\t\t\t\treturn sym2 != e1->right.sym ? expr_alloc_comp(E_EQUAL, sym1, sym2)\n\t\t\t\t\t\t\t     : expr_alloc_symbol(&symbol_no);\n\t\t}\n\t\tif (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&\n\t\t\t   ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_no) ||\n\t\t\t    (e1->right.sym == &symbol_no && e2->right.sym == &symbol_yes)))\n\t\t\t \n\t\t\treturn expr_alloc_comp(E_EQUAL, sym1, &symbol_mod);\n\n\t\tif (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&\n\t\t\t   ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_mod) ||\n\t\t\t    (e1->right.sym == &symbol_mod && e2->right.sym == &symbol_yes)))\n\t\t\t \n\t\t\treturn expr_alloc_comp(E_EQUAL, sym1, &symbol_no);\n\n\t\tif (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&\n\t\t\t   ((e1->right.sym == &symbol_mod && e2->right.sym == &symbol_no) ||\n\t\t\t    (e1->right.sym == &symbol_no && e2->right.sym == &symbol_mod)))\n\t\t\t \n\t\t\treturn expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);\n\n\t\tif ((e1->type == E_SYMBOL && e2->type == E_EQUAL && e2->right.sym == &symbol_mod) ||\n\t\t    (e2->type == E_SYMBOL && e1->type == E_EQUAL && e1->right.sym == &symbol_mod) ||\n\t\t    (e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_yes) ||\n\t\t    (e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_yes))\n\t\t\treturn NULL;\n\t}\n\n\tif (DEBUG_EXPR) {\n\t\tprintf(\"optimize (\");\n\t\texpr_fprint(e1, stdout);\n\t\tprintf(\") && (\");\n\t\texpr_fprint(e2, stdout);\n\t\tprintf(\")?\\n\");\n\t}\n\treturn NULL;\n}\n\n \nstatic void expr_eliminate_dups1(enum expr_type type, struct expr **ep1, struct expr **ep2)\n{\n#define e1 (*ep1)\n#define e2 (*ep2)\n\tstruct expr *tmp;\n\n\t \n\n\tif (e1->type == type) {\n\t\texpr_eliminate_dups1(type, &e1->left.expr, &e2);\n\t\texpr_eliminate_dups1(type, &e1->right.expr, &e2);\n\t\treturn;\n\t}\n\tif (e2->type == type) {\n\t\texpr_eliminate_dups1(type, &e1, &e2->left.expr);\n\t\texpr_eliminate_dups1(type, &e1, &e2->right.expr);\n\t\treturn;\n\t}\n\n\t \n\n\tif (e1 == e2)\n\t\treturn;\n\n\tswitch (e1->type) {\n\tcase E_OR: case E_AND:\n\t\texpr_eliminate_dups1(e1->type, &e1, &e1);\n\tdefault:\n\t\t;\n\t}\n\n\tswitch (type) {\n\tcase E_OR:\n\t\ttmp = expr_join_or(e1, e2);\n\t\tif (tmp) {\n\t\t\texpr_free(e1); expr_free(e2);\n\t\t\te1 = expr_alloc_symbol(&symbol_no);\n\t\t\te2 = tmp;\n\t\t\ttrans_count++;\n\t\t}\n\t\tbreak;\n\tcase E_AND:\n\t\ttmp = expr_join_and(e1, e2);\n\t\tif (tmp) {\n\t\t\texpr_free(e1); expr_free(e2);\n\t\t\te1 = expr_alloc_symbol(&symbol_yes);\n\t\t\te2 = tmp;\n\t\t\ttrans_count++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n#undef e1\n#undef e2\n}\n\n \nstruct expr *expr_eliminate_dups(struct expr *e)\n{\n\tint oldcount;\n\tif (!e)\n\t\treturn e;\n\n\toldcount = trans_count;\n\twhile (1) {\n\t\ttrans_count = 0;\n\t\tswitch (e->type) {\n\t\tcase E_OR: case E_AND:\n\t\t\texpr_eliminate_dups1(e->type, &e, &e);\n\t\tdefault:\n\t\t\t;\n\t\t}\n\t\tif (!trans_count)\n\t\t\t \n\t\t\tbreak;\n\t\te = expr_eliminate_yn(e);\n\t}\n\ttrans_count = oldcount;\n\treturn e;\n}\n\n \nstruct expr *expr_transform(struct expr *e)\n{\n\tstruct expr *tmp;\n\n\tif (!e)\n\t\treturn NULL;\n\tswitch (e->type) {\n\tcase E_EQUAL:\n\tcase E_GEQ:\n\tcase E_GTH:\n\tcase E_LEQ:\n\tcase E_LTH:\n\tcase E_UNEQUAL:\n\tcase E_SYMBOL:\n\tcase E_LIST:\n\t\tbreak;\n\tdefault:\n\t\te->left.expr = expr_transform(e->left.expr);\n\t\te->right.expr = expr_transform(e->right.expr);\n\t}\n\n\tswitch (e->type) {\n\tcase E_EQUAL:\n\t\tif (e->left.sym->type != S_BOOLEAN)\n\t\t\tbreak;\n\t\tif (e->right.sym == &symbol_no) {\n\t\t\te->type = E_NOT;\n\t\t\te->left.expr = expr_alloc_symbol(e->left.sym);\n\t\t\te->right.sym = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (e->right.sym == &symbol_mod) {\n\t\t\tprintf(\"boolean symbol %s tested for 'm'? test forced to 'n'\\n\", e->left.sym->name);\n\t\t\te->type = E_SYMBOL;\n\t\t\te->left.sym = &symbol_no;\n\t\t\te->right.sym = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (e->right.sym == &symbol_yes) {\n\t\t\te->type = E_SYMBOL;\n\t\t\te->right.sym = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase E_UNEQUAL:\n\t\tif (e->left.sym->type != S_BOOLEAN)\n\t\t\tbreak;\n\t\tif (e->right.sym == &symbol_no) {\n\t\t\te->type = E_SYMBOL;\n\t\t\te->right.sym = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (e->right.sym == &symbol_mod) {\n\t\t\tprintf(\"boolean symbol %s tested for 'm'? test forced to 'y'\\n\", e->left.sym->name);\n\t\t\te->type = E_SYMBOL;\n\t\t\te->left.sym = &symbol_yes;\n\t\t\te->right.sym = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (e->right.sym == &symbol_yes) {\n\t\t\te->type = E_NOT;\n\t\t\te->left.expr = expr_alloc_symbol(e->left.sym);\n\t\t\te->right.sym = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase E_NOT:\n\t\tswitch (e->left.expr->type) {\n\t\tcase E_NOT:\n\t\t\t\n\t\t\ttmp = e->left.expr->left.expr;\n\t\t\tfree(e->left.expr);\n\t\t\tfree(e);\n\t\t\te = tmp;\n\t\t\te = expr_transform(e);\n\t\t\tbreak;\n\t\tcase E_EQUAL:\n\t\tcase E_UNEQUAL:\n\t\t\t\n\t\t\ttmp = e->left.expr;\n\t\t\tfree(e);\n\t\t\te = tmp;\n\t\t\te->type = e->type == E_EQUAL ? E_UNEQUAL : E_EQUAL;\n\t\t\tbreak;\n\t\tcase E_LEQ:\n\t\tcase E_GEQ:\n\t\t\t\n\t\t\ttmp = e->left.expr;\n\t\t\tfree(e);\n\t\t\te = tmp;\n\t\t\te->type = e->type == E_LEQ ? E_GTH : E_LTH;\n\t\t\tbreak;\n\t\tcase E_LTH:\n\t\tcase E_GTH:\n\t\t\t\n\t\t\ttmp = e->left.expr;\n\t\t\tfree(e);\n\t\t\te = tmp;\n\t\t\te->type = e->type == E_LTH ? E_GEQ : E_LEQ;\n\t\t\tbreak;\n\t\tcase E_OR:\n\t\t\t\n\t\t\ttmp = e->left.expr;\n\t\t\te->type = E_AND;\n\t\t\te->right.expr = expr_alloc_one(E_NOT, tmp->right.expr);\n\t\t\ttmp->type = E_NOT;\n\t\t\ttmp->right.expr = NULL;\n\t\t\te = expr_transform(e);\n\t\t\tbreak;\n\t\tcase E_AND:\n\t\t\t\n\t\t\ttmp = e->left.expr;\n\t\t\te->type = E_OR;\n\t\t\te->right.expr = expr_alloc_one(E_NOT, tmp->right.expr);\n\t\t\ttmp->type = E_NOT;\n\t\t\ttmp->right.expr = NULL;\n\t\t\te = expr_transform(e);\n\t\t\tbreak;\n\t\tcase E_SYMBOL:\n\t\t\tif (e->left.expr->left.sym == &symbol_yes) {\n\t\t\t\t\n\t\t\t\ttmp = e->left.expr;\n\t\t\t\tfree(e);\n\t\t\t\te = tmp;\n\t\t\t\te->type = E_SYMBOL;\n\t\t\t\te->left.sym = &symbol_no;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e->left.expr->left.sym == &symbol_mod) {\n\t\t\t\t\n\t\t\t\ttmp = e->left.expr;\n\t\t\t\tfree(e);\n\t\t\t\te = tmp;\n\t\t\t\te->type = E_SYMBOL;\n\t\t\t\te->left.sym = &symbol_mod;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e->left.expr->left.sym == &symbol_no) {\n\t\t\t\t\n\t\t\t\ttmp = e->left.expr;\n\t\t\t\tfree(e);\n\t\t\t\te = tmp;\n\t\t\t\te->type = E_SYMBOL;\n\t\t\t\te->left.sym = &symbol_yes;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n\treturn e;\n}\n\nint expr_contains_symbol(struct expr *dep, struct symbol *sym)\n{\n\tif (!dep)\n\t\treturn 0;\n\n\tswitch (dep->type) {\n\tcase E_AND:\n\tcase E_OR:\n\t\treturn expr_contains_symbol(dep->left.expr, sym) ||\n\t\t       expr_contains_symbol(dep->right.expr, sym);\n\tcase E_SYMBOL:\n\t\treturn dep->left.sym == sym;\n\tcase E_EQUAL:\n\tcase E_GEQ:\n\tcase E_GTH:\n\tcase E_LEQ:\n\tcase E_LTH:\n\tcase E_UNEQUAL:\n\t\treturn dep->left.sym == sym ||\n\t\t       dep->right.sym == sym;\n\tcase E_NOT:\n\t\treturn expr_contains_symbol(dep->left.expr, sym);\n\tdefault:\n\t\t;\n\t}\n\treturn 0;\n}\n\nbool expr_depends_symbol(struct expr *dep, struct symbol *sym)\n{\n\tif (!dep)\n\t\treturn false;\n\n\tswitch (dep->type) {\n\tcase E_AND:\n\t\treturn expr_depends_symbol(dep->left.expr, sym) ||\n\t\t       expr_depends_symbol(dep->right.expr, sym);\n\tcase E_SYMBOL:\n\t\treturn dep->left.sym == sym;\n\tcase E_EQUAL:\n\t\tif (dep->left.sym == sym) {\n\t\t\tif (dep->right.sym == &symbol_yes || dep->right.sym == &symbol_mod)\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase E_UNEQUAL:\n\t\tif (dep->left.sym == sym) {\n\t\t\tif (dep->right.sym == &symbol_no)\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n \treturn false;\n}\n\n \nstruct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symbol *sym)\n{\n\tstruct expr *e1, *e2;\n\n\tif (!e) {\n\t\te = expr_alloc_symbol(sym);\n\t\tif (type == E_UNEQUAL)\n\t\t\te = expr_alloc_one(E_NOT, e);\n\t\treturn e;\n\t}\n\tswitch (e->type) {\n\tcase E_AND:\n\t\te1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);\n\t\te2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);\n\t\tif (sym == &symbol_yes)\n\t\t\te = expr_alloc_two(E_AND, e1, e2);\n\t\tif (sym == &symbol_no)\n\t\t\te = expr_alloc_two(E_OR, e1, e2);\n\t\tif (type == E_UNEQUAL)\n\t\t\te = expr_alloc_one(E_NOT, e);\n\t\treturn e;\n\tcase E_OR:\n\t\te1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);\n\t\te2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);\n\t\tif (sym == &symbol_yes)\n\t\t\te = expr_alloc_two(E_OR, e1, e2);\n\t\tif (sym == &symbol_no)\n\t\t\te = expr_alloc_two(E_AND, e1, e2);\n\t\tif (type == E_UNEQUAL)\n\t\t\te = expr_alloc_one(E_NOT, e);\n\t\treturn e;\n\tcase E_NOT:\n\t\treturn expr_trans_compare(e->left.expr, type == E_EQUAL ? E_UNEQUAL : E_EQUAL, sym);\n\tcase E_UNEQUAL:\n\tcase E_LTH:\n\tcase E_LEQ:\n\tcase E_GTH:\n\tcase E_GEQ:\n\tcase E_EQUAL:\n\t\tif (type == E_EQUAL) {\n\t\t\tif (sym == &symbol_yes)\n\t\t\t\treturn expr_copy(e);\n\t\t\tif (sym == &symbol_mod)\n\t\t\t\treturn expr_alloc_symbol(&symbol_no);\n\t\t\tif (sym == &symbol_no)\n\t\t\t\treturn expr_alloc_one(E_NOT, expr_copy(e));\n\t\t} else {\n\t\t\tif (sym == &symbol_yes)\n\t\t\t\treturn expr_alloc_one(E_NOT, expr_copy(e));\n\t\t\tif (sym == &symbol_mod)\n\t\t\t\treturn expr_alloc_symbol(&symbol_yes);\n\t\t\tif (sym == &symbol_no)\n\t\t\t\treturn expr_copy(e);\n\t\t}\n\t\tbreak;\n\tcase E_SYMBOL:\n\t\treturn expr_alloc_comp(type, e->left.sym, sym);\n\tcase E_LIST:\n\tcase E_RANGE:\n\tcase E_NONE:\n\t\t ;\n\t}\n\treturn NULL;\n}\n\nenum string_value_kind {\n\tk_string,\n\tk_signed,\n\tk_unsigned,\n};\n\nunion string_value {\n\tunsigned long long u;\n\tsigned long long s;\n};\n\nstatic enum string_value_kind expr_parse_string(const char *str,\n\t\t\t\t\t\tenum symbol_type type,\n\t\t\t\t\t\tunion string_value *val)\n{\n\tchar *tail;\n\tenum string_value_kind kind;\n\n\terrno = 0;\n\tswitch (type) {\n\tcase S_BOOLEAN:\n\tcase S_TRISTATE:\n\t\tval->s = !strcmp(str, \"n\") ? 0 :\n\t\t\t !strcmp(str, \"m\") ? 1 :\n\t\t\t !strcmp(str, \"y\") ? 2 : -1;\n\t\treturn k_signed;\n\tcase S_INT:\n\t\tval->s = strtoll(str, &tail, 10);\n\t\tkind = k_signed;\n\t\tbreak;\n\tcase S_HEX:\n\t\tval->u = strtoull(str, &tail, 16);\n\t\tkind = k_unsigned;\n\t\tbreak;\n\tdefault:\n\t\tval->s = strtoll(str, &tail, 0);\n\t\tkind = k_signed;\n\t\tbreak;\n\t}\n\treturn !errno && !*tail && tail > str && isxdigit(tail[-1])\n\t       ? kind : k_string;\n}\n\ntristate expr_calc_value(struct expr *e)\n{\n\ttristate val1, val2;\n\tconst char *str1, *str2;\n\tenum string_value_kind k1 = k_string, k2 = k_string;\n\tunion string_value lval = {}, rval = {};\n\tint res;\n\n\tif (!e)\n\t\treturn yes;\n\n\tswitch (e->type) {\n\tcase E_SYMBOL:\n\t\tsym_calc_value(e->left.sym);\n\t\treturn e->left.sym->curr.tri;\n\tcase E_AND:\n\t\tval1 = expr_calc_value(e->left.expr);\n\t\tval2 = expr_calc_value(e->right.expr);\n\t\treturn EXPR_AND(val1, val2);\n\tcase E_OR:\n\t\tval1 = expr_calc_value(e->left.expr);\n\t\tval2 = expr_calc_value(e->right.expr);\n\t\treturn EXPR_OR(val1, val2);\n\tcase E_NOT:\n\t\tval1 = expr_calc_value(e->left.expr);\n\t\treturn EXPR_NOT(val1);\n\tcase E_EQUAL:\n\tcase E_GEQ:\n\tcase E_GTH:\n\tcase E_LEQ:\n\tcase E_LTH:\n\tcase E_UNEQUAL:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"expr_calc_value: %d?\\n\", e->type);\n\t\treturn no;\n\t}\n\n\tsym_calc_value(e->left.sym);\n\tsym_calc_value(e->right.sym);\n\tstr1 = sym_get_string_value(e->left.sym);\n\tstr2 = sym_get_string_value(e->right.sym);\n\n\tif (e->left.sym->type != S_STRING || e->right.sym->type != S_STRING) {\n\t\tk1 = expr_parse_string(str1, e->left.sym->type, &lval);\n\t\tk2 = expr_parse_string(str2, e->right.sym->type, &rval);\n\t}\n\n\tif (k1 == k_string || k2 == k_string)\n\t\tres = strcmp(str1, str2);\n\telse if (k1 == k_unsigned || k2 == k_unsigned)\n\t\tres = (lval.u > rval.u) - (lval.u < rval.u);\n\telse  \n\t\tres = (lval.s > rval.s) - (lval.s < rval.s);\n\n\tswitch(e->type) {\n\tcase E_EQUAL:\n\t\treturn res ? no : yes;\n\tcase E_GEQ:\n\t\treturn res >= 0 ? yes : no;\n\tcase E_GTH:\n\t\treturn res > 0 ? yes : no;\n\tcase E_LEQ:\n\t\treturn res <= 0 ? yes : no;\n\tcase E_LTH:\n\t\treturn res < 0 ? yes : no;\n\tcase E_UNEQUAL:\n\t\treturn res ? yes : no;\n\tdefault:\n\t\tprintf(\"expr_calc_value: relation %d?\\n\", e->type);\n\t\treturn no;\n\t}\n}\n\nstatic int expr_compare_type(enum expr_type t1, enum expr_type t2)\n{\n\tif (t1 == t2)\n\t\treturn 0;\n\tswitch (t1) {\n\tcase E_LEQ:\n\tcase E_LTH:\n\tcase E_GEQ:\n\tcase E_GTH:\n\t\tif (t2 == E_EQUAL || t2 == E_UNEQUAL)\n\t\t\treturn 1;\n\tcase E_EQUAL:\n\tcase E_UNEQUAL:\n\t\tif (t2 == E_NOT)\n\t\t\treturn 1;\n\tcase E_NOT:\n\t\tif (t2 == E_AND)\n\t\t\treturn 1;\n\tcase E_AND:\n\t\tif (t2 == E_OR)\n\t\t\treturn 1;\n\tcase E_OR:\n\t\tif (t2 == E_LIST)\n\t\t\treturn 1;\n\tcase E_LIST:\n\t\tif (t2 == 0)\n\t\t\treturn 1;\n\tdefault:\n\t\treturn -1;\n\t}\n\tprintf(\"[%dgt%d?]\", t1, t2);\n\treturn 0;\n}\n\nvoid expr_print(struct expr *e,\n\t\tvoid (*fn)(void *, struct symbol *, const char *),\n\t\tvoid *data, int prevtoken)\n{\n\tif (!e) {\n\t\tfn(data, NULL, \"y\");\n\t\treturn;\n\t}\n\n\tif (expr_compare_type(prevtoken, e->type) > 0)\n\t\tfn(data, NULL, \"(\");\n\tswitch (e->type) {\n\tcase E_SYMBOL:\n\t\tif (e->left.sym->name)\n\t\t\tfn(data, e->left.sym, e->left.sym->name);\n\t\telse\n\t\t\tfn(data, NULL, \"<choice>\");\n\t\tbreak;\n\tcase E_NOT:\n\t\tfn(data, NULL, \"!\");\n\t\texpr_print(e->left.expr, fn, data, E_NOT);\n\t\tbreak;\n\tcase E_EQUAL:\n\t\tif (e->left.sym->name)\n\t\t\tfn(data, e->left.sym, e->left.sym->name);\n\t\telse\n\t\t\tfn(data, NULL, \"<choice>\");\n\t\tfn(data, NULL, \"=\");\n\t\tfn(data, e->right.sym, e->right.sym->name);\n\t\tbreak;\n\tcase E_LEQ:\n\tcase E_LTH:\n\t\tif (e->left.sym->name)\n\t\t\tfn(data, e->left.sym, e->left.sym->name);\n\t\telse\n\t\t\tfn(data, NULL, \"<choice>\");\n\t\tfn(data, NULL, e->type == E_LEQ ? \"<=\" : \"<\");\n\t\tfn(data, e->right.sym, e->right.sym->name);\n\t\tbreak;\n\tcase E_GEQ:\n\tcase E_GTH:\n\t\tif (e->left.sym->name)\n\t\t\tfn(data, e->left.sym, e->left.sym->name);\n\t\telse\n\t\t\tfn(data, NULL, \"<choice>\");\n\t\tfn(data, NULL, e->type == E_GEQ ? \">=\" : \">\");\n\t\tfn(data, e->right.sym, e->right.sym->name);\n\t\tbreak;\n\tcase E_UNEQUAL:\n\t\tif (e->left.sym->name)\n\t\t\tfn(data, e->left.sym, e->left.sym->name);\n\t\telse\n\t\t\tfn(data, NULL, \"<choice>\");\n\t\tfn(data, NULL, \"!=\");\n\t\tfn(data, e->right.sym, e->right.sym->name);\n\t\tbreak;\n\tcase E_OR:\n\t\texpr_print(e->left.expr, fn, data, E_OR);\n\t\tfn(data, NULL, \" || \");\n\t\texpr_print(e->right.expr, fn, data, E_OR);\n\t\tbreak;\n\tcase E_AND:\n\t\texpr_print(e->left.expr, fn, data, E_AND);\n\t\tfn(data, NULL, \" && \");\n\t\texpr_print(e->right.expr, fn, data, E_AND);\n\t\tbreak;\n\tcase E_LIST:\n\t\tfn(data, e->right.sym, e->right.sym->name);\n\t\tif (e->left.expr) {\n\t\t\tfn(data, NULL, \" ^ \");\n\t\t\texpr_print(e->left.expr, fn, data, E_LIST);\n\t\t}\n\t\tbreak;\n\tcase E_RANGE:\n\t\tfn(data, NULL, \"[\");\n\t\tfn(data, e->left.sym, e->left.sym->name);\n\t\tfn(data, NULL, \" \");\n\t\tfn(data, e->right.sym, e->right.sym->name);\n\t\tfn(data, NULL, \"]\");\n\t\tbreak;\n\tdefault:\n\t  {\n\t\tchar buf[32];\n\t\tsprintf(buf, \"<unknown type %d>\", e->type);\n\t\tfn(data, NULL, buf);\n\t\tbreak;\n\t  }\n\t}\n\tif (expr_compare_type(prevtoken, e->type) > 0)\n\t\tfn(data, NULL, \")\");\n}\n\nstatic void expr_print_file_helper(void *data, struct symbol *sym, const char *str)\n{\n\txfwrite(str, strlen(str), 1, data);\n}\n\nvoid expr_fprint(struct expr *e, FILE *out)\n{\n\texpr_print(e, expr_print_file_helper, out, E_NONE);\n}\n\nstatic void expr_print_gstr_helper(void *data, struct symbol *sym, const char *str)\n{\n\tstruct gstr *gs = (struct gstr*)data;\n\tconst char *sym_str = NULL;\n\n\tif (sym)\n\t\tsym_str = sym_get_string_value(sym);\n\n\tif (gs->max_width) {\n\t\tunsigned extra_length = strlen(str);\n\t\tconst char *last_cr = strrchr(gs->s, '\\n');\n\t\tunsigned last_line_length;\n\n\t\tif (sym_str)\n\t\t\textra_length += 4 + strlen(sym_str);\n\n\t\tif (!last_cr)\n\t\t\tlast_cr = gs->s;\n\n\t\tlast_line_length = strlen(gs->s) - (last_cr - gs->s);\n\n\t\tif ((last_line_length + extra_length) > gs->max_width)\n\t\t\tstr_append(gs, \"\\\\\\n\");\n\t}\n\n\tstr_append(gs, str);\n\tif (sym && sym->type != S_UNKNOWN)\n\t\tstr_printf(gs, \" [=%s]\", sym_str);\n}\n\nvoid expr_gstr_print(struct expr *e, struct gstr *gs)\n{\n\texpr_print(e, expr_print_gstr_helper, gs, E_NONE);\n}\n\n \nstatic void expr_print_revdep(struct expr *e,\n\t\t\t      void (*fn)(void *, struct symbol *, const char *),\n\t\t\t      void *data, tristate pr_type, const char **title)\n{\n\tif (e->type == E_OR) {\n\t\texpr_print_revdep(e->left.expr, fn, data, pr_type, title);\n\t\texpr_print_revdep(e->right.expr, fn, data, pr_type, title);\n\t} else if (expr_calc_value(e) == pr_type) {\n\t\tif (*title) {\n\t\t\tfn(data, NULL, *title);\n\t\t\t*title = NULL;\n\t\t}\n\n\t\tfn(data, NULL, \"  - \");\n\t\texpr_print(e, fn, data, E_NONE);\n\t\tfn(data, NULL, \"\\n\");\n\t}\n}\n\nvoid expr_gstr_print_revdep(struct expr *e, struct gstr *gs,\n\t\t\t    tristate pr_type, const char *title)\n{\n\texpr_print_revdep(e, expr_print_gstr_helper, gs, pr_type, &title);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}