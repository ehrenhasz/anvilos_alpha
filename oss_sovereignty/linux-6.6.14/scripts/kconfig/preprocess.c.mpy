{
  "module_name": "preprocess.c",
  "hash_id": "2ea2b105dadeeca1a205ed90ba87fab618ca601d81a0c1834ca9fde430480173",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/preprocess.c",
  "human_readable_source": "\n\n\n\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"list.h\"\n#include \"lkc.h\"\n\n#define ARRAY_SIZE(arr)\t\t(sizeof(arr) / sizeof((arr)[0]))\n\nstatic char *expand_string_with_args(const char *in, int argc, char *argv[]);\nstatic char *expand_string(const char *in);\n\nstatic void __attribute__((noreturn)) pperror(const char *format, ...)\n{\n\tva_list ap;\n\n\tfprintf(stderr, \"%s:%d: \", current_file->name, yylineno);\n\tva_start(ap, format);\n\tvfprintf(stderr, format, ap);\n\tva_end(ap);\n\tfprintf(stderr, \"\\n\");\n\n\texit(1);\n}\n\n \nstatic LIST_HEAD(env_list);\n\nstruct env {\n\tchar *name;\n\tchar *value;\n\tstruct list_head node;\n};\n\nstatic void env_add(const char *name, const char *value)\n{\n\tstruct env *e;\n\n\te = xmalloc(sizeof(*e));\n\te->name = xstrdup(name);\n\te->value = xstrdup(value);\n\n\tlist_add_tail(&e->node, &env_list);\n}\n\nstatic void env_del(struct env *e)\n{\n\tlist_del(&e->node);\n\tfree(e->name);\n\tfree(e->value);\n\tfree(e);\n}\n\n \nstatic char *env_expand(const char *name)\n{\n\tstruct env *e;\n\tconst char *value;\n\n\tif (!*name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(e, &env_list, node) {\n\t\tif (!strcmp(name, e->name))\n\t\t\treturn xstrdup(e->value);\n\t}\n\n\tvalue = getenv(name);\n\tif (!value)\n\t\treturn NULL;\n\n\t \n\tenv_add(name, value);\n\n\treturn xstrdup(value);\n}\n\nvoid env_write_dep(FILE *f, const char *autoconfig_name)\n{\n\tstruct env *e, *tmp;\n\n\tlist_for_each_entry_safe(e, tmp, &env_list, node) {\n\t\tfprintf(f, \"ifneq \\\"$(%s)\\\" \\\"%s\\\"\\n\", e->name, e->value);\n\t\tfprintf(f, \"%s: FORCE\\n\", autoconfig_name);\n\t\tfprintf(f, \"endif\\n\");\n\t\tenv_del(e);\n\t}\n}\n\n \nstruct function {\n\tconst char *name;\n\tunsigned int min_args;\n\tunsigned int max_args;\n\tchar *(*func)(int argc, char *argv[]);\n};\n\nstatic char *do_error_if(int argc, char *argv[])\n{\n\tif (!strcmp(argv[0], \"y\"))\n\t\tpperror(\"%s\", argv[1]);\n\n\treturn xstrdup(\"\");\n}\n\nstatic char *do_filename(int argc, char *argv[])\n{\n\treturn xstrdup(current_file->name);\n}\n\nstatic char *do_info(int argc, char *argv[])\n{\n\tprintf(\"%s\\n\", argv[0]);\n\n\treturn xstrdup(\"\");\n}\n\nstatic char *do_lineno(int argc, char *argv[])\n{\n\tchar buf[16];\n\n\tsprintf(buf, \"%d\", yylineno);\n\n\treturn xstrdup(buf);\n}\n\nstatic char *do_shell(int argc, char *argv[])\n{\n\tFILE *p;\n\tchar buf[4096];\n\tchar *cmd;\n\tsize_t nread;\n\tint i;\n\n\tcmd = argv[0];\n\n\tp = popen(cmd, \"r\");\n\tif (!p) {\n\t\tperror(cmd);\n\t\texit(1);\n\t}\n\n\tnread = fread(buf, 1, sizeof(buf), p);\n\tif (nread == sizeof(buf))\n\t\tnread--;\n\n\t \n\twhile (nread > 0 && buf[nread - 1] == '\\n')\n\t\tnread--;\n\n\tbuf[nread] = 0;\n\n\t \n\tfor (i = 0; i < nread; i++) {\n\t\tif (buf[i] == '\\n')\n\t\t\tbuf[i] = ' ';\n\t}\n\n\tif (pclose(p) == -1) {\n\t\tperror(cmd);\n\t\texit(1);\n\t}\n\n\treturn xstrdup(buf);\n}\n\nstatic char *do_warning_if(int argc, char *argv[])\n{\n\tif (!strcmp(argv[0], \"y\"))\n\t\tfprintf(stderr, \"%s:%d: %s\\n\",\n\t\t\tcurrent_file->name, yylineno, argv[1]);\n\n\treturn xstrdup(\"\");\n}\n\nstatic const struct function function_table[] = {\n\t \n\t{ \"error-if\",\t2,\t2,\tdo_error_if },\n\t{ \"filename\",\t0,\t0,\tdo_filename },\n\t{ \"info\",\t1,\t1,\tdo_info },\n\t{ \"lineno\",\t0,\t0,\tdo_lineno },\n\t{ \"shell\",\t1,\t1,\tdo_shell },\n\t{ \"warning-if\",\t2,\t2,\tdo_warning_if },\n};\n\n#define FUNCTION_MAX_ARGS\t\t16\n\nstatic char *function_expand(const char *name, int argc, char *argv[])\n{\n\tconst struct function *f;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(function_table); i++) {\n\t\tf = &function_table[i];\n\t\tif (strcmp(f->name, name))\n\t\t\tcontinue;\n\n\t\tif (argc < f->min_args)\n\t\t\tpperror(\"too few function arguments passed to '%s'\",\n\t\t\t\tname);\n\n\t\tif (argc > f->max_args)\n\t\t\tpperror(\"too many function arguments passed to '%s'\",\n\t\t\t\tname);\n\n\t\treturn f->func(argc, argv);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic LIST_HEAD(variable_list);\n\nstruct variable {\n\tchar *name;\n\tchar *value;\n\tenum variable_flavor flavor;\n\tint exp_count;\n\tstruct list_head node;\n};\n\nstatic struct variable *variable_lookup(const char *name)\n{\n\tstruct variable *v;\n\n\tlist_for_each_entry(v, &variable_list, node) {\n\t\tif (!strcmp(name, v->name))\n\t\t\treturn v;\n\t}\n\n\treturn NULL;\n}\n\nstatic char *variable_expand(const char *name, int argc, char *argv[])\n{\n\tstruct variable *v;\n\tchar *res;\n\n\tv = variable_lookup(name);\n\tif (!v)\n\t\treturn NULL;\n\n\tif (argc == 0 && v->exp_count)\n\t\tpperror(\"Recursive variable '%s' references itself (eventually)\",\n\t\t\tname);\n\n\tif (v->exp_count > 1000)\n\t\tpperror(\"Too deep recursive expansion\");\n\n\tv->exp_count++;\n\n\tif (v->flavor == VAR_RECURSIVE)\n\t\tres = expand_string_with_args(v->value, argc, argv);\n\telse\n\t\tres = xstrdup(v->value);\n\n\tv->exp_count--;\n\n\treturn res;\n}\n\nvoid variable_add(const char *name, const char *value,\n\t\t  enum variable_flavor flavor)\n{\n\tstruct variable *v;\n\tchar *new_value;\n\tbool append = false;\n\n\tv = variable_lookup(name);\n\tif (v) {\n\t\t \n\t\tif (flavor == VAR_APPEND) {\n\t\t\tflavor = v->flavor;\n\t\t\tappend = true;\n\t\t} else {\n\t\t\tfree(v->value);\n\t\t}\n\t} else {\n\t\t \n\t\tif (flavor == VAR_APPEND)\n\t\t\tflavor = VAR_RECURSIVE;\n\n\t\tv = xmalloc(sizeof(*v));\n\t\tv->name = xstrdup(name);\n\t\tv->exp_count = 0;\n\t\tlist_add_tail(&v->node, &variable_list);\n\t}\n\n\tv->flavor = flavor;\n\n\tif (flavor == VAR_SIMPLE)\n\t\tnew_value = expand_string(value);\n\telse\n\t\tnew_value = xstrdup(value);\n\n\tif (append) {\n\t\tv->value = xrealloc(v->value,\n\t\t\t\t    strlen(v->value) + strlen(new_value) + 2);\n\t\tstrcat(v->value, \" \");\n\t\tstrcat(v->value, new_value);\n\t\tfree(new_value);\n\t} else {\n\t\tv->value = new_value;\n\t}\n}\n\nstatic void variable_del(struct variable *v)\n{\n\tlist_del(&v->node);\n\tfree(v->name);\n\tfree(v->value);\n\tfree(v);\n}\n\nvoid variable_all_del(void)\n{\n\tstruct variable *v, *tmp;\n\n\tlist_for_each_entry_safe(v, tmp, &variable_list, node)\n\t\tvariable_del(v);\n}\n\n \nstatic char *eval_clause(const char *str, size_t len, int argc, char *argv[])\n{\n\tchar *tmp, *name, *res, *endptr, *prev, *p;\n\tint new_argc = 0;\n\tchar *new_argv[FUNCTION_MAX_ARGS];\n\tint nest = 0;\n\tint i;\n\tunsigned long n;\n\n\ttmp = xstrndup(str, len);\n\n\t \n\tn = strtoul(tmp, &endptr, 10);\n\tif (!*endptr && n > 0 && n <= argc) {\n\t\tres = xstrdup(argv[n - 1]);\n\t\tgoto free_tmp;\n\t}\n\n\tprev = p = tmp;\n\n\t \n\twhile (*p) {\n\t\tif (nest == 0 && *p == ',') {\n\t\t\t*p = 0;\n\t\t\tif (new_argc >= FUNCTION_MAX_ARGS)\n\t\t\t\tpperror(\"too many function arguments\");\n\t\t\tnew_argv[new_argc++] = prev;\n\t\t\tprev = p + 1;\n\t\t} else if (*p == '(') {\n\t\t\tnest++;\n\t\t} else if (*p == ')') {\n\t\t\tnest--;\n\t\t}\n\n\t\tp++;\n\t}\n\n\tif (new_argc >= FUNCTION_MAX_ARGS)\n\t\tpperror(\"too many function arguments\");\n\tnew_argv[new_argc++] = prev;\n\n\t \n\tname = expand_string_with_args(new_argv[0], argc, argv);\n\tnew_argc--;\n\tfor (i = 0; i < new_argc; i++)\n\t\tnew_argv[i] = expand_string_with_args(new_argv[i + 1],\n\t\t\t\t\t\t      argc, argv);\n\n\t \n\tres = variable_expand(name, new_argc, new_argv);\n\tif (res)\n\t\tgoto free;\n\n\t \n\tres = function_expand(name, new_argc, new_argv);\n\tif (res)\n\t\tgoto free;\n\n\t \n\tif (new_argc == 0) {\n\t\tres = env_expand(name);\n\t\tif (res)\n\t\t\tgoto free;\n\t}\n\n\tres = xstrdup(\"\");\nfree:\n\tfor (i = 0; i < new_argc; i++)\n\t\tfree(new_argv[i]);\n\tfree(name);\nfree_tmp:\n\tfree(tmp);\n\n\treturn res;\n}\n\n \nstatic char *expand_dollar_with_args(const char **str, int argc, char *argv[])\n{\n\tconst char *p = *str;\n\tconst char *q;\n\tint nest = 0;\n\n\t \n\tif (*p != '(') {\n\t\t*str = p;\n\t\treturn xstrdup(\"$\");\n\t}\n\n\tp++;\n\tq = p;\n\twhile (*q) {\n\t\tif (*q == '(') {\n\t\t\tnest++;\n\t\t} else if (*q == ')') {\n\t\t\tif (nest-- == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tq++;\n\t}\n\n\tif (!*q)\n\t\tpperror(\"unterminated reference to '%s': missing ')'\", p);\n\n\t \n\t*str = q + 1;\n\n\treturn eval_clause(p, q - p, argc, argv);\n}\n\nchar *expand_dollar(const char **str)\n{\n\treturn expand_dollar_with_args(str, 0, NULL);\n}\n\nstatic char *__expand_string(const char **str, bool (*is_end)(char c),\n\t\t\t     int argc, char *argv[])\n{\n\tconst char *in, *p;\n\tchar *expansion, *out;\n\tsize_t in_len, out_len;\n\n\tout = xmalloc(1);\n\t*out = 0;\n\tout_len = 1;\n\n\tp = in = *str;\n\n\twhile (1) {\n\t\tif (*p == '$') {\n\t\t\tin_len = p - in;\n\t\t\tp++;\n\t\t\texpansion = expand_dollar_with_args(&p, argc, argv);\n\t\t\tout_len += in_len + strlen(expansion);\n\t\t\tout = xrealloc(out, out_len);\n\t\t\tstrncat(out, in, in_len);\n\t\t\tstrcat(out, expansion);\n\t\t\tfree(expansion);\n\t\t\tin = p;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_end(*p))\n\t\t\tbreak;\n\n\t\tp++;\n\t}\n\n\tin_len = p - in;\n\tout_len += in_len;\n\tout = xrealloc(out, out_len);\n\tstrncat(out, in, in_len);\n\n\t \n\t*str = p;\n\n\treturn out;\n}\n\nstatic bool is_end_of_str(char c)\n{\n\treturn !c;\n}\n\n \nstatic char *expand_string_with_args(const char *in, int argc, char *argv[])\n{\n\treturn __expand_string(&in, is_end_of_str, argc, argv);\n}\n\nstatic char *expand_string(const char *in)\n{\n\treturn expand_string_with_args(in, 0, NULL);\n}\n\nstatic bool is_end_of_token(char c)\n{\n\treturn !(isalnum(c) || c == '_' || c == '-');\n}\n\n \nchar *expand_one_token(const char **str)\n{\n\treturn __expand_string(str, is_end_of_token, 0, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}