{
  "module_name": "nconf.c",
  "hash_id": "c4d673fba424e2820ec891a2f6744fc00571e3dec5eb93c74379440f59001059",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kconfig/nconf.c",
  "human_readable_source": "\n \n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <string.h>\n#include <strings.h>\n#include <stdlib.h>\n\n#include \"lkc.h\"\n#include \"nconf.h\"\n#include <ctype.h>\n\nstatic const char nconf_global_help[] =\n\"Help windows\\n\"\n\"------------\\n\"\n\"o  Global help:  Unless in a data entry window, pressing <F1> will give \\n\"\n\"   you the global help window, which you are just reading.\\n\"\n\"\\n\"\n\"o  A short version of the global help is available by pressing <F3>.\\n\"\n\"\\n\"\n\"o  Local help:  To get help related to the current menu entry, use any\\n\"\n\"   of <?> <h>, or if in a data entry window then press <F1>.\\n\"\n\"\\n\"\n\"\\n\"\n\"Menu entries\\n\"\n\"------------\\n\"\n\"This interface lets you select features and parameters for the kernel\\n\"\n\"build.  Kernel features can either be built-in, modularized, or removed.\\n\"\n\"Parameters must be entered as text or decimal or hexadecimal numbers.\\n\"\n\"\\n\"\n\"Menu entries beginning with following braces represent features that\\n\"\n\"  [ ]  can be built in or removed\\n\"\n\"  < >  can be built in, modularized or removed\\n\"\n\"  { }  can be built in or modularized, are selected by another feature\\n\"\n\"  - -  are selected by another feature\\n\"\n\"  XXX  cannot be selected.  Symbol Info <F2> tells you why.\\n\"\n\"*, M or whitespace inside braces means to build in, build as a module\\n\"\n\"or to exclude the feature respectively.\\n\"\n\"\\n\"\n\"To change any of these features, highlight it with the movement keys\\n\"\n\"listed below and press <y> to build it in, <m> to make it a module or\\n\"\n\"<n> to remove it.  You may press the <Space> key to cycle through the\\n\"\n\"available options.\\n\"\n\"\\n\"\n\"A trailing \\\"--->\\\" designates a submenu, a trailing \\\"----\\\" an\\n\"\n\"empty submenu.\\n\"\n\"\\n\"\n\"Menu navigation keys\\n\"\n\"----------------------------------------------------------------------\\n\"\n\"Linewise up                 <Up>    <k>\\n\"\n\"Linewise down               <Down>  <j>\\n\"\n\"Pagewise up                 <Page Up>\\n\"\n\"Pagewise down               <Page Down>\\n\"\n\"First entry                 <Home>\\n\"\n\"Last entry                  <End>\\n\"\n\"Enter a submenu             <Right>  <Enter>\\n\"\n\"Go back to parent menu      <Left>   <Esc>  <F5>\\n\"\n\"Close a help window         <Enter>  <Esc>  <F5>\\n\"\n\"Close entry window, apply   <Enter>\\n\"\n\"Close entry window, forget  <Esc>  <F5>\\n\"\n\"Start incremental, case-insensitive search for STRING in menu entries,\\n\"\n\"    no regex support, STRING is displayed in upper left corner\\n\"\n\"                            </>STRING\\n\"\n\"    Remove last character   <Backspace>\\n\"\n\"    Jump to next hit        <Down>\\n\"\n\"    Jump to previous hit    <Up>\\n\"\n\"Exit menu search mode       </>  <Esc>\\n\"\n\"Search for configuration variables with or without leading CONFIG_\\n\"\n\"                            <F8>RegExpr<Enter>\\n\"\n\"Verbose search help         <F8><F1>\\n\"\n\"----------------------------------------------------------------------\\n\"\n\"\\n\"\n\"Unless in a data entry window, key <1> may be used instead of <F1>,\\n\"\n\"<2> instead of <F2>, etc.\\n\"\n\"\\n\"\n\"\\n\"\n\"Radiolist (Choice list)\\n\"\n\"-----------------------\\n\"\n\"Use the movement keys listed above to select the option you wish to set\\n\"\n\"and press <Space>.\\n\"\n\"\\n\"\n\"\\n\"\n\"Data entry\\n\"\n\"----------\\n\"\n\"Enter the requested information and press <Enter>.  Hexadecimal values\\n\"\n\"may be entered without the \\\"0x\\\" prefix.\\n\"\n\"\\n\"\n\"\\n\"\n\"Text Box (Help Window)\\n\"\n\"----------------------\\n\"\n\"Use movement keys as listed in table above.\\n\"\n\"\\n\"\n\"Press any of <Enter> <Esc> <q> <F5> <F9> to exit.\\n\"\n\"\\n\"\n\"\\n\"\n\"Alternate configuration files\\n\"\n\"-----------------------------\\n\"\n\"nconfig supports switching between different configurations.\\n\"\n\"Press <F6> to save your current configuration.  Press <F7> and enter\\n\"\n\"a file name to load a previously saved configuration.\\n\"\n\"\\n\"\n\"\\n\"\n\"Terminal configuration\\n\"\n\"----------------------\\n\"\n\"If you use nconfig in a xterm window, make sure your TERM environment\\n\"\n\"variable specifies a terminal configuration which supports at least\\n\"\n\"16 colors.  Otherwise nconfig will look rather bad.\\n\"\n\"\\n\"\n\"If the \\\"stty size\\\" command reports the current terminalsize correctly,\\n\"\n\"nconfig will adapt to sizes larger than the traditional 80x25 \\\"standard\\\"\\n\"\n\"and display longer menus properly.\\n\"\n\"\\n\"\n\"\\n\"\n\"Single menu mode\\n\"\n\"----------------\\n\"\n\"If you prefer to have all of the menu entries listed in a single menu,\\n\"\n\"rather than the default multimenu hierarchy, run nconfig with\\n\"\n\"NCONFIG_MODE environment variable set to single_menu.  Example:\\n\"\n\"\\n\"\n\"make NCONFIG_MODE=single_menu nconfig\\n\"\n\"\\n\"\n\"<Enter> will then unfold the appropriate category, or fold it if it\\n\"\n\"is already unfolded.  Folded menu entries will be designated by a\\n\"\n\"leading \\\"++>\\\" and unfolded entries by a leading \\\"-->\\\".\\n\"\n\"\\n\"\n\"Note that this mode can eventually be a little more CPU expensive than\\n\"\n\"the default mode, especially with a larger number of unfolded submenus.\\n\"\n\"\\n\",\nmenu_no_f_instructions[] =\n\"Legend:  [*] built-in  [ ] excluded  <M> module  < > module capable.\\n\"\n\"Submenus are designated by a trailing \\\"--->\\\", empty ones by \\\"----\\\".\\n\"\n\"\\n\"\n\"Use the following keys to navigate the menus:\\n\"\n\"Move up or down with <Up> and <Down>.\\n\"\n\"Enter a submenu with <Enter> or <Right>.\\n\"\n\"Exit a submenu to its parent menu with <Esc> or <Left>.\\n\"\n\"Pressing <y> includes, <n> excludes, <m> modularizes features.\\n\"\n\"Pressing <Space> cycles through the available options.\\n\"\n\"To search for menu entries press </>.\\n\"\n\"<Esc> always leaves the current window.\\n\"\n\"\\n\"\n\"You do not have function keys support.\\n\"\n\"Press <1> instead of <F1>, <2> instead of <F2>, etc.\\n\"\n\"For verbose global help use key <1>.\\n\"\n\"For help related to the current menu entry press <?> or <h>.\\n\",\nmenu_instructions[] =\n\"Legend:  [*] built-in  [ ] excluded  <M> module  < > module capable.\\n\"\n\"Submenus are designated by a trailing \\\"--->\\\", empty ones by \\\"----\\\".\\n\"\n\"\\n\"\n\"Use the following keys to navigate the menus:\\n\"\n\"Move up or down with <Up> or <Down>.\\n\"\n\"Enter a submenu with <Enter> or <Right>.\\n\"\n\"Exit a submenu to its parent menu with <Esc> or <Left>.\\n\"\n\"Pressing <y> includes, <n> excludes, <m> modularizes features.\\n\"\n\"Pressing <Space> cycles through the available options.\\n\"\n\"To search for menu entries press </>.\\n\"\n\"<Esc> always leaves the current window.\\n\"\n\"\\n\"\n\"Pressing <1> may be used instead of <F1>, <2> instead of <F2>, etc.\\n\"\n\"For verbose global help press <F1>.\\n\"\n\"For help related to the current menu entry press <?> or <h>.\\n\",\nradiolist_instructions[] =\n\"Press <Up>, <Down>, <Home> or <End> to navigate a radiolist, select\\n\"\n\"with <Space>.\\n\"\n\"For help related to the current entry press <?> or <h>.\\n\"\n\"For global help press <F1>.\\n\",\ninputbox_instructions_int[] =\n\"Please enter a decimal value.\\n\"\n\"Fractions will not be accepted.\\n\"\n\"Press <Enter> to apply, <Esc> to cancel.\",\ninputbox_instructions_hex[] =\n\"Please enter a hexadecimal value.\\n\"\n\"Press <Enter> to apply, <Esc> to cancel.\",\ninputbox_instructions_string[] =\n\"Please enter a string value.\\n\"\n\"Press <Enter> to apply, <Esc> to cancel.\",\nsetmod_text[] =\n\"This feature depends on another feature which has been configured as a\\n\"\n\"module.  As a result, the current feature will be built as a module too.\",\nload_config_text[] =\n\"Enter the name of the configuration file you wish to load.\\n\"\n\"Accept the name shown to restore the configuration you last\\n\"\n\"retrieved.  Leave empty to abort.\",\nload_config_help[] =\n\"For various reasons, one may wish to keep several different\\n\"\n\"configurations available on a single machine.\\n\"\n\"\\n\"\n\"If you have saved a previous configuration in a file other than the\\n\"\n\"default one, entering its name here will allow you to load and modify\\n\"\n\"that configuration.\\n\"\n\"\\n\"\n\"Leave empty to abort.\\n\",\nsave_config_text[] =\n\"Enter a filename to which this configuration should be saved\\n\"\n\"as an alternate.  Leave empty to abort.\",\nsave_config_help[] =\n\"For various reasons, one may wish to keep several different\\n\"\n\"configurations available on a single machine.\\n\"\n\"\\n\"\n\"Entering a file name here will allow you to later retrieve, modify\\n\"\n\"and use the current configuration as an alternate to whatever\\n\"\n\"configuration options you have selected at that time.\\n\"\n\"\\n\"\n\"Leave empty to abort.\\n\",\nsearch_help[] =\n\"Search for symbols (configuration variable names CONFIG_*) and display\\n\"\n\"their relations.  Regular expressions are supported.\\n\"\n\"Example:  Search for \\\"^FOO\\\".\\n\"\n\"Result:\\n\"\n\"-----------------------------------------------------------------\\n\"\n\"Symbol: FOO [ = m]\\n\"\n\"Prompt: Foo bus is used to drive the bar HW\\n\"\n\"Defined at drivers/pci/Kconfig:47\\n\"\n\"Depends on: X86_LOCAL_APIC && X86_IO_APIC || IA64\\n\"\n\"Location:\\n\"\n\"  -> Bus options (PCI, PCMCIA, EISA, ISA)\\n\"\n\"    -> PCI support (PCI [ = y])\\n\"\n\"(1)   -> PCI access mode (<choice> [ = y])\\n\"\n\"Selects: LIBCRC32\\n\"\n\"Selected by: BAR\\n\"\n\"-----------------------------------------------------------------\\n\"\n\"o  The line 'Prompt:' shows the text displayed for this symbol in\\n\"\n\"   the menu hierarchy.\\n\"\n\"o  The 'Defined at' line tells at what file / line number the symbol is\\n\"\n\"   defined.\\n\"\n\"o  The 'Depends on:' line lists symbols that need to be defined for\\n\"\n\"   this symbol to be visible and selectable in the menu.\\n\"\n\"o  The 'Location:' lines tell, where in the menu structure this symbol\\n\"\n\"   is located.\\n\"\n\"     A location followed by a [ = y] indicates that this is\\n\"\n\"     a selectable menu item, and the current value is displayed inside\\n\"\n\"     brackets.\\n\"\n\"     Press the key in the (#) prefix to jump directly to that\\n\"\n\"     location. You will be returned to the current search results\\n\"\n\"     after exiting this new menu.\\n\"\n\"o  The 'Selects:' line tells, what symbol will be automatically selected\\n\"\n\"   if this symbol is selected (y or m).\\n\"\n\"o  The 'Selected by' line tells what symbol has selected this symbol.\\n\"\n\"\\n\"\n\"Only relevant lines are shown.\\n\"\n\"\\n\\n\"\n\"Search examples:\\n\"\n\"USB  => find all symbols containing USB\\n\"\n\"^USB => find all symbols starting with USB\\n\"\n\"USB$ => find all symbols ending with USB\\n\"\n\"\\n\";\n\nstruct mitem {\n\tchar str[256];\n\tchar tag;\n\tvoid *usrptr;\n\tint is_visible;\n};\n\n#define MAX_MENU_ITEMS 4096\nstatic int show_all_items;\nstatic int indent;\nstatic struct menu *current_menu;\nstatic int child_count;\nstatic int single_menu_mode;\n \nstatic WINDOW *main_window;\n \nstatic int mwin_max_lines;\nstatic int mwin_max_cols;\n \nstatic MENU *curses_menu;\nstatic ITEM *curses_menu_items[MAX_MENU_ITEMS];\nstatic struct mitem k_menu_items[MAX_MENU_ITEMS];\nstatic unsigned int items_num;\nstatic int global_exit;\n \nstatic const char *current_instructions = menu_instructions;\n\nstatic char *dialog_input_result;\nstatic int dialog_input_result_len;\nstatic int jump_key_char;\n\nstatic void selected_conf(struct menu *menu, struct menu *active_menu);\nstatic void conf(struct menu *menu);\nstatic void conf_choice(struct menu *menu);\nstatic void conf_string(struct menu *menu);\nstatic void conf_load(void);\nstatic void conf_save(void);\nstatic void show_help(struct menu *menu);\nstatic int do_exit(void);\nstatic void setup_windows(void);\nstatic void search_conf(void);\n\ntypedef void (*function_key_handler_t)(int *key, struct menu *menu);\nstatic void handle_f1(int *key, struct menu *current_item);\nstatic void handle_f2(int *key, struct menu *current_item);\nstatic void handle_f3(int *key, struct menu *current_item);\nstatic void handle_f4(int *key, struct menu *current_item);\nstatic void handle_f5(int *key, struct menu *current_item);\nstatic void handle_f6(int *key, struct menu *current_item);\nstatic void handle_f7(int *key, struct menu *current_item);\nstatic void handle_f8(int *key, struct menu *current_item);\nstatic void handle_f9(int *key, struct menu *current_item);\n\nstruct function_keys {\n\tconst char *key_str;\n\tconst char *func;\n\tfunction_key key;\n\tfunction_key_handler_t handler;\n};\n\nstatic const int function_keys_num = 9;\nstatic struct function_keys function_keys[] = {\n\t{\n\t\t.key_str = \"F1\",\n\t\t.func = \"Help\",\n\t\t.key = F_HELP,\n\t\t.handler = handle_f1,\n\t},\n\t{\n\t\t.key_str = \"F2\",\n\t\t.func = \"SymInfo\",\n\t\t.key = F_SYMBOL,\n\t\t.handler = handle_f2,\n\t},\n\t{\n\t\t.key_str = \"F3\",\n\t\t.func = \"Help 2\",\n\t\t.key = F_INSTS,\n\t\t.handler = handle_f3,\n\t},\n\t{\n\t\t.key_str = \"F4\",\n\t\t.func = \"ShowAll\",\n\t\t.key = F_CONF,\n\t\t.handler = handle_f4,\n\t},\n\t{\n\t\t.key_str = \"F5\",\n\t\t.func = \"Back\",\n\t\t.key = F_BACK,\n\t\t.handler = handle_f5,\n\t},\n\t{\n\t\t.key_str = \"F6\",\n\t\t.func = \"Save\",\n\t\t.key = F_SAVE,\n\t\t.handler = handle_f6,\n\t},\n\t{\n\t\t.key_str = \"F7\",\n\t\t.func = \"Load\",\n\t\t.key = F_LOAD,\n\t\t.handler = handle_f7,\n\t},\n\t{\n\t\t.key_str = \"F8\",\n\t\t.func = \"SymSearch\",\n\t\t.key = F_SEARCH,\n\t\t.handler = handle_f8,\n\t},\n\t{\n\t\t.key_str = \"F9\",\n\t\t.func = \"Exit\",\n\t\t.key = F_EXIT,\n\t\t.handler = handle_f9,\n\t},\n};\n\nstatic void print_function_line(void)\n{\n\tint i;\n\tint offset = 1;\n\tconst int skip = 1;\n\tint lines = getmaxy(stdscr);\n\n\tfor (i = 0; i < function_keys_num; i++) {\n\t\twattrset(main_window, attr_function_highlight);\n\t\tmvwprintw(main_window, lines-3, offset,\n\t\t\t\t\"%s\",\n\t\t\t\tfunction_keys[i].key_str);\n\t\twattrset(main_window, attr_function_text);\n\t\toffset += strlen(function_keys[i].key_str);\n\t\tmvwprintw(main_window, lines-3,\n\t\t\t\toffset, \"%s\",\n\t\t\t\tfunction_keys[i].func);\n\t\toffset += strlen(function_keys[i].func) + skip;\n\t}\n\twattrset(main_window, attr_normal);\n}\n\n \nstatic void handle_f1(int *key, struct menu *current_item)\n{\n\tshow_scroll_win(main_window,\n\t\t\t\"Global help\", nconf_global_help);\n\treturn;\n}\n\n \nstatic void handle_f2(int *key, struct menu *current_item)\n{\n\tshow_help(current_item);\n\treturn;\n}\n\n \nstatic void handle_f3(int *key, struct menu *current_item)\n{\n\tshow_scroll_win(main_window,\n\t\t\t\"Short help\",\n\t\t\tcurrent_instructions);\n\treturn;\n}\n\n \nstatic void handle_f4(int *key, struct menu *current_item)\n{\n\tint res = btn_dialog(main_window,\n\t\t\t\"Show all symbols?\",\n\t\t\t2,\n\t\t\t\"   <Show All>   \",\n\t\t\t\"<Don't show all>\");\n\tif (res == 0)\n\t\tshow_all_items = 1;\n\telse if (res == 1)\n\t\tshow_all_items = 0;\n\n\treturn;\n}\n\n \nstatic void handle_f5(int *key, struct menu *current_item)\n{\n\t*key = KEY_LEFT;\n\treturn;\n}\n\n \nstatic void handle_f6(int *key, struct menu *current_item)\n{\n\tconf_save();\n\treturn;\n}\n\n \nstatic void handle_f7(int *key, struct menu *current_item)\n{\n\tconf_load();\n\treturn;\n}\n\n \nstatic void handle_f8(int *key, struct menu *current_item)\n{\n\tsearch_conf();\n\treturn;\n}\n\n \nstatic void handle_f9(int *key, struct menu *current_item)\n{\n\tdo_exit();\n\treturn;\n}\n\n \nstatic int process_special_keys(int *key, struct menu *menu)\n{\n\tint i;\n\n\tif (*key == KEY_RESIZE) {\n\t\tsetup_windows();\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < function_keys_num; i++) {\n\t\tif (*key == KEY_F(function_keys[i].key) ||\n\t\t    *key == '0' + function_keys[i].key){\n\t\t\tfunction_keys[i].handler(key, menu);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void clean_items(void)\n{\n\tint i;\n\tfor (i = 0; curses_menu_items[i]; i++)\n\t\tfree_item(curses_menu_items[i]);\n\tbzero(curses_menu_items, sizeof(curses_menu_items));\n\tbzero(k_menu_items, sizeof(k_menu_items));\n\titems_num = 0;\n}\n\ntypedef enum {MATCH_TINKER_PATTERN_UP, MATCH_TINKER_PATTERN_DOWN,\n\tFIND_NEXT_MATCH_DOWN, FIND_NEXT_MATCH_UP} match_f;\n\n \nstatic int get_mext_match(const char *match_str, match_f flag)\n{\n\tint match_start, index;\n\n\t \n\tmatch_start = item_index(current_item(curses_menu));\n\tif (match_start == ERR)\n\t\treturn -1;\n\n\tif (flag == FIND_NEXT_MATCH_DOWN)\n\t\t++match_start;\n\telse if (flag == FIND_NEXT_MATCH_UP)\n\t\t--match_start;\n\n\tmatch_start = (match_start + items_num) % items_num;\n\tindex = match_start;\n\twhile (true) {\n\t\tchar *str = k_menu_items[index].str;\n\t\tif (strcasestr(str, match_str) != NULL)\n\t\t\treturn index;\n\t\tif (flag == FIND_NEXT_MATCH_UP ||\n\t\t    flag == MATCH_TINKER_PATTERN_UP)\n\t\t\t--index;\n\t\telse\n\t\t\t++index;\n\t\tindex = (index + items_num) % items_num;\n\t\tif (index == match_start)\n\t\t\treturn -1;\n\t}\n}\n\n \nstatic void item_make(struct menu *menu, char tag, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif (items_num > MAX_MENU_ITEMS-1)\n\t\treturn;\n\n\tbzero(&k_menu_items[items_num], sizeof(k_menu_items[0]));\n\tk_menu_items[items_num].tag = tag;\n\tk_menu_items[items_num].usrptr = menu;\n\tif (menu != NULL)\n\t\tk_menu_items[items_num].is_visible =\n\t\t\tmenu_is_visible(menu);\n\telse\n\t\tk_menu_items[items_num].is_visible = 1;\n\n\tva_start(ap, fmt);\n\tvsnprintf(k_menu_items[items_num].str,\n\t\t  sizeof(k_menu_items[items_num].str),\n\t\t  fmt, ap);\n\tva_end(ap);\n\n\tif (!k_menu_items[items_num].is_visible)\n\t\tmemcpy(k_menu_items[items_num].str, \"XXX\", 3);\n\n\tcurses_menu_items[items_num] = new_item(\n\t\t\tk_menu_items[items_num].str,\n\t\t\tk_menu_items[items_num].str);\n\tset_item_userptr(curses_menu_items[items_num],\n\t\t\t&k_menu_items[items_num]);\n\t \n\n\titems_num++;\n\tcurses_menu_items[items_num] = NULL;\n}\n\n \nstatic void item_add_str(const char *fmt, ...)\n{\n\tva_list ap;\n\tint index = items_num-1;\n\tchar new_str[256];\n\tchar tmp_str[256];\n\n\tif (index < 0)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\tvsnprintf(new_str, sizeof(new_str), fmt, ap);\n\tva_end(ap);\n\tsnprintf(tmp_str, sizeof(tmp_str), \"%s%s\",\n\t\t\tk_menu_items[index].str, new_str);\n\tstrncpy(k_menu_items[index].str,\n\t\ttmp_str,\n\t\tsizeof(k_menu_items[index].str));\n\n\tfree_item(curses_menu_items[index]);\n\tcurses_menu_items[index] = new_item(\n\t\t\tk_menu_items[index].str,\n\t\t\tk_menu_items[index].str);\n\tset_item_userptr(curses_menu_items[index],\n\t\t\t&k_menu_items[index]);\n}\n\n \nstatic char item_tag(void)\n{\n\tITEM *cur;\n\tstruct mitem *mcur;\n\n\tcur = current_item(curses_menu);\n\tif (cur == NULL)\n\t\treturn 0;\n\tmcur = (struct mitem *) item_userptr(cur);\n\treturn mcur->tag;\n}\n\nstatic int curses_item_index(void)\n{\n\treturn  item_index(current_item(curses_menu));\n}\n\nstatic void *item_data(void)\n{\n\tITEM *cur;\n\tstruct mitem *mcur;\n\n\tcur = current_item(curses_menu);\n\tif (!cur)\n\t\treturn NULL;\n\tmcur = (struct mitem *) item_userptr(cur);\n\treturn mcur->usrptr;\n\n}\n\nstatic int item_is_tag(char tag)\n{\n\treturn item_tag() == tag;\n}\n\nstatic char filename[PATH_MAX+1];\nstatic char menu_backtitle[PATH_MAX+128];\nstatic void set_config_filename(const char *config_filename)\n{\n\tsnprintf(menu_backtitle, sizeof(menu_backtitle), \"%s - %s\",\n\t\t config_filename, rootmenu.prompt->text);\n\n\tsnprintf(filename, sizeof(filename), \"%s\", config_filename);\n}\n\n \nstatic int do_exit(void)\n{\n\tint res;\n\tif (!conf_get_changed()) {\n\t\tglobal_exit = 1;\n\t\treturn 0;\n\t}\n\tres = btn_dialog(main_window,\n\t\t\t\"Do you wish to save your new configuration?\\n\"\n\t\t\t\t\"<ESC> to cancel and resume nconfig.\",\n\t\t\t2,\n\t\t\t\"   <save>   \",\n\t\t\t\"<don't save>\");\n\tif (res == KEY_EXIT) {\n\t\tglobal_exit = 0;\n\t\treturn -1;\n\t}\n\n\t \n\tswitch (res) {\n\tcase 0:\n\t\tres = conf_write(filename);\n\t\tif (res)\n\t\t\tbtn_dialog(\n\t\t\t\tmain_window,\n\t\t\t\t\"Error during writing of configuration.\\n\"\n\t\t\t\t  \"Your configuration changes were NOT saved.\",\n\t\t\t\t  1,\n\t\t\t\t  \"<OK>\");\n\t\tconf_write_autoconf(0);\n\t\tbreak;\n\tdefault:\n\t\tbtn_dialog(\n\t\t\tmain_window,\n\t\t\t\"Your configuration changes were NOT saved.\",\n\t\t\t1,\n\t\t\t\"<OK>\");\n\t\tbreak;\n\t}\n\tglobal_exit = 1;\n\treturn 0;\n}\n\nstruct search_data {\n\tstruct list_head *head;\n\tstruct menu *target;\n};\n\nstatic int next_jump_key(int key)\n{\n\tif (key < '1' || key > '9')\n\t\treturn '1';\n\n\tkey++;\n\n\tif (key > '9')\n\t\tkey = '1';\n\n\treturn key;\n}\n\nstatic int handle_search_keys(int key, size_t start, size_t end, void *_data)\n{\n\tstruct search_data *data = _data;\n\tstruct jump_key *pos;\n\tint index = 0;\n\n\tif (key < '1' || key > '9')\n\t\treturn 0;\n\n\tlist_for_each_entry(pos, data->head, entries) {\n\t\tindex = next_jump_key(index);\n\n\t\tif (pos->offset < start)\n\t\t\tcontinue;\n\n\t\tif (pos->offset >= end)\n\t\t\tbreak;\n\n\t\tif (key == index) {\n\t\t\tdata->target = pos->target;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint get_jump_key_char(void)\n{\n\tjump_key_char = next_jump_key(jump_key_char);\n\n\treturn jump_key_char;\n}\n\nstatic void search_conf(void)\n{\n\tstruct symbol **sym_arr;\n\tstruct gstr res;\n\tstruct gstr title;\n\tchar *dialog_input;\n\tint dres, vscroll = 0, hscroll = 0;\n\tbool again;\n\n\ttitle = str_new();\n\tstr_printf( &title, \"Enter (sub)string or regexp to search for \"\n\t\t\t      \"(with or without \\\"%s\\\")\", CONFIG_);\n\nagain:\n\tdres = dialog_inputbox(main_window,\n\t\t\t\"Search Configuration Parameter\",\n\t\t\tstr_get(&title),\n\t\t\t\"\", &dialog_input_result, &dialog_input_result_len);\n\tswitch (dres) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tshow_scroll_win(main_window,\n\t\t\t\t\"Search Configuration\", search_help);\n\t\tgoto again;\n\tdefault:\n\t\tstr_free(&title);\n\t\treturn;\n\t}\n\n\t \n\tdialog_input = dialog_input_result;\n\tif (strncasecmp(dialog_input_result, CONFIG_, strlen(CONFIG_)) == 0)\n\t\tdialog_input += strlen(CONFIG_);\n\n\tsym_arr = sym_re_search(dialog_input);\n\n\tdo {\n\t\tLIST_HEAD(head);\n\t\tstruct search_data data = {\n\t\t\t.head = &head,\n\t\t\t.target = NULL,\n\t\t};\n\t\tjump_key_char = 0;\n\t\tres = get_relations_str(sym_arr, &head);\n\t\tdres = show_scroll_win_ext(main_window,\n\t\t\t\t\"Search Results\", str_get(&res),\n\t\t\t\t&vscroll, &hscroll,\n\t\t\t\thandle_search_keys, &data);\n\t\tagain = false;\n\t\tif (dres >= '1' && dres <= '9') {\n\t\t\tassert(data.target != NULL);\n\t\t\tselected_conf(data.target->parent, data.target);\n\t\t\tagain = true;\n\t\t}\n\t\tstr_free(&res);\n\t} while (again);\n\tfree(sym_arr);\n\tstr_free(&title);\n}\n\n\nstatic void build_conf(struct menu *menu)\n{\n\tstruct symbol *sym;\n\tstruct property *prop;\n\tstruct menu *child;\n\tint type, tmp, doint = 2;\n\ttristate val;\n\tchar ch;\n\n\tif (!menu || (!show_all_items && !menu_is_visible(menu)))\n\t\treturn;\n\n\tsym = menu->sym;\n\tprop = menu->prompt;\n\tif (!sym) {\n\t\tif (prop && menu != current_menu) {\n\t\t\tconst char *prompt = menu_get_prompt(menu);\n\t\t\tenum prop_type ptype;\n\t\t\tptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\n\t\t\tswitch (ptype) {\n\t\t\tcase P_MENU:\n\t\t\t\tchild_count++;\n\t\t\t\tif (single_menu_mode) {\n\t\t\t\t\titem_make(menu, 'm',\n\t\t\t\t\t\t\"%s%*c%s\",\n\t\t\t\t\t\tmenu->data ? \"-->\" : \"++>\",\n\t\t\t\t\t\tindent + 1, ' ', prompt);\n\t\t\t\t} else\n\t\t\t\t\titem_make(menu, 'm',\n\t\t\t\t\t\t  \"   %*c%s  %s\",\n\t\t\t\t\t\t  indent + 1, ' ', prompt,\n\t\t\t\t\t\t  menu_is_empty(menu) ? \"----\" : \"--->\");\n\n\t\t\t\tif (single_menu_mode && menu->data)\n\t\t\t\t\tgoto conf_childs;\n\t\t\t\treturn;\n\t\t\tcase P_COMMENT:\n\t\t\t\tif (prompt) {\n\t\t\t\t\tchild_count++;\n\t\t\t\t\titem_make(menu, ':',\n\t\t\t\t\t\t\"   %*c*** %s ***\",\n\t\t\t\t\t\tindent + 1, ' ',\n\t\t\t\t\t\tprompt);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (prompt) {\n\t\t\t\t\tchild_count++;\n\t\t\t\t\titem_make(menu, ':', \"---%*c%s\",\n\t\t\t\t\t\tindent + 1, ' ',\n\t\t\t\t\t\tprompt);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tdoint = 0;\n\t\tgoto conf_childs;\n\t}\n\n\ttype = sym_get_type(sym);\n\tif (sym_is_choice(sym)) {\n\t\tstruct symbol *def_sym = sym_get_choice_value(sym);\n\t\tstruct menu *def_menu = NULL;\n\n\t\tchild_count++;\n\t\tfor (child = menu->list; child; child = child->next) {\n\t\t\tif (menu_is_visible(child) && child->sym == def_sym)\n\t\t\t\tdef_menu = child;\n\t\t}\n\n\t\tval = sym_get_tristate_value(sym);\n\t\tif (sym_is_changeable(sym)) {\n\t\t\tswitch (type) {\n\t\t\tcase S_BOOLEAN:\n\t\t\t\titem_make(menu, 't', \"[%c]\",\n\t\t\t\t\t\tval == no ? ' ' : '*');\n\t\t\t\tbreak;\n\t\t\tcase S_TRISTATE:\n\t\t\t\tswitch (val) {\n\t\t\t\tcase yes:\n\t\t\t\t\tch = '*';\n\t\t\t\t\tbreak;\n\t\t\t\tcase mod:\n\t\t\t\t\tch = 'M';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tch = ' ';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titem_make(menu, 't', \"<%c>\", ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\titem_make(menu, def_menu ? 't' : ':', \"   \");\n\t\t}\n\n\t\titem_add_str(\"%*c%s\", indent + 1,\n\t\t\t\t' ', menu_get_prompt(menu));\n\t\tif (val == yes) {\n\t\t\tif (def_menu) {\n\t\t\t\titem_add_str(\" (%s)\",\n\t\t\t\t\tmenu_get_prompt(def_menu));\n\t\t\t\titem_add_str(\"  --->\");\n\t\t\t\tif (def_menu->list) {\n\t\t\t\t\tindent += 2;\n\t\t\t\t\tbuild_conf(def_menu);\n\t\t\t\t\tindent -= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (menu == current_menu) {\n\t\t\titem_make(menu, ':',\n\t\t\t\t\"---%*c%s\", indent + 1,\n\t\t\t\t' ', menu_get_prompt(menu));\n\t\t\tgoto conf_childs;\n\t\t}\n\t\tchild_count++;\n\t\tval = sym_get_tristate_value(sym);\n\t\tif (sym_is_choice_value(sym) && val == yes) {\n\t\t\titem_make(menu, ':', \"   \");\n\t\t} else {\n\t\t\tswitch (type) {\n\t\t\tcase S_BOOLEAN:\n\t\t\t\tif (sym_is_changeable(sym))\n\t\t\t\t\titem_make(menu, 't', \"[%c]\",\n\t\t\t\t\t\tval == no ? ' ' : '*');\n\t\t\t\telse\n\t\t\t\t\titem_make(menu, 't', \"-%c-\",\n\t\t\t\t\t\tval == no ? ' ' : '*');\n\t\t\t\tbreak;\n\t\t\tcase S_TRISTATE:\n\t\t\t\tswitch (val) {\n\t\t\t\tcase yes:\n\t\t\t\t\tch = '*';\n\t\t\t\t\tbreak;\n\t\t\t\tcase mod:\n\t\t\t\t\tch = 'M';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tch = ' ';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (sym_is_changeable(sym)) {\n\t\t\t\t\tif (sym->rev_dep.tri == mod)\n\t\t\t\t\t\titem_make(menu,\n\t\t\t\t\t\t\t't', \"{%c}\", ch);\n\t\t\t\t\telse\n\t\t\t\t\t\titem_make(menu,\n\t\t\t\t\t\t\t't', \"<%c>\", ch);\n\t\t\t\t} else\n\t\t\t\t\titem_make(menu, 't', \"-%c-\", ch);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttmp = 2 + strlen(sym_get_string_value(sym));\n\t\t\t\titem_make(menu, 's', \"    (%s)\",\n\t\t\t\t\t\tsym_get_string_value(sym));\n\t\t\t\ttmp = indent - tmp + 4;\n\t\t\t\tif (tmp < 0)\n\t\t\t\t\ttmp = 0;\n\t\t\t\titem_add_str(\"%*c%s%s\", tmp, ' ',\n\t\t\t\t\t\tmenu_get_prompt(menu),\n\t\t\t\t\t\t(sym_has_value(sym) ||\n\t\t\t\t\t\t !sym_is_changeable(sym)) ? \"\" :\n\t\t\t\t\t\t\" (NEW)\");\n\t\t\t\tgoto conf_childs;\n\t\t\t}\n\t\t}\n\t\titem_add_str(\"%*c%s%s\", indent + 1, ' ',\n\t\t\t\tmenu_get_prompt(menu),\n\t\t\t\t(sym_has_value(sym) || !sym_is_changeable(sym)) ?\n\t\t\t\t\"\" : \" (NEW)\");\n\t\tif (menu->prompt && menu->prompt->type == P_MENU) {\n\t\t\titem_add_str(\"  %s\", menu_is_empty(menu) ? \"----\" : \"--->\");\n\t\t\treturn;\n\t\t}\n\t}\n\nconf_childs:\n\tindent += doint;\n\tfor (child = menu->list; child; child = child->next)\n\t\tbuild_conf(child);\n\tindent -= doint;\n}\n\nstatic void reset_menu(void)\n{\n\tunpost_menu(curses_menu);\n\tclean_items();\n}\n\n \nstatic void center_item(int selected_index, int *last_top_row)\n{\n\tint toprow;\n\n\tset_top_row(curses_menu, *last_top_row);\n\ttoprow = top_row(curses_menu);\n\tif (selected_index < toprow ||\n\t    selected_index >= toprow+mwin_max_lines) {\n\t\ttoprow = max(selected_index-mwin_max_lines/2, 0);\n\t\tif (toprow >= item_count(curses_menu)-mwin_max_lines)\n\t\t\ttoprow = item_count(curses_menu)-mwin_max_lines;\n\t\tset_top_row(curses_menu, toprow);\n\t}\n\tset_current_item(curses_menu,\n\t\t\tcurses_menu_items[selected_index]);\n\t*last_top_row = toprow;\n\tpost_menu(curses_menu);\n\trefresh_all_windows(main_window);\n}\n\n \nstatic void show_menu(const char *prompt, const char *instructions,\n\t\tint selected_index, int *last_top_row)\n{\n\tint maxx, maxy;\n\tWINDOW *menu_window;\n\n\tcurrent_instructions = instructions;\n\n\tclear();\n\tprint_in_middle(stdscr, 1, getmaxx(stdscr),\n\t\t\tmenu_backtitle,\n\t\t\tattr_main_heading);\n\n\twattrset(main_window, attr_main_menu_box);\n\tbox(main_window, 0, 0);\n\twattrset(main_window, attr_main_menu_heading);\n\tmvwprintw(main_window, 0, 3, \" %s \", prompt);\n\twattrset(main_window, attr_normal);\n\n\tset_menu_items(curses_menu, curses_menu_items);\n\n\t \n\tscale_menu(curses_menu, &maxy, &maxx);\n\tmaxx = min(maxx, mwin_max_cols-2);\n\tmaxy = mwin_max_lines;\n\tmenu_window = derwin(main_window,\n\t\t\tmaxy,\n\t\t\tmaxx,\n\t\t\t2,\n\t\t\t(mwin_max_cols-maxx)/2);\n\tkeypad(menu_window, TRUE);\n\tset_menu_win(curses_menu, menu_window);\n\tset_menu_sub(curses_menu, menu_window);\n\n\t \n\tset_menu_format(curses_menu, maxy, 1);\n\tcenter_item(selected_index, last_top_row);\n\tset_menu_format(curses_menu, maxy, 1);\n\n\tprint_function_line();\n\n\t \n\tpost_menu(curses_menu);\n\trefresh_all_windows(main_window);\n}\n\nstatic void adj_match_dir(match_f *match_direction)\n{\n\tif (*match_direction == FIND_NEXT_MATCH_DOWN)\n\t\t*match_direction =\n\t\t\tMATCH_TINKER_PATTERN_DOWN;\n\telse if (*match_direction == FIND_NEXT_MATCH_UP)\n\t\t*match_direction =\n\t\t\tMATCH_TINKER_PATTERN_UP;\n\t \n}\n\nstruct match_state\n{\n\tint in_search;\n\tmatch_f match_direction;\n\tchar pattern[256];\n};\n\n \nstatic int do_match(int key, struct match_state *state, int *ans)\n{\n\tchar c = (char) key;\n\tint terminate_search = 0;\n\t*ans = -1;\n\tif (key == '/' || (state->in_search && key == 27)) {\n\t\tmove(0, 0);\n\t\trefresh();\n\t\tclrtoeol();\n\t\tstate->in_search = 1-state->in_search;\n\t\tbzero(state->pattern, sizeof(state->pattern));\n\t\tstate->match_direction = MATCH_TINKER_PATTERN_DOWN;\n\t\treturn 0;\n\t} else if (!state->in_search)\n\t\treturn 1;\n\n\tif (isalnum(c) || isgraph(c) || c == ' ') {\n\t\tstate->pattern[strlen(state->pattern)] = c;\n\t\tstate->pattern[strlen(state->pattern)] = '\\0';\n\t\tadj_match_dir(&state->match_direction);\n\t\t*ans = get_mext_match(state->pattern,\n\t\t\t\tstate->match_direction);\n\t} else if (key == KEY_DOWN) {\n\t\tstate->match_direction = FIND_NEXT_MATCH_DOWN;\n\t\t*ans = get_mext_match(state->pattern,\n\t\t\t\tstate->match_direction);\n\t} else if (key == KEY_UP) {\n\t\tstate->match_direction = FIND_NEXT_MATCH_UP;\n\t\t*ans = get_mext_match(state->pattern,\n\t\t\t\tstate->match_direction);\n\t} else if (key == KEY_BACKSPACE || key == 8 || key == 127) {\n\t\tstate->pattern[strlen(state->pattern)-1] = '\\0';\n\t\tadj_match_dir(&state->match_direction);\n\t} else\n\t\tterminate_search = 1;\n\n\tif (terminate_search) {\n\t\tstate->in_search = 0;\n\t\tbzero(state->pattern, sizeof(state->pattern));\n\t\tmove(0, 0);\n\t\trefresh();\n\t\tclrtoeol();\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void conf(struct menu *menu)\n{\n\tselected_conf(menu, NULL);\n}\n\nstatic void selected_conf(struct menu *menu, struct menu *active_menu)\n{\n\tstruct menu *submenu = NULL;\n\tstruct symbol *sym;\n\tint i, res;\n\tint current_index = 0;\n\tint last_top_row = 0;\n\tstruct match_state match_state = {\n\t\t.in_search = 0,\n\t\t.match_direction = MATCH_TINKER_PATTERN_DOWN,\n\t\t.pattern = \"\",\n\t};\n\n\twhile (!global_exit) {\n\t\treset_menu();\n\t\tcurrent_menu = menu;\n\t\tbuild_conf(menu);\n\t\tif (!child_count)\n\t\t\tbreak;\n\n\t\tif (active_menu != NULL) {\n\t\t\tfor (i = 0; i < items_num; i++) {\n\t\t\t\tstruct mitem *mcur;\n\n\t\t\t\tmcur = (struct mitem *) item_userptr(curses_menu_items[i]);\n\t\t\t\tif ((struct menu *) mcur->usrptr == active_menu) {\n\t\t\t\t\tcurrent_index = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tactive_menu = NULL;\n\t\t}\n\n\t\tshow_menu(menu_get_prompt(menu), menu_instructions,\n\t\t\t  current_index, &last_top_row);\n\t\tkeypad((menu_win(curses_menu)), TRUE);\n\t\twhile (!global_exit) {\n\t\t\tif (match_state.in_search) {\n\t\t\t\tmvprintw(0, 0,\n\t\t\t\t\t\"searching: %s\", match_state.pattern);\n\t\t\t\tclrtoeol();\n\t\t\t}\n\t\t\trefresh_all_windows(main_window);\n\t\t\tres = wgetch(menu_win(curses_menu));\n\t\t\tif (!res)\n\t\t\t\tbreak;\n\t\t\tif (do_match(res, &match_state, &current_index) == 0) {\n\t\t\t\tif (current_index != -1)\n\t\t\t\t\tcenter_item(current_index,\n\t\t\t\t\t\t    &last_top_row);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (process_special_keys(&res,\n\t\t\t\t\t\t(struct menu *) item_data()))\n\t\t\t\tbreak;\n\t\t\tswitch (res) {\n\t\t\tcase KEY_DOWN:\n\t\t\tcase 'j':\n\t\t\t\tmenu_driver(curses_menu, REQ_DOWN_ITEM);\n\t\t\t\tbreak;\n\t\t\tcase KEY_UP:\n\t\t\tcase 'k':\n\t\t\t\tmenu_driver(curses_menu, REQ_UP_ITEM);\n\t\t\t\tbreak;\n\t\t\tcase KEY_NPAGE:\n\t\t\t\tmenu_driver(curses_menu, REQ_SCR_DPAGE);\n\t\t\t\tbreak;\n\t\t\tcase KEY_PPAGE:\n\t\t\t\tmenu_driver(curses_menu, REQ_SCR_UPAGE);\n\t\t\t\tbreak;\n\t\t\tcase KEY_HOME:\n\t\t\t\tmenu_driver(curses_menu, REQ_FIRST_ITEM);\n\t\t\t\tbreak;\n\t\t\tcase KEY_END:\n\t\t\t\tmenu_driver(curses_menu, REQ_LAST_ITEM);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tshow_help((struct menu *) item_data());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res == 10 || res == 27 ||\n\t\t\t\tres == 32 || res == 'n' || res == 'y' ||\n\t\t\t\tres == KEY_LEFT || res == KEY_RIGHT ||\n\t\t\t\tres == 'm')\n\t\t\t\tbreak;\n\t\t\trefresh_all_windows(main_window);\n\t\t}\n\n\t\trefresh_all_windows(main_window);\n\t\t \n\t\tif (res == 27 || (menu != &rootmenu && res == KEY_LEFT))\n\t\t\tbreak;\n\n\t\t \n\t\tlast_top_row = top_row(curses_menu);\n\t\tcurrent_index = curses_item_index();\n\n\t\tif (!item_tag())\n\t\t\tcontinue;\n\n\t\tsubmenu = (struct menu *) item_data();\n\t\tif (!submenu || !menu_is_visible(submenu))\n\t\t\tcontinue;\n\t\tsym = submenu->sym;\n\n\t\tswitch (res) {\n\t\tcase ' ':\n\t\t\tif (item_is_tag('t'))\n\t\t\t\tsym_toggle_tristate_value(sym);\n\t\t\telse if (item_is_tag('m'))\n\t\t\t\tconf(submenu);\n\t\t\tbreak;\n\t\tcase KEY_RIGHT:\n\t\tcase 10:  \n\t\t\tswitch (item_tag()) {\n\t\t\tcase 'm':\n\t\t\t\tif (single_menu_mode)\n\t\t\t\t\tsubmenu->data =\n\t\t\t\t\t\t(void *) (long) !submenu->data;\n\t\t\t\telse\n\t\t\t\t\tconf(submenu);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tif (sym_is_choice(sym) &&\n\t\t\t\t    sym_get_tristate_value(sym) == yes)\n\t\t\t\t\tconf_choice(submenu);\n\t\t\t\telse if (submenu->prompt &&\n\t\t\t\t\t submenu->prompt->type == P_MENU)\n\t\t\t\t\tconf(submenu);\n\t\t\t\telse if (res == 10)\n\t\t\t\t\tsym_toggle_tristate_value(sym);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tconf_string(submenu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (item_is_tag('t')) {\n\t\t\t\tif (sym_set_tristate_value(sym, yes))\n\t\t\t\t\tbreak;\n\t\t\t\tif (sym_set_tristate_value(sym, mod))\n\t\t\t\t\tbtn_dialog(main_window, setmod_text, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (item_is_tag('t'))\n\t\t\t\tsym_set_tristate_value(sym, no);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (item_is_tag('t'))\n\t\t\t\tsym_set_tristate_value(sym, mod);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void conf_message_callback(const char *s)\n{\n\tbtn_dialog(main_window, s, 1, \"<OK>\");\n}\n\nstatic void show_help(struct menu *menu)\n{\n\tstruct gstr help;\n\n\tif (!menu)\n\t\treturn;\n\n\thelp = str_new();\n\tmenu_get_ext_help(menu, &help);\n\tshow_scroll_win(main_window, menu_get_prompt(menu), str_get(&help));\n\tstr_free(&help);\n}\n\nstatic void conf_choice(struct menu *menu)\n{\n\tconst char *prompt = menu_get_prompt(menu);\n\tstruct menu *child = NULL;\n\tstruct symbol *active;\n\tint selected_index = 0;\n\tint last_top_row = 0;\n\tint res, i = 0;\n\tstruct match_state match_state = {\n\t\t.in_search = 0,\n\t\t.match_direction = MATCH_TINKER_PATTERN_DOWN,\n\t\t.pattern = \"\",\n\t};\n\n\tactive = sym_get_choice_value(menu->sym);\n\t \n\twhile (!global_exit) {\n\t\treset_menu();\n\n\t\tfor (i = 0, child = menu->list; child; child = child->next) {\n\t\t\tif (!show_all_items && !menu_is_visible(child))\n\t\t\t\tcontinue;\n\n\t\t\tif (child->sym == sym_get_choice_value(menu->sym))\n\t\t\t\titem_make(child, ':', \"<X> %s\",\n\t\t\t\t\t\tmenu_get_prompt(child));\n\t\t\telse if (child->sym)\n\t\t\t\titem_make(child, ':', \"    %s\",\n\t\t\t\t\t\tmenu_get_prompt(child));\n\t\t\telse\n\t\t\t\titem_make(child, ':', \"*** %s ***\",\n\t\t\t\t\t\tmenu_get_prompt(child));\n\n\t\t\tif (child->sym == active){\n\t\t\t\tlast_top_row = top_row(curses_menu);\n\t\t\t\tselected_index = i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tshow_menu(prompt ? prompt : \"Choice Menu\",\n\t\t\t\tradiolist_instructions,\n\t\t\t\tselected_index,\n\t\t\t\t&last_top_row);\n\t\twhile (!global_exit) {\n\t\t\tif (match_state.in_search) {\n\t\t\t\tmvprintw(0, 0, \"searching: %s\",\n\t\t\t\t\t match_state.pattern);\n\t\t\t\tclrtoeol();\n\t\t\t}\n\t\t\trefresh_all_windows(main_window);\n\t\t\tres = wgetch(menu_win(curses_menu));\n\t\t\tif (!res)\n\t\t\t\tbreak;\n\t\t\tif (do_match(res, &match_state, &selected_index) == 0) {\n\t\t\t\tif (selected_index != -1)\n\t\t\t\t\tcenter_item(selected_index,\n\t\t\t\t\t\t    &last_top_row);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (process_special_keys(\n\t\t\t\t\t\t&res,\n\t\t\t\t\t\t(struct menu *) item_data()))\n\t\t\t\tbreak;\n\t\t\tswitch (res) {\n\t\t\tcase KEY_DOWN:\n\t\t\tcase 'j':\n\t\t\t\tmenu_driver(curses_menu, REQ_DOWN_ITEM);\n\t\t\t\tbreak;\n\t\t\tcase KEY_UP:\n\t\t\tcase 'k':\n\t\t\t\tmenu_driver(curses_menu, REQ_UP_ITEM);\n\t\t\t\tbreak;\n\t\t\tcase KEY_NPAGE:\n\t\t\t\tmenu_driver(curses_menu, REQ_SCR_DPAGE);\n\t\t\t\tbreak;\n\t\t\tcase KEY_PPAGE:\n\t\t\t\tmenu_driver(curses_menu, REQ_SCR_UPAGE);\n\t\t\t\tbreak;\n\t\t\tcase KEY_HOME:\n\t\t\t\tmenu_driver(curses_menu, REQ_FIRST_ITEM);\n\t\t\t\tbreak;\n\t\t\tcase KEY_END:\n\t\t\t\tmenu_driver(curses_menu, REQ_LAST_ITEM);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tshow_help((struct menu *) item_data());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res == 10 || res == 27 || res == ' ' ||\n\t\t\t\t\tres == KEY_LEFT){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trefresh_all_windows(main_window);\n\t\t}\n\t\t \n\t\tif (res == 27 || res == KEY_LEFT)\n\t\t\tbreak;\n\n\t\tchild = item_data();\n\t\tif (!child || !menu_is_visible(child) || !child->sym)\n\t\t\tcontinue;\n\t\tswitch (res) {\n\t\tcase ' ':\n\t\tcase  10:\n\t\tcase KEY_RIGHT:\n\t\t\tsym_set_tristate_value(child->sym, yes);\n\t\t\treturn;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tshow_help(child);\n\t\t\tactive = child->sym;\n\t\t\tbreak;\n\t\tcase KEY_EXIT:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void conf_string(struct menu *menu)\n{\n\tconst char *prompt = menu_get_prompt(menu);\n\n\twhile (1) {\n\t\tint res;\n\t\tconst char *heading;\n\n\t\tswitch (sym_get_type(menu->sym)) {\n\t\tcase S_INT:\n\t\t\theading = inputbox_instructions_int;\n\t\t\tbreak;\n\t\tcase S_HEX:\n\t\t\theading = inputbox_instructions_hex;\n\t\t\tbreak;\n\t\tcase S_STRING:\n\t\t\theading = inputbox_instructions_string;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\theading = \"Internal nconf error!\";\n\t\t}\n\t\tres = dialog_inputbox(main_window,\n\t\t\t\tprompt ? prompt : \"Main Menu\",\n\t\t\t\theading,\n\t\t\t\tsym_get_string_value(menu->sym),\n\t\t\t\t&dialog_input_result,\n\t\t\t\t&dialog_input_result_len);\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tif (sym_set_string_value(menu->sym,\n\t\t\t\t\t\tdialog_input_result))\n\t\t\t\treturn;\n\t\t\tbtn_dialog(main_window,\n\t\t\t\t\"You have made an invalid entry.\", 0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tshow_help(menu);\n\t\t\tbreak;\n\t\tcase KEY_EXIT:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void conf_load(void)\n{\n\twhile (1) {\n\t\tint res;\n\t\tres = dialog_inputbox(main_window,\n\t\t\t\tNULL, load_config_text,\n\t\t\t\tfilename,\n\t\t\t\t&dialog_input_result,\n\t\t\t\t&dialog_input_result_len);\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tif (!dialog_input_result[0])\n\t\t\t\treturn;\n\t\t\tif (!conf_read(dialog_input_result)) {\n\t\t\t\tset_config_filename(dialog_input_result);\n\t\t\t\tconf_set_changed(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbtn_dialog(main_window, \"File does not exist!\", 0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tshow_scroll_win(main_window,\n\t\t\t\t\t\"Load Alternate Configuration\",\n\t\t\t\t\tload_config_help);\n\t\t\tbreak;\n\t\tcase KEY_EXIT:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void conf_save(void)\n{\n\twhile (1) {\n\t\tint res;\n\t\tres = dialog_inputbox(main_window,\n\t\t\t\tNULL, save_config_text,\n\t\t\t\tfilename,\n\t\t\t\t&dialog_input_result,\n\t\t\t\t&dialog_input_result_len);\n\t\tswitch (res) {\n\t\tcase 0:\n\t\t\tif (!dialog_input_result[0])\n\t\t\t\treturn;\n\t\t\tres = conf_write(dialog_input_result);\n\t\t\tif (!res) {\n\t\t\t\tset_config_filename(dialog_input_result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbtn_dialog(main_window, \"Can't create file!\",\n\t\t\t\t1, \"<OK>\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tshow_scroll_win(main_window,\n\t\t\t\t\"Save Alternate Configuration\",\n\t\t\t\tsave_config_help);\n\t\t\tbreak;\n\t\tcase KEY_EXIT:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void setup_windows(void)\n{\n\tint lines, columns;\n\n\tgetmaxyx(stdscr, lines, columns);\n\n\tif (main_window != NULL)\n\t\tdelwin(main_window);\n\n\t \n\tmain_window = newwin(lines-2, columns-2, 2, 1);\n\tkeypad(main_window, TRUE);\n\tmwin_max_lines = lines-7;\n\tmwin_max_cols = columns-6;\n\n\t \n\tnew_panel(main_window);\n}\n\nint main(int ac, char **av)\n{\n\tint lines, columns;\n\tchar *mode;\n\n\tif (ac > 1 && strcmp(av[1], \"-s\") == 0) {\n\t\t \n\t\tconf_set_message_callback(NULL);\n\t\tav++;\n\t}\n\tconf_parse(av[1]);\n\tconf_read(NULL);\n\n\tmode = getenv(\"NCONFIG_MODE\");\n\tif (mode) {\n\t\tif (!strcasecmp(mode, \"single_menu\"))\n\t\t\tsingle_menu_mode = 1;\n\t}\n\n\t \n\tinitscr();\n\t \n\tset_colors();\n\n\tcbreak();\n\tnoecho();\n\tkeypad(stdscr, TRUE);\n\tcurs_set(0);\n\n\tgetmaxyx(stdscr, lines, columns);\n\tif (columns < 75 || lines < 20) {\n\t\tendwin();\n\t\tprintf(\"Your terminal should have at \"\n\t\t\t\"least 20 lines and 75 columns\\n\");\n\t\treturn 1;\n\t}\n\n\tnotimeout(stdscr, FALSE);\n#if NCURSES_REENTRANT\n\tset_escdelay(1);\n#else\n\tESCDELAY = 1;\n#endif\n\n\t \n\tcurses_menu = new_menu(curses_menu_items);\n\tmenu_opts_off(curses_menu, O_SHOWDESC);\n\tmenu_opts_on(curses_menu, O_SHOWMATCH);\n\tmenu_opts_on(curses_menu, O_ONEVALUE);\n\tmenu_opts_on(curses_menu, O_NONCYCLIC);\n\tmenu_opts_on(curses_menu, O_IGNORECASE);\n\tset_menu_mark(curses_menu, \" \");\n\tset_menu_fore(curses_menu, attr_main_menu_fore);\n\tset_menu_back(curses_menu, attr_main_menu_back);\n\tset_menu_grey(curses_menu, attr_main_menu_grey);\n\n\tset_config_filename(conf_get_configname());\n\tsetup_windows();\n\n\t \n\tif (has_key(KEY_F(1)) == FALSE) {\n\t\tshow_scroll_win(main_window,\n\t\t\t\t\"Instructions\",\n\t\t\t\tmenu_no_f_instructions);\n\t}\n\n\tconf_set_message_callback(conf_message_callback);\n\t \n\twhile (!global_exit) {\n\t\tconf(&rootmenu);\n\t\tif (!global_exit && do_exit() == 0)\n\t\t\tbreak;\n\t}\n\t \n\tunpost_menu(curses_menu);\n\tfree_menu(curses_menu);\n\tdelwin(main_window);\n\tclear();\n\trefresh();\n\tendwin();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}