{
  "module_name": "faddr2line",
  "hash_id": "3cb5627550a485640e94b02b7bd926963b31e281fc659349ba5e4eca9124c33f",
  "original_prompt": "Ingested from linux-6.6.14/scripts/faddr2line",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Translate stack dump function offsets.\n#\n# addr2line doesn't work with KASLR addresses.  This works similarly to\n# addr2line, but instead takes the 'func+0x123' format as input:\n#\n#   $ ./scripts/faddr2line ~/k/vmlinux meminfo_proc_show+0x5/0x568\n#   meminfo_proc_show+0x5/0x568:\n#   meminfo_proc_show at fs/proc/meminfo.c:27\n#\n# If the address is part of an inlined function, the full inline call chain is\n# printed:\n#\n#   $ ./scripts/faddr2line ~/k/vmlinux native_write_msr+0x6/0x27\n#   native_write_msr+0x6/0x27:\n#   arch_static_branch at arch/x86/include/asm/msr.h:121\n#    (inlined by) static_key_false at include/linux/jump_label.h:125\n#    (inlined by) native_write_msr at arch/x86/include/asm/msr.h:125\n#\n# The function size after the '/' in the input is optional, but recommended.\n# It's used to help disambiguate any duplicate symbol names, which can occur\n# rarely.  If the size is omitted for a duplicate symbol then it's possible for\n# multiple code sites to be printed:\n#\n#   $ ./scripts/faddr2line ~/k/vmlinux raw_ioctl+0x5\n#   raw_ioctl+0x5/0x20:\n#   raw_ioctl at drivers/char/raw.c:122\n#\n#   raw_ioctl+0x5/0xb1:\n#   raw_ioctl at net/ipv4/raw.c:876\n#\n# Multiple addresses can be specified on a single command line:\n#\n#   $ ./scripts/faddr2line ~/k/vmlinux type_show+0x10/45 free_reserved_area+0x90\n#   type_show+0x10/0x2d:\n#   type_show at drivers/video/backlight/backlight.c:213\n#\n#   free_reserved_area+0x90/0x123:\n#   free_reserved_area at mm/page_alloc.c:6429 (discriminator 2)\n\n\nset -o errexit\nset -o nounset\n\nusage() {\n\techo \"usage: faddr2line [--list] <object file> <func+offset> <func+offset>...\" >&2\n\texit 1\n}\n\nwarn() {\n\techo \"$1\" >&2\n}\n\ndie() {\n\techo \"ERROR: $1\" >&2\n\texit 1\n}\n\nREADELF=\"${CROSS_COMPILE:-}readelf\"\nADDR2LINE=\"${CROSS_COMPILE:-}addr2line\"\nAWK=\"awk\"\nGREP=\"grep\"\n\ncommand -v ${AWK} >/dev/null 2>&1 || die \"${AWK} isn't installed\"\ncommand -v ${READELF} >/dev/null 2>&1 || die \"${READELF} isn't installed\"\ncommand -v ${ADDR2LINE} >/dev/null 2>&1 || die \"${ADDR2LINE} isn't installed\"\n\n# Try to figure out the source directory prefix so we can remove it from the\n# addr2line output.  HACK ALERT: This assumes that start_kernel() is in\n# init/main.c!  This only works for vmlinux.  Otherwise it falls back to\n# printing the absolute path.\nfind_dir_prefix() {\n\tlocal objfile=$1\n\n\tlocal start_kernel_addr=$(${READELF} --symbols --wide $objfile | sed 's/\\[.*\\]//' |\n\t\t${AWK} '$8 == \"start_kernel\" {printf \"0x%s\", $2}')\n\t[[ -z $start_kernel_addr ]] && return\n\n\tlocal file_line=$(${ADDR2LINE} -e $objfile $start_kernel_addr)\n\t[[ -z $file_line ]] && return\n\n\tlocal prefix=${file_line%init/main.c:*}\n\tif [[ -z $prefix ]] || [[ $prefix = $file_line ]]; then\n\t\treturn\n\tfi\n\n\tDIR_PREFIX=$prefix\n\treturn 0\n}\n\n__faddr2line() {\n\tlocal objfile=$1\n\tlocal func_addr=$2\n\tlocal dir_prefix=$3\n\tlocal print_warnings=$4\n\n\tlocal sym_name=${func_addr%+*}\n\tlocal func_offset=${func_addr#*+}\n\tfunc_offset=${func_offset%/*}\n\tlocal user_size=\n\tlocal file_type\n\tlocal is_vmlinux=0\n\t[[ $func_addr =~ \"/\" ]] && user_size=${func_addr#*/}\n\n\tif [[ -z $sym_name ]] || [[ -z $func_offset ]] || [[ $sym_name = $func_addr ]]; then\n\t\twarn \"bad func+offset $func_addr\"\n\t\tDONE=1\n\t\treturn\n\tfi\n\n\t# vmlinux uses absolute addresses in the section table rather than\n\t# section offsets.\n\tlocal file_type=$(${READELF} --file-header $objfile |\n\t\t${AWK} '$1 == \"Type:\" { print $2; exit }')\n\tif [[ $file_type = \"EXEC\" ]] || [[ $file_type == \"DYN\" ]]; then\n\t\tis_vmlinux=1\n\tfi\n\n\t# Go through each of the object's symbols which match the func name.\n\t# In rare cases there might be duplicates, in which case we print all\n\t# matches.\n\twhile read line; do\n\t\tlocal fields=($line)\n\t\tlocal sym_addr=0x${fields[1]}\n\t\tlocal sym_elf_size=${fields[2]}\n\t\tlocal sym_sec=${fields[6]}\n\t\tlocal sec_size\n\t\tlocal sec_name\n\n\t\t# Get the section size:\n\t\tsec_size=$(${READELF} --section-headers --wide $objfile |\n\t\t\tsed 's/\\[ /\\[/' |\n\t\t\t${AWK} -v sec=$sym_sec '$1 == \"[\" sec \"]\" { print \"0x\" $6; exit }')\n\n\t\tif [[ -z $sec_size ]]; then\n\t\t\twarn \"bad section size: section: $sym_sec\"\n\t\t\tDONE=1\n\t\t\treturn\n\t\tfi\n\n\t\t# Get the section name:\n\t\tsec_name=$(${READELF} --section-headers --wide $objfile |\n\t\t\tsed 's/\\[ /\\[/' |\n\t\t\t${AWK} -v sec=$sym_sec '$1 == \"[\" sec \"]\" { print $2; exit }')\n\n\t\tif [[ -z $sec_name ]]; then\n\t\t\twarn \"bad section name: section: $sym_sec\"\n\t\t\tDONE=1\n\t\t\treturn\n\t\tfi\n\n\t\t# Calculate the symbol size.\n\t\t#\n\t\t# Unfortunately we can't use the ELF size, because kallsyms\n\t\t# also includes the padding bytes in its size calculation.  For\n\t\t# kallsyms, the size calculation is the distance between the\n\t\t# symbol and the next symbol in a sorted list.\n\t\tlocal sym_size\n\t\tlocal cur_sym_addr\n\t\tlocal found=0\n\t\twhile read line; do\n\t\t\tlocal fields=($line)\n\t\t\tcur_sym_addr=0x${fields[1]}\n\t\t\tlocal cur_sym_elf_size=${fields[2]}\n\t\t\tlocal cur_sym_name=${fields[7]:-}\n\n\t\t\tif [[ $cur_sym_addr = $sym_addr ]] &&\n\t\t\t   [[ $cur_sym_elf_size = $sym_elf_size ]] &&\n\t\t\t   [[ $cur_sym_name = $sym_name ]]; then\n\t\t\t\tfound=1\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\tif [[ $found = 1 ]]; then\n\t\t\t\tsym_size=$(($cur_sym_addr - $sym_addr))\n\t\t\t\t[[ $sym_size -lt $sym_elf_size ]] && continue;\n\t\t\t\tfound=2\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone < <(${READELF} --symbols --wide $objfile | sed 's/\\[.*\\]//' | ${AWK} -v sec=$sym_sec '$7 == sec' | sort --key=2)\n\n\t\tif [[ $found = 0 ]]; then\n\t\t\twarn \"can't find symbol: sym_name: $sym_name sym_sec: $sym_sec sym_addr: $sym_addr sym_elf_size: $sym_elf_size\"\n\t\t\tDONE=1\n\t\t\treturn\n\t\tfi\n\n\t\t# If nothing was found after the symbol, assume it's the last\n\t\t# symbol in the section.\n\t\t[[ $found = 1 ]] && sym_size=$(($sec_size - $sym_addr))\n\n\t\tif [[ -z $sym_size ]] || [[ $sym_size -le 0 ]]; then\n\t\t\twarn \"bad symbol size: sym_addr: $sym_addr cur_sym_addr: $cur_sym_addr\"\n\t\t\tDONE=1\n\t\t\treturn\n\t\tfi\n\n\t\tsym_size=0x$(printf %x $sym_size)\n\n\t\t# Calculate the address from user-supplied offset:\n\t\tlocal addr=$(($sym_addr + $func_offset))\n\t\tif [[ -z $addr ]] || [[ $addr = 0 ]]; then\n\t\t\twarn \"bad address: $sym_addr + $func_offset\"\n\t\t\tDONE=1\n\t\t\treturn\n\t\tfi\n\t\taddr=0x$(printf %x $addr)\n\n\t\t# If the user provided a size, make sure it matches the symbol's size:\n\t\tif [[ -n $user_size ]] && [[ $user_size -ne $sym_size ]]; then\n\t\t\t[[ $print_warnings = 1 ]] &&\n\t\t\t\techo \"skipping $sym_name address at $addr due to size mismatch ($user_size != $sym_size)\"\n\t\t\tcontinue;\n\t\tfi\n\n\t\t# Make sure the provided offset is within the symbol's range:\n\t\tif [[ $func_offset -gt $sym_size ]]; then\n\t\t\t[[ $print_warnings = 1 ]] &&\n\t\t\t\techo \"skipping $sym_name address at $addr due to size mismatch ($func_offset > $sym_size)\"\n\t\t\tcontinue\n\t\tfi\n\n\t\t# In case of duplicates or multiple addresses specified on the\n\t\t# cmdline, separate multiple entries with a blank line:\n\t\t[[ $FIRST = 0 ]] && echo\n\t\tFIRST=0\n\n\t\techo \"$sym_name+$func_offset/$sym_size:\"\n\n\t\t# Pass section address to addr2line and strip absolute paths\n\t\t# from the output:\n\t\tlocal args=\"--functions --pretty-print --inlines --exe=$objfile\"\n\t\t[[ $is_vmlinux = 0 ]] && args=\"$args --section=$sec_name\"\n\t\tlocal output=$(${ADDR2LINE} $args $addr | sed \"s; $dir_prefix\\(\\./\\)*; ;\")\n\t\t[[ -z $output ]] && continue\n\n\t\t# Default output (non --list):\n\t\tif [[ $LIST = 0 ]]; then\n\t\t\techo \"$output\" | while read -r line\n\t\t\tdo\n\t\t\t\techo $line\n\t\t\tdone\n\t\t\tDONE=1;\n\t\t\tcontinue\n\t\tfi\n\n\t\t# For --list, show each line with its corresponding source code:\n\t\techo \"$output\" | while read -r line\n\t\tdo\n\t\t\techo\n\t\t\techo $line\n\t\t\tn=$(echo $line | sed 's/.*:\\([0-9]\\+\\).*/\\1/g')\n\t\t\tn1=$[$n-5]\n\t\t\tn2=$[$n+5]\n\t\t\tf=$(echo $line | sed 's/.*at \\(.\\+\\):.*/\\1/g')\n\t\t\t${AWK} 'NR>=strtonum(\"'$n1'\") && NR<=strtonum(\"'$n2'\") { if (NR=='$n') printf(\">%d<\", NR); else printf(\" %d \", NR); printf(\"\\t%s\\n\", $0)}' $f\n\t\tdone\n\n\t\tDONE=1\n\n\tdone < <(${READELF} --symbols --wide $objfile | sed 's/\\[.*\\]//' | ${AWK} -v fn=$sym_name '$4 == \"FUNC\" && $8 == fn')\n}\n\n[[ $# -lt 2 ]] && usage\n\nobjfile=$1\n\nLIST=0\n[[ \"$objfile\" == \"--list\" ]] && LIST=1 && shift && objfile=$1\n\n[[ ! -f $objfile ]] && die \"can't find objfile $objfile\"\nshift\n\n${READELF} --section-headers --wide $objfile | ${GREP} -q '\\.debug_info' || die \"CONFIG_DEBUG_INFO not enabled\"\n\nDIR_PREFIX=supercalifragilisticexpialidocious\nfind_dir_prefix $objfile\n\nFIRST=1\nwhile [[ $# -gt 0 ]]; do\n\tfunc_addr=$1\n\tshift\n\n\t# print any matches found\n\tDONE=0\n\t__faddr2line $objfile $func_addr $DIR_PREFIX 0\n\n\t# if no match was found, print warnings\n\tif [[ $DONE = 0 ]]; then\n\t\t__faddr2line $objfile $func_addr $DIR_PREFIX 1\n\t\twarn \"no match for $func_addr\"\n\tfi\ndone\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}