{
  "module_name": "genheaders.c",
  "hash_id": "fad1e41107df2e9782c543c0d37883a7ea5d9df8f23c786b4ed50a093d9816fd",
  "original_prompt": "Ingested from linux-6.6.14/scripts/selinux/genheaders/genheaders.c",
  "human_readable_source": "\n\n \n#define __EXPORTED_HEADERS__\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <ctype.h>\n\nstruct security_class_mapping {\n\tconst char *name;\n\tconst char *perms[sizeof(unsigned) * 8 + 1];\n};\n\n#include \"classmap.h\"\n#include \"initial_sid_to_string.h\"\n\nconst char *progname;\n\nstatic void usage(void)\n{\n\tprintf(\"usage: %s flask.h av_permissions.h\\n\", progname);\n\texit(1);\n}\n\nstatic char *stoupperx(const char *s)\n{\n\tchar *s2 = strdup(s);\n\tchar *p;\n\n\tif (!s2) {\n\t\tfprintf(stderr, \"%s:  out of memory\\n\", progname);\n\t\texit(3);\n\t}\n\n\tfor (p = s2; *p; p++)\n\t\t*p = toupper(*p);\n\treturn s2;\n}\n\nint main(int argc, char *argv[])\n{\n\tint i, j;\n\tint isids_len;\n\tFILE *fout;\n\n\tprogname = argv[0];\n\n\tif (argc < 3)\n\t\tusage();\n\n\tfout = fopen(argv[1], \"w\");\n\tif (!fout) {\n\t\tfprintf(stderr, \"Could not open %s for writing:  %s\\n\",\n\t\t\targv[1], strerror(errno));\n\t\texit(2);\n\t}\n\n\tfprintf(fout, \"/* This file is automatically generated.  Do not edit. */\\n\");\n\tfprintf(fout, \"#ifndef _SELINUX_FLASK_H_\\n#define _SELINUX_FLASK_H_\\n\\n\");\n\n\tfor (i = 0; secclass_map[i].name; i++) {\n\t\tchar *name = stoupperx(secclass_map[i].name);\n\n\t\tfprintf(fout, \"#define SECCLASS_%-39s %2d\\n\", name, i+1);\n\t\tfree(name);\n\t}\n\n\tfprintf(fout, \"\\n\");\n\n\tisids_len = sizeof(initial_sid_to_string) / sizeof(char *);\n\tfor (i = 1; i < isids_len; i++) {\n\t\tconst char *s = initial_sid_to_string[i];\n\t\tif (s) {\n\t\t\tchar *sidname = stoupperx(s);\n\n\t\t\tfprintf(fout, \"#define SECINITSID_%-39s %2d\\n\", sidname, i);\n\t\t\tfree(sidname);\n\t\t}\n\t}\n\tfprintf(fout, \"\\n#define SECINITSID_NUM %d\\n\", i-1);\n\tfprintf(fout, \"\\nstatic inline bool security_is_socket_class(u16 kern_tclass)\\n\");\n\tfprintf(fout, \"{\\n\");\n\tfprintf(fout, \"\\tbool sock = false;\\n\\n\");\n\tfprintf(fout, \"\\tswitch (kern_tclass) {\\n\");\n\tfor (i = 0; secclass_map[i].name; i++) {\n\t\tstatic char s[] = \"SOCKET\";\n\t\tint len, l;\n\t\tchar *name = stoupperx(secclass_map[i].name);\n\n\t\tlen = strlen(name);\n\t\tl = sizeof(s) - 1;\n\t\tif (len >= l && memcmp(name + len - l, s, l) == 0)\n\t\t\tfprintf(fout, \"\\tcase SECCLASS_%s:\\n\", name);\n\t\tfree(name);\n\t}\n\tfprintf(fout, \"\\t\\tsock = true;\\n\");\n\tfprintf(fout, \"\\t\\tbreak;\\n\");\n\tfprintf(fout, \"\\tdefault:\\n\");\n\tfprintf(fout, \"\\t\\tbreak;\\n\");\n\tfprintf(fout, \"\\t}\\n\\n\");\n\tfprintf(fout, \"\\treturn sock;\\n\");\n\tfprintf(fout, \"}\\n\");\n\n\tfprintf(fout, \"\\n#endif\\n\");\n\n\tif (fclose(fout) != 0) {\n\t\tfprintf(stderr, \"Could not successfully close %s:  %s\\n\",\n\t\t\targv[1], strerror(errno));\n\t\texit(4);\n\t}\n\n\tfout = fopen(argv[2], \"w\");\n\tif (!fout) {\n\t\tfprintf(stderr, \"Could not open %s for writing:  %s\\n\",\n\t\t\targv[2], strerror(errno));\n\t\texit(5);\n\t}\n\n\tfprintf(fout, \"/* This file is automatically generated.  Do not edit. */\\n\");\n\tfprintf(fout, \"#ifndef _SELINUX_AV_PERMISSIONS_H_\\n#define _SELINUX_AV_PERMISSIONS_H_\\n\\n\");\n\n\tfor (i = 0; secclass_map[i].name; i++) {\n\t\tconst struct security_class_mapping *map = &secclass_map[i];\n\t\tint len;\n\t\tchar *name = stoupperx(map->name);\n\n\t\tlen = strlen(name);\n\t\tfor (j = 0; map->perms[j]; j++) {\n\t\t\tchar *permname;\n\n\t\t\tif (j >= 32) {\n\t\t\t\tfprintf(stderr, \"Too many permissions to fit into an access vector at (%s, %s).\\n\",\n\t\t\t\t\tmap->name, map->perms[j]);\n\t\t\t\texit(5);\n\t\t\t}\n\t\t\tpermname = stoupperx(map->perms[j]);\n\t\t\tfprintf(fout, \"#define %s__%-*s 0x%08xU\\n\", name,\n\t\t\t\t39-len, permname, 1U<<j);\n\t\t\tfree(permname);\n\t\t}\n\t\tfree(name);\n\t}\n\n\tfprintf(fout, \"\\n#endif\\n\");\n\n\tif (fclose(fout) != 0) {\n\t\tfprintf(stderr, \"Could not successfully close %s:  %s\\n\",\n\t\t\targv[2], strerror(errno));\n\t\texit(6);\n\t}\n\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}