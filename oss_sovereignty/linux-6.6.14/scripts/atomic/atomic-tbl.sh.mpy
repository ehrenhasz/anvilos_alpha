{
  "module_name": "atomic-tbl.sh",
  "hash_id": "d955345a04f40c630a2e9a7f80e6fb28de99c7ff44842210d6f854b819956367",
  "original_prompt": "Ingested from linux-6.6.14/scripts/atomic/atomic-tbl.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n# helpers for dealing with atomics.tbl\n\n#meta_in(meta, match)\nmeta_in()\n{\n\tcase \"$1\" in\n\t[$2]) return 0;;\n\tesac\n\n\treturn 1\n}\n\n#meta_has_ret(meta)\nmeta_has_ret()\n{\n\tmeta_in \"$1\" \"bBiIfFlR\"\n}\n\n#meta_has_acquire(meta)\nmeta_has_acquire()\n{\n\tmeta_in \"$1\" \"BFIlR\"\n}\n\n#meta_has_release(meta)\nmeta_has_release()\n{\n\tmeta_in \"$1\" \"BFIRs\"\n}\n\n#meta_has_relaxed(meta)\nmeta_has_relaxed()\n{\n\tmeta_in \"$1\" \"BFIR\"\n}\n\n#meta_is_implicitly_relaxed(meta)\nmeta_is_implicitly_relaxed()\n{\n\tmeta_in \"$1\" \"vls\"\n}\n\n#find_template(tmpltype, pfx, name, sfx, order)\nfind_template()\n{\n\tlocal tmpltype=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\n\tlocal base=\"\"\n\tlocal file=\"\"\n\n\t# We may have fallbacks for a specific case (e.g. read_acquire()), or\n\t# an entire class, e.g. *inc*().\n\t#\n\t# Start at the most specific, and fall back to the most general. Once\n\t# we find a specific fallback, don't bother looking for more.\n\tfor base in \"${pfx}${name}${sfx}${order}\" \"${pfx}${name}${sfx}\" \"${name}\"; do\n\t\tfile=\"${ATOMICDIR}/${tmpltype}/${base}\"\n\n\t\tif [ -f \"${file}\" ]; then\n\t\t\tprintf \"${file}\"\n\t\t\tbreak\n\t\tfi\n\tdone\n}\n\n#find_fallback_template(pfx, name, sfx, order)\nfind_fallback_template()\n{\n\tfind_template \"fallbacks\" \"$@\"\n}\n\n#find_kerneldoc_template(pfx, name, sfx, order)\nfind_kerneldoc_template()\n{\n\tfind_template \"kerneldoc\" \"$@\"\n}\n\n#gen_ret_type(meta, int)\ngen_ret_type() {\n\tlocal meta=\"$1\"; shift\n\tlocal int=\"$1\"; shift\n\n\tcase \"${meta}\" in\n\t[sv]) printf \"void\";;\n\t[bB]) printf \"bool\";;\n\t[aiIfFlR]) printf \"${int}\";;\n\tesac\n}\n\n#gen_ret_stmt(meta)\ngen_ret_stmt()\n{\n\tif meta_has_ret \"${meta}\"; then\n\t\tprintf \"return \";\n\tfi\n}\n\n# gen_param_name(arg)\ngen_param_name()\n{\n\t# strip off the leading 'c' for 'cv'\n\tlocal name=\"${1#c}\"\n\tprintf \"${name#*:}\"\n}\n\n# gen_param_type(arg, int, atomic)\ngen_param_type()\n{\n\tlocal type=\"${1%%:*}\"; shift\n\tlocal int=\"$1\"; shift\n\tlocal atomic=\"$1\"; shift\n\n\tcase \"${type}\" in\n\ti) type=\"${int} \";;\n\tp) type=\"${int} *\";;\n\tv) type=\"${atomic}_t *\";;\n\tcv) type=\"const ${atomic}_t *\";;\n\tesac\n\n\tprintf \"${type}\"\n}\n\n#gen_param(arg, int, atomic)\ngen_param()\n{\n\tlocal arg=\"$1\"; shift\n\tlocal int=\"$1\"; shift\n\tlocal atomic=\"$1\"; shift\n\tlocal name=\"$(gen_param_name \"${arg}\")\"\n\tlocal type=\"$(gen_param_type \"${arg}\" \"${int}\" \"${atomic}\")\"\n\n\tprintf \"${type}${name}\"\n}\n\n#gen_params(int, atomic, arg...)\ngen_params()\n{\n\tlocal int=\"$1\"; shift\n\tlocal atomic=\"$1\"; shift\n\n\twhile [ \"$#\" -gt 0 ]; do\n\t\tgen_param \"$1\" \"${int}\" \"${atomic}\"\n\t\t[ \"$#\" -gt 1 ] && printf \", \"\n\t\tshift;\n\tdone\n}\n\n#gen_args(arg...)\ngen_args()\n{\n\twhile [ \"$#\" -gt 0 ]; do\n\t\tprintf \"$(gen_param_name \"$1\")\"\n\t\t[ \"$#\" -gt 1 ] && printf \", \"\n\t\tshift;\n\tdone\n}\n\n#gen_desc_return(meta)\ngen_desc_return()\n{\n\tlocal meta=\"$1\"; shift\n\n\tcase \"${meta}\" in\n\t[v])\n\t\tprintf \"Return: Nothing.\"\n\t\t;;\n\t[Ff])\n\t\tprintf \"Return: The original value of @v.\"\n\t\t;;\n\t[R])\n\t\tprintf \"Return: The updated value of @v.\"\n\t\t;;\n\t[l])\n\t\tprintf \"Return: The value of @v.\"\n\t\t;;\n\tesac\n}\n\n#gen_template_kerneldoc(template, class, meta, pfx, name, sfx, order, atomic, int, args...)\ngen_template_kerneldoc()\n{\n\tlocal template=\"$1\"; shift\n\tlocal class=\"$1\"; shift\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\tlocal atomic=\"$1\"; shift\n\tlocal int=\"$1\"; shift\n\n\tlocal atomicname=\"${atomic}_${pfx}${name}${sfx}${order}\"\n\n\tlocal ret=\"$(gen_ret_type \"${meta}\" \"${int}\")\"\n\tlocal retstmt=\"$(gen_ret_stmt \"${meta}\")\"\n\tlocal params=\"$(gen_params \"${int}\" \"${atomic}\" \"$@\")\"\n\tlocal args=\"$(gen_args \"$@\")\"\n\tlocal desc_order=\"\"\n\tlocal desc_instrumentation=\"\"\n\tlocal desc_return=\"\"\n\n\tif [ ! -z \"${order}\" ]; then\n\t\tdesc_order=\"${order##_}\"\n\telif meta_is_implicitly_relaxed \"${meta}\"; then\n\t\tdesc_order=\"relaxed\"\n\telse\n\t\tdesc_order=\"full\"\n\tfi\n\n\tif [ -z \"${class}\" ]; then\n\t\tdesc_noinstr=\"Unsafe to use in noinstr code; use raw_${atomicname}() there.\"\n\telse\n\t\tdesc_noinstr=\"Safe to use in noinstr code; prefer ${atomicname}() elsewhere.\"\n\tfi\n\n\tdesc_return=\"$(gen_desc_return \"${meta}\")\"\n\n\t. ${template}\n}\n\n#gen_kerneldoc(class, meta, pfx, name, sfx, order, atomic, int, args...)\ngen_kerneldoc()\n{\n\tlocal class=\"$1\"; shift\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\n\tlocal atomicname=\"${atomic}_${pfx}${name}${sfx}${order}\"\n\n\tlocal tmpl=\"$(find_kerneldoc_template \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\")\"\n\tif [ -z \"${tmpl}\" ]; then\n\t\tprintf \"/*\\n\"\n\t\tprintf \" * No kerneldoc available for ${class}${atomicname}\\n\"\n\t\tprintf \" */\\n\"\n\telse\n\tgen_template_kerneldoc \"${tmpl}\" \"${class}\" \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\" \"$@\"\n\tfi\n}\n\n#gen_proto_order_variants(meta, pfx, name, sfx, ...)\ngen_proto_order_variants()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\n\tgen_proto_order_variant \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"\" \"$@\"\n\n\tif meta_has_acquire \"${meta}\"; then\n\t\tgen_proto_order_variant \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"_acquire\" \"$@\"\n\tfi\n\tif meta_has_release \"${meta}\"; then\n\t\tgen_proto_order_variant \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"_release\" \"$@\"\n\tfi\n\tif meta_has_relaxed \"${meta}\"; then\n\t\tgen_proto_order_variant \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"_relaxed\" \"$@\"\n\tfi\n}\n\n#gen_proto_variants(meta, name, ...)\ngen_proto_variants()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal pfx=\"\"\n\tlocal sfx=\"\"\n\n\tmeta_in \"${meta}\" \"fF\" && pfx=\"fetch_\"\n\tmeta_in \"${meta}\" \"R\" && sfx=\"_return\"\n\n\tgen_proto_order_variants \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"$@\"\n}\n\n#gen_proto(meta, ...)\ngen_proto() {\n\tlocal meta=\"$1\"; shift\n\tfor m in $(echo \"${meta}\" | grep -o .); do\n\t\tgen_proto_variants \"${m}\" \"$@\"\n\tdone\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}