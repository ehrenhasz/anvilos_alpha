{
  "module_name": "gen-atomic-instrumented.sh",
  "hash_id": "d16e84023c1050d0d5f71f389b546d913b6acd60ab47499fa5973254e1e81d78",
  "original_prompt": "Ingested from linux-6.6.14/scripts/atomic/gen-atomic-instrumented.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n\nATOMICDIR=$(dirname $0)\n\n. ${ATOMICDIR}/atomic-tbl.sh\n\n#gen_param_check(meta, arg)\ngen_param_check()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal arg=\"$1\"; shift\n\tlocal type=\"${arg%%:*}\"\n\tlocal name=\"$(gen_param_name \"${arg}\")\"\n\tlocal rw=\"write\"\n\n\tcase \"${type#c}\" in\n\ti) return;;\n\tesac\n\n\tif [ ${type#c} != ${type} ]; then\n\t\t# We don't write to constant parameters.\n\t\trw=\"read\"\n\telif [ \"${meta}\" != \"s\" ]; then\n\t\t# An atomic RMW: if this parameter is not a constant, and this atomic is\n\t\t# not just a 's'tore, this parameter is both read from and written to.\n\t\trw=\"read_write\"\n\tfi\n\n\tprintf \"\\tinstrument_atomic_${rw}(${name}, sizeof(*${name}));\\n\"\n}\n\n#gen_params_checks(meta, arg...)\ngen_params_checks()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\n\tif [ \"${order}\" = \"_release\" ]; then\n\t\tprintf \"\\tkcsan_release();\\n\"\n\telif [ -z \"${order}\" ] && ! meta_in \"$meta\" \"slv\"; then\n\t\t# RMW with return value is fully ordered\n\t\tprintf \"\\tkcsan_mb();\\n\"\n\tfi\n\n\twhile [ \"$#\" -gt 0 ]; do\n\t\tgen_param_check \"$meta\" \"$1\"\n\t\tshift;\n\tdone\n}\n\n#gen_proto_order_variant(meta, pfx, name, sfx, order, atomic, int, arg...)\ngen_proto_order_variant()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\tlocal atomic=\"$1\"; shift\n\tlocal int=\"$1\"; shift\n\n\tlocal atomicname=\"${atomic}_${pfx}${name}${sfx}${order}\"\n\n\tlocal ret=\"$(gen_ret_type \"${meta}\" \"${int}\")\"\n\tlocal params=\"$(gen_params \"${int}\" \"${atomic}\" \"$@\")\"\n\tlocal checks=\"$(gen_params_checks \"${meta}\" \"${order}\" \"$@\")\"\n\tlocal args=\"$(gen_args \"$@\")\"\n\tlocal retstmt=\"$(gen_ret_stmt \"${meta}\")\"\n\n\tgen_kerneldoc \"\" \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\" \"${atomic}\" \"${int}\" \"$@\"\n\ncat <<EOF\nstatic __always_inline ${ret}\n${atomicname}(${params})\n{\n${checks}\n\t${retstmt}raw_${atomicname}(${args});\n}\nEOF\n\n\tprintf \"\\n\"\n}\n\ngen_xchg()\n{\n\tlocal xchg=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\n\tkcsan_barrier=\"\"\n\tif [ \"${xchg%_local}\" = \"${xchg}\" ]; then\n\t\tcase \"$order\" in\n\t\t_release)\tkcsan_barrier=\"kcsan_release()\" ;;\n\t\t\"\")\t\t\tkcsan_barrier=\"kcsan_mb()\" ;;\n\t\tesac\n\tfi\n\n\tif [ \"${xchg%${xchg#try_cmpxchg}}\" = \"try_cmpxchg\" ] ; then\n\ncat <<EOF\n#define ${xchg}${order}(ptr, oldp, ...) \\\\\n({ \\\\\n\ttypeof(ptr) __ai_ptr = (ptr); \\\\\n\ttypeof(oldp) __ai_oldp = (oldp); \\\\\nEOF\n[ -n \"$kcsan_barrier\" ] && printf \"\\t${kcsan_barrier}; \\\\\\\\\\n\"\ncat <<EOF\n\tinstrument_atomic_read_write(__ai_ptr, sizeof(*__ai_ptr)); \\\\\n\tinstrument_read_write(__ai_oldp, sizeof(*__ai_oldp)); \\\\\n\traw_${xchg}${order}(__ai_ptr, __ai_oldp, __VA_ARGS__); \\\\\n})\nEOF\n\n\telse\n\ncat <<EOF\n#define ${xchg}${order}(ptr, ...) \\\\\n({ \\\\\n\ttypeof(ptr) __ai_ptr = (ptr); \\\\\nEOF\n[ -n \"$kcsan_barrier\" ] && printf \"\\t${kcsan_barrier}; \\\\\\\\\\n\"\ncat <<EOF\n\tinstrument_atomic_read_write(__ai_ptr, sizeof(*__ai_ptr)); \\\\\n\traw_${xchg}${order}(__ai_ptr, __VA_ARGS__); \\\\\n})\nEOF\n\n\tfi\n}\n\ncat << EOF\n// SPDX-License-Identifier: GPL-2.0\n\n// Generated by $0\n// DO NOT MODIFY THIS FILE DIRECTLY\n\n/*\n * This file provoides atomic operations with explicit instrumentation (e.g.\n * KASAN, KCSAN), which should be used unless it is necessary to avoid\n * instrumentation. Where it is necessary to aovid instrumenation, the\n * raw_atomic*() operations should be used.\n */\n#ifndef _LINUX_ATOMIC_INSTRUMENTED_H\n#define _LINUX_ATOMIC_INSTRUMENTED_H\n\n#include <linux/build_bug.h>\n#include <linux/compiler.h>\n#include <linux/instrumented.h>\n\nEOF\n\ngrep '^[a-z]' \"$1\" | while read name meta args; do\n\tgen_proto \"${meta}\" \"${name}\" \"atomic\" \"int\" ${args}\ndone\n\ngrep '^[a-z]' \"$1\" | while read name meta args; do\n\tgen_proto \"${meta}\" \"${name}\" \"atomic64\" \"s64\" ${args}\ndone\n\ngrep '^[a-z]' \"$1\" | while read name meta args; do\n\tgen_proto \"${meta}\" \"${name}\" \"atomic_long\" \"long\" ${args}\ndone\n\n\nfor xchg in \"xchg\" \"cmpxchg\" \"cmpxchg64\" \"cmpxchg128\" \"try_cmpxchg\" \"try_cmpxchg64\" \"try_cmpxchg128\"; do\n\tfor order in \"\" \"_acquire\" \"_release\" \"_relaxed\"; do\n\t\tgen_xchg \"${xchg}\" \"${order}\"\n\t\tprintf \"\\n\"\n\tdone\ndone\n\nfor xchg in \"cmpxchg_local\" \"cmpxchg64_local\" \"cmpxchg128_local\" \"sync_cmpxchg\" \"try_cmpxchg_local\" \"try_cmpxchg64_local\" \"try_cmpxchg128_local\"; do\n\tgen_xchg \"${xchg}\" \"\"\n\tprintf \"\\n\"\ndone\n\ncat <<EOF\n\n#endif /* _LINUX_ATOMIC_INSTRUMENTED_H */\nEOF\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}