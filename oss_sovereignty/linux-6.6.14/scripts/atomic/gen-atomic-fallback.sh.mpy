{
  "module_name": "gen-atomic-fallback.sh",
  "hash_id": "0bcaec4b23b2872d67ad7bd1b6d0089198a11693de2b81dfa32c51202e010702",
  "original_prompt": "Ingested from linux-6.6.14/scripts/atomic/gen-atomic-fallback.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n\nATOMICDIR=$(dirname $0)\n\n. ${ATOMICDIR}/atomic-tbl.sh\n\n#gen_template_fallback(template, meta, pfx, name, sfx, order, atomic, int, args...)\ngen_template_fallback()\n{\n\tlocal template=\"$1\"; shift\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\tlocal atomic=\"$1\"; shift\n\tlocal int=\"$1\"; shift\n\n\tlocal ret=\"$(gen_ret_type \"${meta}\" \"${int}\")\"\n\tlocal retstmt=\"$(gen_ret_stmt \"${meta}\")\"\n\tlocal params=\"$(gen_params \"${int}\" \"${atomic}\" \"$@\")\"\n\tlocal args=\"$(gen_args \"$@\")\"\n\n\t. ${template}\n}\n\n#gen_order_fallback(meta, pfx, name, sfx, order, atomic, int, args...)\ngen_order_fallback()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\n\tlocal tmpl_order=${order#_}\n\tlocal tmpl=\"${ATOMICDIR}/fallbacks/${tmpl_order:-fence}\"\n\tgen_template_fallback \"${tmpl}\" \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\" \"$@\"\n}\n\n#gen_proto_fallback(meta, pfx, name, sfx, order, atomic, int, args...)\ngen_proto_fallback()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\n\tlocal tmpl=\"$(find_fallback_template \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\")\"\n\tgen_template_fallback \"${tmpl}\" \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\" \"$@\"\n}\n\n#gen_proto_order_variant(meta, pfx, name, sfx, order, atomic, int, args...)\ngen_proto_order_variant()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\tlocal atomic=\"$1\"; shift\n\tlocal int=\"$1\"; shift\n\n\tlocal atomicname=\"${atomic}_${pfx}${name}${sfx}${order}\"\n\tlocal basename=\"${atomic}_${pfx}${name}${sfx}\"\n\n\tlocal template=\"$(find_fallback_template \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\")\"\n\n\tlocal ret=\"$(gen_ret_type \"${meta}\" \"${int}\")\"\n\tlocal retstmt=\"$(gen_ret_stmt \"${meta}\")\"\n\tlocal params=\"$(gen_params \"${int}\" \"${atomic}\" \"$@\")\"\n\tlocal args=\"$(gen_args \"$@\")\"\n\n\tgen_kerneldoc \"raw_\" \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\" \"${atomic}\" \"${int}\" \"$@\"\n\n\tprintf \"static __always_inline ${ret}\\n\"\n\tprintf \"raw_${atomicname}(${params})\\n\"\n\tprintf \"{\\n\"\n\n\t# Where there is no possible fallback, this order variant is mandatory\n\t# and must be provided by arch code. Add a comment to the header to\n\t# make this obvious.\n\t#\n\t# Ideally we'd error on a missing definition, but arch code might\n\t# define this order variant as a C function without a preprocessor\n\t# symbol.\n\tif [ -z ${template} ] && [ -z \"${order}\" ] && ! meta_has_relaxed \"${meta}\"; then\n\t\tprintf \"\\t${retstmt}arch_${atomicname}(${args});\\n\"\n\t\tprintf \"}\\n\\n\"\n\t\treturn\n\tfi\n\n\tprintf \"#if defined(arch_${atomicname})\\n\"\n\tprintf \"\\t${retstmt}arch_${atomicname}(${args});\\n\"\n\n\t# Allow FULL/ACQUIRE/RELEASE ops to be defined in terms of RELAXED ops\n\tif [ \"${order}\" != \"_relaxed\" ] && meta_has_relaxed \"${meta}\"; then\n\t\tprintf \"#elif defined(arch_${basename}_relaxed)\\n\"\n\t\tgen_order_fallback \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\" \"${atomic}\" \"${int}\" \"$@\"\n\tfi\n\n\t# Allow ACQUIRE/RELEASE/RELAXED ops to be defined in terms of FULL ops\n\tif [ ! -z \"${order}\" ] && ! meta_is_implicitly_relaxed \"${meta}\"; then\n\t\tprintf \"#elif defined(arch_${basename})\\n\"\n\t\tprintf \"\\t${retstmt}arch_${basename}(${args});\\n\"\n\tfi\n\n\tprintf \"#else\\n\"\n\tif [ ! -z \"${template}\" ]; then\n\t\tgen_proto_fallback \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"${order}\" \"${atomic}\" \"${int}\" \"$@\"\n\telse\n\t\tprintf \"#error \\\"Unable to define raw_${atomicname}\\\"\\n\"\n\tfi\n\n\tprintf \"#endif\\n\"\n\tprintf \"}\\n\\n\"\n}\n\n\n#gen_proto_order_variants(meta, pfx, name, sfx, atomic, int, args...)\ngen_proto_order_variants()\n{\n\tlocal meta=\"$1\"; shift\n\tlocal pfx=\"$1\"; shift\n\tlocal name=\"$1\"; shift\n\tlocal sfx=\"$1\"; shift\n\tlocal atomic=\"$1\"\n\n\tgen_proto_order_variant \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"\" \"$@\"\n\n\tif meta_has_acquire \"${meta}\"; then\n\t\tgen_proto_order_variant \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"_acquire\" \"$@\"\n\tfi\n\n\tif meta_has_release \"${meta}\"; then\n\t\tgen_proto_order_variant \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"_release\" \"$@\"\n\tfi\n\n\tif meta_has_relaxed \"${meta}\"; then\n\t\tgen_proto_order_variant \"${meta}\" \"${pfx}\" \"${name}\" \"${sfx}\" \"_relaxed\" \"$@\"\n\tfi\n}\n\n#gen_basic_fallbacks(basename)\ngen_basic_fallbacks()\n{\n\tlocal basename=\"$1\"; shift\ncat << EOF\n#define raw_${basename}_acquire arch_${basename}\n#define raw_${basename}_release arch_${basename}\n#define raw_${basename}_relaxed arch_${basename}\nEOF\n}\n\ngen_order_fallbacks()\n{\n\tlocal xchg=\"$1\"; shift\n\ncat <<EOF\n\n#define raw_${xchg}_relaxed arch_${xchg}_relaxed\n\n#ifdef arch_${xchg}_acquire\n#define raw_${xchg}_acquire arch_${xchg}_acquire\n#else\n#define raw_${xchg}_acquire(...) \\\\\n\t__atomic_op_acquire(arch_${xchg}, __VA_ARGS__)\n#endif\n\n#ifdef arch_${xchg}_release\n#define raw_${xchg}_release arch_${xchg}_release\n#else\n#define raw_${xchg}_release(...) \\\\\n\t__atomic_op_release(arch_${xchg}, __VA_ARGS__)\n#endif\n\n#ifdef arch_${xchg}\n#define raw_${xchg} arch_${xchg}\n#else\n#define raw_${xchg}(...) \\\\\n\t__atomic_op_fence(arch_${xchg}, __VA_ARGS__)\n#endif\n\nEOF\n}\n\ngen_xchg_order_fallback()\n{\n\tlocal xchg=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\tlocal forder=\"${order:-_fence}\"\n\n\tprintf \"#if defined(arch_${xchg}${order})\\n\"\n\tprintf \"#define raw_${xchg}${order} arch_${xchg}${order}\\n\"\n\n\tif [ \"${order}\" != \"_relaxed\" ]; then\n\t\tprintf \"#elif defined(arch_${xchg}_relaxed)\\n\"\n\t\tprintf \"#define raw_${xchg}${order}(...) \\\\\\\\\\n\"\n\t\tprintf \"\t__atomic_op${forder}(arch_${xchg}, __VA_ARGS__)\\n\"\n\tfi\n\n\tif [ ! -z \"${order}\" ]; then\n\t\tprintf \"#elif defined(arch_${xchg})\\n\"\n\t\tprintf \"#define raw_${xchg}${order} arch_${xchg}\\n\"\n\tfi\n\n\tprintf \"#else\\n\"\n\tprintf \"extern void raw_${xchg}${order}_not_implemented(void);\\n\"\n\tprintf \"#define raw_${xchg}${order}(...) raw_${xchg}${order}_not_implemented()\\n\"\n\tprintf \"#endif\\n\\n\"\n}\n\ngen_xchg_fallbacks()\n{\n\tlocal xchg=\"$1\"; shift\n\n\tfor order in \"\" \"_acquire\" \"_release\" \"_relaxed\"; do\n\t\tgen_xchg_order_fallback \"${xchg}\" \"${order}\"\n\tdone\n}\n\ngen_try_cmpxchg_fallback()\n{\n\tlocal cmpxchg=\"$1\"; shift;\n\tlocal order=\"$1\"; shift;\n\ncat <<EOF\n#define raw_try_${cmpxchg}${order}(_ptr, _oldp, _new) \\\\\n({ \\\\\n\ttypeof(*(_ptr)) *___op = (_oldp), ___o = *___op, ___r; \\\\\n\t___r = raw_${cmpxchg}${order}((_ptr), ___o, (_new)); \\\\\n\tif (unlikely(___r != ___o)) \\\\\n\t\t*___op = ___r; \\\\\n\tlikely(___r == ___o); \\\\\n})\nEOF\n}\n\ngen_try_cmpxchg_order_fallback()\n{\n\tlocal cmpxchg=\"$1\"; shift\n\tlocal order=\"$1\"; shift\n\tlocal forder=\"${order:-_fence}\"\n\n\tprintf \"#if defined(arch_try_${cmpxchg}${order})\\n\"\n\tprintf \"#define raw_try_${cmpxchg}${order} arch_try_${cmpxchg}${order}\\n\"\n\n\tif [ \"${order}\" != \"_relaxed\" ]; then\n\t\tprintf \"#elif defined(arch_try_${cmpxchg}_relaxed)\\n\"\n\t\tprintf \"#define raw_try_${cmpxchg}${order}(...) \\\\\\\\\\n\"\n\t\tprintf \"\t__atomic_op${forder}(arch_try_${cmpxchg}, __VA_ARGS__)\\n\"\n\tfi\n\n\tif [ ! -z \"${order}\" ]; then\n\t\tprintf \"#elif defined(arch_try_${cmpxchg})\\n\"\n\t\tprintf \"#define raw_try_${cmpxchg}${order} arch_try_${cmpxchg}\\n\"\n\tfi\n\n\tprintf \"#else\\n\"\n\tgen_try_cmpxchg_fallback \"${cmpxchg}\" \"${order}\"\n\tprintf \"#endif\\n\\n\"\n}\n\ngen_try_cmpxchg_fallbacks()\n{\n\tlocal cmpxchg=\"$1\"; shift;\n\n\tfor order in \"\" \"_acquire\" \"_release\" \"_relaxed\"; do\n\t\tgen_try_cmpxchg_order_fallback \"${cmpxchg}\" \"${order}\"\n\tdone\n}\n\ngen_cmpxchg_local_fallbacks()\n{\n\tlocal cmpxchg=\"$1\"; shift\n\n\tprintf \"#define raw_${cmpxchg} arch_${cmpxchg}\\n\\n\"\n\tprintf \"#ifdef arch_try_${cmpxchg}\\n\"\n\tprintf \"#define raw_try_${cmpxchg} arch_try_${cmpxchg}\\n\"\n\tprintf \"#else\\n\"\n\tgen_try_cmpxchg_fallback \"${cmpxchg}\" \"\"\n\tprintf \"#endif\\n\\n\"\n}\n\ncat << EOF\n// SPDX-License-Identifier: GPL-2.0\n\n// Generated by $0\n// DO NOT MODIFY THIS FILE DIRECTLY\n\n#ifndef _LINUX_ATOMIC_FALLBACK_H\n#define _LINUX_ATOMIC_FALLBACK_H\n\n#include <linux/compiler.h>\n\nEOF\n\nfor xchg in \"xchg\" \"cmpxchg\" \"cmpxchg64\" \"cmpxchg128\"; do\n\tgen_xchg_fallbacks \"${xchg}\"\ndone\n\nfor cmpxchg in \"cmpxchg\" \"cmpxchg64\" \"cmpxchg128\"; do\n\tgen_try_cmpxchg_fallbacks \"${cmpxchg}\"\ndone\n\nfor cmpxchg in \"cmpxchg_local\" \"cmpxchg64_local\" \"cmpxchg128_local\"; do\n\tgen_cmpxchg_local_fallbacks \"${cmpxchg}\" \"\"\ndone\n\nfor cmpxchg in \"sync_cmpxchg\"; do\n\tprintf \"#define raw_${cmpxchg} arch_${cmpxchg}\\n\\n\"\ndone\n\ngrep '^[a-z]' \"$1\" | while read name meta args; do\n\tgen_proto \"${meta}\" \"${name}\" \"atomic\" \"int\" ${args}\ndone\n\ncat <<EOF\n#ifdef CONFIG_GENERIC_ATOMIC64\n#include <asm-generic/atomic64.h>\n#endif\n\nEOF\n\ngrep '^[a-z]' \"$1\" | while read name meta args; do\n\tgen_proto \"${meta}\" \"${name}\" \"atomic64\" \"s64\" ${args}\ndone\n\ncat <<EOF\n#endif /* _LINUX_ATOMIC_FALLBACK_H */\nEOF\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}