{
  "module_name": "checkkconfigsymbols.py",
  "hash_id": "9e22f1e9389cf589c7a9b1cee9da487c75b9c6be3a5ffa31c8be65a0fd1737a3",
  "original_prompt": "Ingested from linux-6.6.14/scripts/checkkconfigsymbols.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n\n\"\"\"Find Kconfig symbols that are referenced but not defined.\"\"\"\n\n# (c) 2014-2017 Valentin Rothberg <valentinrothberg@gmail.com>\n# (c) 2014 Stefan Hengelein <stefan.hengelein@fau.de>\n#\n\n\nimport argparse\nimport difflib\nimport os\nimport re\nimport signal\nimport subprocess\nimport sys\nfrom multiprocessing import Pool, cpu_count\n\n\n# regex expressions\nOPERATORS = r\"&|\\(|\\)|\\||\\!\"\nSYMBOL = r\"(?:\\w*[A-Z0-9]\\w*){2,}\"\nDEF = r\"^\\s*(?:menu){,1}config\\s+(\" + SYMBOL + r\")\\s*\"\nEXPR = r\"(?:\" + OPERATORS + r\"|\\s|\" + SYMBOL + r\")+\"\nDEFAULT = r\"default\\s+.*?(?:if\\s.+){,1}\"\nSTMT = r\"^\\s*(?:if|select|imply|depends\\s+on|(?:\" + DEFAULT + r\"))\\s+\" + EXPR\nSOURCE_SYMBOL = r\"(?:\\W|\\b)+[D]{,1}CONFIG_(\" + SYMBOL + r\")\"\n\n# regex objects\nREGEX_FILE_KCONFIG = re.compile(r\".*Kconfig[\\.\\w+\\-]*$\")\nREGEX_SYMBOL = re.compile(r'(?!\\B)' + SYMBOL + r'(?!\\B)')\nREGEX_SOURCE_SYMBOL = re.compile(SOURCE_SYMBOL)\nREGEX_KCONFIG_DEF = re.compile(DEF)\nREGEX_KCONFIG_EXPR = re.compile(EXPR)\nREGEX_KCONFIG_STMT = re.compile(STMT)\nREGEX_FILTER_SYMBOLS = re.compile(r\"[A-Za-z0-9]$\")\nREGEX_NUMERIC = re.compile(r\"0[xX][0-9a-fA-F]+|[0-9]+\")\nREGEX_QUOTES = re.compile(\"(\\\"(.*?)\\\")\")\n\n\ndef parse_options():\n    \"\"\"The user interface of this module.\"\"\"\n    usage = \"Run this tool to detect Kconfig symbols that are referenced but \" \\\n            \"not defined in Kconfig.  If no option is specified, \"             \\\n            \"checkkconfigsymbols defaults to check your current tree.  \"       \\\n            \"Please note that specifying commits will 'git reset --hard\\' \"    \\\n            \"your current tree!  You may save uncommitted changes to avoid \"   \\\n            \"losing data.\"\n\n    parser = argparse.ArgumentParser(description=usage)\n\n    parser.add_argument('-c', '--commit', dest='commit', action='store',\n                        default=\"\",\n                        help=\"check if the specified commit (hash) introduces \"\n                             \"undefined Kconfig symbols\")\n\n    parser.add_argument('-d', '--diff', dest='diff', action='store',\n                        default=\"\",\n                        help=\"diff undefined symbols between two commits \"\n                             \"(e.g., -d commmit1..commit2)\")\n\n    parser.add_argument('-f', '--find', dest='find', action='store_true',\n                        default=False,\n                        help=\"find and show commits that may cause symbols to be \"\n                             \"missing (required to run with --diff)\")\n\n    parser.add_argument('-i', '--ignore', dest='ignore', action='store',\n                        default=\"\",\n                        help=\"ignore files matching this Python regex \"\n                             \"(e.g., -i '.*defconfig')\")\n\n    parser.add_argument('-s', '--sim', dest='sim', action='store', default=\"\",\n                        help=\"print a list of max. 10 string-similar symbols\")\n\n    parser.add_argument('--force', dest='force', action='store_true',\n                        default=False,\n                        help=\"reset current Git tree even when it's dirty\")\n\n    parser.add_argument('--no-color', dest='color', action='store_false',\n                        default=True,\n                        help=\"don't print colored output (default when not \"\n                             \"outputting to a terminal)\")\n\n    args = parser.parse_args()\n\n    if args.commit and args.diff:\n        sys.exit(\"Please specify only one option at once.\")\n\n    if args.diff and not re.match(r\"^[\\w\\-\\.\\^]+\\.\\.[\\w\\-\\.\\^]+$\", args.diff):\n        sys.exit(\"Please specify valid input in the following format: \"\n                 \"\\'commit1..commit2\\'\")\n\n    if args.commit or args.diff:\n        if not args.force and tree_is_dirty():\n            sys.exit(\"The current Git tree is dirty (see 'git status').  \"\n                     \"Running this script may\\ndelete important data since it \"\n                     \"calls 'git reset --hard' for some performance\\nreasons. \"\n                     \" Please run this script in a clean Git tree or pass \"\n                     \"'--force' if you\\nwant to ignore this warning and \"\n                     \"continue.\")\n\n    if args.commit:\n        if args.commit.startswith('HEAD'):\n            sys.exit(\"The --commit option can't use the HEAD ref\")\n\n        args.find = False\n\n    if args.ignore:\n        try:\n            re.match(args.ignore, \"this/is/just/a/test.c\")\n        except:\n            sys.exit(\"Please specify a valid Python regex.\")\n\n    return args\n\n\ndef print_undefined_symbols():\n    \"\"\"Main function of this module.\"\"\"\n    args = parse_options()\n\n    global COLOR\n    COLOR = args.color and sys.stdout.isatty()\n\n    if args.sim and not args.commit and not args.diff:\n        sims = find_sims(args.sim, args.ignore)\n        if sims:\n            print(\"%s: %s\" % (yel(\"Similar symbols\"), ', '.join(sims)))\n        else:\n            print(\"%s: no similar symbols found\" % yel(\"Similar symbols\"))\n        sys.exit(0)\n\n    # dictionary of (un)defined symbols\n    defined = {}\n    undefined = {}\n\n    if args.commit or args.diff:\n        head = get_head()\n\n        # get commit range\n        commit_a = None\n        commit_b = None\n        if args.commit:\n            commit_a = args.commit + \"~\"\n            commit_b = args.commit\n        elif args.diff:\n            split = args.diff.split(\"..\")\n            commit_a = split[0]\n            commit_b = split[1]\n            undefined_a = {}\n            undefined_b = {}\n\n        # get undefined items before the commit\n        reset(commit_a)\n        undefined_a, _ = check_symbols(args.ignore)\n\n        # get undefined items for the commit\n        reset(commit_b)\n        undefined_b, defined = check_symbols(args.ignore)\n\n        # report cases that are present for the commit but not before\n        for symbol in sorted(undefined_b):\n            # symbol has not been undefined before\n            if symbol not in undefined_a:\n                files = sorted(undefined_b.get(symbol))\n                undefined[symbol] = files\n            # check if there are new files that reference the undefined symbol\n            else:\n                files = sorted(undefined_b.get(symbol) -\n                               undefined_a.get(symbol))\n                if files:\n                    undefined[symbol] = files\n\n        # reset to head\n        reset(head)\n\n    # default to check the entire tree\n    else:\n        undefined, defined = check_symbols(args.ignore)\n\n    # now print the output\n    for symbol in sorted(undefined):\n        print(red(symbol))\n\n        files = sorted(undefined.get(symbol))\n        print(\"%s: %s\" % (yel(\"Referencing files\"), \", \".join(files)))\n\n        sims = find_sims(symbol, args.ignore, defined)\n        sims_out = yel(\"Similar symbols\")\n        if sims:\n            print(\"%s: %s\" % (sims_out, ', '.join(sims)))\n        else:\n            print(\"%s: %s\" % (sims_out, \"no similar symbols found\"))\n\n        if args.find:\n            print(\"%s:\" % yel(\"Commits changing symbol\"))\n            commits = find_commits(symbol, args.diff)\n            if commits:\n                for commit in commits:\n                    commit = commit.split(\" \", 1)\n                    print(\"\\t- %s (\\\"%s\\\")\" % (yel(commit[0]), commit[1]))\n            else:\n                print(\"\\t- no commit found\")\n        print()  # new line\n\n\ndef reset(commit):\n    \"\"\"Reset current git tree to %commit.\"\"\"\n    execute([\"git\", \"reset\", \"--hard\", commit])\n\n\ndef yel(string):\n    \"\"\"\n    Color %string yellow.\n    \"\"\"\n    return \"\\033[33m%s\\033[0m\" % string if COLOR else string\n\n\ndef red(string):\n    \"\"\"\n    Color %string red.\n    \"\"\"\n    return \"\\033[31m%s\\033[0m\" % string if COLOR else string\n\n\ndef execute(cmd):\n    \"\"\"Execute %cmd and return stdout.  Exit in case of error.\"\"\"\n    try:\n        stdout = subprocess.check_output(cmd, stderr=subprocess.STDOUT, shell=False)\n        stdout = stdout.decode(errors='replace')\n    except subprocess.CalledProcessError as fail:\n        exit(fail)\n    return stdout\n\n\ndef find_commits(symbol, diff):\n    \"\"\"Find commits changing %symbol in the given range of %diff.\"\"\"\n    commits = execute([\"git\", \"log\", \"--pretty=oneline\",\n                       \"--abbrev-commit\", \"-G\",\n                       symbol, diff])\n    return [x for x in commits.split(\"\\n\") if x]\n\n\ndef tree_is_dirty():\n    \"\"\"Return true if the current working tree is dirty (i.e., if any file has\n    been added, deleted, modified, renamed or copied but not committed).\"\"\"\n    stdout = execute([\"git\", \"status\", \"--porcelain\"])\n    for line in stdout:\n        if re.findall(r\"[URMADC]{1}\", line[:2]):\n            return True\n    return False\n\n\ndef get_head():\n    \"\"\"Return commit hash of current HEAD.\"\"\"\n    stdout = execute([\"git\", \"rev-parse\", \"HEAD\"])\n    return stdout.strip('\\n')\n\n\ndef partition(lst, size):\n    \"\"\"Partition list @lst into eveni-sized lists of size @size.\"\"\"\n    return [lst[i::size] for i in range(size)]\n\n\ndef init_worker():\n    \"\"\"Set signal handler to ignore SIGINT.\"\"\"\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n\ndef find_sims(symbol, ignore, defined=[]):\n    \"\"\"Return a list of max. ten Kconfig symbols that are string-similar to\n    @symbol.\"\"\"\n    if defined:\n        return difflib.get_close_matches(symbol, set(defined), 10)\n\n    pool = Pool(cpu_count(), init_worker)\n    kfiles = []\n    for gitfile in get_files():\n        if REGEX_FILE_KCONFIG.match(gitfile):\n            kfiles.append(gitfile)\n\n    arglist = []\n    for part in partition(kfiles, cpu_count()):\n        arglist.append((part, ignore))\n\n    for res in pool.map(parse_kconfig_files, arglist):\n        defined.extend(res[0])\n\n    return difflib.get_close_matches(symbol, set(defined), 10)\n\n\ndef get_files():\n    \"\"\"Return a list of all files in the current git directory.\"\"\"\n    # use 'git ls-files' to get the worklist\n    stdout = execute([\"git\", \"ls-files\"])\n    if len(stdout) > 0 and stdout[-1] == \"\\n\":\n        stdout = stdout[:-1]\n\n    files = []\n    for gitfile in stdout.rsplit(\"\\n\"):\n        if \".git\" in gitfile or \"ChangeLog\" in gitfile or      \\\n                \".log\" in gitfile or os.path.isdir(gitfile) or \\\n                gitfile.startswith(\"tools/\"):\n            continue\n        files.append(gitfile)\n    return files\n\n\ndef check_symbols(ignore):\n    \"\"\"Find undefined Kconfig symbols and return a dict with the symbol as key\n    and a list of referencing files as value.  Files matching %ignore are not\n    checked for undefined symbols.\"\"\"\n    pool = Pool(cpu_count(), init_worker)\n    try:\n        return check_symbols_helper(pool, ignore)\n    except KeyboardInterrupt:\n        pool.terminate()\n        pool.join()\n        sys.exit(1)\n\n\ndef check_symbols_helper(pool, ignore):\n    \"\"\"Helper method for check_symbols().  Used to catch keyboard interrupts in\n    check_symbols() in order to properly terminate running worker processes.\"\"\"\n    source_files = []\n    kconfig_files = []\n    defined_symbols = []\n    referenced_symbols = dict()  # {file: [symbols]}\n\n    for gitfile in get_files():\n        if REGEX_FILE_KCONFIG.match(gitfile):\n            kconfig_files.append(gitfile)\n        else:\n            if ignore and re.match(ignore, gitfile):\n                continue\n            # add source files that do not match the ignore pattern\n            source_files.append(gitfile)\n\n    # parse source files\n    arglist = partition(source_files, cpu_count())\n    for res in pool.map(parse_source_files, arglist):\n        referenced_symbols.update(res)\n\n    # parse kconfig files\n    arglist = []\n    for part in partition(kconfig_files, cpu_count()):\n        arglist.append((part, ignore))\n    for res in pool.map(parse_kconfig_files, arglist):\n        defined_symbols.extend(res[0])\n        referenced_symbols.update(res[1])\n    defined_symbols = set(defined_symbols)\n\n    # inverse mapping of referenced_symbols to dict(symbol: [files])\n    inv_map = dict()\n    for _file, symbols in referenced_symbols.items():\n        for symbol in symbols:\n            inv_map[symbol] = inv_map.get(symbol, set())\n            inv_map[symbol].add(_file)\n    referenced_symbols = inv_map\n\n    undefined = {}  # {symbol: [files]}\n    for symbol in sorted(referenced_symbols):\n        # filter some false positives\n        if symbol == \"FOO\" or symbol == \"BAR\" or \\\n                symbol == \"FOO_BAR\" or symbol == \"XXX\":\n            continue\n        if symbol not in defined_symbols:\n            if symbol.endswith(\"_MODULE\"):\n                # avoid false positives for kernel modules\n                if symbol[:-len(\"_MODULE\")] in defined_symbols:\n                    continue\n            undefined[symbol] = referenced_symbols.get(symbol)\n    return undefined, defined_symbols\n\n\ndef parse_source_files(source_files):\n    \"\"\"Parse each source file in @source_files and return dictionary with source\n    files as keys and lists of references Kconfig symbols as values.\"\"\"\n    referenced_symbols = dict()\n    for sfile in source_files:\n        referenced_symbols[sfile] = parse_source_file(sfile)\n    return referenced_symbols\n\n\ndef parse_source_file(sfile):\n    \"\"\"Parse @sfile and return a list of referenced Kconfig symbols.\"\"\"\n    lines = []\n    references = []\n\n    if not os.path.exists(sfile):\n        return references\n\n    with open(sfile, \"r\", encoding='utf-8', errors='replace') as stream:\n        lines = stream.readlines()\n\n    for line in lines:\n        if \"CONFIG_\" not in line:\n            continue\n        symbols = REGEX_SOURCE_SYMBOL.findall(line)\n        for symbol in symbols:\n            if not REGEX_FILTER_SYMBOLS.search(symbol):\n                continue\n            references.append(symbol)\n\n    return references\n\n\ndef get_symbols_in_line(line):\n    \"\"\"Return mentioned Kconfig symbols in @line.\"\"\"\n    return REGEX_SYMBOL.findall(line)\n\n\ndef parse_kconfig_files(args):\n    \"\"\"Parse kconfig files and return tuple of defined and references Kconfig\n    symbols.  Note, @args is a tuple of a list of files and the @ignore\n    pattern.\"\"\"\n    kconfig_files = args[0]\n    ignore = args[1]\n    defined_symbols = []\n    referenced_symbols = dict()\n\n    for kfile in kconfig_files:\n        defined, references = parse_kconfig_file(kfile)\n        defined_symbols.extend(defined)\n        if ignore and re.match(ignore, kfile):\n            # do not collect references for files that match the ignore pattern\n            continue\n        referenced_symbols[kfile] = references\n    return (defined_symbols, referenced_symbols)\n\n\ndef parse_kconfig_file(kfile):\n    \"\"\"Parse @kfile and update symbol definitions and references.\"\"\"\n    lines = []\n    defined = []\n    references = []\n\n    if not os.path.exists(kfile):\n        return defined, references\n\n    with open(kfile, \"r\", encoding='utf-8', errors='replace') as stream:\n        lines = stream.readlines()\n\n    for i in range(len(lines)):\n        line = lines[i]\n        line = line.strip('\\n')\n        line = line.split(\"#\")[0]  # ignore comments\n\n        if REGEX_KCONFIG_DEF.match(line):\n            symbol_def = REGEX_KCONFIG_DEF.findall(line)\n            defined.append(symbol_def[0])\n        elif REGEX_KCONFIG_STMT.match(line):\n            line = REGEX_QUOTES.sub(\"\", line)\n            symbols = get_symbols_in_line(line)\n            # multi-line statements\n            while line.endswith(\"\\\\\"):\n                i += 1\n                line = lines[i]\n                line = line.strip('\\n')\n                symbols.extend(get_symbols_in_line(line))\n            for symbol in set(symbols):\n                if REGEX_NUMERIC.match(symbol):\n                    # ignore numeric values\n                    continue\n                references.append(symbol)\n\n    return defined, references\n\n\ndef main():\n    try:\n        print_undefined_symbols()\n    except BrokenPipeError:\n        # Python flushes standard streams on exit; redirect remaining output\n        # to devnull to avoid another BrokenPipeError at shutdown\n        devnull = os.open(os.devnull, os.O_WRONLY)\n        os.dup2(devnull, sys.stdout.fileno())\n        sys.exit(1)  # Python exits with error code 1 on EPIPE\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}