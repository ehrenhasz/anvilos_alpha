{
  "module_name": "link-vmlinux.sh",
  "hash_id": "9bf1de01f85486403dc5055462ae6b8a624a8a37a980b8296ba7329dba18a67b",
  "original_prompt": "Ingested from linux-6.6.14/scripts/link-vmlinux.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# link vmlinux\n#\n# vmlinux is linked from the objects in vmlinux.a and $(KBUILD_VMLINUX_LIBS).\n# vmlinux.a contains objects that are linked unconditionally.\n# $(KBUILD_VMLINUX_LIBS) are archives which are linked conditionally\n# (not within --whole-archive), and do not require symbol indexes added.\n#\n# vmlinux\n#   ^\n#   |\n#   +--< vmlinux.a\n#   |\n#   +--< $(KBUILD_VMLINUX_LIBS)\n#   |    +--< lib/lib.a + more\n#   |\n#   +-< ${kallsymso} (see description in KALLSYMS section)\n#\n# vmlinux version (uname -v) cannot be updated during normal\n# descending-into-subdirs phase since we do not yet know if we need to\n# update vmlinux.\n# Therefore this step is delayed until just before final link of vmlinux.\n#\n# System.map is generated to document addresses of all kernel symbols\n\n# Error out on error\nset -e\n\nLD=\"$1\"\nKBUILD_LDFLAGS=\"$2\"\nLDFLAGS_vmlinux=\"$3\"\n\nis_enabled() {\n\tgrep -q \"^$1=y\" include/config/auto.conf\n}\n\n# Nice output in kbuild format\n# Will be supressed by \"make -s\"\ninfo()\n{\n\tprintf \"  %-7s %s\\n\" \"${1}\" \"${2}\"\n}\n\n# Link of vmlinux\n# ${1} - output file\n# ${2}, ${3}, ... - optional extra .o files\nvmlinux_link()\n{\n\tlocal output=${1}\n\tlocal objs\n\tlocal libs\n\tlocal ld\n\tlocal ldflags\n\tlocal ldlibs\n\n\tinfo LD ${output}\n\n\t# skip output file argument\n\tshift\n\n\tif is_enabled CONFIG_LTO_CLANG || is_enabled CONFIG_X86_KERNEL_IBT; then\n\t\t# Use vmlinux.o instead of performing the slow LTO link again.\n\t\tobjs=vmlinux.o\n\t\tlibs=\n\telse\n\t\tobjs=vmlinux.a\n\t\tlibs=\"${KBUILD_VMLINUX_LIBS}\"\n\tfi\n\n\tif is_enabled CONFIG_MODULES; then\n\t\tobjs=\"${objs} .vmlinux.export.o\"\n\tfi\n\n\tobjs=\"${objs} init/version-timestamp.o\"\n\n\tif [ \"${SRCARCH}\" = \"um\" ]; then\n\t\twl=-Wl,\n\t\tld=\"${CC}\"\n\t\tldflags=\"${CFLAGS_vmlinux}\"\n\t\tldlibs=\"-lutil -lrt -lpthread\"\n\telse\n\t\twl=\n\t\tld=\"${LD}\"\n\t\tldflags=\"${KBUILD_LDFLAGS} ${LDFLAGS_vmlinux}\"\n\t\tldlibs=\n\tfi\n\n\tldflags=\"${ldflags} ${wl}--script=${objtree}/${KBUILD_LDS}\"\n\n\t# The kallsyms linking does not need debug symbols included.\n\tif [ \"$output\" != \"${output#.tmp_vmlinux.kallsyms}\" ] ; then\n\t\tldflags=\"${ldflags} ${wl}--strip-debug\"\n\tfi\n\n\tif is_enabled CONFIG_VMLINUX_MAP; then\n\t\tldflags=\"${ldflags} ${wl}-Map=${output}.map\"\n\tfi\n\n\t${ld} ${ldflags} -o ${output}\t\t\t\t\t\\\n\t\t${wl}--whole-archive ${objs} ${wl}--no-whole-archive\t\\\n\t\t${wl}--start-group ${libs} ${wl}--end-group\t\t\\\n\t\t$@ ${ldlibs}\n}\n\n# generate .BTF typeinfo from DWARF debuginfo\n# ${1} - vmlinux image\n# ${2} - file to dump raw BTF data into\ngen_btf()\n{\n\tlocal pahole_ver\n\n\tif ! [ -x \"$(command -v ${PAHOLE})\" ]; then\n\t\techo >&2 \"BTF: ${1}: pahole (${PAHOLE}) is not available\"\n\t\treturn 1\n\tfi\n\n\tpahole_ver=$(${PAHOLE} --version | sed -E 's/v([0-9]+)\\.([0-9]+)/\\1\\2/')\n\tif [ \"${pahole_ver}\" -lt \"116\" ]; then\n\t\techo >&2 \"BTF: ${1}: pahole version $(${PAHOLE} --version) is too old, need at least v1.16\"\n\t\treturn 1\n\tfi\n\n\tvmlinux_link ${1}\n\n\tinfo \"BTF\" ${2}\n\tLLVM_OBJCOPY=\"${OBJCOPY}\" ${PAHOLE} -J ${PAHOLE_FLAGS} ${1}\n\n\t# Create ${2} which contains just .BTF section but no symbols. Add\n\t# SHF_ALLOC because .BTF will be part of the vmlinux image. --strip-all\n\t# deletes all symbols including __start_BTF and __stop_BTF, which will\n\t# be redefined in the linker script. Add 2>/dev/null to suppress GNU\n\t# objcopy warnings: \"empty loadable segment detected at ...\"\n\t${OBJCOPY} --only-section=.BTF --set-section-flags .BTF=alloc,readonly \\\n\t\t--strip-all ${1} ${2} 2>/dev/null\n\t# Change e_type to ET_REL so that it can be used to link final vmlinux.\n\t# Unlike GNU ld, lld does not allow an ET_EXEC input.\n\tprintf '\\1' | dd of=${2} conv=notrunc bs=1 seek=16 status=none\n}\n\n# Create ${2} .S file with all symbols from the ${1} object file\nkallsyms()\n{\n\tlocal kallsymopt;\n\n\tif is_enabled CONFIG_KALLSYMS_ALL; then\n\t\tkallsymopt=\"${kallsymopt} --all-symbols\"\n\tfi\n\n\tif is_enabled CONFIG_KALLSYMS_ABSOLUTE_PERCPU; then\n\t\tkallsymopt=\"${kallsymopt} --absolute-percpu\"\n\tfi\n\n\tif is_enabled CONFIG_KALLSYMS_BASE_RELATIVE; then\n\t\tkallsymopt=\"${kallsymopt} --base-relative\"\n\tfi\n\n\tif is_enabled CONFIG_LTO_CLANG; then\n\t\tkallsymopt=\"${kallsymopt} --lto-clang\"\n\tfi\n\n\tinfo KSYMS ${2}\n\tscripts/kallsyms ${kallsymopt} ${1} > ${2}\n}\n\n# Perform one step in kallsyms generation, including temporary linking of\n# vmlinux.\nkallsyms_step()\n{\n\tkallsymso_prev=${kallsymso}\n\tkallsyms_vmlinux=.tmp_vmlinux.kallsyms${1}\n\tkallsymso=${kallsyms_vmlinux}.o\n\tkallsyms_S=${kallsyms_vmlinux}.S\n\n\tvmlinux_link ${kallsyms_vmlinux} \"${kallsymso_prev}\" ${btf_vmlinux_bin_o}\n\tmksysmap ${kallsyms_vmlinux} ${kallsyms_vmlinux}.syms ${kallsymso_prev}\n\tkallsyms ${kallsyms_vmlinux}.syms ${kallsyms_S}\n\n\tinfo AS ${kallsyms_S}\n\t${CC} ${NOSTDINC_FLAGS} ${LINUXINCLUDE} ${KBUILD_CPPFLAGS} \\\n\t      ${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL} \\\n\t      -c -o ${kallsymso} ${kallsyms_S}\n}\n\n# Create map file with all symbols from ${1}\n# See mksymap for additional details\nmksysmap()\n{\n\tinfo NM ${2}\n\t${CONFIG_SHELL} \"${srctree}/scripts/mksysmap\" ${1} ${2} ${3}\n}\n\nsorttable()\n{\n\t${objtree}/scripts/sorttable ${1}\n}\n\n# Delete output files in case of error\ncleanup()\n{\n\trm -f .btf.*\n\trm -f System.map\n\trm -f vmlinux\n\trm -f vmlinux.map\n}\n\n# Use \"make V=1\" to debug this script\ncase \"${KBUILD_VERBOSE}\" in\n*1*)\n\tset -x\n\t;;\nesac\n\nif [ \"$1\" = \"clean\" ]; then\n\tcleanup\n\texit 0\nfi\n\n${MAKE} -f \"${srctree}/scripts/Makefile.build\" obj=init init/version-timestamp.o\n\nbtf_vmlinux_bin_o=\"\"\nif is_enabled CONFIG_DEBUG_INFO_BTF; then\n\tbtf_vmlinux_bin_o=.btf.vmlinux.bin.o\n\tif ! gen_btf .tmp_vmlinux.btf $btf_vmlinux_bin_o ; then\n\t\techo >&2 \"Failed to generate BTF for vmlinux\"\n\t\techo >&2 \"Try to disable CONFIG_DEBUG_INFO_BTF\"\n\t\texit 1\n\tfi\nfi\n\nkallsymso=\"\"\nkallsymso_prev=\"\"\nkallsyms_vmlinux=\"\"\nif is_enabled CONFIG_KALLSYMS; then\n\n\t# kallsyms support\n\t# Generate section listing all symbols and add it into vmlinux\n\t# It's a three step process:\n\t# 1)  Link .tmp_vmlinux.kallsyms1 so it has all symbols and sections,\n\t#     but __kallsyms is empty.\n\t#     Running kallsyms on that gives us .tmp_kallsyms1.o with\n\t#     the right size\n\t# 2)  Link .tmp_vmlinux.kallsyms2 so it now has a __kallsyms section of\n\t#     the right size, but due to the added section, some\n\t#     addresses have shifted.\n\t#     From here, we generate a correct .tmp_vmlinux.kallsyms2.o\n\t# 3)  That link may have expanded the kernel image enough that\n\t#     more linker branch stubs / trampolines had to be added, which\n\t#     introduces new names, which further expands kallsyms. Do another\n\t#     pass if that is the case. In theory it's possible this results\n\t#     in even more stubs, but unlikely.\n\t#     KALLSYMS_EXTRA_PASS=1 may also used to debug or work around\n\t#     other bugs.\n\t# 4)  The correct ${kallsymso} is linked into the final vmlinux.\n\t#\n\t# a)  Verify that the System.map from vmlinux matches the map from\n\t#     ${kallsymso}.\n\n\tkallsyms_step 1\n\tkallsyms_step 2\n\n\t# step 3\n\tsize1=$(${CONFIG_SHELL} \"${srctree}/scripts/file-size.sh\" ${kallsymso_prev})\n\tsize2=$(${CONFIG_SHELL} \"${srctree}/scripts/file-size.sh\" ${kallsymso})\n\n\tif [ $size1 -ne $size2 ] || [ -n \"${KALLSYMS_EXTRA_PASS}\" ]; then\n\t\tkallsyms_step 3\n\tfi\nfi\n\nvmlinux_link vmlinux \"${kallsymso}\" ${btf_vmlinux_bin_o}\n\n# fill in BTF IDs\nif is_enabled CONFIG_DEBUG_INFO_BTF && is_enabled CONFIG_BPF; then\n\tinfo BTFIDS vmlinux\n\t${RESOLVE_BTFIDS} vmlinux\nfi\n\nmksysmap vmlinux System.map ${kallsymso}\n\nif is_enabled CONFIG_BUILDTIME_TABLE_SORT; then\n\tinfo SORTTAB vmlinux\n\tif ! sorttable vmlinux; then\n\t\techo >&2 Failed to sort kernel tables\n\t\texit 1\n\tfi\nfi\n\n# step a (see comment above)\nif is_enabled CONFIG_KALLSYMS; then\n\tif ! cmp -s System.map ${kallsyms_vmlinux}.syms; then\n\t\techo >&2 Inconsistent kallsyms data\n\t\techo >&2 'Try \"make KALLSYMS_EXTRA_PASS=1\" as a workaround'\n\t\texit 1\n\tfi\nfi\n\n# For fixdep\necho \"vmlinux: $0\" > .vmlinux.d\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}