{
  "module_name": "genksyms.c",
  "hash_id": "0c0de49f231423f2ca8e853a455448ef395d2f55ff3033a68cbeeb06e8906416",
  "original_prompt": "Ingested from linux-6.6.14/scripts/genksyms/genksyms.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <assert.h>\n#include <stdarg.h>\n#ifdef __GNU_LIBRARY__\n#include <getopt.h>\n#endif\t\t\t\t \n\n#include \"genksyms.h\"\n \n\n#define HASH_BUCKETS  4096\n\nstatic struct symbol *symtab[HASH_BUCKETS];\nstatic FILE *debugfile;\n\nint cur_line = 1;\nchar *cur_filename;\nint in_source_file;\n\nstatic int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,\n\t   flag_preserve, flag_warnings;\n\nstatic int errors;\nstatic int nsyms;\n\nstatic struct symbol *expansion_trail;\nstatic struct symbol *visited_symbols;\n\nstatic const struct {\n\tint n;\n\tconst char *name;\n} symbol_types[] = {\n\t[SYM_NORMAL]     = { 0, NULL},\n\t[SYM_TYPEDEF]    = {'t', \"typedef\"},\n\t[SYM_ENUM]       = {'e', \"enum\"},\n\t[SYM_STRUCT]     = {'s', \"struct\"},\n\t[SYM_UNION]      = {'u', \"union\"},\n\t[SYM_ENUM_CONST] = {'E', \"enum constant\"},\n};\n\nstatic int equal_list(struct string_list *a, struct string_list *b);\nstatic void print_list(FILE * f, struct string_list *list);\nstatic struct string_list *concat_list(struct string_list *start, ...);\nstatic struct string_list *mk_node(const char *string);\nstatic void print_location(void);\nstatic void print_type_name(enum symbol_type type, const char *name);\n\n \n\nstatic const unsigned int crctab32[] = {\n\t0x00000000U, 0x77073096U, 0xee0e612cU, 0x990951baU, 0x076dc419U,\n\t0x706af48fU, 0xe963a535U, 0x9e6495a3U, 0x0edb8832U, 0x79dcb8a4U,\n\t0xe0d5e91eU, 0x97d2d988U, 0x09b64c2bU, 0x7eb17cbdU, 0xe7b82d07U,\n\t0x90bf1d91U, 0x1db71064U, 0x6ab020f2U, 0xf3b97148U, 0x84be41deU,\n\t0x1adad47dU, 0x6ddde4ebU, 0xf4d4b551U, 0x83d385c7U, 0x136c9856U,\n\t0x646ba8c0U, 0xfd62f97aU, 0x8a65c9ecU, 0x14015c4fU, 0x63066cd9U,\n\t0xfa0f3d63U, 0x8d080df5U, 0x3b6e20c8U, 0x4c69105eU, 0xd56041e4U,\n\t0xa2677172U, 0x3c03e4d1U, 0x4b04d447U, 0xd20d85fdU, 0xa50ab56bU,\n\t0x35b5a8faU, 0x42b2986cU, 0xdbbbc9d6U, 0xacbcf940U, 0x32d86ce3U,\n\t0x45df5c75U, 0xdcd60dcfU, 0xabd13d59U, 0x26d930acU, 0x51de003aU,\n\t0xc8d75180U, 0xbfd06116U, 0x21b4f4b5U, 0x56b3c423U, 0xcfba9599U,\n\t0xb8bda50fU, 0x2802b89eU, 0x5f058808U, 0xc60cd9b2U, 0xb10be924U,\n\t0x2f6f7c87U, 0x58684c11U, 0xc1611dabU, 0xb6662d3dU, 0x76dc4190U,\n\t0x01db7106U, 0x98d220bcU, 0xefd5102aU, 0x71b18589U, 0x06b6b51fU,\n\t0x9fbfe4a5U, 0xe8b8d433U, 0x7807c9a2U, 0x0f00f934U, 0x9609a88eU,\n\t0xe10e9818U, 0x7f6a0dbbU, 0x086d3d2dU, 0x91646c97U, 0xe6635c01U,\n\t0x6b6b51f4U, 0x1c6c6162U, 0x856530d8U, 0xf262004eU, 0x6c0695edU,\n\t0x1b01a57bU, 0x8208f4c1U, 0xf50fc457U, 0x65b0d9c6U, 0x12b7e950U,\n\t0x8bbeb8eaU, 0xfcb9887cU, 0x62dd1ddfU, 0x15da2d49U, 0x8cd37cf3U,\n\t0xfbd44c65U, 0x4db26158U, 0x3ab551ceU, 0xa3bc0074U, 0xd4bb30e2U,\n\t0x4adfa541U, 0x3dd895d7U, 0xa4d1c46dU, 0xd3d6f4fbU, 0x4369e96aU,\n\t0x346ed9fcU, 0xad678846U, 0xda60b8d0U, 0x44042d73U, 0x33031de5U,\n\t0xaa0a4c5fU, 0xdd0d7cc9U, 0x5005713cU, 0x270241aaU, 0xbe0b1010U,\n\t0xc90c2086U, 0x5768b525U, 0x206f85b3U, 0xb966d409U, 0xce61e49fU,\n\t0x5edef90eU, 0x29d9c998U, 0xb0d09822U, 0xc7d7a8b4U, 0x59b33d17U,\n\t0x2eb40d81U, 0xb7bd5c3bU, 0xc0ba6cadU, 0xedb88320U, 0x9abfb3b6U,\n\t0x03b6e20cU, 0x74b1d29aU, 0xead54739U, 0x9dd277afU, 0x04db2615U,\n\t0x73dc1683U, 0xe3630b12U, 0x94643b84U, 0x0d6d6a3eU, 0x7a6a5aa8U,\n\t0xe40ecf0bU, 0x9309ff9dU, 0x0a00ae27U, 0x7d079eb1U, 0xf00f9344U,\n\t0x8708a3d2U, 0x1e01f268U, 0x6906c2feU, 0xf762575dU, 0x806567cbU,\n\t0x196c3671U, 0x6e6b06e7U, 0xfed41b76U, 0x89d32be0U, 0x10da7a5aU,\n\t0x67dd4accU, 0xf9b9df6fU, 0x8ebeeff9U, 0x17b7be43U, 0x60b08ed5U,\n\t0xd6d6a3e8U, 0xa1d1937eU, 0x38d8c2c4U, 0x4fdff252U, 0xd1bb67f1U,\n\t0xa6bc5767U, 0x3fb506ddU, 0x48b2364bU, 0xd80d2bdaU, 0xaf0a1b4cU,\n\t0x36034af6U, 0x41047a60U, 0xdf60efc3U, 0xa867df55U, 0x316e8eefU,\n\t0x4669be79U, 0xcb61b38cU, 0xbc66831aU, 0x256fd2a0U, 0x5268e236U,\n\t0xcc0c7795U, 0xbb0b4703U, 0x220216b9U, 0x5505262fU, 0xc5ba3bbeU,\n\t0xb2bd0b28U, 0x2bb45a92U, 0x5cb36a04U, 0xc2d7ffa7U, 0xb5d0cf31U,\n\t0x2cd99e8bU, 0x5bdeae1dU, 0x9b64c2b0U, 0xec63f226U, 0x756aa39cU,\n\t0x026d930aU, 0x9c0906a9U, 0xeb0e363fU, 0x72076785U, 0x05005713U,\n\t0x95bf4a82U, 0xe2b87a14U, 0x7bb12baeU, 0x0cb61b38U, 0x92d28e9bU,\n\t0xe5d5be0dU, 0x7cdcefb7U, 0x0bdbdf21U, 0x86d3d2d4U, 0xf1d4e242U,\n\t0x68ddb3f8U, 0x1fda836eU, 0x81be16cdU, 0xf6b9265bU, 0x6fb077e1U,\n\t0x18b74777U, 0x88085ae6U, 0xff0f6a70U, 0x66063bcaU, 0x11010b5cU,\n\t0x8f659effU, 0xf862ae69U, 0x616bffd3U, 0x166ccf45U, 0xa00ae278U,\n\t0xd70dd2eeU, 0x4e048354U, 0x3903b3c2U, 0xa7672661U, 0xd06016f7U,\n\t0x4969474dU, 0x3e6e77dbU, 0xaed16a4aU, 0xd9d65adcU, 0x40df0b66U,\n\t0x37d83bf0U, 0xa9bcae53U, 0xdebb9ec5U, 0x47b2cf7fU, 0x30b5ffe9U,\n\t0xbdbdf21cU, 0xcabac28aU, 0x53b39330U, 0x24b4a3a6U, 0xbad03605U,\n\t0xcdd70693U, 0x54de5729U, 0x23d967bfU, 0xb3667a2eU, 0xc4614ab8U,\n\t0x5d681b02U, 0x2a6f2b94U, 0xb40bbe37U, 0xc30c8ea1U, 0x5a05df1bU,\n\t0x2d02ef8dU\n};\n\nstatic unsigned long partial_crc32_one(unsigned char c, unsigned long crc)\n{\n\treturn crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);\n}\n\nstatic unsigned long partial_crc32(const char *s, unsigned long crc)\n{\n\twhile (*s)\n\t\tcrc = partial_crc32_one(*s++, crc);\n\treturn crc;\n}\n\nstatic unsigned long crc32(const char *s)\n{\n\treturn partial_crc32(s, 0xffffffff) ^ 0xffffffff;\n}\n\n \n\nstatic enum symbol_type map_to_ns(enum symbol_type t)\n{\n\tswitch (t) {\n\tcase SYM_ENUM_CONST:\n\tcase SYM_NORMAL:\n\tcase SYM_TYPEDEF:\n\t\treturn SYM_NORMAL;\n\tcase SYM_ENUM:\n\tcase SYM_STRUCT:\n\tcase SYM_UNION:\n\t\treturn SYM_STRUCT;\n\t}\n\treturn t;\n}\n\nstruct symbol *find_symbol(const char *name, enum symbol_type ns, int exact)\n{\n\tunsigned long h = crc32(name) % HASH_BUCKETS;\n\tstruct symbol *sym;\n\n\tfor (sym = symtab[h]; sym; sym = sym->hash_next)\n\t\tif (map_to_ns(sym->type) == map_to_ns(ns) &&\n\t\t    strcmp(name, sym->name) == 0 &&\n\t\t    sym->is_declared)\n\t\t\tbreak;\n\n\tif (exact && sym && sym->type != ns)\n\t\treturn NULL;\n\treturn sym;\n}\n\nstatic int is_unknown_symbol(struct symbol *sym)\n{\n\tstruct string_list *defn;\n\n\treturn ((sym->type == SYM_STRUCT ||\n\t\t sym->type == SYM_UNION ||\n\t\t sym->type == SYM_ENUM) &&\n\t\t(defn = sym->defn)  && defn->tag == SYM_NORMAL &&\n\t\t\tstrcmp(defn->string, \"}\") == 0 &&\n\t\t(defn = defn->next) && defn->tag == SYM_NORMAL &&\n\t\t\tstrcmp(defn->string, \"UNKNOWN\") == 0 &&\n\t\t(defn = defn->next) && defn->tag == SYM_NORMAL &&\n\t\t\tstrcmp(defn->string, \"{\") == 0);\n}\n\nstatic struct symbol *__add_symbol(const char *name, enum symbol_type type,\n\t\t\t    struct string_list *defn, int is_extern,\n\t\t\t    int is_reference)\n{\n\tunsigned long h;\n\tstruct symbol *sym;\n\tenum symbol_status status = STATUS_UNCHANGED;\n\t \n\tstatic int enum_counter;\n\tstatic struct string_list *last_enum_expr;\n\n\tif (type == SYM_ENUM_CONST) {\n\t\tif (defn) {\n\t\t\tfree_list(last_enum_expr, NULL);\n\t\t\tlast_enum_expr = copy_list_range(defn, NULL);\n\t\t\tenum_counter = 1;\n\t\t} else {\n\t\t\tstruct string_list *expr;\n\t\t\tchar buf[20];\n\n\t\t\tsnprintf(buf, sizeof(buf), \"%d\", enum_counter++);\n\t\t\tif (last_enum_expr) {\n\t\t\t\texpr = copy_list_range(last_enum_expr, NULL);\n\t\t\t\tdefn = concat_list(mk_node(\"(\"),\n\t\t\t\t\t\t   expr,\n\t\t\t\t\t\t   mk_node(\")\"),\n\t\t\t\t\t\t   mk_node(\"+\"),\n\t\t\t\t\t\t   mk_node(buf), NULL);\n\t\t\t} else {\n\t\t\t\tdefn = mk_node(buf);\n\t\t\t}\n\t\t}\n\t} else if (type == SYM_ENUM) {\n\t\tfree_list(last_enum_expr, NULL);\n\t\tlast_enum_expr = NULL;\n\t\tenum_counter = 0;\n\t\tif (!name)\n\t\t\t \n\t\t\treturn NULL;\n\t}\n\n\th = crc32(name) % HASH_BUCKETS;\n\tfor (sym = symtab[h]; sym; sym = sym->hash_next) {\n\t\tif (map_to_ns(sym->type) == map_to_ns(type) &&\n\t\t    strcmp(name, sym->name) == 0) {\n\t\t\tif (is_reference)\n\t\t\t\t  ;\n\t\t\telse if (sym->type == type &&\n\t\t\t\t equal_list(sym->defn, defn)) {\n\t\t\t\tif (!sym->is_declared && sym->is_override) {\n\t\t\t\t\tprint_location();\n\t\t\t\t\tprint_type_name(type, name);\n\t\t\t\t\tfprintf(stderr, \" modversion is \"\n\t\t\t\t\t\t\"unchanged\\n\");\n\t\t\t\t}\n\t\t\t\tsym->is_declared = 1;\n\t\t\t\treturn sym;\n\t\t\t} else if (!sym->is_declared) {\n\t\t\t\tif (sym->is_override && flag_preserve) {\n\t\t\t\t\tprint_location();\n\t\t\t\t\tfprintf(stderr, \"ignoring \");\n\t\t\t\t\tprint_type_name(type, name);\n\t\t\t\t\tfprintf(stderr, \" modversion change\\n\");\n\t\t\t\t\tsym->is_declared = 1;\n\t\t\t\t\treturn sym;\n\t\t\t\t} else {\n\t\t\t\t\tstatus = is_unknown_symbol(sym) ?\n\t\t\t\t\t\tSTATUS_DEFINED : STATUS_MODIFIED;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_with_pos(\"redefinition of %s\", name);\n\t\t\t\treturn sym;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sym) {\n\t\tstruct symbol **psym;\n\n\t\tfor (psym = &symtab[h]; *psym; psym = &(*psym)->hash_next) {\n\t\t\tif (*psym == sym) {\n\t\t\t\t*psym = sym->hash_next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t--nsyms;\n\t}\n\n\tsym = xmalloc(sizeof(*sym));\n\tsym->name = name;\n\tsym->type = type;\n\tsym->defn = defn;\n\tsym->expansion_trail = NULL;\n\tsym->visited = NULL;\n\tsym->is_extern = is_extern;\n\n\tsym->hash_next = symtab[h];\n\tsymtab[h] = sym;\n\n\tsym->is_declared = !is_reference;\n\tsym->status = status;\n\tsym->is_override = 0;\n\n\tif (flag_debug) {\n\t\tif (symbol_types[type].name)\n\t\t\tfprintf(debugfile, \"Defn for %s %s == <\",\n\t\t\t\tsymbol_types[type].name, name);\n\t\telse\n\t\t\tfprintf(debugfile, \"Defn for type%d %s == <\",\n\t\t\t\ttype, name);\n\t\tif (is_extern)\n\t\t\tfputs(\"extern \", debugfile);\n\t\tprint_list(debugfile, defn);\n\t\tfputs(\">\\n\", debugfile);\n\t}\n\n\t++nsyms;\n\treturn sym;\n}\n\nstruct symbol *add_symbol(const char *name, enum symbol_type type,\n\t\t\t  struct string_list *defn, int is_extern)\n{\n\treturn __add_symbol(name, type, defn, is_extern, 0);\n}\n\nstatic struct symbol *add_reference_symbol(const char *name, enum symbol_type type,\n\t\t\t\t    struct string_list *defn, int is_extern)\n{\n\treturn __add_symbol(name, type, defn, is_extern, 1);\n}\n\n \n\nvoid free_node(struct string_list *node)\n{\n\tfree(node->string);\n\tfree(node);\n}\n\nvoid free_list(struct string_list *s, struct string_list *e)\n{\n\twhile (s != e) {\n\t\tstruct string_list *next = s->next;\n\t\tfree_node(s);\n\t\ts = next;\n\t}\n}\n\nstatic struct string_list *mk_node(const char *string)\n{\n\tstruct string_list *newnode;\n\n\tnewnode = xmalloc(sizeof(*newnode));\n\tnewnode->string = xstrdup(string);\n\tnewnode->tag = SYM_NORMAL;\n\tnewnode->next = NULL;\n\n\treturn newnode;\n}\n\nstatic struct string_list *concat_list(struct string_list *start, ...)\n{\n\tva_list ap;\n\tstruct string_list *n, *n2;\n\n\tif (!start)\n\t\treturn NULL;\n\tfor (va_start(ap, start); (n = va_arg(ap, struct string_list *));) {\n\t\tfor (n2 = n; n2->next; n2 = n2->next)\n\t\t\t;\n\t\tn2->next = start;\n\t\tstart = n;\n\t}\n\tva_end(ap);\n\treturn start;\n}\n\nstruct string_list *copy_node(struct string_list *node)\n{\n\tstruct string_list *newnode;\n\n\tnewnode = xmalloc(sizeof(*newnode));\n\tnewnode->string = xstrdup(node->string);\n\tnewnode->tag = node->tag;\n\n\treturn newnode;\n}\n\nstruct string_list *copy_list_range(struct string_list *start,\n\t\t\t\t    struct string_list *end)\n{\n\tstruct string_list *res, *n;\n\n\tif (start == end)\n\t\treturn NULL;\n\tn = res = copy_node(start);\n\tfor (start = start->next; start != end; start = start->next) {\n\t\tn->next = copy_node(start);\n\t\tn = n->next;\n\t}\n\tn->next = NULL;\n\treturn res;\n}\n\nstatic int equal_list(struct string_list *a, struct string_list *b)\n{\n\twhile (a && b) {\n\t\tif (a->tag != b->tag || strcmp(a->string, b->string))\n\t\t\treturn 0;\n\t\ta = a->next;\n\t\tb = b->next;\n\t}\n\n\treturn !a && !b;\n}\n\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n\nstatic struct string_list *read_node(FILE *f)\n{\n\tchar buffer[256];\n\tstruct string_list node = {\n\t\t.string = buffer,\n\t\t.tag = SYM_NORMAL };\n\tint c, in_string = 0;\n\n\twhile ((c = fgetc(f)) != EOF) {\n\t\tif (!in_string && c == ' ') {\n\t\t\tif (node.string == buffer)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t} else if (c == '\"') {\n\t\t\tin_string = !in_string;\n\t\t} else if (c == '\\n') {\n\t\t\tif (node.string == buffer)\n\t\t\t\treturn NULL;\n\t\t\tungetc(c, f);\n\t\t\tbreak;\n\t\t}\n\t\tif (node.string >= buffer + sizeof(buffer) - 1) {\n\t\t\tfprintf(stderr, \"Token too long\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t*node.string++ = c;\n\t}\n\tif (node.string == buffer)\n\t\treturn NULL;\n\t*node.string = 0;\n\tnode.string = buffer;\n\n\tif (node.string[1] == '#') {\n\t\tsize_t n;\n\n\t\tfor (n = 0; n < ARRAY_SIZE(symbol_types); n++) {\n\t\t\tif (node.string[0] == symbol_types[n].n) {\n\t\t\t\tnode.tag = n;\n\t\t\t\tnode.string += 2;\n\t\t\t\treturn copy_node(&node);\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"Unknown type %c\\n\", node.string[0]);\n\t\texit(1);\n\t}\n\treturn copy_node(&node);\n}\n\nstatic void read_reference(FILE *f)\n{\n\twhile (!feof(f)) {\n\t\tstruct string_list *defn = NULL;\n\t\tstruct string_list *sym, *def;\n\t\tint is_extern = 0, is_override = 0;\n\t\tstruct symbol *subsym;\n\n\t\tsym = read_node(f);\n\t\tif (sym && sym->tag == SYM_NORMAL &&\n\t\t    !strcmp(sym->string, \"override\")) {\n\t\t\tis_override = 1;\n\t\t\tfree_node(sym);\n\t\t\tsym = read_node(f);\n\t\t}\n\t\tif (!sym)\n\t\t\tcontinue;\n\t\tdef = read_node(f);\n\t\tif (def && def->tag == SYM_NORMAL &&\n\t\t    !strcmp(def->string, \"extern\")) {\n\t\t\tis_extern = 1;\n\t\t\tfree_node(def);\n\t\t\tdef = read_node(f);\n\t\t}\n\t\twhile (def) {\n\t\t\tdef->next = defn;\n\t\t\tdefn = def;\n\t\t\tdef = read_node(f);\n\t\t}\n\t\tsubsym = add_reference_symbol(xstrdup(sym->string), sym->tag,\n\t\t\t\t\t      defn, is_extern);\n\t\tsubsym->is_override = is_override;\n\t\tfree_node(sym);\n\t}\n}\n\nstatic void print_node(FILE * f, struct string_list *list)\n{\n\tif (symbol_types[list->tag].n) {\n\t\tputc(symbol_types[list->tag].n, f);\n\t\tputc('#', f);\n\t}\n\tfputs(list->string, f);\n}\n\nstatic void print_list(FILE * f, struct string_list *list)\n{\n\tstruct string_list **e, **b;\n\tstruct string_list *tmp, **tmp2;\n\tint elem = 1;\n\n\tif (list == NULL) {\n\t\tfputs(\"(nil)\", f);\n\t\treturn;\n\t}\n\n\ttmp = list;\n\twhile ((tmp = tmp->next) != NULL)\n\t\telem++;\n\n\tb = alloca(elem * sizeof(*e));\n\te = b + elem;\n\ttmp2 = e - 1;\n\n\t(*tmp2--) = list;\n\twhile ((list = list->next) != NULL)\n\t\t*(tmp2--) = list;\n\n\twhile (b != e) {\n\t\tprint_node(f, *b++);\n\t\tputc(' ', f);\n\t}\n}\n\nstatic unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)\n{\n\tstruct string_list *list = sym->defn;\n\tstruct string_list **e, **b;\n\tstruct string_list *tmp, **tmp2;\n\tint elem = 1;\n\n\tif (!list)\n\t\treturn crc;\n\n\ttmp = list;\n\twhile ((tmp = tmp->next) != NULL)\n\t\telem++;\n\n\tb = alloca(elem * sizeof(*e));\n\te = b + elem;\n\ttmp2 = e - 1;\n\n\t*(tmp2--) = list;\n\twhile ((list = list->next) != NULL)\n\t\t*(tmp2--) = list;\n\n\twhile (b != e) {\n\t\tstruct string_list *cur;\n\t\tstruct symbol *subsym;\n\n\t\tcur = *(b++);\n\t\tswitch (cur->tag) {\n\t\tcase SYM_NORMAL:\n\t\t\tif (flag_dump_defs)\n\t\t\t\tfprintf(debugfile, \"%s \", cur->string);\n\t\t\tcrc = partial_crc32(cur->string, crc);\n\t\t\tcrc = partial_crc32_one(' ', crc);\n\t\t\tbreak;\n\n\t\tcase SYM_ENUM_CONST:\n\t\tcase SYM_TYPEDEF:\n\t\t\tsubsym = find_symbol(cur->string, cur->tag, 0);\n\t\t\t \n\t\t\tif (subsym->expansion_trail) {\n\t\t\t\tif (flag_dump_defs)\n\t\t\t\t\tfprintf(debugfile, \"%s \", cur->string);\n\t\t\t\tcrc = partial_crc32(cur->string, crc);\n\t\t\t\tcrc = partial_crc32_one(' ', crc);\n\t\t\t} else {\n\t\t\t\tsubsym->expansion_trail = expansion_trail;\n\t\t\t\texpansion_trail = subsym;\n\t\t\t\tcrc = expand_and_crc_sym(subsym, crc);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SYM_STRUCT:\n\t\tcase SYM_UNION:\n\t\tcase SYM_ENUM:\n\t\t\tsubsym = find_symbol(cur->string, cur->tag, 0);\n\t\t\tif (!subsym) {\n\t\t\t\tstruct string_list *n;\n\n\t\t\t\terror_with_pos(\"expand undefined %s %s\",\n\t\t\t\t\t       symbol_types[cur->tag].name,\n\t\t\t\t\t       cur->string);\n\t\t\t\tn = concat_list(mk_node\n\t\t\t\t\t\t(symbol_types[cur->tag].name),\n\t\t\t\t\t\tmk_node(cur->string),\n\t\t\t\t\t\tmk_node(\"{\"),\n\t\t\t\t\t\tmk_node(\"UNKNOWN\"),\n\t\t\t\t\t\tmk_node(\"}\"), NULL);\n\t\t\t\tsubsym =\n\t\t\t\t    add_symbol(cur->string, cur->tag, n, 0);\n\t\t\t}\n\t\t\tif (subsym->expansion_trail) {\n\t\t\t\tif (flag_dump_defs) {\n\t\t\t\t\tfprintf(debugfile, \"%s %s \",\n\t\t\t\t\t\tsymbol_types[cur->tag].name,\n\t\t\t\t\t\tcur->string);\n\t\t\t\t}\n\n\t\t\t\tcrc = partial_crc32(symbol_types[cur->tag].name,\n\t\t\t\t\t\t    crc);\n\t\t\t\tcrc = partial_crc32_one(' ', crc);\n\t\t\t\tcrc = partial_crc32(cur->string, crc);\n\t\t\t\tcrc = partial_crc32_one(' ', crc);\n\t\t\t} else {\n\t\t\t\tsubsym->expansion_trail = expansion_trail;\n\t\t\t\texpansion_trail = subsym;\n\t\t\t\tcrc = expand_and_crc_sym(subsym, crc);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t{\n\t\tstatic struct symbol **end = &visited_symbols;\n\n\t\tif (!sym->visited) {\n\t\t\t*end = sym;\n\t\t\tend = &sym->visited;\n\t\t\tsym->visited = (struct symbol *)-1L;\n\t\t}\n\t}\n\n\treturn crc;\n}\n\nvoid export_symbol(const char *name)\n{\n\tstruct symbol *sym;\n\n\tsym = find_symbol(name, SYM_NORMAL, 0);\n\tif (!sym)\n\t\terror_with_pos(\"export undefined symbol %s\", name);\n\telse {\n\t\tunsigned long crc;\n\t\tint has_changed = 0;\n\n\t\tif (flag_dump_defs)\n\t\t\tfprintf(debugfile, \"Export %s == <\", name);\n\n\t\texpansion_trail = (struct symbol *)-1L;\n\n\t\tsym->expansion_trail = expansion_trail;\n\t\texpansion_trail = sym;\n\t\tcrc = expand_and_crc_sym(sym, 0xffffffff) ^ 0xffffffff;\n\n\t\tsym = expansion_trail;\n\t\twhile (sym != (struct symbol *)-1L) {\n\t\t\tstruct symbol *n = sym->expansion_trail;\n\n\t\t\tif (sym->status != STATUS_UNCHANGED) {\n\t\t\t\tif (!has_changed) {\n\t\t\t\t\tprint_location();\n\t\t\t\t\tfprintf(stderr, \"%s: %s: modversion \"\n\t\t\t\t\t\t\"changed because of changes \"\n\t\t\t\t\t\t\"in \", flag_preserve ? \"error\" :\n\t\t\t\t\t\t       \"warning\", name);\n\t\t\t\t} else\n\t\t\t\t\tfprintf(stderr, \", \");\n\t\t\t\tprint_type_name(sym->type, sym->name);\n\t\t\t\tif (sym->status == STATUS_DEFINED)\n\t\t\t\t\tfprintf(stderr, \" (became defined)\");\n\t\t\t\thas_changed = 1;\n\t\t\t\tif (flag_preserve)\n\t\t\t\t\terrors++;\n\t\t\t}\n\t\t\tsym->expansion_trail = 0;\n\t\t\tsym = n;\n\t\t}\n\t\tif (has_changed)\n\t\t\tfprintf(stderr, \"\\n\");\n\n\t\tif (flag_dump_defs)\n\t\t\tfputs(\">\\n\", debugfile);\n\n\t\tprintf(\"#SYMVER %s 0x%08lx\\n\", name, crc);\n\t}\n}\n\n \n\nstatic void print_location(void)\n{\n\tfprintf(stderr, \"%s:%d: \", cur_filename ? : \"<stdin>\", cur_line);\n}\n\nstatic void print_type_name(enum symbol_type type, const char *name)\n{\n\tif (symbol_types[type].name)\n\t\tfprintf(stderr, \"%s %s\", symbol_types[type].name, name);\n\telse\n\t\tfprintf(stderr, \"%s\", name);\n}\n\nvoid error_with_pos(const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (flag_warnings) {\n\t\tprint_location();\n\n\t\tva_start(args, fmt);\n\t\tvfprintf(stderr, fmt, args);\n\t\tva_end(args);\n\t\tputc('\\n', stderr);\n\n\t\terrors++;\n\t}\n}\n\nstatic void genksyms_usage(void)\n{\n\tfputs(\"Usage:\\n\" \"genksyms [-adDTwqhVR] > /path/to/.tmp_obj.ver\\n\" \"\\n\"\n#ifdef __GNU_LIBRARY__\n\t      \"  -s, --symbol-prefix   Select symbol prefix\\n\"\n\t      \"  -d, --debug           Increment the debug level (repeatable)\\n\"\n\t      \"  -D, --dump            Dump expanded symbol defs (for debugging only)\\n\"\n\t      \"  -r, --reference file  Read reference symbols from a file\\n\"\n\t      \"  -T, --dump-types file Dump expanded types into file\\n\"\n\t      \"  -p, --preserve        Preserve reference modversions or fail\\n\"\n\t      \"  -w, --warnings        Enable warnings\\n\"\n\t      \"  -q, --quiet           Disable warnings (default)\\n\"\n\t      \"  -h, --help            Print this message\\n\"\n\t      \"  -V, --version         Print the release version\\n\"\n#else\t\t\t\t \n\t      \"  -s                    Select symbol prefix\\n\"\n\t      \"  -d                    Increment the debug level (repeatable)\\n\"\n\t      \"  -D                    Dump expanded symbol defs (for debugging only)\\n\"\n\t      \"  -r file               Read reference symbols from a file\\n\"\n\t      \"  -T file               Dump expanded types into file\\n\"\n\t      \"  -p                    Preserve reference modversions or fail\\n\"\n\t      \"  -w                    Enable warnings\\n\"\n\t      \"  -q                    Disable warnings (default)\\n\"\n\t      \"  -h                    Print this message\\n\"\n\t      \"  -V                    Print the release version\\n\"\n#endif\t\t\t\t \n\t      , stderr);\n}\n\nint main(int argc, char **argv)\n{\n\tFILE *dumpfile = NULL, *ref_file = NULL;\n\tint o;\n\n#ifdef __GNU_LIBRARY__\n\tstruct option long_opts[] = {\n\t\t{\"debug\", 0, 0, 'd'},\n\t\t{\"warnings\", 0, 0, 'w'},\n\t\t{\"quiet\", 0, 0, 'q'},\n\t\t{\"dump\", 0, 0, 'D'},\n\t\t{\"reference\", 1, 0, 'r'},\n\t\t{\"dump-types\", 1, 0, 'T'},\n\t\t{\"preserve\", 0, 0, 'p'},\n\t\t{\"version\", 0, 0, 'V'},\n\t\t{\"help\", 0, 0, 'h'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\twhile ((o = getopt_long(argc, argv, \"s:dwqVDr:T:ph\",\n\t\t\t\t&long_opts[0], NULL)) != EOF)\n#else\t\t\t\t \n\twhile ((o = getopt(argc, argv, \"s:dwqVDr:T:ph\")) != EOF)\n#endif\t\t\t\t \n\t\tswitch (o) {\n\t\tcase 'd':\n\t\t\tflag_debug++;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tflag_warnings = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tflag_warnings = 0;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tfputs(\"genksyms version 2.5.60\\n\", stderr);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tflag_dump_defs = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflag_reference = 1;\n\t\t\tref_file = fopen(optarg, \"r\");\n\t\t\tif (!ref_file) {\n\t\t\t\tperror(optarg);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tflag_dump_types = 1;\n\t\t\tdumpfile = fopen(optarg, \"w\");\n\t\t\tif (!dumpfile) {\n\t\t\t\tperror(optarg);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tflag_preserve = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tgenksyms_usage();\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tgenksyms_usage();\n\t\t\treturn 1;\n\t\t}\n\t{\n\t\textern int yydebug;\n\t\textern int yy_flex_debug;\n\n\t\tyydebug = (flag_debug > 1);\n\t\tyy_flex_debug = (flag_debug > 2);\n\n\t\tdebugfile = stderr;\n\t\t \n\t}\n\n\tif (flag_reference) {\n\t\tread_reference(ref_file);\n\t\tfclose(ref_file);\n\t}\n\n\tyyparse();\n\n\tif (flag_dump_types && visited_symbols) {\n\t\twhile (visited_symbols != (struct symbol *)-1L) {\n\t\t\tstruct symbol *sym = visited_symbols;\n\n\t\t\tif (sym->is_override)\n\t\t\t\tfputs(\"override \", dumpfile);\n\t\t\tif (symbol_types[sym->type].n) {\n\t\t\t\tputc(symbol_types[sym->type].n, dumpfile);\n\t\t\t\tputc('#', dumpfile);\n\t\t\t}\n\t\t\tfputs(sym->name, dumpfile);\n\t\t\tputc(' ', dumpfile);\n\t\t\tif (sym->is_extern)\n\t\t\t\tfputs(\"extern \", dumpfile);\n\t\t\tprint_list(dumpfile, sym->defn);\n\t\t\tputc('\\n', dumpfile);\n\n\t\t\tvisited_symbols = sym->visited;\n\t\t\tsym->visited = NULL;\n\t\t}\n\t}\n\n\tif (flag_debug) {\n\t\tfprintf(debugfile, \"Hash table occupancy %d/%d = %g\\n\",\n\t\t\tnsyms, HASH_BUCKETS,\n\t\t\t(double)nsyms / (double)HASH_BUCKETS);\n\t}\n\n\tif (dumpfile)\n\t\tfclose(dumpfile);\n\n\treturn errors != 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}