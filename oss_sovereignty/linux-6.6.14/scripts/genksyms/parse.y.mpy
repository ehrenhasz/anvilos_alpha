{
  "module_name": "parse.y",
  "hash_id": "7557622e2b2305b19504f4c75ab47ce0ce0adc43b3b54651a4b990360cae66f1",
  "original_prompt": "Ingested from linux-6.6.14/scripts/genksyms/parse.y",
  "human_readable_source": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * C global declaration parser for genksyms.\n * Copyright 1996, 1997 Linux International.\n *\n * New implementation contributed by Richard Henderson <rth@tamu.edu>\n * Based on original work by Bjorn Ekwall <bj0rn@blox.se>\n *\n * This file is part of the Linux modutils.\n */\n\n%{\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"genksyms.h\"\n\nstatic int is_typedef;\nstatic int is_extern;\nstatic char *current_name;\nstatic struct string_list *decl_spec;\n\nstatic void yyerror(const char *);\n\nstatic inline void\nremove_node(struct string_list **p)\n{\n  struct string_list *node = *p;\n  *p = node->next;\n  free_node(node);\n}\n\nstatic inline void\nremove_list(struct string_list **pb, struct string_list **pe)\n{\n  struct string_list *b = *pb, *e = *pe;\n  *pb = e;\n  free_list(b, e);\n}\n\n/* Record definition of a struct/union/enum */\nstatic void record_compound(struct string_list **keyw,\n\t\t       struct string_list **ident,\n\t\t       struct string_list **body,\n\t\t       enum symbol_type type)\n{\n\tstruct string_list *b = *body, *i = *ident, *r;\n\n\tif (i->in_source_file) {\n\t\tremove_node(keyw);\n\t\t(*ident)->tag = type;\n\t\tremove_list(body, ident);\n\t\treturn;\n\t}\n\tr = copy_node(i); r->tag = type;\n\tr->next = (*keyw)->next; *body = r; (*keyw)->next = NULL;\n\tadd_symbol(i->string, type, b, is_extern);\n}\n\n%}\n\n%token ASM_KEYW\n%token ATTRIBUTE_KEYW\n%token AUTO_KEYW\n%token BOOL_KEYW\n%token BUILTIN_INT_KEYW\n%token CHAR_KEYW\n%token CONST_KEYW\n%token DOUBLE_KEYW\n%token ENUM_KEYW\n%token EXTERN_KEYW\n%token EXTENSION_KEYW\n%token FLOAT_KEYW\n%token INLINE_KEYW\n%token INT_KEYW\n%token LONG_KEYW\n%token REGISTER_KEYW\n%token RESTRICT_KEYW\n%token SHORT_KEYW\n%token SIGNED_KEYW\n%token STATIC_KEYW\n%token STATIC_ASSERT_KEYW\n%token STRUCT_KEYW\n%token TYPEDEF_KEYW\n%token UNION_KEYW\n%token UNSIGNED_KEYW\n%token VOID_KEYW\n%token VOLATILE_KEYW\n%token TYPEOF_KEYW\n%token VA_LIST_KEYW\n\n%token EXPORT_SYMBOL_KEYW\n\n%token ASM_PHRASE\n%token ATTRIBUTE_PHRASE\n%token TYPEOF_PHRASE\n%token BRACE_PHRASE\n%token BRACKET_PHRASE\n%token EXPRESSION_PHRASE\n%token STATIC_ASSERT_PHRASE\n\n%token CHAR\n%token DOTS\n%token IDENT\n%token INT\n%token REAL\n%token STRING\n%token TYPE\n%token OTHER\n%token FILENAME\n\n%%\n\ndeclaration_seq:\n\tdeclaration\n\t| declaration_seq declaration\n\t;\n\ndeclaration:\n\t{ is_typedef = 0; is_extern = 0; current_name = NULL; decl_spec = NULL; }\n\tdeclaration1\n\t{ free_list(*$2, NULL); *$2 = NULL; }\n\t;\n\ndeclaration1:\n\tEXTENSION_KEYW TYPEDEF_KEYW { is_typedef = 1; } simple_declaration\n\t\t{ $$ = $4; }\n\t| TYPEDEF_KEYW { is_typedef = 1; } simple_declaration\n\t\t{ $$ = $3; }\n\t| simple_declaration\n\t| function_definition\n\t| asm_definition\n\t| export_definition\n\t| static_assert\n\t| error ';'\t\t\t\t{ $$ = $2; }\n\t| error '}'\t\t\t\t{ $$ = $2; }\n\t;\n\nsimple_declaration:\n\tdecl_specifier_seq_opt init_declarator_list_opt ';'\n\t\t{ if (current_name) {\n\t\t    struct string_list *decl = (*$3)->next;\n\t\t    (*$3)->next = NULL;\n\t\t    add_symbol(current_name,\n\t\t\t       is_typedef ? SYM_TYPEDEF : SYM_NORMAL,\n\t\t\t       decl, is_extern);\n\t\t    current_name = NULL;\n\t\t  }\n\t\t  $$ = $3;\n\t\t}\n\t;\n\ninit_declarator_list_opt:\n\t/* empty */\t\t\t\t{ $$ = NULL; }\n\t| init_declarator_list\n\t;\n\ninit_declarator_list:\n\tinit_declarator\n\t\t{ struct string_list *decl = *$1;\n\t\t  *$1 = NULL;\n\t\t  add_symbol(current_name,\n\t\t\t     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);\n\t\t  current_name = NULL;\n\t\t  $$ = $1;\n\t\t}\n\t| init_declarator_list ',' init_declarator\n\t\t{ struct string_list *decl = *$3;\n\t\t  *$3 = NULL;\n\t\t  free_list(*$2, NULL);\n\t\t  *$2 = decl_spec;\n\t\t  add_symbol(current_name,\n\t\t\t     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);\n\t\t  current_name = NULL;\n\t\t  $$ = $3;\n\t\t}\n\t;\n\ninit_declarator:\n\tdeclarator asm_phrase_opt attribute_opt initializer_opt\n\t\t{ $$ = $4 ? $4 : $3 ? $3 : $2 ? $2 : $1; }\n\t;\n\n/* Hang on to the specifiers so that we can reuse them.  */\ndecl_specifier_seq_opt:\n\t/* empty */\t\t\t\t{ decl_spec = NULL; }\n\t| decl_specifier_seq\n\t;\n\ndecl_specifier_seq:\n\tdecl_specifier\t\t\t\t{ decl_spec = *$1; }\n\t| decl_specifier_seq decl_specifier\t{ decl_spec = *$2; }\n\t;\n\ndecl_specifier:\n\tstorage_class_specifier\n\t\t{ /* Version 2 checksumming ignores storage class, as that\n\t\t     is really irrelevant to the linkage.  */\n\t\t  remove_node($1);\n\t\t  $$ = $1;\n\t\t}\n\t| type_specifier\n\t;\n\nstorage_class_specifier:\n\tAUTO_KEYW\n\t| REGISTER_KEYW\n\t| STATIC_KEYW\n\t| EXTERN_KEYW\t{ is_extern = 1; $$ = $1; }\n\t| INLINE_KEYW\t{ is_extern = 0; $$ = $1; }\n\t;\n\ntype_specifier:\n\tsimple_type_specifier\n\t| cvar_qualifier\n\t| TYPEOF_KEYW '(' parameter_declaration ')'\n\t| TYPEOF_PHRASE\n\n\t/* References to s/u/e's defined elsewhere.  Rearrange things\n\t   so that it is easier to expand the definition fully later.  */\n\t| STRUCT_KEYW IDENT\n\t\t{ remove_node($1); (*$2)->tag = SYM_STRUCT; $$ = $2; }\n\t| UNION_KEYW IDENT\n\t\t{ remove_node($1); (*$2)->tag = SYM_UNION; $$ = $2; }\n\t| ENUM_KEYW IDENT\n\t\t{ remove_node($1); (*$2)->tag = SYM_ENUM; $$ = $2; }\n\n\t/* Full definitions of an s/u/e.  Record it.  */\n\t| STRUCT_KEYW IDENT class_body\n\t\t{ record_compound($1, $2, $3, SYM_STRUCT); $$ = $3; }\n\t| UNION_KEYW IDENT class_body\n\t\t{ record_compound($1, $2, $3, SYM_UNION); $$ = $3; }\n\t| ENUM_KEYW IDENT enum_body\n\t\t{ record_compound($1, $2, $3, SYM_ENUM); $$ = $3; }\n\t/*\n\t * Anonymous enum definition. Tell add_symbol() to restart its counter.\n\t */\n\t| ENUM_KEYW enum_body\n\t\t{ add_symbol(NULL, SYM_ENUM, NULL, 0); $$ = $2; }\n\t/* Anonymous s/u definitions.  Nothing needs doing.  */\n\t| STRUCT_KEYW class_body\t\t\t{ $$ = $2; }\n\t| UNION_KEYW class_body\t\t\t\t{ $$ = $2; }\n\t;\n\nsimple_type_specifier:\n\tCHAR_KEYW\n\t| SHORT_KEYW\n\t| INT_KEYW\n\t| LONG_KEYW\n\t| SIGNED_KEYW\n\t| UNSIGNED_KEYW\n\t| FLOAT_KEYW\n\t| DOUBLE_KEYW\n\t| VOID_KEYW\n\t| BOOL_KEYW\n\t| VA_LIST_KEYW\n\t| BUILTIN_INT_KEYW\n\t| TYPE\t\t\t{ (*$1)->tag = SYM_TYPEDEF; $$ = $1; }\n\t;\n\nptr_operator:\n\t'*' cvar_qualifier_seq_opt\n\t\t{ $$ = $2 ? $2 : $1; }\n\t;\n\ncvar_qualifier_seq_opt:\n\t/* empty */\t\t\t\t\t{ $$ = NULL; }\n\t| cvar_qualifier_seq\n\t;\n\ncvar_qualifier_seq:\n\tcvar_qualifier\n\t| cvar_qualifier_seq cvar_qualifier\t\t{ $$ = $2; }\n\t;\n\ncvar_qualifier:\n\tCONST_KEYW | VOLATILE_KEYW | ATTRIBUTE_PHRASE\n\t| RESTRICT_KEYW\n\t\t{ /* restrict has no effect in prototypes so ignore it */\n\t\t  remove_node($1);\n\t\t  $$ = $1;\n\t\t}\n\t;\n\ndeclarator:\n\tptr_operator declarator\t\t\t{ $$ = $2; }\n\t| direct_declarator\n\t;\n\ndirect_declarator:\n\tIDENT\n\t\t{ if (current_name != NULL) {\n\t\t    error_with_pos(\"unexpected second declaration name\");\n\t\t    YYERROR;\n\t\t  } else {\n\t\t    current_name = (*$1)->string;\n\t\t    $$ = $1;\n\t\t  }\n\t\t}\n\t| TYPE\n\t\t{ if (current_name != NULL) {\n\t\t    error_with_pos(\"unexpected second declaration name\");\n\t\t    YYERROR;\n\t\t  } else {\n\t\t    current_name = (*$1)->string;\n\t\t    $$ = $1;\n\t\t  }\n\t\t}\n\t| direct_declarator '(' parameter_declaration_clause ')'\n\t\t{ $$ = $4; }\n\t| direct_declarator '(' error ')'\n\t\t{ $$ = $4; }\n\t| direct_declarator BRACKET_PHRASE\n\t\t{ $$ = $2; }\n\t| '(' declarator ')'\n\t\t{ $$ = $3; }\n\t;\n\n/* Nested declarators differ from regular declarators in that they do\n   not record the symbols they find in the global symbol table.  */\nnested_declarator:\n\tptr_operator nested_declarator\t\t{ $$ = $2; }\n\t| direct_nested_declarator\n\t;\n\ndirect_nested_declarator:\n\tIDENT\n\t| TYPE\n\t| direct_nested_declarator '(' parameter_declaration_clause ')'\n\t\t{ $$ = $4; }\n\t| direct_nested_declarator '(' error ')'\n\t\t{ $$ = $4; }\n\t| direct_nested_declarator BRACKET_PHRASE\n\t\t{ $$ = $2; }\n\t| '(' nested_declarator ')'\n\t\t{ $$ = $3; }\n\t| '(' error ')'\n\t\t{ $$ = $3; }\n\t;\n\nparameter_declaration_clause:\n\tparameter_declaration_list_opt DOTS\t\t{ $$ = $2; }\n\t| parameter_declaration_list_opt\n\t| parameter_declaration_list ',' DOTS\t\t{ $$ = $3; }\n\t;\n\nparameter_declaration_list_opt:\n\t/* empty */\t\t\t\t\t{ $$ = NULL; }\n\t| parameter_declaration_list\n\t;\n\nparameter_declaration_list:\n\tparameter_declaration\n\t| parameter_declaration_list ',' parameter_declaration\n\t\t{ $$ = $3; }\n\t;\n\nparameter_declaration:\n\tdecl_specifier_seq m_abstract_declarator\n\t\t{ $$ = $2 ? $2 : $1; }\n\t;\n\nm_abstract_declarator:\n\tptr_operator m_abstract_declarator\n\t\t{ $$ = $2 ? $2 : $1; }\n\t| direct_m_abstract_declarator\n\t;\n\ndirect_m_abstract_declarator:\n\t/* empty */\t\t\t\t\t{ $$ = NULL; }\n\t| IDENT\n\t\t{ /* For version 2 checksums, we don't want to remember\n\t\t     private parameter names.  */\n\t\t  remove_node($1);\n\t\t  $$ = $1;\n\t\t}\n\t/* This wasn't really a typedef name but an identifier that\n\t   shadows one.  */\n\t| TYPE\n\t\t{ remove_node($1);\n\t\t  $$ = $1;\n\t\t}\n\t| direct_m_abstract_declarator '(' parameter_declaration_clause ')'\n\t\t{ $$ = $4; }\n\t| direct_m_abstract_declarator '(' error ')'\n\t\t{ $$ = $4; }\n\t| direct_m_abstract_declarator BRACKET_PHRASE\n\t\t{ $$ = $2; }\n\t| '(' m_abstract_declarator ')'\n\t\t{ $$ = $3; }\n\t| '(' error ')'\n\t\t{ $$ = $3; }\n\t;\n\nfunction_definition:\n\tdecl_specifier_seq_opt declarator BRACE_PHRASE\n\t\t{ struct string_list *decl = *$2;\n\t\t  *$2 = NULL;\n\t\t  add_symbol(current_name, SYM_NORMAL, decl, is_extern);\n\t\t  $$ = $3;\n\t\t}\n\t;\n\ninitializer_opt:\n\t/* empty */\t\t\t\t\t{ $$ = NULL; }\n\t| initializer\n\t;\n\n/* We never care about the contents of an initializer.  */\ninitializer:\n\t'=' EXPRESSION_PHRASE\n\t\t{ remove_list($2, &(*$1)->next); $$ = $2; }\n\t;\n\nclass_body:\n\t'{' member_specification_opt '}'\t\t{ $$ = $3; }\n\t| '{' error '}'\t\t\t\t\t{ $$ = $3; }\n\t;\n\nmember_specification_opt:\n\t/* empty */\t\t\t\t\t{ $$ = NULL; }\n\t| member_specification\n\t;\n\nmember_specification:\n\tmember_declaration\n\t| member_specification member_declaration\t{ $$ = $2; }\n\t;\n\nmember_declaration:\n\tdecl_specifier_seq_opt member_declarator_list_opt ';'\n\t\t{ $$ = $3; }\n\t| error ';'\n\t\t{ $$ = $2; }\n\t;\n\nmember_declarator_list_opt:\n\t/* empty */\t\t\t\t\t{ $$ = NULL; }\n\t| member_declarator_list\n\t;\n\nmember_declarator_list:\n\tmember_declarator\n\t| member_declarator_list ',' member_declarator\t{ $$ = $3; }\n\t;\n\nmember_declarator:\n\tnested_declarator attribute_opt\t\t\t{ $$ = $2 ? $2 : $1; }\n\t| IDENT member_bitfield_declarator\t\t{ $$ = $2; }\n\t| member_bitfield_declarator\n\t;\n\nmember_bitfield_declarator:\n\t':' EXPRESSION_PHRASE\t\t\t\t{ $$ = $2; }\n\t;\n\nattribute_opt:\n\t/* empty */\t\t\t\t\t{ $$ = NULL; }\n\t| attribute_opt ATTRIBUTE_PHRASE\n\t;\n\nenum_body:\n\t'{' enumerator_list '}'\t\t\t\t{ $$ = $3; }\n\t| '{' enumerator_list ',' '}'\t\t\t{ $$ = $4; }\n\t ;\n\nenumerator_list:\n\tenumerator\n\t| enumerator_list ',' enumerator\n\nenumerator:\n\tIDENT\n\t\t{\n\t\t\tconst char *name = strdup((*$1)->string);\n\t\t\tadd_symbol(name, SYM_ENUM_CONST, NULL, 0);\n\t\t}\n\t| IDENT '=' EXPRESSION_PHRASE\n\t\t{\n\t\t\tconst char *name = strdup((*$1)->string);\n\t\t\tstruct string_list *expr = copy_list_range(*$3, *$2);\n\t\t\tadd_symbol(name, SYM_ENUM_CONST, expr, 0);\n\t\t}\n\nasm_definition:\n\tASM_PHRASE ';'\t\t\t\t\t{ $$ = $2; }\n\t;\n\nasm_phrase_opt:\n\t/* empty */\t\t\t\t\t{ $$ = NULL; }\n\t| ASM_PHRASE\n\t;\n\nexport_definition:\n\tEXPORT_SYMBOL_KEYW '(' IDENT ')' ';'\n\t\t{ export_symbol((*$3)->string); $$ = $5; }\n\t;\n\n/* Ignore any module scoped _Static_assert(...) */\nstatic_assert:\n\tSTATIC_ASSERT_PHRASE ';'\t\t\t{ $$ = $2; }\n\t;\n\n%%\n\nstatic void\nyyerror(const char *e)\n{\n  error_with_pos(\"%s\", e);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}