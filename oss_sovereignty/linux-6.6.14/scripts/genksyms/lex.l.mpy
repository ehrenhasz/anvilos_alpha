{
  "module_name": "lex.l",
  "hash_id": "9f3b68f2a956faf0ef03b36bd01500177de87ffbe936569047aeb594ed0a6eaa",
  "original_prompt": "Ingested from linux-6.6.14/scripts/genksyms/lex.l",
  "human_readable_source": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * Lexical analysis for genksyms.\n * Copyright 1996, 1997 Linux International.\n *\n * New implementation contributed by Richard Henderson <rth@tamu.edu>\n * Based on original work by Bjorn Ekwall <bj0rn@blox.se>\n *\n * Taken from Linux modutils 2.4.22.\n */\n\n%{\n\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"genksyms.h\"\n#include \"parse.tab.h\"\n\n/* We've got a two-level lexer here.  We let flex do basic tokenization\n   and then we categorize those basic tokens in the second stage.  */\n#define YY_DECL\t\tstatic int yylex1(void)\n\n%}\n\nIDENT\t\t\t[A-Za-z_\\$][A-Za-z0-9_\\$]*\n\nO_INT\t\t\t0[0-7]*\nD_INT\t\t\t[1-9][0-9]*\nX_INT\t\t\t0[Xx][0-9A-Fa-f]+\nI_SUF\t\t\t[Uu]|[Ll]|[Uu][Ll]|[Ll][Uu]\nINT\t\t\t({O_INT}|{D_INT}|{X_INT}){I_SUF}?\n\nFRAC\t\t\t([0-9]*\\.[0-9]+)|([0-9]+\\.)\nEXP\t\t\t[Ee][+-]?[0-9]+\nF_SUF\t\t\t[FfLl]\nREAL\t\t\t({FRAC}{EXP}?{F_SUF}?)|([0-9]+{EXP}{F_SUF}?)\n\nSTRING\t\t\tL?\\\"([^\\\\\\\"]*\\\\.)*[^\\\\\\\"]*\\\"\nCHAR\t\t\tL?\\'([^\\\\\\']*\\\\.)*[^\\\\\\']*\\'\n\nMC_TOKEN\t\t([~%^&*+=|<>/-]=)|(&&)|(\"||\")|(->)|(<<)|(>>)\n\n/* We don't do multiple input files.  */\n%option noyywrap\n\n%option noinput\n\n%%\n\n\n /* Keep track of our location in the original source files.  */\n^#[ \\t]+{INT}[ \\t]+\\\"[^\\\"\\n]+\\\".*\\n\treturn FILENAME;\n^#.*\\n\t\t\t\t\tcur_line++;\n\\n\t\t\t\t\tcur_line++;\n\n /* Ignore all other whitespace.  */\n[ \\t\\f\\v\\r]+\t\t\t\t;\n\n\n{STRING}\t\t\t\treturn STRING;\n{CHAR}\t\t\t\t\treturn CHAR;\n{IDENT}\t\t\t\t\treturn IDENT;\n\n /* The Pedant requires that the other C multi-character tokens be\n    recognized as tokens.  We don't actually use them since we don't\n    parse expressions, but we do want whitespace to be arranged\n    around them properly.  */\n{MC_TOKEN}\t\t\t\treturn OTHER;\n{INT}\t\t\t\t\treturn INT;\n{REAL}\t\t\t\t\treturn REAL;\n\n\"...\"\t\t\t\t\treturn DOTS;\n\n /* All other tokens are single characters.  */\n.\t\t\t\t\treturn yytext[0];\n\n\n%%\n\n/* Bring in the keyword recognizer.  */\n\n#include \"keywords.c\"\n\n\n/* Macros to append to our phrase collection list.  */\n\n/*\n * We mark any token, that that equals to a known enumerator, as\n * SYM_ENUM_CONST. The parser will change this for struct and union tags later,\n * the only problem is struct and union members:\n *    enum e { a, b }; struct s { int a, b; }\n * but in this case, the only effect will be, that the ABI checksums become\n * more volatile, which is acceptable. Also, such collisions are quite rare,\n * so far it was only observed in include/linux/telephony.h.\n */\n#define _APP(T,L)\tdo {\t\t\t\t\t\t   \\\n\t\t\t  cur_node = next_node;\t\t\t\t   \\\n\t\t\t  next_node = xmalloc(sizeof(*next_node));\t   \\\n\t\t\t  next_node->next = cur_node;\t\t\t   \\\n\t\t\t  cur_node->string = memcpy(xmalloc(L+1), T, L+1); \\\n\t\t\t  cur_node->tag =\t\t\t\t   \\\n\t\t\t    find_symbol(cur_node->string, SYM_ENUM_CONST, 1)?\\\n\t\t\t    SYM_ENUM_CONST : SYM_NORMAL ;\t\t   \\\n\t\t\t  cur_node->in_source_file = in_source_file;       \\\n\t\t\t} while (0)\n\n#define APP\t\t_APP(yytext, yyleng)\n\n\n/* The second stage lexer.  Here we incorporate knowledge of the state\n   of the parser to tailor the tokens that are returned.  */\n\nint\nyylex(void)\n{\n  static enum {\n    ST_NOTSTARTED, ST_NORMAL, ST_ATTRIBUTE, ST_ASM, ST_TYPEOF, ST_TYPEOF_1,\n    ST_BRACKET, ST_BRACE, ST_EXPRESSION, ST_STATIC_ASSERT,\n  } lexstate = ST_NOTSTARTED;\n\n  static int suppress_type_lookup, dont_want_brace_phrase;\n  static struct string_list *next_node;\n  static char *source_file;\n\n  int token, count = 0;\n  struct string_list *cur_node;\n\n  if (lexstate == ST_NOTSTARTED)\n    {\n      next_node = xmalloc(sizeof(*next_node));\n      next_node->next = NULL;\n      lexstate = ST_NORMAL;\n    }\n\nrepeat:\n  token = yylex1();\n\n  if (token == 0)\n    return 0;\n  else if (token == FILENAME)\n    {\n      char *file, *e;\n\n      /* Save the filename and line number for later error messages.  */\n\n      if (cur_filename)\n\tfree(cur_filename);\n\n      file = strchr(yytext, '\\\"')+1;\n      e = strchr(file, '\\\"');\n      *e = '\\0';\n      cur_filename = memcpy(xmalloc(e-file+1), file, e-file+1);\n      cur_line = atoi(yytext+2);\n\n      if (!source_file) {\n        source_file = xstrdup(cur_filename);\n        in_source_file = 1;\n      } else {\n        in_source_file = (strcmp(cur_filename, source_file) == 0);\n      }\n\n      goto repeat;\n    }\n\n  switch (lexstate)\n    {\n    case ST_NORMAL:\n      switch (token)\n\t{\n\tcase IDENT:\n\t  APP;\n\t  {\n\t    int r = is_reserved_word(yytext, yyleng);\n\t    if (r >= 0)\n\t      {\n\t\tswitch (token = r)\n\t\t  {\n\t\t  case ATTRIBUTE_KEYW:\n\t\t    lexstate = ST_ATTRIBUTE;\n\t\t    count = 0;\n\t\t    goto repeat;\n\t\t  case ASM_KEYW:\n\t\t    lexstate = ST_ASM;\n\t\t    count = 0;\n\t\t    goto repeat;\n\t\t  case TYPEOF_KEYW:\n\t\t    lexstate = ST_TYPEOF;\n\t\t    count = 0;\n\t\t    goto repeat;\n\n\t\t  case STRUCT_KEYW:\n\t\t  case UNION_KEYW:\n\t\t  case ENUM_KEYW:\n\t\t    dont_want_brace_phrase = 3;\n\t\t    suppress_type_lookup = 2;\n\t\t    goto fini;\n\n\t\t  case EXPORT_SYMBOL_KEYW:\n\t\t      goto fini;\n\n\t\t  case STATIC_ASSERT_KEYW:\n\t\t    lexstate = ST_STATIC_ASSERT;\n\t\t    count = 0;\n\t\t    goto repeat;\n\t\t  }\n\t      }\n\t    if (!suppress_type_lookup)\n\t      {\n\t\tif (find_symbol(yytext, SYM_TYPEDEF, 1))\n\t\t  token = TYPE;\n\t      }\n\t  }\n\t  break;\n\n\tcase '[':\n\t  APP;\n\t  lexstate = ST_BRACKET;\n\t  count = 1;\n\t  goto repeat;\n\n\tcase '{':\n\t  APP;\n\t  if (dont_want_brace_phrase)\n\t    break;\n\t  lexstate = ST_BRACE;\n\t  count = 1;\n\t  goto repeat;\n\n\tcase '=': case ':':\n\t  APP;\n\t  lexstate = ST_EXPRESSION;\n\t  break;\n\n\tdefault:\n\t  APP;\n\t  break;\n\t}\n      break;\n\n    case ST_ATTRIBUTE:\n      APP;\n      switch (token)\n\t{\n\tcase '(':\n\t  ++count;\n\t  goto repeat;\n\tcase ')':\n\t  if (--count == 0)\n\t    {\n\t      lexstate = ST_NORMAL;\n\t      token = ATTRIBUTE_PHRASE;\n\t      break;\n\t    }\n\t  goto repeat;\n\tdefault:\n\t  goto repeat;\n\t}\n      break;\n\n    case ST_ASM:\n      APP;\n      switch (token)\n\t{\n\tcase '(':\n\t  ++count;\n\t  goto repeat;\n\tcase ')':\n\t  if (--count == 0)\n\t    {\n\t      lexstate = ST_NORMAL;\n\t      token = ASM_PHRASE;\n\t      break;\n\t    }\n\t  goto repeat;\n\tdefault:\n\t  goto repeat;\n\t}\n      break;\n\n    case ST_TYPEOF_1:\n      if (token == IDENT)\n\t{\n\t  if (is_reserved_word(yytext, yyleng) >= 0\n\t      || find_symbol(yytext, SYM_TYPEDEF, 1))\n\t    {\n\t      yyless(0);\n\t      unput('(');\n\t      lexstate = ST_NORMAL;\n\t      token = TYPEOF_KEYW;\n\t      break;\n\t    }\n\t  _APP(\"(\", 1);\n\t}\n\tlexstate = ST_TYPEOF;\n\t/* FALLTHRU */\n\n    case ST_TYPEOF:\n      switch (token)\n\t{\n\tcase '(':\n\t  if ( ++count == 1 )\n\t    lexstate = ST_TYPEOF_1;\n\t  else\n\t    APP;\n\t  goto repeat;\n\tcase ')':\n\t  APP;\n\t  if (--count == 0)\n\t    {\n\t      lexstate = ST_NORMAL;\n\t      token = TYPEOF_PHRASE;\n\t      break;\n\t    }\n\t  goto repeat;\n\tdefault:\n\t  APP;\n\t  goto repeat;\n\t}\n      break;\n\n    case ST_BRACKET:\n      APP;\n      switch (token)\n\t{\n\tcase '[':\n\t  ++count;\n\t  goto repeat;\n\tcase ']':\n\t  if (--count == 0)\n\t    {\n\t      lexstate = ST_NORMAL;\n\t      token = BRACKET_PHRASE;\n\t      break;\n\t    }\n\t  goto repeat;\n\tdefault:\n\t  goto repeat;\n\t}\n      break;\n\n    case ST_BRACE:\n      APP;\n      switch (token)\n\t{\n\tcase '{':\n\t  ++count;\n\t  goto repeat;\n\tcase '}':\n\t  if (--count == 0)\n\t    {\n\t      lexstate = ST_NORMAL;\n\t      token = BRACE_PHRASE;\n\t      break;\n\t    }\n\t  goto repeat;\n\tdefault:\n\t  goto repeat;\n\t}\n      break;\n\n    case ST_EXPRESSION:\n      switch (token)\n\t{\n\tcase '(': case '[': case '{':\n\t  ++count;\n\t  APP;\n\t  goto repeat;\n\tcase '}':\n\t  /* is this the last line of an enum declaration? */\n\t  if (count == 0)\n\t    {\n\t      /* Put back the token we just read so's we can find it again\n\t\t after registering the expression.  */\n\t      unput(token);\n\n\t      lexstate = ST_NORMAL;\n\t      token = EXPRESSION_PHRASE;\n\t      break;\n\t    }\n\t  /* FALLTHRU */\n\tcase ')': case ']':\n\t  --count;\n\t  APP;\n\t  goto repeat;\n\tcase ',': case ';':\n\t  if (count == 0)\n\t    {\n\t      /* Put back the token we just read so's we can find it again\n\t\t after registering the expression.  */\n\t      unput(token);\n\n\t      lexstate = ST_NORMAL;\n\t      token = EXPRESSION_PHRASE;\n\t      break;\n\t    }\n\t  APP;\n\t  goto repeat;\n\tdefault:\n\t  APP;\n\t  goto repeat;\n\t}\n      break;\n\n    case ST_STATIC_ASSERT:\n      APP;\n      switch (token)\n\t{\n\tcase '(':\n\t  ++count;\n\t  goto repeat;\n\tcase ')':\n\t  if (--count == 0)\n\t    {\n\t      lexstate = ST_NORMAL;\n\t      token = STATIC_ASSERT_PHRASE;\n\t      break;\n\t    }\n\t  goto repeat;\n\tdefault:\n\t  goto repeat;\n\t}\n      break;\n\n    default:\n      exit(1);\n    }\nfini:\n\n  if (suppress_type_lookup > 0)\n    --suppress_type_lookup;\n  if (dont_want_brace_phrase > 0)\n    --dont_want_brace_phrase;\n\n  yylval = &next_node->next;\n\n  return token;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}