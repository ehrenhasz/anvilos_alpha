{
  "module_name": "generate_rust_analyzer.py",
  "hash_id": "e68b30f9ebfd1af3cff1d1ea16dfec8fa7e3227a509fe20b2d92c75b151c77cf",
  "original_prompt": "Ingested from linux-6.6.14/scripts/generate_rust_analyzer.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n\"\"\"generate_rust_analyzer - Generates the `rust-project.json` file for `rust-analyzer`.\n\"\"\"\n\nimport argparse\nimport json\nimport logging\nimport os\nimport pathlib\nimport sys\n\ndef args_crates_cfgs(cfgs):\n    crates_cfgs = {}\n    for cfg in cfgs:\n        crate, vals = cfg.split(\"=\", 1)\n        crates_cfgs[crate] = vals.replace(\"--cfg\", \"\").split()\n\n    return crates_cfgs\n\ndef generate_crates(srctree, objtree, sysroot_src, external_src, cfgs):\n    # Generate the configuration list.\n    cfg = []\n    with open(objtree / \"include\" / \"generated\" / \"rustc_cfg\") as fd:\n        for line in fd:\n            line = line.replace(\"--cfg=\", \"\")\n            line = line.replace(\"\\n\", \"\")\n            cfg.append(line)\n\n    # Now fill the crates list -- dependencies need to come first.\n    #\n    # Avoid O(n^2) iterations by keeping a map of indexes.\n    crates = []\n    crates_indexes = {}\n    crates_cfgs = args_crates_cfgs(cfgs)\n\n    def append_crate(display_name, root_module, deps, cfg=[], is_workspace_member=True, is_proc_macro=False):\n        crates_indexes[display_name] = len(crates)\n        crates.append({\n            \"display_name\": display_name,\n            \"root_module\": str(root_module),\n            \"is_workspace_member\": is_workspace_member,\n            \"is_proc_macro\": is_proc_macro,\n            \"deps\": [{\"crate\": crates_indexes[dep], \"name\": dep} for dep in deps],\n            \"cfg\": cfg,\n            \"edition\": \"2021\",\n            \"env\": {\n                \"RUST_MODFILE\": \"This is only for rust-analyzer\"\n            }\n        })\n\n    # First, the ones in `rust/` since they are a bit special.\n    append_crate(\n        \"core\",\n        sysroot_src / \"core\" / \"src\" / \"lib.rs\",\n        [],\n        cfg=crates_cfgs.get(\"core\", []),\n        is_workspace_member=False,\n    )\n\n    append_crate(\n        \"compiler_builtins\",\n        srctree / \"rust\" / \"compiler_builtins.rs\",\n        [],\n    )\n\n    append_crate(\n        \"alloc\",\n        srctree / \"rust\" / \"alloc\" / \"lib.rs\",\n        [\"core\", \"compiler_builtins\"],\n        cfg=crates_cfgs.get(\"alloc\", []),\n    )\n\n    append_crate(\n        \"macros\",\n        srctree / \"rust\" / \"macros\" / \"lib.rs\",\n        [],\n        is_proc_macro=True,\n    )\n    crates[-1][\"proc_macro_dylib_path\"] = f\"{objtree}/rust/libmacros.so\"\n\n    append_crate(\n        \"build_error\",\n        srctree / \"rust\" / \"build_error.rs\",\n        [\"core\", \"compiler_builtins\"],\n    )\n\n    append_crate(\n        \"bindings\",\n        srctree / \"rust\"/ \"bindings\" / \"lib.rs\",\n        [\"core\"],\n        cfg=cfg,\n    )\n    crates[-1][\"env\"][\"OBJTREE\"] = str(objtree.resolve(True))\n\n    append_crate(\n        \"kernel\",\n        srctree / \"rust\" / \"kernel\" / \"lib.rs\",\n        [\"core\", \"alloc\", \"macros\", \"build_error\", \"bindings\"],\n        cfg=cfg,\n    )\n    crates[-1][\"source\"] = {\n        \"include_dirs\": [\n            str(srctree / \"rust\" / \"kernel\"),\n            str(objtree / \"rust\")\n        ],\n        \"exclude_dirs\": [],\n    }\n\n    def is_root_crate(build_file, target):\n        try:\n            return f\"{target}.o\" in open(build_file).read()\n        except FileNotFoundError:\n            return False\n\n    # Then, the rest outside of `rust/`.\n    #\n    # We explicitly mention the top-level folders we want to cover.\n    extra_dirs = map(lambda dir: srctree / dir, (\"samples\", \"drivers\"))\n    if external_src is not None:\n        extra_dirs = [external_src]\n    for folder in extra_dirs:\n        for path in folder.rglob(\"*.rs\"):\n            logging.info(\"Checking %s\", path)\n            name = path.name.replace(\".rs\", \"\")\n\n            # Skip those that are not crate roots.\n            if not is_root_crate(path.parent / \"Makefile\", name) and \\\n               not is_root_crate(path.parent / \"Kbuild\", name):\n                continue\n\n            logging.info(\"Adding %s\", name)\n            append_crate(\n                name,\n                path,\n                [\"core\", \"alloc\", \"kernel\"],\n                cfg=cfg,\n            )\n\n    return crates\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--verbose', '-v', action='store_true')\n    parser.add_argument('--cfgs', action='append', default=[])\n    parser.add_argument(\"srctree\", type=pathlib.Path)\n    parser.add_argument(\"objtree\", type=pathlib.Path)\n    parser.add_argument(\"sysroot_src\", type=pathlib.Path)\n    parser.add_argument(\"exttree\", type=pathlib.Path, nargs=\"?\")\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        format=\"[%(asctime)s] [%(levelname)s] %(message)s\",\n        level=logging.INFO if args.verbose else logging.WARNING\n    )\n\n    rust_project = {\n        \"crates\": generate_crates(args.srctree, args.objtree, args.sysroot_src, args.exttree, args.cfgs),\n        \"sysroot_src\": str(args.sysroot_src),\n    }\n\n    json.dump(rust_project, sys.stdout, sort_keys=True, indent=4)\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}