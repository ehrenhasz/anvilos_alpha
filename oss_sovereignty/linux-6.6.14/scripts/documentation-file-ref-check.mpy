{
  "module_name": "documentation-file-ref-check",
  "hash_id": "b6a244364be914631e5046875ad9163557f05d8731837999e7a9ba3b2c8840ec",
  "original_prompt": "Ingested from linux-6.6.14/scripts/documentation-file-ref-check",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# Treewide grep for references to files under Documentation, and report\n# non-existing files in stderr.\n\nuse warnings;\nuse strict;\nuse Getopt::Long qw(:config no_auto_abbrev);\n\n# NOTE: only add things here when the file was gone, but the text wants\n# to mention a past documentation file, for example, to give credits for\n# the original work.\nmy %false_positives = (\n\t\"Documentation/scsi/scsi_mid_low_api.rst\" => \"Documentation/Configure.help\",\n\t\"drivers/vhost/vhost.c\" => \"Documentation/virtual/lguest/lguest.c\",\n);\n\nmy $scriptname = $0;\n$scriptname =~ s,.*/([^/]+/),$1,;\n\n# Parse arguments\nmy $help = 0;\nmy $fix = 0;\nmy $warn = 0;\n\nif (! -e \".git\") {\n\tprintf \"Warning: can't check if file exists, as this is not a git tree\\n\";\n\texit 0;\n}\n\nGetOptions(\n\t'fix' => \\$fix,\n\t'warn' => \\$warn,\n\t'h|help|usage' => \\$help,\n);\n\nif ($help != 0) {\n    print \"$scriptname [--help] [--fix]\\n\";\n    exit -1;\n}\n\n# Step 1: find broken references\nprint \"Finding broken references. This may take a while...  \" if ($fix);\n\nmy %broken_ref;\n\nmy $doc_fix = 0;\n\nopen IN, \"git grep ':doc:\\`' Documentation/|\"\n     or die \"Failed to run git grep\";\nwhile (<IN>) {\n\tnext if (!m,^([^:]+):.*\\:doc\\:\\`([^\\`]+)\\`,);\n\tnext if (m,sphinx/,);\n\n\tmy $file = $1;\n\tmy $d = $1;\n\tmy $doc_ref = $2;\n\n\tmy $f = $doc_ref;\n\n\t$d =~ s,(.*/).*,$1,;\n\t$f =~ s,.*\\<([^\\>]+)\\>,$1,;\n\n\tif ($f =~ m,^/,) {\n\t\t$f = \"$f.rst\";\n\t\t$f =~ s,^/,Documentation/,;\n\t} else {\n\t\t$f = \"$d$f.rst\";\n\t}\n\n\tnext if (grep -e, glob(\"$f\"));\n\n\tif ($fix && !$doc_fix) {\n\t\tprint STDERR \"\\nWARNING: Currently, can't fix broken :doc:`` fields\\n\";\n\t}\n\t$doc_fix++;\n\n\tprint STDERR \"$file: :doc:`$doc_ref`\\n\";\n}\nclose IN;\n\nopen IN, \"git grep 'Documentation/'|\"\n     or die \"Failed to run git grep\";\nwhile (<IN>) {\n\tnext if (!m/^([^:]+):(.*)/);\n\n\tmy $f = $1;\n\tmy $ln = $2;\n\n\t# On linux-next, discard the Next/ directory\n\tnext if ($f =~ m,^Next/,);\n\n\t# Makefiles and scripts contain nasty expressions to parse docs\n\tnext if ($f =~ m/Makefile/ || $f =~ m/\\.sh$/);\n\n\t# It doesn't make sense to parse hidden files\n\tnext if ($f =~ m#/\\.#);\n\n\t# Skip this script\n\tnext if ($f eq $scriptname);\n\n\t# Ignore the dir where documentation will be built\n\tnext if ($ln =~ m,\\b(\\S*)Documentation/output,);\n\n\tif ($ln =~ m,\\b(\\S*)(Documentation/[A-Za-z0-9\\_\\.\\,\\~/\\*\\[\\]\\?+-]*)(.*),) {\n\t\tmy $prefix = $1;\n\t\tmy $ref = $2;\n\t\tmy $base = $2;\n\t\tmy $extra = $3;\n\n\t\t# some file references are like:\n\t\t# /usr/src/linux/Documentation/DMA-{API,mapping}.txt\n\t\t# For now, ignore them\n\t\tnext if ($extra =~ m/^{/);\n\n\t\t# Remove footnotes at the end like:\n\t\t# Documentation/devicetree/dt-object-internal.txt[1]\n\t\t$ref =~ s/(txt|rst)\\[\\d+]$/$1/;\n\n\t\t# Remove ending ']' without any '['\n\t\t$ref =~ s/\\].*// if (!($ref =~ m/\\[/));\n\n\t\t# Remove puntuation marks at the end\n\t\t$ref =~ s/[\\,\\.]+$//;\n\n\t\tmy $fulref = \"$prefix$ref\";\n\n\t\t$fulref =~ s/^(\\<file|ref)://;\n\t\t$fulref =~ s/^[\\'\\`]+//;\n\t\t$fulref =~ s,^\\$\\(.*\\)/,,;\n\t\t$base =~ s,.*/,,;\n\n\t\t# Remove URL false-positives\n\t\tnext if ($fulref =~ m/^http/);\n\n\t\t# Remove sched-pelt false-positive\n\t\tnext if ($fulref =~ m,^Documentation/scheduler/sched-pelt$,);\n\n\t\t# Discard some build examples from Documentation/target/tcm_mod_builder.rst\n\t\tnext if ($fulref =~ m,mnt/sdb/lio-core-2.6.git/Documentation/target,);\n\n\t\t# Check if exists, evaluating wildcards\n\t\tnext if (grep -e, glob(\"$ref $fulref\"));\n\n\t\t# Accept relative Documentation patches for tools/\n\t\tif ($f =~ m/tools/) {\n\t\t\tmy $path = $f;\n\t\t\t$path =~ s,(.*)/.*,$1,;\n\t\t\t$path =~ s,testing/selftests/bpf,bpf/bpftool,;\n\t\t\tnext if (grep -e, glob(\"$path/$ref $path/../$ref $path/$fulref\"));\n\t\t}\n\n\t\t# Discard known false-positives\n\t\tif (defined($false_positives{$f})) {\n\t\t\tnext if ($false_positives{$f} eq $fulref);\n\t\t}\n\n\t\tif ($fix) {\n\t\t\tif (!($ref =~ m/(scripts|Kconfig|Kbuild)/)) {\n\t\t\t\t$broken_ref{$ref}++;\n\t\t\t}\n\t\t} elsif ($warn) {\n\t\t\tprint STDERR \"Warning: $f references a file that doesn't exist: $fulref\\n\";\n\t\t} else {\n\t\t\tprint STDERR \"$f: $fulref\\n\";\n\t\t}\n\t}\n}\nclose IN;\n\nexit 0 if (!$fix);\n\n# Step 2: Seek for file name alternatives\nprint \"Auto-fixing broken references. Please double-check the results\\n\";\n\nforeach my $ref (keys %broken_ref) {\n\tmy $new =$ref;\n\n\tmy $basedir = \".\";\n\t# On translations, only seek inside the translations directory\n\t$basedir  = $1 if ($ref =~ m,(Documentation/translations/[^/]+),);\n\n\t# get just the basename\n\t$new =~ s,.*/,,;\n\n\tmy $f=\"\";\n\n\t# usual reason for breakage: DT file moved around\n\tif ($ref =~ /devicetree/) {\n\t\t# usual reason for breakage: DT file renamed to .yaml\n\t\tif (!$f) {\n\t\t\tmy $new_ref = $ref;\n\t\t\t$new_ref =~ s/\\.txt$/.yaml/;\n\t\t\t$f=$new_ref if (-f $new_ref);\n\t\t}\n\n\t\tif (!$f) {\n\t\t\tmy $search = $new;\n\t\t\t$search =~ s,^.*/,,;\n\t\t\t$f = qx(find Documentation/devicetree/ -iname \"*$search*\") if ($search);\n\t\t\tif (!$f) {\n\t\t\t\t# Manufacturer name may have changed\n\t\t\t\t$search =~ s/^.*,//;\n\t\t\t\t$f = qx(find Documentation/devicetree/ -iname \"*$search*\") if ($search);\n\t\t\t}\n\t\t}\n\t}\n\n\t# usual reason for breakage: file renamed to .rst\n\tif (!$f) {\n\t\t$new =~ s/\\.txt$/.rst/;\n\t\t$f=qx(find $basedir -iname $new) if ($new);\n\t}\n\n\t# usual reason for breakage: use dash or underline\n\tif (!$f) {\n\t\t$new =~ s/[-_]/[-_]/g;\n\t\t$f=qx(find $basedir -iname $new) if ($new);\n\t}\n\n\t# Wild guess: seek for the same name on another place\n\tif (!$f) {\n\t\t$f = qx(find $basedir -iname $new) if ($new);\n\t}\n\n\tmy @find = split /\\s+/, $f;\n\n\tif (!$f) {\n\t\tprint STDERR \"ERROR: Didn't find a replacement for $ref\\n\";\n\t} elsif (scalar(@find) > 1) {\n\t\tprint STDERR \"WARNING: Won't auto-replace, as found multiple files close to $ref:\\n\";\n\t\tforeach my $j (@find) {\n\t\t\t$j =~ s,^./,,;\n\t\t\tprint STDERR \"    $j\\n\";\n\t\t}\n\t} else {\n\t\t$f = $find[0];\n\t\t$f =~ s,^./,,;\n\t\tprint \"INFO: Replacing $ref to $f\\n\";\n\t\tforeach my $j (qx(git grep -l $ref)) {\n\t\t\tqx(sed \"s\\@$ref\\@$f\\@g\" -i $j);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}