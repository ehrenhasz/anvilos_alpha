{
  "module_name": "kallsyms.c",
  "hash_id": "9bb231808620854713100ba0f8c2c99a2c78562d17aab78288043551957c63bf",
  "original_prompt": "Ingested from linux-6.6.14/scripts/kallsyms.c",
  "human_readable_source": " \n\n#include <errno.h>\n#include <getopt.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))\n\n#define KSYM_NAME_LEN\t\t512\n\nstruct sym_entry {\n\tunsigned long long addr;\n\tunsigned int len;\n\tunsigned int seq;\n\tunsigned int start_pos;\n\tunsigned int percpu_absolute;\n\tunsigned char sym[];\n};\n\nstruct addr_range {\n\tconst char *start_sym, *end_sym;\n\tunsigned long long start, end;\n};\n\nstatic unsigned long long _text;\nstatic unsigned long long relative_base;\nstatic struct addr_range text_ranges[] = {\n\t{ \"_stext\",     \"_etext\"     },\n\t{ \"_sinittext\", \"_einittext\" },\n};\n#define text_range_text     (&text_ranges[0])\n#define text_range_inittext (&text_ranges[1])\n\nstatic struct addr_range percpu_range = {\n\t\"__per_cpu_start\", \"__per_cpu_end\", -1ULL, 0\n};\n\nstatic struct sym_entry **table;\nstatic unsigned int table_size, table_cnt;\nstatic int all_symbols;\nstatic int absolute_percpu;\nstatic int base_relative;\nstatic int lto_clang;\n\nstatic int token_profit[0x10000];\n\n \nstatic unsigned char best_table[256][2];\nstatic unsigned char best_table_len[256];\n\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"Usage: kallsyms [--all-symbols] [--absolute-percpu] \"\n\t\t\t\"[--base-relative] [--lto-clang] in.map > out.S\\n\");\n\texit(1);\n}\n\nstatic char *sym_name(const struct sym_entry *s)\n{\n\treturn (char *)s->sym + 1;\n}\n\nstatic bool is_ignored_symbol(const char *name, char type)\n{\n\tif (type == 'u' || type == 'n')\n\t\treturn true;\n\n\tif (toupper(type) == 'A') {\n\t\t \n\t\tif (strcmp(name, \"__kernel_syscall_via_break\") &&\n\t\t    strcmp(name, \"__kernel_syscall_via_epc\") &&\n\t\t    strcmp(name, \"__kernel_sigtramp\") &&\n\t\t    strcmp(name, \"__gp\"))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void check_symbol_range(const char *sym, unsigned long long addr,\n\t\t\t       struct addr_range *ranges, int entries)\n{\n\tsize_t i;\n\tstruct addr_range *ar;\n\n\tfor (i = 0; i < entries; ++i) {\n\t\tar = &ranges[i];\n\n\t\tif (strcmp(sym, ar->start_sym) == 0) {\n\t\t\tar->start = addr;\n\t\t\treturn;\n\t\t} else if (strcmp(sym, ar->end_sym) == 0) {\n\t\t\tar->end = addr;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic struct sym_entry *read_symbol(FILE *in, char **buf, size_t *buf_len)\n{\n\tchar *name, type, *p;\n\tunsigned long long addr;\n\tsize_t len;\n\tssize_t readlen;\n\tstruct sym_entry *sym;\n\n\terrno = 0;\n\treadlen = getline(buf, buf_len, in);\n\tif (readlen < 0) {\n\t\tif (errno) {\n\t\t\tperror(\"read_symbol\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif ((*buf)[readlen - 1] == '\\n')\n\t\t(*buf)[readlen - 1] = 0;\n\n\taddr = strtoull(*buf, &p, 16);\n\n\tif (*buf == p || *p++ != ' ' || !isascii((type = *p++)) || *p++ != ' ') {\n\t\tfprintf(stderr, \"line format error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tname = p;\n\tlen = strlen(name);\n\n\tif (len >= KSYM_NAME_LEN) {\n\t\tfprintf(stderr, \"Symbol %s too long for kallsyms (%zu >= %d).\\n\"\n\t\t\t\t\"Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\\n\",\n\t\t\tname, len, KSYM_NAME_LEN);\n\t\treturn NULL;\n\t}\n\n\tif (strcmp(name, \"_text\") == 0)\n\t\t_text = addr;\n\n\t \n\tif (is_ignored_symbol(name, type))\n\t\treturn NULL;\n\n\tcheck_symbol_range(name, addr, text_ranges, ARRAY_SIZE(text_ranges));\n\tcheck_symbol_range(name, addr, &percpu_range, 1);\n\n\t \n\tlen++;\n\n\tsym = malloc(sizeof(*sym) + len + 1);\n\tif (!sym) {\n\t\tfprintf(stderr, \"kallsyms failure: \"\n\t\t\t\"unable to allocate required amount of memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tsym->addr = addr;\n\tsym->len = len;\n\tsym->sym[0] = type;\n\tstrcpy(sym_name(sym), name);\n\tsym->percpu_absolute = 0;\n\n\treturn sym;\n}\n\nstatic int symbol_in_range(const struct sym_entry *s,\n\t\t\t   const struct addr_range *ranges, int entries)\n{\n\tsize_t i;\n\tconst struct addr_range *ar;\n\n\tfor (i = 0; i < entries; ++i) {\n\t\tar = &ranges[i];\n\n\t\tif (s->addr >= ar->start && s->addr <= ar->end)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int symbol_valid(const struct sym_entry *s)\n{\n\tconst char *name = sym_name(s);\n\n\t \n\tif (!all_symbols) {\n\t\tif (symbol_in_range(s, text_ranges,\n\t\t\t\t    ARRAY_SIZE(text_ranges)) == 0)\n\t\t\treturn 0;\n\t\t \n\t\tif ((s->addr == text_range_text->end &&\n\t\t     strcmp(name, text_range_text->end_sym)) ||\n\t\t    (s->addr == text_range_inittext->end &&\n\t\t     strcmp(name, text_range_inittext->end_sym)))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic void shrink_table(void)\n{\n\tunsigned int i, pos;\n\n\tpos = 0;\n\tfor (i = 0; i < table_cnt; i++) {\n\t\tif (symbol_valid(table[i])) {\n\t\t\tif (pos != i)\n\t\t\t\ttable[pos] = table[i];\n\t\t\tpos++;\n\t\t} else {\n\t\t\tfree(table[i]);\n\t\t}\n\t}\n\ttable_cnt = pos;\n\n\t \n\tif (!table_cnt) {\n\t\tfprintf(stderr, \"No valid symbol.\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void read_map(const char *in)\n{\n\tFILE *fp;\n\tstruct sym_entry *sym;\n\tchar *buf = NULL;\n\tsize_t buflen = 0;\n\n\tfp = fopen(in, \"r\");\n\tif (!fp) {\n\t\tperror(in);\n\t\texit(1);\n\t}\n\n\twhile (!feof(fp)) {\n\t\tsym = read_symbol(fp, &buf, &buflen);\n\t\tif (!sym)\n\t\t\tcontinue;\n\n\t\tsym->start_pos = table_cnt;\n\n\t\tif (table_cnt >= table_size) {\n\t\t\ttable_size += 10000;\n\t\t\ttable = realloc(table, sizeof(*table) * table_size);\n\t\t\tif (!table) {\n\t\t\t\tfprintf(stderr, \"out of memory\\n\");\n\t\t\t\tfclose(fp);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t}\n\n\t\ttable[table_cnt++] = sym;\n\t}\n\n\tfree(buf);\n\tfclose(fp);\n}\n\nstatic void output_label(const char *label)\n{\n\tprintf(\".globl %s\\n\", label);\n\tprintf(\"\\tALGN\\n\");\n\tprintf(\"%s:\\n\", label);\n}\n\n \nstatic void output_address(unsigned long long addr)\n{\n\tif (_text <= addr)\n\t\tprintf(\"\\tPTR\\t_text + %#llx\\n\", addr - _text);\n\telse\n\t\tprintf(\"\\tPTR\\t_text - %#llx\\n\", _text - addr);\n}\n\n \nstatic int expand_symbol(const unsigned char *data, int len, char *result)\n{\n\tint c, rlen, total=0;\n\n\twhile (len) {\n\t\tc = *data;\n\t\t \n\t\tif (best_table[c][0]==c && best_table_len[c]==1) {\n\t\t\t*result++ = c;\n\t\t\ttotal++;\n\t\t} else {\n\t\t\t \n\t\t\trlen = expand_symbol(best_table[c], best_table_len[c], result);\n\t\t\ttotal += rlen;\n\t\t\tresult += rlen;\n\t\t}\n\t\tdata++;\n\t\tlen--;\n\t}\n\t*result=0;\n\n\treturn total;\n}\n\nstatic int symbol_absolute(const struct sym_entry *s)\n{\n\treturn s->percpu_absolute;\n}\n\nstatic void cleanup_symbol_name(char *s)\n{\n\tchar *p;\n\n\t \n\tp = strstr(s, \".llvm.\");\n\tif (p)\n\t\t*p = '\\0';\n}\n\nstatic int compare_names(const void *a, const void *b)\n{\n\tint ret;\n\tconst struct sym_entry *sa = *(const struct sym_entry **)a;\n\tconst struct sym_entry *sb = *(const struct sym_entry **)b;\n\n\tret = strcmp(sym_name(sa), sym_name(sb));\n\tif (!ret) {\n\t\tif (sa->addr > sb->addr)\n\t\t\treturn 1;\n\t\telse if (sa->addr < sb->addr)\n\t\t\treturn -1;\n\n\t\t \n\t\treturn (int)(sa->seq - sb->seq);\n\t}\n\n\treturn ret;\n}\n\nstatic void sort_symbols_by_name(void)\n{\n\tqsort(table, table_cnt, sizeof(table[0]), compare_names);\n}\n\nstatic void write_src(void)\n{\n\tunsigned int i, k, off;\n\tunsigned int best_idx[256];\n\tunsigned int *markers;\n\tchar buf[KSYM_NAME_LEN];\n\n\tprintf(\"#include <asm/bitsperlong.h>\\n\");\n\tprintf(\"#if BITS_PER_LONG == 64\\n\");\n\tprintf(\"#define PTR .quad\\n\");\n\tprintf(\"#define ALGN .balign 8\\n\");\n\tprintf(\"#else\\n\");\n\tprintf(\"#define PTR .long\\n\");\n\tprintf(\"#define ALGN .balign 4\\n\");\n\tprintf(\"#endif\\n\");\n\n\tprintf(\"\\t.section .rodata, \\\"a\\\"\\n\");\n\n\toutput_label(\"kallsyms_num_syms\");\n\tprintf(\"\\t.long\\t%u\\n\", table_cnt);\n\tprintf(\"\\n\");\n\n\t \n\tmarkers = malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));\n\tif (!markers) {\n\t\tfprintf(stderr, \"kallsyms failure: \"\n\t\t\t\"unable to allocate required memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\toutput_label(\"kallsyms_names\");\n\toff = 0;\n\tfor (i = 0; i < table_cnt; i++) {\n\t\tif ((i & 0xFF) == 0)\n\t\t\tmarkers[i >> 8] = off;\n\t\ttable[i]->seq = i;\n\n\t\t \n\t\tif (table[i]->len == 0) {\n\t\t\tfprintf(stderr, \"kallsyms failure: \"\n\t\t\t\t\"unexpected zero symbol length\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t \n\t\tif (table[i]->len > 0x3FFF) {\n\t\t\tfprintf(stderr, \"kallsyms failure: \"\n\t\t\t\t\"unexpected huge symbol length\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t \n\t\tif (table[i]->len <= 0x7F) {\n\t\t\t \n\t\t\tprintf(\"\\t.byte 0x%02x\", table[i]->len);\n\t\t\toff += table[i]->len + 1;\n\t\t} else {\n\t\t\t \n\t\t\tprintf(\"\\t.byte 0x%02x, 0x%02x\",\n\t\t\t\t(table[i]->len & 0x7F) | 0x80,\n\t\t\t\t(table[i]->len >> 7) & 0x7F);\n\t\t\toff += table[i]->len + 2;\n\t\t}\n\t\tfor (k = 0; k < table[i]->len; k++)\n\t\t\tprintf(\", 0x%02x\", table[i]->sym[k]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\n\t \n\tfor (i = 0; i < table_cnt; i++) {\n\t\texpand_symbol(table[i]->sym, table[i]->len, buf);\n\t\tstrcpy((char *)table[i]->sym, buf);\n\t}\n\n\toutput_label(\"kallsyms_markers\");\n\tfor (i = 0; i < ((table_cnt + 255) >> 8); i++)\n\t\tprintf(\"\\t.long\\t%u\\n\", markers[i]);\n\tprintf(\"\\n\");\n\n\tfree(markers);\n\n\toutput_label(\"kallsyms_token_table\");\n\toff = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tbest_idx[i] = off;\n\t\texpand_symbol(best_table[i], best_table_len[i], buf);\n\t\tprintf(\"\\t.asciz\\t\\\"%s\\\"\\n\", buf);\n\t\toff += strlen(buf) + 1;\n\t}\n\tprintf(\"\\n\");\n\n\toutput_label(\"kallsyms_token_index\");\n\tfor (i = 0; i < 256; i++)\n\t\tprintf(\"\\t.short\\t%d\\n\", best_idx[i]);\n\tprintf(\"\\n\");\n\n\tif (!base_relative)\n\t\toutput_label(\"kallsyms_addresses\");\n\telse\n\t\toutput_label(\"kallsyms_offsets\");\n\n\tfor (i = 0; i < table_cnt; i++) {\n\t\tif (base_relative) {\n\t\t\t \n\n\t\t\tlong long offset;\n\t\t\tint overflow;\n\n\t\t\tif (!absolute_percpu) {\n\t\t\t\toffset = table[i]->addr - relative_base;\n\t\t\t\toverflow = (offset < 0 || offset > UINT_MAX);\n\t\t\t} else if (symbol_absolute(table[i])) {\n\t\t\t\toffset = table[i]->addr;\n\t\t\t\toverflow = (offset < 0 || offset > INT_MAX);\n\t\t\t} else {\n\t\t\t\toffset = relative_base - table[i]->addr - 1;\n\t\t\t\toverflow = (offset < INT_MIN || offset >= 0);\n\t\t\t}\n\t\t\tif (overflow) {\n\t\t\t\tfprintf(stderr, \"kallsyms failure: \"\n\t\t\t\t\t\"%s symbol value %#llx out of range in relative mode\\n\",\n\t\t\t\t\tsymbol_absolute(table[i]) ? \"absolute\" : \"relative\",\n\t\t\t\t\ttable[i]->addr);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tprintf(\"\\t.long\\t%#x\t/* %s */\\n\", (int)offset, table[i]->sym);\n\t\t} else if (!symbol_absolute(table[i])) {\n\t\t\toutput_address(table[i]->addr);\n\t\t} else {\n\t\t\tprintf(\"\\tPTR\\t%#llx\\n\", table[i]->addr);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\tif (base_relative) {\n\t\toutput_label(\"kallsyms_relative_base\");\n\t\toutput_address(relative_base);\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (lto_clang)\n\t\tfor (i = 0; i < table_cnt; i++)\n\t\t\tcleanup_symbol_name((char *)table[i]->sym);\n\n\tsort_symbols_by_name();\n\toutput_label(\"kallsyms_seqs_of_names\");\n\tfor (i = 0; i < table_cnt; i++)\n\t\tprintf(\"\\t.byte 0x%02x, 0x%02x, 0x%02x\\n\",\n\t\t\t(unsigned char)(table[i]->seq >> 16),\n\t\t\t(unsigned char)(table[i]->seq >> 8),\n\t\t\t(unsigned char)(table[i]->seq >> 0));\n\tprintf(\"\\n\");\n}\n\n\n \n\n \nstatic void learn_symbol(const unsigned char *symbol, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len - 1; i++)\n\t\ttoken_profit[ symbol[i] + (symbol[i + 1] << 8) ]++;\n}\n\n \nstatic void forget_symbol(const unsigned char *symbol, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len - 1; i++)\n\t\ttoken_profit[ symbol[i] + (symbol[i + 1] << 8) ]--;\n}\n\n \nstatic void build_initial_token_table(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < table_cnt; i++)\n\t\tlearn_symbol(table[i]->sym, table[i]->len);\n}\n\nstatic unsigned char *find_token(unsigned char *str, int len,\n\t\t\t\t const unsigned char *token)\n{\n\tint i;\n\n\tfor (i = 0; i < len - 1; i++) {\n\t\tif (str[i] == token[0] && str[i+1] == token[1])\n\t\t\treturn &str[i];\n\t}\n\treturn NULL;\n}\n\n \nstatic void compress_symbols(const unsigned char *str, int idx)\n{\n\tunsigned int i, len, size;\n\tunsigned char *p1, *p2;\n\n\tfor (i = 0; i < table_cnt; i++) {\n\n\t\tlen = table[i]->len;\n\t\tp1 = table[i]->sym;\n\n\t\t \n\t\tp2 = find_token(p1, len, str);\n\t\tif (!p2) continue;\n\n\t\t \n\t\tforget_symbol(table[i]->sym, len);\n\n\t\tsize = len;\n\n\t\tdo {\n\t\t\t*p2 = idx;\n\t\t\tp2++;\n\t\t\tsize -= (p2 - p1);\n\t\t\tmemmove(p2, p2 + 1, size);\n\t\t\tp1 = p2;\n\t\t\tlen--;\n\n\t\t\tif (size < 2) break;\n\n\t\t\t \n\t\t\tp2 = find_token(p1, size, str);\n\n\t\t} while (p2);\n\n\t\ttable[i]->len = len;\n\n\t\t \n\t\tlearn_symbol(table[i]->sym, len);\n\t}\n}\n\n \nstatic int find_best_token(void)\n{\n\tint i, best, bestprofit;\n\n\tbestprofit=-10000;\n\tbest = 0;\n\n\tfor (i = 0; i < 0x10000; i++) {\n\t\tif (token_profit[i] > bestprofit) {\n\t\t\tbest = i;\n\t\t\tbestprofit = token_profit[i];\n\t\t}\n\t}\n\treturn best;\n}\n\n \nstatic void optimize_result(void)\n{\n\tint i, best;\n\n\t \n\tfor (i = 255; i >= 0; i--) {\n\n\t\t \n\t\tif (!best_table_len[i]) {\n\n\t\t\t \n\t\t\tbest = find_best_token();\n\t\t\tif (token_profit[best] == 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tbest_table_len[i] = 2;\n\t\t\tbest_table[i][0] = best & 0xFF;\n\t\t\tbest_table[i][1] = (best >> 8) & 0xFF;\n\n\t\t\t \n\t\t\tcompress_symbols(best_table[i], i);\n\t\t}\n\t}\n}\n\n \nstatic void insert_real_symbols_in_table(void)\n{\n\tunsigned int i, j, c;\n\n\tfor (i = 0; i < table_cnt; i++) {\n\t\tfor (j = 0; j < table[i]->len; j++) {\n\t\t\tc = table[i]->sym[j];\n\t\t\tbest_table[c][0]=c;\n\t\t\tbest_table_len[c]=1;\n\t\t}\n\t}\n}\n\nstatic void optimize_token_table(void)\n{\n\tbuild_initial_token_table();\n\n\tinsert_real_symbols_in_table();\n\n\toptimize_result();\n}\n\n \nstatic int may_be_linker_script_provide_symbol(const struct sym_entry *se)\n{\n\tconst char *symbol = sym_name(se);\n\tint len = se->len - 1;\n\n\tif (len < 8)\n\t\treturn 0;\n\n\tif (symbol[0] != '_' || symbol[1] != '_')\n\t\treturn 0;\n\n\t \n\tif (!memcmp(symbol + 2, \"start_\", 6))\n\t\treturn 1;\n\n\t \n\tif (!memcmp(symbol + 2, \"stop_\", 5))\n\t\treturn 1;\n\n\t \n\tif (!memcmp(symbol + 2, \"end_\", 4))\n\t\treturn 1;\n\n\t \n\tif (!memcmp(symbol + len - 6, \"_start\", 6))\n\t\treturn 1;\n\n\t \n\tif (!memcmp(symbol + len - 4, \"_end\", 4))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int compare_symbols(const void *a, const void *b)\n{\n\tconst struct sym_entry *sa = *(const struct sym_entry **)a;\n\tconst struct sym_entry *sb = *(const struct sym_entry **)b;\n\tint wa, wb;\n\n\t \n\tif (sa->addr > sb->addr)\n\t\treturn 1;\n\tif (sa->addr < sb->addr)\n\t\treturn -1;\n\n\t \n\twa = (sa->sym[0] == 'w') || (sa->sym[0] == 'W');\n\twb = (sb->sym[0] == 'w') || (sb->sym[0] == 'W');\n\tif (wa != wb)\n\t\treturn wa - wb;\n\n\t \n\twa = may_be_linker_script_provide_symbol(sa);\n\twb = may_be_linker_script_provide_symbol(sb);\n\tif (wa != wb)\n\t\treturn wa - wb;\n\n\t \n\twa = strspn(sym_name(sa), \"_\");\n\twb = strspn(sym_name(sb), \"_\");\n\tif (wa != wb)\n\t\treturn wa - wb;\n\n\t \n\treturn sa->start_pos - sb->start_pos;\n}\n\nstatic void sort_symbols(void)\n{\n\tqsort(table, table_cnt, sizeof(table[0]), compare_symbols);\n}\n\nstatic void make_percpus_absolute(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < table_cnt; i++)\n\t\tif (symbol_in_range(table[i], &percpu_range, 1)) {\n\t\t\t \n\t\t\ttable[i]->sym[0] = 'A';\n\t\t\ttable[i]->percpu_absolute = 1;\n\t\t}\n}\n\n \nstatic void record_relative_base(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < table_cnt; i++)\n\t\tif (!symbol_absolute(table[i])) {\n\t\t\t \n\t\t\trelative_base = table[i]->addr;\n\t\t\treturn;\n\t\t}\n}\n\nint main(int argc, char **argv)\n{\n\twhile (1) {\n\t\tstatic const struct option long_options[] = {\n\t\t\t{\"all-symbols\",     no_argument, &all_symbols,     1},\n\t\t\t{\"absolute-percpu\", no_argument, &absolute_percpu, 1},\n\t\t\t{\"base-relative\",   no_argument, &base_relative,   1},\n\t\t\t{\"lto-clang\",       no_argument, &lto_clang,       1},\n\t\t\t{},\n\t\t};\n\n\t\tint c = getopt_long(argc, argv, \"\", long_options, NULL);\n\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tif (c != 0)\n\t\t\tusage();\n\t}\n\n\tif (optind >= argc)\n\t\tusage();\n\n\tread_map(argv[optind]);\n\tshrink_table();\n\tif (absolute_percpu)\n\t\tmake_percpus_absolute();\n\tsort_symbols();\n\tif (base_relative)\n\t\trecord_relative_base();\n\toptimize_token_table();\n\twrite_src();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}