{
  "module_name": "setlocalversion",
  "hash_id": "e10013cf73f84fd8a519aa0243f4387314165571b1ccb43cd114a05b3b56db4e",
  "original_prompt": "Ingested from linux-6.6.14/scripts/setlocalversion",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# This scripts adds local version information from the version\n# control system git.\n#\n# If something goes wrong, send a mail the kernel build mailinglist\n# (see MAINTAINERS) and CC Nico Schottelius\n# <nico-linuxsetlocalversion -at- schottelius.org>.\n#\n#\n\nusage() {\n\techo \"Usage: $0 [--no-local] [srctree]\" >&2\n\texit 1\n}\n\nno_local=false\nif test \"$1\" = \"--no-local\"; then\n\tno_local=true\n\tshift\nfi\n\nsrctree=.\nif test $# -gt 0; then\n\tsrctree=$1\n\tshift\nfi\nif test $# -gt 0 -o ! -d \"$srctree\"; then\n\tusage\nfi\n\nscm_version()\n{\n\tlocal short=false\n\tlocal no_dirty=false\n\tlocal tag\n\n\twhile [ $# -gt 0 ];\n\tdo\n\t\tcase \"$1\" in\n\t\t--short)\n\t\t\tshort=true;;\n\t\t--no-dirty)\n\t\t\tno_dirty=true;;\n\t\tesac\n\t\tshift\n\tdone\n\n\tcd \"$srctree\"\n\n\tif test -n \"$(git rev-parse --show-cdup 2>/dev/null)\"; then\n\t\treturn\n\tfi\n\n\tif ! head=$(git rev-parse --verify HEAD 2>/dev/null); then\n\t\treturn\n\tfi\n\n\t# mainline kernel:  6.2.0-rc5  ->  v6.2-rc5\n\t# stable kernel:    6.1.7      ->  v6.1.7\n\tversion_tag=v$(echo \"${KERNELVERSION}\" | sed -E 's/^([0-9]+\\.[0-9]+)\\.0(.*)$/\\1\\2/')\n\n\t# If a localversion* file exists, and the corresponding\n\t# annotated tag exists and is an ancestor of HEAD, use\n\t# it. This is the case in linux-next.\n\ttag=${file_localversion#-}\n\tdesc=\n\tif [ -n \"${tag}\" ]; then\n\t\tdesc=$(git describe --match=$tag 2>/dev/null)\n\tfi\n\n\t# Otherwise, if a localversion* file exists, and the tag\n\t# obtained by appending it to the tag derived from\n\t# KERNELVERSION exists and is an ancestor of HEAD, use\n\t# it. This is e.g. the case in linux-rt.\n\tif [ -z \"${desc}\" ] && [ -n \"${file_localversion}\" ]; then\n\t\ttag=\"${version_tag}${file_localversion}\"\n\t\tdesc=$(git describe --match=$tag 2>/dev/null)\n\tfi\n\n\t# Otherwise, default to the annotated tag derived from KERNELVERSION.\n\tif [ -z \"${desc}\" ]; then\n\t\ttag=\"${version_tag}\"\n\t\tdesc=$(git describe --match=$tag 2>/dev/null)\n\tfi\n\n\t# If we are at the tagged commit, we ignore it because the version is\n\t# well-defined.\n\tif [ \"${tag}\" != \"${desc}\" ]; then\n\n\t\t# If only the short version is requested, don't bother\n\t\t# running further git commands\n\t\tif $short; then\n\t\t\techo \"+\"\n\t\t\treturn\n\t\tfi\n\t\t# If we are past the tagged commit, we pretty print it.\n\t\t# (like 6.1.0-14595-g292a089d78d3)\n\t\tif [ -n \"${desc}\" ]; then\n\t\t\techo \"${desc}\" | awk -F- '{printf(\"-%05d\", $(NF-1))}'\n\t\tfi\n\n\t\t# Add -g and exactly 12 hex chars.\n\t\tprintf '%s%s' -g \"$(echo $head | cut -c1-12)\"\n\tfi\n\n\tif ${no_dirty}; then\n\t\treturn\n\tfi\n\n\t# Check for uncommitted changes.\n\t# This script must avoid any write attempt to the source tree, which\n\t# might be read-only.\n\t# You cannot use 'git describe --dirty' because it tries to create\n\t# .git/index.lock .\n\t# First, with git-status, but --no-optional-locks is only supported in\n\t# git >= 2.14, so fall back to git-diff-index if it fails. Note that\n\t# git-diff-index does not refresh the index, so it may give misleading\n\t# results.\n\t# See git-update-index(1), git-diff-index(1), and git-status(1).\n\tif {\n\t\tgit --no-optional-locks status -uno --porcelain 2>/dev/null ||\n\t\tgit diff-index --name-only HEAD\n\t} | read dummy; then\n\t\tprintf '%s' -dirty\n\tfi\n}\n\ncollect_files()\n{\n\tlocal file res=\n\n\tfor file; do\n\t\tcase \"$file\" in\n\t\t*\\~*)\n\t\t\tcontinue\n\t\t\t;;\n\t\tesac\n\t\tif test -e \"$file\"; then\n\t\t\tres=\"$res$(cat \"$file\")\"\n\t\tfi\n\tdone\n\techo \"$res\"\n}\n\nif [ -z \"${KERNELVERSION}\" ]; then\n\techo \"KERNELVERSION is not set\" >&2\n\texit 1\nfi\n\n# localversion* files in the build and source directory\nfile_localversion=\"$(collect_files localversion*)\"\nif test ! \"$srctree\" -ef .; then\n\tfile_localversion=\"${file_localversion}$(collect_files \"$srctree\"/localversion*)\"\nfi\n\nif ${no_local}; then\n\techo \"${KERNELVERSION}$(scm_version --no-dirty)\"\n\texit 0\nfi\n\nif ! test -e include/config/auto.conf; then\n\techo \"Error: kernelrelease not valid - run 'make prepare' to update it\" >&2\n\texit 1\nfi\n\n# version string from CONFIG_LOCALVERSION\nconfig_localversion=$(sed -n 's/^CONFIG_LOCALVERSION=\\(.*\\)$/\\1/p' include/config/auto.conf)\n\n# scm version string if not at the kernel version tag or at the file_localversion\nif grep -q \"^CONFIG_LOCALVERSION_AUTO=y$\" include/config/auto.conf; then\n\t# full scm version string\n\tscm_version=\"$(scm_version)\"\nelif [ \"${LOCALVERSION+set}\" != \"set\" ]; then\n\t# If the variable LOCALVERSION is not set, append a plus\n\t# sign if the repository is not in a clean annotated or\n\t# signed tagged state (as git describe only looks at signed\n\t# or annotated tags - git tag -a/-s).\n\t#\n\t# If the variable LOCALVERSION is set (including being set\n\t# to an empty string), we don't want to append a plus sign.\n\tscm_version=\"$(scm_version --short)\"\nfi\n\necho \"${KERNELVERSION}${file_localversion}${config_localversion}${LOCALVERSION}${scm_version}\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}