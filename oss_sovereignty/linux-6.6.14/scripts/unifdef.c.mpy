{
  "module_name": "unifdef.c",
  "hash_id": "728597ee3ef501dae51b0a90d0a2a671f6d3069c145dac4b8d174f6f2bb590d7",
  "original_prompt": "Ingested from linux-6.6.14/scripts/unifdef.c",
  "human_readable_source": " \n\n \n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <ctype.h>\n#include <err.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nconst char copyright[] =\n    \"@(#) $Version: unifdef-2.5 $\\n\"\n    \"@(#) $Author: Tony Finch (dot@dotat.at) $\\n\"\n    \"@(#) $URL: http://dotat.at/prog/unifdef $\\n\"\n;\n\n \ntypedef enum {\n\tLT_TRUEI,\t\t \n\tLT_FALSEI,\t\t \n\tLT_IF,\t\t\t \n\tLT_TRUE,\t\t \n\tLT_FALSE,\t\t \n\tLT_ELIF,\t\t \n\tLT_ELTRUE,\t\t \n\tLT_ELFALSE,\t\t \n\tLT_ELSE,\t\t \n\tLT_ENDIF,\t\t \n\tLT_DODGY,\t\t \n\tLT_DODGY_LAST = LT_DODGY + LT_ENDIF,\n\tLT_PLAIN,\t\t \n\tLT_EOF,\t\t\t \n\tLT_ERROR,\t\t \n\tLT_COUNT\n} Linetype;\n\nstatic char const * const linetype_name[] = {\n\t\"TRUEI\", \"FALSEI\", \"IF\", \"TRUE\", \"FALSE\",\n\t\"ELIF\", \"ELTRUE\", \"ELFALSE\", \"ELSE\", \"ENDIF\",\n\t\"DODGY TRUEI\", \"DODGY FALSEI\",\n\t\"DODGY IF\", \"DODGY TRUE\", \"DODGY FALSE\",\n\t\"DODGY ELIF\", \"DODGY ELTRUE\", \"DODGY ELFALSE\",\n\t\"DODGY ELSE\", \"DODGY ENDIF\",\n\t\"PLAIN\", \"EOF\", \"ERROR\"\n};\n\n \ntypedef enum {\n\tIS_OUTSIDE,\n\tIS_FALSE_PREFIX,\t \n\tIS_TRUE_PREFIX,\t\t \n\tIS_PASS_MIDDLE,\t\t \n\tIS_FALSE_MIDDLE,\t \n\tIS_TRUE_MIDDLE,\t\t \n\tIS_PASS_ELSE,\t\t \n\tIS_FALSE_ELSE,\t\t \n\tIS_TRUE_ELSE,\t\t \n\tIS_FALSE_TRAILER,\t \n\tIS_COUNT\n} Ifstate;\n\nstatic char const * const ifstate_name[] = {\n\t\"OUTSIDE\", \"FALSE_PREFIX\", \"TRUE_PREFIX\",\n\t\"PASS_MIDDLE\", \"FALSE_MIDDLE\", \"TRUE_MIDDLE\",\n\t\"PASS_ELSE\", \"FALSE_ELSE\", \"TRUE_ELSE\",\n\t\"FALSE_TRAILER\"\n};\n\n \ntypedef enum {\n\tNO_COMMENT = false,\t \n\tC_COMMENT,\t\t \n\tCXX_COMMENT,\t\t \n\tSTARTING_COMMENT,\t \n\tFINISHING_COMMENT,\t \n\tCHAR_LITERAL,\t\t \n\tSTRING_LITERAL\t\t \n} Comment_state;\n\nstatic char const * const comment_name[] = {\n\t\"NO\", \"C\", \"CXX\", \"STARTING\", \"FINISHING\", \"CHAR\", \"STRING\"\n};\n\n \ntypedef enum {\n\tLS_START,\t\t \n\tLS_HASH,\t\t \n\tLS_DIRTY\t\t \n} Line_state;\n\nstatic char const * const linestate_name[] = {\n\t\"START\", \"HASH\", \"DIRTY\"\n};\n\n \n#define\tMAXDEPTH        64\t\t\t \n#define\tMAXLINE         4096\t\t\t \n#define\tMAXSYMS         4096\t\t\t \n\n \n#define\tEDITSLOP        10\n\n \n#define TEMPLATE        \"unifdef.XXXXXX\"\n\n \n\nstatic bool             compblank;\t\t \nstatic bool             lnblank;\t\t \nstatic bool             complement;\t\t \nstatic bool             debugging;\t\t \nstatic bool             iocccok;\t\t \nstatic bool             strictlogic;\t\t \nstatic bool             killconsts;\t\t \nstatic bool             lnnum;\t\t\t \nstatic bool             symlist;\t\t \nstatic bool             symdepth;\t\t \nstatic bool             text;\t\t\t \n\nstatic const char      *symname[MAXSYMS];\t \nstatic const char      *value[MAXSYMS];\t\t \nstatic bool             ignore[MAXSYMS];\t \nstatic int              nsyms;\t\t\t \n\nstatic FILE            *input;\t\t\t \nstatic const char      *filename;\t\t \nstatic int              linenum;\t\t \nstatic FILE            *output;\t\t\t \nstatic const char      *ofilename;\t\t \nstatic bool             overwriting;\t\t \nstatic char             tempname[FILENAME_MAX];\t \n\nstatic char             tline[MAXLINE+EDITSLOP]; \nstatic char            *keyword;\t\t \n\nstatic const char      *newline;\t\t \nstatic const char       newline_unix[] = \"\\n\";\nstatic const char       newline_crlf[] = \"\\r\\n\";\n\nstatic Comment_state    incomment;\t\t \nstatic Line_state       linestate;\t\t \nstatic Ifstate          ifstate[MAXDEPTH];\t \nstatic bool             ignoring[MAXDEPTH];\t \nstatic int              stifline[MAXDEPTH];\t \nstatic int              depth;\t\t\t \nstatic int              delcount;\t\t \nstatic unsigned         blankcount;\t\t \nstatic unsigned         blankmax;\t\t \nstatic bool             constexpr;\t\t \nstatic bool             zerosyms = true;\t \nstatic bool             firstsym;\t\t \n\nstatic int              exitstat;\t\t \n\nstatic void             addsym(bool, bool, char *);\nstatic void             closeout(void);\nstatic void             debug(const char *, ...);\nstatic void             done(void);\nstatic void             error(const char *);\nstatic int              findsym(const char *);\nstatic void             flushline(bool);\nstatic Linetype         parseline(void);\nstatic Linetype         ifeval(const char **);\nstatic void             ignoreoff(void);\nstatic void             ignoreon(void);\nstatic void             keywordedit(const char *);\nstatic void             nest(void);\nstatic void             process(void);\nstatic const char      *skipargs(const char *);\nstatic const char      *skipcomment(const char *);\nstatic const char      *skipsym(const char *);\nstatic void             state(Ifstate);\nstatic int              strlcmp(const char *, const char *, size_t);\nstatic void             unnest(void);\nstatic void             usage(void);\nstatic void             version(void);\n\n#define endsym(c) (!isalnum((unsigned char)c) && c != '_')\n\n \nint\nmain(int argc, char *argv[])\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"i:D:U:I:o:bBcdeKklnsStV\")) != -1)\n\t\tswitch (opt) {\n\t\tcase 'i':  \n\t\t\t \n\t\t\topt = *optarg++;\n\t\t\tif (opt == 'D')\n\t\t\t\taddsym(true, true, optarg);\n\t\t\telse if (opt == 'U')\n\t\t\t\taddsym(true, false, optarg);\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'D':  \n\t\t\taddsym(false, true, optarg);\n\t\t\tbreak;\n\t\tcase 'U':  \n\t\t\taddsym(false, false, optarg);\n\t\t\tbreak;\n\t\tcase 'I':  \n\t\t\tbreak;\n\t\tcase 'b':  \n\t\tcase 'l':  \n\t\t\tlnblank = true;\n\t\t\tbreak;\n\t\tcase 'B':  \n\t\t\tcompblank = true;\n\t\t\tbreak;\n\t\tcase 'c':  \n\t\t\tcomplement = true;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebugging = true;\n\t\t\tbreak;\n\t\tcase 'e':  \n\t\t\tiocccok = true;\n\t\t\tbreak;\n\t\tcase 'K':  \n\t\t\tstrictlogic = true;\n\t\t\tbreak;\n\t\tcase 'k':  \n\t\t\tkillconsts = true;\n\t\t\tbreak;\n\t\tcase 'n':  \n\t\t\tlnnum = true;\n\t\t\tbreak;\n\t\tcase 'o':  \n\t\t\tofilename = optarg;\n\t\t\tbreak;\n\t\tcase 's':  \n\t\t\tsymlist = true;\n\t\t\tbreak;\n\t\tcase 'S':  \n\t\t\tsymlist = symdepth = true;\n\t\t\tbreak;\n\t\tcase 't':  \n\t\t\ttext = true;\n\t\t\tbreak;\n\t\tcase 'V':  \n\t\t\tversion();\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\tif (compblank && lnblank)\n\t\terrx(2, \"-B and -b are mutually exclusive\");\n\tif (argc > 1) {\n\t\terrx(2, \"can only do one file\");\n\t} else if (argc == 1 && strcmp(*argv, \"-\") != 0) {\n\t\tfilename = *argv;\n\t\tinput = fopen(filename, \"rb\");\n\t\tif (input == NULL)\n\t\t\terr(2, \"can't open %s\", filename);\n\t} else {\n\t\tfilename = \"[stdin]\";\n\t\tinput = stdin;\n\t}\n\tif (ofilename == NULL) {\n\t\tofilename = \"[stdout]\";\n\t\toutput = stdout;\n\t} else {\n\t\tstruct stat ist, ost;\n\t\tif (stat(ofilename, &ost) == 0 &&\n\t\t    fstat(fileno(input), &ist) == 0)\n\t\t\toverwriting = (ist.st_dev == ost.st_dev\n\t\t\t\t    && ist.st_ino == ost.st_ino);\n\t\tif (overwriting) {\n\t\t\tconst char *dirsep;\n\t\t\tint ofd;\n\n\t\t\tdirsep = strrchr(ofilename, '/');\n\t\t\tif (dirsep != NULL)\n\t\t\t\tsnprintf(tempname, sizeof(tempname),\n\t\t\t\t    \"%.*s/\" TEMPLATE,\n\t\t\t\t    (int)(dirsep - ofilename), ofilename);\n\t\t\telse\n\t\t\t\tsnprintf(tempname, sizeof(tempname),\n\t\t\t\t    TEMPLATE);\n\t\t\tofd = mkstemp(tempname);\n\t\t\tif (ofd != -1)\n\t\t\t\toutput = fdopen(ofd, \"wb+\");\n\t\t\tif (output == NULL)\n\t\t\t\terr(2, \"can't create temporary file\");\n\t\t\tfchmod(ofd, ist.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO));\n\t\t} else {\n\t\t\toutput = fopen(ofilename, \"wb\");\n\t\t\tif (output == NULL)\n\t\t\t\terr(2, \"can't open %s\", ofilename);\n\t\t}\n\t}\n\tprocess();\n\tabort();  \n}\n\nstatic void\nversion(void)\n{\n\tconst char *c = copyright;\n\tfor (;;) {\n\t\twhile (*++c != '$')\n\t\t\tif (*c == '\\0')\n\t\t\t\texit(0);\n\t\twhile (*++c != '$')\n\t\t\tputc(*c, stderr);\n\t\tputc('\\n', stderr);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"usage: unifdef [-bBcdeKknsStV] [-Ipath]\"\n\t    \" [-Dsym[=val]] [-Usym] [-iDsym[=val]] [-iUsym] ... [file]\\n\");\n\texit(2);\n}\n\n \ntypedef void state_fn(void);\n\n \nstatic void Eelif (void) { error(\"Inappropriate #elif\"); }\nstatic void Eelse (void) { error(\"Inappropriate #else\"); }\nstatic void Eendif(void) { error(\"Inappropriate #endif\"); }\nstatic void Eeof  (void) { error(\"Premature EOF\"); }\nstatic void Eioccc(void) { error(\"Obfuscated preprocessor control line\"); }\n \nstatic void print (void) { flushline(true); }\nstatic void drop  (void) { flushline(false); }\n \nstatic void Strue (void) { drop();  ignoreoff(); state(IS_TRUE_PREFIX); }\nstatic void Sfalse(void) { drop();  ignoreoff(); state(IS_FALSE_PREFIX); }\nstatic void Selse (void) { drop();               state(IS_TRUE_ELSE); }\n \nstatic void Pelif (void) { print(); ignoreoff(); state(IS_PASS_MIDDLE); }\nstatic void Pelse (void) { print();              state(IS_PASS_ELSE); }\nstatic void Pendif(void) { print(); unnest(); }\n \nstatic void Dfalse(void) { drop();  ignoreoff(); state(IS_FALSE_TRAILER); }\nstatic void Delif (void) { drop();  ignoreoff(); state(IS_FALSE_MIDDLE); }\nstatic void Delse (void) { drop();               state(IS_FALSE_ELSE); }\nstatic void Dendif(void) { drop();  unnest(); }\n \nstatic void Fdrop (void) { nest();  Dfalse(); }\nstatic void Fpass (void) { nest();  Pelif(); }\nstatic void Ftrue (void) { nest();  Strue(); }\nstatic void Ffalse(void) { nest();  Sfalse(); }\n \nstatic void Oiffy (void) { if (!iocccok) Eioccc(); Fpass(); ignoreon(); }\nstatic void Oif   (void) { if (!iocccok) Eioccc(); Fpass(); }\nstatic void Oelif (void) { if (!iocccok) Eioccc(); Pelif(); }\n \nstatic void Idrop (void) { Fdrop();  ignoreon(); }\nstatic void Itrue (void) { Ftrue();  ignoreon(); }\nstatic void Ifalse(void) { Ffalse(); ignoreon(); }\n \nstatic void Mpass (void) { memcpy(keyword, \"if  \", 4); Pelif(); }\nstatic void Mtrue (void) { keywordedit(\"else\");  state(IS_TRUE_MIDDLE); }\nstatic void Melif (void) { keywordedit(\"endif\"); state(IS_FALSE_TRAILER); }\nstatic void Melse (void) { keywordedit(\"endif\"); state(IS_FALSE_ELSE); }\n\nstatic state_fn * const trans_table[IS_COUNT][LT_COUNT] = {\n \n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Eendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Eendif,\n  print, done,  abort },\n \n{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Mpass, Strue, Sfalse,Selse, Dendif,\n  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Mpass, Eioccc,Eioccc,Eioccc,Eioccc,\n  drop,  Eeof,  abort },\n \n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Dfalse,Dfalse,Dfalse,Delse, Dendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eioccc,Eioccc,Eioccc,Eioccc,Eioccc,\n  print, Eeof,  abort },\n \n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Pelif, Mtrue, Delif, Pelse, Pendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Pelif, Oelif, Oelif, Pelse, Pendif,\n  print, Eeof,  abort },\n \n{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Pelif, Mtrue, Delif, Pelse, Pendif,\n  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eioccc,Eioccc,Eioccc,Eioccc,Eioccc,\n  drop,  Eeof,  abort },\n \n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Melif, Melif, Melif, Melse, Pendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eioccc,Eioccc,Eioccc,Eioccc,Pendif,\n  print, Eeof,  abort },\n \n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Pendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Pendif,\n  print, Eeof,  abort },\n \n{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eelif, Eelif, Eelif, Eelse, Dendif,\n  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eelif, Eelif, Eelif, Eelse, Eioccc,\n  drop,  Eeof,  abort },\n \n{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Dendif,\n  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Eioccc,\n  print, Eeof,  abort },\n \n{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Dfalse,Dfalse,Dfalse,Delse, Dendif,\n  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Dfalse,Dfalse,Dfalse,Delse, Eioccc,\n  drop,  Eeof,  abort }\n \n};\n\n \nstatic void\nignoreoff(void)\n{\n\tif (depth == 0)\n\t\tabort();  \n\tignoring[depth] = ignoring[depth-1];\n}\nstatic void\nignoreon(void)\n{\n\tignoring[depth] = true;\n}\nstatic void\nkeywordedit(const char *replacement)\n{\n\tsnprintf(keyword, tline + sizeof(tline) - keyword,\n\t    \"%s%s\", replacement, newline);\n\tprint();\n}\nstatic void\nnest(void)\n{\n\tif (depth > MAXDEPTH-1)\n\t\tabort();  \n\tif (depth == MAXDEPTH-1)\n\t\terror(\"Too many levels of nesting\");\n\tdepth += 1;\n\tstifline[depth] = linenum;\n}\nstatic void\nunnest(void)\n{\n\tif (depth == 0)\n\t\tabort();  \n\tdepth -= 1;\n}\nstatic void\nstate(Ifstate is)\n{\n\tifstate[depth] = is;\n}\n\n \nstatic void\nflushline(bool keep)\n{\n\tif (symlist)\n\t\treturn;\n\tif (keep ^ complement) {\n\t\tbool blankline = tline[strspn(tline, \" \\t\\r\\n\")] == '\\0';\n\t\tif (blankline && compblank && blankcount != blankmax) {\n\t\t\tdelcount += 1;\n\t\t\tblankcount += 1;\n\t\t} else {\n\t\t\tif (lnnum && delcount > 0)\n\t\t\t\tprintf(\"#line %d%s\", linenum, newline);\n\t\t\tfputs(tline, output);\n\t\t\tdelcount = 0;\n\t\t\tblankmax = blankcount = blankline ? blankcount + 1 : 0;\n\t\t}\n\t} else {\n\t\tif (lnblank)\n\t\t\tfputs(newline, output);\n\t\texitstat = 1;\n\t\tdelcount += 1;\n\t\tblankcount = 0;\n\t}\n\tif (debugging)\n\t\tfflush(output);\n}\n\n \nstatic void\nprocess(void)\n{\n\t \n\tblankmax = blankcount = 1000;\n\tfor (;;) {\n\t\tLinetype lineval = parseline();\n\t\ttrans_table[ifstate[depth]][lineval]();\n\t\tdebug(\"process line %d %s -> %s depth %d\",\n\t\t    linenum, linetype_name[lineval],\n\t\t    ifstate_name[ifstate[depth]], depth);\n\t}\n}\n\n \nstatic void\ncloseout(void)\n{\n\tif (symdepth && !zerosyms)\n\t\tprintf(\"\\n\");\n\tif (fclose(output) == EOF) {\n\t\twarn(\"couldn't write to %s\", ofilename);\n\t\tif (overwriting) {\n\t\t\tunlink(tempname);\n\t\t\terrx(2, \"%s unchanged\", filename);\n\t\t} else {\n\t\t\texit(2);\n\t\t}\n\t}\n}\n\n \nstatic void\ndone(void)\n{\n\tif (incomment)\n\t\terror(\"EOF in comment\");\n\tcloseout();\n\tif (overwriting && rename(tempname, ofilename) == -1) {\n\t\twarn(\"couldn't rename temporary file\");\n\t\tunlink(tempname);\n\t\terrx(2, \"%s unchanged\", ofilename);\n\t}\n\texit(exitstat);\n}\n\n \nstatic Linetype\nparseline(void)\n{\n\tconst char *cp;\n\tint cursym;\n\tint kwlen;\n\tLinetype retval;\n\tComment_state wascomment;\n\n\tlinenum++;\n\tif (fgets(tline, MAXLINE, input) == NULL)\n\t\treturn (LT_EOF);\n\tif (newline == NULL) {\n\t\tif (strrchr(tline, '\\n') == strrchr(tline, '\\r') + 1)\n\t\t\tnewline = newline_crlf;\n\t\telse\n\t\t\tnewline = newline_unix;\n\t}\n\tretval = LT_PLAIN;\n\twascomment = incomment;\n\tcp = skipcomment(tline);\n\tif (linestate == LS_START) {\n\t\tif (*cp == '#') {\n\t\t\tlinestate = LS_HASH;\n\t\t\tfirstsym = true;\n\t\t\tcp = skipcomment(cp + 1);\n\t\t} else if (*cp != '\\0')\n\t\t\tlinestate = LS_DIRTY;\n\t}\n\tif (!incomment && linestate == LS_HASH) {\n\t\tkeyword = tline + (cp - tline);\n\t\tcp = skipsym(cp);\n\t\tkwlen = cp - keyword;\n\t\t \n\t\tif (strncmp(cp, \"\\\\\\r\\n\", 3) == 0 ||\n\t\t    strncmp(cp, \"\\\\\\n\", 2) == 0)\n\t\t\tEioccc();\n\t\tif (strlcmp(\"ifdef\", keyword, kwlen) == 0 ||\n\t\t    strlcmp(\"ifndef\", keyword, kwlen) == 0) {\n\t\t\tcp = skipcomment(cp);\n\t\t\tif ((cursym = findsym(cp)) < 0)\n\t\t\t\tretval = LT_IF;\n\t\t\telse {\n\t\t\t\tretval = (keyword[2] == 'n')\n\t\t\t\t    ? LT_FALSE : LT_TRUE;\n\t\t\t\tif (value[cursym] == NULL)\n\t\t\t\t\tretval = (retval == LT_TRUE)\n\t\t\t\t\t    ? LT_FALSE : LT_TRUE;\n\t\t\t\tif (ignore[cursym])\n\t\t\t\t\tretval = (retval == LT_TRUE)\n\t\t\t\t\t    ? LT_TRUEI : LT_FALSEI;\n\t\t\t}\n\t\t\tcp = skipsym(cp);\n\t\t} else if (strlcmp(\"if\", keyword, kwlen) == 0)\n\t\t\tretval = ifeval(&cp);\n\t\telse if (strlcmp(\"elif\", keyword, kwlen) == 0)\n\t\t\tretval = ifeval(&cp) - LT_IF + LT_ELIF;\n\t\telse if (strlcmp(\"else\", keyword, kwlen) == 0)\n\t\t\tretval = LT_ELSE;\n\t\telse if (strlcmp(\"endif\", keyword, kwlen) == 0)\n\t\t\tretval = LT_ENDIF;\n\t\telse {\n\t\t\tlinestate = LS_DIRTY;\n\t\t\tretval = LT_PLAIN;\n\t\t}\n\t\tcp = skipcomment(cp);\n\t\tif (*cp != '\\0') {\n\t\t\tlinestate = LS_DIRTY;\n\t\t\tif (retval == LT_TRUE || retval == LT_FALSE ||\n\t\t\t    retval == LT_TRUEI || retval == LT_FALSEI)\n\t\t\t\tretval = LT_IF;\n\t\t\tif (retval == LT_ELTRUE || retval == LT_ELFALSE)\n\t\t\t\tretval = LT_ELIF;\n\t\t}\n\t\tif (retval != LT_PLAIN && (wascomment || incomment)) {\n\t\t\tretval += LT_DODGY;\n\t\t\tif (incomment)\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t}\n\t\t \n\t\tif (linestate == LS_HASH) {\n\t\t\tsize_t len = cp - tline;\n\t\t\tif (fgets(tline + len, MAXLINE - len, input) == NULL) {\n\t\t\t\t \n\t\t\t\tstrcpy(tline + len, newline);\n\t\t\t\tcp += strlen(newline);\n\t\t\t\tlinestate = LS_START;\n\t\t\t} else {\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t\t}\n\t\t}\n\t}\n\tif (linestate == LS_DIRTY) {\n\t\twhile (*cp != '\\0')\n\t\t\tcp = skipcomment(cp + 1);\n\t}\n\tdebug(\"parser line %d state %s comment %s line\", linenum,\n\t    comment_name[incomment], linestate_name[linestate]);\n\treturn (retval);\n}\n\n \nstatic Linetype op_strict(int *p, int v, Linetype at, Linetype bt) {\n\tif(at == LT_IF || bt == LT_IF) return (LT_IF);\n\treturn (*p = v, v ? LT_TRUE : LT_FALSE);\n}\nstatic Linetype op_lt(int *p, Linetype at, int a, Linetype bt, int b) {\n\treturn op_strict(p, a < b, at, bt);\n}\nstatic Linetype op_gt(int *p, Linetype at, int a, Linetype bt, int b) {\n\treturn op_strict(p, a > b, at, bt);\n}\nstatic Linetype op_le(int *p, Linetype at, int a, Linetype bt, int b) {\n\treturn op_strict(p, a <= b, at, bt);\n}\nstatic Linetype op_ge(int *p, Linetype at, int a, Linetype bt, int b) {\n\treturn op_strict(p, a >= b, at, bt);\n}\nstatic Linetype op_eq(int *p, Linetype at, int a, Linetype bt, int b) {\n\treturn op_strict(p, a == b, at, bt);\n}\nstatic Linetype op_ne(int *p, Linetype at, int a, Linetype bt, int b) {\n\treturn op_strict(p, a != b, at, bt);\n}\nstatic Linetype op_or(int *p, Linetype at, int a, Linetype bt, int b) {\n\tif (!strictlogic && (at == LT_TRUE || bt == LT_TRUE))\n\t\treturn (*p = 1, LT_TRUE);\n\treturn op_strict(p, a || b, at, bt);\n}\nstatic Linetype op_and(int *p, Linetype at, int a, Linetype bt, int b) {\n\tif (!strictlogic && (at == LT_FALSE || bt == LT_FALSE))\n\t\treturn (*p = 0, LT_FALSE);\n\treturn op_strict(p, a && b, at, bt);\n}\n\n \nstruct ops;\n\ntypedef Linetype eval_fn(const struct ops *, int *, const char **);\n\nstatic eval_fn eval_table, eval_unary;\n\n \nstatic const struct ops {\n\teval_fn *inner;\n\tstruct op {\n\t\tconst char *str;\n\t\tLinetype (*fn)(int *, Linetype, int, Linetype, int);\n\t} op[5];\n} eval_ops[] = {\n\t{ eval_table, { { \"||\", op_or } } },\n\t{ eval_table, { { \"&&\", op_and } } },\n\t{ eval_table, { { \"==\", op_eq },\n\t\t\t{ \"!=\", op_ne } } },\n\t{ eval_unary, { { \"<=\", op_le },\n\t\t\t{ \">=\", op_ge },\n\t\t\t{ \"<\", op_lt },\n\t\t\t{ \">\", op_gt } } }\n};\n\n \nstatic Linetype\neval_unary(const struct ops *ops, int *valp, const char **cpp)\n{\n\tconst char *cp;\n\tchar *ep;\n\tint sym;\n\tbool defparen;\n\tLinetype lt;\n\n\tcp = skipcomment(*cpp);\n\tif (*cp == '!') {\n\t\tdebug(\"eval%d !\", ops - eval_ops);\n\t\tcp++;\n\t\tlt = eval_unary(ops, valp, &cp);\n\t\tif (lt == LT_ERROR)\n\t\t\treturn (LT_ERROR);\n\t\tif (lt != LT_IF) {\n\t\t\t*valp = !*valp;\n\t\t\tlt = *valp ? LT_TRUE : LT_FALSE;\n\t\t}\n\t} else if (*cp == '(') {\n\t\tcp++;\n\t\tdebug(\"eval%d (\", ops - eval_ops);\n\t\tlt = eval_table(eval_ops, valp, &cp);\n\t\tif (lt == LT_ERROR)\n\t\t\treturn (LT_ERROR);\n\t\tcp = skipcomment(cp);\n\t\tif (*cp++ != ')')\n\t\t\treturn (LT_ERROR);\n\t} else if (isdigit((unsigned char)*cp)) {\n\t\tdebug(\"eval%d number\", ops - eval_ops);\n\t\t*valp = strtol(cp, &ep, 0);\n\t\tif (ep == cp)\n\t\t\treturn (LT_ERROR);\n\t\tlt = *valp ? LT_TRUE : LT_FALSE;\n\t\tcp = skipsym(cp);\n\t} else if (strncmp(cp, \"defined\", 7) == 0 && endsym(cp[7])) {\n\t\tcp = skipcomment(cp+7);\n\t\tdebug(\"eval%d defined\", ops - eval_ops);\n\t\tif (*cp == '(') {\n\t\t\tcp = skipcomment(cp+1);\n\t\t\tdefparen = true;\n\t\t} else {\n\t\t\tdefparen = false;\n\t\t}\n\t\tsym = findsym(cp);\n\t\tif (sym < 0) {\n\t\t\tlt = LT_IF;\n\t\t} else {\n\t\t\t*valp = (value[sym] != NULL);\n\t\t\tlt = *valp ? LT_TRUE : LT_FALSE;\n\t\t}\n\t\tcp = skipsym(cp);\n\t\tcp = skipcomment(cp);\n\t\tif (defparen && *cp++ != ')')\n\t\t\treturn (LT_ERROR);\n\t\tconstexpr = false;\n\t} else if (!endsym(*cp)) {\n\t\tdebug(\"eval%d symbol\", ops - eval_ops);\n\t\tsym = findsym(cp);\n\t\tcp = skipsym(cp);\n\t\tif (sym < 0) {\n\t\t\tlt = LT_IF;\n\t\t\tcp = skipargs(cp);\n\t\t} else if (value[sym] == NULL) {\n\t\t\t*valp = 0;\n\t\t\tlt = LT_FALSE;\n\t\t} else {\n\t\t\t*valp = strtol(value[sym], &ep, 0);\n\t\t\tif (*ep != '\\0' || ep == value[sym])\n\t\t\t\treturn (LT_ERROR);\n\t\t\tlt = *valp ? LT_TRUE : LT_FALSE;\n\t\t\tcp = skipargs(cp);\n\t\t}\n\t\tconstexpr = false;\n\t} else {\n\t\tdebug(\"eval%d bad expr\", ops - eval_ops);\n\t\treturn (LT_ERROR);\n\t}\n\n\t*cpp = cp;\n\tdebug(\"eval%d = %d\", ops - eval_ops, *valp);\n\treturn (lt);\n}\n\n \nstatic Linetype\neval_table(const struct ops *ops, int *valp, const char **cpp)\n{\n\tconst struct op *op;\n\tconst char *cp;\n\tint val;\n\tLinetype lt, rt;\n\n\tdebug(\"eval%d\", ops - eval_ops);\n\tcp = *cpp;\n\tlt = ops->inner(ops+1, valp, &cp);\n\tif (lt == LT_ERROR)\n\t\treturn (LT_ERROR);\n\tfor (;;) {\n\t\tcp = skipcomment(cp);\n\t\tfor (op = ops->op; op->str != NULL; op++)\n\t\t\tif (strncmp(cp, op->str, strlen(op->str)) == 0)\n\t\t\t\tbreak;\n\t\tif (op->str == NULL)\n\t\t\tbreak;\n\t\tcp += strlen(op->str);\n\t\tdebug(\"eval%d %s\", ops - eval_ops, op->str);\n\t\trt = ops->inner(ops+1, &val, &cp);\n\t\tif (rt == LT_ERROR)\n\t\t\treturn (LT_ERROR);\n\t\tlt = op->fn(valp, lt, *valp, rt, val);\n\t}\n\n\t*cpp = cp;\n\tdebug(\"eval%d = %d\", ops - eval_ops, *valp);\n\tdebug(\"eval%d lt = %s\", ops - eval_ops, linetype_name[lt]);\n\treturn (lt);\n}\n\n \nstatic Linetype\nifeval(const char **cpp)\n{\n\tint ret;\n\tint val = 0;\n\n\tdebug(\"eval %s\", *cpp);\n\tconstexpr = killconsts ? false : true;\n\tret = eval_table(eval_ops, &val, cpp);\n\tdebug(\"eval = %d\", val);\n\treturn (constexpr ? LT_IF : ret == LT_ERROR ? LT_IF : ret);\n}\n\n \nstatic const char *\nskipcomment(const char *cp)\n{\n\tif (text || ignoring[depth]) {\n\t\tfor (; isspace((unsigned char)*cp); cp++)\n\t\t\tif (*cp == '\\n')\n\t\t\t\tlinestate = LS_START;\n\t\treturn (cp);\n\t}\n\twhile (*cp != '\\0')\n\t\t \n\t\tif (strncmp(cp, \"\\\\\\r\\n\", 3) == 0)\n\t\t\tcp += 3;\n\t\telse if (strncmp(cp, \"\\\\\\n\", 2) == 0)\n\t\t\tcp += 2;\n\t\telse switch (incomment) {\n\t\tcase NO_COMMENT:\n\t\t\tif (strncmp(cp, \"/\\\\\\r\\n\", 4) == 0) {\n\t\t\t\tincomment = STARTING_COMMENT;\n\t\t\t\tcp += 4;\n\t\t\t} else if (strncmp(cp, \"/\\\\\\n\", 3) == 0) {\n\t\t\t\tincomment = STARTING_COMMENT;\n\t\t\t\tcp += 3;\n\t\t\t} else if (strncmp(cp, \"/*\", 2) == 0) {\n\t\t\t\tincomment = C_COMMENT;\n\t\t\t\tcp += 2;\n\t\t\t} else if (strncmp(cp, \"\n\t\t\t\tincomment = CXX_COMMENT;\n\t\t\t\tcp += 2;\n\t\t\t} else if (strncmp(cp, \"\\'\", 1) == 0) {\n\t\t\t\tincomment = CHAR_LITERAL;\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t\t\tcp += 1;\n\t\t\t} else if (strncmp(cp, \"\\\"\", 1) == 0) {\n\t\t\t\tincomment = STRING_LITERAL;\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t\t\tcp += 1;\n\t\t\t} else if (strncmp(cp, \"\\n\", 1) == 0) {\n\t\t\t\tlinestate = LS_START;\n\t\t\t\tcp += 1;\n\t\t\t} else if (strchr(\" \\r\\t\", *cp) != NULL) {\n\t\t\t\tcp += 1;\n\t\t\t} else\n\t\t\t\treturn (cp);\n\t\t\tcontinue;\n\t\tcase CXX_COMMENT:\n\t\t\tif (strncmp(cp, \"\\n\", 1) == 0) {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tlinestate = LS_START;\n\t\t\t}\n\t\t\tcp += 1;\n\t\t\tcontinue;\n\t\tcase CHAR_LITERAL:\n\t\tcase STRING_LITERAL:\n\t\t\tif ((incomment == CHAR_LITERAL && cp[0] == '\\'') ||\n\t\t\t    (incomment == STRING_LITERAL && cp[0] == '\\\"')) {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tcp += 1;\n\t\t\t} else if (cp[0] == '\\\\') {\n\t\t\t\tif (cp[1] == '\\0')\n\t\t\t\t\tcp += 1;\n\t\t\t\telse\n\t\t\t\t\tcp += 2;\n\t\t\t} else if (strncmp(cp, \"\\n\", 1) == 0) {\n\t\t\t\tif (incomment == CHAR_LITERAL)\n\t\t\t\t\terror(\"unterminated char literal\");\n\t\t\t\telse\n\t\t\t\t\terror(\"unterminated string literal\");\n\t\t\t} else\n\t\t\t\tcp += 1;\n\t\t\tcontinue;\n\t\tcase C_COMMENT:\n\t\t\tif (strncmp(cp, \"*\\\\\\r\\n\", 4) == 0) {\n\t\t\t\tincomment = FINISHING_COMMENT;\n\t\t\t\tcp += 4;\n\t\t\t} else if (strncmp(cp, \"*\\\\\\n\", 3) == 0) {\n\t\t\t\tincomment = FINISHING_COMMENT;\n\t\t\t\tcp += 3;\n\t\t\t} else if (strncmp(cp, \"*/\", 2) == 0) {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tcp += 2;\n\t\t\t} else\n\t\t\t\tcp += 1;\n\t\t\tcontinue;\n\t\tcase STARTING_COMMENT:\n\t\t\tif (*cp == '*') {\n\t\t\t\tincomment = C_COMMENT;\n\t\t\t\tcp += 1;\n\t\t\t} else if (*cp == '/') {\n\t\t\t\tincomment = CXX_COMMENT;\n\t\t\t\tcp += 1;\n\t\t\t} else {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tlinestate = LS_DIRTY;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase FINISHING_COMMENT:\n\t\t\tif (*cp == '/') {\n\t\t\t\tincomment = NO_COMMENT;\n\t\t\t\tcp += 1;\n\t\t\t} else\n\t\t\t\tincomment = C_COMMENT;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tabort();  \n\t\t}\n\treturn (cp);\n}\n\n \nstatic const char *\nskipargs(const char *cp)\n{\n\tconst char *ocp = cp;\n\tint level = 0;\n\tcp = skipcomment(cp);\n\tif (*cp != '(')\n\t\treturn (cp);\n\tdo {\n\t\tif (*cp == '(')\n\t\t\tlevel++;\n\t\tif (*cp == ')')\n\t\t\tlevel--;\n\t\tcp = skipcomment(cp+1);\n\t} while (level != 0 && *cp != '\\0');\n\tif (level == 0)\n\t\treturn (cp);\n\telse\n\t \n\t\treturn (ocp);\n}\n\n \nstatic const char *\nskipsym(const char *cp)\n{\n\twhile (!endsym(*cp))\n\t\t++cp;\n\treturn (cp);\n}\n\n \nstatic int\nfindsym(const char *str)\n{\n\tconst char *cp;\n\tint symind;\n\n\tcp = skipsym(str);\n\tif (cp == str)\n\t\treturn (-1);\n\tif (symlist) {\n\t\tif (symdepth && firstsym)\n\t\t\tprintf(\"%s%3d\", zerosyms ? \"\" : \"\\n\", depth);\n\t\tfirstsym = zerosyms = false;\n\t\tprintf(\"%s%.*s%s\",\n\t\t    symdepth ? \" \" : \"\",\n\t\t    (int)(cp-str), str,\n\t\t    symdepth ? \"\" : \"\\n\");\n\t\t \n\t\treturn (0);\n\t}\n\tfor (symind = 0; symind < nsyms; ++symind) {\n\t\tif (strlcmp(symname[symind], str, cp-str) == 0) {\n\t\t\tdebug(\"findsym %s %s\", symname[symind],\n\t\t\t    value[symind] ? value[symind] : \"\");\n\t\t\treturn (symind);\n\t\t}\n\t}\n\treturn (-1);\n}\n\n \nstatic void\naddsym(bool ignorethis, bool definethis, char *sym)\n{\n\tint symind;\n\tchar *val;\n\n\tsymind = findsym(sym);\n\tif (symind < 0) {\n\t\tif (nsyms >= MAXSYMS)\n\t\t\terrx(2, \"too many symbols\");\n\t\tsymind = nsyms++;\n\t}\n\tsymname[symind] = sym;\n\tignore[symind] = ignorethis;\n\tval = sym + (skipsym(sym) - sym);\n\tif (definethis) {\n\t\tif (*val == '=') {\n\t\t\tvalue[symind] = val+1;\n\t\t\t*val = '\\0';\n\t\t} else if (*val == '\\0')\n\t\t\tvalue[symind] = \"1\";\n\t\telse\n\t\t\tusage();\n\t} else {\n\t\tif (*val != '\\0')\n\t\t\tusage();\n\t\tvalue[symind] = NULL;\n\t}\n\tdebug(\"addsym %s=%s\", symname[symind],\n\t    value[symind] ? value[symind] : \"undef\");\n}\n\n \nstatic int\nstrlcmp(const char *s, const char *t, size_t n)\n{\n\twhile (n-- && *t != '\\0')\n\t\tif (*s != *t)\n\t\t\treturn ((unsigned char)*s - (unsigned char)*t);\n\t\telse\n\t\t\t++s, ++t;\n\treturn ((unsigned char)*s);\n}\n\n \nstatic void\ndebug(const char *msg, ...)\n{\n\tva_list ap;\n\n\tif (debugging) {\n\t\tva_start(ap, msg);\n\t\tvwarnx(msg, ap);\n\t\tva_end(ap);\n\t}\n}\n\nstatic void\nerror(const char *msg)\n{\n\tif (depth == 0)\n\t\twarnx(\"%s: %d: %s\", filename, linenum, msg);\n\telse\n\t\twarnx(\"%s: %d: %s (#if line %d depth %d)\",\n\t\t    filename, linenum, msg, stifline[depth], depth);\n\tcloseout();\n\terrx(2, \"output may be truncated\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}