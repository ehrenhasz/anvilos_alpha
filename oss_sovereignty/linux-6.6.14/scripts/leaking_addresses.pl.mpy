{
  "module_name": "leaking_addresses.pl",
  "hash_id": "e8c654868b999f1cafd325e0b641074ecb15edb94e4d6126282f7de830eb1be6",
  "original_prompt": "Ingested from linux-6.6.14/scripts/leaking_addresses.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# (c) 2017 Tobin C. Harding <me@tobin.cc>\n#\n# leaking_addresses.pl: Scan the kernel for potential leaking addresses.\n#  - Scans dmesg output.\n#  - Walks directory tree and parses each file (for each directory in @DIRS).\n#\n# Use --debug to output path before parsing, this is useful to find files that\n# cause the script to choke.\n\n#\n# When the system is idle it is likely that most files under /proc/PID will be\n# identical for various processes.  Scanning _all_ the PIDs under /proc is\n# unnecessary and implies that we are thoroughly scanning /proc.  This is _not_\n# the case because there may be ways userspace can trigger creation of /proc\n# files that leak addresses but were not present during a scan.  For these two\n# reasons we exclude all PID directories under /proc except '1/'\n\nuse warnings;\nuse strict;\nuse POSIX;\nuse File::Basename;\nuse File::Spec;\nuse Cwd 'abs_path';\nuse Term::ANSIColor qw(:constants);\nuse Getopt::Long qw(:config no_auto_abbrev);\nuse Config;\nuse bigint qw/hex/;\nuse feature 'state';\n\nmy $P = $0;\n\n# Directories to scan.\nmy @DIRS = ('/proc', '/sys');\n\n# Timer for parsing each file, in seconds.\nmy $TIMEOUT = 10;\n\n# Kernel addresses vary by architecture.  We can only auto-detect the following\n# architectures (using `uname -m`).  (flag --32-bit overrides auto-detection.)\nmy @SUPPORTED_ARCHITECTURES = ('x86_64', 'ppc64', 'x86');\n\n# Command line options.\nmy $help = 0;\nmy $debug = 0;\nmy $raw = 0;\nmy $output_raw = \"\";\t# Write raw results to file.\nmy $input_raw = \"\";\t# Read raw results from file instead of scanning.\nmy $suppress_dmesg = 0;\t\t# Don't show dmesg in output.\nmy $squash_by_path = 0;\t\t# Summary report grouped by absolute path.\nmy $squash_by_filename = 0;\t# Summary report grouped by filename.\nmy $kernel_config_file = \"\";\t# Kernel configuration file.\nmy $opt_32bit = 0;\t\t# Scan 32-bit kernel.\nmy $page_offset_32bit = 0;\t# Page offset for 32-bit kernel.\n\n# Skip these absolute paths.\nmy @skip_abs = (\n\t'/proc/kmsg',\n\t'/proc/device-tree',\n\t'/proc/1/syscall',\n\t'/sys/firmware/devicetree',\n\t'/sys/kernel/tracing/trace_pipe',\n\t'/sys/kernel/debug/tracing/trace_pipe',\n\t'/sys/kernel/security/apparmor/revision');\n\n# Skip these under any subdirectory.\nmy @skip_any = (\n\t'pagemap',\n\t'events',\n\t'access',\n\t'registers',\n\t'snapshot_raw',\n\t'trace_pipe_raw',\n\t'ptmx',\n\t'trace_pipe',\n\t'fd',\n\t'usbmon');\n\nsub help\n{\n\tmy ($exitcode) = @_;\n\n\tprint << \"EOM\";\n\nUsage: $P [OPTIONS]\n\nOptions:\n\n\t-o, --output-raw=<file>\t\tSave results for future processing.\n\t-i, --input-raw=<file>\t\tRead results from file instead of scanning.\n\t      --raw\t\t\tShow raw results (default).\n\t      --suppress-dmesg\t\tDo not show dmesg results.\n\t      --squash-by-path\t\tShow one result per unique path.\n\t      --squash-by-filename\tShow one result per unique filename.\n\t--kernel-config-file=<file>     Kernel configuration file (e.g /boot/config)\n\t--32-bit\t\t\tScan 32-bit kernel.\n\t--page-offset-32-bit=o\t\tPage offset (for 32-bit kernel 0xABCD1234).\n\t-d, --debug\t\t\tDisplay debugging output.\n\t-h, --help\t\t\tDisplay this help and exit.\n\nScans the running kernel for potential leaking addresses.\n\nEOM\n\texit($exitcode);\n}\n\nGetOptions(\n\t'd|debug'\t\t=> \\$debug,\n\t'h|help'\t\t=> \\$help,\n\t'o|output-raw=s'        => \\$output_raw,\n\t'i|input-raw=s'         => \\$input_raw,\n\t'suppress-dmesg'        => \\$suppress_dmesg,\n\t'squash-by-path'        => \\$squash_by_path,\n\t'squash-by-filename'    => \\$squash_by_filename,\n\t'raw'                   => \\$raw,\n\t'kernel-config-file=s'\t=> \\$kernel_config_file,\n\t'32-bit'\t\t=> \\$opt_32bit,\n\t'page-offset-32-bit=o'\t=> \\$page_offset_32bit,\n) or help(1);\n\nhelp(0) if ($help);\n\nif ($input_raw) {\n\tformat_output($input_raw);\n\texit(0);\n}\n\nif (!$input_raw and ($squash_by_path or $squash_by_filename)) {\n\tprintf \"\\nSummary reporting only available with --input-raw=<file>\\n\";\n\tprintf \"(First run scan with --output-raw=<file>.)\\n\";\n\texit(128);\n}\n\nif (!(is_supported_architecture() or $opt_32bit or $page_offset_32bit)) {\n\tprintf \"\\nScript does not support your architecture, sorry.\\n\";\n\tprintf \"\\nCurrently we support: \\n\\n\";\n\tforeach(@SUPPORTED_ARCHITECTURES) {\n\t\tprintf \"\\t%s\\n\", $_;\n\t}\n\tprintf(\"\\n\");\n\n\tprintf(\"If you are running a 32-bit architecture you may use:\\n\");\n\tprintf(\"\\n\\t--32-bit or --page-offset-32-bit=<page offset>\\n\\n\");\n\n\tmy $archname = `uname -m`;\n\tprintf(\"Machine hardware name (`uname -m`): %s\\n\", $archname);\n\n\texit(129);\n}\n\nif ($output_raw) {\n\topen my $fh, '>', $output_raw or die \"$0: $output_raw: $!\\n\";\n\tselect $fh;\n}\n\nparse_dmesg();\nwalk(@DIRS);\n\nexit 0;\n\nsub dprint\n{\n\tprintf(STDERR @_) if $debug;\n}\n\nsub is_supported_architecture\n{\n\treturn (is_x86_64() or is_ppc64() or is_ix86_32());\n}\n\nsub is_32bit\n{\n\t# Allow --32-bit or --page-offset-32-bit to override\n\tif ($opt_32bit or $page_offset_32bit) {\n\t\treturn 1;\n\t}\n\n\treturn is_ix86_32();\n}\n\nsub is_ix86_32\n{\n       state $arch = `uname -m`;\n\n       chomp $arch;\n       if ($arch =~ m/i[3456]86/) {\n               return 1;\n       }\n       return 0;\n}\n\nsub is_arch\n{\n       my ($desc) = @_;\n       my $arch = `uname -m`;\n\n       chomp $arch;\n       if ($arch eq $desc) {\n               return 1;\n       }\n       return 0;\n}\n\nsub is_x86_64\n{\n\tstate $is = is_arch('x86_64');\n\treturn $is;\n}\n\nsub is_ppc64\n{\n\tstate $is = is_arch('ppc64');\n\treturn $is;\n}\n\n# Gets config option value from kernel config file.\n# Returns \"\" on error or if config option not found.\nsub get_kernel_config_option\n{\n\tmy ($option) = @_;\n\tmy $value = \"\";\n\tmy $tmp_file = \"\";\n\tmy @config_files;\n\n\t# Allow --kernel-config-file to override.\n\tif ($kernel_config_file ne \"\") {\n\t\t@config_files = ($kernel_config_file);\n\t} elsif (-R \"/proc/config.gz\") {\n\t\tmy $tmp_file = \"/tmp/tmpkconf\";\n\n\t\tif (system(\"gunzip < /proc/config.gz > $tmp_file\")) {\n\t\t\tdprint(\"system(gunzip < /proc/config.gz) failed\\n\");\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\t@config_files = ($tmp_file);\n\t\t}\n\t} else {\n\t\tmy $file = '/boot/config-' . `uname -r`;\n\t\tchomp $file;\n\t\t@config_files = ($file, '/boot/config');\n\t}\n\n\tforeach my $file (@config_files) {\n\t\tdprint(\"parsing config file: $file\\n\");\n\t\t$value = option_from_file($option, $file);\n\t\tif ($value ne \"\") {\n\t\t\tlast;\n\t\t}\n\t}\n\n\tif ($tmp_file ne \"\") {\n\t\tsystem(\"rm -f $tmp_file\");\n\t}\n\n\treturn $value;\n}\n\n# Parses $file and returns kernel configuration option value.\nsub option_from_file\n{\n\tmy ($option, $file) = @_;\n\tmy $str = \"\";\n\tmy $val = \"\";\n\n\topen(my $fh, \"<\", $file) or return \"\";\n\twhile (my $line = <$fh> ) {\n\t\tif ($line =~ /^$option/) {\n\t\t\t($str, $val) = split /=/, $line;\n\t\t\tchomp $val;\n\t\t\tlast;\n\t\t}\n\t}\n\n\tclose $fh;\n\treturn $val;\n}\n\nsub is_false_positive\n{\n\tmy ($match) = @_;\n\n\tif (is_32bit()) {\n\t\treturn is_false_positive_32bit($match);\n\t}\n\n\t# 64 bit false positives.\n\n\tif ($match =~ '\\b(0x)?(f|F){16}\\b' or\n\t    $match =~ '\\b(0x)?0{16}\\b') {\n\t\treturn 1;\n\t}\n\n\tif (is_x86_64() and is_in_vsyscall_memory_region($match)) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nsub is_false_positive_32bit\n{\n       my ($match) = @_;\n       state $page_offset = get_page_offset();\n\n       if ($match =~ '\\b(0x)?(f|F){8}\\b') {\n               return 1;\n       }\n\n       if (hex($match) < $page_offset) {\n               return 1;\n       }\n\n       return 0;\n}\n\n# returns integer value\nsub get_page_offset\n{\n       my $page_offset;\n       my $default_offset = 0xc0000000;\n\n       # Allow --page-offset-32bit to override.\n       if ($page_offset_32bit != 0) {\n               return $page_offset_32bit;\n       }\n\n       $page_offset = get_kernel_config_option('CONFIG_PAGE_OFFSET');\n       if (!$page_offset) {\n\t       return $default_offset;\n       }\n       return $page_offset;\n}\n\nsub is_in_vsyscall_memory_region\n{\n\tmy ($match) = @_;\n\n\tmy $hex = hex($match);\n\tmy $region_min = hex(\"0xffffffffff600000\");\n\tmy $region_max = hex(\"0xffffffffff601000\");\n\n\treturn ($hex >= $region_min and $hex <= $region_max);\n}\n\n# True if argument potentially contains a kernel address.\nsub may_leak_address\n{\n\tmy ($line) = @_;\n\tmy $address_re;\n\n\t# Signal masks.\n\tif ($line =~ '^SigBlk:' or\n\t    $line =~ '^SigIgn:' or\n\t    $line =~ '^SigCgt:') {\n\t\treturn 0;\n\t}\n\n\tif ($line =~ '\\bKEY=[[:xdigit:]]{14} [[:xdigit:]]{16} [[:xdigit:]]{16}\\b' or\n\t    $line =~ '\\b[[:xdigit:]]{14} [[:xdigit:]]{16} [[:xdigit:]]{16}\\b') {\n\t\treturn 0;\n\t}\n\n\t$address_re = get_address_re();\n\twhile ($line =~ /($address_re)/g) {\n\t\tif (!is_false_positive($1)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nsub get_address_re\n{\n\tif (is_ppc64()) {\n\t\treturn '\\b(0x)?[89abcdef]00[[:xdigit:]]{13}\\b';\n\t} elsif (is_32bit()) {\n\t\treturn '\\b(0x)?[[:xdigit:]]{8}\\b';\n\t}\n\n\treturn get_x86_64_re();\n}\n\nsub get_x86_64_re\n{\n\t# We handle page table levels but only if explicitly configured using\n\t# CONFIG_PGTABLE_LEVELS.  If config file parsing fails or config option\n\t# is not found we default to using address regular expression suitable\n\t# for 4 page table levels.\n\tstate $ptl = get_kernel_config_option('CONFIG_PGTABLE_LEVELS');\n\n\tif ($ptl == 5) {\n\t\treturn '\\b(0x)?ff[[:xdigit:]]{14}\\b';\n\t}\n\treturn '\\b(0x)?ffff[[:xdigit:]]{12}\\b';\n}\n\nsub parse_dmesg\n{\n\topen my $cmd, '-|', 'dmesg';\n\twhile (<$cmd>) {\n\t\tif (may_leak_address($_)) {\n\t\t\tprint 'dmesg: ' . $_;\n\t\t}\n\t}\n\tclose $cmd;\n}\n\n# True if we should skip this path.\nsub skip\n{\n\tmy ($path) = @_;\n\n\tforeach (@skip_abs) {\n\t\treturn 1 if (/^$path$/);\n\t}\n\n\tmy($filename, $dirs, $suffix) = fileparse($path);\n\tforeach (@skip_any) {\n\t\treturn 1 if (/^$filename$/);\n\t}\n\n\treturn 0;\n}\n\nsub timed_parse_file\n{\n\tmy ($file) = @_;\n\n\teval {\n\t\tlocal $SIG{ALRM} = sub { die \"alarm\\n\" }; # NB: \\n required.\n\t\talarm $TIMEOUT;\n\t\tparse_file($file);\n\t\talarm 0;\n\t};\n\n\tif ($@) {\n\t\tdie unless $@ eq \"alarm\\n\";\t# Propagate unexpected errors.\n\t\tprintf STDERR \"timed out parsing: %s\\n\", $file;\n\t}\n}\n\nsub parse_file\n{\n\tmy ($file) = @_;\n\n\tif (! -R $file) {\n\t\treturn;\n\t}\n\n\tif (! -T $file) {\n\t\treturn;\n\t}\n\n\topen my $fh, \"<\", $file or return;\n\twhile ( <$fh> ) {\n\t\tchomp;\n\t\tif (may_leak_address($_)) {\n\t\t\tprintf(\"$file: $_\\n\");\n\t\t}\n\t}\n\tclose $fh;\n}\n\n# Checks if the actual path name is leaking a kernel address.\nsub check_path_for_leaks\n{\n\tmy ($path) = @_;\n\n\tif (may_leak_address($path)) {\n\t\tprintf(\"Path name may contain address: $path\\n\");\n\t}\n}\n\n# Recursively walk directory tree.\nsub walk\n{\n\tmy @dirs = @_;\n\n\twhile (my $pwd = shift @dirs) {\n\t\tnext if (!opendir(DIR, $pwd));\n\t\tmy @files = readdir(DIR);\n\t\tclosedir(DIR);\n\n\t\tforeach my $file (@files) {\n\t\t\tnext if ($file eq '.' or $file eq '..');\n\n\t\t\tmy $path = \"$pwd/$file\";\n\t\t\tnext if (-l $path);\n\n\t\t\t# skip /proc/PID except /proc/1\n\t\t\tnext if (($path =~ /^\\/proc\\/[0-9]+$/) &&\n\t\t\t\t ($path !~ /^\\/proc\\/1$/));\n\n\t\t\tnext if (skip($path));\n\n\t\t\tcheck_path_for_leaks($path);\n\n\t\t\tif (-d $path) {\n\t\t\t\tpush @dirs, $path;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tdprint(\"parsing: $path\\n\");\n\t\t\ttimed_parse_file($path);\n\t\t}\n\t}\n}\n\nsub format_output\n{\n\tmy ($file) = @_;\n\n\t# Default is to show raw results.\n\tif ($raw or (!$squash_by_path and !$squash_by_filename)) {\n\t\tdump_raw_output($file);\n\t\treturn;\n\t}\n\n\tmy ($total, $dmesg, $paths, $files) = parse_raw_file($file);\n\n\tprintf \"\\nTotal number of results from scan (incl dmesg): %d\\n\", $total;\n\n\tif (!$suppress_dmesg) {\n\t\tprint_dmesg($dmesg);\n\t}\n\n\tif ($squash_by_filename) {\n\t\tsquash_by($files, 'filename');\n\t}\n\n\tif ($squash_by_path) {\n\t\tsquash_by($paths, 'path');\n\t}\n}\n\nsub dump_raw_output\n{\n\tmy ($file) = @_;\n\n\topen (my $fh, '<', $file) or die \"$0: $file: $!\\n\";\n\twhile (<$fh>) {\n\t\tif ($suppress_dmesg) {\n\t\t\tif (\"dmesg:\" eq substr($_, 0, 6)) {\n\t\t\t\tnext;\n\t\t\t}\n\t\t}\n\t\tprint $_;\n\t}\n\tclose $fh;\n}\n\nsub parse_raw_file\n{\n\tmy ($file) = @_;\n\n\tmy $total = 0;          # Total number of lines parsed.\n\tmy @dmesg;              # dmesg output.\n\tmy %files;              # Unique filenames containing leaks.\n\tmy %paths;              # Unique paths containing leaks.\n\n\topen (my $fh, '<', $file) or die \"$0: $file: $!\\n\";\n\twhile (my $line = <$fh>) {\n\t\t$total++;\n\n\t\tif (\"dmesg:\" eq substr($line, 0, 6)) {\n\t\t\tpush @dmesg, $line;\n\t\t\tnext;\n\t\t}\n\n\t\tcache_path(\\%paths, $line);\n\t\tcache_filename(\\%files, $line);\n\t}\n\n\treturn $total, \\@dmesg, \\%paths, \\%files;\n}\n\nsub print_dmesg\n{\n\tmy ($dmesg) = @_;\n\n\tprint \"\\ndmesg output:\\n\";\n\n\tif (@$dmesg == 0) {\n\t\tprint \"<no results>\\n\";\n\t\treturn;\n\t}\n\n\tforeach(@$dmesg) {\n\t\tmy $index = index($_, ': ');\n\t\t$index += 2;    # skid ': '\n\t\tprint substr($_, $index);\n\t}\n}\n\nsub squash_by\n{\n\tmy ($ref, $desc) = @_;\n\n\tprint \"\\nResults squashed by $desc (excl dmesg). \";\n\tprint \"Displaying [<number of results> <$desc>], <example result>\\n\";\n\n\tif (keys %$ref == 0) {\n\t\tprint \"<no results>\\n\";\n\t\treturn;\n\t}\n\n\tforeach(keys %$ref) {\n\t\tmy $lines = $ref->{$_};\n\t\tmy $length = @$lines;\n\t\tprintf \"[%d %s] %s\", $length, $_, @$lines[0];\n\t}\n}\n\nsub cache_path\n{\n\tmy ($paths, $line) = @_;\n\n\tmy $index = index($line, ': ');\n\tmy $path = substr($line, 0, $index);\n\n\t$index += 2;            # skip ': '\n\tadd_to_cache($paths, $path, substr($line, $index));\n}\n\nsub cache_filename\n{\n\tmy ($files, $line) = @_;\n\n\tmy $index = index($line, ': ');\n\tmy $path = substr($line, 0, $index);\n\tmy $filename = basename($path);\n\n\t$index += 2;            # skip ': '\n\tadd_to_cache($files, $filename, substr($line, $index));\n}\n\nsub add_to_cache\n{\n\tmy ($cache, $key, $value) = @_;\n\n\tif (!$cache->{$key}) {\n\t\t$cache->{$key} = ();\n\t}\n\tpush @{$cache->{$key}}, $value;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}