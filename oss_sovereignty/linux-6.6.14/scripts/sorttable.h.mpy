{
  "module_name": "sorttable.h",
  "hash_id": "244131e2fcfb82b8c800c4935d0d86e3aa2595ff34f518acb307acc8d247a0f0",
  "original_prompt": "Ingested from linux-6.6.14/scripts/sorttable.h",
  "human_readable_source": " \n \n\n#undef extable_ent_size\n#undef compare_extable\n#undef get_mcount_loc\n#undef sort_mcount_loc\n#undef elf_mcount_loc\n#undef do_sort\n#undef Elf_Addr\n#undef Elf_Ehdr\n#undef Elf_Shdr\n#undef Elf_Rel\n#undef Elf_Rela\n#undef Elf_Sym\n#undef ELF_R_SYM\n#undef Elf_r_sym\n#undef ELF_R_INFO\n#undef Elf_r_info\n#undef ELF_ST_BIND\n#undef ELF_ST_TYPE\n#undef fn_ELF_R_SYM\n#undef fn_ELF_R_INFO\n#undef uint_t\n#undef _r\n#undef _w\n\n#ifdef SORTTABLE_64\n# define extable_ent_size\t16\n# define compare_extable\tcompare_extable_64\n# define get_mcount_loc\t\tget_mcount_loc_64\n# define sort_mcount_loc\tsort_mcount_loc_64\n# define elf_mcount_loc\t\telf_mcount_loc_64\n# define do_sort\t\tdo_sort_64\n# define Elf_Addr\t\tElf64_Addr\n# define Elf_Ehdr\t\tElf64_Ehdr\n# define Elf_Shdr\t\tElf64_Shdr\n# define Elf_Rel\t\tElf64_Rel\n# define Elf_Rela\t\tElf64_Rela\n# define Elf_Sym\t\tElf64_Sym\n# define ELF_R_SYM\t\tELF64_R_SYM\n# define Elf_r_sym\t\tElf64_r_sym\n# define ELF_R_INFO\t\tELF64_R_INFO\n# define Elf_r_info\t\tElf64_r_info\n# define ELF_ST_BIND\t\tELF64_ST_BIND\n# define ELF_ST_TYPE\t\tELF64_ST_TYPE\n# define fn_ELF_R_SYM\t\tfn_ELF64_R_SYM\n# define fn_ELF_R_INFO\t\tfn_ELF64_R_INFO\n# define uint_t\t\t\tuint64_t\n# define _r\t\t\tr8\n# define _w\t\t\tw8\n#else\n# define extable_ent_size\t8\n# define compare_extable\tcompare_extable_32\n# define get_mcount_loc\t\tget_mcount_loc_32\n# define sort_mcount_loc\tsort_mcount_loc_32\n# define elf_mcount_loc\t\telf_mcount_loc_32\n# define do_sort\t\tdo_sort_32\n# define Elf_Addr\t\tElf32_Addr\n# define Elf_Ehdr\t\tElf32_Ehdr\n# define Elf_Shdr\t\tElf32_Shdr\n# define Elf_Rel\t\tElf32_Rel\n# define Elf_Rela\t\tElf32_Rela\n# define Elf_Sym\t\tElf32_Sym\n# define ELF_R_SYM\t\tELF32_R_SYM\n# define Elf_r_sym\t\tElf32_r_sym\n# define ELF_R_INFO\t\tELF32_R_INFO\n# define Elf_r_info\t\tElf32_r_info\n# define ELF_ST_BIND\t\tELF32_ST_BIND\n# define ELF_ST_TYPE\t\tELF32_ST_TYPE\n# define fn_ELF_R_SYM\t\tfn_ELF32_R_SYM\n# define fn_ELF_R_INFO\t\tfn_ELF32_R_INFO\n# define uint_t\t\t\tuint32_t\n# define _r\t\t\tr\n# define _w\t\t\tw\n#endif\n\n#if defined(SORTTABLE_64) && defined(UNWINDER_ORC_ENABLED)\n \n#include <asm/orc_types.h>\n\n#define ERRSTR_MAXSZ\t256\n\nchar g_err[ERRSTR_MAXSZ];\nint *g_orc_ip_table;\nstruct orc_entry *g_orc_table;\n\npthread_t orc_sort_thread;\n\nstatic inline unsigned long orc_ip(const int *ip)\n{\n\treturn (unsigned long)ip + *ip;\n}\n\nstatic int orc_sort_cmp(const void *_a, const void *_b)\n{\n\tstruct orc_entry *orc_a;\n\tconst int *a = g_orc_ip_table + *(int *)_a;\n\tconst int *b = g_orc_ip_table + *(int *)_b;\n\tunsigned long a_val = orc_ip(a);\n\tunsigned long b_val = orc_ip(b);\n\n\tif (a_val > b_val)\n\t\treturn 1;\n\tif (a_val < b_val)\n\t\treturn -1;\n\n\t \n\torc_a = g_orc_table + (a - g_orc_ip_table);\n\treturn orc_a->type == ORC_TYPE_UNDEFINED ? -1 : 1;\n}\n\nstatic void *sort_orctable(void *arg)\n{\n\tint i;\n\tint *idxs = NULL;\n\tint *tmp_orc_ip_table = NULL;\n\tstruct orc_entry *tmp_orc_table = NULL;\n\tunsigned int *orc_ip_size = (unsigned int *)arg;\n\tunsigned int num_entries = *orc_ip_size / sizeof(int);\n\tunsigned int orc_size = num_entries * sizeof(struct orc_entry);\n\n\tidxs = (int *)malloc(*orc_ip_size);\n\tif (!idxs) {\n\t\tsnprintf(g_err, ERRSTR_MAXSZ, \"malloc idxs: %s\",\n\t\t\t strerror(errno));\n\t\tpthread_exit(g_err);\n\t}\n\n\ttmp_orc_ip_table = (int *)malloc(*orc_ip_size);\n\tif (!tmp_orc_ip_table) {\n\t\tsnprintf(g_err, ERRSTR_MAXSZ, \"malloc tmp_orc_ip_table: %s\",\n\t\t\t strerror(errno));\n\t\tpthread_exit(g_err);\n\t}\n\n\ttmp_orc_table = (struct orc_entry *)malloc(orc_size);\n\tif (!tmp_orc_table) {\n\t\tsnprintf(g_err, ERRSTR_MAXSZ, \"malloc tmp_orc_table: %s\",\n\t\t\t strerror(errno));\n\t\tpthread_exit(g_err);\n\t}\n\n\t \n\tfor (i = 0; i < num_entries; i++) {\n\t\tidxs[i] = i;\n\t\ttmp_orc_ip_table[i] = g_orc_ip_table[i] + i * sizeof(int);\n\t}\n\tmemcpy(tmp_orc_table, g_orc_table, orc_size);\n\n\tqsort(idxs, num_entries, sizeof(int), orc_sort_cmp);\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tif (idxs[i] == i)\n\t\t\tcontinue;\n\n\t\t \n\t\tg_orc_ip_table[i] = tmp_orc_ip_table[idxs[i]] - i * sizeof(int);\n\t\tg_orc_table[i] = tmp_orc_table[idxs[i]];\n\t}\n\n\tfree(idxs);\n\tfree(tmp_orc_ip_table);\n\tfree(tmp_orc_table);\n\tpthread_exit(NULL);\n}\n#endif\n\nstatic int compare_extable(const void *a, const void *b)\n{\n\tElf_Addr av = _r(a);\n\tElf_Addr bv = _r(b);\n\n\tif (av < bv)\n\t\treturn -1;\n\tif (av > bv)\n\t\treturn 1;\n\treturn 0;\n}\n#ifdef MCOUNT_SORT_ENABLED\npthread_t mcount_sort_thread;\n\nstruct elf_mcount_loc {\n\tElf_Ehdr *ehdr;\n\tElf_Shdr *init_data_sec;\n\tuint_t start_mcount_loc;\n\tuint_t stop_mcount_loc;\n};\n\n \nstatic void *sort_mcount_loc(void *arg)\n{\n\tstruct elf_mcount_loc *emloc = (struct elf_mcount_loc *)arg;\n\tuint_t offset = emloc->start_mcount_loc - _r(&(emloc->init_data_sec)->sh_addr)\n\t\t\t\t\t+ _r(&(emloc->init_data_sec)->sh_offset);\n\tuint_t count = emloc->stop_mcount_loc - emloc->start_mcount_loc;\n\tunsigned char *start_loc = (void *)emloc->ehdr + offset;\n\n\tqsort(start_loc, count/sizeof(uint_t), sizeof(uint_t), compare_extable);\n\treturn NULL;\n}\n\n \nstatic void get_mcount_loc(uint_t *_start, uint_t *_stop)\n{\n\tFILE *file_start, *file_stop;\n\tchar start_buff[20];\n\tchar stop_buff[20];\n\tint len = 0;\n\n\tfile_start = popen(\" grep start_mcount System.map | awk '{print $1}' \", \"r\");\n\tif (!file_start) {\n\t\tfprintf(stderr, \"get start_mcount_loc error!\");\n\t\treturn;\n\t}\n\n\tfile_stop = popen(\" grep stop_mcount System.map | awk '{print $1}' \", \"r\");\n\tif (!file_stop) {\n\t\tfprintf(stderr, \"get stop_mcount_loc error!\");\n\t\tpclose(file_start);\n\t\treturn;\n\t}\n\n\twhile (fgets(start_buff, sizeof(start_buff), file_start) != NULL) {\n\t\tlen = strlen(start_buff);\n\t\tstart_buff[len - 1] = '\\0';\n\t}\n\t*_start = strtoul(start_buff, NULL, 16);\n\n\twhile (fgets(stop_buff, sizeof(stop_buff), file_stop) != NULL) {\n\t\tlen = strlen(stop_buff);\n\t\tstop_buff[len - 1] = '\\0';\n\t}\n\t*_stop = strtoul(stop_buff, NULL, 16);\n\n\tpclose(file_start);\n\tpclose(file_stop);\n}\n#endif\nstatic int do_sort(Elf_Ehdr *ehdr,\n\t\t   char const *const fname,\n\t\t   table_sort_t custom_sort)\n{\n\tint rc = -1;\n\tElf_Shdr *s, *shdr = (Elf_Shdr *)((char *)ehdr + _r(&ehdr->e_shoff));\n\tElf_Shdr *strtab_sec = NULL;\n\tElf_Shdr *symtab_sec = NULL;\n\tElf_Shdr *extab_sec = NULL;\n\tElf_Sym *sym;\n\tconst Elf_Sym *symtab;\n\tElf32_Word *symtab_shndx = NULL;\n\tElf_Sym *sort_needed_sym = NULL;\n\tElf_Shdr *sort_needed_sec;\n\tElf_Rel *relocs = NULL;\n\tint relocs_size = 0;\n\tuint32_t *sort_needed_loc;\n\tconst char *secstrings;\n\tconst char *strtab;\n\tchar *extab_image;\n\tint extab_index = 0;\n\tint i;\n\tint idx;\n\tunsigned int shnum;\n\tunsigned int shstrndx;\n#ifdef MCOUNT_SORT_ENABLED\n\tstruct elf_mcount_loc mstruct = {0};\n\tuint_t _start_mcount_loc = 0;\n\tuint_t _stop_mcount_loc = 0;\n#endif\n#if defined(SORTTABLE_64) && defined(UNWINDER_ORC_ENABLED)\n\tunsigned int orc_ip_size = 0;\n\tunsigned int orc_size = 0;\n\tunsigned int orc_num_entries = 0;\n#endif\n\n\tshstrndx = r2(&ehdr->e_shstrndx);\n\tif (shstrndx == SHN_XINDEX)\n\t\tshstrndx = r(&shdr[0].sh_link);\n\tsecstrings = (const char *)ehdr + _r(&shdr[shstrndx].sh_offset);\n\n\tshnum = r2(&ehdr->e_shnum);\n\tif (shnum == SHN_UNDEF)\n\t\tshnum = _r(&shdr[0].sh_size);\n\n\tfor (i = 0, s = shdr; s < shdr + shnum; i++, s++) {\n\t\tidx = r(&s->sh_name);\n\t\tif (!strcmp(secstrings + idx, \"__ex_table\")) {\n\t\t\textab_sec = s;\n\t\t\textab_index = i;\n\t\t}\n\t\tif (!strcmp(secstrings + idx, \".symtab\"))\n\t\t\tsymtab_sec = s;\n\t\tif (!strcmp(secstrings + idx, \".strtab\"))\n\t\t\tstrtab_sec = s;\n\n\t\tif ((r(&s->sh_type) == SHT_REL ||\n\t\t     r(&s->sh_type) == SHT_RELA) &&\n\t\t    r(&s->sh_info) == extab_index) {\n\t\t\trelocs = (void *)ehdr + _r(&s->sh_offset);\n\t\t\trelocs_size = _r(&s->sh_size);\n\t\t}\n\t\tif (r(&s->sh_type) == SHT_SYMTAB_SHNDX)\n\t\t\tsymtab_shndx = (Elf32_Word *)((const char *)ehdr +\n\t\t\t\t\t\t      _r(&s->sh_offset));\n\n#ifdef MCOUNT_SORT_ENABLED\n\t\t \n\t\tif (!strcmp(secstrings + idx, \".init.data\")) {\n\t\t\tget_mcount_loc(&_start_mcount_loc, &_stop_mcount_loc);\n\t\t\tmstruct.ehdr = ehdr;\n\t\t\tmstruct.init_data_sec = s;\n\t\t\tmstruct.start_mcount_loc = _start_mcount_loc;\n\t\t\tmstruct.stop_mcount_loc = _stop_mcount_loc;\n\t\t}\n#endif\n\n#if defined(SORTTABLE_64) && defined(UNWINDER_ORC_ENABLED)\n\t\t \n\t\tif (!strcmp(secstrings + idx, \".orc_unwind_ip\")) {\n\t\t\torc_ip_size = s->sh_size;\n\t\t\tg_orc_ip_table = (int *)((void *)ehdr +\n\t\t\t\t\t\t   s->sh_offset);\n\t\t}\n\t\tif (!strcmp(secstrings + idx, \".orc_unwind\")) {\n\t\t\torc_size = s->sh_size;\n\t\t\tg_orc_table = (struct orc_entry *)((void *)ehdr +\n\t\t\t\t\t\t\t     s->sh_offset);\n\t\t}\n#endif\n\t}  \n\n#if defined(SORTTABLE_64) && defined(UNWINDER_ORC_ENABLED)\n\tif (!g_orc_ip_table || !g_orc_table) {\n\t\tfprintf(stderr,\n\t\t\t\"incomplete ORC unwind tables in file: %s\\n\", fname);\n\t\tgoto out;\n\t}\n\n\torc_num_entries = orc_ip_size / sizeof(int);\n\tif (orc_ip_size % sizeof(int) != 0 ||\n\t    orc_size % sizeof(struct orc_entry) != 0 ||\n\t    orc_num_entries != orc_size / sizeof(struct orc_entry)) {\n\t\tfprintf(stderr,\n\t\t\t\"inconsistent ORC unwind table entries in file: %s\\n\",\n\t\t\tfname);\n\t\tgoto out;\n\t}\n\n\t \n\tif (pthread_create(&orc_sort_thread, NULL,\n\t\t\t   sort_orctable, &orc_ip_size)) {\n\t\tfprintf(stderr,\n\t\t\t\"pthread_create orc_sort_thread failed '%s': %s\\n\",\n\t\t\tstrerror(errno), fname);\n\t\tgoto out;\n\t}\n#endif\n\n#ifdef MCOUNT_SORT_ENABLED\n\tif (!mstruct.init_data_sec || !_start_mcount_loc || !_stop_mcount_loc) {\n\t\tfprintf(stderr,\n\t\t\t\"incomplete mcount's sort in file: %s\\n\",\n\t\t\tfname);\n\t\tgoto out;\n\t}\n\n\t \n\tif (pthread_create(&mcount_sort_thread, NULL, &sort_mcount_loc, &mstruct)) {\n\t\tfprintf(stderr,\n\t\t\t\"pthread_create mcount_sort_thread failed '%s': %s\\n\",\n\t\t\tstrerror(errno), fname);\n\t\tgoto out;\n\t}\n#endif\n\tif (!extab_sec) {\n\t\tfprintf(stderr,\t\"no __ex_table in file: %s\\n\", fname);\n\t\tgoto out;\n\t}\n\n\tif (!symtab_sec) {\n\t\tfprintf(stderr,\t\"no .symtab in file: %s\\n\", fname);\n\t\tgoto out;\n\t}\n\n\tif (!strtab_sec) {\n\t\tfprintf(stderr,\t\"no .strtab in file: %s\\n\", fname);\n\t\tgoto out;\n\t}\n\n\textab_image = (void *)ehdr + _r(&extab_sec->sh_offset);\n\tstrtab = (const char *)ehdr + _r(&strtab_sec->sh_offset);\n\tsymtab = (const Elf_Sym *)((const char *)ehdr +\n\t\t\t\t\t\t  _r(&symtab_sec->sh_offset));\n\n\tif (custom_sort) {\n\t\tcustom_sort(extab_image, _r(&extab_sec->sh_size));\n\t} else {\n\t\tint num_entries = _r(&extab_sec->sh_size) / extable_ent_size;\n\t\tqsort(extab_image, num_entries,\n\t\t      extable_ent_size, compare_extable);\n\t}\n\n\t \n\tif (relocs)\n\t\tmemset(relocs, 0, relocs_size);\n\n\t \n\tfor (sym = (void *)ehdr + _r(&symtab_sec->sh_offset);\n\t     sym < sym + _r(&symtab_sec->sh_size) / sizeof(Elf_Sym);\n\t     sym++) {\n\t\tif (ELF_ST_TYPE(sym->st_info) != STT_OBJECT)\n\t\t\tcontinue;\n\t\tif (!strcmp(strtab + r(&sym->st_name),\n\t\t\t    \"main_extable_sort_needed\")) {\n\t\t\tsort_needed_sym = sym;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!sort_needed_sym) {\n\t\tfprintf(stderr,\n\t\t\t\"no main_extable_sort_needed symbol in file: %s\\n\",\n\t\t\tfname);\n\t\tgoto out;\n\t}\n\n\tsort_needed_sec = &shdr[get_secindex(r2(&sym->st_shndx),\n\t\t\t\t\t     sort_needed_sym - symtab,\n\t\t\t\t\t     symtab_shndx)];\n\tsort_needed_loc = (void *)ehdr +\n\t\t_r(&sort_needed_sec->sh_offset) +\n\t\t_r(&sort_needed_sym->st_value) -\n\t\t_r(&sort_needed_sec->sh_addr);\n\n\t \n\tw(0, sort_needed_loc);\n\trc = 0;\n\nout:\n#if defined(SORTTABLE_64) && defined(UNWINDER_ORC_ENABLED)\n\tif (orc_sort_thread) {\n\t\tvoid *retval = NULL;\n\t\t \n\t\trc = pthread_join(orc_sort_thread, &retval);\n\t\tif (rc) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"pthread_join failed '%s': %s\\n\",\n\t\t\t\tstrerror(errno), fname);\n\t\t} else if (retval) {\n\t\t\trc = -1;\n\t\t\tfprintf(stderr,\n\t\t\t\t\"failed to sort ORC tables '%s': %s\\n\",\n\t\t\t\t(char *)retval, fname);\n\t\t}\n\t}\n#endif\n\n#ifdef MCOUNT_SORT_ENABLED\n\tif (mcount_sort_thread) {\n\t\tvoid *retval = NULL;\n\t\t \n\t\trc = pthread_join(mcount_sort_thread, &retval);\n\t\tif (rc) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"pthread_join failed '%s': %s\\n\",\n\t\t\t\tstrerror(errno), fname);\n\t\t} else if (retval) {\n\t\t\trc = -1;\n\t\t\tfprintf(stderr,\n\t\t\t\t\"failed to sort mcount '%s': %s\\n\",\n\t\t\t\t(char *)retval, fname);\n\t\t}\n\t}\n#endif\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}