{
  "module_name": "jobserver-exec",
  "hash_id": "f51c1705b7e73a6f5cb3b0d83e6465f55547e66899018c23676a35df4e82eca0",
  "original_prompt": "Ingested from linux-6.6.14/scripts/jobserver-exec",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0+\n#\n# This determines how many parallel tasks \"make\" is expecting, as it is\n# not exposed via an special variables, reserves them all, runs a subprocess\n# with PARALLELISM environment variable set, and releases the jobs back again.\n#\n# https://www.gnu.org/software/make/manual/html_node/POSIX-Jobserver.html#POSIX-Jobserver\nfrom __future__ import print_function\nimport os, sys, errno\nimport subprocess\n\n# Extract and prepare jobserver file descriptors from environment.\nclaim = 0\njobs = b\"\"\ntry:\n\t# Fetch the make environment options.\n\tflags = os.environ['MAKEFLAGS']\n\n\t# Look for \"--jobserver=R,W\"\n\t# Note that GNU Make has used --jobserver-fds and --jobserver-auth\n\t# so this handles all of them.\n\topts = [x for x in flags.split(\" \") if x.startswith(\"--jobserver\")]\n\n\t# Parse out R,W file descriptor numbers and set them nonblocking.\n\t# If the MAKEFLAGS variable contains multiple instances of the\n\t# --jobserver-auth= option, the last one is relevant.\n\tfds = opts[-1].split(\"=\", 1)[1]\n\n\t# Starting with GNU Make 4.4, named pipes are used for reader and writer.\n\t# Example argument: --jobserver-auth=fifo:/tmp/GMfifo8134\n\t_, _, path = fds.partition('fifo:')\n\n\tif path:\n\t\treader = os.open(path, os.O_RDONLY | os.O_NONBLOCK)\n\t\twriter = os.open(path, os.O_WRONLY)\n\telse:\n\t\treader, writer = [int(x) for x in fds.split(\",\", 1)]\n\t\t# Open a private copy of reader to avoid setting nonblocking\n\t\t# on an unexpecting process with the same reader fd.\n\t\treader = os.open(\"/proc/self/fd/%d\" % (reader),\n\t\t\t\t os.O_RDONLY | os.O_NONBLOCK)\n\n\t# Read out as many jobserver slots as possible.\n\twhile True:\n\t\ttry:\n\t\t\tslot = os.read(reader, 8)\n\t\t\tjobs += slot\n\t\texcept (OSError, IOError) as e:\n\t\t\tif e.errno == errno.EWOULDBLOCK:\n\t\t\t\t# Stop at the end of the jobserver queue.\n\t\t\t\tbreak\n\t\t\t# If something went wrong, give back the jobs.\n\t\t\tif len(jobs):\n\t\t\t\tos.write(writer, jobs)\n\t\t\traise e\n\t# Add a bump for our caller's reserveration, since we're just going\n\t# to sit here blocked on our child.\n\tclaim = len(jobs) + 1\nexcept (KeyError, IndexError, ValueError, OSError, IOError) as e:\n\t# Any missing environment strings or bad fds should result in just\n\t# not being parallel.\n\tpass\n\n# We can only claim parallelism if there was a jobserver (i.e. a top-level\n# \"-jN\" argument) and there were no other failures. Otherwise leave out the\n# environment variable and let the child figure out what is best.\nif claim > 0:\n\tos.environ['PARALLELISM'] = '%d' % (claim)\n\nrc = subprocess.call(sys.argv[1:])\n\n# Return all the reserved slots.\nif len(jobs):\n\tos.write(writer, jobs)\n\nsys.exit(rc)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}