{
  "module_name": "extract-module-sig.pl",
  "hash_id": "ac9e13a0a3c2cc9c554a7c730850b53d3259bb5fd8a9ddec17c1a5dd7551ac11",
  "original_prompt": "Ingested from linux-6.6.14/scripts/extract-module-sig.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# extract-mod-sig <part> <module-file>\n#\n# Reads the module file and writes out some or all of the signature\n# section to stdout.  Part is the bit to be written and is one of:\n#\n#  -0: The unsigned module, no signature data at all\n#  -a: All of the signature data, including magic number\n#  -d: Just the descriptor values as a sequence of numbers\n#  -n: Just the signer's name\n#  -k: Just the key ID\n#  -s: Just the crypto signature or PKCS#7 message\n#\nuse warnings;\nuse strict;\n\ndie \"Format: $0 -[0adnks] module-file >out\\n\"\n    if ($#ARGV != 1);\n\nmy $part = $ARGV[0];\nmy $modfile = $ARGV[1];\n\nmy $magic_number = \"~Module signature appended~\\n\";\n\n#\n# Read the module contents\n#\nopen FD, \"<$modfile\" || die $modfile;\nbinmode(FD);\nmy @st = stat(FD);\ndie \"$modfile\" unless (@st);\nmy $buf = \"\";\nmy $len = sysread(FD, $buf, $st[7]);\ndie \"$modfile\" unless (defined($len));\ndie \"Short read on $modfile\\n\" unless ($len == $st[7]);\nclose(FD) || die $modfile;\n\nprint STDERR \"Read \", $len, \" bytes from module file\\n\";\n\ndie \"The file is too short to have a sig magic number and descriptor\\n\"\n    if ($len < 12 + length($magic_number));\n\n#\n# Check for the magic number and extract the information block\n#\nmy $p = $len - length($magic_number);\nmy $raw_magic = substr($buf, $p);\n\ndie \"Magic number not found at $len\\n\"\n    if ($raw_magic ne $magic_number);\nprint STDERR \"Found magic number at $len\\n\";\n\n$p -= 12;\nmy $raw_info = substr($buf, $p, 12);\n\nmy @info = unpack(\"CCCCCxxxN\", $raw_info);\nmy ($algo, $hash, $id_type, $name_len, $kid_len, $sig_len) = @info;\n\nif ($id_type == 0) {\n    print STDERR \"Found PGP key identifier\\n\";\n} elsif ($id_type == 1) {\n    print STDERR \"Found X.509 cert identifier\\n\";\n} elsif ($id_type == 2) {\n    print STDERR \"Found PKCS#7/CMS encapsulation\\n\";\n} else {\n    print STDERR \"Found unsupported identifier type $id_type\\n\";\n}\n\n#\n# Extract the three pieces of info data\n#\ndie \"Insufficient name+kid+sig data in file\\n\"\n    unless ($p >= $name_len + $kid_len + $sig_len);\n\n$p -= $sig_len;\nmy $raw_sig = substr($buf, $p, $sig_len);\n$p -= $kid_len;\nmy $raw_kid = substr($buf, $p, $kid_len);\n$p -= $name_len;\nmy $raw_name = substr($buf, $p, $name_len);\n\nmy $module_len = $p;\n\nif ($sig_len > 0) {\n    print STDERR \"Found $sig_len bytes of signature [\";\n    my $n = $sig_len > 16 ? 16 : $sig_len;\n    foreach my $i (unpack(\"C\" x $n, substr($raw_sig, 0, $n))) {\n\tprintf STDERR \"%02x\", $i;\n    }\n    print STDERR \"]\\n\";\n}\n\nif ($kid_len > 0) {\n    print STDERR \"Found $kid_len bytes of key identifier [\";\n    my $n = $kid_len > 16 ? 16 : $kid_len;\n    foreach my $i (unpack(\"C\" x $n, substr($raw_kid, 0, $n))) {\n\tprintf STDERR \"%02x\", $i;\n    }\n    print STDERR \"]\\n\";\n}\n\nif ($name_len > 0) {\n    print STDERR \"Found $name_len bytes of signer's name [$raw_name]\\n\";\n}\n\n#\n# Produce the requested output\n#\nif ($part eq \"-0\") {\n    # The unsigned module, no signature data at all\n    binmode(STDOUT);\n    print substr($buf, 0, $module_len);\n} elsif ($part eq \"-a\") {\n    # All of the signature data, including magic number\n    binmode(STDOUT);\n    print substr($buf, $module_len);\n} elsif ($part eq \"-d\") {\n    # Just the descriptor values as a sequence of numbers\n    print join(\" \", @info), \"\\n\";\n} elsif ($part eq \"-n\") {\n    # Just the signer's name\n    print STDERR \"No signer's name for PKCS#7 message type sig\\n\"\n\tif ($id_type == 2);\n    binmode(STDOUT);\n    print $raw_name;\n} elsif ($part eq \"-k\") {\n    # Just the key identifier\n    print STDERR \"No key ID for PKCS#7 message type sig\\n\"\n\tif ($id_type == 2);\n    binmode(STDOUT);\n    print $raw_kid;\n} elsif ($part eq \"-s\") {\n    # Just the crypto signature or PKCS#7 message\n    binmode(STDOUT);\n    print $raw_sig;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}