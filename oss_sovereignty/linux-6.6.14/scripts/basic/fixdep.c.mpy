{
  "module_name": "fixdep.c",
  "hash_id": "339a660cbf87f483448a63163e4b3acba9d42a01a931524421f1e6fcc48e053b",
  "original_prompt": "Ingested from linux-6.6.14/scripts/basic/fixdep.c",
  "human_readable_source": " \n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\nstatic void usage(void)\n{\n\tfprintf(stderr, \"Usage: fixdep <depfile> <target> <cmdline>\\n\");\n\texit(1);\n}\n\nstruct item {\n\tstruct item\t*next;\n\tunsigned int\tlen;\n\tunsigned int\thash;\n\tchar\t\tname[];\n};\n\n#define HASHSZ 256\nstatic struct item *config_hashtab[HASHSZ], *file_hashtab[HASHSZ];\n\nstatic unsigned int strhash(const char *str, unsigned int sz)\n{\n\t \n\tunsigned int i, hash = 2166136261U;\n\n\tfor (i = 0; i < sz; i++)\n\t\thash = (hash ^ str[i]) * 0x01000193;\n\treturn hash;\n}\n\n \nstatic void add_to_hashtable(const char *name, int len, unsigned int hash,\n\t\t\t     struct item *hashtab[])\n{\n\tstruct item *aux = malloc(sizeof(*aux) + len);\n\n\tif (!aux) {\n\t\tperror(\"fixdep:malloc\");\n\t\texit(1);\n\t}\n\tmemcpy(aux->name, name, len);\n\taux->len = len;\n\taux->hash = hash;\n\taux->next = hashtab[hash % HASHSZ];\n\thashtab[hash % HASHSZ] = aux;\n}\n\n \nstatic bool in_hashtable(const char *name, int len, struct item *hashtab[])\n{\n\tstruct item *aux;\n\tunsigned int hash = strhash(name, len);\n\n\tfor (aux = hashtab[hash % HASHSZ]; aux; aux = aux->next) {\n\t\tif (aux->hash == hash && aux->len == len &&\n\t\t    memcmp(aux->name, name, len) == 0)\n\t\t\treturn true;\n\t}\n\n\tadd_to_hashtable(name, len, hash, hashtab);\n\n\treturn false;\n}\n\n \nstatic void use_config(const char *m, int slen)\n{\n\tif (in_hashtable(m, slen, config_hashtab))\n\t\treturn;\n\n\t \n\tprintf(\"    $(wildcard include/config/%.*s) \\\\\\n\", slen, m);\n}\n\n \nstatic int str_ends_with(const char *s, int slen, const char *sub)\n{\n\tint sublen = strlen(sub);\n\n\tif (sublen > slen)\n\t\treturn 0;\n\n\treturn !memcmp(s + slen - sublen, sub, sublen);\n}\n\nstatic void parse_config_file(const char *p)\n{\n\tconst char *q, *r;\n\tconst char *start = p;\n\n\twhile ((p = strstr(p, \"CONFIG_\"))) {\n\t\tif (p > start && (isalnum(p[-1]) || p[-1] == '_')) {\n\t\t\tp += 7;\n\t\t\tcontinue;\n\t\t}\n\t\tp += 7;\n\t\tq = p;\n\t\twhile (isalnum(*q) || *q == '_')\n\t\t\tq++;\n\t\tif (str_ends_with(p, q - p, \"_MODULE\"))\n\t\t\tr = q - 7;\n\t\telse\n\t\t\tr = q;\n\t\tif (r > p)\n\t\t\tuse_config(p, r - p);\n\t\tp = q;\n\t}\n}\n\nstatic void *read_file(const char *filename)\n{\n\tstruct stat st;\n\tint fd;\n\tchar *buf;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"fixdep: error opening file: \");\n\t\tperror(filename);\n\t\texit(2);\n\t}\n\tif (fstat(fd, &st) < 0) {\n\t\tfprintf(stderr, \"fixdep: error fstat'ing file: \");\n\t\tperror(filename);\n\t\texit(2);\n\t}\n\tbuf = malloc(st.st_size + 1);\n\tif (!buf) {\n\t\tperror(\"fixdep: malloc\");\n\t\texit(2);\n\t}\n\tif (read(fd, buf, st.st_size) != st.st_size) {\n\t\tperror(\"fixdep: read\");\n\t\texit(2);\n\t}\n\tbuf[st.st_size] = '\\0';\n\tclose(fd);\n\n\treturn buf;\n}\n\n \nstatic int is_ignored_file(const char *s, int len)\n{\n\treturn str_ends_with(s, len, \"include/generated/autoconf.h\");\n}\n\n \nstatic int is_no_parse_file(const char *s, int len)\n{\n\t \n\treturn str_ends_with(s, len, \".rlib\") ||\n\t       str_ends_with(s, len, \".rmeta\") ||\n\t       str_ends_with(s, len, \".so\");\n}\n\n \nstatic void parse_dep_file(char *p, const char *target)\n{\n\tbool saw_any_target = false;\n\tbool is_target = true;\n\tbool is_source = false;\n\tbool need_parse;\n\tchar *q, saved_c;\n\n\twhile (*p) {\n\t\t \n\t\tswitch (*p) {\n\t\tcase '#':\n\t\t\t \n\t\t\tp++;\n\t\t\twhile (*p != '\\0' && *p != '\\n') {\n\t\t\t\t \n\t\t\t\tif (*p == '\\\\')\n\t\t\t\t\tp++;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\t\t \n\t\t\tp++;\n\t\t\tcontinue;\n\t\tcase '\\\\':\n\t\t\t \n\t\t\tif (*(p + 1) == '\\n') {\n\t\t\t\tp += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\t \n\t\t\tp++;\n\t\t\tis_target = true;\n\t\t\tcontinue;\n\t\tcase ':':\n\t\t\t \n\t\t\tp++;\n\t\t\tis_target = false;\n\t\t\tis_source = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tq = p;\n\t\twhile (*q != ' ' && *q != '\\t' && *q != '\\n' && *q != '#' && *q != ':') {\n\t\t\tif (*q == '\\\\') {\n\t\t\t\t \n\t\t\t\tif (*(q + 1) == '\\n')\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (*(q + 1) == '#' || *(q + 1) == ':') {\n\t\t\t\t\tmemmove(p + 1, p, q - p);\n\t\t\t\t\tp++;\n\t\t\t\t}\n\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tif (*q == '\\0')\n\t\t\t\tbreak;\n\t\t\tq++;\n\t\t}\n\n\t\t \n\t\tif (is_target) {\n\t\t\tp = q;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsaved_c = *q;\n\t\t*q = '\\0';\n\t\tneed_parse = false;\n\n\t\t \n\t\tif (is_source) {\n\t\t\t \n\t\t\tif (!saw_any_target) {\n\t\t\t\tsaw_any_target = true;\n\t\t\t\tprintf(\"source_%s := %s\\n\\n\", target, p);\n\t\t\t\tprintf(\"deps_%s := \\\\\\n\", target);\n\t\t\t\tneed_parse = true;\n\t\t\t}\n\t\t} else if (!is_ignored_file(p, q - p) &&\n\t\t\t   !in_hashtable(p, q - p, file_hashtab)) {\n\t\t\tprintf(\"  %s \\\\\\n\", p);\n\t\t\tneed_parse = true;\n\t\t}\n\n\t\tif (need_parse && !is_no_parse_file(p, q - p)) {\n\t\t\tvoid *buf;\n\n\t\t\tbuf = read_file(p);\n\t\t\tparse_config_file(buf);\n\t\t\tfree(buf);\n\t\t}\n\n\t\tis_source = false;\n\t\t*q = saved_c;\n\t\tp = q;\n\t}\n\n\tif (!saw_any_target) {\n\t\tfprintf(stderr, \"fixdep: parse error; no targets found\\n\");\n\t\texit(1);\n\t}\n\n\tprintf(\"\\n%s: $(deps_%s)\\n\\n\", target, target);\n\tprintf(\"$(deps_%s):\\n\", target);\n}\n\nint main(int argc, char *argv[])\n{\n\tconst char *depfile, *target, *cmdline;\n\tvoid *buf;\n\n\tif (argc != 4)\n\t\tusage();\n\n\tdepfile = argv[1];\n\ttarget = argv[2];\n\tcmdline = argv[3];\n\n\tprintf(\"savedcmd_%s := %s\\n\\n\", target, cmdline);\n\n\tbuf = read_file(depfile);\n\tparse_dep_file(buf, target);\n\tfree(buf);\n\n\tfflush(stdout);\n\n\t \n\tif (ferror(stdout)) {\n\t\tfprintf(stderr, \"fixdep: not all data was written to the output\\n\");\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}