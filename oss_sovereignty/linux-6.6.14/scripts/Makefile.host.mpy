{
  "module_name": "Makefile.host",
  "hash_id": "35635bf1604f6ef58574e67c5de5a31a880921ac47301465fec1d3ab7f47ece2",
  "original_prompt": "Ingested from linux-6.6.14/scripts/Makefile.host",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n\n# LEX\n# ---------------------------------------------------------------------------\nquiet_cmd_flex = LEX     $@\n      cmd_flex = $(LEX) -o$@ -L $<\n\n$(obj)/%.lex.c: $(src)/%.l FORCE\n\t$(call if_changed,flex)\n\n# YACC\n# ---------------------------------------------------------------------------\nquiet_cmd_bison = YACC    $(basename $@).[ch]\n      cmd_bison = $(YACC) -o $(basename $@).c --defines=$(basename $@).h -t -l $<\n\n$(obj)/%.tab.c $(obj)/%.tab.h: $(src)/%.y FORCE\n\t$(call if_changed,bison)\n\n# ==========================================================================\n# Building binaries on the host system\n# Binaries are used during the compilation of the kernel, for example\n# to preprocess a data file.\n#\n# Both C and C++ are supported, but preferred language is C for such utilities.\n# Rust is also supported, but it may only be used in scenarios where a Rust\n# toolchain is required to be available (e.g. when  `CONFIG_RUST` is enabled).\n#\n# Sample syntax (see Documentation/kbuild/makefiles.rst for reference)\n# hostprogs := bin2hex\n# Will compile bin2hex.c and create an executable named bin2hex\n#\n# hostprogs     := lxdialog\n# lxdialog-objs := checklist.o lxdialog.o\n# Will compile lxdialog.c and checklist.c, and then link the executable\n# lxdialog, based on checklist.o and lxdialog.o\n#\n# hostprogs       := qconf\n# qconf-cxxobjs   := qconf.o\n# qconf-objs      := menu.o\n# Will compile qconf as a C++ program, and menu as a C program.\n# They are linked as C++ code to the executable qconf\n#\n# hostprogs   := target\n# target-rust := y\n# Will compile `target` as a Rust program, using `target.rs` as the crate root.\n# The crate may consist of several source files.\n\n# C code\n# Executables compiled from a single .c file\nhost-csingle\t:= $(foreach m,$(hostprogs), \\\n\t\t\t$(if $($(m)-objs)$($(m)-cxxobjs)$($(m)-rust),,$(m)))\n\n# C executables linked based on several .o files\nhost-cmulti\t:= $(foreach m,$(hostprogs),\\\n\t\t   $(if $($(m)-cxxobjs)$($(m)-rust),,$(if $($(m)-objs),$(m))))\n\n# Object (.o) files compiled from .c files\nhost-cobjs\t:= $(sort $(foreach m,$(hostprogs),$($(m)-objs)))\n\n# C++ code\n# C++ executables compiled from at least one .cc file\n# and zero or more .c files\nhost-cxxmulti\t:= $(foreach m,$(hostprogs),$(if $($(m)-cxxobjs),$(m)))\n\n# C++ Object (.o) files compiled from .cc files\nhost-cxxobjs\t:= $(sort $(foreach m,$(host-cxxmulti),$($(m)-cxxobjs)))\n\n# Rust code\n# Executables compiled from a single Rust crate (which may consist of\n# one or more .rs files)\nhost-rust\t:= $(foreach m,$(hostprogs),$(if $($(m)-rust),$(m)))\n\nhost-csingle\t:= $(addprefix $(obj)/,$(host-csingle))\nhost-cmulti\t:= $(addprefix $(obj)/,$(host-cmulti))\nhost-cobjs\t:= $(addprefix $(obj)/,$(host-cobjs))\nhost-cxxmulti\t:= $(addprefix $(obj)/,$(host-cxxmulti))\nhost-cxxobjs\t:= $(addprefix $(obj)/,$(host-cxxobjs))\nhost-rust\t:= $(addprefix $(obj)/,$(host-rust))\n\n#####\n# Handle options to gcc. Support building with separate output directory\n\nhostc_flags    = -Wp,-MMD,$(depfile) \\\n                 $(KBUILD_HOSTCFLAGS) $(HOST_EXTRACFLAGS) \\\n                 $(HOSTCFLAGS_$(target-stem).o)\nhostcxx_flags  = -Wp,-MMD,$(depfile) \\\n                 $(KBUILD_HOSTCXXFLAGS) $(HOST_EXTRACXXFLAGS) \\\n                 $(HOSTCXXFLAGS_$(target-stem).o)\n\n# `--out-dir` is required to avoid temporaries being created by `rustc` in the\n# current working directory, which may be not accessible in the out-of-tree\n# modules case.\nhostrust_flags = --out-dir $(dir $@) --emit=dep-info=$(depfile) \\\n                 $(KBUILD_HOSTRUSTFLAGS) $(HOST_EXTRARUSTFLAGS) \\\n                 $(HOSTRUSTFLAGS_$(target-stem))\n\n# $(objtree)/$(obj) for including generated headers from checkin source files\nifeq ($(KBUILD_EXTMOD),)\nifdef building_out_of_srctree\nhostc_flags   += -I $(objtree)/$(obj)\nhostcxx_flags += -I $(objtree)/$(obj)\nendif\nendif\n\n#####\n# Compile programs on the host\n\n# Create executable from a single .c file\n# host-csingle -> Executable\nquiet_cmd_host-csingle \t= HOSTCC  $@\n      cmd_host-csingle\t= $(HOSTCC) $(hostc_flags) $(KBUILD_HOSTLDFLAGS) -o $@ $< \\\n\t\t$(KBUILD_HOSTLDLIBS) $(HOSTLDLIBS_$(target-stem))\n$(host-csingle): $(obj)/%: $(src)/%.c FORCE\n\t$(call if_changed_dep,host-csingle)\n\n# Link an executable based on list of .o files, all plain c\n# host-cmulti -> executable\nquiet_cmd_host-cmulti\t= HOSTLD  $@\n      cmd_host-cmulti\t= $(HOSTCC) $(KBUILD_HOSTLDFLAGS) -o $@ \\\n\t\t\t  $(addprefix $(obj)/, $($(target-stem)-objs)) \\\n\t\t\t  $(KBUILD_HOSTLDLIBS) $(HOSTLDLIBS_$(target-stem))\n$(host-cmulti): FORCE\n\t$(call if_changed,host-cmulti)\n$(call multi_depend, $(host-cmulti), , -objs)\n\n# Create .o file from a single .c file\n# host-cobjs -> .o\nquiet_cmd_host-cobjs\t= HOSTCC  $@\n      cmd_host-cobjs\t= $(HOSTCC) $(hostc_flags) -c -o $@ $<\n$(host-cobjs): $(obj)/%.o: $(src)/%.c FORCE\n\t$(call if_changed_dep,host-cobjs)\n\n# Link an executable based on list of .o files, a mixture of .c and .cc\n# host-cxxmulti -> executable\nquiet_cmd_host-cxxmulti\t= HOSTLD  $@\n      cmd_host-cxxmulti\t= $(HOSTCXX) $(KBUILD_HOSTLDFLAGS) -o $@ \\\n\t\t\t  $(foreach o,objs cxxobjs,\\\n\t\t\t  $(addprefix $(obj)/, $($(target-stem)-$(o)))) \\\n\t\t\t  $(KBUILD_HOSTLDLIBS) $(HOSTLDLIBS_$(target-stem))\n$(host-cxxmulti): FORCE\n\t$(call if_changed,host-cxxmulti)\n$(call multi_depend, $(host-cxxmulti), , -objs -cxxobjs)\n\n# Create .o file from a single .cc (C++) file\nquiet_cmd_host-cxxobjs\t= HOSTCXX $@\n      cmd_host-cxxobjs\t= $(HOSTCXX) $(hostcxx_flags) -c -o $@ $<\n$(host-cxxobjs): $(obj)/%.o: $(src)/%.cc FORCE\n\t$(call if_changed_dep,host-cxxobjs)\n\n# Create executable from a single Rust crate (which may consist of\n# one or more `.rs` files)\n# host-rust -> Executable\nquiet_cmd_host-rust\t= HOSTRUSTC $@\n      cmd_host-rust\t= \\\n\t$(HOSTRUSTC) $(hostrust_flags) --emit=link=$@ $<\n$(host-rust): $(obj)/%: $(src)/%.rs FORCE\n\t$(call if_changed_dep,host-rust)\n\ntargets += $(host-csingle) $(host-cmulti) $(host-cobjs) \\\n\t   $(host-cxxmulti) $(host-cxxobjs) $(host-rust)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}