{
  "module_name": "checkstack.pl",
  "hash_id": "9790586da6538c4ba06b69767c902f0d0f3ee44030495007d4b94434ab373502",
  "original_prompt": "Ingested from linux-6.6.14/scripts/checkstack.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n\n#\tCheck the stack usage of functions\n#\n#\tCopyright Joern Engel <joern@lazybastard.org>\n#\tInspired by Linus Torvalds\n#\tOriginal idea maybe from Keith Owens\n#\ts390 port and big speedup by Arnd Bergmann <arnd@bergmann-dalldorf.de>\n#\tMips port by Juan Quintela <quintela@mandrakesoft.com>\n#\tIA64 port via Andreas Dilger\n#\tArm port by Holger Schurig\n#\tRandom bits by Matt Mackall <mpm@selenic.com>\n#\tM68k port by Geert Uytterhoeven and Andreas Schwab\n#\tAArch64, PARISC ports by Kyle McMartin\n#\tsparc port by Martin Habets <errandir_news@mph.eclipse.co.uk>\n#\tppc64le port by Breno Leitao <leitao@debian.org>\n#\triscv port by Wadim Mueller <wafgo01@gmail.com>\n#\n#\tUsage:\n#\tobjdump -d vmlinux | scripts/checkstack.pl [arch]\n#\n#\tTODO :\tPort to all architectures (one regex per arch)\n\nuse strict;\n\n# check for arch\n#\n# $re is used for two matches:\n# $& (whole re) matches the complete objdump line with the stack growth\n# $1 (first bracket) matches the size of the stack growth\n#\n# $dre is similar, but for dynamic stack redutions:\n# $& (whole re) matches the complete objdump line with the stack growth\n# $1 (first bracket) matches the dynamic amount of the stack growth\n#\n# $sub: subroutine for special handling to check stack usage.\n#\n# use anything else and feel the pain ;)\nmy (@stack, $re, $dre, $sub, $x, $xs, $funcre, $min_stack);\n{\n\tmy $arch = shift;\n\tif ($arch eq \"\") {\n\t\t$arch = `uname -m`;\n\t\tchomp($arch);\n\t}\n\n\t$min_stack = shift;\n\tif ($min_stack eq \"\" || $min_stack !~ /^\\d+$/) {\n\t\t$min_stack = 100;\n\t}\n\n\t$x\t= \"[0-9a-f]\";\t# hex character\n\t$xs\t= \"[0-9a-f ]\";\t# hex character or space\n\t$funcre = qr/^$x* <(.*)>:$/;\n\tif ($arch =~ '^(aarch|arm)64$') {\n\t\t#ffffffc0006325cc:       a9bb7bfd        stp     x29, x30, [sp, #-80]!\n\t\t#a110:       d11643ff        sub     sp, sp, #0x590\n\t\t$re = qr/^.*stp.*sp, \\#-([0-9]{1,8})\\]\\!/o;\n\t\t$dre = qr/^.*sub.*sp, sp, #(0x$x{1,8})/o;\n\t} elsif ($arch eq 'arm') {\n\t\t#c0008ffc:\te24dd064\tsub\tsp, sp, #100\t; 0x64\n\t\t$re = qr/.*sub.*sp, sp, #([0-9]{1,4})/o;\n\t\t$sub = \\&arm_push_handling;\n\t} elsif ($arch =~ /^x86(_64)?$/ || $arch =~ /^i[3456]86$/) {\n\t\t#c0105234:       81 ec ac 05 00 00       sub    $0x5ac,%esp\n\t\t# or\n\t\t#    2f60:    48 81 ec e8 05 00 00       sub    $0x5e8,%rsp\n\t\t$re = qr/^.*[as][du][db]    \\$(0x$x{1,8}),\\%(e|r)sp$/o;\n\t\t$dre = qr/^.*[as][du][db]    (%.*),\\%(e|r)sp$/o;\n\t} elsif ($arch eq 'ia64') {\n\t\t#e0000000044011fc:       01 0f fc 8c     adds r12=-384,r12\n\t\t$re = qr/.*adds.*r12=-(([0-9]{2}|[3-9])[0-9]{2}),r12/o;\n\t} elsif ($arch eq 'm68k') {\n\t\t#    2b6c:       4e56 fb70       linkw %fp,#-1168\n\t\t#  1df770:       defc ffe4       addaw #-28,%sp\n\t\t$re = qr/.*(?:linkw %fp,|addaw )#-([0-9]{1,4})(?:,%sp)?$/o;\n\t} elsif ($arch eq 'mips64') {\n\t\t#8800402c:       67bdfff0        daddiu  sp,sp,-16\n\t\t$re = qr/.*daddiu.*sp,sp,-(([0-9]{2}|[3-9])[0-9]{2})/o;\n\t} elsif ($arch eq 'mips') {\n\t\t#88003254:       27bdffe0        addiu   sp,sp,-32\n\t\t$re = qr/.*addiu.*sp,sp,-(([0-9]{2}|[3-9])[0-9]{2})/o;\n\t} elsif ($arch eq 'nios2') {\n\t\t#25a8:\tdefffb04 \taddi\tsp,sp,-20\n\t\t$re = qr/.*addi.*sp,sp,-(([0-9]{2}|[3-9])[0-9]{2})/o;\n\t} elsif ($arch eq 'openrisc') {\n\t\t# c000043c:       9c 21 fe f0     l.addi r1,r1,-272\n\t\t$re = qr/.*l\\.addi.*r1,r1,-(([0-9]{2}|[3-9])[0-9]{2})/o;\n\t} elsif ($arch eq 'parisc' || $arch eq 'parisc64') {\n\t\t$re = qr/.*ldo ($x{1,8})\\(sp\\),sp/o;\n\t} elsif ($arch eq 'powerpc' || $arch =~ /^ppc(64)?(le)?$/ ) {\n\t\t# powerpc    : 94 21 ff 30     stwu    r1,-208(r1)\n\t\t# ppc64(le)  : 81 ff 21 f8     stdu    r1,-128(r1)\n\t\t$re = qr/.*st[dw]u.*r1,-($x{1,8})\\(r1\\)/o;\n\t} elsif ($arch =~ /^s390x?$/) {\n\t\t#   11160:       a7 fb ff 60             aghi   %r15,-160\n\t\t# or\n\t\t#  100092:\t e3 f0 ff c8 ff 71\t lay\t %r15,-56(%r15)\n\t\t$re = qr/.*(?:lay|ag?hi).*\\%r15,-([0-9]+)(?:\\(\\%r15\\))?$/o;\n\t} elsif ($arch eq 'sparc' || $arch eq 'sparc64') {\n\t\t# f0019d10:       9d e3 bf 90     save  %sp, -112, %sp\n\t\t$re = qr/.*save.*%sp, -(([0-9]{2}|[3-9])[0-9]{2}), %sp/o;\n\t} elsif ($arch =~ /^riscv(64)?$/) {\n\t\t#ffffffff8036e868:\tc2010113          \taddi\tsp,sp,-992\n\t\t$re = qr/.*addi.*sp,sp,-(([0-9]{2}|[3-9])[0-9]{2})/o;\n\t} else {\n\t\tprint(\"wrong or unknown architecture \\\"$arch\\\"\\n\");\n\t\texit\n\t}\n}\n\n#\n# To count stack usage of push {*, fp, ip, lr, pc} instruction in ARM,\n# if FRAME POINTER is enabled.\n# e.g. c01f0d48: e92ddff0 push {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}\n#\nsub arm_push_handling {\n\tmy $regex = qr/.*push.*fp, ip, lr, pc}/o;\n\tmy $size = 0;\n\tmy $line_arg = shift;\n\n\tif ($line_arg =~ m/$regex/) {\n\t\t$size = $line_arg =~ tr/,//;\n\t\t$size = ($size + 1) * 4;\n\t}\n\n\treturn $size;\n}\n\n#\n# main()\n#\nmy ($func, $file, $lastslash, $total_size, $addr, $intro);\n\n$total_size = 0;\n\nwhile (my $line = <STDIN>) {\n\tif ($line =~ m/$funcre/) {\n\t\t$func = $1;\n\t\tnext if $line !~ m/^($x*)/;\n\t\tif ($total_size > $min_stack) {\n\t\t\tpush @stack, \"$intro$total_size\\n\";\n\t\t}\n\t\t$addr = \"0x$1\";\n\t\t$intro = \"$addr $func [$file]:\";\n\t\tmy $padlen = 56 - length($intro);\n\t\twhile ($padlen > 0) {\n\t\t\t$intro .= '\t';\n\t\t\t$padlen -= 8;\n\t\t}\n\n\t\t$total_size = 0;\n\t}\n\telsif ($line =~ m/(.*):\\s*file format/) {\n\t\t$file = $1;\n\t\t$file =~ s/\\.ko//;\n\t\t$lastslash = rindex($file, \"/\");\n\t\tif ($lastslash != -1) {\n\t\t\t$file = substr($file, $lastslash + 1);\n\t\t}\n\t}\n\telsif ($line =~ m/$re/) {\n\t\tmy $size = $1;\n\t\t$size = hex($size) if ($size =~ /^0x/);\n\n\t\tif ($size > 0xf0000000) {\n\t\t\t$size = - $size;\n\t\t\t$size += 0x80000000;\n\t\t\t$size += 0x80000000;\n\t\t}\n\t\tnext if ($size > 0x10000000);\n\n\t\t$total_size += $size;\n\t}\n\telsif (defined $dre && $line =~ m/$dre/) {\n\t\tmy $size = $1;\n\n\t\t$size = hex($size) if ($size =~ /^0x/);\n\t\t$total_size += $size;\n\t}\n\telsif (defined $sub) {\n\t\tmy $size = &$sub($line);\n\n\t\t$total_size += $size;\n\t}\n}\nif ($total_size > $min_stack) {\n\tpush @stack, \"$intro$total_size\\n\";\n}\n\n# Sort output by size (last field)\nprint sort { ($b =~ /:\\t*(\\d+)$/)[0] <=> ($a =~ /:\\t*(\\d+)$/)[0] } @stack;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}