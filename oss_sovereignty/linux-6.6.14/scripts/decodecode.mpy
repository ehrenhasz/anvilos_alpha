{
  "module_name": "decodecode",
  "hash_id": "166fd4440b97bb6c107b4f784d0bcd422f47ceb4ed5ea30ae4098aa99d9004f1",
  "original_prompt": "Ingested from linux-6.6.14/scripts/decodecode",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# Disassemble the Code: line in Linux oopses\n# usage: decodecode < oops.file\n#\n# options: set env. variable AFLAGS=options to pass options to \"as\";\n# e.g., to decode an i386 oops on an x86_64 system, use:\n# AFLAGS=--32 decodecode < 386.oops\n# PC=hex - the PC (program counter) the oops points to\n\nfaultlinenum=1\n\ncleanup() {\n\trm -f $T $T.s $T.o $T.oo $T.aa $T.dis\n\texit 1\n}\n\ndie() {\n\techo \"$@\"\n\texit 1\n}\n\ntrap cleanup EXIT\n\nT=`mktemp` || die \"cannot create temp file\"\ncode=\ncont=\n\nwhile read i ; do\n\ncase \"$i\" in\n*Code:*)\n\tcode=$i\n\tcont=yes\n\t;;\n*)\n\t[ -n \"$cont\" ] && {\n\t\txdump=\"$(echo $i | grep '^[[:xdigit:]<>[:space:]]\\+$')\"\n\t\tif [ -n \"$xdump\" ]; then\n\t\t\tcode=\"$code $xdump\"\n\t\telse\n\t\t\tcont=\n\t\tfi\n\t}\n\t;;\nesac\n\ndone\n\nif [ -z \"$code\" ]; then\n\trm $T\n\texit\nfi\n\necho $code\ncode=`echo $code | sed -e 's/.*Code: //'`\n\nwidth=`expr index \"$code\" ' '`\nwidth=$((($width-1)/2))\ncase $width in\n1) type=byte ;;\n2) type=2byte ;;\n4) type=4byte ;;\nesac\n\nif [ -z \"$ARCH\" ]; then\n    case `uname -m` in\n\taarch64*) ARCH=arm64 ;;\n\tarm*) ARCH=arm ;;\n    esac\nfi\n\n# Params: (tmp_file, pc_sub)\ndisas() {\n\tt=$1\n\tpc_sub=$2\n\n\t${CROSS_COMPILE}as $AFLAGS -o $t.o $t.s > /dev/null 2>&1\n\n\tif [ \"$ARCH\" = \"arm\" ]; then\n\t\tif [ $width -eq 2 ]; then\n\t\t\tOBJDUMPFLAGS=\"-M force-thumb\"\n\t\tfi\n\n\t\t${CROSS_COMPILE}strip $t.o\n\tfi\n\n\tif [ \"$ARCH\" = \"arm64\" ]; then\n\t\tif [ $width -eq 4 ]; then\n\t\t\ttype=inst\n\t\tfi\n\n\t\t${CROSS_COMPILE}strip $t.o\n\tfi\n\n\tif [ \"$ARCH\" = \"riscv\" ]; then\n\t\tOBJDUMPFLAGS=\"-M no-aliases --section=.text -D\"\n\t\t${CROSS_COMPILE}strip $t.o\n\tfi\n\n\tif [ $pc_sub -ne 0 ]; then\n\t\tif [ $PC ]; then\n\t\t\tadj_vma=$(( $PC - $pc_sub ))\n\t\t\tOBJDUMPFLAGS=\"$OBJDUMPFLAGS --adjust-vma=$adj_vma\"\n\t\tfi\n\tfi\n\n\t${CROSS_COMPILE}objdump $OBJDUMPFLAGS -S $t.o | \\\n\t\tgrep -v \"/tmp\\|Disassembly\\|\\.text\\|^$\" > $t.dis 2>&1\n}\n\n# Match the maximum number of opcode bytes from @op_bytes contained within\n# @opline\n#\n# Params:\n# @op_bytes: The string of bytes from the Code: line\n# @opline: The disassembled line coming from objdump\n#\n# Returns:\n# The max number of opcode bytes from the beginning of @op_bytes which match\n# the opcode bytes in the objdump line.\nget_substr_opcode_bytes_num()\n{\n\tlocal op_bytes=$1\n\tlocal opline=$2\n\n\tlocal retval=0\n\tsubstr=\"\"\n\n\tfor opc in $op_bytes;\n\tdo\n\t\tsubstr+=\"$opc\"\n\n\t\topcode=\"$substr\"\n\t\tif [ \"$ARCH\" = \"riscv\" ]; then\n\t\t\topcode=$(echo $opcode | tr ' ' '\\n' | tac | tr -d '\\n')\n\t\tfi\n\n\t\t# return if opcode bytes do not match @opline anymore\n\t\tif ! echo $opline | grep -q \"$opcode\";\n\t\tthen\n\t\t\tbreak\n\t\tfi\n\n\t\t# add trailing space\n\t\tsubstr+=\" \"\n\t\tretval=$((retval+1))\n\tdone\n\n\treturn $retval\n}\n\n# Return the line number in objdump output to where the IP marker in the Code:\n# line points to\n#\n# Params:\n# @all_code: code in bytes without the marker\n# @dis_file: disassembled file\n# @ip_byte: The byte to which the IP points to\nget_faultlinenum()\n{\n\tlocal all_code=\"$1\"\n\tlocal dis_file=\"$2\"\n\n\t# num bytes including IP byte\n\tlocal num_bytes_ip=$(( $3 + 1 * $width ))\n\n\t# Add the two header lines (we're counting from 1).\n\tlocal retval=3\n\n\t# remove marker\n\tall_code=$(echo $all_code | sed -e 's/[<>()]//g')\n\n\twhile read line\n\tdo\n\t\tget_substr_opcode_bytes_num \"$all_code\" \"$line\"\n\t\tate_opcodes=$?\n\n\t\tif ! (( $ate_opcodes )); then\n\t\t\tcontinue\n\t\tfi\n\n\t\tnum_bytes_ip=$((num_bytes_ip - ($ate_opcodes * $width) ))\n\t\tif (( $num_bytes_ip <= 0 )); then\n\t\t\tbreak\n\t\tfi\n\n\t\t# Delete matched opcode bytes from all_code. For that, compute\n\t\t# how many chars those opcodes are represented by and include\n\t\t# trailing space.\n\t\t#\n\t\t# a byte is 2 chars, ate_opcodes is also the number of trailing\n\t\t# spaces\n\t\tdel_chars=$(( ($ate_opcodes * $width * 2) + $ate_opcodes ))\n\n\t\tall_code=$(echo $all_code | sed -e \"s!^.\\{$del_chars\\}!!\")\n\n\t\tlet \"retval+=1\"\n\n\tdone < $dis_file\n\n\treturn $retval\n}\n\nmarker=`expr index \"$code\" \"\\<\"`\nif [ $marker -eq 0 ]; then\n\tmarker=`expr index \"$code\" \"\\(\"`\nfi\n\ntouch $T.oo\nif [ $marker -ne 0 ]; then\n\t# How many bytes to subtract from the program counter\n\t# in order to get to the beginning virtual address of the\n\t# Code:\n\tpc_sub=$(( (($marker - 1) / (2 * $width + 1)) * $width ))\n\techo All code >> $T.oo\n\techo ======== >> $T.oo\n\tbeforemark=`echo \"$code\"`\n\techo -n \"\t.$type 0x\" > $T.s\n\n\techo $beforemark | sed -e 's/ /,0x/g; s/[<>()]//g' >> $T.s\n\n\tdisas $T $pc_sub\n\n\tcat $T.dis >> $T.oo\n\n\tget_faultlinenum \"$code\" \"$T.dis\" $pc_sub\n\tfaultlinenum=$?\n\n\t# and fix code at-and-after marker\n\tcode=`echo \"$code\" | cut -c$((${marker} + 1))-`\n\n\trm -f $T.o $T.s $T.dis\nfi\n\necho Code starting with the faulting instruction  > $T.aa\necho =========================================== >> $T.aa\ncode=`echo $code | sed -e 's/\\r//;s/ [<(]/ /;s/[>)] / /;s/ /,0x/g; s/[>)]$//'`\necho -n \"\t.$type 0x\" > $T.s\necho $code >> $T.s\ndisas $T 0\ncat $T.dis >> $T.aa\n\ncat $T.oo | sed -e \"${faultlinenum}s/^\\([^:]*:\\)\\(.*\\)/\\1\\*\\2\\t\\t<-- trapping instruction/\"\necho\ncat $T.aa\ncleanup\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}