{
  "module_name": "headerdep.pl",
  "hash_id": "863be9b72ff8551815ce643a243660a91703ac05b4dfbac59045b9a76923d2cc",
  "original_prompt": "Ingested from linux-6.6.14/scripts/headerdep.pl",
  "human_readable_source": "#! /usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# Detect cycles in the header file dependency graph\n# Vegard Nossum <vegardno@ifi.uio.no>\n#\n\nuse strict;\nuse warnings;\n\nuse Getopt::Long;\n\nmy $opt_all;\nmy @opt_include;\nmy $opt_graph;\n\n&Getopt::Long::Configure(qw(bundling pass_through));\n&GetOptions(\n\thelp\t=> \\&help,\n\tversion\t=> \\&version,\n\n\tall\t=> \\$opt_all,\n\t\"I=s\"\t=> \\@opt_include,\n\tgraph\t=> \\$opt_graph,\n);\n\npush @opt_include, 'include';\nmy %deps = ();\nmy %linenos = ();\n\nmy @headers = grep { strip($_) } @ARGV;\n\nparse_all(@headers);\n\nif($opt_graph) {\n\tgraph();\n} else {\n\tdetect_cycles(@headers);\n}\n\n\nsub help {\n\tprint \"Usage: $0 [options] file...\\n\";\n\tprint \"\\n\";\n\tprint \"Options:\\n\";\n\tprint \"  --all\\n\";\n\tprint \"  --graph\\n\";\n\tprint \"\\n\";\n\tprint \"  -I includedir\\n\";\n\tprint \"\\n\";\n\tprint \"To make nice graphs, try:\\n\";\n\tprint \"  $0 --graph include/linux/kernel.h | dot -Tpng -o graph.png\\n\";\n\texit;\n}\n\nsub version {\n\tprint \"headerdep version 2\\n\";\n\texit;\n}\n\n# Get a file name that is relative to our include paths\nsub strip {\n\tmy $filename = shift;\n\n\tfor my $i (@opt_include) {\n\t\tmy $stripped = $filename;\n\t\t$stripped =~ s/^$i\\///;\n\n\t\treturn $stripped if $stripped ne $filename;\n\t}\n\n\treturn $filename;\n}\n\n# Search for the file name in the list of include paths\nsub search {\n\tmy $filename = shift;\n\treturn $filename if -f $filename;\n\n\tfor my $i (@opt_include) {\n\t\tmy $path = \"$i/$filename\";\n\t\treturn $path if -f $path;\n\t}\n\treturn;\n}\n\nsub parse_all {\n\t# Parse all the headers.\n\tmy @queue = @_;\n\twhile(@queue) {\n\t\tmy $header = pop @queue;\n\t\tnext if exists $deps{$header};\n\n\t\t$deps{$header} = [] unless exists $deps{$header};\n\n\t\tmy $path = search($header);\n\t\tnext unless $path;\n\n\t\topen(my $file, '<', $path) or die($!);\n\t\tchomp(my @lines = <$file>);\n\t\tclose($file);\n\n\t\tfor my $i (0 .. $#lines) {\n\t\t\tmy $line = $lines[$i];\n\t\t\tif(my($dep) = ($line =~ m/^#\\s*include\\s*<(.*?)>/)) {\n\t\t\t\tpush @queue, $dep;\n\t\t\t\tpush @{$deps{$header}}, [$i + 1, $dep];\n\t\t\t}\n\t\t}\n\t}\n}\n\nsub print_cycle {\n\t# $cycle[n] includes $cycle[n + 1];\n\t# $cycle[-1] will be the culprit\n\tmy $cycle = shift;\n\n\t# Adjust the line numbers\n\tfor my $i (0 .. $#$cycle - 1) {\n\t\t$cycle->[$i]->[0] = $cycle->[$i + 1]->[0];\n\t}\n\t$cycle->[-1]->[0] = 0;\n\n\tmy $first = shift @$cycle;\n\tmy $last = pop @$cycle;\n\n\tmy $msg = \"In file included\";\n\tprintf \"%s from %s,\\n\", $msg, $last->[1] if defined $last;\n\n\tfor my $header (reverse @$cycle) {\n\t\tprintf \"%s from %s:%d%s\\n\",\n\t\t\t\" \" x length $msg,\n\t\t\t$header->[1], $header->[0],\n\t\t\t$header->[1] eq $last->[1] ? ' <-- here' : '';\n\t}\n\n\tprintf \"%s:%d: warning: recursive header inclusion\\n\",\n\t\t$first->[1], $first->[0];\n}\n\n# Find and print the smallest cycle starting in the specified node.\nsub detect_cycles {\n\tmy @queue = map { [[0, $_]] } @_;\n\twhile(@queue) {\n\t\tmy $top = pop @queue;\n\t\tmy $name = $top->[-1]->[1];\n\n\t\tfor my $dep (@{$deps{$name}}) {\n\t\t\tmy $chain = [@$top, [$dep->[0], $dep->[1]]];\n\n\t\t\t# If the dep already exists in the chain, we have a\n\t\t\t# cycle...\n\t\t\tif(grep { $_->[1] eq $dep->[1] } @$top) {\n\t\t\t\tprint_cycle($chain);\n\t\t\t\tnext if $opt_all;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpush @queue, $chain;\n\t\t}\n\t}\n}\n\nsub mangle {\n\t$_ = shift;\n\ts/\\//__/g;\n\ts/\\./_/g;\n\ts/-/_/g;\n\t$_;\n}\n\n# Output dependency graph in GraphViz language.\nsub graph {\n\tprint \"digraph {\\n\";\n\n\tprint \"\\t/* vertices */\\n\";\n\tfor my $header (keys %deps) {\n\t\tprintf \"\\t%s [label=\\\"%s\\\"];\\n\",\n\t\t\tmangle($header), $header;\n\t}\n\n\tprint \"\\n\";\n\n\tprint \"\\t/* edges */\\n\";\n\tfor my $header (keys %deps) {\n\t\tfor my $dep (@{$deps{$header}}) {\n\t\t\tprintf \"\\t%s -> %s;\\n\",\n\t\t\t\tmangle($header), mangle($dep->[1]);\n\t\t}\n\t}\n\n\tprint \"}\\n\";\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}