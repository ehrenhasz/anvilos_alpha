{
  "module_name": "bpf_doc.py",
  "hash_id": "c42604eca6c4c8ba45a96af63b47a459e625e7313eca1a236f74feeca01bc72f",
  "original_prompt": "Ingested from linux-6.6.14/scripts/bpf_doc.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Copyright (C) 2018-2019 Netronome Systems, Inc.\n# Copyright (C) 2021 Isovalent, Inc.\n\n# In case user attempts to run with Python 2.\nfrom __future__ import print_function\n\nimport argparse\nimport re\nimport sys, os\nimport subprocess\n\nhelpersDocStart = 'Start of BPF helper function descriptions:'\n\nclass NoHelperFound(BaseException):\n    pass\n\nclass NoSyscallCommandFound(BaseException):\n    pass\n\nclass ParsingError(BaseException):\n    def __init__(self, line='<line not provided>', reader=None):\n        if reader:\n            BaseException.__init__(self,\n                                   'Error at file offset %d, parsing line: %s' %\n                                   (reader.tell(), line))\n        else:\n            BaseException.__init__(self, 'Error parsing line: %s' % line)\n\n\nclass APIElement(object):\n    \"\"\"\n    An object representing the description of an aspect of the eBPF API.\n    @proto: prototype of the API symbol\n    @desc: textual description of the symbol\n    @ret: (optional) description of any associated return value\n    \"\"\"\n    def __init__(self, proto='', desc='', ret=''):\n        self.proto = proto\n        self.desc = desc\n        self.ret = ret\n\n\nclass Helper(APIElement):\n    \"\"\"\n    An object representing the description of an eBPF helper function.\n    @proto: function prototype of the helper function\n    @desc: textual description of the helper function\n    @ret: description of the return value of the helper function\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.enum_val = None\n\n    def proto_break_down(self):\n        \"\"\"\n        Break down helper function protocol into smaller chunks: return type,\n        name, distincts arguments.\n        \"\"\"\n        arg_re = re.compile(r'((\\w+ )*?(\\w+|...))( (\\**)(\\w+))?$')\n        res = {}\n        proto_re = re.compile(r'(.+) (\\**)(\\w+)\\(((([^,]+)(, )?){1,5})\\)$')\n\n        capture = proto_re.match(self.proto)\n        res['ret_type'] = capture.group(1)\n        res['ret_star'] = capture.group(2)\n        res['name']     = capture.group(3)\n        res['args'] = []\n\n        args    = capture.group(4).split(', ')\n        for a in args:\n            capture = arg_re.match(a)\n            res['args'].append({\n                'type' : capture.group(1),\n                'star' : capture.group(5),\n                'name' : capture.group(6)\n            })\n\n        return res\n\n\nclass HeaderParser(object):\n    \"\"\"\n    An object used to parse a file in order to extract the documentation of a\n    list of eBPF helper functions. All the helpers that can be retrieved are\n    stored as Helper object, in the self.helpers() array.\n    @filename: name of file to parse, usually include/uapi/linux/bpf.h in the\n               kernel tree\n    \"\"\"\n    def __init__(self, filename):\n        self.reader = open(filename, 'r')\n        self.line = ''\n        self.helpers = []\n        self.commands = []\n        self.desc_unique_helpers = set()\n        self.define_unique_helpers = []\n        self.helper_enum_vals = {}\n        self.helper_enum_pos = {}\n        self.desc_syscalls = []\n        self.enum_syscalls = []\n\n    def parse_element(self):\n        proto    = self.parse_symbol()\n        desc     = self.parse_desc(proto)\n        ret      = self.parse_ret(proto)\n        return APIElement(proto=proto, desc=desc, ret=ret)\n\n    def parse_helper(self):\n        proto    = self.parse_proto()\n        desc     = self.parse_desc(proto)\n        ret      = self.parse_ret(proto)\n        return Helper(proto=proto, desc=desc, ret=ret)\n\n    def parse_symbol(self):\n        p = re.compile(r' \\* ?(BPF\\w+)$')\n        capture = p.match(self.line)\n        if not capture:\n            raise NoSyscallCommandFound\n        end_re = re.compile(r' \\* ?NOTES$')\n        end = end_re.match(self.line)\n        if end:\n            raise NoSyscallCommandFound\n        self.line = self.reader.readline()\n        return capture.group(1)\n\n    def parse_proto(self):\n        # Argument can be of shape:\n        #   - \"void\"\n        #   - \"type  name\"\n        #   - \"type *name\"\n        #   - Same as above, with \"const\" and/or \"struct\" in front of type\n        #   - \"...\" (undefined number of arguments, for bpf_trace_printk())\n        # There is at least one term (\"void\"), and at most five arguments.\n        p = re.compile(r' \\* ?((.+) \\**\\w+\\((((const )?(struct )?(\\w+|\\.\\.\\.)( \\**\\w+)?)(, )?){1,5}\\))$')\n        capture = p.match(self.line)\n        if not capture:\n            raise NoHelperFound\n        self.line = self.reader.readline()\n        return capture.group(1)\n\n    def parse_desc(self, proto):\n        p = re.compile(r' \\* ?(?:\\t| {5,8})Description$')\n        capture = p.match(self.line)\n        if not capture:\n            raise Exception(\"No description section found for \" + proto)\n        # Description can be several lines, some of them possibly empty, and it\n        # stops when another subsection title is met.\n        desc = ''\n        desc_present = False\n        while True:\n            self.line = self.reader.readline()\n            if self.line == ' *\\n':\n                desc += '\\n'\n            else:\n                p = re.compile(r' \\* ?(?:\\t| {5,8})(?:\\t| {8})(.*)')\n                capture = p.match(self.line)\n                if capture:\n                    desc_present = True\n                    desc += capture.group(1) + '\\n'\n                else:\n                    break\n\n        if not desc_present:\n            raise Exception(\"No description found for \" + proto)\n        return desc\n\n    def parse_ret(self, proto):\n        p = re.compile(r' \\* ?(?:\\t| {5,8})Return$')\n        capture = p.match(self.line)\n        if not capture:\n            raise Exception(\"No return section found for \" + proto)\n        # Return value description can be several lines, some of them possibly\n        # empty, and it stops when another subsection title is met.\n        ret = ''\n        ret_present = False\n        while True:\n            self.line = self.reader.readline()\n            if self.line == ' *\\n':\n                ret += '\\n'\n            else:\n                p = re.compile(r' \\* ?(?:\\t| {5,8})(?:\\t| {8})(.*)')\n                capture = p.match(self.line)\n                if capture:\n                    ret_present = True\n                    ret += capture.group(1) + '\\n'\n                else:\n                    break\n\n        if not ret_present:\n            raise Exception(\"No return found for \" + proto)\n        return ret\n\n    def seek_to(self, target, help_message, discard_lines = 1):\n        self.reader.seek(0)\n        offset = self.reader.read().find(target)\n        if offset == -1:\n            raise Exception(help_message)\n        self.reader.seek(offset)\n        self.reader.readline()\n        for _ in range(discard_lines):\n            self.reader.readline()\n        self.line = self.reader.readline()\n\n    def parse_desc_syscall(self):\n        self.seek_to('* DOC: eBPF Syscall Commands',\n                     'Could not find start of eBPF syscall descriptions list')\n        while True:\n            try:\n                command = self.parse_element()\n                self.commands.append(command)\n                self.desc_syscalls.append(command.proto)\n\n            except NoSyscallCommandFound:\n                break\n\n    def parse_enum_syscall(self):\n        self.seek_to('enum bpf_cmd {',\n                     'Could not find start of bpf_cmd enum', 0)\n        # Searches for either one or more BPF\\w+ enums\n        bpf_p = re.compile(r'\\s*(BPF\\w+)+')\n        # Searches for an enum entry assigned to another entry,\n        # for e.g. BPF_PROG_RUN = BPF_PROG_TEST_RUN, which is\n        # not documented hence should be skipped in check to\n        # determine if the right number of syscalls are documented\n        assign_p = re.compile(r'\\s*(BPF\\w+)\\s*=\\s*(BPF\\w+)')\n        bpf_cmd_str = ''\n        while True:\n            capture = assign_p.match(self.line)\n            if capture:\n                # Skip line if an enum entry is assigned to another entry\n                self.line = self.reader.readline()\n                continue\n            capture = bpf_p.match(self.line)\n            if capture:\n                bpf_cmd_str += self.line\n            else:\n                break\n            self.line = self.reader.readline()\n        # Find the number of occurences of BPF\\w+\n        self.enum_syscalls = re.findall(r'(BPF\\w+)+', bpf_cmd_str)\n\n    def parse_desc_helpers(self):\n        self.seek_to(helpersDocStart,\n                     'Could not find start of eBPF helper descriptions list')\n        while True:\n            try:\n                helper = self.parse_helper()\n                self.helpers.append(helper)\n                proto = helper.proto_break_down()\n                self.desc_unique_helpers.add(proto['name'])\n            except NoHelperFound:\n                break\n\n    def parse_define_helpers(self):\n        # Parse FN(...) in #define ___BPF_FUNC_MAPPER to compare later with the\n        # number of unique function names present in description and use the\n        # correct enumeration value.\n        # Note: seek_to(..) discards the first line below the target search text,\n        # resulting in FN(unspec, 0, ##ctx) being skipped and not added to\n        # self.define_unique_helpers.\n        self.seek_to('#define ___BPF_FUNC_MAPPER(FN, ctx...)',\n                     'Could not find start of eBPF helper definition list')\n        # Searches for one FN(\\w+) define or a backslash for newline\n        p = re.compile(r'\\s*FN\\((\\w+), (\\d+), ##ctx\\)|\\\\\\\\')\n        fn_defines_str = ''\n        i = 0\n        while True:\n            capture = p.match(self.line)\n            if capture:\n                fn_defines_str += self.line\n                helper_name = capture.expand(r'bpf_\\1')\n                self.helper_enum_vals[helper_name] = int(capture.group(2))\n                self.helper_enum_pos[helper_name] = i\n                i += 1\n            else:\n                break\n            self.line = self.reader.readline()\n        # Find the number of occurences of FN(\\w+)\n        self.define_unique_helpers = re.findall(r'FN\\(\\w+, \\d+, ##ctx\\)', fn_defines_str)\n\n    def validate_helpers(self):\n        last_helper = ''\n        seen_helpers = set()\n        seen_enum_vals = set()\n        i = 0\n        for helper in self.helpers:\n            proto = helper.proto_break_down()\n            name = proto['name']\n            try:\n                enum_val = self.helper_enum_vals[name]\n                enum_pos = self.helper_enum_pos[name]\n            except KeyError:\n                raise Exception(\"Helper %s is missing from enum bpf_func_id\" % name)\n\n            if name in seen_helpers:\n                if last_helper != name:\n                    raise Exception(\"Helper %s has multiple descriptions which are not grouped together\" % name)\n                continue\n\n            # Enforce current practice of having the descriptions ordered\n            # by enum value.\n            if enum_pos != i:\n                raise Exception(\"Helper %s (ID %d) comment order (#%d) must be aligned with its position (#%d) in enum bpf_func_id\" % (name, enum_val, i + 1, enum_pos + 1))\n            if enum_val in seen_enum_vals:\n                raise Exception(\"Helper %s has duplicated value %d\" % (name, enum_val))\n\n            seen_helpers.add(name)\n            last_helper = name\n            seen_enum_vals.add(enum_val)\n\n            helper.enum_val = enum_val\n            i += 1\n\n    def run(self):\n        self.parse_desc_syscall()\n        self.parse_enum_syscall()\n        self.parse_desc_helpers()\n        self.parse_define_helpers()\n        self.validate_helpers()\n        self.reader.close()\n\n###############################################################################\n\nclass Printer(object):\n    \"\"\"\n    A generic class for printers. Printers should be created with an array of\n    Helper objects, and implement a way to print them in the desired fashion.\n    @parser: A HeaderParser with objects to print to standard output\n    \"\"\"\n    def __init__(self, parser):\n        self.parser = parser\n        self.elements = []\n\n    def print_header(self):\n        pass\n\n    def print_footer(self):\n        pass\n\n    def print_one(self, helper):\n        pass\n\n    def print_all(self):\n        self.print_header()\n        for elem in self.elements:\n            self.print_one(elem)\n        self.print_footer()\n\n    def elem_number_check(self, desc_unique_elem, define_unique_elem, type, instance):\n        \"\"\"\n        Checks the number of helpers/syscalls documented within the header file\n        description with those defined as part of enum/macro and raise an\n        Exception if they don't match.\n        \"\"\"\n        nr_desc_unique_elem = len(desc_unique_elem)\n        nr_define_unique_elem = len(define_unique_elem)\n        if nr_desc_unique_elem != nr_define_unique_elem:\n            exception_msg = '''\nThe number of unique %s in description (%d) doesn\\'t match the number of unique %s defined in %s (%d)\n''' % (type, nr_desc_unique_elem, type, instance, nr_define_unique_elem)\n            if nr_desc_unique_elem < nr_define_unique_elem:\n                # Function description is parsed until no helper is found (which can be due to\n                # misformatting). Hence, only print the first missing/misformatted helper/enum.\n                exception_msg += '''\nThe description for %s is not present or formatted correctly.\n''' % (define_unique_elem[nr_desc_unique_elem])\n            raise Exception(exception_msg)\n\nclass PrinterRST(Printer):\n    \"\"\"\n    A generic class for printers that print ReStructured Text. Printers should\n    be created with a HeaderParser object, and implement a way to print API\n    elements in the desired fashion.\n    @parser: A HeaderParser with objects to print to standard output\n    \"\"\"\n    def __init__(self, parser):\n        self.parser = parser\n\n    def print_license(self):\n        license = '''\\\n.. Copyright (C) All BPF authors and contributors from 2014 to present.\n.. See git log include/uapi/linux/bpf.h in kernel tree for details.\n.. \n.. SPDX-License-Identifier: Linux-man-pages-copyleft\n.. \n.. Please do not edit this file. It was generated from the documentation\n.. located in file include/uapi/linux/bpf.h of the Linux kernel sources\n.. (helpers description), and from scripts/bpf_doc.py in the same\n.. repository (header and footer).\n'''\n        print(license)\n\n    def print_elem(self, elem):\n        if (elem.desc):\n            print('\\tDescription')\n            # Do not strip all newline characters: formatted code at the end of\n            # a section must be followed by a blank line.\n            for line in re.sub('\\n$', '', elem.desc, count=1).split('\\n'):\n                print('{}{}'.format('\\t\\t' if line else '', line))\n\n        if (elem.ret):\n            print('\\tReturn')\n            for line in elem.ret.rstrip().split('\\n'):\n                print('{}{}'.format('\\t\\t' if line else '', line))\n\n        print('')\n\n    def get_kernel_version(self):\n        try:\n            version = subprocess.run(['git', 'describe'], cwd=linuxRoot,\n                                     capture_output=True, check=True)\n            version = version.stdout.decode().rstrip()\n        except:\n            try:\n                version = subprocess.run(['make', 'kernelversion'], cwd=linuxRoot,\n                                         capture_output=True, check=True)\n                version = version.stdout.decode().rstrip()\n            except:\n                return 'Linux'\n        return 'Linux {version}'.format(version=version)\n\n    def get_last_doc_update(self, delimiter):\n        try:\n            cmd = ['git', 'log', '-1', '--pretty=format:%cs', '--no-patch',\n                   '-L',\n                   '/{}/,/\\\\*\\\\//:include/uapi/linux/bpf.h'.format(delimiter)]\n            date = subprocess.run(cmd, cwd=linuxRoot,\n                                  capture_output=True, check=True)\n            return date.stdout.decode().rstrip()\n        except:\n            return ''\n\nclass PrinterHelpersRST(PrinterRST):\n    \"\"\"\n    A printer for dumping collected information about helpers as a ReStructured\n    Text page compatible with the rst2man program, which can be used to\n    generate a manual page for the helpers.\n    @parser: A HeaderParser with Helper objects to print to standard output\n    \"\"\"\n    def __init__(self, parser):\n        self.elements = parser.helpers\n        self.elem_number_check(parser.desc_unique_helpers, parser.define_unique_helpers, 'helper', '___BPF_FUNC_MAPPER')\n\n    def print_header(self):\n        header = '''\\\n===========\nBPF-HELPERS\n===========\n-------------------------------------------------------------------------------\nlist of eBPF helper functions\n-------------------------------------------------------------------------------\n\n:Manual section: 7\n:Version: {version}\n{date_field}{date}\n\nDESCRIPTION\n===========\n\nThe extended Berkeley Packet Filter (eBPF) subsystem consists in programs\nwritten in a pseudo-assembly language, then attached to one of the several\nkernel hooks and run in reaction of specific events. This framework differs\nfrom the older, \"classic\" BPF (or \"cBPF\") in several aspects, one of them being\nthe ability to call special functions (or \"helpers\") from within a program.\nThese functions are restricted to a white-list of helpers defined in the\nkernel.\n\nThese helpers are used by eBPF programs to interact with the system, or with\nthe context in which they work. For instance, they can be used to print\ndebugging messages, to get the time since the system was booted, to interact\nwith eBPF maps, or to manipulate network packets. Since there are several eBPF\nprogram types, and that they do not run in the same context, each program type\ncan only call a subset of those helpers.\n\nDue to eBPF conventions, a helper can not have more than five arguments.\n\nInternally, eBPF programs call directly into the compiled helper functions\nwithout requiring any foreign-function interface. As a result, calling helpers\nintroduces no overhead, thus offering excellent performance.\n\nThis document is an attempt to list and document the helpers available to eBPF\ndevelopers. They are sorted by chronological order (the oldest helpers in the\nkernel at the top).\n\nHELPERS\n=======\n'''\n        kernelVersion = self.get_kernel_version()\n        lastUpdate = self.get_last_doc_update(helpersDocStart)\n\n        PrinterRST.print_license(self)\n        print(header.format(version=kernelVersion,\n                            date_field = ':Date: ' if lastUpdate else '',\n                            date=lastUpdate))\n\n    def print_footer(self):\n        footer = '''\nEXAMPLES\n========\n\nExample usage for most of the eBPF helpers listed in this manual page are\navailable within the Linux kernel sources, at the following locations:\n\n* *samples/bpf/*\n* *tools/testing/selftests/bpf/*\n\nLICENSE\n=======\n\neBPF programs can have an associated license, passed along with the bytecode\ninstructions to the kernel when the programs are loaded. The format for that\nstring is identical to the one in use for kernel modules (Dual licenses, such\nas \"Dual BSD/GPL\", may be used). Some helper functions are only accessible to\nprograms that are compatible with the GNU Privacy License (GPL).\n\nIn order to use such helpers, the eBPF program must be loaded with the correct\nlicense string passed (via **attr**) to the **bpf**\\\\ () system call, and this\ngenerally translates into the C source code of the program containing a line\nsimilar to the following:\n\n::\n\n\tchar ____license[] __attribute__((section(\"license\"), used)) = \"GPL\";\n\nIMPLEMENTATION\n==============\n\nThis manual page is an effort to document the existing eBPF helper functions.\nBut as of this writing, the BPF sub-system is under heavy development. New eBPF\nprogram or map types are added, along with new helper functions. Some helpers\nare occasionally made available for additional program types. So in spite of\nthe efforts of the community, this page might not be up-to-date. If you want to\ncheck by yourself what helper functions exist in your kernel, or what types of\nprograms they can support, here are some files among the kernel tree that you\nmay be interested in:\n\n* *include/uapi/linux/bpf.h* is the main BPF header. It contains the full list\n  of all helper functions, as well as many other BPF definitions including most\n  of the flags, structs or constants used by the helpers.\n* *net/core/filter.c* contains the definition of most network-related helper\n  functions, and the list of program types from which they can be used.\n* *kernel/trace/bpf_trace.c* is the equivalent for most tracing program-related\n  helpers.\n* *kernel/bpf/verifier.c* contains the functions used to check that valid types\n  of eBPF maps are used with a given helper function.\n* *kernel/bpf/* directory contains other files in which additional helpers are\n  defined (for cgroups, sockmaps, etc.).\n* The bpftool utility can be used to probe the availability of helper functions\n  on the system (as well as supported program and map types, and a number of\n  other parameters). To do so, run **bpftool feature probe** (see\n  **bpftool-feature**\\\\ (8) for details). Add the **unprivileged** keyword to\n  list features available to unprivileged users.\n\nCompatibility between helper functions and program types can generally be found\nin the files where helper functions are defined. Look for the **struct\nbpf_func_proto** objects and for functions returning them: these functions\ncontain a list of helpers that a given program type can call. Note that the\n**default:** label of the **switch ... case** used to filter helpers can call\nother functions, themselves allowing access to additional helpers. The\nrequirement for GPL license is also in those **struct bpf_func_proto**.\n\nCompatibility between helper functions and map types can be found in the\n**check_map_func_compatibility**\\\\ () function in file *kernel/bpf/verifier.c*.\n\nHelper functions that invalidate the checks on **data** and **data_end**\npointers for network processing are listed in function\n**bpf_helper_changes_pkt_data**\\\\ () in file *net/core/filter.c*.\n\nSEE ALSO\n========\n\n**bpf**\\\\ (2),\n**bpftool**\\\\ (8),\n**cgroups**\\\\ (7),\n**ip**\\\\ (8),\n**perf_event_open**\\\\ (2),\n**sendmsg**\\\\ (2),\n**socket**\\\\ (7),\n**tc-bpf**\\\\ (8)'''\n        print(footer)\n\n    def print_proto(self, helper):\n        \"\"\"\n        Format function protocol with bold and italics markers. This makes RST\n        file less readable, but gives nice results in the manual page.\n        \"\"\"\n        proto = helper.proto_break_down()\n\n        print('**%s %s%s(' % (proto['ret_type'],\n                              proto['ret_star'].replace('*', '\\\\*'),\n                              proto['name']),\n              end='')\n\n        comma = ''\n        for a in proto['args']:\n            one_arg = '{}{}'.format(comma, a['type'])\n            if a['name']:\n                if a['star']:\n                    one_arg += ' {}**\\\\ '.format(a['star'].replace('*', '\\\\*'))\n                else:\n                    one_arg += '** '\n                one_arg += '*{}*\\\\ **'.format(a['name'])\n            comma = ', '\n            print(one_arg, end='')\n\n        print(')**')\n\n    def print_one(self, helper):\n        self.print_proto(helper)\n        self.print_elem(helper)\n\n\nclass PrinterSyscallRST(PrinterRST):\n    \"\"\"\n    A printer for dumping collected information about the syscall API as a\n    ReStructured Text page compatible with the rst2man program, which can be\n    used to generate a manual page for the syscall.\n    @parser: A HeaderParser with APIElement objects to print to standard\n             output\n    \"\"\"\n    def __init__(self, parser):\n        self.elements = parser.commands\n        self.elem_number_check(parser.desc_syscalls, parser.enum_syscalls, 'syscall', 'bpf_cmd')\n\n    def print_header(self):\n        header = '''\\\n===\nbpf\n===\n-------------------------------------------------------------------------------\nPerform a command on an extended BPF object\n-------------------------------------------------------------------------------\n\n:Manual section: 2\n\nCOMMANDS\n========\n'''\n        PrinterRST.print_license(self)\n        print(header)\n\n    def print_one(self, command):\n        print('**%s**' % (command.proto))\n        self.print_elem(command)\n\n\nclass PrinterHelpers(Printer):\n    \"\"\"\n    A printer for dumping collected information about helpers as C header to\n    be included from BPF program.\n    @parser: A HeaderParser with Helper objects to print to standard output\n    \"\"\"\n    def __init__(self, parser):\n        self.elements = parser.helpers\n        self.elem_number_check(parser.desc_unique_helpers, parser.define_unique_helpers, 'helper', '___BPF_FUNC_MAPPER')\n\n    type_fwds = [\n            'struct bpf_fib_lookup',\n            'struct bpf_sk_lookup',\n            'struct bpf_perf_event_data',\n            'struct bpf_perf_event_value',\n            'struct bpf_pidns_info',\n            'struct bpf_redir_neigh',\n            'struct bpf_sock',\n            'struct bpf_sock_addr',\n            'struct bpf_sock_ops',\n            'struct bpf_sock_tuple',\n            'struct bpf_spin_lock',\n            'struct bpf_sysctl',\n            'struct bpf_tcp_sock',\n            'struct bpf_tunnel_key',\n            'struct bpf_xfrm_state',\n            'struct linux_binprm',\n            'struct pt_regs',\n            'struct sk_reuseport_md',\n            'struct sockaddr',\n            'struct tcphdr',\n            'struct seq_file',\n            'struct tcp6_sock',\n            'struct tcp_sock',\n            'struct tcp_timewait_sock',\n            'struct tcp_request_sock',\n            'struct udp6_sock',\n            'struct unix_sock',\n            'struct task_struct',\n            'struct cgroup',\n\n            'struct __sk_buff',\n            'struct sk_msg_md',\n            'struct xdp_md',\n            'struct path',\n            'struct btf_ptr',\n            'struct inode',\n            'struct socket',\n            'struct file',\n            'struct bpf_timer',\n            'struct mptcp_sock',\n            'struct bpf_dynptr',\n            'struct iphdr',\n            'struct ipv6hdr',\n    ]\n    known_types = {\n            '...',\n            'void',\n            'const void',\n            'char',\n            'const char',\n            'int',\n            'long',\n            'unsigned long',\n\n            '__be16',\n            '__be32',\n            '__wsum',\n\n            'struct bpf_fib_lookup',\n            'struct bpf_perf_event_data',\n            'struct bpf_perf_event_value',\n            'struct bpf_pidns_info',\n            'struct bpf_redir_neigh',\n            'struct bpf_sk_lookup',\n            'struct bpf_sock',\n            'struct bpf_sock_addr',\n            'struct bpf_sock_ops',\n            'struct bpf_sock_tuple',\n            'struct bpf_spin_lock',\n            'struct bpf_sysctl',\n            'struct bpf_tcp_sock',\n            'struct bpf_tunnel_key',\n            'struct bpf_xfrm_state',\n            'struct linux_binprm',\n            'struct pt_regs',\n            'struct sk_reuseport_md',\n            'struct sockaddr',\n            'struct tcphdr',\n            'struct seq_file',\n            'struct tcp6_sock',\n            'struct tcp_sock',\n            'struct tcp_timewait_sock',\n            'struct tcp_request_sock',\n            'struct udp6_sock',\n            'struct unix_sock',\n            'struct task_struct',\n            'struct cgroup',\n            'struct path',\n            'struct btf_ptr',\n            'struct inode',\n            'struct socket',\n            'struct file',\n            'struct bpf_timer',\n            'struct mptcp_sock',\n            'struct bpf_dynptr',\n            'const struct bpf_dynptr',\n            'struct iphdr',\n            'struct ipv6hdr',\n    }\n    mapped_types = {\n            'u8': '__u8',\n            'u16': '__u16',\n            'u32': '__u32',\n            'u64': '__u64',\n            's8': '__s8',\n            's16': '__s16',\n            's32': '__s32',\n            's64': '__s64',\n            'size_t': 'unsigned long',\n            'struct bpf_map': 'void',\n            'struct sk_buff': 'struct __sk_buff',\n            'const struct sk_buff': 'const struct __sk_buff',\n            'struct sk_msg_buff': 'struct sk_msg_md',\n            'struct xdp_buff': 'struct xdp_md',\n    }\n    # Helpers overloaded for different context types.\n    overloaded_helpers = [\n        'bpf_get_socket_cookie',\n        'bpf_sk_assign',\n    ]\n\n    def print_header(self):\n        header = '''\\\n/* This is auto-generated file. See bpf_doc.py for details. */\n\n/* Forward declarations of BPF structs */'''\n\n        print(header)\n        for fwd in self.type_fwds:\n            print('%s;' % fwd)\n        print('')\n\n    def print_footer(self):\n        footer = ''\n        print(footer)\n\n    def map_type(self, t):\n        if t in self.known_types:\n            return t\n        if t in self.mapped_types:\n            return self.mapped_types[t]\n        print(\"Unrecognized type '%s', please add it to known types!\" % t,\n              file=sys.stderr)\n        sys.exit(1)\n\n    seen_helpers = set()\n\n    def print_one(self, helper):\n        proto = helper.proto_break_down()\n\n        if proto['name'] in self.seen_helpers:\n            return\n        self.seen_helpers.add(proto['name'])\n\n        print('/*')\n        print(\" * %s\" % proto['name'])\n        print(\" *\")\n        if (helper.desc):\n            # Do not strip all newline characters: formatted code at the end of\n            # a section must be followed by a blank line.\n            for line in re.sub('\\n$', '', helper.desc, count=1).split('\\n'):\n                print(' *{}{}'.format(' \\t' if line else '', line))\n\n        if (helper.ret):\n            print(' *')\n            print(' * Returns')\n            for line in helper.ret.rstrip().split('\\n'):\n                print(' *{}{}'.format(' \\t' if line else '', line))\n\n        print(' */')\n        print('static %s %s(*%s)(' % (self.map_type(proto['ret_type']),\n                                      proto['ret_star'], proto['name']), end='')\n        comma = ''\n        for i, a in enumerate(proto['args']):\n            t = a['type']\n            n = a['name']\n            if proto['name'] in self.overloaded_helpers and i == 0:\n                    t = 'void'\n                    n = 'ctx'\n            one_arg = '{}{}'.format(comma, self.map_type(t))\n            if n:\n                if a['star']:\n                    one_arg += ' {}'.format(a['star'])\n                else:\n                    one_arg += ' '\n                one_arg += '{}'.format(n)\n            comma = ', '\n            print(one_arg, end='')\n\n        print(') = (void *) %d;' % helper.enum_val)\n        print('')\n\n###############################################################################\n\n# If script is launched from scripts/ from kernel tree and can access\n# ../include/uapi/linux/bpf.h, use it as a default name for the file to parse,\n# otherwise the --filename argument will be required from the command line.\nscript = os.path.abspath(sys.argv[0])\nlinuxRoot = os.path.dirname(os.path.dirname(script))\nbpfh = os.path.join(linuxRoot, 'include/uapi/linux/bpf.h')\n\nprinters = {\n        'helpers': PrinterHelpersRST,\n        'syscall': PrinterSyscallRST,\n}\n\nargParser = argparse.ArgumentParser(description=\"\"\"\nParse eBPF header file and generate documentation for the eBPF API.\nThe RST-formatted output produced can be turned into a manual page with the\nrst2man utility.\n\"\"\")\nargParser.add_argument('--header', action='store_true',\n                       help='generate C header file')\nif (os.path.isfile(bpfh)):\n    argParser.add_argument('--filename', help='path to include/uapi/linux/bpf.h',\n                           default=bpfh)\nelse:\n    argParser.add_argument('--filename', help='path to include/uapi/linux/bpf.h')\nargParser.add_argument('target', nargs='?', default='helpers',\n                       choices=printers.keys(), help='eBPF API target')\nargs = argParser.parse_args()\n\n# Parse file.\nheaderParser = HeaderParser(args.filename)\nheaderParser.run()\n\n# Print formatted output to standard output.\nif args.header:\n    if args.target != 'helpers':\n        raise NotImplementedError('Only helpers header generation is supported')\n    printer = PrinterHelpers(headerParser)\nelse:\n    printer = printers[args.target](headerParser)\nprinter.print_all()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}