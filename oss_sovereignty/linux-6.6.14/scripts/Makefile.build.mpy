{
  "module_name": "Makefile.build",
  "hash_id": "bbe901ed249056a20f0fae8ad43b2758223322a4d5ffb43f1ab331fe4c1e235a",
  "original_prompt": "Ingested from linux-6.6.14/scripts/Makefile.build",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n# ==========================================================================\n# Building\n# ==========================================================================\n\nsrc := $(obj)\n\nPHONY := $(obj)/\n$(obj)/:\n\n# Init all relevant variables used in kbuild files so\n# 1) they have correct type\n# 2) they do not inherit any value from the environment\nobj-y :=\nobj-m :=\nlib-y :=\nlib-m :=\nalways-y :=\nalways-m :=\ntargets :=\nsubdir-y :=\nsubdir-m :=\nEXTRA_AFLAGS   :=\nEXTRA_CFLAGS   :=\nEXTRA_CPPFLAGS :=\nEXTRA_LDFLAGS  :=\nasflags-y  :=\nccflags-y  :=\nrustflags-y :=\ncppflags-y :=\nldflags-y  :=\n\nsubdir-asflags-y :=\nsubdir-ccflags-y :=\n\n# Read auto.conf if it exists, otherwise ignore\n-include include/config/auto.conf\n\ninclude $(srctree)/scripts/Kbuild.include\ninclude $(srctree)/scripts/Makefile.compiler\ninclude $(kbuild-file)\ninclude $(srctree)/scripts/Makefile.lib\n\n# Do not include hostprogs rules unless needed.\n# $(sort ...) is used here to remove duplicated words and excessive spaces.\nhostprogs := $(sort $(hostprogs))\nifneq ($(hostprogs),)\ninclude $(srctree)/scripts/Makefile.host\nendif\n\n# Do not include userprogs rules unless needed.\n# $(sort ...) is used here to remove duplicated words and excessive spaces.\nuserprogs := $(sort $(userprogs))\nifneq ($(userprogs),)\ninclude $(srctree)/scripts/Makefile.userprogs\nendif\n\nifndef obj\n$(warning kbuild: Makefile.build is included improperly)\nendif\n\nifeq ($(need-modorder),)\nifneq ($(obj-m),)\n$(warning $(patsubst %.o,'%.ko',$(obj-m)) will not be built even though obj-m is specified.)\n$(warning You cannot use subdir-y/m to visit a module Makefile. Use obj-y/m instead.)\nendif\nendif\n\n# ===========================================================================\n\n# subdir-builtin and subdir-modorder may contain duplications. Use $(sort ...)\nsubdir-builtin := $(sort $(filter %/built-in.a, $(real-obj-y)))\nsubdir-modorder := $(sort $(filter %/modules.order, $(obj-m)))\n\ntargets-for-builtin := $(extra-y)\n\nifneq ($(strip $(lib-y) $(lib-m) $(lib-)),)\ntargets-for-builtin += $(obj)/lib.a\nendif\n\nifdef need-builtin\ntargets-for-builtin += $(obj)/built-in.a\nendif\n\ntargets-for-modules := $(foreach x, o mod, \\\n\t\t\t\t$(patsubst %.o, %.$x, $(filter %.o, $(obj-m))))\n\nifdef need-modorder\ntargets-for-modules += $(obj)/modules.order\nendif\n\ntargets += $(targets-for-builtin) $(targets-for-modules)\n\n# Linus' kernel sanity checking tool\nifeq ($(KBUILD_CHECKSRC),1)\n  quiet_cmd_checksrc       = CHECK   $<\n        cmd_checksrc       = $(CHECK) $(CHECKFLAGS) $(c_flags) $<\nelse ifeq ($(KBUILD_CHECKSRC),2)\n  quiet_cmd_force_checksrc = CHECK   $<\n        cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $<\nendif\n\nifneq ($(KBUILD_EXTRA_WARN),)\n  cmd_checkdoc = $(srctree)/scripts/kernel-doc -none $(KDOCFLAGS) \\\n        $(if $(findstring 2, $(KBUILD_EXTRA_WARN)), -Wall) \\\n        $<\nendif\n\n# Compile C sources (.c)\n# ---------------------------------------------------------------------------\n\nquiet_cmd_cc_s_c = CC $(quiet_modtag)  $@\n      cmd_cc_s_c = $(CC) $(filter-out $(DEBUG_CFLAGS) $(CC_FLAGS_LTO), $(c_flags)) -fverbose-asm -S -o $@ $<\n\n$(obj)/%.s: $(src)/%.c FORCE\n\t$(call if_changed_dep,cc_s_c)\n\nquiet_cmd_cpp_i_c = CPP $(quiet_modtag) $@\ncmd_cpp_i_c       = $(CPP) $(c_flags) -o $@ $<\n\n$(obj)/%.i: $(src)/%.c FORCE\n\t$(call if_changed_dep,cpp_i_c)\n\ngenksyms = scripts/genksyms/genksyms\t\t\\\n\t$(if $(1), -T $(2))\t\t\t\\\n\t$(if $(KBUILD_PRESERVE), -p)\t\t\\\n\t-r $(or $(wildcard $(2:.symtypes=.symref)), /dev/null)\n\n# These mirror gensymtypes_S and co below, keep them in synch.\ncmd_gensymtypes_c = $(CPP) -D__GENKSYMS__ $(c_flags) $< | $(genksyms)\n\nquiet_cmd_cc_symtypes_c = SYM $(quiet_modtag) $@\n      cmd_cc_symtypes_c = $(call cmd_gensymtypes_c,true,$@) >/dev/null\n\n$(obj)/%.symtypes : $(src)/%.c FORCE\n\t$(call cmd,cc_symtypes_c)\n\n# LLVM assembly\n# Generate .ll files from .c\nquiet_cmd_cc_ll_c = CC $(quiet_modtag)  $@\n      cmd_cc_ll_c = $(CC) $(c_flags) -emit-llvm -S -fno-discard-value-names -o $@ $<\n\n$(obj)/%.ll: $(src)/%.c FORCE\n\t$(call if_changed_dep,cc_ll_c)\n\n# C (.c) files\n# The C file is compiled and updated dependency information is generated.\n# (See cmd_cc_o_c + relevant part of rule_cc_o_c)\n\nis-single-obj-m = $(and $(part-of-module),$(filter $@, $(obj-m)),y)\n\n# When a module consists of a single object, there is no reason to keep LLVM IR.\n# Make $(LD) covert LLVM IR to ELF here.\nifdef CONFIG_LTO_CLANG\ncmd_ld_single_m = $(if $(is-single-obj-m), ; $(LD) $(ld_flags) -r -o $(tmp-target) $@; mv $(tmp-target) $@)\nendif\n\nquiet_cmd_cc_o_c = CC $(quiet_modtag)  $@\n      cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $< \\\n\t\t$(cmd_ld_single_m) \\\n\t\t$(cmd_objtool)\n\nifdef CONFIG_MODVERSIONS\n# When module versioning is enabled the following steps are executed:\n# o compile a <file>.o from <file>.c\n# o if <file>.o doesn't contain a __export_symbol_*, i.e. does\n#   not export symbols, it's done.\n# o otherwise, we calculate symbol versions using the good old\n#   genksyms on the preprocessed source and dump them into the .cmd file.\n# o modpost will extract versions from that file and create *.c files that will\n#   be compiled and linked to the kernel and/or modules.\n\ngen_symversions =\t\t\t\t\t\t\t\t\\\n\tif $(NM) $@ 2>/dev/null | grep -q ' __export_symbol_'; then\t\t\\\n\t\t$(call cmd_gensymtypes_$(1),$(KBUILD_SYMTYPES),$(@:.o=.symtypes)) \\\n\t\t\t>> $(dot-target).cmd;\t\t\t\t\t\\\n\tfi\n\ncmd_gen_symversions_c =\t$(call gen_symversions,c)\n\nendif\n\nifdef CONFIG_FTRACE_MCOUNT_USE_RECORDMCOUNT\n# compiler will not generate __mcount_loc use recordmcount or recordmcount.pl\nifdef BUILD_C_RECORDMCOUNT\nifeq (\"$(origin RECORDMCOUNT_WARN)\", \"command line\")\n  RECORDMCOUNT_FLAGS = -w\nendif\n# Due to recursion, we must skip empty.o.\n# The empty.o file is created in the make process in order to determine\n# the target endianness and word size. It is made before all other C\n# files, including recordmcount.\nsub_cmd_record_mcount =\t\t\t\t\t\\\n\tif [ $(@) != \"scripts/mod/empty.o\" ]; then\t\\\n\t\t$(objtree)/scripts/recordmcount $(RECORDMCOUNT_FLAGS) \"$(@)\";\t\\\n\tfi;\nrecordmcount_source := $(srctree)/scripts/recordmcount.c \\\n\t\t    $(srctree)/scripts/recordmcount.h\nelse\nsub_cmd_record_mcount = perl $(srctree)/scripts/recordmcount.pl \"$(ARCH)\" \\\n\t\"$(if $(CONFIG_CPU_BIG_ENDIAN),big,little)\" \\\n\t\"$(if $(CONFIG_64BIT),64,32)\" \\\n\t\"$(OBJDUMP)\" \"$(OBJCOPY)\" \"$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS)\" \\\n\t\"$(LD) $(KBUILD_LDFLAGS)\" \"$(NM)\" \"$(RM)\" \"$(MV)\" \\\n\t\"$(if $(part-of-module),1,0)\" \"$(@)\";\nrecordmcount_source := $(srctree)/scripts/recordmcount.pl\nendif # BUILD_C_RECORDMCOUNT\ncmd_record_mcount = $(if $(findstring $(strip $(CC_FLAGS_FTRACE)),$(_c_flags)),\t\\\n\t$(sub_cmd_record_mcount))\nendif # CONFIG_FTRACE_MCOUNT_USE_RECORDMCOUNT\n\n# 'OBJECT_FILES_NON_STANDARD := y': skip objtool checking for a directory\n# 'OBJECT_FILES_NON_STANDARD_foo.o := 'y': skip objtool checking for a file\n# 'OBJECT_FILES_NON_STANDARD_foo.o := 'n': override directory skip for a file\n\nis-standard-object = $(if $(filter-out y%, $(OBJECT_FILES_NON_STANDARD_$(basetarget).o)$(OBJECT_FILES_NON_STANDARD)n),y)\n\n$(obj)/%.o: objtool-enabled = $(if $(is-standard-object),$(if $(delay-objtool),$(is-single-obj-m),y))\n\nifneq ($(findstring 1, $(KBUILD_EXTRA_WARN)),)\ncmd_warn_shared_object = $(if $(word 2, $(modname-multi)),$(warning $(kbuild-file): $*.o is added to multiple modules: $(modname-multi)))\nendif\n\ndefine rule_cc_o_c\n\t$(call cmd_and_fixdep,cc_o_c)\n\t$(call cmd,checksrc)\n\t$(call cmd,checkdoc)\n\t$(call cmd,gen_objtooldep)\n\t$(call cmd,gen_symversions_c)\n\t$(call cmd,record_mcount)\n\t$(call cmd,warn_shared_object)\nendef\n\ndefine rule_as_o_S\n\t$(call cmd_and_fixdep,as_o_S)\n\t$(call cmd,gen_objtooldep)\n\t$(call cmd,gen_symversions_S)\n\t$(call cmd,warn_shared_object)\nendef\n\n# Built-in and composite module parts\n$(obj)/%.o: $(src)/%.c $(recordmcount_source) FORCE\n\t$(call if_changed_rule,cc_o_c)\n\t$(call cmd,force_checksrc)\n\n# To make this rule robust against \"Argument list too long\" error,\n# ensure to add $(obj)/ prefix by a shell command.\ncmd_mod = printf '%s\\n' $(call real-search, $*.o, .o, -objs -y -m) | \\\n\t$(AWK) '!x[$$0]++ { print(\"$(obj)/\"$$0) }' > $@\n\n$(obj)/%.mod: FORCE\n\t$(call if_changed,mod)\n\nquiet_cmd_cc_lst_c = MKLST   $@\n      cmd_cc_lst_c = $(CC) $(c_flags) -g -c -o $*.o $< && \\\n\t\t     $(CONFIG_SHELL) $(srctree)/scripts/makelst $*.o \\\n\t\t\t\t     System.map $(OBJDUMP) > $@\n\n$(obj)/%.lst: $(src)/%.c FORCE\n\t$(call if_changed_dep,cc_lst_c)\n\n# Compile Rust sources (.rs)\n# ---------------------------------------------------------------------------\n\nrust_allowed_features := new_uninit\n\n# `--out-dir` is required to avoid temporaries being created by `rustc` in the\n# current working directory, which may be not accessible in the out-of-tree\n# modules case.\nrust_common_cmd = \\\n\tRUST_MODFILE=$(modfile) $(RUSTC_OR_CLIPPY) $(rust_flags) \\\n\t-Zallow-features=$(rust_allowed_features) \\\n\t-Zcrate-attr=no_std \\\n\t-Zcrate-attr='feature($(rust_allowed_features))' \\\n\t--extern alloc --extern kernel \\\n\t--crate-type rlib -L $(objtree)/rust/ \\\n\t--crate-name $(basename $(notdir $@)) \\\n\t--out-dir $(dir $@) --emit=dep-info=$(depfile)\n\n# `--emit=obj`, `--emit=asm` and `--emit=llvm-ir` imply a single codegen unit\n# will be used. We explicitly request `-Ccodegen-units=1` in any case, and\n# the compiler shows a warning if it is not 1. However, if we ever stop\n# requesting it explicitly and we start using some other `--emit` that does not\n# imply it (and for which codegen is performed), then we would be out of sync,\n# i.e. the outputs we would get for the different single targets (e.g. `.ll`)\n# would not match each other.\n\nquiet_cmd_rustc_o_rs = $(RUSTC_OR_CLIPPY_QUIET) $(quiet_modtag) $@\n      cmd_rustc_o_rs = $(rust_common_cmd) --emit=obj=$@ $<\n\n$(obj)/%.o: $(src)/%.rs FORCE\n\t$(call if_changed_dep,rustc_o_rs)\n\nquiet_cmd_rustc_rsi_rs = $(RUSTC_OR_CLIPPY_QUIET) $(quiet_modtag) $@\n      cmd_rustc_rsi_rs = \\\n\t$(rust_common_cmd) -Zunpretty=expanded $< >$@; \\\n\tcommand -v $(RUSTFMT) >/dev/null && $(RUSTFMT) $@\n\n$(obj)/%.rsi: $(src)/%.rs FORCE\n\t$(call if_changed_dep,rustc_rsi_rs)\n\nquiet_cmd_rustc_s_rs = $(RUSTC_OR_CLIPPY_QUIET) $(quiet_modtag) $@\n      cmd_rustc_s_rs = $(rust_common_cmd) --emit=asm=$@ $<\n\n$(obj)/%.s: $(src)/%.rs FORCE\n\t$(call if_changed_dep,rustc_s_rs)\n\nquiet_cmd_rustc_ll_rs = $(RUSTC_OR_CLIPPY_QUIET) $(quiet_modtag) $@\n      cmd_rustc_ll_rs = $(rust_common_cmd) --emit=llvm-ir=$@ $<\n\n$(obj)/%.ll: $(src)/%.rs FORCE\n\t$(call if_changed_dep,rustc_ll_rs)\n\n# Compile assembler sources (.S)\n# ---------------------------------------------------------------------------\n\n# .S file exports must have their C prototypes defined in asm/asm-prototypes.h\n# or a file that it includes, in order to get versioned symbols. We build a\n# dummy C file that includes asm-prototypes and the EXPORT_SYMBOL lines from\n# the .S file (with trailing ';'), and run genksyms on that, to extract vers.\n#\n# This is convoluted. The .S file must first be preprocessed to run guards and\n# expand names, then the resulting exports must be constructed into plain\n# EXPORT_SYMBOL(symbol); to build our dummy C file, and that gets preprocessed\n# to make the genksyms input.\n#\n# These mirror gensymtypes_c and co above, keep them in synch.\ncmd_gensymtypes_S =                                                         \\\n   { echo \"\\#include <linux/kernel.h>\" ;                                    \\\n     echo \"\\#include <asm/asm-prototypes.h>\" ;                              \\\n     $(NM) $@ | sed -n 's/.* __export_symbol_\\(.*\\)/EXPORT_SYMBOL(\\1);/p' ; } | \\\n    $(CPP) -D__GENKSYMS__ $(c_flags) -xc - | $(genksyms)\n\nquiet_cmd_cc_symtypes_S = SYM $(quiet_modtag) $@\n      cmd_cc_symtypes_S = $(call cmd_gensymtypes_S,true,$@) >/dev/null\n\n$(obj)/%.symtypes : $(src)/%.S FORCE\n\t$(call cmd,cc_symtypes_S)\n\n\nquiet_cmd_cpp_s_S = CPP $(quiet_modtag) $@\ncmd_cpp_s_S       = $(CPP) $(a_flags) -o $@ $<\n\n$(obj)/%.s: $(src)/%.S FORCE\n\t$(call if_changed_dep,cpp_s_S)\n\nquiet_cmd_as_o_S = AS $(quiet_modtag)  $@\n      cmd_as_o_S = $(CC) $(a_flags) -c -o $@ $< $(cmd_objtool)\n\nifdef CONFIG_ASM_MODVERSIONS\n\n# versioning matches the C process described above, with difference that\n# we parse asm-prototypes.h C header to get function definitions.\n\ncmd_gen_symversions_S = $(call gen_symversions,S)\n\nendif\n\n$(obj)/%.o: $(src)/%.S FORCE\n\t$(call if_changed_rule,as_o_S)\n\ntargets += $(filter-out $(subdir-builtin), $(real-obj-y))\ntargets += $(filter-out $(subdir-modorder), $(real-obj-m))\ntargets += $(real-dtb-y) $(lib-y) $(always-y)\n\n# Linker scripts preprocessor (.lds.S -> .lds)\n# ---------------------------------------------------------------------------\nquiet_cmd_cpp_lds_S = LDS     $@\n      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -U$(ARCH) \\\n\t                     -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $<\n\n$(obj)/%.lds: $(src)/%.lds.S FORCE\n\t$(call if_changed_dep,cpp_lds_S)\n\n# ASN.1 grammar\n# ---------------------------------------------------------------------------\nquiet_cmd_asn1_compiler = ASN.1   $(basename $@).[ch]\n      cmd_asn1_compiler = $(objtree)/scripts/asn1_compiler $< \\\n\t\t\t\t$(basename $@).c $(basename $@).h\n\n$(obj)/%.asn1.c $(obj)/%.asn1.h: $(src)/%.asn1 $(objtree)/scripts/asn1_compiler\n\t$(call cmd,asn1_compiler)\n\n# Build the compiled-in targets\n# ---------------------------------------------------------------------------\n\n# To build objects in subdirs, we need to descend into the directories\n$(subdir-builtin): $(obj)/%/built-in.a: $(obj)/% ;\n$(subdir-modorder): $(obj)/%/modules.order: $(obj)/% ;\n\n#\n# Rule to compile a set of .o files into one .a file (without symbol table)\n#\n# To make this rule robust against \"Argument list too long\" error,\n# remove $(obj)/ prefix, and restore it by a shell command.\n\nquiet_cmd_ar_builtin = AR      $@\n      cmd_ar_builtin = rm -f $@; \\\n\t$(if $(real-prereqs), printf \"$(obj)/%s \" $(patsubst $(obj)/%,%,$(real-prereqs)) | xargs) \\\n\t$(AR) cDPrST $@\n\n$(obj)/built-in.a: $(real-obj-y) FORCE\n\t$(call if_changed,ar_builtin)\n\n#\n# Rule to create modules.order file\n#\n# Create commands to either record .ko file or cat modules.order from\n# a subdirectory\n# Add $(obj-m) as the prerequisite to avoid updating the timestamp of\n# modules.order unless contained modules are updated.\n\ncmd_modules_order = { $(foreach m, $(real-prereqs), \\\n\t$(if $(filter %/modules.order, $m), cat $m, echo $m);) :; } \\\n\t> $@\n\n$(obj)/modules.order: $(obj-m) FORCE\n\t$(call if_changed,modules_order)\n\n#\n# Rule to compile a set of .o files into one .a file (with symbol table)\n#\n\n$(obj)/lib.a: $(lib-y) FORCE\n\t$(call if_changed,ar)\n\nquiet_cmd_ld_multi_m = LD [M]  $@\n      cmd_ld_multi_m = $(LD) $(ld_flags) -r -o $@ @$(patsubst %.o,%.mod,$@) $(cmd_objtool)\n\ndefine rule_ld_multi_m\n\t$(call cmd_and_savecmd,ld_multi_m)\n\t$(call cmd,gen_objtooldep)\nendef\n\n$(multi-obj-m): objtool-enabled := $(delay-objtool)\n$(multi-obj-m): part-of-module := y\n$(multi-obj-m): %.o: %.mod FORCE\n\t$(call if_changed_rule,ld_multi_m)\n$(call multi_depend, $(multi-obj-m), .o, -objs -y -m)\n\n# Add intermediate targets:\n# When building objects with specific suffix patterns, add intermediate\n# targets that the final targets are derived from.\nintermediate_targets = $(foreach sfx, $(2), \\\n\t\t\t\t$(patsubst %$(strip $(1)),%$(sfx), \\\n\t\t\t\t\t$(filter %$(strip $(1)), $(targets))))\n# %.asn1.o <- %.asn1.[ch] <- %.asn1\n# %.dtb.o <- %.dtb.S <- %.dtb <- %.dts\n# %.dtbo.o <- %.dtbo.S <- %.dtbo <- %.dtso\n# %.lex.o <- %.lex.c <- %.l\n# %.tab.o <- %.tab.[ch] <- %.y\ntargets += $(call intermediate_targets, .asn1.o, .asn1.c .asn1.h) \\\n\t   $(call intermediate_targets, .dtb.o, .dtb.S .dtb) \\\n\t   $(call intermediate_targets, .dtbo.o, .dtbo.S .dtbo) \\\n\t   $(call intermediate_targets, .lex.o, .lex.c) \\\n\t   $(call intermediate_targets, .tab.o, .tab.c .tab.h)\n\n# Build\n# ---------------------------------------------------------------------------\n\n$(obj)/: $(if $(KBUILD_BUILTIN), $(targets-for-builtin)) \\\n\t $(if $(KBUILD_MODULES), $(targets-for-modules)) \\\n\t $(subdir-ym) $(always-y)\n\t@:\n\n# Single targets\n# ---------------------------------------------------------------------------\n\nsingle-subdirs := $(foreach d, $(subdir-ym), $(if $(filter $d/%, $(MAKECMDGOALS)), $d))\nsingle-subdir-goals := $(filter $(addsuffix /%, $(single-subdirs)), $(MAKECMDGOALS))\n\n$(single-subdir-goals): $(single-subdirs)\n\t@:\n\n# Descending\n# ---------------------------------------------------------------------------\n\nPHONY += $(subdir-ym)\n$(subdir-ym):\n\t$(Q)$(MAKE) $(build)=$@ \\\n\tneed-builtin=$(if $(filter $@/built-in.a, $(subdir-builtin)),1) \\\n\tneed-modorder=$(if $(filter $@/modules.order, $(subdir-modorder)),1) \\\n\t$(filter $@/%, $(single-subdir-goals))\n\n# Add FORCE to the prequisites of a target to force it to be always rebuilt.\n# ---------------------------------------------------------------------------\n\nPHONY += FORCE\n\nFORCE:\n\ntargets += $(filter-out $(single-subdir-goals), $(MAKECMDGOALS))\ntargets := $(filter-out $(PHONY), $(targets))\n\n# Read all saved command lines and dependencies for the $(targets) we\n# may be building above, using $(if_changed{,_dep}). As an\n# optimization, we don't need to read them if the target does not\n# exist, we will rebuild anyway in that case.\n\nexisting-targets := $(wildcard $(sort $(targets)))\n\n-include $(foreach f,$(existing-targets),$(dir $(f)).$(notdir $(f)).cmd)\n\n# Create directories for object files if they do not exist\nobj-dirs := $(sort $(patsubst %/,%, $(dir $(targets))))\n# If targets exist, their directories apparently exist. Skip mkdir.\nexisting-dirs := $(sort $(patsubst %/,%, $(dir $(existing-targets))))\nobj-dirs := $(strip $(filter-out $(existing-dirs), $(obj-dirs)))\nifneq ($(obj-dirs),)\n$(shell mkdir -p $(obj-dirs))\nendif\n\n.PHONY: $(PHONY)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}