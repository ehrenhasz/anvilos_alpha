{
  "module_name": "mksysmap",
  "hash_id": "a828505911b97fb2a8bb9dd981191af9e969c9aecac51a44a0c250c0ba198462",
  "original_prompt": "Ingested from linux-6.6.14/scripts/mksysmap",
  "human_readable_source": "#!/bin/sh -x\n# Based on the vmlinux file create the System.map file\n# System.map is used by module-init tools and some debugging\n# tools to retrieve the actual addresses of symbols in the kernel.\n#\n# Usage\n# mksysmap vmlinux System.map [exclude]\n\n\n#####\n# Generate System.map (actual filename passed as second argument)\n# The following refers to the symbol type as per nm(1).\n\n# readprofile starts reading symbols when _stext is found, and\n# continue until it finds a symbol which is not either of 'T', 't',\n# 'W' or 'w'.\n#\n\n${NM} -n ${1} | sed >${2} -e \"\n# ---------------------------------------------------------------------------\n# Ignored symbol types\n#\n\n# a: local absolute symbols\n# N: debugging symbols\n# U: undefined global symbols\n# w: local weak symbols\n/ [aNUw] /d\n\n# ---------------------------------------------------------------------------\n# Ignored prefixes\n#  (do not forget a space before each pattern)\n\n# local symbols for ARM, MIPS, etc.\n/ \\\\$/d\n\n# local labels, .LBB, .Ltmpxxx, .L__unnamed_xx, .LASANPC, etc.\n/ \\.L/d\n\n# arm64 EFI stub namespace\n/ __efistub_/d\n\n# arm64 local symbols in PIE namespace\n/ __pi_\\\\$/d\n/ __pi_\\.L/d\n\n# arm64 local symbols in non-VHE KVM namespace\n/ __kvm_nvhe_\\\\$/d\n/ __kvm_nvhe_\\.L/d\n\n# arm64 lld\n/ __AArch64ADRPThunk_/d\n\n# arm lld\n/ __ARMV5PILongThunk_/d\n/ __ARMV7PILongThunk_/d\n/ __ThumbV7PILongThunk_/d\n\n# mips lld\n/ __LA25Thunk_/d\n/ __microLA25Thunk_/d\n\n# CFI type identifiers\n/ __kcfi_typeid_/d\n/ __kvm_nvhe___kcfi_typeid_/d\n/ __pi___kcfi_typeid_/d\n\n# CRC from modversions\n/ __crc_/d\n\n# EXPORT_SYMBOL (symbol name)\n/ __kstrtab_/d\n\n# EXPORT_SYMBOL (namespace)\n/ __kstrtabns_/d\n\n# ---------------------------------------------------------------------------\n# Ignored suffixes\n#  (do not forget '$' after each pattern)\n\n# arm\n/_from_arm$/d\n/_from_thumb$/d\n/_veneer$/d\n\n# ---------------------------------------------------------------------------\n# Ignored symbols (exact match)\n#  (do not forget a space before and '$' after each pattern)\n\n# for LoongArch?\n/ L0$/d\n\n# ppc\n/ _SDA_BASE_$/d\n/ _SDA2_BASE_$/d\n\n# ---------------------------------------------------------------------------\n# Ignored patterns\n#  (symbols that contain the pattern are ignored)\n\n# ppc stub\n/\\.long_branch\\./d\n/\\.plt_branch\\./d\n\n# ---------------------------------------------------------------------------\n# Ignored kallsyms symbols\n#\n# If the 3rd parameter exists, symbols from it will be omitted from the output.\n# This makes kallsyms have the identical symbol lists in the step 1 and 2.\n# Without this, the step2 would get new symbols generated by scripts/kallsyms.c\n# when CONFIG_KALLSYMS_ALL is enabled. That might require one more pass.\n$(if [ $# -ge 3 ]; then ${NM} ${3} | sed -n '/ U /!s:.* \\([^ ]*\\)$:/ \\1$/d:p'; fi)\n\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}