{
  "module_name": "get_feat.pl",
  "hash_id": "2f0346d04576d62d751d03c9074cb483cb83060ab09354890eac3e891df9488e",
  "original_prompt": "Ingested from linux-6.6.14/scripts/get_feat.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n\nuse strict;\nuse Pod::Usage;\nuse Getopt::Long;\nuse File::Find;\nuse Fcntl ':mode';\nuse Cwd 'abs_path';\n\nmy $help;\nmy $man;\nmy $debug;\nmy $arch;\nmy $feat;\nmy $enable_fname;\n\nmy $basename = abs_path($0);\n$basename =~ s,/[^/]+$,/,;\n\nmy $prefix=$basename . \"../Documentation/features\";\n\n# Used only at for full features output. The script will auto-adjust\n# such values for the minimal possible values\nmy $status_size = 1;\nmy $description_size = 1;\n\nGetOptions(\n\t\"debug|d+\" => \\$debug,\n\t\"dir=s\" => \\$prefix,\n\t'help|?' => \\$help,\n\t'arch=s' => \\$arch,\n\t'feat=s' => \\$feat,\n\t'feature=s' => \\$feat,\n\t\"enable-fname\" => \\$enable_fname,\n\tman => \\$man\n) or pod2usage(2);\n\npod2usage(1) if $help;\npod2usage(-exitstatus => 0, -verbose => 2) if $man;\n\npod2usage(1) if (scalar @ARGV < 1 || @ARGV > 2);\n\nmy ($cmd, $arg) = @ARGV;\n\npod2usage(2) if ($cmd ne \"current\" && $cmd ne \"rest\" && $cmd ne \"validate\"\n\t\t&& $cmd ne \"ls\" && $cmd ne \"list\");\n\nrequire Data::Dumper if ($debug);\n\nmy %data;\nmy %archs;\n\n#\n# Displays an error message, printing file name and line\n#\nsub parse_error($$$$) {\n\tmy ($file, $ln, $msg, $data) = @_;\n\n\t$data =~ s/\\s+$/\\n/;\n\n\tprint STDERR \"Warning: file $file#$ln:\\n\\t$msg\";\n\n\tif ($data ne \"\") {\n\t\tprint STDERR \". Line\\n\\t\\t$data\";\n\t} else {\n\t    print STDERR \"\\n\";\n\t}\n}\n\n#\n# Parse a features file, storing its contents at %data\n#\n\nmy $h_name = \"Feature\";\nmy $h_kconfig = \"Kconfig\";\nmy $h_description = \"Description\";\nmy $h_subsys = \"Subsystem\";\nmy $h_status = \"Status\";\nmy $h_arch = \"Architecture\";\n\nmy $max_size_name = length($h_name);\nmy $max_size_kconfig = length($h_kconfig);\nmy $max_size_description = length($h_description);\nmy $max_size_subsys = length($h_subsys);\nmy $max_size_status = length($h_status);\n\nmy $max_size_arch = 0;\nmy $max_size_arch_with_header;\nmy $max_description_word = 0;\n\nsub parse_feat {\n\tmy $file = $File::Find::name;\n\n\tmy $mode = (stat($file))[2];\n\treturn if ($mode & S_IFDIR);\n\treturn if ($file =~ m,($prefix)/arch-support.txt,);\n\treturn if (!($file =~ m,arch-support.txt$,));\n\n\tif ($enable_fname) {\n\t\tprintf \".. FILE %s\\n\", abs_path($file);\n\t}\n\n\tmy $subsys = \"\";\n\t$subsys = $2 if ( m,.*($prefix)/([^/]+).*,);\n\n\tif (length($subsys) > $max_size_subsys) {\n\t\t$max_size_subsys = length($subsys);\n\t}\n\n\tmy $name;\n\tmy $kconfig;\n\tmy $description;\n\tmy $comments = \"\";\n\tmy $last_status;\n\tmy $ln;\n\tmy %arch_table;\n\n\tprint STDERR \"Opening $file\\n\" if ($debug > 1);\n\topen IN, $file;\n\n\twhile(<IN>) {\n\t\t$ln++;\n\n\t\tif (m/^\\#\\s+Feature\\s+name:\\s*(.*\\S)/) {\n\t\t\t$name = $1;\n\t\t\tif (length($name) > $max_size_name) {\n\t\t\t\t$max_size_name = length($name);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\tif (m/^\\#\\s+Kconfig:\\s*(.*\\S)/) {\n\t\t\t$kconfig = $1;\n\t\t\tif (length($kconfig) > $max_size_kconfig) {\n\t\t\t\t$max_size_kconfig = length($kconfig);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\tif (m/^\\#\\s+description:\\s*(.*\\S)/) {\n\t\t\t$description = $1;\n\t\t\tif (length($description) > $max_size_description) {\n\t\t\t\t$max_size_description = length($description);\n\t\t\t}\n\n\t\t\tforeach my $word (split /\\s+/, $description) {\n\t\t\t\tif (length($word) > $max_description_word) {\n\t\t\t\t\t$max_description_word = length($word);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext;\n\t\t}\n\t\tnext if (m/^\\\\s*$/);\n\t\tnext if (m/^\\s*\\-+\\s*$/);\n\t\tnext if (m/^\\s*\\|\\s*arch\\s*\\|\\s*status\\s*\\|\\s*$/);\n\n\t\tif (m/^\\#\\s*(.*)/) {\n\t\t\t$comments .= \"$1\\n\";\n\t\t\tnext;\n\t\t}\n\t\tif (m/^\\s*\\|\\s*(\\S+):\\s*\\|\\s*(\\S+)\\s*\\|\\s*$/) {\n\t\t\tmy $a = $1;\n\t\t\tmy $status = $2;\n\n\t\t\tif (length($status) > $max_size_status) {\n\t\t\t\t$max_size_status = length($status);\n\t\t\t}\n\t\t\tif (length($a) > $max_size_arch) {\n\t\t\t\t$max_size_arch = length($a);\n\t\t\t}\n\n\t\t\t$status = \"---\" if ($status =~ m/^\\.\\.$/);\n\n\t\t\t$archs{$a} = 1;\n\t\t\t$arch_table{$a} = $status;\n\t\t\tnext;\n\t\t}\n\n\t\t#Everything else is an error\n\t\tparse_error($file, $ln, \"line is invalid\", $_);\n\t}\n\tclose IN;\n\n\tif (!$name) {\n\t\tparse_error($file, $ln, \"Feature name not found\", \"\");\n\t\treturn;\n\t}\n\n\tparse_error($file, $ln, \"Subsystem not found\", \"\") if (!$subsys);\n\tparse_error($file, $ln, \"Kconfig not found\", \"\") if (!$kconfig);\n\tparse_error($file, $ln, \"Description not found\", \"\") if (!$description);\n\n\tif (!%arch_table) {\n\t\tparse_error($file, $ln, \"Architecture table not found\", \"\");\n\t\treturn;\n\t}\n\n\t$data{$name}->{where} = $file;\n\t$data{$name}->{subsys} = $subsys;\n\t$data{$name}->{kconfig} = $kconfig;\n\t$data{$name}->{description} = $description;\n\t$data{$name}->{comments} = $comments;\n\t$data{$name}->{table} = \\%arch_table;\n\n\t$max_size_arch_with_header = $max_size_arch + length($h_arch);\n}\n\n#\n# Output feature(s) for a given architecture\n#\nsub output_arch_table {\n\tmy $title = \"Feature status on $arch architecture\";\n\n\tprint \"=\" x length($title) . \"\\n\";\n\tprint \"$title\\n\";\n\tprint \"=\" x length($title) . \"\\n\\n\";\n\n\tprint \"=\" x $max_size_subsys;\n\tprint \"  \";\n\tprint \"=\" x $max_size_name;\n\tprint \"  \";\n\tprint \"=\" x $max_size_kconfig;\n\tprint \"  \";\n\tprint \"=\" x $max_size_status;\n\tprint \"  \";\n\tprint \"=\" x $max_size_description;\n\tprint \"\\n\";\n\tprintf \"%-${max_size_subsys}s  \", $h_subsys;\n\tprintf \"%-${max_size_name}s  \", $h_name;\n\tprintf \"%-${max_size_kconfig}s  \", $h_kconfig;\n\tprintf \"%-${max_size_status}s  \", $h_status;\n\tprintf \"%-${max_size_description}s\\n\", $h_description;\n\tprint \"=\" x $max_size_subsys;\n\tprint \"  \";\n\tprint \"=\" x $max_size_name;\n\tprint \"  \";\n\tprint \"=\" x $max_size_kconfig;\n\tprint \"  \";\n\tprint \"=\" x $max_size_status;\n\tprint \"  \";\n\tprint \"=\" x $max_size_description;\n\tprint \"\\n\";\n\n\tforeach my $name (sort {\n\t\t\t\t($data{$a}->{subsys} cmp $data{$b}->{subsys}) ||\n\t\t\t\t(\"\\L$a\" cmp \"\\L$b\")\n\t\t\t       } keys %data) {\n\t\tnext if ($feat && $name ne $feat);\n\n\t\tmy %arch_table = %{$data{$name}->{table}};\n\t\tprintf \"%-${max_size_subsys}s  \", $data{$name}->{subsys};\n\t\tprintf \"%-${max_size_name}s  \", $name;\n\t\tprintf \"%-${max_size_kconfig}s  \", $data{$name}->{kconfig};\n\t\tprintf \"%-${max_size_status}s  \", $arch_table{$arch};\n\t\tprintf \"%-s\\n\", $data{$name}->{description};\n\t}\n\n\tprint \"=\" x $max_size_subsys;\n\tprint \"  \";\n\tprint \"=\" x $max_size_name;\n\tprint \"  \";\n\tprint \"=\" x $max_size_kconfig;\n\tprint \"  \";\n\tprint \"=\" x $max_size_status;\n\tprint \"  \";\n\tprint \"=\" x $max_size_description;\n\tprint \"\\n\";\n}\n\n#\n# list feature(s) for a given architecture\n#\nsub list_arch_features {\n\tprint \"#\\n# Kernel feature support matrix of the '$arch' architecture:\\n#\\n\";\n\n\tforeach my $name (sort {\n\t\t\t\t($data{$a}->{subsys} cmp $data{$b}->{subsys}) ||\n\t\t\t\t(\"\\L$a\" cmp \"\\L$b\")\n\t\t\t       } keys %data) {\n\t\tnext if ($feat && $name ne $feat);\n\n\t\tmy %arch_table = %{$data{$name}->{table}};\n\n\t\tmy $status = $arch_table{$arch};\n\t\t$status = \" \" x ((4 - length($status)) / 2) . $status;\n\n\t\tprintf \" %${max_size_subsys}s/ \", $data{$name}->{subsys};\n\t\tprintf \"%-${max_size_name}s: \", $name;\n\t\tprintf \"%-5s|   \", $status;\n\t\tprintf \"%${max_size_kconfig}s # \", $data{$name}->{kconfig};\n\t\tprintf \" %s\\n\", $data{$name}->{description};\n\t}\n}\n\n#\n# Output a feature on all architectures\n#\nsub output_feature {\n\tmy $title = \"Feature $feat\";\n\n\tprint \"=\" x length($title) . \"\\n\";\n\tprint \"$title\\n\";\n\tprint \"=\" x length($title) . \"\\n\\n\";\n\n\tprint \":Subsystem: $data{$feat}->{subsys} \\n\" if ($data{$feat}->{subsys});\n\tprint \":Kconfig: $data{$feat}->{kconfig} \\n\" if ($data{$feat}->{kconfig});\n\n\tmy $desc = $data{$feat}->{description};\n\t$desc =~ s/^([a-z])/\\U$1/;\n\t$desc =~ s/\\.?\\s*//;\n\tprint \"\\n$desc.\\n\\n\";\n\n\tmy $com = $data{$feat}->{comments};\n\t$com =~ s/^\\s+//;\n\t$com =~ s/\\s+$//;\n\tif ($com) {\n\t\tprint \"Comments\\n\";\n\t\tprint \"--------\\n\\n\";\n\t\tprint \"$com\\n\\n\";\n\t}\n\n\tprint \"=\" x $max_size_arch_with_header;\n\tprint \"  \";\n\tprint \"=\" x $max_size_status;\n\tprint \"\\n\";\n\n\tprintf \"%-${max_size_arch}s  \", $h_arch;\n\tprintf \"%-${max_size_status}s\", $h_status . \"\\n\";\n\n\tprint \"=\" x $max_size_arch_with_header;\n\tprint \"  \";\n\tprint \"=\" x $max_size_status;\n\tprint \"\\n\";\n\n\tmy %arch_table = %{$data{$feat}->{table}};\n\tforeach my $arch (sort keys %arch_table) {\n\t\tprintf \"%-${max_size_arch}s  \", $arch;\n\t\tprintf \"%-${max_size_status}s\\n\", $arch_table{$arch};\n\t}\n\n\tprint \"=\" x $max_size_arch_with_header;\n\tprint \"  \";\n\tprint \"=\" x $max_size_status;\n\tprint \"\\n\";\n}\n\n#\n# Output all features for all architectures\n#\n\nsub matrix_lines($$$) {\n\tmy $desc_size = shift;\n\tmy $status_size = shift;\n\tmy $header = shift;\n\tmy $fill;\n\tmy $ln_marker;\n\n\tif ($header) {\n\t\t$ln_marker = \"=\";\n\t} else {\n\t\t$ln_marker = \"-\";\n\t}\n\n\t$fill = $ln_marker;\n\n\tprint \"+\";\n\tprint $fill x $max_size_name;\n\tprint \"+\";\n\tprint $fill x $desc_size;\n\tprint \"+\";\n\tprint $ln_marker x $status_size;\n\tprint \"+\\n\";\n}\n\nsub output_matrix {\n\tmy $title = \"Feature status on all architectures\";\n\tmy $notcompat = \"Not compatible\";\n\n\tprint \"=\" x length($title) . \"\\n\";\n\tprint \"$title\\n\";\n\tprint \"=\" x length($title) . \"\\n\\n\";\n\n\tmy $desc_title = \"$h_kconfig / $h_description\";\n\n\tmy $desc_size = $max_size_kconfig + 4;\n\tif (!$description_size) {\n\t\t$desc_size = $max_size_description if ($max_size_description > $desc_size);\n\t} else {\n\t\t$desc_size = $description_size if ($description_size > $desc_size);\n\t}\n\t$desc_size = $max_description_word if ($max_description_word > $desc_size);\n\n\t$desc_size = length($desc_title) if (length($desc_title) > $desc_size);\n\n\t$max_size_status = length($notcompat) if (length($notcompat) > $max_size_status);\n\n\t# Ensure that the status will fit\n\tmy $min_status_size = $max_size_status + $max_size_arch + 6;\n\t$status_size = $min_status_size if ($status_size < $min_status_size);\n\n\n\tmy $cur_subsys = \"\";\n\tforeach my $name (sort {\n\t\t\t\t($data{$a}->{subsys} cmp $data{$b}->{subsys}) or\n\t\t\t\t(\"\\L$a\" cmp \"\\L$b\")\n\t\t\t       } keys %data) {\n\n\t\tif ($cur_subsys ne $data{$name}->{subsys}) {\n\t\t\tif ($cur_subsys ne \"\") {\n\t\t\t\tprintf \"\\n\";\n\t\t\t}\n\n\t\t\t$cur_subsys = $data{$name}->{subsys};\n\n\t\t\tmy $title = \"Subsystem: $cur_subsys\";\n\t\t\tprint \"$title\\n\";\n\t\t\tprint \"=\" x length($title) . \"\\n\\n\";\n\n\n\t\t\tmatrix_lines($desc_size, $status_size, 0);\n\n\t\t\tprintf \"|%-${max_size_name}s\", $h_name;\n\t\t\tprintf \"|%-${desc_size}s\", $desc_title;\n\n\t\t\tprintf \"|%-${status_size}s|\\n\", \"Status per architecture\";\n\t\t\tmatrix_lines($desc_size, $status_size, 1);\n\t\t}\n\n\t\tmy %arch_table = %{$data{$name}->{table}};\n\t\tmy $cur_status = \"\";\n\n\t\tmy (@lines, @descs);\n\t\tmy $line = \"\";\n\t\tforeach my $arch (sort {\n\t\t\t\t\t($arch_table{$b} cmp $arch_table{$a}) or\n\t\t\t\t\t(\"\\L$a\" cmp \"\\L$b\")\n\t\t\t\t       } keys %arch_table) {\n\n\t\t\tmy $status = $arch_table{$arch};\n\n\t\t\tif ($status eq \"---\") {\n\t\t\t\t$status = $notcompat;\n\t\t\t}\n\n\t\t\tif ($status ne $cur_status) {\n\t\t\t\tif ($line ne \"\") {\n\t\t\t\t\tpush @lines, $line;\n\t\t\t\t\t$line = \"\";\n\t\t\t\t}\n\t\t\t\t$line = \"- **\" . $status . \"**: \" . $arch;\n\t\t\t} elsif (length($line) + length ($arch) + 2 < $status_size) {\n\t\t\t\t$line .= \", \" . $arch;\n\t\t\t} else {\n\t\t\t\tpush @lines, $line;\n\t\t\t\t$line = \"  \" . $arch;\n\t\t\t}\n\t\t\t$cur_status = $status;\n\t\t}\n\t\tpush @lines, $line if ($line ne \"\");\n\n\t\tmy $description = $data{$name}->{description};\n\t\twhile (length($description) > $desc_size) {\n\t\t\tmy $d = substr $description, 0, $desc_size;\n\n\t\t\t# Ensure that it will end on a space\n\t\t\t# if it can't, it means that the size is too small\n\t\t\t# Instead of aborting it, let's print what we have\n\t\t\tif (!($d =~ s/^(.*)\\s+.*/$1/)) {\n\t\t\t\t$d = substr $d, 0, -1;\n\t\t\t\tpush @descs, \"$d\\\\\";\n\t\t\t\t$description =~ s/^\\Q$d\\E//;\n\t\t\t} else {\n\t\t\t\tpush @descs, $d;\n\t\t\t\t$description =~ s/^\\Q$d\\E\\s+//;\n\t\t\t}\n\t\t}\n\t\tpush @descs, $description;\n\n\t\t# Ensure that the full description will be printed\n\t\tpush @lines, \"\" while (scalar(@lines) < 2 + scalar(@descs));\n\n\t\tmy $ln = 0;\n\t\tfor my $line(@lines) {\n\t\t\tif (!$ln) {\n\t\t\t\tprintf \"|%-${max_size_name}s\", $name;\n\t\t\t\tprintf \"|%-${desc_size}s\", \"``\" . $data{$name}->{kconfig} . \"``\";\n\t\t\t} elsif ($ln >= 2 && scalar(@descs)) {\n\t\t\t\tprintf \"|%-${max_size_name}s\", \"\";\n\t\t\t\tprintf \"|%-${desc_size}s\", shift @descs;\n\t\t\t} else {\n\t\t\t\tprintf \"|%-${max_size_name}s\", \"\";\n\t\t\t\tprintf \"|%-${desc_size}s\", \"\";\n\t\t\t}\n\n\t\t\tprintf \"|%-${status_size}s|\\n\", $line;\n\n\t\t\t$ln++;\n\t\t}\n\t\tmatrix_lines($desc_size, $status_size, 0);\n\t}\n}\n\n\n#\n# Parses all feature files located at $prefix dir\n#\nfind({wanted =>\\&parse_feat, no_chdir => 1}, $prefix);\n\nprint STDERR Data::Dumper->Dump([\\%data], [qw(*data)]) if ($debug);\n\n#\n# Handles the command\n#\nif ($cmd eq \"current\") {\n\t$arch = qx(uname -m | sed 's/x86_64/x86/' | sed 's/i386/x86/');\n\t$arch =~s/\\s+$//;\n}\n\nif ($cmd eq \"ls\" or $cmd eq \"list\") {\n\tif (!$arch) {\n\t\t$arch = qx(uname -m | sed 's/x86_64/x86/' | sed 's/i386/x86/');\n\t\t$arch =~s/\\s+$//;\n\t}\n\n\tlist_arch_features;\n\n\texit;\n}\n\nif ($cmd ne \"validate\") {\n\tif ($arch) {\n\t\toutput_arch_table;\n\t} elsif ($feat) {\n\t\toutput_feature;\n\t} else {\n\t\toutput_matrix;\n\t}\n}\n\n__END__\n\n=head1 NAME\n\nget_feat.pl - parse the Linux Feature files and produce a ReST book.\n\n=head1 SYNOPSIS\n\nB<get_feat.pl> [--debug] [--man] [--help] [--dir=<dir>] [--arch=<arch>]\n\t       [--feature=<feature>|--feat=<feature>] <COMAND> [<ARGUMENT>]\n\nWhere <COMMAND> can be:\n\n=over 8\n\nB<current>               - output table in ReST compatible ASCII format\n\t\t\t   with features for this machine's architecture\n\nB<rest>                  - output table(s)  in ReST compatible ASCII format\n\t\t\t   with features in ReST markup language. The output\n\t\t\t   is affected by --arch or --feat/--feature flags.\n\nB<validate>              - validate the contents of the files under\n\t\t\t   Documentation/features.\n\nB<ls> or B<list>         - list features for this machine's architecture,\n\t\t\t   using an easier to parse format.\n\t\t\t   The output is affected by --arch flag.\n\n=back\n\n=head1 OPTIONS\n\n=over 8\n\n=item B<--arch>\n\nOutput features for an specific architecture, optionally filtering for\na single specific feature.\n\n=item B<--feat> or B<--feature>\n\nOutput features for a single specific feature.\n\n=item B<--dir>\n\nChanges the location of the Feature files. By default, it uses\nthe Documentation/features directory.\n\n=item B<--enable-fname>\n\nPrints the file name of the feature files. This can be used in order to\ntrack dependencies during documentation build.\n\n=item B<--debug>\n\nPut the script in verbose mode, useful for debugging. Can be called multiple\ntimes, to increase verbosity.\n\n=item B<--help>\n\nPrints a brief help message and exits.\n\n=item B<--man>\n\nPrints the manual page and exits.\n\n=back\n\n=head1 DESCRIPTION\n\nParse the Linux feature files from Documentation/features (by default),\noptionally producing results at ReST format.\n\nIt supports output data per architecture, per feature or a\nfeature x arch matrix.\n\nWhen used with B<rest> command, it will use either one of the tree formats:\n\nIf neither B<--arch> or B<--feature> arguments are used, it will output a\nmatrix with features per architecture.\n\nIf B<--arch> argument is used, it will output the features availability for\na given architecture.\n\nIf B<--feat> argument is used, it will output the content of the feature\nfile using ReStructured Text markup.\n\n=head1 BUGS\n\nReport bugs to Mauro Carvalho Chehab <mchehab+samsung@kernel.org>\n\n=head1 COPYRIGHT\n\nCopyright (c) 2019 by Mauro Carvalho Chehab <mchehab+samsung@kernel.org>.\n\nLicense GPLv2: GNU GPL version 2 <http://gnu.org/licenses/gpl.html>.\n\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n=cut\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}