{
  "module_name": "gcc-common.h",
  "hash_id": "fb75444bab9e51b49a935de42c82ccf7acf4e6b3de9204dd1674beafeb6cc37e",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gcc-plugins/gcc-common.h",
  "human_readable_source": " \n#ifndef GCC_COMMON_H_INCLUDED\n#define GCC_COMMON_H_INCLUDED\n\n#include \"bversion.h\"\n#if BUILDING_GCC_VERSION >= 6000\n#include \"gcc-plugin.h\"\n#else\n#include \"plugin.h\"\n#endif\n#include \"plugin-version.h\"\n#include \"config.h\"\n#include \"system.h\"\n#include \"coretypes.h\"\n#include \"tm.h\"\n#include \"line-map.h\"\n#include \"input.h\"\n#include \"tree.h\"\n\n#include \"tree-inline.h\"\n#include \"version.h\"\n#include \"rtl.h\"\n#include \"tm_p.h\"\n#include \"flags.h\"\n#include \"hard-reg-set.h\"\n#include \"output.h\"\n#include \"except.h\"\n#include \"function.h\"\n#include \"toplev.h\"\n#include \"expr.h\"\n#include \"basic-block.h\"\n#include \"intl.h\"\n#include \"ggc.h\"\n#include \"timevar.h\"\n\n#if BUILDING_GCC_VERSION < 10000\n#include \"params.h\"\n#endif\n\n#include \"hash-map.h\"\n\n#if BUILDING_GCC_VERSION >= 7000\n#include \"memmodel.h\"\n#endif\n#include \"emit-rtl.h\"\n#include \"debug.h\"\n#include \"target.h\"\n#include \"langhooks.h\"\n#include \"cfgloop.h\"\n#include \"cgraph.h\"\n#include \"opts.h\"\n#include \"tree-pretty-print.h\"\n#include \"gimple-pretty-print.h\"\n#include \"c-family/c-common.h\"\n#include \"tree-cfgcleanup.h\"\n#include \"tree-ssa-operands.h\"\n#include \"tree-into-ssa.h\"\n#include \"is-a.h\"\n#include \"diagnostic.h\"\n#include \"tree-dump.h\"\n#include \"tree-pass.h\"\n#include \"pass_manager.h\"\n#include \"predict.h\"\n#include \"ipa-utils.h\"\n\n#if BUILDING_GCC_VERSION >= 8000\n#include \"stringpool.h\"\n#endif\n\n#include \"attribs.h\"\n#include \"varasm.h\"\n#include \"stor-layout.h\"\n#include \"internal-fn.h\"\n#include \"gimple.h\"\n#include \"gimple-expr.h\"\n#include \"gimple-iterator.h\"\n#include \"gimple-fold.h\"\n#include \"context.h\"\n#include \"tree-ssa-alias.h\"\n#include \"tree-ssa.h\"\n#include \"stringpool.h\"\n#if BUILDING_GCC_VERSION >= 7000\n#include \"tree-vrp.h\"\n#endif\n#include \"tree-ssanames.h\"\n#include \"print-tree.h\"\n#include \"tree-eh.h\"\n#include \"stmt.h\"\n#include \"gimplify.h\"\n#include \"tree-phinodes.h\"\n#include \"tree-cfg.h\"\n#include \"gimple-ssa.h\"\n#include \"ssa-iterators.h\"\n\n#include \"builtins.h\"\n\n \nvoid debug_dominance_info(enum cdi_direction dir);\nvoid debug_dominance_tree(enum cdi_direction dir, basic_block root);\n\n#ifndef __unused\n#define __unused __attribute__((__unused__))\n#endif\n#ifndef __visible\n#define __visible __attribute__((visibility(\"default\")))\n#endif\n\n#define DECL_NAME_POINTER(node) IDENTIFIER_POINTER(DECL_NAME(node))\n#define DECL_NAME_LENGTH(node) IDENTIFIER_LENGTH(DECL_NAME(node))\n#define TYPE_NAME_POINTER(node) IDENTIFIER_POINTER(TYPE_NAME(node))\n#define TYPE_NAME_LENGTH(node) IDENTIFIER_LENGTH(TYPE_NAME(node))\n\n \n#define C_TYPE_FIELDS_READONLY(TYPE) TREE_LANG_FLAG_1(TYPE)\n\nstatic inline tree build_const_char_string(int len, const char *str)\n{\n\ttree cstr, elem, index, type;\n\n\tcstr = build_string(len, str);\n\telem = build_type_variant(char_type_node, 1, 0);\n\tindex = build_index_type(size_int(len - 1));\n\ttype = build_array_type(elem, index);\n\tTREE_TYPE(cstr) = type;\n\tTREE_CONSTANT(cstr) = 1;\n\tTREE_READONLY(cstr) = 1;\n\tTREE_STATIC(cstr) = 1;\n\treturn cstr;\n}\n\n#define PASS_INFO(NAME, REF, ID, POS)\t\t\\\nstruct register_pass_info NAME##_pass_info = {\t\\\n\t.pass = make_##NAME##_pass(),\t\t\\\n\t.reference_pass_name = REF,\t\t\\\n\t.ref_pass_instance_number = ID,\t\t\\\n\t.pos_op = POS,\t\t\t\t\\\n}\n\n#define add_referenced_var(var)\n#define mark_sym_for_renaming(var)\n#define varpool_mark_needed_node(node)\n#define create_var_ann(var)\n#define TODO_dump_func 0\n#define TODO_dump_cgraph 0\n\n#define TODO_ggc_collect 0\n#define NODE_SYMBOL(node) (node)\n#define NODE_DECL(node) (node)->decl\n#define cgraph_node_name(node) (node)->name()\n#define NODE_IMPLICIT_ALIAS(node) (node)->cpp_implicit_alias\n\nstatic inline opt_pass *get_pass_for_id(int id)\n{\n\treturn g->get_passes()->get_pass_for_id(id);\n}\n\n#if BUILDING_GCC_VERSION < 6000\n \ntemplate <>\ntemplate <>\ninline bool is_a_helper<const gassign *>::test(const_gimple gs)\n{\n\treturn gs->code == GIMPLE_ASSIGN;\n}\n#endif\n\n#define TODO_verify_ssa TODO_verify_il\n#define TODO_verify_flow TODO_verify_il\n#define TODO_verify_stmts TODO_verify_il\n#define TODO_verify_rtl_sharing TODO_verify_il\n\n#define INSN_DELETED_P(insn) (insn)->deleted()\n\nstatic inline const char *get_decl_section_name(const_tree decl)\n{\n\treturn DECL_SECTION_NAME(decl);\n}\n\n \n#define debug_cgraph_node(node) (node)->debug()\n#define cgraph_get_node(decl) cgraph_node::get(decl)\n#define cgraph_get_create_node(decl) cgraph_node::get_create(decl)\n#define cgraph_create_node(decl) cgraph_node::create(decl)\n#define cgraph_n_nodes symtab->cgraph_count\n#define cgraph_max_uid symtab->cgraph_max_uid\n#define varpool_get_node(decl) varpool_node::get(decl)\n#define dump_varpool_node(file, node) (node)->dump(file)\n\n#if BUILDING_GCC_VERSION >= 8000\n#define cgraph_create_edge(caller, callee, call_stmt, count, freq) \\\n\t(caller)->create_edge((callee), (call_stmt), (count))\n\n#define cgraph_create_edge_including_clones(caller, callee,\t\\\n\t\told_call_stmt, call_stmt, count, freq, reason)\t\\\n\t(caller)->create_edge_including_clones((callee),\t\\\n\t\t(old_call_stmt), (call_stmt), (count), (reason))\n#else\n#define cgraph_create_edge(caller, callee, call_stmt, count, freq) \\\n\t(caller)->create_edge((callee), (call_stmt), (count), (freq))\n\n#define cgraph_create_edge_including_clones(caller, callee,\t\\\n\t\told_call_stmt, call_stmt, count, freq, reason)\t\\\n\t(caller)->create_edge_including_clones((callee),\t\\\n\t\t(old_call_stmt), (call_stmt), (count), (freq), (reason))\n#endif\n\ntypedef struct cgraph_node *cgraph_node_ptr;\ntypedef struct cgraph_edge *cgraph_edge_p;\ntypedef struct varpool_node *varpool_node_ptr;\n\nstatic inline void change_decl_assembler_name(tree decl, tree name)\n{\n\tsymtab->change_decl_assembler_name(decl, name);\n}\n\nstatic inline void varpool_finalize_decl(tree decl)\n{\n\tvarpool_node::finalize_decl(decl);\n}\n\nstatic inline void varpool_add_new_variable(tree decl)\n{\n\tvarpool_node::add(decl);\n}\n\nstatic inline unsigned int rebuild_cgraph_edges(void)\n{\n\treturn cgraph_edge::rebuild_edges();\n}\n\nstatic inline cgraph_node_ptr cgraph_function_node(cgraph_node_ptr node, enum availability *availability)\n{\n\treturn node->function_symbol(availability);\n}\n\nstatic inline cgraph_node_ptr cgraph_function_or_thunk_node(cgraph_node_ptr node, enum availability *availability = NULL)\n{\n\treturn node->ultimate_alias_target(availability);\n}\n\nstatic inline bool cgraph_only_called_directly_p(cgraph_node_ptr node)\n{\n\treturn node->only_called_directly_p();\n}\n\nstatic inline enum availability cgraph_function_body_availability(cgraph_node_ptr node)\n{\n\treturn node->get_availability();\n}\n\nstatic inline cgraph_node_ptr cgraph_alias_target(cgraph_node_ptr node)\n{\n\treturn node->get_alias_target();\n}\n\nstatic inline bool cgraph_for_node_and_aliases(cgraph_node_ptr node, bool (*callback)(cgraph_node_ptr, void *), void *data, bool include_overwritable)\n{\n\treturn node->call_for_symbol_thunks_and_aliases(callback, data, include_overwritable);\n}\n\nstatic inline struct cgraph_node_hook_list *cgraph_add_function_insertion_hook(cgraph_node_hook hook, void *data)\n{\n\treturn symtab->add_cgraph_insertion_hook(hook, data);\n}\n\nstatic inline void cgraph_remove_function_insertion_hook(struct cgraph_node_hook_list *entry)\n{\n\tsymtab->remove_cgraph_insertion_hook(entry);\n}\n\nstatic inline struct cgraph_node_hook_list *cgraph_add_node_removal_hook(cgraph_node_hook hook, void *data)\n{\n\treturn symtab->add_cgraph_removal_hook(hook, data);\n}\n\nstatic inline void cgraph_remove_node_removal_hook(struct cgraph_node_hook_list *entry)\n{\n\tsymtab->remove_cgraph_removal_hook(entry);\n}\n\nstatic inline struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook(cgraph_2node_hook hook, void *data)\n{\n\treturn symtab->add_cgraph_duplication_hook(hook, data);\n}\n\nstatic inline void cgraph_remove_node_duplication_hook(struct cgraph_2node_hook_list *entry)\n{\n\tsymtab->remove_cgraph_duplication_hook(entry);\n}\n\nstatic inline void cgraph_call_node_duplication_hooks(cgraph_node_ptr node, cgraph_node_ptr node2)\n{\n\tsymtab->call_cgraph_duplication_hooks(node, node2);\n}\n\nstatic inline void cgraph_call_edge_duplication_hooks(cgraph_edge *cs1, cgraph_edge *cs2)\n{\n\tsymtab->call_edge_duplication_hooks(cs1, cs2);\n}\n\n#if BUILDING_GCC_VERSION >= 6000\ntypedef gimple *gimple_ptr;\ntypedef const gimple *const_gimple_ptr;\n#define gimple gimple_ptr\n#define const_gimple const_gimple_ptr\n#undef CONST_CAST_GIMPLE\n#define CONST_CAST_GIMPLE(X) CONST_CAST(gimple, (X))\n#endif\n\n \nstatic inline gimple gimple_build_assign_with_ops(enum tree_code subcode, tree lhs, tree op1, tree op2 MEM_STAT_DECL)\n{\n\treturn gimple_build_assign(lhs, subcode, op1, op2 PASS_MEM_STAT);\n}\n\n#if BUILDING_GCC_VERSION < 10000\ntemplate <>\ntemplate <>\ninline bool is_a_helper<const ggoto *>::test(const_gimple gs)\n{\n\treturn gs->code == GIMPLE_GOTO;\n}\n\ntemplate <>\ntemplate <>\ninline bool is_a_helper<const greturn *>::test(const_gimple gs)\n{\n\treturn gs->code == GIMPLE_RETURN;\n}\n#endif\n\nstatic inline gasm *as_a_gasm(gimple stmt)\n{\n\treturn as_a<gasm *>(stmt);\n}\n\nstatic inline const gasm *as_a_const_gasm(const_gimple stmt)\n{\n\treturn as_a<const gasm *>(stmt);\n}\n\nstatic inline gassign *as_a_gassign(gimple stmt)\n{\n\treturn as_a<gassign *>(stmt);\n}\n\nstatic inline const gassign *as_a_const_gassign(const_gimple stmt)\n{\n\treturn as_a<const gassign *>(stmt);\n}\n\nstatic inline gcall *as_a_gcall(gimple stmt)\n{\n\treturn as_a<gcall *>(stmt);\n}\n\nstatic inline const gcall *as_a_const_gcall(const_gimple stmt)\n{\n\treturn as_a<const gcall *>(stmt);\n}\n\nstatic inline ggoto *as_a_ggoto(gimple stmt)\n{\n\treturn as_a<ggoto *>(stmt);\n}\n\nstatic inline const ggoto *as_a_const_ggoto(const_gimple stmt)\n{\n\treturn as_a<const ggoto *>(stmt);\n}\n\nstatic inline gphi *as_a_gphi(gimple stmt)\n{\n\treturn as_a<gphi *>(stmt);\n}\n\nstatic inline const gphi *as_a_const_gphi(const_gimple stmt)\n{\n\treturn as_a<const gphi *>(stmt);\n}\n\nstatic inline greturn *as_a_greturn(gimple stmt)\n{\n\treturn as_a<greturn *>(stmt);\n}\n\nstatic inline const greturn *as_a_const_greturn(const_gimple stmt)\n{\n\treturn as_a<const greturn *>(stmt);\n}\n\n \n#define ipa_ref_list_referring_iterate(L, I, P)\t\\\n\t(L)->referring.iterate((I), &(P))\n#define ipa_ref_list_reference_iterate(L, I, P)\t\\\n\t(L)->reference.iterate((I), &(P))\n\nstatic inline cgraph_node_ptr ipa_ref_referring_node(struct ipa_ref *ref)\n{\n\treturn dyn_cast<cgraph_node_ptr>(ref->referring);\n}\n\nstatic inline void ipa_remove_stmt_references(symtab_node *referring_node, gimple stmt)\n{\n\treferring_node->remove_stmt_references(stmt);\n}\n\n#if BUILDING_GCC_VERSION < 6000\n#define get_inner_reference(exp, pbitsize, pbitpos, poffset, pmode, punsignedp, preversep, pvolatilep, keep_aligning)\t\\\n\tget_inner_reference(exp, pbitsize, pbitpos, poffset, pmode, punsignedp, pvolatilep, keep_aligning)\n#define gen_rtx_set(ARG0, ARG1) gen_rtx_SET(VOIDmode, (ARG0), (ARG1))\n#endif\n\n#if BUILDING_GCC_VERSION >= 6000\n#define gen_rtx_set(ARG0, ARG1) gen_rtx_SET((ARG0), (ARG1))\n#endif\n\n#ifdef __cplusplus\nstatic inline void debug_tree(const_tree t)\n{\n\tdebug_tree(CONST_CAST_TREE(t));\n}\n\nstatic inline void debug_gimple_stmt(const_gimple s)\n{\n\tdebug_gimple_stmt(CONST_CAST_GIMPLE(s));\n}\n#else\n#define debug_tree(t) debug_tree(CONST_CAST_TREE(t))\n#define debug_gimple_stmt(s) debug_gimple_stmt(CONST_CAST_GIMPLE(s))\n#endif\n\n#if BUILDING_GCC_VERSION >= 7000\n#define get_inner_reference(exp, pbitsize, pbitpos, poffset, pmode, punsignedp, preversep, pvolatilep, keep_aligning)\t\\\n\tget_inner_reference(exp, pbitsize, pbitpos, poffset, pmode, punsignedp, preversep, pvolatilep)\n#endif\n\n#if BUILDING_GCC_VERSION < 7000\n#define SET_DECL_ALIGN(decl, align)\tDECL_ALIGN(decl) = (align)\n#define SET_DECL_MODE(decl, mode)\tDECL_MODE(decl) = (mode)\n#endif\n\n#if BUILDING_GCC_VERSION >= 14000\n#define last_stmt(x)\t\t\tlast_nondebug_stmt(x)\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}