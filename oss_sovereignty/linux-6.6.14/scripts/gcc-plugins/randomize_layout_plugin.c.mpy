{
  "module_name": "randomize_layout_plugin.c",
  "hash_id": "6ce9810f0abb36f432b258b1e8c977893a1724b68e1d0ba08561414dc0260f61",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gcc-plugins/randomize_layout_plugin.c",
  "human_readable_source": " \n\n#include \"gcc-common.h\"\n#include \"randomize_layout_seed.h\"\n\n#if BUILDING_GCC_MAJOR < 4 || (BUILDING_GCC_MAJOR == 4 && BUILDING_GCC_MINOR < 7)\n#error \"The RANDSTRUCT plugin requires GCC 4.7 or newer.\"\n#endif\n\n#define ORIG_TYPE_NAME(node) \\\n\t(TYPE_NAME(TYPE_MAIN_VARIANT(node)) != NULL_TREE ? ((const unsigned char *)IDENTIFIER_POINTER(TYPE_NAME(TYPE_MAIN_VARIANT(node)))) : (const unsigned char *)\"anonymous\")\n\n#define INFORM(loc, msg, ...)\tinform(loc, \"randstruct: \" msg, ##__VA_ARGS__)\n#define MISMATCH(loc, how, ...)\tINFORM(loc, \"casting between randomized structure pointer types (\" how \"): %qT and %qT\\n\", __VA_ARGS__)\n\n__visible int plugin_is_GPL_compatible;\n\nstatic int performance_mode;\n\nstatic struct plugin_info randomize_layout_plugin_info = {\n\t.version\t= PLUGIN_VERSION,\n\t.help\t\t= \"disable\\t\\t\\tdo not activate plugin\\n\"\n\t\t\t  \"performance-mode\\tenable cacheline-aware layout randomization\\n\"\n};\n\n \nstatic inline unsigned long\npartial_name_hash(unsigned long c, unsigned long prevhash)\n{\n\treturn (prevhash + (c << 4) + (c >> 4)) * 11;\n}\nstatic inline unsigned int\nname_hash(const unsigned char *name)\n{\n\tunsigned long hash = 0;\n\tunsigned int len = strlen((const char *)name);\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn (unsigned int)hash;\n}\n\nstatic tree handle_randomize_layout_attr(tree *node, tree name, tree args, int flags, bool *no_add_attrs)\n{\n\ttree type;\n\n\t*no_add_attrs = true;\n\tif (TREE_CODE(*node) == FUNCTION_DECL) {\n\t\terror(\"%qE attribute does not apply to functions (%qF)\", name, *node);\n\t\treturn NULL_TREE;\n\t}\n\n\tif (TREE_CODE(*node) == PARM_DECL) {\n\t\terror(\"%qE attribute does not apply to function parameters (%qD)\", name, *node);\n\t\treturn NULL_TREE;\n\t}\n\n\tif (TREE_CODE(*node) == VAR_DECL) {\n\t\terror(\"%qE attribute does not apply to variables (%qD)\", name, *node);\n\t\treturn NULL_TREE;\n\t}\n\n\tif (TYPE_P(*node)) {\n\t\ttype = *node;\n\t} else {\n\t\tgcc_assert(TREE_CODE(*node) == TYPE_DECL);\n\t\ttype = TREE_TYPE(*node);\n\t}\n\n\tif (TREE_CODE(type) != RECORD_TYPE) {\n\t\terror(\"%qE attribute used on %qT applies to struct types only\", name, type);\n\t\treturn NULL_TREE;\n\t}\n\n\tif (lookup_attribute(IDENTIFIER_POINTER(name), TYPE_ATTRIBUTES(type))) {\n\t\terror(\"%qE attribute is already applied to the type %qT\", name, type);\n\t\treturn NULL_TREE;\n\t}\n\n\t*no_add_attrs = false;\n\n\treturn NULL_TREE;\n}\n\n \nstatic tree handle_randomize_considered_attr(tree *node, tree name, tree args, int flags, bool *no_add_attrs)\n{\n\t*no_add_attrs = false;\n\treturn NULL_TREE;\n}\n\n \nstatic tree handle_randomize_performed_attr(tree *node, tree name, tree args, int flags, bool *no_add_attrs)\n{\n\t*no_add_attrs = false;\n\treturn NULL_TREE;\n}\n\n \n\ntypedef unsigned long long u64;\n\ntypedef struct ranctx { u64 a; u64 b; u64 c; u64 d; } ranctx;\n\n#define rot(x,k) (((x)<<(k))|((x)>>(64-(k))))\nstatic u64 ranval(ranctx *x) {\n\tu64 e = x->a - rot(x->b, 7);\n\tx->a = x->b ^ rot(x->c, 13);\n\tx->b = x->c + rot(x->d, 37);\n\tx->c = x->d + e;\n\tx->d = e + x->a;\n\treturn x->d;\n}\n\nstatic void raninit(ranctx *x, u64 *seed) {\n\tint i;\n\n\tx->a = seed[0];\n\tx->b = seed[1];\n\tx->c = seed[2];\n\tx->d = seed[3];\n\n\tfor (i=0; i < 30; ++i)\n\t\t(void)ranval(x);\n}\n\nstatic u64 shuffle_seed[4];\n\nstruct partition_group {\n\ttree tree_start;\n\tunsigned long start;\n\tunsigned long length;\n};\n\nstatic void partition_struct(tree *fields, unsigned long length, struct partition_group *size_groups, unsigned long *num_groups)\n{\n\tunsigned long i;\n\tunsigned long accum_size = 0;\n\tunsigned long accum_length = 0;\n\tunsigned long group_idx = 0;\n\n\tgcc_assert(length < INT_MAX);\n\n\tmemset(size_groups, 0, sizeof(struct partition_group) * length);\n\n\tfor (i = 0; i < length; i++) {\n\t\tif (size_groups[group_idx].tree_start == NULL_TREE) {\n\t\t\tsize_groups[group_idx].tree_start = fields[i];\n\t\t\tsize_groups[group_idx].start = i;\n\t\t\taccum_length = 0;\n\t\t\taccum_size = 0;\n\t\t}\n\t\taccum_size += (unsigned long)int_size_in_bytes(TREE_TYPE(fields[i]));\n\t\taccum_length++;\n\t\tif (accum_size >= 64) {\n\t\t\tsize_groups[group_idx].length = accum_length;\n\t\t\taccum_length = 0;\n\t\t\tgroup_idx++;\n\t\t}\n\t}\n\n\tif (size_groups[group_idx].tree_start != NULL_TREE &&\n\t    !size_groups[group_idx].length) {\n\t\tsize_groups[group_idx].length = accum_length;\n\t\tgroup_idx++;\n\t}\n\n\t*num_groups = group_idx;\n}\n\nstatic void performance_shuffle(tree *newtree, unsigned long length, ranctx *prng_state)\n{\n\tunsigned long i, x, index;\n\tstruct partition_group size_group[length];\n\tunsigned long num_groups = 0;\n\tunsigned long randnum;\n\n\tpartition_struct(newtree, length, (struct partition_group *)&size_group, &num_groups);\n\n\t \n\tfor (i = num_groups - 1; i > 0; i--) {\n\t\tstruct partition_group tmp;\n\t\trandnum = ranval(prng_state) % (i + 1);\n\t\ttmp = size_group[i];\n\t\tsize_group[i] = size_group[randnum];\n\t\tsize_group[randnum] = tmp;\n\t}\n\n\tfor (x = 0; x < num_groups; x++) {\n\t\tfor (index = size_group[x].length - 1; index > 0; index--) {\n\t\t\ttree tmp;\n\n\t\t\ti = size_group[x].start + index;\n\t\t\tif (DECL_BIT_FIELD_TYPE(newtree[i]))\n\t\t\t\tcontinue;\n\t\t\trandnum = ranval(prng_state) % (index + 1);\n\t\t\trandnum += size_group[x].start;\n\t\t\t \n\t\t\tif (DECL_BIT_FIELD_TYPE(newtree[randnum]))\n\t\t\t\tcontinue;\n\t\t\ttmp = newtree[i];\n\t\t\tnewtree[i] = newtree[randnum];\n\t\t\tnewtree[randnum] = tmp;\n\t\t}\n\t}\n}\n\nstatic void full_shuffle(tree *newtree, unsigned long length, ranctx *prng_state)\n{\n\tunsigned long i, randnum;\n\n\tfor (i = length - 1; i > 0; i--) {\n\t\ttree tmp;\n\t\trandnum = ranval(prng_state) % (i + 1);\n\t\ttmp = newtree[i];\n\t\tnewtree[i] = newtree[randnum];\n\t\tnewtree[randnum] = tmp;\n\t}\n}\n\n \nstatic void shuffle(const_tree type, tree *newtree, unsigned long length)\n{\n\tunsigned long i;\n\tu64 seed[4];\n\tranctx prng_state;\n\tconst unsigned char *structname;\n\n\tif (length == 0)\n\t\treturn;\n\n\tgcc_assert(TREE_CODE(type) == RECORD_TYPE);\n\n\tstructname = ORIG_TYPE_NAME(type);\n\n#ifdef __DEBUG_PLUGIN\n\tfprintf(stderr, \"Shuffling struct %s %p\\n\", (const char *)structname, type);\n#ifdef __DEBUG_VERBOSE\n\tdebug_tree((tree)type);\n#endif\n#endif\n\n\tfor (i = 0; i < 4; i++) {\n\t\tseed[i] = shuffle_seed[i];\n\t\tseed[i] ^= name_hash(structname);\n\t}\n\n\traninit(&prng_state, (u64 *)&seed);\n\n\tif (performance_mode)\n\t\tperformance_shuffle(newtree, length, &prng_state);\n\telse\n\t\tfull_shuffle(newtree, length, &prng_state);\n}\n\nstatic bool is_flexible_array(const_tree field)\n{\n\tconst_tree fieldtype;\n\tconst_tree typesize;\n\n\tfieldtype = TREE_TYPE(field);\n\ttypesize = TYPE_SIZE(fieldtype);\n\n\tif (TREE_CODE(fieldtype) != ARRAY_TYPE)\n\t\treturn false;\n\n\t \n\n\tif (typesize == NULL_TREE && TYPE_DOMAIN(fieldtype) != NULL_TREE &&\n\t    TYPE_MAX_VALUE(TYPE_DOMAIN(fieldtype)) == NULL_TREE)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int relayout_struct(tree type)\n{\n\tunsigned long num_fields = (unsigned long)list_length(TYPE_FIELDS(type));\n\tunsigned long shuffle_length = num_fields;\n\ttree field;\n\ttree newtree[num_fields];\n\tunsigned long i;\n\ttree list;\n\ttree variant;\n\ttree main_variant;\n\texpanded_location xloc;\n\tbool has_flexarray = false;\n\n\tif (TYPE_FIELDS(type) == NULL_TREE)\n\t\treturn 0;\n\n\tif (num_fields < 2)\n\t\treturn 0;\n\n\tgcc_assert(TREE_CODE(type) == RECORD_TYPE);\n\n\tgcc_assert(num_fields < INT_MAX);\n\n\tif (lookup_attribute(\"randomize_performed\", TYPE_ATTRIBUTES(type)) ||\n\t    lookup_attribute(\"no_randomize_layout\", TYPE_ATTRIBUTES(TYPE_MAIN_VARIANT(type))))\n\t\treturn 0;\n\n\t \n\tif (!strcmp((const char *)ORIG_TYPE_NAME(type), \"INTNETTRUNKFACTORY\") ||\n\t    !strcmp((const char *)ORIG_TYPE_NAME(type), \"RAWPCIFACTORY\"))\n\t\treturn 0;\n\n\t \n\txloc = expand_location(DECL_SOURCE_LOCATION(TYPE_FIELDS(type)));\n\n\tif (strstr(xloc.file, \"/uapi/\"))\n\t\terror(G_(\"attempted to randomize userland API struct %s\"), ORIG_TYPE_NAME(type));\n\n\tfor (field = TYPE_FIELDS(type), i = 0; field; field = TREE_CHAIN(field), i++) {\n\t\tgcc_assert(TREE_CODE(field) == FIELD_DECL);\n\t\tnewtree[i] = field;\n\t}\n\n\t \n\tif (is_flexible_array(newtree[num_fields - 1])) {\n\t\thas_flexarray = true;\n\t\tshuffle_length--;\n\t}\n\n\tshuffle(type, (tree *)newtree, shuffle_length);\n\n\t \n\tlist = make_node(FIELD_DECL);\n\tTREE_CHAIN(list) = newtree[0];\n\tTREE_TYPE(list) = void_type_node;\n\tDECL_SIZE(list) = bitsize_zero_node;\n\tDECL_NONADDRESSABLE_P(list) = 1;\n\tDECL_FIELD_BIT_OFFSET(list) = bitsize_zero_node;\n\tDECL_SIZE_UNIT(list) = size_zero_node;\n\tDECL_FIELD_OFFSET(list) = size_zero_node;\n\tDECL_CONTEXT(list) = type;\n\t\n\tTREE_READONLY(list) = 1;\n\n\tfor (i = 0; i < num_fields - 1; i++)\n\t\tTREE_CHAIN(newtree[i]) = newtree[i+1];\n\tTREE_CHAIN(newtree[num_fields - 1]) = NULL_TREE;\n\n\tmain_variant = TYPE_MAIN_VARIANT(type);\n\tfor (variant = main_variant; variant; variant = TYPE_NEXT_VARIANT(variant)) {\n\t\tTYPE_FIELDS(variant) = list;\n\t\tTYPE_ATTRIBUTES(variant) = copy_list(TYPE_ATTRIBUTES(variant));\n\t\tTYPE_ATTRIBUTES(variant) = tree_cons(get_identifier(\"randomize_performed\"), NULL_TREE, TYPE_ATTRIBUTES(variant));\n\t\tTYPE_ATTRIBUTES(variant) = tree_cons(get_identifier(\"designated_init\"), NULL_TREE, TYPE_ATTRIBUTES(variant));\n\t\tif (has_flexarray)\n\t\t\tTYPE_ATTRIBUTES(type) = tree_cons(get_identifier(\"has_flexarray\"), NULL_TREE, TYPE_ATTRIBUTES(type));\n\t}\n\n\t \n\tTYPE_SIZE(main_variant) = NULL_TREE;\n\tlayout_type(main_variant);\n\tgcc_assert(TYPE_SIZE(main_variant) != NULL_TREE);\n\n\treturn 1;\n}\n\n \nstatic const_tree get_field_type(const_tree field)\n{\n\treturn strip_array_types(TREE_TYPE(field));\n}\n\n \nstatic bool is_fptr(const_tree fieldtype)\n{\n\tif (TREE_CODE(fieldtype) != POINTER_TYPE)\n\t\treturn false;\n\n\treturn TREE_CODE(TREE_TYPE(fieldtype)) == FUNCTION_TYPE;\n}\n\n \nstatic int is_pure_ops_struct(const_tree node)\n{\n\tconst_tree field;\n\n\tgcc_assert(TREE_CODE(node) == RECORD_TYPE || TREE_CODE(node) == UNION_TYPE);\n\n\tfor (field = TYPE_FIELDS(node); field; field = TREE_CHAIN(field)) {\n\t\tconst_tree fieldtype = get_field_type(field);\n\t\tenum tree_code code = TREE_CODE(fieldtype);\n\n\t\tif (node == fieldtype)\n\t\t\tcontinue;\n\n\t\tif (code == RECORD_TYPE || code == UNION_TYPE) {\n\t\t\tif (!is_pure_ops_struct(fieldtype))\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!is_fptr(fieldtype))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void randomize_type(tree type)\n{\n\ttree variant;\n\n\tgcc_assert(TREE_CODE(type) == RECORD_TYPE);\n\n\tif (lookup_attribute(\"randomize_considered\", TYPE_ATTRIBUTES(type)))\n\t\treturn;\n\n\tif (lookup_attribute(\"randomize_layout\", TYPE_ATTRIBUTES(TYPE_MAIN_VARIANT(type))) || is_pure_ops_struct(type))\n\t\trelayout_struct(type);\n\n\tfor (variant = TYPE_MAIN_VARIANT(type); variant; variant = TYPE_NEXT_VARIANT(variant)) {\n\t\tTYPE_ATTRIBUTES(type) = copy_list(TYPE_ATTRIBUTES(type));\n\t\tTYPE_ATTRIBUTES(type) = tree_cons(get_identifier(\"randomize_considered\"), NULL_TREE, TYPE_ATTRIBUTES(type));\n\t}\n#ifdef __DEBUG_PLUGIN\n\tfprintf(stderr, \"Marking randomize_considered on struct %s\\n\", ORIG_TYPE_NAME(type));\n#ifdef __DEBUG_VERBOSE\n\tdebug_tree(type);\n#endif\n#endif\n}\n\nstatic void update_decl_size(tree decl)\n{\n\ttree lastval, lastidx, field, init, type, flexsize;\n\tunsigned HOST_WIDE_INT len;\n\n\ttype = TREE_TYPE(decl);\n\n\tif (!lookup_attribute(\"has_flexarray\", TYPE_ATTRIBUTES(type)))\n\t\treturn;\n\n\tinit = DECL_INITIAL(decl);\n\tif (init == NULL_TREE || init == error_mark_node)\n\t\treturn;\n\n\tif (TREE_CODE(init) != CONSTRUCTOR)\n\t\treturn;\n\n\tlen = CONSTRUCTOR_NELTS(init);\n        if (!len)\n\t\treturn;\n\n\tlastval = CONSTRUCTOR_ELT(init, CONSTRUCTOR_NELTS(init) - 1)->value;\n\tlastidx = CONSTRUCTOR_ELT(init, CONSTRUCTOR_NELTS(init) - 1)->index;\n\n\tfor (field = TYPE_FIELDS(TREE_TYPE(decl)); TREE_CHAIN(field); field = TREE_CHAIN(field))\n\t\t;\n\n\tif (lastidx != field)\n\t\treturn;\n\n\tif (TREE_CODE(lastval) != STRING_CST) {\n\t\terror(\"Only string constants are supported as initializers \"\n\t\t      \"for randomized structures with flexible arrays\");\n\t\treturn;\n\t}\n\n\tflexsize = bitsize_int(TREE_STRING_LENGTH(lastval) *\n\t\ttree_to_uhwi(TYPE_SIZE(TREE_TYPE(TREE_TYPE(lastval)))));\n\n\tDECL_SIZE(decl) = size_binop(PLUS_EXPR, TYPE_SIZE(type), flexsize);\n\n\treturn;\n}\n\n\nstatic void randomize_layout_finish_decl(void *event_data, void *data)\n{\n\ttree decl = (tree)event_data;\n\ttree type;\n\n\tif (decl == NULL_TREE || decl == error_mark_node)\n\t\treturn;\n\n\ttype = TREE_TYPE(decl);\n\n\tif (TREE_CODE(decl) != VAR_DECL)\n\t\treturn;\n\n\tif (TREE_CODE(type) != RECORD_TYPE && TREE_CODE(type) != UNION_TYPE)\n\t\treturn;\n\n\tif (!lookup_attribute(\"randomize_performed\", TYPE_ATTRIBUTES(type)))\n\t\treturn;\n\n\tDECL_SIZE(decl) = 0;\n\tDECL_SIZE_UNIT(decl) = 0;\n\tSET_DECL_ALIGN(decl, 0);\n\tSET_DECL_MODE (decl, VOIDmode);\n\tSET_DECL_RTL(decl, 0);\n\tupdate_decl_size(decl);\n\tlayout_decl(decl, 0);\n}\n\nstatic void finish_type(void *event_data, void *data)\n{\n\ttree type = (tree)event_data;\n\n\tif (type == NULL_TREE || type == error_mark_node)\n\t\treturn;\n\n\tif (TREE_CODE(type) != RECORD_TYPE)\n\t\treturn;\n\n\tif (TYPE_FIELDS(type) == NULL_TREE)\n\t\treturn;\n\n\tif (lookup_attribute(\"randomize_considered\", TYPE_ATTRIBUTES(type)))\n\t\treturn;\n\n#ifdef __DEBUG_PLUGIN\n\tfprintf(stderr, \"Calling randomize_type on %s\\n\", ORIG_TYPE_NAME(type));\n#endif\n#ifdef __DEBUG_VERBOSE\n\tdebug_tree(type);\n#endif\n\trandomize_type(type);\n\n\treturn;\n}\n\nstatic struct attribute_spec randomize_layout_attr = { };\nstatic struct attribute_spec no_randomize_layout_attr = { };\nstatic struct attribute_spec randomize_considered_attr = { };\nstatic struct attribute_spec randomize_performed_attr = { };\n\nstatic void register_attributes(void *event_data, void *data)\n{\n\trandomize_layout_attr.name\t\t= \"randomize_layout\";\n\trandomize_layout_attr.type_required\t= true;\n\trandomize_layout_attr.handler\t\t= handle_randomize_layout_attr;\n\trandomize_layout_attr.affects_type_identity = true;\n\n\tno_randomize_layout_attr.name\t\t= \"no_randomize_layout\";\n\tno_randomize_layout_attr.type_required\t= true;\n\tno_randomize_layout_attr.handler\t= handle_randomize_layout_attr;\n\tno_randomize_layout_attr.affects_type_identity = true;\n\n\trandomize_considered_attr.name\t\t= \"randomize_considered\";\n\trandomize_considered_attr.type_required\t= true;\n\trandomize_considered_attr.handler\t= handle_randomize_considered_attr;\n\n\trandomize_performed_attr.name\t\t= \"randomize_performed\";\n\trandomize_performed_attr.type_required\t= true;\n\trandomize_performed_attr.handler\t= handle_randomize_performed_attr;\n\n\tregister_attribute(&randomize_layout_attr);\n\tregister_attribute(&no_randomize_layout_attr);\n\tregister_attribute(&randomize_considered_attr);\n\tregister_attribute(&randomize_performed_attr);\n}\n\nstatic void check_bad_casts_in_constructor(tree var, tree init)\n{\n\tunsigned HOST_WIDE_INT idx;\n\ttree field, val;\n\ttree field_type, val_type;\n\n\tFOR_EACH_CONSTRUCTOR_ELT(CONSTRUCTOR_ELTS(init), idx, field, val) {\n\t\tif (TREE_CODE(val) == CONSTRUCTOR) {\n\t\t\tcheck_bad_casts_in_constructor(var, val);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (field == NULL_TREE)\n\t\t\tcontinue;\n\t\tfield_type = TREE_TYPE(field);\n\t\tval_type = TREE_TYPE(val);\n\n\t\tif (TREE_CODE(field_type) != POINTER_TYPE || TREE_CODE(val_type) != POINTER_TYPE)\n\t\t\tcontinue;\n\n\t\tif (field_type == val_type)\n\t\t\tcontinue;\n\n\t\tfield_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(field_type))));\n\t\tval_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(val_type))));\n\n\t\tif (field_type == void_type_node)\n\t\t\tcontinue;\n\t\tif (field_type == val_type)\n\t\t\tcontinue;\n\t\tif (TREE_CODE(val_type) != RECORD_TYPE)\n\t\t\tcontinue;\n\n\t\tif (!lookup_attribute(\"randomize_performed\", TYPE_ATTRIBUTES(val_type)))\n\t\t\tcontinue;\n\t\tMISMATCH(DECL_SOURCE_LOCATION(var), \"constructor\\n\", TYPE_MAIN_VARIANT(field_type), TYPE_MAIN_VARIANT(val_type));\n\t}\n}\n\n \nstatic void check_global_variables(void *event_data, void *data)\n{\n\tstruct varpool_node *node;\n\ttree init;\n\n\tFOR_EACH_VARIABLE(node) {\n\t\ttree var = NODE_DECL(node);\n\t\tinit = DECL_INITIAL(var);\n\t\tif (init == NULL_TREE)\n\t\t\tcontinue;\n\n\t\tif (TREE_CODE(init) != CONSTRUCTOR)\n\t\t\tcontinue;\n\n\t\tcheck_bad_casts_in_constructor(var, init);\n\t}\n}\n\nstatic bool dominated_by_is_err(const_tree rhs, basic_block bb)\n{\n\tbasic_block dom;\n\tgimple dom_stmt;\n\tgimple call_stmt;\n\tconst_tree dom_lhs;\n\tconst_tree poss_is_err_cond;\n\tconst_tree poss_is_err_func;\n\tconst_tree is_err_arg;\n\n\tdom = get_immediate_dominator(CDI_DOMINATORS, bb);\n\tif (!dom)\n\t\treturn false;\n\n\tdom_stmt = last_stmt(dom);\n\tif (!dom_stmt)\n\t\treturn false;\n\n\tif (gimple_code(dom_stmt) != GIMPLE_COND)\n\t\treturn false;\n\n\tif (gimple_cond_code(dom_stmt) != NE_EXPR)\n\t\treturn false;\n\n\tif (!integer_zerop(gimple_cond_rhs(dom_stmt)))\n\t\treturn false;\n\n\tposs_is_err_cond = gimple_cond_lhs(dom_stmt);\n\n\tif (TREE_CODE(poss_is_err_cond) != SSA_NAME)\n\t\treturn false;\n\n\tcall_stmt = SSA_NAME_DEF_STMT(poss_is_err_cond);\n\n\tif (gimple_code(call_stmt) != GIMPLE_CALL)\n\t\treturn false;\n\n\tdom_lhs = gimple_get_lhs(call_stmt);\n\tposs_is_err_func = gimple_call_fndecl(call_stmt);\n\tif (!poss_is_err_func)\n\t\treturn false;\n\tif (dom_lhs != poss_is_err_cond)\n\t\treturn false;\n\tif (strcmp(DECL_NAME_POINTER(poss_is_err_func), \"IS_ERR\"))\n\t\treturn false;\n\n\tis_err_arg = gimple_call_arg(call_stmt, 0);\n\tif (!is_err_arg)\n\t\treturn false;\n\n\tif (is_err_arg != rhs)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void handle_local_var_initializers(void)\n{\n\ttree var;\n\tunsigned int i;\n\n\tFOR_EACH_LOCAL_DECL(cfun, i, var) {\n\t\ttree init = DECL_INITIAL(var);\n\t\tif (!init)\n\t\t\tcontinue;\n\t\tif (TREE_CODE(init) != CONSTRUCTOR)\n\t\t\tcontinue;\n\t\tcheck_bad_casts_in_constructor(var, init);\n\t}\n}\n\n \nstatic unsigned int find_bad_casts_execute(void)\n{\n\tbasic_block bb;\n\n\thandle_local_var_initializers();\n\n\tFOR_EACH_BB_FN(bb, cfun) {\n\t\tgimple_stmt_iterator gsi;\n\n\t\tfor (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {\n\t\t\tgimple stmt;\n\t\t\tconst_tree lhs;\n\t\t\tconst_tree lhs_type;\n\t\t\tconst_tree rhs1;\n\t\t\tconst_tree rhs_type;\n\t\t\tconst_tree ptr_lhs_type;\n\t\t\tconst_tree ptr_rhs_type;\n\t\t\tconst_tree op0;\n\t\t\tconst_tree op0_type;\n\t\t\tenum tree_code rhs_code;\n\n\t\t\tstmt = gsi_stmt(gsi);\n\n#ifdef __DEBUG_PLUGIN\n#ifdef __DEBUG_VERBOSE\n\t\t\tdebug_gimple_stmt(stmt);\n\t\t\tdebug_tree(gimple_get_lhs(stmt));\n#endif\n#endif\n\n\t\t\tif (gimple_code(stmt) != GIMPLE_ASSIGN)\n\t\t\t\tcontinue;\n\n#ifdef __DEBUG_PLUGIN\n#ifdef __DEBUG_VERBOSE\n\t\t\tdebug_tree(gimple_assign_rhs1(stmt));\n#endif\n#endif\n\n\n\t\t\trhs_code = gimple_assign_rhs_code(stmt);\n\n\t\t\tif (rhs_code != ADDR_EXPR && rhs_code != SSA_NAME)\n\t\t\t\tcontinue;\n\n\t\t\tlhs = gimple_get_lhs(stmt);\n\t\t\tlhs_type = TREE_TYPE(lhs);\n\t\t\trhs1 = gimple_assign_rhs1(stmt);\n\t\t\trhs_type = TREE_TYPE(rhs1);\n\n\t\t\tif (TREE_CODE(rhs_type) != POINTER_TYPE ||\n\t\t\t    TREE_CODE(lhs_type) != POINTER_TYPE)\n\t\t\t\tcontinue;\n\n\t\t\tptr_lhs_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(lhs_type))));\n\t\t\tptr_rhs_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(rhs_type))));\n\n\t\t\tif (ptr_rhs_type == void_type_node)\n\t\t\t\tcontinue;\n\n\t\t\tif (ptr_lhs_type == void_type_node)\n\t\t\t\tcontinue;\n\n\t\t\tif (dominated_by_is_err(rhs1, bb))\n\t\t\t\tcontinue;\n\n\t\t\tif (TREE_CODE(ptr_rhs_type) != RECORD_TYPE) {\n#ifndef __DEBUG_PLUGIN\n\t\t\t\tif (lookup_attribute(\"randomize_performed\", TYPE_ATTRIBUTES(ptr_lhs_type)))\n#endif\n\t\t\t\tMISMATCH(gimple_location(stmt), \"rhs\", ptr_lhs_type, ptr_rhs_type);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rhs_code == SSA_NAME && ptr_lhs_type == ptr_rhs_type)\n\t\t\t\tcontinue;\n\n\t\t\tif (rhs_code == ADDR_EXPR) {\n\t\t\t\top0 = TREE_OPERAND(rhs1, 0);\n\n\t\t\t\tif (op0 == NULL_TREE)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (TREE_CODE(op0) != VAR_DECL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\top0_type = TYPE_MAIN_VARIANT(strip_array_types(TYPE_MAIN_VARIANT(TREE_TYPE(op0))));\n\t\t\t\tif (op0_type == ptr_lhs_type)\n\t\t\t\t\tcontinue;\n\n#ifndef __DEBUG_PLUGIN\n\t\t\t\tif (lookup_attribute(\"randomize_performed\", TYPE_ATTRIBUTES(op0_type)))\n#endif\n\t\t\t\tMISMATCH(gimple_location(stmt), \"op0\", ptr_lhs_type, op0_type);\n\t\t\t} else {\n\t\t\t\tconst_tree ssa_name_var = SSA_NAME_VAR(rhs1);\n\t\t\t\t \n\t\t\t\tif (ssa_name_var != NULL_TREE && DECL_NAME(ssa_name_var) && \n\t\t\t\t    !strcmp((const char *)DECL_NAME_POINTER(ssa_name_var), \"__mptr\"))\n\t\t\t\t\tcontinue;\n#ifndef __DEBUG_PLUGIN\n\t\t\t\tif (lookup_attribute(\"randomize_performed\", TYPE_ATTRIBUTES(ptr_rhs_type)))\n#endif\n\t\t\t\tMISMATCH(gimple_location(stmt), \"ssa\", ptr_lhs_type, ptr_rhs_type);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define PASS_NAME find_bad_casts\n#define NO_GATE\n#define TODO_FLAGS_FINISH TODO_dump_func\n#include \"gcc-generate-gimple-pass.h\"\n\n__visible int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)\n{\n\tint i;\n\tconst char * const plugin_name = plugin_info->base_name;\n\tconst int argc = plugin_info->argc;\n\tconst struct plugin_argument * const argv = plugin_info->argv;\n\tbool enable = true;\n\tint obtained_seed = 0;\n\tstruct register_pass_info find_bad_casts_pass_info;\n\n\tfind_bad_casts_pass_info.pass\t\t\t= make_find_bad_casts_pass();\n\tfind_bad_casts_pass_info.reference_pass_name\t= \"ssa\";\n\tfind_bad_casts_pass_info.ref_pass_instance_number\t= 1;\n\tfind_bad_casts_pass_info.pos_op\t\t\t= PASS_POS_INSERT_AFTER;\n\n\tif (!plugin_default_version_check(version, &gcc_version)) {\n\t\terror(G_(\"incompatible gcc/plugin versions\"));\n\t\treturn 1;\n\t}\n\n\tif (strncmp(lang_hooks.name, \"GNU C\", 5) && !strncmp(lang_hooks.name, \"GNU C+\", 6)) {\n\t\tinform(UNKNOWN_LOCATION, G_(\"%s supports C only, not %s\"), plugin_name, lang_hooks.name);\n\t\tenable = false;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (!strcmp(argv[i].key, \"disable\")) {\n\t\t\tenable = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(argv[i].key, \"performance-mode\")) {\n\t\t\tperformance_mode = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terror(G_(\"unknown option '-fplugin-arg-%s-%s'\"), plugin_name, argv[i].key);\n\t}\n\n\tif (strlen(randstruct_seed) != 64) {\n\t\terror(G_(\"invalid seed value supplied for %s plugin\"), plugin_name);\n\t\treturn 1;\n\t}\n\tobtained_seed = sscanf(randstruct_seed, \"%016llx%016llx%016llx%016llx\",\n\t\t&shuffle_seed[0], &shuffle_seed[1], &shuffle_seed[2], &shuffle_seed[3]);\n\tif (obtained_seed != 4) {\n\t\terror(G_(\"Invalid seed supplied for %s plugin\"), plugin_name);\n\t\treturn 1;\n\t}\n\n\tregister_callback(plugin_name, PLUGIN_INFO, NULL, &randomize_layout_plugin_info);\n\tif (enable) {\n\t\tregister_callback(plugin_name, PLUGIN_ALL_IPA_PASSES_START, check_global_variables, NULL);\n\t\tregister_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &find_bad_casts_pass_info);\n\t\tregister_callback(plugin_name, PLUGIN_FINISH_TYPE, finish_type, NULL);\n\t\tregister_callback(plugin_name, PLUGIN_FINISH_DECL, randomize_layout_finish_decl, NULL);\n\t}\n\tregister_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes, NULL);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}