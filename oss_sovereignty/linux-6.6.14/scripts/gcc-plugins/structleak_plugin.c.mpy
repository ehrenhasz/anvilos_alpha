{
  "module_name": "structleak_plugin.c",
  "hash_id": "524e78bc405913cab61a1731c580ff942b4c4e8ee4d8cceef5c8d14e95d6085e",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gcc-plugins/structleak_plugin.c",
  "human_readable_source": "\n \n\n#include \"gcc-common.h\"\n\n \n#define TYPE_USERSPACE(TYPE) TYPE_LANG_FLAG_5(TYPE)\n\n__visible int plugin_is_GPL_compatible;\n\nstatic struct plugin_info structleak_plugin_info = {\n\t.version\t= PLUGIN_VERSION,\n\t.help\t\t= \"disable\\tdo not activate plugin\\n\"\n\t\t\t  \"byref\\tinit structs passed by reference\\n\"\n\t\t\t  \"byref-all\\tinit anything passed by reference\\n\"\n\t\t\t  \"verbose\\tprint all initialized variables\\n\",\n};\n\n#define BYREF_STRUCT\t1\n#define BYREF_ALL\t2\n\nstatic bool verbose;\nstatic int byref;\n\nstatic tree handle_user_attribute(tree *node, tree name, tree args, int flags, bool *no_add_attrs)\n{\n\t*no_add_attrs = true;\n\n\t \n\tif (TREE_CODE(*node) != FIELD_DECL)\n\t\treturn NULL_TREE;\n\n\t*no_add_attrs = false;\n\treturn NULL_TREE;\n}\n\nstatic struct attribute_spec user_attr = { };\n\nstatic void register_attributes(void *event_data, void *data)\n{\n\tuser_attr.name\t\t\t= \"user\";\n\tuser_attr.handler\t\t= handle_user_attribute;\n\tuser_attr.affects_type_identity\t= true;\n\n\tregister_attribute(&user_attr);\n}\n\nstatic tree get_field_type(tree field)\n{\n\treturn strip_array_types(TREE_TYPE(field));\n}\n\nstatic bool is_userspace_type(tree type)\n{\n\ttree field;\n\n\tfor (field = TYPE_FIELDS(type); field; field = TREE_CHAIN(field)) {\n\t\ttree fieldtype = get_field_type(field);\n\t\tenum tree_code code = TREE_CODE(fieldtype);\n\n\t\tif (code == RECORD_TYPE || code == UNION_TYPE)\n\t\t\tif (is_userspace_type(fieldtype))\n\t\t\t\treturn true;\n\n\t\tif (lookup_attribute(\"user\", DECL_ATTRIBUTES(field)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void finish_type(void *event_data, void *data)\n{\n\ttree type = (tree)event_data;\n\n\tif (type == NULL_TREE || type == error_mark_node)\n\t\treturn;\n\n\tif (TREE_CODE(type) == ENUMERAL_TYPE)\n\t\treturn;\n\n\tif (TYPE_USERSPACE(type))\n\t\treturn;\n\n\tif (is_userspace_type(type))\n\t\tTYPE_USERSPACE(type) = 1;\n}\n\nstatic void initialize(tree var)\n{\n\tbasic_block bb;\n\tgimple_stmt_iterator gsi;\n\ttree initializer;\n\tgimple init_stmt;\n\ttree type;\n\n\t \n\tbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\n\n\t \n\tfor (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {\n\t\tgimple stmt = gsi_stmt(gsi);\n\t\ttree rhs1;\n\n\t\t \n\t\tif (!gimple_assign_single_p(stmt))\n\t\t\tcontinue;\n\t\trhs1 = gimple_assign_rhs1(stmt);\n\t\t \n\t\tif (TREE_CLOBBER_P(rhs1))\n\t\t\tcontinue;\n\t\t \n\t\tif (gimple_get_lhs(stmt) != var)\n\t\t\tcontinue;\n\t\t \n\t\tif (TREE_CODE(rhs1) == CONSTRUCTOR)\n\t\t\treturn;\n\t}\n\n\t \n\tif (verbose)\n\t\tinform(DECL_SOURCE_LOCATION(var),\n\t\t\t\"%s variable will be forcibly initialized\",\n\t\t\t(byref && TREE_ADDRESSABLE(var)) ? \"byref\"\n\t\t\t\t\t\t\t : \"userspace\");\n\n\t \n\ttype = TREE_TYPE(var);\n\tif (AGGREGATE_TYPE_P(type))\n\t\tinitializer = build_constructor(type, NULL);\n\telse\n\t\tinitializer = fold_convert(type, integer_zero_node);\n\n\t \n\tinit_stmt = gimple_build_assign(var, initializer);\n\tgsi = gsi_after_labels(single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\tgsi_insert_before(&gsi, init_stmt, GSI_NEW_STMT);\n\tupdate_stmt(init_stmt);\n}\n\nstatic unsigned int structleak_execute(void)\n{\n\tbasic_block bb;\n\ttree var;\n\tunsigned int i;\n\n\t \n\tgcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\tbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\n\tif (!single_pred_p(bb)) {\n\t\tsplit_edge(single_succ_edge(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\t\tgcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\t}\n\n\t \n\tFOR_EACH_LOCAL_DECL(cfun, i, var) {\n\t\ttree type = TREE_TYPE(var);\n\n\t\tgcc_assert(DECL_P(var));\n\t\tif (!auto_var_in_fn_p(var, current_function_decl))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (byref != BYREF_ALL && TREE_CODE(type) != RECORD_TYPE && TREE_CODE(type) != UNION_TYPE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (TYPE_USERSPACE(type) ||\n\t\t    (byref && TREE_ADDRESSABLE(var)))\n\t\t\tinitialize(var);\n\t}\n\n\treturn 0;\n}\n\n#define PASS_NAME structleak\n#define NO_GATE\n#define PROPERTIES_REQUIRED PROP_cfg\n#define TODO_FLAGS_FINISH TODO_verify_il | TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_remove_unused_locals | TODO_update_ssa | TODO_ggc_collect | TODO_verify_flow\n#include \"gcc-generate-gimple-pass.h\"\n\n__visible int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)\n{\n\tint i;\n\tconst char * const plugin_name = plugin_info->base_name;\n\tconst int argc = plugin_info->argc;\n\tconst struct plugin_argument * const argv = plugin_info->argv;\n\tbool enable = true;\n\n\tPASS_INFO(structleak, \"early_optimizations\", 1, PASS_POS_INSERT_BEFORE);\n\n\tif (!plugin_default_version_check(version, &gcc_version)) {\n\t\terror(G_(\"incompatible gcc/plugin versions\"));\n\t\treturn 1;\n\t}\n\n\tif (strncmp(lang_hooks.name, \"GNU C\", 5) && !strncmp(lang_hooks.name, \"GNU C+\", 6)) {\n\t\tinform(UNKNOWN_LOCATION, G_(\"%s supports C only, not %s\"), plugin_name, lang_hooks.name);\n\t\tenable = false;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (!strcmp(argv[i].key, \"disable\")) {\n\t\t\tenable = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(argv[i].key, \"verbose\")) {\n\t\t\tverbose = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(argv[i].key, \"byref\")) {\n\t\t\tbyref = BYREF_STRUCT;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(argv[i].key, \"byref-all\")) {\n\t\t\tbyref = BYREF_ALL;\n\t\t\tcontinue;\n\t\t}\n\t\terror(G_(\"unknown option '-fplugin-arg-%s-%s'\"), plugin_name, argv[i].key);\n\t}\n\n\tregister_callback(plugin_name, PLUGIN_INFO, NULL, &structleak_plugin_info);\n\tif (enable) {\n\t\tregister_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &structleak_pass_info);\n\t\tregister_callback(plugin_name, PLUGIN_FINISH_TYPE, finish_type, NULL);\n\t}\n\tregister_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes, NULL);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}