{
  "module_name": "stackleak_plugin.c",
  "hash_id": "097103554e71cfd79096265274eeaab0f04d2873e67db86e3af7fd506608ae79",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gcc-plugins/stackleak_plugin.c",
  "human_readable_source": "\n \n\n#include \"gcc-common.h\"\n\n__visible int plugin_is_GPL_compatible;\n\nstatic int track_frame_size = -1;\nstatic bool build_for_x86 = false;\nstatic const char track_function[] = \"stackleak_track_stack\";\nstatic bool disable = false;\nstatic bool verbose = false;\n\n \nstatic GTY(()) tree track_function_decl;\n\nstatic struct plugin_info stackleak_plugin_info = {\n\t.version = PLUGIN_VERSION,\n\t.help = \"track-min-size=nn\\ttrack stack for functions with a stack frame size >= nn bytes\\n\"\n\t\t\"arch=target_arch\\tspecify target build arch\\n\"\n\t\t\"disable\\t\\tdo not activate the plugin\\n\"\n\t\t\"verbose\\t\\tprint info about the instrumentation\\n\"\n};\n\nstatic void add_stack_tracking_gcall(gimple_stmt_iterator *gsi, bool after)\n{\n\tgimple stmt;\n\tgcall *gimple_call;\n\tcgraph_node_ptr node;\n\tbasic_block bb;\n\n\t \n\tstmt = gimple_build_call(track_function_decl, 0);\n\tgimple_call = as_a_gcall(stmt);\n\tif (after)\n\t\tgsi_insert_after(gsi, gimple_call, GSI_CONTINUE_LINKING);\n\telse\n\t\tgsi_insert_before(gsi, gimple_call, GSI_SAME_STMT);\n\n\t \n\tbb = gimple_bb(gimple_call);\n\tnode = cgraph_get_create_node(track_function_decl);\n\tgcc_assert(node);\n\tcgraph_create_edge(cgraph_get_node(current_function_decl), node,\n\t\t\tgimple_call, bb->count,\n\t\t\tcompute_call_stmt_bb_frequency(current_function_decl, bb));\n}\n\nstatic bool is_alloca(gimple stmt)\n{\n\tif (gimple_call_builtin_p(stmt, BUILT_IN_ALLOCA))\n\t\treturn true;\n\n\tif (gimple_call_builtin_p(stmt, BUILT_IN_ALLOCA_WITH_ALIGN))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic tree get_current_stack_pointer_decl(void)\n{\n\tvarpool_node_ptr node;\n\n\tFOR_EACH_VARIABLE(node) {\n\t\ttree var = NODE_DECL(node);\n\t\ttree name = DECL_NAME(var);\n\n\t\tif (DECL_NAME_LENGTH(var) != sizeof(\"current_stack_pointer\") - 1)\n\t\t\tcontinue;\n\n\t\tif (strcmp(IDENTIFIER_POINTER(name), \"current_stack_pointer\"))\n\t\t\tcontinue;\n\n\t\treturn var;\n\t}\n\n\tif (verbose) {\n\t\tfprintf(stderr, \"stackleak: missing current_stack_pointer in %s()\\n\",\n\t\t\tDECL_NAME_POINTER(current_function_decl));\n\t}\n\treturn NULL_TREE;\n}\n\nstatic void add_stack_tracking_gasm(gimple_stmt_iterator *gsi, bool after)\n{\n\tgasm *asm_call = NULL;\n\ttree sp_decl, input;\n\tvec<tree, va_gc> *inputs = NULL;\n\n\t \n\tgcc_assert(build_for_x86);\n\n\t \n\tsp_decl = get_current_stack_pointer_decl();\n\tif (sp_decl == NULL_TREE) {\n\t\tadd_stack_tracking_gcall(gsi, after);\n\t\treturn;\n\t}\n\tinput = build_tree_list(NULL_TREE, build_const_char_string(2, \"r\"));\n\tinput = chainon(NULL_TREE, build_tree_list(input, sp_decl));\n\tvec_safe_push(inputs, input);\n\tasm_call = gimple_build_asm_vec(\"call stackleak_track_stack\",\n\t\t\t\t\tinputs, NULL, NULL, NULL);\n\tgimple_asm_set_volatile(asm_call, true);\n\tif (after)\n\t\tgsi_insert_after(gsi, asm_call, GSI_CONTINUE_LINKING);\n\telse\n\t\tgsi_insert_before(gsi, asm_call, GSI_SAME_STMT);\n\tupdate_stmt(asm_call);\n}\n\nstatic void add_stack_tracking(gimple_stmt_iterator *gsi, bool after)\n{\n\t \n\tif (lookup_attribute_spec(get_identifier(\"no_caller_saved_registers\")))\n\t\tadd_stack_tracking_gasm(gsi, after);\n\telse\n\t\tadd_stack_tracking_gcall(gsi, after);\n}\n\n \nstatic unsigned int stackleak_instrument_execute(void)\n{\n\tbasic_block bb, entry_bb;\n\tbool prologue_instrumented = false, is_leaf = true;\n\tgimple_stmt_iterator gsi = { 0 };\n\n\t \n\tgcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\tentry_bb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\n\n\t \n\tFOR_EACH_BB_FN(bb, cfun) {\n\t\tfor (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {\n\t\t\tgimple stmt;\n\n\t\t\tstmt = gsi_stmt(gsi);\n\n\t\t\t \n\t\t\tif (is_gimple_call(stmt))\n\t\t\t\tis_leaf = false;\n\n\t\t\tif (!is_alloca(stmt))\n\t\t\t\tcontinue;\n\n\t\t\tif (verbose) {\n\t\t\t\tfprintf(stderr, \"stackleak: be careful, alloca() in %s()\\n\",\n\t\t\t\t\tDECL_NAME_POINTER(current_function_decl));\n\t\t\t}\n\n\t\t\t \n\t\t\tadd_stack_tracking(&gsi, true);\n\t\t\tif (bb == entry_bb)\n\t\t\t\tprologue_instrumented = true;\n\t\t}\n\t}\n\n\tif (prologue_instrumented)\n\t\treturn 0;\n\n\t \n\tif (is_leaf &&\n\t    !TREE_PUBLIC(current_function_decl) &&\n\t    DECL_DECLARED_INLINE_P(current_function_decl)) {\n\t\treturn 0;\n\t}\n\n\tif (is_leaf &&\n\t    !strncmp(IDENTIFIER_POINTER(DECL_NAME(current_function_decl)),\n\t\t     \"_paravirt_\", 10)) {\n\t\treturn 0;\n\t}\n\n\t \n\tbb = entry_bb;\n\tif (!single_pred_p(bb)) {\n\t\t \n\t\tsplit_edge(single_succ_edge(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\t\tgcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\t\tbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\n\t}\n\tgsi = gsi_after_labels(bb);\n\tadd_stack_tracking(&gsi, false);\n\n\treturn 0;\n}\n\nstatic bool large_stack_frame(void)\n{\n#if BUILDING_GCC_VERSION >= 8000\n\treturn maybe_ge(get_frame_size(), track_frame_size);\n#else\n\treturn (get_frame_size() >= track_frame_size);\n#endif\n}\n\nstatic void remove_stack_tracking_gcall(void)\n{\n\trtx_insn *insn, *next;\n\n\t \n\tfor (insn = get_insns(); insn; insn = next) {\n\t\trtx body;\n\n\t\tnext = NEXT_INSN(insn);\n\n\t\t \n\t\tif (!CALL_P(insn))\n\t\t\tcontinue;\n\n\t\t \n\t\tbody = PATTERN(insn);\n\n\t\tif (GET_CODE(body) == PARALLEL)\n\t\t\tbody = XVECEXP(body, 0, 0);\n\n\t\tif (GET_CODE(body) != CALL)\n\t\t\tcontinue;\n\n\t\t \n\t\tbody = XEXP(body, 0);\n\t\tif (GET_CODE(body) != MEM)\n\t\t\tcontinue;\n\n\t\tbody = XEXP(body, 0);\n\t\tif (GET_CODE(body) != SYMBOL_REF)\n\t\t\tcontinue;\n\n\t\tif (SYMBOL_REF_DECL(body) != track_function_decl)\n\t\t\tcontinue;\n\n\t\t \n\t\tdelete_insn_and_edges(insn);\n#if BUILDING_GCC_VERSION < 8000\n\t\tif (GET_CODE(next) == NOTE &&\n\t\t    NOTE_KIND(next) == NOTE_INSN_CALL_ARG_LOCATION) {\n\t\t\tinsn = next;\n\t\t\tnext = NEXT_INSN(insn);\n\t\t\tdelete_insn_and_edges(insn);\n\t\t}\n#endif\n\t}\n}\n\nstatic bool remove_stack_tracking_gasm(void)\n{\n\tbool removed = false;\n\trtx_insn *insn, *next;\n\n\t \n\tgcc_assert(build_for_x86);\n\n\t \n\tfor (insn = get_insns(); insn; insn = next) {\n\t\trtx body;\n\n\t\tnext = NEXT_INSN(insn);\n\n\t\t \n\t\tif (!NONJUMP_INSN_P(insn))\n\t\t\tcontinue;\n\n\t\t \n\t\tbody = PATTERN(insn);\n\n\t\tif (GET_CODE(body) != PARALLEL)\n\t\t\tcontinue;\n\n\t\tbody = XVECEXP(body, 0, 0);\n\n\t\tif (GET_CODE(body) != ASM_OPERANDS)\n\t\t\tcontinue;\n\n\t\tif (strcmp(ASM_OPERANDS_TEMPLATE(body),\n\t\t\t\t\t\t\"call stackleak_track_stack\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelete_insn_and_edges(insn);\n\t\tgcc_assert(!removed);\n\t\tremoved = true;\n\t}\n\n\treturn removed;\n}\n\n \nstatic unsigned int stackleak_cleanup_execute(void)\n{\n\tconst char *fn = DECL_NAME_POINTER(current_function_decl);\n\tbool removed = false;\n\n\t \n\tif (cfun->calls_alloca) {\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"stackleak: instrument %s(): calls_alloca\\n\", fn);\n\t\treturn 0;\n\t}\n\n\t \n\tif (large_stack_frame()) {\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"stackleak: instrument %s()\\n\", fn);\n\t\treturn 0;\n\t}\n\n\tif (lookup_attribute_spec(get_identifier(\"no_caller_saved_registers\")))\n\t\tremoved = remove_stack_tracking_gasm();\n\n\tif (!removed)\n\t\tremove_stack_tracking_gcall();\n\n\treturn 0;\n}\n\n \nstatic inline bool string_equal(tree node, const char *string, int length)\n{\n\tif (TREE_STRING_LENGTH(node) < length)\n\t\treturn false;\n\tif (TREE_STRING_LENGTH(node) > length + 1)\n\t\treturn false;\n\tif (TREE_STRING_LENGTH(node) == length + 1 &&\n\t    TREE_STRING_POINTER(node)[length] != '\\0')\n\t\treturn false;\n\treturn !memcmp(TREE_STRING_POINTER(node), string, length);\n}\n#define STRING_EQUAL(node, str)\tstring_equal(node, str, strlen(str))\n\nstatic bool stackleak_gate(void)\n{\n\ttree section;\n\n\tsection = lookup_attribute(\"section\",\n\t\t\t\t   DECL_ATTRIBUTES(current_function_decl));\n\tif (section && TREE_VALUE(section)) {\n\t\tsection = TREE_VALUE(TREE_VALUE(section));\n\n\t\tif (STRING_EQUAL(section, \".init.text\"))\n\t\t\treturn false;\n\t\tif (STRING_EQUAL(section, \".devinit.text\"))\n\t\t\treturn false;\n\t\tif (STRING_EQUAL(section, \".cpuinit.text\"))\n\t\t\treturn false;\n\t\tif (STRING_EQUAL(section, \".meminit.text\"))\n\t\t\treturn false;\n\t\tif (STRING_EQUAL(section, \".noinstr.text\"))\n\t\t\treturn false;\n\t\tif (STRING_EQUAL(section, \".entry.text\"))\n\t\t\treturn false;\n\t}\n\n\treturn track_frame_size >= 0;\n}\n\n \nstatic void stackleak_start_unit(void *gcc_data __unused,\n\t\t\t\t void *user_data __unused)\n{\n\ttree fntype;\n\n\t \n\tfntype = build_function_type_list(void_type_node, NULL_TREE);\n\ttrack_function_decl = build_fn_decl(track_function, fntype);\n\tDECL_ASSEMBLER_NAME(track_function_decl);  \n\tTREE_PUBLIC(track_function_decl) = 1;\n\tTREE_USED(track_function_decl) = 1;\n\tDECL_EXTERNAL(track_function_decl) = 1;\n\tDECL_ARTIFICIAL(track_function_decl) = 1;\n\tDECL_PRESERVE_P(track_function_decl) = 1;\n}\n\n \nstatic bool stackleak_instrument_gate(void)\n{\n\treturn stackleak_gate();\n}\n\n#define PASS_NAME stackleak_instrument\n#define PROPERTIES_REQUIRED PROP_gimple_leh | PROP_cfg\n#define TODO_FLAGS_START TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts\n#define TODO_FLAGS_FINISH TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func \\\n\t\t\t| TODO_update_ssa | TODO_rebuild_cgraph_edges\n#include \"gcc-generate-gimple-pass.h\"\n\nstatic bool stackleak_cleanup_gate(void)\n{\n\treturn stackleak_gate();\n}\n\n#define PASS_NAME stackleak_cleanup\n#define TODO_FLAGS_FINISH TODO_dump_func\n#include \"gcc-generate-rtl-pass.h\"\n\n \n__visible int plugin_init(struct plugin_name_args *plugin_info,\n\t\t\t  struct plugin_gcc_version *version)\n{\n\tconst char * const plugin_name = plugin_info->base_name;\n\tconst int argc = plugin_info->argc;\n\tconst struct plugin_argument * const argv = plugin_info->argv;\n\tint i = 0;\n\n\t \n\tstatic const struct ggc_root_tab gt_ggc_r_gt_stackleak[] = {\n\t\t{\n\t\t\t.base = &track_function_decl,\n\t\t\t.nelt = 1,\n\t\t\t.stride = sizeof(track_function_decl),\n\t\t\t.cb = &gt_ggc_mx_tree_node,\n\t\t\t.pchw = &gt_pch_nx_tree_node\n\t\t},\n\t\tLAST_GGC_ROOT_TAB\n\t};\n\n\t \n\tPASS_INFO(stackleak_instrument, \"optimized\", 1,\n\t\t\t\t\t\tPASS_POS_INSERT_BEFORE);\n\n\t \n\tPASS_INFO(stackleak_cleanup, \"*free_cfg\", 1, PASS_POS_INSERT_BEFORE);\n\n\tif (!plugin_default_version_check(version, &gcc_version)) {\n\t\terror(G_(\"incompatible gcc/plugin versions\"));\n\t\treturn 1;\n\t}\n\n\t \n\tfor (i = 0; i < argc; i++) {\n\t\tif (!strcmp(argv[i].key, \"track-min-size\")) {\n\t\t\tif (!argv[i].value) {\n\t\t\t\terror(G_(\"no value supplied for option '-fplugin-arg-%s-%s'\"),\n\t\t\t\t\tplugin_name, argv[i].key);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\ttrack_frame_size = atoi(argv[i].value);\n\t\t\tif (track_frame_size < 0) {\n\t\t\t\terror(G_(\"invalid option argument '-fplugin-arg-%s-%s=%s'\"),\n\t\t\t\t\tplugin_name, argv[i].key, argv[i].value);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (!strcmp(argv[i].key, \"arch\")) {\n\t\t\tif (!argv[i].value) {\n\t\t\t\terror(G_(\"no value supplied for option '-fplugin-arg-%s-%s'\"),\n\t\t\t\t\tplugin_name, argv[i].key);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (!strcmp(argv[i].value, \"x86\"))\n\t\t\t\tbuild_for_x86 = true;\n\t\t} else if (!strcmp(argv[i].key, \"disable\")) {\n\t\t\tdisable = true;\n\t\t} else if (!strcmp(argv[i].key, \"verbose\")) {\n\t\t\tverbose = true;\n\t\t} else {\n\t\t\terror(G_(\"unknown option '-fplugin-arg-%s-%s'\"),\n\t\t\t\t\tplugin_name, argv[i].key);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (disable) {\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"stackleak: disabled for this translation unit\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tregister_callback(plugin_name, PLUGIN_INFO, NULL,\n\t\t\t\t\t\t&stackleak_plugin_info);\n\n\t \n\tregister_callback(plugin_name, PLUGIN_START_UNIT,\n\t\t\t\t\t&stackleak_start_unit, NULL);\n\n\t \n\tregister_callback(plugin_name, PLUGIN_REGISTER_GGC_ROOTS, NULL,\n\t\t\t\t\t(void *)&gt_ggc_r_gt_stackleak);\n\n\t \n\tregister_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n\t\t\t\t\t&stackleak_instrument_pass_info);\n\tregister_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n\t\t\t\t\t&stackleak_cleanup_pass_info);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}