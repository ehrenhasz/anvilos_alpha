{
  "module_name": "latent_entropy_plugin.c",
  "hash_id": "19fb8ef90b53e13c484c517f42a693d642f5e516da5445efb57529503c41dae5",
  "original_prompt": "Ingested from linux-6.6.14/scripts/gcc-plugins/latent_entropy_plugin.c",
  "human_readable_source": "\n \n\n#include \"gcc-common.h\"\n\n__visible int plugin_is_GPL_compatible;\n\nstatic GTY(()) tree latent_entropy_decl;\n\nstatic struct plugin_info latent_entropy_plugin_info = {\n\t.version\t= PLUGIN_VERSION,\n\t.help\t\t= \"disable\\tturn off latent entropy instrumentation\\n\",\n};\n\nstatic unsigned HOST_WIDE_INT deterministic_seed;\nstatic unsigned HOST_WIDE_INT rnd_buf[32];\nstatic size_t rnd_idx = ARRAY_SIZE(rnd_buf);\nstatic int urandom_fd = -1;\n\nstatic unsigned HOST_WIDE_INT get_random_const(void)\n{\n\tif (deterministic_seed) {\n\t\tunsigned HOST_WIDE_INT w = deterministic_seed;\n\t\tw ^= w << 13;\n\t\tw ^= w >> 7;\n\t\tw ^= w << 17;\n\t\tdeterministic_seed = w;\n\t\treturn deterministic_seed;\n\t}\n\n\tif (urandom_fd < 0) {\n\t\turandom_fd = open(\"/dev/urandom\", O_RDONLY);\n\t\tgcc_assert(urandom_fd >= 0);\n\t}\n\tif (rnd_idx >= ARRAY_SIZE(rnd_buf)) {\n\t\tgcc_assert(read(urandom_fd, rnd_buf, sizeof(rnd_buf)) == sizeof(rnd_buf));\n\t\trnd_idx = 0;\n\t}\n\treturn rnd_buf[rnd_idx++];\n}\n\nstatic tree tree_get_random_const(tree type)\n{\n\tunsigned long long mask;\n\n\tmask = 1ULL << (TREE_INT_CST_LOW(TYPE_SIZE(type)) - 1);\n\tmask = 2 * (mask - 1) + 1;\n\n\tif (TYPE_UNSIGNED(type))\n\t\treturn build_int_cstu(type, mask & get_random_const());\n\treturn build_int_cst(type, mask & get_random_const());\n}\n\nstatic tree handle_latent_entropy_attribute(tree *node, tree name,\n\t\t\t\t\t\ttree args __unused,\n\t\t\t\t\t\tint flags __unused,\n\t\t\t\t\t\tbool *no_add_attrs)\n{\n\ttree type;\n\tvec<constructor_elt, va_gc> *vals;\n\n\tswitch (TREE_CODE(*node)) {\n\tdefault:\n\t\t*no_add_attrs = true;\n\t\terror(\"%qE attribute only applies to functions and variables\",\n\t\t\tname);\n\t\tbreak;\n\n\tcase VAR_DECL:\n\t\tif (DECL_INITIAL(*node)) {\n\t\t\t*no_add_attrs = true;\n\t\t\terror(\"variable %qD with %qE attribute must not be initialized\",\n\t\t\t\t*node, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!TREE_STATIC(*node)) {\n\t\t\t*no_add_attrs = true;\n\t\t\terror(\"variable %qD with %qE attribute must not be local\",\n\t\t\t\t*node, name);\n\t\t\tbreak;\n\t\t}\n\n\t\ttype = TREE_TYPE(*node);\n\t\tswitch (TREE_CODE(type)) {\n\t\tdefault:\n\t\t\t*no_add_attrs = true;\n\t\t\terror(\"variable %qD with %qE attribute must be an integer or a fixed length integer array type or a fixed sized structure with integer fields\",\n\t\t\t\t*node, name);\n\t\t\tbreak;\n\n\t\tcase RECORD_TYPE: {\n\t\t\ttree fld, lst = TYPE_FIELDS(type);\n\t\t\tunsigned int nelt = 0;\n\n\t\t\tfor (fld = lst; fld; nelt++, fld = TREE_CHAIN(fld)) {\n\t\t\t\ttree fieldtype;\n\n\t\t\t\tfieldtype = TREE_TYPE(fld);\n\t\t\t\tif (TREE_CODE(fieldtype) == INTEGER_TYPE)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t*no_add_attrs = true;\n\t\t\t\terror(\"structure variable %qD with %qE attribute has a non-integer field %qE\",\n\t\t\t\t\t*node, name, fld);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (fld)\n\t\t\t\tbreak;\n\n\t\t\tvec_alloc(vals, nelt);\n\n\t\t\tfor (fld = lst; fld; fld = TREE_CHAIN(fld)) {\n\t\t\t\ttree random_const, fld_t = TREE_TYPE(fld);\n\n\t\t\t\trandom_const = tree_get_random_const(fld_t);\n\t\t\t\tCONSTRUCTOR_APPEND_ELT(vals, fld, random_const);\n\t\t\t}\n\n\t\t\t \n\t\t\tDECL_INITIAL(*node) = build_constructor(type, vals);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcase INTEGER_TYPE:\n\t\t\tDECL_INITIAL(*node) = tree_get_random_const(type);\n\t\t\tbreak;\n\n\t\tcase ARRAY_TYPE: {\n\t\t\ttree elt_type, array_size, elt_size;\n\t\t\tunsigned int i, nelt;\n\t\t\tHOST_WIDE_INT array_size_int, elt_size_int;\n\n\t\t\telt_type = TREE_TYPE(type);\n\t\t\telt_size = TYPE_SIZE_UNIT(TREE_TYPE(type));\n\t\t\tarray_size = TYPE_SIZE_UNIT(type);\n\n\t\t\tif (TREE_CODE(elt_type) != INTEGER_TYPE || !array_size\n\t\t\t\t|| TREE_CODE(array_size) != INTEGER_CST) {\n\t\t\t\t*no_add_attrs = true;\n\t\t\t\terror(\"array variable %qD with %qE attribute must be a fixed length integer array type\",\n\t\t\t\t\t*node, name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tarray_size_int = TREE_INT_CST_LOW(array_size);\n\t\t\telt_size_int = TREE_INT_CST_LOW(elt_size);\n\t\t\tnelt = array_size_int / elt_size_int;\n\n\t\t\tvec_alloc(vals, nelt);\n\n\t\t\tfor (i = 0; i < nelt; i++) {\n\t\t\t\ttree cst = size_int(i);\n\t\t\t\ttree rand_cst = tree_get_random_const(elt_type);\n\n\t\t\t\tCONSTRUCTOR_APPEND_ELT(vals, cst, rand_cst);\n\t\t\t}\n\n\t\t\t \n\t\t\tDECL_INITIAL(*node) = build_constructor(type, vals);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase FUNCTION_DECL:\n\t\tbreak;\n\t}\n\n\treturn NULL_TREE;\n}\n\nstatic struct attribute_spec latent_entropy_attr = { };\n\nstatic void register_attributes(void *event_data __unused, void *data __unused)\n{\n\tlatent_entropy_attr.name\t\t= \"latent_entropy\";\n\tlatent_entropy_attr.decl_required\t= true;\n\tlatent_entropy_attr.handler\t\t= handle_latent_entropy_attribute;\n\n\tregister_attribute(&latent_entropy_attr);\n}\n\nstatic bool latent_entropy_gate(void)\n{\n\ttree list;\n\n\t \n\tif (TREE_THIS_VOLATILE(current_function_decl))\n\t\treturn false;\n\n\t \n\tif (EDGE_COUNT(EXIT_BLOCK_PTR_FOR_FN(cfun)->preds) == 0)\n\t\treturn false;\n\n\tlist = DECL_ATTRIBUTES(current_function_decl);\n\treturn lookup_attribute(\"latent_entropy\", list) != NULL_TREE;\n}\n\nstatic tree create_var(tree type, const char *name)\n{\n\ttree var;\n\n\tvar = create_tmp_var(type, name);\n\tadd_referenced_var(var);\n\tmark_sym_for_renaming(var);\n\treturn var;\n}\n\n \nstatic enum tree_code get_op(tree *rhs)\n{\n\tstatic enum tree_code op;\n\tunsigned HOST_WIDE_INT random_const;\n\n\trandom_const = get_random_const();\n\n\tswitch (op) {\n\tcase BIT_XOR_EXPR:\n\t\top = PLUS_EXPR;\n\t\tbreak;\n\n\tcase PLUS_EXPR:\n\t\tif (rhs) {\n\t\t\top = LROTATE_EXPR;\n\t\t\t \n\t\t\trandom_const %= TYPE_PRECISION(long_unsigned_type_node);\n\t\t\tbreak;\n\t\t}\n\n\tcase LROTATE_EXPR:\n\tdefault:\n\t\top = BIT_XOR_EXPR;\n\t\tbreak;\n\t}\n\tif (rhs)\n\t\t*rhs = build_int_cstu(long_unsigned_type_node, random_const);\n\treturn op;\n}\n\nstatic gimple create_assign(enum tree_code code, tree lhs, tree op1,\n\t\t\t\ttree op2)\n{\n\treturn gimple_build_assign_with_ops(code, lhs, op1, op2);\n}\n\nstatic void perturb_local_entropy(basic_block bb, tree local_entropy)\n{\n\tgimple_stmt_iterator gsi;\n\tgimple assign;\n\ttree rhs;\n\tenum tree_code op;\n\n\top = get_op(&rhs);\n\tassign = create_assign(op, local_entropy, local_entropy, rhs);\n\tgsi = gsi_after_labels(bb);\n\tgsi_insert_before(&gsi, assign, GSI_NEW_STMT);\n\tupdate_stmt(assign);\n}\n\nstatic void __perturb_latent_entropy(gimple_stmt_iterator *gsi,\n\t\t\t\t\ttree local_entropy)\n{\n\tgimple assign;\n\ttree temp;\n\tenum tree_code op;\n\n\t \n\ttemp = create_var(long_unsigned_type_node, \"temp_latent_entropy\");\n\n\t \n\tadd_referenced_var(latent_entropy_decl);\n\tmark_sym_for_renaming(latent_entropy_decl);\n\tassign = gimple_build_assign(temp, latent_entropy_decl);\n\tgsi_insert_before(gsi, assign, GSI_NEW_STMT);\n\tupdate_stmt(assign);\n\n\t \n\top = get_op(NULL);\n\tassign = create_assign(op, temp, temp, local_entropy);\n\tgsi_insert_after(gsi, assign, GSI_NEW_STMT);\n\tupdate_stmt(assign);\n\n\t \n\tassign = gimple_build_assign(latent_entropy_decl, temp);\n\tgsi_insert_after(gsi, assign, GSI_NEW_STMT);\n\tupdate_stmt(assign);\n}\n\nstatic bool handle_tail_calls(basic_block bb, tree local_entropy)\n{\n\tgimple_stmt_iterator gsi;\n\n\tfor (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {\n\t\tgcall *call;\n\t\tgimple stmt = gsi_stmt(gsi);\n\n\t\tif (!is_gimple_call(stmt))\n\t\t\tcontinue;\n\n\t\tcall = as_a_gcall(stmt);\n\t\tif (!gimple_call_tail_p(call))\n\t\t\tcontinue;\n\n\t\t__perturb_latent_entropy(&gsi, local_entropy);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void perturb_latent_entropy(tree local_entropy)\n{\n\tedge_iterator ei;\n\tedge e, last_bb_e;\n\tbasic_block last_bb;\n\n\tgcc_assert(single_pred_p(EXIT_BLOCK_PTR_FOR_FN(cfun)));\n\tlast_bb_e = single_pred_edge(EXIT_BLOCK_PTR_FOR_FN(cfun));\n\n\tFOR_EACH_EDGE(e, ei, last_bb_e->src->preds) {\n\t\tif (ENTRY_BLOCK_PTR_FOR_FN(cfun) == e->src)\n\t\t\tcontinue;\n\t\tif (EXIT_BLOCK_PTR_FOR_FN(cfun) == e->src)\n\t\t\tcontinue;\n\n\t\thandle_tail_calls(e->src, local_entropy);\n\t}\n\n\tlast_bb = single_pred(EXIT_BLOCK_PTR_FOR_FN(cfun));\n\tif (!handle_tail_calls(last_bb, local_entropy)) {\n\t\tgimple_stmt_iterator gsi = gsi_last_bb(last_bb);\n\n\t\t__perturb_latent_entropy(&gsi, local_entropy);\n\t}\n}\n\nstatic void init_local_entropy(basic_block bb, tree local_entropy)\n{\n\tgimple assign, call;\n\ttree frame_addr, rand_const, tmp, fndecl, udi_frame_addr;\n\tenum tree_code op;\n\tunsigned HOST_WIDE_INT rand_cst;\n\tgimple_stmt_iterator gsi = gsi_after_labels(bb);\n\n\t \n\tframe_addr = create_var(ptr_type_node, \"local_entropy_frameaddr\");\n\n\t \n\tfndecl = builtin_decl_implicit(BUILT_IN_FRAME_ADDRESS);\n\tcall = gimple_build_call(fndecl, 1, integer_zero_node);\n\tgimple_call_set_lhs(call, frame_addr);\n\tgsi_insert_before(&gsi, call, GSI_NEW_STMT);\n\tupdate_stmt(call);\n\n\tudi_frame_addr = fold_convert(long_unsigned_type_node, frame_addr);\n\tassign = gimple_build_assign(local_entropy, udi_frame_addr);\n\tgsi_insert_after(&gsi, assign, GSI_NEW_STMT);\n\tupdate_stmt(assign);\n\n\t \n\ttmp = create_var(long_unsigned_type_node, \"temp_latent_entropy\");\n\n\t \n\tadd_referenced_var(latent_entropy_decl);\n\tmark_sym_for_renaming(latent_entropy_decl);\n\tassign = gimple_build_assign(tmp, latent_entropy_decl);\n\tgsi_insert_after(&gsi, assign, GSI_NEW_STMT);\n\tupdate_stmt(assign);\n\n\t \n\tassign = create_assign(BIT_XOR_EXPR, local_entropy, local_entropy, tmp);\n\tgsi_insert_after(&gsi, assign, GSI_NEW_STMT);\n\tupdate_stmt(assign);\n\n\trand_cst = get_random_const();\n\trand_const = build_int_cstu(long_unsigned_type_node, rand_cst);\n\top = get_op(NULL);\n\tassign = create_assign(op, local_entropy, local_entropy, rand_const);\n\tgsi_insert_after(&gsi, assign, GSI_NEW_STMT);\n\tupdate_stmt(assign);\n}\n\nstatic bool create_latent_entropy_decl(void)\n{\n\tvarpool_node_ptr node;\n\n\tif (latent_entropy_decl != NULL_TREE)\n\t\treturn true;\n\n\tFOR_EACH_VARIABLE(node) {\n\t\ttree name, var = NODE_DECL(node);\n\n\t\tif (DECL_NAME_LENGTH(var) < sizeof(\"latent_entropy\") - 1)\n\t\t\tcontinue;\n\n\t\tname = DECL_NAME(var);\n\t\tif (strcmp(IDENTIFIER_POINTER(name), \"latent_entropy\"))\n\t\t\tcontinue;\n\n\t\tlatent_entropy_decl = var;\n\t\tbreak;\n\t}\n\n\treturn latent_entropy_decl != NULL_TREE;\n}\n\nstatic unsigned int latent_entropy_execute(void)\n{\n\tbasic_block bb;\n\ttree local_entropy;\n\n\tif (!create_latent_entropy_decl())\n\t\treturn 0;\n\n\t \n\tgcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\tbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\n\tif (!single_pred_p(bb)) {\n\t\tsplit_edge(single_succ_edge(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\t\tgcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\n\t\tbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\n\t}\n\n\t \n\tlocal_entropy = create_var(long_unsigned_type_node, \"local_entropy\");\n\n\t \n\tinit_local_entropy(bb, local_entropy);\n\n\tbb = bb->next_bb;\n\n\t \n\twhile (bb != EXIT_BLOCK_PTR_FOR_FN(cfun)) {\n\t\tperturb_local_entropy(bb, local_entropy);\n\t\tbb = bb->next_bb;\n\t}\n\n\t \n\tperturb_latent_entropy(local_entropy);\n\treturn 0;\n}\n\nstatic void latent_entropy_start_unit(void *gcc_data __unused,\n\t\t\t\t\tvoid *user_data __unused)\n{\n\ttree type, id;\n\tint quals;\n\n\tif (in_lto_p)\n\t\treturn;\n\n\t \n\tquals = TYPE_QUALS(long_unsigned_type_node) | TYPE_QUAL_VOLATILE;\n\ttype = build_qualified_type(long_unsigned_type_node, quals);\n\tid = get_identifier(\"latent_entropy\");\n\tlatent_entropy_decl = build_decl(UNKNOWN_LOCATION, VAR_DECL, id, type);\n\n\tTREE_STATIC(latent_entropy_decl) = 1;\n\tTREE_PUBLIC(latent_entropy_decl) = 1;\n\tTREE_USED(latent_entropy_decl) = 1;\n\tDECL_PRESERVE_P(latent_entropy_decl) = 1;\n\tTREE_THIS_VOLATILE(latent_entropy_decl) = 1;\n\tDECL_EXTERNAL(latent_entropy_decl) = 1;\n\tDECL_ARTIFICIAL(latent_entropy_decl) = 1;\n\tlang_hooks.decls.pushdecl(latent_entropy_decl);\n}\n\n#define PASS_NAME latent_entropy\n#define PROPERTIES_REQUIRED PROP_gimple_leh | PROP_cfg\n#define TODO_FLAGS_FINISH TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func \\\n\t| TODO_update_ssa\n#include \"gcc-generate-gimple-pass.h\"\n\n__visible int plugin_init(struct plugin_name_args *plugin_info,\n\t\t\t  struct plugin_gcc_version *version)\n{\n\tbool enabled = true;\n\tconst char * const plugin_name = plugin_info->base_name;\n\tconst int argc = plugin_info->argc;\n\tconst struct plugin_argument * const argv = plugin_info->argv;\n\tint i;\n\n\t \n\tdeterministic_seed = get_random_seed(true);\n\n\tstatic const struct ggc_root_tab gt_ggc_r_gt_latent_entropy[] = {\n\t\t{\n\t\t\t.base = &latent_entropy_decl,\n\t\t\t.nelt = 1,\n\t\t\t.stride = sizeof(latent_entropy_decl),\n\t\t\t.cb = &gt_ggc_mx_tree_node,\n\t\t\t.pchw = &gt_pch_nx_tree_node\n\t\t},\n\t\tLAST_GGC_ROOT_TAB\n\t};\n\n\tPASS_INFO(latent_entropy, \"optimized\", 1, PASS_POS_INSERT_BEFORE);\n\n\tif (!plugin_default_version_check(version, &gcc_version)) {\n\t\terror(G_(\"incompatible gcc/plugin versions\"));\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tif (!(strcmp(argv[i].key, \"disable\"))) {\n\t\t\tenabled = false;\n\t\t\tcontinue;\n\t\t}\n\t\terror(G_(\"unknown option '-fplugin-arg-%s-%s'\"), plugin_name, argv[i].key);\n\t}\n\n\tregister_callback(plugin_name, PLUGIN_INFO, NULL,\n\t\t\t\t&latent_entropy_plugin_info);\n\tif (enabled) {\n\t\tregister_callback(plugin_name, PLUGIN_START_UNIT,\n\t\t\t\t\t&latent_entropy_start_unit, NULL);\n\t\tregister_callback(plugin_name, PLUGIN_REGISTER_GGC_ROOTS,\n\t\t\t\t  NULL, (void *)&gt_ggc_r_gt_latent_entropy);\n\t\tregister_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n\t\t\t\t\t&latent_entropy_pass_info);\n\t}\n\tregister_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes,\n\t\t\t\tNULL);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}