{
  "module_name": "get_maintainer.pl",
  "hash_id": "b9a2a2cccbc6061dbb1ca59209eb989927ed171fa0314061266ce608577eb10b",
  "original_prompt": "Ingested from linux-6.6.14/scripts/get_maintainer.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# (c) 2007, Joe Perches <joe@perches.com>\n#           created from checkpatch.pl\n#\n# Print selected MAINTAINERS information for\n# the files modified in a patch or for a file\n#\n# usage: perl scripts/get_maintainer.pl [OPTIONS] <patch>\n#        perl scripts/get_maintainer.pl [OPTIONS] -f <file>\n\nuse warnings;\nuse strict;\n\nmy $P = $0;\nmy $V = '0.26';\n\nuse Getopt::Long qw(:config no_auto_abbrev);\nuse Cwd;\nuse File::Find;\nuse File::Spec::Functions;\n\nmy $cur_path = fastgetcwd() . '/';\nmy $lk_path = \"./\";\nmy $email = 1;\nmy $email_usename = 1;\nmy $email_maintainer = 1;\nmy $email_reviewer = 1;\nmy $email_fixes = 1;\nmy $email_list = 1;\nmy $email_moderated_list = 1;\nmy $email_subscriber_list = 0;\nmy $email_git_penguin_chiefs = 0;\nmy $email_git = 0;\nmy $email_git_all_signature_types = 0;\nmy $email_git_blame = 0;\nmy $email_git_blame_signatures = 1;\nmy $email_git_fallback = 1;\nmy $email_git_min_signatures = 1;\nmy $email_git_max_maintainers = 5;\nmy $email_git_min_percent = 5;\nmy $email_git_since = \"1-year-ago\";\nmy $email_hg_since = \"-365\";\nmy $interactive = 0;\nmy $email_remove_duplicates = 1;\nmy $email_use_mailmap = 1;\nmy $output_multiline = 1;\nmy $output_separator = \", \";\nmy $output_roles = 0;\nmy $output_rolestats = 1;\nmy $output_section_maxlen = 50;\nmy $scm = 0;\nmy $tree = 1;\nmy $web = 0;\nmy $subsystem = 0;\nmy $status = 0;\nmy $letters = \"\";\nmy $keywords = 1;\nmy $sections = 0;\nmy $email_file_emails = 0;\nmy $from_filename = 0;\nmy $pattern_depth = 0;\nmy $self_test = undef;\nmy $version = 0;\nmy $help = 0;\nmy $find_maintainer_files = 0;\nmy $maintainer_path;\nmy $vcs_used = 0;\n\nmy $exit = 0;\n\nmy @files = ();\nmy @fixes = ();\t\t\t# If a patch description includes Fixes: lines\nmy @range = ();\nmy @keyword_tvi = ();\nmy @file_emails = ();\n\nmy %commit_author_hash;\nmy %commit_signer_hash;\n\nmy @penguin_chief = ();\npush(@penguin_chief, \"Linus Torvalds:torvalds\\@linux-foundation.org\");\n#Andrew wants in on most everything - 2009/01/14\n#push(@penguin_chief, \"Andrew Morton:akpm\\@linux-foundation.org\");\n\nmy @penguin_chief_names = ();\nforeach my $chief (@penguin_chief) {\n    if ($chief =~ m/^(.*):(.*)/) {\n\tmy $chief_name = $1;\n\tmy $chief_addr = $2;\n\tpush(@penguin_chief_names, $chief_name);\n    }\n}\nmy $penguin_chiefs = \"\\(\" . join(\"|\", @penguin_chief_names) . \"\\)\";\n\n# Signature types of people who are either\n# \ta) responsible for the code in question, or\n# \tb) familiar enough with it to give relevant feedback\nmy @signature_tags = ();\npush(@signature_tags, \"Signed-off-by:\");\npush(@signature_tags, \"Reviewed-by:\");\npush(@signature_tags, \"Acked-by:\");\n\nmy $signature_pattern = \"\\(\" . join(\"|\", @signature_tags) . \"\\)\";\n\n# rfc822 email address - preloaded methods go here.\nmy $rfc822_lwsp = \"(?:(?:\\\\r\\\\n)?[ \\\\t])\";\nmy $rfc822_char = '[\\\\000-\\\\377]';\n\n# VCS command support: class-like functions and strings\n\nmy %VCS_cmds;\n\nmy %VCS_cmds_git = (\n    \"execute_cmd\" => \\&git_execute_cmd,\n    \"available\" => '(which(\"git\") ne \"\") && (-e \".git\")',\n    \"find_signers_cmd\" =>\n\t\"git log --no-color --follow --since=\\$email_git_since \" .\n\t    '--numstat --no-merges ' .\n\t    '--format=\"GitCommit: %H%n' .\n\t\t      'GitAuthor: %an <%ae>%n' .\n\t\t      'GitDate: %aD%n' .\n\t\t      'GitSubject: %s%n' .\n\t\t      '%b%n\"' .\n\t    \" -- \\$file\",\n    \"find_commit_signers_cmd\" =>\n\t\"git log --no-color \" .\n\t    '--numstat ' .\n\t    '--format=\"GitCommit: %H%n' .\n\t\t      'GitAuthor: %an <%ae>%n' .\n\t\t      'GitDate: %aD%n' .\n\t\t      'GitSubject: %s%n' .\n\t\t      '%b%n\"' .\n\t    \" -1 \\$commit\",\n    \"find_commit_author_cmd\" =>\n\t\"git log --no-color \" .\n\t    '--numstat ' .\n\t    '--format=\"GitCommit: %H%n' .\n\t\t      'GitAuthor: %an <%ae>%n' .\n\t\t      'GitDate: %aD%n' .\n\t\t      'GitSubject: %s%n\"' .\n\t    \" -1 \\$commit\",\n    \"blame_range_cmd\" => \"git blame -l -L \\$diff_start,+\\$diff_length \\$file\",\n    \"blame_file_cmd\" => \"git blame -l \\$file\",\n    \"commit_pattern\" => \"^GitCommit: ([0-9a-f]{40,40})\",\n    \"blame_commit_pattern\" => \"^([0-9a-f]+) \",\n    \"author_pattern\" => \"^GitAuthor: (.*)\",\n    \"subject_pattern\" => \"^GitSubject: (.*)\",\n    \"stat_pattern\" => \"^(\\\\d+)\\\\t(\\\\d+)\\\\t\\$file\\$\",\n    \"file_exists_cmd\" => \"git ls-files \\$file\",\n    \"list_files_cmd\" => \"git ls-files \\$file\",\n);\n\nmy %VCS_cmds_hg = (\n    \"execute_cmd\" => \\&hg_execute_cmd,\n    \"available\" => '(which(\"hg\") ne \"\") && (-d \".hg\")',\n    \"find_signers_cmd\" =>\n\t\"hg log --date=\\$email_hg_since \" .\n\t    \"--template='HgCommit: {node}\\\\n\" .\n\t                \"HgAuthor: {author}\\\\n\" .\n\t\t\t\"HgSubject: {desc}\\\\n'\" .\n\t    \" -- \\$file\",\n    \"find_commit_signers_cmd\" =>\n\t\"hg log \" .\n\t    \"--template='HgSubject: {desc}\\\\n'\" .\n\t    \" -r \\$commit\",\n    \"find_commit_author_cmd\" =>\n\t\"hg log \" .\n\t    \"--template='HgCommit: {node}\\\\n\" .\n\t\t        \"HgAuthor: {author}\\\\n\" .\n\t\t\t\"HgSubject: {desc|firstline}\\\\n'\" .\n\t    \" -r \\$commit\",\n    \"blame_range_cmd\" => \"\",\t\t# not supported\n    \"blame_file_cmd\" => \"hg blame -n \\$file\",\n    \"commit_pattern\" => \"^HgCommit: ([0-9a-f]{40,40})\",\n    \"blame_commit_pattern\" => \"^([ 0-9a-f]+):\",\n    \"author_pattern\" => \"^HgAuthor: (.*)\",\n    \"subject_pattern\" => \"^HgSubject: (.*)\",\n    \"stat_pattern\" => \"^(\\\\d+)\\t(\\\\d+)\\t\\$file\\$\",\n    \"file_exists_cmd\" => \"hg files \\$file\",\n    \"list_files_cmd\" => \"hg manifest -R \\$file\",\n);\n\nmy $conf = which_conf(\".get_maintainer.conf\");\nif (-f $conf) {\n    my @conf_args;\n    open(my $conffile, '<', \"$conf\")\n\tor warn \"$P: Can't find a readable .get_maintainer.conf file $!\\n\";\n\n    while (<$conffile>) {\n\tmy $line = $_;\n\n\t$line =~ s/\\s*\\n?$//g;\n\t$line =~ s/^\\s*//g;\n\t$line =~ s/\\s+/ /g;\n\n\tnext if ($line =~ m/^\\s*#/);\n\tnext if ($line =~ m/^\\s*$/);\n\n\tmy @words = split(\" \", $line);\n\tforeach my $word (@words) {\n\t    last if ($word =~ m/^#/);\n\t    push (@conf_args, $word);\n\t}\n    }\n    close($conffile);\n    unshift(@ARGV, @conf_args) if @conf_args;\n}\n\nmy @ignore_emails = ();\nmy $ignore_file = which_conf(\".get_maintainer.ignore\");\nif (-f $ignore_file) {\n    open(my $ignore, '<', \"$ignore_file\")\n\tor warn \"$P: Can't find a readable .get_maintainer.ignore file $!\\n\";\n    while (<$ignore>) {\n\tmy $line = $_;\n\n\t$line =~ s/\\s*\\n?$//;\n\t$line =~ s/^\\s*//;\n\t$line =~ s/\\s+$//;\n\t$line =~ s/#.*$//;\n\n\tnext if ($line =~ m/^\\s*$/);\n\tif (rfc822_valid($line)) {\n\t    push(@ignore_emails, $line);\n\t}\n    }\n    close($ignore);\n}\n\nif ($#ARGV > 0) {\n    foreach (@ARGV) {\n        if ($_ =~ /^-{1,2}self-test(?:=|$)/) {\n            die \"$P: using --self-test does not allow any other option or argument\\n\";\n        }\n    }\n}\n\nif (!GetOptions(\n\t\t'email!' => \\$email,\n\t\t'git!' => \\$email_git,\n\t\t'git-all-signature-types!' => \\$email_git_all_signature_types,\n\t\t'git-blame!' => \\$email_git_blame,\n\t\t'git-blame-signatures!' => \\$email_git_blame_signatures,\n\t\t'git-fallback!' => \\$email_git_fallback,\n\t\t'git-chief-penguins!' => \\$email_git_penguin_chiefs,\n\t\t'git-min-signatures=i' => \\$email_git_min_signatures,\n\t\t'git-max-maintainers=i' => \\$email_git_max_maintainers,\n\t\t'git-min-percent=i' => \\$email_git_min_percent,\n\t\t'git-since=s' => \\$email_git_since,\n\t\t'hg-since=s' => \\$email_hg_since,\n\t\t'i|interactive!' => \\$interactive,\n\t\t'remove-duplicates!' => \\$email_remove_duplicates,\n\t\t'mailmap!' => \\$email_use_mailmap,\n\t\t'm!' => \\$email_maintainer,\n\t\t'r!' => \\$email_reviewer,\n\t\t'n!' => \\$email_usename,\n\t\t'l!' => \\$email_list,\n\t\t'fixes!' => \\$email_fixes,\n\t\t'moderated!' => \\$email_moderated_list,\n\t\t's!' => \\$email_subscriber_list,\n\t\t'multiline!' => \\$output_multiline,\n\t\t'roles!' => \\$output_roles,\n\t\t'rolestats!' => \\$output_rolestats,\n\t\t'separator=s' => \\$output_separator,\n\t\t'subsystem!' => \\$subsystem,\n\t\t'status!' => \\$status,\n\t\t'scm!' => \\$scm,\n\t\t'tree!' => \\$tree,\n\t\t'web!' => \\$web,\n\t\t'letters=s' => \\$letters,\n\t\t'pattern-depth=i' => \\$pattern_depth,\n\t\t'k|keywords!' => \\$keywords,\n\t\t'sections!' => \\$sections,\n\t\t'fe|file-emails!' => \\$email_file_emails,\n\t\t'f|file' => \\$from_filename,\n\t\t'find-maintainer-files' => \\$find_maintainer_files,\n\t\t'mpath|maintainer-path=s' => \\$maintainer_path,\n\t\t'self-test:s' => \\$self_test,\n\t\t'v|version' => \\$version,\n\t\t'h|help|usage' => \\$help,\n\t\t)) {\n    die \"$P: invalid argument - use --help if necessary\\n\";\n}\n\nif ($help != 0) {\n    usage();\n    exit 0;\n}\n\nif ($version != 0) {\n    print(\"${P} ${V}\\n\");\n    exit 0;\n}\n\nif (defined $self_test) {\n    read_all_maintainer_files();\n    self_test();\n    exit 0;\n}\n\nif (-t STDIN && !@ARGV) {\n    # We're talking to a terminal, but have no command line arguments.\n    die \"$P: missing patchfile or -f file - use --help if necessary\\n\";\n}\n\n$output_multiline = 0 if ($output_separator ne \", \");\n$output_rolestats = 1 if ($interactive);\n$output_roles = 1 if ($output_rolestats);\n\nif ($sections || $letters ne \"\") {\n    $sections = 1;\n    $email = 0;\n    $email_list = 0;\n    $scm = 0;\n    $status = 0;\n    $subsystem = 0;\n    $web = 0;\n    $keywords = 0;\n    $interactive = 0;\n} else {\n    my $selections = $email + $scm + $status + $subsystem + $web;\n    if ($selections == 0) {\n\tdie \"$P:  Missing required option: email, scm, status, subsystem or web\\n\";\n    }\n}\n\nif ($email &&\n    ($email_maintainer + $email_reviewer +\n     $email_list + $email_subscriber_list +\n     $email_git + $email_git_penguin_chiefs + $email_git_blame) == 0) {\n    die \"$P: Please select at least 1 email option\\n\";\n}\n\nif ($tree && !top_of_kernel_tree($lk_path)) {\n    die \"$P: The current directory does not appear to be \"\n\t. \"a linux kernel source tree.\\n\";\n}\n\n## Read MAINTAINERS for type/value pairs\n\nmy @typevalue = ();\nmy %keyword_hash;\nmy @mfiles = ();\nmy @self_test_info = ();\n\nsub read_maintainer_file {\n    my ($file) = @_;\n\n    open (my $maint, '<', \"$file\")\n\tor die \"$P: Can't open MAINTAINERS file '$file': $!\\n\";\n    my $i = 1;\n    while (<$maint>) {\n\tmy $line = $_;\n\tchomp $line;\n\n\tif ($line =~ m/^([A-Z]):\\s*(.*)/) {\n\t    my $type = $1;\n\t    my $value = $2;\n\n\t    ##Filename pattern matching\n\t    if ($type eq \"F\" || $type eq \"X\") {\n\t\t$value =~ s@\\.@\\\\\\.@g;       ##Convert . to \\.\n\t\t$value =~ s/\\*/\\.\\*/g;       ##Convert * to .*\n\t\t$value =~ s/\\?/\\./g;         ##Convert ? to .\n\t\t##if pattern is a directory and it lacks a trailing slash, add one\n\t\tif ((-d $value)) {\n\t\t    $value =~ s@([^/])$@$1/@;\n\t\t}\n\t    } elsif ($type eq \"K\") {\n\t\t$keyword_hash{@typevalue} = $value;\n\t    }\n\t    push(@typevalue, \"$type:$value\");\n\t} elsif (!(/^\\s*$/ || /^\\s*\\#/)) {\n\t    push(@typevalue, $line);\n\t}\n\tif (defined $self_test) {\n\t    push(@self_test_info, {file=>$file, linenr=>$i, line=>$line});\n\t}\n\t$i++;\n    }\n    close($maint);\n}\n\nsub find_is_maintainer_file {\n    my ($file) = $_;\n    return if ($file !~ m@/MAINTAINERS$@);\n    $file = $File::Find::name;\n    return if (! -f $file);\n    push(@mfiles, $file);\n}\n\nsub find_ignore_git {\n    return grep { $_ !~ /^\\.git$/; } @_;\n}\n\nread_all_maintainer_files();\n\nsub read_all_maintainer_files {\n    my $path = \"${lk_path}MAINTAINERS\";\n    if (defined $maintainer_path) {\n\t$path = $maintainer_path;\n\t# Perl Cookbook tilde expansion if necessary\n\t$path =~ s@^~([^/]*)@ $1 ? (getpwnam($1))[7] : ( $ENV{HOME} || $ENV{LOGDIR} || (getpwuid($<))[7])@ex;\n    }\n\n    if (-d $path) {\n\t$path .= '/' if ($path !~ m@/$@);\n\tif ($find_maintainer_files) {\n\t    find( { wanted => \\&find_is_maintainer_file,\n\t\t    preprocess => \\&find_ignore_git,\n\t\t    no_chdir => 1,\n\t\t}, \"$path\");\n\t} else {\n\t    opendir(DIR, \"$path\") or die $!;\n\t    my @files = readdir(DIR);\n\t    closedir(DIR);\n\t    foreach my $file (@files) {\n\t\tpush(@mfiles, \"$path$file\") if ($file !~ /^\\./);\n\t    }\n\t}\n    } elsif (-f \"$path\") {\n\tpush(@mfiles, \"$path\");\n    } else {\n\tdie \"$P: MAINTAINER file not found '$path'\\n\";\n    }\n    die \"$P: No MAINTAINER files found in '$path'\\n\" if (scalar(@mfiles) == 0);\n    foreach my $file (@mfiles) {\n\tread_maintainer_file(\"$file\");\n    }\n}\n\nsub maintainers_in_file {\n    my ($file) = @_;\n\n    return if ($file =~ m@\\bMAINTAINERS$@);\n\n    if (-f $file && ($email_file_emails || $file =~ /\\.yaml$/)) {\n\topen(my $f, '<', $file)\n\t    or die \"$P: Can't open $file: $!\\n\";\n\tmy $text = do { local($/) ; <$f> };\n\tclose($f);\n\n\tmy @poss_addr = $text =~ m$[A-Za-z\u00c0-\u00ff\\\"\\' \\,\\.\\+-]*\\s*[\\,]*\\s*[\\(\\<\\{]{0,1}[A-Za-z0-9_\\.\\+-]+\\@[A-Za-z0-9\\.-]+\\.[A-Za-z0-9]+[\\)\\>\\}]{0,1}$g;\n\tpush(@file_emails, clean_file_emails(@poss_addr));\n    }\n}\n\n#\n# Read mail address map\n#\n\nmy $mailmap;\n\nread_mailmap();\n\nsub read_mailmap {\n    $mailmap = {\n\tnames => {},\n\taddresses => {}\n    };\n\n    return if (!$email_use_mailmap || !(-f \"${lk_path}.mailmap\"));\n\n    open(my $mailmap_file, '<', \"${lk_path}.mailmap\")\n\tor warn \"$P: Can't open .mailmap: $!\\n\";\n\n    while (<$mailmap_file>) {\n\ts/#.*$//; #strip comments\n\ts/^\\s+|\\s+$//g; #trim\n\n\tnext if (/^\\s*$/); #skip empty lines\n\t#entries have one of the following formats:\n\t# name1 <mail1>\n\t# <mail1> <mail2>\n\t# name1 <mail1> <mail2>\n\t# name1 <mail1> name2 <mail2>\n\t# (see man git-shortlog)\n\n\tif (/^([^<]+)<([^>]+)>$/) {\n\t    my $real_name = $1;\n\t    my $address = $2;\n\n\t    $real_name =~ s/\\s+$//;\n\t    ($real_name, $address) = parse_email(\"$real_name <$address>\");\n\t    $mailmap->{names}->{$address} = $real_name;\n\n\t} elsif (/^<([^>]+)>\\s*<([^>]+)>$/) {\n\t    my $real_address = $1;\n\t    my $wrong_address = $2;\n\n\t    $mailmap->{addresses}->{$wrong_address} = $real_address;\n\n\t} elsif (/^(.+)<([^>]+)>\\s*<([^>]+)>$/) {\n\t    my $real_name = $1;\n\t    my $real_address = $2;\n\t    my $wrong_address = $3;\n\n\t    $real_name =~ s/\\s+$//;\n\t    ($real_name, $real_address) =\n\t\tparse_email(\"$real_name <$real_address>\");\n\t    $mailmap->{names}->{$wrong_address} = $real_name;\n\t    $mailmap->{addresses}->{$wrong_address} = $real_address;\n\n\t} elsif (/^(.+)<([^>]+)>\\s*(.+)\\s*<([^>]+)>$/) {\n\t    my $real_name = $1;\n\t    my $real_address = $2;\n\t    my $wrong_name = $3;\n\t    my $wrong_address = $4;\n\n\t    $real_name =~ s/\\s+$//;\n\t    ($real_name, $real_address) =\n\t\tparse_email(\"$real_name <$real_address>\");\n\n\t    $wrong_name =~ s/\\s+$//;\n\t    ($wrong_name, $wrong_address) =\n\t\tparse_email(\"$wrong_name <$wrong_address>\");\n\n\t    my $wrong_email = format_email($wrong_name, $wrong_address, 1);\n\t    $mailmap->{names}->{$wrong_email} = $real_name;\n\t    $mailmap->{addresses}->{$wrong_email} = $real_address;\n\t}\n    }\n    close($mailmap_file);\n}\n\n## use the filenames on the command line or find the filenames in the patchfiles\n\nif (!@ARGV) {\n    push(@ARGV, \"&STDIN\");\n}\n\nforeach my $file (@ARGV) {\n    if ($file ne \"&STDIN\") {\n\t$file = canonpath($file);\n\t##if $file is a directory and it lacks a trailing slash, add one\n\tif ((-d $file)) {\n\t    $file =~ s@([^/])$@$1/@;\n\t} elsif (!(-f $file)) {\n\t    die \"$P: file '${file}' not found\\n\";\n\t}\n    }\n    if ($from_filename && (vcs_exists() && !vcs_file_exists($file))) {\n\twarn \"$P: file '$file' not found in version control $!\\n\";\n    }\n    if ($from_filename || ($file ne \"&STDIN\" && vcs_file_exists($file))) {\n\t$file =~ s/^\\Q${cur_path}\\E//;\t#strip any absolute path\n\t$file =~ s/^\\Q${lk_path}\\E//;\t#or the path to the lk tree\n\tpush(@files, $file);\n\tif ($file ne \"MAINTAINERS\" && -f $file && $keywords) {\n\t    open(my $f, '<', $file)\n\t\tor die \"$P: Can't open $file: $!\\n\";\n\t    my $text = do { local($/) ; <$f> };\n\t    close($f);\n\t    if ($keywords) {\n\t\tforeach my $line (keys %keyword_hash) {\n\t\t    if ($text =~ m/$keyword_hash{$line}/x) {\n\t\t\tpush(@keyword_tvi, $line);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    } else {\n\tmy $file_cnt = @files;\n\tmy $lastfile;\n\n\topen(my $patch, \"< $file\")\n\t    or die \"$P: Can't open $file: $!\\n\";\n\n\t# We can check arbitrary information before the patch\n\t# like the commit message, mail headers, etc...\n\t# This allows us to match arbitrary keywords against any part\n\t# of a git format-patch generated file (subject tags, etc...)\n\n\tmy $patch_prefix = \"\";\t\t\t#Parsing the intro\n\n\twhile (<$patch>) {\n\t    my $patch_line = $_;\n\t    if (m/^ mode change [0-7]+ => [0-7]+ (\\S+)\\s*$/) {\n\t\tmy $filename = $1;\n\t\tpush(@files, $filename);\n\t    } elsif (m/^rename (?:from|to) (\\S+)\\s*$/) {\n\t\tmy $filename = $1;\n\t\tpush(@files, $filename);\n\t    } elsif (m/^diff --git a\\/(\\S+) b\\/(\\S+)\\s*$/) {\n\t\tmy $filename1 = $1;\n\t\tmy $filename2 = $2;\n\t\tpush(@files, $filename1);\n\t\tpush(@files, $filename2);\n\t    } elsif (m/^Fixes:\\s+([0-9a-fA-F]{6,40})/) {\n\t\tpush(@fixes, $1) if ($email_fixes);\n\t    } elsif (m/^\\+\\+\\+\\s+(\\S+)/ or m/^---\\s+(\\S+)/) {\n\t\tmy $filename = $1;\n\t\t$filename =~ s@^[^/]*/@@;\n\t\t$filename =~ s@\\n@@;\n\t\t$lastfile = $filename;\n\t\tpush(@files, $filename);\n\t\t$patch_prefix = \"^[+-].*\";\t#Now parsing the actual patch\n\t    } elsif (m/^\\@\\@ -(\\d+),(\\d+)/) {\n\t\tif ($email_git_blame) {\n\t\t    push(@range, \"$lastfile:$1:$2\");\n\t\t}\n\t    } elsif ($keywords) {\n\t\tforeach my $line (keys %keyword_hash) {\n\t\t    if ($patch_line =~ m/${patch_prefix}$keyword_hash{$line}/x) {\n\t\t\tpush(@keyword_tvi, $line);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tclose($patch);\n\n\tif ($file_cnt == @files) {\n\t    warn \"$P: file '${file}' doesn't appear to be a patch.  \"\n\t\t. \"Add -f to options?\\n\";\n\t}\n\t@files = sort_and_uniq(@files);\n    }\n}\n\n@file_emails = uniq(@file_emails);\n@fixes = uniq(@fixes);\n\nmy %email_hash_name;\nmy %email_hash_address;\nmy @email_to = ();\nmy %hash_list_to;\nmy @list_to = ();\nmy @scm = ();\nmy @web = ();\nmy @subsystem = ();\nmy @status = ();\nmy %deduplicate_name_hash = ();\nmy %deduplicate_address_hash = ();\n\nmy @maintainers = get_maintainers();\nif (@maintainers) {\n    @maintainers = merge_email(@maintainers);\n    output(@maintainers);\n}\n\nif ($scm) {\n    @scm = uniq(@scm);\n    output(@scm);\n}\n\nif ($status) {\n    @status = uniq(@status);\n    output(@status);\n}\n\nif ($subsystem) {\n    @subsystem = uniq(@subsystem);\n    output(@subsystem);\n}\n\nif ($web) {\n    @web = uniq(@web);\n    output(@web);\n}\n\nexit($exit);\n\nsub self_test {\n    my @lsfiles = ();\n    my @good_links = ();\n    my @bad_links = ();\n    my @section_headers = ();\n    my $index = 0;\n\n    @lsfiles = vcs_list_files($lk_path);\n\n    for my $x (@self_test_info) {\n\t$index++;\n\n\t## Section header duplication and missing section content\n\tif (($self_test eq \"\" || $self_test =~ /\\bsections\\b/) &&\n\t    $x->{line} =~ /^\\S[^:]/ &&\n\t    defined $self_test_info[$index] &&\n\t    $self_test_info[$index]->{line} =~ /^([A-Z]):\\s*\\S/) {\n\t    my $has_S = 0;\n\t    my $has_F = 0;\n\t    my $has_ML = 0;\n\t    my $status = \"\";\n\t    if (grep(m@^\\Q$x->{line}\\E@, @section_headers)) {\n\t\tprint(\"$x->{file}:$x->{linenr}: warning: duplicate section header\\t$x->{line}\\n\");\n\t    } else {\n\t\tpush(@section_headers, $x->{line});\n\t    }\n\t    my $nextline = $index;\n\t    while (defined $self_test_info[$nextline] &&\n\t\t   $self_test_info[$nextline]->{line} =~ /^([A-Z]):\\s*(\\S.*)/) {\n\t\tmy $type = $1;\n\t\tmy $value = $2;\n\t\tif ($type eq \"S\") {\n\t\t    $has_S = 1;\n\t\t    $status = $value;\n\t\t} elsif ($type eq \"F\" || $type eq \"N\") {\n\t\t    $has_F = 1;\n\t\t} elsif ($type eq \"M\" || $type eq \"R\" || $type eq \"L\") {\n\t\t    $has_ML = 1;\n\t\t}\n\t\t$nextline++;\n\t    }\n\t    if (!$has_ML && $status !~ /orphan|obsolete/i) {\n\t\tprint(\"$x->{file}:$x->{linenr}: warning: section without email address\\t$x->{line}\\n\");\n\t    }\n\t    if (!$has_S) {\n\t\tprint(\"$x->{file}:$x->{linenr}: warning: section without status \\t$x->{line}\\n\");\n\t    }\n\t    if (!$has_F) {\n\t\tprint(\"$x->{file}:$x->{linenr}: warning: section without file pattern\\t$x->{line}\\n\");\n\t    }\n\t}\n\n\tnext if ($x->{line} !~ /^([A-Z]):\\s*(.*)/);\n\n\tmy $type = $1;\n\tmy $value = $2;\n\n\t## Filename pattern matching\n\tif (($type eq \"F\" || $type eq \"X\") &&\n\t    ($self_test eq \"\" || $self_test =~ /\\bpatterns\\b/)) {\n\t    $value =~ s@\\.@\\\\\\.@g;       ##Convert . to \\.\n\t    $value =~ s/\\*/\\.\\*/g;       ##Convert * to .*\n\t    $value =~ s/\\?/\\./g;         ##Convert ? to .\n\t    ##if pattern is a directory and it lacks a trailing slash, add one\n\t    if ((-d $value)) {\n\t\t$value =~ s@([^/])$@$1/@;\n\t    }\n\t    if (!grep(m@^$value@, @lsfiles)) {\n\t\tprint(\"$x->{file}:$x->{linenr}: warning: no file matches\\t$x->{line}\\n\");\n\t    }\n\n\t## Link reachability\n\t} elsif (($type eq \"W\" || $type eq \"Q\" || $type eq \"B\") &&\n\t\t $value =~ /^https?:/ &&\n\t\t ($self_test eq \"\" || $self_test =~ /\\blinks\\b/)) {\n\t    next if (grep(m@^\\Q$value\\E$@, @good_links));\n\t    my $isbad = 0;\n\t    if (grep(m@^\\Q$value\\E$@, @bad_links)) {\n\t        $isbad = 1;\n\t    } else {\n\t\tmy $output = `wget --spider -q --no-check-certificate --timeout 10 --tries 1 $value`;\n\t\tif ($? == 0) {\n\t\t    push(@good_links, $value);\n\t\t} else {\n\t\t    push(@bad_links, $value);\n\t\t    $isbad = 1;\n\t\t}\n\t    }\n\t    if ($isbad) {\n\t        print(\"$x->{file}:$x->{linenr}: warning: possible bad link\\t$x->{line}\\n\");\n\t    }\n\n\t## SCM reachability\n\t} elsif ($type eq \"T\" &&\n\t\t ($self_test eq \"\" || $self_test =~ /\\bscm\\b/)) {\n\t    next if (grep(m@^\\Q$value\\E$@, @good_links));\n\t    my $isbad = 0;\n\t    if (grep(m@^\\Q$value\\E$@, @bad_links)) {\n\t        $isbad = 1;\n            } elsif ($value !~ /^(?:git|quilt|hg)\\s+\\S/) {\n\t\tprint(\"$x->{file}:$x->{linenr}: warning: malformed entry\\t$x->{line}\\n\");\n\t    } elsif ($value =~ /^git\\s+(\\S+)(\\s+([^\\(]+\\S+))?/) {\n\t\tmy $url = $1;\n\t\tmy $branch = \"\";\n\t\t$branch = $3 if $3;\n\t\tmy $output = `git ls-remote --exit-code -h \"$url\" $branch > /dev/null 2>&1`;\n\t\tif ($? == 0) {\n\t\t    push(@good_links, $value);\n\t\t} else {\n\t\t    push(@bad_links, $value);\n\t\t    $isbad = 1;\n\t\t}\n\t    } elsif ($value =~ /^(?:quilt|hg)\\s+(https?:\\S+)/) {\n\t\tmy $url = $1;\n\t\tmy $output = `wget --spider -q --no-check-certificate --timeout 10 --tries 1 $url`;\n\t\tif ($? == 0) {\n\t\t    push(@good_links, $value);\n\t\t} else {\n\t\t    push(@bad_links, $value);\n\t\t    $isbad = 1;\n\t\t}\n\t    }\n\t    if ($isbad) {\n\t\tprint(\"$x->{file}:$x->{linenr}: warning: possible bad link\\t$x->{line}\\n\");\n\t    }\n\t}\n    }\n}\n\nsub ignore_email_address {\n    my ($address) = @_;\n\n    foreach my $ignore (@ignore_emails) {\n\treturn 1 if ($ignore eq $address);\n    }\n\n    return 0;\n}\n\nsub range_is_maintained {\n    my ($start, $end) = @_;\n\n    for (my $i = $start; $i < $end; $i++) {\n\tmy $line = $typevalue[$i];\n\tif ($line =~ m/^([A-Z]):\\s*(.*)/) {\n\t    my $type = $1;\n\t    my $value = $2;\n\t    if ($type eq 'S') {\n\t\tif ($value =~ /(maintain|support)/i) {\n\t\t    return 1;\n\t\t}\n\t    }\n\t}\n    }\n    return 0;\n}\n\nsub range_has_maintainer {\n    my ($start, $end) = @_;\n\n    for (my $i = $start; $i < $end; $i++) {\n\tmy $line = $typevalue[$i];\n\tif ($line =~ m/^([A-Z]):\\s*(.*)/) {\n\t    my $type = $1;\n\t    my $value = $2;\n\t    if ($type eq 'M') {\n\t\treturn 1;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nsub get_maintainers {\n    %email_hash_name = ();\n    %email_hash_address = ();\n    %commit_author_hash = ();\n    %commit_signer_hash = ();\n    @email_to = ();\n    %hash_list_to = ();\n    @list_to = ();\n    @scm = ();\n    @web = ();\n    @subsystem = ();\n    @status = ();\n    %deduplicate_name_hash = ();\n    %deduplicate_address_hash = ();\n    if ($email_git_all_signature_types) {\n\t$signature_pattern = \"(.+?)[Bb][Yy]:\";\n    } else {\n\t$signature_pattern = \"\\(\" . join(\"|\", @signature_tags) . \"\\)\";\n    }\n\n    # Find responsible parties\n\n    my %exact_pattern_match_hash = ();\n\n    foreach my $file (@files) {\n\n\tmy %hash;\n\tmy $tvi = find_first_section();\n\twhile ($tvi < @typevalue) {\n\t    my $start = find_starting_index($tvi);\n\t    my $end = find_ending_index($tvi);\n\t    my $exclude = 0;\n\t    my $i;\n\n\t    #Do not match excluded file patterns\n\n\t    for ($i = $start; $i < $end; $i++) {\n\t\tmy $line = $typevalue[$i];\n\t\tif ($line =~ m/^([A-Z]):\\s*(.*)/) {\n\t\t    my $type = $1;\n\t\t    my $value = $2;\n\t\t    if ($type eq 'X') {\n\t\t\tif (file_match_pattern($file, $value)) {\n\t\t\t    $exclude = 1;\n\t\t\t    last;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (!$exclude) {\n\t\tfor ($i = $start; $i < $end; $i++) {\n\t\t    my $line = $typevalue[$i];\n\t\t    if ($line =~ m/^([A-Z]):\\s*(.*)/) {\n\t\t\tmy $type = $1;\n\t\t\tmy $value = $2;\n\t\t\tif ($type eq 'F') {\n\t\t\t    if (file_match_pattern($file, $value)) {\n\t\t\t\tmy $value_pd = ($value =~ tr@/@@);\n\t\t\t\tmy $file_pd = ($file  =~ tr@/@@);\n\t\t\t\t$value_pd++ if (substr($value,-1,1) ne \"/\");\n\t\t\t\t$value_pd = -1 if ($value =~ /^\\.\\*/);\n\t\t\t\tif ($value_pd >= $file_pd &&\n\t\t\t\t    range_is_maintained($start, $end) &&\n\t\t\t\t    range_has_maintainer($start, $end)) {\n\t\t\t\t    $exact_pattern_match_hash{$file} = 1;\n\t\t\t\t}\n\t\t\t\tif ($pattern_depth == 0 ||\n\t\t\t\t    (($file_pd - $value_pd) < $pattern_depth)) {\n\t\t\t\t    $hash{$tvi} = $value_pd;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} elsif ($type eq 'N') {\n\t\t\t    if ($file =~ m/$value/x) {\n\t\t\t\t$hash{$tvi} = 0;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    $tvi = $end + 1;\n\t}\n\n\tforeach my $line (sort {$hash{$b} <=> $hash{$a}} keys %hash) {\n\t    add_categories($line);\n\t    if ($sections) {\n\t\tmy $i;\n\t\tmy $start = find_starting_index($line);\n\t\tmy $end = find_ending_index($line);\n\t\tfor ($i = $start; $i < $end; $i++) {\n\t\t    my $line = $typevalue[$i];\n\t\t    if ($line =~ /^[FX]:/) {\t\t##Restore file patterns\n\t\t\t$line =~ s/([^\\\\])\\.([^\\*])/$1\\?$2/g;\n\t\t\t$line =~ s/([^\\\\])\\.$/$1\\?/g;\t##Convert . back to ?\n\t\t\t$line =~ s/\\\\\\./\\./g;       \t##Convert \\. to .\n\t\t\t$line =~ s/\\.\\*/\\*/g;       \t##Convert .* to *\n\t\t    }\n\t\t    my $count = $line =~ s/^([A-Z]):/$1:\\t/g;\n\t\t    if ($letters eq \"\" || (!$count || $letters =~ /$1/i)) {\n\t\t\tprint(\"$line\\n\");\n\t\t    }\n\t\t}\n\t\tprint(\"\\n\");\n\t    }\n\t}\n\n\tmaintainers_in_file($file);\n    }\n\n    if ($keywords) {\n\t@keyword_tvi = sort_and_uniq(@keyword_tvi);\n\tforeach my $line (@keyword_tvi) {\n\t    add_categories($line);\n\t}\n    }\n\n    foreach my $email (@email_to, @list_to) {\n\t$email->[0] = deduplicate_email($email->[0]);\n    }\n\n    foreach my $file (@files) {\n\tif ($email &&\n\t    ($email_git ||\n\t     ($email_git_fallback &&\n\t      $file !~ /MAINTAINERS$/ &&\n\t      !$exact_pattern_match_hash{$file}))) {\n\t    vcs_file_signoffs($file);\n\t}\n\tif ($email && $email_git_blame) {\n\t    vcs_file_blame($file);\n\t}\n    }\n\n    if ($email) {\n\tforeach my $chief (@penguin_chief) {\n\t    if ($chief =~ m/^(.*):(.*)/) {\n\t\tmy $email_address;\n\n\t\t$email_address = format_email($1, $2, $email_usename);\n\t\tif ($email_git_penguin_chiefs) {\n\t\t    push(@email_to, [$email_address, 'chief penguin']);\n\t\t} else {\n\t\t    @email_to = grep($_->[0] !~ /${email_address}/, @email_to);\n\t\t}\n\t    }\n\t}\n\n\tforeach my $email (@file_emails) {\n\t    $email = mailmap_email($email);\n\t    my ($name, $address) = parse_email($email);\n\n\t    my $tmp_email = format_email($name, $address, $email_usename);\n\t    push_email_address($tmp_email, '');\n\t    add_role($tmp_email, 'in file');\n\t}\n    }\n\n    foreach my $fix (@fixes) {\n\tvcs_add_commit_signers($fix, \"blamed_fixes\");\n    }\n\n    my @to = ();\n    if ($email || $email_list) {\n\tif ($email) {\n\t    @to = (@to, @email_to);\n\t}\n\tif ($email_list) {\n\t    @to = (@to, @list_to);\n\t}\n    }\n\n    if ($interactive) {\n\t@to = interactive_get_maintainers(\\@to);\n    }\n\n    return @to;\n}\n\nsub file_match_pattern {\n    my ($file, $pattern) = @_;\n    if (substr($pattern, -1) eq \"/\") {\n\tif ($file =~ m@^$pattern@) {\n\t    return 1;\n\t}\n    } else {\n\tif ($file =~ m@^$pattern@) {\n\t    my $s1 = ($file =~ tr@/@@);\n\t    my $s2 = ($pattern =~ tr@/@@);\n\t    if ($s1 == $s2) {\n\t\treturn 1;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nsub usage {\n    print <<EOT;\nusage: $P [options] patchfile\n       $P [options] -f file|directory\nversion: $V\n\nMAINTAINER field selection options:\n  --email => print email address(es) if any\n    --git => include recent git \\*-by: signers\n    --git-all-signature-types => include signers regardless of signature type\n        or use only ${signature_pattern} signers (default: $email_git_all_signature_types)\n    --git-fallback => use git when no exact MAINTAINERS pattern (default: $email_git_fallback)\n    --git-chief-penguins => include ${penguin_chiefs}\n    --git-min-signatures => number of signatures required (default: $email_git_min_signatures)\n    --git-max-maintainers => maximum maintainers to add (default: $email_git_max_maintainers)\n    --git-min-percent => minimum percentage of commits required (default: $email_git_min_percent)\n    --git-blame => use git blame to find modified commits for patch or file\n    --git-blame-signatures => when used with --git-blame, also include all commit signers\n    --git-since => git history to use (default: $email_git_since)\n    --hg-since => hg history to use (default: $email_hg_since)\n    --interactive => display a menu (mostly useful if used with the --git option)\n    --m => include maintainer(s) if any\n    --r => include reviewer(s) if any\n    --n => include name 'Full Name <addr\\@domain.tld>'\n    --l => include list(s) if any\n    --moderated => include moderated lists(s) if any (default: true)\n    --s => include subscriber only list(s) if any (default: false)\n    --remove-duplicates => minimize duplicate email names/addresses\n    --roles => show roles (status:subsystem, git-signer, list, etc...)\n    --rolestats => show roles and statistics (commits/total_commits, %)\n    --file-emails => add email addresses found in -f file (default: 0 (off))\n    --fixes => for patches, add signatures of commits with 'Fixes: <commit>' (default: 1 (on))\n  --scm => print SCM tree(s) if any\n  --status => print status if any\n  --subsystem => print subsystem name if any\n  --web => print website(s) if any\n\nOutput type options:\n  --separator [, ] => separator for multiple entries on 1 line\n    using --separator also sets --nomultiline if --separator is not [, ]\n  --multiline => print 1 entry per line\n\nOther options:\n  --pattern-depth => Number of pattern directory traversals (default: 0 (all))\n  --keywords => scan patch for keywords (default: $keywords)\n  --sections => print all of the subsystem sections with pattern matches\n  --letters => print all matching 'letter' types from all matching sections\n  --mailmap => use .mailmap file (default: $email_use_mailmap)\n  --no-tree => run without a kernel tree\n  --self-test => show potential issues with MAINTAINERS file content\n  --version => show version\n  --help => show this help information\n\nDefault options:\n  [--email --tree --nogit --git-fallback --m --r --n --l --multiline\n   --pattern-depth=0 --remove-duplicates --rolestats]\n\nNotes:\n  Using \"-f directory\" may give unexpected results:\n      Used with \"--git\", git signators for _all_ files in and below\n          directory are examined as git recurses directories.\n          Any specified X: (exclude) pattern matches are _not_ ignored.\n      Used with \"--nogit\", directory is used as a pattern match,\n          no individual file within the directory or subdirectory\n          is matched.\n      Used with \"--git-blame\", does not iterate all files in directory\n  Using \"--git-blame\" is slow and may add old committers and authors\n      that are no longer active maintainers to the output.\n  Using \"--roles\" or \"--rolestats\" with git send-email --cc-cmd or any\n      other automated tools that expect only [\"name\"] <email address>\n      may not work because of additional output after <email address>.\n  Using \"--rolestats\" and \"--git-blame\" shows the #/total=% commits,\n      not the percentage of the entire file authored.  # of commits is\n      not a good measure of amount of code authored.  1 major commit may\n      contain a thousand lines, 5 trivial commits may modify a single line.\n  If git is not installed, but mercurial (hg) is installed and an .hg\n      repository exists, the following options apply to mercurial:\n          --git,\n          --git-min-signatures, --git-max-maintainers, --git-min-percent, and\n          --git-blame\n      Use --hg-since not --git-since to control date selection\n  File \".get_maintainer.conf\", if it exists in the linux kernel source root\n      directory, can change whatever get_maintainer defaults are desired.\n      Entries in this file can be any command line argument.\n      This file is prepended to any additional command line arguments.\n      Multiple lines and # comments are allowed.\n  Most options have both positive and negative forms.\n      The negative forms for --<foo> are --no<foo> and --no-<foo>.\n\nEOT\n}\n\nsub top_of_kernel_tree {\n    my ($lk_path) = @_;\n\n    if ($lk_path ne \"\" && substr($lk_path,length($lk_path)-1,1) ne \"/\") {\n\t$lk_path .= \"/\";\n    }\n    if (   (-f \"${lk_path}COPYING\")\n\t&& (-f \"${lk_path}CREDITS\")\n\t&& (-f \"${lk_path}Kbuild\")\n\t&& (-e \"${lk_path}MAINTAINERS\")\n\t&& (-f \"${lk_path}Makefile\")\n\t&& (-f \"${lk_path}README\")\n\t&& (-d \"${lk_path}Documentation\")\n\t&& (-d \"${lk_path}arch\")\n\t&& (-d \"${lk_path}include\")\n\t&& (-d \"${lk_path}drivers\")\n\t&& (-d \"${lk_path}fs\")\n\t&& (-d \"${lk_path}init\")\n\t&& (-d \"${lk_path}ipc\")\n\t&& (-d \"${lk_path}kernel\")\n\t&& (-d \"${lk_path}lib\")\n\t&& (-d \"${lk_path}scripts\")) {\n\treturn 1;\n    }\n    return 0;\n}\n\nsub parse_email {\n    my ($formatted_email) = @_;\n\n    my $name = \"\";\n    my $address = \"\";\n\n    if ($formatted_email =~ /^([^<]+)<(.+\\@.*)>.*$/) {\n\t$name = $1;\n\t$address = $2;\n    } elsif ($formatted_email =~ /^\\s*<(.+\\@\\S*)>.*$/) {\n\t$address = $1;\n    } elsif ($formatted_email =~ /^(.+\\@\\S*).*$/) {\n\t$address = $1;\n    }\n\n    $name =~ s/^\\s+|\\s+$//g;\n    $name =~ s/^\\\"|\\\"$//g;\n    $address =~ s/^\\s+|\\s+$//g;\n\n    if ($name =~ /[^\\w \\-]/i) {  \t ##has \"must quote\" chars\n\t$name =~ s/(?<!\\\\)\"/\\\\\"/g;       ##escape quotes\n\t$name = \"\\\"$name\\\"\";\n    }\n\n    return ($name, $address);\n}\n\nsub format_email {\n    my ($name, $address, $usename) = @_;\n\n    my $formatted_email;\n\n    $name =~ s/^\\s+|\\s+$//g;\n    $name =~ s/^\\\"|\\\"$//g;\n    $address =~ s/^\\s+|\\s+$//g;\n\n    if ($name =~ /[^\\w \\-]/i) {          ##has \"must quote\" chars\n\t$name =~ s/(?<!\\\\)\"/\\\\\"/g;       ##escape quotes\n\t$name = \"\\\"$name\\\"\";\n    }\n\n    if ($usename) {\n\tif (\"$name\" eq \"\") {\n\t    $formatted_email = \"$address\";\n\t} else {\n\t    $formatted_email = \"$name <$address>\";\n\t}\n    } else {\n\t$formatted_email = $address;\n    }\n\n    return $formatted_email;\n}\n\nsub find_first_section {\n    my $index = 0;\n\n    while ($index < @typevalue) {\n\tmy $tv = $typevalue[$index];\n\tif (($tv =~ m/^([A-Z]):\\s*(.*)/)) {\n\t    last;\n\t}\n\t$index++;\n    }\n\n    return $index;\n}\n\nsub find_starting_index {\n    my ($index) = @_;\n\n    while ($index > 0) {\n\tmy $tv = $typevalue[$index];\n\tif (!($tv =~ m/^([A-Z]):\\s*(.*)/)) {\n\t    last;\n\t}\n\t$index--;\n    }\n\n    return $index;\n}\n\nsub find_ending_index {\n    my ($index) = @_;\n\n    while ($index < @typevalue) {\n\tmy $tv = $typevalue[$index];\n\tif (!($tv =~ m/^([A-Z]):\\s*(.*)/)) {\n\t    last;\n\t}\n\t$index++;\n    }\n\n    return $index;\n}\n\nsub get_subsystem_name {\n    my ($index) = @_;\n\n    my $start = find_starting_index($index);\n\n    my $subsystem = $typevalue[$start];\n    if ($output_section_maxlen && length($subsystem) > $output_section_maxlen) {\n\t$subsystem = substr($subsystem, 0, $output_section_maxlen - 3);\n\t$subsystem =~ s/\\s*$//;\n\t$subsystem = $subsystem . \"...\";\n    }\n    return $subsystem;\n}\n\nsub get_maintainer_role {\n    my ($index) = @_;\n\n    my $i;\n    my $start = find_starting_index($index);\n    my $end = find_ending_index($index);\n\n    my $role = \"unknown\";\n    my $subsystem = get_subsystem_name($index);\n\n    for ($i = $start + 1; $i < $end; $i++) {\n\tmy $tv = $typevalue[$i];\n\tif ($tv =~ m/^([A-Z]):\\s*(.*)/) {\n\t    my $ptype = $1;\n\t    my $pvalue = $2;\n\t    if ($ptype eq \"S\") {\n\t\t$role = $pvalue;\n\t    }\n\t}\n    }\n\n    $role = lc($role);\n    if      ($role eq \"supported\") {\n\t$role = \"supporter\";\n    } elsif ($role eq \"maintained\") {\n\t$role = \"maintainer\";\n    } elsif ($role eq \"odd fixes\") {\n\t$role = \"odd fixer\";\n    } elsif ($role eq \"orphan\") {\n\t$role = \"orphan minder\";\n    } elsif ($role eq \"obsolete\") {\n\t$role = \"obsolete minder\";\n    } elsif ($role eq \"buried alive in reporters\") {\n\t$role = \"chief penguin\";\n    }\n\n    return $role . \":\" . $subsystem;\n}\n\nsub get_list_role {\n    my ($index) = @_;\n\n    my $subsystem = get_subsystem_name($index);\n\n    if ($subsystem eq \"THE REST\") {\n\t$subsystem = \"\";\n    }\n\n    return $subsystem;\n}\n\nsub add_categories {\n    my ($index) = @_;\n\n    my $i;\n    my $start = find_starting_index($index);\n    my $end = find_ending_index($index);\n\n    push(@subsystem, $typevalue[$start]);\n\n    for ($i = $start + 1; $i < $end; $i++) {\n\tmy $tv = $typevalue[$i];\n\tif ($tv =~ m/^([A-Z]):\\s*(.*)/) {\n\t    my $ptype = $1;\n\t    my $pvalue = $2;\n\t    if ($ptype eq \"L\") {\n\t\tmy $list_address = $pvalue;\n\t\tmy $list_additional = \"\";\n\t\tmy $list_role = get_list_role($i);\n\n\t\tif ($list_role ne \"\") {\n\t\t    $list_role = \":\" . $list_role;\n\t\t}\n\t\tif ($list_address =~ m/([^\\s]+)\\s+(.*)$/) {\n\t\t    $list_address = $1;\n\t\t    $list_additional = $2;\n\t\t}\n\t\tif ($list_additional =~ m/subscribers-only/) {\n\t\t    if ($email_subscriber_list) {\n\t\t\tif (!$hash_list_to{lc($list_address)}) {\n\t\t\t    $hash_list_to{lc($list_address)} = 1;\n\t\t\t    push(@list_to, [$list_address,\n\t\t\t\t\t    \"subscriber list${list_role}\"]);\n\t\t\t}\n\t\t    }\n\t\t} else {\n\t\t    if ($email_list) {\n\t\t\tif (!$hash_list_to{lc($list_address)}) {\n\t\t\t    if ($list_additional =~ m/moderated/) {\n\t\t\t\tif ($email_moderated_list) {\n\t\t\t\t    $hash_list_to{lc($list_address)} = 1;\n\t\t\t\t    push(@list_to, [$list_address,\n\t\t\t\t\t\t    \"moderated list${list_role}\"]);\n\t\t\t\t}\n\t\t\t    } else {\n\t\t\t\t$hash_list_to{lc($list_address)} = 1;\n\t\t\t\tpush(@list_to, [$list_address,\n\t\t\t\t\t\t\"open list${list_role}\"]);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    } elsif ($ptype eq \"M\") {\n\t\tif ($email_maintainer) {\n\t\t    my $role = get_maintainer_role($i);\n\t\t    push_email_addresses($pvalue, $role);\n\t\t}\n\t    } elsif ($ptype eq \"R\") {\n\t\tif ($email_reviewer) {\n\t\t    my $subsystem = get_subsystem_name($i);\n\t\t    push_email_addresses($pvalue, \"reviewer:$subsystem\");\n\t\t}\n\t    } elsif ($ptype eq \"T\") {\n\t\tpush(@scm, $pvalue);\n\t    } elsif ($ptype eq \"W\") {\n\t\tpush(@web, $pvalue);\n\t    } elsif ($ptype eq \"S\") {\n\t\tpush(@status, $pvalue);\n\t    }\n\t}\n    }\n}\n\nsub email_inuse {\n    my ($name, $address) = @_;\n\n    return 1 if (($name eq \"\") && ($address eq \"\"));\n    return 1 if (($name ne \"\") && exists($email_hash_name{lc($name)}));\n    return 1 if (($address ne \"\") && exists($email_hash_address{lc($address)}));\n\n    return 0;\n}\n\nsub push_email_address {\n    my ($line, $role) = @_;\n\n    my ($name, $address) = parse_email($line);\n\n    if ($address eq \"\") {\n\treturn 0;\n    }\n\n    if (!$email_remove_duplicates) {\n\tpush(@email_to, [format_email($name, $address, $email_usename), $role]);\n    } elsif (!email_inuse($name, $address)) {\n\tpush(@email_to, [format_email($name, $address, $email_usename), $role]);\n\t$email_hash_name{lc($name)}++ if ($name ne \"\");\n\t$email_hash_address{lc($address)}++;\n    }\n\n    return 1;\n}\n\nsub push_email_addresses {\n    my ($address, $role) = @_;\n\n    my @address_list = ();\n\n    if (rfc822_valid($address)) {\n\tpush_email_address($address, $role);\n    } elsif (@address_list = rfc822_validlist($address)) {\n\tmy $array_count = shift(@address_list);\n\twhile (my $entry = shift(@address_list)) {\n\t    push_email_address($entry, $role);\n\t}\n    } else {\n\tif (!push_email_address($address, $role)) {\n\t    warn(\"Invalid MAINTAINERS address: '\" . $address . \"'\\n\");\n\t}\n    }\n}\n\nsub add_role {\n    my ($line, $role) = @_;\n\n    my ($name, $address) = parse_email($line);\n    my $email = format_email($name, $address, $email_usename);\n\n    foreach my $entry (@email_to) {\n\tif ($email_remove_duplicates) {\n\t    my ($entry_name, $entry_address) = parse_email($entry->[0]);\n\t    if (($name eq $entry_name || $address eq $entry_address)\n\t\t&& ($role eq \"\" || !($entry->[1] =~ m/$role/))\n\t    ) {\n\t\tif ($entry->[1] eq \"\") {\n\t\t    $entry->[1] = \"$role\";\n\t\t} else {\n\t\t    $entry->[1] = \"$entry->[1],$role\";\n\t\t}\n\t    }\n\t} else {\n\t    if ($email eq $entry->[0]\n\t\t&& ($role eq \"\" || !($entry->[1] =~ m/$role/))\n\t    ) {\n\t\tif ($entry->[1] eq \"\") {\n\t\t    $entry->[1] = \"$role\";\n\t\t} else {\n\t\t    $entry->[1] = \"$entry->[1],$role\";\n\t\t}\n\t    }\n\t}\n    }\n}\n\nsub which {\n    my ($bin) = @_;\n\n    foreach my $path (split(/:/, $ENV{PATH})) {\n\tif (-e \"$path/$bin\") {\n\t    return \"$path/$bin\";\n\t}\n    }\n\n    return \"\";\n}\n\nsub which_conf {\n    my ($conf) = @_;\n\n    foreach my $path (split(/:/, \".:$ENV{HOME}:.scripts\")) {\n\tif (-e \"$path/$conf\") {\n\t    return \"$path/$conf\";\n\t}\n    }\n\n    return \"\";\n}\n\nsub mailmap_email {\n    my ($line) = @_;\n\n    my ($name, $address) = parse_email($line);\n    my $email = format_email($name, $address, 1);\n    my $real_name = $name;\n    my $real_address = $address;\n\n    if (exists $mailmap->{names}->{$email} ||\n\texists $mailmap->{addresses}->{$email}) {\n\tif (exists $mailmap->{names}->{$email}) {\n\t    $real_name = $mailmap->{names}->{$email};\n\t}\n\tif (exists $mailmap->{addresses}->{$email}) {\n\t    $real_address = $mailmap->{addresses}->{$email};\n\t}\n    } else {\n\tif (exists $mailmap->{names}->{$address}) {\n\t    $real_name = $mailmap->{names}->{$address};\n\t}\n\tif (exists $mailmap->{addresses}->{$address}) {\n\t    $real_address = $mailmap->{addresses}->{$address};\n\t}\n    }\n    return format_email($real_name, $real_address, 1);\n}\n\nsub mailmap {\n    my (@addresses) = @_;\n\n    my @mapped_emails = ();\n    foreach my $line (@addresses) {\n\tpush(@mapped_emails, mailmap_email($line));\n    }\n    merge_by_realname(@mapped_emails) if ($email_use_mailmap);\n    return @mapped_emails;\n}\n\nsub merge_by_realname {\n    my %address_map;\n    my (@emails) = @_;\n\n    foreach my $email (@emails) {\n\tmy ($name, $address) = parse_email($email);\n\tif (exists $address_map{$name}) {\n\t    $address = $address_map{$name};\n\t    $email = format_email($name, $address, 1);\n\t} else {\n\t    $address_map{$name} = $address;\n\t}\n    }\n}\n\nsub git_execute_cmd {\n    my ($cmd) = @_;\n    my @lines = ();\n\n    my $output = `$cmd`;\n    $output =~ s/^\\s*//gm;\n    @lines = split(\"\\n\", $output);\n\n    return @lines;\n}\n\nsub hg_execute_cmd {\n    my ($cmd) = @_;\n    my @lines = ();\n\n    my $output = `$cmd`;\n    @lines = split(\"\\n\", $output);\n\n    return @lines;\n}\n\nsub extract_formatted_signatures {\n    my (@signature_lines) = @_;\n\n    my @type = @signature_lines;\n\n    s/\\s*(.*):.*/$1/ for (@type);\n\n    # cut -f2- -d\":\"\n    s/\\s*.*:\\s*(.+)\\s*/$1/ for (@signature_lines);\n\n## Reformat email addresses (with names) to avoid badly written signatures\n\n    foreach my $signer (@signature_lines) {\n\t$signer = deduplicate_email($signer);\n    }\n\n    return (\\@type, \\@signature_lines);\n}\n\nsub vcs_find_signers {\n    my ($cmd, $file) = @_;\n    my $commits;\n    my @lines = ();\n    my @signatures = ();\n    my @authors = ();\n    my @stats = ();\n\n    @lines = &{$VCS_cmds{\"execute_cmd\"}}($cmd);\n\n    my $pattern = $VCS_cmds{\"commit_pattern\"};\n    my $author_pattern = $VCS_cmds{\"author_pattern\"};\n    my $stat_pattern = $VCS_cmds{\"stat_pattern\"};\n\n    $stat_pattern =~ s/(\\$\\w+)/$1/eeg;\t\t#interpolate $stat_pattern\n\n    $commits = grep(/$pattern/, @lines);\t# of commits\n\n    @authors = grep(/$author_pattern/, @lines);\n    @signatures = grep(/^[ \\t]*${signature_pattern}.*\\@.*$/, @lines);\n    @stats = grep(/$stat_pattern/, @lines);\n\n#    print(\"stats: <@stats>\\n\");\n\n    return (0, \\@signatures, \\@authors, \\@stats) if !@signatures;\n\n    save_commits_by_author(@lines) if ($interactive);\n    save_commits_by_signer(@lines) if ($interactive);\n\n    if (!$email_git_penguin_chiefs) {\n\t@signatures = grep(!/${penguin_chiefs}/i, @signatures);\n    }\n\n    my ($author_ref, $authors_ref) = extract_formatted_signatures(@authors);\n    my ($types_ref, $signers_ref) = extract_formatted_signatures(@signatures);\n\n    return ($commits, $signers_ref, $authors_ref, \\@stats);\n}\n\nsub vcs_find_author {\n    my ($cmd) = @_;\n    my @lines = ();\n\n    @lines = &{$VCS_cmds{\"execute_cmd\"}}($cmd);\n\n    if (!$email_git_penguin_chiefs) {\n\t@lines = grep(!/${penguin_chiefs}/i, @lines);\n    }\n\n    return @lines if !@lines;\n\n    my @authors = ();\n    foreach my $line (@lines) {\n\tif ($line =~ m/$VCS_cmds{\"author_pattern\"}/) {\n\t    my $author = $1;\n\t    my ($name, $address) = parse_email($author);\n\t    $author = format_email($name, $address, 1);\n\t    push(@authors, $author);\n\t}\n    }\n\n    save_commits_by_author(@lines) if ($interactive);\n    save_commits_by_signer(@lines) if ($interactive);\n\n    return @authors;\n}\n\nsub vcs_save_commits {\n    my ($cmd) = @_;\n    my @lines = ();\n    my @commits = ();\n\n    @lines = &{$VCS_cmds{\"execute_cmd\"}}($cmd);\n\n    foreach my $line (@lines) {\n\tif ($line =~ m/$VCS_cmds{\"blame_commit_pattern\"}/) {\n\t    push(@commits, $1);\n\t}\n    }\n\n    return @commits;\n}\n\nsub vcs_blame {\n    my ($file) = @_;\n    my $cmd;\n    my @commits = ();\n\n    return @commits if (!(-f $file));\n\n    if (@range && $VCS_cmds{\"blame_range_cmd\"} eq \"\") {\n\tmy @all_commits = ();\n\n\t$cmd = $VCS_cmds{\"blame_file_cmd\"};\n\t$cmd =~ s/(\\$\\w+)/$1/eeg;\t\t#interpolate $cmd\n\t@all_commits = vcs_save_commits($cmd);\n\n\tforeach my $file_range_diff (@range) {\n\t    next if (!($file_range_diff =~ m/(.+):(.+):(.+)/));\n\t    my $diff_file = $1;\n\t    my $diff_start = $2;\n\t    my $diff_length = $3;\n\t    next if (\"$file\" ne \"$diff_file\");\n\t    for (my $i = $diff_start; $i < $diff_start + $diff_length; $i++) {\n\t\tpush(@commits, $all_commits[$i]);\n\t    }\n\t}\n    } elsif (@range) {\n\tforeach my $file_range_diff (@range) {\n\t    next if (!($file_range_diff =~ m/(.+):(.+):(.+)/));\n\t    my $diff_file = $1;\n\t    my $diff_start = $2;\n\t    my $diff_length = $3;\n\t    next if (\"$file\" ne \"$diff_file\");\n\t    $cmd = $VCS_cmds{\"blame_range_cmd\"};\n\t    $cmd =~ s/(\\$\\w+)/$1/eeg;\t\t#interpolate $cmd\n\t    push(@commits, vcs_save_commits($cmd));\n\t}\n    } else {\n\t$cmd = $VCS_cmds{\"blame_file_cmd\"};\n\t$cmd =~ s/(\\$\\w+)/$1/eeg;\t\t#interpolate $cmd\n\t@commits = vcs_save_commits($cmd);\n    }\n\n    foreach my $commit (@commits) {\n\t$commit =~ s/^\\^//g;\n    }\n\n    return @commits;\n}\n\nmy $printed_novcs = 0;\nsub vcs_exists {\n    %VCS_cmds = %VCS_cmds_git;\n    return 1 if eval $VCS_cmds{\"available\"};\n    %VCS_cmds = %VCS_cmds_hg;\n    return 2 if eval $VCS_cmds{\"available\"};\n    %VCS_cmds = ();\n    if (!$printed_novcs && $email_git) {\n\twarn(\"$P: No supported VCS found.  Add --nogit to options?\\n\");\n\twarn(\"Using a git repository produces better results.\\n\");\n\twarn(\"Try Linus Torvalds' latest git repository using:\\n\");\n\twarn(\"git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\\n\");\n\t$printed_novcs = 1;\n    }\n    return 0;\n}\n\nsub vcs_is_git {\n    vcs_exists();\n    return $vcs_used == 1;\n}\n\nsub vcs_is_hg {\n    return $vcs_used == 2;\n}\n\nsub vcs_add_commit_signers {\n    return if (!vcs_exists());\n\n    my ($commit, $desc) = @_;\n    my $commit_count = 0;\n    my $commit_authors_ref;\n    my $commit_signers_ref;\n    my $stats_ref;\n    my @commit_authors = ();\n    my @commit_signers = ();\n    my $cmd;\n\n    $cmd = $VCS_cmds{\"find_commit_signers_cmd\"};\n    $cmd =~ s/(\\$\\w+)/$1/eeg;\t#substitute variables in $cmd\n\n    ($commit_count, $commit_signers_ref, $commit_authors_ref, $stats_ref) = vcs_find_signers($cmd, \"\");\n    @commit_authors = @{$commit_authors_ref} if defined $commit_authors_ref;\n    @commit_signers = @{$commit_signers_ref} if defined $commit_signers_ref;\n\n    foreach my $signer (@commit_signers) {\n\t$signer = deduplicate_email($signer);\n    }\n\n    vcs_assign($desc, 1, @commit_signers);\n}\n\nsub interactive_get_maintainers {\n    my ($list_ref) = @_;\n    my @list = @$list_ref;\n\n    vcs_exists();\n\n    my %selected;\n    my %authored;\n    my %signed;\n    my $count = 0;\n    my $maintained = 0;\n    foreach my $entry (@list) {\n\t$maintained = 1 if ($entry->[1] =~ /^(maintainer|supporter)/i);\n\t$selected{$count} = 1;\n\t$authored{$count} = 0;\n\t$signed{$count} = 0;\n\t$count++;\n    }\n\n    #menu loop\n    my $done = 0;\n    my $print_options = 0;\n    my $redraw = 1;\n    while (!$done) {\n\t$count = 0;\n\tif ($redraw) {\n\t    printf STDERR \"\\n%1s %2s %-65s\",\n\t\t\t  \"*\", \"#\", \"email/list and role:stats\";\n\t    if ($email_git ||\n\t\t($email_git_fallback && !$maintained) ||\n\t\t$email_git_blame) {\n\t\tprint STDERR \"auth sign\";\n\t    }\n\t    print STDERR \"\\n\";\n\t    foreach my $entry (@list) {\n\t\tmy $email = $entry->[0];\n\t\tmy $role = $entry->[1];\n\t\tmy $sel = \"\";\n\t\t$sel = \"*\" if ($selected{$count});\n\t\tmy $commit_author = $commit_author_hash{$email};\n\t\tmy $commit_signer = $commit_signer_hash{$email};\n\t\tmy $authored = 0;\n\t\tmy $signed = 0;\n\t\t$authored++ for (@{$commit_author});\n\t\t$signed++ for (@{$commit_signer});\n\t\tprintf STDERR \"%1s %2d %-65s\", $sel, $count + 1, $email;\n\t\tprintf STDERR \"%4d %4d\", $authored, $signed\n\t\t    if ($authored > 0 || $signed > 0);\n\t\tprintf STDERR \"\\n     %s\\n\", $role;\n\t\tif ($authored{$count}) {\n\t\t    my $commit_author = $commit_author_hash{$email};\n\t\t    foreach my $ref (@{$commit_author}) {\n\t\t\tprint STDERR \"     Author: @{$ref}[1]\\n\";\n\t\t    }\n\t\t}\n\t\tif ($signed{$count}) {\n\t\t    my $commit_signer = $commit_signer_hash{$email};\n\t\t    foreach my $ref (@{$commit_signer}) {\n\t\t\tprint STDERR \"     @{$ref}[2]: @{$ref}[1]\\n\";\n\t\t    }\n\t\t}\n\n\t\t$count++;\n\t    }\n\t}\n\tmy $date_ref = \\$email_git_since;\n\t$date_ref = \\$email_hg_since if (vcs_is_hg());\n\tif ($print_options) {\n\t    $print_options = 0;\n\t    if (vcs_exists()) {\n\t\tprint STDERR <<EOT\n\nVersion Control options:\ng  use git history      [$email_git]\ngf use git-fallback     [$email_git_fallback]\nb  use git blame        [$email_git_blame]\nbs use blame signatures [$email_git_blame_signatures]\nc# minimum commits      [$email_git_min_signatures]\n%# min percent          [$email_git_min_percent]\nd# history to use       [$$date_ref]\nx# max maintainers      [$email_git_max_maintainers]\nt  all signature types  [$email_git_all_signature_types]\nm  use .mailmap         [$email_use_mailmap]\nEOT\n\t    }\n\t    print STDERR <<EOT\n\nAdditional options:\n0  toggle all\ntm toggle maintainers\ntg toggle git entries\ntl toggle open list entries\nts toggle subscriber list entries\nf  emails in file       [$email_file_emails]\nk  keywords in file     [$keywords]\nr  remove duplicates    [$email_remove_duplicates]\np# pattern match depth  [$pattern_depth]\nEOT\n\t}\n\tprint STDERR\n\"\\n#(toggle), A#(author), S#(signed) *(all), ^(none), O(options), Y(approve): \";\n\n\tmy $input = <STDIN>;\n\tchomp($input);\n\n\t$redraw = 1;\n\tmy $rerun = 0;\n\tmy @wish = split(/[, ]+/, $input);\n\tforeach my $nr (@wish) {\n\t    $nr = lc($nr);\n\t    my $sel = substr($nr, 0, 1);\n\t    my $str = substr($nr, 1);\n\t    my $val = 0;\n\t    $val = $1 if $str =~ /^(\\d+)$/;\n\n\t    if ($sel eq \"y\") {\n\t\t$interactive = 0;\n\t\t$done = 1;\n\t\t$output_rolestats = 0;\n\t\t$output_roles = 0;\n\t\tlast;\n\t    } elsif ($nr =~ /^\\d+$/ && $nr > 0 && $nr <= $count) {\n\t\t$selected{$nr - 1} = !$selected{$nr - 1};\n\t    } elsif ($sel eq \"*\" || $sel eq '^') {\n\t\tmy $toggle = 0;\n\t\t$toggle = 1 if ($sel eq '*');\n\t\tfor (my $i = 0; $i < $count; $i++) {\n\t\t    $selected{$i} = $toggle;\n\t\t}\n\t    } elsif ($sel eq \"0\") {\n\t\tfor (my $i = 0; $i < $count; $i++) {\n\t\t    $selected{$i} = !$selected{$i};\n\t\t}\n\t    } elsif ($sel eq \"t\") {\n\t\tif (lc($str) eq \"m\") {\n\t\t    for (my $i = 0; $i < $count; $i++) {\n\t\t\t$selected{$i} = !$selected{$i}\n\t\t\t    if ($list[$i]->[1] =~ /^(maintainer|supporter)/i);\n\t\t    }\n\t\t} elsif (lc($str) eq \"g\") {\n\t\t    for (my $i = 0; $i < $count; $i++) {\n\t\t\t$selected{$i} = !$selected{$i}\n\t\t\t    if ($list[$i]->[1] =~ /^(author|commit|signer)/i);\n\t\t    }\n\t\t} elsif (lc($str) eq \"l\") {\n\t\t    for (my $i = 0; $i < $count; $i++) {\n\t\t\t$selected{$i} = !$selected{$i}\n\t\t\t    if ($list[$i]->[1] =~ /^(open list)/i);\n\t\t    }\n\t\t} elsif (lc($str) eq \"s\") {\n\t\t    for (my $i = 0; $i < $count; $i++) {\n\t\t\t$selected{$i} = !$selected{$i}\n\t\t\t    if ($list[$i]->[1] =~ /^(subscriber list)/i);\n\t\t    }\n\t\t}\n\t    } elsif ($sel eq \"a\") {\n\t\tif ($val > 0 && $val <= $count) {\n\t\t    $authored{$val - 1} = !$authored{$val - 1};\n\t\t} elsif ($str eq '*' || $str eq '^') {\n\t\t    my $toggle = 0;\n\t\t    $toggle = 1 if ($str eq '*');\n\t\t    for (my $i = 0; $i < $count; $i++) {\n\t\t\t$authored{$i} = $toggle;\n\t\t    }\n\t\t}\n\t    } elsif ($sel eq \"s\") {\n\t\tif ($val > 0 && $val <= $count) {\n\t\t    $signed{$val - 1} = !$signed{$val - 1};\n\t\t} elsif ($str eq '*' || $str eq '^') {\n\t\t    my $toggle = 0;\n\t\t    $toggle = 1 if ($str eq '*');\n\t\t    for (my $i = 0; $i < $count; $i++) {\n\t\t\t$signed{$i} = $toggle;\n\t\t    }\n\t\t}\n\t    } elsif ($sel eq \"o\") {\n\t\t$print_options = 1;\n\t\t$redraw = 1;\n\t    } elsif ($sel eq \"g\") {\n\t\tif ($str eq \"f\") {\n\t\t    bool_invert(\\$email_git_fallback);\n\t\t} else {\n\t\t    bool_invert(\\$email_git);\n\t\t}\n\t\t$rerun = 1;\n\t    } elsif ($sel eq \"b\") {\n\t\tif ($str eq \"s\") {\n\t\t    bool_invert(\\$email_git_blame_signatures);\n\t\t} else {\n\t\t    bool_invert(\\$email_git_blame);\n\t\t}\n\t\t$rerun = 1;\n\t    } elsif ($sel eq \"c\") {\n\t\tif ($val > 0) {\n\t\t    $email_git_min_signatures = $val;\n\t\t    $rerun = 1;\n\t\t}\n\t    } elsif ($sel eq \"x\") {\n\t\tif ($val > 0) {\n\t\t    $email_git_max_maintainers = $val;\n\t\t    $rerun = 1;\n\t\t}\n\t    } elsif ($sel eq \"%\") {\n\t\tif ($str ne \"\" && $val >= 0) {\n\t\t    $email_git_min_percent = $val;\n\t\t    $rerun = 1;\n\t\t}\n\t    } elsif ($sel eq \"d\") {\n\t\tif (vcs_is_git()) {\n\t\t    $email_git_since = $str;\n\t\t} elsif (vcs_is_hg()) {\n\t\t    $email_hg_since = $str;\n\t\t}\n\t\t$rerun = 1;\n\t    } elsif ($sel eq \"t\") {\n\t\tbool_invert(\\$email_git_all_signature_types);\n\t\t$rerun = 1;\n\t    } elsif ($sel eq \"f\") {\n\t\tbool_invert(\\$email_file_emails);\n\t\t$rerun = 1;\n\t    } elsif ($sel eq \"r\") {\n\t\tbool_invert(\\$email_remove_duplicates);\n\t\t$rerun = 1;\n\t    } elsif ($sel eq \"m\") {\n\t\tbool_invert(\\$email_use_mailmap);\n\t\tread_mailmap();\n\t\t$rerun = 1;\n\t    } elsif ($sel eq \"k\") {\n\t\tbool_invert(\\$keywords);\n\t\t$rerun = 1;\n\t    } elsif ($sel eq \"p\") {\n\t\tif ($str ne \"\" && $val >= 0) {\n\t\t    $pattern_depth = $val;\n\t\t    $rerun = 1;\n\t\t}\n\t    } elsif ($sel eq \"h\" || $sel eq \"?\") {\n\t\tprint STDERR <<EOT\n\nInteractive mode allows you to select the various maintainers, submitters,\ncommit signers and mailing lists that could be CC'd on a patch.\n\nAny *'d entry is selected.\n\nIf you have git or hg installed, you can choose to summarize the commit\nhistory of files in the patch.  Also, each line of the current file can\nbe matched to its commit author and that commits signers with blame.\n\nVarious knobs exist to control the length of time for active commit\ntracking, the maximum number of commit authors and signers to add,\nand such.\n\nEnter selections at the prompt until you are satisfied that the selected\nmaintainers are appropriate.  You may enter multiple selections separated\nby either commas or spaces.\n\nEOT\n\t    } else {\n\t\tprint STDERR \"invalid option: '$nr'\\n\";\n\t\t$redraw = 0;\n\t    }\n\t}\n\tif ($rerun) {\n\t    print STDERR \"git-blame can be very slow, please have patience...\"\n\t\tif ($email_git_blame);\n\t    goto &get_maintainers;\n\t}\n    }\n\n    #drop not selected entries\n    $count = 0;\n    my @new_emailto = ();\n    foreach my $entry (@list) {\n\tif ($selected{$count}) {\n\t    push(@new_emailto, $list[$count]);\n\t}\n\t$count++;\n    }\n    return @new_emailto;\n}\n\nsub bool_invert {\n    my ($bool_ref) = @_;\n\n    if ($$bool_ref) {\n\t$$bool_ref = 0;\n    } else {\n\t$$bool_ref = 1;\n    }\n}\n\nsub deduplicate_email {\n    my ($email) = @_;\n\n    my $matched = 0;\n    my ($name, $address) = parse_email($email);\n    $email = format_email($name, $address, 1);\n    $email = mailmap_email($email);\n\n    return $email if (!$email_remove_duplicates);\n\n    ($name, $address) = parse_email($email);\n\n    if ($name ne \"\" && $deduplicate_name_hash{lc($name)}) {\n\t$name = $deduplicate_name_hash{lc($name)}->[0];\n\t$address = $deduplicate_name_hash{lc($name)}->[1];\n\t$matched = 1;\n    } elsif ($deduplicate_address_hash{lc($address)}) {\n\t$name = $deduplicate_address_hash{lc($address)}->[0];\n\t$address = $deduplicate_address_hash{lc($address)}->[1];\n\t$matched = 1;\n    }\n    if (!$matched) {\n\t$deduplicate_name_hash{lc($name)} = [ $name, $address ];\n\t$deduplicate_address_hash{lc($address)} = [ $name, $address ];\n    }\n    $email = format_email($name, $address, 1);\n    $email = mailmap_email($email);\n    return $email;\n}\n\nsub save_commits_by_author {\n    my (@lines) = @_;\n\n    my @authors = ();\n    my @commits = ();\n    my @subjects = ();\n\n    foreach my $line (@lines) {\n\tif ($line =~ m/$VCS_cmds{\"author_pattern\"}/) {\n\t    my $author = $1;\n\t    $author = deduplicate_email($author);\n\t    push(@authors, $author);\n\t}\n\tpush(@commits, $1) if ($line =~ m/$VCS_cmds{\"commit_pattern\"}/);\n\tpush(@subjects, $1) if ($line =~ m/$VCS_cmds{\"subject_pattern\"}/);\n    }\n\n    for (my $i = 0; $i < @authors; $i++) {\n\tmy $exists = 0;\n\tforeach my $ref(@{$commit_author_hash{$authors[$i]}}) {\n\t    if (@{$ref}[0] eq $commits[$i] &&\n\t\t@{$ref}[1] eq $subjects[$i]) {\n\t\t$exists = 1;\n\t\tlast;\n\t    }\n\t}\n\tif (!$exists) {\n\t    push(@{$commit_author_hash{$authors[$i]}},\n\t\t [ ($commits[$i], $subjects[$i]) ]);\n\t}\n    }\n}\n\nsub save_commits_by_signer {\n    my (@lines) = @_;\n\n    my $commit = \"\";\n    my $subject = \"\";\n\n    foreach my $line (@lines) {\n\t$commit = $1 if ($line =~ m/$VCS_cmds{\"commit_pattern\"}/);\n\t$subject = $1 if ($line =~ m/$VCS_cmds{\"subject_pattern\"}/);\n\tif ($line =~ /^[ \\t]*${signature_pattern}.*\\@.*$/) {\n\t    my @signatures = ($line);\n\t    my ($types_ref, $signers_ref) = extract_formatted_signatures(@signatures);\n\t    my @types = @$types_ref;\n\t    my @signers = @$signers_ref;\n\n\t    my $type = $types[0];\n\t    my $signer = $signers[0];\n\n\t    $signer = deduplicate_email($signer);\n\n\t    my $exists = 0;\n\t    foreach my $ref(@{$commit_signer_hash{$signer}}) {\n\t\tif (@{$ref}[0] eq $commit &&\n\t\t    @{$ref}[1] eq $subject &&\n\t\t    @{$ref}[2] eq $type) {\n\t\t    $exists = 1;\n\t\t    last;\n\t\t}\n\t    }\n\t    if (!$exists) {\n\t\tpush(@{$commit_signer_hash{$signer}},\n\t\t     [ ($commit, $subject, $type) ]);\n\t    }\n\t}\n    }\n}\n\nsub vcs_assign {\n    my ($role, $divisor, @lines) = @_;\n\n    my %hash;\n    my $count = 0;\n\n    return if (@lines <= 0);\n\n    if ($divisor <= 0) {\n\twarn(\"Bad divisor in \" . (caller(0))[3] . \": $divisor\\n\");\n\t$divisor = 1;\n    }\n\n    @lines = mailmap(@lines);\n\n    return if (@lines <= 0);\n\n    @lines = sort(@lines);\n\n    # uniq -c\n    $hash{$_}++ for @lines;\n\n    # sort -rn\n    foreach my $line (sort {$hash{$b} <=> $hash{$a}} keys %hash) {\n\tmy $sign_offs = $hash{$line};\n\tmy $percent = $sign_offs * 100 / $divisor;\n\n\t$percent = 100 if ($percent > 100);\n\tnext if (ignore_email_address($line));\n\t$count++;\n\tlast if ($sign_offs < $email_git_min_signatures ||\n\t\t $count > $email_git_max_maintainers ||\n\t\t $percent < $email_git_min_percent);\n\tpush_email_address($line, '');\n\tif ($output_rolestats) {\n\t    my $fmt_percent = sprintf(\"%.0f\", $percent);\n\t    add_role($line, \"$role:$sign_offs/$divisor=$fmt_percent%\");\n\t} else {\n\t    add_role($line, $role);\n\t}\n    }\n}\n\nsub vcs_file_signoffs {\n    my ($file) = @_;\n\n    my $authors_ref;\n    my $signers_ref;\n    my $stats_ref;\n    my @authors = ();\n    my @signers = ();\n    my @stats = ();\n    my $commits;\n\n    $vcs_used = vcs_exists();\n    return if (!$vcs_used);\n\n    my $cmd = $VCS_cmds{\"find_signers_cmd\"};\n    $cmd =~ s/(\\$\\w+)/$1/eeg;\t\t# interpolate $cmd\n\n    ($commits, $signers_ref, $authors_ref, $stats_ref) = vcs_find_signers($cmd, $file);\n\n    @signers = @{$signers_ref} if defined $signers_ref;\n    @authors = @{$authors_ref} if defined $authors_ref;\n    @stats = @{$stats_ref} if defined $stats_ref;\n\n#    print(\"commits: <$commits>\\nsigners:<@signers>\\nauthors: <@authors>\\nstats: <@stats>\\n\");\n\n    foreach my $signer (@signers) {\n\t$signer = deduplicate_email($signer);\n    }\n\n    vcs_assign(\"commit_signer\", $commits, @signers);\n    vcs_assign(\"authored\", $commits, @authors);\n    if ($#authors == $#stats) {\n\tmy $stat_pattern = $VCS_cmds{\"stat_pattern\"};\n\t$stat_pattern =~ s/(\\$\\w+)/$1/eeg;\t#interpolate $stat_pattern\n\n\tmy $added = 0;\n\tmy $deleted = 0;\n\tfor (my $i = 0; $i <= $#stats; $i++) {\n\t    if ($stats[$i] =~ /$stat_pattern/) {\n\t\t$added += $1;\n\t\t$deleted += $2;\n\t    }\n\t}\n\tmy @tmp_authors = uniq(@authors);\n\tforeach my $author (@tmp_authors) {\n\t    $author = deduplicate_email($author);\n\t}\n\t@tmp_authors = uniq(@tmp_authors);\n\tmy @list_added = ();\n\tmy @list_deleted = ();\n\tforeach my $author (@tmp_authors) {\n\t    my $auth_added = 0;\n\t    my $auth_deleted = 0;\n\t    for (my $i = 0; $i <= $#stats; $i++) {\n\t\tif ($author eq deduplicate_email($authors[$i]) &&\n\t\t    $stats[$i] =~ /$stat_pattern/) {\n\t\t    $auth_added += $1;\n\t\t    $auth_deleted += $2;\n\t\t}\n\t    }\n\t    for (my $i = 0; $i < $auth_added; $i++) {\n\t\tpush(@list_added, $author);\n\t    }\n\t    for (my $i = 0; $i < $auth_deleted; $i++) {\n\t\tpush(@list_deleted, $author);\n\t    }\n\t}\n\tvcs_assign(\"added_lines\", $added, @list_added);\n\tvcs_assign(\"removed_lines\", $deleted, @list_deleted);\n    }\n}\n\nsub vcs_file_blame {\n    my ($file) = @_;\n\n    my @signers = ();\n    my @all_commits = ();\n    my @commits = ();\n    my $total_commits;\n    my $total_lines;\n\n    $vcs_used = vcs_exists();\n    return if (!$vcs_used);\n\n    @all_commits = vcs_blame($file);\n    @commits = uniq(@all_commits);\n    $total_commits = @commits;\n    $total_lines = @all_commits;\n\n    if ($email_git_blame_signatures) {\n\tif (vcs_is_hg()) {\n\t    my $commit_count;\n\t    my $commit_authors_ref;\n\t    my $commit_signers_ref;\n\t    my $stats_ref;\n\t    my @commit_authors = ();\n\t    my @commit_signers = ();\n\t    my $commit = join(\" -r \", @commits);\n\t    my $cmd;\n\n\t    $cmd = $VCS_cmds{\"find_commit_signers_cmd\"};\n\t    $cmd =~ s/(\\$\\w+)/$1/eeg;\t#substitute variables in $cmd\n\n\t    ($commit_count, $commit_signers_ref, $commit_authors_ref, $stats_ref) = vcs_find_signers($cmd, $file);\n\t    @commit_authors = @{$commit_authors_ref} if defined $commit_authors_ref;\n\t    @commit_signers = @{$commit_signers_ref} if defined $commit_signers_ref;\n\n\t    push(@signers, @commit_signers);\n\t} else {\n\t    foreach my $commit (@commits) {\n\t\tmy $commit_count;\n\t\tmy $commit_authors_ref;\n\t\tmy $commit_signers_ref;\n\t\tmy $stats_ref;\n\t\tmy @commit_authors = ();\n\t\tmy @commit_signers = ();\n\t\tmy $cmd;\n\n\t\t$cmd = $VCS_cmds{\"find_commit_signers_cmd\"};\n\t\t$cmd =~ s/(\\$\\w+)/$1/eeg;\t#substitute variables in $cmd\n\n\t\t($commit_count, $commit_signers_ref, $commit_authors_ref, $stats_ref) = vcs_find_signers($cmd, $file);\n\t\t@commit_authors = @{$commit_authors_ref} if defined $commit_authors_ref;\n\t\t@commit_signers = @{$commit_signers_ref} if defined $commit_signers_ref;\n\n\t\tpush(@signers, @commit_signers);\n\t    }\n\t}\n    }\n\n    if ($from_filename) {\n\tif ($output_rolestats) {\n\t    my @blame_signers;\n\t    if (vcs_is_hg()) {{\t\t# Double brace for last exit\n\t\tmy $commit_count;\n\t\tmy @commit_signers = ();\n\t\t@commits = uniq(@commits);\n\t\t@commits = sort(@commits);\n\t\tmy $commit = join(\" -r \", @commits);\n\t\tmy $cmd;\n\n\t\t$cmd = $VCS_cmds{\"find_commit_author_cmd\"};\n\t\t$cmd =~ s/(\\$\\w+)/$1/eeg;\t#substitute variables in $cmd\n\n\t\tmy @lines = ();\n\n\t\t@lines = &{$VCS_cmds{\"execute_cmd\"}}($cmd);\n\n\t\tif (!$email_git_penguin_chiefs) {\n\t\t    @lines = grep(!/${penguin_chiefs}/i, @lines);\n\t\t}\n\n\t\tlast if !@lines;\n\n\t\tmy @authors = ();\n\t\tforeach my $line (@lines) {\n\t\t    if ($line =~ m/$VCS_cmds{\"author_pattern\"}/) {\n\t\t\tmy $author = $1;\n\t\t\t$author = deduplicate_email($author);\n\t\t\tpush(@authors, $author);\n\t\t    }\n\t\t}\n\n\t\tsave_commits_by_author(@lines) if ($interactive);\n\t\tsave_commits_by_signer(@lines) if ($interactive);\n\n\t\tpush(@signers, @authors);\n\t    }}\n\t    else {\n\t\tforeach my $commit (@commits) {\n\t\t    my $i;\n\t\t    my $cmd = $VCS_cmds{\"find_commit_author_cmd\"};\n\t\t    $cmd =~ s/(\\$\\w+)/$1/eeg;\t#interpolate $cmd\n\t\t    my @author = vcs_find_author($cmd);\n\t\t    next if !@author;\n\n\t\t    my $formatted_author = deduplicate_email($author[0]);\n\n\t\t    my $count = grep(/$commit/, @all_commits);\n\t\t    for ($i = 0; $i < $count ; $i++) {\n\t\t\tpush(@blame_signers, $formatted_author);\n\t\t    }\n\t\t}\n\t    }\n\t    if (@blame_signers) {\n\t\tvcs_assign(\"authored lines\", $total_lines, @blame_signers);\n\t    }\n\t}\n\tforeach my $signer (@signers) {\n\t    $signer = deduplicate_email($signer);\n\t}\n\tvcs_assign(\"commits\", $total_commits, @signers);\n    } else {\n\tforeach my $signer (@signers) {\n\t    $signer = deduplicate_email($signer);\n\t}\n\tvcs_assign(\"modified commits\", $total_commits, @signers);\n    }\n}\n\nsub vcs_file_exists {\n    my ($file) = @_;\n\n    my $exists;\n\n    my $vcs_used = vcs_exists();\n    return 0 if (!$vcs_used);\n\n    my $cmd = $VCS_cmds{\"file_exists_cmd\"};\n    $cmd =~ s/(\\$\\w+)/$1/eeg;\t\t# interpolate $cmd\n    $cmd .= \" 2>&1\";\n    $exists = &{$VCS_cmds{\"execute_cmd\"}}($cmd);\n\n    return 0 if ($? != 0);\n\n    return $exists;\n}\n\nsub vcs_list_files {\n    my ($file) = @_;\n\n    my @lsfiles = ();\n\n    my $vcs_used = vcs_exists();\n    return 0 if (!$vcs_used);\n\n    my $cmd = $VCS_cmds{\"list_files_cmd\"};\n    $cmd =~ s/(\\$\\w+)/$1/eeg;   # interpolate $cmd\n    @lsfiles = &{$VCS_cmds{\"execute_cmd\"}}($cmd);\n\n    return () if ($? != 0);\n\n    return @lsfiles;\n}\n\nsub uniq {\n    my (@parms) = @_;\n\n    my %saw;\n    @parms = grep(!$saw{$_}++, @parms);\n    return @parms;\n}\n\nsub sort_and_uniq {\n    my (@parms) = @_;\n\n    my %saw;\n    @parms = sort @parms;\n    @parms = grep(!$saw{$_}++, @parms);\n    return @parms;\n}\n\nsub clean_file_emails {\n    my (@file_emails) = @_;\n    my @fmt_emails = ();\n\n    foreach my $email (@file_emails) {\n\t$email =~ s/[\\(\\<\\{]{0,1}([A-Za-z0-9_\\.\\+-]+\\@[A-Za-z0-9\\.-]+)[\\)\\>\\}]{0,1}/\\<$1\\>/g;\n\tmy ($name, $address) = parse_email($email);\n\tif ($name eq '\"[,\\.]\"') {\n\t    $name = \"\";\n\t}\n\n\tmy @nw = split(/[^A-Za-z\u00c0-\u00ff\\'\\,\\.\\+-]/, $name);\n\tif (@nw > 2) {\n\t    my $first = $nw[@nw - 3];\n\t    my $middle = $nw[@nw - 2];\n\t    my $last = $nw[@nw - 1];\n\n\t    if (((length($first) == 1 && $first =~ m/[A-Za-z]/) ||\n\t\t (length($first) == 2 && substr($first, -1) eq \".\")) ||\n\t\t(length($middle) == 1 ||\n\t\t (length($middle) == 2 && substr($middle, -1) eq \".\"))) {\n\t\t$name = \"$first $middle $last\";\n\t    } else {\n\t\t$name = \"$middle $last\";\n\t    }\n\t}\n\n\tif (substr($name, -1) =~ /[,\\.]/) {\n\t    $name = substr($name, 0, length($name) - 1);\n\t} elsif (substr($name, -2) =~ /[,\\.]\"/) {\n\t    $name = substr($name, 0, length($name) - 2) . '\"';\n\t}\n\n\tif (substr($name, 0, 1) =~ /[,\\.]/) {\n\t    $name = substr($name, 1, length($name) - 1);\n\t} elsif (substr($name, 0, 2) =~ /\"[,\\.]/) {\n\t    $name = '\"' . substr($name, 2, length($name) - 2);\n\t}\n\n\tmy $fmt_email = format_email($name, $address, $email_usename);\n\tpush(@fmt_emails, $fmt_email);\n    }\n    return @fmt_emails;\n}\n\nsub merge_email {\n    my @lines;\n    my %saw;\n\n    for (@_) {\n\tmy ($address, $role) = @$_;\n\tif (!$saw{$address}) {\n\t    if ($output_roles) {\n\t\tpush(@lines, \"$address ($role)\");\n\t    } else {\n\t\tpush(@lines, $address);\n\t    }\n\t    $saw{$address} = 1;\n\t}\n    }\n\n    return @lines;\n}\n\nsub output {\n    my (@parms) = @_;\n\n    if ($output_multiline) {\n\tforeach my $line (@parms) {\n\t    print(\"${line}\\n\");\n\t}\n    } else {\n\tprint(join($output_separator, @parms));\n\tprint(\"\\n\");\n    }\n}\n\nmy $rfc822re;\n\nsub make_rfc822re {\n#   Basic lexical tokens are specials, domain_literal, quoted_string, atom, and\n#   comment.  We must allow for rfc822_lwsp (or comments) after each of these.\n#   This regexp will only work on addresses which have had comments stripped\n#   and replaced with rfc822_lwsp.\n\n    my $specials = '()<>@,;:\\\\\\\\\".\\\\[\\\\]';\n    my $controls = '\\\\000-\\\\037\\\\177';\n\n    my $dtext = \"[^\\\\[\\\\]\\\\r\\\\\\\\]\";\n    my $domain_literal = \"\\\\[(?:$dtext|\\\\\\\\.)*\\\\]$rfc822_lwsp*\";\n\n    my $quoted_string = \"\\\"(?:[^\\\\\\\"\\\\r\\\\\\\\]|\\\\\\\\.|$rfc822_lwsp)*\\\"$rfc822_lwsp*\";\n\n#   Use zero-width assertion to spot the limit of an atom.  A simple\n#   $rfc822_lwsp* causes the regexp engine to hang occasionally.\n    my $atom = \"[^$specials $controls]+(?:$rfc822_lwsp+|\\\\Z|(?=[\\\\[\\\"$specials]))\";\n    my $word = \"(?:$atom|$quoted_string)\";\n    my $localpart = \"$word(?:\\\\.$rfc822_lwsp*$word)*\";\n\n    my $sub_domain = \"(?:$atom|$domain_literal)\";\n    my $domain = \"$sub_domain(?:\\\\.$rfc822_lwsp*$sub_domain)*\";\n\n    my $addr_spec = \"$localpart\\@$rfc822_lwsp*$domain\";\n\n    my $phrase = \"$word*\";\n    my $route = \"(?:\\@$domain(?:,\\@$rfc822_lwsp*$domain)*:$rfc822_lwsp*)\";\n    my $route_addr = \"\\\\<$rfc822_lwsp*$route?$addr_spec\\\\>$rfc822_lwsp*\";\n    my $mailbox = \"(?:$addr_spec|$phrase$route_addr)\";\n\n    my $group = \"$phrase:$rfc822_lwsp*(?:$mailbox(?:,\\\\s*$mailbox)*)?;\\\\s*\";\n    my $address = \"(?:$mailbox|$group)\";\n\n    return \"$rfc822_lwsp*$address\";\n}\n\nsub rfc822_strip_comments {\n    my $s = shift;\n#   Recursively remove comments, and replace with a single space.  The simpler\n#   regexps in the Email Addressing FAQ are imperfect - they will miss escaped\n#   chars in atoms, for example.\n\n    while ($s =~ s/^((?:[^\"\\\\]|\\\\.)*\n                    (?:\"(?:[^\"\\\\]|\\\\.)*\"(?:[^\"\\\\]|\\\\.)*)*)\n                    \\((?:[^()\\\\]|\\\\.)*\\)/$1 /osx) {}\n    return $s;\n}\n\n#   valid: returns true if the parameter is an RFC822 valid address\n#\nsub rfc822_valid {\n    my $s = rfc822_strip_comments(shift);\n\n    if (!$rfc822re) {\n        $rfc822re = make_rfc822re();\n    }\n\n    return $s =~ m/^$rfc822re$/so && $s =~ m/^$rfc822_char*$/;\n}\n\n#   validlist: In scalar context, returns true if the parameter is an RFC822\n#              valid list of addresses.\n#\n#              In list context, returns an empty list on failure (an invalid\n#              address was found); otherwise a list whose first element is the\n#              number of addresses found and whose remaining elements are the\n#              addresses.  This is needed to disambiguate failure (invalid)\n#              from success with no addresses found, because an empty string is\n#              a valid list.\n\nsub rfc822_validlist {\n    my $s = rfc822_strip_comments(shift);\n\n    if (!$rfc822re) {\n        $rfc822re = make_rfc822re();\n    }\n    # * null list items are valid according to the RFC\n    # * the '1' business is to aid in distinguishing failure from no results\n\n    my @r;\n    if ($s =~ m/^(?:$rfc822re)?(?:,(?:$rfc822re)?)*$/so &&\n\t$s =~ m/^$rfc822_char*$/) {\n        while ($s =~ m/(?:^|,$rfc822_lwsp*)($rfc822re)/gos) {\n            push(@r, $1);\n        }\n        return wantarray ? (scalar(@r), @r) : 1;\n    }\n    return wantarray ? () : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}