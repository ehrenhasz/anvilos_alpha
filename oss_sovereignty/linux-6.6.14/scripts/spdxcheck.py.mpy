{
  "module_name": "spdxcheck.py",
  "hash_id": "104d6363a54ef25ad2e0cb9641878f8d017cfbb072e7465653de2da7a3dd47fb",
  "original_prompt": "Ingested from linux-6.6.14/scripts/spdxcheck.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n# Copyright Thomas Gleixner <tglx@linutronix.de>\n\nfrom argparse import ArgumentParser\nfrom ply import lex, yacc\nimport locale\nimport traceback\nimport fnmatch\nimport sys\nimport git\nimport re\nimport os\n\nclass ParserException(Exception):\n    def __init__(self, tok, txt):\n        self.tok = tok\n        self.txt = txt\n\nclass SPDXException(Exception):\n    def __init__(self, el, txt):\n        self.el = el\n        self.txt = txt\n\nclass SPDXdata(object):\n    def __init__(self):\n        self.license_files = 0\n        self.exception_files = 0\n        self.licenses = [ ]\n        self.exceptions = { }\n\nclass dirinfo(object):\n    def __init__(self):\n        self.missing = 0\n        self.total = 0\n        self.files = []\n\n    def update(self, fname, basedir, miss):\n        self.total += 1\n        self.missing += miss\n        if miss:\n            fname = './' + fname\n            bdir = os.path.dirname(fname)\n            if bdir == basedir.rstrip('/'):\n                self.files.append(fname)\n\n# Read the spdx data from the LICENSES directory\ndef read_spdxdata(repo):\n\n    # The subdirectories of LICENSES in the kernel source\n    # Note: exceptions needs to be parsed as last directory.\n    license_dirs = [ \"preferred\", \"dual\", \"deprecated\", \"exceptions\" ]\n    lictree = repo.head.commit.tree['LICENSES']\n\n    spdx = SPDXdata()\n\n    for d in license_dirs:\n        for el in lictree[d].traverse():\n            if not os.path.isfile(el.path):\n                continue\n\n            exception = None\n            for l in open(el.path, encoding=\"utf-8\").readlines():\n                if l.startswith('Valid-License-Identifier:'):\n                    lid = l.split(':')[1].strip().upper()\n                    if lid in spdx.licenses:\n                        raise SPDXException(el, 'Duplicate License Identifier: %s' %lid)\n                    else:\n                        spdx.licenses.append(lid)\n\n                elif l.startswith('SPDX-Exception-Identifier:'):\n                    exception = l.split(':')[1].strip().upper()\n                    spdx.exceptions[exception] = []\n\n                elif l.startswith('SPDX-Licenses:'):\n                    for lic in l.split(':')[1].upper().strip().replace(' ', '').replace('\\t', '').split(','):\n                        if not lic in spdx.licenses:\n                            raise SPDXException(None, 'Exception %s missing license %s' %(exception, lic))\n                        spdx.exceptions[exception].append(lic)\n\n                elif l.startswith(\"License-Text:\"):\n                    if exception:\n                        if not len(spdx.exceptions[exception]):\n                            raise SPDXException(el, 'Exception %s is missing SPDX-Licenses' %exception)\n                        spdx.exception_files += 1\n                    else:\n                        spdx.license_files += 1\n                    break\n    return spdx\n\nclass id_parser(object):\n\n    reserved = [ 'AND', 'OR', 'WITH' ]\n    tokens = [ 'LPAR', 'RPAR', 'ID', 'EXC' ] + reserved\n\n    precedence = ( ('nonassoc', 'AND', 'OR'), )\n\n    t_ignore = ' \\t'\n\n    def __init__(self, spdx):\n        self.spdx = spdx\n        self.lasttok = None\n        self.lastid = None\n        self.lexer = lex.lex(module = self, reflags = re.UNICODE)\n        # Initialize the parser. No debug file and no parser rules stored on disk\n        # The rules are small enough to be generated on the fly\n        self.parser = yacc.yacc(module = self, write_tables = False, debug = False)\n        self.lines_checked = 0\n        self.checked = 0\n        self.excluded = 0\n        self.spdx_valid = 0\n        self.spdx_errors = 0\n        self.spdx_dirs = {}\n        self.dirdepth = -1\n        self.basedir = '.'\n        self.curline = 0\n        self.deepest = 0\n\n    def set_dirinfo(self, basedir, dirdepth):\n        if dirdepth >= 0:\n            self.basedir = basedir\n            bdir = basedir.lstrip('./').rstrip('/')\n            if bdir != '':\n                parts = bdir.split('/')\n            else:\n                parts = []\n            self.dirdepth = dirdepth + len(parts)\n\n    # Validate License and Exception IDs\n    def validate(self, tok):\n        id = tok.value.upper()\n        if tok.type == 'ID':\n            if not id in self.spdx.licenses:\n                raise ParserException(tok, 'Invalid License ID')\n            self.lastid = id\n        elif tok.type == 'EXC':\n            if id not in self.spdx.exceptions:\n                raise ParserException(tok, 'Invalid Exception ID')\n            if self.lastid not in self.spdx.exceptions[id]:\n                raise ParserException(tok, 'Exception not valid for license %s' %self.lastid)\n            self.lastid = None\n        elif tok.type != 'WITH':\n            self.lastid = None\n\n    # Lexer functions\n    def t_RPAR(self, tok):\n        r'\\)'\n        self.lasttok = tok.type\n        return tok\n\n    def t_LPAR(self, tok):\n        r'\\('\n        self.lasttok = tok.type\n        return tok\n\n    def t_ID(self, tok):\n        r'[A-Za-z.0-9\\-+]+'\n\n        if self.lasttok == 'EXC':\n            print(tok)\n            raise ParserException(tok, 'Missing parentheses')\n\n        tok.value = tok.value.strip()\n        val = tok.value.upper()\n\n        if val in self.reserved:\n            tok.type = val\n        elif self.lasttok == 'WITH':\n            tok.type = 'EXC'\n\n        self.lasttok = tok.type\n        self.validate(tok)\n        return tok\n\n    def t_error(self, tok):\n        raise ParserException(tok, 'Invalid token')\n\n    def p_expr(self, p):\n        '''expr : ID\n                | ID WITH EXC\n                | expr AND expr\n                | expr OR expr\n                | LPAR expr RPAR'''\n        pass\n\n    def p_error(self, p):\n        if not p:\n            raise ParserException(None, 'Unfinished license expression')\n        else:\n            raise ParserException(p, 'Syntax error')\n\n    def parse(self, expr):\n        self.lasttok = None\n        self.lastid = None\n        self.parser.parse(expr, lexer = self.lexer)\n\n    def parse_lines(self, fd, maxlines, fname):\n        self.checked += 1\n        self.curline = 0\n        fail = 1\n        try:\n            for line in fd:\n                line = line.decode(locale.getpreferredencoding(False), errors='ignore')\n                self.curline += 1\n                if self.curline > maxlines:\n                    break\n                self.lines_checked += 1\n                if line.find(\"SPDX-License-Identifier:\") < 0:\n                    continue\n                expr = line.split(':')[1].strip()\n                # Remove trailing comment closure\n                if line.strip().endswith('*/'):\n                    expr = expr.rstrip('*/').strip()\n                # Remove trailing xml comment closure\n                if line.strip().endswith('-->'):\n                    expr = expr.rstrip('-->').strip()\n                # Special case for SH magic boot code files\n                if line.startswith('LIST \\\"'):\n                    expr = expr.rstrip('\\\"').strip()\n                self.parse(expr)\n                self.spdx_valid += 1\n                #\n                # Should we check for more SPDX ids in the same file and\n                # complain if there are any?\n                #\n                fail = 0\n                break\n\n        except ParserException as pe:\n            if pe.tok:\n                col = line.find(expr) + pe.tok.lexpos\n                tok = pe.tok.value\n                sys.stdout.write('%s: %d:%d %s: %s\\n' %(fname, self.curline, col, pe.txt, tok))\n            else:\n                sys.stdout.write('%s: %d:0 %s\\n' %(fname, self.curline, pe.txt))\n            self.spdx_errors += 1\n\n        if fname == '-':\n            return\n\n        base = os.path.dirname(fname)\n        if self.dirdepth > 0:\n            parts = base.split('/')\n            i = 0\n            base = '.'\n            while i < self.dirdepth and i < len(parts) and len(parts[i]):\n                base += '/' + parts[i]\n                i += 1\n        elif self.dirdepth == 0:\n            base = self.basedir\n        else:\n            base = './' + base.rstrip('/')\n        base += '/'\n\n        di = self.spdx_dirs.get(base, dirinfo())\n        di.update(fname, base, fail)\n        self.spdx_dirs[base] = di\n\nclass pattern(object):\n    def __init__(self, line):\n        self.pattern = line\n        self.match = self.match_file\n        if line == '.*':\n            self.match = self.match_dot\n        elif line.endswith('/'):\n            self.pattern = line[:-1]\n            self.match = self.match_dir\n        elif line.startswith('/'):\n            self.pattern = line[1:]\n            self.match = self.match_fn\n\n    def match_dot(self, fpath):\n        return os.path.basename(fpath).startswith('.')\n\n    def match_file(self, fpath):\n        return os.path.basename(fpath) == self.pattern\n\n    def match_fn(self, fpath):\n        return fnmatch.fnmatchcase(fpath, self.pattern)\n\n    def match_dir(self, fpath):\n        if self.match_fn(os.path.dirname(fpath)):\n            return True\n        return fpath.startswith(self.pattern)\n\ndef exclude_file(fpath):\n    for rule in exclude_rules:\n        if rule.match(fpath):\n            return True\n    return False\n\ndef scan_git_tree(tree, basedir, dirdepth):\n    parser.set_dirinfo(basedir, dirdepth)\n    for el in tree.traverse():\n        if not os.path.isfile(el.path):\n            continue\n        if exclude_file(el.path):\n            parser.excluded += 1\n            continue\n        with open(el.path, 'rb') as fd:\n            parser.parse_lines(fd, args.maxlines, el.path)\n\ndef scan_git_subtree(tree, path, dirdepth):\n    for p in path.strip('/').split('/'):\n        tree = tree[p]\n    scan_git_tree(tree, path.strip('/'), dirdepth)\n\ndef read_exclude_file(fname):\n    rules = []\n    if not fname:\n        return rules\n    with open(fname) as fd:\n        for line in fd:\n            line = line.strip()\n            if line.startswith('#'):\n                continue\n            if not len(line):\n                continue\n            rules.append(pattern(line))\n    return rules\n\nif __name__ == '__main__':\n\n    ap = ArgumentParser(description='SPDX expression checker')\n    ap.add_argument('path', nargs='*', help='Check path or file. If not given full git tree scan. For stdin use \"-\"')\n    ap.add_argument('-d', '--dirs', action='store_true',\n                    help='Show [sub]directory statistics.')\n    ap.add_argument('-D', '--depth', type=int, default=-1,\n                    help='Directory depth for -d statistics. Default: unlimited')\n    ap.add_argument('-e', '--exclude',\n                    help='File containing file patterns to exclude. Default: scripts/spdxexclude')\n    ap.add_argument('-f', '--files', action='store_true',\n                    help='Show files without SPDX.')\n    ap.add_argument('-m', '--maxlines', type=int, default=15,\n                    help='Maximum number of lines to scan in a file. Default 15')\n    ap.add_argument('-v', '--verbose', action='store_true', help='Verbose statistics output')\n    args = ap.parse_args()\n\n    # Sanity check path arguments\n    if '-' in args.path and len(args.path) > 1:\n        sys.stderr.write('stdin input \"-\" must be the only path argument\\n')\n        sys.exit(1)\n\n    try:\n        # Use git to get the valid license expressions\n        repo = git.Repo(os.getcwd())\n        assert not repo.bare\n\n        # Initialize SPDX data\n        spdx = read_spdxdata(repo)\n\n        # Initialize the parser\n        parser = id_parser(spdx)\n\n    except SPDXException as se:\n        if se.el:\n            sys.stderr.write('%s: %s\\n' %(se.el.path, se.txt))\n        else:\n            sys.stderr.write('%s\\n' %se.txt)\n        sys.exit(1)\n\n    except Exception as ex:\n        sys.stderr.write('FAIL: %s\\n' %ex)\n        sys.stderr.write('%s\\n' %traceback.format_exc())\n        sys.exit(1)\n\n    try:\n        fname = args.exclude\n        if not fname:\n            fname = os.path.join(os.path.dirname(__file__), 'spdxexclude')\n        exclude_rules = read_exclude_file(fname)\n    except Exception as ex:\n        sys.stderr.write('FAIL: Reading exclude file %s: %s\\n' %(fname, ex))\n        sys.exit(1)\n\n    try:\n        if len(args.path) and args.path[0] == '-':\n            stdin = os.fdopen(sys.stdin.fileno(), 'rb')\n            parser.parse_lines(stdin, args.maxlines, '-')\n        else:\n            if args.path:\n                for p in args.path:\n                    if os.path.isfile(p):\n                        parser.parse_lines(open(p, 'rb'), args.maxlines, p)\n                    elif os.path.isdir(p):\n                        scan_git_subtree(repo.head.reference.commit.tree, p,\n                                         args.depth)\n                    else:\n                        sys.stderr.write('path %s does not exist\\n' %p)\n                        sys.exit(1)\n            else:\n                # Full git tree scan\n                scan_git_tree(repo.head.commit.tree, '.', args.depth)\n\n            ndirs = len(parser.spdx_dirs)\n            dirsok = 0\n            if ndirs:\n                for di in parser.spdx_dirs.values():\n                    if not di.missing:\n                        dirsok += 1\n\n            if args.verbose:\n                sys.stderr.write('\\n')\n                sys.stderr.write('License files:     %12d\\n' %spdx.license_files)\n                sys.stderr.write('Exception files:   %12d\\n' %spdx.exception_files)\n                sys.stderr.write('License IDs        %12d\\n' %len(spdx.licenses))\n                sys.stderr.write('Exception IDs      %12d\\n' %len(spdx.exceptions))\n                sys.stderr.write('\\n')\n                sys.stderr.write('Files excluded:    %12d\\n' %parser.excluded)\n                sys.stderr.write('Files checked:     %12d\\n' %parser.checked)\n                sys.stderr.write('Lines checked:     %12d\\n' %parser.lines_checked)\n                if parser.checked:\n                    pc = int(100 * parser.spdx_valid / parser.checked)\n                    sys.stderr.write('Files with SPDX:   %12d %3d%%\\n' %(parser.spdx_valid, pc))\n                sys.stderr.write('Files with errors: %12d\\n' %parser.spdx_errors)\n                if ndirs:\n                    sys.stderr.write('\\n')\n                    sys.stderr.write('Directories accounted: %8d\\n' %ndirs)\n                    pc = int(100 * dirsok / ndirs)\n                    sys.stderr.write('Directories complete:  %8d %3d%%\\n' %(dirsok, pc))\n\n            if ndirs and ndirs != dirsok and args.dirs:\n                if args.verbose:\n                    sys.stderr.write('\\n')\n                sys.stderr.write('Incomplete directories: SPDX in Files\\n')\n                for f in sorted(parser.spdx_dirs.keys()):\n                    di = parser.spdx_dirs[f]\n                    if di.missing:\n                        valid = di.total - di.missing\n                        pc = int(100 * valid / di.total)\n                        sys.stderr.write('    %-80s: %5d of %5d  %3d%%\\n' %(f, valid, di.total, pc))\n\n            if ndirs and ndirs != dirsok and args.files:\n                if args.verbose or args.dirs:\n                    sys.stderr.write('\\n')\n                sys.stderr.write('Files without SPDX:\\n')\n                for f in sorted(parser.spdx_dirs.keys()):\n                    di = parser.spdx_dirs[f]\n                    for f in sorted(di.files):\n                        sys.stderr.write('    %s\\n' %f)\n\n            sys.exit(0)\n\n    except Exception as ex:\n        sys.stderr.write('FAIL: %s\\n' %ex)\n        sys.stderr.write('%s\\n' %traceback.format_exc())\n        sys.exit(1)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}