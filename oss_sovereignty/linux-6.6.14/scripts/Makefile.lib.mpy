{
  "module_name": "Makefile.lib",
  "hash_id": "852f3ee60d6868046bea2dbcfe72e891291e87c42c82b70e34922fc07eb57316",
  "original_prompt": "Ingested from linux-6.6.14/scripts/Makefile.lib",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n# Backward compatibility\nasflags-y  += $(EXTRA_AFLAGS)\nccflags-y  += $(EXTRA_CFLAGS)\ncppflags-y += $(EXTRA_CPPFLAGS)\nldflags-y  += $(EXTRA_LDFLAGS)\n\n# flags that take effect in current and sub directories\nKBUILD_AFLAGS += $(subdir-asflags-y)\nKBUILD_CFLAGS += $(subdir-ccflags-y)\nKBUILD_RUSTFLAGS += $(subdir-rustflags-y)\n\n# Figure out what we need to build from the various variables\n# ===========================================================================\n\n# When an object is listed to be built compiled-in and modular,\n# only build the compiled-in version\nobj-m := $(filter-out $(obj-y),$(obj-m))\n\n# Libraries are always collected in one lib file.\n# Filter out objects already built-in\nlib-y := $(filter-out $(obj-y), $(sort $(lib-y) $(lib-m)))\n\n# Subdirectories we need to descend into\nsubdir-ym := $(sort $(subdir-y) $(subdir-m) \\\n\t\t\t$(patsubst %/,%, $(filter %/, $(obj-y) $(obj-m))))\n\n# Handle objects in subdirs:\n# - If we encounter foo/ in $(obj-y), replace it by foo/built-in.a and\n#   foo/modules.order\n# - If we encounter foo/ in $(obj-m), replace it by foo/modules.order\n#\n# Generate modules.order to determine modorder. Unfortunately, we don't have\n# information about ordering between -y and -m subdirs. Just put -y's first.\n\nifdef need-modorder\nobj-m := $(patsubst %/,%/modules.order, $(filter %/, $(obj-y)) $(obj-m))\nelse\nobj-m := $(filter-out %/, $(obj-m))\nendif\n\nifdef need-builtin\nobj-y\t\t:= $(patsubst %/, %/built-in.a, $(obj-y))\nelse\nobj-y\t\t:= $(filter-out %/, $(obj-y))\nendif\n\n# Expand $(foo-objs) $(foo-y) etc. by replacing their individuals\nsuffix-search = $(strip $(foreach s, $3, $($(1:%$(strip $2)=%$s))))\n# List composite targets that are constructed by combining other targets\nmulti-search = $(sort $(foreach m, $1, $(if $(call suffix-search, $m, $2, $3 -), $m)))\n# List primitive targets that are compiled from source files\nreal-search = $(foreach m, $1, $(if $(call suffix-search, $m, $2, $3 -), $(call suffix-search, $m, $2, $3), $m))\n\n# If $(foo-objs), $(foo-y), $(foo-m), or $(foo-) exists, foo.o is a composite object\nmulti-obj-y := $(call multi-search, $(obj-y), .o, -objs -y)\nmulti-obj-m := $(call multi-search, $(obj-m), .o, -objs -y -m)\nmulti-obj-ym := $(multi-obj-y) $(multi-obj-m)\n\n# Replace multi-part objects by their individual parts,\n# including built-in.a from subdirectories\nreal-obj-y := $(call real-search, $(obj-y), .o, -objs -y)\nreal-obj-m := $(call real-search, $(obj-m), .o, -objs -y -m)\n\nalways-y += $(always-m)\n\n# hostprogs-always-y += foo\n# ... is a shorthand for\n# hostprogs += foo\n# always-y  += foo\nhostprogs += $(hostprogs-always-y) $(hostprogs-always-m)\nalways-y += $(hostprogs-always-y) $(hostprogs-always-m)\n\n# userprogs-always-y is likewise.\nuserprogs += $(userprogs-always-y) $(userprogs-always-m)\nalways-y += $(userprogs-always-y) $(userprogs-always-m)\n\n# DTB\n# If CONFIG_OF_ALL_DTBS is enabled, all DT blobs are built\ndtb-$(CONFIG_OF_ALL_DTBS)       += $(dtb-)\n\n# Composite DTB (i.e. DTB constructed by overlay)\nmulti-dtb-y := $(call multi-search, $(dtb-y), .dtb, -dtbs)\n# Primitive DTB compiled from *.dts\nreal-dtb-y := $(call real-search, $(dtb-y), .dtb, -dtbs)\n# Base DTB that overlay is applied onto (each first word of $(*-dtbs) expansion)\nbase-dtb-y := $(foreach m, $(multi-dtb-y), $(firstword $(call suffix-search, $m, .dtb, -dtbs)))\n\nalways-y\t\t\t+= $(dtb-y)\n\n# Add subdir path\n\nifneq ($(obj),.)\nextra-y\t\t:= $(addprefix $(obj)/,$(extra-y))\nalways-y\t:= $(addprefix $(obj)/,$(always-y))\ntargets\t\t:= $(addprefix $(obj)/,$(targets))\nobj-m\t\t:= $(addprefix $(obj)/,$(obj-m))\nlib-y\t\t:= $(addprefix $(obj)/,$(lib-y))\nreal-obj-y\t:= $(addprefix $(obj)/,$(real-obj-y))\nreal-obj-m\t:= $(addprefix $(obj)/,$(real-obj-m))\nmulti-obj-m\t:= $(addprefix $(obj)/, $(multi-obj-m))\nmulti-dtb-y\t:= $(addprefix $(obj)/, $(multi-dtb-y))\nreal-dtb-y\t:= $(addprefix $(obj)/, $(real-dtb-y))\nsubdir-ym\t:= $(addprefix $(obj)/,$(subdir-ym))\nendif\n\n# Finds the multi-part object the current object will be linked into.\n# If the object belongs to two or more multi-part objects, list them all.\nmodname-multi = $(sort $(foreach m,$(multi-obj-ym),\\\n\t\t$(if $(filter $*.o, $(call suffix-search, $m, .o, -objs -y -m)),$(m:.o=))))\n\n__modname = $(or $(modname-multi),$(basetarget))\n\nmodname = $(subst $(space),:,$(__modname))\nmodfile = $(addprefix $(obj)/,$(__modname))\n\n# target with $(obj)/ and its suffix stripped\ntarget-stem = $(basename $(patsubst $(obj)/%,%,$@))\n\n# These flags are needed for modversions and compiling, so we define them here\n# $(modname_flags) defines KBUILD_MODNAME as the name of the module it will\n# end up in (or would, if it gets compiled in)\nname-fix-token = $(subst $(comma),_,$(subst -,_,$1))\nname-fix = $(call stringify,$(call name-fix-token,$1))\nbasename_flags = -DKBUILD_BASENAME=$(call name-fix,$(basetarget))\nmodname_flags  = -DKBUILD_MODNAME=$(call name-fix,$(modname)) \\\n\t\t -D__KBUILD_MODNAME=kmod_$(call name-fix-token,$(modname))\nmodfile_flags  = -DKBUILD_MODFILE=$(call stringify,$(modfile))\n\n_c_flags       = $(filter-out $(CFLAGS_REMOVE_$(target-stem).o), \\\n                     $(filter-out $(ccflags-remove-y), \\\n                         $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) $(ccflags-y)) \\\n                     $(CFLAGS_$(target-stem).o))\n_rust_flags    = $(filter-out $(RUSTFLAGS_REMOVE_$(target-stem).o), \\\n                     $(filter-out $(rustflags-remove-y), \\\n                         $(KBUILD_RUSTFLAGS) $(rustflags-y)) \\\n                     $(RUSTFLAGS_$(target-stem).o))\n_a_flags       = $(filter-out $(AFLAGS_REMOVE_$(target-stem).o), \\\n                     $(filter-out $(asflags-remove-y), \\\n                         $(KBUILD_CPPFLAGS) $(KBUILD_AFLAGS) $(asflags-y)) \\\n                     $(AFLAGS_$(target-stem).o))\n_cpp_flags     = $(KBUILD_CPPFLAGS) $(cppflags-y) $(CPPFLAGS_$(target-stem).lds)\n\n#\n# Enable gcov profiling flags for a file, directory or for all files depending\n# on variables GCOV_PROFILE_obj.o, GCOV_PROFILE and CONFIG_GCOV_PROFILE_ALL\n# (in this order)\n#\nifeq ($(CONFIG_GCOV_KERNEL),y)\n_c_flags += $(if $(patsubst n%,, \\\n\t\t$(GCOV_PROFILE_$(basetarget).o)$(GCOV_PROFILE)$(CONFIG_GCOV_PROFILE_ALL)), \\\n\t\t$(CFLAGS_GCOV))\nendif\n\n#\n# Enable address sanitizer flags for kernel except some files or directories\n# we don't want to check (depends on variables KASAN_SANITIZE_obj.o, KASAN_SANITIZE)\n#\nifeq ($(CONFIG_KASAN),y)\nifneq ($(CONFIG_KASAN_HW_TAGS),y)\n_c_flags += $(if $(patsubst n%,, \\\n\t\t$(KASAN_SANITIZE_$(basetarget).o)$(KASAN_SANITIZE)y), \\\n\t\t$(CFLAGS_KASAN), $(CFLAGS_KASAN_NOSANITIZE))\nendif\nendif\n\nifeq ($(CONFIG_KMSAN),y)\n_c_flags += $(if $(patsubst n%,, \\\n\t\t$(KMSAN_SANITIZE_$(basetarget).o)$(KMSAN_SANITIZE)y), \\\n\t\t$(CFLAGS_KMSAN))\n_c_flags += $(if $(patsubst n%,, \\\n\t\t$(KMSAN_ENABLE_CHECKS_$(basetarget).o)$(KMSAN_ENABLE_CHECKS)y), \\\n\t\t, -mllvm -msan-disable-checks=1)\nendif\n\nifeq ($(CONFIG_UBSAN),y)\n_c_flags += $(if $(patsubst n%,, \\\n\t\t$(UBSAN_SANITIZE_$(basetarget).o)$(UBSAN_SANITIZE)$(CONFIG_UBSAN_SANITIZE_ALL)), \\\n\t\t$(CFLAGS_UBSAN))\nendif\n\nifeq ($(CONFIG_KCOV),y)\n_c_flags += $(if $(patsubst n%,, \\\n\t$(KCOV_INSTRUMENT_$(basetarget).o)$(KCOV_INSTRUMENT)$(CONFIG_KCOV_INSTRUMENT_ALL)), \\\n\t$(CFLAGS_KCOV))\nendif\n\n#\n# Enable KCSAN flags except some files or directories we don't want to check\n# (depends on variables KCSAN_SANITIZE_obj.o, KCSAN_SANITIZE)\n#\nifeq ($(CONFIG_KCSAN),y)\n_c_flags += $(if $(patsubst n%,, \\\n\t$(KCSAN_SANITIZE_$(basetarget).o)$(KCSAN_SANITIZE)y), \\\n\t$(CFLAGS_KCSAN))\n# Some uninstrumented files provide implied barriers required to avoid false\n# positives: set KCSAN_INSTRUMENT_BARRIERS for barrier instrumentation only.\n_c_flags += $(if $(patsubst n%,, \\\n\t$(KCSAN_INSTRUMENT_BARRIERS_$(basetarget).o)$(KCSAN_INSTRUMENT_BARRIERS)n), \\\n\t-D__KCSAN_INSTRUMENT_BARRIERS__)\nendif\n\n# $(srctree)/$(src) for including checkin headers from generated source files\n# $(objtree)/$(obj) for including generated headers from checkin source files\nifeq ($(KBUILD_EXTMOD),)\nifdef building_out_of_srctree\n_c_flags   += -I $(srctree)/$(src) -I $(objtree)/$(obj)\n_a_flags   += -I $(srctree)/$(src) -I $(objtree)/$(obj)\n_cpp_flags += -I $(srctree)/$(src) -I $(objtree)/$(obj)\nendif\nendif\n\npart-of-module = $(if $(filter $(basename $@).o, $(real-obj-m)),y)\nquiet_modtag = $(if $(part-of-module),[M],   )\n\nmodkern_cflags =                                          \\\n\t$(if $(part-of-module),                           \\\n\t\t$(KBUILD_CFLAGS_MODULE) $(CFLAGS_MODULE), \\\n\t\t$(KBUILD_CFLAGS_KERNEL) $(CFLAGS_KERNEL) $(modfile_flags))\n\nmodkern_rustflags =                                              \\\n\t$(if $(part-of-module),                                   \\\n\t\t$(KBUILD_RUSTFLAGS_MODULE) $(RUSTFLAGS_MODULE), \\\n\t\t$(KBUILD_RUSTFLAGS_KERNEL) $(RUSTFLAGS_KERNEL))\n\nmodkern_aflags = $(if $(part-of-module),\t\t\t\t\\\n\t\t\t$(KBUILD_AFLAGS_MODULE) $(AFLAGS_MODULE),\t\\\n\t\t\t$(KBUILD_AFLAGS_KERNEL) $(AFLAGS_KERNEL))\n\nc_flags        = -Wp,-MMD,$(depfile) $(NOSTDINC_FLAGS) $(LINUXINCLUDE)     \\\n\t\t -include $(srctree)/include/linux/compiler_types.h       \\\n\t\t $(_c_flags) $(modkern_cflags)                           \\\n\t\t $(basename_flags) $(modname_flags)\n\nrust_flags     = $(_rust_flags) $(modkern_rustflags) @$(objtree)/include/generated/rustc_cfg\n\na_flags        = -Wp,-MMD,$(depfile) $(NOSTDINC_FLAGS) $(LINUXINCLUDE)     \\\n\t\t $(_a_flags) $(modkern_aflags)\n\ncpp_flags      = -Wp,-MMD,$(depfile) $(NOSTDINC_FLAGS) $(LINUXINCLUDE)     \\\n\t\t $(_cpp_flags)\n\nld_flags       = $(KBUILD_LDFLAGS) $(ldflags-y) $(LDFLAGS_$(@F))\n\nDTC_INCLUDE    := $(srctree)/scripts/dtc/include-prefixes\n\ndtc_cpp_flags  = -Wp,-MMD,$(depfile).pre.tmp -nostdinc                    \\\n\t\t $(addprefix -I,$(DTC_INCLUDE))                          \\\n\t\t -undef -D__DTS__\n\nifdef CONFIG_OBJTOOL\n\nobjtool := $(objtree)/tools/objtool/objtool\n\nobjtool-args-$(CONFIG_HAVE_JUMP_LABEL_HACK)\t\t+= --hacks=jump_label\nobjtool-args-$(CONFIG_HAVE_NOINSTR_HACK)\t\t+= --hacks=noinstr\nobjtool-args-$(CONFIG_CALL_DEPTH_TRACKING)\t\t+= --hacks=skylake\nobjtool-args-$(CONFIG_X86_KERNEL_IBT)\t\t\t+= --ibt\nobjtool-args-$(CONFIG_FINEIBT)\t\t\t\t+= --cfi\nobjtool-args-$(CONFIG_FTRACE_MCOUNT_USE_OBJTOOL)\t+= --mcount\nifdef CONFIG_FTRACE_MCOUNT_USE_OBJTOOL\nobjtool-args-$(CONFIG_HAVE_OBJTOOL_NOP_MCOUNT)\t\t+= --mnop\nendif\nobjtool-args-$(CONFIG_UNWINDER_ORC)\t\t\t+= --orc\nobjtool-args-$(CONFIG_RETPOLINE)\t\t\t+= --retpoline\nobjtool-args-$(CONFIG_RETHUNK)\t\t\t\t+= --rethunk\nobjtool-args-$(CONFIG_SLS)\t\t\t\t+= --sls\nobjtool-args-$(CONFIG_STACK_VALIDATION)\t\t\t+= --stackval\nobjtool-args-$(CONFIG_HAVE_STATIC_CALL_INLINE)\t\t+= --static-call\nobjtool-args-$(CONFIG_HAVE_UACCESS_VALIDATION)\t\t+= --uaccess\nobjtool-args-$(CONFIG_GCOV_KERNEL)\t\t\t+= --no-unreachable\nobjtool-args-$(CONFIG_PREFIX_SYMBOLS)\t\t\t+= --prefix=$(CONFIG_FUNCTION_PADDING_BYTES)\n\nobjtool-args = $(objtool-args-y)\t\t\t\t\t\\\n\t$(if $(delay-objtool), --link)\t\t\t\t\t\\\n\t$(if $(part-of-module), --module)\n\ndelay-objtool := $(or $(CONFIG_LTO_CLANG),$(CONFIG_X86_KERNEL_IBT))\n\ncmd_objtool = $(if $(objtool-enabled), ; $(objtool) $(objtool-args) $@)\ncmd_gen_objtooldep = $(if $(objtool-enabled), { echo ; echo '$@: $$(wildcard $(objtool))' ; } >> $(dot-target).cmd)\n\nendif # CONFIG_OBJTOOL\n\n# Useful for describing the dependency of composite objects\n# Usage:\n#   $(call multi_depend, multi_used_targets, suffix_to_remove, suffix_to_add)\ndefine multi_depend\n$(foreach m, $1, \\\n\t$(eval $m: \\\n\t$(addprefix $(obj)/, $(call suffix-search, $(patsubst $(obj)/%,%,$m), $2, $3))))\nendef\n\n# Copy a file\n# ===========================================================================\n# 'cp' preserves permissions. If you use it to copy a file in read-only srctree,\n# the copy would be read-only as well, leading to an error when executing the\n# rule next time. Use 'cat' instead in order to generate a writable file.\nquiet_cmd_copy = COPY    $@\n      cmd_copy = cat $< > $@\n\n$(obj)/%: $(src)/%_shipped\n\t$(call cmd,copy)\n\n# Commands useful for building a boot image\n# ===========================================================================\n#\n#\tUse as following:\n#\n#\ttarget: source(s) FORCE\n#\t\t$(if_changed,ld/objcopy/gzip)\n#\n#\tand add target to 'targets' so that we know we have to\n#\tread in the saved command line\n\n# Linking\n# ---------------------------------------------------------------------------\n\nquiet_cmd_ld = LD      $@\n      cmd_ld = $(LD) $(ld_flags) $(real-prereqs) -o $@\n\n# Archive\n# ---------------------------------------------------------------------------\n\nquiet_cmd_ar = AR      $@\n      cmd_ar = rm -f $@; $(AR) cDPrsT $@ $(real-prereqs)\n\n# Objcopy\n# ---------------------------------------------------------------------------\n\nquiet_cmd_objcopy = OBJCOPY $@\ncmd_objcopy = $(OBJCOPY) $(OBJCOPYFLAGS) $(OBJCOPYFLAGS_$(@F)) $< $@\n\n# Gzip\n# ---------------------------------------------------------------------------\n\nquiet_cmd_gzip = GZIP    $@\n      cmd_gzip = cat $(real-prereqs) | $(KGZIP) -n -f -9 > $@\n\n# DTC\n# ---------------------------------------------------------------------------\nDTC ?= $(objtree)/scripts/dtc/dtc\nDTC_FLAGS += -Wno-interrupt_provider \\\n\t-Wno-unique_unit_address\n\n# Disable noisy checks by default\nifeq ($(findstring 1,$(KBUILD_EXTRA_WARN)),)\nDTC_FLAGS += -Wno-unit_address_vs_reg \\\n\t-Wno-avoid_unnecessary_addr_size \\\n\t-Wno-alias_paths \\\n\t-Wno-graph_child_address \\\n\t-Wno-simple_bus_reg\nelse\nDTC_FLAGS += \\\n        -Wunique_unit_address_if_enabled\nendif\n\nifneq ($(findstring 2,$(KBUILD_EXTRA_WARN)),)\nDTC_FLAGS += -Wnode_name_chars_strict \\\n\t-Wproperty_name_chars_strict \\\n\t-Winterrupt_provider \\\n\t-Wunique_unit_address\nendif\n\nDTC_FLAGS += $(DTC_FLAGS_$(basetarget))\n\n# Set -@ if the target is a base DTB that overlay is applied onto\nDTC_FLAGS += $(if $(filter $(patsubst $(obj)/%,%,$@), $(base-dtb-y)), -@)\n\n# Generate an assembly file to wrap the output of the device tree compiler\nquiet_cmd_wrap_S_dtb = WRAP    $@\n      cmd_wrap_S_dtb = {\t\t\t\t\t\t\t\t\\\n\t\tsymbase=__$(patsubst .%,%,$(suffix $<))_$(subst -,_,$(notdir $*));\t\\\n\t\techo '\\#include <asm-generic/vmlinux.lds.h>';\t\t\t\t\\\n\t\techo '.section .dtb.init.rodata,\"a\"';\t\t\t\t\t\\\n\t\techo '.balign STRUCT_ALIGNMENT';\t\t\t\t\t\\\n\t\techo \".global $${symbase}_begin\";\t\t\t\t\t\\\n\t\techo \"$${symbase}_begin:\";\t\t\t\t\t\t\\\n\t\techo '.incbin \"$<\" ';\t\t\t\t\t\t\t\\\n\t\techo \".global $${symbase}_end\";\t\t\t\t\t\t\\\n\t\techo \"$${symbase}_end:\";\t\t\t\t\t\t\\\n\t\techo '.balign STRUCT_ALIGNMENT';\t\t\t\t\t\\\n\t} > $@\n\n$(obj)/%.dtb.S: $(obj)/%.dtb FORCE\n\t$(call if_changed,wrap_S_dtb)\n\n$(obj)/%.dtbo.S: $(obj)/%.dtbo FORCE\n\t$(call if_changed,wrap_S_dtb)\n\nquiet_cmd_dtc = DTC     $@\ncmd_dtc = $(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \\\n\t$(DTC) -o $@ -b 0 \\\n\t\t$(addprefix -i,$(dir $<) $(DTC_INCLUDE)) $(DTC_FLAGS) \\\n\t\t-d $(depfile).dtc.tmp $(dtc-tmp) ; \\\n\tcat $(depfile).pre.tmp $(depfile).dtc.tmp > $(depfile)\n\nquiet_cmd_fdtoverlay = DTOVL   $@\n      cmd_fdtoverlay = $(objtree)/scripts/dtc/fdtoverlay -o $@ -i $(real-prereqs)\n\n$(multi-dtb-y): FORCE\n\t$(call if_changed,fdtoverlay)\n$(call multi_depend, $(multi-dtb-y), .dtb, -dtbs)\n\nifneq ($(CHECK_DTBS)$(CHECK_DT_BINDING),)\nDT_CHECKER ?= dt-validate\nDT_CHECKER_FLAGS ?= $(if $(DT_SCHEMA_FILES),-l $(DT_SCHEMA_FILES),-m)\nDT_BINDING_DIR := Documentation/devicetree/bindings\nDT_TMP_SCHEMA := $(objtree)/$(DT_BINDING_DIR)/processed-schema.json\n\nquiet_cmd_dtb =\tDTC_CHK $@\n      cmd_dtb =\t$(cmd_dtc) ; $(DT_CHECKER) $(DT_CHECKER_FLAGS) -u $(srctree)/$(DT_BINDING_DIR) -p $(DT_TMP_SCHEMA) $@ || true\nelse\nquiet_cmd_dtb = $(quiet_cmd_dtc)\n      cmd_dtb = $(cmd_dtc)\nendif\n\n$(obj)/%.dtb: $(src)/%.dts $(DTC) $(DT_TMP_SCHEMA) FORCE\n\t$(call if_changed_dep,dtb)\n\n$(obj)/%.dtbo: $(src)/%.dtso $(DTC) FORCE\n\t$(call if_changed_dep,dtc)\n\ndtc-tmp = $(subst $(comma),_,$(dot-target).dts.tmp)\n\n# Bzip2\n# ---------------------------------------------------------------------------\n\n# Bzip2 and LZMA do not include size in file... so we have to fake that;\n# append the size as a 32-bit littleendian number as gzip does.\nsize_append = printf $(shell\t\t\t\t\t\t\\\ndec_size=0;\t\t\t\t\t\t\t\t\\\nfor F in $(real-prereqs); do\t\t\t\t\t\\\n\tfsize=$$($(CONFIG_SHELL) $(srctree)/scripts/file-size.sh $$F);\t\\\n\tdec_size=$$(expr $$dec_size + $$fsize);\t\t\t\t\\\ndone;\t\t\t\t\t\t\t\t\t\\\nprintf \"%08x\\n\" $$dec_size |\t\t\t\t\t\t\\\n\tsed 's/\\(..\\)/\\1 /g' | {\t\t\t\t\t\\\n\t\tread ch0 ch1 ch2 ch3;\t\t\t\t\t\\\n\t\tfor ch in $$ch3 $$ch2 $$ch1 $$ch0; do\t\t\t\\\n\t\t\tprintf '%s%03o' '\\\\' $$((0x$$ch)); \t\t\\\n\t\tdone;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n)\n\nquiet_cmd_file_size = GEN     $@\n      cmd_file_size = $(size_append) > $@\n\nquiet_cmd_bzip2 = BZIP2   $@\n      cmd_bzip2 = cat $(real-prereqs) | $(KBZIP2) -9 > $@\n\nquiet_cmd_bzip2_with_size = BZIP2   $@\n      cmd_bzip2_with_size = { cat $(real-prereqs) | $(KBZIP2) -9; $(size_append); } > $@\n\n# Lzma\n# ---------------------------------------------------------------------------\n\nquiet_cmd_lzma = LZMA    $@\n      cmd_lzma = cat $(real-prereqs) | $(LZMA) -9 > $@\n\nquiet_cmd_lzma_with_size = LZMA    $@\n      cmd_lzma_with_size = { cat $(real-prereqs) | $(LZMA) -9; $(size_append); } > $@\n\nquiet_cmd_lzo = LZO     $@\n      cmd_lzo = cat $(real-prereqs) | $(KLZOP) -9 > $@\n\nquiet_cmd_lzo_with_size = LZO     $@\n      cmd_lzo_with_size = { cat $(real-prereqs) | $(KLZOP) -9; $(size_append); } > $@\n\nquiet_cmd_lz4 = LZ4     $@\n      cmd_lz4 = cat $(real-prereqs) | $(LZ4) -l -c1 stdin stdout > $@\n\nquiet_cmd_lz4_with_size = LZ4     $@\n      cmd_lz4_with_size = { cat $(real-prereqs) | $(LZ4) -l -c1 stdin stdout; \\\n                  $(size_append); } > $@\n\n# U-Boot mkimage\n# ---------------------------------------------------------------------------\n\nMKIMAGE := $(srctree)/scripts/mkuboot.sh\n\n# SRCARCH just happens to match slightly more than ARCH (on sparc), so reduces\n# the number of overrides in arch makefiles\nUIMAGE_ARCH ?= $(SRCARCH)\nUIMAGE_COMPRESSION ?= $(or $(2),none)\nUIMAGE_OPTS-y ?=\nUIMAGE_TYPE ?= kernel\nUIMAGE_LOADADDR ?= arch_must_set_this\nUIMAGE_ENTRYADDR ?= $(UIMAGE_LOADADDR)\nUIMAGE_NAME ?= 'Linux-$(KERNELRELEASE)'\n\nquiet_cmd_uimage = UIMAGE  $@\n      cmd_uimage = $(BASH) $(MKIMAGE) -A $(UIMAGE_ARCH) -O linux \\\n\t\t\t-C $(UIMAGE_COMPRESSION) $(UIMAGE_OPTS-y) \\\n\t\t\t-T $(UIMAGE_TYPE) \\\n\t\t\t-a $(UIMAGE_LOADADDR) -e $(UIMAGE_ENTRYADDR) \\\n\t\t\t-n $(UIMAGE_NAME) -d $< $@\n\n# XZ\n# ---------------------------------------------------------------------------\n# Use xzkern to compress the kernel image and xzmisc to compress other things.\n#\n# xzkern uses a big LZMA2 dictionary since it doesn't increase memory usage\n# of the kernel decompressor. A BCJ filter is used if it is available for\n# the target architecture. xzkern also appends uncompressed size of the data\n# using size_append. The .xz format has the size information available at\n# the end of the file too, but it's in more complex format and it's good to\n# avoid changing the part of the boot code that reads the uncompressed size.\n# Note that the bytes added by size_append will make the xz tool think that\n# the file is corrupt. This is expected.\n#\n# xzmisc doesn't use size_append, so it can be used to create normal .xz\n# files. xzmisc uses smaller LZMA2 dictionary than xzkern, because a very\n# big dictionary would increase the memory usage too much in the multi-call\n# decompression mode. A BCJ filter isn't used either.\nquiet_cmd_xzkern = XZKERN  $@\n      cmd_xzkern = cat $(real-prereqs) | sh $(srctree)/scripts/xz_wrap.sh > $@\n\nquiet_cmd_xzkern_with_size = XZKERN  $@\n      cmd_xzkern_with_size = { cat $(real-prereqs) | sh $(srctree)/scripts/xz_wrap.sh; \\\n                     $(size_append); } > $@\n\nquiet_cmd_xzmisc = XZMISC  $@\n      cmd_xzmisc = cat $(real-prereqs) | $(XZ) --check=crc32 --lzma2=dict=1MiB > $@\n\n# ZSTD\n# ---------------------------------------------------------------------------\n# Appends the uncompressed size of the data using size_append. The .zst\n# format has the size information available at the beginning of the file too,\n# but it's in a more complex format and it's good to avoid changing the part\n# of the boot code that reads the uncompressed size.\n#\n# Note that the bytes added by size_append will make the zstd tool think that\n# the file is corrupt. This is expected.\n#\n# zstd uses a maximum window size of 8 MB. zstd22 uses a maximum window size of\n# 128 MB. zstd22 is used for kernel compression because it is decompressed in a\n# single pass, so zstd doesn't need to allocate a window buffer. When streaming\n# decompression is used, like initramfs decompression, zstd22 should likely not\n# be used because it would require zstd to allocate a 128 MB buffer.\n\nquiet_cmd_zstd = ZSTD    $@\n      cmd_zstd = cat $(real-prereqs) | $(ZSTD) -19 > $@\n\nquiet_cmd_zstd22 = ZSTD22  $@\n      cmd_zstd22 = cat $(real-prereqs) | $(ZSTD) -22 --ultra > $@\n\nquiet_cmd_zstd22_with_size = ZSTD22  $@\n      cmd_zstd22_with_size = { cat $(real-prereqs) | $(ZSTD) -22 --ultra; $(size_append); } > $@\n\n# ASM offsets\n# ---------------------------------------------------------------------------\n\n# Default sed regexp - multiline due to syntax constraints\n#\n# Use [:space:] because LLVM's integrated assembler inserts <tab> around\n# the .ascii directive whereas GCC keeps the <space> as-is.\ndefine sed-offsets\n\t's:^[[:space:]]*\\.ascii[[:space:]]*\"\\(.*\\)\".*:\\1:; \\\n\t/^->/{s:->#\\(.*\\):/* \\1 */:; \\\n\ts:^->\\([^ ]*\\) [\\$$#]*\\([^ ]*\\) \\(.*\\):#define \\1 \\2 /* \\3 */:; \\\n\ts:->::; p;}'\nendef\n\n# Use filechk to avoid rebuilds when a header changes, but the resulting file\n# does not\ndefine filechk_offsets\n\t echo \"#ifndef $2\"; \\\n\t echo \"#define $2\"; \\\n\t echo \"/*\"; \\\n\t echo \" * DO NOT MODIFY.\"; \\\n\t echo \" *\"; \\\n\t echo \" * This file was generated by Kbuild\"; \\\n\t echo \" */\"; \\\n\t echo \"\"; \\\n\t sed -ne $(sed-offsets) < $<; \\\n\t echo \"\"; \\\n\t echo \"#endif\"\nendef\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}