{
  "module_name": "recordmcount.c",
  "hash_id": "16d1ef73822f60cf0e78e3ab121d04c21291ca9b4d4db32c02481f333a4e596f",
  "original_prompt": "Ingested from linux-6.6.14/scripts/recordmcount.c",
  "human_readable_source": "\n \n\n \n\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <getopt.h>\n#include <elf.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifndef EM_AARCH64\n#define EM_AARCH64\t183\n#define R_AARCH64_NONE\t\t0\n#define R_AARCH64_ABS64\t257\n#endif\n\n#ifndef EM_LOONGARCH\n#define EM_LOONGARCH\t\t258\n#define R_LARCH_32\t\t\t1\n#define R_LARCH_64\t\t\t2\n#define R_LARCH_MARK_LA\t\t\t20\n#define R_LARCH_SOP_PUSH_PLT_PCREL\t29\n#endif\n\n#define R_ARM_PC24\t\t1\n#define R_ARM_THM_CALL\t\t10\n#define R_ARM_CALL\t\t28\n\n#define R_AARCH64_CALL26\t283\n\nstatic int fd_map;\t \nstatic int mmap_failed;  \nstatic char gpfx;\t \nstatic struct stat sb;\t \nstatic const char *altmcount;\t \nstatic int warn_on_notrace_sect;  \nstatic void *file_map;\t \nstatic void *file_end;\t \nstatic int file_updated;  \nstatic void *file_ptr;\t \n\nstatic void *file_append;  \nstatic size_t file_append_size;  \n\n \nstatic void file_append_cleanup(void)\n{\n\tfree(file_append);\n\tfile_append = NULL;\n\tfile_append_size = 0;\n\tfile_updated = 0;\n}\n\nstatic void mmap_cleanup(void)\n{\n\tif (!mmap_failed)\n\t\tmunmap(file_map, sb.st_size);\n\telse\n\t\tfree(file_map);\n\tfile_map = NULL;\n}\n\n \n\nstatic off_t ulseek(off_t const offset, int const whence)\n{\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\tfile_ptr = file_map + offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfile_ptr += offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfile_ptr = file_map + (sb.st_size - offset);\n\t\tbreak;\n\t}\n\tif (file_ptr < file_map) {\n\t\tfprintf(stderr, \"lseek: seek before file\\n\");\n\t\treturn -1;\n\t}\n\treturn file_ptr - file_map;\n}\n\nstatic ssize_t uwrite(void const *const buf, size_t const count)\n{\n\tsize_t cnt = count;\n\toff_t idx = 0;\n\tvoid *p = NULL;\n\n\tfile_updated = 1;\n\n\tif (file_ptr + count >= file_end) {\n\t\toff_t aoffset = (file_ptr + count) - file_end;\n\n\t\tif (aoffset > file_append_size) {\n\t\t\tp = realloc(file_append, aoffset);\n\t\t\tif (!p)\n\t\t\t\tfree(file_append);\n\t\t\tfile_append = p;\n\t\t\tfile_append_size = aoffset;\n\t\t}\n\t\tif (!file_append) {\n\t\t\tperror(\"write\");\n\t\t\tfile_append_cleanup();\n\t\t\tmmap_cleanup();\n\t\t\treturn -1;\n\t\t}\n\t\tif (file_ptr < file_end) {\n\t\t\tcnt = file_end - file_ptr;\n\t\t} else {\n\t\t\tcnt = 0;\n\t\t\tidx = aoffset - count;\n\t\t}\n\t}\n\n\tif (cnt)\n\t\tmemcpy(file_ptr, buf, cnt);\n\n\tif (cnt < count)\n\t\tmemcpy(file_append + idx, buf + cnt, count - cnt);\n\n\tfile_ptr += count;\n\treturn count;\n}\n\nstatic void * umalloc(size_t size)\n{\n\tvoid *const addr = malloc(size);\n\tif (addr == 0) {\n\t\tfprintf(stderr, \"malloc failed: %zu bytes\\n\", size);\n\t\tfile_append_cleanup();\n\t\tmmap_cleanup();\n\t\treturn NULL;\n\t}\n\treturn addr;\n}\n\n \nstatic void *mmap_file(char const *fname)\n{\n\t \n\tfd_map = -1;\n\tmmap_failed = 1;\n\tfile_map = NULL;\n\tfile_ptr = NULL;\n\tfile_updated = 0;\n\tsb.st_size = 0;\n\n\tfd_map = open(fname, O_RDONLY);\n\tif (fd_map < 0) {\n\t\tperror(fname);\n\t\treturn NULL;\n\t}\n\tif (fstat(fd_map, &sb) < 0) {\n\t\tperror(fname);\n\t\tgoto out;\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\tfprintf(stderr, \"not a regular file: %s\\n\", fname);\n\t\tgoto out;\n\t}\n\tfile_map = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,\n\t\t\tfd_map, 0);\n\tif (file_map == MAP_FAILED) {\n\t\tmmap_failed = 1;\n\t\tfile_map = umalloc(sb.st_size);\n\t\tif (!file_map) {\n\t\t\tperror(fname);\n\t\t\tgoto out;\n\t\t}\n\t\tif (read(fd_map, file_map, sb.st_size) != sb.st_size) {\n\t\t\tperror(fname);\n\t\t\tfree(file_map);\n\t\t\tfile_map = NULL;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tmmap_failed = 0;\nout:\n\tclose(fd_map);\n\tfd_map = -1;\n\n\tfile_end = file_map + sb.st_size;\n\n\treturn file_map;\n}\n\n\nstatic unsigned char ideal_nop5_x86_64[5] = { 0x0f, 0x1f, 0x44, 0x00, 0x00 };\nstatic unsigned char ideal_nop5_x86_32[5] = { 0x3e, 0x8d, 0x74, 0x26, 0x00 };\nstatic unsigned char *ideal_nop;\n\nstatic char rel_type_nop;\n\nstatic int (*make_nop)(void *map, size_t const offset);\n\nstatic int make_nop_x86(void *map, size_t const offset)\n{\n\tuint32_t *ptr;\n\tunsigned char *op;\n\n\t \n\tptr = map + offset;\n\tif (*ptr != 0)\n\t\treturn -1;\n\n\top = map + offset - 1;\n\tif (*op != 0xe8)\n\t\treturn -1;\n\n\t \n\tif (ulseek(offset - 1, SEEK_SET) < 0)\n\t\treturn -1;\n\tif (uwrite(ideal_nop, 5) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic unsigned char ideal_nop4_arm_le[4] = { 0x00, 0x00, 0xa0, 0xe1 };  \nstatic unsigned char ideal_nop4_arm_be[4] = { 0xe1, 0xa0, 0x00, 0x00 };  \nstatic unsigned char *ideal_nop4_arm;\n\nstatic unsigned char bl_mcount_arm_le[4] = { 0xfe, 0xff, 0xff, 0xeb };  \nstatic unsigned char bl_mcount_arm_be[4] = { 0xeb, 0xff, 0xff, 0xfe };  \nstatic unsigned char *bl_mcount_arm;\n\nstatic unsigned char push_arm_le[4] = { 0x04, 0xe0, 0x2d, 0xe5 };  \nstatic unsigned char push_arm_be[4] = { 0xe5, 0x2d, 0xe0, 0x04 };  \nstatic unsigned char *push_arm;\n\nstatic unsigned char ideal_nop2_thumb_le[2] = { 0x00, 0xbf };  \nstatic unsigned char ideal_nop2_thumb_be[2] = { 0xbf, 0x00 };  \nstatic unsigned char *ideal_nop2_thumb;\n\nstatic unsigned char push_bl_mcount_thumb_le[6] = { 0x00, 0xb5, 0xff, 0xf7, 0xfe, 0xff };  \nstatic unsigned char push_bl_mcount_thumb_be[6] = { 0xb5, 0x00, 0xf7, 0xff, 0xff, 0xfe };  \nstatic unsigned char *push_bl_mcount_thumb;\n\nstatic int make_nop_arm(void *map, size_t const offset)\n{\n\tchar *ptr;\n\tint cnt = 1;\n\tint nop_size;\n\tsize_t off = offset;\n\n\tptr = map + offset;\n\tif (memcmp(ptr, bl_mcount_arm, 4) == 0) {\n\t\tif (memcmp(ptr - 4, push_arm, 4) == 0) {\n\t\t\toff -= 4;\n\t\t\tcnt = 2;\n\t\t}\n\t\tideal_nop = ideal_nop4_arm;\n\t\tnop_size = 4;\n\t} else if (memcmp(ptr - 2, push_bl_mcount_thumb, 6) == 0) {\n\t\tcnt = 3;\n\t\tnop_size = 2;\n\t\toff -= 2;\n\t\tideal_nop = ideal_nop2_thumb;\n\t} else\n\t\treturn -1;\n\n\t \n\tif (ulseek(off, SEEK_SET) < 0)\n\t\treturn -1;\n\n\tdo {\n\t\tif (uwrite(ideal_nop, nop_size) < 0)\n\t\t\treturn -1;\n\t} while (--cnt > 0);\n\n\treturn 0;\n}\n\nstatic unsigned char ideal_nop4_arm64[4] = {0x1f, 0x20, 0x03, 0xd5};\nstatic int make_nop_arm64(void *map, size_t const offset)\n{\n\tuint32_t *ptr;\n\n\tptr = map + offset;\n\t \n\tif (*ptr != 0x94000000)\n\t\treturn -1;\n\n\t \n\tif (ulseek(offset, SEEK_SET) < 0)\n\t\treturn -1;\n\tif (uwrite(ideal_nop, 4) < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int write_file(const char *fname)\n{\n\tchar tmp_file[strlen(fname) + 4];\n\tsize_t n;\n\n\tif (!file_updated)\n\t\treturn 0;\n\n\tsprintf(tmp_file, \"%s.rc\", fname);\n\n\t \n\tfd_map = open(tmp_file, O_WRONLY | O_TRUNC | O_CREAT, sb.st_mode);\n\tif (fd_map < 0) {\n\t\tperror(fname);\n\t\treturn -1;\n\t}\n\tn = write(fd_map, file_map, sb.st_size);\n\tif (n != sb.st_size) {\n\t\tperror(\"write\");\n\t\tclose(fd_map);\n\t\treturn -1;\n\t}\n\tif (file_append_size) {\n\t\tn = write(fd_map, file_append, file_append_size);\n\t\tif (n != file_append_size) {\n\t\t\tperror(\"write\");\n\t\t\tclose(fd_map);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tclose(fd_map);\n\tif (rename(tmp_file, fname) < 0) {\n\t\tperror(fname);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic uint64_t w8rev(uint64_t const x)\n{\n\treturn   ((0xff & (x >> (0 * 8))) << (7 * 8))\n\t       | ((0xff & (x >> (1 * 8))) << (6 * 8))\n\t       | ((0xff & (x >> (2 * 8))) << (5 * 8))\n\t       | ((0xff & (x >> (3 * 8))) << (4 * 8))\n\t       | ((0xff & (x >> (4 * 8))) << (3 * 8))\n\t       | ((0xff & (x >> (5 * 8))) << (2 * 8))\n\t       | ((0xff & (x >> (6 * 8))) << (1 * 8))\n\t       | ((0xff & (x >> (7 * 8))) << (0 * 8));\n}\n\nstatic uint32_t w4rev(uint32_t const x)\n{\n\treturn   ((0xff & (x >> (0 * 8))) << (3 * 8))\n\t       | ((0xff & (x >> (1 * 8))) << (2 * 8))\n\t       | ((0xff & (x >> (2 * 8))) << (1 * 8))\n\t       | ((0xff & (x >> (3 * 8))) << (0 * 8));\n}\n\nstatic uint32_t w2rev(uint16_t const x)\n{\n\treturn   ((0xff & (x >> (0 * 8))) << (1 * 8))\n\t       | ((0xff & (x >> (1 * 8))) << (0 * 8));\n}\n\nstatic uint64_t w8nat(uint64_t const x)\n{\n\treturn x;\n}\n\nstatic uint32_t w4nat(uint32_t const x)\n{\n\treturn x;\n}\n\nstatic uint32_t w2nat(uint16_t const x)\n{\n\treturn x;\n}\n\nstatic uint64_t (*w8)(uint64_t);\nstatic uint32_t (*w)(uint32_t);\nstatic uint32_t (*w2)(uint16_t);\n\n \nstatic int is_mcounted_section_name(char const *const txtname)\n{\n\treturn strncmp(\".text\",          txtname, 5) == 0 ||\n\t\tstrcmp(\".init.text\",     txtname) == 0 ||\n\t\tstrcmp(\".ref.text\",      txtname) == 0 ||\n\t\tstrcmp(\".sched.text\",    txtname) == 0 ||\n\t\tstrcmp(\".spinlock.text\", txtname) == 0 ||\n\t\tstrcmp(\".irqentry.text\", txtname) == 0 ||\n\t\tstrcmp(\".softirqentry.text\", txtname) == 0 ||\n\t\tstrcmp(\".kprobes.text\", txtname) == 0 ||\n\t\tstrcmp(\".cpuidle.text\", txtname) == 0;\n}\n\nstatic char const *already_has_rel_mcount = \"success\";  \n\n \n#include \"recordmcount.h\"\n#define RECORD_MCOUNT_64\n#include \"recordmcount.h\"\n\nstatic int arm_is_fake_mcount(Elf32_Rel const *rp)\n{\n\tswitch (ELF32_R_TYPE(w(rp->r_info))) {\n\tcase R_ARM_THM_CALL:\n\tcase R_ARM_CALL:\n\tcase R_ARM_PC24:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int arm64_is_fake_mcount(Elf64_Rel const *rp)\n{\n\treturn ELF64_R_TYPE(w8(rp->r_info)) != R_AARCH64_CALL26;\n}\n\nstatic int LARCH32_is_fake_mcount(Elf32_Rel const *rp)\n{\n\tswitch (ELF64_R_TYPE(w(rp->r_info))) {\n\tcase R_LARCH_MARK_LA:\n\tcase R_LARCH_SOP_PUSH_PLT_PCREL:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int LARCH64_is_fake_mcount(Elf64_Rel const *rp)\n{\n\tswitch (ELF64_R_TYPE(w(rp->r_info))) {\n\tcase R_LARCH_MARK_LA:\n\tcase R_LARCH_SOP_PUSH_PLT_PCREL:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \n\ntypedef uint8_t myElf64_Byte;\t\t \n\nunion mips_r_info {\n\tElf64_Xword r_info;\n\tstruct {\n\t\tElf64_Word r_sym;\t\t \n\t\tmyElf64_Byte r_ssym;\t\t \n\t\tmyElf64_Byte r_type3;\t\t \n\t\tmyElf64_Byte r_type2;\t\t \n\t\tmyElf64_Byte r_type;\t\t \n\t} r_mips;\n};\n\nstatic uint64_t MIPS64_r_sym(Elf64_Rel const *rp)\n{\n\treturn w(((union mips_r_info){ .r_info = rp->r_info }).r_mips.r_sym);\n}\n\nstatic void MIPS64_r_info(Elf64_Rel *const rp, unsigned sym, unsigned type)\n{\n\trp->r_info = ((union mips_r_info){\n\t\t.r_mips = { .r_sym = w(sym), .r_type = type }\n\t}).r_info;\n}\n\nstatic int do_file(char const *const fname)\n{\n\tunsigned int reltype = 0;\n\tElf32_Ehdr *ehdr;\n\tint rc = -1;\n\n\tehdr = mmap_file(fname);\n\tif (!ehdr)\n\t\tgoto out;\n\n\tw = w4nat;\n\tw2 = w2nat;\n\tw8 = w8nat;\n\tswitch (ehdr->e_ident[EI_DATA]) {\n\t\tstatic unsigned int const endian = 1;\n\tdefault:\n\t\tfprintf(stderr, \"unrecognized ELF data encoding %d: %s\\n\",\n\t\t\tehdr->e_ident[EI_DATA], fname);\n\t\tgoto out;\n\tcase ELFDATA2LSB:\n\t\tif (*(unsigned char const *)&endian != 1) {\n\t\t\t \n\t\t\tw = w4rev;\n\t\t\tw2 = w2rev;\n\t\t\tw8 = w8rev;\n\t\t}\n\t\tideal_nop4_arm = ideal_nop4_arm_le;\n\t\tbl_mcount_arm = bl_mcount_arm_le;\n\t\tpush_arm = push_arm_le;\n\t\tideal_nop2_thumb = ideal_nop2_thumb_le;\n\t\tpush_bl_mcount_thumb = push_bl_mcount_thumb_le;\n\t\tbreak;\n\tcase ELFDATA2MSB:\n\t\tif (*(unsigned char const *)&endian != 0) {\n\t\t\t \n\t\t\tw = w4rev;\n\t\t\tw2 = w2rev;\n\t\t\tw8 = w8rev;\n\t\t}\n\t\tideal_nop4_arm = ideal_nop4_arm_be;\n\t\tbl_mcount_arm = bl_mcount_arm_be;\n\t\tpush_arm = push_arm_be;\n\t\tideal_nop2_thumb = ideal_nop2_thumb_be;\n\t\tpush_bl_mcount_thumb = push_bl_mcount_thumb_be;\n\t\tbreak;\n\t}   \n\tif (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0 ||\n\t    w2(ehdr->e_type) != ET_REL ||\n\t    ehdr->e_ident[EI_VERSION] != EV_CURRENT) {\n\t\tfprintf(stderr, \"unrecognized ET_REL file %s\\n\", fname);\n\t\tgoto out;\n\t}\n\n\tgpfx = '_';\n\tswitch (w2(ehdr->e_machine)) {\n\tdefault:\n\t\tfprintf(stderr, \"unrecognized e_machine %u %s\\n\",\n\t\t\tw2(ehdr->e_machine), fname);\n\t\tgoto out;\n\tcase EM_386:\n\t\treltype = R_386_32;\n\t\trel_type_nop = R_386_NONE;\n\t\tmake_nop = make_nop_x86;\n\t\tideal_nop = ideal_nop5_x86_32;\n\t\tmcount_adjust_32 = -1;\n\t\tgpfx = 0;\n\t\tbreak;\n\tcase EM_ARM:\n\t\treltype = R_ARM_ABS32;\n\t\taltmcount = \"__gnu_mcount_nc\";\n\t\tmake_nop = make_nop_arm;\n\t\trel_type_nop = R_ARM_NONE;\n\t\tis_fake_mcount32 = arm_is_fake_mcount;\n\t\tgpfx = 0;\n\t\tbreak;\n\tcase EM_AARCH64:\n\t\treltype = R_AARCH64_ABS64;\n\t\tmake_nop = make_nop_arm64;\n\t\trel_type_nop = R_AARCH64_NONE;\n\t\tideal_nop = ideal_nop4_arm64;\n\t\tis_fake_mcount64 = arm64_is_fake_mcount;\n\t\tbreak;\n\tcase EM_IA_64:\treltype = R_IA64_IMM64; break;\n\tcase EM_MIPS:\t  break;\n\tcase EM_LOONGARCH:\t  break;\n\tcase EM_PPC:\treltype = R_PPC_ADDR32; break;\n\tcase EM_PPC64:\treltype = R_PPC64_ADDR64; break;\n\tcase EM_S390:\t  break;\n\tcase EM_SH:\treltype = R_SH_DIR32; gpfx = 0; break;\n\tcase EM_SPARCV9: reltype = R_SPARC_64; break;\n\tcase EM_X86_64:\n\t\tmake_nop = make_nop_x86;\n\t\tideal_nop = ideal_nop5_x86_64;\n\t\treltype = R_X86_64_64;\n\t\trel_type_nop = R_X86_64_NONE;\n\t\tmcount_adjust_64 = -1;\n\t\tgpfx = 0;\n\t\tbreak;\n\t}   \n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tdefault:\n\t\tfprintf(stderr, \"unrecognized ELF class %d %s\\n\",\n\t\t\tehdr->e_ident[EI_CLASS], fname);\n\t\tgoto out;\n\tcase ELFCLASS32:\n\t\tif (w2(ehdr->e_ehsize) != sizeof(Elf32_Ehdr)\n\t\t||  w2(ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"unrecognized ET_REL file: %s\\n\", fname);\n\t\t\tgoto out;\n\t\t}\n\t\tif (w2(ehdr->e_machine) == EM_MIPS) {\n\t\t\treltype = R_MIPS_32;\n\t\t\tis_fake_mcount32 = MIPS32_is_fake_mcount;\n\t\t}\n\t\tif (w2(ehdr->e_machine) == EM_LOONGARCH) {\n\t\t\treltype = R_LARCH_32;\n\t\t\tis_fake_mcount32 = LARCH32_is_fake_mcount;\n\t\t}\n\t\tif (do32(ehdr, fname, reltype) < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase ELFCLASS64: {\n\t\tElf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;\n\t\tif (w2(ghdr->e_ehsize) != sizeof(Elf64_Ehdr)\n\t\t||  w2(ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"unrecognized ET_REL file: %s\\n\", fname);\n\t\t\tgoto out;\n\t\t}\n\t\tif (w2(ghdr->e_machine) == EM_S390) {\n\t\t\treltype = R_390_64;\n\t\t\tmcount_adjust_64 = -14;\n\t\t}\n\t\tif (w2(ghdr->e_machine) == EM_MIPS) {\n\t\t\treltype = R_MIPS_64;\n\t\t\tElf64_r_sym = MIPS64_r_sym;\n\t\t\tElf64_r_info = MIPS64_r_info;\n\t\t\tis_fake_mcount64 = MIPS64_is_fake_mcount;\n\t\t}\n\t\tif (w2(ghdr->e_machine) == EM_LOONGARCH) {\n\t\t\treltype = R_LARCH_64;\n\t\t\tis_fake_mcount64 = LARCH64_is_fake_mcount;\n\t\t}\n\t\tif (do64(ghdr, fname, reltype) < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\t}   \n\n\trc = write_file(fname);\nout:\n\tfile_append_cleanup();\n\tmmap_cleanup();\n\treturn rc;\n}\n\nint main(int argc, char *argv[])\n{\n\tconst char ftrace[] = \"/ftrace.o\";\n\tint ftrace_size = sizeof(ftrace) - 1;\n\tint n_error = 0;   \n\tint c;\n\tint i;\n\n\twhile ((c = getopt(argc, argv, \"w\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'w':\n\t\t\twarn_on_notrace_sect = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"usage: recordmcount [-w] file.o...\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((argc - optind) < 1) {\n\t\tfprintf(stderr, \"usage: recordmcount [-w] file.o...\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = optind; i < argc; i++) {\n\t\tchar *file = argv[i];\n\t\tint len;\n\n\t\t \n\t\tlen = strlen(file);\n\t\tif (len >= ftrace_size &&\n\t\t    strcmp(file + (len - ftrace_size), ftrace) == 0)\n\t\t\tcontinue;\n\n\t\tif (do_file(file)) {\n\t\t\tfprintf(stderr, \"%s: failed\\n\", file);\n\t\t\t++n_error;\n\t\t}\n\t}\n\treturn !!n_error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}