{
  "module_name": "check-sysctl-docs",
  "hash_id": "c28c69598e41b7bda719d46e1582722265d2d97268bc5a78fdcbcbcf968478da",
  "original_prompt": "Ingested from linux-6.6.14/scripts/check-sysctl-docs",
  "human_readable_source": "#!/usr/bin/gawk -f\n# SPDX-License-Identifier: GPL-2.0\n\n# Script to check sysctl documentation against source files\n#\n# Copyright (c) 2020 Stephen Kitt\n\n# Example invocation:\n#\tscripts/check-sysctl-docs -vtable=\"kernel\" \\\n#\t\tDocumentation/admin-guide/sysctl/kernel.rst \\\n#\t\t$(git grep -l register_sysctl_)\n#\n# Specify -vdebug=1 to see debugging information\n\nBEGIN {\n    if (!table) {\n\tprint \"Please specify the table to look for using the table variable\" > \"/dev/stderr\"\n\texit 1\n    }\n}\n\n# The following globals are used:\n# children: maps ctl_table names and procnames to child ctl_table names\n# documented: maps documented entries (each key is an entry)\n# entries: maps ctl_table names and procnames to counts (so\n#          enumerating the subkeys for a given ctl_table lists its\n#          procnames)\n# files: maps procnames to source file names\n# paths: maps ctl_path names to paths\n# curpath: the name of the current ctl_path struct\n# curtable: the name of the current ctl_table struct\n# curentry: the name of the current proc entry (procname when parsing\n#           a ctl_table, constructed path when parsing a ctl_path)\n\n\n# Remove punctuation from the given value\nfunction trimpunct(value) {\n    while (value ~ /^[\"&]/) {\n\tvalue = substr(value, 2)\n    }\n    while (value ~ /[][\"&,}]$/) {\n\tvalue = substr(value, 1, length(value) - 1)\n    }\n    return value\n}\n\n# Print the information for the given entry\nfunction printentry(entry) {\n    seen[entry]++\n    printf \"* %s from %s\", entry, file[entry]\n    if (documented[entry]) {\n\tprintf \" (documented)\"\n    }\n    print \"\"\n}\n\n\n# Stage 1: build the list of documented entries\nFNR == NR && /^=+$/ {\n    if (prevline ~ /Documentation for/) {\n\t# This is the main title\n\tnext\n    }\n\n    # The previous line is a section title, parse it\n    $0 = prevline\n    if (debug) print \"Parsing \" $0\n    inbrackets = 0\n    for (i = 1; i <= NF; i++) {\n\tif (length($i) == 0) {\n\t    continue\n\t}\n\tif (!inbrackets && substr($i, 1, 1) == \"(\") {\n\t    inbrackets = 1\n\t}\n\tif (!inbrackets) {\n\t    token = trimpunct($i)\n\t    if (length(token) > 0 && token != \"and\") {\n\t\tif (debug) print trimpunct($i)\n\t\tdocumented[trimpunct($i)]++\n\t    }\n\t}\n\tif (inbrackets && substr($i, length($i), 1) == \")\") {\n\t    inbrackets = 0\n\t}\n    }\n}\n\nFNR == NR {\n    prevline = $0\n    next\n}\n\n\n# Stage 2: process each file and find all sysctl tables\nBEGINFILE {\n    delete children\n    delete entries\n    delete paths\n    curpath = \"\"\n    curtable = \"\"\n    curentry = \"\"\n    if (debug) print \"Processing file \" FILENAME\n}\n\n/^static struct ctl_path/ {\n    match($0, /static struct ctl_path ([^][]+)/, tables)\n    curpath = tables[1]\n    if (debug) print \"Processing path \" curpath\n}\n\n/^static struct ctl_table/ {\n    match($0, /static struct ctl_table ([^][]+)/, tables)\n    curtable = tables[1]\n    if (debug) print \"Processing table \" curtable\n}\n\n/^};$/ {\n    curpath = \"\"\n    curtable = \"\"\n    curentry = \"\"\n}\n\ncurpath && /\\.procname[\\t ]*=[\\t ]*\".+\"/ {\n    match($0, /.procname[\\t ]*=[\\t ]*\"([^\"]+)\"/, names)\n    if (curentry) {\n\tcurentry = curentry \"/\" names[1]\n    } else {\n\tcurentry = names[1]\n    }\n    if (debug) print \"Setting path \" curpath \" to \" curentry\n    paths[curpath] = curentry\n}\n\ncurtable && /\\.procname[\\t ]*=[\\t ]*\".+\"/ {\n    match($0, /.procname[\\t ]*=[\\t ]*\"([^\"]+)\"/, names)\n    curentry = names[1]\n    if (debug) print \"Adding entry \" curentry \" to table \" curtable\n    entries[curtable][curentry]++\n    file[curentry] = FILENAME\n}\n\n/\\.child[\\t ]*=/ {\n    child = trimpunct($NF)\n    if (debug) print \"Linking child \" child \" to table \" curtable \" entry \" curentry\n    children[curtable][curentry] = child\n}\n\nEND {\n    for (entry in documented) {\n\tif (!seen[entry]) {\n\t    print \"No implementation for \" entry\n\t}\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}