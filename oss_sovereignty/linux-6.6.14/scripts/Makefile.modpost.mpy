{
  "module_name": "Makefile.modpost",
  "hash_id": "7da18133253def95f80ae82b56d90907fc1cee94342a81af3480f5f35bcb89e4",
  "original_prompt": "Ingested from linux-6.6.14/scripts/Makefile.modpost",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n# ===========================================================================\n# Module versions\n# ===========================================================================\n#\n# Stage one of module building created the following:\n# a) The individual .o files used for the module\n# b) A <module>.o file which is the .o files above linked together\n# c) A <module>.mod file, listing the name of the preliminary <module>.o file,\n#    plus all .o files\n# d) modules.order, which lists all the modules\n\n# Stage 2 is handled by this file and does the following\n# 1) Find all modules listed in modules.order\n# 2) modpost is then used to\n# 3)  create one <module>.mod.c file per module\n# 4)  create one Module.symvers file with CRC for all exported symbols\n\n# Step 3 is used to place certain information in the module's ELF\n# section, including information such as:\n#   Version magic (see include/linux/vermagic.h for full details)\n#     - Kernel release\n#     - SMP is CONFIG_SMP\n#     - PREEMPT is CONFIG_PREEMPT[_RT]\n#     - GCC Version\n#   Module info\n#     - Module version (MODULE_VERSION)\n#     - Module alias'es (MODULE_ALIAS)\n#     - Module license (MODULE_LICENSE)\n#     - See include/linux/module.h for more details\n\n# Step 4 is solely used to allow module versioning in external modules,\n# where the CRC of each module is retrieved from the Module.symvers file.\n\nPHONY := __modpost\n__modpost:\n\ninclude include/config/auto.conf\ninclude $(srctree)/scripts/Kbuild.include\n\nMODPOST = scripts/mod/modpost\n\nmodpost-args =\t\t\t\t\t\t\t\t\t\t\\\n\t$(if $(CONFIG_MODULES),-M)\t\t\t\t\t\t\t\\\n\t$(if $(CONFIG_MODVERSIONS),-m)\t\t\t\t\t\t\t\\\n\t$(if $(CONFIG_MODULE_SRCVERSION_ALL),-a)\t\t\t\t\t\\\n\t$(if $(CONFIG_SECTION_MISMATCH_WARN_ONLY),,-E)\t\t\t\t\t\\\n\t$(if $(KBUILD_MODPOST_WARN),-w)\t\t\t\t\t\t\t\\\n\t$(if $(KBUILD_NSDEPS),-d $(MODULES_NSDEPS))\t\t\t\t\t\\\n\t$(if $(CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS)$(KBUILD_NSDEPS),-N)\t\\\n\t$(if $(findstring 1, $(KBUILD_EXTRA_WARN)),-W)\t\t\t\t\t\\\n\t-o $@\n\nmodpost-deps := $(MODPOST)\n\n# 'make -i -k' ignores compile errors, and builds as many modules as possible.\nifneq ($(findstring i,$(filter-out --%,$(MAKEFLAGS))),)\nmodpost-args += -n\nendif\n\n# Read out modules.order to pass in modpost.\n# Otherwise, allmodconfig would fail with \"Argument list too long\".\nifdef KBUILD_MODULES\nmodpost-args += -T $(MODORDER)\nmodpost-deps += $(MODORDER)\nendif\n\nifeq ($(KBUILD_EXTMOD),)\n\n# Generate the list of in-tree objects in vmlinux\n# ---------------------------------------------------------------------------\n\n# This is used to retrieve symbol versions generated by genksyms.\nifdef CONFIG_MODVERSIONS\nvmlinux.symvers Module.symvers: .vmlinux.objs\nendif\n\n# Ignore libgcc.a\n# Some architectures do '$(CC) --print-libgcc-file-name' to borrow libgcc.a\n# from the toolchain, but there is no EXPORT_SYMBOL in it.\n\nquiet_cmd_vmlinux_objs = GEN     $@\n      cmd_vmlinux_objs =\t\t\\\n\tfor f in $(real-prereqs); do\t\\\n\t\tcase $${f} in\t\t\\\n\t\t*libgcc.a) ;;\t\t\\\n\t\t*) $(AR) t $${f} ;;\t\\\n\t\tesac\t\t\t\\\n\tdone > $@\n\ntargets += .vmlinux.objs\n.vmlinux.objs: vmlinux.a $(KBUILD_VMLINUX_LIBS) FORCE\n\t$(call if_changed,vmlinux_objs)\n\nifdef CONFIG_TRIM_UNUSED_KSYMS\nksym-wl := $(CONFIG_UNUSED_KSYMS_WHITELIST)\nksym-wl := $(if $(filter-out /%, $(ksym-wl)),$(srctree)/)$(ksym-wl)\nmodpost-args += -t $(addprefix -u , $(ksym-wl))\nmodpost-deps += $(ksym-wl)\nendif\n\nifeq ($(wildcard vmlinux.o),)\nmissing-input := vmlinux.o\noutput-symdump := modules-only.symvers\nelse\nmodpost-args += vmlinux.o\nmodpost-deps += vmlinux.o\noutput-symdump := $(if $(KBUILD_MODULES), Module.symvers, vmlinux.symvers)\nendif\n\nelse\n\n# set src + obj - they may be used in the modules's Makefile\nobj := $(KBUILD_EXTMOD)\nsrc := $(obj)\n\n# Include the module's Makefile to find KBUILD_EXTRA_SYMBOLS\ninclude $(kbuild-file)\n\noutput-symdump := $(KBUILD_EXTMOD)/Module.symvers\n\nifeq ($(wildcard Module.symvers),)\nmissing-input := Module.symvers\nelse\nmodpost-args += -i Module.symvers\nmodpost-deps += Module.symvers\nendif\n\nmodpost-args += -e $(addprefix -i , $(KBUILD_EXTRA_SYMBOLS))\n\nendif # ($(KBUILD_EXTMOD),)\n\nquiet_cmd_modpost = MODPOST $@\n      cmd_modpost = \\\n\t$(if $(missing-input), \\\n\t\techo >&2 \"WARNING: $(missing-input) is missing.\"; \\\n\t\techo >&2 \"         Modules may not have dependencies or modversions.\"; \\\n\t\techo >&2 \"         You may get many unresolved symbol errors.\"; \\\n\t\techo >&2 \"         You can set KBUILD_MODPOST_WARN=1 to turn errors into warning\"; \\\n\t\techo >&2 \"         if you want to proceed at your own risk.\";) \\\n\t$(MODPOST) $(modpost-args)\n\ntargets += $(output-symdump)\n$(output-symdump): $(modpost-deps) FORCE\n\t$(call if_changed,modpost)\n\n__modpost: $(output-symdump)\nPHONY += FORCE\nFORCE:\n\nexisting-targets := $(wildcard $(sort $(targets)))\n\n-include $(foreach f,$(existing-targets),$(dir $(f)).$(notdir $(f)).cmd)\n\n.PHONY: $(PHONY)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}