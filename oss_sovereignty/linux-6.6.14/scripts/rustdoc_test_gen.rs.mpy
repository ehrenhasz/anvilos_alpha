{
  "module_name": "rustdoc_test_gen.rs",
  "hash_id": "d6ff8d6104dd8c858e46a3e79512094544dafd10aa229662debdcc81083b1bdf",
  "original_prompt": "Ingested from linux-6.6.14/scripts/rustdoc_test_gen.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Generates KUnit tests from saved `rustdoc`-generated tests.\n//!\n//! KUnit passes a context (`struct kunit *`) to each test, which should be forwarded to the other\n//! KUnit functions and macros.\n//!\n//! However, we want to keep this as an implementation detail because:\n//!\n//!   - Test code should not care about the implementation.\n//!\n//!   - Documentation looks worse if it needs to carry extra details unrelated to the piece\n//!     being described.\n//!\n//!   - Test code should be able to define functions and call them, without having to carry\n//!     the context.\n//!\n//!   - Later on, we may want to be able to test non-kernel code (e.g. `core`, `alloc` or\n//!     third-party crates) which likely use the standard library `assert*!` macros.\n//!\n//! For this reason, instead of the passed context, `kunit_get_current_test()` is used instead\n//! (i.e. `current->kunit_test`).\n//!\n//! Note that this means other threads/tasks potentially spawned by a given test, if failing, will\n//! report the failure in the kernel log but will not fail the actual test. Saving the pointer in\n//! e.g. a `static` per test does not fully solve the issue either, because currently KUnit does\n//! not support assertions (only expectations) from other tasks. Thus leave that feature for\n//! the future, which simplifies the code here too. We could also simply not allow `assert`s in\n//! other tasks, but that seems overly constraining, and we do want to support them, eventually.\n\nuse std::{\n    fs,\n    fs::File,\n    io::{BufWriter, Read, Write},\n    path::{Path, PathBuf},\n};\n\n/// Find the real path to the original file based on the `file` portion of the test name.\n///\n/// `rustdoc` generated `file`s look like `sync_locked_by_rs`. Underscores (except the last one)\n/// may represent an actual underscore in a directory/file, or a path separator. Thus the actual\n/// file might be `sync_locked_by.rs`, `sync/locked_by.rs`, `sync_locked/by.rs` or\n/// `sync/locked/by.rs`. This function walks the file system to determine which is the real one.\n///\n/// This does require that ambiguities do not exist, but that seems fair, especially since this is\n/// all supposed to be temporary until `rustdoc` gives us proper metadata to build this. If such\n/// ambiguities are detected, they are diagnosed and the script panics.\nfn find_real_path<'a>(srctree: &Path, valid_paths: &'a mut Vec<PathBuf>, file: &str) -> &'a str {\n    valid_paths.clear();\n\n    let potential_components: Vec<&str> = file.strip_suffix(\"_rs\").unwrap().split('_').collect();\n\n    find_candidates(srctree, valid_paths, Path::new(\"\"), &potential_components);\n    fn find_candidates(\n        srctree: &Path,\n        valid_paths: &mut Vec<PathBuf>,\n        prefix: &Path,\n        potential_components: &[&str],\n    ) {\n        // The base case: check whether all the potential components left, joined by underscores,\n        // is a file.\n        let joined_potential_components = potential_components.join(\"_\") + \".rs\";\n        if srctree\n            .join(\"rust/kernel\")\n            .join(prefix)\n            .join(&joined_potential_components)\n            .is_file()\n        {\n            // Avoid `srctree` here in order to keep paths relative to it in the KTAP output.\n            valid_paths.push(\n                Path::new(\"rust/kernel\")\n                    .join(prefix)\n                    .join(joined_potential_components),\n            );\n        }\n\n        // In addition, check whether each component prefix, joined by underscores, is a directory.\n        // If not, there is no need to check for combinations with that prefix.\n        for i in 1..potential_components.len() {\n            let (components_prefix, components_rest) = potential_components.split_at(i);\n            let prefix = prefix.join(components_prefix.join(\"_\"));\n            if srctree.join(\"rust/kernel\").join(&prefix).is_dir() {\n                find_candidates(srctree, valid_paths, &prefix, components_rest);\n            }\n        }\n    }\n\n    assert!(\n        valid_paths.len() > 0,\n        \"No path candidates found. This is likely a bug in the build system, or some files went \\\n        away while compiling.\"\n    );\n\n    if valid_paths.len() > 1 {\n        eprintln!(\"Several path candidates found:\");\n        for path in valid_paths {\n            eprintln!(\"    {path:?}\");\n        }\n        panic!(\n            \"Several path candidates found, please resolve the ambiguity by renaming a file or \\\n            folder.\"\n        );\n    }\n\n    valid_paths[0].to_str().unwrap()\n}\n\nfn main() {\n    let srctree = std::env::var(\"srctree\").unwrap();\n    let srctree = Path::new(&srctree);\n\n    let mut paths = fs::read_dir(\"rust/test/doctests/kernel\")\n        .unwrap()\n        .map(|entry| entry.unwrap().path())\n        .collect::<Vec<_>>();\n\n    // Sort paths.\n    paths.sort();\n\n    let mut rust_tests = String::new();\n    let mut c_test_declarations = String::new();\n    let mut c_test_cases = String::new();\n    let mut body = String::new();\n    let mut last_file = String::new();\n    let mut number = 0;\n    let mut valid_paths: Vec<PathBuf> = Vec::new();\n    let mut real_path: &str = \"\";\n    for path in paths {\n        // The `name` follows the `{file}_{line}_{number}` pattern (see description in\n        // `scripts/rustdoc_test_builder.rs`). Discard the `number`.\n        let name = path.file_name().unwrap().to_str().unwrap().to_string();\n\n        // Extract the `file` and the `line`, discarding the `number`.\n        let (file, line) = name.rsplit_once('_').unwrap().0.rsplit_once('_').unwrap();\n\n        // Generate an ID sequence (\"test number\") for each one in the file.\n        if file == last_file {\n            number += 1;\n        } else {\n            number = 0;\n            last_file = file.to_string();\n\n            // Figure out the real path, only once per file.\n            real_path = find_real_path(srctree, &mut valid_paths, file);\n        }\n\n        // Generate a KUnit name (i.e. test name and C symbol) for this test.\n        //\n        // We avoid the line number, like `rustdoc` does, to make things slightly more stable for\n        // bisection purposes. However, to aid developers in mapping back what test failed, we will\n        // print a diagnostics line in the KTAP report.\n        let kunit_name = format!(\"rust_doctest_kernel_{file}_{number}\");\n\n        // Read the test's text contents to dump it below.\n        body.clear();\n        File::open(path).unwrap().read_to_string(&mut body).unwrap();\n\n        // Calculate how many lines before `main` function (including the `main` function line).\n        let body_offset = body\n            .lines()\n            .take_while(|line| !line.contains(\"fn main() {\"))\n            .count()\n            + 1;\n\n        use std::fmt::Write;\n        write!(\n            rust_tests,\n            r#\"/// Generated `{name}` KUnit test case from a Rust documentation test.\n#[no_mangle]\npub extern \"C\" fn {kunit_name}(__kunit_test: *mut kernel::bindings::kunit) {{\n    /// Overrides the usual [`assert!`] macro with one that calls KUnit instead.\n    #[allow(unused)]\n    macro_rules! assert {{\n        ($cond:expr $(,)?) => {{{{\n            kernel::kunit_assert!(\"{kunit_name}\", \"{real_path}\", __DOCTEST_ANCHOR - {line}, $cond);\n        }}}}\n    }}\n\n    /// Overrides the usual [`assert_eq!`] macro with one that calls KUnit instead.\n    #[allow(unused)]\n    macro_rules! assert_eq {{\n        ($left:expr, $right:expr $(,)?) => {{{{\n            kernel::kunit_assert_eq!(\"{kunit_name}\", \"{real_path}\", __DOCTEST_ANCHOR - {line}, $left, $right);\n        }}}}\n    }}\n\n    // Many tests need the prelude, so provide it by default.\n    #[allow(unused)]\n    use kernel::prelude::*;\n\n    // Unconditionally print the location of the original doctest (i.e. rather than the location in\n    // the generated file) so that developers can easily map the test back to the source code.\n    //\n    // This information is also printed when assertions fail, but this helps in the successful cases\n    // when the user is running KUnit manually, or when passing `--raw_output` to `kunit.py`.\n    //\n    // This follows the syntax for declaring test metadata in the proposed KTAP v2 spec, which may\n    // be used for the proposed KUnit test attributes API. Thus hopefully this will make migration\n    // easier later on.\n    kernel::kunit::info(format_args!(\"    # {kunit_name}.location: {real_path}:{line}\\n\"));\n\n    /// The anchor where the test code body starts.\n    #[allow(unused)]\n    static __DOCTEST_ANCHOR: i32 = core::line!() as i32 + {body_offset} + 1;\n    {{\n        {body}\n        main();\n    }}\n}}\n\n\"#\n        )\n        .unwrap();\n\n        write!(c_test_declarations, \"void {kunit_name}(struct kunit *);\\n\").unwrap();\n        write!(c_test_cases, \"    KUNIT_CASE({kunit_name}),\\n\").unwrap();\n    }\n\n    let rust_tests = rust_tests.trim();\n    let c_test_declarations = c_test_declarations.trim();\n    let c_test_cases = c_test_cases.trim();\n\n    write!(\n        BufWriter::new(File::create(\"rust/doctests_kernel_generated.rs\").unwrap()),\n        r#\"//! `kernel` crate documentation tests.\n\nconst __LOG_PREFIX: &[u8] = b\"rust_doctests_kernel\\0\";\n\n{rust_tests}\n\"#\n    )\n    .unwrap();\n\n    write!(\n        BufWriter::new(File::create(\"rust/doctests_kernel_generated_kunit.c\").unwrap()),\n        r#\"/*\n * `kernel` crate documentation tests.\n */\n\n#include <kunit/test.h>\n\n{c_test_declarations}\n\nstatic struct kunit_case test_cases[] = {{\n    {c_test_cases}\n    {{ }}\n}};\n\nstatic struct kunit_suite test_suite = {{\n    .name = \"rust_doctests_kernel\",\n    .test_cases = test_cases,\n}};\n\nkunit_test_suite(test_suite);\n\nMODULE_LICENSE(\"GPL\");\n\"#\n    )\n    .unwrap();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}