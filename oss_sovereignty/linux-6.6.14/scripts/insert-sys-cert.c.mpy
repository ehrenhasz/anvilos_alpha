{
  "module_name": "insert-sys-cert.c",
  "hash_id": "60e70d4461335b23aa81eba0e22692afb6ec9bfdd45da980b51acd3d5a826ae9",
  "original_prompt": "Ingested from linux-6.6.14/scripts/insert-sys-cert.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <elf.h>\n\n#define CERT_SYM  \"system_extra_cert\"\n#define USED_SYM  \"system_extra_cert_used\"\n#define LSIZE_SYM \"system_certificate_list_size\"\n\n#define info(format, args...) fprintf(stderr, \"INFO:    \" format, ## args)\n#define warn(format, args...) fprintf(stdout, \"WARNING: \" format, ## args)\n#define  err(format, args...) fprintf(stderr, \"ERROR:   \" format, ## args)\n\n#if UINTPTR_MAX == 0xffffffff\n#define CURRENT_ELFCLASS ELFCLASS32\n#define Elf_Ehdr\tElf32_Ehdr\n#define Elf_Shdr\tElf32_Shdr\n#define Elf_Sym\t\tElf32_Sym\n#else\n#define CURRENT_ELFCLASS ELFCLASS64\n#define Elf_Ehdr\tElf64_Ehdr\n#define Elf_Shdr\tElf64_Shdr\n#define Elf_Sym\t\tElf64_Sym\n#endif\n\nstatic unsigned char endianness(void)\n{\n\tuint16_t two_byte = 0x00FF;\n\tuint8_t low_address = *((uint8_t *)&two_byte);\n\n\tif (low_address == 0)\n\t\treturn ELFDATA2MSB;\n\telse\n\t\treturn ELFDATA2LSB;\n}\n\nstruct sym {\n\tchar *name;\n\tunsigned long address;\n\tunsigned long offset;\n\tvoid *content;\n\tint size;\n};\n\nstatic unsigned long get_offset_from_address(Elf_Ehdr *hdr, unsigned long addr)\n{\n\tElf_Shdr *x;\n\tunsigned int i, num_sections;\n\n\tx = (void *)hdr + hdr->e_shoff;\n\tif (hdr->e_shnum == SHN_UNDEF)\n\t\tnum_sections = x[0].sh_size;\n\telse\n\t\tnum_sections = hdr->e_shnum;\n\n\tfor (i = 1; i < num_sections; i++) {\n\t\tunsigned long start = x[i].sh_addr;\n\t\tunsigned long end = start + x[i].sh_size;\n\t\tunsigned long offset = x[i].sh_offset;\n\n\t\tif (addr >= start && addr <= end)\n\t\t\treturn addr - start + offset;\n\t}\n\treturn 0;\n}\n\n\n#define LINE_SIZE 100\n\nstatic void get_symbol_from_map(Elf_Ehdr *hdr, FILE *f, char *name,\n\t\t\t\tstruct sym *s)\n{\n\tchar l[LINE_SIZE];\n\tchar *w, *p, *n;\n\n\ts->size = 0;\n\ts->address = 0;\n\ts->offset = 0;\n\tif (fseek(f, 0, SEEK_SET) != 0) {\n\t\tperror(\"File seek failed\");\n\t\texit(EXIT_FAILURE);\n\t}\n\twhile (fgets(l, LINE_SIZE, f)) {\n\t\tp = strchr(l, '\\n');\n\t\tif (!p) {\n\t\t\terr(\"Missing line ending.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tn = strstr(l, name);\n\t\tif (n)\n\t\t\tbreak;\n\t}\n\tif (!n) {\n\t\terr(\"Unable to find symbol: %s\\n\", name);\n\t\treturn;\n\t}\n\tw = strchr(l, ' ');\n\tif (!w)\n\t\treturn;\n\n\t*w = '\\0';\n\ts->address = strtoul(l, NULL, 16);\n\tif (s->address == 0)\n\t\treturn;\n\ts->offset = get_offset_from_address(hdr, s->address);\n\ts->name = name;\n\ts->content = (void *)hdr + s->offset;\n}\n\nstatic Elf_Sym *find_elf_symbol(Elf_Ehdr *hdr, Elf_Shdr *symtab, char *name)\n{\n\tElf_Sym *sym, *symtab_start;\n\tchar *strtab, *symname;\n\tunsigned int link;\n\tElf_Shdr *x;\n\tint i, n;\n\n\tx = (void *)hdr + hdr->e_shoff;\n\tlink = symtab->sh_link;\n\tsymtab_start = (void *)hdr + symtab->sh_offset;\n\tn = symtab->sh_size / symtab->sh_entsize;\n\tstrtab = (void *)hdr + x[link].sh_offset;\n\n\tfor (i = 0; i < n; i++) {\n\t\tsym = &symtab_start[i];\n\t\tsymname = strtab + sym->st_name;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn sym;\n\t}\n\terr(\"Unable to find symbol: %s\\n\", name);\n\treturn NULL;\n}\n\nstatic void get_symbol_from_table(Elf_Ehdr *hdr, Elf_Shdr *symtab,\n\t\t\t\t  char *name, struct sym *s)\n{\n\tElf_Shdr *sec;\n\tint secndx;\n\tElf_Sym *elf_sym;\n\tElf_Shdr *x;\n\n\tx = (void *)hdr + hdr->e_shoff;\n\ts->size = 0;\n\ts->address = 0;\n\ts->offset = 0;\n\telf_sym = find_elf_symbol(hdr, symtab, name);\n\tif (!elf_sym)\n\t\treturn;\n\tsecndx = elf_sym->st_shndx;\n\tif (!secndx)\n\t\treturn;\n\tsec = &x[secndx];\n\ts->size = elf_sym->st_size;\n\ts->address = elf_sym->st_value;\n\ts->offset = s->address - sec->sh_addr\n\t\t\t       + sec->sh_offset;\n\ts->name = name;\n\ts->content = (void *)hdr + s->offset;\n}\n\nstatic Elf_Shdr *get_symbol_table(Elf_Ehdr *hdr)\n{\n\tElf_Shdr *x;\n\tunsigned int i, num_sections;\n\n\tx = (void *)hdr + hdr->e_shoff;\n\tif (hdr->e_shnum == SHN_UNDEF)\n\t\tnum_sections = x[0].sh_size;\n\telse\n\t\tnum_sections = hdr->e_shnum;\n\n\tfor (i = 1; i < num_sections; i++)\n\t\tif (x[i].sh_type == SHT_SYMTAB)\n\t\t\treturn &x[i];\n\treturn NULL;\n}\n\nstatic void *map_file(char *file_name, int *size)\n{\n\tstruct stat st;\n\tvoid *map;\n\tint fd;\n\n\tfd = open(file_name, O_RDWR);\n\tif (fd < 0) {\n\t\tperror(file_name);\n\t\treturn NULL;\n\t}\n\tif (fstat(fd, &st)) {\n\t\tperror(\"Could not determine file size\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\t*size = st.st_size;\n\tmap = mmap(NULL, *size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (map == MAP_FAILED) {\n\t\tperror(\"Mapping to memory failed\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tclose(fd);\n\treturn map;\n}\n\nstatic char *read_file(char *file_name, int *size)\n{\n\tstruct stat st;\n\tchar *buf;\n\tint fd;\n\n\tfd = open(file_name, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(file_name);\n\t\treturn NULL;\n\t}\n\tif (fstat(fd, &st)) {\n\t\tperror(\"Could not determine file size\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\t*size = st.st_size;\n\tbuf = malloc(*size);\n\tif (!buf) {\n\t\tperror(\"Allocating memory failed\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (read(fd, buf, *size) != *size) {\n\t\tperror(\"File read failed\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tclose(fd);\n\treturn buf;\n}\n\nstatic void print_sym(Elf_Ehdr *hdr, struct sym *s)\n{\n\tinfo(\"sym:    %s\\n\", s->name);\n\tinfo(\"addr:   0x%lx\\n\", s->address);\n\tinfo(\"size:   %d\\n\", s->size);\n\tinfo(\"offset: 0x%lx\\n\", (unsigned long)s->offset);\n}\n\nstatic void print_usage(char *e)\n{\n\tprintf(\"Usage %s [-s <System.map>] -b <vmlinux> -c <certfile>\\n\", e);\n}\n\nint main(int argc, char **argv)\n{\n\tchar *system_map_file = NULL;\n\tchar *vmlinux_file = NULL;\n\tchar *cert_file = NULL;\n\tint vmlinux_size;\n\tint cert_size;\n\tElf_Ehdr *hdr;\n\tchar *cert;\n\tFILE *system_map;\n\tunsigned long *lsize;\n\tint *used;\n\tint opt;\n\tElf_Shdr *symtab = NULL;\n\tstruct sym cert_sym, lsize_sym, used_sym;\n\n\twhile ((opt = getopt(argc, argv, \"b:c:s:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\tsystem_map_file = optarg;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tvmlinux_file = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcert_file = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!vmlinux_file || !cert_file) {\n\t\tprint_usage(argv[0]);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcert = read_file(cert_file, &cert_size);\n\tif (!cert)\n\t\texit(EXIT_FAILURE);\n\n\thdr = map_file(vmlinux_file, &vmlinux_size);\n\tif (!hdr)\n\t\texit(EXIT_FAILURE);\n\n\tif (vmlinux_size < sizeof(*hdr)) {\n\t\terr(\"Invalid ELF file.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif ((hdr->e_ident[EI_MAG0] != ELFMAG0) ||\n\t    (hdr->e_ident[EI_MAG1] != ELFMAG1) ||\n\t    (hdr->e_ident[EI_MAG2] != ELFMAG2) ||\n\t    (hdr->e_ident[EI_MAG3] != ELFMAG3)) {\n\t\terr(\"Invalid ELF magic.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (hdr->e_ident[EI_CLASS] != CURRENT_ELFCLASS) {\n\t\terr(\"ELF class mismatch.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (hdr->e_ident[EI_DATA] != endianness()) {\n\t\terr(\"ELF endian mismatch.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (hdr->e_shoff > vmlinux_size) {\n\t\terr(\"Could not find section header.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsymtab = get_symbol_table(hdr);\n\tif (!symtab) {\n\t\twarn(\"Could not find the symbol table.\\n\");\n\t\tif (!system_map_file) {\n\t\t\terr(\"Please provide a System.map file.\\n\");\n\t\t\tprint_usage(argv[0]);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tsystem_map = fopen(system_map_file, \"r\");\n\t\tif (!system_map) {\n\t\t\tperror(system_map_file);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tget_symbol_from_map(hdr, system_map, CERT_SYM, &cert_sym);\n\t\tget_symbol_from_map(hdr, system_map, USED_SYM, &used_sym);\n\t\tget_symbol_from_map(hdr, system_map, LSIZE_SYM, &lsize_sym);\n\t\tcert_sym.size = used_sym.address - cert_sym.address;\n\t} else {\n\t\tinfo(\"Symbol table found.\\n\");\n\t\tif (system_map_file)\n\t\t\twarn(\"System.map is ignored.\\n\");\n\t\tget_symbol_from_table(hdr, symtab, CERT_SYM, &cert_sym);\n\t\tget_symbol_from_table(hdr, symtab, USED_SYM, &used_sym);\n\t\tget_symbol_from_table(hdr, symtab, LSIZE_SYM, &lsize_sym);\n\t}\n\n\tif (!cert_sym.offset || !lsize_sym.offset || !used_sym.offset)\n\t\texit(EXIT_FAILURE);\n\n\tprint_sym(hdr, &cert_sym);\n\tprint_sym(hdr, &used_sym);\n\tprint_sym(hdr, &lsize_sym);\n\n\tlsize = (unsigned long *)lsize_sym.content;\n\tused = (int *)used_sym.content;\n\n\tif (cert_sym.size < cert_size) {\n\t\terr(\"Certificate is larger than the reserved area!\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (cert_size == *used &&\n\t    strncmp(cert_sym.content, cert, cert_size) == 0) {\n\t\twarn(\"Certificate was already inserted.\\n\");\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (*used > 0)\n\t\twarn(\"Replacing previously inserted certificate.\\n\");\n\n\tmemcpy(cert_sym.content, cert, cert_size);\n\tif (cert_size < cert_sym.size)\n\t\tmemset(cert_sym.content + cert_size,\n\t\t\t0, cert_sym.size - cert_size);\n\n\t*lsize = *lsize + cert_size - *used;\n\t*used = cert_size;\n\tinfo(\"Inserted the contents of %s into %lx.\\n\", cert_file,\n\t\t\t\t\t\tcert_sym.address);\n\tinfo(\"Used %d bytes out of %d bytes reserved.\\n\", *used,\n\t\t\t\t\t\t cert_sym.size);\n\texit(EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}