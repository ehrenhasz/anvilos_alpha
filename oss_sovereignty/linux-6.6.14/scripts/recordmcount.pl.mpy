{
  "module_name": "recordmcount.pl",
  "hash_id": "ed6f4aacc6c4c8236631febdea2d35d19d69e884e9800de4cbb7b83fae08381c",
  "original_prompt": "Ingested from linux-6.6.14/scripts/recordmcount.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0-only\n# (c) 2008, Steven Rostedt <srostedt@redhat.com>\n#\n# recordmcount.pl - makes a section called __mcount_loc that holds\n#                   all the offsets to the calls to mcount.\n#\n#\n# What we want to end up with this is that each object file will have a\n# section called __mcount_loc that will hold the list of pointers to mcount\n# callers. After final linking, the vmlinux will have within .init.data the\n# list of all callers to mcount between __start_mcount_loc and __stop_mcount_loc.\n# Later on boot up, the kernel will read this list, save the locations and turn\n# them into nops. When tracing or profiling is later enabled, these locations\n# will then be converted back to pointers to some function.\n#\n# This is no easy feat. This script is called just after the original\n# object is compiled and before it is linked.\n#\n# When parse this object file using 'objdump', the references to the call\n# sites are offsets from the section that the call site is in. Hence, all\n# functions in a section that has a call site to mcount, will have the\n# offset from the beginning of the section and not the beginning of the\n# function.\n#\n# But where this section will reside finally in vmlinx is undetermined at\n# this point. So we can't use this kind of offsets to record the final\n# address of this call site.\n#\n# The trick is to change the call offset referring the start of a section to\n# referring a function symbol in this section. During the link step, 'ld' will\n# compute the final address according to the information we record.\n#\n# e.g.\n#\n#  .section \".sched.text\", \"ax\"\n#        [...]\n#  func1:\n#        [...]\n#        call mcount  (offset: 0x10)\n#        [...]\n#        ret\n#  .globl fun2\n#  func2:             (offset: 0x20)\n#        [...]\n#        [...]\n#        ret\n#  func3:\n#        [...]\n#        call mcount (offset: 0x30)\n#        [...]\n#\n# Both relocation offsets for the mcounts in the above example will be\n# offset from .sched.text. If we choose global symbol func2 as a reference and\n# make another file called tmp.s with the new offsets:\n#\n#  .section __mcount_loc\n#  .quad  func2 - 0x10\n#  .quad  func2 + 0x10\n#\n# We can then compile this tmp.s into tmp.o, and link it back to the original\n# object.\n#\n# In our algorithm, we will choose the first global function we meet in this\n# section as the reference. But this gets hard if there is no global functions\n# in this section. In such a case we have to select a local one. E.g. func1:\n#\n#  .section \".sched.text\", \"ax\"\n#  func1:\n#        [...]\n#        call mcount  (offset: 0x10)\n#        [...]\n#        ret\n#  func2:\n#        [...]\n#        call mcount (offset: 0x20)\n#        [...]\n#  .section \"other.section\"\n#\n# If we make the tmp.s the same as above, when we link together with\n# the original object, we will end up with two symbols for func1:\n# one local, one global.  After final compile, we will end up with\n# an undefined reference to func1 or a wrong reference to another global\n# func1 in other files.\n#\n# Since local objects can reference local variables, we need to find\n# a way to make tmp.o reference the local objects of the original object\n# file after it is linked together. To do this, we convert func1\n# into a global symbol before linking tmp.o. Then after we link tmp.o\n# we will only have a single symbol for func1 that is global.\n# We can convert func1 back into a local symbol and we are done.\n#\n# Here are the steps we take:\n#\n# 1) Record all the local and weak symbols by using 'nm'\n# 2) Use objdump to find all the call site offsets and sections for\n#    mcount.\n# 3) Compile the list into its own object.\n# 4) Do we have to deal with local functions? If not, go to step 8.\n# 5) Make an object that converts these local functions to global symbols\n#    with objcopy.\n# 6) Link together this new object with the list object.\n# 7) Convert the local functions back to local symbols and rename\n#    the result as the original object.\n# 8) Link the object with the list object.\n# 9) Move the result back to the original object.\n#\n\nuse warnings;\nuse strict;\n\nmy $P = $0;\n$P =~ s@.*/@@g;\n\nmy $V = '0.1';\n\nif ($#ARGV != 11) {\n\tprint \"usage: $P arch endian bits objdump objcopy cc ld nm rm mv is_module inputfile\\n\";\n\tprint \"version: $V\\n\";\n\texit(1);\n}\n\nmy ($arch, $endian, $bits, $objdump, $objcopy, $cc,\n    $ld, $nm, $rm, $mv, $is_module, $inputfile) = @ARGV;\n\n# This file refers to mcount and shouldn't be ftraced, so lets' ignore it\nif ($inputfile =~ m,kernel/trace/ftrace\\.o$,) {\n    exit(0);\n}\n\n# Acceptable sections to record.\nmy %text_sections = (\n     \".text\" => 1,\n     \".init.text\" => 1,\n     \".ref.text\" => 1,\n     \".sched.text\" => 1,\n     \".spinlock.text\" => 1,\n     \".irqentry.text\" => 1,\n     \".softirqentry.text\" => 1,\n     \".kprobes.text\" => 1,\n     \".cpuidle.text\" => 1,\n     \".text.unlikely\" => 1,\n);\n\n# Acceptable section-prefixes to record.\nmy %text_section_prefixes = (\n     \".text.\" => 1,\n);\n\n# Note: we are nice to C-programmers here, thus we skip the '||='-idiom.\n$objdump = 'objdump' if (!$objdump);\n$objcopy = 'objcopy' if (!$objcopy);\n$cc = 'gcc' if (!$cc);\n$ld = 'ld' if (!$ld);\n$nm = 'nm' if (!$nm);\n$rm = 'rm' if (!$rm);\n$mv = 'mv' if (!$mv);\n\n#print STDERR \"running: $P '$arch' '$objdump' '$objcopy' '$cc' '$ld' \" .\n#    \"'$nm' '$rm' '$mv' '$inputfile'\\n\";\n\nmy %locals;\t\t# List of local (static) functions\nmy %weak;\t\t# List of weak functions\nmy %convert;\t\t# List of local functions used that needs conversion\n\nmy $type;\nmy $local_regex;\t# Match a local function (return function)\nmy $weak_regex; \t# Match a weak function (return function)\nmy $section_regex;\t# Find the start of a section\nmy $function_regex;\t# Find the name of a function\n\t\t\t#    (return offset and func name)\nmy $mcount_regex;\t# Find the call site to mcount (return offset)\nmy $mcount_adjust;\t# Address adjustment to mcount offset\nmy $alignment;\t\t# The .align value to use for $mcount_section\nmy $section_type;\t# Section header plus possible alignment command\n\nif ($arch =~ /(x86(_64)?)|(i386)/) {\n    if ($bits == 64) {\n\t$arch = \"x86_64\";\n    } else {\n\t$arch = \"i386\";\n    }\n}\n\n#\n# We base the defaults off of i386, the other archs may\n# feel free to change them in the below if statements.\n#\n$local_regex = \"^[0-9a-fA-F]+\\\\s+t\\\\s+(\\\\S+)\";\n$weak_regex = \"^[0-9a-fA-F]+\\\\s+([wW])\\\\s+(\\\\S+)\";\n$section_regex = \"Disassembly of section\\\\s+(\\\\S+):\";\n$function_regex = \"^([0-9a-fA-F]+)\\\\s+<([^^]*?)>:\";\n$mcount_regex = \"^\\\\s*([0-9a-fA-F]+):.*\\\\s(mcount|__fentry__)\\$\";\n$section_type = '@progbits';\n$mcount_adjust = 0;\n$type = \".long\";\n\nif ($arch eq \"x86_64\") {\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):.*\\\\s(mcount|__fentry__)([+-]0x[0-9a-zA-Z]+)?\\$\";\n    $type = \".quad\";\n    $alignment = 8;\n    $mcount_adjust = -1;\n\n    # force flags for this arch\n    $ld .= \" -m elf_x86_64\";\n    $objdump .= \" -M x86-64\";\n    $objcopy .= \" -O elf64-x86-64\";\n    $cc .= \" -m64\";\n\n} elsif ($arch eq \"i386\") {\n    $alignment = 4;\n    $mcount_adjust = -1;\n\n    # force flags for this arch\n    $ld .= \" -m elf_i386\";\n    $objdump .= \" -M i386\";\n    $objcopy .= \" -O elf32-i386\";\n    $cc .= \" -m32\";\n\n} elsif ($arch eq \"s390\" && $bits == 64) {\n    if ($cc =~ /-DCC_USING_HOTPATCH/) {\n\t$mcount_regex = \"^\\\\s*([0-9a-fA-F]+):\\\\s*c0 04 00 00 00 00\\\\s*(brcl\\\\s*0,|jgnop\\\\s*)[0-9a-f]+ <([^\\+]*)>\\$\";\n\t$mcount_adjust = 0;\n    }\n    $alignment = 8;\n    $type = \".quad\";\n    $ld .= \" -m elf64_s390\";\n    $cc .= \" -m64\";\n\n} elsif ($arch eq \"sh\") {\n    $alignment = 2;\n\n    # force flags for this arch\n    $ld .= \" -m shlelf_linux\";\n    if ($endian eq \"big\") {\n\t$objcopy .= \" -O elf32-shbig-linux\";\n    } else {\n\t$objcopy .= \" -O elf32-sh-linux\";\n    }\n\n} elsif ($arch eq \"powerpc\") {\n    my $ldemulation;\n\n    $local_regex = \"^[0-9a-fA-F]+\\\\s+t\\\\s+(\\\\.?\\\\S+)\";\n    # See comment in the sparc64 section for why we use '\\w'.\n    $function_regex = \"^([0-9a-fA-F]+)\\\\s+<(\\\\.?\\\\w*?)>:\";\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):.*\\\\s\\\\.?_mcount\\$\";\n\n    if ($endian eq \"big\") {\n\t    $cc .= \" -mbig-endian \";\n\t    $ld .= \" -EB \";\n\t    $ldemulation = \"ppc\"\n    } else {\n\t    $cc .= \" -mlittle-endian \";\n\t    $ld .= \" -EL \";\n\t    $ldemulation = \"lppc\"\n    }\n    if ($bits == 64) {\n\t$type = \".quad\";\n\t$cc .= \" -m64 \";\n\t$ld .= \" -m elf64\".$ldemulation.\" \";\n    } else {\n\t$cc .= \" -m32 \";\n\t$ld .= \" -m elf32\".$ldemulation.\" \";\n    }\n\n} elsif ($arch eq \"arm\") {\n    $alignment = 2;\n    $section_type = '%progbits';\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):\\\\s*R_ARM_(CALL|PC24|THM_CALL)\" .\n\t\t\t\"\\\\s+(__gnu_mcount_nc|mcount)\\$\";\n\n} elsif ($arch eq \"arm64\") {\n    $alignment = 3;\n    $section_type = '%progbits';\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):\\\\s*R_AARCH64_CALL26\\\\s+_mcount\\$\";\n    $type = \".quad\";\n} elsif ($arch eq \"ia64\") {\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):.*\\\\s_mcount\\$\";\n    $type = \"data8\";\n\n    if ($is_module eq \"0\") {\n\t$cc .= \" -mconstant-gp\";\n    }\n} elsif ($arch eq \"sparc64\") {\n    # In the objdump output there are giblets like:\n    # 0000000000000000 <igmp_net_exit-0x18>:\n    # As there's some data blobs that get emitted into the\n    # text section before the first instructions and the first\n    # real symbols.  We don't want to match that, so to combat\n    # this we use '\\w' so we'll match just plain symbol names,\n    # and not those that also include hex offsets inside of the\n    # '<>' brackets.  Actually the generic function_regex setting\n    # could safely use this too.\n    $function_regex = \"^([0-9a-fA-F]+)\\\\s+<(\\\\w*?)>:\";\n\n    # Sparc64 calls '_mcount' instead of plain 'mcount'.\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):.*\\\\s_mcount\\$\";\n\n    $alignment = 8;\n    $type = \".xword\";\n    $ld .= \" -m elf64_sparc\";\n    $cc .= \" -m64\";\n    $objcopy .= \" -O elf64-sparc\";\n} elsif ($arch eq \"mips\") {\n    # To enable module support, we need to enable the -mlong-calls option\n    # of gcc for module, after using this option, we can not get the real\n    # offset of the calling to _mcount, but the offset of the lui\n    # instruction or the addiu one. herein, we record the address of the\n    # first one, and then we can replace this instruction by a branch\n    # instruction to jump over the profiling function to filter the\n    # indicated functions, or switch back to the lui instruction to trace\n    # them, which means dynamic tracing.\n    #\n    #       c:\t3c030000 \tlui\tv1,0x0\n    #\t\t\tc: R_MIPS_HI16\t_mcount\n    #\t\t\tc: R_MIPS_NONE\t*ABS*\n    #\t\t\tc: R_MIPS_NONE\t*ABS*\n    #      10:\t64630000 \tdaddiu\tv1,v1,0\n    #\t\t\t10: R_MIPS_LO16\t_mcount\n    #\t\t\t10: R_MIPS_NONE\t*ABS*\n    #\t\t\t10: R_MIPS_NONE\t*ABS*\n    #      14:\t03e0082d \tmove\tat,ra\n    #      18:\t0060f809 \tjalr\tv1\n    #\n    # for the kernel:\n    #\n    #     10:   03e0082d        move    at,ra\n    #\t  14:   0c000000        jal     0 <loongson_halt>\n    #                    14: R_MIPS_26   _mcount\n    #                    14: R_MIPS_NONE *ABS*\n    #                    14: R_MIPS_NONE *ABS*\n    #\t 18:   00020021        nop\n    if ($is_module eq \"0\") {\n\t    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+): R_MIPS_26\\\\s+_mcount\\$\";\n    } else {\n\t    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+): R_MIPS_HI16\\\\s+_mcount\\$\";\n    }\n    $objdump .= \" -Melf-trad\".$endian.\"mips \";\n\n    if ($endian eq \"big\") {\n\t    $endian = \" -EB \";\n\t    $ld .= \" -melf\".$bits.\"btsmip\";\n    } else {\n\t    $endian = \" -EL \";\n\t    $ld .= \" -melf\".$bits.\"ltsmip\";\n    }\n\n    $cc .= \" -mno-abicalls -fno-pic -mabi=\" . $bits . $endian;\n    $ld .= $endian;\n\n    if ($bits == 64) {\n\t    $function_regex =\n\t\t\"^([0-9a-fA-F]+)\\\\s+<(.|[^\\$]L.*?|\\$[^L].*?|[^\\$][^L].*?)>:\";\n\t    $type = \".dword\";\n    }\n} elsif ($arch eq \"microblaze\") {\n    # Microblaze calls '_mcount' instead of plain 'mcount'.\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):.*\\\\s_mcount\\$\";\n} elsif ($arch eq \"riscv\") {\n    $function_regex = \"^([0-9a-fA-F]+)\\\\s+<([^.0-9][0-9a-zA-Z_\\\\.]+)>:\";\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):\\\\sR_RISCV_CALL(_PLT)?\\\\s_?mcount\\$\";\n    $type = \".quad\";\n    $alignment = 2;\n} elsif ($arch eq \"csky\") {\n    $mcount_regex = \"^\\\\s*([0-9a-fA-F]+):\\\\s*R_CKCORE_PCREL_JSR_IMM26BY2\\\\s+_mcount\\$\";\n    $alignment = 2;\n} else {\n    die \"Arch $arch is not supported with CONFIG_FTRACE_MCOUNT_RECORD\";\n}\n\nmy $text_found = 0;\nmy $read_function = 0;\nmy $opened = 0;\nmy $mcount_section = \"__mcount_loc\";\n\nmy $dirname;\nmy $filename;\nmy $prefix;\nmy $ext;\n\nif ($inputfile =~ m,^(.*)/([^/]*)$,) {\n    $dirname = $1;\n    $filename = $2;\n} else {\n    $dirname = \".\";\n    $filename = $inputfile;\n}\n\nif ($filename =~ m,^(.*)(\\.\\S),) {\n    $prefix = $1;\n    $ext = $2;\n} else {\n    $prefix = $filename;\n    $ext = \"\";\n}\n\nmy $mcount_s = $dirname . \"/.tmp_mc_\" . $prefix . \".s\";\nmy $mcount_o = $dirname . \"/.tmp_mc_\" . $prefix . \".o\";\n\n#\n# Step 1: find all the local (static functions) and weak symbols.\n#         't' is local, 'w/W' is weak\n#\nopen (IN, \"$nm $inputfile|\") || die \"error running $nm\";\nwhile (<IN>) {\n    if (/$local_regex/) {\n\t$locals{$1} = 1;\n    } elsif (/$weak_regex/) {\n\t$weak{$2} = $1;\n    }\n}\nclose(IN);\n\nmy @offsets;\t\t# Array of offsets of mcount callers\nmy $ref_func;\t\t# reference function to use for offsets\nmy $offset = 0;\t\t# offset of ref_func to section beginning\n\n##\n# update_funcs - print out the current mcount callers\n#\n#  Go through the list of offsets to callers and write them to\n#  the output file in a format that can be read by an assembler.\n#\nsub update_funcs\n{\n    return unless ($ref_func and @offsets);\n\n    # Sanity check on weak function. A weak function may be overwritten by\n    # another function of the same name, making all these offsets incorrect.\n    if (defined $weak{$ref_func}) {\n\tdie \"$inputfile: ERROR: referencing weak function\" .\n\t    \" $ref_func for mcount\\n\";\n    }\n\n    # is this function static? If so, note this fact.\n    if (defined $locals{$ref_func}) {\n\t$convert{$ref_func} = 1;\n    }\n\n    # Loop through all the mcount caller offsets and print a reference\n    # to the caller based from the ref_func.\n    if (!$opened) {\n\topen(FILE, \">$mcount_s\") || die \"can't create $mcount_s\\n\";\n\t$opened = 1;\n\tprint FILE \"\\t.section $mcount_section,\\\"a\\\",$section_type\\n\";\n\tprint FILE \"\\t.align $alignment\\n\" if (defined($alignment));\n    }\n    foreach my $cur_offset (@offsets) {\n\tprintf FILE \"\\t%s %s + %d\\n\", $type, $ref_func, $cur_offset - $offset;\n    }\n}\n\n#\n# Step 2: find the sections and mcount call sites\n#\nopen(IN, \"LC_ALL=C $objdump -hdr $inputfile|\") || die \"error running $objdump\";\n\nmy $text;\n\n\n# read headers first\nmy $read_headers = 1;\n\nwhile (<IN>) {\n\n    if ($read_headers && /$mcount_section/) {\n\t#\n\t# Somehow the make process can execute this script on an\n\t# object twice. If it does, we would duplicate the mcount\n\t# section and it will cause the function tracer self test\n\t# to fail. Check if the mcount section exists, and if it does,\n\t# warn and exit.\n\t#\n\tprint STDERR \"ERROR: $mcount_section already in $inputfile\\n\" .\n\t    \"\\tThis may be an indication that your build is corrupted.\\n\" .\n\t    \"\\tDelete $inputfile and try again. If the same object file\\n\" .\n\t    \"\\tstill causes an issue, then disable CONFIG_DYNAMIC_FTRACE.\\n\";\n\texit(-1);\n    }\n\n    # is it a section?\n    if (/$section_regex/) {\n\t$read_headers = 0;\n\n\t# Only record text sections that we know are safe\n\t$read_function = defined($text_sections{$1});\n\tif (!$read_function) {\n\t    foreach my $prefix (keys %text_section_prefixes) {\n\t\tif (substr($1, 0, length $prefix) eq $prefix) {\n\t\t    $read_function = 1;\n\t\t    last;\n\t\t}\n\t    }\n\t}\n\t# print out any recorded offsets\n\tupdate_funcs();\n\n\t# reset all markers and arrays\n\t$text_found = 0;\n\tundef($ref_func);\n\tundef(@offsets);\n\n    # section found, now is this a start of a function?\n    } elsif ($read_function && /$function_regex/) {\n\t$text_found = 1;\n\t$text = $2;\n\n\t# if this is either a local function or a weak function\n\t# keep looking for functions that are global that\n\t# we can use safely.\n\tif (!defined($locals{$text}) && !defined($weak{$text})) {\n\t    $ref_func = $text;\n\t    $read_function = 0;\n\t    $offset = hex $1;\n\t} else {\n\t    # if we already have a function, and this is weak, skip it\n\t    if (!defined($ref_func) && !defined($weak{$text}) &&\n\t\t # PPC64 can have symbols that start with .L and\n\t\t # gcc considers these special. Don't use them!\n\t\t $text !~ /^\\.L/) {\n\t\t$ref_func = $text;\n\t\t$offset = hex $1;\n\t    }\n\t}\n    }\n    # is this a call site to mcount? If so, record it to print later\n    if ($text_found && /$mcount_regex/) {\n\tpush(@offsets, (hex $1) + $mcount_adjust);\n    }\n}\n\n# dump out anymore offsets that may have been found\nupdate_funcs();\n\n# If we did not find any mcount callers, we are done (do nothing).\nif (!$opened) {\n    exit(0);\n}\n\nclose(FILE);\n\n#\n# Step 3: Compile the file that holds the list of call sites to mcount.\n#\n`$cc -o $mcount_o -c $mcount_s`;\n\nmy @converts = keys %convert;\n\n#\n# Step 4: Do we have sections that started with local functions?\n#\nif ($#converts >= 0) {\n    my $globallist = \"\";\n    my $locallist = \"\";\n\n    foreach my $con (@converts) {\n\t$globallist .= \" --globalize-symbol $con\";\n\t$locallist .= \" --localize-symbol $con\";\n    }\n\n    my $globalobj = $dirname . \"/.tmp_gl_\" . $filename;\n    my $globalmix = $dirname . \"/.tmp_mx_\" . $filename;\n\n    #\n    # Step 5: set up each local function as a global\n    #\n    `$objcopy $globallist $inputfile $globalobj`;\n\n    #\n    # Step 6: Link the global version to our list.\n    #\n    `$ld -r $globalobj $mcount_o -o $globalmix`;\n\n    #\n    # Step 7: Convert the local functions back into local symbols\n    #\n    `$objcopy $locallist $globalmix $inputfile`;\n\n    # Remove the temp files\n    `$rm $globalobj $globalmix`;\n\n} else {\n\n    my $mix = $dirname . \"/.tmp_mx_\" . $filename;\n\n    #\n    # Step 8: Link the object with our list of call sites object.\n    #\n    `$ld -r $inputfile $mcount_o -o $mix`;\n\n    #\n    # Step 9: Move the result back to the original object.\n    #\n    `$mv $mix $inputfile`;\n}\n\n# Clean up the temp files\n`$rm $mcount_o $mcount_s`;\n\nexit(0);\n\n# vim: softtabstop=4\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}