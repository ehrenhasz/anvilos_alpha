{
  "module_name": "rust_is_available_test.py",
  "hash_id": "3592b753c776add22b503d9d61ec532e9a9f9a9781be74c6148d1756ad1ed7f9",
  "original_prompt": "Ingested from linux-6.6.14/scripts/rust_is_available_test.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n\n\"\"\"Tests the `rust_is_available.sh` script.\n\nSome of the tests require the real programs to be available in `$PATH`\nunder their canonical name (and with the expected versions).\n\"\"\"\n\nimport enum\nimport os\nimport pathlib\nimport stat\nimport subprocess\nimport tempfile\nimport unittest\n\nclass TestRustIsAvailable(unittest.TestCase):\n    @enum.unique\n    class Expected(enum.Enum):\n        SUCCESS = enum.auto()\n        SUCCESS_WITH_WARNINGS = enum.auto()\n        SUCCESS_WITH_EXTRA_OUTPUT = enum.auto()\n        FAILURE = enum.auto()\n\n    @classmethod\n    def generate_executable(cls, content):\n        path = pathlib.Path(cls.tempdir.name)\n        name = str(len(tuple(path.iterdir())))\n        path = path / name\n        with open(path, \"w\") as file_:\n            file_.write(content)\n        os.chmod(path, os.stat(path).st_mode | stat.S_IXUSR)\n        return path\n\n    @classmethod\n    def generate_clang(cls, stdout):\n        return cls.generate_executable(f\"\"\"#!/usr/bin/env python3\nimport sys\nif \"-E\" in \" \".join(sys.argv):\n    print({repr(\"Clang \" + \" \".join(cls.llvm_default_version.split(\" \")))})\nelse:\n    print({repr(stdout)})\n\"\"\")\n\n    @classmethod\n    def generate_rustc(cls, stdout):\n        return cls.generate_executable(f\"\"\"#!/usr/bin/env python3\nimport sys\nif \"--print sysroot\" in \" \".join(sys.argv):\n    print({repr(cls.rust_default_sysroot)})\nelse:\n    print({repr(stdout)})\n\"\"\")\n\n    @classmethod\n    def generate_bindgen(cls, version_stdout, libclang_stderr):\n        return cls.generate_executable(f\"\"\"#!/usr/bin/env python3\nimport sys\nif \"rust_is_available_bindgen_libclang.h\" in \" \".join(sys.argv):\n    print({repr(libclang_stderr)}, file=sys.stderr)\nelse:\n    print({repr(version_stdout)})\n\"\"\")\n\n    @classmethod\n    def generate_bindgen_version(cls, stdout):\n        return cls.generate_bindgen(stdout, cls.bindgen_default_bindgen_libclang_stderr)\n\n    @classmethod\n    def generate_bindgen_libclang(cls, stderr):\n        return cls.generate_bindgen(cls.bindgen_default_bindgen_version_stdout, stderr)\n\n    @classmethod\n    def setUpClass(cls):\n        cls.tempdir = tempfile.TemporaryDirectory()\n\n        cls.missing = pathlib.Path(cls.tempdir.name) / \"missing\"\n\n        cls.nonexecutable = pathlib.Path(cls.tempdir.name) / \"nonexecutable\"\n        with open(cls.nonexecutable, \"w\") as file_:\n            file_.write(\"nonexecutable\")\n\n        cls.unexpected_binary = \"true\"\n\n        cls.rustc_default_version = subprocess.check_output((\"scripts/min-tool-version.sh\", \"rustc\")).decode().strip()\n        cls.bindgen_default_version = subprocess.check_output((\"scripts/min-tool-version.sh\", \"bindgen\")).decode().strip()\n        cls.llvm_default_version = subprocess.check_output((\"scripts/min-tool-version.sh\", \"llvm\")).decode().strip()\n        cls.rust_default_sysroot = subprocess.check_output((\"rustc\", \"--print\", \"sysroot\")).decode().strip()\n\n        cls.bindgen_default_bindgen_version_stdout = f\"bindgen {cls.bindgen_default_version}\"\n        cls.bindgen_default_bindgen_libclang_stderr = f\"scripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version {cls.llvm_default_version} [-W#pragma-messages], err: false\"\n\n        cls.default_rustc = cls.generate_rustc(f\"rustc {cls.rustc_default_version}\")\n        cls.default_bindgen =  cls.generate_bindgen(cls.bindgen_default_bindgen_version_stdout, cls.bindgen_default_bindgen_libclang_stderr)\n        cls.default_cc = cls.generate_clang(f\"clang version {cls.llvm_default_version}\")\n\n    def run_script(self, expected, override_env):\n        env = {\n            \"RUSTC\": self.default_rustc,\n            \"BINDGEN\": self.default_bindgen,\n            \"CC\": self.default_cc,\n        }\n\n        for key, value in override_env.items():\n            if value is None:\n                del env[key]\n                continue\n            env[key] = value\n\n        result = subprocess.run(\"scripts/rust_is_available.sh\", env=env, capture_output=True)\n\n        # The script should never output anything to `stdout`.\n        self.assertEqual(result.stdout, b\"\")\n\n        if expected == self.Expected.SUCCESS:\n            # When expecting a success, the script should return 0\n            # and it should not output anything to `stderr`.\n            self.assertEqual(result.returncode, 0)\n            self.assertEqual(result.stderr, b\"\")\n        elif expected == self.Expected.SUCCESS_WITH_EXTRA_OUTPUT:\n            # When expecting a success with extra output (that is not warnings,\n            # which is the common case), the script should return 0 and it\n            # should output at least something to `stderr` (the output should\n            # be checked further by the test).\n            self.assertEqual(result.returncode, 0)\n            self.assertNotEqual(result.stderr, b\"\")\n        elif expected == self.Expected.SUCCESS_WITH_WARNINGS:\n            # When expecting a success with warnings, the script should return 0\n            # and it should output at least the instructions to `stderr`.\n            self.assertEqual(result.returncode, 0)\n            self.assertIn(b\"Please see Documentation/rust/quick-start.rst for details\", result.stderr)\n        else:\n            # When expecting a failure, the script should return non-0\n            # and it should output at least the instructions to `stderr`.\n            self.assertNotEqual(result.returncode, 0)\n            self.assertIn(b\"Please see Documentation/rust/quick-start.rst for details\", result.stderr)\n\n        # The output will generally be UTF-8 (i.e. unless the user has\n        # put strange values in the environment).\n        result.stderr = result.stderr.decode()\n\n        return result\n\n    def test_rustc_unset(self):\n        result = self.run_script(self.Expected.FAILURE, { \"RUSTC\": None })\n        self.assertIn(\"Environment variable 'RUSTC' is not set.\", result.stderr)\n        self.assertIn(\"This script is intended to be called from Kbuild.\", result.stderr)\n\n    def test_bindgen_unset(self):\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": None })\n        self.assertIn(\"Environment variable 'BINDGEN' is not set.\", result.stderr)\n        self.assertIn(\"This script is intended to be called from Kbuild.\", result.stderr)\n\n    def test_cc_unset(self):\n        result = self.run_script(self.Expected.FAILURE, { \"CC\": None })\n        self.assertIn(\"Environment variable 'CC' is not set.\", result.stderr)\n        self.assertIn(\"This script is intended to be called from Kbuild.\", result.stderr)\n\n    def test_rustc_missing(self):\n        result = self.run_script(self.Expected.FAILURE, { \"RUSTC\": self.missing })\n        self.assertIn(f\"Rust compiler '{self.missing}' could not be found.\", result.stderr)\n\n    def test_bindgen_missing(self):\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": self.missing })\n        self.assertIn(f\"Rust bindings generator '{self.missing}' could not be found.\", result.stderr)\n\n    def test_rustc_nonexecutable(self):\n        result = self.run_script(self.Expected.FAILURE, { \"RUSTC\": self.nonexecutable })\n        self.assertIn(f\"Running '{self.nonexecutable}' to check the Rust compiler version failed with\", result.stderr)\n\n    def test_rustc_unexpected_binary(self):\n        result = self.run_script(self.Expected.FAILURE, { \"RUSTC\": self.unexpected_binary })\n        self.assertIn(f\"Running '{self.unexpected_binary}' to check the Rust compiler version did not return\", result.stderr)\n\n    def test_rustc_unexpected_name(self):\n        rustc = self.generate_rustc(f\"unexpected {self.rustc_default_version} (a8314ef7d 2022-06-27)\")\n        result = self.run_script(self.Expected.FAILURE, { \"RUSTC\": rustc })\n        self.assertIn(f\"Running '{rustc}' to check the Rust compiler version did not return\", result.stderr)\n\n    def test_rustc_unexpected_version(self):\n        rustc = self.generate_rustc(\"rustc unexpected (a8314ef7d 2022-06-27)\")\n        result = self.run_script(self.Expected.FAILURE, { \"RUSTC\": rustc })\n        self.assertIn(f\"Running '{rustc}' to check the Rust compiler version did not return\", result.stderr)\n\n    def test_rustc_no_minor(self):\n        rustc = self.generate_rustc(f\"rustc {'.'.join(self.rustc_default_version.split('.')[:2])} (a8314ef7d 2022-06-27)\")\n        result = self.run_script(self.Expected.FAILURE, { \"RUSTC\": rustc })\n        self.assertIn(f\"Running '{rustc}' to check the Rust compiler version did not return\", result.stderr)\n\n    def test_rustc_old_version(self):\n        rustc = self.generate_rustc(\"rustc 1.60.0 (a8314ef7d 2022-06-27)\")\n        result = self.run_script(self.Expected.FAILURE, { \"RUSTC\": rustc })\n        self.assertIn(f\"Rust compiler '{rustc}' is too old.\", result.stderr)\n\n    def test_rustc_new_version(self):\n        rustc = self.generate_rustc(\"rustc 1.999.0 (a8314ef7d 2099-06-27)\")\n        result = self.run_script(self.Expected.SUCCESS_WITH_WARNINGS, { \"RUSTC\": rustc })\n        self.assertIn(f\"Rust compiler '{rustc}' is too new. This may or may not work.\", result.stderr)\n\n    def test_bindgen_nonexecutable(self):\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": self.nonexecutable })\n        self.assertIn(f\"Running '{self.nonexecutable}' to check the Rust bindings generator version failed with\", result.stderr)\n\n    def test_bindgen_unexpected_binary(self):\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": self.unexpected_binary })\n        self.assertIn(f\"Running '{self.unexpected_binary}' to check the bindings generator version did not return\", result.stderr)\n\n    def test_bindgen_unexpected_name(self):\n        bindgen = self.generate_bindgen_version(f\"unexpected {self.bindgen_default_version}\")\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": bindgen })\n        self.assertIn(f\"Running '{bindgen}' to check the bindings generator version did not return\", result.stderr)\n\n    def test_bindgen_unexpected_version(self):\n        bindgen = self.generate_bindgen_version(\"bindgen unexpected\")\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": bindgen })\n        self.assertIn(f\"Running '{bindgen}' to check the bindings generator version did not return\", result.stderr)\n\n    def test_bindgen_no_minor(self):\n        bindgen = self.generate_bindgen_version(f\"bindgen {'.'.join(self.bindgen_default_version.split('.')[:2])}\")\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": bindgen })\n        self.assertIn(f\"Running '{bindgen}' to check the bindings generator version did not return\", result.stderr)\n\n    def test_bindgen_old_version(self):\n        bindgen = self.generate_bindgen_version(\"bindgen 0.50.0\")\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": bindgen })\n        self.assertIn(f\"Rust bindings generator '{bindgen}' is too old.\", result.stderr)\n\n    def test_bindgen_new_version(self):\n        bindgen = self.generate_bindgen_version(\"bindgen 0.999.0\")\n        result = self.run_script(self.Expected.SUCCESS_WITH_WARNINGS, { \"BINDGEN\": bindgen })\n        self.assertIn(f\"Rust bindings generator '{bindgen}' is too new. This may or may not work.\", result.stderr)\n\n    def test_bindgen_libclang_failure(self):\n        for env in (\n            { \"LLVM_CONFIG_PATH\": self.missing },\n            { \"LIBCLANG_PATH\": self.missing },\n            { \"CLANG_PATH\": self.missing },\n        ):\n            with self.subTest(env=env):\n                result = self.run_script(self.Expected.FAILURE, env | { \"PATH\": os.environ[\"PATH\"], \"BINDGEN\": \"bindgen\" })\n                self.assertIn(\"Running 'bindgen' to check the libclang version (used by the Rust\", result.stderr)\n                self.assertIn(\"bindings generator) failed with code \", result.stderr)\n\n    def test_bindgen_libclang_unexpected_version(self):\n        bindgen = self.generate_bindgen_libclang(\"scripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version unexpected [-W#pragma-messages], err: false\")\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": bindgen })\n        self.assertIn(f\"Running '{bindgen}' to check the libclang version (used by the Rust\", result.stderr)\n        self.assertIn(\"bindings generator) did not return an expected output. See output\", result.stderr)\n\n    def test_bindgen_libclang_old_version(self):\n        bindgen = self.generate_bindgen_libclang(\"scripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version 10.0.0 [-W#pragma-messages], err: false\")\n        result = self.run_script(self.Expected.FAILURE, { \"BINDGEN\": bindgen })\n        self.assertIn(f\"libclang (used by the Rust bindings generator '{bindgen}') is too old.\", result.stderr)\n\n    def test_clang_matches_bindgen_libclang_different_bindgen(self):\n        bindgen = self.generate_bindgen_libclang(\"scripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version 999.0.0 [-W#pragma-messages], err: false\")\n        result = self.run_script(self.Expected.SUCCESS_WITH_WARNINGS, { \"BINDGEN\": bindgen })\n        self.assertIn(\"version does not match Clang's. This may be a problem.\", result.stderr)\n\n    def test_clang_matches_bindgen_libclang_different_clang(self):\n        cc = self.generate_clang(\"clang version 999.0.0\")\n        result = self.run_script(self.Expected.SUCCESS_WITH_WARNINGS, { \"CC\": cc })\n        self.assertIn(\"version does not match Clang's. This may be a problem.\", result.stderr)\n\n    def test_rustc_src_core_krustflags(self):\n        result = self.run_script(self.Expected.FAILURE, { \"PATH\": os.environ[\"PATH\"], \"RUSTC\": \"rustc\", \"KRUSTFLAGS\": f\"--sysroot={self.missing}\" })\n        self.assertIn(\"Source code for the 'core' standard library could not be found\", result.stderr)\n\n    def test_rustc_src_core_rustlibsrc(self):\n        result = self.run_script(self.Expected.FAILURE, { \"RUST_LIB_SRC\": self.missing })\n        self.assertIn(\"Source code for the 'core' standard library could not be found\", result.stderr)\n\n    def test_success_cc_unknown(self):\n        result = self.run_script(self.Expected.SUCCESS_WITH_EXTRA_OUTPUT, { \"CC\": self.missing })\n        self.assertIn(\"unknown C compiler\", result.stderr)\n\n    def test_success_cc_multiple_arguments_ccache(self):\n        clang = self.generate_clang(f\"\"\"Ubuntu clang version {self.llvm_default_version}-1ubuntu1\nTarget: x86_64-pc-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\n\"\"\")\n        result = self.run_script(self.Expected.SUCCESS, { \"CC\": f\"{clang} clang\" })\n\n    def test_success_rustc_version(self):\n        for rustc_stdout in (\n            f\"rustc {self.rustc_default_version} (a8314ef7d 2022-06-27)\",\n            f\"rustc {self.rustc_default_version}-dev (a8314ef7d 2022-06-27)\",\n            f\"rustc {self.rustc_default_version}-1.60.0 (a8314ef7d 2022-06-27)\",\n        ):\n            with self.subTest(rustc_stdout=rustc_stdout):\n                rustc = self.generate_rustc(rustc_stdout)\n                result = self.run_script(self.Expected.SUCCESS, { \"RUSTC\": rustc })\n\n    def test_success_bindgen_version(self):\n        for bindgen_stdout in (\n            f\"bindgen {self.bindgen_default_version}\",\n            f\"bindgen {self.bindgen_default_version}-dev\",\n            f\"bindgen {self.bindgen_default_version}-0.999.0\",\n        ):\n            with self.subTest(bindgen_stdout=bindgen_stdout):\n                bindgen = self.generate_bindgen_version(bindgen_stdout)\n                result = self.run_script(self.Expected.SUCCESS, { \"BINDGEN\": bindgen })\n\n    def test_success_bindgen_libclang(self):\n        for stderr in (\n            f\"scripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version {self.llvm_default_version} (https://github.com/llvm/llvm-project.git 4a2c05b05ed07f1f620e94f6524a8b4b2760a0b1) [-W#pragma-messages], err: false\",\n            f\"/home/jd/Documents/dev/kernel-module-flake/linux-6.1/outputs/dev/lib/modules/6.1.0-development/source/scripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version {self.llvm_default_version}  [-W#pragma-messages], err: false\",\n            f\"scripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version {self.llvm_default_version} (Fedora 13.0.0-3.fc35) [-W#pragma-messages], err: false\",\n            f\"\"\"\n/nix/store/dsd5gz46hdbdk2rfdimqddhq6m8m8fqs-bash-5.1-p16/bin/bash: warning: setlocale: LC_ALL: cannot change locale (c)\nscripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version {self.llvm_default_version}  [-W#pragma-messages], err: false\n\"\"\",\n            f\"\"\"\n/nix/store/dsd5gz46hdbdk2rfdimqddhq6m8m8fqs-bash-5.1.0-p16/bin/bash: warning: setlocale: LC_ALL: cannot change locale (c)\n/home/jd/Documents/dev/kernel-module-flake/linux-6.1/outputs/dev/lib/modules/6.1.0-development/source/scripts/rust_is_available_bindgen_libclang.h:2:9: warning: clang version {self.llvm_default_version} (Fedora 13.0.0-3.fc35) [-W#pragma-messages], err: false\n\"\"\"\n        ):\n            with self.subTest(stderr=stderr):\n                bindgen = self.generate_bindgen_libclang(stderr)\n                result = self.run_script(self.Expected.SUCCESS, { \"BINDGEN\": bindgen })\n\n    def test_success_clang_version(self):\n        for clang_stdout in (\n            f\"clang version {self.llvm_default_version} (https://github.com/llvm/llvm-project.git 4a2c05b05ed07f1f620e94f6524a8b4b2760a0b1)\",\n            f\"clang version {self.llvm_default_version}-dev\",\n            f\"clang version {self.llvm_default_version}-2~ubuntu20.04.1\",\n            f\"Ubuntu clang version {self.llvm_default_version}-2~ubuntu20.04.1\",\n        ):\n            with self.subTest(clang_stdout=clang_stdout):\n                clang = self.generate_clang(clang_stdout)\n                result = self.run_script(self.Expected.SUCCESS, { \"CC\": clang })\n\n    def test_success_real_programs(self):\n        for cc in [\"gcc\", \"clang\"]:\n            with self.subTest(cc=cc):\n                result = self.run_script(self.Expected.SUCCESS, {\n                    \"PATH\": os.environ[\"PATH\"],\n                    \"RUSTC\": \"rustc\",\n                    \"BINDGEN\": \"bindgen\",\n                    \"CC\": cc,\n                })\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}