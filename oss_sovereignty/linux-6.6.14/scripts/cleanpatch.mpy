{
  "module_name": "cleanpatch",
  "hash_id": "61b6c15d7291cf1cbeb78dc03e4d778f8f63a0c86bfd00f275afb661c82699dc",
  "original_prompt": "Ingested from linux-6.6.14/scripts/cleanpatch",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# Clean a patch file -- or directory of patch files -- of stealth whitespace.\n# WARNING: this can be a highly destructive operation.  Use with caution.\n#\n\nuse warnings;\nuse bytes;\nuse File::Basename;\n\n# Default options\n$max_width = 79;\n\n# Clean up space-tab sequences, either by removing spaces or\n# replacing them with tabs.\nsub clean_space_tabs($)\n{\n    no bytes;\t\t\t# Tab alignment depends on characters\n\n    my($li) = @_;\n    my($lo) = '';\n    my $pos = 0;\n    my $nsp = 0;\n    my($i, $c);\n\n    for ($i = 0; $i < length($li); $i++) {\n\t$c = substr($li, $i, 1);\n\tif ($c eq \"\\t\") {\n\t    my $npos = ($pos+$nsp+8) & ~7;\n\t    my $ntab = ($npos >> 3) - ($pos >> 3);\n\t    $lo .= \"\\t\" x $ntab;\n\t    $pos = $npos;\n\t    $nsp = 0;\n\t} elsif ($c eq \"\\n\" || $c eq \"\\r\") {\n\t    $lo .= \" \" x $nsp;\n\t    $pos += $nsp;\n\t    $nsp = 0;\n\t    $lo .= $c;\n\t    $pos = 0;\n\t} elsif ($c eq \" \") {\n\t    $nsp++;\n\t} else {\n\t    $lo .= \" \" x $nsp;\n\t    $pos += $nsp;\n\t    $nsp = 0;\n\t    $lo .= $c;\n\t    $pos++;\n\t}\n    }\n    $lo .= \" \" x $nsp;\n    return $lo;\n}\n\n# Compute the visual width of a string\nsub strwidth($) {\n    no bytes;\t\t\t# Tab alignment depends on characters\n\n    my($li) = @_;\n    my($c, $i);\n    my $pos = 0;\n    my $mlen = 0;\n\n    for ($i = 0; $i < length($li); $i++) {\n\t$c = substr($li,$i,1);\n\tif ($c eq \"\\t\") {\n\t    $pos = ($pos+8) & ~7;\n\t} elsif ($c eq \"\\n\") {\n\t    $mlen = $pos if ($pos > $mlen);\n\t    $pos = 0;\n\t} else {\n\t    $pos++;\n\t}\n    }\n\n    $mlen = $pos if ($pos > $mlen);\n    return $mlen;\n}\n\n$name = basename($0);\n\n@files = ();\n\nwhile (defined($a = shift(@ARGV))) {\n    if ($a =~ /^-/) {\n\tif ($a eq '-width' || $a eq '-w') {\n\t    $max_width = shift(@ARGV)+0;\n\t} else {\n\t    print STDERR \"Usage: $name [-width #] files...\\n\";\n\t    exit 1;\n\t}\n    } else {\n\tpush(@files, $a);\n    }\n}\n\nforeach $f ( @files ) {\n    print STDERR \"$name: $f\\n\";\n\n    if (! -f $f) {\n\tprint STDERR \"$f: not a file\\n\";\n\tnext;\n    }\n\n    if (!open(FILE, '+<', $f)) {\n\tprint STDERR \"$name: Cannot open file: $f: $!\\n\";\n\tnext;\n    }\n\n    binmode FILE;\n\n    # First, verify that it is not a binary file; consider any file\n    # with a zero byte to be a binary file.  Is there any better, or\n    # additional, heuristic that should be applied?\n    $is_binary = 0;\n\n    while (read(FILE, $data, 65536) > 0) {\n\tif ($data =~ /\\0/) {\n\t    $is_binary = 1;\n\t    last;\n\t}\n    }\n\n    if ($is_binary) {\n\tprint STDERR \"$name: $f: binary file\\n\";\n\tnext;\n    }\n\n    seek(FILE, 0, 0);\n\n    $in_bytes = 0;\n    $out_bytes = 0;\n    $lineno = 0;\n\n    @lines  = ();\n\n    $in_hunk = 0;\n    $err = 0;\n\n    while ( defined($line = <FILE>) ) {\n\t$lineno++;\n\t$in_bytes += length($line);\n\n\tif (!$in_hunk) {\n\t    if ($line =~\n\t\t/^\\@\\@\\s+\\-([0-9]+),([0-9]+)\\s+\\+([0-9]+),([0-9]+)\\s\\@\\@/) {\n\t\t$minus_lines = $2;\n\t\t$plus_lines = $4;\n\t\tif ($minus_lines || $plus_lines) {\n\t\t    $in_hunk = 1;\n\t\t    @hunk_lines = ($line);\n\t\t}\n\t    } else {\n\t\tpush(@lines, $line);\n\t\t$out_bytes += length($line);\n\t    }\n\t} else {\n\t    # We're in a hunk\n\n\t    if ($line =~ /^\\+/) {\n\t\t$plus_lines--;\n\n\t\t$text = substr($line, 1);\n\t\t$text =~ s/[ \\t\\r]*$//;\t\t# Remove trailing spaces\n\t\t$text = clean_space_tabs($text);\n\n\t\t$l_width = strwidth($text);\n\t\tif ($max_width && $l_width > $max_width) {\n\t\t    print STDERR\n\t\t\t\"$f:$lineno: adds line exceeds $max_width \",\n\t\t\t\"characters ($l_width)\\n\";\n\t\t}\n\n\t\tpush(@hunk_lines, '+'.$text);\n\t    } elsif ($line =~ /^\\-/) {\n\t\t$minus_lines--;\n\t\tpush(@hunk_lines, $line);\n\t    } elsif ($line =~ /^ /) {\n\t\t$plus_lines--;\n\t\t$minus_lines--;\n\t\tpush(@hunk_lines, $line);\n\t    } else {\n\t\tprint STDERR \"$name: $f: malformed patch\\n\";\n\t\t$err = 1;\n\t\tlast;\n\t    }\n\n\t    if ($plus_lines < 0 || $minus_lines < 0) {\n\t\tprint STDERR \"$name: $f: malformed patch\\n\";\n\t\t$err = 1;\n\t\tlast;\n\t    } elsif ($plus_lines == 0 && $minus_lines == 0) {\n\t\t# End of a hunk.  Process this hunk.\n\t\tmy $i;\n\t\tmy $l;\n\t\tmy @h = ();\n\t\tmy $adj = 0;\n\t\tmy $done = 0;\n\n\t\tfor ($i = scalar(@hunk_lines)-1; $i > 0; $i--) {\n\t\t    $l = $hunk_lines[$i];\n\t\t    if (!$done && $l eq \"+\\n\") {\n\t\t\t$adj++; # Skip this line\n\t\t    } elsif ($l =~ /^[ +]/) {\n\t\t\t$done = 1;\n\t\t\tunshift(@h, $l);\n\t\t    } else {\n\t\t\tunshift(@h, $l);\n\t\t    }\n\t\t}\n\n\t\t$l = $hunk_lines[0];  # Hunk header\n\t\tundef @hunk_lines;    # Free memory\n\n\t\tif ($adj) {\n\t\t    die unless\n\t\t\t($l =~ /^\\@\\@\\s+\\-([0-9]+),([0-9]+)\\s+\\+([0-9]+),([0-9]+)\\s\\@\\@(.*)$/);\n\t\t    my $mstart = $1;\n\t\t    my $mlin = $2;\n\t\t    my $pstart = $3;\n\t\t    my $plin = $4;\n\t\t    my $tail = $5; # doesn't include the final newline\n\n\t\t    $l = sprintf(\"@@ -%d,%d +%d,%d @@%s\\n\",\n\t\t\t\t $mstart, $mlin, $pstart, $plin-$adj,\n\t\t\t\t $tail);\n\t\t}\n\t\tunshift(@h, $l);\n\n\t\t# Transfer to the output array\n\t\tforeach $l (@h) {\n\t\t    $out_bytes += length($l);\n\t\t    push(@lines, $l);\n\t\t}\n\n\t\t$in_hunk = 0;\n\t    }\n\t}\n    }\n\n    if ($in_hunk) {\n\tprint STDERR \"$name: $f: malformed patch\\n\";\n\t$err = 1;\n    }\n\n    if (!$err) {\n\tif ($in_bytes != $out_bytes) {\n\t    # Only write to the file if changed\n\t    seek(FILE, 0, 0);\n\t    print FILE @lines;\n\n\t    if ( !defined($where = tell(FILE)) ||\n\t\t !truncate(FILE, $where) ) {\n\t\tdie \"$name: Failed to truncate modified file: $f: $!\\n\";\n\t    }\n\t}\n    }\n\n    close(FILE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}