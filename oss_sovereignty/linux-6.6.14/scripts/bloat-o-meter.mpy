{
  "module_name": "bloat-o-meter",
  "hash_id": "42cf0e02e0a9219547dc49182a1f97e3b6c514f5343ebf7c466646d9e97713d6",
  "original_prompt": "Ingested from linux-6.6.14/scripts/bloat-o-meter",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# Copyright 2004 Matt Mackall <mpm@selenic.com>\n#\n# inspired by perl Bloat-O-Meter (c) 1997 by Andi Kleen\n#\n# This software may be used and distributed according to the terms\n# of the GNU General Public License, incorporated herein by reference.\n\nimport sys, os, re, argparse\nfrom signal import signal, SIGPIPE, SIG_DFL\n\nsignal(SIGPIPE, SIG_DFL)\n\nparser = argparse.ArgumentParser(description=\"Simple script used to compare the symbol sizes of 2 object files\")\ngroup = parser.add_mutually_exclusive_group()\ngroup.add_argument('-c', help='categorize output based on symbol type', action='store_true')\ngroup.add_argument('-d', help='Show delta of Data Section', action='store_true')\ngroup.add_argument('-t', help='Show delta of text Section', action='store_true')\nparser.add_argument('-p', dest='prefix', help='Arch prefix for the tool being used. Useful in cross build scenarios')\nparser.add_argument('file1', help='First file to compare')\nparser.add_argument('file2', help='Second file to compare')\n\nargs = parser.parse_args()\n\nre_NUMBER = re.compile(r'\\.[0-9]+')\n\ndef getsizes(file, format):\n    sym = {}\n    nm = \"nm\"\n    if args.prefix:\n        nm = \"{}nm\".format(args.prefix)\n\n    with os.popen(\"{} --size-sort {}\".format(nm, file)) as f:\n        for line in f:\n            if line.startswith(\"\\n\") or \":\" in line:\n                continue\n            size, type, name = line.split()\n            if type in format:\n                # strip generated symbols\n                if name.startswith(\"__mod_\"): continue\n                if name.startswith(\"__se_sys\"): continue\n                if name.startswith(\"__se_compat_sys\"): continue\n                if name.startswith(\"__addressable_\"): continue\n                if name == \"linux_banner\": continue\n                if name == \"vermagic\": continue\n                # statics and some other optimizations adds random .NUMBER\n                name = re_NUMBER.sub('', name)\n                sym[name] = sym.get(name, 0) + int(size, 16)\n    return sym\n\ndef calc(oldfile, newfile, format):\n    old = getsizes(oldfile, format)\n    new = getsizes(newfile, format)\n    grow, shrink, add, remove, up, down = 0, 0, 0, 0, 0, 0\n    delta, common = [], {}\n    otot, ntot = 0, 0\n\n    for a in old:\n        if a in new:\n            common[a] = 1\n\n    for name in old:\n        otot += old[name]\n        if name not in common:\n            remove += 1\n            down += old[name]\n            delta.append((-old[name], name))\n\n    for name in new:\n        ntot += new[name]\n        if name not in common:\n            add += 1\n            up += new[name]\n            delta.append((new[name], name))\n\n    for name in common:\n        d = new.get(name, 0) - old.get(name, 0)\n        if d>0: grow, up = grow+1, up+d\n        if d<0: shrink, down = shrink+1, down-d\n        delta.append((d, name))\n\n    delta.sort(reverse=True)\n    return grow, shrink, add, remove, up, down, delta, old, new, otot, ntot\n\ndef print_result(symboltype, symbolformat):\n    grow, shrink, add, remove, up, down, delta, old, new, otot, ntot = \\\n    calc(args.file1, args.file2, symbolformat)\n\n    print(\"add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)\" % \\\n          (add, remove, grow, shrink, up, -down, up-down))\n    print(\"%-40s %7s %7s %+7s\" % (symboltype, \"old\", \"new\", \"delta\"))\n    for d, n in delta:\n        if d: print(\"%-40s %7s %7s %+7d\" % (n, old.get(n,\"-\"), new.get(n,\"-\"), d))\n\n    if otot:\n        percent = (ntot - otot) * 100.0 / otot\n    else:\n        percent = 0\n    print(\"Total: Before=%d, After=%d, chg %+.2f%%\" % (otot, ntot, percent))\n\nif args.c:\n    print_result(\"Function\", \"tTwW\")\n    print_result(\"Data\", \"dDbBvV\")\n    print_result(\"RO Data\", \"rR\")\nelif args.d:\n    print_result(\"Data\", \"dDbBrRvV\")\nelif args.t:\n    print_result(\"Function\", \"tTwW\")\nelse:\n    print_result(\"Function\", \"tTdDbBrRvVwW\")\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}