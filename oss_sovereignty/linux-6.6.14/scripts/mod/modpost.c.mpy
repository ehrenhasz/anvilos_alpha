{
  "module_name": "modpost.c",
  "hash_id": "9f1146594d64392b8ead51fd69b801b85512484e4f426af2fc18d1d588242cb8",
  "original_prompt": "Ingested from linux-6.6.14/scripts/mod/modpost.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n#include <elf.h>\n#include <fnmatch.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <errno.h>\n#include \"modpost.h\"\n#include \"../../include/linux/license.h\"\n#include \"../../include/linux/module_symbol.h\"\n\nstatic bool module_enabled;\n \nstatic bool modversions;\n \nstatic bool all_versions;\n \nstatic bool external_module;\n \nstatic bool warn_unresolved;\n\nstatic int sec_mismatch_count;\nstatic bool sec_mismatch_warn_only = true;\n \nstatic bool trim_unused_exports;\n\n \nstatic bool ignore_missing_files;\n \nstatic bool allow_missing_ns_imports;\n\nstatic bool error_occurred;\n\nstatic bool extra_warn;\n\n \n#define MAX_UNRESOLVED_REPORTS\t10\nstatic unsigned int nr_unresolved;\n\n \n\n#define MODULE_NAME_LEN (64 - sizeof(Elf_Addr))\n\nvoid __attribute__((format(printf, 2, 3)))\nmodpost_log(enum loglevel loglevel, const char *fmt, ...)\n{\n\tva_list arglist;\n\n\tswitch (loglevel) {\n\tcase LOG_WARN:\n\t\tfprintf(stderr, \"WARNING: \");\n\t\tbreak;\n\tcase LOG_ERROR:\n\t\tfprintf(stderr, \"ERROR: \");\n\t\tbreak;\n\tcase LOG_FATAL:\n\t\tfprintf(stderr, \"FATAL: \");\n\t\tbreak;\n\tdefault:  \n\t\tbreak;\n\t}\n\n\tfprintf(stderr, \"modpost: \");\n\n\tva_start(arglist, fmt);\n\tvfprintf(stderr, fmt, arglist);\n\tva_end(arglist);\n\n\tif (loglevel == LOG_FATAL)\n\t\texit(1);\n\tif (loglevel == LOG_ERROR)\n\t\terror_occurred = true;\n}\n\nstatic inline bool strends(const char *str, const char *postfix)\n{\n\tif (strlen(str) < strlen(postfix))\n\t\treturn false;\n\n\treturn strcmp(str + strlen(str) - strlen(postfix), postfix) == 0;\n}\n\nvoid *do_nofail(void *ptr, const char *expr)\n{\n\tif (!ptr)\n\t\tfatal(\"Memory allocation failure: %s.\\n\", expr);\n\n\treturn ptr;\n}\n\nchar *read_text_file(const char *filename)\n{\n\tstruct stat st;\n\tsize_t nbytes;\n\tint fd;\n\tchar *buf;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\n\tbuf = NOFAIL(malloc(st.st_size + 1));\n\n\tnbytes = st.st_size;\n\n\twhile (nbytes) {\n\t\tssize_t bytes_read;\n\n\t\tbytes_read = read(fd, buf, nbytes);\n\t\tif (bytes_read < 0) {\n\t\t\tperror(filename);\n\t\t\texit(1);\n\t\t}\n\n\t\tnbytes -= bytes_read;\n\t}\n\tbuf[st.st_size] = '\\0';\n\n\tclose(fd);\n\n\treturn buf;\n}\n\nchar *get_line(char **stringp)\n{\n\tchar *orig = *stringp, *next;\n\n\t \n\tif (!orig || *orig == '\\0')\n\t\treturn NULL;\n\n\t \n\tnext = strchr(orig, '\\n');\n\tif (next)\n\t\t*next++ = '\\0';\n\n\t*stringp = next;\n\n\treturn orig;\n}\n\n \nLIST_HEAD(modules);\n\nstatic struct module *find_module(const char *modname)\n{\n\tstruct module *mod;\n\n\tlist_for_each_entry(mod, &modules, list) {\n\t\tif (strcmp(mod->name, modname) == 0)\n\t\t\treturn mod;\n\t}\n\treturn NULL;\n}\n\nstatic struct module *new_module(const char *name, size_t namelen)\n{\n\tstruct module *mod;\n\n\tmod = NOFAIL(malloc(sizeof(*mod) + namelen + 1));\n\tmemset(mod, 0, sizeof(*mod));\n\n\tINIT_LIST_HEAD(&mod->exported_symbols);\n\tINIT_LIST_HEAD(&mod->unresolved_symbols);\n\tINIT_LIST_HEAD(&mod->missing_namespaces);\n\tINIT_LIST_HEAD(&mod->imported_namespaces);\n\n\tmemcpy(mod->name, name, namelen);\n\tmod->name[namelen] = '\\0';\n\tmod->is_vmlinux = (strcmp(mod->name, \"vmlinux\") == 0);\n\n\t \n\tmod->is_gpl_compatible = true;\n\n\tlist_add_tail(&mod->list, &modules);\n\n\treturn mod;\n}\n\n \n\n#define SYMBOL_HASH_SIZE 1024\n\nstruct symbol {\n\tstruct symbol *next;\n\tstruct list_head list;\t \n\tstruct module *module;\n\tchar *namespace;\n\tunsigned int crc;\n\tbool crc_valid;\n\tbool weak;\n\tbool is_func;\n\tbool is_gpl_only;\t \n\tbool used;\t\t \n\tchar name[];\n};\n\nstatic struct symbol *symbolhash[SYMBOL_HASH_SIZE];\n\n \nstatic inline unsigned int tdb_hash(const char *name)\n{\n\tunsigned value;\t \n\tunsigned   i;\t \n\n\t \n\tfor (value = 0x238F13AF * strlen(name), i = 0; name[i]; i++)\n\t\tvalue = (value + (((unsigned char *)name)[i] << (i*5 % 24)));\n\n\treturn (1103515243 * value + 12345);\n}\n\n \nstatic struct symbol *alloc_symbol(const char *name)\n{\n\tstruct symbol *s = NOFAIL(malloc(sizeof(*s) + strlen(name) + 1));\n\n\tmemset(s, 0, sizeof(*s));\n\tstrcpy(s->name, name);\n\n\treturn s;\n}\n\n \nstatic void hash_add_symbol(struct symbol *sym)\n{\n\tunsigned int hash;\n\n\thash = tdb_hash(sym->name) % SYMBOL_HASH_SIZE;\n\tsym->next = symbolhash[hash];\n\tsymbolhash[hash] = sym;\n}\n\nstatic void sym_add_unresolved(const char *name, struct module *mod, bool weak)\n{\n\tstruct symbol *sym;\n\n\tsym = alloc_symbol(name);\n\tsym->weak = weak;\n\n\tlist_add_tail(&sym->list, &mod->unresolved_symbols);\n}\n\nstatic struct symbol *sym_find_with_module(const char *name, struct module *mod)\n{\n\tstruct symbol *s;\n\n\t \n\tif (name[0] == '.')\n\t\tname++;\n\n\tfor (s = symbolhash[tdb_hash(name) % SYMBOL_HASH_SIZE]; s; s = s->next) {\n\t\tif (strcmp(s->name, name) == 0 && (!mod || s->module == mod))\n\t\t\treturn s;\n\t}\n\treturn NULL;\n}\n\nstatic struct symbol *find_symbol(const char *name)\n{\n\treturn sym_find_with_module(name, NULL);\n}\n\nstruct namespace_list {\n\tstruct list_head list;\n\tchar namespace[];\n};\n\nstatic bool contains_namespace(struct list_head *head, const char *namespace)\n{\n\tstruct namespace_list *list;\n\n\t \n\tif (!namespace[0])\n\t\treturn true;\n\n\tlist_for_each_entry(list, head, list) {\n\t\tif (!strcmp(list->namespace, namespace))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void add_namespace(struct list_head *head, const char *namespace)\n{\n\tstruct namespace_list *ns_entry;\n\n\tif (!contains_namespace(head, namespace)) {\n\t\tns_entry = NOFAIL(malloc(sizeof(*ns_entry) +\n\t\t\t\t\t strlen(namespace) + 1));\n\t\tstrcpy(ns_entry->namespace, namespace);\n\t\tlist_add_tail(&ns_entry->list, head);\n\t}\n}\n\nstatic void *sym_get_data_by_offset(const struct elf_info *info,\n\t\t\t\t    unsigned int secindex, unsigned long offset)\n{\n\tElf_Shdr *sechdr = &info->sechdrs[secindex];\n\n\treturn (void *)info->hdr + sechdr->sh_offset + offset;\n}\n\nvoid *sym_get_data(const struct elf_info *info, const Elf_Sym *sym)\n{\n\treturn sym_get_data_by_offset(info, get_secindex(info, sym),\n\t\t\t\t      sym->st_value);\n}\n\nstatic const char *sech_name(const struct elf_info *info, Elf_Shdr *sechdr)\n{\n\treturn sym_get_data_by_offset(info, info->secindex_strings,\n\t\t\t\t      sechdr->sh_name);\n}\n\nstatic const char *sec_name(const struct elf_info *info, unsigned int secindex)\n{\n\t \n\tif (secindex >= info->num_sections)\n\t\treturn \"\";\n\n\treturn sech_name(info, &info->sechdrs[secindex]);\n}\n\n#define strstarts(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)\n\nstatic struct symbol *sym_add_exported(const char *name, struct module *mod,\n\t\t\t\t       bool gpl_only, const char *namespace)\n{\n\tstruct symbol *s = find_symbol(name);\n\n\tif (s && (!external_module || s->module->is_vmlinux || s->module == mod)) {\n\t\terror(\"%s: '%s' exported twice. Previous export was in %s%s\\n\",\n\t\t      mod->name, name, s->module->name,\n\t\t      s->module->is_vmlinux ? \"\" : \".ko\");\n\t}\n\n\ts = alloc_symbol(name);\n\ts->module = mod;\n\ts->is_gpl_only = gpl_only;\n\ts->namespace = NOFAIL(strdup(namespace));\n\tlist_add_tail(&s->list, &mod->exported_symbols);\n\thash_add_symbol(s);\n\n\treturn s;\n}\n\nstatic void sym_set_crc(struct symbol *sym, unsigned int crc)\n{\n\tsym->crc = crc;\n\tsym->crc_valid = true;\n}\n\nstatic void *grab_file(const char *filename, size_t *size)\n{\n\tstruct stat st;\n\tvoid *map = MAP_FAILED;\n\tint fd;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\tif (fstat(fd, &st))\n\t\tgoto failed;\n\n\t*size = st.st_size;\n\tmap = mmap(NULL, *size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);\n\nfailed:\n\tclose(fd);\n\tif (map == MAP_FAILED)\n\t\treturn NULL;\n\treturn map;\n}\n\nstatic void release_file(void *file, size_t size)\n{\n\tmunmap(file, size);\n}\n\nstatic int parse_elf(struct elf_info *info, const char *filename)\n{\n\tunsigned int i;\n\tElf_Ehdr *hdr;\n\tElf_Shdr *sechdrs;\n\tElf_Sym  *sym;\n\tconst char *secstrings;\n\tunsigned int symtab_idx = ~0U, symtab_shndx_idx = ~0U;\n\n\thdr = grab_file(filename, &info->size);\n\tif (!hdr) {\n\t\tif (ignore_missing_files) {\n\t\t\tfprintf(stderr, \"%s: %s (ignored)\\n\", filename,\n\t\t\t\tstrerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\tinfo->hdr = hdr;\n\tif (info->size < sizeof(*hdr)) {\n\t\t \n\t\treturn 0;\n\t}\n\t \n\tif ((hdr->e_ident[EI_MAG0] != ELFMAG0) ||\n\t    (hdr->e_ident[EI_MAG1] != ELFMAG1) ||\n\t    (hdr->e_ident[EI_MAG2] != ELFMAG2) ||\n\t    (hdr->e_ident[EI_MAG3] != ELFMAG3)) {\n\t\t \n\t\treturn 0;\n\t}\n\t \n\thdr->e_type      = TO_NATIVE(hdr->e_type);\n\thdr->e_machine   = TO_NATIVE(hdr->e_machine);\n\thdr->e_version   = TO_NATIVE(hdr->e_version);\n\thdr->e_entry     = TO_NATIVE(hdr->e_entry);\n\thdr->e_phoff     = TO_NATIVE(hdr->e_phoff);\n\thdr->e_shoff     = TO_NATIVE(hdr->e_shoff);\n\thdr->e_flags     = TO_NATIVE(hdr->e_flags);\n\thdr->e_ehsize    = TO_NATIVE(hdr->e_ehsize);\n\thdr->e_phentsize = TO_NATIVE(hdr->e_phentsize);\n\thdr->e_phnum     = TO_NATIVE(hdr->e_phnum);\n\thdr->e_shentsize = TO_NATIVE(hdr->e_shentsize);\n\thdr->e_shnum     = TO_NATIVE(hdr->e_shnum);\n\thdr->e_shstrndx  = TO_NATIVE(hdr->e_shstrndx);\n\tsechdrs = (void *)hdr + hdr->e_shoff;\n\tinfo->sechdrs = sechdrs;\n\n\t \n\tif (hdr->e_type != ET_REL)\n\t\tfatal(\"%s: not relocatable object.\", filename);\n\n\t \n\tif (hdr->e_shoff > info->size) {\n\t\tfatal(\"section header offset=%lu in file '%s' is bigger than filesize=%zu\\n\",\n\t\t      (unsigned long)hdr->e_shoff, filename, info->size);\n\t\treturn 0;\n\t}\n\n\tif (hdr->e_shnum == SHN_UNDEF) {\n\t\t \n\t\tinfo->num_sections = TO_NATIVE(sechdrs[0].sh_size);\n\t}\n\telse {\n\t\tinfo->num_sections = hdr->e_shnum;\n\t}\n\tif (hdr->e_shstrndx == SHN_XINDEX) {\n\t\tinfo->secindex_strings = TO_NATIVE(sechdrs[0].sh_link);\n\t}\n\telse {\n\t\tinfo->secindex_strings = hdr->e_shstrndx;\n\t}\n\n\t \n\tfor (i = 0; i < info->num_sections; i++) {\n\t\tsechdrs[i].sh_name      = TO_NATIVE(sechdrs[i].sh_name);\n\t\tsechdrs[i].sh_type      = TO_NATIVE(sechdrs[i].sh_type);\n\t\tsechdrs[i].sh_flags     = TO_NATIVE(sechdrs[i].sh_flags);\n\t\tsechdrs[i].sh_addr      = TO_NATIVE(sechdrs[i].sh_addr);\n\t\tsechdrs[i].sh_offset    = TO_NATIVE(sechdrs[i].sh_offset);\n\t\tsechdrs[i].sh_size      = TO_NATIVE(sechdrs[i].sh_size);\n\t\tsechdrs[i].sh_link      = TO_NATIVE(sechdrs[i].sh_link);\n\t\tsechdrs[i].sh_info      = TO_NATIVE(sechdrs[i].sh_info);\n\t\tsechdrs[i].sh_addralign = TO_NATIVE(sechdrs[i].sh_addralign);\n\t\tsechdrs[i].sh_entsize   = TO_NATIVE(sechdrs[i].sh_entsize);\n\t}\n\t \n\tsecstrings = (void *)hdr + sechdrs[info->secindex_strings].sh_offset;\n\tfor (i = 1; i < info->num_sections; i++) {\n\t\tconst char *secname;\n\t\tint nobits = sechdrs[i].sh_type == SHT_NOBITS;\n\n\t\tif (!nobits && sechdrs[i].sh_offset > info->size) {\n\t\t\tfatal(\"%s is truncated. sechdrs[i].sh_offset=%lu > sizeof(*hrd)=%zu\\n\",\n\t\t\t      filename, (unsigned long)sechdrs[i].sh_offset,\n\t\t\t      sizeof(*hdr));\n\t\t\treturn 0;\n\t\t}\n\t\tsecname = secstrings + sechdrs[i].sh_name;\n\t\tif (strcmp(secname, \".modinfo\") == 0) {\n\t\t\tif (nobits)\n\t\t\t\tfatal(\"%s has NOBITS .modinfo\\n\", filename);\n\t\t\tinfo->modinfo = (void *)hdr + sechdrs[i].sh_offset;\n\t\t\tinfo->modinfo_len = sechdrs[i].sh_size;\n\t\t} else if (!strcmp(secname, \".export_symbol\")) {\n\t\t\tinfo->export_symbol_secndx = i;\n\t\t}\n\n\t\tif (sechdrs[i].sh_type == SHT_SYMTAB) {\n\t\t\tunsigned int sh_link_idx;\n\t\t\tsymtab_idx = i;\n\t\t\tinfo->symtab_start = (void *)hdr +\n\t\t\t    sechdrs[i].sh_offset;\n\t\t\tinfo->symtab_stop  = (void *)hdr +\n\t\t\t    sechdrs[i].sh_offset + sechdrs[i].sh_size;\n\t\t\tsh_link_idx = sechdrs[i].sh_link;\n\t\t\tinfo->strtab       = (void *)hdr +\n\t\t\t    sechdrs[sh_link_idx].sh_offset;\n\t\t}\n\n\t\t \n\t\tif (sechdrs[i].sh_type == SHT_SYMTAB_SHNDX) {\n\t\t\tsymtab_shndx_idx = i;\n\t\t\tinfo->symtab_shndx_start = (void *)hdr +\n\t\t\t    sechdrs[i].sh_offset;\n\t\t\tinfo->symtab_shndx_stop  = (void *)hdr +\n\t\t\t    sechdrs[i].sh_offset + sechdrs[i].sh_size;\n\t\t}\n\t}\n\tif (!info->symtab_start)\n\t\tfatal(\"%s has no symtab?\\n\", filename);\n\n\t \n\tfor (sym = info->symtab_start; sym < info->symtab_stop; sym++) {\n\t\tsym->st_shndx = TO_NATIVE(sym->st_shndx);\n\t\tsym->st_name  = TO_NATIVE(sym->st_name);\n\t\tsym->st_value = TO_NATIVE(sym->st_value);\n\t\tsym->st_size  = TO_NATIVE(sym->st_size);\n\t}\n\n\tif (symtab_shndx_idx != ~0U) {\n\t\tElf32_Word *p;\n\t\tif (symtab_idx != sechdrs[symtab_shndx_idx].sh_link)\n\t\t\tfatal(\"%s: SYMTAB_SHNDX has bad sh_link: %u!=%u\\n\",\n\t\t\t      filename, sechdrs[symtab_shndx_idx].sh_link,\n\t\t\t      symtab_idx);\n\t\t \n\t\tfor (p = info->symtab_shndx_start; p < info->symtab_shndx_stop;\n\t\t     p++)\n\t\t\t*p = TO_NATIVE(*p);\n\t}\n\n\treturn 1;\n}\n\nstatic void parse_elf_finish(struct elf_info *info)\n{\n\trelease_file(info->hdr, info->size);\n}\n\nstatic int ignore_undef_symbol(struct elf_info *info, const char *symname)\n{\n\t \n\tif (strcmp(symname, \"__this_module\") == 0)\n\t\treturn 1;\n\t \n\tif (strcmp(symname, \"_GLOBAL_OFFSET_TABLE_\") == 0)\n\t\treturn 1;\n\tif (info->hdr->e_machine == EM_PPC)\n\t\t \n\t\tif (strstarts(symname, \"_restgpr_\") ||\n\t\t    strstarts(symname, \"_savegpr_\") ||\n\t\t    strstarts(symname, \"_rest32gpr_\") ||\n\t\t    strstarts(symname, \"_save32gpr_\") ||\n\t\t    strstarts(symname, \"_restvr_\") ||\n\t\t    strstarts(symname, \"_savevr_\"))\n\t\t\treturn 1;\n\tif (info->hdr->e_machine == EM_PPC64)\n\t\t \n\t\tif (strstarts(symname, \"_restgpr0_\") ||\n\t\t    strstarts(symname, \"_savegpr0_\") ||\n\t\t    strstarts(symname, \"_restvr_\") ||\n\t\t    strstarts(symname, \"_savevr_\") ||\n\t\t    strcmp(symname, \".TOC.\") == 0)\n\t\t\treturn 1;\n\n\tif (info->hdr->e_machine == EM_S390)\n\t\t \n\t\tif (strstarts(symname, \"__s390_indirect_jump_r\"))\n\t\t\treturn 1;\n\t \n\treturn 0;\n}\n\nstatic void handle_symbol(struct module *mod, struct elf_info *info,\n\t\t\t  const Elf_Sym *sym, const char *symname)\n{\n\tswitch (sym->st_shndx) {\n\tcase SHN_COMMON:\n\t\tif (strstarts(symname, \"__gnu_lto_\")) {\n\t\t\t \n\t\t} else\n\t\t\twarn(\"\\\"%s\\\" [%s] is COMMON symbol\\n\", symname, mod->name);\n\t\tbreak;\n\tcase SHN_UNDEF:\n\t\t \n\t\tif (ELF_ST_BIND(sym->st_info) != STB_GLOBAL &&\n\t\t    ELF_ST_BIND(sym->st_info) != STB_WEAK)\n\t\t\tbreak;\n\t\tif (ignore_undef_symbol(info, symname))\n\t\t\tbreak;\n\t\tif (info->hdr->e_machine == EM_SPARC ||\n\t\t    info->hdr->e_machine == EM_SPARCV9) {\n\t\t\t \n\t\t\tif (ELF_ST_TYPE(sym->st_info) == STT_SPARC_REGISTER)\n\t\t\t\tbreak;\n\t\t\tif (symname[0] == '.') {\n\t\t\t\tchar *munged = NOFAIL(strdup(symname));\n\t\t\t\tmunged[0] = '_';\n\t\t\t\tmunged[1] = toupper(munged[1]);\n\t\t\t\tsymname = munged;\n\t\t\t}\n\t\t}\n\n\t\tsym_add_unresolved(symname, mod,\n\t\t\t\t   ELF_ST_BIND(sym->st_info) == STB_WEAK);\n\t\tbreak;\n\tdefault:\n\t\tif (strcmp(symname, \"init_module\") == 0)\n\t\t\tmod->has_init = true;\n\t\tif (strcmp(symname, \"cleanup_module\") == 0)\n\t\t\tmod->has_cleanup = true;\n\t\tbreak;\n\t}\n}\n\n \nstatic char *next_string(char *string, unsigned long *secsize)\n{\n\t \n\twhile (string[0]) {\n\t\tstring++;\n\t\tif ((*secsize)-- <= 1)\n\t\t\treturn NULL;\n\t}\n\n\t \n\twhile (!string[0]) {\n\t\tstring++;\n\t\tif ((*secsize)-- <= 1)\n\t\t\treturn NULL;\n\t}\n\treturn string;\n}\n\nstatic char *get_next_modinfo(struct elf_info *info, const char *tag,\n\t\t\t      char *prev)\n{\n\tchar *p;\n\tunsigned int taglen = strlen(tag);\n\tchar *modinfo = info->modinfo;\n\tunsigned long size = info->modinfo_len;\n\n\tif (prev) {\n\t\tsize -= prev - modinfo;\n\t\tmodinfo = next_string(prev, &size);\n\t}\n\n\tfor (p = modinfo; p; p = next_string(p, &size)) {\n\t\tif (strncmp(p, tag, taglen) == 0 && p[taglen] == '=')\n\t\t\treturn p + taglen + 1;\n\t}\n\treturn NULL;\n}\n\nstatic char *get_modinfo(struct elf_info *info, const char *tag)\n\n{\n\treturn get_next_modinfo(info, tag, NULL);\n}\n\nstatic const char *sym_name(struct elf_info *elf, Elf_Sym *sym)\n{\n\tif (sym)\n\t\treturn elf->strtab + sym->st_name;\n\telse\n\t\treturn \"(unknown)\";\n}\n\n \nstatic bool match(const char *string, const char *const patterns[])\n{\n\tconst char *pattern;\n\n\twhile ((pattern = *patterns++)) {\n\t\tif (!fnmatch(pattern, string, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n#define PATTERNS(...) \\\n\t({ \\\n\t\tstatic const char *const patterns[] = {__VA_ARGS__, NULL}; \\\n\t\tpatterns; \\\n\t})\n\n \nstatic const char *const section_white_list[] =\n{\n\t\".comment*\",\n\t\".debug*\",\n\t\".zdebug*\",\t\t \n\t\".GCC.command.line\",\t \n\t\".mdebug*\",         \n\t\".pdr\",             \n\t\".stab*\",\n\t\".note*\",\n\t\".got*\",\n\t\".toc*\",\n\t\".xt.prop\",\t\t\t\t  \n\t\".xt.lit\",          \n\t\".arcextmap*\",\t\t\t \n\t\".gnu.linkonce.arcext*\",\t \n\t\".cmem*\",\t\t\t \n\t\".fmt_slot*\",\t\t\t \n\t\".gnu.lto*\",\n\t\".discard.*\",\n\t\".llvm.call-graph-profile\",\t \n\tNULL\n};\n\n \nstatic void check_section(const char *modname, struct elf_info *elf,\n\t\t\t  Elf_Shdr *sechdr)\n{\n\tconst char *sec = sech_name(elf, sechdr);\n\n\tif (sechdr->sh_type == SHT_PROGBITS &&\n\t    !(sechdr->sh_flags & SHF_ALLOC) &&\n\t    !match(sec, section_white_list)) {\n\t\twarn(\"%s (%s): unexpected non-allocatable section.\\n\"\n\t\t     \"Did you forget to use \\\"ax\\\"/\\\"aw\\\" in a .S file?\\n\"\n\t\t     \"Note that for example <linux/init.h> contains\\n\"\n\t\t     \"section definitions for use in .S files.\\n\\n\",\n\t\t     modname, sec);\n\t}\n}\n\n\n\n#define ALL_INIT_DATA_SECTIONS \\\n\t\".init.setup\", \".init.rodata\", \".meminit.rodata\", \\\n\t\".init.data\", \".meminit.data\"\n#define ALL_EXIT_DATA_SECTIONS \\\n\t\".exit.data\", \".memexit.data\"\n\n#define ALL_INIT_TEXT_SECTIONS \\\n\t\".init.text\", \".meminit.text\"\n#define ALL_EXIT_TEXT_SECTIONS \\\n\t\".exit.text\", \".memexit.text\"\n\n#define ALL_PCI_INIT_SECTIONS\t\\\n\t\".pci_fixup_early\", \".pci_fixup_header\", \".pci_fixup_final\", \\\n\t\".pci_fixup_enable\", \".pci_fixup_resume\", \\\n\t\".pci_fixup_resume_early\", \".pci_fixup_suspend\"\n\n#define ALL_XXXINIT_SECTIONS MEM_INIT_SECTIONS\n#define ALL_XXXEXIT_SECTIONS MEM_EXIT_SECTIONS\n\n#define ALL_INIT_SECTIONS INIT_SECTIONS, ALL_XXXINIT_SECTIONS\n#define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS\n\n#define DATA_SECTIONS \".data\", \".data.rel\"\n#define TEXT_SECTIONS \".text\", \".text.*\", \".sched.text\", \\\n\t\t\".kprobes.text\", \".cpuidle.text\", \".noinstr.text\"\n#define OTHER_TEXT_SECTIONS \".ref.text\", \".head.text\", \".spinlock.text\", \\\n\t\t\".fixup\", \".entry.text\", \".exception.text\", \\\n\t\t\".coldtext\", \".softirqentry.text\"\n\n#define INIT_SECTIONS      \".init.*\"\n#define MEM_INIT_SECTIONS  \".meminit.*\"\n\n#define EXIT_SECTIONS      \".exit.*\"\n#define MEM_EXIT_SECTIONS  \".memexit.*\"\n\n#define ALL_TEXT_SECTIONS  ALL_INIT_TEXT_SECTIONS, ALL_EXIT_TEXT_SECTIONS, \\\n\t\tTEXT_SECTIONS, OTHER_TEXT_SECTIONS\n\nenum mismatch {\n\tTEXT_TO_ANY_INIT,\n\tDATA_TO_ANY_INIT,\n\tTEXTDATA_TO_ANY_EXIT,\n\tXXXINIT_TO_SOME_INIT,\n\tXXXEXIT_TO_SOME_EXIT,\n\tANY_INIT_TO_ANY_EXIT,\n\tANY_EXIT_TO_ANY_INIT,\n\tEXTABLE_TO_NON_TEXT,\n};\n\n \nstruct sectioncheck {\n\tconst char *fromsec[20];\n\tconst char *bad_tosec[20];\n\tconst char *good_tosec[20];\n\tenum mismatch mismatch;\n};\n\nstatic const struct sectioncheck sectioncheck[] = {\n \n{\n\t.fromsec = { TEXT_SECTIONS, NULL },\n\t.bad_tosec = { ALL_INIT_SECTIONS, NULL },\n\t.mismatch = TEXT_TO_ANY_INIT,\n},\n{\n\t.fromsec = { DATA_SECTIONS, NULL },\n\t.bad_tosec = { ALL_XXXINIT_SECTIONS, INIT_SECTIONS, NULL },\n\t.mismatch = DATA_TO_ANY_INIT,\n},\n{\n\t.fromsec = { TEXT_SECTIONS, DATA_SECTIONS, NULL },\n\t.bad_tosec = { ALL_EXIT_SECTIONS, NULL },\n\t.mismatch = TEXTDATA_TO_ANY_EXIT,\n},\n \n{\n\t.fromsec = { ALL_XXXINIT_SECTIONS, NULL },\n\t.bad_tosec = { INIT_SECTIONS, NULL },\n\t.mismatch = XXXINIT_TO_SOME_INIT,\n},\n \n{\n\t.fromsec = { ALL_XXXEXIT_SECTIONS, NULL },\n\t.bad_tosec = { EXIT_SECTIONS, NULL },\n\t.mismatch = XXXEXIT_TO_SOME_EXIT,\n},\n \n{\n\t.fromsec = { ALL_INIT_SECTIONS, NULL },\n\t.bad_tosec = { ALL_EXIT_SECTIONS, NULL },\n\t.mismatch = ANY_INIT_TO_ANY_EXIT,\n},\n \n{\n\t.fromsec = { ALL_EXIT_SECTIONS, NULL },\n\t.bad_tosec = { ALL_INIT_SECTIONS, NULL },\n\t.mismatch = ANY_EXIT_TO_ANY_INIT,\n},\n{\n\t.fromsec = { ALL_PCI_INIT_SECTIONS, NULL },\n\t.bad_tosec = { INIT_SECTIONS, NULL },\n\t.mismatch = ANY_INIT_TO_ANY_EXIT,\n},\n{\n\t.fromsec = { \"__ex_table\", NULL },\n\t \n\t.bad_tosec = { \".altinstr_replacement\", NULL },\n\t.good_tosec = {ALL_TEXT_SECTIONS , NULL},\n\t.mismatch = EXTABLE_TO_NON_TEXT,\n}\n};\n\nstatic const struct sectioncheck *section_mismatch(\n\t\tconst char *fromsec, const char *tosec)\n{\n\tint i;\n\n\t \n\tif (*tosec == '\\0')\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(sectioncheck); i++) {\n\t\tconst struct sectioncheck *check = &sectioncheck[i];\n\n\t\tif (match(fromsec, check->fromsec)) {\n\t\t\tif (check->bad_tosec[0] && match(tosec, check->bad_tosec))\n\t\t\t\treturn check;\n\t\t\tif (check->good_tosec[0] && !match(tosec, check->good_tosec))\n\t\t\t\treturn check;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int secref_whitelist(const char *fromsec, const char *fromsym,\n\t\t\t    const char *tosec, const char *tosym)\n{\n\t \n\tif (match(tosec, PATTERNS(ALL_INIT_DATA_SECTIONS)) &&\n\t    match(fromsec, PATTERNS(DATA_SECTIONS)) &&\n\t    strstarts(fromsym, \"__param\"))\n\t\treturn 0;\n\n\t \n\tif (strcmp(tosec, \".init.text\") == 0 &&\n\t    match(fromsec, PATTERNS(DATA_SECTIONS)) &&\n\t    strstarts(fromsym, \"__param_ops_\"))\n\t\treturn 0;\n\n\t \n\tif (match(fromsec, PATTERNS(DATA_SECTIONS)) &&\n\t    match(tosec, PATTERNS(ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS)) &&\n\t    match(fromsym, PATTERNS(\"*_template\", \n\t\t\t\t    \"*_timer\", \n\t\t\t\t    \"*_sht\", \n\t\t\t\t    \"*_ops\",\n\t\t\t\t    \"*_probe\",\n\t\t\t\t    \"*_probe_one\",\n\t\t\t\t    \"*_console\")))\n\t\treturn 0;\n\n\t \n\tif (match(fromsec, PATTERNS(DATA_SECTIONS)) &&\n\t    match(tosec, PATTERNS(ALL_XXXINIT_SECTIONS, ALL_XXXEXIT_SECTIONS)) &&\n\t    match(fromsym, PATTERNS(\"*driver\")))\n\t\treturn 0;\n\n\t \n\tif (!extra_warn &&\n\t    match(fromsec, PATTERNS(DATA_SECTIONS)) &&\n\t    match(tosec, PATTERNS(EXIT_SECTIONS)) &&\n\t    match(fromsym, PATTERNS(\"*driver\")))\n\t\treturn 0;\n\n\t \n\tif (strstarts(fromsec, \".head.text\") &&\n\t    match(tosec, PATTERNS(ALL_INIT_SECTIONS)))\n\t\treturn 0;\n\n\t \n\tif (match(tosym, PATTERNS(\"__init_begin\", \"_sinittext\", \"_einittext\")))\n\t\treturn 0;\n\n\t \n\tif (match(fromsec, PATTERNS(ALL_TEXT_SECTIONS)) &&\n\t    match(tosec, PATTERNS(ALL_INIT_SECTIONS)) &&\n\t    match(fromsym, PATTERNS(\"*.constprop.*\")))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic inline int is_valid_name(struct elf_info *elf, Elf_Sym *sym)\n{\n\tconst char *name = elf->strtab + sym->st_name;\n\n\tif (!name || !strlen(name))\n\t\treturn 0;\n\treturn !is_mapping_symbol(name);\n}\n\n \nstatic Elf_Sym *find_nearest_sym(struct elf_info *elf, Elf_Addr addr,\n\t\t\t\t unsigned int secndx, bool allow_negative,\n\t\t\t\t Elf_Addr min_distance)\n{\n\tElf_Sym *sym;\n\tElf_Sym *near = NULL;\n\tElf_Addr sym_addr, distance;\n\tbool is_arm = (elf->hdr->e_machine == EM_ARM);\n\n\tfor (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {\n\t\tif (get_secindex(elf, sym) != secndx)\n\t\t\tcontinue;\n\t\tif (!is_valid_name(elf, sym))\n\t\t\tcontinue;\n\n\t\tsym_addr = sym->st_value;\n\n\t\t \n\t\tif (is_arm && ELF_ST_TYPE(sym->st_info) == STT_FUNC)\n\t\t\t sym_addr &= ~1;\n\n\t\tif (addr >= sym_addr)\n\t\t\tdistance = addr - sym_addr;\n\t\telse if (allow_negative)\n\t\t\tdistance = sym_addr - addr;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (distance <= min_distance) {\n\t\t\tmin_distance = distance;\n\t\t\tnear = sym;\n\t\t}\n\n\t\tif (min_distance == 0)\n\t\t\tbreak;\n\t}\n\treturn near;\n}\n\nstatic Elf_Sym *find_fromsym(struct elf_info *elf, Elf_Addr addr,\n\t\t\t     unsigned int secndx)\n{\n\treturn find_nearest_sym(elf, addr, secndx, false, ~0);\n}\n\nstatic Elf_Sym *find_tosym(struct elf_info *elf, Elf_Addr addr, Elf_Sym *sym)\n{\n\t \n\tif (is_valid_name(elf, sym))\n\t\treturn sym;\n\n\t \n\treturn find_nearest_sym(elf, addr, get_secindex(elf, sym), true, 20);\n}\n\nstatic bool is_executable_section(struct elf_info *elf, unsigned int secndx)\n{\n\tif (secndx >= elf->num_sections)\n\t\treturn false;\n\n\treturn (elf->sechdrs[secndx].sh_flags & SHF_EXECINSTR) != 0;\n}\n\nstatic void default_mismatch_handler(const char *modname, struct elf_info *elf,\n\t\t\t\t     const struct sectioncheck* const mismatch,\n\t\t\t\t     Elf_Sym *tsym,\n\t\t\t\t     unsigned int fsecndx, const char *fromsec, Elf_Addr faddr,\n\t\t\t\t     const char *tosec, Elf_Addr taddr)\n{\n\tElf_Sym *from;\n\tconst char *tosym;\n\tconst char *fromsym;\n\n\tfrom = find_fromsym(elf, faddr, fsecndx);\n\tfromsym = sym_name(elf, from);\n\n\ttsym = find_tosym(elf, taddr, tsym);\n\ttosym = sym_name(elf, tsym);\n\n\t \n\tif (!secref_whitelist(fromsec, fromsym, tosec, tosym))\n\t\treturn;\n\n\tsec_mismatch_count++;\n\n\twarn(\"%s: section mismatch in reference: %s+0x%x (section: %s) -> %s (section: %s)\\n\",\n\t     modname, fromsym, (unsigned int)(faddr - from->st_value), fromsec, tosym, tosec);\n\n\tif (mismatch->mismatch == EXTABLE_TO_NON_TEXT) {\n\t\tif (match(tosec, mismatch->bad_tosec))\n\t\t\tfatal(\"The relocation at %s+0x%lx references\\n\"\n\t\t\t      \"section \\\"%s\\\" which is black-listed.\\n\"\n\t\t\t      \"Something is seriously wrong and should be fixed.\\n\"\n\t\t\t      \"You might get more information about where this is\\n\"\n\t\t\t      \"coming from by using scripts/check_extable.sh %s\\n\",\n\t\t\t      fromsec, (long)faddr, tosec, modname);\n\t\telse if (is_executable_section(elf, get_secindex(elf, tsym)))\n\t\t\twarn(\"The relocation at %s+0x%lx references\\n\"\n\t\t\t     \"section \\\"%s\\\" which is not in the list of\\n\"\n\t\t\t     \"authorized sections.  If you're adding a new section\\n\"\n\t\t\t     \"and/or if this reference is valid, add \\\"%s\\\" to the\\n\"\n\t\t\t     \"list of authorized sections to jump to on fault.\\n\"\n\t\t\t     \"This can be achieved by adding \\\"%s\\\" to\\n\"\n\t\t\t     \"OTHER_TEXT_SECTIONS in scripts/mod/modpost.c.\\n\",\n\t\t\t     fromsec, (long)faddr, tosec, tosec, tosec);\n\t\telse\n\t\t\terror(\"%s+0x%lx references non-executable section '%s'\\n\",\n\t\t\t      fromsec, (long)faddr, tosec);\n\t}\n}\n\nstatic void check_export_symbol(struct module *mod, struct elf_info *elf,\n\t\t\t\tElf_Addr faddr, const char *secname,\n\t\t\t\tElf_Sym *sym)\n{\n\tstatic const char *prefix = \"__export_symbol_\";\n\tconst char *label_name, *name, *data;\n\tElf_Sym *label;\n\tstruct symbol *s;\n\tbool is_gpl;\n\n\tlabel = find_fromsym(elf, faddr, elf->export_symbol_secndx);\n\tlabel_name = sym_name(elf, label);\n\n\tif (!strstarts(label_name, prefix)) {\n\t\terror(\"%s: .export_symbol section contains strange symbol '%s'\\n\",\n\t\t      mod->name, label_name);\n\t\treturn;\n\t}\n\n\tif (ELF_ST_BIND(sym->st_info) != STB_GLOBAL &&\n\t    ELF_ST_BIND(sym->st_info) != STB_WEAK) {\n\t\terror(\"%s: local symbol '%s' was exported\\n\", mod->name,\n\t\t      label_name + strlen(prefix));\n\t\treturn;\n\t}\n\n\tname = sym_name(elf, sym);\n\tif (strcmp(label_name + strlen(prefix), name)) {\n\t\terror(\"%s: .export_symbol section references '%s', but it does not seem to be an export symbol\\n\",\n\t\t      mod->name, name);\n\t\treturn;\n\t}\n\n\tdata = sym_get_data(elf, label);\t \n\tif (!strcmp(data, \"GPL\")) {\n\t\tis_gpl = true;\n\t} else if (!strcmp(data, \"\")) {\n\t\tis_gpl = false;\n\t} else {\n\t\terror(\"%s: unknown license '%s' was specified for '%s'\\n\",\n\t\t      mod->name, data, name);\n\t\treturn;\n\t}\n\n\tdata += strlen(data) + 1;\t \n\ts = sym_add_exported(name, mod, is_gpl, data);\n\n\t \n\ts->is_func = (ELF_ST_TYPE(sym->st_info) == STT_FUNC);\n\n\t \n\tif (elf->hdr->e_ident[EI_CLASS] == ELFCLASS64 &&\n\t    elf->hdr->e_machine == EM_PARISC &&\n\t    ELF_ST_TYPE(sym->st_info) == STT_LOPROC)\n\t\ts->is_func = true;\n\n\tif (match(secname, PATTERNS(INIT_SECTIONS)))\n\t\twarn(\"%s: %s: EXPORT_SYMBOL used for init symbol. Remove __init or EXPORT_SYMBOL.\\n\",\n\t\t     mod->name, name);\n\telse if (match(secname, PATTERNS(EXIT_SECTIONS)))\n\t\twarn(\"%s: %s: EXPORT_SYMBOL used for exit symbol. Remove __exit or EXPORT_SYMBOL.\\n\",\n\t\t     mod->name, name);\n}\n\nstatic void check_section_mismatch(struct module *mod, struct elf_info *elf,\n\t\t\t\t   Elf_Sym *sym,\n\t\t\t\t   unsigned int fsecndx, const char *fromsec,\n\t\t\t\t   Elf_Addr faddr, Elf_Addr taddr)\n{\n\tconst char *tosec = sec_name(elf, get_secindex(elf, sym));\n\tconst struct sectioncheck *mismatch;\n\n\tif (module_enabled && elf->export_symbol_secndx == fsecndx) {\n\t\tcheck_export_symbol(mod, elf, faddr, tosec, sym);\n\t\treturn;\n\t}\n\n\tmismatch = section_mismatch(fromsec, tosec);\n\tif (!mismatch)\n\t\treturn;\n\n\tdefault_mismatch_handler(mod->name, elf, mismatch, sym,\n\t\t\t\t fsecndx, fromsec, faddr,\n\t\t\t\t tosec, taddr);\n}\n\nstatic Elf_Addr addend_386_rel(uint32_t *location, unsigned int r_type)\n{\n\tswitch (r_type) {\n\tcase R_386_32:\n\t\treturn TO_NATIVE(*location);\n\tcase R_386_PC32:\n\t\treturn TO_NATIVE(*location) + 4;\n\t}\n\n\treturn (Elf_Addr)(-1);\n}\n\n#ifndef R_ARM_CALL\n#define R_ARM_CALL\t28\n#endif\n#ifndef R_ARM_JUMP24\n#define R_ARM_JUMP24\t29\n#endif\n\n#ifndef\tR_ARM_THM_CALL\n#define\tR_ARM_THM_CALL\t\t10\n#endif\n#ifndef\tR_ARM_THM_JUMP24\n#define\tR_ARM_THM_JUMP24\t30\n#endif\n\n#ifndef R_ARM_MOVW_ABS_NC\n#define R_ARM_MOVW_ABS_NC\t43\n#endif\n\n#ifndef R_ARM_MOVT_ABS\n#define R_ARM_MOVT_ABS\t\t44\n#endif\n\n#ifndef R_ARM_THM_MOVW_ABS_NC\n#define R_ARM_THM_MOVW_ABS_NC\t47\n#endif\n\n#ifndef R_ARM_THM_MOVT_ABS\n#define R_ARM_THM_MOVT_ABS\t48\n#endif\n\n#ifndef\tR_ARM_THM_JUMP19\n#define\tR_ARM_THM_JUMP19\t51\n#endif\n\nstatic int32_t sign_extend32(int32_t value, int index)\n{\n\tuint8_t shift = 31 - index;\n\n\treturn (int32_t)(value << shift) >> shift;\n}\n\nstatic Elf_Addr addend_arm_rel(void *loc, Elf_Sym *sym, unsigned int r_type)\n{\n\tuint32_t inst, upper, lower, sign, j1, j2;\n\tint32_t offset;\n\n\tswitch (r_type) {\n\tcase R_ARM_ABS32:\n\tcase R_ARM_REL32:\n\t\tinst = TO_NATIVE(*(uint32_t *)loc);\n\t\treturn inst + sym->st_value;\n\tcase R_ARM_MOVW_ABS_NC:\n\tcase R_ARM_MOVT_ABS:\n\t\tinst = TO_NATIVE(*(uint32_t *)loc);\n\t\toffset = sign_extend32(((inst & 0xf0000) >> 4) | (inst & 0xfff),\n\t\t\t\t       15);\n\t\treturn offset + sym->st_value;\n\tcase R_ARM_PC24:\n\tcase R_ARM_CALL:\n\tcase R_ARM_JUMP24:\n\t\tinst = TO_NATIVE(*(uint32_t *)loc);\n\t\toffset = sign_extend32((inst & 0x00ffffff) << 2, 25);\n\t\treturn offset + sym->st_value + 8;\n\tcase R_ARM_THM_MOVW_ABS_NC:\n\tcase R_ARM_THM_MOVT_ABS:\n\t\tupper = TO_NATIVE(*(uint16_t *)loc);\n\t\tlower = TO_NATIVE(*((uint16_t *)loc + 1));\n\t\toffset = sign_extend32(((upper & 0x000f) << 12) |\n\t\t\t\t       ((upper & 0x0400) << 1) |\n\t\t\t\t       ((lower & 0x7000) >> 4) |\n\t\t\t\t       (lower & 0x00ff),\n\t\t\t\t       15);\n\t\treturn offset + sym->st_value;\n\tcase R_ARM_THM_JUMP19:\n\t\t \n\t\tupper = TO_NATIVE(*(uint16_t *)loc);\n\t\tlower = TO_NATIVE(*((uint16_t *)loc + 1));\n\n\t\tsign = (upper >> 10) & 1;\n\t\tj1 = (lower >> 13) & 1;\n\t\tj2 = (lower >> 11) & 1;\n\t\toffset = sign_extend32((sign << 20) | (j2 << 19) | (j1 << 18) |\n\t\t\t\t       ((upper & 0x03f) << 12) |\n\t\t\t\t       ((lower & 0x07ff) << 1),\n\t\t\t\t       20);\n\t\treturn offset + sym->st_value + 4;\n\tcase R_ARM_THM_CALL:\n\tcase R_ARM_THM_JUMP24:\n\t\t \n\t\tupper = TO_NATIVE(*(uint16_t *)loc);\n\t\tlower = TO_NATIVE(*((uint16_t *)loc + 1));\n\n\t\tsign = (upper >> 10) & 1;\n\t\tj1 = (lower >> 13) & 1;\n\t\tj2 = (lower >> 11) & 1;\n\t\toffset = sign_extend32((sign << 24) |\n\t\t\t\t       ((~(j1 ^ sign) & 1) << 23) |\n\t\t\t\t       ((~(j2 ^ sign) & 1) << 22) |\n\t\t\t\t       ((upper & 0x03ff) << 12) |\n\t\t\t\t       ((lower & 0x07ff) << 1),\n\t\t\t\t       24);\n\t\treturn offset + sym->st_value + 4;\n\t}\n\n\treturn (Elf_Addr)(-1);\n}\n\nstatic Elf_Addr addend_mips_rel(uint32_t *location, unsigned int r_type)\n{\n\tuint32_t inst;\n\n\tinst = TO_NATIVE(*location);\n\tswitch (r_type) {\n\tcase R_MIPS_LO16:\n\t\treturn inst & 0xffff;\n\tcase R_MIPS_26:\n\t\treturn (inst & 0x03ffffff) << 2;\n\tcase R_MIPS_32:\n\t\treturn inst;\n\t}\n\treturn (Elf_Addr)(-1);\n}\n\n#ifndef EM_RISCV\n#define EM_RISCV\t\t243\n#endif\n\n#ifndef R_RISCV_SUB32\n#define R_RISCV_SUB32\t\t39\n#endif\n\n#ifndef EM_LOONGARCH\n#define EM_LOONGARCH\t\t258\n#endif\n\n#ifndef R_LARCH_SUB32\n#define R_LARCH_SUB32\t\t55\n#endif\n\nstatic void get_rel_type_and_sym(struct elf_info *elf, uint64_t r_info,\n\t\t\t\t unsigned int *r_type, unsigned int *r_sym)\n{\n\ttypedef struct {\n\t\tElf64_Word    r_sym;\t \n\t\tunsigned char r_ssym;\t \n\t\tunsigned char r_type3;\t \n\t\tunsigned char r_type2;\t \n\t\tunsigned char r_type;\t \n\t} Elf64_Mips_R_Info;\n\n\tbool is_64bit = (elf->hdr->e_ident[EI_CLASS] == ELFCLASS64);\n\n\tif (elf->hdr->e_machine == EM_MIPS && is_64bit) {\n\t\tElf64_Mips_R_Info *mips64_r_info = (void *)&r_info;\n\n\t\t*r_type = mips64_r_info->r_type;\n\t\t*r_sym = TO_NATIVE(mips64_r_info->r_sym);\n\t\treturn;\n\t}\n\n\tif (is_64bit) {\n\t\tElf64_Xword r_info64 = r_info;\n\n\t\tr_info = TO_NATIVE(r_info64);\n\t} else {\n\t\tElf32_Word r_info32 = r_info;\n\n\t\tr_info = TO_NATIVE(r_info32);\n\t}\n\n\t*r_type = ELF_R_TYPE(r_info);\n\t*r_sym = ELF_R_SYM(r_info);\n}\n\nstatic void section_rela(struct module *mod, struct elf_info *elf,\n\t\t\t Elf_Shdr *sechdr)\n{\n\tElf_Rela *rela;\n\tunsigned int fsecndx = sechdr->sh_info;\n\tconst char *fromsec = sec_name(elf, fsecndx);\n\tElf_Rela *start = (void *)elf->hdr + sechdr->sh_offset;\n\tElf_Rela *stop  = (void *)start + sechdr->sh_size;\n\n\t \n\tif (match(fromsec, section_white_list))\n\t\treturn;\n\n\tfor (rela = start; rela < stop; rela++) {\n\t\tElf_Sym *tsym;\n\t\tElf_Addr taddr, r_offset;\n\t\tunsigned int r_type, r_sym;\n\n\t\tr_offset = TO_NATIVE(rela->r_offset);\n\t\tget_rel_type_and_sym(elf, rela->r_info, &r_type, &r_sym);\n\n\t\ttsym = elf->symtab_start + r_sym;\n\t\ttaddr = tsym->st_value + TO_NATIVE(rela->r_addend);\n\n\t\tswitch (elf->hdr->e_machine) {\n\t\tcase EM_RISCV:\n\t\t\tif (!strcmp(\"__ex_table\", fromsec) &&\n\t\t\t    r_type == R_RISCV_SUB32)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase EM_LOONGARCH:\n\t\t\tif (!strcmp(\"__ex_table\", fromsec) &&\n\t\t\t    r_type == R_LARCH_SUB32)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tcheck_section_mismatch(mod, elf, tsym,\n\t\t\t\t       fsecndx, fromsec, r_offset, taddr);\n\t}\n}\n\nstatic void section_rel(struct module *mod, struct elf_info *elf,\n\t\t\tElf_Shdr *sechdr)\n{\n\tElf_Rel *rel;\n\tunsigned int fsecndx = sechdr->sh_info;\n\tconst char *fromsec = sec_name(elf, fsecndx);\n\tElf_Rel *start = (void *)elf->hdr + sechdr->sh_offset;\n\tElf_Rel *stop  = (void *)start + sechdr->sh_size;\n\n\t \n\tif (match(fromsec, section_white_list))\n\t\treturn;\n\n\tfor (rel = start; rel < stop; rel++) {\n\t\tElf_Sym *tsym;\n\t\tElf_Addr taddr = 0, r_offset;\n\t\tunsigned int r_type, r_sym;\n\t\tvoid *loc;\n\n\t\tr_offset = TO_NATIVE(rel->r_offset);\n\t\tget_rel_type_and_sym(elf, rel->r_info, &r_type, &r_sym);\n\n\t\tloc = sym_get_data_by_offset(elf, fsecndx, r_offset);\n\t\ttsym = elf->symtab_start + r_sym;\n\n\t\tswitch (elf->hdr->e_machine) {\n\t\tcase EM_386:\n\t\t\ttaddr = addend_386_rel(loc, r_type);\n\t\t\tbreak;\n\t\tcase EM_ARM:\n\t\t\ttaddr = addend_arm_rel(loc, tsym, r_type);\n\t\t\tbreak;\n\t\tcase EM_MIPS:\n\t\t\ttaddr = addend_mips_rel(loc, r_type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Please add code to calculate addend for this architecture\\n\");\n\t\t}\n\n\t\tcheck_section_mismatch(mod, elf, tsym,\n\t\t\t\t       fsecndx, fromsec, r_offset, taddr);\n\t}\n}\n\n \nstatic void check_sec_ref(struct module *mod, struct elf_info *elf)\n{\n\tint i;\n\tElf_Shdr *sechdrs = elf->sechdrs;\n\n\t \n\tfor (i = 0; i < elf->num_sections; i++) {\n\t\tcheck_section(mod->name, elf, &elf->sechdrs[i]);\n\t\t \n\t\tif (sechdrs[i].sh_type == SHT_RELA)\n\t\t\tsection_rela(mod, elf, &elf->sechdrs[i]);\n\t\telse if (sechdrs[i].sh_type == SHT_REL)\n\t\t\tsection_rel(mod, elf, &elf->sechdrs[i]);\n\t}\n}\n\nstatic char *remove_dot(char *s)\n{\n\tsize_t n = strcspn(s, \".\");\n\n\tif (n && s[n]) {\n\t\tsize_t m = strspn(s + n + 1, \"0123456789\");\n\t\tif (m && (s[n + m + 1] == '.' || s[n + m + 1] == 0))\n\t\t\ts[n] = 0;\n\t}\n\treturn s;\n}\n\n \nstatic void extract_crcs_for_object(const char *object, struct module *mod)\n{\n\tchar cmd_file[PATH_MAX];\n\tchar *buf, *p;\n\tconst char *base;\n\tint dirlen, ret;\n\n\tbase = strrchr(object, '/');\n\tif (base) {\n\t\tbase++;\n\t\tdirlen = base - object;\n\t} else {\n\t\tdirlen = 0;\n\t\tbase = object;\n\t}\n\n\tret = snprintf(cmd_file, sizeof(cmd_file), \"%.*s.%s.cmd\",\n\t\t       dirlen, object, base);\n\tif (ret >= sizeof(cmd_file)) {\n\t\terror(\"%s: too long path was truncated\\n\", cmd_file);\n\t\treturn;\n\t}\n\n\tbuf = read_text_file(cmd_file);\n\tp = buf;\n\n\twhile ((p = strstr(p, \"\\n#SYMVER \"))) {\n\t\tchar *name;\n\t\tsize_t namelen;\n\t\tunsigned int crc;\n\t\tstruct symbol *sym;\n\n\t\tname = p + strlen(\"\\n#SYMVER \");\n\n\t\tp = strchr(name, ' ');\n\t\tif (!p)\n\t\t\tbreak;\n\n\t\tnamelen = p - name;\n\t\tp++;\n\n\t\tif (!isdigit(*p))\n\t\t\tcontinue;\t \n\n\t\tcrc = strtoul(p, &p, 0);\n\t\tif (*p != '\\n')\n\t\t\tcontinue;\t \n\n\t\tname[namelen] = '\\0';\n\n\t\t \n\t\tsym = sym_find_with_module(name, mod);\n\t\tif (sym)\n\t\t\tsym_set_crc(sym, crc);\n\t}\n\n\tfree(buf);\n}\n\n \nstatic void mod_set_crcs(struct module *mod)\n{\n\tchar objlist[PATH_MAX];\n\tchar *buf, *p, *obj;\n\tint ret;\n\n\tif (mod->is_vmlinux) {\n\t\tstrcpy(objlist, \".vmlinux.objs\");\n\t} else {\n\t\t \n\t\tret = snprintf(objlist, sizeof(objlist), \"%s.mod\", mod->name);\n\t\tif (ret >= sizeof(objlist)) {\n\t\t\terror(\"%s: too long path was truncated\\n\", objlist);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbuf = read_text_file(objlist);\n\tp = buf;\n\n\twhile ((obj = strsep(&p, \"\\n\")) && obj[0])\n\t\textract_crcs_for_object(obj, mod);\n\n\tfree(buf);\n}\n\nstatic void read_symbols(const char *modname)\n{\n\tconst char *symname;\n\tchar *version;\n\tchar *license;\n\tchar *namespace;\n\tstruct module *mod;\n\tstruct elf_info info = { };\n\tElf_Sym *sym;\n\n\tif (!parse_elf(&info, modname))\n\t\treturn;\n\n\tif (!strends(modname, \".o\")) {\n\t\terror(\"%s: filename must be suffixed with .o\\n\", modname);\n\t\treturn;\n\t}\n\n\t \n\tmod = new_module(modname, strlen(modname) - strlen(\".o\"));\n\n\tif (!mod->is_vmlinux) {\n\t\tlicense = get_modinfo(&info, \"license\");\n\t\tif (!license)\n\t\t\terror(\"missing MODULE_LICENSE() in %s\\n\", modname);\n\t\twhile (license) {\n\t\t\tif (!license_is_gpl_compatible(license)) {\n\t\t\t\tmod->is_gpl_compatible = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlicense = get_next_modinfo(&info, \"license\", license);\n\t\t}\n\n\t\tnamespace = get_modinfo(&info, \"import_ns\");\n\t\twhile (namespace) {\n\t\t\tadd_namespace(&mod->imported_namespaces, namespace);\n\t\t\tnamespace = get_next_modinfo(&info, \"import_ns\",\n\t\t\t\t\t\t     namespace);\n\t\t}\n\t}\n\n\tif (extra_warn && !get_modinfo(&info, \"description\"))\n\t\twarn(\"missing MODULE_DESCRIPTION() in %s\\n\", modname);\n\tfor (sym = info.symtab_start; sym < info.symtab_stop; sym++) {\n\t\tsymname = remove_dot(info.strtab + sym->st_name);\n\n\t\thandle_symbol(mod, &info, sym, symname);\n\t\thandle_moddevtable(mod, &info, sym, symname);\n\t}\n\n\tcheck_sec_ref(mod, &info);\n\n\tif (!mod->is_vmlinux) {\n\t\tversion = get_modinfo(&info, \"version\");\n\t\tif (version || all_versions)\n\t\t\tget_src_version(mod->name, mod->srcversion,\n\t\t\t\t\tsizeof(mod->srcversion) - 1);\n\t}\n\n\tparse_elf_finish(&info);\n\n\tif (modversions) {\n\t\t \n\t\tsym_add_unresolved(\"module_layout\", mod, false);\n\n\t\tmod_set_crcs(mod);\n\t}\n}\n\nstatic void read_symbols_from_files(const char *filename)\n{\n\tFILE *in = stdin;\n\tchar fname[PATH_MAX];\n\n\tin = fopen(filename, \"r\");\n\tif (!in)\n\t\tfatal(\"Can't open filenames file %s: %m\", filename);\n\n\twhile (fgets(fname, PATH_MAX, in) != NULL) {\n\t\tif (strends(fname, \"\\n\"))\n\t\t\tfname[strlen(fname)-1] = '\\0';\n\t\tread_symbols(fname);\n\t}\n\n\tfclose(in);\n}\n\n#define SZ 500\n\n \n\nvoid __attribute__((format(printf, 2, 3))) buf_printf(struct buffer *buf,\n\t\t\t\t\t\t      const char *fmt, ...)\n{\n\tchar tmp[SZ];\n\tint len;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tlen = vsnprintf(tmp, SZ, fmt, ap);\n\tbuf_write(buf, tmp, len);\n\tva_end(ap);\n}\n\nvoid buf_write(struct buffer *buf, const char *s, int len)\n{\n\tif (buf->size - buf->pos < len) {\n\t\tbuf->size += len + SZ;\n\t\tbuf->p = NOFAIL(realloc(buf->p, buf->size));\n\t}\n\tstrncpy(buf->p + buf->pos, s, len);\n\tbuf->pos += len;\n}\n\nstatic void check_exports(struct module *mod)\n{\n\tstruct symbol *s, *exp;\n\n\tlist_for_each_entry(s, &mod->unresolved_symbols, list) {\n\t\tconst char *basename;\n\t\texp = find_symbol(s->name);\n\t\tif (!exp) {\n\t\t\tif (!s->weak && nr_unresolved++ < MAX_UNRESOLVED_REPORTS)\n\t\t\t\tmodpost_log(warn_unresolved ? LOG_WARN : LOG_ERROR,\n\t\t\t\t\t    \"\\\"%s\\\" [%s.ko] undefined!\\n\",\n\t\t\t\t\t    s->name, mod->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (exp->module == mod) {\n\t\t\terror(\"\\\"%s\\\" [%s.ko] was exported without definition\\n\",\n\t\t\t      s->name, mod->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\texp->used = true;\n\t\ts->module = exp->module;\n\t\ts->crc_valid = exp->crc_valid;\n\t\ts->crc = exp->crc;\n\n\t\tbasename = strrchr(mod->name, '/');\n\t\tif (basename)\n\t\t\tbasename++;\n\t\telse\n\t\t\tbasename = mod->name;\n\n\t\tif (!contains_namespace(&mod->imported_namespaces, exp->namespace)) {\n\t\t\tmodpost_log(allow_missing_ns_imports ? LOG_WARN : LOG_ERROR,\n\t\t\t\t    \"module %s uses symbol %s from namespace %s, but does not import it.\\n\",\n\t\t\t\t    basename, exp->name, exp->namespace);\n\t\t\tadd_namespace(&mod->missing_namespaces, exp->namespace);\n\t\t}\n\n\t\tif (!mod->is_gpl_compatible && exp->is_gpl_only)\n\t\t\terror(\"GPL-incompatible module %s.ko uses GPL-only symbol '%s'\\n\",\n\t\t\t      basename, exp->name);\n\t}\n}\n\nstatic void handle_white_list_exports(const char *white_list)\n{\n\tchar *buf, *p, *name;\n\n\tbuf = read_text_file(white_list);\n\tp = buf;\n\n\twhile ((name = strsep(&p, \"\\n\"))) {\n\t\tstruct symbol *sym = find_symbol(name);\n\n\t\tif (sym)\n\t\t\tsym->used = true;\n\t}\n\n\tfree(buf);\n}\n\nstatic void check_modname_len(struct module *mod)\n{\n\tconst char *mod_name;\n\n\tmod_name = strrchr(mod->name, '/');\n\tif (mod_name == NULL)\n\t\tmod_name = mod->name;\n\telse\n\t\tmod_name++;\n\tif (strlen(mod_name) >= MODULE_NAME_LEN)\n\t\terror(\"module name is too long [%s.ko]\\n\", mod->name);\n}\n\n \nstatic void add_header(struct buffer *b, struct module *mod)\n{\n\tbuf_printf(b, \"#include <linux/module.h>\\n\");\n\t \n\tbuf_printf(b, \"#define INCLUDE_VERMAGIC\\n\");\n\tbuf_printf(b, \"#include <linux/build-salt.h>\\n\");\n\tbuf_printf(b, \"#include <linux/elfnote-lto.h>\\n\");\n\tbuf_printf(b, \"#include <linux/export-internal.h>\\n\");\n\tbuf_printf(b, \"#include <linux/vermagic.h>\\n\");\n\tbuf_printf(b, \"#include <linux/compiler.h>\\n\");\n\tbuf_printf(b, \"\\n\");\n\tbuf_printf(b, \"#ifdef CONFIG_UNWINDER_ORC\\n\");\n\tbuf_printf(b, \"#include <asm/orc_header.h>\\n\");\n\tbuf_printf(b, \"ORC_HEADER;\\n\");\n\tbuf_printf(b, \"#endif\\n\");\n\tbuf_printf(b, \"\\n\");\n\tbuf_printf(b, \"BUILD_SALT;\\n\");\n\tbuf_printf(b, \"BUILD_LTO_INFO;\\n\");\n\tbuf_printf(b, \"\\n\");\n\tbuf_printf(b, \"MODULE_INFO(vermagic, VERMAGIC_STRING);\\n\");\n\tbuf_printf(b, \"MODULE_INFO(name, KBUILD_MODNAME);\\n\");\n\tbuf_printf(b, \"\\n\");\n\tbuf_printf(b, \"__visible struct module __this_module\\n\");\n\tbuf_printf(b, \"__section(\\\".gnu.linkonce.this_module\\\") = {\\n\");\n\tbuf_printf(b, \"\\t.name = KBUILD_MODNAME,\\n\");\n\tif (mod->has_init)\n\t\tbuf_printf(b, \"\\t.init = init_module,\\n\");\n\tif (mod->has_cleanup)\n\t\tbuf_printf(b, \"#ifdef CONFIG_MODULE_UNLOAD\\n\"\n\t\t\t      \"\\t.exit = cleanup_module,\\n\"\n\t\t\t      \"#endif\\n\");\n\tbuf_printf(b, \"\\t.arch = MODULE_ARCH_INIT,\\n\");\n\tbuf_printf(b, \"};\\n\");\n\n\tif (!external_module)\n\t\tbuf_printf(b, \"\\nMODULE_INFO(intree, \\\"Y\\\");\\n\");\n\n\tbuf_printf(b,\n\t\t   \"\\n\"\n\t\t   \"#ifdef CONFIG_RETPOLINE\\n\"\n\t\t   \"MODULE_INFO(retpoline, \\\"Y\\\");\\n\"\n\t\t   \"#endif\\n\");\n\n\tif (strstarts(mod->name, \"drivers/staging\"))\n\t\tbuf_printf(b, \"\\nMODULE_INFO(staging, \\\"Y\\\");\\n\");\n\n\tif (strstarts(mod->name, \"tools/testing\"))\n\t\tbuf_printf(b, \"\\nMODULE_INFO(test, \\\"Y\\\");\\n\");\n}\n\nstatic void add_exported_symbols(struct buffer *buf, struct module *mod)\n{\n\tstruct symbol *sym;\n\n\t \n\tbuf_printf(buf, \"\\n\");\n\tlist_for_each_entry(sym, &mod->exported_symbols, list) {\n\t\tif (trim_unused_exports && !sym->used)\n\t\t\tcontinue;\n\n\t\tbuf_printf(buf, \"KSYMTAB_%s(%s, \\\"%s\\\", \\\"%s\\\");\\n\",\n\t\t\t   sym->is_func ? \"FUNC\" : \"DATA\", sym->name,\n\t\t\t   sym->is_gpl_only ? \"_gpl\" : \"\", sym->namespace);\n\t}\n\n\tif (!modversions)\n\t\treturn;\n\n\t \n\tbuf_printf(buf, \"\\n\");\n\tlist_for_each_entry(sym, &mod->exported_symbols, list) {\n\t\tif (trim_unused_exports && !sym->used)\n\t\t\tcontinue;\n\n\t\tif (!sym->crc_valid)\n\t\t\twarn(\"EXPORT symbol \\\"%s\\\" [%s%s] version generation failed, symbol will not be versioned.\\n\"\n\t\t\t     \"Is \\\"%s\\\" prototyped in <asm/asm-prototypes.h>?\\n\",\n\t\t\t     sym->name, mod->name, mod->is_vmlinux ? \"\" : \".ko\",\n\t\t\t     sym->name);\n\n\t\tbuf_printf(buf, \"SYMBOL_CRC(%s, 0x%08x, \\\"%s\\\");\\n\",\n\t\t\t   sym->name, sym->crc, sym->is_gpl_only ? \"_gpl\" : \"\");\n\t}\n}\n\n \nstatic void add_versions(struct buffer *b, struct module *mod)\n{\n\tstruct symbol *s;\n\n\tif (!modversions)\n\t\treturn;\n\n\tbuf_printf(b, \"\\n\");\n\tbuf_printf(b, \"static const struct modversion_info ____versions[]\\n\");\n\tbuf_printf(b, \"__used __section(\\\"__versions\\\") = {\\n\");\n\n\tlist_for_each_entry(s, &mod->unresolved_symbols, list) {\n\t\tif (!s->module)\n\t\t\tcontinue;\n\t\tif (!s->crc_valid) {\n\t\t\twarn(\"\\\"%s\\\" [%s.ko] has no CRC!\\n\",\n\t\t\t\ts->name, mod->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strlen(s->name) >= MODULE_NAME_LEN) {\n\t\t\terror(\"too long symbol \\\"%s\\\" [%s.ko]\\n\",\n\t\t\t      s->name, mod->name);\n\t\t\tbreak;\n\t\t}\n\t\tbuf_printf(b, \"\\t{ %#8x, \\\"%s\\\" },\\n\",\n\t\t\t   s->crc, s->name);\n\t}\n\n\tbuf_printf(b, \"};\\n\");\n}\n\nstatic void add_depends(struct buffer *b, struct module *mod)\n{\n\tstruct symbol *s;\n\tint first = 1;\n\n\t \n\tlist_for_each_entry(s, &mod->unresolved_symbols, list) {\n\t\tif (s->module)\n\t\t\ts->module->seen = s->module->is_vmlinux;\n\t}\n\n\tbuf_printf(b, \"\\n\");\n\tbuf_printf(b, \"MODULE_INFO(depends, \\\"\");\n\tlist_for_each_entry(s, &mod->unresolved_symbols, list) {\n\t\tconst char *p;\n\t\tif (!s->module)\n\t\t\tcontinue;\n\n\t\tif (s->module->seen)\n\t\t\tcontinue;\n\n\t\ts->module->seen = true;\n\t\tp = strrchr(s->module->name, '/');\n\t\tif (p)\n\t\t\tp++;\n\t\telse\n\t\t\tp = s->module->name;\n\t\tbuf_printf(b, \"%s%s\", first ? \"\" : \",\", p);\n\t\tfirst = 0;\n\t}\n\tbuf_printf(b, \"\\\");\\n\");\n}\n\nstatic void add_srcversion(struct buffer *b, struct module *mod)\n{\n\tif (mod->srcversion[0]) {\n\t\tbuf_printf(b, \"\\n\");\n\t\tbuf_printf(b, \"MODULE_INFO(srcversion, \\\"%s\\\");\\n\",\n\t\t\t   mod->srcversion);\n\t}\n}\n\nstatic void write_buf(struct buffer *b, const char *fname)\n{\n\tFILE *file;\n\n\tif (error_occurred)\n\t\treturn;\n\n\tfile = fopen(fname, \"w\");\n\tif (!file) {\n\t\tperror(fname);\n\t\texit(1);\n\t}\n\tif (fwrite(b->p, 1, b->pos, file) != b->pos) {\n\t\tperror(fname);\n\t\texit(1);\n\t}\n\tif (fclose(file) != 0) {\n\t\tperror(fname);\n\t\texit(1);\n\t}\n}\n\nstatic void write_if_changed(struct buffer *b, const char *fname)\n{\n\tchar *tmp;\n\tFILE *file;\n\tstruct stat st;\n\n\tfile = fopen(fname, \"r\");\n\tif (!file)\n\t\tgoto write;\n\n\tif (fstat(fileno(file), &st) < 0)\n\t\tgoto close_write;\n\n\tif (st.st_size != b->pos)\n\t\tgoto close_write;\n\n\ttmp = NOFAIL(malloc(b->pos));\n\tif (fread(tmp, 1, b->pos, file) != b->pos)\n\t\tgoto free_write;\n\n\tif (memcmp(tmp, b->p, b->pos) != 0)\n\t\tgoto free_write;\n\n\tfree(tmp);\n\tfclose(file);\n\treturn;\n\n free_write:\n\tfree(tmp);\n close_write:\n\tfclose(file);\n write:\n\twrite_buf(b, fname);\n}\n\nstatic void write_vmlinux_export_c_file(struct module *mod)\n{\n\tstruct buffer buf = { };\n\n\tbuf_printf(&buf,\n\t\t   \"#include <linux/export-internal.h>\\n\");\n\n\tadd_exported_symbols(&buf, mod);\n\twrite_if_changed(&buf, \".vmlinux.export.c\");\n\tfree(buf.p);\n}\n\n \nstatic void write_mod_c_file(struct module *mod)\n{\n\tstruct buffer buf = { };\n\tchar fname[PATH_MAX];\n\tint ret;\n\n\tadd_header(&buf, mod);\n\tadd_exported_symbols(&buf, mod);\n\tadd_versions(&buf, mod);\n\tadd_depends(&buf, mod);\n\tadd_moddevtable(&buf, mod);\n\tadd_srcversion(&buf, mod);\n\n\tret = snprintf(fname, sizeof(fname), \"%s.mod.c\", mod->name);\n\tif (ret >= sizeof(fname)) {\n\t\terror(\"%s: too long path was truncated\\n\", fname);\n\t\tgoto free;\n\t}\n\n\twrite_if_changed(&buf, fname);\n\nfree:\n\tfree(buf.p);\n}\n\n \nstatic void read_dump(const char *fname)\n{\n\tchar *buf, *pos, *line;\n\n\tbuf = read_text_file(fname);\n\tif (!buf)\n\t\t \n\t\treturn;\n\n\tpos = buf;\n\n\twhile ((line = get_line(&pos))) {\n\t\tchar *symname, *namespace, *modname, *d, *export;\n\t\tunsigned int crc;\n\t\tstruct module *mod;\n\t\tstruct symbol *s;\n\t\tbool gpl_only;\n\n\t\tif (!(symname = strchr(line, '\\t')))\n\t\t\tgoto fail;\n\t\t*symname++ = '\\0';\n\t\tif (!(modname = strchr(symname, '\\t')))\n\t\t\tgoto fail;\n\t\t*modname++ = '\\0';\n\t\tif (!(export = strchr(modname, '\\t')))\n\t\t\tgoto fail;\n\t\t*export++ = '\\0';\n\t\tif (!(namespace = strchr(export, '\\t')))\n\t\t\tgoto fail;\n\t\t*namespace++ = '\\0';\n\n\t\tcrc = strtoul(line, &d, 16);\n\t\tif (*symname == '\\0' || *modname == '\\0' || *d != '\\0')\n\t\t\tgoto fail;\n\n\t\tif (!strcmp(export, \"EXPORT_SYMBOL_GPL\")) {\n\t\t\tgpl_only = true;\n\t\t} else if (!strcmp(export, \"EXPORT_SYMBOL\")) {\n\t\t\tgpl_only = false;\n\t\t} else {\n\t\t\terror(\"%s: unknown license %s. skip\", symname, export);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmod = find_module(modname);\n\t\tif (!mod) {\n\t\t\tmod = new_module(modname, strlen(modname));\n\t\t\tmod->from_dump = true;\n\t\t}\n\t\ts = sym_add_exported(symname, mod, gpl_only, namespace);\n\t\tsym_set_crc(s, crc);\n\t}\n\tfree(buf);\n\treturn;\nfail:\n\tfree(buf);\n\tfatal(\"parse error in symbol dump file\\n\");\n}\n\nstatic void write_dump(const char *fname)\n{\n\tstruct buffer buf = { };\n\tstruct module *mod;\n\tstruct symbol *sym;\n\n\tlist_for_each_entry(mod, &modules, list) {\n\t\tif (mod->from_dump)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(sym, &mod->exported_symbols, list) {\n\t\t\tif (trim_unused_exports && !sym->used)\n\t\t\t\tcontinue;\n\n\t\t\tbuf_printf(&buf, \"0x%08x\\t%s\\t%s\\tEXPORT_SYMBOL%s\\t%s\\n\",\n\t\t\t\t   sym->crc, sym->name, mod->name,\n\t\t\t\t   sym->is_gpl_only ? \"_GPL\" : \"\",\n\t\t\t\t   sym->namespace);\n\t\t}\n\t}\n\twrite_buf(&buf, fname);\n\tfree(buf.p);\n}\n\nstatic void write_namespace_deps_files(const char *fname)\n{\n\tstruct module *mod;\n\tstruct namespace_list *ns;\n\tstruct buffer ns_deps_buf = {};\n\n\tlist_for_each_entry(mod, &modules, list) {\n\n\t\tif (mod->from_dump || list_empty(&mod->missing_namespaces))\n\t\t\tcontinue;\n\n\t\tbuf_printf(&ns_deps_buf, \"%s.ko:\", mod->name);\n\n\t\tlist_for_each_entry(ns, &mod->missing_namespaces, list)\n\t\t\tbuf_printf(&ns_deps_buf, \" %s\", ns->namespace);\n\n\t\tbuf_printf(&ns_deps_buf, \"\\n\");\n\t}\n\n\twrite_if_changed(&ns_deps_buf, fname);\n\tfree(ns_deps_buf.p);\n}\n\nstruct dump_list {\n\tstruct list_head list;\n\tconst char *file;\n};\n\nint main(int argc, char **argv)\n{\n\tstruct module *mod;\n\tchar *missing_namespace_deps = NULL;\n\tchar *unused_exports_white_list = NULL;\n\tchar *dump_write = NULL, *files_source = NULL;\n\tint opt;\n\tLIST_HEAD(dump_lists);\n\tstruct dump_list *dl, *dl2;\n\n\twhile ((opt = getopt(argc, argv, \"ei:MmnT:to:au:WwENd:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'e':\n\t\t\texternal_module = true;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tdl = NOFAIL(malloc(sizeof(*dl)));\n\t\t\tdl->file = optarg;\n\t\t\tlist_add_tail(&dl->list, &dump_lists);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tmodule_enabled = true;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tmodversions = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tignore_missing_files = true;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdump_write = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tall_versions = true;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfiles_source = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttrim_unused_exports = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tunused_exports_white_list = optarg;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\textra_warn = true;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twarn_unresolved = true;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tsec_mismatch_warn_only = false;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tallow_missing_ns_imports = true;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tmissing_namespace_deps = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(dl, dl2, &dump_lists, list) {\n\t\tread_dump(dl->file);\n\t\tlist_del(&dl->list);\n\t\tfree(dl);\n\t}\n\n\twhile (optind < argc)\n\t\tread_symbols(argv[optind++]);\n\n\tif (files_source)\n\t\tread_symbols_from_files(files_source);\n\n\tlist_for_each_entry(mod, &modules, list) {\n\t\tif (mod->from_dump || mod->is_vmlinux)\n\t\t\tcontinue;\n\n\t\tcheck_modname_len(mod);\n\t\tcheck_exports(mod);\n\t}\n\n\tif (unused_exports_white_list)\n\t\thandle_white_list_exports(unused_exports_white_list);\n\n\tlist_for_each_entry(mod, &modules, list) {\n\t\tif (mod->from_dump)\n\t\t\tcontinue;\n\n\t\tif (mod->is_vmlinux)\n\t\t\twrite_vmlinux_export_c_file(mod);\n\t\telse\n\t\t\twrite_mod_c_file(mod);\n\t}\n\n\tif (missing_namespace_deps)\n\t\twrite_namespace_deps_files(missing_namespace_deps);\n\n\tif (dump_write)\n\t\twrite_dump(dump_write);\n\tif (sec_mismatch_count && !sec_mismatch_warn_only)\n\t\terror(\"Section mismatches detected.\\n\"\n\t\t      \"Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\\n\");\n\n\tif (nr_unresolved > MAX_UNRESOLVED_REPORTS)\n\t\twarn(\"suppressed %u unresolved symbol warnings because there were too many)\\n\",\n\t\t     nr_unresolved - MAX_UNRESOLVED_REPORTS);\n\n\treturn error_occurred ? 1 : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}