{
  "module_name": "file2alias.c",
  "hash_id": "499ef5852ccaac805df030c1dc2f65888cdb69511786e69bc01943eefa1f8b5d",
  "original_prompt": "Ingested from linux-6.6.14/scripts/mod/file2alias.c",
  "human_readable_source": " \n\n#include \"modpost.h\"\n#include \"devicetable-offsets.h\"\n\n \n#if KERNEL_ELFCLASS == ELFCLASS32\ntypedef Elf32_Addr\tkernel_ulong_t;\n#define BITS_PER_LONG 32\n#else\ntypedef Elf64_Addr\tkernel_ulong_t;\n#define BITS_PER_LONG 64\n#endif\n#ifdef __sun__\n#include <inttypes.h>\n#else\n#include <stdint.h>\n#endif\n\n#include <ctype.h>\n#include <stdbool.h>\n\ntypedef uint32_t\t__u32;\ntypedef uint16_t\t__u16;\ntypedef unsigned char\t__u8;\n\n \ntypedef struct {\n\t__u8 b[16];\n} guid_t;\n\ntypedef struct {\n\t__u8 b[16];\n} uuid_t;\n\n#define\tUUID_STRING_LEN\t\t36\n\n \ntypedef struct {\n\t__u8 b[16];\n} uuid_le;\n\n \n#include \"../../include/linux/mod_devicetable.h\"\n\n \nstruct devtable {\n\tconst char *device_id;  \n\tunsigned long id_size;\n\tint (*do_entry)(const char *filename, void *symval, char *alias);\n};\n\n \n#define ALIAS_SIZE 500\n\n \n#define DEF_FIELD(m, devid, f) \\\n\ttypeof(((struct devid *)0)->f) f = TO_NATIVE(*(typeof(f) *)((m) + OFF_##devid##_##f))\n\n \n#define DEF_FIELD_ADDR_VAR(m, devid, f, v) \\\n\ttypeof(((struct devid *)0)->f) *v = ((m) + OFF_##devid##_##f)\n\n \n#define DEF_FIELD_ADDR(m, devid, f) \\\n\tDEF_FIELD_ADDR_VAR(m, devid, f, f)\n\n#define ADD(str, sep, cond, field)                              \\\ndo {                                                            \\\n        strcat(str, sep);                                       \\\n        if (cond)                                               \\\n                sprintf(str + strlen(str),                      \\\n                        sizeof(field) == 1 ? \"%02X\" :           \\\n                        sizeof(field) == 2 ? \"%04X\" :           \\\n                        sizeof(field) == 4 ? \"%08X\" : \"\",       \\\n                        field);                                 \\\n        else                                                    \\\n                sprintf(str + strlen(str), \"*\");                \\\n} while(0)\n\n \nstatic inline void add_wildcard(char *str)\n{\n\tint len = strlen(str);\n\n\tif (str[len - 1] != '*')\n\t\tstrcat(str + len, \"*\");\n}\n\nstatic inline void add_uuid(char *str, uuid_le uuid)\n{\n\tint len = strlen(str);\n\n\tsprintf(str + len, \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t\tuuid.b[3], uuid.b[2], uuid.b[1], uuid.b[0],\n\t\tuuid.b[5], uuid.b[4], uuid.b[7], uuid.b[6],\n\t\tuuid.b[8], uuid.b[9], uuid.b[10], uuid.b[11],\n\t\tuuid.b[12], uuid.b[13], uuid.b[14], uuid.b[15]);\n}\n\nstatic inline void add_guid(char *str, guid_t guid)\n{\n\tint len = strlen(str);\n\n\tsprintf(str + len, \"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n\t\tguid.b[3], guid.b[2], guid.b[1], guid.b[0],\n\t\tguid.b[5], guid.b[4], guid.b[7], guid.b[6],\n\t\tguid.b[8], guid.b[9], guid.b[10], guid.b[11],\n\t\tguid.b[12], guid.b[13], guid.b[14], guid.b[15]);\n}\n\n \nstatic void device_id_check(const char *modname, const char *device_id,\n\t\t\t    unsigned long size, unsigned long id_size,\n\t\t\t    void *symval)\n{\n\tint i;\n\n\tif (size % id_size || size < id_size) {\n\t\tfatal(\"%s: sizeof(struct %s_device_id)=%lu is not a modulo of the size of section __mod_%s__<identifier>_device_table=%lu.\\n\"\n\t\t      \"Fix definition of struct %s_device_id in mod_devicetable.h\\n\",\n\t\t      modname, device_id, id_size, device_id, size, device_id);\n\t}\n\t \n\tfor (i = 0; i < id_size; i++ ) {\n\t\tif (*(uint8_t*)(symval+size-id_size+i)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: struct %s_device_id is %lu bytes.  The last of %lu is:\\n\",\n\t\t\t\tmodname, device_id, id_size, size / id_size);\n\t\t\tfor (i = 0; i < id_size; i++ )\n\t\t\t\tfprintf(stderr,\"0x%02x \",\n\t\t\t\t\t*(uint8_t*)(symval+size-id_size+i) );\n\t\t\tfprintf(stderr,\"\\n\");\n\t\t\tfatal(\"%s: struct %s_device_id is not terminated with a NULL entry!\\n\",\n\t\t\t      modname, device_id);\n\t\t}\n\t}\n}\n\n \n \nstatic void do_usb_entry(void *symval,\n\t\t\t unsigned int bcdDevice_initial, int bcdDevice_initial_digits,\n\t\t\t unsigned char range_lo, unsigned char range_hi,\n\t\t\t unsigned char max, struct module *mod)\n{\n\tchar alias[500];\n\tDEF_FIELD(symval, usb_device_id, match_flags);\n\tDEF_FIELD(symval, usb_device_id, idVendor);\n\tDEF_FIELD(symval, usb_device_id, idProduct);\n\tDEF_FIELD(symval, usb_device_id, bcdDevice_lo);\n\tDEF_FIELD(symval, usb_device_id, bDeviceClass);\n\tDEF_FIELD(symval, usb_device_id, bDeviceSubClass);\n\tDEF_FIELD(symval, usb_device_id, bDeviceProtocol);\n\tDEF_FIELD(symval, usb_device_id, bInterfaceClass);\n\tDEF_FIELD(symval, usb_device_id, bInterfaceSubClass);\n\tDEF_FIELD(symval, usb_device_id, bInterfaceProtocol);\n\tDEF_FIELD(symval, usb_device_id, bInterfaceNumber);\n\n\tstrcpy(alias, \"usb:\");\n\tADD(alias, \"v\", match_flags&USB_DEVICE_ID_MATCH_VENDOR,\n\t    idVendor);\n\tADD(alias, \"p\", match_flags&USB_DEVICE_ID_MATCH_PRODUCT,\n\t    idProduct);\n\n\tstrcat(alias, \"d\");\n\tif (bcdDevice_initial_digits)\n\t\tsprintf(alias + strlen(alias), \"%0*X\",\n\t\t\tbcdDevice_initial_digits, bcdDevice_initial);\n\tif (range_lo == range_hi)\n\t\tsprintf(alias + strlen(alias), \"%X\", range_lo);\n\telse if (range_lo > 0 || range_hi < max) {\n\t\tif (range_lo > 0x9 || range_hi < 0xA)\n\t\t\tsprintf(alias + strlen(alias),\n\t\t\t\t\"[%X-%X]\",\n\t\t\t\trange_lo,\n\t\t\t\trange_hi);\n\t\telse {\n\t\t\tsprintf(alias + strlen(alias),\n\t\t\t\trange_lo < 0x9 ? \"[%X-9\" : \"[%X\",\n\t\t\t\trange_lo);\n\t\t\tsprintf(alias + strlen(alias),\n\t\t\t\trange_hi > 0xA ? \"A-%X]\" : \"%X]\",\n\t\t\t\trange_hi);\n\t\t}\n\t}\n\tif (bcdDevice_initial_digits < (sizeof(bcdDevice_lo) * 2 - 1))\n\t\tstrcat(alias, \"*\");\n\n\tADD(alias, \"dc\", match_flags&USB_DEVICE_ID_MATCH_DEV_CLASS,\n\t    bDeviceClass);\n\tADD(alias, \"dsc\", match_flags&USB_DEVICE_ID_MATCH_DEV_SUBCLASS,\n\t    bDeviceSubClass);\n\tADD(alias, \"dp\", match_flags&USB_DEVICE_ID_MATCH_DEV_PROTOCOL,\n\t    bDeviceProtocol);\n\tADD(alias, \"ic\", match_flags&USB_DEVICE_ID_MATCH_INT_CLASS,\n\t    bInterfaceClass);\n\tADD(alias, \"isc\", match_flags&USB_DEVICE_ID_MATCH_INT_SUBCLASS,\n\t    bInterfaceSubClass);\n\tADD(alias, \"ip\", match_flags&USB_DEVICE_ID_MATCH_INT_PROTOCOL,\n\t    bInterfaceProtocol);\n\tADD(alias, \"in\", match_flags&USB_DEVICE_ID_MATCH_INT_NUMBER,\n\t    bInterfaceNumber);\n\n\tadd_wildcard(alias);\n\tbuf_printf(&mod->dev_table_buf,\n\t\t   \"MODULE_ALIAS(\\\"%s\\\");\\n\", alias);\n}\n\n \n \nstatic unsigned int incbcd(unsigned int *bcd,\n\t\t\t   int inc,\n\t\t\t   unsigned char max,\n\t\t\t   size_t chars)\n{\n\tunsigned int init = *bcd, i, j;\n\tunsigned long long c, dec = 0;\n\n\t \n\tif (max > 0x9) {\n\t\t*bcd += inc;\n\t\treturn init;\n\t}\n\n\t \n\tfor (i=0 ; i < chars ; i++) {\n\t\tc = (*bcd >> (i << 2)) & 0xf;\n\t\tc = c > 9 ? 9 : c;  \n\t\tfor (j=0 ; j < i ; j++)\n\t\t\tc = c * 10;\n\t\tdec += c;\n\t}\n\n\t \n\tdec += inc;\n\t*bcd  = 0;\n\n\t \n\tfor (i=0 ; i < chars ; i++) {\n\t\tfor (c=1,j=0 ; j < i ; j++)\n\t\t\tc = c * 10;\n\t\tc = (dec / c) % 10;\n\t\t*bcd += c << (i << 2);\n\t}\n\treturn init;\n}\n\nstatic void do_usb_entry_multi(void *symval, struct module *mod)\n{\n\tunsigned int devlo, devhi;\n\tunsigned char chi, clo, max;\n\tint ndigits;\n\n\tDEF_FIELD(symval, usb_device_id, match_flags);\n\tDEF_FIELD(symval, usb_device_id, idVendor);\n\tDEF_FIELD(symval, usb_device_id, idProduct);\n\tDEF_FIELD(symval, usb_device_id, bcdDevice_lo);\n\tDEF_FIELD(symval, usb_device_id, bcdDevice_hi);\n\tDEF_FIELD(symval, usb_device_id, bDeviceClass);\n\tDEF_FIELD(symval, usb_device_id, bInterfaceClass);\n\n\tdevlo = match_flags & USB_DEVICE_ID_MATCH_DEV_LO ?\n\t\tbcdDevice_lo : 0x0U;\n\tdevhi = match_flags & USB_DEVICE_ID_MATCH_DEV_HI ?\n\t\tbcdDevice_hi : ~0x0U;\n\n\t \n\tmax = 0x9;  \n\tfor (ndigits = 0 ; ndigits < sizeof(bcdDevice_lo) * 2 ; ndigits++) {\n\t\tclo = (devlo >> (ndigits << 2)) & 0xf;\n\t\tchi = ((devhi > 0x9999 ? 0x9999 : devhi) >> (ndigits << 2)) & 0xf;\n\t\tif (clo > max || chi > max) {\n\t\t\tmax = 0xf;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!(idVendor | idProduct | bDeviceClass | bInterfaceClass))\n\t\treturn;\n\n\t \n\tfor (ndigits = sizeof(bcdDevice_lo) * 2 - 1; devlo <= devhi; ndigits--) {\n\t\tclo = devlo & 0xf;\n\t\tchi = devhi & 0xf;\n\t\tif (chi > max)\t \n\t\t\tchi = max;\n\t\tdevlo >>= 4;\n\t\tdevhi >>= 4;\n\n\t\tif (devlo == devhi || !ndigits) {\n\t\t\tdo_usb_entry(symval, devlo, ndigits, clo, chi, max, mod);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (clo > 0x0)\n\t\t\tdo_usb_entry(symval,\n\t\t\t\t     incbcd(&devlo, 1, max,\n\t\t\t\t\t    sizeof(bcdDevice_lo) * 2),\n\t\t\t\t     ndigits, clo, max, max, mod);\n\n\t\tif (chi < max)\n\t\t\tdo_usb_entry(symval,\n\t\t\t\t     incbcd(&devhi, -1, max,\n\t\t\t\t\t    sizeof(bcdDevice_lo) * 2),\n\t\t\t\t     ndigits, 0x0, chi, max, mod);\n\t}\n}\n\nstatic void do_usb_table(void *symval, unsigned long size,\n\t\t\t struct module *mod)\n{\n\tunsigned int i;\n\tconst unsigned long id_size = SIZE_usb_device_id;\n\n\tdevice_id_check(mod->name, \"usb\", size, id_size, symval);\n\n\t \n\tsize -= id_size;\n\n\tfor (i = 0; i < size; i += id_size)\n\t\tdo_usb_entry_multi(symval + i, mod);\n}\n\nstatic void do_of_entry_multi(void *symval, struct module *mod)\n{\n\tchar alias[500];\n\tint len;\n\tchar *tmp;\n\n\tDEF_FIELD_ADDR(symval, of_device_id, name);\n\tDEF_FIELD_ADDR(symval, of_device_id, type);\n\tDEF_FIELD_ADDR(symval, of_device_id, compatible);\n\n\tlen = sprintf(alias, \"of:N%sT%s\", (*name)[0] ? *name : \"*\",\n\t\t      (*type)[0] ? *type : \"*\");\n\n\tif ((*compatible)[0])\n\t\tsprintf(&alias[len], \"%sC%s\", (*type)[0] ? \"*\" : \"\",\n\t\t\t*compatible);\n\n\t \n\tfor (tmp = alias; tmp && *tmp; tmp++)\n\t\tif (isspace(*tmp))\n\t\t\t*tmp = '_';\n\n\tbuf_printf(&mod->dev_table_buf, \"MODULE_ALIAS(\\\"%s\\\");\\n\", alias);\n\tstrcat(alias, \"C\");\n\tadd_wildcard(alias);\n\tbuf_printf(&mod->dev_table_buf, \"MODULE_ALIAS(\\\"%s\\\");\\n\", alias);\n}\n\nstatic void do_of_table(void *symval, unsigned long size,\n\t\t\tstruct module *mod)\n{\n\tunsigned int i;\n\tconst unsigned long id_size = SIZE_of_device_id;\n\n\tdevice_id_check(mod->name, \"of\", size, id_size, symval);\n\n\t \n\tsize -= id_size;\n\n\tfor (i = 0; i < size; i += id_size)\n\t\tdo_of_entry_multi(symval + i, mod);\n}\n\n \nstatic int do_hid_entry(const char *filename,\n\t\t\t     void *symval, char *alias)\n{\n\tDEF_FIELD(symval, hid_device_id, bus);\n\tDEF_FIELD(symval, hid_device_id, group);\n\tDEF_FIELD(symval, hid_device_id, vendor);\n\tDEF_FIELD(symval, hid_device_id, product);\n\n\tsprintf(alias, \"hid:\");\n\tADD(alias, \"b\", bus != HID_BUS_ANY, bus);\n\tADD(alias, \"g\", group != HID_GROUP_ANY, group);\n\tADD(alias, \"v\", vendor != HID_ANY_ID, vendor);\n\tADD(alias, \"p\", product != HID_ANY_ID, product);\n\n\treturn 1;\n}\n\n \nstatic int do_ieee1394_entry(const char *filename,\n\t\t\t     void *symval, char *alias)\n{\n\tDEF_FIELD(symval, ieee1394_device_id, match_flags);\n\tDEF_FIELD(symval, ieee1394_device_id, vendor_id);\n\tDEF_FIELD(symval, ieee1394_device_id, model_id);\n\tDEF_FIELD(symval, ieee1394_device_id, specifier_id);\n\tDEF_FIELD(symval, ieee1394_device_id, version);\n\n\tstrcpy(alias, \"ieee1394:\");\n\tADD(alias, \"ven\", match_flags & IEEE1394_MATCH_VENDOR_ID,\n\t    vendor_id);\n\tADD(alias, \"mo\", match_flags & IEEE1394_MATCH_MODEL_ID,\n\t    model_id);\n\tADD(alias, \"sp\", match_flags & IEEE1394_MATCH_SPECIFIER_ID,\n\t    specifier_id);\n\tADD(alias, \"ver\", match_flags & IEEE1394_MATCH_VERSION,\n\t    version);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_pci_entry(const char *filename,\n\t\t\tvoid *symval, char *alias)\n{\n\t \n\tunsigned char baseclass, subclass, interface,\n\t\tbaseclass_mask, subclass_mask, interface_mask;\n\n\tDEF_FIELD(symval, pci_device_id, vendor);\n\tDEF_FIELD(symval, pci_device_id, device);\n\tDEF_FIELD(symval, pci_device_id, subvendor);\n\tDEF_FIELD(symval, pci_device_id, subdevice);\n\tDEF_FIELD(symval, pci_device_id, class);\n\tDEF_FIELD(symval, pci_device_id, class_mask);\n\tDEF_FIELD(symval, pci_device_id, override_only);\n\n\tswitch (override_only) {\n\tcase 0:\n\t\tstrcpy(alias, \"pci:\");\n\t\tbreak;\n\tcase PCI_ID_F_VFIO_DRIVER_OVERRIDE:\n\t\tstrcpy(alias, \"vfio_pci:\");\n\t\tbreak;\n\tdefault:\n\t\twarn(\"Unknown PCI driver_override alias %08X\\n\",\n\t\t     override_only);\n\t\treturn 0;\n\t}\n\n\tADD(alias, \"v\", vendor != PCI_ANY_ID, vendor);\n\tADD(alias, \"d\", device != PCI_ANY_ID, device);\n\tADD(alias, \"sv\", subvendor != PCI_ANY_ID, subvendor);\n\tADD(alias, \"sd\", subdevice != PCI_ANY_ID, subdevice);\n\n\tbaseclass = (class) >> 16;\n\tbaseclass_mask = (class_mask) >> 16;\n\tsubclass = (class) >> 8;\n\tsubclass_mask = (class_mask) >> 8;\n\tinterface = class;\n\tinterface_mask = class_mask;\n\n\tif ((baseclass_mask != 0 && baseclass_mask != 0xFF)\n\t    || (subclass_mask != 0 && subclass_mask != 0xFF)\n\t    || (interface_mask != 0 && interface_mask != 0xFF)) {\n\t\twarn(\"Can't handle masks in %s:%04X\\n\",\n\t\t     filename, class_mask);\n\t\treturn 0;\n\t}\n\n\tADD(alias, \"bc\", baseclass_mask == 0xFF, baseclass);\n\tADD(alias, \"sc\", subclass_mask == 0xFF, subclass);\n\tADD(alias, \"i\", interface_mask == 0xFF, interface);\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_ccw_entry(const char *filename,\n\t\t\tvoid *symval, char *alias)\n{\n\tDEF_FIELD(symval, ccw_device_id, match_flags);\n\tDEF_FIELD(symval, ccw_device_id, cu_type);\n\tDEF_FIELD(symval, ccw_device_id, cu_model);\n\tDEF_FIELD(symval, ccw_device_id, dev_type);\n\tDEF_FIELD(symval, ccw_device_id, dev_model);\n\n\tstrcpy(alias, \"ccw:\");\n\tADD(alias, \"t\", match_flags&CCW_DEVICE_ID_MATCH_CU_TYPE,\n\t    cu_type);\n\tADD(alias, \"m\", match_flags&CCW_DEVICE_ID_MATCH_CU_MODEL,\n\t    cu_model);\n\tADD(alias, \"dt\", match_flags&CCW_DEVICE_ID_MATCH_DEVICE_TYPE,\n\t    dev_type);\n\tADD(alias, \"dm\", match_flags&CCW_DEVICE_ID_MATCH_DEVICE_MODEL,\n\t    dev_model);\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_ap_entry(const char *filename,\n\t\t       void *symval, char *alias)\n{\n\tDEF_FIELD(symval, ap_device_id, dev_type);\n\n\tsprintf(alias, \"ap:t%02X*\", dev_type);\n\treturn 1;\n}\n\n \nstatic int do_css_entry(const char *filename,\n\t\t\tvoid *symval, char *alias)\n{\n\tDEF_FIELD(symval, css_device_id, type);\n\n\tsprintf(alias, \"css:t%01X\", type);\n\treturn 1;\n}\n\n \nstatic int do_serio_entry(const char *filename,\n\t\t\t  void *symval, char *alias)\n{\n\tDEF_FIELD(symval, serio_device_id, type);\n\tDEF_FIELD(symval, serio_device_id, proto);\n\tDEF_FIELD(symval, serio_device_id, id);\n\tDEF_FIELD(symval, serio_device_id, extra);\n\n\tstrcpy(alias, \"serio:\");\n\tADD(alias, \"ty\", type != SERIO_ANY, type);\n\tADD(alias, \"pr\", proto != SERIO_ANY, proto);\n\tADD(alias, \"id\", id != SERIO_ANY, id);\n\tADD(alias, \"ex\", extra != SERIO_ANY, extra);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_acpi_entry(const char *filename,\n\t\t\tvoid *symval, char *alias)\n{\n\tDEF_FIELD_ADDR(symval, acpi_device_id, id);\n\tDEF_FIELD_ADDR(symval, acpi_device_id, cls);\n\tDEF_FIELD_ADDR(symval, acpi_device_id, cls_msk);\n\n\tif (id && strlen((const char *)*id))\n\t\tsprintf(alias, \"acpi*:%s:*\", *id);\n\telse if (cls) {\n\t\tint i, byte_shift, cnt = 0;\n\t\tunsigned int msk;\n\n\t\tsprintf(&alias[cnt], \"acpi*:\");\n\t\tcnt = 6;\n\t\tfor (i = 1; i <= 3; i++) {\n\t\t\tbyte_shift = 8 * (3-i);\n\t\t\tmsk = (*cls_msk >> byte_shift) & 0xFF;\n\t\t\tif (msk)\n\t\t\t\tsprintf(&alias[cnt], \"%02x\",\n\t\t\t\t\t(*cls >> byte_shift) & 0xFF);\n\t\t\telse\n\t\t\t\tsprintf(&alias[cnt], \"??\");\n\t\t\tcnt += 2;\n\t\t}\n\t\tsprintf(&alias[cnt], \":*\");\n\t}\n\treturn 1;\n}\n\n \nstatic void do_pnp_device_entry(void *symval, unsigned long size,\n\t\t\t\tstruct module *mod)\n{\n\tconst unsigned long id_size = SIZE_pnp_device_id;\n\tconst unsigned int count = (size / id_size)-1;\n\tunsigned int i;\n\n\tdevice_id_check(mod->name, \"pnp\", size, id_size, symval);\n\n\tfor (i = 0; i < count; i++) {\n\t\tDEF_FIELD_ADDR(symval + i*id_size, pnp_device_id, id);\n\t\tchar acpi_id[sizeof(*id)];\n\t\tint j;\n\n\t\tbuf_printf(&mod->dev_table_buf,\n\t\t\t   \"MODULE_ALIAS(\\\"pnp:d%s*\\\");\\n\", *id);\n\n\t\t \n\t\tfor (j = 0; j < sizeof(acpi_id); j++)\n\t\t\tacpi_id[j] = toupper((*id)[j]);\n\t\tbuf_printf(&mod->dev_table_buf,\n\t\t\t   \"MODULE_ALIAS(\\\"acpi*:%s:*\\\");\\n\", acpi_id);\n\t}\n}\n\n \nstatic void do_pnp_card_entries(void *symval, unsigned long size,\n\t\t\t\tstruct module *mod)\n{\n\tconst unsigned long id_size = SIZE_pnp_card_device_id;\n\tconst unsigned int count = (size / id_size)-1;\n\tunsigned int i;\n\n\tdevice_id_check(mod->name, \"pnp\", size, id_size, symval);\n\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned int j;\n\t\tDEF_FIELD_ADDR(symval + i * id_size, pnp_card_device_id, devs);\n\n\t\tfor (j = 0; j < PNP_MAX_DEVICES; j++) {\n\t\t\tconst char *id = (char *)(*devs)[j].id;\n\t\t\tint i2, j2;\n\t\t\tint dup = 0;\n\n\t\t\tif (!id[0])\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tfor (i2 = 0; i2 < i && !dup; i2++) {\n\t\t\t\tDEF_FIELD_ADDR_VAR(symval + i2 * id_size,\n\t\t\t\t\t\t   pnp_card_device_id,\n\t\t\t\t\t\t   devs, devs_dup);\n\n\t\t\t\tfor (j2 = 0; j2 < PNP_MAX_DEVICES; j2++) {\n\t\t\t\t\tconst char *id2 =\n\t\t\t\t\t\t(char *)(*devs_dup)[j2].id;\n\n\t\t\t\t\tif (!id2[0])\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (!strcmp(id, id2)) {\n\t\t\t\t\t\tdup = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!dup) {\n\t\t\t\tchar acpi_id[PNP_ID_LEN];\n\t\t\t\tint k;\n\n\t\t\t\tbuf_printf(&mod->dev_table_buf,\n\t\t\t\t\t   \"MODULE_ALIAS(\\\"pnp:d%s*\\\");\\n\", id);\n\n\t\t\t\t \n\t\t\t\tfor (k = 0; k < sizeof(acpi_id); k++)\n\t\t\t\t\tacpi_id[k] = toupper(id[k]);\n\t\t\t\tbuf_printf(&mod->dev_table_buf,\n\t\t\t\t\t   \"MODULE_ALIAS(\\\"acpi*:%s:*\\\");\\n\", acpi_id);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int do_pcmcia_entry(const char *filename,\n\t\t\t   void *symval, char *alias)\n{\n\tunsigned int i;\n\tDEF_FIELD(symval, pcmcia_device_id, match_flags);\n\tDEF_FIELD(symval, pcmcia_device_id, manf_id);\n\tDEF_FIELD(symval, pcmcia_device_id, card_id);\n\tDEF_FIELD(symval, pcmcia_device_id, func_id);\n\tDEF_FIELD(symval, pcmcia_device_id, function);\n\tDEF_FIELD(symval, pcmcia_device_id, device_no);\n\tDEF_FIELD_ADDR(symval, pcmcia_device_id, prod_id_hash);\n\n\tfor (i=0; i<4; i++) {\n\t\t(*prod_id_hash)[i] = TO_NATIVE((*prod_id_hash)[i]);\n\t}\n\n\tstrcpy(alias, \"pcmcia:\");\n\tADD(alias, \"m\", match_flags & PCMCIA_DEV_ID_MATCH_MANF_ID,\n\t    manf_id);\n\tADD(alias, \"c\", match_flags & PCMCIA_DEV_ID_MATCH_CARD_ID,\n\t    card_id);\n\tADD(alias, \"f\", match_flags & PCMCIA_DEV_ID_MATCH_FUNC_ID,\n\t    func_id);\n\tADD(alias, \"fn\", match_flags & PCMCIA_DEV_ID_MATCH_FUNCTION,\n\t    function);\n\tADD(alias, \"pfn\", match_flags & PCMCIA_DEV_ID_MATCH_DEVICE_NO,\n\t    device_no);\n\tADD(alias, \"pa\", match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID1, (*prod_id_hash)[0]);\n\tADD(alias, \"pb\", match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID2, (*prod_id_hash)[1]);\n\tADD(alias, \"pc\", match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID3, (*prod_id_hash)[2]);\n\tADD(alias, \"pd\", match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID4, (*prod_id_hash)[3]);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\nstatic int do_vio_entry(const char *filename, void *symval,\n\t\tchar *alias)\n{\n\tchar *tmp;\n\tDEF_FIELD_ADDR(symval, vio_device_id, type);\n\tDEF_FIELD_ADDR(symval, vio_device_id, compat);\n\n\tsprintf(alias, \"vio:T%sS%s\", (*type)[0] ? *type : \"*\",\n\t\t\t(*compat)[0] ? *compat : \"*\");\n\n\t \n\tfor (tmp = alias; tmp && *tmp; tmp++)\n\t\tif (isspace (*tmp))\n\t\t\t*tmp = '_';\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\nstatic void do_input(char *alias,\n\t\t     kernel_ulong_t *arr, unsigned int min, unsigned int max)\n{\n\tunsigned int i;\n\n\tfor (i = min / BITS_PER_LONG; i < max / BITS_PER_LONG + 1; i++)\n\t\tarr[i] = TO_NATIVE(arr[i]);\n\tfor (i = min; i < max; i++)\n\t\tif (arr[i / BITS_PER_LONG] & (1L << (i%BITS_PER_LONG)))\n\t\t\tsprintf(alias + strlen(alias), \"%X,*\", i);\n}\n\n \nstatic int do_input_entry(const char *filename, void *symval,\n\t\t\t  char *alias)\n{\n\tDEF_FIELD(symval, input_device_id, flags);\n\tDEF_FIELD(symval, input_device_id, bustype);\n\tDEF_FIELD(symval, input_device_id, vendor);\n\tDEF_FIELD(symval, input_device_id, product);\n\tDEF_FIELD(symval, input_device_id, version);\n\tDEF_FIELD_ADDR(symval, input_device_id, evbit);\n\tDEF_FIELD_ADDR(symval, input_device_id, keybit);\n\tDEF_FIELD_ADDR(symval, input_device_id, relbit);\n\tDEF_FIELD_ADDR(symval, input_device_id, absbit);\n\tDEF_FIELD_ADDR(symval, input_device_id, mscbit);\n\tDEF_FIELD_ADDR(symval, input_device_id, ledbit);\n\tDEF_FIELD_ADDR(symval, input_device_id, sndbit);\n\tDEF_FIELD_ADDR(symval, input_device_id, ffbit);\n\tDEF_FIELD_ADDR(symval, input_device_id, swbit);\n\n\tsprintf(alias, \"input:\");\n\n\tADD(alias, \"b\", flags & INPUT_DEVICE_ID_MATCH_BUS, bustype);\n\tADD(alias, \"v\", flags & INPUT_DEVICE_ID_MATCH_VENDOR, vendor);\n\tADD(alias, \"p\", flags & INPUT_DEVICE_ID_MATCH_PRODUCT, product);\n\tADD(alias, \"e\", flags & INPUT_DEVICE_ID_MATCH_VERSION, version);\n\n\tsprintf(alias + strlen(alias), \"-e*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_EVBIT)\n\t\tdo_input(alias, *evbit, 0, INPUT_DEVICE_ID_EV_MAX);\n\tsprintf(alias + strlen(alias), \"k*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_KEYBIT)\n\t\tdo_input(alias, *keybit,\n\t\t\t INPUT_DEVICE_ID_KEY_MIN_INTERESTING,\n\t\t\t INPUT_DEVICE_ID_KEY_MAX);\n\tsprintf(alias + strlen(alias), \"r*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_RELBIT)\n\t\tdo_input(alias, *relbit, 0, INPUT_DEVICE_ID_REL_MAX);\n\tsprintf(alias + strlen(alias), \"a*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_ABSBIT)\n\t\tdo_input(alias, *absbit, 0, INPUT_DEVICE_ID_ABS_MAX);\n\tsprintf(alias + strlen(alias), \"m*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_MSCIT)\n\t\tdo_input(alias, *mscbit, 0, INPUT_DEVICE_ID_MSC_MAX);\n\tsprintf(alias + strlen(alias), \"l*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_LEDBIT)\n\t\tdo_input(alias, *ledbit, 0, INPUT_DEVICE_ID_LED_MAX);\n\tsprintf(alias + strlen(alias), \"s*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_SNDBIT)\n\t\tdo_input(alias, *sndbit, 0, INPUT_DEVICE_ID_SND_MAX);\n\tsprintf(alias + strlen(alias), \"f*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_FFBIT)\n\t\tdo_input(alias, *ffbit, 0, INPUT_DEVICE_ID_FF_MAX);\n\tsprintf(alias + strlen(alias), \"w*\");\n\tif (flags & INPUT_DEVICE_ID_MATCH_SWBIT)\n\t\tdo_input(alias, *swbit, 0, INPUT_DEVICE_ID_SW_MAX);\n\treturn 1;\n}\n\nstatic int do_eisa_entry(const char *filename, void *symval,\n\t\tchar *alias)\n{\n\tDEF_FIELD_ADDR(symval, eisa_device_id, sig);\n\tif (sig[0])\n\t\tsprintf(alias, EISA_DEVICE_MODALIAS_FMT \"*\", *sig);\n\telse\n\t\tstrcat(alias, \"*\");\n\treturn 1;\n}\n\n \nstatic int do_parisc_entry(const char *filename, void *symval,\n\t\tchar *alias)\n{\n\tDEF_FIELD(symval, parisc_device_id, hw_type);\n\tDEF_FIELD(symval, parisc_device_id, hversion);\n\tDEF_FIELD(symval, parisc_device_id, hversion_rev);\n\tDEF_FIELD(symval, parisc_device_id, sversion);\n\n\tstrcpy(alias, \"parisc:\");\n\tADD(alias, \"t\", hw_type != PA_HWTYPE_ANY_ID, hw_type);\n\tADD(alias, \"hv\", hversion != PA_HVERSION_ANY_ID, hversion);\n\tADD(alias, \"rev\", hversion_rev != PA_HVERSION_REV_ANY_ID, hversion_rev);\n\tADD(alias, \"sv\", sversion != PA_SVERSION_ANY_ID, sversion);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_sdio_entry(const char *filename,\n\t\t\tvoid *symval, char *alias)\n{\n\tDEF_FIELD(symval, sdio_device_id, class);\n\tDEF_FIELD(symval, sdio_device_id, vendor);\n\tDEF_FIELD(symval, sdio_device_id, device);\n\n\tstrcpy(alias, \"sdio:\");\n\tADD(alias, \"c\", class != (__u8)SDIO_ANY_ID, class);\n\tADD(alias, \"v\", vendor != (__u16)SDIO_ANY_ID, vendor);\n\tADD(alias, \"d\", device != (__u16)SDIO_ANY_ID, device);\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_ssb_entry(const char *filename,\n\t\t\tvoid *symval, char *alias)\n{\n\tDEF_FIELD(symval, ssb_device_id, vendor);\n\tDEF_FIELD(symval, ssb_device_id, coreid);\n\tDEF_FIELD(symval, ssb_device_id, revision);\n\n\tstrcpy(alias, \"ssb:\");\n\tADD(alias, \"v\", vendor != SSB_ANY_VENDOR, vendor);\n\tADD(alias, \"id\", coreid != SSB_ANY_ID, coreid);\n\tADD(alias, \"rev\", revision != SSB_ANY_REV, revision);\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_bcma_entry(const char *filename,\n\t\t\t void *symval, char *alias)\n{\n\tDEF_FIELD(symval, bcma_device_id, manuf);\n\tDEF_FIELD(symval, bcma_device_id, id);\n\tDEF_FIELD(symval, bcma_device_id, rev);\n\tDEF_FIELD(symval, bcma_device_id, class);\n\n\tstrcpy(alias, \"bcma:\");\n\tADD(alias, \"m\", manuf != BCMA_ANY_MANUF, manuf);\n\tADD(alias, \"id\", id != BCMA_ANY_ID, id);\n\tADD(alias, \"rev\", rev != BCMA_ANY_REV, rev);\n\tADD(alias, \"cl\", class != BCMA_ANY_CLASS, class);\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_virtio_entry(const char *filename, void *symval,\n\t\t\t   char *alias)\n{\n\tDEF_FIELD(symval, virtio_device_id, device);\n\tDEF_FIELD(symval, virtio_device_id, vendor);\n\n\tstrcpy(alias, \"virtio:\");\n\tADD(alias, \"d\", device != VIRTIO_DEV_ANY_ID, device);\n\tADD(alias, \"v\", vendor != VIRTIO_DEV_ANY_ID, vendor);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \n\nstatic int do_vmbus_entry(const char *filename, void *symval,\n\t\t\t  char *alias)\n{\n\tint i;\n\tDEF_FIELD_ADDR(symval, hv_vmbus_device_id, guid);\n\tchar guid_name[(sizeof(*guid) + 1) * 2];\n\n\tfor (i = 0; i < (sizeof(*guid) * 2); i += 2)\n\t\tsprintf(&guid_name[i], \"%02x\", TO_NATIVE((guid->b)[i/2]));\n\n\tstrcpy(alias, \"vmbus:\");\n\tstrcat(alias, guid_name);\n\n\treturn 1;\n}\n\n \nstatic int do_rpmsg_entry(const char *filename, void *symval,\n\t\t\t  char *alias)\n{\n\tDEF_FIELD_ADDR(symval, rpmsg_device_id, name);\n\tsprintf(alias, RPMSG_DEVICE_MODALIAS_FMT, *name);\n\n\treturn 1;\n}\n\n \nstatic int do_i2c_entry(const char *filename, void *symval,\n\t\t\tchar *alias)\n{\n\tDEF_FIELD_ADDR(symval, i2c_device_id, name);\n\tsprintf(alias, I2C_MODULE_PREFIX \"%s\", *name);\n\n\treturn 1;\n}\n\nstatic int do_i3c_entry(const char *filename, void *symval,\n\t\t\tchar *alias)\n{\n\tDEF_FIELD(symval, i3c_device_id, match_flags);\n\tDEF_FIELD(symval, i3c_device_id, dcr);\n\tDEF_FIELD(symval, i3c_device_id, manuf_id);\n\tDEF_FIELD(symval, i3c_device_id, part_id);\n\tDEF_FIELD(symval, i3c_device_id, extra_info);\n\n\tstrcpy(alias, \"i3c:\");\n\tADD(alias, \"dcr\", match_flags & I3C_MATCH_DCR, dcr);\n\tADD(alias, \"manuf\", match_flags & I3C_MATCH_MANUF, manuf_id);\n\tADD(alias, \"part\", match_flags & I3C_MATCH_PART, part_id);\n\tADD(alias, \"ext\", match_flags & I3C_MATCH_EXTRA_INFO, extra_info);\n\n\treturn 1;\n}\n\n \nstatic int do_spi_entry(const char *filename, void *symval,\n\t\t\tchar *alias)\n{\n\tDEF_FIELD_ADDR(symval, spi_device_id, name);\n\tsprintf(alias, SPI_MODULE_PREFIX \"%s\", *name);\n\n\treturn 1;\n}\n\nstatic const struct dmifield {\n\tconst char *prefix;\n\tint field;\n} dmi_fields[] = {\n\t{ \"bvn\", DMI_BIOS_VENDOR },\n\t{ \"bvr\", DMI_BIOS_VERSION },\n\t{ \"bd\",  DMI_BIOS_DATE },\n\t{ \"br\",  DMI_BIOS_RELEASE },\n\t{ \"efr\", DMI_EC_FIRMWARE_RELEASE },\n\t{ \"svn\", DMI_SYS_VENDOR },\n\t{ \"pn\",  DMI_PRODUCT_NAME },\n\t{ \"pvr\", DMI_PRODUCT_VERSION },\n\t{ \"rvn\", DMI_BOARD_VENDOR },\n\t{ \"rn\",  DMI_BOARD_NAME },\n\t{ \"rvr\", DMI_BOARD_VERSION },\n\t{ \"cvn\", DMI_CHASSIS_VENDOR },\n\t{ \"ct\",  DMI_CHASSIS_TYPE },\n\t{ \"cvr\", DMI_CHASSIS_VERSION },\n\t{ NULL,  DMI_NONE }\n};\n\nstatic void dmi_ascii_filter(char *d, const char *s)\n{\n\t \n\tfor (; *s; s++)\n\t\tif (*s > ' ' && *s < 127 && *s != ':')\n\t\t\t*(d++) = *s;\n\n\t*d = 0;\n}\n\n\nstatic int do_dmi_entry(const char *filename, void *symval,\n\t\t\tchar *alias)\n{\n\tint i, j;\n\tDEF_FIELD_ADDR(symval, dmi_system_id, matches);\n\tsprintf(alias, \"dmi*\");\n\n\tfor (i = 0; i < ARRAY_SIZE(dmi_fields); i++) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tif ((*matches)[j].slot &&\n\t\t\t    (*matches)[j].slot == dmi_fields[i].field) {\n\t\t\t\tsprintf(alias + strlen(alias), \":%s*\",\n\t\t\t\t\tdmi_fields[i].prefix);\n\t\t\t\tdmi_ascii_filter(alias + strlen(alias),\n\t\t\t\t\t\t (*matches)[j].substr);\n\t\t\t\tstrcat(alias, \"*\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcat(alias, \":\");\n\treturn 1;\n}\n\nstatic int do_platform_entry(const char *filename,\n\t\t\t     void *symval, char *alias)\n{\n\tDEF_FIELD_ADDR(symval, platform_device_id, name);\n\tsprintf(alias, PLATFORM_MODULE_PREFIX \"%s\", *name);\n\treturn 1;\n}\n\nstatic int do_mdio_entry(const char *filename,\n\t\t\t void *symval, char *alias)\n{\n\tint i;\n\tDEF_FIELD(symval, mdio_device_id, phy_id);\n\tDEF_FIELD(symval, mdio_device_id, phy_id_mask);\n\n\talias += sprintf(alias, MDIO_MODULE_PREFIX);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (!((phy_id_mask >> (31-i)) & 1))\n\t\t\t*(alias++) = '?';\n\t\telse if ((phy_id >> (31-i)) & 1)\n\t\t\t*(alias++) = '1';\n\t\telse\n\t\t\t*(alias++) = '0';\n\t}\n\n\t \n\t*alias = 0;\n\n\treturn 1;\n}\n\n \nstatic int do_zorro_entry(const char *filename, void *symval,\n\t\t\t  char *alias)\n{\n\tDEF_FIELD(symval, zorro_device_id, id);\n\tstrcpy(alias, \"zorro:\");\n\tADD(alias, \"i\", id != ZORRO_WILDCARD, id);\n\treturn 1;\n}\n\n \nstatic int do_isapnp_entry(const char *filename,\n\t\t\t   void *symval, char *alias)\n{\n\tDEF_FIELD(symval, isapnp_device_id, vendor);\n\tDEF_FIELD(symval, isapnp_device_id, function);\n\tsprintf(alias, \"pnp:d%c%c%c%x%x%x%x*\",\n\t\t'A' + ((vendor >> 2) & 0x3f) - 1,\n\t\t'A' + (((vendor & 3) << 3) | ((vendor >> 13) & 7)) - 1,\n\t\t'A' + ((vendor >> 8) & 0x1f) - 1,\n\t\t(function >> 4) & 0x0f, function & 0x0f,\n\t\t(function >> 12) & 0x0f, (function >> 8) & 0x0f);\n\treturn 1;\n}\n\n \nstatic int do_ipack_entry(const char *filename,\n\t\t\t  void *symval, char *alias)\n{\n\tDEF_FIELD(symval, ipack_device_id, format);\n\tDEF_FIELD(symval, ipack_device_id, vendor);\n\tDEF_FIELD(symval, ipack_device_id, device);\n\tstrcpy(alias, \"ipack:\");\n\tADD(alias, \"f\", format != IPACK_ANY_FORMAT, format);\n\tADD(alias, \"v\", vendor != IPACK_ANY_ID, vendor);\n\tADD(alias, \"d\", device != IPACK_ANY_ID, device);\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic void append_nibble_mask(char **outp,\n\t\t\t       unsigned int nibble, unsigned int mask)\n{\n\tchar *p = *outp;\n\tunsigned int i;\n\n\tswitch (mask) {\n\tcase 0:\n\t\t*p++ = '?';\n\t\tbreak;\n\n\tcase 0xf:\n\t\tp += sprintf(p, \"%X\",  nibble);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\t*p++ = '[';\n\t\tfor (i = 0; i < 0x10; i++)\n\t\t\tif ((i & mask) == nibble)\n\t\t\t\tp += sprintf(p, \"%X\", i);\n\t\t*p++ = ']';\n\t}\n\n\t \n\t*p = '\\0';\n\n\t \n\t*outp = p;\n}\n\n \nstatic int do_amba_entry(const char *filename,\n\t\t\t void *symval, char *alias)\n{\n\tunsigned int digit;\n\tchar *p = alias;\n\tDEF_FIELD(symval, amba_id, id);\n\tDEF_FIELD(symval, amba_id, mask);\n\n\tif ((id & mask) != id)\n\t\tfatal(\"%s: Masked-off bit(s) of AMBA device ID are non-zero: id=0x%08X, mask=0x%08X.  Please fix this driver.\\n\",\n\t\t      filename, id, mask);\n\n\tp += sprintf(alias, \"amba:d\");\n\tfor (digit = 0; digit < 8; digit++)\n\t\tappend_nibble_mask(&p,\n\t\t\t\t   (id >> (4 * (7 - digit))) & 0xf,\n\t\t\t\t   (mask >> (4 * (7 - digit))) & 0xf);\n\n\treturn 1;\n}\n\n \nstatic int do_mips_cdmm_entry(const char *filename,\n\t\t\t      void *symval, char *alias)\n{\n\tDEF_FIELD(symval, mips_cdmm_device_id, type);\n\n\tsprintf(alias, \"mipscdmm:t%02X*\", type);\n\treturn 1;\n}\n\n \n\nstatic int do_x86cpu_entry(const char *filename, void *symval,\n\t\t\t   char *alias)\n{\n\tDEF_FIELD(symval, x86_cpu_id, feature);\n\tDEF_FIELD(symval, x86_cpu_id, family);\n\tDEF_FIELD(symval, x86_cpu_id, model);\n\tDEF_FIELD(symval, x86_cpu_id, vendor);\n\n\tstrcpy(alias, \"cpu:type:x86,\");\n\tADD(alias, \"ven\", vendor != X86_VENDOR_ANY, vendor);\n\tADD(alias, \"fam\", family != X86_FAMILY_ANY, family);\n\tADD(alias, \"mod\", model  != X86_MODEL_ANY,  model);\n\tstrcat(alias, \":feature:*\");\n\tif (feature != X86_FEATURE_ANY)\n\t\tsprintf(alias + strlen(alias), \"%04X*\", feature);\n\treturn 1;\n}\n\n \nstatic int do_cpu_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD(symval, cpu_feature, feature);\n\n\tsprintf(alias, \"cpu:type:*:feature:*%04X*\", feature);\n\treturn 1;\n}\n\n \nstatic int do_mei_entry(const char *filename, void *symval,\n\t\t\tchar *alias)\n{\n\tDEF_FIELD_ADDR(symval, mei_cl_device_id, name);\n\tDEF_FIELD_ADDR(symval, mei_cl_device_id, uuid);\n\tDEF_FIELD(symval, mei_cl_device_id, version);\n\n\tsprintf(alias, MEI_CL_MODULE_PREFIX);\n\tsprintf(alias + strlen(alias), \"%s:\",  (*name)[0]  ? *name : \"*\");\n\tadd_uuid(alias, *uuid);\n\tADD(alias, \":\", version != MEI_CL_VERSION_ANY, version);\n\n\tstrcat(alias, \":*\");\n\n\treturn 1;\n}\n\n \nstatic int do_rio_entry(const char *filename,\n\t\t\tvoid *symval, char *alias)\n{\n\tDEF_FIELD(symval, rio_device_id, did);\n\tDEF_FIELD(symval, rio_device_id, vid);\n\tDEF_FIELD(symval, rio_device_id, asm_did);\n\tDEF_FIELD(symval, rio_device_id, asm_vid);\n\n\tstrcpy(alias, \"rapidio:\");\n\tADD(alias, \"v\", vid != RIO_ANY_ID, vid);\n\tADD(alias, \"d\", did != RIO_ANY_ID, did);\n\tADD(alias, \"av\", asm_vid != RIO_ANY_ID, asm_vid);\n\tADD(alias, \"ad\", asm_did != RIO_ANY_ID, asm_did);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_ulpi_entry(const char *filename, void *symval,\n\t\t\t char *alias)\n{\n\tDEF_FIELD(symval, ulpi_device_id, vendor);\n\tDEF_FIELD(symval, ulpi_device_id, product);\n\n\tsprintf(alias, \"ulpi:v%04xp%04x\", vendor, product);\n\n\treturn 1;\n}\n\n \nstatic int do_hda_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD(symval, hda_device_id, vendor_id);\n\tDEF_FIELD(symval, hda_device_id, rev_id);\n\tDEF_FIELD(symval, hda_device_id, api_version);\n\n\tstrcpy(alias, \"hdaudio:\");\n\tADD(alias, \"v\", vendor_id != 0, vendor_id);\n\tADD(alias, \"r\", rev_id != 0, rev_id);\n\tADD(alias, \"a\", api_version != 0, api_version);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_sdw_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD(symval, sdw_device_id, mfg_id);\n\tDEF_FIELD(symval, sdw_device_id, part_id);\n\tDEF_FIELD(symval, sdw_device_id, sdw_version);\n\tDEF_FIELD(symval, sdw_device_id, class_id);\n\n\tstrcpy(alias, \"sdw:\");\n\tADD(alias, \"m\", mfg_id != 0, mfg_id);\n\tADD(alias, \"p\", part_id != 0, part_id);\n\tADD(alias, \"v\", sdw_version != 0, sdw_version);\n\tADD(alias, \"c\", class_id != 0, class_id);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_fsl_mc_entry(const char *filename, void *symval,\n\t\t\t   char *alias)\n{\n\tDEF_FIELD(symval, fsl_mc_device_id, vendor);\n\tDEF_FIELD_ADDR(symval, fsl_mc_device_id, obj_type);\n\n\tsprintf(alias, \"fsl-mc:v%08Xd%s\", vendor, *obj_type);\n\treturn 1;\n}\n\n \nstatic int do_tbsvc_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD(symval, tb_service_id, match_flags);\n\tDEF_FIELD_ADDR(symval, tb_service_id, protocol_key);\n\tDEF_FIELD(symval, tb_service_id, protocol_id);\n\tDEF_FIELD(symval, tb_service_id, protocol_version);\n\tDEF_FIELD(symval, tb_service_id, protocol_revision);\n\n\tstrcpy(alias, \"tbsvc:\");\n\tif (match_flags & TBSVC_MATCH_PROTOCOL_KEY)\n\t\tsprintf(alias + strlen(alias), \"k%s\", *protocol_key);\n\telse\n\t\tstrcat(alias + strlen(alias), \"k*\");\n\tADD(alias, \"p\", match_flags & TBSVC_MATCH_PROTOCOL_ID, protocol_id);\n\tADD(alias, \"v\", match_flags & TBSVC_MATCH_PROTOCOL_VERSION,\n\t    protocol_version);\n\tADD(alias, \"r\", match_flags & TBSVC_MATCH_PROTOCOL_REVISION,\n\t    protocol_revision);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_typec_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD(symval, typec_device_id, svid);\n\tDEF_FIELD(symval, typec_device_id, mode);\n\n\tsprintf(alias, \"typec:id%04X\", svid);\n\tADD(alias, \"m\", mode != TYPEC_ANY_MODE, mode);\n\n\treturn 1;\n}\n\n \nstatic int do_tee_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD_ADDR(symval, tee_client_device_id, uuid);\n\n\tsprintf(alias, \"tee:%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t\tuuid->b[0], uuid->b[1], uuid->b[2], uuid->b[3], uuid->b[4],\n\t\tuuid->b[5], uuid->b[6], uuid->b[7], uuid->b[8], uuid->b[9],\n\t\tuuid->b[10], uuid->b[11], uuid->b[12], uuid->b[13], uuid->b[14],\n\t\tuuid->b[15]);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_wmi_entry(const char *filename, void *symval, char *alias)\n{\n\tint len;\n\tDEF_FIELD_ADDR(symval, wmi_device_id, guid_string);\n\n\tif (strlen(*guid_string) != UUID_STRING_LEN) {\n\t\twarn(\"Invalid WMI device id 'wmi:%s' in '%s'\\n\",\n\t\t\t\t*guid_string, filename);\n\t\treturn 0;\n\t}\n\n\tlen = snprintf(alias, ALIAS_SIZE, WMI_MODULE_PREFIX \"%s\", *guid_string);\n\tif (len < 0 || len >= ALIAS_SIZE) {\n\t\twarn(\"Could not generate all MODULE_ALIAS's in '%s'\\n\",\n\t\t\t\tfilename);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int do_mhi_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD_ADDR(symval, mhi_device_id, chan);\n\tsprintf(alias, MHI_DEVICE_MODALIAS_FMT, *chan);\n\treturn 1;\n}\n\n \nstatic int do_mhi_ep_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD_ADDR(symval, mhi_device_id, chan);\n\tsprintf(alias, MHI_EP_DEVICE_MODALIAS_FMT, *chan);\n\n\treturn 1;\n}\n\n \nstatic int do_ishtp_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD_ADDR(symval, ishtp_device_id, guid);\n\n\tstrcpy(alias, ISHTP_MODULE_PREFIX \"{\");\n\tadd_guid(alias, *guid);\n\tstrcat(alias, \"}\");\n\n\treturn 1;\n}\n\nstatic int do_auxiliary_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD_ADDR(symval, auxiliary_device_id, name);\n\tsprintf(alias, AUXILIARY_MODULE_PREFIX \"%s\", *name);\n\n\treturn 1;\n}\n\n \nstatic int do_ssam_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD(symval, ssam_device_id, match_flags);\n\tDEF_FIELD(symval, ssam_device_id, domain);\n\tDEF_FIELD(symval, ssam_device_id, category);\n\tDEF_FIELD(symval, ssam_device_id, target);\n\tDEF_FIELD(symval, ssam_device_id, instance);\n\tDEF_FIELD(symval, ssam_device_id, function);\n\n\tsprintf(alias, \"ssam:d%02Xc%02X\", domain, category);\n\tADD(alias, \"t\", match_flags & SSAM_MATCH_TARGET, target);\n\tADD(alias, \"i\", match_flags & SSAM_MATCH_INSTANCE, instance);\n\tADD(alias, \"f\", match_flags & SSAM_MATCH_FUNCTION, function);\n\n\treturn 1;\n}\n\n \nstatic int do_dfl_entry(const char *filename, void *symval, char *alias)\n{\n\tDEF_FIELD(symval, dfl_device_id, type);\n\tDEF_FIELD(symval, dfl_device_id, feature_id);\n\n\tsprintf(alias, \"dfl:t%04Xf%04X\", type, feature_id);\n\n\tadd_wildcard(alias);\n\treturn 1;\n}\n\n \nstatic int do_cdx_entry(const char *filename, void *symval,\n\t\t\tchar *alias)\n{\n\tDEF_FIELD(symval, cdx_device_id, vendor);\n\tDEF_FIELD(symval, cdx_device_id, device);\n\tDEF_FIELD(symval, cdx_device_id, override_only);\n\n\tswitch (override_only) {\n\tcase 0:\n\t\tstrcpy(alias, \"cdx:\");\n\t\tbreak;\n\tcase CDX_ID_F_VFIO_DRIVER_OVERRIDE:\n\t\tstrcpy(alias, \"vfio_cdx:\");\n\t\tbreak;\n\tdefault:\n\t\twarn(\"Unknown CDX driver_override alias %08X\\n\",\n\t\t     override_only);\n\t\treturn 0;\n\t}\n\n\tADD(alias, \"v\", vendor != CDX_ANY_ID, vendor);\n\tADD(alias, \"d\", device != CDX_ANY_ID, device);\n\treturn 1;\n}\n\n \nstatic bool sym_is(const char *name, unsigned namelen, const char *symbol)\n{\n\tif (namelen != strlen(symbol))\n\t\treturn false;\n\n\treturn memcmp(name, symbol, namelen) == 0;\n}\n\nstatic void do_table(void *symval, unsigned long size,\n\t\t     unsigned long id_size,\n\t\t     const char *device_id,\n\t\t     int (*do_entry)(const char *filename, void *symval, char *alias),\n\t\t     struct module *mod)\n{\n\tunsigned int i;\n\tchar alias[ALIAS_SIZE];\n\n\tdevice_id_check(mod->name, device_id, size, id_size, symval);\n\t \n\tsize -= id_size;\n\n\tfor (i = 0; i < size; i += id_size) {\n\t\tif (do_entry(mod->name, symval+i, alias)) {\n\t\t\tbuf_printf(&mod->dev_table_buf,\n\t\t\t\t   \"MODULE_ALIAS(\\\"%s\\\");\\n\", alias);\n\t\t}\n\t}\n}\n\nstatic const struct devtable devtable[] = {\n\t{\"hid\", SIZE_hid_device_id, do_hid_entry},\n\t{\"ieee1394\", SIZE_ieee1394_device_id, do_ieee1394_entry},\n\t{\"pci\", SIZE_pci_device_id, do_pci_entry},\n\t{\"ccw\", SIZE_ccw_device_id, do_ccw_entry},\n\t{\"ap\", SIZE_ap_device_id, do_ap_entry},\n\t{\"css\", SIZE_css_device_id, do_css_entry},\n\t{\"serio\", SIZE_serio_device_id, do_serio_entry},\n\t{\"acpi\", SIZE_acpi_device_id, do_acpi_entry},\n\t{\"pcmcia\", SIZE_pcmcia_device_id, do_pcmcia_entry},\n\t{\"vio\", SIZE_vio_device_id, do_vio_entry},\n\t{\"input\", SIZE_input_device_id, do_input_entry},\n\t{\"eisa\", SIZE_eisa_device_id, do_eisa_entry},\n\t{\"parisc\", SIZE_parisc_device_id, do_parisc_entry},\n\t{\"sdio\", SIZE_sdio_device_id, do_sdio_entry},\n\t{\"ssb\", SIZE_ssb_device_id, do_ssb_entry},\n\t{\"bcma\", SIZE_bcma_device_id, do_bcma_entry},\n\t{\"virtio\", SIZE_virtio_device_id, do_virtio_entry},\n\t{\"vmbus\", SIZE_hv_vmbus_device_id, do_vmbus_entry},\n\t{\"rpmsg\", SIZE_rpmsg_device_id, do_rpmsg_entry},\n\t{\"i2c\", SIZE_i2c_device_id, do_i2c_entry},\n\t{\"i3c\", SIZE_i3c_device_id, do_i3c_entry},\n\t{\"spi\", SIZE_spi_device_id, do_spi_entry},\n\t{\"dmi\", SIZE_dmi_system_id, do_dmi_entry},\n\t{\"platform\", SIZE_platform_device_id, do_platform_entry},\n\t{\"mdio\", SIZE_mdio_device_id, do_mdio_entry},\n\t{\"zorro\", SIZE_zorro_device_id, do_zorro_entry},\n\t{\"isapnp\", SIZE_isapnp_device_id, do_isapnp_entry},\n\t{\"ipack\", SIZE_ipack_device_id, do_ipack_entry},\n\t{\"amba\", SIZE_amba_id, do_amba_entry},\n\t{\"mipscdmm\", SIZE_mips_cdmm_device_id, do_mips_cdmm_entry},\n\t{\"x86cpu\", SIZE_x86_cpu_id, do_x86cpu_entry},\n\t{\"cpu\", SIZE_cpu_feature, do_cpu_entry},\n\t{\"mei\", SIZE_mei_cl_device_id, do_mei_entry},\n\t{\"rapidio\", SIZE_rio_device_id, do_rio_entry},\n\t{\"ulpi\", SIZE_ulpi_device_id, do_ulpi_entry},\n\t{\"hdaudio\", SIZE_hda_device_id, do_hda_entry},\n\t{\"sdw\", SIZE_sdw_device_id, do_sdw_entry},\n\t{\"fslmc\", SIZE_fsl_mc_device_id, do_fsl_mc_entry},\n\t{\"tbsvc\", SIZE_tb_service_id, do_tbsvc_entry},\n\t{\"typec\", SIZE_typec_device_id, do_typec_entry},\n\t{\"tee\", SIZE_tee_client_device_id, do_tee_entry},\n\t{\"wmi\", SIZE_wmi_device_id, do_wmi_entry},\n\t{\"mhi\", SIZE_mhi_device_id, do_mhi_entry},\n\t{\"mhi_ep\", SIZE_mhi_device_id, do_mhi_ep_entry},\n\t{\"auxiliary\", SIZE_auxiliary_device_id, do_auxiliary_entry},\n\t{\"ssam\", SIZE_ssam_device_id, do_ssam_entry},\n\t{\"dfl\", SIZE_dfl_device_id, do_dfl_entry},\n\t{\"ishtp\", SIZE_ishtp_device_id, do_ishtp_entry},\n\t{\"cdx\", SIZE_cdx_device_id, do_cdx_entry},\n};\n\n \nvoid handle_moddevtable(struct module *mod, struct elf_info *info,\n\t\t\tElf_Sym *sym, const char *symname)\n{\n\tvoid *symval;\n\tchar *zeros = NULL;\n\tconst char *name, *identifier;\n\tunsigned int namelen;\n\n\t \n\tif (!sym->st_shndx || get_secindex(info, sym) >= info->num_sections)\n\t\treturn;\n\n\t \n\tif (ELF_ST_TYPE(sym->st_info) != STT_OBJECT)\n\t\treturn;\n\n\t \n\tif (strncmp(symname, \"__mod_\", strlen(\"__mod_\")))\n\t\treturn;\n\tname = symname + strlen(\"__mod_\");\n\tnamelen = strlen(name);\n\tif (namelen < strlen(\"_device_table\"))\n\t\treturn;\n\tif (strcmp(name + namelen - strlen(\"_device_table\"), \"_device_table\"))\n\t\treturn;\n\tidentifier = strstr(name, \"__\");\n\tif (!identifier)\n\t\treturn;\n\tnamelen = identifier - name;\n\n\t \n\tif (info->sechdrs[get_secindex(info, sym)].sh_type & SHT_NOBITS) {\n\t\tzeros = calloc(1, sym->st_size);\n\t\tsymval = zeros;\n\t} else {\n\t\tsymval = sym_get_data(info, sym);\n\t}\n\n\t \n\tif (sym_is(name, namelen, \"usb\"))\n\t\tdo_usb_table(symval, sym->st_size, mod);\n\telse if (sym_is(name, namelen, \"of\"))\n\t\tdo_of_table(symval, sym->st_size, mod);\n\telse if (sym_is(name, namelen, \"pnp\"))\n\t\tdo_pnp_device_entry(symval, sym->st_size, mod);\n\telse if (sym_is(name, namelen, \"pnp_card\"))\n\t\tdo_pnp_card_entries(symval, sym->st_size, mod);\n\telse {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(devtable); i++) {\n\t\t\tconst struct devtable *p = &devtable[i];\n\n\t\t\tif (sym_is(name, namelen, p->device_id)) {\n\t\t\t\tdo_table(symval, sym->st_size, p->id_size,\n\t\t\t\t\t p->device_id, p->do_entry, mod);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(zeros);\n}\n\n \nvoid add_moddevtable(struct buffer *buf, struct module *mod)\n{\n\tbuf_printf(buf, \"\\n\");\n\tbuf_write(buf, mod->dev_table_buf.p, mod->dev_table_buf.pos);\n\tfree(mod->dev_table_buf.p);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}