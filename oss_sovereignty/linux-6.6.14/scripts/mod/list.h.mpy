{
  "module_name": "list.h",
  "hash_id": "1305ad580498c0eb5d538e40c92993f6553e18de89296d9c94282441f968614a",
  "original_prompt": "Ingested from linux-6.6.14/scripts/mod/list.h",
  "human_readable_source": " \n#ifndef LIST_H\n#define LIST_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n \n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n \n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\t_Static_assert(__same_type(*(ptr), ((type *)0)->member) ||\t\\\n\t\t      __same_type(*(ptr), void),\t\t\t\\\n\t\t      \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n\n#define LIST_POISON1  ((void *) 0x100)\n#define LIST_POISON2  ((void *) 0x122)\n\n \n\nstruct list_head {\n\tstruct list_head *next, *prev;\n};\n\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n#define LIST_HEAD(name) \\\n\tstruct list_head name = LIST_HEAD_INIT(name)\n\n \nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n\tlist->next = list;\n\tlist->prev = list;\n}\n\n \nstatic inline void __list_add(struct list_head *new,\n\t\t\t      struct list_head *prev,\n\t\t\t      struct list_head *next)\n{\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tprev->next = new;\n}\n\n \nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head, head->next);\n}\n\n \nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head->prev, head);\n}\n\n \nstatic inline void __list_del(struct list_head *prev, struct list_head *next)\n{\n\tnext->prev = prev;\n\tprev->next = next;\n}\n\nstatic inline void __list_del_entry(struct list_head *entry)\n{\n\t__list_del(entry->prev, entry->next);\n}\n\n \nstatic inline void list_del(struct list_head *entry)\n{\n\t__list_del_entry(entry);\n\tentry->next = LIST_POISON1;\n\tentry->prev = LIST_POISON2;\n}\n\n \nstatic inline int list_is_head(const struct list_head *list, const struct list_head *head)\n{\n\treturn list == head;\n}\n\n \nstatic inline int list_empty(const struct list_head *head)\n{\n\treturn head->next == head;\n}\n\n \n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\n \n#define list_first_entry(ptr, type, member) \\\n\tlist_entry((ptr)->next, type, member)\n\n \n#define list_next_entry(pos, member) \\\n\tlist_entry((pos)->member.next, typeof(*(pos)), member)\n\n \n#define list_entry_is_head(pos, head, member)\t\t\t\t\\\n\t(&pos->member == (head))\n\n \n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = list_first_entry(head, typeof(*pos), member);\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n \n#define list_for_each_entry_safe(pos, n, head, member)\t\t\t\\\n\tfor (pos = list_first_entry(head, typeof(*pos), member),\t\\\n\t\tn = list_next_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}