{
  "module_name": "sumversion.c",
  "hash_id": "77eaa9ebd665d2533f29d08f63aadb05e233efa772a1020bfb1f1be40c55a226",
  "original_prompt": "Ingested from linux-6.6.14/scripts/mod/sumversion.c",
  "human_readable_source": "#include <netinet/in.h>\n#ifdef __sun__\n#include <inttypes.h>\n#else\n#include <stdint.h>\n#endif\n#include <ctype.h>\n#include <errno.h>\n#include <string.h>\n#include <limits.h>\n#include \"modpost.h\"\n\n \n#define MD4_DIGEST_SIZE\t\t16\n#define MD4_HMAC_BLOCK_SIZE\t64\n#define MD4_BLOCK_WORDS\t\t16\n#define MD4_HASH_WORDS\t\t4\n\nstruct md4_ctx {\n\tuint32_t hash[MD4_HASH_WORDS];\n\tuint32_t block[MD4_BLOCK_WORDS];\n\tuint64_t byte_count;\n};\n\nstatic inline uint32_t lshift(uint32_t x, unsigned int s)\n{\n\tx &= 0xFFFFFFFF;\n\treturn ((x << s) & 0xFFFFFFFF) | (x >> (32 - s));\n}\n\nstatic inline uint32_t F(uint32_t x, uint32_t y, uint32_t z)\n{\n\treturn (x & y) | ((~x) & z);\n}\n\nstatic inline uint32_t G(uint32_t x, uint32_t y, uint32_t z)\n{\n\treturn (x & y) | (x & z) | (y & z);\n}\n\nstatic inline uint32_t H(uint32_t x, uint32_t y, uint32_t z)\n{\n\treturn x ^ y ^ z;\n}\n\n#define ROUND1(a,b,c,d,k,s) (a = lshift(a + F(b,c,d) + k, s))\n#define ROUND2(a,b,c,d,k,s) (a = lshift(a + G(b,c,d) + k + (uint32_t)0x5A827999,s))\n#define ROUND3(a,b,c,d,k,s) (a = lshift(a + H(b,c,d) + k + (uint32_t)0x6ED9EBA1,s))\n\n \nstatic inline void le32_to_cpu_array(uint32_t *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t*buf = ntohl(*buf);\n\t\tbuf++;\n\t}\n}\n\nstatic inline void cpu_to_le32_array(uint32_t *buf, unsigned int words)\n{\n\twhile (words--) {\n\t\t*buf = htonl(*buf);\n\t\tbuf++;\n\t}\n}\n\nstatic void md4_transform(uint32_t *hash, uint32_t const *in)\n{\n\tuint32_t a, b, c, d;\n\n\ta = hash[0];\n\tb = hash[1];\n\tc = hash[2];\n\td = hash[3];\n\n\tROUND1(a, b, c, d, in[0], 3);\n\tROUND1(d, a, b, c, in[1], 7);\n\tROUND1(c, d, a, b, in[2], 11);\n\tROUND1(b, c, d, a, in[3], 19);\n\tROUND1(a, b, c, d, in[4], 3);\n\tROUND1(d, a, b, c, in[5], 7);\n\tROUND1(c, d, a, b, in[6], 11);\n\tROUND1(b, c, d, a, in[7], 19);\n\tROUND1(a, b, c, d, in[8], 3);\n\tROUND1(d, a, b, c, in[9], 7);\n\tROUND1(c, d, a, b, in[10], 11);\n\tROUND1(b, c, d, a, in[11], 19);\n\tROUND1(a, b, c, d, in[12], 3);\n\tROUND1(d, a, b, c, in[13], 7);\n\tROUND1(c, d, a, b, in[14], 11);\n\tROUND1(b, c, d, a, in[15], 19);\n\n\tROUND2(a, b, c, d,in[ 0], 3);\n\tROUND2(d, a, b, c, in[4], 5);\n\tROUND2(c, d, a, b, in[8], 9);\n\tROUND2(b, c, d, a, in[12], 13);\n\tROUND2(a, b, c, d, in[1], 3);\n\tROUND2(d, a, b, c, in[5], 5);\n\tROUND2(c, d, a, b, in[9], 9);\n\tROUND2(b, c, d, a, in[13], 13);\n\tROUND2(a, b, c, d, in[2], 3);\n\tROUND2(d, a, b, c, in[6], 5);\n\tROUND2(c, d, a, b, in[10], 9);\n\tROUND2(b, c, d, a, in[14], 13);\n\tROUND2(a, b, c, d, in[3], 3);\n\tROUND2(d, a, b, c, in[7], 5);\n\tROUND2(c, d, a, b, in[11], 9);\n\tROUND2(b, c, d, a, in[15], 13);\n\n\tROUND3(a, b, c, d,in[ 0], 3);\n\tROUND3(d, a, b, c, in[8], 9);\n\tROUND3(c, d, a, b, in[4], 11);\n\tROUND3(b, c, d, a, in[12], 15);\n\tROUND3(a, b, c, d, in[2], 3);\n\tROUND3(d, a, b, c, in[10], 9);\n\tROUND3(c, d, a, b, in[6], 11);\n\tROUND3(b, c, d, a, in[14], 15);\n\tROUND3(a, b, c, d, in[1], 3);\n\tROUND3(d, a, b, c, in[9], 9);\n\tROUND3(c, d, a, b, in[5], 11);\n\tROUND3(b, c, d, a, in[13], 15);\n\tROUND3(a, b, c, d, in[3], 3);\n\tROUND3(d, a, b, c, in[11], 9);\n\tROUND3(c, d, a, b, in[7], 11);\n\tROUND3(b, c, d, a, in[15], 15);\n\n\thash[0] += a;\n\thash[1] += b;\n\thash[2] += c;\n\thash[3] += d;\n}\n\nstatic inline void md4_transform_helper(struct md4_ctx *ctx)\n{\n\tle32_to_cpu_array(ctx->block, ARRAY_SIZE(ctx->block));\n\tmd4_transform(ctx->hash, ctx->block);\n}\n\nstatic void md4_init(struct md4_ctx *mctx)\n{\n\tmctx->hash[0] = 0x67452301;\n\tmctx->hash[1] = 0xefcdab89;\n\tmctx->hash[2] = 0x98badcfe;\n\tmctx->hash[3] = 0x10325476;\n\tmctx->byte_count = 0;\n}\n\nstatic void md4_update(struct md4_ctx *mctx,\n\t\t       const unsigned char *data, unsigned int len)\n{\n\tconst uint32_t avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);\n\n\tmctx->byte_count += len;\n\n\tif (avail > len) {\n\t\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t\t       data, len);\n\t\treturn;\n\t}\n\n\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t       data, avail);\n\n\tmd4_transform_helper(mctx);\n\tdata += avail;\n\tlen -= avail;\n\n\twhile (len >= sizeof(mctx->block)) {\n\t\tmemcpy(mctx->block, data, sizeof(mctx->block));\n\t\tmd4_transform_helper(mctx);\n\t\tdata += sizeof(mctx->block);\n\t\tlen -= sizeof(mctx->block);\n\t}\n\n\tmemcpy(mctx->block, data, len);\n}\n\nstatic void md4_final_ascii(struct md4_ctx *mctx, char *out, unsigned int len)\n{\n\tconst unsigned int offset = mctx->byte_count & 0x3f;\n\tchar *p = (char *)mctx->block + offset;\n\tint padding = 56 - (offset + 1);\n\n\t*p++ = 0x80;\n\tif (padding < 0) {\n\t\tmemset(p, 0x00, padding + sizeof (uint64_t));\n\t\tmd4_transform_helper(mctx);\n\t\tp = (char *)mctx->block;\n\t\tpadding = 56;\n\t}\n\n\tmemset(p, 0, padding);\n\tmctx->block[14] = mctx->byte_count << 3;\n\tmctx->block[15] = mctx->byte_count >> 29;\n\tle32_to_cpu_array(mctx->block, (sizeof(mctx->block) -\n\t\t\t  sizeof(uint64_t)) / sizeof(uint32_t));\n\tmd4_transform(mctx->hash, mctx->block);\n\tcpu_to_le32_array(mctx->hash, ARRAY_SIZE(mctx->hash));\n\n\tsnprintf(out, len, \"%08X%08X%08X%08X\",\n\t\t mctx->hash[0], mctx->hash[1], mctx->hash[2], mctx->hash[3]);\n}\n\nstatic inline void add_char(unsigned char c, struct md4_ctx *md)\n{\n\tmd4_update(md, &c, 1);\n}\n\nstatic int parse_string(const char *file, unsigned long len,\n\t\t\tstruct md4_ctx *md)\n{\n\tunsigned long i;\n\n\tadd_char(file[0], md);\n\tfor (i = 1; i < len; i++) {\n\t\tadd_char(file[i], md);\n\t\tif (file[i] == '\"' && file[i-1] != '\\\\')\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic int parse_comment(const char *file, unsigned long len)\n{\n\tunsigned long i;\n\n\tfor (i = 2; i < len; i++) {\n\t\tif (file[i-1] == '*' && file[i] == '/')\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\n \nstatic int parse_file(const char *fname, struct md4_ctx *md)\n{\n\tchar *file;\n\tunsigned long i, len;\n\n\tfile = read_text_file(fname);\n\tlen = strlen(file);\n\n\tfor (i = 0; i < len; i++) {\n\t\t \n\t\tif (file[i] == '\\\\' && (i+1 < len) && file[i+1] == '\\n') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (isspace(file[i]))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (file[i] == '\"') {\n\t\t\ti += parse_string(file+i, len - i, md);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (file[i] == '/' && file[i+1] == '*') {\n\t\t\ti += parse_comment(file+i, len - i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tadd_char(file[i], md);\n\t}\n\tfree(file);\n\treturn 1;\n}\n \nstatic bool is_static_library(const char *objfile)\n{\n\tint len = strlen(objfile);\n\n\treturn objfile[len - 2] == '.' && objfile[len - 1] == 'a';\n}\n\n \nstatic int parse_source_files(const char *objfile, struct md4_ctx *md)\n{\n\tchar *cmd, *file, *line, *dir, *pos;\n\tconst char *base;\n\tint dirlen, ret = 0, check_files = 0;\n\n\tcmd = NOFAIL(malloc(strlen(objfile) + sizeof(\"..cmd\")));\n\n\tbase = strrchr(objfile, '/');\n\tif (base) {\n\t\tbase++;\n\t\tdirlen = base - objfile;\n\t\tsprintf(cmd, \"%.*s.%s.cmd\", dirlen, objfile, base);\n\t} else {\n\t\tdirlen = 0;\n\t\tsprintf(cmd, \".%s.cmd\", objfile);\n\t}\n\tdir = NOFAIL(malloc(dirlen + 1));\n\tstrncpy(dir, objfile, dirlen);\n\tdir[dirlen] = '\\0';\n\n\tfile = read_text_file(cmd);\n\n\tpos = file;\n\n\t \n\twhile ((line = get_line(&pos))) {\n\t\tchar* p = line;\n\n\t\tif (strncmp(line, \"source_\", sizeof(\"source_\")-1) == 0) {\n\t\t\tp = strrchr(line, ' ');\n\t\t\tif (!p) {\n\t\t\t\twarn(\"malformed line: %s\\n\", line);\n\t\t\t\tgoto out_file;\n\t\t\t}\n\t\t\tp++;\n\t\t\tif (!parse_file(p, md)) {\n\t\t\t\twarn(\"could not open %s: %s\\n\",\n\t\t\t\t     p, strerror(errno));\n\t\t\t\tgoto out_file;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncmp(line, \"deps_\", sizeof(\"deps_\")-1) == 0) {\n\t\t\tcheck_files = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!check_files)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ( *(p + strlen(p)-1) != '\\\\')\n\t\t\tbreak;\n\t\t \n\t\twhile (*p) {\n\t\t\tif (isspace(*p)) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\t \n\t\tif ((strstr(line, dir)+strlen(dir)-1) == strrchr(line, '/')) {\n\t\t\tif (!parse_file(line, md)) {\n\t\t\t\twarn(\"could not open %s: %s\\n\",\n\t\t\t\t     line, strerror(errno));\n\t\t\t\tgoto out_file;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t \n\tret = 1;\nout_file:\n\tfree(file);\n\tfree(dir);\n\tfree(cmd);\n\treturn ret;\n}\n\n \nvoid get_src_version(const char *modname, char sum[], unsigned sumlen)\n{\n\tchar *buf;\n\tstruct md4_ctx md;\n\tchar *fname;\n\tchar filelist[PATH_MAX + 1];\n\n\t \n\tsnprintf(filelist, sizeof(filelist), \"%s.mod\", modname);\n\n\tbuf = read_text_file(filelist);\n\n\tmd4_init(&md);\n\twhile ((fname = strsep(&buf, \"\\n\"))) {\n\t\tif (!*fname)\n\t\t\tcontinue;\n\t\tif (!(is_static_library(fname)) &&\n\t\t\t\t!parse_source_files(fname, &md))\n\t\t\tgoto free;\n\t}\n\n\tmd4_final_ascii(&md, sum, sumlen);\nfree:\n\tfree(buf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}