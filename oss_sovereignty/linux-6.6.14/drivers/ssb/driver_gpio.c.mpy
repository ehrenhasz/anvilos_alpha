{
  "module_name": "driver_gpio.c",
  "hash_id": "9719e7346e944933120a3ec80edce763fc5bf851488790a6431807df932704bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/driver_gpio.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/gpio/driver.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/export.h>\n#include <linux/ssb/ssb.h>\n\n\n \n\n#if IS_ENABLED(CONFIG_SSB_EMBEDDED)\nstatic int ssb_gpio_to_irq(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\tif (bus->bustype == SSB_BUSTYPE_SSB)\n\t\treturn irq_find_mapping(bus->irq_domain, gpio);\n\telse\n\t\treturn -EINVAL;\n}\n#endif\n\n \n\nstatic int ssb_gpio_chipco_get_value(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\treturn !!ssb_chipco_gpio_in(&bus->chipco, 1 << gpio);\n}\n\nstatic void ssb_gpio_chipco_set_value(struct gpio_chip *chip, unsigned int gpio,\n\t\t\t\t      int value)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\tssb_chipco_gpio_out(&bus->chipco, 1 << gpio, value ? 1 << gpio : 0);\n}\n\nstatic int ssb_gpio_chipco_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned int gpio)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\tssb_chipco_gpio_outen(&bus->chipco, 1 << gpio, 0);\n\treturn 0;\n}\n\nstatic int ssb_gpio_chipco_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t    unsigned int gpio, int value)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\tssb_chipco_gpio_outen(&bus->chipco, 1 << gpio, 1 << gpio);\n\tssb_chipco_gpio_out(&bus->chipco, 1 << gpio, value ? 1 << gpio : 0);\n\treturn 0;\n}\n\nstatic int ssb_gpio_chipco_request(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\tssb_chipco_gpio_control(&bus->chipco, 1 << gpio, 0);\n\t \n\tssb_chipco_gpio_pulldown(&bus->chipco, 1 << gpio, 0);\n\t \n\tssb_chipco_gpio_pullup(&bus->chipco, 1 << gpio, 1 << gpio);\n\n\treturn 0;\n}\n\nstatic void ssb_gpio_chipco_free(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\t \n\tssb_chipco_gpio_pullup(&bus->chipco, 1 << gpio, 0);\n}\n\n#if IS_ENABLED(CONFIG_SSB_EMBEDDED)\nstatic void ssb_gpio_irq_chipco_mask(struct irq_data *d)\n{\n\tstruct ssb_bus *bus = irq_data_get_irq_chip_data(d);\n\tint gpio = irqd_to_hwirq(d);\n\n\tssb_chipco_gpio_intmask(&bus->chipco, BIT(gpio), 0);\n}\n\nstatic void ssb_gpio_irq_chipco_unmask(struct irq_data *d)\n{\n\tstruct ssb_bus *bus = irq_data_get_irq_chip_data(d);\n\tint gpio = irqd_to_hwirq(d);\n\tu32 val = ssb_chipco_gpio_in(&bus->chipco, BIT(gpio));\n\n\tssb_chipco_gpio_polarity(&bus->chipco, BIT(gpio), val);\n\tssb_chipco_gpio_intmask(&bus->chipco, BIT(gpio), BIT(gpio));\n}\n\nstatic struct irq_chip ssb_gpio_irq_chipco_chip = {\n\t.name\t\t= \"SSB-GPIO-CC\",\n\t.irq_mask\t= ssb_gpio_irq_chipco_mask,\n\t.irq_unmask\t= ssb_gpio_irq_chipco_unmask,\n};\n\nstatic irqreturn_t ssb_gpio_irq_chipco_handler(int irq, void *dev_id)\n{\n\tstruct ssb_bus *bus = dev_id;\n\tstruct ssb_chipcommon *chipco = &bus->chipco;\n\tu32 val = chipco_read32(chipco, SSB_CHIPCO_GPIOIN);\n\tu32 mask = chipco_read32(chipco, SSB_CHIPCO_GPIOIRQ);\n\tu32 pol = chipco_read32(chipco, SSB_CHIPCO_GPIOPOL);\n\tunsigned long irqs = (val ^ pol) & mask;\n\tint gpio;\n\n\tif (!irqs)\n\t\treturn IRQ_NONE;\n\n\tfor_each_set_bit(gpio, &irqs, bus->gpio.ngpio)\n\t\tgeneric_handle_domain_irq_safe(bus->irq_domain, gpio);\n\n\tssb_chipco_gpio_polarity(chipco, irqs, val & irqs);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ssb_gpio_irq_chipco_domain_init(struct ssb_bus *bus)\n{\n\tstruct ssb_chipcommon *chipco = &bus->chipco;\n\tstruct gpio_chip *chip = &bus->gpio;\n\tint gpio, hwirq, err;\n\n\tif (bus->bustype != SSB_BUSTYPE_SSB)\n\t\treturn 0;\n\n\tbus->irq_domain = irq_domain_add_linear(NULL, chip->ngpio,\n\t\t\t\t\t\t&irq_domain_simple_ops, chipco);\n\tif (!bus->irq_domain) {\n\t\terr = -ENODEV;\n\t\tgoto err_irq_domain;\n\t}\n\tfor (gpio = 0; gpio < chip->ngpio; gpio++) {\n\t\tint irq = irq_create_mapping(bus->irq_domain, gpio);\n\n\t\tirq_set_chip_data(irq, bus);\n\t\tirq_set_chip_and_handler(irq, &ssb_gpio_irq_chipco_chip,\n\t\t\t\t\t handle_simple_irq);\n\t}\n\n\thwirq = ssb_mips_irq(bus->chipco.dev) + 2;\n\terr = request_irq(hwirq, ssb_gpio_irq_chipco_handler, IRQF_SHARED,\n\t\t\t  \"gpio\", bus);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\tssb_chipco_gpio_intmask(&bus->chipco, ~0, 0);\n\tchipco_set32(chipco, SSB_CHIPCO_IRQMASK, SSB_CHIPCO_IRQ_GPIO);\n\n\treturn 0;\n\nerr_req_irq:\n\tfor (gpio = 0; gpio < chip->ngpio; gpio++) {\n\t\tint irq = irq_find_mapping(bus->irq_domain, gpio);\n\n\t\tirq_dispose_mapping(irq);\n\t}\n\tirq_domain_remove(bus->irq_domain);\nerr_irq_domain:\n\treturn err;\n}\n\nstatic void ssb_gpio_irq_chipco_domain_exit(struct ssb_bus *bus)\n{\n\tstruct ssb_chipcommon *chipco = &bus->chipco;\n\tstruct gpio_chip *chip = &bus->gpio;\n\tint gpio;\n\n\tif (bus->bustype != SSB_BUSTYPE_SSB)\n\t\treturn;\n\n\tchipco_mask32(chipco, SSB_CHIPCO_IRQMASK, ~SSB_CHIPCO_IRQ_GPIO);\n\tfree_irq(ssb_mips_irq(bus->chipco.dev) + 2, chipco);\n\tfor (gpio = 0; gpio < chip->ngpio; gpio++) {\n\t\tint irq = irq_find_mapping(bus->irq_domain, gpio);\n\n\t\tirq_dispose_mapping(irq);\n\t}\n\tirq_domain_remove(bus->irq_domain);\n}\n#else\nstatic int ssb_gpio_irq_chipco_domain_init(struct ssb_bus *bus)\n{\n\treturn 0;\n}\n\nstatic void ssb_gpio_irq_chipco_domain_exit(struct ssb_bus *bus)\n{\n}\n#endif\n\nstatic int ssb_gpio_chipco_init(struct ssb_bus *bus)\n{\n\tstruct gpio_chip *chip = &bus->gpio;\n\tint err;\n\n\tchip->label\t\t= \"ssb_chipco_gpio\";\n\tchip->owner\t\t= THIS_MODULE;\n\tchip->request\t\t= ssb_gpio_chipco_request;\n\tchip->free\t\t= ssb_gpio_chipco_free;\n\tchip->get\t\t= ssb_gpio_chipco_get_value;\n\tchip->set\t\t= ssb_gpio_chipco_set_value;\n\tchip->direction_input\t= ssb_gpio_chipco_direction_input;\n\tchip->direction_output\t= ssb_gpio_chipco_direction_output;\n#if IS_ENABLED(CONFIG_SSB_EMBEDDED)\n\tchip->to_irq\t\t= ssb_gpio_to_irq;\n#endif\n\tchip->ngpio\t\t= 16;\n\t \n\tif (bus->bustype == SSB_BUSTYPE_SSB)\n\t\tchip->base\t\t= 0;\n\telse\n\t\tchip->base\t\t= -1;\n\n\terr = ssb_gpio_irq_chipco_domain_init(bus);\n\tif (err)\n\t\treturn err;\n\n\terr = gpiochip_add_data(chip, bus);\n\tif (err) {\n\t\tssb_gpio_irq_chipco_domain_exit(bus);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_SSB_DRIVER_EXTIF\n\nstatic int ssb_gpio_extif_get_value(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\treturn !!ssb_extif_gpio_in(&bus->extif, 1 << gpio);\n}\n\nstatic void ssb_gpio_extif_set_value(struct gpio_chip *chip, unsigned int gpio,\n\t\t\t\t     int value)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\tssb_extif_gpio_out(&bus->extif, 1 << gpio, value ? 1 << gpio : 0);\n}\n\nstatic int ssb_gpio_extif_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned int gpio)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\tssb_extif_gpio_outen(&bus->extif, 1 << gpio, 0);\n\treturn 0;\n}\n\nstatic int ssb_gpio_extif_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned int gpio, int value)\n{\n\tstruct ssb_bus *bus = gpiochip_get_data(chip);\n\n\tssb_extif_gpio_outen(&bus->extif, 1 << gpio, 1 << gpio);\n\tssb_extif_gpio_out(&bus->extif, 1 << gpio, value ? 1 << gpio : 0);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SSB_EMBEDDED)\nstatic void ssb_gpio_irq_extif_mask(struct irq_data *d)\n{\n\tstruct ssb_bus *bus = irq_data_get_irq_chip_data(d);\n\tint gpio = irqd_to_hwirq(d);\n\n\tssb_extif_gpio_intmask(&bus->extif, BIT(gpio), 0);\n}\n\nstatic void ssb_gpio_irq_extif_unmask(struct irq_data *d)\n{\n\tstruct ssb_bus *bus = irq_data_get_irq_chip_data(d);\n\tint gpio = irqd_to_hwirq(d);\n\tu32 val = ssb_extif_gpio_in(&bus->extif, BIT(gpio));\n\n\tssb_extif_gpio_polarity(&bus->extif, BIT(gpio), val);\n\tssb_extif_gpio_intmask(&bus->extif, BIT(gpio), BIT(gpio));\n}\n\nstatic struct irq_chip ssb_gpio_irq_extif_chip = {\n\t.name\t\t= \"SSB-GPIO-EXTIF\",\n\t.irq_mask\t= ssb_gpio_irq_extif_mask,\n\t.irq_unmask\t= ssb_gpio_irq_extif_unmask,\n};\n\nstatic irqreturn_t ssb_gpio_irq_extif_handler(int irq, void *dev_id)\n{\n\tstruct ssb_bus *bus = dev_id;\n\tstruct ssb_extif *extif = &bus->extif;\n\tu32 val = ssb_read32(extif->dev, SSB_EXTIF_GPIO_IN);\n\tu32 mask = ssb_read32(extif->dev, SSB_EXTIF_GPIO_INTMASK);\n\tu32 pol = ssb_read32(extif->dev, SSB_EXTIF_GPIO_INTPOL);\n\tunsigned long irqs = (val ^ pol) & mask;\n\tint gpio;\n\n\tif (!irqs)\n\t\treturn IRQ_NONE;\n\n\tfor_each_set_bit(gpio, &irqs, bus->gpio.ngpio)\n\t\tgeneric_handle_domain_irq_safe(bus->irq_domain, gpio);\n\n\tssb_extif_gpio_polarity(extif, irqs, val & irqs);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ssb_gpio_irq_extif_domain_init(struct ssb_bus *bus)\n{\n\tstruct ssb_extif *extif = &bus->extif;\n\tstruct gpio_chip *chip = &bus->gpio;\n\tint gpio, hwirq, err;\n\n\tif (bus->bustype != SSB_BUSTYPE_SSB)\n\t\treturn 0;\n\n\tbus->irq_domain = irq_domain_add_linear(NULL, chip->ngpio,\n\t\t\t\t\t\t&irq_domain_simple_ops, extif);\n\tif (!bus->irq_domain) {\n\t\terr = -ENODEV;\n\t\tgoto err_irq_domain;\n\t}\n\tfor (gpio = 0; gpio < chip->ngpio; gpio++) {\n\t\tint irq = irq_create_mapping(bus->irq_domain, gpio);\n\n\t\tirq_set_chip_data(irq, bus);\n\t\tirq_set_chip_and_handler(irq, &ssb_gpio_irq_extif_chip,\n\t\t\t\t\t handle_simple_irq);\n\t}\n\n\thwirq = ssb_mips_irq(bus->extif.dev) + 2;\n\terr = request_irq(hwirq, ssb_gpio_irq_extif_handler, IRQF_SHARED,\n\t\t\t  \"gpio\", bus);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\tssb_extif_gpio_intmask(&bus->extif, ~0, 0);\n\n\treturn 0;\n\nerr_req_irq:\n\tfor (gpio = 0; gpio < chip->ngpio; gpio++) {\n\t\tint irq = irq_find_mapping(bus->irq_domain, gpio);\n\n\t\tirq_dispose_mapping(irq);\n\t}\n\tirq_domain_remove(bus->irq_domain);\nerr_irq_domain:\n\treturn err;\n}\n\nstatic void ssb_gpio_irq_extif_domain_exit(struct ssb_bus *bus)\n{\n\tstruct ssb_extif *extif = &bus->extif;\n\tstruct gpio_chip *chip = &bus->gpio;\n\tint gpio;\n\n\tif (bus->bustype != SSB_BUSTYPE_SSB)\n\t\treturn;\n\n\tfree_irq(ssb_mips_irq(bus->extif.dev) + 2, extif);\n\tfor (gpio = 0; gpio < chip->ngpio; gpio++) {\n\t\tint irq = irq_find_mapping(bus->irq_domain, gpio);\n\n\t\tirq_dispose_mapping(irq);\n\t}\n\tirq_domain_remove(bus->irq_domain);\n}\n#else\nstatic int ssb_gpio_irq_extif_domain_init(struct ssb_bus *bus)\n{\n\treturn 0;\n}\n\nstatic void ssb_gpio_irq_extif_domain_exit(struct ssb_bus *bus)\n{\n}\n#endif\n\nstatic int ssb_gpio_extif_init(struct ssb_bus *bus)\n{\n\tstruct gpio_chip *chip = &bus->gpio;\n\tint err;\n\n\tchip->label\t\t= \"ssb_extif_gpio\";\n\tchip->owner\t\t= THIS_MODULE;\n\tchip->get\t\t= ssb_gpio_extif_get_value;\n\tchip->set\t\t= ssb_gpio_extif_set_value;\n\tchip->direction_input\t= ssb_gpio_extif_direction_input;\n\tchip->direction_output\t= ssb_gpio_extif_direction_output;\n#if IS_ENABLED(CONFIG_SSB_EMBEDDED)\n\tchip->to_irq\t\t= ssb_gpio_to_irq;\n#endif\n\tchip->ngpio\t\t= 5;\n\t \n\tif (bus->bustype == SSB_BUSTYPE_SSB)\n\t\tchip->base\t\t= 0;\n\telse\n\t\tchip->base\t\t= -1;\n\n\terr = ssb_gpio_irq_extif_domain_init(bus);\n\tif (err)\n\t\treturn err;\n\n\terr = gpiochip_add_data(chip, bus);\n\tif (err) {\n\t\tssb_gpio_irq_extif_domain_exit(bus);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#else\nstatic int ssb_gpio_extif_init(struct ssb_bus *bus)\n{\n\treturn -ENOTSUPP;\n}\n#endif\n\n \n\nint ssb_gpio_init(struct ssb_bus *bus)\n{\n\tif (ssb_chipco_available(&bus->chipco))\n\t\treturn ssb_gpio_chipco_init(bus);\n\telse if (ssb_extif_available(&bus->extif))\n\t\treturn ssb_gpio_extif_init(bus);\n\treturn -1;\n}\n\nint ssb_gpio_unregister(struct ssb_bus *bus)\n{\n\tif (ssb_chipco_available(&bus->chipco) ||\n\t    ssb_extif_available(&bus->extif)) {\n\t\tgpiochip_remove(&bus->gpio);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}