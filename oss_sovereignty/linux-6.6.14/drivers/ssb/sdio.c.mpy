{
  "module_name": "sdio.c",
  "hash_id": "12a6b26ce57c306578b8adb7a7fb8009571f9b7fb858572d8ad58a09210e70b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/sdio.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/ssb/ssb.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/etherdevice.h>\n#include <linux/mmc/sdio_func.h>\n\n \n#define SSB_VERBOSE_SDIOCORESWITCH_DEBUG\t\t0\n\n\n \n#define SSB_SDIO_CIS\t\t\t0x80\n#define  SSB_SDIO_CIS_SROMREV\t\t0x00\n#define  SSB_SDIO_CIS_ID\t\t0x01\n#define  SSB_SDIO_CIS_BOARDREV\t\t0x02\n#define  SSB_SDIO_CIS_PA\t\t0x03\n#define   SSB_SDIO_CIS_PA_PA0B0_LO\t0\n#define   SSB_SDIO_CIS_PA_PA0B0_HI\t1\n#define   SSB_SDIO_CIS_PA_PA0B1_LO\t2\n#define   SSB_SDIO_CIS_PA_PA0B1_HI\t3\n#define   SSB_SDIO_CIS_PA_PA0B2_LO\t4\n#define   SSB_SDIO_CIS_PA_PA0B2_HI\t5\n#define   SSB_SDIO_CIS_PA_ITSSI\t\t6\n#define   SSB_SDIO_CIS_PA_MAXPOW\t7\n#define  SSB_SDIO_CIS_OEMNAME\t\t0x04\n#define  SSB_SDIO_CIS_CCODE\t\t0x05\n#define  SSB_SDIO_CIS_ANTENNA\t\t0x06\n#define  SSB_SDIO_CIS_ANTGAIN\t\t0x07\n#define  SSB_SDIO_CIS_BFLAGS\t\t0x08\n#define  SSB_SDIO_CIS_LEDS\t\t0x09\n\n#define CISTPL_FUNCE_LAN_NODE_ID        0x04\t \n\n\n \n#define SBSDIO_FUNC1_SBADDRLOW\t0x1000a\t \n#define SBSDIO_FUNC1_SBADDRMID\t0x1000b\t \n#define SBSDIO_FUNC1_SBADDRHIGH\t0x1000c\t \n\n \n#define SBSDIO_SBADDRLOW_MASK\t0x80\t \n#define SBSDIO_SBADDRMID_MASK\t0xff\t \n#define SBSDIO_SBADDRHIGH_MASK\t0xff\t \n\n#define SBSDIO_SB_OFT_ADDR_MASK\t0x7FFF\t \n\n \n#define SBSDIO_SB_ACCESS_2_4B_FLAG\t0x8000\t \n\n\n \n\n\n \n\nstatic inline struct device *ssb_sdio_dev(struct ssb_bus *bus)\n{\n\treturn &bus->host_sdio->dev;\n}\n\n \nstatic int ssb_sdio_writeb(struct ssb_bus *bus, unsigned int addr, u8 val)\n{\n\tint error = 0;\n\n\tsdio_writeb(bus->host_sdio, val, addr, &error);\n\tif (unlikely(error)) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%08X <- %02x, error %d\\n\",\n\t\t\taddr, val, error);\n\t}\n\n\treturn error;\n}\n\n#if 0\nstatic u8 ssb_sdio_readb(struct ssb_bus *bus, unsigned int addr)\n{\n\tu8 val;\n\tint error = 0;\n\n\tval = sdio_readb(bus->host_sdio, addr, &error);\n\tif (unlikely(error)) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%08X -> %02x, error %d\\n\",\n\t\t\taddr, val, error);\n\t}\n\n\treturn val;\n}\n#endif\n\n \nstatic int ssb_sdio_set_sbaddr_window(struct ssb_bus *bus, u32 address)\n{\n\tint error;\n\n\terror = ssb_sdio_writeb(bus, SBSDIO_FUNC1_SBADDRLOW,\n\t\t\t\t(address >> 8) & SBSDIO_SBADDRLOW_MASK);\n\tif (error)\n\t\tgoto out;\n\terror = ssb_sdio_writeb(bus, SBSDIO_FUNC1_SBADDRMID,\n\t\t\t\t(address >> 16) & SBSDIO_SBADDRMID_MASK);\n\tif (error)\n\t\tgoto out;\n\terror = ssb_sdio_writeb(bus, SBSDIO_FUNC1_SBADDRHIGH,\n\t\t\t\t(address >> 24) & SBSDIO_SBADDRHIGH_MASK);\n\tif (error)\n\t\tgoto out;\n\tbus->sdio_sbaddr = address;\nout:\n\tif (error) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"failed to set address window\"\n\t\t\t\" to 0x%08x, error %d\\n\", address, error);\n\t}\n\n\treturn error;\n}\n\n \nu32 ssb_sdio_scan_read32(struct ssb_bus *bus, u16 offset)\n{\n\tu32 val;\n\tint error;\n\n\tsdio_claim_host(bus->host_sdio);\n\tval = sdio_readl(bus->host_sdio, offset, &error);\n\tsdio_release_host(bus->host_sdio);\n\tif (unlikely(error)) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X > %08x, error %d\\n\",\n\t\t\tbus->sdio_sbaddr >> 16, offset, val, error);\n\t}\n\n\treturn val;\n}\n\n \nint ssb_sdio_scan_switch_coreidx(struct ssb_bus *bus, u8 coreidx)\n{\n\tu32 sbaddr;\n\tint error;\n\n\tsbaddr = (coreidx * SSB_CORE_SIZE) + SSB_ENUM_BASE;\n\tsdio_claim_host(bus->host_sdio);\n\terror = ssb_sdio_set_sbaddr_window(bus, sbaddr);\n\tsdio_release_host(bus->host_sdio);\n\tif (error) {\n\t\tdev_err(ssb_sdio_dev(bus), \"failed to switch to core %u,\"\n\t\t\t\" error %d\\n\", coreidx, error);\n\t\tgoto out;\n\t}\nout:\n\treturn error;\n}\n\n \nstatic int ssb_sdio_switch_core(struct ssb_bus *bus, struct ssb_device *dev)\n{\n\tu8 coreidx = dev->core_index;\n\tu32 sbaddr;\n\tint error = 0;\n\n\tsbaddr = (coreidx * SSB_CORE_SIZE) + SSB_ENUM_BASE;\n\tif (unlikely(bus->sdio_sbaddr != sbaddr)) {\n#if SSB_VERBOSE_SDIOCORESWITCH_DEBUG\n\t\tdev_info(ssb_sdio_dev(bus),\n\t\t\t   \"switching to %s core, index %d\\n\",\n\t\t\t   ssb_core_name(dev->id.coreid), coreidx);\n#endif\n\t\terror = ssb_sdio_set_sbaddr_window(bus, sbaddr);\n\t\tif (error) {\n\t\t\tdev_dbg(ssb_sdio_dev(bus), \"failed to switch to\"\n\t\t\t\t\" core %u, error %d\\n\", coreidx, error);\n\t\t\tgoto out;\n\t\t}\n\t\tbus->mapped_device = dev;\n\t}\n\nout:\n\treturn error;\n}\n\nstatic u8 ssb_sdio_read8(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tu8 val = 0xff;\n\tint error = 0;\n\n\tsdio_claim_host(bus->host_sdio);\n\tif (unlikely(ssb_sdio_switch_core(bus, dev)))\n\t\tgoto out;\n\toffset |= bus->sdio_sbaddr & 0xffff;\n\toffset &= SBSDIO_SB_OFT_ADDR_MASK;\n\tval = sdio_readb(bus->host_sdio, offset, &error);\n\tif (error) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X > %02x, error %d\\n\",\n\t\t\tbus->sdio_sbaddr >> 16, offset, val, error);\n\t}\nout:\n\tsdio_release_host(bus->host_sdio);\n\n\treturn val;\n}\n\nstatic u16 ssb_sdio_read16(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tu16 val = 0xffff;\n\tint error = 0;\n\n\tsdio_claim_host(bus->host_sdio);\n\tif (unlikely(ssb_sdio_switch_core(bus, dev)))\n\t\tgoto out;\n\toffset |= bus->sdio_sbaddr & 0xffff;\n\toffset &= SBSDIO_SB_OFT_ADDR_MASK;\n\tval = sdio_readw(bus->host_sdio, offset, &error);\n\tif (error) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X > %04x, error %d\\n\",\n\t\t\tbus->sdio_sbaddr >> 16, offset, val, error);\n\t}\nout:\n\tsdio_release_host(bus->host_sdio);\n\n\treturn val;\n}\n\nstatic u32 ssb_sdio_read32(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tu32 val = 0xffffffff;\n\tint error = 0;\n\n\tsdio_claim_host(bus->host_sdio);\n\tif (unlikely(ssb_sdio_switch_core(bus, dev)))\n\t\tgoto out;\n\toffset |= bus->sdio_sbaddr & 0xffff;\n\toffset &= SBSDIO_SB_OFT_ADDR_MASK;\n\toffset |= SBSDIO_SB_ACCESS_2_4B_FLAG;\t \n\tval = sdio_readl(bus->host_sdio, offset, &error);\n\tif (error) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X > %08x, error %d\\n\",\n\t\t\tbus->sdio_sbaddr >> 16, offset, val, error);\n\t}\nout:\n\tsdio_release_host(bus->host_sdio);\n\n\treturn val;\n}\n\n#ifdef CONFIG_SSB_BLOCKIO\nstatic void ssb_sdio_block_read(struct ssb_device *dev, void *buffer,\n\t\t\t\t  size_t count, u16 offset, u8 reg_width)\n{\n\tsize_t saved_count = count;\n\tstruct ssb_bus *bus = dev->bus;\n\tint error = 0;\n\n\tsdio_claim_host(bus->host_sdio);\n\tif (unlikely(ssb_sdio_switch_core(bus, dev))) {\n\t\terror = -EIO;\n\t\tmemset(buffer, 0xff, count);\n\t\tgoto err_out;\n\t}\n\toffset |= bus->sdio_sbaddr & 0xffff;\n\toffset &= SBSDIO_SB_OFT_ADDR_MASK;\n\n\tswitch (reg_width) {\n\tcase sizeof(u8): {\n\t\terror = sdio_readsb(bus->host_sdio, buffer, offset, count);\n\t\tbreak;\n\t}\n\tcase sizeof(u16): {\n\t\tWARN_ON(count & 1);\n\t\terror = sdio_readsb(bus->host_sdio, buffer, offset, count);\n\t\tbreak;\n\t}\n\tcase sizeof(u32): {\n\t\tWARN_ON(count & 3);\n\t\toffset |= SBSDIO_SB_ACCESS_2_4B_FLAG;\t \n\t\terror = sdio_readsb(bus->host_sdio, buffer, offset, count);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\tif (!error)\n\t\tgoto out;\n\nerr_out:\n\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X (width=%u, len=%zu), error %d\\n\",\n\t\tbus->sdio_sbaddr >> 16, offset, reg_width, saved_count, error);\nout:\n\tsdio_release_host(bus->host_sdio);\n}\n#endif  \n\nstatic void ssb_sdio_write8(struct ssb_device *dev, u16 offset, u8 val)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tint error = 0;\n\n\tsdio_claim_host(bus->host_sdio);\n\tif (unlikely(ssb_sdio_switch_core(bus, dev)))\n\t\tgoto out;\n\toffset |= bus->sdio_sbaddr & 0xffff;\n\toffset &= SBSDIO_SB_OFT_ADDR_MASK;\n\tsdio_writeb(bus->host_sdio, val, offset, &error);\n\tif (error) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X < %02x, error %d\\n\",\n\t\t\tbus->sdio_sbaddr >> 16, offset, val, error);\n\t}\nout:\n\tsdio_release_host(bus->host_sdio);\n}\n\nstatic void ssb_sdio_write16(struct ssb_device *dev, u16 offset, u16 val)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tint error = 0;\n\n\tsdio_claim_host(bus->host_sdio);\n\tif (unlikely(ssb_sdio_switch_core(bus, dev)))\n\t\tgoto out;\n\toffset |= bus->sdio_sbaddr & 0xffff;\n\toffset &= SBSDIO_SB_OFT_ADDR_MASK;\n\tsdio_writew(bus->host_sdio, val, offset, &error);\n\tif (error) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X < %04x, error %d\\n\",\n\t\t\tbus->sdio_sbaddr >> 16, offset, val, error);\n\t}\nout:\n\tsdio_release_host(bus->host_sdio);\n}\n\nstatic void ssb_sdio_write32(struct ssb_device *dev, u16 offset, u32 val)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tint error = 0;\n\n\tsdio_claim_host(bus->host_sdio);\n\tif (unlikely(ssb_sdio_switch_core(bus, dev)))\n\t\tgoto out;\n\toffset |= bus->sdio_sbaddr & 0xffff;\n\toffset &= SBSDIO_SB_OFT_ADDR_MASK;\n\toffset |= SBSDIO_SB_ACCESS_2_4B_FLAG;\t \n\tsdio_writel(bus->host_sdio, val, offset, &error);\n\tif (error) {\n\t\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X < %08x, error %d\\n\",\n\t\t\tbus->sdio_sbaddr >> 16, offset, val, error);\n\t}\n\tif (bus->quirks & SSB_QUIRK_SDIO_READ_AFTER_WRITE32)\n\t\tsdio_readl(bus->host_sdio, 0, &error);\nout:\n\tsdio_release_host(bus->host_sdio);\n}\n\n#ifdef CONFIG_SSB_BLOCKIO\nstatic void ssb_sdio_block_write(struct ssb_device *dev, const void *buffer,\n\t\t\t\t   size_t count, u16 offset, u8 reg_width)\n{\n\tsize_t saved_count = count;\n\tstruct ssb_bus *bus = dev->bus;\n\tint error = 0;\n\n\tsdio_claim_host(bus->host_sdio);\n\tif (unlikely(ssb_sdio_switch_core(bus, dev))) {\n\t\terror = -EIO;\n\t\tgoto err_out;\n\t}\n\toffset |= bus->sdio_sbaddr & 0xffff;\n\toffset &= SBSDIO_SB_OFT_ADDR_MASK;\n\n\tswitch (reg_width) {\n\tcase sizeof(u8):\n\t\terror = sdio_writesb(bus->host_sdio, offset,\n\t\t\t\t     (void *)buffer, count);\n\t\tbreak;\n\tcase sizeof(u16):\n\t\tWARN_ON(count & 1);\n\t\terror = sdio_writesb(bus->host_sdio, offset,\n\t\t\t\t     (void *)buffer, count);\n\t\tbreak;\n\tcase sizeof(u32):\n\t\tWARN_ON(count & 3);\n\t\toffset |= SBSDIO_SB_ACCESS_2_4B_FLAG;\t \n\t\terror = sdio_writesb(bus->host_sdio, offset,\n\t\t\t\t     (void *)buffer, count);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\tif (!error)\n\t\tgoto out;\n\nerr_out:\n\tdev_dbg(ssb_sdio_dev(bus), \"%04X:%04X (width=%u, len=%zu), error %d\\n\",\n\t\tbus->sdio_sbaddr >> 16, offset, reg_width, saved_count, error);\nout:\n\tsdio_release_host(bus->host_sdio);\n}\n\n#endif  \n\n \nconst struct ssb_bus_ops ssb_sdio_ops = {\n\t.read8\t\t= ssb_sdio_read8,\n\t.read16\t\t= ssb_sdio_read16,\n\t.read32\t\t= ssb_sdio_read32,\n\t.write8\t\t= ssb_sdio_write8,\n\t.write16\t= ssb_sdio_write16,\n\t.write32\t= ssb_sdio_write32,\n#ifdef CONFIG_SSB_BLOCKIO\n\t.block_read\t= ssb_sdio_block_read,\n\t.block_write\t= ssb_sdio_block_write,\n#endif\n};\n\n#define GOTO_ERROR_ON(condition, description) do {\t\\\n\tif (unlikely(condition)) {\t\t\t\\\n\t\terror_description = description;\t\\\n\t\tgoto error;\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n  } while (0)\n\nint ssb_sdio_get_invariants(struct ssb_bus *bus,\n\t\t\t    struct ssb_init_invariants *iv)\n{\n\tstruct ssb_sprom *sprom = &iv->sprom;\n\tstruct ssb_boardinfo *bi = &iv->boardinfo;\n\tconst char *error_description = \"none\";\n\tstruct sdio_func_tuple *tuple;\n\tvoid *mac;\n\n\tmemset(sprom, 0xFF, sizeof(*sprom));\n\tsprom->boardflags_lo = 0;\n\tsprom->boardflags_hi = 0;\n\n\ttuple = bus->host_sdio->tuples;\n\twhile (tuple) {\n\t\tswitch (tuple->code) {\n\t\tcase 0x22:  \n\t\t\tswitch (tuple->data[0]) {\n\t\t\tcase CISTPL_FUNCE_LAN_NODE_ID:\n\t\t\t\tGOTO_ERROR_ON((tuple->size != 7) &&\n\t\t\t\t\t      (tuple->data[1] != 6),\n\t\t\t\t\t      \"mac tpl size\");\n\t\t\t\t \n\t\t\t\tmac = tuple->data + 2;\n\t\t\t\tmemcpy(sprom->il0mac, mac, ETH_ALEN);\n\t\t\t\tmemcpy(sprom->et1mac, mac, ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x80:  \n\t\t\tswitch (tuple->data[0]) {\n\t\t\tcase SSB_SDIO_CIS_SROMREV:\n\t\t\t\tGOTO_ERROR_ON(tuple->size != 2,\n\t\t\t\t\t      \"sromrev tpl size\");\n\t\t\t\tsprom->revision = tuple->data[1];\n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_ID:\n\t\t\t\tGOTO_ERROR_ON((tuple->size != 5) &&\n\t\t\t\t\t      (tuple->size != 7),\n\t\t\t\t\t      \"id tpl size\");\n\t\t\t\tbi->vendor = tuple->data[1] |\n\t\t\t\t\t     (tuple->data[2]<<8);\n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_BOARDREV:\n\t\t\t\tGOTO_ERROR_ON(tuple->size != 2,\n\t\t\t\t\t      \"boardrev tpl size\");\n\t\t\t\tsprom->board_rev = tuple->data[1];\n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_PA:\n\t\t\t\tGOTO_ERROR_ON((tuple->size != 9) &&\n\t\t\t\t\t      (tuple->size != 10),\n\t\t\t\t\t      \"pa tpl size\");\n\t\t\t\tsprom->pa0b0 = tuple->data[1] |\n\t\t\t\t\t ((u16)tuple->data[2] << 8);\n\t\t\t\tsprom->pa0b1 = tuple->data[3] |\n\t\t\t\t\t ((u16)tuple->data[4] << 8);\n\t\t\t\tsprom->pa0b2 = tuple->data[5] |\n\t\t\t\t\t ((u16)tuple->data[6] << 8);\n\t\t\t\tsprom->itssi_a = tuple->data[7];\n\t\t\t\tsprom->itssi_bg = tuple->data[7];\n\t\t\t\tsprom->maxpwr_a = tuple->data[8];\n\t\t\t\tsprom->maxpwr_bg = tuple->data[8];\n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_OEMNAME:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_CCODE:\n\t\t\t\tGOTO_ERROR_ON(tuple->size != 2,\n\t\t\t\t\t      \"ccode tpl size\");\n\t\t\t\tsprom->country_code = tuple->data[1];\n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_ANTENNA:\n\t\t\t\tGOTO_ERROR_ON(tuple->size != 2,\n\t\t\t\t\t      \"ant tpl size\");\n\t\t\t\tsprom->ant_available_a = tuple->data[1];\n\t\t\t\tsprom->ant_available_bg = tuple->data[1];\n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_ANTGAIN:\n\t\t\t\tGOTO_ERROR_ON(tuple->size != 2,\n\t\t\t\t\t      \"antg tpl size\");\n\t\t\t\tsprom->antenna_gain.a0 = tuple->data[1];\n\t\t\t\tsprom->antenna_gain.a1 = tuple->data[1];\n\t\t\t\tsprom->antenna_gain.a2 = tuple->data[1];\n\t\t\t\tsprom->antenna_gain.a3 = tuple->data[1];\n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_BFLAGS:\n\t\t\t\tGOTO_ERROR_ON((tuple->size != 3) &&\n\t\t\t\t\t      (tuple->size != 5),\n\t\t\t\t\t      \"bfl tpl size\");\n\t\t\t\tsprom->boardflags_lo = tuple->data[1] |\n\t\t\t\t\t\t ((u16)tuple->data[2] << 8);\n\t\t\t\tbreak;\n\t\t\tcase SSB_SDIO_CIS_LEDS:\n\t\t\t\tGOTO_ERROR_ON(tuple->size != 5,\n\t\t\t\t\t      \"leds tpl size\");\n\t\t\t\tsprom->gpio0 = tuple->data[1];\n\t\t\t\tsprom->gpio1 = tuple->data[2];\n\t\t\t\tsprom->gpio2 = tuple->data[3];\n\t\t\t\tsprom->gpio3 = tuple->data[4];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttuple = tuple->next;\n\t}\n\n\treturn 0;\nerror:\n\tdev_err(ssb_sdio_dev(bus), \"failed to fetch device invariants: %s\\n\",\n\t\terror_description);\n\treturn -ENODEV;\n}\n\nvoid ssb_sdio_exit(struct ssb_bus *bus)\n{\n\tif (bus->bustype != SSB_BUSTYPE_SDIO)\n\t\treturn;\n\t \n}\n\nint ssb_sdio_init(struct ssb_bus *bus)\n{\n\tif (bus->bustype != SSB_BUSTYPE_SDIO)\n\t\treturn 0;\n\n\tbus->sdio_sbaddr = ~0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}