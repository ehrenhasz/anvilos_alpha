{
  "module_name": "driver_chipcommon_pmu.c",
  "hash_id": "2a1d2373f28219858ccae89d9239ad9de3318d2232f1452168cccfa7bcca239f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/driver_chipcommon_pmu.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/ssb/ssb.h>\n#include <linux/ssb/ssb_regs.h>\n#include <linux/ssb/ssb_driver_chipcommon.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#ifdef CONFIG_BCM47XX\n#include <linux/bcm47xx_nvram.h>\n#endif\n\nstatic u32 ssb_chipco_pll_read(struct ssb_chipcommon *cc, u32 offset)\n{\n\tchipco_write32(cc, SSB_CHIPCO_PLLCTL_ADDR, offset);\n\treturn chipco_read32(cc, SSB_CHIPCO_PLLCTL_DATA);\n}\n\nstatic void ssb_chipco_pll_write(struct ssb_chipcommon *cc,\n\t\t\t\t u32 offset, u32 value)\n{\n\tchipco_write32(cc, SSB_CHIPCO_PLLCTL_ADDR, offset);\n\tchipco_write32(cc, SSB_CHIPCO_PLLCTL_DATA, value);\n}\n\nstatic void ssb_chipco_regctl_maskset(struct ssb_chipcommon *cc,\n\t\t\t\t   u32 offset, u32 mask, u32 set)\n{\n\tu32 value;\n\n\tchipco_read32(cc, SSB_CHIPCO_REGCTL_ADDR);\n\tchipco_write32(cc, SSB_CHIPCO_REGCTL_ADDR, offset);\n\tchipco_read32(cc, SSB_CHIPCO_REGCTL_ADDR);\n\tvalue = chipco_read32(cc, SSB_CHIPCO_REGCTL_DATA);\n\tvalue &= mask;\n\tvalue |= set;\n\tchipco_write32(cc, SSB_CHIPCO_REGCTL_DATA, value);\n\tchipco_read32(cc, SSB_CHIPCO_REGCTL_DATA);\n}\n\nstruct pmu0_plltab_entry {\n\tu16 freq;\t \n\tu8 xf;\t\t \n\tu8 wb_int;\n\tu32 wb_frac;\n};\n\nstatic const struct pmu0_plltab_entry pmu0_plltab[] = {\n\t{ .freq = 12000, .xf =  1, .wb_int = 73, .wb_frac = 349525, },\n\t{ .freq = 13000, .xf =  2, .wb_int = 67, .wb_frac = 725937, },\n\t{ .freq = 14400, .xf =  3, .wb_int = 61, .wb_frac = 116508, },\n\t{ .freq = 15360, .xf =  4, .wb_int = 57, .wb_frac = 305834, },\n\t{ .freq = 16200, .xf =  5, .wb_int = 54, .wb_frac = 336579, },\n\t{ .freq = 16800, .xf =  6, .wb_int = 52, .wb_frac = 399457, },\n\t{ .freq = 19200, .xf =  7, .wb_int = 45, .wb_frac = 873813, },\n\t{ .freq = 19800, .xf =  8, .wb_int = 44, .wb_frac = 466033, },\n\t{ .freq = 20000, .xf =  9, .wb_int = 44, .wb_frac = 0,      },\n\t{ .freq = 25000, .xf = 10, .wb_int = 70, .wb_frac = 419430, },\n\t{ .freq = 26000, .xf = 11, .wb_int = 67, .wb_frac = 725937, },\n\t{ .freq = 30000, .xf = 12, .wb_int = 58, .wb_frac = 699050, },\n\t{ .freq = 38400, .xf = 13, .wb_int = 45, .wb_frac = 873813, },\n\t{ .freq = 40000, .xf = 14, .wb_int = 45, .wb_frac = 0,      },\n};\n#define SSB_PMU0_DEFAULT_XTALFREQ\t20000\n\nstatic const struct pmu0_plltab_entry * pmu0_plltab_find_entry(u32 crystalfreq)\n{\n\tconst struct pmu0_plltab_entry *e;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pmu0_plltab); i++) {\n\t\te = &pmu0_plltab[i];\n\t\tif (e->freq == crystalfreq)\n\t\t\treturn e;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void ssb_pmu0_pllinit_r0(struct ssb_chipcommon *cc,\n\t\t\t\tu32 crystalfreq)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\tconst struct pmu0_plltab_entry *e = NULL;\n\tu32 pmuctl, tmp, pllctl;\n\tunsigned int i;\n\n\tif (crystalfreq)\n\t\te = pmu0_plltab_find_entry(crystalfreq);\n\tif (!e)\n\t\te = pmu0_plltab_find_entry(SSB_PMU0_DEFAULT_XTALFREQ);\n\tBUG_ON(!e);\n\tcrystalfreq = e->freq;\n\tcc->pmu.crystalfreq = e->freq;\n\n\t \n\tpmuctl = chipco_read32(cc, SSB_CHIPCO_PMU_CTL);\n\tif (((pmuctl & SSB_CHIPCO_PMU_CTL_XTALFREQ) >> SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT) == e->xf) {\n\t\t \n\t\treturn;\n\t}\n\n\tdev_info(cc->dev->dev, \"Programming PLL to %u.%03u MHz\\n\",\n\t\t crystalfreq / 1000, crystalfreq % 1000);\n\n\t \n\tswitch (bus->chip_id) {\n\tcase 0x4328:\n\t\tchipco_mask32(cc, SSB_CHIPCO_PMU_MINRES_MSK,\n\t\t\t      ~(1 << SSB_PMURES_4328_BB_PLL_PU));\n\t\tchipco_mask32(cc, SSB_CHIPCO_PMU_MAXRES_MSK,\n\t\t\t      ~(1 << SSB_PMURES_4328_BB_PLL_PU));\n\t\tbreak;\n\tcase 0x5354:\n\t\tchipco_mask32(cc, SSB_CHIPCO_PMU_MINRES_MSK,\n\t\t\t      ~(1 << SSB_PMURES_5354_BB_PLL_PU));\n\t\tchipco_mask32(cc, SSB_CHIPCO_PMU_MAXRES_MSK,\n\t\t\t      ~(1 << SSB_PMURES_5354_BB_PLL_PU));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\tfor (i = 1500; i; i--) {\n\t\ttmp = chipco_read32(cc, SSB_CHIPCO_CLKCTLST);\n\t\tif (!(tmp & SSB_CHIPCO_CLKCTLST_HAVEHT))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\ttmp = chipco_read32(cc, SSB_CHIPCO_CLKCTLST);\n\tif (tmp & SSB_CHIPCO_CLKCTLST_HAVEHT)\n\t\tdev_emerg(cc->dev->dev, \"Failed to turn the PLL off!\\n\");\n\n\t \n\tpllctl = ssb_chipco_pll_read(cc, SSB_PMU0_PLLCTL0);\n\tif (crystalfreq >= SSB_PMU0_PLLCTL0_PDIV_FREQ)\n\t\tpllctl |= SSB_PMU0_PLLCTL0_PDIV_MSK;\n\telse\n\t\tpllctl &= ~SSB_PMU0_PLLCTL0_PDIV_MSK;\n\tssb_chipco_pll_write(cc, SSB_PMU0_PLLCTL0, pllctl);\n\n\t \n\tpllctl = ssb_chipco_pll_read(cc, SSB_PMU0_PLLCTL1);\n\tpllctl &= ~SSB_PMU0_PLLCTL1_STOPMOD;\n\tpllctl &= ~(SSB_PMU0_PLLCTL1_WILD_IMSK | SSB_PMU0_PLLCTL1_WILD_FMSK);\n\tpllctl |= ((u32)e->wb_int << SSB_PMU0_PLLCTL1_WILD_IMSK_SHIFT) & SSB_PMU0_PLLCTL1_WILD_IMSK;\n\tpllctl |= ((u32)e->wb_frac << SSB_PMU0_PLLCTL1_WILD_FMSK_SHIFT) & SSB_PMU0_PLLCTL1_WILD_FMSK;\n\tif (e->wb_frac == 0)\n\t\tpllctl |= SSB_PMU0_PLLCTL1_STOPMOD;\n\tssb_chipco_pll_write(cc, SSB_PMU0_PLLCTL1, pllctl);\n\n\t \n\tpllctl = ssb_chipco_pll_read(cc, SSB_PMU0_PLLCTL2);\n\tpllctl &= ~SSB_PMU0_PLLCTL2_WILD_IMSKHI;\n\tpllctl |= (((u32)e->wb_int >> 4) << SSB_PMU0_PLLCTL2_WILD_IMSKHI_SHIFT) & SSB_PMU0_PLLCTL2_WILD_IMSKHI;\n\tssb_chipco_pll_write(cc, SSB_PMU0_PLLCTL2, pllctl);\n\n\t \n\tpmuctl = chipco_read32(cc, SSB_CHIPCO_PMU_CTL);\n\tpmuctl &= ~SSB_CHIPCO_PMU_CTL_ILP_DIV;\n\tpmuctl |= (((crystalfreq + 127) / 128 - 1) << SSB_CHIPCO_PMU_CTL_ILP_DIV_SHIFT)\n\t\t\t& SSB_CHIPCO_PMU_CTL_ILP_DIV;\n\tpmuctl &= ~SSB_CHIPCO_PMU_CTL_XTALFREQ;\n\tpmuctl |= ((u32)e->xf << SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT) & SSB_CHIPCO_PMU_CTL_XTALFREQ;\n\tchipco_write32(cc, SSB_CHIPCO_PMU_CTL, pmuctl);\n}\n\nstruct pmu1_plltab_entry {\n\tu16 freq;\t \n\tu8 xf;\t\t \n\tu8 ndiv_int;\n\tu32 ndiv_frac;\n\tu8 p1div;\n\tu8 p2div;\n};\n\nstatic const struct pmu1_plltab_entry pmu1_plltab[] = {\n\t{ .freq = 12000, .xf =  1, .p1div = 3, .p2div = 22, .ndiv_int =  0x9, .ndiv_frac = 0xFFFFEF, },\n\t{ .freq = 13000, .xf =  2, .p1div = 1, .p2div =  6, .ndiv_int =  0xb, .ndiv_frac = 0x483483, },\n\t{ .freq = 14400, .xf =  3, .p1div = 1, .p2div = 10, .ndiv_int =  0xa, .ndiv_frac = 0x1C71C7, },\n\t{ .freq = 15360, .xf =  4, .p1div = 1, .p2div =  5, .ndiv_int =  0xb, .ndiv_frac = 0x755555, },\n\t{ .freq = 16200, .xf =  5, .p1div = 1, .p2div = 10, .ndiv_int =  0x5, .ndiv_frac = 0x6E9E06, },\n\t{ .freq = 16800, .xf =  6, .p1div = 1, .p2div = 10, .ndiv_int =  0x5, .ndiv_frac = 0x3CF3CF, },\n\t{ .freq = 19200, .xf =  7, .p1div = 1, .p2div =  9, .ndiv_int =  0x5, .ndiv_frac = 0x17B425, },\n\t{ .freq = 19800, .xf =  8, .p1div = 1, .p2div = 11, .ndiv_int =  0x4, .ndiv_frac = 0xA57EB,  },\n\t{ .freq = 20000, .xf =  9, .p1div = 1, .p2div = 11, .ndiv_int =  0x4, .ndiv_frac = 0,        },\n\t{ .freq = 24000, .xf = 10, .p1div = 3, .p2div = 11, .ndiv_int =  0xa, .ndiv_frac = 0,        },\n\t{ .freq = 25000, .xf = 11, .p1div = 5, .p2div = 16, .ndiv_int =  0xb, .ndiv_frac = 0,        },\n\t{ .freq = 26000, .xf = 12, .p1div = 1, .p2div =  2, .ndiv_int = 0x10, .ndiv_frac = 0xEC4EC4, },\n\t{ .freq = 30000, .xf = 13, .p1div = 3, .p2div =  8, .ndiv_int =  0xb, .ndiv_frac = 0,        },\n\t{ .freq = 38400, .xf = 14, .p1div = 1, .p2div =  5, .ndiv_int =  0x4, .ndiv_frac = 0x955555, },\n\t{ .freq = 40000, .xf = 15, .p1div = 1, .p2div =  2, .ndiv_int =  0xb, .ndiv_frac = 0,        },\n};\n\n#define SSB_PMU1_DEFAULT_XTALFREQ\t15360\n\nstatic const struct pmu1_plltab_entry * pmu1_plltab_find_entry(u32 crystalfreq)\n{\n\tconst struct pmu1_plltab_entry *e;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pmu1_plltab); i++) {\n\t\te = &pmu1_plltab[i];\n\t\tif (e->freq == crystalfreq)\n\t\t\treturn e;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void ssb_pmu1_pllinit_r0(struct ssb_chipcommon *cc,\n\t\t\t\tu32 crystalfreq)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\tconst struct pmu1_plltab_entry *e = NULL;\n\tu32 buffer_strength = 0;\n\tu32 tmp, pllctl, pmuctl;\n\tunsigned int i;\n\n\tif (bus->chip_id == 0x4312) {\n\t\t \n\t\tcc->pmu.crystalfreq = 20000;\n\t\treturn;\n\t}\n\n\tif (crystalfreq)\n\t\te = pmu1_plltab_find_entry(crystalfreq);\n\tif (!e)\n\t\te = pmu1_plltab_find_entry(SSB_PMU1_DEFAULT_XTALFREQ);\n\tBUG_ON(!e);\n\tcrystalfreq = e->freq;\n\tcc->pmu.crystalfreq = e->freq;\n\n\t \n\tpmuctl = chipco_read32(cc, SSB_CHIPCO_PMU_CTL);\n\tif (((pmuctl & SSB_CHIPCO_PMU_CTL_XTALFREQ) >> SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT) == e->xf) {\n\t\t \n\t\treturn;\n\t}\n\n\tdev_info(cc->dev->dev, \"Programming PLL to %u.%03u MHz\\n\",\n\t\t crystalfreq / 1000, crystalfreq % 1000);\n\n\t \n\tswitch (bus->chip_id) {\n\tcase 0x4325:\n\t\tchipco_mask32(cc, SSB_CHIPCO_PMU_MINRES_MSK,\n\t\t\t      ~((1 << SSB_PMURES_4325_BBPLL_PWRSW_PU) |\n\t\t\t\t(1 << SSB_PMURES_4325_HT_AVAIL)));\n\t\tchipco_mask32(cc, SSB_CHIPCO_PMU_MAXRES_MSK,\n\t\t\t      ~((1 << SSB_PMURES_4325_BBPLL_PWRSW_PU) |\n\t\t\t\t(1 << SSB_PMURES_4325_HT_AVAIL)));\n\t\t \n\t\tbuffer_strength = 0x222222;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\tfor (i = 1500; i; i--) {\n\t\ttmp = chipco_read32(cc, SSB_CHIPCO_CLKCTLST);\n\t\tif (!(tmp & SSB_CHIPCO_CLKCTLST_HAVEHT))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\ttmp = chipco_read32(cc, SSB_CHIPCO_CLKCTLST);\n\tif (tmp & SSB_CHIPCO_CLKCTLST_HAVEHT)\n\t\tdev_emerg(cc->dev->dev, \"Failed to turn the PLL off!\\n\");\n\n\t \n\tpllctl = ssb_chipco_pll_read(cc, SSB_PMU1_PLLCTL0);\n\tpllctl &= ~(SSB_PMU1_PLLCTL0_P1DIV | SSB_PMU1_PLLCTL0_P2DIV);\n\tpllctl |= ((u32)e->p1div << SSB_PMU1_PLLCTL0_P1DIV_SHIFT) & SSB_PMU1_PLLCTL0_P1DIV;\n\tpllctl |= ((u32)e->p2div << SSB_PMU1_PLLCTL0_P2DIV_SHIFT) & SSB_PMU1_PLLCTL0_P2DIV;\n\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL0, pllctl);\n\n\t \n\tpllctl = ssb_chipco_pll_read(cc, SSB_PMU1_PLLCTL2);\n\tpllctl &= ~(SSB_PMU1_PLLCTL2_NDIVINT | SSB_PMU1_PLLCTL2_NDIVMODE);\n\tpllctl |= ((u32)e->ndiv_int << SSB_PMU1_PLLCTL2_NDIVINT_SHIFT) & SSB_PMU1_PLLCTL2_NDIVINT;\n\tpllctl |= (1 << SSB_PMU1_PLLCTL2_NDIVMODE_SHIFT) & SSB_PMU1_PLLCTL2_NDIVMODE;\n\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL2, pllctl);\n\n\t \n\tpllctl = ssb_chipco_pll_read(cc, SSB_PMU1_PLLCTL3);\n\tpllctl &= ~SSB_PMU1_PLLCTL3_NDIVFRAC;\n\tpllctl |= ((u32)e->ndiv_frac << SSB_PMU1_PLLCTL3_NDIVFRAC_SHIFT) & SSB_PMU1_PLLCTL3_NDIVFRAC;\n\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL3, pllctl);\n\n\t \n\tif (buffer_strength) {\n\t\tpllctl = ssb_chipco_pll_read(cc, SSB_PMU1_PLLCTL5);\n\t\tpllctl &= ~SSB_PMU1_PLLCTL5_CLKDRV;\n\t\tpllctl |= (buffer_strength << SSB_PMU1_PLLCTL5_CLKDRV_SHIFT) & SSB_PMU1_PLLCTL5_CLKDRV;\n\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL5, pllctl);\n\t}\n\n\t \n\tpmuctl = chipco_read32(cc, SSB_CHIPCO_PMU_CTL);\n\tpmuctl &= ~(SSB_CHIPCO_PMU_CTL_ILP_DIV | SSB_CHIPCO_PMU_CTL_XTALFREQ);\n\tpmuctl |= ((((u32)e->freq + 127) / 128 - 1) << SSB_CHIPCO_PMU_CTL_ILP_DIV_SHIFT)\n\t\t\t& SSB_CHIPCO_PMU_CTL_ILP_DIV;\n\tpmuctl |= ((u32)e->xf << SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT) & SSB_CHIPCO_PMU_CTL_XTALFREQ;\n\tchipco_write32(cc, SSB_CHIPCO_PMU_CTL, pmuctl);\n}\n\nstatic void ssb_pmu_pll_init(struct ssb_chipcommon *cc)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\tu32 crystalfreq = 0;  \n\n\tif (bus->bustype == SSB_BUSTYPE_SSB) {\n#ifdef CONFIG_BCM47XX\n\t\tchar buf[20];\n\t\tif (bcm47xx_nvram_getenv(\"xtalfreq\", buf, sizeof(buf)) >= 0)\n\t\t\tcrystalfreq = simple_strtoul(buf, NULL, 0);\n#endif\n\t}\n\n\tswitch (bus->chip_id) {\n\tcase 0x4312:\n\tcase 0x4325:\n\t\tssb_pmu1_pllinit_r0(cc, crystalfreq);\n\t\tbreak;\n\tcase 0x4328:\n\t\tssb_pmu0_pllinit_r0(cc, crystalfreq);\n\t\tbreak;\n\tcase 0x5354:\n\t\tif (crystalfreq == 0)\n\t\t\tcrystalfreq = 25000;\n\t\tssb_pmu0_pllinit_r0(cc, crystalfreq);\n\t\tbreak;\n\tcase 0x4322:\n\t\tif (cc->pmu.rev == 2) {\n\t\t\tchipco_write32(cc, SSB_CHIPCO_PLLCTL_ADDR, 0x0000000A);\n\t\t\tchipco_write32(cc, SSB_CHIPCO_PLLCTL_DATA, 0x380005C0);\n\t\t}\n\t\tbreak;\n\tcase 43222:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cc->dev->dev, \"ERROR: PLL init unknown for device %04X\\n\",\n\t\t\tbus->chip_id);\n\t}\n}\n\nstruct pmu_res_updown_tab_entry {\n\tu8 resource;\t \n\tu16 updown;\t \n};\n\nenum pmu_res_depend_tab_task {\n\tPMU_RES_DEP_SET = 1,\n\tPMU_RES_DEP_ADD,\n\tPMU_RES_DEP_REMOVE,\n};\n\nstruct pmu_res_depend_tab_entry {\n\tu8 resource;\t \n\tu8 task;\t \n\tu32 depend;\t \n};\n\nstatic const struct pmu_res_updown_tab_entry pmu_res_updown_tab_4328a0[] = {\n\t{ .resource = SSB_PMURES_4328_EXT_SWITCHER_PWM,\t\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_BB_SWITCHER_PWM,\t\t.updown = 0x1F01, },\n\t{ .resource = SSB_PMURES_4328_BB_SWITCHER_BURST,\t.updown = 0x010F, },\n\t{ .resource = SSB_PMURES_4328_BB_EXT_SWITCHER_BURST,\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_ILP_REQUEST,\t\t.updown = 0x0202, },\n\t{ .resource = SSB_PMURES_4328_RADIO_SWITCHER_PWM,\t.updown = 0x0F01, },\n\t{ .resource = SSB_PMURES_4328_RADIO_SWITCHER_BURST,\t.updown = 0x0F01, },\n\t{ .resource = SSB_PMURES_4328_ROM_SWITCH,\t\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_PA_REF_LDO,\t\t.updown = 0x0F01, },\n\t{ .resource = SSB_PMURES_4328_RADIO_LDO,\t\t.updown = 0x0F01, },\n\t{ .resource = SSB_PMURES_4328_AFE_LDO,\t\t\t.updown = 0x0F01, },\n\t{ .resource = SSB_PMURES_4328_PLL_LDO,\t\t\t.updown = 0x0F01, },\n\t{ .resource = SSB_PMURES_4328_BG_FILTBYP,\t\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_TX_FILTBYP,\t\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_RX_FILTBYP,\t\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_XTAL_PU,\t\t\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_XTAL_EN,\t\t\t.updown = 0xA001, },\n\t{ .resource = SSB_PMURES_4328_BB_PLL_FILTBYP,\t\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_RF_PLL_FILTBYP,\t\t.updown = 0x0101, },\n\t{ .resource = SSB_PMURES_4328_BB_PLL_PU,\t\t.updown = 0x0701, },\n};\n\nstatic const struct pmu_res_depend_tab_entry pmu_res_depend_tab_4328a0[] = {\n\t{\n\t\t \n\t\t.resource = SSB_PMURES_4328_ILP_REQUEST,\n\t\t.task = PMU_RES_DEP_SET,\n\t\t.depend = ((1 << SSB_PMURES_4328_EXT_SWITCHER_PWM) |\n\t\t\t   (1 << SSB_PMURES_4328_BB_SWITCHER_PWM)),\n\t},\n};\n\nstatic const struct pmu_res_updown_tab_entry pmu_res_updown_tab_4325a0[] = {\n\t{ .resource = SSB_PMURES_4325_XTAL_PU,\t\t\t.updown = 0x1501, },\n};\n\nstatic const struct pmu_res_depend_tab_entry pmu_res_depend_tab_4325a0[] = {\n\t{\n\t\t \n\t\t.resource = SSB_PMURES_4325_HT_AVAIL,\n\t\t.task = PMU_RES_DEP_ADD,\n\t\t.depend = ((1 << SSB_PMURES_4325_RX_PWRSW_PU) |\n\t\t\t   (1 << SSB_PMURES_4325_TX_PWRSW_PU) |\n\t\t\t   (1 << SSB_PMURES_4325_LOGEN_PWRSW_PU) |\n\t\t\t   (1 << SSB_PMURES_4325_AFE_PWRSW_PU)),\n\t},\n};\n\nstatic void ssb_pmu_resources_init(struct ssb_chipcommon *cc)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\tu32 min_msk = 0, max_msk = 0;\n\tunsigned int i;\n\tconst struct pmu_res_updown_tab_entry *updown_tab = NULL;\n\tunsigned int updown_tab_size = 0;\n\tconst struct pmu_res_depend_tab_entry *depend_tab = NULL;\n\tunsigned int depend_tab_size = 0;\n\n\tswitch (bus->chip_id) {\n\tcase 0x4312:\n\t\t min_msk = 0xCBB;\n\t\t break;\n\tcase 0x4322:\n\tcase 43222:\n\t\t \n\t\tbreak;\n\tcase 0x4325:\n\t\t \n\t\tmin_msk = (1 << SSB_PMURES_4325_CBUCK_BURST) |\n\t\t\t  (1 << SSB_PMURES_4325_LNLDO2_PU);\n\t\tif (chipco_read32(cc, SSB_CHIPCO_CHIPSTAT) &\n\t\t    SSB_CHIPCO_CHST_4325_PMUTOP_2B)\n\t\t\tmin_msk |= (1 << SSB_PMURES_4325_CLDO_CBUCK_BURST);\n\t\t \n\t\tmax_msk = 0xFFFFF;\n\t\tupdown_tab = pmu_res_updown_tab_4325a0;\n\t\tupdown_tab_size = ARRAY_SIZE(pmu_res_updown_tab_4325a0);\n\t\tdepend_tab = pmu_res_depend_tab_4325a0;\n\t\tdepend_tab_size = ARRAY_SIZE(pmu_res_depend_tab_4325a0);\n\t\tbreak;\n\tcase 0x4328:\n\t\tmin_msk = (1 << SSB_PMURES_4328_EXT_SWITCHER_PWM) |\n\t\t\t  (1 << SSB_PMURES_4328_BB_SWITCHER_PWM) |\n\t\t\t  (1 << SSB_PMURES_4328_XTAL_EN);\n\t\t \n\t\tmax_msk = 0xFFFFF;\n\t\tupdown_tab = pmu_res_updown_tab_4328a0;\n\t\tupdown_tab_size = ARRAY_SIZE(pmu_res_updown_tab_4328a0);\n\t\tdepend_tab = pmu_res_depend_tab_4328a0;\n\t\tdepend_tab_size = ARRAY_SIZE(pmu_res_depend_tab_4328a0);\n\t\tbreak;\n\tcase 0x5354:\n\t\t \n\t\tmax_msk = 0xFFFFF;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cc->dev->dev, \"ERROR: PMU resource config unknown for device %04X\\n\",\n\t\t\tbus->chip_id);\n\t}\n\n\tif (updown_tab) {\n\t\tfor (i = 0; i < updown_tab_size; i++) {\n\t\t\tchipco_write32(cc, SSB_CHIPCO_PMU_RES_TABSEL,\n\t\t\t\t       updown_tab[i].resource);\n\t\t\tchipco_write32(cc, SSB_CHIPCO_PMU_RES_UPDNTM,\n\t\t\t\t       updown_tab[i].updown);\n\t\t}\n\t}\n\tif (depend_tab) {\n\t\tfor (i = 0; i < depend_tab_size; i++) {\n\t\t\tchipco_write32(cc, SSB_CHIPCO_PMU_RES_TABSEL,\n\t\t\t\t       depend_tab[i].resource);\n\t\t\tswitch (depend_tab[i].task) {\n\t\t\tcase PMU_RES_DEP_SET:\n\t\t\t\tchipco_write32(cc, SSB_CHIPCO_PMU_RES_DEPMSK,\n\t\t\t\t\t       depend_tab[i].depend);\n\t\t\t\tbreak;\n\t\t\tcase PMU_RES_DEP_ADD:\n\t\t\t\tchipco_set32(cc, SSB_CHIPCO_PMU_RES_DEPMSK,\n\t\t\t\t\t     depend_tab[i].depend);\n\t\t\t\tbreak;\n\t\t\tcase PMU_RES_DEP_REMOVE:\n\t\t\t\tchipco_mask32(cc, SSB_CHIPCO_PMU_RES_DEPMSK,\n\t\t\t\t\t      ~(depend_tab[i].depend));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (min_msk)\n\t\tchipco_write32(cc, SSB_CHIPCO_PMU_MINRES_MSK, min_msk);\n\tif (max_msk)\n\t\tchipco_write32(cc, SSB_CHIPCO_PMU_MAXRES_MSK, max_msk);\n}\n\n \n\t\treturn 240000000;\n\tdefault:\n\t\tdev_err(cc->dev->dev, \"ERROR: PMU cpu clock unknown for device %04X\\n\",\n\t\t\tbus->chip_id);\n\t\treturn 0;\n\t}\n}\n\nu32 ssb_pmu_get_controlclock(struct ssb_chipcommon *cc)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\n\tswitch (bus->chip_id) {\n\tcase 0x5354:\n\t\treturn 120000000;\n\tdefault:\n\t\tdev_err(cc->dev->dev, \"ERROR: PMU controlclock unknown for device %04X\\n\",\n\t\t\tbus->chip_id);\n\t\treturn 0;\n\t}\n}\n\nvoid ssb_pmu_spuravoid_pllupdate(struct ssb_chipcommon *cc, int spuravoid)\n{\n\tu32 pmu_ctl = 0;\n\n\tswitch (cc->dev->bus->chip_id) {\n\tcase 0x4322:\n\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL0, 0x11100070);\n\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL1, 0x1014140a);\n\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL5, 0x88888854);\n\t\tif (spuravoid == 1)\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL2, 0x05201828);\n\t\telse\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL2, 0x05001828);\n\t\tpmu_ctl = SSB_CHIPCO_PMU_CTL_PLL_UPD;\n\t\tbreak;\n\tcase 43222:\n\t\tif (spuravoid == 1) {\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL0, 0x11500008);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL1, 0x0C000C06);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL2, 0x0F600a08);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL3, 0x00000000);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL4, 0x2001E920);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL5, 0x88888815);\n\t\t} else {\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL0, 0x11100008);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL1, 0x0c000c06);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL2, 0x03000a08);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL3, 0x00000000);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL4, 0x200005c0);\n\t\t\tssb_chipco_pll_write(cc, SSB_PMU1_PLLCTL5, 0x88888855);\n\t\t}\n\t\tpmu_ctl = SSB_CHIPCO_PMU_CTL_PLL_UPD;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cc->dev->dev,\n\t\t\t\"Unknown spuravoidance settings for chip 0x%04X, not changing PLL\\n\",\n\t\t\tcc->dev->bus->chip_id);\n\t\treturn;\n\t}\n\n\tchipco_set32(cc, SSB_CHIPCO_PMU_CTL, pmu_ctl);\n}\nEXPORT_SYMBOL_GPL(ssb_pmu_spuravoid_pllupdate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}