{
  "module_name": "pcmcia.c",
  "hash_id": "261617d2c951820de65e9c2df14da709ff5e824871bc3d3b0a5262864c192bc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/pcmcia.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/ssb/ssb.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/etherdevice.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/cisreg.h>\n\n\n \n#define SSB_VERBOSE_PCMCIACORESWITCH_DEBUG\t\t0\n\n\n \n#define SSB_PCMCIA_ADDRESS0\t\t0x2E\n#define SSB_PCMCIA_ADDRESS1\t\t0x30\n#define SSB_PCMCIA_ADDRESS2\t\t0x32\n#define SSB_PCMCIA_MEMSEG\t\t0x34\n#define SSB_PCMCIA_SPROMCTL\t\t0x36\n#define  SSB_PCMCIA_SPROMCTL_IDLE\t0\n#define  SSB_PCMCIA_SPROMCTL_WRITE\t1\n#define  SSB_PCMCIA_SPROMCTL_READ\t2\n#define  SSB_PCMCIA_SPROMCTL_WRITEEN\t4\n#define  SSB_PCMCIA_SPROMCTL_WRITEDIS\t7\n#define  SSB_PCMCIA_SPROMCTL_DONE\t8\n#define SSB_PCMCIA_SPROM_DATALO\t\t0x38\n#define SSB_PCMCIA_SPROM_DATAHI\t\t0x3A\n#define SSB_PCMCIA_SPROM_ADDRLO\t\t0x3C\n#define SSB_PCMCIA_SPROM_ADDRHI\t\t0x3E\n\n \n#define SSB_PCMCIA_CIS\t\t\t0x80\n#define  SSB_PCMCIA_CIS_ID\t\t0x01\n#define  SSB_PCMCIA_CIS_BOARDREV\t0x02\n#define  SSB_PCMCIA_CIS_PA\t\t0x03\n#define   SSB_PCMCIA_CIS_PA_PA0B0_LO\t0\n#define   SSB_PCMCIA_CIS_PA_PA0B0_HI\t1\n#define   SSB_PCMCIA_CIS_PA_PA0B1_LO\t2\n#define   SSB_PCMCIA_CIS_PA_PA0B1_HI\t3\n#define   SSB_PCMCIA_CIS_PA_PA0B2_LO\t4\n#define   SSB_PCMCIA_CIS_PA_PA0B2_HI\t5\n#define   SSB_PCMCIA_CIS_PA_ITSSI\t6\n#define   SSB_PCMCIA_CIS_PA_MAXPOW\t7\n#define  SSB_PCMCIA_CIS_OEMNAME\t\t0x04\n#define  SSB_PCMCIA_CIS_CCODE\t\t0x05\n#define  SSB_PCMCIA_CIS_ANTENNA\t\t0x06\n#define  SSB_PCMCIA_CIS_ANTGAIN\t\t0x07\n#define  SSB_PCMCIA_CIS_BFLAGS\t\t0x08\n#define  SSB_PCMCIA_CIS_LEDS\t\t0x09\n\n \n#define SSB_PCMCIA_SPROM_SIZE\t\t256\n#define SSB_PCMCIA_SPROM_SIZE_BYTES\t(SSB_PCMCIA_SPROM_SIZE * sizeof(u16))\n\n\n \nstatic int ssb_pcmcia_cfg_write(struct ssb_bus *bus, u8 offset, u8 value)\n{\n\tint res;\n\n\tres = pcmcia_write_config_byte(bus->host_pcmcia, offset, value);\n\tif (unlikely(res != 0))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n \nstatic int ssb_pcmcia_cfg_read(struct ssb_bus *bus, u8 offset, u8 *value)\n{\n\tint res;\n\n\tres = pcmcia_read_config_byte(bus->host_pcmcia, offset, value);\n\tif (unlikely(res != 0))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nint ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,\n\t\t\t      u8 coreidx)\n{\n\tint err;\n\tint attempts = 0;\n\tu32 cur_core;\n\tu32 addr;\n\tu32 read_addr;\n\tu8 val;\n\n\taddr = (coreidx * SSB_CORE_SIZE) + SSB_ENUM_BASE;\n\twhile (1) {\n\t\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_ADDRESS0,\n\t\t\t\t\t   (addr & 0x0000F000) >> 12);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_ADDRESS1,\n\t\t\t\t\t   (addr & 0x00FF0000) >> 16);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_ADDRESS2,\n\t\t\t\t\t   (addr & 0xFF000000) >> 24);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tread_addr = 0;\n\n\t\terr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_ADDRESS0, &val);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tread_addr |= ((u32)(val & 0x0F)) << 12;\n\t\terr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_ADDRESS1, &val);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tread_addr |= ((u32)val) << 16;\n\t\terr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_ADDRESS2, &val);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tread_addr |= ((u32)val) << 24;\n\n\t\tcur_core = (read_addr - SSB_ENUM_BASE) / SSB_CORE_SIZE;\n\t\tif (cur_core == coreidx)\n\t\t\tbreak;\n\n\t\terr = -ETIMEDOUT;\n\t\tif (attempts++ > SSB_BAR0_MAX_RETRIES)\n\t\t\tgoto error;\n\t\tudelay(10);\n\t}\n\n\treturn 0;\nerror:\n\tpr_err(\"Failed to switch to core %u\\n\", coreidx);\n\treturn err;\n}\n\nstatic int ssb_pcmcia_switch_core(struct ssb_bus *bus, struct ssb_device *dev)\n{\n\tint err;\n\n#if SSB_VERBOSE_PCMCIACORESWITCH_DEBUG\n\tpr_info(\"Switching to %s core, index %d\\n\",\n\t\tssb_core_name(dev->id.coreid), dev->core_index);\n#endif\n\n\terr = ssb_pcmcia_switch_coreidx(bus, dev->core_index);\n\tif (!err)\n\t\tbus->mapped_device = dev;\n\n\treturn err;\n}\n\nint ssb_pcmcia_switch_segment(struct ssb_bus *bus, u8 seg)\n{\n\tint attempts = 0;\n\tint err;\n\tu8 val;\n\n\tWARN_ON((seg != 0) && (seg != 1));\n\twhile (1) {\n\t\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_MEMSEG, seg);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_MEMSEG, &val);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tif (val == seg)\n\t\t\tbreak;\n\n\t\terr = -ETIMEDOUT;\n\t\tif (unlikely(attempts++ > SSB_BAR0_MAX_RETRIES))\n\t\t\tgoto error;\n\t\tudelay(10);\n\t}\n\tbus->mapped_pcmcia_seg = seg;\n\n\treturn 0;\nerror:\n\tpr_err(\"Failed to switch pcmcia segment\\n\");\n\treturn err;\n}\n\nstatic int select_core_and_segment(struct ssb_device *dev,\n\t\t\t\t   u16 *offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tint err;\n\tu8 need_segment;\n\n\tif (*offset >= 0x800) {\n\t\t*offset -= 0x800;\n\t\tneed_segment = 1;\n\t} else\n\t\tneed_segment = 0;\n\n\tif (unlikely(dev != bus->mapped_device)) {\n\t\terr = ssb_pcmcia_switch_core(bus, dev);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t}\n\tif (unlikely(need_segment != bus->mapped_pcmcia_seg)) {\n\t\terr = ssb_pcmcia_switch_segment(bus, need_segment);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 ssb_pcmcia_read8(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tunsigned long flags;\n\tint err;\n\tu8 value = 0xFF;\n\n\tspin_lock_irqsave(&bus->bar_lock, flags);\n\terr = select_core_and_segment(dev, &offset);\n\tif (likely(!err))\n\t\tvalue = readb(bus->mmio + offset);\n\tspin_unlock_irqrestore(&bus->bar_lock, flags);\n\n\treturn value;\n}\n\nstatic u16 ssb_pcmcia_read16(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tunsigned long flags;\n\tint err;\n\tu16 value = 0xFFFF;\n\n\tspin_lock_irqsave(&bus->bar_lock, flags);\n\terr = select_core_and_segment(dev, &offset);\n\tif (likely(!err))\n\t\tvalue = readw(bus->mmio + offset);\n\tspin_unlock_irqrestore(&bus->bar_lock, flags);\n\n\treturn value;\n}\n\nstatic u32 ssb_pcmcia_read32(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tunsigned long flags;\n\tint err;\n\tu32 lo = 0xFFFFFFFF, hi = 0xFFFFFFFF;\n\n\tspin_lock_irqsave(&bus->bar_lock, flags);\n\terr = select_core_and_segment(dev, &offset);\n\tif (likely(!err)) {\n\t\tlo = readw(bus->mmio + offset);\n\t\thi = readw(bus->mmio + offset + 2);\n\t}\n\tspin_unlock_irqrestore(&bus->bar_lock, flags);\n\n\treturn (lo | (hi << 16));\n}\n\n#ifdef CONFIG_SSB_BLOCKIO\nstatic void ssb_pcmcia_block_read(struct ssb_device *dev, void *buffer,\n\t\t\t\t  size_t count, u16 offset, u8 reg_width)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tunsigned long flags;\n\tvoid __iomem *addr = bus->mmio + offset;\n\tint err;\n\n\tspin_lock_irqsave(&bus->bar_lock, flags);\n\terr = select_core_and_segment(dev, &offset);\n\tif (unlikely(err)) {\n\t\tmemset(buffer, 0xFF, count);\n\t\tgoto unlock;\n\t}\n\tswitch (reg_width) {\n\tcase sizeof(u8): {\n\t\tu8 *buf = buffer;\n\n\t\twhile (count) {\n\t\t\t*buf = __raw_readb(addr);\n\t\t\tbuf++;\n\t\t\tcount--;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u16): {\n\t\t__le16 *buf = buffer;\n\n\t\tWARN_ON(count & 1);\n\t\twhile (count) {\n\t\t\t*buf = (__force __le16)__raw_readw(addr);\n\t\t\tbuf++;\n\t\t\tcount -= 2;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u32): {\n\t\t__le16 *buf = buffer;\n\n\t\tWARN_ON(count & 3);\n\t\twhile (count) {\n\t\t\t*buf = (__force __le16)__raw_readw(addr);\n\t\t\tbuf++;\n\t\t\t*buf = (__force __le16)__raw_readw(addr + 2);\n\t\t\tbuf++;\n\t\t\tcount -= 4;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t}\nunlock:\n\tspin_unlock_irqrestore(&bus->bar_lock, flags);\n}\n#endif  \n\nstatic void ssb_pcmcia_write8(struct ssb_device *dev, u16 offset, u8 value)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&bus->bar_lock, flags);\n\terr = select_core_and_segment(dev, &offset);\n\tif (likely(!err))\n\t\twriteb(value, bus->mmio + offset);\n\tspin_unlock_irqrestore(&bus->bar_lock, flags);\n}\n\nstatic void ssb_pcmcia_write16(struct ssb_device *dev, u16 offset, u16 value)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&bus->bar_lock, flags);\n\terr = select_core_and_segment(dev, &offset);\n\tif (likely(!err))\n\t\twritew(value, bus->mmio + offset);\n\tspin_unlock_irqrestore(&bus->bar_lock, flags);\n}\n\nstatic void ssb_pcmcia_write32(struct ssb_device *dev, u16 offset, u32 value)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&bus->bar_lock, flags);\n\terr = select_core_and_segment(dev, &offset);\n\tif (likely(!err)) {\n\t\twritew((value & 0x0000FFFF), bus->mmio + offset);\n\t\twritew(((value & 0xFFFF0000) >> 16), bus->mmio + offset + 2);\n\t}\n\tspin_unlock_irqrestore(&bus->bar_lock, flags);\n}\n\n#ifdef CONFIG_SSB_BLOCKIO\nstatic void ssb_pcmcia_block_write(struct ssb_device *dev, const void *buffer,\n\t\t\t\t   size_t count, u16 offset, u8 reg_width)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tunsigned long flags;\n\tvoid __iomem *addr = bus->mmio + offset;\n\tint err;\n\n\tspin_lock_irqsave(&bus->bar_lock, flags);\n\terr = select_core_and_segment(dev, &offset);\n\tif (unlikely(err))\n\t\tgoto unlock;\n\tswitch (reg_width) {\n\tcase sizeof(u8): {\n\t\tconst u8 *buf = buffer;\n\n\t\twhile (count) {\n\t\t\t__raw_writeb(*buf, addr);\n\t\t\tbuf++;\n\t\t\tcount--;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u16): {\n\t\tconst __le16 *buf = buffer;\n\n\t\tWARN_ON(count & 1);\n\t\twhile (count) {\n\t\t\t__raw_writew((__force u16)(*buf), addr);\n\t\t\tbuf++;\n\t\t\tcount -= 2;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u32): {\n\t\tconst __le16 *buf = buffer;\n\n\t\tWARN_ON(count & 3);\n\t\twhile (count) {\n\t\t\t__raw_writew((__force u16)(*buf), addr);\n\t\t\tbuf++;\n\t\t\t__raw_writew((__force u16)(*buf), addr + 2);\n\t\t\tbuf++;\n\t\t\tcount -= 4;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t}\nunlock:\n\tspin_unlock_irqrestore(&bus->bar_lock, flags);\n}\n#endif  \n\n \nconst struct ssb_bus_ops ssb_pcmcia_ops = {\n\t.read8\t\t= ssb_pcmcia_read8,\n\t.read16\t\t= ssb_pcmcia_read16,\n\t.read32\t\t= ssb_pcmcia_read32,\n\t.write8\t\t= ssb_pcmcia_write8,\n\t.write16\t= ssb_pcmcia_write16,\n\t.write32\t= ssb_pcmcia_write32,\n#ifdef CONFIG_SSB_BLOCKIO\n\t.block_read\t= ssb_pcmcia_block_read,\n\t.block_write\t= ssb_pcmcia_block_write,\n#endif\n};\n\nstatic int ssb_pcmcia_sprom_command(struct ssb_bus *bus, u8 command)\n{\n\tunsigned int i;\n\tint err;\n\tu8 value;\n\n\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROMCTL, command);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < 1000; i++) {\n\t\terr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_SPROMCTL, &value);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value & SSB_PCMCIA_SPROMCTL_DONE)\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int ssb_pcmcia_sprom_read(struct ssb_bus *bus, u16 offset, u16 *value)\n{\n\tint err;\n\tu8 lo, hi;\n\n\toffset *= 2;  \n\n\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_ADDRLO,\n\t\t\t\t   (offset & 0x00FF));\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_ADDRHI,\n\t\t\t\t   (offset & 0xFF00) >> 8);\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_sprom_command(bus, SSB_PCMCIA_SPROMCTL_READ);\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_SPROM_DATALO, &lo);\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_SPROM_DATAHI, &hi);\n\tif (err)\n\t\treturn err;\n\t*value = (lo | (((u16)hi) << 8));\n\n\treturn 0;\n}\n\n \nstatic int ssb_pcmcia_sprom_write(struct ssb_bus *bus, u16 offset, u16 value)\n{\n\tint err;\n\n\toffset *= 2;  \n\n\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_ADDRLO,\n\t\t\t\t   (offset & 0x00FF));\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_ADDRHI,\n\t\t\t\t   (offset & 0xFF00) >> 8);\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_DATALO,\n\t\t\t\t   (value & 0x00FF));\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_DATAHI,\n\t\t\t\t   (value & 0xFF00) >> 8);\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_sprom_command(bus, SSB_PCMCIA_SPROMCTL_WRITE);\n\tif (err)\n\t\treturn err;\n\tmsleep(20);\n\n\treturn 0;\n}\n\n \nstatic int ssb_pcmcia_sprom_read_all(struct ssb_bus *bus, u16 *sprom)\n{\n\tint err, i;\n\n\tfor (i = 0; i < SSB_PCMCIA_SPROM_SIZE; i++) {\n\t\terr = ssb_pcmcia_sprom_read(bus, i, &sprom[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ssb_pcmcia_sprom_write_all(struct ssb_bus *bus, const u16 *sprom)\n{\n\tint i, err;\n\tbool failed = 0;\n\tsize_t size = SSB_PCMCIA_SPROM_SIZE;\n\n\tpr_notice(\"Writing SPROM. Do NOT turn off the power! Please stand by...\\n\");\n\terr = ssb_pcmcia_sprom_command(bus, SSB_PCMCIA_SPROMCTL_WRITEEN);\n\tif (err) {\n\t\tpr_notice(\"Could not enable SPROM write access\\n\");\n\t\treturn -EBUSY;\n\t}\n\tpr_notice(\"[ 0%%\");\n\tmsleep(500);\n\tfor (i = 0; i < size; i++) {\n\t\tif (i == size / 4)\n\t\t\tpr_cont(\"25%%\");\n\t\telse if (i == size / 2)\n\t\t\tpr_cont(\"50%%\");\n\t\telse if (i == (size * 3) / 4)\n\t\t\tpr_cont(\"75%%\");\n\t\telse if (i % 2)\n\t\t\tpr_cont(\".\");\n\t\terr = ssb_pcmcia_sprom_write(bus, i, sprom[i]);\n\t\tif (err) {\n\t\t\tpr_notice(\"Failed to write to SPROM\\n\");\n\t\t\tfailed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = ssb_pcmcia_sprom_command(bus, SSB_PCMCIA_SPROMCTL_WRITEDIS);\n\tif (err) {\n\t\tpr_notice(\"Could not disable SPROM write access\\n\");\n\t\tfailed = 1;\n\t}\n\tmsleep(500);\n\tif (!failed) {\n\t\tpr_cont(\"100%% ]\\n\");\n\t\tpr_notice(\"SPROM written\\n\");\n\t}\n\n\treturn failed ? -EBUSY : 0;\n}\n\nstatic int ssb_pcmcia_sprom_check_crc(const u16 *sprom, size_t size)\n{\n\t\n\treturn 0;\n}\n\n#define GOTO_ERROR_ON(condition, description) do {\t\\\n\tif (unlikely(condition)) {\t\t\t\\\n\t\terror_description = description;\t\\\n\t\tgoto error;\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n  } while (0)\n\nstatic int ssb_pcmcia_get_mac(struct pcmcia_device *p_dev,\n\t\t\ttuple_t *tuple,\n\t\t\tvoid *priv)\n{\n\tstruct ssb_sprom *sprom = priv;\n\n\tif (tuple->TupleData[0] != CISTPL_FUNCE_LAN_NODE_ID)\n\t\treturn -EINVAL;\n\tif (tuple->TupleDataLen != ETH_ALEN + 2)\n\t\treturn -EINVAL;\n\tif (tuple->TupleData[1] != ETH_ALEN)\n\t\treturn -EINVAL;\n\tmemcpy(sprom->il0mac, &tuple->TupleData[2], ETH_ALEN);\n\treturn 0;\n};\n\nstatic int ssb_pcmcia_do_get_invariants(struct pcmcia_device *p_dev,\n\t\t\t\t\ttuple_t *tuple,\n\t\t\t\t\tvoid *priv)\n{\n\tstruct ssb_init_invariants *iv = priv;\n\tstruct ssb_sprom *sprom = &iv->sprom;\n\tstruct ssb_boardinfo *bi = &iv->boardinfo;\n\tconst char *error_description;\n\n\tGOTO_ERROR_ON(tuple->TupleDataLen < 1, \"VEN tpl < 1\");\n\tswitch (tuple->TupleData[0]) {\n\tcase SSB_PCMCIA_CIS_ID:\n\t\tGOTO_ERROR_ON((tuple->TupleDataLen != 5) &&\n\t\t\t      (tuple->TupleDataLen != 7),\n\t\t\t      \"id tpl size\");\n\t\tbi->vendor = tuple->TupleData[1] |\n\t\t\t((u16)tuple->TupleData[2] << 8);\n\t\tbreak;\n\tcase SSB_PCMCIA_CIS_BOARDREV:\n\t\tGOTO_ERROR_ON(tuple->TupleDataLen != 2,\n\t\t\t\"boardrev tpl size\");\n\t\tsprom->board_rev = tuple->TupleData[1];\n\t\tbreak;\n\tcase SSB_PCMCIA_CIS_PA:\n\t\tGOTO_ERROR_ON((tuple->TupleDataLen != 9) &&\n\t\t\t(tuple->TupleDataLen != 10),\n\t\t\t\"pa tpl size\");\n\t\tsprom->pa0b0 = tuple->TupleData[1] |\n\t\t\t((u16)tuple->TupleData[2] << 8);\n\t\tsprom->pa0b1 = tuple->TupleData[3] |\n\t\t\t((u16)tuple->TupleData[4] << 8);\n\t\tsprom->pa0b2 = tuple->TupleData[5] |\n\t\t\t((u16)tuple->TupleData[6] << 8);\n\t\tsprom->itssi_a = tuple->TupleData[7];\n\t\tsprom->itssi_bg = tuple->TupleData[7];\n\t\tsprom->maxpwr_a = tuple->TupleData[8];\n\t\tsprom->maxpwr_bg = tuple->TupleData[8];\n\t\tbreak;\n\tcase SSB_PCMCIA_CIS_OEMNAME:\n\t\t \n\t\tbreak;\n\tcase SSB_PCMCIA_CIS_CCODE:\n\t\tGOTO_ERROR_ON(tuple->TupleDataLen != 2,\n\t\t\t\"ccode tpl size\");\n\t\tsprom->country_code = tuple->TupleData[1];\n\t\tbreak;\n\tcase SSB_PCMCIA_CIS_ANTENNA:\n\t\tGOTO_ERROR_ON(tuple->TupleDataLen != 2,\n\t\t\t\"ant tpl size\");\n\t\tsprom->ant_available_a = tuple->TupleData[1];\n\t\tsprom->ant_available_bg = tuple->TupleData[1];\n\t\tbreak;\n\tcase SSB_PCMCIA_CIS_ANTGAIN:\n\t\tGOTO_ERROR_ON(tuple->TupleDataLen != 2,\n\t\t\t\"antg tpl size\");\n\t\tsprom->antenna_gain.a0 = tuple->TupleData[1];\n\t\tsprom->antenna_gain.a1 = tuple->TupleData[1];\n\t\tsprom->antenna_gain.a2 = tuple->TupleData[1];\n\t\tsprom->antenna_gain.a3 = tuple->TupleData[1];\n\t\tbreak;\n\tcase SSB_PCMCIA_CIS_BFLAGS:\n\t\tGOTO_ERROR_ON((tuple->TupleDataLen != 3) &&\n\t\t\t(tuple->TupleDataLen != 5),\n\t\t\t\"bfl tpl size\");\n\t\tsprom->boardflags_lo = tuple->TupleData[1] |\n\t\t\t((u16)tuple->TupleData[2] << 8);\n\t\tbreak;\n\tcase SSB_PCMCIA_CIS_LEDS:\n\t\tGOTO_ERROR_ON(tuple->TupleDataLen != 5,\n\t\t\t\"leds tpl size\");\n\t\tsprom->gpio0 = tuple->TupleData[1];\n\t\tsprom->gpio1 = tuple->TupleData[2];\n\t\tsprom->gpio2 = tuple->TupleData[3];\n\t\tsprom->gpio3 = tuple->TupleData[4];\n\t\tbreak;\n\t}\n\treturn -ENOSPC;  \n\nerror:\n\tpr_err(\"PCMCIA: Failed to fetch device invariants: %s\\n\",\n\t       error_description);\n\treturn -ENODEV;\n}\n\n\nint ssb_pcmcia_get_invariants(struct ssb_bus *bus,\n\t\t\t      struct ssb_init_invariants *iv)\n{\n\tstruct ssb_sprom *sprom = &iv->sprom;\n\tint res;\n\n\tmemset(sprom, 0xFF, sizeof(*sprom));\n\tsprom->revision = 1;\n\tsprom->boardflags_lo = 0;\n\tsprom->boardflags_hi = 0;\n\n\t \n\tres = pcmcia_loop_tuple(bus->host_pcmcia, CISTPL_FUNCE,\n\t\t\t\tssb_pcmcia_get_mac, sprom);\n\tif (res != 0) {\n\t\tpr_err(\"PCMCIA: Failed to fetch MAC address\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tres = pcmcia_loop_tuple(bus->host_pcmcia, SSB_PCMCIA_CIS,\n\t\t\t\tssb_pcmcia_do_get_invariants, iv);\n\tif ((res == 0) || (res == -ENOSPC))\n\t\treturn 0;\n\n\tpr_err(\"PCMCIA: Failed to fetch device invariants\\n\");\n\treturn -ENODEV;\n}\n\nstatic ssize_t ssb_sprom_show(struct device *pcmciadev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct pcmcia_device *pdev =\n\t\tcontainer_of(pcmciadev, struct pcmcia_device, dev);\n\tstruct ssb_bus *bus;\n\n\tbus = ssb_pcmcia_dev_to_bus(pdev);\n\tif (!bus)\n\t\treturn -ENODEV;\n\n\treturn ssb_attr_sprom_show(bus, buf,\n\t\t\t\t   ssb_pcmcia_sprom_read_all);\n}\n\nstatic ssize_t ssb_sprom_store(struct device *pcmciadev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct pcmcia_device *pdev =\n\t\tcontainer_of(pcmciadev, struct pcmcia_device, dev);\n\tstruct ssb_bus *bus;\n\n\tbus = ssb_pcmcia_dev_to_bus(pdev);\n\tif (!bus)\n\t\treturn -ENODEV;\n\n\treturn ssb_attr_sprom_store(bus, buf, count,\n\t\t\t\t    ssb_pcmcia_sprom_check_crc,\n\t\t\t\t    ssb_pcmcia_sprom_write_all);\n}\n\nstatic DEVICE_ATTR_ADMIN_RW(ssb_sprom);\n\nstatic int ssb_pcmcia_cor_setup(struct ssb_bus *bus, u8 cor)\n{\n\tu8 val;\n\tint err;\n\n\terr = ssb_pcmcia_cfg_read(bus, cor, &val);\n\tif (err)\n\t\treturn err;\n\tval &= ~COR_SOFT_RESET;\n\tval |= COR_FUNC_ENA | COR_IREQ_ENA | COR_LEVEL_REQ;\n\terr = ssb_pcmcia_cfg_write(bus, cor, val);\n\tif (err)\n\t\treturn err;\n\tmsleep(40);\n\n\treturn 0;\n}\n\n \nint ssb_pcmcia_hardware_setup(struct ssb_bus *bus)\n{\n\tint err;\n\n\tif (bus->bustype != SSB_BUSTYPE_PCMCIA)\n\t\treturn 0;\n\n\t \n\tssb_pcmcia_switch_segment(bus, 0);\n\t \n\terr = ssb_pcmcia_cor_setup(bus, CISREG_COR);\n\tif (err)\n\t\treturn err;\n\t \n\terr = ssb_pcmcia_cor_setup(bus, CISREG_COR + 0x80);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nvoid ssb_pcmcia_exit(struct ssb_bus *bus)\n{\n\tif (bus->bustype != SSB_BUSTYPE_PCMCIA)\n\t\treturn;\n\n\tdevice_remove_file(&bus->host_pcmcia->dev, &dev_attr_ssb_sprom);\n}\n\nint ssb_pcmcia_init(struct ssb_bus *bus)\n{\n\tint err;\n\n\tif (bus->bustype != SSB_BUSTYPE_PCMCIA)\n\t\treturn 0;\n\n\terr = ssb_pcmcia_hardware_setup(bus);\n\tif (err)\n\t\tgoto error;\n\n\tbus->sprom_size = SSB_PCMCIA_SPROM_SIZE;\n\tmutex_init(&bus->sprom_mutex);\n\terr = device_create_file(&bus->host_pcmcia->dev, &dev_attr_ssb_sprom);\n\tif (err)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tpr_err(\"Failed to initialize PCMCIA host device\\n\");\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}