{
  "module_name": "driver_pcicore.c",
  "hash_id": "4595ff70f2c6c44ba5233b07a25fee86336749227cfd58f765f9f3a26f53917d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/driver_pcicore.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/ssb/ssb.h>\n#include <linux/pci.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/ssb/ssb_embedded.h>\n\nstatic u32 ssb_pcie_read(struct ssb_pcicore *pc, u32 address);\nstatic void ssb_pcie_write(struct ssb_pcicore *pc, u32 address, u32 data);\nstatic u16 ssb_pcie_mdio_read(struct ssb_pcicore *pc, u8 device, u8 address);\nstatic void ssb_pcie_mdio_write(struct ssb_pcicore *pc, u8 device,\n\t\t\t\tu8 address, u16 data);\n\nstatic inline\nu32 pcicore_read32(struct ssb_pcicore *pc, u16 offset)\n{\n\treturn ssb_read32(pc->dev, offset);\n}\n\nstatic inline\nvoid pcicore_write32(struct ssb_pcicore *pc, u16 offset, u32 value)\n{\n\tssb_write32(pc->dev, offset, value);\n}\n\nstatic inline\nu16 pcicore_read16(struct ssb_pcicore *pc, u16 offset)\n{\n\treturn ssb_read16(pc->dev, offset);\n}\n\nstatic inline\nvoid pcicore_write16(struct ssb_pcicore *pc, u16 offset, u16 value)\n{\n\tssb_write16(pc->dev, offset, value);\n}\n\n \n\n#ifdef CONFIG_SSB_PCICORE_HOSTMODE\n\n#include <asm/paccess.h>\n \n#define mips_busprobe32(val, addr)\tget_dbe((val), ((u32 *)(addr)))\n\n \n#define SSB_PCI_SLOT_MAX\t16\n\n \nstatic DEFINE_SPINLOCK(cfgspace_lock);\n \nstatic struct ssb_pcicore *extpci_core;\n\n\nstatic u32 get_cfgspace_addr(struct ssb_pcicore *pc,\n\t\t\t     unsigned int bus, unsigned int dev,\n\t\t\t     unsigned int func, unsigned int off)\n{\n\tu32 addr = 0;\n\tu32 tmp;\n\n\t \n\tif (pc->cardbusmode && (dev > 1))\n\t\tgoto out;\n\n\tif (bus == 0) {\n\t\t \n\t\tif (unlikely(dev >= SSB_PCI_SLOT_MAX))\n\t\t\tgoto out;\n\t\t \n\t\ttmp = SSB_PCICORE_SBTOPCI_CFG0;\n\t\ttmp |= ((1 << (dev + 16)) & SSB_PCICORE_SBTOPCI1_MASK);\n\t\tpcicore_write32(pc, SSB_PCICORE_SBTOPCI1, tmp);\n\t\t \n\t\taddr = SSB_PCI_CFG;\n\t\taddr |= ((1 << (dev + 16)) & ~SSB_PCICORE_SBTOPCI1_MASK);\n\t\taddr |= (func << 8);\n\t\taddr |= (off & ~3);\n\t} else {\n\t\t \n\t\tpcicore_write32(pc, SSB_PCICORE_SBTOPCI1,\n\t\t\t\tSSB_PCICORE_SBTOPCI_CFG1);\n\t\t \n\t\taddr = SSB_PCI_CFG;\n\t\taddr |= (bus << 16);\n\t\taddr |= (dev << 11);\n\t\taddr |= (func << 8);\n\t\taddr |= (off & ~3);\n\t}\nout:\n\treturn addr;\n}\n\nstatic int ssb_extpci_read_config(struct ssb_pcicore *pc,\n\t\t\t\t  unsigned int bus, unsigned int dev,\n\t\t\t\t  unsigned int func, unsigned int off,\n\t\t\t\t  void *buf, int len)\n{\n\tint err = -EINVAL;\n\tu32 addr, val;\n\tvoid __iomem *mmio;\n\n\tWARN_ON(!pc->hostmode);\n\tif (unlikely(len != 1 && len != 2 && len != 4))\n\t\tgoto out;\n\taddr = get_cfgspace_addr(pc, bus, dev, func, off);\n\tif (unlikely(!addr))\n\t\tgoto out;\n\terr = -ENOMEM;\n\tmmio = ioremap(addr, len);\n\tif (!mmio)\n\t\tgoto out;\n\n\tif (mips_busprobe32(val, mmio)) {\n\t\tval = 0xffffffff;\n\t\tgoto unmap;\n\t}\n\n\tval = readl(mmio);\n\tval >>= (8 * (off & 3));\n\n\tswitch (len) {\n\tcase 1:\n\t\t*((u8 *)buf) = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*((u16 *)buf) = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*((u32 *)buf) = (u32)val;\n\t\tbreak;\n\t}\n\terr = 0;\nunmap:\n\tiounmap(mmio);\nout:\n\treturn err;\n}\n\nstatic int ssb_extpci_write_config(struct ssb_pcicore *pc,\n\t\t\t\t   unsigned int bus, unsigned int dev,\n\t\t\t\t   unsigned int func, unsigned int off,\n\t\t\t\t   const void *buf, int len)\n{\n\tint err = -EINVAL;\n\tu32 addr, val = 0;\n\tvoid __iomem *mmio;\n\n\tWARN_ON(!pc->hostmode);\n\tif (unlikely(len != 1 && len != 2 && len != 4))\n\t\tgoto out;\n\taddr = get_cfgspace_addr(pc, bus, dev, func, off);\n\tif (unlikely(!addr))\n\t\tgoto out;\n\terr = -ENOMEM;\n\tmmio = ioremap(addr, len);\n\tif (!mmio)\n\t\tgoto out;\n\n\tif (mips_busprobe32(val, mmio)) {\n\t\tval = 0xffffffff;\n\t\tgoto unmap;\n\t}\n\n\tswitch (len) {\n\tcase 1:\n\t\tval = readl(mmio);\n\t\tval &= ~(0xFF << (8 * (off & 3)));\n\t\tval |= *((const u8 *)buf) << (8 * (off & 3));\n\t\tbreak;\n\tcase 2:\n\t\tval = readl(mmio);\n\t\tval &= ~(0xFFFF << (8 * (off & 3)));\n\t\tval |= *((const u16 *)buf) << (8 * (off & 3));\n\t\tbreak;\n\tcase 4:\n\t\tval = *((const u32 *)buf);\n\t\tbreak;\n\t}\n\twritel(val, mmio);\n\n\terr = 0;\nunmap:\n\tiounmap(mmio);\nout:\n\treturn err;\n}\n\nstatic int ssb_pcicore_read_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t   int reg, int size, u32 *val)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&cfgspace_lock, flags);\n\terr = ssb_extpci_read_config(extpci_core, bus->number, PCI_SLOT(devfn),\n\t\t\t\t     PCI_FUNC(devfn), reg, val, size);\n\tspin_unlock_irqrestore(&cfgspace_lock, flags);\n\n\treturn err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\n}\n\nstatic int ssb_pcicore_write_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t    int reg, int size, u32 val)\n{\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&cfgspace_lock, flags);\n\terr = ssb_extpci_write_config(extpci_core, bus->number, PCI_SLOT(devfn),\n\t\t\t\t      PCI_FUNC(devfn), reg, &val, size);\n\tspin_unlock_irqrestore(&cfgspace_lock, flags);\n\n\treturn err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\n}\n\nstatic struct pci_ops ssb_pcicore_pciops = {\n\t.read\t= ssb_pcicore_read_config,\n\t.write\t= ssb_pcicore_write_config,\n};\n\nstatic struct resource ssb_pcicore_mem_resource = {\n\t.name\t= \"SSB PCIcore external memory\",\n\t.start\t= SSB_PCI_DMA,\n\t.end\t= SSB_PCI_DMA + SSB_PCI_DMA_SZ - 1,\n\t.flags\t= IORESOURCE_MEM | IORESOURCE_PCI_FIXED,\n};\n\nstatic struct resource ssb_pcicore_io_resource = {\n\t.name\t= \"SSB PCIcore external I/O\",\n\t.start\t= 0x100,\n\t.end\t= 0x7FF,\n\t.flags\t= IORESOURCE_IO | IORESOURCE_PCI_FIXED,\n};\n\nstatic struct pci_controller ssb_pcicore_controller = {\n\t.pci_ops\t= &ssb_pcicore_pciops,\n\t.io_resource\t= &ssb_pcicore_io_resource,\n\t.mem_resource\t= &ssb_pcicore_mem_resource,\n};\n\n \nint ssb_pcicore_plat_dev_init(struct pci_dev *d)\n{\n\tif (d->bus->ops != &ssb_pcicore_pciops) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&d->dev, \"PCI: Fixing up device %s\\n\", pci_name(d));\n\n\t \n\td->irq = ssb_mips_irq(extpci_core->dev) + 2;\n\tpci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);\n\n\treturn 0;\n}\n\n \nstatic void ssb_pcicore_fixup_pcibridge(struct pci_dev *dev)\n{\n\tu8 lat;\n\n\tif (dev->bus->ops != &ssb_pcicore_pciops) {\n\t\t \n\t\treturn;\n\t}\n\tif (dev->bus->number != 0 || PCI_SLOT(dev->devfn) != 0)\n\t\treturn;\n\n\tdev_info(&dev->dev, \"PCI: Fixing up bridge %s\\n\", pci_name(dev));\n\n\t \n\tpci_set_master(dev);\n\tif (pcibios_enable_device(dev, ~0) < 0) {\n\t\tdev_err(&dev->dev, \"PCI: SSB bridge enable failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tpci_write_config_dword(dev, SSB_BAR1_CONTROL, 3);\n\n\t \n\tlat = 168;\n\tdev_info(&dev->dev,\n\t\t \"PCI: Fixing latency timer of device %s to %u\\n\",\n\t\t pci_name(dev), lat);\n\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, ssb_pcicore_fixup_pcibridge);\n\n \nint ssb_pcicore_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\n{\n\tif (dev->bus->ops != &ssb_pcicore_pciops) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\treturn ssb_mips_irq(extpci_core->dev) + 2;\n}\n\nstatic void ssb_pcicore_init_hostmode(struct ssb_pcicore *pc)\n{\n\tu32 val;\n\n\tif (WARN_ON(extpci_core))\n\t\treturn;\n\textpci_core = pc;\n\n\tdev_dbg(pc->dev->dev, \"PCIcore in host mode found\\n\");\n\t \n\tval = SSB_PCICORE_CTL_RST_OE;\n\tval |= SSB_PCICORE_CTL_CLK_OE;\n\tpcicore_write32(pc, SSB_PCICORE_CTL, val);\n\tval |= SSB_PCICORE_CTL_CLK;  \n\tpcicore_write32(pc, SSB_PCICORE_CTL, val);\n\tudelay(150);  \n\tval |= SSB_PCICORE_CTL_RST;  \n\tpcicore_write32(pc, SSB_PCICORE_CTL, val);\n\tval = SSB_PCICORE_ARBCTL_INTERN;\n\tpcicore_write32(pc, SSB_PCICORE_ARBCTL, val);\n\tudelay(1);  \n\n\tif (pc->dev->bus->has_cardbus_slot) {\n\t\tdev_dbg(pc->dev->dev, \"CardBus slot detected\\n\");\n\t\tpc->cardbusmode = 1;\n\t\t \n\t\tssb_gpio_out(pc->dev->bus, 1, 1);\n\t\tssb_gpio_outen(pc->dev->bus, 1, 1);\n\t\tpcicore_write16(pc, SSB_PCICORE_SPROM(0),\n\t\t\t\tpcicore_read16(pc, SSB_PCICORE_SPROM(0))\n\t\t\t\t| 0x0400);\n\t}\n\n\t \n\tpcicore_write32(pc, SSB_PCICORE_SBTOPCI0,\n\t\t\tSSB_PCICORE_SBTOPCI_IO);\n\t \n\tpcicore_write32(pc, SSB_PCICORE_SBTOPCI1,\n\t\t\tSSB_PCICORE_SBTOPCI_CFG0);\n\t \n\tpcicore_write32(pc, SSB_PCICORE_SBTOPCI2,\n\t\t\tSSB_PCICORE_SBTOPCI_MEM | SSB_PCI_DMA);\n\n\t \n\tusleep_range(1000, 2000);\n\n\t \n\tval = PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;\n\tssb_extpci_write_config(pc, 0, 0, 0, PCI_COMMAND, &val, 2);\n\t \n\tval = 0;\n\tssb_extpci_write_config(pc, 0, 0, 0, PCI_STATUS, &val, 2);\n\n\t \n\tpcicore_write32(pc, SSB_PCICORE_IMASK,\n\t\t\tSSB_PCICORE_IMASK_INTA);\n\n\t \n\tssb_pcicore_controller.io_map_base = (unsigned long)ioremap(SSB_PCI_MEM, 0x04000000);\n\tset_io_port_base(ssb_pcicore_controller.io_map_base);\n\t \n\tmdelay(10);\n\tregister_pci_controller(&ssb_pcicore_controller);\n}\n\nstatic int pcicore_is_in_hostmode(struct ssb_pcicore *pc)\n{\n\tstruct ssb_bus *bus = pc->dev->bus;\n\tu16 chipid_top;\n\tu32 tmp;\n\n\tchipid_top = (bus->chip_id & 0xFF00);\n\tif (chipid_top != 0x4700 &&\n\t    chipid_top != 0x5300)\n\t\treturn 0;\n\n\tif (bus->sprom.boardflags_lo & SSB_PCICORE_BFL_NOPCI)\n\t\treturn 0;\n\n\t \n\tif (bus->chip_id == 0x4712) {\n\t\tif (bus->chip_package == SSB_CHIPPACK_BCM4712S)\n\t\t\treturn 0;\n\t\tif (bus->chip_package == SSB_CHIPPACK_BCM4712M)\n\t\t\treturn 0;\n\t}\n\tif (bus->chip_id == 0x5350)\n\t\treturn 0;\n\n\treturn !mips_busprobe32(tmp, (bus->mmio + (pc->dev->core_index * SSB_CORE_SIZE)));\n}\n#endif  \n\n \n\nstatic void ssb_pcicore_fix_sprom_core_index(struct ssb_pcicore *pc)\n{\n\tu16 tmp = pcicore_read16(pc, SSB_PCICORE_SPROM(0));\n\tif (((tmp & 0xF000) >> 12) != pc->dev->core_index) {\n\t\ttmp &= ~0xF000;\n\t\ttmp |= (pc->dev->core_index << 12);\n\t\tpcicore_write16(pc, SSB_PCICORE_SPROM(0), tmp);\n\t}\n}\n\nstatic u8 ssb_pcicore_polarity_workaround(struct ssb_pcicore *pc)\n{\n\treturn (ssb_pcie_read(pc, 0x204) & 0x10) ? 0xC0 : 0x80;\n}\n\nstatic void ssb_pcicore_serdes_workaround(struct ssb_pcicore *pc)\n{\n\tconst u8 serdes_pll_device = 0x1D;\n\tconst u8 serdes_rx_device = 0x1F;\n\tu16 tmp;\n\n\tssb_pcie_mdio_write(pc, serdes_rx_device, 1  ,\n\t\t\t    ssb_pcicore_polarity_workaround(pc));\n\ttmp = ssb_pcie_mdio_read(pc, serdes_pll_device, 1  );\n\tif (tmp & 0x4000)\n\t\tssb_pcie_mdio_write(pc, serdes_pll_device, 1, tmp & ~0x4000);\n}\n\nstatic void ssb_pcicore_pci_setup_workarounds(struct ssb_pcicore *pc)\n{\n\tstruct ssb_device *pdev = pc->dev;\n\tstruct ssb_bus *bus = pdev->bus;\n\tu32 tmp;\n\n\ttmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);\n\ttmp |= SSB_PCICORE_SBTOPCI_PREF;\n\ttmp |= SSB_PCICORE_SBTOPCI_BURST;\n\tpcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);\n\n\tif (pdev->id.revision < 5) {\n\t\ttmp = ssb_read32(pdev, SSB_IMCFGLO);\n\t\ttmp &= ~SSB_IMCFGLO_SERTO;\n\t\ttmp |= 2;\n\t\ttmp &= ~SSB_IMCFGLO_REQTO;\n\t\ttmp |= 3 << SSB_IMCFGLO_REQTO_SHIFT;\n\t\tssb_write32(pdev, SSB_IMCFGLO, tmp);\n\t\tssb_commit_settings(bus);\n\t} else if (pdev->id.revision >= 11) {\n\t\ttmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);\n\t\ttmp |= SSB_PCICORE_SBTOPCI_MRM;\n\t\tpcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);\n\t}\n}\n\nstatic void ssb_pcicore_pcie_setup_workarounds(struct ssb_pcicore *pc)\n{\n\tu32 tmp;\n\tu8 rev = pc->dev->id.revision;\n\n\tif (rev == 0 || rev == 1) {\n\t\t \n\t\ttmp = ssb_pcie_read(pc, 0x4);\n\t\ttmp |= 0x8;\n\t\tssb_pcie_write(pc, 0x4, tmp);\n\t}\n\tif (rev == 1) {\n\t\t \n\t\ttmp = ssb_pcie_read(pc, 0x100);\n\t\ttmp |= 0x40;\n\t\tssb_pcie_write(pc, 0x100, tmp);\n\t}\n\n\tif (rev == 0) {\n\t\tconst u8 serdes_rx_device = 0x1F;\n\n\t\tssb_pcie_mdio_write(pc, serdes_rx_device,\n\t\t\t\t\t2  , 0x8128);\n\t\tssb_pcie_mdio_write(pc, serdes_rx_device,\n\t\t\t\t\t6  , 0x0100);\n\t\tssb_pcie_mdio_write(pc, serdes_rx_device,\n\t\t\t\t\t7  , 0x1466);\n\t} else if (rev == 3 || rev == 4 || rev == 5) {\n\t\t \n\t\tssb_pcicore_serdes_workaround(pc);\n\t\t \n\t} else if (rev == 7) {\n\t\t \n\t}\n\n\tif (rev >= 6) {\n\t\t \n\t\ttmp = pcicore_read16(pc, SSB_PCICORE_SPROM(5));\n\t\tif (!(tmp & 0x8000))\n\t\t\tpcicore_write16(pc, SSB_PCICORE_SPROM(5),\n\t\t\t\t\ttmp | 0x8000);\n\t}\n}\n\n \n\nstatic void ssb_pcicore_init_clientmode(struct ssb_pcicore *pc)\n{\n\tstruct ssb_device *pdev = pc->dev;\n\tstruct ssb_bus *bus = pdev->bus;\n\n\tif (bus->bustype == SSB_BUSTYPE_PCI)\n\t\tssb_pcicore_fix_sprom_core_index(pc);\n\n\t \n\tssb_write32(pdev, SSB_INTVEC, 0);\n\n\t \n\tif (pc->dev->id.coreid == SSB_DEV_PCIE) {\n\t\tssb_pcicore_serdes_workaround(pc);\n\t\t \n\t\t \n\t}\n}\n\nvoid ssb_pcicore_init(struct ssb_pcicore *pc)\n{\n\tstruct ssb_device *dev = pc->dev;\n\n\tif (!dev)\n\t\treturn;\n\tif (!ssb_device_is_enabled(dev))\n\t\tssb_device_enable(dev, 0);\n\n#ifdef CONFIG_SSB_PCICORE_HOSTMODE\n\tpc->hostmode = pcicore_is_in_hostmode(pc);\n\tif (pc->hostmode)\n\t\tssb_pcicore_init_hostmode(pc);\n#endif  \n\tif (!pc->hostmode)\n\t\tssb_pcicore_init_clientmode(pc);\n}\n\nstatic u32 ssb_pcie_read(struct ssb_pcicore *pc, u32 address)\n{\n\tpcicore_write32(pc, 0x130, address);\n\treturn pcicore_read32(pc, 0x134);\n}\n\nstatic void ssb_pcie_write(struct ssb_pcicore *pc, u32 address, u32 data)\n{\n\tpcicore_write32(pc, 0x130, address);\n\tpcicore_write32(pc, 0x134, data);\n}\n\nstatic void ssb_pcie_mdio_set_phy(struct ssb_pcicore *pc, u8 phy)\n{\n\tconst u16 mdio_control = 0x128;\n\tconst u16 mdio_data = 0x12C;\n\tu32 v;\n\tint i;\n\n\tv = (1 << 30);  \n\tv |= (1 << 28);  \n\tv |= (1 << 17);  \n\tv |= (0x1F << 18);\n\tv |= (phy << 4);\n\tpcicore_write32(pc, mdio_data, v);\n\n\tudelay(10);\n\tfor (i = 0; i < 200; i++) {\n\t\tv = pcicore_read32(pc, mdio_control);\n\t\tif (v & 0x100  )\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n}\n\nstatic u16 ssb_pcie_mdio_read(struct ssb_pcicore *pc, u8 device, u8 address)\n{\n\tconst u16 mdio_control = 0x128;\n\tconst u16 mdio_data = 0x12C;\n\tint max_retries = 10;\n\tu16 ret = 0;\n\tu32 v;\n\tint i;\n\n\tv = 0x80;  \n\tv |= 0x2;  \n\tpcicore_write32(pc, mdio_control, v);\n\n\tif (pc->dev->id.revision >= 10) {\n\t\tmax_retries = 200;\n\t\tssb_pcie_mdio_set_phy(pc, device);\n\t}\n\n\tv = (1 << 30);  \n\tv |= (1 << 29);  \n\tv |= (1 << 17);  \n\tif (pc->dev->id.revision < 10)\n\t\tv |= (u32)device << 22;\n\tv |= (u32)address << 18;\n\tpcicore_write32(pc, mdio_data, v);\n\t \n\tudelay(10);\n\tfor (i = 0; i < max_retries; i++) {\n\t\tv = pcicore_read32(pc, mdio_control);\n\t\tif (v & 0x100  ) {\n\t\t\tudelay(10);\n\t\t\tret = pcicore_read32(pc, mdio_data);\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(1);\n\t}\n\tpcicore_write32(pc, mdio_control, 0);\n\treturn ret;\n}\n\nstatic void ssb_pcie_mdio_write(struct ssb_pcicore *pc, u8 device,\n\t\t\t\tu8 address, u16 data)\n{\n\tconst u16 mdio_control = 0x128;\n\tconst u16 mdio_data = 0x12C;\n\tint max_retries = 10;\n\tu32 v;\n\tint i;\n\n\tv = 0x80;  \n\tv |= 0x2;  \n\tpcicore_write32(pc, mdio_control, v);\n\n\tif (pc->dev->id.revision >= 10) {\n\t\tmax_retries = 200;\n\t\tssb_pcie_mdio_set_phy(pc, device);\n\t}\n\n\tv = (1 << 30);  \n\tv |= (1 << 28);  \n\tv |= (1 << 17);  \n\tif (pc->dev->id.revision < 10)\n\t\tv |= (u32)device << 22;\n\tv |= (u32)address << 18;\n\tv |= data;\n\tpcicore_write32(pc, mdio_data, v);\n\t \n\tudelay(10);\n\tfor (i = 0; i < max_retries; i++) {\n\t\tv = pcicore_read32(pc, mdio_control);\n\t\tif (v & 0x100  )\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\tpcicore_write32(pc, mdio_control, 0);\n}\n\nint ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,\n\t\t\t\t   struct ssb_device *dev)\n{\n\tstruct ssb_device *pdev = pc->dev;\n\tstruct ssb_bus *bus;\n\tint err = 0;\n\tu32 tmp;\n\n\tif (dev->bus->bustype != SSB_BUSTYPE_PCI) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (!pdev)\n\t\tgoto out;\n\tbus = pdev->bus;\n\n\tmight_sleep_if(pdev->id.coreid != SSB_DEV_PCI);\n\n\t \n\tif ((pdev->id.revision >= 6) || (pdev->id.coreid == SSB_DEV_PCIE)) {\n\t\tu32 coremask;\n\n\t\t \n\t\tcoremask = (1 << dev->core_index);\n\n\t\tWARN_ON(bus->bustype != SSB_BUSTYPE_PCI);\n\t\terr = pci_read_config_dword(bus->host_pci, SSB_PCI_IRQMASK, &tmp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\ttmp |= coremask << 8;\n\t\terr = pci_write_config_dword(bus->host_pci, SSB_PCI_IRQMASK, tmp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tu32 intvec;\n\n\t\tintvec = ssb_read32(pdev, SSB_INTVEC);\n\t\ttmp = ssb_read32(dev, SSB_TPSFLAG);\n\t\ttmp &= SSB_TPSFLAG_BPFLAG;\n\t\tintvec |= (1 << tmp);\n\t\tssb_write32(pdev, SSB_INTVEC, intvec);\n\t}\n\n\t \n\tif (pc->setup_done)\n\t\tgoto out;\n\tif (pdev->id.coreid == SSB_DEV_PCI) {\n\t\tssb_pcicore_pci_setup_workarounds(pc);\n\t} else {\n\t\tWARN_ON(pdev->id.coreid != SSB_DEV_PCIE);\n\t\tssb_pcicore_pcie_setup_workarounds(pc);\n\t}\n\tpc->setup_done = 1;\nout:\n\treturn err;\n}\nEXPORT_SYMBOL(ssb_pcicore_dev_irqvecs_enable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}