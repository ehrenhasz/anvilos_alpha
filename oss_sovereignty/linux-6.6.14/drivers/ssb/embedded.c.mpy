{
  "module_name": "embedded.c",
  "hash_id": "1ddc4a7fe97914aaccadab1bee3fc2d94c7b63b53c0aff2d6922c63f4c04d6e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/embedded.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/export.h>\n#include <linux/platform_device.h>\n#include <linux/ssb/ssb.h>\n#include <linux/ssb/ssb_embedded.h>\n#include <linux/ssb/ssb_driver_pci.h>\n#include <linux/ssb/ssb_driver_gige.h>\n#include <linux/pci.h>\n\n\nint ssb_watchdog_timer_set(struct ssb_bus *bus, u32 ticks)\n{\n\tif (ssb_chipco_available(&bus->chipco)) {\n\t\tssb_chipco_watchdog_timer_set(&bus->chipco, ticks);\n\t\treturn 0;\n\t}\n\tif (ssb_extif_available(&bus->extif)) {\n\t\tssb_extif_watchdog_timer_set(&bus->extif, ticks);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(ssb_watchdog_timer_set);\n\nint ssb_watchdog_register(struct ssb_bus *bus)\n{\n\tstruct bcm47xx_wdt wdt = {};\n\tstruct platform_device *pdev;\n\n\tif (ssb_chipco_available(&bus->chipco)) {\n\t\twdt.driver_data = &bus->chipco;\n\t\twdt.timer_set = ssb_chipco_watchdog_timer_set_wdt;\n\t\twdt.timer_set_ms = ssb_chipco_watchdog_timer_set_ms;\n\t\twdt.max_timer_ms = bus->chipco.max_timer_ms;\n\t} else if (ssb_extif_available(&bus->extif)) {\n\t\twdt.driver_data = &bus->extif;\n\t\twdt.timer_set = ssb_extif_watchdog_timer_set_wdt;\n\t\twdt.timer_set_ms = ssb_extif_watchdog_timer_set_ms;\n\t\twdt.max_timer_ms = SSB_EXTIF_WATCHDOG_MAX_TIMER_MS;\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\tpdev = platform_device_register_data(NULL, \"bcm47xx-wdt\",\n\t\t\t\t\t     bus->busnumber, &wdt,\n\t\t\t\t\t     sizeof(wdt));\n\tif (IS_ERR(pdev)) {\n\t\tpr_debug(\"can not register watchdog device, err: %li\\n\",\n\t\t\t PTR_ERR(pdev));\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\tbus->watchdog = pdev;\n\treturn 0;\n}\n\nu32 ssb_gpio_in(struct ssb_bus *bus, u32 mask)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&bus->gpio_lock, flags);\n\tif (ssb_chipco_available(&bus->chipco))\n\t\tres = ssb_chipco_gpio_in(&bus->chipco, mask);\n\telse if (ssb_extif_available(&bus->extif))\n\t\tres = ssb_extif_gpio_in(&bus->extif, mask);\n\telse\n\t\tWARN_ON(1);\n\tspin_unlock_irqrestore(&bus->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(ssb_gpio_in);\n\nu32 ssb_gpio_out(struct ssb_bus *bus, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&bus->gpio_lock, flags);\n\tif (ssb_chipco_available(&bus->chipco))\n\t\tres = ssb_chipco_gpio_out(&bus->chipco, mask, value);\n\telse if (ssb_extif_available(&bus->extif))\n\t\tres = ssb_extif_gpio_out(&bus->extif, mask, value);\n\telse\n\t\tWARN_ON(1);\n\tspin_unlock_irqrestore(&bus->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(ssb_gpio_out);\n\nu32 ssb_gpio_outen(struct ssb_bus *bus, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&bus->gpio_lock, flags);\n\tif (ssb_chipco_available(&bus->chipco))\n\t\tres = ssb_chipco_gpio_outen(&bus->chipco, mask, value);\n\telse if (ssb_extif_available(&bus->extif))\n\t\tres = ssb_extif_gpio_outen(&bus->extif, mask, value);\n\telse\n\t\tWARN_ON(1);\n\tspin_unlock_irqrestore(&bus->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(ssb_gpio_outen);\n\nu32 ssb_gpio_control(struct ssb_bus *bus, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&bus->gpio_lock, flags);\n\tif (ssb_chipco_available(&bus->chipco))\n\t\tres = ssb_chipco_gpio_control(&bus->chipco, mask, value);\n\tspin_unlock_irqrestore(&bus->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(ssb_gpio_control);\n\nu32 ssb_gpio_intmask(struct ssb_bus *bus, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&bus->gpio_lock, flags);\n\tif (ssb_chipco_available(&bus->chipco))\n\t\tres = ssb_chipco_gpio_intmask(&bus->chipco, mask, value);\n\telse if (ssb_extif_available(&bus->extif))\n\t\tres = ssb_extif_gpio_intmask(&bus->extif, mask, value);\n\telse\n\t\tWARN_ON(1);\n\tspin_unlock_irqrestore(&bus->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(ssb_gpio_intmask);\n\nu32 ssb_gpio_polarity(struct ssb_bus *bus, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&bus->gpio_lock, flags);\n\tif (ssb_chipco_available(&bus->chipco))\n\t\tres = ssb_chipco_gpio_polarity(&bus->chipco, mask, value);\n\telse if (ssb_extif_available(&bus->extif))\n\t\tres = ssb_extif_gpio_polarity(&bus->extif, mask, value);\n\telse\n\t\tWARN_ON(1);\n\tspin_unlock_irqrestore(&bus->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(ssb_gpio_polarity);\n\n#ifdef CONFIG_SSB_DRIVER_GIGE\nstatic int gige_pci_init_callback(struct ssb_bus *bus, unsigned long data)\n{\n\tstruct pci_dev *pdev = (struct pci_dev *)data;\n\tstruct ssb_device *dev;\n\tunsigned int i;\n\tint res;\n\n\tfor (i = 0; i < bus->nr_devices; i++) {\n\t\tdev = &(bus->devices[i]);\n\t\tif (dev->id.coreid != SSB_DEV_ETHERNET_GBIT)\n\t\t\tcontinue;\n\t\tif (!dev->dev ||\n\t\t    !dev->dev->driver ||\n\t\t    !device_is_registered(dev->dev))\n\t\t\tcontinue;\n\t\tres = ssb_gige_pcibios_plat_dev_init(dev, pdev);\n\t\tif (res >= 0)\n\t\t\treturn res;\n\t}\n\n\treturn -ENODEV;\n}\n#endif  \n\nint ssb_pcibios_plat_dev_init(struct pci_dev *dev)\n{\n\tint err;\n\n\terr = ssb_pcicore_plat_dev_init(dev);\n\tif (!err)\n\t\treturn 0;\n#ifdef CONFIG_SSB_DRIVER_GIGE\n\terr = ssb_for_each_bus_call((unsigned long)dev, gige_pci_init_callback);\n\tif (err >= 0)\n\t\treturn err;\n#endif\n\t \n\n\treturn -ENODEV;\n}\n\n#ifdef CONFIG_SSB_DRIVER_GIGE\nstatic int gige_map_irq_callback(struct ssb_bus *bus, unsigned long data)\n{\n\tconst struct pci_dev *pdev = (const struct pci_dev *)data;\n\tstruct ssb_device *dev;\n\tunsigned int i;\n\tint res;\n\n\tfor (i = 0; i < bus->nr_devices; i++) {\n\t\tdev = &(bus->devices[i]);\n\t\tif (dev->id.coreid != SSB_DEV_ETHERNET_GBIT)\n\t\t\tcontinue;\n\t\tif (!dev->dev ||\n\t\t    !dev->dev->driver ||\n\t\t    !device_is_registered(dev->dev))\n\t\t\tcontinue;\n\t\tres = ssb_gige_map_irq(dev, pdev);\n\t\tif (res >= 0)\n\t\t\treturn res;\n\t}\n\n\treturn -ENODEV;\n}\n#endif  \n\nint ssb_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\n{\n\tint res;\n\n\t \n\n\tres = ssb_pcicore_pcibios_map_irq(dev, slot, pin);\n\tif (res >= 0)\n\t\treturn res;\n#ifdef CONFIG_SSB_DRIVER_GIGE\n\tres = ssb_for_each_bus_call((unsigned long)dev, gige_map_irq_callback);\n\tif (res >= 0)\n\t\treturn res;\n#endif\n\t \n\n\treturn -ENODEV;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}