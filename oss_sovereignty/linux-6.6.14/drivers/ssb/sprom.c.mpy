{
  "module_name": "sprom.c",
  "hash_id": "74c46fbbe7c6bb3d315f406ff82797bd6be568548e50846fd36d6b485e3392b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/sprom.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\n\nstatic int(*get_fallback_sprom)(struct ssb_bus *dev, struct ssb_sprom *out);\n\n\nstatic int sprom2hex(const u16 *sprom, char *buf, size_t buf_len,\n\t\t     size_t sprom_size_words)\n{\n\tint i, pos = 0;\n\n\tfor (i = 0; i < sprom_size_words; i++)\n\t\tpos += scnprintf(buf + pos, buf_len - pos - 1,\n\t\t\t\t\"%04X\", swab16(sprom[i]) & 0xFFFF);\n\tpos += scnprintf(buf + pos, buf_len - pos - 1, \"\\n\");\n\n\treturn pos + 1;\n}\n\nstatic int hex2sprom(u16 *sprom, const char *dump, size_t len,\n\t\t     size_t sprom_size_words)\n{\n\tchar c, tmp[5] = { 0 };\n\tint err, cnt = 0;\n\tunsigned long parsed;\n\n\t \n\twhile (len) {\n\t\tc = dump[len - 1];\n\t\tif (!isspace(c) && c != '\\0')\n\t\t\tbreak;\n\t\tlen--;\n\t}\n\t \n\tif (len != sprom_size_words * 4)\n\t\treturn -EINVAL;\n\n\twhile (cnt < sprom_size_words) {\n\t\tmemcpy(tmp, dump, 4);\n\t\tdump += 4;\n\t\terr = kstrtoul(tmp, 16, &parsed);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsprom[cnt++] = swab16((u16)parsed);\n\t}\n\n\treturn 0;\n}\n\n \nssize_t ssb_attr_sprom_show(struct ssb_bus *bus, char *buf,\n\t\t\t    int (*sprom_read)(struct ssb_bus *bus, u16 *sprom))\n{\n\tu16 *sprom;\n\tint err = -ENOMEM;\n\tssize_t count = 0;\n\tsize_t sprom_size_words = bus->sprom_size;\n\n\tsprom = kcalloc(sprom_size_words, sizeof(u16), GFP_KERNEL);\n\tif (!sprom)\n\t\tgoto out;\n\n\t \n\terr = -ERESTARTSYS;\n\tif (mutex_lock_interruptible(&bus->sprom_mutex))\n\t\tgoto out_kfree;\n\terr = sprom_read(bus, sprom);\n\tmutex_unlock(&bus->sprom_mutex);\n\n\tif (!err)\n\t\tcount = sprom2hex(sprom, buf, PAGE_SIZE, sprom_size_words);\n\nout_kfree:\n\tkfree(sprom);\nout:\n\treturn err ? err : count;\n}\n\n \nssize_t ssb_attr_sprom_store(struct ssb_bus *bus,\n\t\t\t     const char *buf, size_t count,\n\t\t\t     int (*sprom_check_crc)(const u16 *sprom, size_t size),\n\t\t\t     int (*sprom_write)(struct ssb_bus *bus, const u16 *sprom))\n{\n\tu16 *sprom;\n\tint res = 0, err = -ENOMEM;\n\tsize_t sprom_size_words = bus->sprom_size;\n\tstruct ssb_freeze_context freeze;\n\n\tsprom = kcalloc(bus->sprom_size, sizeof(u16), GFP_KERNEL);\n\tif (!sprom)\n\t\tgoto out;\n\terr = hex2sprom(sprom, buf, count, sprom_size_words);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_kfree;\n\t}\n\terr = sprom_check_crc(sprom, sprom_size_words);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_kfree;\n\t}\n\n\t \n\terr = -ERESTARTSYS;\n\tif (mutex_lock_interruptible(&bus->sprom_mutex))\n\t\tgoto out_kfree;\n\terr = ssb_devices_freeze(bus, &freeze);\n\tif (err) {\n\t\tpr_err(\"SPROM write: Could not freeze all devices\\n\");\n\t\tgoto out_unlock;\n\t}\n\tres = sprom_write(bus, sprom);\n\terr = ssb_devices_thaw(&freeze);\n\tif (err)\n\t\tpr_err(\"SPROM write: Could not thaw all devices\\n\");\nout_unlock:\n\tmutex_unlock(&bus->sprom_mutex);\nout_kfree:\n\tkfree(sprom);\nout:\n\tif (res)\n\t\treturn res;\n\treturn err ? err : count;\n}\n\n \nint ssb_arch_register_fallback_sprom(int (*sprom_callback)(struct ssb_bus *bus,\n\t\t\t\t     struct ssb_sprom *out))\n{\n\tif (get_fallback_sprom)\n\t\treturn -EEXIST;\n\tget_fallback_sprom = sprom_callback;\n\n\treturn 0;\n}\n\nint ssb_fill_sprom_with_fallback(struct ssb_bus *bus, struct ssb_sprom *out)\n{\n\tif (!get_fallback_sprom)\n\t\treturn -ENOENT;\n\n\treturn get_fallback_sprom(bus, out);\n}\n\n \n\t \n\tif (bus->bustype == SSB_BUSTYPE_PCI &&\n\t    bus->chipco.dev &&\t \n\t    bus->chipco.dev->id.revision >= 31)\n\t\treturn bus->chipco.capabilities & SSB_CHIPCO_CAP_SPROM;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}