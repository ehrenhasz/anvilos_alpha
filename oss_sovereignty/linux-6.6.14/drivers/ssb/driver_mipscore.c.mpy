{
  "module_name": "driver_mipscore.c",
  "hash_id": "337338fa2e784e06cfbda1dc78b313e03aa5d4c9563aef7e7c66447c3876ec4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/driver_mipscore.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/ssb/ssb.h>\n\n#include <linux/mtd/physmap.h>\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n#include <linux/time.h>\n#ifdef CONFIG_BCM47XX\n#include <linux/bcm47xx_nvram.h>\n#endif\n\nstatic const char * const part_probes[] = { \"bcm47xxpart\", NULL };\n\nstatic struct physmap_flash_data ssb_pflash_data = {\n\t.part_probe_types\t= part_probes,\n};\n\nstatic struct resource ssb_pflash_resource = {\n\t.name\t= \"ssb_pflash\",\n\t.flags  = IORESOURCE_MEM,\n};\n\nstruct platform_device ssb_pflash_dev = {\n\t.name\t\t= \"physmap-flash\",\n\t.dev\t\t= {\n\t\t.platform_data  = &ssb_pflash_data,\n\t},\n\t.resource\t= &ssb_pflash_resource,\n\t.num_resources\t= 1,\n};\n\nstatic inline u32 mips_read32(struct ssb_mipscore *mcore,\n\t\t\t      u16 offset)\n{\n\treturn ssb_read32(mcore->dev, offset);\n}\n\nstatic inline void mips_write32(struct ssb_mipscore *mcore,\n\t\t\t\tu16 offset,\n\t\t\t\tu32 value)\n{\n\tssb_write32(mcore->dev, offset, value);\n}\n\nstatic const u32 ipsflag_irq_mask[] = {\n\t0,\n\tSSB_IPSFLAG_IRQ1,\n\tSSB_IPSFLAG_IRQ2,\n\tSSB_IPSFLAG_IRQ3,\n\tSSB_IPSFLAG_IRQ4,\n};\n\nstatic const u32 ipsflag_irq_shift[] = {\n\t0,\n\tSSB_IPSFLAG_IRQ1_SHIFT,\n\tSSB_IPSFLAG_IRQ2_SHIFT,\n\tSSB_IPSFLAG_IRQ3_SHIFT,\n\tSSB_IPSFLAG_IRQ4_SHIFT,\n};\n\nstatic inline u32 ssb_irqflag(struct ssb_device *dev)\n{\n\tu32 tpsflag = ssb_read32(dev, SSB_TPSFLAG);\n\tif (tpsflag)\n\t\treturn ssb_read32(dev, SSB_TPSFLAG) & SSB_TPSFLAG_BPFLAG;\n\telse\n\t\t \n\t\treturn 0x3f;\n}\n\nstatic struct ssb_device *find_device(struct ssb_device *rdev, int irqflag)\n{\n\tstruct ssb_bus *bus = rdev->bus;\n\tint i;\n\tfor (i = 0; i < bus->nr_devices; i++) {\n\t\tstruct ssb_device *dev;\n\t\tdev = &(bus->devices[i]);\n\t\tif (ssb_irqflag(dev) == irqflag)\n\t\t\treturn dev;\n\t}\n\treturn NULL;\n}\n\n \nunsigned int ssb_mips_irq(struct ssb_device *dev)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tstruct ssb_device *mdev = bus->mipscore.dev;\n\tu32 irqflag;\n\tu32 ipsflag;\n\tu32 tmp;\n\tunsigned int irq;\n\n\tirqflag = ssb_irqflag(dev);\n\tif (irqflag == 0x3f)\n\t\treturn 6;\n\tipsflag = ssb_read32(bus->mipscore.dev, SSB_IPSFLAG);\n\tfor (irq = 1; irq <= 4; irq++) {\n\t\ttmp = ((ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq]);\n\t\tif (tmp == irqflag)\n\t\t\tbreak;\n\t}\n\tif (irq\t== 5) {\n\t\tif ((1 << irqflag) & ssb_read32(mdev, SSB_INTVEC))\n\t\t\tirq = 0;\n\t}\n\n\treturn irq;\n}\n\nstatic void clear_irq(struct ssb_bus *bus, unsigned int irq)\n{\n\tstruct ssb_device *dev = bus->mipscore.dev;\n\n\t \n\tif (irq == 0) {\n\t\tssb_write32(dev, SSB_INTVEC, 0);\n\t} else {\n\t\tssb_write32(dev, SSB_IPSFLAG,\n\t\t\t    ssb_read32(dev, SSB_IPSFLAG) |\n\t\t\t    ipsflag_irq_mask[irq]);\n\t}\n}\n\nstatic void set_irq(struct ssb_device *dev, unsigned int irq)\n{\n\tunsigned int oldirq = ssb_mips_irq(dev);\n\tstruct ssb_bus *bus = dev->bus;\n\tstruct ssb_device *mdev = bus->mipscore.dev;\n\tu32 irqflag = ssb_irqflag(dev);\n\n\tBUG_ON(oldirq == 6);\n\n\tdev->irq = irq + 2;\n\n\t \n\tif (oldirq == 0)\n\t\tssb_write32(mdev, SSB_INTVEC, (~(1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));\n\telse if (oldirq != 5)\n\t\tclear_irq(bus, oldirq);\n\n\t \n\tif (irq == 0) {\n\t\tssb_write32(mdev, SSB_INTVEC, ((1 << irqflag) | ssb_read32(mdev, SSB_INTVEC)));\n\t} else {\n\t\tu32 ipsflag = ssb_read32(mdev, SSB_IPSFLAG);\n\t\tif ((ipsflag & ipsflag_irq_mask[irq]) != ipsflag_irq_mask[irq]) {\n\t\t\tu32 oldipsflag = (ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq];\n\t\t\tstruct ssb_device *olddev = find_device(dev, oldipsflag);\n\t\t\tif (olddev)\n\t\t\t\tset_irq(olddev, 0);\n\t\t}\n\t\tirqflag <<= ipsflag_irq_shift[irq];\n\t\tirqflag |= (ipsflag & ~ipsflag_irq_mask[irq]);\n\t\tssb_write32(mdev, SSB_IPSFLAG, irqflag);\n\t}\n\tdev_dbg(dev->dev, \"set_irq: core 0x%04x, irq %d => %d\\n\",\n\t\tdev->id.coreid, oldirq+2, irq+2);\n}\n\nstatic void print_irq(struct ssb_device *dev, unsigned int irq)\n{\n\tstatic const char *irq_name[] = {\"2(S)\", \"3\", \"4\", \"5\", \"6\", \"D\", \"I\"};\n\tdev_dbg(dev->dev,\n\t\t\"core 0x%04x, irq : %s%s %s%s %s%s %s%s %s%s %s%s %s%s\\n\",\n\t\tdev->id.coreid,\n\t\tirq_name[0], irq == 0 ? \"*\" : \" \",\n\t\tirq_name[1], irq == 1 ? \"*\" : \" \",\n\t\tirq_name[2], irq == 2 ? \"*\" : \" \",\n\t\tirq_name[3], irq == 3 ? \"*\" : \" \",\n\t\tirq_name[4], irq == 4 ? \"*\" : \" \",\n\t\tirq_name[5], irq == 5 ? \"*\" : \" \",\n\t\tirq_name[6], irq == 6 ? \"*\" : \" \");\n}\n\nstatic void dump_irq(struct ssb_bus *bus)\n{\n\tint i;\n\tfor (i = 0; i < bus->nr_devices; i++) {\n\t\tstruct ssb_device *dev;\n\t\tdev = &(bus->devices[i]);\n\t\tprint_irq(dev, ssb_mips_irq(dev));\n\t}\n}\n\nstatic void ssb_mips_serial_init(struct ssb_mipscore *mcore)\n{\n\tstruct ssb_bus *bus = mcore->dev->bus;\n\n\tif (ssb_extif_available(&bus->extif))\n\t\tmcore->nr_serial_ports = ssb_extif_serial_init(&bus->extif, mcore->serial_ports);\n\telse if (ssb_chipco_available(&bus->chipco))\n\t\tmcore->nr_serial_ports = ssb_chipco_serial_init(&bus->chipco, mcore->serial_ports);\n\telse\n\t\tmcore->nr_serial_ports = 0;\n}\n\nstatic void ssb_mips_flash_detect(struct ssb_mipscore *mcore)\n{\n\tstruct ssb_bus *bus = mcore->dev->bus;\n\tstruct ssb_sflash *sflash = &mcore->sflash;\n\tstruct ssb_pflash *pflash = &mcore->pflash;\n\n\t \n\tif (!ssb_chipco_available(&bus->chipco)) {\n\t\tpflash->present = true;\n\t\tpflash->buswidth = 2;\n\t\tpflash->window = SSB_FLASH1;\n\t\tpflash->window_size = SSB_FLASH1_SZ;\n\t\tgoto ssb_pflash;\n\t}\n\n\t \n\tswitch (bus->chipco.capabilities & SSB_CHIPCO_CAP_FLASHT) {\n\tcase SSB_CHIPCO_FLASHT_STSER:\n\tcase SSB_CHIPCO_FLASHT_ATSER:\n\t\tdev_dbg(mcore->dev->dev, \"Found serial flash\\n\");\n\t\tssb_sflash_init(&bus->chipco);\n\t\tbreak;\n\tcase SSB_CHIPCO_FLASHT_PARA:\n\t\tdev_dbg(mcore->dev->dev, \"Found parallel flash\\n\");\n\t\tpflash->present = true;\n\t\tpflash->window = SSB_FLASH2;\n\t\tpflash->window_size = SSB_FLASH2_SZ;\n\t\tif ((ssb_read32(bus->chipco.dev, SSB_CHIPCO_FLASH_CFG)\n\t\t               & SSB_CHIPCO_CFG_DS16) == 0)\n\t\t\tpflash->buswidth = 1;\n\t\telse\n\t\t\tpflash->buswidth = 2;\n\t\tbreak;\n\t}\n\nssb_pflash:\n\tif (sflash->present) {\n#ifdef CONFIG_BCM47XX\n\t\tbcm47xx_nvram_init_from_mem(sflash->window, sflash->size);\n#endif\n\t} else if (pflash->present) {\n#ifdef CONFIG_BCM47XX\n\t\tbcm47xx_nvram_init_from_mem(pflash->window, pflash->window_size);\n#endif\n\n\t\tssb_pflash_data.width = pflash->buswidth;\n\t\tssb_pflash_resource.start = pflash->window;\n\t\tssb_pflash_resource.end = pflash->window + pflash->window_size;\n\t}\n}\n\nu32 ssb_cpu_clock(struct ssb_mipscore *mcore)\n{\n\tstruct ssb_bus *bus = mcore->dev->bus;\n\tu32 pll_type, n, m, rate = 0;\n\n\tif (bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU)\n\t\treturn ssb_pmu_get_cpu_clock(&bus->chipco);\n\n\tif (ssb_extif_available(&bus->extif)) {\n\t\tssb_extif_get_clockcontrol(&bus->extif, &pll_type, &n, &m);\n\t} else if (ssb_chipco_available(&bus->chipco)) {\n\t\tssb_chipco_get_clockcpu(&bus->chipco, &pll_type, &n, &m);\n\t} else\n\t\treturn 0;\n\n\tif ((pll_type == SSB_PLLTYPE_5) || (bus->chip_id == 0x5365)) {\n\t\trate = 200000000;\n\t} else {\n\t\trate = ssb_calc_clock_rate(pll_type, n, m);\n\t}\n\n\tif (pll_type == SSB_PLLTYPE_6) {\n\t\trate *= 2;\n\t}\n\n\treturn rate;\n}\n\nvoid ssb_mipscore_init(struct ssb_mipscore *mcore)\n{\n\tstruct ssb_bus *bus;\n\tstruct ssb_device *dev;\n\tunsigned long hz, ns;\n\tunsigned int irq, i;\n\n\tif (!mcore->dev)\n\t\treturn;  \n\n\tdev_dbg(mcore->dev->dev, \"Initializing MIPS core...\\n\");\n\n\tbus = mcore->dev->bus;\n\thz = ssb_clockspeed(bus);\n\tif (!hz)\n\t\thz = 100000000;\n\tns = 1000000000 / hz;\n\n\tif (ssb_extif_available(&bus->extif))\n\t\tssb_extif_timing_init(&bus->extif, ns);\n\telse if (ssb_chipco_available(&bus->chipco))\n\t\tssb_chipco_timing_init(&bus->chipco, ns);\n\n\t \n\tfor (irq = 2, i = 0; i < bus->nr_devices; i++) {\n\t\tint mips_irq;\n\t\tdev = &(bus->devices[i]);\n\t\tmips_irq = ssb_mips_irq(dev);\n\t\tif (mips_irq > 4)\n\t\t\tdev->irq = 0;\n\t\telse\n\t\t\tdev->irq = mips_irq + 2;\n\t\tif (dev->irq > 5)\n\t\t\tcontinue;\n\t\tswitch (dev->id.coreid) {\n\t\tcase SSB_DEV_USB11_HOST:\n\t\t\t \n\t\t\tif ((bus->chip_id == 0x4710) && (irq <= 4)) {\n\t\t\t\tset_irq(dev, irq++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSB_DEV_PCI:\n\t\tcase SSB_DEV_ETHERNET:\n\t\tcase SSB_DEV_ETHERNET_GBIT:\n\t\tcase SSB_DEV_80211:\n\t\tcase SSB_DEV_USB20_HOST:\n\t\t\t \n\t\t\tif (irq <= 4) {\n\t\t\t\tset_irq(dev, irq++);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase SSB_DEV_EXTIF:\n\t\t\tset_irq(dev, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdev_dbg(mcore->dev->dev, \"after irq reconfiguration\\n\");\n\tdump_irq(bus);\n\n\tssb_mips_serial_init(mcore);\n\tssb_mips_flash_detect(mcore);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}