{
  "module_name": "host_soc.c",
  "hash_id": "268efac85e0cb587daaefff7696fce7ad97a61542d41f9d86bd54fa8cacf1a80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/host_soc.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/bcm47xx_nvram.h>\n#include <linux/ssb/ssb.h>\n\nstatic u8 ssb_host_soc_read8(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\n\toffset += dev->core_index * SSB_CORE_SIZE;\n\treturn readb(bus->mmio + offset);\n}\n\nstatic u16 ssb_host_soc_read16(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\n\toffset += dev->core_index * SSB_CORE_SIZE;\n\treturn readw(bus->mmio + offset);\n}\n\nstatic u32 ssb_host_soc_read32(struct ssb_device *dev, u16 offset)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\n\toffset += dev->core_index * SSB_CORE_SIZE;\n\treturn readl(bus->mmio + offset);\n}\n\n#ifdef CONFIG_SSB_BLOCKIO\nstatic void ssb_host_soc_block_read(struct ssb_device *dev, void *buffer,\n\t\t\t\t    size_t count, u16 offset, u8 reg_width)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tvoid __iomem *addr;\n\n\toffset += dev->core_index * SSB_CORE_SIZE;\n\taddr = bus->mmio + offset;\n\n\tswitch (reg_width) {\n\tcase sizeof(u8): {\n\t\tu8 *buf = buffer;\n\n\t\twhile (count) {\n\t\t\t*buf = __raw_readb(addr);\n\t\t\tbuf++;\n\t\t\tcount--;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u16): {\n\t\t__le16 *buf = buffer;\n\n\t\tWARN_ON(count & 1);\n\t\twhile (count) {\n\t\t\t*buf = (__force __le16)__raw_readw(addr);\n\t\t\tbuf++;\n\t\t\tcount -= 2;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u32): {\n\t\t__le32 *buf = buffer;\n\n\t\tWARN_ON(count & 3);\n\t\twhile (count) {\n\t\t\t*buf = (__force __le32)__raw_readl(addr);\n\t\t\tbuf++;\n\t\t\tcount -= 4;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n#endif  \n\nstatic void ssb_host_soc_write8(struct ssb_device *dev, u16 offset, u8 value)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\n\toffset += dev->core_index * SSB_CORE_SIZE;\n\twriteb(value, bus->mmio + offset);\n}\n\nstatic void ssb_host_soc_write16(struct ssb_device *dev, u16 offset, u16 value)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\n\toffset += dev->core_index * SSB_CORE_SIZE;\n\twritew(value, bus->mmio + offset);\n}\n\nstatic void ssb_host_soc_write32(struct ssb_device *dev, u16 offset, u32 value)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\n\toffset += dev->core_index * SSB_CORE_SIZE;\n\twritel(value, bus->mmio + offset);\n}\n\n#ifdef CONFIG_SSB_BLOCKIO\nstatic void ssb_host_soc_block_write(struct ssb_device *dev, const void *buffer,\n\t\t\t\t     size_t count, u16 offset, u8 reg_width)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tvoid __iomem *addr;\n\n\toffset += dev->core_index * SSB_CORE_SIZE;\n\taddr = bus->mmio + offset;\n\n\tswitch (reg_width) {\n\tcase sizeof(u8): {\n\t\tconst u8 *buf = buffer;\n\n\t\twhile (count) {\n\t\t\t__raw_writeb(*buf, addr);\n\t\t\tbuf++;\n\t\t\tcount--;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u16): {\n\t\tconst __le16 *buf = buffer;\n\n\t\tWARN_ON(count & 1);\n\t\twhile (count) {\n\t\t\t__raw_writew((__force u16)(*buf), addr);\n\t\t\tbuf++;\n\t\t\tcount -= 2;\n\t\t}\n\t\tbreak;\n\t}\n\tcase sizeof(u32): {\n\t\tconst __le32 *buf = buffer;\n\n\t\tWARN_ON(count & 3);\n\t\twhile (count) {\n\t\t\t__raw_writel((__force u32)(*buf), addr);\n\t\t\tbuf++;\n\t\t\tcount -= 4;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n#endif  \n\n \nconst struct ssb_bus_ops ssb_host_soc_ops = {\n\t.read8\t\t= ssb_host_soc_read8,\n\t.read16\t\t= ssb_host_soc_read16,\n\t.read32\t\t= ssb_host_soc_read32,\n\t.write8\t\t= ssb_host_soc_write8,\n\t.write16\t= ssb_host_soc_write16,\n\t.write32\t= ssb_host_soc_write32,\n#ifdef CONFIG_SSB_BLOCKIO\n\t.block_read\t= ssb_host_soc_block_read,\n\t.block_write\t= ssb_host_soc_block_write,\n#endif\n};\n\nint ssb_host_soc_get_invariants(struct ssb_bus *bus,\n\t\t\t\tstruct ssb_init_invariants *iv)\n{\n\tchar buf[20];\n\tint len, err;\n\n\t \n\tmemset(&iv->boardinfo, 0, sizeof(struct ssb_boardinfo));\n\n\tlen = bcm47xx_nvram_getenv(\"boardvendor\", buf, sizeof(buf));\n\tif (len > 0) {\n\t\terr = kstrtou16(strim(buf), 0, &iv->boardinfo.vendor);\n\t\tif (err)\n\t\t\tpr_warn(\"Couldn't parse nvram board vendor entry with value \\\"%s\\\"\\n\",\n\t\t\t\tbuf);\n\t}\n\tif (!iv->boardinfo.vendor)\n\t\tiv->boardinfo.vendor = SSB_BOARDVENDOR_BCM;\n\n\tlen = bcm47xx_nvram_getenv(\"boardtype\", buf, sizeof(buf));\n\tif (len > 0) {\n\t\terr = kstrtou16(strim(buf), 0, &iv->boardinfo.type);\n\t\tif (err)\n\t\t\tpr_warn(\"Couldn't parse nvram board type entry with value \\\"%s\\\"\\n\",\n\t\t\t\tbuf);\n\t}\n\n\tmemset(&iv->sprom, 0, sizeof(struct ssb_sprom));\n\tssb_fill_sprom_with_fallback(bus, &iv->sprom);\n\n\tif (bcm47xx_nvram_getenv(\"cardbus\", buf, sizeof(buf)) >= 0)\n\t\tiv->has_cardbus_slot = !!simple_strtoul(buf, NULL, 10);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}