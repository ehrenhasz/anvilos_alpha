{
  "module_name": "main.c",
  "hash_id": "621a6dc837d929e44dd22ba1c9e3b4e2a027a3a557926660acf1bebd08aaa9aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/main.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/ssb/ssb.h>\n#include <linux/ssb/ssb_regs.h>\n#include <linux/ssb/ssb_driver_gige.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/slab.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n\n\nMODULE_DESCRIPTION(\"Sonics Silicon Backplane driver\");\nMODULE_LICENSE(\"GPL\");\n\n\n \nstatic LIST_HEAD(attach_queue);\n \nstatic LIST_HEAD(buses);\n \nstatic unsigned int next_busnumber;\n \nstatic DEFINE_MUTEX(buses_mutex);\n\n \nstatic bool ssb_is_early_boot = 1;\n\nstatic void ssb_buses_lock(void);\nstatic void ssb_buses_unlock(void);\n\n\n#ifdef CONFIG_SSB_PCIHOST\nstruct ssb_bus *ssb_pci_dev_to_bus(struct pci_dev *pdev)\n{\n\tstruct ssb_bus *bus;\n\n\tssb_buses_lock();\n\tlist_for_each_entry(bus, &buses, list) {\n\t\tif (bus->bustype == SSB_BUSTYPE_PCI &&\n\t\t    bus->host_pci == pdev)\n\t\t\tgoto found;\n\t}\n\tbus = NULL;\nfound:\n\tssb_buses_unlock();\n\n\treturn bus;\n}\n#endif  \n\n#ifdef CONFIG_SSB_PCMCIAHOST\nstruct ssb_bus *ssb_pcmcia_dev_to_bus(struct pcmcia_device *pdev)\n{\n\tstruct ssb_bus *bus;\n\n\tssb_buses_lock();\n\tlist_for_each_entry(bus, &buses, list) {\n\t\tif (bus->bustype == SSB_BUSTYPE_PCMCIA &&\n\t\t    bus->host_pcmcia == pdev)\n\t\t\tgoto found;\n\t}\n\tbus = NULL;\nfound:\n\tssb_buses_unlock();\n\n\treturn bus;\n}\n#endif  \n\nint ssb_for_each_bus_call(unsigned long data,\n\t\t\t  int (*func)(struct ssb_bus *bus, unsigned long data))\n{\n\tstruct ssb_bus *bus;\n\tint res;\n\n\tssb_buses_lock();\n\tlist_for_each_entry(bus, &buses, list) {\n\t\tres = func(bus, data);\n\t\tif (res >= 0) {\n\t\t\tssb_buses_unlock();\n\t\t\treturn res;\n\t\t}\n\t}\n\tssb_buses_unlock();\n\n\treturn -ENODEV;\n}\n\nstatic struct ssb_device *ssb_device_get(struct ssb_device *dev)\n{\n\tif (dev)\n\t\tget_device(dev->dev);\n\treturn dev;\n}\n\nstatic void ssb_device_put(struct ssb_device *dev)\n{\n\tif (dev)\n\t\tput_device(dev->dev);\n}\n\nstatic int ssb_device_resume(struct device *dev)\n{\n\tstruct ssb_device *ssb_dev = dev_to_ssb_dev(dev);\n\tstruct ssb_driver *ssb_drv;\n\tint err = 0;\n\n\tif (dev->driver) {\n\t\tssb_drv = drv_to_ssb_drv(dev->driver);\n\t\tif (ssb_drv && ssb_drv->resume)\n\t\t\terr = ssb_drv->resume(ssb_dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\treturn err;\n}\n\nstatic int ssb_device_suspend(struct device *dev, pm_message_t state)\n{\n\tstruct ssb_device *ssb_dev = dev_to_ssb_dev(dev);\n\tstruct ssb_driver *ssb_drv;\n\tint err = 0;\n\n\tif (dev->driver) {\n\t\tssb_drv = drv_to_ssb_drv(dev->driver);\n\t\tif (ssb_drv && ssb_drv->suspend)\n\t\t\terr = ssb_drv->suspend(ssb_dev, state);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\treturn err;\n}\n\nint ssb_bus_resume(struct ssb_bus *bus)\n{\n\tint err;\n\n\t \n\tbus->mapped_device = NULL;\n#ifdef CONFIG_SSB_DRIVER_PCICORE\n\tbus->pcicore.setup_done = 0;\n#endif\n\n\terr = ssb_bus_powerup(bus, 0);\n\tif (err)\n\t\treturn err;\n\terr = ssb_pcmcia_hardware_setup(bus);\n\tif (err) {\n\t\tssb_bus_may_powerdown(bus);\n\t\treturn err;\n\t}\n\tssb_chipco_resume(&bus->chipco);\n\tssb_bus_may_powerdown(bus);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ssb_bus_resume);\n\nint ssb_bus_suspend(struct ssb_bus *bus)\n{\n\tssb_chipco_suspend(&bus->chipco);\n\tssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ssb_bus_suspend);\n\n#ifdef CONFIG_SSB_SPROM\n \nint ssb_devices_freeze(struct ssb_bus *bus, struct ssb_freeze_context *ctx)\n{\n\tstruct ssb_device *sdev;\n\tstruct ssb_driver *sdrv;\n\tunsigned int i;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->bus = bus;\n\tWARN_ON(bus->nr_devices > ARRAY_SIZE(ctx->device_frozen));\n\n\tfor (i = 0; i < bus->nr_devices; i++) {\n\t\tsdev = ssb_device_get(&bus->devices[i]);\n\n\t\tif (!sdev->dev || !sdev->dev->driver ||\n\t\t    !device_is_registered(sdev->dev)) {\n\t\t\tssb_device_put(sdev);\n\t\t\tcontinue;\n\t\t}\n\t\tsdrv = drv_to_ssb_drv(sdev->dev->driver);\n\t\tif (WARN_ON(!sdrv->remove))\n\t\t\tcontinue;\n\t\tsdrv->remove(sdev);\n\t\tctx->device_frozen[i] = 1;\n\t}\n\n\treturn 0;\n}\n\n \nint ssb_devices_thaw(struct ssb_freeze_context *ctx)\n{\n\tstruct ssb_bus *bus = ctx->bus;\n\tstruct ssb_device *sdev;\n\tstruct ssb_driver *sdrv;\n\tunsigned int i;\n\tint err, result = 0;\n\n\tfor (i = 0; i < bus->nr_devices; i++) {\n\t\tif (!ctx->device_frozen[i])\n\t\t\tcontinue;\n\t\tsdev = &bus->devices[i];\n\n\t\tif (WARN_ON(!sdev->dev || !sdev->dev->driver))\n\t\t\tcontinue;\n\t\tsdrv = drv_to_ssb_drv(sdev->dev->driver);\n\t\tif (WARN_ON(!sdrv || !sdrv->probe))\n\t\t\tcontinue;\n\n\t\terr = sdrv->probe(sdev, &sdev->id);\n\t\tif (err) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"Failed to thaw device %s\\n\",\n\t\t\t\tdev_name(sdev->dev));\n\t\t\tresult = err;\n\t\t}\n\t\tssb_device_put(sdev);\n\t}\n\n\treturn result;\n}\n#endif  \n\nstatic void ssb_device_shutdown(struct device *dev)\n{\n\tstruct ssb_device *ssb_dev = dev_to_ssb_dev(dev);\n\tstruct ssb_driver *ssb_drv;\n\n\tif (!dev->driver)\n\t\treturn;\n\tssb_drv = drv_to_ssb_drv(dev->driver);\n\tif (ssb_drv && ssb_drv->shutdown)\n\t\tssb_drv->shutdown(ssb_dev);\n}\n\nstatic void ssb_device_remove(struct device *dev)\n{\n\tstruct ssb_device *ssb_dev = dev_to_ssb_dev(dev);\n\tstruct ssb_driver *ssb_drv = drv_to_ssb_drv(dev->driver);\n\n\tif (ssb_drv && ssb_drv->remove)\n\t\tssb_drv->remove(ssb_dev);\n\tssb_device_put(ssb_dev);\n}\n\nstatic int ssb_device_probe(struct device *dev)\n{\n\tstruct ssb_device *ssb_dev = dev_to_ssb_dev(dev);\n\tstruct ssb_driver *ssb_drv = drv_to_ssb_drv(dev->driver);\n\tint err = 0;\n\n\tssb_device_get(ssb_dev);\n\tif (ssb_drv && ssb_drv->probe)\n\t\terr = ssb_drv->probe(ssb_dev, &ssb_dev->id);\n\tif (err)\n\t\tssb_device_put(ssb_dev);\n\n\treturn err;\n}\n\nstatic int ssb_match_devid(const struct ssb_device_id *tabid,\n\t\t\t   const struct ssb_device_id *devid)\n{\n\tif ((tabid->vendor != devid->vendor) &&\n\t    tabid->vendor != SSB_ANY_VENDOR)\n\t\treturn 0;\n\tif ((tabid->coreid != devid->coreid) &&\n\t    tabid->coreid != SSB_ANY_ID)\n\t\treturn 0;\n\tif ((tabid->revision != devid->revision) &&\n\t    tabid->revision != SSB_ANY_REV)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int ssb_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct ssb_device *ssb_dev = dev_to_ssb_dev(dev);\n\tstruct ssb_driver *ssb_drv = drv_to_ssb_drv(drv);\n\tconst struct ssb_device_id *id;\n\n\tfor (id = ssb_drv->id_table;\n\t     id->vendor || id->coreid || id->revision;\n\t     id++) {\n\t\tif (ssb_match_devid(id, &ssb_dev->id))\n\t\t\treturn 1;  \n\t}\n\n\treturn 0;\n}\n\nstatic int ssb_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\treturn add_uevent_var(env,\n\t\t\t     \"MODALIAS=ssb:v%04Xid%04Xrev%02X\",\n\t\t\t     ssb_dev->id.vendor, ssb_dev->id.coreid,\n\t\t\t     ssb_dev->id.revision);\n}\n\n#define ssb_config_attr(attrib, field, format_string) \\\nstatic ssize_t \\\nattrib##_show(struct device *dev, struct device_attribute *attr, char *buf) \\\n{ \\\n\treturn sprintf(buf, format_string, dev_to_ssb_dev(dev)->field); \\\n} \\\nstatic DEVICE_ATTR_RO(attrib);\n\nssb_config_attr(core_num, core_index, \"%u\\n\")\nssb_config_attr(coreid, id.coreid, \"0x%04x\\n\")\nssb_config_attr(vendor, id.vendor, \"0x%04x\\n\")\nssb_config_attr(revision, id.revision, \"%u\\n\")\nssb_config_attr(irq, irq, \"%u\\n\")\nstatic ssize_t\nname_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       ssb_core_name(dev_to_ssb_dev(dev)->id.coreid));\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *ssb_device_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_core_num.attr,\n\t&dev_attr_coreid.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_revision.attr,\n\t&dev_attr_irq.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ssb_device);\n\nstatic struct bus_type ssb_bustype = {\n\t.name\t\t= \"ssb\",\n\t.match\t\t= ssb_bus_match,\n\t.probe\t\t= ssb_device_probe,\n\t.remove\t\t= ssb_device_remove,\n\t.shutdown\t= ssb_device_shutdown,\n\t.suspend\t= ssb_device_suspend,\n\t.resume\t\t= ssb_device_resume,\n\t.uevent\t\t= ssb_device_uevent,\n\t.dev_groups\t= ssb_device_groups,\n};\n\nstatic void ssb_buses_lock(void)\n{\n\t \n\tif (!ssb_is_early_boot)\n\t\tmutex_lock(&buses_mutex);\n}\n\nstatic void ssb_buses_unlock(void)\n{\n\t \n\tif (!ssb_is_early_boot)\n\t\tmutex_unlock(&buses_mutex);\n}\n\nstatic void ssb_devices_unregister(struct ssb_bus *bus)\n{\n\tstruct ssb_device *sdev;\n\tint i;\n\n\tfor (i = bus->nr_devices - 1; i >= 0; i--) {\n\t\tsdev = &(bus->devices[i]);\n\t\tif (sdev->dev)\n\t\t\tdevice_unregister(sdev->dev);\n\t}\n\n#ifdef CONFIG_SSB_EMBEDDED\n\tif (bus->bustype == SSB_BUSTYPE_SSB)\n\t\tplatform_device_unregister(bus->watchdog);\n#endif\n}\n\nvoid ssb_bus_unregister(struct ssb_bus *bus)\n{\n\tint err;\n\n\terr = ssb_gpio_unregister(bus);\n\tif (err)\n\t\tpr_debug(\"Can not unregister GPIO driver: %i\\n\", err);\n\n\tssb_buses_lock();\n\tssb_devices_unregister(bus);\n\tlist_del(&bus->list);\n\tssb_buses_unlock();\n\n\tssb_pcmcia_exit(bus);\n\tssb_pci_exit(bus);\n\tssb_iounmap(bus);\n}\nEXPORT_SYMBOL(ssb_bus_unregister);\n\nstatic void ssb_release_dev(struct device *dev)\n{\n\tstruct __ssb_dev_wrapper *devwrap;\n\n\tdevwrap = container_of(dev, struct __ssb_dev_wrapper, dev);\n\tkfree(devwrap);\n}\n\nstatic int ssb_devices_register(struct ssb_bus *bus)\n{\n\tstruct ssb_device *sdev;\n\tstruct device *dev;\n\tstruct __ssb_dev_wrapper *devwrap;\n\tint i, err = 0;\n\tint dev_idx = 0;\n\n\tfor (i = 0; i < bus->nr_devices; i++) {\n\t\tsdev = &(bus->devices[i]);\n\n\t\t \n\t\tswitch (sdev->id.coreid) {\n\t\tcase SSB_DEV_CHIPCOMMON:\n\t\tcase SSB_DEV_PCI:\n\t\tcase SSB_DEV_PCIE:\n\t\tcase SSB_DEV_PCMCIA:\n\t\tcase SSB_DEV_MIPS:\n\t\tcase SSB_DEV_MIPS_3302:\n\t\tcase SSB_DEV_EXTIF:\n\t\t\tcontinue;\n\t\t}\n\n\t\tdevwrap = kzalloc(sizeof(*devwrap), GFP_KERNEL);\n\t\tif (!devwrap) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tdev = &devwrap->dev;\n\t\tdevwrap->sdev = sdev;\n\n\t\tdev->release = ssb_release_dev;\n\t\tdev->bus = &ssb_bustype;\n\t\tdev_set_name(dev, \"ssb%u:%d\", bus->busnumber, dev_idx);\n\n\t\tswitch (bus->bustype) {\n\t\tcase SSB_BUSTYPE_PCI:\n#ifdef CONFIG_SSB_PCIHOST\n\t\t\tsdev->irq = bus->host_pci->irq;\n\t\t\tdev->parent = &bus->host_pci->dev;\n\t\t\tsdev->dma_dev = dev->parent;\n#endif\n\t\t\tbreak;\n\t\tcase SSB_BUSTYPE_PCMCIA:\n#ifdef CONFIG_SSB_PCMCIAHOST\n\t\t\tsdev->irq = bus->host_pcmcia->irq;\n\t\t\tdev->parent = &bus->host_pcmcia->dev;\n#endif\n\t\t\tbreak;\n\t\tcase SSB_BUSTYPE_SDIO:\n#ifdef CONFIG_SSB_SDIOHOST\n\t\t\tdev->parent = &bus->host_sdio->dev;\n#endif\n\t\t\tbreak;\n\t\tcase SSB_BUSTYPE_SSB:\n\t\t\tdev->dma_mask = &dev->coherent_dma_mask;\n\t\t\tsdev->dma_dev = dev;\n\t\t\tbreak;\n\t\t}\n\n\t\tsdev->dev = dev;\n\t\terr = device_register(dev);\n\t\tif (err) {\n\t\t\tpr_err(\"Could not register %s\\n\", dev_name(dev));\n\t\t\t \n\t\t\tsdev->dev = NULL;\n\t\t\tput_device(dev);\n\t\t\tgoto error;\n\t\t}\n\t\tdev_idx++;\n\t}\n\n#ifdef CONFIG_SSB_DRIVER_MIPS\n\tif (bus->mipscore.pflash.present) {\n\t\terr = platform_device_register(&ssb_pflash_dev);\n\t\tif (err)\n\t\t\tpr_err(\"Error registering parallel flash\\n\");\n\t}\n#endif\n\n#ifdef CONFIG_SSB_SFLASH\n\tif (bus->mipscore.sflash.present) {\n\t\terr = platform_device_register(&ssb_sflash_dev);\n\t\tif (err)\n\t\t\tpr_err(\"Error registering serial flash\\n\");\n\t}\n#endif\n\n\treturn 0;\nerror:\n\t \n\tssb_devices_unregister(bus);\n\treturn err;\n}\n\n \nstatic int ssb_attach_queued_buses(void)\n{\n\tstruct ssb_bus *bus, *n;\n\tint err = 0;\n\tint drop_them_all = 0;\n\n\tlist_for_each_entry_safe(bus, n, &attach_queue, list) {\n\t\tif (drop_them_all) {\n\t\t\tlist_del(&bus->list);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\terr = ssb_bus_powerup(bus, 0);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tssb_pcicore_init(&bus->pcicore);\n\t\tif (bus->bustype == SSB_BUSTYPE_SSB)\n\t\t\tssb_watchdog_register(bus);\n\n\t\terr = ssb_gpio_init(bus);\n\t\tif (err == -ENOTSUPP)\n\t\t\tpr_debug(\"GPIO driver not activated\\n\");\n\t\telse if (err)\n\t\t\tpr_debug(\"Error registering GPIO driver: %i\\n\", err);\n\n\t\tssb_bus_may_powerdown(bus);\n\n\t\terr = ssb_devices_register(bus);\nerror:\n\t\tif (err) {\n\t\t\tdrop_them_all = 1;\n\t\t\tlist_del(&bus->list);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_move_tail(&bus->list, &buses);\n\t}\n\n\treturn err;\n}\n\nstatic int ssb_fetch_invariants(struct ssb_bus *bus,\n\t\t\t\tssb_invariants_func_t get_invariants)\n{\n\tstruct ssb_init_invariants iv;\n\tint err;\n\n\tmemset(&iv, 0, sizeof(iv));\n\terr = get_invariants(bus, &iv);\n\tif (err)\n\t\tgoto out;\n\tmemcpy(&bus->boardinfo, &iv.boardinfo, sizeof(iv.boardinfo));\n\tmemcpy(&bus->sprom, &iv.sprom, sizeof(iv.sprom));\n\tbus->has_cardbus_slot = iv.has_cardbus_slot;\nout:\n\treturn err;\n}\n\nstatic int __maybe_unused\nssb_bus_register(struct ssb_bus *bus,\n\t\t ssb_invariants_func_t get_invariants,\n\t\t unsigned long baseaddr)\n{\n\tint err;\n\n\tspin_lock_init(&bus->bar_lock);\n\tINIT_LIST_HEAD(&bus->list);\n#ifdef CONFIG_SSB_EMBEDDED\n\tspin_lock_init(&bus->gpio_lock);\n#endif\n\n\t \n\terr = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = ssb_sdio_init(bus);\n\tif (err)\n\t\tgoto err_disable_xtal;\n\n\tssb_buses_lock();\n\tbus->busnumber = next_busnumber;\n\t \n\terr = ssb_bus_scan(bus, baseaddr);\n\tif (err)\n\t\tgoto err_sdio_exit;\n\n\t \n\terr = ssb_pci_init(bus);\n\tif (err)\n\t\tgoto err_unmap;\n\t \n\terr = ssb_pcmcia_init(bus);\n\tif (err)\n\t\tgoto err_pci_exit;\n\n\t \n\terr = ssb_bus_powerup(bus, 0);\n\tif (err)\n\t\tgoto err_pcmcia_exit;\n\tssb_chipcommon_init(&bus->chipco);\n\tssb_extif_init(&bus->extif);\n\tssb_mipscore_init(&bus->mipscore);\n\terr = ssb_fetch_invariants(bus, get_invariants);\n\tif (err) {\n\t\tssb_bus_may_powerdown(bus);\n\t\tgoto err_pcmcia_exit;\n\t}\n\tssb_bus_may_powerdown(bus);\n\n\t \n\tlist_add_tail(&bus->list, &attach_queue);\n\tif (!ssb_is_early_boot) {\n\t\t \n\t\terr = ssb_attach_queued_buses();\n\t\tif (err)\n\t\t\tgoto err_dequeue;\n\t}\n\tnext_busnumber++;\n\tssb_buses_unlock();\n\nout:\n\treturn err;\n\nerr_dequeue:\n\tlist_del(&bus->list);\nerr_pcmcia_exit:\n\tssb_pcmcia_exit(bus);\nerr_pci_exit:\n\tssb_pci_exit(bus);\nerr_unmap:\n\tssb_iounmap(bus);\nerr_sdio_exit:\n\tssb_sdio_exit(bus);\nerr_disable_xtal:\n\tssb_buses_unlock();\n\tssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);\n\treturn err;\n}\n\n#ifdef CONFIG_SSB_PCIHOST\nint ssb_bus_pcibus_register(struct ssb_bus *bus, struct pci_dev *host_pci)\n{\n\tint err;\n\n\tbus->bustype = SSB_BUSTYPE_PCI;\n\tbus->host_pci = host_pci;\n\tbus->ops = &ssb_pci_ops;\n\n\terr = ssb_bus_register(bus, ssb_pci_get_invariants, 0);\n\tif (!err) {\n\t\tdev_info(&host_pci->dev,\n\t\t\t \"Sonics Silicon Backplane found on PCI device %s\\n\",\n\t\t\t dev_name(&host_pci->dev));\n\t} else {\n\t\tdev_err(&host_pci->dev,\n\t\t\t\"Failed to register PCI version of SSB with error %d\\n\",\n\t\t\terr);\n\t}\n\n\treturn err;\n}\n#endif  \n\n#ifdef CONFIG_SSB_PCMCIAHOST\nint ssb_bus_pcmciabus_register(struct ssb_bus *bus,\n\t\t\t       struct pcmcia_device *pcmcia_dev,\n\t\t\t       unsigned long baseaddr)\n{\n\tint err;\n\n\tbus->bustype = SSB_BUSTYPE_PCMCIA;\n\tbus->host_pcmcia = pcmcia_dev;\n\tbus->ops = &ssb_pcmcia_ops;\n\n\terr = ssb_bus_register(bus, ssb_pcmcia_get_invariants, baseaddr);\n\tif (!err) {\n\t\tdev_info(&pcmcia_dev->dev,\n\t\t\t \"Sonics Silicon Backplane found on PCMCIA device %s\\n\",\n\t\t\t pcmcia_dev->devname);\n\t}\n\n\treturn err;\n}\n#endif  \n\n#ifdef CONFIG_SSB_SDIOHOST\nint ssb_bus_sdiobus_register(struct ssb_bus *bus, struct sdio_func *func,\n\t\t\t     unsigned int quirks)\n{\n\tint err;\n\n\tbus->bustype = SSB_BUSTYPE_SDIO;\n\tbus->host_sdio = func;\n\tbus->ops = &ssb_sdio_ops;\n\tbus->quirks = quirks;\n\n\terr = ssb_bus_register(bus, ssb_sdio_get_invariants, ~0);\n\tif (!err) {\n\t\tdev_info(&func->dev,\n\t\t\t \"Sonics Silicon Backplane found on SDIO device %s\\n\",\n\t\t\t sdio_func_id(func));\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL(ssb_bus_sdiobus_register);\n#endif  \n\n#ifdef CONFIG_SSB_HOST_SOC\nint ssb_bus_host_soc_register(struct ssb_bus *bus, unsigned long baseaddr)\n{\n\tint err;\n\n\tbus->bustype = SSB_BUSTYPE_SSB;\n\tbus->ops = &ssb_host_soc_ops;\n\n\terr = ssb_bus_register(bus, ssb_host_soc_get_invariants, baseaddr);\n\tif (!err) {\n\t\tpr_info(\"Sonics Silicon Backplane found at address 0x%08lX\\n\",\n\t\t\tbaseaddr);\n\t}\n\n\treturn err;\n}\n#endif\n\nint __ssb_driver_register(struct ssb_driver *drv, struct module *owner)\n{\n\tdrv->drv.name = drv->name;\n\tdrv->drv.bus = &ssb_bustype;\n\tdrv->drv.owner = owner;\n\n\treturn driver_register(&drv->drv);\n}\nEXPORT_SYMBOL(__ssb_driver_register);\n\nvoid ssb_driver_unregister(struct ssb_driver *drv)\n{\n\tdriver_unregister(&drv->drv);\n}\nEXPORT_SYMBOL(ssb_driver_unregister);\n\nvoid ssb_set_devtypedata(struct ssb_device *dev, void *data)\n{\n\tstruct ssb_bus *bus = dev->bus;\n\tstruct ssb_device *ent;\n\tint i;\n\n\tfor (i = 0; i < bus->nr_devices; i++) {\n\t\tent = &(bus->devices[i]);\n\t\tif (ent->id.vendor != dev->id.vendor)\n\t\t\tcontinue;\n\t\tif (ent->id.coreid != dev->id.coreid)\n\t\t\tcontinue;\n\n\t\tent->devtypedata = data;\n\t}\n}\nEXPORT_SYMBOL(ssb_set_devtypedata);\n\nstatic u32 clkfactor_f6_resolve(u32 v)\n{\n\t \n\tswitch (v) {\n\tcase SSB_CHIPCO_CLK_F6_2:\n\t\treturn 2;\n\tcase SSB_CHIPCO_CLK_F6_3:\n\t\treturn 3;\n\tcase SSB_CHIPCO_CLK_F6_4:\n\t\treturn 4;\n\tcase SSB_CHIPCO_CLK_F6_5:\n\t\treturn 5;\n\tcase SSB_CHIPCO_CLK_F6_6:\n\t\treturn 6;\n\tcase SSB_CHIPCO_CLK_F6_7:\n\t\treturn 7;\n\t}\n\treturn 0;\n}\n\n \nu32 ssb_calc_clock_rate(u32 plltype, u32 n, u32 m)\n{\n\tu32 n1, n2, clock, m1, m2, m3, mc;\n\n\tn1 = (n & SSB_CHIPCO_CLK_N1);\n\tn2 = ((n & SSB_CHIPCO_CLK_N2) >> SSB_CHIPCO_CLK_N2_SHIFT);\n\n\tswitch (plltype) {\n\tcase SSB_PLLTYPE_6:  \n\t\tif (m & SSB_CHIPCO_CLK_T6_MMASK)\n\t\t\treturn SSB_CHIPCO_CLK_T6_M1;\n\t\treturn SSB_CHIPCO_CLK_T6_M0;\n\tcase SSB_PLLTYPE_1:  \n\tcase SSB_PLLTYPE_3:  \n\tcase SSB_PLLTYPE_4:  \n\tcase SSB_PLLTYPE_7:  \n\t\tn1 = clkfactor_f6_resolve(n1);\n\t\tn2 += SSB_CHIPCO_CLK_F5_BIAS;\n\t\tbreak;\n\tcase SSB_PLLTYPE_2:  \n\t\tn1 += SSB_CHIPCO_CLK_T2_BIAS;\n\t\tn2 += SSB_CHIPCO_CLK_T2_BIAS;\n\t\tWARN_ON(!((n1 >= 2) && (n1 <= 7)));\n\t\tWARN_ON(!((n2 >= 5) && (n2 <= 23)));\n\t\tbreak;\n\tcase SSB_PLLTYPE_5:  \n\t\treturn 100000000;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tswitch (plltype) {\n\tcase SSB_PLLTYPE_3:  \n\tcase SSB_PLLTYPE_7:  \n\t\tclock = SSB_CHIPCO_CLK_BASE2 * n1 * n2;\n\t\tbreak;\n\tdefault:\n\t\tclock = SSB_CHIPCO_CLK_BASE1 * n1 * n2;\n\t}\n\tif (!clock)\n\t\treturn 0;\n\n\tm1 = (m & SSB_CHIPCO_CLK_M1);\n\tm2 = ((m & SSB_CHIPCO_CLK_M2) >> SSB_CHIPCO_CLK_M2_SHIFT);\n\tm3 = ((m & SSB_CHIPCO_CLK_M3) >> SSB_CHIPCO_CLK_M3_SHIFT);\n\tmc = ((m & SSB_CHIPCO_CLK_MC) >> SSB_CHIPCO_CLK_MC_SHIFT);\n\n\tswitch (plltype) {\n\tcase SSB_PLLTYPE_1:  \n\tcase SSB_PLLTYPE_3:  \n\tcase SSB_PLLTYPE_4:  \n\tcase SSB_PLLTYPE_7:  \n\t\tm1 = clkfactor_f6_resolve(m1);\n\t\tif ((plltype == SSB_PLLTYPE_1) ||\n\t\t    (plltype == SSB_PLLTYPE_3))\n\t\t\tm2 += SSB_CHIPCO_CLK_F5_BIAS;\n\t\telse\n\t\t\tm2 = clkfactor_f6_resolve(m2);\n\t\tm3 = clkfactor_f6_resolve(m3);\n\n\t\tswitch (mc) {\n\t\tcase SSB_CHIPCO_CLK_MC_BYPASS:\n\t\t\treturn clock;\n\t\tcase SSB_CHIPCO_CLK_MC_M1:\n\t\t\treturn (clock / m1);\n\t\tcase SSB_CHIPCO_CLK_MC_M1M2:\n\t\t\treturn (clock / (m1 * m2));\n\t\tcase SSB_CHIPCO_CLK_MC_M1M2M3:\n\t\t\treturn (clock / (m1 * m2 * m3));\n\t\tcase SSB_CHIPCO_CLK_MC_M1M3:\n\t\t\treturn (clock / (m1 * m3));\n\t\t}\n\t\treturn 0;\n\tcase SSB_PLLTYPE_2:\n\t\tm1 += SSB_CHIPCO_CLK_T2_BIAS;\n\t\tm2 += SSB_CHIPCO_CLK_T2M2_BIAS;\n\t\tm3 += SSB_CHIPCO_CLK_T2_BIAS;\n\t\tWARN_ON(!((m1 >= 2) && (m1 <= 7)));\n\t\tWARN_ON(!((m2 >= 3) && (m2 <= 10)));\n\t\tWARN_ON(!((m3 >= 2) && (m3 <= 7)));\n\n\t\tif (!(mc & SSB_CHIPCO_CLK_T2MC_M1BYP))\n\t\t\tclock /= m1;\n\t\tif (!(mc & SSB_CHIPCO_CLK_T2MC_M2BYP))\n\t\t\tclock /= m2;\n\t\tif (!(mc & SSB_CHIPCO_CLK_T2MC_M3BYP))\n\t\t\tclock /= m3;\n\t\treturn clock;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\treturn 0;\n}\n\n \nu32 ssb_clockspeed(struct ssb_bus *bus)\n{\n\tu32 rate;\n\tu32 plltype;\n\tu32 clkctl_n, clkctl_m;\n\n\tif (bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU)\n\t\treturn ssb_pmu_get_controlclock(&bus->chipco);\n\n\tif (ssb_extif_available(&bus->extif))\n\t\tssb_extif_get_clockcontrol(&bus->extif, &plltype,\n\t\t\t\t\t   &clkctl_n, &clkctl_m);\n\telse if (bus->chipco.dev)\n\t\tssb_chipco_get_clockcontrol(&bus->chipco, &plltype,\n\t\t\t\t\t    &clkctl_n, &clkctl_m);\n\telse\n\t\treturn 0;\n\n\tif (bus->chip_id == 0x5365) {\n\t\trate = 100000000;\n\t} else {\n\t\trate = ssb_calc_clock_rate(plltype, clkctl_n, clkctl_m);\n\t\tif (plltype == SSB_PLLTYPE_3)  \n\t\t\trate /= 2;\n\t}\n\n\treturn rate;\n}\nEXPORT_SYMBOL(ssb_clockspeed);\n\nstatic u32 ssb_tmslow_reject_bitmask(struct ssb_device *dev)\n{\n\tu32 rev = ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_SSBREV;\n\n\t \n\tswitch (rev) {\n\tcase SSB_IDLOW_SSBREV_22:\n\tcase SSB_IDLOW_SSBREV_24:\n\tcase SSB_IDLOW_SSBREV_26:\n\t\treturn SSB_TMSLOW_REJECT;\n\tcase SSB_IDLOW_SSBREV_23:\n\t\treturn SSB_TMSLOW_REJECT_23;\n\tcase SSB_IDLOW_SSBREV_25:      \n\tcase SSB_IDLOW_SSBREV_27:      \n\t\treturn SSB_TMSLOW_REJECT;\t \n\tcase SSB_IDLOW_SSBREV:\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, KERN_INFO \"ssb: Backplane Revision 0x%.8X\\n\", rev);\n\t}\n\treturn (SSB_TMSLOW_REJECT | SSB_TMSLOW_REJECT_23);\n}\n\nint ssb_device_is_enabled(struct ssb_device *dev)\n{\n\tu32 val;\n\tu32 reject;\n\n\treject = ssb_tmslow_reject_bitmask(dev);\n\tval = ssb_read32(dev, SSB_TMSLOW);\n\tval &= SSB_TMSLOW_CLOCK | SSB_TMSLOW_RESET | reject;\n\n\treturn (val == SSB_TMSLOW_CLOCK);\n}\nEXPORT_SYMBOL(ssb_device_is_enabled);\n\nstatic void ssb_flush_tmslow(struct ssb_device *dev)\n{\n\t \n\tssb_read32(dev, SSB_TMSLOW);\n\tudelay(1);\n}\n\nvoid ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags)\n{\n\tu32 val;\n\n\tssb_device_disable(dev, core_specific_flags);\n\tssb_write32(dev, SSB_TMSLOW,\n\t\t    SSB_TMSLOW_RESET | SSB_TMSLOW_CLOCK |\n\t\t    SSB_TMSLOW_FGC | core_specific_flags);\n\tssb_flush_tmslow(dev);\n\n\t \n\tif (ssb_read32(dev, SSB_TMSHIGH) & SSB_TMSHIGH_SERR)\n\t\tssb_write32(dev, SSB_TMSHIGH, 0);\n\n\tval = ssb_read32(dev, SSB_IMSTATE);\n\tif (val & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO)) {\n\t\tval &= ~(SSB_IMSTATE_IBE | SSB_IMSTATE_TO);\n\t\tssb_write32(dev, SSB_IMSTATE, val);\n\t}\n\n\tssb_write32(dev, SSB_TMSLOW,\n\t\t    SSB_TMSLOW_CLOCK | SSB_TMSLOW_FGC |\n\t\t    core_specific_flags);\n\tssb_flush_tmslow(dev);\n\n\tssb_write32(dev, SSB_TMSLOW, SSB_TMSLOW_CLOCK |\n\t\t    core_specific_flags);\n\tssb_flush_tmslow(dev);\n}\nEXPORT_SYMBOL(ssb_device_enable);\n\n \nstatic int ssb_wait_bits(struct ssb_device *dev, u16 reg, u32 bitmask,\n\t\t\t int timeout, int set)\n{\n\tint i;\n\tu32 val;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tval = ssb_read32(dev, reg);\n\t\tif (set) {\n\t\t\tif ((val & bitmask) == bitmask)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!(val & bitmask))\n\t\t\t\treturn 0;\n\t\t}\n\t\tudelay(10);\n\t}\n\tdev_err(dev->dev,\n\t\t\"Timeout waiting for bitmask %08X on register %04X to %s\\n\",\n\t\tbitmask, reg, set ? \"set\" : \"clear\");\n\n\treturn -ETIMEDOUT;\n}\n\nvoid ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags)\n{\n\tu32 reject, val;\n\n\tif (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_RESET)\n\t\treturn;\n\n\treject = ssb_tmslow_reject_bitmask(dev);\n\n\tif (ssb_read32(dev, SSB_TMSLOW) & SSB_TMSLOW_CLOCK) {\n\t\tssb_write32(dev, SSB_TMSLOW, reject | SSB_TMSLOW_CLOCK);\n\t\tssb_wait_bits(dev, SSB_TMSLOW, reject, 1000, 1);\n\t\tssb_wait_bits(dev, SSB_TMSHIGH, SSB_TMSHIGH_BUSY, 1000, 0);\n\n\t\tif (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_INITIATOR) {\n\t\t\tval = ssb_read32(dev, SSB_IMSTATE);\n\t\t\tval |= SSB_IMSTATE_REJECT;\n\t\t\tssb_write32(dev, SSB_IMSTATE, val);\n\t\t\tssb_wait_bits(dev, SSB_IMSTATE, SSB_IMSTATE_BUSY, 1000,\n\t\t\t\t      0);\n\t\t}\n\n\t\tssb_write32(dev, SSB_TMSLOW,\n\t\t\tSSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |\n\t\t\treject | SSB_TMSLOW_RESET |\n\t\t\tcore_specific_flags);\n\t\tssb_flush_tmslow(dev);\n\n\t\tif (ssb_read32(dev, SSB_IDLOW) & SSB_IDLOW_INITIATOR) {\n\t\t\tval = ssb_read32(dev, SSB_IMSTATE);\n\t\t\tval &= ~SSB_IMSTATE_REJECT;\n\t\t\tssb_write32(dev, SSB_IMSTATE, val);\n\t\t}\n\t}\n\n\tssb_write32(dev, SSB_TMSLOW,\n\t\t    reject | SSB_TMSLOW_RESET |\n\t\t    core_specific_flags);\n\tssb_flush_tmslow(dev);\n}\nEXPORT_SYMBOL(ssb_device_disable);\n\n \nstatic bool ssb_dma_translation_special_bit(struct ssb_device *dev)\n{\n\tu16 chip_id = dev->bus->chip_id;\n\n\tif (dev->id.coreid == SSB_DEV_80211) {\n\t\treturn (chip_id == 0x4322 || chip_id == 43221 ||\n\t\t\tchip_id == 43231 || chip_id == 43222);\n\t}\n\n\treturn false;\n}\n\nu32 ssb_dma_translation(struct ssb_device *dev)\n{\n\tswitch (dev->bus->bustype) {\n\tcase SSB_BUSTYPE_SSB:\n\t\treturn 0;\n\tcase SSB_BUSTYPE_PCI:\n\t\tif (pci_is_pcie(dev->bus->host_pci) &&\n\t\t    ssb_read32(dev, SSB_TMSHIGH) & SSB_TMSHIGH_DMA64) {\n\t\t\treturn SSB_PCIE_DMA_H32;\n\t\t} else {\n\t\t\tif (ssb_dma_translation_special_bit(dev))\n\t\t\t\treturn SSB_PCIE_DMA_H32;\n\t\t\telse\n\t\t\t\treturn SSB_PCI_DMA;\n\t\t}\n\tdefault:\n\t\t__ssb_dma_not_implemented(dev);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ssb_dma_translation);\n\nint ssb_bus_may_powerdown(struct ssb_bus *bus)\n{\n\tstruct ssb_chipcommon *cc;\n\tint err = 0;\n\n\t \n\tif (bus->bustype == SSB_BUSTYPE_SSB)\n\t\tgoto out;\n\n\tcc = &bus->chipco;\n\n\tif (!cc->dev)\n\t\tgoto out;\n\tif (cc->dev->id.revision < 5)\n\t\tgoto out;\n\n\tssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);\n\terr = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 0);\n\tif (err)\n\t\tgoto error;\nout:\n\tbus->powered_up = 0;\n\treturn err;\nerror:\n\tpr_err(\"Bus powerdown failed\\n\");\n\tgoto out;\n}\nEXPORT_SYMBOL(ssb_bus_may_powerdown);\n\nint ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl)\n{\n\tint err;\n\tenum ssb_clkmode mode;\n\n\terr = ssb_pci_xtal(bus, SSB_GPIO_XTAL | SSB_GPIO_PLL, 1);\n\tif (err)\n\t\tgoto error;\n\n\tbus->powered_up = 1;\n\n\tmode = dynamic_pctl ? SSB_CLKMODE_DYNAMIC : SSB_CLKMODE_FAST;\n\tssb_chipco_set_clockmode(&bus->chipco, mode);\n\n\treturn 0;\nerror:\n\tpr_err(\"Bus powerup failed\\n\");\n\treturn err;\n}\nEXPORT_SYMBOL(ssb_bus_powerup);\n\nstatic void ssb_broadcast_value(struct ssb_device *dev,\n\t\t\t\tu32 address, u32 data)\n{\n#ifdef CONFIG_SSB_DRIVER_PCICORE\n\t \n\tBUILD_BUG_ON(SSB_PCICORE_BCAST_ADDR != SSB_CHIPCO_BCAST_ADDR);\n\tBUILD_BUG_ON(SSB_PCICORE_BCAST_DATA != SSB_CHIPCO_BCAST_DATA);\n#endif\n\n\tssb_write32(dev, SSB_CHIPCO_BCAST_ADDR, address);\n\tssb_read32(dev, SSB_CHIPCO_BCAST_ADDR);  \n\tssb_write32(dev, SSB_CHIPCO_BCAST_DATA, data);\n\tssb_read32(dev, SSB_CHIPCO_BCAST_DATA);  \n}\n\nvoid ssb_commit_settings(struct ssb_bus *bus)\n{\n\tstruct ssb_device *dev;\n\n#ifdef CONFIG_SSB_DRIVER_PCICORE\n\tdev = bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev;\n#else\n\tdev = bus->chipco.dev;\n#endif\n\tif (WARN_ON(!dev))\n\t\treturn;\n\t \n\tssb_broadcast_value(dev, 0xFD8, 0);\n}\nEXPORT_SYMBOL(ssb_commit_settings);\n\nu32 ssb_admatch_base(u32 adm)\n{\n\tu32 base = 0;\n\n\tswitch (adm & SSB_ADM_TYPE) {\n\tcase SSB_ADM_TYPE0:\n\t\tbase = (adm & SSB_ADM_BASE0);\n\t\tbreak;\n\tcase SSB_ADM_TYPE1:\n\t\tWARN_ON(adm & SSB_ADM_NEG);  \n\t\tbase = (adm & SSB_ADM_BASE1);\n\t\tbreak;\n\tcase SSB_ADM_TYPE2:\n\t\tWARN_ON(adm & SSB_ADM_NEG);  \n\t\tbase = (adm & SSB_ADM_BASE2);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\treturn base;\n}\nEXPORT_SYMBOL(ssb_admatch_base);\n\nu32 ssb_admatch_size(u32 adm)\n{\n\tu32 size = 0;\n\n\tswitch (adm & SSB_ADM_TYPE) {\n\tcase SSB_ADM_TYPE0:\n\t\tsize = ((adm & SSB_ADM_SZ0) >> SSB_ADM_SZ0_SHIFT);\n\t\tbreak;\n\tcase SSB_ADM_TYPE1:\n\t\tWARN_ON(adm & SSB_ADM_NEG);  \n\t\tsize = ((adm & SSB_ADM_SZ1) >> SSB_ADM_SZ1_SHIFT);\n\t\tbreak;\n\tcase SSB_ADM_TYPE2:\n\t\tWARN_ON(adm & SSB_ADM_NEG);  \n\t\tsize = ((adm & SSB_ADM_SZ2) >> SSB_ADM_SZ2_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\tsize = (1 << (size + 1));\n\n\treturn size;\n}\nEXPORT_SYMBOL(ssb_admatch_size);\n\nstatic int __init ssb_modinit(void)\n{\n\tint err;\n\n\t \n\tssb_is_early_boot = 0;\n\terr = bus_register(&ssb_bustype);\n\tif (err)\n\t\treturn err;\n\n\t \n\tssb_buses_lock();\n\terr = ssb_attach_queued_buses();\n\tssb_buses_unlock();\n\tif (err) {\n\t\tbus_unregister(&ssb_bustype);\n\t\tgoto out;\n\t}\n\n\terr = b43_pci_ssb_bridge_init();\n\tif (err) {\n\t\tpr_err(\"Broadcom 43xx PCI-SSB-bridge initialization failed\\n\");\n\t\t \n\t}\n\terr = ssb_host_pcmcia_init();\n\tif (err) {\n\t\tpr_err(\"PCMCIA host initialization failed\\n\");\n\t\t \n\t}\n\terr = ssb_gige_init();\n\tif (err) {\n\t\tpr_err(\"SSB Broadcom Gigabit Ethernet driver initialization failed\\n\");\n\t\t \n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}\n \nfs_initcall(ssb_modinit);\n\nstatic void __exit ssb_modexit(void)\n{\n\tssb_gige_exit();\n\tssb_host_pcmcia_exit();\n\tb43_pci_ssb_bridge_exit();\n\tbus_unregister(&ssb_bustype);\n}\nmodule_exit(ssb_modexit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}