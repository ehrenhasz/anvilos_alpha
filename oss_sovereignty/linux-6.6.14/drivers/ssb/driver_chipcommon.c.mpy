{
  "module_name": "driver_chipcommon.c",
  "hash_id": "710bb29d01704c321a49c8f1d1a273d3eb31b8fb013ddcca640f1ebf9ae39ea7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/driver_chipcommon.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/ssb/ssb.h>\n#include <linux/ssb/ssb_regs.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <linux/bcm47xx_wdt.h>\n\n\n \nenum ssb_clksrc {\n\t \n\tSSB_CHIPCO_CLKSRC_PCI,\n\t \n\tSSB_CHIPCO_CLKSRC_XTALOS,\n\t \n\tSSB_CHIPCO_CLKSRC_LOPWROS,\n};\n\n\nstatic inline u32 chipco_write32_masked(struct ssb_chipcommon *cc, u16 offset,\n\t\t\t\t\tu32 mask, u32 value)\n{\n\tvalue &= mask;\n\tvalue |= chipco_read32(cc, offset) & ~mask;\n\tchipco_write32(cc, offset, value);\n\n\treturn value;\n}\n\nvoid ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,\n\t\t\t      enum ssb_clkmode mode)\n{\n\tstruct ssb_device *ccdev = cc->dev;\n\tstruct ssb_bus *bus;\n\tu32 tmp;\n\n\tif (!ccdev)\n\t\treturn;\n\tbus = ccdev->bus;\n\n\t \n\tif (ccdev->id.revision >= 10 && mode == SSB_CLKMODE_SLOW)\n\t\tmode = SSB_CLKMODE_DYNAMIC;\n\n\tif (cc->capabilities & SSB_CHIPCO_CAP_PMU)\n\t\treturn;  \n\tWARN_ON(ccdev->id.revision >= 20);\n\n\t \n\tif (ccdev->id.revision < 6)\n\t\treturn;\n\n\t \n\tif (ccdev->id.revision >= 10)\n\t\treturn;\n\n\tif (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))\n\t\treturn;\n\n\tswitch (mode) {\n\tcase SSB_CLKMODE_SLOW:  \n\t\ttmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\n\t\ttmp |= SSB_CHIPCO_SLOWCLKCTL_FSLOW;\n\t\tchipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);\n\t\tbreak;\n\tcase SSB_CLKMODE_FAST:\n\t\tif (ccdev->id.revision < 10) {\n\t\t\tssb_pci_xtal(bus, SSB_GPIO_XTAL, 1);  \n\t\t\ttmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\n\t\t\ttmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;\n\t\t\ttmp |= SSB_CHIPCO_SLOWCLKCTL_IPLL;\n\t\t\tchipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);\n\t\t} else {\n\t\t\tchipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,\n\t\t\t\t(chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) |\n\t\t\t\t SSB_CHIPCO_SYSCLKCTL_FORCEHT));\n\t\t\t \n\t\t}\n\t\tbreak;\n\tcase SSB_CLKMODE_DYNAMIC:\n\t\tif (ccdev->id.revision < 10) {\n\t\t\ttmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\n\t\t\ttmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;\n\t\t\ttmp &= ~SSB_CHIPCO_SLOWCLKCTL_IPLL;\n\t\t\ttmp &= ~SSB_CHIPCO_SLOWCLKCTL_ENXTAL;\n\t\t\tif ((tmp & SSB_CHIPCO_SLOWCLKCTL_SRC) !=\n\t\t\t    SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL)\n\t\t\t\ttmp |= SSB_CHIPCO_SLOWCLKCTL_ENXTAL;\n\t\t\tchipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);\n\n\t\t\t \n\t\t\tif (tmp & SSB_CHIPCO_SLOWCLKCTL_ENXTAL)\n\t\t\t\tssb_pci_xtal(bus, SSB_GPIO_XTAL, 0);\n\t\t} else {\n\t\t\tchipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,\n\t\t\t\t(chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) &\n\t\t\t\t ~SSB_CHIPCO_SYSCLKCTL_FORCEHT));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\n \nstatic enum ssb_clksrc chipco_pctl_get_slowclksrc(struct ssb_chipcommon *cc)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\tu32 tmp;\n\n\tif (cc->dev->id.revision < 6) {\n\t\tif (bus->bustype == SSB_BUSTYPE_SSB ||\n\t\t    bus->bustype == SSB_BUSTYPE_PCMCIA)\n\t\t\treturn SSB_CHIPCO_CLKSRC_XTALOS;\n\t\tif (bus->bustype == SSB_BUSTYPE_PCI) {\n\t\t\tpci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &tmp);\n\t\t\tif (tmp & 0x10)\n\t\t\t\treturn SSB_CHIPCO_CLKSRC_PCI;\n\t\t\treturn SSB_CHIPCO_CLKSRC_XTALOS;\n\t\t}\n\t}\n\tif (cc->dev->id.revision < 10) {\n\t\ttmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\n\t\ttmp &= 0x7;\n\t\tif (tmp == 0)\n\t\t\treturn SSB_CHIPCO_CLKSRC_LOPWROS;\n\t\tif (tmp == 1)\n\t\t\treturn SSB_CHIPCO_CLKSRC_XTALOS;\n\t\tif (tmp == 2)\n\t\t\treturn SSB_CHIPCO_CLKSRC_PCI;\n\t}\n\n\treturn SSB_CHIPCO_CLKSRC_XTALOS;\n}\n\n \nstatic int chipco_pctl_clockfreqlimit(struct ssb_chipcommon *cc, int get_max)\n{\n\tint limit;\n\tenum ssb_clksrc clocksrc;\n\tint divisor = 1;\n\tu32 tmp;\n\n\tclocksrc = chipco_pctl_get_slowclksrc(cc);\n\tif (cc->dev->id.revision < 6) {\n\t\tswitch (clocksrc) {\n\t\tcase SSB_CHIPCO_CLKSRC_PCI:\n\t\t\tdivisor = 64;\n\t\t\tbreak;\n\t\tcase SSB_CHIPCO_CLKSRC_XTALOS:\n\t\t\tdivisor = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t} else if (cc->dev->id.revision < 10) {\n\t\tswitch (clocksrc) {\n\t\tcase SSB_CHIPCO_CLKSRC_LOPWROS:\n\t\t\tbreak;\n\t\tcase SSB_CHIPCO_CLKSRC_XTALOS:\n\t\tcase SSB_CHIPCO_CLKSRC_PCI:\n\t\t\ttmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\n\t\t\tdivisor = (tmp >> 16) + 1;\n\t\t\tdivisor *= 4;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttmp = chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL);\n\t\tdivisor = (tmp >> 16) + 1;\n\t\tdivisor *= 4;\n\t}\n\n\tswitch (clocksrc) {\n\tcase SSB_CHIPCO_CLKSRC_LOPWROS:\n\t\tif (get_max)\n\t\t\tlimit = 43000;\n\t\telse\n\t\t\tlimit = 25000;\n\t\tbreak;\n\tcase SSB_CHIPCO_CLKSRC_XTALOS:\n\t\tif (get_max)\n\t\t\tlimit = 20200000;\n\t\telse\n\t\t\tlimit = 19800000;\n\t\tbreak;\n\tcase SSB_CHIPCO_CLKSRC_PCI:\n\t\tif (get_max)\n\t\t\tlimit = 34000000;\n\t\telse\n\t\t\tlimit = 25000000;\n\t\tbreak;\n\t}\n\tlimit /= divisor;\n\n\treturn limit;\n}\n\nstatic void chipco_powercontrol_init(struct ssb_chipcommon *cc)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\n\tif (bus->chip_id == 0x4321) {\n\t\tif (bus->chip_rev == 0)\n\t\t\tchipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0x3A4);\n\t\telse if (bus->chip_rev == 1)\n\t\t\tchipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0xA4);\n\t}\n\n\tif (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))\n\t\treturn;\n\n\tif (cc->dev->id.revision >= 10) {\n\t\t \n\t\tchipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,\n\t\t\t       (chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) &\n\t\t\t\t0x0000FFFF) | 0x00040000);\n\t} else {\n\t\tint maxfreq;\n\n\t\tmaxfreq = chipco_pctl_clockfreqlimit(cc, 1);\n\t\tchipco_write32(cc, SSB_CHIPCO_PLLONDELAY,\n\t\t\t       (maxfreq * 150 + 999999) / 1000000);\n\t\tchipco_write32(cc, SSB_CHIPCO_FREFSELDELAY,\n\t\t\t       (maxfreq * 15 + 999999) / 1000000);\n\t}\n}\n\n \nstatic u16 pmu_fast_powerup_delay(struct ssb_chipcommon *cc)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\n\tswitch (bus->chip_id) {\n\tcase 0x4312:\n\tcase 0x4322:\n\tcase 0x4328:\n\t\treturn 7000;\n\tcase 0x4325:\n\t\t \n\tdefault:\n\t\treturn 15000;\n\t}\n}\n\n \nstatic void calc_fast_powerup_delay(struct ssb_chipcommon *cc)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\tint minfreq;\n\tunsigned int tmp;\n\tu32 pll_on_delay;\n\n\tif (bus->bustype != SSB_BUSTYPE_PCI)\n\t\treturn;\n\n\tif (cc->capabilities & SSB_CHIPCO_CAP_PMU) {\n\t\tcc->fast_pwrup_delay = pmu_fast_powerup_delay(cc);\n\t\treturn;\n\t}\n\n\tif (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))\n\t\treturn;\n\n\tminfreq = chipco_pctl_clockfreqlimit(cc, 0);\n\tpll_on_delay = chipco_read32(cc, SSB_CHIPCO_PLLONDELAY);\n\ttmp = (((pll_on_delay + 2) * 1000000) + (minfreq - 1)) / minfreq;\n\tWARN_ON(tmp & ~0xFFFF);\n\n\tcc->fast_pwrup_delay = tmp;\n}\n\nstatic u32 ssb_chipco_alp_clock(struct ssb_chipcommon *cc)\n{\n\tif (cc->capabilities & SSB_CHIPCO_CAP_PMU)\n\t\treturn ssb_pmu_get_alp_clock(cc);\n\n\treturn 20000000;\n}\n\nstatic u32 ssb_chipco_watchdog_get_max_timer(struct ssb_chipcommon *cc)\n{\n\tu32 nb;\n\n\tif (cc->capabilities & SSB_CHIPCO_CAP_PMU) {\n\t\tif (cc->dev->id.revision < 26)\n\t\t\tnb = 16;\n\t\telse\n\t\t\tnb = (cc->dev->id.revision >= 37) ? 32 : 24;\n\t} else {\n\t\tnb = 28;\n\t}\n\tif (nb == 32)\n\t\treturn 0xffffffff;\n\telse\n\t\treturn (1 << nb) - 1;\n}\n\nu32 ssb_chipco_watchdog_timer_set_wdt(struct bcm47xx_wdt *wdt, u32 ticks)\n{\n\tstruct ssb_chipcommon *cc = bcm47xx_wdt_get_drvdata(wdt);\n\n\tif (cc->dev->bus->bustype != SSB_BUSTYPE_SSB)\n\t\treturn 0;\n\n\treturn ssb_chipco_watchdog_timer_set(cc, ticks);\n}\n\nu32 ssb_chipco_watchdog_timer_set_ms(struct bcm47xx_wdt *wdt, u32 ms)\n{\n\tstruct ssb_chipcommon *cc = bcm47xx_wdt_get_drvdata(wdt);\n\tu32 ticks;\n\n\tif (cc->dev->bus->bustype != SSB_BUSTYPE_SSB)\n\t\treturn 0;\n\n\tticks = ssb_chipco_watchdog_timer_set(cc, cc->ticks_per_ms * ms);\n\treturn ticks / cc->ticks_per_ms;\n}\n\nstatic int ssb_chipco_watchdog_ticks_per_ms(struct ssb_chipcommon *cc)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\n\tif (cc->capabilities & SSB_CHIPCO_CAP_PMU) {\n\t\t\t \n\t\t\treturn 32;\n\t} else {\n\t\tif (cc->dev->id.revision < 18)\n\t\t\treturn ssb_clockspeed(bus) / 1000;\n\t\telse\n\t\t\treturn ssb_chipco_alp_clock(cc) / 1000;\n\t}\n}\n\nvoid ssb_chipcommon_init(struct ssb_chipcommon *cc)\n{\n\tif (!cc->dev)\n\t\treturn;  \n\n\tspin_lock_init(&cc->gpio_lock);\n\n\tif (cc->dev->id.revision >= 11)\n\t\tcc->status = chipco_read32(cc, SSB_CHIPCO_CHIPSTAT);\n\tdev_dbg(cc->dev->dev, \"chipcommon status is 0x%x\\n\", cc->status);\n\n\tif (cc->dev->id.revision >= 20) {\n\t\tchipco_write32(cc, SSB_CHIPCO_GPIOPULLUP, 0);\n\t\tchipco_write32(cc, SSB_CHIPCO_GPIOPULLDOWN, 0);\n\t}\n\n\tssb_pmu_init(cc);\n\tchipco_powercontrol_init(cc);\n\tssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);\n\tcalc_fast_powerup_delay(cc);\n\n\tif (cc->dev->bus->bustype == SSB_BUSTYPE_SSB) {\n\t\tcc->ticks_per_ms = ssb_chipco_watchdog_ticks_per_ms(cc);\n\t\tcc->max_timer_ms = ssb_chipco_watchdog_get_max_timer(cc) / cc->ticks_per_ms;\n\t}\n}\n\nvoid ssb_chipco_suspend(struct ssb_chipcommon *cc)\n{\n\tif (!cc->dev)\n\t\treturn;\n\tssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);\n}\n\nvoid ssb_chipco_resume(struct ssb_chipcommon *cc)\n{\n\tif (!cc->dev)\n\t\treturn;\n\tchipco_powercontrol_init(cc);\n\tssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);\n}\n\n \nvoid ssb_chipco_get_clockcpu(struct ssb_chipcommon *cc,\n                             u32 *plltype, u32 *n, u32 *m)\n{\n\t*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);\n\t*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);\n\tswitch (*plltype) {\n\tcase SSB_PLLTYPE_2:\n\tcase SSB_PLLTYPE_4:\n\tcase SSB_PLLTYPE_6:\n\tcase SSB_PLLTYPE_7:\n\t\t*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_MIPS);\n\t\tbreak;\n\tcase SSB_PLLTYPE_3:\n\t\t \n\t\t*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_M2);\n\t\tbreak;\n\tdefault:\n\t\t*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_SB);\n\t\tbreak;\n\t}\n}\n\n \nvoid ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,\n\t\t\t\t u32 *plltype, u32 *n, u32 *m)\n{\n\t*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);\n\t*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);\n\tswitch (*plltype) {\n\tcase SSB_PLLTYPE_6:  \n\t\t*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_MIPS);\n\t\tbreak;\n\tcase SSB_PLLTYPE_3:  \n\t\tif (cc->dev->bus->chip_id != 0x5365) {\n\t\t\t*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_M2);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_SB);\n\t}\n}\n\nvoid ssb_chipco_timing_init(struct ssb_chipcommon *cc,\n\t\t\t    unsigned long ns)\n{\n\tstruct ssb_device *dev = cc->dev;\n\tstruct ssb_bus *bus = dev->bus;\n\tu32 tmp;\n\n\t \n\tchipco_write32(cc, SSB_CHIPCO_PROG_CFG, 0x11);\n\ttmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;\t\t \n\ttmp |= DIV_ROUND_UP(40, ns) << SSB_PROG_WCNT_1_SHIFT;\t \n\ttmp |= DIV_ROUND_UP(240, ns);\t\t\t\t \n\tchipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp);\t \n\n\t \n\ttmp = DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_3_SHIFT;\t \n\ttmp |= DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_1_SHIFT;\t \n\ttmp |= DIV_ROUND_UP(120, ns);\t\t\t\t \n\tif ((bus->chip_id == 0x5365) ||\n\t    (dev->id.revision < 9))\n\t\tchipco_write32(cc, SSB_CHIPCO_FLASH_WAITCNT, tmp);\n\tif ((bus->chip_id == 0x5365) ||\n\t    (dev->id.revision < 9) ||\n\t    ((bus->chip_id == 0x5350) && (bus->chip_rev == 0)))\n\t\tchipco_write32(cc, SSB_CHIPCO_PCMCIA_MEMWAIT, tmp);\n\n\tif (bus->chip_id == 0x5350) {\n\t\t \n\t\ttmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;\t   \n\t\ttmp |= DIV_ROUND_UP(20, ns) << SSB_PROG_WCNT_2_SHIFT;   \n\t\ttmp |= DIV_ROUND_UP(100, ns) << SSB_PROG_WCNT_1_SHIFT;  \n\t\ttmp |= DIV_ROUND_UP(120, ns);\t\t\t   \n\t\tchipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp);  \n\t}\n}\n\n \nu32 ssb_chipco_watchdog_timer_set(struct ssb_chipcommon *cc, u32 ticks)\n{\n\tu32 maxt;\n\tenum ssb_clkmode clkmode;\n\n\tmaxt = ssb_chipco_watchdog_get_max_timer(cc);\n\tif (cc->capabilities & SSB_CHIPCO_CAP_PMU) {\n\t\tif (ticks == 1)\n\t\t\tticks = 2;\n\t\telse if (ticks > maxt)\n\t\t\tticks = maxt;\n\t\tchipco_write32(cc, SSB_CHIPCO_PMU_WATCHDOG, ticks);\n\t} else {\n\t\tclkmode = ticks ? SSB_CLKMODE_FAST : SSB_CLKMODE_DYNAMIC;\n\t\tssb_chipco_set_clockmode(cc, clkmode);\n\t\tif (ticks > maxt)\n\t\t\tticks = maxt;\n\t\t \n\t\tchipco_write32(cc, SSB_CHIPCO_WATCHDOG, ticks);\n\t}\n\treturn ticks;\n}\n\nvoid ssb_chipco_irq_mask(struct ssb_chipcommon *cc, u32 mask, u32 value)\n{\n\tchipco_write32_masked(cc, SSB_CHIPCO_IRQMASK, mask, value);\n}\n\nu32 ssb_chipco_irq_status(struct ssb_chipcommon *cc, u32 mask)\n{\n\treturn chipco_read32(cc, SSB_CHIPCO_IRQSTAT) & mask;\n}\n\nu32 ssb_chipco_gpio_in(struct ssb_chipcommon *cc, u32 mask)\n{\n\treturn chipco_read32(cc, SSB_CHIPCO_GPIOIN) & mask;\n}\n\nu32 ssb_chipco_gpio_out(struct ssb_chipcommon *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUT, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 ssb_chipco_gpio_outen(struct ssb_chipcommon *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUTEN, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 ssb_chipco_gpio_control(struct ssb_chipcommon *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = chipco_write32_masked(cc, SSB_CHIPCO_GPIOCTL, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(ssb_chipco_gpio_control);\n\nu32 ssb_chipco_gpio_intmask(struct ssb_chipcommon *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = chipco_write32_masked(cc, SSB_CHIPCO_GPIOIRQ, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 ssb_chipco_gpio_polarity(struct ssb_chipcommon *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = chipco_write32_masked(cc, SSB_CHIPCO_GPIOPOL, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 ssb_chipco_gpio_pullup(struct ssb_chipcommon *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tif (cc->dev->id.revision < 20)\n\t\treturn 0xffffffff;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = chipco_write32_masked(cc, SSB_CHIPCO_GPIOPULLUP, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 ssb_chipco_gpio_pulldown(struct ssb_chipcommon *cc, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tif (cc->dev->id.revision < 20)\n\t\treturn 0xffffffff;\n\n\tspin_lock_irqsave(&cc->gpio_lock, flags);\n\tres = chipco_write32_masked(cc, SSB_CHIPCO_GPIOPULLDOWN, mask, value);\n\tspin_unlock_irqrestore(&cc->gpio_lock, flags);\n\n\treturn res;\n}\n\n#ifdef CONFIG_SSB_SERIAL\nint ssb_chipco_serial_init(struct ssb_chipcommon *cc,\n\t\t\t   struct ssb_serial_port *ports)\n{\n\tstruct ssb_bus *bus = cc->dev->bus;\n\tint nr_ports = 0;\n\tu32 plltype;\n\tunsigned int irq;\n\tu32 baud_base, div;\n\tu32 i, n;\n\tunsigned int ccrev = cc->dev->id.revision;\n\n\tplltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);\n\tirq = ssb_mips_irq(cc->dev);\n\n\tif (plltype == SSB_PLLTYPE_1) {\n\t\t \n\t\tbaud_base = ssb_calc_clock_rate(plltype,\n\t\t\t\t\t\tchipco_read32(cc, SSB_CHIPCO_CLOCK_N),\n\t\t\t\t\t\tchipco_read32(cc, SSB_CHIPCO_CLOCK_M2));\n\t\tdiv = 1;\n\t} else {\n\t\tif (ccrev == 20) {\n\t\t\t \n\t\t\tbaud_base = 25000000;\n\t\t\tdiv = 48;\n\t\t\t \n\t\t\tchipco_write32(cc, SSB_CHIPCO_CORECTL,\n\t\t\t\t       chipco_read32(cc, SSB_CHIPCO_CORECTL)\n\t\t\t\t       | SSB_CHIPCO_CORECTL_UARTCLK0);\n\t\t} else if ((ccrev >= 11) && (ccrev != 15)) {\n\t\t\tbaud_base = ssb_chipco_alp_clock(cc);\n\t\t\tdiv = 1;\n\t\t\tif (ccrev >= 21) {\n\t\t\t\t \n\t\t\t\tchipco_write32(cc, SSB_CHIPCO_CORECTL,\n\t\t\t\t\t       chipco_read32(cc, SSB_CHIPCO_CORECTL)\n\t\t\t\t\t       & ~SSB_CHIPCO_CORECTL_UARTCLKEN);\n\t\t\t}\n\t\t\t \n\t\t\tchipco_write32(cc, SSB_CHIPCO_CORECTL,\n\t\t\t\t       chipco_read32(cc, SSB_CHIPCO_CORECTL)\n\t\t\t\t       | SSB_CHIPCO_CORECTL_UARTCLK0);\n\t\t\tif (ccrev >= 21) {\n\t\t\t\t \n\t\t\t\tchipco_write32(cc, SSB_CHIPCO_CORECTL,\n\t\t\t\t\t       chipco_read32(cc, SSB_CHIPCO_CORECTL)\n\t\t\t\t\t       | SSB_CHIPCO_CORECTL_UARTCLKEN);\n\t\t\t}\n\t\t} else if (ccrev >= 3) {\n\t\t\t \n\t\t\tbaud_base = ssb_clockspeed(bus);\n\t\t\tdiv = chipco_read32(cc, SSB_CHIPCO_CLKDIV)\n\t\t\t      & SSB_CHIPCO_CLKDIV_UART;\n\t\t} else {\n\t\t\t \n\t\t\tbaud_base = 88000000;\n\t\t\tdiv = 48;\n\t\t}\n\n\t\t \n\t\tif ((ccrev > 0) &&\n\t\t    !(chipco_read32(cc, SSB_CHIPCO_CORECTL) & SSB_CHIPCO_CORECTL_UARTCLK0)) {\n\t\t\tif ((cc->capabilities & SSB_CHIPCO_CAP_UARTCLK) ==\n\t\t\t    SSB_CHIPCO_CAP_UARTCLK_INT) {\n\t\t\t\t \n\t\t\t\tbaud_base /= div;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbaud_base = 1843200;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tn = (cc->capabilities & SSB_CHIPCO_CAP_NRUART);\n\tfor (i = 0; i < n; i++) {\n\t\tvoid __iomem *cc_mmio;\n\t\tvoid __iomem *uart_regs;\n\n\t\tcc_mmio = cc->dev->bus->mmio + (cc->dev->core_index * SSB_CORE_SIZE);\n\t\tuart_regs = cc_mmio + SSB_CHIPCO_UART0_DATA;\n\t\t \n\t\tif (ccrev == 0)\n\t\t\tuart_regs += (i * 8);\n\t\telse\n\t\t\tuart_regs += (i * 256);\n\n\t\tnr_ports++;\n\t\tports[i].regs = uart_regs;\n\t\tports[i].irq = irq;\n\t\tports[i].baud_base = baud_base;\n\t\tports[i].reg_shift = 0;\n\t}\n\n\treturn nr_ports;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}