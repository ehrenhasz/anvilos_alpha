{
  "module_name": "driver_extif.c",
  "hash_id": "11234912b7fdf01bebda375b64850a75ea7cada9bd940f928ae78f225285a1c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/driver_extif.c",
  "human_readable_source": " \n\n#include \"ssb_private.h\"\n\n#include <linux/serial.h>\n#include <linux/serial_core.h>\n#include <linux/serial_reg.h>\n\n\nstatic inline u32 extif_read32(struct ssb_extif *extif, u16 offset)\n{\n\treturn ssb_read32(extif->dev, offset);\n}\n\nstatic inline void extif_write32(struct ssb_extif *extif, u16 offset, u32 value)\n{\n\tssb_write32(extif->dev, offset, value);\n}\n\nstatic inline u32 extif_write32_masked(struct ssb_extif *extif, u16 offset,\n\t\t\t\t       u32 mask, u32 value)\n{\n\tvalue &= mask;\n\tvalue |= extif_read32(extif, offset) & ~mask;\n\textif_write32(extif, offset, value);\n\n\treturn value;\n}\n\n#ifdef CONFIG_SSB_SERIAL\nstatic bool serial_exists(u8 *regs)\n{\n\tu8 save_mcr, msr = 0;\n\n\tif (regs) {\n\t\tsave_mcr = regs[UART_MCR];\n\t\tregs[UART_MCR] = (UART_MCR_LOOP | UART_MCR_OUT2 | UART_MCR_RTS);\n\t\tmsr = regs[UART_MSR] & (UART_MSR_DCD | UART_MSR_RI\n\t\t\t\t\t| UART_MSR_CTS | UART_MSR_DSR);\n\t\tregs[UART_MCR] = save_mcr;\n\t}\n\treturn (msr == (UART_MSR_DCD | UART_MSR_CTS));\n}\n\nint ssb_extif_serial_init(struct ssb_extif *extif, struct ssb_serial_port *ports)\n{\n\tu32 i, nr_ports = 0;\n\n\t \n\textif_write32(extif, SSB_EXTIF_GPIO_INTPOL, 0);\n\textif_write32(extif, SSB_EXTIF_GPIO_INTMASK, 0);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tvoid __iomem *uart_regs;\n\n\t\tuart_regs = ioremap(SSB_EUART, 16);\n\t\tif (uart_regs) {\n\t\t\tuart_regs += (i * 8);\n\n\t\t\tif (serial_exists(uart_regs) && ports) {\n\t\t\t\textif_write32(extif, SSB_EXTIF_GPIO_INTMASK, 2);\n\n\t\t\t\tnr_ports++;\n\t\t\t\tports[i].regs = uart_regs;\n\t\t\t\tports[i].irq = 2;\n\t\t\t\tports[i].baud_base = 13500000;\n\t\t\t\tports[i].reg_shift = 0;\n\t\t\t}\n\t\t\tiounmap(uart_regs);\n\t\t}\n\t}\n\treturn nr_ports;\n}\n#endif  \n\nvoid ssb_extif_timing_init(struct ssb_extif *extif, unsigned long ns)\n{\n\tu32 tmp;\n\n\t \n\textif_write32(extif, SSB_EXTIF_PROG_CFG, SSB_EXTCFG_EN);\n\n\t \n\ttmp  = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;\n\ttmp |= DIV_ROUND_UP(40, ns) << SSB_PROG_WCNT_1_SHIFT;\n\ttmp |= DIV_ROUND_UP(120, ns);\n\textif_write32(extif, SSB_EXTIF_PROG_WAITCNT, tmp);\n\n\t \n\ttmp  = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;\n\ttmp |= DIV_ROUND_UP(20, ns) << SSB_PROG_WCNT_2_SHIFT;\n\ttmp |= DIV_ROUND_UP(100, ns) << SSB_PROG_WCNT_1_SHIFT;\n\ttmp |= DIV_ROUND_UP(120, ns);\n\textif_write32(extif, SSB_EXTIF_PROG_WAITCNT, tmp);\n}\n\nvoid ssb_extif_get_clockcontrol(struct ssb_extif *extif,\n\t\t\t\tu32 *pll_type, u32 *n, u32 *m)\n{\n\t*pll_type = SSB_PLLTYPE_1;\n\t*n = extif_read32(extif, SSB_EXTIF_CLOCK_N);\n\t*m = extif_read32(extif, SSB_EXTIF_CLOCK_SB);\n}\n\nu32 ssb_extif_watchdog_timer_set_wdt(struct bcm47xx_wdt *wdt, u32 ticks)\n{\n\tstruct ssb_extif *extif = bcm47xx_wdt_get_drvdata(wdt);\n\n\treturn ssb_extif_watchdog_timer_set(extif, ticks);\n}\n\nu32 ssb_extif_watchdog_timer_set_ms(struct bcm47xx_wdt *wdt, u32 ms)\n{\n\tstruct ssb_extif *extif = bcm47xx_wdt_get_drvdata(wdt);\n\tu32 ticks = (SSB_EXTIF_WATCHDOG_CLK / 1000) * ms;\n\n\tticks = ssb_extif_watchdog_timer_set(extif, ticks);\n\n\treturn (ticks * 1000) / SSB_EXTIF_WATCHDOG_CLK;\n}\n\nu32 ssb_extif_watchdog_timer_set(struct ssb_extif *extif, u32 ticks)\n{\n\tif (ticks > SSB_EXTIF_WATCHDOG_MAX_TIMER)\n\t\tticks = SSB_EXTIF_WATCHDOG_MAX_TIMER;\n\textif_write32(extif, SSB_EXTIF_WATCHDOG, ticks);\n\n\treturn ticks;\n}\n\nvoid ssb_extif_init(struct ssb_extif *extif)\n{\n\tif (!extif->dev)\n\t\treturn;  \n\tspin_lock_init(&extif->gpio_lock);\n}\n\nu32 ssb_extif_gpio_in(struct ssb_extif *extif, u32 mask)\n{\n\treturn extif_read32(extif, SSB_EXTIF_GPIO_IN) & mask;\n}\n\nu32 ssb_extif_gpio_out(struct ssb_extif *extif, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&extif->gpio_lock, flags);\n\tres = extif_write32_masked(extif, SSB_EXTIF_GPIO_OUT(0),\n\t\t\t\t   mask, value);\n\tspin_unlock_irqrestore(&extif->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 ssb_extif_gpio_outen(struct ssb_extif *extif, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&extif->gpio_lock, flags);\n\tres = extif_write32_masked(extif, SSB_EXTIF_GPIO_OUTEN(0),\n\t\t\t\t   mask, value);\n\tspin_unlock_irqrestore(&extif->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 ssb_extif_gpio_polarity(struct ssb_extif *extif, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&extif->gpio_lock, flags);\n\tres = extif_write32_masked(extif, SSB_EXTIF_GPIO_INTPOL, mask, value);\n\tspin_unlock_irqrestore(&extif->gpio_lock, flags);\n\n\treturn res;\n}\n\nu32 ssb_extif_gpio_intmask(struct ssb_extif *extif, u32 mask, u32 value)\n{\n\tunsigned long flags;\n\tu32 res = 0;\n\n\tspin_lock_irqsave(&extif->gpio_lock, flags);\n\tres = extif_write32_masked(extif, SSB_EXTIF_GPIO_INTMASK, mask, value);\n\tspin_unlock_irqrestore(&extif->gpio_lock, flags);\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}