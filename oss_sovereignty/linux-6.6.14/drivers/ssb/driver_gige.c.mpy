{
  "module_name": "driver_gige.c",
  "hash_id": "b9f3d08f2ec6068cf349e6e05758f075a65cdecc7da5895bf466aab310cf4f66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ssb/driver_gige.c",
  "human_readable_source": " \n\n#include <linux/ssb/ssb.h>\n#include <linux/ssb/ssb_driver_gige.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/slab.h>\n\n\n \n\nstatic const struct ssb_device_id ssb_gige_tbl[] = {\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_ETHERNET_GBIT, SSB_ANY_REV),\n\t{},\n};\n \n\n\nstatic inline u8 gige_read8(struct ssb_gige *dev, u16 offset)\n{\n\treturn ssb_read8(dev->dev, offset);\n}\n\nstatic inline u16 gige_read16(struct ssb_gige *dev, u16 offset)\n{\n\treturn ssb_read16(dev->dev, offset);\n}\n\nstatic inline u32 gige_read32(struct ssb_gige *dev, u16 offset)\n{\n\treturn ssb_read32(dev->dev, offset);\n}\n\nstatic inline void gige_write8(struct ssb_gige *dev,\n\t\t\t       u16 offset, u8 value)\n{\n\tssb_write8(dev->dev, offset, value);\n}\n\nstatic inline void gige_write16(struct ssb_gige *dev,\n\t\t\t\tu16 offset, u16 value)\n{\n\tssb_write16(dev->dev, offset, value);\n}\n\nstatic inline void gige_write32(struct ssb_gige *dev,\n\t\t\t\tu16 offset, u32 value)\n{\n\tssb_write32(dev->dev, offset, value);\n}\n\nstatic inline\nu8 gige_pcicfg_read8(struct ssb_gige *dev, unsigned int offset)\n{\n\tBUG_ON(offset >= 256);\n\treturn gige_read8(dev, SSB_GIGE_PCICFG + offset);\n}\n\nstatic inline\nu16 gige_pcicfg_read16(struct ssb_gige *dev, unsigned int offset)\n{\n\tBUG_ON(offset >= 256);\n\treturn gige_read16(dev, SSB_GIGE_PCICFG + offset);\n}\n\nstatic inline\nu32 gige_pcicfg_read32(struct ssb_gige *dev, unsigned int offset)\n{\n\tBUG_ON(offset >= 256);\n\treturn gige_read32(dev, SSB_GIGE_PCICFG + offset);\n}\n\nstatic inline\nvoid gige_pcicfg_write8(struct ssb_gige *dev,\n\t\t\tunsigned int offset, u8 value)\n{\n\tBUG_ON(offset >= 256);\n\tgige_write8(dev, SSB_GIGE_PCICFG + offset, value);\n}\n\nstatic inline\nvoid gige_pcicfg_write16(struct ssb_gige *dev,\n\t\t\t unsigned int offset, u16 value)\n{\n\tBUG_ON(offset >= 256);\n\tgige_write16(dev, SSB_GIGE_PCICFG + offset, value);\n}\n\nstatic inline\nvoid gige_pcicfg_write32(struct ssb_gige *dev,\n\t\t\t unsigned int offset, u32 value)\n{\n\tBUG_ON(offset >= 256);\n\tgige_write32(dev, SSB_GIGE_PCICFG + offset, value);\n}\n\nstatic int ssb_gige_pci_read_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t    int reg, int size, u32 *val)\n{\n\tstruct ssb_gige *dev = container_of(bus->ops, struct ssb_gige, pci_ops);\n\tunsigned long flags;\n\n\tif ((PCI_SLOT(devfn) > 0) || (PCI_FUNC(devfn) > 0))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (reg >= 256)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tswitch (size) {\n\tcase 1:\n\t\t*val = gige_pcicfg_read8(dev, reg);\n\t\tbreak;\n\tcase 2:\n\t\t*val = gige_pcicfg_read16(dev, reg);\n\t\tbreak;\n\tcase 4:\n\t\t*val = gige_pcicfg_read32(dev, reg);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int ssb_gige_pci_write_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t     int reg, int size, u32 val)\n{\n\tstruct ssb_gige *dev = container_of(bus->ops, struct ssb_gige, pci_ops);\n\tunsigned long flags;\n\n\tif ((PCI_SLOT(devfn) > 0) || (PCI_FUNC(devfn) > 0))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (reg >= 256)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tswitch (size) {\n\tcase 1:\n\t\tgige_pcicfg_write8(dev, reg, val);\n\t\tbreak;\n\tcase 2:\n\t\tgige_pcicfg_write16(dev, reg, val);\n\t\tbreak;\n\tcase 4:\n\t\tgige_pcicfg_write32(dev, reg, val);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int ssb_gige_probe(struct ssb_device *sdev,\n\t\t\t  const struct ssb_device_id *id)\n{\n\tstruct ssb_gige *dev;\n\tu32 base, tmslow, tmshigh;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->dev = sdev;\n\n\tspin_lock_init(&dev->lock);\n\tdev->pci_controller.pci_ops = &dev->pci_ops;\n\tdev->pci_controller.io_resource = &dev->io_resource;\n\tdev->pci_controller.mem_resource = &dev->mem_resource;\n\tdev->pci_controller.io_map_base = 0x800;\n\tdev->pci_ops.read = ssb_gige_pci_read_config;\n\tdev->pci_ops.write = ssb_gige_pci_write_config;\n\n\tdev->io_resource.name = SSB_GIGE_IO_RES_NAME;\n\tdev->io_resource.start = 0x800;\n\tdev->io_resource.end = 0x8FF;\n\tdev->io_resource.flags = IORESOURCE_IO | IORESOURCE_PCI_FIXED;\n\n\tif (!ssb_device_is_enabled(sdev))\n\t\tssb_device_enable(sdev, 0);\n\n\t \n\tbase = ssb_admatch_base(ssb_read32(sdev, SSB_ADMATCH1));\n\tgige_pcicfg_write32(dev, PCI_BASE_ADDRESS_0, base);\n\tgige_pcicfg_write32(dev, PCI_BASE_ADDRESS_1, 0);\n\n\tdev->mem_resource.name = SSB_GIGE_MEM_RES_NAME;\n\tdev->mem_resource.start = base;\n\tdev->mem_resource.end = base + 0x10000 - 1;\n\tdev->mem_resource.flags = IORESOURCE_MEM | IORESOURCE_PCI_FIXED;\n\n\t \n\tgige_pcicfg_write16(dev, PCI_COMMAND,\n\t\t\t    gige_pcicfg_read16(dev, PCI_COMMAND)\n\t\t\t    | PCI_COMMAND_MEMORY);\n\n\t \n\tgige_write32(dev, SSB_GIGE_SHIM_FLUSHSTAT, 0x00000068);\n\n\t \n\ttmslow = ssb_read32(sdev, SSB_TMSLOW);\n\ttmshigh = ssb_read32(sdev, SSB_TMSHIGH);\n\tif (tmshigh & SSB_GIGE_TMSHIGH_RGMII) {\n\t\ttmslow &= ~SSB_GIGE_TMSLOW_TXBYPASS;\n\t\ttmslow &= ~SSB_GIGE_TMSLOW_RXBYPASS;\n\t\tdev->has_rgmii = 1;\n\t} else {\n\t\ttmslow |= SSB_GIGE_TMSLOW_TXBYPASS;\n\t\ttmslow |= SSB_GIGE_TMSLOW_RXBYPASS;\n\t\tdev->has_rgmii = 0;\n\t}\n\ttmslow |= SSB_GIGE_TMSLOW_DLLEN;\n\tssb_write32(sdev, SSB_TMSLOW, tmslow);\n\n\tssb_set_drvdata(sdev, dev);\n\tregister_pci_controller(&dev->pci_controller);\n\n\treturn 0;\n}\n\nbool pdev_is_ssb_gige_core(struct pci_dev *pdev)\n{\n\tif (!pdev->resource[0].name)\n\t\treturn false;\n\treturn (strcmp(pdev->resource[0].name, SSB_GIGE_MEM_RES_NAME) == 0);\n}\nEXPORT_SYMBOL(pdev_is_ssb_gige_core);\n\nint ssb_gige_pcibios_plat_dev_init(struct ssb_device *sdev,\n\t\t\t\t   struct pci_dev *pdev)\n{\n\tstruct ssb_gige *dev = ssb_get_drvdata(sdev);\n\tstruct resource *res;\n\n\tif (pdev->bus->ops != &dev->pci_ops) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\t \n\tres = &(pdev->resource[0]);\n\tres->flags = IORESOURCE_MEM | IORESOURCE_PCI_FIXED;\n\tres->name = dev->mem_resource.name;\n\tres->start = dev->mem_resource.start;\n\tres->end = dev->mem_resource.end;\n\n\t \n\tpdev->irq = ssb_mips_irq(sdev) + 2;\n\tpci_write_config_byte(pdev, PCI_INTERRUPT_LINE, pdev->irq);\n\n\treturn 0;\n}\n\nint ssb_gige_map_irq(struct ssb_device *sdev,\n\t\t     const struct pci_dev *pdev)\n{\n\tstruct ssb_gige *dev = ssb_get_drvdata(sdev);\n\n\tif (pdev->bus->ops != &dev->pci_ops) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\treturn ssb_mips_irq(sdev) + 2;\n}\n\nstatic struct ssb_driver ssb_gige_driver = {\n\t.name\t\t= \"BCM-GigE\",\n\t.id_table\t= ssb_gige_tbl,\n\t.probe\t\t= ssb_gige_probe,\n};\n\nint ssb_gige_init(void)\n{\n\treturn ssb_driver_register(&ssb_gige_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}