{
  "module_name": "hid-led.c",
  "hash_id": "7e8f88f6d0fa018823c66139efd9feeb317cb014e648de868b8a1e7925f5f10e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-led.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/hidraw.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include \"hid-ids.h\"\n\nenum hidled_report_type {\n\tRAW_REQUEST,\n\tOUTPUT_REPORT\n};\n\nenum hidled_type {\n\tRISO_KAGAKU,\n\tDREAM_CHEEKY,\n\tTHINGM,\n\tDELCOM,\n\tLUXAFOR,\n};\n\nstatic unsigned const char riso_kagaku_tbl[] = {\n \n\t[0] = 0,  \n\t[1] = 2,  \n\t[2] = 1,  \n\t[3] = 5,  \n\t[4] = 3,  \n\t[5] = 6,  \n\t[6] = 4,  \n\t[7] = 7   \n};\n\n#define RISO_KAGAKU_IX(r, g, b) riso_kagaku_tbl[((r)?1:0)+((g)?2:0)+((b)?4:0)]\n\nunion delcom_packet {\n\t__u8 data[8];\n\tstruct {\n\t\t__u8 major_cmd;\n\t\t__u8 minor_cmd;\n\t\t__u8 data_lsb;\n\t\t__u8 data_msb;\n\t} tx;\n\tstruct {\n\t\t__u8 cmd;\n\t} rx;\n\tstruct {\n\t\t__le16 family_code;\n\t\t__le16 security_code;\n\t\t__u8 fw_version;\n\t} fw;\n};\n\n#define DELCOM_GREEN_LED\t0\n#define DELCOM_RED_LED\t\t1\n#define DELCOM_BLUE_LED\t\t2\n\nstruct hidled_device;\nstruct hidled_rgb;\n\nstruct hidled_config {\n\tenum hidled_type\ttype;\n\tconst char\t\t*name;\n\tconst char\t\t*short_name;\n\tenum led_brightness\tmax_brightness;\n\tint\t\t\tnum_leds;\n\tsize_t\t\t\treport_size;\n\tenum hidled_report_type\treport_type;\n\tint (*init)(struct hidled_device *ldev);\n\tint (*write)(struct led_classdev *cdev, enum led_brightness br);\n};\n\nstruct hidled_led {\n\tstruct led_classdev\tcdev;\n\tstruct hidled_rgb\t*rgb;\n\tchar\t\t\tname[32];\n};\n\nstruct hidled_rgb {\n\tstruct hidled_device\t*ldev;\n\tstruct hidled_led\tred;\n\tstruct hidled_led\tgreen;\n\tstruct hidled_led\tblue;\n\tu8\t\t\tnum;\n};\n\nstruct hidled_device {\n\tconst struct hidled_config *config;\n\tstruct hid_device       *hdev;\n\tstruct hidled_rgb\t*rgb;\n\tu8\t\t\t*buf;\n\tstruct mutex\t\tlock;\n};\n\n#define MAX_REPORT_SIZE\t\t16\n\n#define to_hidled_led(arg) container_of(arg, struct hidled_led, cdev)\n\nstatic bool riso_kagaku_switch_green_blue;\nmodule_param(riso_kagaku_switch_green_blue, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(riso_kagaku_switch_green_blue,\n\t\"switch green and blue RGB component for Riso Kagaku devices\");\n\nstatic int hidled_send(struct hidled_device *ldev, __u8 *buf)\n{\n\tint ret;\n\n\tmutex_lock(&ldev->lock);\n\n\t \n\tmemcpy(ldev->buf, buf, ldev->config->report_size);\n\n\tif (ldev->config->report_type == RAW_REQUEST)\n\t\tret = hid_hw_raw_request(ldev->hdev, buf[0], ldev->buf,\n\t\t\t\t\t ldev->config->report_size,\n\t\t\t\t\t HID_FEATURE_REPORT,\n\t\t\t\t\t HID_REQ_SET_REPORT);\n\telse if (ldev->config->report_type == OUTPUT_REPORT)\n\t\tret = hid_hw_output_report(ldev->hdev, ldev->buf,\n\t\t\t\t\t   ldev->config->report_size);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&ldev->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret == ldev->config->report_size ? 0 : -EMSGSIZE;\n}\n\n \nstatic int hidled_recv(struct hidled_device *ldev, __u8 *buf)\n{\n\tint ret;\n\n\tif (ldev->config->report_type != RAW_REQUEST)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ldev->lock);\n\n\tmemcpy(ldev->buf, buf, ldev->config->report_size);\n\n\tret = hid_hw_raw_request(ldev->hdev, buf[0], ldev->buf,\n\t\t\t\t ldev->config->report_size,\n\t\t\t\t HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = hid_hw_raw_request(ldev->hdev, buf[0], ldev->buf,\n\t\t\t\t ldev->config->report_size,\n\t\t\t\t HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\n\tmemcpy(buf, ldev->buf, ldev->config->report_size);\nerr:\n\tmutex_unlock(&ldev->lock);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic u8 riso_kagaku_index(struct hidled_rgb *rgb)\n{\n\tenum led_brightness r, g, b;\n\n\tr = rgb->red.cdev.brightness;\n\tg = rgb->green.cdev.brightness;\n\tb = rgb->blue.cdev.brightness;\n\n\tif (riso_kagaku_switch_green_blue)\n\t\treturn RISO_KAGAKU_IX(r, b, g);\n\telse\n\t\treturn RISO_KAGAKU_IX(r, g, b);\n}\n\nstatic int riso_kagaku_write(struct led_classdev *cdev, enum led_brightness br)\n{\n\tstruct hidled_led *led = to_hidled_led(cdev);\n\tstruct hidled_rgb *rgb = led->rgb;\n\t__u8 buf[MAX_REPORT_SIZE] = {};\n\n\tbuf[1] = riso_kagaku_index(rgb);\n\n\treturn hidled_send(rgb->ldev, buf);\n}\n\nstatic int dream_cheeky_write(struct led_classdev *cdev, enum led_brightness br)\n{\n\tstruct hidled_led *led = to_hidled_led(cdev);\n\tstruct hidled_rgb *rgb = led->rgb;\n\t__u8 buf[MAX_REPORT_SIZE] = {};\n\n\tbuf[1] = rgb->red.cdev.brightness;\n\tbuf[2] = rgb->green.cdev.brightness;\n\tbuf[3] = rgb->blue.cdev.brightness;\n\tbuf[7] = 0x1a;\n\tbuf[8] = 0x05;\n\n\treturn hidled_send(rgb->ldev, buf);\n}\n\nstatic int dream_cheeky_init(struct hidled_device *ldev)\n{\n\t__u8 buf[MAX_REPORT_SIZE] = {};\n\n\t \n\tbuf[1] = 0x1f;\n\tbuf[2] = 0x02;\n\tbuf[4] = 0x5f;\n\tbuf[7] = 0x1a;\n\tbuf[8] = 0x03;\n\n\treturn hidled_send(ldev, buf);\n}\n\nstatic int _thingm_write(struct led_classdev *cdev, enum led_brightness br,\n\t\t\t u8 offset)\n{\n\tstruct hidled_led *led = to_hidled_led(cdev);\n\t__u8 buf[MAX_REPORT_SIZE] = { 1, 'c' };\n\n\tbuf[2] = led->rgb->red.cdev.brightness;\n\tbuf[3] = led->rgb->green.cdev.brightness;\n\tbuf[4] = led->rgb->blue.cdev.brightness;\n\tbuf[7] = led->rgb->num + offset;\n\n\treturn hidled_send(led->rgb->ldev, buf);\n}\n\nstatic int thingm_write_v1(struct led_classdev *cdev, enum led_brightness br)\n{\n\treturn _thingm_write(cdev, br, 0);\n}\n\nstatic int thingm_write(struct led_classdev *cdev, enum led_brightness br)\n{\n\treturn _thingm_write(cdev, br, 1);\n}\n\nstatic const struct hidled_config hidled_config_thingm_v1 = {\n\t.name = \"ThingM blink(1) v1\",\n\t.short_name = \"thingm\",\n\t.max_brightness = 255,\n\t.num_leds = 1,\n\t.report_size = 9,\n\t.report_type = RAW_REQUEST,\n\t.write = thingm_write_v1,\n};\n\nstatic int thingm_init(struct hidled_device *ldev)\n{\n\t__u8 buf[MAX_REPORT_SIZE] = { 1, 'v' };\n\tint ret;\n\n\tret = hidled_recv(ldev, buf);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (buf[3] == '1')\n\t\tldev->config = &hidled_config_thingm_v1;\n\n\treturn 0;\n}\n\nstatic inline int delcom_get_lednum(const struct hidled_led *led)\n{\n\tif (led == &led->rgb->red)\n\t\treturn DELCOM_RED_LED;\n\telse if (led == &led->rgb->green)\n\t\treturn DELCOM_GREEN_LED;\n\telse\n\t\treturn DELCOM_BLUE_LED;\n}\n\nstatic int delcom_enable_led(struct hidled_led *led)\n{\n\tunion delcom_packet dp = { .tx.major_cmd = 101, .tx.minor_cmd = 12 };\n\n\tdp.tx.data_lsb = 1 << delcom_get_lednum(led);\n\tdp.tx.data_msb = 0;\n\n\treturn hidled_send(led->rgb->ldev, dp.data);\n}\n\nstatic int delcom_set_pwm(struct hidled_led *led)\n{\n\tunion delcom_packet dp = { .tx.major_cmd = 101, .tx.minor_cmd = 34 };\n\n\tdp.tx.data_lsb = delcom_get_lednum(led);\n\tdp.tx.data_msb = led->cdev.brightness;\n\n\treturn hidled_send(led->rgb->ldev, dp.data);\n}\n\nstatic int delcom_write(struct led_classdev *cdev, enum led_brightness br)\n{\n\tstruct hidled_led *led = to_hidled_led(cdev);\n\tint ret;\n\n\t \n\tret = delcom_enable_led(led);\n\tif (ret)\n\t\treturn ret;\n\n\treturn delcom_set_pwm(led);\n}\n\nstatic int delcom_init(struct hidled_device *ldev)\n{\n\tunion delcom_packet dp = { .rx.cmd = 104 };\n\tint ret;\n\n\tret = hidled_recv(ldev, dp.data);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn le16_to_cpu(dp.fw.family_code) == 2 ? 0 : -ENODEV;\n}\n\nstatic int luxafor_write(struct led_classdev *cdev, enum led_brightness br)\n{\n\tstruct hidled_led *led = to_hidled_led(cdev);\n\t__u8 buf[MAX_REPORT_SIZE] = { [1] = 1 };\n\n\tbuf[2] = led->rgb->num + 1;\n\tbuf[3] = led->rgb->red.cdev.brightness;\n\tbuf[4] = led->rgb->green.cdev.brightness;\n\tbuf[5] = led->rgb->blue.cdev.brightness;\n\n\treturn hidled_send(led->rgb->ldev, buf);\n}\n\nstatic const struct hidled_config hidled_configs[] = {\n\t{\n\t\t.type = RISO_KAGAKU,\n\t\t.name = \"Riso Kagaku Webmail Notifier\",\n\t\t.short_name = \"riso_kagaku\",\n\t\t.max_brightness = 1,\n\t\t.num_leds = 1,\n\t\t.report_size = 6,\n\t\t.report_type = OUTPUT_REPORT,\n\t\t.write = riso_kagaku_write,\n\t},\n\t{\n\t\t.type = DREAM_CHEEKY,\n\t\t.name = \"Dream Cheeky Webmail Notifier\",\n\t\t.short_name = \"dream_cheeky\",\n\t\t.max_brightness = 63,\n\t\t.num_leds = 1,\n\t\t.report_size = 9,\n\t\t.report_type = RAW_REQUEST,\n\t\t.init = dream_cheeky_init,\n\t\t.write = dream_cheeky_write,\n\t},\n\t{\n\t\t.type = THINGM,\n\t\t.name = \"ThingM blink(1)\",\n\t\t.short_name = \"thingm\",\n\t\t.max_brightness = 255,\n\t\t.num_leds = 2,\n\t\t.report_size = 9,\n\t\t.report_type = RAW_REQUEST,\n\t\t.init = thingm_init,\n\t\t.write = thingm_write,\n\t},\n\t{\n\t\t.type = DELCOM,\n\t\t.name = \"Delcom Visual Signal Indicator G2\",\n\t\t.short_name = \"delcom\",\n\t\t.max_brightness = 100,\n\t\t.num_leds = 1,\n\t\t.report_size = 8,\n\t\t.report_type = RAW_REQUEST,\n\t\t.init = delcom_init,\n\t\t.write = delcom_write,\n\t},\n\t{\n\t\t.type = LUXAFOR,\n\t\t.name = \"Greynut Luxafor\",\n\t\t.short_name = \"luxafor\",\n\t\t.max_brightness = 255,\n\t\t.num_leds = 6,\n\t\t.report_size = 9,\n\t\t.report_type = OUTPUT_REPORT,\n\t\t.write = luxafor_write,\n\t},\n};\n\nstatic int hidled_init_led(struct hidled_led *led, const char *color_name,\n\t\t\t   struct hidled_rgb *rgb, unsigned int minor)\n{\n\tconst struct hidled_config *config = rgb->ldev->config;\n\n\tif (config->num_leds > 1)\n\t\tsnprintf(led->name, sizeof(led->name), \"%s%u:%s:led%u\",\n\t\t\t config->short_name, minor, color_name, rgb->num);\n\telse\n\t\tsnprintf(led->name, sizeof(led->name), \"%s%u:%s\",\n\t\t\t config->short_name, minor, color_name);\n\tled->cdev.name = led->name;\n\tled->cdev.max_brightness = config->max_brightness;\n\tled->cdev.brightness_set_blocking = config->write;\n\tled->cdev.flags = LED_HW_PLUGGABLE;\n\tled->rgb = rgb;\n\n\treturn devm_led_classdev_register(&rgb->ldev->hdev->dev, &led->cdev);\n}\n\nstatic int hidled_init_rgb(struct hidled_rgb *rgb, unsigned int minor)\n{\n\tint ret;\n\n\t \n\tret = hidled_init_led(&rgb->red, \"red\", rgb, minor);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = hidled_init_led(&rgb->green, \"green\", rgb, minor);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn hidled_init_led(&rgb->blue, \"blue\", rgb, minor);\n}\n\nstatic int hidled_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct hidled_device *ldev;\n\tunsigned int minor;\n\tint ret, i;\n\n\tldev = devm_kzalloc(&hdev->dev, sizeof(*ldev), GFP_KERNEL);\n\tif (!ldev)\n\t\treturn -ENOMEM;\n\n\tldev->buf = devm_kmalloc(&hdev->dev, MAX_REPORT_SIZE, GFP_KERNEL);\n\tif (!ldev->buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tldev->hdev = hdev;\n\tmutex_init(&ldev->lock);\n\n\tfor (i = 0; !ldev->config && i < ARRAY_SIZE(hidled_configs); i++)\n\t\tif (hidled_configs[i].type == id->driver_data)\n\t\t\tldev->config = &hidled_configs[i];\n\n\tif (!ldev->config)\n\t\treturn -EINVAL;\n\n\tif (ldev->config->init) {\n\t\tret = ldev->config->init(ldev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tldev->rgb = devm_kcalloc(&hdev->dev, ldev->config->num_leds,\n\t\t\t\t sizeof(struct hidled_rgb), GFP_KERNEL);\n\tif (!ldev->rgb)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tfor (i = 0; i < ldev->config->num_leds; i++) {\n\t\tldev->rgb[i].ldev = ldev;\n\t\tldev->rgb[i].num = i;\n\t\tret = hidled_init_rgb(&ldev->rgb[i], minor);\n\t\tif (ret) {\n\t\t\thid_hw_stop(hdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thid_info(hdev, \"%s initialized\\n\", ldev->config->name);\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id hidled_table[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_RISO_KAGAKU,\n\t  USB_DEVICE_ID_RI_KA_WEBMAIL), .driver_data = RISO_KAGAKU },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DREAM_CHEEKY,\n\t  USB_DEVICE_ID_DREAM_CHEEKY_WN), .driver_data = DREAM_CHEEKY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DREAM_CHEEKY,\n\t  USB_DEVICE_ID_DREAM_CHEEKY_FA), .driver_data = DREAM_CHEEKY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THINGM,\n\t  USB_DEVICE_ID_BLINK1), .driver_data = THINGM },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DELCOM,\n\t  USB_DEVICE_ID_DELCOM_VISUAL_IND), .driver_data = DELCOM },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP,\n\t  USB_DEVICE_ID_LUXAFOR), .driver_data = LUXAFOR },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, hidled_table);\n\nstatic struct hid_driver hidled_driver = {\n\t.name = \"hid-led\",\n\t.probe = hidled_probe,\n\t.id_table = hidled_table,\n};\n\nmodule_hid_driver(hidled_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Heiner Kallweit <hkallweit1@gmail.com>\");\nMODULE_DESCRIPTION(\"Simple USB RGB LED driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}