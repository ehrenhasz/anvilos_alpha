{
  "module_name": "hid-samsung.c",
  "hash_id": "9a7435ef132369cdf206e45e967740cf499d9615215a1530de5cbca55d94614d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-samsung.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n \nstatic inline void samsung_irda_dev_trace(struct hid_device *hdev,\n\t\tunsigned int rsize)\n{\n\thid_info(hdev, \"fixing up Samsung IrDA %d byte report descriptor\\n\",\n\t\t rsize);\n}\n\nstatic __u8 *samsung_irda_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize == 184 && rdesc[175] == 0x25 && rdesc[176] == 0x40 &&\n\t\t\trdesc[177] == 0x75 && rdesc[178] == 0x30 &&\n\t\t\trdesc[179] == 0x95 && rdesc[180] == 0x01 &&\n\t\t\trdesc[182] == 0x40) {\n\t\tsamsung_irda_dev_trace(hdev, 184);\n\t\trdesc[176] = 0xff;\n\t\trdesc[178] = 0x08;\n\t\trdesc[180] = 0x06;\n\t\trdesc[182] = 0x42;\n\t} else\n\tif (*rsize == 203 && rdesc[192] == 0x15 && rdesc[193] == 0x0 &&\n\t\t\trdesc[194] == 0x25 && rdesc[195] == 0x12) {\n\t\tsamsung_irda_dev_trace(hdev, 203);\n\t\trdesc[193] = 0x1;\n\t\trdesc[195] = 0xf;\n\t} else\n\tif (*rsize == 135 && rdesc[124] == 0x15 && rdesc[125] == 0x0 &&\n\t\t\trdesc[126] == 0x25 && rdesc[127] == 0x11) {\n\t\tsamsung_irda_dev_trace(hdev, 135);\n\t\trdesc[125] = 0x1;\n\t\trdesc[127] = 0xe;\n\t} else\n\tif (*rsize == 171 && rdesc[160] == 0x15 && rdesc[161] == 0x0 &&\n\t\t\trdesc[162] == 0x25 && rdesc[163] == 0x01) {\n\t\tsamsung_irda_dev_trace(hdev, 171);\n\t\trdesc[161] = 0x1;\n\t\trdesc[163] = 0x3;\n\t}\n\treturn rdesc;\n}\n\n#define samsung_kbd_mouse_map_key_clear(c) \\\n\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, (c))\n\nstatic int samsung_kbd_mouse_input_mapping(struct hid_device *hdev,\n\tstruct hid_input *hi, struct hid_field *field, struct hid_usage *usage,\n\tunsigned long **bit, int *max)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tunsigned short ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tif (1 != ifnum || HID_UP_CONSUMER != (usage->hid & HID_USAGE_PAGE))\n\t\treturn 0;\n\n\tdbg_hid(\"samsung wireless keyboard/mouse input mapping event [0x%x]\\n\",\n\t\tusage->hid & HID_USAGE);\n\n\tswitch (usage->hid & HID_USAGE) {\n\t \n\tcase 0x183: samsung_kbd_mouse_map_key_clear(KEY_MEDIA); break;\n\tcase 0x195: samsung_kbd_mouse_map_key_clear(KEY_EMAIL);\tbreak;\n\tcase 0x196: samsung_kbd_mouse_map_key_clear(KEY_CALC); break;\n\tcase 0x197: samsung_kbd_mouse_map_key_clear(KEY_COMPUTER); break;\n\tcase 0x22b: samsung_kbd_mouse_map_key_clear(KEY_SEARCH); break;\n\tcase 0x22c: samsung_kbd_mouse_map_key_clear(KEY_WWW); break;\n\tcase 0x22d: samsung_kbd_mouse_map_key_clear(KEY_BACK); break;\n\tcase 0x22e: samsung_kbd_mouse_map_key_clear(KEY_FORWARD); break;\n\tcase 0x22f: samsung_kbd_mouse_map_key_clear(KEY_FAVORITES); break;\n\tcase 0x230: samsung_kbd_mouse_map_key_clear(KEY_REFRESH); break;\n\tcase 0x231: samsung_kbd_mouse_map_key_clear(KEY_STOP); break;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic __u8 *samsung_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\tunsigned int *rsize)\n{\n\tif (USB_DEVICE_ID_SAMSUNG_IR_REMOTE == hdev->product)\n\t\trdesc = samsung_irda_report_fixup(hdev, rdesc, rsize);\n\treturn rdesc;\n}\n\nstatic int samsung_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\tstruct hid_field *field, struct hid_usage *usage,\n\tunsigned long **bit, int *max)\n{\n\tint ret = 0;\n\n\tif (USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE == hdev->product)\n\t\tret = samsung_kbd_mouse_input_mapping(hdev,\n\t\t\thi, field, usage, bit, max);\n\n\treturn ret;\n}\n\nstatic int samsung_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint ret;\n\tunsigned int cmask = HID_CONNECT_DEFAULT;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (USB_DEVICE_ID_SAMSUNG_IR_REMOTE == hdev->product) {\n\t\tif (hdev->rsize == 184) {\n\t\t\t \n\t\t\tcmask = (cmask & ~HID_CONNECT_HIDINPUT) |\n\t\t\t\tHID_CONNECT_HIDDEV_FORCE;\n\t\t}\n\t}\n\n\tret = hid_hw_start(hdev, cmask);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\nerr_free:\n\treturn ret;\n}\n\nstatic const struct hid_device_id samsung_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, samsung_devices);\n\nstatic struct hid_driver samsung_driver = {\n\t.name = \"samsung\",\n\t.id_table = samsung_devices,\n\t.report_fixup = samsung_report_fixup,\n\t.input_mapping = samsung_input_mapping,\n\t.probe = samsung_probe,\n};\nmodule_hid_driver(samsung_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}