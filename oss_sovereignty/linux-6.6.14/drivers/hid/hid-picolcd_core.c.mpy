{
  "module_name": "hid-picolcd_core.c",
  "hash_id": "6727c0c3965c6a2f62e41d22baaeea36ff797dd22d7682c04d6f3af1a248b2e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-picolcd_core.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/hid-debug.h>\n#include <linux/input.h>\n#include \"hid-ids.h\"\n\n#include <linux/fb.h>\n#include <linux/vmalloc.h>\n\n#include <linux/completion.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\n#include \"hid-picolcd.h\"\n\n\n \nstatic const unsigned short def_keymap[PICOLCD_KEYS] = {\n\tKEY_RESERVED,\t \n\tKEY_BACK,\t \n\tKEY_HOMEPAGE,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_SCROLLUP,\t \n\tKEY_OK,\t\t \n\tKEY_SCROLLDOWN,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n};\n\n\n \nstruct hid_report *picolcd_report(int id, struct hid_device *hdev, int dir)\n{\n\tstruct list_head *feature_report_list = &hdev->report_enum[dir].report_list;\n\tstruct hid_report *report = NULL;\n\n\tlist_for_each_entry(report, feature_report_list, list) {\n\t\tif (report->id == id)\n\t\t\treturn report;\n\t}\n\thid_warn(hdev, \"No report with id 0x%x found\\n\", id);\n\treturn NULL;\n}\n\n \nstruct picolcd_pending *picolcd_send_and_wait(struct hid_device *hdev,\n\t\tint report_id, const u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tstruct picolcd_pending *work;\n\tstruct hid_report *report = picolcd_out_report(report_id, hdev);\n\tunsigned long flags;\n\tint i, j, k;\n\n\tif (!report || !data)\n\t\treturn NULL;\n\tif (data->status & PICOLCD_FAILED)\n\t\treturn NULL;\n\twork = kzalloc(sizeof(*work), GFP_KERNEL);\n\tif (!work)\n\t\treturn NULL;\n\n\tinit_completion(&work->ready);\n\twork->out_report = report;\n\twork->in_report  = NULL;\n\twork->raw_size   = 0;\n\n\tmutex_lock(&data->mutex);\n\tspin_lock_irqsave(&data->lock, flags);\n\tfor (i = k = 0; i < report->maxfield; i++)\n\t\tfor (j = 0; j < report->field[i]->report_count; j++) {\n\t\t\thid_set_field(report->field[i], j, k < size ? raw_data[k] : 0);\n\t\t\tk++;\n\t\t}\n\tif (data->status & PICOLCD_FAILED) {\n\t\tkfree(work);\n\t\twork = NULL;\n\t} else {\n\t\tdata->pending = work;\n\t\thid_hw_request(data->hdev, report, HID_REQ_SET_REPORT);\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\twait_for_completion_interruptible_timeout(&work->ready, HZ*2);\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tdata->pending = NULL;\n\t}\n\tspin_unlock_irqrestore(&data->lock, flags);\n\tmutex_unlock(&data->mutex);\n\treturn work;\n}\n\n \nstatic int picolcd_raw_keypad(struct picolcd_data *data,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\t \n\tint i, j;\n\n\t \n\tfor (i = 0; i < size; i++) {\n\t\tunsigned int key_code;\n\t\tif (raw_data[i] == 0)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < sizeof(data->pressed_keys); j++)\n\t\t\tif (data->pressed_keys[j] == raw_data[i])\n\t\t\t\tgoto key_already_down;\n\t\tfor (j = 0; j < sizeof(data->pressed_keys); j++)\n\t\t\tif (data->pressed_keys[j] == 0) {\n\t\t\t\tdata->pressed_keys[j] = raw_data[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tinput_event(data->input_keys, EV_MSC, MSC_SCAN, raw_data[i]);\n\t\tif (raw_data[i] < PICOLCD_KEYS)\n\t\t\tkey_code = data->keycode[raw_data[i]];\n\t\telse\n\t\t\tkey_code = KEY_UNKNOWN;\n\t\tif (key_code != KEY_UNKNOWN) {\n\t\t\tdbg_hid(PICOLCD_NAME \" got key press for %u:%d\",\n\t\t\t\t\traw_data[i], key_code);\n\t\t\tinput_report_key(data->input_keys, key_code, 1);\n\t\t}\n\t\tinput_sync(data->input_keys);\nkey_already_down:\n\t\tcontinue;\n\t}\n\n\t \n\tfor (j = 0; j < sizeof(data->pressed_keys); j++) {\n\t\tunsigned int key_code;\n\t\tif (data->pressed_keys[j] == 0)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < size; i++)\n\t\t\tif (data->pressed_keys[j] == raw_data[i])\n\t\t\t\tgoto key_still_down;\n\t\tinput_event(data->input_keys, EV_MSC, MSC_SCAN, data->pressed_keys[j]);\n\t\tif (data->pressed_keys[j] < PICOLCD_KEYS)\n\t\t\tkey_code = data->keycode[data->pressed_keys[j]];\n\t\telse\n\t\t\tkey_code = KEY_UNKNOWN;\n\t\tif (key_code != KEY_UNKNOWN) {\n\t\t\tdbg_hid(PICOLCD_NAME \" got key release for %u:%d\",\n\t\t\t\t\tdata->pressed_keys[j], key_code);\n\t\t\tinput_report_key(data->input_keys, key_code, 0);\n\t\t}\n\t\tinput_sync(data->input_keys);\n\t\tdata->pressed_keys[j] = 0;\nkey_still_down:\n\t\tcontinue;\n\t}\n\treturn 1;\n}\n\nstatic int picolcd_check_version(struct hid_device *hdev)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tstruct picolcd_pending *verinfo;\n\tint ret = 0;\n\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tverinfo = picolcd_send_and_wait(hdev, REPORT_VERSION, NULL, 0);\n\tif (!verinfo) {\n\t\thid_err(hdev, \"no version response from PicoLCD\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (verinfo->raw_size == 2) {\n\t\tdata->version[0] = verinfo->raw_data[1];\n\t\tdata->version[1] = verinfo->raw_data[0];\n\t\tif (data->status & PICOLCD_BOOTLOADER) {\n\t\t\thid_info(hdev, \"PicoLCD, bootloader version %d.%d\\n\",\n\t\t\t\t verinfo->raw_data[1], verinfo->raw_data[0]);\n\t\t} else {\n\t\t\thid_info(hdev, \"PicoLCD, firmware version %d.%d\\n\",\n\t\t\t\t verinfo->raw_data[1], verinfo->raw_data[0]);\n\t\t}\n\t} else {\n\t\thid_err(hdev, \"confused, got unexpected version response from PicoLCD\\n\");\n\t\tret = -EINVAL;\n\t}\n\tkfree(verinfo);\n\treturn ret;\n}\n\n \nint picolcd_reset(struct hid_device *hdev)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tstruct hid_report *report = picolcd_out_report(REPORT_RESET, hdev);\n\tunsigned long flags;\n\tint error;\n\n\tif (!data || !report || report->maxfield != 1)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\tif (hdev->product == USB_DEVICE_ID_PICOLCD_BOOTLOADER)\n\t\tdata->status |= PICOLCD_BOOTLOADER;\n\n\t \n\thid_set_field(report->field[0], 0, 1);\n\tif (data->status & PICOLCD_FAILED) {\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\terror = picolcd_check_version(hdev);\n\tif (error)\n\t\treturn error;\n\n\tpicolcd_resume_lcd(data);\n\tpicolcd_resume_backlight(data);\n\tpicolcd_fb_refresh(data);\n\tpicolcd_leds_set(data);\n\treturn 0;\n}\n\n \nstatic ssize_t picolcd_operation_mode_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct picolcd_data *data = dev_get_drvdata(dev);\n\n\tif (data->status & PICOLCD_BOOTLOADER)\n\t\treturn snprintf(buf, PAGE_SIZE, \"[bootloader] lcd\\n\");\n\telse\n\t\treturn snprintf(buf, PAGE_SIZE, \"bootloader [lcd]\\n\");\n}\n\nstatic ssize_t picolcd_operation_mode_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct picolcd_data *data = dev_get_drvdata(dev);\n\tstruct hid_report *report = NULL;\n\tint timeout = data->opmode_delay;\n\tunsigned long flags;\n\n\tif (sysfs_streq(buf, \"lcd\")) {\n\t\tif (data->status & PICOLCD_BOOTLOADER)\n\t\t\treport = picolcd_out_report(REPORT_EXIT_FLASHER, data->hdev);\n\t} else if (sysfs_streq(buf, \"bootloader\")) {\n\t\tif (!(data->status & PICOLCD_BOOTLOADER))\n\t\t\treport = picolcd_out_report(REPORT_EXIT_KEYBOARD, data->hdev);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!report || report->maxfield != 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\thid_set_field(report->field[0], 0, timeout & 0xff);\n\thid_set_field(report->field[0], 1, (timeout >> 8) & 0xff);\n\thid_hw_request(data->hdev, report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(operation_mode, 0644, picolcd_operation_mode_show,\n\t\tpicolcd_operation_mode_store);\n\n \nstatic ssize_t picolcd_operation_mode_delay_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct picolcd_data *data = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%hu\\n\", data->opmode_delay);\n}\n\nstatic ssize_t picolcd_operation_mode_delay_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct picolcd_data *data = dev_get_drvdata(dev);\n\tunsigned u;\n\tif (sscanf(buf, \"%u\", &u) != 1)\n\t\treturn -EINVAL;\n\tif (u > 30000)\n\t\treturn -EINVAL;\n\telse\n\t\tdata->opmode_delay = u;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(operation_mode_delay, 0644, picolcd_operation_mode_delay_show,\n\t\tpicolcd_operation_mode_delay_store);\n\n \nstatic int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tif (!data)\n\t\treturn 1;\n\n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event (%d)\\n\",\n\t\t\t\tsize, report->id);\n\t\treturn 0;\n\t}\n\n\tif (report->id == REPORT_KEY_STATE) {\n\t\tif (data->input_keys)\n\t\t\tpicolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tpicolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\t \n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}\n\n#ifdef CONFIG_PM\nstatic int picolcd_suspend(struct hid_device *hdev, pm_message_t message)\n{\n\tif (PMSG_IS_AUTO(message))\n\t\treturn 0;\n\n\tpicolcd_suspend_backlight(hid_get_drvdata(hdev));\n\tdbg_hid(PICOLCD_NAME \" device ready for suspend\\n\");\n\treturn 0;\n}\n\nstatic int picolcd_resume(struct hid_device *hdev)\n{\n\tint ret;\n\tret = picolcd_resume_backlight(hid_get_drvdata(hdev));\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" restoring backlight failed: %d\\n\", ret);\n\treturn 0;\n}\n\nstatic int picolcd_reset_resume(struct hid_device *hdev)\n{\n\tint ret;\n\tret = picolcd_reset(hdev);\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" resetting our device failed: %d\\n\", ret);\n\tret = picolcd_fb_reset(hid_get_drvdata(hdev), 0);\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" restoring framebuffer content failed: %d\\n\", ret);\n\tret = picolcd_resume_lcd(hid_get_drvdata(hdev));\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" restoring lcd failed: %d\\n\", ret);\n\tret = picolcd_resume_backlight(hid_get_drvdata(hdev));\n\tif (ret)\n\t\tdbg_hid(PICOLCD_NAME \" restoring backlight failed: %d\\n\", ret);\n\tpicolcd_leds_set(hid_get_drvdata(hdev));\n\treturn 0;\n}\n#endif\n\n \nstatic int picolcd_init_keys(struct picolcd_data *data,\n\t\tstruct hid_report *report)\n{\n\tstruct hid_device *hdev = data->hdev;\n\tstruct input_dev *idev;\n\tint error, i;\n\n\tif (!report)\n\t\treturn -ENODEV;\n\tif (report->maxfield != 1 || report->field[0]->report_count != 2 ||\n\t\t\treport->field[0]->report_size != 8) {\n\t\thid_err(hdev, \"unsupported KEY_STATE report\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tidev = input_allocate_device();\n\tif (idev == NULL) {\n\t\thid_err(hdev, \"failed to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tinput_set_drvdata(idev, hdev);\n\tmemcpy(data->keycode, def_keymap, sizeof(def_keymap));\n\tidev->name = hdev->name;\n\tidev->phys = hdev->phys;\n\tidev->uniq = hdev->uniq;\n\tidev->id.bustype = hdev->bus;\n\tidev->id.vendor  = hdev->vendor;\n\tidev->id.product = hdev->product;\n\tidev->id.version = hdev->version;\n\tidev->dev.parent = &hdev->dev;\n\tidev->keycode     = &data->keycode;\n\tidev->keycodemax  = PICOLCD_KEYS;\n\tidev->keycodesize = sizeof(data->keycode[0]);\n\tinput_set_capability(idev, EV_MSC, MSC_SCAN);\n\tset_bit(EV_REP, idev->evbit);\n\tfor (i = 0; i < PICOLCD_KEYS; i++)\n\t\tinput_set_capability(idev, EV_KEY, data->keycode[i]);\n\terror = input_register_device(idev);\n\tif (error) {\n\t\thid_err(hdev, \"error registering the input device\\n\");\n\t\tinput_free_device(idev);\n\t\treturn error;\n\t}\n\tdata->input_keys = idev;\n\treturn 0;\n}\n\nstatic void picolcd_exit_keys(struct picolcd_data *data)\n{\n\tstruct input_dev *idev = data->input_keys;\n\n\tdata->input_keys = NULL;\n\tif (idev)\n\t\tinput_unregister_device(idev);\n}\n\nstatic int picolcd_probe_lcd(struct hid_device *hdev, struct picolcd_data *data)\n{\n\tint error;\n\n\t \n\terror = picolcd_init_keys(data, picolcd_in_report(REPORT_KEY_STATE, hdev));\n\tif (error)\n\t\tgoto err;\n\n\t \n\terror = picolcd_init_cir(data, picolcd_in_report(REPORT_IR_DATA, hdev));\n\tif (error)\n\t\tgoto err;\n\n\t \n\terror = picolcd_init_framebuffer(data);\n\tif (error)\n\t\tgoto err;\n\n\t \n\terror = picolcd_init_lcd(data, picolcd_out_report(REPORT_CONTRAST, hdev));\n\tif (error)\n\t\tgoto err;\n\n\t \n\terror = picolcd_init_backlight(data, picolcd_out_report(REPORT_BRIGHTNESS, hdev));\n\tif (error)\n\t\tgoto err;\n\n\t \n\terror = picolcd_init_leds(data, picolcd_out_report(REPORT_LED_STATE, hdev));\n\tif (error)\n\t\tgoto err;\n\n\tpicolcd_init_devfs(data, picolcd_out_report(REPORT_EE_READ, hdev),\n\t\t\tpicolcd_out_report(REPORT_EE_WRITE, hdev),\n\t\t\tpicolcd_out_report(REPORT_READ_MEMORY, hdev),\n\t\t\tpicolcd_out_report(REPORT_WRITE_MEMORY, hdev),\n\t\t\tpicolcd_out_report(REPORT_RESET, hdev));\n\treturn 0;\nerr:\n\tpicolcd_exit_leds(data);\n\tpicolcd_exit_backlight(data);\n\tpicolcd_exit_lcd(data);\n\tpicolcd_exit_framebuffer(data);\n\tpicolcd_exit_cir(data);\n\tpicolcd_exit_keys(data);\n\treturn error;\n}\n\nstatic int picolcd_probe_bootloader(struct hid_device *hdev, struct picolcd_data *data)\n{\n\tpicolcd_init_devfs(data, NULL, NULL,\n\t\t\tpicolcd_out_report(REPORT_BL_READ_MEMORY, hdev),\n\t\t\tpicolcd_out_report(REPORT_BL_WRITE_MEMORY, hdev), NULL);\n\treturn 0;\n}\n\nstatic int picolcd_probe(struct hid_device *hdev,\n\t\t     const struct hid_device_id *id)\n{\n\tstruct picolcd_data *data;\n\tint error = -ENOMEM;\n\n\tdbg_hid(PICOLCD_NAME \" hardware probe...\\n\");\n\n\t \n\tdata = kzalloc(sizeof(struct picolcd_data), GFP_KERNEL);\n\tif (data == NULL) {\n\t\thid_err(hdev, \"can't allocate space for Minibox PicoLCD device data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&data->lock);\n\tmutex_init(&data->mutex);\n\tdata->hdev = hdev;\n\tdata->opmode_delay = 5000;\n\tif (hdev->product == USB_DEVICE_ID_PICOLCD_BOOTLOADER)\n\t\tdata->status |= PICOLCD_BOOTLOADER;\n\thid_set_drvdata(hdev, data);\n\n\t \n\terror = hid_parse(hdev);\n\tif (error) {\n\t\thid_err(hdev, \"device report parse failed\\n\");\n\t\tgoto err_cleanup_data;\n\t}\n\n\terror = hid_hw_start(hdev, 0);\n\tif (error) {\n\t\thid_err(hdev, \"hardware start failed\\n\");\n\t\tgoto err_cleanup_data;\n\t}\n\n\terror = hid_hw_open(hdev);\n\tif (error) {\n\t\thid_err(hdev, \"failed to open input interrupt pipe for key and IR events\\n\");\n\t\tgoto err_cleanup_hid_hw;\n\t}\n\n\terror = device_create_file(&hdev->dev, &dev_attr_operation_mode_delay);\n\tif (error) {\n\t\thid_err(hdev, \"failed to create sysfs attributes\\n\");\n\t\tgoto err_cleanup_hid_ll;\n\t}\n\n\terror = device_create_file(&hdev->dev, &dev_attr_operation_mode);\n\tif (error) {\n\t\thid_err(hdev, \"failed to create sysfs attributes\\n\");\n\t\tgoto err_cleanup_sysfs1;\n\t}\n\n\tif (data->status & PICOLCD_BOOTLOADER)\n\t\terror = picolcd_probe_bootloader(hdev, data);\n\telse\n\t\terror = picolcd_probe_lcd(hdev, data);\n\tif (error)\n\t\tgoto err_cleanup_sysfs2;\n\n\tdbg_hid(PICOLCD_NAME \" activated and initialized\\n\");\n\treturn 0;\n\nerr_cleanup_sysfs2:\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\nerr_cleanup_sysfs1:\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\nerr_cleanup_hid_ll:\n\thid_hw_close(hdev);\nerr_cleanup_hid_hw:\n\thid_hw_stop(hdev);\nerr_cleanup_data:\n\tkfree(data);\n\treturn error;\n}\n\nstatic void picolcd_remove(struct hid_device *hdev)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tdbg_hid(PICOLCD_NAME \" hardware remove...\\n\");\n\tspin_lock_irqsave(&data->lock, flags);\n\tdata->status |= PICOLCD_FAILED;\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\tpicolcd_exit_devfs(data);\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n\n\t \n\tspin_lock_irqsave(&data->lock, flags);\n\tif (data->pending)\n\t\tcomplete(&data->pending->ready);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t \n\tpicolcd_exit_leds(data);\n\t \n\tpicolcd_exit_backlight(data);\n\tpicolcd_exit_lcd(data);\n\tpicolcd_exit_framebuffer(data);\n\t \n\tpicolcd_exit_cir(data);\n\tpicolcd_exit_keys(data);\n\n\tmutex_destroy(&data->mutex);\n\t \n\tkfree(data);\n}\n\nstatic const struct hid_device_id picolcd_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD_BOOTLOADER) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, picolcd_devices);\n\nstatic struct hid_driver picolcd_driver = {\n\t.name =          \"hid-picolcd\",\n\t.id_table =      picolcd_devices,\n\t.probe =         picolcd_probe,\n\t.remove =        picolcd_remove,\n\t.raw_event =     picolcd_raw_event,\n#ifdef CONFIG_PM\n\t.suspend =       picolcd_suspend,\n\t.resume =        picolcd_resume,\n\t.reset_resume =  picolcd_reset_resume,\n#endif\n};\nmodule_hid_driver(picolcd_driver);\n\nMODULE_DESCRIPTION(\"Minibox graphics PicoLCD Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}