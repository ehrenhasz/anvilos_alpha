{
  "module_name": "hid-picolcd_cir.c",
  "hash_id": "27b257e36cc44d261e9422604cc88907de3d9100a8cd1be2f8b08473a5a8b80d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-picolcd_cir.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/hid-debug.h>\n#include <linux/input.h>\n#include \"hid-ids.h\"\n\n#include <linux/fb.h>\n#include <linux/vmalloc.h>\n#include <linux/backlight.h>\n#include <linux/lcd.h>\n\n#include <linux/leds.h>\n\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n\n#include <linux/completion.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <media/rc-core.h>\n\n#include \"hid-picolcd.h\"\n\n\nint picolcd_raw_cir(struct picolcd_data *data,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tunsigned long flags;\n\tint i, w, sz;\n\tstruct ir_raw_event rawir = {};\n\n\t \n\tspin_lock_irqsave(&data->lock, flags);\n\tif (!data->rc_dev || (data->status & PICOLCD_CIR_SHUN)) {\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\treturn 1;\n\t}\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t \n\tsz = size > 0 ? min((int)raw_data[0], size-1) : 0;\n\tfor (i = 0; i+1 < sz; i += 2) {\n\t\tw = (raw_data[i] << 8) | (raw_data[i+1]);\n\t\trawir.pulse = !!(w & 0x8000);\n\t\trawir.duration = rawir.pulse ? (65536 - w) : w;\n\t\t \n\t\tif (i == 0 && rawir.duration > 15000)\n\t\t\trawir.duration -= 15000;\n\t\tir_raw_event_store(data->rc_dev, &rawir);\n\t}\n\tir_raw_event_handle(data->rc_dev);\n\n\treturn 1;\n}\n\nstatic int picolcd_cir_open(struct rc_dev *dev)\n{\n\tstruct picolcd_data *data = dev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\tdata->status &= ~PICOLCD_CIR_SHUN;\n\tspin_unlock_irqrestore(&data->lock, flags);\n\treturn 0;\n}\n\nstatic void picolcd_cir_close(struct rc_dev *dev)\n{\n\tstruct picolcd_data *data = dev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\tdata->status |= PICOLCD_CIR_SHUN;\n\tspin_unlock_irqrestore(&data->lock, flags);\n}\n\n \nint picolcd_init_cir(struct picolcd_data *data, struct hid_report *report)\n{\n\tstruct rc_dev *rdev;\n\tint ret = 0;\n\n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!rdev)\n\t\treturn -ENOMEM;\n\n\trdev->priv             = data;\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->open             = picolcd_cir_open;\n\trdev->close            = picolcd_cir_close;\n\trdev->device_name      = data->hdev->name;\n\trdev->input_phys       = data->hdev->phys;\n\trdev->input_id.bustype = data->hdev->bus;\n\trdev->input_id.vendor  = data->hdev->vendor;\n\trdev->input_id.product = data->hdev->product;\n\trdev->input_id.version = data->hdev->version;\n\trdev->dev.parent       = &data->hdev->dev;\n\trdev->driver_name      = PICOLCD_NAME;\n\trdev->map_name         = RC_MAP_RC6_MCE;\n\trdev->timeout          = MS_TO_US(100);\n\trdev->rx_resolution    = 1;\n\n\tret = rc_register_device(rdev);\n\tif (ret)\n\t\tgoto err;\n\tdata->rc_dev = rdev;\n\treturn 0;\n\nerr:\n\trc_free_device(rdev);\n\treturn ret;\n}\n\nvoid picolcd_exit_cir(struct picolcd_data *data)\n{\n\tstruct rc_dev *rdev = data->rc_dev;\n\n\tdata->rc_dev = NULL;\n\trc_unregister_device(rdev);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}