{
  "module_name": "hid-cp2112.c",
  "hash_id": "24da5243a12267d4acea12a42052293a33cd14bf48c0b752c52ba49a15c26e4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-cp2112.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/hid.h>\n#include <linux/hidraw.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/nls.h>\n#include <linux/string_choices.h>\n#include <linux/usb/ch9.h>\n#include \"hid-ids.h\"\n\n#define CP2112_REPORT_MAX_LENGTH\t\t64\n#define CP2112_GPIO_CONFIG_LENGTH\t\t5\n#define CP2112_GPIO_GET_LENGTH\t\t\t2\n#define CP2112_GPIO_SET_LENGTH\t\t\t3\n#define CP2112_GPIO_MAX_GPIO\t\t\t8\n#define CP2112_GPIO_ALL_GPIO_MASK\t\tGENMASK(7, 0)\n\nenum {\n\tCP2112_GPIO_CONFIG\t\t= 0x02,\n\tCP2112_GPIO_GET\t\t\t= 0x03,\n\tCP2112_GPIO_SET\t\t\t= 0x04,\n\tCP2112_GET_VERSION_INFO\t\t= 0x05,\n\tCP2112_SMBUS_CONFIG\t\t= 0x06,\n\tCP2112_DATA_READ_REQUEST\t= 0x10,\n\tCP2112_DATA_WRITE_READ_REQUEST\t= 0x11,\n\tCP2112_DATA_READ_FORCE_SEND\t= 0x12,\n\tCP2112_DATA_READ_RESPONSE\t= 0x13,\n\tCP2112_DATA_WRITE_REQUEST\t= 0x14,\n\tCP2112_TRANSFER_STATUS_REQUEST\t= 0x15,\n\tCP2112_TRANSFER_STATUS_RESPONSE\t= 0x16,\n\tCP2112_CANCEL_TRANSFER\t\t= 0x17,\n\tCP2112_LOCK_BYTE\t\t= 0x20,\n\tCP2112_USB_CONFIG\t\t= 0x21,\n\tCP2112_MANUFACTURER_STRING\t= 0x22,\n\tCP2112_PRODUCT_STRING\t\t= 0x23,\n\tCP2112_SERIAL_STRING\t\t= 0x24,\n};\n\nenum {\n\tSTATUS0_IDLE\t\t= 0x00,\n\tSTATUS0_BUSY\t\t= 0x01,\n\tSTATUS0_COMPLETE\t= 0x02,\n\tSTATUS0_ERROR\t\t= 0x03,\n};\n\nenum {\n\tSTATUS1_TIMEOUT_NACK\t\t= 0x00,\n\tSTATUS1_TIMEOUT_BUS\t\t= 0x01,\n\tSTATUS1_ARBITRATION_LOST\t= 0x02,\n\tSTATUS1_READ_INCOMPLETE\t\t= 0x03,\n\tSTATUS1_WRITE_INCOMPLETE\t= 0x04,\n\tSTATUS1_SUCCESS\t\t\t= 0x05,\n};\n\nstruct cp2112_smbus_config_report {\n\tu8 report;\t\t \n\t__be32 clock_speed;\t \n\tu8 device_address;\t \n\tu8 auto_send_read;\t \n\t__be16 write_timeout;\t \n\t__be16 read_timeout;\t \n\tu8 scl_low_timeout;\t \n\t__be16 retry_time;\t \n} __packed;\n\nstruct cp2112_usb_config_report {\n\tu8 report;\t \n\t__le16 vid;\t \n\t__le16 pid;\t \n\tu8 max_power;\t \n\tu8 power_mode;\t \n\tu8 release_major;\n\tu8 release_minor;\n\tu8 mask;\t \n} __packed;\n\nstruct cp2112_read_req_report {\n\tu8 report;\t \n\tu8 slave_address;\n\t__be16 length;\n} __packed;\n\nstruct cp2112_write_read_req_report {\n\tu8 report;\t \n\tu8 slave_address;\n\t__be16 length;\n\tu8 target_address_length;\n\tu8 target_address[16];\n} __packed;\n\nstruct cp2112_write_req_report {\n\tu8 report;\t \n\tu8 slave_address;\n\tu8 length;\n\tu8 data[61];\n} __packed;\n\nstruct cp2112_force_read_report {\n\tu8 report;\t \n\t__be16 length;\n} __packed;\n\nstruct cp2112_xfer_status_report {\n\tu8 report;\t \n\tu8 status0;\t \n\tu8 status1;\t \n\t__be16 retries;\n\t__be16 length;\n} __packed;\n\nstruct cp2112_string_report {\n\tu8 dummy;\t\t \n\tstruct_group_attr(contents, __packed,\n\t\tu8 report;\t\t \n\t\tu8 length;\t\t \n\t\tu8 type;\t\t \n\t\twchar_t string[30];\t \n\t);\n} __packed;\n\n \nstatic const int XFER_STATUS_RETRIES = 10;\n\n \nstatic const int RESPONSE_TIMEOUT = 50;\n\nstatic const struct hid_device_id cp2112_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_CP2112) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, cp2112_devices);\n\nstruct cp2112_device {\n\tstruct i2c_adapter adap;\n\tstruct hid_device *hdev;\n\twait_queue_head_t wait;\n\tu8 read_data[61];\n\tu8 read_length;\n\tu8 hwversion;\n\tint xfer_status;\n\tatomic_t read_avail;\n\tatomic_t xfer_avail;\n\tstruct gpio_chip gc;\n\tu8 *in_out_buffer;\n\tstruct mutex lock;\n\n\tbool gpio_poll;\n\tstruct delayed_work gpio_poll_worker;\n\tunsigned long irq_mask;\n\tu8 gpio_prev_state;\n};\n\nstatic int gpio_push_pull = CP2112_GPIO_ALL_GPIO_MASK;\nmodule_param(gpio_push_pull, int, 0644);\nMODULE_PARM_DESC(gpio_push_pull, \"GPIO push-pull configuration bitmask\");\n\nstatic int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~BIT(offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\nstatic void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? CP2112_GPIO_ALL_GPIO_MASK : 0;\n\tbuf[2] = BIT(offset);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tmutex_unlock(&dev->lock);\n}\n\nstatic int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}\n\nstatic int cp2112_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\n\tret = cp2112_gpio_get_all(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret >> offset) & 1;\n}\n\nstatic int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tmutex_unlock(&dev->lock);\n\n\t \n\tcp2112_gpio_set(chip, offset, value);\n\n\treturn 0;\n\nfail:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}\n\nstatic int cp2112_hid_get(struct hid_device *hdev, unsigned char report_number,\n\t\t\t  u8 *data, size_t count, unsigned char report_type)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, report_number, buf, count,\n\t\t\t\t       report_type, HID_REQ_GET_REPORT);\n\tmemcpy(data, buf, count);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int cp2112_hid_output(struct hid_device *hdev, u8 *data, size_t count,\n\t\t\t     unsigned char report_type)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (report_type == HID_OUTPUT_REPORT)\n\t\tret = hid_hw_output_report(hdev, buf, count);\n\telse\n\t\tret = hid_hw_raw_request(hdev, buf[0], buf, count, report_type,\n\t\t\t\tHID_REQ_SET_REPORT);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int cp2112_wait(struct cp2112_device *dev, atomic_t *avail)\n{\n\tint ret = 0;\n\n\t \n\tret = wait_event_interruptible_timeout(dev->wait,\n\t\tatomic_read(avail), msecs_to_jiffies(RESPONSE_TIMEOUT));\n\tif (-ERESTARTSYS == ret)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tatomic_set(avail, 0);\n\treturn 0;\n}\n\nstatic int cp2112_xfer_status(struct cp2112_device *dev)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[2];\n\tint ret;\n\n\tbuf[0] = CP2112_TRANSFER_STATUS_REQUEST;\n\tbuf[1] = 0x01;\n\tatomic_set(&dev->xfer_avail, 0);\n\n\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error requesting status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_wait(dev, &dev->xfer_avail);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dev->xfer_status;\n}\n\nstatic int cp2112_read(struct cp2112_device *dev, u8 *data, size_t size)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct cp2112_force_read_report report;\n\tint ret;\n\n\tif (size > sizeof(dev->read_data))\n\t\tsize = sizeof(dev->read_data);\n\treport.report = CP2112_DATA_READ_FORCE_SEND;\n\treport.length = cpu_to_be16(size);\n\n\tatomic_set(&dev->read_avail, 0);\n\n\tret = cp2112_hid_output(hdev, &report.report, sizeof(report),\n\t\t\t\tHID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error requesting data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_wait(dev, &dev->read_avail);\n\tif (ret)\n\t\treturn ret;\n\n\thid_dbg(hdev, \"read %d of %zd bytes requested\\n\",\n\t\tdev->read_length, size);\n\n\tif (size > dev->read_length)\n\t\tsize = dev->read_length;\n\n\tmemcpy(data, dev->read_data, size);\n\treturn dev->read_length;\n}\n\nstatic int cp2112_read_req(void *buf, u8 slave_address, u16 length)\n{\n\tstruct cp2112_read_req_report *report = buf;\n\n\tif (length < 1 || length > 512)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(length);\n\treturn sizeof(*report);\n}\n\nstatic int cp2112_write_read_req(void *buf, u8 slave_address, u16 length,\n\t\t\t\t u8 command, u8 *data, u8 data_length)\n{\n\tstruct cp2112_write_read_req_report *report = buf;\n\n\tif (length < 1 || length > 512\n\t    || data_length > sizeof(report->target_address) - 1)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(length);\n\treport->target_address_length = data_length + 1;\n\treport->target_address[0] = command;\n\tmemcpy(&report->target_address[1], data, data_length);\n\treturn data_length + 6;\n}\n\nstatic int cp2112_write_req(void *buf, u8 slave_address, u8 command, u8 *data,\n\t\t\t    u8 data_length)\n{\n\tstruct cp2112_write_req_report *report = buf;\n\n\tif (data_length > sizeof(report->data) - 1)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = data_length + 1;\n\treport->data[0] = command;\n\tmemcpy(&report->data[1], data, data_length);\n\treturn data_length + 4;\n}\n\nstatic int cp2112_i2c_write_req(void *buf, u8 slave_address, u8 *data,\n\t\t\t\tu8 data_length)\n{\n\tstruct cp2112_write_req_report *report = buf;\n\n\tif (data_length > sizeof(report->data))\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = data_length;\n\tmemcpy(report->data, data, data_length);\n\treturn data_length + 3;\n}\n\nstatic int cp2112_i2c_write_read_req(void *buf, u8 slave_address,\n\t\t\t\t     u8 *addr, int addr_length,\n\t\t\t\t     int read_length)\n{\n\tstruct cp2112_write_read_req_report *report = buf;\n\n\tif (read_length < 1 || read_length > 512 ||\n\t    addr_length > sizeof(report->target_address))\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(read_length);\n\treport->target_address_length = addr_length;\n\tmemcpy(report->target_address, addr, addr_length);\n\treturn addr_length + 5;\n}\n\nstatic int cp2112_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t   int num)\n{\n\tstruct cp2112_device *dev = (struct cp2112_device *)adap->algo_data;\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[64];\n\tssize_t count;\n\tssize_t read_length = 0;\n\tu8 *read_buf = NULL;\n\tunsigned int retries;\n\tint ret;\n\n\thid_dbg(hdev, \"I2C %d messages\\n\", num);\n\n\tif (num == 1) {\n\t\thid_dbg(hdev, \"I2C %s %#04x len %d\\n\",\n\t\t\tstr_read_write(msgs->flags & I2C_M_RD), msgs->addr, msgs->len);\n\t\tif (msgs->flags & I2C_M_RD) {\n\t\t\tread_length = msgs->len;\n\t\t\tread_buf = msgs->buf;\n\t\t\tcount = cp2112_read_req(buf, msgs->addr, msgs->len);\n\t\t} else {\n\t\t\tcount = cp2112_i2c_write_req(buf, msgs->addr,\n\t\t\t\t\t\t     msgs->buf, msgs->len);\n\t\t}\n\t\tif (count < 0)\n\t\t\treturn count;\n\t} else if (dev->hwversion > 1 &&   \n\t\t   num == 2 &&\n\t\t   msgs[0].addr == msgs[1].addr &&\n\t\t   !(msgs[0].flags & I2C_M_RD) && (msgs[1].flags & I2C_M_RD)) {\n\t\thid_dbg(hdev, \"I2C write-read %#04x wlen %d rlen %d\\n\",\n\t\t\tmsgs[0].addr, msgs[0].len, msgs[1].len);\n\t\tread_length = msgs[1].len;\n\t\tread_buf = msgs[1].buf;\n\t\tcount = cp2112_i2c_write_read_req(buf, msgs[0].addr,\n\t\t\t\tmsgs[0].buf, msgs[0].len, msgs[1].len);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t} else {\n\t\thid_err(hdev,\n\t\t\t\"Multi-message I2C transactions not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_hid_output(hdev, buf, count, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error starting transaction: %d\\n\", ret);\n\t\tgoto power_normal;\n\t}\n\n\tfor (retries = 0; retries < XFER_STATUS_RETRIES; ++retries) {\n\t\tret = cp2112_xfer_status(dev);\n\t\tif (-EBUSY == ret)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tbreak;\n\t}\n\n\tif (XFER_STATUS_RETRIES <= retries) {\n\t\thid_warn(hdev, \"Transfer timed out, cancelling.\\n\");\n\t\tbuf[0] = CP2112_CANCEL_TRANSFER;\n\t\tbuf[1] = 0x01;\n\n\t\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\t\tif (ret < 0)\n\t\t\thid_warn(hdev, \"Error cancelling transaction: %d\\n\",\n\t\t\t\t ret);\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto power_normal;\n\t}\n\n\tfor (count = 0; count < read_length;) {\n\t\tret = cp2112_read(dev, read_buf + count, read_length - count);\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tif (ret == 0) {\n\t\t\thid_err(hdev, \"read returned 0\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto power_normal;\n\t\t}\n\t\tcount += ret;\n\t\tif (count > read_length) {\n\t\t\t \n\t\t\thid_err(hdev, \"long read: %d > %zd\\n\",\n\t\t\t\tret, read_length - count + ret);\n\t\t\tret = -EIO;\n\t\t\tgoto power_normal;\n\t\t}\n\t}\n\n\t \n\tret = num;\n\npower_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\thid_dbg(hdev, \"I2C transfer finished: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int cp2112_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tstruct cp2112_device *dev = (struct cp2112_device *)adap->algo_data;\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[64];\n\t__le16 word;\n\tssize_t count;\n\tsize_t read_length = 0;\n\tunsigned int retries;\n\tint ret;\n\n\thid_dbg(hdev, \"%s addr 0x%x flags 0x%x cmd 0x%x size %d\\n\",\n\t\tstr_write_read(read_write == I2C_SMBUS_WRITE),\n\t\taddr, flags, command, size);\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\t\tread_length = 1;\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_read_req(buf, addr, read_length);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command, NULL,\n\t\t\t\t\t\t 0);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tread_length = 1;\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_write_read_req(buf, addr, read_length,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t &data->byte, 1);\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tread_length = 2;\n\t\tword = cpu_to_le16(data->word);\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_write_read_req(buf, addr, read_length,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t (u8 *)&word, 2);\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tsize = I2C_SMBUS_WORD_DATA;\n\t\tread_write = I2C_SMBUS_READ;\n\t\tread_length = 2;\n\t\tword = cpu_to_le16(data->word);\n\n\t\tcount = cp2112_write_read_req(buf, addr, read_length, command,\n\t\t\t\t\t      (u8 *)&word, 2);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tread_length = data->block[0];\n\t\t\tcount = cp2112_write_read_req(buf, addr, read_length,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\t} else {\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t data->block + 1,\n\t\t\t\t\t\t data->block[0]);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (I2C_SMBUS_READ == read_write) {\n\t\t\tcount = cp2112_write_read_req(buf, addr,\n\t\t\t\t\t\t      I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\t} else {\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t data->block,\n\t\t\t\t\t\t data->block[0] + 1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tsize = I2C_SMBUS_BLOCK_DATA;\n\t\tread_write = I2C_SMBUS_READ;\n\n\t\tcount = cp2112_write_read_req(buf, addr, I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t      command, data->block,\n\t\t\t\t\t      data->block[0] + 1);\n\t\tbreak;\n\tdefault:\n\t\thid_warn(hdev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (count < 0)\n\t\treturn count;\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_hid_output(hdev, buf, count, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error starting transaction: %d\\n\", ret);\n\t\tgoto power_normal;\n\t}\n\n\tfor (retries = 0; retries < XFER_STATUS_RETRIES; ++retries) {\n\t\tret = cp2112_xfer_status(dev);\n\t\tif (-EBUSY == ret)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tbreak;\n\t}\n\n\tif (XFER_STATUS_RETRIES <= retries) {\n\t\thid_warn(hdev, \"Transfer timed out, cancelling.\\n\");\n\t\tbuf[0] = CP2112_CANCEL_TRANSFER;\n\t\tbuf[1] = 0x01;\n\n\t\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\t\tif (ret < 0)\n\t\t\thid_warn(hdev, \"Error cancelling transaction: %d\\n\",\n\t\t\t\t ret);\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto power_normal;\n\t}\n\n\tif (I2C_SMBUS_WRITE == read_write) {\n\t\tret = 0;\n\t\tgoto power_normal;\n\t}\n\n\tif (I2C_SMBUS_BLOCK_DATA == size)\n\t\tread_length = ret;\n\n\tret = cp2112_read(dev, buf, read_length);\n\tif (ret < 0)\n\t\tgoto power_normal;\n\tif (ret != read_length) {\n\t\thid_warn(hdev, \"short read: %d < %zd\\n\", ret, read_length);\n\t\tret = -EIO;\n\t\tgoto power_normal;\n\t}\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tdata->byte = buf[0];\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tdata->word = le16_to_cpup((__le16 *)buf);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (read_length > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto power_normal;\n\t\t}\n\n\t\tmemcpy(data->block + 1, buf, read_length);\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_length > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto power_normal;\n\t\t}\n\n\t\tmemcpy(data->block, buf, read_length);\n\t\tbreak;\n\t}\n\n\tret = 0;\npower_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\thid_dbg(hdev, \"transfer finished: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic u32 cp2112_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C |\n\t\tI2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_BLOCK_DATA |\n\t\tI2C_FUNC_SMBUS_I2C_BLOCK |\n\t\tI2C_FUNC_SMBUS_PROC_CALL |\n\t\tI2C_FUNC_SMBUS_BLOCK_PROC_CALL;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.master_xfer\t= cp2112_i2c_xfer,\n\t.smbus_xfer\t= cp2112_xfer,\n\t.functionality\t= cp2112_functionality,\n};\n\nstatic int cp2112_get_usb_config(struct hid_device *hdev,\n\t\t\t\t struct cp2112_usb_config_report *cfg)\n{\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, CP2112_USB_CONFIG, (u8 *)cfg, sizeof(*cfg),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(*cfg)) {\n\t\thid_err(hdev, \"error reading usb config: %d\\n\", ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cp2112_set_usb_config(struct hid_device *hdev,\n\t\t\t\t struct cp2112_usb_config_report *cfg)\n{\n\tint ret;\n\n\tBUG_ON(cfg->report != CP2112_USB_CONFIG);\n\n\tret = cp2112_hid_output(hdev, (u8 *)cfg, sizeof(*cfg),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(*cfg)) {\n\t\thid_err(hdev, \"error writing usb config: %d\\n\", ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void chmod_sysfs_attrs(struct hid_device *hdev);\n\n#define CP2112_CONFIG_ATTR(name, store, format, ...) \\\nstatic ssize_t name##_store(struct device *kdev, \\\n\t\t\t    struct device_attribute *attr, const char *buf, \\\n\t\t\t    size_t count) \\\n{ \\\n\tstruct hid_device *hdev = to_hid_device(kdev); \\\n\tstruct cp2112_usb_config_report cfg; \\\n\tint ret = cp2112_get_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\tstore; \\\n\tret = cp2112_set_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\tchmod_sysfs_attrs(hdev); \\\n\treturn count; \\\n} \\\nstatic ssize_t name##_show(struct device *kdev, \\\n\t\t\t   struct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct hid_device *hdev = to_hid_device(kdev); \\\n\tstruct cp2112_usb_config_report cfg; \\\n\tint ret = cp2112_get_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\treturn sysfs_emit(buf, format, ##__VA_ARGS__); \\\n} \\\nstatic DEVICE_ATTR_RW(name);\n\nCP2112_CONFIG_ATTR(vendor_id, ({\n\tu16 vid;\n\n\tif (sscanf(buf, \"%hi\", &vid) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.vid = cpu_to_le16(vid);\n\tcfg.mask = 0x01;\n}), \"0x%04x\\n\", le16_to_cpu(cfg.vid));\n\nCP2112_CONFIG_ATTR(product_id, ({\n\tu16 pid;\n\n\tif (sscanf(buf, \"%hi\", &pid) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.pid = cpu_to_le16(pid);\n\tcfg.mask = 0x02;\n}), \"0x%04x\\n\", le16_to_cpu(cfg.pid));\n\nCP2112_CONFIG_ATTR(max_power, ({\n\tint mA;\n\n\tif (sscanf(buf, \"%i\", &mA) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.max_power = (mA + 1) / 2;\n\tcfg.mask = 0x04;\n}), \"%u mA\\n\", cfg.max_power * 2);\n\nCP2112_CONFIG_ATTR(power_mode, ({\n\tif (sscanf(buf, \"%hhi\", &cfg.power_mode) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.mask = 0x08;\n}), \"%u\\n\", cfg.power_mode);\n\nCP2112_CONFIG_ATTR(release_version, ({\n\tif (sscanf(buf, \"%hhi.%hhi\", &cfg.release_major, &cfg.release_minor)\n\t    != 2)\n\t\treturn -EINVAL;\n\n\tcfg.mask = 0x10;\n}), \"%u.%u\\n\", cfg.release_major, cfg.release_minor);\n\n#undef CP2112_CONFIG_ATTR\n\nstatic ssize_t pstr_store(struct device *kdev, struct device_attribute *kattr,\n\t\t\t  const char *buf, size_t count, int number)\n{\n\tstruct hid_device *hdev = to_hid_device(kdev);\n\tstruct cp2112_string_report report;\n\tint ret;\n\n\tmemset(&report, 0, sizeof(report));\n\n\tret = utf8s_to_utf16s(buf, count, UTF16_LITTLE_ENDIAN,\n\t\t\t      report.string, ARRAY_SIZE(report.string));\n\treport.report = number;\n\treport.length = ret * sizeof(report.string[0]) + 2;\n\treport.type = USB_DT_STRING;\n\n\tret = cp2112_hid_output(hdev, &report.report, report.length + 1,\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != report.length + 1) {\n\t\thid_err(hdev, \"error writing %s string: %d\\n\", kattr->attr.name,\n\t\t\tret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\treturn count;\n}\n\nstatic ssize_t pstr_show(struct device *kdev, struct device_attribute *kattr,\n\t\t\t char *buf, int number)\n{\n\tstruct hid_device *hdev = to_hid_device(kdev);\n\tstruct cp2112_string_report report;\n\tu8 length;\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, number, (u8 *)&report.contents,\n\t\t\t     sizeof(report.contents), HID_FEATURE_REPORT);\n\tif (ret < 3) {\n\t\thid_err(hdev, \"error reading %s string: %d\\n\", kattr->attr.name,\n\t\t\tret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\tif (report.length < 2) {\n\t\thid_err(hdev, \"invalid %s string length: %d\\n\",\n\t\t\tkattr->attr.name, report.length);\n\t\treturn -EIO;\n\t}\n\n\tlength = report.length > ret - 1 ? ret - 1 : report.length;\n\tlength = (length - 2) / sizeof(report.string[0]);\n\tret = utf16s_to_utf8s(report.string, length, UTF16_LITTLE_ENDIAN, buf,\n\t\t\t      PAGE_SIZE - 1);\n\tbuf[ret++] = '\\n';\n\treturn ret;\n}\n\n#define CP2112_PSTR_ATTR(name, _report) \\\nstatic ssize_t name##_store(struct device *kdev, struct device_attribute *kattr, \\\n\t\t\t    const char *buf, size_t count) \\\n{ \\\n\treturn pstr_store(kdev, kattr, buf, count, _report); \\\n} \\\nstatic ssize_t name##_show(struct device *kdev, struct device_attribute *kattr, char *buf) \\\n{ \\\n\treturn pstr_show(kdev, kattr, buf, _report); \\\n} \\\nstatic DEVICE_ATTR_RW(name);\n\nCP2112_PSTR_ATTR(manufacturer,\tCP2112_MANUFACTURER_STRING);\nCP2112_PSTR_ATTR(product,\tCP2112_PRODUCT_STRING);\nCP2112_PSTR_ATTR(serial,\tCP2112_SERIAL_STRING);\n\n#undef CP2112_PSTR_ATTR\n\nstatic const struct attribute_group cp2112_attr_group = {\n\t.attrs = (struct attribute *[]){\n\t\t&dev_attr_vendor_id.attr,\n\t\t&dev_attr_product_id.attr,\n\t\t&dev_attr_max_power.attr,\n\t\t&dev_attr_power_mode.attr,\n\t\t&dev_attr_release_version.attr,\n\t\t&dev_attr_manufacturer.attr,\n\t\t&dev_attr_product.attr,\n\t\t&dev_attr_serial.attr,\n\t\tNULL\n\t}\n};\n\n \nstatic void chmod_sysfs_attrs(struct hid_device *hdev)\n{\n\tstruct attribute **attr;\n\tu8 buf[2];\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, CP2112_LOCK_BYTE, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error reading lock byte: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tfor (attr = cp2112_attr_group.attrs; *attr; ++attr) {\n\t\tumode_t mode = (buf[1] & 1) ? 0644 : 0444;\n\t\tret = sysfs_chmod_file(&hdev->dev.kobj, *attr, mode);\n\t\tif (ret < 0)\n\t\t\thid_err(hdev, \"error chmoding sysfs file %s\\n\",\n\t\t\t\t(*attr)->name);\n\t\tbuf[1] >>= 1;\n\t}\n}\n\nstatic void cp2112_gpio_irq_ack(struct irq_data *d)\n{\n}\n\nstatic void cp2112_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\t__clear_bit(hwirq, &dev->irq_mask);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void cp2112_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, hwirq);\n\t__set_bit(hwirq, &dev->irq_mask);\n}\n\nstatic void cp2112_gpio_poll_callback(struct work_struct *work)\n{\n\tstruct cp2112_device *dev = container_of(work, struct cp2112_device,\n\t\t\t\t\t\t gpio_poll_worker.work);\n\tstruct irq_data *d;\n\tu8 gpio_mask;\n\tu32 irq_type;\n\tint irq, virq, ret;\n\n\tret = cp2112_gpio_get_all(&dev->gc);\n\tif (ret == -ENODEV)  \n\t\treturn;\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tgpio_mask = ret;\n\tfor_each_set_bit(virq, &dev->irq_mask, CP2112_GPIO_MAX_GPIO) {\n\t\tirq = irq_find_mapping(dev->gc.irq.domain, virq);\n\t\tif (!irq)\n\t\t\tcontinue;\n\n\t\td = irq_get_irq_data(irq);\n\t\tif (!d)\n\t\t\tcontinue;\n\n\t\tirq_type = irqd_get_trigger_type(d);\n\n\t\tif (gpio_mask & BIT(virq)) {\n\t\t\t \n\n\t\t\tif (irq_type & IRQ_TYPE_LEVEL_HIGH)\n\t\t\t\thandle_nested_irq(irq);\n\n\t\t\tif ((irq_type & IRQ_TYPE_EDGE_RISING) &&\n\t\t\t    !(dev->gpio_prev_state & BIT(virq)))\n\t\t\t\thandle_nested_irq(irq);\n\t\t} else {\n\t\t\t \n\n\t\t\tif (irq_type & IRQ_TYPE_LEVEL_LOW)\n\t\t\t\thandle_nested_irq(irq);\n\n\t\t\tif ((irq_type & IRQ_TYPE_EDGE_FALLING) &&\n\t\t\t    (dev->gpio_prev_state & BIT(virq)))\n\t\t\t\thandle_nested_irq(irq);\n\t\t}\n\t}\n\n\tdev->gpio_prev_state = gpio_mask;\n\nexit:\n\tif (dev->gpio_poll)\n\t\tschedule_delayed_work(&dev->gpio_poll_worker, 10);\n}\n\n\nstatic unsigned int cp2112_gpio_irq_startup(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\tif (!dev->gpio_poll) {\n\t\tdev->gpio_poll = true;\n\t\tschedule_delayed_work(&dev->gpio_poll_worker, 0);\n\t}\n\n\tcp2112_gpio_irq_unmask(d);\n\treturn 0;\n}\n\nstatic void cp2112_gpio_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\tcp2112_gpio_irq_mask(d);\n\n\tif (!dev->irq_mask) {\n\t\tdev->gpio_poll = false;\n\t\tcancel_delayed_work_sync(&dev->gpio_poll_worker);\n\t}\n}\n\nstatic int cp2112_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\treturn 0;\n}\n\nstatic const struct irq_chip cp2112_gpio_irqchip = {\n\t.name = \"cp2112-gpio\",\n\t.irq_startup = cp2112_gpio_irq_startup,\n\t.irq_shutdown = cp2112_gpio_irq_shutdown,\n\t.irq_ack = cp2112_gpio_irq_ack,\n\t.irq_mask = cp2112_gpio_irq_mask,\n\t.irq_unmask = cp2112_gpio_irq_unmask,\n\t.irq_set_type = cp2112_gpio_irq_type,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct cp2112_device *dev;\n\tu8 buf[3];\n\tstruct cp2112_smbus_config_report config;\n\tstruct gpio_irq_chip *girq;\n\tint ret;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->in_out_buffer)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->lock);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hw open failed\\n\");\n\t\tgoto err_hid_stop;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\tgoto err_hid_close;\n\t}\n\n\tret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error requesting version\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_info(hdev, \"Part Number: 0x%02X Device Version: 0x%02X\\n\",\n\t\t buf[1], buf[2]);\n\n\tret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\n\t\t\t     sizeof(config), HID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error requesting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\tconfig.retry_time = cpu_to_be16(1);\n\n\tret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error setting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_set_drvdata(hdev, (void *)dev);\n\tdev->hdev\t\t= hdev;\n\tdev->adap.owner\t\t= THIS_MODULE;\n\tdev->adap.class\t\t= I2C_CLASS_HWMON;\n\tdev->adap.algo\t\t= &smbus_algorithm;\n\tdev->adap.algo_data\t= dev;\n\tdev->adap.dev.parent\t= &hdev->dev;\n\tsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\t\t \"CP2112 SMBus Bridge on hidraw%d\",\n\t\t ((struct hidraw *)hdev->hidraw)->minor);\n\tdev->hwversion = buf[2];\n\tinit_waitqueue_head(&dev->wait);\n\n\thid_device_io_start(hdev);\n\tret = i2c_add_adapter(&dev->adap);\n\thid_device_io_stop(hdev);\n\n\tif (ret) {\n\t\thid_err(hdev, \"error registering i2c adapter\\n\");\n\t\tgoto err_power_normal;\n\t}\n\n\thid_dbg(hdev, \"adapter registered\\n\");\n\n\tdev->gc.label\t\t\t= \"cp2112_gpio\";\n\tdev->gc.direction_input\t\t= cp2112_gpio_direction_input;\n\tdev->gc.direction_output\t= cp2112_gpio_direction_output;\n\tdev->gc.set\t\t\t= cp2112_gpio_set;\n\tdev->gc.get\t\t\t= cp2112_gpio_get;\n\tdev->gc.base\t\t\t= -1;\n\tdev->gc.ngpio\t\t\t= CP2112_GPIO_MAX_GPIO;\n\tdev->gc.can_sleep\t\t= 1;\n\tdev->gc.parent\t\t\t= &hdev->dev;\n\n\tgirq = &dev->gc.irq;\n\tgpio_irq_chip_set_chip(girq, &cp2112_gpio_irqchip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\tgirq->threaded = true;\n\n\tINIT_DELAYED_WORK(&dev->gpio_poll_worker, cp2112_gpio_poll_callback);\n\n\tret = gpiochip_add_data(&dev->gc, dev);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error registering gpio chip\\n\");\n\t\tgoto err_free_i2c;\n\t}\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error creating sysfs attrs\\n\");\n\t\tgoto err_gpiochip_remove;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\n\treturn ret;\n\nerr_gpiochip_remove:\n\tgpiochip_remove(&dev->gc);\nerr_free_i2c:\n\ti2c_del_adapter(&dev->adap);\nerr_power_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\nerr_hid_close:\n\thid_hw_close(hdev);\nerr_hid_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void cp2112_remove(struct hid_device *hdev)\n{\n\tstruct cp2112_device *dev = hid_get_drvdata(hdev);\n\n\tsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\n\ti2c_del_adapter(&dev->adap);\n\n\tif (dev->gpio_poll) {\n\t\tdev->gpio_poll = false;\n\t\tcancel_delayed_work_sync(&dev->gpio_poll_worker);\n\t}\n\n\tgpiochip_remove(&dev->gc);\n\t \n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic int cp2112_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\t\t    u8 *data, int size)\n{\n\tstruct cp2112_device *dev = hid_get_drvdata(hdev);\n\tstruct cp2112_xfer_status_report *xfer = (void *)data;\n\n\tswitch (data[0]) {\n\tcase CP2112_TRANSFER_STATUS_RESPONSE:\n\t\thid_dbg(hdev, \"xfer status: %02x %02x %04x %04x\\n\",\n\t\t\txfer->status0, xfer->status1,\n\t\t\tbe16_to_cpu(xfer->retries), be16_to_cpu(xfer->length));\n\n\t\tswitch (xfer->status0) {\n\t\tcase STATUS0_IDLE:\n\t\t\tdev->xfer_status = -EAGAIN;\n\t\t\tbreak;\n\t\tcase STATUS0_BUSY:\n\t\t\tdev->xfer_status = -EBUSY;\n\t\t\tbreak;\n\t\tcase STATUS0_COMPLETE:\n\t\t\tdev->xfer_status = be16_to_cpu(xfer->length);\n\t\t\tbreak;\n\t\tcase STATUS0_ERROR:\n\t\t\tswitch (xfer->status1) {\n\t\t\tcase STATUS1_TIMEOUT_NACK:\n\t\t\tcase STATUS1_TIMEOUT_BUS:\n\t\t\t\tdev->xfer_status = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev->xfer_status = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev->xfer_status = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tatomic_set(&dev->xfer_avail, 1);\n\t\tbreak;\n\tcase CP2112_DATA_READ_RESPONSE:\n\t\thid_dbg(hdev, \"read response: %02x %02x\\n\", data[1], data[2]);\n\n\t\tdev->read_length = data[2];\n\t\tif (dev->read_length > sizeof(dev->read_data))\n\t\t\tdev->read_length = sizeof(dev->read_data);\n\n\t\tmemcpy(dev->read_data, &data[3], dev->read_length);\n\t\tatomic_set(&dev->read_avail, 1);\n\t\tbreak;\n\tdefault:\n\t\thid_err(hdev, \"unknown report\\n\");\n\n\t\treturn 0;\n\t}\n\n\twake_up_interruptible(&dev->wait);\n\treturn 1;\n}\n\nstatic struct hid_driver cp2112_driver = {\n\t.name\t\t= \"cp2112\",\n\t.id_table\t= cp2112_devices,\n\t.probe\t\t= cp2112_probe,\n\t.remove\t\t= cp2112_remove,\n\t.raw_event\t= cp2112_raw_event,\n};\n\nmodule_hid_driver(cp2112_driver);\nMODULE_DESCRIPTION(\"Silicon Labs HID USB to SMBus master bridge\");\nMODULE_AUTHOR(\"David Barksdale <dbarksdale@uplogix.com>\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}