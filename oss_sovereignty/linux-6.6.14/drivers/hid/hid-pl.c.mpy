{
  "module_name": "hid-pl.c",
  "hash_id": "9b5c9993616b07b05e430e6e939f377db6de76fae3d5bffeeecf58308f2ebda0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-pl.c",
  "human_readable_source": "\n \n\n \n\n\n \n\n#define debug(format, arg...) pr_debug(\"hid-plff: \" format \"\\n\" , ## arg)\n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/hid.h>\n\n#include \"hid-ids.h\"\n\n#ifdef CONFIG_PANTHERLORD_FF\n\nstruct plff_device {\n\tstruct hid_report *report;\n\ts32 maxval;\n\ts32 *strong;\n\ts32 *weak;\n};\n\nstatic int hid_plff_play(struct input_dev *dev, void *data,\n\t\t\t struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct plff_device *plff = data;\n\tint left, right;\n\n\tleft = effect->u.rumble.strong_magnitude;\n\tright = effect->u.rumble.weak_magnitude;\n\tdebug(\"called with 0x%04x 0x%04x\", left, right);\n\n\tleft = left * plff->maxval / 0xffff;\n\tright = right * plff->maxval / 0xffff;\n\n\t*plff->strong = left;\n\t*plff->weak = right;\n\tdebug(\"running with 0x%02x 0x%02x\", left, right);\n\thid_hw_request(hid, plff->report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}\n\nstatic int plff_init(struct hid_device *hid)\n{\n\tstruct plff_device *plff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput;\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct list_head *report_ptr = report_list;\n\tstruct input_dev *dev;\n\tint error;\n\ts32 maxval;\n\ts32 *strong;\n\ts32 *weak;\n\n\t \n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlist_for_each_entry(hidinput, &hid->inputs, list) {\n\n\t\treport_ptr = report_ptr->next;\n\n\t\tif (report_ptr == report_list) {\n\t\t\thid_err(hid, \"required output report is missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\treport = list_entry(report_ptr, struct hid_report, list);\n\t\tif (report->maxfield < 1) {\n\t\t\thid_err(hid, \"no fields in the report\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tmaxval = 0x7f;\n\t\tif (report->field[0]->report_count >= 4) {\n\t\t\treport->field[0]->value[0] = 0x00;\n\t\t\treport->field[0]->value[1] = 0x00;\n\t\t\tstrong = &report->field[0]->value[2];\n\t\t\tweak = &report->field[0]->value[3];\n\t\t\tdebug(\"detected single-field device\");\n\t\t} else if (report->field[0]->maxusage == 1 &&\n\t\t\t   report->field[0]->usage[0].hid ==\n\t\t\t\t(HID_UP_LED | 0x43) &&\n\t\t\t   report->maxfield >= 4 &&\n\t\t\t   report->field[0]->report_count >= 1 &&\n\t\t\t   report->field[1]->report_count >= 1 &&\n\t\t\t   report->field[2]->report_count >= 1 &&\n\t\t\t   report->field[3]->report_count >= 1) {\n\t\t\treport->field[0]->value[0] = 0x00;\n\t\t\treport->field[1]->value[0] = 0x00;\n\t\t\tstrong = &report->field[2]->value[0];\n\t\t\tweak = &report->field[3]->value[0];\n\t\t\tif (hid->vendor == USB_VENDOR_ID_JESS2)\n\t\t\t\tmaxval = 0xff;\n\t\t\tdebug(\"detected 4-field device\");\n\t\t} else {\n\t\t\thid_err(hid, \"not enough fields or values\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tplff = kzalloc(sizeof(struct plff_device), GFP_KERNEL);\n\t\tif (!plff)\n\t\t\treturn -ENOMEM;\n\n\t\tdev = hidinput->input;\n\n\t\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\t\terror = input_ff_create_memless(dev, plff, hid_plff_play);\n\t\tif (error) {\n\t\t\tkfree(plff);\n\t\t\treturn error;\n\t\t}\n\n\t\tplff->report = report;\n\t\tplff->strong = strong;\n\t\tplff->weak = weak;\n\t\tplff->maxval = maxval;\n\n\t\t*strong = 0x00;\n\t\t*weak = 0x00;\n\t\thid_hw_request(hid, plff->report, HID_REQ_SET_REPORT);\n\t}\n\n\thid_info(hid, \"Force feedback for PantherLord/GreenAsia devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\treturn 0;\n}\n#else\nstatic inline int plff_init(struct hid_device *hid)\n{\n\treturn 0;\n}\n#endif\n\nstatic int pl_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\n\tif (id->driver_data)\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err;\n\t}\n\n\tplff_init(hdev);\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic const struct hid_device_id pl_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GAMERON, USB_DEVICE_ID_GAMERON_DUAL_PSX_ADAPTOR),\n\t\t.driver_data = 1 },  \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GAMERON, USB_DEVICE_ID_GAMERON_DUAL_PCS_ADAPTOR),\n\t\t.driver_data = 1 },  \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GREENASIA, 0x0003), },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JESS2, USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, pl_devices);\n\nstatic struct hid_driver pl_driver = {\n\t.name = \"pantherlord\",\n\t.id_table = pl_devices,\n\t.probe = pl_probe,\n};\nmodule_hid_driver(pl_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}