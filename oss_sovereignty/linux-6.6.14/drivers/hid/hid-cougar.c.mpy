{
  "module_name": "hid-cougar.c",
  "hash_id": "dae1b59bab9c4702c51e92b3ab5c68ddaa84457c598dd8971ba0485d36021107",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-cougar.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n\n#include \"hid-ids.h\"\n\nMODULE_AUTHOR(\"Daniel M. Lambea <dmlambea@gmail.com>\");\nMODULE_DESCRIPTION(\"Cougar 500k Gaming Keyboard\");\nMODULE_LICENSE(\"GPL\");\nMODULE_INFO(key_mappings, \"G1-G6 are mapped to F13-F18\");\n\nstatic bool g6_is_space = true;\nMODULE_PARM_DESC(g6_is_space,\n\t\"If true, G6 programmable key sends SPACE instead of F18 (default=true)\");\n\n#define COUGAR_VENDOR_USAGE\t0xff00ff00\n\n#define COUGAR_FIELD_CODE\t1\n#define COUGAR_FIELD_ACTION\t2\n\n#define COUGAR_KEY_G1\t\t0x83\n#define COUGAR_KEY_G2\t\t0x84\n#define COUGAR_KEY_G3\t\t0x85\n#define COUGAR_KEY_G4\t\t0x86\n#define COUGAR_KEY_G5\t\t0x87\n#define COUGAR_KEY_G6\t\t0x78\n#define COUGAR_KEY_FN\t\t0x0d\n#define COUGAR_KEY_MR\t\t0x6f\n#define COUGAR_KEY_M1\t\t0x80\n#define COUGAR_KEY_M2\t\t0x81\n#define COUGAR_KEY_M3\t\t0x82\n#define COUGAR_KEY_LEDS\t\t0x67\n#define COUGAR_KEY_LOCK\t\t0x6e\n\n\n \nstatic unsigned char cougar_mapping[][2] = {\n\t{ COUGAR_KEY_G6,   KEY_SPACE },\n\t{ COUGAR_KEY_G1,   KEY_F13 },\n\t{ COUGAR_KEY_G2,   KEY_F14 },\n\t{ COUGAR_KEY_G3,   KEY_F15 },\n\t{ COUGAR_KEY_G4,   KEY_F16 },\n\t{ COUGAR_KEY_G5,   KEY_F17 },\n\t{ COUGAR_KEY_LOCK, KEY_SCREENLOCK },\n \n\t{ 0, 0 },\n};\n\nstruct cougar_shared {\n\tstruct list_head list;\n\tstruct kref kref;\n\tbool enabled;\n\tstruct hid_device *dev;\n\tstruct input_dev *input;\n};\n\nstruct cougar {\n\tbool special_intf;\n\tstruct cougar_shared *shared;\n};\n\nstatic LIST_HEAD(cougar_udev_list);\nstatic DEFINE_MUTEX(cougar_udev_list_lock);\n\n \nstatic void cougar_fix_g6_mapping(void)\n{\n\tint i;\n\n\tfor (i = 0; cougar_mapping[i][0]; i++) {\n\t\tif (cougar_mapping[i][0] == COUGAR_KEY_G6) {\n\t\t\tcougar_mapping[i][1] =\n\t\t\t\tg6_is_space ? KEY_SPACE : KEY_F18;\n\t\t\tpr_info(\"cougar: G6 mapped to %s\\n\",\n\t\t\t\tg6_is_space ? \"space\" : \"F18\");\n\t\t\treturn;\n\t\t}\n\t}\n\tpr_warn(\"cougar: no mappings defined for G6/spacebar\");\n}\n\n \nstatic __u8 *cougar_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\t\t\t unsigned int *rsize)\n{\n\tif (rdesc[2] == 0x09 && rdesc[3] == 0x02 &&\n\t    (rdesc[115] | rdesc[116] << 8) >= HID_MAX_USAGES) {\n\t\thid_info(hdev,\n\t\t\t\"usage count exceeds max: fixing up report descriptor\\n\");\n\t\trdesc[115] = ((HID_MAX_USAGES-1) & 0xff);\n\t\trdesc[116] = ((HID_MAX_USAGES-1) >> 8);\n\t}\n\treturn rdesc;\n}\n\nstatic struct cougar_shared *cougar_get_shared_data(struct hid_device *hdev)\n{\n\tstruct cougar_shared *shared;\n\n\t \n\tlist_for_each_entry(shared, &cougar_udev_list, list) {\n\t\tif (hid_compare_device_paths(hdev, shared->dev, '/')) {\n\t\t\tkref_get(&shared->kref);\n\t\t\treturn shared;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void cougar_release_shared_data(struct kref *kref)\n{\n\tstruct cougar_shared *shared = container_of(kref,\n\t\t\t\t\t\t    struct cougar_shared, kref);\n\n\tmutex_lock(&cougar_udev_list_lock);\n\tlist_del(&shared->list);\n\tmutex_unlock(&cougar_udev_list_lock);\n\n\tkfree(shared);\n}\n\nstatic void cougar_remove_shared_data(void *resource)\n{\n\tstruct cougar *cougar = resource;\n\n\tif (cougar->shared) {\n\t\tkref_put(&cougar->shared->kref, cougar_release_shared_data);\n\t\tcougar->shared = NULL;\n\t}\n}\n\n \nstatic int cougar_bind_shared_data(struct hid_device *hdev,\n\t\t\t\t   struct cougar *cougar)\n{\n\tstruct cougar_shared *shared;\n\tint error = 0;\n\n\tmutex_lock(&cougar_udev_list_lock);\n\n\tshared = cougar_get_shared_data(hdev);\n\tif (!shared) {\n\t\tshared = kzalloc(sizeof(*shared), GFP_KERNEL);\n\t\tif (!shared) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkref_init(&shared->kref);\n\t\tshared->dev = hdev;\n\t\tlist_add_tail(&shared->list, &cougar_udev_list);\n\t}\n\n\tcougar->shared = shared;\n\n\terror = devm_add_action_or_reset(&hdev->dev, cougar_remove_shared_data, cougar);\n\tif (error) {\n\t\tmutex_unlock(&cougar_udev_list_lock);\n\t\treturn error;\n\t}\n\nout:\n\tmutex_unlock(&cougar_udev_list_lock);\n\treturn error;\n}\n\nstatic int cougar_probe(struct hid_device *hdev,\n\t\t\tconst struct hid_device_id *id)\n{\n\tstruct cougar *cougar;\n\tstruct hid_input *next, *hidinput = NULL;\n\tunsigned int connect_mask;\n\tint error;\n\n\tcougar = devm_kzalloc(&hdev->dev, sizeof(*cougar), GFP_KERNEL);\n\tif (!cougar)\n\t\treturn -ENOMEM;\n\thid_set_drvdata(hdev, cougar);\n\n\terror = hid_parse(hdev);\n\tif (error) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn error;\n\t}\n\n\tif (hdev->collection->usage == COUGAR_VENDOR_USAGE) {\n\t\tcougar->special_intf = true;\n\t\tconnect_mask = HID_CONNECT_HIDRAW;\n\t} else\n\t\tconnect_mask = HID_CONNECT_DEFAULT;\n\n\terror = hid_hw_start(hdev, connect_mask);\n\tif (error) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = cougar_bind_shared_data(hdev, cougar);\n\tif (error)\n\t\tgoto fail_stop_and_cleanup;\n\n\t \n\tif (hdev->collection->usage == HID_GD_KEYBOARD) {\n\t\tlist_for_each_entry_safe(hidinput, next, &hdev->inputs, list) {\n\t\t\tif (hidinput->registered && hidinput->input != NULL) {\n\t\t\t\tcougar->shared->input = hidinput->input;\n\t\t\t\tcougar->shared->enabled = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (hdev->collection->usage == COUGAR_VENDOR_USAGE) {\n\t\t \n\t\tcougar_fix_g6_mapping();\n\t\terror = hid_hw_open(hdev);\n\t\tif (error)\n\t\t\tgoto fail_stop_and_cleanup;\n\t}\n\treturn 0;\n\nfail_stop_and_cleanup:\n\thid_hw_stop(hdev);\n\treturn error;\n}\n\n \nstatic int cougar_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\t\t    u8 *data, int size)\n{\n\tstruct cougar *cougar;\n\tstruct cougar_shared *shared;\n\tunsigned char code, action;\n\tint i;\n\n\tcougar = hid_get_drvdata(hdev);\n\tshared = cougar->shared;\n\tif (!cougar->special_intf || !shared)\n\t\treturn 0;\n\n\tif (!shared->enabled || !shared->input)\n\t\treturn -EPERM;\n\n\tcode = data[COUGAR_FIELD_CODE];\n\taction = data[COUGAR_FIELD_ACTION];\n\tfor (i = 0; cougar_mapping[i][0]; i++) {\n\t\tif (code == cougar_mapping[i][0]) {\n\t\t\tinput_event(shared->input, EV_KEY,\n\t\t\t\t    cougar_mapping[i][1], action);\n\t\t\tinput_sync(shared->input);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t \n\tif (action != 0)\n\t\thid_warn(hdev, \"unmapped special key code %0x: ignoring\\n\", code);\n\treturn -EPERM;\n}\n\nstatic void cougar_remove(struct hid_device *hdev)\n{\n\tstruct cougar *cougar = hid_get_drvdata(hdev);\n\n\tif (cougar) {\n\t\t \n\t\tif (cougar->shared)\n\t\t\tcougar->shared->enabled = false;\n\t\tif (cougar->special_intf)\n\t\t\thid_hw_close(hdev);\n\t}\n\thid_hw_stop(hdev);\n}\n\nstatic int cougar_param_set_g6_is_space(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tint ret;\n\n\tret = param_set_bool(val, kp);\n\tif (ret)\n\t\treturn ret;\n\n\tcougar_fix_g6_mapping();\n\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops cougar_g6_is_space_ops = {\n\t.set\t= cougar_param_set_g6_is_space,\n\t.get\t= param_get_bool,\n};\nmodule_param_cb(g6_is_space, &cougar_g6_is_space_ops, &g6_is_space, 0644);\n\nstatic const struct hid_device_id cougar_id_table[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SOLID_YEAR,\n\t\t\t USB_DEVICE_ID_COUGAR_500K_GAMING_KEYBOARD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SOLID_YEAR,\n\t\t\t USB_DEVICE_ID_COUGAR_700K_GAMING_KEYBOARD) },\n\t{}\n};\nMODULE_DEVICE_TABLE(hid, cougar_id_table);\n\nstatic struct hid_driver cougar_driver = {\n\t.name\t\t\t= \"cougar\",\n\t.id_table\t\t= cougar_id_table,\n\t.report_fixup\t\t= cougar_report_fixup,\n\t.probe\t\t\t= cougar_probe,\n\t.remove\t\t\t= cougar_remove,\n\t.raw_event\t\t= cougar_raw_event,\n};\n\nmodule_hid_driver(cougar_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}