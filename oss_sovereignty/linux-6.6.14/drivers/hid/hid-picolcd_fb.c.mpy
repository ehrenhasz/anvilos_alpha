{
  "module_name": "hid-picolcd_fb.c",
  "hash_id": "060cb89fe6a55228379c272e04306d1651093c5a86b3f4d2ae4ed45d8963dc4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-picolcd_fb.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/vmalloc.h>\n\n#include <linux/fb.h>\n#include <linux/module.h>\n\n#include \"hid-picolcd.h\"\n\n \n#define PICOLCDFB_NAME \"picolcdfb\"\n#define PICOLCDFB_WIDTH (256)\n#define PICOLCDFB_HEIGHT (64)\n#define PICOLCDFB_SIZE (PICOLCDFB_WIDTH * PICOLCDFB_HEIGHT / 8)\n\n#define PICOLCDFB_UPDATE_RATE_LIMIT   10\n#define PICOLCDFB_UPDATE_RATE_DEFAULT  2\n\n \nstatic const struct fb_fix_screeninfo picolcdfb_fix = {\n\t.id          = PICOLCDFB_NAME,\n\t.type        = FB_TYPE_PACKED_PIXELS,\n\t.visual      = FB_VISUAL_MONO01,\n\t.xpanstep    = 0,\n\t.ypanstep    = 0,\n\t.ywrapstep   = 0,\n\t.line_length = PICOLCDFB_WIDTH / 8,\n\t.accel       = FB_ACCEL_NONE,\n};\n\nstatic const struct fb_var_screeninfo picolcdfb_var = {\n\t.xres           = PICOLCDFB_WIDTH,\n\t.yres           = PICOLCDFB_HEIGHT,\n\t.xres_virtual   = PICOLCDFB_WIDTH,\n\t.yres_virtual   = PICOLCDFB_HEIGHT,\n\t.width          = 103,\n\t.height         = 26,\n\t.bits_per_pixel = 1,\n\t.grayscale      = 1,\n\t.red            = {\n\t\t.offset = 0,\n\t\t.length = 1,\n\t\t.msb_right = 0,\n\t},\n\t.green          = {\n\t\t.offset = 0,\n\t\t.length = 1,\n\t\t.msb_right = 0,\n\t},\n\t.blue           = {\n\t\t.offset = 0,\n\t\t.length = 1,\n\t\t.msb_right = 0,\n\t},\n\t.transp         = {\n\t\t.offset = 0,\n\t\t.length = 0,\n\t\t.msb_right = 0,\n\t},\n};\n\n \nstatic int picolcd_fb_send_tile(struct picolcd_data *data, u8 *vbitmap,\n\t\tint chip, int tile)\n{\n\tstruct hid_report *report1, *report2;\n\tunsigned long flags;\n\tu8 *tdata;\n\tint i;\n\n\treport1 = picolcd_out_report(REPORT_LCD_CMD_DATA, data->hdev);\n\tif (!report1 || report1->maxfield != 1)\n\t\treturn -ENODEV;\n\treport2 = picolcd_out_report(REPORT_LCD_DATA, data->hdev);\n\tif (!report2 || report2->maxfield != 1)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\tif ((data->status & PICOLCD_FAILED)) {\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\thid_set_field(report1->field[0],  0, chip << 2);\n\thid_set_field(report1->field[0],  1, 0x02);\n\thid_set_field(report1->field[0],  2, 0x00);\n\thid_set_field(report1->field[0],  3, 0x00);\n\thid_set_field(report1->field[0],  4, 0xb8 | tile);\n\thid_set_field(report1->field[0],  5, 0x00);\n\thid_set_field(report1->field[0],  6, 0x00);\n\thid_set_field(report1->field[0],  7, 0x40);\n\thid_set_field(report1->field[0],  8, 0x00);\n\thid_set_field(report1->field[0],  9, 0x00);\n\thid_set_field(report1->field[0], 10,   32);\n\n\thid_set_field(report2->field[0],  0, (chip << 2) | 0x01);\n\thid_set_field(report2->field[0],  1, 0x00);\n\thid_set_field(report2->field[0],  2, 0x00);\n\thid_set_field(report2->field[0],  3,   32);\n\n\ttdata = vbitmap + (tile * 4 + chip) * 64;\n\tfor (i = 0; i < 64; i++)\n\t\tif (i < 32)\n\t\t\thid_set_field(report1->field[0], 11 + i, tdata[i]);\n\t\telse\n\t\t\thid_set_field(report2->field[0], 4 + i - 32, tdata[i]);\n\n\thid_hw_request(data->hdev, report1, HID_REQ_SET_REPORT);\n\thid_hw_request(data->hdev, report2, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\treturn 0;\n}\n\n \nstatic int picolcd_fb_update_tile(u8 *vbitmap, const u8 *bitmap, int bpp,\n\t\tint chip, int tile)\n{\n\tint i, b, changed = 0;\n\tu8 tdata[64];\n\tu8 *vdata = vbitmap + (tile * 4 + chip) * 64;\n\n\tif (bpp == 1) {\n\t\tfor (b = 7; b >= 0; b--) {\n\t\t\tconst u8 *bdata = bitmap + tile * 256 + chip * 8 + b * 32;\n\t\t\tfor (i = 0; i < 64; i++) {\n\t\t\t\ttdata[i] <<= 1;\n\t\t\t\ttdata[i] |= (bdata[i/8] >> (i % 8)) & 0x01;\n\t\t\t}\n\t\t}\n\t} else if (bpp == 8) {\n\t\tfor (b = 7; b >= 0; b--) {\n\t\t\tconst u8 *bdata = bitmap + (tile * 256 + chip * 8 + b * 32) * 8;\n\t\t\tfor (i = 0; i < 64; i++) {\n\t\t\t\ttdata[i] <<= 1;\n\t\t\t\ttdata[i] |= (bdata[i] & 0x80) ? 0x01 : 0x00;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 64; i++)\n\t\tif (tdata[i] != vdata[i]) {\n\t\t\tchanged = 1;\n\t\t\tvdata[i] = tdata[i];\n\t\t}\n\treturn changed;\n}\n\nvoid picolcd_fb_refresh(struct picolcd_data *data)\n{\n\tif (data->fb_info)\n\t\tschedule_delayed_work(&data->fb_info->deferred_work, 0);\n}\n\n \nint picolcd_fb_reset(struct picolcd_data *data, int clear)\n{\n\tstruct hid_report *report = picolcd_out_report(REPORT_LCD_CMD, data->hdev);\n\tstruct picolcd_fb_data *fbdata = data->fb_info->par;\n\tint i, j;\n\tunsigned long flags;\n\tstatic const u8 mapcmd[8] = { 0x00, 0x02, 0x00, 0x64, 0x3f, 0x00, 0x64, 0xc0 };\n\n\tif (!report || report->maxfield != 1)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = 0; j < report->field[0]->maxusage; j++)\n\t\t\tif (j == 0)\n\t\t\t\thid_set_field(report->field[0], j, i << 2);\n\t\t\telse if (j < sizeof(mapcmd))\n\t\t\t\thid_set_field(report->field[0], j, mapcmd[j]);\n\t\t\telse\n\t\t\t\thid_set_field(report->field[0], j, 0);\n\t\thid_hw_request(data->hdev, report, HID_REQ_SET_REPORT);\n\t}\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\tif (clear) {\n\t\tmemset(fbdata->vbitmap, 0, PICOLCDFB_SIZE);\n\t\tmemset(fbdata->bitmap, 0, PICOLCDFB_SIZE*fbdata->bpp);\n\t}\n\tfbdata->force = 1;\n\n\t \n\tif (fbdata->ready)\n\t\tschedule_delayed_work(&data->fb_info->deferred_work, 0);\n\telse\n\t\tfbdata->ready = 1;\n\n\treturn 0;\n}\n\n \nstatic void picolcd_fb_update(struct fb_info *info)\n{\n\tint chip, tile, n;\n\tunsigned long flags;\n\tstruct picolcd_fb_data *fbdata = info->par;\n\tstruct picolcd_data *data;\n\n\tmutex_lock(&info->lock);\n\n\tspin_lock_irqsave(&fbdata->lock, flags);\n\tif (!fbdata->ready && fbdata->picolcd)\n\t\tpicolcd_fb_reset(fbdata->picolcd, 0);\n\tspin_unlock_irqrestore(&fbdata->lock, flags);\n\n\t \n\tn = 0;\n\tfor (chip = 0; chip < 4; chip++)\n\t\tfor (tile = 0; tile < 8; tile++) {\n\t\t\tif (!fbdata->force && !picolcd_fb_update_tile(\n\t\t\t\t\tfbdata->vbitmap, fbdata->bitmap,\n\t\t\t\t\tfbdata->bpp, chip, tile))\n\t\t\t\tcontinue;\n\t\t\tn += 2;\n\t\t\tif (n >= HID_OUTPUT_FIFO_SIZE / 2) {\n\t\t\t\tspin_lock_irqsave(&fbdata->lock, flags);\n\t\t\t\tdata = fbdata->picolcd;\n\t\t\t\tspin_unlock_irqrestore(&fbdata->lock, flags);\n\t\t\t\tmutex_unlock(&info->lock);\n\t\t\t\tif (!data)\n\t\t\t\t\treturn;\n\t\t\t\thid_hw_wait(data->hdev);\n\t\t\t\tmutex_lock(&info->lock);\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&fbdata->lock, flags);\n\t\t\tdata = fbdata->picolcd;\n\t\t\tspin_unlock_irqrestore(&fbdata->lock, flags);\n\t\t\tif (!data || picolcd_fb_send_tile(data,\n\t\t\t\t\tfbdata->vbitmap, chip, tile))\n\t\t\t\tgoto out;\n\t\t}\n\tfbdata->force = false;\n\tif (n) {\n\t\tspin_lock_irqsave(&fbdata->lock, flags);\n\t\tdata = fbdata->picolcd;\n\t\tspin_unlock_irqrestore(&fbdata->lock, flags);\n\t\tmutex_unlock(&info->lock);\n\t\tif (data)\n\t\t\thid_hw_wait(data->hdev);\n\t\treturn;\n\t}\nout:\n\tmutex_unlock(&info->lock);\n}\n\n \nstatic void picolcd_fb_fillrect(struct fb_info *info,\n\t\tconst struct fb_fillrect *rect)\n{\n\tif (!info->par)\n\t\treturn;\n\tsys_fillrect(info, rect);\n\n\tschedule_delayed_work(&info->deferred_work, 0);\n}\n\n \nstatic void picolcd_fb_copyarea(struct fb_info *info,\n\t\tconst struct fb_copyarea *area)\n{\n\tif (!info->par)\n\t\treturn;\n\tsys_copyarea(info, area);\n\n\tschedule_delayed_work(&info->deferred_work, 0);\n}\n\n \nstatic void picolcd_fb_imageblit(struct fb_info *info, const struct fb_image *image)\n{\n\tif (!info->par)\n\t\treturn;\n\tsys_imageblit(info, image);\n\n\tschedule_delayed_work(&info->deferred_work, 0);\n}\n\n \nstatic ssize_t picolcd_fb_write(struct fb_info *info, const char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tif (!info->par)\n\t\treturn -ENODEV;\n\tret = fb_sys_write(info, buf, count, ppos);\n\tif (ret >= 0)\n\t\tschedule_delayed_work(&info->deferred_work, 0);\n\treturn ret;\n}\n\nstatic int picolcd_fb_blank(int blank, struct fb_info *info)\n{\n\t \n\treturn 0;\n}\n\nstatic void picolcd_fb_destroy(struct fb_info *info)\n{\n\tstruct picolcd_fb_data *fbdata = info->par;\n\n\t \n\tfb_deferred_io_cleanup(info);\n\n\t \n\tWARN_ON(fbdata->picolcd != NULL);\n\n\tvfree((u8 *)info->fix.smem_start);\n\tframebuffer_release(info);\n}\n\nstatic int picolcd_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\t__u32 bpp      = var->bits_per_pixel;\n\t__u32 activate = var->activate;\n\n\t \n\t*var = picolcdfb_var;\n\tvar->activate = activate;\n\tif (bpp >= 8) {\n\t\tvar->bits_per_pixel = 8;\n\t\tvar->red.length     = 8;\n\t\tvar->green.length   = 8;\n\t\tvar->blue.length    = 8;\n\t} else {\n\t\tvar->bits_per_pixel = 1;\n\t\tvar->red.length     = 1;\n\t\tvar->green.length   = 1;\n\t\tvar->blue.length    = 1;\n\t}\n\treturn 0;\n}\n\nstatic int picolcd_set_par(struct fb_info *info)\n{\n\tstruct picolcd_fb_data *fbdata = info->par;\n\tu8 *tmp_fb, *o_fb;\n\tif (info->var.bits_per_pixel == fbdata->bpp)\n\t\treturn 0;\n\t \n\tif (info->var.bits_per_pixel != 1 && info->var.bits_per_pixel != 8)\n\t\treturn -EINVAL;\n\n\to_fb   = fbdata->bitmap;\n\ttmp_fb = kmalloc_array(PICOLCDFB_SIZE, info->var.bits_per_pixel,\n\t\t\t       GFP_KERNEL);\n\tif (!tmp_fb)\n\t\treturn -ENOMEM;\n\n\t \n\tif (info->var.bits_per_pixel == 1) {\n\t\tint i, b;\n\t\tfor (i = 0; i < PICOLCDFB_SIZE; i++) {\n\t\t\tu8 p = 0;\n\t\t\tfor (b = 0; b < 8; b++) {\n\t\t\t\tp <<= 1;\n\t\t\t\tp |= o_fb[i*8+b] ? 0x01 : 0x00;\n\t\t\t}\n\t\t\ttmp_fb[i] = p;\n\t\t}\n\t\tmemcpy(o_fb, tmp_fb, PICOLCDFB_SIZE);\n\t\tinfo->fix.visual = FB_VISUAL_MONO01;\n\t\tinfo->fix.line_length = PICOLCDFB_WIDTH / 8;\n\t} else {\n\t\tint i;\n\t\tmemcpy(tmp_fb, o_fb, PICOLCDFB_SIZE);\n\t\tfor (i = 0; i < PICOLCDFB_SIZE * 8; i++)\n\t\t\to_fb[i] = tmp_fb[i/8] & (0x01 << (7 - i % 8)) ? 0xff : 0x00;\n\t\tinfo->fix.visual = FB_VISUAL_DIRECTCOLOR;\n\t\tinfo->fix.line_length = PICOLCDFB_WIDTH;\n\t}\n\n\tkfree(tmp_fb);\n\tfbdata->bpp = info->var.bits_per_pixel;\n\treturn 0;\n}\n\nstatic const struct fb_ops picolcdfb_ops = {\n\t.owner        = THIS_MODULE,\n\t.fb_destroy   = picolcd_fb_destroy,\n\t.fb_read      = fb_sys_read,\n\t.fb_write     = picolcd_fb_write,\n\t.fb_blank     = picolcd_fb_blank,\n\t.fb_fillrect  = picolcd_fb_fillrect,\n\t.fb_copyarea  = picolcd_fb_copyarea,\n\t.fb_imageblit = picolcd_fb_imageblit,\n\t.fb_check_var = picolcd_fb_check_var,\n\t.fb_set_par   = picolcd_set_par,\n\t.fb_mmap      = fb_deferred_io_mmap,\n};\n\n\n \nstatic void picolcd_fb_deferred_io(struct fb_info *info, struct list_head *pagereflist)\n{\n\tpicolcd_fb_update(info);\n}\n\nstatic const struct fb_deferred_io picolcd_fb_defio = {\n\t.delay = HZ / PICOLCDFB_UPDATE_RATE_DEFAULT,\n\t.deferred_io = picolcd_fb_deferred_io,\n};\n\n\n \nstatic ssize_t picolcd_fb_update_rate_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct picolcd_data *data = dev_get_drvdata(dev);\n\tstruct picolcd_fb_data *fbdata = data->fb_info->par;\n\tunsigned i, fb_update_rate = fbdata->update_rate;\n\tsize_t ret = 0;\n\n\tfor (i = 1; i <= PICOLCDFB_UPDATE_RATE_LIMIT; i++)\n\t\tif (ret >= PAGE_SIZE)\n\t\t\tbreak;\n\t\telse if (i == fb_update_rate)\n\t\t\tret += scnprintf(buf+ret, PAGE_SIZE-ret, \"[%u] \", i);\n\t\telse\n\t\t\tret += scnprintf(buf+ret, PAGE_SIZE-ret, \"%u \", i);\n\tif (ret > 0)\n\t\tbuf[min(ret, (size_t)PAGE_SIZE)-1] = '\\n';\n\treturn ret;\n}\n\nstatic ssize_t picolcd_fb_update_rate_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct picolcd_data *data = dev_get_drvdata(dev);\n\tstruct picolcd_fb_data *fbdata = data->fb_info->par;\n\tint i;\n\tunsigned u;\n\n\tif (count < 1 || count > 10)\n\t\treturn -EINVAL;\n\n\ti = sscanf(buf, \"%u\", &u);\n\tif (i != 1)\n\t\treturn -EINVAL;\n\n\tif (u > PICOLCDFB_UPDATE_RATE_LIMIT)\n\t\treturn -ERANGE;\n\telse if (u == 0)\n\t\tu = PICOLCDFB_UPDATE_RATE_DEFAULT;\n\n\tfbdata->update_rate = u;\n\tdata->fb_info->fbdefio->delay = HZ / fbdata->update_rate;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(fb_update_rate, 0664, picolcd_fb_update_rate_show,\n\t\tpicolcd_fb_update_rate_store);\n\n \nint picolcd_init_framebuffer(struct picolcd_data *data)\n{\n\tstruct device *dev = &data->hdev->dev;\n\tstruct fb_info *info = NULL;\n\tstruct picolcd_fb_data *fbdata = NULL;\n\tint i, error = -ENOMEM;\n\tu32 *palette;\n\n\t \n\tinfo = framebuffer_alloc(256 * sizeof(u32) +\n\t\t\tsizeof(struct fb_deferred_io) +\n\t\t\tsizeof(struct picolcd_fb_data) +\n\t\t\tPICOLCDFB_SIZE, dev);\n\tif (!info)\n\t\tgoto err_nomem;\n\n\tinfo->fbdefio = info->par;\n\t*info->fbdefio = picolcd_fb_defio;\n\tinfo->par += sizeof(struct fb_deferred_io);\n\tpalette = info->par;\n\tinfo->par += 256 * sizeof(u32);\n\tfor (i = 0; i < 256; i++)\n\t\tpalette[i] = i > 0 && i < 16 ? 0xff : 0;\n\tinfo->pseudo_palette = palette;\n\tinfo->fbops = &picolcdfb_ops;\n\tinfo->var = picolcdfb_var;\n\tinfo->fix = picolcdfb_fix;\n\tinfo->fix.smem_len   = PICOLCDFB_SIZE*8;\n\n\tfbdata = info->par;\n\tspin_lock_init(&fbdata->lock);\n\tfbdata->picolcd = data;\n\tfbdata->update_rate = PICOLCDFB_UPDATE_RATE_DEFAULT;\n\tfbdata->bpp     = picolcdfb_var.bits_per_pixel;\n\tfbdata->force   = 1;\n\tfbdata->vbitmap = info->par + sizeof(struct picolcd_fb_data);\n\tfbdata->bitmap  = vmalloc(PICOLCDFB_SIZE*8);\n\tif (fbdata->bitmap == NULL) {\n\t\tdev_err(dev, \"can't get a free page for framebuffer\\n\");\n\t\tgoto err_nomem;\n\t}\n\tinfo->screen_buffer = fbdata->bitmap;\n\tinfo->fix.smem_start = (unsigned long)fbdata->bitmap;\n\tmemset(fbdata->vbitmap, 0xff, PICOLCDFB_SIZE);\n\tdata->fb_info = info;\n\n\terror = picolcd_fb_reset(data, 1);\n\tif (error) {\n\t\tdev_err(dev, \"failed to configure display\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\terror = device_create_file(dev, &dev_attr_fb_update_rate);\n\tif (error) {\n\t\tdev_err(dev, \"failed to create sysfs attributes\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\tfb_deferred_io_init(info);\n\terror = register_framebuffer(info);\n\tif (error) {\n\t\tdev_err(dev, \"failed to register framebuffer\\n\");\n\t\tgoto err_sysfs;\n\t}\n\treturn 0;\n\nerr_sysfs:\n\tdevice_remove_file(dev, &dev_attr_fb_update_rate);\n\tfb_deferred_io_cleanup(info);\nerr_cleanup:\n\tdata->fb_info    = NULL;\n\nerr_nomem:\n\tif (fbdata)\n\t\tvfree(fbdata->bitmap);\n\tframebuffer_release(info);\n\treturn error;\n}\n\nvoid picolcd_exit_framebuffer(struct picolcd_data *data)\n{\n\tstruct fb_info *info = data->fb_info;\n\tstruct picolcd_fb_data *fbdata;\n\tunsigned long flags;\n\n\tif (!info)\n\t\treturn;\n\n\tdevice_remove_file(&data->hdev->dev, &dev_attr_fb_update_rate);\n\tfbdata = info->par;\n\n\t \n\tspin_lock_irqsave(&fbdata->lock, flags);\n\tfbdata->picolcd = NULL;\n\tspin_unlock_irqrestore(&fbdata->lock, flags);\n\n\t \n\tflush_delayed_work(&info->deferred_work);\n\n\tdata->fb_info = NULL;\n\tunregister_framebuffer(info);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}