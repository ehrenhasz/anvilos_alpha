{
  "module_name": "hid-google-hammer.c",
  "hash_id": "9b5ed49af16bff8c5cf4a27ceff316ae9f1d6fe19795774756318706c0bfa6e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-google-hammer.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/acpi.h>\n#include <linux/hid.h>\n#include <linux/input/vivaldi-fmap.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeup.h>\n#include <asm/unaligned.h>\n\n#include \"hid-ids.h\"\n#include \"hid-vivaldi-common.h\"\n\n \nstruct cbas_ec {\n\tstruct device *dev;\t \n\tstruct input_dev *input;\n\tbool base_present;\n\tbool base_folded;\n\tstruct notifier_block notifier;\n};\n\nstatic struct cbas_ec cbas_ec;\nstatic DEFINE_SPINLOCK(cbas_ec_lock);\nstatic DEFINE_MUTEX(cbas_ec_reglock);\n\nstatic bool cbas_parse_base_state(const void *data)\n{\n\tu32 switches = get_unaligned_le32(data);\n\n\treturn !!(switches & BIT(EC_MKBP_BASE_ATTACHED));\n}\n\nstatic int cbas_ec_query_base(struct cros_ec_device *ec_dev, bool get_state,\n\t\t\t\t  bool *state)\n{\n\tstruct ec_params_mkbp_info *params;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kzalloc(struct_size(msg, data, max(sizeof(u32), sizeof(*params))),\n\t\t      GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_MKBP_INFO;\n\tmsg->version = 1;\n\tmsg->outsize = sizeof(*params);\n\tmsg->insize = sizeof(u32);\n\tparams = (struct ec_params_mkbp_info *)msg->data;\n\tparams->info_type = get_state ?\n\t\tEC_MKBP_INFO_CURRENT : EC_MKBP_INFO_SUPPORTED;\n\tparams->event_type = EC_MKBP_EVENT_SWITCH;\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, msg);\n\tif (ret >= 0) {\n\t\tif (ret != sizeof(u32)) {\n\t\t\tdev_warn(ec_dev->dev, \"wrong result size: %d != %zu\\n\",\n\t\t\t\t ret, sizeof(u32));\n\t\t\tret = -EPROTO;\n\t\t} else {\n\t\t\t*state = cbas_parse_base_state(msg->data);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tkfree(msg);\n\n\treturn ret;\n}\n\nstatic int cbas_ec_notify(struct notifier_block *nb,\n\t\t\t      unsigned long queued_during_suspend,\n\t\t\t      void *_notify)\n{\n\tstruct cros_ec_device *ec = _notify;\n\tunsigned long flags;\n\tbool base_present;\n\n\tif (ec->event_data.event_type == EC_MKBP_EVENT_SWITCH) {\n\t\tbase_present = cbas_parse_base_state(\n\t\t\t\t\t&ec->event_data.data.switches);\n\t\tdev_dbg(cbas_ec.dev,\n\t\t\t\"%s: base: %d\\n\", __func__, base_present);\n\n\t\tif (device_may_wakeup(cbas_ec.dev) ||\n\t\t    !queued_during_suspend) {\n\n\t\t\tpm_wakeup_event(cbas_ec.dev, 0);\n\n\t\t\tspin_lock_irqsave(&cbas_ec_lock, flags);\n\n\t\t\t \n\t\t\tif (base_present != cbas_ec.base_present) {\n\t\t\t\tinput_report_switch(cbas_ec.input,\n\t\t\t\t\t\t    SW_TABLET_MODE,\n\t\t\t\t\t\t    !base_present);\n\t\t\t\tinput_sync(cbas_ec.input);\n\t\t\t\tcbas_ec.base_present = base_present;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&cbas_ec_lock, flags);\n\t\t}\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic __maybe_unused int cbas_ec_resume(struct device *dev)\n{\n\tstruct cros_ec_device *ec = dev_get_drvdata(dev->parent);\n\tbool base_present;\n\tint error;\n\n\terror = cbas_ec_query_base(ec, true, &base_present);\n\tif (error) {\n\t\tdev_warn(dev, \"failed to fetch base state on resume: %d\\n\",\n\t\t\t error);\n\t} else {\n\t\tspin_lock_irq(&cbas_ec_lock);\n\n\t\tcbas_ec.base_present = base_present;\n\n\t\t \n\t\tif (!cbas_ec.base_present) {\n\t\t\tinput_report_switch(cbas_ec.input, SW_TABLET_MODE, 1);\n\t\t\tinput_sync(cbas_ec.input);\n\t\t}\n\n\t\tspin_unlock_irq(&cbas_ec_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cbas_ec_pm_ops, NULL, cbas_ec_resume);\n\nstatic void cbas_ec_set_input(struct input_dev *input)\n{\n\t \n\tspin_lock_irq(&cbas_ec_lock);\n\tcbas_ec.input = input;\n\tspin_unlock_irq(&cbas_ec_lock);\n}\n\nstatic int __cbas_ec_probe(struct platform_device *pdev)\n{\n\tstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\n\tstruct input_dev *input;\n\tbool base_supported;\n\tint error;\n\n\terror = cbas_ec_query_base(ec, false, &base_supported);\n\tif (error)\n\t\treturn error;\n\n\tif (!base_supported)\n\t\treturn -ENXIO;\n\n\tinput = devm_input_allocate_device(&pdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"Whiskers Tablet Mode Switch\";\n\tinput->id.bustype = BUS_HOST;\n\n\tinput_set_capability(input, EV_SW, SW_TABLET_MODE);\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"cannot register input device: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\terror = cbas_ec_query_base(ec, true, &cbas_ec.base_present);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"cannot query base state: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (!cbas_ec.base_present)\n\t\tcbas_ec.base_folded = false;\n\n\tdev_dbg(&pdev->dev, \"%s: base: %d, folded: %d\\n\", __func__,\n\t\tcbas_ec.base_present, cbas_ec.base_folded);\n\n\tinput_report_switch(input, SW_TABLET_MODE,\n\t\t\t    !cbas_ec.base_present || cbas_ec.base_folded);\n\n\tcbas_ec_set_input(input);\n\n\tcbas_ec.dev = &pdev->dev;\n\tcbas_ec.notifier.notifier_call = cbas_ec_notify;\n\terror = blocking_notifier_chain_register(&ec->event_notifier,\n\t\t\t\t\t\t &cbas_ec.notifier);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"cannot register notifier: %d\\n\", error);\n\t\tcbas_ec_set_input(NULL);\n\t\treturn error;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\treturn 0;\n}\n\nstatic int cbas_ec_probe(struct platform_device *pdev)\n{\n\tint retval;\n\n\tmutex_lock(&cbas_ec_reglock);\n\n\tif (cbas_ec.input) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tretval = __cbas_ec_probe(pdev);\n\nout:\n\tmutex_unlock(&cbas_ec_reglock);\n\treturn retval;\n}\n\nstatic int cbas_ec_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\n\n\tmutex_lock(&cbas_ec_reglock);\n\n\tblocking_notifier_chain_unregister(&ec->event_notifier,\n\t\t\t\t\t   &cbas_ec.notifier);\n\tcbas_ec_set_input(NULL);\n\n\tmutex_unlock(&cbas_ec_reglock);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id cbas_ec_acpi_ids[] = {\n\t{ \"GOOG000B\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cbas_ec_acpi_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cbas_ec_of_match[] = {\n\t{ .compatible = \"google,cros-cbas\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, cbas_ec_of_match);\n#endif\n\nstatic struct platform_driver cbas_ec_driver = {\n\t.probe = cbas_ec_probe,\n\t.remove = cbas_ec_remove,\n\t.driver = {\n\t\t.name = \"cbas_ec\",\n\t\t.acpi_match_table = ACPI_PTR(cbas_ec_acpi_ids),\n\t\t.of_match_table = of_match_ptr(cbas_ec_of_match),\n\t\t.pm = &cbas_ec_pm_ops,\n\t},\n};\n\n#define MAX_BRIGHTNESS 100\n\nstruct hammer_kbd_leds {\n\tstruct led_classdev cdev;\n\tstruct hid_device *hdev;\n\tu8 buf[2] ____cacheline_aligned;\n};\n\nstatic int hammer_kbd_brightness_set_blocking(struct led_classdev *cdev,\n\t\tenum led_brightness br)\n{\n\tstruct hammer_kbd_leds *led = container_of(cdev,\n\t\t\t\t\t\t   struct hammer_kbd_leds,\n\t\t\t\t\t\t   cdev);\n\tint ret;\n\n\tled->buf[0] = 0;\n\tled->buf[1] = br;\n\n\t \n\tret = hid_hw_power(led->hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(led->hdev, \"failed: device not resumed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_output_report(led->hdev, led->buf, sizeof(led->buf));\n\tif (ret == -ENOSYS)\n\t\tret = hid_hw_raw_request(led->hdev, 0, led->buf,\n\t\t\t\t\t sizeof(led->buf),\n\t\t\t\t\t HID_OUTPUT_REPORT,\n\t\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(led->hdev, \"failed to set keyboard backlight: %d\\n\",\n\t\t\tret);\n\n\t \n\thid_hw_power(led->hdev, PM_HINT_NORMAL);\n\n\treturn ret;\n}\n\nstatic int hammer_register_leds(struct hid_device *hdev)\n{\n\tstruct hammer_kbd_leds *kbd_backlight;\n\n\tkbd_backlight = devm_kzalloc(&hdev->dev, sizeof(*kbd_backlight),\n\t\t\t\t     GFP_KERNEL);\n\tif (!kbd_backlight)\n\t\treturn -ENOMEM;\n\n\tkbd_backlight->hdev = hdev;\n\tkbd_backlight->cdev.name = \"hammer::kbd_backlight\";\n\tkbd_backlight->cdev.max_brightness = MAX_BRIGHTNESS;\n\tkbd_backlight->cdev.brightness_set_blocking =\n\t\thammer_kbd_brightness_set_blocking;\n\tkbd_backlight->cdev.flags = LED_HW_PLUGGABLE;\n\n\t \n\thammer_kbd_brightness_set_blocking(&kbd_backlight->cdev, 0);\n\n\treturn devm_led_classdev_register(&hdev->dev, &kbd_backlight->cdev);\n}\n\n#define HID_UP_GOOGLEVENDOR\t0xffd10000\n#define HID_VD_KBD_FOLDED\t0x00000019\n#define HID_USAGE_KBD_FOLDED\t(HID_UP_GOOGLEVENDOR | HID_VD_KBD_FOLDED)\n\n \n#define HID_AD_BRIGHTNESS\t0x00140046\n\nstatic int hammer_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t\tstruct hid_field *field,\n\t\t\t\tstruct hid_usage *usage,\n\t\t\t\tunsigned long **bit, int *max)\n{\n\tif (usage->hid == HID_USAGE_KBD_FOLDED) {\n\t\t \n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void hammer_folded_event(struct hid_device *hdev, bool folded)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cbas_ec_lock, flags);\n\n\t \n\tcbas_ec.base_present = true;\n\tcbas_ec.base_folded = folded;\n\thid_dbg(hdev, \"%s: base: %d, folded: %d\\n\", __func__,\n\t\tcbas_ec.base_present, cbas_ec.base_folded);\n\n\tif (cbas_ec.input) {\n\t\tinput_report_switch(cbas_ec.input, SW_TABLET_MODE, folded);\n\t\tinput_sync(cbas_ec.input);\n\t}\n\n\tspin_unlock_irqrestore(&cbas_ec_lock, flags);\n}\n\nstatic int hammer_event(struct hid_device *hid, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, __s32 value)\n{\n\tif (usage->hid == HID_USAGE_KBD_FOLDED) {\n\t\thammer_folded_event(hid, value);\n\t\treturn 1;  \n\t}\n\n\treturn 0;\n}\n\nstatic bool hammer_has_usage(struct hid_device *hdev, unsigned int report_type,\n\t\t\tunsigned application, unsigned usage)\n{\n\tstruct hid_report_enum *re = &hdev->report_enum[report_type];\n\tstruct hid_report *report;\n\tint i, j;\n\n\tlist_for_each_entry(report, &re->report_list, list) {\n\t\tif (report->application != application)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\tstruct hid_field *field = report->field[i];\n\n\t\t\tfor (j = 0; j < field->maxusage; j++)\n\t\t\t\tif (field->usage[j].hid == usage)\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool hammer_has_folded_event(struct hid_device *hdev)\n{\n\treturn hammer_has_usage(hdev, HID_INPUT_REPORT,\n\t\t\t\tHID_GD_KEYBOARD, HID_USAGE_KBD_FOLDED);\n}\n\nstatic bool hammer_has_backlight_control(struct hid_device *hdev)\n{\n\treturn hammer_has_usage(hdev, HID_OUTPUT_REPORT,\n\t\t\t\tHID_GD_KEYBOARD, HID_AD_BRIGHTNESS);\n}\n\nstatic void hammer_get_folded_state(struct hid_device *hdev)\n{\n\tstruct hid_report *report;\n\tchar *buf;\n\tint len, rlen;\n\tint a;\n\n\treport = hdev->report_enum[HID_INPUT_REPORT].report_id_hash[0x0];\n\n\tif (!report || report->maxfield < 1)\n\t\treturn;\n\n\tlen = hid_report_len(report) + 1;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\trlen = hid_hw_raw_request(hdev, report->id, buf, len, report->type, HID_REQ_GET_REPORT);\n\n\tif (rlen != len) {\n\t\thid_warn(hdev, \"Unable to read base folded state: %d (expected %d)\\n\", rlen, len);\n\t\tgoto out;\n\t}\n\n\tfor (a = 0; a < report->maxfield; a++) {\n\t\tstruct hid_field *field = report->field[a];\n\n\t\tif (field->usage->hid == HID_USAGE_KBD_FOLDED) {\n\t\t\tu32 value = hid_field_extract(hdev, buf+1,\n\t\t\t\t\tfield->report_offset, field->report_size);\n\n\t\t\thammer_folded_event(hdev, value);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(buf);\n}\n\nstatic void hammer_stop(void *hdev)\n{\n\thid_hw_stop(hdev);\n}\n\nstatic int hammer_probe(struct hid_device *hdev,\n\t\t\tconst struct hid_device_id *id)\n{\n\tstruct vivaldi_data *vdata;\n\tint error;\n\n\tvdata = devm_kzalloc(&hdev->dev, sizeof(*vdata), GFP_KERNEL);\n\tif (!vdata)\n\t\treturn -ENOMEM;\n\n\thid_set_drvdata(hdev, vdata);\n\n\terror = hid_parse(hdev);\n\tif (error)\n\t\treturn error;\n\n\terror = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (error)\n\t\treturn error;\n\n\terror = devm_add_action(&hdev->dev, hammer_stop, hdev);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (hammer_has_folded_event(hdev)) {\n\t\thdev->quirks |= HID_QUIRK_ALWAYS_POLL;\n\t\terror = hid_hw_open(hdev);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thammer_get_folded_state(hdev);\n\t}\n\n\tif (hammer_has_backlight_control(hdev)) {\n\t\terror = hammer_register_leds(hdev);\n\t\tif (error)\n\t\t\thid_warn(hdev,\n\t\t\t\t\"Failed to register keyboard backlight: %d\\n\",\n\t\t\t\terror);\n\t}\n\n\treturn 0;\n}\n\nstatic void hammer_remove(struct hid_device *hdev)\n{\n\tunsigned long flags;\n\n\tif (hammer_has_folded_event(hdev)) {\n\t\thid_hw_close(hdev);\n\n\t\t \n\t\tspin_lock_irqsave(&cbas_ec_lock, flags);\n\t\tif (cbas_ec.input && cbas_ec.base_present) {\n\t\t\tinput_report_switch(cbas_ec.input, SW_TABLET_MODE, 1);\n\t\t\tinput_sync(cbas_ec.input);\n\t\t}\n\t\tcbas_ec.base_present = false;\n\t\tspin_unlock_irqrestore(&cbas_ec_lock, flags);\n\t}\n\n\t \n}\n\nstatic const struct hid_device_id hammer_devices[] = {\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_DON) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_VIVALDI,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_EEL) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_HAMMER) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_JEWEL) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_MAGNEMITE) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_MASTERBALL) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_MOONBALL) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_STAFF) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_WAND) },\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_WHISKERS) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, hammer_devices);\n\nstatic struct hid_driver hammer_driver = {\n\t.name = \"hammer\",\n\t.id_table = hammer_devices,\n\t.probe = hammer_probe,\n\t.remove = hammer_remove,\n\t.feature_mapping = vivaldi_feature_mapping,\n\t.input_mapping = hammer_input_mapping,\n\t.event = hammer_event,\n\t.driver = {\n\t\t.dev_groups = vivaldi_attribute_groups,\n\t},\n};\n\nstatic int __init hammer_init(void)\n{\n\tint error;\n\n\terror = platform_driver_register(&cbas_ec_driver);\n\tif (error)\n\t\treturn error;\n\n\terror = hid_register_driver(&hammer_driver);\n\tif (error) {\n\t\tplatform_driver_unregister(&cbas_ec_driver);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\nmodule_init(hammer_init);\n\nstatic void __exit hammer_exit(void)\n{\n\thid_unregister_driver(&hammer_driver);\n\tplatform_driver_unregister(&cbas_ec_driver);\n}\nmodule_exit(hammer_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}