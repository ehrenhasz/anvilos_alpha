{
  "module_name": "hid-uclogic-core.c",
  "hash_id": "0cbf849a4d508455fee3dce30cc932d940f2ff88cf4bf920ac16033acef92f65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-uclogic-core.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include \"usbhid/usbhid.h\"\n#include \"hid-uclogic-params.h\"\n\n#include \"hid-ids.h\"\n\n \nstatic void uclogic_inrange_timeout(struct timer_list *t)\n{\n\tstruct uclogic_drvdata *drvdata = from_timer(drvdata, t,\n\t\t\t\t\t\t\tinrange_timer);\n\tstruct input_dev *input = drvdata->pen_input;\n\n\tif (input == NULL)\n\t\treturn;\n\tinput_report_abs(input, ABS_PRESSURE, 0);\n\t \n\tif (test_bit(BTN_TOUCH, input->key)) {\n\t\tinput_event(input, EV_MSC, MSC_SCAN,\n\t\t\t\t \n\t\t\t\t0xd0042);\n\t\tinput_report_key(input, BTN_TOUCH, 0);\n\t}\n\tinput_report_key(input, BTN_TOOL_PEN, 0);\n\tinput_sync(input);\n}\n\nstatic __u8 *uclogic_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\t\t\t\tunsigned int *rsize)\n{\n\tstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tif (drvdata->desc_ptr != NULL) {\n\t\trdesc = drvdata->desc_ptr;\n\t\t*rsize = drvdata->desc_size;\n\t}\n\treturn rdesc;\n}\n\nstatic int uclogic_input_mapping(struct hid_device *hdev,\n\t\t\t\t struct hid_input *hi,\n\t\t\t\t struct hid_field *field,\n\t\t\t\t struct hid_usage *usage,\n\t\t\t\t unsigned long **bit,\n\t\t\t\t int *max)\n{\n\tstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\n\tstruct uclogic_params *params = &drvdata->params;\n\n\t \n\tif (params->pen.usage_invalid && (field->application == HID_DG_PEN))\n\t\treturn -1;\n\n\t \n\treturn 0;\n}\n\nstatic int uclogic_input_configured(struct hid_device *hdev,\n\t\tstruct hid_input *hi)\n{\n\tstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\n\tstruct uclogic_params *params = &drvdata->params;\n\tconst char *suffix = NULL;\n\tstruct hid_field *field;\n\tsize_t i;\n\tconst struct uclogic_params_frame *frame;\n\n\t \n\tif (!hi->report)\n\t\treturn 0;\n\n\t \n\tif (hi->report->id == params->pen.id) {\n\t\t \n\t\tdrvdata->pen_input = hi->input;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(params->frame_list); i++) {\n\t\tframe = &params->frame_list[i];\n\t\tif (hi->report->id == frame->id) {\n\t\t\t \n\t\t\tsuffix = frame->suffix;\n\t\t\t \n\t\t\tif (frame->touch_byte > 0)\n\t\t\t\t__clear_bit(EV_MSC, hi->input->evbit);\n\t\t}\n\t}\n\n\tif (!suffix) {\n\t\tfield = hi->report->field[0];\n\n\t\tswitch (field->application) {\n\t\tcase HID_GD_KEYBOARD:\n\t\t\tsuffix = \"Keyboard\";\n\t\t\tbreak;\n\t\tcase HID_GD_MOUSE:\n\t\t\tsuffix = \"Mouse\";\n\t\t\tbreak;\n\t\tcase HID_GD_KEYPAD:\n\t\t\tsuffix = \"Pad\";\n\t\t\tbreak;\n\t\tcase HID_DG_PEN:\n\t\tcase HID_DG_DIGITIZER:\n\t\t\tsuffix = \"Pen\";\n\t\t\tbreak;\n\t\tcase HID_CP_CONSUMER_CONTROL:\n\t\t\tsuffix = \"Consumer Control\";\n\t\t\tbreak;\n\t\tcase HID_GD_SYSTEM_CONTROL:\n\t\t\tsuffix = \"System Control\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (suffix)\n\t\thi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t \"%s %s\", hdev->name, suffix);\n\n\treturn 0;\n}\n\nstatic int uclogic_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint rc;\n\tstruct uclogic_drvdata *drvdata = NULL;\n\tbool params_initialized = false;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\t \n\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\thdev->quirks |= HID_QUIRK_HIDINPUT_FORCE;\n\n\t \n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto failure;\n\t}\n\ttimer_setup(&drvdata->inrange_timer, uclogic_inrange_timeout, 0);\n\tdrvdata->re_state = U8_MAX;\n\tdrvdata->quirks = id->driver_data;\n\thid_set_drvdata(hdev, drvdata);\n\n\t \n\trc = uclogic_params_init(&drvdata->params, hdev);\n\tif (rc != 0) {\n\t\thid_err(hdev, \"failed probing parameters: %d\\n\", rc);\n\t\tgoto failure;\n\t}\n\tparams_initialized = true;\n\thid_dbg(hdev, \"parameters:\\n\");\n\tuclogic_params_hid_dbg(hdev, &drvdata->params);\n\tif (drvdata->params.invalid) {\n\t\thid_info(hdev, \"interface is invalid, ignoring\\n\");\n\t\trc = -ENODEV;\n\t\tgoto failure;\n\t}\n\n\t \n\trc = uclogic_params_get_desc(&drvdata->params,\n\t\t\t\t     &drvdata->desc_ptr,\n\t\t\t\t     &drvdata->desc_size);\n\tif (rc) {\n\t\thid_err(hdev,\n\t\t\t\"failed generating replacement report descriptor: %d\\n\",\n\t\t\trc);\n\t\tgoto failure;\n\t}\n\n\trc = hid_parse(hdev);\n\tif (rc) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto failure;\n\t}\n\n\trc = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (rc) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto failure;\n\t}\n\n\treturn 0;\nfailure:\n\t \n\tif (params_initialized)\n\t\tuclogic_params_cleanup(&drvdata->params);\n\treturn rc;\n}\n\n#ifdef CONFIG_PM\nstatic int uclogic_resume(struct hid_device *hdev)\n{\n\tint rc;\n\tstruct uclogic_params params;\n\n\t \n\trc = uclogic_params_init(&params, hdev);\n\tif (rc != 0)\n\t\thid_err(hdev, \"failed to re-initialize the device\\n\");\n\telse\n\t\tuclogic_params_cleanup(&params);\n\n\treturn rc;\n}\n#endif\n\n \nstatic bool uclogic_exec_event_hook(struct uclogic_params *p, u8 *event, int size)\n{\n\tstruct uclogic_raw_event_hook *curr;\n\n\tif (!p->event_hooks)\n\t\treturn false;\n\n\tlist_for_each_entry(curr, &p->event_hooks->list, list) {\n\t\tif (curr->size == size && memcmp(curr->event, event, size) == 0) {\n\t\t\tschedule_work(&curr->work);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic int uclogic_raw_event_pen(struct uclogic_drvdata *drvdata,\n\t\t\t\t\tu8 *data, int size)\n{\n\tstruct uclogic_params_pen *pen = &drvdata->params.pen;\n\n\tWARN_ON(drvdata == NULL);\n\tWARN_ON(data == NULL && size != 0);\n\n\t \n\tif (pen->inrange ==\n\t\tUCLOGIC_PARAMS_PEN_INRANGE_INVERTED) {\n\t\t \n\t\tdata[1] ^= 0x40;\n\t}\n\t \n\tif (size >= 10 && pen->fragmented_hires) {\n\t\tu8 pressure_low_byte;\n\t\tu8 pressure_high_byte;\n\n\t\t \n\t\tpressure_low_byte = data[6];\n\t\tpressure_high_byte = data[7];\n\t\t \n\t\tdata[6] = data[5];\n\t\tdata[5] = data[4];\n\t\t \n\t\tdata[4] = data[8];\n\t\t \n\t\tdata[7] = data[9];\n\t\t \n\t\tdata[8] = pressure_low_byte;\n\t\tdata[9] = pressure_high_byte;\n\t}\n\t \n\tif (pen->inrange == UCLOGIC_PARAMS_PEN_INRANGE_NONE) {\n\t\t \n\t\tdata[1] |= 0x40;\n\t\t \n\t\tmod_timer(&drvdata->inrange_timer,\n\t\t\t\tjiffies + msecs_to_jiffies(100));\n\t}\n\t \n\tif (size >= 12 && pen->tilt_y_flipped)\n\t\tdata[11] = -data[11];\n\n\treturn 0;\n}\n\n \nstatic int uclogic_raw_event_frame(\n\t\tstruct uclogic_drvdata *drvdata,\n\t\tconst struct uclogic_params_frame *frame,\n\t\tu8 *data, int size)\n{\n\tWARN_ON(drvdata == NULL);\n\tWARN_ON(data == NULL && size != 0);\n\n\t \n\tif (frame->dev_id_byte > 0 && frame->dev_id_byte < size) {\n\t\t \n\t\tif (frame->touch_byte > 0 && frame->touch_byte < size &&\n\t\t    data[frame->touch_byte] == 0) {\n\t\t\tdata[frame->dev_id_byte] = 0;\n\t\t} else {\n\t\t\tdata[frame->dev_id_byte] = 0xf;\n\t\t}\n\t}\n\n\t \n\tif (frame->re_lsb > 0 && frame->re_lsb / 8 < size) {\n\t\tunsigned int byte = frame->re_lsb / 8;\n\t\tunsigned int bit = frame->re_lsb % 8;\n\n\t\tu8 change;\n\t\tu8 prev_state = drvdata->re_state;\n\t\t \n\t\tu8 state = (data[byte] >> bit) & 0x3;\n\t\t \n\t\tif ((prev_state == 1 && state == 0) ||\n\t\t    (prev_state == 2 && state == 3)) {\n\t\t\tchange = 1;\n\t\t} else if ((prev_state == 2 && state == 0) ||\n\t\t\t   (prev_state == 1 && state == 3)) {\n\t\t\tchange = 3;\n\t\t} else {\n\t\t\tchange = 0;\n\t\t}\n\t\t \n\t\tdata[byte] = (data[byte] & ~((u8)3 << bit)) |\n\t\t\t\t(change << bit);\n\t\t \n\t\tdrvdata->re_state = state;\n\t}\n\n\t \n\tif (frame->touch_byte > 0 && frame->touch_byte < size) {\n\t\t__s8 value = data[frame->touch_byte];\n\n\t\tif (value != 0) {\n\t\t\tif (frame->touch_flip_at != 0) {\n\t\t\t\tvalue = frame->touch_flip_at - value;\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tvalue = frame->touch_max + value;\n\t\t\t}\n\t\t\tdata[frame->touch_byte] = value - 1;\n\t\t}\n\t}\n\n\t \n\tif (frame->bitmap_dial_byte > 0 && frame->bitmap_dial_byte < size) {\n\t\tif (data[frame->bitmap_dial_byte] == 2)\n\t\t\tdata[frame->bitmap_dial_byte] = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int uclogic_raw_event(struct hid_device *hdev,\n\t\t\t\tstruct hid_report *report,\n\t\t\t\tu8 *data, int size)\n{\n\tunsigned int report_id = report->id;\n\tstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\n\tstruct uclogic_params *params = &drvdata->params;\n\tstruct uclogic_params_pen_subreport *subreport;\n\tstruct uclogic_params_pen_subreport *subreport_list_end;\n\tsize_t i;\n\n\t \n\tif (report->type != HID_INPUT_REPORT)\n\t\treturn 0;\n\n\tif (uclogic_exec_event_hook(params, data, size))\n\t\treturn 0;\n\n\twhile (true) {\n\t\t \n\t\tif ((report_id == params->pen.id) && (size >= 2)) {\n\t\t\tsubreport_list_end =\n\t\t\t\tparams->pen.subreport_list +\n\t\t\t\tARRAY_SIZE(params->pen.subreport_list);\n\t\t\t \n\t\t\tfor (subreport = params->pen.subreport_list;\n\t\t\t     subreport < subreport_list_end; subreport++) {\n\t\t\t\tif (subreport->value != 0 &&\n\t\t\t\t    subreport->value == data[1]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (subreport < subreport_list_end) {\n\t\t\t\t \n\t\t\t\treport_id = data[0] = subreport->id;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn uclogic_raw_event_pen(drvdata, data, size);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(params->frame_list); i++) {\n\t\t\tif (report_id == params->frame_list[i].id) {\n\t\t\t\treturn uclogic_raw_event_frame(\n\t\t\t\t\tdrvdata, &params->frame_list[i],\n\t\t\t\t\tdata, size);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void uclogic_remove(struct hid_device *hdev)\n{\n\tstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tdel_timer_sync(&drvdata->inrange_timer);\n\thid_hw_stop(hdev);\n\tkfree(drvdata->desc_ptr);\n\tuclogic_params_cleanup(&drvdata->params);\n}\n\nstatic const struct hid_device_id uclogic_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_TABLET_PF1209) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_TABLET_WP4030U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_TABLET_WP5540U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_TABLET_WP8060U) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_TABLET_WP1062) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_TABLET_TWHA60) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HUION,\n\t\t\t\tUSB_DEVICE_ID_HUION_TABLET) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_HUION,\n\t\t\t\tUSB_DEVICE_ID_HUION_TABLET2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TRUST,\n\t\t\t\tUSB_DEVICE_ID_TRUST_PANORA_TABLET) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_HUION_TABLET) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_YIYNOVA_TABLET) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC,\n\t\t\t\tUSB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGTIZER,\n\t\t\t\tUSB_DEVICE_ID_UGTIZER_TABLET_GP0610) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGTIZER,\n\t\t\t\tUSB_DEVICE_ID_UGTIZER_TABLET_GT5040) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_PARBLO_A610_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_TABLET_G5) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_TABLET_EX07S) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_G540) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_G640) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01_V2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_L) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_MW),\n\t\t.driver_data = UCLOGIC_MOUSE_FRAME_QUIRK | UCLOGIC_BATTERY_QUIRK },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_S) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_SW),\n\t\t.driver_data = UCLOGIC_MOUSE_FRAME_QUIRK | UCLOGIC_BATTERY_QUIRK },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE,\n\t\t\t\tUSB_DEVICE_ID_UGEE_XPPEN_TABLET_STAR06) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, uclogic_devices);\n\nstatic struct hid_driver uclogic_driver = {\n\t.name = \"uclogic\",\n\t.id_table = uclogic_devices,\n\t.probe = uclogic_probe,\n\t.remove = uclogic_remove,\n\t.report_fixup = uclogic_report_fixup,\n\t.raw_event = uclogic_raw_event,\n\t.input_mapping = uclogic_input_mapping,\n\t.input_configured = uclogic_input_configured,\n#ifdef CONFIG_PM\n\t.resume\t          = uclogic_resume,\n\t.reset_resume     = uclogic_resume,\n#endif\n};\nmodule_hid_driver(uclogic_driver);\n\nMODULE_AUTHOR(\"Martin Rusko\");\nMODULE_AUTHOR(\"Nikolai Kondrashov\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef CONFIG_HID_KUNIT_TEST\n#include \"hid-uclogic-core-test.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}