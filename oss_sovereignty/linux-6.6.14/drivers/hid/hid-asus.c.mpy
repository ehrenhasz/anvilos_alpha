{
  "module_name": "hid-asus.c",
  "hash_id": "d92b82ebf2857017006cf26d8d72d974ea5964d780e075d49919aa4fa0808760",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-asus.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/dmi.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/platform_data/x86/asus-wmi.h>\n#include <linux/input/mt.h>\n#include <linux/usb.h>  \n#include <linux/power_supply.h>\n#include <linux/leds.h>\n\n#include \"hid-ids.h\"\n\nMODULE_AUTHOR(\"Yusuke Fujimaki <usk.fujimaki@gmail.com>\");\nMODULE_AUTHOR(\"Brendan McGrath <redmcg@redmandi.dyndns.org>\");\nMODULE_AUTHOR(\"Victor Vlasenko <victor.vlasenko@sysgears.com>\");\nMODULE_AUTHOR(\"Frederik Wenigwieser <frederik.wenigwieser@gmail.com>\");\nMODULE_DESCRIPTION(\"Asus HID Keyboard and TouchPad\");\n\n#define T100_TPAD_INTF 2\n#define MEDION_E1239T_TPAD_INTF 1\n\n#define E1239T_TP_TOGGLE_REPORT_ID 0x05\n#define T100CHI_MOUSE_REPORT_ID 0x06\n#define FEATURE_REPORT_ID 0x0d\n#define INPUT_REPORT_ID 0x5d\n#define FEATURE_KBD_REPORT_ID 0x5a\n#define FEATURE_KBD_REPORT_SIZE 16\n#define FEATURE_KBD_LED_REPORT_ID1 0x5d\n#define FEATURE_KBD_LED_REPORT_ID2 0x5e\n\n#define SUPPORT_KBD_BACKLIGHT BIT(0)\n\n#define MAX_TOUCH_MAJOR 8\n#define MAX_PRESSURE 128\n\n#define BTN_LEFT_MASK 0x01\n#define CONTACT_TOOL_TYPE_MASK 0x80\n#define CONTACT_X_MSB_MASK 0xf0\n#define CONTACT_Y_MSB_MASK 0x0f\n#define CONTACT_TOUCH_MAJOR_MASK 0x07\n#define CONTACT_PRESSURE_MASK 0x7f\n\n#define\tBATTERY_REPORT_ID\t(0x03)\n#define\tBATTERY_REPORT_SIZE\t(1 + 8)\n#define\tBATTERY_LEVEL_MAX\t((u8)255)\n#define\tBATTERY_STAT_DISCONNECT\t(0)\n#define\tBATTERY_STAT_CHARGING\t(1)\n#define\tBATTERY_STAT_FULL\t(2)\n\n#define QUIRK_FIX_NOTEBOOK_REPORT\tBIT(0)\n#define QUIRK_NO_INIT_REPORTS\t\tBIT(1)\n#define QUIRK_SKIP_INPUT_MAPPING\tBIT(2)\n#define QUIRK_IS_MULTITOUCH\t\tBIT(3)\n#define QUIRK_NO_CONSUMER_USAGES\tBIT(4)\n#define QUIRK_USE_KBD_BACKLIGHT\t\tBIT(5)\n#define QUIRK_T100_KEYBOARD\t\tBIT(6)\n#define QUIRK_T100CHI\t\t\tBIT(7)\n#define QUIRK_G752_KEYBOARD\t\tBIT(8)\n#define QUIRK_T90CHI\t\t\tBIT(9)\n#define QUIRK_MEDION_E1239T\t\tBIT(10)\n#define QUIRK_ROG_NKEY_KEYBOARD\t\tBIT(11)\n#define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)\n\n#define I2C_KEYBOARD_QUIRKS\t\t\t(QUIRK_FIX_NOTEBOOK_REPORT | \\\n\t\t\t\t\t\t QUIRK_NO_INIT_REPORTS | \\\n\t\t\t\t\t\t QUIRK_NO_CONSUMER_USAGES)\n#define I2C_TOUCHPAD_QUIRKS\t\t\t(QUIRK_NO_INIT_REPORTS | \\\n\t\t\t\t\t\t QUIRK_SKIP_INPUT_MAPPING | \\\n\t\t\t\t\t\t QUIRK_IS_MULTITOUCH)\n\n#define TRKID_SGN       ((TRKID_MAX + 1) >> 1)\n\nstruct asus_kbd_leds {\n\tstruct led_classdev cdev;\n\tstruct hid_device *hdev;\n\tstruct work_struct work;\n\tunsigned int brightness;\n\tspinlock_t lock;\n\tbool removed;\n};\n\nstruct asus_touchpad_info {\n\tint max_x;\n\tint max_y;\n\tint res_x;\n\tint res_y;\n\tint contact_size;\n\tint max_contacts;\n\tint report_size;\n};\n\nstruct asus_drvdata {\n\tunsigned long quirks;\n\tstruct hid_device *hdev;\n\tstruct input_dev *input;\n\tstruct input_dev *tp_kbd_input;\n\tstruct asus_kbd_leds *kbd_backlight;\n\tconst struct asus_touchpad_info *tp;\n\tbool enable_backlight;\n\tstruct power_supply *battery;\n\tstruct power_supply_desc battery_desc;\n\tint battery_capacity;\n\tint battery_stat;\n\tbool battery_in_query;\n\tunsigned long battery_next_query;\n};\n\nstatic int asus_report_battery(struct asus_drvdata *, u8 *, int);\n\nstatic const struct asus_touchpad_info asus_i2c_tp = {\n\t.max_x = 2794,\n\t.max_y = 1758,\n\t.contact_size = 5,\n\t.max_contacts = 5,\n\t.report_size = 28  ,\n};\n\nstatic const struct asus_touchpad_info asus_t100ta_tp = {\n\t.max_x = 2240,\n\t.max_y = 1120,\n\t.res_x = 30,  \n\t.res_y = 27,  \n\t.contact_size = 5,\n\t.max_contacts = 5,\n\t.report_size = 28  ,\n};\n\nstatic const struct asus_touchpad_info asus_t100ha_tp = {\n\t.max_x = 2640,\n\t.max_y = 1320,\n\t.res_x = 30,  \n\t.res_y = 29,  \n\t.contact_size = 5,\n\t.max_contacts = 5,\n\t.report_size = 28  ,\n};\n\nstatic const struct asus_touchpad_info asus_t200ta_tp = {\n\t.max_x = 3120,\n\t.max_y = 1716,\n\t.res_x = 30,  \n\t.res_y = 28,  \n\t.contact_size = 5,\n\t.max_contacts = 5,\n\t.report_size = 28  ,\n};\n\nstatic const struct asus_touchpad_info asus_t100chi_tp = {\n\t.max_x = 2640,\n\t.max_y = 1320,\n\t.res_x = 31,  \n\t.res_y = 29,  \n\t.contact_size = 3,\n\t.max_contacts = 4,\n\t.report_size = 15  ,\n};\n\nstatic const struct asus_touchpad_info medion_e1239t_tp = {\n\t.max_x = 2640,\n\t.max_y = 1380,\n\t.res_x = 29,  \n\t.res_y = 28,  \n\t.contact_size = 5,\n\t.max_contacts = 5,\n\t.report_size = 32  ,\n};\n\nstatic void asus_report_contact_down(struct asus_drvdata *drvdat,\n\t\tint toolType, u8 *data)\n{\n\tstruct input_dev *input = drvdat->input;\n\tint touch_major, pressure, x, y;\n\n\tx = (data[0] & CONTACT_X_MSB_MASK) << 4 | data[1];\n\ty = drvdat->tp->max_y - ((data[0] & CONTACT_Y_MSB_MASK) << 8 | data[2]);\n\n\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\n\tif (drvdat->tp->contact_size < 5)\n\t\treturn;\n\n\tif (toolType == MT_TOOL_PALM) {\n\t\ttouch_major = MAX_TOUCH_MAJOR;\n\t\tpressure = MAX_PRESSURE;\n\t} else {\n\t\ttouch_major = (data[3] >> 4) & CONTACT_TOUCH_MAJOR_MASK;\n\t\tpressure = data[4] & CONTACT_PRESSURE_MASK;\n\t}\n\n\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, touch_major);\n\tinput_report_abs(input, ABS_MT_PRESSURE, pressure);\n}\n\n \nstatic void asus_report_tool_width(struct asus_drvdata *drvdat)\n{\n\tstruct input_mt *mt = drvdat->input->mt;\n\tstruct input_mt_slot *oldest;\n\tint oldid, i;\n\n\tif (drvdat->tp->contact_size < 5)\n\t\treturn;\n\n\toldest = NULL;\n\toldid = mt->trkid;\n\n\tfor (i = 0; i < mt->num_slots; ++i) {\n\t\tstruct input_mt_slot *ps = &mt->slots[i];\n\t\tint id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);\n\n\t\tif (id < 0)\n\t\t\tcontinue;\n\t\tif ((id - oldid) & TRKID_SGN) {\n\t\t\toldest = ps;\n\t\t\toldid = id;\n\t\t}\n\t}\n\n\tif (oldest) {\n\t\tinput_report_abs(drvdat->input, ABS_TOOL_WIDTH,\n\t\t\tinput_mt_get_value(oldest, ABS_MT_TOUCH_MAJOR));\n\t}\n}\n\nstatic int asus_report_input(struct asus_drvdata *drvdat, u8 *data, int size)\n{\n\tint i, toolType = MT_TOOL_FINGER;\n\tu8 *contactData = data + 2;\n\n\tif (size != drvdat->tp->report_size)\n\t\treturn 0;\n\n\tfor (i = 0; i < drvdat->tp->max_contacts; i++) {\n\t\tbool down = !!(data[1] & BIT(i+3));\n\n\t\tif (drvdat->tp->contact_size >= 5)\n\t\t\ttoolType = contactData[3] & CONTACT_TOOL_TYPE_MASK ?\n\t\t\t\t\t\tMT_TOOL_PALM : MT_TOOL_FINGER;\n\n\t\tinput_mt_slot(drvdat->input, i);\n\t\tinput_mt_report_slot_state(drvdat->input, toolType, down);\n\n\t\tif (down) {\n\t\t\tasus_report_contact_down(drvdat, toolType, contactData);\n\t\t\tcontactData += drvdat->tp->contact_size;\n\t\t}\n\t}\n\n\tinput_report_key(drvdat->input, BTN_LEFT, data[1] & BTN_LEFT_MASK);\n\tasus_report_tool_width(drvdat);\n\n\tinput_mt_sync_frame(drvdat->input);\n\tinput_sync(drvdat->input);\n\n\treturn 1;\n}\n\nstatic int asus_e1239t_event(struct asus_drvdata *drvdat, u8 *data, int size)\n{\n\tif (size != 3)\n\t\treturn 0;\n\n\t \n\tif (!drvdat->tp &&\n\t    data[0] == 0x02 && data[1] == 0xe2 && data[2] == 0x00) {\n\t\tinput_report_key(drvdat->input, KEY_MUTE, 1);\n\t\tinput_sync(drvdat->input);\n\t\tinput_report_key(drvdat->input, KEY_MUTE, 0);\n\t\tinput_sync(drvdat->input);\n\t\treturn 1;\n\t}\n\n\t \n\tif (drvdat->tp_kbd_input &&\n\t    data[0] == 0x05 && data[1] == 0x02 && data[2] == 0x28) {\n\t\tinput_report_key(drvdat->tp_kbd_input, KEY_F21, 1);\n\t\tinput_sync(drvdat->tp_kbd_input);\n\t\tinput_report_key(drvdat->tp_kbd_input, KEY_F21, 0);\n\t\tinput_sync(drvdat->tp_kbd_input);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int asus_event(struct hid_device *hdev, struct hid_field *field,\n\t\t      struct hid_usage *usage, __s32 value)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) == 0xff310000 &&\n\t    (usage->hid & HID_USAGE) != 0x00 &&\n\t    (usage->hid & HID_USAGE) != 0xff && !usage->type) {\n\t\thid_warn(hdev, \"Unmapped Asus vendor usagepage code 0x%02x\\n\",\n\t\t\t usage->hid & HID_USAGE);\n\t}\n\n\treturn 0;\n}\n\nstatic int asus_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tif (drvdata->battery && data[0] == BATTERY_REPORT_ID)\n\t\treturn asus_report_battery(drvdata, data, size);\n\n\tif (drvdata->tp && data[0] == INPUT_REPORT_ID)\n\t\treturn asus_report_input(drvdata, data, size);\n\n\tif (drvdata->quirks & QUIRK_MEDION_E1239T)\n\t\treturn asus_e1239t_event(drvdata, data, size);\n\n\tif (drvdata->quirks & QUIRK_USE_KBD_BACKLIGHT) {\n\t\t \n\t\tif (report->id == FEATURE_KBD_LED_REPORT_ID1 ||\n\t\t\t\treport->id == FEATURE_KBD_LED_REPORT_ID2) {\n\t\t\treturn -1;\n\t\t \n\t\t} else if (report->id == FEATURE_KBD_REPORT_ID) {\n\t\t\t \n\t\t\tif (data[1] == 0xea || data[1] == 0xec || data[1] == 0x02 ||\n\t\t\t\t\tdata[1] == 0x8a || data[1] == 0x9e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD) {\n\t\t\t \n\t\t\tif(data[0] == 0x02 && data[1] == 0x30) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (drvdata->quirks & QUIRK_ROG_CLAYMORE_II_KEYBOARD) {\n\t\t \n\n\t\tif(size == 2 && data[0] == 0x02 && data[1] == 0x00) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t buf_size)\n{\n\tunsigned char *dmabuf;\n\tint ret;\n\n\tdmabuf = kmemdup(buf, buf_size, GFP_KERNEL);\n\tif (!dmabuf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = hid_hw_raw_request(hdev, buf[0], dmabuf,\n\t\t\t\t buf_size, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tkfree(dmabuf);\n\n\treturn ret;\n}\n\nstatic int asus_kbd_init(struct hid_device *hdev)\n{\n\tconst u8 buf[] = { FEATURE_KBD_REPORT_ID, 0x41, 0x53, 0x55, 0x53, 0x20, 0x54,\n\t\t     0x65, 0x63, 0x68, 0x2e, 0x49, 0x6e, 0x63, 0x2e, 0x00 };\n\tint ret;\n\n\tret = asus_kbd_set_report(hdev, buf, sizeof(buf));\n\tif (ret < 0)\n\t\thid_err(hdev, \"Asus failed to send init command: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int asus_kbd_get_functions(struct hid_device *hdev,\n\t\t\t\t  unsigned char *kbd_func)\n{\n\tconst u8 buf[] = { FEATURE_KBD_REPORT_ID, 0x05, 0x20, 0x31, 0x00, 0x08 };\n\tu8 *readbuf;\n\tint ret;\n\n\tret = asus_kbd_set_report(hdev, buf, sizeof(buf));\n\tif (ret < 0) {\n\t\thid_err(hdev, \"Asus failed to send configuration command: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treadbuf = kzalloc(FEATURE_KBD_REPORT_SIZE, GFP_KERNEL);\n\tif (!readbuf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, FEATURE_KBD_REPORT_ID, readbuf,\n\t\t\t\t FEATURE_KBD_REPORT_SIZE, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"Asus failed to request functions: %d\\n\", ret);\n\t\tkfree(readbuf);\n\t\treturn ret;\n\t}\n\n\t*kbd_func = readbuf[6];\n\n\tkfree(readbuf);\n\treturn ret;\n}\n\nstatic int rog_nkey_led_init(struct hid_device *hdev)\n{\n\tconst u8 buf_init_start[] = { FEATURE_KBD_LED_REPORT_ID1, 0xB9 };\n\tu8 buf_init2[] = { FEATURE_KBD_LED_REPORT_ID1, 0x41, 0x53, 0x55, 0x53, 0x20,\n\t\t\t\t0x54, 0x65, 0x63, 0x68, 0x2e, 0x49, 0x6e, 0x63, 0x2e, 0x00 };\n\tu8 buf_init3[] = { FEATURE_KBD_LED_REPORT_ID1,\n\t\t\t\t\t\t0x05, 0x20, 0x31, 0x00, 0x08 };\n\tint ret;\n\n\thid_info(hdev, \"Asus initialise N-KEY Device\");\n\t \n\tret = asus_kbd_set_report(hdev, buf_init_start, sizeof(buf_init_start));\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Asus failed to send init start command: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tret = asus_kbd_set_report(hdev, buf_init2, sizeof(buf_init2));\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Asus failed to send init command 1.0: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tret = asus_kbd_set_report(hdev, buf_init3, sizeof(buf_init3));\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Asus failed to send init command 1.1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tbuf_init2[0] = FEATURE_KBD_LED_REPORT_ID2;\n\tbuf_init3[0] = FEATURE_KBD_LED_REPORT_ID2;\n\n\tret = asus_kbd_set_report(hdev, buf_init2, sizeof(buf_init2));\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Asus failed to send init command 2.0: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = asus_kbd_set_report(hdev, buf_init3, sizeof(buf_init3));\n\tif (ret < 0)\n\t\thid_warn(hdev, \"Asus failed to send init command 2.1: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void asus_schedule_work(struct asus_kbd_leds *led)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led->lock, flags);\n\tif (!led->removed)\n\t\tschedule_work(&led->work);\n\tspin_unlock_irqrestore(&led->lock, flags);\n}\n\nstatic void asus_kbd_backlight_set(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct asus_kbd_leds *led = container_of(led_cdev, struct asus_kbd_leds,\n\t\t\t\t\t\t cdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led->lock, flags);\n\tled->brightness = brightness;\n\tspin_unlock_irqrestore(&led->lock, flags);\n\n\tasus_schedule_work(led);\n}\n\nstatic enum led_brightness asus_kbd_backlight_get(struct led_classdev *led_cdev)\n{\n\tstruct asus_kbd_leds *led = container_of(led_cdev, struct asus_kbd_leds,\n\t\t\t\t\t\t cdev);\n\tenum led_brightness brightness;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led->lock, flags);\n\tbrightness = led->brightness;\n\tspin_unlock_irqrestore(&led->lock, flags);\n\n\treturn brightness;\n}\n\nstatic void asus_kbd_backlight_work(struct work_struct *work)\n{\n\tstruct asus_kbd_leds *led = container_of(work, struct asus_kbd_leds, work);\n\tu8 buf[] = { FEATURE_KBD_REPORT_ID, 0xba, 0xc5, 0xc4, 0x00 };\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led->lock, flags);\n\tbuf[4] = led->brightness;\n\tspin_unlock_irqrestore(&led->lock, flags);\n\n\tret = asus_kbd_set_report(led->hdev, buf, sizeof(buf));\n\tif (ret < 0)\n\t\thid_err(led->hdev, \"Asus failed to set keyboard backlight: %d\\n\", ret);\n}\n\n \nstatic bool asus_kbd_wmi_led_control_present(struct hid_device *hdev)\n{\n\tu32 value;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_ASUS_WMI))\n\t\treturn false;\n\n\tret = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS,\n\t\t\t\t       ASUS_WMI_DEVID_KBD_BACKLIGHT, 0, &value);\n\thid_dbg(hdev, \"WMI backlight check: rc %d value %x\", ret, value);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(value & ASUS_WMI_DSTS_PRESENCE_BIT);\n}\n\nstatic int asus_kbd_register_leds(struct hid_device *hdev)\n{\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\tunsigned char kbd_func;\n\tint ret;\n\n\tif (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD) {\n\t\tret = rog_nkey_led_init(hdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tret = asus_kbd_init(hdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = asus_kbd_get_functions(hdev, &kbd_func);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!(kbd_func & SUPPORT_KBD_BACKLIGHT))\n\t\t\treturn -ENODEV;\n\t}\n\n\tdrvdata->kbd_backlight = devm_kzalloc(&hdev->dev,\n\t\t\t\t\t      sizeof(struct asus_kbd_leds),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!drvdata->kbd_backlight)\n\t\treturn -ENOMEM;\n\n\tdrvdata->kbd_backlight->removed = false;\n\tdrvdata->kbd_backlight->brightness = 0;\n\tdrvdata->kbd_backlight->hdev = hdev;\n\tdrvdata->kbd_backlight->cdev.name = \"asus::kbd_backlight\";\n\tdrvdata->kbd_backlight->cdev.max_brightness = 3;\n\tdrvdata->kbd_backlight->cdev.brightness_set = asus_kbd_backlight_set;\n\tdrvdata->kbd_backlight->cdev.brightness_get = asus_kbd_backlight_get;\n\tINIT_WORK(&drvdata->kbd_backlight->work, asus_kbd_backlight_work);\n\tspin_lock_init(&drvdata->kbd_backlight->lock);\n\n\tret = devm_led_classdev_register(&hdev->dev, &drvdata->kbd_backlight->cdev);\n\tif (ret < 0) {\n\t\t \n\t\tdevm_kfree(&hdev->dev, drvdata->kbd_backlight);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int asus_parse_battery(struct asus_drvdata *drvdata, u8 *data, int size)\n{\n\tu8 sts;\n\tu8 lvl;\n\tint val;\n\n\tlvl = data[1];\n\tsts = data[8];\n\n\tdrvdata->battery_capacity = ((int)lvl * 100) / (int)BATTERY_LEVEL_MAX;\n\n\tswitch (sts) {\n\tcase BATTERY_STAT_CHARGING:\n\t\tval = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase BATTERY_STAT_FULL:\n\t\tval = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase BATTERY_STAT_DISCONNECT:\n\tdefault:\n\t\tval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\t}\n\tdrvdata->battery_stat = val;\n\n\treturn 0;\n}\n\nstatic int asus_report_battery(struct asus_drvdata *drvdata, u8 *data, int size)\n{\n\t \n\tif ((drvdata->battery_in_query == false) &&\n\t\t\t (size == BATTERY_REPORT_SIZE))\n\t\tpower_supply_changed(drvdata->battery);\n\n\treturn 0;\n}\n\nstatic int asus_battery_query(struct asus_drvdata *drvdata)\n{\n\tu8 *buf;\n\tint ret = 0;\n\n\tbuf = kmalloc(BATTERY_REPORT_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdrvdata->battery_in_query = true;\n\tret = hid_hw_raw_request(drvdata->hdev, BATTERY_REPORT_ID,\n\t\t\t\tbuf, BATTERY_REPORT_SIZE,\n\t\t\t\tHID_INPUT_REPORT, HID_REQ_GET_REPORT);\n\tdrvdata->battery_in_query = false;\n\tif (ret == BATTERY_REPORT_SIZE)\n\t\tret = asus_parse_battery(drvdata, buf, BATTERY_REPORT_SIZE);\n\telse\n\t\tret = -ENODATA;\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic enum power_supply_property asus_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n};\n\n#define\tQUERY_MIN_INTERVAL\t(60 * HZ)\t \n\nstatic int asus_battery_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct asus_drvdata *drvdata = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tif (time_before(drvdata->battery_next_query, jiffies)) {\n\t\t\tdrvdata->battery_next_query =\n\t\t\t\t\t jiffies + QUERY_MIN_INTERVAL;\n\t\t\tret = asus_battery_query(drvdata);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (psp == POWER_SUPPLY_PROP_STATUS)\n\t\t\tval->intval = drvdata->battery_stat;\n\t\telse\n\t\t\tval->intval = drvdata->battery_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = drvdata->hdev->name;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int asus_battery_probe(struct hid_device *hdev)\n{\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\tstruct power_supply_config pscfg = { .drv_data = drvdata };\n\tint ret = 0;\n\n\tdrvdata->battery_capacity = 0;\n\tdrvdata->battery_stat = POWER_SUPPLY_STATUS_UNKNOWN;\n\tdrvdata->battery_in_query = false;\n\n\tdrvdata->battery_desc.properties = asus_battery_props;\n\tdrvdata->battery_desc.num_properties = ARRAY_SIZE(asus_battery_props);\n\tdrvdata->battery_desc.get_property = asus_battery_get_property;\n\tdrvdata->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tdrvdata->battery_desc.use_for_apm = 0;\n\tdrvdata->battery_desc.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,\n\t\t\t\t\t\"asus-keyboard-%s-battery\",\n\t\t\t\t\tstrlen(hdev->uniq) ?\n\t\t\t\t\thdev->uniq : dev_name(&hdev->dev));\n\tif (!drvdata->battery_desc.name)\n\t\treturn -ENOMEM;\n\n\tdrvdata->battery_next_query = jiffies;\n\n\tdrvdata->battery = devm_power_supply_register(&hdev->dev,\n\t\t\t\t&(drvdata->battery_desc), &pscfg);\n\tif (IS_ERR(drvdata->battery)) {\n\t\tret = PTR_ERR(drvdata->battery);\n\t\tdrvdata->battery = NULL;\n\t\thid_err(hdev, \"Unable to register battery device\\n\");\n\t\treturn ret;\n\t}\n\n\tpower_supply_powers(drvdata->battery, &hdev->dev);\n\n\treturn ret;\n}\n\nstatic int asus_input_configured(struct hid_device *hdev, struct hid_input *hi)\n{\n\tstruct input_dev *input = hi->input;\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\t \n\tif (drvdata->quirks & QUIRK_T100CHI &&\n\t    hi->report->id != T100CHI_MOUSE_REPORT_ID)\n\t\treturn 0;\n\n\t \n\tif (drvdata->tp && (drvdata->quirks & QUIRK_MEDION_E1239T)) {\n\t\tswitch (hi->report->id) {\n\t\tcase E1239T_TP_TOGGLE_REPORT_ID:\n\t\t\tinput_set_capability(input, EV_KEY, KEY_F21);\n\t\t\tinput->name = \"Asus Touchpad Keys\";\n\t\t\tdrvdata->tp_kbd_input = input;\n\t\t\treturn 0;\n\t\tcase INPUT_REPORT_ID:\n\t\t\tbreak;  \n\t\tdefault:\n\t\t\treturn 0;  \n\t\t}\n\t}\n\n\tif (drvdata->tp) {\n\t\tint ret;\n\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0,\n\t\t\t\t     drvdata->tp->max_x, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0,\n\t\t\t\t     drvdata->tp->max_y, 0, 0);\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_X, drvdata->tp->res_x);\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_Y, drvdata->tp->res_y);\n\n\t\tif (drvdata->tp->contact_size >= 5) {\n\t\t\tinput_set_abs_params(input, ABS_TOOL_WIDTH, 0,\n\t\t\t\t\t     MAX_TOUCH_MAJOR, 0, 0);\n\t\t\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0,\n\t\t\t\t\t     MAX_TOUCH_MAJOR, 0, 0);\n\t\t\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0,\n\t\t\t\t\t      MAX_PRESSURE, 0, 0);\n\t\t}\n\n\t\t__set_bit(BTN_LEFT, input->keybit);\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\n\t\tret = input_mt_init_slots(input, drvdata->tp->max_contacts,\n\t\t\t\t\t  INPUT_MT_POINTER);\n\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Asus input mt init slots failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdrvdata->input = input;\n\n\tif (drvdata->enable_backlight &&\n\t    !asus_kbd_wmi_led_control_present(hdev) &&\n\t    asus_kbd_register_leds(hdev))\n\t\thid_warn(hdev, \"Failed to initialize backlight.\\n\");\n\n\treturn 0;\n}\n\n#define asus_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, \\\n\t\t\t\t\t\t    max, EV_KEY, (c))\nstatic int asus_input_mapping(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit,\n\t\tint *max)\n{\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tif (drvdata->quirks & QUIRK_SKIP_INPUT_MAPPING) {\n\t\t \n\t\treturn -1;\n\t}\n\n\t \n\tif ((drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) &&\n\t    (field->application == (HID_UP_GENDESK | 0x0080) ||\n\t     field->application == HID_GD_MOUSE ||\n\t     usage->hid == (HID_UP_GENDEVCTRLS | 0x0024) ||\n\t     usage->hid == (HID_UP_GENDEVCTRLS | 0x0025) ||\n\t     usage->hid == (HID_UP_GENDEVCTRLS | 0x0026)))\n\t\treturn -1;\n\n\t \n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_ASUSVENDOR) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x10: asus_map_key_clear(KEY_BRIGHTNESSDOWN);\tbreak;\n\t\tcase 0x20: asus_map_key_clear(KEY_BRIGHTNESSUP);\t\tbreak;\n\t\tcase 0x35: asus_map_key_clear(KEY_DISPLAY_OFF);\t\tbreak;\n\t\tcase 0x6c: asus_map_key_clear(KEY_SLEEP);\t\tbreak;\n\t\tcase 0x7c: asus_map_key_clear(KEY_MICMUTE);\t\tbreak;\n\t\tcase 0x82: asus_map_key_clear(KEY_CAMERA);\t\tbreak;\n\t\tcase 0x88: asus_map_key_clear(KEY_RFKILL);\t\t\tbreak;\n\t\tcase 0xb5: asus_map_key_clear(KEY_CALC);\t\t\tbreak;\n\t\tcase 0xc4: asus_map_key_clear(KEY_KBDILLUMUP);\t\tbreak;\n\t\tcase 0xc5: asus_map_key_clear(KEY_KBDILLUMDOWN);\t\tbreak;\n\t\tcase 0xc7: asus_map_key_clear(KEY_KBDILLUMTOGGLE);\tbreak;\n\n\t\tcase 0x6b: asus_map_key_clear(KEY_F21);\t\tbreak;  \n\t\tcase 0x38: asus_map_key_clear(KEY_PROG1);\tbreak;  \n\t\tcase 0xba: asus_map_key_clear(KEY_PROG2);\tbreak;  \n\t\tcase 0x5c: asus_map_key_clear(KEY_PROG3);\tbreak;  \n\t\tcase 0x99: asus_map_key_clear(KEY_PROG4);\tbreak;  \n\t\tcase 0xae: asus_map_key_clear(KEY_PROG4);\tbreak;  \n\t\tcase 0x92: asus_map_key_clear(KEY_CALC);\tbreak;  \n\t\tcase 0xb2: asus_map_key_clear(KEY_PROG2);\tbreak;  \n\t\tcase 0xb3: asus_map_key_clear(KEY_PROG3);\tbreak;  \n\t\tcase 0x6a: asus_map_key_clear(KEY_F13);\t\tbreak;  \n\t\tcase 0x4b: asus_map_key_clear(KEY_F14);\t\tbreak;  \n\n\n\t\tdefault:\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (drvdata->quirks & QUIRK_USE_KBD_BACKLIGHT)\n\t\t\tdrvdata->enable_backlight = true;\n\n\t\tset_bit(EV_REP, hi->input->evbit);\n\t\treturn 1;\n\t}\n\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_MSVENDOR) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0xff01: asus_map_key_clear(BTN_1);\tbreak;\n\t\tcase 0xff02: asus_map_key_clear(BTN_2);\tbreak;\n\t\tcase 0xff03: asus_map_key_clear(BTN_3);\tbreak;\n\t\tcase 0xff04: asus_map_key_clear(BTN_4);\tbreak;\n\t\tcase 0xff05: asus_map_key_clear(BTN_5);\tbreak;\n\t\tcase 0xff06: asus_map_key_clear(BTN_6);\tbreak;\n\t\tcase 0xff07: asus_map_key_clear(BTN_7);\tbreak;\n\t\tcase 0xff08: asus_map_key_clear(BTN_8);\tbreak;\n\t\tcase 0xff09: asus_map_key_clear(BTN_9);\tbreak;\n\t\tcase 0xff0a: asus_map_key_clear(BTN_A);\tbreak;\n\t\tcase 0xff0b: asus_map_key_clear(BTN_B);\tbreak;\n\t\tcase 0x00f1: asus_map_key_clear(KEY_WLAN);\tbreak;\n\t\tcase 0x00f2: asus_map_key_clear(KEY_BRIGHTNESSDOWN);\tbreak;\n\t\tcase 0x00f3: asus_map_key_clear(KEY_BRIGHTNESSUP);\tbreak;\n\t\tcase 0x00f4: asus_map_key_clear(KEY_DISPLAY_OFF);\tbreak;\n\t\tcase 0x00f7: asus_map_key_clear(KEY_CAMERA);\tbreak;\n\t\tcase 0x00f8: asus_map_key_clear(KEY_PROG1);\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tset_bit(EV_REP, hi->input->evbit);\n\t\treturn 1;\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_CONSUMER_USAGES &&\n\t\t(usage->hid & HID_USAGE_PAGE) == HID_UP_CONSUMER) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0xe2:  \n\t\tcase 0xe9:  \n\t\tcase 0xea:  \n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) &&\n\t    usage->hid == (HID_UP_CONSUMER | 0xe2)) {\n\t\tinput_set_capability(hi->input, EV_KEY, KEY_MUTE);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int asus_start_multitouch(struct hid_device *hdev)\n{\n\tint ret;\n\tstatic const unsigned char buf[] = {\n\t\tFEATURE_REPORT_ID, 0x00, 0x03, 0x01, 0x00\n\t};\n\tunsigned char *dmabuf = kmemdup(buf, sizeof(buf), GFP_KERNEL);\n\n\tif (!dmabuf) {\n\t\tret = -ENOMEM;\n\t\thid_err(hdev, \"Asus failed to alloc dma buf: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_raw_request(hdev, dmabuf[0], dmabuf, sizeof(buf),\n\t\t\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\n\tkfree(dmabuf);\n\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"Asus failed to start multitouch: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused asus_resume(struct hid_device *hdev) {\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\tint ret = 0;\n\n\tif (drvdata->kbd_backlight) {\n\t\tconst u8 buf[] = { FEATURE_KBD_REPORT_ID, 0xba, 0xc5, 0xc4,\n\t\t\t\tdrvdata->kbd_backlight->cdev.brightness };\n\t\tret = asus_kbd_set_report(hdev, buf, sizeof(buf));\n\t\tif (ret < 0) {\n\t\t\thid_err(hdev, \"Asus failed to set keyboard backlight: %d\\n\", ret);\n\t\t\tgoto asus_resume_err;\n\t\t}\n\t}\n\nasus_resume_err:\n\treturn ret;\n}\n\nstatic int __maybe_unused asus_reset_resume(struct hid_device *hdev)\n{\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tif (drvdata->tp)\n\t\treturn asus_start_multitouch(hdev);\n\n\treturn 0;\n}\n\nstatic int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct asus_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (drvdata == NULL) {\n\t\thid_err(hdev, \"Can't alloc Asus descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tdrvdata->quirks = id->driver_data;\n\n\t \n\tif (strstr(hdev->name, \"T90CHI\")) {\n\t\tdrvdata->quirks &= ~QUIRK_T100CHI;\n\t\tdrvdata->quirks |= QUIRK_T90CHI;\n\t}\n\n\tif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\n\t\tdrvdata->tp = &asus_i2c_tp;\n\n\tif ((drvdata->quirks & QUIRK_T100_KEYBOARD) && hid_is_usb(hdev)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\tif (intf->altsetting->desc.bInterfaceNumber == T100_TPAD_INTF) {\n\t\t\tdrvdata->quirks = QUIRK_SKIP_INPUT_MAPPING;\n\t\t\t \n\t\t\tif (dmi_match(DMI_PRODUCT_NAME, \"T100HAN\"))\n\t\t\t\tdrvdata->tp = &asus_t100ha_tp;\n\t\t\telse if (dmi_match(DMI_PRODUCT_NAME, \"T200TA\"))\n\t\t\t\tdrvdata->tp = &asus_t200ta_tp;\n\t\t\telse\n\t\t\t\tdrvdata->tp = &asus_t100ta_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t \n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\tdrvdata->tp = &asus_t100chi_tp;\n\t}\n\n\tif ((drvdata->quirks & QUIRK_MEDION_E1239T) && hid_is_usb(hdev)) {\n\t\tstruct usb_host_interface *alt =\n\t\t\tto_usb_interface(hdev->dev.parent)->altsetting;\n\n\t\tif (alt->desc.bInterfaceNumber == MEDION_E1239T_TPAD_INTF) {\n\t\t\t \n\t\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t\t\tdrvdata->quirks |= QUIRK_SKIP_INPUT_MAPPING;\n\t\t\tdrvdata->tp = &medion_e1239t_tp;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\n\t\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tdrvdata->hdev = hdev;\n\n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tret = asus_battery_probe(hdev);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t    \"Asus hid battery_probe failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hid parse failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Asus hw start failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Asus input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (drvdata->tp) {\n\t\tdrvdata->input->name = \"Asus TouchPad\";\n\t} else {\n\t\tdrvdata->input->name = \"Asus Keyboard\";\n\t}\n\n\tif (drvdata->tp) {\n\t\tret = asus_start_multitouch(hdev);\n\t\tif (ret)\n\t\t\tgoto err_stop_hw;\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void asus_remove(struct hid_device *hdev)\n{\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tif (drvdata->kbd_backlight) {\n\t\tspin_lock_irqsave(&drvdata->kbd_backlight->lock, flags);\n\t\tdrvdata->kbd_backlight->removed = true;\n\t\tspin_unlock_irqrestore(&drvdata->kbd_backlight->lock, flags);\n\n\t\tcancel_work_sync(&drvdata->kbd_backlight->work);\n\t}\n\n\thid_hw_stop(hdev);\n}\n\nstatic const __u8 asus_g752_fixed_rdesc[] = {\n        0x19, 0x00,\t\t\t \n        0x2A, 0xFF, 0x00,\t\t \n};\n\nstatic __u8 *asus_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tif (drvdata->quirks & QUIRK_FIX_NOTEBOOK_REPORT &&\n\t\t\t*rsize >= 56 && rdesc[54] == 0x25 && rdesc[55] == 0x65) {\n\t\thid_info(hdev, \"Fixing up Asus notebook report descriptor\\n\");\n\t\trdesc[55] = 0xdd;\n\t}\n\t \n\tif (drvdata->quirks & QUIRK_T100_KEYBOARD &&\n\t\t (*rsize == 76 || *rsize == 101) &&\n\t\t rdesc[73] == 0x81 && rdesc[74] == 0x01) {\n\t\thid_info(hdev, \"Fixing up Asus T100 keyb report descriptor\\n\");\n\t\trdesc[74] &= ~HID_MAIN_ITEM_CONSTANT;\n\t}\n\t \n\tif (drvdata->quirks & (QUIRK_T100CHI | QUIRK_T90CHI)) {\n\t\tint rsize_orig;\n\t\tint offs;\n\n\t\tif (drvdata->quirks & QUIRK_T100CHI) {\n\t\t\trsize_orig = 403;\n\t\t\toffs = 388;\n\t\t} else {\n\t\t\trsize_orig = 306;\n\t\t\toffs = 291;\n\t\t}\n\n\t\t \n\t\tif (*rsize == rsize_orig &&\n\t\t\trdesc[offs] == 0x09 && rdesc[offs + 1] == 0x76) {\n\t\t\t*rsize = rsize_orig + 1;\n\t\t\trdesc = kmemdup(rdesc, *rsize, GFP_KERNEL);\n\t\t\tif (!rdesc)\n\t\t\t\treturn NULL;\n\n\t\t\thid_info(hdev, \"Fixing up %s keyb report descriptor\\n\",\n\t\t\t\tdrvdata->quirks & QUIRK_T100CHI ?\n\t\t\t\t\"T100CHI\" : \"T90CHI\");\n\t\t\tmemmove(rdesc + offs + 4, rdesc + offs + 2, 12);\n\t\t\trdesc[offs] = 0x19;\n\t\t\trdesc[offs + 1] = 0x00;\n\t\t\trdesc[offs + 2] = 0x29;\n\t\t\trdesc[offs + 3] = 0xff;\n\t\t\trdesc[offs + 14] = 0x00;\n\t\t}\n\t}\n\n\tif (drvdata->quirks & QUIRK_G752_KEYBOARD &&\n\t\t *rsize == 75 && rdesc[61] == 0x15 && rdesc[62] == 0x00) {\n\t\t \n\t\t__u8 *new_rdesc;\n\t\tsize_t new_size = *rsize + sizeof(asus_g752_fixed_rdesc);\n\n\t\tnew_rdesc = devm_kzalloc(&hdev->dev, new_size, GFP_KERNEL);\n\t\tif (new_rdesc == NULL)\n\t\t\treturn rdesc;\n\n\t\thid_info(hdev, \"Fixing up Asus G752 keyb report descriptor\\n\");\n\t\t \n\t\tmemcpy(new_rdesc, rdesc, 61);\n\t\t \n\t\tmemcpy(new_rdesc + 61, asus_g752_fixed_rdesc, sizeof(asus_g752_fixed_rdesc));\n\t\t \n\t\tmemcpy(new_rdesc + 61 + sizeof(asus_g752_fixed_rdesc), rdesc + 61, *rsize - 61);\n\n\t\t*rsize = new_size;\n\t\trdesc = new_rdesc;\n\t}\n\n\tif (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD &&\n\t\t\t*rsize == 331 && rdesc[190] == 0x85 && rdesc[191] == 0x5a &&\n\t\t\trdesc[204] == 0x95 && rdesc[205] == 0x05) {\n\t\thid_info(hdev, \"Fixing up Asus N-KEY keyb report descriptor\\n\");\n\t\trdesc[205] = 0x01;\n\t}\n\n\treturn rdesc;\n}\n\nstatic const struct hid_device_id asus_devices[] = {\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_I2C_KEYBOARD), I2C_KEYBOARD_QUIRKS},\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_I2C_TOUCHPAD), I2C_TOUCHPAD_QUIRKS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD1), QUIRK_USE_KBD_BACKLIGHT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD2), QUIRK_USE_KBD_BACKLIGHT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD3), QUIRK_G752_KEYBOARD },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_FX503VD_KEYBOARD),\n\t  QUIRK_USE_KBD_BACKLIGHT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD),\n\t  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD2),\n\t  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD3),\n\t  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),\n\t  QUIRK_ROG_CLAYMORE_II_KEYBOARD },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_T100TA_KEYBOARD),\n\t  QUIRK_T100_KEYBOARD | QUIRK_NO_CONSUMER_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_T100TAF_KEYBOARD),\n\t  QUIRK_T100_KEYBOARD | QUIRK_NO_CONSUMER_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_ASUS_AK1D) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TURBOX, USB_DEVICE_ID_ASUS_MD_5110) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_JESS, USB_DEVICE_ID_ASUS_MD_5112) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_T100CHI_KEYBOARD), QUIRK_T100CHI },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ITE, USB_DEVICE_ID_ITE_MEDION_E1239T),\n\t\tQUIRK_MEDION_E1239T },\n\t \n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\tUSB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, asus_devices);\n\nstatic struct hid_driver asus_driver = {\n\t.name\t\t\t= \"asus\",\n\t.id_table\t\t= asus_devices,\n\t.report_fixup\t\t= asus_report_fixup,\n\t.probe                  = asus_probe,\n\t.remove\t\t\t= asus_remove,\n\t.input_mapping          = asus_input_mapping,\n\t.input_configured       = asus_input_configured,\n#ifdef CONFIG_PM\n\t.reset_resume           = asus_reset_resume,\n\t.resume\t\t\t\t\t= asus_resume,\n#endif\n\t.event\t\t\t= asus_event,\n\t.raw_event\t\t= asus_raw_event\n};\nmodule_hid_driver(asus_driver);\n\nMODULE_LICENSE(\"GPL\");",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}