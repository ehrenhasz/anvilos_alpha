{
  "module_name": "hidraw.c",
  "hash_id": "33bd63d47c602088c4671405549b83d2b2b01a86ad076651b3a670962b2b9299",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hidraw.c",
  "human_readable_source": "\n \n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/cdev.h>\n#include <linux/poll.h>\n#include <linux/device.h>\n#include <linux/major.h>\n#include <linux/slab.h>\n#include <linux/hid.h>\n#include <linux/mutex.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n\n#include <linux/hidraw.h>\n\nstatic int hidraw_major;\nstatic struct cdev hidraw_cdev;\nstatic const struct class hidraw_class = {\n\t.name = \"hidraw\",\n};\nstatic struct hidraw *hidraw_table[HIDRAW_MAX_DEVICES];\nstatic DECLARE_RWSEM(minors_rwsem);\n\nstatic ssize_t hidraw_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tstruct hidraw_list *list = file->private_data;\n\tint ret = 0, len;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tmutex_lock(&list->read_mutex);\n\n\twhile (ret == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tadd_wait_queue(&list->hidraw->wait, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!list->hidraw->exist) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmutex_unlock(&list->read_mutex);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&list->read_mutex);\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&list->hidraw->wait, &wait);\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tlen = list->buffer[list->tail].len > count ?\n\t\t\tcount : list->buffer[list->tail].len;\n\n\t\tif (list->buffer[list->tail].value) {\n\t\t\tif (copy_to_user(buffer, list->buffer[list->tail].value, len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = len;\n\t\t}\n\n\t\tkfree(list->buffer[list->tail].value);\n\t\tlist->buffer[list->tail].value = NULL;\n\t\tlist->tail = (list->tail + 1) & (HIDRAW_BUFFER_SIZE - 1);\n\t}\nout:\n\tmutex_unlock(&list->read_mutex);\n\treturn ret;\n}\n\n \nstatic ssize_t hidraw_send_report(struct file *file, const char __user *buffer, size_t count, unsigned char report_type)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tstruct hid_device *dev;\n\t__u8 *buf;\n\tint ret = 0;\n\n\tlockdep_assert_held(&minors_rwsem);\n\n\tif (!hidraw_table[minor] || !hidraw_table[minor]->exist) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdev = hidraw_table[minor]->hid;\n\n\tif (count > HID_MAX_BUFFER_SIZE) {\n\t\thid_warn(dev, \"pid %d passed too large report\\n\",\n\t\t\t task_pid_nr(current));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (count < 2) {\n\t\thid_warn(dev, \"pid %d passed too short report\\n\",\n\t\t\t task_pid_nr(current));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbuf = memdup_user(buffer, count);\n\tif (IS_ERR(buf)) {\n\t\tret = PTR_ERR(buf);\n\t\tgoto out;\n\t}\n\n\tif ((report_type == HID_OUTPUT_REPORT) &&\n\t    !(dev->quirks & HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP)) {\n\t\tret = hid_hw_output_report(dev, buf, count);\n\t\t \n\t\tif (ret != -ENOSYS)\n\t\t\tgoto out_free;\n\t}\n\n\tret = hid_hw_raw_request(dev, buf[0], buf, count, report_type,\n\t\t\t\tHID_REQ_SET_REPORT);\n\nout_free:\n\tkfree(buf);\nout:\n\treturn ret;\n}\n\nstatic ssize_t hidraw_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tdown_read(&minors_rwsem);\n\tret = hidraw_send_report(file, buffer, count, HID_OUTPUT_REPORT);\n\tup_read(&minors_rwsem);\n\treturn ret;\n}\n\n\n \nstatic ssize_t hidraw_get_report(struct file *file, char __user *buffer, size_t count, unsigned char report_type)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tstruct hid_device *dev;\n\t__u8 *buf;\n\tint ret = 0, len;\n\tunsigned char report_number;\n\n\tlockdep_assert_held(&minors_rwsem);\n\n\tif (!hidraw_table[minor] || !hidraw_table[minor]->exist) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdev = hidraw_table[minor]->hid;\n\n\tif (!dev->ll_driver->raw_request) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (count > HID_MAX_BUFFER_SIZE) {\n\t\thid_warn(dev, \"pid %d passed too large report\\n\",\n\t\t\ttask_pid_nr(current));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (count < 2) {\n\t\thid_warn(dev, \"pid %d passed too short report\\n\",\n\t\t\ttask_pid_nr(current));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (copy_from_user(&report_number, buffer, 1)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tret = hid_hw_raw_request(dev, report_number, buf, count, report_type,\n\t\t\t\t HID_REQ_GET_REPORT);\n\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tlen = (ret < count) ? ret : count;\n\n\tif (copy_to_user(buffer, buf, len)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tret = len;\n\nout_free:\n\tkfree(buf);\nout:\n\treturn ret;\n}\n\nstatic __poll_t hidraw_poll(struct file *file, poll_table *wait)\n{\n\tstruct hidraw_list *list = file->private_data;\n\t__poll_t mask = EPOLLOUT | EPOLLWRNORM;  \n\n\tpoll_wait(file, &list->hidraw->wait, wait);\n\tif (list->head != list->tail)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (!list->hidraw->exist)\n\t\tmask |= EPOLLERR | EPOLLHUP;\n\treturn mask;\n}\n\nstatic int hidraw_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct hidraw *dev;\n\tstruct hidraw_list *list;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (!(list = kzalloc(sizeof(struct hidraw_list), GFP_KERNEL))) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tdown_write(&minors_rwsem);\n\tif (!hidraw_table[minor] || !hidraw_table[minor]->exist) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tdev = hidraw_table[minor];\n\tif (!dev->open++) {\n\t\terr = hid_hw_power(dev->hid, PM_HINT_FULLON);\n\t\tif (err < 0) {\n\t\t\tdev->open--;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = hid_hw_open(dev->hid);\n\t\tif (err < 0) {\n\t\t\thid_hw_power(dev->hid, PM_HINT_NORMAL);\n\t\t\tdev->open--;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tlist->hidraw = hidraw_table[minor];\n\tmutex_init(&list->read_mutex);\n\tspin_lock_irqsave(&hidraw_table[minor]->list_lock, flags);\n\tlist_add_tail(&list->node, &hidraw_table[minor]->list);\n\tspin_unlock_irqrestore(&hidraw_table[minor]->list_lock, flags);\n\tfile->private_data = list;\nout_unlock:\n\tup_write(&minors_rwsem);\nout:\n\tif (err < 0)\n\t\tkfree(list);\n\treturn err;\n\n}\n\nstatic int hidraw_fasync(int fd, struct file *file, int on)\n{\n\tstruct hidraw_list *list = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &list->fasync);\n}\n\nstatic void drop_ref(struct hidraw *hidraw, int exists_bit)\n{\n\tif (exists_bit) {\n\t\thidraw->exist = 0;\n\t\tif (hidraw->open) {\n\t\t\thid_hw_close(hidraw->hid);\n\t\t\twake_up_interruptible(&hidraw->wait);\n\t\t}\n\t\tdevice_destroy(&hidraw_class,\n\t\t\t       MKDEV(hidraw_major, hidraw->minor));\n\t} else {\n\t\t--hidraw->open;\n\t}\n\tif (!hidraw->open) {\n\t\tif (!hidraw->exist) {\n\t\t\thidraw_table[hidraw->minor] = NULL;\n\t\t\tkfree(hidraw);\n\t\t} else {\n\t\t\t \n\t\t\thid_hw_close(hidraw->hid);\n\t\t\thid_hw_power(hidraw->hid, PM_HINT_NORMAL);\n\t\t}\n\t}\n}\n\nstatic int hidraw_release(struct inode * inode, struct file * file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct hidraw_list *list = file->private_data;\n\tunsigned long flags;\n\n\tdown_write(&minors_rwsem);\n\n\tspin_lock_irqsave(&hidraw_table[minor]->list_lock, flags);\n\tfor (int i = list->tail; i < list->head; i++)\n\t\tkfree(list->buffer[i].value);\n\tlist_del(&list->node);\n\tspin_unlock_irqrestore(&hidraw_table[minor]->list_lock, flags);\n\tkfree(list);\n\n\tdrop_ref(hidraw_table[minor], 0);\n\n\tup_write(&minors_rwsem);\n\treturn 0;\n}\n\nstatic long hidraw_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tunsigned int minor = iminor(inode);\n\tlong ret = 0;\n\tstruct hidraw *dev;\n\tvoid __user *user_arg = (void __user*) arg;\n\n\tdown_read(&minors_rwsem);\n\tdev = hidraw_table[minor];\n\tif (!dev || !dev->exist) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\t\tcase HIDIOCGRDESCSIZE:\n\t\t\tif (put_user(dev->hid->rsize, (int __user *)arg))\n\t\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\n\t\tcase HIDIOCGRDESC:\n\t\t\t{\n\t\t\t\t__u32 len;\n\n\t\t\t\tif (get_user(len, (int __user *)arg))\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\telse if (len > HID_MAX_DESCRIPTOR_SIZE - 1)\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\telse if (copy_to_user(user_arg + offsetof(\n\t\t\t\t\tstruct hidraw_report_descriptor,\n\t\t\t\t\tvalue[0]),\n\t\t\t\t\tdev->hid->rdesc,\n\t\t\t\t\tmin(dev->hid->rsize, len)))\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase HIDIOCGRAWINFO:\n\t\t\t{\n\t\t\t\tstruct hidraw_devinfo dinfo;\n\n\t\t\t\tdinfo.bustype = dev->hid->bus;\n\t\t\t\tdinfo.vendor = dev->hid->vendor;\n\t\t\t\tdinfo.product = dev->hid->product;\n\t\t\t\tif (copy_to_user(user_arg, &dinfo, sizeof(dinfo)))\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\t{\n\t\t\t\tstruct hid_device *hid = dev->hid;\n\t\t\t\tif (_IOC_TYPE(cmd) != 'H') {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCSFEATURE(0))) {\n\t\t\t\t\tint len = _IOC_SIZE(cmd);\n\t\t\t\t\tret = hidraw_send_report(file, user_arg, len, HID_FEATURE_REPORT);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGFEATURE(0))) {\n\t\t\t\t\tint len = _IOC_SIZE(cmd);\n\t\t\t\t\tret = hidraw_get_report(file, user_arg, len, HID_FEATURE_REPORT);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCSINPUT(0))) {\n\t\t\t\t\tint len = _IOC_SIZE(cmd);\n\t\t\t\t\tret = hidraw_send_report(file, user_arg, len, HID_INPUT_REPORT);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGINPUT(0))) {\n\t\t\t\t\tint len = _IOC_SIZE(cmd);\n\t\t\t\t\tret = hidraw_get_report(file, user_arg, len, HID_INPUT_REPORT);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCSOUTPUT(0))) {\n\t\t\t\t\tint len = _IOC_SIZE(cmd);\n\t\t\t\t\tret = hidraw_send_report(file, user_arg, len, HID_OUTPUT_REPORT);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGOUTPUT(0))) {\n\t\t\t\t\tint len = _IOC_SIZE(cmd);\n\t\t\t\t\tret = hidraw_get_report(file, user_arg, len, HID_OUTPUT_REPORT);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (_IOC_DIR(cmd) != _IOC_READ) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWNAME(0))) {\n\t\t\t\t\tint len = strlen(hid->name) + 1;\n\t\t\t\t\tif (len > _IOC_SIZE(cmd))\n\t\t\t\t\t\tlen = _IOC_SIZE(cmd);\n\t\t\t\t\tret = copy_to_user(user_arg, hid->name, len) ?\n\t\t\t\t\t\t-EFAULT : len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWPHYS(0))) {\n\t\t\t\t\tint len = strlen(hid->phys) + 1;\n\t\t\t\t\tif (len > _IOC_SIZE(cmd))\n\t\t\t\t\t\tlen = _IOC_SIZE(cmd);\n\t\t\t\t\tret = copy_to_user(user_arg, hid->phys, len) ?\n\t\t\t\t\t\t-EFAULT : len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGRAWUNIQ(0))) {\n\t\t\t\t\tint len = strlen(hid->uniq) + 1;\n\t\t\t\t\tif (len > _IOC_SIZE(cmd))\n\t\t\t\t\t\tlen = _IOC_SIZE(cmd);\n\t\t\t\t\tret = copy_to_user(user_arg, hid->uniq, len) ?\n\t\t\t\t\t\t-EFAULT : len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tret = -ENOTTY;\n\t}\nout:\n\tup_read(&minors_rwsem);\n\treturn ret;\n}\n\nstatic const struct file_operations hidraw_ops = {\n\t.owner =        THIS_MODULE,\n\t.read =         hidraw_read,\n\t.write =        hidraw_write,\n\t.poll =         hidraw_poll,\n\t.open =         hidraw_open,\n\t.release =      hidraw_release,\n\t.unlocked_ioctl = hidraw_ioctl,\n\t.fasync =\thidraw_fasync,\n\t.compat_ioctl   = compat_ptr_ioctl,\n\t.llseek =\tnoop_llseek,\n};\n\nint hidraw_report_event(struct hid_device *hid, u8 *data, int len)\n{\n\tstruct hidraw *dev = hid->hidraw;\n\tstruct hidraw_list *list;\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->list_lock, flags);\n\tlist_for_each_entry(list, &dev->list, node) {\n\t\tint new_head = (list->head + 1) & (HIDRAW_BUFFER_SIZE - 1);\n\n\t\tif (new_head == list->tail)\n\t\t\tcontinue;\n\n\t\tif (!(list->buffer[list->head].value = kmemdup(data, len, GFP_ATOMIC))) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tlist->buffer[list->head].len = len;\n\t\tlist->head = new_head;\n\t\tkill_fasync(&list->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock_irqrestore(&dev->list_lock, flags);\n\n\twake_up_interruptible(&dev->wait);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hidraw_report_event);\n\nint hidraw_connect(struct hid_device *hid)\n{\n\tint minor, result;\n\tstruct hidraw *dev;\n\n\t \n\n\tdev = kzalloc(sizeof(struct hidraw), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tresult = -EINVAL;\n\n\tdown_write(&minors_rwsem);\n\n\tfor (minor = 0; minor < HIDRAW_MAX_DEVICES; minor++) {\n\t\tif (hidraw_table[minor])\n\t\t\tcontinue;\n\t\thidraw_table[minor] = dev;\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\n\tif (result) {\n\t\tup_write(&minors_rwsem);\n\t\tkfree(dev);\n\t\tgoto out;\n\t}\n\n\tdev->dev = device_create(&hidraw_class, &hid->dev, MKDEV(hidraw_major, minor),\n\t\t\t\t NULL, \"%s%d\", \"hidraw\", minor);\n\n\tif (IS_ERR(dev->dev)) {\n\t\thidraw_table[minor] = NULL;\n\t\tup_write(&minors_rwsem);\n\t\tresult = PTR_ERR(dev->dev);\n\t\tkfree(dev);\n\t\tgoto out;\n\t}\n\n\tinit_waitqueue_head(&dev->wait);\n\tspin_lock_init(&dev->list_lock);\n\tINIT_LIST_HEAD(&dev->list);\n\n\tdev->hid = hid;\n\tdev->minor = minor;\n\n\tdev->exist = 1;\n\thid->hidraw = dev;\n\n\tup_write(&minors_rwsem);\nout:\n\treturn result;\n\n}\nEXPORT_SYMBOL_GPL(hidraw_connect);\n\nvoid hidraw_disconnect(struct hid_device *hid)\n{\n\tstruct hidraw *hidraw = hid->hidraw;\n\n\tdown_write(&minors_rwsem);\n\n\tdrop_ref(hidraw, 1);\n\n\tup_write(&minors_rwsem);\n}\nEXPORT_SYMBOL_GPL(hidraw_disconnect);\n\nint __init hidraw_init(void)\n{\n\tint result;\n\tdev_t dev_id;\n\n\tresult = alloc_chrdev_region(&dev_id, HIDRAW_FIRST_MINOR,\n\t\t\tHIDRAW_MAX_DEVICES, \"hidraw\");\n\tif (result < 0) {\n\t\tpr_warn(\"can't get major number\\n\");\n\t\tgoto out;\n\t}\n\n\thidraw_major = MAJOR(dev_id);\n\n\tresult = class_register(&hidraw_class);\n\tif (result)\n\t\tgoto error_cdev;\n\n        cdev_init(&hidraw_cdev, &hidraw_ops);\n\tresult = cdev_add(&hidraw_cdev, dev_id, HIDRAW_MAX_DEVICES);\n\tif (result < 0)\n\t\tgoto error_class;\n\n\tpr_info(\"raw HID events driver (C) Jiri Kosina\\n\");\nout:\n\treturn result;\n\nerror_class:\n\tclass_unregister(&hidraw_class);\nerror_cdev:\n\tunregister_chrdev_region(dev_id, HIDRAW_MAX_DEVICES);\n\tgoto out;\n}\n\nvoid hidraw_exit(void)\n{\n\tdev_t dev_id = MKDEV(hidraw_major, 0);\n\n\tcdev_del(&hidraw_cdev);\n\tclass_unregister(&hidraw_class);\n\tunregister_chrdev_region(dev_id, HIDRAW_MAX_DEVICES);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}