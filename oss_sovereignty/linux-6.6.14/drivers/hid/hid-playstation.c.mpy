{
  "module_name": "hid-playstation.c",
  "hash_id": "e7c6ea1174019ee3444a8fb8c870bdd90772f9fccc8dda9a8823f39dbd395148",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-playstation.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/crc32.h>\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/idr.h>\n#include <linux/input/mt.h>\n#include <linux/leds.h>\n#include <linux/led-class-multicolor.h>\n#include <linux/module.h>\n\n#include <asm/unaligned.h>\n\n#include \"hid-ids.h\"\n\n \nstatic DEFINE_MUTEX(ps_devices_lock);\nstatic LIST_HEAD(ps_devices_list);\n\nstatic DEFINE_IDA(ps_player_id_allocator);\n\n#define HID_PLAYSTATION_VERSION_PATCH 0x8000\n\n \nstruct ps_device {\n\tstruct list_head list;\n\tstruct hid_device *hdev;\n\tspinlock_t lock;\n\n\tuint32_t player_id;\n\n\tstruct power_supply_desc battery_desc;\n\tstruct power_supply *battery;\n\tuint8_t battery_capacity;\n\tint battery_status;\n\n\tconst char *input_dev_name;  \n\tuint8_t mac_address[6];  \n\tuint32_t hw_version;\n\tuint32_t fw_version;\n\n\tint (*parse_report)(struct ps_device *dev, struct hid_report *report, u8 *data, int size);\n\tvoid (*remove)(struct ps_device *dev);\n};\n\n \nstruct ps_calibration_data {\n\tint abs_code;\n\tshort bias;\n\tint sens_numer;\n\tint sens_denom;\n};\n\nstruct ps_led_info {\n\tconst char *name;\n\tconst char *color;\n\tint max_brightness;\n\tenum led_brightness (*brightness_get)(struct led_classdev *cdev);\n\tint (*brightness_set)(struct led_classdev *cdev, enum led_brightness);\n\tint (*blink_set)(struct led_classdev *led, unsigned long *on, unsigned long *off);\n};\n\n \n#define PS_INPUT_CRC32_SEED\t0xA1\n#define PS_OUTPUT_CRC32_SEED\t0xA2\n#define PS_FEATURE_CRC32_SEED\t0xA3\n\n#define DS_INPUT_REPORT_USB\t\t\t0x01\n#define DS_INPUT_REPORT_USB_SIZE\t\t64\n#define DS_INPUT_REPORT_BT\t\t\t0x31\n#define DS_INPUT_REPORT_BT_SIZE\t\t\t78\n#define DS_OUTPUT_REPORT_USB\t\t\t0x02\n#define DS_OUTPUT_REPORT_USB_SIZE\t\t63\n#define DS_OUTPUT_REPORT_BT\t\t\t0x31\n#define DS_OUTPUT_REPORT_BT_SIZE\t\t78\n\n#define DS_FEATURE_REPORT_CALIBRATION\t\t0x05\n#define DS_FEATURE_REPORT_CALIBRATION_SIZE\t41\n#define DS_FEATURE_REPORT_PAIRING_INFO\t\t0x09\n#define DS_FEATURE_REPORT_PAIRING_INFO_SIZE\t20\n#define DS_FEATURE_REPORT_FIRMWARE_INFO\t\t0x20\n#define DS_FEATURE_REPORT_FIRMWARE_INFO_SIZE\t64\n\n \n#define DS_BUTTONS0_HAT_SWITCH\tGENMASK(3, 0)\n#define DS_BUTTONS0_SQUARE\tBIT(4)\n#define DS_BUTTONS0_CROSS\tBIT(5)\n#define DS_BUTTONS0_CIRCLE\tBIT(6)\n#define DS_BUTTONS0_TRIANGLE\tBIT(7)\n#define DS_BUTTONS1_L1\t\tBIT(0)\n#define DS_BUTTONS1_R1\t\tBIT(1)\n#define DS_BUTTONS1_L2\t\tBIT(2)\n#define DS_BUTTONS1_R2\t\tBIT(3)\n#define DS_BUTTONS1_CREATE\tBIT(4)\n#define DS_BUTTONS1_OPTIONS\tBIT(5)\n#define DS_BUTTONS1_L3\t\tBIT(6)\n#define DS_BUTTONS1_R3\t\tBIT(7)\n#define DS_BUTTONS2_PS_HOME\tBIT(0)\n#define DS_BUTTONS2_TOUCHPAD\tBIT(1)\n#define DS_BUTTONS2_MIC_MUTE\tBIT(2)\n\n \n#define DS_STATUS_BATTERY_CAPACITY\tGENMASK(3, 0)\n#define DS_STATUS_CHARGING\t\tGENMASK(7, 4)\n#define DS_STATUS_CHARGING_SHIFT\t4\n\n \n#define DS_FEATURE_VERSION(major, minor) ((major & 0xff) << 8 | (minor & 0xff))\n\n \n#define DS_TOUCH_POINT_INACTIVE BIT(7)\n\n  \n#define DS_OUTPUT_TAG 0x10\n \n#define DS_OUTPUT_VALID_FLAG0_COMPATIBLE_VIBRATION BIT(0)\n#define DS_OUTPUT_VALID_FLAG0_HAPTICS_SELECT BIT(1)\n#define DS_OUTPUT_VALID_FLAG1_MIC_MUTE_LED_CONTROL_ENABLE BIT(0)\n#define DS_OUTPUT_VALID_FLAG1_POWER_SAVE_CONTROL_ENABLE BIT(1)\n#define DS_OUTPUT_VALID_FLAG1_LIGHTBAR_CONTROL_ENABLE BIT(2)\n#define DS_OUTPUT_VALID_FLAG1_RELEASE_LEDS BIT(3)\n#define DS_OUTPUT_VALID_FLAG1_PLAYER_INDICATOR_CONTROL_ENABLE BIT(4)\n#define DS_OUTPUT_VALID_FLAG2_LIGHTBAR_SETUP_CONTROL_ENABLE BIT(1)\n#define DS_OUTPUT_VALID_FLAG2_COMPATIBLE_VIBRATION2 BIT(2)\n#define DS_OUTPUT_POWER_SAVE_CONTROL_MIC_MUTE BIT(4)\n#define DS_OUTPUT_LIGHTBAR_SETUP_LIGHT_OUT BIT(1)\n\n \n#define DS_ACC_RES_PER_G\t8192\n#define DS_ACC_RANGE\t\t(4*DS_ACC_RES_PER_G)\n#define DS_GYRO_RES_PER_DEG_S\t1024\n#define DS_GYRO_RANGE\t\t(2048*DS_GYRO_RES_PER_DEG_S)\n#define DS_TOUCHPAD_WIDTH\t1920\n#define DS_TOUCHPAD_HEIGHT\t1080\n\nstruct dualsense {\n\tstruct ps_device base;\n\tstruct input_dev *gamepad;\n\tstruct input_dev *sensors;\n\tstruct input_dev *touchpad;\n\n\t \n\tuint16_t update_version;\n\n\t \n\tstruct ps_calibration_data accel_calib_data[3];\n\tstruct ps_calibration_data gyro_calib_data[3];\n\n\t \n\tbool sensor_timestamp_initialized;\n\tuint32_t prev_sensor_timestamp;\n\tuint32_t sensor_timestamp_us;\n\n\t \n\tbool use_vibration_v2;\n\tbool update_rumble;\n\tuint8_t motor_left;\n\tuint8_t motor_right;\n\n\t \n\tstruct led_classdev_mc lightbar;\n\tbool update_lightbar;\n\tuint8_t lightbar_red;\n\tuint8_t lightbar_green;\n\tuint8_t lightbar_blue;\n\n\t \n\tbool update_mic_mute;\n\tbool mic_muted;\n\tbool last_btn_mic_state;\n\n\t \n\tbool update_player_leds;\n\tuint8_t player_leds_state;\n\tstruct led_classdev player_leds[5];\n\n\tstruct work_struct output_worker;\n\tbool output_worker_initialized;\n\tvoid *output_report_dmabuf;\n\tuint8_t output_seq;  \n};\n\nstruct dualsense_touch_point {\n\tuint8_t contact;\n\tuint8_t x_lo;\n\tuint8_t x_hi:4, y_lo:4;\n\tuint8_t y_hi;\n} __packed;\nstatic_assert(sizeof(struct dualsense_touch_point) == 4);\n\n \nstruct dualsense_input_report {\n\tuint8_t x, y;\n\tuint8_t rx, ry;\n\tuint8_t z, rz;\n\tuint8_t seq_number;\n\tuint8_t buttons[4];\n\tuint8_t reserved[4];\n\n\t \n\t__le16 gyro[3];  \n\t__le16 accel[3];  \n\t__le32 sensor_timestamp;\n\tuint8_t reserved2;\n\n\t \n\tstruct dualsense_touch_point points[2];\n\n\tuint8_t reserved3[12];\n\tuint8_t status;\n\tuint8_t reserved4[10];\n} __packed;\n \nstatic_assert(sizeof(struct dualsense_input_report) == DS_INPUT_REPORT_USB_SIZE - 1);\n\n \nstruct dualsense_output_report_common {\n\tuint8_t valid_flag0;\n\tuint8_t valid_flag1;\n\n\t \n\tuint8_t motor_right;\n\tuint8_t motor_left;\n\n\t \n\tuint8_t reserved[4];\n\tuint8_t mute_button_led;\n\n\tuint8_t power_save_control;\n\tuint8_t reserved2[28];\n\n\t \n\tuint8_t valid_flag2;\n\tuint8_t reserved3[2];\n\tuint8_t lightbar_setup;\n\tuint8_t led_brightness;\n\tuint8_t player_leds;\n\tuint8_t lightbar_red;\n\tuint8_t lightbar_green;\n\tuint8_t lightbar_blue;\n} __packed;\nstatic_assert(sizeof(struct dualsense_output_report_common) == 47);\n\nstruct dualsense_output_report_bt {\n\tuint8_t report_id;  \n\tuint8_t seq_tag;\n\tuint8_t tag;\n\tstruct dualsense_output_report_common common;\n\tuint8_t reserved[24];\n\t__le32 crc32;\n} __packed;\nstatic_assert(sizeof(struct dualsense_output_report_bt) == DS_OUTPUT_REPORT_BT_SIZE);\n\nstruct dualsense_output_report_usb {\n\tuint8_t report_id;  \n\tstruct dualsense_output_report_common common;\n\tuint8_t reserved[15];\n} __packed;\nstatic_assert(sizeof(struct dualsense_output_report_usb) == DS_OUTPUT_REPORT_USB_SIZE);\n\n \nstruct dualsense_output_report {\n\tuint8_t *data;  \n\tuint8_t len;  \n\n\t \n\tstruct dualsense_output_report_bt *bt;\n\t \n\tstruct dualsense_output_report_usb *usb;\n\t \n\tstruct dualsense_output_report_common *common;\n};\n\n#define DS4_INPUT_REPORT_USB\t\t\t0x01\n#define DS4_INPUT_REPORT_USB_SIZE\t\t64\n#define DS4_INPUT_REPORT_BT\t\t\t0x11\n#define DS4_INPUT_REPORT_BT_SIZE\t\t78\n#define DS4_OUTPUT_REPORT_USB\t\t\t0x05\n#define DS4_OUTPUT_REPORT_USB_SIZE\t\t32\n#define DS4_OUTPUT_REPORT_BT\t\t\t0x11\n#define DS4_OUTPUT_REPORT_BT_SIZE\t\t78\n\n#define DS4_FEATURE_REPORT_CALIBRATION\t\t0x02\n#define DS4_FEATURE_REPORT_CALIBRATION_SIZE\t37\n#define DS4_FEATURE_REPORT_CALIBRATION_BT\t0x05\n#define DS4_FEATURE_REPORT_CALIBRATION_BT_SIZE\t41\n#define DS4_FEATURE_REPORT_FIRMWARE_INFO\t0xa3\n#define DS4_FEATURE_REPORT_FIRMWARE_INFO_SIZE\t49\n#define DS4_FEATURE_REPORT_PAIRING_INFO\t\t0x12\n#define DS4_FEATURE_REPORT_PAIRING_INFO_SIZE\t16\n\n \n#define DS4_TOUCH_POINT_INACTIVE BIT(7)\n\n \n#define DS4_STATUS0_BATTERY_CAPACITY\tGENMASK(3, 0)\n#define DS4_STATUS0_CABLE_STATE\t\tBIT(4)\n \n#define DS4_BATTERY_STATUS_FULL\t\t11\n \n#define DS4_STATUS1_DONGLE_STATE\tBIT(2)\n\n \n#define DS4_OUTPUT_HWCTL_BT_POLL_MASK\t0x3F\n \n#define DS4_BT_DEFAULT_POLL_INTERVAL_MS\t4\n#define DS4_OUTPUT_HWCTL_CRC32\t\t0x40\n#define DS4_OUTPUT_HWCTL_HID\t\t0x80\n\n \n#define DS4_OUTPUT_VALID_FLAG0_MOTOR\t\t0x01\n#define DS4_OUTPUT_VALID_FLAG0_LED\t\t0x02\n#define DS4_OUTPUT_VALID_FLAG0_LED_BLINK\t0x04\n\n \n#define DS4_ACC_RES_PER_G\t8192\n#define DS4_ACC_RANGE\t\t(4*DS_ACC_RES_PER_G)\n#define DS4_GYRO_RES_PER_DEG_S\t1024\n#define DS4_GYRO_RANGE\t\t(2048*DS_GYRO_RES_PER_DEG_S)\n#define DS4_LIGHTBAR_MAX_BLINK\t255  \n#define DS4_TOUCHPAD_WIDTH\t1920\n#define DS4_TOUCHPAD_HEIGHT\t942\n\nenum dualshock4_dongle_state {\n\tDONGLE_DISCONNECTED,\n\tDONGLE_CALIBRATING,\n\tDONGLE_CONNECTED,\n\tDONGLE_DISABLED\n};\n\nstruct dualshock4 {\n\tstruct ps_device base;\n\tstruct input_dev *gamepad;\n\tstruct input_dev *sensors;\n\tstruct input_dev *touchpad;\n\n\t \n\tstruct ps_calibration_data accel_calib_data[3];\n\tstruct ps_calibration_data gyro_calib_data[3];\n\n\t \n\tenum dualshock4_dongle_state dongle_state;\n\t \n\tstruct work_struct dongle_hotplug_worker;\n\n\t \n\tbool sensor_timestamp_initialized;\n\tuint32_t prev_sensor_timestamp;\n\tuint32_t sensor_timestamp_us;\n\n\t \n\tbool update_bt_poll_interval;\n\tuint8_t bt_poll_interval;\n\n\tbool update_rumble;\n\tuint8_t motor_left;\n\tuint8_t motor_right;\n\n\t \n\tbool update_lightbar;\n\tbool update_lightbar_blink;\n\tbool lightbar_enabled;  \n\tuint8_t lightbar_red;\n\tuint8_t lightbar_green;\n\tuint8_t lightbar_blue;\n\tuint8_t lightbar_blink_on;  \n\tuint8_t lightbar_blink_off;  \n\tstruct led_classdev lightbar_leds[4];\n\n\tstruct work_struct output_worker;\n\tbool output_worker_initialized;\n\tvoid *output_report_dmabuf;\n};\n\nstruct dualshock4_touch_point {\n\tuint8_t contact;\n\tuint8_t x_lo;\n\tuint8_t x_hi:4, y_lo:4;\n\tuint8_t y_hi;\n} __packed;\nstatic_assert(sizeof(struct dualshock4_touch_point) == 4);\n\nstruct dualshock4_touch_report {\n\tuint8_t timestamp;\n\tstruct dualshock4_touch_point points[2];\n} __packed;\nstatic_assert(sizeof(struct dualshock4_touch_report) == 9);\n\n \nstruct dualshock4_input_report_common {\n\tuint8_t x, y;\n\tuint8_t rx, ry;\n\tuint8_t buttons[3];\n\tuint8_t z, rz;\n\n\t \n\t__le16 sensor_timestamp;\n\tuint8_t sensor_temperature;\n\t__le16 gyro[3];  \n\t__le16 accel[3];  \n\tuint8_t reserved2[5];\n\n\tuint8_t status[2];\n\tuint8_t reserved3;\n} __packed;\nstatic_assert(sizeof(struct dualshock4_input_report_common) == 32);\n\nstruct dualshock4_input_report_usb {\n\tuint8_t report_id;  \n\tstruct dualshock4_input_report_common common;\n\tuint8_t num_touch_reports;\n\tstruct dualshock4_touch_report touch_reports[3];\n\tuint8_t reserved[3];\n} __packed;\nstatic_assert(sizeof(struct dualshock4_input_report_usb) == DS4_INPUT_REPORT_USB_SIZE);\n\nstruct dualshock4_input_report_bt {\n\tuint8_t report_id;  \n\tuint8_t reserved[2];\n\tstruct dualshock4_input_report_common common;\n\tuint8_t num_touch_reports;\n\tstruct dualshock4_touch_report touch_reports[4];  \n\tuint8_t reserved2[2];\n\t__le32 crc32;\n} __packed;\nstatic_assert(sizeof(struct dualshock4_input_report_bt) == DS4_INPUT_REPORT_BT_SIZE);\n\n \nstruct dualshock4_output_report_common {\n\tuint8_t valid_flag0;\n\tuint8_t valid_flag1;\n\n\tuint8_t reserved;\n\n\tuint8_t motor_right;\n\tuint8_t motor_left;\n\n\tuint8_t lightbar_red;\n\tuint8_t lightbar_green;\n\tuint8_t lightbar_blue;\n\tuint8_t lightbar_blink_on;\n\tuint8_t lightbar_blink_off;\n} __packed;\n\nstruct dualshock4_output_report_usb {\n\tuint8_t report_id;  \n\tstruct dualshock4_output_report_common common;\n\tuint8_t reserved[21];\n} __packed;\nstatic_assert(sizeof(struct dualshock4_output_report_usb) == DS4_OUTPUT_REPORT_USB_SIZE);\n\nstruct dualshock4_output_report_bt {\n\tuint8_t report_id;  \n\tuint8_t hw_control;\n\tuint8_t audio_control;\n\tstruct dualshock4_output_report_common common;\n\tuint8_t reserved[61];\n\t__le32 crc32;\n} __packed;\nstatic_assert(sizeof(struct dualshock4_output_report_bt) == DS4_OUTPUT_REPORT_BT_SIZE);\n\n \nstruct dualshock4_output_report {\n\tuint8_t *data;  \n\tuint8_t len;  \n\n\t \n\tstruct dualshock4_output_report_bt *bt;\n\t \n\tstruct dualshock4_output_report_usb *usb;\n\t \n\tstruct dualshock4_output_report_common *common;\n};\n\n \nstatic const int ps_gamepad_buttons[] = {\n\tBTN_WEST,  \n\tBTN_NORTH,  \n\tBTN_EAST,  \n\tBTN_SOUTH,  \n\tBTN_TL,  \n\tBTN_TR,  \n\tBTN_TL2,  \n\tBTN_TR2,  \n\tBTN_SELECT,  \n\tBTN_START,  \n\tBTN_THUMBL,  \n\tBTN_THUMBR,  \n\tBTN_MODE,  \n};\n\nstatic const struct {int x; int y; } ps_gamepad_hat_mapping[] = {\n\t{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1},\n\t{0, 0},\n};\n\nstatic int dualshock4_get_calibration_data(struct dualshock4 *ds4);\nstatic inline void dualsense_schedule_work(struct dualsense *ds);\nstatic inline void dualshock4_schedule_work(struct dualshock4 *ds4);\nstatic void dualsense_set_lightbar(struct dualsense *ds, uint8_t red, uint8_t green, uint8_t blue);\nstatic void dualshock4_set_default_lightbar_colors(struct dualshock4 *ds4);\n\n \nstatic int ps_devices_list_add(struct ps_device *dev)\n{\n\tstruct ps_device *entry;\n\n\tmutex_lock(&ps_devices_lock);\n\tlist_for_each_entry(entry, &ps_devices_list, list) {\n\t\tif (!memcmp(entry->mac_address, dev->mac_address, sizeof(dev->mac_address))) {\n\t\t\thid_err(dev->hdev, \"Duplicate device found for MAC address %pMR.\\n\",\n\t\t\t\t\tdev->mac_address);\n\t\t\tmutex_unlock(&ps_devices_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tlist_add_tail(&dev->list, &ps_devices_list);\n\tmutex_unlock(&ps_devices_lock);\n\treturn 0;\n}\n\nstatic int ps_devices_list_remove(struct ps_device *dev)\n{\n\tmutex_lock(&ps_devices_lock);\n\tlist_del(&dev->list);\n\tmutex_unlock(&ps_devices_lock);\n\treturn 0;\n}\n\nstatic int ps_device_set_player_id(struct ps_device *dev)\n{\n\tint ret = ida_alloc(&ps_player_id_allocator, GFP_KERNEL);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev->player_id = ret;\n\treturn 0;\n}\n\nstatic void ps_device_release_player_id(struct ps_device *dev)\n{\n\tida_free(&ps_player_id_allocator, dev->player_id);\n\n\tdev->player_id = U32_MAX;\n}\n\nstatic struct input_dev *ps_allocate_input_dev(struct hid_device *hdev, const char *name_suffix)\n{\n\tstruct input_dev *input_dev;\n\n\tinput_dev = devm_input_allocate_device(&hdev->dev);\n\tif (!input_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinput_dev->id.bustype = hdev->bus;\n\tinput_dev->id.vendor = hdev->vendor;\n\tinput_dev->id.product = hdev->product;\n\tinput_dev->id.version = hdev->version;\n\tinput_dev->uniq = hdev->uniq;\n\n\tif (name_suffix) {\n\t\tinput_dev->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, \"%s %s\", hdev->name,\n\t\t\t\tname_suffix);\n\t\tif (!input_dev->name)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t} else {\n\t\tinput_dev->name = hdev->name;\n\t}\n\n\tinput_set_drvdata(input_dev, hdev);\n\n\treturn input_dev;\n}\n\nstatic enum power_supply_property ps_power_supply_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_SCOPE,\n};\n\nstatic int ps_battery_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tunion power_supply_propval *val)\n{\n\tstruct ps_device *dev = power_supply_get_drvdata(psy);\n\tuint8_t battery_capacity;\n\tint battery_status;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbattery_capacity = dev->battery_capacity;\n\tbattery_status = dev->battery_status;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = battery_status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = battery_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ps_device_register_battery(struct ps_device *dev)\n{\n\tstruct power_supply *battery;\n\tstruct power_supply_config battery_cfg = { .drv_data = dev };\n\tint ret;\n\n\tdev->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tdev->battery_desc.properties = ps_power_supply_props;\n\tdev->battery_desc.num_properties = ARRAY_SIZE(ps_power_supply_props);\n\tdev->battery_desc.get_property = ps_battery_get_property;\n\tdev->battery_desc.name = devm_kasprintf(&dev->hdev->dev, GFP_KERNEL,\n\t\t\t\"ps-controller-battery-%pMR\", dev->mac_address);\n\tif (!dev->battery_desc.name)\n\t\treturn -ENOMEM;\n\n\tbattery = devm_power_supply_register(&dev->hdev->dev, &dev->battery_desc, &battery_cfg);\n\tif (IS_ERR(battery)) {\n\t\tret = PTR_ERR(battery);\n\t\thid_err(dev->hdev, \"Unable to register battery device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev->battery = battery;\n\n\tret = power_supply_powers(dev->battery, &dev->hdev->dev);\n\tif (ret) {\n\t\thid_err(dev->hdev, \"Unable to activate battery device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool ps_check_crc32(uint8_t seed, uint8_t *data, size_t len, uint32_t report_crc)\n{\n\tuint32_t crc;\n\n\tcrc = crc32_le(0xFFFFFFFF, &seed, 1);\n\tcrc = ~crc32_le(crc, data, len);\n\n\treturn crc == report_crc;\n}\n\nstatic struct input_dev *ps_gamepad_create(struct hid_device *hdev,\n\t\tint (*play_effect)(struct input_dev *, void *, struct ff_effect *))\n{\n\tstruct input_dev *gamepad;\n\tunsigned int i;\n\tint ret;\n\n\tgamepad = ps_allocate_input_dev(hdev, NULL);\n\tif (IS_ERR(gamepad))\n\t\treturn ERR_CAST(gamepad);\n\n\tinput_set_abs_params(gamepad, ABS_X, 0, 255, 0, 0);\n\tinput_set_abs_params(gamepad, ABS_Y, 0, 255, 0, 0);\n\tinput_set_abs_params(gamepad, ABS_Z, 0, 255, 0, 0);\n\tinput_set_abs_params(gamepad, ABS_RX, 0, 255, 0, 0);\n\tinput_set_abs_params(gamepad, ABS_RY, 0, 255, 0, 0);\n\tinput_set_abs_params(gamepad, ABS_RZ, 0, 255, 0, 0);\n\n\tinput_set_abs_params(gamepad, ABS_HAT0X, -1, 1, 0, 0);\n\tinput_set_abs_params(gamepad, ABS_HAT0Y, -1, 1, 0, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(ps_gamepad_buttons); i++)\n\t\tinput_set_capability(gamepad, EV_KEY, ps_gamepad_buttons[i]);\n\n#if IS_ENABLED(CONFIG_PLAYSTATION_FF)\n\tif (play_effect) {\n\t\tinput_set_capability(gamepad, EV_FF, FF_RUMBLE);\n\t\tinput_ff_create_memless(gamepad, NULL, play_effect);\n\t}\n#endif\n\n\tret = input_register_device(gamepad);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn gamepad;\n}\n\nstatic int ps_get_report(struct hid_device *hdev, uint8_t report_id, uint8_t *buf, size_t size,\n\t\tbool check_crc)\n{\n\tint ret;\n\n\tret = hid_hw_raw_request(hdev, report_id, buf, size, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"Failed to retrieve feature with reportID %d: %d\\n\", report_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (ret != size) {\n\t\thid_err(hdev, \"Invalid byte count transferred, expected %zu got %d\\n\", size, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (buf[0] != report_id) {\n\t\thid_err(hdev, \"Invalid reportID received, expected %d got %d\\n\", report_id, buf[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdev->bus == BUS_BLUETOOTH && check_crc) {\n\t\t \n\t\tuint8_t crc_offset = size - 4;\n\t\tuint32_t report_crc = get_unaligned_le32(&buf[crc_offset]);\n\n\t\tif (!ps_check_crc32(PS_FEATURE_CRC32_SEED, buf, crc_offset, report_crc)) {\n\t\t\thid_err(hdev, \"CRC check failed for reportID=%d\\n\", report_id);\n\t\t\treturn -EILSEQ;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ps_led_register(struct ps_device *ps_dev, struct led_classdev *led,\n\t\tconst struct ps_led_info *led_info)\n{\n\tint ret;\n\n\tif (led_info->name) {\n\t\tled->name = devm_kasprintf(&ps_dev->hdev->dev, GFP_KERNEL,\n\t\t\t\t\"%s:%s:%s\", ps_dev->input_dev_name, led_info->color, led_info->name);\n\t} else {\n\t\t \n\t\tled->name = devm_kasprintf(&ps_dev->hdev->dev, GFP_KERNEL,\n\t\t\t\t\"%s:%s\", ps_dev->input_dev_name, led_info->color);\n\t}\n\n\tif (!led->name)\n\t\treturn -ENOMEM;\n\n\tled->brightness = 0;\n\tled->max_brightness = led_info->max_brightness;\n\tled->flags = LED_CORE_SUSPENDRESUME;\n\tled->brightness_get = led_info->brightness_get;\n\tled->brightness_set_blocking = led_info->brightness_set;\n\tled->blink_set = led_info->blink_set;\n\n\tret = devm_led_classdev_register(&ps_dev->hdev->dev, led);\n\tif (ret) {\n\t\thid_err(ps_dev->hdev, \"Failed to register LED %s: %d\\n\", led_info->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ps_lightbar_register(struct ps_device *ps_dev, struct led_classdev_mc *lightbar_mc_dev,\n\tint (*brightness_set)(struct led_classdev *, enum led_brightness))\n{\n\tstruct hid_device *hdev = ps_dev->hdev;\n\tstruct mc_subled *mc_led_info;\n\tstruct led_classdev *led_cdev;\n\tint ret;\n\n\tmc_led_info = devm_kmalloc_array(&hdev->dev, 3, sizeof(*mc_led_info),\n\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (!mc_led_info)\n\t\treturn -ENOMEM;\n\n\tmc_led_info[0].color_index = LED_COLOR_ID_RED;\n\tmc_led_info[1].color_index = LED_COLOR_ID_GREEN;\n\tmc_led_info[2].color_index = LED_COLOR_ID_BLUE;\n\n\tlightbar_mc_dev->subled_info = mc_led_info;\n\tlightbar_mc_dev->num_colors = 3;\n\n\tled_cdev = &lightbar_mc_dev->led_cdev;\n\tled_cdev->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, \"%s:rgb:indicator\",\n\t\t\tps_dev->input_dev_name);\n\tif (!led_cdev->name)\n\t\treturn -ENOMEM;\n\tled_cdev->brightness = 255;\n\tled_cdev->max_brightness = 255;\n\tled_cdev->brightness_set_blocking = brightness_set;\n\n\tret = devm_led_classdev_multicolor_register(&hdev->dev, lightbar_mc_dev);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"Cannot register multicolor LED device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct input_dev *ps_sensors_create(struct hid_device *hdev, int accel_range, int accel_res,\n\t\tint gyro_range, int gyro_res)\n{\n\tstruct input_dev *sensors;\n\tint ret;\n\n\tsensors = ps_allocate_input_dev(hdev, \"Motion Sensors\");\n\tif (IS_ERR(sensors))\n\t\treturn ERR_CAST(sensors);\n\n\t__set_bit(INPUT_PROP_ACCELEROMETER, sensors->propbit);\n\t__set_bit(EV_MSC, sensors->evbit);\n\t__set_bit(MSC_TIMESTAMP, sensors->mscbit);\n\n\t \n\tinput_set_abs_params(sensors, ABS_X, -accel_range, accel_range, 16, 0);\n\tinput_set_abs_params(sensors, ABS_Y, -accel_range, accel_range, 16, 0);\n\tinput_set_abs_params(sensors, ABS_Z, -accel_range, accel_range, 16, 0);\n\tinput_abs_set_res(sensors, ABS_X, accel_res);\n\tinput_abs_set_res(sensors, ABS_Y, accel_res);\n\tinput_abs_set_res(sensors, ABS_Z, accel_res);\n\n\t \n\tinput_set_abs_params(sensors, ABS_RX, -gyro_range, gyro_range, 16, 0);\n\tinput_set_abs_params(sensors, ABS_RY, -gyro_range, gyro_range, 16, 0);\n\tinput_set_abs_params(sensors, ABS_RZ, -gyro_range, gyro_range, 16, 0);\n\tinput_abs_set_res(sensors, ABS_RX, gyro_res);\n\tinput_abs_set_res(sensors, ABS_RY, gyro_res);\n\tinput_abs_set_res(sensors, ABS_RZ, gyro_res);\n\n\tret = input_register_device(sensors);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn sensors;\n}\n\nstatic struct input_dev *ps_touchpad_create(struct hid_device *hdev, int width, int height,\n\t\tunsigned int num_contacts)\n{\n\tstruct input_dev *touchpad;\n\tint ret;\n\n\ttouchpad = ps_allocate_input_dev(hdev, \"Touchpad\");\n\tif (IS_ERR(touchpad))\n\t\treturn ERR_CAST(touchpad);\n\n\t \n\tinput_set_capability(touchpad, EV_KEY, BTN_LEFT);\n\t__set_bit(INPUT_PROP_BUTTONPAD, touchpad->propbit);\n\n\tinput_set_abs_params(touchpad, ABS_MT_POSITION_X, 0, width - 1, 0, 0);\n\tinput_set_abs_params(touchpad, ABS_MT_POSITION_Y, 0, height - 1, 0, 0);\n\n\tret = input_mt_init_slots(touchpad, num_contacts, INPUT_MT_POINTER);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = input_register_device(touchpad);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn touchpad;\n}\n\nstatic ssize_t firmware_version_show(struct device *dev,\n\t\t\t\tstruct device_attribute\n\t\t\t\t*attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ps_device *ps_dev = hid_get_drvdata(hdev);\n\n\treturn sysfs_emit(buf, \"0x%08x\\n\", ps_dev->fw_version);\n}\n\nstatic DEVICE_ATTR_RO(firmware_version);\n\nstatic ssize_t hardware_version_show(struct device *dev,\n\t\t\t\tstruct device_attribute\n\t\t\t\t*attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ps_device *ps_dev = hid_get_drvdata(hdev);\n\n\treturn sysfs_emit(buf, \"0x%08x\\n\", ps_dev->hw_version);\n}\n\nstatic DEVICE_ATTR_RO(hardware_version);\n\nstatic struct attribute *ps_device_attrs[] = {\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_hardware_version.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(ps_device);\n\nstatic int dualsense_get_calibration_data(struct dualsense *ds)\n{\n\tstruct hid_device *hdev = ds->base.hdev;\n\tshort gyro_pitch_bias, gyro_pitch_plus, gyro_pitch_minus;\n\tshort gyro_yaw_bias, gyro_yaw_plus, gyro_yaw_minus;\n\tshort gyro_roll_bias, gyro_roll_plus, gyro_roll_minus;\n\tshort gyro_speed_plus, gyro_speed_minus;\n\tshort acc_x_plus, acc_x_minus;\n\tshort acc_y_plus, acc_y_minus;\n\tshort acc_z_plus, acc_z_minus;\n\tint speed_2x;\n\tint range_2g;\n\tint ret = 0;\n\tint i;\n\tuint8_t *buf;\n\n\tbuf = kzalloc(DS_FEATURE_REPORT_CALIBRATION_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = ps_get_report(ds->base.hdev, DS_FEATURE_REPORT_CALIBRATION, buf,\n\t\t\tDS_FEATURE_REPORT_CALIBRATION_SIZE, true);\n\tif (ret) {\n\t\thid_err(ds->base.hdev, \"Failed to retrieve DualSense calibration info: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tgyro_pitch_bias  = get_unaligned_le16(&buf[1]);\n\tgyro_yaw_bias    = get_unaligned_le16(&buf[3]);\n\tgyro_roll_bias   = get_unaligned_le16(&buf[5]);\n\tgyro_pitch_plus  = get_unaligned_le16(&buf[7]);\n\tgyro_pitch_minus = get_unaligned_le16(&buf[9]);\n\tgyro_yaw_plus    = get_unaligned_le16(&buf[11]);\n\tgyro_yaw_minus   = get_unaligned_le16(&buf[13]);\n\tgyro_roll_plus   = get_unaligned_le16(&buf[15]);\n\tgyro_roll_minus  = get_unaligned_le16(&buf[17]);\n\tgyro_speed_plus  = get_unaligned_le16(&buf[19]);\n\tgyro_speed_minus = get_unaligned_le16(&buf[21]);\n\tacc_x_plus       = get_unaligned_le16(&buf[23]);\n\tacc_x_minus      = get_unaligned_le16(&buf[25]);\n\tacc_y_plus       = get_unaligned_le16(&buf[27]);\n\tacc_y_minus      = get_unaligned_le16(&buf[29]);\n\tacc_z_plus       = get_unaligned_le16(&buf[31]);\n\tacc_z_minus      = get_unaligned_le16(&buf[33]);\n\n\t \n\tspeed_2x = (gyro_speed_plus + gyro_speed_minus);\n\tds->gyro_calib_data[0].abs_code = ABS_RX;\n\tds->gyro_calib_data[0].bias = 0;\n\tds->gyro_calib_data[0].sens_numer = speed_2x*DS_GYRO_RES_PER_DEG_S;\n\tds->gyro_calib_data[0].sens_denom = abs(gyro_pitch_plus - gyro_pitch_bias) +\n\t\t\tabs(gyro_pitch_minus - gyro_pitch_bias);\n\n\tds->gyro_calib_data[1].abs_code = ABS_RY;\n\tds->gyro_calib_data[1].bias = 0;\n\tds->gyro_calib_data[1].sens_numer = speed_2x*DS_GYRO_RES_PER_DEG_S;\n\tds->gyro_calib_data[1].sens_denom = abs(gyro_yaw_plus - gyro_yaw_bias) +\n\t\t\tabs(gyro_yaw_minus - gyro_yaw_bias);\n\n\tds->gyro_calib_data[2].abs_code = ABS_RZ;\n\tds->gyro_calib_data[2].bias = 0;\n\tds->gyro_calib_data[2].sens_numer = speed_2x*DS_GYRO_RES_PER_DEG_S;\n\tds->gyro_calib_data[2].sens_denom = abs(gyro_roll_plus - gyro_roll_bias) +\n\t\t\tabs(gyro_roll_minus - gyro_roll_bias);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ds->gyro_calib_data); i++) {\n\t\tif (ds->gyro_calib_data[i].sens_denom == 0) {\n\t\t\thid_warn(hdev, \"Invalid gyro calibration data for axis (%d), disabling calibration.\",\n\t\t\t\t\tds->gyro_calib_data[i].abs_code);\n\t\t\tds->gyro_calib_data[i].bias = 0;\n\t\t\tds->gyro_calib_data[i].sens_numer = DS_GYRO_RANGE;\n\t\t\tds->gyro_calib_data[i].sens_denom = S16_MAX;\n\t\t}\n\t}\n\n\t \n\trange_2g = acc_x_plus - acc_x_minus;\n\tds->accel_calib_data[0].abs_code = ABS_X;\n\tds->accel_calib_data[0].bias = acc_x_plus - range_2g / 2;\n\tds->accel_calib_data[0].sens_numer = 2*DS_ACC_RES_PER_G;\n\tds->accel_calib_data[0].sens_denom = range_2g;\n\n\trange_2g = acc_y_plus - acc_y_minus;\n\tds->accel_calib_data[1].abs_code = ABS_Y;\n\tds->accel_calib_data[1].bias = acc_y_plus - range_2g / 2;\n\tds->accel_calib_data[1].sens_numer = 2*DS_ACC_RES_PER_G;\n\tds->accel_calib_data[1].sens_denom = range_2g;\n\n\trange_2g = acc_z_plus - acc_z_minus;\n\tds->accel_calib_data[2].abs_code = ABS_Z;\n\tds->accel_calib_data[2].bias = acc_z_plus - range_2g / 2;\n\tds->accel_calib_data[2].sens_numer = 2*DS_ACC_RES_PER_G;\n\tds->accel_calib_data[2].sens_denom = range_2g;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ds->accel_calib_data); i++) {\n\t\tif (ds->accel_calib_data[i].sens_denom == 0) {\n\t\t\thid_warn(hdev, \"Invalid accelerometer calibration data for axis (%d), disabling calibration.\",\n\t\t\t\t\tds->accel_calib_data[i].abs_code);\n\t\t\tds->accel_calib_data[i].bias = 0;\n\t\t\tds->accel_calib_data[i].sens_numer = DS_ACC_RANGE;\n\t\t\tds->accel_calib_data[i].sens_denom = S16_MAX;\n\t\t}\n\t}\n\nerr_free:\n\tkfree(buf);\n\treturn ret;\n}\n\n\nstatic int dualsense_get_firmware_info(struct dualsense *ds)\n{\n\tuint8_t *buf;\n\tint ret;\n\n\tbuf = kzalloc(DS_FEATURE_REPORT_FIRMWARE_INFO_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = ps_get_report(ds->base.hdev, DS_FEATURE_REPORT_FIRMWARE_INFO, buf,\n\t\t\tDS_FEATURE_REPORT_FIRMWARE_INFO_SIZE, true);\n\tif (ret) {\n\t\thid_err(ds->base.hdev, \"Failed to retrieve DualSense firmware info: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tds->base.hw_version = get_unaligned_le32(&buf[24]);\n\tds->base.fw_version = get_unaligned_le32(&buf[28]);\n\n\t \n\tds->update_version = get_unaligned_le16(&buf[44]);\n\nerr_free:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dualsense_get_mac_address(struct dualsense *ds)\n{\n\tuint8_t *buf;\n\tint ret = 0;\n\n\tbuf = kzalloc(DS_FEATURE_REPORT_PAIRING_INFO_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = ps_get_report(ds->base.hdev, DS_FEATURE_REPORT_PAIRING_INFO, buf,\n\t\t\tDS_FEATURE_REPORT_PAIRING_INFO_SIZE, true);\n\tif (ret) {\n\t\thid_err(ds->base.hdev, \"Failed to retrieve DualSense pairing info: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tmemcpy(ds->base.mac_address, &buf[1], sizeof(ds->base.mac_address));\n\nerr_free:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dualsense_lightbar_set_brightness(struct led_classdev *cdev,\n\tenum led_brightness brightness)\n{\n\tstruct led_classdev_mc *mc_cdev = lcdev_to_mccdev(cdev);\n\tstruct dualsense *ds = container_of(mc_cdev, struct dualsense, lightbar);\n\tuint8_t red, green, blue;\n\n\tled_mc_calc_color_components(mc_cdev, brightness);\n\tred = mc_cdev->subled_info[0].brightness;\n\tgreen = mc_cdev->subled_info[1].brightness;\n\tblue = mc_cdev->subled_info[2].brightness;\n\n\tdualsense_set_lightbar(ds, red, green, blue);\n\treturn 0;\n}\n\nstatic enum led_brightness dualsense_player_led_get_brightness(struct led_classdev *led)\n{\n\tstruct hid_device *hdev = to_hid_device(led->dev->parent);\n\tstruct dualsense *ds = hid_get_drvdata(hdev);\n\n\treturn !!(ds->player_leds_state & BIT(led - ds->player_leds));\n}\n\nstatic int dualsense_player_led_set_brightness(struct led_classdev *led, enum led_brightness value)\n{\n\tstruct hid_device *hdev = to_hid_device(led->dev->parent);\n\tstruct dualsense *ds = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tunsigned int led_index;\n\n\tspin_lock_irqsave(&ds->base.lock, flags);\n\n\tled_index = led - ds->player_leds;\n\tif (value == LED_OFF)\n\t\tds->player_leds_state &= ~BIT(led_index);\n\telse\n\t\tds->player_leds_state |= BIT(led_index);\n\n\tds->update_player_leds = true;\n\tspin_unlock_irqrestore(&ds->base.lock, flags);\n\n\tdualsense_schedule_work(ds);\n\n\treturn 0;\n}\n\nstatic void dualsense_init_output_report(struct dualsense *ds, struct dualsense_output_report *rp,\n\t\tvoid *buf)\n{\n\tstruct hid_device *hdev = ds->base.hdev;\n\n\tif (hdev->bus == BUS_BLUETOOTH) {\n\t\tstruct dualsense_output_report_bt *bt = buf;\n\n\t\tmemset(bt, 0, sizeof(*bt));\n\t\tbt->report_id = DS_OUTPUT_REPORT_BT;\n\t\tbt->tag = DS_OUTPUT_TAG;  \n\n\t\t \n\t\tbt->seq_tag = (ds->output_seq << 4) | 0x0;\n\t\tif (++ds->output_seq == 16)\n\t\t\tds->output_seq = 0;\n\n\t\trp->data = buf;\n\t\trp->len = sizeof(*bt);\n\t\trp->bt = bt;\n\t\trp->usb = NULL;\n\t\trp->common = &bt->common;\n\t} else {  \n\t\tstruct dualsense_output_report_usb *usb = buf;\n\n\t\tmemset(usb, 0, sizeof(*usb));\n\t\tusb->report_id = DS_OUTPUT_REPORT_USB;\n\n\t\trp->data = buf;\n\t\trp->len = sizeof(*usb);\n\t\trp->bt = NULL;\n\t\trp->usb = usb;\n\t\trp->common = &usb->common;\n\t}\n}\n\nstatic inline void dualsense_schedule_work(struct dualsense *ds)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ds->base.lock, flags);\n\tif (ds->output_worker_initialized)\n\t\tschedule_work(&ds->output_worker);\n\tspin_unlock_irqrestore(&ds->base.lock, flags);\n}\n\n \nstatic void dualsense_send_output_report(struct dualsense *ds,\n\t\tstruct dualsense_output_report *report)\n{\n\tstruct hid_device *hdev = ds->base.hdev;\n\n\t \n\tif (report->bt) {\n\t\tuint32_t crc;\n\t\tuint8_t seed = PS_OUTPUT_CRC32_SEED;\n\n\t\tcrc = crc32_le(0xFFFFFFFF, &seed, 1);\n\t\tcrc = ~crc32_le(crc, report->data, report->len - 4);\n\n\t\treport->bt->crc32 = cpu_to_le32(crc);\n\t}\n\n\thid_hw_output_report(hdev, report->data, report->len);\n}\n\nstatic void dualsense_output_worker(struct work_struct *work)\n{\n\tstruct dualsense *ds = container_of(work, struct dualsense, output_worker);\n\tstruct dualsense_output_report report;\n\tstruct dualsense_output_report_common *common;\n\tunsigned long flags;\n\n\tdualsense_init_output_report(ds, &report, ds->output_report_dmabuf);\n\tcommon = report.common;\n\n\tspin_lock_irqsave(&ds->base.lock, flags);\n\n\tif (ds->update_rumble) {\n\t\t \n\t\tcommon->valid_flag0 |= DS_OUTPUT_VALID_FLAG0_HAPTICS_SELECT;\n\t\tif (ds->use_vibration_v2)\n\t\t\tcommon->valid_flag2 |= DS_OUTPUT_VALID_FLAG2_COMPATIBLE_VIBRATION2;\n\t\telse\n\t\t\tcommon->valid_flag0 |= DS_OUTPUT_VALID_FLAG0_COMPATIBLE_VIBRATION;\n\t\tcommon->motor_left = ds->motor_left;\n\t\tcommon->motor_right = ds->motor_right;\n\t\tds->update_rumble = false;\n\t}\n\n\tif (ds->update_lightbar) {\n\t\tcommon->valid_flag1 |= DS_OUTPUT_VALID_FLAG1_LIGHTBAR_CONTROL_ENABLE;\n\t\tcommon->lightbar_red = ds->lightbar_red;\n\t\tcommon->lightbar_green = ds->lightbar_green;\n\t\tcommon->lightbar_blue = ds->lightbar_blue;\n\n\t\tds->update_lightbar = false;\n\t}\n\n\tif (ds->update_player_leds) {\n\t\tcommon->valid_flag1 |= DS_OUTPUT_VALID_FLAG1_PLAYER_INDICATOR_CONTROL_ENABLE;\n\t\tcommon->player_leds = ds->player_leds_state;\n\n\t\tds->update_player_leds = false;\n\t}\n\n\tif (ds->update_mic_mute) {\n\t\tcommon->valid_flag1 |= DS_OUTPUT_VALID_FLAG1_MIC_MUTE_LED_CONTROL_ENABLE;\n\t\tcommon->mute_button_led = ds->mic_muted;\n\n\t\tif (ds->mic_muted) {\n\t\t\t \n\t\t\tcommon->valid_flag1 |= DS_OUTPUT_VALID_FLAG1_POWER_SAVE_CONTROL_ENABLE;\n\t\t\tcommon->power_save_control |= DS_OUTPUT_POWER_SAVE_CONTROL_MIC_MUTE;\n\t\t} else {\n\t\t\t \n\t\t\tcommon->valid_flag1 |= DS_OUTPUT_VALID_FLAG1_POWER_SAVE_CONTROL_ENABLE;\n\t\t\tcommon->power_save_control &= ~DS_OUTPUT_POWER_SAVE_CONTROL_MIC_MUTE;\n\t\t}\n\n\t\tds->update_mic_mute = false;\n\t}\n\n\tspin_unlock_irqrestore(&ds->base.lock, flags);\n\n\tdualsense_send_output_report(ds, &report);\n}\n\nstatic int dualsense_parse_report(struct ps_device *ps_dev, struct hid_report *report,\n\t\tu8 *data, int size)\n{\n\tstruct hid_device *hdev = ps_dev->hdev;\n\tstruct dualsense *ds = container_of(ps_dev, struct dualsense, base);\n\tstruct dualsense_input_report *ds_report;\n\tuint8_t battery_data, battery_capacity, charging_status, value;\n\tint battery_status;\n\tuint32_t sensor_timestamp;\n\tbool btn_mic_state;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tif (hdev->bus == BUS_USB && report->id == DS_INPUT_REPORT_USB &&\n\t\t\tsize == DS_INPUT_REPORT_USB_SIZE) {\n\t\tds_report = (struct dualsense_input_report *)&data[1];\n\t} else if (hdev->bus == BUS_BLUETOOTH && report->id == DS_INPUT_REPORT_BT &&\n\t\t\tsize == DS_INPUT_REPORT_BT_SIZE) {\n\t\t \n\t\tuint32_t report_crc = get_unaligned_le32(&data[size - 4]);\n\n\t\tif (!ps_check_crc32(PS_INPUT_CRC32_SEED, data, size - 4, report_crc)) {\n\t\t\thid_err(hdev, \"DualSense input CRC's check failed\\n\");\n\t\t\treturn -EILSEQ;\n\t\t}\n\n\t\tds_report = (struct dualsense_input_report *)&data[2];\n\t} else {\n\t\thid_err(hdev, \"Unhandled reportID=%d\\n\", report->id);\n\t\treturn -1;\n\t}\n\n\tinput_report_abs(ds->gamepad, ABS_X,  ds_report->x);\n\tinput_report_abs(ds->gamepad, ABS_Y,  ds_report->y);\n\tinput_report_abs(ds->gamepad, ABS_RX, ds_report->rx);\n\tinput_report_abs(ds->gamepad, ABS_RY, ds_report->ry);\n\tinput_report_abs(ds->gamepad, ABS_Z,  ds_report->z);\n\tinput_report_abs(ds->gamepad, ABS_RZ, ds_report->rz);\n\n\tvalue = ds_report->buttons[0] & DS_BUTTONS0_HAT_SWITCH;\n\tif (value >= ARRAY_SIZE(ps_gamepad_hat_mapping))\n\t\tvalue = 8;  \n\tinput_report_abs(ds->gamepad, ABS_HAT0X, ps_gamepad_hat_mapping[value].x);\n\tinput_report_abs(ds->gamepad, ABS_HAT0Y, ps_gamepad_hat_mapping[value].y);\n\n\tinput_report_key(ds->gamepad, BTN_WEST,   ds_report->buttons[0] & DS_BUTTONS0_SQUARE);\n\tinput_report_key(ds->gamepad, BTN_SOUTH,  ds_report->buttons[0] & DS_BUTTONS0_CROSS);\n\tinput_report_key(ds->gamepad, BTN_EAST,   ds_report->buttons[0] & DS_BUTTONS0_CIRCLE);\n\tinput_report_key(ds->gamepad, BTN_NORTH,  ds_report->buttons[0] & DS_BUTTONS0_TRIANGLE);\n\tinput_report_key(ds->gamepad, BTN_TL,     ds_report->buttons[1] & DS_BUTTONS1_L1);\n\tinput_report_key(ds->gamepad, BTN_TR,     ds_report->buttons[1] & DS_BUTTONS1_R1);\n\tinput_report_key(ds->gamepad, BTN_TL2,    ds_report->buttons[1] & DS_BUTTONS1_L2);\n\tinput_report_key(ds->gamepad, BTN_TR2,    ds_report->buttons[1] & DS_BUTTONS1_R2);\n\tinput_report_key(ds->gamepad, BTN_SELECT, ds_report->buttons[1] & DS_BUTTONS1_CREATE);\n\tinput_report_key(ds->gamepad, BTN_START,  ds_report->buttons[1] & DS_BUTTONS1_OPTIONS);\n\tinput_report_key(ds->gamepad, BTN_THUMBL, ds_report->buttons[1] & DS_BUTTONS1_L3);\n\tinput_report_key(ds->gamepad, BTN_THUMBR, ds_report->buttons[1] & DS_BUTTONS1_R3);\n\tinput_report_key(ds->gamepad, BTN_MODE,   ds_report->buttons[2] & DS_BUTTONS2_PS_HOME);\n\tinput_sync(ds->gamepad);\n\n\t \n\tbtn_mic_state = !!(ds_report->buttons[2] & DS_BUTTONS2_MIC_MUTE);\n\tif (btn_mic_state && !ds->last_btn_mic_state) {\n\t\tspin_lock_irqsave(&ps_dev->lock, flags);\n\t\tds->update_mic_mute = true;\n\t\tds->mic_muted = !ds->mic_muted;  \n\t\tspin_unlock_irqrestore(&ps_dev->lock, flags);\n\n\t\t \n\t\tdualsense_schedule_work(ds);\n\t}\n\tds->last_btn_mic_state = btn_mic_state;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ds_report->gyro); i++) {\n\t\tint raw_data = (short)le16_to_cpu(ds_report->gyro[i]);\n\t\tint calib_data = mult_frac(ds->gyro_calib_data[i].sens_numer,\n\t\t\t\t\t   raw_data, ds->gyro_calib_data[i].sens_denom);\n\n\t\tinput_report_abs(ds->sensors, ds->gyro_calib_data[i].abs_code, calib_data);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ds_report->accel); i++) {\n\t\tint raw_data = (short)le16_to_cpu(ds_report->accel[i]);\n\t\tint calib_data = mult_frac(ds->accel_calib_data[i].sens_numer,\n\t\t\t\t\t   raw_data - ds->accel_calib_data[i].bias,\n\t\t\t\t\t   ds->accel_calib_data[i].sens_denom);\n\n\t\tinput_report_abs(ds->sensors, ds->accel_calib_data[i].abs_code, calib_data);\n\t}\n\n\t \n\tsensor_timestamp = le32_to_cpu(ds_report->sensor_timestamp);\n\tif (!ds->sensor_timestamp_initialized) {\n\t\tds->sensor_timestamp_us = DIV_ROUND_CLOSEST(sensor_timestamp, 3);\n\t\tds->sensor_timestamp_initialized = true;\n\t} else {\n\t\tuint32_t delta;\n\n\t\tif (ds->prev_sensor_timestamp > sensor_timestamp)\n\t\t\tdelta = (U32_MAX - ds->prev_sensor_timestamp + sensor_timestamp + 1);\n\t\telse\n\t\t\tdelta = sensor_timestamp - ds->prev_sensor_timestamp;\n\t\tds->sensor_timestamp_us += DIV_ROUND_CLOSEST(delta, 3);\n\t}\n\tds->prev_sensor_timestamp = sensor_timestamp;\n\tinput_event(ds->sensors, EV_MSC, MSC_TIMESTAMP, ds->sensor_timestamp_us);\n\tinput_sync(ds->sensors);\n\n\tfor (i = 0; i < ARRAY_SIZE(ds_report->points); i++) {\n\t\tstruct dualsense_touch_point *point = &ds_report->points[i];\n\t\tbool active = (point->contact & DS_TOUCH_POINT_INACTIVE) ? false : true;\n\n\t\tinput_mt_slot(ds->touchpad, i);\n\t\tinput_mt_report_slot_state(ds->touchpad, MT_TOOL_FINGER, active);\n\n\t\tif (active) {\n\t\t\tint x = (point->x_hi << 8) | point->x_lo;\n\t\t\tint y = (point->y_hi << 4) | point->y_lo;\n\n\t\t\tinput_report_abs(ds->touchpad, ABS_MT_POSITION_X, x);\n\t\t\tinput_report_abs(ds->touchpad, ABS_MT_POSITION_Y, y);\n\t\t}\n\t}\n\tinput_mt_sync_frame(ds->touchpad);\n\tinput_report_key(ds->touchpad, BTN_LEFT, ds_report->buttons[2] & DS_BUTTONS2_TOUCHPAD);\n\tinput_sync(ds->touchpad);\n\n\tbattery_data = ds_report->status & DS_STATUS_BATTERY_CAPACITY;\n\tcharging_status = (ds_report->status & DS_STATUS_CHARGING) >> DS_STATUS_CHARGING_SHIFT;\n\n\tswitch (charging_status) {\n\tcase 0x0:\n\t\t \n\t\tbattery_capacity = min(battery_data * 10 + 5, 100);\n\t\tbattery_status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase 0x1:\n\t\tbattery_capacity = min(battery_data * 10 + 5, 100);\n\t\tbattery_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase 0x2:\n\t\tbattery_capacity = 100;\n\t\tbattery_status = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase 0xa:  \n\tcase 0xb:  \n\t\tbattery_capacity = 0;\n\t\tbattery_status = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\tcase 0xf:  \n\tdefault:\n\t\tbattery_capacity = 0;\n\t\tbattery_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t}\n\n\tspin_lock_irqsave(&ps_dev->lock, flags);\n\tps_dev->battery_capacity = battery_capacity;\n\tps_dev->battery_status = battery_status;\n\tspin_unlock_irqrestore(&ps_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int dualsense_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)\n{\n\tstruct hid_device *hdev = input_get_drvdata(dev);\n\tstruct dualsense *ds = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tif (effect->type != FF_RUMBLE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ds->base.lock, flags);\n\tds->update_rumble = true;\n\tds->motor_left = effect->u.rumble.strong_magnitude / 256;\n\tds->motor_right = effect->u.rumble.weak_magnitude / 256;\n\tspin_unlock_irqrestore(&ds->base.lock, flags);\n\n\tdualsense_schedule_work(ds);\n\treturn 0;\n}\n\nstatic void dualsense_remove(struct ps_device *ps_dev)\n{\n\tstruct dualsense *ds = container_of(ps_dev, struct dualsense, base);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ds->base.lock, flags);\n\tds->output_worker_initialized = false;\n\tspin_unlock_irqrestore(&ds->base.lock, flags);\n\n\tcancel_work_sync(&ds->output_worker);\n}\n\nstatic int dualsense_reset_leds(struct dualsense *ds)\n{\n\tstruct dualsense_output_report report;\n\tuint8_t *buf;\n\n\tbuf = kzalloc(sizeof(struct dualsense_output_report_bt), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdualsense_init_output_report(ds, &report, buf);\n\t \n\treport.common->valid_flag2 = DS_OUTPUT_VALID_FLAG2_LIGHTBAR_SETUP_CONTROL_ENABLE;\n\treport.common->lightbar_setup = DS_OUTPUT_LIGHTBAR_SETUP_LIGHT_OUT;  \n\tdualsense_send_output_report(ds, &report);\n\n\tkfree(buf);\n\treturn 0;\n}\n\nstatic void dualsense_set_lightbar(struct dualsense *ds, uint8_t red, uint8_t green, uint8_t blue)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ds->base.lock, flags);\n\tds->update_lightbar = true;\n\tds->lightbar_red = red;\n\tds->lightbar_green = green;\n\tds->lightbar_blue = blue;\n\tspin_unlock_irqrestore(&ds->base.lock, flags);\n\n\tdualsense_schedule_work(ds);\n}\n\nstatic void dualsense_set_player_leds(struct dualsense *ds)\n{\n\t \n\tstatic const int player_ids[5] = {\n\t\tBIT(2),\n\t\tBIT(3) | BIT(1),\n\t\tBIT(4) | BIT(2) | BIT(0),\n\t\tBIT(4) | BIT(3) | BIT(1) | BIT(0),\n\t\tBIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0)\n\t};\n\n\tuint8_t player_id = ds->base.player_id % ARRAY_SIZE(player_ids);\n\n\tds->update_player_leds = true;\n\tds->player_leds_state = player_ids[player_id];\n\tdualsense_schedule_work(ds);\n}\n\nstatic struct ps_device *dualsense_create(struct hid_device *hdev)\n{\n\tstruct dualsense *ds;\n\tstruct ps_device *ps_dev;\n\tuint8_t max_output_report_size;\n\tint i, ret;\n\n\tstatic const struct ps_led_info player_leds_info[] = {\n\t\t{ LED_FUNCTION_PLAYER1, \"white\", 1, dualsense_player_led_get_brightness,\n\t\t\t\tdualsense_player_led_set_brightness },\n\t\t{ LED_FUNCTION_PLAYER2, \"white\", 1, dualsense_player_led_get_brightness,\n\t\t\t\tdualsense_player_led_set_brightness },\n\t\t{ LED_FUNCTION_PLAYER3, \"white\", 1, dualsense_player_led_get_brightness,\n\t\t\t\tdualsense_player_led_set_brightness },\n\t\t{ LED_FUNCTION_PLAYER4, \"white\", 1, dualsense_player_led_get_brightness,\n\t\t\t\tdualsense_player_led_set_brightness },\n\t\t{ LED_FUNCTION_PLAYER5, \"white\", 1, dualsense_player_led_get_brightness,\n\t\t\t\tdualsense_player_led_set_brightness }\n\t};\n\n\tds = devm_kzalloc(&hdev->dev, sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\thdev->version |= HID_PLAYSTATION_VERSION_PATCH;\n\n\tps_dev = &ds->base;\n\tps_dev->hdev = hdev;\n\tspin_lock_init(&ps_dev->lock);\n\tps_dev->battery_capacity = 100;  \n\tps_dev->battery_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\tps_dev->parse_report = dualsense_parse_report;\n\tps_dev->remove = dualsense_remove;\n\tINIT_WORK(&ds->output_worker, dualsense_output_worker);\n\tds->output_worker_initialized = true;\n\thid_set_drvdata(hdev, ds);\n\n\tmax_output_report_size = sizeof(struct dualsense_output_report_bt);\n\tds->output_report_dmabuf = devm_kzalloc(&hdev->dev, max_output_report_size, GFP_KERNEL);\n\tif (!ds->output_report_dmabuf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = dualsense_get_mac_address(ds);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to get MAC address from DualSense\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\tsnprintf(hdev->uniq, sizeof(hdev->uniq), \"%pMR\", ds->base.mac_address);\n\n\tret = dualsense_get_firmware_info(ds);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to get firmware info from DualSense\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tif (hdev->product == USB_DEVICE_ID_SONY_PS5_CONTROLLER) {\n\t\t \n\t\tds->use_vibration_v2 = ds->update_version >= DS_FEATURE_VERSION(2, 21);\n\t} else if (hdev->product == USB_DEVICE_ID_SONY_PS5_CONTROLLER_2) {\n\t\tds->use_vibration_v2 = true;\n\t}\n\n\tret = ps_devices_list_add(ps_dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = dualsense_get_calibration_data(ds);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to get calibration data from DualSense\\n\");\n\t\tgoto err;\n\t}\n\n\tds->gamepad = ps_gamepad_create(hdev, dualsense_play_effect);\n\tif (IS_ERR(ds->gamepad)) {\n\t\tret = PTR_ERR(ds->gamepad);\n\t\tgoto err;\n\t}\n\t \n\tps_dev->input_dev_name = dev_name(&ds->gamepad->dev);\n\n\tds->sensors = ps_sensors_create(hdev, DS_ACC_RANGE, DS_ACC_RES_PER_G,\n\t\t\tDS_GYRO_RANGE, DS_GYRO_RES_PER_DEG_S);\n\tif (IS_ERR(ds->sensors)) {\n\t\tret = PTR_ERR(ds->sensors);\n\t\tgoto err;\n\t}\n\n\tds->touchpad = ps_touchpad_create(hdev, DS_TOUCHPAD_WIDTH, DS_TOUCHPAD_HEIGHT, 2);\n\tif (IS_ERR(ds->touchpad)) {\n\t\tret = PTR_ERR(ds->touchpad);\n\t\tgoto err;\n\t}\n\n\tret = ps_device_register_battery(ps_dev);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = dualsense_reset_leds(ds);\n\tif (ret)\n\t\tgoto err;\n\n\tret = ps_lightbar_register(ps_dev, &ds->lightbar, dualsense_lightbar_set_brightness);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tdualsense_set_lightbar(ds, 0, 0, 128);  \n\n\tfor (i = 0; i < ARRAY_SIZE(player_leds_info); i++) {\n\t\tconst struct ps_led_info *led_info = &player_leds_info[i];\n\n\t\tret = ps_led_register(ps_dev, &ds->player_leds[i], led_info);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tret = ps_device_set_player_id(ps_dev);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to assign player id for DualSense: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tdualsense_set_player_leds(ds);\n\n\t \n\thid_info(hdev, \"Registered DualSense controller hw_version=0x%08x fw_version=0x%08x\\n\",\n\t\t\tds->base.hw_version, ds->base.fw_version);\n\n\treturn &ds->base;\n\nerr:\n\tps_devices_list_remove(ps_dev);\n\treturn ERR_PTR(ret);\n}\n\nstatic void dualshock4_dongle_calibration_work(struct work_struct *work)\n{\n\tstruct dualshock4 *ds4 = container_of(work, struct dualshock4, dongle_hotplug_worker);\n\tunsigned long flags;\n\tenum dualshock4_dongle_state dongle_state;\n\tint ret;\n\n\tret = dualshock4_get_calibration_data(ds4);\n\tif (ret < 0) {\n\t\t \n\t\thid_err(ds4->base.hdev, \"DualShock 4 USB dongle: calibration failed, disabling device\\n\");\n\t\tdongle_state = DONGLE_DISABLED;\n\t} else {\n\t\thid_info(ds4->base.hdev, \"DualShock 4 USB dongle: calibration completed\\n\");\n\t\tdongle_state = DONGLE_CONNECTED;\n\t}\n\n\tspin_lock_irqsave(&ds4->base.lock, flags);\n\tds4->dongle_state = dongle_state;\n\tspin_unlock_irqrestore(&ds4->base.lock, flags);\n}\n\nstatic int dualshock4_get_calibration_data(struct dualshock4 *ds4)\n{\n\tstruct hid_device *hdev = ds4->base.hdev;\n\tshort gyro_pitch_bias, gyro_pitch_plus, gyro_pitch_minus;\n\tshort gyro_yaw_bias, gyro_yaw_plus, gyro_yaw_minus;\n\tshort gyro_roll_bias, gyro_roll_plus, gyro_roll_minus;\n\tshort gyro_speed_plus, gyro_speed_minus;\n\tshort acc_x_plus, acc_x_minus;\n\tshort acc_y_plus, acc_y_minus;\n\tshort acc_z_plus, acc_z_minus;\n\tint speed_2x;\n\tint range_2g;\n\tint ret = 0;\n\tint i;\n\tuint8_t *buf;\n\n\tif (ds4->base.hdev->bus == BUS_USB) {\n\t\tint retries;\n\n\t\tbuf = kzalloc(DS4_FEATURE_REPORT_CALIBRATION_SIZE, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tfor (retries = 0; retries < 3; retries++) {\n\t\t\tret = ps_get_report(hdev, DS4_FEATURE_REPORT_CALIBRATION, buf,\n\t\t\t\t\tDS4_FEATURE_REPORT_CALIBRATION_SIZE, true);\n\t\t\tif (ret) {\n\t\t\t\tif (retries < 2) {\n\t\t\t\t\thid_warn(hdev, \"Retrying DualShock 4 get calibration report (0x02) request\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\thid_err(hdev, \"Failed to retrieve DualShock4 calibration info: %d\\n\", ret);\n\t\t\t\tret = -EILSEQ;\n\t\t\t\tgoto err_free;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {  \n\t\tbuf = kzalloc(DS4_FEATURE_REPORT_CALIBRATION_BT_SIZE, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tret = ps_get_report(hdev, DS4_FEATURE_REPORT_CALIBRATION_BT, buf,\n\t\t\t\tDS4_FEATURE_REPORT_CALIBRATION_BT_SIZE, true);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Failed to retrieve DualShock4 calibration info: %d\\n\", ret);\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tgyro_pitch_bias  = get_unaligned_le16(&buf[1]);\n\tgyro_yaw_bias    = get_unaligned_le16(&buf[3]);\n\tgyro_roll_bias   = get_unaligned_le16(&buf[5]);\n\tif (ds4->base.hdev->bus == BUS_USB) {\n\t\tgyro_pitch_plus  = get_unaligned_le16(&buf[7]);\n\t\tgyro_pitch_minus = get_unaligned_le16(&buf[9]);\n\t\tgyro_yaw_plus    = get_unaligned_le16(&buf[11]);\n\t\tgyro_yaw_minus   = get_unaligned_le16(&buf[13]);\n\t\tgyro_roll_plus   = get_unaligned_le16(&buf[15]);\n\t\tgyro_roll_minus  = get_unaligned_le16(&buf[17]);\n\t} else {\n\t\t \n\t\tgyro_pitch_plus  = get_unaligned_le16(&buf[7]);\n\t\tgyro_yaw_plus    = get_unaligned_le16(&buf[9]);\n\t\tgyro_roll_plus   = get_unaligned_le16(&buf[11]);\n\t\tgyro_pitch_minus = get_unaligned_le16(&buf[13]);\n\t\tgyro_yaw_minus   = get_unaligned_le16(&buf[15]);\n\t\tgyro_roll_minus  = get_unaligned_le16(&buf[17]);\n\t}\n\tgyro_speed_plus  = get_unaligned_le16(&buf[19]);\n\tgyro_speed_minus = get_unaligned_le16(&buf[21]);\n\tacc_x_plus       = get_unaligned_le16(&buf[23]);\n\tacc_x_minus      = get_unaligned_le16(&buf[25]);\n\tacc_y_plus       = get_unaligned_le16(&buf[27]);\n\tacc_y_minus      = get_unaligned_le16(&buf[29]);\n\tacc_z_plus       = get_unaligned_le16(&buf[31]);\n\tacc_z_minus      = get_unaligned_le16(&buf[33]);\n\n\t \n\tspeed_2x = (gyro_speed_plus + gyro_speed_minus);\n\tds4->gyro_calib_data[0].abs_code = ABS_RX;\n\tds4->gyro_calib_data[0].bias = 0;\n\tds4->gyro_calib_data[0].sens_numer = speed_2x*DS4_GYRO_RES_PER_DEG_S;\n\tds4->gyro_calib_data[0].sens_denom = abs(gyro_pitch_plus - gyro_pitch_bias) +\n\t\t\tabs(gyro_pitch_minus - gyro_pitch_bias);\n\n\tds4->gyro_calib_data[1].abs_code = ABS_RY;\n\tds4->gyro_calib_data[1].bias = 0;\n\tds4->gyro_calib_data[1].sens_numer = speed_2x*DS4_GYRO_RES_PER_DEG_S;\n\tds4->gyro_calib_data[1].sens_denom = abs(gyro_yaw_plus - gyro_yaw_bias) +\n\t\t\tabs(gyro_yaw_minus - gyro_yaw_bias);\n\n\tds4->gyro_calib_data[2].abs_code = ABS_RZ;\n\tds4->gyro_calib_data[2].bias = 0;\n\tds4->gyro_calib_data[2].sens_numer = speed_2x*DS4_GYRO_RES_PER_DEG_S;\n\tds4->gyro_calib_data[2].sens_denom = abs(gyro_roll_plus - gyro_roll_bias) +\n\t\t\tabs(gyro_roll_minus - gyro_roll_bias);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ds4->gyro_calib_data); i++) {\n\t\tif (ds4->gyro_calib_data[i].sens_denom == 0) {\n\t\t\thid_warn(hdev, \"Invalid gyro calibration data for axis (%d), disabling calibration.\",\n\t\t\t\t\tds4->gyro_calib_data[i].abs_code);\n\t\t\tds4->gyro_calib_data[i].bias = 0;\n\t\t\tds4->gyro_calib_data[i].sens_numer = DS4_GYRO_RANGE;\n\t\t\tds4->gyro_calib_data[i].sens_denom = S16_MAX;\n\t\t}\n\t}\n\n\t \n\trange_2g = acc_x_plus - acc_x_minus;\n\tds4->accel_calib_data[0].abs_code = ABS_X;\n\tds4->accel_calib_data[0].bias = acc_x_plus - range_2g / 2;\n\tds4->accel_calib_data[0].sens_numer = 2*DS4_ACC_RES_PER_G;\n\tds4->accel_calib_data[0].sens_denom = range_2g;\n\n\trange_2g = acc_y_plus - acc_y_minus;\n\tds4->accel_calib_data[1].abs_code = ABS_Y;\n\tds4->accel_calib_data[1].bias = acc_y_plus - range_2g / 2;\n\tds4->accel_calib_data[1].sens_numer = 2*DS4_ACC_RES_PER_G;\n\tds4->accel_calib_data[1].sens_denom = range_2g;\n\n\trange_2g = acc_z_plus - acc_z_minus;\n\tds4->accel_calib_data[2].abs_code = ABS_Z;\n\tds4->accel_calib_data[2].bias = acc_z_plus - range_2g / 2;\n\tds4->accel_calib_data[2].sens_numer = 2*DS4_ACC_RES_PER_G;\n\tds4->accel_calib_data[2].sens_denom = range_2g;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ds4->accel_calib_data); i++) {\n\t\tif (ds4->accel_calib_data[i].sens_denom == 0) {\n\t\t\thid_warn(hdev, \"Invalid accelerometer calibration data for axis (%d), disabling calibration.\",\n\t\t\t\t\tds4->accel_calib_data[i].abs_code);\n\t\t\tds4->accel_calib_data[i].bias = 0;\n\t\t\tds4->accel_calib_data[i].sens_numer = DS4_ACC_RANGE;\n\t\t\tds4->accel_calib_data[i].sens_denom = S16_MAX;\n\t\t}\n\t}\n\nerr_free:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dualshock4_get_firmware_info(struct dualshock4 *ds4)\n{\n\tuint8_t *buf;\n\tint ret;\n\n\tbuf = kzalloc(DS4_FEATURE_REPORT_FIRMWARE_INFO_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = ps_get_report(ds4->base.hdev, DS4_FEATURE_REPORT_FIRMWARE_INFO, buf,\n\t\t\tDS4_FEATURE_REPORT_FIRMWARE_INFO_SIZE, false);\n\tif (ret) {\n\t\thid_err(ds4->base.hdev, \"Failed to retrieve DualShock4 firmware info: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tds4->base.hw_version = get_unaligned_le16(&buf[35]);\n\tds4->base.fw_version = get_unaligned_le16(&buf[41]);\n\nerr_free:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int dualshock4_get_mac_address(struct dualshock4 *ds4)\n{\n\tstruct hid_device *hdev = ds4->base.hdev;\n\tuint8_t *buf;\n\tint ret = 0;\n\n\tif (hdev->bus == BUS_USB) {\n\t\tbuf = kzalloc(DS4_FEATURE_REPORT_PAIRING_INFO_SIZE, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tret = ps_get_report(hdev, DS4_FEATURE_REPORT_PAIRING_INFO, buf,\n\t\t\t\tDS4_FEATURE_REPORT_PAIRING_INFO_SIZE, false);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Failed to retrieve DualShock4 pairing info: %d\\n\", ret);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tmemcpy(ds4->base.mac_address, &buf[1], sizeof(ds4->base.mac_address));\n\t} else {\n\t\t \n\t\tif (strlen(hdev->uniq) != 17)\n\t\t\treturn -EINVAL;\n\n\t\tret = sscanf(hdev->uniq, \"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\",\n\t\t\t\t&ds4->base.mac_address[5], &ds4->base.mac_address[4],\n\t\t\t\t&ds4->base.mac_address[3], &ds4->base.mac_address[2],\n\t\t\t\t&ds4->base.mac_address[1], &ds4->base.mac_address[0]);\n\n\t\tif (ret != sizeof(ds4->base.mac_address))\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\nerr_free:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic enum led_brightness dualshock4_led_get_brightness(struct led_classdev *led)\n{\n\tstruct hid_device *hdev = to_hid_device(led->dev->parent);\n\tstruct dualshock4 *ds4 = hid_get_drvdata(hdev);\n\tunsigned int led_index;\n\n\tled_index = led - ds4->lightbar_leds;\n\tswitch (led_index) {\n\tcase 0:\n\t\treturn ds4->lightbar_red;\n\tcase 1:\n\t\treturn ds4->lightbar_green;\n\tcase 2:\n\t\treturn ds4->lightbar_blue;\n\tcase 3:\n\t\treturn ds4->lightbar_enabled;\n\t}\n\n\treturn -1;\n}\n\nstatic int dualshock4_led_set_blink(struct led_classdev *led, unsigned long *delay_on,\n\t\tunsigned long *delay_off)\n{\n\tstruct hid_device *hdev = to_hid_device(led->dev->parent);\n\tstruct dualshock4 *ds4 = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ds4->base.lock, flags);\n\n\tif (!*delay_on && !*delay_off) {\n\t\t \n\t\tds4->lightbar_blink_on = 50;\n\t\tds4->lightbar_blink_off = 50;\n\t} else {\n\t\t \n\t\tds4->lightbar_blink_on = min_t(unsigned long, *delay_on/10, DS4_LIGHTBAR_MAX_BLINK);\n\t\tds4->lightbar_blink_off = min_t(unsigned long, *delay_off/10, DS4_LIGHTBAR_MAX_BLINK);\n\t}\n\n\tds4->update_lightbar_blink = true;\n\n\tspin_unlock_irqrestore(&ds4->base.lock, flags);\n\n\tdualshock4_schedule_work(ds4);\n\n\t*delay_on = ds4->lightbar_blink_on;\n\t*delay_off = ds4->lightbar_blink_off;\n\n\treturn 0;\n}\n\nstatic int dualshock4_led_set_brightness(struct led_classdev *led, enum led_brightness value)\n{\n\tstruct hid_device *hdev = to_hid_device(led->dev->parent);\n\tstruct dualshock4 *ds4 = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tunsigned int led_index;\n\n\tspin_lock_irqsave(&ds4->base.lock, flags);\n\n\tled_index = led - ds4->lightbar_leds;\n\tswitch (led_index) {\n\tcase 0:\n\t\tds4->lightbar_red = value;\n\t\tbreak;\n\tcase 1:\n\t\tds4->lightbar_green = value;\n\t\tbreak;\n\tcase 2:\n\t\tds4->lightbar_blue = value;\n\t\tbreak;\n\tcase 3:\n\t\tds4->lightbar_enabled = !!value;\n\t}\n\n\tds4->update_lightbar = true;\n\n\tspin_unlock_irqrestore(&ds4->base.lock, flags);\n\n\tdualshock4_schedule_work(ds4);\n\n\treturn 0;\n}\n\nstatic void dualshock4_init_output_report(struct dualshock4 *ds4,\n\t\tstruct dualshock4_output_report *rp, void *buf)\n{\n\tstruct hid_device *hdev = ds4->base.hdev;\n\n\tif (hdev->bus == BUS_BLUETOOTH) {\n\t\tstruct dualshock4_output_report_bt *bt = buf;\n\n\t\tmemset(bt, 0, sizeof(*bt));\n\t\tbt->report_id = DS4_OUTPUT_REPORT_BT;\n\n\t\trp->data = buf;\n\t\trp->len = sizeof(*bt);\n\t\trp->bt = bt;\n\t\trp->usb = NULL;\n\t\trp->common = &bt->common;\n\t} else {  \n\t\tstruct dualshock4_output_report_usb *usb = buf;\n\n\t\tmemset(usb, 0, sizeof(*usb));\n\t\tusb->report_id = DS4_OUTPUT_REPORT_USB;\n\n\t\trp->data = buf;\n\t\trp->len = sizeof(*usb);\n\t\trp->bt = NULL;\n\t\trp->usb = usb;\n\t\trp->common = &usb->common;\n\t}\n}\n\nstatic void dualshock4_output_worker(struct work_struct *work)\n{\n\tstruct dualshock4 *ds4 = container_of(work, struct dualshock4, output_worker);\n\tstruct dualshock4_output_report report;\n\tstruct dualshock4_output_report_common *common;\n\tunsigned long flags;\n\n\tdualshock4_init_output_report(ds4, &report, ds4->output_report_dmabuf);\n\tcommon = report.common;\n\n\tspin_lock_irqsave(&ds4->base.lock, flags);\n\n\tif (ds4->update_rumble) {\n\t\t \n\t\tcommon->valid_flag0 |= DS4_OUTPUT_VALID_FLAG0_MOTOR;\n\t\tcommon->motor_left = ds4->motor_left;\n\t\tcommon->motor_right = ds4->motor_right;\n\t\tds4->update_rumble = false;\n\t}\n\n\tif (ds4->update_lightbar) {\n\t\tcommon->valid_flag0 |= DS4_OUTPUT_VALID_FLAG0_LED;\n\t\t \n\t\tcommon->lightbar_red = ds4->lightbar_enabled ? ds4->lightbar_red : 0;\n\t\tcommon->lightbar_green = ds4->lightbar_enabled ? ds4->lightbar_green : 0;\n\t\tcommon->lightbar_blue = ds4->lightbar_enabled ? ds4->lightbar_blue : 0;\n\t\tds4->update_lightbar = false;\n\t}\n\n\tif (ds4->update_lightbar_blink) {\n\t\tcommon->valid_flag0 |= DS4_OUTPUT_VALID_FLAG0_LED_BLINK;\n\t\tcommon->lightbar_blink_on = ds4->lightbar_blink_on;\n\t\tcommon->lightbar_blink_off = ds4->lightbar_blink_off;\n\t\tds4->update_lightbar_blink = false;\n\t}\n\n\tspin_unlock_irqrestore(&ds4->base.lock, flags);\n\n\t \n\tif (report.bt) {\n\t\tuint32_t crc;\n\t\tuint8_t seed = PS_OUTPUT_CRC32_SEED;\n\n\t\t \n\t\treport.bt->hw_control = DS4_OUTPUT_HWCTL_HID | DS4_OUTPUT_HWCTL_CRC32;\n\n\t\tif (ds4->update_bt_poll_interval) {\n\t\t\treport.bt->hw_control |= ds4->bt_poll_interval;\n\t\t\tds4->update_bt_poll_interval = false;\n\t\t}\n\n\t\tcrc = crc32_le(0xFFFFFFFF, &seed, 1);\n\t\tcrc = ~crc32_le(crc, report.data, report.len - 4);\n\n\t\treport.bt->crc32 = cpu_to_le32(crc);\n\t}\n\n\thid_hw_output_report(ds4->base.hdev, report.data, report.len);\n}\n\nstatic int dualshock4_parse_report(struct ps_device *ps_dev, struct hid_report *report,\n\t\tu8 *data, int size)\n{\n\tstruct hid_device *hdev = ps_dev->hdev;\n\tstruct dualshock4 *ds4 = container_of(ps_dev, struct dualshock4, base);\n\tstruct dualshock4_input_report_common *ds4_report;\n\tstruct dualshock4_touch_report *touch_reports;\n\tuint8_t battery_capacity, num_touch_reports, value;\n\tint battery_status, i, j;\n\tuint16_t sensor_timestamp;\n\tunsigned long flags;\n\n\t \n\tif (hdev->bus == BUS_USB && report->id == DS4_INPUT_REPORT_USB &&\n\t\t\tsize == DS4_INPUT_REPORT_USB_SIZE) {\n\t\tstruct dualshock4_input_report_usb *usb = (struct dualshock4_input_report_usb *)data;\n\n\t\tds4_report = &usb->common;\n\t\tnum_touch_reports = usb->num_touch_reports;\n\t\ttouch_reports = usb->touch_reports;\n\t} else if (hdev->bus == BUS_BLUETOOTH && report->id == DS4_INPUT_REPORT_BT &&\n\t\t\tsize == DS4_INPUT_REPORT_BT_SIZE) {\n\t\tstruct dualshock4_input_report_bt *bt = (struct dualshock4_input_report_bt *)data;\n\t\tuint32_t report_crc = get_unaligned_le32(&bt->crc32);\n\n\t\t \n\t\tif (!ps_check_crc32(PS_INPUT_CRC32_SEED, data, size - 4, report_crc)) {\n\t\t\thid_err(hdev, \"DualShock4 input CRC's check failed\\n\");\n\t\t\treturn -EILSEQ;\n\t\t}\n\n\t\tds4_report = &bt->common;\n\t\tnum_touch_reports = bt->num_touch_reports;\n\t\ttouch_reports = bt->touch_reports;\n\t} else {\n\t\thid_err(hdev, \"Unhandled reportID=%d\\n\", report->id);\n\t\treturn -1;\n\t}\n\n\tinput_report_abs(ds4->gamepad, ABS_X,  ds4_report->x);\n\tinput_report_abs(ds4->gamepad, ABS_Y,  ds4_report->y);\n\tinput_report_abs(ds4->gamepad, ABS_RX, ds4_report->rx);\n\tinput_report_abs(ds4->gamepad, ABS_RY, ds4_report->ry);\n\tinput_report_abs(ds4->gamepad, ABS_Z,  ds4_report->z);\n\tinput_report_abs(ds4->gamepad, ABS_RZ, ds4_report->rz);\n\n\tvalue = ds4_report->buttons[0] & DS_BUTTONS0_HAT_SWITCH;\n\tif (value >= ARRAY_SIZE(ps_gamepad_hat_mapping))\n\t\tvalue = 8;  \n\tinput_report_abs(ds4->gamepad, ABS_HAT0X, ps_gamepad_hat_mapping[value].x);\n\tinput_report_abs(ds4->gamepad, ABS_HAT0Y, ps_gamepad_hat_mapping[value].y);\n\n\tinput_report_key(ds4->gamepad, BTN_WEST,   ds4_report->buttons[0] & DS_BUTTONS0_SQUARE);\n\tinput_report_key(ds4->gamepad, BTN_SOUTH,  ds4_report->buttons[0] & DS_BUTTONS0_CROSS);\n\tinput_report_key(ds4->gamepad, BTN_EAST,   ds4_report->buttons[0] & DS_BUTTONS0_CIRCLE);\n\tinput_report_key(ds4->gamepad, BTN_NORTH,  ds4_report->buttons[0] & DS_BUTTONS0_TRIANGLE);\n\tinput_report_key(ds4->gamepad, BTN_TL,     ds4_report->buttons[1] & DS_BUTTONS1_L1);\n\tinput_report_key(ds4->gamepad, BTN_TR,     ds4_report->buttons[1] & DS_BUTTONS1_R1);\n\tinput_report_key(ds4->gamepad, BTN_TL2,    ds4_report->buttons[1] & DS_BUTTONS1_L2);\n\tinput_report_key(ds4->gamepad, BTN_TR2,    ds4_report->buttons[1] & DS_BUTTONS1_R2);\n\tinput_report_key(ds4->gamepad, BTN_SELECT, ds4_report->buttons[1] & DS_BUTTONS1_CREATE);\n\tinput_report_key(ds4->gamepad, BTN_START,  ds4_report->buttons[1] & DS_BUTTONS1_OPTIONS);\n\tinput_report_key(ds4->gamepad, BTN_THUMBL, ds4_report->buttons[1] & DS_BUTTONS1_L3);\n\tinput_report_key(ds4->gamepad, BTN_THUMBR, ds4_report->buttons[1] & DS_BUTTONS1_R3);\n\tinput_report_key(ds4->gamepad, BTN_MODE,   ds4_report->buttons[2] & DS_BUTTONS2_PS_HOME);\n\tinput_sync(ds4->gamepad);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ds4_report->gyro); i++) {\n\t\tint raw_data = (short)le16_to_cpu(ds4_report->gyro[i]);\n\t\tint calib_data = mult_frac(ds4->gyro_calib_data[i].sens_numer,\n\t\t\t\t\t   raw_data, ds4->gyro_calib_data[i].sens_denom);\n\n\t\tinput_report_abs(ds4->sensors, ds4->gyro_calib_data[i].abs_code, calib_data);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ds4_report->accel); i++) {\n\t\tint raw_data = (short)le16_to_cpu(ds4_report->accel[i]);\n\t\tint calib_data = mult_frac(ds4->accel_calib_data[i].sens_numer,\n\t\t\t\t\t   raw_data - ds4->accel_calib_data[i].bias,\n\t\t\t\t\t   ds4->accel_calib_data[i].sens_denom);\n\n\t\tinput_report_abs(ds4->sensors, ds4->accel_calib_data[i].abs_code, calib_data);\n\t}\n\n\t \n\tsensor_timestamp = le16_to_cpu(ds4_report->sensor_timestamp);\n\tif (!ds4->sensor_timestamp_initialized) {\n\t\tds4->sensor_timestamp_us = DIV_ROUND_CLOSEST(sensor_timestamp*16, 3);\n\t\tds4->sensor_timestamp_initialized = true;\n\t} else {\n\t\tuint16_t delta;\n\n\t\tif (ds4->prev_sensor_timestamp > sensor_timestamp)\n\t\t\tdelta = (U16_MAX - ds4->prev_sensor_timestamp + sensor_timestamp + 1);\n\t\telse\n\t\t\tdelta = sensor_timestamp - ds4->prev_sensor_timestamp;\n\t\tds4->sensor_timestamp_us += DIV_ROUND_CLOSEST(delta*16, 3);\n\t}\n\tds4->prev_sensor_timestamp = sensor_timestamp;\n\tinput_event(ds4->sensors, EV_MSC, MSC_TIMESTAMP, ds4->sensor_timestamp_us);\n\tinput_sync(ds4->sensors);\n\n\tfor (i = 0; i < num_touch_reports; i++) {\n\t\tstruct dualshock4_touch_report *touch_report = &touch_reports[i];\n\n\t\tfor (j = 0; j < ARRAY_SIZE(touch_report->points); j++) {\n\t\t\tstruct dualshock4_touch_point *point = &touch_report->points[j];\n\t\t\tbool active = (point->contact & DS4_TOUCH_POINT_INACTIVE) ? false : true;\n\n\t\t\tinput_mt_slot(ds4->touchpad, j);\n\t\t\tinput_mt_report_slot_state(ds4->touchpad, MT_TOOL_FINGER, active);\n\n\t\t\tif (active) {\n\t\t\t\tint x = (point->x_hi << 8) | point->x_lo;\n\t\t\t\tint y = (point->y_hi << 4) | point->y_lo;\n\n\t\t\t\tinput_report_abs(ds4->touchpad, ABS_MT_POSITION_X, x);\n\t\t\t\tinput_report_abs(ds4->touchpad, ABS_MT_POSITION_Y, y);\n\t\t\t}\n\t\t}\n\t\tinput_mt_sync_frame(ds4->touchpad);\n\t\tinput_sync(ds4->touchpad);\n\t}\n\tinput_report_key(ds4->touchpad, BTN_LEFT, ds4_report->buttons[2] & DS_BUTTONS2_TOUCHPAD);\n\n\t \n\tif (ds4_report->status[0] & DS4_STATUS0_CABLE_STATE) {\n\t\tuint8_t battery_data = ds4_report->status[0] & DS4_STATUS0_BATTERY_CAPACITY;\n\n\t\tif (battery_data < 10) {\n\t\t\t \n\t\t\tbattery_capacity = battery_data * 10 + 5;\n\t\t\tbattery_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\t} else if (battery_data == 10) {\n\t\t\tbattery_capacity = 100;\n\t\t\tbattery_status = POWER_SUPPLY_STATUS_CHARGING;\n\t\t} else if (battery_data == DS4_BATTERY_STATUS_FULL) {\n\t\t\tbattery_capacity = 100;\n\t\t\tbattery_status = POWER_SUPPLY_STATUS_FULL;\n\t\t} else {  \n\t\t\tbattery_capacity = 0;\n\t\t\tbattery_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tuint8_t battery_data = ds4_report->status[0] & DS4_STATUS0_BATTERY_CAPACITY;\n\n\t\tif (battery_data < 10)\n\t\t\tbattery_capacity = battery_data * 10 + 5;\n\t\telse  \n\t\t\tbattery_capacity = 100;\n\n\t\tbattery_status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t}\n\n\tspin_lock_irqsave(&ps_dev->lock, flags);\n\tps_dev->battery_capacity = battery_capacity;\n\tps_dev->battery_status = battery_status;\n\tspin_unlock_irqrestore(&ps_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int dualshock4_dongle_parse_report(struct ps_device *ps_dev, struct hid_report *report,\n\t\tu8 *data, int size)\n{\n\tstruct dualshock4 *ds4 = container_of(ps_dev, struct dualshock4, base);\n\tbool connected = false;\n\n\t \n\tif (data[0] == DS4_INPUT_REPORT_USB && size == DS4_INPUT_REPORT_USB_SIZE) {\n\t\tstruct dualshock4_input_report_common *ds4_report = (struct dualshock4_input_report_common *)&data[1];\n\t\tunsigned long flags;\n\n\t\tconnected = ds4_report->status[1] & DS4_STATUS1_DONGLE_STATE ? false : true;\n\n\t\tif (ds4->dongle_state == DONGLE_DISCONNECTED && connected) {\n\t\t\thid_info(ps_dev->hdev, \"DualShock 4 USB dongle: controller connected\\n\");\n\n\t\t\tdualshock4_set_default_lightbar_colors(ds4);\n\n\t\t\tspin_lock_irqsave(&ps_dev->lock, flags);\n\t\t\tds4->dongle_state = DONGLE_CALIBRATING;\n\t\t\tspin_unlock_irqrestore(&ps_dev->lock, flags);\n\n\t\t\tschedule_work(&ds4->dongle_hotplug_worker);\n\n\t\t\t \n\t\t\treturn 0;\n\t\t} else if ((ds4->dongle_state == DONGLE_CONNECTED ||\n\t\t\t    ds4->dongle_state == DONGLE_DISABLED) && !connected) {\n\t\t\thid_info(ps_dev->hdev, \"DualShock 4 USB dongle: controller disconnected\\n\");\n\n\t\t\tspin_lock_irqsave(&ps_dev->lock, flags);\n\t\t\tds4->dongle_state = DONGLE_DISCONNECTED;\n\t\t\tspin_unlock_irqrestore(&ps_dev->lock, flags);\n\n\t\t\t \n\t\t\treturn 0;\n\t\t} else if (ds4->dongle_state == DONGLE_CALIBRATING ||\n\t\t\t   ds4->dongle_state == DONGLE_DISABLED ||\n\t\t\t   ds4->dongle_state == DONGLE_DISCONNECTED) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (connected)\n\t\treturn dualshock4_parse_report(ps_dev, report, data, size);\n\n\treturn 0;\n}\n\nstatic int dualshock4_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)\n{\n\tstruct hid_device *hdev = input_get_drvdata(dev);\n\tstruct dualshock4 *ds4 = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tif (effect->type != FF_RUMBLE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ds4->base.lock, flags);\n\tds4->update_rumble = true;\n\tds4->motor_left = effect->u.rumble.strong_magnitude / 256;\n\tds4->motor_right = effect->u.rumble.weak_magnitude / 256;\n\tspin_unlock_irqrestore(&ds4->base.lock, flags);\n\n\tdualshock4_schedule_work(ds4);\n\treturn 0;\n}\n\nstatic void dualshock4_remove(struct ps_device *ps_dev)\n{\n\tstruct dualshock4 *ds4 = container_of(ps_dev, struct dualshock4, base);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ds4->base.lock, flags);\n\tds4->output_worker_initialized = false;\n\tspin_unlock_irqrestore(&ds4->base.lock, flags);\n\n\tcancel_work_sync(&ds4->output_worker);\n\n\tif (ps_dev->hdev->product == USB_DEVICE_ID_SONY_PS4_CONTROLLER_DONGLE)\n\t\tcancel_work_sync(&ds4->dongle_hotplug_worker);\n}\n\nstatic inline void dualshock4_schedule_work(struct dualshock4 *ds4)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ds4->base.lock, flags);\n\tif (ds4->output_worker_initialized)\n\t\tschedule_work(&ds4->output_worker);\n\tspin_unlock_irqrestore(&ds4->base.lock, flags);\n}\n\nstatic void dualshock4_set_bt_poll_interval(struct dualshock4 *ds4, uint8_t interval)\n{\n\tds4->bt_poll_interval = interval;\n\tds4->update_bt_poll_interval = true;\n\tdualshock4_schedule_work(ds4);\n}\n\n \nstatic void dualshock4_set_default_lightbar_colors(struct dualshock4 *ds4)\n{\n\t \n\tstatic const int player_colors[4][3] = {\n\t\t{ 0x00, 0x00, 0x40 },  \n\t\t{ 0x40, 0x00, 0x00 },  \n\t\t{ 0x00, 0x40, 0x00 },  \n\t\t{ 0x20, 0x00, 0x20 }   \n\t};\n\n\tuint8_t player_id = ds4->base.player_id % ARRAY_SIZE(player_colors);\n\n\tds4->lightbar_enabled = true;\n\tds4->lightbar_red = player_colors[player_id][0];\n\tds4->lightbar_green = player_colors[player_id][1];\n\tds4->lightbar_blue = player_colors[player_id][2];\n\n\tds4->update_lightbar = true;\n\tdualshock4_schedule_work(ds4);\n}\n\nstatic struct ps_device *dualshock4_create(struct hid_device *hdev)\n{\n\tstruct dualshock4 *ds4;\n\tstruct ps_device *ps_dev;\n\tuint8_t max_output_report_size;\n\tint i, ret;\n\n\t \n\tstatic const struct ps_led_info lightbar_leds_info[] = {\n\t\t{ NULL, \"red\", 255, dualshock4_led_get_brightness, dualshock4_led_set_brightness },\n\t\t{ NULL, \"green\", 255, dualshock4_led_get_brightness, dualshock4_led_set_brightness },\n\t\t{ NULL, \"blue\", 255, dualshock4_led_get_brightness, dualshock4_led_set_brightness },\n\t\t{ NULL, \"global\", 1, dualshock4_led_get_brightness, dualshock4_led_set_brightness,\n\t\t\t\tdualshock4_led_set_blink },\n\t};\n\n\tds4 = devm_kzalloc(&hdev->dev, sizeof(*ds4), GFP_KERNEL);\n\tif (!ds4)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\thdev->version |= HID_PLAYSTATION_VERSION_PATCH;\n\n\tps_dev = &ds4->base;\n\tps_dev->hdev = hdev;\n\tspin_lock_init(&ps_dev->lock);\n\tps_dev->battery_capacity = 100;  \n\tps_dev->battery_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\tps_dev->parse_report = dualshock4_parse_report;\n\tps_dev->remove = dualshock4_remove;\n\tINIT_WORK(&ds4->output_worker, dualshock4_output_worker);\n\tds4->output_worker_initialized = true;\n\thid_set_drvdata(hdev, ds4);\n\n\tmax_output_report_size = sizeof(struct dualshock4_output_report_bt);\n\tds4->output_report_dmabuf = devm_kzalloc(&hdev->dev, max_output_report_size, GFP_KERNEL);\n\tif (!ds4->output_report_dmabuf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (hdev->product == USB_DEVICE_ID_SONY_PS4_CONTROLLER_DONGLE) {\n\t\tds4->dongle_state = DONGLE_DISCONNECTED;\n\t\tINIT_WORK(&ds4->dongle_hotplug_worker, dualshock4_dongle_calibration_work);\n\n\t\t \n\t\tps_dev->parse_report = dualshock4_dongle_parse_report;\n\t}\n\n\tret = dualshock4_get_mac_address(ds4);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to get MAC address from DualShock4\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\tsnprintf(hdev->uniq, sizeof(hdev->uniq), \"%pMR\", ds4->base.mac_address);\n\n\tret = dualshock4_get_firmware_info(ds4);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to get firmware info from DualShock4\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = ps_devices_list_add(ps_dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = dualshock4_get_calibration_data(ds4);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to get calibration data from DualShock4\\n\");\n\t\tgoto err;\n\t}\n\n\tds4->gamepad = ps_gamepad_create(hdev, dualshock4_play_effect);\n\tif (IS_ERR(ds4->gamepad)) {\n\t\tret = PTR_ERR(ds4->gamepad);\n\t\tgoto err;\n\t}\n\n\t \n\tps_dev->input_dev_name = dev_name(&ds4->gamepad->dev);\n\n\tds4->sensors = ps_sensors_create(hdev, DS4_ACC_RANGE, DS4_ACC_RES_PER_G,\n\t\t\tDS4_GYRO_RANGE, DS4_GYRO_RES_PER_DEG_S);\n\tif (IS_ERR(ds4->sensors)) {\n\t\tret = PTR_ERR(ds4->sensors);\n\t\tgoto err;\n\t}\n\n\tds4->touchpad = ps_touchpad_create(hdev, DS4_TOUCHPAD_WIDTH, DS4_TOUCHPAD_HEIGHT, 2);\n\tif (IS_ERR(ds4->touchpad)) {\n\t\tret = PTR_ERR(ds4->touchpad);\n\t\tgoto err;\n\t}\n\n\tret = ps_device_register_battery(ps_dev);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < ARRAY_SIZE(lightbar_leds_info); i++) {\n\t\tconst struct ps_led_info *led_info = &lightbar_leds_info[i];\n\n\t\tret = ps_led_register(ps_dev, &ds4->lightbar_leds[i], led_info);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tdualshock4_set_bt_poll_interval(ds4, DS4_BT_DEFAULT_POLL_INTERVAL_MS);\n\n\tret = ps_device_set_player_id(ps_dev);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to assign player id for DualShock4: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tdualshock4_set_default_lightbar_colors(ds4);\n\n\t \n\thid_info(hdev, \"Registered DualShock4 controller hw_version=0x%08x fw_version=0x%08x\\n\",\n\t\t\tds4->base.hw_version, ds4->base.fw_version);\n\treturn &ds4->base;\n\nerr:\n\tps_devices_list_remove(ps_dev);\n\treturn ERR_PTR(ret);\n}\n\nstatic int ps_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\tu8 *data, int size)\n{\n\tstruct ps_device *dev = hid_get_drvdata(hdev);\n\n\tif (dev && dev->parse_report)\n\t\treturn dev->parse_report(dev, report, data, size);\n\n\treturn 0;\n}\n\nstatic int ps_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct ps_device *dev;\n\tint ret;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to start HID device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to open HID device\\n\");\n\t\tgoto err_stop;\n\t}\n\n\tif (hdev->product == USB_DEVICE_ID_SONY_PS4_CONTROLLER ||\n\t\thdev->product == USB_DEVICE_ID_SONY_PS4_CONTROLLER_2 ||\n\t\thdev->product == USB_DEVICE_ID_SONY_PS4_CONTROLLER_DONGLE) {\n\t\tdev = dualshock4_create(hdev);\n\t\tif (IS_ERR(dev)) {\n\t\t\thid_err(hdev, \"Failed to create dualshock4.\\n\");\n\t\t\tret = PTR_ERR(dev);\n\t\t\tgoto err_close;\n\t\t}\n\t} else if (hdev->product == USB_DEVICE_ID_SONY_PS5_CONTROLLER ||\n\t\thdev->product == USB_DEVICE_ID_SONY_PS5_CONTROLLER_2) {\n\t\tdev = dualsense_create(hdev);\n\t\tif (IS_ERR(dev)) {\n\t\t\thid_err(hdev, \"Failed to create dualsense.\\n\");\n\t\t\tret = PTR_ERR(dev);\n\t\t\tgoto err_close;\n\t\t}\n\t}\n\n\treturn ret;\n\nerr_close:\n\thid_hw_close(hdev);\nerr_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void ps_remove(struct hid_device *hdev)\n{\n\tstruct ps_device *dev = hid_get_drvdata(hdev);\n\n\tps_devices_list_remove(dev);\n\tps_device_release_player_id(dev);\n\n\tif (dev->remove)\n\t\tdev->remove(dev);\n\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id ps_devices[] = {\n\t \n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER_DONGLE) },\n\t \n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS5_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS5_CONTROLLER) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS5_CONTROLLER_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS5_CONTROLLER_2) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ps_devices);\n\nstatic struct hid_driver ps_driver = {\n\t.name\t\t= \"playstation\",\n\t.id_table\t= ps_devices,\n\t.probe\t\t= ps_probe,\n\t.remove\t\t= ps_remove,\n\t.raw_event\t= ps_raw_event,\n\t.driver = {\n\t\t.dev_groups = ps_device_groups,\n\t},\n};\n\nstatic int __init ps_init(void)\n{\n\treturn hid_register_driver(&ps_driver);\n}\n\nstatic void __exit ps_exit(void)\n{\n\thid_unregister_driver(&ps_driver);\n\tida_destroy(&ps_player_id_allocator);\n}\n\nmodule_init(ps_init);\nmodule_exit(ps_exit);\n\nMODULE_AUTHOR(\"Sony Interactive Entertainment\");\nMODULE_DESCRIPTION(\"HID Driver for PlayStation peripherals.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}