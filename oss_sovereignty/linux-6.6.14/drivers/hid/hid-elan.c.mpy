{
  "module_name": "hid-elan.c",
  "hash_id": "d3ee8b36d11a8250da3fdba5e48dca89bbfed1d6c4fb5088878c33d659c22d1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-elan.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/input/mt.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"hid-ids.h\"\n\n#define ELAN_MT_I2C\t\t0x5d\n#define ELAN_SINGLE_FINGER\t0x81\n#define ELAN_MT_FIRST_FINGER\t0x82\n#define ELAN_MT_SECOND_FINGER\t0x83\n#define ELAN_INPUT_REPORT_SIZE\t8\n#define ELAN_I2C_REPORT_SIZE\t32\n#define ELAN_FINGER_DATA_LEN\t5\n#define ELAN_MAX_FINGERS\t5\n#define ELAN_MAX_PRESSURE\t255\n#define ELAN_TP_USB_INTF\t1\n\n#define ELAN_FEATURE_REPORT\t0x0d\n#define ELAN_FEATURE_SIZE\t5\n#define ELAN_PARAM_MAX_X\t6\n#define ELAN_PARAM_MAX_Y\t7\n#define ELAN_PARAM_RES\t\t8\n\n#define ELAN_MUTE_LED_REPORT\t0xBC\n#define ELAN_LED_REPORT_SIZE\t8\n\n#define ELAN_HAS_LED\t\tBIT(0)\n\nstruct elan_drvdata {\n\tstruct input_dev *input;\n\tu8 prev_report[ELAN_INPUT_REPORT_SIZE];\n\tstruct led_classdev mute_led;\n\tu8 mute_led_state;\n\tu16 max_x;\n\tu16 max_y;\n\tu16 res_x;\n\tu16 res_y;\n};\n\nstatic int is_not_elan_touchpad(struct hid_device *hdev)\n{\n\tif (hid_is_usb(hdev)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\t\treturn (intf->altsetting->desc.bInterfaceNumber !=\n\t\t\tELAN_TP_USB_INTF);\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t      struct hid_field *field, struct hid_usage *usage,\n\t\t\t      unsigned long **bit, int *max)\n{\n\tif (is_not_elan_touchpad(hdev))\n\t\treturn 0;\n\n\tif (field->report->id == ELAN_SINGLE_FINGER ||\n\t    field->report->id == ELAN_MT_FIRST_FINGER ||\n\t    field->report->id == ELAN_MT_SECOND_FINGER ||\n\t    field->report->id == ELAN_MT_I2C)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int elan_get_device_param(struct hid_device *hdev,\n\t\t\t\t unsigned char *dmabuf, unsigned char param)\n{\n\tint ret;\n\n\tdmabuf[0] = ELAN_FEATURE_REPORT;\n\tdmabuf[1] = 0x05;\n\tdmabuf[2] = 0x03;\n\tdmabuf[3] = param;\n\tdmabuf[4] = 0x01;\n\n\tret = hid_hw_raw_request(hdev, ELAN_FEATURE_REPORT, dmabuf,\n\t\t\t\t ELAN_FEATURE_SIZE, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret != ELAN_FEATURE_SIZE) {\n\t\thid_err(hdev, \"Set report error for parm %d: %d\\n\", param, ret);\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_raw_request(hdev, ELAN_FEATURE_REPORT, dmabuf,\n\t\t\t\t ELAN_FEATURE_SIZE, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != ELAN_FEATURE_SIZE) {\n\t\thid_err(hdev, \"Get report error for parm %d: %d\\n\", param, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int elan_convert_res(char val)\n{\n\t \n\treturn (val * 10 + 790) * 10 / 254;\n}\n\nstatic int elan_get_device_params(struct hid_device *hdev)\n{\n\tstruct elan_drvdata *drvdata = hid_get_drvdata(hdev);\n\tunsigned char *dmabuf;\n\tint ret;\n\n\tdmabuf = kmalloc(ELAN_FEATURE_SIZE, GFP_KERNEL);\n\tif (!dmabuf)\n\t\treturn -ENOMEM;\n\n\tret = elan_get_device_param(hdev, dmabuf, ELAN_PARAM_MAX_X);\n\tif (ret)\n\t\tgoto err;\n\n\tdrvdata->max_x = (dmabuf[4] << 8) | dmabuf[3];\n\n\tret = elan_get_device_param(hdev, dmabuf, ELAN_PARAM_MAX_Y);\n\tif (ret)\n\t\tgoto err;\n\n\tdrvdata->max_y = (dmabuf[4] << 8) | dmabuf[3];\n\n\tret = elan_get_device_param(hdev, dmabuf, ELAN_PARAM_RES);\n\tif (ret)\n\t\tgoto err;\n\n\tdrvdata->res_x = elan_convert_res(dmabuf[3]);\n\tdrvdata->res_y = elan_convert_res(dmabuf[4]);\n\nerr:\n\tkfree(dmabuf);\n\treturn ret;\n}\n\nstatic int elan_input_configured(struct hid_device *hdev, struct hid_input *hi)\n{\n\tint ret;\n\tstruct input_dev *input;\n\tstruct elan_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tif (is_not_elan_touchpad(hdev))\n\t\treturn 0;\n\n\tret = elan_get_device_params(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tinput = devm_input_allocate_device(&hdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"Elan Touchpad\";\n\tinput->phys = hdev->phys;\n\tinput->uniq = hdev->uniq;\n\tinput->id.bustype = hdev->bus;\n\tinput->id.vendor  = hdev->vendor;\n\tinput->id.product = hdev->product;\n\tinput->id.version = hdev->version;\n\tinput->dev.parent = &hdev->dev;\n\n\tinput_set_abs_params(input, ABS_MT_POSITION_X, 0, drvdata->max_x,\n\t\t\t     0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y, 0, drvdata->max_y,\n\t\t\t     0, 0);\n\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, ELAN_MAX_PRESSURE,\n\t\t\t     0, 0);\n\n\t__set_bit(BTN_LEFT, input->keybit);\n\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\n\tret = input_mt_init_slots(input, ELAN_MAX_FINGERS, INPUT_MT_POINTER);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to init elan MT slots: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinput_abs_set_res(input, ABS_X, drvdata->res_x);\n\tinput_abs_set_res(input, ABS_Y, drvdata->res_y);\n\n\tret = input_register_device(input);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to register elan input device: %d\\n\",\n\t\t\tret);\n\t\tinput_mt_destroy_slots(input);\n\t\treturn ret;\n\t}\n\n\tdrvdata->input = input;\n\n\treturn 0;\n}\n\nstatic void elan_report_mt_slot(struct elan_drvdata *drvdata, u8 *data,\n\t\t\t\tunsigned int slot_num)\n{\n\tstruct input_dev *input = drvdata->input;\n\tint x, y, p;\n\n\tbool active = !!data;\n\n\tinput_mt_slot(input, slot_num);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, active);\n\tif (active) {\n\t\tx = ((data[0] & 0xF0) << 4) | data[1];\n\t\ty = drvdata->max_y -\n\t\t    (((data[0] & 0x07) << 8) | data[2]);\n\t\tp = data[4];\n\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\t\tinput_report_abs(input, ABS_MT_PRESSURE, p);\n\t}\n}\n\nstatic void elan_usb_report_input(struct elan_drvdata *drvdata, u8 *data)\n{\n\tint i;\n\tstruct input_dev *input = drvdata->input;\n\n\t \n\n\tif (data[0] == ELAN_SINGLE_FINGER) {\n\t\tfor (i = 0; i < ELAN_MAX_FINGERS; i++) {\n\t\t\tif (data[2] & BIT(i + 3))\n\t\t\t\telan_report_mt_slot(drvdata, data + 3, i);\n\t\t\telse\n\t\t\t\telan_report_mt_slot(drvdata, NULL, i);\n\t\t}\n\t\tinput_report_key(input, BTN_LEFT, data[2] & 0x01);\n\t}\n\t \n\tif (data[0] == ELAN_MT_FIRST_FINGER) {\n\t\tmemcpy(drvdata->prev_report, data,\n\t\t       sizeof(drvdata->prev_report));\n\t\treturn;\n\t}\n\n\tif (data[0] == ELAN_MT_SECOND_FINGER) {\n\t\tint first = 0;\n\t\tu8 *prev_report = drvdata->prev_report;\n\n\t\tif (prev_report[0] != ELAN_MT_FIRST_FINGER)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < ELAN_MAX_FINGERS; i++) {\n\t\t\tif (prev_report[2] & BIT(i + 3)) {\n\t\t\t\tif (!first) {\n\t\t\t\t\tfirst = 1;\n\t\t\t\t\telan_report_mt_slot(drvdata, prev_report + 3, i);\n\t\t\t\t} else {\n\t\t\t\t\telan_report_mt_slot(drvdata, data + 1, i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telan_report_mt_slot(drvdata, NULL, i);\n\t\t\t}\n\t\t}\n\t\tinput_report_key(input, BTN_LEFT, prev_report[2] & 0x01);\n\t}\n\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n}\n\nstatic void elan_i2c_report_input(struct elan_drvdata *drvdata, u8 *data)\n{\n\tstruct input_dev *input = drvdata->input;\n\tu8 *finger_data;\n\tint i;\n\n\t \n\n\tfinger_data = data + 2;\n\tfor (i = 0; i < ELAN_MAX_FINGERS; i++) {\n\t\tif (data[1] & BIT(i + 3)) {\n\t\t\telan_report_mt_slot(drvdata, finger_data, i);\n\t\t\tfinger_data += ELAN_FINGER_DATA_LEN;\n\t\t} else {\n\t\t\telan_report_mt_slot(drvdata, NULL, i);\n\t\t}\n\t}\n\n\tinput_report_key(input, BTN_LEFT, data[1] & 0x01);\n\tinput_mt_sync_frame(input);\n\tinput_sync(input);\n}\n\nstatic int elan_raw_event(struct hid_device *hdev,\n\t\t\t  struct hid_report *report, u8 *data, int size)\n{\n\tstruct elan_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tif (is_not_elan_touchpad(hdev))\n\t\treturn 0;\n\n\tif (data[0] == ELAN_SINGLE_FINGER ||\n\t    data[0] == ELAN_MT_FIRST_FINGER ||\n\t    data[0] == ELAN_MT_SECOND_FINGER) {\n\t\tif (size == ELAN_INPUT_REPORT_SIZE) {\n\t\t\telan_usb_report_input(drvdata, data);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (data[0] == ELAN_MT_I2C && size == ELAN_I2C_REPORT_SIZE) {\n\t\telan_i2c_report_input(drvdata, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_start_multitouch(struct hid_device *hdev)\n{\n\tint ret;\n\n\t \n\tstatic const unsigned char buf[] = { 0x0D, 0x00, 0x03, 0x21, 0x00 };\n\tunsigned char *dmabuf = kmemdup(buf, sizeof(buf), GFP_KERNEL);\n\n\tif (!dmabuf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, dmabuf[0], dmabuf, sizeof(buf),\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\n\tkfree(dmabuf);\n\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"Failed to start multitouch: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int elan_mute_led_set_brigtness(struct led_classdev *led_cdev,\n\t\t\t\t       enum led_brightness value)\n{\n\tint ret;\n\tu8 led_state;\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct elan_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tunsigned char *dmabuf = kzalloc(ELAN_LED_REPORT_SIZE, GFP_KERNEL);\n\n\tif (!dmabuf)\n\t\treturn -ENOMEM;\n\n\tled_state = !!value;\n\n\tdmabuf[0] = ELAN_MUTE_LED_REPORT;\n\tdmabuf[1] = 0x02;\n\tdmabuf[2] = led_state;\n\n\tret = hid_hw_raw_request(hdev, dmabuf[0], dmabuf, ELAN_LED_REPORT_SIZE,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\n\tkfree(dmabuf);\n\n\tif (ret != ELAN_LED_REPORT_SIZE) {\n\t\tif (ret != -ENODEV)\n\t\t\thid_err(hdev, \"Failed to set mute led brightness: %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\tdrvdata->mute_led_state = led_state;\n\treturn 0;\n}\n\nstatic int elan_init_mute_led(struct hid_device *hdev)\n{\n\tstruct elan_drvdata *drvdata = hid_get_drvdata(hdev);\n\tstruct led_classdev *mute_led = &drvdata->mute_led;\n\n\tmute_led->name = \"elan:red:mute\";\n\tmute_led->default_trigger = \"audio-mute\";\n\tmute_led->brightness_set_blocking = elan_mute_led_set_brigtness;\n\tmute_led->max_brightness = LED_ON;\n\tmute_led->flags = LED_HW_PLUGGABLE;\n\tmute_led->dev = &hdev->dev;\n\n\treturn devm_led_classdev_register(&hdev->dev, mute_led);\n}\n\nstatic int elan_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct elan_drvdata *drvdata;\n\n\tdrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\thid_set_drvdata(hdev, drvdata);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Hid Parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"Hid hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (is_not_elan_touchpad(hdev))\n\t\treturn 0;\n\n\tif (!drvdata->input) {\n\t\thid_err(hdev, \"Input device is not registered\\n\");\n\t\tret = -ENAVAIL;\n\t\tgoto err;\n\t}\n\n\tret = elan_start_multitouch(hdev);\n\tif (ret)\n\t\tgoto err;\n\n\tif (id->driver_data & ELAN_HAS_LED) {\n\t\tret = elan_init_mute_led(hdev);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic const struct hid_device_id elan_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELAN, USB_DEVICE_ID_HP_X2),\n\t  .driver_data = ELAN_HAS_LED },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELAN, USB_DEVICE_ID_HP_X2_10_COVER),\n\t  .driver_data = ELAN_HAS_LED },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, USB_DEVICE_ID_TOSHIBA_CLICK_L9W) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, elan_devices);\n\nstatic struct hid_driver elan_driver = {\n\t.name = \"elan\",\n\t.id_table = elan_devices,\n\t.input_mapping = elan_input_mapping,\n\t.input_configured = elan_input_configured,\n\t.raw_event = elan_raw_event,\n\t.probe = elan_probe,\n};\n\nmodule_hid_driver(elan_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alexandrov Stanislav\");\nMODULE_DESCRIPTION(\"Driver for HID ELAN Touchpads\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}