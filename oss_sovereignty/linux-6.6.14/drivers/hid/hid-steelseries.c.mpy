{
  "module_name": "hid-steelseries.c",
  "hash_id": "71ae3fcb6709793851d6bca48e88b77e6cef6b097024c24a6fdb673d314da343",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-steelseries.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/leds.h>\n\n#include \"hid-ids.h\"\n\n#define STEELSERIES_SRWS1\t\tBIT(0)\n#define STEELSERIES_ARCTIS_1\t\tBIT(1)\n\nstruct steelseries_device {\n\tstruct hid_device *hdev;\n\tunsigned long quirks;\n\n\tstruct delayed_work battery_work;\n\tspinlock_t lock;\n\tbool removed;\n\n\tstruct power_supply_desc battery_desc;\n\tstruct power_supply *battery;\n\tuint8_t battery_capacity;\n\tbool headset_connected;\n};\n\n#if IS_BUILTIN(CONFIG_LEDS_CLASS) || \\\n    (IS_MODULE(CONFIG_LEDS_CLASS) && IS_MODULE(CONFIG_HID_STEELSERIES))\n#define SRWS1_NUMBER_LEDS 15\nstruct steelseries_srws1_data {\n\t__u16 led_state;\n\t \n\tstruct led_classdev *led[SRWS1_NUMBER_LEDS + 1];\n};\n#endif\n\n \n\nstatic __u8 steelseries_srws1_rdesc_fixed[] = {\n0x05, 0x01,          \n0x09, 0x08,          \n0xA1, 0x01,          \n0xA1, 0x02,          \n0x95, 0x01,          \n0x05, 0x01,          \n0x09, 0x30,          \n0x16, 0xF8, 0xF8,    \n0x26, 0x08, 0x07,    \n0x65, 0x14,          \n0x55, 0x0F,          \n0x75, 0x10,          \n0x81, 0x02,          \n0x09, 0x31,          \n0x15, 0x00,          \n0x26, 0xFF, 0x03,    \n0x75, 0x0C,          \n0x81, 0x02,          \n0x09, 0x32,          \n0x15, 0x00,          \n0x26, 0xFF, 0x03,    \n0x75, 0x0C,          \n0x81, 0x02,          \n0x05, 0x01,          \n0x09, 0x39,          \n0x25, 0x07,          \n0x35, 0x00,          \n0x46, 0x3B, 0x01,    \n0x65, 0x14,          \n0x75, 0x04,          \n0x95, 0x01,          \n0x81, 0x02,          \n0x25, 0x01,          \n0x45, 0x01,          \n0x65, 0x00,          \n0x75, 0x01,          \n0x95, 0x03,          \n0x81, 0x01,          \n0x05, 0x09,          \n0x19, 0x01,          \n0x29, 0x11,          \n0x95, 0x11,          \n0x81, 0x02,          \n                     \n0x05, 0x01,          \n0x09, 0x33,          \n0x75, 0x04,          \n0x95, 0x02,          \n0x15, 0x00,          \n0x25, 0x0b,          \n0x81, 0x02,          \n0x09, 0x35,          \n0x75, 0x04,          \n0x95, 0x01,          \n0x25, 0x03,          \n0x81, 0x02,          \n                     \n0x06, 0x00, 0xFF,    \n0x09, 0x01,          \n0x75, 0x04,          \n0x95, 0x0D,          \n0x81, 0x02,          \n0xC0,                \n0xA1, 0x02,          \n0x09, 0x02,          \n0x75, 0x08,          \n0x95, 0x10,          \n0x91, 0x02,          \n0xC0,                \n0xC0                 \n};\n\n#if IS_BUILTIN(CONFIG_LEDS_CLASS) || \\\n    (IS_MODULE(CONFIG_LEDS_CLASS) && IS_MODULE(CONFIG_HID_STEELSERIES))\nstatic void steelseries_srws1_set_leds(struct hid_device *hdev, __u16 leds)\n{\n\tstruct list_head *report_list = &hdev->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\n\t__s32 *value = report->field[0]->value;\n\n\tvalue[0] = 0x40;\n\tvalue[1] = leds & 0xFF;\n\tvalue[2] = leds >> 8;\n\tvalue[3] = 0x00;\n\tvalue[4] = 0x00;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\tvalue[7] = 0x00;\n\tvalue[8] = 0x00;\n\tvalue[9] = 0x00;\n\tvalue[10] = 0x00;\n\tvalue[11] = 0x00;\n\tvalue[12] = 0x00;\n\tvalue[13] = 0x00;\n\tvalue[14] = 0x00;\n\tvalue[15] = 0x00;\n\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n\n\t \n}\n\nstatic void steelseries_srws1_led_all_set_brightness(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct steelseries_srws1_data *drv_data = hid_get_drvdata(hid);\n\n\tif (!drv_data) {\n\t\thid_err(hid, \"Device data not found.\");\n\t\treturn;\n\t}\n\n\tif (value == LED_OFF)\n\t\tdrv_data->led_state = 0;\n\telse\n\t\tdrv_data->led_state = (1 << (SRWS1_NUMBER_LEDS + 1)) - 1;\n\n\tsteelseries_srws1_set_leds(hid, drv_data->led_state);\n}\n\nstatic enum led_brightness steelseries_srws1_led_all_get_brightness(struct led_classdev *led_cdev)\n{\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct steelseries_srws1_data *drv_data;\n\n\tdrv_data = hid_get_drvdata(hid);\n\n\tif (!drv_data) {\n\t\thid_err(hid, \"Device data not found.\");\n\t\treturn LED_OFF;\n\t}\n\n\treturn (drv_data->led_state >> SRWS1_NUMBER_LEDS) ? LED_FULL : LED_OFF;\n}\n\nstatic void steelseries_srws1_led_set_brightness(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct steelseries_srws1_data *drv_data = hid_get_drvdata(hid);\n\tint i, state = 0;\n\n\tif (!drv_data) {\n\t\thid_err(hid, \"Device data not found.\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < SRWS1_NUMBER_LEDS; i++) {\n\t\tif (led_cdev != drv_data->led[i])\n\t\t\tcontinue;\n\n\t\tstate = (drv_data->led_state >> i) & 1;\n\t\tif (value == LED_OFF && state) {\n\t\t\tdrv_data->led_state &= ~(1 << i);\n\t\t\tsteelseries_srws1_set_leds(hid, drv_data->led_state);\n\t\t} else if (value != LED_OFF && !state) {\n\t\t\tdrv_data->led_state |= 1 << i;\n\t\t\tsteelseries_srws1_set_leds(hid, drv_data->led_state);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic enum led_brightness steelseries_srws1_led_get_brightness(struct led_classdev *led_cdev)\n{\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct steelseries_srws1_data *drv_data;\n\tint i, value = 0;\n\n\tdrv_data = hid_get_drvdata(hid);\n\n\tif (!drv_data) {\n\t\thid_err(hid, \"Device data not found.\");\n\t\treturn LED_OFF;\n\t}\n\n\tfor (i = 0; i < SRWS1_NUMBER_LEDS; i++)\n\t\tif (led_cdev == drv_data->led[i]) {\n\t\t\tvalue = (drv_data->led_state >> i) & 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn value ? LED_FULL : LED_OFF;\n}\n\nstatic int steelseries_srws1_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint ret, i;\n\tstruct led_classdev *led;\n\tsize_t name_sz;\n\tchar *name;\n\n\tstruct steelseries_srws1_data *drv_data = kzalloc(sizeof(*drv_data), GFP_KERNEL);\n\n\tif (drv_data == NULL) {\n\t\thid_err(hdev, \"can't alloc SRW-S1 memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, drv_data);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 16)) {\n\t\tret = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\t \n\tdrv_data->led_state = 0;\n\tfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++)\n\t\tdrv_data->led[i] = NULL;\n\n\tsteelseries_srws1_set_leds(hdev, 0);\n\n\tname_sz = strlen(hdev->uniq) + 16;\n\n\t \n\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\tif (!led) {\n\t\thid_err(hdev, \"can't allocate memory for LED ALL\\n\");\n\t\tgoto err_led;\n\t}\n\n\tname = (void *)(&led[1]);\n\tsnprintf(name, name_sz, \"SRWS1::%s::RPMALL\", hdev->uniq);\n\tled->name = name;\n\tled->brightness = 0;\n\tled->max_brightness = 1;\n\tled->brightness_get = steelseries_srws1_led_all_get_brightness;\n\tled->brightness_set = steelseries_srws1_led_all_set_brightness;\n\n\tdrv_data->led[SRWS1_NUMBER_LEDS] = led;\n\tret = led_classdev_register(&hdev->dev, led);\n\tif (ret)\n\t\tgoto err_led;\n\n\t \n\tfor (i = 0; i < SRWS1_NUMBER_LEDS; i++) {\n\t\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\t\tif (!led) {\n\t\t\thid_err(hdev, \"can't allocate memory for LED %d\\n\", i);\n\t\t\tgoto err_led;\n\t\t}\n\n\t\tname = (void *)(&led[1]);\n\t\tsnprintf(name, name_sz, \"SRWS1::%s::RPM%d\", hdev->uniq, i+1);\n\t\tled->name = name;\n\t\tled->brightness = 0;\n\t\tled->max_brightness = 1;\n\t\tled->brightness_get = steelseries_srws1_led_get_brightness;\n\t\tled->brightness_set = steelseries_srws1_led_set_brightness;\n\n\t\tdrv_data->led[i] = led;\n\t\tret = led_classdev_register(&hdev->dev, led);\n\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"failed to register LED %d. Aborting.\\n\", i);\nerr_led:\n\t\t\t \n\t\t\tfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++) {\n\t\t\t\tled = drv_data->led[i];\n\t\t\t\tdrv_data->led[i] = NULL;\n\t\t\t\tif (!led)\n\t\t\t\t\tcontinue;\n\t\t\t\tled_classdev_unregister(led);\n\t\t\t\tkfree(led);\n\t\t\t}\n\t\t\tgoto out;\t \n\t\t}\n\t}\nout:\n\treturn 0;\nerr_free:\n\tkfree(drv_data);\n\treturn ret;\n}\n\nstatic void steelseries_srws1_remove(struct hid_device *hdev)\n{\n\tint i;\n\tstruct led_classdev *led;\n\n\tstruct steelseries_srws1_data *drv_data = hid_get_drvdata(hdev);\n\n\tif (drv_data) {\n\t\t \n\t\tfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++) {\n\t\t\tled = drv_data->led[i];\n\t\t\tdrv_data->led[i] = NULL;\n\t\t\tif (!led)\n\t\t\t\tcontinue;\n\t\t\tled_classdev_unregister(led);\n\t\t\tkfree(led);\n\t\t}\n\n\t}\n\n\thid_hw_stop(hdev);\n\tkfree(drv_data);\n\treturn;\n}\n#endif\n\n#define STEELSERIES_HEADSET_BATTERY_TIMEOUT_MS\t3000\n\n#define ARCTIS_1_BATTERY_RESPONSE_LEN\t\t8\nstatic const char arctis_1_battery_request[] = { 0x06, 0x12 };\n\nstatic int steelseries_headset_arctis_1_fetch_battery(struct hid_device *hdev)\n{\n\tu8 *write_buf;\n\tint ret;\n\n\t \n\twrite_buf = kmemdup(arctis_1_battery_request, sizeof(arctis_1_battery_request), GFP_KERNEL);\n\tif (!write_buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, arctis_1_battery_request[0],\n\t\t\t\t write_buf, sizeof(arctis_1_battery_request),\n\t\t\t\t HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);\n\tif (ret < (int)sizeof(arctis_1_battery_request)) {\n\t\thid_err(hdev, \"hid_hw_raw_request() failed with %d\\n\", ret);\n\t\tret = -ENODATA;\n\t}\n\tkfree(write_buf);\n\treturn ret;\n}\n\nstatic void steelseries_headset_fetch_battery(struct hid_device *hdev)\n{\n\tstruct steelseries_device *sd = hid_get_drvdata(hdev);\n\tint ret = 0;\n\n\tif (sd->quirks & STEELSERIES_ARCTIS_1)\n\t\tret = steelseries_headset_arctis_1_fetch_battery(hdev);\n\n\tif (ret < 0)\n\t\thid_dbg(hdev,\n\t\t\t\"Battery query failed (err: %d)\\n\", ret);\n}\n\nstatic void steelseries_headset_battery_timer_tick(struct work_struct *work)\n{\n\tstruct steelseries_device *sd = container_of(work,\n\t\tstruct steelseries_device, battery_work.work);\n\tstruct hid_device *hdev = sd->hdev;\n\n\tsteelseries_headset_fetch_battery(hdev);\n}\n\nstatic int steelseries_headset_battery_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct steelseries_device *sd = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = sd->headset_connected ?\n\t\t\tPOWER_SUPPLY_STATUS_DISCHARGING :\n\t\t\tPOWER_SUPPLY_STATUS_UNKNOWN;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = sd->battery_capacity;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void\nsteelseries_headset_set_wireless_status(struct hid_device *hdev,\n\t\t\t\t\tbool connected)\n{\n\tstruct usb_interface *intf;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn;\n\n\tintf = to_usb_interface(hdev->dev.parent);\n\tusb_set_wireless_status(intf, connected ?\n\t\t\t\tUSB_WIRELESS_STATUS_CONNECTED :\n\t\t\t\tUSB_WIRELESS_STATUS_DISCONNECTED);\n}\n\nstatic enum power_supply_property steelseries_headset_battery_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n};\n\nstatic int steelseries_headset_battery_register(struct steelseries_device *sd)\n{\n\tstatic atomic_t battery_no = ATOMIC_INIT(0);\n\tstruct power_supply_config battery_cfg = { .drv_data = sd, };\n\tunsigned long n;\n\tint ret;\n\n\tsd->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tsd->battery_desc.properties = steelseries_headset_battery_props;\n\tsd->battery_desc.num_properties = ARRAY_SIZE(steelseries_headset_battery_props);\n\tsd->battery_desc.get_property = steelseries_headset_battery_get_property;\n\tsd->battery_desc.use_for_apm = 0;\n\tn = atomic_inc_return(&battery_no) - 1;\n\tsd->battery_desc.name = devm_kasprintf(&sd->hdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t    \"steelseries_headset_battery_%ld\", n);\n\tif (!sd->battery_desc.name)\n\t\treturn -ENOMEM;\n\n\t \n\tsteelseries_headset_set_wireless_status(sd->hdev, false);\n\tsd->battery_capacity = 100;\n\n\tsd->battery = devm_power_supply_register(&sd->hdev->dev,\n\t\t\t&sd->battery_desc, &battery_cfg);\n\tif (IS_ERR(sd->battery)) {\n\t\tret = PTR_ERR(sd->battery);\n\t\thid_err(sd->hdev,\n\t\t\t\t\"%s:power_supply_register failed with error %d\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\tpower_supply_powers(sd->battery, &sd->hdev->dev);\n\n\tINIT_DELAYED_WORK(&sd->battery_work, steelseries_headset_battery_timer_tick);\n\tsteelseries_headset_fetch_battery(sd->hdev);\n\n\treturn 0;\n}\n\nstatic int steelseries_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct steelseries_device *sd;\n\tint ret;\n\n\tsd = devm_kzalloc(&hdev->dev, sizeof(*sd), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\thid_set_drvdata(hdev, sd);\n\tsd->hdev = hdev;\n\tsd->quirks = id->driver_data;\n\n\tif (sd->quirks & STEELSERIES_SRWS1) {\n#if IS_BUILTIN(CONFIG_LEDS_CLASS) || \\\n    (IS_MODULE(CONFIG_LEDS_CLASS) && IS_MODULE(CONFIG_HID_STEELSERIES))\n\t\treturn steelseries_srws1_probe(hdev, id);\n#else\n\t\treturn -ENODEV;\n#endif\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&sd->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (steelseries_headset_battery_register(sd) < 0)\n\t\thid_err(sd->hdev,\n\t\t\t\"Failed to register battery for headset\\n\");\n\n\treturn ret;\n}\n\nstatic void steelseries_remove(struct hid_device *hdev)\n{\n\tstruct steelseries_device *sd = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tif (sd->quirks & STEELSERIES_SRWS1) {\n#if IS_BUILTIN(CONFIG_LEDS_CLASS) || \\\n    (IS_MODULE(CONFIG_LEDS_CLASS) && IS_MODULE(CONFIG_HID_STEELSERIES))\n\t\tsteelseries_srws1_remove(hdev);\n#endif\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&sd->lock, flags);\n\tsd->removed = true;\n\tspin_unlock_irqrestore(&sd->lock, flags);\n\n\tcancel_delayed_work_sync(&sd->battery_work);\n\n\thid_hw_stop(hdev);\n}\n\nstatic __u8 *steelseries_srws1_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (hdev->vendor != USB_VENDOR_ID_STEELSERIES ||\n\t    hdev->product != USB_DEVICE_ID_STEELSERIES_SRWS1)\n\t\treturn rdesc;\n\n\tif (*rsize >= 115 && rdesc[11] == 0x02 && rdesc[13] == 0xc8\n\t\t\t&& rdesc[29] == 0xbb && rdesc[40] == 0xc5) {\n\t\thid_info(hdev, \"Fixing up Steelseries SRW-S1 report descriptor\\n\");\n\t\trdesc = steelseries_srws1_rdesc_fixed;\n\t\t*rsize = sizeof(steelseries_srws1_rdesc_fixed);\n\t}\n\treturn rdesc;\n}\n\nstatic int steelseries_headset_raw_event(struct hid_device *hdev,\n\t\t\t\t\tstruct hid_report *report, u8 *read_buf,\n\t\t\t\t\tint size)\n{\n\tstruct steelseries_device *sd = hid_get_drvdata(hdev);\n\tint capacity = sd->battery_capacity;\n\tbool connected = sd->headset_connected;\n\tunsigned long flags;\n\n\t \n\tif (sd->quirks & STEELSERIES_SRWS1)\n\t\treturn 0;\n\n\tif (sd->quirks & STEELSERIES_ARCTIS_1) {\n\t\thid_dbg(sd->hdev,\n\t\t\t\"Parsing raw event for Arctis 1 headset (%*ph)\\n\", size, read_buf);\n\t\tif (size < ARCTIS_1_BATTERY_RESPONSE_LEN ||\n\t\t    memcmp (read_buf, arctis_1_battery_request, sizeof(arctis_1_battery_request)))\n\t\t\treturn 0;\n\t\tif (read_buf[2] == 0x01) {\n\t\t\tconnected = false;\n\t\t\tcapacity = 100;\n\t\t} else {\n\t\t\tconnected = true;\n\t\t\tcapacity = read_buf[3];\n\t\t}\n\t}\n\n\tif (connected != sd->headset_connected) {\n\t\thid_dbg(sd->hdev,\n\t\t\t\"Connected status changed from %sconnected to %sconnected\\n\",\n\t\t\tsd->headset_connected ? \"\" : \"not \",\n\t\t\tconnected ? \"\" : \"not \");\n\t\tsd->headset_connected = connected;\n\t\tsteelseries_headset_set_wireless_status(hdev, connected);\n\t}\n\n\tif (capacity != sd->battery_capacity) {\n\t\thid_dbg(sd->hdev,\n\t\t\t\"Battery capacity changed from %d%% to %d%%\\n\",\n\t\t\tsd->battery_capacity, capacity);\n\t\tsd->battery_capacity = capacity;\n\t\tpower_supply_changed(sd->battery);\n\t}\n\n\tspin_lock_irqsave(&sd->lock, flags);\n\tif (!sd->removed)\n\t\tschedule_delayed_work(&sd->battery_work,\n\t\t\t\tmsecs_to_jiffies(STEELSERIES_HEADSET_BATTERY_TIMEOUT_MS));\n\tspin_unlock_irqrestore(&sd->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id steelseries_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_STEELSERIES, USB_DEVICE_ID_STEELSERIES_SRWS1),\n\t  .driver_data = STEELSERIES_SRWS1 },\n\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_STEELSERIES, 0x12b6),\n\t.driver_data = STEELSERIES_ARCTIS_1 },\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, steelseries_devices);\n\nstatic struct hid_driver steelseries_driver = {\n\t.name = \"steelseries\",\n\t.id_table = steelseries_devices,\n\t.probe = steelseries_probe,\n\t.remove = steelseries_remove,\n\t.report_fixup = steelseries_srws1_report_fixup,\n\t.raw_event = steelseries_headset_raw_event,\n};\n\nmodule_hid_driver(steelseries_driver);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bastien Nocera <hadess@hadess.net>\");\nMODULE_AUTHOR(\"Simon Wood <simon@mungewell.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}