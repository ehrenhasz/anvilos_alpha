{
  "module_name": "hid-nvidia-shield.c",
  "hash_id": "ed663135733553a49d021e5543ec8f0cc0b6095740174c46d7b323629cae88ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-nvidia-shield.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/idr.h>\n#include <linux/input-event-codes.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/power_supply.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n\n#include \"hid-ids.h\"\n\n#define NOT_INIT_STR \"NOT INITIALIZED\"\n#define android_map_key(c) hid_map_usage(hi, usage, bit, max, EV_KEY, (c))\n\nenum {\n\tHID_USAGE_ANDROID_PLAYPAUSE_BTN = 0xcd,  \n\tHID_USAGE_ANDROID_VOLUMEUP_BTN = 0xe9,\n\tHID_USAGE_ANDROID_VOLUMEDOWN_BTN = 0xea,\n\tHID_USAGE_ANDROID_SEARCH_BTN = 0x221,  \n\tHID_USAGE_ANDROID_HOME_BTN = 0x223,\n\tHID_USAGE_ANDROID_BACK_BTN = 0x224,\n};\n\nenum {\n\tSHIELD_FW_VERSION_INITIALIZED = 0,\n\tSHIELD_BOARD_INFO_INITIALIZED,\n\tSHIELD_BATTERY_STATS_INITIALIZED,\n\tSHIELD_CHARGER_STATE_INITIALIZED,\n};\n\nenum {\n\tTHUNDERSTRIKE_FW_VERSION_UPDATE = 0,\n\tTHUNDERSTRIKE_BOARD_INFO_UPDATE,\n\tTHUNDERSTRIKE_HAPTICS_UPDATE,\n\tTHUNDERSTRIKE_LED_UPDATE,\n\tTHUNDERSTRIKE_POWER_SUPPLY_STATS_UPDATE,\n};\n\nenum {\n\tTHUNDERSTRIKE_HOSTCMD_REPORT_SIZE = 33,\n\tTHUNDERSTRIKE_HOSTCMD_REQ_REPORT_ID = 0x4,\n\tTHUNDERSTRIKE_HOSTCMD_RESP_REPORT_ID = 0x3,\n};\n\nenum {\n\tTHUNDERSTRIKE_HOSTCMD_ID_FW_VERSION = 1,\n\tTHUNDERSTRIKE_HOSTCMD_ID_LED = 6,\n\tTHUNDERSTRIKE_HOSTCMD_ID_BATTERY,\n\tTHUNDERSTRIKE_HOSTCMD_ID_BOARD_INFO = 16,\n\tTHUNDERSTRIKE_HOSTCMD_ID_USB_INIT = 53,\n\tTHUNDERSTRIKE_HOSTCMD_ID_HAPTICS = 57,\n\tTHUNDERSTRIKE_HOSTCMD_ID_CHARGER,\n};\n\nstruct power_supply_dev {\n\tstruct power_supply *psy;\n\tstruct power_supply_desc desc;\n};\n\nstruct thunderstrike_psy_prop_values {\n\tint voltage_min;\n\tint voltage_now;\n\tint voltage_avg;\n\tint voltage_boot;\n\tint capacity;\n\tint status;\n\tint charge_type;\n\tint temp;\n};\n\nstatic const enum power_supply_property thunderstrike_battery_props[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_VOLTAGE_AVG,\n\tPOWER_SUPPLY_PROP_VOLTAGE_BOOT,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TEMP_MIN,\n\tPOWER_SUPPLY_PROP_TEMP_MAX,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MIN,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MAX,\n};\n\nenum thunderstrike_led_state {\n\tTHUNDERSTRIKE_LED_OFF = 1,\n\tTHUNDERSTRIKE_LED_ON = 8,\n} __packed;\nstatic_assert(sizeof(enum thunderstrike_led_state) == 1);\n\nstruct thunderstrike_hostcmd_battery {\n\t__le16 voltage_avg;\n\tu8 reserved_at_10;\n\t__le16 thermistor;\n\t__le16 voltage_min;\n\t__le16 voltage_boot;\n\t__le16 voltage_now;\n\tu8 capacity;\n} __packed;\n\nenum thunderstrike_charger_type {\n\tTHUNDERSTRIKE_CHARGER_TYPE_NONE = 0,\n\tTHUNDERSTRIKE_CHARGER_TYPE_TRICKLE,\n\tTHUNDERSTRIKE_CHARGER_TYPE_NORMAL,\n} __packed;\nstatic_assert(sizeof(enum thunderstrike_charger_type) == 1);\n\nenum thunderstrike_charger_state {\n\tTHUNDERSTRIKE_CHARGER_STATE_UNKNOWN = 0,\n\tTHUNDERSTRIKE_CHARGER_STATE_DISABLED,\n\tTHUNDERSTRIKE_CHARGER_STATE_CHARGING,\n\tTHUNDERSTRIKE_CHARGER_STATE_FULL,\n\tTHUNDERSTRIKE_CHARGER_STATE_FAILED = 8,\n} __packed;\nstatic_assert(sizeof(enum thunderstrike_charger_state) == 1);\n\nstruct thunderstrike_hostcmd_charger {\n\tu8 connected;\n\tenum thunderstrike_charger_type type;\n\tenum thunderstrike_charger_state state;\n} __packed;\n\nstruct thunderstrike_hostcmd_board_info {\n\t__le16 revision;\n\t__le16 serial[7];\n} __packed;\n\nstruct thunderstrike_hostcmd_haptics {\n\tu8 motor_left;\n\tu8 motor_right;\n} __packed;\n\nstruct thunderstrike_hostcmd_resp_report {\n\tu8 report_id;  \n\tu8 cmd_id;\n\tu8 reserved_at_10;\n\n\tunion {\n\t\tstruct thunderstrike_hostcmd_board_info board_info;\n\t\tstruct thunderstrike_hostcmd_haptics motors;\n\t\t__le16 fw_version;\n\t\tenum thunderstrike_led_state led_state;\n\t\tstruct thunderstrike_hostcmd_battery battery;\n\t\tstruct thunderstrike_hostcmd_charger charger;\n\t\tu8 payload[30];\n\t} __packed;\n} __packed;\nstatic_assert(sizeof(struct thunderstrike_hostcmd_resp_report) ==\n\t      THUNDERSTRIKE_HOSTCMD_REPORT_SIZE);\n\nstruct thunderstrike_hostcmd_req_report {\n\tu8 report_id;  \n\tu8 cmd_id;\n\tu8 reserved_at_10;\n\n\tunion {\n\t\tstruct __packed {\n\t\t\tu8 update;\n\t\t\tenum thunderstrike_led_state state;\n\t\t} led;\n\t\tstruct __packed {\n\t\t\tu8 update;\n\t\t\tstruct thunderstrike_hostcmd_haptics motors;\n\t\t} haptics;\n\t} __packed;\n\tu8 reserved_at_30[27];\n} __packed;\nstatic_assert(sizeof(struct thunderstrike_hostcmd_req_report) ==\n\t      THUNDERSTRIKE_HOSTCMD_REPORT_SIZE);\n\n \nstruct shield_device {\n\tstruct hid_device *hdev;\n\tstruct power_supply_dev battery_dev;\n\n\tunsigned long initialized_flags;\n\tconst char *codename;\n\tu16 fw_version;\n\tstruct {\n\t\tu16 revision;\n\t\tchar serial_number[15];\n\t} board_info;\n};\n\n \nstatic DEFINE_IDA(thunderstrike_ida);\n\nstruct thunderstrike {\n\tstruct shield_device base;\n\n\tint id;\n\n\t \n\tstruct input_dev *haptics_dev;\n\tstruct led_classdev led_dev;\n\n\t \n\tvoid *req_report_dmabuf;\n\tunsigned long update_flags;\n\tstruct thunderstrike_hostcmd_haptics haptics_val;\n\tspinlock_t haptics_update_lock;\n\tu8 led_state : 1;\n\tenum thunderstrike_led_state led_value;\n\tstruct thunderstrike_psy_prop_values psy_stats;\n\tspinlock_t psy_stats_lock;\n\tstruct timer_list psy_stats_timer;\n\tstruct work_struct hostcmd_req_work;\n};\n\nstatic inline void thunderstrike_hostcmd_req_report_init(\n\tstruct thunderstrike_hostcmd_req_report *report, u8 cmd_id)\n{\n\tmemset(report, 0, sizeof(*report));\n\treport->report_id = THUNDERSTRIKE_HOSTCMD_REQ_REPORT_ID;\n\treport->cmd_id = cmd_id;\n}\n\nstatic inline void shield_strrev(char *dest, size_t len, u16 rev)\n{\n\tdest[0] = ('A' - 1) + (rev >> 8);\n\tsnprintf(&dest[1], len - 1, \"%02X\", 0xff & rev);\n}\n\nstatic struct input_dev *shield_allocate_input_dev(struct hid_device *hdev,\n\t\t\t\t\t\t   const char *name_suffix)\n{\n\tstruct input_dev *idev;\n\n\tidev = input_allocate_device();\n\tif (!idev)\n\t\tgoto err_device;\n\n\tidev->id.bustype = hdev->bus;\n\tidev->id.vendor = hdev->vendor;\n\tidev->id.product = hdev->product;\n\tidev->id.version = hdev->version;\n\tidev->uniq = hdev->uniq;\n\tidev->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, \"%s %s\", hdev->name,\n\t\t\t\t    name_suffix);\n\tif (!idev->name)\n\t\tgoto err_name;\n\n\tinput_set_drvdata(idev, hdev);\n\n\treturn idev;\n\nerr_name:\n\tinput_free_device(idev);\nerr_device:\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic struct input_dev *shield_haptics_create(\n\tstruct shield_device *dev,\n\tint (*play_effect)(struct input_dev *, void *, struct ff_effect *))\n{\n\tstruct input_dev *haptics;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_NVIDIA_SHIELD_FF))\n\t\treturn NULL;\n\n\thaptics = shield_allocate_input_dev(dev->hdev, \"Haptics\");\n\tif (IS_ERR(haptics))\n\t\treturn haptics;\n\n\tinput_set_capability(haptics, EV_FF, FF_RUMBLE);\n\tinput_ff_create_memless(haptics, NULL, play_effect);\n\n\tret = input_register_device(haptics);\n\tif (ret)\n\t\tgoto err;\n\n\treturn haptics;\n\nerr:\n\tinput_free_device(haptics);\n\treturn ERR_PTR(ret);\n}\n\nstatic inline void thunderstrike_send_hostcmd_request(struct thunderstrike *ts)\n{\n\tstruct thunderstrike_hostcmd_req_report *report = ts->req_report_dmabuf;\n\tstruct shield_device *shield_dev = &ts->base;\n\tint ret;\n\n\tret = hid_hw_raw_request(shield_dev->hdev, report->report_id,\n\t\t\t\t ts->req_report_dmabuf,\n\t\t\t\t THUNDERSTRIKE_HOSTCMD_REPORT_SIZE,\n\t\t\t\t HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);\n\n\tif (ret < 0) {\n\t\thid_err(shield_dev->hdev,\n\t\t\t\"Failed to output Thunderstrike HOSTCMD request HID report due to %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t}\n}\n\nstatic void thunderstrike_hostcmd_req_work_handler(struct work_struct *work)\n{\n\tstruct thunderstrike *ts =\n\t\tcontainer_of(work, struct thunderstrike, hostcmd_req_work);\n\tstruct thunderstrike_hostcmd_req_report *report;\n\tunsigned long flags;\n\n\treport = ts->req_report_dmabuf;\n\n\tif (test_and_clear_bit(THUNDERSTRIKE_FW_VERSION_UPDATE, &ts->update_flags)) {\n\t\tthunderstrike_hostcmd_req_report_init(\n\t\t\treport, THUNDERSTRIKE_HOSTCMD_ID_FW_VERSION);\n\t\tthunderstrike_send_hostcmd_request(ts);\n\t}\n\n\tif (test_and_clear_bit(THUNDERSTRIKE_LED_UPDATE, &ts->update_flags)) {\n\t\tthunderstrike_hostcmd_req_report_init(report, THUNDERSTRIKE_HOSTCMD_ID_LED);\n\t\treport->led.update = 1;\n\t\treport->led.state = ts->led_value;\n\t\tthunderstrike_send_hostcmd_request(ts);\n\t}\n\n\tif (test_and_clear_bit(THUNDERSTRIKE_POWER_SUPPLY_STATS_UPDATE, &ts->update_flags)) {\n\t\tthunderstrike_hostcmd_req_report_init(\n\t\t\treport, THUNDERSTRIKE_HOSTCMD_ID_BATTERY);\n\t\tthunderstrike_send_hostcmd_request(ts);\n\n\t\tthunderstrike_hostcmd_req_report_init(\n\t\t\treport, THUNDERSTRIKE_HOSTCMD_ID_CHARGER);\n\t\tthunderstrike_send_hostcmd_request(ts);\n\t}\n\n\tif (test_and_clear_bit(THUNDERSTRIKE_BOARD_INFO_UPDATE, &ts->update_flags)) {\n\t\tthunderstrike_hostcmd_req_report_init(\n\t\t\treport, THUNDERSTRIKE_HOSTCMD_ID_BOARD_INFO);\n\t\tthunderstrike_send_hostcmd_request(ts);\n\t}\n\n\tif (test_and_clear_bit(THUNDERSTRIKE_HAPTICS_UPDATE, &ts->update_flags)) {\n\t\tthunderstrike_hostcmd_req_report_init(\n\t\t\treport, THUNDERSTRIKE_HOSTCMD_ID_HAPTICS);\n\n\t\treport->haptics.update = 1;\n\t\tspin_lock_irqsave(&ts->haptics_update_lock, flags);\n\t\treport->haptics.motors = ts->haptics_val;\n\t\tspin_unlock_irqrestore(&ts->haptics_update_lock, flags);\n\n\t\tthunderstrike_send_hostcmd_request(ts);\n\t}\n}\n\nstatic inline void thunderstrike_request_firmware_version(struct thunderstrike *ts)\n{\n\tset_bit(THUNDERSTRIKE_FW_VERSION_UPDATE, &ts->update_flags);\n\tschedule_work(&ts->hostcmd_req_work);\n}\n\nstatic inline void thunderstrike_request_board_info(struct thunderstrike *ts)\n{\n\tset_bit(THUNDERSTRIKE_BOARD_INFO_UPDATE, &ts->update_flags);\n\tschedule_work(&ts->hostcmd_req_work);\n}\n\nstatic inline int\nthunderstrike_update_haptics(struct thunderstrike *ts,\n\t\t\t     struct thunderstrike_hostcmd_haptics *motors)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ts->haptics_update_lock, flags);\n\tts->haptics_val = *motors;\n\tspin_unlock_irqrestore(&ts->haptics_update_lock, flags);\n\n\tset_bit(THUNDERSTRIKE_HAPTICS_UPDATE, &ts->update_flags);\n\tschedule_work(&ts->hostcmd_req_work);\n\n\treturn 0;\n}\n\nstatic int thunderstrike_play_effect(struct input_dev *idev, void *data,\n\t\t\t\t     struct ff_effect *effect)\n{\n\tstruct hid_device *hdev = input_get_drvdata(idev);\n\tstruct thunderstrike_hostcmd_haptics motors;\n\tstruct shield_device *shield_dev;\n\tstruct thunderstrike *ts;\n\n\tif (effect->type != FF_RUMBLE)\n\t\treturn 0;\n\n\tshield_dev = hid_get_drvdata(hdev);\n\tts = container_of(shield_dev, struct thunderstrike, base);\n\n\t \n\tmotors.motor_left = effect->u.rumble.strong_magnitude / 2047;\n\tmotors.motor_right = effect->u.rumble.weak_magnitude / 2047;\n\n\thid_dbg(hdev, \"Thunderstrike FF_RUMBLE request, left: %u right: %u\\n\",\n\t\tmotors.motor_left, motors.motor_right);\n\n\treturn thunderstrike_update_haptics(ts, &motors);\n}\n\nstatic enum led_brightness\nthunderstrike_led_get_brightness(struct led_classdev *led)\n{\n\tstruct hid_device *hdev = to_hid_device(led->dev->parent);\n\tstruct shield_device *shield_dev = hid_get_drvdata(hdev);\n\tstruct thunderstrike *ts;\n\n\tts = container_of(shield_dev, struct thunderstrike, base);\n\n\treturn ts->led_state;\n}\n\nstatic void thunderstrike_led_set_brightness(struct led_classdev *led,\n\t\t\t\t\t    enum led_brightness value)\n{\n\tstruct hid_device *hdev = to_hid_device(led->dev->parent);\n\tstruct shield_device *shield_dev = hid_get_drvdata(hdev);\n\tstruct thunderstrike *ts;\n\n\tts = container_of(shield_dev, struct thunderstrike, base);\n\n\tswitch (value) {\n\tcase LED_OFF:\n\t\tts->led_value = THUNDERSTRIKE_LED_OFF;\n\t\tbreak;\n\tdefault:\n\t\tts->led_value = THUNDERSTRIKE_LED_ON;\n\t\tbreak;\n\t}\n\n\tset_bit(THUNDERSTRIKE_LED_UPDATE, &ts->update_flags);\n\tschedule_work(&ts->hostcmd_req_work);\n}\n\nstatic int thunderstrike_battery_get_property(struct power_supply *psy,\n\t\t\t\t\t      enum power_supply_property psp,\n\t\t\t\t\t      union power_supply_propval *val)\n{\n\tstruct shield_device *shield_dev = power_supply_get_drvdata(psy);\n\tstruct thunderstrike_psy_prop_values prop_values;\n\tstruct thunderstrike *ts;\n\tint ret = 0;\n\n\tts = container_of(shield_dev, struct thunderstrike, base);\n\tspin_lock(&ts->psy_stats_lock);\n\tprop_values = ts->psy_stats;\n\tspin_unlock(&ts->psy_stats_lock);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = prop_values.status;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tval->intval = prop_values.charge_type;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\tval->intval = prop_values.voltage_min;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\n\t\tval->intval = 2900000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\n\t\tval->intval = 2200000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = prop_values.voltage_now;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_AVG:\n\t\tval->intval = prop_values.voltage_avg;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_BOOT:\n\t\tval->intval = prop_values.voltage_boot;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = prop_values.capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval = prop_values.temp;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_MIN:\n\t\tval->intval = 0;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_MAX:\n\t\tval->intval = 400;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\n\t\tval->intval = 15;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tval->intval = 380;  \n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic inline void thunderstrike_request_psy_stats(struct thunderstrike *ts)\n{\n\tset_bit(THUNDERSTRIKE_POWER_SUPPLY_STATS_UPDATE, &ts->update_flags);\n\tschedule_work(&ts->hostcmd_req_work);\n}\n\nstatic void thunderstrike_psy_stats_timer_handler(struct timer_list *timer)\n{\n\tstruct thunderstrike *ts =\n\t\tcontainer_of(timer, struct thunderstrike, psy_stats_timer);\n\n\tthunderstrike_request_psy_stats(ts);\n\t \n\tmod_timer(timer, jiffies + 300 * HZ);\n}\n\nstatic void\nthunderstrike_parse_fw_version_payload(struct shield_device *shield_dev,\n\t\t\t\t       __le16 fw_version)\n{\n\tshield_dev->fw_version = le16_to_cpu(fw_version);\n\n\tset_bit(SHIELD_FW_VERSION_INITIALIZED, &shield_dev->initialized_flags);\n\n\thid_dbg(shield_dev->hdev, \"Thunderstrike firmware version 0x%04X\\n\",\n\t\tshield_dev->fw_version);\n}\n\nstatic void\nthunderstrike_parse_board_info_payload(struct shield_device *shield_dev,\n\t\t\t\t       struct thunderstrike_hostcmd_board_info *board_info)\n{\n\tchar board_revision_str[4];\n\tint i;\n\n\tshield_dev->board_info.revision = le16_to_cpu(board_info->revision);\n\tfor (i = 0; i < 7; ++i) {\n\t\tu16 val = le16_to_cpu(board_info->serial[i]);\n\n\t\tshield_dev->board_info.serial_number[2 * i] = val & 0xFF;\n\t\tshield_dev->board_info.serial_number[2 * i + 1] = val >> 8;\n\t}\n\tshield_dev->board_info.serial_number[14] = '\\0';\n\n\tset_bit(SHIELD_BOARD_INFO_INITIALIZED, &shield_dev->initialized_flags);\n\n\tshield_strrev(board_revision_str, 4, shield_dev->board_info.revision);\n\thid_dbg(shield_dev->hdev,\n\t\t\"Thunderstrike BOARD_REVISION_%s (0x%04X) S/N: %s\\n\",\n\t\tboard_revision_str, shield_dev->board_info.revision,\n\t\tshield_dev->board_info.serial_number);\n}\n\nstatic inline void\nthunderstrike_parse_haptics_payload(struct shield_device *shield_dev,\n\t\t\t\t    struct thunderstrike_hostcmd_haptics *haptics)\n{\n\thid_dbg(shield_dev->hdev,\n\t\t\"Thunderstrike haptics HOSTCMD response, left: %u right: %u\\n\",\n\t\thaptics->motor_left, haptics->motor_right);\n}\n\nstatic void\nthunderstrike_parse_led_payload(struct shield_device *shield_dev,\n\t\t\t\tenum thunderstrike_led_state led_state)\n{\n\tstruct thunderstrike *ts = container_of(shield_dev, struct thunderstrike, base);\n\n\tswitch (led_state) {\n\tcase THUNDERSTRIKE_LED_OFF:\n\t\tts->led_state = 0;\n\t\tbreak;\n\tcase THUNDERSTRIKE_LED_ON:\n\t\tts->led_state = 1;\n\t\tbreak;\n\t}\n\n\thid_dbg(shield_dev->hdev, \"Thunderstrike led HOSTCMD response, 0x%02X\\n\", led_state);\n}\n\nstatic void thunderstrike_parse_battery_payload(\n\tstruct shield_device *shield_dev,\n\tstruct thunderstrike_hostcmd_battery *battery)\n{\n\tstruct thunderstrike *ts = container_of(shield_dev, struct thunderstrike, base);\n\tu16 hostcmd_voltage_boot = le16_to_cpu(battery->voltage_boot);\n\tu16 hostcmd_voltage_avg = le16_to_cpu(battery->voltage_avg);\n\tu16 hostcmd_voltage_min = le16_to_cpu(battery->voltage_min);\n\tu16 hostcmd_voltage_now = le16_to_cpu(battery->voltage_now);\n\tu16 hostcmd_thermistor = le16_to_cpu(battery->thermistor);\n\tint voltage_boot, voltage_avg, voltage_min, voltage_now;\n\tstruct hid_device *hdev = shield_dev->hdev;\n\tu8 capacity = battery->capacity;\n\tint temp;\n\n\t \n\tvoltage_boot = hostcmd_voltage_boot * 1000;\n\tvoltage_avg = hostcmd_voltage_avg * 1000;\n\tvoltage_min = hostcmd_voltage_min * 1000;\n\tvoltage_now = hostcmd_voltage_now * 1000;\n\ttemp = (1378 - (int)hostcmd_thermistor) * 10 / 19;\n\n\t \n\tspin_lock(&ts->psy_stats_lock);\n\tts->psy_stats.voltage_boot = voltage_boot;\n\tts->psy_stats.voltage_avg = voltage_avg;\n\tts->psy_stats.voltage_min = voltage_min;\n\tts->psy_stats.voltage_now = voltage_now;\n\tts->psy_stats.capacity = capacity;\n\tts->psy_stats.temp = temp;\n\tspin_unlock(&ts->psy_stats_lock);\n\n\tset_bit(SHIELD_BATTERY_STATS_INITIALIZED, &shield_dev->initialized_flags);\n\n\thid_dbg(hdev,\n\t\t\"Thunderstrike battery HOSTCMD response, voltage_avg: %u voltage_now: %u\\n\",\n\t\thostcmd_voltage_avg, hostcmd_voltage_now);\n\thid_dbg(hdev,\n\t\t\"Thunderstrike battery HOSTCMD response, voltage_boot: %u voltage_min: %u\\n\",\n\t\thostcmd_voltage_boot, hostcmd_voltage_min);\n\thid_dbg(hdev,\n\t\t\"Thunderstrike battery HOSTCMD response, thermistor: %u\\n\",\n\t\thostcmd_thermistor);\n\thid_dbg(hdev,\n\t\t\"Thunderstrike battery HOSTCMD response, capacity: %u%%\\n\",\n\t\tcapacity);\n}\n\nstatic void thunderstrike_parse_charger_payload(\n\tstruct shield_device *shield_dev,\n\tstruct thunderstrike_hostcmd_charger *charger)\n{\n\tstruct thunderstrike *ts = container_of(shield_dev, struct thunderstrike, base);\n\tint charge_type = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;\n\tstruct hid_device *hdev = shield_dev->hdev;\n\tint status = POWER_SUPPLY_STATUS_UNKNOWN;\n\n\tswitch (charger->type) {\n\tcase THUNDERSTRIKE_CHARGER_TYPE_NONE:\n\t\tcharge_type = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t\tbreak;\n\tcase THUNDERSTRIKE_CHARGER_TYPE_TRICKLE:\n\t\tcharge_type = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t\tbreak;\n\tcase THUNDERSTRIKE_CHARGER_TYPE_NORMAL:\n\t\tcharge_type = POWER_SUPPLY_CHARGE_TYPE_STANDARD;\n\t\tbreak;\n\tdefault:\n\t\thid_warn(hdev, \"Unhandled Thunderstrike charger HOSTCMD type, %u\\n\",\n\t\t\t charger->type);\n\t\tbreak;\n\t}\n\n\tswitch (charger->state) {\n\tcase THUNDERSTRIKE_CHARGER_STATE_UNKNOWN:\n\t\tstatus = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tbreak;\n\tcase THUNDERSTRIKE_CHARGER_STATE_DISABLED:\n\t\t \n\t\tbreak;\n\tcase THUNDERSTRIKE_CHARGER_STATE_CHARGING:\n\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase THUNDERSTRIKE_CHARGER_STATE_FULL:\n\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase THUNDERSTRIKE_CHARGER_STATE_FAILED:\n\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\thid_err(hdev, \"Thunderstrike device failed to charge\\n\");\n\t\tbreak;\n\tdefault:\n\t\thid_warn(hdev, \"Unhandled Thunderstrike charger HOSTCMD state, %u\\n\",\n\t\t\t charger->state);\n\t\tbreak;\n\t}\n\n\tif (!charger->connected)\n\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\tspin_lock(&ts->psy_stats_lock);\n\tts->psy_stats.charge_type = charge_type;\n\tts->psy_stats.status = status;\n\tspin_unlock(&ts->psy_stats_lock);\n\n\tset_bit(SHIELD_CHARGER_STATE_INITIALIZED, &shield_dev->initialized_flags);\n\n\thid_dbg(hdev,\n\t\t\"Thunderstrike charger HOSTCMD response, connected: %u, type: %u, state: %u\\n\",\n\t\tcharger->connected, charger->type, charger->state);\n}\n\nstatic inline void thunderstrike_device_init_info(struct shield_device *shield_dev)\n{\n\tstruct thunderstrike *ts =\n\t\tcontainer_of(shield_dev, struct thunderstrike, base);\n\n\tif (!test_bit(SHIELD_FW_VERSION_INITIALIZED, &shield_dev->initialized_flags))\n\t\tthunderstrike_request_firmware_version(ts);\n\n\tif (!test_bit(SHIELD_BOARD_INFO_INITIALIZED, &shield_dev->initialized_flags))\n\t\tthunderstrike_request_board_info(ts);\n\n\tif (!test_bit(SHIELD_BATTERY_STATS_INITIALIZED, &shield_dev->initialized_flags) ||\n\t    !test_bit(SHIELD_CHARGER_STATE_INITIALIZED, &shield_dev->initialized_flags))\n\t\tthunderstrike_psy_stats_timer_handler(&ts->psy_stats_timer);\n}\n\nstatic int thunderstrike_parse_report(struct shield_device *shield_dev,\n\t\t\t\t      struct hid_report *report, u8 *data,\n\t\t\t\t      int size)\n{\n\tstruct thunderstrike_hostcmd_resp_report *hostcmd_resp_report;\n\tstruct hid_device *hdev = shield_dev->hdev;\n\n\tswitch (report->id) {\n\tcase THUNDERSTRIKE_HOSTCMD_RESP_REPORT_ID:\n\t\tif (size != THUNDERSTRIKE_HOSTCMD_REPORT_SIZE) {\n\t\t\thid_err(hdev,\n\t\t\t\t\"Encountered Thunderstrike HOSTCMD HID report with unexpected size %d\\n\",\n\t\t\t\tsize);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thostcmd_resp_report =\n\t\t\t(struct thunderstrike_hostcmd_resp_report *)data;\n\n\t\tswitch (hostcmd_resp_report->cmd_id) {\n\t\tcase THUNDERSTRIKE_HOSTCMD_ID_FW_VERSION:\n\t\t\tthunderstrike_parse_fw_version_payload(\n\t\t\t\tshield_dev, hostcmd_resp_report->fw_version);\n\t\t\tbreak;\n\t\tcase THUNDERSTRIKE_HOSTCMD_ID_LED:\n\t\t\tthunderstrike_parse_led_payload(shield_dev, hostcmd_resp_report->led_state);\n\t\t\tbreak;\n\t\tcase THUNDERSTRIKE_HOSTCMD_ID_BATTERY:\n\t\t\tthunderstrike_parse_battery_payload(shield_dev,\n\t\t\t\t\t\t\t    &hostcmd_resp_report->battery);\n\t\t\tbreak;\n\t\tcase THUNDERSTRIKE_HOSTCMD_ID_BOARD_INFO:\n\t\t\tthunderstrike_parse_board_info_payload(\n\t\t\t\tshield_dev, &hostcmd_resp_report->board_info);\n\t\t\tbreak;\n\t\tcase THUNDERSTRIKE_HOSTCMD_ID_HAPTICS:\n\t\t\tthunderstrike_parse_haptics_payload(\n\t\t\t\tshield_dev, &hostcmd_resp_report->motors);\n\t\t\tbreak;\n\t\tcase THUNDERSTRIKE_HOSTCMD_ID_USB_INIT:\n\t\t\t \n\t\t\tthunderstrike_device_init_info(shield_dev);\n\t\t\tbreak;\n\t\tcase THUNDERSTRIKE_HOSTCMD_ID_CHARGER:\n\t\t\t \n\t\t\tthunderstrike_device_init_info(shield_dev);\n\n\t\t\tthunderstrike_parse_charger_payload(\n\t\t\t\tshield_dev, &hostcmd_resp_report->charger);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thid_warn(hdev,\n\t\t\t\t \"Unhandled Thunderstrike HOSTCMD id %d\\n\",\n\t\t\t\t hostcmd_resp_report->cmd_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int thunderstrike_led_create(struct thunderstrike *ts)\n{\n\tstruct led_classdev *led = &ts->led_dev;\n\n\tled->name = devm_kasprintf(&ts->base.hdev->dev, GFP_KERNEL,\n\t\t\t\t   \"thunderstrike%d:blue:led\", ts->id);\n\tled->max_brightness = 1;\n\tled->flags = LED_CORE_SUSPENDRESUME | LED_RETAIN_AT_SHUTDOWN;\n\tled->brightness_get = &thunderstrike_led_get_brightness;\n\tled->brightness_set = &thunderstrike_led_set_brightness;\n\n\treturn led_classdev_register(&ts->base.hdev->dev, led);\n}\n\nstatic inline int thunderstrike_psy_create(struct shield_device *shield_dev)\n{\n\tstruct thunderstrike *ts = container_of(shield_dev, struct thunderstrike, base);\n\tstruct power_supply_config psy_cfg = { .drv_data = shield_dev, };\n\tstruct hid_device *hdev = shield_dev->hdev;\n\tint ret;\n\n\t \n\tts->psy_stats.capacity = 100;\n\tts->psy_stats.temp = 182;\n\n\tshield_dev->battery_dev.desc.properties = thunderstrike_battery_props;\n\tshield_dev->battery_dev.desc.num_properties =\n\t\tARRAY_SIZE(thunderstrike_battery_props);\n\tshield_dev->battery_dev.desc.get_property = thunderstrike_battery_get_property;\n\tshield_dev->battery_dev.desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tshield_dev->battery_dev.desc.name =\n\t\tdevm_kasprintf(&ts->base.hdev->dev, GFP_KERNEL,\n\t\t\t       \"thunderstrike_%d\", ts->id);\n\n\tshield_dev->battery_dev.psy = power_supply_register(\n\t\t&hdev->dev, &shield_dev->battery_dev.desc, &psy_cfg);\n\tif (IS_ERR(shield_dev->battery_dev.psy)) {\n\t\thid_err(hdev, \"Failed to register Thunderstrike battery device\\n\");\n\t\treturn PTR_ERR(shield_dev->battery_dev.psy);\n\t}\n\n\tret = power_supply_powers(shield_dev->battery_dev.psy, &hdev->dev);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to associate battery device to Thunderstrike\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tpower_supply_unregister(shield_dev->battery_dev.psy);\n\treturn ret;\n}\n\nstatic struct shield_device *thunderstrike_create(struct hid_device *hdev)\n{\n\tstruct shield_device *shield_dev;\n\tstruct thunderstrike *ts;\n\tint ret;\n\n\tts = devm_kzalloc(&hdev->dev, sizeof(*ts), GFP_KERNEL);\n\tif (!ts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tts->req_report_dmabuf = devm_kzalloc(\n\t\t&hdev->dev, THUNDERSTRIKE_HOSTCMD_REPORT_SIZE, GFP_KERNEL);\n\tif (!ts->req_report_dmabuf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tshield_dev = &ts->base;\n\tshield_dev->hdev = hdev;\n\tshield_dev->codename = \"Thunderstrike\";\n\n\tspin_lock_init(&ts->haptics_update_lock);\n\tspin_lock_init(&ts->psy_stats_lock);\n\tINIT_WORK(&ts->hostcmd_req_work, thunderstrike_hostcmd_req_work_handler);\n\n\thid_set_drvdata(hdev, shield_dev);\n\n\tts->id = ida_alloc(&thunderstrike_ida, GFP_KERNEL);\n\tif (ts->id < 0)\n\t\treturn ERR_PTR(ts->id);\n\n\tts->haptics_dev = shield_haptics_create(shield_dev, thunderstrike_play_effect);\n\tif (IS_ERR(ts->haptics_dev)) {\n\t\thid_err(hdev, \"Failed to create Thunderstrike haptics instance\\n\");\n\t\tret = PTR_ERR(ts->haptics_dev);\n\t\tgoto err_id;\n\t}\n\n\tret = thunderstrike_psy_create(shield_dev);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to create Thunderstrike power supply instance\\n\");\n\t\tgoto err_haptics;\n\t}\n\n\tret = thunderstrike_led_create(ts);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to create Thunderstrike LED instance\\n\");\n\t\tgoto err_psy;\n\t}\n\n\ttimer_setup(&ts->psy_stats_timer, thunderstrike_psy_stats_timer_handler, 0);\n\n\thid_info(hdev, \"Registered Thunderstrike controller\\n\");\n\treturn shield_dev;\n\nerr_psy:\n\tpower_supply_unregister(shield_dev->battery_dev.psy);\nerr_haptics:\n\tif (ts->haptics_dev)\n\t\tinput_unregister_device(ts->haptics_dev);\nerr_id:\n\tida_free(&thunderstrike_ida, ts->id);\n\treturn ERR_PTR(ret);\n}\n\nstatic int android_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t\t struct hid_field *field,\n\t\t\t\t struct hid_usage *usage, unsigned long **bit,\n\t\t\t\t int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase HID_USAGE_ANDROID_PLAYPAUSE_BTN:\n\t\tandroid_map_key(KEY_PLAYPAUSE);\n\t\tbreak;\n\tcase HID_USAGE_ANDROID_VOLUMEUP_BTN:\n\t\tandroid_map_key(KEY_VOLUMEUP);\n\t\tbreak;\n\tcase HID_USAGE_ANDROID_VOLUMEDOWN_BTN:\n\t\tandroid_map_key(KEY_VOLUMEDOWN);\n\t\tbreak;\n\tcase HID_USAGE_ANDROID_SEARCH_BTN:\n\t\tandroid_map_key(BTN_Z);\n\t\tbreak;\n\tcase HID_USAGE_ANDROID_HOME_BTN:\n\t\tandroid_map_key(BTN_MODE);\n\t\tbreak;\n\tcase HID_USAGE_ANDROID_BACK_BTN:\n\t\tandroid_map_key(BTN_SELECT);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic ssize_t firmware_version_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct shield_device *shield_dev;\n\tint ret;\n\n\tshield_dev = hid_get_drvdata(hdev);\n\n\tif (test_bit(SHIELD_FW_VERSION_INITIALIZED, &shield_dev->initialized_flags))\n\t\tret = sysfs_emit(buf, \"0x%04X\\n\", shield_dev->fw_version);\n\telse\n\t\tret = sysfs_emit(buf, NOT_INIT_STR \"\\n\");\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(firmware_version);\n\nstatic ssize_t hardware_version_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct shield_device *shield_dev;\n\tchar board_revision_str[4];\n\tint ret;\n\n\tshield_dev = hid_get_drvdata(hdev);\n\n\tif (test_bit(SHIELD_BOARD_INFO_INITIALIZED, &shield_dev->initialized_flags)) {\n\t\tshield_strrev(board_revision_str, 4, shield_dev->board_info.revision);\n\t\tret = sysfs_emit(buf, \"%s BOARD_REVISION_%s (0x%04X)\\n\",\n\t\t\t\t shield_dev->codename, board_revision_str,\n\t\t\t\t shield_dev->board_info.revision);\n\t} else\n\t\tret = sysfs_emit(buf, NOT_INIT_STR \"\\n\");\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(hardware_version);\n\nstatic ssize_t serial_number_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct shield_device *shield_dev;\n\tint ret;\n\n\tshield_dev = hid_get_drvdata(hdev);\n\n\tif (test_bit(SHIELD_BOARD_INFO_INITIALIZED, &shield_dev->initialized_flags))\n\t\tret = sysfs_emit(buf, \"%s\\n\", shield_dev->board_info.serial_number);\n\telse\n\t\tret = sysfs_emit(buf, NOT_INIT_STR \"\\n\");\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(serial_number);\n\nstatic struct attribute *shield_device_attrs[] = {\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_hardware_version.attr,\n\t&dev_attr_serial_number.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(shield_device);\n\nstatic int shield_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\t\t    u8 *data, int size)\n{\n\tstruct shield_device *dev = hid_get_drvdata(hdev);\n\n\treturn thunderstrike_parse_report(dev, report, data, size);\n}\n\nstatic int shield_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct shield_device *shield_dev = NULL;\n\tstruct thunderstrike *ts;\n\tint ret;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (id->product) {\n\tcase USB_DEVICE_ID_NVIDIA_THUNDERSTRIKE_CONTROLLER:\n\t\tshield_dev = thunderstrike_create(hdev);\n\t\tbreak;\n\t}\n\n\tif (unlikely(!shield_dev)) {\n\t\thid_err(hdev, \"Failed to identify SHIELD device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (IS_ERR(shield_dev)) {\n\t\thid_err(hdev, \"Failed to create SHIELD device\\n\");\n\t\treturn PTR_ERR(shield_dev);\n\t}\n\n\tts = container_of(shield_dev, struct thunderstrike, base);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDINPUT);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to start HID device\\n\");\n\t\tgoto err_ts_create;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to open HID device\\n\");\n\t\tgoto err_stop;\n\t}\n\n\tthunderstrike_device_init_info(shield_dev);\n\n\treturn ret;\n\nerr_stop:\n\thid_hw_stop(hdev);\nerr_ts_create:\n\tpower_supply_unregister(ts->base.battery_dev.psy);\n\tif (ts->haptics_dev)\n\t\tinput_unregister_device(ts->haptics_dev);\n\tled_classdev_unregister(&ts->led_dev);\n\tida_free(&thunderstrike_ida, ts->id);\n\treturn ret;\n}\n\nstatic void shield_remove(struct hid_device *hdev)\n{\n\tstruct shield_device *dev = hid_get_drvdata(hdev);\n\tstruct thunderstrike *ts;\n\n\tts = container_of(dev, struct thunderstrike, base);\n\n\thid_hw_close(hdev);\n\tpower_supply_unregister(dev->battery_dev.psy);\n\tif (ts->haptics_dev)\n\t\tinput_unregister_device(ts->haptics_dev);\n\tled_classdev_unregister(&ts->led_dev);\n\tida_free(&thunderstrike_ida, ts->id);\n\tdel_timer_sync(&ts->psy_stats_timer);\n\tcancel_work_sync(&ts->hostcmd_req_work);\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id shield_devices[] = {\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NVIDIA,\n\t\t\t       USB_DEVICE_ID_NVIDIA_THUNDERSTRIKE_CONTROLLER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NVIDIA,\n\t\t\t USB_DEVICE_ID_NVIDIA_THUNDERSTRIKE_CONTROLLER) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, shield_devices);\n\nstatic struct hid_driver shield_driver = {\n\t.name          = \"shield\",\n\t.id_table      = shield_devices,\n\t.input_mapping = android_input_mapping,\n\t.probe         = shield_probe,\n\t.remove        = shield_remove,\n\t.raw_event     = shield_raw_event,\n\t.driver = {\n\t\t.dev_groups = shield_device_groups,\n\t},\n};\nmodule_hid_driver(shield_driver);\n\nMODULE_AUTHOR(\"Rahul Rameshbabu <rrameshbabu@nvidia.com>\");\nMODULE_DESCRIPTION(\"HID Driver for NVIDIA SHIELD peripherals.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}