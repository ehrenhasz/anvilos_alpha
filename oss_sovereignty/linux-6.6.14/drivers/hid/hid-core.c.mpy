{
  "module_name": "hid-core.c",
  "hash_id": "8b835064431767e3b4d34f1c9a377178298705a6d610ecb8ad01d1e641d3dfe0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-core.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/input.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n#include <linux/semaphore.h>\n\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/hid-debug.h>\n#include <linux/hidraw.h>\n\n#include \"hid-ids.h\"\n\n \n\n#define DRIVER_DESC \"HID core driver\"\n\nstatic int hid_ignore_special_drivers = 0;\nmodule_param_named(ignore_special_drivers, hid_ignore_special_drivers, int, 0600);\nMODULE_PARM_DESC(ignore_special_drivers, \"Ignore any special drivers and handle all devices by generic driver\");\n\n \n\nstruct hid_report *hid_register_report(struct hid_device *device,\n\t\t\t\t       enum hid_report_type type, unsigned int id,\n\t\t\t\t       unsigned int application)\n{\n\tstruct hid_report_enum *report_enum = device->report_enum + type;\n\tstruct hid_report *report;\n\n\tif (id >= HID_MAX_IDS)\n\t\treturn NULL;\n\tif (report_enum->report_id_hash[id])\n\t\treturn report_enum->report_id_hash[id];\n\n\treport = kzalloc(sizeof(struct hid_report), GFP_KERNEL);\n\tif (!report)\n\t\treturn NULL;\n\n\tif (id != 0)\n\t\treport_enum->numbered = 1;\n\n\treport->id = id;\n\treport->type = type;\n\treport->size = 0;\n\treport->device = device;\n\treport->application = application;\n\treport_enum->report_id_hash[id] = report;\n\n\tlist_add_tail(&report->list, &report_enum->report_list);\n\tINIT_LIST_HEAD(&report->field_entry_list);\n\n\treturn report;\n}\nEXPORT_SYMBOL_GPL(hid_register_report);\n\n \n\nstatic struct hid_field *hid_register_field(struct hid_report *report, unsigned usages)\n{\n\tstruct hid_field *field;\n\n\tif (report->maxfield == HID_MAX_FIELDS) {\n\t\thid_err(report->device, \"too many fields in report\\n\");\n\t\treturn NULL;\n\t}\n\n\tfield = kzalloc((sizeof(struct hid_field) +\n\t\t\t usages * sizeof(struct hid_usage) +\n\t\t\t 3 * usages * sizeof(unsigned int)), GFP_KERNEL);\n\tif (!field)\n\t\treturn NULL;\n\n\tfield->index = report->maxfield++;\n\treport->field[field->index] = field;\n\tfield->usage = (struct hid_usage *)(field + 1);\n\tfield->value = (s32 *)(field->usage + usages);\n\tfield->new_value = (s32 *)(field->value + usages);\n\tfield->usages_priorities = (s32 *)(field->new_value + usages);\n\tfield->report = report;\n\n\treturn field;\n}\n\n \n\nstatic int open_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_collection *collection;\n\tunsigned usage;\n\tint collection_index;\n\n\tusage = parser->local.usage[0];\n\n\tif (parser->collection_stack_ptr == parser->collection_stack_size) {\n\t\tunsigned int *collection_stack;\n\t\tunsigned int new_size = parser->collection_stack_size +\n\t\t\t\t\tHID_COLLECTION_STACK_SIZE;\n\n\t\tcollection_stack = krealloc(parser->collection_stack,\n\t\t\t\t\t    new_size * sizeof(unsigned int),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!collection_stack)\n\t\t\treturn -ENOMEM;\n\n\t\tparser->collection_stack = collection_stack;\n\t\tparser->collection_stack_size = new_size;\n\t}\n\n\tif (parser->device->maxcollection == parser->device->collection_size) {\n\t\tcollection = kmalloc(\n\t\t\t\tarray3_size(sizeof(struct hid_collection),\n\t\t\t\t\t    parser->device->collection_size,\n\t\t\t\t\t    2),\n\t\t\t\tGFP_KERNEL);\n\t\tif (collection == NULL) {\n\t\t\thid_err(parser->device, \"failed to reallocate collection array\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(collection, parser->device->collection,\n\t\t\tsizeof(struct hid_collection) *\n\t\t\tparser->device->collection_size);\n\t\tmemset(collection + parser->device->collection_size, 0,\n\t\t\tsizeof(struct hid_collection) *\n\t\t\tparser->device->collection_size);\n\t\tkfree(parser->device->collection);\n\t\tparser->device->collection = collection;\n\t\tparser->device->collection_size *= 2;\n\t}\n\n\tparser->collection_stack[parser->collection_stack_ptr++] =\n\t\tparser->device->maxcollection;\n\n\tcollection_index = parser->device->maxcollection++;\n\tcollection = parser->device->collection + collection_index;\n\tcollection->type = type;\n\tcollection->usage = usage;\n\tcollection->level = parser->collection_stack_ptr - 1;\n\tcollection->parent_idx = (collection->level == 0) ? -1 :\n\t\tparser->collection_stack[collection->level - 1];\n\n\tif (type == HID_COLLECTION_APPLICATION)\n\t\tparser->device->maxapplication++;\n\n\treturn 0;\n}\n\n \n\nstatic int close_collection(struct hid_parser *parser)\n{\n\tif (!parser->collection_stack_ptr) {\n\t\thid_err(parser->device, \"collection stack underflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\tparser->collection_stack_ptr--;\n\treturn 0;\n}\n\n \n\nstatic unsigned hid_lookup_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_collection *collection = parser->device->collection;\n\tint n;\n\n\tfor (n = parser->collection_stack_ptr - 1; n >= 0; n--) {\n\t\tunsigned index = parser->collection_stack[n];\n\t\tif (collection[index].type == type)\n\t\t\treturn collection[index].usage;\n\t}\n\treturn 0;  \n}\n\n \n\nstatic void complete_usage(struct hid_parser *parser, unsigned int index)\n{\n\tparser->local.usage[index] &= 0xFFFF;\n\tparser->local.usage[index] |=\n\t\t(parser->global.usage_page & 0xFFFF) << 16;\n}\n\n \n\nstatic int hid_add_usage(struct hid_parser *parser, unsigned usage, u8 size)\n{\n\tif (parser->local.usage_index >= HID_MAX_USAGES) {\n\t\thid_err(parser->device, \"usage index exceeded\\n\");\n\t\treturn -1;\n\t}\n\tparser->local.usage[parser->local.usage_index] = usage;\n\n\t \n\tif (size <= 2)\n\t\tcomplete_usage(parser, parser->local.usage_index);\n\n\tparser->local.usage_size[parser->local.usage_index] = size;\n\tparser->local.collection_index[parser->local.usage_index] =\n\t\tparser->collection_stack_ptr ?\n\t\tparser->collection_stack[parser->collection_stack_ptr - 1] : 0;\n\tparser->local.usage_index++;\n\treturn 0;\n}\n\n \n\nstatic int hid_add_field(struct hid_parser *parser, unsigned report_type, unsigned flags)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tunsigned int max_buffer_size = HID_MAX_BUFFER_SIZE;\n\tunsigned int usages;\n\tunsigned int offset;\n\tunsigned int i;\n\tunsigned int application;\n\n\tapplication = hid_lookup_collection(parser, HID_COLLECTION_APPLICATION);\n\n\treport = hid_register_report(parser->device, report_type,\n\t\t\t\t     parser->global.report_id, application);\n\tif (!report) {\n\t\thid_err(parser->device, \"hid_register_report failed\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif ((parser->global.logical_minimum < 0 &&\n\t\tparser->global.logical_maximum <\n\t\tparser->global.logical_minimum) ||\n\t\t(parser->global.logical_minimum >= 0 &&\n\t\t(__u32)parser->global.logical_maximum <\n\t\t(__u32)parser->global.logical_minimum)) {\n\t\tdbg_hid(\"logical range invalid 0x%x 0x%x\\n\",\n\t\t\tparser->global.logical_minimum,\n\t\t\tparser->global.logical_maximum);\n\t\treturn -1;\n\t}\n\n\toffset = report->size;\n\treport->size += parser->global.report_size * parser->global.report_count;\n\n\tif (parser->device->ll_driver->max_buffer_size)\n\t\tmax_buffer_size = parser->device->ll_driver->max_buffer_size;\n\n\t \n\tif (report->size > (max_buffer_size - 1) << 3) {\n\t\thid_err(parser->device, \"report is too long\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!parser->local.usage_index)  \n\t\treturn 0;\n\n\tusages = max_t(unsigned, parser->local.usage_index,\n\t\t\t\t parser->global.report_count);\n\n\tfield = hid_register_field(report, usages);\n\tif (!field)\n\t\treturn 0;\n\n\tfield->physical = hid_lookup_collection(parser, HID_COLLECTION_PHYSICAL);\n\tfield->logical = hid_lookup_collection(parser, HID_COLLECTION_LOGICAL);\n\tfield->application = application;\n\n\tfor (i = 0; i < usages; i++) {\n\t\tunsigned j = i;\n\t\t \n\t\tif (i >= parser->local.usage_index)\n\t\t\tj = parser->local.usage_index - 1;\n\t\tfield->usage[i].hid = parser->local.usage[j];\n\t\tfield->usage[i].collection_index =\n\t\t\tparser->local.collection_index[j];\n\t\tfield->usage[i].usage_index = i;\n\t\tfield->usage[i].resolution_multiplier = 1;\n\t}\n\n\tfield->maxusage = usages;\n\tfield->flags = flags;\n\tfield->report_offset = offset;\n\tfield->report_type = report_type;\n\tfield->report_size = parser->global.report_size;\n\tfield->report_count = parser->global.report_count;\n\tfield->logical_minimum = parser->global.logical_minimum;\n\tfield->logical_maximum = parser->global.logical_maximum;\n\tfield->physical_minimum = parser->global.physical_minimum;\n\tfield->physical_maximum = parser->global.physical_maximum;\n\tfield->unit_exponent = parser->global.unit_exponent;\n\tfield->unit = parser->global.unit;\n\n\treturn 0;\n}\n\n \n\nstatic u32 item_udata(struct hid_item *item)\n{\n\tswitch (item->size) {\n\tcase 1: return item->data.u8;\n\tcase 2: return item->data.u16;\n\tcase 4: return item->data.u32;\n\t}\n\treturn 0;\n}\n\nstatic s32 item_sdata(struct hid_item *item)\n{\n\tswitch (item->size) {\n\tcase 1: return item->data.s8;\n\tcase 2: return item->data.s16;\n\tcase 4: return item->data.s32;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int hid_parser_global(struct hid_parser *parser, struct hid_item *item)\n{\n\t__s32 raw_value;\n\tswitch (item->tag) {\n\tcase HID_GLOBAL_ITEM_TAG_PUSH:\n\n\t\tif (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {\n\t\t\thid_err(parser->device, \"global environment stack overflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(parser->global_stack + parser->global_stack_ptr++,\n\t\t\t&parser->global, sizeof(struct hid_global));\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_POP:\n\n\t\tif (!parser->global_stack_ptr) {\n\t\t\thid_err(parser->device, \"global environment stack underflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(&parser->global, parser->global_stack +\n\t\t\t--parser->global_stack_ptr, sizeof(struct hid_global));\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_USAGE_PAGE:\n\t\tparser->global.usage_page = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM:\n\t\tparser->global.logical_minimum = item_sdata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM:\n\t\tif (parser->global.logical_minimum < 0)\n\t\t\tparser->global.logical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.logical_maximum = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM:\n\t\tparser->global.physical_minimum = item_sdata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM:\n\t\tif (parser->global.physical_minimum < 0)\n\t\t\tparser->global.physical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.physical_maximum = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:\n\t\t \n\t\traw_value = item_sdata(item);\n\t\tif (!(raw_value & 0xfffffff0))\n\t\t\tparser->global.unit_exponent = hid_snto32(raw_value, 4);\n\t\telse\n\t\t\tparser->global.unit_exponent = raw_value;\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_UNIT:\n\t\tparser->global.unit = item_udata(item);\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_SIZE:\n\t\tparser->global.report_size = item_udata(item);\n\t\tif (parser->global.report_size > 256) {\n\t\t\thid_err(parser->device, \"invalid report_size %d\\n\",\n\t\t\t\t\tparser->global.report_size);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_COUNT:\n\t\tparser->global.report_count = item_udata(item);\n\t\tif (parser->global.report_count > HID_MAX_USAGES) {\n\t\t\thid_err(parser->device, \"invalid report_count %d\\n\",\n\t\t\t\t\tparser->global.report_count);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_ID:\n\t\tparser->global.report_id = item_udata(item);\n\t\tif (parser->global.report_id == 0 ||\n\t\t    parser->global.report_id >= HID_MAX_IDS) {\n\t\t\thid_err(parser->device, \"report_id %u is invalid\\n\",\n\t\t\t\tparser->global.report_id);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\thid_err(parser->device, \"unknown global tag 0x%x\\n\", item->tag);\n\t\treturn -1;\n\t}\n}\n\n \n\nstatic int hid_parser_local(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tunsigned n;\n\t__u32 count;\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_LOCAL_ITEM_TAG_DELIMITER:\n\n\t\tif (data) {\n\t\t\t \n\t\t\tif (parser->local.delimiter_depth != 0) {\n\t\t\t\thid_err(parser->device, \"nested delimiters\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tparser->local.delimiter_depth++;\n\t\t\tparser->local.delimiter_branch++;\n\t\t} else {\n\t\t\tif (parser->local.delimiter_depth < 1) {\n\t\t\t\thid_err(parser->device, \"bogus close delimiter\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tparser->local.delimiter_depth--;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn hid_add_usage(parser, data, item->size);\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE_MINIMUM:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tparser->local.usage_minimum = data;\n\t\treturn 0;\n\n\tcase HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM:\n\n\t\tif (parser->local.delimiter_branch > 1) {\n\t\t\tdbg_hid(\"alternative usage ignored\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcount = data - parser->local.usage_minimum;\n\t\tif (count + parser->local.usage_index >= HID_MAX_USAGES) {\n\t\t\t \n\t\t\tif (dev_name(&parser->device->dev))\n\t\t\t\thid_warn(parser->device,\n\t\t\t\t\t \"ignoring exceeding usage max\\n\");\n\t\t\tdata = HID_MAX_USAGES - parser->local.usage_index +\n\t\t\t\tparser->local.usage_minimum - 1;\n\t\t\tif (data <= 0) {\n\t\t\t\thid_err(parser->device,\n\t\t\t\t\t\"no more usage index available\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (n = parser->local.usage_minimum; n <= data; n++)\n\t\t\tif (hid_add_usage(parser, n, item->size)) {\n\t\t\t\tdbg_hid(\"hid_add_usage failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\treturn 0;\n\n\tdefault:\n\n\t\tdbg_hid(\"unknown local item tag 0x%x\\n\", item->tag);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n \n\nstatic void hid_concatenate_last_usage_page(struct hid_parser *parser)\n{\n\tint i;\n\tunsigned int usage_page;\n\tunsigned int current_page;\n\n\tif (!parser->local.usage_index)\n\t\treturn;\n\n\tusage_page = parser->global.usage_page;\n\n\t \n\tfor (i = parser->local.usage_index - 1; i >= 0; i--) {\n\t\tif (parser->local.usage_size[i] > 2)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tcurrent_page = parser->local.usage[i] >> 16;\n\t\tif (current_page == usage_page)\n\t\t\tbreak;\n\n\t\tcomplete_usage(parser, i);\n\t}\n}\n\n \n\nstatic int hid_parser_main(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tint ret;\n\n\thid_concatenate_last_usage_page(parser);\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:\n\t\tret = open_collection(parser, data & 0xff);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_END_COLLECTION:\n\t\tret = close_collection(parser);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_INPUT:\n\t\tret = hid_add_field(parser, HID_INPUT_REPORT, data);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_OUTPUT:\n\t\tret = hid_add_field(parser, HID_OUTPUT_REPORT, data);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_FEATURE:\n\t\tret = hid_add_field(parser, HID_FEATURE_REPORT, data);\n\t\tbreak;\n\tdefault:\n\t\thid_warn(parser->device, \"unknown main item tag 0x%x\\n\", item->tag);\n\t\tret = 0;\n\t}\n\n\tmemset(&parser->local, 0, sizeof(parser->local));\t \n\n\treturn ret;\n}\n\n \n\nstatic int hid_parser_reserved(struct hid_parser *parser, struct hid_item *item)\n{\n\tdbg_hid(\"reserved item type, tag 0x%x\\n\", item->tag);\n\treturn 0;\n}\n\n \n\nstatic void hid_free_report(struct hid_report *report)\n{\n\tunsigned n;\n\n\tkfree(report->field_entries);\n\n\tfor (n = 0; n < report->maxfield; n++)\n\t\tkfree(report->field[n]);\n\tkfree(report);\n}\n\n \nstatic void hid_close_report(struct hid_device *device)\n{\n\tunsigned i, j;\n\n\tfor (i = 0; i < HID_REPORT_TYPES; i++) {\n\t\tstruct hid_report_enum *report_enum = device->report_enum + i;\n\n\t\tfor (j = 0; j < HID_MAX_IDS; j++) {\n\t\t\tstruct hid_report *report = report_enum->report_id_hash[j];\n\t\t\tif (report)\n\t\t\t\thid_free_report(report);\n\t\t}\n\t\tmemset(report_enum, 0, sizeof(*report_enum));\n\t\tINIT_LIST_HEAD(&report_enum->report_list);\n\t}\n\n\tkfree(device->rdesc);\n\tdevice->rdesc = NULL;\n\tdevice->rsize = 0;\n\n\tkfree(device->collection);\n\tdevice->collection = NULL;\n\tdevice->collection_size = 0;\n\tdevice->maxcollection = 0;\n\tdevice->maxapplication = 0;\n\n\tdevice->status &= ~HID_STAT_PARSED;\n}\n\n \n\nvoid hiddev_free(struct kref *ref)\n{\n\tstruct hid_device *hid = container_of(ref, struct hid_device, ref);\n\n\thid_close_report(hid);\n\tkfree(hid->dev_rdesc);\n\tkfree(hid);\n}\n\nstatic void hid_device_release(struct device *dev)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\n\tkref_put(&hid->ref, hiddev_free);\n}\n\n \n\nstatic u8 *fetch_item(__u8 *start, __u8 *end, struct hid_item *item)\n{\n\tu8 b;\n\n\tif ((end - start) <= 0)\n\t\treturn NULL;\n\n\tb = *start++;\n\n\titem->type = (b >> 2) & 3;\n\titem->tag  = (b >> 4) & 15;\n\n\tif (item->tag == HID_ITEM_TAG_LONG) {\n\n\t\titem->format = HID_ITEM_FORMAT_LONG;\n\n\t\tif ((end - start) < 2)\n\t\t\treturn NULL;\n\n\t\titem->size = *start++;\n\t\titem->tag  = *start++;\n\n\t\tif ((end - start) < item->size)\n\t\t\treturn NULL;\n\n\t\titem->data.longdata = start;\n\t\tstart += item->size;\n\t\treturn start;\n\t}\n\n\titem->format = HID_ITEM_FORMAT_SHORT;\n\titem->size = b & 3;\n\n\tswitch (item->size) {\n\tcase 0:\n\t\treturn start;\n\n\tcase 1:\n\t\tif ((end - start) < 1)\n\t\t\treturn NULL;\n\t\titem->data.u8 = *start++;\n\t\treturn start;\n\n\tcase 2:\n\t\tif ((end - start) < 2)\n\t\t\treturn NULL;\n\t\titem->data.u16 = get_unaligned_le16(start);\n\t\tstart = (__u8 *)((__le16 *)start + 1);\n\t\treturn start;\n\n\tcase 3:\n\t\titem->size++;\n\t\tif ((end - start) < 4)\n\t\t\treturn NULL;\n\t\titem->data.u32 = get_unaligned_le32(start);\n\t\tstart = (__u8 *)((__le32 *)start + 1);\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hid_scan_input_usage(struct hid_parser *parser, u32 usage)\n{\n\tstruct hid_device *hid = parser->device;\n\n\tif (usage == HID_DG_CONTACTID)\n\t\thid->group = HID_GROUP_MULTITOUCH;\n}\n\nstatic void hid_scan_feature_usage(struct hid_parser *parser, u32 usage)\n{\n\tif (usage == 0xff0000c5 && parser->global.report_count == 256 &&\n\t    parser->global.report_size == 8)\n\t\tparser->scan_flags |= HID_SCAN_FLAG_MT_WIN_8;\n\n\tif (usage == 0xff0000c6 && parser->global.report_count == 1 &&\n\t    parser->global.report_size == 8)\n\t\tparser->scan_flags |= HID_SCAN_FLAG_MT_WIN_8;\n}\n\nstatic void hid_scan_collection(struct hid_parser *parser, unsigned type)\n{\n\tstruct hid_device *hid = parser->device;\n\tint i;\n\n\tif (((parser->global.usage_page << 16) == HID_UP_SENSOR) &&\n\t    (type == HID_COLLECTION_PHYSICAL ||\n\t     type == HID_COLLECTION_APPLICATION))\n\t\thid->group = HID_GROUP_SENSOR_HUB;\n\n\tif (hid->vendor == USB_VENDOR_ID_MICROSOFT &&\n\t    hid->product == USB_DEVICE_ID_MS_POWER_COVER &&\n\t    hid->group == HID_GROUP_MULTITOUCH)\n\t\thid->group = HID_GROUP_GENERIC;\n\n\tif ((parser->global.usage_page << 16) == HID_UP_GENDESK)\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\tif (parser->local.usage[i] == HID_GD_POINTER)\n\t\t\t\tparser->scan_flags |= HID_SCAN_FLAG_GD_POINTER;\n\n\tif ((parser->global.usage_page << 16) >= HID_UP_MSVENDOR)\n\t\tparser->scan_flags |= HID_SCAN_FLAG_VENDOR_SPECIFIC;\n\n\tif ((parser->global.usage_page << 16) == HID_UP_GOOGLEVENDOR)\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\tif (parser->local.usage[i] ==\n\t\t\t\t\t(HID_UP_GOOGLEVENDOR | 0x0001))\n\t\t\t\tparser->device->group =\n\t\t\t\t\tHID_GROUP_VIVALDI;\n}\n\nstatic int hid_scan_main(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 data;\n\tint i;\n\n\thid_concatenate_last_usage_page(parser);\n\n\tdata = item_udata(item);\n\n\tswitch (item->tag) {\n\tcase HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:\n\t\thid_scan_collection(parser, data & 0xff);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_END_COLLECTION:\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_INPUT:\n\t\t \n\t\tif (data & HID_MAIN_ITEM_CONSTANT)\n\t\t\tbreak;\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\thid_scan_input_usage(parser, parser->local.usage[i]);\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_OUTPUT:\n\t\tbreak;\n\tcase HID_MAIN_ITEM_TAG_FEATURE:\n\t\tfor (i = 0; i < parser->local.usage_index; i++)\n\t\t\thid_scan_feature_usage(parser, parser->local.usage[i]);\n\t\tbreak;\n\t}\n\n\t \n\tmemset(&parser->local, 0, sizeof(parser->local));\n\n\treturn 0;\n}\n\n \nstatic int hid_scan_report(struct hid_device *hid)\n{\n\tstruct hid_parser *parser;\n\tstruct hid_item item;\n\t__u8 *start = hid->dev_rdesc;\n\t__u8 *end = start + hid->dev_rsize;\n\tstatic int (*dispatch_type[])(struct hid_parser *parser,\n\t\t\t\t      struct hid_item *item) = {\n\t\thid_scan_main,\n\t\thid_parser_global,\n\t\thid_parser_local,\n\t\thid_parser_reserved\n\t};\n\n\tparser = vzalloc(sizeof(struct hid_parser));\n\tif (!parser)\n\t\treturn -ENOMEM;\n\n\tparser->device = hid;\n\thid->group = HID_GROUP_GENERIC;\n\n\t \n\twhile ((start = fetch_item(start, end, &item)) != NULL)\n\t\tdispatch_type[item.type](parser, &item);\n\n\t \n\tif ((parser->scan_flags & HID_SCAN_FLAG_MT_WIN_8) &&\n\t    (hid->group == HID_GROUP_MULTITOUCH))\n\t\thid->group = HID_GROUP_MULTITOUCH_WIN_8;\n\n\t \n\tswitch (hid->vendor) {\n\tcase USB_VENDOR_ID_WACOM:\n\t\thid->group = HID_GROUP_WACOM;\n\t\tbreak;\n\tcase USB_VENDOR_ID_SYNAPTICS:\n\t\tif (hid->group == HID_GROUP_GENERIC)\n\t\t\tif ((parser->scan_flags & HID_SCAN_FLAG_VENDOR_SPECIFIC)\n\t\t\t    && (parser->scan_flags & HID_SCAN_FLAG_GD_POINTER))\n\t\t\t\t \n\t\t\t\thid->group = HID_GROUP_RMI;\n\t\tbreak;\n\t}\n\n\tkfree(parser->collection_stack);\n\tvfree(parser);\n\treturn 0;\n}\n\n \nint hid_parse_report(struct hid_device *hid, __u8 *start, unsigned size)\n{\n\thid->dev_rdesc = kmemdup(start, size, GFP_KERNEL);\n\tif (!hid->dev_rdesc)\n\t\treturn -ENOMEM;\n\thid->dev_rsize = size;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_parse_report);\n\nstatic const char * const hid_report_names[] = {\n\t\"HID_INPUT_REPORT\",\n\t\"HID_OUTPUT_REPORT\",\n\t\"HID_FEATURE_REPORT\",\n};\n \nstruct hid_report *hid_validate_values(struct hid_device *hid,\n\t\t\t\t       enum hid_report_type type, unsigned int id,\n\t\t\t\t       unsigned int field_index,\n\t\t\t\t       unsigned int report_counts)\n{\n\tstruct hid_report *report;\n\n\tif (type > HID_FEATURE_REPORT) {\n\t\thid_err(hid, \"invalid HID report type %u\\n\", type);\n\t\treturn NULL;\n\t}\n\n\tif (id >= HID_MAX_IDS) {\n\t\thid_err(hid, \"invalid HID report id %u\\n\", id);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (id == 0) {\n\t\t \n\t\treport = list_first_entry_or_null(\n\t\t\t\t&hid->report_enum[type].report_list,\n\t\t\t\tstruct hid_report, list);\n\t} else {\n\t\treport = hid->report_enum[type].report_id_hash[id];\n\t}\n\tif (!report) {\n\t\thid_err(hid, \"missing %s %u\\n\", hid_report_names[type], id);\n\t\treturn NULL;\n\t}\n\tif (report->maxfield <= field_index) {\n\t\thid_err(hid, \"not enough fields in %s %u\\n\",\n\t\t\thid_report_names[type], id);\n\t\treturn NULL;\n\t}\n\tif (report->field[field_index]->report_count < report_counts) {\n\t\thid_err(hid, \"not enough values in %s %u field %u\\n\",\n\t\t\thid_report_names[type], id, field_index);\n\t\treturn NULL;\n\t}\n\treturn report;\n}\nEXPORT_SYMBOL_GPL(hid_validate_values);\n\nstatic int hid_calculate_multiplier(struct hid_device *hid,\n\t\t\t\t     struct hid_field *multiplier)\n{\n\tint m;\n\t__s32 v = *multiplier->value;\n\t__s32 lmin = multiplier->logical_minimum;\n\t__s32 lmax = multiplier->logical_maximum;\n\t__s32 pmin = multiplier->physical_minimum;\n\t__s32 pmax = multiplier->physical_maximum;\n\n\t \n\tif (lmax - lmin == 0)\n\t\treturn 1;\n\t \n\tm = ((v - lmin)/(lmax - lmin) * (pmax - pmin) + pmin);\n\tif (unlikely(multiplier->unit_exponent != 0)) {\n\t\thid_warn(hid,\n\t\t\t \"unsupported Resolution Multiplier unit exponent %d\\n\",\n\t\t\t multiplier->unit_exponent);\n\t}\n\n\t \n\tif (unlikely(m == 0 || m > 255 || m < -255)) {\n\t\thid_warn(hid, \"unsupported Resolution Multiplier %d\\n\", m);\n\t\tm = 1;\n\t}\n\n\treturn m;\n}\n\nstatic void hid_apply_multiplier_to_field(struct hid_device *hid,\n\t\t\t\t\t  struct hid_field *field,\n\t\t\t\t\t  struct hid_collection *multiplier_collection,\n\t\t\t\t\t  int effective_multiplier)\n{\n\tstruct hid_collection *collection;\n\tstruct hid_usage *usage;\n\tint i;\n\n\t \n\tfor (i = 0; i < field->maxusage; i++) {\n\t\tusage = &field->usage[i];\n\n\t\tcollection = &hid->collection[usage->collection_index];\n\t\twhile (collection->parent_idx != -1 &&\n\t\t       collection != multiplier_collection)\n\t\t\tcollection = &hid->collection[collection->parent_idx];\n\n\t\tif (collection->parent_idx != -1 ||\n\t\t    multiplier_collection == NULL)\n\t\t\tusage->resolution_multiplier = effective_multiplier;\n\n\t}\n}\n\nstatic void hid_apply_multiplier(struct hid_device *hid,\n\t\t\t\t struct hid_field *multiplier)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct hid_field *field;\n\tstruct hid_collection *multiplier_collection;\n\tint effective_multiplier;\n\tint i;\n\n\t \n\tmultiplier_collection = &hid->collection[multiplier->usage->collection_index];\n\twhile (multiplier_collection->parent_idx != -1 &&\n\t       multiplier_collection->type != HID_COLLECTION_LOGICAL)\n\t\tmultiplier_collection = &hid->collection[multiplier_collection->parent_idx];\n\n\teffective_multiplier = hid_calculate_multiplier(hid, multiplier);\n\n\trep_enum = &hid->report_enum[HID_INPUT_REPORT];\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tfor (i = 0; i < rep->maxfield; i++) {\n\t\t\tfield = rep->field[i];\n\t\t\thid_apply_multiplier_to_field(hid, field,\n\t\t\t\t\t\t      multiplier_collection,\n\t\t\t\t\t\t      effective_multiplier);\n\t\t}\n\t}\n}\n\n \nvoid hid_setup_resolution_multiplier(struct hid_device *hid)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct hid_usage *usage;\n\tint i, j;\n\n\trep_enum = &hid->report_enum[HID_FEATURE_REPORT];\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tfor (i = 0; i < rep->maxfield; i++) {\n\t\t\t \n\t\t\tif (rep->field[i]->report_count < 1)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < rep->field[i]->maxusage; j++) {\n\t\t\t\tusage = &rep->field[i]->usage[j];\n\t\t\t\tif (usage->hid == HID_GD_RESOLUTION_MULTIPLIER)\n\t\t\t\t\thid_apply_multiplier(hid,\n\t\t\t\t\t\t\t     rep->field[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(hid_setup_resolution_multiplier);\n\n \nint hid_open_report(struct hid_device *device)\n{\n\tstruct hid_parser *parser;\n\tstruct hid_item item;\n\tunsigned int size;\n\t__u8 *start;\n\t__u8 *buf;\n\t__u8 *end;\n\t__u8 *next;\n\tint ret;\n\tint i;\n\tstatic int (*dispatch_type[])(struct hid_parser *parser,\n\t\t\t\t      struct hid_item *item) = {\n\t\thid_parser_main,\n\t\thid_parser_global,\n\t\thid_parser_local,\n\t\thid_parser_reserved\n\t};\n\n\tif (WARN_ON(device->status & HID_STAT_PARSED))\n\t\treturn -EBUSY;\n\n\tstart = device->dev_rdesc;\n\tif (WARN_ON(!start))\n\t\treturn -ENODEV;\n\tsize = device->dev_rsize;\n\n\t \n\tbuf = call_hid_bpf_rdesc_fixup(device, start, &size);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (device->driver->report_fixup)\n\t\tstart = device->driver->report_fixup(device, buf, &size);\n\telse\n\t\tstart = buf;\n\n\tstart = kmemdup(start, size, GFP_KERNEL);\n\tkfree(buf);\n\tif (start == NULL)\n\t\treturn -ENOMEM;\n\n\tdevice->rdesc = start;\n\tdevice->rsize = size;\n\n\tparser = vzalloc(sizeof(struct hid_parser));\n\tif (!parser) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_err;\n\t}\n\n\tparser->device = device;\n\n\tend = start + size;\n\n\tdevice->collection = kcalloc(HID_DEFAULT_NUM_COLLECTIONS,\n\t\t\t\t     sizeof(struct hid_collection), GFP_KERNEL);\n\tif (!device->collection) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdevice->collection_size = HID_DEFAULT_NUM_COLLECTIONS;\n\tfor (i = 0; i < HID_DEFAULT_NUM_COLLECTIONS; i++)\n\t\tdevice->collection[i].parent_idx = -1;\n\n\tret = -EINVAL;\n\twhile ((next = fetch_item(start, end, &item)) != NULL) {\n\t\tstart = next;\n\n\t\tif (item.format != HID_ITEM_FORMAT_SHORT) {\n\t\t\thid_err(device, \"unexpected long global item\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dispatch_type[item.type](parser, &item)) {\n\t\t\thid_err(device, \"item %u %u %u %u parsing failed\\n\",\n\t\t\t\titem.format, (unsigned)item.size,\n\t\t\t\t(unsigned)item.type, (unsigned)item.tag);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (start == end) {\n\t\t\tif (parser->collection_stack_ptr) {\n\t\t\t\thid_err(device, \"unbalanced collection at end of report description\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (parser->local.delimiter_depth) {\n\t\t\t\thid_err(device, \"unbalanced delimiter at end of report description\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t \n\t\t\thid_setup_resolution_multiplier(device);\n\n\t\t\tkfree(parser->collection_stack);\n\t\t\tvfree(parser);\n\t\t\tdevice->status |= HID_STAT_PARSED;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\thid_err(device, \"item fetching failed at offset %u/%u\\n\",\n\t\tsize - (unsigned int)(end - start), size);\nerr:\n\tkfree(parser->collection_stack);\nalloc_err:\n\tvfree(parser);\n\thid_close_report(device);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_open_report);\n\n \n\nstatic s32 snto32(__u32 value, unsigned n)\n{\n\tif (!value || !n)\n\t\treturn 0;\n\n\tif (n > 32)\n\t\tn = 32;\n\n\tswitch (n) {\n\tcase 8:  return ((__s8)value);\n\tcase 16: return ((__s16)value);\n\tcase 32: return ((__s32)value);\n\t}\n\treturn value & (1 << (n - 1)) ? value | (~0U << n) : value;\n}\n\ns32 hid_snto32(__u32 value, unsigned n)\n{\n\treturn snto32(value, n);\n}\nEXPORT_SYMBOL_GPL(hid_snto32);\n\n \n\nstatic u32 s32ton(__s32 value, unsigned n)\n{\n\ts32 a = value >> (n - 1);\n\tif (a && a != -1)\n\t\treturn value < 0 ? 1 << (n - 1) : (1 << (n - 1)) - 1;\n\treturn value & ((1 << n) - 1);\n}\n\n \n\nstatic u32 __extract(u8 *report, unsigned offset, int n)\n{\n\tunsigned int idx = offset / 8;\n\tunsigned int bit_nr = 0;\n\tunsigned int bit_shift = offset % 8;\n\tint bits_to_copy = 8 - bit_shift;\n\tu32 value = 0;\n\tu32 mask = n < 32 ? (1U << n) - 1 : ~0U;\n\n\twhile (n > 0) {\n\t\tvalue |= ((u32)report[idx] >> bit_shift) << bit_nr;\n\t\tn -= bits_to_copy;\n\t\tbit_nr += bits_to_copy;\n\t\tbits_to_copy = 8;\n\t\tbit_shift = 0;\n\t\tidx++;\n\t}\n\n\treturn value & mask;\n}\n\nu32 hid_field_extract(const struct hid_device *hid, u8 *report,\n\t\t\tunsigned offset, unsigned n)\n{\n\tif (n > 32) {\n\t\thid_warn_once(hid, \"%s() called with n (%d) > 32! (%s)\\n\",\n\t\t\t      __func__, n, current->comm);\n\t\tn = 32;\n\t}\n\n\treturn __extract(report, offset, n);\n}\nEXPORT_SYMBOL_GPL(hid_field_extract);\n\n \n\nstatic void __implement(u8 *report, unsigned offset, int n, u32 value)\n{\n\tunsigned int idx = offset / 8;\n\tunsigned int bit_shift = offset % 8;\n\tint bits_to_set = 8 - bit_shift;\n\n\twhile (n - bits_to_set >= 0) {\n\t\treport[idx] &= ~(0xff << bit_shift);\n\t\treport[idx] |= value << bit_shift;\n\t\tvalue >>= bits_to_set;\n\t\tn -= bits_to_set;\n\t\tbits_to_set = 8;\n\t\tbit_shift = 0;\n\t\tidx++;\n\t}\n\n\t \n\tif (n) {\n\t\tu8 bit_mask = ((1U << n) - 1);\n\t\treport[idx] &= ~(bit_mask << bit_shift);\n\t\treport[idx] |= value << bit_shift;\n\t}\n}\n\nstatic void implement(const struct hid_device *hid, u8 *report,\n\t\t      unsigned offset, unsigned n, u32 value)\n{\n\tif (unlikely(n > 32)) {\n\t\thid_warn(hid, \"%s() called with n (%d) > 32! (%s)\\n\",\n\t\t\t __func__, n, current->comm);\n\t\tn = 32;\n\t} else if (n < 32) {\n\t\tu32 m = (1U << n) - 1;\n\n\t\tif (unlikely(value > m)) {\n\t\t\thid_warn(hid,\n\t\t\t\t \"%s() called with too large value %d (n: %d)! (%s)\\n\",\n\t\t\t\t __func__, value, n, current->comm);\n\t\t\tWARN_ON(1);\n\t\t\tvalue &= m;\n\t\t}\n\t}\n\n\t__implement(report, offset, n, value);\n}\n\n \n\nstatic int search(__s32 *array, __s32 value, unsigned n)\n{\n\twhile (n--) {\n\t\tif (*array++ == value)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n \nstatic int hid_match_report(struct hid_device *hid, struct hid_report *report)\n{\n\tconst struct hid_report_id *id = hid->driver->report_table;\n\n\tif (!id)  \n\t\treturn 1;\n\n\tfor (; id->report_type != HID_TERMINATOR; id++)\n\t\tif (id->report_type == HID_ANY_ID ||\n\t\t\t\tid->report_type == report->type)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int hid_match_usage(struct hid_device *hid, struct hid_usage *usage)\n{\n\tconst struct hid_usage_id *id = hid->driver->usage_table;\n\n\tif (!id)  \n\t\treturn 1;\n\n\tfor (; id->usage_type != HID_ANY_ID - 1; id++)\n\t\tif ((id->usage_hid == HID_ANY_ID ||\n\t\t\t\tid->usage_hid == usage->hid) &&\n\t\t\t\t(id->usage_type == HID_ANY_ID ||\n\t\t\t\tid->usage_type == usage->type) &&\n\t\t\t\t(id->usage_code == HID_ANY_ID ||\n\t\t\t\t id->usage_code == usage->code))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic void hid_process_event(struct hid_device *hid, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value, int interrupt)\n{\n\tstruct hid_driver *hdrv = hid->driver;\n\tint ret;\n\n\tif (!list_empty(&hid->debug_list))\n\t\thid_dump_input(hid, usage, value);\n\n\tif (hdrv && hdrv->event && hid_match_usage(hid, usage)) {\n\t\tret = hdrv->event(hid, field, usage, value);\n\t\tif (ret != 0) {\n\t\t\tif (ret < 0)\n\t\t\t\thid_err(hid, \"%s's event failed with %d\\n\",\n\t\t\t\t\t\thdrv->name, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (hid->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_hid_event(hid, field, usage, value);\n\tif (hid->claimed & HID_CLAIMED_HIDDEV && interrupt && hid->hiddev_hid_event)\n\t\thid->hiddev_hid_event(hid, field, usage, value);\n}\n\n \nstatic inline int hid_array_value_is_valid(struct hid_field *field,\n\t\t\t\t\t   __s32 value)\n{\n\t__s32 min = field->logical_minimum;\n\n\t \n\treturn value >= min &&\n\t       value <= field->logical_maximum &&\n\t       value - min < field->maxusage;\n}\n\n \nstatic void hid_input_fetch_field(struct hid_device *hid,\n\t\t\t\t  struct hid_field *field,\n\t\t\t\t  __u8 *data)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 *value;\n\n\tvalue = field->new_value;\n\tmemset(value, 0, count * sizeof(__s32));\n\tfield->ignored = false;\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\n\t\t \n\t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t\t    hid_array_value_is_valid(field, value[n]) &&\n\t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1) {\n\t\t\tfield->ignored = true;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \n\nstatic void hid_input_var_field(struct hid_device *hid,\n\t\t\t\tstruct hid_field *field,\n\t\t\t\tint interrupt)\n{\n\tunsigned int count = field->report_count;\n\t__s32 *value = field->new_value;\n\tunsigned int n;\n\n\tfor (n = 0; n < count; n++)\n\t\thid_process_event(hid,\n\t\t\t\t  field,\n\t\t\t\t  &field->usage[n],\n\t\t\t\t  value[n],\n\t\t\t\t  interrupt);\n\n\tmemcpy(field->value, value, count * sizeof(__s32));\n}\n\n \n\nstatic void hid_input_array_field(struct hid_device *hid,\n\t\t\t\t  struct hid_field *field,\n\t\t\t\t  int interrupt)\n{\n\tunsigned int n;\n\tunsigned int count = field->report_count;\n\t__s32 min = field->logical_minimum;\n\t__s32 *value;\n\n\tvalue = field->new_value;\n\n\t \n\tif (field->ignored)\n\t\treturn;\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (hid_array_value_is_valid(field, field->value[n]) &&\n\t\t    search(value, field->value[n], count))\n\t\t\thid_process_event(hid,\n\t\t\t\t\t  field,\n\t\t\t\t\t  &field->usage[field->value[n] - min],\n\t\t\t\t\t  0,\n\t\t\t\t\t  interrupt);\n\n\t\tif (hid_array_value_is_valid(field, value[n]) &&\n\t\t    search(field->value, value[n], count))\n\t\t\thid_process_event(hid,\n\t\t\t\t\t  field,\n\t\t\t\t\t  &field->usage[value[n] - min],\n\t\t\t\t\t  1,\n\t\t\t\t\t  interrupt);\n\t}\n\n\tmemcpy(field->value, value, count * sizeof(__s32));\n}\n\n \nstatic void hid_process_report(struct hid_device *hid,\n\t\t\t       struct hid_report *report,\n\t\t\t       __u8 *data,\n\t\t\t       int interrupt)\n{\n\tunsigned int a;\n\tstruct hid_field_entry *entry;\n\tstruct hid_field *field;\n\n\t \n\tfor (a = 0; a < report->maxfield; a++)\n\t\thid_input_fetch_field(hid, report->field[a], data);\n\n\tif (!list_empty(&report->field_entry_list)) {\n\t\t \n\t\tlist_for_each_entry(entry,\n\t\t\t\t    &report->field_entry_list,\n\t\t\t\t    list) {\n\t\t\tfield = entry->field;\n\n\t\t\tif (field->flags & HID_MAIN_ITEM_VARIABLE)\n\t\t\t\thid_process_event(hid,\n\t\t\t\t\t\t  field,\n\t\t\t\t\t\t  &field->usage[entry->index],\n\t\t\t\t\t\t  field->new_value[entry->index],\n\t\t\t\t\t\t  interrupt);\n\t\t\telse\n\t\t\t\thid_input_array_field(hid, field, interrupt);\n\t\t}\n\n\t\t \n\t\tfor (a = 0; a < report->maxfield; a++) {\n\t\t\tfield = report->field[a];\n\n\t\t\tif (field->flags & HID_MAIN_ITEM_VARIABLE)\n\t\t\t\tmemcpy(field->value, field->new_value,\n\t\t\t\t       field->report_count * sizeof(__s32));\n\t\t}\n\t} else {\n\t\t \n\t\tfor (a = 0; a < report->maxfield; a++) {\n\t\t\tfield = report->field[a];\n\n\t\t\tif (field->flags & HID_MAIN_ITEM_VARIABLE)\n\t\t\t\thid_input_var_field(hid, field, interrupt);\n\t\t\telse\n\t\t\t\thid_input_array_field(hid, field, interrupt);\n\t\t}\n\t}\n}\n\n \nstatic void __hid_insert_field_entry(struct hid_device *hid,\n\t\t\t\t     struct hid_report *report,\n\t\t\t\t     struct hid_field_entry *entry,\n\t\t\t\t     struct hid_field *field,\n\t\t\t\t     unsigned int usage_index)\n{\n\tstruct hid_field_entry *next;\n\n\tentry->field = field;\n\tentry->index = usage_index;\n\tentry->priority = field->usages_priorities[usage_index];\n\n\t \n\tlist_for_each_entry(next,\n\t\t\t    &report->field_entry_list,\n\t\t\t    list) {\n\t\t \n\t\tif (entry->priority > next->priority) {\n\t\t\tlist_add_tail(&entry->list, &next->list);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tlist_add_tail(&entry->list, &report->field_entry_list);\n}\n\nstatic void hid_report_process_ordering(struct hid_device *hid,\n\t\t\t\t\tstruct hid_report *report)\n{\n\tstruct hid_field *field;\n\tstruct hid_field_entry *entries;\n\tunsigned int a, u, usages;\n\tunsigned int count = 0;\n\n\t \n\tfor (a = 0; a < report->maxfield; a++) {\n\t\tfield = report->field[a];\n\n\t\tif (field->flags & HID_MAIN_ITEM_VARIABLE)\n\t\t\tcount += field->report_count;\n\t\telse\n\t\t\tcount++;\n\t}\n\n\t \n\tentries = kcalloc(count, sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn;\n\n\treport->field_entries = entries;\n\n\t \n\tusages = 0;\n\tfor (a = 0; a < report->maxfield; a++) {\n\t\tfield = report->field[a];\n\n\t\tif (field->flags & HID_MAIN_ITEM_VARIABLE) {\n\t\t\tfor (u = 0; u < field->report_count; u++) {\n\t\t\t\t__hid_insert_field_entry(hid, report,\n\t\t\t\t\t\t\t &entries[usages],\n\t\t\t\t\t\t\t field, u);\n\t\t\t\tusages++;\n\t\t\t}\n\t\t} else {\n\t\t\t__hid_insert_field_entry(hid, report, &entries[usages],\n\t\t\t\t\t\t field, 0);\n\t\t\tusages++;\n\t\t}\n\t}\n}\n\nstatic void hid_process_ordering(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tstruct hid_report_enum *report_enum = &hid->report_enum[HID_INPUT_REPORT];\n\n\tlist_for_each_entry(report, &report_enum->report_list, list)\n\t\thid_report_process_ordering(hid, report);\n}\n\n \n\nstatic void hid_output_field(const struct hid_device *hid,\n\t\t\t     struct hid_field *field, __u8 *data)\n{\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\tunsigned n;\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (field->logical_minimum < 0)\t \n\t\t\timplement(hid, data, offset + n * size, size,\n\t\t\t\t  s32ton(field->value[n], size));\n\t\telse\t\t\t\t \n\t\t\timplement(hid, data, offset + n * size, size,\n\t\t\t\t  field->value[n]);\n\t}\n}\n\n \nstatic size_t hid_compute_report_size(struct hid_report *report)\n{\n\tif (report->size)\n\t\treturn ((report->size - 1) >> 3) + 1;\n\n\treturn 0;\n}\n\n \n\nvoid hid_output_report(struct hid_report *report, __u8 *data)\n{\n\tunsigned n;\n\n\tif (report->id > 0)\n\t\t*data++ = report->id;\n\n\tmemset(data, 0, hid_compute_report_size(report));\n\tfor (n = 0; n < report->maxfield; n++)\n\t\thid_output_field(report->device, report->field[n], data);\n}\nEXPORT_SYMBOL_GPL(hid_output_report);\n\n \nu8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)\n{\n\t \n\n\tu32 len = hid_report_len(report) + 7;\n\n\treturn kmalloc(len, flags);\n}\nEXPORT_SYMBOL_GPL(hid_alloc_report_buf);\n\n \n\nint hid_set_field(struct hid_field *field, unsigned offset, __s32 value)\n{\n\tunsigned size;\n\n\tif (!field)\n\t\treturn -1;\n\n\tsize = field->report_size;\n\n\thid_dump_input(field->report->device, field->usage + offset, value);\n\n\tif (offset >= field->report_count) {\n\t\thid_err(field->report->device, \"offset (%d) exceeds report_count (%d)\\n\",\n\t\t\t\toffset, field->report_count);\n\t\treturn -1;\n\t}\n\tif (field->logical_minimum < 0) {\n\t\tif (value != snto32(s32ton(value, size), size)) {\n\t\t\thid_err(field->report->device, \"value %d is out of range\\n\", value);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfield->value[offset] = value;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_set_field);\n\nstatic struct hid_report *hid_get_report(struct hid_report_enum *report_enum,\n\t\tconst u8 *data)\n{\n\tstruct hid_report *report;\n\tunsigned int n = 0;\t \n\n\t \n\tif (report_enum->numbered)\n\t\tn = *data;\n\n\treport = report_enum->report_id_hash[n];\n\tif (report == NULL)\n\t\tdbg_hid(\"undefined report_id %u received\\n\", n);\n\n\treturn report;\n}\n\n \nint __hid_request(struct hid_device *hid, struct hid_report *report,\n\t\tenum hid_class_request reqtype)\n{\n\tchar *buf;\n\tint ret;\n\tu32 len;\n\n\tbuf = hid_alloc_report_buf(report, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen = hid_report_len(report);\n\n\tif (reqtype == HID_REQ_SET_REPORT)\n\t\thid_output_report(report, buf);\n\n\tret = hid->ll_driver->raw_request(hid, report->id, buf, len,\n\t\t\t\t\t  report->type, reqtype);\n\tif (ret < 0) {\n\t\tdbg_hid(\"unable to complete request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (reqtype == HID_REQ_GET_REPORT)\n\t\thid_input_report(hid, report->type, buf, ret, 0);\n\n\tret = 0;\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__hid_request);\n\nint hid_report_raw_event(struct hid_device *hid, enum hid_report_type type, u8 *data, u32 size,\n\t\t\t int interrupt)\n{\n\tstruct hid_report_enum *report_enum = hid->report_enum + type;\n\tstruct hid_report *report;\n\tstruct hid_driver *hdrv;\n\tint max_buffer_size = HID_MAX_BUFFER_SIZE;\n\tu32 rsize, csize = size;\n\tu8 *cdata = data;\n\tint ret = 0;\n\n\treport = hid_get_report(report_enum, data);\n\tif (!report)\n\t\tgoto out;\n\n\tif (report_enum->numbered) {\n\t\tcdata++;\n\t\tcsize--;\n\t}\n\n\trsize = hid_compute_report_size(report);\n\n\tif (hid->ll_driver->max_buffer_size)\n\t\tmax_buffer_size = hid->ll_driver->max_buffer_size;\n\n\tif (report_enum->numbered && rsize >= max_buffer_size)\n\t\trsize = max_buffer_size - 1;\n\telse if (rsize > max_buffer_size)\n\t\trsize = max_buffer_size;\n\n\tif (csize < rsize) {\n\t\tdbg_hid(\"report %d is too short, (%d < %d)\\n\", report->id,\n\t\t\t\tcsize, rsize);\n\t\tmemset(cdata + csize, 0, rsize - csize);\n\t}\n\n\tif ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_report_event)\n\t\thid->hiddev_report_event(hid, report);\n\tif (hid->claimed & HID_CLAIMED_HIDRAW) {\n\t\tret = hidraw_report_event(hid, data, size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (hid->claimed != HID_CLAIMED_HIDRAW && report->maxfield) {\n\t\thid_process_report(hid, report, cdata, interrupt);\n\t\thdrv = hid->driver;\n\t\tif (hdrv && hdrv->report)\n\t\t\thdrv->report(hid, report);\n\t}\n\n\tif (hid->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_report_event(hid, report);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_report_raw_event);\n\n \nint hid_input_report(struct hid_device *hid, enum hid_report_type type, u8 *data, u32 size,\n\t\t     int interrupt)\n{\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_driver *hdrv;\n\tstruct hid_report *report;\n\tint ret = 0;\n\n\tif (!hid)\n\t\treturn -ENODEV;\n\n\tif (down_trylock(&hid->driver_input_lock))\n\t\treturn -EBUSY;\n\n\tif (!hid->driver) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\treport_enum = hid->report_enum + type;\n\thdrv = hid->driver;\n\n\tdata = dispatch_hid_bpf_device_event(hid, type, data, &size, interrupt);\n\tif (IS_ERR(data)) {\n\t\tret = PTR_ERR(data);\n\t\tgoto unlock;\n\t}\n\n\tif (!size) {\n\t\tdbg_hid(\"empty report\\n\");\n\t\tret = -1;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (!list_empty(&hid->debug_list))\n\t\thid_dump_report(hid, type, data, size);\n\n\treport = hid_get_report(report_enum, data);\n\n\tif (!report) {\n\t\tret = -1;\n\t\tgoto unlock;\n\t}\n\n\tif (hdrv && hdrv->raw_event && hid_match_report(hid, report)) {\n\t\tret = hdrv->raw_event(hid, report, data, size);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tret = hid_report_raw_event(hid, type, data, size, interrupt);\n\nunlock:\n\tup(&hid->driver_input_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_input_report);\n\nbool hid_match_one_id(const struct hid_device *hdev,\n\t\t      const struct hid_device_id *id)\n{\n\treturn (id->bus == HID_BUS_ANY || id->bus == hdev->bus) &&\n\t\t(id->group == HID_GROUP_ANY || id->group == hdev->group) &&\n\t\t(id->vendor == HID_ANY_ID || id->vendor == hdev->vendor) &&\n\t\t(id->product == HID_ANY_ID || id->product == hdev->product);\n}\n\nconst struct hid_device_id *hid_match_id(const struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tfor (; id->bus; id++)\n\t\tif (hid_match_one_id(hdev, id))\n\t\t\treturn id;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(hid_match_id);\n\nstatic const struct hid_device_id hid_hiddev_list[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS1) },\n\t{ }\n};\n\nstatic bool hid_hiddev(struct hid_device *hdev)\n{\n\treturn !!hid_match_id(hdev, hid_hiddev_list);\n}\n\n\nstatic ssize_t\nread_report_descriptor(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\tif (off >= hdev->rsize)\n\t\treturn 0;\n\n\tif (off + count > hdev->rsize)\n\t\tcount = hdev->rsize - off;\n\n\tmemcpy(buf, hdev->rdesc + off, count);\n\n\treturn count;\n}\n\nstatic ssize_t\nshow_country(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\treturn sprintf(buf, \"%02x\\n\", hdev->country & 0xff);\n}\n\nstatic struct bin_attribute dev_bin_attr_report_desc = {\n\t.attr = { .name = \"report_descriptor\", .mode = 0444 },\n\t.read = read_report_descriptor,\n\t.size = HID_MAX_DESCRIPTOR_SIZE,\n};\n\nstatic const struct device_attribute dev_attr_country = {\n\t.attr = { .name = \"country\", .mode = 0444 },\n\t.show = show_country,\n};\n\nint hid_connect(struct hid_device *hdev, unsigned int connect_mask)\n{\n\tstatic const char *types[] = { \"Device\", \"Pointer\", \"Mouse\", \"Device\",\n\t\t\"Joystick\", \"Gamepad\", \"Keyboard\", \"Keypad\",\n\t\t\"Multi-Axis Controller\"\n\t};\n\tconst char *type, *bus;\n\tchar buf[64] = \"\";\n\tunsigned int i;\n\tint len;\n\tint ret;\n\n\tret = hid_bpf_connect_device(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hdev->quirks & HID_QUIRK_HIDDEV_FORCE)\n\t\tconnect_mask |= (HID_CONNECT_HIDDEV_FORCE | HID_CONNECT_HIDDEV);\n\tif (hdev->quirks & HID_QUIRK_HIDINPUT_FORCE)\n\t\tconnect_mask |= HID_CONNECT_HIDINPUT_FORCE;\n\tif (hdev->bus != BUS_USB)\n\t\tconnect_mask &= ~HID_CONNECT_HIDDEV;\n\tif (hid_hiddev(hdev))\n\t\tconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\n\n\tif ((connect_mask & HID_CONNECT_HIDINPUT) && !hidinput_connect(hdev,\n\t\t\t\tconnect_mask & HID_CONNECT_HIDINPUT_FORCE))\n\t\thdev->claimed |= HID_CLAIMED_INPUT;\n\n\tif ((connect_mask & HID_CONNECT_HIDDEV) && hdev->hiddev_connect &&\n\t\t\t!hdev->hiddev_connect(hdev,\n\t\t\t\tconnect_mask & HID_CONNECT_HIDDEV_FORCE))\n\t\thdev->claimed |= HID_CLAIMED_HIDDEV;\n\tif ((connect_mask & HID_CONNECT_HIDRAW) && !hidraw_connect(hdev))\n\t\thdev->claimed |= HID_CLAIMED_HIDRAW;\n\n\tif (connect_mask & HID_CONNECT_DRIVER)\n\t\thdev->claimed |= HID_CLAIMED_DRIVER;\n\n\t \n\tif (!hdev->claimed && !hdev->driver->raw_event) {\n\t\thid_err(hdev, \"device has no listeners, quitting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thid_process_ordering(hdev);\n\n\tif ((hdev->claimed & HID_CLAIMED_INPUT) &&\n\t\t\t(connect_mask & HID_CONNECT_FF) && hdev->ff_init)\n\t\thdev->ff_init(hdev);\n\n\tlen = 0;\n\tif (hdev->claimed & HID_CLAIMED_INPUT)\n\t\tlen += sprintf(buf + len, \"input\");\n\tif (hdev->claimed & HID_CLAIMED_HIDDEV)\n\t\tlen += sprintf(buf + len, \"%shiddev%d\", len ? \",\" : \"\",\n\t\t\t\t((struct hiddev *)hdev->hiddev)->minor);\n\tif (hdev->claimed & HID_CLAIMED_HIDRAW)\n\t\tlen += sprintf(buf + len, \"%shidraw%d\", len ? \",\" : \"\",\n\t\t\t\t((struct hidraw *)hdev->hidraw)->minor);\n\n\ttype = \"Device\";\n\tfor (i = 0; i < hdev->maxcollection; i++) {\n\t\tstruct hid_collection *col = &hdev->collection[i];\n\t\tif (col->type == HID_COLLECTION_APPLICATION &&\n\t\t   (col->usage & HID_USAGE_PAGE) == HID_UP_GENDESK &&\n\t\t   (col->usage & 0xffff) < ARRAY_SIZE(types)) {\n\t\t\ttype = types[col->usage & 0xffff];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (hdev->bus) {\n\tcase BUS_USB:\n\t\tbus = \"USB\";\n\t\tbreak;\n\tcase BUS_BLUETOOTH:\n\t\tbus = \"BLUETOOTH\";\n\t\tbreak;\n\tcase BUS_I2C:\n\t\tbus = \"I2C\";\n\t\tbreak;\n\tcase BUS_VIRTUAL:\n\t\tbus = \"VIRTUAL\";\n\t\tbreak;\n\tcase BUS_INTEL_ISHTP:\n\tcase BUS_AMD_SFH:\n\t\tbus = \"SENSOR HUB\";\n\t\tbreak;\n\tdefault:\n\t\tbus = \"<UNKNOWN>\";\n\t}\n\n\tret = device_create_file(&hdev->dev, &dev_attr_country);\n\tif (ret)\n\t\thid_warn(hdev,\n\t\t\t \"can't create sysfs country code attribute err: %d\\n\", ret);\n\n\thid_info(hdev, \"%s: %s HID v%x.%02x %s [%s] on %s\\n\",\n\t\t buf, bus, hdev->version >> 8, hdev->version & 0xff,\n\t\t type, hdev->name, hdev->phys);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_connect);\n\nvoid hid_disconnect(struct hid_device *hdev)\n{\n\tdevice_remove_file(&hdev->dev, &dev_attr_country);\n\tif (hdev->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_disconnect(hdev);\n\tif (hdev->claimed & HID_CLAIMED_HIDDEV)\n\t\thdev->hiddev_disconnect(hdev);\n\tif (hdev->claimed & HID_CLAIMED_HIDRAW)\n\t\thidraw_disconnect(hdev);\n\thdev->claimed = 0;\n\n\thid_bpf_disconnect_device(hdev);\n}\nEXPORT_SYMBOL_GPL(hid_disconnect);\n\n \nint hid_hw_start(struct hid_device *hdev, unsigned int connect_mask)\n{\n\tint error;\n\n\terror = hdev->ll_driver->start(hdev);\n\tif (error)\n\t\treturn error;\n\n\tif (connect_mask) {\n\t\terror = hid_connect(hdev, connect_mask);\n\t\tif (error) {\n\t\t\thdev->ll_driver->stop(hdev);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_hw_start);\n\n \nvoid hid_hw_stop(struct hid_device *hdev)\n{\n\thid_disconnect(hdev);\n\thdev->ll_driver->stop(hdev);\n}\nEXPORT_SYMBOL_GPL(hid_hw_stop);\n\n \nint hid_hw_open(struct hid_device *hdev)\n{\n\tint ret;\n\n\tret = mutex_lock_killable(&hdev->ll_open_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!hdev->ll_open_count++) {\n\t\tret = hdev->ll_driver->open(hdev);\n\t\tif (ret)\n\t\t\thdev->ll_open_count--;\n\t}\n\n\tmutex_unlock(&hdev->ll_open_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_hw_open);\n\n \nvoid hid_hw_close(struct hid_device *hdev)\n{\n\tmutex_lock(&hdev->ll_open_lock);\n\tif (!--hdev->ll_open_count)\n\t\thdev->ll_driver->close(hdev);\n\tmutex_unlock(&hdev->ll_open_lock);\n}\nEXPORT_SYMBOL_GPL(hid_hw_close);\n\n \nvoid hid_hw_request(struct hid_device *hdev,\n\t\t    struct hid_report *report, enum hid_class_request reqtype)\n{\n\tif (hdev->ll_driver->request)\n\t\treturn hdev->ll_driver->request(hdev, report, reqtype);\n\n\t__hid_request(hdev, report, reqtype);\n}\nEXPORT_SYMBOL_GPL(hid_hw_request);\n\n \nint hid_hw_raw_request(struct hid_device *hdev,\n\t\t       unsigned char reportnum, __u8 *buf,\n\t\t       size_t len, enum hid_report_type rtype, enum hid_class_request reqtype)\n{\n\tunsigned int max_buffer_size = HID_MAX_BUFFER_SIZE;\n\n\tif (hdev->ll_driver->max_buffer_size)\n\t\tmax_buffer_size = hdev->ll_driver->max_buffer_size;\n\n\tif (len < 1 || len > max_buffer_size || !buf)\n\t\treturn -EINVAL;\n\n\treturn hdev->ll_driver->raw_request(hdev, reportnum, buf, len,\n\t\t\t\t\t    rtype, reqtype);\n}\nEXPORT_SYMBOL_GPL(hid_hw_raw_request);\n\n \nint hid_hw_output_report(struct hid_device *hdev, __u8 *buf, size_t len)\n{\n\tunsigned int max_buffer_size = HID_MAX_BUFFER_SIZE;\n\n\tif (hdev->ll_driver->max_buffer_size)\n\t\tmax_buffer_size = hdev->ll_driver->max_buffer_size;\n\n\tif (len < 1 || len > max_buffer_size || !buf)\n\t\treturn -EINVAL;\n\n\tif (hdev->ll_driver->output_report)\n\t\treturn hdev->ll_driver->output_report(hdev, buf, len);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(hid_hw_output_report);\n\n#ifdef CONFIG_PM\nint hid_driver_suspend(struct hid_device *hdev, pm_message_t state)\n{\n\tif (hdev->driver && hdev->driver->suspend)\n\t\treturn hdev->driver->suspend(hdev, state);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_driver_suspend);\n\nint hid_driver_reset_resume(struct hid_device *hdev)\n{\n\tif (hdev->driver && hdev->driver->reset_resume)\n\t\treturn hdev->driver->reset_resume(hdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_driver_reset_resume);\n\nint hid_driver_resume(struct hid_device *hdev)\n{\n\tif (hdev->driver && hdev->driver->resume)\n\t\treturn hdev->driver->resume(hdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_driver_resume);\n#endif  \n\nstruct hid_dynid {\n\tstruct list_head list;\n\tstruct hid_device_id id;\n};\n\n \nstatic ssize_t new_id_store(struct device_driver *drv, const char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(drv);\n\tstruct hid_dynid *dynid;\n\t__u32 bus, vendor, product;\n\tunsigned long driver_data = 0;\n\tint ret;\n\n\tret = sscanf(buf, \"%x %x %x %lx\",\n\t\t\t&bus, &vendor, &product, &driver_data);\n\tif (ret < 3)\n\t\treturn -EINVAL;\n\n\tdynid = kzalloc(sizeof(*dynid), GFP_KERNEL);\n\tif (!dynid)\n\t\treturn -ENOMEM;\n\n\tdynid->id.bus = bus;\n\tdynid->id.group = HID_GROUP_ANY;\n\tdynid->id.vendor = vendor;\n\tdynid->id.product = product;\n\tdynid->id.driver_data = driver_data;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_add_tail(&dynid->list, &hdrv->dyn_list);\n\tspin_unlock(&hdrv->dyn_lock);\n\n\tret = driver_attach(&hdrv->driver);\n\n\treturn ret ? : count;\n}\nstatic DRIVER_ATTR_WO(new_id);\n\nstatic struct attribute *hid_drv_attrs[] = {\n\t&driver_attr_new_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(hid_drv);\n\nstatic void hid_free_dynids(struct hid_driver *hdrv)\n{\n\tstruct hid_dynid *dynid, *n;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_for_each_entry_safe(dynid, n, &hdrv->dyn_list, list) {\n\t\tlist_del(&dynid->list);\n\t\tkfree(dynid);\n\t}\n\tspin_unlock(&hdrv->dyn_lock);\n}\n\nconst struct hid_device_id *hid_match_device(struct hid_device *hdev,\n\t\t\t\t\t     struct hid_driver *hdrv)\n{\n\tstruct hid_dynid *dynid;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_for_each_entry(dynid, &hdrv->dyn_list, list) {\n\t\tif (hid_match_one_id(hdev, &dynid->id)) {\n\t\t\tspin_unlock(&hdrv->dyn_lock);\n\t\t\treturn &dynid->id;\n\t\t}\n\t}\n\tspin_unlock(&hdrv->dyn_lock);\n\n\treturn hid_match_id(hdev, hdrv->id_table);\n}\nEXPORT_SYMBOL_GPL(hid_match_device);\n\nstatic int hid_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(drv);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\treturn hid_match_device(hdev, hdrv) != NULL;\n}\n\n \nbool hid_compare_device_paths(struct hid_device *hdev_a,\n\t\t\t      struct hid_device *hdev_b, char separator)\n{\n\tint n1 = strrchr(hdev_a->phys, separator) - hdev_a->phys;\n\tint n2 = strrchr(hdev_b->phys, separator) - hdev_b->phys;\n\n\tif (n1 != n2 || n1 <= 0 || n2 <= 0)\n\t\treturn false;\n\n\treturn !strncmp(hdev_a->phys, hdev_b->phys, n1);\n}\nEXPORT_SYMBOL_GPL(hid_compare_device_paths);\n\nstatic bool hid_check_device_match(struct hid_device *hdev,\n\t\t\t\t   struct hid_driver *hdrv,\n\t\t\t\t   const struct hid_device_id **id)\n{\n\t*id = hid_match_device(hdev, hdrv);\n\tif (!*id)\n\t\treturn false;\n\n\tif (hdrv->match)\n\t\treturn hdrv->match(hdev, hid_ignore_special_drivers);\n\n\t \n\treturn !hid_ignore_special_drivers;\n}\n\nstatic int __hid_device_probe(struct hid_device *hdev, struct hid_driver *hdrv)\n{\n\tconst struct hid_device_id *id;\n\tint ret;\n\n\tif (!hid_check_device_match(hdev, hdrv, &id))\n\t\treturn -ENODEV;\n\n\thdev->devres_group_id = devres_open_group(&hdev->dev, NULL, GFP_KERNEL);\n\tif (!hdev->devres_group_id)\n\t\treturn -ENOMEM;\n\n\t \n\thdev->quirks = hid_lookup_quirk(hdev);\n\thdev->driver = hdrv;\n\n\tif (hdrv->probe) {\n\t\tret = hdrv->probe(hdev, id);\n\t} else {  \n\t\tret = hid_open_report(hdev);\n\t\tif (!ret)\n\t\t\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t}\n\n\t \n\n\tif (ret) {\n\t\tdevres_release_group(&hdev->dev, hdev->devres_group_id);\n\t\thid_close_report(hdev);\n\t\thdev->driver = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int hid_device_probe(struct device *dev)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct hid_driver *hdrv = to_hid_driver(dev->driver);\n\tint ret = 0;\n\n\tif (down_interruptible(&hdev->driver_input_lock))\n\t\treturn -EINTR;\n\n\thdev->io_started = false;\n\tclear_bit(ffs(HID_STAT_REPROBED), &hdev->status);\n\n\tif (!hdev->driver)\n\t\tret = __hid_device_probe(hdev, hdrv);\n\n\tif (!hdev->io_started)\n\t\tup(&hdev->driver_input_lock);\n\n\treturn ret;\n}\n\nstatic void hid_device_remove(struct device *dev)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct hid_driver *hdrv;\n\n\tdown(&hdev->driver_input_lock);\n\thdev->io_started = false;\n\n\thdrv = hdev->driver;\n\tif (hdrv) {\n\t\tif (hdrv->remove)\n\t\t\thdrv->remove(hdev);\n\t\telse  \n\t\t\thid_hw_stop(hdev);\n\n\t\t \n\t\tdevres_release_group(&hdev->dev, hdev->devres_group_id);\n\n\t\thid_close_report(hdev);\n\t\thdev->driver = NULL;\n\t}\n\n\tif (!hdev->io_started)\n\t\tup(&hdev->driver_input_lock);\n}\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *a,\n\t\t\t     char *buf)\n{\n\tstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"hid:b%04Xg%04Xv%08Xp%08X\\n\",\n\t\t\t hdev->bus, hdev->group, hdev->vendor, hdev->product);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *hid_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nstatic struct bin_attribute *hid_dev_bin_attrs[] = {\n\t&dev_bin_attr_report_desc,\n\tNULL\n};\nstatic const struct attribute_group hid_dev_group = {\n\t.attrs = hid_dev_attrs,\n\t.bin_attrs = hid_dev_bin_attrs,\n};\n__ATTRIBUTE_GROUPS(hid_dev);\n\nstatic int hid_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct hid_device *hdev = to_hid_device(dev);\n\n\tif (add_uevent_var(env, \"HID_ID=%04X:%08X:%08X\",\n\t\t\thdev->bus, hdev->vendor, hdev->product))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_NAME=%s\", hdev->name))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_PHYS=%s\", hdev->phys))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"HID_UNIQ=%s\", hdev->uniq))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MODALIAS=hid:b%04Xg%04Xv%08Xp%08X\",\n\t\t\t   hdev->bus, hdev->group, hdev->vendor, hdev->product))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct bus_type hid_bus_type = {\n\t.name\t\t= \"hid\",\n\t.dev_groups\t= hid_dev_groups,\n\t.drv_groups\t= hid_drv_groups,\n\t.match\t\t= hid_bus_match,\n\t.probe\t\t= hid_device_probe,\n\t.remove\t\t= hid_device_remove,\n\t.uevent\t\t= hid_uevent,\n};\nEXPORT_SYMBOL(hid_bus_type);\n\nint hid_add_device(struct hid_device *hdev)\n{\n\tstatic atomic_t id = ATOMIC_INIT(0);\n\tint ret;\n\n\tif (WARN_ON(hdev->status & HID_STAT_ADDED))\n\t\treturn -EBUSY;\n\n\thdev->quirks = hid_lookup_quirk(hdev);\n\n\t \n\tif (hid_ignore(hdev))\n\t\treturn -ENODEV;\n\n\t \n\t if (!hdev->ll_driver->raw_request) {\n\t\thid_err(hdev, \"transport driver missing .raw_request()\\n\");\n\t\treturn -EINVAL;\n\t }\n\n\t \n\tret = hdev->ll_driver->parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\tif (!hdev->dev_rdesc)\n\t\treturn -ENODEV;\n\n\t \n\tif (hid_ignore_special_drivers) {\n\t\thdev->group = HID_GROUP_GENERIC;\n\t} else if (!hdev->group &&\n\t\t   !(hdev->quirks & HID_QUIRK_HAVE_SPECIAL_DRIVER)) {\n\t\tret = hid_scan_report(hdev);\n\t\tif (ret)\n\t\t\thid_warn(hdev, \"bad device descriptor (%d)\\n\", ret);\n\t}\n\n\thdev->id = atomic_inc_return(&id);\n\n\t \n\tdev_set_name(&hdev->dev, \"%04X:%04X:%04X.%04X\", hdev->bus,\n\t\t     hdev->vendor, hdev->product, hdev->id);\n\n\thid_debug_register(hdev, dev_name(&hdev->dev));\n\tret = device_add(&hdev->dev);\n\tif (!ret)\n\t\thdev->status |= HID_STAT_ADDED;\n\telse\n\t\thid_debug_unregister(hdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hid_add_device);\n\n \nstruct hid_device *hid_allocate_device(void)\n{\n\tstruct hid_device *hdev;\n\tint ret = -ENOMEM;\n\n\thdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\n\tif (hdev == NULL)\n\t\treturn ERR_PTR(ret);\n\n\tdevice_initialize(&hdev->dev);\n\thdev->dev.release = hid_device_release;\n\thdev->dev.bus = &hid_bus_type;\n\tdevice_enable_async_suspend(&hdev->dev);\n\n\thid_close_report(hdev);\n\n\tinit_waitqueue_head(&hdev->debug_wait);\n\tINIT_LIST_HEAD(&hdev->debug_list);\n\tspin_lock_init(&hdev->debug_list_lock);\n\tsema_init(&hdev->driver_input_lock, 1);\n\tmutex_init(&hdev->ll_open_lock);\n\tkref_init(&hdev->ref);\n\n\thid_bpf_device_init(hdev);\n\n\treturn hdev;\n}\nEXPORT_SYMBOL_GPL(hid_allocate_device);\n\nstatic void hid_remove_device(struct hid_device *hdev)\n{\n\tif (hdev->status & HID_STAT_ADDED) {\n\t\tdevice_del(&hdev->dev);\n\t\thid_debug_unregister(hdev);\n\t\thdev->status &= ~HID_STAT_ADDED;\n\t}\n\tkfree(hdev->dev_rdesc);\n\thdev->dev_rdesc = NULL;\n\thdev->dev_rsize = 0;\n}\n\n \nvoid hid_destroy_device(struct hid_device *hdev)\n{\n\thid_bpf_destroy_device(hdev);\n\thid_remove_device(hdev);\n\tput_device(&hdev->dev);\n}\nEXPORT_SYMBOL_GPL(hid_destroy_device);\n\n\nstatic int __hid_bus_reprobe_drivers(struct device *dev, void *data)\n{\n\tstruct hid_driver *hdrv = data;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\tif (hdev->driver == hdrv &&\n\t    !hdrv->match(hdev, hid_ignore_special_drivers) &&\n\t    !test_and_set_bit(ffs(HID_STAT_REPROBED), &hdev->status))\n\t\treturn device_reprobe(dev);\n\n\treturn 0;\n}\n\nstatic int __hid_bus_driver_added(struct device_driver *drv, void *data)\n{\n\tstruct hid_driver *hdrv = to_hid_driver(drv);\n\n\tif (hdrv->match) {\n\t\tbus_for_each_dev(&hid_bus_type, NULL, hdrv,\n\t\t\t\t __hid_bus_reprobe_drivers);\n\t}\n\n\treturn 0;\n}\n\nstatic int __bus_removed_driver(struct device_driver *drv, void *data)\n{\n\treturn bus_rescan_devices(&hid_bus_type);\n}\n\nint __hid_register_driver(struct hid_driver *hdrv, struct module *owner,\n\t\tconst char *mod_name)\n{\n\tint ret;\n\n\thdrv->driver.name = hdrv->name;\n\thdrv->driver.bus = &hid_bus_type;\n\thdrv->driver.owner = owner;\n\thdrv->driver.mod_name = mod_name;\n\n\tINIT_LIST_HEAD(&hdrv->dyn_list);\n\tspin_lock_init(&hdrv->dyn_lock);\n\n\tret = driver_register(&hdrv->driver);\n\n\tif (ret == 0)\n\t\tbus_for_each_drv(&hid_bus_type, NULL, NULL,\n\t\t\t\t __hid_bus_driver_added);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__hid_register_driver);\n\nvoid hid_unregister_driver(struct hid_driver *hdrv)\n{\n\tdriver_unregister(&hdrv->driver);\n\thid_free_dynids(hdrv);\n\n\tbus_for_each_drv(&hid_bus_type, NULL, hdrv, __bus_removed_driver);\n}\nEXPORT_SYMBOL_GPL(hid_unregister_driver);\n\nint hid_check_keys_pressed(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput;\n\tint i;\n\n\tif (!(hid->claimed & HID_CLAIMED_INPUT))\n\t\treturn 0;\n\n\tlist_for_each_entry(hidinput, &hid->inputs, list) {\n\t\tfor (i = 0; i < BITS_TO_LONGS(KEY_MAX); i++)\n\t\t\tif (hidinput->input->key[i])\n\t\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hid_check_keys_pressed);\n\n#ifdef CONFIG_HID_BPF\nstatic struct hid_bpf_ops hid_ops = {\n\t.hid_get_report = hid_get_report,\n\t.hid_hw_raw_request = hid_hw_raw_request,\n\t.owner = THIS_MODULE,\n\t.bus_type = &hid_bus_type,\n};\n#endif\n\nstatic int __init hid_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&hid_bus_type);\n\tif (ret) {\n\t\tpr_err(\"can't register hid bus\\n\");\n\t\tgoto err;\n\t}\n\n#ifdef CONFIG_HID_BPF\n\thid_bpf_ops = &hid_ops;\n#endif\n\n\tret = hidraw_init();\n\tif (ret)\n\t\tgoto err_bus;\n\n\thid_debug_init();\n\n\treturn 0;\nerr_bus:\n\tbus_unregister(&hid_bus_type);\nerr:\n\treturn ret;\n}\n\nstatic void __exit hid_exit(void)\n{\n#ifdef CONFIG_HID_BPF\n\thid_bpf_ops = NULL;\n#endif\n\thid_debug_exit();\n\thidraw_exit();\n\tbus_unregister(&hid_bus_type);\n\thid_quirks_exit(HID_BUS_ANY);\n}\n\nmodule_init(hid_init);\nmodule_exit(hid_exit);\n\nMODULE_AUTHOR(\"Andreas Gal\");\nMODULE_AUTHOR(\"Vojtech Pavlik\");\nMODULE_AUTHOR(\"Jiri Kosina\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}