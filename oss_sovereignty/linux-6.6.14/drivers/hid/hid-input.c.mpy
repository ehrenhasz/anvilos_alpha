{
  "module_name": "hid-input.c",
  "hash_id": "2ed80d6f517e93553f925ec962b144118c5eab9277523c04bc3149282d2ad092",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-input.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#include <linux/hid.h>\n#include <linux/hid-debug.h>\n\n#include \"hid-ids.h\"\n\n#define unk\tKEY_UNKNOWN\n\nstatic const unsigned char hid_keyboard[256] = {\n\t  0,  0,  0,  0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38,\n\t 50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44,  2,  3,\n\t  4,  5,  6,  7,  8,  9, 10, 11, 28,  1, 14, 15, 57, 12, 13, 26,\n\t 27, 43, 43, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64,\n\t 65, 66, 67, 68, 87, 88, 99, 70,119,110,102,104,111,107,109,106,\n\t105,108,103, 69, 98, 55, 74, 78, 96, 79, 80, 81, 75, 76, 77, 71,\n\t 72, 73, 82, 83, 86,127,116,117,183,184,185,186,187,188,189,190,\n\t191,192,193,194,134,138,130,132,128,129,131,137,133,135,136,113,\n\t115,114,unk,unk,unk,121,unk, 89, 93,124, 92, 94, 95,unk,unk,unk,\n\t122,123, 90, 91, 85,unk,unk,unk,unk,unk,unk,unk,111,unk,unk,unk,\n\tunk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,\n\tunk,unk,unk,unk,unk,unk,179,180,unk,unk,unk,unk,unk,unk,unk,unk,\n\tunk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,\n\tunk,unk,unk,unk,unk,unk,unk,unk,111,unk,unk,unk,unk,unk,unk,unk,\n\t 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113,\n\t150,158,159,128,136,177,178,176,142,152,173,140,unk,unk,unk,unk\n};\n\nstatic const struct {\n\t__s32 x;\n\t__s32 y;\n}  hid_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};\n\nstruct usage_priority {\n\t__u32 usage;\t\t\t \n\tbool global;\t\t\t \n\tunsigned int slot_overwrite;\t \n};\n\n \nstatic const struct usage_priority hidinput_usages_priorities[] = {\n\t{  \n\t  .usage = HID_DG_ERASER,\n\t},\n\t{  \n\t  .usage = HID_DG_INVERT,\n\t},\n\t{  \n\t  .usage = HID_DG_TIPSWITCH,\n\t},\n\t{  \n\t  .usage = HID_DG_TIPPRESSURE,\n\t},\n\t{  \n\t  .usage = HID_DG_INRANGE,\n\t},\n};\n\n#define map_abs(c)\thid_map_usage(hidinput, usage, &bit, &max, EV_ABS, (c))\n#define map_rel(c)\thid_map_usage(hidinput, usage, &bit, &max, EV_REL, (c))\n#define map_key(c)\thid_map_usage(hidinput, usage, &bit, &max, EV_KEY, (c))\n#define map_led(c)\thid_map_usage(hidinput, usage, &bit, &max, EV_LED, (c))\n#define map_msc(c)\thid_map_usage(hidinput, usage, &bit, &max, EV_MSC, (c))\n\n#define map_abs_clear(c)\thid_map_usage_clear(hidinput, usage, &bit, \\\n\t\t&max, EV_ABS, (c))\n#define map_key_clear(c)\thid_map_usage_clear(hidinput, usage, &bit, \\\n\t\t&max, EV_KEY, (c))\n\nstatic bool match_scancode(struct hid_usage *usage,\n\t\t\t   unsigned int cur_idx, unsigned int scancode)\n{\n\treturn (usage->hid & (HID_USAGE_PAGE | HID_USAGE)) == scancode;\n}\n\nstatic bool match_keycode(struct hid_usage *usage,\n\t\t\t  unsigned int cur_idx, unsigned int keycode)\n{\n\t \n\treturn (usage->type == EV_KEY && usage->code == keycode);\n}\n\nstatic bool match_index(struct hid_usage *usage,\n\t\t\tunsigned int cur_idx, unsigned int idx)\n{\n\treturn cur_idx == idx;\n}\n\ntypedef bool (*hid_usage_cmp_t)(struct hid_usage *usage,\n\t\t\t\tunsigned int cur_idx, unsigned int val);\n\nstatic struct hid_usage *hidinput_find_key(struct hid_device *hid,\n\t\t\t\t\t   hid_usage_cmp_t match,\n\t\t\t\t\t   unsigned int value,\n\t\t\t\t\t   unsigned int *usage_idx)\n{\n\tunsigned int i, j, k, cur_idx = 0;\n\tstruct hid_report *report;\n\tstruct hid_usage *usage;\n\n\tfor (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {\n\t\tlist_for_each_entry(report, &hid->report_enum[k].report_list, list) {\n\t\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\t\tfor (j = 0; j < report->field[i]->maxusage; j++) {\n\t\t\t\t\tusage = report->field[i]->usage + j;\n\t\t\t\t\tif (usage->type == EV_KEY || usage->type == 0) {\n\t\t\t\t\t\tif (match(usage, cur_idx, value)) {\n\t\t\t\t\t\t\tif (usage_idx)\n\t\t\t\t\t\t\t\t*usage_idx = cur_idx;\n\t\t\t\t\t\t\treturn usage;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur_idx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct hid_usage *hidinput_locate_usage(struct hid_device *hid,\n\t\t\t\t\tconst struct input_keymap_entry *ke,\n\t\t\t\t\tunsigned int *index)\n{\n\tstruct hid_usage *usage;\n\tunsigned int scancode;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX)\n\t\tusage = hidinput_find_key(hid, match_index, ke->index, index);\n\telse if (input_scancode_to_scalar(ke, &scancode) == 0)\n\t\tusage = hidinput_find_key(hid, match_scancode, scancode, index);\n\telse\n\t\tusage = NULL;\n\n\treturn usage;\n}\n\nstatic int hidinput_getkeycode(struct input_dev *dev,\n\t\t\t       struct input_keymap_entry *ke)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct hid_usage *usage;\n\tunsigned int scancode, index;\n\n\tusage = hidinput_locate_usage(hid, ke, &index);\n\tif (usage) {\n\t\tke->keycode = usage->type == EV_KEY ?\n\t\t\t\tusage->code : KEY_RESERVED;\n\t\tke->index = index;\n\t\tscancode = usage->hid & (HID_USAGE_PAGE | HID_USAGE);\n\t\tke->len = sizeof(scancode);\n\t\tmemcpy(ke->scancode, &scancode, sizeof(scancode));\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int hidinput_setkeycode(struct input_dev *dev,\n\t\t\t       const struct input_keymap_entry *ke,\n\t\t\t       unsigned int *old_keycode)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct hid_usage *usage;\n\n\tusage = hidinput_locate_usage(hid, ke, NULL);\n\tif (usage) {\n\t\t*old_keycode = usage->type == EV_KEY ?\n\t\t\t\tusage->code : KEY_RESERVED;\n\t\tusage->type = EV_KEY;\n\t\tusage->code = ke->keycode;\n\n\t\tclear_bit(*old_keycode, dev->keybit);\n\t\tset_bit(usage->code, dev->keybit);\n\t\tdbg_hid(\"Assigned keycode %d to HID usage code %x\\n\",\n\t\t\tusage->code, usage->hid);\n\n\t\t \n\t\tif (hidinput_find_key(hid, match_keycode, *old_keycode, NULL))\n\t\t\tset_bit(*old_keycode, dev->keybit);\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n\n \n__s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)\n{\n\t__s32 unit_exponent = field->unit_exponent;\n\t__s32 logical_extents = field->logical_maximum -\n\t\t\t\t\tfield->logical_minimum;\n\t__s32 physical_extents = field->physical_maximum -\n\t\t\t\t\tfield->physical_minimum;\n\t__s32 prev;\n\n\t \n\tif (logical_extents <= 0 || physical_extents <= 0)\n\t\treturn 0;\n\n\t \n\tswitch (code) {\n\tcase ABS_X:\n\tcase ABS_Y:\n\tcase ABS_Z:\n\tcase ABS_MT_POSITION_X:\n\tcase ABS_MT_POSITION_Y:\n\tcase ABS_MT_TOOL_X:\n\tcase ABS_MT_TOOL_Y:\n\tcase ABS_MT_TOUCH_MAJOR:\n\tcase ABS_MT_TOUCH_MINOR:\n\t\tif (field->unit == 0x11) {\t\t \n\t\t\t \n\t\t\tunit_exponent += 1;\n\t\t} else if (field->unit == 0x13) {\t \n\t\t\t \n\t\t\tprev = physical_extents;\n\t\t\tphysical_extents *= 254;\n\t\t\tif (physical_extents < prev)\n\t\t\t\treturn 0;\n\t\t\tunit_exponent -= 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase ABS_RX:\n\tcase ABS_RY:\n\tcase ABS_RZ:\n\tcase ABS_WHEEL:\n\tcase ABS_TILT_X:\n\tcase ABS_TILT_Y:\n\t\tif (field->unit == 0x14) {\t\t \n\t\t\t \n\t\t\tprev = logical_extents;\n\t\t\tlogical_extents *= 573;\n\t\t\tif (logical_extents < prev)\n\t\t\t\treturn 0;\n\t\t\tunit_exponent += 1;\n\t\t} else if (field->unit != 0x12) {\t \n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tfor (; unit_exponent < 0; unit_exponent++) {\n\t\tprev = logical_extents;\n\t\tlogical_extents *= 10;\n\t\tif (logical_extents < prev)\n\t\t\treturn 0;\n\t}\n\t \n\tfor (; unit_exponent > 0; unit_exponent--) {\n\t\tprev = physical_extents;\n\t\tphysical_extents *= 10;\n\t\tif (physical_extents < prev)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn DIV_ROUND_CLOSEST(logical_extents, physical_extents);\n}\nEXPORT_SYMBOL_GPL(hidinput_calc_abs_res);\n\n#ifdef CONFIG_HID_BATTERY_STRENGTH\nstatic enum power_supply_property hidinput_battery_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_SCOPE,\n};\n\n#define HID_BATTERY_QUIRK_PERCENT\t(1 << 0)  \n#define HID_BATTERY_QUIRK_FEATURE\t(1 << 1)  \n#define HID_BATTERY_QUIRK_IGNORE\t(1 << 2)  \n#define HID_BATTERY_QUIRK_AVOID_QUERY\t(1 << 3)  \n\nstatic const struct hid_device_id hid_battery_quirks[] = {\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),\n\t  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI),\n\t  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),\n\t  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\t\t       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO),\n\t  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI),\n\t  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_MAGICTRACKPAD),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ELECOM,\n\t\tUSB_DEVICE_ID_ELECOM_BM084),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYMBOL,\n\t\tUSB_DEVICE_ID_SYMBOL_SCANNER_3),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ASUSTEK,\n\t\tUSB_DEVICE_ID_ASUSTEK_T100CHI_KEYBOARD),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_DINOVO_EDGE_KBD),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_ASUS_TP420IA_TOUCHSCREEN),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_ASUS_GV301RA_TOUCHSCREEN),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELAN, USB_DEVICE_ID_ASUS_UX550_TOUCHSCREEN),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELAN, USB_DEVICE_ID_ASUS_UX550VE_TOUCHSCREEN),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE, USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_L),\n\t  HID_BATTERY_QUIRK_AVOID_QUERY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE, USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_MW),\n\t  HID_BATTERY_QUIRK_AVOID_QUERY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_UGEE, USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_SW),\n\t  HID_BATTERY_QUIRK_AVOID_QUERY },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_ENVY_X360_15),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_ENVY_X360_15T_DR100),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_ENVY_X360_EU0009NV),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_SPECTRE_X360_15),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_SPECTRE_X360_13_AW0020NG),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_SURFACE_GO_TOUCHSCREEN),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_SURFACE_GO2_TOUCHSCREEN),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_LENOVO_YOGA_C630_TOUCHSCREEN),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_SPECTRE_X360_13T_AW100),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_SPECTRE_X360_14T_EA100_V1),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_SPECTRE_X360_14T_EA100_V2),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_HP_ENVY_X360_15_EU0556NG),\n\t  HID_BATTERY_QUIRK_IGNORE },\n\t{}\n};\n\nstatic unsigned find_battery_quirk(struct hid_device *hdev)\n{\n\tunsigned quirks = 0;\n\tconst struct hid_device_id *match;\n\n\tmatch = hid_match_id(hdev, hid_battery_quirks);\n\tif (match != NULL)\n\t\tquirks = match->driver_data;\n\n\treturn quirks;\n}\n\nstatic int hidinput_scale_battery_capacity(struct hid_device *dev,\n\t\t\t\t\t   int value)\n{\n\tif (dev->battery_min < dev->battery_max &&\n\t    value >= dev->battery_min && value <= dev->battery_max)\n\t\tvalue = ((value - dev->battery_min) * 100) /\n\t\t\t(dev->battery_max - dev->battery_min);\n\n\treturn value;\n}\n\nstatic int hidinput_query_battery_capacity(struct hid_device *dev)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(4, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(dev, dev->battery_report_id, buf, 4,\n\t\t\t\t dev->battery_report_type, HID_REQ_GET_REPORT);\n\tif (ret < 2) {\n\t\tkfree(buf);\n\t\treturn -ENODATA;\n\t}\n\n\tret = hidinput_scale_battery_capacity(dev, buf[1]);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int hidinput_get_battery_property(struct power_supply *psy,\n\t\t\t\t\t enum power_supply_property prop,\n\t\t\t\t\t union power_supply_propval *val)\n{\n\tstruct hid_device *dev = power_supply_get_drvdata(psy);\n\tint value;\n\tint ret = 0;\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = 1;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tif (dev->battery_status != HID_BATTERY_REPORTED &&\n\t\t    !dev->battery_avoid_query) {\n\t\t\tvalue = hidinput_query_battery_capacity(dev);\n\t\t\tif (value < 0)\n\t\t\t\treturn value;\n\t\t} else  {\n\t\t\tvalue = dev->battery_capacity;\n\t\t}\n\n\t\tval->intval = value;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = dev->name;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (dev->battery_status != HID_BATTERY_REPORTED &&\n\t\t    !dev->battery_avoid_query) {\n\t\t\tvalue = hidinput_query_battery_capacity(dev);\n\t\t\tif (value < 0)\n\t\t\t\treturn value;\n\n\t\t\tdev->battery_capacity = value;\n\t\t\tdev->battery_status = HID_BATTERY_QUERIED;\n\t\t}\n\n\t\tif (dev->battery_status == HID_BATTERY_UNKNOWN)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\telse\n\t\t\tval->intval = dev->battery_charge_status;\n\t\tbreak;\n\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int hidinput_setup_battery(struct hid_device *dev, unsigned report_type,\n\t\t\t\t  struct hid_field *field, bool is_percentage)\n{\n\tstruct power_supply_desc *psy_desc;\n\tstruct power_supply_config psy_cfg = { .drv_data = dev, };\n\tunsigned quirks;\n\ts32 min, max;\n\tint error;\n\n\tif (dev->battery)\n\t\treturn 0;\t \n\n\tquirks = find_battery_quirk(dev);\n\n\thid_dbg(dev, \"device %x:%x:%x %d quirks %d\\n\",\n\t\tdev->bus, dev->vendor, dev->product, dev->version, quirks);\n\n\tif (quirks & HID_BATTERY_QUIRK_IGNORE)\n\t\treturn 0;\n\n\tpsy_desc = kzalloc(sizeof(*psy_desc), GFP_KERNEL);\n\tif (!psy_desc)\n\t\treturn -ENOMEM;\n\n\tpsy_desc->name = kasprintf(GFP_KERNEL, \"hid-%s-battery\",\n\t\t\t\t   strlen(dev->uniq) ?\n\t\t\t\t\tdev->uniq : dev_name(&dev->dev));\n\tif (!psy_desc->name) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_mem;\n\t}\n\n\tpsy_desc->type = POWER_SUPPLY_TYPE_BATTERY;\n\tpsy_desc->properties = hidinput_battery_props;\n\tpsy_desc->num_properties = ARRAY_SIZE(hidinput_battery_props);\n\tpsy_desc->use_for_apm = 0;\n\tpsy_desc->get_property = hidinput_get_battery_property;\n\n\tmin = field->logical_minimum;\n\tmax = field->logical_maximum;\n\n\tif (is_percentage || (quirks & HID_BATTERY_QUIRK_PERCENT)) {\n\t\tmin = 0;\n\t\tmax = 100;\n\t}\n\n\tif (quirks & HID_BATTERY_QUIRK_FEATURE)\n\t\treport_type = HID_FEATURE_REPORT;\n\n\tdev->battery_min = min;\n\tdev->battery_max = max;\n\tdev->battery_report_type = report_type;\n\tdev->battery_report_id = field->report->id;\n\tdev->battery_charge_status = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\t \n\tdev->battery_avoid_query = report_type == HID_INPUT_REPORT &&\n\t\t\t\t   field->physical == HID_DG_STYLUS;\n\n\tif (quirks & HID_BATTERY_QUIRK_AVOID_QUERY)\n\t\tdev->battery_avoid_query = true;\n\n\tdev->battery = power_supply_register(&dev->dev, psy_desc, &psy_cfg);\n\tif (IS_ERR(dev->battery)) {\n\t\terror = PTR_ERR(dev->battery);\n\t\thid_warn(dev, \"can't register power supply: %d\\n\", error);\n\t\tgoto err_free_name;\n\t}\n\n\tpower_supply_powers(dev->battery, &dev->dev);\n\treturn 0;\n\nerr_free_name:\n\tkfree(psy_desc->name);\nerr_free_mem:\n\tkfree(psy_desc);\n\tdev->battery = NULL;\n\treturn error;\n}\n\nstatic void hidinput_cleanup_battery(struct hid_device *dev)\n{\n\tconst struct power_supply_desc *psy_desc;\n\n\tif (!dev->battery)\n\t\treturn;\n\n\tpsy_desc = dev->battery->desc;\n\tpower_supply_unregister(dev->battery);\n\tkfree(psy_desc->name);\n\tkfree(psy_desc);\n\tdev->battery = NULL;\n}\n\nstatic void hidinput_update_battery(struct hid_device *dev, int value)\n{\n\tint capacity;\n\n\tif (!dev->battery)\n\t\treturn;\n\n\tif (value == 0 || value < dev->battery_min || value > dev->battery_max)\n\t\treturn;\n\n\tcapacity = hidinput_scale_battery_capacity(dev, value);\n\n\tif (dev->battery_status != HID_BATTERY_REPORTED ||\n\t    capacity != dev->battery_capacity ||\n\t    ktime_after(ktime_get_coarse(), dev->battery_ratelimit_time)) {\n\t\tdev->battery_capacity = capacity;\n\t\tdev->battery_status = HID_BATTERY_REPORTED;\n\t\tdev->battery_ratelimit_time =\n\t\t\tktime_add_ms(ktime_get_coarse(), 30 * 1000);\n\t\tpower_supply_changed(dev->battery);\n\t}\n}\n\nstatic bool hidinput_set_battery_charge_status(struct hid_device *dev,\n\t\t\t\t\t       unsigned int usage, int value)\n{\n\tswitch (usage) {\n\tcase HID_BAT_CHARGING:\n\t\tdev->battery_charge_status = value ?\n\t\t\t\t\t     POWER_SUPPLY_STATUS_CHARGING :\n\t\t\t\t\t     POWER_SUPPLY_STATUS_DISCHARGING;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n#else   \nstatic int hidinput_setup_battery(struct hid_device *dev, unsigned report_type,\n\t\t\t\t  struct hid_field *field, bool is_percentage)\n{\n\treturn 0;\n}\n\nstatic void hidinput_cleanup_battery(struct hid_device *dev)\n{\n}\n\nstatic void hidinput_update_battery(struct hid_device *dev, int value)\n{\n}\n\nstatic bool hidinput_set_battery_charge_status(struct hid_device *dev,\n\t\t\t\t\t       unsigned int usage, int value)\n{\n\treturn false;\n}\n#endif\t \n\nstatic bool hidinput_field_in_collection(struct hid_device *device, struct hid_field *field,\n\t\t\t\t\t unsigned int type, unsigned int usage)\n{\n\tstruct hid_collection *collection;\n\n\tcollection = &device->collection[field->usage->collection_index];\n\n\treturn collection->type == type && collection->usage == usage;\n}\n\nstatic void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,\n\t\t\t\t     struct hid_usage *usage, unsigned int usage_index)\n{\n\tstruct input_dev *input = hidinput->input;\n\tstruct hid_device *device = input_get_drvdata(input);\n\tconst struct usage_priority *usage_priority = NULL;\n\tint max = 0, code;\n\tunsigned int i = 0;\n\tunsigned long *bit = NULL;\n\n\tfield->hidinput = hidinput;\n\n\tif (field->flags & HID_MAIN_ITEM_CONSTANT)\n\t\tgoto ignore;\n\n\t \n\tif (field->report_count < 1)\n\t\tgoto ignore;\n\n\t \n\tif (field->report_type == HID_OUTPUT_REPORT &&\n\t\t\t(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {\n\t\tgoto ignore;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(hidinput_usages_priorities); i++) {\n\t\tif (usage->hid == hidinput_usages_priorities[i].usage) {\n\t\t\tusage_priority = &hidinput_usages_priorities[i];\n\n\t\t\tfield->usages_priorities[usage_index] =\n\t\t\t\t(ARRAY_SIZE(hidinput_usages_priorities) - i) << 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (usage_priority && usage_priority->global)\n\t\tfield->usages_priorities[usage_index] |=\n\t\t\tusage_priority->slot_overwrite;\n\telse\n\t\tfield->usages_priorities[usage_index] |=\n\t\t\t(0xff - field->slot_idx) << 16;\n\n\tif (device->driver->input_mapping) {\n\t\tint ret = device->driver->input_mapping(device, hidinput, field,\n\t\t\t\tusage, &bit, &max);\n\t\tif (ret > 0)\n\t\t\tgoto mapped;\n\t\tif (ret < 0)\n\t\t\tgoto ignore;\n\t}\n\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\tcase HID_UP_UNDEFINED:\n\t\tgoto ignore;\n\n\tcase HID_UP_KEYBOARD:\n\t\tset_bit(EV_REP, input->evbit);\n\n\t\tif ((usage->hid & HID_USAGE) < 256) {\n\t\t\tif (!hid_keyboard[usage->hid & HID_USAGE]) goto ignore;\n\t\t\tmap_key_clear(hid_keyboard[usage->hid & HID_USAGE]);\n\t\t} else\n\t\t\tmap_key(KEY_UNKNOWN);\n\n\t\tbreak;\n\n\tcase HID_UP_BUTTON:\n\t\tcode = ((usage->hid - 1) & HID_USAGE);\n\n\t\tswitch (field->application) {\n\t\tcase HID_GD_MOUSE:\n\t\tcase HID_GD_POINTER:  code += BTN_MOUSE; break;\n\t\tcase HID_GD_JOYSTICK:\n\t\t\t\tif (code <= 0xf)\n\t\t\t\t\tcode += BTN_JOYSTICK;\n\t\t\t\telse\n\t\t\t\t\tcode += BTN_TRIGGER_HAPPY - 0x10;\n\t\t\t\tbreak;\n\t\tcase HID_GD_GAMEPAD:\n\t\t\t\tif (code <= 0xf)\n\t\t\t\t\tcode += BTN_GAMEPAD;\n\t\t\t\telse\n\t\t\t\t\tcode += BTN_TRIGGER_HAPPY - 0x10;\n\t\t\t\tbreak;\n\t\tcase HID_CP_CONSUMER_CONTROL:\n\t\t\t\tif (hidinput_field_in_collection(device, field,\n\t\t\t\t\t\t\t\t HID_COLLECTION_NAMED_ARRAY,\n\t\t\t\t\t\t\t\t HID_CP_PROGRAMMABLEBUTTONS)) {\n\t\t\t\t\tif (code <= 0x1d)\n\t\t\t\t\t\tcode += KEY_MACRO1;\n\t\t\t\t\telse\n\t\t\t\t\t\tcode += BTN_TRIGGER_HAPPY - 0x1e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tswitch (field->physical) {\n\t\t\tcase HID_GD_MOUSE:\n\t\t\tcase HID_GD_POINTER:  code += BTN_MOUSE; break;\n\t\t\tcase HID_GD_JOYSTICK: code += BTN_JOYSTICK; break;\n\t\t\tcase HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;\n\t\t\tdefault:              code += BTN_MISC;\n\t\t\t}\n\t\t}\n\n\t\tmap_key(code);\n\t\tbreak;\n\n\tcase HID_UP_SIMULATION:\n\t\tswitch (usage->hid & 0xffff) {\n\t\tcase 0xba: map_abs(ABS_RUDDER);   break;\n\t\tcase 0xbb: map_abs(ABS_THROTTLE); break;\n\t\tcase 0xc4: map_abs(ABS_GAS);      break;\n\t\tcase 0xc5: map_abs(ABS_BRAKE);    break;\n\t\tcase 0xc8: map_abs(ABS_WHEEL);    break;\n\t\tdefault:   goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_GENDESK:\n\t\tif ((usage->hid & 0xf0) == 0x80) {\t \n\t\t\tswitch (usage->hid & 0xf) {\n\t\t\tcase 0x1: map_key_clear(KEY_POWER);  break;\n\t\t\tcase 0x2: map_key_clear(KEY_SLEEP);  break;\n\t\t\tcase 0x3: map_key_clear(KEY_WAKEUP); break;\n\t\t\tcase 0x4: map_key_clear(KEY_CONTEXT_MENU); break;\n\t\t\tcase 0x5: map_key_clear(KEY_MENU); break;\n\t\t\tcase 0x6: map_key_clear(KEY_PROG1); break;\n\t\t\tcase 0x7: map_key_clear(KEY_HELP); break;\n\t\t\tcase 0x8: map_key_clear(KEY_EXIT); break;\n\t\t\tcase 0x9: map_key_clear(KEY_SELECT); break;\n\t\t\tcase 0xa: map_key_clear(KEY_RIGHT); break;\n\t\t\tcase 0xb: map_key_clear(KEY_LEFT); break;\n\t\t\tcase 0xc: map_key_clear(KEY_UP); break;\n\t\t\tcase 0xd: map_key_clear(KEY_DOWN); break;\n\t\t\tcase 0xe: map_key_clear(KEY_POWER2); break;\n\t\t\tcase 0xf: map_key_clear(KEY_RESTART); break;\n\t\t\tdefault: goto unknown;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((usage->hid & 0xf0) == 0xa0) {\t \n\t\t\tswitch (usage->hid & 0xf) {\n\t\t\tcase 0x9: map_key_clear(KEY_MICMUTE); break;\n\t\t\tdefault: goto ignore;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((usage->hid & 0xf0) == 0xb0) {\t \n\t\t\tswitch (usage->hid & 0xf) {\n\t\t\tcase 0x05: map_key_clear(KEY_SWITCHVIDEOMODE); break;\n\t\t\tdefault: goto ignore;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (field->application == HID_GD_SYSTEM_CONTROL)\n\t\t\tgoto ignore;\n\n\t\tif ((usage->hid & 0xf0) == 0x90) {\t \n\t\t\tswitch (usage->hid) {\n\t\t\tcase HID_GD_UP:\t   usage->hat_dir = 1; break;\n\t\t\tcase HID_GD_DOWN:  usage->hat_dir = 5; break;\n\t\t\tcase HID_GD_RIGHT: usage->hat_dir = 3; break;\n\t\t\tcase HID_GD_LEFT:  usage->hat_dir = 7; break;\n\t\t\tdefault: goto unknown;\n\t\t\t}\n\t\t\tif (field->dpad) {\n\t\t\t\tmap_abs(field->dpad);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\tmap_abs(ABS_HAT0X);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (usage->hid) {\n\t\t \n\t\tcase HID_GD_X: case HID_GD_Y: case HID_GD_Z:\n\t\tcase HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\t\t\tmap_rel(usage->hid & 0xf);\n\t\t\telse\n\t\t\t\tmap_abs_clear(usage->hid & 0xf);\n\t\t\tbreak;\n\n\t\tcase HID_GD_WHEEL:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE) {\n\t\t\t\tset_bit(REL_WHEEL, input->relbit);\n\t\t\t\tmap_rel(REL_WHEEL_HI_RES);\n\t\t\t} else {\n\t\t\t\tmap_abs(usage->hid & 0xf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HID_GD_SLIDER: case HID_GD_DIAL:\n\t\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\t\t\tmap_rel(usage->hid & 0xf);\n\t\t\telse\n\t\t\t\tmap_abs(usage->hid & 0xf);\n\t\t\tbreak;\n\n\t\tcase HID_GD_HATSWITCH:\n\t\t\tusage->hat_min = field->logical_minimum;\n\t\t\tusage->hat_max = field->logical_maximum;\n\t\t\tmap_abs(ABS_HAT0X);\n\t\t\tbreak;\n\n\t\tcase HID_GD_START:\tmap_key_clear(BTN_START);\tbreak;\n\t\tcase HID_GD_SELECT:\tmap_key_clear(BTN_SELECT);\tbreak;\n\n\t\tcase HID_GD_RFKILL_BTN:\n\t\t\t \n\t\t\tif (field->application == HID_GD_WIRELESS_RADIO_CTLS) {\n\t\t\t\tmap_key_clear(KEY_RFKILL);\n\t\t\t\t \n\t\t\t\tfield->flags |= HID_MAIN_ITEM_RELATIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto unknown;\n\n\t\tdefault: goto unknown;\n\t\t}\n\n\t\tbreak;\n\n\tcase HID_UP_LED:\n\t\tswitch (usage->hid & 0xffff) {\t\t       \n\t\tcase 0x01:  map_led (LED_NUML);     break;     \n\t\tcase 0x02:  map_led (LED_CAPSL);    break;     \n\t\tcase 0x03:  map_led (LED_SCROLLL);  break;     \n\t\tcase 0x04:  map_led (LED_COMPOSE);  break;     \n\t\tcase 0x05:  map_led (LED_KANA);     break;     \n\t\tcase 0x27:  map_led (LED_SLEEP);    break;     \n\t\tcase 0x4c:  map_led (LED_SUSPEND);  break;     \n\t\tcase 0x09:  map_led (LED_MUTE);     break;     \n\t\tcase 0x4b:  map_led (LED_MISC);     break;     \n\t\tcase 0x19:  map_led (LED_MAIL);     break;     \n\t\tcase 0x4d:  map_led (LED_CHARGING); break;     \n\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_DIGITIZER:\n\t\tif ((field->application & 0xff) == 0x01)  \n\t\t\t__set_bit(INPUT_PROP_POINTER, input->propbit);\n\t\telse if ((field->application & 0xff) == 0x02)  \n\t\t\t__set_bit(INPUT_PROP_DIRECT, input->propbit);\n\n\t\tswitch (usage->hid & 0xff) {\n\t\tcase 0x00:  \n\t\t\tgoto ignore;\n\n\t\tcase 0x30:  \n\t\t\tif (!test_bit(BTN_TOUCH, input->keybit)) {\n\t\t\t\tdevice->quirks |= HID_QUIRK_NOTOUCH;\n\t\t\t\tset_bit(EV_KEY, input->evbit);\n\t\t\t\tset_bit(BTN_TOUCH, input->keybit);\n\t\t\t}\n\t\t\tmap_abs_clear(ABS_PRESSURE);\n\t\t\tbreak;\n\n\t\tcase 0x32:  \n\t\t\tswitch (field->physical) {\n\t\t\tcase HID_DG_PUCK:\n\t\t\t\tmap_key(BTN_TOOL_MOUSE);\n\t\t\t\tbreak;\n\t\t\tcase HID_DG_FINGER:\n\t\t\t\tmap_key(BTN_TOOL_FINGER);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tif (!field->physical) {\n\t\t\t\t\tswitch (field->application) {\n\t\t\t\t\tcase HID_DG_TOUCHSCREEN:\n\t\t\t\t\tcase HID_DG_TOUCHPAD:\n\t\t\t\t\t\tmap_key_clear(BTN_TOOL_FINGER);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmap_key_clear(BTN_TOOL_PEN);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmap_key(BTN_TOOL_PEN);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x3b:  \n\t\t\thidinput_setup_battery(device, HID_INPUT_REPORT, field, false);\n\t\t\tusage->type = EV_PWR;\n\t\t\treturn;\n\n\t\tcase 0x3c:  \n\t\t\tdevice->quirks &= ~HID_QUIRK_NOINVERT;\n\t\t\tmap_key_clear(BTN_TOOL_RUBBER);\n\t\t\tbreak;\n\n\t\tcase 0x3d:  \n\t\t\tmap_abs_clear(ABS_TILT_X);\n\t\t\tbreak;\n\n\t\tcase 0x3e:  \n\t\t\tmap_abs_clear(ABS_TILT_Y);\n\t\t\tbreak;\n\n\t\tcase 0x33:  \n\t\tcase 0x42:  \n\t\tcase 0x43:  \n\t\t\tdevice->quirks &= ~HID_QUIRK_NOTOUCH;\n\t\t\tmap_key_clear(BTN_TOUCH);\n\t\t\tbreak;\n\n\t\tcase 0x44:  \n\t\t\tmap_key_clear(BTN_STYLUS);\n\t\t\tbreak;\n\n\t\tcase 0x45:  \n\t\t\t \n\t\t\tif (!test_bit(BTN_TOOL_RUBBER, input->keybit)) {\n\t\t\t\tdevice->quirks |= HID_QUIRK_NOINVERT;\n\t\t\t\tset_bit(BTN_TOOL_RUBBER, input->keybit);\n\t\t\t}\n\t\t\tmap_key_clear(BTN_TOUCH);\n\t\t\tbreak;\n\n\t\tcase 0x46:  \n\t\tcase 0x5a:  \n\t\t\tmap_key_clear(BTN_STYLUS2);\n\t\t\tbreak;\n\n\t\tcase 0x5b:  \n\t\tcase 0x6e:  \n\t\t\tmap_msc(MSC_SERIAL);\n\t\t\tbreak;\n\n\t\tdefault:  goto unknown;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_TELEPHONY:\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x2f: map_key_clear(KEY_MICMUTE);\t\tbreak;\n\t\tcase 0xb0: map_key_clear(KEY_NUMERIC_0);\tbreak;\n\t\tcase 0xb1: map_key_clear(KEY_NUMERIC_1);\tbreak;\n\t\tcase 0xb2: map_key_clear(KEY_NUMERIC_2);\tbreak;\n\t\tcase 0xb3: map_key_clear(KEY_NUMERIC_3);\tbreak;\n\t\tcase 0xb4: map_key_clear(KEY_NUMERIC_4);\tbreak;\n\t\tcase 0xb5: map_key_clear(KEY_NUMERIC_5);\tbreak;\n\t\tcase 0xb6: map_key_clear(KEY_NUMERIC_6);\tbreak;\n\t\tcase 0xb7: map_key_clear(KEY_NUMERIC_7);\tbreak;\n\t\tcase 0xb8: map_key_clear(KEY_NUMERIC_8);\tbreak;\n\t\tcase 0xb9: map_key_clear(KEY_NUMERIC_9);\tbreak;\n\t\tcase 0xba: map_key_clear(KEY_NUMERIC_STAR);\tbreak;\n\t\tcase 0xbb: map_key_clear(KEY_NUMERIC_POUND);\tbreak;\n\t\tcase 0xbc: map_key_clear(KEY_NUMERIC_A);\tbreak;\n\t\tcase 0xbd: map_key_clear(KEY_NUMERIC_B);\tbreak;\n\t\tcase 0xbe: map_key_clear(KEY_NUMERIC_C);\tbreak;\n\t\tcase 0xbf: map_key_clear(KEY_NUMERIC_D);\tbreak;\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_CONSUMER:\t \n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x000: goto ignore;\n\t\tcase 0x030: map_key_clear(KEY_POWER);\t\tbreak;\n\t\tcase 0x031: map_key_clear(KEY_RESTART);\t\tbreak;\n\t\tcase 0x032: map_key_clear(KEY_SLEEP);\t\tbreak;\n\t\tcase 0x034: map_key_clear(KEY_SLEEP);\t\tbreak;\n\t\tcase 0x035: map_key_clear(KEY_KBDILLUMTOGGLE);\tbreak;\n\t\tcase 0x036: map_key_clear(BTN_MISC);\t\tbreak;\n\n\t\tcase 0x040: map_key_clear(KEY_MENU);\t\tbreak;  \n\t\tcase 0x041: map_key_clear(KEY_SELECT);\t\tbreak;  \n\t\tcase 0x042: map_key_clear(KEY_UP);\t\tbreak;  \n\t\tcase 0x043: map_key_clear(KEY_DOWN);\t\tbreak;  \n\t\tcase 0x044: map_key_clear(KEY_LEFT);\t\tbreak;  \n\t\tcase 0x045: map_key_clear(KEY_RIGHT);\t\tbreak;  \n\t\tcase 0x046: map_key_clear(KEY_ESC);\t\tbreak;  \n\t\tcase 0x047: map_key_clear(KEY_KPPLUS);\t\tbreak;  \n\t\tcase 0x048: map_key_clear(KEY_KPMINUS);\t\tbreak;  \n\n\t\tcase 0x060: map_key_clear(KEY_INFO);\t\tbreak;  \n\t\tcase 0x061: map_key_clear(KEY_SUBTITLE);\tbreak;  \n\t\tcase 0x063: map_key_clear(KEY_VCR);\t\tbreak;  \n\t\tcase 0x065: map_key_clear(KEY_CAMERA);\t\tbreak;  \n\t\tcase 0x069: map_key_clear(KEY_RED);\t\tbreak;\n\t\tcase 0x06a: map_key_clear(KEY_GREEN);\t\tbreak;\n\t\tcase 0x06b: map_key_clear(KEY_BLUE);\t\tbreak;\n\t\tcase 0x06c: map_key_clear(KEY_YELLOW);\t\tbreak;\n\t\tcase 0x06d: map_key_clear(KEY_ASPECT_RATIO);\tbreak;\n\n\t\tcase 0x06f: map_key_clear(KEY_BRIGHTNESSUP);\t\tbreak;\n\t\tcase 0x070: map_key_clear(KEY_BRIGHTNESSDOWN);\t\tbreak;\n\t\tcase 0x072: map_key_clear(KEY_BRIGHTNESS_TOGGLE);\tbreak;\n\t\tcase 0x073: map_key_clear(KEY_BRIGHTNESS_MIN);\t\tbreak;\n\t\tcase 0x074: map_key_clear(KEY_BRIGHTNESS_MAX);\t\tbreak;\n\t\tcase 0x075: map_key_clear(KEY_BRIGHTNESS_AUTO);\t\tbreak;\n\n\t\tcase 0x076: map_key_clear(KEY_CAMERA_ACCESS_ENABLE);\tbreak;\n\t\tcase 0x077: map_key_clear(KEY_CAMERA_ACCESS_DISABLE);\tbreak;\n\t\tcase 0x078: map_key_clear(KEY_CAMERA_ACCESS_TOGGLE);\tbreak;\n\n\t\tcase 0x079: map_key_clear(KEY_KBDILLUMUP);\tbreak;\n\t\tcase 0x07a: map_key_clear(KEY_KBDILLUMDOWN);\tbreak;\n\t\tcase 0x07c: map_key_clear(KEY_KBDILLUMTOGGLE);\tbreak;\n\n\t\tcase 0x082: map_key_clear(KEY_VIDEO_NEXT);\tbreak;\n\t\tcase 0x083: map_key_clear(KEY_LAST);\t\tbreak;\n\t\tcase 0x084: map_key_clear(KEY_ENTER);\t\tbreak;\n\t\tcase 0x088: map_key_clear(KEY_PC);\t\tbreak;\n\t\tcase 0x089: map_key_clear(KEY_TV);\t\tbreak;\n\t\tcase 0x08a: map_key_clear(KEY_WWW);\t\tbreak;\n\t\tcase 0x08b: map_key_clear(KEY_DVD);\t\tbreak;\n\t\tcase 0x08c: map_key_clear(KEY_PHONE);\t\tbreak;\n\t\tcase 0x08d: map_key_clear(KEY_PROGRAM);\t\tbreak;\n\t\tcase 0x08e: map_key_clear(KEY_VIDEOPHONE);\tbreak;\n\t\tcase 0x08f: map_key_clear(KEY_GAMES);\t\tbreak;\n\t\tcase 0x090: map_key_clear(KEY_MEMO);\t\tbreak;\n\t\tcase 0x091: map_key_clear(KEY_CD);\t\tbreak;\n\t\tcase 0x092: map_key_clear(KEY_VCR);\t\tbreak;\n\t\tcase 0x093: map_key_clear(KEY_TUNER);\t\tbreak;\n\t\tcase 0x094: map_key_clear(KEY_EXIT);\t\tbreak;\n\t\tcase 0x095: map_key_clear(KEY_HELP);\t\tbreak;\n\t\tcase 0x096: map_key_clear(KEY_TAPE);\t\tbreak;\n\t\tcase 0x097: map_key_clear(KEY_TV2);\t\tbreak;\n\t\tcase 0x098: map_key_clear(KEY_SAT);\t\tbreak;\n\t\tcase 0x09a: map_key_clear(KEY_PVR);\t\tbreak;\n\n\t\tcase 0x09c: map_key_clear(KEY_CHANNELUP);\tbreak;\n\t\tcase 0x09d: map_key_clear(KEY_CHANNELDOWN);\tbreak;\n\t\tcase 0x0a0: map_key_clear(KEY_VCR2);\t\tbreak;\n\n\t\tcase 0x0b0: map_key_clear(KEY_PLAY);\t\tbreak;\n\t\tcase 0x0b1: map_key_clear(KEY_PAUSE);\t\tbreak;\n\t\tcase 0x0b2: map_key_clear(KEY_RECORD);\t\tbreak;\n\t\tcase 0x0b3: map_key_clear(KEY_FASTFORWARD);\tbreak;\n\t\tcase 0x0b4: map_key_clear(KEY_REWIND);\t\tbreak;\n\t\tcase 0x0b5: map_key_clear(KEY_NEXTSONG);\tbreak;\n\t\tcase 0x0b6: map_key_clear(KEY_PREVIOUSSONG);\tbreak;\n\t\tcase 0x0b7: map_key_clear(KEY_STOPCD);\t\tbreak;\n\t\tcase 0x0b8: map_key_clear(KEY_EJECTCD);\t\tbreak;\n\t\tcase 0x0bc: map_key_clear(KEY_MEDIA_REPEAT);\tbreak;\n\t\tcase 0x0b9: map_key_clear(KEY_SHUFFLE);\t\tbreak;\n\t\tcase 0x0bf: map_key_clear(KEY_SLOW);\t\tbreak;\n\n\t\tcase 0x0cd: map_key_clear(KEY_PLAYPAUSE);\tbreak;\n\t\tcase 0x0cf: map_key_clear(KEY_VOICECOMMAND);\tbreak;\n\n\t\tcase 0x0d8: map_key_clear(KEY_DICTATE);\t\tbreak;\n\t\tcase 0x0d9: map_key_clear(KEY_EMOJI_PICKER);\tbreak;\n\n\t\tcase 0x0e0: map_abs_clear(ABS_VOLUME);\t\tbreak;\n\t\tcase 0x0e2: map_key_clear(KEY_MUTE);\t\tbreak;\n\t\tcase 0x0e5: map_key_clear(KEY_BASSBOOST);\tbreak;\n\t\tcase 0x0e9: map_key_clear(KEY_VOLUMEUP);\tbreak;\n\t\tcase 0x0ea: map_key_clear(KEY_VOLUMEDOWN);\tbreak;\n\t\tcase 0x0f5: map_key_clear(KEY_SLOW);\t\tbreak;\n\n\t\tcase 0x181: map_key_clear(KEY_BUTTONCONFIG);\tbreak;\n\t\tcase 0x182: map_key_clear(KEY_BOOKMARKS);\tbreak;\n\t\tcase 0x183: map_key_clear(KEY_CONFIG);\t\tbreak;\n\t\tcase 0x184: map_key_clear(KEY_WORDPROCESSOR);\tbreak;\n\t\tcase 0x185: map_key_clear(KEY_EDITOR);\t\tbreak;\n\t\tcase 0x186: map_key_clear(KEY_SPREADSHEET);\tbreak;\n\t\tcase 0x187: map_key_clear(KEY_GRAPHICSEDITOR);\tbreak;\n\t\tcase 0x188: map_key_clear(KEY_PRESENTATION);\tbreak;\n\t\tcase 0x189: map_key_clear(KEY_DATABASE);\tbreak;\n\t\tcase 0x18a: map_key_clear(KEY_MAIL);\t\tbreak;\n\t\tcase 0x18b: map_key_clear(KEY_NEWS);\t\tbreak;\n\t\tcase 0x18c: map_key_clear(KEY_VOICEMAIL);\tbreak;\n\t\tcase 0x18d: map_key_clear(KEY_ADDRESSBOOK);\tbreak;\n\t\tcase 0x18e: map_key_clear(KEY_CALENDAR);\tbreak;\n\t\tcase 0x18f: map_key_clear(KEY_TASKMANAGER);\tbreak;\n\t\tcase 0x190: map_key_clear(KEY_JOURNAL);\t\tbreak;\n\t\tcase 0x191: map_key_clear(KEY_FINANCE);\t\tbreak;\n\t\tcase 0x192: map_key_clear(KEY_CALC);\t\tbreak;\n\t\tcase 0x193: map_key_clear(KEY_PLAYER);\t\tbreak;\n\t\tcase 0x194: map_key_clear(KEY_FILE);\t\tbreak;\n\t\tcase 0x196: map_key_clear(KEY_WWW);\t\tbreak;\n\t\tcase 0x199: map_key_clear(KEY_CHAT);\t\tbreak;\n\t\tcase 0x19c: map_key_clear(KEY_LOGOFF);\t\tbreak;\n\t\tcase 0x19e: map_key_clear(KEY_COFFEE);\t\tbreak;\n\t\tcase 0x19f: map_key_clear(KEY_CONTROLPANEL);\t\tbreak;\n\t\tcase 0x1a2: map_key_clear(KEY_APPSELECT);\t\tbreak;\n\t\tcase 0x1a3: map_key_clear(KEY_NEXT);\t\tbreak;\n\t\tcase 0x1a4: map_key_clear(KEY_PREVIOUS);\tbreak;\n\t\tcase 0x1a6: map_key_clear(KEY_HELP);\t\tbreak;\n\t\tcase 0x1a7: map_key_clear(KEY_DOCUMENTS);\tbreak;\n\t\tcase 0x1ab: map_key_clear(KEY_SPELLCHECK);\tbreak;\n\t\tcase 0x1ae: map_key_clear(KEY_KEYBOARD);\tbreak;\n\t\tcase 0x1b1: map_key_clear(KEY_SCREENSAVER);\t\tbreak;\n\t\tcase 0x1b4: map_key_clear(KEY_FILE);\t\tbreak;\n\t\tcase 0x1b6: map_key_clear(KEY_IMAGES);\t\tbreak;\n\t\tcase 0x1b7: map_key_clear(KEY_AUDIO);\t\tbreak;\n\t\tcase 0x1b8: map_key_clear(KEY_VIDEO);\t\tbreak;\n\t\tcase 0x1bc: map_key_clear(KEY_MESSENGER);\tbreak;\n\t\tcase 0x1bd: map_key_clear(KEY_INFO);\t\tbreak;\n\t\tcase 0x1cb: map_key_clear(KEY_ASSISTANT);\tbreak;\n\t\tcase 0x201: map_key_clear(KEY_NEW);\t\tbreak;\n\t\tcase 0x202: map_key_clear(KEY_OPEN);\t\tbreak;\n\t\tcase 0x203: map_key_clear(KEY_CLOSE);\t\tbreak;\n\t\tcase 0x204: map_key_clear(KEY_EXIT);\t\tbreak;\n\t\tcase 0x207: map_key_clear(KEY_SAVE);\t\tbreak;\n\t\tcase 0x208: map_key_clear(KEY_PRINT);\t\tbreak;\n\t\tcase 0x209: map_key_clear(KEY_PROPS);\t\tbreak;\n\t\tcase 0x21a: map_key_clear(KEY_UNDO);\t\tbreak;\n\t\tcase 0x21b: map_key_clear(KEY_COPY);\t\tbreak;\n\t\tcase 0x21c: map_key_clear(KEY_CUT);\t\tbreak;\n\t\tcase 0x21d: map_key_clear(KEY_PASTE);\t\tbreak;\n\t\tcase 0x21f: map_key_clear(KEY_FIND);\t\tbreak;\n\t\tcase 0x221: map_key_clear(KEY_SEARCH);\t\tbreak;\n\t\tcase 0x222: map_key_clear(KEY_GOTO);\t\tbreak;\n\t\tcase 0x223: map_key_clear(KEY_HOMEPAGE);\tbreak;\n\t\tcase 0x224: map_key_clear(KEY_BACK);\t\tbreak;\n\t\tcase 0x225: map_key_clear(KEY_FORWARD);\t\tbreak;\n\t\tcase 0x226: map_key_clear(KEY_STOP);\t\tbreak;\n\t\tcase 0x227: map_key_clear(KEY_REFRESH);\t\tbreak;\n\t\tcase 0x22a: map_key_clear(KEY_BOOKMARKS);\tbreak;\n\t\tcase 0x22d: map_key_clear(KEY_ZOOMIN);\t\tbreak;\n\t\tcase 0x22e: map_key_clear(KEY_ZOOMOUT);\t\tbreak;\n\t\tcase 0x22f: map_key_clear(KEY_ZOOMRESET);\tbreak;\n\t\tcase 0x232: map_key_clear(KEY_FULL_SCREEN);\tbreak;\n\t\tcase 0x233: map_key_clear(KEY_SCROLLUP);\tbreak;\n\t\tcase 0x234: map_key_clear(KEY_SCROLLDOWN);\tbreak;\n\t\tcase 0x238:  \n\t\t\tset_bit(REL_HWHEEL, input->relbit);\n\t\t\tmap_rel(REL_HWHEEL_HI_RES);\n\t\t\tbreak;\n\t\tcase 0x23d: map_key_clear(KEY_EDIT);\t\tbreak;\n\t\tcase 0x25f: map_key_clear(KEY_CANCEL);\t\tbreak;\n\t\tcase 0x269: map_key_clear(KEY_INSERT);\t\tbreak;\n\t\tcase 0x26a: map_key_clear(KEY_DELETE);\t\tbreak;\n\t\tcase 0x279: map_key_clear(KEY_REDO);\t\tbreak;\n\n\t\tcase 0x289: map_key_clear(KEY_REPLY);\t\tbreak;\n\t\tcase 0x28b: map_key_clear(KEY_FORWARDMAIL);\tbreak;\n\t\tcase 0x28c: map_key_clear(KEY_SEND);\t\tbreak;\n\n\t\tcase 0x29d: map_key_clear(KEY_KBD_LAYOUT_NEXT);\tbreak;\n\n\t\tcase 0x2a2: map_key_clear(KEY_ALL_APPLICATIONS);\tbreak;\n\n\t\tcase 0x2c7: map_key_clear(KEY_KBDINPUTASSIST_PREV);\t\tbreak;\n\t\tcase 0x2c8: map_key_clear(KEY_KBDINPUTASSIST_NEXT);\t\tbreak;\n\t\tcase 0x2c9: map_key_clear(KEY_KBDINPUTASSIST_PREVGROUP);\t\tbreak;\n\t\tcase 0x2ca: map_key_clear(KEY_KBDINPUTASSIST_NEXTGROUP);\t\tbreak;\n\t\tcase 0x2cb: map_key_clear(KEY_KBDINPUTASSIST_ACCEPT);\tbreak;\n\t\tcase 0x2cc: map_key_clear(KEY_KBDINPUTASSIST_CANCEL);\tbreak;\n\n\t\tcase 0x29f: map_key_clear(KEY_SCALE);\t\tbreak;\n\n\t\tdefault: map_key_clear(KEY_UNKNOWN);\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_GENDEVCTRLS:\n\t\tswitch (usage->hid) {\n\t\tcase HID_DC_BATTERYSTRENGTH:\n\t\t\thidinput_setup_battery(device, HID_INPUT_REPORT, field, false);\n\t\t\tusage->type = EV_PWR;\n\t\t\treturn;\n\t\t}\n\t\tgoto unknown;\n\n\tcase HID_UP_BATTERY:\n\t\tswitch (usage->hid) {\n\t\tcase HID_BAT_ABSOLUTESTATEOFCHARGE:\n\t\t\thidinput_setup_battery(device, HID_INPUT_REPORT, field, true);\n\t\t\tusage->type = EV_PWR;\n\t\t\treturn;\n\t\tcase HID_BAT_CHARGING:\n\t\t\tusage->type = EV_PWR;\n\t\t\treturn;\n\t\t}\n\t\tgoto unknown;\n\tcase HID_UP_CAMERA:\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x020:\n\t\t\tmap_key_clear(KEY_CAMERA_FOCUS);\tbreak;\n\t\tcase 0x021:\n\t\t\tmap_key_clear(KEY_CAMERA);\t\tbreak;\n\t\tdefault:\n\t\t\tgoto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_HPVENDOR:\t \n\t\tset_bit(EV_REP, input->evbit);\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x021: map_key_clear(KEY_PRINT);           break;\n\t\tcase 0x070: map_key_clear(KEY_HP);\t\tbreak;\n\t\tcase 0x071: map_key_clear(KEY_CAMERA);\t\tbreak;\n\t\tcase 0x072: map_key_clear(KEY_SOUND);\t\tbreak;\n\t\tcase 0x073: map_key_clear(KEY_QUESTION);\tbreak;\n\t\tcase 0x080: map_key_clear(KEY_EMAIL);\t\tbreak;\n\t\tcase 0x081: map_key_clear(KEY_CHAT);\t\tbreak;\n\t\tcase 0x082: map_key_clear(KEY_SEARCH);\t\tbreak;\n\t\tcase 0x083: map_key_clear(KEY_CONNECT);\t        break;\n\t\tcase 0x084: map_key_clear(KEY_FINANCE);\t\tbreak;\n\t\tcase 0x085: map_key_clear(KEY_SPORT);\t\tbreak;\n\t\tcase 0x086: map_key_clear(KEY_SHOP);\t        break;\n\t\tdefault:    goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_HPVENDOR2:\n\t\tset_bit(EV_REP, input->evbit);\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x001: map_key_clear(KEY_MICMUTE);\t\tbreak;\n\t\tcase 0x003: map_key_clear(KEY_BRIGHTNESSDOWN);\tbreak;\n\t\tcase 0x004: map_key_clear(KEY_BRIGHTNESSUP);\tbreak;\n\t\tdefault:    goto ignore;\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_MSVENDOR:\n\t\tgoto ignore;\n\n\tcase HID_UP_CUSTOM:  \n\t\tset_bit(EV_REP, input->evbit);\n\t\tgoto ignore;\n\n\tcase HID_UP_LOGIVENDOR:\n\t\t \n\tcase HID_UP_LOGIVENDOR2:\n\t\t \n\tcase HID_UP_LOGIVENDOR3:\n\t\tgoto ignore;\n\n\tcase HID_UP_PID:\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0xa4: map_key_clear(BTN_DEAD);\tbreak;\n\t\tdefault: goto ignore;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\tunknown:\n\t\tif (field->report_size == 1) {\n\t\t\tif (field->report->type == HID_OUTPUT_REPORT) {\n\t\t\t\tmap_led(LED_MISC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap_key(BTN_MISC);\n\t\t\tbreak;\n\t\t}\n\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE) {\n\t\t\tmap_rel(REL_MISC);\n\t\t\tbreak;\n\t\t}\n\t\tmap_abs(ABS_MISC);\n\t\tbreak;\n\t}\n\nmapped:\n\t \n\tif (!bit)\n\t\treturn;\n\n\tif (device->driver->input_mapped &&\n\t    device->driver->input_mapped(device, hidinput, field, usage,\n\t\t\t\t\t &bit, &max) < 0) {\n\t\t \n\t\treturn;\n\t}\n\n\tset_bit(usage->type, input->evbit);\n\n\t \n\twhile (usage->code <= max && test_and_set_bit(usage->code, bit)) {\n\t\tif (device->quirks & HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE) {\n\t\t\tusage->code = find_next_zero_bit(bit,\n\t\t\t\t\t\t\t max + 1,\n\t\t\t\t\t\t\t usage->code);\n\t\t} else {\n\t\t\tdevice->status |= HID_STAT_DUP_DETECTED;\n\t\t\tgoto ignore;\n\t\t}\n\t}\n\n\tif (usage->code > max)\n\t\tgoto ignore;\n\n\tif (usage->type == EV_ABS) {\n\n\t\tint a = field->logical_minimum;\n\t\tint b = field->logical_maximum;\n\n\t\tif ((device->quirks & HID_QUIRK_BADPAD) && (usage->code == ABS_X || usage->code == ABS_Y)) {\n\t\t\ta = field->logical_minimum = 0;\n\t\t\tb = field->logical_maximum = 255;\n\t\t}\n\n\t\tif (field->application == HID_GD_GAMEPAD || field->application == HID_GD_JOYSTICK)\n\t\t\tinput_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);\n\t\telse\tinput_set_abs_params(input, usage->code, a, b, 0, 0);\n\n\t\tinput_abs_set_res(input, usage->code,\n\t\t\t\t  hidinput_calc_abs_res(field, usage->code));\n\n\t\t \n\t\tif (usage->code == ABS_MT_POSITION_X && input->hint_events_per_packet == 0)\n\t\t\tinput_set_events_per_packet(input, 60);\n\t}\n\n\tif (usage->type == EV_ABS &&\n\t    (usage->hat_min < usage->hat_max || usage->hat_dir)) {\n\t\tint i;\n\t\tfor (i = usage->code; i < usage->code + 2 && i <= max; i++) {\n\t\t\tinput_set_abs_params(input, i, -1, 1, 0, 0);\n\t\t\tset_bit(i, input->absbit);\n\t\t}\n\t\tif (usage->hat_dir && !field->dpad)\n\t\t\tfield->dpad = usage->code;\n\t}\n\n\t \n\tif ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&\n\t\t\t(usage->code == ABS_VOLUME)) {\n\t\tset_bit(KEY_VOLUMEUP, input->keybit);\n\t\tset_bit(KEY_VOLUMEDOWN, input->keybit);\n\t}\n\n\tif (usage->type == EV_KEY) {\n\t\tset_bit(EV_MSC, input->evbit);\n\t\tset_bit(MSC_SCAN, input->mscbit);\n\t}\n\n\treturn;\n\nignore:\n\tusage->type = 0;\n\tusage->code = 0;\n}\n\nstatic void hidinput_handle_scroll(struct hid_usage *usage,\n\t\t\t\t   struct input_dev *input,\n\t\t\t\t   __s32 value)\n{\n\tint code;\n\tint hi_res, lo_res;\n\n\tif (value == 0)\n\t\treturn;\n\n\tif (usage->code == REL_WHEEL_HI_RES)\n\t\tcode = REL_WHEEL;\n\telse\n\t\tcode = REL_HWHEEL;\n\n\t \n\thi_res = value * 120/usage->resolution_multiplier;\n\n\tusage->wheel_accumulated += hi_res;\n\tlo_res = usage->wheel_accumulated/120;\n\tif (lo_res)\n\t\tusage->wheel_accumulated -= lo_res * 120;\n\n\tinput_event(input, EV_REL, code, lo_res);\n\tinput_event(input, EV_REL, usage->code, hi_res);\n}\n\nstatic void hid_report_release_tool(struct hid_report *report, struct input_dev *input,\n\t\t\t\t    unsigned int tool)\n{\n\t \n\tif (!test_bit(tool, input->key))\n\t\treturn;\n\n\t \n\tinput_event(input, EV_KEY, BTN_TOUCH, 0);\n\tinput_event(input, EV_KEY, tool, 0);\n\tinput_event(input, EV_SYN, SYN_REPORT, 0);\n\n\treport->tool = 0;\n}\n\nstatic void hid_report_set_tool(struct hid_report *report, struct input_dev *input,\n\t\t\t\tunsigned int new_tool)\n{\n\tif (report->tool != new_tool)\n\t\thid_report_release_tool(report, input, report->tool);\n\n\tinput_event(input, EV_KEY, new_tool, 1);\n\treport->tool = new_tool;\n}\n\nvoid hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value)\n{\n\tstruct input_dev *input;\n\tstruct hid_report *report = field->report;\n\tunsigned *quirks = &hid->quirks;\n\n\tif (!usage->type)\n\t\treturn;\n\n\tif (usage->type == EV_PWR) {\n\t\tbool handled = hidinput_set_battery_charge_status(hid, usage->hid, value);\n\n\t\tif (!handled)\n\t\t\thidinput_update_battery(hid, value);\n\n\t\treturn;\n\t}\n\n\tif (!field->hidinput)\n\t\treturn;\n\n\tinput = field->hidinput->input;\n\n\tif (usage->hat_min < usage->hat_max || usage->hat_dir) {\n\t\tint hat_dir = usage->hat_dir;\n\t\tif (!hat_dir)\n\t\t\that_dir = (value - usage->hat_min) * 8 / (usage->hat_max - usage->hat_min + 1) + 1;\n\t\tif (hat_dir < 0 || hat_dir > 8) hat_dir = 0;\n\t\tinput_event(input, usage->type, usage->code    , hid_hat_to_axis[hat_dir].x);\n\t\tinput_event(input, usage->type, usage->code + 1, hid_hat_to_axis[hat_dir].y);\n\t\treturn;\n\t}\n\n\t \n\tif ((field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t    field->logical_minimum < field->logical_maximum) {\n\t\tif (field->flags & HID_MAIN_ITEM_NULL_STATE &&\n\t\t    (value < field->logical_minimum ||\n\t\t     value > field->logical_maximum)) {\n\t\t\tdbg_hid(\"Ignoring out-of-range value %x\\n\", value);\n\t\t\treturn;\n\t\t}\n\t\tvalue = clamp(value,\n\t\t\t      field->logical_minimum,\n\t\t\t      field->logical_maximum);\n\t}\n\n\tswitch (usage->hid) {\n\tcase HID_DG_ERASER:\n\t\treport->tool_active |= !!value;\n\n\t\t \n\t\tif (value)\n\t\t\thid_report_set_tool(report, input, BTN_TOOL_RUBBER);\n\t\telse if (report->tool != BTN_TOOL_RUBBER)\n\t\t\t \n\t\t\treturn;\n\t\telse if (*quirks & HID_QUIRK_NOINVERT &&\n\t\t\t !test_bit(BTN_TOUCH, input->key)) {\n\t\t\t \n\t\t\thid_report_release_tool(report, input, BTN_TOOL_RUBBER);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tbreak;\n\n\tcase HID_DG_INVERT:\n\t\treport->tool_active |= !!value;\n\n\t\t \n\t\tif (value)\n\t\t\thid_report_set_tool(report, input, BTN_TOOL_RUBBER);\n\t\telse if (!report->tool_active)\n\t\t\t \n\t\t\thid_report_release_tool(report, input, BTN_TOOL_RUBBER);\n\n\t\t \n\t\treturn;\n\n\tcase HID_DG_INRANGE:\n\t\treport->tool_active |= !!value;\n\n\t\tif (report->tool_active) {\n\t\t\t \n\t\t\tif (!report->tool)\n\t\t\t\treport->tool = usage->code;\n\n\t\t\t \n\t\t\thid_report_set_tool(report, input, report->tool);\n\t\t} else {\n\t\t\thid_report_release_tool(report, input, usage->code);\n\t\t}\n\n\t\t \n\t\treport->tool_active = false;\n\n\t\t \n\t\treturn;\n\n\tcase HID_DG_TIPSWITCH:\n\t\treport->tool_active |= !!value;\n\n\t\t \n\t\tif (report->tool == BTN_TOOL_RUBBER)\n\t\t\treturn;\n\n\t\tbreak;\n\n\tcase HID_DG_TIPPRESSURE:\n\t\tif (*quirks & HID_QUIRK_NOTOUCH) {\n\t\t\tint a = field->logical_minimum;\n\t\t\tint b = field->logical_maximum;\n\n\t\t\tif (value > a + ((b - a) >> 3)) {\n\t\t\t\tinput_event(input, EV_KEY, BTN_TOUCH, 1);\n\t\t\t\treport->tool_active = true;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase HID_UP_PID | 0x83UL:  \n\t\tdbg_hid(\"Maximum Effects - %d\\n\",value);\n\t\treturn;\n\n\tcase HID_UP_PID | 0x7fUL:\n\t\tdbg_hid(\"PID Pool Report\\n\");\n\t\treturn;\n\t}\n\n\tswitch (usage->type) {\n\tcase EV_KEY:\n\t\tif (usage->code == 0)  \n\t\t\treturn;\n\t\tbreak;\n\n\tcase EV_REL:\n\t\tif (usage->code == REL_WHEEL_HI_RES ||\n\t\t    usage->code == REL_HWHEEL_HI_RES) {\n\t\t\thidinput_handle_scroll(usage, input, value);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase EV_ABS:\n\t\tif ((field->flags & HID_MAIN_ITEM_RELATIVE) &&\n\t\t    usage->code == ABS_VOLUME) {\n\t\t\tint count = abs(value);\n\t\t\tint direction = value > 0 ? KEY_VOLUMEUP : KEY_VOLUMEDOWN;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tinput_event(input, EV_KEY, direction, 1);\n\t\t\t\tinput_sync(input);\n\t\t\t\tinput_event(input, EV_KEY, direction, 0);\n\t\t\t\tinput_sync(input);\n\t\t\t}\n\t\t\treturn;\n\n\t\t} else if (((*quirks & HID_QUIRK_X_INVERT) && usage->code == ABS_X) ||\n\t\t\t   ((*quirks & HID_QUIRK_Y_INVERT) && usage->code == ABS_Y))\n\t\t\tvalue = field->logical_maximum - value;\n\t\tbreak;\n\t}\n\n\t \n\tif (!(field->flags & (HID_MAIN_ITEM_RELATIVE |\n\t                      HID_MAIN_ITEM_BUFFERED_BYTE)) &&\n\t\t\t      (field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t    usage->usage_index < field->maxusage &&\n\t    value == field->value[usage->usage_index])\n\t\treturn;\n\n\t \n\tif (usage->type == EV_KEY &&\n\t    (!test_bit(usage->code, input->key)) == value)\n\t\tinput_event(input, EV_MSC, MSC_SCAN, usage->hid);\n\n\tinput_event(input, usage->type, usage->code, value);\n\n\tif ((field->flags & HID_MAIN_ITEM_RELATIVE) &&\n\t    usage->type == EV_KEY && value) {\n\t\tinput_sync(input);\n\t\tinput_event(input, usage->type, usage->code, 0);\n\t}\n}\n\nvoid hidinput_report_event(struct hid_device *hid, struct hid_report *report)\n{\n\tstruct hid_input *hidinput;\n\n\tif (hid->quirks & HID_QUIRK_NO_INPUT_SYNC)\n\t\treturn;\n\n\tlist_for_each_entry(hidinput, &hid->inputs, list)\n\t\tinput_sync(hidinput->input);\n}\nEXPORT_SYMBOL_GPL(hidinput_report_event);\n\nstatic int hidinput_find_field(struct hid_device *hid, unsigned int type,\n\t\t\t       unsigned int code, struct hid_field **field)\n{\n\tstruct hid_report *report;\n\tint i, j;\n\n\tlist_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\t*field = report->field[i];\n\t\t\tfor (j = 0; j < (*field)->maxusage; j++)\n\t\t\t\tif ((*field)->usage[j].type == type && (*field)->usage[j].code == code)\n\t\t\t\t\treturn j;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstruct hid_field *hidinput_get_led_field(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i, j;\n\n\tlist_for_each_entry(report,\n\t\t\t    &hid->report_enum[HID_OUTPUT_REPORT].report_list,\n\t\t\t    list) {\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\tfield = report->field[i];\n\t\t\tfor (j = 0; j < field->maxusage; j++)\n\t\t\t\tif (field->usage[j].type == EV_LED)\n\t\t\t\t\treturn field;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(hidinput_get_led_field);\n\nunsigned int hidinput_count_leds(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i, j;\n\tunsigned int count = 0;\n\n\tlist_for_each_entry(report,\n\t\t\t    &hid->report_enum[HID_OUTPUT_REPORT].report_list,\n\t\t\t    list) {\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\tfield = report->field[i];\n\t\t\tfor (j = 0; j < field->maxusage; j++)\n\t\t\t\tif (field->usage[j].type == EV_LED &&\n\t\t\t\t    field->value[j])\n\t\t\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(hidinput_count_leds);\n\nstatic void hidinput_led_worker(struct work_struct *work)\n{\n\tstruct hid_device *hid = container_of(work, struct hid_device,\n\t\t\t\t\t      led_work);\n\tstruct hid_field *field;\n\tstruct hid_report *report;\n\tint ret;\n\tu32 len;\n\t__u8 *buf;\n\n\tfield = hidinput_get_led_field(hid);\n\tif (!field)\n\t\treturn;\n\n\t \n\n\treport = field->report;\n\n\t \n\tif (hid->ll_driver->request)\n\t\treturn hid->ll_driver->request(hid, report, HID_REQ_SET_REPORT);\n\n\t \n\tlen = hid_report_len(report);\n\tbuf = hid_alloc_report_buf(report, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\thid_output_report(report, buf);\n\t \n\tret = hid_hw_output_report(hid, buf, len);\n\tif (ret == -ENOSYS)\n\t\thid_hw_raw_request(hid, report->id, buf, len, HID_OUTPUT_REPORT,\n\t\t\t\tHID_REQ_SET_REPORT);\n\tkfree(buf);\n}\n\nstatic int hidinput_input_event(struct input_dev *dev, unsigned int type,\n\t\t\t\tunsigned int code, int value)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct hid_field *field;\n\tint offset;\n\n\tif (type == EV_FF)\n\t\treturn input_ff_event(dev, type, code, value);\n\n\tif (type != EV_LED)\n\t\treturn -1;\n\n\tif ((offset = hidinput_find_field(hid, type, code, &field)) == -1) {\n\t\thid_warn(dev, \"event field not found\\n\");\n\t\treturn -1;\n\t}\n\n\thid_set_field(field, offset, value);\n\n\tschedule_work(&hid->led_work);\n\treturn 0;\n}\n\nstatic int hidinput_open(struct input_dev *dev)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\n\treturn hid_hw_open(hid);\n}\n\nstatic void hidinput_close(struct input_dev *dev)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\n\thid_hw_close(hid);\n}\n\nstatic bool __hidinput_change_resolution_multipliers(struct hid_device *hid,\n\t\tstruct hid_report *report, bool use_logical_max)\n{\n\tstruct hid_usage *usage;\n\tbool update_needed = false;\n\tbool get_report_completed = false;\n\tint i, j;\n\n\tif (report->maxfield == 0)\n\t\treturn false;\n\n\tfor (i = 0; i < report->maxfield; i++) {\n\t\t__s32 value = use_logical_max ?\n\t\t\t      report->field[i]->logical_maximum :\n\t\t\t      report->field[i]->logical_minimum;\n\n\t\t \n\t\tif (report->field[i]->report_count != 1)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < report->field[i]->maxusage; j++) {\n\t\t\tusage = &report->field[i]->usage[j];\n\n\t\t\tif (usage->hid != HID_GD_RESOLUTION_MULTIPLIER)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!get_report_completed && report->maxfield > 1) {\n\t\t\t\tif (hid->quirks & HID_QUIRK_NO_INIT_REPORTS)\n\t\t\t\t\treturn update_needed;\n\n\t\t\t\thid_hw_request(hid, report, HID_REQ_GET_REPORT);\n\t\t\t\thid_hw_wait(hid);\n\t\t\t\tget_report_completed = true;\n\t\t\t}\n\n\t\t\treport->field[i]->value[j] = value;\n\t\t\tupdate_needed = true;\n\t\t}\n\t}\n\n\treturn update_needed;\n}\n\nstatic void hidinput_change_resolution_multipliers(struct hid_device *hid)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tint ret;\n\n\trep_enum = &hid->report_enum[HID_FEATURE_REPORT];\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tbool update_needed = __hidinput_change_resolution_multipliers(hid,\n\t\t\t\t\t\t\t\t     rep, true);\n\n\t\tif (update_needed) {\n\t\t\tret = __hid_request(hid, rep, HID_REQ_SET_REPORT);\n\t\t\tif (ret) {\n\t\t\t\t__hidinput_change_resolution_multipliers(hid,\n\t\t\t\t\t\t\t\t    rep, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\thid_setup_resolution_multiplier(hid);\n}\n\nstatic void report_features(struct hid_device *hid)\n{\n\tstruct hid_driver *drv = hid->driver;\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct hid_usage *usage;\n\tint i, j;\n\n\trep_enum = &hid->report_enum[HID_FEATURE_REPORT];\n\tlist_for_each_entry(rep, &rep_enum->report_list, list)\n\t\tfor (i = 0; i < rep->maxfield; i++) {\n\t\t\t \n\t\t\tif (rep->field[i]->report_count < 1)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < rep->field[i]->maxusage; j++) {\n\t\t\t\tusage = &rep->field[i]->usage[j];\n\n\t\t\t\t \n\t\t\t\tif (usage->hid == HID_DC_BATTERYSTRENGTH)\n\t\t\t\t\thidinput_setup_battery(hid, HID_FEATURE_REPORT,\n\t\t\t\t\t\t\t       rep->field[i], false);\n\n\t\t\t\tif (drv->feature_mapping)\n\t\t\t\t\tdrv->feature_mapping(hid, rep->field[i], usage);\n\t\t\t}\n\t\t}\n}\n\nstatic struct hid_input *hidinput_allocate(struct hid_device *hid,\n\t\t\t\t\t   unsigned int application)\n{\n\tstruct hid_input *hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);\n\tstruct input_dev *input_dev = input_allocate_device();\n\tconst char *suffix = NULL;\n\tsize_t suffix_len, name_len;\n\n\tif (!hidinput || !input_dev)\n\t\tgoto fail;\n\n\tif ((hid->quirks & HID_QUIRK_INPUT_PER_APP) &&\n\t    hid->maxapplication > 1) {\n\t\tswitch (application) {\n\t\tcase HID_GD_KEYBOARD:\n\t\t\tsuffix = \"Keyboard\";\n\t\t\tbreak;\n\t\tcase HID_GD_KEYPAD:\n\t\t\tsuffix = \"Keypad\";\n\t\t\tbreak;\n\t\tcase HID_GD_MOUSE:\n\t\t\tsuffix = \"Mouse\";\n\t\t\tbreak;\n\t\tcase HID_DG_PEN:\n\t\t\t \n\t\t\tsuffix = \"Stylus\";\n\t\t\tbreak;\n\t\tcase HID_DG_STYLUS:\n\t\t\tsuffix = \"Pen\";\n\t\t\tbreak;\n\t\tcase HID_DG_TOUCHSCREEN:\n\t\t\tsuffix = \"Touchscreen\";\n\t\t\tbreak;\n\t\tcase HID_DG_TOUCHPAD:\n\t\t\tsuffix = \"Touchpad\";\n\t\t\tbreak;\n\t\tcase HID_GD_SYSTEM_CONTROL:\n\t\t\tsuffix = \"System Control\";\n\t\t\tbreak;\n\t\tcase HID_CP_CONSUMER_CONTROL:\n\t\t\tsuffix = \"Consumer Control\";\n\t\t\tbreak;\n\t\tcase HID_GD_WIRELESS_RADIO_CTLS:\n\t\t\tsuffix = \"Wireless Radio Control\";\n\t\t\tbreak;\n\t\tcase HID_GD_SYSTEM_MULTIAXIS:\n\t\t\tsuffix = \"System Multi Axis\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (suffix) {\n\t\tname_len = strlen(hid->name);\n\t\tsuffix_len = strlen(suffix);\n\t\tif ((name_len < suffix_len) ||\n\t\t    strcmp(hid->name + name_len - suffix_len, suffix)) {\n\t\t\thidinput->name = kasprintf(GFP_KERNEL, \"%s %s\",\n\t\t\t\t\t\t   hid->name, suffix);\n\t\t\tif (!hidinput->name)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tinput_set_drvdata(input_dev, hid);\n\tinput_dev->event = hidinput_input_event;\n\tinput_dev->open = hidinput_open;\n\tinput_dev->close = hidinput_close;\n\tinput_dev->setkeycode = hidinput_setkeycode;\n\tinput_dev->getkeycode = hidinput_getkeycode;\n\n\tinput_dev->name = hidinput->name ? hidinput->name : hid->name;\n\tinput_dev->phys = hid->phys;\n\tinput_dev->uniq = hid->uniq;\n\tinput_dev->id.bustype = hid->bus;\n\tinput_dev->id.vendor  = hid->vendor;\n\tinput_dev->id.product = hid->product;\n\tinput_dev->id.version = hid->version;\n\tinput_dev->dev.parent = &hid->dev;\n\n\thidinput->input = input_dev;\n\thidinput->application = application;\n\tlist_add_tail(&hidinput->list, &hid->inputs);\n\n\tINIT_LIST_HEAD(&hidinput->reports);\n\n\treturn hidinput;\n\nfail:\n\tkfree(hidinput);\n\tinput_free_device(input_dev);\n\thid_err(hid, \"Out of memory during hid input probe\\n\");\n\treturn NULL;\n}\n\nstatic bool hidinput_has_been_populated(struct hid_input *hidinput)\n{\n\tint i;\n\tunsigned long r = 0;\n\n\tfor (i = 0; i < BITS_TO_LONGS(EV_CNT); i++)\n\t\tr |= hidinput->input->evbit[i];\n\n\tfor (i = 0; i < BITS_TO_LONGS(KEY_CNT); i++)\n\t\tr |= hidinput->input->keybit[i];\n\n\tfor (i = 0; i < BITS_TO_LONGS(REL_CNT); i++)\n\t\tr |= hidinput->input->relbit[i];\n\n\tfor (i = 0; i < BITS_TO_LONGS(ABS_CNT); i++)\n\t\tr |= hidinput->input->absbit[i];\n\n\tfor (i = 0; i < BITS_TO_LONGS(MSC_CNT); i++)\n\t\tr |= hidinput->input->mscbit[i];\n\n\tfor (i = 0; i < BITS_TO_LONGS(LED_CNT); i++)\n\t\tr |= hidinput->input->ledbit[i];\n\n\tfor (i = 0; i < BITS_TO_LONGS(SND_CNT); i++)\n\t\tr |= hidinput->input->sndbit[i];\n\n\tfor (i = 0; i < BITS_TO_LONGS(FF_CNT); i++)\n\t\tr |= hidinput->input->ffbit[i];\n\n\tfor (i = 0; i < BITS_TO_LONGS(SW_CNT); i++)\n\t\tr |= hidinput->input->swbit[i];\n\n\treturn !!r;\n}\n\nstatic void hidinput_cleanup_hidinput(struct hid_device *hid,\n\t\tstruct hid_input *hidinput)\n{\n\tstruct hid_report *report;\n\tint i, k;\n\n\tlist_del(&hidinput->list);\n\tinput_free_device(hidinput->input);\n\tkfree(hidinput->name);\n\n\tfor (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {\n\t\tif (k == HID_OUTPUT_REPORT &&\n\t\t\thid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(report, &hid->report_enum[k].report_list,\n\t\t\t\t    list) {\n\n\t\t\tfor (i = 0; i < report->maxfield; i++)\n\t\t\t\tif (report->field[i]->hidinput == hidinput)\n\t\t\t\t\treport->field[i]->hidinput = NULL;\n\t\t}\n\t}\n\n\tkfree(hidinput);\n}\n\nstatic struct hid_input *hidinput_match(struct hid_report *report)\n{\n\tstruct hid_device *hid = report->device;\n\tstruct hid_input *hidinput;\n\n\tlist_for_each_entry(hidinput, &hid->inputs, list) {\n\t\tif (hidinput->report &&\n\t\t    hidinput->report->id == report->id)\n\t\t\treturn hidinput;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct hid_input *hidinput_match_application(struct hid_report *report)\n{\n\tstruct hid_device *hid = report->device;\n\tstruct hid_input *hidinput;\n\n\tlist_for_each_entry(hidinput, &hid->inputs, list) {\n\t\tif (hidinput->application == report->application)\n\t\t\treturn hidinput;\n\n\t\t \n\t\tif ((report->application == HID_GD_SYSTEM_CONTROL ||\n\t\t     report->application == HID_CP_CONSUMER_CONTROL) &&\n\t\t    hidinput->application == HID_GD_KEYBOARD) {\n\t\t\treturn hidinput;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic inline void hidinput_configure_usages(struct hid_input *hidinput,\n\t\t\t\t\t     struct hid_report *report)\n{\n\tint i, j, k;\n\tint first_field_index = 0;\n\tint slot_collection_index = -1;\n\tint prev_collection_index = -1;\n\tunsigned int slot_idx = 0;\n\tstruct hid_field *field;\n\n\t \n\tfor (i = 0; i < report->maxfield; i++) {\n\t\tfield = report->field[i];\n\n\t\t \n\t\tif (field->maxusage < 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (prev_collection_index != field->usage->collection_index) {\n\t\t\tprev_collection_index = field->usage->collection_index;\n\t\t\tfirst_field_index = i;\n\t\t}\n\n\t\t \n\t\tif (slot_collection_index == field->usage->collection_index) {\n\t\t\tfield->slot_idx = slot_idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < field->maxusage; j++) {\n\t\t\tif (field->usage[j].hid == HID_DG_CONTACTID) {\n\t\t\t\tslot_collection_index = field->usage->collection_index;\n\t\t\t\tslot_idx++;\n\n\t\t\t\t \n\t\t\t\tfor (k = first_field_index; k <= i; k++)\n\t\t\t\t\treport->field[k]->slot_idx = slot_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < report->maxfield; i++)\n\t\tfor (j = 0; j < report->field[i]->maxusage; j++)\n\t\t\thidinput_configure_usage(hidinput, report->field[i],\n\t\t\t\t\t\t report->field[i]->usage + j,\n\t\t\t\t\t\t j);\n}\n\n \n\nint hidinput_connect(struct hid_device *hid, unsigned int force)\n{\n\tstruct hid_driver *drv = hid->driver;\n\tstruct hid_report *report;\n\tstruct hid_input *next, *hidinput = NULL;\n\tunsigned int application;\n\tint i, k;\n\n\tINIT_LIST_HEAD(&hid->inputs);\n\tINIT_WORK(&hid->led_work, hidinput_led_worker);\n\n\thid->status &= ~HID_STAT_DUP_DETECTED;\n\n\tif (!force) {\n\t\tfor (i = 0; i < hid->maxcollection; i++) {\n\t\t\tstruct hid_collection *col = &hid->collection[i];\n\t\t\tif (col->type == HID_COLLECTION_APPLICATION ||\n\t\t\t\t\tcol->type == HID_COLLECTION_PHYSICAL)\n\t\t\t\tif (IS_INPUT_APPLICATION(col->usage))\n\t\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == hid->maxcollection)\n\t\t\treturn -1;\n\t}\n\n\treport_features(hid);\n\n\tfor (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {\n\t\tif (k == HID_OUTPUT_REPORT &&\n\t\t\thid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(report, &hid->report_enum[k].report_list, list) {\n\n\t\t\tif (!report->maxfield)\n\t\t\t\tcontinue;\n\n\t\t\tapplication = report->application;\n\n\t\t\t \n\t\t\tif (hid->quirks & HID_QUIRK_MULTI_INPUT)\n\t\t\t\thidinput = hidinput_match(report);\n\t\t\telse if (hid->maxapplication > 1 &&\n\t\t\t\t (hid->quirks & HID_QUIRK_INPUT_PER_APP))\n\t\t\t\thidinput = hidinput_match_application(report);\n\n\t\t\tif (!hidinput) {\n\t\t\t\thidinput = hidinput_allocate(hid, application);\n\t\t\t\tif (!hidinput)\n\t\t\t\t\tgoto out_unwind;\n\t\t\t}\n\n\t\t\thidinput_configure_usages(hidinput, report);\n\n\t\t\tif (hid->quirks & HID_QUIRK_MULTI_INPUT)\n\t\t\t\thidinput->report = report;\n\n\t\t\tlist_add_tail(&report->hidinput_list,\n\t\t\t\t      &hidinput->reports);\n\t\t}\n\t}\n\n\thidinput_change_resolution_multipliers(hid);\n\n\tlist_for_each_entry_safe(hidinput, next, &hid->inputs, list) {\n\t\tif (drv->input_configured &&\n\t\t    drv->input_configured(hid, hidinput))\n\t\t\tgoto out_unwind;\n\n\t\tif (!hidinput_has_been_populated(hidinput)) {\n\t\t\t \n\t\t\thidinput_cleanup_hidinput(hid, hidinput);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (input_register_device(hidinput->input))\n\t\t\tgoto out_unwind;\n\t\thidinput->registered = true;\n\t}\n\n\tif (list_empty(&hid->inputs)) {\n\t\thid_err(hid, \"No inputs registered, leaving\\n\");\n\t\tgoto out_unwind;\n\t}\n\n\tif (hid->status & HID_STAT_DUP_DETECTED)\n\t\thid_dbg(hid,\n\t\t\t\"Some usages could not be mapped, please use HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE if this is legitimate.\\n\");\n\n\treturn 0;\n\nout_unwind:\n\t \n\thidinput_disconnect(hid);\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(hidinput_connect);\n\nvoid hidinput_disconnect(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput, *next;\n\n\thidinput_cleanup_battery(hid);\n\n\tlist_for_each_entry_safe(hidinput, next, &hid->inputs, list) {\n\t\tlist_del(&hidinput->list);\n\t\tif (hidinput->registered)\n\t\t\tinput_unregister_device(hidinput->input);\n\t\telse\n\t\t\tinput_free_device(hidinput->input);\n\t\tkfree(hidinput->name);\n\t\tkfree(hidinput);\n\t}\n\n\t \n\tcancel_work_sync(&hid->led_work);\n}\nEXPORT_SYMBOL_GPL(hidinput_disconnect);\n\n#ifdef CONFIG_HID_KUNIT_TEST\n#include \"hid-input-test.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}