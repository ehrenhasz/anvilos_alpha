{
  "module_name": "hid-pidff.c",
  "hash_id": "ffceaae697f4344e0a5c09cde910e27be02d224f80d8b4236a3b7b99de36730d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/usbhid/hid-pidff.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <linux/hid.h>\n\n#include \"usbhid.h\"\n\n#define\tPID_EFFECTS_MAX\t\t64\n\n \n\n#define PID_SET_EFFECT\t\t0\n#define PID_EFFECT_OPERATION\t1\n#define PID_DEVICE_GAIN\t\t2\n#define PID_POOL\t\t3\n#define PID_BLOCK_LOAD\t\t4\n#define PID_BLOCK_FREE\t\t5\n#define PID_DEVICE_CONTROL\t6\n#define PID_CREATE_NEW_EFFECT\t7\n\n#define PID_REQUIRED_REPORTS\t7\n\n#define PID_SET_ENVELOPE\t8\n#define PID_SET_CONDITION\t9\n#define PID_SET_PERIODIC\t10\n#define PID_SET_CONSTANT\t11\n#define PID_SET_RAMP\t\t12\nstatic const u8 pidff_reports[] = {\n\t0x21, 0x77, 0x7d, 0x7f, 0x89, 0x90, 0x96, 0xab,\n\t0x5a, 0x5f, 0x6e, 0x73, 0x74\n};\n\n \n\n \n\n#define PID_EFFECT_BLOCK_INDEX\t0\n\n#define PID_DURATION\t\t1\n#define PID_GAIN\t\t2\n#define PID_TRIGGER_BUTTON\t3\n#define PID_TRIGGER_REPEAT_INT\t4\n#define PID_DIRECTION_ENABLE\t5\n#define PID_START_DELAY\t\t6\nstatic const u8 pidff_set_effect[] = {\n\t0x22, 0x50, 0x52, 0x53, 0x54, 0x56, 0xa7\n};\n\n#define PID_ATTACK_LEVEL\t1\n#define PID_ATTACK_TIME\t\t2\n#define PID_FADE_LEVEL\t\t3\n#define PID_FADE_TIME\t\t4\nstatic const u8 pidff_set_envelope[] = { 0x22, 0x5b, 0x5c, 0x5d, 0x5e };\n\n#define PID_PARAM_BLOCK_OFFSET\t1\n#define PID_CP_OFFSET\t\t2\n#define PID_POS_COEFFICIENT\t3\n#define PID_NEG_COEFFICIENT\t4\n#define PID_POS_SATURATION\t5\n#define PID_NEG_SATURATION\t6\n#define PID_DEAD_BAND\t\t7\nstatic const u8 pidff_set_condition[] = {\n\t0x22, 0x23, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65\n};\n\n#define PID_MAGNITUDE\t\t1\n#define PID_OFFSET\t\t2\n#define PID_PHASE\t\t3\n#define PID_PERIOD\t\t4\nstatic const u8 pidff_set_periodic[] = { 0x22, 0x70, 0x6f, 0x71, 0x72 };\nstatic const u8 pidff_set_constant[] = { 0x22, 0x70 };\n\n#define PID_RAMP_START\t\t1\n#define PID_RAMP_END\t\t2\nstatic const u8 pidff_set_ramp[] = { 0x22, 0x75, 0x76 };\n\n#define PID_RAM_POOL_AVAILABLE\t1\nstatic const u8 pidff_block_load[] = { 0x22, 0xac };\n\n#define PID_LOOP_COUNT\t\t1\nstatic const u8 pidff_effect_operation[] = { 0x22, 0x7c };\n\nstatic const u8 pidff_block_free[] = { 0x22 };\n\n#define PID_DEVICE_GAIN_FIELD\t0\nstatic const u8 pidff_device_gain[] = { 0x7e };\n\n#define PID_RAM_POOL_SIZE\t0\n#define PID_SIMULTANEOUS_MAX\t1\n#define PID_DEVICE_MANAGED_POOL\t2\nstatic const u8 pidff_pool[] = { 0x80, 0x83, 0xa9 };\n\n \n\n#define PID_ENABLE_ACTUATORS\t0\n#define PID_RESET\t\t1\nstatic const u8 pidff_device_control[] = { 0x97, 0x9a };\n\n#define PID_CONSTANT\t0\n#define PID_RAMP\t1\n#define PID_SQUARE\t2\n#define PID_SINE\t3\n#define PID_TRIANGLE\t4\n#define PID_SAW_UP\t5\n#define PID_SAW_DOWN\t6\n#define PID_SPRING\t7\n#define PID_DAMPER\t8\n#define PID_INERTIA\t9\n#define PID_FRICTION\t10\nstatic const u8 pidff_effect_types[] = {\n\t0x26, 0x27, 0x30, 0x31, 0x32, 0x33, 0x34,\n\t0x40, 0x41, 0x42, 0x43\n};\n\n#define PID_BLOCK_LOAD_SUCCESS\t0\n#define PID_BLOCK_LOAD_FULL\t1\nstatic const u8 pidff_block_load_status[] = { 0x8c, 0x8d };\n\n#define PID_EFFECT_START\t0\n#define PID_EFFECT_STOP\t\t1\nstatic const u8 pidff_effect_operation_status[] = { 0x79, 0x7b };\n\nstruct pidff_usage {\n\tstruct hid_field *field;\n\ts32 *value;\n};\n\nstruct pidff_device {\n\tstruct hid_device *hid;\n\n\tstruct hid_report *reports[sizeof(pidff_reports)];\n\n\tstruct pidff_usage set_effect[sizeof(pidff_set_effect)];\n\tstruct pidff_usage set_envelope[sizeof(pidff_set_envelope)];\n\tstruct pidff_usage set_condition[sizeof(pidff_set_condition)];\n\tstruct pidff_usage set_periodic[sizeof(pidff_set_periodic)];\n\tstruct pidff_usage set_constant[sizeof(pidff_set_constant)];\n\tstruct pidff_usage set_ramp[sizeof(pidff_set_ramp)];\n\n\tstruct pidff_usage device_gain[sizeof(pidff_device_gain)];\n\tstruct pidff_usage block_load[sizeof(pidff_block_load)];\n\tstruct pidff_usage pool[sizeof(pidff_pool)];\n\tstruct pidff_usage effect_operation[sizeof(pidff_effect_operation)];\n\tstruct pidff_usage block_free[sizeof(pidff_block_free)];\n\n\t \n\n\t \n\tstruct hid_field *create_new_effect_type;\n\n\t \n\tstruct hid_field *set_effect_type;\n\tstruct hid_field *effect_direction;\n\n\t \n\tstruct hid_field *device_control;\n\n\t \n\tstruct hid_field *block_load_status;\n\n\t \n\tstruct hid_field *effect_operation_status;\n\n\tint control_id[sizeof(pidff_device_control)];\n\tint type_id[sizeof(pidff_effect_types)];\n\tint status_id[sizeof(pidff_block_load_status)];\n\tint operation_id[sizeof(pidff_effect_operation_status)];\n\n\tint pid_id[PID_EFFECTS_MAX];\n};\n\n \nstatic int pidff_rescale(int i, int max, struct hid_field *field)\n{\n\treturn i * (field->logical_maximum - field->logical_minimum) / max +\n\t    field->logical_minimum;\n}\n\n \nstatic int pidff_rescale_signed(int i, struct hid_field *field)\n{\n\treturn i == 0 ? 0 : i >\n\t    0 ? i * field->logical_maximum / 0x7fff : i *\n\t    field->logical_minimum / -0x8000;\n}\n\nstatic void pidff_set(struct pidff_usage *usage, u16 value)\n{\n\tusage->value[0] = pidff_rescale(value, 0xffff, usage->field);\n\tpr_debug(\"calculated from %d to %d\\n\", value, usage->value[0]);\n}\n\nstatic void pidff_set_signed(struct pidff_usage *usage, s16 value)\n{\n\tif (usage->field->logical_minimum < 0)\n\t\tusage->value[0] = pidff_rescale_signed(value, usage->field);\n\telse {\n\t\tif (value < 0)\n\t\t\tusage->value[0] =\n\t\t\t    pidff_rescale(-value, 0x8000, usage->field);\n\t\telse\n\t\t\tusage->value[0] =\n\t\t\t    pidff_rescale(value, 0x7fff, usage->field);\n\t}\n\tpr_debug(\"calculated from %d to %d\\n\", value, usage->value[0]);\n}\n\n \nstatic void pidff_set_envelope_report(struct pidff_device *pidff,\n\t\t\t\t      struct ff_envelope *envelope)\n{\n\tpidff->set_envelope[PID_EFFECT_BLOCK_INDEX].value[0] =\n\t    pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\n\n\tpidff->set_envelope[PID_ATTACK_LEVEL].value[0] =\n\t    pidff_rescale(envelope->attack_level >\n\t\t\t  0x7fff ? 0x7fff : envelope->attack_level, 0x7fff,\n\t\t\t  pidff->set_envelope[PID_ATTACK_LEVEL].field);\n\tpidff->set_envelope[PID_FADE_LEVEL].value[0] =\n\t    pidff_rescale(envelope->fade_level >\n\t\t\t  0x7fff ? 0x7fff : envelope->fade_level, 0x7fff,\n\t\t\t  pidff->set_envelope[PID_FADE_LEVEL].field);\n\n\tpidff->set_envelope[PID_ATTACK_TIME].value[0] = envelope->attack_length;\n\tpidff->set_envelope[PID_FADE_TIME].value[0] = envelope->fade_length;\n\n\thid_dbg(pidff->hid, \"attack %u => %d\\n\",\n\t\tenvelope->attack_level,\n\t\tpidff->set_envelope[PID_ATTACK_LEVEL].value[0]);\n\n\thid_hw_request(pidff->hid, pidff->reports[PID_SET_ENVELOPE],\n\t\t\tHID_REQ_SET_REPORT);\n}\n\n \nstatic int pidff_needs_set_envelope(struct ff_envelope *envelope,\n\t\t\t\t    struct ff_envelope *old)\n{\n\treturn envelope->attack_level != old->attack_level ||\n\t       envelope->fade_level != old->fade_level ||\n\t       envelope->attack_length != old->attack_length ||\n\t       envelope->fade_length != old->fade_length;\n}\n\n \nstatic void pidff_set_constant_force_report(struct pidff_device *pidff,\n\t\t\t\t\t    struct ff_effect *effect)\n{\n\tpidff->set_constant[PID_EFFECT_BLOCK_INDEX].value[0] =\n\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\n\tpidff_set_signed(&pidff->set_constant[PID_MAGNITUDE],\n\t\t\t effect->u.constant.level);\n\n\thid_hw_request(pidff->hid, pidff->reports[PID_SET_CONSTANT],\n\t\t\tHID_REQ_SET_REPORT);\n}\n\n \nstatic int pidff_needs_set_constant(struct ff_effect *effect,\n\t\t\t\t    struct ff_effect *old)\n{\n\treturn effect->u.constant.level != old->u.constant.level;\n}\n\n \nstatic void pidff_set_effect_report(struct pidff_device *pidff,\n\t\t\t\t    struct ff_effect *effect)\n{\n\tpidff->set_effect[PID_EFFECT_BLOCK_INDEX].value[0] =\n\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\n\tpidff->set_effect_type->value[0] =\n\t\tpidff->create_new_effect_type->value[0];\n\tpidff->set_effect[PID_DURATION].value[0] = effect->replay.length;\n\tpidff->set_effect[PID_TRIGGER_BUTTON].value[0] = effect->trigger.button;\n\tpidff->set_effect[PID_TRIGGER_REPEAT_INT].value[0] =\n\t\teffect->trigger.interval;\n\tpidff->set_effect[PID_GAIN].value[0] =\n\t\tpidff->set_effect[PID_GAIN].field->logical_maximum;\n\tpidff->set_effect[PID_DIRECTION_ENABLE].value[0] = 1;\n\tpidff->effect_direction->value[0] =\n\t\tpidff_rescale(effect->direction, 0xffff,\n\t\t\t\tpidff->effect_direction);\n\tpidff->set_effect[PID_START_DELAY].value[0] = effect->replay.delay;\n\n\thid_hw_request(pidff->hid, pidff->reports[PID_SET_EFFECT],\n\t\t\tHID_REQ_SET_REPORT);\n}\n\n \nstatic int pidff_needs_set_effect(struct ff_effect *effect,\n\t\t\t\t  struct ff_effect *old)\n{\n\treturn effect->replay.length != old->replay.length ||\n\t       effect->trigger.interval != old->trigger.interval ||\n\t       effect->trigger.button != old->trigger.button ||\n\t       effect->direction != old->direction ||\n\t       effect->replay.delay != old->replay.delay;\n}\n\n \nstatic void pidff_set_periodic_report(struct pidff_device *pidff,\n\t\t\t\t      struct ff_effect *effect)\n{\n\tpidff->set_periodic[PID_EFFECT_BLOCK_INDEX].value[0] =\n\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\n\tpidff_set_signed(&pidff->set_periodic[PID_MAGNITUDE],\n\t\t\t effect->u.periodic.magnitude);\n\tpidff_set_signed(&pidff->set_periodic[PID_OFFSET],\n\t\t\t effect->u.periodic.offset);\n\tpidff_set(&pidff->set_periodic[PID_PHASE], effect->u.periodic.phase);\n\tpidff->set_periodic[PID_PERIOD].value[0] = effect->u.periodic.period;\n\n\thid_hw_request(pidff->hid, pidff->reports[PID_SET_PERIODIC],\n\t\t\tHID_REQ_SET_REPORT);\n\n}\n\n \nstatic int pidff_needs_set_periodic(struct ff_effect *effect,\n\t\t\t\t    struct ff_effect *old)\n{\n\treturn effect->u.periodic.magnitude != old->u.periodic.magnitude ||\n\t       effect->u.periodic.offset != old->u.periodic.offset ||\n\t       effect->u.periodic.phase != old->u.periodic.phase ||\n\t       effect->u.periodic.period != old->u.periodic.period;\n}\n\n \nstatic void pidff_set_condition_report(struct pidff_device *pidff,\n\t\t\t\t       struct ff_effect *effect)\n{\n\tint i;\n\n\tpidff->set_condition[PID_EFFECT_BLOCK_INDEX].value[0] =\n\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\n\n\tfor (i = 0; i < 2; i++) {\n\t\tpidff->set_condition[PID_PARAM_BLOCK_OFFSET].value[0] = i;\n\t\tpidff_set_signed(&pidff->set_condition[PID_CP_OFFSET],\n\t\t\t\t effect->u.condition[i].center);\n\t\tpidff_set_signed(&pidff->set_condition[PID_POS_COEFFICIENT],\n\t\t\t\t effect->u.condition[i].right_coeff);\n\t\tpidff_set_signed(&pidff->set_condition[PID_NEG_COEFFICIENT],\n\t\t\t\t effect->u.condition[i].left_coeff);\n\t\tpidff_set(&pidff->set_condition[PID_POS_SATURATION],\n\t\t\t  effect->u.condition[i].right_saturation);\n\t\tpidff_set(&pidff->set_condition[PID_NEG_SATURATION],\n\t\t\t  effect->u.condition[i].left_saturation);\n\t\tpidff_set(&pidff->set_condition[PID_DEAD_BAND],\n\t\t\t  effect->u.condition[i].deadband);\n\t\thid_hw_request(pidff->hid, pidff->reports[PID_SET_CONDITION],\n\t\t\t\tHID_REQ_SET_REPORT);\n\t}\n}\n\n \nstatic int pidff_needs_set_condition(struct ff_effect *effect,\n\t\t\t\t     struct ff_effect *old)\n{\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct ff_condition_effect *cond = &effect->u.condition[i];\n\t\tstruct ff_condition_effect *old_cond = &old->u.condition[i];\n\n\t\tret |= cond->center != old_cond->center ||\n\t\t       cond->right_coeff != old_cond->right_coeff ||\n\t\t       cond->left_coeff != old_cond->left_coeff ||\n\t\t       cond->right_saturation != old_cond->right_saturation ||\n\t\t       cond->left_saturation != old_cond->left_saturation ||\n\t\t       cond->deadband != old_cond->deadband;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void pidff_set_ramp_force_report(struct pidff_device *pidff,\n\t\t\t\t\tstruct ff_effect *effect)\n{\n\tpidff->set_ramp[PID_EFFECT_BLOCK_INDEX].value[0] =\n\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\n\tpidff_set_signed(&pidff->set_ramp[PID_RAMP_START],\n\t\t\t effect->u.ramp.start_level);\n\tpidff_set_signed(&pidff->set_ramp[PID_RAMP_END],\n\t\t\t effect->u.ramp.end_level);\n\thid_hw_request(pidff->hid, pidff->reports[PID_SET_RAMP],\n\t\t\tHID_REQ_SET_REPORT);\n}\n\n \nstatic int pidff_needs_set_ramp(struct ff_effect *effect, struct ff_effect *old)\n{\n\treturn effect->u.ramp.start_level != old->u.ramp.start_level ||\n\t       effect->u.ramp.end_level != old->u.ramp.end_level;\n}\n\n \nstatic int pidff_request_effect_upload(struct pidff_device *pidff, int efnum)\n{\n\tint j;\n\n\tpidff->create_new_effect_type->value[0] = efnum;\n\thid_hw_request(pidff->hid, pidff->reports[PID_CREATE_NEW_EFFECT],\n\t\t\tHID_REQ_SET_REPORT);\n\thid_dbg(pidff->hid, \"create_new_effect sent, type: %d\\n\", efnum);\n\n\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] = 0;\n\tpidff->block_load_status->value[0] = 0;\n\thid_hw_wait(pidff->hid);\n\n\tfor (j = 0; j < 60; j++) {\n\t\thid_dbg(pidff->hid, \"pid_block_load requested\\n\");\n\t\thid_hw_request(pidff->hid, pidff->reports[PID_BLOCK_LOAD],\n\t\t\t\tHID_REQ_GET_REPORT);\n\t\thid_hw_wait(pidff->hid);\n\t\tif (pidff->block_load_status->value[0] ==\n\t\t    pidff->status_id[PID_BLOCK_LOAD_SUCCESS]) {\n\t\t\thid_dbg(pidff->hid, \"device reported free memory: %d bytes\\n\",\n\t\t\t\t pidff->block_load[PID_RAM_POOL_AVAILABLE].value ?\n\t\t\t\t pidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);\n\t\t\treturn 0;\n\t\t}\n\t\tif (pidff->block_load_status->value[0] ==\n\t\t    pidff->status_id[PID_BLOCK_LOAD_FULL]) {\n\t\t\thid_dbg(pidff->hid, \"not enough memory free: %d bytes\\n\",\n\t\t\t\tpidff->block_load[PID_RAM_POOL_AVAILABLE].value ?\n\t\t\t\tpidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\thid_err(pidff->hid, \"pid_block_load failed 60 times\\n\");\n\treturn -EIO;\n}\n\n \nstatic void pidff_playback_pid(struct pidff_device *pidff, int pid_id, int n)\n{\n\tpidff->effect_operation[PID_EFFECT_BLOCK_INDEX].value[0] = pid_id;\n\n\tif (n == 0) {\n\t\tpidff->effect_operation_status->value[0] =\n\t\t\tpidff->operation_id[PID_EFFECT_STOP];\n\t} else {\n\t\tpidff->effect_operation_status->value[0] =\n\t\t\tpidff->operation_id[PID_EFFECT_START];\n\t\tpidff->effect_operation[PID_LOOP_COUNT].value[0] = n;\n\t}\n\n\thid_hw_request(pidff->hid, pidff->reports[PID_EFFECT_OPERATION],\n\t\t\tHID_REQ_SET_REPORT);\n}\n\n \nstatic int pidff_playback(struct input_dev *dev, int effect_id, int value)\n{\n\tstruct pidff_device *pidff = dev->ff->private;\n\n\tpidff_playback_pid(pidff, pidff->pid_id[effect_id], value);\n\n\treturn 0;\n}\n\n \nstatic void pidff_erase_pid(struct pidff_device *pidff, int pid_id)\n{\n\tpidff->block_free[PID_EFFECT_BLOCK_INDEX].value[0] = pid_id;\n\thid_hw_request(pidff->hid, pidff->reports[PID_BLOCK_FREE],\n\t\t\tHID_REQ_SET_REPORT);\n}\n\n \nstatic int pidff_erase_effect(struct input_dev *dev, int effect_id)\n{\n\tstruct pidff_device *pidff = dev->ff->private;\n\tint pid_id = pidff->pid_id[effect_id];\n\n\thid_dbg(pidff->hid, \"starting to erase %d/%d\\n\",\n\t\teffect_id, pidff->pid_id[effect_id]);\n\t \n\thid_hw_wait(pidff->hid);\n\tpidff_playback_pid(pidff, pid_id, 0);\n\tpidff_erase_pid(pidff, pid_id);\n\n\treturn 0;\n}\n\n \nstatic int pidff_upload_effect(struct input_dev *dev, struct ff_effect *effect,\n\t\t\t       struct ff_effect *old)\n{\n\tstruct pidff_device *pidff = dev->ff->private;\n\tint type_id;\n\tint error;\n\n\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] = 0;\n\tif (old) {\n\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] =\n\t\t\tpidff->pid_id[effect->id];\n\t}\n\n\tswitch (effect->type) {\n\tcase FF_CONSTANT:\n\t\tif (!old) {\n\t\t\terror = pidff_request_effect_upload(pidff,\n\t\t\t\t\tpidff->type_id[PID_CONSTANT]);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (!old || pidff_needs_set_effect(effect, old))\n\t\t\tpidff_set_effect_report(pidff, effect);\n\t\tif (!old || pidff_needs_set_constant(effect, old))\n\t\t\tpidff_set_constant_force_report(pidff, effect);\n\t\tif (!old ||\n\t\t    pidff_needs_set_envelope(&effect->u.constant.envelope,\n\t\t\t\t\t&old->u.constant.envelope))\n\t\t\tpidff_set_envelope_report(pidff,\n\t\t\t\t\t&effect->u.constant.envelope);\n\t\tbreak;\n\n\tcase FF_PERIODIC:\n\t\tif (!old) {\n\t\t\tswitch (effect->u.periodic.waveform) {\n\t\t\tcase FF_SQUARE:\n\t\t\t\ttype_id = PID_SQUARE;\n\t\t\t\tbreak;\n\t\t\tcase FF_TRIANGLE:\n\t\t\t\ttype_id = PID_TRIANGLE;\n\t\t\t\tbreak;\n\t\t\tcase FF_SINE:\n\t\t\t\ttype_id = PID_SINE;\n\t\t\t\tbreak;\n\t\t\tcase FF_SAW_UP:\n\t\t\t\ttype_id = PID_SAW_UP;\n\t\t\t\tbreak;\n\t\t\tcase FF_SAW_DOWN:\n\t\t\t\ttype_id = PID_SAW_DOWN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\thid_err(pidff->hid, \"invalid waveform\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terror = pidff_request_effect_upload(pidff,\n\t\t\t\t\tpidff->type_id[type_id]);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (!old || pidff_needs_set_effect(effect, old))\n\t\t\tpidff_set_effect_report(pidff, effect);\n\t\tif (!old || pidff_needs_set_periodic(effect, old))\n\t\t\tpidff_set_periodic_report(pidff, effect);\n\t\tif (!old ||\n\t\t    pidff_needs_set_envelope(&effect->u.periodic.envelope,\n\t\t\t\t\t&old->u.periodic.envelope))\n\t\t\tpidff_set_envelope_report(pidff,\n\t\t\t\t\t&effect->u.periodic.envelope);\n\t\tbreak;\n\n\tcase FF_RAMP:\n\t\tif (!old) {\n\t\t\terror = pidff_request_effect_upload(pidff,\n\t\t\t\t\tpidff->type_id[PID_RAMP]);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (!old || pidff_needs_set_effect(effect, old))\n\t\t\tpidff_set_effect_report(pidff, effect);\n\t\tif (!old || pidff_needs_set_ramp(effect, old))\n\t\t\tpidff_set_ramp_force_report(pidff, effect);\n\t\tif (!old ||\n\t\t    pidff_needs_set_envelope(&effect->u.ramp.envelope,\n\t\t\t\t\t&old->u.ramp.envelope))\n\t\t\tpidff_set_envelope_report(pidff,\n\t\t\t\t\t&effect->u.ramp.envelope);\n\t\tbreak;\n\n\tcase FF_SPRING:\n\t\tif (!old) {\n\t\t\terror = pidff_request_effect_upload(pidff,\n\t\t\t\t\tpidff->type_id[PID_SPRING]);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (!old || pidff_needs_set_effect(effect, old))\n\t\t\tpidff_set_effect_report(pidff, effect);\n\t\tif (!old || pidff_needs_set_condition(effect, old))\n\t\t\tpidff_set_condition_report(pidff, effect);\n\t\tbreak;\n\n\tcase FF_FRICTION:\n\t\tif (!old) {\n\t\t\terror = pidff_request_effect_upload(pidff,\n\t\t\t\t\tpidff->type_id[PID_FRICTION]);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (!old || pidff_needs_set_effect(effect, old))\n\t\t\tpidff_set_effect_report(pidff, effect);\n\t\tif (!old || pidff_needs_set_condition(effect, old))\n\t\t\tpidff_set_condition_report(pidff, effect);\n\t\tbreak;\n\n\tcase FF_DAMPER:\n\t\tif (!old) {\n\t\t\terror = pidff_request_effect_upload(pidff,\n\t\t\t\t\tpidff->type_id[PID_DAMPER]);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (!old || pidff_needs_set_effect(effect, old))\n\t\t\tpidff_set_effect_report(pidff, effect);\n\t\tif (!old || pidff_needs_set_condition(effect, old))\n\t\t\tpidff_set_condition_report(pidff, effect);\n\t\tbreak;\n\n\tcase FF_INERTIA:\n\t\tif (!old) {\n\t\t\terror = pidff_request_effect_upload(pidff,\n\t\t\t\t\tpidff->type_id[PID_INERTIA]);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (!old || pidff_needs_set_effect(effect, old))\n\t\t\tpidff_set_effect_report(pidff, effect);\n\t\tif (!old || pidff_needs_set_condition(effect, old))\n\t\t\tpidff_set_condition_report(pidff, effect);\n\t\tbreak;\n\n\tdefault:\n\t\thid_err(pidff->hid, \"invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!old)\n\t\tpidff->pid_id[effect->id] =\n\t\t    pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\n\n\thid_dbg(pidff->hid, \"uploaded\\n\");\n\n\treturn 0;\n}\n\n \nstatic void pidff_set_gain(struct input_dev *dev, u16 gain)\n{\n\tstruct pidff_device *pidff = dev->ff->private;\n\n\tpidff_set(&pidff->device_gain[PID_DEVICE_GAIN_FIELD], gain);\n\thid_hw_request(pidff->hid, pidff->reports[PID_DEVICE_GAIN],\n\t\t\tHID_REQ_SET_REPORT);\n}\n\nstatic void pidff_autocenter(struct pidff_device *pidff, u16 magnitude)\n{\n\tstruct hid_field *field =\n\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].field;\n\n\tif (!magnitude) {\n\t\tpidff_playback_pid(pidff, field->logical_minimum, 0);\n\t\treturn;\n\t}\n\n\tpidff_playback_pid(pidff, field->logical_minimum, 1);\n\n\tpidff->set_effect[PID_EFFECT_BLOCK_INDEX].value[0] =\n\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum;\n\tpidff->set_effect_type->value[0] = pidff->type_id[PID_SPRING];\n\tpidff->set_effect[PID_DURATION].value[0] = 0;\n\tpidff->set_effect[PID_TRIGGER_BUTTON].value[0] = 0;\n\tpidff->set_effect[PID_TRIGGER_REPEAT_INT].value[0] = 0;\n\tpidff_set(&pidff->set_effect[PID_GAIN], magnitude);\n\tpidff->set_effect[PID_DIRECTION_ENABLE].value[0] = 1;\n\tpidff->set_effect[PID_START_DELAY].value[0] = 0;\n\n\thid_hw_request(pidff->hid, pidff->reports[PID_SET_EFFECT],\n\t\t\tHID_REQ_SET_REPORT);\n}\n\n \nstatic void pidff_set_autocenter(struct input_dev *dev, u16 magnitude)\n{\n\tstruct pidff_device *pidff = dev->ff->private;\n\n\tpidff_autocenter(pidff, magnitude);\n}\n\n \nstatic int pidff_find_fields(struct pidff_usage *usage, const u8 *table,\n\t\t\t     struct hid_report *report, int count, int strict)\n{\n\tint i, j, k, found;\n\n\tfor (k = 0; k < count; k++) {\n\t\tfound = 0;\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\tif (report->field[i]->maxusage !=\n\t\t\t    report->field[i]->report_count) {\n\t\t\t\tpr_debug(\"maxusage and report_count do not match, skipping\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0; j < report->field[i]->maxusage; j++) {\n\t\t\t\tif (report->field[i]->usage[j].hid ==\n\t\t\t\t    (HID_UP_PID | table[k])) {\n\t\t\t\t\tpr_debug(\"found %d at %d->%d\\n\",\n\t\t\t\t\t\t k, i, j);\n\t\t\t\t\tusage[k].field = report->field[i];\n\t\t\t\t\tusage[k].value =\n\t\t\t\t\t\t&report->field[i]->value[j];\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!found && strict) {\n\t\t\tpr_debug(\"failed to locate %d\\n\", k);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int pidff_check_usage(int usage)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(pidff_reports); i++)\n\t\tif (usage == (HID_UP_PID | pidff_reports[i]))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\n \nstatic void pidff_find_reports(struct hid_device *hid, int report_type,\n\t\t\t       struct pidff_device *pidff)\n{\n\tstruct hid_report *report;\n\tint i, ret;\n\n\tlist_for_each_entry(report,\n\t\t\t    &hid->report_enum[report_type].report_list, list) {\n\t\tif (report->maxfield < 1)\n\t\t\tcontinue;\n\t\tret = pidff_check_usage(report->field[0]->logical);\n\t\tif (ret != -1) {\n\t\t\thid_dbg(hid, \"found usage 0x%02x from field->logical\\n\",\n\t\t\t\tpidff_reports[ret]);\n\t\t\tpidff->reports[ret] = report;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ti = report->field[0]->usage[0].collection_index;\n\t\tif (i <= 0 ||\n\t\t    hid->collection[i - 1].type != HID_COLLECTION_LOGICAL)\n\t\t\tcontinue;\n\t\tret = pidff_check_usage(hid->collection[i - 1].usage);\n\t\tif (ret != -1 && !pidff->reports[ret]) {\n\t\t\thid_dbg(hid,\n\t\t\t\t\"found usage 0x%02x from collection array\\n\",\n\t\t\t\tpidff_reports[ret]);\n\t\t\tpidff->reports[ret] = report;\n\t\t}\n\t}\n}\n\n \nstatic int pidff_reports_ok(struct pidff_device *pidff)\n{\n\tint i;\n\n\tfor (i = 0; i <= PID_REQUIRED_REPORTS; i++) {\n\t\tif (!pidff->reports[i]) {\n\t\t\thid_dbg(pidff->hid, \"%d missing\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n \nstatic struct hid_field *pidff_find_special_field(struct hid_report *report,\n\t\t\t\t\t\t  int usage, int enforce_min)\n{\n\tint i;\n\n\tfor (i = 0; i < report->maxfield; i++) {\n\t\tif (report->field[i]->logical == (HID_UP_PID | usage) &&\n\t\t    report->field[i]->report_count > 0) {\n\t\t\tif (!enforce_min ||\n\t\t\t    report->field[i]->logical_minimum == 1)\n\t\t\t\treturn report->field[i];\n\t\t\telse {\n\t\t\t\tpr_err(\"logical_minimum is not 1 as it should be\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int pidff_find_special_keys(int *keys, struct hid_field *fld,\n\t\t\t\t   const u8 *usagetable, int count)\n{\n\n\tint i, j;\n\tint found = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tfor (j = 0; j < fld->maxusage; j++) {\n\t\t\tif (fld->usage[j].hid == (HID_UP_PID | usagetable[i])) {\n\t\t\t\tkeys[i] = j + 1;\n\t\t\t\tfound++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\n#define PIDFF_FIND_SPECIAL_KEYS(keys, field, name) \\\n\tpidff_find_special_keys(pidff->keys, pidff->field, pidff_ ## name, \\\n\t\tsizeof(pidff_ ## name))\n\n \nstatic int pidff_find_special_fields(struct pidff_device *pidff)\n{\n\thid_dbg(pidff->hid, \"finding special fields\\n\");\n\n\tpidff->create_new_effect_type =\n\t\tpidff_find_special_field(pidff->reports[PID_CREATE_NEW_EFFECT],\n\t\t\t\t\t 0x25, 1);\n\tpidff->set_effect_type =\n\t\tpidff_find_special_field(pidff->reports[PID_SET_EFFECT],\n\t\t\t\t\t 0x25, 1);\n\tpidff->effect_direction =\n\t\tpidff_find_special_field(pidff->reports[PID_SET_EFFECT],\n\t\t\t\t\t 0x57, 0);\n\tpidff->device_control =\n\t\tpidff_find_special_field(pidff->reports[PID_DEVICE_CONTROL],\n\t\t\t\t\t 0x96, 1);\n\tpidff->block_load_status =\n\t\tpidff_find_special_field(pidff->reports[PID_BLOCK_LOAD],\n\t\t\t\t\t 0x8b, 1);\n\tpidff->effect_operation_status =\n\t\tpidff_find_special_field(pidff->reports[PID_EFFECT_OPERATION],\n\t\t\t\t\t 0x78, 1);\n\n\thid_dbg(pidff->hid, \"search done\\n\");\n\n\tif (!pidff->create_new_effect_type || !pidff->set_effect_type) {\n\t\thid_err(pidff->hid, \"effect lists not found\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!pidff->effect_direction) {\n\t\thid_err(pidff->hid, \"direction field not found\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!pidff->device_control) {\n\t\thid_err(pidff->hid, \"device control field not found\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!pidff->block_load_status) {\n\t\thid_err(pidff->hid, \"block load status field not found\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!pidff->effect_operation_status) {\n\t\thid_err(pidff->hid, \"effect operation field not found\\n\");\n\t\treturn -1;\n\t}\n\n\tpidff_find_special_keys(pidff->control_id, pidff->device_control,\n\t\t\t\tpidff_device_control,\n\t\t\t\tsizeof(pidff_device_control));\n\n\tPIDFF_FIND_SPECIAL_KEYS(control_id, device_control, device_control);\n\n\tif (!PIDFF_FIND_SPECIAL_KEYS(type_id, create_new_effect_type,\n\t\t\t\t     effect_types)) {\n\t\thid_err(pidff->hid, \"no effect types found\\n\");\n\t\treturn -1;\n\t}\n\n\tif (PIDFF_FIND_SPECIAL_KEYS(status_id, block_load_status,\n\t\t\t\t    block_load_status) !=\n\t\t\tsizeof(pidff_block_load_status)) {\n\t\thid_err(pidff->hid,\n\t\t\t\"block load status identifiers not found\\n\");\n\t\treturn -1;\n\t}\n\n\tif (PIDFF_FIND_SPECIAL_KEYS(operation_id, effect_operation_status,\n\t\t\t\t    effect_operation_status) !=\n\t\t\tsizeof(pidff_effect_operation_status)) {\n\t\thid_err(pidff->hid, \"effect operation identifiers not found\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pidff_find_effects(struct pidff_device *pidff,\n\t\t\t      struct input_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(pidff_effect_types); i++) {\n\t\tint pidff_type = pidff->type_id[i];\n\t\tif (pidff->set_effect_type->usage[pidff_type].hid !=\n\t\t    pidff->create_new_effect_type->usage[pidff_type].hid) {\n\t\t\thid_err(pidff->hid,\n\t\t\t\t\"effect type number %d is invalid\\n\", i);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (pidff->type_id[PID_CONSTANT])\n\t\tset_bit(FF_CONSTANT, dev->ffbit);\n\tif (pidff->type_id[PID_RAMP])\n\t\tset_bit(FF_RAMP, dev->ffbit);\n\tif (pidff->type_id[PID_SQUARE]) {\n\t\tset_bit(FF_SQUARE, dev->ffbit);\n\t\tset_bit(FF_PERIODIC, dev->ffbit);\n\t}\n\tif (pidff->type_id[PID_SINE]) {\n\t\tset_bit(FF_SINE, dev->ffbit);\n\t\tset_bit(FF_PERIODIC, dev->ffbit);\n\t}\n\tif (pidff->type_id[PID_TRIANGLE]) {\n\t\tset_bit(FF_TRIANGLE, dev->ffbit);\n\t\tset_bit(FF_PERIODIC, dev->ffbit);\n\t}\n\tif (pidff->type_id[PID_SAW_UP]) {\n\t\tset_bit(FF_SAW_UP, dev->ffbit);\n\t\tset_bit(FF_PERIODIC, dev->ffbit);\n\t}\n\tif (pidff->type_id[PID_SAW_DOWN]) {\n\t\tset_bit(FF_SAW_DOWN, dev->ffbit);\n\t\tset_bit(FF_PERIODIC, dev->ffbit);\n\t}\n\tif (pidff->type_id[PID_SPRING])\n\t\tset_bit(FF_SPRING, dev->ffbit);\n\tif (pidff->type_id[PID_DAMPER])\n\t\tset_bit(FF_DAMPER, dev->ffbit);\n\tif (pidff->type_id[PID_INERTIA])\n\t\tset_bit(FF_INERTIA, dev->ffbit);\n\tif (pidff->type_id[PID_FRICTION])\n\t\tset_bit(FF_FRICTION, dev->ffbit);\n\n\treturn 0;\n\n}\n\n#define PIDFF_FIND_FIELDS(name, report, strict) \\\n\tpidff_find_fields(pidff->name, pidff_ ## name, \\\n\t\tpidff->reports[report], \\\n\t\tsizeof(pidff_ ## name), strict)\n\n \nstatic int pidff_init_fields(struct pidff_device *pidff, struct input_dev *dev)\n{\n\tint envelope_ok = 0;\n\n\tif (PIDFF_FIND_FIELDS(set_effect, PID_SET_EFFECT, 1)) {\n\t\thid_err(pidff->hid, \"unknown set_effect report layout\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tPIDFF_FIND_FIELDS(block_load, PID_BLOCK_LOAD, 0);\n\tif (!pidff->block_load[PID_EFFECT_BLOCK_INDEX].value) {\n\t\thid_err(pidff->hid, \"unknown pid_block_load report layout\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (PIDFF_FIND_FIELDS(effect_operation, PID_EFFECT_OPERATION, 1)) {\n\t\thid_err(pidff->hid, \"unknown effect_operation report layout\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (PIDFF_FIND_FIELDS(block_free, PID_BLOCK_FREE, 1)) {\n\t\thid_err(pidff->hid, \"unknown pid_block_free report layout\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!PIDFF_FIND_FIELDS(set_envelope, PID_SET_ENVELOPE, 1))\n\t\tenvelope_ok = 1;\n\n\tif (pidff_find_special_fields(pidff) || pidff_find_effects(pidff, dev))\n\t\treturn -ENODEV;\n\n\tif (!envelope_ok) {\n\t\tif (test_and_clear_bit(FF_CONSTANT, dev->ffbit))\n\t\t\thid_warn(pidff->hid,\n\t\t\t\t \"has constant effect but no envelope\\n\");\n\t\tif (test_and_clear_bit(FF_RAMP, dev->ffbit))\n\t\t\thid_warn(pidff->hid,\n\t\t\t\t \"has ramp effect but no envelope\\n\");\n\n\t\tif (test_and_clear_bit(FF_PERIODIC, dev->ffbit))\n\t\t\thid_warn(pidff->hid,\n\t\t\t\t \"has periodic effect but no envelope\\n\");\n\t}\n\n\tif (test_bit(FF_CONSTANT, dev->ffbit) &&\n\t    PIDFF_FIND_FIELDS(set_constant, PID_SET_CONSTANT, 1)) {\n\t\thid_warn(pidff->hid, \"unknown constant effect layout\\n\");\n\t\tclear_bit(FF_CONSTANT, dev->ffbit);\n\t}\n\n\tif (test_bit(FF_RAMP, dev->ffbit) &&\n\t    PIDFF_FIND_FIELDS(set_ramp, PID_SET_RAMP, 1)) {\n\t\thid_warn(pidff->hid, \"unknown ramp effect layout\\n\");\n\t\tclear_bit(FF_RAMP, dev->ffbit);\n\t}\n\n\tif ((test_bit(FF_SPRING, dev->ffbit) ||\n\t     test_bit(FF_DAMPER, dev->ffbit) ||\n\t     test_bit(FF_FRICTION, dev->ffbit) ||\n\t     test_bit(FF_INERTIA, dev->ffbit)) &&\n\t    PIDFF_FIND_FIELDS(set_condition, PID_SET_CONDITION, 1)) {\n\t\thid_warn(pidff->hid, \"unknown condition effect layout\\n\");\n\t\tclear_bit(FF_SPRING, dev->ffbit);\n\t\tclear_bit(FF_DAMPER, dev->ffbit);\n\t\tclear_bit(FF_FRICTION, dev->ffbit);\n\t\tclear_bit(FF_INERTIA, dev->ffbit);\n\t}\n\n\tif (test_bit(FF_PERIODIC, dev->ffbit) &&\n\t    PIDFF_FIND_FIELDS(set_periodic, PID_SET_PERIODIC, 1)) {\n\t\thid_warn(pidff->hid, \"unknown periodic effect layout\\n\");\n\t\tclear_bit(FF_PERIODIC, dev->ffbit);\n\t}\n\n\tPIDFF_FIND_FIELDS(pool, PID_POOL, 0);\n\n\tif (!PIDFF_FIND_FIELDS(device_gain, PID_DEVICE_GAIN, 1))\n\t\tset_bit(FF_GAIN, dev->ffbit);\n\n\treturn 0;\n}\n\n \nstatic void pidff_reset(struct pidff_device *pidff)\n{\n\tstruct hid_device *hid = pidff->hid;\n\tint i = 0;\n\n\tpidff->device_control->value[0] = pidff->control_id[PID_RESET];\n\t \n\thid_hw_request(hid, pidff->reports[PID_DEVICE_CONTROL], HID_REQ_SET_REPORT);\n\thid_hw_wait(hid);\n\thid_hw_request(hid, pidff->reports[PID_DEVICE_CONTROL], HID_REQ_SET_REPORT);\n\thid_hw_wait(hid);\n\n\tpidff->device_control->value[0] =\n\t\tpidff->control_id[PID_ENABLE_ACTUATORS];\n\thid_hw_request(hid, pidff->reports[PID_DEVICE_CONTROL], HID_REQ_SET_REPORT);\n\thid_hw_wait(hid);\n\n\t \n\thid_hw_request(hid, pidff->reports[PID_POOL], HID_REQ_GET_REPORT);\n\thid_hw_wait(hid);\n\n\tif (pidff->pool[PID_SIMULTANEOUS_MAX].value) {\n\t\twhile (pidff->pool[PID_SIMULTANEOUS_MAX].value[0] < 2) {\n\t\t\tif (i++ > 20) {\n\t\t\t\thid_warn(pidff->hid,\n\t\t\t\t\t \"device reports %d simultaneous effects\\n\",\n\t\t\t\t\t pidff->pool[PID_SIMULTANEOUS_MAX].value[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thid_dbg(pidff->hid, \"pid_pool requested again\\n\");\n\t\t\thid_hw_request(hid, pidff->reports[PID_POOL],\n\t\t\t\t\t  HID_REQ_GET_REPORT);\n\t\t\thid_hw_wait(hid);\n\t\t}\n\t}\n}\n\n \nstatic int pidff_check_autocenter(struct pidff_device *pidff,\n\t\t\t\t  struct input_dev *dev)\n{\n\tint error;\n\n\t \n\n\terror = pidff_request_effect_upload(pidff, 1);\n\tif (error) {\n\t\thid_err(pidff->hid, \"upload request failed\\n\");\n\t\treturn error;\n\t}\n\n\tif (pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] ==\n\t    pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum + 1) {\n\t\tpidff_autocenter(pidff, 0xffff);\n\t\tset_bit(FF_AUTOCENTER, dev->ffbit);\n\t} else {\n\t\thid_notice(pidff->hid,\n\t\t\t   \"device has unknown autocenter control method\\n\");\n\t}\n\n\tpidff_erase_pid(pidff,\n\t\t\tpidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0]);\n\n\treturn 0;\n\n}\n\n \nint hid_pidff_init(struct hid_device *hid)\n{\n\tstruct pidff_device *pidff;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tstruct ff_device *ff;\n\tint max_effects;\n\tint error;\n\n\thid_dbg(hid, \"starting pid init\\n\");\n\n\tif (list_empty(&hid->report_enum[HID_OUTPUT_REPORT].report_list)) {\n\t\thid_dbg(hid, \"not a PID device, no output report\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpidff = kzalloc(sizeof(*pidff), GFP_KERNEL);\n\tif (!pidff)\n\t\treturn -ENOMEM;\n\n\tpidff->hid = hid;\n\n\thid_device_io_start(hid);\n\n\tpidff_find_reports(hid, HID_OUTPUT_REPORT, pidff);\n\tpidff_find_reports(hid, HID_FEATURE_REPORT, pidff);\n\n\tif (!pidff_reports_ok(pidff)) {\n\t\thid_dbg(hid, \"reports not ok, aborting\\n\");\n\t\terror = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\terror = pidff_init_fields(pidff, dev);\n\tif (error)\n\t\tgoto fail;\n\n\tpidff_reset(pidff);\n\n\tif (test_bit(FF_GAIN, dev->ffbit)) {\n\t\tpidff_set(&pidff->device_gain[PID_DEVICE_GAIN_FIELD], 0xffff);\n\t\thid_hw_request(hid, pidff->reports[PID_DEVICE_GAIN],\n\t\t\t\t     HID_REQ_SET_REPORT);\n\t}\n\n\terror = pidff_check_autocenter(pidff, dev);\n\tif (error)\n\t\tgoto fail;\n\n\tmax_effects =\n\t    pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_maximum -\n\t    pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum +\n\t    1;\n\thid_dbg(hid, \"max effects is %d\\n\", max_effects);\n\n\tif (max_effects > PID_EFFECTS_MAX)\n\t\tmax_effects = PID_EFFECTS_MAX;\n\n\tif (pidff->pool[PID_SIMULTANEOUS_MAX].value)\n\t\thid_dbg(hid, \"max simultaneous effects is %d\\n\",\n\t\t\tpidff->pool[PID_SIMULTANEOUS_MAX].value[0]);\n\n\tif (pidff->pool[PID_RAM_POOL_SIZE].value)\n\t\thid_dbg(hid, \"device memory size is %d bytes\\n\",\n\t\t\tpidff->pool[PID_RAM_POOL_SIZE].value[0]);\n\n\tif (pidff->pool[PID_DEVICE_MANAGED_POOL].value &&\n\t    pidff->pool[PID_DEVICE_MANAGED_POOL].value[0] == 0) {\n\t\terror = -EPERM;\n\t\thid_notice(hid,\n\t\t\t   \"device does not support device managed pool\\n\");\n\t\tgoto fail;\n\t}\n\n\terror = input_ff_create(dev, max_effects);\n\tif (error)\n\t\tgoto fail;\n\n\tff = dev->ff;\n\tff->private = pidff;\n\tff->upload = pidff_upload_effect;\n\tff->erase = pidff_erase_effect;\n\tff->set_gain = pidff_set_gain;\n\tff->set_autocenter = pidff_set_autocenter;\n\tff->playback = pidff_playback;\n\n\thid_info(dev, \"Force feedback for USB HID PID devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\n\thid_device_io_stop(hid);\n\n\treturn 0;\n\n fail:\n\thid_device_io_stop(hid);\n\n\tkfree(pidff);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}