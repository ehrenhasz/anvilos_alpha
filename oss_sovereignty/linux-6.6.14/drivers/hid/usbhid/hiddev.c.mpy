{
  "module_name": "hiddev.c",
  "hash_id": "f5bfab6867a94d995d2bc67fe44287e54a59380fa44dd78cbfc78a343f0a6b05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/usbhid/hiddev.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/compat.h>\n#include <linux/vmalloc.h>\n#include <linux/nospec.h>\n#include \"usbhid.h\"\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define HIDDEV_MINOR_BASE\t0\n#define HIDDEV_MINORS\t\t256\n#else\n#define HIDDEV_MINOR_BASE\t96\n#define HIDDEV_MINORS\t\t16\n#endif\n#define HIDDEV_BUFFER_SIZE\t2048\n\nstruct hiddev_list {\n\tstruct hiddev_usage_ref buffer[HIDDEV_BUFFER_SIZE];\n\tint head;\n\tint tail;\n\tunsigned flags;\n\tstruct fasync_struct *fasync;\n\tstruct hiddev *hiddev;\n\tstruct list_head node;\n\tstruct mutex thread_lock;\n};\n\n \nstatic struct hid_report *\nhiddev_lookup_report(struct hid_device *hid, struct hiddev_report_info *rinfo)\n{\n\tunsigned int flags = rinfo->report_id & ~HID_REPORT_ID_MASK;\n\tunsigned int rid = rinfo->report_id & HID_REPORT_ID_MASK;\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_report *report;\n\tstruct list_head *list;\n\n\tif (rinfo->report_type < HID_REPORT_TYPE_MIN ||\n\t    rinfo->report_type > HID_REPORT_TYPE_MAX)\n\t\treturn NULL;\n\n\treport_enum = hid->report_enum +\n\t\t(rinfo->report_type - HID_REPORT_TYPE_MIN);\n\n\tswitch (flags) {\n\tcase 0:  \n\t\tbreak;\n\n\tcase HID_REPORT_ID_FIRST:\n\t\tif (list_empty(&report_enum->report_list))\n\t\t\treturn NULL;\n\n\t\tlist = report_enum->report_list.next;\n\t\treport = list_entry(list, struct hid_report, list);\n\t\trinfo->report_id = report->id;\n\t\tbreak;\n\n\tcase HID_REPORT_ID_NEXT:\n\t\treport = report_enum->report_id_hash[rid];\n\t\tif (!report)\n\t\t\treturn NULL;\n\n\t\tlist = report->list.next;\n\t\tif (list == &report_enum->report_list)\n\t\t\treturn NULL;\n\n\t\treport = list_entry(list, struct hid_report, list);\n\t\trinfo->report_id = report->id;\n\t\tbreak;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn report_enum->report_id_hash[rinfo->report_id];\n}\n\n \nstatic struct hid_field *\nhiddev_lookup_usage(struct hid_device *hid, struct hiddev_usage_ref *uref)\n{\n\tint i, j;\n\tstruct hid_report *report;\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_field *field;\n\n\tif (uref->report_type < HID_REPORT_TYPE_MIN ||\n\t    uref->report_type > HID_REPORT_TYPE_MAX)\n\t\treturn NULL;\n\n\treport_enum = hid->report_enum +\n\t\t(uref->report_type - HID_REPORT_TYPE_MIN);\n\n\tlist_for_each_entry(report, &report_enum->report_list, list) {\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\tfield = report->field[i];\n\t\t\tfor (j = 0; j < field->maxusage; j++) {\n\t\t\t\tif (field->usage[j].hid == uref->usage_code) {\n\t\t\t\t\turef->report_id = report->id;\n\t\t\t\t\turef->field_index = i;\n\t\t\t\t\turef->usage_index = j;\n\t\t\t\t\treturn field;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void hiddev_send_event(struct hid_device *hid,\n\t\t\t      struct hiddev_usage_ref *uref)\n{\n\tstruct hiddev *hiddev = hid->hiddev;\n\tstruct hiddev_list *list;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hiddev->list_lock, flags);\n\tlist_for_each_entry(list, &hiddev->list, node) {\n\t\tif (uref->field_index != HID_FIELD_INDEX_NONE ||\n\t\t    (list->flags & HIDDEV_FLAG_REPORT) != 0) {\n\t\t\tlist->buffer[list->head] = *uref;\n\t\t\tlist->head = (list->head + 1) &\n\t\t\t\t(HIDDEV_BUFFER_SIZE - 1);\n\t\t\tkill_fasync(&list->fasync, SIGIO, POLL_IN);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&hiddev->list_lock, flags);\n\n\twake_up_interruptible(&hiddev->wait);\n}\n\n \nvoid hiddev_hid_event(struct hid_device *hid, struct hid_field *field,\n\t\t      struct hid_usage *usage, __s32 value)\n{\n\tunsigned type = field->report_type;\n\tstruct hiddev_usage_ref uref;\n\n\turef.report_type =\n\t  (type == HID_INPUT_REPORT) ? HID_REPORT_TYPE_INPUT :\n\t  ((type == HID_OUTPUT_REPORT) ? HID_REPORT_TYPE_OUTPUT :\n\t   ((type == HID_FEATURE_REPORT) ? HID_REPORT_TYPE_FEATURE : 0));\n\turef.report_id = field->report->id;\n\turef.field_index = field->index;\n\turef.usage_index = (usage - field->usage);\n\turef.usage_code = usage->hid;\n\turef.value = value;\n\n\thiddev_send_event(hid, &uref);\n}\nEXPORT_SYMBOL_GPL(hiddev_hid_event);\n\nvoid hiddev_report_event(struct hid_device *hid, struct hid_report *report)\n{\n\tunsigned type = report->type;\n\tstruct hiddev_usage_ref uref;\n\n\tmemset(&uref, 0, sizeof(uref));\n\turef.report_type =\n\t  (type == HID_INPUT_REPORT) ? HID_REPORT_TYPE_INPUT :\n\t  ((type == HID_OUTPUT_REPORT) ? HID_REPORT_TYPE_OUTPUT :\n\t   ((type == HID_FEATURE_REPORT) ? HID_REPORT_TYPE_FEATURE : 0));\n\turef.report_id = report->id;\n\turef.field_index = HID_FIELD_INDEX_NONE;\n\n\thiddev_send_event(hid, &uref);\n}\n\n \nstatic int hiddev_fasync(int fd, struct file *file, int on)\n{\n\tstruct hiddev_list *list = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &list->fasync);\n}\n\n\n \nstatic int hiddev_release(struct inode * inode, struct file * file)\n{\n\tstruct hiddev_list *list = file->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list->hiddev->list_lock, flags);\n\tlist_del(&list->node);\n\tspin_unlock_irqrestore(&list->hiddev->list_lock, flags);\n\n\tmutex_lock(&list->hiddev->existancelock);\n\tif (!--list->hiddev->open) {\n\t\tif (list->hiddev->exist) {\n\t\t\thid_hw_close(list->hiddev->hid);\n\t\t\thid_hw_power(list->hiddev->hid, PM_HINT_NORMAL);\n\t\t} else {\n\t\t\tmutex_unlock(&list->hiddev->existancelock);\n\t\t\tkfree(list->hiddev);\n\t\t\tvfree(list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&list->hiddev->existancelock);\n\tvfree(list);\n\n\treturn 0;\n}\n\nstatic int __hiddev_open(struct hiddev *hiddev, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tint error;\n\n\tlockdep_assert_held(&hiddev->existancelock);\n\n\tlist = vzalloc(sizeof(*list));\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\n\tif (!hiddev->open++) {\n\t\terror = hid_hw_power(hiddev->hid, PM_HINT_FULLON);\n\t\tif (error < 0)\n\t\t\tgoto err_drop_count;\n\n\t\terror = hid_hw_open(hiddev->hid);\n\t\tif (error < 0)\n\t\t\tgoto err_normal_power;\n\t}\n\n\tspin_lock_irq(&hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&hiddev->list_lock);\n\n\tfile->private_data = list;\n\n\treturn 0;\n\nerr_normal_power:\n\thid_hw_power(hiddev->hid, PM_HINT_NORMAL);\nerr_drop_count:\n\thiddev->open--;\n\tvfree(list);\n\treturn error;\n}\n\n \nstatic int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\n\tmutex_lock(&hiddev->existancelock);\n\tres = hiddev->exist ? __hiddev_open(hiddev, file) : -ENODEV;\n\tmutex_unlock(&hiddev->existancelock);\n\n\treturn res;\n}\n\n \nstatic ssize_t hiddev_write(struct file * file, const char __user * buffer, size_t count, loff_t *ppos)\n{\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t hiddev_read(struct file * file, char __user * buffer, size_t count, loff_t *ppos)\n{\n\tDEFINE_WAIT(wait);\n\tstruct hiddev_list *list = file->private_data;\n\tint event_size;\n\tint retval;\n\n\tevent_size = ((list->flags & HIDDEV_FLAG_UREF) != 0) ?\n\t\tsizeof(struct hiddev_usage_ref) : sizeof(struct hiddev_event);\n\n\tif (count < event_size)\n\t\treturn 0;\n\n\t \n\tretval = mutex_lock_interruptible(&list->thread_lock);\n\tif (retval)\n\t\treturn -ERESTARTSYS;\n\n\twhile (retval == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tprepare_to_wait(&list->hiddev->wait, &wait, TASK_INTERRUPTIBLE);\n\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!list->hiddev->exist) {\n\t\t\t\t\tretval = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tretval = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmutex_unlock(&list->thread_lock);\n\t\t\t\tschedule();\n\t\t\t\tif (mutex_lock_interruptible(&list->thread_lock)) {\n\t\t\t\t\tfinish_wait(&list->hiddev->wait, &wait);\n\t\t\t\t\treturn -EINTR;\n\t\t\t\t}\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\t\t\tfinish_wait(&list->hiddev->wait, &wait);\n\n\t\t}\n\n\t\tif (retval) {\n\t\t\tmutex_unlock(&list->thread_lock);\n\t\t\treturn retval;\n\t\t}\n\n\n\t\twhile (list->head != list->tail &&\n\t\t       retval + event_size <= count) {\n\t\t\tif ((list->flags & HIDDEV_FLAG_UREF) == 0) {\n\t\t\t\tif (list->buffer[list->tail].field_index != HID_FIELD_INDEX_NONE) {\n\t\t\t\t\tstruct hiddev_event event;\n\n\t\t\t\t\tevent.hid = list->buffer[list->tail].usage_code;\n\t\t\t\t\tevent.value = list->buffer[list->tail].value;\n\t\t\t\t\tif (copy_to_user(buffer + retval, &event, sizeof(struct hiddev_event))) {\n\t\t\t\t\t\tmutex_unlock(&list->thread_lock);\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\tretval += sizeof(struct hiddev_event);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (list->buffer[list->tail].field_index != HID_FIELD_INDEX_NONE ||\n\t\t\t\t    (list->flags & HIDDEV_FLAG_REPORT) != 0) {\n\n\t\t\t\t\tif (copy_to_user(buffer + retval, list->buffer + list->tail, sizeof(struct hiddev_usage_ref))) {\n\t\t\t\t\t\tmutex_unlock(&list->thread_lock);\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\tretval += sizeof(struct hiddev_usage_ref);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist->tail = (list->tail + 1) & (HIDDEV_BUFFER_SIZE - 1);\n\t\t}\n\n\t}\n\tmutex_unlock(&list->thread_lock);\n\n\treturn retval;\n}\n\n \nstatic __poll_t hiddev_poll(struct file *file, poll_table *wait)\n{\n\tstruct hiddev_list *list = file->private_data;\n\n\tpoll_wait(file, &list->hiddev->wait, wait);\n\tif (list->head != list->tail)\n\t\treturn EPOLLIN | EPOLLRDNORM | EPOLLOUT;\n\tif (!list->hiddev->exist)\n\t\treturn EPOLLERR | EPOLLHUP;\n\treturn 0;\n}\n\n \nstatic noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\n{\n\tstruct hid_device *hid = hiddev->hid;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_usage_ref_multi *uref_multi = NULL;\n\tstruct hiddev_usage_ref *uref;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i;\n\n\turef_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);\n\tif (!uref_multi)\n\t\treturn -ENOMEM;\n\turef = &uref_multi->uref;\n\tif (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {\n\t\tif (copy_from_user(uref_multi, user_arg,\n\t\t\t\t   sizeof(*uref_multi)))\n\t\t\tgoto fault;\n\t} else {\n\t\tif (copy_from_user(uref, user_arg, sizeof(*uref)))\n\t\t\tgoto fault;\n\t}\n\n\tswitch (cmd) {\n\tcase HIDIOCGUCODE:\n\t\trinfo.report_type = uref->report_type;\n\t\trinfo.report_id = uref->report_id;\n\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\tgoto inval;\n\n\t\tif (uref->field_index >= report->maxfield)\n\t\t\tgoto inval;\n\t\turef->field_index = array_index_nospec(uref->field_index,\n\t\t\t\t\t\t       report->maxfield);\n\n\t\tfield = report->field[uref->field_index];\n\t\tif (uref->usage_index >= field->maxusage)\n\t\t\tgoto inval;\n\t\turef->usage_index = array_index_nospec(uref->usage_index,\n\t\t\t\t\t\t       field->maxusage);\n\n\t\turef->usage_code = field->usage[uref->usage_index].hid;\n\n\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\tgoto fault;\n\n\t\tgoto goodreturn;\n\n\tdefault:\n\t\tif (cmd != HIDIOCGUSAGE &&\n\t\t    cmd != HIDIOCGUSAGES &&\n\t\t    uref->report_type == HID_REPORT_TYPE_INPUT)\n\t\t\tgoto inval;\n\n\t\tif (uref->report_id == HID_REPORT_ID_UNKNOWN) {\n\t\t\tfield = hiddev_lookup_usage(hid, uref);\n\t\t\tif (field == NULL)\n\t\t\t\tgoto inval;\n\t\t} else {\n\t\t\trinfo.report_type = uref->report_type;\n\t\t\trinfo.report_id = uref->report_id;\n\t\t\tif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\n\t\t\t\tgoto inval;\n\n\t\t\tif (uref->field_index >= report->maxfield)\n\t\t\t\tgoto inval;\n\t\t\turef->field_index = array_index_nospec(uref->field_index,\n\t\t\t\t\t\t\t       report->maxfield);\n\n\t\t\tfield = report->field[uref->field_index];\n\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t\turef->usage_index =\n\t\t\t\t\tarray_index_nospec(uref->usage_index,\n\t\t\t\t\t\t\t   field->maxusage);\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tif (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {\n\t\t\tif (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t\t    uref->usage_index + uref_multi->num_values >\n\t\t\t    field->report_count)\n\t\t\t\tgoto inval;\n\n\t\t\turef->usage_index =\n\t\t\t\tarray_index_nospec(uref->usage_index,\n\t\t\t\t\t\t   field->report_count -\n\t\t\t\t\t\t   uref_multi->num_values);\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\tif (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCSUSAGE:\n\t\t\tif (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\t\t\tfield->value[uref->usage_index] = uref->value;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCGCOLLECTIONINDEX:\n\t\t\ti = field->usage[uref->usage_index].collection_index;\n\t\t\tkfree(uref_multi);\n\t\t\treturn i;\n\t\tcase HIDIOCGUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\turef_multi->values[i] =\n\t\t\t\t    field->value[uref->usage_index + i];\n\t\t\tif (copy_to_user(user_arg, uref_multi,\n\t\t\t\t\t sizeof(*uref_multi)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\t\tcase HIDIOCSUSAGES:\n\t\t\tfor (i = 0; i < uref_multi->num_values; i++)\n\t\t\t\tfield->value[uref->usage_index + i] =\n\t\t\t\t    uref_multi->values[i];\n\t\t\tgoto goodreturn;\n\t\t}\n\ngoodreturn:\n\t\tkfree(uref_multi);\n\t\treturn 0;\nfault:\n\t\tkfree(uref_multi);\n\t\treturn -EFAULT;\ninval:\n\t\tkfree(uref_multi);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic noinline int hiddev_ioctl_string(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\n{\n\tstruct hid_device *hid = hiddev->hid;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tint idx, len;\n\tchar *buf;\n\n\tif (get_user(idx, (int __user *)user_arg))\n\t\treturn -EFAULT;\n\n\tif ((buf = kmalloc(HID_STRING_SIZE, GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\n\tif ((len = usb_string(dev, idx, buf, HID_STRING_SIZE-1)) < 0) {\n\t\tkfree(buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_to_user(user_arg+sizeof(int), buf, len+1)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(buf);\n\n\treturn len;\n}\n\nstatic long hiddev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hiddev_list *list = file->private_data;\n\tstruct hiddev *hiddev = list->hiddev;\n\tstruct hid_device *hid;\n\tstruct hiddev_collection_info cinfo;\n\tstruct hiddev_report_info rinfo;\n\tstruct hiddev_field_info finfo;\n\tstruct hiddev_devinfo dinfo;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tvoid __user *user_arg = (void __user *)arg;\n\tint i, r = -EINVAL;\n\n\t \n\n\tmutex_lock(&hiddev->existancelock);\n\tif (!hiddev->exist) {\n\t\tr = -ENODEV;\n\t\tgoto ret_unlock;\n\t}\n\n\thid = hiddev->hid;\n\n\tswitch (cmd) {\n\n\tcase HIDIOCGVERSION:\n\t\tr = put_user(HID_VERSION, (int __user *)arg) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\n\tcase HIDIOCAPPLICATION:\n\t\tif (arg >= hid->maxapplication)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < hid->maxcollection; i++)\n\t\t\tif (hid->collection[i].type ==\n\t\t\t    HID_COLLECTION_APPLICATION && arg-- == 0)\n\t\t\t\tbreak;\n\n\t\tif (i < hid->maxcollection)\n\t\t\tr = hid->collection[i].usage;\n\t\tbreak;\n\n\tcase HIDIOCGDEVINFO:\n\t\t{\n\t\t\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\t\t\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\t\t\tmemset(&dinfo, 0, sizeof(dinfo));\n\n\t\t\tdinfo.bustype = BUS_USB;\n\t\t\tdinfo.busnum = dev->bus->busnum;\n\t\t\tdinfo.devnum = dev->devnum;\n\t\t\tdinfo.ifnum = usbhid->ifnum;\n\t\t\tdinfo.vendor = le16_to_cpu(dev->descriptor.idVendor);\n\t\t\tdinfo.product = le16_to_cpu(dev->descriptor.idProduct);\n\t\t\tdinfo.version = le16_to_cpu(dev->descriptor.bcdDevice);\n\t\t\tdinfo.num_applications = hid->maxapplication;\n\n\t\t\tr = copy_to_user(user_arg, &dinfo, sizeof(dinfo)) ?\n\t\t\t\t-EFAULT : 0;\n\t\t\tbreak;\n\t\t}\n\n\tcase HIDIOCGFLAG:\n\t\tr = put_user(list->flags, (int __user *)arg) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\n\tcase HIDIOCSFLAG:\n\t\t{\n\t\t\tint newflags;\n\n\t\t\tif (get_user(newflags, (int __user *)arg)) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((newflags & ~HIDDEV_FLAGS) != 0 ||\n\t\t\t    ((newflags & HIDDEV_FLAG_REPORT) != 0 &&\n\t\t\t     (newflags & HIDDEV_FLAG_UREF) == 0))\n\t\t\t\tbreak;\n\n\t\t\tlist->flags = newflags;\n\n\t\t\tr = 0;\n\t\t\tbreak;\n\t\t}\n\n\tcase HIDIOCGSTRING:\n\t\tr = hiddev_ioctl_string(hiddev, cmd, user_arg);\n\t\tbreak;\n\n\tcase HIDIOCINITREPORT:\n\t\tusbhid_init_reports(hid);\n\t\thiddev->initialized = true;\n\t\tr = 0;\n\t\tbreak;\n\n\tcase HIDIOCGREPORT:\n\t\tif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rinfo.report_type == HID_REPORT_TYPE_OUTPUT)\n\t\t\tbreak;\n\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\n\t\thid_hw_request(hid, report, HID_REQ_GET_REPORT);\n\t\thid_hw_wait(hid);\n\n\t\tr = 0;\n\t\tbreak;\n\n\tcase HIDIOCSREPORT:\n\t\tif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rinfo.report_type == HID_REPORT_TYPE_INPUT)\n\t\t\tbreak;\n\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\n\t\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\t\thid_hw_wait(hid);\n\n\t\tr = 0;\n\t\tbreak;\n\n\tcase HIDIOCGREPORTINFO:\n\t\tif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\n\t\trinfo.num_fields = report->maxfield;\n\n\t\tr = copy_to_user(user_arg, &rinfo, sizeof(rinfo)) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\n\tcase HIDIOCGFIELDINFO:\n\t\tif (copy_from_user(&finfo, user_arg, sizeof(finfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trinfo.report_type = finfo.report_type;\n\t\trinfo.report_id = finfo.report_id;\n\n\t\treport = hiddev_lookup_report(hid, &rinfo);\n\t\tif (report == NULL)\n\t\t\tbreak;\n\n\t\tif (finfo.field_index >= report->maxfield)\n\t\t\tbreak;\n\t\tfinfo.field_index = array_index_nospec(finfo.field_index,\n\t\t\t\t\t\t       report->maxfield);\n\n\t\tfield = report->field[finfo.field_index];\n\t\tmemset(&finfo, 0, sizeof(finfo));\n\t\tfinfo.report_type = rinfo.report_type;\n\t\tfinfo.report_id = rinfo.report_id;\n\t\tfinfo.field_index = field->report_count - 1;\n\t\tfinfo.maxusage = field->maxusage;\n\t\tfinfo.flags = field->flags;\n\t\tfinfo.physical = field->physical;\n\t\tfinfo.logical = field->logical;\n\t\tfinfo.application = field->application;\n\t\tfinfo.logical_minimum = field->logical_minimum;\n\t\tfinfo.logical_maximum = field->logical_maximum;\n\t\tfinfo.physical_minimum = field->physical_minimum;\n\t\tfinfo.physical_maximum = field->physical_maximum;\n\t\tfinfo.unit_exponent = field->unit_exponent;\n\t\tfinfo.unit = field->unit;\n\n\t\tr = copy_to_user(user_arg, &finfo, sizeof(finfo)) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\n\tcase HIDIOCGUCODE:\n\tcase HIDIOCGUSAGE:\n\tcase HIDIOCSUSAGE:\n\tcase HIDIOCGUSAGES:\n\tcase HIDIOCSUSAGES:\n\tcase HIDIOCGCOLLECTIONINDEX:\n\t\tif (!hiddev->initialized) {\n\t\t\tusbhid_init_reports(hid);\n\t\t\thiddev->initialized = true;\n\t\t}\n\t\tr = hiddev_ioctl_usage(hiddev, cmd, user_arg);\n\t\tbreak;\n\n\tcase HIDIOCGCOLLECTIONINFO:\n\t\tif (copy_from_user(&cinfo, user_arg, sizeof(cinfo))) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cinfo.index >= hid->maxcollection)\n\t\t\tbreak;\n\t\tcinfo.index = array_index_nospec(cinfo.index,\n\t\t\t\t\t\t hid->maxcollection);\n\n\t\tcinfo.type = hid->collection[cinfo.index].type;\n\t\tcinfo.usage = hid->collection[cinfo.index].usage;\n\t\tcinfo.level = hid->collection[cinfo.index].level;\n\n\t\tr = copy_to_user(user_arg, &cinfo, sizeof(cinfo)) ?\n\t\t\t-EFAULT : 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (_IOC_TYPE(cmd) != 'H' || _IOC_DIR(cmd) != _IOC_READ)\n\t\t\tbreak;\n\n\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGNAME(0))) {\n\t\t\tint len = strlen(hid->name) + 1;\n\t\t\tif (len > _IOC_SIZE(cmd))\n\t\t\t\t len = _IOC_SIZE(cmd);\n\t\t\tr = copy_to_user(user_arg, hid->name, len) ?\n\t\t\t\t-EFAULT : len;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGPHYS(0))) {\n\t\t\tint len = strlen(hid->phys) + 1;\n\t\t\tif (len > _IOC_SIZE(cmd))\n\t\t\t\tlen = _IOC_SIZE(cmd);\n\t\t\tr = copy_to_user(user_arg, hid->phys, len) ?\n\t\t\t\t-EFAULT : len;\n\t\t\tbreak;\n\t\t}\n\t}\n\nret_unlock:\n\tmutex_unlock(&hiddev->existancelock);\n\treturn r;\n}\n\nstatic const struct file_operations hiddev_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\thiddev_read,\n\t.write =\thiddev_write,\n\t.poll =\t\thiddev_poll,\n\t.open =\t\thiddev_open,\n\t.release =\thiddev_release,\n\t.unlocked_ioctl =\thiddev_ioctl,\n\t.fasync =\thiddev_fasync,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic char *hiddev_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"usb/%s\", dev_name(dev));\n}\n\nstatic struct usb_class_driver hiddev_class = {\n\t.name =\t\t\"hiddev%d\",\n\t.devnode =\thiddev_devnode,\n\t.fops =\t\t&hiddev_fops,\n\t.minor_base =\tHIDDEV_MINOR_BASE,\n};\n\n \nint hiddev_connect(struct hid_device *hid, unsigned int force)\n{\n\tstruct hiddev *hiddev;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint retval;\n\n\tif (!force) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < hid->maxcollection; i++)\n\t\t\tif (hid->collection[i].type ==\n\t\t\t    HID_COLLECTION_APPLICATION &&\n\t\t\t    !IS_INPUT_APPLICATION(hid->collection[i].usage))\n\t\t\t\tbreak;\n\n\t\tif (i == hid->maxcollection)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(hiddev = kzalloc(sizeof(struct hiddev), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&hiddev->wait);\n\tINIT_LIST_HEAD(&hiddev->list);\n\tspin_lock_init(&hiddev->list_lock);\n\tmutex_init(&hiddev->existancelock);\n\thid->hiddev = hiddev;\n\thiddev->hid = hid;\n\thiddev->exist = 1;\n\tretval = usb_register_dev(usbhid->intf, &hiddev_class);\n\tif (retval) {\n\t\thid_err(hid, \"Not able to get a minor for this device\\n\");\n\t\thid->hiddev = NULL;\n\t\tkfree(hiddev);\n\t\treturn retval;\n\t}\n\n\t \n\thiddev->initialized = hid->quirks & HID_QUIRK_NO_INIT_REPORTS;\n\n\thiddev->minor = usbhid->intf->minor;\n\n\treturn 0;\n}\n\n \nstatic struct usb_class_driver hiddev_class;\nvoid hiddev_disconnect(struct hid_device *hid)\n{\n\tstruct hiddev *hiddev = hid->hiddev;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tusb_deregister_dev(usbhid->intf, &hiddev_class);\n\n\tmutex_lock(&hiddev->existancelock);\n\thiddev->exist = 0;\n\n\tif (hiddev->open) {\n\t\thid_hw_close(hiddev->hid);\n\t\twake_up_interruptible(&hiddev->wait);\n\t\tmutex_unlock(&hiddev->existancelock);\n\t} else {\n\t\tmutex_unlock(&hiddev->existancelock);\n\t\tkfree(hiddev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}