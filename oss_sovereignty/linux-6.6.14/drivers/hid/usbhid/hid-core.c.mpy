{
  "module_name": "hid-core.c",
  "hash_id": "998aa4372b97468fd605c10b7c3c8d8a0e5146dea77658f542afff1f3894daea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/usbhid/hid-core.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/input.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/string.h>\n\n#include <linux/usb.h>\n\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/hid-debug.h>\n#include <linux/hidraw.h>\n#include \"usbhid.h\"\n\n \n\n#define DRIVER_DESC \"USB HID core driver\"\n\n \n\nstatic unsigned int hid_mousepoll_interval;\nmodule_param_named(mousepoll, hid_mousepoll_interval, uint, 0644);\nMODULE_PARM_DESC(mousepoll, \"Polling interval of mice\");\n\nstatic unsigned int hid_jspoll_interval;\nmodule_param_named(jspoll, hid_jspoll_interval, uint, 0644);\nMODULE_PARM_DESC(jspoll, \"Polling interval of joysticks\");\n\nstatic unsigned int hid_kbpoll_interval;\nmodule_param_named(kbpoll, hid_kbpoll_interval, uint, 0644);\nMODULE_PARM_DESC(kbpoll, \"Polling interval of keyboards\");\n\nstatic unsigned int ignoreled;\nmodule_param_named(ignoreled, ignoreled, uint, 0644);\nMODULE_PARM_DESC(ignoreled, \"Autosuspend with active leds\");\n\n \nstatic char *quirks_param[MAX_USBHID_BOOT_QUIRKS];\nmodule_param_array_named(quirks, quirks_param, charp, NULL, 0444);\nMODULE_PARM_DESC(quirks, \"Add/modify USB HID quirks by specifying \"\n\t\t\" quirks=vendorID:productID:quirks\"\n\t\t\" where vendorID, productID, and quirks are all in\"\n\t\t\" 0x-prefixed hex\");\n \nstatic void hid_io_error(struct hid_device *hid);\nstatic int hid_submit_out(struct hid_device *hid);\nstatic int hid_submit_ctrl(struct hid_device *hid);\nstatic void hid_cancel_delayed_stuff(struct usbhid_device *usbhid);\n\n \nstatic int hid_start_in(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\tif (test_bit(HID_IN_POLLING, &usbhid->iofl) &&\n\t    !test_bit(HID_DISCONNECTED, &usbhid->iofl) &&\n\t    !test_bit(HID_SUSPENDED, &usbhid->iofl) &&\n\t    !test_and_set_bit(HID_IN_RUNNING, &usbhid->iofl)) {\n\t\trc = usb_submit_urb(usbhid->urbin, GFP_ATOMIC);\n\t\tif (rc != 0) {\n\t\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\t\tif (rc == -ENOSPC)\n\t\t\t\tset_bit(HID_NO_BANDWIDTH, &usbhid->iofl);\n\t\t} else {\n\t\t\tclear_bit(HID_NO_BANDWIDTH, &usbhid->iofl);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\treturn rc;\n}\n\n \nstatic void hid_retry_timeout(struct timer_list *t)\n{\n\tstruct usbhid_device *usbhid = from_timer(usbhid, t, io_retry);\n\tstruct hid_device *hid = usbhid->hid;\n\n\tdev_dbg(&usbhid->intf->dev, \"retrying intr urb\\n\");\n\tif (hid_start_in(hid))\n\t\thid_io_error(hid);\n}\n\n \nstatic void hid_reset(struct work_struct *work)\n{\n\tstruct usbhid_device *usbhid =\n\t\tcontainer_of(work, struct usbhid_device, reset_work);\n\tstruct hid_device *hid = usbhid->hid;\n\tint rc;\n\n\tif (test_bit(HID_CLEAR_HALT, &usbhid->iofl)) {\n\t\tdev_dbg(&usbhid->intf->dev, \"clear halt\\n\");\n\t\trc = usb_clear_halt(hid_to_usb_dev(hid), usbhid->urbin->pipe);\n\t\tclear_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\t\tif (rc == 0) {\n\t\t\thid_start_in(hid);\n\t\t} else {\n\t\t\tdev_dbg(&usbhid->intf->dev,\n\t\t\t\t\t\"clear-halt failed: %d\\n\", rc);\n\t\t\tset_bit(HID_RESET_PENDING, &usbhid->iofl);\n\t\t}\n\t}\n\n\tif (test_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\t\tdev_dbg(&usbhid->intf->dev, \"resetting device\\n\");\n\t\tusb_queue_reset_device(usbhid->intf);\n\t}\n}\n\n \nstatic void hid_io_error(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\t \n\tif (test_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\tgoto done;\n\n\t \n\tif (time_after(jiffies, usbhid->stop_retry + HZ/2))\n\t\tusbhid->retry_delay = 0;\n\n\t \n\tif (usbhid->retry_delay == 0) {\n\t\tusbhid->retry_delay = 13;\t \n\t\tusbhid->stop_retry = jiffies + msecs_to_jiffies(1000);\n\t} else if (usbhid->retry_delay < 100)\n\t\tusbhid->retry_delay *= 2;\n\n\tif (time_after(jiffies, usbhid->stop_retry)) {\n\n\t\t \n\t\tif (!test_bit(HID_NO_BANDWIDTH, &usbhid->iofl)\n\t\t     && !test_and_set_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\n\t\t\tschedule_work(&usbhid->reset_work);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmod_timer(&usbhid->io_retry,\n\t\t\tjiffies + msecs_to_jiffies(usbhid->retry_delay));\ndone:\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\n\nstatic void usbhid_mark_busy(struct usbhid_device *usbhid)\n{\n\tstruct usb_interface *intf = usbhid->intf;\n\n\tusb_mark_last_busy(interface_to_usbdev(intf));\n}\n\nstatic int usbhid_restart_out_queue(struct usbhid_device *usbhid)\n{\n\tstruct hid_device *hid = usb_get_intfdata(usbhid->intf);\n\tint kicked;\n\tint r;\n\n\tif (!hid || test_bit(HID_RESET_PENDING, &usbhid->iofl) ||\n\t\t\ttest_bit(HID_SUSPENDED, &usbhid->iofl))\n\t\treturn 0;\n\n\tif ((kicked = (usbhid->outhead != usbhid->outtail))) {\n\t\thid_dbg(hid, \"Kicking head %d tail %d\", usbhid->outhead, usbhid->outtail);\n\n\t\t \n\t\tr = usb_autopm_get_interface_async(usbhid->intf);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\t \n\t\tif (test_bit(HID_SUSPENDED, &usbhid->iofl)) {\n\t\t\tusb_autopm_put_interface_no_suspend(usbhid->intf);\n\t\t\treturn r;\n\t\t}\n\n\t\t \n\t\tset_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\t\tif (hid_submit_out(hid)) {\n\t\t\tclear_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\twake_up(&usbhid->wait);\n\t}\n\treturn kicked;\n}\n\nstatic int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)\n{\n\tstruct hid_device *hid = usb_get_intfdata(usbhid->intf);\n\tint kicked;\n\tint r;\n\n\tWARN_ON(hid == NULL);\n\tif (!hid || test_bit(HID_RESET_PENDING, &usbhid->iofl) ||\n\t\t\ttest_bit(HID_SUSPENDED, &usbhid->iofl))\n\t\treturn 0;\n\n\tif ((kicked = (usbhid->ctrlhead != usbhid->ctrltail))) {\n\t\thid_dbg(hid, \"Kicking head %d tail %d\", usbhid->ctrlhead, usbhid->ctrltail);\n\n\t\t \n\t\tr = usb_autopm_get_interface_async(usbhid->intf);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\t \n\t\tif (test_bit(HID_SUSPENDED, &usbhid->iofl)) {\n\t\t\tusb_autopm_put_interface_no_suspend(usbhid->intf);\n\t\t\treturn r;\n\t\t}\n\n\t\t \n\t\tset_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\t\tif (hid_submit_ctrl(hid)) {\n\t\t\tclear_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\twake_up(&usbhid->wait);\n\t}\n\treturn kicked;\n}\n\n \n\nstatic void hid_irq_in(struct urb *urb)\n{\n\tstruct hid_device\t*hid = urb->context;\n\tstruct usbhid_device\t*usbhid = hid->driver_data;\n\tint\t\t\tstatus;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t \n\t\tusbhid->retry_delay = 0;\n\t\tif (!test_bit(HID_OPENED, &usbhid->iofl))\n\t\t\tbreak;\n\t\tusbhid_mark_busy(usbhid);\n\t\tif (!test_bit(HID_RESUME_RUNNING, &usbhid->iofl)) {\n\t\t\thid_input_report(urb->context, HID_INPUT_REPORT,\n\t\t\t\t\t urb->transfer_buffer,\n\t\t\t\t\t urb->actual_length, 1);\n\t\t\t \n\t\t\tif (hid_check_keys_pressed(hid))\n\t\t\t\tset_bit(HID_KEYS_PRESSED, &usbhid->iofl);\n\t\t\telse\n\t\t\t\tclear_bit(HID_KEYS_PRESSED, &usbhid->iofl);\n\t\t}\n\t\tbreak;\n\tcase -EPIPE:\t\t \n\t\tusbhid_mark_busy(usbhid);\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\tset_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\t\tschedule_work(&usbhid->reset_work);\n\t\treturn;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\t \n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\treturn;\n\tcase -EILSEQ:\t\t \n\tcase -EPROTO:\t\t \n\tcase -ETIME:\t\t \n\tcase -ETIMEDOUT:\t \n\t\tusbhid_mark_busy(usbhid);\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\thid_io_error(hid);\n\t\treturn;\n\tdefault:\t\t \n\t\thid_warn(urb->dev, \"input irq status %d received\\n\",\n\t\t\t urb->status);\n\t}\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\tclear_bit(HID_IN_RUNNING, &usbhid->iofl);\n\t\tif (status != -EPERM) {\n\t\t\thid_err(hid, \"can't resubmit intr, %s-%s/input%d, status %d\\n\",\n\t\t\t\thid_to_usb_dev(hid)->bus->bus_name,\n\t\t\t\thid_to_usb_dev(hid)->devpath,\n\t\t\t\tusbhid->ifnum, status);\n\t\t\thid_io_error(hid);\n\t\t}\n\t}\n}\n\nstatic int hid_submit_out(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tchar *raw_report;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint r;\n\n\treport = usbhid->out[usbhid->outtail].report;\n\traw_report = usbhid->out[usbhid->outtail].raw_report;\n\n\tusbhid->urbout->transfer_buffer_length = hid_report_len(report);\n\tusbhid->urbout->dev = hid_to_usb_dev(hid);\n\tif (raw_report) {\n\t\tmemcpy(usbhid->outbuf, raw_report,\n\t\t\t\tusbhid->urbout->transfer_buffer_length);\n\t\tkfree(raw_report);\n\t\tusbhid->out[usbhid->outtail].raw_report = NULL;\n\t}\n\n\tdbg_hid(\"submitting out urb\\n\");\n\n\tr = usb_submit_urb(usbhid->urbout, GFP_ATOMIC);\n\tif (r < 0) {\n\t\thid_err(hid, \"usb_submit_urb(out) failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\tusbhid->last_out = jiffies;\n\treturn 0;\n}\n\nstatic int hid_submit_ctrl(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tunsigned char dir;\n\tchar *raw_report;\n\tint len, r;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\treport = usbhid->ctrl[usbhid->ctrltail].report;\n\traw_report = usbhid->ctrl[usbhid->ctrltail].raw_report;\n\tdir = usbhid->ctrl[usbhid->ctrltail].dir;\n\n\tlen = hid_report_len(report);\n\tif (dir == USB_DIR_OUT) {\n\t\tusbhid->urbctrl->pipe = usb_sndctrlpipe(hid_to_usb_dev(hid), 0);\n\t\tif (raw_report) {\n\t\t\tmemcpy(usbhid->ctrlbuf, raw_report, len);\n\t\t\tkfree(raw_report);\n\t\t\tusbhid->ctrl[usbhid->ctrltail].raw_report = NULL;\n\t\t}\n\t} else {\n\t\tint maxpacket;\n\n\t\tusbhid->urbctrl->pipe = usb_rcvctrlpipe(hid_to_usb_dev(hid), 0);\n\t\tmaxpacket = usb_maxpacket(hid_to_usb_dev(hid),\n\t\t\t\t\t  usbhid->urbctrl->pipe);\n\t\tlen += (len == 0);\t \n\t\tlen = round_up(len, maxpacket);\n\t\tif (len > usbhid->bufsize)\n\t\t\tlen = usbhid->bufsize;\n\t}\n\tusbhid->urbctrl->transfer_buffer_length = len;\n\tusbhid->urbctrl->dev = hid_to_usb_dev(hid);\n\n\tusbhid->cr->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE | dir;\n\tusbhid->cr->bRequest = (dir == USB_DIR_OUT) ? HID_REQ_SET_REPORT :\n\t\t\t\t\t\t      HID_REQ_GET_REPORT;\n\tusbhid->cr->wValue = cpu_to_le16(((report->type + 1) << 8) |\n\t\t\t\t\t report->id);\n\tusbhid->cr->wIndex = cpu_to_le16(usbhid->ifnum);\n\tusbhid->cr->wLength = cpu_to_le16(len);\n\n\tdbg_hid(\"submitting ctrl urb: %s wValue=0x%04x wIndex=0x%04x wLength=%u\\n\",\n\t\tusbhid->cr->bRequest == HID_REQ_SET_REPORT ? \"Set_Report\" :\n\t\t\t\t\t\t\t     \"Get_Report\",\n\t\tusbhid->cr->wValue, usbhid->cr->wIndex, usbhid->cr->wLength);\n\n\tr = usb_submit_urb(usbhid->urbctrl, GFP_ATOMIC);\n\tif (r < 0) {\n\t\thid_err(hid, \"usb_submit_urb(ctrl) failed: %d\\n\", r);\n\t\treturn r;\n\t}\n\tusbhid->last_ctrl = jiffies;\n\treturn 0;\n}\n\n \n\nstatic void hid_irq_out(struct urb *urb)\n{\n\tstruct hid_device *hid = urb->context;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned long flags;\n\tint unplug = 0;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t \n\t\tbreak;\n\tcase -ESHUTDOWN:\t \n\t\tunplug = 1;\n\t\tbreak;\n\tcase -EILSEQ:\t\t \n\tcase -EPROTO:\t\t \n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\t\t \n\t\thid_warn(urb->dev, \"output irq status %d received\\n\",\n\t\t\t urb->status);\n\t}\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\tif (unplug) {\n\t\tusbhid->outtail = usbhid->outhead;\n\t} else {\n\t\tusbhid->outtail = (usbhid->outtail + 1) & (HID_OUTPUT_FIFO_SIZE - 1);\n\n\t\tif (usbhid->outhead != usbhid->outtail &&\n\t\t\t\thid_submit_out(hid) == 0) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclear_bit(HID_OUT_RUNNING, &usbhid->iofl);\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\tusb_autopm_put_interface_async(usbhid->intf);\n\twake_up(&usbhid->wait);\n}\n\n \n\nstatic void hid_ctrl(struct urb *urb)\n{\n\tstruct hid_device *hid = urb->context;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned long flags;\n\tint unplug = 0, status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t \n\t\tif (usbhid->ctrl[usbhid->ctrltail].dir == USB_DIR_IN)\n\t\t\thid_input_report(urb->context,\n\t\t\t\tusbhid->ctrl[usbhid->ctrltail].report->type,\n\t\t\t\turb->transfer_buffer, urb->actual_length, 0);\n\t\tbreak;\n\tcase -ESHUTDOWN:\t \n\t\tunplug = 1;\n\t\tbreak;\n\tcase -EILSEQ:\t\t \n\tcase -EPROTO:\t\t \n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -EPIPE:\t\t \n\t\tbreak;\n\tdefault:\t\t \n\t\thid_warn(urb->dev, \"ctrl urb status %d received\\n\", status);\n\t}\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\tif (unplug) {\n\t\tusbhid->ctrltail = usbhid->ctrlhead;\n\t} else if (usbhid->ctrlhead != usbhid->ctrltail) {\n\t\tusbhid->ctrltail = (usbhid->ctrltail + 1) & (HID_CONTROL_FIFO_SIZE - 1);\n\n\t\tif (usbhid->ctrlhead != usbhid->ctrltail &&\n\t\t\t\thid_submit_ctrl(hid) == 0) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclear_bit(HID_CTRL_RUNNING, &usbhid->iofl);\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n\tusb_autopm_put_interface_async(usbhid->intf);\n\twake_up(&usbhid->wait);\n}\n\nstatic void __usbhid_submit_report(struct hid_device *hid, struct hid_report *report,\n\t\t\t\t   unsigned char dir)\n{\n\tint head;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (((hid->quirks & HID_QUIRK_NOGET) && dir == USB_DIR_IN) ||\n\t\ttest_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\treturn;\n\n\tif (usbhid->urbout && dir == USB_DIR_OUT && report->type == HID_OUTPUT_REPORT) {\n\t\tif ((head = (usbhid->outhead + 1) & (HID_OUTPUT_FIFO_SIZE - 1)) == usbhid->outtail) {\n\t\t\thid_warn(hid, \"output queue full\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tusbhid->out[usbhid->outhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);\n\t\tif (!usbhid->out[usbhid->outhead].raw_report) {\n\t\t\thid_warn(hid, \"output queueing failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\thid_output_report(report, usbhid->out[usbhid->outhead].raw_report);\n\t\tusbhid->out[usbhid->outhead].report = report;\n\t\tusbhid->outhead = head;\n\n\t\t \n\t\tif (!test_bit(HID_OUT_RUNNING, &usbhid->iofl)) {\n\t\t\tusbhid_restart_out_queue(usbhid);\n\n\t\t \n\t\t} else if (time_after(jiffies, usbhid->last_out + HZ * 5)) {\n\n\t\t\t \n\t\t\tusb_autopm_get_interface_no_resume(usbhid->intf);\n\n\t\t\t \n\t\t\tusb_block_urb(usbhid->urbout);\n\n\t\t\t \n\t\t\tspin_unlock(&usbhid->lock);\n\n\t\t\tusb_unlink_urb(usbhid->urbout);\n\t\t\tspin_lock(&usbhid->lock);\n\t\t\tusb_unblock_urb(usbhid->urbout);\n\n\t\t\t \n\t\t\tif (!test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\t\t\tusbhid_restart_out_queue(usbhid);\n\n\t\t\t \n\t\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((head = (usbhid->ctrlhead + 1) & (HID_CONTROL_FIFO_SIZE - 1)) == usbhid->ctrltail) {\n\t\thid_warn(hid, \"control queue full\\n\");\n\t\treturn;\n\t}\n\n\tif (dir == USB_DIR_OUT) {\n\t\tusbhid->ctrl[usbhid->ctrlhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);\n\t\tif (!usbhid->ctrl[usbhid->ctrlhead].raw_report) {\n\t\t\thid_warn(hid, \"control queueing failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\thid_output_report(report, usbhid->ctrl[usbhid->ctrlhead].raw_report);\n\t}\n\tusbhid->ctrl[usbhid->ctrlhead].report = report;\n\tusbhid->ctrl[usbhid->ctrlhead].dir = dir;\n\tusbhid->ctrlhead = head;\n\n\t \n\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl)) {\n\t\tusbhid_restart_ctrl_queue(usbhid);\n\n\t \n\t} else if (time_after(jiffies, usbhid->last_ctrl + HZ * 5)) {\n\n\t\t \n\t\tusb_autopm_get_interface_no_resume(usbhid->intf);\n\n\t\t \n\t\tusb_block_urb(usbhid->urbctrl);\n\n\t\t \n\t\tspin_unlock(&usbhid->lock);\n\n\t\tusb_unlink_urb(usbhid->urbctrl);\n\t\tspin_lock(&usbhid->lock);\n\t\tusb_unblock_urb(usbhid->urbctrl);\n\n\t\t \n\t\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\t\tusbhid_restart_ctrl_queue(usbhid);\n\n\t\t \n\t\tusb_autopm_put_interface_async(usbhid->intf);\n\t}\n}\n\nstatic void usbhid_submit_report(struct hid_device *hid, struct hid_report *report, unsigned char dir)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\t__usbhid_submit_report(hid, report, dir);\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\n\nstatic int usbhid_wait_io(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (!wait_event_timeout(usbhid->wait,\n\t\t\t\t(!test_bit(HID_CTRL_RUNNING, &usbhid->iofl) &&\n\t\t\t\t!test_bit(HID_OUT_RUNNING, &usbhid->iofl)),\n\t\t\t\t\t10*HZ)) {\n\t\tdbg_hid(\"timeout waiting for ctrl or out queue to clear\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int hid_set_idle(struct usb_device *dev, int ifnum, int report, int idle)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\tHID_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE, (idle << 8) | report,\n\t\tifnum, NULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\nstatic int hid_get_class_descriptor(struct usb_device *dev, int ifnum,\n\t\tunsigned char type, void *buf, int size)\n{\n\tint result, retries = 4;\n\n\tmemset(buf, 0, size);\n\n\tdo {\n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t(type << 8), ifnum, buf, size, USB_CTRL_GET_TIMEOUT);\n\t\tretries--;\n\t} while (result < size && retries);\n\treturn result;\n}\n\nstatic int usbhid_open(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint res;\n\n\tmutex_lock(&usbhid->mutex);\n\n\tset_bit(HID_OPENED, &usbhid->iofl);\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL) {\n\t\tres = 0;\n\t\tgoto Done;\n\t}\n\n\tres = usb_autopm_get_interface(usbhid->intf);\n\t \n\tif (res < 0) {\n\t\tclear_bit(HID_OPENED, &usbhid->iofl);\n\t\tres = -EIO;\n\t\tgoto Done;\n\t}\n\n\tusbhid->intf->needs_remote_wakeup = 1;\n\n\tset_bit(HID_RESUME_RUNNING, &usbhid->iofl);\n\tset_bit(HID_IN_POLLING, &usbhid->iofl);\n\n\tres = hid_start_in(hid);\n\tif (res) {\n\t\tif (res != -ENOSPC) {\n\t\t\thid_io_error(hid);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t \n\t\t\tres = -EBUSY;\n\t\t\tclear_bit(HID_OPENED, &usbhid->iofl);\n\t\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\t\tusbhid->intf->needs_remote_wakeup = 0;\n\t\t}\n\t}\n\n\tusb_autopm_put_interface(usbhid->intf);\n\n\t \n\tif (res == 0)\n\t\tmsleep(50);\n\n\tclear_bit(HID_RESUME_RUNNING, &usbhid->iofl);\n\n Done:\n\tmutex_unlock(&usbhid->mutex);\n\treturn res;\n}\n\nstatic void usbhid_close(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tmutex_lock(&usbhid->mutex);\n\n\t \n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_OPENED, &usbhid->iofl);\n\tif (!(hid->quirks & HID_QUIRK_ALWAYS_POLL))\n\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\n\tif (!(hid->quirks & HID_QUIRK_ALWAYS_POLL)) {\n\t\thid_cancel_delayed_stuff(usbhid);\n\t\tusb_kill_urb(usbhid->urbin);\n\t\tusbhid->intf->needs_remote_wakeup = 0;\n\t}\n\n\tmutex_unlock(&usbhid->mutex);\n}\n\n \n\nvoid usbhid_init_reports(struct hid_device *hid)\n{\n\tstruct hid_report *report;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct hid_report_enum *report_enum;\n\tint err, ret;\n\n\treport_enum = &hid->report_enum[HID_INPUT_REPORT];\n\tlist_for_each_entry(report, &report_enum->report_list, list)\n\t\tusbhid_submit_report(hid, report, USB_DIR_IN);\n\n\treport_enum = &hid->report_enum[HID_FEATURE_REPORT];\n\tlist_for_each_entry(report, &report_enum->report_list, list)\n\t\tusbhid_submit_report(hid, report, USB_DIR_IN);\n\n\terr = 0;\n\tret = usbhid_wait_io(hid);\n\twhile (ret) {\n\t\terr |= ret;\n\t\tif (test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\t\tusb_kill_urb(usbhid->urbctrl);\n\t\tif (test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\t\tusb_kill_urb(usbhid->urbout);\n\t\tret = usbhid_wait_io(hid);\n\t}\n\n\tif (err)\n\t\thid_warn(hid, \"timeout initializing reports\\n\");\n}\n\n \nstatic int hid_find_field_early(struct hid_device *hid, unsigned int page,\n    unsigned int hid_code, struct hid_field **pfield)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tstruct hid_usage *usage;\n\tint i, j;\n\n\tlist_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {\n\t\tfor (i = 0; i < report->maxfield; i++) {\n\t\t\tfield = report->field[i];\n\t\t\tfor (j = 0; j < field->maxusage; j++) {\n\t\t\t\tusage = &field->usage[j];\n\t\t\t\tif ((usage->hid & HID_USAGE_PAGE) == page &&\n\t\t\t\t    (usage->hid & 0xFFFF) == hid_code) {\n\t\t\t\t\t*pfield = field;\n\t\t\t\t\treturn j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void usbhid_set_leds(struct hid_device *hid)\n{\n\tstruct hid_field *field;\n\tint offset;\n\n\tif ((offset = hid_find_field_early(hid, HID_UP_LED, 0x01, &field)) != -1) {\n\t\thid_set_field(field, offset, 0);\n\t\tusbhid_submit_report(hid, field->report, USB_DIR_OUT);\n\t}\n}\n\n \nstatic void hid_find_max_report(struct hid_device *hid, unsigned int type,\n\t\tunsigned int *max)\n{\n\tstruct hid_report *report;\n\tunsigned int size;\n\n\tlist_for_each_entry(report, &hid->report_enum[type].report_list, list) {\n\t\tsize = ((report->size - 1) >> 3) + 1 + hid->report_enum[type].numbered;\n\t\tif (*max < size)\n\t\t\t*max = size;\n\t}\n}\n\nstatic int hid_alloc_buffers(struct usb_device *dev, struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tusbhid->inbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->inbuf_dma);\n\tusbhid->outbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->outbuf_dma);\n\tusbhid->cr = kmalloc(sizeof(*usbhid->cr), GFP_KERNEL);\n\tusbhid->ctrlbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,\n\t\t\t&usbhid->ctrlbuf_dma);\n\tif (!usbhid->inbuf || !usbhid->outbuf || !usbhid->cr ||\n\t\t\t!usbhid->ctrlbuf)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int usbhid_get_raw_report(struct hid_device *hid,\n\t\tunsigned char report_number, __u8 *buf, size_t count,\n\t\tunsigned char report_type)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = usbhid->intf;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint skipped_report_id = 0;\n\tint ret;\n\n\t \n\tbuf[0] = report_number;\n\tif (report_number == 0x0) {\n\t\t \n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\tHID_REQ_GET_REPORT,\n\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t((report_type + 1) << 8) | report_number,\n\t\tinterface->desc.bInterfaceNumber, buf, count,\n\t\tUSB_CTRL_SET_TIMEOUT);\n\n\t \n\tif (ret > 0 && skipped_report_id)\n\t\tret++;\n\n\treturn ret;\n}\n\nstatic int usbhid_set_raw_report(struct hid_device *hid, unsigned int reportnum,\n\t\t\t\t __u8 *buf, size_t count, unsigned char rtype)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = usbhid->intf;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint ret, skipped_report_id = 0;\n\n\t \n\tif ((rtype == HID_OUTPUT_REPORT) &&\n\t    (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORT_ID))\n\t\tbuf[0] = 0;\n\telse\n\t\tbuf[0] = reportnum;\n\n\tif (buf[0] == 0x0) {\n\t\t \n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tHID_REQ_SET_REPORT,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t((rtype + 1) << 8) | reportnum,\n\t\t\tinterface->desc.bInterfaceNumber, buf, count,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t \n\tif (ret > 0 && skipped_report_id)\n\t\tret++;\n\n\treturn ret;\n}\n\nstatic int usbhid_output_report(struct hid_device *hid, __u8 *buf, size_t count)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tint actual_length, skipped_report_id = 0, ret;\n\n\tif (!usbhid->urbout)\n\t\treturn -ENOSYS;\n\n\tif (buf[0] == 0x0) {\n\t\t \n\t\tbuf++;\n\t\tcount--;\n\t\tskipped_report_id = 1;\n\t}\n\n\tret = usb_interrupt_msg(dev, usbhid->urbout->pipe,\n\t\t\t\tbuf, count, &actual_length,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t \n\tif (ret == 0) {\n\t\tret = actual_length;\n\t\t \n\t\tif (skipped_report_id)\n\t\t\tret++;\n\t}\n\n\treturn ret;\n}\n\nstatic void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->inbuf, usbhid->inbuf_dma);\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->outbuf, usbhid->outbuf_dma);\n\tkfree(usbhid->cr);\n\tusb_free_coherent(dev, usbhid->bufsize, usbhid->ctrlbuf, usbhid->ctrlbuf_dma);\n}\n\nstatic int usbhid_parse(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_descriptor *hdesc;\n\tu32 quirks = 0;\n\tunsigned int rsize = 0;\n\tchar *rdesc;\n\tint ret, n;\n\tint num_descriptors;\n\tsize_t offset = offsetof(struct hid_descriptor, desc);\n\n\tquirks = hid_lookup_quirk(hid);\n\n\tif (quirks & HID_QUIRK_IGNORE)\n\t\treturn -ENODEV;\n\n\t \n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\tif (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||\n\t\t\tinterface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)\n\t\t\t\tquirks |= HID_QUIRK_NOGET;\n\t}\n\n\tif (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&\n\t    (!interface->desc.bNumEndpoints ||\n\t     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {\n\t\tdbg_hid(\"class descriptor not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (hdesc->bLength < sizeof(struct hid_descriptor)) {\n\t\tdbg_hid(\"hid descriptor is too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thid->version = le16_to_cpu(hdesc->bcdHID);\n\thid->country = hdesc->bCountryCode;\n\n\tnum_descriptors = min_t(int, hdesc->bNumDescriptors,\n\t       (hdesc->bLength - offset) / sizeof(struct hid_class_descriptor));\n\n\tfor (n = 0; n < num_descriptors; n++)\n\t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n\t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);\n\t\treturn -EINVAL;\n\t}\n\n\trdesc = kmalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\thid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);\n\n\tret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,\n\t\t\tHID_DT_REPORT, rdesc, rsize);\n\tif (ret < 0) {\n\t\tdbg_hid(\"reading report descriptor failed\\n\");\n\t\tkfree(rdesc);\n\t\tgoto err;\n\t}\n\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n\tif (ret) {\n\t\tdbg_hid(\"parsing report descriptor failed\\n\");\n\t\tgoto err;\n\t}\n\n\thid->quirks |= quirks;\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int usbhid_start(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tunsigned int n, insize = 0;\n\tint ret;\n\n\tmutex_lock(&usbhid->mutex);\n\n\tclear_bit(HID_DISCONNECTED, &usbhid->iofl);\n\n\tusbhid->bufsize = HID_MIN_BUFFER_SIZE;\n\thid_find_max_report(hid, HID_INPUT_REPORT, &usbhid->bufsize);\n\thid_find_max_report(hid, HID_OUTPUT_REPORT, &usbhid->bufsize);\n\thid_find_max_report(hid, HID_FEATURE_REPORT, &usbhid->bufsize);\n\n\tif (usbhid->bufsize > HID_MAX_BUFFER_SIZE)\n\t\tusbhid->bufsize = HID_MAX_BUFFER_SIZE;\n\n\thid_find_max_report(hid, HID_INPUT_REPORT, &insize);\n\n\tif (insize > HID_MAX_BUFFER_SIZE)\n\t\tinsize = HID_MAX_BUFFER_SIZE;\n\n\tif (hid_alloc_buffers(dev, hid)) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfor (n = 0; n < interface->desc.bNumEndpoints; n++) {\n\t\tstruct usb_endpoint_descriptor *endpoint;\n\t\tint pipe;\n\t\tint interval;\n\n\t\tendpoint = &interface->endpoint[n].desc;\n\t\tif (!usb_endpoint_xfer_int(endpoint))\n\t\t\tcontinue;\n\n\t\tinterval = endpoint->bInterval;\n\n\t\t \n\t\tif (hid->quirks & HID_QUIRK_FULLSPEED_INTERVAL &&\n\t\t    dev->speed == USB_SPEED_HIGH) {\n\t\t\tinterval = fls(endpoint->bInterval*8);\n\t\t\tpr_info(\"%s: Fixing fullspeed to highspeed interval: %d -> %d\\n\",\n\t\t\t\thid->name, endpoint->bInterval, interval);\n\t\t}\n\n\t\t \n\t\tswitch (hid->collection->usage) {\n\t\tcase HID_GD_MOUSE:\n\t\t\tif (hid_mousepoll_interval > 0)\n\t\t\t\tinterval = hid_mousepoll_interval;\n\t\t\tbreak;\n\t\tcase HID_GD_JOYSTICK:\n\t\t\tif (hid_jspoll_interval > 0)\n\t\t\t\tinterval = hid_jspoll_interval;\n\t\t\tbreak;\n\t\tcase HID_GD_KEYBOARD:\n\t\t\tif (hid_kbpoll_interval > 0)\n\t\t\t\tinterval = hid_kbpoll_interval;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tif (usb_endpoint_dir_in(endpoint)) {\n\t\t\tif (usbhid->urbin)\n\t\t\t\tcontinue;\n\t\t\tif (!(usbhid->urbin = usb_alloc_urb(0, GFP_KERNEL)))\n\t\t\t\tgoto fail;\n\t\t\tpipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\n\t\t\tusb_fill_int_urb(usbhid->urbin, dev, pipe, usbhid->inbuf, insize,\n\t\t\t\t\t hid_irq_in, hid, interval);\n\t\t\tusbhid->urbin->transfer_dma = usbhid->inbuf_dma;\n\t\t\tusbhid->urbin->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\t} else {\n\t\t\tif (usbhid->urbout)\n\t\t\t\tcontinue;\n\t\t\tif (!(usbhid->urbout = usb_alloc_urb(0, GFP_KERNEL)))\n\t\t\t\tgoto fail;\n\t\t\tpipe = usb_sndintpipe(dev, endpoint->bEndpointAddress);\n\t\t\tusb_fill_int_urb(usbhid->urbout, dev, pipe, usbhid->outbuf, 0,\n\t\t\t\t\t hid_irq_out, hid, interval);\n\t\t\tusbhid->urbout->transfer_dma = usbhid->outbuf_dma;\n\t\t\tusbhid->urbout->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\t}\n\t}\n\n\tusbhid->urbctrl = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!usbhid->urbctrl) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tusb_fill_control_urb(usbhid->urbctrl, dev, 0, (void *) usbhid->cr,\n\t\t\t     usbhid->ctrlbuf, 1, hid_ctrl, hid);\n\tusbhid->urbctrl->transfer_dma = usbhid->ctrlbuf_dma;\n\tusbhid->urbctrl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tset_bit(HID_STARTED, &usbhid->iofl);\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL) {\n\t\tret = usb_autopm_get_interface(usbhid->intf);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tset_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\tusbhid->intf->needs_remote_wakeup = 1;\n\t\tret = hid_start_in(hid);\n\t\tif (ret) {\n\t\t\tdev_err(&hid->dev,\n\t\t\t\t\"failed to start in urb: %d\\n\", ret);\n\t\t}\n\t\tusb_autopm_put_interface(usbhid->intf);\n\t}\n\n\t \n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT &&\n\t\t\tinterface->desc.bInterfaceProtocol ==\n\t\t\t\tUSB_INTERFACE_PROTOCOL_KEYBOARD) {\n\t\tusbhid_set_leds(hid);\n\t\tdevice_set_wakeup_enable(&dev->dev, 1);\n\t}\n\n\tmutex_unlock(&usbhid->mutex);\n\treturn 0;\n\nfail:\n\tusb_free_urb(usbhid->urbin);\n\tusb_free_urb(usbhid->urbout);\n\tusb_free_urb(usbhid->urbctrl);\n\tusbhid->urbin = NULL;\n\tusbhid->urbout = NULL;\n\tusbhid->urbctrl = NULL;\n\thid_free_buffers(dev, hid);\n\tmutex_unlock(&usbhid->mutex);\n\treturn ret;\n}\n\nstatic void usbhid_stop(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tif (WARN_ON(!usbhid))\n\t\treturn;\n\n\tif (hid->quirks & HID_QUIRK_ALWAYS_POLL) {\n\t\tclear_bit(HID_IN_POLLING, &usbhid->iofl);\n\t\tusbhid->intf->needs_remote_wakeup = 0;\n\t}\n\n\tmutex_lock(&usbhid->mutex);\n\n\tclear_bit(HID_STARTED, &usbhid->iofl);\n\n\tspin_lock_irq(&usbhid->lock);\t \n\tset_bit(HID_DISCONNECTED, &usbhid->iofl);\n\twhile (usbhid->ctrltail != usbhid->ctrlhead) {\n\t\tif (usbhid->ctrl[usbhid->ctrltail].dir == USB_DIR_OUT) {\n\t\t\tkfree(usbhid->ctrl[usbhid->ctrltail].raw_report);\n\t\t\tusbhid->ctrl[usbhid->ctrltail].raw_report = NULL;\n\t\t}\n\n\t\tusbhid->ctrltail = (usbhid->ctrltail + 1) &\n\t\t\t(HID_CONTROL_FIFO_SIZE - 1);\n\t}\n\tspin_unlock_irq(&usbhid->lock);\n\n\tusb_kill_urb(usbhid->urbin);\n\tusb_kill_urb(usbhid->urbout);\n\tusb_kill_urb(usbhid->urbctrl);\n\n\thid_cancel_delayed_stuff(usbhid);\n\n\thid->claimed = 0;\n\n\tusb_free_urb(usbhid->urbin);\n\tusb_free_urb(usbhid->urbctrl);\n\tusb_free_urb(usbhid->urbout);\n\tusbhid->urbin = NULL;  \n\tusbhid->urbctrl = NULL;\n\tusbhid->urbout = NULL;\n\n\thid_free_buffers(hid_to_usb_dev(hid), hid);\n\n\tmutex_unlock(&usbhid->mutex);\n}\n\nstatic int usbhid_power(struct hid_device *hid, int lvl)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint r = 0;\n\n\tswitch (lvl) {\n\tcase PM_HINT_FULLON:\n\t\tr = usb_autopm_get_interface(usbhid->intf);\n\t\tbreak;\n\n\tcase PM_HINT_NORMAL:\n\t\tusb_autopm_put_interface(usbhid->intf);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic void usbhid_request(struct hid_device *hid, struct hid_report *rep, int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\tusbhid_submit_report(hid, rep, USB_DIR_IN);\n\t\tbreak;\n\tcase HID_REQ_SET_REPORT:\n\t\tusbhid_submit_report(hid, rep, USB_DIR_OUT);\n\t\tbreak;\n\t}\n}\n\nstatic int usbhid_raw_request(struct hid_device *hid, unsigned char reportnum,\n\t\t\t      __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t      int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\treturn usbhid_get_raw_report(hid, reportnum, buf, len, rtype);\n\tcase HID_REQ_SET_REPORT:\n\t\treturn usbhid_set_raw_report(hid, reportnum, buf, len, rtype);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int usbhid_idle(struct hid_device *hid, int report, int idle,\n\t\tint reqtype)\n{\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint ifnum = interface->desc.bInterfaceNumber;\n\n\tif (reqtype != HID_REQ_SET_IDLE)\n\t\treturn -EINVAL;\n\n\treturn hid_set_idle(dev, ifnum, report, idle);\n}\n\nstatic bool usbhid_may_wakeup(struct hid_device *hid)\n{\n\tstruct usb_device *dev = hid_to_usb_dev(hid);\n\n\treturn device_may_wakeup(&dev->dev);\n}\n\nstatic const struct hid_ll_driver usb_hid_driver = {\n\t.parse = usbhid_parse,\n\t.start = usbhid_start,\n\t.stop = usbhid_stop,\n\t.open = usbhid_open,\n\t.close = usbhid_close,\n\t.power = usbhid_power,\n\t.request = usbhid_request,\n\t.wait = usbhid_wait_io,\n\t.raw_request = usbhid_raw_request,\n\t.output_report = usbhid_output_report,\n\t.idle = usbhid_idle,\n\t.may_wakeup = usbhid_may_wakeup,\n};\n\nbool hid_is_usb(const struct hid_device *hdev)\n{\n\treturn hdev->ll_driver == &usb_hid_driver;\n}\nEXPORT_SYMBOL_GPL(hid_is_usb);\n\nstatic int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usbhid_device *usbhid;\n\tstruct hid_device *hid;\n\tunsigned int n, has_in = 0;\n\tsize_t len;\n\tint ret;\n\n\tdbg_hid(\"HID probe called for ifnum %d\\n\",\n\t\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\tfor (n = 0; n < interface->desc.bNumEndpoints; n++)\n\t\tif (usb_endpoint_is_int_in(&interface->endpoint[n].desc))\n\t\t\thas_in++;\n\tif (!has_in) {\n\t\thid_err(intf, \"couldn't find an input interrupt endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid))\n\t\treturn PTR_ERR(hid);\n\n\tusb_set_intfdata(intf, hid);\n\thid->ll_driver = &usb_hid_driver;\n\thid->ff_init = hid_pidff_init;\n#ifdef CONFIG_USB_HIDDEV\n\thid->hiddev_connect = hiddev_connect;\n\thid->hiddev_disconnect = hiddev_disconnect;\n\thid->hiddev_hid_event = hiddev_hid_event;\n\thid->hiddev_report_event = hiddev_report_event;\n#endif\n\thid->dev.parent = &intf->dev;\n\thid->bus = BUS_USB;\n\thid->vendor = le16_to_cpu(dev->descriptor.idVendor);\n\thid->product = le16_to_cpu(dev->descriptor.idProduct);\n\thid->version = le16_to_cpu(dev->descriptor.bcdDevice);\n\thid->name[0] = 0;\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol ==\n\t\t\tUSB_INTERFACE_PROTOCOL_MOUSE)\n\t\thid->type = HID_TYPE_USBMOUSE;\n\telse if (intf->cur_altsetting->desc.bInterfaceProtocol == 0)\n\t\thid->type = HID_TYPE_USBNONE;\n\n\tif (dev->manufacturer)\n\t\tstrscpy(hid->name, dev->manufacturer, sizeof(hid->name));\n\n\tif (dev->product) {\n\t\tif (dev->manufacturer)\n\t\t\tstrlcat(hid->name, \" \", sizeof(hid->name));\n\t\tstrlcat(hid->name, dev->product, sizeof(hid->name));\n\t}\n\n\tif (!strlen(hid->name))\n\t\tsnprintf(hid->name, sizeof(hid->name), \"HID %04x:%04x\",\n\t\t\t le16_to_cpu(dev->descriptor.idVendor),\n\t\t\t le16_to_cpu(dev->descriptor.idProduct));\n\n\tusb_make_path(dev, hid->phys, sizeof(hid->phys));\n\tstrlcat(hid->phys, \"/input\", sizeof(hid->phys));\n\tlen = strlen(hid->phys);\n\tif (len < sizeof(hid->phys) - 1)\n\t\tsnprintf(hid->phys + len, sizeof(hid->phys) - len,\n\t\t\t \"%d\", intf->altsetting[0].desc.bInterfaceNumber);\n\n\tif (usb_string(dev, dev->descriptor.iSerialNumber, hid->uniq, 64) <= 0)\n\t\thid->uniq[0] = 0;\n\n\tusbhid = kzalloc(sizeof(*usbhid), GFP_KERNEL);\n\tif (usbhid == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\thid->driver_data = usbhid;\n\tusbhid->hid = hid;\n\tusbhid->intf = intf;\n\tusbhid->ifnum = interface->desc.bInterfaceNumber;\n\n\tinit_waitqueue_head(&usbhid->wait);\n\tINIT_WORK(&usbhid->reset_work, hid_reset);\n\ttimer_setup(&usbhid->io_retry, hid_retry_timeout, 0);\n\tspin_lock_init(&usbhid->lock);\n\tmutex_init(&usbhid->mutex);\n\n\tret = hid_add_device(hid);\n\tif (ret) {\n\t\tif (ret != -ENODEV)\n\t\t\thid_err(intf, \"can't add hid device: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(usbhid);\nerr:\n\thid_destroy_device(hid);\n\treturn ret;\n}\n\nstatic void usbhid_disconnect(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid;\n\n\tif (WARN_ON(!hid))\n\t\treturn;\n\n\tusbhid = hid->driver_data;\n\tspin_lock_irq(&usbhid->lock);\t \n\tset_bit(HID_DISCONNECTED, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_destroy_device(hid);\n\tkfree(usbhid);\n}\n\nstatic void hid_cancel_delayed_stuff(struct usbhid_device *usbhid)\n{\n\tdel_timer_sync(&usbhid->io_retry);\n\tcancel_work_sync(&usbhid->reset_work);\n}\n\nstatic void hid_cease_io(struct usbhid_device *usbhid)\n{\n\tdel_timer_sync(&usbhid->io_retry);\n\tusb_kill_urb(usbhid->urbin);\n\tusb_kill_urb(usbhid->urbctrl);\n\tusb_kill_urb(usbhid->urbout);\n}\n\nstatic void hid_restart_io(struct hid_device *hid)\n{\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint clear_halt = test_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\tint reset_pending = test_bit(HID_RESET_PENDING, &usbhid->iofl);\n\n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_SUSPENDED, &usbhid->iofl);\n\tusbhid_mark_busy(usbhid);\n\n\tif (clear_halt || reset_pending)\n\t\tschedule_work(&usbhid->reset_work);\n\tusbhid->retry_delay = 0;\n\tspin_unlock_irq(&usbhid->lock);\n\n\tif (reset_pending || !test_bit(HID_STARTED, &usbhid->iofl))\n\t\treturn;\n\n\tif (!clear_halt) {\n\t\tif (hid_start_in(hid) < 0)\n\t\t\thid_io_error(hid);\n\t}\n\n\tspin_lock_irq(&usbhid->lock);\n\tif (usbhid->urbout && !test_bit(HID_OUT_RUNNING, &usbhid->iofl))\n\t\tusbhid_restart_out_queue(usbhid);\n\tif (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))\n\t\tusbhid_restart_ctrl_queue(usbhid);\n\tspin_unlock_irq(&usbhid->lock);\n}\n\n \nstatic int hid_pre_reset(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irq(&usbhid->lock);\n\tset_bit(HID_RESET_PENDING, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_cease_io(usbhid);\n\n\treturn 0;\n}\n\n \nstatic int hid_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tint status;\n\tchar *rdesc;\n\n\t \n\trdesc = kmalloc(hid->dev_rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\tstatus = hid_get_class_descriptor(dev,\n\t\t\t\tinterface->desc.bInterfaceNumber,\n\t\t\t\tHID_DT_REPORT, rdesc, hid->dev_rsize);\n\tif (status < 0) {\n\t\tdbg_hid(\"reading report descriptor failed (post_reset)\\n\");\n\t\tkfree(rdesc);\n\t\treturn status;\n\t}\n\tstatus = memcmp(rdesc, hid->dev_rdesc, hid->dev_rsize);\n\tkfree(rdesc);\n\tif (status != 0) {\n\t\tdbg_hid(\"report descriptor changed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tspin_lock_irq(&usbhid->lock);\n\tclear_bit(HID_RESET_PENDING, &usbhid->iofl);\n\tclear_bit(HID_CLEAR_HALT, &usbhid->iofl);\n\tspin_unlock_irq(&usbhid->lock);\n\thid_set_idle(dev, intf->cur_altsetting->desc.bInterfaceNumber, 0, 0);\n\n\thid_restart_io(hid);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int hid_resume_common(struct hid_device *hid, bool driver_suspended)\n{\n\tint status = 0;\n\n\thid_restart_io(hid);\n\tif (driver_suspended)\n\t\tstatus = hid_driver_resume(hid);\n\treturn status;\n}\n\nstatic int hid_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint status = 0;\n\tbool driver_suspended = false;\n\tunsigned int ledcount;\n\n\tif (PMSG_IS_AUTO(message)) {\n\t\tledcount = hidinput_count_leds(hid);\n\t\tspin_lock_irq(&usbhid->lock);\t \n\t\tif (!test_bit(HID_RESET_PENDING, &usbhid->iofl)\n\t\t    && !test_bit(HID_CLEAR_HALT, &usbhid->iofl)\n\t\t    && !test_bit(HID_OUT_RUNNING, &usbhid->iofl)\n\t\t    && !test_bit(HID_CTRL_RUNNING, &usbhid->iofl)\n\t\t    && !test_bit(HID_KEYS_PRESSED, &usbhid->iofl)\n\t\t    && (!ledcount || ignoreled))\n\t\t{\n\t\t\tset_bit(HID_SUSPENDED, &usbhid->iofl);\n\t\t\tspin_unlock_irq(&usbhid->lock);\n\t\t\tstatus = hid_driver_suspend(hid, message);\n\t\t\tif (status < 0)\n\t\t\t\tgoto failed;\n\t\t\tdriver_suspended = true;\n\t\t} else {\n\t\t\tusbhid_mark_busy(usbhid);\n\t\t\tspin_unlock_irq(&usbhid->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t} else {\n\t\t \n\t\tstatus = hid_driver_suspend(hid, message);\n\t\tdriver_suspended = true;\n\t\tspin_lock_irq(&usbhid->lock);\n\t\tset_bit(HID_SUSPENDED, &usbhid->iofl);\n\t\tspin_unlock_irq(&usbhid->lock);\n\t\tif (usbhid_wait_io(hid) < 0)\n\t\t\tstatus = -EIO;\n\t}\n\n\thid_cancel_delayed_stuff(usbhid);\n\thid_cease_io(usbhid);\n\n\tif (PMSG_IS_AUTO(message) && test_bit(HID_KEYS_PRESSED, &usbhid->iofl)) {\n\t\t \n\t\tstatus = -EBUSY;\n\t\tgoto failed;\n\t}\n\tdev_dbg(&intf->dev, \"suspend\\n\");\n\treturn status;\n\n failed:\n\thid_resume_common(hid, driver_suspended);\n\treturn status;\n}\n\nstatic int hid_resume(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata (intf);\n\tint status;\n\n\tstatus = hid_resume_common(hid, true);\n\tdev_dbg(&intf->dev, \"resume status %d\\n\", status);\n\treturn 0;\n}\n\nstatic int hid_reset_resume(struct usb_interface *intf)\n{\n\tstruct hid_device *hid = usb_get_intfdata(intf);\n\tint status;\n\n\tstatus = hid_post_reset(intf);\n\tif (status >= 0) {\n\t\tint ret = hid_driver_reset_resume(hid);\n\t\tif (ret < 0)\n\t\t\tstatus = ret;\n\t}\n\treturn status;\n}\n\n#endif  \n\nstatic const struct usb_device_id hid_usb_ids[] = {\n\t{ .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n\t\t.bInterfaceClass = USB_INTERFACE_CLASS_HID },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE (usb, hid_usb_ids);\n\nstatic struct usb_driver hid_driver = {\n\t.name =\t\t\"usbhid\",\n\t.probe =\tusbhid_probe,\n\t.disconnect =\tusbhid_disconnect,\n#ifdef CONFIG_PM\n\t.suspend =\thid_suspend,\n\t.resume =\thid_resume,\n\t.reset_resume =\thid_reset_resume,\n#endif\n\t.pre_reset =\thid_pre_reset,\n\t.post_reset =\thid_post_reset,\n\t.id_table =\thid_usb_ids,\n\t.supports_autosuspend = 1,\n};\n\nstruct usb_interface *usbhid_find_interface(int minor)\n{\n\treturn usb_find_interface(&hid_driver, minor);\n}\n\nstatic int __init hid_init(void)\n{\n\tint retval;\n\n\tretval = hid_quirks_init(quirks_param, BUS_USB, MAX_USBHID_BOOT_QUIRKS);\n\tif (retval)\n\t\tgoto usbhid_quirks_init_fail;\n\tretval = usb_register(&hid_driver);\n\tif (retval)\n\t\tgoto usb_register_fail;\n\tpr_info(KBUILD_MODNAME \": \" DRIVER_DESC \"\\n\");\n\n\treturn 0;\nusb_register_fail:\n\thid_quirks_exit(BUS_USB);\nusbhid_quirks_init_fail:\n\treturn retval;\n}\n\nstatic void __exit hid_exit(void)\n{\n\tusb_deregister(&hid_driver);\n\thid_quirks_exit(BUS_USB);\n}\n\nmodule_init(hid_init);\nmodule_exit(hid_exit);\n\nMODULE_AUTHOR(\"Andreas Gal\");\nMODULE_AUTHOR(\"Vojtech Pavlik\");\nMODULE_AUTHOR(\"Jiri Kosina\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}