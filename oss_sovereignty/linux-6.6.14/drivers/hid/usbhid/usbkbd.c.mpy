{
  "module_name": "usbkbd.c",
  "hash_id": "97d56aa23ca305fedbed4eab064c0803bfd52ed40ddcba0c29c9e023aff4f269",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/usbhid/usbkbd.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/usb/input.h>\n#include <linux/hid.h>\n\n \n#define DRIVER_VERSION \"\"\n#define DRIVER_AUTHOR \"Vojtech Pavlik <vojtech@ucw.cz>\"\n#define DRIVER_DESC \"USB HID Boot Protocol keyboard driver\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic const unsigned char usb_kbd_keycode[256] = {\n\t  0,  0,  0,  0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38,\n\t 50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44,  2,  3,\n\t  4,  5,  6,  7,  8,  9, 10, 11, 28,  1, 14, 15, 57, 12, 13, 26,\n\t 27, 43, 43, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64,\n\t 65, 66, 67, 68, 87, 88, 99, 70,119,110,102,104,111,107,109,106,\n\t105,108,103, 69, 98, 55, 74, 78, 96, 79, 80, 81, 75, 76, 77, 71,\n\t 72, 73, 82, 83, 86,127,116,117,183,184,185,186,187,188,189,190,\n\t191,192,193,194,134,138,130,132,128,129,131,137,133,135,136,113,\n\t115,114,  0,  0,  0,121,  0, 89, 93,124, 92, 94, 95,  0,  0,  0,\n\t122,123, 90, 91, 85,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113,\n\t150,158,159,128,136,177,178,176,142,152,173,140\n};\n\n\n \nstruct usb_kbd {\n\tstruct input_dev *dev;\n\tstruct usb_device *usbdev;\n\tunsigned char old[8];\n\tstruct urb *irq, *led;\n\tunsigned char newleds;\n\tchar name[128];\n\tchar phys[64];\n\n\tunsigned char *new;\n\tstruct usb_ctrlrequest *cr;\n\tunsigned char *leds;\n\tdma_addr_t new_dma;\n\tdma_addr_t leds_dma;\n\n\tspinlock_t leds_lock;\n\tbool led_urb_submitted;\n\n};\n\nstatic void usb_kbd_irq(struct urb *urb)\n{\n\tstruct usb_kbd *kbd = urb->context;\n\tint i;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t \n\tdefault:\t\t \n\t\tgoto resubmit;\n\t}\n\n\tfor (i = 0; i < 8; i++)\n\t\tinput_report_key(kbd->dev, usb_kbd_keycode[i + 224], (kbd->new[0] >> i) & 1);\n\n\tfor (i = 2; i < 8; i++) {\n\n\t\tif (kbd->old[i] > 3 && memscan(kbd->new + 2, kbd->old[i], 6) == kbd->new + 8) {\n\t\t\tif (usb_kbd_keycode[kbd->old[i]])\n\t\t\t\tinput_report_key(kbd->dev, usb_kbd_keycode[kbd->old[i]], 0);\n\t\t\telse\n\t\t\t\thid_info(urb->dev,\n\t\t\t\t\t \"Unknown key (scancode %#x) released.\\n\",\n\t\t\t\t\t kbd->old[i]);\n\t\t}\n\n\t\tif (kbd->new[i] > 3 && memscan(kbd->old + 2, kbd->new[i], 6) == kbd->old + 8) {\n\t\t\tif (usb_kbd_keycode[kbd->new[i]])\n\t\t\t\tinput_report_key(kbd->dev, usb_kbd_keycode[kbd->new[i]], 1);\n\t\t\telse\n\t\t\t\thid_info(urb->dev,\n\t\t\t\t\t \"Unknown key (scancode %#x) pressed.\\n\",\n\t\t\t\t\t kbd->new[i]);\n\t\t}\n\t}\n\n\tinput_sync(kbd->dev);\n\n\tmemcpy(kbd->old, kbd->new, 8);\n\nresubmit:\n\ti = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (i)\n\t\thid_err(urb->dev, \"can't resubmit intr, %s-%s/input0, status %d\",\n\t\t\tkbd->usbdev->bus->bus_name,\n\t\t\tkbd->usbdev->devpath, i);\n}\n\nstatic int usb_kbd_event(struct input_dev *dev, unsigned int type,\n\t\t\t unsigned int code, int value)\n{\n\tunsigned long flags;\n\tstruct usb_kbd *kbd = input_get_drvdata(dev);\n\n\tif (type != EV_LED)\n\t\treturn -1;\n\n\tspin_lock_irqsave(&kbd->leds_lock, flags);\n\tkbd->newleds = (!!test_bit(LED_KANA,    dev->led) << 3) | (!!test_bit(LED_COMPOSE, dev->led) << 3) |\n\t\t       (!!test_bit(LED_SCROLLL, dev->led) << 2) | (!!test_bit(LED_CAPSL,   dev->led) << 1) |\n\t\t       (!!test_bit(LED_NUML,    dev->led));\n\n\tif (kbd->led_urb_submitted){\n\t\tspin_unlock_irqrestore(&kbd->leds_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (*(kbd->leds) == kbd->newleds){\n\t\tspin_unlock_irqrestore(&kbd->leds_lock, flags);\n\t\treturn 0;\n\t}\n\n\t*(kbd->leds) = kbd->newleds;\n\n\tkbd->led->dev = kbd->usbdev;\n\tif (usb_submit_urb(kbd->led, GFP_ATOMIC))\n\t\tpr_err(\"usb_submit_urb(leds) failed\\n\");\n\telse\n\t\tkbd->led_urb_submitted = true;\n\n\tspin_unlock_irqrestore(&kbd->leds_lock, flags);\n\n\treturn 0;\n}\n\nstatic void usb_kbd_led(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct usb_kbd *kbd = urb->context;\n\n\tif (urb->status)\n\t\thid_warn(urb->dev, \"led urb status %d received\\n\",\n\t\t\t urb->status);\n\n\tspin_lock_irqsave(&kbd->leds_lock, flags);\n\n\tif (*(kbd->leds) == kbd->newleds){\n\t\tkbd->led_urb_submitted = false;\n\t\tspin_unlock_irqrestore(&kbd->leds_lock, flags);\n\t\treturn;\n\t}\n\n\t*(kbd->leds) = kbd->newleds;\n\n\tkbd->led->dev = kbd->usbdev;\n\tif (usb_submit_urb(kbd->led, GFP_ATOMIC)){\n\t\thid_err(urb->dev, \"usb_submit_urb(leds) failed\\n\");\n\t\tkbd->led_urb_submitted = false;\n\t}\n\tspin_unlock_irqrestore(&kbd->leds_lock, flags);\n\n}\n\nstatic int usb_kbd_open(struct input_dev *dev)\n{\n\tstruct usb_kbd *kbd = input_get_drvdata(dev);\n\n\tkbd->irq->dev = kbd->usbdev;\n\tif (usb_submit_urb(kbd->irq, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void usb_kbd_close(struct input_dev *dev)\n{\n\tstruct usb_kbd *kbd = input_get_drvdata(dev);\n\n\tusb_kill_urb(kbd->irq);\n}\n\nstatic int usb_kbd_alloc_mem(struct usb_device *dev, struct usb_kbd *kbd)\n{\n\tif (!(kbd->irq = usb_alloc_urb(0, GFP_KERNEL)))\n\t\treturn -1;\n\tif (!(kbd->led = usb_alloc_urb(0, GFP_KERNEL)))\n\t\treturn -1;\n\tif (!(kbd->new = usb_alloc_coherent(dev, 8, GFP_KERNEL, &kbd->new_dma)))\n\t\treturn -1;\n\tif (!(kbd->cr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL)))\n\t\treturn -1;\n\tif (!(kbd->leds = usb_alloc_coherent(dev, 1, GFP_KERNEL, &kbd->leds_dma)))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void usb_kbd_free_mem(struct usb_device *dev, struct usb_kbd *kbd)\n{\n\tusb_free_urb(kbd->irq);\n\tusb_free_urb(kbd->led);\n\tusb_free_coherent(dev, 8, kbd->new, kbd->new_dma);\n\tkfree(kbd->cr);\n\tusb_free_coherent(dev, 1, kbd->leds, kbd->leds_dma);\n}\n\nstatic int usb_kbd_probe(struct usb_interface *iface,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(iface);\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_kbd *kbd;\n\tstruct input_dev *input_dev;\n\tint i, pipe, maxp;\n\tint error = -ENOMEM;\n\n\tinterface = iface->cur_altsetting;\n\n\tif (interface->desc.bNumEndpoints != 1)\n\t\treturn -ENODEV;\n\n\tendpoint = &interface->endpoint[0].desc;\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\treturn -ENODEV;\n\n\tpipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(dev, pipe);\n\n\tkbd = kzalloc(sizeof(struct usb_kbd), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!kbd || !input_dev)\n\t\tgoto fail1;\n\n\tif (usb_kbd_alloc_mem(dev, kbd))\n\t\tgoto fail2;\n\n\tkbd->usbdev = dev;\n\tkbd->dev = input_dev;\n\tspin_lock_init(&kbd->leds_lock);\n\n\tif (dev->manufacturer)\n\t\tstrscpy(kbd->name, dev->manufacturer, sizeof(kbd->name));\n\n\tif (dev->product) {\n\t\tif (dev->manufacturer)\n\t\t\tstrlcat(kbd->name, \" \", sizeof(kbd->name));\n\t\tstrlcat(kbd->name, dev->product, sizeof(kbd->name));\n\t}\n\n\tif (!strlen(kbd->name))\n\t\tsnprintf(kbd->name, sizeof(kbd->name),\n\t\t\t \"USB HIDBP Keyboard %04x:%04x\",\n\t\t\t le16_to_cpu(dev->descriptor.idVendor),\n\t\t\t le16_to_cpu(dev->descriptor.idProduct));\n\n\tusb_make_path(dev, kbd->phys, sizeof(kbd->phys));\n\tstrlcat(kbd->phys, \"/input0\", sizeof(kbd->phys));\n\n\tinput_dev->name = kbd->name;\n\tinput_dev->phys = kbd->phys;\n\tusb_to_input_id(dev, &input_dev->id);\n\tinput_dev->dev.parent = &iface->dev;\n\n\tinput_set_drvdata(input_dev, kbd);\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\n\t\tBIT_MASK(EV_REP);\n\tinput_dev->ledbit[0] = BIT_MASK(LED_NUML) | BIT_MASK(LED_CAPSL) |\n\t\tBIT_MASK(LED_SCROLLL) | BIT_MASK(LED_COMPOSE) |\n\t\tBIT_MASK(LED_KANA);\n\n\tfor (i = 0; i < 255; i++)\n\t\tset_bit(usb_kbd_keycode[i], input_dev->keybit);\n\tclear_bit(0, input_dev->keybit);\n\n\tinput_dev->event = usb_kbd_event;\n\tinput_dev->open = usb_kbd_open;\n\tinput_dev->close = usb_kbd_close;\n\n\tusb_fill_int_urb(kbd->irq, dev, pipe,\n\t\t\t kbd->new, (maxp > 8 ? 8 : maxp),\n\t\t\t usb_kbd_irq, kbd, endpoint->bInterval);\n\tkbd->irq->transfer_dma = kbd->new_dma;\n\tkbd->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tkbd->cr->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE;\n\tkbd->cr->bRequest = 0x09;\n\tkbd->cr->wValue = cpu_to_le16(0x200);\n\tkbd->cr->wIndex = cpu_to_le16(interface->desc.bInterfaceNumber);\n\tkbd->cr->wLength = cpu_to_le16(1);\n\n\tusb_fill_control_urb(kbd->led, dev, usb_sndctrlpipe(dev, 0),\n\t\t\t     (void *) kbd->cr, kbd->leds, 1,\n\t\t\t     usb_kbd_led, kbd);\n\tkbd->led->transfer_dma = kbd->leds_dma;\n\tkbd->led->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\terror = input_register_device(kbd->dev);\n\tif (error)\n\t\tgoto fail2;\n\n\tusb_set_intfdata(iface, kbd);\n\tdevice_set_wakeup_enable(&dev->dev, 1);\n\treturn 0;\n\nfail2:\n\tusb_kbd_free_mem(dev, kbd);\nfail1:\n\tinput_free_device(input_dev);\n\tkfree(kbd);\n\treturn error;\n}\n\nstatic void usb_kbd_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_kbd *kbd = usb_get_intfdata (intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (kbd) {\n\t\tusb_kill_urb(kbd->irq);\n\t\tinput_unregister_device(kbd->dev);\n\t\tusb_kill_urb(kbd->led);\n\t\tusb_kbd_free_mem(interface_to_usbdev(intf), kbd);\n\t\tkfree(kbd);\n\t}\n}\n\nstatic const struct usb_device_id usb_kbd_id_table[] = {\n\t{ USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,\n\t\tUSB_INTERFACE_PROTOCOL_KEYBOARD) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE (usb, usb_kbd_id_table);\n\nstatic struct usb_driver usb_kbd_driver = {\n\t.name =\t\t\"usbkbd\",\n\t.probe =\tusb_kbd_probe,\n\t.disconnect =\tusb_kbd_disconnect,\n\t.id_table =\tusb_kbd_id_table,\n};\n\nmodule_usb_driver(usb_kbd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}