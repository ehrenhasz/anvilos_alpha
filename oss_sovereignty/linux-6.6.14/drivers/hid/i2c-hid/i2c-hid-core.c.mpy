{
  "module_name": "i2c-hid-core.c",
  "hash_id": "3cb8c366f9c0defcefe65b314ea082fe70a68498cb9055f01746f9652ebef322",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/i2c-hid/i2c-hid-core.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/hid.h>\n#include <linux/mutex.h>\n#include <asm/unaligned.h>\n\n#include <drm/drm_panel.h>\n\n#include \"../hid-ids.h\"\n#include \"i2c-hid.h\"\n\n \n#define I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV\tBIT(0)\n#define I2C_HID_QUIRK_NO_IRQ_AFTER_RESET\tBIT(1)\n#define I2C_HID_QUIRK_BOGUS_IRQ\t\t\tBIT(4)\n#define I2C_HID_QUIRK_RESET_ON_RESUME\t\tBIT(5)\n#define I2C_HID_QUIRK_BAD_INPUT_SIZE\t\tBIT(6)\n#define I2C_HID_QUIRK_NO_WAKEUP_AFTER_RESET\tBIT(7)\n\n \n#define I2C_HID_OPCODE_RESET\t\t\t0x01\n#define I2C_HID_OPCODE_GET_REPORT\t\t0x02\n#define I2C_HID_OPCODE_SET_REPORT\t\t0x03\n#define I2C_HID_OPCODE_GET_IDLE\t\t\t0x04\n#define I2C_HID_OPCODE_SET_IDLE\t\t\t0x05\n#define I2C_HID_OPCODE_GET_PROTOCOL\t\t0x06\n#define I2C_HID_OPCODE_SET_PROTOCOL\t\t0x07\n#define I2C_HID_OPCODE_SET_POWER\t\t0x08\n\n \n#define I2C_HID_STARTED\t\t0\n#define I2C_HID_RESET_PENDING\t1\n#define I2C_HID_READ_PENDING\t2\n\n#define I2C_HID_PWR_ON\t\t0x00\n#define I2C_HID_PWR_SLEEP\t0x01\n\n#define i2c_hid_dbg(ihid, ...) dev_dbg(&(ihid)->client->dev, __VA_ARGS__)\n\nstruct i2c_hid_desc {\n\t__le16 wHIDDescLength;\n\t__le16 bcdVersion;\n\t__le16 wReportDescLength;\n\t__le16 wReportDescRegister;\n\t__le16 wInputRegister;\n\t__le16 wMaxInputLength;\n\t__le16 wOutputRegister;\n\t__le16 wMaxOutputLength;\n\t__le16 wCommandRegister;\n\t__le16 wDataRegister;\n\t__le16 wVendorID;\n\t__le16 wProductID;\n\t__le16 wVersionID;\n\t__le32 reserved;\n} __packed;\n\n \nstruct i2c_hid {\n\tstruct i2c_client\t*client;\t \n\tstruct hid_device\t*hid;\t \n\tstruct i2c_hid_desc hdesc;\t\t \n\t__le16\t\t\twHIDDescRegister;  \n\tunsigned int\t\tbufsize;\t \n\tu8\t\t\t*inbuf;\t\t \n\tu8\t\t\t*rawbuf;\t \n\tu8\t\t\t*cmdbuf;\t \n\n\tunsigned long\t\tflags;\t\t \n\tunsigned long\t\tquirks;\t\t \n\n\twait_queue_head_t\twait;\t\t \n\n\tstruct mutex\t\treset_lock;\n\n\tstruct i2chid_ops\t*ops;\n\tstruct drm_panel_follower panel_follower;\n\tstruct work_struct\tpanel_follower_prepare_work;\n\tbool\t\t\tis_panel_follower;\n\tbool\t\t\tprepare_work_finished;\n};\n\nstatic const struct i2c_hid_quirks {\n\t__u16 idVendor;\n\t__u16 idProduct;\n\t__u32 quirks;\n} i2c_hid_quirks[] = {\n\t{ USB_VENDOR_ID_WEIDA, HID_ANY_ID,\n\t\tI2C_HID_QUIRK_SET_PWR_WAKEUP_DEV },\n\t{ I2C_VENDOR_ID_HANTICK, I2C_PRODUCT_ID_HANTICK_5288,\n\t\tI2C_HID_QUIRK_NO_IRQ_AFTER_RESET },\n\t{ I2C_VENDOR_ID_ITE, I2C_DEVICE_ID_ITE_VOYO_WINPAD_A15,\n\t\tI2C_HID_QUIRK_NO_IRQ_AFTER_RESET },\n\t{ I2C_VENDOR_ID_RAYDIUM, I2C_PRODUCT_ID_RAYDIUM_3118,\n\t\tI2C_HID_QUIRK_NO_IRQ_AFTER_RESET },\n\t{ USB_VENDOR_ID_ALPS_JP, HID_ANY_ID,\n\t\t I2C_HID_QUIRK_RESET_ON_RESUME },\n\t{ I2C_VENDOR_ID_SYNAPTICS, I2C_PRODUCT_ID_SYNAPTICS_SYNA2393,\n\t\t I2C_HID_QUIRK_RESET_ON_RESUME },\n\t{ USB_VENDOR_ID_ITE, I2C_DEVICE_ID_ITE_LENOVO_LEGION_Y720,\n\t\tI2C_HID_QUIRK_BAD_INPUT_SIZE },\n\t \n\t{ USB_VENDOR_ID_ELAN, HID_ANY_ID,\n\t\t I2C_HID_QUIRK_NO_WAKEUP_AFTER_RESET |\n\t\t I2C_HID_QUIRK_BOGUS_IRQ },\n\t{ 0, 0 }\n};\n\n \nstatic u32 i2c_hid_lookup_quirk(const u16 idVendor, const u16 idProduct)\n{\n\tu32 quirks = 0;\n\tint n;\n\n\tfor (n = 0; i2c_hid_quirks[n].idVendor; n++)\n\t\tif (i2c_hid_quirks[n].idVendor == idVendor &&\n\t\t    (i2c_hid_quirks[n].idProduct == (__u16)HID_ANY_ID ||\n\t\t     i2c_hid_quirks[n].idProduct == idProduct))\n\t\t\tquirks = i2c_hid_quirks[n].quirks;\n\n\treturn quirks;\n}\n\nstatic int i2c_hid_xfer(struct i2c_hid *ihid,\n\t\t\tu8 *send_buf, int send_len, u8 *recv_buf, int recv_len)\n{\n\tstruct i2c_client *client = ihid->client;\n\tstruct i2c_msg msgs[2] = { 0 };\n\tint n = 0;\n\tint ret;\n\n\tif (send_len) {\n\t\ti2c_hid_dbg(ihid, \"%s: cmd=%*ph\\n\",\n\t\t\t    __func__, send_len, send_buf);\n\n\t\tmsgs[n].addr = client->addr;\n\t\tmsgs[n].flags = (client->flags & I2C_M_TEN) | I2C_M_DMA_SAFE;\n\t\tmsgs[n].len = send_len;\n\t\tmsgs[n].buf = send_buf;\n\t\tn++;\n\t}\n\n\tif (recv_len) {\n\t\tmsgs[n].addr = client->addr;\n\t\tmsgs[n].flags = (client->flags & I2C_M_TEN) |\n\t\t\t\tI2C_M_RD | I2C_M_DMA_SAFE;\n\t\tmsgs[n].len = recv_len;\n\t\tmsgs[n].buf = recv_buf;\n\t\tn++;\n\n\t\tset_bit(I2C_HID_READ_PENDING, &ihid->flags);\n\t}\n\n\tret = i2c_transfer(client->adapter, msgs, n);\n\n\tif (recv_len)\n\t\tclear_bit(I2C_HID_READ_PENDING, &ihid->flags);\n\n\tif (ret != n)\n\t\treturn ret < 0 ? ret : -EIO;\n\n\treturn 0;\n}\n\nstatic int i2c_hid_read_register(struct i2c_hid *ihid, __le16 reg,\n\t\t\t\t void *buf, size_t len)\n{\n\t*(__le16 *)ihid->cmdbuf = reg;\n\n\treturn i2c_hid_xfer(ihid, ihid->cmdbuf, sizeof(__le16), buf, len);\n}\n\nstatic size_t i2c_hid_encode_command(u8 *buf, u8 opcode,\n\t\t\t\t     int report_type, int report_id)\n{\n\tsize_t length = 0;\n\n\tif (report_id < 0x0F) {\n\t\tbuf[length++] = report_type << 4 | report_id;\n\t\tbuf[length++] = opcode;\n\t} else {\n\t\tbuf[length++] = report_type << 4 | 0x0F;\n\t\tbuf[length++] = opcode;\n\t\tbuf[length++] = report_id;\n\t}\n\n\treturn length;\n}\n\nstatic int i2c_hid_get_report(struct i2c_hid *ihid,\n\t\t\t      u8 report_type, u8 report_id,\n\t\t\t      u8 *recv_buf, size_t recv_len)\n{\n\tsize_t length = 0;\n\tsize_t ret_count;\n\tint error;\n\n\ti2c_hid_dbg(ihid, \"%s\\n\", __func__);\n\n\t \n\t*(__le16 *)ihid->cmdbuf = ihid->hdesc.wCommandRegister;\n\tlength += sizeof(__le16);\n\t \n\tlength += i2c_hid_encode_command(ihid->cmdbuf + length,\n\t\t\t\t\t I2C_HID_OPCODE_GET_REPORT,\n\t\t\t\t\t report_type, report_id);\n\t \n\tput_unaligned_le16(le16_to_cpu(ihid->hdesc.wDataRegister),\n\t\t\t   ihid->cmdbuf + length);\n\tlength += sizeof(__le16);\n\n\t \n\terror = i2c_hid_xfer(ihid, ihid->cmdbuf, length,\n\t\t\t     ihid->rawbuf, recv_len + sizeof(__le16));\n\tif (error) {\n\t\tdev_err(&ihid->client->dev,\n\t\t\t\"failed to set a report to device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\t \n\tret_count = le16_to_cpup((__le16 *)ihid->rawbuf);\n\n\t \n\tif (ret_count <= sizeof(__le16))\n\t\treturn 0;\n\n\trecv_len = min(recv_len, ret_count - sizeof(__le16));\n\tmemcpy(recv_buf, ihid->rawbuf + sizeof(__le16), recv_len);\n\n\tif (report_id && recv_len != 0 && recv_buf[0] != report_id) {\n\t\tdev_err(&ihid->client->dev,\n\t\t\t\"device returned incorrect report (%d vs %d expected)\\n\",\n\t\t\trecv_buf[0], report_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn recv_len;\n}\n\nstatic size_t i2c_hid_format_report(u8 *buf, int report_id,\n\t\t\t\t    const u8 *data, size_t size)\n{\n\tsize_t length = sizeof(__le16);  \n\n\tif (report_id)\n\t\tbuf[length++] = report_id;\n\n\tmemcpy(buf + length, data, size);\n\tlength += size;\n\n\t \n\tput_unaligned_le16(length, buf);\n\n\treturn length;\n}\n\n \nstatic int i2c_hid_set_or_send_report(struct i2c_hid *ihid,\n\t\t\t\t      u8 report_type, u8 report_id,\n\t\t\t\t      const u8 *buf, size_t data_len,\n\t\t\t\t      bool do_set)\n{\n\tsize_t length = 0;\n\tint error;\n\n\ti2c_hid_dbg(ihid, \"%s\\n\", __func__);\n\n\tif (data_len > ihid->bufsize)\n\t\treturn -EINVAL;\n\n\tif (!do_set && le16_to_cpu(ihid->hdesc.wMaxOutputLength) == 0)\n\t\treturn -ENOSYS;\n\n\tif (do_set) {\n\t\t \n\t\t*(__le16 *)ihid->cmdbuf = ihid->hdesc.wCommandRegister;\n\t\tlength += sizeof(__le16);\n\t\t \n\t\tlength += i2c_hid_encode_command(ihid->cmdbuf + length,\n\t\t\t\t\t\t I2C_HID_OPCODE_SET_REPORT,\n\t\t\t\t\t\t report_type, report_id);\n\t\t \n\t\tput_unaligned_le16(le16_to_cpu(ihid->hdesc.wDataRegister),\n\t\t\t\t   ihid->cmdbuf + length);\n\t\tlength += sizeof(__le16);\n\t} else {\n\t\t \n\t\t*(__le16 *)ihid->cmdbuf = ihid->hdesc.wOutputRegister;\n\t\tlength += sizeof(__le16);\n\t}\n\n\tlength += i2c_hid_format_report(ihid->cmdbuf + length,\n\t\t\t\t\treport_id, buf, data_len);\n\n\terror = i2c_hid_xfer(ihid, ihid->cmdbuf, length, NULL, 0);\n\tif (error) {\n\t\tdev_err(&ihid->client->dev,\n\t\t\t\"failed to set a report to device: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn data_len;\n}\n\nstatic int i2c_hid_set_power_command(struct i2c_hid *ihid, int power_state)\n{\n\tsize_t length;\n\n\t \n\t*(__le16 *)ihid->cmdbuf = ihid->hdesc.wCommandRegister;\n\tlength = sizeof(__le16);\n\n\t \n\tlength += i2c_hid_encode_command(ihid->cmdbuf + length,\n\t\t\t\t\t I2C_HID_OPCODE_SET_POWER,\n\t\t\t\t\t 0, power_state);\n\n\treturn i2c_hid_xfer(ihid, ihid->cmdbuf, length, NULL, 0);\n}\n\nstatic int i2c_hid_set_power(struct i2c_hid *ihid, int power_state)\n{\n\tint ret;\n\n\ti2c_hid_dbg(ihid, \"%s\\n\", __func__);\n\n\t \n\tif (power_state == I2C_HID_PWR_ON &&\n\t    ihid->quirks & I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV) {\n\t\tret = i2c_hid_set_power_command(ihid, I2C_HID_PWR_ON);\n\n\t\t \n\t\tif (!ret)\n\t\t\tgoto set_pwr_exit;\n\t}\n\n\tret = i2c_hid_set_power_command(ihid, power_state);\n\tif (ret)\n\t\tdev_err(&ihid->client->dev,\n\t\t\t\"failed to change power setting.\\n\");\n\nset_pwr_exit:\n\n\t \n\tif (!ret && power_state == I2C_HID_PWR_ON)\n\t\tmsleep(60);\n\n\treturn ret;\n}\n\nstatic int i2c_hid_execute_reset(struct i2c_hid *ihid)\n{\n\tsize_t length = 0;\n\tint ret;\n\n\ti2c_hid_dbg(ihid, \"resetting...\\n\");\n\n\t \n\t*(__le16 *)ihid->cmdbuf = ihid->hdesc.wCommandRegister;\n\tlength += sizeof(__le16);\n\t \n\tlength += i2c_hid_encode_command(ihid->cmdbuf + length,\n\t\t\t\t\t I2C_HID_OPCODE_RESET, 0, 0);\n\n\tset_bit(I2C_HID_RESET_PENDING, &ihid->flags);\n\n\tret = i2c_hid_xfer(ihid, ihid->cmdbuf, length, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&ihid->client->dev, \"failed to reset device.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (ihid->quirks & I2C_HID_QUIRK_NO_IRQ_AFTER_RESET) {\n\t\tmsleep(100);\n\t\tgoto out;\n\t}\n\n\ti2c_hid_dbg(ihid, \"%s: waiting...\\n\", __func__);\n\tif (!wait_event_timeout(ihid->wait,\n\t\t\t\t!test_bit(I2C_HID_RESET_PENDING, &ihid->flags),\n\t\t\t\tmsecs_to_jiffies(5000))) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t}\n\ti2c_hid_dbg(ihid, \"%s: finished.\\n\", __func__);\n\nout:\n\tclear_bit(I2C_HID_RESET_PENDING, &ihid->flags);\n\treturn ret;\n}\n\nstatic int i2c_hid_hwreset(struct i2c_hid *ihid)\n{\n\tint ret;\n\n\ti2c_hid_dbg(ihid, \"%s\\n\", __func__);\n\n\t \n\tmutex_lock(&ihid->reset_lock);\n\n\tret = i2c_hid_set_power(ihid, I2C_HID_PWR_ON);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = i2c_hid_execute_reset(ihid);\n\tif (ret) {\n\t\tdev_err(&ihid->client->dev,\n\t\t\t\"failed to reset device: %d\\n\", ret);\n\t\ti2c_hid_set_power(ihid, I2C_HID_PWR_SLEEP);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (!(ihid->quirks & I2C_HID_QUIRK_NO_WAKEUP_AFTER_RESET))\n\t\tret = i2c_hid_set_power(ihid, I2C_HID_PWR_ON);\n\nout_unlock:\n\tmutex_unlock(&ihid->reset_lock);\n\treturn ret;\n}\n\nstatic void i2c_hid_get_input(struct i2c_hid *ihid)\n{\n\tu16 size = le16_to_cpu(ihid->hdesc.wMaxInputLength);\n\tu16 ret_size;\n\tint ret;\n\n\tif (size > ihid->bufsize)\n\t\tsize = ihid->bufsize;\n\n\tret = i2c_master_recv(ihid->client, ihid->inbuf, size);\n\tif (ret != size) {\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tdev_err(&ihid->client->dev, \"%s: got %d data instead of %d\\n\",\n\t\t\t__func__, ret, size);\n\t\treturn;\n\t}\n\n\t \n\tret_size = le16_to_cpup((__le16 *)ihid->inbuf);\n\tif (!ret_size) {\n\t\t \n\t\tif (test_and_clear_bit(I2C_HID_RESET_PENDING, &ihid->flags))\n\t\t\twake_up(&ihid->wait);\n\t\treturn;\n\t}\n\n\tif ((ihid->quirks & I2C_HID_QUIRK_BOGUS_IRQ) && ret_size == 0xffff) {\n\t\tdev_warn_once(&ihid->client->dev,\n\t\t\t      \"%s: IRQ triggered but there's no data\\n\",\n\t\t\t      __func__);\n\t\treturn;\n\t}\n\n\tif (ret_size > size || ret_size < sizeof(__le16)) {\n\t\tif (ihid->quirks & I2C_HID_QUIRK_BAD_INPUT_SIZE) {\n\t\t\t*(__le16 *)ihid->inbuf = cpu_to_le16(size);\n\t\t\tret_size = size;\n\t\t} else {\n\t\t\tdev_err(&ihid->client->dev,\n\t\t\t\t\"%s: incomplete report (%d/%d)\\n\",\n\t\t\t\t__func__, size, ret_size);\n\t\t\treturn;\n\t\t}\n\t}\n\n\ti2c_hid_dbg(ihid, \"input: %*ph\\n\", ret_size, ihid->inbuf);\n\n\tif (test_bit(I2C_HID_STARTED, &ihid->flags)) {\n\t\tif (ihid->hid->group != HID_GROUP_RMI)\n\t\t\tpm_wakeup_event(&ihid->client->dev, 0);\n\n\t\thid_input_report(ihid->hid, HID_INPUT_REPORT,\n\t\t\t\tihid->inbuf + sizeof(__le16),\n\t\t\t\tret_size - sizeof(__le16), 1);\n\t}\n\n\treturn;\n}\n\nstatic irqreturn_t i2c_hid_irq(int irq, void *dev_id)\n{\n\tstruct i2c_hid *ihid = dev_id;\n\n\tif (test_bit(I2C_HID_READ_PENDING, &ihid->flags))\n\t\treturn IRQ_HANDLED;\n\n\ti2c_hid_get_input(ihid);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int i2c_hid_get_report_length(struct hid_report *report)\n{\n\treturn ((report->size - 1) >> 3) + 1 +\n\t\treport->device->report_enum[report->type].numbered + 2;\n}\n\n \nstatic void i2c_hid_find_max_report(struct hid_device *hid, unsigned int type,\n\t\tunsigned int *max)\n{\n\tstruct hid_report *report;\n\tunsigned int size;\n\n\t \n\tlist_for_each_entry(report, &hid->report_enum[type].report_list, list) {\n\t\tsize = i2c_hid_get_report_length(report);\n\t\tif (*max < size)\n\t\t\t*max = size;\n\t}\n}\n\nstatic void i2c_hid_free_buffers(struct i2c_hid *ihid)\n{\n\tkfree(ihid->inbuf);\n\tkfree(ihid->rawbuf);\n\tkfree(ihid->cmdbuf);\n\tihid->inbuf = NULL;\n\tihid->rawbuf = NULL;\n\tihid->cmdbuf = NULL;\n\tihid->bufsize = 0;\n}\n\nstatic int i2c_hid_alloc_buffers(struct i2c_hid *ihid, size_t report_size)\n{\n\t \n\tint cmd_len = sizeof(__le16) +\t \n\t\t      sizeof(u8) +\t \n\t\t      sizeof(u8) +\t \n\t\t      sizeof(u8) +\t \n\t\t      sizeof(__le16) +\t \n\t\t      sizeof(__le16) +\t \n\t\t      sizeof(u8) +\t \n\t\t      report_size;\n\n\tihid->inbuf = kzalloc(report_size, GFP_KERNEL);\n\tihid->rawbuf = kzalloc(report_size, GFP_KERNEL);\n\tihid->cmdbuf = kzalloc(cmd_len, GFP_KERNEL);\n\n\tif (!ihid->inbuf || !ihid->rawbuf || !ihid->cmdbuf) {\n\t\ti2c_hid_free_buffers(ihid);\n\t\treturn -ENOMEM;\n\t}\n\n\tihid->bufsize = report_size;\n\n\treturn 0;\n}\n\nstatic int i2c_hid_get_raw_report(struct hid_device *hid,\n\t\t\t\t  u8 report_type, u8 report_id,\n\t\t\t\t  u8 *buf, size_t count)\n{\n\tstruct i2c_client *client = hid->driver_data;\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\tint ret_count;\n\n\tif (report_type == HID_OUTPUT_REPORT)\n\t\treturn -EINVAL;\n\n\t \n\tif (!report_id) {\n\t\tbuf[0] = 0;\n\t\tbuf++;\n\t\tcount--;\n\t}\n\n\tret_count = i2c_hid_get_report(ihid,\n\t\t\treport_type == HID_FEATURE_REPORT ? 0x03 : 0x01,\n\t\t\treport_id, buf, count);\n\n\tif (ret_count > 0 && !report_id)\n\t\tret_count++;\n\n\treturn ret_count;\n}\n\nstatic int i2c_hid_output_raw_report(struct hid_device *hid, u8 report_type,\n\t\t\t\t     const u8 *buf, size_t count, bool do_set)\n{\n\tstruct i2c_client *client = hid->driver_data;\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\tint report_id = buf[0];\n\tint ret;\n\n\tif (report_type == HID_INPUT_REPORT)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ihid->reset_lock);\n\n\t \n\tret = i2c_hid_set_or_send_report(ihid,\n\t\t\t\treport_type == HID_FEATURE_REPORT ? 0x03 : 0x02,\n\t\t\t\treport_id, buf + 1, count - 1, do_set);\n\n\tif (ret >= 0)\n\t\tret++;  \n\n\tmutex_unlock(&ihid->reset_lock);\n\n\treturn ret;\n}\n\nstatic int i2c_hid_output_report(struct hid_device *hid, u8 *buf, size_t count)\n{\n\treturn i2c_hid_output_raw_report(hid, HID_OUTPUT_REPORT, buf, count,\n\t\t\t\t\t false);\n}\n\nstatic int i2c_hid_raw_request(struct hid_device *hid, unsigned char reportnum,\n\t\t\t       __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t       int reqtype)\n{\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\treturn i2c_hid_get_raw_report(hid, rtype, reportnum, buf, len);\n\tcase HID_REQ_SET_REPORT:\n\t\tif (buf[0] != reportnum)\n\t\t\treturn -EINVAL;\n\t\treturn i2c_hid_output_raw_report(hid, rtype, buf, len, true);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int i2c_hid_parse(struct hid_device *hid)\n{\n\tstruct i2c_client *client = hid->driver_data;\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\tstruct i2c_hid_desc *hdesc = &ihid->hdesc;\n\tunsigned int rsize;\n\tchar *rdesc;\n\tint ret;\n\tint tries = 3;\n\tchar *use_override;\n\n\ti2c_hid_dbg(ihid, \"entering %s\\n\", __func__);\n\n\trsize = le16_to_cpu(hdesc->wReportDescLength);\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tret = i2c_hid_hwreset(ihid);\n\t\tif (ret)\n\t\t\tmsleep(1000);\n\t} while (tries-- > 0 && ret);\n\n\tif (ret)\n\t\treturn ret;\n\n\tuse_override = i2c_hid_get_dmi_hid_report_desc_override(client->name,\n\t\t\t\t\t\t\t\t&rsize);\n\n\tif (use_override) {\n\t\trdesc = use_override;\n\t\ti2c_hid_dbg(ihid, \"Using a HID report descriptor override\\n\");\n\t} else {\n\t\trdesc = kzalloc(rsize, GFP_KERNEL);\n\n\t\tif (!rdesc) {\n\t\t\tdbg_hid(\"couldn't allocate rdesc memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ti2c_hid_dbg(ihid, \"asking HID report descriptor\\n\");\n\n\t\tret = i2c_hid_read_register(ihid,\n\t\t\t\t\t    ihid->hdesc.wReportDescRegister,\n\t\t\t\t\t    rdesc, rsize);\n\t\tif (ret) {\n\t\t\thid_err(hid, \"reading report descriptor failed\\n\");\n\t\t\tkfree(rdesc);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\ti2c_hid_dbg(ihid, \"Report Descriptor: %*ph\\n\", rsize, rdesc);\n\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tif (!use_override)\n\t\tkfree(rdesc);\n\n\tif (ret) {\n\t\tdbg_hid(\"parsing report descriptor failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int i2c_hid_start(struct hid_device *hid)\n{\n\tstruct i2c_client *client = hid->driver_data;\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\tint ret;\n\tunsigned int bufsize = HID_MIN_BUFFER_SIZE;\n\n\ti2c_hid_find_max_report(hid, HID_INPUT_REPORT, &bufsize);\n\ti2c_hid_find_max_report(hid, HID_OUTPUT_REPORT, &bufsize);\n\ti2c_hid_find_max_report(hid, HID_FEATURE_REPORT, &bufsize);\n\n\tif (bufsize > ihid->bufsize) {\n\t\tdisable_irq(client->irq);\n\t\ti2c_hid_free_buffers(ihid);\n\n\t\tret = i2c_hid_alloc_buffers(ihid, bufsize);\n\t\tenable_irq(client->irq);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void i2c_hid_stop(struct hid_device *hid)\n{\n\thid->claimed = 0;\n}\n\nstatic int i2c_hid_open(struct hid_device *hid)\n{\n\tstruct i2c_client *client = hid->driver_data;\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\n\tset_bit(I2C_HID_STARTED, &ihid->flags);\n\treturn 0;\n}\n\nstatic void i2c_hid_close(struct hid_device *hid)\n{\n\tstruct i2c_client *client = hid->driver_data;\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\n\tclear_bit(I2C_HID_STARTED, &ihid->flags);\n}\n\nstatic const struct hid_ll_driver i2c_hid_ll_driver = {\n\t.parse = i2c_hid_parse,\n\t.start = i2c_hid_start,\n\t.stop = i2c_hid_stop,\n\t.open = i2c_hid_open,\n\t.close = i2c_hid_close,\n\t.output_report = i2c_hid_output_report,\n\t.raw_request = i2c_hid_raw_request,\n};\n\nstatic int i2c_hid_init_irq(struct i2c_client *client)\n{\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\tunsigned long irqflags = 0;\n\tint ret;\n\n\ti2c_hid_dbg(ihid, \"Requesting IRQ: %d\\n\", client->irq);\n\n\tif (!irq_get_trigger_type(client->irq))\n\t\tirqflags = IRQF_TRIGGER_LOW;\n\n\tret = request_threaded_irq(client->irq, NULL, i2c_hid_irq,\n\t\t\t\t   irqflags | IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t   client->name, ihid);\n\tif (ret < 0) {\n\t\tdev_warn(&client->dev,\n\t\t\t\"Could not register for %s interrupt, irq = %d,\"\n\t\t\t\" ret = %d\\n\",\n\t\t\tclient->name, client->irq, ret);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int i2c_hid_fetch_hid_descriptor(struct i2c_hid *ihid)\n{\n\tstruct i2c_client *client = ihid->client;\n\tstruct i2c_hid_desc *hdesc = &ihid->hdesc;\n\tunsigned int dsize;\n\tint error;\n\n\t \n\tif (i2c_hid_get_dmi_i2c_hid_desc_override(client->name)) {\n\t\ti2c_hid_dbg(ihid, \"Using a HID descriptor override\\n\");\n\t\tihid->hdesc =\n\t\t\t*i2c_hid_get_dmi_i2c_hid_desc_override(client->name);\n\t} else {\n\t\ti2c_hid_dbg(ihid, \"Fetching the HID descriptor\\n\");\n\t\terror = i2c_hid_read_register(ihid,\n\t\t\t\t\t      ihid->wHIDDescRegister,\n\t\t\t\t\t      &ihid->hdesc,\n\t\t\t\t\t      sizeof(ihid->hdesc));\n\t\tif (error) {\n\t\t\tdev_err(&ihid->client->dev,\n\t\t\t\t\"failed to fetch HID descriptor: %d\\n\",\n\t\t\t\terror);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\t \n\tif (le16_to_cpu(hdesc->bcdVersion) != 0x0100) {\n\t\tdev_err(&ihid->client->dev,\n\t\t\t\"unexpected HID descriptor bcdVersion (0x%04hx)\\n\",\n\t\t\tle16_to_cpu(hdesc->bcdVersion));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdsize = le16_to_cpu(hdesc->wHIDDescLength);\n\tif (dsize != sizeof(struct i2c_hid_desc)) {\n\t\tdev_err(&ihid->client->dev,\n\t\t\t\"weird size of HID descriptor (%u)\\n\", dsize);\n\t\treturn -ENODEV;\n\t}\n\ti2c_hid_dbg(ihid, \"HID Descriptor: %*ph\\n\", dsize, &ihid->hdesc);\n\treturn 0;\n}\n\nstatic int i2c_hid_core_power_up(struct i2c_hid *ihid)\n{\n\tif (!ihid->ops->power_up)\n\t\treturn 0;\n\n\treturn ihid->ops->power_up(ihid->ops);\n}\n\nstatic void i2c_hid_core_power_down(struct i2c_hid *ihid)\n{\n\tif (!ihid->ops->power_down)\n\t\treturn;\n\n\tihid->ops->power_down(ihid->ops);\n}\n\nstatic void i2c_hid_core_shutdown_tail(struct i2c_hid *ihid)\n{\n\tif (!ihid->ops->shutdown_tail)\n\t\treturn;\n\n\tihid->ops->shutdown_tail(ihid->ops);\n}\n\nstatic int i2c_hid_core_suspend(struct i2c_hid *ihid, bool force_poweroff)\n{\n\tstruct i2c_client *client = ihid->client;\n\tstruct hid_device *hid = ihid->hid;\n\tint ret;\n\n\tret = hid_driver_suspend(hid, PMSG_SUSPEND);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ti2c_hid_set_power(ihid, I2C_HID_PWR_SLEEP);\n\n\tdisable_irq(client->irq);\n\n\tif (force_poweroff || !device_may_wakeup(&client->dev))\n\t\ti2c_hid_core_power_down(ihid);\n\n\treturn 0;\n}\n\nstatic int i2c_hid_core_resume(struct i2c_hid *ihid)\n{\n\tstruct i2c_client *client = ihid->client;\n\tstruct hid_device *hid = ihid->hid;\n\tint ret;\n\n\tif (!device_may_wakeup(&client->dev))\n\t\ti2c_hid_core_power_up(ihid);\n\n\tenable_irq(client->irq);\n\n\t \n\tif (ihid->quirks & I2C_HID_QUIRK_RESET_ON_RESUME)\n\t\tret = i2c_hid_hwreset(ihid);\n\telse\n\t\tret = i2c_hid_set_power(ihid, I2C_HID_PWR_ON);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn hid_driver_reset_resume(hid);\n}\n\n \nstatic int __i2c_hid_core_probe(struct i2c_hid *ihid)\n{\n\tstruct i2c_client *client = ihid->client;\n\tstruct hid_device *hid = ihid->hid;\n\tint ret;\n\n\t \n\tret = i2c_smbus_read_byte(client);\n\tif (ret < 0) {\n\t\ti2c_hid_dbg(ihid, \"nothing at this address: %d\\n\", ret);\n\t\treturn -ENXIO;\n\t}\n\n\tret = i2c_hid_fetch_hid_descriptor(ihid);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to fetch the HID Descriptor\\n\");\n\t\treturn ret;\n\t}\n\n\thid->version = le16_to_cpu(ihid->hdesc.bcdVersion);\n\thid->vendor = le16_to_cpu(ihid->hdesc.wVendorID);\n\thid->product = le16_to_cpu(ihid->hdesc.wProductID);\n\n\thid->initial_quirks |= i2c_hid_get_dmi_quirks(hid->vendor,\n\t\t\t\t\t\t      hid->product);\n\n\tsnprintf(hid->name, sizeof(hid->name), \"%s %04X:%04X\",\n\t\t client->name, (u16)hid->vendor, (u16)hid->product);\n\tstrscpy(hid->phys, dev_name(&client->dev), sizeof(hid->phys));\n\n\tihid->quirks = i2c_hid_lookup_quirk(hid->vendor, hid->product);\n\n\treturn 0;\n}\n\nstatic int i2c_hid_core_register_hid(struct i2c_hid *ihid)\n{\n\tstruct i2c_client *client = ihid->client;\n\tstruct hid_device *hid = ihid->hid;\n\tint ret;\n\n\tenable_irq(client->irq);\n\n\tret = hid_add_device(hid);\n\tif (ret) {\n\t\tif (ret != -ENODEV)\n\t\t\thid_err(client, \"can't add hid device: %d\\n\", ret);\n\t\tdisable_irq(client->irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int i2c_hid_core_probe_panel_follower(struct i2c_hid *ihid)\n{\n\tint ret;\n\n\tret = i2c_hid_core_power_up(ihid);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __i2c_hid_core_probe(ihid);\n\tif (ret)\n\t\tgoto err_power_down;\n\n\tret = i2c_hid_core_register_hid(ihid);\n\tif (ret)\n\t\tgoto err_power_down;\n\n\treturn 0;\n\nerr_power_down:\n\ti2c_hid_core_power_down(ihid);\n\n\treturn ret;\n}\n\nstatic void ihid_core_panel_prepare_work(struct work_struct *work)\n{\n\tstruct i2c_hid *ihid = container_of(work, struct i2c_hid,\n\t\t\t\t\t    panel_follower_prepare_work);\n\tstruct hid_device *hid = ihid->hid;\n\tint ret;\n\n\t \n\tif (!hid->version)\n\t\tret = i2c_hid_core_probe_panel_follower(ihid);\n\telse\n\t\tret = i2c_hid_core_resume(ihid);\n\n\tif (ret)\n\t\tdev_warn(&ihid->client->dev, \"Power on failed: %d\\n\", ret);\n\telse\n\t\tWRITE_ONCE(ihid->prepare_work_finished, true);\n\n\t \n\tsmp_wmb();\n}\n\nstatic int i2c_hid_core_panel_prepared(struct drm_panel_follower *follower)\n{\n\tstruct i2c_hid *ihid = container_of(follower, struct i2c_hid, panel_follower);\n\n\t \n\tWRITE_ONCE(ihid->prepare_work_finished, false);\n\tschedule_work(&ihid->panel_follower_prepare_work);\n\n\treturn 0;\n}\n\nstatic int i2c_hid_core_panel_unpreparing(struct drm_panel_follower *follower)\n{\n\tstruct i2c_hid *ihid = container_of(follower, struct i2c_hid, panel_follower);\n\n\tcancel_work_sync(&ihid->panel_follower_prepare_work);\n\n\t \n\tsmp_rmb();\n\tif (!READ_ONCE(ihid->prepare_work_finished))\n\t\treturn 0;\n\n\treturn i2c_hid_core_suspend(ihid, true);\n}\n\nstatic const struct drm_panel_follower_funcs i2c_hid_core_panel_follower_funcs = {\n\t.panel_prepared = i2c_hid_core_panel_prepared,\n\t.panel_unpreparing = i2c_hid_core_panel_unpreparing,\n};\n\nstatic int i2c_hid_core_register_panel_follower(struct i2c_hid *ihid)\n{\n\tstruct device *dev = &ihid->client->dev;\n\tint ret;\n\n\tihid->panel_follower.funcs = &i2c_hid_core_panel_follower_funcs;\n\n\t \n\tif (device_can_wakeup(dev)) {\n\t\tdev_warn(dev, \"Can't wakeup if following panel\\n\");\n\t\tdevice_set_wakeup_capable(dev, false);\n\t}\n\n\tret = drm_panel_add_follower(dev, &ihid->panel_follower);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint i2c_hid_core_probe(struct i2c_client *client, struct i2chid_ops *ops,\n\t\t       u16 hid_descriptor_address, u32 quirks)\n{\n\tint ret;\n\tstruct i2c_hid *ihid;\n\tstruct hid_device *hid;\n\n\tdbg_hid(\"HID probe called for i2c 0x%02x\\n\", client->addr);\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev,\n\t\t\t\"HID over i2c has not been provided an Int IRQ\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (client->irq < 0) {\n\t\tif (client->irq != -EPROBE_DEFER)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"HID over i2c doesn't have a valid IRQ\\n\");\n\t\treturn client->irq;\n\t}\n\n\tihid = devm_kzalloc(&client->dev, sizeof(*ihid), GFP_KERNEL);\n\tif (!ihid)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, ihid);\n\n\tihid->ops = ops;\n\tihid->client = client;\n\tihid->wHIDDescRegister = cpu_to_le16(hid_descriptor_address);\n\tihid->is_panel_follower = drm_is_panel_follower(&client->dev);\n\n\tinit_waitqueue_head(&ihid->wait);\n\tmutex_init(&ihid->reset_lock);\n\tINIT_WORK(&ihid->panel_follower_prepare_work, ihid_core_panel_prepare_work);\n\n\t \n\tret = i2c_hid_alloc_buffers(ihid, HID_MIN_BUFFER_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\tdevice_enable_async_suspend(&client->dev);\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\tret = PTR_ERR(hid);\n\t\tgoto err_free_buffers;\n\t}\n\n\tihid->hid = hid;\n\n\thid->driver_data = client;\n\thid->ll_driver = &i2c_hid_ll_driver;\n\thid->dev.parent = &client->dev;\n\thid->bus = BUS_I2C;\n\thid->initial_quirks = quirks;\n\n\t \n\tif (!ihid->is_panel_follower) {\n\t\tret = i2c_hid_core_power_up(ihid);\n\t\tif (ret < 0)\n\t\t\tgoto err_destroy_device;\n\n\t\tret = __i2c_hid_core_probe(ihid);\n\t\tif (ret < 0)\n\t\t\tgoto err_power_down;\n\t}\n\n\tret = i2c_hid_init_irq(client);\n\tif (ret < 0)\n\t\tgoto err_power_down;\n\n\t \n\tif (ihid->is_panel_follower)\n\t\tret = i2c_hid_core_register_panel_follower(ihid);\n\telse\n\t\tret = i2c_hid_core_register_hid(ihid);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(client->irq, ihid);\nerr_power_down:\n\tif (!ihid->is_panel_follower)\n\t\ti2c_hid_core_power_down(ihid);\nerr_destroy_device:\n\thid_destroy_device(hid);\nerr_free_buffers:\n\ti2c_hid_free_buffers(ihid);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_hid_core_probe);\n\nvoid i2c_hid_core_remove(struct i2c_client *client)\n{\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\tstruct hid_device *hid;\n\n\t \n\tif (ihid->is_panel_follower)\n\t\tdrm_panel_remove_follower(&ihid->panel_follower);\n\telse\n\t\ti2c_hid_core_suspend(ihid, true);\n\n\thid = ihid->hid;\n\thid_destroy_device(hid);\n\n\tfree_irq(client->irq, ihid);\n\n\tif (ihid->bufsize)\n\t\ti2c_hid_free_buffers(ihid);\n}\nEXPORT_SYMBOL_GPL(i2c_hid_core_remove);\n\nvoid i2c_hid_core_shutdown(struct i2c_client *client)\n{\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\n\ti2c_hid_set_power(ihid, I2C_HID_PWR_SLEEP);\n\tfree_irq(client->irq, ihid);\n\n\ti2c_hid_core_shutdown_tail(ihid);\n}\nEXPORT_SYMBOL_GPL(i2c_hid_core_shutdown);\n\nstatic int i2c_hid_core_pm_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\n\tif (ihid->is_panel_follower)\n\t\treturn 0;\n\n\treturn i2c_hid_core_suspend(ihid, false);\n}\n\nstatic int i2c_hid_core_pm_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct i2c_hid *ihid = i2c_get_clientdata(client);\n\n\tif (ihid->is_panel_follower)\n\t\treturn 0;\n\n\treturn i2c_hid_core_resume(ihid);\n}\n\nconst struct dev_pm_ops i2c_hid_core_pm = {\n\tSYSTEM_SLEEP_PM_OPS(i2c_hid_core_pm_suspend, i2c_hid_core_pm_resume)\n};\nEXPORT_SYMBOL_GPL(i2c_hid_core_pm);\n\nMODULE_DESCRIPTION(\"HID over I2C core driver\");\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}