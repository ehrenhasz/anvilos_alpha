{
  "module_name": "i2c-hid-of.c",
  "hash_id": "672d64c9a09dda9fa7ef2c2231e026702ded40217353f8959cb915aa4cb9b6fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/i2c-hid/i2c-hid-of.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/hid.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n\n#include \"i2c-hid.h\"\n\nstruct i2c_hid_of {\n\tstruct i2chid_ops ops;\n\n\tstruct i2c_client *client;\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator_bulk_data supplies[2];\n\tint post_power_delay_ms;\n\tint post_reset_delay_ms;\n};\n\nstatic int i2c_hid_of_power_up(struct i2chid_ops *ops)\n{\n\tstruct i2c_hid_of *ihid_of = container_of(ops, struct i2c_hid_of, ops);\n\tstruct device *dev = &ihid_of->client->dev;\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ihid_of->supplies),\n\t\t\t\t    ihid_of->supplies);\n\tif (ret) {\n\t\tdev_warn(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ihid_of->post_power_delay_ms)\n\t\tmsleep(ihid_of->post_power_delay_ms);\n\n\tgpiod_set_value_cansleep(ihid_of->reset_gpio, 0);\n\tif (ihid_of->post_reset_delay_ms)\n\t\tmsleep(ihid_of->post_reset_delay_ms);\n\n\treturn 0;\n}\n\nstatic void i2c_hid_of_power_down(struct i2chid_ops *ops)\n{\n\tstruct i2c_hid_of *ihid_of = container_of(ops, struct i2c_hid_of, ops);\n\n\tgpiod_set_value_cansleep(ihid_of->reset_gpio, 1);\n\tregulator_bulk_disable(ARRAY_SIZE(ihid_of->supplies),\n\t\t\t       ihid_of->supplies);\n}\n\nstatic int i2c_hid_of_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct i2c_hid_of *ihid_of;\n\tu16 hid_descriptor_address;\n\tu32 quirks = 0;\n\tint ret;\n\tu32 val;\n\n\tihid_of = devm_kzalloc(dev, sizeof(*ihid_of), GFP_KERNEL);\n\tif (!ihid_of)\n\t\treturn -ENOMEM;\n\n\tihid_of->ops.power_up = i2c_hid_of_power_up;\n\tihid_of->ops.power_down = i2c_hid_of_power_down;\n\n\tret = device_property_read_u32(dev, \"hid-descr-addr\", &val);\n\tif (ret) {\n\t\tdev_err(dev, \"HID register address not provided\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (val >> 16) {\n\t\tdev_err(dev, \"Bad HID register address: 0x%08x\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\thid_descriptor_address = val;\n\n\tif (!device_property_read_u32(dev, \"post-power-on-delay-ms\", &val))\n\t\tihid_of->post_power_delay_ms = val;\n\n\t \n\tif (!device_property_read_u32(dev, \"post-reset-deassert-delay-ms\", &val))\n\t\tihid_of->post_reset_delay_ms = val;\n\n\t \n\tihid_of->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ihid_of->reset_gpio))\n\t\treturn PTR_ERR(ihid_of->reset_gpio);\n\n\tihid_of->supplies[0].supply = \"vdd\";\n\tihid_of->supplies[1].supply = \"vddl\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ihid_of->supplies),\n\t\t\t\t      ihid_of->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_property_read_bool(dev, \"touchscreen-inverted-x\"))\n\t\tquirks |= HID_QUIRK_X_INVERT;\n\n\tif (device_property_read_bool(dev, \"touchscreen-inverted-y\"))\n\t\tquirks |= HID_QUIRK_Y_INVERT;\n\n\treturn i2c_hid_core_probe(client, &ihid_of->ops,\n\t\t\t\t  hid_descriptor_address, quirks);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id i2c_hid_of_match[] = {\n\t{ .compatible = \"hid-over-i2c\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_hid_of_match);\n#endif\n\nstatic const struct i2c_device_id i2c_hid_of_id_table[] = {\n\t{ \"hid\", 0 },\n\t{ \"hid-over-i2c\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, i2c_hid_of_id_table);\n\nstatic struct i2c_driver i2c_hid_of_driver = {\n\t.driver = {\n\t\t.name\t= \"i2c_hid_of\",\n\t\t.pm\t= &i2c_hid_core_pm,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(i2c_hid_of_match),\n\t},\n\n\t.probe\t\t= i2c_hid_of_probe,\n\t.remove\t\t= i2c_hid_core_remove,\n\t.shutdown\t= i2c_hid_core_shutdown,\n\t.id_table\t= i2c_hid_of_id_table,\n};\n\nmodule_i2c_driver(i2c_hid_of_driver);\n\nMODULE_DESCRIPTION(\"HID over I2C OF driver\");\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}