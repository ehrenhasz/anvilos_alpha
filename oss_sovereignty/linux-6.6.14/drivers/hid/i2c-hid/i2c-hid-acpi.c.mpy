{
  "module_name": "i2c-hid-acpi.c",
  "hash_id": "d3cc26645c1c3698435b1c0263d9892f037ee9504c0ab05d3d435526f9a25205",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/i2c-hid/i2c-hid-acpi.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/uuid.h>\n\n#include \"i2c-hid.h\"\n\nstruct i2c_hid_acpi {\n\tstruct i2chid_ops ops;\n\tstruct acpi_device *adev;\n};\n\nstatic const struct acpi_device_id i2c_hid_acpi_blacklist[] = {\n\t \n\t{ \"CHPN0001\" },\n\t \n\t{ \"IDEA5002\" },\n\t{ }\n};\n\n \nstatic guid_t i2c_hid_guid =\n\tGUID_INIT(0x3CDFF6F7, 0x4267, 0x4555,\n\t\t  0xAD, 0x05, 0xB3, 0x0A, 0x3D, 0x89, 0x38, 0xDE);\n\nstatic int i2c_hid_acpi_get_descriptor(struct i2c_hid_acpi *ihid_acpi)\n{\n\tstruct acpi_device *adev = ihid_acpi->adev;\n\tacpi_handle handle = acpi_device_handle(adev);\n\tunion acpi_object *obj;\n\tu16 hid_descriptor_address;\n\n\tif (acpi_match_device_ids(adev, i2c_hid_acpi_blacklist) == 0)\n\t\treturn -ENODEV;\n\n\tobj = acpi_evaluate_dsm_typed(handle, &i2c_hid_guid, 1, 1, NULL,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\tif (!obj) {\n\t\tacpi_handle_err(handle, \"Error _DSM call to get HID descriptor address failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thid_descriptor_address = obj->integer.value;\n\tACPI_FREE(obj);\n\n\treturn hid_descriptor_address;\n}\n\nstatic void i2c_hid_acpi_shutdown_tail(struct i2chid_ops *ops)\n{\n\tstruct i2c_hid_acpi *ihid_acpi = container_of(ops, struct i2c_hid_acpi, ops);\n\n\tacpi_device_set_power(ihid_acpi->adev, ACPI_STATE_D3_COLD);\n}\n\nstatic int i2c_hid_acpi_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct i2c_hid_acpi *ihid_acpi;\n\tu16 hid_descriptor_address;\n\tint ret;\n\n\tihid_acpi = devm_kzalloc(&client->dev, sizeof(*ihid_acpi), GFP_KERNEL);\n\tif (!ihid_acpi)\n\t\treturn -ENOMEM;\n\n\tihid_acpi->adev = ACPI_COMPANION(dev);\n\tihid_acpi->ops.shutdown_tail = i2c_hid_acpi_shutdown_tail;\n\n\tret = i2c_hid_acpi_get_descriptor(ihid_acpi);\n\tif (ret < 0)\n\t\treturn ret;\n\thid_descriptor_address = ret;\n\n\tacpi_device_fix_up_power(ihid_acpi->adev);\n\n\treturn i2c_hid_core_probe(client, &ihid_acpi->ops,\n\t\t\t\t  hid_descriptor_address, 0);\n}\n\nstatic const struct acpi_device_id i2c_hid_acpi_match[] = {\n\t{ \"ACPI0C50\" },\n\t{ \"PNP0C50\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, i2c_hid_acpi_match);\n\nstatic struct i2c_driver i2c_hid_acpi_driver = {\n\t.driver = {\n\t\t.name\t= \"i2c_hid_acpi\",\n\t\t.pm\t= &i2c_hid_core_pm,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.acpi_match_table = i2c_hid_acpi_match,\n\t},\n\n\t.probe\t\t= i2c_hid_acpi_probe,\n\t.remove\t\t= i2c_hid_core_remove,\n\t.shutdown\t= i2c_hid_core_shutdown,\n};\n\nmodule_i2c_driver(i2c_hid_acpi_driver);\n\nMODULE_DESCRIPTION(\"HID over I2C ACPI driver\");\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}