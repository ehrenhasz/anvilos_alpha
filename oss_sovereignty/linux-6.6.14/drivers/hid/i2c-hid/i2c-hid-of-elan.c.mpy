{
  "module_name": "i2c-hid-of-elan.c",
  "hash_id": "bf161902090d26e56df895cd82b4619cf7174e7a23d5ff40fc14d645b03fde5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/i2c-hid/i2c-hid-of-elan.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n\n#include \"i2c-hid.h\"\n\nstruct elan_i2c_hid_chip_data {\n\tunsigned int post_gpio_reset_on_delay_ms;\n\tunsigned int post_gpio_reset_off_delay_ms;\n\tunsigned int post_power_delay_ms;\n\tu16 hid_descriptor_address;\n\tconst char *main_supply_name;\n};\n\nstruct i2c_hid_of_elan {\n\tstruct i2chid_ops ops;\n\n\tstruct regulator *vcc33;\n\tstruct regulator *vccio;\n\tstruct gpio_desc *reset_gpio;\n\tconst struct elan_i2c_hid_chip_data *chip_data;\n};\n\nstatic int elan_i2c_hid_power_up(struct i2chid_ops *ops)\n{\n\tstruct i2c_hid_of_elan *ihid_elan =\n\t\tcontainer_of(ops, struct i2c_hid_of_elan, ops);\n\tint ret;\n\n\tif (ihid_elan->vcc33) {\n\t\tret = regulator_enable(ihid_elan->vcc33);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regulator_enable(ihid_elan->vccio);\n\tif (ret) {\n\t\tregulator_disable(ihid_elan->vcc33);\n\t\treturn ret;\n\t}\n\n\tif (ihid_elan->chip_data->post_power_delay_ms)\n\t\tmsleep(ihid_elan->chip_data->post_power_delay_ms);\n\n\tgpiod_set_value_cansleep(ihid_elan->reset_gpio, 0);\n\tif (ihid_elan->chip_data->post_gpio_reset_on_delay_ms)\n\t\tmsleep(ihid_elan->chip_data->post_gpio_reset_on_delay_ms);\n\n\treturn 0;\n}\n\nstatic void elan_i2c_hid_power_down(struct i2chid_ops *ops)\n{\n\tstruct i2c_hid_of_elan *ihid_elan =\n\t\tcontainer_of(ops, struct i2c_hid_of_elan, ops);\n\n\tgpiod_set_value_cansleep(ihid_elan->reset_gpio, 1);\n\tif (ihid_elan->chip_data->post_gpio_reset_off_delay_ms)\n\t\tmsleep(ihid_elan->chip_data->post_gpio_reset_off_delay_ms);\n\n\tregulator_disable(ihid_elan->vccio);\n\tif (ihid_elan->vcc33)\n\t\tregulator_disable(ihid_elan->vcc33);\n}\n\nstatic int i2c_hid_of_elan_probe(struct i2c_client *client)\n{\n\tstruct i2c_hid_of_elan *ihid_elan;\n\n\tihid_elan = devm_kzalloc(&client->dev, sizeof(*ihid_elan), GFP_KERNEL);\n\tif (!ihid_elan)\n\t\treturn -ENOMEM;\n\n\tihid_elan->ops.power_up = elan_i2c_hid_power_up;\n\tihid_elan->ops.power_down = elan_i2c_hid_power_down;\n\n\t \n\tihid_elan->reset_gpio =\n\t\tdevm_gpiod_get_optional(&client->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ihid_elan->reset_gpio))\n\t\treturn PTR_ERR(ihid_elan->reset_gpio);\n\n\tihid_elan->vccio = devm_regulator_get(&client->dev, \"vccio\");\n\tif (IS_ERR(ihid_elan->vccio))\n\t\treturn PTR_ERR(ihid_elan->vccio);\n\n\tihid_elan->chip_data = device_get_match_data(&client->dev);\n\n\tif (ihid_elan->chip_data->main_supply_name) {\n\t\tihid_elan->vcc33 = devm_regulator_get(&client->dev,\n\t\t\t\t\t\t      ihid_elan->chip_data->main_supply_name);\n\t\tif (IS_ERR(ihid_elan->vcc33))\n\t\t\treturn PTR_ERR(ihid_elan->vcc33);\n\t}\n\n\treturn i2c_hid_core_probe(client, &ihid_elan->ops,\n\t\t\t\t  ihid_elan->chip_data->hid_descriptor_address, 0);\n}\n\nstatic const struct elan_i2c_hid_chip_data elan_ekth6915_chip_data = {\n\t.post_power_delay_ms = 1,\n\t.post_gpio_reset_on_delay_ms = 300,\n\t.hid_descriptor_address = 0x0001,\n\t.main_supply_name = \"vcc33\",\n};\n\nstatic const struct elan_i2c_hid_chip_data ilitek_ili9882t_chip_data = {\n\t.post_power_delay_ms = 1,\n\t.post_gpio_reset_on_delay_ms = 200,\n\t.post_gpio_reset_off_delay_ms = 65,\n\t.hid_descriptor_address = 0x0001,\n\t \n\t.main_supply_name = NULL,\n};\n\nstatic const struct of_device_id elan_i2c_hid_of_match[] = {\n\t{ .compatible = \"elan,ekth6915\", .data = &elan_ekth6915_chip_data },\n\t{ .compatible = \"ilitek,ili9882t\", .data = &ilitek_ili9882t_chip_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, elan_i2c_hid_of_match);\n\nstatic struct i2c_driver elan_i2c_hid_ts_driver = {\n\t.driver = {\n\t\t.name\t= \"i2c_hid_of_elan\",\n\t\t.pm\t= &i2c_hid_core_pm,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(elan_i2c_hid_of_match),\n\t},\n\t.probe\t\t= i2c_hid_of_elan_probe,\n\t.remove\t\t= i2c_hid_core_remove,\n\t.shutdown\t= i2c_hid_core_shutdown,\n};\nmodule_i2c_driver(elan_i2c_hid_ts_driver);\n\nMODULE_AUTHOR(\"Douglas Anderson <dianders@chromium.org>\");\nMODULE_DESCRIPTION(\"Elan i2c-hid touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}