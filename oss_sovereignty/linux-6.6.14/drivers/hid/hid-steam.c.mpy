{
  "module_name": "hid-steam.c",
  "hash_id": "ce3c306f1d3f6dc228cacc3f01ef859ce2a00ffa17dc89cea58f840e1e825be8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-steam.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/delay.h>\n#include <linux/power_supply.h>\n#include \"hid-ids.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\");\n\nstatic bool lizard_mode = true;\n\nstatic DEFINE_MUTEX(steam_devices_lock);\nstatic LIST_HEAD(steam_devices);\n\n#define STEAM_QUIRK_WIRELESS\t\tBIT(0)\n#define STEAM_QUIRK_DECK\t\tBIT(1)\n\n \n#define STEAM_PAD_RESOLUTION 1638\n \n#define STEAM_TRIGGER_RESOLUTION 51\n \n#define STEAM_JOYSTICK_RESOLUTION 51\n \n#define STEAM_DECK_TRIGGER_RESOLUTION 5461\n \n#define STEAM_DECK_JOYSTICK_RESOLUTION 6553\n\n#define STEAM_PAD_FUZZ 256\n\n \n#define STEAM_CMD_SET_MAPPINGS\t\t0x80\n#define STEAM_CMD_CLEAR_MAPPINGS\t0x81\n#define STEAM_CMD_GET_MAPPINGS\t\t0x82\n#define STEAM_CMD_GET_ATTRIB\t\t0x83\n#define STEAM_CMD_GET_ATTRIB_LABEL\t0x84\n#define STEAM_CMD_DEFAULT_MAPPINGS\t0x85\n#define STEAM_CMD_FACTORY_RESET\t\t0x86\n#define STEAM_CMD_WRITE_REGISTER\t0x87\n#define STEAM_CMD_CLEAR_REGISTER\t0x88\n#define STEAM_CMD_READ_REGISTER\t\t0x89\n#define STEAM_CMD_GET_REGISTER_LABEL\t0x8a\n#define STEAM_CMD_GET_REGISTER_MAX\t0x8b\n#define STEAM_CMD_GET_REGISTER_DEFAULT\t0x8c\n#define STEAM_CMD_SET_MODE\t\t0x8d\n#define STEAM_CMD_DEFAULT_MOUSE\t\t0x8e\n#define STEAM_CMD_FORCEFEEDBAK\t\t0x8f\n#define STEAM_CMD_REQUEST_COMM_STATUS\t0xb4\n#define STEAM_CMD_GET_SERIAL\t\t0xae\n#define STEAM_CMD_HAPTIC_RUMBLE\t\t0xeb\n\n \n#define STEAM_REG_LPAD_MODE\t\t0x07\n#define STEAM_REG_RPAD_MODE\t\t0x08\n#define STEAM_REG_RPAD_MARGIN\t\t0x18\n#define STEAM_REG_LED\t\t\t0x2d\n#define STEAM_REG_GYRO_MODE\t\t0x30\n#define STEAM_REG_LPAD_CLICK_PRESSURE\t0x34\n#define STEAM_REG_RPAD_CLICK_PRESSURE\t0x35\n\n \n#define STEAM_EV_INPUT_DATA\t\t0x01\n#define STEAM_EV_CONNECT\t\t0x03\n#define STEAM_EV_BATTERY\t\t0x04\n#define STEAM_EV_DECK_INPUT_DATA\t0x09\n\n \n#define STEAM_GYRO_MODE_OFF\t\t0x0000\n#define STEAM_GYRO_MODE_STEERING\t0x0001\n#define STEAM_GYRO_MODE_TILT\t\t0x0002\n#define STEAM_GYRO_MODE_SEND_ORIENTATION\t0x0004\n#define STEAM_GYRO_MODE_SEND_RAW_ACCEL\t\t0x0008\n#define STEAM_GYRO_MODE_SEND_RAW_GYRO\t\t0x0010\n\n \n#define STEAM_SERIAL_LEN 10\n\nstruct steam_device {\n\tstruct list_head list;\n\tspinlock_t lock;\n\tstruct hid_device *hdev, *client_hdev;\n\tstruct mutex mutex;\n\tbool client_opened;\n\tstruct input_dev __rcu *input;\n\tunsigned long quirks;\n\tstruct work_struct work_connect;\n\tbool connected;\n\tchar serial_no[STEAM_SERIAL_LEN + 1];\n\tstruct power_supply_desc battery_desc;\n\tstruct power_supply __rcu *battery;\n\tu8 battery_charge;\n\tu16 voltage;\n\tstruct delayed_work heartbeat;\n\tstruct work_struct rumble_work;\n\tu16 rumble_left;\n\tu16 rumble_right;\n};\n\nstatic int steam_recv_report(struct steam_device *steam,\n\t\tu8 *data, int size)\n{\n\tstruct hid_report *r;\n\tu8 *buf;\n\tint ret;\n\n\tr = steam->hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[0];\n\tif (!r) {\n\t\thid_err(steam->hdev, \"No HID_FEATURE_REPORT submitted -  nothing to read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hid_report_len(r) < 64)\n\t\treturn -EINVAL;\n\n\tbuf = hid_alloc_report_buf(r, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = hid_hw_raw_request(steam->hdev, 0x00,\n\t\t\tbuf, hid_report_len(r) + 1,\n\t\t\tHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret > 0)\n\t\tmemcpy(data, buf + 1, min(size, ret - 1));\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int steam_send_report(struct steam_device *steam,\n\t\tu8 *cmd, int size)\n{\n\tstruct hid_report *r;\n\tu8 *buf;\n\tunsigned int retries = 50;\n\tint ret;\n\n\tr = steam->hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[0];\n\tif (!r) {\n\t\thid_err(steam->hdev, \"No HID_FEATURE_REPORT submitted -  nothing to read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hid_report_len(r) < 64)\n\t\treturn -EINVAL;\n\n\tbuf = hid_alloc_report_buf(r, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(buf + 1, cmd, size);\n\n\t \n\tdo {\n\t\tret = hid_hw_raw_request(steam->hdev, 0,\n\t\t\t\tbuf, max(size, 64) + 1,\n\t\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\t\tif (ret != -EPIPE)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t} while (--retries);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\thid_err(steam->hdev, \"%s: error %d (%*ph)\\n\", __func__,\n\t\t\t\tret, size, cmd);\n\treturn ret;\n}\n\nstatic inline int steam_send_report_byte(struct steam_device *steam, u8 cmd)\n{\n\treturn steam_send_report(steam, &cmd, 1);\n}\n\nstatic int steam_write_registers(struct steam_device *steam,\n\t\t ...)\n{\n\t \n\tu8 reg;\n\tu16 val;\n\tu8 cmd[64] = {STEAM_CMD_WRITE_REGISTER, 0x00};\n\tint ret;\n\tva_list args;\n\n\tva_start(args, steam);\n\tfor (;;) {\n\t\treg = va_arg(args, int);\n\t\tif (reg == 0)\n\t\t\tbreak;\n\t\tval = va_arg(args, int);\n\t\tcmd[cmd[1] + 2] = reg;\n\t\tcmd[cmd[1] + 3] = val & 0xff;\n\t\tcmd[cmd[1] + 4] = val >> 8;\n\t\tcmd[1] += 3;\n\t}\n\tva_end(args);\n\n\tret = steam_send_report(steam, cmd, 2 + cmd[1]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn steam_recv_report(steam, cmd, 2 + cmd[1]);\n}\n\nstatic int steam_get_serial(struct steam_device *steam)\n{\n\t \n\tint ret;\n\tu8 cmd[] = {STEAM_CMD_GET_SERIAL, 0x15, 0x01};\n\tu8 reply[3 + STEAM_SERIAL_LEN + 1];\n\n\tret = steam_send_report(steam, cmd, sizeof(cmd));\n\tif (ret < 0)\n\t\treturn ret;\n\tret = steam_recv_report(steam, reply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (reply[0] != 0xae || reply[1] != 0x15 || reply[2] != 0x01)\n\t\treturn -EIO;\n\treply[3 + STEAM_SERIAL_LEN] = 0;\n\tstrscpy(steam->serial_no, reply + 3, sizeof(steam->serial_no));\n\treturn 0;\n}\n\n \nstatic inline int steam_request_conn_status(struct steam_device *steam)\n{\n\treturn steam_send_report_byte(steam, STEAM_CMD_REQUEST_COMM_STATUS);\n}\n\nstatic inline int steam_haptic_rumble(struct steam_device *steam,\n\t\t\t\tu16 intensity, u16 left_speed, u16 right_speed,\n\t\t\t\tu8 left_gain, u8 right_gain)\n{\n\tu8 report[11] = {STEAM_CMD_HAPTIC_RUMBLE, 9};\n\n\treport[3] = intensity & 0xFF;\n\treport[4] = intensity >> 8;\n\treport[5] = left_speed & 0xFF;\n\treport[6] = left_speed >> 8;\n\treport[7] = right_speed & 0xFF;\n\treport[8] = right_speed >> 8;\n\treport[9] = left_gain;\n\treport[10] = right_gain;\n\n\treturn steam_send_report(steam, report, sizeof(report));\n}\n\nstatic void steam_haptic_rumble_cb(struct work_struct *work)\n{\n\tstruct steam_device *steam = container_of(work, struct steam_device,\n\t\t\t\t\t\t\trumble_work);\n\tsteam_haptic_rumble(steam, 0, steam->rumble_left,\n\t\tsteam->rumble_right, 2, 0);\n}\n\n#ifdef CONFIG_STEAM_FF\nstatic int steam_play_effect(struct input_dev *dev, void *data,\n\t\t\t\tstruct ff_effect *effect)\n{\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\n\tsteam->rumble_left = effect->u.rumble.strong_magnitude;\n\tsteam->rumble_right = effect->u.rumble.weak_magnitude;\n\n\treturn schedule_work(&steam->rumble_work);\n}\n#endif\n\nstatic void steam_set_lizard_mode(struct steam_device *steam, bool enable)\n{\n\tif (enable) {\n\t\t \n\t\tsteam_send_report_byte(steam, STEAM_CMD_DEFAULT_MAPPINGS);\n\t\t \n\t\tsteam_send_report_byte(steam, STEAM_CMD_DEFAULT_MOUSE);\n\t\tsteam_write_registers(steam,\n\t\t\tSTEAM_REG_RPAD_MARGIN, 0x01,  \n\t\t\t0);\n\n\t\tcancel_delayed_work_sync(&steam->heartbeat);\n\t} else {\n\t\t \n\t\tsteam_send_report_byte(steam, STEAM_CMD_CLEAR_MAPPINGS);\n\n\t\tif (steam->quirks & STEAM_QUIRK_DECK) {\n\t\t\tsteam_write_registers(steam,\n\t\t\t\tSTEAM_REG_RPAD_MARGIN, 0x00,  \n\t\t\t\tSTEAM_REG_LPAD_MODE, 0x07,  \n\t\t\t\tSTEAM_REG_RPAD_MODE, 0x07,  \n\t\t\t\tSTEAM_REG_LPAD_CLICK_PRESSURE, 0xFFFF,  \n\t\t\t\tSTEAM_REG_RPAD_CLICK_PRESSURE, 0xFFFF,  \n\t\t\t\t0);\n\t\t\t \n\t\t\tif (!work_busy(&steam->heartbeat.work))\n\t\t\t\tschedule_delayed_work(&steam->heartbeat, 5 * HZ);\n\t\t} else {\n\t\t\tsteam_write_registers(steam,\n\t\t\t\tSTEAM_REG_RPAD_MARGIN, 0x00,  \n\t\t\t\tSTEAM_REG_LPAD_MODE, 0x07,  \n\t\t\t\tSTEAM_REG_RPAD_MODE, 0x07,  \n\t\t\t\t0);\n\t\t}\n\t}\n}\n\nstatic int steam_input_open(struct input_dev *dev)\n{\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\n\tmutex_lock(&steam->mutex);\n\tif (!steam->client_opened && lizard_mode)\n\t\tsteam_set_lizard_mode(steam, false);\n\tmutex_unlock(&steam->mutex);\n\treturn 0;\n}\n\nstatic void steam_input_close(struct input_dev *dev)\n{\n\tstruct steam_device *steam = input_get_drvdata(dev);\n\n\tmutex_lock(&steam->mutex);\n\tif (!steam->client_opened && lizard_mode)\n\t\tsteam_set_lizard_mode(steam, true);\n\tmutex_unlock(&steam->mutex);\n}\n\nstatic enum power_supply_property steam_battery_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n};\n\nstatic int steam_battery_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct steam_device *steam = power_supply_get_drvdata(psy);\n\tunsigned long flags;\n\ts16 volts;\n\tu8 batt;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&steam->lock, flags);\n\tvolts = steam->voltage;\n\tbatt = steam->battery_charge;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = volts * 1000;  \n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = batt;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int steam_battery_register(struct steam_device *steam)\n{\n\tstruct power_supply *battery;\n\tstruct power_supply_config battery_cfg = { .drv_data = steam, };\n\tunsigned long flags;\n\tint ret;\n\n\tsteam->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tsteam->battery_desc.properties = steam_battery_props;\n\tsteam->battery_desc.num_properties = ARRAY_SIZE(steam_battery_props);\n\tsteam->battery_desc.get_property = steam_battery_get_property;\n\tsteam->battery_desc.name = devm_kasprintf(&steam->hdev->dev,\n\t\t\tGFP_KERNEL, \"steam-controller-%s-battery\",\n\t\t\tsteam->serial_no);\n\tif (!steam->battery_desc.name)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_irqsave(&steam->lock, flags);\n\tsteam->voltage = 3000;\n\tsteam->battery_charge = 100;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\n\tbattery = power_supply_register(&steam->hdev->dev,\n\t\t\t&steam->battery_desc, &battery_cfg);\n\tif (IS_ERR(battery)) {\n\t\tret = PTR_ERR(battery);\n\t\thid_err(steam->hdev,\n\t\t\t\t\"%s:power_supply_register failed with error %d\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\trcu_assign_pointer(steam->battery, battery);\n\tpower_supply_powers(battery, &steam->hdev->dev);\n\treturn 0;\n}\n\nstatic int steam_input_register(struct steam_device *steam)\n{\n\tstruct hid_device *hdev = steam->hdev;\n\tstruct input_dev *input;\n\tint ret;\n\n\trcu_read_lock();\n\tinput = rcu_dereference(steam->input);\n\trcu_read_unlock();\n\tif (input) {\n\t\tdbg_hid(\"%s: already connected\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tinput = input_allocate_device();\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(input, steam);\n\tinput->dev.parent = &hdev->dev;\n\tinput->open = steam_input_open;\n\tinput->close = steam_input_close;\n\n\tinput->name = (steam->quirks & STEAM_QUIRK_WIRELESS) ? \"Wireless Steam Controller\" :\n\t\t(steam->quirks & STEAM_QUIRK_DECK) ? \"Steam Deck\" :\n\t\t\"Steam Controller\";\n\tinput->phys = hdev->phys;\n\tinput->uniq = steam->serial_no;\n\tinput->id.bustype = hdev->bus;\n\tinput->id.vendor = hdev->vendor;\n\tinput->id.product = hdev->product;\n\tinput->id.version = hdev->version;\n\n\tinput_set_capability(input, EV_KEY, BTN_TR2);\n\tinput_set_capability(input, EV_KEY, BTN_TL2);\n\tinput_set_capability(input, EV_KEY, BTN_TR);\n\tinput_set_capability(input, EV_KEY, BTN_TL);\n\tinput_set_capability(input, EV_KEY, BTN_Y);\n\tinput_set_capability(input, EV_KEY, BTN_B);\n\tinput_set_capability(input, EV_KEY, BTN_X);\n\tinput_set_capability(input, EV_KEY, BTN_A);\n\tinput_set_capability(input, EV_KEY, BTN_DPAD_UP);\n\tinput_set_capability(input, EV_KEY, BTN_DPAD_RIGHT);\n\tinput_set_capability(input, EV_KEY, BTN_DPAD_LEFT);\n\tinput_set_capability(input, EV_KEY, BTN_DPAD_DOWN);\n\tinput_set_capability(input, EV_KEY, BTN_SELECT);\n\tinput_set_capability(input, EV_KEY, BTN_MODE);\n\tinput_set_capability(input, EV_KEY, BTN_START);\n\tinput_set_capability(input, EV_KEY, BTN_THUMBR);\n\tinput_set_capability(input, EV_KEY, BTN_THUMBL);\n\tinput_set_capability(input, EV_KEY, BTN_THUMB);\n\tinput_set_capability(input, EV_KEY, BTN_THUMB2);\n\tif (steam->quirks & STEAM_QUIRK_DECK) {\n\t\tinput_set_capability(input, EV_KEY, BTN_BASE);\n\t\tinput_set_capability(input, EV_KEY, BTN_TRIGGER_HAPPY1);\n\t\tinput_set_capability(input, EV_KEY, BTN_TRIGGER_HAPPY2);\n\t\tinput_set_capability(input, EV_KEY, BTN_TRIGGER_HAPPY3);\n\t\tinput_set_capability(input, EV_KEY, BTN_TRIGGER_HAPPY4);\n\t} else {\n\t\tinput_set_capability(input, EV_KEY, BTN_GEAR_DOWN);\n\t\tinput_set_capability(input, EV_KEY, BTN_GEAR_UP);\n\t}\n\n\tinput_set_abs_params(input, ABS_X, -32767, 32767, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, -32767, 32767, 0, 0);\n\n\tinput_set_abs_params(input, ABS_HAT0X, -32767, 32767,\n\t\t\tSTEAM_PAD_FUZZ, 0);\n\tinput_set_abs_params(input, ABS_HAT0Y, -32767, 32767,\n\t\t\tSTEAM_PAD_FUZZ, 0);\n\n\tif (steam->quirks & STEAM_QUIRK_DECK) {\n\t\tinput_set_abs_params(input, ABS_HAT2Y, 0, 32767, 0, 0);\n\t\tinput_set_abs_params(input, ABS_HAT2X, 0, 32767, 0, 0);\n\n\t\tinput_set_abs_params(input, ABS_RX, -32767, 32767, 0, 0);\n\t\tinput_set_abs_params(input, ABS_RY, -32767, 32767, 0, 0);\n\n\t\tinput_set_abs_params(input, ABS_HAT1X, -32767, 32767,\n\t\t\t\tSTEAM_PAD_FUZZ, 0);\n\t\tinput_set_abs_params(input, ABS_HAT1Y, -32767, 32767,\n\t\t\t\tSTEAM_PAD_FUZZ, 0);\n\n\t\tinput_abs_set_res(input, ABS_X, STEAM_DECK_JOYSTICK_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_Y, STEAM_DECK_JOYSTICK_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_RX, STEAM_DECK_JOYSTICK_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_RY, STEAM_DECK_JOYSTICK_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_HAT1X, STEAM_PAD_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_HAT1Y, STEAM_PAD_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_HAT2Y, STEAM_DECK_TRIGGER_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_HAT2X, STEAM_DECK_TRIGGER_RESOLUTION);\n\t} else {\n\t\tinput_set_abs_params(input, ABS_HAT2Y, 0, 255, 0, 0);\n\t\tinput_set_abs_params(input, ABS_HAT2X, 0, 255, 0, 0);\n\n\t\tinput_set_abs_params(input, ABS_RX, -32767, 32767,\n\t\t\t\tSTEAM_PAD_FUZZ, 0);\n\t\tinput_set_abs_params(input, ABS_RY, -32767, 32767,\n\t\t\t\tSTEAM_PAD_FUZZ, 0);\n\n\t\tinput_abs_set_res(input, ABS_X, STEAM_JOYSTICK_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_Y, STEAM_JOYSTICK_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_RX, STEAM_PAD_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_RY, STEAM_PAD_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_HAT2Y, STEAM_TRIGGER_RESOLUTION);\n\t\tinput_abs_set_res(input, ABS_HAT2X, STEAM_TRIGGER_RESOLUTION);\n\t}\n\tinput_abs_set_res(input, ABS_HAT0X, STEAM_PAD_RESOLUTION);\n\tinput_abs_set_res(input, ABS_HAT0Y, STEAM_PAD_RESOLUTION);\n\n#ifdef CONFIG_STEAM_FF\n\tif (steam->quirks & STEAM_QUIRK_DECK) {\n\t\tinput_set_capability(input, EV_FF, FF_RUMBLE);\n\t\tret = input_ff_create_memless(input, NULL, steam_play_effect);\n\t\tif (ret)\n\t\t\tgoto input_register_fail;\n\t}\n#endif\n\n\tret = input_register_device(input);\n\tif (ret)\n\t\tgoto input_register_fail;\n\n\trcu_assign_pointer(steam->input, input);\n\treturn 0;\n\ninput_register_fail:\n\tinput_free_device(input);\n\treturn ret;\n}\n\nstatic void steam_input_unregister(struct steam_device *steam)\n{\n\tstruct input_dev *input;\n\trcu_read_lock();\n\tinput = rcu_dereference(steam->input);\n\trcu_read_unlock();\n\tif (!input)\n\t\treturn;\n\tRCU_INIT_POINTER(steam->input, NULL);\n\tsynchronize_rcu();\n\tinput_unregister_device(input);\n}\n\nstatic void steam_battery_unregister(struct steam_device *steam)\n{\n\tstruct power_supply *battery;\n\n\trcu_read_lock();\n\tbattery = rcu_dereference(steam->battery);\n\trcu_read_unlock();\n\n\tif (!battery)\n\t\treturn;\n\tRCU_INIT_POINTER(steam->battery, NULL);\n\tsynchronize_rcu();\n\tpower_supply_unregister(battery);\n}\n\nstatic int steam_register(struct steam_device *steam)\n{\n\tint ret;\n\tbool client_opened;\n\n\t \n\tif (!steam->serial_no[0]) {\n\t\t \n\t\tmutex_lock(&steam->mutex);\n\t\tif (steam_get_serial(steam) < 0)\n\t\t\tstrscpy(steam->serial_no, \"XXXXXXXXXX\",\n\t\t\t\t\tsizeof(steam->serial_no));\n\t\tmutex_unlock(&steam->mutex);\n\n\t\thid_info(steam->hdev, \"Steam Controller '%s' connected\",\n\t\t\t\tsteam->serial_no);\n\n\t\t \n\t\tif (steam->quirks & STEAM_QUIRK_WIRELESS)\n\t\t\tsteam_battery_register(steam);\n\n\t\tmutex_lock(&steam_devices_lock);\n\t\tif (list_empty(&steam->list))\n\t\t\tlist_add(&steam->list, &steam_devices);\n\t\tmutex_unlock(&steam_devices_lock);\n\t}\n\n\tmutex_lock(&steam->mutex);\n\tclient_opened = steam->client_opened;\n\tif (!client_opened)\n\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\tmutex_unlock(&steam->mutex);\n\n\tif (!client_opened)\n\t\tret = steam_input_register(steam);\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic void steam_unregister(struct steam_device *steam)\n{\n\tsteam_battery_unregister(steam);\n\tsteam_input_unregister(steam);\n\tif (steam->serial_no[0]) {\n\t\thid_info(steam->hdev, \"Steam Controller '%s' disconnected\",\n\t\t\t\tsteam->serial_no);\n\t\tmutex_lock(&steam_devices_lock);\n\t\tlist_del_init(&steam->list);\n\t\tmutex_unlock(&steam_devices_lock);\n\t\tsteam->serial_no[0] = 0;\n\t}\n}\n\nstatic void steam_work_connect_cb(struct work_struct *work)\n{\n\tstruct steam_device *steam = container_of(work, struct steam_device,\n\t\t\t\t\t\t\twork_connect);\n\tunsigned long flags;\n\tbool connected;\n\tint ret;\n\n\tspin_lock_irqsave(&steam->lock, flags);\n\tconnected = steam->connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\n\tif (connected) {\n\t\tret = steam_register(steam);\n\t\tif (ret) {\n\t\t\thid_err(steam->hdev,\n\t\t\t\t\"%s:steam_register failed with error %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t}\n\t} else {\n\t\tsteam_unregister(steam);\n\t}\n}\n\nstatic bool steam_is_valve_interface(struct hid_device *hdev)\n{\n\tstruct hid_report_enum *rep_enum;\n\n\t \n\trep_enum = &hdev->report_enum[HID_FEATURE_REPORT];\n\treturn !list_empty(&rep_enum->report_list);\n}\n\nstatic void steam_lizard_mode_heartbeat(struct work_struct *work)\n{\n\tstruct steam_device *steam = container_of(work, struct steam_device,\n\t\t\t\t\t\t\theartbeat.work);\n\n\tmutex_lock(&steam->mutex);\n\tif (!steam->client_opened && steam->client_hdev) {\n\t\tsteam_send_report_byte(steam, STEAM_CMD_CLEAR_MAPPINGS);\n\t\tsteam_write_registers(steam,\n\t\t\tSTEAM_REG_RPAD_MODE, 0x07,  \n\t\t\t0);\n\t\tschedule_delayed_work(&steam->heartbeat, 5 * HZ);\n\t}\n\tmutex_unlock(&steam->mutex);\n}\n\nstatic int steam_client_ll_parse(struct hid_device *hdev)\n{\n\tstruct steam_device *steam = hdev->driver_data;\n\n\treturn hid_parse_report(hdev, steam->hdev->dev_rdesc,\n\t\t\tsteam->hdev->dev_rsize);\n}\n\nstatic int steam_client_ll_start(struct hid_device *hdev)\n{\n\treturn 0;\n}\n\nstatic void steam_client_ll_stop(struct hid_device *hdev)\n{\n}\n\nstatic int steam_client_ll_open(struct hid_device *hdev)\n{\n\tstruct steam_device *steam = hdev->driver_data;\n\n\tmutex_lock(&steam->mutex);\n\tsteam->client_opened = true;\n\tmutex_unlock(&steam->mutex);\n\n\tsteam_input_unregister(steam);\n\n\treturn 0;\n}\n\nstatic void steam_client_ll_close(struct hid_device *hdev)\n{\n\tstruct steam_device *steam = hdev->driver_data;\n\n\tunsigned long flags;\n\tbool connected;\n\n\tspin_lock_irqsave(&steam->lock, flags);\n\tconnected = steam->connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\n\tmutex_lock(&steam->mutex);\n\tsteam->client_opened = false;\n\tif (connected)\n\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\tmutex_unlock(&steam->mutex);\n\n\tif (connected)\n\t\tsteam_input_register(steam);\n}\n\nstatic int steam_client_ll_raw_request(struct hid_device *hdev,\n\t\t\t\tunsigned char reportnum, u8 *buf,\n\t\t\t\tsize_t count, unsigned char report_type,\n\t\t\t\tint reqtype)\n{\n\tstruct steam_device *steam = hdev->driver_data;\n\n\treturn hid_hw_raw_request(steam->hdev, reportnum, buf, count,\n\t\t\treport_type, reqtype);\n}\n\nstatic const struct hid_ll_driver steam_client_ll_driver = {\n\t.parse = steam_client_ll_parse,\n\t.start = steam_client_ll_start,\n\t.stop = steam_client_ll_stop,\n\t.open = steam_client_ll_open,\n\t.close = steam_client_ll_close,\n\t.raw_request = steam_client_ll_raw_request,\n};\n\nstatic struct hid_device *steam_create_client_hid(struct hid_device *hdev)\n{\n\tstruct hid_device *client_hdev;\n\n\tclient_hdev = hid_allocate_device();\n\tif (IS_ERR(client_hdev))\n\t\treturn client_hdev;\n\n\tclient_hdev->ll_driver = &steam_client_ll_driver;\n\tclient_hdev->dev.parent = hdev->dev.parent;\n\tclient_hdev->bus = hdev->bus;\n\tclient_hdev->vendor = hdev->vendor;\n\tclient_hdev->product = hdev->product;\n\tclient_hdev->version = hdev->version;\n\tclient_hdev->type = hdev->type;\n\tclient_hdev->country = hdev->country;\n\tstrscpy(client_hdev->name, hdev->name,\n\t\t\tsizeof(client_hdev->name));\n\tstrscpy(client_hdev->phys, hdev->phys,\n\t\t\tsizeof(client_hdev->phys));\n\t \n\tclient_hdev->group = HID_GROUP_STEAM;\n\treturn client_hdev;\n}\n\nstatic int steam_probe(struct hid_device *hdev,\n\t\t\t\tconst struct hid_device_id *id)\n{\n\tstruct steam_device *steam;\n\tint ret;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev,\n\t\t\t\"%s:parse of hid interface failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tif (hdev->group == HID_GROUP_STEAM)\n\t\treturn hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\t \n\tif (!steam_is_valve_interface(hdev))\n\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\n\tsteam = devm_kzalloc(&hdev->dev, sizeof(*steam), GFP_KERNEL);\n\tif (!steam) {\n\t\tret = -ENOMEM;\n\t\tgoto steam_alloc_fail;\n\t}\n\tsteam->hdev = hdev;\n\thid_set_drvdata(hdev, steam);\n\tspin_lock_init(&steam->lock);\n\tmutex_init(&steam->mutex);\n\tsteam->quirks = id->driver_data;\n\tINIT_WORK(&steam->work_connect, steam_work_connect_cb);\n\tINIT_LIST_HEAD(&steam->list);\n\tINIT_DEFERRABLE_WORK(&steam->heartbeat, steam_lizard_mode_heartbeat);\n\tINIT_WORK(&steam->rumble_work, steam_haptic_rumble_cb);\n\n\tsteam->client_hdev = steam_create_client_hid(hdev);\n\tif (IS_ERR(steam->client_hdev)) {\n\t\tret = PTR_ERR(steam->client_hdev);\n\t\tgoto client_hdev_fail;\n\t}\n\tsteam->client_hdev->driver_data = steam;\n\n\t \n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\tgoto hid_hw_start_fail;\n\n\tret = hid_add_device(steam->client_hdev);\n\tif (ret)\n\t\tgoto client_hdev_add_fail;\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev,\n\t\t\t\"%s:hid_hw_open\\n\",\n\t\t\t__func__);\n\t\tgoto hid_hw_open_fail;\n\t}\n\n\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t\thid_info(hdev, \"Steam wireless receiver connected\");\n\t\t \n\t\tsteam->connected = false;\n\t\tsteam_request_conn_status(steam);\n\t} else {\n\t\t \n\t\tsteam->connected = true;\n\t\tret = steam_register(steam);\n\t\tif (ret) {\n\t\t\thid_err(hdev,\n\t\t\t\t\"%s:steam_register failed with error %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto input_register_fail;\n\t\t}\n\t}\n\n\treturn 0;\n\ninput_register_fail:\nhid_hw_open_fail:\nclient_hdev_add_fail:\n\thid_hw_stop(hdev);\nhid_hw_start_fail:\n\thid_destroy_device(steam->client_hdev);\nclient_hdev_fail:\n\tcancel_work_sync(&steam->work_connect);\n\tcancel_delayed_work_sync(&steam->heartbeat);\n\tcancel_work_sync(&steam->rumble_work);\nsteam_alloc_fail:\n\thid_err(hdev, \"%s: failed with error %d\\n\",\n\t\t\t__func__, ret);\n\treturn ret;\n}\n\nstatic void steam_remove(struct hid_device *hdev)\n{\n\tstruct steam_device *steam = hid_get_drvdata(hdev);\n\n\tif (!steam || hdev->group == HID_GROUP_STEAM) {\n\t\thid_hw_stop(hdev);\n\t\treturn;\n\t}\n\n\thid_destroy_device(steam->client_hdev);\n\tmutex_lock(&steam->mutex);\n\tsteam->client_hdev = NULL;\n\tsteam->client_opened = false;\n\tcancel_delayed_work_sync(&steam->heartbeat);\n\tmutex_unlock(&steam->mutex);\n\tcancel_work_sync(&steam->work_connect);\n\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t\thid_info(hdev, \"Steam wireless receiver disconnected\");\n\t}\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n\tsteam_unregister(steam);\n}\n\nstatic void steam_do_connect_event(struct steam_device *steam, bool connected)\n{\n\tunsigned long flags;\n\tbool changed;\n\n\tspin_lock_irqsave(&steam->lock, flags);\n\tchanged = steam->connected != connected;\n\tsteam->connected = connected;\n\tspin_unlock_irqrestore(&steam->lock, flags);\n\n\tif (changed && schedule_work(&steam->work_connect) == 0)\n\t\tdbg_hid(\"%s: connected=%d event already queued\\n\",\n\t\t\t\t__func__, connected);\n}\n\n \nstatic inline s16 steam_le16(u8 *data)\n{\n\ts16 x = (s16) le16_to_cpup((__le16 *)data);\n\n\treturn x == -32768 ? -32767 : x;\n}\n\n \n\nstatic void steam_do_input_event(struct steam_device *steam,\n\t\tstruct input_dev *input, u8 *data)\n{\n\t \n\tu8 b8, b9, b10;\n\ts16 x, y;\n\tbool lpad_touched, lpad_and_joy;\n\n\tb8 = data[8];\n\tb9 = data[9];\n\tb10 = data[10];\n\n\tinput_report_abs(input, ABS_HAT2Y, data[11]);\n\tinput_report_abs(input, ABS_HAT2X, data[12]);\n\n\t \n\tlpad_touched = b10 & BIT(3);\n\tlpad_and_joy = b10 & BIT(7);\n\tx = steam_le16(data + 16);\n\ty = -steam_le16(data + 18);\n\n\tinput_report_abs(input, lpad_touched ? ABS_HAT0X : ABS_X, x);\n\tinput_report_abs(input, lpad_touched ? ABS_HAT0Y : ABS_Y, y);\n\t \n\tif (lpad_touched && !lpad_and_joy) {\n\t\tinput_report_abs(input, ABS_X, 0);\n\t\tinput_report_abs(input, ABS_Y, 0);\n\t}\n\t \n\tif (!(lpad_touched || lpad_and_joy)) {\n\t\tinput_report_abs(input, ABS_HAT0X, 0);\n\t\tinput_report_abs(input, ABS_HAT0Y, 0);\n\t}\n\n\tinput_report_abs(input, ABS_RX, steam_le16(data + 20));\n\tinput_report_abs(input, ABS_RY, -steam_le16(data + 22));\n\n\tinput_event(input, EV_KEY, BTN_TR2, !!(b8 & BIT(0)));\n\tinput_event(input, EV_KEY, BTN_TL2, !!(b8 & BIT(1)));\n\tinput_event(input, EV_KEY, BTN_TR, !!(b8 & BIT(2)));\n\tinput_event(input, EV_KEY, BTN_TL, !!(b8 & BIT(3)));\n\tinput_event(input, EV_KEY, BTN_Y, !!(b8 & BIT(4)));\n\tinput_event(input, EV_KEY, BTN_B, !!(b8 & BIT(5)));\n\tinput_event(input, EV_KEY, BTN_X, !!(b8 & BIT(6)));\n\tinput_event(input, EV_KEY, BTN_A, !!(b8 & BIT(7)));\n\tinput_event(input, EV_KEY, BTN_SELECT, !!(b9 & BIT(4)));\n\tinput_event(input, EV_KEY, BTN_MODE, !!(b9 & BIT(5)));\n\tinput_event(input, EV_KEY, BTN_START, !!(b9 & BIT(6)));\n\tinput_event(input, EV_KEY, BTN_GEAR_DOWN, !!(b9 & BIT(7)));\n\tinput_event(input, EV_KEY, BTN_GEAR_UP, !!(b10 & BIT(0)));\n\tinput_event(input, EV_KEY, BTN_THUMBR, !!(b10 & BIT(2)));\n\tinput_event(input, EV_KEY, BTN_THUMBL, !!(b10 & BIT(6)));\n\tinput_event(input, EV_KEY, BTN_THUMB, lpad_touched || lpad_and_joy);\n\tinput_event(input, EV_KEY, BTN_THUMB2, !!(b10 & BIT(4)));\n\tinput_event(input, EV_KEY, BTN_DPAD_UP, !!(b9 & BIT(0)));\n\tinput_event(input, EV_KEY, BTN_DPAD_RIGHT, !!(b9 & BIT(1)));\n\tinput_event(input, EV_KEY, BTN_DPAD_LEFT, !!(b9 & BIT(2)));\n\tinput_event(input, EV_KEY, BTN_DPAD_DOWN, !!(b9 & BIT(3)));\n\n\tinput_sync(input);\n}\n\n \nstatic void steam_do_deck_input_event(struct steam_device *steam,\n\t\tstruct input_dev *input, u8 *data)\n{\n\tu8 b8, b9, b10, b11, b13, b14;\n\tbool lpad_touched, rpad_touched;\n\n\tb8 = data[8];\n\tb9 = data[9];\n\tb10 = data[10];\n\tb11 = data[11];\n\tb13 = data[13];\n\tb14 = data[14];\n\n\tlpad_touched = b10 & BIT(3);\n\trpad_touched = b10 & BIT(4);\n\n\tif (lpad_touched) {\n\t\tinput_report_abs(input, ABS_HAT0X, steam_le16(data + 16));\n\t\tinput_report_abs(input, ABS_HAT0Y, steam_le16(data + 18));\n\t} else {\n\t\tinput_report_abs(input, ABS_HAT0X, 0);\n\t\tinput_report_abs(input, ABS_HAT0Y, 0);\n\t}\n\n\tif (rpad_touched) {\n\t\tinput_report_abs(input, ABS_HAT1X, steam_le16(data + 20));\n\t\tinput_report_abs(input, ABS_HAT1Y, steam_le16(data + 22));\n\t} else {\n\t\tinput_report_abs(input, ABS_HAT1X, 0);\n\t\tinput_report_abs(input, ABS_HAT1Y, 0);\n\t}\n\n\tinput_report_abs(input, ABS_X, steam_le16(data + 48));\n\tinput_report_abs(input, ABS_Y, -steam_le16(data + 50));\n\tinput_report_abs(input, ABS_RX, steam_le16(data + 52));\n\tinput_report_abs(input, ABS_RY, -steam_le16(data + 54));\n\n\tinput_report_abs(input, ABS_HAT2Y, steam_le16(data + 44));\n\tinput_report_abs(input, ABS_HAT2X, steam_le16(data + 46));\n\n\tinput_event(input, EV_KEY, BTN_TR2, !!(b8 & BIT(0)));\n\tinput_event(input, EV_KEY, BTN_TL2, !!(b8 & BIT(1)));\n\tinput_event(input, EV_KEY, BTN_TR, !!(b8 & BIT(2)));\n\tinput_event(input, EV_KEY, BTN_TL, !!(b8 & BIT(3)));\n\tinput_event(input, EV_KEY, BTN_Y, !!(b8 & BIT(4)));\n\tinput_event(input, EV_KEY, BTN_B, !!(b8 & BIT(5)));\n\tinput_event(input, EV_KEY, BTN_X, !!(b8 & BIT(6)));\n\tinput_event(input, EV_KEY, BTN_A, !!(b8 & BIT(7)));\n\tinput_event(input, EV_KEY, BTN_SELECT, !!(b9 & BIT(4)));\n\tinput_event(input, EV_KEY, BTN_MODE, !!(b9 & BIT(5)));\n\tinput_event(input, EV_KEY, BTN_START, !!(b9 & BIT(6)));\n\tinput_event(input, EV_KEY, BTN_TRIGGER_HAPPY3, !!(b9 & BIT(7)));\n\tinput_event(input, EV_KEY, BTN_TRIGGER_HAPPY4, !!(b10 & BIT(0)));\n\tinput_event(input, EV_KEY, BTN_THUMBL, !!(b10 & BIT(6)));\n\tinput_event(input, EV_KEY, BTN_THUMBR, !!(b11 & BIT(2)));\n\tinput_event(input, EV_KEY, BTN_DPAD_UP, !!(b9 & BIT(0)));\n\tinput_event(input, EV_KEY, BTN_DPAD_RIGHT, !!(b9 & BIT(1)));\n\tinput_event(input, EV_KEY, BTN_DPAD_LEFT, !!(b9 & BIT(2)));\n\tinput_event(input, EV_KEY, BTN_DPAD_DOWN, !!(b9 & BIT(3)));\n\tinput_event(input, EV_KEY, BTN_THUMB, !!(b10 & BIT(1)));\n\tinput_event(input, EV_KEY, BTN_THUMB2, !!(b10 & BIT(2)));\n\tinput_event(input, EV_KEY, BTN_TRIGGER_HAPPY1, !!(b13 & BIT(1)));\n\tinput_event(input, EV_KEY, BTN_TRIGGER_HAPPY2, !!(b13 & BIT(2)));\n\tinput_event(input, EV_KEY, BTN_BASE, !!(b14 & BIT(2)));\n\n\tinput_sync(input);\n}\n\n \nstatic void steam_do_battery_event(struct steam_device *steam,\n\t\tstruct power_supply *battery, u8 *data)\n{\n\tunsigned long flags;\n\n\ts16 volts = steam_le16(data + 12);\n\tu8 batt = data[14];\n\n\t \n\trcu_read_lock();\n\tbattery = rcu_dereference(steam->battery);\n\tif (likely(battery)) {\n\t\tspin_lock_irqsave(&steam->lock, flags);\n\t\tsteam->voltage = volts;\n\t\tsteam->battery_charge = batt;\n\t\tspin_unlock_irqrestore(&steam->lock, flags);\n\t\tpower_supply_changed(battery);\n\t}\n\trcu_read_unlock();\n}\n\nstatic int steam_raw_event(struct hid_device *hdev,\n\t\t\tstruct hid_report *report, u8 *data,\n\t\t\tint size)\n{\n\tstruct steam_device *steam = hid_get_drvdata(hdev);\n\tstruct input_dev *input;\n\tstruct power_supply *battery;\n\n\tif (!steam)\n\t\treturn 0;\n\n\tif (steam->client_opened)\n\t\thid_input_report(steam->client_hdev, HID_FEATURE_REPORT,\n\t\t\t\tdata, size, 0);\n\t \n\n\tif (size != 64 || data[0] != 1 || data[1] != 0)\n\t\treturn 0;\n\n\tswitch (data[2]) {\n\tcase STEAM_EV_INPUT_DATA:\n\t\tif (steam->client_opened)\n\t\t\treturn 0;\n\t\trcu_read_lock();\n\t\tinput = rcu_dereference(steam->input);\n\t\tif (likely(input))\n\t\t\tsteam_do_input_event(steam, input, data);\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase STEAM_EV_DECK_INPUT_DATA:\n\t\tif (steam->client_opened)\n\t\t\treturn 0;\n\t\trcu_read_lock();\n\t\tinput = rcu_dereference(steam->input);\n\t\tif (likely(input))\n\t\t\tsteam_do_deck_input_event(steam, input, data);\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase STEAM_EV_CONNECT:\n\t\t \n\t\tswitch (data[4]) {\n\t\tcase 0x01:\n\t\t\tsteam_do_connect_event(steam, false);\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tsteam_do_connect_event(steam, true);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase STEAM_EV_BATTERY:\n\t\tif (steam->quirks & STEAM_QUIRK_WIRELESS) {\n\t\t\trcu_read_lock();\n\t\t\tbattery = rcu_dereference(steam->battery);\n\t\t\tif (likely(battery)) {\n\t\t\t\tsteam_do_battery_event(steam, battery, data);\n\t\t\t} else {\n\t\t\t\tdbg_hid(\n\t\t\t\t\t\"%s: battery data without connect event\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tsteam_do_connect_event(steam, true);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int steam_param_set_lizard_mode(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tstruct steam_device *steam;\n\tint ret;\n\n\tret = param_set_bool(val, kp);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&steam_devices_lock);\n\tlist_for_each_entry(steam, &steam_devices, list) {\n\t\tmutex_lock(&steam->mutex);\n\t\tif (!steam->client_opened)\n\t\t\tsteam_set_lizard_mode(steam, lizard_mode);\n\t\tmutex_unlock(&steam->mutex);\n\t}\n\tmutex_unlock(&steam_devices_lock);\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops steam_lizard_mode_ops = {\n\t.set\t= steam_param_set_lizard_mode,\n\t.get\t= param_get_bool,\n};\n\nmodule_param_cb(lizard_mode, &steam_lizard_mode_ops, &lizard_mode, 0644);\nMODULE_PARM_DESC(lizard_mode,\n\t\"Enable mouse and keyboard emulation (lizard mode) when the gamepad is not in use\");\n\nstatic const struct hid_device_id steam_controllers[] = {\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_VALVE,\n\t\tUSB_DEVICE_ID_STEAM_CONTROLLER)\n\t},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_VALVE,\n\t\tUSB_DEVICE_ID_STEAM_CONTROLLER_WIRELESS),\n\t  .driver_data = STEAM_QUIRK_WIRELESS\n\t},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_VALVE,\n\t\tUSB_DEVICE_ID_STEAM_DECK),\n\t  .driver_data = STEAM_QUIRK_DECK\n\t},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(hid, steam_controllers);\n\nstatic struct hid_driver steam_controller_driver = {\n\t.name = \"hid-steam\",\n\t.id_table = steam_controllers,\n\t.probe = steam_probe,\n\t.remove = steam_remove,\n\t.raw_event = steam_raw_event,\n};\n\nmodule_hid_driver(steam_controller_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}