{
  "module_name": "hid-u2fzero.c",
  "hash_id": "868b24ad13ba25f5db79912e77d5eb367cbfb56ba50a4f9b5ac55b459392037b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-u2fzero.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/hidraw.h>\n#include <linux/hw_random.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/usb.h>\n\n#include \"usbhid/usbhid.h\"\n#include \"hid-ids.h\"\n\n#define DRIVER_SHORT\t\t\"u2fzero\"\n\n#define HID_REPORT_SIZE\t\t64\n\nenum hw_revision {\n\tHW_U2FZERO,\n\tHW_NITROKEY_U2F,\n};\n\nstruct hw_revision_config {\n\tu8 rng_cmd;\n\tu8 wink_cmd;\n\tconst char *name;\n};\n\nstatic const struct hw_revision_config hw_configs[] = {\n\t[HW_U2FZERO] = {\n\t\t.rng_cmd  = 0x21,\n\t\t.wink_cmd = 0x24,\n\t\t.name = \"U2F Zero\",\n\t},\n\t[HW_NITROKEY_U2F] = {\n\t\t.rng_cmd  = 0xc0,\n\t\t.wink_cmd = 0xc2,\n\t\t.name = \"NitroKey U2F\",\n\t},\n};\n\n \n#define CID_BROADCAST\t\t0xffffffff\n\nstruct u2f_hid_msg {\n\tu32 cid;\n\tunion {\n\t\tstruct {\n\t\t\tu8 cmd;\n\t\t\tu8 bcnth;\n\t\t\tu8 bcntl;\n\t\t\tu8 data[HID_REPORT_SIZE - 7];\n\t\t} init;\n\t\tstruct {\n\t\t\tu8 seq;\n\t\t\tu8 data[HID_REPORT_SIZE - 5];\n\t\t} cont;\n\t};\n} __packed;\n\nstruct u2f_hid_report {\n\tu8 report_type;\n\tstruct u2f_hid_msg msg;\n} __packed;\n\n#define U2F_HID_MSG_LEN(f)\t(size_t)(((f).init.bcnth << 8) + (f).init.bcntl)\n\nstruct u2fzero_device {\n\tstruct hid_device\t*hdev;\n\tstruct urb\t\t*urb;\t     \n\tstruct led_classdev\tldev;\t     \n\tstruct hwrng\t\thwrng;\t     \n\tchar\t\t\t*led_name;\n\tchar\t\t\t*rng_name;\n\tu8\t\t\t*buf_out;\n\tu8\t\t\t*buf_in;\n\tstruct mutex\t\tlock;\n\tbool\t\t\tpresent;\n\tkernel_ulong_t\t\thw_revision;\n};\n\nstatic int u2fzero_send(struct u2fzero_device *dev, struct u2f_hid_report *req)\n{\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tmemcpy(dev->buf_out, req, sizeof(struct u2f_hid_report));\n\n\tret = hid_hw_output_report(dev->hdev, dev->buf_out,\n\t\t\t\t   sizeof(struct u2f_hid_msg));\n\n\tmutex_unlock(&dev->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret == sizeof(struct u2f_hid_msg) ? 0 : -EMSGSIZE;\n}\n\nstruct u2fzero_transfer_context {\n\tstruct completion done;\n\tint status;\n};\n\nstatic void u2fzero_read_callback(struct urb *urb)\n{\n\tstruct u2fzero_transfer_context *ctx = urb->context;\n\n\tctx->status = urb->status;\n\tcomplete(&ctx->done);\n}\n\nstatic int u2fzero_recv(struct u2fzero_device *dev,\n\t\t\tstruct u2f_hid_report *req,\n\t\t\tstruct u2f_hid_msg *resp)\n{\n\tint ret;\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct u2fzero_transfer_context ctx;\n\n\tmutex_lock(&dev->lock);\n\n\tmemcpy(dev->buf_out, req, sizeof(struct u2f_hid_report));\n\n\tdev->urb->context = &ctx;\n\tinit_completion(&ctx.done);\n\n\tret = usb_submit_urb(dev->urb, GFP_NOIO);\n\tif (unlikely(ret)) {\n\t\thid_err(hdev, \"usb_submit_urb failed: %d\", ret);\n\t\tgoto err;\n\t}\n\n\tret = hid_hw_output_report(dev->hdev, dev->buf_out,\n\t\t\t\t   sizeof(struct u2f_hid_msg));\n\n\tif (ret < 0) {\n\t\thid_err(hdev, \"hid_hw_output_report failed: %d\", ret);\n\t\tgoto err;\n\t}\n\n\tret = (wait_for_completion_timeout(\n\t\t&ctx.done, msecs_to_jiffies(USB_CTRL_SET_TIMEOUT)));\n\tif (ret == 0) {\n\t\tusb_kill_urb(dev->urb);\n\t\thid_err(hdev, \"urb submission timed out\");\n\t} else {\n\t\tret = dev->urb->actual_length;\n\t\tmemcpy(resp, dev->buf_in, ret);\n\t}\n\nerr:\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}\n\nstatic int u2fzero_blink(struct led_classdev *ldev)\n{\n\tstruct u2fzero_device *dev = container_of(ldev,\n\t\tstruct u2fzero_device, ldev);\n\tstruct u2f_hid_report req = {\n\t\t.report_type = 0,\n\t\t.msg.cid = CID_BROADCAST,\n\t\t.msg.init = {\n\t\t\t.cmd = hw_configs[dev->hw_revision].wink_cmd,\n\t\t\t.bcnth = 0,\n\t\t\t.bcntl = 0,\n\t\t\t.data  = {0},\n\t\t}\n\t};\n\treturn u2fzero_send(dev, &req);\n}\n\nstatic int u2fzero_brightness_set(struct led_classdev *ldev,\n\t\t\t\t  enum led_brightness brightness)\n{\n\tldev->brightness = LED_OFF;\n\tif (brightness)\n\t\treturn u2fzero_blink(ldev);\n\telse\n\t\treturn 0;\n}\n\nstatic int u2fzero_rng_read(struct hwrng *rng, void *data,\n\t\t\t    size_t max, bool wait)\n{\n\tstruct u2fzero_device *dev = container_of(rng,\n\t\tstruct u2fzero_device, hwrng);\n\tstruct u2f_hid_report req = {\n\t\t.report_type = 0,\n\t\t.msg.cid = CID_BROADCAST,\n\t\t.msg.init = {\n\t\t\t.cmd = hw_configs[dev->hw_revision].rng_cmd,\n\t\t\t.bcnth = 0,\n\t\t\t.bcntl = 0,\n\t\t\t.data  = {0},\n\t\t}\n\t};\n\tstruct u2f_hid_msg resp;\n\tint ret;\n\tsize_t actual_length;\n\t \n\tint min_length = offsetof(struct u2f_hid_msg, init.data);\n\n\tif (!dev->present) {\n\t\thid_dbg(dev->hdev, \"device not present\");\n\t\treturn 0;\n\t}\n\n\tret = u2fzero_recv(dev, &req, &resp);\n\n\t \n\tif (ret < min_length)\n\t\treturn 0;\n\n\t \n\tactual_length = min3((size_t)ret - min_length,\n\t\tU2F_HID_MSG_LEN(resp), max);\n\n\tmemcpy(data, resp.init.data, actual_length);\n\n\treturn actual_length;\n}\n\nstatic int u2fzero_init_led(struct u2fzero_device *dev,\n\t\t\t    unsigned int minor)\n{\n\tdev->led_name = devm_kasprintf(&dev->hdev->dev, GFP_KERNEL,\n\t\t\"%s%u\", DRIVER_SHORT, minor);\n\tif (dev->led_name == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->ldev.name = dev->led_name;\n\tdev->ldev.max_brightness = LED_ON;\n\tdev->ldev.flags = LED_HW_PLUGGABLE;\n\tdev->ldev.brightness_set_blocking = u2fzero_brightness_set;\n\n\treturn devm_led_classdev_register(&dev->hdev->dev, &dev->ldev);\n}\n\nstatic int u2fzero_init_hwrng(struct u2fzero_device *dev,\n\t\t\t      unsigned int minor)\n{\n\tdev->rng_name = devm_kasprintf(&dev->hdev->dev, GFP_KERNEL,\n\t\t\"%s-rng%u\", DRIVER_SHORT, minor);\n\tif (dev->rng_name == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hwrng.name = dev->rng_name;\n\tdev->hwrng.read = u2fzero_rng_read;\n\n\treturn devm_hwrng_register(&dev->hdev->dev, &dev->hwrng);\n}\n\nstatic int u2fzero_fill_in_urb(struct u2fzero_device *dev)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct usb_device *udev;\n\tstruct usbhid_device *usbhid = hdev->driver_data;\n\tunsigned int pipe_in;\n\tstruct usb_host_endpoint *ep;\n\n\tif (dev->hdev->bus != BUS_USB)\n\t\treturn -EINVAL;\n\n\tudev = hid_to_usb_dev(hdev);\n\n\tif (!usbhid->urbout || !usbhid->urbin)\n\t\treturn -ENODEV;\n\n\tep = usb_pipe_endpoint(udev, usbhid->urbin->pipe);\n\tif (!ep)\n\t\treturn -ENODEV;\n\n\tdev->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->urb)\n\t\treturn -ENOMEM;\n\n\tpipe_in = (usbhid->urbin->pipe & ~(3 << 30)) | (PIPE_INTERRUPT << 30);\n\n\tusb_fill_int_urb(dev->urb,\n\t\tudev,\n\t\tpipe_in,\n\t\tdev->buf_in,\n\t\tHID_REPORT_SIZE,\n\t\tu2fzero_read_callback,\n\t\tNULL,\n\t\tep->desc.bInterval);\n\n\treturn 0;\n}\n\nstatic int u2fzero_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct u2fzero_device *dev;\n\tunsigned int minor;\n\tint ret;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->hw_revision = id->driver_data;\n\n\tdev->buf_out = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_report), GFP_KERNEL);\n\tif (dev->buf_out == NULL)\n\t\treturn -ENOMEM;\n\n\tdev->buf_in = devm_kmalloc(&hdev->dev,\n\t\tsizeof(struct u2f_hid_msg), GFP_KERNEL);\n\tif (dev->buf_in == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->hdev = hdev;\n\thid_set_drvdata(hdev, dev);\n\tmutex_init(&dev->lock);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret)\n\t\treturn ret;\n\n\tu2fzero_fill_in_urb(dev);\n\n\tdev->present = true;\n\n\tminor = ((struct hidraw *) hdev->hidraw)->minor;\n\n\tret = u2fzero_init_led(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s LED initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\tret = u2fzero_init_hwrng(dev, minor);\n\tif (ret) {\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"%s RNG initialised\\n\", hw_configs[dev->hw_revision].name);\n\n\treturn 0;\n}\n\nstatic void u2fzero_remove(struct hid_device *hdev)\n{\n\tstruct u2fzero_device *dev = hid_get_drvdata(hdev);\n\n\tmutex_lock(&dev->lock);\n\tdev->present = false;\n\tmutex_unlock(&dev->lock);\n\n\thid_hw_stop(hdev);\n\tusb_poison_urb(dev->urb);\n\tusb_free_urb(dev->urb);\n}\n\nstatic const struct hid_device_id u2fzero_table[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL,\n\t  USB_DEVICE_ID_U2F_ZERO),\n\t  .driver_data = HW_U2FZERO },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CLAY_LOGIC,\n\t  USB_DEVICE_ID_NITROKEY_U2F),\n\t  .driver_data = HW_NITROKEY_U2F },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, u2fzero_table);\n\nstatic struct hid_driver u2fzero_driver = {\n\t.name = \"hid-\" DRIVER_SHORT,\n\t.probe = u2fzero_probe,\n\t.remove = u2fzero_remove,\n\t.id_table = u2fzero_table,\n};\n\nmodule_hid_driver(u2fzero_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrej Shadura <andrew@shadura.me>\");\nMODULE_DESCRIPTION(\"U2F Zero LED and RNG driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}