{
  "module_name": "hid-mf.c",
  "hash_id": "3ccb152eadd3ae77f368e23679ded2707faa627996245076978c754b04024705",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-mf.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\nstruct mf_device {\n\tstruct hid_report *report;\n};\n\nstatic int mf_play(struct input_dev *dev, void *data, struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct mf_device *mf = data;\n\tint strong, weak;\n\n\tstrong = effect->u.rumble.strong_magnitude;\n\tweak = effect->u.rumble.weak_magnitude;\n\n\tdbg_hid(\"Called with 0x%04x 0x%04x.\\n\", strong, weak);\n\n\tstrong = strong * 0xff / 0xffff;\n\tweak = weak * 0xff / 0xffff;\n\n\tdbg_hid(\"Running with 0x%02x 0x%02x.\\n\", strong, weak);\n\n\tmf->report->field[0]->value[0] = weak;\n\tmf->report->field[0]->value[1] = strong;\n\thid_hw_request(hid, mf->report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}\n\nstatic int mf_init(struct hid_device *hid)\n{\n\tstruct mf_device *mf;\n\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\n\tstruct list_head *report_ptr;\n\tstruct hid_report *report;\n\n\tstruct list_head *input_ptr = &hid->inputs;\n\tstruct hid_input *input;\n\n\tstruct input_dev *dev;\n\n\tint error;\n\n\t \n\tlist_for_each(report_ptr, report_list) {\n\t\treport = list_entry(report_ptr, struct hid_report, list);\n\n\t\tif (report->maxfield < 1 || report->field[0]->report_count < 2) {\n\t\t\thid_err(hid, \"Invalid report, this should never happen!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (list_is_last(input_ptr, &hid->inputs)) {\n\t\t\thid_err(hid, \"Missing input, this should never happen!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tinput_ptr = input_ptr->next;\n\t\tinput = list_entry(input_ptr, struct hid_input, list);\n\n\t\tmf = kzalloc(sizeof(struct mf_device), GFP_KERNEL);\n\t\tif (!mf)\n\t\t\treturn -ENOMEM;\n\n\t\tdev = input->input;\n\t\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\t\terror = input_ff_create_memless(dev, mf, mf_play);\n\t\tif (error) {\n\t\t\tkfree(mf);\n\t\t\treturn error;\n\t\t}\n\n\t\tmf->report = report;\n\t\tmf->report->field[0]->value[0] = 0x00;\n\t\tmf->report->field[0]->value[1] = 0x00;\n\t\thid_hw_request(hid, mf->report, HID_REQ_SET_REPORT);\n\t}\n\n\thid_info(hid, \"Force feedback for HJZ Mayflash game controller \"\n\t\t      \"adapters by Marcel Hasler <mahasler@gmail.com>\\n\");\n\n\treturn 0;\n}\n\nstatic int mf_probe(struct hid_device *hid, const struct hid_device_id *id)\n{\n\tint error;\n\n\tdev_dbg(&hid->dev, \"Mayflash HID hardware probe...\\n\");\n\n\t \n\thid->quirks |= id->driver_data;\n\n\terror = hid_parse(hid);\n\tif (error) {\n\t\thid_err(hid, \"HID parse failed.\\n\");\n\t\treturn error;\n\t}\n\n\terror = hid_hw_start(hid, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\tif (error) {\n\t\thid_err(hid, \"HID hw start failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = mf_init(hid);\n\tif (error) {\n\t\thid_err(hid, \"Force feedback init failed.\\n\");\n\t\thid_hw_stop(hid);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id mf_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_PS3),\n\t\t.driver_data = HID_QUIRK_MULTI_INPUT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_DOLPHINBAR),\n\t\t.driver_data = HID_QUIRK_MULTI_INPUT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_GAMECUBE1),\n\t\t.driver_data = HID_QUIRK_MULTI_INPUT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_GAMECUBE2),\n\t\t.driver_data = 0 },  \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_GAMECUBE3),\n\t\t.driver_data = HID_QUIRK_MULTI_INPUT },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, mf_devices);\n\nstatic struct hid_driver mf_driver = {\n\t.name = \"hid_mf\",\n\t.id_table = mf_devices,\n\t.probe = mf_probe,\n};\nmodule_hid_driver(mf_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}