{
  "module_name": "hid-roccat-lua.c",
  "hash_id": "bdfab9375be314db135f4c8b4b9e4877600b3c4e657274a15a36f42b1a1e1026",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-roccat-lua.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/hid-roccat.h>\n#include \"hid-ids.h\"\n#include \"hid-roccat-common.h\"\n#include \"hid-roccat-lua.h\"\n\nstatic ssize_t lua_sysfs_read(struct file *fp, struct kobject *kobj,\n\t\tchar *buf, loff_t off, size_t count,\n\t\tsize_t real_size, uint command)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct lua_device *lua = hid_get_drvdata(dev_get_drvdata(dev));\n\tstruct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));\n\tint retval;\n\n\tif (off >= real_size)\n\t\treturn 0;\n\n\tif (off != 0 || count != real_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lua->lua_lock);\n\tretval = roccat_common2_receive(usb_dev, command, buf, real_size);\n\tmutex_unlock(&lua->lua_lock);\n\n\treturn retval ? retval : real_size;\n}\n\nstatic ssize_t lua_sysfs_write(struct file *fp, struct kobject *kobj,\n\t\tvoid const *buf, loff_t off, size_t count,\n\t\tsize_t real_size, uint command)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct lua_device *lua = hid_get_drvdata(dev_get_drvdata(dev));\n\tstruct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));\n\tint retval;\n\n\tif (off != 0 || count != real_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lua->lua_lock);\n\tretval = roccat_common2_send(usb_dev, command, buf, real_size);\n\tmutex_unlock(&lua->lua_lock);\n\n\treturn retval ? retval : real_size;\n}\n\n#define LUA_SYSFS_W(thingy, THINGY) \\\nstatic ssize_t lua_sysfs_write_ ## thingy(struct file *fp, \\\n\t\tstruct kobject *kobj, struct bin_attribute *attr, \\\n\t\tchar *buf, loff_t off, size_t count) \\\n{ \\\n\treturn lua_sysfs_write(fp, kobj, buf, off, count, \\\n\t\t\tLUA_SIZE_ ## THINGY, LUA_COMMAND_ ## THINGY); \\\n}\n\n#define LUA_SYSFS_R(thingy, THINGY) \\\nstatic ssize_t lua_sysfs_read_ ## thingy(struct file *fp, \\\n\t\tstruct kobject *kobj, struct bin_attribute *attr, \\\n\t\tchar *buf, loff_t off, size_t count) \\\n{ \\\n\treturn lua_sysfs_read(fp, kobj, buf, off, count, \\\n\t\t\tLUA_SIZE_ ## THINGY, LUA_COMMAND_ ## THINGY); \\\n}\n\n#define LUA_BIN_ATTRIBUTE_RW(thingy, THINGY) \\\nLUA_SYSFS_W(thingy, THINGY) \\\nLUA_SYSFS_R(thingy, THINGY) \\\nstatic struct bin_attribute lua_ ## thingy ## _attr = { \\\n\t.attr = { .name = #thingy, .mode = 0660 }, \\\n\t.size = LUA_SIZE_ ## THINGY, \\\n\t.read = lua_sysfs_read_ ## thingy, \\\n\t.write = lua_sysfs_write_ ## thingy \\\n};\n\nLUA_BIN_ATTRIBUTE_RW(control, CONTROL)\n\nstatic int lua_create_sysfs_attributes(struct usb_interface *intf)\n{\n\treturn sysfs_create_bin_file(&intf->dev.kobj, &lua_control_attr);\n}\n\nstatic void lua_remove_sysfs_attributes(struct usb_interface *intf)\n{\n\tsysfs_remove_bin_file(&intf->dev.kobj, &lua_control_attr);\n}\n\nstatic int lua_init_lua_device_struct(struct usb_device *usb_dev,\n\t\tstruct lua_device *lua)\n{\n\tmutex_init(&lua->lua_lock);\n\n\treturn 0;\n}\n\nstatic int lua_init_specials(struct hid_device *hdev)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct lua_device *lua;\n\tint retval;\n\n\tlua = kzalloc(sizeof(*lua), GFP_KERNEL);\n\tif (!lua) {\n\t\thid_err(hdev, \"can't alloc device descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, lua);\n\n\tretval = lua_init_lua_device_struct(usb_dev, lua);\n\tif (retval) {\n\t\thid_err(hdev, \"couldn't init struct lua_device\\n\");\n\t\tgoto exit;\n\t}\n\n\tretval = lua_create_sysfs_attributes(intf);\n\tif (retval) {\n\t\thid_err(hdev, \"cannot create sysfs files\\n\");\n\t\tgoto exit;\n\t}\n\n\treturn 0;\nexit:\n\tkfree(lua);\n\treturn retval;\n}\n\nstatic void lua_remove_specials(struct hid_device *hdev)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct lua_device *lua;\n\n\tlua_remove_sysfs_attributes(intf);\n\n\tlua = hid_get_drvdata(hdev);\n\tkfree(lua);\n}\n\nstatic int lua_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint retval;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (retval) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tretval = lua_init_specials(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"couldn't install mouse\\n\");\n\t\tgoto exit_stop;\n\t}\n\n\treturn 0;\n\nexit_stop:\n\thid_hw_stop(hdev);\nexit:\n\treturn retval;\n}\n\nstatic void lua_remove(struct hid_device *hdev)\n{\n\tlua_remove_specials(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id lua_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_LUA) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(hid, lua_devices);\n\nstatic struct hid_driver lua_driver = {\n\t\t.name = \"lua\",\n\t\t.id_table = lua_devices,\n\t\t.probe = lua_probe,\n\t\t.remove = lua_remove\n};\nmodule_hid_driver(lua_driver);\n\nMODULE_AUTHOR(\"Stefan Achatz\");\nMODULE_DESCRIPTION(\"USB Roccat Lua driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}