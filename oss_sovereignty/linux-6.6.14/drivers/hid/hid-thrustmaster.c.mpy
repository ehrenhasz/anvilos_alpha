{
  "module_name": "hid-thrustmaster.c",
  "hash_id": "39a0455c6c2d16a40867c98c13e46917eab3aef9feed787f67ca36642a635fcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-thrustmaster.c",
  "human_readable_source": "\n \n#include <linux/hid.h>\n#include <linux/usb.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n \nstatic const u8 setup_0[] = { 0x42, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 setup_1[] = { 0x0a, 0x04, 0x90, 0x03, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 setup_2[] = { 0x0a, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 setup_3[] = { 0x0a, 0x04, 0x12, 0x10, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 setup_4[] = { 0x0a, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 *const setup_arr[] = { setup_0, setup_1, setup_2, setup_3, setup_4 };\nstatic const unsigned int setup_arr_sizes[] = {\n\tARRAY_SIZE(setup_0),\n\tARRAY_SIZE(setup_1),\n\tARRAY_SIZE(setup_2),\n\tARRAY_SIZE(setup_3),\n\tARRAY_SIZE(setup_4)\n};\n \nstruct tm_wheel_info {\n\tuint16_t wheel_type;\n\n\t \n\tuint16_t switch_value;\n\n\tchar const *const wheel_name;\n};\n\n \nstatic const struct tm_wheel_info tm_wheels_infos[] = {\n\t{0x0306, 0x0006, \"Thrustmaster T150RS\"},\n\t{0x0200, 0x0005, \"Thrustmaster T300RS (Missing Attachment)\"},\n\t{0x0206, 0x0005, \"Thrustmaster T300RS\"},\n\t{0x0209, 0x0005, \"Thrustmaster T300RS (Open Wheel Attachment)\"},\n\t{0x020a, 0x0005, \"Thrustmaster T300RS (Sparco R383 Mod)\"},\n\t{0x0204, 0x0005, \"Thrustmaster T300 Ferrari Alcantara Edition\"},\n\t{0x0002, 0x0002, \"Thrustmaster T500RS\"}\n\t\n};\n\nstatic const uint8_t tm_wheels_infos_length = 7;\n\n \nstruct __packed tm_wheel_response\n{\n\t \n\tuint16_t type;\n\n\tunion {\n\t\tstruct __packed {\n\t\t\tuint16_t field0;\n\t\t\tuint16_t field1;\n\t\t\t \n\t\t\tuint16_t model;\n\n\t\t\tuint16_t field2;\n\t\t\tuint16_t field3;\n\t\t\tuint16_t field4;\n\t\t\tuint16_t field5;\n\t\t} a;\n\t\tstruct __packed {\n\t\t\tuint16_t field0;\n\t\t\tuint16_t field1;\n\t\t\tuint16_t model;\n\t\t} b;\n\t} data;\n};\n\nstruct tm_wheel {\n\tstruct usb_device *usb_dev;\n\tstruct urb *urb;\n\n\tstruct usb_ctrlrequest *model_request;\n\tstruct tm_wheel_response *response;\n\n\tstruct usb_ctrlrequest *change_request;\n};\n\n \nstatic const struct usb_ctrlrequest model_request = {\n\t.bRequestType = 0xc1,\n\t.bRequest = 73,\n\t.wValue = 0,\n\t.wIndex = 0,\n\t.wLength = cpu_to_le16(0x0010)\n};\n\nstatic const struct usb_ctrlrequest change_request = {\n\t.bRequestType = 0x41,\n\t.bRequest = 83,\n\t.wValue = 0, \n\t.wIndex = 0,\n\t.wLength = 0\n};\n\n \nstatic void thrustmaster_interrupts(struct hid_device *hdev)\n{\n\tint ret, trans, i, b_ep;\n\tu8 *send_buf = kmalloc(256, GFP_KERNEL);\n\tstruct usb_host_endpoint *ep;\n\tstruct device *dev = &hdev->dev;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\n\tif (!send_buf) {\n\t\thid_err(hdev, \"failed allocating send buffer\\n\");\n\t\treturn;\n\t}\n\n\tif (usbif->cur_altsetting->desc.bNumEndpoints < 2) {\n\t\tkfree(send_buf);\n\t\thid_err(hdev, \"Wrong number of endpoints?\\n\");\n\t\treturn;\n\t}\n\n\tep = &usbif->cur_altsetting->endpoint[1];\n\tb_ep = ep->desc.bEndpointAddress;\n\n\tfor (i = 0; i < ARRAY_SIZE(setup_arr); ++i) {\n\t\tmemcpy(send_buf, setup_arr[i], setup_arr_sizes[i]);\n\n\t\tret = usb_interrupt_msg(usbdev,\n\t\t\tusb_sndintpipe(usbdev, b_ep),\n\t\t\tsend_buf,\n\t\t\tsetup_arr_sizes[i],\n\t\t\t&trans,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"setup data couldn't be sent\\n\");\n\t\t\tkfree(send_buf);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkfree(send_buf);\n}\n\nstatic void thrustmaster_change_handler(struct urb *urb)\n{\n\tstruct hid_device *hdev = urb->context;\n\n\t \n\tif (urb->status == 0 || urb->status == -EPROTO || urb->status == -EPIPE)\n\t\thid_info(hdev, \"Success?! The wheel should have been initialized!\\n\");\n\telse\n\t\thid_warn(hdev, \"URB to change wheel mode seems to have failed with error %d\\n\", urb->status);\n}\n\n \nstatic void thrustmaster_model_handler(struct urb *urb)\n{\n\tstruct hid_device *hdev = urb->context;\n\tstruct tm_wheel *tm_wheel = hid_get_drvdata(hdev);\n\tuint16_t model = 0;\n\tint i, ret;\n\tconst struct tm_wheel_info *twi = NULL;\n\n\tif (urb->status) {\n\t\thid_err(hdev, \"URB to get model id failed with error %d\\n\", urb->status);\n\t\treturn;\n\t}\n\n\tif (tm_wheel->response->type == cpu_to_le16(0x49))\n\t\tmodel = le16_to_cpu(tm_wheel->response->data.a.model);\n\telse if (tm_wheel->response->type == cpu_to_le16(0x47))\n\t\tmodel = le16_to_cpu(tm_wheel->response->data.b.model);\n\telse {\n\t\thid_err(hdev, \"Unknown packet type 0x%x, unable to proceed further with wheel init\\n\", tm_wheel->response->type);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < tm_wheels_infos_length && !twi; i++)\n\t\tif (tm_wheels_infos[i].wheel_type == model)\n\t\t\ttwi = tm_wheels_infos + i;\n\n\tif (twi)\n\t\thid_info(hdev, \"Wheel with model id 0x%x is a %s\\n\", model, twi->wheel_name);\n\telse {\n\t\thid_err(hdev, \"Unknown wheel's model id 0x%x, unable to proceed further with wheel init\\n\", model);\n\t\treturn;\n\t}\n\n\ttm_wheel->change_request->wValue = cpu_to_le16(twi->switch_value);\n\tusb_fill_control_urb(\n\t\ttm_wheel->urb,\n\t\ttm_wheel->usb_dev,\n\t\tusb_sndctrlpipe(tm_wheel->usb_dev, 0),\n\t\t(char *)tm_wheel->change_request,\n\t\tNULL, 0,  \n\t\tthrustmaster_change_handler,\n\t\thdev\n\t);\n\n\tret = usb_submit_urb(tm_wheel->urb, GFP_ATOMIC);\n\tif (ret)\n\t\thid_err(hdev, \"Error %d while submitting the change URB. I am unable to initialize this wheel...\\n\", ret);\n}\n\nstatic void thrustmaster_remove(struct hid_device *hdev)\n{\n\tstruct tm_wheel *tm_wheel = hid_get_drvdata(hdev);\n\n\tusb_kill_urb(tm_wheel->urb);\n\n\tkfree(tm_wheel->change_request);\n\tkfree(tm_wheel->response);\n\tkfree(tm_wheel->model_request);\n\tusb_free_urb(tm_wheel->urb);\n\tkfree(tm_wheel);\n\n\thid_hw_stop(hdev);\n}\n\n \nstatic int thrustmaster_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret = 0;\n\tstruct tm_wheel *tm_wheel = NULL;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed with error %d\\n\", ret);\n\t\tgoto error0;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed with error %d\\n\", ret);\n\t\tgoto error0;\n\t}\n\n\t \n\ttm_wheel = kzalloc(sizeof(struct tm_wheel), GFP_KERNEL);\n\tif (!tm_wheel) {\n\t\tret = -ENOMEM;\n\t\tgoto error1;\n\t}\n\n\ttm_wheel->urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!tm_wheel->urb) {\n\t\tret = -ENOMEM;\n\t\tgoto error2;\n\t}\n\n\ttm_wheel->model_request = kmemdup(&model_request,\n\t\t\t\t\t  sizeof(struct usb_ctrlrequest),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!tm_wheel->model_request) {\n\t\tret = -ENOMEM;\n\t\tgoto error3;\n\t}\n\n\ttm_wheel->response = kzalloc(sizeof(struct tm_wheel_response), GFP_KERNEL);\n\tif (!tm_wheel->response) {\n\t\tret = -ENOMEM;\n\t\tgoto error4;\n\t}\n\n\ttm_wheel->change_request = kmemdup(&change_request,\n\t\t\t\t\t   sizeof(struct usb_ctrlrequest),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!tm_wheel->change_request) {\n\t\tret = -ENOMEM;\n\t\tgoto error5;\n\t}\n\n\ttm_wheel->usb_dev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\thid_set_drvdata(hdev, tm_wheel);\n\n\tthrustmaster_interrupts(hdev);\n\n\tusb_fill_control_urb(\n\t\ttm_wheel->urb,\n\t\ttm_wheel->usb_dev,\n\t\tusb_rcvctrlpipe(tm_wheel->usb_dev, 0),\n\t\t(char *)tm_wheel->model_request,\n\t\ttm_wheel->response,\n\t\tsizeof(struct tm_wheel_response),\n\t\tthrustmaster_model_handler,\n\t\thdev\n\t);\n\n\tret = usb_submit_urb(tm_wheel->urb, GFP_ATOMIC);\n\tif (ret) {\n\t\thid_err(hdev, \"Error %d while submitting the URB. I am unable to initialize this wheel...\\n\", ret);\n\t\tgoto error6;\n\t}\n\n\treturn ret;\n\nerror6: kfree(tm_wheel->change_request);\nerror5: kfree(tm_wheel->response);\nerror4: kfree(tm_wheel->model_request);\nerror3: usb_free_urb(tm_wheel->urb);\nerror2: kfree(tm_wheel);\nerror1: hid_hw_stop(hdev);\nerror0:\n\treturn ret;\n}\n\nstatic const struct hid_device_id thrustmaster_devices[] = {\n\t{ HID_USB_DEVICE(0x044f, 0xb65d)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(hid, thrustmaster_devices);\n\nstatic struct hid_driver thrustmaster_driver = {\n\t.name = \"hid-thrustmaster\",\n\t.id_table = thrustmaster_devices,\n\t.probe = thrustmaster_probe,\n\t.remove = thrustmaster_remove,\n};\n\nmodule_hid_driver(thrustmaster_driver);\n\nMODULE_AUTHOR(\"Dario Pagani <dario.pagani.146+linuxk@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Driver to initialize some steering wheel joysticks from Thrustmaster\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}