{
  "module_name": "hid-hyperv.c",
  "hash_id": "49fb2b2e21721356e01a862be29d33f09a18da923300a16d81fdd89835d5fc32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-hyperv.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/completion.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/hiddev.h>\n#include <linux/hyperv.h>\n\n\nstruct hv_input_dev_info {\n\tunsigned int size;\n\tunsigned short vendor;\n\tunsigned short product;\n\tunsigned short version;\n\tunsigned short reserved[11];\n};\n\n \n#define SYNTHHID_INPUT_VERSION_MAJOR\t2\n#define SYNTHHID_INPUT_VERSION_MINOR\t0\n#define SYNTHHID_INPUT_VERSION\t\t(SYNTHHID_INPUT_VERSION_MINOR | \\\n\t\t\t\t\t (SYNTHHID_INPUT_VERSION_MAJOR << 16))\n\n\n#pragma pack(push, 1)\n \nenum synthhid_msg_type {\n\tSYNTH_HID_PROTOCOL_REQUEST,\n\tSYNTH_HID_PROTOCOL_RESPONSE,\n\tSYNTH_HID_INITIAL_DEVICE_INFO,\n\tSYNTH_HID_INITIAL_DEVICE_INFO_ACK,\n\tSYNTH_HID_INPUT_REPORT,\n\tSYNTH_HID_MAX\n};\n\n \nstruct synthhid_msg_hdr {\n\tenum synthhid_msg_type type;\n\tu32 size;\n};\n\nunion synthhid_version {\n\tstruct {\n\t\tu16 minor_version;\n\t\tu16 major_version;\n\t};\n\tu32 version;\n};\n\n \nstruct synthhid_protocol_request {\n\tstruct synthhid_msg_hdr header;\n\tunion synthhid_version version_requested;\n};\n\nstruct synthhid_protocol_response {\n\tstruct synthhid_msg_hdr header;\n\tunion synthhid_version version_requested;\n\tunsigned char approved;\n};\n\nstruct synthhid_device_info {\n\tstruct synthhid_msg_hdr header;\n\tstruct hv_input_dev_info hid_dev_info;\n\tstruct hid_descriptor hid_descriptor;\n};\n\nstruct synthhid_device_info_ack {\n\tstruct synthhid_msg_hdr header;\n\tunsigned char reserved;\n};\n\nstruct synthhid_input_report {\n\tstruct synthhid_msg_hdr header;\n\tchar buffer[];\n};\n\n#pragma pack(pop)\n\n#define INPUTVSC_SEND_RING_BUFFER_SIZE\tVMBUS_RING_SIZE(36 * 1024)\n#define INPUTVSC_RECV_RING_BUFFER_SIZE\tVMBUS_RING_SIZE(36 * 1024)\n\n\nenum pipe_prot_msg_type {\n\tPIPE_MESSAGE_INVALID,\n\tPIPE_MESSAGE_DATA,\n\tPIPE_MESSAGE_MAXIMUM\n};\n\n\nstruct pipe_prt_msg {\n\tenum pipe_prot_msg_type type;\n\tu32 size;\n\tchar data[];\n};\n\nstruct  mousevsc_prt_msg {\n\tenum pipe_prot_msg_type type;\n\tu32 size;\n\tunion {\n\t\tstruct synthhid_protocol_request request;\n\t\tstruct synthhid_protocol_response response;\n\t\tstruct synthhid_device_info_ack ack;\n\t};\n};\n\n \nstruct mousevsc_dev {\n\tstruct hv_device\t*device;\n\tbool\t\t\tinit_complete;\n\tbool\t\t\tconnected;\n\tstruct mousevsc_prt_msg\tprotocol_req;\n\tstruct mousevsc_prt_msg\tprotocol_resp;\n\t \n\tstruct completion\twait_event;\n\tint\t\t\tdev_info_status;\n\n\tstruct hid_descriptor\t*hid_desc;\n\tunsigned char\t\t*report_desc;\n\tu32\t\t\treport_desc_size;\n\tstruct hv_input_dev_info hid_dev_info;\n\tstruct hid_device       *hid_device;\n\tu8\t\t\tinput_buf[HID_MAX_BUFFER_SIZE];\n};\n\n\nstatic struct mousevsc_dev *mousevsc_alloc_device(struct hv_device *device)\n{\n\tstruct mousevsc_dev *input_dev;\n\n\tinput_dev = kzalloc(sizeof(struct mousevsc_dev), GFP_KERNEL);\n\n\tif (!input_dev)\n\t\treturn NULL;\n\n\tinput_dev->device = device;\n\thv_set_drvdata(device, input_dev);\n\tinit_completion(&input_dev->wait_event);\n\tinput_dev->init_complete = false;\n\n\treturn input_dev;\n}\n\nstatic void mousevsc_free_device(struct mousevsc_dev *device)\n{\n\tkfree(device->hid_desc);\n\tkfree(device->report_desc);\n\thv_set_drvdata(device->device, NULL);\n\tkfree(device);\n}\n\nstatic void mousevsc_on_receive_device_info(struct mousevsc_dev *input_device,\n\t\t\t\tstruct synthhid_device_info *device_info)\n{\n\tint ret = 0;\n\tstruct hid_descriptor *desc;\n\tstruct mousevsc_prt_msg ack;\n\n\tinput_device->dev_info_status = -ENOMEM;\n\n\tinput_device->hid_dev_info = device_info->hid_dev_info;\n\tdesc = &device_info->hid_descriptor;\n\tif (desc->bLength == 0)\n\t\tgoto cleanup;\n\n\t \n\tkfree(input_device->hid_desc);\n\tinput_device->hid_desc = kmemdup(desc, desc->bLength, GFP_ATOMIC);\n\n\tif (!input_device->hid_desc)\n\t\tgoto cleanup;\n\n\tinput_device->report_desc_size = le16_to_cpu(\n\t\t\t\t\tdesc->desc[0].wDescriptorLength);\n\tif (input_device->report_desc_size == 0) {\n\t\tinput_device->dev_info_status = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tkfree(input_device->report_desc);\n\tinput_device->report_desc = kzalloc(input_device->report_desc_size,\n\t\t\t\t\t  GFP_ATOMIC);\n\n\tif (!input_device->report_desc) {\n\t\tinput_device->dev_info_status = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tmemcpy(input_device->report_desc,\n\t       ((unsigned char *)desc) + desc->bLength,\n\t       le16_to_cpu(desc->desc[0].wDescriptorLength));\n\n\t \n\tmemset(&ack, 0, sizeof(struct mousevsc_prt_msg));\n\n\tack.type = PIPE_MESSAGE_DATA;\n\tack.size = sizeof(struct synthhid_device_info_ack);\n\n\tack.ack.header.type = SYNTH_HID_INITIAL_DEVICE_INFO_ACK;\n\tack.ack.header.size = 1;\n\tack.ack.reserved = 0;\n\n\tret = vmbus_sendpacket(input_device->device->channel,\n\t\t\t&ack,\n\t\t\tsizeof(struct pipe_prt_msg) +\n\t\t\tsizeof(struct synthhid_device_info_ack),\n\t\t\t(unsigned long)&ack,\n\t\t\tVM_PKT_DATA_INBAND,\n\t\t\tVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\n\tif (!ret)\n\t\tinput_device->dev_info_status = 0;\n\ncleanup:\n\tcomplete(&input_device->wait_event);\n\n\treturn;\n}\n\nstatic void mousevsc_on_receive(struct hv_device *device,\n\t\t\t\tstruct vmpacket_descriptor *packet)\n{\n\tstruct pipe_prt_msg *pipe_msg;\n\tstruct synthhid_msg_hdr *hid_msg_hdr;\n\tstruct mousevsc_dev *input_dev = hv_get_drvdata(device);\n\tstruct synthhid_input_report *input_report;\n\tsize_t len;\n\n\tpipe_msg = (struct pipe_prt_msg *)((unsigned long)packet +\n\t\t\t\t\t\t(packet->offset8 << 3));\n\n\tif (pipe_msg->type != PIPE_MESSAGE_DATA)\n\t\treturn;\n\n\thid_msg_hdr = (struct synthhid_msg_hdr *)pipe_msg->data;\n\n\tswitch (hid_msg_hdr->type) {\n\tcase SYNTH_HID_PROTOCOL_RESPONSE:\n\t\tlen = struct_size(pipe_msg, data, pipe_msg->size);\n\n\t\t \n\t\tif (WARN_ON(len > sizeof(struct mousevsc_prt_msg)))\n\t\t\tbreak;\n\n\t\tmemcpy(&input_dev->protocol_resp, pipe_msg, len);\n\t\tcomplete(&input_dev->wait_event);\n\t\tbreak;\n\n\tcase SYNTH_HID_INITIAL_DEVICE_INFO:\n\t\tWARN_ON(pipe_msg->size < sizeof(struct hv_input_dev_info));\n\n\t\t \n\t\tmousevsc_on_receive_device_info(input_dev,\n\t\t\t(struct synthhid_device_info *)pipe_msg->data);\n\t\tbreak;\n\tcase SYNTH_HID_INPUT_REPORT:\n\t\tinput_report =\n\t\t\t(struct synthhid_input_report *)pipe_msg->data;\n\t\tif (!input_dev->init_complete)\n\t\t\tbreak;\n\n\t\tlen = min(input_report->header.size,\n\t\t\t  (u32)sizeof(input_dev->input_buf));\n\t\tmemcpy(input_dev->input_buf, input_report->buffer, len);\n\t\thid_input_report(input_dev->hid_device, HID_INPUT_REPORT,\n\t\t\t\t input_dev->input_buf, len, 1);\n\n\t\tpm_wakeup_hard_event(&input_dev->device->device);\n\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported hid msg type - type %d len %d\\n\",\n\t\t       hid_msg_hdr->type, hid_msg_hdr->size);\n\t\tbreak;\n\t}\n\n}\n\nstatic void mousevsc_on_channel_callback(void *context)\n{\n\tstruct hv_device *device = context;\n\tstruct vmpacket_descriptor *desc;\n\n\tforeach_vmbus_pkt(desc, device->channel) {\n\t\tswitch (desc->type) {\n\t\tcase VM_PKT_COMP:\n\t\t\tbreak;\n\n\t\tcase VM_PKT_DATA_INBAND:\n\t\t\tmousevsc_on_receive(device, desc);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Unhandled packet type %d, tid %llx len %d\\n\",\n\t\t\t       desc->type, desc->trans_id, desc->len8 * 8);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int mousevsc_connect_to_vsp(struct hv_device *device)\n{\n\tint ret = 0;\n\tunsigned long t;\n\tstruct mousevsc_dev *input_dev = hv_get_drvdata(device);\n\tstruct mousevsc_prt_msg *request;\n\tstruct mousevsc_prt_msg *response;\n\n\treinit_completion(&input_dev->wait_event);\n\n\trequest = &input_dev->protocol_req;\n\tmemset(request, 0, sizeof(struct mousevsc_prt_msg));\n\n\trequest->type = PIPE_MESSAGE_DATA;\n\trequest->size = sizeof(struct synthhid_protocol_request);\n\trequest->request.header.type = SYNTH_HID_PROTOCOL_REQUEST;\n\trequest->request.header.size = sizeof(unsigned int);\n\trequest->request.version_requested.version = SYNTHHID_INPUT_VERSION;\n\n\tret = vmbus_sendpacket(device->channel, request,\n\t\t\t\tsizeof(struct pipe_prt_msg) +\n\t\t\t\tsizeof(struct synthhid_protocol_request),\n\t\t\t\t(unsigned long)request,\n\t\t\t\tVM_PKT_DATA_INBAND,\n\t\t\t\tVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tt = wait_for_completion_timeout(&input_dev->wait_event, 5*HZ);\n\tif (!t) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto cleanup;\n\t}\n\n\tresponse = &input_dev->protocol_resp;\n\n\tif (!response->response.approved) {\n\t\tpr_err(\"synthhid protocol request failed (version %d)\\n\",\n\t\t       SYNTHHID_INPUT_VERSION);\n\t\tret = -ENODEV;\n\t\tgoto cleanup;\n\t}\n\n\tt = wait_for_completion_timeout(&input_dev->wait_event, 5*HZ);\n\tif (!t) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tret = input_dev->dev_info_status;\n\ncleanup:\n\treturn ret;\n}\n\nstatic int mousevsc_hid_parse(struct hid_device *hid)\n{\n\tstruct hv_device *dev = hid_get_drvdata(hid);\n\tstruct mousevsc_dev *input_dev = hv_get_drvdata(dev);\n\n\treturn hid_parse_report(hid, input_dev->report_desc,\n\t\t\t\tinput_dev->report_desc_size);\n}\n\nstatic int mousevsc_hid_open(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic int mousevsc_hid_start(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void mousevsc_hid_close(struct hid_device *hid)\n{\n}\n\nstatic void mousevsc_hid_stop(struct hid_device *hid)\n{\n}\n\nstatic int mousevsc_hid_raw_request(struct hid_device *hid,\n\t\t\t\t    unsigned char report_num,\n\t\t\t\t    __u8 *buf, size_t len,\n\t\t\t\t    unsigned char rtype,\n\t\t\t\t    int reqtype)\n{\n\treturn 0;\n}\n\nstatic const struct hid_ll_driver mousevsc_ll_driver = {\n\t.parse = mousevsc_hid_parse,\n\t.open = mousevsc_hid_open,\n\t.close = mousevsc_hid_close,\n\t.start = mousevsc_hid_start,\n\t.stop = mousevsc_hid_stop,\n\t.raw_request = mousevsc_hid_raw_request,\n};\n\nstatic struct hid_driver mousevsc_hid_driver;\n\nstatic int mousevsc_probe(struct hv_device *device,\n\t\t\tconst struct hv_vmbus_device_id *dev_id)\n{\n\tint ret;\n\tstruct mousevsc_dev *input_dev;\n\tstruct hid_device *hid_dev;\n\n\tinput_dev = mousevsc_alloc_device(device);\n\n\tif (!input_dev)\n\t\treturn -ENOMEM;\n\n\tret = vmbus_open(device->channel,\n\t\tINPUTVSC_SEND_RING_BUFFER_SIZE,\n\t\tINPUTVSC_RECV_RING_BUFFER_SIZE,\n\t\tNULL,\n\t\t0,\n\t\tmousevsc_on_channel_callback,\n\t\tdevice\n\t\t);\n\n\tif (ret)\n\t\tgoto probe_err0;\n\n\tret = mousevsc_connect_to_vsp(device);\n\n\tif (ret)\n\t\tgoto probe_err1;\n\n\t \n\tif (input_dev->report_desc[14] == 0x25)\n\t\tinput_dev->report_desc[14] = 0x29;\n\n\thid_dev = hid_allocate_device();\n\tif (IS_ERR(hid_dev)) {\n\t\tret = PTR_ERR(hid_dev);\n\t\tgoto probe_err1;\n\t}\n\n\thid_dev->ll_driver = &mousevsc_ll_driver;\n\thid_dev->driver = &mousevsc_hid_driver;\n\thid_dev->bus = BUS_VIRTUAL;\n\thid_dev->vendor = input_dev->hid_dev_info.vendor;\n\thid_dev->product = input_dev->hid_dev_info.product;\n\thid_dev->version = input_dev->hid_dev_info.version;\n\tinput_dev->hid_device = hid_dev;\n\n\tsprintf(hid_dev->name, \"%s\", \"Microsoft Vmbus HID-compliant Mouse\");\n\n\thid_set_drvdata(hid_dev, device);\n\n\tret = hid_add_device(hid_dev);\n\tif (ret)\n\t\tgoto probe_err2;\n\n\n\tret = hid_parse(hid_dev);\n\tif (ret) {\n\t\thid_err(hid_dev, \"parse failed\\n\");\n\t\tgoto probe_err2;\n\t}\n\n\tret = hid_hw_start(hid_dev, HID_CONNECT_HIDINPUT | HID_CONNECT_HIDDEV);\n\n\tif (ret) {\n\t\thid_err(hid_dev, \"hw start failed\\n\");\n\t\tgoto probe_err2;\n\t}\n\n\tdevice_init_wakeup(&device->device, true);\n\n\tinput_dev->connected = true;\n\tinput_dev->init_complete = true;\n\n\treturn ret;\n\nprobe_err2:\n\thid_destroy_device(hid_dev);\n\nprobe_err1:\n\tvmbus_close(device->channel);\n\nprobe_err0:\n\tmousevsc_free_device(input_dev);\n\n\treturn ret;\n}\n\n\nstatic void mousevsc_remove(struct hv_device *dev)\n{\n\tstruct mousevsc_dev *input_dev = hv_get_drvdata(dev);\n\n\tdevice_init_wakeup(&dev->device, false);\n\tvmbus_close(dev->channel);\n\thid_hw_stop(input_dev->hid_device);\n\thid_destroy_device(input_dev->hid_device);\n\tmousevsc_free_device(input_dev);\n}\n\nstatic int mousevsc_suspend(struct hv_device *dev)\n{\n\tvmbus_close(dev->channel);\n\n\treturn 0;\n}\n\nstatic int mousevsc_resume(struct hv_device *dev)\n{\n\tint ret;\n\n\tret = vmbus_open(dev->channel,\n\t\t\t INPUTVSC_SEND_RING_BUFFER_SIZE,\n\t\t\t INPUTVSC_RECV_RING_BUFFER_SIZE,\n\t\t\t NULL, 0,\n\t\t\t mousevsc_on_channel_callback,\n\t\t\t dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mousevsc_connect_to_vsp(dev);\n\treturn ret;\n}\n\nstatic const struct hv_vmbus_device_id id_table[] = {\n\t \n\t{ HV_MOUSE_GUID, },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(vmbus, id_table);\n\nstatic struct  hv_driver mousevsc_drv = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = id_table,\n\t.probe = mousevsc_probe,\n\t.remove = mousevsc_remove,\n\t.suspend = mousevsc_suspend,\n\t.resume = mousevsc_resume,\n\t.driver = {\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init mousevsc_init(void)\n{\n\treturn vmbus_driver_register(&mousevsc_drv);\n}\n\nstatic void __exit mousevsc_exit(void)\n{\n\tvmbus_driver_unregister(&mousevsc_drv);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Microsoft Hyper-V Synthetic HID Driver\");\n\nmodule_init(mousevsc_init);\nmodule_exit(mousevsc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}