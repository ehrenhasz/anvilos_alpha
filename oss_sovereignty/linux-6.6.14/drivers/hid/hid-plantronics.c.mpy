{
  "module_name": "hid-plantronics.c",
  "hash_id": "206300251cf395dab911f70d6e7a70df564c25a343e9cb07e32a02b43d80cb12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-plantronics.c",
  "human_readable_source": "\n \n\n \n\n#include \"hid-ids.h\"\n\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n\n#define PLT_HID_1_0_PAGE\t0xffa00000\n#define PLT_HID_2_0_PAGE\t0xffa20000\n\n#define PLT_BASIC_TELEPHONY\t0x0003\n#define PLT_BASIC_EXCEPTION\t0x0005\n\n#define PLT_VOL_UP\t\t0x00b1\n#define PLT_VOL_DOWN\t\t0x00b2\n\n#define PLT1_VOL_UP\t\t(PLT_HID_1_0_PAGE | PLT_VOL_UP)\n#define PLT1_VOL_DOWN\t\t(PLT_HID_1_0_PAGE | PLT_VOL_DOWN)\n#define PLT2_VOL_UP\t\t(PLT_HID_2_0_PAGE | PLT_VOL_UP)\n#define PLT2_VOL_DOWN\t\t(PLT_HID_2_0_PAGE | PLT_VOL_DOWN)\n\n#define PLT_DA60\t\t0xda60\n#define PLT_BT300_MIN\t\t0x0413\n#define PLT_BT300_MAX\t\t0x0418\n\n\n#define PLT_ALLOW_CONSUMER (field->application == HID_CP_CONSUMERCONTROL && \\\n\t\t\t    (usage->hid & HID_USAGE_PAGE) == HID_UP_CONSUMER)\n\n#define PLT_QUIRK_DOUBLE_VOLUME_KEYS BIT(0)\n\n#define PLT_DOUBLE_KEY_TIMEOUT 5  \n\nstruct plt_drv_data {\n\tunsigned long device_type;\n\tunsigned long last_volume_key_ts;\n\tu32 quirks;\n};\n\nstatic int plantronics_input_mapping(struct hid_device *hdev,\n\t\t\t\t     struct hid_input *hi,\n\t\t\t\t     struct hid_field *field,\n\t\t\t\t     struct hid_usage *usage,\n\t\t\t\t     unsigned long **bit, int *max)\n{\n\tunsigned short mapped_key;\n\tstruct plt_drv_data *drv_data = hid_get_drvdata(hdev);\n\tunsigned long plt_type = drv_data->device_type;\n\n\t \n\tif (field->application == HID_GD_JOYSTICK)\n\t\tgoto defaulted;\n\n\t \n\t \n\tif (!(plt_type & HID_USAGE_PAGE)) {\n\t\tswitch (plt_type) {\n\t\tcase PLT_DA60:\n\t\t\tif (PLT_ALLOW_CONSUMER)\n\t\t\t\tgoto defaulted;\n\t\t\tgoto ignored;\n\t\tdefault:\n\t\t\tif (PLT_ALLOW_CONSUMER)\n\t\t\t\tgoto defaulted;\n\t\t}\n\t}\n\t \n\t \n\telse if ((plt_type & HID_USAGE) >= PLT_BASIC_TELEPHONY &&\n\t\t (plt_type & HID_USAGE) != PLT_BASIC_EXCEPTION) {\n\t\tif (PLT_ALLOW_CONSUMER)\n\t\t\tgoto defaulted;\n\t}\n\t \n\t \n\telse if (!((field->application ^ plt_type) & HID_USAGE_PAGE)) {\n\t\tswitch (usage->hid) {\n\t\tcase PLT1_VOL_UP:\n\t\tcase PLT2_VOL_UP:\n\t\t\tmapped_key = KEY_VOLUMEUP;\n\t\t\tgoto mapped;\n\t\tcase PLT1_VOL_DOWN:\n\t\tcase PLT2_VOL_DOWN:\n\t\t\tmapped_key = KEY_VOLUMEDOWN;\n\t\t\tgoto mapped;\n\t\t}\n\t}\n\n \n\nignored:\n\treturn -1;\n\ndefaulted:\n\thid_dbg(hdev, \"usage: %08x (appl: %08x) - defaulted\\n\",\n\t\tusage->hid, field->application);\n\treturn 0;\n\nmapped:\n\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, mapped_key);\n\thid_dbg(hdev, \"usage: %08x (appl: %08x) - mapped to key %d\\n\",\n\t\tusage->hid, field->application, mapped_key);\n\treturn 1;\n}\n\nstatic int plantronics_event(struct hid_device *hdev, struct hid_field *field,\n\t\t\t     struct hid_usage *usage, __s32 value)\n{\n\tstruct plt_drv_data *drv_data = hid_get_drvdata(hdev);\n\n\tif (drv_data->quirks & PLT_QUIRK_DOUBLE_VOLUME_KEYS) {\n\t\tunsigned long prev_ts, cur_ts;\n\n\t\t \n\n\t\tif (!value)  \n\t\t\treturn 0;\n\n\t\tprev_ts = drv_data->last_volume_key_ts;\n\t\tcur_ts = jiffies;\n\t\tif (jiffies_to_msecs(cur_ts - prev_ts) <= PLT_DOUBLE_KEY_TIMEOUT)\n\t\t\treturn 1;  \n\n\t\tdrv_data->last_volume_key_ts = cur_ts;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long plantronics_device_type(struct hid_device *hdev)\n{\n\tunsigned i, col_page;\n\tunsigned long plt_type = hdev->product;\n\n\t \n\tif (plt_type >= PLT_BT300_MIN && plt_type <= PLT_BT300_MAX)\n\t\tgoto exit;\n\n\t \n\tfor (i = 0; i < hdev->maxcollection; i++) {\n\t\tcol_page = hdev->collection[i].usage & HID_USAGE_PAGE;\n\t\tif (col_page == PLT_HID_2_0_PAGE) {\n\t\t\tplt_type = hdev->collection[i].usage;\n\t\t\tbreak;\n\t\t}\n\t\tif (col_page == PLT_HID_1_0_PAGE)\n\t\t\tplt_type = hdev->collection[i].usage;\n\t}\n\nexit:\n\thid_dbg(hdev, \"plt_type decoded as: %08lx\\n\", plt_type);\n\treturn plt_type;\n}\n\nstatic int plantronics_probe(struct hid_device *hdev,\n\t\t\t     const struct hid_device_id *id)\n{\n\tstruct plt_drv_data *drv_data;\n\tint ret;\n\n\tdrv_data = devm_kzalloc(&hdev->dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdrv_data->device_type = plantronics_device_type(hdev);\n\tdrv_data->quirks = id->driver_data;\n\tdrv_data->last_volume_key_ts = jiffies - msecs_to_jiffies(PLT_DOUBLE_KEY_TIMEOUT);\n\n\thid_set_drvdata(hdev, drv_data);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT |\n\t\tHID_CONNECT_HIDINPUT_FORCE | HID_CONNECT_HIDDEV_FORCE);\n\tif (ret)\n\t\thid_err(hdev, \"hw start failed\\n\");\n\nerr:\n\treturn ret;\n}\n\nstatic const struct hid_device_id plantronics_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLANTRONICS,\n\t\t\t\t\t USB_DEVICE_ID_PLANTRONICS_BLACKWIRE_3210_SERIES),\n\t\t.driver_data = PLT_QUIRK_DOUBLE_VOLUME_KEYS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLANTRONICS,\n\t\t\t\t\t USB_DEVICE_ID_PLANTRONICS_BLACKWIRE_3220_SERIES),\n\t\t.driver_data = PLT_QUIRK_DOUBLE_VOLUME_KEYS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLANTRONICS,\n\t\t\t\t\t USB_DEVICE_ID_PLANTRONICS_BLACKWIRE_3215_SERIES),\n\t\t.driver_data = PLT_QUIRK_DOUBLE_VOLUME_KEYS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLANTRONICS,\n\t\t\t\t\t USB_DEVICE_ID_PLANTRONICS_BLACKWIRE_3225_SERIES),\n\t\t.driver_data = PLT_QUIRK_DOUBLE_VOLUME_KEYS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PLANTRONICS, HID_ANY_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, plantronics_devices);\n\nstatic const struct hid_usage_id plantronics_usages[] = {\n\t{ HID_CP_VOLUMEUP, EV_KEY, HID_ANY_ID },\n\t{ HID_CP_VOLUMEDOWN, EV_KEY, HID_ANY_ID },\n\t{ HID_TERMINATOR, HID_TERMINATOR, HID_TERMINATOR }\n};\n\nstatic struct hid_driver plantronics_driver = {\n\t.name = \"plantronics\",\n\t.id_table = plantronics_devices,\n\t.usage_table = plantronics_usages,\n\t.input_mapping = plantronics_input_mapping,\n\t.event = plantronics_event,\n\t.probe = plantronics_probe,\n};\nmodule_hid_driver(plantronics_driver);\n\nMODULE_AUTHOR(\"JD Cole <jd.cole@plantronics.com>\");\nMODULE_AUTHOR(\"Terry Junge <terry.junge@plantronics.com>\");\nMODULE_DESCRIPTION(\"Plantronics USB HID Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}