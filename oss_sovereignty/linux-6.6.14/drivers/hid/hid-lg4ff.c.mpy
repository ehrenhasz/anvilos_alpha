{
  "module_name": "hid-lg4ff.c",
  "hash_id": "94a266ce600eecec466d6a697e7c90555e695742c6065eec1236dbb8e60065c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-lg4ff.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n\n#include \"usbhid/usbhid.h\"\n#include \"hid-lg.h\"\n#include \"hid-lg4ff.h\"\n#include \"hid-ids.h\"\n\n#define LG4FF_MMODE_IS_MULTIMODE 0\n#define LG4FF_MMODE_SWITCHED 1\n#define LG4FF_MMODE_NOT_MULTIMODE 2\n\n#define LG4FF_MODE_NATIVE_IDX 0\n#define LG4FF_MODE_DFEX_IDX 1\n#define LG4FF_MODE_DFP_IDX 2\n#define LG4FF_MODE_G25_IDX 3\n#define LG4FF_MODE_DFGT_IDX 4\n#define LG4FF_MODE_G27_IDX 5\n#define LG4FF_MODE_G29_IDX 6\n#define LG4FF_MODE_MAX_IDX 7\n\n#define LG4FF_MODE_NATIVE BIT(LG4FF_MODE_NATIVE_IDX)\n#define LG4FF_MODE_DFEX BIT(LG4FF_MODE_DFEX_IDX)\n#define LG4FF_MODE_DFP BIT(LG4FF_MODE_DFP_IDX)\n#define LG4FF_MODE_G25 BIT(LG4FF_MODE_G25_IDX)\n#define LG4FF_MODE_DFGT BIT(LG4FF_MODE_DFGT_IDX)\n#define LG4FF_MODE_G27 BIT(LG4FF_MODE_G27_IDX)\n#define LG4FF_MODE_G29 BIT(LG4FF_MODE_G29_IDX)\n\n#define LG4FF_DFEX_TAG \"DF-EX\"\n#define LG4FF_DFEX_NAME \"Driving Force / Formula EX\"\n#define LG4FF_DFP_TAG \"DFP\"\n#define LG4FF_DFP_NAME \"Driving Force Pro\"\n#define LG4FF_G25_TAG \"G25\"\n#define LG4FF_G25_NAME \"G25 Racing Wheel\"\n#define LG4FF_G27_TAG \"G27\"\n#define LG4FF_G27_NAME \"G27 Racing Wheel\"\n#define LG4FF_G29_TAG \"G29\"\n#define LG4FF_G29_NAME \"G29 Racing Wheel\"\n#define LG4FF_DFGT_TAG \"DFGT\"\n#define LG4FF_DFGT_NAME \"Driving Force GT\"\n\n#define LG4FF_FFEX_REV_MAJ 0x21\n#define LG4FF_FFEX_REV_MIN 0x00\n\nstatic void lg4ff_set_range_dfp(struct hid_device *hid, u16 range);\nstatic void lg4ff_set_range_g25(struct hid_device *hid, u16 range);\n\nstruct lg4ff_wheel_data {\n\tconst u32 product_id;\n\tu16 combine;\n\tu16 range;\n\tconst u16 min_range;\n\tconst u16 max_range;\n#ifdef CONFIG_LEDS_CLASS\n\tu8  led_state;\n\tstruct led_classdev *led[5];\n#endif\n\tconst u32 alternate_modes;\n\tconst char * const real_tag;\n\tconst char * const real_name;\n\tconst u16 real_product_id;\n\n\tvoid (*set_range)(struct hid_device *hid, u16 range);\n};\n\nstruct lg4ff_device_entry {\n\tspinlock_t report_lock;  \n\tstruct hid_report *report;\n\tstruct lg4ff_wheel_data wdata;\n};\n\nstatic const signed short lg4ff_wheel_effects[] = {\n\tFF_CONSTANT,\n\tFF_AUTOCENTER,\n\t-1\n};\n\nstatic const signed short no_wheel_effects[] = {\n\t-1\n};\n\nstruct lg4ff_wheel {\n\tconst u32 product_id;\n\tconst signed short *ff_effects;\n\tconst u16 min_range;\n\tconst u16 max_range;\n\tvoid (*set_range)(struct hid_device *hid, u16 range);\n};\n\nstruct lg4ff_compat_mode_switch {\n\tconst u8 cmd_count;\t \n\tconst u8 cmd[];\n};\n\nstruct lg4ff_wheel_ident_info {\n\tconst u32 modes;\n\tconst u16 mask;\n\tconst u16 result;\n\tconst u16 real_product_id;\n};\n\nstruct lg4ff_multimode_wheel {\n\tconst u16 product_id;\n\tconst u32 alternate_modes;\n\tconst char *real_tag;\n\tconst char *real_name;\n};\n\nstruct lg4ff_alternate_mode {\n\tconst u16 product_id;\n\tconst char *tag;\n\tconst char *name;\n};\n\nstatic const struct lg4ff_wheel lg4ff_devices[] = {\n\t{USB_DEVICE_ID_LOGITECH_WINGMAN_FG,  no_wheel_effects,    40, 180, NULL},\n\t{USB_DEVICE_ID_LOGITECH_WINGMAN_FFG, lg4ff_wheel_effects, 40, 180, NULL},\n\t{USB_DEVICE_ID_LOGITECH_WHEEL,       lg4ff_wheel_effects, 40, 270, NULL},\n\t{USB_DEVICE_ID_LOGITECH_MOMO_WHEEL,  lg4ff_wheel_effects, 40, 270, NULL},\n\t{USB_DEVICE_ID_LOGITECH_DFP_WHEEL,   lg4ff_wheel_effects, 40, 900, lg4ff_set_range_dfp},\n\t{USB_DEVICE_ID_LOGITECH_G25_WHEEL,   lg4ff_wheel_effects, 40, 900, lg4ff_set_range_g25},\n\t{USB_DEVICE_ID_LOGITECH_DFGT_WHEEL,  lg4ff_wheel_effects, 40, 900, lg4ff_set_range_g25},\n\t{USB_DEVICE_ID_LOGITECH_G27_WHEEL,   lg4ff_wheel_effects, 40, 900, lg4ff_set_range_g25},\n\t{USB_DEVICE_ID_LOGITECH_G29_WHEEL,   lg4ff_wheel_effects, 40, 900, lg4ff_set_range_g25},\n\t{USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2, lg4ff_wheel_effects, 40, 270, NULL},\n\t{USB_DEVICE_ID_LOGITECH_WII_WHEEL,   lg4ff_wheel_effects, 40, 270, NULL}\n};\n\nstatic const struct lg4ff_multimode_wheel lg4ff_multimode_wheels[] = {\n\t{USB_DEVICE_ID_LOGITECH_DFP_WHEEL,\n\t LG4FF_MODE_NATIVE | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t LG4FF_DFP_TAG, LG4FF_DFP_NAME},\n\t{USB_DEVICE_ID_LOGITECH_G25_WHEEL,\n\t LG4FF_MODE_NATIVE | LG4FF_MODE_G25 | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t LG4FF_G25_TAG, LG4FF_G25_NAME},\n\t{USB_DEVICE_ID_LOGITECH_DFGT_WHEEL,\n\t LG4FF_MODE_NATIVE | LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t LG4FF_DFGT_TAG, LG4FF_DFGT_NAME},\n\t{USB_DEVICE_ID_LOGITECH_G27_WHEEL,\n\t LG4FF_MODE_NATIVE | LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t LG4FF_G27_TAG, LG4FF_G27_NAME},\n\t{USB_DEVICE_ID_LOGITECH_G29_WHEEL,\n\t LG4FF_MODE_NATIVE | LG4FF_MODE_G29 | LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t LG4FF_G29_TAG, LG4FF_G29_NAME},\n};\n\nstatic const struct lg4ff_alternate_mode lg4ff_alternate_modes[] = {\n\t[LG4FF_MODE_NATIVE_IDX] = {0, \"native\", \"\"},\n\t[LG4FF_MODE_DFEX_IDX] = {USB_DEVICE_ID_LOGITECH_WHEEL, LG4FF_DFEX_TAG, LG4FF_DFEX_NAME},\n\t[LG4FF_MODE_DFP_IDX] = {USB_DEVICE_ID_LOGITECH_DFP_WHEEL, LG4FF_DFP_TAG, LG4FF_DFP_NAME},\n\t[LG4FF_MODE_G25_IDX] = {USB_DEVICE_ID_LOGITECH_G25_WHEEL, LG4FF_G25_TAG, LG4FF_G25_NAME},\n\t[LG4FF_MODE_DFGT_IDX] = {USB_DEVICE_ID_LOGITECH_DFGT_WHEEL, LG4FF_DFGT_TAG, LG4FF_DFGT_NAME},\n\t[LG4FF_MODE_G27_IDX] = {USB_DEVICE_ID_LOGITECH_G27_WHEEL, LG4FF_G27_TAG, LG4FF_G27_NAME},\n\t[LG4FF_MODE_G29_IDX] = {USB_DEVICE_ID_LOGITECH_G29_WHEEL, LG4FF_G29_TAG, LG4FF_G29_NAME},\n};\n\n \nstatic const struct lg4ff_wheel_ident_info lg4ff_dfp_ident_info = {\n\tLG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t0xf000,\n\t0x1000,\n\tUSB_DEVICE_ID_LOGITECH_DFP_WHEEL\n};\n\nstatic const struct lg4ff_wheel_ident_info lg4ff_g25_ident_info = {\n\tLG4FF_MODE_G25 | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t0xff00,\n\t0x1200,\n\tUSB_DEVICE_ID_LOGITECH_G25_WHEEL\n};\n\nstatic const struct lg4ff_wheel_ident_info lg4ff_g27_ident_info = {\n\tLG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t0xfff0,\n\t0x1230,\n\tUSB_DEVICE_ID_LOGITECH_G27_WHEEL\n};\n\nstatic const struct lg4ff_wheel_ident_info lg4ff_dfgt_ident_info = {\n\tLG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t0xff00,\n\t0x1300,\n\tUSB_DEVICE_ID_LOGITECH_DFGT_WHEEL\n};\n\nstatic const struct lg4ff_wheel_ident_info lg4ff_g29_ident_info = {\n\tLG4FF_MODE_G29 | LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t0xfff8,\n\t0x1350,\n\tUSB_DEVICE_ID_LOGITECH_G29_WHEEL\n};\n\nstatic const struct lg4ff_wheel_ident_info lg4ff_g29_ident_info2 = {\n\tLG4FF_MODE_G29 | LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,\n\t0xff00,\n\t0x8900,\n\tUSB_DEVICE_ID_LOGITECH_G29_WHEEL\n};\n\n \nstatic const struct lg4ff_wheel_ident_info *lg4ff_main_checklist[] = {\n\t&lg4ff_g29_ident_info,\n\t&lg4ff_g29_ident_info2,\n\t&lg4ff_dfgt_ident_info,\n\t&lg4ff_g27_ident_info,\n\t&lg4ff_g25_ident_info,\n\t&lg4ff_dfp_ident_info\n};\n\n \n \nstatic const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_dfex = {\n\t2,\n\t{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0xf8, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00}\t \n};\n\nstatic const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_dfp = {\n\t2,\n\t{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0xf8, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00}\t \n};\n\nstatic const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_g25 = {\n\t2,\n\t{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0xf8, 0x09, 0x02, 0x01, 0x00, 0x00, 0x00}\t \n};\n\nstatic const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_dfgt = {\n\t2,\n\t{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0xf8, 0x09, 0x03, 0x01, 0x00, 0x00, 0x00}\t \n};\n\nstatic const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_g27 = {\n\t2,\n\t{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0xf8, 0x09, 0x04, 0x01, 0x00, 0x00, 0x00}\t \n};\n\nstatic const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_g29 = {\n\t2,\n\t{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\t \n\t 0xf8, 0x09, 0x05, 0x01, 0x01, 0x00, 0x00}\t \n};\n\n \nstatic const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext01_dfp = {\n\t1,\n\t{0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}\n};\n\n \nstatic const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext16_g25 = {\n\t1,\n\t{0xf8, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00}\n};\n\n \nstatic s32 lg4ff_adjust_dfp_x_axis(s32 value, u16 range)\n{\n\tu16 max_range;\n\ts32 new_value;\n\n\tif (range == 900)\n\t\treturn value;\n\telse if (range == 200)\n\t\treturn value;\n\telse if (range < 200)\n\t\tmax_range = 200;\n\telse\n\t\tmax_range = 900;\n\n\tnew_value = 8192 + mult_frac(value - 8192, max_range, range);\n\tif (new_value < 0)\n\t\treturn 0;\n\telse if (new_value > 16383)\n\t\treturn 16383;\n\telse\n\t\treturn new_value;\n}\n\nint lg4ff_adjust_input_event(struct hid_device *hid, struct hid_field *field,\n\t\t\t     struct hid_usage *usage, s32 value, struct lg_drv_data *drv_data)\n{\n\tstruct lg4ff_device_entry *entry = drv_data->device_props;\n\ts32 new_value = 0;\n\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found\");\n\t\treturn 0;\n\t}\n\n\tswitch (entry->wdata.product_id) {\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tswitch (usage->code) {\n\t\tcase ABS_X:\n\t\t\tnew_value = lg4ff_adjust_dfp_x_axis(value, entry->wdata.range);\n\t\t\tinput_event(field->hidinput->input, usage->type, usage->code, new_value);\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint lg4ff_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\tu8 *rd, int size, struct lg_drv_data *drv_data)\n{\n\tint offset;\n\tstruct lg4ff_device_entry *entry = drv_data->device_props;\n\n\tif (!entry)\n\t\treturn 0;\n\n\t \n\tif (entry->wdata.combine) {\n\t\tswitch (entry->wdata.product_id) {\n\t\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\t\trd[5] = rd[3];\n\t\t\trd[6] = 0x7F;\n\t\t\treturn 1;\n\t\tcase USB_DEVICE_ID_LOGITECH_WINGMAN_FG:\n\t\tcase USB_DEVICE_ID_LOGITECH_WINGMAN_FFG:\n\t\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\t\trd[4] = rd[3];\n\t\t\trd[5] = 0x7F;\n\t\t\treturn 1;\n\t\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\t\trd[5] = rd[4];\n\t\t\trd[6] = 0x7F;\n\t\t\treturn 1;\n\t\tcase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_G27_WHEEL:\n\t\t\toffset = 5;\n\t\t\tbreak;\n\t\tcase USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_G29_WHEEL:\n\t\t\toffset = 6;\n\t\t\tbreak;\n\t\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\t\toffset = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\trd[offset] = (0xFF + rd[offset] - rd[offset+1]) >> 1;\n\t\trd[offset+1] = 0x7F;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void lg4ff_init_wheel_data(struct lg4ff_wheel_data * const wdata, const struct lg4ff_wheel *wheel,\n\t\t\t\t  const struct lg4ff_multimode_wheel *mmode_wheel,\n\t\t\t\t  const u16 real_product_id)\n{\n\tu32 alternate_modes = 0;\n\tconst char *real_tag = NULL;\n\tconst char *real_name = NULL;\n\n\tif (mmode_wheel) {\n\t\talternate_modes = mmode_wheel->alternate_modes;\n\t\treal_tag = mmode_wheel->real_tag;\n\t\treal_name = mmode_wheel->real_name;\n\t}\n\n\t{\n\t\tstruct lg4ff_wheel_data t_wdata =  { .product_id = wheel->product_id,\n\t\t\t\t\t\t     .real_product_id = real_product_id,\n\t\t\t\t\t\t     .combine = 0,\n\t\t\t\t\t\t     .min_range = wheel->min_range,\n\t\t\t\t\t\t     .max_range = wheel->max_range,\n\t\t\t\t\t\t     .set_range = wheel->set_range,\n\t\t\t\t\t\t     .alternate_modes = alternate_modes,\n\t\t\t\t\t\t     .real_tag = real_tag,\n\t\t\t\t\t\t     .real_name = real_name };\n\n\t\tmemcpy(wdata, &t_wdata, sizeof(t_wdata));\n\t}\n}\n\nstatic int lg4ff_play(struct input_dev *dev, void *data, struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tunsigned long flags;\n\ts32 *value;\n\tint x;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tvalue = entry->report->field[0]->value;\n\n#define CLAMP(x) do { if (x < 0) x = 0; else if (x > 0xff) x = 0xff; } while (0)\n\n\tswitch (effect->type) {\n\tcase FF_CONSTANT:\n\t\tx = effect->u.ramp.start_level + 0x80;\t \n\t\tCLAMP(x);\n\n\t\tspin_lock_irqsave(&entry->report_lock, flags);\n\t\tif (x == 0x80) {\n\t\t\t \n\t\t\tvalue[0] = 0x13;\n\t\t\tvalue[1] = 0x00;\n\t\t\tvalue[2] = 0x00;\n\t\t\tvalue[3] = 0x00;\n\t\t\tvalue[4] = 0x00;\n\t\t\tvalue[5] = 0x00;\n\t\t\tvalue[6] = 0x00;\n\n\t\t\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\t\t\tspin_unlock_irqrestore(&entry->report_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tvalue[0] = 0x11;\t \n\t\tvalue[1] = 0x08;\n\t\tvalue[2] = x;\n\t\tvalue[3] = 0x80;\n\t\tvalue[4] = 0x00;\n\t\tvalue[5] = 0x00;\n\t\tvalue[6] = 0x00;\n\n\t\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\t\tspin_unlock_irqrestore(&entry->report_lock, flags);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic void lg4ff_set_autocenter_default(struct input_dev *dev, u16 magnitude)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\ts32 *value;\n\tu32 expand_a, expand_b;\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tunsigned long flags;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn;\n\t}\n\tvalue = entry->report->field[0]->value;\n\n\t \n\tspin_lock_irqsave(&entry->report_lock, flags);\n\tif (magnitude == 0) {\n\t\tvalue[0] = 0xf5;\n\t\tvalue[1] = 0x00;\n\t\tvalue[2] = 0x00;\n\t\tvalue[3] = 0x00;\n\t\tvalue[4] = 0x00;\n\t\tvalue[5] = 0x00;\n\t\tvalue[6] = 0x00;\n\n\t\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\t\tspin_unlock_irqrestore(&entry->report_lock, flags);\n\t\treturn;\n\t}\n\n\tif (magnitude <= 0xaaaa) {\n\t\texpand_a = 0x0c * magnitude;\n\t\texpand_b = 0x80 * magnitude;\n\t} else {\n\t\texpand_a = (0x0c * 0xaaaa) + 0x06 * (magnitude - 0xaaaa);\n\t\texpand_b = (0x80 * 0xaaaa) + 0xff * (magnitude - 0xaaaa);\n\t}\n\n\t \n\tswitch (entry->wdata.product_id) {\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tbreak;\n\tdefault:\n\t\texpand_a = expand_a >> 1;\n\t\tbreak;\n\t}\n\n\tvalue[0] = 0xfe;\n\tvalue[1] = 0x0d;\n\tvalue[2] = expand_a / 0xaaaa;\n\tvalue[3] = expand_a / 0xaaaa;\n\tvalue[4] = expand_b / 0xaaaa;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\n\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\n\t \n\tvalue[0] = 0x14;\n\tvalue[1] = 0x00;\n\tvalue[2] = 0x00;\n\tvalue[3] = 0x00;\n\tvalue[4] = 0x00;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\n\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&entry->report_lock, flags);\n}\n\n \nstatic void lg4ff_set_autocenter_ffex(struct input_dev *dev, u16 magnitude)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tunsigned long flags;\n\ts32 *value;\n\tmagnitude = magnitude * 90 / 65535;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn;\n\t}\n\tvalue = entry->report->field[0]->value;\n\n\tspin_lock_irqsave(&entry->report_lock, flags);\n\tvalue[0] = 0xfe;\n\tvalue[1] = 0x03;\n\tvalue[2] = magnitude >> 14;\n\tvalue[3] = magnitude >> 14;\n\tvalue[4] = magnitude;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\n\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&entry->report_lock, flags);\n}\n\n \nstatic void lg4ff_set_range_g25(struct hid_device *hid, u16 range)\n{\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tunsigned long flags;\n\ts32 *value;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn;\n\t}\n\tvalue = entry->report->field[0]->value;\n\tdbg_hid(\"G25/G27/DFGT: setting range to %u\\n\", range);\n\n\tspin_lock_irqsave(&entry->report_lock, flags);\n\tvalue[0] = 0xf8;\n\tvalue[1] = 0x81;\n\tvalue[2] = range & 0x00ff;\n\tvalue[3] = (range & 0xff00) >> 8;\n\tvalue[4] = 0x00;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\n\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&entry->report_lock, flags);\n}\n\n \nstatic void lg4ff_set_range_dfp(struct hid_device *hid, u16 range)\n{\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tunsigned long flags;\n\tint start_left, start_right, full_range;\n\ts32 *value;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn;\n\t}\n\tvalue = entry->report->field[0]->value;\n\tdbg_hid(\"Driving Force Pro: setting range to %u\\n\", range);\n\n\t \n\tspin_lock_irqsave(&entry->report_lock, flags);\n\tvalue[0] = 0xf8;\n\tvalue[1] = 0x00;\t \n\tvalue[2] = 0x00;\n\tvalue[3] = 0x00;\n\tvalue[4] = 0x00;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\n\tif (range > 200) {\n\t\tvalue[1] = 0x03;\n\t\tfull_range = 900;\n\t} else {\n\t\tvalue[1] = 0x02;\n\t\tfull_range = 200;\n\t}\n\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\n\t \n\tvalue[0] = 0x81;\n\tvalue[1] = 0x0b;\n\tvalue[2] = 0x00;\n\tvalue[3] = 0x00;\n\tvalue[4] = 0x00;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\n\tif (range == 200 || range == 900) {\t \n\t\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\t\tspin_unlock_irqrestore(&entry->report_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tstart_left = (((full_range - range + 1) * 2047) / full_range);\n\tstart_right = 0xfff - start_left;\n\n\tvalue[2] = start_left >> 4;\n\tvalue[3] = start_right >> 4;\n\tvalue[4] = 0xff;\n\tvalue[5] = (start_right & 0xe) << 4 | (start_left & 0xe);\n\tvalue[6] = 0xff;\n\n\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&entry->report_lock, flags);\n}\n\nstatic const struct lg4ff_compat_mode_switch *lg4ff_get_mode_switch_command(const u16 real_product_id, const u16 target_product_id)\n{\n\tswitch (real_product_id) {\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tswitch (target_product_id) {\n\t\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext01_dfp;\n\t\t \n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\n\t\tswitch (target_product_id) {\n\t\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext01_dfp;\n\t\tcase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext16_g25;\n\t\t \n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_LOGITECH_G27_WHEEL:\n\t\tswitch (target_product_id) {\n\t\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_dfex;\n\t\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_dfp;\n\t\tcase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_g25;\n\t\tcase USB_DEVICE_ID_LOGITECH_G27_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_g27;\n\t\t \n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_LOGITECH_G29_WHEEL:\n\t\tswitch (target_product_id) {\n\t\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_dfp;\n\t\tcase USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_dfgt;\n\t\tcase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_g25;\n\t\tcase USB_DEVICE_ID_LOGITECH_G27_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_g27;\n\t\tcase USB_DEVICE_ID_LOGITECH_G29_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_g29;\n\t\t \n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:\n\t\tswitch (target_product_id) {\n\t\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_dfex;\n\t\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_dfp;\n\t\tcase USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:\n\t\t\treturn &lg4ff_mode_switch_ext09_dfgt;\n\t\t \n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int lg4ff_switch_compatibility_mode(struct hid_device *hid, const struct lg4ff_compat_mode_switch *s)\n{\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tunsigned long flags;\n\ts32 *value;\n\tu8 i;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tvalue = entry->report->field[0]->value;\n\n\tspin_lock_irqsave(&entry->report_lock, flags);\n\tfor (i = 0; i < s->cmd_count; i++) {\n\t\tu8 j;\n\n\t\tfor (j = 0; j < 7; j++)\n\t\t\tvalue[j] = s->cmd[j + (7*i)];\n\n\t\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\t}\n\tspin_unlock_irqrestore(&entry->report_lock, flags);\n\thid_hw_wait(hid);\n\treturn 0;\n}\n\nstatic ssize_t lg4ff_alternate_modes_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tssize_t count = 0;\n\tint i;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!entry->wdata.real_name) {\n\t\thid_err(hid, \"NULL pointer to string\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < LG4FF_MODE_MAX_IDX; i++) {\n\t\tif (entry->wdata.alternate_modes & BIT(i)) {\n\t\t\t \n\t\t\tcount += scnprintf(buf + count, PAGE_SIZE - count, \"%s: %s\",\n\t\t\t\t\t   lg4ff_alternate_modes[i].tag,\n\t\t\t\t\t   !lg4ff_alternate_modes[i].product_id ? entry->wdata.real_name : lg4ff_alternate_modes[i].name);\n\t\t\tif (count >= PAGE_SIZE - 1)\n\t\t\t\treturn count;\n\n\t\t\t \n\t\t\tif (lg4ff_alternate_modes[i].product_id == entry->wdata.product_id ||\n\t\t\t    (lg4ff_alternate_modes[i].product_id == 0 && entry->wdata.product_id == entry->wdata.real_product_id))\n\t\t\t\tcount += scnprintf(buf + count, PAGE_SIZE - count, \" *\\n\");\n\t\t\telse\n\t\t\t\tcount += scnprintf(buf + count, PAGE_SIZE - count, \"\\n\");\n\n\t\t\tif (count >= PAGE_SIZE - 1)\n\t\t\t\treturn count;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t lg4ff_alternate_modes_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tconst struct lg4ff_compat_mode_switch *s;\n\tu16 target_product_id = 0;\n\tint i, ret;\n\tchar *lbuf;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlbuf = kasprintf(GFP_KERNEL, \"%s\", buf);\n\tif (!lbuf)\n\t\treturn -ENOMEM;\n\n\ti = strlen(lbuf);\n\n\tif (i == 0) {\n\t\tkfree(lbuf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lbuf[i-1] == '\\n') {\n\t\tif (i == 1) {\n\t\t\tkfree(lbuf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlbuf[i-1] = '\\0';\n\t}\n\n\tfor (i = 0; i < LG4FF_MODE_MAX_IDX; i++) {\n\t\tconst u16 mode_product_id = lg4ff_alternate_modes[i].product_id;\n\t\tconst char *tag = lg4ff_alternate_modes[i].tag;\n\n\t\tif (entry->wdata.alternate_modes & BIT(i)) {\n\t\t\tif (!strcmp(tag, lbuf)) {\n\t\t\t\tif (!mode_product_id)\n\t\t\t\t\ttarget_product_id = entry->wdata.real_product_id;\n\t\t\t\telse\n\t\t\t\t\ttarget_product_id = mode_product_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i == LG4FF_MODE_MAX_IDX) {\n\t\thid_info(hid, \"Requested mode \\\"%s\\\" is not supported by the device\\n\", lbuf);\n\t\tkfree(lbuf);\n\t\treturn -EINVAL;\n\t}\n\tkfree(lbuf);  \n\n\tif (target_product_id == entry->wdata.product_id)  \n\t\treturn count;\n\n\t \n\tif (target_product_id == USB_DEVICE_ID_LOGITECH_WHEEL && !lg4ff_no_autoswitch) {\n\t\thid_info(hid, \"\\\"%s\\\" cannot be switched to \\\"DF-EX\\\" mode. Load the \\\"hid_logitech\\\" module with \\\"lg4ff_no_autoswitch=1\\\" parameter set and try again\\n\",\n\t\t\t entry->wdata.real_name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((entry->wdata.real_product_id == USB_DEVICE_ID_LOGITECH_DFP_WHEEL || entry->wdata.real_product_id == USB_DEVICE_ID_LOGITECH_G25_WHEEL) &&\n\t    entry->wdata.product_id > target_product_id) {\n\t\thid_info(hid, \"\\\"%s\\\" cannot be switched back into \\\"%s\\\" mode\\n\", entry->wdata.real_name, lg4ff_alternate_modes[i].name);\n\t\treturn -EINVAL;\n\t}\n\n\ts = lg4ff_get_mode_switch_command(entry->wdata.real_product_id, target_product_id);\n\tif (!s) {\n\t\thid_err(hid, \"Invalid target product ID %X\\n\", target_product_id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = lg4ff_switch_compatibility_mode(hid, s);\n\treturn (ret == 0 ? count : ret);\n}\nstatic DEVICE_ATTR(alternate_modes, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_alternate_modes_show, lg4ff_alternate_modes_store);\n\nstatic ssize_t lg4ff_combine_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tsize_t count;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tcount = scnprintf(buf, PAGE_SIZE, \"%u\\n\", entry->wdata.combine);\n\treturn count;\n}\n\nstatic ssize_t lg4ff_combine_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tu16 combine = simple_strtoul(buf, NULL, 10);\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (combine > 1)\n\t\tcombine = 1;\n\n\tentry->wdata.combine = combine;\n\treturn count;\n}\nstatic DEVICE_ATTR(combine_pedals, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_combine_show, lg4ff_combine_store);\n\n \nstatic ssize_t lg4ff_range_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tsize_t count;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tcount = scnprintf(buf, PAGE_SIZE, \"%u\\n\", entry->wdata.range);\n\treturn count;\n}\n\n \nstatic ssize_t lg4ff_range_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tu16 range = simple_strtoul(buf, NULL, 10);\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (range == 0)\n\t\trange = entry->wdata.max_range;\n\n\t \n\tif (entry->wdata.set_range && range >= entry->wdata.min_range && range <= entry->wdata.max_range) {\n\t\tentry->wdata.set_range(hid, range);\n\t\tentry->wdata.range = range;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(range, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_range_show, lg4ff_range_store);\n\nstatic ssize_t lg4ff_real_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tsize_t count;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!entry->wdata.real_tag || !entry->wdata.real_name) {\n\t\thid_err(hid, \"NULL pointer to string\\n\");\n\t\treturn 0;\n\t}\n\n\tcount = scnprintf(buf, PAGE_SIZE, \"%s: %s\\n\", entry->wdata.real_tag, entry->wdata.real_name);\n\treturn count;\n}\n\nstatic ssize_t lg4ff_real_id_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\t \n\treturn -EPERM;\n}\nstatic DEVICE_ATTR(real_id, S_IRUGO, lg4ff_real_id_show, lg4ff_real_id_store);\n\n#ifdef CONFIG_LEDS_CLASS\nstatic void lg4ff_set_leds(struct hid_device *hid, u8 leds)\n{\n\tstruct lg_drv_data *drv_data;\n\tstruct lg4ff_device_entry *entry;\n\tunsigned long flags;\n\ts32 *value;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Private driver data not found!\\n\");\n\t\treturn;\n\t}\n\n\tentry = drv_data->device_props;\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found!\\n\");\n\t\treturn;\n\t}\n\tvalue = entry->report->field[0]->value;\n\n\tspin_lock_irqsave(&entry->report_lock, flags);\n\tvalue[0] = 0xf8;\n\tvalue[1] = 0x12;\n\tvalue[2] = leds;\n\tvalue[3] = 0x00;\n\tvalue[4] = 0x00;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\thid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&entry->report_lock, flags);\n}\n\nstatic void lg4ff_led_set_brightness(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hid);\n\tstruct lg4ff_device_entry *entry;\n\tint i, state = 0;\n\n\tif (!drv_data) {\n\t\thid_err(hid, \"Device data not found.\");\n\t\treturn;\n\t}\n\n\tentry = drv_data->device_props;\n\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found.\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 5; i++) {\n\t\tif (led_cdev != entry->wdata.led[i])\n\t\t\tcontinue;\n\t\tstate = (entry->wdata.led_state >> i) & 1;\n\t\tif (value == LED_OFF && state) {\n\t\t\tentry->wdata.led_state &= ~(1 << i);\n\t\t\tlg4ff_set_leds(hid, entry->wdata.led_state);\n\t\t} else if (value != LED_OFF && !state) {\n\t\t\tentry->wdata.led_state |= 1 << i;\n\t\t\tlg4ff_set_leds(hid, entry->wdata.led_state);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic enum led_brightness lg4ff_led_get_brightness(struct led_classdev *led_cdev)\n{\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hid);\n\tstruct lg4ff_device_entry *entry;\n\tint i, value = 0;\n\n\tif (!drv_data) {\n\t\thid_err(hid, \"Device data not found.\");\n\t\treturn LED_OFF;\n\t}\n\n\tentry = drv_data->device_props;\n\n\tif (!entry) {\n\t\thid_err(hid, \"Device properties not found.\");\n\t\treturn LED_OFF;\n\t}\n\n\tfor (i = 0; i < 5; i++)\n\t\tif (led_cdev == entry->wdata.led[i]) {\n\t\t\tvalue = (entry->wdata.led_state >> i) & 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn value ? LED_FULL : LED_OFF;\n}\n#endif\n\nstatic u16 lg4ff_identify_multimode_wheel(struct hid_device *hid, const u16 reported_product_id, const u16 bcdDevice)\n{\n\tu32 current_mode;\n\tint i;\n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(lg4ff_alternate_modes); i++) {\n\t\tdbg_hid(\"Testing whether PID is %X\\n\", lg4ff_alternate_modes[i].product_id);\n\t\tif (reported_product_id == lg4ff_alternate_modes[i].product_id)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(lg4ff_alternate_modes))\n\t\treturn 0;\n\n\tcurrent_mode = BIT(i);\n\n\tfor (i = 0; i < ARRAY_SIZE(lg4ff_main_checklist); i++) {\n\t\tconst u16 mask = lg4ff_main_checklist[i]->mask;\n\t\tconst u16 result = lg4ff_main_checklist[i]->result;\n\t\tconst u16 real_product_id = lg4ff_main_checklist[i]->real_product_id;\n\n\t\tif ((current_mode & lg4ff_main_checklist[i]->modes) && \\\n\t\t\t\t(bcdDevice & mask) == result) {\n\t\t\tdbg_hid(\"Found wheel with real PID %X whose reported PID is %X\\n\", real_product_id, reported_product_id);\n\t\t\treturn real_product_id;\n\t\t}\n\t}\n\n\t \n\tdbg_hid(\"Wheel with bcdDevice %X was not recognized as multimode wheel, leaving in its current mode\\n\", bcdDevice);\n\treturn 0;\n}\n\nstatic int lg4ff_handle_multimode_wheel(struct hid_device *hid, u16 *real_product_id, const u16 bcdDevice)\n{\n\tconst u16 reported_product_id = hid->product;\n\tint ret;\n\n\t*real_product_id = lg4ff_identify_multimode_wheel(hid, reported_product_id, bcdDevice);\n\t \n\tif (!*real_product_id) {\n\t\t*real_product_id = reported_product_id;\n\t\tdbg_hid(\"Wheel is not a multimode wheel\\n\");\n\t\treturn LG4FF_MMODE_NOT_MULTIMODE;\n\t}\n\n\t \n\tif (reported_product_id == USB_DEVICE_ID_LOGITECH_WHEEL &&\n\t    reported_product_id != *real_product_id &&\n\t    !lg4ff_no_autoswitch) {\n\t\tconst struct lg4ff_compat_mode_switch *s = lg4ff_get_mode_switch_command(*real_product_id, *real_product_id);\n\n\t\tif (!s) {\n\t\t\thid_err(hid, \"Invalid product id %X\\n\", *real_product_id);\n\t\t\treturn LG4FF_MMODE_NOT_MULTIMODE;\n\t\t}\n\n\t\tret = lg4ff_switch_compatibility_mode(hid, s);\n\t\tif (ret) {\n\t\t\t \n\t\t\thid_err(hid, \"Unable to switch wheel mode, errno %d\\n\", ret);\n\t\t\treturn LG4FF_MMODE_IS_MULTIMODE;\n\t\t}\n\t\treturn LG4FF_MMODE_SWITCHED;\n\t}\n\n\treturn LG4FF_MMODE_IS_MULTIMODE;\n}\n\n\nint lg4ff_init(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput;\n\tstruct input_dev *dev;\n\tstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\n\tconst struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid)->descriptor);\n\tconst u16 bcdDevice = le16_to_cpu(udesc->bcdDevice);\n\tconst struct lg4ff_multimode_wheel *mmode_wheel = NULL;\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\tint error, i, j;\n\tint mmode_ret, mmode_idx = -1;\n\tu16 real_product_id;\n\n\tif (list_empty(&hid->inputs)) {\n\t\thid_err(hid, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tdev = hidinput->input;\n\n\t \n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -1;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Cannot add device, private driver data not allocated\\n\");\n\t\treturn -1;\n\t}\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&entry->report_lock);\n\tentry->report = report;\n\tdrv_data->device_props = entry;\n\n\t \n\tmmode_ret = lg4ff_handle_multimode_wheel(hid, &real_product_id, bcdDevice);\n\n\t \n\tif (mmode_ret == LG4FF_MMODE_SWITCHED)\n\t\treturn 0;\n\telse if (mmode_ret < 0) {\n\t\thid_err(hid, \"Unable to switch device mode during initialization, errno %d\\n\", mmode_ret);\n\t\terror = mmode_ret;\n\t\tgoto err_init;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lg4ff_devices); i++) {\n\t\tif (hid->product == lg4ff_devices[i].product_id) {\n\t\t\tdbg_hid(\"Found compatible device, product ID %04X\\n\", lg4ff_devices[i].product_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(lg4ff_devices)) {\n\t\thid_err(hid, \"This device is flagged to be handled by the lg4ff module but this module does not know how to handle it. \"\n\t\t\t     \"Please report this as a bug to LKML, Simon Wood <simon@mungewell.org> or \"\n\t\t\t     \"Michal Maly <madcatxster@devoid-pointer.net>\\n\");\n\t\terror = -1;\n\t\tgoto err_init;\n\t}\n\n\tif (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {\n\t\tfor (mmode_idx = 0; mmode_idx < ARRAY_SIZE(lg4ff_multimode_wheels); mmode_idx++) {\n\t\t\tif (real_product_id == lg4ff_multimode_wheels[mmode_idx].product_id)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (mmode_idx == ARRAY_SIZE(lg4ff_multimode_wheels)) {\n\t\t\thid_err(hid, \"Device product ID %X is not listed as a multimode wheel\", real_product_id);\n\t\t\terror = -1;\n\t\t\tgoto err_init;\n\t\t}\n\t}\n\n\t \n\tfor (j = 0; lg4ff_devices[i].ff_effects[j] >= 0; j++)\n\t\tset_bit(lg4ff_devices[i].ff_effects[j], dev->ffbit);\n\n\terror = input_ff_create_memless(dev, NULL, lg4ff_play);\n\n\tif (error)\n\t\tgoto err_init;\n\n\t \n\tif (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {\n\t\tBUG_ON(mmode_idx == -1);\n\t\tmmode_wheel = &lg4ff_multimode_wheels[mmode_idx];\n\t}\n\tlg4ff_init_wheel_data(&entry->wdata, &lg4ff_devices[i], mmode_wheel, real_product_id);\n\n\t \n\tif (test_bit(FF_AUTOCENTER, dev->ffbit)) {\n\t\t \n\t\tif ((bcdDevice >> 8) == LG4FF_FFEX_REV_MAJ &&\n\t\t    (bcdDevice & 0xff) == LG4FF_FFEX_REV_MIN)\n\t\t\tdev->ff->set_autocenter = lg4ff_set_autocenter_ffex;\n\t\telse\n\t\t\tdev->ff->set_autocenter = lg4ff_set_autocenter_default;\n\n\t\tdev->ff->set_autocenter(dev, 0);\n\t}\n\n\t \n\terror = device_create_file(&hid->dev, &dev_attr_combine_pedals);\n\tif (error)\n\t\thid_warn(hid, \"Unable to create sysfs interface for \\\"combine\\\", errno %d\\n\", error);\n\terror = device_create_file(&hid->dev, &dev_attr_range);\n\tif (error)\n\t\thid_warn(hid, \"Unable to create sysfs interface for \\\"range\\\", errno %d\\n\", error);\n\tif (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {\n\t\terror = device_create_file(&hid->dev, &dev_attr_real_id);\n\t\tif (error)\n\t\t\thid_warn(hid, \"Unable to create sysfs interface for \\\"real_id\\\", errno %d\\n\", error);\n\t\terror = device_create_file(&hid->dev, &dev_attr_alternate_modes);\n\t\tif (error)\n\t\t\thid_warn(hid, \"Unable to create sysfs interface for \\\"alternate_modes\\\", errno %d\\n\", error);\n\t}\n\tdbg_hid(\"sysfs interface created\\n\");\n\n\t \n\tentry->wdata.range = entry->wdata.max_range;\n\tif (entry->wdata.set_range)\n\t\tentry->wdata.set_range(hid, entry->wdata.range);\n\n#ifdef CONFIG_LEDS_CLASS\n\t \n\tentry->wdata.led_state = 0;\n\tfor (j = 0; j < 5; j++)\n\t\tentry->wdata.led[j] = NULL;\n\n\tif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G27_WHEEL ||\n\t\t\tlg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G29_WHEEL) {\n\t\tstruct led_classdev *led;\n\t\tsize_t name_sz;\n\t\tchar *name;\n\n\t\tlg4ff_set_leds(hid, 0);\n\n\t\tname_sz = strlen(dev_name(&hid->dev)) + 8;\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\t\t\tif (!led) {\n\t\t\t\thid_err(hid, \"can't allocate memory for LED %d\\n\", j);\n\t\t\t\tgoto err_leds;\n\t\t\t}\n\n\t\t\tname = (void *)(&led[1]);\n\t\t\tsnprintf(name, name_sz, \"%s::RPM%d\", dev_name(&hid->dev), j+1);\n\t\t\tled->name = name;\n\t\t\tled->brightness = 0;\n\t\t\tled->max_brightness = 1;\n\t\t\tled->brightness_get = lg4ff_led_get_brightness;\n\t\t\tled->brightness_set = lg4ff_led_set_brightness;\n\n\t\t\tentry->wdata.led[j] = led;\n\t\t\terror = led_classdev_register(&hid->dev, led);\n\n\t\t\tif (error) {\n\t\t\t\thid_err(hid, \"failed to register LED %d. Aborting.\\n\", j);\nerr_leds:\n\t\t\t\t \n\t\t\t\tfor (j = 0; j < 5; j++) {\n\t\t\t\t\tled = entry->wdata.led[j];\n\t\t\t\t\tentry->wdata.led[j] = NULL;\n\t\t\t\t\tif (!led)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tled_classdev_unregister(led);\n\t\t\t\t\tkfree(led);\n\t\t\t\t}\n\t\t\t\tgoto out;\t \n\t\t\t}\n\t\t}\n\t}\nout:\n#endif\n\thid_info(hid, \"Force feedback support for Logitech Gaming Wheels\\n\");\n\treturn 0;\n\nerr_init:\n\tdrv_data->device_props = NULL;\n\tkfree(entry);\n\treturn error;\n}\n\nint lg4ff_deinit(struct hid_device *hid)\n{\n\tstruct lg4ff_device_entry *entry;\n\tstruct lg_drv_data *drv_data;\n\n\tdrv_data = hid_get_drvdata(hid);\n\tif (!drv_data) {\n\t\thid_err(hid, \"Error while deinitializing device, no private driver data.\\n\");\n\t\treturn -1;\n\t}\n\tentry = drv_data->device_props;\n\tif (!entry)\n\t\tgoto out;  \n\n\t \n\tif (entry->wdata.alternate_modes) {\n\t\tdevice_remove_file(&hid->dev, &dev_attr_real_id);\n\t\tdevice_remove_file(&hid->dev, &dev_attr_alternate_modes);\n\t}\n\n\tdevice_remove_file(&hid->dev, &dev_attr_combine_pedals);\n\tdevice_remove_file(&hid->dev, &dev_attr_range);\n#ifdef CONFIG_LEDS_CLASS\n\t{\n\t\tint j;\n\t\tstruct led_classdev *led;\n\n\t\t \n\t\tfor (j = 0; j < 5; j++) {\n\n\t\t\tled = entry->wdata.led[j];\n\t\t\tentry->wdata.led[j] = NULL;\n\t\t\tif (!led)\n\t\t\t\tcontinue;\n\t\t\tled_classdev_unregister(led);\n\t\t\tkfree(led);\n\t\t}\n\t}\n#endif\n\tdrv_data->device_props = NULL;\n\n\tkfree(entry);\nout:\n\tdbg_hid(\"Device successfully unregistered\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}