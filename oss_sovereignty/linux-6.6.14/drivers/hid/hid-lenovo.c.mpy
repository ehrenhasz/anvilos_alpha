{
  "module_name": "hid-lenovo.c",
  "hash_id": "29236608cab683d87f4802997ae2568667dd51c2ded45c235c85700579b7efe8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-lenovo.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/sysfs.h>\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/leds.h>\n#include <linux/workqueue.h>\n\n#include \"hid-ids.h\"\n\n \n#define LENOVO_KEY_MICMUTE KEY_F20\n\nstruct lenovo_drvdata {\n\tu8 led_report[3];  \n\tint led_state;\n\tstruct mutex led_report_mutex;\n\tstruct led_classdev led_mute;\n\tstruct led_classdev led_micmute;\n\tstruct work_struct fn_lock_sync_work;\n\tstruct hid_device *hdev;\n\tint press_to_select;\n\tint dragging;\n\tint release_to_select;\n\tint select_right;\n\tint sensitivity;\n\tint press_speed;\n\t \n\tu8 middlebutton_state;\n\tbool fn_lock;\n};\n\n#define map_key_clear(c) hid_map_usage_clear(hi, usage, bit, max, EV_KEY, (c))\n\n#define TP10UBKBD_LED_OUTPUT_REPORT\t9\n\n#define TP10UBKBD_FN_LOCK_LED\t\t0x54\n#define TP10UBKBD_MUTE_LED\t\t0x64\n#define TP10UBKBD_MICMUTE_LED\t\t0x74\n\n#define TP10UBKBD_LED_OFF\t\t1\n#define TP10UBKBD_LED_ON\t\t2\n\nstatic int lenovo_led_set_tp10ubkbd(struct hid_device *hdev, u8 led_code,\n\t\t\t\t    enum led_brightness value)\n{\n\tstruct lenovo_drvdata *data = hid_get_drvdata(hdev);\n\tint ret;\n\n\tmutex_lock(&data->led_report_mutex);\n\n\tdata->led_report[0] = TP10UBKBD_LED_OUTPUT_REPORT;\n\tdata->led_report[1] = led_code;\n\tdata->led_report[2] = value ? TP10UBKBD_LED_ON : TP10UBKBD_LED_OFF;\n\tret = hid_hw_raw_request(hdev, data->led_report[0], data->led_report, 3,\n\t\t\t\t HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);\n\tif (ret != 3) {\n\t\tif (ret != -ENODEV)\n\t\t\thid_err(hdev, \"Set LED output report error: %d\\n\", ret);\n\n\t\tret = ret < 0 ? ret : -EIO;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tmutex_unlock(&data->led_report_mutex);\n\n\treturn ret;\n}\n\nstatic void lenovo_tp10ubkbd_sync_fn_lock(struct work_struct *work)\n{\n\tstruct lenovo_drvdata *data =\n\t\tcontainer_of(work, struct lenovo_drvdata, fn_lock_sync_work);\n\n\tlenovo_led_set_tp10ubkbd(data->hdev, TP10UBKBD_FN_LOCK_LED,\n\t\t\t\t data->fn_lock);\n}\n\nstatic const __u8 lenovo_pro_dock_need_fixup_collection[] = {\n\t0x05, 0x88,\t\t \n\t0x09, 0x01,\t\t \n\t0xa1, 0x01,\t\t \n\t0x85, 0x04,\t\t \n\t0x19, 0x00,\t\t \n\t0x2a, 0xff, 0xff,\t \n};\n\n \nstatic const __u8 lenovo_tpIIbtkbd_need_fixup_collection[] = {\n\t0x06, 0x00, 0xFF,\t \n\t0x09, 0x01,\t\t \n\t0xA1, 0x01,\t\t \n\t0x85, 0x05,\t\t \n\t0x1A, 0xF1, 0x00,\t \n\t0x2A, 0xFC, 0x00,\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x75, 0x01,\t\t \n\t0x95, 0x0D,\t\t \n\t0x81, 0x02,\t\t \n\t0x95, 0x03,\t\t \n\t0x81, 0x01,\t\t \n};\n\nstatic __u8 *lenovo_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_TPPRODOCK:\n\t\t \n\t\tif (*rsize >= 153 &&\n\t\t    memcmp(&rdesc[140], lenovo_pro_dock_need_fixup_collection,\n\t\t\t  sizeof(lenovo_pro_dock_need_fixup_collection)) == 0) {\n\t\t\trdesc[151] = 0x01;\n\t\t\trdesc[152] = 0x00;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_LENOVO_TPIIBTKBD:\n\t\tif (*rsize >= 263 &&\n\t\t    memcmp(&rdesc[234], lenovo_tpIIbtkbd_need_fixup_collection,\n\t\t\t  sizeof(lenovo_tpIIbtkbd_need_fixup_collection)) == 0) {\n\t\t\trdesc[244] = 0x00;  \n\t\t\trdesc[247] = 0xff;  \n\t\t\trdesc[252] = 0xff;  \n\t\t\trdesc[254] = 0x08;  \n\t\t\trdesc[256] = 0x01;  \n\t\t\trdesc[258] = 0x00;  \n\t\t\trdesc[260] = 0x01;  \n\t\t}\n\t\tbreak;\n\t}\n\treturn rdesc;\n}\n\nstatic int lenovo_input_mapping_tpkbd(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tif (usage->hid == (HID_UP_BUTTON | 0x0010)) {\n\t\t \n\t\thid_set_drvdata(hdev, (void *)1);\n\t\tmap_key_clear(LENOVO_KEY_MICMUTE);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int lenovo_input_mapping_cptkbd(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\t \n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_MSVENDOR ||\n\t    (usage->hid & HID_USAGE_PAGE) == HID_UP_LNVENDOR) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x00f1:  \n\t\t\tmap_key_clear(LENOVO_KEY_MICMUTE);\n\t\t\treturn 1;\n\t\tcase 0x00f2:  \n\t\t\tmap_key_clear(KEY_BRIGHTNESSDOWN);\n\t\t\treturn 1;\n\t\tcase 0x00f3:  \n\t\t\tmap_key_clear(KEY_BRIGHTNESSUP);\n\t\t\treturn 1;\n\t\tcase 0x00f4:  \n\t\t\tmap_key_clear(KEY_SWITCHVIDEOMODE);\n\t\t\treturn 1;\n\t\tcase 0x00f5:  \n\t\t\tmap_key_clear(KEY_WLAN);\n\t\t\treturn 1;\n\t\tcase 0x00f6:  \n\t\t\tmap_key_clear(KEY_CONFIG);\n\t\t\treturn 1;\n\t\tcase 0x00f8:  \n\t\t\tmap_key_clear(KEY_SCALE);\n\t\t\treturn 1;\n\t\tcase 0x00f9:  \n\t\t\t \n\t\t\tmap_key_clear(KEY_FILE);\n\t\t\treturn 1;\n\t\tcase 0x00fa:  \n\t\t\tmap_key_clear(KEY_FN_ESC);\n\t\t\treturn 1;\n\t\tcase 0x00fb:  \n\t\t\tmap_key_clear(BTN_MIDDLE);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tif (usage->hid == HID_GD_WHEEL)\n\t\treturn -1;\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON &&\n\t\t\t(usage->hid & HID_USAGE) == 0x003)\n\t\treturn -1;\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_CONSUMER &&\n\t\t\t(usage->hid & HID_USAGE) == 0x238)\n\t\treturn -1;\n\n\t \n\tif ((usage->hid & HID_USAGE_PAGE) == 0xff100000 ||\n\t    (usage->hid & HID_USAGE_PAGE) == 0xffa10000) {\n\t\tfield->flags |= HID_MAIN_ITEM_RELATIVE | HID_MAIN_ITEM_VARIABLE;\n\t\tfield->logical_minimum = -127;\n\t\tfield->logical_maximum = 127;\n\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x0000:\n\t\t\thid_map_usage(hi, usage, bit, max, EV_REL, REL_HWHEEL);\n\t\t\treturn 1;\n\t\tcase 0x0001:\n\t\t\thid_map_usage(hi, usage, bit, max, EV_REL, REL_WHEEL);\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lenovo_input_mapping_tpIIkbd(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\t \n\tif (((usage->hid & HID_USAGE_PAGE) == 0xff0a0000 ||\n\t    (usage->hid & HID_USAGE_PAGE) == HID_UP_MSVENDOR) &&\n\t    field->report->id == 5) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x00bb:  \n\t\t\tmap_key_clear(LENOVO_KEY_MICMUTE);\n\t\t\treturn 1;\n\t\tcase 0x00c3:  \n\t\t\tmap_key_clear(KEY_BRIGHTNESSDOWN);\n\t\t\treturn 1;\n\t\tcase 0x00c4:  \n\t\t\tmap_key_clear(KEY_BRIGHTNESSUP);\n\t\t\treturn 1;\n\t\tcase 0x00c1:  \n\t\t\tmap_key_clear(KEY_NOTIFICATION_CENTER);\n\t\t\treturn 1;\n\t\tcase 0x00bc:  \n\t\t\tmap_key_clear(KEY_CONFIG);\n\t\t\treturn 1;\n\t\tcase 0x00b6:  \n\t\t\tmap_key_clear(KEY_BLUETOOTH);\n\t\t\treturn 1;\n\t\tcase 0x00b7:  \n\t\t\tmap_key_clear(KEY_KEYBOARD);\n\t\t\treturn 1;\n\t\tcase 0x00b8:  \n\t\t\tmap_key_clear(KEY_PROG1);\n\t\t\treturn 1;\n\t\tcase 0x00b9:  \n\t\t\tmap_key_clear(KEY_SELECTIVE_SCREENSHOT);\n\t\t\treturn 1;\n\t\tcase 0x00b5:  \n\t\t\tmap_key_clear(KEY_FN_ESC);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif ((usage->hid & HID_USAGE_PAGE) == 0xffa00000) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x00fb:  \n\t\t\tmap_key_clear(BTN_MIDDLE);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_MSVENDOR &&\n\t    field->report->id == 21) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x0004:  \n\t\t\tmap_key_clear(BTN_MIDDLE);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tif (usage->hid == HID_GD_WHEEL)\n\t\treturn -1;\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON &&\n\t\t\t(usage->hid & HID_USAGE) == 0x003)\n\t\treturn -1;\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_CONSUMER &&\n\t\t\t(usage->hid & HID_USAGE) == 0x238)\n\t\treturn -1;\n\n\t \n\tif ((usage->hid & HID_USAGE_PAGE) == 0xff100000) {\n\t\tfield->flags |= HID_MAIN_ITEM_RELATIVE | HID_MAIN_ITEM_VARIABLE;\n\t\tfield->logical_minimum = -127;\n\t\tfield->logical_maximum = 127;\n\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x0000:\n\t\t\thid_map_usage(hi, usage, bit, max, EV_REL, REL_HWHEEL);\n\t\t\treturn 1;\n\t\tcase 0x0001:\n\t\t\thid_map_usage(hi, usage, bit, max, EV_REL, REL_WHEEL);\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lenovo_input_mapping_scrollpoint(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tif (usage->hid == HID_GD_Z) {\n\t\thid_map_usage(hi, usage, bit, max, EV_REL, REL_HWHEEL);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int lenovo_input_mapping_tp10_ultrabook_kbd(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\t \n\tif (usage->hid == 0x000c0001) {\n\t\tswitch (usage->usage_index) {\n\t\tcase 8:  \n\t\t\tmap_key_clear(KEY_FN_ESC);\n\t\t\treturn 1;\n\t\tcase 9:  \n\t\t\tmap_key_clear(LENOVO_KEY_MICMUTE);\n\t\t\treturn 1;\n\t\tcase 10:  \n\t\t\tmap_key_clear(KEY_CONFIG);\n\t\t\treturn 1;\n\t\tcase 11:  \n\t\t\tmap_key_clear(KEY_SEARCH);\n\t\t\treturn 1;\n\t\tcase 12:  \n\t\t\tmap_key_clear(KEY_FILE);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tif (usage->hid == 0x00070072)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int lenovo_input_mapping_x1_tab_kbd(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\t \n\tif (usage->hid == 0x000c0001) {\n\t\tswitch (usage->usage_index) {\n\t\tcase 0:  \n\t\t\tmap_key_clear(KEY_BLUETOOTH);\n\t\t\treturn 1;\n\t\tcase 1:  \n\t\t\tmap_key_clear(KEY_KEYBOARD);\n\t\t\treturn 1;\n\t\tcase 2:  \n\t\t\tmap_key_clear(KEY_MACRO1);\n\t\t\treturn 1;\n\t\tcase 3:  \n\t\t\tmap_key_clear(KEY_SELECTIVE_SCREENSHOT);\n\t\t\treturn 1;\n\t\tcase 8:  \n\t\t\tmap_key_clear(KEY_FN_ESC);\n\t\t\treturn 1;\n\t\tcase 9:  \n\t\t\tmap_key_clear(KEY_MICMUTE);\n\t\t\treturn 1;\n\t\tcase 10:  \n\t\t\tmap_key_clear(KEY_CONFIG);\n\t\t\treturn 1;\n\t\tcase 13:  \n\t\t\tmap_key_clear(KEY_SWITCHVIDEOMODE);\n\t\t\treturn 1;\n\t\tcase 14:  \n\t\t\tmap_key_clear(KEY_WLAN);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (usage->hid == (HID_UP_KEYBOARD | 0x009a)) {\n\t\tmap_key_clear(KEY_SYSRQ);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int lenovo_input_mapping(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_TPKBD:\n\t\treturn lenovo_input_mapping_tpkbd(hdev, hi, field,\n\t\t\t\t\t\t\tusage, bit, max);\n\tcase USB_DEVICE_ID_LENOVO_CUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_CBTKBD:\n\t\treturn lenovo_input_mapping_cptkbd(hdev, hi, field,\n\t\t\t\t\t\t\tusage, bit, max);\n\tcase USB_DEVICE_ID_LENOVO_TPIIUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIBTKBD:\n\t\treturn lenovo_input_mapping_tpIIkbd(hdev, hi, field,\n\t\t\t\t\t\t\tusage, bit, max);\n\tcase USB_DEVICE_ID_IBM_SCROLLPOINT_III:\n\tcase USB_DEVICE_ID_IBM_SCROLLPOINT_PRO:\n\tcase USB_DEVICE_ID_IBM_SCROLLPOINT_OPTICAL:\n\tcase USB_DEVICE_ID_IBM_SCROLLPOINT_800DPI_OPTICAL:\n\tcase USB_DEVICE_ID_IBM_SCROLLPOINT_800DPI_OPTICAL_PRO:\n\tcase USB_DEVICE_ID_LENOVO_SCROLLPOINT_OPTICAL:\n\t\treturn lenovo_input_mapping_scrollpoint(hdev, hi, field,\n\t\t\t\t\t\t\tusage, bit, max);\n\tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n\t\treturn lenovo_input_mapping_tp10_ultrabook_kbd(hdev, hi, field,\n\t\t\t\t\t\t\t       usage, bit, max);\n\tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n\t\treturn lenovo_input_mapping_x1_tab_kbd(hdev, hi, field, usage, bit, max);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n#undef map_key_clear\n\n \nstatic int lenovo_send_cmd_cptkbd(struct hid_device *hdev,\n\t\t\tunsigned char byte2, unsigned char byte3)\n{\n\tint ret;\n\tunsigned char *buf;\n\n\tbuf = kzalloc(3, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tbuf[0] = 0x18;\n\tbuf[1] = byte2;\n\tbuf[2] = byte3;\n\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_CUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIUSBKBD:\n\t\tret = hid_hw_raw_request(hdev, 0x13, buf, 3,\n\t\t\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\t\tbreak;\n\tcase USB_DEVICE_ID_LENOVO_CBTKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIBTKBD:\n\t\tret = hid_hw_output_report(hdev, buf, 3);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tkfree(buf);\n\n\treturn ret < 0 ? ret : 0;  \n}\n\nstatic void lenovo_features_set_cptkbd(struct hid_device *hdev)\n{\n\tint ret;\n\tstruct lenovo_drvdata *cptkbd_data = hid_get_drvdata(hdev);\n\n\t \n\tret = lenovo_send_cmd_cptkbd(hdev, 0x01, 0x03);\n\tif (ret)\n\t\thid_warn(hdev, \"Failed to switch F7/9/11 mode: %d\\n\", ret);\n\n\t \n\tret = lenovo_send_cmd_cptkbd(hdev, 0x09, 0x01);\n\tif (ret)\n\t\thid_warn(hdev, \"Failed to switch middle button: %d\\n\", ret);\n\n\tret = lenovo_send_cmd_cptkbd(hdev, 0x05, cptkbd_data->fn_lock);\n\tif (ret)\n\t\thid_err(hdev, \"Fn-lock setting failed: %d\\n\", ret);\n\n\tret = lenovo_send_cmd_cptkbd(hdev, 0x02, cptkbd_data->sensitivity);\n\tif (ret)\n\t\thid_err(hdev, \"Sensitivity setting failed: %d\\n\", ret);\n}\n\nstatic ssize_t attr_fn_lock_show(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data = hid_get_drvdata(hdev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", data->fn_lock);\n}\n\nstatic ssize_t attr_fn_lock_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data = hid_get_drvdata(hdev);\n\tint value, ret;\n\n\tif (kstrtoint(buf, 10, &value))\n\t\treturn -EINVAL;\n\tif (value < 0 || value > 1)\n\t\treturn -EINVAL;\n\n\tdata->fn_lock = !!value;\n\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_CUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_CBTKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIBTKBD:\n\t\tlenovo_features_set_cptkbd(hdev);\n\t\tbreak;\n\tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n\tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n\t\tret = lenovo_led_set_tp10ubkbd(hdev, TP10UBKBD_FN_LOCK_LED, value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t attr_sensitivity_show_cptkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *cptkbd_data = hid_get_drvdata(hdev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\tcptkbd_data->sensitivity);\n}\n\nstatic ssize_t attr_sensitivity_store_cptkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *cptkbd_data = hid_get_drvdata(hdev);\n\tint value;\n\n\tif (kstrtoint(buf, 10, &value) || value < 1 || value > 255)\n\t\treturn -EINVAL;\n\n\tcptkbd_data->sensitivity = value;\n\tlenovo_features_set_cptkbd(hdev);\n\n\treturn count;\n}\n\n\nstatic struct device_attribute dev_attr_fn_lock =\n\t__ATTR(fn_lock, S_IWUSR | S_IRUGO,\n\t\t\tattr_fn_lock_show,\n\t\t\tattr_fn_lock_store);\n\nstatic struct device_attribute dev_attr_sensitivity_cptkbd =\n\t__ATTR(sensitivity, S_IWUSR | S_IRUGO,\n\t\t\tattr_sensitivity_show_cptkbd,\n\t\t\tattr_sensitivity_store_cptkbd);\n\n\nstatic struct attribute *lenovo_attributes_cptkbd[] = {\n\t&dev_attr_fn_lock.attr,\n\t&dev_attr_sensitivity_cptkbd.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lenovo_attr_group_cptkbd = {\n\t.attrs = lenovo_attributes_cptkbd,\n};\n\nstatic int lenovo_raw_event(struct hid_device *hdev,\n\t\t\tstruct hid_report *report, u8 *data, int size)\n{\n\t \n\tif (unlikely(hdev->product == USB_DEVICE_ID_LENOVO_CUSBKBD\n\t\t\t&& size == 3\n\t\t\t&& data[0] == 0x15\n\t\t\t&& data[1] == 0x94\n\t\t\t&& data[2] == 0x01)) {\n\t\tdata[1] = 0x00;\n\t\tdata[2] = 0x01;\n\t}\n\n\treturn 0;\n}\n\nstatic int lenovo_event_tp10ubkbd(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage, __s32 value)\n{\n\tstruct lenovo_drvdata *data = hid_get_drvdata(hdev);\n\n\tif (usage->type == EV_KEY && usage->code == KEY_FN_ESC && value == 1) {\n\t\t \n\t\tdata->fn_lock = !data->fn_lock;\n\t\tschedule_work(&data->fn_lock_sync_work);\n\t}\n\n\treturn 0;\n}\n\nstatic int lenovo_event_cptkbd(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage, __s32 value)\n{\n\tstruct lenovo_drvdata *cptkbd_data = hid_get_drvdata(hdev);\n\n\tif (cptkbd_data->middlebutton_state != 3) {\n\t\t \n\t\tif (hdev->product == USB_DEVICE_ID_LENOVO_CUSBKBD &&\n\t\t\t\tcptkbd_data->middlebutton_state == 1 &&\n\t\t\t\tusage->type == EV_REL &&\n\t\t\t\t(usage->code == REL_X || usage->code == REL_Y)) {\n\t\t\tcptkbd_data->middlebutton_state = 3;\n\t\t\t \n\t\t\tinput_event(field->hidinput->input,\n\t\t\t\tEV_KEY, BTN_MIDDLE, 1);\n\t\t\tinput_sync(field->hidinput->input);\n\t\t}\n\n\t\t \n\t\tif (usage->type == EV_REL && (usage->code == REL_WHEEL ||\n\t\t\t\tusage->code == REL_HWHEEL)) {\n\t\t\t \n\t\t\tcptkbd_data->middlebutton_state = 2;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (usage->type == EV_KEY && usage->code == BTN_MIDDLE) {\n\t\t\tif (value == 1) {\n\t\t\t\tcptkbd_data->middlebutton_state = 1;\n\t\t\t} else if (value == 0) {\n\t\t\t\tif (cptkbd_data->middlebutton_state == 1) {\n\t\t\t\t\t \n\t\t\t\t\tinput_event(field->hidinput->input,\n\t\t\t\t\t\tEV_KEY, BTN_MIDDLE, 1);\n\t\t\t\t\tinput_sync(field->hidinput->input);\n\t\t\t\t\tinput_event(field->hidinput->input,\n\t\t\t\t\t\tEV_KEY, BTN_MIDDLE, 0);\n\t\t\t\t\tinput_sync(field->hidinput->input);\n\t\t\t\t}\n\t\t\t\tcptkbd_data->middlebutton_state = 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (usage->type == EV_KEY && usage->code == KEY_FN_ESC && value == 1) {\n\t\t \n\t\tcptkbd_data->fn_lock = !cptkbd_data->fn_lock;\n\t}\n\n\treturn 0;\n}\n\nstatic int lenovo_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tif (!hid_get_drvdata(hdev))\n\t\treturn 0;\n\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_CUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_CBTKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIBTKBD:\n\t\treturn lenovo_event_cptkbd(hdev, field, usage, value);\n\tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n\tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n\t\treturn lenovo_event_tp10ubkbd(hdev, field, usage, value);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int lenovo_features_set_tpkbd(struct hid_device *hdev)\n{\n\tstruct hid_report *report;\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\n\treport = hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[4];\n\n\treport->field[0]->value[0]  = data_pointer->press_to_select   ? 0x01 : 0x02;\n\treport->field[0]->value[0] |= data_pointer->dragging          ? 0x04 : 0x08;\n\treport->field[0]->value[0] |= data_pointer->release_to_select ? 0x10 : 0x20;\n\treport->field[0]->value[0] |= data_pointer->select_right      ? 0x80 : 0x40;\n\treport->field[1]->value[0] = 0x03;  \n\treport->field[2]->value[0] = data_pointer->sensitivity;\n\treport->field[3]->value[0] = data_pointer->press_speed;\n\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n\treturn 0;\n}\n\nstatic ssize_t attr_press_to_select_show_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", data_pointer->press_to_select);\n}\n\nstatic ssize_t attr_press_to_select_store_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\tint value;\n\n\tif (kstrtoint(buf, 10, &value))\n\t\treturn -EINVAL;\n\tif (value < 0 || value > 1)\n\t\treturn -EINVAL;\n\n\tdata_pointer->press_to_select = value;\n\tlenovo_features_set_tpkbd(hdev);\n\n\treturn count;\n}\n\nstatic ssize_t attr_dragging_show_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", data_pointer->dragging);\n}\n\nstatic ssize_t attr_dragging_store_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\tint value;\n\n\tif (kstrtoint(buf, 10, &value))\n\t\treturn -EINVAL;\n\tif (value < 0 || value > 1)\n\t\treturn -EINVAL;\n\n\tdata_pointer->dragging = value;\n\tlenovo_features_set_tpkbd(hdev);\n\n\treturn count;\n}\n\nstatic ssize_t attr_release_to_select_show_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", data_pointer->release_to_select);\n}\n\nstatic ssize_t attr_release_to_select_store_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\tint value;\n\n\tif (kstrtoint(buf, 10, &value))\n\t\treturn -EINVAL;\n\tif (value < 0 || value > 1)\n\t\treturn -EINVAL;\n\n\tdata_pointer->release_to_select = value;\n\tlenovo_features_set_tpkbd(hdev);\n\n\treturn count;\n}\n\nstatic ssize_t attr_select_right_show_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", data_pointer->select_right);\n}\n\nstatic ssize_t attr_select_right_store_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\tint value;\n\n\tif (kstrtoint(buf, 10, &value))\n\t\treturn -EINVAL;\n\tif (value < 0 || value > 1)\n\t\treturn -EINVAL;\n\n\tdata_pointer->select_right = value;\n\tlenovo_features_set_tpkbd(hdev);\n\n\treturn count;\n}\n\nstatic ssize_t attr_sensitivity_show_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\tdata_pointer->sensitivity);\n}\n\nstatic ssize_t attr_sensitivity_store_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\tint value;\n\n\tif (kstrtoint(buf, 10, &value) || value < 1 || value > 255)\n\t\treturn -EINVAL;\n\n\tdata_pointer->sensitivity = value;\n\tlenovo_features_set_tpkbd(hdev);\n\n\treturn count;\n}\n\nstatic ssize_t attr_press_speed_show_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\tdata_pointer->press_speed);\n}\n\nstatic ssize_t attr_press_speed_store_tpkbd(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf,\n\t\tsize_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\tint value;\n\n\tif (kstrtoint(buf, 10, &value) || value < 1 || value > 255)\n\t\treturn -EINVAL;\n\n\tdata_pointer->press_speed = value;\n\tlenovo_features_set_tpkbd(hdev);\n\n\treturn count;\n}\n\nstatic struct device_attribute dev_attr_press_to_select_tpkbd =\n\t__ATTR(press_to_select, S_IWUSR | S_IRUGO,\n\t\t\tattr_press_to_select_show_tpkbd,\n\t\t\tattr_press_to_select_store_tpkbd);\n\nstatic struct device_attribute dev_attr_dragging_tpkbd =\n\t__ATTR(dragging, S_IWUSR | S_IRUGO,\n\t\t\tattr_dragging_show_tpkbd,\n\t\t\tattr_dragging_store_tpkbd);\n\nstatic struct device_attribute dev_attr_release_to_select_tpkbd =\n\t__ATTR(release_to_select, S_IWUSR | S_IRUGO,\n\t\t\tattr_release_to_select_show_tpkbd,\n\t\t\tattr_release_to_select_store_tpkbd);\n\nstatic struct device_attribute dev_attr_select_right_tpkbd =\n\t__ATTR(select_right, S_IWUSR | S_IRUGO,\n\t\t\tattr_select_right_show_tpkbd,\n\t\t\tattr_select_right_store_tpkbd);\n\nstatic struct device_attribute dev_attr_sensitivity_tpkbd =\n\t__ATTR(sensitivity, S_IWUSR | S_IRUGO,\n\t\t\tattr_sensitivity_show_tpkbd,\n\t\t\tattr_sensitivity_store_tpkbd);\n\nstatic struct device_attribute dev_attr_press_speed_tpkbd =\n\t__ATTR(press_speed, S_IWUSR | S_IRUGO,\n\t\t\tattr_press_speed_show_tpkbd,\n\t\t\tattr_press_speed_store_tpkbd);\n\nstatic struct attribute *lenovo_attributes_tpkbd[] = {\n\t&dev_attr_press_to_select_tpkbd.attr,\n\t&dev_attr_dragging_tpkbd.attr,\n\t&dev_attr_release_to_select_tpkbd.attr,\n\t&dev_attr_select_right_tpkbd.attr,\n\t&dev_attr_sensitivity_tpkbd.attr,\n\t&dev_attr_press_speed_tpkbd.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lenovo_attr_group_tpkbd = {\n\t.attrs = lenovo_attributes_tpkbd,\n};\n\nstatic void lenovo_led_set_tpkbd(struct hid_device *hdev)\n{\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\tstruct hid_report *report;\n\n\treport = hdev->report_enum[HID_OUTPUT_REPORT].report_id_hash[3];\n\treport->field[0]->value[0] = (data_pointer->led_state >> 0) & 1;\n\treport->field[0]->value[1] = (data_pointer->led_state >> 1) & 1;\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n}\n\nstatic int lenovo_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\tstatic const u8 tp10ubkbd_led[] = { TP10UBKBD_MUTE_LED, TP10UBKBD_MICMUTE_LED };\n\tint led_nr = 0;\n\tint ret = 0;\n\n\tif (led_cdev == &data_pointer->led_micmute)\n\t\tled_nr = 1;\n\n\tif (value == LED_OFF)\n\t\tdata_pointer->led_state &= ~(1 << led_nr);\n\telse\n\t\tdata_pointer->led_state |= 1 << led_nr;\n\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_TPKBD:\n\t\tlenovo_led_set_tpkbd(hdev);\n\t\tbreak;\n\tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n\tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n\t\tret = lenovo_led_set_tp10ubkbd(hdev, tp10ubkbd_led[led_nr], value);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int lenovo_register_leds(struct hid_device *hdev)\n{\n\tstruct lenovo_drvdata *data = hid_get_drvdata(hdev);\n\tsize_t name_sz = strlen(dev_name(&hdev->dev)) + 16;\n\tchar *name_mute, *name_micm;\n\tint ret;\n\n\tname_mute = devm_kzalloc(&hdev->dev, name_sz, GFP_KERNEL);\n\tname_micm = devm_kzalloc(&hdev->dev, name_sz, GFP_KERNEL);\n\tif (name_mute == NULL || name_micm == NULL) {\n\t\thid_err(hdev, \"Could not allocate memory for led data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsnprintf(name_mute, name_sz, \"%s:amber:mute\", dev_name(&hdev->dev));\n\tsnprintf(name_micm, name_sz, \"%s:amber:micmute\", dev_name(&hdev->dev));\n\n\tdata->led_mute.name = name_mute;\n\tdata->led_mute.default_trigger = \"audio-mute\";\n\tdata->led_mute.brightness_set_blocking = lenovo_led_brightness_set;\n\tdata->led_mute.max_brightness = 1;\n\tdata->led_mute.flags = LED_HW_PLUGGABLE;\n\tdata->led_mute.dev = &hdev->dev;\n\tret = led_classdev_register(&hdev->dev, &data->led_mute);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->led_micmute.name = name_micm;\n\tdata->led_micmute.default_trigger = \"audio-micmute\";\n\tdata->led_micmute.brightness_set_blocking = lenovo_led_brightness_set;\n\tdata->led_micmute.max_brightness = 1;\n\tdata->led_micmute.flags = LED_HW_PLUGGABLE;\n\tdata->led_micmute.dev = &hdev->dev;\n\tret = led_classdev_register(&hdev->dev, &data->led_micmute);\n\tif (ret < 0) {\n\t\tled_classdev_unregister(&data->led_mute);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lenovo_probe_tpkbd(struct hid_device *hdev)\n{\n\tstruct lenovo_drvdata *data_pointer;\n\tint i, ret;\n\n\t \n\tif (!hid_get_drvdata(hdev))\n\t\treturn 0;\n\n\thid_set_drvdata(hdev, NULL);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (!hid_validate_values(hdev, HID_FEATURE_REPORT, 4, i, 1))\n\t\t\treturn -ENODEV;\n\t}\n\tif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 3, 0, 2))\n\t\treturn -ENODEV;\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &lenovo_attr_group_tpkbd);\n\tif (ret)\n\t\thid_warn(hdev, \"Could not create sysfs group: %d\\n\", ret);\n\n\tdata_pointer = devm_kzalloc(&hdev->dev,\n\t\t\t\t    sizeof(struct lenovo_drvdata),\n\t\t\t\t    GFP_KERNEL);\n\tif (data_pointer == NULL) {\n\t\thid_err(hdev, \"Could not allocate memory for driver data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tdata_pointer->sensitivity = 0xa0;\n\tdata_pointer->press_speed = 0x38;\n\n\thid_set_drvdata(hdev, data_pointer);\n\n\tret = lenovo_register_leds(hdev);\n\tif (ret)\n\t\tgoto err;\n\n\tlenovo_features_set_tpkbd(hdev);\n\n\treturn 0;\nerr:\n\tsysfs_remove_group(&hdev->dev.kobj, &lenovo_attr_group_tpkbd);\n\treturn ret;\n}\n\nstatic int lenovo_probe_cptkbd(struct hid_device *hdev)\n{\n\tint ret;\n\tstruct lenovo_drvdata *cptkbd_data;\n\n\t \n\tif (((hdev->product == USB_DEVICE_ID_LENOVO_CUSBKBD) ||\n\t    (hdev->product == USB_DEVICE_ID_LENOVO_TPIIUSBKBD)) &&\n\t    hdev->type != HID_TYPE_USBMOUSE) {\n\t\thid_dbg(hdev, \"Ignoring keyboard half of device\\n\");\n\t\treturn 0;\n\t}\n\n\tcptkbd_data = devm_kzalloc(&hdev->dev,\n\t\t\t\t\tsizeof(*cptkbd_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (cptkbd_data == NULL) {\n\t\thid_err(hdev, \"can't alloc keyboard descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, cptkbd_data);\n\n\t \n\tcptkbd_data->middlebutton_state = 0;\n\tcptkbd_data->fn_lock = true;\n\tcptkbd_data->sensitivity = 0x05;\n\tlenovo_features_set_cptkbd(hdev);\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &lenovo_attr_group_cptkbd);\n\tif (ret)\n\t\thid_warn(hdev, \"Could not create sysfs group: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic struct attribute *lenovo_attributes_tp10ubkbd[] = {\n\t&dev_attr_fn_lock.attr,\n\tNULL\n};\n\nstatic const struct attribute_group lenovo_attr_group_tp10ubkbd = {\n\t.attrs = lenovo_attributes_tp10ubkbd,\n};\n\nstatic int lenovo_probe_tp10ubkbd(struct hid_device *hdev)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct lenovo_drvdata *data;\n\tstruct hid_report *rep;\n\tbool found;\n\tint ret;\n\n\t \n\tfound = false;\n\trep_enum = &hdev->report_enum[HID_OUTPUT_REPORT];\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xffa00001)\n\t\t\tfound = true;\n\t}\n\tif (!found)\n\t\treturn 0;\n\n\tdata = devm_kzalloc(&hdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->led_report_mutex);\n\tINIT_WORK(&data->fn_lock_sync_work, lenovo_tp10ubkbd_sync_fn_lock);\n\tdata->hdev = hdev;\n\n\thid_set_drvdata(hdev, data);\n\n\t \n\tdata->fn_lock = true;\n\tlenovo_led_set_tp10ubkbd(hdev, TP10UBKBD_FN_LOCK_LED, data->fn_lock);\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &lenovo_attr_group_tp10ubkbd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lenovo_register_leds(hdev);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tsysfs_remove_group(&hdev->dev.kobj, &lenovo_attr_group_tp10ubkbd);\n\treturn ret;\n}\n\nstatic int lenovo_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint ret;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hid_parse failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hid_hw_start failed\\n\");\n\t\tgoto err;\n\t}\n\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_TPKBD:\n\t\tret = lenovo_probe_tpkbd(hdev);\n\t\tbreak;\n\tcase USB_DEVICE_ID_LENOVO_CUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_CBTKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIBTKBD:\n\t\tret = lenovo_probe_cptkbd(hdev);\n\t\tbreak;\n\tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n\tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n\t\tret = lenovo_probe_tp10ubkbd(hdev);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tgoto err_hid;\n\n\treturn 0;\nerr_hid:\n\thid_hw_stop(hdev);\nerr:\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int lenovo_reset_resume(struct hid_device *hdev)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_CUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIUSBKBD:\n\t\tif (hdev->type == HID_TYPE_USBMOUSE)\n\t\t\tlenovo_features_set_cptkbd(hdev);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic void lenovo_remove_tpkbd(struct hid_device *hdev)\n{\n\tstruct lenovo_drvdata *data_pointer = hid_get_drvdata(hdev);\n\n\t \n\tif (data_pointer == NULL)\n\t\treturn;\n\n\tsysfs_remove_group(&hdev->dev.kobj,\n\t\t\t&lenovo_attr_group_tpkbd);\n\n\tled_classdev_unregister(&data_pointer->led_micmute);\n\tled_classdev_unregister(&data_pointer->led_mute);\n}\n\nstatic void lenovo_remove_cptkbd(struct hid_device *hdev)\n{\n\tsysfs_remove_group(&hdev->dev.kobj,\n\t\t\t&lenovo_attr_group_cptkbd);\n}\n\nstatic void lenovo_remove_tp10ubkbd(struct hid_device *hdev)\n{\n\tstruct lenovo_drvdata *data = hid_get_drvdata(hdev);\n\n\tif (data == NULL)\n\t\treturn;\n\n\tled_classdev_unregister(&data->led_micmute);\n\tled_classdev_unregister(&data->led_mute);\n\n\tsysfs_remove_group(&hdev->dev.kobj, &lenovo_attr_group_tp10ubkbd);\n\tcancel_work_sync(&data->fn_lock_sync_work);\n}\n\nstatic void lenovo_remove(struct hid_device *hdev)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_LENOVO_TPKBD:\n\t\tlenovo_remove_tpkbd(hdev);\n\t\tbreak;\n\tcase USB_DEVICE_ID_LENOVO_CUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_CBTKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIUSBKBD:\n\tcase USB_DEVICE_ID_LENOVO_TPIIBTKBD:\n\t\tlenovo_remove_cptkbd(hdev);\n\t\tbreak;\n\tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n\tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n\t\tlenovo_remove_tp10ubkbd(hdev);\n\t\tbreak;\n\t}\n\n\thid_hw_stop(hdev);\n}\n\nstatic int lenovo_input_configured(struct hid_device *hdev,\n\t\tstruct hid_input *hi)\n{\n\tswitch (hdev->product) {\n\t\tcase USB_DEVICE_ID_LENOVO_TPKBD:\n\t\tcase USB_DEVICE_ID_LENOVO_CUSBKBD:\n\t\tcase USB_DEVICE_ID_LENOVO_CBTKBD:\n\t\tcase USB_DEVICE_ID_LENOVO_TPIIUSBKBD:\n\t\tcase USB_DEVICE_ID_LENOVO_TPIIBTKBD:\n\t\t\tif (test_bit(EV_REL, hi->input->evbit)) {\n\t\t\t\t \n\t\t\t\t__set_bit(INPUT_PROP_POINTER, hi->input->propbit);\n\t\t\t\t__set_bit(INPUT_PROP_POINTING_STICK,\n\t\t\t\t\t\thi->input->propbit);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct hid_device_id lenovo_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPKBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CUSBKBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPIIUSBKBD) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CBTKBD) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPIIBTKBD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPPRODOCK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_IBM, USB_DEVICE_ID_IBM_SCROLLPOINT_III) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_IBM, USB_DEVICE_ID_IBM_SCROLLPOINT_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_IBM, USB_DEVICE_ID_IBM_SCROLLPOINT_OPTICAL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_IBM, USB_DEVICE_ID_IBM_SCROLLPOINT_800DPI_OPTICAL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_IBM, USB_DEVICE_ID_IBM_SCROLLPOINT_800DPI_OPTICAL_PRO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_SCROLLPOINT_OPTICAL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TP10UBKBD) },\n\t \n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_TAB) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(hid, lenovo_devices);\n\nstatic struct hid_driver lenovo_driver = {\n\t.name = \"lenovo\",\n\t.id_table = lenovo_devices,\n\t.input_configured = lenovo_input_configured,\n\t.input_mapping = lenovo_input_mapping,\n\t.probe = lenovo_probe,\n\t.remove = lenovo_remove,\n\t.raw_event = lenovo_raw_event,\n\t.event = lenovo_event,\n\t.report_fixup = lenovo_report_fixup,\n#ifdef CONFIG_PM\n\t.reset_resume = lenovo_reset_resume,\n#endif\n};\nmodule_hid_driver(lenovo_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}