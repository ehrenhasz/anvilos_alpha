{
  "module_name": "hid-udraw-ps3.c",
  "hash_id": "fe2036085eddc1c877ecc117c8a631b206c86e8a0452ab86865ea43d0d27713c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-udraw-ps3.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include \"hid-ids.h\"\n\nMODULE_AUTHOR(\"Bastien Nocera <hadess@hadess.net>\");\nMODULE_DESCRIPTION(\"PS3 uDraw tablet driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n \n\nenum {\n\tTOUCH_NONE,\n\tTOUCH_PEN,\n\tTOUCH_FINGER,\n\tTOUCH_TWOFINGER\n};\n\nenum {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z\n};\n\n \nstatic struct {\n\tint min;\n\tint max;\n} accel_limits[] = {\n\t[AXIS_X] = { 490, 534 },\n\t[AXIS_Y] = { 490, 534 },\n\t[AXIS_Z] = { 492, 536 }\n};\n\n#define DEVICE_NAME \"THQ uDraw Game Tablet for PS3\"\n \n#define RES_X 1920\n#define RES_Y 1080\n \n#define WIDTH  160\n#define HEIGHT 90\n#define PRESSURE_OFFSET 113\n#define MAX_PRESSURE (255 - PRESSURE_OFFSET)\n\nstruct udraw {\n\tstruct input_dev *joy_input_dev;\n\tstruct input_dev *touch_input_dev;\n\tstruct input_dev *pen_input_dev;\n\tstruct input_dev *accel_input_dev;\n\tstruct hid_device *hdev;\n\n\t \n\tint last_one_finger_x;\n\tint last_one_finger_y;\n\tint last_two_finger_x;\n\tint last_two_finger_y;\n};\n\nstatic int clamp_accel(int axis, int offset)\n{\n\taxis = clamp(axis,\n\t\t\taccel_limits[offset].min,\n\t\t\taccel_limits[offset].max);\n\taxis = (axis - accel_limits[offset].min) /\n\t\t\t((accel_limits[offset].max -\n\t\t\t  accel_limits[offset].min) * 0xFF);\n\treturn axis;\n}\n\nstatic int udraw_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t u8 *data, int len)\n{\n\tstruct udraw *udraw = hid_get_drvdata(hdev);\n\tint touch;\n\tint x, y, z;\n\n\tif (len != 27)\n\t\treturn 0;\n\n\tif (data[11] == 0x00)\n\t\ttouch = TOUCH_NONE;\n\telse if (data[11] == 0x40)\n\t\ttouch = TOUCH_PEN;\n\telse if (data[11] == 0x80)\n\t\ttouch = TOUCH_FINGER;\n\telse\n\t\ttouch = TOUCH_TWOFINGER;\n\n\t \n\tinput_report_key(udraw->joy_input_dev, BTN_WEST, data[0] & 1);\n\tinput_report_key(udraw->joy_input_dev, BTN_SOUTH, !!(data[0] & 2));\n\tinput_report_key(udraw->joy_input_dev, BTN_EAST, !!(data[0] & 4));\n\tinput_report_key(udraw->joy_input_dev, BTN_NORTH, !!(data[0] & 8));\n\n\tinput_report_key(udraw->joy_input_dev, BTN_SELECT, !!(data[1] & 1));\n\tinput_report_key(udraw->joy_input_dev, BTN_START, !!(data[1] & 2));\n\tinput_report_key(udraw->joy_input_dev, BTN_MODE, !!(data[1] & 16));\n\n\tx = y = 0;\n\tswitch (data[2]) {\n\tcase 0x0:\n\t\ty = -127;\n\t\tbreak;\n\tcase 0x1:\n\t\ty = -127;\n\t\tx = 127;\n\t\tbreak;\n\tcase 0x2:\n\t\tx = 127;\n\t\tbreak;\n\tcase 0x3:\n\t\ty = 127;\n\t\tx = 127;\n\t\tbreak;\n\tcase 0x4:\n\t\ty = 127;\n\t\tbreak;\n\tcase 0x5:\n\t\ty = 127;\n\t\tx = -127;\n\t\tbreak;\n\tcase 0x6:\n\t\tx = -127;\n\t\tbreak;\n\tcase 0x7:\n\t\ty = -127;\n\t\tx = -127;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tinput_report_abs(udraw->joy_input_dev, ABS_X, x);\n\tinput_report_abs(udraw->joy_input_dev, ABS_Y, y);\n\n\tinput_sync(udraw->joy_input_dev);\n\n\t \n\tx = y = 0;\n\tif (touch != TOUCH_NONE) {\n\t\tif (data[15] != 0x0F)\n\t\t\tx = data[15] * 256 + data[17];\n\t\tif (data[16] != 0x0F)\n\t\t\ty = data[16] * 256 + data[18];\n\t}\n\n\tif (touch == TOUCH_FINGER) {\n\t\t \n\t\tudraw->last_one_finger_x = x;\n\t\tudraw->last_one_finger_y = y;\n\t\tudraw->last_two_finger_x = -1;\n\t\tudraw->last_two_finger_y = -1;\n\t} else if (touch == TOUCH_TWOFINGER) {\n\t\t \n\t\tif (udraw->last_two_finger_x == -1) {\n\t\t\t \n\t\t\tudraw->last_two_finger_x = x;\n\t\t\tudraw->last_two_finger_y = y;\n\n\t\t\tx = udraw->last_one_finger_x;\n\t\t\ty = udraw->last_one_finger_y;\n\t\t} else {\n\t\t\t \n\t\t\tx = x - (udraw->last_two_finger_x\n\t\t\t\t- udraw->last_one_finger_x);\n\t\t\ty = y - (udraw->last_two_finger_y\n\t\t\t\t- udraw->last_one_finger_y);\n\t\t}\n\t}\n\n\t \n\tif (touch == TOUCH_FINGER || touch == TOUCH_TWOFINGER) {\n\t\tinput_report_key(udraw->touch_input_dev, BTN_TOUCH, 1);\n\t\tinput_report_key(udraw->touch_input_dev, BTN_TOOL_FINGER,\n\t\t\t\ttouch == TOUCH_FINGER);\n\t\tinput_report_key(udraw->touch_input_dev, BTN_TOOL_DOUBLETAP,\n\t\t\t\ttouch == TOUCH_TWOFINGER);\n\n\t\tinput_report_abs(udraw->touch_input_dev, ABS_X, x);\n\t\tinput_report_abs(udraw->touch_input_dev, ABS_Y, y);\n\t} else {\n\t\tinput_report_key(udraw->touch_input_dev, BTN_TOUCH, 0);\n\t\tinput_report_key(udraw->touch_input_dev, BTN_TOOL_FINGER, 0);\n\t\tinput_report_key(udraw->touch_input_dev, BTN_TOOL_DOUBLETAP, 0);\n\t}\n\tinput_sync(udraw->touch_input_dev);\n\n\t \n\tif (touch == TOUCH_PEN) {\n\t\tint level;\n\n\t\tlevel = clamp(data[13] - PRESSURE_OFFSET,\n\t\t\t\t0, MAX_PRESSURE);\n\n\t\tinput_report_key(udraw->pen_input_dev, BTN_TOUCH, (level != 0));\n\t\tinput_report_key(udraw->pen_input_dev, BTN_TOOL_PEN, 1);\n\t\tinput_report_abs(udraw->pen_input_dev, ABS_PRESSURE, level);\n\t\tinput_report_abs(udraw->pen_input_dev, ABS_X, x);\n\t\tinput_report_abs(udraw->pen_input_dev, ABS_Y, y);\n\t} else {\n\t\tinput_report_key(udraw->pen_input_dev, BTN_TOUCH, 0);\n\t\tinput_report_key(udraw->pen_input_dev, BTN_TOOL_PEN, 0);\n\t\tinput_report_abs(udraw->pen_input_dev, ABS_PRESSURE, 0);\n\t}\n\tinput_sync(udraw->pen_input_dev);\n\n\t \n\tx = (data[19] + (data[20] << 8));\n\tx = clamp_accel(x, AXIS_X);\n\ty = (data[21] + (data[22] << 8));\n\ty = clamp_accel(y, AXIS_Y);\n\tz = (data[23] + (data[24] << 8));\n\tz = clamp_accel(z, AXIS_Z);\n\tinput_report_abs(udraw->accel_input_dev, ABS_X, x);\n\tinput_report_abs(udraw->accel_input_dev, ABS_Y, y);\n\tinput_report_abs(udraw->accel_input_dev, ABS_Z, z);\n\tinput_sync(udraw->accel_input_dev);\n\n\t \n\treturn 0;\n}\n\nstatic int udraw_open(struct input_dev *dev)\n{\n\tstruct udraw *udraw = input_get_drvdata(dev);\n\n\treturn hid_hw_open(udraw->hdev);\n}\n\nstatic void udraw_close(struct input_dev *dev)\n{\n\tstruct udraw *udraw = input_get_drvdata(dev);\n\n\thid_hw_close(udraw->hdev);\n}\n\nstatic struct input_dev *allocate_and_setup(struct hid_device *hdev,\n\t\tconst char *name)\n{\n\tstruct input_dev *input_dev;\n\n\tinput_dev = devm_input_allocate_device(&hdev->dev);\n\tif (!input_dev)\n\t\treturn NULL;\n\n\tinput_dev->name = name;\n\tinput_dev->phys = hdev->phys;\n\tinput_dev->dev.parent = &hdev->dev;\n\tinput_dev->open = udraw_open;\n\tinput_dev->close = udraw_close;\n\tinput_dev->uniq = hdev->uniq;\n\tinput_dev->id.bustype = hdev->bus;\n\tinput_dev->id.vendor  = hdev->vendor;\n\tinput_dev->id.product = hdev->product;\n\tinput_dev->id.version = hdev->version;\n\tinput_set_drvdata(input_dev, hid_get_drvdata(hdev));\n\n\treturn input_dev;\n}\n\nstatic bool udraw_setup_touch(struct udraw *udraw,\n\t\tstruct hid_device *hdev)\n{\n\tstruct input_dev *input_dev;\n\n\tinput_dev = allocate_and_setup(hdev, DEVICE_NAME \" Touchpad\");\n\tif (!input_dev)\n\t\treturn false;\n\n\tinput_dev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, RES_X, 1, 0);\n\tinput_abs_set_res(input_dev, ABS_X, RES_X / WIDTH);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, RES_Y, 1, 0);\n\tinput_abs_set_res(input_dev, ABS_Y, RES_Y / HEIGHT);\n\n\tset_bit(BTN_TOUCH, input_dev->keybit);\n\tset_bit(BTN_TOOL_FINGER, input_dev->keybit);\n\tset_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);\n\n\tset_bit(INPUT_PROP_POINTER, input_dev->propbit);\n\n\tudraw->touch_input_dev = input_dev;\n\n\treturn true;\n}\n\nstatic bool udraw_setup_pen(struct udraw *udraw,\n\t\tstruct hid_device *hdev)\n{\n\tstruct input_dev *input_dev;\n\n\tinput_dev = allocate_and_setup(hdev, DEVICE_NAME \" Pen\");\n\tif (!input_dev)\n\t\treturn false;\n\n\tinput_dev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0, RES_X, 1, 0);\n\tinput_abs_set_res(input_dev, ABS_X, RES_X / WIDTH);\n\tinput_set_abs_params(input_dev, ABS_Y, 0, RES_Y, 1, 0);\n\tinput_abs_set_res(input_dev, ABS_Y, RES_Y / HEIGHT);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE,\n\t\t\t0, MAX_PRESSURE, 0, 0);\n\n\tset_bit(BTN_TOUCH, input_dev->keybit);\n\tset_bit(BTN_TOOL_PEN, input_dev->keybit);\n\n\tset_bit(INPUT_PROP_POINTER, input_dev->propbit);\n\n\tudraw->pen_input_dev = input_dev;\n\n\treturn true;\n}\n\nstatic bool udraw_setup_accel(struct udraw *udraw,\n\t\tstruct hid_device *hdev)\n{\n\tstruct input_dev *input_dev;\n\n\tinput_dev = allocate_and_setup(hdev, DEVICE_NAME \" Accelerometer\");\n\tif (!input_dev)\n\t\treturn false;\n\n\tinput_dev->evbit[0] = BIT(EV_ABS);\n\n\t \n\tinput_set_abs_params(input_dev, ABS_X, -512, 512, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, -512, 512, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Z, -512, 512, 0, 0);\n\n\tset_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);\n\n\tudraw->accel_input_dev = input_dev;\n\n\treturn true;\n}\n\nstatic bool udraw_setup_joypad(struct udraw *udraw,\n\t\tstruct hid_device *hdev)\n{\n\tstruct input_dev *input_dev;\n\n\tinput_dev = allocate_and_setup(hdev, DEVICE_NAME \" Joypad\");\n\tif (!input_dev)\n\t\treturn false;\n\n\tinput_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);\n\n\tset_bit(BTN_SOUTH, input_dev->keybit);\n\tset_bit(BTN_NORTH, input_dev->keybit);\n\tset_bit(BTN_EAST, input_dev->keybit);\n\tset_bit(BTN_WEST, input_dev->keybit);\n\tset_bit(BTN_SELECT, input_dev->keybit);\n\tset_bit(BTN_START, input_dev->keybit);\n\tset_bit(BTN_MODE, input_dev->keybit);\n\n\tinput_set_abs_params(input_dev, ABS_X, -127, 127, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, -127, 127, 0, 0);\n\n\tudraw->joy_input_dev = input_dev;\n\n\treturn true;\n}\n\nstatic int udraw_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct udraw *udraw;\n\tint ret;\n\n\tudraw = devm_kzalloc(&hdev->dev, sizeof(struct udraw), GFP_KERNEL);\n\tif (!udraw)\n\t\treturn -ENOMEM;\n\n\tudraw->hdev = hdev;\n\tudraw->last_two_finger_x = -1;\n\tudraw->last_two_finger_y = -1;\n\n\thid_set_drvdata(hdev, udraw);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!udraw_setup_joypad(udraw, hdev) ||\n\t    !udraw_setup_touch(udraw, hdev) ||\n\t    !udraw_setup_pen(udraw, hdev) ||\n\t    !udraw_setup_accel(udraw, hdev)) {\n\t\thid_err(hdev, \"could not allocate interfaces\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = input_register_device(udraw->joy_input_dev) ||\n\t\tinput_register_device(udraw->touch_input_dev) ||\n\t\tinput_register_device(udraw->pen_input_dev) ||\n\t\tinput_register_device(udraw->accel_input_dev);\n\tif (ret) {\n\t\thid_err(hdev, \"failed to register interfaces\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW | HID_CONNECT_DRIVER);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id udraw_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THQ, USB_DEVICE_ID_THQ_PS3_UDRAW) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, udraw_devices);\n\nstatic struct hid_driver udraw_driver = {\n\t.name = \"hid-udraw\",\n\t.id_table = udraw_devices,\n\t.raw_event = udraw_raw_event,\n\t.probe = udraw_probe,\n};\nmodule_hid_driver(udraw_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}