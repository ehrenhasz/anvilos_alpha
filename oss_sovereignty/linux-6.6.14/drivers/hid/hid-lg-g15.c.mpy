{
  "module_name": "hid-lg-g15.c",
  "hash_id": "92e721145cd1f16ab599e605b4b2a6e61705e429bf52cddd9414da2392c7266f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-lg-g15.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n\n#include \"hid-ids.h\"\n\n#define LG_G15_TRANSFER_BUF_SIZE\t20\n\n#define LG_G15_FEATURE_REPORT\t\t0x02\n\n#define LG_G510_FEATURE_M_KEYS_LEDS\t0x04\n#define LG_G510_FEATURE_BACKLIGHT_RGB\t0x05\n#define LG_G510_FEATURE_POWER_ON_RGB\t0x06\n\nenum lg_g15_model {\n\tLG_G15,\n\tLG_G15_V2,\n\tLG_G510,\n\tLG_G510_USB_AUDIO,\n\tLG_Z10,\n};\n\nenum lg_g15_led_type {\n\tLG_G15_KBD_BRIGHTNESS,\n\tLG_G15_LCD_BRIGHTNESS,\n\tLG_G15_BRIGHTNESS_MAX,\n\tLG_G15_MACRO_PRESET1 = 2,\n\tLG_G15_MACRO_PRESET2,\n\tLG_G15_MACRO_PRESET3,\n\tLG_G15_MACRO_RECORD,\n\tLG_G15_LED_MAX\n};\n\nstruct lg_g15_led {\n\tstruct led_classdev cdev;\n\tenum led_brightness brightness;\n\tenum lg_g15_led_type led;\n\tu8 red, green, blue;\n};\n\nstruct lg_g15_data {\n\t \n\tu8 transfer_buf[LG_G15_TRANSFER_BUF_SIZE];\n\t \n\tstruct mutex mutex;\n\tstruct work_struct work;\n\tstruct input_dev *input;\n\tstruct hid_device *hdev;\n\tenum lg_g15_model model;\n\tstruct lg_g15_led leds[LG_G15_LED_MAX];\n\tbool game_mode_enabled;\n};\n\n \n\nstatic int lg_g15_update_led_brightness(struct lg_g15_data *g15)\n{\n\tint ret;\n\n\tret = hid_hw_raw_request(g15->hdev, LG_G15_FEATURE_REPORT,\n\t\t\t\t g15->transfer_buf, 4,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret != 4) {\n\t\thid_err(g15->hdev, \"Error getting LED brightness: %d\\n\", ret);\n\t\treturn (ret < 0) ? ret : -EIO;\n\t}\n\n\tg15->leds[LG_G15_KBD_BRIGHTNESS].brightness = g15->transfer_buf[1];\n\tg15->leds[LG_G15_LCD_BRIGHTNESS].brightness = g15->transfer_buf[2];\n\n\tg15->leds[LG_G15_MACRO_PRESET1].brightness =\n\t\t!(g15->transfer_buf[3] & 0x01);\n\tg15->leds[LG_G15_MACRO_PRESET2].brightness =\n\t\t!(g15->transfer_buf[3] & 0x02);\n\tg15->leds[LG_G15_MACRO_PRESET3].brightness =\n\t\t!(g15->transfer_buf[3] & 0x04);\n\tg15->leds[LG_G15_MACRO_RECORD].brightness =\n\t\t!(g15->transfer_buf[3] & 0x08);\n\n\treturn 0;\n}\n\nstatic enum led_brightness lg_g15_led_get(struct led_classdev *led_cdev)\n{\n\tstruct lg_g15_led *g15_led =\n\t\tcontainer_of(led_cdev, struct lg_g15_led, cdev);\n\tstruct lg_g15_data *g15 = dev_get_drvdata(led_cdev->dev->parent);\n\tenum led_brightness brightness;\n\n\tmutex_lock(&g15->mutex);\n\tlg_g15_update_led_brightness(g15);\n\tbrightness = g15->leds[g15_led->led].brightness;\n\tmutex_unlock(&g15->mutex);\n\n\treturn brightness;\n}\n\nstatic int lg_g15_led_set(struct led_classdev *led_cdev,\n\t\t\t  enum led_brightness brightness)\n{\n\tstruct lg_g15_led *g15_led =\n\t\tcontainer_of(led_cdev, struct lg_g15_led, cdev);\n\tstruct lg_g15_data *g15 = dev_get_drvdata(led_cdev->dev->parent);\n\tu8 val, mask = 0;\n\tint i, ret;\n\n\t \n\tif (led_cdev->flags & LED_UNREGISTERING)\n\t\treturn 0;\n\n\tmutex_lock(&g15->mutex);\n\n\tg15->transfer_buf[0] = LG_G15_FEATURE_REPORT;\n\tg15->transfer_buf[3] = 0;\n\n\tif (g15_led->led < LG_G15_BRIGHTNESS_MAX) {\n\t\tg15->transfer_buf[1] = g15_led->led + 1;\n\t\tg15->transfer_buf[2] = brightness << (g15_led->led * 4);\n\t} else {\n\t\tfor (i = LG_G15_MACRO_PRESET1; i < LG_G15_LED_MAX; i++) {\n\t\t\tif (i == g15_led->led)\n\t\t\t\tval = brightness;\n\t\t\telse\n\t\t\t\tval = g15->leds[i].brightness;\n\n\t\t\tif (val)\n\t\t\t\tmask |= 1 << (i - LG_G15_MACRO_PRESET1);\n\t\t}\n\n\t\tg15->transfer_buf[1] = 0x04;\n\t\tg15->transfer_buf[2] = ~mask;\n\t}\n\n\tret = hid_hw_raw_request(g15->hdev, LG_G15_FEATURE_REPORT,\n\t\t\t\t g15->transfer_buf, 4,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\tif (ret == 4) {\n\t\t \n\t\tg15_led->brightness = brightness;\n\t\tret = 0;\n\t} else {\n\t\thid_err(g15->hdev, \"Error setting LED brightness: %d\\n\", ret);\n\t\tret = (ret < 0) ? ret : -EIO;\n\t}\n\n\tmutex_unlock(&g15->mutex);\n\n\treturn ret;\n}\n\nstatic void lg_g15_leds_changed_work(struct work_struct *work)\n{\n\tstruct lg_g15_data *g15 = container_of(work, struct lg_g15_data, work);\n\tenum led_brightness old_brightness[LG_G15_BRIGHTNESS_MAX];\n\tenum led_brightness brightness[LG_G15_BRIGHTNESS_MAX];\n\tint i, ret;\n\n\tmutex_lock(&g15->mutex);\n\tfor (i = 0; i < LG_G15_BRIGHTNESS_MAX; i++)\n\t\told_brightness[i] = g15->leds[i].brightness;\n\n\tret = lg_g15_update_led_brightness(g15);\n\n\tfor (i = 0; i < LG_G15_BRIGHTNESS_MAX; i++)\n\t\tbrightness[i] = g15->leds[i].brightness;\n\tmutex_unlock(&g15->mutex);\n\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < LG_G15_BRIGHTNESS_MAX; i++) {\n\t\tif (brightness[i] == old_brightness[i])\n\t\t\tcontinue;\n\n\t\tled_classdev_notify_brightness_hw_changed(&g15->leds[i].cdev,\n\t\t\t\t\t\t\t  brightness[i]);\n\t}\n}\n\n \n\nstatic int lg_g510_get_initial_led_brightness(struct lg_g15_data *g15, int i)\n{\n\tint ret, high;\n\n\tret = hid_hw_raw_request(g15->hdev, LG_G510_FEATURE_BACKLIGHT_RGB + i,\n\t\t\t\t g15->transfer_buf, 4,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret != 4) {\n\t\thid_err(g15->hdev, \"Error getting LED brightness: %d\\n\", ret);\n\t\treturn (ret < 0) ? ret : -EIO;\n\t}\n\n\thigh = max3(g15->transfer_buf[1], g15->transfer_buf[2],\n\t\t    g15->transfer_buf[3]);\n\n\tif (high) {\n\t\tg15->leds[i].red =\n\t\t\tDIV_ROUND_CLOSEST(g15->transfer_buf[1] * 255, high);\n\t\tg15->leds[i].green =\n\t\t\tDIV_ROUND_CLOSEST(g15->transfer_buf[2] * 255, high);\n\t\tg15->leds[i].blue =\n\t\t\tDIV_ROUND_CLOSEST(g15->transfer_buf[3] * 255, high);\n\t\tg15->leds[i].brightness = high;\n\t} else {\n\t\tg15->leds[i].red   = 255;\n\t\tg15->leds[i].green = 255;\n\t\tg15->leds[i].blue  = 255;\n\t\tg15->leds[i].brightness = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int lg_g510_kbd_led_write(struct lg_g15_data *g15,\n\t\t\t\t struct lg_g15_led *g15_led,\n\t\t\t\t enum led_brightness brightness)\n{\n\tint ret;\n\n\tg15->transfer_buf[0] = 5 + g15_led->led;\n\tg15->transfer_buf[1] =\n\t\tDIV_ROUND_CLOSEST(g15_led->red * brightness, 255);\n\tg15->transfer_buf[2] =\n\t\tDIV_ROUND_CLOSEST(g15_led->green * brightness, 255);\n\tg15->transfer_buf[3] =\n\t\tDIV_ROUND_CLOSEST(g15_led->blue * brightness, 255);\n\n\tret = hid_hw_raw_request(g15->hdev,\n\t\t\t\t LG_G510_FEATURE_BACKLIGHT_RGB + g15_led->led,\n\t\t\t\t g15->transfer_buf, 4,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\tif (ret == 4) {\n\t\t \n\t\tg15_led->brightness = brightness;\n\t\tret = 0;\n\t} else {\n\t\thid_err(g15->hdev, \"Error setting LED brightness: %d\\n\", ret);\n\t\tret = (ret < 0) ? ret : -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int lg_g510_kbd_led_set(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness brightness)\n{\n\tstruct lg_g15_led *g15_led =\n\t\tcontainer_of(led_cdev, struct lg_g15_led, cdev);\n\tstruct lg_g15_data *g15 = dev_get_drvdata(led_cdev->dev->parent);\n\tint ret;\n\n\t \n\tif (led_cdev->flags & LED_UNREGISTERING)\n\t\treturn 0;\n\n\tmutex_lock(&g15->mutex);\n\tret = lg_g510_kbd_led_write(g15, g15_led, brightness);\n\tmutex_unlock(&g15->mutex);\n\n\treturn ret;\n}\n\nstatic enum led_brightness lg_g510_kbd_led_get(struct led_classdev *led_cdev)\n{\n\tstruct lg_g15_led *g15_led =\n\t\tcontainer_of(led_cdev, struct lg_g15_led, cdev);\n\n\treturn g15_led->brightness;\n}\n\nstatic ssize_t color_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lg_g15_led *g15_led =\n\t\tcontainer_of(led_cdev, struct lg_g15_led, cdev);\n\tstruct lg_g15_data *g15 = dev_get_drvdata(led_cdev->dev->parent);\n\tunsigned long value;\n\tint ret;\n\n\tif (count < 7 || (count == 8 && buf[7] != '\\n') || count > 8)\n\t\treturn -EINVAL;\n\n\tif (buf[0] != '#')\n\t\treturn -EINVAL;\n\n\tret = kstrtoul(buf + 1, 16, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&g15->mutex);\n\tg15_led->red   = (value & 0xff0000) >> 16;\n\tg15_led->green = (value & 0x00ff00) >> 8;\n\tg15_led->blue  = (value & 0x0000ff);\n\tret = lg_g510_kbd_led_write(g15, g15_led, g15_led->brightness);\n\tmutex_unlock(&g15->mutex);\n\n\treturn (ret < 0) ? ret : count;\n}\n\nstatic ssize_t color_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct lg_g15_led *g15_led =\n\t\tcontainer_of(led_cdev, struct lg_g15_led, cdev);\n\tstruct lg_g15_data *g15 = dev_get_drvdata(led_cdev->dev->parent);\n\tssize_t ret;\n\n\tmutex_lock(&g15->mutex);\n\tret = sprintf(buf, \"#%02x%02x%02x\\n\",\n\t\t      g15_led->red, g15_led->green, g15_led->blue);\n\tmutex_unlock(&g15->mutex);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RW(color);\n\nstatic struct attribute *lg_g510_kbd_led_attrs[] = {\n\t&dev_attr_color.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lg_g510_kbd_led_group = {\n\t.attrs = lg_g510_kbd_led_attrs,\n};\n\nstatic const struct attribute_group *lg_g510_kbd_led_groups[] = {\n\t&lg_g510_kbd_led_group,\n\tNULL,\n};\n\nstatic void lg_g510_leds_sync_work(struct work_struct *work)\n{\n\tstruct lg_g15_data *g15 = container_of(work, struct lg_g15_data, work);\n\n\tmutex_lock(&g15->mutex);\n\tlg_g510_kbd_led_write(g15, &g15->leds[LG_G15_KBD_BRIGHTNESS],\n\t\t\t      g15->leds[LG_G15_KBD_BRIGHTNESS].brightness);\n\tmutex_unlock(&g15->mutex);\n}\n\nstatic int lg_g510_update_mkey_led_brightness(struct lg_g15_data *g15)\n{\n\tint ret;\n\n\tret = hid_hw_raw_request(g15->hdev, LG_G510_FEATURE_M_KEYS_LEDS,\n\t\t\t\t g15->transfer_buf, 2,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret != 2) {\n\t\thid_err(g15->hdev, \"Error getting LED brightness: %d\\n\", ret);\n\t\tret = (ret < 0) ? ret : -EIO;\n\t}\n\n\tg15->leds[LG_G15_MACRO_PRESET1].brightness =\n\t\t!!(g15->transfer_buf[1] & 0x80);\n\tg15->leds[LG_G15_MACRO_PRESET2].brightness =\n\t\t!!(g15->transfer_buf[1] & 0x40);\n\tg15->leds[LG_G15_MACRO_PRESET3].brightness =\n\t\t!!(g15->transfer_buf[1] & 0x20);\n\tg15->leds[LG_G15_MACRO_RECORD].brightness =\n\t\t!!(g15->transfer_buf[1] & 0x10);\n\n\treturn 0;\n}\n\nstatic enum led_brightness lg_g510_mkey_led_get(struct led_classdev *led_cdev)\n{\n\tstruct lg_g15_led *g15_led =\n\t\tcontainer_of(led_cdev, struct lg_g15_led, cdev);\n\tstruct lg_g15_data *g15 = dev_get_drvdata(led_cdev->dev->parent);\n\tenum led_brightness brightness;\n\n\tmutex_lock(&g15->mutex);\n\tlg_g510_update_mkey_led_brightness(g15);\n\tbrightness = g15->leds[g15_led->led].brightness;\n\tmutex_unlock(&g15->mutex);\n\n\treturn brightness;\n}\n\nstatic int lg_g510_mkey_led_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness brightness)\n{\n\tstruct lg_g15_led *g15_led =\n\t\tcontainer_of(led_cdev, struct lg_g15_led, cdev);\n\tstruct lg_g15_data *g15 = dev_get_drvdata(led_cdev->dev->parent);\n\tu8 val, mask = 0;\n\tint i, ret;\n\n\t \n\tif (led_cdev->flags & LED_UNREGISTERING)\n\t\treturn 0;\n\n\tmutex_lock(&g15->mutex);\n\n\tfor (i = LG_G15_MACRO_PRESET1; i < LG_G15_LED_MAX; i++) {\n\t\tif (i == g15_led->led)\n\t\t\tval = brightness;\n\t\telse\n\t\t\tval = g15->leds[i].brightness;\n\n\t\tif (val)\n\t\t\tmask |= 0x80 >> (i - LG_G15_MACRO_PRESET1);\n\t}\n\n\tg15->transfer_buf[0] = LG_G510_FEATURE_M_KEYS_LEDS;\n\tg15->transfer_buf[1] = mask;\n\n\tret = hid_hw_raw_request(g15->hdev, LG_G510_FEATURE_M_KEYS_LEDS,\n\t\t\t\t g15->transfer_buf, 2,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\tif (ret == 2) {\n\t\t \n\t\tg15_led->brightness = brightness;\n\t\tret = 0;\n\t} else {\n\t\thid_err(g15->hdev, \"Error setting LED brightness: %d\\n\", ret);\n\t\tret = (ret < 0) ? ret : -EIO;\n\t}\n\n\tmutex_unlock(&g15->mutex);\n\n\treturn ret;\n}\n\n \nstatic int lg_g15_get_initial_led_brightness(struct lg_g15_data *g15)\n{\n\tint ret;\n\n\tswitch (g15->model) {\n\tcase LG_G15:\n\tcase LG_G15_V2:\n\t\treturn lg_g15_update_led_brightness(g15);\n\tcase LG_G510:\n\tcase LG_G510_USB_AUDIO:\n\t\tret = lg_g510_get_initial_led_brightness(g15, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = lg_g510_get_initial_led_brightness(g15, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn lg_g510_update_mkey_led_brightness(g15);\n\tcase LG_Z10:\n\t\t \n\t\treturn 0;\n\t}\n\treturn -EINVAL;  \n}\n\n \n\n \nstatic void lg_g15_handle_lcd_menu_keys(struct lg_g15_data *g15, u8 *data)\n{\n\tint i, val;\n\n\t \n\tinput_report_key(g15->input, KEY_KBD_LCD_MENU1, data[8] & 0x80);\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tval = data[i + 2] & 0x80;\n\t\tinput_report_key(g15->input, KEY_KBD_LCD_MENU2 + i, val);\n\t}\n}\n\nstatic int lg_g15_event(struct lg_g15_data *g15, u8 *data)\n{\n\tint i, val;\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tval = data[i + 1] & (1 << i);\n\t\tinput_report_key(g15->input, KEY_MACRO1 + i, val);\n\t}\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tval = data[i + 2] & (1 << i);\n\t\tinput_report_key(g15->input, KEY_MACRO7 + i, val);\n\t}\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tval = data[i + 1] & (4 << i);\n\t\tinput_report_key(g15->input, KEY_MACRO13 + i, val);\n\t}\n\t \n\tinput_report_key(g15->input, KEY_MACRO18, data[8] & 0x40);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tval = data[i + 6] & (1 << i);\n\t\tinput_report_key(g15->input, KEY_MACRO_PRESET1 + i, val);\n\t}\n\t \n\tinput_report_key(g15->input, KEY_MACRO_RECORD_START, data[7] & 0x40);\n\n\tlg_g15_handle_lcd_menu_keys(g15, data);\n\n\t \n\tif (data[1] & 0x80)\n\t\tschedule_work(&g15->work);\n\n\tinput_sync(g15->input);\n\treturn 0;\n}\n\nstatic int lg_g15_v2_event(struct lg_g15_data *g15, u8 *data)\n{\n\tint i, val;\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tval = data[1] & (1 << i);\n\t\tinput_report_key(g15->input, KEY_MACRO1 + i, val);\n\t}\n\n\t \n\tinput_report_key(g15->input, KEY_MACRO_PRESET1, data[1] & 0x40);\n\tinput_report_key(g15->input, KEY_MACRO_PRESET2, data[1] & 0x80);\n\tinput_report_key(g15->input, KEY_MACRO_PRESET3, data[2] & 0x20);\n\tinput_report_key(g15->input, KEY_MACRO_RECORD_START, data[2] & 0x40);\n\n\t \n\tinput_report_key(g15->input, KEY_KBD_LCD_MENU1, data[2] & 0x80);\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tval = data[2] & (2 << i);\n\t\tinput_report_key(g15->input, KEY_KBD_LCD_MENU2 + i, val);\n\t}\n\n\t \n\tif (data[2] & 0x01)\n\t\tschedule_work(&g15->work);\n\n\tinput_sync(g15->input);\n\treturn 0;\n}\n\nstatic int lg_g510_event(struct lg_g15_data *g15, u8 *data)\n{\n\tbool game_mode_enabled;\n\tint i, val;\n\n\t \n\tfor (i = 0; i < 18; i++) {\n\t\tval = data[i / 8 + 1] & (1 << (i % 8));\n\t\tinput_report_key(g15->input, KEY_MACRO1 + i, val);\n\t}\n\n\t \n\tgame_mode_enabled = data[3] & 0x04;\n\tif (game_mode_enabled != g15->game_mode_enabled) {\n\t\tif (game_mode_enabled)\n\t\t\thid_info(g15->hdev, \"Game Mode enabled, Windows (super) key is disabled\\n\");\n\t\telse\n\t\t\thid_info(g15->hdev, \"Game Mode disabled\\n\");\n\t\tg15->game_mode_enabled = game_mode_enabled;\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tval = data[3] & (0x10 << i);\n\t\tinput_report_key(g15->input, KEY_MACRO_PRESET1 + i, val);\n\t}\n\t \n\tinput_report_key(g15->input, KEY_MACRO_RECORD_START, data[3] & 0x80);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tval = data[4] & (1 << i);\n\t\tinput_report_key(g15->input, KEY_KBD_LCD_MENU1 + i, val);\n\t}\n\n\t \n\tinput_report_key(g15->input, KEY_MUTE, data[4] & 0x20);\n\t \n\tinput_report_key(g15->input, KEY_F20, data[4] & 0x40);\n\n\tinput_sync(g15->input);\n\treturn 0;\n}\n\nstatic int lg_g510_leds_event(struct lg_g15_data *g15, u8 *data)\n{\n\tbool backlight_disabled;\n\n\t \n\tbacklight_disabled = data[1] & 0x04;\n\tif (!backlight_disabled)\n\t\tschedule_work(&g15->work);\n\n\treturn 0;\n}\n\nstatic int lg_g15_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\t\t    u8 *data, int size)\n{\n\tstruct lg_g15_data *g15 = hid_get_drvdata(hdev);\n\n\tif (!g15)\n\t\treturn 0;\n\n\tswitch (g15->model) {\n\tcase LG_G15:\n\t\tif (data[0] == 0x02 && size == 9)\n\t\t\treturn lg_g15_event(g15, data);\n\t\tbreak;\n\tcase LG_G15_V2:\n\t\tif (data[0] == 0x02 && size == 5)\n\t\t\treturn lg_g15_v2_event(g15, data);\n\t\tbreak;\n\tcase LG_Z10:\n\t\tif (data[0] == 0x02 && size == 9) {\n\t\t\tlg_g15_handle_lcd_menu_keys(g15, data);\n\t\t\tinput_sync(g15->input);\n\t\t}\n\t\tbreak;\n\tcase LG_G510:\n\tcase LG_G510_USB_AUDIO:\n\t\tif (data[0] == 0x03 && size == 5)\n\t\t\treturn lg_g510_event(g15, data);\n\t\tif (data[0] == 0x04 && size == 2)\n\t\t\treturn lg_g510_leds_event(g15, data);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int lg_g15_input_open(struct input_dev *dev)\n{\n\tstruct hid_device *hdev = input_get_drvdata(dev);\n\n\treturn hid_hw_open(hdev);\n}\n\nstatic void lg_g15_input_close(struct input_dev *dev)\n{\n\tstruct hid_device *hdev = input_get_drvdata(dev);\n\n\thid_hw_close(hdev);\n}\n\nstatic int lg_g15_register_led(struct lg_g15_data *g15, int i, const char *name)\n{\n\tg15->leds[i].led = i;\n\tg15->leds[i].cdev.name = name;\n\n\tswitch (g15->model) {\n\tcase LG_G15:\n\tcase LG_G15_V2:\n\t\tg15->leds[i].cdev.brightness_get = lg_g15_led_get;\n\t\tfallthrough;\n\tcase LG_Z10:\n\t\tg15->leds[i].cdev.brightness_set_blocking = lg_g15_led_set;\n\t\tif (i < LG_G15_BRIGHTNESS_MAX) {\n\t\t\tg15->leds[i].cdev.flags = LED_BRIGHT_HW_CHANGED;\n\t\t\tg15->leds[i].cdev.max_brightness = 2;\n\t\t} else {\n\t\t\tg15->leds[i].cdev.max_brightness = 1;\n\t\t}\n\t\tbreak;\n\tcase LG_G510:\n\tcase LG_G510_USB_AUDIO:\n\t\tswitch (i) {\n\t\tcase LG_G15_LCD_BRIGHTNESS:\n\t\t\t \n\t\t\tg15->leds[i].cdev.name = \"g15::power_on_backlight_val\";\n\t\t\tfallthrough;\n\t\tcase LG_G15_KBD_BRIGHTNESS:\n\t\t\tg15->leds[i].cdev.brightness_set_blocking =\n\t\t\t\tlg_g510_kbd_led_set;\n\t\t\tg15->leds[i].cdev.brightness_get =\n\t\t\t\tlg_g510_kbd_led_get;\n\t\t\tg15->leds[i].cdev.max_brightness = 255;\n\t\t\tg15->leds[i].cdev.groups = lg_g510_kbd_led_groups;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg15->leds[i].cdev.brightness_set_blocking =\n\t\t\t\tlg_g510_mkey_led_set;\n\t\t\tg15->leds[i].cdev.brightness_get =\n\t\t\t\tlg_g510_mkey_led_get;\n\t\t\tg15->leds[i].cdev.max_brightness = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn devm_led_classdev_register(&g15->hdev->dev, &g15->leds[i].cdev);\n}\n\n \nstatic void lg_g15_init_input_dev(struct hid_device *hdev, struct input_dev *input,\n\t\t\t\t  const char *name)\n{\n\tint i;\n\n\tinput->name = name;\n\tinput->phys = hdev->phys;\n\tinput->uniq = hdev->uniq;\n\tinput->id.bustype = hdev->bus;\n\tinput->id.vendor  = hdev->vendor;\n\tinput->id.product = hdev->product;\n\tinput->id.version = hdev->version;\n\tinput->dev.parent = &hdev->dev;\n\tinput->open = lg_g15_input_open;\n\tinput->close = lg_g15_input_close;\n\n\t \n\tfor (i = 0; i < 5; i++)\n\t\tinput_set_capability(input, EV_KEY, KEY_KBD_LCD_MENU1 + i);\n}\n\nstatic int lg_g15_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstatic const char * const led_names[] = {\n\t\t\"g15::kbd_backlight\",\n\t\t\"g15::lcd_backlight\",\n\t\t\"g15::macro_preset1\",\n\t\t\"g15::macro_preset2\",\n\t\t\"g15::macro_preset3\",\n\t\t\"g15::macro_record\",\n\t};\n\tu8 gkeys_settings_output_report = 0;\n\tu8 gkeys_settings_feature_report = 0;\n\tstruct hid_report_enum *rep_enum;\n\tunsigned int connect_mask = 0;\n\tbool has_ff000000 = false;\n\tstruct lg_g15_data *g15;\n\tstruct input_dev *input;\n\tstruct hid_report *rep;\n\tint ret, i, gkeys = 0;\n\n\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000000)\n\t\t\thas_ff000000 = true;\n\t}\n\tif (!has_ff000000)\n\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\n\tg15 = devm_kzalloc(&hdev->dev, sizeof(*g15), GFP_KERNEL);\n\tif (!g15)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&g15->mutex);\n\n\tinput = devm_input_allocate_device(&hdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tg15->hdev = hdev;\n\tg15->model = id->driver_data;\n\tg15->input = input;\n\tinput_set_drvdata(input, hdev);\n\thid_set_drvdata(hdev, (void *)g15);\n\n\tswitch (g15->model) {\n\tcase LG_G15:\n\t\tINIT_WORK(&g15->work, lg_g15_leds_changed_work);\n\t\t \n\t\tconnect_mask = HID_CONNECT_HIDRAW;\n\t\tgkeys_settings_output_report = 0x02;\n\t\tgkeys = 18;\n\t\tbreak;\n\tcase LG_G15_V2:\n\t\tINIT_WORK(&g15->work, lg_g15_leds_changed_work);\n\t\tconnect_mask = HID_CONNECT_HIDRAW;\n\t\tgkeys_settings_output_report = 0x02;\n\t\tgkeys = 6;\n\t\tbreak;\n\tcase LG_G510:\n\tcase LG_G510_USB_AUDIO:\n\t\tINIT_WORK(&g15->work, lg_g510_leds_sync_work);\n\t\tconnect_mask = HID_CONNECT_HIDINPUT | HID_CONNECT_HIDRAW;\n\t\tgkeys_settings_feature_report = 0x01;\n\t\tgkeys = 18;\n\t\tbreak;\n\tcase LG_Z10:\n\t\tconnect_mask = HID_CONNECT_HIDRAW;\n\t\tbreak;\n\t}\n\n\tret = hid_hw_start(hdev, connect_mask);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (gkeys_settings_output_report) {\n\t\tg15->transfer_buf[0] = gkeys_settings_output_report;\n\t\tmemset(g15->transfer_buf + 1, 0, gkeys);\n\t\t \n\t\tret = hid_hw_open(hdev);\n\t\tif (ret)\n\t\t\tgoto error_hw_stop;\n\t\tret = hid_hw_output_report(hdev, g15->transfer_buf, gkeys + 1);\n\t\thid_hw_close(hdev);\n\t}\n\n\tif (gkeys_settings_feature_report) {\n\t\tg15->transfer_buf[0] = gkeys_settings_feature_report;\n\t\tmemset(g15->transfer_buf + 1, 0, gkeys);\n\t\tret = hid_hw_raw_request(g15->hdev,\n\t\t\t\tgkeys_settings_feature_report,\n\t\t\t\tg15->transfer_buf, gkeys + 1,\n\t\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\t}\n\n\tif (ret < 0) {\n\t\thid_err(hdev, \"Error %d disabling keyboard emulation for the G-keys, falling back to generic hid-input driver\\n\",\n\t\t\tret);\n\t\thid_set_drvdata(hdev, NULL);\n\t\treturn 0;\n\t}\n\n\t \n\tret = lg_g15_get_initial_led_brightness(g15);\n\tif (ret)\n\t\tgoto error_hw_stop;\n\n\tif (g15->model == LG_Z10) {\n\t\tlg_g15_init_input_dev(hdev, g15->input, \"Logitech Z-10 LCD Menu Keys\");\n\t\tret = input_register_device(g15->input);\n\t\tif (ret)\n\t\t\tgoto error_hw_stop;\n\n\t\tret = lg_g15_register_led(g15, 1, \"z-10::lcd_backlight\");\n\t\tif (ret)\n\t\t\tgoto error_hw_stop;\n\n\t\treturn 0;  \n\t}\n\n\t \n\tlg_g15_init_input_dev(hdev, input, \"Logitech Gaming Keyboard Gaming Keys\");\n\n\t \n\tfor (i = 0; i < gkeys; i++)\n\t\tinput_set_capability(input, EV_KEY, KEY_MACRO1 + i);\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tinput_set_capability(input, EV_KEY, KEY_MACRO_PRESET1 + i);\n\tinput_set_capability(input, EV_KEY, KEY_MACRO_RECORD_START);\n\n\t \n\tif (g15->model == LG_G510) {\n\t\tinput_set_capability(input, EV_KEY, KEY_MUTE);\n\t\t \n\t\tinput_set_capability(input, EV_KEY, KEY_F20);\n\t}\n\n\tret = input_register_device(input);\n\tif (ret)\n\t\tgoto error_hw_stop;\n\n\t \n\tfor (i = 0; i < LG_G15_LED_MAX; i++) {\n\t\tret = lg_g15_register_led(g15, i, led_names[i]);\n\t\tif (ret)\n\t\t\tgoto error_hw_stop;\n\t}\n\n\treturn 0;\n\nerror_hw_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic const struct hid_device_id lg_g15_devices[] = {\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_G11),\n\t\t.driver_data = LG_G15 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t\t USB_DEVICE_ID_LOGITECH_G15_LCD),\n\t\t.driver_data = LG_G15 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t\t USB_DEVICE_ID_LOGITECH_G15_V2_LCD),\n\t\t.driver_data = LG_G15_V2 },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t\t USB_DEVICE_ID_LOGITECH_G510),\n\t\t.driver_data = LG_G510 },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t\t USB_DEVICE_ID_LOGITECH_G510_USB_AUDIO),\n\t\t.driver_data = LG_G510_USB_AUDIO },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t\t USB_DEVICE_ID_LOGITECH_Z_10_SPK),\n\t\t.driver_data = LG_Z10 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, lg_g15_devices);\n\nstatic struct hid_driver lg_g15_driver = {\n\t.name\t\t\t= \"lg-g15\",\n\t.id_table\t\t= lg_g15_devices,\n\t.raw_event\t\t= lg_g15_raw_event,\n\t.probe\t\t\t= lg_g15_probe,\n};\nmodule_hid_driver(lg_g15_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}