{
  "module_name": "hid-gfrm.c",
  "hash_id": "83c6ef7e368ecc8799040199a5e92207c0954f197d198ff4c58d7c3ab032bf43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-gfrm.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define GFRM100  1   \n#define GFRM200  2   \n\n#define GFRM100_SEARCH_KEY_REPORT_ID   0xF7\n#define GFRM100_SEARCH_KEY_DOWN        0x0\n#define GFRM100_SEARCH_KEY_AUDIO_DATA  0x1\n#define GFRM100_SEARCH_KEY_UP          0x2\n\nstatic u8 search_key_dn[3] = {0x40, 0x21, 0x02};\nstatic u8 search_key_up[3] = {0x40, 0x00, 0x00};\n\nstatic int gfrm_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tunsigned long hdev_type = (unsigned long) hid_get_drvdata(hdev);\n\n\tif (hdev_type == GFRM100) {\n\t\tif (usage->hid == (HID_UP_CONSUMER | 0x4)) {\n\t\t\t \n\t\t\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, KEY_INFO);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (usage->hid == (HID_UP_CONSUMER | 0x41)) {\n\t\t\t \n\t\t\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, KEY_OK);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gfrm_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\tu8 *data, int size)\n{\n\tunsigned long hdev_type = (unsigned long) hid_get_drvdata(hdev);\n\tint ret = 0;\n\n\tif (hdev_type != GFRM100)\n\t\treturn 0;\n\n\tif (size < 2 || data[0] != GFRM100_SEARCH_KEY_REPORT_ID)\n\t\treturn 0;\n\n\t \n\tswitch (data[1]) {\n\tcase GFRM100_SEARCH_KEY_DOWN:\n\t\tret = hid_report_raw_event(hdev, HID_INPUT_REPORT, search_key_dn,\n\t\t\t\t\t   sizeof(search_key_dn), 1);\n\t\tbreak;\n\n\tcase GFRM100_SEARCH_KEY_AUDIO_DATA:\n\t\tbreak;\n\n\tcase GFRM100_SEARCH_KEY_UP:\n\t\tret = hid_report_raw_event(hdev, HID_INPUT_REPORT, search_key_up,\n\t\t\t\t\t   sizeof(search_key_up), 1);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (ret < 0) ? ret : -1;\n}\n\nstatic int gfrm_input_configured(struct hid_device *hid, struct hid_input *hidinput)\n{\n\t \n\tinput_enable_softrepeat(hidinput->input, 400, 100);\n\treturn 0;\n}\n\nstatic int gfrm_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\n\thid_set_drvdata(hdev, (void *) id->driver_data);\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\tgoto done;\n\n\tif (id->driver_data == GFRM100) {\n\t\t \n\t\tif (!hid_register_report(hdev, HID_INPUT_REPORT,\n\t\t\t\t\t GFRM100_SEARCH_KEY_REPORT_ID, 0)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\ndone:\n\treturn ret;\n}\n\nstatic const struct hid_device_id gfrm_devices[] = {\n\t{ HID_BLUETOOTH_DEVICE(0x58, 0x2000),\n\t\t.driver_data = GFRM100 },\n\t{ HID_BLUETOOTH_DEVICE(0x471, 0x2210),\n\t\t.driver_data = GFRM200 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, gfrm_devices);\n\nstatic struct hid_driver gfrm_driver = {\n\t.name = \"gfrm\",\n\t.id_table = gfrm_devices,\n\t.probe = gfrm_probe,\n\t.input_mapping = gfrm_input_mapping,\n\t.raw_event = gfrm_raw_event,\n\t.input_configured = gfrm_input_configured,\n};\n\nmodule_hid_driver(gfrm_driver);\n\nMODULE_AUTHOR(\"Petri Gynther <pgynther@google.com>\");\nMODULE_DESCRIPTION(\"Google Fiber TV Box remote control driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}