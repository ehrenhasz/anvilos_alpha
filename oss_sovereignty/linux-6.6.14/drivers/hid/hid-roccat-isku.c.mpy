{
  "module_name": "hid-roccat-isku.c",
  "hash_id": "08b22c4f4d9274b630857e4ab3d9d7a3017637aaf61ff50d875f41a0234fb009",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-roccat-isku.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/hid-roccat.h>\n#include \"hid-ids.h\"\n#include \"hid-roccat-common.h\"\n#include \"hid-roccat-isku.h\"\n\nstatic void isku_profile_activated(struct isku_device *isku, uint new_profile)\n{\n\tisku->actual_profile = new_profile;\n}\n\nstatic int isku_receive(struct usb_device *usb_dev, uint command,\n\t\tvoid *buf, uint size)\n{\n\treturn roccat_common2_receive(usb_dev, command, buf, size);\n}\n\nstatic int isku_get_actual_profile(struct usb_device *usb_dev)\n{\n\tstruct isku_actual_profile buf;\n\tint retval;\n\n\tretval = isku_receive(usb_dev, ISKU_COMMAND_ACTUAL_PROFILE,\n\t\t\t&buf, sizeof(struct isku_actual_profile));\n\treturn retval ? retval : buf.actual_profile;\n}\n\nstatic int isku_set_actual_profile(struct usb_device *usb_dev, int new_profile)\n{\n\tstruct isku_actual_profile buf;\n\n\tbuf.command = ISKU_COMMAND_ACTUAL_PROFILE;\n\tbuf.size = sizeof(struct isku_actual_profile);\n\tbuf.actual_profile = new_profile;\n\treturn roccat_common2_send_with_status(usb_dev,\n\t\t\tISKU_COMMAND_ACTUAL_PROFILE, &buf,\n\t\t\tsizeof(struct isku_actual_profile));\n}\n\nstatic ssize_t isku_sysfs_show_actual_profile(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct isku_device *isku =\n\t\t\thid_get_drvdata(dev_get_drvdata(dev->parent->parent));\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", isku->actual_profile);\n}\n\nstatic ssize_t isku_sysfs_set_actual_profile(struct device *dev,\n\t\tstruct device_attribute *attr, char const *buf, size_t size)\n{\n\tstruct isku_device *isku;\n\tstruct usb_device *usb_dev;\n\tunsigned long profile;\n\tint retval;\n\tstruct isku_roccat_report roccat_report;\n\n\tdev = dev->parent->parent;\n\tisku = hid_get_drvdata(dev_get_drvdata(dev));\n\tusb_dev = interface_to_usbdev(to_usb_interface(dev));\n\n\tretval = kstrtoul(buf, 10, &profile);\n\tif (retval)\n\t\treturn retval;\n\n\tif (profile > 4)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&isku->isku_lock);\n\n\tretval = isku_set_actual_profile(usb_dev, profile);\n\tif (retval) {\n\t\tmutex_unlock(&isku->isku_lock);\n\t\treturn retval;\n\t}\n\n\tisku_profile_activated(isku, profile);\n\n\troccat_report.event = ISKU_REPORT_BUTTON_EVENT_PROFILE;\n\troccat_report.data1 = profile + 1;\n\troccat_report.data2 = 0;\n\troccat_report.profile = profile + 1;\n\troccat_report_event(isku->chrdev_minor, (uint8_t const *)&roccat_report);\n\n\tmutex_unlock(&isku->isku_lock);\n\n\treturn size;\n}\nstatic DEVICE_ATTR(actual_profile, 0660, isku_sysfs_show_actual_profile,\n\t\t   isku_sysfs_set_actual_profile);\n\nstatic struct attribute *isku_attrs[] = {\n\t&dev_attr_actual_profile.attr,\n\tNULL,\n};\n\nstatic ssize_t isku_sysfs_read(struct file *fp, struct kobject *kobj,\n\t\tchar *buf, loff_t off, size_t count,\n\t\tsize_t real_size, uint command)\n{\n\tstruct device *dev = kobj_to_dev(kobj)->parent->parent;\n\tstruct isku_device *isku = hid_get_drvdata(dev_get_drvdata(dev));\n\tstruct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));\n\tint retval;\n\n\tif (off >= real_size)\n\t\treturn 0;\n\n\tif (off != 0 || count > real_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&isku->isku_lock);\n\tretval = isku_receive(usb_dev, command, buf, count);\n\tmutex_unlock(&isku->isku_lock);\n\n\treturn retval ? retval : count;\n}\n\nstatic ssize_t isku_sysfs_write(struct file *fp, struct kobject *kobj,\n\t\tvoid const *buf, loff_t off, size_t count,\n\t\tsize_t real_size, uint command)\n{\n\tstruct device *dev = kobj_to_dev(kobj)->parent->parent;\n\tstruct isku_device *isku = hid_get_drvdata(dev_get_drvdata(dev));\n\tstruct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));\n\tint retval;\n\n\tif (off != 0 || count > real_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&isku->isku_lock);\n\tretval = roccat_common2_send_with_status(usb_dev, command,\n\t\t\t(void *)buf, count);\n\tmutex_unlock(&isku->isku_lock);\n\n\treturn retval ? retval : count;\n}\n\n#define ISKU_SYSFS_W(thingy, THINGY) \\\nstatic ssize_t isku_sysfs_write_ ## thingy(struct file *fp, struct kobject *kobj, \\\n\t\tstruct bin_attribute *attr, char *buf, \\\n\t\tloff_t off, size_t count) \\\n{ \\\n\treturn isku_sysfs_write(fp, kobj, buf, off, count, \\\n\t\t\tISKU_SIZE_ ## THINGY, ISKU_COMMAND_ ## THINGY); \\\n}\n\n#define ISKU_SYSFS_R(thingy, THINGY) \\\nstatic ssize_t isku_sysfs_read_ ## thingy(struct file *fp, struct kobject *kobj, \\\n\t\tstruct bin_attribute *attr, char *buf, \\\n\t\tloff_t off, size_t count) \\\n{ \\\n\treturn isku_sysfs_read(fp, kobj, buf, off, count, \\\n\t\t\tISKU_SIZE_ ## THINGY, ISKU_COMMAND_ ## THINGY); \\\n}\n\n#define ISKU_SYSFS_RW(thingy, THINGY) \\\nISKU_SYSFS_R(thingy, THINGY) \\\nISKU_SYSFS_W(thingy, THINGY)\n\n#define ISKU_BIN_ATTR_RW(thingy, THINGY) \\\nISKU_SYSFS_RW(thingy, THINGY); \\\nstatic struct bin_attribute bin_attr_##thingy = { \\\n\t.attr = { .name = #thingy, .mode = 0660 }, \\\n\t.size = ISKU_SIZE_ ## THINGY, \\\n\t.read = isku_sysfs_read_ ## thingy, \\\n\t.write = isku_sysfs_write_ ## thingy \\\n}\n\n#define ISKU_BIN_ATTR_R(thingy, THINGY) \\\nISKU_SYSFS_R(thingy, THINGY); \\\nstatic struct bin_attribute bin_attr_##thingy = { \\\n\t.attr = { .name = #thingy, .mode = 0440 }, \\\n\t.size = ISKU_SIZE_ ## THINGY, \\\n\t.read = isku_sysfs_read_ ## thingy, \\\n}\n\n#define ISKU_BIN_ATTR_W(thingy, THINGY) \\\nISKU_SYSFS_W(thingy, THINGY); \\\nstatic struct bin_attribute bin_attr_##thingy = { \\\n\t.attr = { .name = #thingy, .mode = 0220 }, \\\n\t.size = ISKU_SIZE_ ## THINGY, \\\n\t.write = isku_sysfs_write_ ## thingy \\\n}\n\nISKU_BIN_ATTR_RW(macro, MACRO);\nISKU_BIN_ATTR_RW(keys_function, KEYS_FUNCTION);\nISKU_BIN_ATTR_RW(keys_easyzone, KEYS_EASYZONE);\nISKU_BIN_ATTR_RW(keys_media, KEYS_MEDIA);\nISKU_BIN_ATTR_RW(keys_thumbster, KEYS_THUMBSTER);\nISKU_BIN_ATTR_RW(keys_macro, KEYS_MACRO);\nISKU_BIN_ATTR_RW(keys_capslock, KEYS_CAPSLOCK);\nISKU_BIN_ATTR_RW(light, LIGHT);\nISKU_BIN_ATTR_RW(key_mask, KEY_MASK);\nISKU_BIN_ATTR_RW(last_set, LAST_SET);\nISKU_BIN_ATTR_W(talk, TALK);\nISKU_BIN_ATTR_W(talkfx, TALKFX);\nISKU_BIN_ATTR_W(control, CONTROL);\nISKU_BIN_ATTR_W(reset, RESET);\nISKU_BIN_ATTR_R(info, INFO);\n\nstatic struct bin_attribute *isku_bin_attributes[] = {\n\t&bin_attr_macro,\n\t&bin_attr_keys_function,\n\t&bin_attr_keys_easyzone,\n\t&bin_attr_keys_media,\n\t&bin_attr_keys_thumbster,\n\t&bin_attr_keys_macro,\n\t&bin_attr_keys_capslock,\n\t&bin_attr_light,\n\t&bin_attr_key_mask,\n\t&bin_attr_last_set,\n\t&bin_attr_talk,\n\t&bin_attr_talkfx,\n\t&bin_attr_control,\n\t&bin_attr_reset,\n\t&bin_attr_info,\n\tNULL,\n};\n\nstatic const struct attribute_group isku_group = {\n\t.attrs = isku_attrs,\n\t.bin_attrs = isku_bin_attributes,\n};\n\nstatic const struct attribute_group *isku_groups[] = {\n\t&isku_group,\n\tNULL,\n};\n\nstatic const struct class isku_class = {\n\t.name = \"isku\",\n\t.dev_groups = isku_groups,\n};\n\nstatic int isku_init_isku_device_struct(struct usb_device *usb_dev,\n\t\tstruct isku_device *isku)\n{\n\tint retval;\n\n\tmutex_init(&isku->isku_lock);\n\n\tretval = isku_get_actual_profile(usb_dev);\n\tif (retval < 0)\n\t\treturn retval;\n\tisku_profile_activated(isku, retval);\n\n\treturn 0;\n}\n\nstatic int isku_init_specials(struct hid_device *hdev)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct isku_device *isku;\n\tint retval;\n\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol\n\t\t\t!= ISKU_USB_INTERFACE_PROTOCOL) {\n\t\thid_set_drvdata(hdev, NULL);\n\t\treturn 0;\n\t}\n\n\tisku = kzalloc(sizeof(*isku), GFP_KERNEL);\n\tif (!isku) {\n\t\thid_err(hdev, \"can't alloc device descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, isku);\n\n\tretval = isku_init_isku_device_struct(usb_dev, isku);\n\tif (retval) {\n\t\thid_err(hdev, \"couldn't init struct isku_device\\n\");\n\t\tgoto exit_free;\n\t}\n\n\tretval = roccat_connect(&isku_class, hdev,\n\t\t\tsizeof(struct isku_roccat_report));\n\tif (retval < 0) {\n\t\thid_err(hdev, \"couldn't init char dev\\n\");\n\t} else {\n\t\tisku->chrdev_minor = retval;\n\t\tisku->roccat_claimed = 1;\n\t}\n\n\treturn 0;\nexit_free:\n\tkfree(isku);\n\treturn retval;\n}\n\nstatic void isku_remove_specials(struct hid_device *hdev)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct isku_device *isku;\n\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol\n\t\t\t!= ISKU_USB_INTERFACE_PROTOCOL)\n\t\treturn;\n\n\tisku = hid_get_drvdata(hdev);\n\tif (isku->roccat_claimed)\n\t\troccat_disconnect(isku->chrdev_minor);\n\tkfree(isku);\n}\n\nstatic int isku_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint retval;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (retval) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tretval = isku_init_specials(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"couldn't install keyboard\\n\");\n\t\tgoto exit_stop;\n\t}\n\n\treturn 0;\n\nexit_stop:\n\thid_hw_stop(hdev);\nexit:\n\treturn retval;\n}\n\nstatic void isku_remove(struct hid_device *hdev)\n{\n\tisku_remove_specials(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic void isku_keep_values_up_to_date(struct isku_device *isku,\n\t\tu8 const *data)\n{\n\tstruct isku_report_button const *button_report;\n\n\tswitch (data[0]) {\n\tcase ISKU_REPORT_NUMBER_BUTTON:\n\t\tbutton_report = (struct isku_report_button const *)data;\n\t\tswitch (button_report->event) {\n\t\tcase ISKU_REPORT_BUTTON_EVENT_PROFILE:\n\t\t\tisku_profile_activated(isku, button_report->data1 - 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void isku_report_to_chrdev(struct isku_device const *isku,\n\t\tu8 const *data)\n{\n\tstruct isku_roccat_report roccat_report;\n\tstruct isku_report_button const *button_report;\n\n\tif (data[0] != ISKU_REPORT_NUMBER_BUTTON)\n\t\treturn;\n\n\tbutton_report = (struct isku_report_button const *)data;\n\n\troccat_report.event = button_report->event;\n\troccat_report.data1 = button_report->data1;\n\troccat_report.data2 = button_report->data2;\n\troccat_report.profile = isku->actual_profile + 1;\n\troccat_report_event(isku->chrdev_minor,\n\t\t\t(uint8_t const *)&roccat_report);\n}\n\nstatic int isku_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct isku_device *isku = hid_get_drvdata(hdev);\n\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol\n\t\t\t!= ISKU_USB_INTERFACE_PROTOCOL)\n\t\treturn 0;\n\n\tif (isku == NULL)\n\t\treturn 0;\n\n\tisku_keep_values_up_to_date(isku, data);\n\n\tif (isku->roccat_claimed)\n\t\tisku_report_to_chrdev(isku, data);\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id isku_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKU) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKUFX) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(hid, isku_devices);\n\nstatic struct hid_driver isku_driver = {\n\t\t.name = \"isku\",\n\t\t.id_table = isku_devices,\n\t\t.probe = isku_probe,\n\t\t.remove = isku_remove,\n\t\t.raw_event = isku_raw_event\n};\n\nstatic int __init isku_init(void)\n{\n\tint retval;\n\n\tretval = class_register(&isku_class);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = hid_register_driver(&isku_driver);\n\tif (retval)\n\t\tclass_unregister(&isku_class);\n\treturn retval;\n}\n\nstatic void __exit isku_exit(void)\n{\n\thid_unregister_driver(&isku_driver);\n\tclass_unregister(&isku_class);\n}\n\nmodule_init(isku_init);\nmodule_exit(isku_exit);\n\nMODULE_AUTHOR(\"Stefan Achatz\");\nMODULE_DESCRIPTION(\"USB Roccat Isku/FX driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}