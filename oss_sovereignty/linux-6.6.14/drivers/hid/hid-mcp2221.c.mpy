{
  "module_name": "hid-mcp2221.c",
  "hash_id": "92b6637ae441e7dff9fc4d2ffda4b8991bd4fa86d5c4b244bac2555ad2709449",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-mcp2221.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/hid.h>\n#include <linux/hidraw.h>\n#include <linux/i2c.h>\n#include <linux/gpio/driver.h>\n#include <linux/iio/iio.h>\n#include \"hid-ids.h\"\n\n \nenum {\n\tMCP2221_I2C_WR_DATA = 0x90,\n\tMCP2221_I2C_WR_NO_STOP = 0x94,\n\tMCP2221_I2C_RD_DATA = 0x91,\n\tMCP2221_I2C_RD_RPT_START = 0x93,\n\tMCP2221_I2C_GET_DATA = 0x40,\n\tMCP2221_I2C_PARAM_OR_STATUS\t= 0x10,\n\tMCP2221_I2C_SET_SPEED = 0x20,\n\tMCP2221_I2C_CANCEL = 0x10,\n\tMCP2221_GPIO_SET = 0x50,\n\tMCP2221_GPIO_GET = 0x51,\n\tMCP2221_SET_SRAM_SETTINGS = 0x60,\n\tMCP2221_GET_SRAM_SETTINGS = 0x61,\n\tMCP2221_READ_FLASH_DATA = 0xb0,\n};\n\n \nenum {\n\tMCP2221_SUCCESS = 0x00,\n\tMCP2221_I2C_ENG_BUSY = 0x01,\n\tMCP2221_I2C_START_TOUT = 0x12,\n\tMCP2221_I2C_STOP_TOUT = 0x62,\n\tMCP2221_I2C_WRADDRL_TOUT = 0x23,\n\tMCP2221_I2C_WRDATA_TOUT = 0x44,\n\tMCP2221_I2C_WRADDRL_NACK = 0x25,\n\tMCP2221_I2C_MASK_ADDR_NACK = 0x40,\n\tMCP2221_I2C_WRADDRL_SEND = 0x21,\n\tMCP2221_I2C_ADDR_NACK = 0x25,\n\tMCP2221_I2C_READ_COMPL = 0x55,\n\tMCP2221_ALT_F_NOT_GPIOV = 0xEE,\n\tMCP2221_ALT_F_NOT_GPIOD = 0xEF,\n};\n\n \nenum {\n\tMCP2221_DIR_OUT = 0x00,\n\tMCP2221_DIR_IN = 0x01,\n};\n\n#define MCP_NGPIO\t4\n\n \nstruct mcp_set_gpio {\n\tu8 cmd;\n\tu8 dummy;\n\tstruct {\n\t\tu8 change_value;\n\t\tu8 value;\n\t\tu8 change_direction;\n\t\tu8 direction;\n\t} gpio[MCP_NGPIO];\n} __packed;\n\n \nstruct mcp_get_gpio {\n\tu8 cmd;\n\tu8 dummy;\n\tstruct {\n\t\tu8 value;\n\t\tu8 direction;\n\t} gpio[MCP_NGPIO];\n} __packed;\n\n \nstruct mcp2221 {\n\tstruct hid_device *hdev;\n\tstruct i2c_adapter adapter;\n\tstruct mutex lock;\n\tstruct completion wait_in_report;\n\tstruct delayed_work init_work;\n\tu8 *rxbuf;\n\tu8 txbuf[64];\n\tint rxbuf_idx;\n\tint status;\n\tu8 cur_i2c_clk_div;\n\tstruct gpio_chip *gc;\n\tu8 gp_idx;\n\tu8 gpio_dir;\n\tu8 mode[4];\n#if IS_REACHABLE(CONFIG_IIO)\n\tstruct iio_chan_spec iio_channels[3];\n\tu16 adc_values[3];\n\tu8 adc_scale;\n\tu8 dac_value;\n\tu16 dac_scale;\n#endif\n};\n\nstruct mcp2221_iio {\n\tstruct mcp2221 *mcp;\n};\n\n \nstatic uint i2c_clk_freq = 400;\n\n \nstatic int mcp_send_report(struct mcp2221 *mcp,\n\t\t\t\t\tu8 *out_report, size_t len)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(out_report, len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = hid_hw_output_report(mcp->hdev, buf, len);\n\tkfree(buf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\n \nstatic int mcp_send_data_req_status(struct mcp2221 *mcp,\n\t\t\tu8 *out_report, int len)\n{\n\tint ret;\n\tunsigned long t;\n\n\treinit_completion(&mcp->wait_in_report);\n\n\tret = mcp_send_report(mcp, out_report, len);\n\tif (ret)\n\t\treturn ret;\n\n\tt = wait_for_completion_timeout(&mcp->wait_in_report,\n\t\t\t\t\t\t\tmsecs_to_jiffies(4000));\n\tif (!t)\n\t\treturn -ETIMEDOUT;\n\n\treturn mcp->status;\n}\n\n \nstatic int mcp_chk_last_cmd_status(struct mcp2221 *mcp)\n{\n\tmemset(mcp->txbuf, 0, 8);\n\tmcp->txbuf[0] = MCP2221_I2C_PARAM_OR_STATUS;\n\n\treturn mcp_send_data_req_status(mcp, mcp->txbuf, 8);\n}\n\n \nstatic int mcp_cancel_last_cmd(struct mcp2221 *mcp)\n{\n\tmemset(mcp->txbuf, 0, 8);\n\tmcp->txbuf[0] = MCP2221_I2C_PARAM_OR_STATUS;\n\tmcp->txbuf[2] = MCP2221_I2C_CANCEL;\n\n\treturn mcp_send_data_req_status(mcp, mcp->txbuf, 8);\n}\n\nstatic int mcp_set_i2c_speed(struct mcp2221 *mcp)\n{\n\tint ret;\n\n\tmemset(mcp->txbuf, 0, 8);\n\tmcp->txbuf[0] = MCP2221_I2C_PARAM_OR_STATUS;\n\tmcp->txbuf[3] = MCP2221_I2C_SET_SPEED;\n\tmcp->txbuf[4] = mcp->cur_i2c_clk_div;\n\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 8);\n\tif (ret) {\n\t\t \n\t\tusleep_range(980, 1000);\n\t\tmcp_cancel_last_cmd(mcp);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mcp_i2c_write(struct mcp2221 *mcp,\n\t\t\t\tstruct i2c_msg *msg, int type, u8 last_status)\n{\n\tint ret, len, idx, sent;\n\n\tidx = 0;\n\tsent  = 0;\n\tif (msg->len < 60)\n\t\tlen = msg->len;\n\telse\n\t\tlen = 60;\n\n\tdo {\n\t\tmcp->txbuf[0] = type;\n\t\tmcp->txbuf[1] = msg->len & 0xff;\n\t\tmcp->txbuf[2] = msg->len >> 8;\n\t\tmcp->txbuf[3] = (u8)(msg->addr << 1);\n\n\t\tmemcpy(&mcp->txbuf[4], &msg->buf[idx], len);\n\n\t\tret = mcp_send_data_req_status(mcp, mcp->txbuf, len + 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tusleep_range(980, 1000);\n\n\t\tif (last_status) {\n\t\t\tret = mcp_chk_last_cmd_status(mcp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tsent = sent + len;\n\t\tif (sent >= msg->len)\n\t\t\tbreak;\n\n\t\tidx = idx + len;\n\t\tif ((msg->len - sent) < 60)\n\t\t\tlen = msg->len - sent;\n\t\telse\n\t\t\tlen = 60;\n\n\t\t \n\t\tusleep_range(980, 1000);\n\t} while (len > 0);\n\n\treturn ret;\n}\n\n \nstatic int mcp_i2c_smbus_read(struct mcp2221 *mcp,\n\t\t\t\tstruct i2c_msg *msg, int type, u16 smbus_addr,\n\t\t\t\tu8 smbus_len, u8 *smbus_buf)\n{\n\tint ret;\n\tu16 total_len;\n\n\tmcp->txbuf[0] = type;\n\tif (msg) {\n\t\tmcp->txbuf[1] = msg->len & 0xff;\n\t\tmcp->txbuf[2] = msg->len >> 8;\n\t\tmcp->txbuf[3] = (u8)(msg->addr << 1);\n\t\ttotal_len = msg->len;\n\t\tmcp->rxbuf = msg->buf;\n\t} else {\n\t\tmcp->txbuf[1] = smbus_len;\n\t\tmcp->txbuf[2] = 0;\n\t\tmcp->txbuf[3] = (u8)(smbus_addr << 1);\n\t\ttotal_len = smbus_len;\n\t\tmcp->rxbuf = smbus_buf;\n\t}\n\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 4);\n\tif (ret)\n\t\treturn ret;\n\n\tmcp->rxbuf_idx = 0;\n\n\tdo {\n\t\tmemset(mcp->txbuf, 0, 4);\n\t\tmcp->txbuf[0] = MCP2221_I2C_GET_DATA;\n\n\t\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mcp_chk_last_cmd_status(mcp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tusleep_range(980, 1000);\n\t} while (mcp->rxbuf_idx < total_len);\n\n\treturn ret;\n}\n\nstatic int mcp_i2c_xfer(struct i2c_adapter *adapter,\n\t\t\t\tstruct i2c_msg msgs[], int num)\n{\n\tint ret;\n\tstruct mcp2221 *mcp = i2c_get_adapdata(adapter);\n\n\thid_hw_power(mcp->hdev, PM_HINT_FULLON);\n\n\tmutex_lock(&mcp->lock);\n\n\t \n\tret = mcp_set_i2c_speed(mcp);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (num == 1) {\n\t\tif (msgs->flags & I2C_M_RD) {\n\t\t\tret = mcp_i2c_smbus_read(mcp, msgs, MCP2221_I2C_RD_DATA,\n\t\t\t\t\t\t\t0, 0, NULL);\n\t\t} else {\n\t\t\tret = mcp_i2c_write(mcp, msgs, MCP2221_I2C_WR_DATA, 1);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto exit;\n\t\tret = num;\n\t} else if (num == 2) {\n\t\t \n\t\tif (msgs[0].addr == msgs[1].addr &&\n\t\t\t!(msgs[0].flags & I2C_M_RD) &&\n\t\t\t (msgs[1].flags & I2C_M_RD)) {\n\n\t\t\tret = mcp_i2c_write(mcp, &msgs[0],\n\t\t\t\t\t\tMCP2221_I2C_WR_NO_STOP, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\n\t\t\tret = mcp_i2c_smbus_read(mcp, &msgs[1],\n\t\t\t\t\t\tMCP2221_I2C_RD_RPT_START,\n\t\t\t\t\t\t0, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\tret = num;\n\t\t} else {\n\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\"unsupported multi-msg i2c transaction\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t}\n\t} else {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"unsupported multi-msg i2c transaction\\n\");\n\t\tret = -EOPNOTSUPP;\n\t}\n\nexit:\n\thid_hw_power(mcp->hdev, PM_HINT_NORMAL);\n\tmutex_unlock(&mcp->lock);\n\treturn ret;\n}\n\nstatic int mcp_smbus_write(struct mcp2221 *mcp, u16 addr,\n\t\t\t\tu8 command, u8 *buf, u8 len, int type,\n\t\t\t\tu8 last_status)\n{\n\tint data_len, ret;\n\n\tmcp->txbuf[0] = type;\n\tmcp->txbuf[1] = len + 1;  \n\tmcp->txbuf[2] = 0;\n\tmcp->txbuf[3] = (u8)(addr << 1);\n\tmcp->txbuf[4] = command;\n\n\tswitch (len) {\n\tcase 0:\n\t\tdata_len = 5;\n\t\tbreak;\n\tcase 1:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tdata_len = 6;\n\t\tbreak;\n\tcase 2:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tmcp->txbuf[6] = buf[1];\n\t\tdata_len = 7;\n\t\tbreak;\n\tdefault:\n\t\tif (len > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&mcp->txbuf[5], buf, len);\n\t\tdata_len = len + 5;\n\t}\n\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, data_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (last_status) {\n\t\tusleep_range(980, 1000);\n\n\t\tret = mcp_chk_last_cmd_status(mcp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int mcp_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t\t\tunsigned short flags, char read_write,\n\t\t\t\tu8 command, int size,\n\t\t\t\tunion i2c_smbus_data *data)\n{\n\tint ret;\n\tstruct mcp2221 *mcp = i2c_get_adapdata(adapter);\n\n\thid_hw_power(mcp->hdev, PM_HINT_FULLON);\n\n\tmutex_lock(&mcp->lock);\n\n\tret = mcp_set_i2c_speed(mcp);\n\tif (ret)\n\t\tgoto exit;\n\n\tswitch (size) {\n\n\tcase I2C_SMBUS_QUICK:\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\tret = mcp_i2c_smbus_read(mcp, NULL, MCP2221_I2C_RD_DATA,\n\t\t\t\t\t\taddr, 0, &data->byte);\n\t\telse\n\t\t\tret = mcp_smbus_write(mcp, addr, command, NULL,\n\t\t\t\t\t\t0, MCP2221_I2C_WR_DATA, 1);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\tret = mcp_i2c_smbus_read(mcp, NULL, MCP2221_I2C_RD_DATA,\n\t\t\t\t\t\taddr, 1, &data->byte);\n\t\telse\n\t\t\tret = mcp_smbus_write(mcp, addr, command, NULL,\n\t\t\t\t\t\t0, MCP2221_I2C_WR_DATA, 1);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = mcp_smbus_write(mcp, addr, command, NULL,\n\t\t\t\t\t\t0, MCP2221_I2C_WR_NO_STOP, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\n\t\t\tret = mcp_i2c_smbus_read(mcp, NULL,\n\t\t\t\t\t\tMCP2221_I2C_RD_RPT_START,\n\t\t\t\t\t\taddr, 1, &data->byte);\n\t\t} else {\n\t\t\tret = mcp_smbus_write(mcp, addr, command, &data->byte,\n\t\t\t\t\t\t1, MCP2221_I2C_WR_DATA, 1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = mcp_smbus_write(mcp, addr, command, NULL,\n\t\t\t\t\t\t0, MCP2221_I2C_WR_NO_STOP, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\n\t\t\tret = mcp_i2c_smbus_read(mcp, NULL,\n\t\t\t\t\t\tMCP2221_I2C_RD_RPT_START,\n\t\t\t\t\t\taddr, 2, (u8 *)&data->word);\n\t\t} else {\n\t\t\tret = mcp_smbus_write(mcp, addr, command,\n\t\t\t\t\t\t(u8 *)&data->word, 2,\n\t\t\t\t\t\tMCP2221_I2C_WR_DATA, 1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = mcp_smbus_write(mcp, addr, command, NULL,\n\t\t\t\t\t\t0, MCP2221_I2C_WR_NO_STOP, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\n\t\t\tmcp->rxbuf_idx = 0;\n\t\t\tmcp->rxbuf = data->block;\n\t\t\tmcp->txbuf[0] = MCP2221_I2C_GET_DATA;\n\t\t\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tif (!data->block[0]) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tret = mcp_smbus_write(mcp, addr, command, data->block,\n\t\t\t\t\t\tdata->block[0] + 1,\n\t\t\t\t\t\tMCP2221_I2C_WR_DATA, 1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = mcp_smbus_write(mcp, addr, command, NULL,\n\t\t\t\t\t\t0, MCP2221_I2C_WR_NO_STOP, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\n\t\t\tmcp->rxbuf_idx = 0;\n\t\t\tmcp->rxbuf = data->block;\n\t\t\tmcp->txbuf[0] = MCP2221_I2C_GET_DATA;\n\t\t\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tif (!data->block[0]) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tret = mcp_smbus_write(mcp, addr, command,\n\t\t\t\t\t\t&data->block[1], data->block[0],\n\t\t\t\t\t\tMCP2221_I2C_WR_DATA, 1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tret = mcp_smbus_write(mcp, addr, command,\n\t\t\t\t\t\t(u8 *)&data->word,\n\t\t\t\t\t\t2, MCP2221_I2C_WR_NO_STOP, 0);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tret = mcp_i2c_smbus_read(mcp, NULL,\n\t\t\t\t\t\tMCP2221_I2C_RD_RPT_START,\n\t\t\t\t\t\taddr, 2, (u8 *)&data->word);\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tret = mcp_smbus_write(mcp, addr, command, data->block,\n\t\t\t\t\t\tdata->block[0] + 1,\n\t\t\t\t\t\tMCP2221_I2C_WR_NO_STOP, 0);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tret = mcp_i2c_smbus_read(mcp, NULL,\n\t\t\t\t\t\tMCP2221_I2C_RD_RPT_START,\n\t\t\t\t\t\taddr, I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t\tdata->block);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&mcp->adapter.dev,\n\t\t\t\"unsupported smbus transaction size:%d\\n\", size);\n\t\tret = -EOPNOTSUPP;\n\t}\n\nexit:\n\thid_hw_power(mcp->hdev, PM_HINT_NORMAL);\n\tmutex_unlock(&mcp->lock);\n\treturn ret;\n}\n\nstatic u32 mcp_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C |\n\t\t\tI2C_FUNC_SMBUS_READ_BLOCK_DATA |\n\t\t\tI2C_FUNC_SMBUS_BLOCK_PROC_CALL |\n\t\t\t(I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_PEC);\n}\n\nstatic const struct i2c_algorithm mcp_i2c_algo = {\n\t.master_xfer = mcp_i2c_xfer,\n\t.smbus_xfer = mcp_smbus_xfer,\n\t.functionality = mcp_i2c_func,\n};\n\n#if IS_REACHABLE(CONFIG_GPIOLIB)\nstatic int mcp_gpio_get(struct gpio_chip *gc,\n\t\t\t\tunsigned int offset)\n{\n\tint ret;\n\tstruct mcp2221 *mcp = gpiochip_get_data(gc);\n\n\tmcp->txbuf[0] = MCP2221_GPIO_GET;\n\n\tmcp->gp_idx = offsetof(struct mcp_get_gpio, gpio[offset]);\n\n\tmutex_lock(&mcp->lock);\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 1);\n\tmutex_unlock(&mcp->lock);\n\n\treturn ret;\n}\n\nstatic void mcp_gpio_set(struct gpio_chip *gc,\n\t\t\t\tunsigned int offset, int value)\n{\n\tstruct mcp2221 *mcp = gpiochip_get_data(gc);\n\n\tmemset(mcp->txbuf, 0, 18);\n\tmcp->txbuf[0] = MCP2221_GPIO_SET;\n\n\tmcp->gp_idx = offsetof(struct mcp_set_gpio, gpio[offset].value);\n\n\tmcp->txbuf[mcp->gp_idx - 1] = 1;\n\tmcp->txbuf[mcp->gp_idx] = !!value;\n\n\tmutex_lock(&mcp->lock);\n\tmcp_send_data_req_status(mcp, mcp->txbuf, 18);\n\tmutex_unlock(&mcp->lock);\n}\n\nstatic int mcp_gpio_dir_set(struct mcp2221 *mcp,\n\t\t\t\tunsigned int offset, u8 val)\n{\n\tmemset(mcp->txbuf, 0, 18);\n\tmcp->txbuf[0] = MCP2221_GPIO_SET;\n\n\tmcp->gp_idx = offsetof(struct mcp_set_gpio, gpio[offset].direction);\n\n\tmcp->txbuf[mcp->gp_idx - 1] = 1;\n\tmcp->txbuf[mcp->gp_idx] = val;\n\n\treturn mcp_send_data_req_status(mcp, mcp->txbuf, 18);\n}\n\nstatic int mcp_gpio_direction_input(struct gpio_chip *gc,\n\t\t\t\tunsigned int offset)\n{\n\tint ret;\n\tstruct mcp2221 *mcp = gpiochip_get_data(gc);\n\n\tmutex_lock(&mcp->lock);\n\tret = mcp_gpio_dir_set(mcp, offset, MCP2221_DIR_IN);\n\tmutex_unlock(&mcp->lock);\n\n\treturn ret;\n}\n\nstatic int mcp_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\tunsigned int offset, int value)\n{\n\tint ret;\n\tstruct mcp2221 *mcp = gpiochip_get_data(gc);\n\n\tmutex_lock(&mcp->lock);\n\tret = mcp_gpio_dir_set(mcp, offset, MCP2221_DIR_OUT);\n\tmutex_unlock(&mcp->lock);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tmcp_gpio_set(gc, offset, value);\n\n\treturn 0;\n}\n\nstatic int mcp_gpio_get_direction(struct gpio_chip *gc,\n\t\t\t\tunsigned int offset)\n{\n\tint ret;\n\tstruct mcp2221 *mcp = gpiochip_get_data(gc);\n\n\tmcp->txbuf[0] = MCP2221_GPIO_GET;\n\n\tmcp->gp_idx = offsetof(struct mcp_get_gpio, gpio[offset]);\n\n\tmutex_lock(&mcp->lock);\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 1);\n\tmutex_unlock(&mcp->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mcp->gpio_dir == MCP2221_DIR_IN)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n#endif\n\n \nstatic int mcp_get_i2c_eng_state(struct mcp2221 *mcp,\n\t\t\t\tu8 *data, u8 idx)\n{\n\tint ret;\n\n\tswitch (data[idx]) {\n\tcase MCP2221_I2C_WRADDRL_NACK:\n\tcase MCP2221_I2C_WRADDRL_SEND:\n\t\tret = -ENXIO;\n\t\tbreak;\n\tcase MCP2221_I2C_START_TOUT:\n\tcase MCP2221_I2C_STOP_TOUT:\n\tcase MCP2221_I2C_WRADDRL_TOUT:\n\tcase MCP2221_I2C_WRDATA_TOUT:\n\t\tret = -ETIMEDOUT;\n\t\tbreak;\n\tcase MCP2221_I2C_ENG_BUSY:\n\t\tret = -EAGAIN;\n\t\tbreak;\n\tcase MCP2221_SUCCESS:\n\t\tret = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int mcp2221_raw_event(struct hid_device *hdev,\n\t\t\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tu8 *buf;\n\tstruct mcp2221 *mcp = hid_get_drvdata(hdev);\n\n\tswitch (data[0]) {\n\n\tcase MCP2221_I2C_WR_DATA:\n\tcase MCP2221_I2C_WR_NO_STOP:\n\tcase MCP2221_I2C_RD_DATA:\n\tcase MCP2221_I2C_RD_RPT_START:\n\t\tswitch (data[1]) {\n\t\tcase MCP2221_SUCCESS:\n\t\t\tmcp->status = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcp->status = mcp_get_i2c_eng_state(mcp, data, 2);\n\t\t}\n\t\tcomplete(&mcp->wait_in_report);\n\t\tbreak;\n\n\tcase MCP2221_I2C_PARAM_OR_STATUS:\n\t\tswitch (data[1]) {\n\t\tcase MCP2221_SUCCESS:\n\t\t\tif ((mcp->txbuf[3] == MCP2221_I2C_SET_SPEED) &&\n\t\t\t\t(data[3] != MCP2221_I2C_SET_SPEED)) {\n\t\t\t\tmcp->status = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (data[20] & MCP2221_I2C_MASK_ADDR_NACK) {\n\t\t\t\tmcp->status = -ENXIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmcp->status = mcp_get_i2c_eng_state(mcp, data, 8);\n#if IS_REACHABLE(CONFIG_IIO)\n\t\t\tmemcpy(&mcp->adc_values, &data[50], sizeof(mcp->adc_values));\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcp->status = -EIO;\n\t\t}\n\t\tcomplete(&mcp->wait_in_report);\n\t\tbreak;\n\n\tcase MCP2221_I2C_GET_DATA:\n\t\tswitch (data[1]) {\n\t\tcase MCP2221_SUCCESS:\n\t\t\tif (data[2] == MCP2221_I2C_ADDR_NACK) {\n\t\t\t\tmcp->status = -ENXIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!mcp_get_i2c_eng_state(mcp, data, 2)\n\t\t\t\t&& (data[3] == 0)) {\n\t\t\t\tmcp->status = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (data[3] == 127) {\n\t\t\t\tmcp->status = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (data[2] == MCP2221_I2C_READ_COMPL) {\n\t\t\t\tbuf = mcp->rxbuf;\n\t\t\t\tmemcpy(&buf[mcp->rxbuf_idx], &data[4], data[3]);\n\t\t\t\tmcp->rxbuf_idx = mcp->rxbuf_idx + data[3];\n\t\t\t\tmcp->status = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmcp->status = -EIO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcp->status = -EIO;\n\t\t}\n\t\tcomplete(&mcp->wait_in_report);\n\t\tbreak;\n\n\tcase MCP2221_GPIO_GET:\n\t\tswitch (data[1]) {\n\t\tcase MCP2221_SUCCESS:\n\t\t\tif ((data[mcp->gp_idx] == MCP2221_ALT_F_NOT_GPIOV) ||\n\t\t\t\t(data[mcp->gp_idx + 1] == MCP2221_ALT_F_NOT_GPIOD)) {\n\t\t\t\tmcp->status = -ENOENT;\n\t\t\t} else {\n\t\t\t\tmcp->status = !!data[mcp->gp_idx];\n\t\t\t\tmcp->gpio_dir = data[mcp->gp_idx + 1];\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcp->status = -EAGAIN;\n\t\t}\n\t\tcomplete(&mcp->wait_in_report);\n\t\tbreak;\n\n\tcase MCP2221_GPIO_SET:\n\t\tswitch (data[1]) {\n\t\tcase MCP2221_SUCCESS:\n\t\t\tif ((data[mcp->gp_idx] == MCP2221_ALT_F_NOT_GPIOV) ||\n\t\t\t\t(data[mcp->gp_idx - 1] == MCP2221_ALT_F_NOT_GPIOV)) {\n\t\t\t\tmcp->status = -ENOENT;\n\t\t\t} else {\n\t\t\t\tmcp->status = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcp->status = -EAGAIN;\n\t\t}\n\t\tcomplete(&mcp->wait_in_report);\n\t\tbreak;\n\n\tcase MCP2221_SET_SRAM_SETTINGS:\n\t\tswitch (data[1]) {\n\t\tcase MCP2221_SUCCESS:\n\t\t\tmcp->status = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcp->status = -EAGAIN;\n\t\t}\n\t\tcomplete(&mcp->wait_in_report);\n\t\tbreak;\n\n\tcase MCP2221_GET_SRAM_SETTINGS:\n\t\tswitch (data[1]) {\n\t\tcase MCP2221_SUCCESS:\n\t\t\tmemcpy(&mcp->mode, &data[22], 4);\n#if IS_REACHABLE(CONFIG_IIO)\n\t\t\tmcp->dac_value = data[6] & GENMASK(4, 0);\n#endif\n\t\t\tmcp->status = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcp->status = -EAGAIN;\n\t\t}\n\t\tcomplete(&mcp->wait_in_report);\n\t\tbreak;\n\n\tcase MCP2221_READ_FLASH_DATA:\n\t\tswitch (data[1]) {\n\t\tcase MCP2221_SUCCESS:\n\t\t\tmcp->status = 0;\n\n\t\t\t \n\t\t\tif (mcp->txbuf[1] != 0) {\n\t\t\t\tmcp->status = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n#if IS_REACHABLE(CONFIG_IIO)\n\t\t\t{\n\t\t\t\tu8 tmp;\n\t\t\t\t \n\t\t\t\ttmp = FIELD_GET(GENMASK(7, 6), data[6]);\n\t\t\t\tif ((data[6] & BIT(5)) && tmp)\n\t\t\t\t\tmcp->dac_scale = tmp + 4;\n\t\t\t\telse\n\t\t\t\t\tmcp->dac_scale = 5;\n\n\t\t\t\t \n\t\t\t\ttmp = FIELD_GET(GENMASK(4, 3), data[7]);\n\t\t\t\tif ((data[7] & BIT(2)) && tmp)\n\t\t\t\t\tmcp->adc_scale = tmp - 1;\n\t\t\t\telse\n\t\t\t\t\tmcp->adc_scale = 0;\n\t\t\t}\n#endif\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcp->status = -EAGAIN;\n\t\t}\n\t\tcomplete(&mcp->wait_in_report);\n\t\tbreak;\n\n\tdefault:\n\t\tmcp->status = -EIO;\n\t\tcomplete(&mcp->wait_in_report);\n\t}\n\n\treturn 1;\n}\n\n \nstatic void mcp2221_hid_unregister(void *ptr)\n{\n\tstruct hid_device *hdev = ptr;\n\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\n \nstatic void mcp2221_remove(struct hid_device *hdev)\n{\n\tstruct mcp2221 *mcp = hid_get_drvdata(hdev);\n\n\tcancel_delayed_work_sync(&mcp->init_work);\n}\n\n#if IS_REACHABLE(CONFIG_IIO)\nstatic int mcp2221_read_raw(struct iio_dev *indio_dev,\n\t\t\t    struct iio_chan_spec const *channel, int *val,\n\t\t\t    int *val2, long mask)\n{\n\tstruct mcp2221_iio *priv = iio_priv(indio_dev);\n\tstruct mcp2221 *mcp = priv->mcp;\n\tint ret;\n\n\tif (mask == IIO_CHAN_INFO_SCALE) {\n\t\tif (channel->output)\n\t\t\t*val = 1 << mcp->dac_scale;\n\t\telse\n\t\t\t*val = 1 << mcp->adc_scale;\n\n\t\treturn IIO_VAL_INT;\n\t}\n\n\tmutex_lock(&mcp->lock);\n\n\tif (channel->output) {\n\t\t*val = mcp->dac_value;\n\t\tret = IIO_VAL_INT;\n\t} else {\n\t\t \n\t\tret = mcp_chk_last_cmd_status(mcp);\n\n\t\tif (!ret) {\n\t\t\t*val = le16_to_cpu((__force __le16) mcp->adc_values[channel->address]);\n\t\t\tif (*val >= BIT(10))\n\t\t\t\tret =  -EINVAL;\n\t\t\telse\n\t\t\t\tret = IIO_VAL_INT;\n\t\t}\n\t}\n\n\tmutex_unlock(&mcp->lock);\n\n\treturn ret;\n}\n\nstatic int mcp2221_write_raw(struct iio_dev *indio_dev,\n\t\t\t     struct iio_chan_spec const *chan,\n\t\t\t     int val, int val2, long mask)\n{\n\tstruct mcp2221_iio *priv = iio_priv(indio_dev);\n\tstruct mcp2221 *mcp = priv->mcp;\n\tint ret;\n\n\tif (val < 0 || val >= BIT(5))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mcp->lock);\n\n\tmemset(mcp->txbuf, 0, 12);\n\tmcp->txbuf[0] = MCP2221_SET_SRAM_SETTINGS;\n\tmcp->txbuf[4] = BIT(7) | val;\n\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 12);\n\tif (!ret)\n\t\tmcp->dac_value = val;\n\n\tmutex_unlock(&mcp->lock);\n\n\treturn ret;\n}\n\nstatic const struct iio_info mcp2221_info = {\n\t.read_raw = &mcp2221_read_raw,\n\t.write_raw = &mcp2221_write_raw,\n};\n\nstatic int mcp_iio_channels(struct mcp2221 *mcp)\n{\n\tint idx, cnt = 0;\n\tbool dac_created = false;\n\n\t \n\tfor (idx = 1; idx < MCP_NGPIO; idx++) {\n\t\tstruct iio_chan_spec *chan = &mcp->iio_channels[cnt];\n\n\t\tswitch (mcp->mode[idx]) {\n\t\tcase 2:\n\t\t\tchan->address = idx - 1;\n\t\t\tchan->channel = cnt++;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\tif (idx == 1 || dac_created)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tdac_created = true;\n\t\t\tchan->output = 1;\n\t\t\tcnt++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t};\n\n\t\tchan->type = IIO_VOLTAGE;\n\t\tchan->indexed = 1;\n\t\tchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\n\t\tchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\n\t\tchan->scan_index = -1;\n\t}\n\n\treturn cnt;\n}\n\nstatic void mcp_init_work(struct work_struct *work)\n{\n\tstruct iio_dev *indio_dev;\n\tstruct mcp2221 *mcp = container_of(work, struct mcp2221, init_work.work);\n\tstruct mcp2221_iio *data;\n\tstatic int retries = 5;\n\tint ret, num_channels;\n\n\thid_hw_power(mcp->hdev, PM_HINT_FULLON);\n\tmutex_lock(&mcp->lock);\n\n\tmcp->txbuf[0] = MCP2221_GET_SRAM_SETTINGS;\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 1);\n\n\tif (ret == -EAGAIN)\n\t\tgoto reschedule_task;\n\n\tnum_channels = mcp_iio_channels(mcp);\n\tif (!num_channels)\n\t\tgoto unlock;\n\n\tmcp->txbuf[0] = MCP2221_READ_FLASH_DATA;\n\tmcp->txbuf[1] = 0;\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, 2);\n\n\tif (ret == -EAGAIN)\n\t\tgoto reschedule_task;\n\n\tindio_dev = devm_iio_device_alloc(&mcp->hdev->dev, sizeof(*data));\n\tif (!indio_dev)\n\t\tgoto unlock;\n\n\tdata = iio_priv(indio_dev);\n\tdata->mcp = mcp;\n\n\tindio_dev->name = \"mcp2221\";\n\tindio_dev->modes = INDIO_DIRECT_MODE;\n\tindio_dev->info = &mcp2221_info;\n\tindio_dev->channels = mcp->iio_channels;\n\tindio_dev->num_channels = num_channels;\n\n\tdevm_iio_device_register(&mcp->hdev->dev, indio_dev);\n\nunlock:\n\tmutex_unlock(&mcp->lock);\n\thid_hw_power(mcp->hdev, PM_HINT_NORMAL);\n\n\treturn;\n\nreschedule_task:\n\tmutex_unlock(&mcp->lock);\n\thid_hw_power(mcp->hdev, PM_HINT_NORMAL);\n\n\tif (!retries--)\n\t\treturn;\n\n\t \n\tschedule_delayed_work(&mcp->init_work, msecs_to_jiffies(100));\n}\n#endif\n\nstatic int mcp2221_probe(struct hid_device *hdev,\n\t\t\t\t\tconst struct hid_device_id *id)\n{\n\tint ret;\n\tstruct mcp2221 *mcp;\n\n\tmcp = devm_kzalloc(&hdev->dev, sizeof(*mcp), GFP_KERNEL);\n\tif (!mcp)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"can't parse reports\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = hid_hw_start(hdev, 0);\n\tif (ret) {\n\t\thid_err(hdev, \"can't start hardware\\n\");\n\t\treturn ret;\n\t}\n\n\thid_info(hdev, \"USB HID v%x.%02x Device [%s] on %s\\n\", hdev->version >> 8,\n\t\t\thdev->version & 0xff, hdev->name, hdev->phys);\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"can't open device\\n\");\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&mcp->lock);\n\tinit_completion(&mcp->wait_in_report);\n\thid_set_drvdata(hdev, mcp);\n\tmcp->hdev = hdev;\n\n\tret = devm_add_action_or_reset(&hdev->dev, mcp2221_hid_unregister, hdev);\n\tif (ret)\n\t\treturn ret;\n\n\thid_device_io_start(hdev);\n\n\t \n\tif (i2c_clk_freq > 400)\n\t\ti2c_clk_freq = 400;\n\tif (i2c_clk_freq < 50)\n\t\ti2c_clk_freq = 50;\n\tmcp->cur_i2c_clk_div = (12000000 / (i2c_clk_freq * 1000)) - 3;\n\n\tmcp->adapter.owner = THIS_MODULE;\n\tmcp->adapter.class = I2C_CLASS_HWMON;\n\tmcp->adapter.algo = &mcp_i2c_algo;\n\tmcp->adapter.retries = 1;\n\tmcp->adapter.dev.parent = &hdev->dev;\n\tsnprintf(mcp->adapter.name, sizeof(mcp->adapter.name),\n\t\t\t\"MCP2221 usb-i2c bridge\");\n\n\ti2c_set_adapdata(&mcp->adapter, mcp);\n\tret = devm_i2c_add_adapter(&hdev->dev, &mcp->adapter);\n\tif (ret) {\n\t\thid_err(hdev, \"can't add usb-i2c adapter: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n#if IS_REACHABLE(CONFIG_GPIOLIB)\n\t \n\tmcp->gc = devm_kzalloc(&hdev->dev, sizeof(*mcp->gc), GFP_KERNEL);\n\tif (!mcp->gc)\n\t\treturn -ENOMEM;\n\n\tmcp->gc->label = \"mcp2221_gpio\";\n\tmcp->gc->direction_input = mcp_gpio_direction_input;\n\tmcp->gc->direction_output = mcp_gpio_direction_output;\n\tmcp->gc->get_direction = mcp_gpio_get_direction;\n\tmcp->gc->set = mcp_gpio_set;\n\tmcp->gc->get = mcp_gpio_get;\n\tmcp->gc->ngpio = MCP_NGPIO;\n\tmcp->gc->base = -1;\n\tmcp->gc->can_sleep = 1;\n\tmcp->gc->parent = &hdev->dev;\n\n\tret = devm_gpiochip_add_data(&hdev->dev, mcp->gc, mcp);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n#if IS_REACHABLE(CONFIG_IIO)\n\tINIT_DELAYED_WORK(&mcp->init_work, mcp_init_work);\n\tschedule_delayed_work(&mcp->init_work, msecs_to_jiffies(100));\n#endif\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id mcp2221_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_MCP2221) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, mcp2221_devices);\n\nstatic struct hid_driver mcp2221_driver = {\n\t.name\t\t= \"mcp2221\",\n\t.id_table\t= mcp2221_devices,\n\t.probe\t\t= mcp2221_probe,\n\t.remove\t\t= mcp2221_remove,\n\t.raw_event\t= mcp2221_raw_event,\n};\n\n \nmodule_hid_driver(mcp2221_driver);\n\nMODULE_AUTHOR(\"Rishi Gupta <gupt21@gmail.com>\");\nMODULE_DESCRIPTION(\"MCP2221 Microchip HID USB to I2C master bridge\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}