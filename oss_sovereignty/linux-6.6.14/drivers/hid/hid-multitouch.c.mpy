{
  "module_name": "hid-multitouch.c",
  "hash_id": "d32773231e8389d511c2118591310f5612b758a20f2035b6ea12696ff6fcb659",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-multitouch.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input/mt.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n\n\nMODULE_AUTHOR(\"Stephane Chatty <chatty@enac.fr>\");\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\");\nMODULE_DESCRIPTION(\"HID multitouch panels\");\nMODULE_LICENSE(\"GPL\");\n\n#include \"hid-ids.h\"\n\n \n#define MT_QUIRK_NOT_SEEN_MEANS_UP\tBIT(0)\n#define MT_QUIRK_SLOT_IS_CONTACTID\tBIT(1)\n#define MT_QUIRK_CYPRESS\t\tBIT(2)\n#define MT_QUIRK_SLOT_IS_CONTACTNUMBER\tBIT(3)\n#define MT_QUIRK_ALWAYS_VALID\t\tBIT(4)\n#define MT_QUIRK_VALID_IS_INRANGE\tBIT(5)\n#define MT_QUIRK_VALID_IS_CONFIDENCE\tBIT(6)\n#define MT_QUIRK_CONFIDENCE\t\tBIT(7)\n#define MT_QUIRK_SLOT_IS_CONTACTID_MINUS_ONE\tBIT(8)\n#define MT_QUIRK_NO_AREA\t\tBIT(9)\n#define MT_QUIRK_IGNORE_DUPLICATES\tBIT(10)\n#define MT_QUIRK_HOVERING\t\tBIT(11)\n#define MT_QUIRK_CONTACT_CNT_ACCURATE\tBIT(12)\n#define MT_QUIRK_FORCE_GET_FEATURE\tBIT(13)\n#define MT_QUIRK_FIX_CONST_CONTACT_ID\tBIT(14)\n#define MT_QUIRK_TOUCH_SIZE_SCALING\tBIT(15)\n#define MT_QUIRK_STICKY_FINGERS\t\tBIT(16)\n#define MT_QUIRK_ASUS_CUSTOM_UP\t\tBIT(17)\n#define MT_QUIRK_WIN8_PTP_BUTTONS\tBIT(18)\n#define MT_QUIRK_SEPARATE_APP_REPORT\tBIT(19)\n#define MT_QUIRK_FORCE_MULTI_INPUT\tBIT(20)\n#define MT_QUIRK_DISABLE_WAKEUP\t\tBIT(21)\n#define MT_QUIRK_ORIENTATION_INVERT\tBIT(22)\n\n#define MT_INPUTMODE_TOUCHSCREEN\t0x02\n#define MT_INPUTMODE_TOUCHPAD\t\t0x03\n\n#define MT_BUTTONTYPE_CLICKPAD\t\t0\n\nenum latency_mode {\n\tHID_LATENCY_NORMAL = 0,\n\tHID_LATENCY_HIGH = 1,\n};\n\n#define MT_IO_FLAGS_RUNNING\t\t0\n#define MT_IO_FLAGS_ACTIVE_SLOTS\t1\n#define MT_IO_FLAGS_PENDING_SLOTS\t2\n\nstatic const bool mtrue = true;\t\t \nstatic const bool mfalse;\t\t \nstatic const __s32 mzero;\t\t \n\n#define DEFAULT_TRUE\t((void *)&mtrue)\n#define DEFAULT_FALSE\t((void *)&mfalse)\n#define DEFAULT_ZERO\t((void *)&mzero)\n\nstruct mt_usages {\n\tstruct list_head list;\n\t__s32 *x, *y, *cx, *cy, *p, *w, *h, *a;\n\t__s32 *contactid;\t \n\tbool *tip_state;\t \n\tbool *inrange_state;\t \n\tbool *confidence_state;\t \n};\n\nstruct mt_application {\n\tstruct list_head list;\n\tunsigned int application;\n\tunsigned int report_id;\n\tstruct list_head mt_usages;\t \n\n\t__s32 quirks;\n\n\t__s32 *scantime;\t\t \n\t__s32 scantime_logical_max;\t \n\n\t__s32 *raw_cc;\t\t\t \n\tint left_button_state;\t\t \n\tunsigned int mt_flags;\t\t \n\n\tunsigned long *pending_palm_slots;\t \n\n\t__u8 num_received;\t \n\t__u8 num_expected;\t \n\t__u8 buttons_count;\t \n\t__u8 touches_by_report;\t \n\n\t__s32 dev_time;\t\t \n\tunsigned long jiffies;\t \n\tint timestamp;\t\t \n\tint prev_scantime;\t\t \n\n\tbool have_contact_count;\n};\n\nstruct mt_class {\n\t__s32 name;\t \n\t__s32 quirks;\n\t__s32 sn_move;\t \n\t__s32 sn_width;\t \n\t__s32 sn_height;\t \n\t__s32 sn_pressure;\t \n\t__u8 maxcontacts;\n\tbool is_indirect;\t \n\tbool export_all_inputs;\t \n};\n\nstruct mt_report_data {\n\tstruct list_head list;\n\tstruct hid_report *report;\n\tstruct mt_application *application;\n\tbool is_mt_collection;\n};\n\nstruct mt_device {\n\tstruct mt_class mtclass;\t \n\tstruct timer_list release_timer;\t \n\tstruct hid_device *hdev;\t \n\tunsigned long mt_io_flags;\t \n\t__u8 inputmode_value;\t \n\t__u8 maxcontacts;\n\tbool is_buttonpad;\t \n\tbool serial_maybe;\t \n\n\tstruct list_head applications;\n\tstruct list_head reports;\n};\n\nstatic void mt_post_parse_default_settings(struct mt_device *td,\n\t\t\t\t\t   struct mt_application *app);\nstatic void mt_post_parse(struct mt_device *td, struct mt_application *app);\n\n \n#define MT_CLS_DEFAULT\t\t\t\t0x0001\n\n#define MT_CLS_SERIAL\t\t\t\t0x0002\n#define MT_CLS_CONFIDENCE\t\t\t0x0003\n#define MT_CLS_CONFIDENCE_CONTACT_ID\t\t0x0004\n#define MT_CLS_CONFIDENCE_MINUS_ONE\t\t0x0005\n#define MT_CLS_DUAL_INRANGE_CONTACTID\t\t0x0006\n#define MT_CLS_DUAL_INRANGE_CONTACTNUMBER\t0x0007\n \n#define MT_CLS_INRANGE_CONTACTNUMBER\t\t0x0009\n#define MT_CLS_NSMU\t\t\t\t0x000a\n \n \n#define MT_CLS_WIN_8\t\t\t\t0x0012\n#define MT_CLS_EXPORT_ALL_INPUTS\t\t0x0013\n \n#define MT_CLS_WIN_8_FORCE_MULTI_INPUT\t\t0x0015\n#define MT_CLS_WIN_8_DISABLE_WAKEUP\t\t0x0016\n#define MT_CLS_WIN_8_NO_STICKY_FINGERS\t\t0x0017\n#define MT_CLS_WIN_8_FORCE_MULTI_INPUT_NSMU\t0x0018\n\n \n#define MT_CLS_3M\t\t\t\t0x0101\n \n#define MT_CLS_EGALAX\t\t\t\t0x0103\n#define MT_CLS_EGALAX_SERIAL\t\t\t0x0104\n#define MT_CLS_TOPSEED\t\t\t\t0x0105\n#define MT_CLS_PANASONIC\t\t\t0x0106\n#define MT_CLS_FLATFROG\t\t\t\t0x0107\n#define MT_CLS_GENERALTOUCH_TWOFINGERS\t\t0x0108\n#define MT_CLS_GENERALTOUCH_PWT_TENFINGERS\t0x0109\n#define MT_CLS_LG\t\t\t\t0x010a\n#define MT_CLS_ASUS\t\t\t\t0x010b\n#define MT_CLS_VTL\t\t\t\t0x0110\n#define MT_CLS_GOOGLE\t\t\t\t0x0111\n#define MT_CLS_RAZER_BLADE_STEALTH\t\t0x0112\n#define MT_CLS_SMART_TECH\t\t\t0x0113\n\n#define MT_DEFAULT_MAXCONTACT\t10\n#define MT_MAX_MAXCONTACT\t250\n\n \n#define MAX_TIMESTAMP_INTERVAL\t1000000\n\n#define MT_USB_DEVICE(v, p)\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH, v, p)\n#define MT_BT_DEVICE(v, p)\tHID_DEVICE(BUS_BLUETOOTH, HID_GROUP_MULTITOUCH, v, p)\n\n \n\nstatic int cypress_compute_slot(struct mt_application *application,\n\t\t\t\tstruct mt_usages *slot)\n{\n\tif (*slot->contactid != 0 || application->num_received == 0)\n\t\treturn *slot->contactid;\n\telse\n\t\treturn -1;\n}\n\nstatic const struct mt_class mt_classes[] = {\n\t{ .name = MT_CLS_DEFAULT,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE },\n\t{ .name = MT_CLS_NSMU,\n\t\t.quirks = MT_QUIRK_NOT_SEEN_MEANS_UP },\n\t{ .name = MT_CLS_SERIAL,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID},\n\t{ .name = MT_CLS_CONFIDENCE,\n\t\t.quirks = MT_QUIRK_VALID_IS_CONFIDENCE },\n\t{ .name = MT_CLS_CONFIDENCE_CONTACT_ID,\n\t\t.quirks = MT_QUIRK_VALID_IS_CONFIDENCE |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTID },\n\t{ .name = MT_CLS_CONFIDENCE_MINUS_ONE,\n\t\t.quirks = MT_QUIRK_VALID_IS_CONFIDENCE |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTID_MINUS_ONE },\n\t{ .name = MT_CLS_DUAL_INRANGE_CONTACTID,\n\t\t.quirks = MT_QUIRK_VALID_IS_INRANGE |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTID,\n\t\t.maxcontacts = 2 },\n\t{ .name = MT_CLS_DUAL_INRANGE_CONTACTNUMBER,\n\t\t.quirks = MT_QUIRK_VALID_IS_INRANGE |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTNUMBER,\n\t\t.maxcontacts = 2 },\n\t{ .name = MT_CLS_INRANGE_CONTACTNUMBER,\n\t\t.quirks = MT_QUIRK_VALID_IS_INRANGE |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTNUMBER },\n\t{ .name = MT_CLS_WIN_8,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_IGNORE_DUPLICATES |\n\t\t\tMT_QUIRK_HOVERING |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_STICKY_FINGERS |\n\t\t\tMT_QUIRK_WIN8_PTP_BUTTONS,\n\t\t.export_all_inputs = true },\n\t{ .name = MT_CLS_EXPORT_ALL_INPUTS,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE,\n\t\t.export_all_inputs = true },\n\t{ .name = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_IGNORE_DUPLICATES |\n\t\t\tMT_QUIRK_HOVERING |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_STICKY_FINGERS |\n\t\t\tMT_QUIRK_WIN8_PTP_BUTTONS |\n\t\t\tMT_QUIRK_FORCE_MULTI_INPUT,\n\t\t.export_all_inputs = true },\n\t{ .name = MT_CLS_WIN_8_FORCE_MULTI_INPUT_NSMU,\n\t\t.quirks = MT_QUIRK_IGNORE_DUPLICATES |\n\t\t\tMT_QUIRK_HOVERING |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_STICKY_FINGERS |\n\t\t\tMT_QUIRK_WIN8_PTP_BUTTONS |\n\t\t\tMT_QUIRK_FORCE_MULTI_INPUT |\n\t\t\tMT_QUIRK_NOT_SEEN_MEANS_UP,\n\t\t.export_all_inputs = true },\n\t{ .name = MT_CLS_WIN_8_DISABLE_WAKEUP,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_IGNORE_DUPLICATES |\n\t\t\tMT_QUIRK_HOVERING |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_STICKY_FINGERS |\n\t\t\tMT_QUIRK_WIN8_PTP_BUTTONS |\n\t\t\tMT_QUIRK_DISABLE_WAKEUP,\n\t\t.export_all_inputs = true },\n\t{ .name = MT_CLS_WIN_8_NO_STICKY_FINGERS,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_IGNORE_DUPLICATES |\n\t\t\tMT_QUIRK_HOVERING |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_WIN8_PTP_BUTTONS,\n\t\t.export_all_inputs = true },\n\n\t \n\t{ .name = MT_CLS_3M,\n\t\t.quirks = MT_QUIRK_VALID_IS_CONFIDENCE |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTID |\n\t\t\tMT_QUIRK_TOUCH_SIZE_SCALING,\n\t\t.sn_move = 2048,\n\t\t.sn_width = 128,\n\t\t.sn_height = 128,\n\t\t.maxcontacts = 60,\n\t},\n\t{ .name = MT_CLS_EGALAX,\n\t\t.quirks =  MT_QUIRK_SLOT_IS_CONTACTID |\n\t\t\tMT_QUIRK_VALID_IS_INRANGE,\n\t\t.sn_move = 4096,\n\t\t.sn_pressure = 32,\n\t},\n\t{ .name = MT_CLS_EGALAX_SERIAL,\n\t\t.quirks =  MT_QUIRK_SLOT_IS_CONTACTID |\n\t\t\tMT_QUIRK_ALWAYS_VALID,\n\t\t.sn_move = 4096,\n\t\t.sn_pressure = 32,\n\t},\n\t{ .name = MT_CLS_TOPSEED,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID,\n\t\t.is_indirect = true,\n\t\t.maxcontacts = 2,\n\t},\n\t{ .name = MT_CLS_PANASONIC,\n\t\t.quirks = MT_QUIRK_NOT_SEEN_MEANS_UP,\n\t\t.maxcontacts = 4 },\n\t{ .name\t= MT_CLS_GENERALTOUCH_TWOFINGERS,\n\t\t.quirks\t= MT_QUIRK_NOT_SEEN_MEANS_UP |\n\t\t\tMT_QUIRK_VALID_IS_INRANGE |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTID,\n\t\t.maxcontacts = 2\n\t},\n\t{ .name\t= MT_CLS_GENERALTOUCH_PWT_TENFINGERS,\n\t\t.quirks\t= MT_QUIRK_NOT_SEEN_MEANS_UP |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTID\n\t},\n\n\t{ .name = MT_CLS_FLATFROG,\n\t\t.quirks = MT_QUIRK_NOT_SEEN_MEANS_UP |\n\t\t\tMT_QUIRK_NO_AREA,\n\t\t.sn_move = 2048,\n\t\t.maxcontacts = 40,\n\t},\n\t{ .name = MT_CLS_LG,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_FIX_CONST_CONTACT_ID |\n\t\t\tMT_QUIRK_IGNORE_DUPLICATES |\n\t\t\tMT_QUIRK_HOVERING |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE },\n\t{ .name = MT_CLS_ASUS,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_ASUS_CUSTOM_UP },\n\t{ .name = MT_CLS_VTL,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_FORCE_GET_FEATURE,\n\t},\n\t{ .name = MT_CLS_GOOGLE,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_SLOT_IS_CONTACTID |\n\t\t\tMT_QUIRK_HOVERING\n\t},\n\t{ .name = MT_CLS_RAZER_BLADE_STEALTH,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_IGNORE_DUPLICATES |\n\t\t\tMT_QUIRK_HOVERING |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_WIN8_PTP_BUTTONS,\n\t},\n\t{ .name = MT_CLS_SMART_TECH,\n\t\t.quirks = MT_QUIRK_ALWAYS_VALID |\n\t\t\tMT_QUIRK_IGNORE_DUPLICATES |\n\t\t\tMT_QUIRK_CONTACT_CNT_ACCURATE |\n\t\t\tMT_QUIRK_SEPARATE_APP_REPORT,\n\t},\n\t{ }\n};\n\nstatic ssize_t mt_show_quirks(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%u\\n\", td->mtclass.quirks);\n}\n\nstatic ssize_t mt_set_quirks(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tstruct mt_application *application;\n\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\ttd->mtclass.quirks = val;\n\n\tlist_for_each_entry(application, &td->applications, list) {\n\t\tapplication->quirks = val;\n\t\tif (!application->have_contact_count)\n\t\t\tapplication->quirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(quirks, S_IWUSR | S_IRUGO, mt_show_quirks, mt_set_quirks);\n\nstatic struct attribute *sysfs_attrs[] = {\n\t&dev_attr_quirks.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mt_attribute_group = {\n\t.attrs = sysfs_attrs\n};\n\nstatic void mt_get_feature(struct hid_device *hdev, struct hid_report *report)\n{\n\tint ret;\n\tu32 size = hid_report_len(report);\n\tu8 *buf;\n\n\t \n\tif (hdev->quirks & HID_QUIRK_NO_INIT_REPORTS)\n\t\treturn;\n\n\tbuf = hid_alloc_report_buf(report, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tret = hid_hw_raw_request(hdev, report->id, buf, size,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret < 0) {\n\t\tdev_warn(&hdev->dev, \"failed to fetch feature %d\\n\",\n\t\t\t report->id);\n\t} else {\n\t\tret = hid_report_raw_event(hdev, HID_FEATURE_REPORT, buf,\n\t\t\t\t\t   size, 0);\n\t\tif (ret)\n\t\t\tdev_warn(&hdev->dev, \"failed to report feature\\n\");\n\t}\n\n\tkfree(buf);\n}\n\nstatic void mt_feature_mapping(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\n\tswitch (usage->hid) {\n\tcase HID_DG_CONTACTMAX:\n\t\tmt_get_feature(hdev, field->report);\n\n\t\ttd->maxcontacts = field->value[0];\n\t\tif (!td->maxcontacts &&\n\t\t    field->logical_maximum <= MT_MAX_MAXCONTACT)\n\t\t\ttd->maxcontacts = field->logical_maximum;\n\t\tif (td->mtclass.maxcontacts)\n\t\t\t \n\t\t\ttd->maxcontacts = td->mtclass.maxcontacts;\n\n\t\tbreak;\n\tcase HID_DG_BUTTONTYPE:\n\t\tif (usage->usage_index >= field->report_count) {\n\t\t\tdev_err(&hdev->dev, \"HID_DG_BUTTONTYPE out of range\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmt_get_feature(hdev, field->report);\n\t\tif (field->value[usage->usage_index] == MT_BUTTONTYPE_CLICKPAD)\n\t\t\ttd->is_buttonpad = true;\n\n\t\tbreak;\n\tcase 0xff0000c5:\n\t\t \n\t\tif (usage->usage_index == 0)\n\t\t\tmt_get_feature(hdev, field->report);\n\t\tbreak;\n\t}\n}\n\nstatic void set_abs(struct input_dev *input, unsigned int code,\n\t\tstruct hid_field *field, int snratio)\n{\n\tint fmin = field->logical_minimum;\n\tint fmax = field->logical_maximum;\n\tint fuzz = snratio ? (fmax - fmin) / snratio : 0;\n\tinput_set_abs_params(input, code, fmin, fmax, fuzz, 0);\n\tinput_abs_set_res(input, code, hidinput_calc_abs_res(field, code));\n}\n\nstatic struct mt_usages *mt_allocate_usage(struct hid_device *hdev,\n\t\t\t\t\t   struct mt_application *application)\n{\n\tstruct mt_usages *usage;\n\n\tusage = devm_kzalloc(&hdev->dev, sizeof(*usage), GFP_KERNEL);\n\tif (!usage)\n\t\treturn NULL;\n\n\t \n\tusage->x = DEFAULT_ZERO;\n\tusage->y = DEFAULT_ZERO;\n\tusage->cx = DEFAULT_ZERO;\n\tusage->cy = DEFAULT_ZERO;\n\tusage->p = DEFAULT_ZERO;\n\tusage->w = DEFAULT_ZERO;\n\tusage->h = DEFAULT_ZERO;\n\tusage->a = DEFAULT_ZERO;\n\tusage->contactid = DEFAULT_ZERO;\n\tusage->tip_state = DEFAULT_FALSE;\n\tusage->inrange_state = DEFAULT_FALSE;\n\tusage->confidence_state = DEFAULT_TRUE;\n\n\tlist_add_tail(&usage->list, &application->mt_usages);\n\n\treturn usage;\n}\n\nstatic struct mt_application *mt_allocate_application(struct mt_device *td,\n\t\t\t\t\t\t      struct hid_report *report)\n{\n\tunsigned int application = report->application;\n\tstruct mt_application *mt_application;\n\n\tmt_application = devm_kzalloc(&td->hdev->dev, sizeof(*mt_application),\n\t\t\t\t      GFP_KERNEL);\n\tif (!mt_application)\n\t\treturn NULL;\n\n\tmt_application->application = application;\n\tINIT_LIST_HEAD(&mt_application->mt_usages);\n\n\tif (application == HID_DG_TOUCHSCREEN)\n\t\tmt_application->mt_flags |= INPUT_MT_DIRECT;\n\n\t \n\tif (application == HID_DG_TOUCHPAD) {\n\t\tmt_application->mt_flags |= INPUT_MT_POINTER;\n\t\ttd->inputmode_value = MT_INPUTMODE_TOUCHPAD;\n\t}\n\n\tmt_application->scantime = DEFAULT_ZERO;\n\tmt_application->raw_cc = DEFAULT_ZERO;\n\tmt_application->quirks = td->mtclass.quirks;\n\tmt_application->report_id = report->id;\n\n\tlist_add_tail(&mt_application->list, &td->applications);\n\n\treturn mt_application;\n}\n\nstatic struct mt_application *mt_find_application(struct mt_device *td,\n\t\t\t\t\t\t  struct hid_report *report)\n{\n\tunsigned int application = report->application;\n\tstruct mt_application *tmp, *mt_application = NULL;\n\n\tlist_for_each_entry(tmp, &td->applications, list) {\n\t\tif (application == tmp->application) {\n\t\t\tif (!(td->mtclass.quirks & MT_QUIRK_SEPARATE_APP_REPORT) ||\n\t\t\t    tmp->report_id == report->id) {\n\t\t\t\tmt_application = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mt_application)\n\t\tmt_application = mt_allocate_application(td, report);\n\n\treturn mt_application;\n}\n\nstatic struct mt_report_data *mt_allocate_report_data(struct mt_device *td,\n\t\t\t\t\t\t      struct hid_report *report)\n{\n\tstruct mt_report_data *rdata;\n\tstruct hid_field *field;\n\tint r, n;\n\n\trdata = devm_kzalloc(&td->hdev->dev, sizeof(*rdata), GFP_KERNEL);\n\tif (!rdata)\n\t\treturn NULL;\n\n\trdata->report = report;\n\trdata->application = mt_find_application(td, report);\n\n\tif (!rdata->application) {\n\t\tdevm_kfree(&td->hdev->dev, rdata);\n\t\treturn NULL;\n\t}\n\n\tfor (r = 0; r < report->maxfield; r++) {\n\t\tfield = report->field[r];\n\n\t\tif (!(HID_MAIN_ITEM_VARIABLE & field->flags))\n\t\t\tcontinue;\n\n\t\tif (field->logical == HID_DG_FINGER || td->hdev->group != HID_GROUP_MULTITOUCH_WIN_8) {\n\t\t\tfor (n = 0; n < field->report_count; n++) {\n\t\t\t\tif (field->usage[n].hid == HID_DG_CONTACTID) {\n\t\t\t\t\trdata->is_mt_collection = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_add_tail(&rdata->list, &td->reports);\n\n\treturn rdata;\n}\n\nstatic struct mt_report_data *mt_find_report_data(struct mt_device *td,\n\t\t\t\t\t\t  struct hid_report *report)\n{\n\tstruct mt_report_data *tmp, *rdata = NULL;\n\n\tlist_for_each_entry(tmp, &td->reports, list) {\n\t\tif (report == tmp->report) {\n\t\t\trdata = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rdata)\n\t\trdata = mt_allocate_report_data(td, report);\n\n\treturn rdata;\n}\n\nstatic void mt_store_field(struct hid_device *hdev,\n\t\t\t   struct mt_application *application,\n\t\t\t   __s32 *value,\n\t\t\t   size_t offset)\n{\n\tstruct mt_usages *usage;\n\t__s32 **target;\n\n\tif (list_empty(&application->mt_usages))\n\t\tusage = mt_allocate_usage(hdev, application);\n\telse\n\t\tusage = list_last_entry(&application->mt_usages,\n\t\t\t\t\tstruct mt_usages,\n\t\t\t\t\tlist);\n\n\tif (!usage)\n\t\treturn;\n\n\ttarget = (__s32 **)((char *)usage + offset);\n\n\t \n\tif (*target != DEFAULT_TRUE &&\n\t    *target != DEFAULT_FALSE &&\n\t    *target != DEFAULT_ZERO) {\n\t\tif (usage->contactid == DEFAULT_ZERO ||\n\t\t    usage->x == DEFAULT_ZERO ||\n\t\t    usage->y == DEFAULT_ZERO) {\n\t\t\thid_dbg(hdev,\n\t\t\t\t\"ignoring duplicate usage on incomplete\");\n\t\t\treturn;\n\t\t}\n\t\tusage = mt_allocate_usage(hdev, application);\n\t\tif (!usage)\n\t\t\treturn;\n\n\t\ttarget = (__s32 **)((char *)usage + offset);\n\t}\n\n\t*target = value;\n}\n\n#define MT_STORE_FIELD(__name)\t\t\t\t\t\t\\\n\tmt_store_field(hdev, app,\t\t\t\t\t\\\n\t\t       &field->value[usage->usage_index],\t\t\\\n\t\t       offsetof(struct mt_usages, __name))\n\nstatic int mt_touch_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max, struct mt_application *app)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tstruct mt_class *cls = &td->mtclass;\n\tint code;\n\tstruct hid_usage *prev_usage = NULL;\n\n\t \n\tif (field->application == HID_DG_TOUCHSCREEN &&\n\t    (usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\n\t\tapp->mt_flags |= INPUT_MT_POINTER;\n\t\ttd->inputmode_value = MT_INPUTMODE_TOUCHPAD;\n\t}\n\n\t \n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON)\n\t\tapp->buttons_count++;\n\n\tif (usage->usage_index)\n\t\tprev_usage = &field->usage[usage->usage_index - 1];\n\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\n\tcase HID_UP_GENDESK:\n\t\tswitch (usage->hid) {\n\t\tcase HID_GD_X:\n\t\t\tif (prev_usage && (prev_usage->hid == usage->hid)) {\n\t\t\t\tcode = ABS_MT_TOOL_X;\n\t\t\t\tMT_STORE_FIELD(cx);\n\t\t\t} else {\n\t\t\t\tcode = ABS_MT_POSITION_X;\n\t\t\t\tMT_STORE_FIELD(x);\n\t\t\t}\n\n\t\t\tset_abs(hi->input, code, field, cls->sn_move);\n\n\t\t\t \n\t\t\tif (field->application == HID_GD_SYSTEM_MULTIAXIS) {\n\t\t\t\t__set_bit(INPUT_PROP_DIRECT,\n\t\t\t\t\t  hi->input->propbit);\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\t     ABS_MT_TOOL_TYPE,\n\t\t\t\t\t\t     MT_TOOL_DIAL,\n\t\t\t\t\t\t     MT_TOOL_DIAL, 0, 0);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\tcase HID_GD_Y:\n\t\t\tif (prev_usage && (prev_usage->hid == usage->hid)) {\n\t\t\t\tcode = ABS_MT_TOOL_Y;\n\t\t\t\tMT_STORE_FIELD(cy);\n\t\t\t} else {\n\t\t\t\tcode = ABS_MT_POSITION_Y;\n\t\t\t\tMT_STORE_FIELD(y);\n\t\t\t}\n\n\t\t\tset_abs(hi->input, code, field, cls->sn_move);\n\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_UP_DIGITIZER:\n\t\tswitch (usage->hid) {\n\t\tcase HID_DG_INRANGE:\n\t\t\tif (app->quirks & MT_QUIRK_HOVERING) {\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\tABS_MT_DISTANCE, 0, 1, 0, 0);\n\t\t\t}\n\t\t\tMT_STORE_FIELD(inrange_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONFIDENCE:\n\t\t\tif ((cls->name == MT_CLS_WIN_8 ||\n\t\t\t     cls->name == MT_CLS_WIN_8_FORCE_MULTI_INPUT ||\n\t\t\t     cls->name == MT_CLS_WIN_8_FORCE_MULTI_INPUT_NSMU ||\n\t\t\t     cls->name == MT_CLS_WIN_8_DISABLE_WAKEUP) &&\n\t\t\t\t(field->application == HID_DG_TOUCHPAD ||\n\t\t\t\t field->application == HID_DG_TOUCHSCREEN))\n\t\t\t\tapp->quirks |= MT_QUIRK_CONFIDENCE;\n\n\t\t\tif (app->quirks & MT_QUIRK_CONFIDENCE)\n\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\t     ABS_MT_TOOL_TYPE,\n\t\t\t\t\t\t     MT_TOOL_FINGER,\n\t\t\t\t\t\t     MT_TOOL_PALM, 0, 0);\n\n\t\t\tMT_STORE_FIELD(confidence_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_TIPSWITCH:\n\t\t\tif (field->application != HID_GD_SYSTEM_MULTIAXIS)\n\t\t\t\tinput_set_capability(hi->input,\n\t\t\t\t\t\t     EV_KEY, BTN_TOUCH);\n\t\t\tMT_STORE_FIELD(tip_state);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTID:\n\t\t\tMT_STORE_FIELD(contactid);\n\t\t\tapp->touches_by_report++;\n\t\t\treturn 1;\n\t\tcase HID_DG_WIDTH:\n\t\t\tif (!(app->quirks & MT_QUIRK_NO_AREA))\n\t\t\t\tset_abs(hi->input, ABS_MT_TOUCH_MAJOR, field,\n\t\t\t\t\tcls->sn_width);\n\t\t\tMT_STORE_FIELD(w);\n\t\t\treturn 1;\n\t\tcase HID_DG_HEIGHT:\n\t\t\tif (!(app->quirks & MT_QUIRK_NO_AREA)) {\n\t\t\t\tset_abs(hi->input, ABS_MT_TOUCH_MINOR, field,\n\t\t\t\t\tcls->sn_height);\n\n\t\t\t\t \n\t\t\t\tif (!test_bit(ABS_MT_ORIENTATION,\n\t\t\t\t\t\thi->input->absbit))\n\t\t\t\t\tinput_set_abs_params(hi->input,\n\t\t\t\t\t\tABS_MT_ORIENTATION, 0, 1, 0, 0);\n\t\t\t}\n\t\t\tMT_STORE_FIELD(h);\n\t\t\treturn 1;\n\t\tcase HID_DG_TIPPRESSURE:\n\t\t\tset_abs(hi->input, ABS_MT_PRESSURE, field,\n\t\t\t\tcls->sn_pressure);\n\t\t\tMT_STORE_FIELD(p);\n\t\t\treturn 1;\n\t\tcase HID_DG_SCANTIME:\n\t\t\tinput_set_capability(hi->input, EV_MSC, MSC_TIMESTAMP);\n\t\t\tapp->scantime = &field->value[usage->usage_index];\n\t\t\tapp->scantime_logical_max = field->logical_maximum;\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTCOUNT:\n\t\t\tapp->have_contact_count = true;\n\t\t\tapp->raw_cc = &field->value[usage->usage_index];\n\t\t\treturn 1;\n\t\tcase HID_DG_AZIMUTH:\n\t\t\t \n\t\t\tinput_set_abs_params(hi->input, ABS_MT_ORIENTATION,\n\t\t\t\t-field->logical_maximum / 4,\n\t\t\t\tfield->logical_maximum / 4,\n\t\t\t\tcls->sn_move ?\n\t\t\t\tfield->logical_maximum / cls->sn_move : 0, 0);\n\t\t\tMT_STORE_FIELD(a);\n\t\t\treturn 1;\n\t\tcase HID_DG_CONTACTMAX:\n\t\t\t \n\t\t\treturn -1;\n\t\tcase HID_DG_TOUCH:\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t\t \n\t\treturn 0;\n\n\tcase HID_UP_BUTTON:\n\t\tcode = BTN_MOUSE + ((usage->hid - 1) & HID_USAGE);\n\t\t \n\t\tif ((app->quirks & MT_QUIRK_WIN8_PTP_BUTTONS) &&\n\t\t    field->application == HID_DG_TOUCHPAD &&\n\t\t    (usage->hid & HID_USAGE) > 1)\n\t\t\tcode--;\n\n\t\tif (field->application == HID_GD_SYSTEM_MULTIAXIS)\n\t\t\tcode = BTN_0  + ((usage->hid - 1) & HID_USAGE);\n\n\t\thid_map_usage(hi, usage, bit, max, EV_KEY, code);\n\t\tif (!*bit)\n\t\t\treturn -1;\n\t\tinput_set_capability(hi->input, EV_KEY, code);\n\t\treturn 1;\n\n\tcase 0xff000000:\n\t\t \n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt_compute_slot(struct mt_device *td, struct mt_application *app,\n\t\t\t   struct mt_usages *slot,\n\t\t\t   struct input_dev *input)\n{\n\t__s32 quirks = app->quirks;\n\n\tif (quirks & MT_QUIRK_SLOT_IS_CONTACTID)\n\t\treturn *slot->contactid;\n\n\tif (quirks & MT_QUIRK_CYPRESS)\n\t\treturn cypress_compute_slot(app, slot);\n\n\tif (quirks & MT_QUIRK_SLOT_IS_CONTACTNUMBER)\n\t\treturn app->num_received;\n\n\tif (quirks & MT_QUIRK_SLOT_IS_CONTACTID_MINUS_ONE)\n\t\treturn *slot->contactid - 1;\n\n\treturn input_mt_get_slot_by_key(input, *slot->contactid);\n}\n\nstatic void mt_release_pending_palms(struct mt_device *td,\n\t\t\t\t     struct mt_application *app,\n\t\t\t\t     struct input_dev *input)\n{\n\tint slotnum;\n\tbool need_sync = false;\n\n\tfor_each_set_bit(slotnum, app->pending_palm_slots, td->maxcontacts) {\n\t\tclear_bit(slotnum, app->pending_palm_slots);\n\n\t\tinput_mt_slot(input, slotnum);\n\t\tinput_mt_report_slot_inactive(input);\n\n\t\tneed_sync = true;\n\t}\n\n\tif (need_sync) {\n\t\tinput_mt_sync_frame(input);\n\t\tinput_sync(input);\n\t}\n}\n\n \nstatic void mt_sync_frame(struct mt_device *td, struct mt_application *app,\n\t\t\t  struct input_dev *input)\n{\n\tif (app->quirks & MT_QUIRK_WIN8_PTP_BUTTONS)\n\t\tinput_event(input, EV_KEY, BTN_LEFT, app->left_button_state);\n\n\tinput_mt_sync_frame(input);\n\tinput_event(input, EV_MSC, MSC_TIMESTAMP, app->timestamp);\n\tinput_sync(input);\n\n\tmt_release_pending_palms(td, app, input);\n\n\tapp->num_received = 0;\n\tapp->left_button_state = 0;\n\n\tif (test_bit(MT_IO_FLAGS_ACTIVE_SLOTS, &td->mt_io_flags))\n\t\tset_bit(MT_IO_FLAGS_PENDING_SLOTS, &td->mt_io_flags);\n\telse\n\t\tclear_bit(MT_IO_FLAGS_PENDING_SLOTS, &td->mt_io_flags);\n\tclear_bit(MT_IO_FLAGS_ACTIVE_SLOTS, &td->mt_io_flags);\n}\n\nstatic int mt_compute_timestamp(struct mt_application *app, __s32 value)\n{\n\tlong delta = value - app->prev_scantime;\n\tunsigned long jdelta = jiffies_to_usecs(jiffies - app->jiffies);\n\n\tapp->jiffies = jiffies;\n\n\tif (delta < 0)\n\t\tdelta += app->scantime_logical_max;\n\n\t \n\tdelta *= 100;\n\n\tif (jdelta > MAX_TIMESTAMP_INTERVAL)\n\t\t \n\t\treturn 0;\n\telse\n\t\treturn app->timestamp + delta;\n}\n\nstatic int mt_touch_event(struct hid_device *hid, struct hid_field *field,\n\t\t\t\tstruct hid_usage *usage, __s32 value)\n{\n\t \n\tif (hid->claimed & HID_CLAIMED_HIDDEV && hid->hiddev_hid_event)\n\t\thid->hiddev_hid_event(hid, field, usage, value);\n\n\treturn 1;\n}\n\nstatic int mt_process_slot(struct mt_device *td, struct input_dev *input,\n\t\t\t    struct mt_application *app,\n\t\t\t    struct mt_usages *slot)\n{\n\tstruct input_mt *mt = input->mt;\n\tstruct hid_device *hdev = td->hdev;\n\t__s32 quirks = app->quirks;\n\tbool valid = true;\n\tbool confidence_state = true;\n\tbool inrange_state = false;\n\tint active;\n\tint slotnum;\n\tint tool = MT_TOOL_FINGER;\n\n\tif (!slot)\n\t\treturn -EINVAL;\n\n\tif ((quirks & MT_QUIRK_CONTACT_CNT_ACCURATE) &&\n\t    app->num_received >= app->num_expected)\n\t\treturn -EAGAIN;\n\n\tif (!(quirks & MT_QUIRK_ALWAYS_VALID)) {\n\t\tif (quirks & MT_QUIRK_VALID_IS_INRANGE)\n\t\t\tvalid = *slot->inrange_state;\n\t\tif (quirks & MT_QUIRK_NOT_SEEN_MEANS_UP)\n\t\t\tvalid = *slot->tip_state;\n\t\tif (quirks & MT_QUIRK_VALID_IS_CONFIDENCE)\n\t\t\tvalid = *slot->confidence_state;\n\n\t\tif (!valid)\n\t\t\treturn 0;\n\t}\n\n\tslotnum = mt_compute_slot(td, app, slot, input);\n\tif (slotnum < 0 || slotnum >= td->maxcontacts)\n\t\treturn 0;\n\n\tif ((quirks & MT_QUIRK_IGNORE_DUPLICATES) && mt) {\n\t\tstruct input_mt_slot *i_slot = &mt->slots[slotnum];\n\n\t\tif (input_mt_is_active(i_slot) &&\n\t\t    input_mt_is_used(mt, i_slot))\n\t\t\treturn -EAGAIN;\n\t}\n\n\tif (quirks & MT_QUIRK_CONFIDENCE)\n\t\tconfidence_state = *slot->confidence_state;\n\n\tif (quirks & MT_QUIRK_HOVERING)\n\t\tinrange_state = *slot->inrange_state;\n\n\tactive = *slot->tip_state || inrange_state;\n\n\tif (app->application == HID_GD_SYSTEM_MULTIAXIS)\n\t\ttool = MT_TOOL_DIAL;\n\telse if (unlikely(!confidence_state)) {\n\t\ttool = MT_TOOL_PALM;\n\t\tif (!active && mt &&\n\t\t    input_mt_is_active(&mt->slots[slotnum])) {\n\t\t\t \n\t\t\tactive = true;\n\t\t\tset_bit(slotnum, app->pending_palm_slots);\n\t\t}\n\t}\n\n\tinput_mt_slot(input, slotnum);\n\tinput_mt_report_slot_state(input, tool, active);\n\tif (active) {\n\t\t \n\t\tint wide = (*slot->w > *slot->h);\n\t\tint major = max(*slot->w, *slot->h);\n\t\tint minor = min(*slot->w, *slot->h);\n\t\tint orientation = wide;\n\t\tint max_azimuth;\n\t\tint azimuth;\n\t\tint x;\n\t\tint y;\n\t\tint cx;\n\t\tint cy;\n\n\t\tif (slot->a != DEFAULT_ZERO) {\n\t\t\t \n\t\t\tazimuth = *slot->a;\n\t\t\tmax_azimuth = input_abs_get_max(input,\n\t\t\t\t\t\t\tABS_MT_ORIENTATION);\n\t\t\tif (azimuth > max_azimuth * 2)\n\t\t\t\tazimuth -= max_azimuth * 4;\n\t\t\torientation = -azimuth;\n\t\t\tif (quirks & MT_QUIRK_ORIENTATION_INVERT)\n\t\t\t\torientation = -orientation;\n\n\t\t}\n\n\t\tif (quirks & MT_QUIRK_TOUCH_SIZE_SCALING) {\n\t\t\t \n\t\t\tmajor = major >> 1;\n\t\t\tminor = minor >> 1;\n\t\t}\n\n\t\tx = hdev->quirks & HID_QUIRK_X_INVERT ?\n\t\t\tinput_abs_get_max(input, ABS_MT_POSITION_X) - *slot->x :\n\t\t\t*slot->x;\n\t\ty = hdev->quirks & HID_QUIRK_Y_INVERT ?\n\t\t\tinput_abs_get_max(input, ABS_MT_POSITION_Y) - *slot->y :\n\t\t\t*slot->y;\n\t\tcx = hdev->quirks & HID_QUIRK_X_INVERT ?\n\t\t\tinput_abs_get_max(input, ABS_MT_POSITION_X) - *slot->cx :\n\t\t\t*slot->cx;\n\t\tcy = hdev->quirks & HID_QUIRK_Y_INVERT ?\n\t\t\tinput_abs_get_max(input, ABS_MT_POSITION_Y) - *slot->cy :\n\t\t\t*slot->cy;\n\n\t\tinput_event(input, EV_ABS, ABS_MT_POSITION_X, x);\n\t\tinput_event(input, EV_ABS, ABS_MT_POSITION_Y, y);\n\t\tinput_event(input, EV_ABS, ABS_MT_TOOL_X, cx);\n\t\tinput_event(input, EV_ABS, ABS_MT_TOOL_Y, cy);\n\t\tinput_event(input, EV_ABS, ABS_MT_DISTANCE, !*slot->tip_state);\n\t\tinput_event(input, EV_ABS, ABS_MT_ORIENTATION, orientation);\n\t\tinput_event(input, EV_ABS, ABS_MT_PRESSURE, *slot->p);\n\t\tinput_event(input, EV_ABS, ABS_MT_TOUCH_MAJOR, major);\n\t\tinput_event(input, EV_ABS, ABS_MT_TOUCH_MINOR, minor);\n\n\t\tset_bit(MT_IO_FLAGS_ACTIVE_SLOTS, &td->mt_io_flags);\n\t}\n\n\treturn 0;\n}\n\nstatic void mt_process_mt_event(struct hid_device *hid,\n\t\t\t\tstruct mt_application *app,\n\t\t\t\tstruct hid_field *field,\n\t\t\t\tstruct hid_usage *usage,\n\t\t\t\t__s32 value,\n\t\t\t\tbool first_packet)\n{\n\t__s32 quirks = app->quirks;\n\tstruct input_dev *input = field->hidinput->input;\n\n\tif (!usage->type || !(hid->claimed & HID_CLAIMED_INPUT))\n\t\treturn;\n\n\tif (quirks & MT_QUIRK_WIN8_PTP_BUTTONS) {\n\n\t\t \n\t\tif (!first_packet)\n\t\t\treturn;\n\n\t\t \n\t\tif (usage->type == EV_KEY && usage->code == BTN_LEFT) {\n\t\t\tapp->left_button_state |= value;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tinput_event(input, usage->type, usage->code, value);\n}\n\nstatic void mt_touch_report(struct hid_device *hid,\n\t\t\t    struct mt_report_data *rdata)\n{\n\tstruct mt_device *td = hid_get_drvdata(hid);\n\tstruct hid_report *report = rdata->report;\n\tstruct mt_application *app = rdata->application;\n\tstruct hid_field *field;\n\tstruct input_dev *input;\n\tstruct mt_usages *slot;\n\tbool first_packet;\n\tunsigned count;\n\tint r, n;\n\tint scantime = 0;\n\tint contact_count = -1;\n\n\t \n\tif (test_and_set_bit_lock(MT_IO_FLAGS_RUNNING, &td->mt_io_flags))\n\t\treturn;\n\n\tscantime = *app->scantime;\n\tapp->timestamp = mt_compute_timestamp(app, scantime);\n\tif (app->raw_cc != DEFAULT_ZERO)\n\t\tcontact_count = *app->raw_cc;\n\n\t \n\tif (contact_count >= 0) {\n\t\t \n\t\tif ((app->quirks & MT_QUIRK_WIN8_PTP_BUTTONS) &&\n\t\t    app->num_received == 0 &&\n\t\t    app->prev_scantime != scantime)\n\t\t\tapp->num_expected = contact_count;\n\t\t \n\t\telse if (contact_count)\n\t\t\tapp->num_expected = contact_count;\n\t}\n\tapp->prev_scantime = scantime;\n\n\tfirst_packet = app->num_received == 0;\n\n\tinput = report->field[0]->hidinput->input;\n\n\tlist_for_each_entry(slot, &app->mt_usages, list) {\n\t\tif (!mt_process_slot(td, input, app, slot))\n\t\t\tapp->num_received++;\n\t}\n\n\tfor (r = 0; r < report->maxfield; r++) {\n\t\tfield = report->field[r];\n\t\tcount = field->report_count;\n\n\t\tif (!(HID_MAIN_ITEM_VARIABLE & field->flags))\n\t\t\tcontinue;\n\n\t\tfor (n = 0; n < count; n++)\n\t\t\tmt_process_mt_event(hid, app, field,\n\t\t\t\t\t    &field->usage[n], field->value[n],\n\t\t\t\t\t    first_packet);\n\t}\n\n\tif (app->num_received >= app->num_expected)\n\t\tmt_sync_frame(td, app, input);\n\n\t \n\tif (app->quirks & MT_QUIRK_STICKY_FINGERS) {\n\t\tif (test_bit(MT_IO_FLAGS_PENDING_SLOTS, &td->mt_io_flags))\n\t\t\tmod_timer(&td->release_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(100));\n\t\telse\n\t\t\tdel_timer(&td->release_timer);\n\t}\n\n\tclear_bit_unlock(MT_IO_FLAGS_RUNNING, &td->mt_io_flags);\n}\n\nstatic int mt_touch_input_configured(struct hid_device *hdev,\n\t\t\t\t     struct hid_input *hi,\n\t\t\t\t     struct mt_application *app)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tstruct mt_class *cls = &td->mtclass;\n\tstruct input_dev *input = hi->input;\n\tint ret;\n\n\tif (!td->maxcontacts)\n\t\ttd->maxcontacts = MT_DEFAULT_MAXCONTACT;\n\n\tmt_post_parse(td, app);\n\tif (td->serial_maybe)\n\t\tmt_post_parse_default_settings(td, app);\n\n\tif (cls->is_indirect)\n\t\tapp->mt_flags |= INPUT_MT_POINTER;\n\n\tif (app->quirks & MT_QUIRK_NOT_SEEN_MEANS_UP)\n\t\tapp->mt_flags |= INPUT_MT_DROP_UNUSED;\n\n\t \n\tif ((app->mt_flags & INPUT_MT_POINTER) &&\n\t    (app->buttons_count == 1))\n\t\ttd->is_buttonpad = true;\n\n\tif (td->is_buttonpad)\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\n\tapp->pending_palm_slots = devm_kcalloc(&hi->input->dev,\n\t\t\t\t\t       BITS_TO_LONGS(td->maxcontacts),\n\t\t\t\t\t       sizeof(long),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!app->pending_palm_slots)\n\t\treturn -ENOMEM;\n\n\tret = input_mt_init_slots(input, td->maxcontacts, app->mt_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tapp->mt_flags = 0;\n\treturn 0;\n}\n\n#define mt_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, \\\n\t\t\t\t\t\t    max, EV_KEY, (c))\nstatic int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tstruct mt_application *application;\n\tstruct mt_report_data *rdata;\n\n\trdata = mt_find_report_data(td, field->report);\n\tif (!rdata) {\n\t\thid_err(hdev, \"failed to allocate data for report\\n\");\n\t\treturn 0;\n\t}\n\n\tapplication = rdata->application;\n\n\t \n\tif (!td->mtclass.export_all_inputs &&\n\t    field->application != HID_DG_TOUCHSCREEN &&\n\t    field->application != HID_DG_PEN &&\n\t    field->application != HID_DG_TOUCHPAD &&\n\t    field->application != HID_GD_KEYBOARD &&\n\t    field->application != HID_GD_SYSTEM_CONTROL &&\n\t    field->application != HID_CP_CONSUMER_CONTROL &&\n\t    field->application != HID_GD_WIRELESS_RADIO_CTLS &&\n\t    field->application != HID_GD_SYSTEM_MULTIAXIS &&\n\t    !(field->application == HID_VD_ASUS_CUSTOM_MEDIA_KEYS &&\n\t      application->quirks & MT_QUIRK_ASUS_CUSTOM_UP))\n\t\treturn -1;\n\n\t \n\tif (field->application == HID_VD_ASUS_CUSTOM_MEDIA_KEYS &&\n\t    application->quirks & MT_QUIRK_ASUS_CUSTOM_UP &&\n\t    (usage->hid & HID_USAGE_PAGE) == HID_UP_CUSTOM) {\n\t\tset_bit(EV_REP, hi->input->evbit);\n\t\tif (field->flags & HID_MAIN_ITEM_VARIABLE)\n\t\t\tfield->flags &= ~HID_MAIN_ITEM_VARIABLE;\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x10: mt_map_key_clear(KEY_BRIGHTNESSDOWN);\tbreak;\n\t\tcase 0x20: mt_map_key_clear(KEY_BRIGHTNESSUP);\t\tbreak;\n\t\tcase 0x35: mt_map_key_clear(KEY_DISPLAY_OFF);\t\tbreak;\n\t\tcase 0x6b: mt_map_key_clear(KEY_F21);\t\t\tbreak;\n\t\tcase 0x6c: mt_map_key_clear(KEY_SLEEP);\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (rdata->is_mt_collection)\n\t\treturn mt_touch_input_mapping(hdev, hi, field, usage, bit, max,\n\t\t\t\t\t      application);\n\n\t \n\tif (field->physical == HID_DG_STYLUS)\n\t\thi->application = HID_DG_STYLUS;\n\n\t \n\treturn 0;\n}\n\nstatic int mt_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tstruct mt_report_data *rdata;\n\n\trdata = mt_find_report_data(td, field->report);\n\tif (rdata && rdata->is_mt_collection) {\n\t\t \n\t\treturn -1;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int mt_event(struct hid_device *hid, struct hid_field *field,\n\t\t\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct mt_device *td = hid_get_drvdata(hid);\n\tstruct mt_report_data *rdata;\n\n\trdata = mt_find_report_data(td, field->report);\n\tif (rdata && rdata->is_mt_collection)\n\t\treturn mt_touch_event(hid, field, usage, value);\n\n\treturn 0;\n}\n\nstatic void mt_report(struct hid_device *hid, struct hid_report *report)\n{\n\tstruct mt_device *td = hid_get_drvdata(hid);\n\tstruct hid_field *field = report->field[0];\n\tstruct mt_report_data *rdata;\n\n\tif (!(hid->claimed & HID_CLAIMED_INPUT))\n\t\treturn;\n\n\trdata = mt_find_report_data(td, report);\n\tif (rdata && rdata->is_mt_collection)\n\t\treturn mt_touch_report(hid, rdata);\n\n\tif (field && field->hidinput && field->hidinput->input)\n\t\tinput_sync(field->hidinput->input);\n}\n\nstatic bool mt_need_to_apply_feature(struct hid_device *hdev,\n\t\t\t\t     struct hid_field *field,\n\t\t\t\t     struct hid_usage *usage,\n\t\t\t\t     enum latency_mode latency,\n\t\t\t\t     bool surface_switch,\n\t\t\t\t     bool button_switch,\n\t\t\t\t     bool *inputmode_found)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tstruct mt_class *cls = &td->mtclass;\n\tstruct hid_report *report = field->report;\n\tunsigned int index = usage->usage_index;\n\tchar *buf;\n\tu32 report_len;\n\tint max;\n\n\tswitch (usage->hid) {\n\tcase HID_DG_INPUTMODE:\n\t\t \n\t\tif (*inputmode_found)\n\t\t\treturn false;\n\n\t\tif (cls->quirks & MT_QUIRK_FORCE_GET_FEATURE) {\n\t\t\treport_len = hid_report_len(report);\n\t\t\tbuf = hid_alloc_report_buf(report, GFP_KERNEL);\n\t\t\tif (!buf) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed to allocate buffer for report\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\thid_hw_raw_request(hdev, report->id, buf, report_len,\n\t\t\t\t\t   HID_FEATURE_REPORT,\n\t\t\t\t\t   HID_REQ_GET_REPORT);\n\t\t\tkfree(buf);\n\t\t}\n\n\t\tfield->value[index] = td->inputmode_value;\n\t\t*inputmode_found = true;\n\t\treturn true;\n\n\tcase HID_DG_CONTACTMAX:\n\t\tif (cls->maxcontacts) {\n\t\t\tmax = min_t(int, field->logical_maximum,\n\t\t\t\t    cls->maxcontacts);\n\t\t\tif (field->value[index] != max) {\n\t\t\t\tfield->value[index] = max;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase HID_DG_LATENCYMODE:\n\t\tfield->value[index] = latency;\n\t\treturn true;\n\n\tcase HID_DG_SURFACESWITCH:\n\t\tfield->value[index] = surface_switch;\n\t\treturn true;\n\n\tcase HID_DG_BUTTONSWITCH:\n\t\tfield->value[index] = button_switch;\n\t\treturn true;\n\t}\n\n\treturn false;  \n}\n\nstatic void mt_set_modes(struct hid_device *hdev, enum latency_mode latency,\n\t\t\t bool surface_switch, bool button_switch)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct hid_usage *usage;\n\tint i, j;\n\tbool update_report;\n\tbool inputmode_found = false;\n\n\trep_enum = &hdev->report_enum[HID_FEATURE_REPORT];\n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tupdate_report = false;\n\n\t\tfor (i = 0; i < rep->maxfield; i++) {\n\t\t\t \n\t\t\tif (rep->field[i]->report_count < 1)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < rep->field[i]->maxusage; j++) {\n\t\t\t\tusage = &rep->field[i]->usage[j];\n\n\t\t\t\tif (mt_need_to_apply_feature(hdev,\n\t\t\t\t\t\t\t     rep->field[i],\n\t\t\t\t\t\t\t     usage,\n\t\t\t\t\t\t\t     latency,\n\t\t\t\t\t\t\t     surface_switch,\n\t\t\t\t\t\t\t     button_switch,\n\t\t\t\t\t\t\t     &inputmode_found))\n\t\t\t\t\tupdate_report = true;\n\t\t\t}\n\t\t}\n\n\t\tif (update_report)\n\t\t\thid_hw_request(hdev, rep, HID_REQ_SET_REPORT);\n\t}\n}\n\nstatic void mt_post_parse_default_settings(struct mt_device *td,\n\t\t\t\t\t   struct mt_application *app)\n{\n\t__s32 quirks = app->quirks;\n\n\t \n\tif (list_is_singular(&app->mt_usages)) {\n\t\tquirks |= MT_QUIRK_ALWAYS_VALID;\n\t\tquirks &= ~MT_QUIRK_NOT_SEEN_MEANS_UP;\n\t\tquirks &= ~MT_QUIRK_VALID_IS_INRANGE;\n\t\tquirks &= ~MT_QUIRK_VALID_IS_CONFIDENCE;\n\t\tquirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;\n\t}\n\n\tapp->quirks = quirks;\n}\n\nstatic void mt_post_parse(struct mt_device *td, struct mt_application *app)\n{\n\tif (!app->have_contact_count)\n\t\tapp->quirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;\n}\n\nstatic int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\tconst char *suffix = NULL;\n\tstruct mt_report_data *rdata;\n\tstruct mt_application *mt_application = NULL;\n\tstruct hid_report *report;\n\tint ret;\n\n\tlist_for_each_entry(report, &hi->reports, hidinput_list) {\n\t\trdata = mt_find_report_data(td, report);\n\t\tif (!rdata) {\n\t\t\thid_err(hdev, \"failed to allocate data for report\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmt_application = rdata->application;\n\n\t\tif (rdata->is_mt_collection) {\n\t\t\tret = mt_touch_input_configured(hdev, hi,\n\t\t\t\t\t\t\tmt_application);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tswitch (hi->application) {\n\tcase HID_GD_KEYBOARD:\n\tcase HID_GD_KEYPAD:\n\tcase HID_GD_MOUSE:\n\tcase HID_DG_TOUCHPAD:\n\tcase HID_GD_SYSTEM_CONTROL:\n\tcase HID_CP_CONSUMER_CONTROL:\n\tcase HID_GD_WIRELESS_RADIO_CTLS:\n\tcase HID_GD_SYSTEM_MULTIAXIS:\n\t\t \n\t\tbreak;\n\tcase HID_DG_TOUCHSCREEN:\n\t\t \n\t\thi->input->name = hdev->name;\n\t\tbreak;\n\tcase HID_VD_ASUS_CUSTOM_MEDIA_KEYS:\n\t\tsuffix = \"Custom Media Keys\";\n\t\tbreak;\n\tcase HID_DG_STYLUS:\n\t\t \n\t\t__set_bit(BTN_STYLUS, hi->input->keybit);\n\t\tbreak;\n\tdefault:\n\t\tsuffix = \"UNKNOWN\";\n\t\tbreak;\n\t}\n\n\tif (suffix)\n\t\thi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t \"%s %s\", hdev->name, suffix);\n\n\treturn 0;\n}\n\nstatic void mt_fix_const_field(struct hid_field *field, unsigned int usage)\n{\n\tif (field->usage[0].hid != usage ||\n\t    !(field->flags & HID_MAIN_ITEM_CONSTANT))\n\t\treturn;\n\n\tfield->flags &= ~HID_MAIN_ITEM_CONSTANT;\n\tfield->flags |= HID_MAIN_ITEM_VARIABLE;\n}\n\nstatic void mt_fix_const_fields(struct hid_device *hdev, unsigned int usage)\n{\n\tstruct hid_report *report;\n\tint i;\n\n\tlist_for_each_entry(report,\n\t\t\t    &hdev->report_enum[HID_INPUT_REPORT].report_list,\n\t\t\t    list) {\n\n\t\tif (!report->maxfield)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < report->maxfield; i++)\n\t\t\tif (report->field[i]->maxusage >= 1)\n\t\t\t\tmt_fix_const_field(report->field[i], usage);\n\t}\n}\n\nstatic void mt_release_contacts(struct hid_device *hid)\n{\n\tstruct hid_input *hidinput;\n\tstruct mt_application *application;\n\tstruct mt_device *td = hid_get_drvdata(hid);\n\n\tlist_for_each_entry(hidinput, &hid->inputs, list) {\n\t\tstruct input_dev *input_dev = hidinput->input;\n\t\tstruct input_mt *mt = input_dev->mt;\n\t\tint i;\n\n\t\tif (mt) {\n\t\t\tfor (i = 0; i < mt->num_slots; i++) {\n\t\t\t\tinput_mt_slot(input_dev, i);\n\t\t\t\tinput_mt_report_slot_inactive(input_dev);\n\t\t\t}\n\t\t\tinput_mt_sync_frame(input_dev);\n\t\t\tinput_sync(input_dev);\n\t\t}\n\t}\n\n\tlist_for_each_entry(application, &td->applications, list) {\n\t\tapplication->num_received = 0;\n\t}\n}\n\nstatic void mt_expired_timeout(struct timer_list *t)\n{\n\tstruct mt_device *td = from_timer(td, t, release_timer);\n\tstruct hid_device *hdev = td->hdev;\n\n\t \n\tif (test_and_set_bit_lock(MT_IO_FLAGS_RUNNING, &td->mt_io_flags))\n\t\treturn;\n\tif (test_bit(MT_IO_FLAGS_PENDING_SLOTS, &td->mt_io_flags))\n\t\tmt_release_contacts(hdev);\n\tclear_bit_unlock(MT_IO_FLAGS_RUNNING, &td->mt_io_flags);\n}\n\nstatic int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret, i;\n\tstruct mt_device *td;\n\tconst struct mt_class *mtclass = mt_classes;  \n\n\tfor (i = 0; mt_classes[i].name ; i++) {\n\t\tif (id->driver_data == mt_classes[i].name) {\n\t\t\tmtclass = &(mt_classes[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttd = devm_kzalloc(&hdev->dev, sizeof(struct mt_device), GFP_KERNEL);\n\tif (!td) {\n\t\tdev_err(&hdev->dev, \"cannot allocate multitouch data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ttd->hdev = hdev;\n\ttd->mtclass = *mtclass;\n\ttd->inputmode_value = MT_INPUTMODE_TOUCHSCREEN;\n\thid_set_drvdata(hdev, td);\n\n\tINIT_LIST_HEAD(&td->applications);\n\tINIT_LIST_HEAD(&td->reports);\n\n\tif (id->vendor == HID_ANY_ID && id->product == HID_ANY_ID)\n\t\ttd->serial_maybe = true;\n\n\n\t \n\tif (hdev->quirks & (HID_QUIRK_X_INVERT | HID_QUIRK_Y_INVERT) &&\n\t    !((hdev->quirks & HID_QUIRK_X_INVERT)\n\t      && (hdev->quirks & HID_QUIRK_Y_INVERT)))\n\t\ttd->mtclass.quirks = MT_QUIRK_ORIENTATION_INVERT;\n\n\t \n\thdev->quirks |= HID_QUIRK_NO_INPUT_SYNC;\n\n\t \n\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\n\tif (id->group != HID_GROUP_MULTITOUCH_WIN_8)\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\n\tif (mtclass->quirks & MT_QUIRK_FORCE_MULTI_INPUT) {\n\t\thdev->quirks &= ~HID_QUIRK_INPUT_PER_APP;\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT;\n\t}\n\n\ttimer_setup(&td->release_timer, mt_expired_timeout, 0);\n\n\tret = hid_parse(hdev);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (mtclass->quirks & MT_QUIRK_FIX_CONST_CONTACT_ID)\n\t\tmt_fix_const_fields(hdev, HID_DG_CONTACTID);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &mt_attribute_group);\n\tif (ret)\n\t\tdev_warn(&hdev->dev, \"Cannot allocate sysfs group for %s\\n\",\n\t\t\t\thdev->name);\n\n\tmt_set_modes(hdev, HID_LATENCY_NORMAL, true, true);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int mt_suspend(struct hid_device *hdev, pm_message_t state)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\n\t \n\tif ((td->mtclass.quirks & MT_QUIRK_DISABLE_WAKEUP) ||\n\t    !hid_hw_may_wakeup(hdev))\n\t\tmt_set_modes(hdev, HID_LATENCY_HIGH, false, false);\n\telse\n\t\tmt_set_modes(hdev, HID_LATENCY_HIGH, true, true);\n\n\treturn 0;\n}\n\nstatic int mt_reset_resume(struct hid_device *hdev)\n{\n\tmt_release_contacts(hdev);\n\tmt_set_modes(hdev, HID_LATENCY_NORMAL, true, true);\n\treturn 0;\n}\n\nstatic int mt_resume(struct hid_device *hdev)\n{\n\t \n\n\thid_hw_idle(hdev, 0, 0, HID_REQ_SET_IDLE);\n\n\tmt_set_modes(hdev, HID_LATENCY_NORMAL, true, true);\n\n\treturn 0;\n}\n#endif\n\nstatic void mt_remove(struct hid_device *hdev)\n{\n\tstruct mt_device *td = hid_get_drvdata(hdev);\n\n\tdel_timer_sync(&td->release_timer);\n\n\tsysfs_remove_group(&hdev->dev.kobj, &mt_attribute_group);\n\thid_hw_stop(hdev);\n}\n\n \nstatic const struct hid_device_id mt_devices[] = {\n\n\t \n\t{ .driver_data = MT_CLS_3M,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_3M,\n\t\t\tUSB_DEVICE_ID_3M1968) },\n\t{ .driver_data = MT_CLS_3M,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_3M,\n\t\t\tUSB_DEVICE_ID_3M2256) },\n\t{ .driver_data = MT_CLS_3M,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_3M,\n\t\t\tUSB_DEVICE_ID_3M3266) },\n\n\t \n\t{ .driver_data = MT_CLS_EXPORT_ALL_INPUTS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_ANTON,\n\t\t\tUSB_DEVICE_ID_ANTON_TOUCH_PAD) },\n\n\t \n\t{ .driver_data = MT_CLS_WIN_8_DISABLE_WAKEUP,\n\t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\t   USB_VENDOR_ID_ASUSTEK,\n\t\t\t   USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD) },\n\n\t \n\t{ .driver_data = MT_CLS_ASUS,\n\t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tUSB_VENDOR_ID_ASUSTEK,\n\t\t\tUSB_DEVICE_ID_ASUSTEK_T304_KEYBOARD) },\n\n\t \n\t{ .driver_data = MT_CLS_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_ATMEL,\n\t\t\tUSB_DEVICE_ID_ATMEL_MXT_DIGITIZER) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_BAANTO,\n\t\t\tUSB_DEVICE_ID_BAANTO_MT_190W2) },\n\n\t \n\t{ .driver_data = MT_CLS_DUAL_INRANGE_CONTACTNUMBER,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_CANDO,\n\t\t\tUSB_DEVICE_ID_CANDO_MULTI_TOUCH) },\n\t{ .driver_data = MT_CLS_DUAL_INRANGE_CONTACTNUMBER,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_CANDO,\n\t\t\tUSB_DEVICE_ID_CANDO_MULTI_TOUCH_15_6) },\n\n\t \n\t{  .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_CHUNGHWAT,\n\t\t\tUSB_DEVICE_ID_CHUNGHWAT_MULTITOUCH) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_CJTOUCH,\n\t\t\tUSB_DEVICE_ID_CJTOUCH_MULTI_TOUCH_0020) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_CJTOUCH,\n\t\t\tUSB_DEVICE_ID_CJTOUCH_MULTI_TOUCH_0040) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_CVTOUCH,\n\t\t\tUSB_DEVICE_ID_CVTOUCH_SCREEN) },\n\n\t \n\t{ .driver_data = MT_CLS_EXPORT_ALL_INPUTS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_EGALAX_TOUCHCONTROLLER) },\n\n\t \n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480D) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480E) },\n\n\t \n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7207) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_720C) },\n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7224) },\n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_722A) },\n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_725E) },\n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7262) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_726B) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72A1) },\n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72AA) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tHID_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72C4) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tHID_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72D0) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72FA) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7302) },\n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7349) },\n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_73F7) },\n\t{ .driver_data = MT_CLS_EGALAX_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_A001) },\n\t{ .driver_data = MT_CLS_EGALAX,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_DWAV,\n\t\t\tUSB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_C002) },\n\n\t \n\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tUSB_VENDOR_ID_ELAN, 0x313a) },\n\n\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tUSB_VENDOR_ID_ELAN, 0x3148) },\n\n\t \n\t{ .driver_data = MT_CLS_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_ELITEGROUP,\n\t\t\tUSB_DEVICE_ID_ELITEGROUP_05D8) },\n\n\t \n\t{ .driver_data = MT_CLS_FLATFROG,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_FLATFROG,\n\t\t\tUSB_DEVICE_ID_MULTITOUCH_3200) },\n\n\t \n\t{ .driver_data = MT_CLS_SERIAL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_CYGNAL,\n\t\t\tUSB_DEVICE_ID_FOCALTECH_FTXXXX_MULTITOUCH) },\n\n\t \n\t{ .driver_data = MT_CLS_GENERALTOUCH_TWOFINGERS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH,\n\t\t\tUSB_DEVICE_ID_GENERAL_TOUCH_WIN7_TWOFINGERS) },\n\t{ .driver_data = MT_CLS_GENERALTOUCH_PWT_TENFINGERS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH,\n\t\t\tUSB_DEVICE_ID_GENERAL_TOUCH_WIN8_PWT_TENFINGERS) },\n\t{ .driver_data = MT_CLS_GENERALTOUCH_TWOFINGERS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH,\n\t\t\tUSB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0101) },\n\t{ .driver_data = MT_CLS_GENERALTOUCH_PWT_TENFINGERS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH,\n\t\t\tUSB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0102) },\n\t{ .driver_data = MT_CLS_GENERALTOUCH_PWT_TENFINGERS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH,\n\t\t\tUSB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0106) },\n\t{ .driver_data = MT_CLS_GENERALTOUCH_PWT_TENFINGERS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH,\n\t\t\tUSB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_010A) },\n\t{ .driver_data = MT_CLS_GENERALTOUCH_PWT_TENFINGERS,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH,\n\t\t\tUSB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_E100) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_BT_DEVICE(USB_VENDOR_ID_FRUCTEL,\n\t\t\tUSB_DEVICE_ID_GAMETEL_MT_MODE) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_GOODTOUCH,\n\t\t\tUSB_DEVICE_ID_GOODTOUCH_000f) },\n\n\t \n\t{ .driver_data = MT_CLS_DUAL_INRANGE_CONTACTID,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_HANVON_ALT,\n\t\t\tUSB_DEVICE_ID_HANVON_ALT_MULTITOUCH) },\n\n\t \n\t{ .driver_data = MT_CLS_VTL,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\t0x347d, 0x7853) },\n\n\t \n\t{  .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_ILITEK,\n\t\t\tUSB_DEVICE_ID_ILITEK_MULTITOUCH) },\n\n\t \n\t{ .driver_data = MT_CLS_LG,\n\t\tHID_USB_DEVICE(USB_VENDOR_ID_LG,\n\t\t\tUSB_DEVICE_ID_LG_MELFAS_MT) },\n\t{ .driver_data = MT_CLS_LG,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_GENERIC,\n\t\t\tUSB_VENDOR_ID_LG, I2C_DEVICE_ID_LG_7010) },\n\n\t \n\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n\t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\t   USB_VENDOR_ID_LENOVO,\n\t\t\t   USB_DEVICE_ID_LENOVO_X1_TAB) },\n\n\t \n\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n\t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\t   USB_VENDOR_ID_LENOVO,\n\t\t\t   USB_DEVICE_ID_LENOVO_X1_TAB3) },\n\n\t \n\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT_NSMU,\n\t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\t   USB_VENDOR_ID_LENOVO,\n\t\t\t   USB_DEVICE_ID_LENOVO_X12_TAB) },\n\n\t \n\t{ .driver_data = MT_CLS_CONFIDENCE_MINUS_ONE,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_ASUS,\n\t\t\tUSB_DEVICE_ID_ASUS_T91MT)},\n\t{ .driver_data = MT_CLS_CONFIDENCE_MINUS_ONE,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_ASUS,\n\t\t\tUSB_DEVICE_ID_ASUSTEK_MULTITOUCH_YFO) },\n\t{ .driver_data = MT_CLS_CONFIDENCE_MINUS_ONE,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_TURBOX,\n\t\t\tUSB_DEVICE_ID_TURBOX_TOUCHSCREEN_MOSART) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_NOVATEK,\n\t\t\tUSB_DEVICE_ID_NOVATEK_PCT) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tUSB_VENDOR_ID_NTRIG, 0x1b05) },\n\n\t \n\t{ .driver_data = MT_CLS_PANASONIC,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_PANASONIC,\n\t\t\tUSB_DEVICE_ID_PANABOARD_UBT780) },\n\t{ .driver_data = MT_CLS_PANASONIC,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_PANASONIC,\n\t\t\tUSB_DEVICE_ID_PANABOARD_UBT880) },\n\n\t \n\t{ .driver_data = MT_CLS_INRANGE_CONTACTNUMBER,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_PIXART,\n\t\t\tUSB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN) },\n\t{ .driver_data = MT_CLS_INRANGE_CONTACTNUMBER,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_PIXART,\n\t\t\tUSB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN1) },\n\t{ .driver_data = MT_CLS_INRANGE_CONTACTNUMBER,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_PIXART,\n\t\t\tUSB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN2) },\n\n\t \n\t{ .driver_data = MT_CLS_DUAL_INRANGE_CONTACTID,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_CANDO,\n\t\t\tUSB_DEVICE_ID_CANDO_PIXCIR_MULTI_TOUCH) },\n\n\t \n\t{ .driver_data = MT_CLS_CONFIDENCE_CONTACT_ID,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_QUANTA,\n\t\t\tUSB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3001) },\n\n\t \n\t{ .driver_data = MT_CLS_RAZER_BLADE_STEALTH,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tUSB_VENDOR_ID_SYNAPTICS, 0x8323) },\n\n\t \n\t{ .driver_data = MT_CLS_SMART_TECH,\n\t\tMT_USB_DEVICE(0x0b8c, 0x0092)},\n\n\t \n\t{ .driver_data = MT_CLS_CONFIDENCE,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_STANTUM_STM,\n\t\t\tUSB_DEVICE_ID_MTP_STM)},\n\n\t \n\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tUSB_VENDOR_ID_SYNAPTICS, 0xcd7e) },\n\n\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tUSB_VENDOR_ID_SYNAPTICS, 0xce08) },\n\n\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n\t\tHID_DEVICE(BUS_I2C, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tUSB_VENDOR_ID_SYNAPTICS, 0xce09) },\n\n\t \n\t{ .driver_data = MT_CLS_TOPSEED,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_TOPSEED2,\n\t\t\tUSB_DEVICE_ID_TOPSEED2_PERIPAD_701) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_TOUCH_INTL,\n\t\t\tUSB_DEVICE_ID_TOUCH_INTL_MULTI_TOUCH) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_UNITEC,\n\t\t\tUSB_DEVICE_ID_UNITEC_USB_TOUCH_0709) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_UNITEC,\n\t\t\tUSB_DEVICE_ID_UNITEC_USB_TOUCH_0A19) },\n\n\t \n\t{ .driver_data = MT_CLS_VTL,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_VTL,\n\t\t\tUSB_DEVICE_ID_VTL_MULTITOUCH_FF3F) },\n\n\t \n\t{ .driver_data = MT_CLS_WIN_8_NO_STICKY_FINGERS,\n\t\tHID_DEVICE(HID_BUS_ANY, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\t   USB_VENDOR_ID_WINBOND, USB_DEVICE_ID_TSTP_MTOUCH) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_WISTRON,\n\t\t\tUSB_DEVICE_ID_WISTRON_OPTICAL_TOUCH) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XAT,\n\t\t\tUSB_DEVICE_ID_XAT_CSR) },\n\n\t \n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_SPX) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_MPX) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_CSR) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_SPX1) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_MPX1) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_CSR1) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_SPX2) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_MPX2) },\n\t{ .driver_data = MT_CLS_NSMU,\n\t\tMT_USB_DEVICE(USB_VENDOR_ID_XIROKU,\n\t\t\tUSB_DEVICE_ID_XIROKU_CSR2) },\n\n\t \n\t{ .driver_data = MT_CLS_GOOGLE,\n\t\tHID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY, USB_VENDOR_ID_GOOGLE,\n\t\t\tUSB_DEVICE_ID_GOOGLE_TOUCH_ROSE) },\n\t{ .driver_data = MT_CLS_GOOGLE,\n\t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8, USB_VENDOR_ID_GOOGLE,\n\t\t\tUSB_DEVICE_ID_GOOGLE_WHISKERS) },\n\n\t \n\t{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_MULTITOUCH, HID_ANY_ID, HID_ANY_ID) },\n\n\t \n\t{  .driver_data = MT_CLS_WIN_8,\n\t\tHID_DEVICE(HID_BUS_ANY, HID_GROUP_MULTITOUCH_WIN_8,\n\t\t\tHID_ANY_ID, HID_ANY_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, mt_devices);\n\nstatic const struct hid_usage_id mt_grabbed_usages[] = {\n\t{ HID_ANY_ID, HID_ANY_ID, HID_ANY_ID },\n\t{ HID_ANY_ID - 1, HID_ANY_ID - 1, HID_ANY_ID - 1}\n};\n\nstatic struct hid_driver mt_driver = {\n\t.name = \"hid-multitouch\",\n\t.id_table = mt_devices,\n\t.probe = mt_probe,\n\t.remove = mt_remove,\n\t.input_mapping = mt_input_mapping,\n\t.input_mapped = mt_input_mapped,\n\t.input_configured = mt_input_configured,\n\t.feature_mapping = mt_feature_mapping,\n\t.usage_table = mt_grabbed_usages,\n\t.event = mt_event,\n\t.report = mt_report,\n#ifdef CONFIG_PM\n\t.suspend = mt_suspend,\n\t.reset_resume = mt_reset_resume,\n\t.resume = mt_resume,\n#endif\n};\nmodule_hid_driver(mt_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}