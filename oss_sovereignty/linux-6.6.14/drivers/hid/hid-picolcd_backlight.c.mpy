{
  "module_name": "hid-picolcd_backlight.c",
  "hash_id": "424a4284f81b6e2b0920c01490b45d1f4441684e7bba188affebfb199f1d68f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-picolcd_backlight.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n\n#include <linux/fb.h>\n#include <linux/backlight.h>\n\n#include \"hid-picolcd.h\"\n\nstatic int picolcd_get_brightness(struct backlight_device *bdev)\n{\n\tstruct picolcd_data *data = bl_get_data(bdev);\n\treturn data->lcd_brightness;\n}\n\nstatic int picolcd_set_brightness(struct backlight_device *bdev)\n{\n\tstruct picolcd_data *data = bl_get_data(bdev);\n\tstruct hid_report *report = picolcd_out_report(REPORT_BRIGHTNESS, data->hdev);\n\tunsigned long flags;\n\n\tif (!report || report->maxfield != 1 || report->field[0]->report_count != 1)\n\t\treturn -ENODEV;\n\n\tdata->lcd_brightness = bdev->props.brightness & 0x0ff;\n\tdata->lcd_power      = bdev->props.power;\n\tspin_lock_irqsave(&data->lock, flags);\n\thid_set_field(report->field[0], 0, data->lcd_power == FB_BLANK_UNBLANK ? data->lcd_brightness : 0);\n\tif (!(data->status & PICOLCD_FAILED))\n\t\thid_hw_request(data->hdev, report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\treturn 0;\n}\n\nstatic int picolcd_check_bl_fb(struct backlight_device *bdev, struct fb_info *fb)\n{\n\treturn fb && fb == picolcd_fbinfo((struct picolcd_data *)bl_get_data(bdev));\n}\n\nstatic const struct backlight_ops picolcd_blops = {\n\t.update_status  = picolcd_set_brightness,\n\t.get_brightness = picolcd_get_brightness,\n\t.check_fb       = picolcd_check_bl_fb,\n};\n\nint picolcd_init_backlight(struct picolcd_data *data, struct hid_report *report)\n{\n\tstruct device *dev = &data->hdev->dev;\n\tstruct backlight_device *bdev;\n\tstruct backlight_properties props;\n\tif (!report)\n\t\treturn -ENODEV;\n\tif (report->maxfield != 1 || report->field[0]->report_count != 1 ||\n\t\t\treport->field[0]->report_size != 8) {\n\t\tdev_err(dev, \"unsupported BRIGHTNESS report\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = 0xff;\n\tbdev = backlight_device_register(dev_name(dev), dev, data,\n\t\t\t&picolcd_blops, &props);\n\tif (IS_ERR(bdev)) {\n\t\tdev_err(dev, \"failed to register backlight\\n\");\n\t\treturn PTR_ERR(bdev);\n\t}\n\tbdev->props.brightness     = 0xff;\n\tdata->lcd_brightness       = 0xff;\n\tdata->backlight            = bdev;\n\tpicolcd_set_brightness(bdev);\n\treturn 0;\n}\n\nvoid picolcd_exit_backlight(struct picolcd_data *data)\n{\n\tstruct backlight_device *bdev = data->backlight;\n\n\tdata->backlight = NULL;\n\tbacklight_device_unregister(bdev);\n}\n\nint picolcd_resume_backlight(struct picolcd_data *data)\n{\n\tif (!data->backlight)\n\t\treturn 0;\n\treturn picolcd_set_brightness(data->backlight);\n}\n\n#ifdef CONFIG_PM\nvoid picolcd_suspend_backlight(struct picolcd_data *data)\n{\n\tint bl_power = data->lcd_power;\n\tif (!data->backlight)\n\t\treturn;\n\n\tdata->backlight->props.power = FB_BLANK_POWERDOWN;\n\tpicolcd_set_brightness(data->backlight);\n\tdata->lcd_power = data->backlight->props.power = bl_power;\n}\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}