{
  "module_name": "hid-google-stadiaff.c",
  "hash_id": "f89ef28882a3f3f090b06df811a0a6171f3ac97cb7e3aa03f413fc0d8a184955",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-google-stadiaff.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define STADIA_FF_REPORT_ID 5\n\nstruct stadiaff_device {\n\tstruct hid_device *hid;\n\tstruct hid_report *report;\n\tspinlock_t lock;\n\tbool removed;\n\tuint16_t strong_magnitude;\n\tuint16_t weak_magnitude;\n\tstruct work_struct work;\n};\n\nstatic void stadiaff_work(struct work_struct *work)\n{\n\tstruct stadiaff_device *stadiaff =\n\t\tcontainer_of(work, struct stadiaff_device, work);\n\tstruct hid_field *rumble_field = stadiaff->report->field[0];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&stadiaff->lock, flags);\n\trumble_field->value[0] = stadiaff->strong_magnitude;\n\trumble_field->value[1] = stadiaff->weak_magnitude;\n\tspin_unlock_irqrestore(&stadiaff->lock, flags);\n\n\thid_hw_request(stadiaff->hid, stadiaff->report, HID_REQ_SET_REPORT);\n}\n\nstatic int stadiaff_play(struct input_dev *dev, void *data,\n\t\t\t struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct stadiaff_device *stadiaff = hid_get_drvdata(hid);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&stadiaff->lock, flags);\n\tif (!stadiaff->removed) {\n\t\tstadiaff->strong_magnitude = effect->u.rumble.strong_magnitude;\n\t\tstadiaff->weak_magnitude = effect->u.rumble.weak_magnitude;\n\t\tschedule_work(&stadiaff->work);\n\t}\n\tspin_unlock_irqrestore(&stadiaff->lock, flags);\n\n\treturn 0;\n}\n\nstatic int stadiaff_init(struct hid_device *hid)\n{\n\tstruct stadiaff_device *stadiaff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput;\n\tstruct input_dev *dev;\n\tint error;\n\n\tif (list_empty(&hid->inputs)) {\n\t\thid_err(hid, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tdev = hidinput->input;\n\n\treport = hid_validate_values(hid, HID_OUTPUT_REPORT,\n\t\t\t\t     STADIA_FF_REPORT_ID, 0, 2);\n\tif (!report)\n\t\treturn -ENODEV;\n\n\tstadiaff = devm_kzalloc(&hid->dev, sizeof(struct stadiaff_device),\n\t\t\t\tGFP_KERNEL);\n\tif (!stadiaff)\n\t\treturn -ENOMEM;\n\n\thid_set_drvdata(hid, stadiaff);\n\n\tinput_set_capability(dev, EV_FF, FF_RUMBLE);\n\n\terror = input_ff_create_memless(dev, NULL, stadiaff_play);\n\tif (error)\n\t\treturn error;\n\n\tstadiaff->removed = false;\n\tstadiaff->hid = hid;\n\tstadiaff->report = report;\n\tINIT_WORK(&stadiaff->work, stadiaff_work);\n\tspin_lock_init(&stadiaff->lock);\n\n\thid_info(hid, \"Force Feedback for Google Stadia controller\\n\");\n\n\treturn 0;\n}\n\nstatic int stadia_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = stadiaff_init(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"force feedback init failed\\n\");\n\t\thid_hw_stop(hdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void stadia_remove(struct hid_device *hid)\n{\n\tstruct stadiaff_device *stadiaff = hid_get_drvdata(hid);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&stadiaff->lock, flags);\n\tstadiaff->removed = true;\n\tspin_unlock_irqrestore(&stadiaff->lock, flags);\n\n\tcancel_work_sync(&stadiaff->work);\n\thid_hw_stop(hid);\n}\n\nstatic const struct hid_device_id stadia_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_STADIA) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_GOOGLE, USB_DEVICE_ID_GOOGLE_STADIA) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, stadia_devices);\n\nstatic struct hid_driver stadia_driver = {\n\t.name = \"stadia\",\n\t.id_table = stadia_devices,\n\t.probe = stadia_probe,\n\t.remove = stadia_remove,\n};\nmodule_hid_driver(stadia_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}