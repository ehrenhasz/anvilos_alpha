{
  "module_name": "hid-sensor-hub.c",
  "hash_id": "bf350c0d71f3107cfd079ade141b877497c1c67a7676cf1b9d0b00e325e1e983",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-sensor-hub.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mfd/core.h>\n#include <linux/list.h>\n#include <linux/hid-sensor-ids.h>\n#include <linux/hid-sensor-hub.h>\n#include \"hid-ids.h\"\n\n#define HID_SENSOR_HUB_ENUM_QUIRK\t0x01\n\n \nstruct sensor_hub_data {\n\tstruct mutex mutex;\n\tspinlock_t lock;\n\tstruct list_head dyn_callback_list;\n\tspinlock_t dyn_callback_lock;\n\tstruct mfd_cell *hid_sensor_hub_client_devs;\n\tint hid_sensor_client_cnt;\n\tint ref_cnt;\n};\n\n \nstruct hid_sensor_hub_callbacks_list {\n\tstruct list_head list;\n\tu32 usage_id;\n\tstruct hid_sensor_hub_device *hsdev;\n\tstruct hid_sensor_hub_callbacks *usage_callback;\n\tvoid *priv;\n};\n\nstatic struct hid_report *sensor_hub_report(int id, struct hid_device *hdev,\n\t\t\t\t\t\tint dir)\n{\n\tstruct hid_report *report;\n\n\tlist_for_each_entry(report, &hdev->report_enum[dir].report_list, list) {\n\t\tif (report->id == id)\n\t\t\treturn report;\n\t}\n\thid_warn(hdev, \"No report with id 0x%x found\\n\", id);\n\n\treturn NULL;\n}\n\nstatic int sensor_hub_get_physical_device_count(struct hid_device *hdev)\n{\n\tint i;\n\tint count = 0;\n\n\tfor (i = 0; i < hdev->maxcollection; ++i) {\n\t\tstruct hid_collection *collection = &hdev->collection[i];\n\t\tif (collection->type == HID_COLLECTION_PHYSICAL ||\n\t\t    collection->type == HID_COLLECTION_APPLICATION)\n\t\t\t++count;\n\t}\n\n\treturn count;\n}\n\nstatic void sensor_hub_fill_attr_info(\n\t\tstruct hid_sensor_hub_attribute_info *info,\n\t\ts32 index, s32 report_id, struct hid_field *field)\n{\n\tinfo->index = index;\n\tinfo->report_id = report_id;\n\tinfo->units = field->unit;\n\tinfo->unit_expo = field->unit_exponent;\n\tinfo->size = (field->report_size * field->report_count)/8;\n\tinfo->logical_minimum = field->logical_minimum;\n\tinfo->logical_maximum = field->logical_maximum;\n}\n\nstatic struct hid_sensor_hub_callbacks *sensor_hub_get_callback(\n\t\t\t\t\tstruct hid_device *hdev,\n\t\t\t\t\tu32 usage_id,\n\t\t\t\t\tint collection_index,\n\t\t\t\t\tstruct hid_sensor_hub_device **hsdev,\n\t\t\t\t\tvoid **priv)\n{\n\tstruct hid_sensor_hub_callbacks_list *callback;\n\tstruct sensor_hub_data *pdata = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\n\tlist_for_each_entry(callback, &pdata->dyn_callback_list, list)\n\t\tif ((callback->usage_id == usage_id ||\n\t\t     callback->usage_id == HID_USAGE_SENSOR_COLLECTION) &&\n\t\t\t(collection_index >=\n\t\t\t\tcallback->hsdev->start_collection_index) &&\n\t\t\t(collection_index <\n\t\t\t\tcallback->hsdev->end_collection_index)) {\n\t\t\t*priv = callback->priv;\n\t\t\t*hsdev = callback->hsdev;\n\t\t\tspin_unlock_irqrestore(&pdata->dyn_callback_lock,\n\t\t\t\t\t       flags);\n\t\t\treturn callback->usage_callback;\n\t\t}\n\tspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\n\n\treturn NULL;\n}\n\nint sensor_hub_register_callback(struct hid_sensor_hub_device *hsdev,\n\t\t\tu32 usage_id,\n\t\t\tstruct hid_sensor_hub_callbacks *usage_callback)\n{\n\tstruct hid_sensor_hub_callbacks_list *callback;\n\tstruct sensor_hub_data *pdata = hid_get_drvdata(hsdev->hdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\n\tlist_for_each_entry(callback, &pdata->dyn_callback_list, list)\n\t\tif (callback->usage_id == usage_id &&\n\t\t\t\t\t\tcallback->hsdev == hsdev) {\n\t\t\tspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\tcallback = kzalloc(sizeof(*callback), GFP_ATOMIC);\n\tif (!callback) {\n\t\tspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\tcallback->hsdev = hsdev;\n\tcallback->usage_callback = usage_callback;\n\tcallback->usage_id = usage_id;\n\tcallback->priv = NULL;\n\t \n\tif (usage_id == HID_USAGE_SENSOR_COLLECTION)\n\t\tlist_add(&callback->list, &pdata->dyn_callback_list);\n\telse\n\t\tlist_add_tail(&callback->list, &pdata->dyn_callback_list);\n\tspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sensor_hub_register_callback);\n\nint sensor_hub_remove_callback(struct hid_sensor_hub_device *hsdev,\n\t\t\t\tu32 usage_id)\n{\n\tstruct hid_sensor_hub_callbacks_list *callback;\n\tstruct sensor_hub_data *pdata = hid_get_drvdata(hsdev->hdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\n\tlist_for_each_entry(callback, &pdata->dyn_callback_list, list)\n\t\tif (callback->usage_id == usage_id &&\n\t\t\t\t\t\tcallback->hsdev == hsdev) {\n\t\t\tlist_del(&callback->list);\n\t\t\tkfree(callback);\n\t\t\tbreak;\n\t\t}\n\tspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sensor_hub_remove_callback);\n\nint sensor_hub_set_feature(struct hid_sensor_hub_device *hsdev, u32 report_id,\n\t\t\t   u32 field_index, int buffer_size, void *buffer)\n{\n\tstruct hid_report *report;\n\tstruct sensor_hub_data *data = hid_get_drvdata(hsdev->hdev);\n\t__s32 *buf32 = buffer;\n\tint i = 0;\n\tint remaining_bytes;\n\t__s32 value;\n\tint ret = 0;\n\n\tmutex_lock(&data->mutex);\n\treport = sensor_hub_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);\n\tif (!report || (field_index >= report->maxfield)) {\n\t\tret = -EINVAL;\n\t\tgoto done_proc;\n\t}\n\n\tremaining_bytes = buffer_size % sizeof(__s32);\n\tbuffer_size = buffer_size / sizeof(__s32);\n\tif (buffer_size) {\n\t\tfor (i = 0; i < buffer_size; ++i) {\n\t\t\tret = hid_set_field(report->field[field_index], i,\n\t\t\t\t\t    (__force __s32)cpu_to_le32(*buf32));\n\t\t\tif (ret)\n\t\t\t\tgoto done_proc;\n\n\t\t\t++buf32;\n\t\t}\n\t}\n\tif (remaining_bytes) {\n\t\tvalue = 0;\n\t\tmemcpy(&value, (u8 *)buf32, remaining_bytes);\n\t\tret = hid_set_field(report->field[field_index], i,\n\t\t\t\t    (__force __s32)cpu_to_le32(value));\n\t\tif (ret)\n\t\t\tgoto done_proc;\n\t}\n\thid_hw_request(hsdev->hdev, report, HID_REQ_SET_REPORT);\n\thid_hw_wait(hsdev->hdev);\n\ndone_proc:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sensor_hub_set_feature);\n\nint sensor_hub_get_feature(struct hid_sensor_hub_device *hsdev, u32 report_id,\n\t\t\t   u32 field_index, int buffer_size, void *buffer)\n{\n\tstruct hid_report *report;\n\tstruct sensor_hub_data *data = hid_get_drvdata(hsdev->hdev);\n\tint report_size;\n\tint ret = 0;\n\tu8 *val_ptr;\n\tint buffer_index = 0;\n\tint i;\n\n\tmemset(buffer, 0, buffer_size);\n\n\tmutex_lock(&data->mutex);\n\treport = sensor_hub_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);\n\tif (!report || (field_index >= report->maxfield) ||\n\t    report->field[field_index]->report_count < 1) {\n\t\tret = -EINVAL;\n\t\tgoto done_proc;\n\t}\n\thid_hw_request(hsdev->hdev, report, HID_REQ_GET_REPORT);\n\thid_hw_wait(hsdev->hdev);\n\n\t \n\treport_size = DIV_ROUND_UP(report->field[field_index]->report_size,\n\t\t\t\t   8) *\n\t\t\t\t   report->field[field_index]->report_count;\n\tif (!report_size) {\n\t\tret = -EINVAL;\n\t\tgoto done_proc;\n\t}\n\tret = min(report_size, buffer_size);\n\n\tval_ptr = (u8 *)report->field[field_index]->value;\n\tfor (i = 0; i < report->field[field_index]->report_count; ++i) {\n\t\tif (buffer_index >= ret)\n\t\t\tbreak;\n\n\t\tmemcpy(&((u8 *)buffer)[buffer_index], val_ptr,\n\t\t       report->field[field_index]->report_size / 8);\n\t\tval_ptr += sizeof(__s32);\n\t\tbuffer_index += (report->field[field_index]->report_size / 8);\n\t}\n\ndone_proc:\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sensor_hub_get_feature);\n\n\nint sensor_hub_input_attr_get_raw_value(struct hid_sensor_hub_device *hsdev,\n\t\t\t\t\tu32 usage_id,\n\t\t\t\t\tu32 attr_usage_id, u32 report_id,\n\t\t\t\t\tenum sensor_hub_read_flags flag,\n\t\t\t\t\tbool is_signed)\n{\n\tstruct sensor_hub_data *data = hid_get_drvdata(hsdev->hdev);\n\tunsigned long flags;\n\tstruct hid_report *report;\n\tint ret_val = 0;\n\n\treport = sensor_hub_report(report_id, hsdev->hdev,\n\t\t\t\t   HID_INPUT_REPORT);\n\tif (!report)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hsdev->mutex_ptr);\n\tif (flag == SENSOR_HUB_SYNC) {\n\t\tmemset(&hsdev->pending, 0, sizeof(hsdev->pending));\n\t\tinit_completion(&hsdev->pending.ready);\n\t\thsdev->pending.usage_id = usage_id;\n\t\thsdev->pending.attr_usage_id = attr_usage_id;\n\t\thsdev->pending.raw_size = 0;\n\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\thsdev->pending.status = true;\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\tmutex_lock(&data->mutex);\n\thid_hw_request(hsdev->hdev, report, HID_REQ_GET_REPORT);\n\tmutex_unlock(&data->mutex);\n\tif (flag == SENSOR_HUB_SYNC) {\n\t\twait_for_completion_interruptible_timeout(\n\t\t\t\t\t\t&hsdev->pending.ready, HZ*5);\n\t\tswitch (hsdev->pending.raw_size) {\n\t\tcase 1:\n\t\t\tif (is_signed)\n\t\t\t\tret_val = *(s8 *)hsdev->pending.raw_data;\n\t\t\telse\n\t\t\t\tret_val = *(u8 *)hsdev->pending.raw_data;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (is_signed)\n\t\t\t\tret_val = *(s16 *)hsdev->pending.raw_data;\n\t\t\telse\n\t\t\t\tret_val = *(u16 *)hsdev->pending.raw_data;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tret_val = *(u32 *)hsdev->pending.raw_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = 0;\n\t\t}\n\t\tkfree(hsdev->pending.raw_data);\n\t\thsdev->pending.status = false;\n\t}\n\tmutex_unlock(hsdev->mutex_ptr);\n\n\treturn ret_val;\n}\nEXPORT_SYMBOL_GPL(sensor_hub_input_attr_get_raw_value);\n\nint hid_sensor_get_usage_index(struct hid_sensor_hub_device *hsdev,\n\t\t\t\tu32 report_id, int field_index, u32 usage_id)\n{\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tint i;\n\n\treport = sensor_hub_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);\n\tif (!report || (field_index >= report->maxfield))\n\t\tgoto done_proc;\n\n\tfield = report->field[field_index];\n\tfor (i = 0; i < field->maxusage; ++i) {\n\t\tif (field->usage[i].hid == usage_id)\n\t\t\treturn field->usage[i].usage_index;\n\t}\n\ndone_proc:\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(hid_sensor_get_usage_index);\n\nint sensor_hub_input_get_attribute_info(struct hid_sensor_hub_device *hsdev,\n\t\t\t\tu8 type,\n\t\t\t\tu32 usage_id,\n\t\t\t\tu32 attr_usage_id,\n\t\t\t\tstruct hid_sensor_hub_attribute_info *info)\n{\n\tint ret = -1;\n\tint i;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_device *hdev = hsdev->hdev;\n\n\t \n\tinfo->usage_id = usage_id;\n\tinfo->attrib_id = attr_usage_id;\n\tinfo->report_id = -1;\n\tinfo->index = -1;\n\tinfo->units = -1;\n\tinfo->unit_expo = -1;\n\n\treport_enum = &hdev->report_enum[type];\n\tlist_for_each_entry(report, &report_enum->report_list, list) {\n\t\tfor (i = 0; i < report->maxfield; ++i) {\n\t\t\tfield = report->field[i];\n\t\t\tif (field->maxusage) {\n\t\t\t\tif ((field->physical == usage_id ||\n\t\t\t\t     field->application == usage_id) &&\n\t\t\t\t\t(field->logical == attr_usage_id ||\n\t\t\t\t\tfield->usage[0].hid ==\n\t\t\t\t\t\t\tattr_usage_id) &&\n\t\t\t\t\t(field->usage[0].collection_index >=\n\t\t\t\t\thsdev->start_collection_index) &&\n\t\t\t\t\t(field->usage[0].collection_index <\n\t\t\t\t\thsdev->end_collection_index)) {\n\n\t\t\t\t\tsensor_hub_fill_attr_info(info, i,\n\t\t\t\t\t\t\t\treport->id,\n\t\t\t\t\t\t\t\tfield);\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sensor_hub_input_get_attribute_info);\n\n#ifdef CONFIG_PM\nstatic int sensor_hub_suspend(struct hid_device *hdev, pm_message_t message)\n{\n\tstruct sensor_hub_data *pdata = hid_get_drvdata(hdev);\n\tstruct hid_sensor_hub_callbacks_list *callback;\n\tunsigned long flags;\n\n\thid_dbg(hdev, \" sensor_hub_suspend\\n\");\n\tspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\n\tlist_for_each_entry(callback, &pdata->dyn_callback_list, list) {\n\t\tif (callback->usage_callback->suspend)\n\t\t\tcallback->usage_callback->suspend(\n\t\t\t\t\tcallback->hsdev, callback->priv);\n\t}\n\tspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\n\n\treturn 0;\n}\n\nstatic int sensor_hub_resume(struct hid_device *hdev)\n{\n\tstruct sensor_hub_data *pdata = hid_get_drvdata(hdev);\n\tstruct hid_sensor_hub_callbacks_list *callback;\n\tunsigned long flags;\n\n\thid_dbg(hdev, \" sensor_hub_resume\\n\");\n\tspin_lock_irqsave(&pdata->dyn_callback_lock, flags);\n\tlist_for_each_entry(callback, &pdata->dyn_callback_list, list) {\n\t\tif (callback->usage_callback->resume)\n\t\t\tcallback->usage_callback->resume(\n\t\t\t\t\tcallback->hsdev, callback->priv);\n\t}\n\tspin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);\n\n\treturn 0;\n}\n\nstatic int sensor_hub_reset_resume(struct hid_device *hdev)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic int sensor_hub_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tint i;\n\tu8 *ptr;\n\tint sz;\n\tstruct sensor_hub_data *pdata = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tstruct hid_sensor_hub_callbacks *callback = NULL;\n\tstruct hid_collection *collection = NULL;\n\tvoid *priv = NULL;\n\tstruct hid_sensor_hub_device *hsdev = NULL;\n\n\thid_dbg(hdev, \"sensor_hub_raw_event report id:0x%x size:%d type:%d\\n\",\n\t\t\t report->id, size, report->type);\n\thid_dbg(hdev, \"maxfield:%d\\n\", report->maxfield);\n\tif (report->type != HID_INPUT_REPORT)\n\t\treturn 1;\n\n\tptr = raw_data;\n\tif (report->id)\n\t\tptr++;  \n\n\tspin_lock_irqsave(&pdata->lock, flags);\n\n\tfor (i = 0; i < report->maxfield; ++i) {\n\t\thid_dbg(hdev, \"%d collection_index:%x hid:%x sz:%x\\n\",\n\t\t\t\ti, report->field[i]->usage->collection_index,\n\t\t\t\treport->field[i]->usage->hid,\n\t\t\t\t(report->field[i]->report_size *\n\t\t\t\t\treport->field[i]->report_count)/8);\n\t\tsz = (report->field[i]->report_size *\n\t\t\t\t\treport->field[i]->report_count)/8;\n\t\tcollection = &hdev->collection[\n\t\t\t\treport->field[i]->usage->collection_index];\n\t\thid_dbg(hdev, \"collection->usage %x\\n\",\n\t\t\t\t\tcollection->usage);\n\n\t\tcallback = sensor_hub_get_callback(hdev,\n\t\t\t\treport->field[i]->physical ? report->field[i]->physical :\n\t\t\t\t\t\t\t     report->field[i]->application,\n\t\t\t\treport->field[i]->usage[0].collection_index,\n\t\t\t\t&hsdev, &priv);\n\t\tif (!callback) {\n\t\t\tptr += sz;\n\t\t\tcontinue;\n\t\t}\n\t\tif (hsdev->pending.status && (hsdev->pending.attr_usage_id ==\n\t\t\t\t\t      report->field[i]->usage->hid ||\n\t\t\t\t\t      hsdev->pending.attr_usage_id ==\n\t\t\t\t\t      report->field[i]->logical)) {\n\t\t\thid_dbg(hdev, \"data was pending ...\\n\");\n\t\t\thsdev->pending.raw_data = kmemdup(ptr, sz, GFP_ATOMIC);\n\t\t\tif (hsdev->pending.raw_data)\n\t\t\t\thsdev->pending.raw_size = sz;\n\t\t\telse\n\t\t\t\thsdev->pending.raw_size = 0;\n\t\t\tcomplete(&hsdev->pending.ready);\n\t\t}\n\t\tif (callback->capture_sample) {\n\t\t\tif (report->field[i]->logical)\n\t\t\t\tcallback->capture_sample(hsdev,\n\t\t\t\t\treport->field[i]->logical, sz, ptr,\n\t\t\t\t\tcallback->pdev);\n\t\t\telse\n\t\t\t\tcallback->capture_sample(hsdev,\n\t\t\t\t\treport->field[i]->usage->hid, sz, ptr,\n\t\t\t\t\tcallback->pdev);\n\t\t}\n\t\tptr += sz;\n\t}\n\tif (callback && collection && callback->send_event)\n\t\tcallback->send_event(hsdev, collection->usage,\n\t\t\t\tcallback->pdev);\n\tspin_unlock_irqrestore(&pdata->lock, flags);\n\n\treturn 1;\n}\n\nint sensor_hub_device_open(struct hid_sensor_hub_device *hsdev)\n{\n\tint ret = 0;\n\tstruct sensor_hub_data *data =  hid_get_drvdata(hsdev->hdev);\n\n\tmutex_lock(&data->mutex);\n\tif (!data->ref_cnt) {\n\t\tret = hid_hw_open(hsdev->hdev);\n\t\tif (ret) {\n\t\t\thid_err(hsdev->hdev, \"failed to open hid device\\n\");\n\t\t\tmutex_unlock(&data->mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdata->ref_cnt++;\n\tmutex_unlock(&data->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sensor_hub_device_open);\n\nvoid sensor_hub_device_close(struct hid_sensor_hub_device *hsdev)\n{\n\tstruct sensor_hub_data *data =  hid_get_drvdata(hsdev->hdev);\n\n\tmutex_lock(&data->mutex);\n\tdata->ref_cnt--;\n\tif (!data->ref_cnt)\n\t\thid_hw_close(hsdev->hdev);\n\tmutex_unlock(&data->mutex);\n}\nEXPORT_SYMBOL_GPL(sensor_hub_device_close);\n\nstatic __u8 *sensor_hub_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\t \n\tif (hdev->product == USB_DEVICE_ID_TEXAS_INSTRUMENTS_LENOVO_YOGA &&\n\t\t*rsize == 2558 && rdesc[913] == 0x17 && rdesc[914] == 0x40 &&\n\t\trdesc[915] == 0x81 && rdesc[916] == 0x08 &&\n\t\trdesc[917] == 0x00 && rdesc[918] == 0x27 &&\n\t\trdesc[921] == 0x07 && rdesc[922] == 0x00) {\n\t\t \n\t\trdesc[914] = rdesc[935] = rdesc[956] = 0xc0;\n\t\trdesc[915] = rdesc[936] = rdesc[957] = 0x7e;\n\t\trdesc[916] = rdesc[937] = rdesc[958] = 0xf7;\n\t\trdesc[917] = rdesc[938] = rdesc[959] = 0xff;\n\t}\n\n\treturn rdesc;\n}\n\nstatic int sensor_hub_probe(struct hid_device *hdev,\n\t\t\t\tconst struct hid_device_id *id)\n{\n\tint ret;\n\tstruct sensor_hub_data *sd;\n\tint i;\n\tchar *name;\n\tint dev_cnt;\n\tstruct hid_sensor_hub_device *hsdev;\n\tstruct hid_sensor_hub_device *last_hsdev = NULL;\n\tstruct hid_sensor_hub_device *collection_hsdev = NULL;\n\n\tsd = devm_kzalloc(&hdev->dev, sizeof(*sd), GFP_KERNEL);\n\tif (!sd) {\n\t\thid_err(hdev, \"cannot allocate Sensor data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, sd);\n\n\tspin_lock_init(&sd->lock);\n\tspin_lock_init(&sd->dyn_callback_lock);\n\tmutex_init(&sd->mutex);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\tINIT_LIST_HEAD(&hdev->inputs);\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT | HID_CONNECT_DRIVER);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\tINIT_LIST_HEAD(&sd->dyn_callback_list);\n\tsd->hid_sensor_client_cnt = 0;\n\n\tdev_cnt = sensor_hub_get_physical_device_count(hdev);\n\tif (dev_cnt > HID_MAX_PHY_DEVICES) {\n\t\thid_err(hdev, \"Invalid Physical device count\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_stop_hw;\n\t}\n\tsd->hid_sensor_hub_client_devs = devm_kcalloc(&hdev->dev,\n\t\t\t\t\t\t      dev_cnt,\n\t\t\t\t\t\t      sizeof(struct mfd_cell),\n\t\t\t\t\t\t      GFP_KERNEL);\n\tif (sd->hid_sensor_hub_client_devs == NULL) {\n\t\thid_err(hdev, \"Failed to allocate memory for mfd cells\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tfor (i = 0; i < hdev->maxcollection; ++i) {\n\t\tstruct hid_collection *collection = &hdev->collection[i];\n\n\t\tif (collection->type == HID_COLLECTION_PHYSICAL ||\n\t\t    collection->type == HID_COLLECTION_APPLICATION) {\n\n\t\t\thsdev = devm_kzalloc(&hdev->dev, sizeof(*hsdev),\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!hsdev) {\n\t\t\t\thid_err(hdev, \"cannot allocate hid_sensor_hub_device\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_stop_hw;\n\t\t\t}\n\t\t\thsdev->hdev = hdev;\n\t\t\thsdev->vendor_id = hdev->vendor;\n\t\t\thsdev->product_id = hdev->product;\n\t\t\thsdev->usage = collection->usage;\n\t\t\thsdev->mutex_ptr = devm_kzalloc(&hdev->dev,\n\t\t\t\t\t\t\tsizeof(struct mutex),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!hsdev->mutex_ptr) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_stop_hw;\n\t\t\t}\n\t\t\tmutex_init(hsdev->mutex_ptr);\n\t\t\thsdev->start_collection_index = i;\n\t\t\tif (last_hsdev)\n\t\t\t\tlast_hsdev->end_collection_index = i;\n\t\t\tlast_hsdev = hsdev;\n\t\t\tname = devm_kasprintf(&hdev->dev, GFP_KERNEL,\n\t\t\t\t\t      \"HID-SENSOR-%x\",\n\t\t\t\t\t      collection->usage);\n\t\t\tif (name == NULL) {\n\t\t\t\thid_err(hdev, \"Failed MFD device name\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_stop_hw;\n\t\t\t}\n\t\t\tsd->hid_sensor_hub_client_devs[\n\t\t\t\tsd->hid_sensor_client_cnt].name = name;\n\t\t\tsd->hid_sensor_hub_client_devs[\n\t\t\t\tsd->hid_sensor_client_cnt].platform_data =\n\t\t\t\t\t\t\thsdev;\n\t\t\tsd->hid_sensor_hub_client_devs[\n\t\t\t\tsd->hid_sensor_client_cnt].pdata_size =\n\t\t\t\t\t\t\tsizeof(*hsdev);\n\t\t\thid_dbg(hdev, \"Adding %s:%d\\n\", name,\n\t\t\t\t\thsdev->start_collection_index);\n\t\t\tsd->hid_sensor_client_cnt++;\n\t\t\tif (collection_hsdev)\n\t\t\t\tcollection_hsdev->end_collection_index = i;\n\t\t\tif (collection->type == HID_COLLECTION_APPLICATION &&\n\t\t\t    collection->usage == HID_USAGE_SENSOR_COLLECTION)\n\t\t\t\tcollection_hsdev = hsdev;\n\t\t}\n\t}\n\tif (last_hsdev)\n\t\tlast_hsdev->end_collection_index = i;\n\tif (collection_hsdev)\n\t\tcollection_hsdev->end_collection_index = i;\n\n\tret = mfd_add_hotplug_devices(&hdev->dev,\n\t\t\tsd->hid_sensor_hub_client_devs,\n\t\t\tsd->hid_sensor_client_cnt);\n\tif (ret < 0)\n\t\tgoto err_stop_hw;\n\n\treturn ret;\n\nerr_stop_hw:\n\thid_hw_stop(hdev);\n\n\treturn ret;\n}\n\nstatic void sensor_hub_remove(struct hid_device *hdev)\n{\n\tstruct sensor_hub_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint i;\n\n\thid_dbg(hdev, \" hardware removed\\n\");\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n\tspin_lock_irqsave(&data->lock, flags);\n\tfor (i = 0; i < data->hid_sensor_client_cnt; ++i) {\n\t\tstruct hid_sensor_hub_device *hsdev =\n\t\t\tdata->hid_sensor_hub_client_devs[i].platform_data;\n\t\tif (hsdev->pending.status)\n\t\t\tcomplete(&hsdev->pending.ready);\n\t}\n\tspin_unlock_irqrestore(&data->lock, flags);\n\tmfd_remove_devices(&hdev->dev);\n\tmutex_destroy(&data->mutex);\n}\n\nstatic const struct hid_device_id sensor_hub_devices[] = {\n\t{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, HID_ANY_ID,\n\t\t     HID_ANY_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, sensor_hub_devices);\n\nstatic struct hid_driver sensor_hub_driver = {\n\t.name = \"hid-sensor-hub\",\n\t.id_table = sensor_hub_devices,\n\t.probe = sensor_hub_probe,\n\t.remove = sensor_hub_remove,\n\t.raw_event = sensor_hub_raw_event,\n\t.report_fixup = sensor_hub_report_fixup,\n#ifdef CONFIG_PM\n\t.suspend = sensor_hub_suspend,\n\t.resume = sensor_hub_resume,\n\t.reset_resume = sensor_hub_reset_resume,\n#endif\n};\nmodule_hid_driver(sensor_hub_driver);\n\nMODULE_DESCRIPTION(\"HID Sensor Hub driver\");\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}