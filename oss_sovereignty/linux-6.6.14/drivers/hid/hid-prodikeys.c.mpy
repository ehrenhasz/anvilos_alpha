{
  "module_name": "hid-prodikeys.c",
  "hash_id": "dd6f449f7aaf36062fc6a88b471ae1b6a5f95006776be8d9e565ebb523cf04d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-prodikeys.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n#include <linux/hid.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/rawmidi.h>\n#include \"hid-ids.h\"\n\n\n#define pk_debug(format, arg...) \\\n\tpr_debug(\"hid-prodikeys: \" format \"\\n\" , ## arg)\n#define pk_error(format, arg...) \\\n\tpr_err(\"hid-prodikeys: \" format \"\\n\" , ## arg)\n\nstruct pcmidi_snd;\n\nstruct pk_device {\n\tunsigned long\t\tquirks;\n\n\tstruct hid_device\t*hdev;\n\tstruct pcmidi_snd\t*pm;  \n};\n\nstruct pcmidi_sustain {\n\tunsigned long\t\tin_use;\n\tstruct pcmidi_snd\t*pm;\n\tstruct timer_list\ttimer;\n\tunsigned char\t\tstatus;\n\tunsigned char\t\tnote;\n\tunsigned char\t\tvelocity;\n};\n\n#define PCMIDI_SUSTAINED_MAX\t32\nstruct pcmidi_snd {\n\tstruct pk_device\t\t*pk;\n\tunsigned short\t\t\tifnum;\n\tstruct hid_report\t\t*pcmidi_report6;\n\tstruct input_dev\t\t*input_ep82;\n\tunsigned short\t\t\tmidi_mode;\n\tunsigned short\t\t\tmidi_sustain_mode;\n\tunsigned short\t\t\tmidi_sustain;\n\tunsigned short\t\t\tmidi_channel;\n\tshort\t\t\t\tmidi_octave;\n\tstruct pcmidi_sustain\t\tsustained_notes[PCMIDI_SUSTAINED_MAX];\n\tunsigned short\t\t\tfn_state;\n\tunsigned short\t\t\tlast_key[24];\n\tspinlock_t\t\t\trawmidi_in_lock;\n\tstruct snd_card\t\t\t*card;\n\tstruct snd_rawmidi\t\t*rwmidi;\n\tstruct snd_rawmidi_substream\t*in_substream;\n\tstruct snd_rawmidi_substream\t*out_substream;\n\tunsigned long\t\t\tin_triggered;\n\tunsigned long\t\t\tout_active;\n};\n\n#define PK_QUIRK_NOGET\t0x00010000\n#define PCMIDI_MIDDLE_C 60\n#define PCMIDI_CHANNEL_MIN 0\n#define PCMIDI_CHANNEL_MAX 15\n#define PCMIDI_OCTAVE_MIN (-2)\n#define PCMIDI_OCTAVE_MAX 2\n#define PCMIDI_SUSTAIN_MIN 0\n#define PCMIDI_SUSTAIN_MAX 5000\n\nstatic const char shortname[] = \"PC-MIDI\";\nstatic const char longname[] = \"Prodikeys PC-MIDI Keyboard\";\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nmodule_param_array(id, charp, NULL, 0444);\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the PC-MIDI virtual audio driver\");\nMODULE_PARM_DESC(id, \"ID string for the PC-MIDI virtual audio driver\");\nMODULE_PARM_DESC(enable, \"Enable for the PC-MIDI virtual audio driver\");\n\n\n \nstatic ssize_t show_channel(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\n\tdbg_hid(\"pcmidi sysfs read channel=%u\\n\", pk->pm->midi_channel);\n\n\treturn sprintf(buf, \"%u (min:%u, max:%u)\\n\", pk->pm->midi_channel,\n\t\tPCMIDI_CHANNEL_MIN, PCMIDI_CHANNEL_MAX);\n}\n\n \nstatic ssize_t store_channel(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\n\tunsigned channel = 0;\n\n\tif (sscanf(buf, \"%u\", &channel) > 0 && channel <= PCMIDI_CHANNEL_MAX) {\n\t\tdbg_hid(\"pcmidi sysfs write channel=%u\\n\", channel);\n\t\tpk->pm->midi_channel = channel;\n\t\treturn strlen(buf);\n\t}\n\treturn -EINVAL;\n}\n\nstatic DEVICE_ATTR(channel, S_IRUGO | S_IWUSR | S_IWGRP , show_channel,\n\t\tstore_channel);\n\nstatic struct device_attribute *sysfs_device_attr_channel = {\n\t\t&dev_attr_channel,\n\t\t};\n\n \nstatic ssize_t show_sustain(struct device *dev,\n struct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\n\tdbg_hid(\"pcmidi sysfs read sustain=%u\\n\", pk->pm->midi_sustain);\n\n\treturn sprintf(buf, \"%u (off:%u, max:%u (ms))\\n\", pk->pm->midi_sustain,\n\t\tPCMIDI_SUSTAIN_MIN, PCMIDI_SUSTAIN_MAX);\n}\n\n \nstatic ssize_t store_sustain(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\n\tunsigned sustain = 0;\n\n\tif (sscanf(buf, \"%u\", &sustain) > 0 && sustain <= PCMIDI_SUSTAIN_MAX) {\n\t\tdbg_hid(\"pcmidi sysfs write sustain=%u\\n\", sustain);\n\t\tpk->pm->midi_sustain = sustain;\n\t\tpk->pm->midi_sustain_mode =\n\t\t\t(0 == sustain || !pk->pm->midi_mode) ? 0 : 1;\n\t\treturn strlen(buf);\n\t}\n\treturn -EINVAL;\n}\n\nstatic DEVICE_ATTR(sustain, S_IRUGO | S_IWUSR | S_IWGRP, show_sustain,\n\t\tstore_sustain);\n\nstatic struct device_attribute *sysfs_device_attr_sustain = {\n\t\t&dev_attr_sustain,\n\t\t};\n\n \nstatic ssize_t show_octave(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\n\tdbg_hid(\"pcmidi sysfs read octave=%d\\n\", pk->pm->midi_octave);\n\n\treturn sprintf(buf, \"%d (min:%d, max:%d)\\n\", pk->pm->midi_octave,\n\t\tPCMIDI_OCTAVE_MIN, PCMIDI_OCTAVE_MAX);\n}\n\n \nstatic ssize_t store_octave(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\n\tint octave = 0;\n\n\tif (sscanf(buf, \"%d\", &octave) > 0 &&\n\t\toctave >= PCMIDI_OCTAVE_MIN && octave <= PCMIDI_OCTAVE_MAX) {\n\t\tdbg_hid(\"pcmidi sysfs write octave=%d\\n\", octave);\n\t\tpk->pm->midi_octave = octave;\n\t\treturn strlen(buf);\n\t}\n\treturn -EINVAL;\n}\n\nstatic DEVICE_ATTR(octave, S_IRUGO | S_IWUSR | S_IWGRP, show_octave,\n\t\tstore_octave);\n\nstatic struct device_attribute *sysfs_device_attr_octave = {\n\t\t&dev_attr_octave,\n\t\t};\n\n\nstatic void pcmidi_send_note(struct pcmidi_snd *pm,\n\tunsigned char status, unsigned char note, unsigned char velocity)\n{\n\tunsigned long flags;\n\tunsigned char buffer[3];\n\n\tbuffer[0] = status;\n\tbuffer[1] = note;\n\tbuffer[2] = velocity;\n\n\tspin_lock_irqsave(&pm->rawmidi_in_lock, flags);\n\n\tif (!pm->in_substream)\n\t\tgoto drop_note;\n\tif (!test_bit(pm->in_substream->number, &pm->in_triggered))\n\t\tgoto drop_note;\n\n\tsnd_rawmidi_receive(pm->in_substream, buffer, 3);\n\ndrop_note:\n\tspin_unlock_irqrestore(&pm->rawmidi_in_lock, flags);\n\n\treturn;\n}\n\nstatic void pcmidi_sustained_note_release(struct timer_list *t)\n{\n\tstruct pcmidi_sustain *pms = from_timer(pms, t, timer);\n\n\tpcmidi_send_note(pms->pm, pms->status, pms->note, pms->velocity);\n\tpms->in_use = 0;\n}\n\nstatic void init_sustain_timers(struct pcmidi_snd *pm)\n{\n\tstruct pcmidi_sustain *pms;\n\tunsigned i;\n\n\tfor (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {\n\t\tpms = &pm->sustained_notes[i];\n\t\tpms->in_use = 0;\n\t\tpms->pm = pm;\n\t\ttimer_setup(&pms->timer, pcmidi_sustained_note_release, 0);\n\t}\n}\n\nstatic void stop_sustain_timers(struct pcmidi_snd *pm)\n{\n\tstruct pcmidi_sustain *pms;\n\tunsigned i;\n\n\tfor (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {\n\t\tpms = &pm->sustained_notes[i];\n\t\tpms->in_use = 1;\n\t\tdel_timer_sync(&pms->timer);\n\t}\n}\n\nstatic int pcmidi_get_output_report(struct pcmidi_snd *pm)\n{\n\tstruct hid_device *hdev = pm->pk->hdev;\n\tstruct hid_report *report;\n\n\tlist_for_each_entry(report,\n\t\t&hdev->report_enum[HID_OUTPUT_REPORT].report_list, list) {\n\t\tif (!(6 == report->id))\n\t\t\tcontinue;\n\n\t\tif (report->maxfield < 1) {\n\t\t\thid_err(hdev, \"output report is empty\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (report->field[0]->report_count != 2) {\n\t\t\thid_err(hdev, \"field count too low\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tpm->pcmidi_report6 = report;\n\t\treturn 0;\n\t}\n\t \n\treturn -ENODEV;\n}\n\nstatic void pcmidi_submit_output_report(struct pcmidi_snd *pm, int state)\n{\n\tstruct hid_device *hdev = pm->pk->hdev;\n\tstruct hid_report *report = pm->pcmidi_report6;\n\treport->field[0]->value[0] = 0x01;\n\treport->field[0]->value[1] = state;\n\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n}\n\nstatic int pcmidi_handle_report1(struct pcmidi_snd *pm, u8 *data)\n{\n\tu32 bit_mask;\n\n\tbit_mask = data[1];\n\tbit_mask = (bit_mask << 8) | data[2];\n\tbit_mask = (bit_mask << 8) | data[3];\n\n\tdbg_hid(\"pcmidi mode: %d\\n\", pm->midi_mode);\n\n\t \n\tif (pm->midi_mode && bit_mask == 0x004000) {\n\t\t \n\t\tpm->midi_octave--;\n\t\tif (pm->midi_octave < -2)\n\t\t\tpm->midi_octave = -2;\n\t\tdbg_hid(\"pcmidi mode: %d octave: %d\\n\",\n\t\t\tpm->midi_mode, pm->midi_octave);\n\t\treturn 1;\n\t}\n\t \n\telse if (pm->midi_mode && bit_mask == 0x000004) {\n\t\t \n\t\tpm->midi_sustain_mode ^= 0x1;\n\t\treturn 1;\n\t}\n\n\treturn 0;  \n}\n\nstatic int pcmidi_handle_report3(struct pcmidi_snd *pm, u8 *data, int size)\n{\n\tstruct pcmidi_sustain *pms;\n\tunsigned i, j;\n\tunsigned char status, note, velocity;\n\n\tunsigned num_notes = (size-1)/2;\n\tfor (j = 0; j < num_notes; j++)\t{\n\t\tnote = data[j*2+1];\n\t\tvelocity = data[j*2+2];\n\n\t\tif (note < 0x81) {  \n\t\t\tstatus = 128 + 16 + pm->midi_channel;  \n\t\t\tnote = note - 0x54 + PCMIDI_MIDDLE_C +\n\t\t\t\t(pm->midi_octave * 12);\n\t\t\tif (0 == velocity)\n\t\t\t\tvelocity = 1;  \n\t\t} else {  \n\t\t\tstatus = 128 + pm->midi_channel;  \n\t\t\tnote = note - 0x94 + PCMIDI_MIDDLE_C +\n\t\t\t\t(pm->midi_octave*12);\n\n\t\t\tif (pm->midi_sustain_mode) {\n\t\t\t\tfor (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {\n\t\t\t\t\tpms = &pm->sustained_notes[i];\n\t\t\t\t\tif (!pms->in_use) {\n\t\t\t\t\t\tpms->status = status;\n\t\t\t\t\t\tpms->note = note;\n\t\t\t\t\t\tpms->velocity = velocity;\n\t\t\t\t\t\tpms->in_use = 1;\n\n\t\t\t\t\t\tmod_timer(&pms->timer,\n\t\t\t\t\t\t\tjiffies +\n\t\t\t\t\tmsecs_to_jiffies(pm->midi_sustain));\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpcmidi_send_note(pm, status, note, velocity);\n\t}\n\n\treturn 1;\n}\n\nstatic int pcmidi_handle_report4(struct pcmidi_snd *pm, u8 *data)\n{\n\tunsigned\tkey;\n\tu32\t\tbit_mask;\n\tu32\t\tbit_index;\n\n\tbit_mask = data[1];\n\tbit_mask = (bit_mask << 8) | data[2];\n\tbit_mask = (bit_mask << 8) | data[3];\n\n\t \n\tfor (bit_index = 0; bit_index < 24; bit_index++) {\n\t\tif (!((0x01 << bit_index) & bit_mask)) {\n\t\t\tinput_event(pm->input_ep82, EV_KEY,\n\t\t\t\tpm->last_key[bit_index], 0);\n\t\t\tpm->last_key[bit_index] = 0;\n\t\t}\n\t}\n\n\t \n\tfor (bit_index = 0; bit_index < 24; bit_index++) {\n\t\tkey = 0;\n\t\tswitch ((0x01 << bit_index) & bit_mask) {\n\t\tcase 0x000010:  \n\t\t\tpm->fn_state ^= 0x000010;\n\t\t\tif (pm->fn_state)\n\t\t\t\tpcmidi_submit_output_report(pm, 0xc5);\n\t\t\telse\n\t\t\t\tpcmidi_submit_output_report(pm, 0xc6);\n\t\t\tcontinue;\n\t\tcase 0x020000:  \n\t\t\tpcmidi_submit_output_report(pm, 0xc1);\n\t\t\tpm->midi_mode ^= 0x01;\n\n\t\t\tdbg_hid(\"pcmidi mode: %d\\n\", pm->midi_mode);\n\t\t\tcontinue;\n\t\tcase 0x100000:  \n\t\t\tdbg_hid(\"pcmidi mode: %d\\n\", pm->midi_mode);\n\t\t\tif (pm->midi_mode) {\n\t\t\t\tpm->midi_octave++;\n\t\t\t\tif (pm->midi_octave > 2)\n\t\t\t\t\tpm->midi_octave = 2;\n\t\t\t\tdbg_hid(\"pcmidi mode: %d octave: %d\\n\",\n\t\t\t\t\tpm->midi_mode, pm->midi_octave);\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tkey = KEY_MESSENGER;\n\t\t\tbreak;\n\t\tcase 0x400000:\n\t\t\tkey = KEY_CALENDAR;\n\t\t\tbreak;\n\t\tcase 0x080000:\n\t\t\tkey = KEY_ADDRESSBOOK;\n\t\t\tbreak;\n\t\tcase 0x040000:\n\t\t\tkey = KEY_DOCUMENTS;\n\t\t\tbreak;\n\t\tcase 0x800000:\n\t\t\tkey = KEY_WORDPROCESSOR;\n\t\t\tbreak;\n\t\tcase 0x200000:\n\t\t\tkey = KEY_SPREADSHEET;\n\t\t\tbreak;\n\t\tcase 0x010000:\n\t\t\tkey = KEY_COFFEE;\n\t\t\tbreak;\n\t\tcase 0x000100:\n\t\t\tkey = KEY_HELP;\n\t\t\tbreak;\n\t\tcase 0x000200:\n\t\t\tkey = KEY_SEND;\n\t\t\tbreak;\n\t\tcase 0x000400:\n\t\t\tkey = KEY_REPLY;\n\t\t\tbreak;\n\t\tcase 0x000800:\n\t\t\tkey = KEY_FORWARDMAIL;\n\t\t\tbreak;\n\t\tcase 0x001000:\n\t\t\tkey = KEY_NEW;\n\t\t\tbreak;\n\t\tcase 0x002000:\n\t\t\tkey = KEY_OPEN;\n\t\t\tbreak;\n\t\tcase 0x004000:\n\t\t\tkey = KEY_CLOSE;\n\t\t\tbreak;\n\t\tcase 0x008000:\n\t\t\tkey = KEY_SAVE;\n\t\t\tbreak;\n\t\tcase 0x000001:\n\t\t\tkey = KEY_UNDO;\n\t\t\tbreak;\n\t\tcase 0x000002:\n\t\t\tkey = KEY_REDO;\n\t\t\tbreak;\n\t\tcase 0x000004:\n\t\t\tkey = KEY_SPELLCHECK;\n\t\t\tbreak;\n\t\tcase 0x000008:\n\t\t\tkey = KEY_PRINT;\n\t\t\tbreak;\n\t\t}\n\t\tif (key) {\n\t\t\tinput_event(pm->input_ep82, EV_KEY, key, 1);\n\t\t\tpm->last_key[bit_index] = key;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int pcmidi_handle_report(\n\tstruct pcmidi_snd *pm, unsigned report_id, u8 *data, int size)\n{\n\tint ret = 0;\n\n\tswitch (report_id) {\n\tcase 0x01:  \n\t\tret = pcmidi_handle_report1(pm, data);\n\t\tbreak;\n\tcase 0x03:  \n\t\tret = pcmidi_handle_report3(pm, data, size);\n\t\tbreak;\n\tcase 0x04:  \n\t\tret = pcmidi_handle_report4(pm, data);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void pcmidi_setup_extra_keys(\n\tstruct pcmidi_snd *pm, struct input_dev *input)\n{\n\t \n\tstatic const unsigned int keys[] = {\n\t\tKEY_FN,\n\t\tKEY_MESSENGER, KEY_CALENDAR,\n\t\tKEY_ADDRESSBOOK, KEY_DOCUMENTS,\n\t\tKEY_WORDPROCESSOR,\n\t\tKEY_SPREADSHEET,\n\t\tKEY_COFFEE,\n\t\tKEY_HELP, KEY_SEND,\n\t\tKEY_REPLY, KEY_FORWARDMAIL,\n\t\tKEY_NEW, KEY_OPEN,\n\t\tKEY_CLOSE, KEY_SAVE,\n\t\tKEY_UNDO, KEY_REDO,\n\t\tKEY_SPELLCHECK,\tKEY_PRINT,\n\t\t0\n\t};\n\n\tconst unsigned int *pkeys = &keys[0];\n\tunsigned short i;\n\n\tif (pm->ifnum != 1)   \n\t\treturn;\n\n\tpm->input_ep82 = input;\n\n\tfor (i = 0; i < 24; i++)\n\t\tpm->last_key[i] = 0;\n\n\twhile (*pkeys != 0) {\n\t\tset_bit(*pkeys, pm->input_ep82->keybit);\n\t\t++pkeys;\n\t}\n}\n\nstatic int pcmidi_set_operational(struct pcmidi_snd *pm)\n{\n\tint rc;\n\n\tif (pm->ifnum != 1)\n\t\treturn 0;  \n\n\trc = pcmidi_get_output_report(pm);\n\tif (rc < 0)\n\t\treturn rc;\n\tpcmidi_submit_output_report(pm, 0xc1);\n\treturn 0;\n}\n\nstatic int pcmidi_snd_free(struct snd_device *dev)\n{\n\treturn 0;\n}\n\nstatic int pcmidi_in_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct pcmidi_snd *pm = substream->rmidi->private_data;\n\n\tdbg_hid(\"pcmidi in open\\n\");\n\tpm->in_substream = substream;\n\treturn 0;\n}\n\nstatic int pcmidi_in_close(struct snd_rawmidi_substream *substream)\n{\n\tdbg_hid(\"pcmidi in close\\n\");\n\treturn 0;\n}\n\nstatic void pcmidi_in_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct pcmidi_snd *pm = substream->rmidi->private_data;\n\n\tdbg_hid(\"pcmidi in trigger %d\\n\", up);\n\n\tpm->in_triggered = up;\n}\n\nstatic const struct snd_rawmidi_ops pcmidi_in_ops = {\n\t.open = pcmidi_in_open,\n\t.close = pcmidi_in_close,\n\t.trigger = pcmidi_in_trigger\n};\n\nstatic int pcmidi_snd_initialise(struct pcmidi_snd *pm)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rwmidi;\n\tint err;\n\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = pcmidi_snd_free,\n\t};\n\n\tif (pm->ifnum != 1)\n\t\treturn 0;  \n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\t \n\n\terr = snd_card_new(&pm->pk->hdev->dev, index[dev], id[dev],\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0) {\n\t\tpk_error(\"failed to create pc-midi sound card\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tpm->card = card;\n\n\t \n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pm, &ops);\n\tif (err < 0) {\n\t\tpk_error(\"failed to create pc-midi sound device: error %d\\n\",\n\t\t\terr);\n\t\tgoto fail;\n\t}\n\n\tstrncpy(card->driver, shortname, sizeof(card->driver));\n\tstrncpy(card->shortname, shortname, sizeof(card->shortname));\n\tstrncpy(card->longname, longname, sizeof(card->longname));\n\n\t \n\terr = snd_rawmidi_new(card, card->shortname, 0,\n\t\t\t      0, 1, &rwmidi);\n\tif (err < 0) {\n\t\tpk_error(\"failed to create pc-midi rawmidi device: error %d\\n\",\n\t\t\terr);\n\t\tgoto fail;\n\t}\n\tpm->rwmidi = rwmidi;\n\tstrncpy(rwmidi->name, card->shortname, sizeof(rwmidi->name));\n\trwmidi->info_flags = SNDRV_RAWMIDI_INFO_INPUT;\n\trwmidi->private_data = pm;\n\n\tsnd_rawmidi_set_ops(rwmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t&pcmidi_in_ops);\n\n\t \n\terr = device_create_file(&pm->pk->hdev->dev,\n\t\t\t\t sysfs_device_attr_channel);\n\tif (err < 0) {\n\t\tpk_error(\"failed to create sysfs attribute channel: error %d\\n\",\n\t\t\terr);\n\t\tgoto fail;\n\t}\n\n\terr = device_create_file(&pm->pk->hdev->dev,\n\t\t\t\tsysfs_device_attr_sustain);\n\tif (err < 0) {\n\t\tpk_error(\"failed to create sysfs attribute sustain: error %d\\n\",\n\t\t\terr);\n\t\tgoto fail_attr_sustain;\n\t}\n\n\terr = device_create_file(&pm->pk->hdev->dev,\n\t\t\t sysfs_device_attr_octave);\n\tif (err < 0) {\n\t\tpk_error(\"failed to create sysfs attribute octave: error %d\\n\",\n\t\t\terr);\n\t\tgoto fail_attr_octave;\n\t}\n\n\tspin_lock_init(&pm->rawmidi_in_lock);\n\n\tinit_sustain_timers(pm);\n\terr = pcmidi_set_operational(pm);\n\tif (err < 0) {\n\t\tpk_error(\"failed to find output report\\n\");\n\t\tgoto fail_register;\n\t}\n\n\t \n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tpk_error(\"failed to register pc-midi sound card: error %d\\n\",\n\t\t\t err);\n\t\tgoto fail_register;\n\t}\n\n\tdbg_hid(\"pcmidi_snd_initialise finished ok\\n\");\n\treturn 0;\n\nfail_register:\n\tstop_sustain_timers(pm);\n\tdevice_remove_file(&pm->pk->hdev->dev, sysfs_device_attr_octave);\nfail_attr_octave:\n\tdevice_remove_file(&pm->pk->hdev->dev, sysfs_device_attr_sustain);\nfail_attr_sustain:\n\tdevice_remove_file(&pm->pk->hdev->dev, sysfs_device_attr_channel);\nfail:\n\tif (pm->card) {\n\t\tsnd_card_free(pm->card);\n\t\tpm->card = NULL;\n\t}\n\treturn err;\n}\n\nstatic int pcmidi_snd_terminate(struct pcmidi_snd *pm)\n{\n\tif (pm->card) {\n\t\tstop_sustain_timers(pm);\n\n\t\tdevice_remove_file(&pm->pk->hdev->dev,\n\t\t\tsysfs_device_attr_channel);\n\t\tdevice_remove_file(&pm->pk->hdev->dev,\n\t\t\tsysfs_device_attr_sustain);\n\t\tdevice_remove_file(&pm->pk->hdev->dev,\n\t\t\tsysfs_device_attr_octave);\n\n\t\tsnd_card_disconnect(pm->card);\n\t\tsnd_card_free_when_closed(pm->card);\n\t}\n\n\treturn 0;\n}\n\n \nstatic __u8 *pk_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize == 178 &&\n\t      rdesc[111] == 0x06 && rdesc[112] == 0x00 &&\n\t      rdesc[113] == 0xff) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up pc-midi keyboard report descriptor\\n\");\n\n\t\trdesc[144] = 0x18;  \n\t}\n\treturn rdesc;\n}\n\nstatic int pk_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\tstruct pcmidi_snd *pm;\n\n\tpm = pk->pm;\n\n\tif (HID_UP_MSVENDOR == (usage->hid & HID_USAGE_PAGE) &&\n\t\t1 == pm->ifnum) {\n\t\tpcmidi_setup_extra_keys(pm, hi->input);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int pk_raw_event(struct hid_device *hdev, struct hid_report *report,\n\tu8 *data, int size)\n{\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\tint ret = 0;\n\n\tif (1 == pk->pm->ifnum) {\n\t\tif (report->id == data[0])\n\t\t\tswitch (report->id) {\n\t\t\tcase 0x01:  \n\t\t\tcase 0x03:  \n\t\t\tcase 0x04:  \n\t\t\t\tret = pcmidi_handle_report(pk->pm,\n\t\t\t\t\t\treport->id, data, size);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int pk_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct usb_interface *intf;\n\tunsigned short ifnum;\n\tunsigned long quirks = id->driver_data;\n\tstruct pk_device *pk;\n\tstruct pcmidi_snd *pm = NULL;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tintf = to_usb_interface(hdev->dev.parent);\n\tifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tpk = kzalloc(sizeof(*pk), GFP_KERNEL);\n\tif (pk == NULL) {\n\t\thid_err(hdev, \"can't alloc descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpk->hdev = hdev;\n\n\tpm = kzalloc(sizeof(*pm), GFP_KERNEL);\n\tif (pm == NULL) {\n\t\thid_err(hdev, \"can't alloc descriptor\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_pk;\n\t}\n\n\tpm->pk = pk;\n\tpk->pm = pm;\n\tpm->ifnum = ifnum;\n\n\thid_set_drvdata(hdev, pk);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hid parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (quirks & PK_QUIRK_NOGET) {  \n\t\thdev->quirks |= HID_QUIRK_NOGET;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = pcmidi_snd_initialise(pm);\n\tif (ret < 0)\n\t\tgoto err_stop;\n\n\treturn 0;\nerr_stop:\n\thid_hw_stop(hdev);\nerr_free:\n\tkfree(pm);\nerr_free_pk:\n\tkfree(pk);\n\n\treturn ret;\n}\n\nstatic void pk_remove(struct hid_device *hdev)\n{\n\tstruct pk_device *pk = hid_get_drvdata(hdev);\n\tstruct pcmidi_snd *pm;\n\n\tpm = pk->pm;\n\tif (pm) {\n\t\tpcmidi_snd_terminate(pm);\n\t\tkfree(pm);\n\t}\n\n\thid_hw_stop(hdev);\n\n\tkfree(pk);\n}\n\nstatic const struct hid_device_id pk_devices[] = {\n\t{HID_USB_DEVICE(USB_VENDOR_ID_CREATIVELABS,\n\t\tUSB_DEVICE_ID_PRODIKEYS_PCMIDI),\n\t    .driver_data = PK_QUIRK_NOGET},\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, pk_devices);\n\nstatic struct hid_driver pk_driver = {\n\t.name = \"prodikeys\",\n\t.id_table = pk_devices,\n\t.report_fixup = pk_report_fixup,\n\t.input_mapping = pk_input_mapping,\n\t.raw_event = pk_raw_event,\n\t.probe = pk_probe,\n\t.remove = pk_remove,\n};\nmodule_hid_driver(pk_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}