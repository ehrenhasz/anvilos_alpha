{
  "module_name": "hid-elo.c",
  "hash_id": "5d14400fb8f7e40a79933c67a639700660e4ffe40afaa7ec410f23db9ee8c22e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-elo.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n\n#include \"hid-ids.h\"\n\n#define ELO_PERIODIC_READ_INTERVAL\tHZ\n#define ELO_SMARTSET_CMD_TIMEOUT\t2000  \n\n \n#define ELO_FLUSH_SMARTSET_RESPONSES\t0x02  \n#define ELO_SEND_SMARTSET_COMMAND\t0x05  \n#define ELO_GET_SMARTSET_RESPONSE\t0x06  \n#define ELO_DIAG\t\t\t0x64  \n#define ELO_SMARTSET_PACKET_SIZE\t8\n\nstruct elo_priv {\n\tstruct usb_device *usbdev;\n\tstruct delayed_work work;\n\tunsigned char buffer[ELO_SMARTSET_PACKET_SIZE];\n};\n\nstatic struct workqueue_struct *wq;\nstatic bool use_fw_quirk = true;\nmodule_param(use_fw_quirk, bool, S_IRUGO);\nMODULE_PARM_DESC(use_fw_quirk, \"Do periodic pokes for broken M firmwares (default = true)\");\n\nstatic int elo_input_configured(struct hid_device *hdev,\n\t\tstruct hid_input *hidinput)\n{\n\tstruct input_dev *input = hidinput->input;\n\n\t \n\tclear_bit(BTN_LEFT, input->keybit);\n\tset_bit(BTN_TOUCH, input->keybit);\n\tset_bit(ABS_PRESSURE, input->absbit);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, 256, 0, 0);\n\n\treturn 0;\n}\n\nstatic void elo_process_data(struct input_dev *input, const u8 *data, int size)\n{\n\tint press;\n\n\tinput_report_abs(input, ABS_X, (data[3] << 8) | data[2]);\n\tinput_report_abs(input, ABS_Y, (data[5] << 8) | data[4]);\n\n\tpress = 0;\n\tif (data[1] & 0x80)\n\t\tpress = (data[7] << 8) | data[6];\n\tinput_report_abs(input, ABS_PRESSURE, press);\n\n\tif (data[1] & 0x03) {\n\t\tinput_report_key(input, BTN_TOUCH, 1);\n\t\tinput_sync(input);\n\t}\n\n\tif (data[1] & 0x04)\n\t\tinput_report_key(input, BTN_TOUCH, 0);\n\n\tinput_sync(input);\n}\n\nstatic int elo_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t u8 *data, int size)\n{\n\tstruct hid_input *hidinput;\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || list_empty(&hdev->inputs))\n\t\treturn 0;\n\n\thidinput = list_first_entry(&hdev->inputs, struct hid_input, list);\n\n\tswitch (report->id) {\n\tcase 0:\n\t\tif (data[0] == 'T') {\t \n\t\t\telo_process_data(hidinput->input, data, size);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\t \n\t\t \n\t\thid_info(hdev, \"unknown report type %d\\n\", report->id);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int elo_smartset_send_get(struct usb_device *dev, u8 command,\n\t\tvoid *data)\n{\n\tunsigned int pipe;\n\tu8 dir;\n\n\tif (command == ELO_SEND_SMARTSET_COMMAND) {\n\t\tpipe = usb_sndctrlpipe(dev, 0);\n\t\tdir = USB_DIR_OUT;\n\t} else if (command == ELO_GET_SMARTSET_RESPONSE) {\n\t\tpipe = usb_rcvctrlpipe(dev, 0);\n\t\tdir = USB_DIR_IN;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn usb_control_msg(dev, pipe, command,\n\t\t\tdir | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, 0, data, ELO_SMARTSET_PACKET_SIZE,\n\t\t\tELO_SMARTSET_CMD_TIMEOUT);\n}\n\nstatic int elo_flush_smartset_responses(struct usb_device *dev)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tELO_FLUSH_SMARTSET_RESPONSES,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\nstatic void elo_work(struct work_struct *work)\n{\n\tstruct elo_priv *priv = container_of(work, struct elo_priv, work.work);\n\tstruct usb_device *dev = priv->usbdev;\n\tunsigned char *buffer = priv->buffer;\n\tint ret;\n\n\tret = elo_flush_smartset_responses(dev);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"initial FLUSH_SMARTSET_RESPONSES failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t \n\t*buffer = ELO_DIAG;\n\tret = elo_smartset_send_get(dev, ELO_SEND_SMARTSET_COMMAND, buffer);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"send Diagnostics Command failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t \n\tret = elo_smartset_send_get(dev, ELO_GET_SMARTSET_RESPONSE, buffer);\n\tif (ret < 0) {\n\t\tdev_err(&dev->dev, \"get Diagnostics Command response failed, error %d\\n\",\n\t\t\t\tret);\n\t\tgoto fail;\n\t}\n\n\t \n\tif (*buffer != 'A') {\n\t\tret = elo_smartset_send_get(dev, ELO_GET_SMARTSET_RESPONSE,\n\t\t\t\tbuffer);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->dev, \"get acknowledge response failed, error %d\\n\",\n\t\t\t\t\tret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tret = elo_flush_smartset_responses(dev);\n\tif (ret < 0)\n\t\tdev_err(&dev->dev, \"final FLUSH_SMARTSET_RESPONSES failed, error %d\\n\",\n\t\t\t\tret);\n\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n}\n\n \nstatic bool elo_broken_firmware(struct usb_device *dev)\n{\n\tstruct usb_device *hub = dev->parent;\n\tstruct usb_device *child = NULL;\n\tu16 fw_lvl = le16_to_cpu(dev->descriptor.bcdDevice);\n\tu16 child_vid, child_pid;\n\tint i;\n    \n\tif (!use_fw_quirk)\n\t\treturn false;\n\tif (fw_lvl != 0x10d)\n\t\treturn false;\n\n\t \n\tusb_hub_for_each_child(hub, i, child) {\n\t\tchild_vid = le16_to_cpu(child->descriptor.idVendor);\n\t\tchild_pid = le16_to_cpu(child->descriptor.idProduct);\n\n\t\t \n\t\tif (child_vid==0x04b3) {\n\t\t\tswitch (child_pid) {\n\t\t\tcase 0x4676:  \n\t\t\tcase 0x4677:  \n\t\t\tcase 0x4678:  \n\t\t\tcase 0x4679:  \n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tpriv->usbdev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(priv);\n\treturn ret;\n}\n\nstatic void elo_remove(struct hid_device *hdev)\n{\n\tstruct elo_priv *priv = hid_get_drvdata(hdev);\n\n\thid_hw_stop(hdev);\n\tcancel_delayed_work_sync(&priv->work);\n\tkfree(priv);\n}\n\nstatic const struct hid_device_id elo_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0009), },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0030), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, elo_devices);\n\nstatic struct hid_driver elo_driver = {\n\t.name = \"elo\",\n\t.id_table = elo_devices,\n\t.probe = elo_probe,\n\t.remove = elo_remove,\n\t.raw_event = elo_raw_event,\n\t.input_configured = elo_input_configured,\n};\n\nstatic int __init elo_driver_init(void)\n{\n\tint ret;\n\n\twq = create_singlethread_workqueue(\"elousb\");\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\tret = hid_register_driver(&elo_driver);\n\tif (ret)\n\t\tdestroy_workqueue(wq);\n\n\treturn ret;\n}\nmodule_init(elo_driver_init);\n\nstatic void __exit elo_driver_exit(void)\n{\n\thid_unregister_driver(&elo_driver);\n\tdestroy_workqueue(wq);\n}\nmodule_exit(elo_driver_exit);\n\nMODULE_AUTHOR(\"Jiri Slaby <jslaby@suse.cz>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}