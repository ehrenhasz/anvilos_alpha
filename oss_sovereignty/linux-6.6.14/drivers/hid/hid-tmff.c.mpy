{
  "module_name": "hid-tmff.c",
  "hash_id": "3cd386f46714d92645d5655d932b53516c4486a250109fee4e3ca1e88897da4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-tmff.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define THRUSTMASTER_DEVICE_ID_2_IN_1_DT\t0xb320\n\nstatic const signed short ff_rumble[] = {\n\tFF_RUMBLE,\n\t-1\n};\n\nstatic const signed short ff_joystick[] = {\n\tFF_CONSTANT,\n\t-1\n};\n\n#ifdef CONFIG_THRUSTMASTER_FF\n\n \n#define THRUSTMASTER_USAGE_FF\t(HID_UP_GENDESK | 0xbb)\n\nstruct tmff_device {\n\tstruct hid_report *report;\n\tstruct hid_field *ff_field;\n};\n\n \nstatic inline int tmff_scale_u16(unsigned int in, int minimum, int maximum)\n{\n\tint ret;\n\n\tret = (in * (maximum - minimum) / 0xffff) + minimum;\n\tif (ret < minimum)\n\t\treturn minimum;\n\tif (ret > maximum)\n\t\treturn maximum;\n\treturn ret;\n}\n\n \nstatic inline int tmff_scale_s8(int in, int minimum, int maximum)\n{\n\tint ret;\n\n\tret = (((in + 0x80) * (maximum - minimum)) / 0xff) + minimum;\n\tif (ret < minimum)\n\t\treturn minimum;\n\tif (ret > maximum)\n\t\treturn maximum;\n\treturn ret;\n}\n\nstatic int tmff_play(struct input_dev *dev, void *data,\n\t\tstruct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct tmff_device *tmff = data;\n\tstruct hid_field *ff_field = tmff->ff_field;\n\tint x, y;\n\tint left, right;\t \n\n\tswitch (effect->type) {\n\tcase FF_CONSTANT:\n\t\tx = tmff_scale_s8(effect->u.ramp.start_level,\n\t\t\t\t\tff_field->logical_minimum,\n\t\t\t\t\tff_field->logical_maximum);\n\t\ty = tmff_scale_s8(effect->u.ramp.end_level,\n\t\t\t\t\tff_field->logical_minimum,\n\t\t\t\t\tff_field->logical_maximum);\n\n\t\tdbg_hid(\"(x, y)=(%04x, %04x)\\n\", x, y);\n\t\tff_field->value[0] = x;\n\t\tff_field->value[1] = y;\n\t\thid_hw_request(hid, tmff->report, HID_REQ_SET_REPORT);\n\t\tbreak;\n\n\tcase FF_RUMBLE:\n\t\tleft = tmff_scale_u16(effect->u.rumble.weak_magnitude,\n\t\t\t\t\tff_field->logical_minimum,\n\t\t\t\t\tff_field->logical_maximum);\n\t\tright = tmff_scale_u16(effect->u.rumble.strong_magnitude,\n\t\t\t\t\tff_field->logical_minimum,\n\t\t\t\t\tff_field->logical_maximum);\n\n\t\t \n\t\tif (hid->product == THRUSTMASTER_DEVICE_ID_2_IN_1_DT)\n\t\t\tswap(left, right);\n\n\t\tdbg_hid(\"(left,right)=(%08x, %08x)\\n\", left, right);\n\t\tff_field->value[0] = left;\n\t\tff_field->value[1] = right;\n\t\thid_hw_request(hid, tmff->report, HID_REQ_SET_REPORT);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int tmff_init(struct hid_device *hid, const signed short *ff_bits)\n{\n\tstruct tmff_device *tmff;\n\tstruct hid_report *report;\n\tstruct list_head *report_list;\n\tstruct hid_input *hidinput;\n\tstruct input_dev *input_dev;\n\tint error;\n\tint i;\n\n\tif (list_empty(&hid->inputs)) {\n\t\thid_err(hid, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tinput_dev = hidinput->input;\n\n\ttmff = kzalloc(sizeof(struct tmff_device), GFP_KERNEL);\n\tif (!tmff)\n\t\treturn -ENOMEM;\n\n\t \n\treport_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tlist_for_each_entry(report, report_list, list) {\n\t\tint fieldnum;\n\n\t\tfor (fieldnum = 0; fieldnum < report->maxfield; ++fieldnum) {\n\t\t\tstruct hid_field *field = report->field[fieldnum];\n\n\t\t\tif (field->maxusage <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (field->usage[0].hid) {\n\t\t\tcase THRUSTMASTER_USAGE_FF:\n\t\t\t\tif (field->report_count < 2) {\n\t\t\t\t\thid_warn(hid, \"ignoring FF field with report_count < 2\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (field->logical_maximum ==\n\t\t\t\t\t\tfield->logical_minimum) {\n\t\t\t\t\thid_warn(hid, \"ignoring FF field with logical_maximum == logical_minimum\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (tmff->report && tmff->report != report) {\n\t\t\t\t\thid_warn(hid, \"ignoring FF field in other report\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (tmff->ff_field && tmff->ff_field != field) {\n\t\t\t\t\thid_warn(hid, \"ignoring duplicate FF field\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttmff->report = report;\n\t\t\t\ttmff->ff_field = field;\n\n\t\t\t\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\t\t\t\tset_bit(ff_bits[i], input_dev->ffbit);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\thid_warn(hid, \"ignoring unknown output usage %08x\\n\",\n\t\t\t\t\t field->usage[0].hid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!tmff->report) {\n\t\thid_err(hid, \"can't find FF field in output reports\\n\");\n\t\terror = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\terror = input_ff_create_memless(input_dev, tmff, tmff_play);\n\tif (error)\n\t\tgoto fail;\n\n\thid_info(hid, \"force feedback for ThrustMaster devices by Zinx Verituse <zinx@epicsol.org>\\n\");\n\treturn 0;\n\nfail:\n\tkfree(tmff);\n\treturn error;\n}\n#else\nstatic inline int tmff_init(struct hid_device *hid, const signed short *ff_bits)\n{\n\treturn 0;\n}\n#endif\n\nstatic int tm_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err;\n\t}\n\n\ttmff_init(hdev, (void *)id->driver_data);\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic const struct hid_device_id tm_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb300),\n\t\t.driver_data = (unsigned long)ff_rumble },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb304),    \n\t\t.driver_data = (unsigned long)ff_rumble },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, THRUSTMASTER_DEVICE_ID_2_IN_1_DT),    \n\t\t.driver_data = (unsigned long)ff_rumble },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb323),    \n\t\t.driver_data = (unsigned long)ff_rumble },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb324),    \n\t\t.driver_data = (unsigned long)ff_rumble },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb605),    \n\t\t.driver_data = (unsigned long)ff_joystick },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb651),\t \n\t\t.driver_data = (unsigned long)ff_rumble },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb653),\t \n\t\t.driver_data = (unsigned long)ff_joystick },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb654),\t \n\t\t.driver_data = (unsigned long)ff_joystick },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb65a),\t \n\t\t.driver_data = (unsigned long)ff_joystick },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, tm_devices);\n\nstatic struct hid_driver tm_driver = {\n\t.name = \"thrustmaster\",\n\t.id_table = tm_devices,\n\t.probe = tm_probe,\n};\nmodule_hid_driver(tm_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}