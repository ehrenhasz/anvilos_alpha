{
  "module_name": "hid-logitech-hidpp.c",
  "hash_id": "5ca942763664213b6a47cca92ca909bee9f268d18d081d814c5772c05cd25bc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-logitech-hidpp.c",
  "human_readable_source": "\n \n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n#include <linux/kfifo.h>\n#include <linux/input/mt.h>\n#include <linux/workqueue.h>\n#include <linux/atomic.h>\n#include <linux/fixp-arith.h>\n#include <asm/unaligned.h>\n#include \"usbhid/usbhid.h\"\n#include \"hid-ids.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\");\nMODULE_AUTHOR(\"Nestor Lopez Casado <nlopezcasad@logitech.com>\");\nMODULE_AUTHOR(\"Bastien Nocera <hadess@hadess.net>\");\n\nstatic bool disable_tap_to_click;\nmodule_param(disable_tap_to_click, bool, 0644);\nMODULE_PARM_DESC(disable_tap_to_click,\n\t\"Disable Tap-To-Click mode reporting for touchpads (only on the K400 currently).\");\n\n \n#define LINUX_KERNEL_SW_ID\t\t\t0x01\n\n#define REPORT_ID_HIDPP_SHORT\t\t\t0x10\n#define REPORT_ID_HIDPP_LONG\t\t\t0x11\n#define REPORT_ID_HIDPP_VERY_LONG\t\t0x12\n\n#define HIDPP_REPORT_SHORT_LENGTH\t\t7\n#define HIDPP_REPORT_LONG_LENGTH\t\t20\n#define HIDPP_REPORT_VERY_LONG_MAX_LENGTH\t64\n\n#define HIDPP_REPORT_SHORT_SUPPORTED\t\tBIT(0)\n#define HIDPP_REPORT_LONG_SUPPORTED\t\tBIT(1)\n#define HIDPP_REPORT_VERY_LONG_SUPPORTED\tBIT(2)\n\n#define HIDPP_SUB_ID_CONSUMER_VENDOR_KEYS\t0x03\n#define HIDPP_SUB_ID_ROLLER\t\t\t0x05\n#define HIDPP_SUB_ID_MOUSE_EXTRA_BTNS\t\t0x06\n#define HIDPP_SUB_ID_USER_IFACE_EVENT\t\t0x08\n#define HIDPP_USER_IFACE_EVENT_ENCRYPTION_KEY_LOST\tBIT(5)\n\n#define HIDPP_QUIRK_CLASS_WTP\t\t\tBIT(0)\n#define HIDPP_QUIRK_CLASS_M560\t\t\tBIT(1)\n#define HIDPP_QUIRK_CLASS_K400\t\t\tBIT(2)\n#define HIDPP_QUIRK_CLASS_G920\t\t\tBIT(3)\n#define HIDPP_QUIRK_CLASS_K750\t\t\tBIT(4)\n\n \n \n#define HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS\tBIT(22)\n#define HIDPP_QUIRK_DELAYED_INIT\t\tBIT(23)\n#define HIDPP_QUIRK_FORCE_OUTPUT_REPORTS\tBIT(24)\n#define HIDPP_QUIRK_UNIFYING\t\t\tBIT(25)\n#define HIDPP_QUIRK_HIDPP_WHEELS\t\tBIT(26)\n#define HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS\tBIT(27)\n#define HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS\tBIT(28)\n#define HIDPP_QUIRK_HI_RES_SCROLL_1P0\t\tBIT(29)\n#define HIDPP_QUIRK_WIRELESS_STATUS\t\tBIT(30)\n\n \n#define HIDPP_QUIRK_KBD_SCROLL_WHEEL HIDPP_QUIRK_HIDPP_WHEELS\n#define HIDPP_QUIRK_KBD_ZOOM_WHEEL   HIDPP_QUIRK_HIDPP_WHEELS\n\n \n#define HIDPP_CAPABILITY_HI_RES_SCROLL\t(HIDPP_CAPABILITY_HIDPP10_FAST_SCROLL | \\\n\t\t\t\t\t HIDPP_CAPABILITY_HIDPP20_HI_RES_SCROLL | \\\n\t\t\t\t\t HIDPP_CAPABILITY_HIDPP20_HI_RES_WHEEL)\n\n#define HIDPP_CAPABILITY_HIDPP10_BATTERY\tBIT(0)\n#define HIDPP_CAPABILITY_HIDPP20_BATTERY\tBIT(1)\n#define HIDPP_CAPABILITY_BATTERY_MILEAGE\tBIT(2)\n#define HIDPP_CAPABILITY_BATTERY_LEVEL_STATUS\tBIT(3)\n#define HIDPP_CAPABILITY_BATTERY_VOLTAGE\tBIT(4)\n#define HIDPP_CAPABILITY_BATTERY_PERCENTAGE\tBIT(5)\n#define HIDPP_CAPABILITY_UNIFIED_BATTERY\tBIT(6)\n#define HIDPP_CAPABILITY_HIDPP20_HI_RES_WHEEL\tBIT(7)\n#define HIDPP_CAPABILITY_HIDPP20_HI_RES_SCROLL\tBIT(8)\n#define HIDPP_CAPABILITY_HIDPP10_FAST_SCROLL\tBIT(9)\n#define HIDPP_CAPABILITY_ADC_MEASUREMENT\tBIT(10)\n\n#define lg_map_key_clear(c)  hid_map_usage_clear(hi, usage, bit, max, EV_KEY, (c))\n\n \n\nstruct fap {\n\tu8 feature_index;\n\tu8 funcindex_clientid;\n\tu8 params[HIDPP_REPORT_VERY_LONG_MAX_LENGTH - 4U];\n};\n\nstruct rap {\n\tu8 sub_id;\n\tu8 reg_address;\n\tu8 params[HIDPP_REPORT_VERY_LONG_MAX_LENGTH - 4U];\n};\n\nstruct hidpp_report {\n\tu8 report_id;\n\tu8 device_index;\n\tunion {\n\t\tstruct fap fap;\n\t\tstruct rap rap;\n\t\tu8 rawbytes[sizeof(struct fap)];\n\t};\n} __packed;\n\nstruct hidpp_battery {\n\tu8 feature_index;\n\tu8 solar_feature_index;\n\tu8 voltage_feature_index;\n\tu8 adc_measurement_feature_index;\n\tstruct power_supply_desc desc;\n\tstruct power_supply *ps;\n\tchar name[64];\n\tint status;\n\tint capacity;\n\tint level;\n\tint voltage;\n\tint charge_type;\n\tbool online;\n\tu8 supported_levels_1004;\n};\n\n \nstruct hidpp_scroll_counter {\n\tint wheel_multiplier;\n\tint remainder;\n\tint direction;\n\tunsigned long long last_time;\n};\n\nstruct hidpp_device {\n\tstruct hid_device *hid_dev;\n\tstruct input_dev *input;\n\tstruct mutex send_mutex;\n\tvoid *send_receive_buf;\n\tchar *name;\t\t \n\twait_queue_head_t wait;\n\tint very_long_report_length;\n\tbool answer_available;\n\tu8 protocol_major;\n\tu8 protocol_minor;\n\n\tvoid *private_data;\n\n\tstruct work_struct work;\n\tstruct kfifo delayed_work_fifo;\n\tatomic_t connected;\n\tstruct input_dev *delayed_input;\n\n\tunsigned long quirks;\n\tunsigned long capabilities;\n\tu8 supported_reports;\n\n\tstruct hidpp_battery battery;\n\tstruct hidpp_scroll_counter vertical_wheel_counter;\n\n\tu8 wireless_feature_index;\n};\n\n \n#define HIDPP_ERROR\t\t\t\t0x8f\n#define HIDPP_ERROR_SUCCESS\t\t\t0x00\n#define HIDPP_ERROR_INVALID_SUBID\t\t0x01\n#define HIDPP_ERROR_INVALID_ADRESS\t\t0x02\n#define HIDPP_ERROR_INVALID_VALUE\t\t0x03\n#define HIDPP_ERROR_CONNECT_FAIL\t\t0x04\n#define HIDPP_ERROR_TOO_MANY_DEVICES\t\t0x05\n#define HIDPP_ERROR_ALREADY_EXISTS\t\t0x06\n#define HIDPP_ERROR_BUSY\t\t\t0x07\n#define HIDPP_ERROR_UNKNOWN_DEVICE\t\t0x08\n#define HIDPP_ERROR_RESOURCE_ERROR\t\t0x09\n#define HIDPP_ERROR_REQUEST_UNAVAILABLE\t\t0x0a\n#define HIDPP_ERROR_INVALID_PARAM_VALUE\t\t0x0b\n#define HIDPP_ERROR_WRONG_PIN_CODE\t\t0x0c\n \n#define HIDPP20_ERROR_NO_ERROR\t\t\t0x00\n#define HIDPP20_ERROR_UNKNOWN\t\t\t0x01\n#define HIDPP20_ERROR_INVALID_ARGS\t\t0x02\n#define HIDPP20_ERROR_OUT_OF_RANGE\t\t0x03\n#define HIDPP20_ERROR_HW_ERROR\t\t\t0x04\n#define HIDPP20_ERROR_NOT_ALLOWED\t\t0x05\n#define HIDPP20_ERROR_INVALID_FEATURE_INDEX\t0x06\n#define HIDPP20_ERROR_INVALID_FUNCTION_ID\t0x07\n#define HIDPP20_ERROR_BUSY\t\t\t0x08\n#define HIDPP20_ERROR_UNSUPPORTED\t\t0x09\n#define HIDPP20_ERROR\t\t\t\t0xff\n\nstatic void hidpp_connect_event(struct hidpp_device *hidpp_dev);\n\nstatic int __hidpp_send_report(struct hid_device *hdev,\n\t\t\t\tstruct hidpp_report *hidpp_report)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tint fields_count, ret;\n\n\tswitch (hidpp_report->report_id) {\n\tcase REPORT_ID_HIDPP_SHORT:\n\t\tfields_count = HIDPP_REPORT_SHORT_LENGTH;\n\t\tbreak;\n\tcase REPORT_ID_HIDPP_LONG:\n\t\tfields_count = HIDPP_REPORT_LONG_LENGTH;\n\t\tbreak;\n\tcase REPORT_ID_HIDPP_VERY_LONG:\n\t\tfields_count = hidpp->very_long_report_length;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thidpp_report->device_index = 0xff;\n\n\tif (hidpp->quirks & HIDPP_QUIRK_FORCE_OUTPUT_REPORTS) {\n\t\tret = hid_hw_output_report(hdev, (u8 *)hidpp_report, fields_count);\n\t} else {\n\t\tret = hid_hw_raw_request(hdev, hidpp_report->report_id,\n\t\t\t(u8 *)hidpp_report, fields_count, HID_OUTPUT_REPORT,\n\t\t\tHID_REQ_SET_REPORT);\n\t}\n\n\treturn ret == fields_count ? 0 : -1;\n}\n\n \nstatic int __do_hidpp_send_message_sync(struct hidpp_device *hidpp,\n\tstruct hidpp_report *message,\n\tstruct hidpp_report *response)\n{\n\tint ret;\n\n\t__must_hold(&hidpp->send_mutex);\n\n\thidpp->send_receive_buf = response;\n\thidpp->answer_available = false;\n\n\t \n\t*response = *message;\n\n\tret = __hidpp_send_report(hidpp->hid_dev, message);\n\tif (ret) {\n\t\tdbg_hid(\"__hidpp_send_report returned err: %d\\n\", ret);\n\t\tmemset(response, 0, sizeof(struct hidpp_report));\n\t\treturn ret;\n\t}\n\n\tif (!wait_event_timeout(hidpp->wait, hidpp->answer_available,\n\t\t\t\t5*HZ)) {\n\t\tdbg_hid(\"%s:timeout waiting for response\\n\", __func__);\n\t\tmemset(response, 0, sizeof(struct hidpp_report));\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (response->report_id == REPORT_ID_HIDPP_SHORT &&\n\t    response->rap.sub_id == HIDPP_ERROR) {\n\t\tret = response->rap.params[1];\n\t\tdbg_hid(\"%s:got hidpp error %02X\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tif ((response->report_id == REPORT_ID_HIDPP_LONG ||\n\t     response->report_id == REPORT_ID_HIDPP_VERY_LONG) &&\n\t    response->fap.feature_index == HIDPP20_ERROR) {\n\t\tret = response->fap.params[1];\n\t\tdbg_hid(\"%s:got hidpp 2.0 error %02X\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hidpp_send_message_sync(struct hidpp_device *hidpp,\n\tstruct hidpp_report *message,\n\tstruct hidpp_report *response)\n{\n\tint ret;\n\tint max_retries = 3;\n\n\tmutex_lock(&hidpp->send_mutex);\n\n\tdo {\n\t\tret = __do_hidpp_send_message_sync(hidpp, message, response);\n\t\tif (ret != HIDPP20_ERROR_BUSY)\n\t\t\tbreak;\n\n\t\tdbg_hid(\"%s:got busy hidpp 2.0 error %02X, retrying\\n\", __func__, ret);\n\t} while (--max_retries);\n\n\tmutex_unlock(&hidpp->send_mutex);\n\treturn ret;\n\n}\n\n \nstatic int hidpp_send_fap_command_sync(struct hidpp_device *hidpp,\n\tu8 feat_index, u8 funcindex_clientid, u8 *params, int param_count,\n\tstruct hidpp_report *response)\n{\n\tstruct hidpp_report *message;\n\tint ret;\n\n\tif (param_count > sizeof(message->fap.params)) {\n\t\thid_dbg(hidpp->hid_dev,\n\t\t\t\"Invalid number of parameters passed to command (%d != %llu)\\n\",\n\t\t\tparam_count,\n\t\t\t(unsigned long long) sizeof(message->fap.params));\n\t\treturn -EINVAL;\n\t}\n\n\tmessage = kzalloc(sizeof(struct hidpp_report), GFP_KERNEL);\n\tif (!message)\n\t\treturn -ENOMEM;\n\n\tif (param_count > (HIDPP_REPORT_LONG_LENGTH - 4))\n\t\tmessage->report_id = REPORT_ID_HIDPP_VERY_LONG;\n\telse\n\t\tmessage->report_id = REPORT_ID_HIDPP_LONG;\n\tmessage->fap.feature_index = feat_index;\n\tmessage->fap.funcindex_clientid = funcindex_clientid | LINUX_KERNEL_SW_ID;\n\tmemcpy(&message->fap.params, params, param_count);\n\n\tret = hidpp_send_message_sync(hidpp, message, response);\n\tkfree(message);\n\treturn ret;\n}\n\n \nstatic int hidpp_send_rap_command_sync(struct hidpp_device *hidpp_dev,\n\tu8 report_id, u8 sub_id, u8 reg_address, u8 *params, int param_count,\n\tstruct hidpp_report *response)\n{\n\tstruct hidpp_report *message;\n\tint ret, max_count;\n\n\t \n\tif (report_id == REPORT_ID_HIDPP_SHORT &&\n\t    !(hidpp_dev->supported_reports & HIDPP_REPORT_SHORT_SUPPORTED))\n\t\treport_id = REPORT_ID_HIDPP_LONG;\n\n\tswitch (report_id) {\n\tcase REPORT_ID_HIDPP_SHORT:\n\t\tmax_count = HIDPP_REPORT_SHORT_LENGTH - 4;\n\t\tbreak;\n\tcase REPORT_ID_HIDPP_LONG:\n\t\tmax_count = HIDPP_REPORT_LONG_LENGTH - 4;\n\t\tbreak;\n\tcase REPORT_ID_HIDPP_VERY_LONG:\n\t\tmax_count = hidpp_dev->very_long_report_length - 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_count > max_count)\n\t\treturn -EINVAL;\n\n\tmessage = kzalloc(sizeof(struct hidpp_report), GFP_KERNEL);\n\tif (!message)\n\t\treturn -ENOMEM;\n\tmessage->report_id = report_id;\n\tmessage->rap.sub_id = sub_id;\n\tmessage->rap.reg_address = reg_address;\n\tmemcpy(&message->rap.params, params, param_count);\n\n\tret = hidpp_send_message_sync(hidpp_dev, message, response);\n\tkfree(message);\n\treturn ret;\n}\n\nstatic void delayed_work_cb(struct work_struct *work)\n{\n\tstruct hidpp_device *hidpp = container_of(work, struct hidpp_device,\n\t\t\t\t\t\t\twork);\n\thidpp_connect_event(hidpp);\n}\n\nstatic inline bool hidpp_match_answer(struct hidpp_report *question,\n\t\tstruct hidpp_report *answer)\n{\n\treturn (answer->fap.feature_index == question->fap.feature_index) &&\n\t   (answer->fap.funcindex_clientid == question->fap.funcindex_clientid);\n}\n\nstatic inline bool hidpp_match_error(struct hidpp_report *question,\n\t\tstruct hidpp_report *answer)\n{\n\treturn ((answer->rap.sub_id == HIDPP_ERROR) ||\n\t    (answer->fap.feature_index == HIDPP20_ERROR)) &&\n\t    (answer->fap.funcindex_clientid == question->fap.feature_index) &&\n\t    (answer->fap.params[0] == question->fap.funcindex_clientid);\n}\n\nstatic inline bool hidpp_report_is_connect_event(struct hidpp_device *hidpp,\n\t\tstruct hidpp_report *report)\n{\n\treturn (hidpp->wireless_feature_index &&\n\t\t(report->fap.feature_index == hidpp->wireless_feature_index)) ||\n\t\t((report->report_id == REPORT_ID_HIDPP_SHORT) &&\n\t\t(report->rap.sub_id == 0x41));\n}\n\n \nstatic void hidpp_prefix_name(char **name, int name_length)\n{\n#define PREFIX_LENGTH 9  \n\n\tint new_length;\n\tchar *new_name;\n\n\tif (name_length > PREFIX_LENGTH &&\n\t    strncmp(*name, \"Logitech \", PREFIX_LENGTH) == 0)\n\t\t \n\t\treturn;\n\n\tnew_length = PREFIX_LENGTH + name_length;\n\tnew_name = kzalloc(new_length, GFP_KERNEL);\n\tif (!new_name)\n\t\treturn;\n\n\tsnprintf(new_name, new_length, \"Logitech %s\", *name);\n\n\tkfree(*name);\n\n\t*name = new_name;\n}\n\n \nstatic void hidpp_update_usb_wireless_status(struct hidpp_device *hidpp)\n{\n\tstruct hid_device *hdev = hidpp->hid_dev;\n\tstruct usb_interface *intf;\n\n\tif (!(hidpp->quirks & HIDPP_QUIRK_WIRELESS_STATUS))\n\t\treturn;\n\tif (!hid_is_usb(hdev))\n\t\treturn;\n\n\tintf = to_usb_interface(hdev->dev.parent);\n\tusb_set_wireless_status(intf, hidpp->battery.online ?\n\t\t\t\tUSB_WIRELESS_STATUS_CONNECTED :\n\t\t\t\tUSB_WIRELESS_STATUS_DISCONNECTED);\n}\n\n \nstatic void hidpp_scroll_counter_handle_scroll(struct input_dev *input_dev,\n\t\t\t\t\t       struct hidpp_scroll_counter *counter,\n\t\t\t\t\t       int hi_res_value)\n{\n\tint low_res_value, remainder, direction;\n\tunsigned long long now, previous;\n\n\thi_res_value = hi_res_value * 120/counter->wheel_multiplier;\n\tinput_report_rel(input_dev, REL_WHEEL_HI_RES, hi_res_value);\n\n\tremainder = counter->remainder;\n\tdirection = hi_res_value > 0 ? 1 : -1;\n\n\tnow = sched_clock();\n\tprevious = counter->last_time;\n\tcounter->last_time = now;\n\t \n\tif (now - previous > 1000000000 || direction != counter->direction)\n\t\tremainder = 0;\n\n\tcounter->direction = direction;\n\tremainder += hi_res_value;\n\n\t \n\tif (abs(remainder) >= 60) {\n\t\t \n\t\tlow_res_value = remainder / 120;\n\t\tif (low_res_value == 0)\n\t\t\tlow_res_value = (hi_res_value > 0 ? 1 : -1);\n\t\tinput_report_rel(input_dev, REL_WHEEL, low_res_value);\n\t\tremainder -= low_res_value * 120;\n\t}\n\tcounter->remainder = remainder;\n}\n\n \n \n \n\n#define HIDPP_SET_REGISTER\t\t\t\t0x80\n#define HIDPP_GET_REGISTER\t\t\t\t0x81\n#define HIDPP_SET_LONG_REGISTER\t\t\t\t0x82\n#define HIDPP_GET_LONG_REGISTER\t\t\t\t0x83\n\n \nstatic int hidpp10_set_register(struct hidpp_device *hidpp_dev,\n\tu8 register_address, u8 byte, u8 mask, u8 value)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 params[3] = { 0 };\n\n\tret = hidpp_send_rap_command_sync(hidpp_dev,\n\t\t\t\t\t  REPORT_ID_HIDPP_SHORT,\n\t\t\t\t\t  HIDPP_GET_REGISTER,\n\t\t\t\t\t  register_address,\n\t\t\t\t\t  NULL, 0, &response);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(params, response.rap.params, 3);\n\n\tparams[byte] &= ~mask;\n\tparams[byte] |= value & mask;\n\n\treturn hidpp_send_rap_command_sync(hidpp_dev,\n\t\t\t\t\t   REPORT_ID_HIDPP_SHORT,\n\t\t\t\t\t   HIDPP_SET_REGISTER,\n\t\t\t\t\t   register_address,\n\t\t\t\t\t   params, 3, &response);\n}\n\n#define HIDPP_REG_ENABLE_REPORTS\t\t\t0x00\n#define HIDPP_ENABLE_CONSUMER_REPORT\t\t\tBIT(0)\n#define HIDPP_ENABLE_WHEEL_REPORT\t\t\tBIT(2)\n#define HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT\t\tBIT(3)\n#define HIDPP_ENABLE_BAT_REPORT\t\t\t\tBIT(4)\n#define HIDPP_ENABLE_HWHEEL_REPORT\t\t\tBIT(5)\n\nstatic int hidpp10_enable_battery_reporting(struct hidpp_device *hidpp_dev)\n{\n\treturn hidpp10_set_register(hidpp_dev, HIDPP_REG_ENABLE_REPORTS, 0,\n\t\t\t  HIDPP_ENABLE_BAT_REPORT, HIDPP_ENABLE_BAT_REPORT);\n}\n\n#define HIDPP_REG_FEATURES\t\t\t\t0x01\n#define HIDPP_ENABLE_SPECIAL_BUTTON_FUNC\t\tBIT(1)\n#define HIDPP_ENABLE_FAST_SCROLL\t\t\tBIT(6)\n\n \nstatic int hidpp10_enable_scrolling_acceleration(struct hidpp_device *hidpp_dev)\n{\n\treturn hidpp10_set_register(hidpp_dev, HIDPP_REG_FEATURES, 0,\n\t\t\t  HIDPP_ENABLE_FAST_SCROLL, HIDPP_ENABLE_FAST_SCROLL);\n}\n\n#define HIDPP_REG_BATTERY_STATUS\t\t\t0x07\n\nstatic int hidpp10_battery_status_map_level(u8 param)\n{\n\tint level;\n\n\tswitch (param) {\n\tcase 1 ... 2:\n\t\tlevel = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t\tbreak;\n\tcase 3 ... 4:\n\t\tlevel = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\t\tbreak;\n\tcase 5 ... 6:\n\t\tlevel = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\t\tbreak;\n\tcase 7:\n\t\tlevel = POWER_SUPPLY_CAPACITY_LEVEL_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tlevel = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\t}\n\n\treturn level;\n}\n\nstatic int hidpp10_battery_status_map_status(u8 param)\n{\n\tint status;\n\n\tswitch (param) {\n\tcase 0x00:\n\t\t \n\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase 0x21:  \n\tcase 0x24:  \n\tcase 0x25:  \n\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase 0x26:  \n\tcase 0x22:  \n\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase 0x20:  \n\t\tstatus = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tbreak;\n\t \n\tdefault:\n\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic int hidpp10_query_battery_status(struct hidpp_device *hidpp)\n{\n\tstruct hidpp_report response;\n\tint ret, status;\n\n\tret = hidpp_send_rap_command_sync(hidpp,\n\t\t\t\t\tREPORT_ID_HIDPP_SHORT,\n\t\t\t\t\tHIDPP_GET_REGISTER,\n\t\t\t\t\tHIDPP_REG_BATTERY_STATUS,\n\t\t\t\t\tNULL, 0, &response);\n\tif (ret)\n\t\treturn ret;\n\n\thidpp->battery.level =\n\t\thidpp10_battery_status_map_level(response.rap.params[0]);\n\tstatus = hidpp10_battery_status_map_status(response.rap.params[1]);\n\thidpp->battery.status = status;\n\t \n\thidpp->battery.online = status == POWER_SUPPLY_STATUS_DISCHARGING ||\n\t\t\t\tstatus == POWER_SUPPLY_STATUS_FULL;\n\n\treturn 0;\n}\n\n#define HIDPP_REG_BATTERY_MILEAGE\t\t\t0x0D\n\nstatic int hidpp10_battery_mileage_map_status(u8 param)\n{\n\tint status;\n\n\tswitch (param >> 6) {\n\tcase 0x00:\n\t\t \n\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase 0x01:  \n\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase 0x02:  \n\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\t \n\tdefault:\n\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic int hidpp10_query_battery_mileage(struct hidpp_device *hidpp)\n{\n\tstruct hidpp_report response;\n\tint ret, status;\n\n\tret = hidpp_send_rap_command_sync(hidpp,\n\t\t\t\t\tREPORT_ID_HIDPP_SHORT,\n\t\t\t\t\tHIDPP_GET_REGISTER,\n\t\t\t\t\tHIDPP_REG_BATTERY_MILEAGE,\n\t\t\t\t\tNULL, 0, &response);\n\tif (ret)\n\t\treturn ret;\n\n\thidpp->battery.capacity = response.rap.params[0];\n\tstatus = hidpp10_battery_mileage_map_status(response.rap.params[2]);\n\thidpp->battery.status = status;\n\t \n\thidpp->battery.online = status == POWER_SUPPLY_STATUS_DISCHARGING ||\n\t\t\t\tstatus == POWER_SUPPLY_STATUS_FULL;\n\n\treturn 0;\n}\n\nstatic int hidpp10_battery_event(struct hidpp_device *hidpp, u8 *data, int size)\n{\n\tstruct hidpp_report *report = (struct hidpp_report *)data;\n\tint status, capacity, level;\n\tbool changed;\n\n\tif (report->report_id != REPORT_ID_HIDPP_SHORT)\n\t\treturn 0;\n\n\tswitch (report->rap.sub_id) {\n\tcase HIDPP_REG_BATTERY_STATUS:\n\t\tcapacity = hidpp->battery.capacity;\n\t\tlevel = hidpp10_battery_status_map_level(report->rawbytes[1]);\n\t\tstatus = hidpp10_battery_status_map_status(report->rawbytes[2]);\n\t\tbreak;\n\tcase HIDPP_REG_BATTERY_MILEAGE:\n\t\tcapacity = report->rap.params[0];\n\t\tlevel = hidpp->battery.level;\n\t\tstatus = hidpp10_battery_mileage_map_status(report->rawbytes[3]);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tchanged = capacity != hidpp->battery.capacity ||\n\t\t  level != hidpp->battery.level ||\n\t\t  status != hidpp->battery.status;\n\n\t \n\thidpp->battery.online = status == POWER_SUPPLY_STATUS_DISCHARGING ||\n\t\t\t\tstatus == POWER_SUPPLY_STATUS_FULL;\n\n\tif (changed) {\n\t\thidpp->battery.level = level;\n\t\thidpp->battery.status = status;\n\t\tif (hidpp->battery.ps)\n\t\t\tpower_supply_changed(hidpp->battery.ps);\n\t}\n\n\treturn 0;\n}\n\n#define HIDPP_REG_PAIRING_INFORMATION\t\t\t0xB5\n#define HIDPP_EXTENDED_PAIRING\t\t\t\t0x30\n#define HIDPP_DEVICE_NAME\t\t\t\t0x40\n\nstatic char *hidpp_unifying_get_name(struct hidpp_device *hidpp_dev)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 params[1] = { HIDPP_DEVICE_NAME };\n\tchar *name;\n\tint len;\n\n\tret = hidpp_send_rap_command_sync(hidpp_dev,\n\t\t\t\t\tREPORT_ID_HIDPP_SHORT,\n\t\t\t\t\tHIDPP_GET_LONG_REGISTER,\n\t\t\t\t\tHIDPP_REG_PAIRING_INFORMATION,\n\t\t\t\t\tparams, 1, &response);\n\tif (ret)\n\t\treturn NULL;\n\n\tlen = response.rap.params[1];\n\n\tif (2 + len > sizeof(response.rap.params))\n\t\treturn NULL;\n\n\tif (len < 4)  \n\t\treturn NULL;\n\n\tname = kzalloc(len + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\tmemcpy(name, &response.rap.params[2], len);\n\n\t \n\thidpp_prefix_name(&name, len + 1);\n\n\treturn name;\n}\n\nstatic int hidpp_unifying_get_serial(struct hidpp_device *hidpp, u32 *serial)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 params[1] = { HIDPP_EXTENDED_PAIRING };\n\n\tret = hidpp_send_rap_command_sync(hidpp,\n\t\t\t\t\tREPORT_ID_HIDPP_SHORT,\n\t\t\t\t\tHIDPP_GET_LONG_REGISTER,\n\t\t\t\t\tHIDPP_REG_PAIRING_INFORMATION,\n\t\t\t\t\tparams, 1, &response);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*serial = *((u32 *)&response.rap.params[1]);\n\treturn 0;\n}\n\nstatic int hidpp_unifying_init(struct hidpp_device *hidpp)\n{\n\tstruct hid_device *hdev = hidpp->hid_dev;\n\tconst char *name;\n\tu32 serial;\n\tint ret;\n\n\tret = hidpp_unifying_get_serial(hidpp, &serial);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(hdev->uniq, sizeof(hdev->uniq), \"%4phD\", &serial);\n\tdbg_hid(\"HID++ Unifying: Got serial: %s\\n\", hdev->uniq);\n\n\tname = hidpp_unifying_get_name(hidpp);\n\tif (!name)\n\t\treturn -EIO;\n\n\tsnprintf(hdev->name, sizeof(hdev->name), \"%s\", name);\n\tdbg_hid(\"HID++ Unifying: Got name: %s\\n\", name);\n\n\tkfree(name);\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_ROOT\t\t\t\t\t0x0000\n#define HIDPP_PAGE_ROOT_IDX\t\t\t\t0x00\n\n#define CMD_ROOT_GET_FEATURE\t\t\t\t0x00\n#define CMD_ROOT_GET_PROTOCOL_VERSION\t\t\t0x10\n\nstatic int hidpp_root_get_feature(struct hidpp_device *hidpp, u16 feature,\n\tu8 *feature_index, u8 *feature_type)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 params[2] = { feature >> 8, feature & 0x00FF };\n\n\tret = hidpp_send_fap_command_sync(hidpp,\n\t\t\tHIDPP_PAGE_ROOT_IDX,\n\t\t\tCMD_ROOT_GET_FEATURE,\n\t\t\tparams, 2, &response);\n\tif (ret)\n\t\treturn ret;\n\n\tif (response.fap.params[0] == 0)\n\t\treturn -ENOENT;\n\n\t*feature_index = response.fap.params[0];\n\t*feature_type = response.fap.params[1];\n\n\treturn ret;\n}\n\nstatic int hidpp_root_get_protocol_version(struct hidpp_device *hidpp)\n{\n\tconst u8 ping_byte = 0x5a;\n\tu8 ping_data[3] = { 0, 0, ping_byte };\n\tstruct hidpp_report response;\n\tint ret;\n\n\tret = hidpp_send_rap_command_sync(hidpp,\n\t\t\tREPORT_ID_HIDPP_SHORT,\n\t\t\tHIDPP_PAGE_ROOT_IDX,\n\t\t\tCMD_ROOT_GET_PROTOCOL_VERSION | LINUX_KERNEL_SW_ID,\n\t\t\tping_data, sizeof(ping_data), &response);\n\n\tif (ret == HIDPP_ERROR_INVALID_SUBID) {\n\t\thidpp->protocol_major = 1;\n\t\thidpp->protocol_minor = 0;\n\t\tgoto print_version;\n\t}\n\n\t \n\tif (ret == HIDPP_ERROR_RESOURCE_ERROR)\n\t\treturn -EIO;\n\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tif (response.rap.params[2] != ping_byte) {\n\t\thid_err(hidpp->hid_dev, \"%s: ping mismatch 0x%02x != 0x%02x\\n\",\n\t\t\t__func__, response.rap.params[2], ping_byte);\n\t\treturn -EPROTO;\n\t}\n\n\thidpp->protocol_major = response.rap.params[0];\n\thidpp->protocol_minor = response.rap.params[1];\n\nprint_version:\n\thid_info(hidpp->hid_dev, \"HID++ %u.%u device connected.\\n\",\n\t\t hidpp->protocol_major, hidpp->protocol_minor);\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_DEVICE_INFORMATION\t\t\t0x0003\n\n#define CMD_GET_DEVICE_INFO\t\t\t\t0x00\n\nstatic int hidpp_get_serial(struct hidpp_device *hidpp, u32 *serial)\n{\n\tstruct hidpp_report response;\n\tu8 feature_type;\n\tu8 feature_index;\n\tint ret;\n\n\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_DEVICE_INFORMATION,\n\t\t\t\t     &feature_index,\n\t\t\t\t     &feature_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_GET_DEVICE_INFO,\n\t\t\t\t\t  NULL, 0, &response);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*serial = *((u32 *)&response.rap.params[1]);\n\treturn 0;\n}\n\nstatic int hidpp_serial_init(struct hidpp_device *hidpp)\n{\n\tstruct hid_device *hdev = hidpp->hid_dev;\n\tu32 serial;\n\tint ret;\n\n\tret = hidpp_get_serial(hidpp, &serial);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(hdev->uniq, sizeof(hdev->uniq), \"%4phD\", &serial);\n\tdbg_hid(\"HID++ DeviceInformation: Got serial: %s\\n\", hdev->uniq);\n\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_GET_DEVICE_NAME_TYPE\t\t\t0x0005\n\n#define CMD_GET_DEVICE_NAME_TYPE_GET_COUNT\t\t0x00\n#define CMD_GET_DEVICE_NAME_TYPE_GET_DEVICE_NAME\t0x10\n#define CMD_GET_DEVICE_NAME_TYPE_GET_TYPE\t\t0x20\n\nstatic int hidpp_devicenametype_get_count(struct hidpp_device *hidpp,\n\tu8 feature_index, u8 *nameLength)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\tCMD_GET_DEVICE_NAME_TYPE_GET_COUNT, NULL, 0, &response);\n\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t*nameLength = response.fap.params[0];\n\n\treturn ret;\n}\n\nstatic int hidpp_devicenametype_get_device_name(struct hidpp_device *hidpp,\n\tu8 feature_index, u8 char_index, char *device_name, int len_buf)\n{\n\tstruct hidpp_report response;\n\tint ret, i;\n\tint count;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\tCMD_GET_DEVICE_NAME_TYPE_GET_DEVICE_NAME, &char_index, 1,\n\t\t&response);\n\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (response.report_id) {\n\tcase REPORT_ID_HIDPP_VERY_LONG:\n\t\tcount = hidpp->very_long_report_length - 4;\n\t\tbreak;\n\tcase REPORT_ID_HIDPP_LONG:\n\t\tcount = HIDPP_REPORT_LONG_LENGTH - 4;\n\t\tbreak;\n\tcase REPORT_ID_HIDPP_SHORT:\n\t\tcount = HIDPP_REPORT_SHORT_LENGTH - 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n\n\tif (len_buf < count)\n\t\tcount = len_buf;\n\n\tfor (i = 0; i < count; i++)\n\t\tdevice_name[i] = response.fap.params[i];\n\n\treturn count;\n}\n\nstatic char *hidpp_get_device_name(struct hidpp_device *hidpp)\n{\n\tu8 feature_type;\n\tu8 feature_index;\n\tu8 __name_length;\n\tchar *name;\n\tunsigned index = 0;\n\tint ret;\n\n\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_GET_DEVICE_NAME_TYPE,\n\t\t&feature_index, &feature_type);\n\tif (ret)\n\t\treturn NULL;\n\n\tret = hidpp_devicenametype_get_count(hidpp, feature_index,\n\t\t&__name_length);\n\tif (ret)\n\t\treturn NULL;\n\n\tname = kzalloc(__name_length + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\twhile (index < __name_length) {\n\t\tret = hidpp_devicenametype_get_device_name(hidpp,\n\t\t\tfeature_index, index, name + index,\n\t\t\t__name_length - index);\n\t\tif (ret <= 0) {\n\t\t\tkfree(name);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex += ret;\n\t}\n\n\t \n\thidpp_prefix_name(&name, __name_length + 1);\n\n\treturn name;\n}\n\n \n \n \n\n#define HIDPP_PAGE_BATTERY_LEVEL_STATUS\t\t\t\t0x1000\n\n#define CMD_BATTERY_LEVEL_STATUS_GET_BATTERY_LEVEL_STATUS\t0x00\n#define CMD_BATTERY_LEVEL_STATUS_GET_BATTERY_CAPABILITY\t\t0x10\n\n#define EVENT_BATTERY_LEVEL_STATUS_BROADCAST\t\t\t0x00\n\n#define FLAG_BATTERY_LEVEL_DISABLE_OSD\t\t\t\tBIT(0)\n#define FLAG_BATTERY_LEVEL_MILEAGE\t\t\t\tBIT(1)\n#define FLAG_BATTERY_LEVEL_RECHARGEABLE\t\t\t\tBIT(2)\n\nstatic int hidpp_map_battery_level(int capacity)\n{\n\tif (capacity < 11)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t \n\telse if (capacity < 30)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\telse if (capacity < 81)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\treturn POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n}\n\nstatic int hidpp20_batterylevel_map_status_capacity(u8 data[3], int *capacity,\n\t\t\t\t\t\t    int *next_capacity,\n\t\t\t\t\t\t    int *level)\n{\n\tint status;\n\n\t*capacity = data[0];\n\t*next_capacity = data[1];\n\t*level = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\n\t \n\tswitch (data[2]) {\n\t\tcase 0:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\t\t*level = hidpp_map_battery_level(*capacity);\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\t\t*level = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\t\t\t*capacity = 100;\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic int hidpp20_batterylevel_get_battery_capacity(struct hidpp_device *hidpp,\n\t\t\t\t\t\t     u8 feature_index,\n\t\t\t\t\t\t     int *status,\n\t\t\t\t\t\t     int *capacity,\n\t\t\t\t\t\t     int *next_capacity,\n\t\t\t\t\t\t     int *level)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 *params = (u8 *)response.fap.params;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_BATTERY_LEVEL_STATUS_GET_BATTERY_LEVEL_STATUS,\n\t\t\t\t\t  NULL, 0, &response);\n\t \n\tif (ret == HIDPP_ERROR_RESOURCE_ERROR)\n\t\treturn -EIO;\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t*status = hidpp20_batterylevel_map_status_capacity(params, capacity,\n\t\t\t\t\t\t\t   next_capacity,\n\t\t\t\t\t\t\t   level);\n\n\treturn 0;\n}\n\nstatic int hidpp20_batterylevel_get_battery_info(struct hidpp_device *hidpp,\n\t\t\t\t\t\t  u8 feature_index)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 *params = (u8 *)response.fap.params;\n\tunsigned int level_count, flags;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_BATTERY_LEVEL_STATUS_GET_BATTERY_CAPABILITY,\n\t\t\t\t\t  NULL, 0, &response);\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tlevel_count = params[0];\n\tflags = params[1];\n\n\tif (level_count < 10 || !(flags & FLAG_BATTERY_LEVEL_MILEAGE))\n\t\thidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_LEVEL_STATUS;\n\telse\n\t\thidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_MILEAGE;\n\n\treturn 0;\n}\n\nstatic int hidpp20_query_battery_info_1000(struct hidpp_device *hidpp)\n{\n\tu8 feature_type;\n\tint ret;\n\tint status, capacity, next_capacity, level;\n\n\tif (hidpp->battery.feature_index == 0xff) {\n\t\tret = hidpp_root_get_feature(hidpp,\n\t\t\t\t\t     HIDPP_PAGE_BATTERY_LEVEL_STATUS,\n\t\t\t\t\t     &hidpp->battery.feature_index,\n\t\t\t\t\t     &feature_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hidpp20_batterylevel_get_battery_capacity(hidpp,\n\t\t\t\t\t\thidpp->battery.feature_index,\n\t\t\t\t\t\t&status, &capacity,\n\t\t\t\t\t\t&next_capacity, &level);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hidpp20_batterylevel_get_battery_info(hidpp,\n\t\t\t\t\t\thidpp->battery.feature_index);\n\tif (ret)\n\t\treturn ret;\n\n\thidpp->battery.status = status;\n\thidpp->battery.capacity = capacity;\n\thidpp->battery.level = level;\n\t \n\thidpp->battery.online = status == POWER_SUPPLY_STATUS_DISCHARGING ||\n\t\t\t\tstatus == POWER_SUPPLY_STATUS_FULL;\n\n\treturn 0;\n}\n\nstatic int hidpp20_battery_event_1000(struct hidpp_device *hidpp,\n\t\t\t\t u8 *data, int size)\n{\n\tstruct hidpp_report *report = (struct hidpp_report *)data;\n\tint status, capacity, next_capacity, level;\n\tbool changed;\n\n\tif (report->fap.feature_index != hidpp->battery.feature_index ||\n\t    report->fap.funcindex_clientid != EVENT_BATTERY_LEVEL_STATUS_BROADCAST)\n\t\treturn 0;\n\n\tstatus = hidpp20_batterylevel_map_status_capacity(report->fap.params,\n\t\t\t\t\t\t\t  &capacity,\n\t\t\t\t\t\t\t  &next_capacity,\n\t\t\t\t\t\t\t  &level);\n\n\t \n\thidpp->battery.online = status == POWER_SUPPLY_STATUS_DISCHARGING ||\n\t\t\t\tstatus == POWER_SUPPLY_STATUS_FULL;\n\n\tchanged = capacity != hidpp->battery.capacity ||\n\t\t  level != hidpp->battery.level ||\n\t\t  status != hidpp->battery.status;\n\n\tif (changed) {\n\t\thidpp->battery.level = level;\n\t\thidpp->battery.capacity = capacity;\n\t\thidpp->battery.status = status;\n\t\tif (hidpp->battery.ps)\n\t\t\tpower_supply_changed(hidpp->battery.ps);\n\t}\n\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_BATTERY_VOLTAGE 0x1001\n\n#define CMD_BATTERY_VOLTAGE_GET_BATTERY_VOLTAGE 0x00\n\n#define EVENT_BATTERY_VOLTAGE_STATUS_BROADCAST 0x00\n\nstatic int hidpp20_battery_map_status_voltage(u8 data[3], int *voltage,\n\t\t\t\t\t\tint *level, int *charge_type)\n{\n\tint status;\n\n\tlong flags = (long) data[2];\n\t*level = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\n\tif (flags & 0x80)\n\t\tswitch (flags & 0x07) {\n\t\tcase 0:\n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\t\t*level = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\telse\n\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\n\t*charge_type = POWER_SUPPLY_CHARGE_TYPE_STANDARD;\n\tif (test_bit(3, &flags)) {\n\t\t*charge_type = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t}\n\tif (test_bit(4, &flags)) {\n\t\t*charge_type = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\n\t}\n\tif (test_bit(5, &flags)) {\n\t\t*level = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t}\n\n\t*voltage = get_unaligned_be16(data);\n\n\treturn status;\n}\n\nstatic int hidpp20_battery_get_battery_voltage(struct hidpp_device *hidpp,\n\t\t\t\t\t\t u8 feature_index,\n\t\t\t\t\t\t int *status, int *voltage,\n\t\t\t\t\t\t int *level, int *charge_type)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 *params = (u8 *)response.fap.params;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_BATTERY_VOLTAGE_GET_BATTERY_VOLTAGE,\n\t\t\t\t\t  NULL, 0, &response);\n\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\thidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_VOLTAGE;\n\n\t*status = hidpp20_battery_map_status_voltage(params, voltage,\n\t\t\t\t\t\t     level, charge_type);\n\n\treturn 0;\n}\n\nstatic int hidpp20_map_battery_capacity(struct hid_device *hid_dev, int voltage)\n{\n\t \n\n\tstatic const int voltages[100] = {\n\t\t4186, 4156, 4143, 4133, 4122, 4113, 4103, 4094, 4086, 4075,\n\t\t4067, 4059, 4051, 4043, 4035, 4027, 4019, 4011, 4003, 3997,\n\t\t3989, 3983, 3976, 3969, 3961, 3955, 3949, 3942, 3935, 3929,\n\t\t3922, 3916, 3909, 3902, 3896, 3890, 3883, 3877, 3870, 3865,\n\t\t3859, 3853, 3848, 3842, 3837, 3833, 3828, 3824, 3819, 3815,\n\t\t3811, 3808, 3804, 3800, 3797, 3793, 3790, 3787, 3784, 3781,\n\t\t3778, 3775, 3772, 3770, 3767, 3764, 3762, 3759, 3757, 3754,\n\t\t3751, 3748, 3744, 3741, 3737, 3734, 3730, 3726, 3724, 3720,\n\t\t3717, 3714, 3710, 3706, 3702, 3697, 3693, 3688, 3683, 3677,\n\t\t3671, 3666, 3662, 3658, 3654, 3646, 3633, 3612, 3579, 3537\n\t};\n\n\tint i;\n\n\tif (unlikely(voltage < 3500 || voltage >= 5000))\n\t\thid_warn_once(hid_dev,\n\t\t\t      \"%s: possibly using the wrong voltage curve\\n\",\n\t\t\t      __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(voltages); i++) {\n\t\tif (voltage >= voltages[i])\n\t\t\treturn ARRAY_SIZE(voltages) - i;\n\t}\n\n\treturn 0;\n}\n\nstatic int hidpp20_query_battery_voltage_info(struct hidpp_device *hidpp)\n{\n\tu8 feature_type;\n\tint ret;\n\tint status, voltage, level, charge_type;\n\n\tif (hidpp->battery.voltage_feature_index == 0xff) {\n\t\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_BATTERY_VOLTAGE,\n\t\t\t\t\t     &hidpp->battery.voltage_feature_index,\n\t\t\t\t\t     &feature_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hidpp20_battery_get_battery_voltage(hidpp,\n\t\t\t\t\t\t  hidpp->battery.voltage_feature_index,\n\t\t\t\t\t\t  &status, &voltage, &level, &charge_type);\n\n\tif (ret)\n\t\treturn ret;\n\n\thidpp->battery.status = status;\n\thidpp->battery.voltage = voltage;\n\thidpp->battery.capacity = hidpp20_map_battery_capacity(hidpp->hid_dev,\n\t\t\t\t\t\t\t       voltage);\n\thidpp->battery.level = level;\n\thidpp->battery.charge_type = charge_type;\n\thidpp->battery.online = status != POWER_SUPPLY_STATUS_NOT_CHARGING;\n\n\treturn 0;\n}\n\nstatic int hidpp20_battery_voltage_event(struct hidpp_device *hidpp,\n\t\t\t\t\t    u8 *data, int size)\n{\n\tstruct hidpp_report *report = (struct hidpp_report *)data;\n\tint status, voltage, level, charge_type;\n\n\tif (report->fap.feature_index != hidpp->battery.voltage_feature_index ||\n\t\treport->fap.funcindex_clientid != EVENT_BATTERY_VOLTAGE_STATUS_BROADCAST)\n\t\treturn 0;\n\n\tstatus = hidpp20_battery_map_status_voltage(report->fap.params, &voltage,\n\t\t\t\t\t\t    &level, &charge_type);\n\n\thidpp->battery.online = status != POWER_SUPPLY_STATUS_NOT_CHARGING;\n\n\tif (voltage != hidpp->battery.voltage || status != hidpp->battery.status) {\n\t\thidpp->battery.voltage = voltage;\n\t\thidpp->battery.capacity = hidpp20_map_battery_capacity(hidpp->hid_dev,\n\t\t\t\t\t\t\t\t       voltage);\n\t\thidpp->battery.status = status;\n\t\thidpp->battery.level = level;\n\t\thidpp->battery.charge_type = charge_type;\n\t\tif (hidpp->battery.ps)\n\t\t\tpower_supply_changed(hidpp->battery.ps);\n\t}\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_UNIFIED_BATTERY\t\t\t\t0x1004\n\n#define CMD_UNIFIED_BATTERY_GET_CAPABILITIES\t\t\t0x00\n#define CMD_UNIFIED_BATTERY_GET_STATUS\t\t\t\t0x10\n\n#define EVENT_UNIFIED_BATTERY_STATUS_EVENT\t\t\t0x00\n\n#define FLAG_UNIFIED_BATTERY_LEVEL_CRITICAL\t\t\tBIT(0)\n#define FLAG_UNIFIED_BATTERY_LEVEL_LOW\t\t\t\tBIT(1)\n#define FLAG_UNIFIED_BATTERY_LEVEL_GOOD\t\t\t\tBIT(2)\n#define FLAG_UNIFIED_BATTERY_LEVEL_FULL\t\t\t\tBIT(3)\n\n#define FLAG_UNIFIED_BATTERY_FLAGS_RECHARGEABLE\t\t\tBIT(0)\n#define FLAG_UNIFIED_BATTERY_FLAGS_STATE_OF_CHARGE\t\tBIT(1)\n\nstatic int hidpp20_unifiedbattery_get_capabilities(struct hidpp_device *hidpp,\n\t\t\t\t\t\t   u8 feature_index)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 *params = (u8 *)response.fap.params;\n\n\tif (hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_LEVEL_STATUS ||\n\t    hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_PERCENTAGE) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_UNIFIED_BATTERY_GET_CAPABILITIES,\n\t\t\t\t\t  NULL, 0, &response);\n\t \n\tif (ret == HIDPP_ERROR_RESOURCE_ERROR)\n\t\treturn -EIO;\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (params[1] & FLAG_UNIFIED_BATTERY_FLAGS_STATE_OF_CHARGE) {\n\t\thidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_PERCENTAGE;\n\t\thidpp->battery.supported_levels_1004 = 0;\n\t} else {\n\t\thidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_LEVEL_STATUS;\n\t\thidpp->battery.supported_levels_1004 = params[0];\n\t}\n\n\treturn 0;\n}\n\nstatic int hidpp20_unifiedbattery_map_status(struct hidpp_device *hidpp,\n\t\t\t\t\t     u8 charging_status,\n\t\t\t\t\t     u8 external_power_status)\n{\n\tint status;\n\n\tswitch (charging_status) {\n\t\tcase 0:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\tcase 2:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\thid_info(hidpp->hid_dev, \"%s: charging error\",\n\t\t\t\t hidpp->name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic int hidpp20_unifiedbattery_map_level(struct hidpp_device *hidpp,\n\t\t\t\t\t    u8 battery_level)\n{\n\t \n\tbattery_level &= hidpp->battery.supported_levels_1004;\n\n\tif (battery_level & FLAG_UNIFIED_BATTERY_LEVEL_FULL)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\telse if (battery_level & FLAG_UNIFIED_BATTERY_LEVEL_GOOD)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\telse if (battery_level & FLAG_UNIFIED_BATTERY_LEVEL_LOW)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\telse if (battery_level & FLAG_UNIFIED_BATTERY_LEVEL_CRITICAL)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\n\treturn POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n}\n\nstatic int hidpp20_unifiedbattery_get_status(struct hidpp_device *hidpp,\n\t\t\t\t\t     u8 feature_index,\n\t\t\t\t\t     u8 *state_of_charge,\n\t\t\t\t\t     int *status,\n\t\t\t\t\t     int *level)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 *params = (u8 *)response.fap.params;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_UNIFIED_BATTERY_GET_STATUS,\n\t\t\t\t\t  NULL, 0, &response);\n\t \n\tif (ret == HIDPP_ERROR_RESOURCE_ERROR)\n\t\treturn -EIO;\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t*state_of_charge = params[0];\n\t*status = hidpp20_unifiedbattery_map_status(hidpp, params[2], params[3]);\n\t*level = hidpp20_unifiedbattery_map_level(hidpp, params[1]);\n\n\treturn 0;\n}\n\nstatic int hidpp20_query_battery_info_1004(struct hidpp_device *hidpp)\n{\n\tu8 feature_type;\n\tint ret;\n\tu8 state_of_charge;\n\tint status, level;\n\n\tif (hidpp->battery.feature_index == 0xff) {\n\t\tret = hidpp_root_get_feature(hidpp,\n\t\t\t\t\t     HIDPP_PAGE_UNIFIED_BATTERY,\n\t\t\t\t\t     &hidpp->battery.feature_index,\n\t\t\t\t\t     &feature_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hidpp20_unifiedbattery_get_capabilities(hidpp,\n\t\t\t\t\thidpp->battery.feature_index);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hidpp20_unifiedbattery_get_status(hidpp,\n\t\t\t\t\t\thidpp->battery.feature_index,\n\t\t\t\t\t\t&state_of_charge,\n\t\t\t\t\t\t&status,\n\t\t\t\t\t\t&level);\n\tif (ret)\n\t\treturn ret;\n\n\thidpp->capabilities |= HIDPP_CAPABILITY_UNIFIED_BATTERY;\n\thidpp->battery.capacity = state_of_charge;\n\thidpp->battery.status = status;\n\thidpp->battery.level = level;\n\thidpp->battery.online = true;\n\n\treturn 0;\n}\n\nstatic int hidpp20_battery_event_1004(struct hidpp_device *hidpp,\n\t\t\t\t u8 *data, int size)\n{\n\tstruct hidpp_report *report = (struct hidpp_report *)data;\n\tu8 *params = (u8 *)report->fap.params;\n\tint state_of_charge, status, level;\n\tbool changed;\n\n\tif (report->fap.feature_index != hidpp->battery.feature_index ||\n\t    report->fap.funcindex_clientid != EVENT_UNIFIED_BATTERY_STATUS_EVENT)\n\t\treturn 0;\n\n\tstate_of_charge = params[0];\n\tstatus = hidpp20_unifiedbattery_map_status(hidpp, params[2], params[3]);\n\tlevel = hidpp20_unifiedbattery_map_level(hidpp, params[1]);\n\n\tchanged = status != hidpp->battery.status ||\n\t\t  (state_of_charge != hidpp->battery.capacity &&\n\t\t   hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_PERCENTAGE) ||\n\t\t  (level != hidpp->battery.level &&\n\t\t   hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_LEVEL_STATUS);\n\n\tif (changed) {\n\t\thidpp->battery.capacity = state_of_charge;\n\t\thidpp->battery.status = status;\n\t\thidpp->battery.level = level;\n\t\tif (hidpp->battery.ps)\n\t\t\tpower_supply_changed(hidpp->battery.ps);\n\t}\n\n\treturn 0;\n}\n\n \n \n \n\nstatic enum power_supply_property hidpp_battery_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n\t0,  \n\t0,  \n\t0,  \n};\n\nstatic int hidpp_battery_get_property(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tstruct hidpp_device *hidpp = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch(psp) {\n\t\tcase POWER_SUPPLY_PROP_STATUS:\n\t\t\tval->intval = hidpp->battery.status;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\t\tval->intval = hidpp->battery.capacity;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\t\tval->intval = hidpp->battery.level;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\t\tval->intval = hidpp->battery.online;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\t\tif (!strncmp(hidpp->name, \"Logitech \", 9))\n\t\t\t\tval->strval = hidpp->name + 9;\n\t\t\telse\n\t\t\t\tval->strval = hidpp->name;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\t\tval->strval = \"Logitech\";\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\t\tval->strval = hidpp->hid_dev->uniq;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\t\t \n\t\t\tval->intval = hidpp->battery.voltage * 1000;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\t\tval->intval = hidpp->battery.charge_type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \n \n \n#define HIDPP_PAGE_WIRELESS_DEVICE_STATUS\t\t\t0x1d4b\n\nstatic int hidpp_get_wireless_feature_index(struct hidpp_device *hidpp, u8 *feature_index)\n{\n\tu8 feature_type;\n\tint ret;\n\n\tret = hidpp_root_get_feature(hidpp,\n\t\t\t\t     HIDPP_PAGE_WIRELESS_DEVICE_STATUS,\n\t\t\t\t     feature_index, &feature_type);\n\n\treturn ret;\n}\n\n \n \n \n\n#define HIDPP_PAGE_ADC_MEASUREMENT 0x1f20\n\n#define CMD_ADC_MEASUREMENT_GET_ADC_MEASUREMENT 0x00\n\n#define EVENT_ADC_MEASUREMENT_STATUS_BROADCAST 0x00\n\nstatic int hidpp20_map_adc_measurement_1f20_capacity(struct hid_device *hid_dev, int voltage)\n{\n\t \n\tstatic const int voltages[100] = {\n\t\t4030, 4024, 4018, 4011, 4003, 3994, 3985, 3975, 3963, 3951,\n\t\t3937, 3922, 3907, 3893, 3880, 3868, 3857, 3846, 3837, 3828,\n\t\t3820, 3812, 3805, 3798, 3791, 3785, 3779, 3773, 3768, 3762,\n\t\t3757, 3752, 3747, 3742, 3738, 3733, 3729, 3724, 3720, 3716,\n\t\t3712, 3708, 3704, 3700, 3696, 3692, 3688, 3685, 3681, 3677,\n\t\t3674, 3670, 3667, 3663, 3660, 3657, 3653, 3650, 3646, 3643,\n\t\t3640, 3637, 3633, 3630, 3627, 3624, 3620, 3617, 3614, 3611,\n\t\t3608, 3604, 3601, 3598, 3595, 3592, 3589, 3585, 3582, 3579,\n\t\t3576, 3573, 3569, 3566, 3563, 3560, 3556, 3553, 3550, 3546,\n\t\t3543, 3539, 3536, 3532, 3529, 3525, 3499, 3466, 3433, 3399,\n\t};\n\n\tint i;\n\n\tif (voltage == 0)\n\t\treturn 0;\n\n\tif (unlikely(voltage < 3400 || voltage >= 5000))\n\t\thid_warn_once(hid_dev,\n\t\t\t      \"%s: possibly using the wrong voltage curve\\n\",\n\t\t\t      __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(voltages); i++) {\n\t\tif (voltage >= voltages[i])\n\t\t\treturn ARRAY_SIZE(voltages) - i;\n\t}\n\n\treturn 0;\n}\n\nstatic int hidpp20_map_adc_measurement_1f20(u8 data[3], int *voltage)\n{\n\tint status;\n\tu8 flags;\n\n\tflags = data[2];\n\n\tswitch (flags) {\n\tcase 0x01:\n\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase 0x03:\n\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\tbreak;\n\tcase 0x07:\n\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\tbreak;\n\tcase 0x0F:\n\tdefault:\n\t\tstatus = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\tbreak;\n\t}\n\n\t*voltage = get_unaligned_be16(data);\n\n\tdbg_hid(\"Parsed 1f20 data as flag 0x%02x voltage %dmV\\n\",\n\t\tflags, *voltage);\n\n\treturn status;\n}\n\n \nstatic bool hidpp20_get_adc_measurement_1f20(struct hidpp_device *hidpp,\n\t\t\t\t\t\t u8 feature_index,\n\t\t\t\t\t\t int *status, int *voltage)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 *params = (u8 *)response.fap.params;\n\n\t*status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t*voltage = 0;\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_ADC_MEASUREMENT_GET_ADC_MEASUREMENT,\n\t\t\t\t\t  NULL, 0, &response);\n\n\tif (ret > 0) {\n\t\thid_dbg(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn false;\n\t}\n\n\t*status = hidpp20_map_adc_measurement_1f20(params, voltage);\n\treturn true;\n}\n\nstatic int hidpp20_query_adc_measurement_info_1f20(struct hidpp_device *hidpp)\n{\n\tu8 feature_type;\n\n\tif (hidpp->battery.adc_measurement_feature_index == 0xff) {\n\t\tint ret;\n\n\t\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_ADC_MEASUREMENT,\n\t\t\t\t\t     &hidpp->battery.adc_measurement_feature_index,\n\t\t\t\t\t     &feature_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\thidpp->capabilities |= HIDPP_CAPABILITY_ADC_MEASUREMENT;\n\t}\n\n\thidpp->battery.online = hidpp20_get_adc_measurement_1f20(hidpp,\n\t\t\t\t\t\t\t\t hidpp->battery.adc_measurement_feature_index,\n\t\t\t\t\t\t\t\t &hidpp->battery.status,\n\t\t\t\t\t\t\t\t &hidpp->battery.voltage);\n\thidpp->battery.capacity = hidpp20_map_adc_measurement_1f20_capacity(hidpp->hid_dev,\n\t\t\t\t\t\t\t\t\t    hidpp->battery.voltage);\n\thidpp_update_usb_wireless_status(hidpp);\n\n\treturn 0;\n}\n\nstatic int hidpp20_adc_measurement_event_1f20(struct hidpp_device *hidpp,\n\t\t\t\t\t    u8 *data, int size)\n{\n\tstruct hidpp_report *report = (struct hidpp_report *)data;\n\tint status, voltage;\n\n\tif (report->fap.feature_index != hidpp->battery.adc_measurement_feature_index ||\n\t\treport->fap.funcindex_clientid != EVENT_ADC_MEASUREMENT_STATUS_BROADCAST)\n\t\treturn 0;\n\n\tstatus = hidpp20_map_adc_measurement_1f20(report->fap.params, &voltage);\n\n\thidpp->battery.online = status != POWER_SUPPLY_STATUS_UNKNOWN;\n\n\tif (voltage != hidpp->battery.voltage || status != hidpp->battery.status) {\n\t\thidpp->battery.status = status;\n\t\thidpp->battery.voltage = voltage;\n\t\thidpp->battery.capacity = hidpp20_map_adc_measurement_1f20_capacity(hidpp->hid_dev, voltage);\n\t\tif (hidpp->battery.ps)\n\t\t\tpower_supply_changed(hidpp->battery.ps);\n\t\thidpp_update_usb_wireless_status(hidpp);\n\t}\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_HI_RESOLUTION_SCROLLING\t\t\t0x2120\n\n#define CMD_HI_RESOLUTION_SCROLLING_SET_HIGHRES_SCROLLING_MODE\t0x10\n\nstatic int hidpp_hrs_set_highres_scrolling_mode(struct hidpp_device *hidpp,\n\tbool enabled, u8 *multiplier)\n{\n\tu8 feature_index;\n\tu8 feature_type;\n\tint ret;\n\tu8 params[1];\n\tstruct hidpp_report response;\n\n\tret = hidpp_root_get_feature(hidpp,\n\t\t\t\t     HIDPP_PAGE_HI_RESOLUTION_SCROLLING,\n\t\t\t\t     &feature_index,\n\t\t\t\t     &feature_type);\n\tif (ret)\n\t\treturn ret;\n\n\tparams[0] = enabled ? BIT(0) : 0;\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_HI_RESOLUTION_SCROLLING_SET_HIGHRES_SCROLLING_MODE,\n\t\t\t\t\t  params, sizeof(params), &response);\n\tif (ret)\n\t\treturn ret;\n\t*multiplier = response.fap.params[1];\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_HIRES_WHEEL\t\t0x2121\n\n#define CMD_HIRES_WHEEL_GET_WHEEL_CAPABILITY\t0x00\n#define CMD_HIRES_WHEEL_SET_WHEEL_MODE\t\t0x20\n\nstatic int hidpp_hrw_get_wheel_capability(struct hidpp_device *hidpp,\n\tu8 *multiplier)\n{\n\tu8 feature_index;\n\tu8 feature_type;\n\tint ret;\n\tstruct hidpp_report response;\n\n\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_HIRES_WHEEL,\n\t\t\t\t     &feature_index, &feature_type);\n\tif (ret)\n\t\tgoto return_default;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t  CMD_HIRES_WHEEL_GET_WHEEL_CAPABILITY,\n\t\t\t\t\t  NULL, 0, &response);\n\tif (ret)\n\t\tgoto return_default;\n\n\t*multiplier = response.fap.params[0];\n\treturn 0;\nreturn_default:\n\thid_warn(hidpp->hid_dev,\n\t\t \"Couldn't get wheel multiplier (error %d)\\n\", ret);\n\treturn ret;\n}\n\nstatic int hidpp_hrw_set_wheel_mode(struct hidpp_device *hidpp, bool invert,\n\tbool high_resolution, bool use_hidpp)\n{\n\tu8 feature_index;\n\tu8 feature_type;\n\tint ret;\n\tu8 params[1];\n\tstruct hidpp_report response;\n\n\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_HIRES_WHEEL,\n\t\t\t\t     &feature_index, &feature_type);\n\tif (ret)\n\t\treturn ret;\n\n\tparams[0] = (invert          ? BIT(2) : 0) |\n\t\t    (high_resolution ? BIT(1) : 0) |\n\t\t    (use_hidpp       ? BIT(0) : 0);\n\n\treturn hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\t\t\t\t   CMD_HIRES_WHEEL_SET_WHEEL_MODE,\n\t\t\t\t\t   params, sizeof(params), &response);\n}\n\n \n \n \n\n#define HIDPP_PAGE_SOLAR_KEYBOARD\t\t\t0x4301\n\n#define CMD_SOLAR_SET_LIGHT_MEASURE\t\t\t0x00\n\n#define EVENT_SOLAR_BATTERY_BROADCAST\t\t\t0x00\n#define EVENT_SOLAR_BATTERY_LIGHT_MEASURE\t\t0x10\n#define EVENT_SOLAR_CHECK_LIGHT_BUTTON\t\t\t0x20\n\nstatic int hidpp_solar_request_battery_event(struct hidpp_device *hidpp)\n{\n\tstruct hidpp_report response;\n\tu8 params[2] = { 1, 1 };\n\tu8 feature_type;\n\tint ret;\n\n\tif (hidpp->battery.feature_index == 0xff) {\n\t\tret = hidpp_root_get_feature(hidpp,\n\t\t\t\t\t     HIDPP_PAGE_SOLAR_KEYBOARD,\n\t\t\t\t\t     &hidpp->battery.solar_feature_index,\n\t\t\t\t\t     &feature_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hidpp_send_fap_command_sync(hidpp,\n\t\t\t\t\t  hidpp->battery.solar_feature_index,\n\t\t\t\t\t  CMD_SOLAR_SET_LIGHT_MEASURE,\n\t\t\t\t\t  params, 2, &response);\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\thidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_MILEAGE;\n\n\treturn 0;\n}\n\nstatic int hidpp_solar_battery_event(struct hidpp_device *hidpp,\n\t\t\t\t     u8 *data, int size)\n{\n\tstruct hidpp_report *report = (struct hidpp_report *)data;\n\tint capacity, lux, status;\n\tu8 function;\n\n\tfunction = report->fap.funcindex_clientid;\n\n\n\tif (report->fap.feature_index != hidpp->battery.solar_feature_index ||\n\t    !(function == EVENT_SOLAR_BATTERY_BROADCAST ||\n\t      function == EVENT_SOLAR_BATTERY_LIGHT_MEASURE ||\n\t      function == EVENT_SOLAR_CHECK_LIGHT_BUTTON))\n\t\treturn 0;\n\n\tcapacity = report->fap.params[0];\n\n\tswitch (function) {\n\tcase EVENT_SOLAR_BATTERY_LIGHT_MEASURE:\n\t\tlux = (report->fap.params[1] << 8) | report->fap.params[2];\n\t\tif (lux > 200)\n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse\n\t\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tcase EVENT_SOLAR_CHECK_LIGHT_BUTTON:\n\tdefault:\n\t\tif (capacity < hidpp->battery.capacity)\n\t\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\telse\n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\n\t}\n\n\tif (capacity == 100)\n\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\n\thidpp->battery.online = true;\n\tif (capacity != hidpp->battery.capacity ||\n\t    status != hidpp->battery.status) {\n\t\thidpp->battery.capacity = capacity;\n\t\thidpp->battery.status = status;\n\t\tif (hidpp->battery.ps)\n\t\t\tpower_supply_changed(hidpp->battery.ps);\n\t}\n\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_TOUCHPAD_FW_ITEMS\t\t\t0x6010\n\n#define CMD_TOUCHPAD_FW_ITEMS_SET\t\t\t0x10\n\nstruct hidpp_touchpad_fw_items {\n\tuint8_t presence;\n\tuint8_t desired_state;\n\tuint8_t state;\n\tuint8_t persistent;\n};\n\n \nstatic int hidpp_touchpad_fw_items_set(struct hidpp_device *hidpp,\n\t\t\t\t       u8 feature_index,\n\t\t\t\t       struct hidpp_touchpad_fw_items *items)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 *params = (u8 *)response.fap.params;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\tCMD_TOUCHPAD_FW_ITEMS_SET, &items->state, 1, &response);\n\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\titems->presence = params[0];\n\titems->desired_state = params[1];\n\titems->state = params[2];\n\titems->persistent = params[3];\n\n\treturn 0;\n}\n\n \n \n \n\n#define HIDPP_PAGE_TOUCHPAD_RAW_XY\t\t\t0x6100\n\n#define CMD_TOUCHPAD_GET_RAW_INFO\t\t\t0x00\n#define CMD_TOUCHPAD_SET_RAW_REPORT_STATE\t\t0x20\n\n#define EVENT_TOUCHPAD_RAW_XY\t\t\t\t0x00\n\n#define TOUCHPAD_RAW_XY_ORIGIN_LOWER_LEFT\t\t0x01\n#define TOUCHPAD_RAW_XY_ORIGIN_UPPER_LEFT\t\t0x03\n\nstruct hidpp_touchpad_raw_info {\n\tu16 x_size;\n\tu16 y_size;\n\tu8 z_range;\n\tu8 area_range;\n\tu8 timestamp_unit;\n\tu8 maxcontacts;\n\tu8 origin;\n\tu16 res;\n};\n\nstruct hidpp_touchpad_raw_xy_finger {\n\tu8 contact_type;\n\tu8 contact_status;\n\tu16 x;\n\tu16 y;\n\tu8 z;\n\tu8 area;\n\tu8 finger_id;\n};\n\nstruct hidpp_touchpad_raw_xy {\n\tu16 timestamp;\n\tstruct hidpp_touchpad_raw_xy_finger fingers[2];\n\tu8 spurious_flag;\n\tu8 end_of_frame;\n\tu8 finger_count;\n\tu8 button;\n};\n\nstatic int hidpp_touchpad_get_raw_info(struct hidpp_device *hidpp,\n\tu8 feature_index, struct hidpp_touchpad_raw_info *raw_info)\n{\n\tstruct hidpp_report response;\n\tint ret;\n\tu8 *params = (u8 *)response.fap.params;\n\n\tret = hidpp_send_fap_command_sync(hidpp, feature_index,\n\t\tCMD_TOUCHPAD_GET_RAW_INFO, NULL, 0, &response);\n\n\tif (ret > 0) {\n\t\thid_err(hidpp->hid_dev, \"%s: received protocol error 0x%02x\\n\",\n\t\t\t__func__, ret);\n\t\treturn -EPROTO;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\traw_info->x_size = get_unaligned_be16(&params[0]);\n\traw_info->y_size = get_unaligned_be16(&params[2]);\n\traw_info->z_range = params[4];\n\traw_info->area_range = params[5];\n\traw_info->maxcontacts = params[7];\n\traw_info->origin = params[8];\n\t \n\traw_info->res = get_unaligned_be16(&params[13]) * 2 / 51;\n\n\treturn ret;\n}\n\nstatic int hidpp_touchpad_set_raw_report_state(struct hidpp_device *hidpp_dev,\n\t\tu8 feature_index, bool send_raw_reports,\n\t\tbool sensor_enhanced_settings)\n{\n\tstruct hidpp_report response;\n\n\t \n\tu8 params = send_raw_reports | (sensor_enhanced_settings << 2);\n\n\treturn hidpp_send_fap_command_sync(hidpp_dev, feature_index,\n\t\tCMD_TOUCHPAD_SET_RAW_REPORT_STATE, &params, 1, &response);\n}\n\nstatic void hidpp_touchpad_touch_event(u8 *data,\n\tstruct hidpp_touchpad_raw_xy_finger *finger)\n{\n\tu8 x_m = data[0] << 2;\n\tu8 y_m = data[2] << 2;\n\n\tfinger->x = x_m << 6 | data[1];\n\tfinger->y = y_m << 6 | data[3];\n\n\tfinger->contact_type = data[0] >> 6;\n\tfinger->contact_status = data[2] >> 6;\n\n\tfinger->z = data[4];\n\tfinger->area = data[5];\n\tfinger->finger_id = data[6] >> 4;\n}\n\nstatic void hidpp_touchpad_raw_xy_event(struct hidpp_device *hidpp_dev,\n\t\tu8 *data, struct hidpp_touchpad_raw_xy *raw_xy)\n{\n\tmemset(raw_xy, 0, sizeof(struct hidpp_touchpad_raw_xy));\n\traw_xy->end_of_frame = data[8] & 0x01;\n\traw_xy->spurious_flag = (data[8] >> 1) & 0x01;\n\traw_xy->finger_count = data[15] & 0x0f;\n\traw_xy->button = (data[8] >> 2) & 0x01;\n\n\tif (raw_xy->finger_count) {\n\t\thidpp_touchpad_touch_event(&data[2], &raw_xy->fingers[0]);\n\t\thidpp_touchpad_touch_event(&data[9], &raw_xy->fingers[1]);\n\t}\n}\n\n \n \n \n\n#define HIDPP_FF_GET_INFO\t\t0x01\n#define HIDPP_FF_RESET_ALL\t\t0x11\n#define HIDPP_FF_DOWNLOAD_EFFECT\t0x21\n#define HIDPP_FF_SET_EFFECT_STATE\t0x31\n#define HIDPP_FF_DESTROY_EFFECT\t\t0x41\n#define HIDPP_FF_GET_APERTURE\t\t0x51\n#define HIDPP_FF_SET_APERTURE\t\t0x61\n#define HIDPP_FF_GET_GLOBAL_GAINS\t0x71\n#define HIDPP_FF_SET_GLOBAL_GAINS\t0x81\n\n#define HIDPP_FF_EFFECT_STATE_GET\t0x00\n#define HIDPP_FF_EFFECT_STATE_STOP\t0x01\n#define HIDPP_FF_EFFECT_STATE_PLAY\t0x02\n#define HIDPP_FF_EFFECT_STATE_PAUSE\t0x03\n\n#define HIDPP_FF_EFFECT_CONSTANT\t0x00\n#define HIDPP_FF_EFFECT_PERIODIC_SINE\t\t0x01\n#define HIDPP_FF_EFFECT_PERIODIC_SQUARE\t\t0x02\n#define HIDPP_FF_EFFECT_PERIODIC_TRIANGLE\t0x03\n#define HIDPP_FF_EFFECT_PERIODIC_SAWTOOTHUP\t0x04\n#define HIDPP_FF_EFFECT_PERIODIC_SAWTOOTHDOWN\t0x05\n#define HIDPP_FF_EFFECT_SPRING\t\t0x06\n#define HIDPP_FF_EFFECT_DAMPER\t\t0x07\n#define HIDPP_FF_EFFECT_FRICTION\t0x08\n#define HIDPP_FF_EFFECT_INERTIA\t\t0x09\n#define HIDPP_FF_EFFECT_RAMP\t\t0x0A\n\n#define HIDPP_FF_EFFECT_AUTOSTART\t0x80\n\n#define HIDPP_FF_EFFECTID_NONE\t\t-1\n#define HIDPP_FF_EFFECTID_AUTOCENTER\t-2\n#define HIDPP_AUTOCENTER_PARAMS_LENGTH\t18\n\n#define HIDPP_FF_MAX_PARAMS\t20\n#define HIDPP_FF_RESERVED_SLOTS\t1\n\nstruct hidpp_ff_private_data {\n\tstruct hidpp_device *hidpp;\n\tu8 feature_index;\n\tu8 version;\n\tu16 gain;\n\ts16 range;\n\tu8 slot_autocenter;\n\tu8 num_effects;\n\tint *effect_ids;\n\tstruct workqueue_struct *wq;\n\tatomic_t workqueue_size;\n};\n\nstruct hidpp_ff_work_data {\n\tstruct work_struct work;\n\tstruct hidpp_ff_private_data *data;\n\tint effect_id;\n\tu8 command;\n\tu8 params[HIDPP_FF_MAX_PARAMS];\n\tu8 size;\n};\n\nstatic const signed short hidpp_ff_effects[] = {\n\tFF_CONSTANT,\n\tFF_PERIODIC,\n\tFF_SINE,\n\tFF_SQUARE,\n\tFF_SAW_UP,\n\tFF_SAW_DOWN,\n\tFF_TRIANGLE,\n\tFF_SPRING,\n\tFF_DAMPER,\n\tFF_AUTOCENTER,\n\tFF_GAIN,\n\t-1\n};\n\nstatic const signed short hidpp_ff_effects_v2[] = {\n\tFF_RAMP,\n\tFF_FRICTION,\n\tFF_INERTIA,\n\t-1\n};\n\nstatic const u8 HIDPP_FF_CONDITION_CMDS[] = {\n\tHIDPP_FF_EFFECT_SPRING,\n\tHIDPP_FF_EFFECT_FRICTION,\n\tHIDPP_FF_EFFECT_DAMPER,\n\tHIDPP_FF_EFFECT_INERTIA\n};\n\nstatic const char *HIDPP_FF_CONDITION_NAMES[] = {\n\t\"spring\",\n\t\"friction\",\n\t\"damper\",\n\t\"inertia\"\n};\n\n\nstatic u8 hidpp_ff_find_effect(struct hidpp_ff_private_data *data, int effect_id)\n{\n\tint i;\n\n\tfor (i = 0; i < data->num_effects; i++)\n\t\tif (data->effect_ids[i] == effect_id)\n\t\t\treturn i+1;\n\n\treturn 0;\n}\n\nstatic void hidpp_ff_work_handler(struct work_struct *w)\n{\n\tstruct hidpp_ff_work_data *wd = container_of(w, struct hidpp_ff_work_data, work);\n\tstruct hidpp_ff_private_data *data = wd->data;\n\tstruct hidpp_report response;\n\tu8 slot;\n\tint ret;\n\n\t \n\tswitch (wd->effect_id) {\n\tcase HIDPP_FF_EFFECTID_AUTOCENTER:\n\t\twd->params[0] = data->slot_autocenter;\n\t\tbreak;\n\tcase HIDPP_FF_EFFECTID_NONE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\twd->params[0] = hidpp_ff_find_effect(data, wd->effect_id);\n\t\tbreak;\n\t}\n\n\t \n\tret = hidpp_send_fap_command_sync(data->hidpp, data->feature_index,\n\t\twd->command, wd->params, wd->size, &response);\n\n\tif (ret) {\n\t\thid_err(data->hidpp->hid_dev, \"Failed to send command to device!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (wd->command) {\n\tcase HIDPP_FF_DOWNLOAD_EFFECT:\n\t\tslot = response.fap.params[0];\n\t\tif (slot > 0 && slot <= data->num_effects) {\n\t\t\tif (wd->effect_id >= 0)\n\t\t\t\t \n\t\t\t\tdata->effect_ids[slot-1] = wd->effect_id;\n\t\t\telse if (wd->effect_id >= HIDPP_FF_EFFECTID_AUTOCENTER)\n\t\t\t\t \n\t\t\t\tdata->slot_autocenter = slot;\n\t\t}\n\t\tbreak;\n\tcase HIDPP_FF_DESTROY_EFFECT:\n\t\tif (wd->effect_id >= 0)\n\t\t\t \n\t\t\tdata->effect_ids[wd->params[0]-1] = -1;\n\t\telse if (wd->effect_id >= HIDPP_FF_EFFECTID_AUTOCENTER)\n\t\t\t \n\t\t\tdata->slot_autocenter = 0;\n\t\tbreak;\n\tcase HIDPP_FF_SET_GLOBAL_GAINS:\n\t\tdata->gain = (wd->params[0] << 8) + wd->params[1];\n\t\tbreak;\n\tcase HIDPP_FF_SET_APERTURE:\n\t\tdata->range = (wd->params[0] << 8) + wd->params[1];\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\nout:\n\tatomic_dec(&data->workqueue_size);\n\tkfree(wd);\n}\n\nstatic int hidpp_ff_queue_work(struct hidpp_ff_private_data *data, int effect_id, u8 command, u8 *params, u8 size)\n{\n\tstruct hidpp_ff_work_data *wd = kzalloc(sizeof(*wd), GFP_KERNEL);\n\tint s;\n\n\tif (!wd)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&wd->work, hidpp_ff_work_handler);\n\n\twd->data = data;\n\twd->effect_id = effect_id;\n\twd->command = command;\n\twd->size = size;\n\tmemcpy(wd->params, params, size);\n\n\ts = atomic_inc_return(&data->workqueue_size);\n\tqueue_work(data->wq, &wd->work);\n\n\t \n\tif (s >= 20 && s % 20 == 0)\n\t\thid_warn(data->hidpp->hid_dev, \"Force feedback command queue contains %d commands, causing substantial delays!\", s);\n\n\treturn 0;\n}\n\nstatic int hidpp_ff_upload_effect(struct input_dev *dev, struct ff_effect *effect, struct ff_effect *old)\n{\n\tstruct hidpp_ff_private_data *data = dev->ff->private;\n\tu8 params[20];\n\tu8 size;\n\tint force;\n\n\t \n\tparams[2] = effect->replay.length >> 8;\n\tparams[3] = effect->replay.length & 255;\n\tparams[4] = effect->replay.delay >> 8;\n\tparams[5] = effect->replay.delay & 255;\n\n\tswitch (effect->type) {\n\tcase FF_CONSTANT:\n\t\tforce = (effect->u.constant.level * fixp_sin16((effect->direction * 360) >> 16)) >> 15;\n\t\tparams[1] = HIDPP_FF_EFFECT_CONSTANT;\n\t\tparams[6] = force >> 8;\n\t\tparams[7] = force & 255;\n\t\tparams[8] = effect->u.constant.envelope.attack_level >> 7;\n\t\tparams[9] = effect->u.constant.envelope.attack_length >> 8;\n\t\tparams[10] = effect->u.constant.envelope.attack_length & 255;\n\t\tparams[11] = effect->u.constant.envelope.fade_level >> 7;\n\t\tparams[12] = effect->u.constant.envelope.fade_length >> 8;\n\t\tparams[13] = effect->u.constant.envelope.fade_length & 255;\n\t\tsize = 14;\n\t\tdbg_hid(\"Uploading constant force level=%d in dir %d = %d\\n\",\n\t\t\t\teffect->u.constant.level,\n\t\t\t\teffect->direction, force);\n\t\tdbg_hid(\"          envelope attack=(%d, %d ms) fade=(%d, %d ms)\\n\",\n\t\t\t\teffect->u.constant.envelope.attack_level,\n\t\t\t\teffect->u.constant.envelope.attack_length,\n\t\t\t\teffect->u.constant.envelope.fade_level,\n\t\t\t\teffect->u.constant.envelope.fade_length);\n\t\tbreak;\n\tcase FF_PERIODIC:\n\t{\n\t\tswitch (effect->u.periodic.waveform) {\n\t\tcase FF_SINE:\n\t\t\tparams[1] = HIDPP_FF_EFFECT_PERIODIC_SINE;\n\t\t\tbreak;\n\t\tcase FF_SQUARE:\n\t\t\tparams[1] = HIDPP_FF_EFFECT_PERIODIC_SQUARE;\n\t\t\tbreak;\n\t\tcase FF_SAW_UP:\n\t\t\tparams[1] = HIDPP_FF_EFFECT_PERIODIC_SAWTOOTHUP;\n\t\t\tbreak;\n\t\tcase FF_SAW_DOWN:\n\t\t\tparams[1] = HIDPP_FF_EFFECT_PERIODIC_SAWTOOTHDOWN;\n\t\t\tbreak;\n\t\tcase FF_TRIANGLE:\n\t\t\tparams[1] = HIDPP_FF_EFFECT_PERIODIC_TRIANGLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thid_err(data->hidpp->hid_dev, \"Unexpected periodic waveform type %i!\\n\", effect->u.periodic.waveform);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tforce = (effect->u.periodic.magnitude * fixp_sin16((effect->direction * 360) >> 16)) >> 15;\n\t\tparams[6] = effect->u.periodic.magnitude >> 8;\n\t\tparams[7] = effect->u.periodic.magnitude & 255;\n\t\tparams[8] = effect->u.periodic.offset >> 8;\n\t\tparams[9] = effect->u.periodic.offset & 255;\n\t\tparams[10] = effect->u.periodic.period >> 8;\n\t\tparams[11] = effect->u.periodic.period & 255;\n\t\tparams[12] = effect->u.periodic.phase >> 8;\n\t\tparams[13] = effect->u.periodic.phase & 255;\n\t\tparams[14] = effect->u.periodic.envelope.attack_level >> 7;\n\t\tparams[15] = effect->u.periodic.envelope.attack_length >> 8;\n\t\tparams[16] = effect->u.periodic.envelope.attack_length & 255;\n\t\tparams[17] = effect->u.periodic.envelope.fade_level >> 7;\n\t\tparams[18] = effect->u.periodic.envelope.fade_length >> 8;\n\t\tparams[19] = effect->u.periodic.envelope.fade_length & 255;\n\t\tsize = 20;\n\t\tdbg_hid(\"Uploading periodic force mag=%d/dir=%d, offset=%d, period=%d ms, phase=%d\\n\",\n\t\t\t\teffect->u.periodic.magnitude, effect->direction,\n\t\t\t\teffect->u.periodic.offset,\n\t\t\t\teffect->u.periodic.period,\n\t\t\t\teffect->u.periodic.phase);\n\t\tdbg_hid(\"          envelope attack=(%d, %d ms) fade=(%d, %d ms)\\n\",\n\t\t\t\teffect->u.periodic.envelope.attack_level,\n\t\t\t\teffect->u.periodic.envelope.attack_length,\n\t\t\t\teffect->u.periodic.envelope.fade_level,\n\t\t\t\teffect->u.periodic.envelope.fade_length);\n\t\tbreak;\n\t}\n\tcase FF_RAMP:\n\t\tparams[1] = HIDPP_FF_EFFECT_RAMP;\n\t\tforce = (effect->u.ramp.start_level * fixp_sin16((effect->direction * 360) >> 16)) >> 15;\n\t\tparams[6] = force >> 8;\n\t\tparams[7] = force & 255;\n\t\tforce = (effect->u.ramp.end_level * fixp_sin16((effect->direction * 360) >> 16)) >> 15;\n\t\tparams[8] = force >> 8;\n\t\tparams[9] = force & 255;\n\t\tparams[10] = effect->u.ramp.envelope.attack_level >> 7;\n\t\tparams[11] = effect->u.ramp.envelope.attack_length >> 8;\n\t\tparams[12] = effect->u.ramp.envelope.attack_length & 255;\n\t\tparams[13] = effect->u.ramp.envelope.fade_level >> 7;\n\t\tparams[14] = effect->u.ramp.envelope.fade_length >> 8;\n\t\tparams[15] = effect->u.ramp.envelope.fade_length & 255;\n\t\tsize = 16;\n\t\tdbg_hid(\"Uploading ramp force level=%d -> %d in dir %d = %d\\n\",\n\t\t\t\teffect->u.ramp.start_level,\n\t\t\t\teffect->u.ramp.end_level,\n\t\t\t\teffect->direction, force);\n\t\tdbg_hid(\"          envelope attack=(%d, %d ms) fade=(%d, %d ms)\\n\",\n\t\t\t\teffect->u.ramp.envelope.attack_level,\n\t\t\t\teffect->u.ramp.envelope.attack_length,\n\t\t\t\teffect->u.ramp.envelope.fade_level,\n\t\t\t\teffect->u.ramp.envelope.fade_length);\n\t\tbreak;\n\tcase FF_FRICTION:\n\tcase FF_INERTIA:\n\tcase FF_SPRING:\n\tcase FF_DAMPER:\n\t\tparams[1] = HIDPP_FF_CONDITION_CMDS[effect->type - FF_SPRING];\n\t\tparams[6] = effect->u.condition[0].left_saturation >> 9;\n\t\tparams[7] = (effect->u.condition[0].left_saturation >> 1) & 255;\n\t\tparams[8] = effect->u.condition[0].left_coeff >> 8;\n\t\tparams[9] = effect->u.condition[0].left_coeff & 255;\n\t\tparams[10] = effect->u.condition[0].deadband >> 9;\n\t\tparams[11] = (effect->u.condition[0].deadband >> 1) & 255;\n\t\tparams[12] = effect->u.condition[0].center >> 8;\n\t\tparams[13] = effect->u.condition[0].center & 255;\n\t\tparams[14] = effect->u.condition[0].right_coeff >> 8;\n\t\tparams[15] = effect->u.condition[0].right_coeff & 255;\n\t\tparams[16] = effect->u.condition[0].right_saturation >> 9;\n\t\tparams[17] = (effect->u.condition[0].right_saturation >> 1) & 255;\n\t\tsize = 18;\n\t\tdbg_hid(\"Uploading %s force left coeff=%d, left sat=%d, right coeff=%d, right sat=%d\\n\",\n\t\t\t\tHIDPP_FF_CONDITION_NAMES[effect->type - FF_SPRING],\n\t\t\t\teffect->u.condition[0].left_coeff,\n\t\t\t\teffect->u.condition[0].left_saturation,\n\t\t\t\teffect->u.condition[0].right_coeff,\n\t\t\t\teffect->u.condition[0].right_saturation);\n\t\tdbg_hid(\"          deadband=%d, center=%d\\n\",\n\t\t\t\teffect->u.condition[0].deadband,\n\t\t\t\teffect->u.condition[0].center);\n\t\tbreak;\n\tdefault:\n\t\thid_err(data->hidpp->hid_dev, \"Unexpected force type %i!\\n\", effect->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn hidpp_ff_queue_work(data, effect->id, HIDPP_FF_DOWNLOAD_EFFECT, params, size);\n}\n\nstatic int hidpp_ff_playback(struct input_dev *dev, int effect_id, int value)\n{\n\tstruct hidpp_ff_private_data *data = dev->ff->private;\n\tu8 params[2];\n\n\tparams[1] = value ? HIDPP_FF_EFFECT_STATE_PLAY : HIDPP_FF_EFFECT_STATE_STOP;\n\n\tdbg_hid(\"St%sing playback of effect %d.\\n\", value?\"art\":\"opp\", effect_id);\n\n\treturn hidpp_ff_queue_work(data, effect_id, HIDPP_FF_SET_EFFECT_STATE, params, ARRAY_SIZE(params));\n}\n\nstatic int hidpp_ff_erase_effect(struct input_dev *dev, int effect_id)\n{\n\tstruct hidpp_ff_private_data *data = dev->ff->private;\n\tu8 slot = 0;\n\n\tdbg_hid(\"Erasing effect %d.\\n\", effect_id);\n\n\treturn hidpp_ff_queue_work(data, effect_id, HIDPP_FF_DESTROY_EFFECT, &slot, 1);\n}\n\nstatic void hidpp_ff_set_autocenter(struct input_dev *dev, u16 magnitude)\n{\n\tstruct hidpp_ff_private_data *data = dev->ff->private;\n\tu8 params[HIDPP_AUTOCENTER_PARAMS_LENGTH];\n\n\tdbg_hid(\"Setting autocenter to %d.\\n\", magnitude);\n\n\t \n\tparams[1] = HIDPP_FF_EFFECT_SPRING | HIDPP_FF_EFFECT_AUTOSTART;\n\t \n\tparams[2] = params[3] = params[4] = params[5] = 0;\n\t \n\tparams[8] = params[14] = magnitude >> 11;\n\tparams[9] = params[15] = (magnitude >> 3) & 255;\n\tparams[6] = params[16] = magnitude >> 9;\n\tparams[7] = params[17] = (magnitude >> 1) & 255;\n\t \n\tparams[10] = params[11] = params[12] = params[13] = 0;\n\n\thidpp_ff_queue_work(data, HIDPP_FF_EFFECTID_AUTOCENTER, HIDPP_FF_DOWNLOAD_EFFECT, params, ARRAY_SIZE(params));\n}\n\nstatic void hidpp_ff_set_gain(struct input_dev *dev, u16 gain)\n{\n\tstruct hidpp_ff_private_data *data = dev->ff->private;\n\tu8 params[4];\n\n\tdbg_hid(\"Setting gain to %d.\\n\", gain);\n\n\tparams[0] = gain >> 8;\n\tparams[1] = gain & 255;\n\tparams[2] = 0;  \n\tparams[3] = 0;\n\n\thidpp_ff_queue_work(data, HIDPP_FF_EFFECTID_NONE, HIDPP_FF_SET_GLOBAL_GAINS, params, ARRAY_SIZE(params));\n}\n\nstatic ssize_t hidpp_ff_range_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *idev = hidinput->input;\n\tstruct hidpp_ff_private_data *data = idev->ff->private;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", data->range);\n}\n\nstatic ssize_t hidpp_ff_range_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *idev = hidinput->input;\n\tstruct hidpp_ff_private_data *data = idev->ff->private;\n\tu8 params[2];\n\tint range = simple_strtoul(buf, NULL, 10);\n\n\trange = clamp(range, 180, 900);\n\n\tparams[0] = range >> 8;\n\tparams[1] = range & 0x00FF;\n\n\thidpp_ff_queue_work(data, -1, HIDPP_FF_SET_APERTURE, params, ARRAY_SIZE(params));\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(range, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, hidpp_ff_range_show, hidpp_ff_range_store);\n\nstatic void hidpp_ff_destroy(struct ff_device *ff)\n{\n\tstruct hidpp_ff_private_data *data = ff->private;\n\tstruct hid_device *hid = data->hidpp->hid_dev;\n\n\thid_info(hid, \"Unloading HID++ force feedback.\\n\");\n\n\tdevice_remove_file(&hid->dev, &dev_attr_range);\n\tdestroy_workqueue(data->wq);\n\tkfree(data->effect_ids);\n}\n\nstatic int hidpp_ff_init(struct hidpp_device *hidpp,\n\t\t\t struct hidpp_ff_private_data *data)\n{\n\tstruct hid_device *hid = hidpp->hid_dev;\n\tstruct hid_input *hidinput;\n\tstruct input_dev *dev;\n\tstruct usb_device_descriptor *udesc;\n\tu16 bcdDevice;\n\tstruct ff_device *ff;\n\tint error, j, num_slots = data->num_effects;\n\tu8 version;\n\n\tif (!hid_is_usb(hid)) {\n\t\thid_err(hid, \"device is not USB\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (list_empty(&hid->inputs)) {\n\t\thid_err(hid, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tdev = hidinput->input;\n\n\tif (!dev) {\n\t\thid_err(hid, \"Struct input_dev not set!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tudesc = &(hid_to_usb_dev(hid)->descriptor);\n\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\tversion = bcdDevice & 255;\n\n\t \n\tfor (j = 0; hidpp_ff_effects[j] >= 0; j++)\n\t\tset_bit(hidpp_ff_effects[j], dev->ffbit);\n\tif (version > 1)\n\t\tfor (j = 0; hidpp_ff_effects_v2[j] >= 0; j++)\n\t\t\tset_bit(hidpp_ff_effects_v2[j], dev->ffbit);\n\n\terror = input_ff_create(dev, num_slots);\n\n\tif (error) {\n\t\thid_err(dev, \"Failed to create FF device!\\n\");\n\t\treturn error;\n\t}\n\t \n\tdata = kmemdup(data, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->effect_ids = kcalloc(num_slots, sizeof(int), GFP_KERNEL);\n\tif (!data->effect_ids) {\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->wq = create_singlethread_workqueue(\"hidpp-ff-sendqueue\");\n\tif (!data->wq) {\n\t\tkfree(data->effect_ids);\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->hidpp = hidpp;\n\tdata->version = version;\n\tfor (j = 0; j < num_slots; j++)\n\t\tdata->effect_ids[j] = -1;\n\n\tff = dev->ff;\n\tff->private = data;\n\n\tff->upload = hidpp_ff_upload_effect;\n\tff->erase = hidpp_ff_erase_effect;\n\tff->playback = hidpp_ff_playback;\n\tff->set_gain = hidpp_ff_set_gain;\n\tff->set_autocenter = hidpp_ff_set_autocenter;\n\tff->destroy = hidpp_ff_destroy;\n\n\t \n\terror = device_create_file(&(hidpp->hid_dev->dev), &dev_attr_range);\n\tif (error)\n\t\thid_warn(hidpp->hid_dev, \"Unable to create sysfs interface for \\\"range\\\", errno %d!\\n\", error);\n\n\t \n\tatomic_set(&data->workqueue_size, 0);\n\n\thid_info(hid, \"Force feedback support loaded (firmware release %d).\\n\",\n\t\t version);\n\n\treturn 0;\n}\n\n \n \n \n \n \n\n \n \n \n\n#define WTP_MANUAL_RESOLUTION\t\t\t\t39\n\nstruct wtp_data {\n\tu16 x_size, y_size;\n\tu8 finger_count;\n\tu8 mt_feature_index;\n\tu8 button_feature_index;\n\tu8 maxcontacts;\n\tbool flip_y;\n\tunsigned int resolution;\n};\n\nstatic int wtp_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\treturn -1;\n}\n\nstatic void wtp_populate_input(struct hidpp_device *hidpp,\n\t\t\t       struct input_dev *input_dev)\n{\n\tstruct wtp_data *wd = hidpp->private_data;\n\n\t__set_bit(EV_ABS, input_dev->evbit);\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__clear_bit(EV_REL, input_dev->evbit);\n\t__clear_bit(EV_LED, input_dev->evbit);\n\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, wd->x_size, 0, 0);\n\tinput_abs_set_res(input_dev, ABS_MT_POSITION_X, wd->resolution);\n\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, wd->y_size, 0, 0);\n\tinput_abs_set_res(input_dev, ABS_MT_POSITION_Y, wd->resolution);\n\n\t \n\tinput_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, 50, 0, 0);\n\n\tinput_set_capability(input_dev, EV_KEY, BTN_LEFT);\n\n\tif (hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS)\n\t\tinput_set_capability(input_dev, EV_KEY, BTN_RIGHT);\n\telse\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);\n\n\tinput_mt_init_slots(input_dev, wd->maxcontacts, INPUT_MT_POINTER |\n\t\tINPUT_MT_DROP_UNUSED);\n}\n\nstatic void wtp_touch_event(struct hidpp_device *hidpp,\n\tstruct hidpp_touchpad_raw_xy_finger *touch_report)\n{\n\tstruct wtp_data *wd = hidpp->private_data;\n\tint slot;\n\n\tif (!touch_report->finger_id || touch_report->contact_type)\n\t\t \n\t\treturn;\n\n\tslot = input_mt_get_slot_by_key(hidpp->input, touch_report->finger_id);\n\n\tinput_mt_slot(hidpp->input, slot);\n\tinput_mt_report_slot_state(hidpp->input, MT_TOOL_FINGER,\n\t\t\t\t\ttouch_report->contact_status);\n\tif (touch_report->contact_status) {\n\t\tinput_event(hidpp->input, EV_ABS, ABS_MT_POSITION_X,\n\t\t\t\ttouch_report->x);\n\t\tinput_event(hidpp->input, EV_ABS, ABS_MT_POSITION_Y,\n\t\t\t\twd->flip_y ? wd->y_size - touch_report->y :\n\t\t\t\t\t     touch_report->y);\n\t\tinput_event(hidpp->input, EV_ABS, ABS_MT_PRESSURE,\n\t\t\t\ttouch_report->area);\n\t}\n}\n\nstatic void wtp_send_raw_xy_event(struct hidpp_device *hidpp,\n\t\tstruct hidpp_touchpad_raw_xy *raw)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\twtp_touch_event(hidpp, &(raw->fingers[i]));\n\n\tif (raw->end_of_frame &&\n\t    !(hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS))\n\t\tinput_event(hidpp->input, EV_KEY, BTN_LEFT, raw->button);\n\n\tif (raw->end_of_frame || raw->finger_count <= 2) {\n\t\tinput_mt_sync_frame(hidpp->input);\n\t\tinput_sync(hidpp->input);\n\t}\n}\n\nstatic int wtp_mouse_raw_xy_event(struct hidpp_device *hidpp, u8 *data)\n{\n\tstruct wtp_data *wd = hidpp->private_data;\n\tu8 c1_area = ((data[7] & 0xf) * (data[7] & 0xf) +\n\t\t      (data[7] >> 4) * (data[7] >> 4)) / 2;\n\tu8 c2_area = ((data[13] & 0xf) * (data[13] & 0xf) +\n\t\t      (data[13] >> 4) * (data[13] >> 4)) / 2;\n\tstruct hidpp_touchpad_raw_xy raw = {\n\t\t.timestamp = data[1],\n\t\t.fingers = {\n\t\t\t{\n\t\t\t\t.contact_type = 0,\n\t\t\t\t.contact_status = !!data[7],\n\t\t\t\t.x = get_unaligned_le16(&data[3]),\n\t\t\t\t.y = get_unaligned_le16(&data[5]),\n\t\t\t\t.z = c1_area,\n\t\t\t\t.area = c1_area,\n\t\t\t\t.finger_id = data[2],\n\t\t\t}, {\n\t\t\t\t.contact_type = 0,\n\t\t\t\t.contact_status = !!data[13],\n\t\t\t\t.x = get_unaligned_le16(&data[9]),\n\t\t\t\t.y = get_unaligned_le16(&data[11]),\n\t\t\t\t.z = c2_area,\n\t\t\t\t.area = c2_area,\n\t\t\t\t.finger_id = data[8],\n\t\t\t}\n\t\t},\n\t\t.finger_count = wd->maxcontacts,\n\t\t.spurious_flag = 0,\n\t\t.end_of_frame = (data[0] >> 7) == 0,\n\t\t.button = data[0] & 0x01,\n\t};\n\n\twtp_send_raw_xy_event(hidpp, &raw);\n\n\treturn 1;\n}\n\nstatic int wtp_raw_event(struct hid_device *hdev, u8 *data, int size)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tstruct wtp_data *wd = hidpp->private_data;\n\tstruct hidpp_report *report = (struct hidpp_report *)data;\n\tstruct hidpp_touchpad_raw_xy raw;\n\n\tif (!wd || !hidpp->input)\n\t\treturn 1;\n\n\tswitch (data[0]) {\n\tcase 0x02:\n\t\tif (size < 2) {\n\t\t\thid_err(hdev, \"Received HID report of bad size (%d)\",\n\t\t\t\tsize);\n\t\t\treturn 1;\n\t\t}\n\t\tif (hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS) {\n\t\t\tinput_event(hidpp->input, EV_KEY, BTN_LEFT,\n\t\t\t\t\t!!(data[1] & 0x01));\n\t\t\tinput_event(hidpp->input, EV_KEY, BTN_RIGHT,\n\t\t\t\t\t!!(data[1] & 0x02));\n\t\t\tinput_sync(hidpp->input);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (size < 21)\n\t\t\t\treturn 1;\n\t\t\treturn wtp_mouse_raw_xy_event(hidpp, &data[7]);\n\t\t}\n\tcase REPORT_ID_HIDPP_LONG:\n\t\t \n\t\tif ((report->fap.feature_index != wd->mt_feature_index) ||\n\t\t    (report->fap.funcindex_clientid != EVENT_TOUCHPAD_RAW_XY))\n\t\t\treturn 1;\n\t\thidpp_touchpad_raw_xy_event(hidpp, data + 4, &raw);\n\n\t\twtp_send_raw_xy_event(hidpp, &raw);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int wtp_get_config(struct hidpp_device *hidpp)\n{\n\tstruct wtp_data *wd = hidpp->private_data;\n\tstruct hidpp_touchpad_raw_info raw_info = {0};\n\tu8 feature_type;\n\tint ret;\n\n\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_TOUCHPAD_RAW_XY,\n\t\t&wd->mt_feature_index, &feature_type);\n\tif (ret)\n\t\t \n\t\treturn ret;\n\n\tret = hidpp_touchpad_get_raw_info(hidpp, wd->mt_feature_index,\n\t\t&raw_info);\n\tif (ret)\n\t\treturn ret;\n\n\twd->x_size = raw_info.x_size;\n\twd->y_size = raw_info.y_size;\n\twd->maxcontacts = raw_info.maxcontacts;\n\twd->flip_y = raw_info.origin == TOUCHPAD_RAW_XY_ORIGIN_LOWER_LEFT;\n\twd->resolution = raw_info.res;\n\tif (!wd->resolution)\n\t\twd->resolution = WTP_MANUAL_RESOLUTION;\n\n\treturn 0;\n}\n\nstatic int wtp_allocate(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tstruct wtp_data *wd;\n\n\twd = devm_kzalloc(&hdev->dev, sizeof(struct wtp_data),\n\t\t\tGFP_KERNEL);\n\tif (!wd)\n\t\treturn -ENOMEM;\n\n\thidpp->private_data = wd;\n\n\treturn 0;\n};\n\nstatic int wtp_connect(struct hid_device *hdev, bool connected)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tstruct wtp_data *wd = hidpp->private_data;\n\tint ret;\n\n\tif (!wd->x_size) {\n\t\tret = wtp_get_config(hidpp);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Can not get wtp config: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn hidpp_touchpad_set_raw_report_state(hidpp, wd->mt_feature_index,\n\t\t\ttrue, true);\n}\n\n \n \n \n\n \n\nstatic const u8 m560_config_parameter[] = {0x00, 0xaf, 0x03};\n\n \n#define M560_MOUSE_BTN_LEFT\t\t0x01\n#define M560_MOUSE_BTN_RIGHT\t\t0x02\n#define M560_MOUSE_BTN_WHEEL_LEFT\t0x08\n#define M560_MOUSE_BTN_WHEEL_RIGHT\t0x10\n\n#define M560_SUB_ID\t\t\t0x0a\n#define M560_BUTTON_MODE_REGISTER\t0x35\n\nstatic int m560_send_config_command(struct hid_device *hdev, bool connected)\n{\n\tstruct hidpp_report response;\n\tstruct hidpp_device *hidpp_dev;\n\n\thidpp_dev = hid_get_drvdata(hdev);\n\n\treturn hidpp_send_rap_command_sync(\n\t\thidpp_dev,\n\t\tREPORT_ID_HIDPP_SHORT,\n\t\tM560_SUB_ID,\n\t\tM560_BUTTON_MODE_REGISTER,\n\t\t(u8 *)m560_config_parameter,\n\t\tsizeof(m560_config_parameter),\n\t\t&response\n\t);\n}\n\nstatic int m560_raw_event(struct hid_device *hdev, u8 *data, int size)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\n\t \n\tif (!hidpp->input) {\n\t\thid_err(hdev, \"error in parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size < 7) {\n\t\thid_err(hdev, \"error in report\\n\");\n\t\treturn 0;\n\t}\n\n\tif (data[0] == REPORT_ID_HIDPP_LONG &&\n\t    data[2] == M560_SUB_ID && data[6] == 0x00) {\n\t\t \n\n\t\tswitch (data[5]) {\n\t\tcase 0xaf:\n\t\t\tinput_report_key(hidpp->input, BTN_MIDDLE, 1);\n\t\t\tbreak;\n\t\tcase 0xb0:\n\t\t\tinput_report_key(hidpp->input, BTN_FORWARD, 1);\n\t\t\tbreak;\n\t\tcase 0xae:\n\t\t\tinput_report_key(hidpp->input, BTN_BACK, 1);\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\t\tinput_report_key(hidpp->input, BTN_BACK, 0);\n\t\t\tinput_report_key(hidpp->input, BTN_FORWARD, 0);\n\t\t\tinput_report_key(hidpp->input, BTN_MIDDLE, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thid_err(hdev, \"error in report\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tinput_sync(hidpp->input);\n\n\t} else if (data[0] == 0x02) {\n\t\t \n\n\t\tint v;\n\n\t\tinput_report_key(hidpp->input, BTN_LEFT,\n\t\t\t!!(data[1] & M560_MOUSE_BTN_LEFT));\n\t\tinput_report_key(hidpp->input, BTN_RIGHT,\n\t\t\t!!(data[1] & M560_MOUSE_BTN_RIGHT));\n\n\t\tif (data[1] & M560_MOUSE_BTN_WHEEL_LEFT) {\n\t\t\tinput_report_rel(hidpp->input, REL_HWHEEL, -1);\n\t\t\tinput_report_rel(hidpp->input, REL_HWHEEL_HI_RES,\n\t\t\t\t\t -120);\n\t\t} else if (data[1] & M560_MOUSE_BTN_WHEEL_RIGHT) {\n\t\t\tinput_report_rel(hidpp->input, REL_HWHEEL, 1);\n\t\t\tinput_report_rel(hidpp->input, REL_HWHEEL_HI_RES,\n\t\t\t\t\t 120);\n\t\t}\n\n\t\tv = hid_snto32(hid_field_extract(hdev, data+3, 0, 12), 12);\n\t\tinput_report_rel(hidpp->input, REL_X, v);\n\n\t\tv = hid_snto32(hid_field_extract(hdev, data+3, 12, 12), 12);\n\t\tinput_report_rel(hidpp->input, REL_Y, v);\n\n\t\tv = hid_snto32(data[6], 8);\n\t\tif (v != 0)\n\t\t\thidpp_scroll_counter_handle_scroll(hidpp->input,\n\t\t\t\t\t&hidpp->vertical_wheel_counter, v);\n\n\t\tinput_sync(hidpp->input);\n\t}\n\n\treturn 1;\n}\n\nstatic void m560_populate_input(struct hidpp_device *hidpp,\n\t\t\t\tstruct input_dev *input_dev)\n{\n\t__set_bit(EV_KEY, input_dev->evbit);\n\t__set_bit(BTN_MIDDLE, input_dev->keybit);\n\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\t__set_bit(BTN_LEFT, input_dev->keybit);\n\t__set_bit(BTN_BACK, input_dev->keybit);\n\t__set_bit(BTN_FORWARD, input_dev->keybit);\n\n\t__set_bit(EV_REL, input_dev->evbit);\n\t__set_bit(REL_X, input_dev->relbit);\n\t__set_bit(REL_Y, input_dev->relbit);\n\t__set_bit(REL_WHEEL, input_dev->relbit);\n\t__set_bit(REL_HWHEEL, input_dev->relbit);\n\t__set_bit(REL_WHEEL_HI_RES, input_dev->relbit);\n\t__set_bit(REL_HWHEEL_HI_RES, input_dev->relbit);\n}\n\nstatic int m560_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\treturn -1;\n}\n\n \n \n \n\n \n\nstruct k400_private_data {\n\tu8 feature_index;\n};\n\nstatic int k400_disable_tap_to_click(struct hidpp_device *hidpp)\n{\n\tstruct k400_private_data *k400 = hidpp->private_data;\n\tstruct hidpp_touchpad_fw_items items = {};\n\tint ret;\n\tu8 feature_type;\n\n\tif (!k400->feature_index) {\n\t\tret = hidpp_root_get_feature(hidpp,\n\t\t\tHIDPP_PAGE_TOUCHPAD_FW_ITEMS,\n\t\t\t&k400->feature_index, &feature_type);\n\t\tif (ret)\n\t\t\t \n\t\t\treturn ret;\n\t}\n\n\tret = hidpp_touchpad_fw_items_set(hidpp, k400->feature_index, &items);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int k400_allocate(struct hid_device *hdev)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tstruct k400_private_data *k400;\n\n\tk400 = devm_kzalloc(&hdev->dev, sizeof(struct k400_private_data),\n\t\t\t    GFP_KERNEL);\n\tif (!k400)\n\t\treturn -ENOMEM;\n\n\thidpp->private_data = k400;\n\n\treturn 0;\n};\n\nstatic int k400_connect(struct hid_device *hdev, bool connected)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\n\tif (!disable_tap_to_click)\n\t\treturn 0;\n\n\treturn k400_disable_tap_to_click(hidpp);\n}\n\n \n \n \n\n#define HIDPP_PAGE_G920_FORCE_FEEDBACK\t\t\t0x8123\n\nstatic int g920_ff_set_autocenter(struct hidpp_device *hidpp,\n\t\t\t\t  struct hidpp_ff_private_data *data)\n{\n\tstruct hidpp_report response;\n\tu8 params[HIDPP_AUTOCENTER_PARAMS_LENGTH] = {\n\t\t[1] = HIDPP_FF_EFFECT_SPRING | HIDPP_FF_EFFECT_AUTOSTART,\n\t};\n\tint ret;\n\n\t \n\n\tdbg_hid(\"Setting autocenter to 0.\\n\");\n\tret = hidpp_send_fap_command_sync(hidpp, data->feature_index,\n\t\t\t\t\t  HIDPP_FF_DOWNLOAD_EFFECT,\n\t\t\t\t\t  params, ARRAY_SIZE(params),\n\t\t\t\t\t  &response);\n\tif (ret)\n\t\thid_warn(hidpp->hid_dev, \"Failed to autocenter device!\\n\");\n\telse\n\t\tdata->slot_autocenter = response.fap.params[0];\n\n\treturn ret;\n}\n\nstatic int g920_get_config(struct hidpp_device *hidpp,\n\t\t\t   struct hidpp_ff_private_data *data)\n{\n\tstruct hidpp_report response;\n\tu8 feature_type;\n\tint ret;\n\n\tmemset(data, 0, sizeof(*data));\n\n\t \n\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_G920_FORCE_FEEDBACK,\n\t\t\t\t     &data->feature_index, &feature_type);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = hidpp_send_fap_command_sync(hidpp, data->feature_index,\n\t\t\t\t\t  HIDPP_FF_GET_INFO,\n\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t  &response);\n\tif (ret) {\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\thid_err(hidpp->hid_dev,\n\t\t\t\"%s: received protocol error 0x%02x\\n\", __func__, ret);\n\t\treturn -EPROTO;\n\t}\n\n\tdata->num_effects = response.fap.params[0] - HIDPP_FF_RESERVED_SLOTS;\n\n\t \n\tret = hidpp_send_fap_command_sync(hidpp, data->feature_index,\n\t\t\t\t\t  HIDPP_FF_RESET_ALL,\n\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t  &response);\n\tif (ret)\n\t\thid_warn(hidpp->hid_dev, \"Failed to reset all forces!\\n\");\n\n\tret = hidpp_send_fap_command_sync(hidpp, data->feature_index,\n\t\t\t\t\t  HIDPP_FF_GET_APERTURE,\n\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t  &response);\n\tif (ret) {\n\t\thid_warn(hidpp->hid_dev,\n\t\t\t \"Failed to read range from device!\\n\");\n\t}\n\tdata->range = ret ?\n\t\t900 : get_unaligned_be16(&response.fap.params[0]);\n\n\t \n\tret = hidpp_send_fap_command_sync(hidpp, data->feature_index,\n\t\t\t\t\t  HIDPP_FF_GET_GLOBAL_GAINS,\n\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t  &response);\n\tif (ret)\n\t\thid_warn(hidpp->hid_dev,\n\t\t\t \"Failed to read gain values from device!\\n\");\n\tdata->gain = ret ?\n\t\t0xffff : get_unaligned_be16(&response.fap.params[0]);\n\n\t \n\n\treturn g920_ff_set_autocenter(hidpp, data);\n}\n\n \n \n \n#define DINOVO_MINI_PRODUCT_ID\t\t0xb30c\n\nstatic int lg_dinovo_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x00d: lg_map_key_clear(KEY_MEDIA);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \n \n \nstatic int hidpp10_wheel_connect(struct hidpp_device *hidpp)\n{\n\treturn hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,\n\t\t\tHIDPP_ENABLE_WHEEL_REPORT | HIDPP_ENABLE_HWHEEL_REPORT,\n\t\t\tHIDPP_ENABLE_WHEEL_REPORT | HIDPP_ENABLE_HWHEEL_REPORT);\n}\n\nstatic int hidpp10_wheel_raw_event(struct hidpp_device *hidpp,\n\t\t\t\t   u8 *data, int size)\n{\n\ts8 value, hvalue;\n\n\tif (!hidpp->input)\n\t\treturn -EINVAL;\n\n\tif (size < 7)\n\t\treturn 0;\n\n\tif (data[0] != REPORT_ID_HIDPP_SHORT || data[2] != HIDPP_SUB_ID_ROLLER)\n\t\treturn 0;\n\n\tvalue = data[3];\n\thvalue = data[4];\n\n\tinput_report_rel(hidpp->input, REL_WHEEL, value);\n\tinput_report_rel(hidpp->input, REL_WHEEL_HI_RES, value * 120);\n\tinput_report_rel(hidpp->input, REL_HWHEEL, hvalue);\n\tinput_report_rel(hidpp->input, REL_HWHEEL_HI_RES, hvalue * 120);\n\tinput_sync(hidpp->input);\n\n\treturn 1;\n}\n\nstatic void hidpp10_wheel_populate_input(struct hidpp_device *hidpp,\n\t\t\t\t\t struct input_dev *input_dev)\n{\n\t__set_bit(EV_REL, input_dev->evbit);\n\t__set_bit(REL_WHEEL, input_dev->relbit);\n\t__set_bit(REL_WHEEL_HI_RES, input_dev->relbit);\n\t__set_bit(REL_HWHEEL, input_dev->relbit);\n\t__set_bit(REL_HWHEEL_HI_RES, input_dev->relbit);\n}\n\n \n \n \nstatic int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)\n{\n\treturn hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,\n\t\t\t\t    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,\n\t\t\t\t    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);\n}\n\nstatic int hidpp10_extra_mouse_buttons_raw_event(struct hidpp_device *hidpp,\n\t\t\t\t    u8 *data, int size)\n{\n\tint i;\n\n\tif (!hidpp->input)\n\t\treturn -EINVAL;\n\n\tif (size < 7)\n\t\treturn 0;\n\n\tif (data[0] != REPORT_ID_HIDPP_SHORT ||\n\t    data[2] != HIDPP_SUB_ID_MOUSE_EXTRA_BTNS)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < 8; i++)\n\t\tinput_report_key(hidpp->input, BTN_MOUSE + i,\n\t\t\t\t (data[3] & (1 << i)));\n\n\t \n\tfor (i = 0; i < 8; i++)\n\t\tinput_report_key(hidpp->input, BTN_MISC + i,\n\t\t\t\t (data[4] & (1 << i)));\n\n\tinput_sync(hidpp->input);\n\treturn 1;\n}\n\nstatic void hidpp10_extra_mouse_buttons_populate_input(\n\t\t\tstruct hidpp_device *hidpp, struct input_dev *input_dev)\n{\n\t \n\t__set_bit(BTN_0, input_dev->keybit);\n\t__set_bit(BTN_1, input_dev->keybit);\n\t__set_bit(BTN_2, input_dev->keybit);\n\t__set_bit(BTN_3, input_dev->keybit);\n\t__set_bit(BTN_4, input_dev->keybit);\n\t__set_bit(BTN_5, input_dev->keybit);\n\t__set_bit(BTN_6, input_dev->keybit);\n\t__set_bit(BTN_7, input_dev->keybit);\n}\n\n \n \n \n\n \nstatic u8 *hidpp10_consumer_keys_report_fixup(struct hidpp_device *hidpp,\n\t\t\t\t\t      u8 *_rdesc, unsigned int *rsize)\n{\n\t \n\tstatic const char consumer_rdesc_start[] = {\n\t\t0x05, 0x0C,\t \n\t\t0x09, 0x01,\t \n\t\t0xA1, 0x01,\t \n\t\t0x85, 0x03,\t \n\t\t0x75, 0x10,\t \n\t\t0x95, 0x02,\t \n\t\t0x15, 0x01,\t \n\t\t0x26, 0x00\t \n\t};\n\tchar *consumer_rdesc, *rdesc = (char *)_rdesc;\n\tunsigned int size;\n\n\tconsumer_rdesc = strnstr(rdesc, consumer_rdesc_start, *rsize);\n\tsize = *rsize - (consumer_rdesc - rdesc);\n\tif (consumer_rdesc && size >= 25) {\n\t\tconsumer_rdesc[15] = 0x7f;\n\t\tconsumer_rdesc[16] = 0x10;\n\t\tconsumer_rdesc[20] = 0x7f;\n\t\tconsumer_rdesc[21] = 0x10;\n\t}\n\treturn _rdesc;\n}\n\nstatic int hidpp10_consumer_keys_connect(struct hidpp_device *hidpp)\n{\n\treturn hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,\n\t\t\t\t    HIDPP_ENABLE_CONSUMER_REPORT,\n\t\t\t\t    HIDPP_ENABLE_CONSUMER_REPORT);\n}\n\nstatic int hidpp10_consumer_keys_raw_event(struct hidpp_device *hidpp,\n\t\t\t\t\t   u8 *data, int size)\n{\n\tu8 consumer_report[5];\n\n\tif (size < 7)\n\t\treturn 0;\n\n\tif (data[0] != REPORT_ID_HIDPP_SHORT ||\n\t    data[2] != HIDPP_SUB_ID_CONSUMER_VENDOR_KEYS)\n\t\treturn 0;\n\n\t \n\tconsumer_report[0] = 0x03;\n\tmemcpy(&consumer_report[1], &data[3], 4);\n\t \n\thid_report_raw_event(hidpp->hid_dev, HID_INPUT_REPORT,\n\t\t\t     consumer_report, 5, 1);\n\n\treturn 1;\n}\n\n \n \n \n\nstatic int hi_res_scroll_enable(struct hidpp_device *hidpp)\n{\n\tint ret;\n\tu8 multiplier = 1;\n\n\tif (hidpp->capabilities & HIDPP_CAPABILITY_HIDPP20_HI_RES_WHEEL) {\n\t\tret = hidpp_hrw_set_wheel_mode(hidpp, false, true, false);\n\t\tif (ret == 0)\n\t\t\tret = hidpp_hrw_get_wheel_capability(hidpp, &multiplier);\n\t} else if (hidpp->capabilities & HIDPP_CAPABILITY_HIDPP20_HI_RES_SCROLL) {\n\t\tret = hidpp_hrs_set_highres_scrolling_mode(hidpp, true,\n\t\t\t\t\t\t\t   &multiplier);\n\t} else   {\n\t\tret = hidpp10_enable_scrolling_acceleration(hidpp);\n\t\tmultiplier = 8;\n\t}\n\tif (ret) {\n\t\thid_dbg(hidpp->hid_dev,\n\t\t\t\"Could not enable hi-res scrolling: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (multiplier == 0) {\n\t\thid_dbg(hidpp->hid_dev,\n\t\t\t\"Invalid multiplier 0 from device, setting it to 1\\n\");\n\t\tmultiplier = 1;\n\t}\n\n\thidpp->vertical_wheel_counter.wheel_multiplier = multiplier;\n\thid_dbg(hidpp->hid_dev, \"wheel multiplier = %d\\n\", multiplier);\n\treturn 0;\n}\n\nstatic int hidpp_initialize_hires_scroll(struct hidpp_device *hidpp)\n{\n\tint ret;\n\tunsigned long capabilities;\n\n\tcapabilities = hidpp->capabilities;\n\n\tif (hidpp->protocol_major >= 2) {\n\t\tu8 feature_index;\n\t\tu8 feature_type;\n\n\t\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_HIRES_WHEEL,\n\t\t\t\t\t     &feature_index, &feature_type);\n\t\tif (!ret) {\n\t\t\thidpp->capabilities |= HIDPP_CAPABILITY_HIDPP20_HI_RES_WHEEL;\n\t\t\thid_dbg(hidpp->hid_dev, \"Detected HID++ 2.0 hi-res scroll wheel\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_HI_RESOLUTION_SCROLLING,\n\t\t\t\t\t     &feature_index, &feature_type);\n\t\tif (!ret) {\n\t\t\thidpp->capabilities |= HIDPP_CAPABILITY_HIDPP20_HI_RES_SCROLL;\n\t\t\thid_dbg(hidpp->hid_dev, \"Detected HID++ 2.0 hi-res scrolling\\n\");\n\t\t}\n\t} else {\n\t\t \n\t\tif (hidpp->quirks & HIDPP_QUIRK_HI_RES_SCROLL_1P0) {\n\t\t\thidpp->capabilities |= HIDPP_CAPABILITY_HIDPP10_FAST_SCROLL;\n\t\t\thid_dbg(hidpp->hid_dev, \"Detected HID++ 1.0 fast scroll\\n\");\n\t\t}\n\t}\n\n\tif (hidpp->capabilities == capabilities)\n\t\thid_dbg(hidpp->hid_dev, \"Did not detect HID++ hi-res scrolling hardware support\\n\");\n\treturn 0;\n}\n\n \n \n \n\nstatic u8 *hidpp_report_fixup(struct hid_device *hdev, u8 *rdesc,\n\t\t\t      unsigned int *rsize)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\n\tif (!hidpp)\n\t\treturn rdesc;\n\n\t \n\tif (hdev->group == HID_GROUP_LOGITECH_27MHZ_DEVICE ||\n\t    (hidpp->quirks & HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS))\n\t\trdesc = hidpp10_consumer_keys_report_fixup(hidpp, rdesc, rsize);\n\n\treturn rdesc;\n}\n\nstatic int hidpp_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\n\tif (!hidpp)\n\t\treturn 0;\n\n\tif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\n\t\treturn wtp_input_mapping(hdev, hi, field, usage, bit, max);\n\telse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560 &&\n\t\t\tfield->application != HID_GD_MOUSE)\n\t\treturn m560_input_mapping(hdev, hi, field, usage, bit, max);\n\n\tif (hdev->product == DINOVO_MINI_PRODUCT_ID)\n\t\treturn lg_dinovo_input_mapping(hdev, hi, field, usage, bit, max);\n\n\treturn 0;\n}\n\nstatic int hidpp_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\n\tif (!hidpp)\n\t\treturn 0;\n\n\t \n\tif (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {\n\t\tif (usage->type == EV_ABS && (usage->code == ABS_X ||\n\t\t\t\tusage->code == ABS_Y || usage->code == ABS_Z ||\n\t\t\t\tusage->code == ABS_RZ)) {\n\t\t\tfield->application = HID_GD_MULTIAXIS;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic void hidpp_populate_input(struct hidpp_device *hidpp,\n\t\t\t\t struct input_dev *input)\n{\n\thidpp->input = input;\n\n\tif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\n\t\twtp_populate_input(hidpp, input);\n\telse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560)\n\t\tm560_populate_input(hidpp, input);\n\n\tif (hidpp->quirks & HIDPP_QUIRK_HIDPP_WHEELS)\n\t\thidpp10_wheel_populate_input(hidpp, input);\n\n\tif (hidpp->quirks & HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS)\n\t\thidpp10_extra_mouse_buttons_populate_input(hidpp, input);\n}\n\nstatic int hidpp_input_configured(struct hid_device *hdev,\n\t\t\t\tstruct hid_input *hidinput)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tstruct input_dev *input = hidinput->input;\n\n\tif (!hidpp)\n\t\treturn 0;\n\n\thidpp_populate_input(hidpp, input);\n\n\treturn 0;\n}\n\nstatic int hidpp_raw_hidpp_event(struct hidpp_device *hidpp, u8 *data,\n\t\tint size)\n{\n\tstruct hidpp_report *question = hidpp->send_receive_buf;\n\tstruct hidpp_report *answer = hidpp->send_receive_buf;\n\tstruct hidpp_report *report = (struct hidpp_report *)data;\n\tint ret;\n\n\t \n\tif (unlikely(mutex_is_locked(&hidpp->send_mutex))) {\n\t\t \n\t\tif (hidpp_match_answer(question, report) ||\n\t\t\t\thidpp_match_error(question, report)) {\n\t\t\t*answer = *report;\n\t\t\thidpp->answer_available = true;\n\t\t\twake_up(&hidpp->wait);\n\t\t\t \n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (unlikely(hidpp_report_is_connect_event(hidpp, report))) {\n\t\tatomic_set(&hidpp->connected,\n\t\t\t\t!(report->rap.params[0] & (1 << 6)));\n\t\tif (schedule_work(&hidpp->work) == 0)\n\t\t\tdbg_hid(\"%s: connect event already queued\\n\", __func__);\n\t\treturn 1;\n\t}\n\n\tif (hidpp->hid_dev->group == HID_GROUP_LOGITECH_27MHZ_DEVICE &&\n\t    data[0] == REPORT_ID_HIDPP_SHORT &&\n\t    data[2] == HIDPP_SUB_ID_USER_IFACE_EVENT &&\n\t    (data[3] & HIDPP_USER_IFACE_EVENT_ENCRYPTION_KEY_LOST)) {\n\t\tdev_err_ratelimited(&hidpp->hid_dev->dev,\n\t\t\t\"Error the keyboard's wireless encryption key has been lost, your keyboard will not work unless you re-configure encryption.\\n\");\n\t\tdev_err_ratelimited(&hidpp->hid_dev->dev,\n\t\t\t\"See: https://gitlab.freedesktop.org/jwrdegoede/logitech-27mhz-keyboard-encryption-setup/\\n\");\n\t}\n\n\tif (hidpp->capabilities & HIDPP_CAPABILITY_HIDPP20_BATTERY) {\n\t\tret = hidpp20_battery_event_1000(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tret = hidpp20_battery_event_1004(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tret = hidpp_solar_battery_event(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tret = hidpp20_battery_voltage_event(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tret = hidpp20_adc_measurement_event_1f20(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tif (hidpp->capabilities & HIDPP_CAPABILITY_HIDPP10_BATTERY) {\n\t\tret = hidpp10_battery_event(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tif (hidpp->quirks & HIDPP_QUIRK_HIDPP_WHEELS) {\n\t\tret = hidpp10_wheel_raw_event(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tif (hidpp->quirks & HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS) {\n\t\tret = hidpp10_extra_mouse_buttons_raw_event(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tif (hidpp->quirks & HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS) {\n\t\tret = hidpp10_consumer_keys_raw_event(hidpp, data, size);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hidpp_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\tu8 *data, int size)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tint ret = 0;\n\n\tif (!hidpp)\n\t\treturn 0;\n\n\t \n\tswitch (data[0]) {\n\tcase REPORT_ID_HIDPP_VERY_LONG:\n\t\tif (size != hidpp->very_long_report_length) {\n\t\t\thid_err(hdev, \"received hid++ report of bad size (%d)\",\n\t\t\t\tsize);\n\t\t\treturn 1;\n\t\t}\n\t\tret = hidpp_raw_hidpp_event(hidpp, data, size);\n\t\tbreak;\n\tcase REPORT_ID_HIDPP_LONG:\n\t\tif (size != HIDPP_REPORT_LONG_LENGTH) {\n\t\t\thid_err(hdev, \"received hid++ report of bad size (%d)\",\n\t\t\t\tsize);\n\t\t\treturn 1;\n\t\t}\n\t\tret = hidpp_raw_hidpp_event(hidpp, data, size);\n\t\tbreak;\n\tcase REPORT_ID_HIDPP_SHORT:\n\t\tif (size != HIDPP_REPORT_SHORT_LENGTH) {\n\t\t\thid_err(hdev, \"received hid++ report of bad size (%d)\",\n\t\t\t\tsize);\n\t\t\treturn 1;\n\t\t}\n\t\tret = hidpp_raw_hidpp_event(hidpp, data, size);\n\t\tbreak;\n\t}\n\n\t \n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\n\t\treturn wtp_raw_event(hdev, data, size);\n\telse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560)\n\t\treturn m560_raw_event(hdev, data, size);\n\n\treturn 0;\n}\n\nstatic int hidpp_event(struct hid_device *hdev, struct hid_field *field,\n\tstruct hid_usage *usage, __s32 value)\n{\n\t \n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tstruct hidpp_scroll_counter *counter;\n\n\tif (!hidpp)\n\t\treturn 0;\n\n\tcounter = &hidpp->vertical_wheel_counter;\n\t \n\tif (!(hidpp->capabilities & HIDPP_CAPABILITY_HI_RES_SCROLL)\n\t    || value == 0 || hidpp->input == NULL\n\t    || counter->wheel_multiplier == 0)\n\t\treturn 0;\n\n\thidpp_scroll_counter_handle_scroll(hidpp->input, counter, value);\n\treturn 1;\n}\n\nstatic int hidpp_initialize_battery(struct hidpp_device *hidpp)\n{\n\tstatic atomic_t battery_no = ATOMIC_INIT(0);\n\tstruct power_supply_config cfg = { .drv_data = hidpp };\n\tstruct power_supply_desc *desc = &hidpp->battery.desc;\n\tenum power_supply_property *battery_props;\n\tstruct hidpp_battery *battery;\n\tunsigned int num_battery_props;\n\tunsigned long n;\n\tint ret;\n\n\tif (hidpp->battery.ps)\n\t\treturn 0;\n\n\thidpp->battery.feature_index = 0xff;\n\thidpp->battery.solar_feature_index = 0xff;\n\thidpp->battery.voltage_feature_index = 0xff;\n\thidpp->battery.adc_measurement_feature_index = 0xff;\n\n\tif (hidpp->protocol_major >= 2) {\n\t\tif (hidpp->quirks & HIDPP_QUIRK_CLASS_K750)\n\t\t\tret = hidpp_solar_request_battery_event(hidpp);\n\t\telse {\n\t\t\t \n\t\t\tret = hidpp20_query_battery_info_1000(hidpp);\n\t\t\tif (ret)\n\t\t\t\tret = hidpp20_query_battery_info_1004(hidpp);\n\t\t\tif (ret)\n\t\t\t\tret = hidpp20_query_battery_voltage_info(hidpp);\n\t\t\tif (ret)\n\t\t\t\tret = hidpp20_query_adc_measurement_info_1f20(hidpp);\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\thidpp->capabilities |= HIDPP_CAPABILITY_HIDPP20_BATTERY;\n\t} else {\n\t\tret = hidpp10_query_battery_status(hidpp);\n\t\tif (ret) {\n\t\t\tret = hidpp10_query_battery_mileage(hidpp);\n\t\t\tif (ret)\n\t\t\t\treturn -ENOENT;\n\t\t\thidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_MILEAGE;\n\t\t} else {\n\t\t\thidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_LEVEL_STATUS;\n\t\t}\n\t\thidpp->capabilities |= HIDPP_CAPABILITY_HIDPP10_BATTERY;\n\t}\n\n\tbattery_props = devm_kmemdup(&hidpp->hid_dev->dev,\n\t\t\t\t     hidpp_battery_props,\n\t\t\t\t     sizeof(hidpp_battery_props),\n\t\t\t\t     GFP_KERNEL);\n\tif (!battery_props)\n\t\treturn -ENOMEM;\n\n\tnum_battery_props = ARRAY_SIZE(hidpp_battery_props) - 3;\n\n\tif (hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_MILEAGE ||\n\t    hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_PERCENTAGE ||\n\t    hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_VOLTAGE ||\n\t    hidpp->capabilities & HIDPP_CAPABILITY_ADC_MEASUREMENT)\n\t\tbattery_props[num_battery_props++] =\n\t\t\t\tPOWER_SUPPLY_PROP_CAPACITY;\n\n\tif (hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_LEVEL_STATUS)\n\t\tbattery_props[num_battery_props++] =\n\t\t\t\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL;\n\n\tif (hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_VOLTAGE ||\n\t    hidpp->capabilities & HIDPP_CAPABILITY_ADC_MEASUREMENT)\n\t\tbattery_props[num_battery_props++] =\n\t\t\tPOWER_SUPPLY_PROP_VOLTAGE_NOW;\n\n\tbattery = &hidpp->battery;\n\n\tn = atomic_inc_return(&battery_no) - 1;\n\tdesc->properties = battery_props;\n\tdesc->num_properties = num_battery_props;\n\tdesc->get_property = hidpp_battery_get_property;\n\tsprintf(battery->name, \"hidpp_battery_%ld\", n);\n\tdesc->name = battery->name;\n\tdesc->type = POWER_SUPPLY_TYPE_BATTERY;\n\tdesc->use_for_apm = 0;\n\n\tbattery->ps = devm_power_supply_register(&hidpp->hid_dev->dev,\n\t\t\t\t\t\t &battery->desc,\n\t\t\t\t\t\t &cfg);\n\tif (IS_ERR(battery->ps))\n\t\treturn PTR_ERR(battery->ps);\n\n\tpower_supply_powers(battery->ps, &hidpp->hid_dev->dev);\n\n\treturn ret;\n}\n\nstatic void hidpp_overwrite_name(struct hid_device *hdev)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tchar *name;\n\n\tif (hidpp->protocol_major < 2)\n\t\treturn;\n\n\tname = hidpp_get_device_name(hidpp);\n\n\tif (!name) {\n\t\thid_err(hdev, \"unable to retrieve the name of the device\");\n\t} else {\n\t\tdbg_hid(\"HID++: Got name: %s\\n\", name);\n\t\tsnprintf(hdev->name, sizeof(hdev->name), \"%s\", name);\n\t}\n\n\tkfree(name);\n}\n\nstatic int hidpp_input_open(struct input_dev *dev)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\n\treturn hid_hw_open(hid);\n}\n\nstatic void hidpp_input_close(struct input_dev *dev)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\n\thid_hw_close(hid);\n}\n\nstatic struct input_dev *hidpp_allocate_input(struct hid_device *hdev)\n{\n\tstruct input_dev *input_dev = devm_input_allocate_device(&hdev->dev);\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\n\tif (!input_dev)\n\t\treturn NULL;\n\n\tinput_set_drvdata(input_dev, hdev);\n\tinput_dev->open = hidpp_input_open;\n\tinput_dev->close = hidpp_input_close;\n\n\tinput_dev->name = hidpp->name;\n\tinput_dev->phys = hdev->phys;\n\tinput_dev->uniq = hdev->uniq;\n\tinput_dev->id.bustype = hdev->bus;\n\tinput_dev->id.vendor  = hdev->vendor;\n\tinput_dev->id.product = hdev->product;\n\tinput_dev->id.version = hdev->version;\n\tinput_dev->dev.parent = &hdev->dev;\n\n\treturn input_dev;\n}\n\nstatic void hidpp_connect_event(struct hidpp_device *hidpp)\n{\n\tstruct hid_device *hdev = hidpp->hid_dev;\n\tint ret = 0;\n\tbool connected = atomic_read(&hidpp->connected);\n\tstruct input_dev *input;\n\tchar *name, *devm_name;\n\n\tif (!connected) {\n\t\tif (hidpp->battery.ps) {\n\t\t\thidpp->battery.online = false;\n\t\t\thidpp->battery.status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\t\thidpp->battery.level = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\t\t\tpower_supply_changed(hidpp->battery.ps);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP) {\n\t\tret = wtp_connect(hdev, connected);\n\t\tif (ret)\n\t\t\treturn;\n\t} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560) {\n\t\tret = m560_send_config_command(hdev, connected);\n\t\tif (ret)\n\t\t\treturn;\n\t} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_K400) {\n\t\tret = k400_connect(hdev, connected);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hidpp->quirks & HIDPP_QUIRK_HIDPP_WHEELS) {\n\t\tret = hidpp10_wheel_connect(hidpp);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hidpp->quirks & HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS) {\n\t\tret = hidpp10_extra_mouse_buttons_connect(hidpp);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hidpp->quirks & HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS) {\n\t\tret = hidpp10_consumer_keys_connect(hidpp);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\t \n\tif (!hidpp->protocol_major) {\n\t\tret = hidpp_root_get_protocol_version(hidpp);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Can not get the protocol version.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (hidpp->protocol_major >= 2) {\n\t\tu8 feature_index;\n\n\t\tif (!hidpp_get_wireless_feature_index(hidpp, &feature_index))\n\t\t\thidpp->wireless_feature_index = feature_index;\n\t}\n\n\tif (hidpp->name == hdev->name && hidpp->protocol_major >= 2) {\n\t\tname = hidpp_get_device_name(hidpp);\n\t\tif (name) {\n\t\t\tdevm_name = devm_kasprintf(&hdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t   \"%s\", name);\n\t\t\tkfree(name);\n\t\t\tif (!devm_name)\n\t\t\t\treturn;\n\n\t\t\thidpp->name = devm_name;\n\t\t}\n\t}\n\n\thidpp_initialize_battery(hidpp);\n\tif (!hid_is_usb(hidpp->hid_dev))\n\t\thidpp_initialize_hires_scroll(hidpp);\n\n\t \n\tif (hidpp->capabilities & HIDPP_CAPABILITY_HIDPP10_BATTERY) {\n\t\thidpp10_enable_battery_reporting(hidpp);\n\t\tif (hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_MILEAGE)\n\t\t\thidpp10_query_battery_mileage(hidpp);\n\t\telse\n\t\t\thidpp10_query_battery_status(hidpp);\n\t} else if (hidpp->capabilities & HIDPP_CAPABILITY_HIDPP20_BATTERY) {\n\t\tif (hidpp->capabilities & HIDPP_CAPABILITY_BATTERY_VOLTAGE)\n\t\t\thidpp20_query_battery_voltage_info(hidpp);\n\t\telse if (hidpp->capabilities & HIDPP_CAPABILITY_UNIFIED_BATTERY)\n\t\t\thidpp20_query_battery_info_1004(hidpp);\n\t\telse if (hidpp->capabilities & HIDPP_CAPABILITY_ADC_MEASUREMENT)\n\t\t\thidpp20_query_adc_measurement_info_1f20(hidpp);\n\t\telse\n\t\t\thidpp20_query_battery_info_1000(hidpp);\n\t}\n\tif (hidpp->battery.ps)\n\t\tpower_supply_changed(hidpp->battery.ps);\n\n\tif (hidpp->capabilities & HIDPP_CAPABILITY_HI_RES_SCROLL)\n\t\thi_res_scroll_enable(hidpp);\n\n\tif (!(hidpp->quirks & HIDPP_QUIRK_DELAYED_INIT) || hidpp->delayed_input)\n\t\t \n\t\treturn;\n\n\tinput = hidpp_allocate_input(hdev);\n\tif (!input) {\n\t\thid_err(hdev, \"cannot allocate new input device: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thidpp_populate_input(hidpp, input);\n\n\tret = input_register_device(input);\n\tif (ret) {\n\t\tinput_free_device(input);\n\t\treturn;\n\t}\n\n\thidpp->delayed_input = input;\n}\n\nstatic DEVICE_ATTR(builtin_power_supply, 0000, NULL, NULL);\n\nstatic struct attribute *sysfs_attrs[] = {\n\t&dev_attr_builtin_power_supply.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ps_attribute_group = {\n\t.attrs = sysfs_attrs\n};\n\nstatic int hidpp_get_report_length(struct hid_device *hdev, int id)\n{\n\tstruct hid_report_enum *re;\n\tstruct hid_report *report;\n\n\tre = &(hdev->report_enum[HID_OUTPUT_REPORT]);\n\treport = re->report_id_hash[id];\n\tif (!report)\n\t\treturn 0;\n\n\treturn report->field[0]->report_count + 1;\n}\n\nstatic u8 hidpp_validate_device(struct hid_device *hdev)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\tint id, report_length;\n\tu8 supported_reports = 0;\n\n\tid = REPORT_ID_HIDPP_SHORT;\n\treport_length = hidpp_get_report_length(hdev, id);\n\tif (report_length) {\n\t\tif (report_length < HIDPP_REPORT_SHORT_LENGTH)\n\t\t\tgoto bad_device;\n\n\t\tsupported_reports |= HIDPP_REPORT_SHORT_SUPPORTED;\n\t}\n\n\tid = REPORT_ID_HIDPP_LONG;\n\treport_length = hidpp_get_report_length(hdev, id);\n\tif (report_length) {\n\t\tif (report_length < HIDPP_REPORT_LONG_LENGTH)\n\t\t\tgoto bad_device;\n\n\t\tsupported_reports |= HIDPP_REPORT_LONG_SUPPORTED;\n\t}\n\n\tid = REPORT_ID_HIDPP_VERY_LONG;\n\treport_length = hidpp_get_report_length(hdev, id);\n\tif (report_length) {\n\t\tif (report_length < HIDPP_REPORT_LONG_LENGTH ||\n\t\t    report_length > HIDPP_REPORT_VERY_LONG_MAX_LENGTH)\n\t\t\tgoto bad_device;\n\n\t\tsupported_reports |= HIDPP_REPORT_VERY_LONG_SUPPORTED;\n\t\thidpp->very_long_report_length = report_length;\n\t}\n\n\treturn supported_reports;\n\nbad_device:\n\thid_warn(hdev, \"not enough values in hidpp report %d\\n\", id);\n\treturn false;\n}\n\nstatic bool hidpp_application_equals(struct hid_device *hdev,\n\t\t\t\t     unsigned int application)\n{\n\tstruct list_head *report_list;\n\tstruct hid_report *report;\n\n\treport_list = &hdev->report_enum[HID_INPUT_REPORT].report_list;\n\treport = list_first_entry_or_null(report_list, struct hid_report, list);\n\treturn report && report->application == application;\n}\n\nstatic int hidpp_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct hidpp_device *hidpp;\n\tint ret;\n\tbool connected;\n\tunsigned int connect_mask = HID_CONNECT_DEFAULT;\n\tstruct hidpp_ff_private_data data;\n\n\t \n\thidpp = devm_kzalloc(&hdev->dev, sizeof(*hidpp), GFP_KERNEL);\n\tif (!hidpp)\n\t\treturn -ENOMEM;\n\n\thidpp->hid_dev = hdev;\n\thidpp->name = hdev->name;\n\thidpp->quirks = id->driver_data;\n\thid_set_drvdata(hdev, hidpp);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"%s:parse failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\thidpp->supported_reports = hidpp_validate_device(hdev);\n\n\tif (!hidpp->supported_reports) {\n\t\thid_set_drvdata(hdev, NULL);\n\t\tdevm_kfree(&hdev->dev, hidpp);\n\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t}\n\n\tif (id->group == HID_GROUP_LOGITECH_DJ_DEVICE)\n\t\thidpp->quirks |= HIDPP_QUIRK_UNIFYING;\n\n\tif (id->group == HID_GROUP_LOGITECH_27MHZ_DEVICE &&\n\t    hidpp_application_equals(hdev, HID_GD_MOUSE))\n\t\thidpp->quirks |= HIDPP_QUIRK_HIDPP_WHEELS |\n\t\t\t\t HIDPP_QUIRK_HIDPP_EXTRA_MOUSE_BTNS;\n\n\tif (id->group == HID_GROUP_LOGITECH_27MHZ_DEVICE &&\n\t    hidpp_application_equals(hdev, HID_GD_KEYBOARD))\n\t\thidpp->quirks |= HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS;\n\n\tif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP) {\n\t\tret = wtp_allocate(hdev, id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_K400) {\n\t\tret = k400_allocate(hdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tINIT_WORK(&hidpp->work, delayed_work_cb);\n\tmutex_init(&hidpp->send_mutex);\n\tinit_waitqueue_head(&hidpp->wait);\n\n\t \n\tret = sysfs_create_group(&hdev->dev.kobj, &ps_attribute_group);\n\tif (ret)\n\t\thid_warn(hdev, \"Cannot allocate sysfs group for %s\\n\",\n\t\t\t hdev->name);\n\n\t \n\tret = hid_hw_start(hdev, 0);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"%s:hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto hid_hw_open_fail;\n\t}\n\n\t \n\thid_device_io_start(hdev);\n\n\tif (hidpp->quirks & HIDPP_QUIRK_UNIFYING)\n\t\thidpp_unifying_init(hidpp);\n\telse if (hid_is_usb(hidpp->hid_dev))\n\t\thidpp_serial_init(hidpp);\n\n\tconnected = hidpp_root_get_protocol_version(hidpp) == 0;\n\tatomic_set(&hidpp->connected, connected);\n\tif (!(hidpp->quirks & HIDPP_QUIRK_UNIFYING)) {\n\t\tif (!connected) {\n\t\t\tret = -ENODEV;\n\t\t\thid_err(hdev, \"Device not connected\");\n\t\t\tgoto hid_hw_init_fail;\n\t\t}\n\n\t\thidpp_overwrite_name(hdev);\n\t}\n\n\tif (connected && (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)) {\n\t\tret = wtp_get_config(hidpp);\n\t\tif (ret)\n\t\t\tgoto hid_hw_init_fail;\n\t} else if (connected && (hidpp->quirks & HIDPP_QUIRK_CLASS_G920)) {\n\t\tret = g920_get_config(hidpp, &data);\n\t\tif (ret)\n\t\t\tgoto hid_hw_init_fail;\n\t}\n\n\tschedule_work(&hidpp->work);\n\tflush_work(&hidpp->work);\n\n\tif (hidpp->quirks & HIDPP_QUIRK_DELAYED_INIT)\n\t\tconnect_mask &= ~HID_CONNECT_HIDINPUT;\n\n\t \n\tret = hid_connect(hdev, connect_mask);\n\tif (ret) {\n\t\thid_err(hdev, \"%s:hid_connect returned error %d\\n\", __func__, ret);\n\t\tgoto hid_hw_init_fail;\n\t}\n\n\tif (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {\n\t\tret = hidpp_ff_init(hidpp, &data);\n\t\tif (ret)\n\t\t\thid_warn(hidpp->hid_dev,\n\t\t     \"Unable to initialize force feedback support, errno %d\\n\",\n\t\t\t\t ret);\n\t}\n\n\t \n\thid_hw_close(hdev);\n\treturn ret;\n\nhid_hw_init_fail:\n\thid_hw_close(hdev);\nhid_hw_open_fail:\n\thid_hw_stop(hdev);\nhid_hw_start_fail:\n\tsysfs_remove_group(&hdev->dev.kobj, &ps_attribute_group);\n\tcancel_work_sync(&hidpp->work);\n\tmutex_destroy(&hidpp->send_mutex);\n\treturn ret;\n}\n\nstatic void hidpp_remove(struct hid_device *hdev)\n{\n\tstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\n\n\tif (!hidpp)\n\t\treturn hid_hw_stop(hdev);\n\n\tsysfs_remove_group(&hdev->dev.kobj, &ps_attribute_group);\n\n\thid_hw_stop(hdev);\n\tcancel_work_sync(&hidpp->work);\n\tmutex_destroy(&hidpp->send_mutex);\n}\n\n#define LDJ_DEVICE(product) \\\n\tHID_DEVICE(BUS_USB, HID_GROUP_LOGITECH_DJ_DEVICE, \\\n\t\t   USB_VENDOR_ID_LOGITECH, (product))\n\n#define L27MHZ_DEVICE(product) \\\n\tHID_DEVICE(BUS_USB, HID_GROUP_LOGITECH_27MHZ_DEVICE, \\\n\t\t   USB_VENDOR_ID_LOGITECH, (product))\n\nstatic const struct hid_device_id hidpp_devices[] = {\n\t{  \n\t  LDJ_DEVICE(0x4011),\n\t  .driver_data = HIDPP_QUIRK_CLASS_WTP | HIDPP_QUIRK_DELAYED_INIT |\n\t\t\t HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS },\n\t{  \n\t  LDJ_DEVICE(0x4101),\n\t  .driver_data = HIDPP_QUIRK_CLASS_WTP | HIDPP_QUIRK_DELAYED_INIT },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_T651),\n\t  .driver_data = HIDPP_QUIRK_CLASS_WTP | HIDPP_QUIRK_DELAYED_INIT },\n\t{  \n\t  LDJ_DEVICE(0x1017), .driver_data = HIDPP_QUIRK_HI_RES_SCROLL_1P0 },\n\t{  \n\t  LDJ_DEVICE(0x402d),\n\t  .driver_data = HIDPP_QUIRK_DELAYED_INIT | HIDPP_QUIRK_CLASS_M560 },\n\t{  \n\t  LDJ_DEVICE(0x101b), .driver_data = HIDPP_QUIRK_HI_RES_SCROLL_1P0 },\n\t{  \n\t  LDJ_DEVICE(0x101a), .driver_data = HIDPP_QUIRK_HI_RES_SCROLL_1P0 },\n\t{  \n\t  LDJ_DEVICE(0x4024),\n\t  .driver_data = HIDPP_QUIRK_CLASS_K400 },\n\t{  \n\t  LDJ_DEVICE(0x4002),\n\t  .driver_data = HIDPP_QUIRK_CLASS_K750 },\n\t{  \n\t  LDJ_DEVICE(0xb305),\n\t  .driver_data = HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS },\n\t{  \n\t  LDJ_DEVICE(0xb309),\n\t  .driver_data = HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS },\n\t{  \n\t  LDJ_DEVICE(0xb30b),\n\t  .driver_data = HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS },\n\n\t{ LDJ_DEVICE(HID_ANY_ID) },\n\n\t{  \n\t  L27MHZ_DEVICE(0x0049),\n\t  .driver_data = HIDPP_QUIRK_KBD_ZOOM_WHEEL },\n\t{  \n\t  L27MHZ_DEVICE(0x0057),\n\t  .driver_data = HIDPP_QUIRK_KBD_SCROLL_WHEEL },\n\t{  \n\t  L27MHZ_DEVICE(0x005c),\n\t  .driver_data = HIDPP_QUIRK_KBD_ZOOM_WHEEL },\n\t{  \n\t  L27MHZ_DEVICE(0x00fe),\n\t  .driver_data = HIDPP_QUIRK_KBD_SCROLL_WHEEL },\n\n\t{ L27MHZ_DEVICE(HID_ANY_ID) },\n\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC082) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC08D) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC087) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC090) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC081) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC086) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC091) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC343) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G920_WHEEL),\n\t\t.driver_data = HIDPP_QUIRK_CLASS_G920 | HIDPP_QUIRK_FORCE_OUTPUT_REPORTS},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G923_XBOX_WHEEL),\n\t\t.driver_data = HIDPP_QUIRK_CLASS_G920 | HIDPP_QUIRK_FORCE_OUTPUT_REPORTS },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC088) },\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0xC094) },\n\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, 0x0a87),\n\t\t.driver_data = HIDPP_QUIRK_WIRELESS_STATUS },\n\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb305),\n\t  .driver_data = HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb309),\n\t  .driver_data = HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb30b),\n\t  .driver_data = HIDPP_QUIRK_HIDPP_CONSUMER_VENDOR_KEYS },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb35f) },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb008) },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb012) },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb015) },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb01d) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb01e) },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb02a) },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb023) },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb025) },\n\t{  \n\t  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, 0xb034) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(hid, hidpp_devices);\n\nstatic const struct hid_usage_id hidpp_usages[] = {\n\t{ HID_GD_WHEEL, EV_REL, REL_WHEEL_HI_RES },\n\t{ HID_ANY_ID - 1, HID_ANY_ID - 1, HID_ANY_ID - 1}\n};\n\nstatic struct hid_driver hidpp_driver = {\n\t.name = \"logitech-hidpp-device\",\n\t.id_table = hidpp_devices,\n\t.report_fixup = hidpp_report_fixup,\n\t.probe = hidpp_probe,\n\t.remove = hidpp_remove,\n\t.raw_event = hidpp_raw_event,\n\t.usage_table = hidpp_usages,\n\t.event = hidpp_event,\n\t.input_configured = hidpp_input_configured,\n\t.input_mapping = hidpp_input_mapping,\n\t.input_mapped = hidpp_input_mapped,\n};\n\nmodule_hid_driver(hidpp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}