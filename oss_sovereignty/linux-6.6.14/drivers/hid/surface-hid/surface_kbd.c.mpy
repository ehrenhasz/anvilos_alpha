{
  "module_name": "surface_kbd.c",
  "hash_id": "2ee9cb7e18ec59bcd0203370cbe588d329dfa89294850ad780a90995658368ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/surface-hid/surface_kbd.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/hid.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#include <linux/surface_aggregator/controller.h>\n\n#include \"surface_hid_core.h\"\n\n\n \n\n#define KBD_FEATURE_REPORT_SIZE\t\t\t7   \n\nenum surface_kbd_cid {\n\tSURFACE_KBD_CID_GET_DESCRIPTOR\t\t= 0x00,\n\tSURFACE_KBD_CID_SET_CAPSLOCK_LED\t= 0x01,\n\tSURFACE_KBD_CID_EVT_INPUT_GENERIC\t= 0x03,\n\tSURFACE_KBD_CID_EVT_INPUT_HOTKEYS\t= 0x04,\n\tSURFACE_KBD_CID_GET_FEATURE_REPORT\t= 0x0b,\n};\n\nstatic int ssam_kbd_get_descriptor(struct surface_hid_device *shid, u8 entry, u8 *buf, size_t len)\n{\n\tstruct ssam_request rqst;\n\tstruct ssam_response rsp;\n\tint status;\n\n\trqst.target_category = shid->uid.category;\n\trqst.target_id = shid->uid.target;\n\trqst.command_id = SURFACE_KBD_CID_GET_DESCRIPTOR;\n\trqst.instance_id = shid->uid.instance;\n\trqst.flags = SSAM_REQUEST_HAS_RESPONSE;\n\trqst.length = sizeof(entry);\n\trqst.payload = &entry;\n\n\trsp.capacity = len;\n\trsp.length = 0;\n\trsp.pointer = buf;\n\n\tstatus = ssam_retry(ssam_request_do_sync_onstack, shid->ctrl, &rqst, &rsp, sizeof(entry));\n\tif (status)\n\t\treturn status;\n\n\tif (rsp.length != len) {\n\t\tdev_err(shid->dev, \"invalid descriptor length: got %zu, expected, %zu\\n\",\n\t\t\trsp.length, len);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ssam_kbd_set_caps_led(struct surface_hid_device *shid, bool value)\n{\n\tstruct ssam_request rqst;\n\tu8 value_u8 = value;\n\n\trqst.target_category = shid->uid.category;\n\trqst.target_id = shid->uid.target;\n\trqst.command_id = SURFACE_KBD_CID_SET_CAPSLOCK_LED;\n\trqst.instance_id = shid->uid.instance;\n\trqst.flags = 0;\n\trqst.length = sizeof(value_u8);\n\trqst.payload = &value_u8;\n\n\treturn ssam_retry(ssam_request_do_sync_onstack, shid->ctrl, &rqst, NULL, sizeof(value_u8));\n}\n\nstatic int ssam_kbd_get_feature_report(struct surface_hid_device *shid, u8 *buf, size_t len)\n{\n\tstruct ssam_request rqst;\n\tstruct ssam_response rsp;\n\tu8 payload = 0;\n\tint status;\n\n\trqst.target_category = shid->uid.category;\n\trqst.target_id = shid->uid.target;\n\trqst.command_id = SURFACE_KBD_CID_GET_FEATURE_REPORT;\n\trqst.instance_id = shid->uid.instance;\n\trqst.flags = SSAM_REQUEST_HAS_RESPONSE;\n\trqst.length = sizeof(payload);\n\trqst.payload = &payload;\n\n\trsp.capacity = len;\n\trsp.length = 0;\n\trsp.pointer = buf;\n\n\tstatus = ssam_retry(ssam_request_do_sync_onstack, shid->ctrl, &rqst, &rsp, sizeof(payload));\n\tif (status)\n\t\treturn status;\n\n\tif (rsp.length != len) {\n\t\tdev_err(shid->dev, \"invalid feature report length: got %zu, expected, %zu\\n\",\n\t\t\trsp.length, len);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ssam_kbd_is_input_event(const struct ssam_event *event)\n{\n\tif (event->command_id == SURFACE_KBD_CID_EVT_INPUT_GENERIC)\n\t\treturn true;\n\n\tif (event->command_id == SURFACE_KBD_CID_EVT_INPUT_HOTKEYS)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic u32 ssam_kbd_event_fn(struct ssam_event_notifier *nf, const struct ssam_event *event)\n{\n\tstruct surface_hid_device *shid = container_of(nf, struct surface_hid_device, notif);\n\n\t \n\n\tif (shid->uid.category != event->target_category)\n\t\treturn 0;\n\n\tif (shid->uid.target != event->target_id)\n\t\treturn 0;\n\n\tif (shid->uid.instance != event->instance_id)\n\t\treturn 0;\n\n\tif (!ssam_kbd_is_input_event(event))\n\t\treturn 0;\n\n\thid_input_report(shid->hid, HID_INPUT_REPORT, (u8 *)&event->data[0], event->length, 0);\n\treturn SSAM_NOTIF_HANDLED;\n}\n\n\n \n\nstatic int skbd_get_caps_led_value(struct hid_device *hid, u8 rprt_id, u8 *buf, size_t len)\n{\n\tstruct hid_field *field;\n\tunsigned int offset, size;\n\tint i;\n\n\t \n\tfield = hidinput_get_led_field(hid);\n\tif (!field)\n\t\treturn -ENOENT;\n\n\t \n\tif (len != hid_report_len(field->report))\n\t\treturn -ENOENT;\n\n\tif (rprt_id != field->report->id)\n\t\treturn -ENOENT;\n\n\t \n\tfor (i = 0; i < field->report_count; i++)\n\t\tif ((field->usage[i].hid & 0xffff) == 0x02)\n\t\t\tbreak;\n\n\tif (i == field->report_count)\n\t\treturn -ENOENT;\n\n\t \n\tsize = field->report_size;\n\toffset = field->report_offset + i * size;\n\treturn !!hid_field_extract(hid, buf + 1, size, offset);\n}\n\nstatic int skbd_output_report(struct surface_hid_device *shid, u8 rprt_id, u8 *buf, size_t len)\n{\n\tint caps_led;\n\tint status;\n\n\tcaps_led = skbd_get_caps_led_value(shid->hid, rprt_id, buf, len);\n\tif (caps_led < 0)\n\t\treturn -EIO;   \n\n\tstatus = ssam_kbd_set_caps_led(shid, caps_led);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn len;\n}\n\nstatic int skbd_get_feature_report(struct surface_hid_device *shid, u8 rprt_id, u8 *buf, size_t len)\n{\n\tu8 report[KBD_FEATURE_REPORT_SIZE];\n\tint status;\n\n\t \n\n\tif (len < ARRAY_SIZE(report))\n\t\treturn -ENOSPC;\n\n\tstatus = ssam_kbd_get_feature_report(shid, report, ARRAY_SIZE(report));\n\tif (status < 0)\n\t\treturn status;\n\n\tif (rprt_id != report[0])\n\t\treturn -ENOENT;\n\n\tmemcpy(buf, report, ARRAY_SIZE(report));\n\treturn len;\n}\n\nstatic int skbd_set_feature_report(struct surface_hid_device *shid, u8 rprt_id, u8 *buf, size_t len)\n{\n\t \n\treturn -EIO;\n}\n\n\n \n\nstatic int surface_kbd_probe(struct platform_device *pdev)\n{\n\tstruct ssam_controller *ctrl;\n\tstruct surface_hid_device *shid;\n\n\t \n\tctrl = ssam_client_bind(&pdev->dev);\n\tif (IS_ERR(ctrl))\n\t\treturn PTR_ERR(ctrl) == -ENODEV ? -EPROBE_DEFER : PTR_ERR(ctrl);\n\n\tshid = devm_kzalloc(&pdev->dev, sizeof(*shid), GFP_KERNEL);\n\tif (!shid)\n\t\treturn -ENOMEM;\n\n\tshid->dev = &pdev->dev;\n\tshid->ctrl = ctrl;\n\n\tshid->uid.domain = SSAM_DOMAIN_SERIALHUB;\n\tshid->uid.category = SSAM_SSH_TC_KBD;\n\tshid->uid.target = SSAM_SSH_TID_KIP;\n\tshid->uid.instance = 0;\n\tshid->uid.function = 0;\n\n\tshid->notif.base.priority = 1;\n\tshid->notif.base.fn = ssam_kbd_event_fn;\n\tshid->notif.event.reg = SSAM_EVENT_REGISTRY_SAM;\n\tshid->notif.event.id.target_category = shid->uid.category;\n\tshid->notif.event.id.instance = shid->uid.instance;\n\tshid->notif.event.mask = SSAM_EVENT_MASK_NONE;\n\tshid->notif.event.flags = 0;\n\n\tshid->ops.get_descriptor = ssam_kbd_get_descriptor;\n\tshid->ops.output_report = skbd_output_report;\n\tshid->ops.get_feature_report = skbd_get_feature_report;\n\tshid->ops.set_feature_report = skbd_set_feature_report;\n\n\tplatform_set_drvdata(pdev, shid);\n\treturn surface_hid_device_add(shid);\n}\n\nstatic int surface_kbd_remove(struct platform_device *pdev)\n{\n\tsurface_hid_device_destroy(platform_get_drvdata(pdev));\n\treturn 0;\n}\n\nstatic const struct acpi_device_id surface_kbd_match[] = {\n\t{ \"MSHW0096\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, surface_kbd_match);\n\nstatic struct platform_driver surface_kbd_driver = {\n\t.probe = surface_kbd_probe,\n\t.remove = surface_kbd_remove,\n\t.driver = {\n\t\t.name = \"surface_keyboard\",\n\t\t.acpi_match_table = surface_kbd_match,\n\t\t.pm = &surface_hid_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_platform_driver(surface_kbd_driver);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"HID legacy transport driver for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}