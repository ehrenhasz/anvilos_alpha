{
  "module_name": "surface_hid.c",
  "hash_id": "aa6357bbb4ecb5d9f86f26d51ffa52844f1e5b0942b97d7a899d1f29ec34d95b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/surface-hid/surface_hid.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/hid.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n\n#include <linux/surface_aggregator/controller.h>\n#include <linux/surface_aggregator/device.h>\n\n#include \"surface_hid_core.h\"\n\n\n \n\nstruct surface_hid_buffer_slice {\n\t__u8 entry;\n\t__le32 offset;\n\t__le32 length;\n\t__u8 end;\n\t__u8 data[];\n} __packed;\n\nstatic_assert(sizeof(struct surface_hid_buffer_slice) == 10);\n\nenum surface_hid_cid {\n\tSURFACE_HID_CID_OUTPUT_REPORT      = 0x01,\n\tSURFACE_HID_CID_GET_FEATURE_REPORT = 0x02,\n\tSURFACE_HID_CID_SET_FEATURE_REPORT = 0x03,\n\tSURFACE_HID_CID_GET_DESCRIPTOR     = 0x04,\n};\n\nstatic int ssam_hid_get_descriptor(struct surface_hid_device *shid, u8 entry, u8 *buf, size_t len)\n{\n\tu8 buffer[sizeof(struct surface_hid_buffer_slice) + 0x76];\n\tstruct surface_hid_buffer_slice *slice;\n\tstruct ssam_request rqst;\n\tstruct ssam_response rsp;\n\tu32 buffer_len, offset, length;\n\tint status;\n\n\t \n\n\tbuffer_len = ARRAY_SIZE(buffer) - sizeof(struct surface_hid_buffer_slice);\n\n\trqst.target_category = shid->uid.category;\n\trqst.target_id = shid->uid.target;\n\trqst.command_id = SURFACE_HID_CID_GET_DESCRIPTOR;\n\trqst.instance_id = shid->uid.instance;\n\trqst.flags = SSAM_REQUEST_HAS_RESPONSE;\n\trqst.length = sizeof(struct surface_hid_buffer_slice);\n\trqst.payload = buffer;\n\n\trsp.capacity = ARRAY_SIZE(buffer);\n\trsp.pointer = buffer;\n\n\tslice = (struct surface_hid_buffer_slice *)buffer;\n\tslice->entry = entry;\n\tslice->end = 0;\n\n\toffset = 0;\n\tlength = buffer_len;\n\n\twhile (!slice->end && offset < len) {\n\t\tput_unaligned_le32(offset, &slice->offset);\n\t\tput_unaligned_le32(length, &slice->length);\n\n\t\trsp.length = 0;\n\n\t\tstatus = ssam_retry(ssam_request_do_sync_onstack, shid->ctrl, &rqst, &rsp,\n\t\t\t\t    sizeof(*slice));\n\t\tif (status)\n\t\t\treturn status;\n\n\t\toffset = get_unaligned_le32(&slice->offset);\n\t\tlength = get_unaligned_le32(&slice->length);\n\n\t\t \n\t\tif (length > buffer_len || offset > len)\n\t\t\treturn -EPROTO;\n\n\t\tif (offset + length > len)\n\t\t\tlength = len - offset;\n\n\t\tmemcpy(buf + offset, &slice->data[0], length);\n\n\t\toffset += length;\n\t\tlength = buffer_len;\n\t}\n\n\tif (offset != len) {\n\t\tdev_err(shid->dev, \"unexpected descriptor length: got %u, expected %zu\\n\",\n\t\t\toffset, len);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ssam_hid_set_raw_report(struct surface_hid_device *shid, u8 rprt_id, bool feature,\n\t\t\t\t   u8 *buf, size_t len)\n{\n\tstruct ssam_request rqst;\n\tu8 cid;\n\n\tif (feature)\n\t\tcid = SURFACE_HID_CID_SET_FEATURE_REPORT;\n\telse\n\t\tcid = SURFACE_HID_CID_OUTPUT_REPORT;\n\n\trqst.target_category = shid->uid.category;\n\trqst.target_id = shid->uid.target;\n\trqst.instance_id = shid->uid.instance;\n\trqst.command_id = cid;\n\trqst.flags = 0;\n\trqst.length = len;\n\trqst.payload = buf;\n\n\tbuf[0] = rprt_id;\n\n\treturn ssam_retry(ssam_request_do_sync, shid->ctrl, &rqst, NULL);\n}\n\nstatic int ssam_hid_get_raw_report(struct surface_hid_device *shid, u8 rprt_id, u8 *buf, size_t len)\n{\n\tstruct ssam_request rqst;\n\tstruct ssam_response rsp;\n\n\trqst.target_category = shid->uid.category;\n\trqst.target_id = shid->uid.target;\n\trqst.instance_id = shid->uid.instance;\n\trqst.command_id = SURFACE_HID_CID_GET_FEATURE_REPORT;\n\trqst.flags = SSAM_REQUEST_HAS_RESPONSE;\n\trqst.length = sizeof(rprt_id);\n\trqst.payload = &rprt_id;\n\n\trsp.capacity = len;\n\trsp.length = 0;\n\trsp.pointer = buf;\n\n\treturn ssam_retry(ssam_request_do_sync_onstack, shid->ctrl, &rqst, &rsp, sizeof(rprt_id));\n}\n\nstatic u32 ssam_hid_event_fn(struct ssam_event_notifier *nf, const struct ssam_event *event)\n{\n\tstruct surface_hid_device *shid = container_of(nf, struct surface_hid_device, notif);\n\n\tif (event->command_id != 0x00)\n\t\treturn 0;\n\n\thid_input_report(shid->hid, HID_INPUT_REPORT, (u8 *)&event->data[0], event->length, 0);\n\treturn SSAM_NOTIF_HANDLED;\n}\n\n\n \n\nstatic int shid_output_report(struct surface_hid_device *shid, u8 rprt_id, u8 *buf, size_t len)\n{\n\tint status;\n\n\tstatus = ssam_hid_set_raw_report(shid, rprt_id, false, buf, len);\n\treturn status >= 0 ? len : status;\n}\n\nstatic int shid_get_feature_report(struct surface_hid_device *shid, u8 rprt_id, u8 *buf, size_t len)\n{\n\tint status;\n\n\tstatus = ssam_hid_get_raw_report(shid, rprt_id, buf, len);\n\treturn status >= 0 ? len : status;\n}\n\nstatic int shid_set_feature_report(struct surface_hid_device *shid, u8 rprt_id, u8 *buf, size_t len)\n{\n\tint status;\n\n\tstatus = ssam_hid_set_raw_report(shid, rprt_id, true, buf, len);\n\treturn status >= 0 ? len : status;\n}\n\n\n \n\nstatic int surface_hid_probe(struct ssam_device *sdev)\n{\n\tstruct surface_hid_device *shid;\n\n\tshid = devm_kzalloc(&sdev->dev, sizeof(*shid), GFP_KERNEL);\n\tif (!shid)\n\t\treturn -ENOMEM;\n\n\tshid->dev = &sdev->dev;\n\tshid->ctrl = sdev->ctrl;\n\tshid->uid = sdev->uid;\n\n\tshid->notif.base.priority = 1;\n\tshid->notif.base.fn = ssam_hid_event_fn;\n\tshid->notif.event.reg = SSAM_EVENT_REGISTRY_REG(sdev->uid.target);\n\tshid->notif.event.id.target_category = sdev->uid.category;\n\tshid->notif.event.id.instance = sdev->uid.instance;\n\tshid->notif.event.mask = SSAM_EVENT_MASK_STRICT;\n\tshid->notif.event.flags = 0;\n\n\tshid->ops.get_descriptor = ssam_hid_get_descriptor;\n\tshid->ops.output_report = shid_output_report;\n\tshid->ops.get_feature_report = shid_get_feature_report;\n\tshid->ops.set_feature_report = shid_set_feature_report;\n\n\tssam_device_set_drvdata(sdev, shid);\n\treturn surface_hid_device_add(shid);\n}\n\nstatic void surface_hid_remove(struct ssam_device *sdev)\n{\n\tsurface_hid_device_destroy(ssam_device_get_drvdata(sdev));\n}\n\nstatic const struct ssam_device_id surface_hid_match[] = {\n\t{ SSAM_SDEV(HID, ANY, SSAM_SSH_IID_ANY, 0x00) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(ssam, surface_hid_match);\n\nstatic struct ssam_device_driver surface_hid_driver = {\n\t.probe = surface_hid_probe,\n\t.remove = surface_hid_remove,\n\t.match_table = surface_hid_match,\n\t.driver = {\n\t\t.name = \"surface_hid\",\n\t\t.pm = &surface_hid_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_ssam_device_driver(surface_hid_driver);\n\nMODULE_AUTHOR(\"Bla\u017e Hrastnik <blaz@mxxn.io>\");\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"HID transport driver for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}