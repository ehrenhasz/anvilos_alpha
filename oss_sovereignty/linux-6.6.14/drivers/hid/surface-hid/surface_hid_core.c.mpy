{
  "module_name": "surface_hid_core.c",
  "hash_id": "91001c6e42e08b503506a748f2a17ae56176576d52bfeb8260eeeacc5618ebf7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/surface-hid/surface_hid_core.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/hid.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/usb/ch9.h>\n\n#include <linux/surface_aggregator/controller.h>\n\n#include \"surface_hid_core.h\"\n\n\n \n\nstatic bool surface_hid_is_hot_removed(struct surface_hid_device *shid)\n{\n\t \n\tif (!is_ssam_device(shid->dev))\n\t\treturn false;\n\n\treturn ssam_device_is_hot_removed(to_ssam_device(shid->dev));\n}\n\n\n \n\nstatic int surface_hid_load_hid_descriptor(struct surface_hid_device *shid)\n{\n\tint status;\n\n\tif (surface_hid_is_hot_removed(shid))\n\t\treturn -ENODEV;\n\n\tstatus = shid->ops.get_descriptor(shid, SURFACE_HID_DESC_HID,\n\t\t\t(u8 *)&shid->hid_desc, sizeof(shid->hid_desc));\n\tif (status)\n\t\treturn status;\n\n\tif (shid->hid_desc.desc_len != sizeof(shid->hid_desc)) {\n\t\tdev_err(shid->dev, \"unexpected HID descriptor length: got %u, expected %zu\\n\",\n\t\t\tshid->hid_desc.desc_len, sizeof(shid->hid_desc));\n\t\treturn -EPROTO;\n\t}\n\n\tif (shid->hid_desc.desc_type != HID_DT_HID) {\n\t\tdev_err(shid->dev, \"unexpected HID descriptor type: got %#04x, expected %#04x\\n\",\n\t\t\tshid->hid_desc.desc_type, HID_DT_HID);\n\t\treturn -EPROTO;\n\t}\n\n\tif (shid->hid_desc.num_descriptors != 1) {\n\t\tdev_err(shid->dev, \"unexpected number of descriptors: got %u, expected 1\\n\",\n\t\t\tshid->hid_desc.num_descriptors);\n\t\treturn -EPROTO;\n\t}\n\n\tif (shid->hid_desc.report_desc_type != HID_DT_REPORT) {\n\t\tdev_err(shid->dev, \"unexpected report descriptor type: got %#04x, expected %#04x\\n\",\n\t\t\tshid->hid_desc.report_desc_type, HID_DT_REPORT);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nstatic int surface_hid_load_device_attributes(struct surface_hid_device *shid)\n{\n\tint status;\n\n\tif (surface_hid_is_hot_removed(shid))\n\t\treturn -ENODEV;\n\n\tstatus = shid->ops.get_descriptor(shid, SURFACE_HID_DESC_ATTRS,\n\t\t\t(u8 *)&shid->attrs, sizeof(shid->attrs));\n\tif (status)\n\t\treturn status;\n\n\tif (get_unaligned_le32(&shid->attrs.length) != sizeof(shid->attrs)) {\n\t\tdev_err(shid->dev, \"unexpected attribute length: got %u, expected %zu\\n\",\n\t\t\tget_unaligned_le32(&shid->attrs.length), sizeof(shid->attrs));\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic int surface_hid_start(struct hid_device *hid)\n{\n\tstruct surface_hid_device *shid = hid->driver_data;\n\n\treturn ssam_notifier_register(shid->ctrl, &shid->notif);\n}\n\nstatic void surface_hid_stop(struct hid_device *hid)\n{\n\tstruct surface_hid_device *shid = hid->driver_data;\n\tbool hot_removed;\n\n\t \n\thot_removed = surface_hid_is_hot_removed(shid);\n\n\t \n\t__ssam_notifier_unregister(shid->ctrl, &shid->notif, !hot_removed);\n}\n\nstatic int surface_hid_open(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void surface_hid_close(struct hid_device *hid)\n{\n}\n\nstatic int surface_hid_parse(struct hid_device *hid)\n{\n\tstruct surface_hid_device *shid = hid->driver_data;\n\tsize_t len = get_unaligned_le16(&shid->hid_desc.report_desc_len);\n\tu8 *buf;\n\tint status;\n\n\tif (surface_hid_is_hot_removed(shid))\n\t\treturn -ENODEV;\n\n\tbuf = kzalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tstatus = shid->ops.get_descriptor(shid, SURFACE_HID_DESC_REPORT, buf, len);\n\tif (!status)\n\t\tstatus = hid_parse_report(hid, buf, len);\n\n\tkfree(buf);\n\treturn status;\n}\n\nstatic int surface_hid_raw_request(struct hid_device *hid, unsigned char reportnum, u8 *buf,\n\t\t\t\t   size_t len, unsigned char rtype, int reqtype)\n{\n\tstruct surface_hid_device *shid = hid->driver_data;\n\n\tif (surface_hid_is_hot_removed(shid))\n\t\treturn -ENODEV;\n\n\tif (rtype == HID_OUTPUT_REPORT && reqtype == HID_REQ_SET_REPORT)\n\t\treturn shid->ops.output_report(shid, reportnum, buf, len);\n\n\telse if (rtype == HID_FEATURE_REPORT && reqtype == HID_REQ_GET_REPORT)\n\t\treturn shid->ops.get_feature_report(shid, reportnum, buf, len);\n\n\telse if (rtype == HID_FEATURE_REPORT && reqtype == HID_REQ_SET_REPORT)\n\t\treturn shid->ops.set_feature_report(shid, reportnum, buf, len);\n\n\treturn -EIO;\n}\n\nstatic const struct hid_ll_driver surface_hid_ll_driver = {\n\t.start       = surface_hid_start,\n\t.stop        = surface_hid_stop,\n\t.open        = surface_hid_open,\n\t.close       = surface_hid_close,\n\t.parse       = surface_hid_parse,\n\t.raw_request = surface_hid_raw_request,\n};\n\n\n \n\nint surface_hid_device_add(struct surface_hid_device *shid)\n{\n\tint status;\n\n\tstatus = surface_hid_load_hid_descriptor(shid);\n\tif (status)\n\t\treturn status;\n\n\tstatus = surface_hid_load_device_attributes(shid);\n\tif (status)\n\t\treturn status;\n\n\tshid->hid = hid_allocate_device();\n\tif (IS_ERR(shid->hid))\n\t\treturn PTR_ERR(shid->hid);\n\n\tshid->hid->dev.parent = shid->dev;\n\tshid->hid->bus = BUS_HOST;\n\tshid->hid->vendor = get_unaligned_le16(&shid->attrs.vendor);\n\tshid->hid->product = get_unaligned_le16(&shid->attrs.product);\n\tshid->hid->version = get_unaligned_le16(&shid->hid_desc.hid_version);\n\tshid->hid->country = shid->hid_desc.country_code;\n\n\tsnprintf(shid->hid->name, sizeof(shid->hid->name), \"Microsoft Surface %04X:%04X\",\n\t\t shid->hid->vendor, shid->hid->product);\n\n\tstrscpy(shid->hid->phys, dev_name(shid->dev), sizeof(shid->hid->phys));\n\n\tshid->hid->driver_data = shid;\n\tshid->hid->ll_driver = &surface_hid_ll_driver;\n\n\tstatus = hid_add_device(shid->hid);\n\tif (status)\n\t\thid_destroy_device(shid->hid);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(surface_hid_device_add);\n\nvoid surface_hid_device_destroy(struct surface_hid_device *shid)\n{\n\thid_destroy_device(shid->hid);\n}\nEXPORT_SYMBOL_GPL(surface_hid_device_destroy);\n\n\n \n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int surface_hid_suspend(struct device *dev)\n{\n\tstruct surface_hid_device *d = dev_get_drvdata(dev);\n\n\treturn hid_driver_suspend(d->hid, PMSG_SUSPEND);\n}\n\nstatic int surface_hid_resume(struct device *dev)\n{\n\tstruct surface_hid_device *d = dev_get_drvdata(dev);\n\n\treturn hid_driver_resume(d->hid);\n}\n\nstatic int surface_hid_freeze(struct device *dev)\n{\n\tstruct surface_hid_device *d = dev_get_drvdata(dev);\n\n\treturn hid_driver_suspend(d->hid, PMSG_FREEZE);\n}\n\nstatic int surface_hid_poweroff(struct device *dev)\n{\n\tstruct surface_hid_device *d = dev_get_drvdata(dev);\n\n\treturn hid_driver_suspend(d->hid, PMSG_HIBERNATE);\n}\n\nstatic int surface_hid_restore(struct device *dev)\n{\n\tstruct surface_hid_device *d = dev_get_drvdata(dev);\n\n\treturn hid_driver_reset_resume(d->hid);\n}\n\nconst struct dev_pm_ops surface_hid_pm_ops = {\n\t.freeze   = surface_hid_freeze,\n\t.thaw     = surface_hid_resume,\n\t.suspend  = surface_hid_suspend,\n\t.resume   = surface_hid_resume,\n\t.poweroff = surface_hid_poweroff,\n\t.restore  = surface_hid_restore,\n};\nEXPORT_SYMBOL_GPL(surface_hid_pm_ops);\n\n#else  \n\nconst struct dev_pm_ops surface_hid_pm_ops = { };\nEXPORT_SYMBOL_GPL(surface_hid_pm_ops);\n\n#endif  \n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"HID transport driver core for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}