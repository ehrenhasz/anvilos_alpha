{
  "module_name": "hid-alps.c",
  "hash_id": "0ab11d81e91aca3e1fff4db36365f884da2ddad6f9497fa3169a992f2af5c2b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-alps.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n#include \"hid-ids.h\"\n\n \n#define HID_PRODUCT_ID_T3_BTNLESS\t0xD0C0\n#define HID_PRODUCT_ID_COSMO\t\t0x1202\n#define HID_PRODUCT_ID_U1_PTP_1\t\t0x1207\n#define HID_PRODUCT_ID_U1\t\t\t0x1209\n#define HID_PRODUCT_ID_U1_PTP_2\t\t0x120A\n#define HID_PRODUCT_ID_U1_DUAL\t\t0x120B\n#define HID_PRODUCT_ID_T4_BTNLESS\t0x120C\n\n#define DEV_SINGLEPOINT\t\t\t\t0x01\n#define DEV_DUALPOINT\t\t\t\t0x02\n\n#define U1_MOUSE_REPORT_ID\t\t\t0x01  \n#define U1_ABSOLUTE_REPORT_ID\t\t0x03  \n#define U1_ABSOLUTE_REPORT_ID_SECD  0x02  \n#define U1_FEATURE_REPORT_ID\t\t0x05  \n#define U1_SP_ABSOLUTE_REPORT_ID\t0x06  \n\n#define U1_FEATURE_REPORT_LEN\t\t0x08  \n#define U1_FEATURE_REPORT_LEN_ALL\t0x0A\n#define U1_CMD_REGISTER_READ\t\t0xD1\n#define U1_CMD_REGISTER_WRITE\t\t0xD2\n\n#define\tU1_DEVTYPE_SP_SUPPORT\t\t0x10  \n#define\tU1_DISABLE_DEV\t\t\t\t0x01\n#define U1_TP_ABS_MODE\t\t\t\t0x02\n#define\tU1_SP_ABS_MODE\t\t\t\t0x80\n\n#define ADDRESS_U1_DEV_CTRL_1\t0x00800040\n#define ADDRESS_U1_DEVICE_TYP\t0x00800043\n#define ADDRESS_U1_NUM_SENS_X\t0x00800047\n#define ADDRESS_U1_NUM_SENS_Y\t0x00800048\n#define ADDRESS_U1_PITCH_SENS_X\t0x00800049\n#define ADDRESS_U1_PITCH_SENS_Y\t0x0080004A\n#define ADDRESS_U1_RESO_DWN_ABS 0x0080004E\n#define ADDRESS_U1_PAD_BTN\t\t0x00800052\n#define ADDRESS_U1_SP_BTN\t\t0x0080009F\n\n#define T4_INPUT_REPORT_LEN\t\t\tsizeof(struct t4_input_report)\n#define T4_FEATURE_REPORT_LEN\t\tT4_INPUT_REPORT_LEN\n#define T4_FEATURE_REPORT_ID\t\t7\n#define T4_CMD_REGISTER_READ\t\t\t0x08\n#define T4_CMD_REGISTER_WRITE\t\t\t0x07\n\n#define T4_ADDRESS_BASE\t\t\t\t0xC2C0\n#define PRM_SYS_CONFIG_1\t\t\t(T4_ADDRESS_BASE + 0x0002)\n#define T4_PRM_FEED_CONFIG_1\t\t(T4_ADDRESS_BASE + 0x0004)\n#define T4_PRM_FEED_CONFIG_4\t\t(T4_ADDRESS_BASE + 0x001A)\n#define T4_PRM_ID_CONFIG_3\t\t\t(T4_ADDRESS_BASE + 0x00B0)\n\n\n#define T4_FEEDCFG4_ADVANCED_ABS_ENABLE\t\t\t0x01\n#define T4_I2C_ABS\t0x78\n\n#define T4_COUNT_PER_ELECTRODE\t\t256\n#define MAX_TOUCHES\t5\n\nenum dev_num {\n\tU1,\n\tT4,\n\tUNKNOWN,\n};\n \nstruct alps_dev {\n\tstruct input_dev *input;\n\tstruct input_dev *input2;\n\tstruct hid_device *hdev;\n\n\tenum dev_num dev_type;\n\tu8  max_fingers;\n\tu8  has_sp;\n\tu8\tsp_btn_info;\n\tu32\tx_active_len_mm;\n\tu32\ty_active_len_mm;\n\tu32\tx_max;\n\tu32\ty_max;\n\tu32\tx_min;\n\tu32\ty_min;\n\tu32\tbtn_cnt;\n\tu32\tsp_btn_cnt;\n};\n\nstruct t4_contact_data {\n\tu8  palm;\n\tu8\tx_lo;\n\tu8\tx_hi;\n\tu8\ty_lo;\n\tu8\ty_hi;\n};\n\nstruct t4_input_report {\n\tu8  reportID;\n\tu8  numContacts;\n\tstruct t4_contact_data contact[5];\n\tu8  button;\n\tu8  track[5];\n\tu8  zx[5], zy[5];\n\tu8  palmTime[5];\n\tu8  kilroy;\n\tu16 timeStamp;\n};\n\nstatic u16 t4_calc_check_sum(u8 *buffer,\n\t\tunsigned long offset, unsigned long length)\n{\n\tu16 sum1 = 0xFF, sum2 = 0xFF;\n\tunsigned long i = 0;\n\n\tif (offset + length >= 50)\n\t\treturn 0;\n\n\twhile (length > 0) {\n\t\tu32 tlen = length > 20 ? 20 : length;\n\n\t\tlength -= tlen;\n\n\t\tdo {\n\t\t\tsum1 += buffer[offset + i];\n\t\t\tsum2 += sum1;\n\t\t\ti++;\n\t\t} while (--tlen > 0);\n\n\t\tsum1 = (sum1 & 0xFF) + (sum1 >> 8);\n\t\tsum2 = (sum2 & 0xFF) + (sum2 >> 8);\n\t}\n\n\tsum1 = (sum1 & 0xFF) + (sum1 >> 8);\n\tsum2 = (sum2 & 0xFF) + (sum2 >> 8);\n\n\treturn(sum2 << 8 | sum1);\n}\n\nstatic int t4_read_write_register(struct hid_device *hdev, u32 address,\n\tu8 *read_val, u8 write_val, bool read_flag)\n{\n\tint ret;\n\tu16 check_sum;\n\tu8 *input;\n\tu8 *readbuf = NULL;\n\n\tinput = kzalloc(T4_FEATURE_REPORT_LEN, GFP_KERNEL);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput[0] = T4_FEATURE_REPORT_ID;\n\tif (read_flag) {\n\t\tinput[1] = T4_CMD_REGISTER_READ;\n\t\tinput[8] = 0x00;\n\t} else {\n\t\tinput[1] = T4_CMD_REGISTER_WRITE;\n\t\tinput[8] = write_val;\n\t}\n\tput_unaligned_le32(address, input + 2);\n\tinput[6] = 1;\n\tinput[7] = 0;\n\n\t \n\tcheck_sum = t4_calc_check_sum(input, 1, 8);\n\tinput[9] = (u8)check_sum;\n\tinput[10] = (u8)(check_sum >> 8);\n\tinput[11] = 0;\n\n\tret = hid_hw_raw_request(hdev, T4_FEATURE_REPORT_ID, input,\n\t\t\tT4_FEATURE_REPORT_LEN,\n\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to read command (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (read_flag) {\n\t\treadbuf = kzalloc(T4_FEATURE_REPORT_LEN, GFP_KERNEL);\n\t\tif (!readbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = hid_hw_raw_request(hdev, T4_FEATURE_REPORT_ID, readbuf,\n\t\t\t\tT4_FEATURE_REPORT_LEN,\n\t\t\t\tHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"failed read register (%d)\\n\", ret);\n\t\t\tgoto exit_readbuf;\n\t\t}\n\n\t\tret = -EINVAL;\n\n\t\tif (*(u32 *)&readbuf[6] != address) {\n\t\t\tdev_err(&hdev->dev, \"read register address error (%x,%x)\\n\",\n\t\t\t\t*(u32 *)&readbuf[6], address);\n\t\t\tgoto exit_readbuf;\n\t\t}\n\n\t\tif (*(u16 *)&readbuf[10] != 1) {\n\t\t\tdev_err(&hdev->dev, \"read register size error (%x)\\n\",\n\t\t\t\t*(u16 *)&readbuf[10]);\n\t\t\tgoto exit_readbuf;\n\t\t}\n\n\t\tcheck_sum = t4_calc_check_sum(readbuf, 6, 7);\n\t\tif (*(u16 *)&readbuf[13] != check_sum) {\n\t\t\tdev_err(&hdev->dev, \"read register checksum error (%x,%x)\\n\",\n\t\t\t\t*(u16 *)&readbuf[13], check_sum);\n\t\t\tgoto exit_readbuf;\n\t\t}\n\n\t\t*read_val = readbuf[12];\n\t}\n\n\tret = 0;\n\nexit_readbuf:\n\tkfree(readbuf);\nexit:\n\tkfree(input);\n\treturn ret;\n}\n\nstatic int u1_read_write_register(struct hid_device *hdev, u32 address,\n\tu8 *read_val, u8 write_val, bool read_flag)\n{\n\tint ret, i;\n\tu8 check_sum;\n\tu8 *input;\n\tu8 *readbuf;\n\n\tinput = kzalloc(U1_FEATURE_REPORT_LEN, GFP_KERNEL);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput[0] = U1_FEATURE_REPORT_ID;\n\tif (read_flag) {\n\t\tinput[1] = U1_CMD_REGISTER_READ;\n\t\tinput[6] = 0x00;\n\t} else {\n\t\tinput[1] = U1_CMD_REGISTER_WRITE;\n\t\tinput[6] = write_val;\n\t}\n\n\tput_unaligned_le32(address, input + 2);\n\n\t \n\tcheck_sum = U1_FEATURE_REPORT_LEN_ALL;\n\tfor (i = 0; i < U1_FEATURE_REPORT_LEN - 1; i++)\n\t\tcheck_sum += input[i];\n\n\tinput[7] = check_sum;\n\tret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, input,\n\t\t\tU1_FEATURE_REPORT_LEN,\n\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to read command (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (read_flag) {\n\t\treadbuf = kzalloc(U1_FEATURE_REPORT_LEN, GFP_KERNEL);\n\t\tif (!readbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, readbuf,\n\t\t\t\tU1_FEATURE_REPORT_LEN,\n\t\t\t\tHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"failed read register (%d)\\n\", ret);\n\t\t\tkfree(readbuf);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t*read_val = readbuf[6];\n\n\t\tkfree(readbuf);\n\t}\n\n\tret = 0;\n\nexit:\n\tkfree(input);\n\treturn ret;\n}\n\nstatic int t4_raw_event(struct alps_dev *hdata, u8 *data, int size)\n{\n\tunsigned int x, y, z;\n\tint i;\n\tstruct t4_input_report *p_report = (struct t4_input_report *)data;\n\n\tif (!data)\n\t\treturn 0;\n\tfor (i = 0; i < hdata->max_fingers; i++) {\n\t\tx = p_report->contact[i].x_hi << 8 | p_report->contact[i].x_lo;\n\t\ty = p_report->contact[i].y_hi << 8 | p_report->contact[i].y_lo;\n\t\ty = hdata->y_max - y + hdata->y_min;\n\t\tz = (p_report->contact[i].palm < 0x80 &&\n\t\t\tp_report->contact[i].palm > 0) * 62;\n\t\tif (x == 0xffff) {\n\t\t\tx = 0;\n\t\t\ty = 0;\n\t\t\tz = 0;\n\t\t}\n\t\tinput_mt_slot(hdata->input, i);\n\n\t\tinput_mt_report_slot_state(hdata->input,\n\t\t\tMT_TOOL_FINGER, z != 0);\n\n\t\tif (!z)\n\t\t\tcontinue;\n\n\t\tinput_report_abs(hdata->input, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(hdata->input, ABS_MT_POSITION_Y, y);\n\t\tinput_report_abs(hdata->input, ABS_MT_PRESSURE, z);\n\t}\n\tinput_mt_sync_frame(hdata->input);\n\n\tinput_report_key(hdata->input, BTN_LEFT, p_report->button);\n\n\tinput_sync(hdata->input);\n\treturn 1;\n}\n\nstatic int u1_raw_event(struct alps_dev *hdata, u8 *data, int size)\n{\n\tunsigned int x, y, z;\n\tint i;\n\tshort sp_x, sp_y;\n\n\tif (!data)\n\t\treturn 0;\n\tswitch (data[0]) {\n\tcase U1_MOUSE_REPORT_ID:\n\t\tbreak;\n\tcase U1_FEATURE_REPORT_ID:\n\t\tbreak;\n\tcase U1_ABSOLUTE_REPORT_ID:\n\tcase U1_ABSOLUTE_REPORT_ID_SECD:\n\t\tfor (i = 0; i < hdata->max_fingers; i++) {\n\t\t\tu8 *contact = &data[i * 5];\n\n\t\t\tx = get_unaligned_le16(contact + 3);\n\t\t\ty = get_unaligned_le16(contact + 5);\n\t\t\tz = contact[7] & 0x7F;\n\n\t\t\tinput_mt_slot(hdata->input, i);\n\n\t\t\tif (z != 0) {\n\t\t\t\tinput_mt_report_slot_state(hdata->input,\n\t\t\t\t\tMT_TOOL_FINGER, 1);\n\t\t\t\tinput_report_abs(hdata->input,\n\t\t\t\t\tABS_MT_POSITION_X, x);\n\t\t\t\tinput_report_abs(hdata->input,\n\t\t\t\t\tABS_MT_POSITION_Y, y);\n\t\t\t\tinput_report_abs(hdata->input,\n\t\t\t\t\tABS_MT_PRESSURE, z);\n\t\t\t} else {\n\t\t\t\tinput_mt_report_slot_inactive(hdata->input);\n\t\t\t}\n\t\t}\n\n\t\tinput_mt_sync_frame(hdata->input);\n\n\t\tinput_report_key(hdata->input, BTN_LEFT,\n\t\t\tdata[1] & 0x1);\n\t\tinput_report_key(hdata->input, BTN_RIGHT,\n\t\t\t(data[1] & 0x2));\n\t\tinput_report_key(hdata->input, BTN_MIDDLE,\n\t\t\t(data[1] & 0x4));\n\n\t\tinput_sync(hdata->input);\n\n\t\treturn 1;\n\n\tcase U1_SP_ABSOLUTE_REPORT_ID:\n\t\tsp_x = get_unaligned_le16(data+2);\n\t\tsp_y = get_unaligned_le16(data+4);\n\n\t\tsp_x = sp_x / 8;\n\t\tsp_y = sp_y / 8;\n\n\t\tinput_report_rel(hdata->input2, REL_X, sp_x);\n\t\tinput_report_rel(hdata->input2, REL_Y, sp_y);\n\n\t\tinput_report_key(hdata->input2, BTN_LEFT,\n\t\t\tdata[1] & 0x1);\n\t\tinput_report_key(hdata->input2, BTN_RIGHT,\n\t\t\t(data[1] & 0x2));\n\t\tinput_report_key(hdata->input2, BTN_MIDDLE,\n\t\t\t(data[1] & 0x4));\n\n\t\tinput_sync(hdata->input2);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int alps_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tint ret = 0;\n\tstruct alps_dev *hdata = hid_get_drvdata(hdev);\n\n\tswitch (hdev->product) {\n\tcase HID_PRODUCT_ID_T4_BTNLESS:\n\t\tret = t4_raw_event(hdata, data, size);\n\t\tbreak;\n\tdefault:\n\t\tret = u1_raw_event(hdata, data, size);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int __maybe_unused alps_post_reset(struct hid_device *hdev)\n{\n\tint ret = -1;\n\tstruct alps_dev *data = hid_get_drvdata(hdev);\n\n\tswitch (data->dev_type) {\n\tcase T4:\n\t\tret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_1,\n\t\t\tNULL, T4_I2C_ABS, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"failed T4_PRM_FEED_CONFIG_1 (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_4,\n\t\t\tNULL, T4_FEEDCFG4_ADVANCED_ABS_ENABLE, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"failed T4_PRM_FEED_CONFIG_4 (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase U1:\n\t\tret = u1_read_write_register(hdev,\n\t\t\tADDRESS_U1_DEV_CTRL_1, NULL,\n\t\t\tU1_TP_ABS_MODE | U1_SP_ABS_MODE, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"failed to change TP mode (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int __maybe_unused alps_post_resume(struct hid_device *hdev)\n{\n\treturn alps_post_reset(hdev);\n}\n\nstatic int u1_init(struct hid_device *hdev, struct alps_dev *pri_data)\n{\n\tint ret;\n\tu8 tmp, dev_ctrl, sen_line_num_x, sen_line_num_y;\n\tu8 pitch_x, pitch_y, resolution;\n\n\t \n\tret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\n\t\t\t&dev_ctrl, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed U1_DEV_CTRL_1 (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tdev_ctrl &= ~U1_DISABLE_DEV;\n\tdev_ctrl |= U1_TP_ABS_MODE;\n\tret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\n\t\t\tNULL, dev_ctrl, false);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to change TP mode (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_X,\n\t\t\t&sen_line_num_x, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed U1_NUM_SENS_X (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_Y,\n\t\t\t&sen_line_num_y, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed U1_NUM_SENS_Y (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_X,\n\t\t\t&pitch_x, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed U1_PITCH_SENS_X (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_Y,\n\t\t\t&pitch_y, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed U1_PITCH_SENS_Y (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_RESO_DWN_ABS,\n\t\t&resolution, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed U1_RESO_DWN_ABS (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\tpri_data->x_active_len_mm =\n\t\t(pitch_x * (sen_line_num_x - 1)) / 10;\n\tpri_data->y_active_len_mm =\n\t\t(pitch_y * (sen_line_num_y - 1)) / 10;\n\n\tpri_data->x_max =\n\t\t(resolution << 2) * (sen_line_num_x - 1);\n\tpri_data->x_min = 1;\n\tpri_data->y_max =\n\t\t(resolution << 2) * (sen_line_num_y - 1);\n\tpri_data->y_min = 1;\n\n\tret = u1_read_write_register(hdev, ADDRESS_U1_PAD_BTN,\n\t\t\t&tmp, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed U1_PAD_BTN (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\tif ((tmp & 0x0F) == (tmp & 0xF0) >> 4) {\n\t\tpri_data->btn_cnt = (tmp & 0x0F);\n\t} else {\n\t\t \n\t\tpri_data->btn_cnt = 1;\n\t}\n\n\tpri_data->has_sp = 0;\n\t \n\tret = u1_read_write_register(hdev, ADDRESS_U1_DEVICE_TYP,\n\t\t\t&tmp, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed U1_DEVICE_TYP (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\tif (tmp & U1_DEVTYPE_SP_SUPPORT) {\n\t\tdev_ctrl |= U1_SP_ABS_MODE;\n\t\tret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\n\t\t\tNULL, dev_ctrl, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"failed SP mode (%d)\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = u1_read_write_register(hdev, ADDRESS_U1_SP_BTN,\n\t\t\t&pri_data->sp_btn_info, 0, true);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"failed U1_SP_BTN (%d)\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\t\tpri_data->has_sp = 1;\n\t}\n\tpri_data->max_fingers = 5;\nexit:\n\treturn ret;\n}\n\nstatic int T4_init(struct hid_device *hdev, struct alps_dev *pri_data)\n{\n\tint ret;\n\tu8 tmp, sen_line_num_x, sen_line_num_y;\n\n\tret = t4_read_write_register(hdev, T4_PRM_ID_CONFIG_3, &tmp, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed T4_PRM_ID_CONFIG_3 (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\tsen_line_num_x = 16 + ((tmp & 0x0F)  | (tmp & 0x08 ? 0xF0 : 0));\n\tsen_line_num_y = 12 + (((tmp & 0xF0) >> 4)  | (tmp & 0x80 ? 0xF0 : 0));\n\n\tpri_data->x_max = sen_line_num_x * T4_COUNT_PER_ELECTRODE;\n\tpri_data->x_min = T4_COUNT_PER_ELECTRODE;\n\tpri_data->y_max = sen_line_num_y * T4_COUNT_PER_ELECTRODE;\n\tpri_data->y_min = T4_COUNT_PER_ELECTRODE;\n\tpri_data->x_active_len_mm = pri_data->y_active_len_mm = 0;\n\tpri_data->btn_cnt = 1;\n\n\tret = t4_read_write_register(hdev, PRM_SYS_CONFIG_1, &tmp, 0, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed PRM_SYS_CONFIG_1 (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\ttmp |= 0x02;\n\tret = t4_read_write_register(hdev, PRM_SYS_CONFIG_1, NULL, tmp, false);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed PRM_SYS_CONFIG_1 (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_1,\n\t\t\t\t\tNULL, T4_I2C_ABS, false);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed T4_PRM_FEED_CONFIG_1 (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = t4_read_write_register(hdev, T4_PRM_FEED_CONFIG_4, NULL,\n\t\t\t\tT4_FEEDCFG4_ADVANCED_ABS_ENABLE, false);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed T4_PRM_FEED_CONFIG_4 (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\tpri_data->max_fingers = 5;\n\tpri_data->has_sp = 0;\nexit:\n\treturn ret;\n}\n\nstatic int alps_sp_open(struct input_dev *dev)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\n\treturn hid_hw_open(hid);\n}\n\nstatic void alps_sp_close(struct input_dev *dev)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\n\thid_hw_close(hid);\n}\n\nstatic int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)\n{\n\tstruct alps_dev *data = hid_get_drvdata(hdev);\n\tstruct input_dev *input = hi->input, *input2;\n\tint ret;\n\tint res_x, res_y, i;\n\n\tdata->input = input;\n\n\thid_dbg(hdev, \"Opening low level driver\\n\");\n\tret = hid_hw_open(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\thid_device_io_start(hdev);\n\tswitch (data->dev_type) {\n\tcase T4:\n\t\tret = T4_init(hdev, data);\n\t\tbreak;\n\tcase U1:\n\t\tret = u1_init(hdev, data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tgoto exit;\n\n\t__set_bit(EV_ABS, input->evbit);\n\tinput_set_abs_params(input, ABS_MT_POSITION_X,\n\t\t\t\t\t\tdata->x_min, data->x_max, 0, 0);\n\tinput_set_abs_params(input, ABS_MT_POSITION_Y,\n\t\t\t\t\t\tdata->y_min, data->y_max, 0, 0);\n\n\tif (data->x_active_len_mm && data->y_active_len_mm) {\n\t\tres_x = (data->x_max - 1) / data->x_active_len_mm;\n\t\tres_y = (data->y_max - 1) / data->y_active_len_mm;\n\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_X, res_x);\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_Y, res_y);\n\t}\n\n\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, 64, 0, 0);\n\n\tinput_mt_init_slots(input, data->max_fingers, INPUT_MT_POINTER);\n\n\t__set_bit(EV_KEY, input->evbit);\n\n\tif (data->btn_cnt == 1)\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\n\tfor (i = 0; i < data->btn_cnt; i++)\n\t\t__set_bit(BTN_LEFT + i, input->keybit);\n\n\t \n\tif (data->has_sp) {\n\t\tinput2 = input_allocate_device();\n\t\tif (!input2) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tdata->input2 = input2;\n\t\tinput2->phys = input->phys;\n\t\tinput2->name = \"DualPoint Stick\";\n\t\tinput2->id.bustype = BUS_I2C;\n\t\tinput2->id.vendor  = input->id.vendor;\n\t\tinput2->id.product = input->id.product;\n\t\tinput2->id.version = input->id.version;\n\t\tinput2->dev.parent = input->dev.parent;\n\n\t\tinput_set_drvdata(input2, hdev);\n\t\tinput2->open = alps_sp_open;\n\t\tinput2->close = alps_sp_close;\n\n\t\t__set_bit(EV_KEY, input2->evbit);\n\t\tdata->sp_btn_cnt = (data->sp_btn_info & 0x0F);\n\t\tfor (i = 0; i < data->sp_btn_cnt; i++)\n\t\t\t__set_bit(BTN_LEFT + i, input2->keybit);\n\n\t\t__set_bit(EV_REL, input2->evbit);\n\t\t__set_bit(REL_X, input2->relbit);\n\t\t__set_bit(REL_Y, input2->relbit);\n\t\t__set_bit(INPUT_PROP_POINTER, input2->propbit);\n\t\t__set_bit(INPUT_PROP_POINTING_STICK, input2->propbit);\n\n\t\tif (input_register_device(data->input2)) {\n\t\t\tinput_free_device(input2);\n\t\t\tret = -ENOENT;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\thid_device_io_stop(hdev);\n\thid_hw_close(hdev);\n\treturn ret;\n}\n\nstatic int alps_input_mapping(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\treturn -1;\n}\n\nstatic int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct alps_dev *data = NULL;\n\tint ret;\n\tdata = devm_kzalloc(&hdev->dev, sizeof(struct alps_dev), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->hdev = hdev;\n\thid_set_drvdata(hdev, data);\n\n\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (hdev->product) {\n\tcase HID_DEVICE_ID_ALPS_T4_BTNLESS:\n\t\tdata->dev_type = T4;\n\t\tbreak;\n\tcase HID_DEVICE_ID_ALPS_U1_DUAL:\n\tcase HID_DEVICE_ID_ALPS_U1:\n\tcase HID_DEVICE_ID_ALPS_U1_UNICORN_LEGACY:\n\t\tdata->dev_type = U1;\n\t\tbreak;\n\tdefault:\n\t\tdata->dev_type = UNKNOWN;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id alps_id[] = {\n\t{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,\n\t\tUSB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_U1_DUAL) },\n\t{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,\n\t\tUSB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_U1) },\n\t{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,\n\t\tUSB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_U1_UNICORN_LEGACY) },\n\t{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,\n\t\tUSB_VENDOR_ID_ALPS_JP, HID_DEVICE_ID_ALPS_T4_BTNLESS) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, alps_id);\n\nstatic struct hid_driver alps_driver = {\n\t.name = \"hid-alps\",\n\t.id_table\t\t= alps_id,\n\t.probe\t\t\t= alps_probe,\n\t.raw_event\t\t= alps_raw_event,\n\t.input_mapping\t\t= alps_input_mapping,\n\t.input_configured\t= alps_input_configured,\n#ifdef CONFIG_PM\n\t.resume\t\t\t= alps_post_resume,\n\t.reset_resume\t\t= alps_post_reset,\n#endif\n};\n\nmodule_hid_driver(alps_driver);\n\nMODULE_AUTHOR(\"Masaki Ota <masaki.ota@jp.alps.com>\");\nMODULE_DESCRIPTION(\"ALPS HID driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}