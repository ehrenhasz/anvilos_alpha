{
  "module_name": "hid-icade.c",
  "hash_id": "49aef5fe1c4447568d7f450b8e623b0637f63e3328195f9b0967ab542799bf8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-icade.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n \n\n \n\n#define ICADE_MAX_USAGE 29\n\nstruct icade_key {\n\tu16 to;\n\tu8 press:1;\n};\n\nstatic const struct icade_key icade_usage_table[30] = {\n\t[26] = { KEY_UP, 1 },\n\t[8] = { KEY_UP, 0 },\n\t[7] = { KEY_RIGHT, 1 },\n\t[6] = { KEY_RIGHT, 0 },\n\t[27] = { KEY_DOWN, 1 },\n\t[29] = { KEY_DOWN, 0 },\n\t[4] = { KEY_LEFT, 1 },\n\t[20] = { KEY_LEFT, 0 },\n\t[28] = { BTN_A, 1 },\n\t[23] = { BTN_A, 0 },\n\t[11] = { BTN_B, 1 },\n\t[21] = { BTN_B, 0 },\n\t[24] = { BTN_C, 1 },\n\t[9] = { BTN_C, 0 },\n\t[13] = { BTN_X, 1 },\n\t[17] = { BTN_X, 0 },\n\t[12] = { BTN_Y, 1 },\n\t[16] = { BTN_Y, 0 },\n\t[14] = { BTN_Z, 1 },\n\t[19] = { BTN_Z, 0 },\n\t[18] = { BTN_THUMBL, 1 },\n\t[10] = { BTN_THUMBL, 0 },\n\t[15] = { BTN_THUMBR, 1 },\n\t[25] = { BTN_THUMBR, 0 },\n};\n\nstatic const struct icade_key *icade_find_translation(u16 from)\n{\n\tif (from > ICADE_MAX_USAGE)\n\t\treturn NULL;\n\treturn &icade_usage_table[from];\n}\n\nstatic int icade_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tconst struct icade_key *trans;\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput ||\n\t\t\t!usage->type)\n\t\treturn 0;\n\n\t \n\tif (!value)\n\t\treturn 1;\n\n\ttrans = icade_find_translation(usage->hid & HID_USAGE);\n\n\tif (!trans)\n\t\treturn 1;\n\n\tinput_event(field->hidinput->input, usage->type,\n\t\t\ttrans->to, trans->press);\n\n\treturn 1;\n}\n\nstatic int icade_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tconst struct icade_key *trans;\n\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_KEYBOARD) {\n\t\ttrans = icade_find_translation(usage->hid & HID_USAGE);\n\n\t\tif (!trans)\n\t\t\treturn -1;\n\n\t\thid_map_usage(hi, usage, bit, max, EV_KEY, trans->to);\n\t\tset_bit(trans->to, hi->input->keybit);\n\n\t\treturn 1;\n\t}\n\n\t \n\treturn -1;\n\n}\n\nstatic int icade_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif (usage->type == EV_KEY)\n\t\tset_bit(usage->type, hi->input->evbit);\n\n\treturn -1;\n}\n\nstatic const struct hid_device_id icade_devices[] = {\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ION, USB_DEVICE_ID_ICADE) },\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, icade_devices);\n\nstatic struct hid_driver icade_driver = {\n\t.name = \"icade\",\n\t.id_table = icade_devices,\n\t.event = icade_event,\n\t.input_mapped = icade_input_mapped,\n\t.input_mapping = icade_input_mapping,\n};\nmodule_hid_driver(icade_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bastien Nocera <hadess@hadess.net>\");\nMODULE_DESCRIPTION(\"ION iCade input driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}