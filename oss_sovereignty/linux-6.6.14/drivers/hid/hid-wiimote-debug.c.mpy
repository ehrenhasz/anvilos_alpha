{
  "module_name": "hid-wiimote-debug.c",
  "hash_id": "2166ff6fd1d244c9005423c1e020675203eddaab7669ee04be08cb05c9b8c054",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-wiimote-debug.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include \"hid-wiimote.h\"\n\nstruct wiimote_debug {\n\tstruct wiimote_data *wdata;\n\tstruct dentry *eeprom;\n\tstruct dentry *drm;\n};\n\nstatic ssize_t wiidebug_eeprom_read(struct file *f, char __user *u, size_t s,\n\t\t\t\t\t\t\t\tloff_t *off)\n{\n\tstruct wiimote_debug *dbg = f->private_data;\n\tstruct wiimote_data *wdata = dbg->wdata;\n\tunsigned long flags;\n\tssize_t ret;\n\tchar buf[16];\n\t__u16 size = 0;\n\n\tif (s == 0)\n\t\treturn -EINVAL;\n\tif (*off > 0xffffff)\n\t\treturn 0;\n\tif (s > 16)\n\t\ts = 16;\n\n\tret = wiimote_cmd_acquire(wdata);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.cmd_read_size = s;\n\twdata->state.cmd_read_buf = buf;\n\twiimote_cmd_set(wdata, WIIPROTO_REQ_RMEM, *off & 0xffff);\n\twiiproto_req_reeprom(wdata, *off, s);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tret = wiimote_cmd_wait(wdata);\n\tif (!ret)\n\t\tsize = wdata->state.cmd_read_size;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.cmd_read_buf = NULL;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\twiimote_cmd_release(wdata);\n\n\tif (ret)\n\t\treturn ret;\n\telse if (size == 0)\n\t\treturn -EIO;\n\n\tif (copy_to_user(u, buf, size))\n\t\treturn -EFAULT;\n\n\t*off += size;\n\tret = size;\n\n\treturn ret;\n}\n\nstatic const struct file_operations wiidebug_eeprom_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = wiidebug_eeprom_read,\n\t.llseek = generic_file_llseek,\n};\n\nstatic const char *wiidebug_drmmap[] = {\n\t[WIIPROTO_REQ_NULL] = \"NULL\",\n\t[WIIPROTO_REQ_DRM_K] = \"K\",\n\t[WIIPROTO_REQ_DRM_KA] = \"KA\",\n\t[WIIPROTO_REQ_DRM_KE] = \"KE\",\n\t[WIIPROTO_REQ_DRM_KAI] = \"KAI\",\n\t[WIIPROTO_REQ_DRM_KEE] = \"KEE\",\n\t[WIIPROTO_REQ_DRM_KAE] = \"KAE\",\n\t[WIIPROTO_REQ_DRM_KIE] = \"KIE\",\n\t[WIIPROTO_REQ_DRM_KAIE] = \"KAIE\",\n\t[WIIPROTO_REQ_DRM_E] = \"E\",\n\t[WIIPROTO_REQ_DRM_SKAI1] = \"SKAI1\",\n\t[WIIPROTO_REQ_DRM_SKAI2] = \"SKAI2\",\n\t[WIIPROTO_REQ_MAX] = NULL\n};\n\nstatic int wiidebug_drm_show(struct seq_file *f, void *p)\n{\n\tstruct wiimote_debug *dbg = f->private;\n\tconst char *str = NULL;\n\tunsigned long flags;\n\t__u8 drm;\n\n\tspin_lock_irqsave(&dbg->wdata->state.lock, flags);\n\tdrm = dbg->wdata->state.drm;\n\tspin_unlock_irqrestore(&dbg->wdata->state.lock, flags);\n\n\tif (drm < WIIPROTO_REQ_MAX)\n\t\tstr = wiidebug_drmmap[drm];\n\tif (!str)\n\t\tstr = \"unknown\";\n\n\tseq_printf(f, \"%s\\n\", str);\n\n\treturn 0;\n}\n\nstatic int wiidebug_drm_open(struct inode *i, struct file *f)\n{\n\treturn single_open(f, wiidebug_drm_show, i->i_private);\n}\n\nstatic ssize_t wiidebug_drm_write(struct file *f, const char __user *u,\n\t\t\t\t\t\t\tsize_t s, loff_t *off)\n{\n\tstruct seq_file *sf = f->private_data;\n\tstruct wiimote_debug *dbg = sf->private;\n\tunsigned long flags;\n\tchar buf[16];\n\tssize_t len;\n\tint i;\n\n\tif (s == 0)\n\t\treturn -EINVAL;\n\n\tlen = min((size_t) 15, s);\n\tif (copy_from_user(buf, u, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = 0;\n\n\tfor (i = 0; i < WIIPROTO_REQ_MAX; ++i) {\n\t\tif (!wiidebug_drmmap[i])\n\t\t\tcontinue;\n\t\tif (!strcasecmp(buf, wiidebug_drmmap[i]))\n\t\t\tbreak;\n\t}\n\n\tif (i == WIIPROTO_REQ_MAX)\n\t\ti = simple_strtoul(buf, NULL, 16);\n\n\tspin_lock_irqsave(&dbg->wdata->state.lock, flags);\n\tdbg->wdata->state.flags &= ~WIIPROTO_FLAG_DRM_LOCKED;\n\twiiproto_req_drm(dbg->wdata, (__u8) i);\n\tif (i != WIIPROTO_REQ_NULL)\n\t\tdbg->wdata->state.flags |= WIIPROTO_FLAG_DRM_LOCKED;\n\tspin_unlock_irqrestore(&dbg->wdata->state.lock, flags);\n\n\treturn len;\n}\n\nstatic const struct file_operations wiidebug_drm_fops = {\n\t.owner = THIS_MODULE,\n\t.open = wiidebug_drm_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.write = wiidebug_drm_write,\n\t.release = single_release,\n};\n\nint wiidebug_init(struct wiimote_data *wdata)\n{\n\tstruct wiimote_debug *dbg;\n\tunsigned long flags;\n\n\tdbg = kzalloc(sizeof(*dbg), GFP_KERNEL);\n\tif (!dbg)\n\t\treturn -ENOMEM;\n\n\tdbg->wdata = wdata;\n\n\tdbg->eeprom = debugfs_create_file(\"eeprom\", S_IRUSR,\n\t\tdbg->wdata->hdev->debug_dir, dbg, &wiidebug_eeprom_fops);\n\n\tdbg->drm = debugfs_create_file(\"drm\", S_IRUSR,\n\t\t\tdbg->wdata->hdev->debug_dir, dbg, &wiidebug_drm_fops);\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->debug = dbg;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n\n}\n\nvoid wiidebug_deinit(struct wiimote_data *wdata)\n{\n\tstruct wiimote_debug *dbg = wdata->debug;\n\tunsigned long flags;\n\n\tif (!dbg)\n\t\treturn;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->debug = NULL;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tdebugfs_remove(dbg->drm);\n\tdebugfs_remove(dbg->eeprom);\n\tkfree(dbg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}