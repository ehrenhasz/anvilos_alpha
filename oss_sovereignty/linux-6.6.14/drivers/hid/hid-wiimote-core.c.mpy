{
  "module_name": "hid-wiimote-core.c",
  "hash_id": "6c9d497ddb2f6332b1b04e0bf694fb77262a36bad01fd179f7d6633c250b5ad1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-wiimote-core.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include \"hid-ids.h\"\n#include \"hid-wiimote.h\"\n\n \n\nstatic int wiimote_hid_send(struct hid_device *hdev, __u8 *buffer,\n\t\t\t    size_t count)\n{\n\t__u8 *buf;\n\tint ret;\n\n\tif (!hdev->ll_driver->output_report)\n\t\treturn -ENODEV;\n\n\tbuf = kmemdup(buffer, count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_output_report(hdev, buf, count);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic void wiimote_queue_worker(struct work_struct *work)\n{\n\tstruct wiimote_queue *queue = container_of(work, struct wiimote_queue,\n\t\t\t\t\t\t   worker);\n\tstruct wiimote_data *wdata = container_of(queue, struct wiimote_data,\n\t\t\t\t\t\t  queue);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&wdata->queue.lock, flags);\n\n\twhile (wdata->queue.head != wdata->queue.tail) {\n\t\tspin_unlock_irqrestore(&wdata->queue.lock, flags);\n\t\tret = wiimote_hid_send(wdata->hdev,\n\t\t\t\t wdata->queue.outq[wdata->queue.tail].data,\n\t\t\t\t wdata->queue.outq[wdata->queue.tail].size);\n\t\tif (ret < 0) {\n\t\t\tspin_lock_irqsave(&wdata->state.lock, flags);\n\t\t\twiimote_cmd_abort(wdata);\n\t\t\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\t\t}\n\t\tspin_lock_irqsave(&wdata->queue.lock, flags);\n\n\t\twdata->queue.tail = (wdata->queue.tail + 1) % WIIMOTE_BUFSIZE;\n\t}\n\n\tspin_unlock_irqrestore(&wdata->queue.lock, flags);\n}\n\nstatic void wiimote_queue(struct wiimote_data *wdata, const __u8 *buffer,\n\t\t\t\t\t\t\t\tsize_t count)\n{\n\tunsigned long flags;\n\t__u8 newhead;\n\n\tif (count > HID_MAX_BUFFER_SIZE) {\n\t\thid_warn(wdata->hdev, \"Sending too large output report\\n\");\n\n\t\tspin_lock_irqsave(&wdata->queue.lock, flags);\n\t\tgoto out_error;\n\t}\n\n\t \n\n\tspin_lock_irqsave(&wdata->queue.lock, flags);\n\n\tmemcpy(wdata->queue.outq[wdata->queue.head].data, buffer, count);\n\twdata->queue.outq[wdata->queue.head].size = count;\n\tnewhead = (wdata->queue.head + 1) % WIIMOTE_BUFSIZE;\n\n\tif (wdata->queue.head == wdata->queue.tail) {\n\t\twdata->queue.head = newhead;\n\t\tschedule_work(&wdata->queue.worker);\n\t} else if (newhead != wdata->queue.tail) {\n\t\twdata->queue.head = newhead;\n\t} else {\n\t\thid_warn(wdata->hdev, \"Output queue is full\");\n\t\tgoto out_error;\n\t}\n\n\tgoto out_unlock;\n\nout_error:\n\twiimote_cmd_abort(wdata);\nout_unlock:\n\tspin_unlock_irqrestore(&wdata->queue.lock, flags);\n}\n\n \nstatic inline void wiiproto_keep_rumble(struct wiimote_data *wdata, __u8 *cmd1)\n{\n\tif (wdata->state.flags & WIIPROTO_FLAG_RUMBLE)\n\t\t*cmd1 |= 0x01;\n}\n\nvoid wiiproto_req_rumble(struct wiimote_data *wdata, __u8 rumble)\n{\n\t__u8 cmd[2];\n\n\trumble = !!rumble;\n\tif (rumble == !!(wdata->state.flags & WIIPROTO_FLAG_RUMBLE))\n\t\treturn;\n\n\tif (rumble)\n\t\twdata->state.flags |= WIIPROTO_FLAG_RUMBLE;\n\telse\n\t\twdata->state.flags &= ~WIIPROTO_FLAG_RUMBLE;\n\n\tcmd[0] = WIIPROTO_REQ_RUMBLE;\n\tcmd[1] = 0;\n\n\twiiproto_keep_rumble(wdata, &cmd[1]);\n\twiimote_queue(wdata, cmd, sizeof(cmd));\n}\n\nvoid wiiproto_req_leds(struct wiimote_data *wdata, int leds)\n{\n\t__u8 cmd[2];\n\n\tleds &= WIIPROTO_FLAGS_LEDS;\n\tif ((wdata->state.flags & WIIPROTO_FLAGS_LEDS) == leds)\n\t\treturn;\n\twdata->state.flags = (wdata->state.flags & ~WIIPROTO_FLAGS_LEDS) | leds;\n\n\tcmd[0] = WIIPROTO_REQ_LED;\n\tcmd[1] = 0;\n\n\tif (leds & WIIPROTO_FLAG_LED1)\n\t\tcmd[1] |= 0x10;\n\tif (leds & WIIPROTO_FLAG_LED2)\n\t\tcmd[1] |= 0x20;\n\tif (leds & WIIPROTO_FLAG_LED3)\n\t\tcmd[1] |= 0x40;\n\tif (leds & WIIPROTO_FLAG_LED4)\n\t\tcmd[1] |= 0x80;\n\n\twiiproto_keep_rumble(wdata, &cmd[1]);\n\twiimote_queue(wdata, cmd, sizeof(cmd));\n}\n\n \nstatic __u8 select_drm(struct wiimote_data *wdata)\n{\n\t__u8 ir = wdata->state.flags & WIIPROTO_FLAGS_IR;\n\tbool ext;\n\n\text = (wdata->state.flags & WIIPROTO_FLAG_EXT_USED) ||\n\t      (wdata->state.flags & WIIPROTO_FLAG_MP_USED);\n\n\t \n\tif (wdata->state.devtype == WIIMOTE_DEV_BALANCE_BOARD) {\n\t\tif (ext)\n\t\t\treturn WIIPROTO_REQ_DRM_KEE;\n\t\telse\n\t\t\treturn WIIPROTO_REQ_DRM_K;\n\t}\n\n\tif (ir == WIIPROTO_FLAG_IR_BASIC) {\n\t\tif (wdata->state.flags & WIIPROTO_FLAG_ACCEL) {\n\t\t\t \n\t\t\treturn WIIPROTO_REQ_DRM_KAIE;\n\t\t} else {\n\t\t\treturn WIIPROTO_REQ_DRM_KIE;\n\t\t}\n\t} else if (ir == WIIPROTO_FLAG_IR_EXT) {\n\t\treturn WIIPROTO_REQ_DRM_KAI;\n\t} else if (ir == WIIPROTO_FLAG_IR_FULL) {\n\t\treturn WIIPROTO_REQ_DRM_SKAI1;\n\t} else {\n\t\tif (wdata->state.flags & WIIPROTO_FLAG_ACCEL) {\n\t\t\tif (ext)\n\t\t\t\treturn WIIPROTO_REQ_DRM_KAE;\n\t\t\telse\n\t\t\t\treturn WIIPROTO_REQ_DRM_KA;\n\t\t} else {\n\t\t\tif (ext)\n\t\t\t\treturn WIIPROTO_REQ_DRM_KEE;\n\t\t\telse\n\t\t\t\treturn WIIPROTO_REQ_DRM_K;\n\t\t}\n\t}\n}\n\nvoid wiiproto_req_drm(struct wiimote_data *wdata, __u8 drm)\n{\n\t__u8 cmd[3];\n\n\tif (wdata->state.flags & WIIPROTO_FLAG_DRM_LOCKED)\n\t\tdrm = wdata->state.drm;\n\telse if (drm == WIIPROTO_REQ_NULL)\n\t\tdrm = select_drm(wdata);\n\n\tcmd[0] = WIIPROTO_REQ_DRM;\n\tcmd[1] = 0;\n\tcmd[2] = drm;\n\n\twdata->state.drm = drm;\n\twiiproto_keep_rumble(wdata, &cmd[1]);\n\twiimote_queue(wdata, cmd, sizeof(cmd));\n}\n\nvoid wiiproto_req_status(struct wiimote_data *wdata)\n{\n\t__u8 cmd[2];\n\n\tcmd[0] = WIIPROTO_REQ_SREQ;\n\tcmd[1] = 0;\n\n\twiiproto_keep_rumble(wdata, &cmd[1]);\n\twiimote_queue(wdata, cmd, sizeof(cmd));\n}\n\nvoid wiiproto_req_accel(struct wiimote_data *wdata, __u8 accel)\n{\n\taccel = !!accel;\n\tif (accel == !!(wdata->state.flags & WIIPROTO_FLAG_ACCEL))\n\t\treturn;\n\n\tif (accel)\n\t\twdata->state.flags |= WIIPROTO_FLAG_ACCEL;\n\telse\n\t\twdata->state.flags &= ~WIIPROTO_FLAG_ACCEL;\n\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n}\n\nvoid wiiproto_req_ir1(struct wiimote_data *wdata, __u8 flags)\n{\n\t__u8 cmd[2];\n\n\tcmd[0] = WIIPROTO_REQ_IR1;\n\tcmd[1] = flags;\n\n\twiiproto_keep_rumble(wdata, &cmd[1]);\n\twiimote_queue(wdata, cmd, sizeof(cmd));\n}\n\nvoid wiiproto_req_ir2(struct wiimote_data *wdata, __u8 flags)\n{\n\t__u8 cmd[2];\n\n\tcmd[0] = WIIPROTO_REQ_IR2;\n\tcmd[1] = flags;\n\n\twiiproto_keep_rumble(wdata, &cmd[1]);\n\twiimote_queue(wdata, cmd, sizeof(cmd));\n}\n\n#define wiiproto_req_wreg(wdata, os, buf, sz) \\\n\t\t\twiiproto_req_wmem((wdata), false, (os), (buf), (sz))\n\n#define wiiproto_req_weeprom(wdata, os, buf, sz) \\\n\t\t\twiiproto_req_wmem((wdata), true, (os), (buf), (sz))\n\nstatic void wiiproto_req_wmem(struct wiimote_data *wdata, bool eeprom,\n\t\t\t\t__u32 offset, const __u8 *buf, __u8 size)\n{\n\t__u8 cmd[22];\n\n\tif (size > 16 || size == 0) {\n\t\thid_warn(wdata->hdev, \"Invalid length %d wmem request\\n\", size);\n\t\treturn;\n\t}\n\n\tmemset(cmd, 0, sizeof(cmd));\n\tcmd[0] = WIIPROTO_REQ_WMEM;\n\tcmd[2] = (offset >> 16) & 0xff;\n\tcmd[3] = (offset >> 8) & 0xff;\n\tcmd[4] = offset & 0xff;\n\tcmd[5] = size;\n\tmemcpy(&cmd[6], buf, size);\n\n\tif (!eeprom)\n\t\tcmd[1] |= 0x04;\n\n\twiiproto_keep_rumble(wdata, &cmd[1]);\n\twiimote_queue(wdata, cmd, sizeof(cmd));\n}\n\nvoid wiiproto_req_rmem(struct wiimote_data *wdata, bool eeprom, __u32 offset,\n\t\t\t\t\t\t\t\t__u16 size)\n{\n\t__u8 cmd[7];\n\n\tif (size == 0) {\n\t\thid_warn(wdata->hdev, \"Invalid length %d rmem request\\n\", size);\n\t\treturn;\n\t}\n\n\tcmd[0] = WIIPROTO_REQ_RMEM;\n\tcmd[1] = 0;\n\tcmd[2] = (offset >> 16) & 0xff;\n\tcmd[3] = (offset >> 8) & 0xff;\n\tcmd[4] = offset & 0xff;\n\tcmd[5] = (size >> 8) & 0xff;\n\tcmd[6] = size & 0xff;\n\n\tif (!eeprom)\n\t\tcmd[1] |= 0x04;\n\n\twiiproto_keep_rumble(wdata, &cmd[1]);\n\twiimote_queue(wdata, cmd, sizeof(cmd));\n}\n\n \nint wiimote_cmd_write(struct wiimote_data *wdata, __u32 offset,\n\t\t\t\t\t\tconst __u8 *wmem, __u8 size)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twiimote_cmd_set(wdata, WIIPROTO_REQ_WMEM, 0);\n\twiiproto_req_wreg(wdata, offset, wmem, size);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tret = wiimote_cmd_wait(wdata);\n\tif (!ret && wdata->state.cmd_err)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\n \nssize_t wiimote_cmd_read(struct wiimote_data *wdata, __u32 offset, __u8 *rmem,\n\t\t\t\t\t\t\t\t__u8 size)\n{\n\tunsigned long flags;\n\tssize_t ret;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.cmd_read_size = size;\n\twdata->state.cmd_read_buf = rmem;\n\twiimote_cmd_set(wdata, WIIPROTO_REQ_RMEM, offset & 0xffff);\n\twiiproto_req_rreg(wdata, offset, size);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tret = wiimote_cmd_wait(wdata);\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.cmd_read_buf = NULL;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tif (!ret) {\n\t\tif (wdata->state.cmd_read_size == 0)\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = wdata->state.cmd_read_size;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int wiimote_cmd_init_ext(struct wiimote_data *wdata)\n{\n\t__u8 wmem;\n\tint ret;\n\n\t \n\twmem = 0x55;\n\tret = wiimote_cmd_write(wdata, 0xa400f0, &wmem, sizeof(wmem));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twmem = 0x0;\n\tret = wiimote_cmd_write(wdata, 0xa400fb, &wmem, sizeof(wmem));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic __u8 wiimote_cmd_read_ext(struct wiimote_data *wdata, __u8 *rmem)\n{\n\tint ret;\n\n\t \n\tret = wiimote_cmd_read(wdata, 0xa400fa, rmem, 6);\n\tif (ret != 6)\n\t\treturn WIIMOTE_EXT_NONE;\n\n\thid_dbg(wdata->hdev, \"extension ID: %6phC\\n\", rmem);\n\n\tif (rmem[0] == 0xff && rmem[1] == 0xff && rmem[2] == 0xff &&\n\t    rmem[3] == 0xff && rmem[4] == 0xff && rmem[5] == 0xff)\n\t\treturn WIIMOTE_EXT_NONE;\n\n\tif (rmem[4] == 0x00 && rmem[5] == 0x00)\n\t\treturn WIIMOTE_EXT_NUNCHUK;\n\tif (rmem[4] == 0x01 && rmem[5] == 0x01)\n\t\treturn WIIMOTE_EXT_CLASSIC_CONTROLLER;\n\tif (rmem[4] == 0x04 && rmem[5] == 0x02)\n\t\treturn WIIMOTE_EXT_BALANCE_BOARD;\n\tif (rmem[4] == 0x01 && rmem[5] == 0x20)\n\t\treturn WIIMOTE_EXT_PRO_CONTROLLER;\n\tif (rmem[0] == 0x01 && rmem[1] == 0x00 &&\n\t    rmem[4] == 0x01 && rmem[5] == 0x03)\n\t\treturn WIIMOTE_EXT_DRUMS;\n\tif (rmem[0] == 0x00 && rmem[1] == 0x00 &&\n\t    rmem[4] == 0x01 && rmem[5] == 0x03)\n\t\treturn WIIMOTE_EXT_GUITAR;\n\tif (rmem[0] == 0x03 && rmem[1] == 0x00 &&\n\t    rmem[4] == 0x01 && rmem[5] == 0x03)\n\t\treturn WIIMOTE_EXT_TURNTABLE;\n\n\treturn WIIMOTE_EXT_UNKNOWN;\n}\n\n \nstatic int wiimote_cmd_init_mp(struct wiimote_data *wdata)\n{\n\t__u8 wmem;\n\tint ret;\n\n\t \n\twmem = 0x55;\n\tret = wiimote_cmd_write(wdata, 0xa600f0, &wmem, sizeof(wmem));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twmem = 0x0;\n\tret = wiimote_cmd_write(wdata, 0xa600fb, &wmem, sizeof(wmem));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic bool wiimote_cmd_map_mp(struct wiimote_data *wdata, __u8 exttype)\n{\n\t__u8 wmem;\n\n\t \n\tswitch (exttype) {\n\tcase WIIMOTE_EXT_CLASSIC_CONTROLLER:\n\tcase WIIMOTE_EXT_DRUMS:\n\tcase WIIMOTE_EXT_GUITAR:\n\t\twmem = 0x07;\n\t\tbreak;\n\tcase WIIMOTE_EXT_TURNTABLE:\n\tcase WIIMOTE_EXT_NUNCHUK:\n\t\twmem = 0x05;\n\t\tbreak;\n\tdefault:\n\t\twmem = 0x04;\n\t\tbreak;\n\t}\n\n\treturn wiimote_cmd_write(wdata, 0xa600fe, &wmem, sizeof(wmem));\n}\n\n \nstatic bool wiimote_cmd_read_mp(struct wiimote_data *wdata, __u8 *rmem)\n{\n\tint ret;\n\n\t \n\tret = wiimote_cmd_read(wdata, 0xa600fa, rmem, 6);\n\tif (ret != 6)\n\t\treturn false;\n\n\thid_dbg(wdata->hdev, \"motion plus ID: %6phC\\n\", rmem);\n\n\tif (rmem[5] == 0x05)\n\t\treturn true;\n\n\thid_info(wdata->hdev, \"unknown motion plus ID: %6phC\\n\", rmem);\n\n\treturn false;\n}\n\n \nstatic __u8 wiimote_cmd_read_mp_mapped(struct wiimote_data *wdata)\n{\n\tint ret;\n\t__u8 rmem[6];\n\n\t \n\tret = wiimote_cmd_read(wdata, 0xa400fa, rmem, 6);\n\tif (ret != 6)\n\t\treturn WIIMOTE_MP_NONE;\n\n\thid_dbg(wdata->hdev, \"mapped motion plus ID: %6phC\\n\", rmem);\n\n\tif (rmem[0] == 0xff && rmem[1] == 0xff && rmem[2] == 0xff &&\n\t    rmem[3] == 0xff && rmem[4] == 0xff && rmem[5] == 0xff)\n\t\treturn WIIMOTE_MP_NONE;\n\n\tif (rmem[4] == 0x04 && rmem[5] == 0x05)\n\t\treturn WIIMOTE_MP_SINGLE;\n\telse if (rmem[4] == 0x05 && rmem[5] == 0x05)\n\t\treturn WIIMOTE_MP_PASSTHROUGH_NUNCHUK;\n\telse if (rmem[4] == 0x07 && rmem[5] == 0x05)\n\t\treturn WIIMOTE_MP_PASSTHROUGH_CLASSIC;\n\n\treturn WIIMOTE_MP_UNKNOWN;\n}\n\n \n\nstatic const __u8 * const wiimote_devtype_mods[WIIMOTE_DEV_NUM] = {\n\t[WIIMOTE_DEV_PENDING] = (const __u8[]){\n\t\tWIIMOD_NULL,\n\t},\n\t[WIIMOTE_DEV_UNKNOWN] = (const __u8[]){\n\t\tWIIMOD_NO_MP,\n\t\tWIIMOD_NULL,\n\t},\n\t[WIIMOTE_DEV_GENERIC] = (const __u8[]){\n\t\tWIIMOD_KEYS,\n\t\tWIIMOD_RUMBLE,\n\t\tWIIMOD_BATTERY,\n\t\tWIIMOD_LED1,\n\t\tWIIMOD_LED2,\n\t\tWIIMOD_LED3,\n\t\tWIIMOD_LED4,\n\t\tWIIMOD_ACCEL,\n\t\tWIIMOD_IR,\n\t\tWIIMOD_NULL,\n\t},\n\t[WIIMOTE_DEV_GEN10] = (const __u8[]){\n\t\tWIIMOD_KEYS,\n\t\tWIIMOD_RUMBLE,\n\t\tWIIMOD_BATTERY,\n\t\tWIIMOD_LED1,\n\t\tWIIMOD_LED2,\n\t\tWIIMOD_LED3,\n\t\tWIIMOD_LED4,\n\t\tWIIMOD_ACCEL,\n\t\tWIIMOD_IR,\n\t\tWIIMOD_NULL,\n\t},\n\t[WIIMOTE_DEV_GEN20] = (const __u8[]){\n\t\tWIIMOD_KEYS,\n\t\tWIIMOD_RUMBLE,\n\t\tWIIMOD_BATTERY,\n\t\tWIIMOD_LED1,\n\t\tWIIMOD_LED2,\n\t\tWIIMOD_LED3,\n\t\tWIIMOD_LED4,\n\t\tWIIMOD_ACCEL,\n\t\tWIIMOD_IR,\n\t\tWIIMOD_BUILTIN_MP,\n\t\tWIIMOD_NULL,\n\t},\n\t[WIIMOTE_DEV_BALANCE_BOARD] = (const __u8[]) {\n\t\tWIIMOD_BATTERY,\n\t\tWIIMOD_LED1,\n\t\tWIIMOD_NO_MP,\n\t\tWIIMOD_NULL,\n\t},\n\t[WIIMOTE_DEV_PRO_CONTROLLER] = (const __u8[]) {\n\t\tWIIMOD_BATTERY,\n\t\tWIIMOD_LED1,\n\t\tWIIMOD_LED2,\n\t\tWIIMOD_LED3,\n\t\tWIIMOD_LED4,\n\t\tWIIMOD_NO_MP,\n\t\tWIIMOD_NULL,\n\t},\n};\n\nstatic void wiimote_modules_load(struct wiimote_data *wdata,\n\t\t\t\t unsigned int devtype)\n{\n\tbool need_input = false;\n\tconst __u8 *mods, *iter;\n\tconst struct wiimod_ops *ops;\n\tint ret;\n\n\tmods = wiimote_devtype_mods[devtype];\n\n\tfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\n\t\tif (wiimod_table[*iter]->flags & WIIMOD_FLAG_INPUT) {\n\t\t\tneed_input = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (need_input) {\n\t\twdata->input = input_allocate_device();\n\t\tif (!wdata->input)\n\t\t\treturn;\n\n\t\tinput_set_drvdata(wdata->input, wdata);\n\t\twdata->input->dev.parent = &wdata->hdev->dev;\n\t\twdata->input->id.bustype = wdata->hdev->bus;\n\t\twdata->input->id.vendor = wdata->hdev->vendor;\n\t\twdata->input->id.product = wdata->hdev->product;\n\t\twdata->input->id.version = wdata->hdev->version;\n\t\twdata->input->name = WIIMOTE_NAME;\n\t}\n\n\tfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\n\t\tops = wiimod_table[*iter];\n\t\tif (!ops->probe)\n\t\t\tcontinue;\n\n\t\tret = ops->probe(ops, wdata);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (wdata->input) {\n\t\tret = input_register_device(wdata->input);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tspin_lock_irq(&wdata->state.lock);\n\twdata->state.devtype = devtype;\n\tspin_unlock_irq(&wdata->state.lock);\n\treturn;\n\nerror:\n\tfor ( ; iter-- != mods; ) {\n\t\tops = wiimod_table[*iter];\n\t\tif (ops->remove)\n\t\t\tops->remove(ops, wdata);\n\t}\n\n\tif (wdata->input) {\n\t\tinput_free_device(wdata->input);\n\t\twdata->input = NULL;\n\t}\n}\n\nstatic void wiimote_modules_unload(struct wiimote_data *wdata)\n{\n\tconst __u8 *mods, *iter;\n\tconst struct wiimod_ops *ops;\n\tunsigned long flags;\n\n\tmods = wiimote_devtype_mods[wdata->state.devtype];\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.devtype = WIIMOTE_DEV_UNKNOWN;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\t \n\tfor (iter = mods; *iter != WIIMOD_NULL; ++iter)\n\t\t  ;\n\n\tif (wdata->input) {\n\t\tinput_get_device(wdata->input);\n\t\tinput_unregister_device(wdata->input);\n\t}\n\n\tfor ( ; iter-- != mods; ) {\n\t\tops = wiimod_table[*iter];\n\t\tif (ops->remove)\n\t\t\tops->remove(ops, wdata);\n\t}\n\n\tif (wdata->input) {\n\t\tinput_put_device(wdata->input);\n\t\twdata->input = NULL;\n\t}\n}\n\n \n\nstatic void wiimote_ext_load(struct wiimote_data *wdata, unsigned int ext)\n{\n\tunsigned long flags;\n\tconst struct wiimod_ops *ops;\n\tint ret;\n\n\tops = wiimod_ext_table[ext];\n\n\tif (ops->probe) {\n\t\tret = ops->probe(ops, wdata);\n\t\tif (ret)\n\t\t\text = WIIMOTE_EXT_UNKNOWN;\n\t}\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.exttype = ext;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic void wiimote_ext_unload(struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\tconst struct wiimod_ops *ops;\n\n\tops = wiimod_ext_table[wdata->state.exttype];\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.exttype = WIIMOTE_EXT_UNKNOWN;\n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tif (ops->remove)\n\t\tops->remove(ops, wdata);\n}\n\nstatic void wiimote_mp_load(struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\tconst struct wiimod_ops *ops;\n\tint ret;\n\t__u8 mode = 2;\n\n\tops = &wiimod_mp;\n\tif (ops->probe) {\n\t\tret = ops->probe(ops, wdata);\n\t\tif (ret)\n\t\t\tmode = 1;\n\t}\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.mp = mode;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic void wiimote_mp_unload(struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\tconst struct wiimod_ops *ops;\n\n\tif (wdata->state.mp < 2)\n\t\treturn;\n\n\tops = &wiimod_mp;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.mp = 0;\n\twdata->state.flags &= ~WIIPROTO_FLAG_MP_USED;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tif (ops->remove)\n\t\tops->remove(ops, wdata);\n}\n\n \n\nstatic const char *wiimote_devtype_names[WIIMOTE_DEV_NUM] = {\n\t[WIIMOTE_DEV_PENDING] = \"Pending\",\n\t[WIIMOTE_DEV_UNKNOWN] = \"Unknown\",\n\t[WIIMOTE_DEV_GENERIC] = \"Generic\",\n\t[WIIMOTE_DEV_GEN10] = \"Nintendo Wii Remote (Gen 1)\",\n\t[WIIMOTE_DEV_GEN20] = \"Nintendo Wii Remote Plus (Gen 2)\",\n\t[WIIMOTE_DEV_BALANCE_BOARD] = \"Nintendo Wii Balance Board\",\n\t[WIIMOTE_DEV_PRO_CONTROLLER] = \"Nintendo Wii U Pro Controller\",\n};\n\n \nstatic void wiimote_init_set_type(struct wiimote_data *wdata,\n\t\t\t\t  __u8 exttype)\n{\n\t__u8 devtype = WIIMOTE_DEV_GENERIC;\n\t__u16 vendor, product;\n\tconst char *name;\n\n\tvendor = wdata->hdev->vendor;\n\tproduct = wdata->hdev->product;\n\tname = wdata->hdev->name;\n\n\tif (exttype == WIIMOTE_EXT_BALANCE_BOARD) {\n\t\tdevtype = WIIMOTE_DEV_BALANCE_BOARD;\n\t\tgoto done;\n\t} else if (exttype == WIIMOTE_EXT_PRO_CONTROLLER) {\n\t\tdevtype = WIIMOTE_DEV_PRO_CONTROLLER;\n\t\tgoto done;\n\t}\n\n\tif (!strcmp(name, \"Nintendo RVL-CNT-01\")) {\n\t\tdevtype = WIIMOTE_DEV_GEN10;\n\t\tgoto done;\n\t} else if (!strcmp(name, \"Nintendo RVL-CNT-01-TR\")) {\n\t\tdevtype = WIIMOTE_DEV_GEN20;\n\t\tgoto done;\n\t} else if (!strcmp(name, \"Nintendo RVL-WBC-01\")) {\n\t\tdevtype = WIIMOTE_DEV_BALANCE_BOARD;\n\t\tgoto done;\n\t} else if (!strcmp(name, \"Nintendo RVL-CNT-01-UC\")) {\n\t\tdevtype = WIIMOTE_DEV_PRO_CONTROLLER;\n\t\tgoto done;\n\t}\n\n\tif (vendor == USB_VENDOR_ID_NINTENDO) {\n\t\tif (product == USB_DEVICE_ID_NINTENDO_WIIMOTE) {\n\t\t\tdevtype = WIIMOTE_DEV_GEN10;\n\t\t\tgoto done;\n\t\t} else if (product == USB_DEVICE_ID_NINTENDO_WIIMOTE2) {\n\t\t\tdevtype = WIIMOTE_DEV_GEN20;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tif (devtype == WIIMOTE_DEV_GENERIC)\n\t\thid_info(wdata->hdev, \"cannot detect device; NAME: %s VID: %04x PID: %04x EXT: %04x\\n\",\n\t\t\tname, vendor, product, exttype);\n\telse\n\t\thid_info(wdata->hdev, \"detected device: %s\\n\",\n\t\t\t wiimote_devtype_names[devtype]);\n\n\twiimote_modules_load(wdata, devtype);\n}\n\nstatic void wiimote_init_detect(struct wiimote_data *wdata)\n{\n\t__u8 exttype = WIIMOTE_EXT_NONE, extdata[6];\n\tbool ext;\n\tint ret;\n\n\twiimote_cmd_acquire_noint(wdata);\n\n\tspin_lock_irq(&wdata->state.lock);\n\twdata->state.devtype = WIIMOTE_DEV_UNKNOWN;\n\twiimote_cmd_set(wdata, WIIPROTO_REQ_SREQ, 0);\n\twiiproto_req_status(wdata);\n\tspin_unlock_irq(&wdata->state.lock);\n\n\tret = wiimote_cmd_wait_noint(wdata);\n\tif (ret)\n\t\tgoto out_release;\n\n\tspin_lock_irq(&wdata->state.lock);\n\text = wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED;\n\tspin_unlock_irq(&wdata->state.lock);\n\n\tif (!ext)\n\t\tgoto out_release;\n\n\twiimote_cmd_init_ext(wdata);\n\texttype = wiimote_cmd_read_ext(wdata, extdata);\n\nout_release:\n\twiimote_cmd_release(wdata);\n\twiimote_init_set_type(wdata, exttype);\n\n\t \n\tspin_lock_irq(&wdata->state.lock);\n\tif (!(wdata->state.flags & WIIPROTO_FLAG_BUILTIN_MP) &&\n\t    !(wdata->state.flags & WIIPROTO_FLAG_NO_MP))\n\t\tmod_timer(&wdata->timer, jiffies + HZ * 4);\n\tspin_unlock_irq(&wdata->state.lock);\n}\n\n \nstatic void wiimote_init_poll_mp(struct wiimote_data *wdata)\n{\n\tbool mp;\n\t__u8 mpdata[6];\n\n\twiimote_cmd_acquire_noint(wdata);\n\twiimote_cmd_init_mp(wdata);\n\tmp = wiimote_cmd_read_mp(wdata, mpdata);\n\twiimote_cmd_release(wdata);\n\n\t \n\tif (mp) {\n\t\tif (!wdata->state.mp) {\n\t\t\thid_info(wdata->hdev, \"detected extension: Nintendo Wii Motion Plus\\n\");\n\t\t\twiimote_mp_load(wdata);\n\t\t}\n\t} else if (wdata->state.mp) {\n\t\twiimote_mp_unload(wdata);\n\t}\n\n\tmod_timer(&wdata->timer, jiffies + HZ * 4);\n}\n\n \nstatic bool wiimote_init_check(struct wiimote_data *wdata)\n{\n\t__u32 flags;\n\t__u8 type, data[6];\n\tbool ret, poll_mp;\n\n\tspin_lock_irq(&wdata->state.lock);\n\tflags = wdata->state.flags;\n\tspin_unlock_irq(&wdata->state.lock);\n\n\twiimote_cmd_acquire_noint(wdata);\n\n\t \n\tif (wdata->state.exttype == WIIMOTE_EXT_NONE &&\n\t    wdata->state.mp > 0 && (flags & WIIPROTO_FLAG_MP_USED)) {\n\t\ttype = wiimote_cmd_read_mp_mapped(wdata);\n\t\tret = type == WIIMOTE_MP_SINGLE;\n\n\t\tspin_lock_irq(&wdata->state.lock);\n\t\tret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);\n\t\tret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_PLUGGED);\n\t\tret = ret && (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);\n\t\tspin_unlock_irq(&wdata->state.lock);\n\n\t\tif (!ret)\n\t\t\thid_dbg(wdata->hdev, \"state left: !EXT && MP\\n\");\n\n\t\t \n\t\tpoll_mp = false;\n\n\t\tgoto out_release;\n\t}\n\n\t \n\tif (!(flags & WIIPROTO_FLAG_MP_USED) &&\n\t    wdata->state.exttype != WIIMOTE_EXT_NONE) {\n\t\ttype = wiimote_cmd_read_ext(wdata, data);\n\t\tret = type == wdata->state.exttype;\n\n\t\tspin_lock_irq(&wdata->state.lock);\n\t\tret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);\n\t\tret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);\n\t\tspin_unlock_irq(&wdata->state.lock);\n\n\t\tif (!ret)\n\t\t\thid_dbg(wdata->hdev, \"state left: EXT && !MP\\n\");\n\n\t\t \n\t\tpoll_mp = true;\n\n\t\tgoto out_release;\n\t}\n\n\t \n\tif (!(flags & WIIPROTO_FLAG_MP_USED) &&\n\t    wdata->state.exttype == WIIMOTE_EXT_NONE) {\n\t\ttype = wiimote_cmd_read_ext(wdata, data);\n\t\tret = type == wdata->state.exttype;\n\n\t\tspin_lock_irq(&wdata->state.lock);\n\t\tret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);\n\t\tret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);\n\t\tret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED);\n\t\tspin_unlock_irq(&wdata->state.lock);\n\n\t\tif (!ret)\n\t\t\thid_dbg(wdata->hdev, \"state left: !EXT && !MP\\n\");\n\n\t\t \n\t\tpoll_mp = true;\n\n\t\tgoto out_release;\n\t}\n\n\t \n\tif (wdata->state.exttype != WIIMOTE_EXT_NONE &&\n\t    wdata->state.mp > 0 && (flags & WIIPROTO_FLAG_MP_USED)) {\n\t\ttype = wiimote_cmd_read_mp_mapped(wdata);\n\t\tret = type != WIIMOTE_MP_NONE;\n\t\tret = ret && type != WIIMOTE_MP_UNKNOWN;\n\t\tret = ret && type != WIIMOTE_MP_SINGLE;\n\n\t\tspin_lock_irq(&wdata->state.lock);\n\t\tret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED);\n\t\tret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);\n\t\tret = ret && (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);\n\t\tspin_unlock_irq(&wdata->state.lock);\n\n\t\tif (!ret)\n\t\t\thid_dbg(wdata->hdev, \"state left: EXT && MP\\n\");\n\n\t\t \n\t\tpoll_mp = false;\n\n\t\tgoto out_release;\n\t}\n\n\t \n\tret = false;\n\nout_release:\n\twiimote_cmd_release(wdata);\n\n\t \n\tif (ret && poll_mp && !(flags & WIIPROTO_FLAG_BUILTIN_MP) &&\n\t    !(flags & WIIPROTO_FLAG_NO_MP))\n\t\twiimote_init_poll_mp(wdata);\n\n\treturn ret;\n}\n\nstatic const char *wiimote_exttype_names[WIIMOTE_EXT_NUM] = {\n\t[WIIMOTE_EXT_NONE] = \"None\",\n\t[WIIMOTE_EXT_UNKNOWN] = \"Unknown\",\n\t[WIIMOTE_EXT_NUNCHUK] = \"Nintendo Wii Nunchuk\",\n\t[WIIMOTE_EXT_CLASSIC_CONTROLLER] = \"Nintendo Wii Classic Controller\",\n\t[WIIMOTE_EXT_BALANCE_BOARD] = \"Nintendo Wii Balance Board\",\n\t[WIIMOTE_EXT_PRO_CONTROLLER] = \"Nintendo Wii U Pro Controller\",\n\t[WIIMOTE_EXT_DRUMS] = \"Nintendo Wii Drums\",\n\t[WIIMOTE_EXT_GUITAR] = \"Nintendo Wii Guitar\",\n\t[WIIMOTE_EXT_TURNTABLE] = \"Nintendo Wii Turntable\"\n};\n\n \nstatic void wiimote_init_hotplug(struct wiimote_data *wdata)\n{\n\t__u8 exttype, extdata[6], mpdata[6];\n\t__u32 flags;\n\tbool mp;\n\n\thid_dbg(wdata->hdev, \"detect extensions..\\n\");\n\n\twiimote_cmd_acquire_noint(wdata);\n\n\tspin_lock_irq(&wdata->state.lock);\n\n\t \n\tflags = wdata->state.flags;\n\n\t \n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_ACTIVE;\n\twdata->state.flags &= ~WIIPROTO_FLAG_MP_ACTIVE;\n\n\tspin_unlock_irq(&wdata->state.lock);\n\n\t \n\twiimote_cmd_init_ext(wdata);\n\tif (flags & WIIPROTO_FLAG_NO_MP) {\n\t\tmp = false;\n\t} else {\n\t\twiimote_cmd_init_mp(wdata);\n\t\tmp = wiimote_cmd_read_mp(wdata, mpdata);\n\t}\n\texttype = wiimote_cmd_read_ext(wdata, extdata);\n\n\twiimote_cmd_release(wdata);\n\n\t \n\tif (exttype != wdata->state.exttype) {\n\t\t \n\t\twiimote_ext_unload(wdata);\n\n\t\tif (exttype == WIIMOTE_EXT_UNKNOWN) {\n\t\t\thid_info(wdata->hdev, \"cannot detect extension; %6phC\\n\",\n\t\t\t\t extdata);\n\t\t} else if (exttype == WIIMOTE_EXT_NONE) {\n\t\t\tspin_lock_irq(&wdata->state.lock);\n\t\t\twdata->state.exttype = WIIMOTE_EXT_NONE;\n\t\t\tspin_unlock_irq(&wdata->state.lock);\n\t\t} else {\n\t\t\thid_info(wdata->hdev, \"detected extension: %s\\n\",\n\t\t\t\t wiimote_exttype_names[exttype]);\n\t\t\t \n\t\t\twiimote_ext_load(wdata, exttype);\n\t\t}\n\t}\n\n\t \n\tif (mp) {\n\t\tif (!wdata->state.mp) {\n\t\t\thid_info(wdata->hdev, \"detected extension: Nintendo Wii Motion Plus\\n\");\n\t\t\twiimote_mp_load(wdata);\n\t\t}\n\t} else if (wdata->state.mp) {\n\t\twiimote_mp_unload(wdata);\n\t}\n\n\t \n\tif (!(flags & WIIPROTO_FLAG_MP_USED))\n\t\tmp = false;\n\n\t \n\tif (mp) {\n\t\twiimote_cmd_acquire_noint(wdata);\n\t\twiimote_cmd_map_mp(wdata, exttype);\n\t\twiimote_cmd_release(wdata);\n\n\t\t \n\t\tdel_timer_sync(&wdata->timer);\n\t} else {\n\t\t \n\t\tif (!(flags & WIIPROTO_FLAG_BUILTIN_MP) &&\n\t\t    !(flags & WIIPROTO_FLAG_NO_MP))\n\t\t\tmod_timer(&wdata->timer, jiffies + HZ * 4);\n\t}\n\n\tspin_lock_irq(&wdata->state.lock);\n\n\t \n\tif (mp) {\n\t\twdata->state.flags |= WIIPROTO_FLAG_MP_ACTIVE;\n\t\tif (wdata->state.exttype == WIIMOTE_EXT_NONE) {\n\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_PLUGGED;\n\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_MP_PLUGGED;\n\t\t} else {\n\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_PLUGGED;\n\t\t\twdata->state.flags |= WIIPROTO_FLAG_MP_PLUGGED;\n\t\t\twdata->state.flags |= WIIPROTO_FLAG_EXT_ACTIVE;\n\t\t}\n\t} else if (wdata->state.exttype != WIIMOTE_EXT_NONE) {\n\t\twdata->state.flags |= WIIPROTO_FLAG_EXT_ACTIVE;\n\t}\n\n\t \n\twiiproto_req_status(wdata);\n\n\tspin_unlock_irq(&wdata->state.lock);\n\n\thid_dbg(wdata->hdev, \"detected extensions: MP: %d EXT: %d\\n\",\n\t\twdata->state.mp, wdata->state.exttype);\n}\n\nstatic void wiimote_init_worker(struct work_struct *work)\n{\n\tstruct wiimote_data *wdata = container_of(work, struct wiimote_data,\n\t\t\t\t\t\t  init_worker);\n\tbool changed = false;\n\n\tif (wdata->state.devtype == WIIMOTE_DEV_PENDING) {\n\t\twiimote_init_detect(wdata);\n\t\tchanged = true;\n\t}\n\n\tif (changed || !wiimote_init_check(wdata))\n\t\twiimote_init_hotplug(wdata);\n\n\tif (changed)\n\t\tkobject_uevent(&wdata->hdev->dev.kobj, KOBJ_CHANGE);\n}\n\nvoid __wiimote_schedule(struct wiimote_data *wdata)\n{\n\tif (!(wdata->state.flags & WIIPROTO_FLAG_EXITING))\n\t\tschedule_work(&wdata->init_worker);\n}\n\nstatic void wiimote_schedule(struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\t__wiimote_schedule(wdata);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic void wiimote_init_timeout(struct timer_list *t)\n{\n\tstruct wiimote_data *wdata = from_timer(wdata, t, timer);\n\n\twiimote_schedule(wdata);\n}\n\n \n\nstatic void handler_keys(struct wiimote_data *wdata, const __u8 *payload)\n{\n\tconst __u8 *iter, *mods;\n\tconst struct wiimod_ops *ops;\n\n\tops = wiimod_ext_table[wdata->state.exttype];\n\tif (ops->in_keys) {\n\t\tops->in_keys(wdata, payload);\n\t\treturn;\n\t}\n\n\tmods = wiimote_devtype_mods[wdata->state.devtype];\n\tfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\n\t\tops = wiimod_table[*iter];\n\t\tif (ops->in_keys) {\n\t\t\tops->in_keys(wdata, payload);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void handler_accel(struct wiimote_data *wdata, const __u8 *payload)\n{\n\tconst __u8 *iter, *mods;\n\tconst struct wiimod_ops *ops;\n\n\tops = wiimod_ext_table[wdata->state.exttype];\n\tif (ops->in_accel) {\n\t\tops->in_accel(wdata, payload);\n\t\treturn;\n\t}\n\n\tmods = wiimote_devtype_mods[wdata->state.devtype];\n\tfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\n\t\tops = wiimod_table[*iter];\n\t\tif (ops->in_accel) {\n\t\t\tops->in_accel(wdata, payload);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic bool valid_ext_handler(const struct wiimod_ops *ops, size_t len)\n{\n\tif (!ops->in_ext)\n\t\treturn false;\n\tif ((ops->flags & WIIMOD_FLAG_EXT8) && len < 8)\n\t\treturn false;\n\tif ((ops->flags & WIIMOD_FLAG_EXT16) && len < 16)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void handler_ext(struct wiimote_data *wdata, const __u8 *payload,\n\t\t\tsize_t len)\n{\n\tstatic const __u8 invalid[21] = { 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t  0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t  0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t  0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t  0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t  0xff };\n\tconst __u8 *iter, *mods;\n\tconst struct wiimod_ops *ops;\n\tbool is_mp;\n\n\tif (len > 21)\n\t\tlen = 21;\n\tif (len < 6 || !memcmp(payload, invalid, len))\n\t\treturn;\n\n\t \n\tif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\n\t\t \n\t\tif (payload[5] & 0x01)\n\t\t\treturn;\n\n\t\tif (payload[4] & 0x01) {\n\t\t\tif (!(wdata->state.flags & WIIPROTO_FLAG_MP_PLUGGED)) {\n\t\t\t\thid_dbg(wdata->hdev, \"MP hotplug: 1\\n\");\n\t\t\t\twdata->state.flags |= WIIPROTO_FLAG_MP_PLUGGED;\n\t\t\t\t__wiimote_schedule(wdata);\n\t\t\t}\n\t\t} else {\n\t\t\tif (wdata->state.flags & WIIPROTO_FLAG_MP_PLUGGED) {\n\t\t\t\thid_dbg(wdata->hdev, \"MP hotplug: 0\\n\");\n\t\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_MP_PLUGGED;\n\t\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_ACTIVE;\n\t\t\t\t__wiimote_schedule(wdata);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tis_mp = payload[5] & 0x02;\n\t} else {\n\t\tis_mp = false;\n\t}\n\n\t \n\tif (!(wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE) && !is_mp)\n\t\treturn;\n\n\t \n\tops = wiimod_ext_table[wdata->state.exttype];\n\tif (is_mp && ops->in_mp) {\n\t\tops->in_mp(wdata, payload);\n\t\treturn;\n\t} else if (!is_mp && valid_ext_handler(ops, len)) {\n\t\tops->in_ext(wdata, payload);\n\t\treturn;\n\t}\n\n\t \n\tops = &wiimod_mp;\n\tif (is_mp && ops->in_mp) {\n\t\tops->in_mp(wdata, payload);\n\t\treturn;\n\t} else if (!is_mp && valid_ext_handler(ops, len)) {\n\t\tops->in_ext(wdata, payload);\n\t\treturn;\n\t}\n\n\t \n\tmods = wiimote_devtype_mods[wdata->state.devtype];\n\tfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\n\t\tops = wiimod_table[*iter];\n\t\tif (is_mp && ops->in_mp) {\n\t\t\tops->in_mp(wdata, payload);\n\t\t\treturn;\n\t\t} else if (!is_mp && valid_ext_handler(ops, len)) {\n\t\t\tops->in_ext(wdata, payload);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#define ir_to_input0(wdata, ir, packed) handler_ir((wdata), (ir), (packed), 0)\n#define ir_to_input1(wdata, ir, packed) handler_ir((wdata), (ir), (packed), 1)\n#define ir_to_input2(wdata, ir, packed) handler_ir((wdata), (ir), (packed), 2)\n#define ir_to_input3(wdata, ir, packed) handler_ir((wdata), (ir), (packed), 3)\n\nstatic void handler_ir(struct wiimote_data *wdata, const __u8 *payload,\n\t\t       bool packed, unsigned int id)\n{\n\tconst __u8 *iter, *mods;\n\tconst struct wiimod_ops *ops;\n\n\tops = wiimod_ext_table[wdata->state.exttype];\n\tif (ops->in_ir) {\n\t\tops->in_ir(wdata, payload, packed, id);\n\t\treturn;\n\t}\n\n\tmods = wiimote_devtype_mods[wdata->state.devtype];\n\tfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\n\t\tops = wiimod_table[*iter];\n\t\tif (ops->in_ir) {\n\t\t\tops->in_ir(wdata, payload, packed, id);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void handler_status_K(struct wiimote_data *wdata,\n\t\t\t     const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\n\t \n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n}\n\n \nstatic void handler_status(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_status_K(wdata, payload);\n\n\t \n\tif (payload[2] & 0x02) {\n\t\tif (!(wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED)) {\n\t\t\thid_dbg(wdata->hdev, \"EXT hotplug: 1\\n\");\n\t\t\twdata->state.flags |= WIIPROTO_FLAG_EXT_PLUGGED;\n\t\t\t__wiimote_schedule(wdata);\n\t\t}\n\t} else {\n\t\tif (wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED) {\n\t\t\thid_dbg(wdata->hdev, \"EXT hotplug: 0\\n\");\n\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_PLUGGED;\n\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_MP_PLUGGED;\n\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_ACTIVE;\n\t\t\twdata->state.flags &= ~WIIPROTO_FLAG_MP_ACTIVE;\n\t\t\t__wiimote_schedule(wdata);\n\t\t}\n\t}\n\n\twdata->state.cmd_battery = payload[5];\n\tif (wiimote_cmd_pending(wdata, WIIPROTO_REQ_SREQ, 0))\n\t\twiimote_cmd_complete(wdata);\n}\n\n \nstatic void handler_generic_K(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n}\n\nstatic void handler_data(struct wiimote_data *wdata, const __u8 *payload)\n{\n\t__u16 offset = payload[3] << 8 | payload[4];\n\t__u8 size = (payload[2] >> 4) + 1;\n\t__u8 err = payload[2] & 0x0f;\n\n\thandler_keys(wdata, payload);\n\n\tif (wiimote_cmd_pending(wdata, WIIPROTO_REQ_RMEM, offset)) {\n\t\tif (err)\n\t\t\tsize = 0;\n\t\telse if (size > wdata->state.cmd_read_size)\n\t\t\tsize = wdata->state.cmd_read_size;\n\n\t\twdata->state.cmd_read_size = size;\n\t\tif (wdata->state.cmd_read_buf)\n\t\t\tmemcpy(wdata->state.cmd_read_buf, &payload[5], size);\n\t\twiimote_cmd_complete(wdata);\n\t}\n}\n\nstatic void handler_return(struct wiimote_data *wdata, const __u8 *payload)\n{\n\t__u8 err = payload[3];\n\t__u8 cmd = payload[2];\n\n\thandler_keys(wdata, payload);\n\n\tif (wiimote_cmd_pending(wdata, cmd, 0)) {\n\t\twdata->state.cmd_err = err;\n\t\twiimote_cmd_complete(wdata);\n\t} else if (err) {\n\t\thid_warn(wdata->hdev, \"Remote error %u on req %u\\n\", err,\n\t\t\t\t\t\t\t\t\tcmd);\n\t}\n}\n\nstatic void handler_drm_KA(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\thandler_accel(wdata, payload);\n}\n\nstatic void handler_drm_KE(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\thandler_ext(wdata, &payload[2], 8);\n}\n\nstatic void handler_drm_KAI(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\thandler_accel(wdata, payload);\n\tir_to_input0(wdata, &payload[5], false);\n\tir_to_input1(wdata, &payload[8], false);\n\tir_to_input2(wdata, &payload[11], false);\n\tir_to_input3(wdata, &payload[14], false);\n}\n\nstatic void handler_drm_KEE(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\thandler_ext(wdata, &payload[2], 19);\n}\n\nstatic void handler_drm_KIE(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\tir_to_input0(wdata, &payload[2], false);\n\tir_to_input1(wdata, &payload[4], true);\n\tir_to_input2(wdata, &payload[7], false);\n\tir_to_input3(wdata, &payload[9], true);\n\thandler_ext(wdata, &payload[12], 9);\n}\n\nstatic void handler_drm_KAE(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\thandler_accel(wdata, payload);\n\thandler_ext(wdata, &payload[5], 16);\n}\n\nstatic void handler_drm_KAIE(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\thandler_accel(wdata, payload);\n\tir_to_input0(wdata, &payload[5], false);\n\tir_to_input1(wdata, &payload[7], true);\n\tir_to_input2(wdata, &payload[10], false);\n\tir_to_input3(wdata, &payload[12], true);\n\thandler_ext(wdata, &payload[15], 6);\n}\n\nstatic void handler_drm_E(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_ext(wdata, payload, 21);\n}\n\nstatic void handler_drm_SKAI1(struct wiimote_data *wdata, const __u8 *payload)\n{\n\thandler_keys(wdata, payload);\n\n\twdata->state.accel_split[0] = payload[2];\n\twdata->state.accel_split[1] = (payload[0] >> 1) & (0x10 | 0x20);\n\twdata->state.accel_split[1] |= (payload[1] << 1) & (0x40 | 0x80);\n\n\tir_to_input0(wdata, &payload[3], false);\n\tir_to_input1(wdata, &payload[12], false);\n}\n\nstatic void handler_drm_SKAI2(struct wiimote_data *wdata, const __u8 *payload)\n{\n\t__u8 buf[5];\n\n\thandler_keys(wdata, payload);\n\n\twdata->state.accel_split[1] |= (payload[0] >> 5) & (0x01 | 0x02);\n\twdata->state.accel_split[1] |= (payload[1] >> 3) & (0x04 | 0x08);\n\n\tbuf[0] = 0;\n\tbuf[1] = 0;\n\tbuf[2] = wdata->state.accel_split[0];\n\tbuf[3] = payload[2];\n\tbuf[4] = wdata->state.accel_split[1];\n\thandler_accel(wdata, buf);\n\n\tir_to_input2(wdata, &payload[3], false);\n\tir_to_input3(wdata, &payload[12], false);\n}\n\nstruct wiiproto_handler {\n\t__u8 id;\n\tsize_t size;\n\tvoid (*func)(struct wiimote_data *wdata, const __u8 *payload);\n};\n\nstatic const struct wiiproto_handler handlers[] = {\n\t{ .id = WIIPROTO_REQ_STATUS, .size = 6, .func = handler_status },\n\t{ .id = WIIPROTO_REQ_STATUS, .size = 2, .func = handler_status_K },\n\t{ .id = WIIPROTO_REQ_DATA, .size = 21, .func = handler_data },\n\t{ .id = WIIPROTO_REQ_DATA, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_RETURN, .size = 4, .func = handler_return },\n\t{ .id = WIIPROTO_REQ_RETURN, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_DRM_K, .size = 2, .func = handler_keys },\n\t{ .id = WIIPROTO_REQ_DRM_KA, .size = 5, .func = handler_drm_KA },\n\t{ .id = WIIPROTO_REQ_DRM_KA, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_DRM_KE, .size = 10, .func = handler_drm_KE },\n\t{ .id = WIIPROTO_REQ_DRM_KE, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_DRM_KAI, .size = 17, .func = handler_drm_KAI },\n\t{ .id = WIIPROTO_REQ_DRM_KAI, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_DRM_KEE, .size = 21, .func = handler_drm_KEE },\n\t{ .id = WIIPROTO_REQ_DRM_KEE, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_DRM_KAE, .size = 21, .func = handler_drm_KAE },\n\t{ .id = WIIPROTO_REQ_DRM_KAE, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_DRM_KIE, .size = 21, .func = handler_drm_KIE },\n\t{ .id = WIIPROTO_REQ_DRM_KIE, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_DRM_KAIE, .size = 21, .func = handler_drm_KAIE },\n\t{ .id = WIIPROTO_REQ_DRM_KAIE, .size = 2, .func = handler_generic_K },\n\t{ .id = WIIPROTO_REQ_DRM_E, .size = 21, .func = handler_drm_E },\n\t{ .id = WIIPROTO_REQ_DRM_SKAI1, .size = 21, .func = handler_drm_SKAI1 },\n\t{ .id = WIIPROTO_REQ_DRM_SKAI2, .size = 21, .func = handler_drm_SKAI2 },\n\t{ .id = 0 }\n};\n\nstatic int wiimote_hid_event(struct hid_device *hdev, struct hid_report *report,\n\t\t\t\t\t\t\tu8 *raw_data, int size)\n{\n\tstruct wiimote_data *wdata = hid_get_drvdata(hdev);\n\tconst struct wiiproto_handler *h;\n\tint i;\n\tunsigned long flags;\n\n\tif (size < 1)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; handlers[i].id; ++i) {\n\t\th = &handlers[i];\n\t\tif (h->id == raw_data[0] && h->size < size) {\n\t\t\tspin_lock_irqsave(&wdata->state.lock, flags);\n\t\t\th->func(wdata, &raw_data[1]);\n\t\t\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!handlers[i].id)\n\t\thid_warn(hdev, \"Unhandled report %hhu size %d\\n\", raw_data[0],\n\t\t\t\t\t\t\t\t\tsize);\n\n\treturn 0;\n}\n\nstatic ssize_t wiimote_ext_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct wiimote_data *wdata = dev_to_wii(dev);\n\t__u8 type;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\ttype = wdata->state.exttype;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tswitch (type) {\n\tcase WIIMOTE_EXT_NONE:\n\t\treturn sprintf(buf, \"none\\n\");\n\tcase WIIMOTE_EXT_NUNCHUK:\n\t\treturn sprintf(buf, \"nunchuk\\n\");\n\tcase WIIMOTE_EXT_CLASSIC_CONTROLLER:\n\t\treturn sprintf(buf, \"classic\\n\");\n\tcase WIIMOTE_EXT_BALANCE_BOARD:\n\t\treturn sprintf(buf, \"balanceboard\\n\");\n\tcase WIIMOTE_EXT_PRO_CONTROLLER:\n\t\treturn sprintf(buf, \"procontroller\\n\");\n\tcase WIIMOTE_EXT_DRUMS:\n\t\treturn sprintf(buf, \"drums\\n\");\n\tcase WIIMOTE_EXT_GUITAR:\n\t\treturn sprintf(buf, \"guitar\\n\");\n\tcase WIIMOTE_EXT_TURNTABLE:\n\t\treturn sprintf(buf, \"turntable\\n\");\n\tcase WIIMOTE_EXT_UNKNOWN:\n\tdefault:\n\t\treturn sprintf(buf, \"unknown\\n\");\n\t}\n}\n\nstatic ssize_t wiimote_ext_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct wiimote_data *wdata = dev_to_wii(dev);\n\n\tif (!strcmp(buf, \"scan\")) {\n\t\twiimote_schedule(wdata);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn strnlen(buf, PAGE_SIZE);\n}\n\nstatic DEVICE_ATTR(extension, S_IRUGO | S_IWUSR | S_IWGRP, wiimote_ext_show,\n\t\t   wiimote_ext_store);\n\nstatic ssize_t wiimote_dev_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct wiimote_data *wdata = dev_to_wii(dev);\n\t__u8 type;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\ttype = wdata->state.devtype;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tswitch (type) {\n\tcase WIIMOTE_DEV_GENERIC:\n\t\treturn sprintf(buf, \"generic\\n\");\n\tcase WIIMOTE_DEV_GEN10:\n\t\treturn sprintf(buf, \"gen10\\n\");\n\tcase WIIMOTE_DEV_GEN20:\n\t\treturn sprintf(buf, \"gen20\\n\");\n\tcase WIIMOTE_DEV_BALANCE_BOARD:\n\t\treturn sprintf(buf, \"balanceboard\\n\");\n\tcase WIIMOTE_DEV_PRO_CONTROLLER:\n\t\treturn sprintf(buf, \"procontroller\\n\");\n\tcase WIIMOTE_DEV_PENDING:\n\t\treturn sprintf(buf, \"pending\\n\");\n\tcase WIIMOTE_DEV_UNKNOWN:\n\tdefault:\n\t\treturn sprintf(buf, \"unknown\\n\");\n\t}\n}\n\nstatic DEVICE_ATTR(devtype, S_IRUGO, wiimote_dev_show, NULL);\n\nstatic struct wiimote_data *wiimote_create(struct hid_device *hdev)\n{\n\tstruct wiimote_data *wdata;\n\n\twdata = kzalloc(sizeof(*wdata), GFP_KERNEL);\n\tif (!wdata)\n\t\treturn NULL;\n\n\twdata->hdev = hdev;\n\thid_set_drvdata(hdev, wdata);\n\n\tspin_lock_init(&wdata->queue.lock);\n\tINIT_WORK(&wdata->queue.worker, wiimote_queue_worker);\n\n\tspin_lock_init(&wdata->state.lock);\n\tinit_completion(&wdata->state.ready);\n\tmutex_init(&wdata->state.sync);\n\twdata->state.drm = WIIPROTO_REQ_DRM_K;\n\twdata->state.cmd_battery = 0xff;\n\n\tINIT_WORK(&wdata->init_worker, wiimote_init_worker);\n\ttimer_setup(&wdata->timer, wiimote_init_timeout, 0);\n\n\treturn wdata;\n}\n\nstatic void wiimote_destroy(struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\n\twiidebug_deinit(wdata);\n\n\t \n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_EXITING;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tcancel_work_sync(&wdata->init_worker);\n\ttimer_shutdown_sync(&wdata->timer);\n\n\tdevice_remove_file(&wdata->hdev->dev, &dev_attr_devtype);\n\tdevice_remove_file(&wdata->hdev->dev, &dev_attr_extension);\n\n\twiimote_mp_unload(wdata);\n\twiimote_ext_unload(wdata);\n\twiimote_modules_unload(wdata);\n\tcancel_work_sync(&wdata->queue.worker);\n\thid_hw_close(wdata->hdev);\n\thid_hw_stop(wdata->hdev);\n\n\tkfree(wdata);\n}\n\nstatic int wiimote_hid_probe(struct hid_device *hdev,\n\t\t\t\tconst struct hid_device_id *id)\n{\n\tstruct wiimote_data *wdata;\n\tint ret;\n\n\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\twdata = wiimote_create(hdev);\n\tif (!wdata) {\n\t\thid_err(hdev, \"Can't alloc device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"HID parse failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"HW start failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"cannot start hardware I/O\\n\");\n\t\tgoto err_stop;\n\t}\n\n\tret = device_create_file(&hdev->dev, &dev_attr_extension);\n\tif (ret) {\n\t\thid_err(hdev, \"cannot create sysfs attribute\\n\");\n\t\tgoto err_close;\n\t}\n\n\tret = device_create_file(&hdev->dev, &dev_attr_devtype);\n\tif (ret) {\n\t\thid_err(hdev, \"cannot create sysfs attribute\\n\");\n\t\tgoto err_ext;\n\t}\n\n\tret = wiidebug_init(wdata);\n\tif (ret)\n\t\tgoto err_free;\n\n\thid_info(hdev, \"New device registered\\n\");\n\n\t \n\twiimote_schedule(wdata);\n\n\treturn 0;\n\nerr_free:\n\twiimote_destroy(wdata);\n\treturn ret;\n\nerr_ext:\n\tdevice_remove_file(&wdata->hdev->dev, &dev_attr_extension);\nerr_close:\n\thid_hw_close(hdev);\nerr_stop:\n\thid_hw_stop(hdev);\nerr:\n\tinput_free_device(wdata->ir);\n\tinput_free_device(wdata->accel);\n\tkfree(wdata);\n\treturn ret;\n}\n\nstatic void wiimote_hid_remove(struct hid_device *hdev)\n{\n\tstruct wiimote_data *wdata = hid_get_drvdata(hdev);\n\n\thid_info(hdev, \"Device removed\\n\");\n\twiimote_destroy(wdata);\n}\n\nstatic const struct hid_device_id wiimote_hid_devices[] = {\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO,\n\t\t\t\tUSB_DEVICE_ID_NINTENDO_WIIMOTE) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO,\n\t\t\t\tUSB_DEVICE_ID_NINTENDO_WIIMOTE2) },\n\t{ }\n};\n\nbool wiimote_dpad_as_analog = false;\nmodule_param_named(dpad_as_analog, wiimote_dpad_as_analog, bool, 0644);\nMODULE_PARM_DESC(dpad_as_analog, \"Use D-Pad as main analog input\");\n\nMODULE_DEVICE_TABLE(hid, wiimote_hid_devices);\n\nstatic struct hid_driver wiimote_hid_driver = {\n\t.name = \"wiimote\",\n\t.id_table = wiimote_hid_devices,\n\t.probe = wiimote_hid_probe,\n\t.remove = wiimote_hid_remove,\n\t.raw_event = wiimote_hid_event,\n};\nmodule_hid_driver(wiimote_hid_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Herrmann <dh.herrmann@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver for Nintendo Wii / Wii U peripherals\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}