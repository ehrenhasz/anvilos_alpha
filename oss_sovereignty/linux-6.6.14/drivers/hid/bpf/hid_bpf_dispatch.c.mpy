{
  "module_name": "hid_bpf_dispatch.c",
  "hash_id": "7c120077d5bc1afbc3e7cb49dab180547c266b3950e7edc9d83ee9c406f8f289",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/bpf/hid_bpf_dispatch.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/bitops.h>\n#include <linux/btf.h>\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/hid.h>\n#include <linux/hid_bpf.h>\n#include <linux/init.h>\n#include <linux/kfifo.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include \"hid_bpf_dispatch.h\"\n#include \"entrypoints/entrypoints.lskel.h\"\n\nstruct hid_bpf_ops *hid_bpf_ops;\nEXPORT_SYMBOL(hid_bpf_ops);\n\n \n \n__weak noinline int hid_bpf_device_event(struct hid_bpf_ctx *ctx)\n{\n\treturn 0;\n}\n\nu8 *\ndispatch_hid_bpf_device_event(struct hid_device *hdev, enum hid_report_type type, u8 *data,\n\t\t\t      u32 *size, int interrupt)\n{\n\tstruct hid_bpf_ctx_kern ctx_kern = {\n\t\t.ctx = {\n\t\t\t.hid = hdev,\n\t\t\t.report_type = type,\n\t\t\t.allocated_size = hdev->bpf.allocated_data,\n\t\t\t.size = *size,\n\t\t},\n\t\t.data = hdev->bpf.device_data,\n\t};\n\tint ret;\n\n\tif (type >= HID_REPORT_TYPES)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (!hdev->bpf.device_data)\n\t\treturn data;\n\n\tmemset(ctx_kern.data, 0, hdev->bpf.allocated_data);\n\tmemcpy(ctx_kern.data, data, *size);\n\n\tret = hid_bpf_prog_run(hdev, HID_BPF_PROG_TYPE_DEVICE_EVENT, &ctx_kern);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (ret) {\n\t\tif (ret > ctx_kern.ctx.allocated_size)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t*size = ret;\n\t}\n\n\treturn ctx_kern.data;\n}\nEXPORT_SYMBOL_GPL(dispatch_hid_bpf_device_event);\n\n \n \n__weak noinline int hid_bpf_rdesc_fixup(struct hid_bpf_ctx *ctx)\n{\n\treturn 0;\n}\n\nu8 *call_hid_bpf_rdesc_fixup(struct hid_device *hdev, u8 *rdesc, unsigned int *size)\n{\n\tint ret;\n\tstruct hid_bpf_ctx_kern ctx_kern = {\n\t\t.ctx = {\n\t\t\t.hid = hdev,\n\t\t\t.size = *size,\n\t\t\t.allocated_size = HID_MAX_DESCRIPTOR_SIZE,\n\t\t},\n\t};\n\n\tctx_kern.data = kzalloc(ctx_kern.ctx.allocated_size, GFP_KERNEL);\n\tif (!ctx_kern.data)\n\t\tgoto ignore_bpf;\n\n\tmemcpy(ctx_kern.data, rdesc, min_t(unsigned int, *size, HID_MAX_DESCRIPTOR_SIZE));\n\n\tret = hid_bpf_prog_run(hdev, HID_BPF_PROG_TYPE_RDESC_FIXUP, &ctx_kern);\n\tif (ret < 0)\n\t\tgoto ignore_bpf;\n\n\tif (ret) {\n\t\tif (ret > ctx_kern.ctx.allocated_size)\n\t\t\tgoto ignore_bpf;\n\n\t\t*size = ret;\n\t}\n\n\trdesc = krealloc(ctx_kern.data, *size, GFP_KERNEL);\n\n\treturn rdesc;\n\n ignore_bpf:\n\tkfree(ctx_kern.data);\n\treturn kmemdup(rdesc, *size, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(call_hid_bpf_rdesc_fixup);\n\n \nnoinline __u8 *\nhid_bpf_get_data(struct hid_bpf_ctx *ctx, unsigned int offset, const size_t rdwr_buf_size)\n{\n\tstruct hid_bpf_ctx_kern *ctx_kern;\n\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx_kern = container_of(ctx, struct hid_bpf_ctx_kern, ctx);\n\n\tif (rdwr_buf_size + offset > ctx->allocated_size)\n\t\treturn NULL;\n\n\treturn ctx_kern->data + offset;\n}\n\n \nBTF_SET8_START(hid_bpf_kfunc_ids)\nBTF_ID_FLAGS(func, hid_bpf_get_data, KF_RET_NULL)\nBTF_SET8_END(hid_bpf_kfunc_ids)\n\nstatic const struct btf_kfunc_id_set hid_bpf_kfunc_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &hid_bpf_kfunc_ids,\n};\n\nstatic int device_match_id(struct device *dev, const void *id)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\treturn hdev->id == *(int *)id;\n}\n\nstatic int __hid_bpf_allocate_data(struct hid_device *hdev, u8 **data, u32 *size)\n{\n\tu8 *alloc_data;\n\tunsigned int i, j, max_report_len = 0;\n\tsize_t alloc_size = 0;\n\n\t \n\tfor (i = 0; i < HID_REPORT_TYPES; i++) {\n\t\tstruct hid_report_enum *report_enum = hdev->report_enum + i;\n\n\t\tfor (j = 0; j < HID_MAX_IDS; j++) {\n\t\t\tstruct hid_report *report = report_enum->report_id_hash[j];\n\n\t\t\tif (report)\n\t\t\t\tmax_report_len = max(max_report_len, hid_report_len(report));\n\t\t}\n\t}\n\n\t \n\talloc_size = DIV_ROUND_UP(max_report_len, 64) * 64;\n\n\talloc_data = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!alloc_data)\n\t\treturn -ENOMEM;\n\n\t*data = alloc_data;\n\t*size = alloc_size;\n\n\treturn 0;\n}\n\nstatic int hid_bpf_allocate_event_data(struct hid_device *hdev)\n{\n\t \n\tif (hdev->bpf.device_data)\n\t\treturn 0;\n\n\treturn __hid_bpf_allocate_data(hdev, &hdev->bpf.device_data, &hdev->bpf.allocated_data);\n}\n\nint hid_bpf_reconnect(struct hid_device *hdev)\n{\n\tif (!test_and_set_bit(ffs(HID_STAT_REPROBED), &hdev->status))\n\t\treturn device_reprobe(&hdev->dev);\n\n\treturn 0;\n}\n\n \n \nnoinline int\nhid_bpf_attach_prog(unsigned int hid_id, int prog_fd, __u32 flags)\n{\n\tstruct hid_device *hdev;\n\tstruct device *dev;\n\tint fd, err, prog_type = hid_bpf_get_prog_attach_type(prog_fd);\n\n\tif (!hid_bpf_ops)\n\t\treturn -EINVAL;\n\n\tif (prog_type < 0)\n\t\treturn prog_type;\n\n\tif (prog_type >= HID_BPF_PROG_TYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif ((flags & ~HID_BPF_FLAG_MASK))\n\t\treturn -EINVAL;\n\n\tdev = bus_find_device(hid_bpf_ops->bus_type, NULL, &hid_id, device_match_id);\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\thdev = to_hid_device(dev);\n\n\tif (prog_type == HID_BPF_PROG_TYPE_DEVICE_EVENT) {\n\t\terr = hid_bpf_allocate_event_data(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfd = __hid_bpf_attach_prog(hdev, prog_type, prog_fd, flags);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (prog_type == HID_BPF_PROG_TYPE_RDESC_FIXUP) {\n\t\terr = hid_bpf_reconnect(hdev);\n\t\tif (err) {\n\t\t\tclose_fd(fd);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn fd;\n}\n\n \nnoinline struct hid_bpf_ctx *\nhid_bpf_allocate_context(unsigned int hid_id)\n{\n\tstruct hid_device *hdev;\n\tstruct hid_bpf_ctx_kern *ctx_kern = NULL;\n\tstruct device *dev;\n\n\tif (!hid_bpf_ops)\n\t\treturn NULL;\n\n\tdev = bus_find_device(hid_bpf_ops->bus_type, NULL, &hid_id, device_match_id);\n\tif (!dev)\n\t\treturn NULL;\n\n\thdev = to_hid_device(dev);\n\n\tctx_kern = kzalloc(sizeof(*ctx_kern), GFP_KERNEL);\n\tif (!ctx_kern)\n\t\treturn NULL;\n\n\tctx_kern->ctx.hid = hdev;\n\n\treturn &ctx_kern->ctx;\n}\n\n \nnoinline void\nhid_bpf_release_context(struct hid_bpf_ctx *ctx)\n{\n\tstruct hid_bpf_ctx_kern *ctx_kern;\n\n\tctx_kern = container_of(ctx, struct hid_bpf_ctx_kern, ctx);\n\n\tkfree(ctx_kern);\n}\n\n \nnoinline int\nhid_bpf_hw_request(struct hid_bpf_ctx *ctx, __u8 *buf, size_t buf__sz,\n\t\t   enum hid_report_type rtype, enum hid_class_request reqtype)\n{\n\tstruct hid_device *hdev;\n\tstruct hid_report *report;\n\tstruct hid_report_enum *report_enum;\n\tu8 *dma_data;\n\tu32 report_len;\n\tint ret;\n\n\t \n\tif (!ctx || !hid_bpf_ops || !buf)\n\t\treturn -EINVAL;\n\n\tswitch (rtype) {\n\tcase HID_INPUT_REPORT:\n\tcase HID_OUTPUT_REPORT:\n\tcase HID_FEATURE_REPORT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\tcase HID_REQ_GET_IDLE:\n\tcase HID_REQ_GET_PROTOCOL:\n\tcase HID_REQ_SET_REPORT:\n\tcase HID_REQ_SET_IDLE:\n\tcase HID_REQ_SET_PROTOCOL:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (buf__sz < 1)\n\t\treturn -EINVAL;\n\n\thdev = (struct hid_device *)ctx->hid;  \n\n\treport_enum = hdev->report_enum + rtype;\n\treport = hid_bpf_ops->hid_get_report(report_enum, buf);\n\tif (!report)\n\t\treturn -EINVAL;\n\n\treport_len = hid_report_len(report);\n\n\tif (buf__sz > report_len)\n\t\tbuf__sz = report_len;\n\n\tdma_data = kmemdup(buf, buf__sz, GFP_KERNEL);\n\tif (!dma_data)\n\t\treturn -ENOMEM;\n\n\tret = hid_bpf_ops->hid_hw_raw_request(hdev,\n\t\t\t\t\t      dma_data[0],\n\t\t\t\t\t      dma_data,\n\t\t\t\t\t      buf__sz,\n\t\t\t\t\t      rtype,\n\t\t\t\t\t      reqtype);\n\n\tif (ret > 0)\n\t\tmemcpy(buf, dma_data, ret);\n\n\tkfree(dma_data);\n\treturn ret;\n}\n\n \nBTF_SET8_START(hid_bpf_fmodret_ids)\nBTF_ID_FLAGS(func, hid_bpf_device_event)\nBTF_ID_FLAGS(func, hid_bpf_rdesc_fixup)\nBTF_ID_FLAGS(func, __hid_bpf_tail_call)\nBTF_SET8_END(hid_bpf_fmodret_ids)\n\nstatic const struct btf_kfunc_id_set hid_bpf_fmodret_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &hid_bpf_fmodret_ids,\n};\n\n \nBTF_SET8_START(hid_bpf_syscall_kfunc_ids)\nBTF_ID_FLAGS(func, hid_bpf_attach_prog)\nBTF_ID_FLAGS(func, hid_bpf_allocate_context, KF_ACQUIRE | KF_RET_NULL)\nBTF_ID_FLAGS(func, hid_bpf_release_context, KF_RELEASE)\nBTF_ID_FLAGS(func, hid_bpf_hw_request)\nBTF_SET8_END(hid_bpf_syscall_kfunc_ids)\n\nstatic const struct btf_kfunc_id_set hid_bpf_syscall_kfunc_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &hid_bpf_syscall_kfunc_ids,\n};\n\nint hid_bpf_connect_device(struct hid_device *hdev)\n{\n\tstruct hid_bpf_prog_list *prog_list;\n\n\trcu_read_lock();\n\tprog_list = rcu_dereference(hdev->bpf.progs[HID_BPF_PROG_TYPE_DEVICE_EVENT]);\n\trcu_read_unlock();\n\n\t \n\tif (!prog_list)\n\t\treturn 0;\n\n\treturn hid_bpf_allocate_event_data(hdev);\n}\nEXPORT_SYMBOL_GPL(hid_bpf_connect_device);\n\nvoid hid_bpf_disconnect_device(struct hid_device *hdev)\n{\n\tkfree(hdev->bpf.device_data);\n\thdev->bpf.device_data = NULL;\n\thdev->bpf.allocated_data = 0;\n}\nEXPORT_SYMBOL_GPL(hid_bpf_disconnect_device);\n\nvoid hid_bpf_destroy_device(struct hid_device *hdev)\n{\n\tif (!hdev)\n\t\treturn;\n\n\t \n\thdev->bpf.destroyed = true;\n\n\t__hid_bpf_destroy_device(hdev);\n}\nEXPORT_SYMBOL_GPL(hid_bpf_destroy_device);\n\nvoid hid_bpf_device_init(struct hid_device *hdev)\n{\n\tspin_lock_init(&hdev->bpf.progs_lock);\n}\nEXPORT_SYMBOL_GPL(hid_bpf_device_init);\n\nstatic int __init hid_bpf_init(void)\n{\n\tint err;\n\n\t \n\n\terr = register_btf_fmodret_id_set(&hid_bpf_fmodret_set);\n\tif (err) {\n\t\tpr_warn(\"error while registering fmodret entrypoints: %d\", err);\n\t\treturn 0;\n\t}\n\n\terr = hid_bpf_preload_skel();\n\tif (err) {\n\t\tpr_warn(\"error while preloading HID BPF dispatcher: %d\", err);\n\t\treturn 0;\n\t}\n\n\t \n\terr = register_btf_kfunc_id_set(BPF_PROG_TYPE_TRACING, &hid_bpf_kfunc_set);\n\tif (err) {\n\t\tpr_warn(\"error while setting HID BPF tracing kfuncs: %d\", err);\n\t\treturn 0;\n\t}\n\n\t \n\terr = register_btf_kfunc_id_set(BPF_PROG_TYPE_SYSCALL, &hid_bpf_syscall_kfunc_set);\n\tif (err) {\n\t\tpr_warn(\"error while setting HID BPF syscall kfuncs: %d\", err);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit hid_bpf_exit(void)\n{\n\t \n\thid_bpf_free_links_and_skel();\n}\n\nlate_initcall(hid_bpf_init);\nmodule_exit(hid_bpf_exit);\nMODULE_AUTHOR(\"Benjamin Tissoires\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}