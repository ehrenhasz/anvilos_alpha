{
  "module_name": "hid-roccat.c",
  "hash_id": "cbd74e19c84f0a9d17dc7d11241019e8b6e1741d66fa86b87fadb3cb721584df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-roccat.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cdev.h>\n#include <linux/poll.h>\n#include <linux/sched/signal.h>\n#include <linux/hid-roccat.h>\n#include <linux/module.h>\n\n#define ROCCAT_FIRST_MINOR 0\n#define ROCCAT_MAX_DEVICES 8\n\n \n#define ROCCAT_CBUF_SIZE 16\n\nstruct roccat_report {\n\tuint8_t *value;\n};\n\nstruct roccat_device {\n\tunsigned int minor;\n\tint report_size;\n\tint open;\n\tint exist;\n\twait_queue_head_t wait;\n\tstruct device *dev;\n\tstruct hid_device *hid;\n\tstruct list_head readers;\n\t \n\tstruct mutex readers_lock;\n\n\t \n\tstruct roccat_report cbuf[ROCCAT_CBUF_SIZE];\n\tint cbuf_end;\n\tstruct mutex cbuf_lock;\n};\n\nstruct roccat_reader {\n\tstruct list_head node;\n\tstruct roccat_device *device;\n\tint cbuf_start;\n};\n\nstatic int roccat_major;\nstatic struct cdev roccat_cdev;\n\nstatic struct roccat_device *devices[ROCCAT_MAX_DEVICES];\n \nstatic DEFINE_MUTEX(devices_lock);\n\nstatic ssize_t roccat_read(struct file *file, char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct roccat_reader *reader = file->private_data;\n\tstruct roccat_device *device = reader->device;\n\tstruct roccat_report *report;\n\tssize_t retval = 0, len;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tmutex_lock(&device->cbuf_lock);\n\n\t \n\tif (reader->cbuf_start == device->cbuf_end) {\n\t\tadd_wait_queue(&device->wait, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t \n\t\twhile (reader->cbuf_start == device->cbuf_end) {\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tretval = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!device->exist) {\n\t\t\t\tretval = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmutex_unlock(&device->cbuf_lock);\n\t\t\tschedule();\n\t\t\tmutex_lock(&device->cbuf_lock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\n\t\tset_current_state(TASK_RUNNING);\n\t\tremove_wait_queue(&device->wait, &wait);\n\t}\n\n\t \n\tif (retval)\n\t\tgoto exit_unlock;\n\n\treport = &device->cbuf[reader->cbuf_start];\n\t \n\tlen = device->report_size > count ? count : device->report_size;\n\n\tif (copy_to_user(buffer, report->value, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto exit_unlock;\n\t}\n\tretval += len;\n\treader->cbuf_start = (reader->cbuf_start + 1) % ROCCAT_CBUF_SIZE;\n\nexit_unlock:\n\tmutex_unlock(&device->cbuf_lock);\n\treturn retval;\n}\n\nstatic __poll_t roccat_poll(struct file *file, poll_table *wait)\n{\n\tstruct roccat_reader *reader = file->private_data;\n\tpoll_wait(file, &reader->device->wait, wait);\n\tif (reader->cbuf_start != reader->device->cbuf_end)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\tif (!reader->device->exist)\n\t\treturn EPOLLERR | EPOLLHUP;\n\treturn 0;\n}\n\nstatic int roccat_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct roccat_reader *reader;\n\tstruct roccat_device *device;\n\tint error = 0;\n\n\treader = kzalloc(sizeof(struct roccat_reader), GFP_KERNEL);\n\tif (!reader)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&devices_lock);\n\n\tdevice = devices[minor];\n\n\tif (!device) {\n\t\tpr_emerg(\"roccat device with minor %d doesn't exist\\n\", minor);\n\t\terror = -ENODEV;\n\t\tgoto exit_err_devices;\n\t}\n\n\tmutex_lock(&device->readers_lock);\n\n\tif (!device->open++) {\n\t\t \n\t\terror = hid_hw_power(device->hid, PM_HINT_FULLON);\n\t\tif (error < 0) {\n\t\t\t--device->open;\n\t\t\tgoto exit_err_readers;\n\t\t}\n\n\t\terror = hid_hw_open(device->hid);\n\t\tif (error < 0) {\n\t\t\thid_hw_power(device->hid, PM_HINT_NORMAL);\n\t\t\t--device->open;\n\t\t\tgoto exit_err_readers;\n\t\t}\n\t}\n\n\treader->device = device;\n\t \n\treader->cbuf_start = device->cbuf_end;\n\n\tlist_add_tail(&reader->node, &device->readers);\n\tfile->private_data = reader;\n\nexit_err_readers:\n\tmutex_unlock(&device->readers_lock);\nexit_err_devices:\n\tmutex_unlock(&devices_lock);\n\tif (error)\n\t\tkfree(reader);\n\treturn error;\n}\n\nstatic int roccat_release(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct roccat_reader *reader = file->private_data;\n\tstruct roccat_device *device;\n\n\tmutex_lock(&devices_lock);\n\n\tdevice = devices[minor];\n\tif (!device) {\n\t\tmutex_unlock(&devices_lock);\n\t\tpr_emerg(\"roccat device with minor %d doesn't exist\\n\", minor);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&device->readers_lock);\n\tlist_del(&reader->node);\n\tmutex_unlock(&device->readers_lock);\n\tkfree(reader);\n\n\tif (!--device->open) {\n\t\t \n\t\tif (device->exist) {\n\t\t\thid_hw_power(device->hid, PM_HINT_NORMAL);\n\t\t\thid_hw_close(device->hid);\n\t\t} else {\n\t\t\tkfree(device);\n\t\t}\n\t}\n\n\tmutex_unlock(&devices_lock);\n\n\treturn 0;\n}\n\n \nint roccat_report_event(int minor, u8 const *data)\n{\n\tstruct roccat_device *device;\n\tstruct roccat_reader *reader;\n\tstruct roccat_report *report;\n\tuint8_t *new_value;\n\n\tdevice = devices[minor];\n\n\tnew_value = kmemdup(data, device->report_size, GFP_ATOMIC);\n\tif (!new_value)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&device->cbuf_lock);\n\n\treport = &device->cbuf[device->cbuf_end];\n\n\t \n\tkfree(report->value);\n\n\treport->value = new_value;\n\tdevice->cbuf_end = (device->cbuf_end + 1) % ROCCAT_CBUF_SIZE;\n\n\tlist_for_each_entry(reader, &device->readers, node) {\n\t\t \n\t\tif (reader->cbuf_start == device->cbuf_end)\n\t\t\treader->cbuf_start = (reader->cbuf_start + 1) % ROCCAT_CBUF_SIZE;\n\t}\n\n\tmutex_unlock(&device->cbuf_lock);\n\n\twake_up_interruptible(&device->wait);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(roccat_report_event);\n\n \nint roccat_connect(const struct class *klass, struct hid_device *hid, int report_size)\n{\n\tunsigned int minor;\n\tstruct roccat_device *device;\n\tint temp;\n\n\tdevice = kzalloc(sizeof(struct roccat_device), GFP_KERNEL);\n\tif (!device)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&devices_lock);\n\n\tfor (minor = 0; minor < ROCCAT_MAX_DEVICES; ++minor) {\n\t\tif (devices[minor])\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (minor < ROCCAT_MAX_DEVICES) {\n\t\tdevices[minor] = device;\n\t} else {\n\t\tmutex_unlock(&devices_lock);\n\t\tkfree(device);\n\t\treturn -EINVAL;\n\t}\n\n\tdevice->dev = device_create(klass, &hid->dev,\n\t\t\tMKDEV(roccat_major, minor), NULL,\n\t\t\t\"%s%s%d\", \"roccat\", hid->driver->name, minor);\n\n\tif (IS_ERR(device->dev)) {\n\t\tdevices[minor] = NULL;\n\t\tmutex_unlock(&devices_lock);\n\t\ttemp = PTR_ERR(device->dev);\n\t\tkfree(device);\n\t\treturn temp;\n\t}\n\n\tmutex_unlock(&devices_lock);\n\n\tinit_waitqueue_head(&device->wait);\n\tINIT_LIST_HEAD(&device->readers);\n\tmutex_init(&device->readers_lock);\n\tmutex_init(&device->cbuf_lock);\n\tdevice->minor = minor;\n\tdevice->hid = hid;\n\tdevice->exist = 1;\n\tdevice->cbuf_end = 0;\n\tdevice->report_size = report_size;\n\n\treturn minor;\n}\nEXPORT_SYMBOL_GPL(roccat_connect);\n\n \nvoid roccat_disconnect(int minor)\n{\n\tstruct roccat_device *device;\n\n\tmutex_lock(&devices_lock);\n\tdevice = devices[minor];\n\tmutex_unlock(&devices_lock);\n\n\tdevice->exist = 0;  \n\n\tdevice_destroy(device->dev->class, MKDEV(roccat_major, minor));\n\n\tmutex_lock(&devices_lock);\n\tdevices[minor] = NULL;\n\tmutex_unlock(&devices_lock);\n\n\tif (device->open) {\n\t\thid_hw_close(device->hid);\n\t\twake_up_interruptible(&device->wait);\n\t} else {\n\t\tkfree(device);\n\t}\n}\nEXPORT_SYMBOL_GPL(roccat_disconnect);\n\nstatic long roccat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct roccat_device *device;\n\tunsigned int minor = iminor(inode);\n\tlong retval = 0;\n\n\tmutex_lock(&devices_lock);\n\n\tdevice = devices[minor];\n\tif (!device) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase ROCCATIOCGREPSIZE:\n\t\tif (put_user(device->report_size, (int __user *)arg))\n\t\t\tretval = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOTTY;\n\t}\nout:\n\tmutex_unlock(&devices_lock);\n\treturn retval;\n}\n\nstatic const struct file_operations roccat_ops = {\n\t.owner = THIS_MODULE,\n\t.read = roccat_read,\n\t.poll = roccat_poll,\n\t.open = roccat_open,\n\t.release = roccat_release,\n\t.llseek = noop_llseek,\n\t.unlocked_ioctl = roccat_ioctl,\n};\n\nstatic int __init roccat_init(void)\n{\n\tint retval;\n\tdev_t dev_id;\n\n\tretval = alloc_chrdev_region(&dev_id, ROCCAT_FIRST_MINOR,\n\t\t\tROCCAT_MAX_DEVICES, \"roccat\");\n\tif (retval < 0) {\n\t\tpr_warn(\"can't get major number\\n\");\n\t\tgoto error;\n\t}\n\n\troccat_major = MAJOR(dev_id);\n\n\tcdev_init(&roccat_cdev, &roccat_ops);\n\tretval = cdev_add(&roccat_cdev, dev_id, ROCCAT_MAX_DEVICES);\n\n\tif (retval < 0) {\n\t\tpr_warn(\"cannot add cdev\\n\");\n\t\tgoto cleanup_alloc_chrdev_region;\n\t}\n\treturn 0;\n\n\n cleanup_alloc_chrdev_region:\n\tunregister_chrdev_region(dev_id, ROCCAT_MAX_DEVICES);\n error:\n\treturn retval;\n}\n\nstatic void __exit roccat_exit(void)\n{\n\tdev_t dev_id = MKDEV(roccat_major, 0);\n\n\tcdev_del(&roccat_cdev);\n\tunregister_chrdev_region(dev_id, ROCCAT_MAX_DEVICES);\n}\n\nmodule_init(roccat_init);\nmodule_exit(roccat_exit);\n\nMODULE_AUTHOR(\"Stefan Achatz\");\nMODULE_DESCRIPTION(\"USB Roccat char device\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}