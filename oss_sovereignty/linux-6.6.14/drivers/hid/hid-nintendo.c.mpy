{
  "module_name": "hid-nintendo.c",
  "hash_id": "e968ce21b0bfccfa9a03ebe816f667caea8539bc636b95b0ea72e5198b677988",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-nintendo.c",
  "human_readable_source": "\n \n\n#include \"hid-ids.h\"\n#include <asm/unaligned.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/power_supply.h>\n#include <linux/spinlock.h>\n\n \n\n \n#define JC_OUTPUT_RUMBLE_AND_SUBCMD\t 0x01\n#define JC_OUTPUT_FW_UPDATE_PKT\t\t 0x03\n#define JC_OUTPUT_RUMBLE_ONLY\t\t 0x10\n#define JC_OUTPUT_MCU_DATA\t\t 0x11\n#define JC_OUTPUT_USB_CMD\t\t 0x80\n\n \n#define JC_SUBCMD_STATE\t\t\t 0x00\n#define JC_SUBCMD_MANUAL_BT_PAIRING\t 0x01\n#define JC_SUBCMD_REQ_DEV_INFO\t\t 0x02\n#define JC_SUBCMD_SET_REPORT_MODE\t 0x03\n#define JC_SUBCMD_TRIGGERS_ELAPSED\t 0x04\n#define JC_SUBCMD_GET_PAGE_LIST_STATE\t 0x05\n#define JC_SUBCMD_SET_HCI_STATE\t\t 0x06\n#define JC_SUBCMD_RESET_PAIRING_INFO\t 0x07\n#define JC_SUBCMD_LOW_POWER_MODE\t 0x08\n#define JC_SUBCMD_SPI_FLASH_READ\t 0x10\n#define JC_SUBCMD_SPI_FLASH_WRITE\t 0x11\n#define JC_SUBCMD_RESET_MCU\t\t 0x20\n#define JC_SUBCMD_SET_MCU_CONFIG\t 0x21\n#define JC_SUBCMD_SET_MCU_STATE\t\t 0x22\n#define JC_SUBCMD_SET_PLAYER_LIGHTS\t 0x30\n#define JC_SUBCMD_GET_PLAYER_LIGHTS\t 0x31\n#define JC_SUBCMD_SET_HOME_LIGHT\t 0x38\n#define JC_SUBCMD_ENABLE_IMU\t\t 0x40\n#define JC_SUBCMD_SET_IMU_SENSITIVITY\t 0x41\n#define JC_SUBCMD_WRITE_IMU_REG\t\t 0x42\n#define JC_SUBCMD_READ_IMU_REG\t\t 0x43\n#define JC_SUBCMD_ENABLE_VIBRATION\t 0x48\n#define JC_SUBCMD_GET_REGULATED_VOLTAGE\t 0x50\n\n \n#define JC_INPUT_BUTTON_EVENT\t\t 0x3F\n#define JC_INPUT_SUBCMD_REPLY\t\t 0x21\n#define JC_INPUT_IMU_DATA\t\t 0x30\n#define JC_INPUT_MCU_DATA\t\t 0x31\n#define JC_INPUT_USB_RESPONSE\t\t 0x81\n\n \n#define JC_FEATURE_LAST_SUBCMD\t\t 0x02\n#define JC_FEATURE_OTA_FW_UPGRADE\t 0x70\n#define JC_FEATURE_SETUP_MEM_READ\t 0x71\n#define JC_FEATURE_MEM_READ\t\t 0x72\n#define JC_FEATURE_ERASE_MEM_SECTOR\t 0x73\n#define JC_FEATURE_MEM_WRITE\t\t 0x74\n#define JC_FEATURE_LAUNCH\t\t 0x75\n\n \n#define JC_USB_CMD_CONN_STATUS\t\t 0x01\n#define JC_USB_CMD_HANDSHAKE\t\t 0x02\n#define JC_USB_CMD_BAUDRATE_3M\t\t 0x03\n#define JC_USB_CMD_NO_TIMEOUT\t\t 0x04\n#define JC_USB_CMD_EN_TIMEOUT\t\t 0x05\n#define JC_USB_RESET\t\t\t 0x06\n#define JC_USB_PRE_HANDSHAKE\t\t 0x91\n#define JC_USB_SEND_UART\t\t 0x92\n\n \n#define JC_CAL_USR_MAGIC_0\t\t 0xB2\n#define JC_CAL_USR_MAGIC_1\t\t 0xA1\n#define JC_CAL_USR_MAGIC_SIZE\t\t 2\n\n \n#define JC_CAL_USR_LEFT_MAGIC_ADDR\t 0x8010\n#define JC_CAL_USR_LEFT_DATA_ADDR\t 0x8012\n#define JC_CAL_USR_LEFT_DATA_END\t 0x801A\n#define JC_CAL_USR_RIGHT_MAGIC_ADDR\t 0x801B\n#define JC_CAL_USR_RIGHT_DATA_ADDR\t 0x801D\n#define JC_CAL_STICK_DATA_SIZE \\\n\t(JC_CAL_USR_LEFT_DATA_END - JC_CAL_USR_LEFT_DATA_ADDR + 1)\n\n \n#define JC_CAL_FCT_DATA_LEFT_ADDR\t 0x603d\n#define JC_CAL_FCT_DATA_RIGHT_ADDR\t 0x6046\n\n \n#define JC_IMU_CAL_FCT_DATA_ADDR\t 0x6020\n#define JC_IMU_CAL_FCT_DATA_END\t 0x6037\n#define JC_IMU_CAL_DATA_SIZE \\\n\t(JC_IMU_CAL_FCT_DATA_END - JC_IMU_CAL_FCT_DATA_ADDR + 1)\n \n#define JC_IMU_CAL_USR_MAGIC_ADDR\t 0x8026\n#define JC_IMU_CAL_USR_DATA_ADDR\t 0x8028\n\n \n#define JC_MAX_STICK_MAG\t\t 32767\n#define JC_STICK_FUZZ\t\t\t 250\n#define JC_STICK_FLAT\t\t\t 500\n\n \n#define JC_MAX_DPAD_MAG\t\t1\n#define JC_DPAD_FUZZ\t\t0\n#define JC_DPAD_FLAT\t\t0\n\n \n#define JC_IMU_DFLT_AVG_DELTA_MS\t15\n \n#define JC_IMU_SAMPLES_PER_DELTA_AVG\t300\n \n#define JC_IMU_DROPPED_PKT_WARNING\t3\n\n \n#define JC_IMU_MAX_ACCEL_MAG\t\t32767\n#define JC_IMU_ACCEL_RES_PER_G\t\t4096\n#define JC_IMU_ACCEL_FUZZ\t\t10\n#define JC_IMU_ACCEL_FLAT\t\t0\n\n \n#define JC_IMU_PREC_RANGE_SCALE\t1000\n \n#define JC_IMU_MAX_GYRO_MAG\t\t32767000  \n#define JC_IMU_GYRO_RES_PER_DPS\t\t14247  \n#define JC_IMU_GYRO_FUZZ\t\t10\n#define JC_IMU_GYRO_FLAT\t\t0\n\n \nstruct joycon_rumble_freq_data {\n\tu16 high;\n\tu8 low;\n\tu16 freq;  \n};\n\nstruct joycon_rumble_amp_data {\n\tu8 high;\n\tu16 low;\n\tu16 amp;\n};\n\n#if IS_ENABLED(CONFIG_NINTENDO_FF)\n \nstatic const struct joycon_rumble_freq_data joycon_rumble_frequencies[] = {\n\t \n\t{ 0x0000, 0x01,   41 }, { 0x0000, 0x02,   42 }, { 0x0000, 0x03,   43 },\n\t{ 0x0000, 0x04,   44 }, { 0x0000, 0x05,   45 }, { 0x0000, 0x06,   46 },\n\t{ 0x0000, 0x07,   47 }, { 0x0000, 0x08,   48 }, { 0x0000, 0x09,   49 },\n\t{ 0x0000, 0x0A,   50 }, { 0x0000, 0x0B,   51 }, { 0x0000, 0x0C,   52 },\n\t{ 0x0000, 0x0D,   53 }, { 0x0000, 0x0E,   54 }, { 0x0000, 0x0F,   55 },\n\t{ 0x0000, 0x10,   57 }, { 0x0000, 0x11,   58 }, { 0x0000, 0x12,   59 },\n\t{ 0x0000, 0x13,   60 }, { 0x0000, 0x14,   62 }, { 0x0000, 0x15,   63 },\n\t{ 0x0000, 0x16,   64 }, { 0x0000, 0x17,   66 }, { 0x0000, 0x18,   67 },\n\t{ 0x0000, 0x19,   69 }, { 0x0000, 0x1A,   70 }, { 0x0000, 0x1B,   72 },\n\t{ 0x0000, 0x1C,   73 }, { 0x0000, 0x1D,   75 }, { 0x0000, 0x1e,   77 },\n\t{ 0x0000, 0x1f,   78 }, { 0x0000, 0x20,   80 }, { 0x0400, 0x21,   82 },\n\t{ 0x0800, 0x22,   84 }, { 0x0c00, 0x23,   85 }, { 0x1000, 0x24,   87 },\n\t{ 0x1400, 0x25,   89 }, { 0x1800, 0x26,   91 }, { 0x1c00, 0x27,   93 },\n\t{ 0x2000, 0x28,   95 }, { 0x2400, 0x29,   97 }, { 0x2800, 0x2a,   99 },\n\t{ 0x2c00, 0x2b,  102 }, { 0x3000, 0x2c,  104 }, { 0x3400, 0x2d,  106 },\n\t{ 0x3800, 0x2e,  108 }, { 0x3c00, 0x2f,  111 }, { 0x4000, 0x30,  113 },\n\t{ 0x4400, 0x31,  116 }, { 0x4800, 0x32,  118 }, { 0x4c00, 0x33,  121 },\n\t{ 0x5000, 0x34,  123 }, { 0x5400, 0x35,  126 }, { 0x5800, 0x36,  129 },\n\t{ 0x5c00, 0x37,  132 }, { 0x6000, 0x38,  135 }, { 0x6400, 0x39,  137 },\n\t{ 0x6800, 0x3a,  141 }, { 0x6c00, 0x3b,  144 }, { 0x7000, 0x3c,  147 },\n\t{ 0x7400, 0x3d,  150 }, { 0x7800, 0x3e,  153 }, { 0x7c00, 0x3f,  157 },\n\t{ 0x8000, 0x40,  160 }, { 0x8400, 0x41,  164 }, { 0x8800, 0x42,  167 },\n\t{ 0x8c00, 0x43,  171 }, { 0x9000, 0x44,  174 }, { 0x9400, 0x45,  178 },\n\t{ 0x9800, 0x46,  182 }, { 0x9c00, 0x47,  186 }, { 0xa000, 0x48,  190 },\n\t{ 0xa400, 0x49,  194 }, { 0xa800, 0x4a,  199 }, { 0xac00, 0x4b,  203 },\n\t{ 0xb000, 0x4c,  207 }, { 0xb400, 0x4d,  212 }, { 0xb800, 0x4e,  217 },\n\t{ 0xbc00, 0x4f,  221 }, { 0xc000, 0x50,  226 }, { 0xc400, 0x51,  231 },\n\t{ 0xc800, 0x52,  236 }, { 0xcc00, 0x53,  241 }, { 0xd000, 0x54,  247 },\n\t{ 0xd400, 0x55,  252 }, { 0xd800, 0x56,  258 }, { 0xdc00, 0x57,  263 },\n\t{ 0xe000, 0x58,  269 }, { 0xe400, 0x59,  275 }, { 0xe800, 0x5a,  281 },\n\t{ 0xec00, 0x5b,  287 }, { 0xf000, 0x5c,  293 }, { 0xf400, 0x5d,  300 },\n\t{ 0xf800, 0x5e,  306 }, { 0xfc00, 0x5f,  313 }, { 0x0001, 0x60,  320 },\n\t{ 0x0401, 0x61,  327 }, { 0x0801, 0x62,  334 }, { 0x0c01, 0x63,  341 },\n\t{ 0x1001, 0x64,  349 }, { 0x1401, 0x65,  357 }, { 0x1801, 0x66,  364 },\n\t{ 0x1c01, 0x67,  372 }, { 0x2001, 0x68,  381 }, { 0x2401, 0x69,  389 },\n\t{ 0x2801, 0x6a,  397 }, { 0x2c01, 0x6b,  406 }, { 0x3001, 0x6c,  415 },\n\t{ 0x3401, 0x6d,  424 }, { 0x3801, 0x6e,  433 }, { 0x3c01, 0x6f,  443 },\n\t{ 0x4001, 0x70,  453 }, { 0x4401, 0x71,  462 }, { 0x4801, 0x72,  473 },\n\t{ 0x4c01, 0x73,  483 }, { 0x5001, 0x74,  494 }, { 0x5401, 0x75,  504 },\n\t{ 0x5801, 0x76,  515 }, { 0x5c01, 0x77,  527 }, { 0x6001, 0x78,  538 },\n\t{ 0x6401, 0x79,  550 }, { 0x6801, 0x7a,  562 }, { 0x6c01, 0x7b,  574 },\n\t{ 0x7001, 0x7c,  587 }, { 0x7401, 0x7d,  600 }, { 0x7801, 0x7e,  613 },\n\t{ 0x7c01, 0x7f,  626 }, { 0x8001, 0x00,  640 }, { 0x8401, 0x00,  654 },\n\t{ 0x8801, 0x00,  668 }, { 0x8c01, 0x00,  683 }, { 0x9001, 0x00,  698 },\n\t{ 0x9401, 0x00,  713 }, { 0x9801, 0x00,  729 }, { 0x9c01, 0x00,  745 },\n\t{ 0xa001, 0x00,  761 }, { 0xa401, 0x00,  778 }, { 0xa801, 0x00,  795 },\n\t{ 0xac01, 0x00,  812 }, { 0xb001, 0x00,  830 }, { 0xb401, 0x00,  848 },\n\t{ 0xb801, 0x00,  867 }, { 0xbc01, 0x00,  886 }, { 0xc001, 0x00,  905 },\n\t{ 0xc401, 0x00,  925 }, { 0xc801, 0x00,  945 }, { 0xcc01, 0x00,  966 },\n\t{ 0xd001, 0x00,  987 }, { 0xd401, 0x00, 1009 }, { 0xd801, 0x00, 1031 },\n\t{ 0xdc01, 0x00, 1053 }, { 0xe001, 0x00, 1076 }, { 0xe401, 0x00, 1100 },\n\t{ 0xe801, 0x00, 1124 }, { 0xec01, 0x00, 1149 }, { 0xf001, 0x00, 1174 },\n\t{ 0xf401, 0x00, 1199 }, { 0xf801, 0x00, 1226 }, { 0xfc01, 0x00, 1253 }\n};\n\n#define joycon_max_rumble_amp\t(1003)\nstatic const struct joycon_rumble_amp_data joycon_rumble_amplitudes[] = {\n\t \n\t{ 0x00, 0x0040,    0 },\n\t{ 0x02, 0x8040,   10 }, { 0x04, 0x0041,   12 }, { 0x06, 0x8041,   14 },\n\t{ 0x08, 0x0042,   17 }, { 0x0a, 0x8042,   20 }, { 0x0c, 0x0043,   24 },\n\t{ 0x0e, 0x8043,   28 }, { 0x10, 0x0044,   33 }, { 0x12, 0x8044,   40 },\n\t{ 0x14, 0x0045,   47 }, { 0x16, 0x8045,   56 }, { 0x18, 0x0046,   67 },\n\t{ 0x1a, 0x8046,   80 }, { 0x1c, 0x0047,   95 }, { 0x1e, 0x8047,  112 },\n\t{ 0x20, 0x0048,  117 }, { 0x22, 0x8048,  123 }, { 0x24, 0x0049,  128 },\n\t{ 0x26, 0x8049,  134 }, { 0x28, 0x004a,  140 }, { 0x2a, 0x804a,  146 },\n\t{ 0x2c, 0x004b,  152 }, { 0x2e, 0x804b,  159 }, { 0x30, 0x004c,  166 },\n\t{ 0x32, 0x804c,  173 }, { 0x34, 0x004d,  181 }, { 0x36, 0x804d,  189 },\n\t{ 0x38, 0x004e,  198 }, { 0x3a, 0x804e,  206 }, { 0x3c, 0x004f,  215 },\n\t{ 0x3e, 0x804f,  225 }, { 0x40, 0x0050,  230 }, { 0x42, 0x8050,  235 },\n\t{ 0x44, 0x0051,  240 }, { 0x46, 0x8051,  245 }, { 0x48, 0x0052,  251 },\n\t{ 0x4a, 0x8052,  256 }, { 0x4c, 0x0053,  262 }, { 0x4e, 0x8053,  268 },\n\t{ 0x50, 0x0054,  273 }, { 0x52, 0x8054,  279 }, { 0x54, 0x0055,  286 },\n\t{ 0x56, 0x8055,  292 }, { 0x58, 0x0056,  298 }, { 0x5a, 0x8056,  305 },\n\t{ 0x5c, 0x0057,  311 }, { 0x5e, 0x8057,  318 }, { 0x60, 0x0058,  325 },\n\t{ 0x62, 0x8058,  332 }, { 0x64, 0x0059,  340 }, { 0x66, 0x8059,  347 },\n\t{ 0x68, 0x005a,  355 }, { 0x6a, 0x805a,  362 }, { 0x6c, 0x005b,  370 },\n\t{ 0x6e, 0x805b,  378 }, { 0x70, 0x005c,  387 }, { 0x72, 0x805c,  395 },\n\t{ 0x74, 0x005d,  404 }, { 0x76, 0x805d,  413 }, { 0x78, 0x005e,  422 },\n\t{ 0x7a, 0x805e,  431 }, { 0x7c, 0x005f,  440 }, { 0x7e, 0x805f,  450 },\n\t{ 0x80, 0x0060,  460 }, { 0x82, 0x8060,  470 }, { 0x84, 0x0061,  480 },\n\t{ 0x86, 0x8061,  491 }, { 0x88, 0x0062,  501 }, { 0x8a, 0x8062,  512 },\n\t{ 0x8c, 0x0063,  524 }, { 0x8e, 0x8063,  535 }, { 0x90, 0x0064,  547 },\n\t{ 0x92, 0x8064,  559 }, { 0x94, 0x0065,  571 }, { 0x96, 0x8065,  584 },\n\t{ 0x98, 0x0066,  596 }, { 0x9a, 0x8066,  609 }, { 0x9c, 0x0067,  623 },\n\t{ 0x9e, 0x8067,  636 }, { 0xa0, 0x0068,  650 }, { 0xa2, 0x8068,  665 },\n\t{ 0xa4, 0x0069,  679 }, { 0xa6, 0x8069,  694 }, { 0xa8, 0x006a,  709 },\n\t{ 0xaa, 0x806a,  725 }, { 0xac, 0x006b,  741 }, { 0xae, 0x806b,  757 },\n\t{ 0xb0, 0x006c,  773 }, { 0xb2, 0x806c,  790 }, { 0xb4, 0x006d,  808 },\n\t{ 0xb6, 0x806d,  825 }, { 0xb8, 0x006e,  843 }, { 0xba, 0x806e,  862 },\n\t{ 0xbc, 0x006f,  881 }, { 0xbe, 0x806f,  900 }, { 0xc0, 0x0070,  920 },\n\t{ 0xc2, 0x8070,  940 }, { 0xc4, 0x0071,  960 }, { 0xc6, 0x8071,  981 },\n\t{ 0xc8, 0x0072, joycon_max_rumble_amp }\n};\nstatic const u16 JC_RUMBLE_DFLT_LOW_FREQ = 160;\nstatic const u16 JC_RUMBLE_DFLT_HIGH_FREQ = 320;\nstatic const unsigned short JC_RUMBLE_ZERO_AMP_PKT_CNT = 5;\n#endif  \nstatic const u16 JC_RUMBLE_PERIOD_MS = 50;\n\n \nenum joycon_ctlr_state {\n\tJOYCON_CTLR_STATE_INIT,\n\tJOYCON_CTLR_STATE_READ,\n\tJOYCON_CTLR_STATE_REMOVED,\n};\n\n \nenum joycon_ctlr_type {\n\tJOYCON_CTLR_TYPE_JCL = 0x01,\n\tJOYCON_CTLR_TYPE_JCR = 0x02,\n\tJOYCON_CTLR_TYPE_PRO = 0x03,\n};\n\nstruct joycon_stick_cal {\n\ts32 max;\n\ts32 min;\n\ts32 center;\n};\n\nstruct joycon_imu_cal {\n\ts16 offset[3];\n\ts16 scale[3];\n};\n\n \n#define JC_BTN_Y\t BIT(0)\n#define JC_BTN_X\t BIT(1)\n#define JC_BTN_B\t BIT(2)\n#define JC_BTN_A\t BIT(3)\n#define JC_BTN_SR_R\t BIT(4)\n#define JC_BTN_SL_R\t BIT(5)\n#define JC_BTN_R\t BIT(6)\n#define JC_BTN_ZR\t BIT(7)\n#define JC_BTN_MINUS\t BIT(8)\n#define JC_BTN_PLUS\t BIT(9)\n#define JC_BTN_RSTICK\t BIT(10)\n#define JC_BTN_LSTICK\t BIT(11)\n#define JC_BTN_HOME\t BIT(12)\n#define JC_BTN_CAP\t BIT(13)  \n#define JC_BTN_DOWN\t BIT(16)\n#define JC_BTN_UP\t BIT(17)\n#define JC_BTN_RIGHT\t BIT(18)\n#define JC_BTN_LEFT\t BIT(19)\n#define JC_BTN_SR_L\t BIT(20)\n#define JC_BTN_SL_L\t BIT(21)\n#define JC_BTN_L\t BIT(22)\n#define JC_BTN_ZL\t BIT(23)\n\nenum joycon_msg_type {\n\tJOYCON_MSG_TYPE_NONE,\n\tJOYCON_MSG_TYPE_USB,\n\tJOYCON_MSG_TYPE_SUBCMD,\n};\n\nstruct joycon_rumble_output {\n\tu8 output_id;\n\tu8 packet_num;\n\tu8 rumble_data[8];\n} __packed;\n\nstruct joycon_subcmd_request {\n\tu8 output_id;  \n\tu8 packet_num;  \n\tu8 rumble_data[8];\n\tu8 subcmd_id;\n\tu8 data[];  \n} __packed;\n\nstruct joycon_subcmd_reply {\n\tu8 ack;  \n\tu8 id;  \n\tu8 data[];  \n} __packed;\n\nstruct joycon_imu_data {\n\ts16 accel_x;\n\ts16 accel_y;\n\ts16 accel_z;\n\ts16 gyro_x;\n\ts16 gyro_y;\n\ts16 gyro_z;\n} __packed;\n\nstruct joycon_input_report {\n\tu8 id;\n\tu8 timer;\n\tu8 bat_con;  \n\tu8 button_status[3];\n\tu8 left_stick[3];\n\tu8 right_stick[3];\n\tu8 vibrator_report;\n\n\tunion {\n\t\tstruct joycon_subcmd_reply subcmd_reply;\n\t\t \n\t\tu8 imu_raw_bytes[sizeof(struct joycon_imu_data) * 3];\n\t};\n} __packed;\n\n#define JC_MAX_RESP_SIZE\t(sizeof(struct joycon_input_report) + 35)\n#define JC_RUMBLE_DATA_SIZE\t8\n#define JC_RUMBLE_QUEUE_SIZE\t8\n\nstatic const char * const joycon_player_led_names[] = {\n\tLED_FUNCTION_PLAYER1,\n\tLED_FUNCTION_PLAYER2,\n\tLED_FUNCTION_PLAYER3,\n\tLED_FUNCTION_PLAYER4,\n};\n#define JC_NUM_LEDS\t\tARRAY_SIZE(joycon_player_led_names)\n\n \nstruct joycon_ctlr {\n\tstruct hid_device *hdev;\n\tstruct input_dev *input;\n\tstruct led_classdev leds[JC_NUM_LEDS];  \n\tstruct led_classdev home_led;\n\tenum joycon_ctlr_state ctlr_state;\n\tspinlock_t lock;\n\tu8 mac_addr[6];\n\tchar *mac_addr_str;\n\tenum joycon_ctlr_type ctlr_type;\n\n\t \n\tenum joycon_msg_type msg_type;\n\tu8 subcmd_num;\n\tstruct mutex output_mutex;\n\tu8 input_buf[JC_MAX_RESP_SIZE];\n\twait_queue_head_t wait;\n\tbool received_resp;\n\tu8 usb_ack_match;\n\tu8 subcmd_ack_match;\n\tbool received_input_report;\n\tunsigned int last_input_report_msecs;\n\tunsigned int last_subcmd_sent_msecs;\n\tunsigned int consecutive_valid_report_deltas;\n\n\t \n\tstruct joycon_stick_cal left_stick_cal_x;\n\tstruct joycon_stick_cal left_stick_cal_y;\n\tstruct joycon_stick_cal right_stick_cal_x;\n\tstruct joycon_stick_cal right_stick_cal_y;\n\n\tstruct joycon_imu_cal accel_cal;\n\tstruct joycon_imu_cal gyro_cal;\n\n\t \n\ts32 imu_cal_accel_divisor[3];\n\ts32 imu_cal_gyro_divisor[3];\n\n\t \n\tstruct power_supply *battery;\n\tstruct power_supply_desc battery_desc;\n\tu8 battery_capacity;\n\tbool battery_charging;\n\tbool host_powered;\n\n\t \n\tu8 rumble_data[JC_RUMBLE_QUEUE_SIZE][JC_RUMBLE_DATA_SIZE];\n\tint rumble_queue_head;\n\tint rumble_queue_tail;\n\tstruct workqueue_struct *rumble_queue;\n\tstruct work_struct rumble_worker;\n\tunsigned int rumble_msecs;\n\tu16 rumble_ll_freq;\n\tu16 rumble_lh_freq;\n\tu16 rumble_rl_freq;\n\tu16 rumble_rh_freq;\n\tunsigned short rumble_zero_countdown;\n\n\t \n\tstruct input_dev *imu_input;\n\tbool imu_first_packet_received;  \n\tunsigned int imu_timestamp_us;  \n\tunsigned int imu_last_pkt_ms;  \n\t \n\tunsigned int imu_delta_samples_count;\n\tunsigned int imu_delta_samples_sum;\n\tunsigned int imu_avg_delta_ms;\n};\n\n \n#define jc_type_is_joycon(ctlr) \\\n\t(ctlr->hdev->product == USB_DEVICE_ID_NINTENDO_JOYCONL || \\\n\t ctlr->hdev->product == USB_DEVICE_ID_NINTENDO_JOYCONR || \\\n\t ctlr->hdev->product == USB_DEVICE_ID_NINTENDO_CHRGGRIP)\n#define jc_type_is_procon(ctlr) \\\n\t(ctlr->hdev->product == USB_DEVICE_ID_NINTENDO_PROCON)\n#define jc_type_is_chrggrip(ctlr) \\\n\t(ctlr->hdev->product == USB_DEVICE_ID_NINTENDO_CHRGGRIP)\n\n \n#define jc_type_has_left(ctlr) \\\n\t(ctlr->ctlr_type == JOYCON_CTLR_TYPE_JCL || \\\n\t ctlr->ctlr_type == JOYCON_CTLR_TYPE_PRO)\n\n \n#define jc_type_has_right(ctlr) \\\n\t(ctlr->ctlr_type == JOYCON_CTLR_TYPE_JCR || \\\n\t ctlr->ctlr_type == JOYCON_CTLR_TYPE_PRO)\n\nstatic int __joycon_hid_send(struct hid_device *hdev, u8 *data, size_t len)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = hid_hw_output_report(hdev, buf, len);\n\tkfree(buf);\n\tif (ret < 0)\n\t\thid_dbg(hdev, \"Failed to send output report ret=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic void joycon_wait_for_input_report(struct joycon_ctlr *ctlr)\n{\n\tint ret;\n\n\t \n\tif (ctlr->ctlr_state == JOYCON_CTLR_STATE_READ) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ctlr->lock, flags);\n\t\tctlr->received_input_report = false;\n\t\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\t\tret = wait_event_timeout(ctlr->wait,\n\t\t\t\t\t ctlr->received_input_report,\n\t\t\t\t\t HZ / 4);\n\t\t \n\t\tif (!ret)\n\t\t\thid_warn(ctlr->hdev,\n\t\t\t\t \"timeout waiting for input report\\n\");\n\t}\n}\n\n \n#define JC_INPUT_REPORT_MIN_DELTA\t8\n#define JC_INPUT_REPORT_MAX_DELTA\t17\n#define JC_SUBCMD_TX_OFFSET_MS\t\t4\n#define JC_SUBCMD_VALID_DELTA_REQ\t3\n#define JC_SUBCMD_RATE_MAX_ATTEMPTS\t500\n#define JC_SUBCMD_RATE_LIMITER_USB_MS\t20\n#define JC_SUBCMD_RATE_LIMITER_BT_MS\t60\n#define JC_SUBCMD_RATE_LIMITER_MS(ctlr)\t((ctlr)->hdev->bus == BUS_USB ? JC_SUBCMD_RATE_LIMITER_USB_MS : JC_SUBCMD_RATE_LIMITER_BT_MS)\nstatic void joycon_enforce_subcmd_rate(struct joycon_ctlr *ctlr)\n{\n\tunsigned int current_ms;\n\tunsigned long subcmd_delta;\n\tint consecutive_valid_deltas = 0;\n\tint attempts = 0;\n\tunsigned long flags;\n\n\tif (unlikely(ctlr->ctlr_state != JOYCON_CTLR_STATE_READ))\n\t\treturn;\n\n\tdo {\n\t\tjoycon_wait_for_input_report(ctlr);\n\t\tcurrent_ms = jiffies_to_msecs(jiffies);\n\t\tsubcmd_delta = current_ms - ctlr->last_subcmd_sent_msecs;\n\n\t\tspin_lock_irqsave(&ctlr->lock, flags);\n\t\tconsecutive_valid_deltas = ctlr->consecutive_valid_report_deltas;\n\t\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\t\tattempts++;\n\t} while ((consecutive_valid_deltas < JC_SUBCMD_VALID_DELTA_REQ ||\n\t\t  subcmd_delta < JC_SUBCMD_RATE_LIMITER_MS(ctlr)) &&\n\t\t ctlr->ctlr_state == JOYCON_CTLR_STATE_READ &&\n\t\t attempts < JC_SUBCMD_RATE_MAX_ATTEMPTS);\n\n\tif (attempts >= JC_SUBCMD_RATE_MAX_ATTEMPTS) {\n\t\thid_warn(ctlr->hdev, \"%s: exceeded max attempts\", __func__);\n\t\treturn;\n\t}\n\n\tctlr->last_subcmd_sent_msecs = current_ms;\n\n\t \n\tmsleep(JC_SUBCMD_TX_OFFSET_MS);\n}\n\nstatic int joycon_hid_send_sync(struct joycon_ctlr *ctlr, u8 *data, size_t len,\n\t\t\t\tu32 timeout)\n{\n\tint ret;\n\tint tries = 2;\n\n\t \n\twhile (tries--) {\n\t\tjoycon_enforce_subcmd_rate(ctlr);\n\n\t\tret = __joycon_hid_send(ctlr->hdev, data, len);\n\t\tif (ret < 0) {\n\t\t\tmemset(ctlr->input_buf, 0, JC_MAX_RESP_SIZE);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = wait_event_timeout(ctlr->wait, ctlr->received_resp,\n\t\t\t\t\t timeout);\n\t\tif (!ret) {\n\t\t\thid_dbg(ctlr->hdev,\n\t\t\t\t\"synchronous send/receive timed out\\n\");\n\t\t\tif (tries) {\n\t\t\t\thid_dbg(ctlr->hdev,\n\t\t\t\t\t\"retrying sync send after timeout\\n\");\n\t\t\t}\n\t\t\tmemset(ctlr->input_buf, 0, JC_MAX_RESP_SIZE);\n\t\t\tret = -ETIMEDOUT;\n\t\t} else {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctlr->received_resp = false;\n\treturn ret;\n}\n\nstatic int joycon_send_usb(struct joycon_ctlr *ctlr, u8 cmd, u32 timeout)\n{\n\tint ret;\n\tu8 buf[2] = {JC_OUTPUT_USB_CMD};\n\n\tbuf[1] = cmd;\n\tctlr->usb_ack_match = cmd;\n\tctlr->msg_type = JOYCON_MSG_TYPE_USB;\n\tret = joycon_hid_send_sync(ctlr, buf, sizeof(buf), timeout);\n\tif (ret)\n\t\thid_dbg(ctlr->hdev, \"send usb command failed; ret=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int joycon_send_subcmd(struct joycon_ctlr *ctlr,\n\t\t\t      struct joycon_subcmd_request *subcmd,\n\t\t\t      size_t data_len, u32 timeout)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctlr->lock, flags);\n\t \n\tif (ctlr->ctlr_state == JOYCON_CTLR_STATE_REMOVED) {\n\t\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tmemcpy(subcmd->rumble_data, ctlr->rumble_data[ctlr->rumble_queue_tail],\n\t       JC_RUMBLE_DATA_SIZE);\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\tsubcmd->output_id = JC_OUTPUT_RUMBLE_AND_SUBCMD;\n\tsubcmd->packet_num = ctlr->subcmd_num;\n\tif (++ctlr->subcmd_num > 0xF)\n\t\tctlr->subcmd_num = 0;\n\tctlr->subcmd_ack_match = subcmd->subcmd_id;\n\tctlr->msg_type = JOYCON_MSG_TYPE_SUBCMD;\n\n\tret = joycon_hid_send_sync(ctlr, (u8 *)subcmd,\n\t\t\t\t   sizeof(*subcmd) + data_len, timeout);\n\tif (ret < 0)\n\t\thid_dbg(ctlr->hdev, \"send subcommand failed; ret=%d\\n\", ret);\n\telse\n\t\tret = 0;\n\treturn ret;\n}\n\n \nstatic int joycon_set_player_leds(struct joycon_ctlr *ctlr, u8 flash, u8 on)\n{\n\tstruct joycon_subcmd_request *req;\n\tu8 buffer[sizeof(*req) + 1] = { 0 };\n\n\treq = (struct joycon_subcmd_request *)buffer;\n\treq->subcmd_id = JC_SUBCMD_SET_PLAYER_LIGHTS;\n\treq->data[0] = (flash << 4) | on;\n\n\thid_dbg(ctlr->hdev, \"setting player leds\\n\");\n\treturn joycon_send_subcmd(ctlr, req, 1, HZ/4);\n}\n\nstatic int joycon_request_spi_flash_read(struct joycon_ctlr *ctlr,\n\t\t\t\t\t u32 start_addr, u8 size, u8 **reply)\n{\n\tstruct joycon_subcmd_request *req;\n\tstruct joycon_input_report *report;\n\tu8 buffer[sizeof(*req) + 5] = { 0 };\n\tu8 *data;\n\tint ret;\n\n\tif (!reply)\n\t\treturn -EINVAL;\n\n\treq = (struct joycon_subcmd_request *)buffer;\n\treq->subcmd_id = JC_SUBCMD_SPI_FLASH_READ;\n\tdata = req->data;\n\tput_unaligned_le32(start_addr, data);\n\tdata[4] = size;\n\n\thid_dbg(ctlr->hdev, \"requesting SPI flash data\\n\");\n\tret = joycon_send_subcmd(ctlr, req, 5, HZ);\n\tif (ret) {\n\t\thid_err(ctlr->hdev, \"failed reading SPI flash; ret=%d\\n\", ret);\n\t} else {\n\t\treport = (struct joycon_input_report *)ctlr->input_buf;\n\t\t \n\t\t*reply = &report->subcmd_reply.data[5];\n\t}\n\treturn ret;\n}\n\n \nstatic int joycon_check_for_cal_magic(struct joycon_ctlr *ctlr, u32 flash_addr)\n{\n\tint ret;\n\tu8 *reply;\n\n\tret = joycon_request_spi_flash_read(ctlr, flash_addr,\n\t\t\t\t\t    JC_CAL_USR_MAGIC_SIZE, &reply);\n\tif (ret)\n\t\treturn ret;\n\n\treturn reply[0] != JC_CAL_USR_MAGIC_0 || reply[1] != JC_CAL_USR_MAGIC_1;\n}\n\nstatic int joycon_read_stick_calibration(struct joycon_ctlr *ctlr, u16 cal_addr,\n\t\t\t\t\t struct joycon_stick_cal *cal_x,\n\t\t\t\t\t struct joycon_stick_cal *cal_y,\n\t\t\t\t\t bool left_stick)\n{\n\ts32 x_max_above;\n\ts32 x_min_below;\n\ts32 y_max_above;\n\ts32 y_min_below;\n\tu8 *raw_cal;\n\tint ret;\n\n\tret = joycon_request_spi_flash_read(ctlr, cal_addr,\n\t\t\t\t\t    JC_CAL_STICK_DATA_SIZE, &raw_cal);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (left_stick) {\n\t\tx_max_above = hid_field_extract(ctlr->hdev, (raw_cal + 0), 0,\n\t\t\t\t\t\t12);\n\t\ty_max_above = hid_field_extract(ctlr->hdev, (raw_cal + 1), 4,\n\t\t\t\t\t\t12);\n\t\tcal_x->center = hid_field_extract(ctlr->hdev, (raw_cal + 3), 0,\n\t\t\t\t\t\t  12);\n\t\tcal_y->center = hid_field_extract(ctlr->hdev, (raw_cal + 4), 4,\n\t\t\t\t\t\t  12);\n\t\tx_min_below = hid_field_extract(ctlr->hdev, (raw_cal + 6), 0,\n\t\t\t\t\t\t12);\n\t\ty_min_below = hid_field_extract(ctlr->hdev, (raw_cal + 7), 4,\n\t\t\t\t\t\t12);\n\t} else {\n\t\tcal_x->center = hid_field_extract(ctlr->hdev, (raw_cal + 0), 0,\n\t\t\t\t\t\t  12);\n\t\tcal_y->center = hid_field_extract(ctlr->hdev, (raw_cal + 1), 4,\n\t\t\t\t\t\t  12);\n\t\tx_min_below = hid_field_extract(ctlr->hdev, (raw_cal + 3), 0,\n\t\t\t\t\t\t12);\n\t\ty_min_below = hid_field_extract(ctlr->hdev, (raw_cal + 4), 4,\n\t\t\t\t\t\t12);\n\t\tx_max_above = hid_field_extract(ctlr->hdev, (raw_cal + 6), 0,\n\t\t\t\t\t\t12);\n\t\ty_max_above = hid_field_extract(ctlr->hdev, (raw_cal + 7), 4,\n\t\t\t\t\t\t12);\n\t}\n\n\tcal_x->max = cal_x->center + x_max_above;\n\tcal_x->min = cal_x->center - x_min_below;\n\tcal_y->max = cal_y->center + y_max_above;\n\tcal_y->min = cal_y->center - y_min_below;\n\n\t \n\tif (cal_x->min >= cal_x->center || cal_x->center >= cal_x->max ||\n\t    cal_y->min >= cal_y->center || cal_y->center >= cal_y->max)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic const u16 DFLT_STICK_CAL_CEN = 2000;\nstatic const u16 DFLT_STICK_CAL_MAX = 3500;\nstatic const u16 DFLT_STICK_CAL_MIN = 500;\nstatic void joycon_use_default_calibration(struct hid_device *hdev,\n\t\t\t\t\t   struct joycon_stick_cal *cal_x,\n\t\t\t\t\t   struct joycon_stick_cal *cal_y,\n\t\t\t\t\t   const char *stick, int ret)\n{\n\thid_warn(hdev,\n\t\t \"Failed to read %s stick cal, using defaults; e=%d\\n\",\n\t\t stick, ret);\n\n\tcal_x->center = cal_y->center = DFLT_STICK_CAL_CEN;\n\tcal_x->max = cal_y->max = DFLT_STICK_CAL_MAX;\n\tcal_x->min = cal_y->min = DFLT_STICK_CAL_MIN;\n}\n\nstatic int joycon_request_calibration(struct joycon_ctlr *ctlr)\n{\n\tu16 left_stick_addr = JC_CAL_FCT_DATA_LEFT_ADDR;\n\tu16 right_stick_addr = JC_CAL_FCT_DATA_RIGHT_ADDR;\n\tint ret;\n\n\thid_dbg(ctlr->hdev, \"requesting cal data\\n\");\n\n\t \n\tif (!joycon_check_for_cal_magic(ctlr, JC_CAL_USR_LEFT_MAGIC_ADDR)) {\n\t\tleft_stick_addr = JC_CAL_USR_LEFT_DATA_ADDR;\n\t\thid_info(ctlr->hdev, \"using user cal for left stick\\n\");\n\t} else {\n\t\thid_info(ctlr->hdev, \"using factory cal for left stick\\n\");\n\t}\n\tif (!joycon_check_for_cal_magic(ctlr, JC_CAL_USR_RIGHT_MAGIC_ADDR)) {\n\t\tright_stick_addr = JC_CAL_USR_RIGHT_DATA_ADDR;\n\t\thid_info(ctlr->hdev, \"using user cal for right stick\\n\");\n\t} else {\n\t\thid_info(ctlr->hdev, \"using factory cal for right stick\\n\");\n\t}\n\n\t \n\tret = joycon_read_stick_calibration(ctlr, left_stick_addr,\n\t\t\t\t\t    &ctlr->left_stick_cal_x,\n\t\t\t\t\t    &ctlr->left_stick_cal_y,\n\t\t\t\t\t    true);\n\n\tif (ret)\n\t\tjoycon_use_default_calibration(ctlr->hdev,\n\t\t\t\t\t       &ctlr->left_stick_cal_x,\n\t\t\t\t\t       &ctlr->left_stick_cal_y,\n\t\t\t\t\t       \"left\", ret);\n\n\t \n\tret = joycon_read_stick_calibration(ctlr, right_stick_addr,\n\t\t\t\t\t    &ctlr->right_stick_cal_x,\n\t\t\t\t\t    &ctlr->right_stick_cal_y,\n\t\t\t\t\t    false);\n\n\tif (ret)\n\t\tjoycon_use_default_calibration(ctlr->hdev,\n\t\t\t\t\t       &ctlr->right_stick_cal_x,\n\t\t\t\t\t       &ctlr->right_stick_cal_y,\n\t\t\t\t\t       \"right\", ret);\n\n\thid_dbg(ctlr->hdev, \"calibration:\\n\"\n\t\t\t    \"l_x_c=%d l_x_max=%d l_x_min=%d\\n\"\n\t\t\t    \"l_y_c=%d l_y_max=%d l_y_min=%d\\n\"\n\t\t\t    \"r_x_c=%d r_x_max=%d r_x_min=%d\\n\"\n\t\t\t    \"r_y_c=%d r_y_max=%d r_y_min=%d\\n\",\n\t\t\t    ctlr->left_stick_cal_x.center,\n\t\t\t    ctlr->left_stick_cal_x.max,\n\t\t\t    ctlr->left_stick_cal_x.min,\n\t\t\t    ctlr->left_stick_cal_y.center,\n\t\t\t    ctlr->left_stick_cal_y.max,\n\t\t\t    ctlr->left_stick_cal_y.min,\n\t\t\t    ctlr->right_stick_cal_x.center,\n\t\t\t    ctlr->right_stick_cal_x.max,\n\t\t\t    ctlr->right_stick_cal_x.min,\n\t\t\t    ctlr->right_stick_cal_y.center,\n\t\t\t    ctlr->right_stick_cal_y.max,\n\t\t\t    ctlr->right_stick_cal_y.min);\n\n\treturn 0;\n}\n\n \nstatic void joycon_calc_imu_cal_divisors(struct joycon_ctlr *ctlr)\n{\n\tint i, divz = 0;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tctlr->imu_cal_accel_divisor[i] = ctlr->accel_cal.scale[i] -\n\t\t\t\t\t\tctlr->accel_cal.offset[i];\n\t\tctlr->imu_cal_gyro_divisor[i] = ctlr->gyro_cal.scale[i] -\n\t\t\t\t\t\tctlr->gyro_cal.offset[i];\n\n\t\tif (ctlr->imu_cal_accel_divisor[i] == 0) {\n\t\t\tctlr->imu_cal_accel_divisor[i] = 1;\n\t\t\tdivz++;\n\t\t}\n\n\t\tif (ctlr->imu_cal_gyro_divisor[i] == 0) {\n\t\t\tctlr->imu_cal_gyro_divisor[i] = 1;\n\t\t\tdivz++;\n\t\t}\n\t}\n\n\tif (divz)\n\t\thid_warn(ctlr->hdev, \"inaccurate IMU divisors (%d)\\n\", divz);\n}\n\nstatic const s16 DFLT_ACCEL_OFFSET  ;\nstatic const s16 DFLT_ACCEL_SCALE = 16384;\nstatic const s16 DFLT_GYRO_OFFSET  ;\nstatic const s16 DFLT_GYRO_SCALE  = 13371;\nstatic int joycon_request_imu_calibration(struct joycon_ctlr *ctlr)\n{\n\tu16 imu_cal_addr = JC_IMU_CAL_FCT_DATA_ADDR;\n\tu8 *raw_cal;\n\tint ret;\n\tint i;\n\n\t \n\tif (!joycon_check_for_cal_magic(ctlr, JC_IMU_CAL_USR_MAGIC_ADDR)) {\n\t\timu_cal_addr = JC_IMU_CAL_USR_DATA_ADDR;\n\t\thid_info(ctlr->hdev, \"using user cal for IMU\\n\");\n\t} else {\n\t\thid_info(ctlr->hdev, \"using factory cal for IMU\\n\");\n\t}\n\n\t \n\thid_dbg(ctlr->hdev, \"requesting IMU cal data\\n\");\n\tret = joycon_request_spi_flash_read(ctlr, imu_cal_addr,\n\t\t\t\t\t    JC_IMU_CAL_DATA_SIZE, &raw_cal);\n\tif (ret) {\n\t\thid_warn(ctlr->hdev,\n\t\t\t \"Failed to read IMU cal, using defaults; ret=%d\\n\",\n\t\t\t ret);\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tctlr->accel_cal.offset[i] = DFLT_ACCEL_OFFSET;\n\t\t\tctlr->accel_cal.scale[i] = DFLT_ACCEL_SCALE;\n\t\t\tctlr->gyro_cal.offset[i] = DFLT_GYRO_OFFSET;\n\t\t\tctlr->gyro_cal.scale[i] = DFLT_GYRO_SCALE;\n\t\t}\n\t\tjoycon_calc_imu_cal_divisors(ctlr);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tint j = i * 2;\n\n\t\tctlr->accel_cal.offset[i] = get_unaligned_le16(raw_cal + j);\n\t\tctlr->accel_cal.scale[i] = get_unaligned_le16(raw_cal + j + 6);\n\t\tctlr->gyro_cal.offset[i] = get_unaligned_le16(raw_cal + j + 12);\n\t\tctlr->gyro_cal.scale[i] = get_unaligned_le16(raw_cal + j + 18);\n\t}\n\n\tjoycon_calc_imu_cal_divisors(ctlr);\n\n\thid_dbg(ctlr->hdev, \"IMU calibration:\\n\"\n\t\t\t    \"a_o[0]=%d a_o[1]=%d a_o[2]=%d\\n\"\n\t\t\t    \"a_s[0]=%d a_s[1]=%d a_s[2]=%d\\n\"\n\t\t\t    \"g_o[0]=%d g_o[1]=%d g_o[2]=%d\\n\"\n\t\t\t    \"g_s[0]=%d g_s[1]=%d g_s[2]=%d\\n\",\n\t\t\t    ctlr->accel_cal.offset[0],\n\t\t\t    ctlr->accel_cal.offset[1],\n\t\t\t    ctlr->accel_cal.offset[2],\n\t\t\t    ctlr->accel_cal.scale[0],\n\t\t\t    ctlr->accel_cal.scale[1],\n\t\t\t    ctlr->accel_cal.scale[2],\n\t\t\t    ctlr->gyro_cal.offset[0],\n\t\t\t    ctlr->gyro_cal.offset[1],\n\t\t\t    ctlr->gyro_cal.offset[2],\n\t\t\t    ctlr->gyro_cal.scale[0],\n\t\t\t    ctlr->gyro_cal.scale[1],\n\t\t\t    ctlr->gyro_cal.scale[2]);\n\n\treturn 0;\n}\n\nstatic int joycon_set_report_mode(struct joycon_ctlr *ctlr)\n{\n\tstruct joycon_subcmd_request *req;\n\tu8 buffer[sizeof(*req) + 1] = { 0 };\n\n\treq = (struct joycon_subcmd_request *)buffer;\n\treq->subcmd_id = JC_SUBCMD_SET_REPORT_MODE;\n\treq->data[0] = 0x30;  \n\n\thid_dbg(ctlr->hdev, \"setting controller report mode\\n\");\n\treturn joycon_send_subcmd(ctlr, req, 1, HZ);\n}\n\nstatic int joycon_enable_rumble(struct joycon_ctlr *ctlr)\n{\n\tstruct joycon_subcmd_request *req;\n\tu8 buffer[sizeof(*req) + 1] = { 0 };\n\n\treq = (struct joycon_subcmd_request *)buffer;\n\treq->subcmd_id = JC_SUBCMD_ENABLE_VIBRATION;\n\treq->data[0] = 0x01;  \n\n\thid_dbg(ctlr->hdev, \"enabling rumble\\n\");\n\treturn joycon_send_subcmd(ctlr, req, 1, HZ/4);\n}\n\nstatic int joycon_enable_imu(struct joycon_ctlr *ctlr)\n{\n\tstruct joycon_subcmd_request *req;\n\tu8 buffer[sizeof(*req) + 1] = { 0 };\n\n\treq = (struct joycon_subcmd_request *)buffer;\n\treq->subcmd_id = JC_SUBCMD_ENABLE_IMU;\n\treq->data[0] = 0x01;  \n\n\thid_dbg(ctlr->hdev, \"enabling IMU\\n\");\n\treturn joycon_send_subcmd(ctlr, req, 1, HZ);\n}\n\nstatic s32 joycon_map_stick_val(struct joycon_stick_cal *cal, s32 val)\n{\n\ts32 center = cal->center;\n\ts32 min = cal->min;\n\ts32 max = cal->max;\n\ts32 new_val;\n\n\tif (val > center) {\n\t\tnew_val = (val - center) * JC_MAX_STICK_MAG;\n\t\tnew_val /= (max - center);\n\t} else {\n\t\tnew_val = (center - val) * -JC_MAX_STICK_MAG;\n\t\tnew_val /= (center - min);\n\t}\n\tnew_val = clamp(new_val, (s32)-JC_MAX_STICK_MAG, (s32)JC_MAX_STICK_MAG);\n\treturn new_val;\n}\n\nstatic void joycon_input_report_parse_imu_data(struct joycon_ctlr *ctlr,\n\t\t\t\t\t       struct joycon_input_report *rep,\n\t\t\t\t\t       struct joycon_imu_data *imu_data)\n{\n\tu8 *raw = rep->imu_raw_bytes;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tstruct joycon_imu_data *data = &imu_data[i];\n\n\t\tdata->accel_x = get_unaligned_le16(raw + 0);\n\t\tdata->accel_y = get_unaligned_le16(raw + 2);\n\t\tdata->accel_z = get_unaligned_le16(raw + 4);\n\t\tdata->gyro_x = get_unaligned_le16(raw + 6);\n\t\tdata->gyro_y = get_unaligned_le16(raw + 8);\n\t\tdata->gyro_z = get_unaligned_le16(raw + 10);\n\t\t \n\t\traw += sizeof(struct joycon_imu_data);\n\t}\n}\n\nstatic void joycon_parse_imu_report(struct joycon_ctlr *ctlr,\n\t\t\t\t    struct joycon_input_report *rep)\n{\n\tstruct joycon_imu_data imu_data[3] = {0};  \n\tstruct input_dev *idev = ctlr->imu_input;\n\tunsigned int msecs = jiffies_to_msecs(jiffies);\n\tunsigned int last_msecs = ctlr->imu_last_pkt_ms;\n\tint i;\n\tint value[6];\n\n\tjoycon_input_report_parse_imu_data(ctlr, rep, imu_data);\n\n\t \n\tif (!ctlr->imu_first_packet_received) {\n\t\tctlr->imu_timestamp_us = 0;\n\t\tctlr->imu_delta_samples_count = 0;\n\t\tctlr->imu_delta_samples_sum = 0;\n\t\tctlr->imu_avg_delta_ms = JC_IMU_DFLT_AVG_DELTA_MS;\n\t\tctlr->imu_first_packet_received = true;\n\t} else {\n\t\tunsigned int delta = msecs - last_msecs;\n\t\tunsigned int dropped_pkts;\n\t\tunsigned int dropped_threshold;\n\n\t\t \n\t\tctlr->imu_delta_samples_sum += delta;\n\t\tctlr->imu_delta_samples_count++;\n\t\tif (ctlr->imu_delta_samples_count >=\n\t\t    JC_IMU_SAMPLES_PER_DELTA_AVG) {\n\t\t\tctlr->imu_avg_delta_ms = ctlr->imu_delta_samples_sum /\n\t\t\t\t\t\t ctlr->imu_delta_samples_count;\n\t\t\tctlr->imu_delta_samples_count = 0;\n\t\t\tctlr->imu_delta_samples_sum = 0;\n\t\t}\n\n\t\t \n\t\tif (ctlr->imu_avg_delta_ms == 0) {\n\t\t\tctlr->imu_avg_delta_ms = 1;\n\t\t\thid_warn(ctlr->hdev, \"calculated avg imu delta of 0\\n\");\n\t\t}\n\n\t\t \n\t\thid_dbg(ctlr->hdev,\n\t\t\t\"imu_report: ms=%u last_ms=%u delta=%u avg_delta=%u\\n\",\n\t\t\tmsecs, last_msecs, delta, ctlr->imu_avg_delta_ms);\n\n\t\t \n\t\tdropped_threshold = ctlr->imu_avg_delta_ms * 3 / 2;\n\t\tdropped_pkts = (delta - min(delta, dropped_threshold)) /\n\t\t\t\tctlr->imu_avg_delta_ms;\n\t\tctlr->imu_timestamp_us += 1000 * ctlr->imu_avg_delta_ms;\n\t\tif (dropped_pkts > JC_IMU_DROPPED_PKT_WARNING) {\n\t\t\thid_warn(ctlr->hdev,\n\t\t\t\t \"compensating for %u dropped IMU reports\\n\",\n\t\t\t\t dropped_pkts);\n\t\t\thid_warn(ctlr->hdev,\n\t\t\t\t \"delta=%u avg_delta=%u\\n\",\n\t\t\t\t delta, ctlr->imu_avg_delta_ms);\n\t\t}\n\t}\n\tctlr->imu_last_pkt_ms = msecs;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tinput_event(idev, EV_MSC, MSC_TIMESTAMP,\n\t\t\t    ctlr->imu_timestamp_us);\n\n\t\t \n\t\tvalue[0] = mult_frac((JC_IMU_PREC_RANGE_SCALE *\n\t\t\t\t      (imu_data[i].gyro_x -\n\t\t\t\t       ctlr->gyro_cal.offset[0])),\n\t\t\t\t     ctlr->gyro_cal.scale[0],\n\t\t\t\t     ctlr->imu_cal_gyro_divisor[0]);\n\t\tvalue[1] = mult_frac((JC_IMU_PREC_RANGE_SCALE *\n\t\t\t\t      (imu_data[i].gyro_y -\n\t\t\t\t       ctlr->gyro_cal.offset[1])),\n\t\t\t\t     ctlr->gyro_cal.scale[1],\n\t\t\t\t     ctlr->imu_cal_gyro_divisor[1]);\n\t\tvalue[2] = mult_frac((JC_IMU_PREC_RANGE_SCALE *\n\t\t\t\t      (imu_data[i].gyro_z -\n\t\t\t\t       ctlr->gyro_cal.offset[2])),\n\t\t\t\t     ctlr->gyro_cal.scale[2],\n\t\t\t\t     ctlr->imu_cal_gyro_divisor[2]);\n\n\t\tvalue[3] = ((s32)imu_data[i].accel_x *\n\t\t\t    ctlr->accel_cal.scale[0]) /\n\t\t\t    ctlr->imu_cal_accel_divisor[0];\n\t\tvalue[4] = ((s32)imu_data[i].accel_y *\n\t\t\t    ctlr->accel_cal.scale[1]) /\n\t\t\t    ctlr->imu_cal_accel_divisor[1];\n\t\tvalue[5] = ((s32)imu_data[i].accel_z *\n\t\t\t    ctlr->accel_cal.scale[2]) /\n\t\t\t    ctlr->imu_cal_accel_divisor[2];\n\n\t\thid_dbg(ctlr->hdev, \"raw_gyro: g_x=%d g_y=%d g_z=%d\\n\",\n\t\t\timu_data[i].gyro_x, imu_data[i].gyro_y,\n\t\t\timu_data[i].gyro_z);\n\t\thid_dbg(ctlr->hdev, \"raw_accel: a_x=%d a_y=%d a_z=%d\\n\",\n\t\t\timu_data[i].accel_x, imu_data[i].accel_y,\n\t\t\timu_data[i].accel_z);\n\n\t\t \n\t\tif (jc_type_is_joycon(ctlr) && jc_type_has_right(ctlr)) {\n\t\t\tint j;\n\n\t\t\t \n\t\t\tfor (j = 1; j < 6; ++j) {\n\t\t\t\tif (j == 3)\n\t\t\t\t\tcontinue;\n\t\t\t\tvalue[j] *= -1;\n\t\t\t}\n\t\t}\n\n\t\tinput_report_abs(idev, ABS_RX, value[0]);\n\t\tinput_report_abs(idev, ABS_RY, value[1]);\n\t\tinput_report_abs(idev, ABS_RZ, value[2]);\n\t\tinput_report_abs(idev, ABS_X, value[3]);\n\t\tinput_report_abs(idev, ABS_Y, value[4]);\n\t\tinput_report_abs(idev, ABS_Z, value[5]);\n\t\tinput_sync(idev);\n\t\t \n\t\tctlr->imu_timestamp_us += ctlr->imu_avg_delta_ms * 1000 / 3;\n\t}\n}\n\nstatic void joycon_parse_report(struct joycon_ctlr *ctlr,\n\t\t\t\tstruct joycon_input_report *rep)\n{\n\tstruct input_dev *dev = ctlr->input;\n\tunsigned long flags;\n\tu8 tmp;\n\tu32 btns;\n\tunsigned long msecs = jiffies_to_msecs(jiffies);\n\tunsigned long report_delta_ms = msecs - ctlr->last_input_report_msecs;\n\n\tspin_lock_irqsave(&ctlr->lock, flags);\n\tif (IS_ENABLED(CONFIG_NINTENDO_FF) && rep->vibrator_report &&\n\t    ctlr->ctlr_state != JOYCON_CTLR_STATE_REMOVED &&\n\t    (msecs - ctlr->rumble_msecs) >= JC_RUMBLE_PERIOD_MS &&\n\t    (ctlr->rumble_queue_head != ctlr->rumble_queue_tail ||\n\t     ctlr->rumble_zero_countdown > 0)) {\n\t\t \n\t\tif (ctlr->rumble_zero_countdown > 0)\n\t\t\tctlr->rumble_zero_countdown--;\n\t\tqueue_work(ctlr->rumble_queue, &ctlr->rumble_worker);\n\t}\n\n\t \n\ttmp = rep->bat_con;\n\tctlr->host_powered = tmp & BIT(0);\n\tctlr->battery_charging = tmp & BIT(4);\n\ttmp = tmp >> 5;\n\tswitch (tmp) {\n\tcase 0:  \n\t\tctlr->battery_capacity = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\t\tbreak;\n\tcase 1:  \n\t\tctlr->battery_capacity = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\t\tbreak;\n\tcase 2:  \n\t\tctlr->battery_capacity = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n\t\tbreak;\n\tcase 3:  \n\t\tctlr->battery_capacity = POWER_SUPPLY_CAPACITY_LEVEL_HIGH;\n\t\tbreak;\n\tcase 4:  \n\t\tctlr->battery_capacity = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\t\tbreak;\n\tdefault:\n\t\tctlr->battery_capacity = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\t\thid_warn(ctlr->hdev, \"Invalid battery status\\n\");\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\t \n\tbtns = hid_field_extract(ctlr->hdev, rep->button_status, 0, 24);\n\n\tif (jc_type_has_left(ctlr)) {\n\t\tu16 raw_x;\n\t\tu16 raw_y;\n\t\ts32 x;\n\t\ts32 y;\n\n\t\t \n\t\traw_x = hid_field_extract(ctlr->hdev, rep->left_stick, 0, 12);\n\t\traw_y = hid_field_extract(ctlr->hdev,\n\t\t\t\t\t  rep->left_stick + 1, 4, 12);\n\t\t \n\t\tx = joycon_map_stick_val(&ctlr->left_stick_cal_x, raw_x);\n\t\ty = -joycon_map_stick_val(&ctlr->left_stick_cal_y, raw_y);\n\t\t \n\t\tinput_report_abs(dev, ABS_X, x);\n\t\tinput_report_abs(dev, ABS_Y, y);\n\n\t\t \n\t\tinput_report_key(dev, BTN_TL, btns & JC_BTN_L);\n\t\tinput_report_key(dev, BTN_TL2, btns & JC_BTN_ZL);\n\t\tinput_report_key(dev, BTN_SELECT, btns & JC_BTN_MINUS);\n\t\tinput_report_key(dev, BTN_THUMBL, btns & JC_BTN_LSTICK);\n\t\tinput_report_key(dev, BTN_Z, btns & JC_BTN_CAP);\n\n\t\tif (jc_type_is_joycon(ctlr)) {\n\t\t\t \n\t\t\tinput_report_key(dev, BTN_TR, btns & JC_BTN_SL_L);\n\t\t\tinput_report_key(dev, BTN_TR2, btns & JC_BTN_SR_L);\n\n\t\t\t \n\t\t\tinput_report_key(dev, BTN_DPAD_DOWN,\n\t\t\t\t\t btns & JC_BTN_DOWN);\n\t\t\tinput_report_key(dev, BTN_DPAD_UP, btns & JC_BTN_UP);\n\t\t\tinput_report_key(dev, BTN_DPAD_RIGHT,\n\t\t\t\t\t btns & JC_BTN_RIGHT);\n\t\t\tinput_report_key(dev, BTN_DPAD_LEFT,\n\t\t\t\t\t btns & JC_BTN_LEFT);\n\t\t} else {\n\t\t\tint hatx = 0;\n\t\t\tint haty = 0;\n\n\t\t\t \n\t\t\tif (btns & JC_BTN_LEFT)\n\t\t\t\thatx = -1;\n\t\t\telse if (btns & JC_BTN_RIGHT)\n\t\t\t\thatx = 1;\n\t\t\tinput_report_abs(dev, ABS_HAT0X, hatx);\n\n\t\t\t \n\t\t\tif (btns & JC_BTN_UP)\n\t\t\t\thaty = -1;\n\t\t\telse if (btns & JC_BTN_DOWN)\n\t\t\t\thaty = 1;\n\t\t\tinput_report_abs(dev, ABS_HAT0Y, haty);\n\t\t}\n\t}\n\tif (jc_type_has_right(ctlr)) {\n\t\tu16 raw_x;\n\t\tu16 raw_y;\n\t\ts32 x;\n\t\ts32 y;\n\n\t\t \n\t\traw_x = hid_field_extract(ctlr->hdev, rep->right_stick, 0, 12);\n\t\traw_y = hid_field_extract(ctlr->hdev,\n\t\t\t\t\t  rep->right_stick + 1, 4, 12);\n\t\t \n\t\tx = joycon_map_stick_val(&ctlr->right_stick_cal_x, raw_x);\n\t\ty = -joycon_map_stick_val(&ctlr->right_stick_cal_y, raw_y);\n\t\t \n\t\tinput_report_abs(dev, ABS_RX, x);\n\t\tinput_report_abs(dev, ABS_RY, y);\n\n\t\t \n\t\tinput_report_key(dev, BTN_TR, btns & JC_BTN_R);\n\t\tinput_report_key(dev, BTN_TR2, btns & JC_BTN_ZR);\n\t\tif (jc_type_is_joycon(ctlr)) {\n\t\t\t \n\t\t\tinput_report_key(dev, BTN_TL, btns & JC_BTN_SL_R);\n\t\t\tinput_report_key(dev, BTN_TL2, btns & JC_BTN_SR_R);\n\t\t}\n\t\tinput_report_key(dev, BTN_START, btns & JC_BTN_PLUS);\n\t\tinput_report_key(dev, BTN_THUMBR, btns & JC_BTN_RSTICK);\n\t\tinput_report_key(dev, BTN_MODE, btns & JC_BTN_HOME);\n\t\tinput_report_key(dev, BTN_WEST, btns & JC_BTN_Y);\n\t\tinput_report_key(dev, BTN_NORTH, btns & JC_BTN_X);\n\t\tinput_report_key(dev, BTN_EAST, btns & JC_BTN_A);\n\t\tinput_report_key(dev, BTN_SOUTH, btns & JC_BTN_B);\n\t}\n\n\tinput_sync(dev);\n\n\tspin_lock_irqsave(&ctlr->lock, flags);\n\tctlr->last_input_report_msecs = msecs;\n\t \n\tif (report_delta_ms >= JC_INPUT_REPORT_MIN_DELTA &&\n\t    report_delta_ms <= JC_INPUT_REPORT_MAX_DELTA) {\n\t\tif (ctlr->consecutive_valid_report_deltas < JC_SUBCMD_VALID_DELTA_REQ)\n\t\t\tctlr->consecutive_valid_report_deltas++;\n\t} else {\n\t\tctlr->consecutive_valid_report_deltas = 0;\n\t}\n\t \n\tif (ctlr->hdev->bus == BUS_USB)\n\t\tctlr->consecutive_valid_report_deltas = JC_SUBCMD_VALID_DELTA_REQ;\n\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\t \n\tif (unlikely(mutex_is_locked(&ctlr->output_mutex))) {\n\t\tspin_lock_irqsave(&ctlr->lock, flags);\n\t\tctlr->received_input_report = true;\n\t\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\t\twake_up(&ctlr->wait);\n\t}\n\n\t \n\tif (rep->id == JC_INPUT_IMU_DATA)\n\t\tjoycon_parse_imu_report(ctlr, rep);\n}\n\nstatic int joycon_send_rumble_data(struct joycon_ctlr *ctlr)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct joycon_rumble_output rumble_output = { 0 };\n\n\tspin_lock_irqsave(&ctlr->lock, flags);\n\t \n\tif (ctlr->ctlr_state == JOYCON_CTLR_STATE_REMOVED) {\n\t\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tmemcpy(rumble_output.rumble_data,\n\t       ctlr->rumble_data[ctlr->rumble_queue_tail],\n\t       JC_RUMBLE_DATA_SIZE);\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\trumble_output.output_id = JC_OUTPUT_RUMBLE_ONLY;\n\trumble_output.packet_num = ctlr->subcmd_num;\n\tif (++ctlr->subcmd_num > 0xF)\n\t\tctlr->subcmd_num = 0;\n\n\tjoycon_enforce_subcmd_rate(ctlr);\n\n\tret = __joycon_hid_send(ctlr->hdev, (u8 *)&rumble_output,\n\t\t\t\tsizeof(rumble_output));\n\treturn ret;\n}\n\nstatic void joycon_rumble_worker(struct work_struct *work)\n{\n\tstruct joycon_ctlr *ctlr = container_of(work, struct joycon_ctlr,\n\t\t\t\t\t\t\trumble_worker);\n\tunsigned long flags;\n\tbool again = true;\n\tint ret;\n\n\twhile (again) {\n\t\tmutex_lock(&ctlr->output_mutex);\n\t\tret = joycon_send_rumble_data(ctlr);\n\t\tmutex_unlock(&ctlr->output_mutex);\n\n\t\t \n\t\tspin_lock_irqsave(&ctlr->lock, flags);\n\t\tif (ret < 0 && ret != -ENODEV &&\n\t\t    ctlr->ctlr_state != JOYCON_CTLR_STATE_REMOVED)\n\t\t\thid_warn(ctlr->hdev, \"Failed to set rumble; e=%d\", ret);\n\n\t\tctlr->rumble_msecs = jiffies_to_msecs(jiffies);\n\t\tif (ctlr->rumble_queue_tail != ctlr->rumble_queue_head) {\n\t\t\tif (++ctlr->rumble_queue_tail >= JC_RUMBLE_QUEUE_SIZE)\n\t\t\t\tctlr->rumble_queue_tail = 0;\n\t\t} else {\n\t\t\tagain = false;\n\t\t}\n\t\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_NINTENDO_FF)\nstatic struct joycon_rumble_freq_data joycon_find_rumble_freq(u16 freq)\n{\n\tconst size_t length = ARRAY_SIZE(joycon_rumble_frequencies);\n\tconst struct joycon_rumble_freq_data *data = joycon_rumble_frequencies;\n\tint i = 0;\n\n\tif (freq > data[0].freq) {\n\t\tfor (i = 1; i < length - 1; i++) {\n\t\t\tif (freq > data[i - 1].freq && freq <= data[i].freq)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn data[i];\n}\n\nstatic struct joycon_rumble_amp_data joycon_find_rumble_amp(u16 amp)\n{\n\tconst size_t length = ARRAY_SIZE(joycon_rumble_amplitudes);\n\tconst struct joycon_rumble_amp_data *data = joycon_rumble_amplitudes;\n\tint i = 0;\n\n\tif (amp > data[0].amp) {\n\t\tfor (i = 1; i < length - 1; i++) {\n\t\t\tif (amp > data[i - 1].amp && amp <= data[i].amp)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn data[i];\n}\n\nstatic void joycon_encode_rumble(u8 *data, u16 freq_low, u16 freq_high, u16 amp)\n{\n\tstruct joycon_rumble_freq_data freq_data_low;\n\tstruct joycon_rumble_freq_data freq_data_high;\n\tstruct joycon_rumble_amp_data amp_data;\n\n\tfreq_data_low = joycon_find_rumble_freq(freq_low);\n\tfreq_data_high = joycon_find_rumble_freq(freq_high);\n\tamp_data = joycon_find_rumble_amp(amp);\n\n\tdata[0] = (freq_data_high.high >> 8) & 0xFF;\n\tdata[1] = (freq_data_high.high & 0xFF) + amp_data.high;\n\tdata[2] = freq_data_low.low + ((amp_data.low >> 8) & 0xFF);\n\tdata[3] = amp_data.low & 0xFF;\n}\n\nstatic const u16 JOYCON_MAX_RUMBLE_HIGH_FREQ\t= 1253;\nstatic const u16 JOYCON_MIN_RUMBLE_HIGH_FREQ\t= 82;\nstatic const u16 JOYCON_MAX_RUMBLE_LOW_FREQ\t= 626;\nstatic const u16 JOYCON_MIN_RUMBLE_LOW_FREQ\t= 41;\n\nstatic void joycon_clamp_rumble_freqs(struct joycon_ctlr *ctlr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctlr->lock, flags);\n\tctlr->rumble_ll_freq = clamp(ctlr->rumble_ll_freq,\n\t\t\t\t     JOYCON_MIN_RUMBLE_LOW_FREQ,\n\t\t\t\t     JOYCON_MAX_RUMBLE_LOW_FREQ);\n\tctlr->rumble_lh_freq = clamp(ctlr->rumble_lh_freq,\n\t\t\t\t     JOYCON_MIN_RUMBLE_HIGH_FREQ,\n\t\t\t\t     JOYCON_MAX_RUMBLE_HIGH_FREQ);\n\tctlr->rumble_rl_freq = clamp(ctlr->rumble_rl_freq,\n\t\t\t\t     JOYCON_MIN_RUMBLE_LOW_FREQ,\n\t\t\t\t     JOYCON_MAX_RUMBLE_LOW_FREQ);\n\tctlr->rumble_rh_freq = clamp(ctlr->rumble_rh_freq,\n\t\t\t\t     JOYCON_MIN_RUMBLE_HIGH_FREQ,\n\t\t\t\t     JOYCON_MAX_RUMBLE_HIGH_FREQ);\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n}\n\nstatic int joycon_set_rumble(struct joycon_ctlr *ctlr, u16 amp_r, u16 amp_l,\n\t\t\t     bool schedule_now)\n{\n\tu8 data[JC_RUMBLE_DATA_SIZE];\n\tu16 amp;\n\tu16 freq_r_low;\n\tu16 freq_r_high;\n\tu16 freq_l_low;\n\tu16 freq_l_high;\n\tunsigned long flags;\n\tint next_rq_head;\n\n\tspin_lock_irqsave(&ctlr->lock, flags);\n\tfreq_r_low = ctlr->rumble_rl_freq;\n\tfreq_r_high = ctlr->rumble_rh_freq;\n\tfreq_l_low = ctlr->rumble_ll_freq;\n\tfreq_l_high = ctlr->rumble_lh_freq;\n\t \n\tif (amp_l != 0 || amp_r != 0)\n\t\tctlr->rumble_zero_countdown = JC_RUMBLE_ZERO_AMP_PKT_CNT;\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\t \n\tamp = amp_r * (u32)joycon_max_rumble_amp / 65535;\n\tjoycon_encode_rumble(data + 4, freq_r_low, freq_r_high, amp);\n\n\t \n\tamp = amp_l * (u32)joycon_max_rumble_amp / 65535;\n\tjoycon_encode_rumble(data, freq_l_low, freq_l_high, amp);\n\n\tspin_lock_irqsave(&ctlr->lock, flags);\n\n\tnext_rq_head = ctlr->rumble_queue_head + 1;\n\tif (next_rq_head >= JC_RUMBLE_QUEUE_SIZE)\n\t\tnext_rq_head = 0;\n\n\t \n\tif (next_rq_head == ctlr->rumble_queue_tail) {\n\t\thid_dbg(ctlr->hdev, \"rumble queue is full\");\n\t\t \n\t\tnext_rq_head = ctlr->rumble_queue_head;\n\t}\n\n\tctlr->rumble_queue_head = next_rq_head;\n\tmemcpy(ctlr->rumble_data[ctlr->rumble_queue_head], data,\n\t       JC_RUMBLE_DATA_SIZE);\n\n\t \n\tif (schedule_now && ctlr->ctlr_state != JOYCON_CTLR_STATE_REMOVED)\n\t\tqueue_work(ctlr->rumble_queue, &ctlr->rumble_worker);\n\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\treturn 0;\n}\n\nstatic int joycon_play_effect(struct input_dev *dev, void *data,\n\t\t\t\t\t\t     struct ff_effect *effect)\n{\n\tstruct joycon_ctlr *ctlr = input_get_drvdata(dev);\n\n\tif (effect->type != FF_RUMBLE)\n\t\treturn 0;\n\n\treturn joycon_set_rumble(ctlr,\n\t\t\t\t effect->u.rumble.weak_magnitude,\n\t\t\t\t effect->u.rumble.strong_magnitude,\n\t\t\t\t true);\n}\n#endif  \n\nstatic const unsigned int joycon_button_inputs_l[] = {\n\tBTN_SELECT, BTN_Z, BTN_THUMBL,\n\tBTN_TL, BTN_TL2,\n\t0  \n};\n\nstatic const unsigned int joycon_button_inputs_r[] = {\n\tBTN_START, BTN_MODE, BTN_THUMBR,\n\tBTN_SOUTH, BTN_EAST, BTN_NORTH, BTN_WEST,\n\tBTN_TR, BTN_TR2,\n\t0  \n};\n\n \nstatic const unsigned int joycon_dpad_inputs_jc[] = {\n\tBTN_DPAD_UP, BTN_DPAD_DOWN, BTN_DPAD_LEFT, BTN_DPAD_RIGHT,\n\t0  \n};\n\nstatic int joycon_input_create(struct joycon_ctlr *ctlr)\n{\n\tstruct hid_device *hdev;\n\tconst char *name;\n\tconst char *imu_name;\n\tint ret;\n\tint i;\n\n\thdev = ctlr->hdev;\n\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_NINTENDO_PROCON:\n\t\tname = \"Nintendo Switch Pro Controller\";\n\t\timu_name = \"Nintendo Switch Pro Controller IMU\";\n\t\tbreak;\n\tcase USB_DEVICE_ID_NINTENDO_CHRGGRIP:\n\t\tif (jc_type_has_left(ctlr)) {\n\t\t\tname = \"Nintendo Switch Left Joy-Con (Grip)\";\n\t\t\timu_name = \"Nintendo Switch Left Joy-Con IMU (Grip)\";\n\t\t} else {\n\t\t\tname = \"Nintendo Switch Right Joy-Con (Grip)\";\n\t\t\timu_name = \"Nintendo Switch Right Joy-Con IMU (Grip)\";\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_NINTENDO_JOYCONL:\n\t\tname = \"Nintendo Switch Left Joy-Con\";\n\t\timu_name = \"Nintendo Switch Left Joy-Con IMU\";\n\t\tbreak;\n\tcase USB_DEVICE_ID_NINTENDO_JOYCONR:\n\t\tname = \"Nintendo Switch Right Joy-Con\";\n\t\timu_name = \"Nintendo Switch Right Joy-Con IMU\";\n\t\tbreak;\n\tdefault:  \n\t\thid_err(hdev, \"Invalid hid product\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tctlr->input = devm_input_allocate_device(&hdev->dev);\n\tif (!ctlr->input)\n\t\treturn -ENOMEM;\n\tctlr->input->id.bustype = hdev->bus;\n\tctlr->input->id.vendor = hdev->vendor;\n\tctlr->input->id.product = hdev->product;\n\tctlr->input->id.version = hdev->version;\n\tctlr->input->uniq = ctlr->mac_addr_str;\n\tctlr->input->name = name;\n\tctlr->input->phys = hdev->phys;\n\tinput_set_drvdata(ctlr->input, ctlr);\n\n\t \n\tif (jc_type_has_left(ctlr)) {\n\t\tinput_set_abs_params(ctlr->input, ABS_X,\n\t\t\t\t     -JC_MAX_STICK_MAG, JC_MAX_STICK_MAG,\n\t\t\t\t     JC_STICK_FUZZ, JC_STICK_FLAT);\n\t\tinput_set_abs_params(ctlr->input, ABS_Y,\n\t\t\t\t     -JC_MAX_STICK_MAG, JC_MAX_STICK_MAG,\n\t\t\t\t     JC_STICK_FUZZ, JC_STICK_FLAT);\n\n\t\tfor (i = 0; joycon_button_inputs_l[i] > 0; i++)\n\t\t\tinput_set_capability(ctlr->input, EV_KEY,\n\t\t\t\t\t     joycon_button_inputs_l[i]);\n\n\t\t \n\t\tif (hdev->product != USB_DEVICE_ID_NINTENDO_PROCON) {\n\t\t\tfor (i = 0; joycon_dpad_inputs_jc[i] > 0; i++)\n\t\t\t\tinput_set_capability(ctlr->input, EV_KEY,\n\t\t\t\t\t\t     joycon_dpad_inputs_jc[i]);\n\t\t} else {\n\t\t\tinput_set_abs_params(ctlr->input, ABS_HAT0X,\n\t\t\t\t\t     -JC_MAX_DPAD_MAG, JC_MAX_DPAD_MAG,\n\t\t\t\t\t     JC_DPAD_FUZZ, JC_DPAD_FLAT);\n\t\t\tinput_set_abs_params(ctlr->input, ABS_HAT0Y,\n\t\t\t\t\t     -JC_MAX_DPAD_MAG, JC_MAX_DPAD_MAG,\n\t\t\t\t\t     JC_DPAD_FUZZ, JC_DPAD_FLAT);\n\t\t}\n\t}\n\tif (jc_type_has_right(ctlr)) {\n\t\tinput_set_abs_params(ctlr->input, ABS_RX,\n\t\t\t\t     -JC_MAX_STICK_MAG, JC_MAX_STICK_MAG,\n\t\t\t\t     JC_STICK_FUZZ, JC_STICK_FLAT);\n\t\tinput_set_abs_params(ctlr->input, ABS_RY,\n\t\t\t\t     -JC_MAX_STICK_MAG, JC_MAX_STICK_MAG,\n\t\t\t\t     JC_STICK_FUZZ, JC_STICK_FLAT);\n\n\t\tfor (i = 0; joycon_button_inputs_r[i] > 0; i++)\n\t\t\tinput_set_capability(ctlr->input, EV_KEY,\n\t\t\t\t\t     joycon_button_inputs_r[i]);\n\t}\n\n\t \n\tif (hdev->product == USB_DEVICE_ID_NINTENDO_JOYCONL) {\n\t\tinput_set_capability(ctlr->input, EV_KEY, BTN_TR);\n\t\tinput_set_capability(ctlr->input, EV_KEY, BTN_TR2);\n\t} else if (hdev->product == USB_DEVICE_ID_NINTENDO_JOYCONR) {\n\t\tinput_set_capability(ctlr->input, EV_KEY, BTN_TL);\n\t\tinput_set_capability(ctlr->input, EV_KEY, BTN_TL2);\n\t}\n\n#if IS_ENABLED(CONFIG_NINTENDO_FF)\n\t \n\tinput_set_capability(ctlr->input, EV_FF, FF_RUMBLE);\n\tinput_ff_create_memless(ctlr->input, NULL, joycon_play_effect);\n\tctlr->rumble_ll_freq = JC_RUMBLE_DFLT_LOW_FREQ;\n\tctlr->rumble_lh_freq = JC_RUMBLE_DFLT_HIGH_FREQ;\n\tctlr->rumble_rl_freq = JC_RUMBLE_DFLT_LOW_FREQ;\n\tctlr->rumble_rh_freq = JC_RUMBLE_DFLT_HIGH_FREQ;\n\tjoycon_clamp_rumble_freqs(ctlr);\n\tjoycon_set_rumble(ctlr, 0, 0, false);\n\tctlr->rumble_msecs = jiffies_to_msecs(jiffies);\n#endif\n\n\tret = input_register_device(ctlr->input);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tctlr->imu_input = devm_input_allocate_device(&hdev->dev);\n\tif (!ctlr->imu_input)\n\t\treturn -ENOMEM;\n\n\tctlr->imu_input->id.bustype = hdev->bus;\n\tctlr->imu_input->id.vendor = hdev->vendor;\n\tctlr->imu_input->id.product = hdev->product;\n\tctlr->imu_input->id.version = hdev->version;\n\tctlr->imu_input->uniq = ctlr->mac_addr_str;\n\tctlr->imu_input->name = imu_name;\n\tctlr->imu_input->phys = hdev->phys;\n\tinput_set_drvdata(ctlr->imu_input, ctlr);\n\n\t \n\tinput_set_abs_params(ctlr->imu_input, ABS_X,\n\t\t\t     -JC_IMU_MAX_ACCEL_MAG, JC_IMU_MAX_ACCEL_MAG,\n\t\t\t     JC_IMU_ACCEL_FUZZ, JC_IMU_ACCEL_FLAT);\n\tinput_set_abs_params(ctlr->imu_input, ABS_Y,\n\t\t\t     -JC_IMU_MAX_ACCEL_MAG, JC_IMU_MAX_ACCEL_MAG,\n\t\t\t     JC_IMU_ACCEL_FUZZ, JC_IMU_ACCEL_FLAT);\n\tinput_set_abs_params(ctlr->imu_input, ABS_Z,\n\t\t\t     -JC_IMU_MAX_ACCEL_MAG, JC_IMU_MAX_ACCEL_MAG,\n\t\t\t     JC_IMU_ACCEL_FUZZ, JC_IMU_ACCEL_FLAT);\n\tinput_abs_set_res(ctlr->imu_input, ABS_X, JC_IMU_ACCEL_RES_PER_G);\n\tinput_abs_set_res(ctlr->imu_input, ABS_Y, JC_IMU_ACCEL_RES_PER_G);\n\tinput_abs_set_res(ctlr->imu_input, ABS_Z, JC_IMU_ACCEL_RES_PER_G);\n\n\tinput_set_abs_params(ctlr->imu_input, ABS_RX,\n\t\t\t     -JC_IMU_MAX_GYRO_MAG, JC_IMU_MAX_GYRO_MAG,\n\t\t\t     JC_IMU_GYRO_FUZZ, JC_IMU_GYRO_FLAT);\n\tinput_set_abs_params(ctlr->imu_input, ABS_RY,\n\t\t\t     -JC_IMU_MAX_GYRO_MAG, JC_IMU_MAX_GYRO_MAG,\n\t\t\t     JC_IMU_GYRO_FUZZ, JC_IMU_GYRO_FLAT);\n\tinput_set_abs_params(ctlr->imu_input, ABS_RZ,\n\t\t\t     -JC_IMU_MAX_GYRO_MAG, JC_IMU_MAX_GYRO_MAG,\n\t\t\t     JC_IMU_GYRO_FUZZ, JC_IMU_GYRO_FLAT);\n\n\tinput_abs_set_res(ctlr->imu_input, ABS_RX, JC_IMU_GYRO_RES_PER_DPS);\n\tinput_abs_set_res(ctlr->imu_input, ABS_RY, JC_IMU_GYRO_RES_PER_DPS);\n\tinput_abs_set_res(ctlr->imu_input, ABS_RZ, JC_IMU_GYRO_RES_PER_DPS);\n\n\t__set_bit(EV_MSC, ctlr->imu_input->evbit);\n\t__set_bit(MSC_TIMESTAMP, ctlr->imu_input->mscbit);\n\t__set_bit(INPUT_PROP_ACCELEROMETER, ctlr->imu_input->propbit);\n\n\tret = input_register_device(ctlr->imu_input);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int joycon_player_led_brightness_set(struct led_classdev *led,\n\t\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct device *dev = led->dev->parent;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct joycon_ctlr *ctlr;\n\tint val = 0;\n\tint i;\n\tint ret;\n\tint num;\n\n\tctlr = hid_get_drvdata(hdev);\n\tif (!ctlr) {\n\t\thid_err(hdev, \"No controller data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (num = 0; num < JC_NUM_LEDS; num++) {\n\t\tif (&ctlr->leds[num] == led)\n\t\t\tbreak;\n\t}\n\tif (num >= JC_NUM_LEDS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ctlr->output_mutex);\n\tfor (i = 0; i < JC_NUM_LEDS; i++) {\n\t\tif (i == num)\n\t\t\tval |= brightness << i;\n\t\telse\n\t\t\tval |= ctlr->leds[i].brightness << i;\n\t}\n\tret = joycon_set_player_leds(ctlr, 0, val);\n\tmutex_unlock(&ctlr->output_mutex);\n\n\treturn ret;\n}\n\nstatic int joycon_home_led_brightness_set(struct led_classdev *led,\n\t\t\t\t\t  enum led_brightness brightness)\n{\n\tstruct device *dev = led->dev->parent;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct joycon_ctlr *ctlr;\n\tstruct joycon_subcmd_request *req;\n\tu8 buffer[sizeof(*req) + 5] = { 0 };\n\tu8 *data;\n\tint ret;\n\n\tctlr = hid_get_drvdata(hdev);\n\tif (!ctlr) {\n\t\thid_err(hdev, \"No controller data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treq = (struct joycon_subcmd_request *)buffer;\n\treq->subcmd_id = JC_SUBCMD_SET_HOME_LIGHT;\n\tdata = req->data;\n\tdata[0] = 0x01;\n\tdata[1] = brightness << 4;\n\tdata[2] = brightness | (brightness << 4);\n\tdata[3] = 0x11;\n\tdata[4] = 0x11;\n\n\thid_dbg(hdev, \"setting home led brightness\\n\");\n\tmutex_lock(&ctlr->output_mutex);\n\tret = joycon_send_subcmd(ctlr, req, 5, HZ/4);\n\tmutex_unlock(&ctlr->output_mutex);\n\n\treturn ret;\n}\n\nstatic DEFINE_MUTEX(joycon_input_num_mutex);\nstatic int joycon_leds_create(struct joycon_ctlr *ctlr)\n{\n\tstruct hid_device *hdev = ctlr->hdev;\n\tstruct device *dev = &hdev->dev;\n\tconst char *d_name = dev_name(dev);\n\tstruct led_classdev *led;\n\tchar *name;\n\tint ret = 0;\n\tint i;\n\tstatic int input_num = 1;\n\n\t \n\tmutex_lock(&joycon_input_num_mutex);\n\tmutex_lock(&ctlr->output_mutex);\n\tret = joycon_set_player_leds(ctlr, 0, 0xF >> (4 - input_num));\n\tif (ret)\n\t\thid_warn(ctlr->hdev, \"Failed to set leds; ret=%d\\n\", ret);\n\tmutex_unlock(&ctlr->output_mutex);\n\n\t \n\tfor (i = 0; i < JC_NUM_LEDS; i++) {\n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s:%s:%s\",\n\t\t\t\t      d_name,\n\t\t\t\t      \"green\",\n\t\t\t\t      joycon_player_led_names[i]);\n\t\tif (!name) {\n\t\t\tmutex_unlock(&joycon_input_num_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tled = &ctlr->leds[i];\n\t\tled->name = name;\n\t\tled->brightness = ((i + 1) <= input_num) ? 1 : 0;\n\t\tled->max_brightness = 1;\n\t\tled->brightness_set_blocking =\n\t\t\t\t\tjoycon_player_led_brightness_set;\n\t\tled->flags = LED_CORE_SUSPENDRESUME | LED_HW_PLUGGABLE;\n\n\t\tret = devm_led_classdev_register(&hdev->dev, led);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Failed registering %s LED\\n\", led->name);\n\t\t\tmutex_unlock(&joycon_input_num_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (++input_num > 4)\n\t\tinput_num = 1;\n\tmutex_unlock(&joycon_input_num_mutex);\n\n\t \n\tif (jc_type_has_right(ctlr)) {\n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s:%s:%s\",\n\t\t\t\t      d_name,\n\t\t\t\t      \"blue\",\n\t\t\t\t      LED_FUNCTION_PLAYER5);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tled = &ctlr->home_led;\n\t\tled->name = name;\n\t\tled->brightness = 0;\n\t\tled->max_brightness = 0xF;\n\t\tled->brightness_set_blocking = joycon_home_led_brightness_set;\n\t\tled->flags = LED_CORE_SUSPENDRESUME | LED_HW_PLUGGABLE;\n\t\tret = devm_led_classdev_register(&hdev->dev, led);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Failed registering home led\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = joycon_home_led_brightness_set(led, 0);\n\t\tif (ret) {\n\t\t\thid_warn(hdev, \"Failed to set home LED default, unregistering home LED\");\n\t\t\tdevm_led_classdev_unregister(&hdev->dev, led);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int joycon_battery_get_property(struct power_supply *supply,\n\t\t\t\t       enum power_supply_property prop,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tstruct joycon_ctlr *ctlr = power_supply_get_drvdata(supply);\n\tunsigned long flags;\n\tint ret = 0;\n\tu8 capacity;\n\tbool charging;\n\tbool powered;\n\n\tspin_lock_irqsave(&ctlr->lock, flags);\n\tcapacity = ctlr->battery_capacity;\n\tcharging = ctlr->battery_charging;\n\tpowered = ctlr->host_powered;\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\tswitch (prop) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\tval->intval = capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tif (charging)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\telse if (capacity == POWER_SUPPLY_CAPACITY_LEVEL_FULL &&\n\t\t\t powered)\n\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic enum power_supply_property joycon_battery_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_STATUS,\n};\n\nstatic int joycon_power_supply_create(struct joycon_ctlr *ctlr)\n{\n\tstruct hid_device *hdev = ctlr->hdev;\n\tstruct power_supply_config supply_config = { .drv_data = ctlr, };\n\tconst char * const name_fmt = \"nintendo_switch_controller_battery_%s\";\n\tint ret = 0;\n\n\t \n\tctlr->battery_capacity = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\n\n\t \n\tctlr->battery_desc.properties = joycon_battery_props;\n\tctlr->battery_desc.num_properties =\n\t\t\t\t\tARRAY_SIZE(joycon_battery_props);\n\tctlr->battery_desc.get_property = joycon_battery_get_property;\n\tctlr->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tctlr->battery_desc.use_for_apm = 0;\n\tctlr->battery_desc.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t name_fmt,\n\t\t\t\t\t\t dev_name(&hdev->dev));\n\tif (!ctlr->battery_desc.name)\n\t\treturn -ENOMEM;\n\n\tctlr->battery = devm_power_supply_register(&hdev->dev,\n\t\t\t\t\t\t   &ctlr->battery_desc,\n\t\t\t\t\t\t   &supply_config);\n\tif (IS_ERR(ctlr->battery)) {\n\t\tret = PTR_ERR(ctlr->battery);\n\t\thid_err(hdev, \"Failed to register battery; ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn power_supply_powers(ctlr->battery, &hdev->dev);\n}\n\nstatic int joycon_read_info(struct joycon_ctlr *ctlr)\n{\n\tint ret;\n\tint i;\n\tint j;\n\tstruct joycon_subcmd_request req = { 0 };\n\tstruct joycon_input_report *report;\n\n\treq.subcmd_id = JC_SUBCMD_REQ_DEV_INFO;\n\tmutex_lock(&ctlr->output_mutex);\n\tret = joycon_send_subcmd(ctlr, &req, 0, HZ);\n\tmutex_unlock(&ctlr->output_mutex);\n\tif (ret) {\n\t\thid_err(ctlr->hdev, \"Failed to get joycon info; ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treport = (struct joycon_input_report *)ctlr->input_buf;\n\n\tfor (i = 4, j = 0; j < 6; i++, j++)\n\t\tctlr->mac_addr[j] = report->subcmd_reply.data[i];\n\n\tctlr->mac_addr_str = devm_kasprintf(&ctlr->hdev->dev, GFP_KERNEL,\n\t\t\t\t\t    \"%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\t\t    ctlr->mac_addr[0],\n\t\t\t\t\t    ctlr->mac_addr[1],\n\t\t\t\t\t    ctlr->mac_addr[2],\n\t\t\t\t\t    ctlr->mac_addr[3],\n\t\t\t\t\t    ctlr->mac_addr[4],\n\t\t\t\t\t    ctlr->mac_addr[5]);\n\tif (!ctlr->mac_addr_str)\n\t\treturn -ENOMEM;\n\thid_info(ctlr->hdev, \"controller MAC = %s\\n\", ctlr->mac_addr_str);\n\n\t \n\tctlr->ctlr_type = report->subcmd_reply.data[2];\n\n\treturn 0;\n}\n\nstatic int joycon_init(struct hid_device *hdev)\n{\n\tstruct joycon_ctlr *ctlr = hid_get_drvdata(hdev);\n\tint ret = 0;\n\n\tmutex_lock(&ctlr->output_mutex);\n\t \n\tif ((jc_type_is_procon(ctlr) || jc_type_is_chrggrip(ctlr)) &&\n\t    !joycon_send_usb(ctlr, JC_USB_CMD_HANDSHAKE, HZ)) {\n\t\thid_dbg(hdev, \"detected USB controller\\n\");\n\t\t \n\t\tret = joycon_send_usb(ctlr, JC_USB_CMD_BAUDRATE_3M, HZ);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Failed to set baudrate; ret=%d\\n\", ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t \n\t\tret = joycon_send_usb(ctlr, JC_USB_CMD_HANDSHAKE, HZ);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Failed handshake; ret=%d\\n\", ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t \n\t\tjoycon_send_usb(ctlr, JC_USB_CMD_NO_TIMEOUT, HZ/10);\n\t} else if (jc_type_is_chrggrip(ctlr)) {\n\t\thid_err(hdev, \"Failed charging grip handshake\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tret = joycon_request_calibration(ctlr);\n\tif (ret) {\n\t\t \n\t\thid_warn(hdev, \"Analog stick positions may be inaccurate\\n\");\n\t}\n\n\t \n\tret = joycon_request_imu_calibration(ctlr);\n\tif (ret) {\n\t\t \n\t\thid_warn(hdev, \"Unable to read IMU calibration data\\n\");\n\t}\n\n\t \n\tret = joycon_set_report_mode(ctlr);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to set report mode; ret=%d\\n\", ret);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tret = joycon_enable_rumble(ctlr);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to enable rumble; ret=%d\\n\", ret);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tret = joycon_enable_imu(ctlr);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to enable the IMU; ret=%d\\n\", ret);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&ctlr->output_mutex);\n\treturn ret;\n}\n\n \nstatic int joycon_ctlr_read_handler(struct joycon_ctlr *ctlr, u8 *data,\n\t\t\t\t\t\t\t      int size)\n{\n\tif (data[0] == JC_INPUT_SUBCMD_REPLY || data[0] == JC_INPUT_IMU_DATA ||\n\t    data[0] == JC_INPUT_MCU_DATA) {\n\t\tif (size >= 12)  \n\t\t\tjoycon_parse_report(ctlr,\n\t\t\t\t\t    (struct joycon_input_report *)data);\n\t}\n\n\treturn 0;\n}\n\nstatic int joycon_ctlr_handle_event(struct joycon_ctlr *ctlr, u8 *data,\n\t\t\t\t\t\t\t      int size)\n{\n\tint ret = 0;\n\tbool match = false;\n\tstruct joycon_input_report *report;\n\n\tif (unlikely(mutex_is_locked(&ctlr->output_mutex)) &&\n\t    ctlr->msg_type != JOYCON_MSG_TYPE_NONE) {\n\t\tswitch (ctlr->msg_type) {\n\t\tcase JOYCON_MSG_TYPE_USB:\n\t\t\tif (size < 2)\n\t\t\t\tbreak;\n\t\t\tif (data[0] == JC_INPUT_USB_RESPONSE &&\n\t\t\t    data[1] == ctlr->usb_ack_match)\n\t\t\t\tmatch = true;\n\t\t\tbreak;\n\t\tcase JOYCON_MSG_TYPE_SUBCMD:\n\t\t\tif (size < sizeof(struct joycon_input_report) ||\n\t\t\t    data[0] != JC_INPUT_SUBCMD_REPLY)\n\t\t\t\tbreak;\n\t\t\treport = (struct joycon_input_report *)data;\n\t\t\tif (report->subcmd_reply.id == ctlr->subcmd_ack_match)\n\t\t\t\tmatch = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (match) {\n\t\t\tmemcpy(ctlr->input_buf, data,\n\t\t\t       min(size, (int)JC_MAX_RESP_SIZE));\n\t\t\tctlr->msg_type = JOYCON_MSG_TYPE_NONE;\n\t\t\tctlr->received_resp = true;\n\t\t\twake_up(&ctlr->wait);\n\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (ctlr->ctlr_state == JOYCON_CTLR_STATE_READ)\n\t\tret = joycon_ctlr_read_handler(ctlr, data, size);\n\n\treturn ret;\n}\n\nstatic int nintendo_hid_event(struct hid_device *hdev,\n\t\t\t      struct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct joycon_ctlr *ctlr = hid_get_drvdata(hdev);\n\n\tif (size < 1)\n\t\treturn -EINVAL;\n\n\treturn joycon_ctlr_handle_event(ctlr, raw_data, size);\n}\n\nstatic int nintendo_hid_probe(struct hid_device *hdev,\n\t\t\t    const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct joycon_ctlr *ctlr;\n\n\thid_dbg(hdev, \"probe - start\\n\");\n\n\tctlr = devm_kzalloc(&hdev->dev, sizeof(*ctlr), GFP_KERNEL);\n\tif (!ctlr) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tctlr->hdev = hdev;\n\tctlr->ctlr_state = JOYCON_CTLR_STATE_INIT;\n\tctlr->rumble_queue_head = 0;\n\tctlr->rumble_queue_tail = 0;\n\thid_set_drvdata(hdev, ctlr);\n\tmutex_init(&ctlr->output_mutex);\n\tinit_waitqueue_head(&ctlr->wait);\n\tspin_lock_init(&ctlr->lock);\n\tctlr->rumble_queue = alloc_workqueue(\"hid-nintendo-rumble_wq\",\n\t\t\t\t\t     WQ_FREEZABLE | WQ_MEM_RECLAIM, 0);\n\tif (!ctlr->rumble_queue) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tINIT_WORK(&ctlr->rumble_worker, joycon_rumble_worker);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"HID parse failed\\n\");\n\t\tgoto err_wq;\n\t}\n\n\t \n\thdev->version |= 0x8000;\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"HW start failed\\n\");\n\t\tgoto err_wq;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"cannot start hardware I/O\\n\");\n\t\tgoto err_stop;\n\t}\n\n\thid_device_io_start(hdev);\n\n\tret = joycon_init(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to initialize controller; ret=%d\\n\", ret);\n\t\tgoto err_close;\n\t}\n\n\tret = joycon_read_info(ctlr);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to retrieve controller info; ret=%d\\n\",\n\t\t\tret);\n\t\tgoto err_close;\n\t}\n\n\t \n\tret = joycon_leds_create(ctlr);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to create leds; ret=%d\\n\", ret);\n\t\tgoto err_close;\n\t}\n\n\t \n\tret = joycon_power_supply_create(ctlr);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to create power_supply; ret=%d\\n\", ret);\n\t\tgoto err_close;\n\t}\n\n\tret = joycon_input_create(ctlr);\n\tif (ret) {\n\t\thid_err(hdev, \"Failed to create input device; ret=%d\\n\", ret);\n\t\tgoto err_close;\n\t}\n\n\tctlr->ctlr_state = JOYCON_CTLR_STATE_READ;\n\n\thid_dbg(hdev, \"probe - success\\n\");\n\treturn 0;\n\nerr_close:\n\thid_hw_close(hdev);\nerr_stop:\n\thid_hw_stop(hdev);\nerr_wq:\n\tdestroy_workqueue(ctlr->rumble_queue);\nerr:\n\thid_err(hdev, \"probe - fail = %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void nintendo_hid_remove(struct hid_device *hdev)\n{\n\tstruct joycon_ctlr *ctlr = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\thid_dbg(hdev, \"remove\\n\");\n\n\t \n\tspin_lock_irqsave(&ctlr->lock, flags);\n\tctlr->ctlr_state = JOYCON_CTLR_STATE_REMOVED;\n\tspin_unlock_irqrestore(&ctlr->lock, flags);\n\n\tdestroy_workqueue(ctlr->rumble_queue);\n\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\n#ifdef CONFIG_PM\n\nstatic int nintendo_hid_resume(struct hid_device *hdev)\n{\n\tint ret = joycon_init(hdev);\n\n\tif (ret)\n\t\thid_err(hdev, \"Failed to restore controller after resume\");\n\n\treturn ret;\n}\n\n#endif\n\nstatic const struct hid_device_id nintendo_hid_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NINTENDO,\n\t\t\t USB_DEVICE_ID_NINTENDO_PROCON) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO,\n\t\t\t USB_DEVICE_ID_NINTENDO_PROCON) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NINTENDO,\n\t\t\t USB_DEVICE_ID_NINTENDO_CHRGGRIP) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO,\n\t\t\t USB_DEVICE_ID_NINTENDO_JOYCONL) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO,\n\t\t\t USB_DEVICE_ID_NINTENDO_JOYCONR) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, nintendo_hid_devices);\n\nstatic struct hid_driver nintendo_hid_driver = {\n\t.name\t\t= \"nintendo\",\n\t.id_table\t= nintendo_hid_devices,\n\t.probe\t\t= nintendo_hid_probe,\n\t.remove\t\t= nintendo_hid_remove,\n\t.raw_event\t= nintendo_hid_event,\n\n#ifdef CONFIG_PM\n\t.resume\t\t= nintendo_hid_resume,\n#endif\n};\nmodule_hid_driver(nintendo_hid_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Daniel J. Ogorchock <djogorchock@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver for Nintendo Switch Controllers\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}