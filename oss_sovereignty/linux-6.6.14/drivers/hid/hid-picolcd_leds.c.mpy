{
  "module_name": "hid-picolcd_leds.c",
  "hash_id": "417b32eccb4bff2e36f88c32663c2f75071d7ebdc8f2b8c2427595918834ca5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-picolcd_leds.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/hid-debug.h>\n#include <linux/input.h>\n#include \"hid-ids.h\"\n\n#include <linux/fb.h>\n#include <linux/vmalloc.h>\n#include <linux/backlight.h>\n#include <linux/lcd.h>\n\n#include <linux/leds.h>\n\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n\n#include <linux/completion.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#include \"hid-picolcd.h\"\n\n\nvoid picolcd_leds_set(struct picolcd_data *data)\n{\n\tstruct hid_report *report;\n\tunsigned long flags;\n\n\tif (!data->led[0])\n\t\treturn;\n\treport = picolcd_out_report(REPORT_LED_STATE, data->hdev);\n\tif (!report || report->maxfield != 1 || report->field[0]->report_count != 1)\n\t\treturn;\n\n\tspin_lock_irqsave(&data->lock, flags);\n\thid_set_field(report->field[0], 0, data->led_state);\n\tif (!(data->status & PICOLCD_FAILED))\n\t\thid_hw_request(data->hdev, report, HID_REQ_SET_REPORT);\n\tspin_unlock_irqrestore(&data->lock, flags);\n}\n\nstatic void picolcd_led_set_brightness(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct device *dev;\n\tstruct hid_device *hdev;\n\tstruct picolcd_data *data;\n\tint i, state = 0;\n\n\tdev  = led_cdev->dev->parent;\n\thdev = to_hid_device(dev);\n\tdata = hid_get_drvdata(hdev);\n\tif (!data)\n\t\treturn;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (led_cdev != data->led[i])\n\t\t\tcontinue;\n\t\tstate = (data->led_state >> i) & 1;\n\t\tif (value == LED_OFF && state) {\n\t\t\tdata->led_state &= ~(1 << i);\n\t\t\tpicolcd_leds_set(data);\n\t\t} else if (value != LED_OFF && !state) {\n\t\t\tdata->led_state |= 1 << i;\n\t\t\tpicolcd_leds_set(data);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic enum led_brightness picolcd_led_get_brightness(struct led_classdev *led_cdev)\n{\n\tstruct device *dev;\n\tstruct hid_device *hdev;\n\tstruct picolcd_data *data;\n\tint i, value = 0;\n\n\tdev  = led_cdev->dev->parent;\n\thdev = to_hid_device(dev);\n\tdata = hid_get_drvdata(hdev);\n\tfor (i = 0; i < 8; i++)\n\t\tif (led_cdev == data->led[i]) {\n\t\t\tvalue = (data->led_state >> i) & 1;\n\t\t\tbreak;\n\t\t}\n\treturn value ? LED_FULL : LED_OFF;\n}\n\nint picolcd_init_leds(struct picolcd_data *data, struct hid_report *report)\n{\n\tstruct device *dev = &data->hdev->dev;\n\tstruct led_classdev *led;\n\tsize_t name_sz = strlen(dev_name(dev)) + 8;\n\tchar *name;\n\tint i, ret = 0;\n\n\tif (!report)\n\t\treturn -ENODEV;\n\tif (report->maxfield != 1 || report->field[0]->report_count != 1 ||\n\t\t\treport->field[0]->report_size != 8) {\n\t\tdev_err(dev, \"unsupported LED_STATE report\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\t\tif (!led) {\n\t\t\tdev_err(dev, \"can't allocate memory for LED %d\\n\", i);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tname = (void *)(&led[1]);\n\t\tsnprintf(name, name_sz, \"%s::GPO%d\", dev_name(dev), i);\n\t\tled->name = name;\n\t\tled->brightness = 0;\n\t\tled->max_brightness = 1;\n\t\tled->brightness_get = picolcd_led_get_brightness;\n\t\tled->brightness_set = picolcd_led_set_brightness;\n\n\t\tdata->led[i] = led;\n\t\tret = led_classdev_register(dev, data->led[i]);\n\t\tif (ret) {\n\t\t\tdata->led[i] = NULL;\n\t\t\tkfree(led);\n\t\t\tdev_err(dev, \"can't register LED %d\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tfor (i = 0; i < 8; i++)\n\t\tif (data->led[i]) {\n\t\t\tled = data->led[i];\n\t\t\tdata->led[i] = NULL;\n\t\t\tled_classdev_unregister(led);\n\t\t\tkfree(led);\n\t\t}\n\treturn ret;\n}\n\nvoid picolcd_exit_leds(struct picolcd_data *data)\n{\n\tstruct led_classdev *led;\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tled = data->led[i];\n\t\tdata->led[i] = NULL;\n\t\tif (!led)\n\t\t\tcontinue;\n\t\tled_classdev_unregister(led);\n\t\tkfree(led);\n\t}\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}