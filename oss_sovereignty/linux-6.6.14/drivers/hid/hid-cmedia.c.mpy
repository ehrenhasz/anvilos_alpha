{
  "module_name": "hid-cmedia.c",
  "hash_id": "bfea6c9d506bbca8f2ff278eb999d84fb9e29e8efbae6d0d1a81470eef2b002d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-cmedia.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include \"hid-ids.h\"\n\nMODULE_AUTHOR(\"Ben Chen\");\nMODULE_AUTHOR(\"Thomas Wei\u00dfschuh\");\nMODULE_DESCRIPTION(\"CM6533 HID jack controls and HS100B mute button\");\nMODULE_LICENSE(\"GPL\");\n\n#define CM6533_JD_TYPE_COUNT      1\n#define CM6533_JD_RAWEV_LEN\t 16\n#define CM6533_JD_SFX_OFFSET\t  8\n\n#define HS100B_RDESC_ORIG_SIZE   60\n\n \nstatic __u8 hs100b_rdesc_fixed[] = {\n\t0x05, 0x0C,          \n\t0x09, 0x01,          \n\t0xA1, 0x01,          \n\t0x15, 0x00,          \n\t0x25, 0x01,          \n\t0x09, 0xE9,          \n\t0x09, 0xEA,          \n\t0x75, 0x01,          \n\t0x95, 0x02,          \n\t0x81, 0x02,          \n\t0x09, 0xE2,          \n\t0x95, 0x01,          \n\t0x81, 0x06,          \n\t0x05, 0x0B,          \n\t0x09, 0x2F,          \n\t0x81, 0x02,          \n\t0x09, 0x20,          \n\t0x81, 0x06,          \n\t0x05, 0x0C,          \n\t0x09, 0x00,          \n\t0x95, 0x03,          \n\t0x81, 0x02,          \n\t0x26, 0xFF, 0x00,    \n\t0x09, 0x00,          \n\t0x75, 0x08,          \n\t0x95, 0x03,          \n\t0x81, 0x02,          \n\t0x09, 0x00,          \n\t0x95, 0x04,          \n\t0x91, 0x02,          \n\t0xC0                 \n};\n\n \n\nstatic const u8 ji_sfx[] = { 0x08, 0x00, 0x08, 0xc0 };\nstatic const u8 ji_in[]  = { 0x01, 0x00, 0x06, 0x00 };\nstatic const u8 ji_out[] = { 0x01, 0x00, 0x04, 0x00 };\n\nstatic int jack_switch_types[CM6533_JD_TYPE_COUNT] = {\n\tSW_HEADPHONE_INSERT,\n};\n\nstruct cmhid {\n\tstruct input_dev *input_dev;\n\tstruct hid_device *hid;\n\tunsigned short switch_map[CM6533_JD_TYPE_COUNT];\n};\n\nstatic void hp_ev(struct hid_device *hid, struct cmhid *cm, int value)\n{\n\tinput_report_switch(cm->input_dev, SW_HEADPHONE_INSERT, value);\n\tinput_sync(cm->input_dev);\n}\n\nstatic int cmhid_raw_event(struct hid_device *hid, struct hid_report *report,\n\t u8 *data, int len)\n{\n\tstruct cmhid *cm = hid_get_drvdata(hid);\n\n\tif (len != CM6533_JD_RAWEV_LEN)\n\t\tgoto out;\n\tif (memcmp(data+CM6533_JD_SFX_OFFSET, ji_sfx, sizeof(ji_sfx)))\n\t\tgoto out;\n\n\tif (!memcmp(data, ji_out, sizeof(ji_out))) {\n\t\thp_ev(hid, cm, 0);\n\t\tgoto out;\n\t}\n\tif (!memcmp(data, ji_in, sizeof(ji_in))) {\n\t\thp_ev(hid, cm, 1);\n\t\tgoto out;\n\t}\n\nout:\n\treturn 0;\n}\n\nstatic int cmhid_input_configured(struct hid_device *hid,\n\t\tstruct hid_input *hidinput)\n{\n\tstruct input_dev *input_dev = hidinput->input;\n\tstruct cmhid *cm = hid_get_drvdata(hid);\n\tint i;\n\n\tcm->input_dev = input_dev;\n\tmemcpy(cm->switch_map, jack_switch_types, sizeof(cm->switch_map));\n\tinput_dev->evbit[0] = BIT(EV_SW);\n\tfor (i = 0; i < CM6533_JD_TYPE_COUNT; i++)\n\t\tinput_set_capability(cm->input_dev,\n\t\t\t\tEV_SW, jack_switch_types[i]);\n\treturn 0;\n}\n\nstatic int cmhid_input_mapping(struct hid_device *hid,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\treturn -1;\n}\n\nstatic int cmhid_probe(struct hid_device *hid, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct cmhid *cm;\n\n\tcm = kzalloc(sizeof(struct cmhid), GFP_KERNEL);\n\tif (!cm) {\n\t\tret = -ENOMEM;\n\t\tgoto allocfail;\n\t}\n\n\tcm->hid = hid;\n\n\thid->quirks |= HID_QUIRK_HIDINPUT_FORCE;\n\thid_set_drvdata(hid, cm);\n\n\tret = hid_parse(hid);\n\tif (ret) {\n\t\thid_err(hid, \"parse failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = hid_hw_start(hid, HID_CONNECT_DEFAULT | HID_CONNECT_HIDDEV_FORCE);\n\tif (ret) {\n\t\thid_err(hid, \"hw start failed\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tkfree(cm);\nallocfail:\n\treturn ret;\n}\n\nstatic void cmhid_remove(struct hid_device *hid)\n{\n\tstruct cmhid *cm = hid_get_drvdata(hid);\n\n\thid_hw_stop(hid);\n\tkfree(cm);\n}\n\nstatic const struct hid_device_id cmhid_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CMEDIA, USB_DEVICE_ID_CM6533) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, cmhid_devices);\n\nstatic struct hid_driver cmhid_driver = {\n\t.name = \"cm6533_jd\",\n\t.id_table = cmhid_devices,\n\t.raw_event = cmhid_raw_event,\n\t.input_configured = cmhid_input_configured,\n\t.probe = cmhid_probe,\n\t.remove = cmhid_remove,\n\t.input_mapping = cmhid_input_mapping,\n};\n\nstatic __u8 *cmhid_hs100b_report_fixup(struct hid_device *hid, __u8 *rdesc,\n\t\t\t\t       unsigned int *rsize)\n{\n\tif (*rsize == HS100B_RDESC_ORIG_SIZE) {\n\t\thid_info(hid, \"Fixing CMedia HS-100B report descriptor\\n\");\n\t\trdesc = hs100b_rdesc_fixed;\n\t\t*rsize = sizeof(hs100b_rdesc_fixed);\n\t}\n\treturn rdesc;\n}\n\nstatic const struct hid_device_id cmhid_hs100b_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CMEDIA, USB_DEVICE_ID_CMEDIA_HS100B) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, cmhid_hs100b_devices);\n\nstatic struct hid_driver cmhid_hs100b_driver = {\n\t.name = \"cmedia_hs100b\",\n\t.id_table = cmhid_hs100b_devices,\n\t.report_fixup = cmhid_hs100b_report_fixup,\n};\n\nstatic int cmedia_init(void)\n{\n\tint ret;\n\n\tret = hid_register_driver(&cmhid_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hid_register_driver(&cmhid_hs100b_driver);\n\tif (ret)\n\t\thid_unregister_driver(&cmhid_driver);\n\n\treturn ret;\n}\nmodule_init(cmedia_init);\n\nstatic void cmedia_exit(void)\n{\n\t\thid_unregister_driver(&cmhid_driver);\n\t\thid_unregister_driver(&cmhid_hs100b_driver);\n}\nmodule_exit(cmedia_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}