{
  "module_name": "hid-logitech-dj.c",
  "hash_id": "a120d78d829598e89458d92d7ad3975cc567fa9a119f0f0737196f449318ce29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-logitech-dj.c",
  "human_readable_source": "\n \n\n\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/kfifo.h>\n#include <linux/delay.h>\n#include <linux/usb.h>  \n#include <asm/unaligned.h>\n#include \"hid-ids.h\"\n\n#define DJ_MAX_PAIRED_DEVICES\t\t\t7\n#define DJ_MAX_NUMBER_NOTIFS\t\t\t8\n#define DJ_RECEIVER_INDEX\t\t\t0\n#define DJ_DEVICE_INDEX_MIN\t\t\t1\n#define DJ_DEVICE_INDEX_MAX\t\t\t7\n\n#define DJREPORT_SHORT_LENGTH\t\t\t15\n#define DJREPORT_LONG_LENGTH\t\t\t32\n\n#define REPORT_ID_DJ_SHORT\t\t\t0x20\n#define REPORT_ID_DJ_LONG\t\t\t0x21\n\n#define REPORT_ID_HIDPP_SHORT\t\t\t0x10\n#define REPORT_ID_HIDPP_LONG\t\t\t0x11\n#define REPORT_ID_HIDPP_VERY_LONG\t\t0x12\n\n#define HIDPP_REPORT_SHORT_LENGTH\t\t7\n#define HIDPP_REPORT_LONG_LENGTH\t\t20\n\n#define HIDPP_RECEIVER_INDEX\t\t\t0xff\n\n#define REPORT_TYPE_RFREPORT_FIRST\t\t0x01\n#define REPORT_TYPE_RFREPORT_LAST\t\t0x1F\n\n \n#define REPORT_TYPE_CMD_SWITCH\t\t\t0x80\n#define CMD_SWITCH_PARAM_DEVBITFIELD\t\t0x00\n#define CMD_SWITCH_PARAM_TIMEOUT_SECONDS\t0x01\n#define TIMEOUT_NO_KEEPALIVE\t\t\t0x00\n\n \n#define REPORT_TYPE_CMD_GET_PAIRED_DEVICES\t0x81\n\n \n#define REPORT_TYPE_NOTIF_DEVICE_PAIRED\t\t0x41\n#define SPFUNCTION_MORE_NOTIF_EXPECTED\t\t0x01\n#define SPFUNCTION_DEVICE_LIST_EMPTY\t\t0x02\n#define DEVICE_PAIRED_PARAM_SPFUNCTION\t\t0x00\n#define DEVICE_PAIRED_PARAM_EQUAD_ID_LSB\t0x01\n#define DEVICE_PAIRED_PARAM_EQUAD_ID_MSB\t0x02\n#define DEVICE_PAIRED_RF_REPORT_TYPE\t\t0x03\n\n \n#define REPORT_TYPE_NOTIF_DEVICE_UNPAIRED\t0x40\n\n \n#define REPORT_TYPE_NOTIF_CONNECTION_STATUS\t0x42\n#define CONNECTION_STATUS_PARAM_STATUS\t\t0x00\n#define STATUS_LINKLOSS\t\t\t\t0x01\n\n \n#define REPORT_TYPE_NOTIF_ERROR\t\t\t0x7F\n#define NOTIF_ERROR_PARAM_ETYPE\t\t\t0x00\n#define ETYPE_KEEPALIVE_TIMEOUT\t\t\t0x01\n\n \n#define REPORT_TYPE_KEYBOARD\t\t\t0x01\n#define REPORT_TYPE_MOUSE\t\t\t0x02\n#define REPORT_TYPE_CONSUMER_CONTROL\t\t0x03\n#define REPORT_TYPE_SYSTEM_CONTROL\t\t0x04\n#define REPORT_TYPE_MEDIA_CENTER\t\t0x08\n#define REPORT_TYPE_LEDS\t\t\t0x0E\n\n \n#define STD_KEYBOARD\t\t\t\tBIT(1)\n#define STD_MOUSE\t\t\t\tBIT(2)\n#define MULTIMEDIA\t\t\t\tBIT(3)\n#define POWER_KEYS\t\t\t\tBIT(4)\n#define KBD_MOUSE\t\t\t\tBIT(5)\n#define MEDIA_CENTER\t\t\t\tBIT(8)\n#define KBD_LEDS\t\t\t\tBIT(14)\n \n#define HIDPP\t\t\t\t\tBIT_ULL(63)\n\n \n#define REPORT_TYPE_NOTIF_DEVICE_CONNECTED\t0x41\n#define HIDPP_PARAM_PROTO_TYPE\t\t\t0x00\n#define HIDPP_PARAM_DEVICE_INFO\t\t\t0x01\n#define HIDPP_PARAM_EQUAD_LSB\t\t\t0x02\n#define HIDPP_PARAM_EQUAD_MSB\t\t\t0x03\n#define HIDPP_PARAM_27MHZ_DEVID\t\t\t0x03\n#define HIDPP_DEVICE_TYPE_MASK\t\t\tGENMASK(3, 0)\n#define HIDPP_LINK_STATUS_MASK\t\t\tBIT(6)\n#define HIDPP_MANUFACTURER_MASK\t\t\tBIT(7)\n#define HIDPP_27MHZ_SECURE_MASK\t\t\tBIT(7)\n\n#define HIDPP_DEVICE_TYPE_KEYBOARD\t\t1\n#define HIDPP_DEVICE_TYPE_MOUSE\t\t\t2\n\n#define HIDPP_SET_REGISTER\t\t\t0x80\n#define HIDPP_GET_LONG_REGISTER\t\t\t0x83\n#define HIDPP_REG_CONNECTION_STATE\t\t0x02\n#define HIDPP_REG_PAIRING_INFORMATION\t\t0xB5\n#define HIDPP_PAIRING_INFORMATION\t\t0x20\n#define HIDPP_FAKE_DEVICE_ARRIVAL\t\t0x02\n\nenum recvr_type {\n\trecvr_type_dj,\n\trecvr_type_hidpp,\n\trecvr_type_gaming_hidpp,\n\trecvr_type_mouse_only,\n\trecvr_type_27mhz,\n\trecvr_type_bluetooth,\n\trecvr_type_dinovo,\n};\n\nstruct dj_report {\n\tu8 report_id;\n\tu8 device_index;\n\tu8 report_type;\n\tu8 report_params[DJREPORT_SHORT_LENGTH - 3];\n};\n\nstruct hidpp_event {\n\tu8 report_id;\n\tu8 device_index;\n\tu8 sub_id;\n\tu8 params[HIDPP_REPORT_LONG_LENGTH - 3U];\n} __packed;\n\nstruct dj_receiver_dev {\n\tstruct hid_device *mouse;\n\tstruct hid_device *keyboard;\n\tstruct hid_device *hidpp;\n\tstruct dj_device *paired_dj_devices[DJ_MAX_PAIRED_DEVICES +\n\t\t\t\t\t    DJ_DEVICE_INDEX_MIN];\n\tstruct list_head list;\n\tstruct kref kref;\n\tstruct work_struct work;\n\tstruct kfifo notif_fifo;\n\tunsigned long last_query;  \n\tbool ready;\n\tenum recvr_type type;\n\tunsigned int unnumbered_application;\n\tspinlock_t lock;\n};\n\nstruct dj_device {\n\tstruct hid_device *hdev;\n\tstruct dj_receiver_dev *dj_receiver_dev;\n\tu64 reports_supported;\n\tu8 device_index;\n};\n\n#define WORKITEM_TYPE_EMPTY\t0\n#define WORKITEM_TYPE_PAIRED\t1\n#define WORKITEM_TYPE_UNPAIRED\t2\n#define WORKITEM_TYPE_UNKNOWN\t255\n\nstruct dj_workitem {\n\tu8 type;\t\t \n\tu8 device_index;\n\tu8 device_type;\n\tu8 quad_id_msb;\n\tu8 quad_id_lsb;\n\tu64 reports_supported;\n};\n\n \nstatic const char kbd_descriptor[] = {\n\t0x05, 0x01,\t\t \n\t0x09, 0x06,\t\t \n\t0xA1, 0x01,\t\t \n\t0x85, 0x01,\t\t \n\t0x95, 0x08,\t\t \n\t0x75, 0x01,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x05, 0x07,\t\t \n\t0x19, 0xE0,\t\t \n\t0x29, 0xE7,\t\t \n\t0x81, 0x02,\t\t \n\t0x95, 0x06,\t\t \n\t0x75, 0x08,\t\t \n\t0x15, 0x00,\t\t \n\t0x26, 0xFF, 0x00,\t \n\t0x05, 0x07,\t\t \n\t0x19, 0x00,\t\t \n\t0x2A, 0xFF, 0x00,\t \n\t0x81, 0x00,\t\t \n\t0x85, 0x0e,\t\t \n\t0x05, 0x08,\t\t \n\t0x95, 0x05,\t\t \n\t0x75, 0x01,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x19, 0x01,\t\t \n\t0x29, 0x05,\t\t \n\t0x91, 0x02,\t\t \n\t0x95, 0x01,\t\t \n\t0x75, 0x03,\t\t \n\t0x91, 0x01,\t\t \n\t0xC0\n};\n\n \nstatic const char mse_descriptor[] = {\n\t0x05, 0x01,\t\t \n\t0x09, 0x02,\t\t \n\t0xA1, 0x01,\t\t \n\t0x85, 0x02,\t\t \n\t0x09, 0x01,\t\t \n\t0xA1, 0x00,\t\t \n\t0x05, 0x09,\t\t \n\t0x19, 0x01,\t\t \n\t0x29, 0x10,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x95, 0x10,\t\t \n\t0x75, 0x01,\t\t \n\t0x81, 0x02,\t\t \n\t0x05, 0x01,\t\t \n\t0x16, 0x01, 0xF8,\t \n\t0x26, 0xFF, 0x07,\t \n\t0x75, 0x0C,\t\t \n\t0x95, 0x02,\t\t \n\t0x09, 0x30,\t\t \n\t0x09, 0x31,\t\t \n\t0x81, 0x06,\t\t \n\t0x15, 0x81,\t\t \n\t0x25, 0x7F,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x01,\t\t \n\t0x09, 0x38,\t\t \n\t0x81, 0x06,\t\t \n\t0x05, 0x0C,\t\t \n\t0x0A, 0x38, 0x02,\t \n\t0x95, 0x01,\t\t \n\t0x81, 0x06,\t\t \n\t0xC0,\t\t\t \n\t0xC0,\t\t\t \n};\n\n \nstatic const char mse_27mhz_descriptor[] = {\n\t0x05, 0x01,\t\t \n\t0x09, 0x02,\t\t \n\t0xA1, 0x01,\t\t \n\t0x85, 0x02,\t\t \n\t0x09, 0x01,\t\t \n\t0xA1, 0x00,\t\t \n\t0x05, 0x09,\t\t \n\t0x19, 0x01,\t\t \n\t0x29, 0x08,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x95, 0x08,\t\t \n\t0x75, 0x01,\t\t \n\t0x81, 0x02,\t\t \n\t0x05, 0x01,\t\t \n\t0x16, 0x01, 0xF8,\t \n\t0x26, 0xFF, 0x07,\t \n\t0x75, 0x0C,\t\t \n\t0x95, 0x02,\t\t \n\t0x09, 0x30,\t\t \n\t0x09, 0x31,\t\t \n\t0x81, 0x06,\t\t \n\t0x15, 0x81,\t\t \n\t0x25, 0x7F,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x01,\t\t \n\t0x09, 0x38,\t\t \n\t0x81, 0x06,\t\t \n\t0x05, 0x0C,\t\t \n\t0x0A, 0x38, 0x02,\t \n\t0x95, 0x01,\t\t \n\t0x81, 0x06,\t\t \n\t0xC0,\t\t\t \n\t0xC0,\t\t\t \n};\n\n \nstatic const char mse_bluetooth_descriptor[] = {\n\t0x05, 0x01,\t\t \n\t0x09, 0x02,\t\t \n\t0xA1, 0x01,\t\t \n\t0x85, 0x02,\t\t \n\t0x09, 0x01,\t\t \n\t0xA1, 0x00,\t\t \n\t0x05, 0x09,\t\t \n\t0x19, 0x01,\t\t \n\t0x29, 0x08,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x95, 0x08,\t\t \n\t0x75, 0x01,\t\t \n\t0x81, 0x02,\t\t \n\t0x05, 0x01,\t\t \n\t0x16, 0x01, 0xF8,\t \n\t0x26, 0xFF, 0x07,\t \n\t0x75, 0x0C,\t\t \n\t0x95, 0x02,\t\t \n\t0x09, 0x30,\t\t \n\t0x09, 0x31,\t\t \n\t0x81, 0x06,\t\t \n\t0x15, 0x81,\t\t \n\t0x25, 0x7F,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x01,\t\t \n\t0x09, 0x38,\t\t \n\t0x81, 0x06,\t\t \n\t0x05, 0x0C,\t\t \n\t0x0A, 0x38, 0x02,\t \n\t0x15, 0xF9,\t\t \n\t0x25, 0x07,\t\t \n\t0x75, 0x04,\t\t \n\t0x95, 0x01,\t\t \n\t0x81, 0x06,\t\t \n\t0x05, 0x09,\t\t \n\t0x19, 0x09,\t\t \n\t0x29, 0x0C,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x75, 0x01,\t\t \n\t0x95, 0x04,\t\t \n\t0x81, 0x02,\t\t \n\t0xC0,\t\t\t \n\t0xC0,\t\t\t \n};\n\n \nstatic const char mse5_bluetooth_descriptor[] = {\n\t0x05, 0x01,\t\t \n\t0x09, 0x02,\t\t \n\t0xa1, 0x01,\t\t \n\t0x85, 0x05,\t\t \n\t0x09, 0x01,\t\t \n\t0xa1, 0x00,\t\t \n\t0x05, 0x09,\t\t \n\t0x19, 0x01,\t\t \n\t0x29, 0x08,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x95, 0x08,\t\t \n\t0x75, 0x01,\t\t \n\t0x81, 0x02,\t\t \n\t0x05, 0x01,\t\t \n\t0x16, 0x01, 0xf8,\t \n\t0x26, 0xff, 0x07,\t \n\t0x75, 0x0c,\t\t \n\t0x95, 0x02,\t\t \n\t0x09, 0x30,\t\t \n\t0x09, 0x31,\t\t \n\t0x81, 0x06,\t\t \n\t0x15, 0x81,\t\t \n\t0x25, 0x7f,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x01,\t\t \n\t0x09, 0x38,\t\t \n\t0x81, 0x06,\t\t \n\t0x05, 0x0c,\t\t \n\t0x0a, 0x38, 0x02,\t \n\t0x15, 0x81,\t\t \n\t0x25, 0x7f,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x01,\t\t \n\t0x81, 0x06,\t\t \n\t0xc0,\t\t\t \n\t0xc0,\t\t\t \n};\n\n \nstatic const char mse_high_res_descriptor[] = {\n\t0x05, 0x01,\t\t \n\t0x09, 0x02,\t\t \n\t0xA1, 0x01,\t\t \n\t0x85, 0x02,\t\t \n\t0x09, 0x01,\t\t \n\t0xA1, 0x00,\t\t \n\t0x05, 0x09,\t\t \n\t0x19, 0x01,\t\t \n\t0x29, 0x10,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x95, 0x10,\t\t \n\t0x75, 0x01,\t\t \n\t0x81, 0x02,\t\t \n\t0x05, 0x01,\t\t \n\t0x16, 0x01, 0x80,\t \n\t0x26, 0xFF, 0x7F,\t \n\t0x75, 0x10,\t\t \n\t0x95, 0x02,\t\t \n\t0x09, 0x30,\t\t \n\t0x09, 0x31,\t\t \n\t0x81, 0x06,\t\t \n\t0x15, 0x81,\t\t \n\t0x25, 0x7F,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x01,\t\t \n\t0x09, 0x38,\t\t \n\t0x81, 0x06,\t\t \n\t0x05, 0x0C,\t\t \n\t0x0A, 0x38, 0x02,\t \n\t0x95, 0x01,\t\t \n\t0x81, 0x06,\t\t \n\t0xC0,\t\t\t \n\t0xC0,\t\t\t \n};\n\n \nstatic const char consumer_descriptor[] = {\n\t0x05, 0x0C,\t\t \n\t0x09, 0x01,\t\t \n\t0xA1, 0x01,\t\t \n\t0x85, 0x03,\t\t \n\t0x75, 0x10,\t\t \n\t0x95, 0x02,\t\t \n\t0x15, 0x01,\t\t \n\t0x26, 0xFF, 0x02,\t \n\t0x19, 0x01,\t\t \n\t0x2A, 0xFF, 0x02,\t \n\t0x81, 0x00,\t\t \n\t0xC0,\t\t\t \n};\t\t\t\t \n\n \nstatic const char syscontrol_descriptor[] = {\n\t0x05, 0x01,\t\t \n\t0x09, 0x80,\t\t \n\t0xA1, 0x01,\t\t \n\t0x85, 0x04,\t\t \n\t0x75, 0x02,\t\t \n\t0x95, 0x01,\t\t \n\t0x15, 0x01,\t\t \n\t0x25, 0x03,\t\t \n\t0x09, 0x82,\t\t \n\t0x09, 0x81,\t\t \n\t0x09, 0x83,\t\t \n\t0x81, 0x60,\t\t \n\t0x75, 0x06,\t\t \n\t0x81, 0x03,\t\t \n\t0xC0,\t\t\t \n};\n\n \nstatic const char media_descriptor[] = {\n\t0x06, 0xbc, 0xff,\t \n\t0x09, 0x88,\t\t \n\t0xa1, 0x01,\t\t \n\t0x85, 0x08,\t\t \n\t0x19, 0x01,\t\t \n\t0x29, 0xff,\t\t \n\t0x15, 0x01,\t\t \n\t0x26, 0xff, 0x00,\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x01,\t\t \n\t0x81, 0x00,\t\t \n\t0xc0,\t\t\t \n};\t\t\t\t \n\n \nstatic const char hidpp_descriptor[] = {\n\t0x06, 0x00, 0xff,\t \n\t0x09, 0x01,\t\t \n\t0xa1, 0x01,\t\t \n\t0x85, 0x10,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x06,\t\t \n\t0x15, 0x00,\t\t \n\t0x26, 0xff, 0x00,\t \n\t0x09, 0x01,\t\t \n\t0x81, 0x00,\t\t \n\t0x09, 0x01,\t\t \n\t0x91, 0x00,\t\t \n\t0xc0,\t\t\t \n\t0x06, 0x00, 0xff,\t \n\t0x09, 0x02,\t\t \n\t0xa1, 0x01,\t\t \n\t0x85, 0x11,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x13,\t\t \n\t0x15, 0x00,\t\t \n\t0x26, 0xff, 0x00,\t \n\t0x09, 0x02,\t\t \n\t0x81, 0x00,\t\t \n\t0x09, 0x02,\t\t \n\t0x91, 0x00,\t\t \n\t0xc0,\t\t\t \n\t0x06, 0x00, 0xff,\t \n\t0x09, 0x04,\t\t \n\t0xa1, 0x01,\t\t \n\t0x85, 0x20,\t\t \n\t0x75, 0x08,\t\t \n\t0x95, 0x0e,\t\t \n\t0x15, 0x00,\t\t \n\t0x26, 0xff, 0x00,\t \n\t0x09, 0x41,\t\t \n\t0x81, 0x00,\t\t \n\t0x09, 0x41,\t\t \n\t0x91, 0x00,\t\t \n\t0x85, 0x21,\t\t \n\t0x95, 0x1f,\t\t \n\t0x15, 0x00,\t\t \n\t0x26, 0xff, 0x00,\t \n\t0x09, 0x42,\t\t \n\t0x81, 0x00,\t\t \n\t0x09, 0x42,\t\t \n\t0x91, 0x00,\t\t \n\t0xc0,\t\t\t \n};\n\n \n#define MAX_REPORT_SIZE 8\n\n \n#define MAX_RDESC_SIZE\t\t\t\t\\\n\t(sizeof(kbd_descriptor) +\t\t\\\n\t sizeof(mse_bluetooth_descriptor) +\t\\\n\t sizeof(mse5_bluetooth_descriptor) +\t\\\n\t sizeof(consumer_descriptor) +\t\t\\\n\t sizeof(syscontrol_descriptor) +\t\\\n\t sizeof(media_descriptor) +\t\\\n\t sizeof(hidpp_descriptor))\n\n \n#define NUMBER_OF_HID_REPORTS 32\nstatic const u8 hid_reportid_size_map[NUMBER_OF_HID_REPORTS] = {\n\t[1] = 8,\t\t \n\t[2] = 8,\t\t \n\t[3] = 5,\t\t \n\t[4] = 2,\t\t \n\t[8] = 2,\t\t \n};\n\n\n#define LOGITECH_DJ_INTERFACE_NUMBER 0x02\n\nstatic const struct hid_ll_driver logi_dj_ll_driver;\n\nstatic int logi_dj_recv_query_paired_devices(struct dj_receiver_dev *djrcv_dev);\nstatic void delayedwork_callback(struct work_struct *work);\n\nstatic LIST_HEAD(dj_hdev_list);\nstatic DEFINE_MUTEX(dj_hdev_list_lock);\n\nstatic bool recvr_type_is_bluetooth(enum recvr_type type)\n{\n\treturn type == recvr_type_bluetooth || type == recvr_type_dinovo;\n}\n\n \nstatic struct dj_receiver_dev *dj_find_receiver_dev(struct hid_device *hdev,\n\t\t\t\t\t\t    enum recvr_type type)\n{\n\tstruct dj_receiver_dev *djrcv_dev;\n\tchar sep;\n\n\t \n\tsep = recvr_type_is_bluetooth(type) ? '.' : '/';\n\n\t \n\tlist_for_each_entry(djrcv_dev, &dj_hdev_list, list) {\n\t\tif (djrcv_dev->mouse &&\n\t\t    hid_compare_device_paths(hdev, djrcv_dev->mouse, sep)) {\n\t\t\tkref_get(&djrcv_dev->kref);\n\t\t\treturn djrcv_dev;\n\t\t}\n\t\tif (djrcv_dev->keyboard &&\n\t\t    hid_compare_device_paths(hdev, djrcv_dev->keyboard, sep)) {\n\t\t\tkref_get(&djrcv_dev->kref);\n\t\t\treturn djrcv_dev;\n\t\t}\n\t\tif (djrcv_dev->hidpp &&\n\t\t    hid_compare_device_paths(hdev, djrcv_dev->hidpp, sep)) {\n\t\t\tkref_get(&djrcv_dev->kref);\n\t\t\treturn djrcv_dev;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void dj_release_receiver_dev(struct kref *kref)\n{\n\tstruct dj_receiver_dev *djrcv_dev = container_of(kref, struct dj_receiver_dev, kref);\n\n\tlist_del(&djrcv_dev->list);\n\tkfifo_free(&djrcv_dev->notif_fifo);\n\tkfree(djrcv_dev);\n}\n\nstatic void dj_put_receiver_dev(struct hid_device *hdev)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\n\tmutex_lock(&dj_hdev_list_lock);\n\n\tif (djrcv_dev->mouse == hdev)\n\t\tdjrcv_dev->mouse = NULL;\n\tif (djrcv_dev->keyboard == hdev)\n\t\tdjrcv_dev->keyboard = NULL;\n\tif (djrcv_dev->hidpp == hdev)\n\t\tdjrcv_dev->hidpp = NULL;\n\n\tkref_put(&djrcv_dev->kref, dj_release_receiver_dev);\n\n\tmutex_unlock(&dj_hdev_list_lock);\n}\n\nstatic struct dj_receiver_dev *dj_get_receiver_dev(struct hid_device *hdev,\n\t\t\t\t\t\t   enum recvr_type type,\n\t\t\t\t\t\t   unsigned int application,\n\t\t\t\t\t\t   bool is_hidpp)\n{\n\tstruct dj_receiver_dev *djrcv_dev;\n\n\tmutex_lock(&dj_hdev_list_lock);\n\n\tdjrcv_dev = dj_find_receiver_dev(hdev, type);\n\tif (!djrcv_dev) {\n\t\tdjrcv_dev = kzalloc(sizeof(*djrcv_dev), GFP_KERNEL);\n\t\tif (!djrcv_dev)\n\t\t\tgoto out;\n\n\t\tINIT_WORK(&djrcv_dev->work, delayedwork_callback);\n\t\tspin_lock_init(&djrcv_dev->lock);\n\t\tif (kfifo_alloc(&djrcv_dev->notif_fifo,\n\t\t\t    DJ_MAX_NUMBER_NOTIFS * sizeof(struct dj_workitem),\n\t\t\t    GFP_KERNEL)) {\n\t\t\tkfree(djrcv_dev);\n\t\t\tdjrcv_dev = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tkref_init(&djrcv_dev->kref);\n\t\tlist_add_tail(&djrcv_dev->list, &dj_hdev_list);\n\t\tdjrcv_dev->last_query = jiffies;\n\t\tdjrcv_dev->type = type;\n\t}\n\n\tif (application == HID_GD_KEYBOARD)\n\t\tdjrcv_dev->keyboard = hdev;\n\tif (application == HID_GD_MOUSE)\n\t\tdjrcv_dev->mouse = hdev;\n\tif (is_hidpp)\n\t\tdjrcv_dev->hidpp = hdev;\n\n\thid_set_drvdata(hdev, djrcv_dev);\nout:\n\tmutex_unlock(&dj_hdev_list_lock);\n\treturn djrcv_dev;\n}\n\nstatic void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t      struct dj_workitem *workitem)\n{\n\t \n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdj_dev = djrcv_dev->paired_dj_devices[workitem->device_index];\n\tdjrcv_dev->paired_dj_devices[workitem->device_index] = NULL;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\tif (dj_dev != NULL) {\n\t\thid_destroy_device(dj_dev->hdev);\n\t\tkfree(dj_dev);\n\t} else {\n\t\thid_err(djrcv_dev->hidpp, \"%s: can't destroy a NULL device\\n\",\n\t\t\t__func__);\n\t}\n}\n\nstatic void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_workitem *workitem)\n{\n\t \n\tstruct hid_device *djrcv_hdev = djrcv_dev->hidpp;\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\tu8 device_index = workitem->device_index;\n\tunsigned long flags;\n\n\t \n\tunsigned char tmpstr[3];\n\n\t \n\tif (djrcv_dev->paired_dj_devices[device_index]) {\n\t\t \n\t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\thid_err(djrcv_hdev, \"%s: hid_allocate_dev failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = djrcv_hdev->vendor;\n\tdj_hiddev->product = (workitem->quad_id_msb << 8) |\n\t\t\t      workitem->quad_id_lsb;\n\tif (workitem->device_type) {\n\t\tconst char *type_str = \"Device\";\n\n\t\tswitch (workitem->device_type) {\n\t\tcase 0x01: type_str = \"Keyboard\";\tbreak;\n\t\tcase 0x02: type_str = \"Mouse\";\t\tbreak;\n\t\tcase 0x03: type_str = \"Numpad\";\t\tbreak;\n\t\tcase 0x04: type_str = \"Presenter\";\tbreak;\n\t\tcase 0x07: type_str = \"Remote Control\";\tbreak;\n\t\tcase 0x08: type_str = \"Trackball\";\tbreak;\n\t\tcase 0x09: type_str = \"Touchpad\";\tbreak;\n\t\t}\n\t\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\t\"Logitech Wireless %s PID:%04x\",\n\t\t\ttype_str, dj_hiddev->product);\n\t} else {\n\t\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\t\"Logitech Wireless Device PID:%04x\",\n\t\t\tdj_hiddev->product);\n\t}\n\n\tif (djrcv_dev->type == recvr_type_27mhz)\n\t\tdj_hiddev->group = HID_GROUP_LOGITECH_27MHZ_DEVICE;\n\telse\n\t\tdj_hiddev->group = HID_GROUP_LOGITECH_DJ_DEVICE;\n\n\tmemcpy(dj_hiddev->phys, djrcv_hdev->phys, sizeof(djrcv_hdev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\thid_err(djrcv_hdev, \"%s: failed allocating dj_dev\\n\", __func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = workitem->reports_supported;\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdjrcv_dev->paired_dj_devices[device_index] = dj_dev;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\thid_err(djrcv_hdev, \"%s: failed adding dj_device\\n\", __func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdjrcv_dev->paired_dj_devices[device_index] = NULL;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}\n\nstatic void delayedwork_callback(struct work_struct *work)\n{\n\tstruct dj_receiver_dev *djrcv_dev =\n\t\tcontainer_of(work, struct dj_receiver_dev, work);\n\n\tstruct dj_workitem workitem;\n\tunsigned long flags;\n\tint count;\n\tint retval;\n\n\tdbg_hid(\"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\n\t \n\tif (!djrcv_dev->ready) {\n\t\tpr_warn(\"%s: delayedwork queued before hidpp interface was enumerated\\n\",\n\t\t\t__func__);\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\treturn;\n\t}\n\n\tcount = kfifo_out(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));\n\n\tif (count != sizeof(workitem)) {\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\treturn;\n\t}\n\n\tif (!kfifo_is_empty(&djrcv_dev->notif_fifo))\n\t\tschedule_work(&djrcv_dev->work);\n\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\tswitch (workitem.type) {\n\tcase WORKITEM_TYPE_PAIRED:\n\t\tlogi_dj_recv_add_djhid_device(djrcv_dev, &workitem);\n\t\tbreak;\n\tcase WORKITEM_TYPE_UNPAIRED:\n\t\tlogi_dj_recv_destroy_djhid_device(djrcv_dev, &workitem);\n\t\tbreak;\n\tcase WORKITEM_TYPE_UNKNOWN:\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval) {\n\t\t\thid_err(djrcv_dev->hidpp, \"%s: logi_dj_recv_query_paired_devices error: %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t}\n\t\tbreak;\n\tcase WORKITEM_TYPE_EMPTY:\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tbreak;\n\t}\n}\n\n \nstatic void logi_dj_recv_queue_unknown_work(struct dj_receiver_dev *djrcv_dev)\n{\n\tstruct dj_workitem workitem = { .type = WORKITEM_TYPE_UNKNOWN };\n\n\t \n\tif (time_before(jiffies, djrcv_dev->last_query + HZ / 2))\n\t\treturn;\n\n\tkfifo_in(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));\n\tschedule_work(&djrcv_dev->work);\n}\n\nstatic void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t   struct dj_report *dj_report)\n{\n\t \n\tstruct dj_workitem workitem = {\n\t\t.device_index = dj_report->device_index,\n\t};\n\n\tswitch (dj_report->report_type) {\n\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tworkitem.type = WORKITEM_TYPE_PAIRED;\n\t\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\t\tworkitem.type = WORKITEM_TYPE_EMPTY;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\tworkitem.quad_id_msb =\n\t\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB];\n\t\tworkitem.quad_id_lsb =\n\t\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB];\n\t\tworkitem.reports_supported = get_unaligned_le32(\n\t\t\t\t\t\tdj_report->report_params +\n\t\t\t\t\t\tDEVICE_PAIRED_RF_REPORT_TYPE);\n\t\tworkitem.reports_supported |= HIDPP;\n\t\tif (dj_report->report_type == REPORT_TYPE_NOTIF_DEVICE_UNPAIRED)\n\t\t\tworkitem.type = WORKITEM_TYPE_UNPAIRED;\n\t\tbreak;\n\tdefault:\n\t\tlogi_dj_recv_queue_unknown_work(djrcv_dev);\n\t\treturn;\n\t}\n\n\tkfifo_in(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));\n\tschedule_work(&djrcv_dev->work);\n}\n\n \nstatic const u16 kbd_builtin_touchpad_ids[] = {\n\t0xb309,  \n\t0xb30c,  \n};\n\nstatic void logi_hidpp_dev_conn_notif_equad(struct hid_device *hdev,\n\t\t\t\t\t    struct hidpp_event *hidpp_report,\n\t\t\t\t\t    struct dj_workitem *workitem)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tint i, id;\n\n\tworkitem->type = WORKITEM_TYPE_PAIRED;\n\tworkitem->device_type = hidpp_report->params[HIDPP_PARAM_DEVICE_INFO] &\n\t\t\t\tHIDPP_DEVICE_TYPE_MASK;\n\tworkitem->quad_id_msb = hidpp_report->params[HIDPP_PARAM_EQUAD_MSB];\n\tworkitem->quad_id_lsb = hidpp_report->params[HIDPP_PARAM_EQUAD_LSB];\n\tswitch (workitem->device_type) {\n\tcase REPORT_TYPE_KEYBOARD:\n\t\tworkitem->reports_supported |= STD_KEYBOARD | MULTIMEDIA |\n\t\t\t\t\t       POWER_KEYS | MEDIA_CENTER |\n\t\t\t\t\t       HIDPP;\n\t\tid = (workitem->quad_id_msb << 8) | workitem->quad_id_lsb;\n\t\tfor (i = 0; i < ARRAY_SIZE(kbd_builtin_touchpad_ids); i++) {\n\t\t\tif (id == kbd_builtin_touchpad_ids[i]) {\n\t\t\t\tif (djrcv_dev->type == recvr_type_dinovo)\n\t\t\t\t\tworkitem->reports_supported |= KBD_MOUSE;\n\t\t\t\telse\n\t\t\t\t\tworkitem->reports_supported |= STD_MOUSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase REPORT_TYPE_MOUSE:\n\t\tworkitem->reports_supported |= STD_MOUSE | HIDPP;\n\t\tif (djrcv_dev->type == recvr_type_mouse_only)\n\t\t\tworkitem->reports_supported |= MULTIMEDIA;\n\t\tbreak;\n\t}\n}\n\nstatic void logi_hidpp_dev_conn_notif_27mhz(struct hid_device *hdev,\n\t\t\t\t\t    struct hidpp_event *hidpp_report,\n\t\t\t\t\t    struct dj_workitem *workitem)\n{\n\tworkitem->type = WORKITEM_TYPE_PAIRED;\n\tworkitem->quad_id_lsb = hidpp_report->params[HIDPP_PARAM_27MHZ_DEVID];\n\tswitch (hidpp_report->device_index) {\n\tcase 1:  \n\tcase 2:  \n\t\tworkitem->device_type = HIDPP_DEVICE_TYPE_MOUSE;\n\t\tworkitem->reports_supported |= STD_MOUSE | HIDPP;\n\t\tbreak;\n\tcase 3:  \n\t\tif (hidpp_report->params[HIDPP_PARAM_DEVICE_INFO] & HIDPP_27MHZ_SECURE_MASK) {\n\t\t\thid_info(hdev, \"Keyboard connection is encrypted\\n\");\n\t\t} else {\n\t\t\thid_warn(hdev, \"Keyboard events are send over the air in plain-text / unencrypted\\n\");\n\t\t\thid_warn(hdev, \"See: https://gitlab.freedesktop.org/jwrdegoede/logitech-27mhz-keyboard-encryption-setup/\\n\");\n\t\t}\n\t\tfallthrough;\n\tcase 4:  \n\t\tworkitem->device_type = HIDPP_DEVICE_TYPE_KEYBOARD;\n\t\tworkitem->reports_supported |= STD_KEYBOARD | MULTIMEDIA |\n\t\t\t\t\t       POWER_KEYS | HIDPP;\n\t\tbreak;\n\tdefault:\n\t\thid_warn(hdev, \"%s: unexpected device-index %d\", __func__,\n\t\t\t hidpp_report->device_index);\n\t}\n}\n\nstatic void logi_hidpp_recv_queue_notif(struct hid_device *hdev,\n\t\t\t\t\tstruct hidpp_event *hidpp_report)\n{\n\t \n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tconst char *device_type = \"UNKNOWN\";\n\tstruct dj_workitem workitem = {\n\t\t.type = WORKITEM_TYPE_EMPTY,\n\t\t.device_index = hidpp_report->device_index,\n\t};\n\n\tswitch (hidpp_report->params[HIDPP_PARAM_PROTO_TYPE]) {\n\tcase 0x01:\n\t\tdevice_type = \"Bluetooth\";\n\t\t \n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tif (!(hidpp_report->params[HIDPP_PARAM_DEVICE_INFO] &\n\t\t\t\t\t\tHIDPP_MANUFACTURER_MASK)) {\n\t\t\thid_info(hdev, \"Non Logitech device connected on slot %d\\n\",\n\t\t\t\t hidpp_report->device_index);\n\t\t\tworkitem.reports_supported &= ~HIDPP;\n\t\t}\n\t\tbreak;\n\tcase 0x02:\n\t\tdevice_type = \"27 Mhz\";\n\t\tlogi_hidpp_dev_conn_notif_27mhz(hdev, hidpp_report, &workitem);\n\t\tbreak;\n\tcase 0x03:\n\t\tdevice_type = \"QUAD or eQUAD\";\n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tbreak;\n\tcase 0x04:\n\t\tdevice_type = \"eQUAD step 4 DJ\";\n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tbreak;\n\tcase 0x05:\n\t\tdevice_type = \"DFU Lite\";\n\t\tbreak;\n\tcase 0x06:\n\t\tdevice_type = \"eQUAD step 4 Lite\";\n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tbreak;\n\tcase 0x07:\n\t\tdevice_type = \"eQUAD step 4 Gaming\";\n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tworkitem.reports_supported |= STD_KEYBOARD;\n\t\tbreak;\n\tcase 0x08:\n\t\tdevice_type = \"eQUAD step 4 for gamepads\";\n\t\tbreak;\n\tcase 0x0a:\n\t\tdevice_type = \"eQUAD nano Lite\";\n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tbreak;\n\tcase 0x0c:\n\t\tdevice_type = \"eQUAD Lightspeed 1\";\n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tworkitem.reports_supported |= STD_KEYBOARD;\n\t\tbreak;\n\tcase 0x0d:\n\t\tdevice_type = \"eQUAD Lightspeed 1.1\";\n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tworkitem.reports_supported |= STD_KEYBOARD;\n\t\tbreak;\n\tcase 0x0f:\n\tcase 0x11:\n\t\tdevice_type = \"eQUAD Lightspeed 1.2\";\n\t\tlogi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);\n\t\tworkitem.reports_supported |= STD_KEYBOARD;\n\t\tbreak;\n\t}\n\n\t \n\tif (hidpp_report->device_index == 7) {\n\t\tworkitem.reports_supported |= HIDPP;\n\t}\n\n\tif (workitem.type == WORKITEM_TYPE_EMPTY) {\n\t\thid_warn(hdev,\n\t\t\t \"unusable device of type %s (0x%02x) connected on slot %d\",\n\t\t\t device_type,\n\t\t\t hidpp_report->params[HIDPP_PARAM_PROTO_TYPE],\n\t\t\t hidpp_report->device_index);\n\t\treturn;\n\t}\n\n\thid_info(hdev, \"device of type %s (0x%02x) connected on slot %d\",\n\t\t device_type, hidpp_report->params[HIDPP_PARAM_PROTO_TYPE],\n\t\t hidpp_report->device_index);\n\n\tkfifo_in(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));\n\tschedule_work(&djrcv_dev->work);\n}\n\nstatic void logi_dj_recv_forward_null_report(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t     struct dj_report *dj_report)\n{\n\t \n\tunsigned int i;\n\tu8 reportbuffer[MAX_REPORT_SIZE];\n\tstruct dj_device *djdev;\n\n\tdjdev = djrcv_dev->paired_dj_devices[dj_report->device_index];\n\n\tmemset(reportbuffer, 0, sizeof(reportbuffer));\n\n\tfor (i = 0; i < NUMBER_OF_HID_REPORTS; i++) {\n\t\tif (djdev->reports_supported & (1 << i)) {\n\t\t\treportbuffer[0] = i;\n\t\t\tif (hid_input_report(djdev->hdev,\n\t\t\t\t\t     HID_INPUT_REPORT,\n\t\t\t\t\t     reportbuffer,\n\t\t\t\t\t     hid_reportid_size_map[i], 1)) {\n\t\t\t\tdbg_hid(\"hid_input_report error sending null \"\n\t\t\t\t\t\"report\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void logi_dj_recv_forward_dj(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t    struct dj_report *dj_report)\n{\n\t \n\tstruct dj_device *dj_device;\n\n\tdj_device = djrcv_dev->paired_dj_devices[dj_report->device_index];\n\n\tif ((dj_report->report_type > ARRAY_SIZE(hid_reportid_size_map) - 1) ||\n\t    (hid_reportid_size_map[dj_report->report_type] == 0)) {\n\t\tdbg_hid(\"invalid report type:%x\\n\", dj_report->report_type);\n\t\treturn;\n\t}\n\n\tif (hid_input_report(dj_device->hdev,\n\t\t\tHID_INPUT_REPORT, &dj_report->report_type,\n\t\t\thid_reportid_size_map[dj_report->report_type], 1)) {\n\t\tdbg_hid(\"hid_input_report error\\n\");\n\t}\n}\n\nstatic void logi_dj_recv_forward_report(struct dj_device *dj_dev, u8 *data,\n\t\t\t\t\tint size)\n{\n\t \n\tif (hid_input_report(dj_dev->hdev, HID_INPUT_REPORT, data, size, 1))\n\t\tdbg_hid(\"hid_input_report error\\n\");\n}\n\nstatic void logi_dj_recv_forward_input_report(struct hid_device *hdev,\n\t\t\t\t\t      u8 *data, int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\tu8 report = data[0];\n\tint i;\n\n\tif (report > REPORT_TYPE_RFREPORT_LAST) {\n\t\thid_err(hdev, \"Unexpected input report number %d\\n\", report);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tfor (i = 0; i < (DJ_MAX_PAIRED_DEVICES + DJ_DEVICE_INDEX_MIN); i++) {\n\t\tdj_dev = djrcv_dev->paired_dj_devices[i];\n\t\tif (dj_dev && (dj_dev->reports_supported & BIT(report))) {\n\t\t\tlogi_dj_recv_forward_report(dj_dev, data, size);\n\t\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlogi_dj_recv_queue_unknown_work(djrcv_dev);\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\tdbg_hid(\"No dj-devs handling input report number %d\\n\", report);\n}\n\nstatic int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t    struct dj_report *dj_report)\n{\n\tstruct hid_device *hdev = djrcv_dev->hidpp;\n\tstruct hid_report *report;\n\tstruct hid_report_enum *output_report_enum;\n\tu8 *data = (u8 *)(&dj_report->device_index);\n\tunsigned int i;\n\n\toutput_report_enum = &hdev->report_enum[HID_OUTPUT_REPORT];\n\treport = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];\n\n\tif (!report) {\n\t\thid_err(hdev, \"%s: unable to find dj report\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < DJREPORT_SHORT_LENGTH - 1; i++)\n\t\treport->field[0]->value[i] = data[i];\n\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}\n\nstatic int logi_dj_recv_query_hidpp_devices(struct dj_receiver_dev *djrcv_dev)\n{\n\tstatic const u8 template[] = {\n\t\tREPORT_ID_HIDPP_SHORT,\n\t\tHIDPP_RECEIVER_INDEX,\n\t\tHIDPP_SET_REGISTER,\n\t\tHIDPP_REG_CONNECTION_STATE,\n\t\tHIDPP_FAKE_DEVICE_ARRIVAL,\n\t\t0x00, 0x00\n\t};\n\tu8 *hidpp_report;\n\tint retval;\n\n\thidpp_report = kmemdup(template, sizeof(template), GFP_KERNEL);\n\tif (!hidpp_report)\n\t\treturn -ENOMEM;\n\n\tretval = hid_hw_raw_request(djrcv_dev->hidpp,\n\t\t\t\t    REPORT_ID_HIDPP_SHORT,\n\t\t\t\t    hidpp_report, sizeof(template),\n\t\t\t\t    HID_OUTPUT_REPORT,\n\t\t\t\t    HID_REQ_SET_REPORT);\n\n\tkfree(hidpp_report);\n\treturn (retval < 0) ? retval : 0;\n}\n\nstatic int logi_dj_recv_query_paired_devices(struct dj_receiver_dev *djrcv_dev)\n{\n\tstruct dj_report *dj_report;\n\tint retval;\n\n\tdjrcv_dev->last_query = jiffies;\n\n\tif (djrcv_dev->type != recvr_type_dj)\n\t\treturn logi_dj_recv_query_hidpp_devices(djrcv_dev);\n\n\tdj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\n\tif (!dj_report)\n\t\treturn -ENOMEM;\n\tdj_report->report_id = REPORT_ID_DJ_SHORT;\n\tdj_report->device_index = HIDPP_RECEIVER_INDEX;\n\tdj_report->report_type = REPORT_TYPE_CMD_GET_PAIRED_DEVICES;\n\tretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\n\tkfree(dj_report);\n\treturn retval;\n}\n\n\nstatic int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  unsigned timeout)\n{\n\tstruct hid_device *hdev = djrcv_dev->hidpp;\n\tstruct dj_report *dj_report;\n\tu8 *buf;\n\tint retval = 0;\n\n\tdj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\n\tif (!dj_report)\n\t\treturn -ENOMEM;\n\n\tif (djrcv_dev->type == recvr_type_dj) {\n\t\tdj_report->report_id = REPORT_ID_DJ_SHORT;\n\t\tdj_report->device_index = HIDPP_RECEIVER_INDEX;\n\t\tdj_report->report_type = REPORT_TYPE_CMD_SWITCH;\n\t\tdj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;\n\t\tdj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] =\n\t\t\t\t\t\t\t\t(u8)timeout;\n\n\t\tretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\n\n\t\t \n\t\tmsleep(50);\n\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tbuf = (u8 *)dj_report;\n\n\tmemset(buf, 0, HIDPP_REPORT_SHORT_LENGTH);\n\n\tbuf[0] = REPORT_ID_HIDPP_SHORT;\n\tbuf[1] = HIDPP_RECEIVER_INDEX;\n\tbuf[2] = 0x80;\n\tbuf[3] = 0x00;\n\tbuf[4] = 0x00;\n\tbuf[5] = 0x09;\n\tbuf[6] = 0x00;\n\n\tretval = hid_hw_raw_request(hdev, REPORT_ID_HIDPP_SHORT, buf,\n\t\t\tHIDPP_REPORT_SHORT_LENGTH, HID_OUTPUT_REPORT,\n\t\t\tHID_REQ_SET_REPORT);\n\n\tkfree(dj_report);\n\treturn retval;\n}\n\n\nstatic int logi_dj_ll_open(struct hid_device *hid)\n{\n\tdbg_hid(\"%s: %s\\n\", __func__, hid->phys);\n\treturn 0;\n\n}\n\nstatic void logi_dj_ll_close(struct hid_device *hid)\n{\n\tdbg_hid(\"%s: %s\\n\", __func__, hid->phys);\n}\n\n \nstatic u8 unifying_pairing_query[]  = { REPORT_ID_HIDPP_SHORT,\n\t\t\t\t\tHIDPP_RECEIVER_INDEX,\n\t\t\t\t\tHIDPP_GET_LONG_REGISTER,\n\t\t\t\t\tHIDPP_REG_PAIRING_INFORMATION };\nstatic u8 unifying_pairing_answer[] = { REPORT_ID_HIDPP_LONG,\n\t\t\t\t\tHIDPP_RECEIVER_INDEX,\n\t\t\t\t\tHIDPP_GET_LONG_REGISTER,\n\t\t\t\t\tHIDPP_REG_PAIRING_INFORMATION };\n\nstatic int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\n\tif ((buf[0] == REPORT_ID_HIDPP_SHORT) ||\n\t    (buf[0] == REPORT_ID_HIDPP_LONG) ||\n\t    (buf[0] == REPORT_ID_HIDPP_VERY_LONG)) {\n\t\tif (count < 2)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (count == 7 && !memcmp(buf, unifying_pairing_query,\n\t\t\t\t\t  sizeof(unifying_pairing_query)))\n\t\t\tbuf[4] = (buf[4] & 0xf0) | (djdev->device_index - 1);\n\t\telse\n\t\t\tbuf[1] = djdev->device_index;\n\t\treturn hid_hw_raw_request(djrcv_dev->hidpp, reportnum, buf,\n\t\t\t\tcount, report_type, reqtype);\n\t}\n\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\n\tif (djrcv_dev->type != recvr_type_dj && count >= 2) {\n\t\tif (!djrcv_dev->keyboard) {\n\t\t\thid_warn(hid, \"Received REPORT_TYPE_LEDS request before the keyboard interface was enumerated\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\treturn hid_hw_raw_request(djrcv_dev->keyboard, 0, buf, count,\n\t\t\t\t\t  report_type, reqtype);\n\t}\n\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count > DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\n\tret = hid_hw_raw_request(djrcv_dev->hidpp, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\n\tkfree(out_buf);\n\treturn ret;\n}\n\nstatic void rdcat(char *rdesc, unsigned int *rsize, const char *data, unsigned int size)\n{\n\tmemcpy(rdesc + *rsize, data, size);\n\t*rsize += size;\n}\n\nstatic int logi_dj_ll_parse(struct hid_device *hid)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tunsigned int rsize = 0;\n\tchar *rdesc;\n\tint retval;\n\n\tdbg_hid(\"%s\\n\", __func__);\n\n\tdjdev->hdev->version = 0x0111;\n\tdjdev->hdev->country = 0x00;\n\n\trdesc = kmalloc(MAX_RDESC_SIZE, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\tif (djdev->reports_supported & STD_KEYBOARD) {\n\t\tdbg_hid(\"%s: sending a kbd descriptor, reports_supported: %llx\\n\",\n\t\t\t__func__, djdev->reports_supported);\n\t\trdcat(rdesc, &rsize, kbd_descriptor, sizeof(kbd_descriptor));\n\t}\n\n\tif (djdev->reports_supported & STD_MOUSE) {\n\t\tdbg_hid(\"%s: sending a mouse descriptor, reports_supported: %llx\\n\",\n\t\t\t__func__, djdev->reports_supported);\n\t\tif (djdev->dj_receiver_dev->type == recvr_type_gaming_hidpp ||\n\t\t    djdev->dj_receiver_dev->type == recvr_type_mouse_only)\n\t\t\trdcat(rdesc, &rsize, mse_high_res_descriptor,\n\t\t\t      sizeof(mse_high_res_descriptor));\n\t\telse if (djdev->dj_receiver_dev->type == recvr_type_27mhz)\n\t\t\trdcat(rdesc, &rsize, mse_27mhz_descriptor,\n\t\t\t      sizeof(mse_27mhz_descriptor));\n\t\telse if (recvr_type_is_bluetooth(djdev->dj_receiver_dev->type))\n\t\t\trdcat(rdesc, &rsize, mse_bluetooth_descriptor,\n\t\t\t      sizeof(mse_bluetooth_descriptor));\n\t\telse\n\t\t\trdcat(rdesc, &rsize, mse_descriptor,\n\t\t\t      sizeof(mse_descriptor));\n\t}\n\n\tif (djdev->reports_supported & KBD_MOUSE) {\n\t\tdbg_hid(\"%s: sending a kbd-mouse descriptor, reports_supported: %llx\\n\",\n\t\t\t__func__, djdev->reports_supported);\n\t\trdcat(rdesc, &rsize, mse5_bluetooth_descriptor,\n\t\t      sizeof(mse5_bluetooth_descriptor));\n\t}\n\n\tif (djdev->reports_supported & MULTIMEDIA) {\n\t\tdbg_hid(\"%s: sending a multimedia report descriptor: %llx\\n\",\n\t\t\t__func__, djdev->reports_supported);\n\t\trdcat(rdesc, &rsize, consumer_descriptor, sizeof(consumer_descriptor));\n\t}\n\n\tif (djdev->reports_supported & POWER_KEYS) {\n\t\tdbg_hid(\"%s: sending a power keys report descriptor: %llx\\n\",\n\t\t\t__func__, djdev->reports_supported);\n\t\trdcat(rdesc, &rsize, syscontrol_descriptor, sizeof(syscontrol_descriptor));\n\t}\n\n\tif (djdev->reports_supported & MEDIA_CENTER) {\n\t\tdbg_hid(\"%s: sending a media center report descriptor: %llx\\n\",\n\t\t\t__func__, djdev->reports_supported);\n\t\trdcat(rdesc, &rsize, media_descriptor, sizeof(media_descriptor));\n\t}\n\n\tif (djdev->reports_supported & KBD_LEDS) {\n\t\tdbg_hid(\"%s: need to send kbd leds report descriptor: %llx\\n\",\n\t\t\t__func__, djdev->reports_supported);\n\t}\n\n\tif (djdev->reports_supported & HIDPP) {\n\t\tdbg_hid(\"%s: sending a HID++ descriptor, reports_supported: %llx\\n\",\n\t\t\t__func__, djdev->reports_supported);\n\t\trdcat(rdesc, &rsize, hidpp_descriptor,\n\t\t      sizeof(hidpp_descriptor));\n\t}\n\n\tretval = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n\n\treturn retval;\n}\n\nstatic int logi_dj_ll_start(struct hid_device *hid)\n{\n\tdbg_hid(\"%s\\n\", __func__);\n\treturn 0;\n}\n\nstatic void logi_dj_ll_stop(struct hid_device *hid)\n{\n\tdbg_hid(\"%s\\n\", __func__);\n}\n\nstatic bool logi_dj_ll_may_wakeup(struct hid_device *hid)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\n\treturn hid_hw_may_wakeup(djrcv_dev->hidpp);\n}\n\nstatic const struct hid_ll_driver logi_dj_ll_driver = {\n\t.parse = logi_dj_ll_parse,\n\t.start = logi_dj_ll_start,\n\t.stop = logi_dj_ll_stop,\n\t.open = logi_dj_ll_open,\n\t.close = logi_dj_ll_close,\n\t.raw_request = logi_dj_ll_raw_request,\n\t.may_wakeup = logi_dj_ll_may_wakeup,\n};\n\nstatic int logi_dj_dj_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\n\t \n\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\t \n\t\tif (dj_report->device_index != DJ_RECEIVER_INDEX)\n\t\t\thid_err(hdev, \"%s: invalid device index:%d\\n\",\n\t\t\t\t__func__, dj_report->device_index);\n\t\treturn false;\n\t}\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\n\tif (!djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n\t\t \n\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\tgoto out;\n\t}\n\n\tswitch (dj_report->report_type) {\n\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\t \n\t\tbreak;\n\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\tbreak;\n\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t    STATUS_LINKLOSS) {\n\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tlogi_dj_recv_forward_dj(djrcv_dev, dj_report);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\treturn true;\n}\n\nstatic int logi_dj_hidpp_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct hidpp_event *hidpp_report = (struct hidpp_event *) data;\n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\tu8 device_index = hidpp_report->device_index;\n\n\tif (device_index == HIDPP_RECEIVER_INDEX) {\n\t\t \n\t\tif (size == HIDPP_REPORT_LONG_LENGTH &&\n\t\t    !memcmp(data, unifying_pairing_answer,\n\t\t\t    sizeof(unifying_pairing_answer)))\n\t\t\tdevice_index = (data[4] & 0x0F) + 1;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t \n\n\tif ((device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\t \n\t\thid_err(hdev, \"%s: invalid device index:%d\\n\", __func__,\n\t\t\thidpp_report->device_index);\n\t\treturn false;\n\t}\n\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\n\tdj_dev = djrcv_dev->paired_dj_devices[device_index];\n\n\t \n\tif (djrcv_dev->type == recvr_type_27mhz && dj_dev &&\n\t    hidpp_report->sub_id == REPORT_TYPE_NOTIF_DEVICE_CONNECTED &&\n\t    hidpp_report->params[HIDPP_PARAM_PROTO_TYPE] == 0x02 &&\n\t    hidpp_report->params[HIDPP_PARAM_27MHZ_DEVID] !=\n\t\t\t\t\t\tdj_dev->hdev->product) {\n\t\tstruct dj_workitem workitem = {\n\t\t\t.device_index = hidpp_report->device_index,\n\t\t\t.type = WORKITEM_TYPE_UNPAIRED,\n\t\t};\n\t\tkfifo_in(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));\n\t\t \n\t\tdj_dev = NULL;\n\t}\n\n\tif (dj_dev) {\n\t\tlogi_dj_recv_forward_report(dj_dev, data, size);\n\t} else {\n\t\tif (hidpp_report->sub_id == REPORT_TYPE_NOTIF_DEVICE_CONNECTED)\n\t\t\tlogi_hidpp_recv_queue_notif(hdev, hidpp_report);\n\t\telse\n\t\t\tlogi_dj_recv_queue_unknown_work(djrcv_dev);\n\t}\n\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\treturn false;\n}\n\nstatic int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\n\tif (!djrcv_dev)\n\t\treturn 0;\n\n\tif (!hdev->report_enum[HID_INPUT_REPORT].numbered) {\n\n\t\tif (djrcv_dev->unnumbered_application == HID_GD_KEYBOARD) {\n\t\t\t \n\t\t\tdata[1] = data[0];\n\t\t\tdata[0] = REPORT_TYPE_KEYBOARD;\n\n\t\t\tlogi_dj_recv_forward_input_report(hdev, data, size);\n\n\t\t\t \n\t\t\tdata[0] = data[1];\n\t\t\tdata[1] = 0;\n\t\t}\n\t\t \n\t\tif (djrcv_dev->unnumbered_application == HID_GD_MOUSE &&\n\t\t    size <= 8) {\n\t\t\tu8 mouse_report[9];\n\n\t\t\t \n\t\t\tmouse_report[0] = REPORT_TYPE_MOUSE;\n\t\t\tmemcpy(mouse_report + 1, data, size);\n\t\t\tlogi_dj_recv_forward_input_report(hdev, mouse_report,\n\t\t\t\t\t\t\t  size + 1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tswitch (data[0]) {\n\tcase REPORT_ID_DJ_SHORT:\n\t\tif (size != DJREPORT_SHORT_LENGTH) {\n\t\t\thid_err(hdev, \"Short DJ report bad size (%d)\", size);\n\t\t\treturn false;\n\t\t}\n\t\treturn logi_dj_dj_event(hdev, report, data, size);\n\tcase REPORT_ID_DJ_LONG:\n\t\tif (size != DJREPORT_LONG_LENGTH) {\n\t\t\thid_err(hdev, \"Long DJ report bad size (%d)\", size);\n\t\t\treturn false;\n\t\t}\n\t\treturn logi_dj_dj_event(hdev, report, data, size);\n\tcase REPORT_ID_HIDPP_SHORT:\n\t\tif (size != HIDPP_REPORT_SHORT_LENGTH) {\n\t\t\thid_err(hdev, \"Short HID++ report bad size (%d)\", size);\n\t\t\treturn false;\n\t\t}\n\t\treturn logi_dj_hidpp_event(hdev, report, data, size);\n\tcase REPORT_ID_HIDPP_LONG:\n\t\tif (size != HIDPP_REPORT_LONG_LENGTH) {\n\t\t\thid_err(hdev, \"Long HID++ report bad size (%d)\", size);\n\t\t\treturn false;\n\t\t}\n\t\treturn logi_dj_hidpp_event(hdev, report, data, size);\n\t}\n\n\tlogi_dj_recv_forward_input_report(hdev, data, size);\n\n\treturn false;\n}\n\nstatic int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *rep;\n\tstruct dj_receiver_dev *djrcv_dev;\n\tstruct usb_interface *intf;\n\tunsigned int no_dj_interfaces = 0;\n\tbool has_hidpp = false;\n\tunsigned long flags;\n\tint retval;\n\n\t \n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: parse failed\\n\", __func__);\n\t\treturn retval;\n\t}\n\n\t \n\tswitch (id->driver_data) {\n\tcase recvr_type_dj:\t\tno_dj_interfaces = 3; break;\n\tcase recvr_type_hidpp:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_gaming_hidpp:\tno_dj_interfaces = 3; break;\n\tcase recvr_type_mouse_only:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_27mhz:\t\tno_dj_interfaces = 2; break;\n\tcase recvr_type_bluetooth:\tno_dj_interfaces = 2; break;\n\tcase recvr_type_dinovo:\t\tno_dj_interfaces = 2; break;\n\t}\n\tif (hid_is_usb(hdev)) {\n\t\tintf = to_usb_interface(hdev->dev.parent);\n\t\tif (intf && intf->altsetting->desc.bInterfaceNumber >=\n\t\t\t\t\t\t\tno_dj_interfaces) {\n\t\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\t\t\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\t\t}\n\t}\n\n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\n\t \n\tif (list_empty(&rep_enum->report_list))\n\t\treturn -ENODEV;\n\n\t \n\tlist_for_each_entry(rep, &rep_enum->report_list, list) {\n\t\tif (rep->application == 0xff000001)\n\t\t\thas_hidpp = true;\n\t}\n\n\t \n\tif (!has_hidpp && id->driver_data == recvr_type_dj)\n\t\treturn -ENODEV;\n\n\t \n\trep = list_first_entry(&rep_enum->report_list, struct hid_report, list);\n\tdjrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,\n\t\t\t\t\trep->application, has_hidpp);\n\tif (!djrcv_dev) {\n\t\thid_err(hdev, \"%s: dj_get_receiver_dev failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!rep_enum->numbered)\n\t\tdjrcv_dev->unnumbered_application = rep->application;\n\n\t \n\tretval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);\n\tif (retval) {\n\t\thid_err(hdev, \"%s: hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\n\tif (has_hidpp) {\n\t\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto switch_to_dj_mode_fail;\n\t\t}\n\t}\n\n\t \n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\n\t \n\thid_device_io_start(hdev);\n\n\tif (has_hidpp) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdjrcv_dev->ready = true;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\t\tif (retval < 0) {\n\t\t\thid_err(hdev, \"%s: logi_dj_recv_query_paired_devices error:%d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\t \n\t\t}\n\t}\n\n\treturn 0;\n\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\n\nhid_hw_start_fail:\n\tdj_put_receiver_dev(hdev);\n\treturn retval;\n}\n\n#ifdef CONFIG_PM\nstatic int logi_dj_reset_resume(struct hid_device *hdev)\n{\n\tint retval;\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\n\tif (!djrcv_dev || djrcv_dev->hidpp != hdev)\n\t\treturn 0;\n\n\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\tif (retval < 0) {\n\t\thid_err(hdev, \"%s: logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic void logi_dj_remove(struct hid_device *hdev)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\tint i;\n\n\tdbg_hid(\"%s\\n\", __func__);\n\n\tif (!djrcv_dev)\n\t\treturn hid_hw_stop(hdev);\n\n\t \n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdjrcv_dev->ready = false;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\n\tcancel_work_sync(&djrcv_dev->work);\n\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n\n\t \n\tfor (i = 0; i < (DJ_MAX_PAIRED_DEVICES + DJ_DEVICE_INDEX_MIN); i++) {\n\t\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\t\tdj_dev = djrcv_dev->paired_dj_devices[i];\n\t\tdjrcv_dev->paired_dj_devices[i] = NULL;\n\t\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\t\tif (dj_dev != NULL) {\n\t\t\thid_destroy_device(dj_dev->hdev);\n\t\t\tkfree(dj_dev);\n\t\t}\n\t}\n\n\tdj_put_receiver_dev(hdev);\n}\n\nstatic const struct hid_device_id logi_dj_receivers[] = {\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER),\n\t .driver_data = recvr_type_dj},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2),\n\t .driver_data = recvr_type_dj},\n\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t\t USB_DEVICE_ID_LOGITECH_NANO_RECEIVER),\n\t .driver_data = recvr_type_mouse_only},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t\t USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_2),\n\t .driver_data = recvr_type_hidpp},\n\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t\t USB_DEVICE_ID_LOGITECH_G700_RECEIVER),\n\t .driver_data = recvr_type_gaming_hidpp},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\t0xc537),\n\t .driver_data = recvr_type_gaming_hidpp},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_NANO_RECEIVER_LIGHTSPEED_1),\n\t .driver_data = recvr_type_gaming_hidpp},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_NANO_RECEIVER_POWERPLAY),\n\t .driver_data = recvr_type_gaming_hidpp},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_NANO_RECEIVER_LIGHTSPEED_1_1),\n\t .driver_data = recvr_type_gaming_hidpp},\n\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_MX3000_RECEIVER),\n\t .driver_data = recvr_type_27mhz},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_S510_RECEIVER_2),\n\t .driver_data = recvr_type_27mhz},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_LOGITECH_27MHZ_MOUSE_RECEIVER),\n\t .driver_data = recvr_type_27mhz},\n\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_MX5000_RECEIVER_KBD_DEV),\n\t .driver_data = recvr_type_bluetooth},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_MX5000_RECEIVER_MOUSE_DEV),\n\t .driver_data = recvr_type_bluetooth},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_MX5500_RECEIVER_KBD_DEV),\n\t .driver_data = recvr_type_bluetooth},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_MX5500_RECEIVER_MOUSE_DEV),\n\t .driver_data = recvr_type_bluetooth},\n\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_DINOVO_EDGE_RECEIVER_KBD_DEV),\n\t .driver_data = recvr_type_dinovo},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_DINOVO_EDGE_RECEIVER_MOUSE_DEV),\n\t .driver_data = recvr_type_dinovo},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_DINOVO_MINI_RECEIVER_KBD_DEV),\n\t .driver_data = recvr_type_dinovo},\n\t{  \n\t  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,\n\t\tUSB_DEVICE_ID_DINOVO_MINI_RECEIVER_MOUSE_DEV),\n\t .driver_data = recvr_type_dinovo},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(hid, logi_dj_receivers);\n\nstatic struct hid_driver logi_djreceiver_driver = {\n\t.name = \"logitech-djreceiver\",\n\t.id_table = logi_dj_receivers,\n\t.probe = logi_dj_probe,\n\t.remove = logi_dj_remove,\n\t.raw_event = logi_dj_raw_event,\n#ifdef CONFIG_PM\n\t.reset_resume = logi_dj_reset_resume,\n#endif\n};\n\nmodule_hid_driver(logi_djreceiver_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Logitech\");\nMODULE_AUTHOR(\"Nestor Lopez Casado\");\nMODULE_AUTHOR(\"nlopezcasad@logitech.com\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}