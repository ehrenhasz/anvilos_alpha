{
  "module_name": "hid-dr.c",
  "hash_id": "c7c16d0690916aede7058a2d54bf624c437d2a4b7029db52d6f75f218e077a25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-dr.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#ifdef CONFIG_DRAGONRISE_FF\n\nstruct drff_device {\n\tstruct hid_report *report;\n};\n\nstatic int drff_play(struct input_dev *dev, void *data,\n\t\t\t\t struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct drff_device *drff = data;\n\tint strong, weak;\n\n\tstrong = effect->u.rumble.strong_magnitude;\n\tweak = effect->u.rumble.weak_magnitude;\n\n\tdbg_hid(\"called with 0x%04x 0x%04x\", strong, weak);\n\n\tif (strong || weak) {\n\t\tstrong = strong * 0xff / 0xffff;\n\t\tweak = weak * 0xff / 0xffff;\n\n\t\t \n\t\tif (weak == 0x0a)\n\t\t\tweak = 0x0b;\n\n\t\tdrff->report->field[0]->value[0] = 0x51;\n\t\tdrff->report->field[0]->value[1] = 0x00;\n\t\tdrff->report->field[0]->value[2] = weak;\n\t\tdrff->report->field[0]->value[4] = strong;\n\t\thid_hw_request(hid, drff->report, HID_REQ_SET_REPORT);\n\n\t\tdrff->report->field[0]->value[0] = 0xfa;\n\t\tdrff->report->field[0]->value[1] = 0xfe;\n\t} else {\n\t\tdrff->report->field[0]->value[0] = 0xf3;\n\t\tdrff->report->field[0]->value[1] = 0x00;\n\t}\n\n\tdrff->report->field[0]->value[2] = 0x00;\n\tdrff->report->field[0]->value[4] = 0x00;\n\tdbg_hid(\"running with 0x%02x 0x%02x\", strong, weak);\n\thid_hw_request(hid, drff->report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}\n\nstatic int drff_init(struct hid_device *hid)\n{\n\tstruct drff_device *drff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput;\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev;\n\tint error;\n\n\tif (list_empty(&hid->inputs)) {\n\t\thid_err(hid, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_first_entry(&hid->inputs, struct hid_input, list);\n\tdev = hidinput->input;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrff = kzalloc(sizeof(struct drff_device), GFP_KERNEL);\n\tif (!drff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, drff, drff_play);\n\tif (error) {\n\t\tkfree(drff);\n\t\treturn error;\n\t}\n\n\tdrff->report = report;\n\tdrff->report->field[0]->value[0] = 0xf3;\n\tdrff->report->field[0]->value[1] = 0x00;\n\tdrff->report->field[0]->value[2] = 0x00;\n\tdrff->report->field[0]->value[3] = 0x00;\n\tdrff->report->field[0]->value[4] = 0x00;\n\tdrff->report->field[0]->value[5] = 0x00;\n\tdrff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, drff->report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force Feedback for DragonRise Inc. \"\n\t\t \"game controllers by Richard Walmsley <richwalm@gmail.com>\\n\");\n\n\treturn 0;\n}\n#else\nstatic inline int drff_init(struct hid_device *hid)\n{\n\treturn 0;\n}\n#endif\n\n \n\n \n#define PID0011_RDESC_ORIG_SIZE\t101\n\n \nstatic __u8 pid0011_rdesc_fixed[] = {\n\t0x05, 0x01,          \n\t0x09, 0x04,          \n\t0xA1, 0x01,          \n\t0xA1, 0x02,          \n\t0x14,                \n\t0x75, 0x08,          \n\t0x95, 0x03,          \n\t0x81, 0x01,          \n\t0x26, 0xFF, 0x00,    \n\t0x95, 0x02,          \n\t0x09, 0x30,          \n\t0x09, 0x31,          \n\t0x81, 0x02,          \n\t0x75, 0x01,          \n\t0x95, 0x04,          \n\t0x81, 0x01,          \n\t0x25, 0x01,          \n\t0x95, 0x0A,          \n\t0x05, 0x09,          \n\t0x19, 0x01,          \n\t0x29, 0x0A,          \n\t0x81, 0x02,          \n\t0x95, 0x0A,          \n\t0x81, 0x01,          \n\t0xC0,                \n\t0xC0                 \n};\n\nstatic __u8 *dr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\t\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase 0x0011:\n\t\tif (*rsize == PID0011_RDESC_ORIG_SIZE) {\n\t\t\trdesc = pid0011_rdesc_fixed;\n\t\t\t*rsize = sizeof(pid0011_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\t}\n\treturn rdesc;\n}\n\n#define map_abs(c)      hid_map_usage(hi, usage, bit, max, EV_ABS, (c))\n#define map_rel(c)      hid_map_usage(hi, usage, bit, max, EV_REL, (c))\n\nstatic int dr_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t    struct hid_field *field, struct hid_usage *usage,\n\t\t\t    unsigned long **bit, int *max)\n{\n\tswitch (usage->hid) {\n\t \n\tcase HID_GD_X: case HID_GD_Y: case HID_GD_Z:\n\tcase HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:\n\t\tif (field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\t\tmap_rel(usage->hid & 0xf);\n\t\telse\n\t\t\tmap_abs(usage->hid & 0xf);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int dr_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\n\tdev_dbg(&hdev->dev, \"DragonRise Inc. HID hardware probe...\");\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err;\n\t}\n\n\tswitch (hdev->product) {\n\tcase 0x0006:\n\t\tret = drff_init(hdev);\n\t\tif (ret) {\n\t\t\tdev_err(&hdev->dev, \"force feedback init failed\\n\");\n\t\t\thid_hw_stop(hdev);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic const struct hid_device_id dr_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, 0x0006),  },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, 0x0011),  },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, dr_devices);\n\nstatic struct hid_driver dr_driver = {\n\t.name = \"dragonrise\",\n\t.id_table = dr_devices,\n\t.report_fixup = dr_report_fixup,\n\t.probe = dr_probe,\n\t.input_mapping = dr_input_mapping,\n};\nmodule_hid_driver(dr_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}