{
  "module_name": "hid-uclogic-params.c",
  "hash_id": "4687f614c4b83b33bd8fcf698094dd80509913571e07fa300d35d2983c6fb5c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-uclogic-params.c",
  "human_readable_source": "\n \n\n \n\n#include \"hid-uclogic-params.h\"\n#include \"hid-uclogic-rdesc.h\"\n#include \"usbhid/usbhid.h\"\n#include \"hid-ids.h\"\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <asm/unaligned.h>\n\n \nstatic const char *uclogic_params_pen_inrange_to_str(\n\t\t\t\tenum uclogic_params_pen_inrange inrange)\n{\n\tswitch (inrange) {\n\tcase UCLOGIC_PARAMS_PEN_INRANGE_NORMAL:\n\t\treturn \"normal\";\n\tcase UCLOGIC_PARAMS_PEN_INRANGE_INVERTED:\n\t\treturn \"inverted\";\n\tcase UCLOGIC_PARAMS_PEN_INRANGE_NONE:\n\t\treturn \"none\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nstatic void uclogic_params_pen_hid_dbg(const struct hid_device *hdev,\n\t\t\t\t\tconst struct uclogic_params_pen *pen)\n{\n\tsize_t i;\n\n\thid_dbg(hdev, \"\\t.usage_invalid = %s\\n\",\n\t\t(pen->usage_invalid ? \"true\" : \"false\"));\n\thid_dbg(hdev, \"\\t.desc_ptr = %p\\n\", pen->desc_ptr);\n\thid_dbg(hdev, \"\\t.desc_size = %u\\n\", pen->desc_size);\n\thid_dbg(hdev, \"\\t.id = %u\\n\", pen->id);\n\thid_dbg(hdev, \"\\t.subreport_list = {\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(pen->subreport_list); i++) {\n\t\thid_dbg(hdev, \"\\t\\t{0x%02hhx, %hhu}%s\\n\",\n\t\t\tpen->subreport_list[i].value,\n\t\t\tpen->subreport_list[i].id,\n\t\t\ti < (ARRAY_SIZE(pen->subreport_list) - 1) ? \",\" : \"\");\n\t}\n\thid_dbg(hdev, \"\\t}\\n\");\n\thid_dbg(hdev, \"\\t.inrange = %s\\n\",\n\t\tuclogic_params_pen_inrange_to_str(pen->inrange));\n\thid_dbg(hdev, \"\\t.fragmented_hires = %s\\n\",\n\t\t(pen->fragmented_hires ? \"true\" : \"false\"));\n\thid_dbg(hdev, \"\\t.tilt_y_flipped = %s\\n\",\n\t\t(pen->tilt_y_flipped ? \"true\" : \"false\"));\n}\n\n \nstatic void uclogic_params_frame_hid_dbg(\n\t\t\t\tconst struct hid_device *hdev,\n\t\t\t\tconst struct uclogic_params_frame *frame)\n{\n\thid_dbg(hdev, \"\\t\\t.desc_ptr = %p\\n\", frame->desc_ptr);\n\thid_dbg(hdev, \"\\t\\t.desc_size = %u\\n\", frame->desc_size);\n\thid_dbg(hdev, \"\\t\\t.id = %u\\n\", frame->id);\n\thid_dbg(hdev, \"\\t\\t.suffix = %s\\n\", frame->suffix);\n\thid_dbg(hdev, \"\\t\\t.re_lsb = %u\\n\", frame->re_lsb);\n\thid_dbg(hdev, \"\\t\\t.dev_id_byte = %u\\n\", frame->dev_id_byte);\n\thid_dbg(hdev, \"\\t\\t.touch_byte = %u\\n\", frame->touch_byte);\n\thid_dbg(hdev, \"\\t\\t.touch_max = %hhd\\n\", frame->touch_max);\n\thid_dbg(hdev, \"\\t\\t.touch_flip_at = %hhd\\n\",\n\t\tframe->touch_flip_at);\n\thid_dbg(hdev, \"\\t\\t.bitmap_dial_byte = %u\\n\",\n\t\tframe->bitmap_dial_byte);\n}\n\n \nvoid uclogic_params_hid_dbg(const struct hid_device *hdev,\n\t\t\t\tconst struct uclogic_params *params)\n{\n\tsize_t i;\n\n\thid_dbg(hdev, \".invalid = %s\\n\",\n\t\tparams->invalid ? \"true\" : \"false\");\n\thid_dbg(hdev, \".desc_ptr = %p\\n\", params->desc_ptr);\n\thid_dbg(hdev, \".desc_size = %u\\n\", params->desc_size);\n\thid_dbg(hdev, \".pen = {\\n\");\n\tuclogic_params_pen_hid_dbg(hdev, &params->pen);\n\thid_dbg(hdev, \"\\t}\\n\");\n\thid_dbg(hdev, \".frame_list = {\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(params->frame_list); i++) {\n\t\thid_dbg(hdev, \"\\t{\\n\");\n\t\tuclogic_params_frame_hid_dbg(hdev, &params->frame_list[i]);\n\t\thid_dbg(hdev, \"\\t}%s\\n\",\n\t\t\ti < (ARRAY_SIZE(params->frame_list) - 1) ? \",\" : \"\");\n\t}\n\thid_dbg(hdev, \"}\\n\");\n}\n\n \nstatic int uclogic_params_get_str_desc(__u8 **pbuf, struct hid_device *hdev,\n\t\t\t\t\t__u8 idx, size_t len)\n{\n\tint rc;\n\tstruct usb_device *udev;\n\t__u8 *buf = NULL;\n\n\t \n\tif (hdev == NULL) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tudev = hid_to_usb_dev(hdev);\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\trc = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\t(USB_DT_STRING << 8) + idx,\n\t\t\t\t0x0409, buf, len,\n\t\t\t\tUSB_CTRL_GET_TIMEOUT);\n\tif (rc == -EPIPE) {\n\t\thid_dbg(hdev, \"string descriptor #%hhu not found\\n\", idx);\n\t\tgoto cleanup;\n\t} else if (rc < 0) {\n\t\thid_err(hdev,\n\t\t\t\"failed retrieving string descriptor #%u: %d\\n\",\n\t\t\tidx, rc);\n\t\tgoto cleanup;\n\t}\n\n\tif (pbuf != NULL) {\n\t\t*pbuf = buf;\n\t\tbuf = NULL;\n\t}\n\ncleanup:\n\tkfree(buf);\n\treturn rc;\n}\n\n \nstatic void uclogic_params_pen_cleanup(struct uclogic_params_pen *pen)\n{\n\tkfree(pen->desc_ptr);\n\tmemset(pen, 0, sizeof(*pen));\n}\n\n \nstatic int uclogic_params_pen_init_v1(struct uclogic_params_pen *pen,\n\t\t\t\t      bool *pfound,\n\t\t\t\t      struct hid_device *hdev)\n{\n\tint rc;\n\tbool found = false;\n\t \n\t__u8 *buf = NULL;\n\t \n\tconst int len = 12;\n\ts32 resolution;\n\t \n\ts32 desc_params[UCLOGIC_RDESC_PH_ID_NUM];\n\t__u8 *desc_ptr = NULL;\n\n\t \n\tif (pen == NULL || pfound == NULL || hdev == NULL) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\trc = uclogic_params_get_str_desc(&buf, hdev, 100, len);\n\tif (rc == -EPIPE) {\n\t\thid_dbg(hdev,\n\t\t\t\"string descriptor with pen parameters not found, assuming not compatible\\n\");\n\t\tgoto finish;\n\t} else if (rc < 0) {\n\t\thid_err(hdev, \"failed retrieving pen parameters: %d\\n\", rc);\n\t\tgoto cleanup;\n\t} else if (rc != len) {\n\t\thid_dbg(hdev,\n\t\t\t\"string descriptor with pen parameters has invalid length (got %d, expected %d), assuming not compatible\\n\",\n\t\t\trc, len);\n\t\tgoto finish;\n\t}\n\n\t \n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_LM] =\n\t\tget_unaligned_le16(buf + 2);\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_LM] =\n\t\tget_unaligned_le16(buf + 4);\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_PRESSURE_LM] =\n\t\tget_unaligned_le16(buf + 8);\n\tresolution = get_unaligned_le16(buf + 10);\n\tif (resolution == 0) {\n\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_PM] = 0;\n\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_PM] = 0;\n\t} else {\n\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_PM] =\n\t\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_LM] * 1000 /\n\t\t\tresolution;\n\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_PM] =\n\t\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_LM] * 1000 /\n\t\t\tresolution;\n\t}\n\tkfree(buf);\n\tbuf = NULL;\n\n\t \n\tdesc_ptr = uclogic_rdesc_template_apply(\n\t\t\t\tuclogic_rdesc_v1_pen_template_arr,\n\t\t\t\tuclogic_rdesc_v1_pen_template_size,\n\t\t\t\tdesc_params, ARRAY_SIZE(desc_params));\n\tif (desc_ptr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tmemset(pen, 0, sizeof(*pen));\n\tpen->desc_ptr = desc_ptr;\n\tdesc_ptr = NULL;\n\tpen->desc_size = uclogic_rdesc_v1_pen_template_size;\n\tpen->id = UCLOGIC_RDESC_V1_PEN_ID;\n\tpen->inrange = UCLOGIC_PARAMS_PEN_INRANGE_INVERTED;\n\tfound = true;\nfinish:\n\t*pfound = found;\n\trc = 0;\ncleanup:\n\tkfree(desc_ptr);\n\tkfree(buf);\n\treturn rc;\n}\n\n \nstatic s32 uclogic_params_get_le24(const void *p)\n{\n\tconst __u8 *b = p;\n\treturn b[0] | (b[1] << 8UL) | (b[2] << 16UL);\n}\n\n \nstatic int uclogic_params_pen_init_v2(struct uclogic_params_pen *pen,\n\t\t\t\t\tbool *pfound,\n\t\t\t\t\t__u8 **pparams_ptr,\n\t\t\t\t\tsize_t *pparams_len,\n\t\t\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tbool found = false;\n\t \n\t__u8 *buf = NULL;\n\t \n\tconst int params_len_min = 18;\n\t \n\tconst int params_len_max = 32;\n\t \n\tint params_len;\n\tsize_t i;\n\ts32 resolution;\n\t \n\ts32 desc_params[UCLOGIC_RDESC_PH_ID_NUM];\n\t__u8 *desc_ptr = NULL;\n\n\t \n\tif (pen == NULL || pfound == NULL || hdev == NULL) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\trc = uclogic_params_get_str_desc(&buf, hdev, 200, params_len_max);\n\tif (rc == -EPIPE) {\n\t\thid_dbg(hdev,\n\t\t\t\"string descriptor with pen parameters not found, assuming not compatible\\n\");\n\t\tgoto finish;\n\t} else if (rc < 0) {\n\t\thid_err(hdev, \"failed retrieving pen parameters: %d\\n\", rc);\n\t\tgoto cleanup;\n\t} else if (rc < params_len_min) {\n\t\thid_dbg(hdev,\n\t\t\t\"string descriptor with pen parameters is too short (got %d, expected at least %d), assuming not compatible\\n\",\n\t\t\trc, params_len_min);\n\t\tgoto finish;\n\t}\n\n\tparams_len = rc;\n\n\t \n\tfor (i = 2;\n\t     i < params_len &&\n\t\t(buf[i] >= 0x20 && buf[i] < 0x7f && buf[i + 1] == 0);\n\t     i += 2);\n\tif (i >= params_len) {\n\t\thid_dbg(hdev,\n\t\t\t\"string descriptor with pen parameters seems to contain only text, assuming not compatible\\n\");\n\t\tgoto finish;\n\t}\n\n\t \n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_LM] =\n\t\tuclogic_params_get_le24(buf + 2);\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_LM] =\n\t\tuclogic_params_get_le24(buf + 5);\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_PRESSURE_LM] =\n\t\tget_unaligned_le16(buf + 8);\n\tresolution = get_unaligned_le16(buf + 10);\n\tif (resolution == 0) {\n\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_PM] = 0;\n\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_PM] = 0;\n\t} else {\n\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_PM] =\n\t\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_LM] * 1000 /\n\t\t\tresolution;\n\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_PM] =\n\t\t\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_LM] * 1000 /\n\t\t\tresolution;\n\t}\n\n\t \n\tdesc_ptr = uclogic_rdesc_template_apply(\n\t\t\t\tuclogic_rdesc_v2_pen_template_arr,\n\t\t\t\tuclogic_rdesc_v2_pen_template_size,\n\t\t\t\tdesc_params, ARRAY_SIZE(desc_params));\n\tif (desc_ptr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tmemset(pen, 0, sizeof(*pen));\n\tpen->desc_ptr = desc_ptr;\n\tdesc_ptr = NULL;\n\tpen->desc_size = uclogic_rdesc_v2_pen_template_size;\n\tpen->id = UCLOGIC_RDESC_V2_PEN_ID;\n\tpen->inrange = UCLOGIC_PARAMS_PEN_INRANGE_NONE;\n\tpen->fragmented_hires = true;\n\tpen->tilt_y_flipped = true;\n\tfound = true;\n\tif (pparams_ptr != NULL) {\n\t\t*pparams_ptr = buf;\n\t\tbuf = NULL;\n\t}\n\tif (pparams_len != NULL)\n\t\t*pparams_len = params_len;\n\nfinish:\n\t*pfound = found;\n\trc = 0;\ncleanup:\n\tkfree(desc_ptr);\n\tkfree(buf);\n\treturn rc;\n}\n\n \nstatic void uclogic_params_frame_cleanup(struct uclogic_params_frame *frame)\n{\n\tkfree(frame->desc_ptr);\n\tmemset(frame, 0, sizeof(*frame));\n}\n\n \nstatic int uclogic_params_frame_init_with_desc(\n\t\t\t\t\tstruct uclogic_params_frame *frame,\n\t\t\t\t\tconst __u8 *desc_ptr,\n\t\t\t\t\tsize_t desc_size,\n\t\t\t\t\tunsigned int id)\n{\n\t__u8 *copy_desc_ptr;\n\n\tif (frame == NULL || (desc_ptr == NULL && desc_size != 0))\n\t\treturn -EINVAL;\n\n\tcopy_desc_ptr = kmemdup(desc_ptr, desc_size, GFP_KERNEL);\n\tif (copy_desc_ptr == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(frame, 0, sizeof(*frame));\n\tframe->desc_ptr = copy_desc_ptr;\n\tframe->desc_size = desc_size;\n\tframe->id = id;\n\treturn 0;\n}\n\n \nstatic int uclogic_params_frame_init_v1(struct uclogic_params_frame *frame,\n\t\t\t\t\tbool *pfound,\n\t\t\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tbool found = false;\n\tstruct usb_device *usb_dev;\n\tchar *str_buf = NULL;\n\tconst size_t str_len = 16;\n\n\t \n\tif (frame == NULL || pfound == NULL || hdev == NULL) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tusb_dev = hid_to_usb_dev(hdev);\n\n\t \n\tstr_buf = kzalloc(str_len, GFP_KERNEL);\n\tif (str_buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\trc = usb_string(usb_dev, 123, str_buf, str_len);\n\tif (rc == -EPIPE) {\n\t\thid_dbg(hdev,\n\t\t\t\"generic button -enabling string descriptor not found\\n\");\n\t} else if (rc < 0) {\n\t\tgoto cleanup;\n\t} else if (strncmp(str_buf, \"HK On\", rc) != 0) {\n\t\thid_dbg(hdev,\n\t\t\t\"invalid response to enabling generic buttons: \\\"%s\\\"\\n\",\n\t\t\tstr_buf);\n\t} else {\n\t\thid_dbg(hdev, \"generic buttons enabled\\n\");\n\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\tframe,\n\t\t\t\tuclogic_rdesc_v1_frame_arr,\n\t\t\t\tuclogic_rdesc_v1_frame_size,\n\t\t\t\tUCLOGIC_RDESC_V1_FRAME_ID);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tfound = true;\n\t}\n\n\t*pfound = found;\n\trc = 0;\ncleanup:\n\tkfree(str_buf);\n\treturn rc;\n}\n\n \nstatic void uclogic_params_cleanup_event_hooks(struct uclogic_params *params)\n{\n\tstruct uclogic_raw_event_hook *curr, *n;\n\n\tif (!params || !params->event_hooks)\n\t\treturn;\n\n\tlist_for_each_entry_safe(curr, n, &params->event_hooks->list, list) {\n\t\tcancel_work_sync(&curr->work);\n\t\tlist_del(&curr->list);\n\t\tkfree(curr->event);\n\t\tkfree(curr);\n\t}\n\n\tkfree(params->event_hooks);\n\tparams->event_hooks = NULL;\n}\n\n \nvoid uclogic_params_cleanup(struct uclogic_params *params)\n{\n\tif (!params->invalid) {\n\t\tsize_t i;\n\t\tkfree(params->desc_ptr);\n\t\tuclogic_params_pen_cleanup(&params->pen);\n\t\tfor (i = 0; i < ARRAY_SIZE(params->frame_list); i++)\n\t\t\tuclogic_params_frame_cleanup(&params->frame_list[i]);\n\n\t\tuclogic_params_cleanup_event_hooks(params);\n\t\tmemset(params, 0, sizeof(*params));\n\t}\n}\n\n \nint uclogic_params_get_desc(const struct uclogic_params *params,\n\t\t\t\t__u8 **pdesc,\n\t\t\t\tunsigned int *psize)\n{\n\tint rc = -ENOMEM;\n\tbool present = false;\n\tunsigned int size = 0;\n\t__u8 *desc = NULL;\n\tsize_t i;\n\n\t \n\tif (params == NULL || pdesc == NULL || psize == NULL)\n\t\treturn -EINVAL;\n\n\t \n#define ADD_DESC(_desc_ptr, _desc_size) \\\n\tdo {                                                        \\\n\t\tunsigned int new_size;                              \\\n\t\t__u8 *new_desc;                                     \\\n\t\tif ((_desc_ptr) == NULL) {                          \\\n\t\t\tbreak;                                      \\\n\t\t}                                                   \\\n\t\tnew_size = size + (_desc_size);                     \\\n\t\tnew_desc = krealloc(desc, new_size, GFP_KERNEL);    \\\n\t\tif (new_desc == NULL) {                             \\\n\t\t\tgoto cleanup;                               \\\n\t\t}                                                   \\\n\t\tmemcpy(new_desc + size, (_desc_ptr), (_desc_size)); \\\n\t\tdesc = new_desc;                                    \\\n\t\tsize = new_size;                                    \\\n\t\tpresent = true;                                     \\\n\t} while (0)\n\n\tADD_DESC(params->desc_ptr, params->desc_size);\n\tADD_DESC(params->pen.desc_ptr, params->pen.desc_size);\n\tfor (i = 0; i < ARRAY_SIZE(params->frame_list); i++) {\n\t\tADD_DESC(params->frame_list[i].desc_ptr,\n\t\t\t\tparams->frame_list[i].desc_size);\n\t}\n\n#undef ADD_DESC\n\n\tif (present) {\n\t\t*pdesc = desc;\n\t\t*psize = size;\n\t\tdesc = NULL;\n\t}\n\trc = 0;\ncleanup:\n\tkfree(desc);\n\treturn rc;\n}\n\n \nstatic void uclogic_params_init_invalid(struct uclogic_params *params)\n{\n\tparams->invalid = true;\n}\n\n \nstatic int uclogic_params_init_with_opt_desc(struct uclogic_params *params,\n\t\t\t\t\t     struct hid_device *hdev,\n\t\t\t\t\t     unsigned int orig_desc_size,\n\t\t\t\t\t     __u8 *desc_ptr,\n\t\t\t\t\t     unsigned int desc_size)\n{\n\t__u8 *desc_copy_ptr = NULL;\n\tunsigned int desc_copy_size;\n\tint rc;\n\n\t \n\tif (params == NULL || hdev == NULL ||\n\t    (desc_ptr == NULL && desc_size != 0)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (hdev->dev_rsize == orig_desc_size) {\n\t\thid_dbg(hdev,\n\t\t\t\"device report descriptor matches the expected size, replacing\\n\");\n\t\tdesc_copy_ptr = kmemdup(desc_ptr, desc_size, GFP_KERNEL);\n\t\tif (desc_copy_ptr == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tdesc_copy_size = desc_size;\n\t} else {\n\t\thid_dbg(hdev,\n\t\t\t\"device report descriptor doesn't match the expected size (%u != %u), preserving\\n\",\n\t\t\thdev->dev_rsize, orig_desc_size);\n\t\tdesc_copy_ptr = NULL;\n\t\tdesc_copy_size = 0;\n\t}\n\n\t \n\tmemset(params, 0, sizeof(*params));\n\tparams->desc_ptr = desc_copy_ptr;\n\tdesc_copy_ptr = NULL;\n\tparams->desc_size = desc_copy_size;\n\n\trc = 0;\ncleanup:\n\tkfree(desc_copy_ptr);\n\treturn rc;\n}\n\n \nstatic int uclogic_params_huion_init(struct uclogic_params *params,\n\t\t\t\t     struct hid_device *hdev)\n{\n\tint rc;\n\tstruct usb_device *udev;\n\tstruct usb_interface *iface;\n\t__u8 bInterfaceNumber;\n\tbool found;\n\t \n\tstruct uclogic_params p = {0, };\n\tstatic const char transition_ver[] = \"HUION_T153_160607\";\n\tchar *ver_ptr = NULL;\n\tconst size_t ver_len = sizeof(transition_ver) + 1;\n\t__u8 *params_ptr = NULL;\n\tsize_t params_len = 0;\n\t \n\tconst __u8 touch_ring_model_params_buf[] = {\n\t\t0x13, 0x03, 0x70, 0xC6, 0x00, 0x06, 0x7C, 0x00,\n\t\t0xFF, 0x1F, 0xD8, 0x13, 0x03, 0x0D, 0x10, 0x01,\n\t\t0x04, 0x3C, 0x3E\n\t};\n\n\t \n\tif (params == NULL || hdev == NULL) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tudev = hid_to_usb_dev(hdev);\n\tiface = to_usb_interface(hdev->dev.parent);\n\tbInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n\tif (bInterfaceNumber == 1) {\n\t\t \n\t\tp.pen.usage_invalid = true;\n\t\tgoto output;\n\t \n\t} else if (bInterfaceNumber != 0) {\n\t\tuclogic_params_init_invalid(&p);\n\t\tgoto output;\n\t}\n\n\t \n\tver_ptr = kzalloc(ver_len, GFP_KERNEL);\n\tif (ver_ptr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\trc = usb_string(udev, 201, ver_ptr, ver_len);\n\tif (rc == -EPIPE) {\n\t\t*ver_ptr = '\\0';\n\t} else if (rc < 0) {\n\t\thid_err(hdev,\n\t\t\t\"failed retrieving Huion firmware version: %d\\n\", rc);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (strcmp(ver_ptr, transition_ver) == 0) {\n\t\thid_dbg(hdev,\n\t\t\t\"transition firmware detected, not probing pen v2 parameters\\n\");\n\t} else {\n\t\t \n\t\trc = uclogic_params_pen_init_v2(&p.pen, &found,\n\t\t\t\t\t\t&params_ptr, &params_len,\n\t\t\t\t\t\thdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev,\n\t\t\t\t\"failed probing pen v2 parameters: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\thid_dbg(hdev, \"pen v2 parameters found\\n\");\n\t\t\t \n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t\t&p.frame_list[0],\n\t\t\t\t\tuclogic_rdesc_v2_frame_buttons_arr,\n\t\t\t\t\tuclogic_rdesc_v2_frame_buttons_size,\n\t\t\t\t\tUCLOGIC_RDESC_V2_FRAME_BUTTONS_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating v2 frame button parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t \n\t\t\tp.pen.subreport_list[0].value = 0xe0;\n\t\t\tp.pen.subreport_list[0].id =\n\t\t\t\tUCLOGIC_RDESC_V2_FRAME_BUTTONS_ID;\n\n\t\t\t \n\t\t\tif (params_ptr != NULL &&\n\t\t\t    params_len == sizeof(touch_ring_model_params_buf) &&\n\t\t\t    memcmp(params_ptr, touch_ring_model_params_buf,\n\t\t\t\t   params_len) == 0) {\n\t\t\t\t \n\t\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t\t&p.frame_list[1],\n\t\t\t\t\tuclogic_rdesc_v2_frame_touch_ring_arr,\n\t\t\t\t\tuclogic_rdesc_v2_frame_touch_ring_size,\n\t\t\t\t\tUCLOGIC_RDESC_V2_FRAME_TOUCH_ID);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"failed creating v2 frame touch ring parameters: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp.frame_list[1].suffix = \"Touch Ring\";\n\t\t\t\tp.frame_list[1].dev_id_byte =\n\t\t\t\t\tUCLOGIC_RDESC_V2_FRAME_TOUCH_DEV_ID_BYTE;\n\t\t\t\tp.frame_list[1].touch_byte = 5;\n\t\t\t\tp.frame_list[1].touch_max = 12;\n\t\t\t\tp.frame_list[1].touch_flip_at = 7;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t\t&p.frame_list[1],\n\t\t\t\t\tuclogic_rdesc_v2_frame_touch_strip_arr,\n\t\t\t\t\tuclogic_rdesc_v2_frame_touch_strip_size,\n\t\t\t\t\tUCLOGIC_RDESC_V2_FRAME_TOUCH_ID);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"failed creating v2 frame touch strip parameters: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp.frame_list[1].suffix = \"Touch Strip\";\n\t\t\t\tp.frame_list[1].dev_id_byte =\n\t\t\t\t\tUCLOGIC_RDESC_V2_FRAME_TOUCH_DEV_ID_BYTE;\n\t\t\t\tp.frame_list[1].touch_byte = 5;\n\t\t\t\tp.frame_list[1].touch_max = 8;\n\t\t\t}\n\n\t\t\t \n\t\t\tp.pen.subreport_list[1].value = 0xf0;\n\t\t\tp.pen.subreport_list[1].id =\n\t\t\t\tUCLOGIC_RDESC_V2_FRAME_TOUCH_ID;\n\n\t\t\t \n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t\t&p.frame_list[2],\n\t\t\t\t\tuclogic_rdesc_v2_frame_dial_arr,\n\t\t\t\t\tuclogic_rdesc_v2_frame_dial_size,\n\t\t\t\t\tUCLOGIC_RDESC_V2_FRAME_DIAL_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating v2 frame dial parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tp.frame_list[2].suffix = \"Dial\";\n\t\t\tp.frame_list[2].dev_id_byte =\n\t\t\t\tUCLOGIC_RDESC_V2_FRAME_DIAL_DEV_ID_BYTE;\n\t\t\tp.frame_list[2].bitmap_dial_byte = 5;\n\n\t\t\t \n\t\t\tp.pen.subreport_list[2].value = 0xf1;\n\t\t\tp.pen.subreport_list[2].id =\n\t\t\t\tUCLOGIC_RDESC_V2_FRAME_DIAL_ID;\n\n\t\t\tgoto output;\n\t\t}\n\t\thid_dbg(hdev, \"pen v2 parameters not found\\n\");\n\t}\n\n\t \n\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\tif (rc != 0) {\n\t\thid_err(hdev,\n\t\t\t\"failed probing pen v1 parameters: %d\\n\", rc);\n\t\tgoto cleanup;\n\t} else if (found) {\n\t\thid_dbg(hdev, \"pen v1 parameters found\\n\");\n\t\t \n\t\trc = uclogic_params_frame_init_v1(&p.frame_list[0],\n\t\t\t\t\t\t  &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"v1 frame probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t}\n\t\thid_dbg(hdev, \"frame v1 parameters%s found\\n\",\n\t\t\t(found ? \"\" : \" not\"));\n\t\tif (found) {\n\t\t\t \n\t\t\tp.pen.subreport_list[0].value = 0xe0;\n\t\t\tp.pen.subreport_list[0].id =\n\t\t\t\tUCLOGIC_RDESC_V1_FRAME_ID;\n\t\t}\n\t\tgoto output;\n\t}\n\thid_dbg(hdev, \"pen v1 parameters not found\\n\");\n\n\tuclogic_params_init_invalid(&p);\n\noutput:\n\t \n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tkfree(params_ptr);\n\tkfree(ver_ptr);\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}\n\n \nstatic int uclogic_probe_interface(struct hid_device *hdev, const u8 *magic_arr,\n\t\t\t\t   size_t magic_size, int endpoint)\n{\n\tstruct usb_device *udev;\n\tunsigned int pipe = 0;\n\tint sent;\n\tu8 *buf = NULL;\n\tint rc = 0;\n\n\tif (!hdev || !magic_arr) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tbuf = kmemdup(magic_arr, magic_size, GFP_KERNEL);\n\tif (!buf) {\n\t\trc = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tudev = hid_to_usb_dev(hdev);\n\tpipe = usb_sndintpipe(udev, endpoint);\n\n\trc = usb_interrupt_msg(udev, pipe, buf, magic_size, &sent, 1000);\n\tif (rc || sent != magic_size) {\n\t\thid_err(hdev, \"Interface probing failed: %d\\n\", rc);\n\t\trc = -1;\n\t\tgoto cleanup;\n\t}\n\n\trc = 0;\ncleanup:\n\tkfree(buf);\n\treturn rc;\n}\n\n \nstatic int uclogic_params_parse_ugee_v2_desc(const __u8 *str_desc,\n\t\t\t\t\t     size_t str_desc_size,\n\t\t\t\t\t     s32 *desc_params,\n\t\t\t\t\t     size_t desc_params_size,\n\t\t\t\t\t     enum uclogic_params_frame_type *frame_type)\n{\n\ts32 pen_x_lm, pen_y_lm;\n\ts32 pen_x_pm, pen_y_pm;\n\ts32 pen_pressure_lm;\n\ts32 frame_num_buttons;\n\ts32 resolution;\n\n\t \n\tconst int min_str_desc_size = 12;\n\n\tif (!str_desc || str_desc_size < min_str_desc_size)\n\t\treturn -EINVAL;\n\n\tif (desc_params_size != UCLOGIC_RDESC_PH_ID_NUM)\n\t\treturn -EINVAL;\n\n\tpen_x_lm = get_unaligned_le16(str_desc + 2);\n\tpen_y_lm = get_unaligned_le16(str_desc + 4);\n\tframe_num_buttons = str_desc[6];\n\t*frame_type = str_desc[7];\n\tpen_pressure_lm = get_unaligned_le16(str_desc + 8);\n\n\tresolution = get_unaligned_le16(str_desc + 10);\n\tif (resolution == 0) {\n\t\tpen_x_pm = 0;\n\t\tpen_y_pm = 0;\n\t} else {\n\t\tpen_x_pm = pen_x_lm * 1000 / resolution;\n\t\tpen_y_pm = pen_y_lm * 1000 / resolution;\n\t}\n\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_LM] = pen_x_lm;\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_X_PM] = pen_x_pm;\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_LM] = pen_y_lm;\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_Y_PM] = pen_y_pm;\n\tdesc_params[UCLOGIC_RDESC_PEN_PH_ID_PRESSURE_LM] = pen_pressure_lm;\n\tdesc_params[UCLOGIC_RDESC_FRAME_PH_ID_UM] = frame_num_buttons;\n\n\treturn 0;\n}\n\n \nstatic int uclogic_params_ugee_v2_init_frame_buttons(struct uclogic_params *p,\n\t\t\t\t\t\t     const s32 *desc_params,\n\t\t\t\t\t\t     size_t desc_params_size)\n{\n\t__u8 *rdesc_frame = NULL;\n\tint rc = 0;\n\n\tif (!p || desc_params_size != UCLOGIC_RDESC_PH_ID_NUM)\n\t\treturn -EINVAL;\n\n\trdesc_frame = uclogic_rdesc_template_apply(\n\t\t\t\tuclogic_rdesc_ugee_v2_frame_btn_template_arr,\n\t\t\t\tuclogic_rdesc_ugee_v2_frame_btn_template_size,\n\t\t\t\tdesc_params, UCLOGIC_RDESC_PH_ID_NUM);\n\tif (!rdesc_frame)\n\t\treturn -ENOMEM;\n\n\trc = uclogic_params_frame_init_with_desc(&p->frame_list[0],\n\t\t\t\t\t\t rdesc_frame,\n\t\t\t\t\t\t uclogic_rdesc_ugee_v2_frame_btn_template_size,\n\t\t\t\t\t\t UCLOGIC_RDESC_V1_FRAME_ID);\n\tkfree(rdesc_frame);\n\treturn rc;\n}\n\n \nstatic int uclogic_params_ugee_v2_init_frame_dial(struct uclogic_params *p,\n\t\t\t\t\t\t  const s32 *desc_params,\n\t\t\t\t\t\t  size_t desc_params_size)\n{\n\t__u8 *rdesc_frame = NULL;\n\tint rc = 0;\n\n\tif (!p || desc_params_size != UCLOGIC_RDESC_PH_ID_NUM)\n\t\treturn -EINVAL;\n\n\trdesc_frame = uclogic_rdesc_template_apply(\n\t\t\t\tuclogic_rdesc_ugee_v2_frame_dial_template_arr,\n\t\t\t\tuclogic_rdesc_ugee_v2_frame_dial_template_size,\n\t\t\t\tdesc_params, UCLOGIC_RDESC_PH_ID_NUM);\n\tif (!rdesc_frame)\n\t\treturn -ENOMEM;\n\n\trc = uclogic_params_frame_init_with_desc(&p->frame_list[0],\n\t\t\t\t\t\t rdesc_frame,\n\t\t\t\t\t\t uclogic_rdesc_ugee_v2_frame_dial_template_size,\n\t\t\t\t\t\t UCLOGIC_RDESC_V1_FRAME_ID);\n\tkfree(rdesc_frame);\n\tif (rc)\n\t\treturn rc;\n\n\tp->frame_list[0].bitmap_dial_byte = 7;\n\treturn 0;\n}\n\n \nstatic int uclogic_params_ugee_v2_init_frame_mouse(struct uclogic_params *p)\n{\n\tint rc = 0;\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\trc = uclogic_params_frame_init_with_desc(&p->frame_list[1],\n\t\t\t\t\t\t uclogic_rdesc_ugee_v2_frame_mouse_template_arr,\n\t\t\t\t\t\t uclogic_rdesc_ugee_v2_frame_mouse_template_size,\n\t\t\t\t\t\t UCLOGIC_RDESC_V1_FRAME_ID);\n\treturn rc;\n}\n\n \nstatic bool uclogic_params_ugee_v2_has_battery(struct hid_device *hdev)\n{\n\tstruct uclogic_drvdata *drvdata = hid_get_drvdata(hdev);\n\n\tif (drvdata->quirks & UCLOGIC_BATTERY_QUIRK)\n\t\treturn true;\n\n\t \n\tif (hdev->vendor == USB_VENDOR_ID_UGEE &&\n\t    hdev->product == USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_L) {\n\t\tstruct usb_device *udev = hid_to_usb_dev(hdev);\n\n\t\tif (strstarts(udev->product, \"Deco LW\"))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int uclogic_params_ugee_v2_init_battery(struct hid_device *hdev,\n\t\t\t\t\t       struct uclogic_params *p)\n{\n\tint rc = 0;\n\n\tif (!hdev || !p)\n\t\treturn -EINVAL;\n\n\t \n\tsnprintf(hdev->uniq, sizeof(hdev->uniq), \"%x-%x\", hdev->vendor,\n\t\t hdev->product);\n\n\trc = uclogic_params_frame_init_with_desc(&p->frame_list[1],\n\t\t\t\t\t\t uclogic_rdesc_ugee_v2_battery_template_arr,\n\t\t\t\t\t\t uclogic_rdesc_ugee_v2_battery_template_size,\n\t\t\t\t\t\t UCLOGIC_RDESC_UGEE_V2_BATTERY_ID);\n\tif (rc)\n\t\treturn rc;\n\n\tp->frame_list[1].suffix = \"Battery\";\n\tp->pen.subreport_list[1].value = 0xf2;\n\tp->pen.subreport_list[1].id = UCLOGIC_RDESC_UGEE_V2_BATTERY_ID;\n\n\treturn rc;\n}\n\n \nstatic void uclogic_params_ugee_v2_reconnect_work(struct work_struct *work)\n{\n\tstruct uclogic_raw_event_hook *event_hook;\n\n\tevent_hook = container_of(work, struct uclogic_raw_event_hook, work);\n\tuclogic_probe_interface(event_hook->hdev, uclogic_ugee_v2_probe_arr,\n\t\t\t\tuclogic_ugee_v2_probe_size,\n\t\t\t\tuclogic_ugee_v2_probe_endpoint);\n}\n\n \nstatic int uclogic_params_ugee_v2_init_event_hooks(struct hid_device *hdev,\n\t\t\t\t\t\t   struct uclogic_params *p)\n{\n\tstruct uclogic_raw_event_hook *event_hook;\n\t__u8 reconnect_event[] = {\n\t\t \n\t\t0x02, 0xF8, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t \n\tif (!uclogic_params_ugee_v2_has_battery(hdev))\n\t\treturn 0;\n\n\tp->event_hooks = kzalloc(sizeof(*p->event_hooks), GFP_KERNEL);\n\tif (!p->event_hooks)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&p->event_hooks->list);\n\n\tevent_hook = kzalloc(sizeof(*event_hook), GFP_KERNEL);\n\tif (!event_hook)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&event_hook->work, uclogic_params_ugee_v2_reconnect_work);\n\tevent_hook->hdev = hdev;\n\tevent_hook->size = ARRAY_SIZE(reconnect_event);\n\tevent_hook->event = kmemdup(reconnect_event, event_hook->size, GFP_KERNEL);\n\tif (!event_hook->event)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&event_hook->list, &p->event_hooks->list);\n\n\treturn 0;\n}\n\n \nstatic int uclogic_params_ugee_v2_init(struct uclogic_params *params,\n\t\t\t\t       struct hid_device *hdev)\n{\n\tint rc = 0;\n\tstruct uclogic_drvdata *drvdata;\n\tstruct usb_interface *iface;\n\t__u8 bInterfaceNumber;\n\tconst int str_desc_len = 12;\n\t__u8 *str_desc = NULL;\n\t__u8 *rdesc_pen = NULL;\n\ts32 desc_params[UCLOGIC_RDESC_PH_ID_NUM];\n\tenum uclogic_params_frame_type frame_type;\n\t \n\tstruct uclogic_params p = {0, };\n\n\tif (!params || !hdev) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tdrvdata = hid_get_drvdata(hdev);\n\tiface = to_usb_interface(hdev->dev.parent);\n\tbInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\n\tif (bInterfaceNumber == 0) {\n\t\trc = uclogic_params_ugee_v2_init_frame_mouse(&p);\n\t\tif (rc)\n\t\t\tgoto cleanup;\n\n\t\tgoto output;\n\t}\n\n\tif (bInterfaceNumber != 2) {\n\t\tuclogic_params_init_invalid(&p);\n\t\tgoto output;\n\t}\n\n\t \n\trc = uclogic_probe_interface(hdev, uclogic_ugee_v2_probe_arr,\n\t\t\t\t     uclogic_ugee_v2_probe_size,\n\t\t\t\t     uclogic_ugee_v2_probe_endpoint);\n\tif (rc) {\n\t\tuclogic_params_init_invalid(&p);\n\t\tgoto output;\n\t}\n\n\t \n\trc = uclogic_params_get_str_desc(&str_desc, hdev, 100, str_desc_len);\n\tif (rc != str_desc_len) {\n\t\thid_err(hdev, \"failed retrieving pen and frame parameters: %d\\n\", rc);\n\t\tuclogic_params_init_invalid(&p);\n\t\tgoto output;\n\t}\n\n\trc = uclogic_params_parse_ugee_v2_desc(str_desc, str_desc_len,\n\t\t\t\t\t       desc_params,\n\t\t\t\t\t       ARRAY_SIZE(desc_params),\n\t\t\t\t\t       &frame_type);\n\tif (rc)\n\t\tgoto cleanup;\n\n\tkfree(str_desc);\n\tstr_desc = NULL;\n\n\t \n\trdesc_pen = uclogic_rdesc_template_apply(\n\t\t\t\tuclogic_rdesc_ugee_v2_pen_template_arr,\n\t\t\t\tuclogic_rdesc_ugee_v2_pen_template_size,\n\t\t\t\tdesc_params, ARRAY_SIZE(desc_params));\n\tif (!rdesc_pen) {\n\t\trc = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tp.pen.desc_ptr = rdesc_pen;\n\tp.pen.desc_size = uclogic_rdesc_ugee_v2_pen_template_size;\n\tp.pen.id = 0x02;\n\tp.pen.subreport_list[0].value = 0xf0;\n\tp.pen.subreport_list[0].id = UCLOGIC_RDESC_V1_FRAME_ID;\n\n\t \n\tif (drvdata->quirks & UCLOGIC_MOUSE_FRAME_QUIRK)\n\t\tframe_type = UCLOGIC_PARAMS_FRAME_MOUSE;\n\n\tswitch (frame_type) {\n\tcase UCLOGIC_PARAMS_FRAME_DIAL:\n\tcase UCLOGIC_PARAMS_FRAME_MOUSE:\n\t\trc = uclogic_params_ugee_v2_init_frame_dial(&p, desc_params,\n\t\t\t\t\t\t\t    ARRAY_SIZE(desc_params));\n\t\tbreak;\n\tcase UCLOGIC_PARAMS_FRAME_BUTTONS:\n\tdefault:\n\t\trc = uclogic_params_ugee_v2_init_frame_buttons(&p, desc_params,\n\t\t\t\t\t\t\t       ARRAY_SIZE(desc_params));\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tgoto cleanup;\n\n\t \n\tif (uclogic_params_ugee_v2_has_battery(hdev)) {\n\t\trc = uclogic_params_ugee_v2_init_battery(hdev, &p);\n\t\tif (rc) {\n\t\t\thid_err(hdev, \"error initializing battery: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\trc = uclogic_params_ugee_v2_init_event_hooks(hdev, &p);\n\tif (rc) {\n\t\thid_err(hdev, \"error initializing event hook list: %d\\n\", rc);\n\t\tgoto cleanup;\n\t}\n\noutput:\n\t \n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tkfree(str_desc);\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}\n\n \nint uclogic_params_init(struct uclogic_params *params,\n\t\t\tstruct hid_device *hdev)\n{\n\tint rc;\n\tstruct usb_device *udev;\n\t__u8  bNumInterfaces;\n\tstruct usb_interface *iface;\n\t__u8 bInterfaceNumber;\n\tbool found;\n\t \n\tstruct uclogic_params p = {0, };\n\n\t \n\tif (params == NULL || hdev == NULL || !hid_is_usb(hdev)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tudev = hid_to_usb_dev(hdev);\n\tbNumInterfaces = udev->config->desc.bNumInterfaces;\n\tiface = to_usb_interface(hdev->dev.parent);\n\tbInterfaceNumber = iface->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n#define WITH_OPT_DESC(_orig_desc_token, _new_desc_token) \\\n\tuclogic_params_init_with_opt_desc(                  \\\n\t\t&p, hdev,                                   \\\n\t\tUCLOGIC_RDESC_##_orig_desc_token##_SIZE,    \\\n\t\tuclogic_rdesc_##_new_desc_token##_arr,      \\\n\t\tuclogic_rdesc_##_new_desc_token##_size)\n\n#define VID_PID(_vid, _pid) \\\n\t(((__u32)(_vid) << 16) | ((__u32)(_pid) & U16_MAX))\n\n\t \n\n\tswitch (VID_PID(hdev->vendor, hdev->product)) {\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_PF1209):\n\t\trc = WITH_OPT_DESC(PF1209_ORIG, pf1209_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp4030u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U):\n\t\tif (hdev->dev_rsize == UCLOGIC_RDESC_WP5540U_V2_ORIG_SIZE) {\n\t\t\tif (bInterfaceNumber == 0) {\n\t\t\t\t \n\t\t\t\trc = uclogic_params_pen_init_v1(&p.pen,\n\t\t\t\t\t\t\t\t&found, hdev);\n\t\t\t\tif (rc != 0) {\n\t\t\t\t\thid_err(hdev,\n\t\t\t\t\t\t\"pen probing failed: %d\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\thid_warn(hdev,\n\t\t\t\t\t\t \"pen parameters not found\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp5540u_fixed);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U):\n\t\trc = WITH_OPT_DESC(WPXXXXU_ORIG, wp8060u_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_WP1062):\n\t\trc = WITH_OPT_DESC(WP1062_ORIG, wp1062_fixed);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850):\n\t\tswitch (bInterfaceNumber) {\n\t\tcase 0:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG0, twhl850_fixed0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG1, twhl850_fixed1);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trc = WITH_OPT_DESC(TWHL850_ORIG2, twhl850_fixed2);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60):\n\t\t \n\t\tif (bNumInterfaces != 3) {\n\t\t\tswitch (bInterfaceNumber) {\n\t\t\tcase 0:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG0,\n\t\t\t\t\t\t\ttwha60_fixed0);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = WITH_OPT_DESC(TWHA60_ORIG1,\n\t\t\t\t\t\t\ttwha60_fixed1);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_HUION,\n\t\t     USB_DEVICE_ID_HUION_TABLET2):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_HUION_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_YIYNOVA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45):\n\tcase VID_PID(USB_VENDOR_ID_UCLOGIC,\n\t\t     USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47):\n\t\trc = uclogic_params_huion_init(&p, hdev);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GP0610):\n\tcase VID_PID(USB_VENDOR_ID_UGTIZER,\n\t\t     USB_DEVICE_ID_UGTIZER_TABLET_GT5040):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_STAR06):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720):\n\t\t \n\t\tif (bInterfaceNumber == 1) {\n\t\t\t \n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\t\tuclogic_params_init_invalid(&p);\n\t\t\t}\n\t\t} else {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01):\n\t\t \n\t\tif (bInterfaceNumber == 1) {\n\t\t\t \n\t\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t \n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame_list[0],\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_arr,\n\t\t\t\tuclogic_rdesc_xppen_deco01_frame_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_PARBLO_A610_PRO):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01_V2):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_L):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_MW):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_S):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_SW):\n\t\trc = uclogic_params_ugee_v2_init(&p, hdev);\n\t\tif (rc != 0)\n\t\t\tgoto cleanup;\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_TRUST,\n\t\t     USB_DEVICE_ID_TRUST_PANORA_TABLET):\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_G5):\n\t\t \n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame_list[0],\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_arr,\n\t\t\t\tuclogic_rdesc_ugee_g5_frame_size,\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_ID);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating frame parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tp.frame_list[0].re_lsb =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_RE_LSB;\n\t\t\tp.frame_list[0].dev_id_byte =\n\t\t\t\tUCLOGIC_RDESC_UGEE_G5_FRAME_DEV_ID_BYTE;\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\tcase VID_PID(USB_VENDOR_ID_UGEE,\n\t\t     USB_DEVICE_ID_UGEE_TABLET_EX07S):\n\t\t \n\t\tif (bInterfaceNumber != 1) {\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = uclogic_params_pen_init_v1(&p.pen, &found, hdev);\n\t\tif (rc != 0) {\n\t\t\thid_err(hdev, \"pen probing failed: %d\\n\", rc);\n\t\t\tgoto cleanup;\n\t\t} else if (found) {\n\t\t\trc = uclogic_params_frame_init_with_desc(\n\t\t\t\t&p.frame_list[0],\n\t\t\t\tuclogic_rdesc_ugee_ex07_frame_arr,\n\t\t\t\tuclogic_rdesc_ugee_ex07_frame_size,\n\t\t\t\t0);\n\t\t\tif (rc != 0) {\n\t\t\t\thid_err(hdev,\n\t\t\t\t\t\"failed creating frame parameters: %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t} else {\n\t\t\thid_warn(hdev, \"pen parameters not found\");\n\t\t\tuclogic_params_init_invalid(&p);\n\t\t}\n\n\t\tbreak;\n\t}\n\n#undef VID_PID\n#undef WITH_OPT_DESC\n\n\t \n\tmemcpy(params, &p, sizeof(*params));\n\tmemset(&p, 0, sizeof(p));\n\trc = 0;\ncleanup:\n\tuclogic_params_cleanup(&p);\n\treturn rc;\n}\n\n#ifdef CONFIG_HID_KUNIT_TEST\n#include \"hid-uclogic-params-test.c\"\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}