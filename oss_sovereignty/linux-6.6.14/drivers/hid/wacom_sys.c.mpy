{
  "module_name": "wacom_sys.c",
  "hash_id": "9309c48eab412a7a4cd321a82072d09f9b322d378d4174a2bef5482382d8a53f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/wacom_sys.c",
  "human_readable_source": "\n \n\n#include \"wacom_wac.h\"\n#include \"wacom.h\"\n#include <linux/input/mt.h>\n\n#define WAC_MSG_RETRIES\t\t5\n#define WAC_CMD_RETRIES\t\t10\n\n#define DEV_ATTR_RW_PERM (S_IRUGO | S_IWUSR | S_IWGRP)\n#define DEV_ATTR_WO_PERM (S_IWUSR | S_IWGRP)\n#define DEV_ATTR_RO_PERM (S_IRUSR | S_IRGRP)\n\nstatic int wacom_get_report(struct hid_device *hdev, u8 type, u8 *buf,\n\t\t\t    size_t size, unsigned int retries)\n{\n\tint retval;\n\n\tdo {\n\t\tretval = hid_hw_raw_request(hdev, buf[0], buf, size, type,\n\t\t\t\tHID_REQ_GET_REPORT);\n\t} while ((retval == -ETIMEDOUT || retval == -EAGAIN) && --retries);\n\n\tif (retval < 0)\n\t\thid_err(hdev, \"wacom_get_report: ran out of retries \"\n\t\t\t\"(last error = %d)\\n\", retval);\n\n\treturn retval;\n}\n\nstatic int wacom_set_report(struct hid_device *hdev, u8 type, u8 *buf,\n\t\t\t    size_t size, unsigned int retries)\n{\n\tint retval;\n\n\tdo {\n\t\tretval = hid_hw_raw_request(hdev, buf[0], buf, size, type,\n\t\t\t\tHID_REQ_SET_REPORT);\n\t} while ((retval == -ETIMEDOUT || retval == -EAGAIN) && --retries);\n\n\tif (retval < 0)\n\t\thid_err(hdev, \"wacom_set_report: ran out of retries \"\n\t\t\t\"(last error = %d)\\n\", retval);\n\n\treturn retval;\n}\n\nstatic void wacom_wac_queue_insert(struct hid_device *hdev,\n\t\t\t\t   struct kfifo_rec_ptr_2 *fifo,\n\t\t\t\t   u8 *raw_data, int size)\n{\n\tbool warned = false;\n\n\twhile (kfifo_avail(fifo) < size) {\n\t\tif (!warned)\n\t\t\thid_warn(hdev, \"%s: kfifo has filled, starting to drop events\\n\", __func__);\n\t\twarned = true;\n\n\t\tkfifo_skip(fifo);\n\t}\n\n\tkfifo_in(fifo, raw_data, size);\n}\n\nstatic void wacom_wac_queue_flush(struct hid_device *hdev,\n\t\t\t\t  struct kfifo_rec_ptr_2 *fifo)\n{\n\twhile (!kfifo_is_empty(fifo)) {\n\t\tu8 buf[WACOM_PKGLEN_MAX];\n\t\tint size;\n\t\tint err;\n\n\t\tsize = kfifo_out(fifo, buf, sizeof(buf));\n\t\terr = hid_report_raw_event(hdev, HID_INPUT_REPORT, buf, size, false);\n\t\tif (err) {\n\t\t\thid_warn(hdev, \"%s: unable to flush event due to error %d\\n\",\n\t\t\t\t __func__, err);\n\t\t}\n\t}\n}\n\nstatic int wacom_wac_pen_serial_enforce(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int report_size)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tbool flush = false;\n\tbool insert = false;\n\tint i, j;\n\n\tif (wacom_wac->serial[0] || !(features->quirks & WACOM_QUIRK_TOOLSERIAL))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < report->maxfield; i++) {\n\t\tfor (j = 0; j < report->field[i]->maxusage; j++) {\n\t\t\tstruct hid_field *field = report->field[i];\n\t\t\tstruct hid_usage *usage = &field->usage[j];\n\t\t\tunsigned int equivalent_usage = wacom_equivalent_usage(usage->hid);\n\t\t\tunsigned int offset;\n\t\t\tunsigned int size;\n\t\t\tunsigned int value;\n\n\t\t\tif (equivalent_usage != HID_DG_INRANGE &&\n\t\t\t    equivalent_usage != HID_DG_TOOLSERIALNUMBER &&\n\t\t\t    equivalent_usage != WACOM_HID_WD_SERIALHI &&\n\t\t\t    equivalent_usage != WACOM_HID_WD_TOOLTYPE)\n\t\t\t\tcontinue;\n\n\t\t\toffset = field->report_offset;\n\t\t\tsize = field->report_size;\n\t\t\tvalue = hid_field_extract(hdev, raw_data+1, offset + j * size, size);\n\n\t\t\t \n\t\t\tif (equivalent_usage == HID_DG_INRANGE)\n\t\t\t\tvalue = !value;\n\n\t\t\tif (value) {\n\t\t\t\tflush = true;\n\t\t\t\tswitch (equivalent_usage) {\n\t\t\t\tcase HID_DG_TOOLSERIALNUMBER:\n\t\t\t\t\twacom_wac->serial[0] = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WACOM_HID_WD_SERIALHI:\n\t\t\t\t\twacom_wac->serial[0] |= ((__u64)value) << 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WACOM_HID_WD_TOOLTYPE:\n\t\t\t\t\twacom_wac->id[0] = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinsert = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flush)\n\t\twacom_wac_queue_flush(hdev, wacom_wac->pen_fifo);\n\telse if (insert)\n\t\twacom_wac_queue_insert(hdev, wacom_wac->pen_fifo,\n\t\t\t\t       raw_data, report_size);\n\n\treturn insert && !flush;\n}\n\nstatic int wacom_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\tu8 *raw_data, int size)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\n\tif (wacom->wacom_wac.features.type == BOOTLOADER)\n\t\treturn 0;\n\n\tif (size > WACOM_PKGLEN_MAX)\n\t\treturn 1;\n\n\tif (wacom_wac_pen_serial_enforce(hdev, report, raw_data, size))\n\t\treturn -1;\n\n\tmemcpy(wacom->wacom_wac.data, raw_data, size);\n\n\twacom_wac_irq(&wacom->wacom_wac, size);\n\n\treturn 0;\n}\n\nstatic int wacom_open(struct input_dev *dev)\n{\n\tstruct wacom *wacom = input_get_drvdata(dev);\n\n\treturn hid_hw_open(wacom->hdev);\n}\n\nstatic void wacom_close(struct input_dev *dev)\n{\n\tstruct wacom *wacom = input_get_drvdata(dev);\n\n\t \n\tif (wacom->hdev)\n\t\thid_hw_close(wacom->hdev);\n}\n\n \nstatic int wacom_calc_hid_res(int logical_extents, int physical_extents,\n\t\t\t       unsigned unit, int exponent)\n{\n\tstruct hid_field field = {\n\t\t.logical_maximum = logical_extents,\n\t\t.physical_maximum = physical_extents,\n\t\t.unit = unit,\n\t\t.unit_exponent = exponent,\n\t};\n\n\treturn hidinput_calc_abs_res(&field, ABS_X);\n}\n\nstatic void wacom_hid_usage_quirk(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_features *features = &wacom->wacom_wac.features;\n\tunsigned int equivalent_usage = wacom_equivalent_usage(usage->hid);\n\n\t \n\tif (hdev->vendor == USB_VENDOR_ID_WACOM &&\n\t    hdev->product == 0x4200 &&\n\t    field->application == HID_UP_MSVENDOR) {\n\t\twacom->wacom_wac.mode_report = field->report->id;\n\t\twacom->wacom_wac.mode_value = 2;\n\t}\n\n\t \n\tif (features->type == HID_GENERIC &&\n\t    usage->hid == 0x000D0000 &&\n\t    field->application == HID_DG_PEN &&\n\t    field->physical == HID_DG_STYLUS) {\n\t\tint i = usage->usage_index;\n\n\t\tif (i-4 >= 0 && i+1 < field->maxusage &&\n\t\t    field->usage[i-4].hid == HID_DG_TIPSWITCH &&\n\t\t    field->usage[i-3].hid == HID_DG_BARRELSWITCH &&\n\t\t    field->usage[i-2].hid == HID_DG_ERASER &&\n\t\t    field->usage[i-1].hid == HID_DG_INVERT &&\n\t\t    field->usage[i+1].hid == HID_DG_INRANGE) {\n\t\t\tusage->hid = HID_DG_BARRELSWITCH2;\n\t\t}\n\t}\n\n\t \n\tif (usage->hid == WACOM_HID_WT_SERIALNUMBER &&\n\t    field->report_size == 16 &&\n\t    field->index + 2 < field->report->maxfield) {\n\t\tstruct hid_field *a = field->report->field[field->index + 1];\n\t\tstruct hid_field *b = field->report->field[field->index + 2];\n\n\t\tif (a->maxusage > 0 &&\n\t\t    a->usage[0].hid == HID_DG_TOOLSERIALNUMBER &&\n\t\t    a->report_size == 32 &&\n\t\t    b->maxusage > 0 &&\n\t\t    b->usage[0].hid == 0xFF000000 &&\n\t\t    b->report_size == 8) {\n\t\t\tfeatures->quirks |= WACOM_QUIRK_AESPEN;\n\t\t\tusage->hid = WACOM_HID_WD_TOOLTYPE;\n\t\t\tfield->logical_minimum = S16_MIN;\n\t\t\tfield->logical_maximum = S16_MAX;\n\t\t\ta->logical_minimum = S32_MIN;\n\t\t\ta->logical_maximum = S32_MAX;\n\t\t\tb->usage[0].hid = WACOM_HID_WD_SERIALHI;\n\t\t\tb->logical_minimum = 0;\n\t\t\tb->logical_maximum = U8_MAX;\n\t\t}\n\t}\n\n\t \n\tif (hdev->vendor == USB_VENDOR_ID_WACOM &&\n\t    hdev->product == 0x0358 &&\n\t    WACOM_PEN_FIELD(field) &&\n\t    equivalent_usage == HID_GD_Y) {\n\t\tfield->logical_maximum = 43200;\n\t}\n}\n\nstatic void wacom_feature_mapping(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_features *features = &wacom->wacom_wac.features;\n\tstruct hid_data *hid_data = &wacom->wacom_wac.hid_data;\n\tunsigned int equivalent_usage = wacom_equivalent_usage(usage->hid);\n\tu8 *data;\n\tint ret;\n\tu32 n;\n\n\twacom_hid_usage_quirk(hdev, field, usage);\n\n\tswitch (equivalent_usage) {\n\tcase WACOM_HID_WD_TOUCH_RING_SETTING:\n\t\twacom->generic_has_leds = true;\n\t\tbreak;\n\tcase HID_DG_CONTACTMAX:\n\t\t \n\t\tif (!features->touch_max) {\n\t\t\t \n\t\t\tn = hid_report_len(field->report);\n\t\t\tdata = hid_alloc_report_buf(field->report, GFP_KERNEL);\n\t\t\tif (!data)\n\t\t\t\tbreak;\n\t\t\tdata[0] = field->report->id;\n\t\t\tret = wacom_get_report(hdev, HID_FEATURE_REPORT,\n\t\t\t\t\t       data, n, WAC_CMD_RETRIES);\n\t\t\tif (ret == n && features->type == HID_GENERIC) {\n\t\t\t\tret = hid_report_raw_event(hdev,\n\t\t\t\t\tHID_FEATURE_REPORT, data, n, 0);\n\t\t\t} else if (ret == 2 && features->type != HID_GENERIC) {\n\t\t\t\tfeatures->touch_max = data[1];\n\t\t\t} else {\n\t\t\t\tfeatures->touch_max = 16;\n\t\t\t\thid_warn(hdev, \"wacom_feature_mapping: \"\n\t\t\t\t\t \"could not get HID_DG_CONTACTMAX, \"\n\t\t\t\t\t \"defaulting to %d\\n\",\n\t\t\t\t\t  features->touch_max);\n\t\t\t}\n\t\t\tkfree(data);\n\t\t}\n\t\tbreak;\n\tcase HID_DG_INPUTMODE:\n\t\t \n\t\tif (usage->usage_index >= field->report_count) {\n\t\t\tdev_err(&hdev->dev, \"HID_DG_INPUTMODE out of range\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\thid_data->inputmode = field->report->id;\n\t\thid_data->inputmode_index = usage->usage_index;\n\t\tbreak;\n\n\tcase HID_UP_DIGITIZER:\n\t\tif (field->report->id == 0x0B &&\n\t\t    (field->application == WACOM_HID_G9_PEN ||\n\t\t     field->application == WACOM_HID_G11_PEN)) {\n\t\t\twacom->wacom_wac.mode_report = field->report->id;\n\t\t\twacom->wacom_wac.mode_value = 0;\n\t\t}\n\t\tbreak;\n\n\tcase WACOM_HID_WD_DATAMODE:\n\t\twacom->wacom_wac.mode_report = field->report->id;\n\t\twacom->wacom_wac.mode_value = 2;\n\t\tbreak;\n\n\tcase WACOM_HID_UP_G9:\n\tcase WACOM_HID_UP_G11:\n\t\tif (field->report->id == 0x03 &&\n\t\t    (field->application == WACOM_HID_G9_TOUCHSCREEN ||\n\t\t     field->application == WACOM_HID_G11_TOUCHSCREEN)) {\n\t\t\twacom->wacom_wac.mode_report = field->report->id;\n\t\t\twacom->wacom_wac.mode_value = 0;\n\t\t}\n\t\tbreak;\n\tcase WACOM_HID_WD_OFFSETLEFT:\n\tcase WACOM_HID_WD_OFFSETTOP:\n\tcase WACOM_HID_WD_OFFSETRIGHT:\n\tcase WACOM_HID_WD_OFFSETBOTTOM:\n\t\t \n\t\tn = hid_report_len(field->report);\n\t\tdata = hid_alloc_report_buf(field->report, GFP_KERNEL);\n\t\tif (!data)\n\t\t\tbreak;\n\t\tdata[0] = field->report->id;\n\t\tret = wacom_get_report(hdev, HID_FEATURE_REPORT,\n\t\t\t\t\tdata, n, WAC_CMD_RETRIES);\n\t\tif (ret == n) {\n\t\t\tret = hid_report_raw_event(hdev, HID_FEATURE_REPORT,\n\t\t\t\t\t\t   data, n, 0);\n\t\t} else {\n\t\t\thid_warn(hdev, \"%s: could not retrieve sensor offsets\\n\",\n\t\t\t\t __func__);\n\t\t}\n\t\tkfree(data);\n\t\tbreak;\n\t}\n}\n\n \nstatic void wacom_usage_mapping(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_features *features = &wacom->wacom_wac.features;\n\tbool finger = WACOM_FINGER_FIELD(field);\n\tbool pen = WACOM_PEN_FIELD(field);\n\tunsigned equivalent_usage = wacom_equivalent_usage(usage->hid);\n\n\t \n\tif (pen)\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PEN;\n\telse if (finger)\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_TOUCH;\n\telse\n\t\treturn;\n\n\twacom_hid_usage_quirk(hdev, field, usage);\n\n\tswitch (equivalent_usage) {\n\tcase HID_GD_X:\n\t\tfeatures->x_max = field->logical_maximum;\n\t\tif (finger) {\n\t\t\tfeatures->x_phy = field->physical_maximum;\n\t\t\tif ((features->type != BAMBOO_PT) &&\n\t\t\t    (features->type != BAMBOO_TOUCH)) {\n\t\t\t\tfeatures->unit = field->unit;\n\t\t\t\tfeatures->unitExpo = field->unit_exponent;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase HID_GD_Y:\n\t\tfeatures->y_max = field->logical_maximum;\n\t\tif (finger) {\n\t\t\tfeatures->y_phy = field->physical_maximum;\n\t\t\tif ((features->type != BAMBOO_PT) &&\n\t\t\t    (features->type != BAMBOO_TOUCH)) {\n\t\t\t\tfeatures->unit = field->unit;\n\t\t\t\tfeatures->unitExpo = field->unit_exponent;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase HID_DG_TIPPRESSURE:\n\t\tif (pen)\n\t\t\tfeatures->pressure_max = field->logical_maximum;\n\t\tbreak;\n\t}\n\n\tif (features->type == HID_GENERIC)\n\t\twacom_wac_usage_mapping(hdev, field, usage);\n}\n\nstatic void wacom_post_parse_hid(struct hid_device *hdev,\n\t\t\t\t struct wacom_features *features)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\n\tif (features->type == HID_GENERIC) {\n\t\t \n\t\tif (wacom_wac->has_mode_change) {\n\t\t\tif (wacom_wac->is_direct_mode)\n\t\t\t\tfeatures->device_type |= WACOM_DEVICETYPE_DIRECT;\n\t\t\telse\n\t\t\t\tfeatures->device_type &= ~WACOM_DEVICETYPE_DIRECT;\n\t\t}\n\n\t\tif (features->touch_max > 1) {\n\t\t\tif (features->device_type & WACOM_DEVICETYPE_DIRECT)\n\t\t\t\tinput_mt_init_slots(wacom_wac->touch_input,\n\t\t\t\t\t\t    wacom_wac->features.touch_max,\n\t\t\t\t\t\t    INPUT_MT_DIRECT);\n\t\t\telse\n\t\t\t\tinput_mt_init_slots(wacom_wac->touch_input,\n\t\t\t\t\t\t    wacom_wac->features.touch_max,\n\t\t\t\t\t\t    INPUT_MT_POINTER);\n\t\t}\n\t}\n}\n\nstatic void wacom_parse_hid(struct hid_device *hdev,\n\t\t\t   struct wacom_features *features)\n{\n\tstruct hid_report_enum *rep_enum;\n\tstruct hid_report *hreport;\n\tint i, j;\n\n\t \n\trep_enum = &hdev->report_enum[HID_FEATURE_REPORT];\n\tlist_for_each_entry(hreport, &rep_enum->report_list, list) {\n\t\tfor (i = 0; i < hreport->maxfield; i++) {\n\t\t\t \n\t\t\tif (hreport->field[i]->report_count < 1)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < hreport->field[i]->maxusage; j++) {\n\t\t\t\twacom_feature_mapping(hdev, hreport->field[i],\n\t\t\t\t\t\threport->field[i]->usage + j);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trep_enum = &hdev->report_enum[HID_INPUT_REPORT];\n\tlist_for_each_entry(hreport, &rep_enum->report_list, list) {\n\n\t\tif (!hreport->maxfield)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < hreport->maxfield; i++)\n\t\t\tfor (j = 0; j < hreport->field[i]->maxusage; j++)\n\t\t\t\twacom_usage_mapping(hdev, hreport->field[i],\n\t\t\t\t\t\threport->field[i]->usage + j);\n\t}\n\n\twacom_post_parse_hid(hdev, features);\n}\n\nstatic int wacom_hid_set_device_mode(struct hid_device *hdev)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct hid_data *hid_data = &wacom->wacom_wac.hid_data;\n\tstruct hid_report *r;\n\tstruct hid_report_enum *re;\n\n\tif (hid_data->inputmode < 0)\n\t\treturn 0;\n\n\tre = &(hdev->report_enum[HID_FEATURE_REPORT]);\n\tr = re->report_id_hash[hid_data->inputmode];\n\tif (r) {\n\t\tr->field[0]->value[hid_data->inputmode_index] = 2;\n\t\thid_hw_request(hdev, r, HID_REQ_SET_REPORT);\n\t}\n\treturn 0;\n}\n\nstatic int wacom_set_device_mode(struct hid_device *hdev,\n\t\t\t\t struct wacom_wac *wacom_wac)\n{\n\tu8 *rep_data;\n\tstruct hid_report *r;\n\tstruct hid_report_enum *re;\n\tu32 length;\n\tint error = -ENOMEM, limit = 0;\n\n\tif (wacom_wac->mode_report < 0)\n\t\treturn 0;\n\n\tre = &(hdev->report_enum[HID_FEATURE_REPORT]);\n\tr = re->report_id_hash[wacom_wac->mode_report];\n\tif (!r)\n\t\treturn -EINVAL;\n\n\trep_data = hid_alloc_report_buf(r, GFP_KERNEL);\n\tif (!rep_data)\n\t\treturn -ENOMEM;\n\n\tlength = hid_report_len(r);\n\n\tdo {\n\t\trep_data[0] = wacom_wac->mode_report;\n\t\trep_data[1] = wacom_wac->mode_value;\n\n\t\terror = wacom_set_report(hdev, HID_FEATURE_REPORT, rep_data,\n\t\t\t\t\t length, 1);\n\t\tif (error >= 0)\n\t\t\terror = wacom_get_report(hdev, HID_FEATURE_REPORT,\n\t\t\t                         rep_data, length, 1);\n\t} while (error >= 0 &&\n\t\t rep_data[1] != wacom_wac->mode_report &&\n\t\t limit++ < WAC_MSG_RETRIES);\n\n\tkfree(rep_data);\n\n\treturn error < 0 ? error : 0;\n}\n\nstatic int wacom_bt_query_tablet_data(struct hid_device *hdev, u8 speed,\n\t\tstruct wacom_features *features)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tint ret;\n\tu8 rep_data[2];\n\n\tswitch (features->type) {\n\tcase GRAPHIRE_BT:\n\t\trep_data[0] = 0x03;\n\t\trep_data[1] = 0x00;\n\t\tret = wacom_set_report(hdev, HID_FEATURE_REPORT, rep_data, 2,\n\t\t\t\t\t3);\n\n\t\tif (ret >= 0) {\n\t\t\trep_data[0] = speed == 0 ? 0x05 : 0x06;\n\t\t\trep_data[1] = 0x00;\n\n\t\t\tret = wacom_set_report(hdev, HID_FEATURE_REPORT,\n\t\t\t\t\t\trep_data, 2, 3);\n\n\t\t\tif (ret >= 0) {\n\t\t\t\twacom->wacom_wac.bt_high_speed = speed;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\thid_warn(hdev, \"failed to poke device, command %d, err %d\\n\",\n\t\t\t rep_data[0], ret);\n\t\tbreak;\n\tcase INTUOS4WL:\n\t\tif (speed == 1)\n\t\t\twacom->wacom_wac.bt_features &= ~0x20;\n\t\telse\n\t\t\twacom->wacom_wac.bt_features |= 0x20;\n\n\t\trep_data[0] = 0x03;\n\t\trep_data[1] = wacom->wacom_wac.bt_features;\n\n\t\tret = wacom_set_report(hdev, HID_FEATURE_REPORT, rep_data, 2,\n\t\t\t\t\t1);\n\t\tif (ret >= 0)\n\t\t\twacom->wacom_wac.bt_high_speed = speed;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int _wacom_query_tablet_data(struct wacom *wacom)\n{\n\tstruct hid_device *hdev = wacom->hdev;\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\n\tif (hdev->bus == BUS_BLUETOOTH)\n\t\treturn wacom_bt_query_tablet_data(hdev, 1, features);\n\n\tif (features->type != HID_GENERIC) {\n\t\tif (features->device_type & WACOM_DEVICETYPE_TOUCH) {\n\t\t\tif (features->type > TABLETPC) {\n\t\t\t\t \n\t\t\t\twacom_wac->mode_report = 3;\n\t\t\t\twacom_wac->mode_value = 4;\n\t\t\t} else if (features->type == WACOM_24HDT) {\n\t\t\t\twacom_wac->mode_report = 18;\n\t\t\t\twacom_wac->mode_value = 2;\n\t\t\t} else if (features->type == WACOM_27QHDT) {\n\t\t\t\twacom_wac->mode_report = 131;\n\t\t\t\twacom_wac->mode_value = 2;\n\t\t\t} else if (features->type == BAMBOO_PAD) {\n\t\t\t\twacom_wac->mode_report = 2;\n\t\t\t\twacom_wac->mode_value = 2;\n\t\t\t}\n\t\t} else if (features->device_type & WACOM_DEVICETYPE_PEN) {\n\t\t\tif (features->type <= BAMBOO_PT) {\n\t\t\t\twacom_wac->mode_report = 2;\n\t\t\t\twacom_wac->mode_value = 2;\n\t\t\t}\n\t\t}\n\t}\n\n\twacom_set_device_mode(hdev, wacom_wac);\n\n\tif (features->type == HID_GENERIC)\n\t\treturn wacom_hid_set_device_mode(hdev);\n\n\treturn 0;\n}\n\nstatic void wacom_retrieve_hid_descriptor(struct hid_device *hdev,\n\t\t\t\t\t struct wacom_features *features)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct usb_interface *intf = wacom->intf;\n\n\t \n\tfeatures->x_fuzz = 4;\n\tfeatures->y_fuzz = 4;\n\tfeatures->pressure_fuzz = 0;\n\tfeatures->distance_fuzz = 1;\n\tfeatures->tilt_fuzz = 1;\n\n\t \n\tif (features->type == WIRELESS && intf) {\n\t\tif (intf->cur_altsetting->desc.bInterfaceNumber == 0)\n\t\t\tfeatures->device_type = WACOM_DEVICETYPE_WL_MONITOR;\n\t\telse\n\t\t\tfeatures->device_type = WACOM_DEVICETYPE_NONE;\n\t\treturn;\n\t}\n\n\twacom_parse_hid(hdev, features);\n}\n\nstruct wacom_hdev_data {\n\tstruct list_head list;\n\tstruct kref kref;\n\tstruct hid_device *dev;\n\tstruct wacom_shared shared;\n};\n\nstatic LIST_HEAD(wacom_udev_list);\nstatic DEFINE_MUTEX(wacom_udev_list_lock);\n\nstatic bool wacom_are_sibling(struct hid_device *hdev,\n\t\tstruct hid_device *sibling)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_features *features = &wacom->wacom_wac.features;\n\tstruct wacom *sibling_wacom = hid_get_drvdata(sibling);\n\tstruct wacom_features *sibling_features = &sibling_wacom->wacom_wac.features;\n\t__u32 oVid = features->oVid ? features->oVid : hdev->vendor;\n\t__u32 oPid = features->oPid ? features->oPid : hdev->product;\n\n\t \n\tif (features->oVid != HID_ANY_ID && sibling->vendor != oVid)\n\t\treturn false;\n\tif (features->oPid != HID_ANY_ID && sibling->product != oPid)\n\t\treturn false;\n\n\t \n\tif (hdev->vendor == sibling->vendor && hdev->product == sibling->product) {\n\t\tif (!hid_compare_device_paths(hdev, sibling, '/'))\n\t\t\treturn false;\n\t} else {\n\t\tif (!hid_compare_device_paths(hdev, sibling, '.'))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (features->type != HID_GENERIC)\n\t\treturn true;\n\n\t \n\tif ((features->device_type & WACOM_DEVICETYPE_DIRECT) &&\n\t    !(sibling_features->device_type & WACOM_DEVICETYPE_DIRECT))\n\t\treturn false;\n\n\t \n\tif (!(features->device_type & WACOM_DEVICETYPE_DIRECT) &&\n\t    (sibling_features->device_type & WACOM_DEVICETYPE_DIRECT))\n\t\treturn false;\n\n\t \n\tif ((features->device_type & WACOM_DEVICETYPE_PEN) &&\n\t    !(sibling_features->device_type & WACOM_DEVICETYPE_TOUCH))\n\t\treturn false;\n\n\t \n\tif ((features->device_type & WACOM_DEVICETYPE_TOUCH) &&\n\t    !(sibling_features->device_type & WACOM_DEVICETYPE_PEN))\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic struct wacom_hdev_data *wacom_get_hdev_data(struct hid_device *hdev)\n{\n\tstruct wacom_hdev_data *data;\n\n\t \n\tlist_for_each_entry(data, &wacom_udev_list, list) {\n\t\tif (hid_compare_device_paths(hdev, data->dev, '/')) {\n\t\t\tkref_get(&data->kref);\n\t\t\treturn data;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(data, &wacom_udev_list, list) {\n\t\tif (wacom_are_sibling(hdev, data->dev)) {\n\t\t\tkref_get(&data->kref);\n\t\t\treturn data;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void wacom_release_shared_data(struct kref *kref)\n{\n\tstruct wacom_hdev_data *data =\n\t\tcontainer_of(kref, struct wacom_hdev_data, kref);\n\n\tmutex_lock(&wacom_udev_list_lock);\n\tlist_del(&data->list);\n\tmutex_unlock(&wacom_udev_list_lock);\n\n\tkfree(data);\n}\n\nstatic void wacom_remove_shared_data(void *res)\n{\n\tstruct wacom *wacom = res;\n\tstruct wacom_hdev_data *data;\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\n\tif (wacom_wac->shared) {\n\t\tdata = container_of(wacom_wac->shared, struct wacom_hdev_data,\n\t\t\t\t    shared);\n\n\t\tif (wacom_wac->shared->touch == wacom->hdev)\n\t\t\twacom_wac->shared->touch = NULL;\n\t\telse if (wacom_wac->shared->pen == wacom->hdev)\n\t\t\twacom_wac->shared->pen = NULL;\n\n\t\tkref_put(&data->kref, wacom_release_shared_data);\n\t\twacom_wac->shared = NULL;\n\t}\n}\n\nstatic int wacom_add_shared_data(struct hid_device *hdev)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_hdev_data *data;\n\tint retval = 0;\n\n\tmutex_lock(&wacom_udev_list_lock);\n\n\tdata = wacom_get_hdev_data(hdev);\n\tif (!data) {\n\t\tdata = kzalloc(sizeof(struct wacom_hdev_data), GFP_KERNEL);\n\t\tif (!data) {\n\t\t\tmutex_unlock(&wacom_udev_list_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tkref_init(&data->kref);\n\t\tdata->dev = hdev;\n\t\tlist_add_tail(&data->list, &wacom_udev_list);\n\t}\n\n\tmutex_unlock(&wacom_udev_list_lock);\n\n\twacom_wac->shared = &data->shared;\n\n\tretval = devm_add_action_or_reset(&hdev->dev, wacom_remove_shared_data, wacom);\n\tif (retval)\n\t\treturn retval;\n\n\tif (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)\n\t\twacom_wac->shared->touch = hdev;\n\telse if (wacom_wac->features.device_type & WACOM_DEVICETYPE_PEN)\n\t\twacom_wac->shared->pen = hdev;\n\n\treturn retval;\n}\n\nstatic int wacom_led_control(struct wacom *wacom)\n{\n\tunsigned char *buf;\n\tint retval;\n\tunsigned char report_id = WAC_CMD_LED_CONTROL;\n\tint buf_size = 9;\n\n\tif (!wacom->led.groups)\n\t\treturn -ENOTSUPP;\n\n\tif (wacom->wacom_wac.features.type == REMOTE)\n\t\treturn -ENOTSUPP;\n\n\tif (wacom->wacom_wac.pid) {  \n\t\treport_id = WAC_CMD_WL_LED_CONTROL;\n\t\tbuf_size = 13;\n\t}\n\telse if (wacom->wacom_wac.features.type == INTUOSP2_BT) {\n\t\treport_id = WAC_CMD_WL_INTUOSP2;\n\t\tbuf_size = 51;\n\t}\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (wacom->wacom_wac.features.type == HID_GENERIC) {\n\t\tbuf[0] = WAC_CMD_LED_CONTROL_GENERIC;\n\t\tbuf[1] = wacom->led.llv;\n\t\tbuf[2] = wacom->led.groups[0].select & 0x03;\n\n\t} else if ((wacom->wacom_wac.features.type >= INTUOS5S &&\n\t    wacom->wacom_wac.features.type <= INTUOSPL)) {\n\t\t \n\t\tint ring_led = wacom->led.groups[0].select & 0x03;\n\t\tint ring_lum = (((wacom->led.llv & 0x60) >> 5) - 1) & 0x03;\n\t\tint crop_lum = 0;\n\t\tunsigned char led_bits = (crop_lum << 4) | (ring_lum << 2) | (ring_led);\n\n\t\tbuf[0] = report_id;\n\t\tif (wacom->wacom_wac.pid) {\n\t\t\twacom_get_report(wacom->hdev, HID_FEATURE_REPORT,\n\t\t\t\t\t buf, buf_size, WAC_CMD_RETRIES);\n\t\t\tbuf[0] = report_id;\n\t\t\tbuf[4] = led_bits;\n\t\t} else\n\t\t\tbuf[1] = led_bits;\n\t}\n\telse if (wacom->wacom_wac.features.type == INTUOSP2_BT) {\n\t\tbuf[0] = report_id;\n\t\tbuf[4] = 100;  \n\t\tbuf[5] = 100;  \n\t\tbuf[6] = 100;  \n\t\tbuf[7] = 100;  \n\t\tbuf[8] = 100;  \n\t\tbuf[9] = wacom->led.llv;\n\t\tbuf[10] = wacom->led.groups[0].select & 0x03;\n\t}\n\telse {\n\t\tint led = wacom->led.groups[0].select | 0x4;\n\n\t\tif (wacom->wacom_wac.features.type == WACOM_21UX2 ||\n\t\t    wacom->wacom_wac.features.type == WACOM_24HD)\n\t\t\tled |= (wacom->led.groups[1].select << 4) | 0x40;\n\n\t\tbuf[0] = report_id;\n\t\tbuf[1] = led;\n\t\tbuf[2] = wacom->led.llv;\n\t\tbuf[3] = wacom->led.hlv;\n\t\tbuf[4] = wacom->led.img_lum;\n\t}\n\n\tretval = wacom_set_report(wacom->hdev, HID_FEATURE_REPORT, buf, buf_size,\n\t\t\t\t  WAC_CMD_RETRIES);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic int wacom_led_putimage(struct wacom *wacom, int button_id, u8 xfer_id,\n\t\tconst unsigned len, const void *img)\n{\n\tunsigned char *buf;\n\tint i, retval;\n\tconst unsigned chunk_len = len / 4;  \n\n\tbuf = kzalloc(chunk_len + 3 , GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tbuf[0] = WAC_CMD_ICON_START;\n\tbuf[1] = 1;\n\tretval = wacom_set_report(wacom->hdev, HID_FEATURE_REPORT, buf, 2,\n\t\t\t\t  WAC_CMD_RETRIES);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbuf[0] = xfer_id;\n\tbuf[1] = button_id & 0x07;\n\tfor (i = 0; i < 4; i++) {\n\t\tbuf[2] = i;\n\t\tmemcpy(buf + 3, img + i * chunk_len, chunk_len);\n\n\t\tretval = wacom_set_report(wacom->hdev, HID_FEATURE_REPORT,\n\t\t\t\t\t  buf, chunk_len + 3, WAC_CMD_RETRIES);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tbuf[0] = WAC_CMD_ICON_START;\n\tbuf[1] = 0;\n\twacom_set_report(wacom->hdev, HID_FEATURE_REPORT, buf, 2,\n\t\t\t WAC_CMD_RETRIES);\n\nout:\n\tkfree(buf);\n\treturn retval;\n}\n\nstatic ssize_t wacom_led_select_store(struct device *dev, int set_id,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tunsigned int id;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &id);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&wacom->lock);\n\n\twacom->led.groups[set_id].select = id & 0x3;\n\terr = wacom_led_control(wacom);\n\n\tmutex_unlock(&wacom->lock);\n\n\treturn err < 0 ? err : count;\n}\n\n#define DEVICE_LED_SELECT_ATTR(SET_ID)\t\t\t\t\t\\\nstatic ssize_t wacom_led##SET_ID##_select_store(struct device *dev,\t\\\n\tstruct device_attribute *attr, const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn wacom_led_select_store(dev, SET_ID, buf, count);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t wacom_led##SET_ID##_select_show(struct device *dev,\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct hid_device *hdev = to_hid_device(dev);\\\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\t\t\t\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\t\t\t\\\n\t\t\t wacom->led.groups[SET_ID].select);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(status_led##SET_ID##_select, DEV_ATTR_RW_PERM,\t\\\n\t\t    wacom_led##SET_ID##_select_show,\t\t\t\\\n\t\t    wacom_led##SET_ID##_select_store)\n\nDEVICE_LED_SELECT_ATTR(0);\nDEVICE_LED_SELECT_ATTR(1);\n\nstatic ssize_t wacom_luminance_store(struct wacom *wacom, u8 *dest,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned int value;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&wacom->lock);\n\n\t*dest = value & 0x7f;\n\terr = wacom_led_control(wacom);\n\n\tmutex_unlock(&wacom->lock);\n\n\treturn err < 0 ? err : count;\n}\n\n#define DEVICE_LUMINANCE_ATTR(name, field)\t\t\t\t\\\nstatic ssize_t wacom_##name##_luminance_store(struct device *dev,\t\\\n\tstruct device_attribute *attr, const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct hid_device *hdev = to_hid_device(dev);\\\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn wacom_luminance_store(wacom, &wacom->led.field,\t\t\\\n\t\t\t\t     buf, count);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t wacom_##name##_luminance_show(struct device *dev,\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct wacom *wacom = dev_get_drvdata(dev);\t\t\t\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", wacom->led.field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name##_luminance, DEV_ATTR_RW_PERM,\t\t\t\\\n\t\t   wacom_##name##_luminance_show,\t\t\t\\\n\t\t   wacom_##name##_luminance_store)\n\nDEVICE_LUMINANCE_ATTR(status0, llv);\nDEVICE_LUMINANCE_ATTR(status1, hlv);\nDEVICE_LUMINANCE_ATTR(buttons, img_lum);\n\nstatic ssize_t wacom_button_image_store(struct device *dev, int button_id,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tint err;\n\tunsigned len;\n\tu8 xfer_id;\n\n\tif (hdev->bus == BUS_BLUETOOTH) {\n\t\tlen = 256;\n\t\txfer_id = WAC_CMD_ICON_BT_XFER;\n\t} else {\n\t\tlen = 1024;\n\t\txfer_id = WAC_CMD_ICON_XFER;\n\t}\n\n\tif (count != len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wacom->lock);\n\n\terr = wacom_led_putimage(wacom, button_id, xfer_id, len, buf);\n\n\tmutex_unlock(&wacom->lock);\n\n\treturn err < 0 ? err : count;\n}\n\n#define DEVICE_BTNIMG_ATTR(BUTTON_ID)\t\t\t\t\t\\\nstatic ssize_t wacom_btnimg##BUTTON_ID##_store(struct device *dev,\t\\\n\tstruct device_attribute *attr, const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn wacom_button_image_store(dev, BUTTON_ID, buf, count);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(button##BUTTON_ID##_rawimg, DEV_ATTR_WO_PERM,\t\\\n\t\t   NULL, wacom_btnimg##BUTTON_ID##_store)\n\nDEVICE_BTNIMG_ATTR(0);\nDEVICE_BTNIMG_ATTR(1);\nDEVICE_BTNIMG_ATTR(2);\nDEVICE_BTNIMG_ATTR(3);\nDEVICE_BTNIMG_ATTR(4);\nDEVICE_BTNIMG_ATTR(5);\nDEVICE_BTNIMG_ATTR(6);\nDEVICE_BTNIMG_ATTR(7);\n\nstatic struct attribute *cintiq_led_attrs[] = {\n\t&dev_attr_status_led0_select.attr,\n\t&dev_attr_status_led1_select.attr,\n\tNULL\n};\n\nstatic const struct attribute_group cintiq_led_attr_group = {\n\t.name = \"wacom_led\",\n\t.attrs = cintiq_led_attrs,\n};\n\nstatic struct attribute *intuos4_led_attrs[] = {\n\t&dev_attr_status0_luminance.attr,\n\t&dev_attr_status1_luminance.attr,\n\t&dev_attr_status_led0_select.attr,\n\t&dev_attr_buttons_luminance.attr,\n\t&dev_attr_button0_rawimg.attr,\n\t&dev_attr_button1_rawimg.attr,\n\t&dev_attr_button2_rawimg.attr,\n\t&dev_attr_button3_rawimg.attr,\n\t&dev_attr_button4_rawimg.attr,\n\t&dev_attr_button5_rawimg.attr,\n\t&dev_attr_button6_rawimg.attr,\n\t&dev_attr_button7_rawimg.attr,\n\tNULL\n};\n\nstatic const struct attribute_group intuos4_led_attr_group = {\n\t.name = \"wacom_led\",\n\t.attrs = intuos4_led_attrs,\n};\n\nstatic struct attribute *intuos5_led_attrs[] = {\n\t&dev_attr_status0_luminance.attr,\n\t&dev_attr_status_led0_select.attr,\n\tNULL\n};\n\nstatic const struct attribute_group intuos5_led_attr_group = {\n\t.name = \"wacom_led\",\n\t.attrs = intuos5_led_attrs,\n};\n\nstatic struct attribute *generic_led_attrs[] = {\n\t&dev_attr_status0_luminance.attr,\n\t&dev_attr_status_led0_select.attr,\n\tNULL\n};\n\nstatic const struct attribute_group generic_led_attr_group = {\n\t.name = \"wacom_led\",\n\t.attrs = generic_led_attrs,\n};\n\nstruct wacom_sysfs_group_devres {\n\tconst struct attribute_group *group;\n\tstruct kobject *root;\n};\n\nstatic void wacom_devm_sysfs_group_release(struct device *dev, void *res)\n{\n\tstruct wacom_sysfs_group_devres *devres = res;\n\tstruct kobject *kobj = devres->root;\n\n\tdev_dbg(dev, \"%s: dropping reference to %s\\n\",\n\t\t__func__, devres->group->name);\n\tsysfs_remove_group(kobj, devres->group);\n}\n\nstatic int __wacom_devm_sysfs_create_group(struct wacom *wacom,\n\t\t\t\t\t   struct kobject *root,\n\t\t\t\t\t   const struct attribute_group *group)\n{\n\tstruct wacom_sysfs_group_devres *devres;\n\tint error;\n\n\tdevres = devres_alloc(wacom_devm_sysfs_group_release,\n\t\t\t      sizeof(struct wacom_sysfs_group_devres),\n\t\t\t      GFP_KERNEL);\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\tdevres->group = group;\n\tdevres->root = root;\n\n\terror = sysfs_create_group(devres->root, group);\n\tif (error) {\n\t\tdevres_free(devres);\n\t\treturn error;\n\t}\n\n\tdevres_add(&wacom->hdev->dev, devres);\n\n\treturn 0;\n}\n\nstatic int wacom_devm_sysfs_create_group(struct wacom *wacom,\n\t\t\t\t\t const struct attribute_group *group)\n{\n\treturn __wacom_devm_sysfs_create_group(wacom, &wacom->hdev->dev.kobj,\n\t\t\t\t\t       group);\n}\n\nstatic void wacom_devm_kfifo_release(struct device *dev, void *res)\n{\n\tstruct kfifo_rec_ptr_2 *devres = res;\n\n\tkfifo_free(devres);\n}\n\nstatic int wacom_devm_kfifo_alloc(struct wacom *wacom)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct kfifo_rec_ptr_2 *pen_fifo;\n\tint error;\n\n\tpen_fifo = devres_alloc(wacom_devm_kfifo_release,\n\t\t\t      sizeof(struct kfifo_rec_ptr_2),\n\t\t\t      GFP_KERNEL);\n\n\tif (!pen_fifo)\n\t\treturn -ENOMEM;\n\n\terror = kfifo_alloc(pen_fifo, WACOM_PKGLEN_MAX, GFP_KERNEL);\n\tif (error) {\n\t\tdevres_free(pen_fifo);\n\t\treturn error;\n\t}\n\n\tdevres_add(&wacom->hdev->dev, pen_fifo);\n\twacom_wac->pen_fifo = pen_fifo;\n\n\treturn 0;\n}\n\nenum led_brightness wacom_leds_brightness_get(struct wacom_led *led)\n{\n\tstruct wacom *wacom = led->wacom;\n\n\tif (wacom->led.max_hlv)\n\t\treturn led->hlv * LED_FULL / wacom->led.max_hlv;\n\n\tif (wacom->led.max_llv)\n\t\treturn led->llv * LED_FULL / wacom->led.max_llv;\n\n\t \n\treturn LED_FULL;\n}\n\nstatic enum led_brightness __wacom_led_brightness_get(struct led_classdev *cdev)\n{\n\tstruct wacom_led *led = container_of(cdev, struct wacom_led, cdev);\n\tstruct wacom *wacom = led->wacom;\n\n\tif (wacom->led.groups[led->group].select != led->id)\n\t\treturn LED_OFF;\n\n\treturn wacom_leds_brightness_get(led);\n}\n\nstatic int wacom_led_brightness_set(struct led_classdev *cdev,\n\t\t\t\t    enum led_brightness brightness)\n{\n\tstruct wacom_led *led = container_of(cdev, struct wacom_led, cdev);\n\tstruct wacom *wacom = led->wacom;\n\tint error;\n\n\tmutex_lock(&wacom->lock);\n\n\tif (!wacom->led.groups || (brightness == LED_OFF &&\n\t    wacom->led.groups[led->group].select != led->id)) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tled->llv = wacom->led.llv = wacom->led.max_llv * brightness / LED_FULL;\n\tled->hlv = wacom->led.hlv = wacom->led.max_hlv * brightness / LED_FULL;\n\n\twacom->led.groups[led->group].select = led->id;\n\n\terror = wacom_led_control(wacom);\n\nout:\n\tmutex_unlock(&wacom->lock);\n\n\treturn error;\n}\n\nstatic void wacom_led_readonly_brightness_set(struct led_classdev *cdev,\n\t\t\t\t\t       enum led_brightness brightness)\n{\n}\n\nstatic int wacom_led_register_one(struct device *dev, struct wacom *wacom,\n\t\t\t\t  struct wacom_led *led, unsigned int group,\n\t\t\t\t  unsigned int id, bool read_only)\n{\n\tint error;\n\tchar *name;\n\n\tname = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t      \"%s::wacom-%d.%d\",\n\t\t\t      dev_name(dev),\n\t\t\t      group,\n\t\t\t      id);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tif (!read_only) {\n\t\tled->trigger.name = name;\n\t\terror = devm_led_trigger_register(dev, &led->trigger);\n\t\tif (error) {\n\t\t\thid_err(wacom->hdev,\n\t\t\t\t\"failed to register LED trigger %s: %d\\n\",\n\t\t\t\tled->cdev.name, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tled->group = group;\n\tled->id = id;\n\tled->wacom = wacom;\n\tled->llv = wacom->led.llv;\n\tled->hlv = wacom->led.hlv;\n\tled->cdev.name = name;\n\tled->cdev.max_brightness = LED_FULL;\n\tled->cdev.flags = LED_HW_PLUGGABLE;\n\tled->cdev.brightness_get = __wacom_led_brightness_get;\n\tif (!read_only) {\n\t\tled->cdev.brightness_set_blocking = wacom_led_brightness_set;\n\t\tled->cdev.default_trigger = led->cdev.name;\n\t} else {\n\t\tled->cdev.brightness_set = wacom_led_readonly_brightness_set;\n\t}\n\n\terror = devm_led_classdev_register(dev, &led->cdev);\n\tif (error) {\n\t\thid_err(wacom->hdev,\n\t\t\t\"failed to register LED %s: %d\\n\",\n\t\t\tled->cdev.name, error);\n\t\tled->cdev.name = NULL;\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void wacom_led_groups_release_one(void *data)\n{\n\tstruct wacom_group_leds *group = data;\n\n\tdevres_release_group(group->dev, group);\n}\n\nstatic int wacom_led_groups_alloc_and_register_one(struct device *dev,\n\t\t\t\t\t\t   struct wacom *wacom,\n\t\t\t\t\t\t   int group_id, int count,\n\t\t\t\t\t\t   bool read_only)\n{\n\tstruct wacom_led *leds;\n\tint i, error;\n\n\tif (group_id >= wacom->led.count || count <= 0)\n\t\treturn -EINVAL;\n\n\tif (!devres_open_group(dev, &wacom->led.groups[group_id], GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tleds = devm_kcalloc(dev, count, sizeof(struct wacom_led), GFP_KERNEL);\n\tif (!leds) {\n\t\terror = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twacom->led.groups[group_id].leds = leds;\n\twacom->led.groups[group_id].count = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\terror = wacom_led_register_one(dev, wacom, &leds[i],\n\t\t\t\t\t       group_id, i, read_only);\n\t\tif (error)\n\t\t\tgoto err;\n\t}\n\n\twacom->led.groups[group_id].dev = dev;\n\n\tdevres_close_group(dev, &wacom->led.groups[group_id]);\n\n\t \n\terror = devm_add_action_or_reset(&wacom->hdev->dev,\n\t\t\t\t\t wacom_led_groups_release_one,\n\t\t\t\t\t &wacom->led.groups[group_id]);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n\nerr:\n\tdevres_release_group(dev, &wacom->led.groups[group_id]);\n\treturn error;\n}\n\nstruct wacom_led *wacom_led_find(struct wacom *wacom, unsigned int group_id,\n\t\t\t\t unsigned int id)\n{\n\tstruct wacom_group_leds *group;\n\n\tif (group_id >= wacom->led.count)\n\t\treturn NULL;\n\n\tgroup = &wacom->led.groups[group_id];\n\n\tif (!group->leds)\n\t\treturn NULL;\n\n\tid %= group->count;\n\n\treturn &group->leds[id];\n}\n\n \nstruct wacom_led *wacom_led_next(struct wacom *wacom, struct wacom_led *cur)\n{\n\tstruct wacom_led *next_led;\n\tint group, next;\n\n\tif (!wacom || !cur)\n\t\treturn NULL;\n\n\tgroup = cur->group;\n\tnext = cur->id;\n\n\tdo {\n\t\tnext_led = wacom_led_find(wacom, group, ++next);\n\t\tif (!next_led || next_led == cur)\n\t\t\treturn next_led;\n\t} while (next_led->cdev.trigger != &next_led->trigger);\n\n\treturn next_led;\n}\n\nstatic void wacom_led_groups_release(void *data)\n{\n\tstruct wacom *wacom = data;\n\n\twacom->led.groups = NULL;\n\twacom->led.count = 0;\n}\n\nstatic int wacom_led_groups_allocate(struct wacom *wacom, int count)\n{\n\tstruct device *dev = &wacom->hdev->dev;\n\tstruct wacom_group_leds *groups;\n\tint error;\n\n\tgroups = devm_kcalloc(dev, count, sizeof(struct wacom_group_leds),\n\t\t\t      GFP_KERNEL);\n\tif (!groups)\n\t\treturn -ENOMEM;\n\n\terror = devm_add_action_or_reset(dev, wacom_led_groups_release, wacom);\n\tif (error)\n\t\treturn error;\n\n\twacom->led.groups = groups;\n\twacom->led.count = count;\n\n\treturn 0;\n}\n\nstatic int wacom_leds_alloc_and_register(struct wacom *wacom, int group_count,\n\t\t\t\t\t int led_per_group, bool read_only)\n{\n\tstruct device *dev;\n\tint i, error;\n\n\tif (!wacom->wacom_wac.pad_input)\n\t\treturn -EINVAL;\n\n\tdev = &wacom->wacom_wac.pad_input->dev;\n\n\terror = wacom_led_groups_allocate(wacom, group_count);\n\tif (error)\n\t\treturn error;\n\n\tfor (i = 0; i < group_count; i++) {\n\t\terror = wacom_led_groups_alloc_and_register_one(dev, wacom, i,\n\t\t\t\t\t\t\t\tled_per_group,\n\t\t\t\t\t\t\t\tread_only);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nint wacom_initialize_leds(struct wacom *wacom)\n{\n\tint error;\n\n\tif (!(wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD))\n\t\treturn 0;\n\n\t \n\tswitch (wacom->wacom_wac.features.type) {\n\tcase HID_GENERIC:\n\t\tif (!wacom->generic_has_leds)\n\t\t\treturn 0;\n\t\twacom->led.llv = 100;\n\t\twacom->led.max_llv = 100;\n\n\t\terror = wacom_leds_alloc_and_register(wacom, 1, 4, false);\n\t\tif (error) {\n\t\t\thid_err(wacom->hdev,\n\t\t\t\t\"cannot create leds err: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = wacom_devm_sysfs_create_group(wacom,\n\t\t\t\t\t\t      &generic_led_attr_group);\n\t\tbreak;\n\n\tcase INTUOS4S:\n\tcase INTUOS4:\n\tcase INTUOS4WL:\n\tcase INTUOS4L:\n\t\twacom->led.llv = 10;\n\t\twacom->led.hlv = 20;\n\t\twacom->led.max_llv = 127;\n\t\twacom->led.max_hlv = 127;\n\t\twacom->led.img_lum = 10;\n\n\t\terror = wacom_leds_alloc_and_register(wacom, 1, 4, false);\n\t\tif (error) {\n\t\t\thid_err(wacom->hdev,\n\t\t\t\t\"cannot create leds err: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = wacom_devm_sysfs_create_group(wacom,\n\t\t\t\t\t\t      &intuos4_led_attr_group);\n\t\tbreak;\n\n\tcase WACOM_24HD:\n\tcase WACOM_21UX2:\n\t\twacom->led.llv = 0;\n\t\twacom->led.hlv = 0;\n\t\twacom->led.img_lum = 0;\n\n\t\terror = wacom_leds_alloc_and_register(wacom, 2, 4, false);\n\t\tif (error) {\n\t\t\thid_err(wacom->hdev,\n\t\t\t\t\"cannot create leds err: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = wacom_devm_sysfs_create_group(wacom,\n\t\t\t\t\t\t      &cintiq_led_attr_group);\n\t\tbreak;\n\n\tcase INTUOS5S:\n\tcase INTUOS5:\n\tcase INTUOS5L:\n\tcase INTUOSPS:\n\tcase INTUOSPM:\n\tcase INTUOSPL:\n\t\twacom->led.llv = 32;\n\t\twacom->led.max_llv = 96;\n\n\t\terror = wacom_leds_alloc_and_register(wacom, 1, 4, false);\n\t\tif (error) {\n\t\t\thid_err(wacom->hdev,\n\t\t\t\t\"cannot create leds err: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = wacom_devm_sysfs_create_group(wacom,\n\t\t\t\t\t\t      &intuos5_led_attr_group);\n\t\tbreak;\n\n\tcase INTUOSP2_BT:\n\t\twacom->led.llv = 50;\n\t\twacom->led.max_llv = 100;\n\t\terror = wacom_leds_alloc_and_register(wacom, 1, 4, false);\n\t\tif (error) {\n\t\t\thid_err(wacom->hdev,\n\t\t\t\t\"cannot create leds err: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t\treturn 0;\n\n\tcase REMOTE:\n\t\twacom->led.llv = 255;\n\t\twacom->led.max_llv = 255;\n\t\terror = wacom_led_groups_allocate(wacom, 5);\n\t\tif (error) {\n\t\t\thid_err(wacom->hdev,\n\t\t\t\t\"cannot create leds err: %d\\n\", error);\n\t\t\treturn error;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (error) {\n\t\thid_err(wacom->hdev,\n\t\t\t\"cannot create sysfs group err: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void wacom_init_work(struct work_struct *work)\n{\n\tstruct wacom *wacom = container_of(work, struct wacom, init_work.work);\n\n\t_wacom_query_tablet_data(wacom);\n\twacom_led_control(wacom);\n}\n\nstatic void wacom_query_tablet_data(struct wacom *wacom)\n{\n\tschedule_delayed_work(&wacom->init_work, msecs_to_jiffies(1000));\n}\n\nstatic enum power_supply_property wacom_battery_props[] = {\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_CAPACITY\n};\n\nstatic int wacom_battery_get_property(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tstruct wacom_battery *battery = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\t\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\t\tval->strval = battery->wacom->wacom_wac.name;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\t\tval->intval = battery->bat_connected;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\t\tval->intval = battery->battery_capacity;\n\t\t\tbreak;\n\t\tcase POWER_SUPPLY_PROP_STATUS:\n\t\t\tif (battery->bat_status != WACOM_POWER_SUPPLY_STATUS_AUTO)\n\t\t\t\tval->intval = battery->bat_status;\n\t\t\telse if (battery->bat_charging)\n\t\t\t\tval->intval = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\telse if (battery->battery_capacity == 100 &&\n\t\t\t\t    battery->ps_connected)\n\t\t\t\tval->intval = POWER_SUPPLY_STATUS_FULL;\n\t\t\telse if (battery->ps_connected)\n\t\t\t\tval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\telse\n\t\t\t\tval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int __wacom_initialize_battery(struct wacom *wacom,\n\t\t\t\t      struct wacom_battery *battery)\n{\n\tstatic atomic_t battery_no = ATOMIC_INIT(0);\n\tstruct device *dev = &wacom->hdev->dev;\n\tstruct power_supply_config psy_cfg = { .drv_data = battery, };\n\tstruct power_supply *ps_bat;\n\tstruct power_supply_desc *bat_desc = &battery->bat_desc;\n\tunsigned long n;\n\tint error;\n\n\tif (!devres_open_group(dev, bat_desc, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tbattery->wacom = wacom;\n\n\tn = atomic_inc_return(&battery_no) - 1;\n\n\tbat_desc->properties = wacom_battery_props;\n\tbat_desc->num_properties = ARRAY_SIZE(wacom_battery_props);\n\tbat_desc->get_property = wacom_battery_get_property;\n\tsprintf(battery->bat_name, \"wacom_battery_%ld\", n);\n\tbat_desc->name = battery->bat_name;\n\tbat_desc->type = POWER_SUPPLY_TYPE_BATTERY;\n\tbat_desc->use_for_apm = 0;\n\n\tps_bat = devm_power_supply_register(dev, bat_desc, &psy_cfg);\n\tif (IS_ERR(ps_bat)) {\n\t\terror = PTR_ERR(ps_bat);\n\t\tgoto err;\n\t}\n\n\tpower_supply_powers(ps_bat, &wacom->hdev->dev);\n\n\tbattery->battery = ps_bat;\n\n\tdevres_close_group(dev, bat_desc);\n\treturn 0;\n\nerr:\n\tdevres_release_group(dev, bat_desc);\n\treturn error;\n}\n\nstatic int wacom_initialize_battery(struct wacom *wacom)\n{\n\tif (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY)\n\t\treturn __wacom_initialize_battery(wacom, &wacom->battery);\n\n\treturn 0;\n}\n\nstatic void wacom_destroy_battery(struct wacom *wacom)\n{\n\tif (wacom->battery.battery) {\n\t\tdevres_release_group(&wacom->hdev->dev,\n\t\t\t\t     &wacom->battery.bat_desc);\n\t\twacom->battery.battery = NULL;\n\t}\n}\n\nstatic ssize_t wacom_show_speed(struct device *dev,\n\t\t\t\tstruct device_attribute\n\t\t\t\t*attr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", wacom->wacom_wac.bt_high_speed);\n}\n\nstatic ssize_t wacom_store_speed(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tu8 new_speed;\n\n\tif (kstrtou8(buf, 0, &new_speed))\n\t\treturn -EINVAL;\n\n\tif (new_speed != 0 && new_speed != 1)\n\t\treturn -EINVAL;\n\n\twacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,\n\t\twacom_show_speed, wacom_store_speed);\n\n\nstatic ssize_t wacom_show_remote_mode(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *kattr,\n\t\t\t\t      char *buf, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj->parent);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tu8 mode;\n\n\tmode = wacom->led.groups[index].select;\n\treturn sprintf(buf, \"%d\\n\", mode < 3 ? mode : -1);\n}\n\n#define DEVICE_EKR_ATTR_GROUP(SET_ID)\t\t\t\t\t\\\nstatic ssize_t wacom_show_remote##SET_ID##_mode(struct kobject *kobj,\t\\\n\t\t\t       struct kobj_attribute *kattr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn wacom_show_remote_mode(kobj, kattr, buf, SET_ID);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic struct kobj_attribute remote##SET_ID##_mode_attr = {\t\t\\\n\t.attr = {.name = \"remote_mode\",\t\t\t\t\t\\\n\t\t.mode = DEV_ATTR_RO_PERM},\t\t\t\t\\\n\t.show = wacom_show_remote##SET_ID##_mode,\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic struct attribute *remote##SET_ID##_serial_attrs[] = {\t\t\\\n\t&remote##SET_ID##_mode_attr.attr,\t\t\t\t\\\n\tNULL\t\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic const struct attribute_group remote##SET_ID##_serial_group = {\t\\\n\t.name = NULL,\t\t\t\t\t\t\t\\\n\t.attrs = remote##SET_ID##_serial_attrs,\t\t\t\t\\\n}\n\nDEVICE_EKR_ATTR_GROUP(0);\nDEVICE_EKR_ATTR_GROUP(1);\nDEVICE_EKR_ATTR_GROUP(2);\nDEVICE_EKR_ATTR_GROUP(3);\nDEVICE_EKR_ATTR_GROUP(4);\n\nstatic int wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial,\n\t\t\t\t\t  int index)\n{\n\tint error = 0;\n\tstruct wacom_remote *remote = wacom->remote;\n\n\tremote->remotes[index].group.name = devm_kasprintf(&wacom->hdev->dev,\n\t\t\t\t\t\t\t  GFP_KERNEL,\n\t\t\t\t\t\t\t  \"%d\", serial);\n\tif (!remote->remotes[index].group.name)\n\t\treturn -ENOMEM;\n\n\terror = __wacom_devm_sysfs_create_group(wacom, remote->remote_dir,\n\t\t\t\t\t\t&remote->remotes[index].group);\n\tif (error) {\n\t\tremote->remotes[index].group.name = NULL;\n\t\thid_err(wacom->hdev,\n\t\t\t\"cannot create sysfs group err: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int wacom_cmd_unpair_remote(struct wacom *wacom, unsigned char selector)\n{\n\tconst size_t buf_size = 2;\n\tunsigned char *buf;\n\tint retval;\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = WAC_CMD_DELETE_PAIRING;\n\tbuf[1] = selector;\n\n\tretval = wacom_set_report(wacom->hdev, HID_OUTPUT_REPORT, buf,\n\t\t\t\t  buf_size, WAC_CMD_RETRIES);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic ssize_t wacom_store_unpair_remote(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned char selector = 0;\n\tstruct device *dev = kobj_to_dev(kobj->parent);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tint err;\n\n\tif (!strncmp(buf, \"*\\n\", 2)) {\n\t\tselector = WAC_CMD_UNPAIR_ALL;\n\t} else {\n\t\thid_info(wacom->hdev, \"remote: unrecognized unpair code: %s\\n\",\n\t\t\t buf);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&wacom->lock);\n\n\terr = wacom_cmd_unpair_remote(wacom, selector);\n\tmutex_unlock(&wacom->lock);\n\n\treturn err < 0 ? err : count;\n}\n\nstatic struct kobj_attribute unpair_remote_attr = {\n\t.attr = {.name = \"unpair_remote\", .mode = 0200},\n\t.store = wacom_store_unpair_remote,\n};\n\nstatic const struct attribute *remote_unpair_attrs[] = {\n\t&unpair_remote_attr.attr,\n\tNULL\n};\n\nstatic void wacom_remotes_destroy(void *data)\n{\n\tstruct wacom *wacom = data;\n\tstruct wacom_remote *remote = wacom->remote;\n\n\tif (!remote)\n\t\treturn;\n\n\tkobject_put(remote->remote_dir);\n\tkfifo_free(&remote->remote_fifo);\n\twacom->remote = NULL;\n}\n\nstatic int wacom_initialize_remotes(struct wacom *wacom)\n{\n\tint error = 0;\n\tstruct wacom_remote *remote;\n\tint i;\n\n\tif (wacom->wacom_wac.features.type != REMOTE)\n\t\treturn 0;\n\n\tremote = devm_kzalloc(&wacom->hdev->dev, sizeof(*wacom->remote),\n\t\t\t      GFP_KERNEL);\n\tif (!remote)\n\t\treturn -ENOMEM;\n\n\twacom->remote = remote;\n\n\tspin_lock_init(&remote->remote_lock);\n\n\terror = kfifo_alloc(&remote->remote_fifo,\n\t\t\t5 * sizeof(struct wacom_remote_work_data),\n\t\t\tGFP_KERNEL);\n\tif (error) {\n\t\thid_err(wacom->hdev, \"failed allocating remote_fifo\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tremote->remotes[0].group = remote0_serial_group;\n\tremote->remotes[1].group = remote1_serial_group;\n\tremote->remotes[2].group = remote2_serial_group;\n\tremote->remotes[3].group = remote3_serial_group;\n\tremote->remotes[4].group = remote4_serial_group;\n\n\tremote->remote_dir = kobject_create_and_add(\"wacom_remote\",\n\t\t\t\t\t\t    &wacom->hdev->dev.kobj);\n\tif (!remote->remote_dir)\n\t\treturn -ENOMEM;\n\n\terror = sysfs_create_files(remote->remote_dir, remote_unpair_attrs);\n\n\tif (error) {\n\t\thid_err(wacom->hdev,\n\t\t\t\"cannot create sysfs group err: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\n\t\twacom->led.groups[i].select = WACOM_STATUS_UNKNOWN;\n\t\tremote->remotes[i].serial = 0;\n\t}\n\n\terror = devm_add_action_or_reset(&wacom->hdev->dev,\n\t\t\t\t\t wacom_remotes_destroy, wacom);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic struct input_dev *wacom_allocate_input(struct wacom *wacom)\n{\n\tstruct input_dev *input_dev;\n\tstruct hid_device *hdev = wacom->hdev;\n\tstruct wacom_wac *wacom_wac = &(wacom->wacom_wac);\n\n\tinput_dev = devm_input_allocate_device(&hdev->dev);\n\tif (!input_dev)\n\t\treturn NULL;\n\n\tinput_dev->name = wacom_wac->features.name;\n\tinput_dev->phys = hdev->phys;\n\tinput_dev->dev.parent = &hdev->dev;\n\tinput_dev->open = wacom_open;\n\tinput_dev->close = wacom_close;\n\tinput_dev->uniq = hdev->uniq;\n\tinput_dev->id.bustype = hdev->bus;\n\tinput_dev->id.vendor  = hdev->vendor;\n\tinput_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;\n\tinput_dev->id.version = hdev->version;\n\tinput_set_drvdata(input_dev, wacom);\n\n\treturn input_dev;\n}\n\nstatic int wacom_allocate_inputs(struct wacom *wacom)\n{\n\tstruct wacom_wac *wacom_wac = &(wacom->wacom_wac);\n\n\twacom_wac->pen_input = wacom_allocate_input(wacom);\n\twacom_wac->touch_input = wacom_allocate_input(wacom);\n\twacom_wac->pad_input = wacom_allocate_input(wacom);\n\tif (!wacom_wac->pen_input ||\n\t    !wacom_wac->touch_input ||\n\t    !wacom_wac->pad_input)\n\t\treturn -ENOMEM;\n\n\twacom_wac->pen_input->name = wacom_wac->pen_name;\n\twacom_wac->touch_input->name = wacom_wac->touch_name;\n\twacom_wac->pad_input->name = wacom_wac->pad_name;\n\n\treturn 0;\n}\n\nstatic int wacom_register_inputs(struct wacom *wacom)\n{\n\tstruct input_dev *pen_input_dev, *touch_input_dev, *pad_input_dev;\n\tstruct wacom_wac *wacom_wac = &(wacom->wacom_wac);\n\tint error = 0;\n\n\tpen_input_dev = wacom_wac->pen_input;\n\ttouch_input_dev = wacom_wac->touch_input;\n\tpad_input_dev = wacom_wac->pad_input;\n\n\tif (!pen_input_dev || !touch_input_dev || !pad_input_dev)\n\t\treturn -EINVAL;\n\n\terror = wacom_setup_pen_input_capabilities(pen_input_dev, wacom_wac);\n\tif (error) {\n\t\t \n\t\tinput_free_device(pen_input_dev);\n\t\twacom_wac->pen_input = NULL;\n\t\tpen_input_dev = NULL;\n\t} else {\n\t\terror = input_register_device(pen_input_dev);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\terror = wacom_setup_touch_input_capabilities(touch_input_dev, wacom_wac);\n\tif (error) {\n\t\t \n\t\tinput_free_device(touch_input_dev);\n\t\twacom_wac->touch_input = NULL;\n\t\ttouch_input_dev = NULL;\n\t} else {\n\t\terror = input_register_device(touch_input_dev);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\terror = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);\n\tif (error) {\n\t\t \n\t\tinput_free_device(pad_input_dev);\n\t\twacom_wac->pad_input = NULL;\n\t\tpad_input_dev = NULL;\n\t} else {\n\t\terror = input_register_device(pad_input_dev);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\twacom_wac->pad_input = NULL;\n\twacom_wac->touch_input = NULL;\n\twacom_wac->pen_input = NULL;\n\treturn error;\n}\n\n \nstatic void wacom_set_default_phy(struct wacom_features *features)\n{\n\tif (features->x_resolution) {\n\t\tfeatures->x_phy = (features->x_max * 100) /\n\t\t\t\t\tfeatures->x_resolution;\n\t\tfeatures->y_phy = (features->y_max * 100) /\n\t\t\t\t\tfeatures->y_resolution;\n\t}\n}\n\nstatic void wacom_calculate_res(struct wacom_features *features)\n{\n\t \n\tif (!features->unit) {\n\t\tfeatures->unit = 0x11;\n\t\tfeatures->unitExpo = -3;\n\t}\n\n\tfeatures->x_resolution = wacom_calc_hid_res(features->x_max,\n\t\t\t\t\t\t    features->x_phy,\n\t\t\t\t\t\t    features->unit,\n\t\t\t\t\t\t    features->unitExpo);\n\tfeatures->y_resolution = wacom_calc_hid_res(features->y_max,\n\t\t\t\t\t\t    features->y_phy,\n\t\t\t\t\t\t    features->unit,\n\t\t\t\t\t\t    features->unitExpo);\n}\n\nvoid wacom_battery_work(struct work_struct *work)\n{\n\tstruct wacom *wacom = container_of(work, struct wacom, battery_work);\n\n\tif ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&\n\t     !wacom->battery.battery) {\n\t\twacom_initialize_battery(wacom);\n\t}\n\telse if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&\n\t\t wacom->battery.battery) {\n\t\twacom_destroy_battery(wacom);\n\t}\n}\n\nstatic size_t wacom_compute_pktlen(struct hid_device *hdev)\n{\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_report *report;\n\tsize_t size = 0;\n\n\treport_enum = hdev->report_enum + HID_INPUT_REPORT;\n\n\tlist_for_each_entry(report, &report_enum->report_list, list) {\n\t\tsize_t report_size = hid_report_len(report);\n\t\tif (report_size > size)\n\t\t\tsize = report_size;\n\t}\n\n\treturn size;\n}\n\nstatic void wacom_update_name(struct wacom *wacom, const char *suffix)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tchar name[WACOM_NAME_MAX - 20];  \n\n\t \n\tif ((features->type == HID_GENERIC) && !strcmp(\"Wacom HID\", features->name)) {\n\t\tchar *product_name = wacom->hdev->name;\n\n\t\tif (hid_is_usb(wacom->hdev)) {\n\t\t\tstruct usb_interface *intf = to_usb_interface(wacom->hdev->dev.parent);\n\t\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\t\t\tproduct_name = dev->product;\n\t\t}\n\n\t\tif (wacom->hdev->bus == BUS_I2C) {\n\t\t\tsnprintf(name, sizeof(name), \"%s %X\",\n\t\t\t\t features->name, wacom->hdev->product);\n\t\t} else if (strstr(product_name, \"Wacom\") ||\n\t\t\t   strstr(product_name, \"wacom\") ||\n\t\t\t   strstr(product_name, \"WACOM\")) {\n\t\t\tif (strscpy(name, product_name, sizeof(name)) < 0) {\n\t\t\t\thid_warn(wacom->hdev, \"String overflow while assembling device name\");\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"Wacom %s\", product_name);\n\t\t}\n\n\t\t \n\t\twhile (1) {\n\t\t\tchar *gap = strstr(name, \"  \");\n\t\t\tif (gap == NULL)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tmemmove(gap, gap+1, strlen(gap));\n\t\t}\n\n\t\t \n\t\tif (name[strlen(name)-1] == ' ')\n\t\t\tname[strlen(name)-1] = '\\0';\n\t} else {\n\t\tif (strscpy(name, features->name, sizeof(name)) < 0) {\n\t\t\thid_warn(wacom->hdev, \"String overflow while assembling device name\");\n\t\t}\n\t}\n\n\tsnprintf(wacom_wac->name, sizeof(wacom_wac->name), \"%s%s\",\n\t\t name, suffix);\n\n\t \n\tsnprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),\n\t\t\"%s%s Pen\", name, suffix);\n\tsnprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),\n\t\t\"%s%s Finger\", name, suffix);\n\tsnprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),\n\t\t\"%s%s Pad\", name, suffix);\n}\n\nstatic void wacom_release_resources(struct wacom *wacom)\n{\n\tstruct hid_device *hdev = wacom->hdev;\n\n\tif (!wacom->resources)\n\t\treturn;\n\n\tdevres_release_group(&hdev->dev, wacom);\n\n\twacom->resources = false;\n\n\twacom->wacom_wac.pen_input = NULL;\n\twacom->wacom_wac.touch_input = NULL;\n\twacom->wacom_wac.pad_input = NULL;\n}\n\nstatic void wacom_set_shared_values(struct wacom_wac *wacom_wac)\n{\n\tif (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH) {\n\t\twacom_wac->shared->type = wacom_wac->features.type;\n\t\twacom_wac->shared->touch_input = wacom_wac->touch_input;\n\t}\n\n\tif (wacom_wac->has_mute_touch_switch) {\n\t\twacom_wac->shared->has_mute_touch_switch = true;\n\t\t \n\t\tif (wacom_wac->is_soft_touch_switch)\n\t\t\twacom_wac->shared->is_touch_on = true;\n\t}\n\n\tif (wacom_wac->shared->has_mute_touch_switch &&\n\t    wacom_wac->shared->touch_input) {\n\t\tset_bit(EV_SW, wacom_wac->shared->touch_input->evbit);\n\t\tinput_set_capability(wacom_wac->shared->touch_input, EV_SW,\n\t\t\t\t     SW_MUTE_DEVICE);\n\t}\n}\n\nstatic int wacom_parse_and_register(struct wacom *wacom, bool wireless)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tstruct hid_device *hdev = wacom->hdev;\n\tint error;\n\tunsigned int connect_mask = HID_CONNECT_HIDRAW;\n\n\tfeatures->pktlen = wacom_compute_pktlen(hdev);\n\tif (features->pktlen > WACOM_PKGLEN_MAX)\n\t\treturn -EINVAL;\n\n\tif (!devres_open_group(&hdev->dev, wacom, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\twacom->resources = true;\n\n\terror = wacom_allocate_inputs(wacom);\n\tif (error)\n\t\tgoto fail;\n\n\t \n\tif (features->type == BAMBOO_PAD) {\n\t\tif (features->pktlen == WACOM_PKGLEN_PENABLED) {\n\t\t\tfeatures->type = HID_GENERIC;\n\t\t} else if ((features->pktlen != WACOM_PKGLEN_BPAD_TOUCH) &&\n\t\t\t   (features->pktlen != WACOM_PKGLEN_BPAD_TOUCH_USB)) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\twacom_set_default_phy(features);\n\n\t \n\twacom_retrieve_hid_descriptor(hdev, features);\n\twacom_setup_device_quirks(wacom);\n\n\tif (features->device_type == WACOM_DEVICETYPE_NONE &&\n\t    features->type != WIRELESS) {\n\t\terror = features->type == HID_GENERIC ? -ENODEV : 0;\n\n\t\tdev_warn(&hdev->dev, \"Unknown device_type for '%s'. %s.\",\n\t\t\t hdev->name,\n\t\t\t error ? \"Ignoring\" : \"Assuming pen\");\n\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PEN;\n\t}\n\n\twacom_calculate_res(features);\n\n\twacom_update_name(wacom, wireless ? \" (WL)\" : \"\");\n\n\t \n\tif ((features->type == BAMBOO_PEN) &&\n\t    ((features->device_type & WACOM_DEVICETYPE_TOUCH) ||\n\t    (features->device_type & WACOM_DEVICETYPE_PAD))) {\n\t\terror = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\terror = wacom_add_shared_data(hdev);\n\tif (error)\n\t\tgoto fail;\n\n\terror = wacom_register_inputs(wacom);\n\tif (error)\n\t\tgoto fail;\n\n\tif (wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD) {\n\t\terror = wacom_initialize_leds(wacom);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = wacom_initialize_remotes(wacom);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tif (features->type == HID_GENERIC)\n\t\tconnect_mask |= HID_CONNECT_DRIVER;\n\n\t \n\terror = hid_hw_start(hdev, connect_mask);\n\tif (error) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (!wireless) {\n\t\t \n\t\twacom_query_tablet_data(wacom);\n\t}\n\n\t \n\tif ((features->type == BAMBOO_TOUCH) &&\n\t    (features->device_type & WACOM_DEVICETYPE_PEN)) {\n\t\tcancel_delayed_work_sync(&wacom->init_work);\n\t\t_wacom_query_tablet_data(wacom);\n\t\terror = -ENODEV;\n\t\tgoto fail_quirks;\n\t}\n\n\tif (features->device_type & WACOM_DEVICETYPE_WL_MONITOR) {\n\t\terror = hid_hw_open(hdev);\n\t\tif (error) {\n\t\t\thid_err(hdev, \"hw open failed\\n\");\n\t\t\tgoto fail_quirks;\n\t\t}\n\t}\n\n\twacom_set_shared_values(wacom_wac);\n\tdevres_close_group(&hdev->dev, wacom);\n\n\treturn 0;\n\nfail_quirks:\n\thid_hw_stop(hdev);\nfail:\n\twacom_release_resources(wacom);\n\treturn error;\n}\n\nstatic void wacom_wireless_work(struct work_struct *work)\n{\n\tstruct wacom *wacom = container_of(work, struct wacom, wireless_work);\n\tstruct usb_device *usbdev = wacom->usbdev;\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct hid_device *hdev1, *hdev2;\n\tstruct wacom *wacom1, *wacom2;\n\tstruct wacom_wac *wacom_wac1, *wacom_wac2;\n\tint error;\n\n\t \n\n\twacom_destroy_battery(wacom);\n\n\tif (!usbdev)\n\t\treturn;\n\n\t \n\thdev1 = usb_get_intfdata(usbdev->config->interface[1]);\n\twacom1 = hid_get_drvdata(hdev1);\n\twacom_wac1 = &(wacom1->wacom_wac);\n\twacom_release_resources(wacom1);\n\n\t \n\thdev2 = usb_get_intfdata(usbdev->config->interface[2]);\n\twacom2 = hid_get_drvdata(hdev2);\n\twacom_wac2 = &(wacom2->wacom_wac);\n\twacom_release_resources(wacom2);\n\n\tif (wacom_wac->pid == 0) {\n\t\thid_info(wacom->hdev, \"wireless tablet disconnected\\n\");\n\t} else {\n\t\tconst struct hid_device_id *id = wacom_ids;\n\n\t\thid_info(wacom->hdev, \"wireless tablet connected with PID %x\\n\",\n\t\t\t wacom_wac->pid);\n\n\t\twhile (id->bus) {\n\t\t\tif (id->vendor == USB_VENDOR_ID_WACOM &&\n\t\t\t    id->product == wacom_wac->pid)\n\t\t\t\tbreak;\n\t\t\tid++;\n\t\t}\n\n\t\tif (!id->bus) {\n\t\t\thid_info(wacom->hdev, \"ignoring unknown PID.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\twacom_wac1->features =\n\t\t\t*((struct wacom_features *)id->driver_data);\n\n\t\twacom_wac1->pid = wacom_wac->pid;\n\t\thid_hw_stop(hdev1);\n\t\terror = wacom_parse_and_register(wacom1, true);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\t \n\t\tif (wacom_wac1->features.touch_max ||\n\t\t    (wacom_wac1->features.type >= INTUOSHT &&\n\t\t    wacom_wac1->features.type <= BAMBOO_PT)) {\n\t\t\twacom_wac2->features =\n\t\t\t\t*((struct wacom_features *)id->driver_data);\n\t\t\twacom_wac2->pid = wacom_wac->pid;\n\t\t\thid_hw_stop(hdev2);\n\t\t\terror = wacom_parse_and_register(wacom2, true);\n\t\t\tif (error)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (strscpy(wacom_wac->name, wacom_wac1->name,\n\t\t\tsizeof(wacom_wac->name)) < 0) {\n\t\t\thid_warn(wacom->hdev, \"String overflow while assembling device name\");\n\t\t}\n\t}\n\n\treturn;\n\nfail:\n\twacom_release_resources(wacom1);\n\twacom_release_resources(wacom2);\n\treturn;\n}\n\nstatic void wacom_remote_destroy_battery(struct wacom *wacom, int index)\n{\n\tstruct wacom_remote *remote = wacom->remote;\n\n\tif (remote->remotes[index].battery.battery) {\n\t\tdevres_release_group(&wacom->hdev->dev,\n\t\t\t\t     &remote->remotes[index].battery.bat_desc);\n\t\tremote->remotes[index].battery.battery = NULL;\n\t\tremote->remotes[index].active_time = 0;\n\t}\n}\n\nstatic void wacom_remote_destroy_one(struct wacom *wacom, unsigned int index)\n{\n\tstruct wacom_remote *remote = wacom->remote;\n\tu32 serial = remote->remotes[index].serial;\n\tint i;\n\tunsigned long flags;\n\n\tfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\n\t\tif (remote->remotes[i].serial == serial) {\n\n\t\t\tspin_lock_irqsave(&remote->remote_lock, flags);\n\t\t\tremote->remotes[i].registered = false;\n\t\t\tspin_unlock_irqrestore(&remote->remote_lock, flags);\n\n\t\t\twacom_remote_destroy_battery(wacom, i);\n\n\t\t\tif (remote->remotes[i].group.name)\n\t\t\t\tdevres_release_group(&wacom->hdev->dev,\n\t\t\t\t\t\t     &remote->remotes[i]);\n\n\t\t\tremote->remotes[i].serial = 0;\n\t\t\tremote->remotes[i].group.name = NULL;\n\t\t\twacom->led.groups[i].select = WACOM_STATUS_UNKNOWN;\n\t\t}\n\t}\n}\n\nstatic int wacom_remote_create_one(struct wacom *wacom, u32 serial,\n\t\t\t\t   unsigned int index)\n{\n\tstruct wacom_remote *remote = wacom->remote;\n\tstruct device *dev = &wacom->hdev->dev;\n\tint error, k;\n\n\t \n\tfor (k = 0; k < WACOM_MAX_REMOTES; k++) {\n\t\tif (remote->remotes[k].serial == serial)\n\t\t\tbreak;\n\t}\n\n\tif (k < WACOM_MAX_REMOTES) {\n\t\tremote->remotes[index].serial = serial;\n\t\treturn 0;\n\t}\n\n\tif (!devres_open_group(dev, &remote->remotes[index], GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terror = wacom_remote_create_attr_group(wacom, serial, index);\n\tif (error)\n\t\tgoto fail;\n\n\tremote->remotes[index].input = wacom_allocate_input(wacom);\n\tif (!remote->remotes[index].input) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tremote->remotes[index].input->uniq = remote->remotes[index].group.name;\n\tremote->remotes[index].input->name = wacom->wacom_wac.pad_name;\n\n\tif (!remote->remotes[index].input->name) {\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\terror = wacom_setup_pad_input_capabilities(remote->remotes[index].input,\n\t\t\t\t\t\t   &wacom->wacom_wac);\n\tif (error)\n\t\tgoto fail;\n\n\tremote->remotes[index].serial = serial;\n\n\terror = input_register_device(remote->remotes[index].input);\n\tif (error)\n\t\tgoto fail;\n\n\terror = wacom_led_groups_alloc_and_register_one(\n\t\t\t\t\t&remote->remotes[index].input->dev,\n\t\t\t\t\twacom, index, 3, true);\n\tif (error)\n\t\tgoto fail;\n\n\tremote->remotes[index].registered = true;\n\n\tdevres_close_group(dev, &remote->remotes[index]);\n\treturn 0;\n\nfail:\n\tdevres_release_group(dev, &remote->remotes[index]);\n\tremote->remotes[index].serial = 0;\n\treturn error;\n}\n\nstatic int wacom_remote_attach_battery(struct wacom *wacom, int index)\n{\n\tstruct wacom_remote *remote = wacom->remote;\n\tint error;\n\n\tif (!remote->remotes[index].registered)\n\t\treturn 0;\n\n\tif (remote->remotes[index].battery.battery)\n\t\treturn 0;\n\n\tif (!remote->remotes[index].active_time)\n\t\treturn 0;\n\n\tif (wacom->led.groups[index].select == WACOM_STATUS_UNKNOWN)\n\t\treturn 0;\n\n\terror = __wacom_initialize_battery(wacom,\n\t\t\t\t\t&wacom->remote->remotes[index].battery);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic void wacom_remote_work(struct work_struct *work)\n{\n\tstruct wacom *wacom = container_of(work, struct wacom, remote_work);\n\tstruct wacom_remote *remote = wacom->remote;\n\tktime_t kt = ktime_get();\n\tstruct wacom_remote_work_data remote_work_data;\n\tunsigned long flags;\n\tunsigned int count;\n\tu32 work_serial;\n\tint i;\n\n\tspin_lock_irqsave(&remote->remote_lock, flags);\n\n\tcount = kfifo_out(&remote->remote_fifo, &remote_work_data,\n\t\t\t  sizeof(remote_work_data));\n\n\tif (count != sizeof(remote_work_data)) {\n\t\thid_err(wacom->hdev,\n\t\t\t\"workitem triggered without status available\\n\");\n\t\tspin_unlock_irqrestore(&remote->remote_lock, flags);\n\t\treturn;\n\t}\n\n\tif (!kfifo_is_empty(&remote->remote_fifo))\n\t\twacom_schedule_work(&wacom->wacom_wac, WACOM_WORKER_REMOTE);\n\n\tspin_unlock_irqrestore(&remote->remote_lock, flags);\n\n\tfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\n\t\twork_serial = remote_work_data.remote[i].serial;\n\t\tif (work_serial) {\n\n\t\t\tif (kt - remote->remotes[i].active_time > WACOM_REMOTE_BATTERY_TIMEOUT\n\t\t\t    && remote->remotes[i].active_time != 0)\n\t\t\t\twacom_remote_destroy_battery(wacom, i);\n\n\t\t\tif (remote->remotes[i].serial == work_serial) {\n\t\t\t\twacom_remote_attach_battery(wacom, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (remote->remotes[i].serial)\n\t\t\t\twacom_remote_destroy_one(wacom, i);\n\n\t\t\twacom_remote_create_one(wacom, work_serial, i);\n\n\t\t} else if (remote->remotes[i].serial) {\n\t\t\twacom_remote_destroy_one(wacom, i);\n\t\t}\n\t}\n}\n\nstatic void wacom_mode_change_work(struct work_struct *work)\n{\n\tstruct wacom *wacom = container_of(work, struct wacom, mode_change_work);\n\tstruct wacom_shared *shared = wacom->wacom_wac.shared;\n\tstruct wacom *wacom1 = NULL;\n\tstruct wacom *wacom2 = NULL;\n\tbool is_direct = wacom->wacom_wac.is_direct_mode;\n\tint error = 0;\n\n\tif (shared->pen) {\n\t\twacom1 = hid_get_drvdata(shared->pen);\n\t\twacom_release_resources(wacom1);\n\t\thid_hw_stop(wacom1->hdev);\n\t\twacom1->wacom_wac.has_mode_change = true;\n\t\twacom1->wacom_wac.is_direct_mode = is_direct;\n\t}\n\n\tif (shared->touch) {\n\t\twacom2 = hid_get_drvdata(shared->touch);\n\t\twacom_release_resources(wacom2);\n\t\thid_hw_stop(wacom2->hdev);\n\t\twacom2->wacom_wac.has_mode_change = true;\n\t\twacom2->wacom_wac.is_direct_mode = is_direct;\n\t}\n\n\tif (wacom1) {\n\t\terror = wacom_parse_and_register(wacom1, false);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\tif (wacom2) {\n\t\terror = wacom_parse_and_register(wacom2, false);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\n\treturn;\n}\n\nstatic int wacom_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tstruct wacom *wacom;\n\tstruct wacom_wac *wacom_wac;\n\tstruct wacom_features *features;\n\tint error;\n\n\tif (!id->driver_data)\n\t\treturn -EINVAL;\n\n\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\n\t \n\thdev->quirks &= ~HID_QUIRK_NOGET;\n\n\twacom = devm_kzalloc(&hdev->dev, sizeof(struct wacom), GFP_KERNEL);\n\tif (!wacom)\n\t\treturn -ENOMEM;\n\n\thid_set_drvdata(hdev, wacom);\n\twacom->hdev = hdev;\n\n\twacom_wac = &wacom->wacom_wac;\n\twacom_wac->features = *((struct wacom_features *)id->driver_data);\n\tfeatures = &wacom_wac->features;\n\n\tif (features->check_for_hid_type && features->hid_type != hdev->type)\n\t\treturn -ENODEV;\n\n\terror = wacom_devm_kfifo_alloc(wacom);\n\tif (error)\n\t\treturn error;\n\n\twacom_wac->hid_data.inputmode = -1;\n\twacom_wac->mode_report = -1;\n\n\tif (hid_is_usb(hdev)) {\n\t\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\t\tstruct usb_device *dev = interface_to_usbdev(intf);\n\n\t\twacom->usbdev = dev;\n\t\twacom->intf = intf;\n\t}\n\n\tmutex_init(&wacom->lock);\n\tINIT_DELAYED_WORK(&wacom->init_work, wacom_init_work);\n\tINIT_WORK(&wacom->wireless_work, wacom_wireless_work);\n\tINIT_WORK(&wacom->battery_work, wacom_battery_work);\n\tINIT_WORK(&wacom->remote_work, wacom_remote_work);\n\tINIT_WORK(&wacom->mode_change_work, wacom_mode_change_work);\n\ttimer_setup(&wacom->idleprox_timer, &wacom_idleprox_timeout, TIMER_DEFERRABLE);\n\n\t \n\terror = hid_parse(hdev);\n\tif (error) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn error;\n\t}\n\n\tif (features->type == BOOTLOADER) {\n\t\thid_warn(hdev, \"Using device in hidraw-only mode\");\n\t\treturn hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\t}\n\n\terror = wacom_parse_and_register(wacom, false);\n\tif (error)\n\t\treturn error;\n\n\tif (hdev->bus == BUS_BLUETOOTH) {\n\t\terror = device_create_file(&hdev->dev, &dev_attr_speed);\n\t\tif (error)\n\t\t\thid_warn(hdev,\n\t\t\t\t \"can't create sysfs speed attribute err: %d\\n\",\n\t\t\t\t error);\n\t}\n\n\twacom_wac->probe_complete = true;\n\treturn 0;\n}\n\nstatic void wacom_remove(struct hid_device *hdev)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\n\tif (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)\n\t\thid_hw_close(hdev);\n\n\thid_hw_stop(hdev);\n\n\tcancel_delayed_work_sync(&wacom->init_work);\n\tcancel_work_sync(&wacom->wireless_work);\n\tcancel_work_sync(&wacom->battery_work);\n\tcancel_work_sync(&wacom->remote_work);\n\tcancel_work_sync(&wacom->mode_change_work);\n\tdel_timer_sync(&wacom->idleprox_timer);\n\tif (hdev->bus == BUS_BLUETOOTH)\n\t\tdevice_remove_file(&hdev->dev, &dev_attr_speed);\n\n\t \n\twacom_led_groups_release(wacom);\n\n\tif (wacom->wacom_wac.features.type != REMOTE)\n\t\twacom_release_resources(wacom);\n}\n\n#ifdef CONFIG_PM\nstatic int wacom_resume(struct hid_device *hdev)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\n\tmutex_lock(&wacom->lock);\n\n\t \n\t_wacom_query_tablet_data(wacom);\n\twacom_led_control(wacom);\n\n\tmutex_unlock(&wacom->lock);\n\n\treturn 0;\n}\n\nstatic int wacom_reset_resume(struct hid_device *hdev)\n{\n\treturn wacom_resume(hdev);\n}\n#endif  \n\nstatic struct hid_driver wacom_driver = {\n\t.name =\t\t\"wacom\",\n\t.id_table =\twacom_ids,\n\t.probe =\twacom_probe,\n\t.remove =\twacom_remove,\n\t.report =\twacom_wac_report,\n#ifdef CONFIG_PM\n\t.resume =\twacom_resume,\n\t.reset_resume =\twacom_reset_resume,\n#endif\n\t.raw_event =\twacom_raw_event,\n};\nmodule_hid_driver(wacom_driver);\n\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}