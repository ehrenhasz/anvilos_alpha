{
  "module_name": "hid-gt683r.c",
  "hash_id": "848910e177ba53ad1e488d03faf6c0687e6daca476e12664918812e43a69baa0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-gt683r.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define GT683R_BUFFER_SIZE\t\t\t8\n\n \nenum gt683r_led_mode {\n\tGT683R_LED_OFF = 0,\n\tGT683R_LED_AUDIO = 2,\n\tGT683R_LED_BREATHING = 3,\n\tGT683R_LED_NORMAL = 5\n};\n\nenum gt683r_panels {\n\tGT683R_LED_BACK = 0,\n\tGT683R_LED_SIDE = 1,\n\tGT683R_LED_FRONT = 2,\n\tGT683R_LED_COUNT,\n};\n\nstatic const char * const gt683r_panel_names[] = {\n\t\"back\",\n\t\"side\",\n\t\"front\",\n};\n\nstruct gt683r_led {\n\tstruct hid_device *hdev;\n\tstruct led_classdev led_devs[GT683R_LED_COUNT];\n\tstruct mutex lock;\n\tstruct work_struct work;\n\tenum led_brightness brightnesses[GT683R_LED_COUNT];\n\tenum gt683r_led_mode mode;\n};\n\nstatic const struct hid_device_id gt683r_led_id[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MSI, USB_DEVICE_ID_MSI_GT683R_LED_PANEL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, gt683r_led_id);\n\nstatic void gt683r_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness brightness)\n{\n\tint i;\n\tstruct device *dev = led_cdev->dev->parent;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct gt683r_led *led = hid_get_drvdata(hdev);\n\n\tfor (i = 0; i < GT683R_LED_COUNT; i++) {\n\t\tif (led_cdev == &led->led_devs[i])\n\t\t\tbreak;\n\t}\n\n\tif (i < GT683R_LED_COUNT) {\n\t\tled->brightnesses[i] = brightness;\n\t\tschedule_work(&led->work);\n\t}\n}\n\nstatic ssize_t mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tu8 sysfs_mode;\n\tstruct hid_device *hdev = to_hid_device(dev->parent);\n\tstruct gt683r_led *led = hid_get_drvdata(hdev);\n\n\tif (led->mode == GT683R_LED_NORMAL)\n\t\tsysfs_mode = 0;\n\telse if (led->mode == GT683R_LED_AUDIO)\n\t\tsysfs_mode = 1;\n\telse\n\t\tsysfs_mode = 2;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", sysfs_mode);\n}\n\nstatic ssize_t mode_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tu8 sysfs_mode;\n\tstruct hid_device *hdev = to_hid_device(dev->parent);\n\tstruct gt683r_led *led = hid_get_drvdata(hdev);\n\n\n\tif (kstrtou8(buf, 10, &sysfs_mode) || sysfs_mode > 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&led->lock);\n\n\tif (sysfs_mode == 0)\n\t\tled->mode = GT683R_LED_NORMAL;\n\telse if (sysfs_mode == 1)\n\t\tled->mode = GT683R_LED_AUDIO;\n\telse\n\t\tled->mode = GT683R_LED_BREATHING;\n\n\tmutex_unlock(&led->lock);\n\tschedule_work(&led->work);\n\n\treturn count;\n}\n\nstatic int gt683r_led_snd_msg(struct gt683r_led *led, u8 *msg)\n{\n\tint ret;\n\n\tret = hid_hw_raw_request(led->hdev, msg[0], msg, GT683R_BUFFER_SIZE,\n\t\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\tif (ret != GT683R_BUFFER_SIZE) {\n\t\thid_err(led->hdev,\n\t\t\t\"failed to send set report request: %i\\n\", ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int gt683r_leds_set(struct gt683r_led *led, u8 leds)\n{\n\tint ret;\n\tu8 *buffer;\n\n\tbuffer = kzalloc(GT683R_BUFFER_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = 0x01;\n\tbuffer[1] = 0x02;\n\tbuffer[2] = 0x30;\n\tbuffer[3] = leds;\n\tret = gt683r_led_snd_msg(led, buffer);\n\n\tkfree(buffer);\n\treturn ret;\n}\n\nstatic int gt683r_mode_set(struct gt683r_led *led, u8 mode)\n{\n\tint ret;\n\tu8 *buffer;\n\n\tbuffer = kzalloc(GT683R_BUFFER_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = 0x01;\n\tbuffer[1] = 0x02;\n\tbuffer[2] = 0x20;\n\tbuffer[3] = mode;\n\tbuffer[4] = 0x01;\n\tret = gt683r_led_snd_msg(led, buffer);\n\n\tkfree(buffer);\n\treturn ret;\n}\n\nstatic void gt683r_led_work(struct work_struct *work)\n{\n\tint i;\n\tu8 leds = 0;\n\tu8 mode;\n\tstruct gt683r_led *led = container_of(work, struct gt683r_led, work);\n\n\tmutex_lock(&led->lock);\n\n\tfor (i = 0; i < GT683R_LED_COUNT; i++) {\n\t\tif (led->brightnesses[i])\n\t\t\tleds |= BIT(i);\n\t}\n\n\tif (gt683r_leds_set(led, leds))\n\t\tgoto fail;\n\n\tif (leds)\n\t\tmode = led->mode;\n\telse\n\t\tmode = GT683R_LED_OFF;\n\n\tgt683r_mode_set(led, mode);\nfail:\n\tmutex_unlock(&led->lock);\n}\n\nstatic DEVICE_ATTR_RW(mode);\n\nstatic struct attribute *gt683r_led_attrs[] = {\n\t&dev_attr_mode.attr,\n\tNULL\n};\n\nstatic const struct attribute_group gt683r_led_group = {\n\t.name = \"gt683r\",\n\t.attrs = gt683r_led_attrs,\n};\n\nstatic const struct attribute_group *gt683r_led_groups[] = {\n\t&gt683r_led_group,\n\tNULL\n};\n\nstatic int gt683r_led_probe(struct hid_device *hdev,\n\t\t\tconst struct hid_device_id *id)\n{\n\tint i;\n\tint ret;\n\tint name_sz;\n\tchar *name;\n\tstruct gt683r_led *led;\n\n\tled = devm_kzalloc(&hdev->dev, sizeof(*led), GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&led->lock);\n\tINIT_WORK(&led->work, gt683r_led_work);\n\n\tled->mode = GT683R_LED_NORMAL;\n\tled->hdev = hdev;\n\thid_set_drvdata(hdev, led);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hid parsing failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < GT683R_LED_COUNT; i++) {\n\t\tname_sz = strlen(dev_name(&hdev->dev)) +\n\t\t\t\tstrlen(gt683r_panel_names[i]) + 3;\n\n\t\tname = devm_kzalloc(&hdev->dev, name_sz, GFP_KERNEL);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsnprintf(name, name_sz, \"%s::%s\",\n\t\t\t\tdev_name(&hdev->dev), gt683r_panel_names[i]);\n\t\tled->led_devs[i].name = name;\n\t\tled->led_devs[i].max_brightness = 1;\n\t\tled->led_devs[i].brightness_set = gt683r_brightness_set;\n\t\tled->led_devs[i].groups = gt683r_led_groups;\n\n\t\tret = led_classdev_register(&hdev->dev, &led->led_devs[i]);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"could not register led device\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\tfor (i = i - 1; i >= 0; i--)\n\t\tled_classdev_unregister(&led->led_devs[i]);\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void gt683r_led_remove(struct hid_device *hdev)\n{\n\tint i;\n\tstruct gt683r_led *led = hid_get_drvdata(hdev);\n\n\tfor (i = 0; i < GT683R_LED_COUNT; i++)\n\t\tled_classdev_unregister(&led->led_devs[i]);\n\tflush_work(&led->work);\n\thid_hw_stop(hdev);\n}\n\nstatic struct hid_driver gt683r_led_driver = {\n\t.probe = gt683r_led_probe,\n\t.remove = gt683r_led_remove,\n\t.name = \"gt683r_led\",\n\t.id_table = gt683r_led_id,\n};\n\nmodule_hid_driver(gt683r_led_driver);\n\nMODULE_AUTHOR(\"Janne Kanniainen\");\nMODULE_DESCRIPTION(\"MSI GT683R led driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}