{
  "module_name": "hid-rmi.c",
  "hash_id": "2d59b8388162ae8132c7777ce6a1c7f23f45d73745c5c94735939e406c159de1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-rmi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/rmi.h>\n#include \"hid-ids.h\"\n\n#define RMI_MOUSE_REPORT_ID\t\t0x01  \n#define RMI_WRITE_REPORT_ID\t\t0x09  \n#define RMI_READ_ADDR_REPORT_ID\t\t0x0a  \n#define RMI_READ_DATA_REPORT_ID\t\t0x0b  \n#define RMI_ATTN_REPORT_ID\t\t0x0c  \n#define RMI_SET_RMI_MODE_REPORT_ID\t0x0f  \n\n \n#define RMI_READ_REQUEST_PENDING\t0\n#define RMI_READ_DATA_PENDING\t\t1\n#define RMI_STARTED\t\t\t2\n\n \n#define RMI_DEVICE\t\t\tBIT(0)\n#define RMI_DEVICE_HAS_PHYS_BUTTONS\tBIT(1)\n#define RMI_DEVICE_OUTPUT_SET_REPORT\tBIT(2)\n\n \n#define RMI_F11_CTRL_REG_COUNT\t\t12\n\nenum rmi_mode_type {\n\tRMI_MODE_OFF\t\t\t= 0,\n\tRMI_MODE_ATTN_REPORTS\t\t= 1,\n\tRMI_MODE_NO_PACKED_ATTN_REPORTS\t= 2,\n};\n\n \nstruct rmi_data {\n\tstruct mutex page_mutex;\n\tint page;\n\tstruct rmi_transport_dev xport;\n\n\twait_queue_head_t wait;\n\n\tu8 *writeReport;\n\tu8 *readReport;\n\n\tu32 input_report_size;\n\tu32 output_report_size;\n\n\tunsigned long flags;\n\n\tstruct work_struct reset_work;\n\tstruct hid_device *hdev;\n\n\tunsigned long device_flags;\n\n\tstruct irq_domain *domain;\n\tint rmi_irq;\n};\n\n#define RMI_PAGE(addr) (((addr) >> 8) & 0xff)\n\nstatic int rmi_write_report(struct hid_device *hdev, u8 *report, int len);\n\n \nstatic int rmi_set_page(struct hid_device *hdev, u8 page)\n{\n\tstruct rmi_data *data = hid_get_drvdata(hdev);\n\tint retval;\n\n\tdata->writeReport[0] = RMI_WRITE_REPORT_ID;\n\tdata->writeReport[1] = 1;\n\tdata->writeReport[2] = 0xFF;\n\tdata->writeReport[4] = page;\n\n\tretval = rmi_write_report(hdev, data->writeReport,\n\t\t\tdata->output_report_size);\n\tif (retval != data->output_report_size) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s: set page failed: %d.\", __func__, retval);\n\t\treturn retval;\n\t}\n\n\tdata->page = page;\n\treturn 0;\n}\n\nstatic int rmi_set_mode(struct hid_device *hdev, u8 mode)\n{\n\tint ret;\n\tconst u8 txbuf[2] = {RMI_SET_RMI_MODE_REPORT_ID, mode};\n\tu8 *buf;\n\n\tbuf = kmemdup(txbuf, sizeof(txbuf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, RMI_SET_RMI_MODE_REPORT_ID, buf,\n\t\t\tsizeof(txbuf), HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\tkfree(buf);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"unable to set rmi mode to %d (%d)\\n\", mode,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_write_report(struct hid_device *hdev, u8 *report, int len)\n{\n\tstruct rmi_data *data = hid_get_drvdata(hdev);\n\tint ret;\n\n\tif (data->device_flags & RMI_DEVICE_OUTPUT_SET_REPORT) {\n\t\t \n\t\tret = hid_hw_raw_request(hdev, report[0], report,\n\t\t\t\tlen, HID_OUTPUT_REPORT, HID_REQ_SET_REPORT);\n\t} else {\n\t\tret = hid_hw_output_report(hdev, (void *)report, len);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to write hid report (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int rmi_hid_read_block(struct rmi_transport_dev *xport, u16 addr,\n\t\tvoid *buf, size_t len)\n{\n\tstruct rmi_data *data = container_of(xport, struct rmi_data, xport);\n\tstruct hid_device *hdev = data->hdev;\n\tint ret;\n\tint bytes_read;\n\tint bytes_needed;\n\tint retries;\n\tint read_input_count;\n\n\tmutex_lock(&data->page_mutex);\n\n\tif (RMI_PAGE(addr) != data->page) {\n\t\tret = rmi_set_page(hdev, RMI_PAGE(addr));\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\n\tfor (retries = 5; retries > 0; retries--) {\n\t\tdata->writeReport[0] = RMI_READ_ADDR_REPORT_ID;\n\t\tdata->writeReport[1] = 0;  \n\t\tdata->writeReport[2] = addr & 0xFF;\n\t\tdata->writeReport[3] = (addr >> 8) & 0xFF;\n\t\tdata->writeReport[4] = len  & 0xFF;\n\t\tdata->writeReport[5] = (len >> 8) & 0xFF;\n\n\t\tset_bit(RMI_READ_REQUEST_PENDING, &data->flags);\n\n\t\tret = rmi_write_report(hdev, data->writeReport,\n\t\t\t\t\t\tdata->output_report_size);\n\t\tif (ret != data->output_report_size) {\n\t\t\tdev_err(&hdev->dev,\n\t\t\t\t\"failed to write request output report (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbytes_read = 0;\n\t\tbytes_needed = len;\n\t\twhile (bytes_read < len) {\n\t\t\tif (!wait_event_timeout(data->wait,\n\t\t\t\ttest_bit(RMI_READ_DATA_PENDING, &data->flags),\n\t\t\t\t\tmsecs_to_jiffies(1000))) {\n\t\t\t\thid_warn(hdev, \"%s: timeout elapsed\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tread_input_count = data->readReport[1];\n\t\t\tmemcpy(buf + bytes_read, &data->readReport[2],\n\t\t\t\tmin(read_input_count, bytes_needed));\n\n\t\t\tbytes_read += read_input_count;\n\t\t\tbytes_needed -= read_input_count;\n\t\t\tclear_bit(RMI_READ_DATA_PENDING, &data->flags);\n\t\t}\n\n\t\tif (ret >= 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nexit:\n\tclear_bit(RMI_READ_REQUEST_PENDING, &data->flags);\n\tmutex_unlock(&data->page_mutex);\n\treturn ret;\n}\n\nstatic int rmi_hid_write_block(struct rmi_transport_dev *xport, u16 addr,\n\t\tconst void *buf, size_t len)\n{\n\tstruct rmi_data *data = container_of(xport, struct rmi_data, xport);\n\tstruct hid_device *hdev = data->hdev;\n\tint ret;\n\n\tmutex_lock(&data->page_mutex);\n\n\tif (RMI_PAGE(addr) != data->page) {\n\t\tret = rmi_set_page(hdev, RMI_PAGE(addr));\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\n\tdata->writeReport[0] = RMI_WRITE_REPORT_ID;\n\tdata->writeReport[1] = len;\n\tdata->writeReport[2] = addr & 0xFF;\n\tdata->writeReport[3] = (addr >> 8) & 0xFF;\n\tmemcpy(&data->writeReport[4], buf, len);\n\n\tret = rmi_write_report(hdev, data->writeReport,\n\t\t\t\t\tdata->output_report_size);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"failed to write request output report (%d)\\n\",\n\t\t\tret);\n\t\tgoto exit;\n\t}\n\tret = 0;\n\nexit:\n\tmutex_unlock(&data->page_mutex);\n\treturn ret;\n}\n\nstatic int rmi_reset_attn_mode(struct hid_device *hdev)\n{\n\tstruct rmi_data *data = hid_get_drvdata(hdev);\n\tstruct rmi_device *rmi_dev = data->xport.rmi_dev;\n\tint ret;\n\n\tret = rmi_set_mode(hdev, RMI_MODE_ATTN_REPORTS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_bit(RMI_STARTED, &data->flags))\n\t\tret = rmi_dev->driver->reset_handler(rmi_dev);\n\n\treturn ret;\n}\n\nstatic void rmi_reset_work(struct work_struct *work)\n{\n\tstruct rmi_data *hdata = container_of(work, struct rmi_data,\n\t\t\t\t\t\treset_work);\n\n\t \n\trmi_reset_attn_mode(hdata->hdev);\n}\n\nstatic int rmi_input_event(struct hid_device *hdev, u8 *data, int size)\n{\n\tstruct rmi_data *hdata = hid_get_drvdata(hdev);\n\tstruct rmi_device *rmi_dev = hdata->xport.rmi_dev;\n\tunsigned long flags;\n\n\tif (!(test_bit(RMI_STARTED, &hdata->flags)))\n\t\treturn 0;\n\n\tpm_wakeup_event(hdev->dev.parent, 0);\n\n\tlocal_irq_save(flags);\n\n\trmi_set_attn_data(rmi_dev, data[1], &data[2], size - 2);\n\n\tgeneric_handle_irq(hdata->rmi_irq);\n\n\tlocal_irq_restore(flags);\n\n\treturn 1;\n}\n\nstatic int rmi_read_data_event(struct hid_device *hdev, u8 *data, int size)\n{\n\tstruct rmi_data *hdata = hid_get_drvdata(hdev);\n\n\tif (!test_bit(RMI_READ_REQUEST_PENDING, &hdata->flags)) {\n\t\thid_dbg(hdev, \"no read request pending\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(hdata->readReport, data, min((u32)size, hdata->input_report_size));\n\tset_bit(RMI_READ_DATA_PENDING, &hdata->flags);\n\twake_up(&hdata->wait);\n\n\treturn 1;\n}\n\nstatic int rmi_check_sanity(struct hid_device *hdev, u8 *data, int size)\n{\n\tint valid_size = size;\n\t \n\n\twhile ((data[valid_size - 1] == 0xff) && valid_size > 0)\n\t\tvalid_size--;\n\n\treturn valid_size;\n}\n\nstatic int rmi_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct rmi_data *hdata = hid_get_drvdata(hdev);\n\n\tif (!(hdata->device_flags & RMI_DEVICE))\n\t\treturn 0;\n\n\tsize = rmi_check_sanity(hdev, data, size);\n\tif (size < 2)\n\t\treturn 0;\n\n\tswitch (data[0]) {\n\tcase RMI_READ_DATA_REPORT_ID:\n\t\treturn rmi_read_data_event(hdev, data, size);\n\tcase RMI_ATTN_REPORT_ID:\n\t\treturn rmi_input_event(hdev, data, size);\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_event(struct hid_device *hdev, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct rmi_data *data = hid_get_drvdata(hdev);\n\n\tif ((data->device_flags & RMI_DEVICE) &&\n\t    (field->application == HID_GD_POINTER ||\n\t    field->application == HID_GD_MOUSE)) {\n\t\tif (data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS) {\n\t\t\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON)\n\t\t\t\treturn 0;\n\n\t\t\tif ((usage->hid == HID_GD_X || usage->hid == HID_GD_Y)\n\t\t\t    && !value)\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tschedule_work(&data->reset_work);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void rmi_report(struct hid_device *hid, struct hid_report *report)\n{\n\tstruct hid_field *field = report->field[0];\n\n\tif (!(hid->claimed & HID_CLAIMED_INPUT))\n\t\treturn;\n\n\tswitch (report->id) {\n\tcase RMI_READ_DATA_REPORT_ID:\n\tcase RMI_ATTN_REPORT_ID:\n\t\treturn;\n\t}\n\n\tif (field && field->hidinput && field->hidinput->input)\n\t\tinput_sync(field->hidinput->input);\n}\n\n#ifdef CONFIG_PM\nstatic int rmi_suspend(struct hid_device *hdev, pm_message_t message)\n{\n\tstruct rmi_data *data = hid_get_drvdata(hdev);\n\tstruct rmi_device *rmi_dev = data->xport.rmi_dev;\n\tint ret;\n\n\tif (!(data->device_flags & RMI_DEVICE))\n\t\treturn 0;\n\n\tret = rmi_driver_suspend(rmi_dev, false);\n\tif (ret) {\n\t\thid_warn(hdev, \"Failed to suspend device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_post_resume(struct hid_device *hdev)\n{\n\tstruct rmi_data *data = hid_get_drvdata(hdev);\n\tstruct rmi_device *rmi_dev = data->xport.rmi_dev;\n\tint ret;\n\n\tif (!(data->device_flags & RMI_DEVICE))\n\t\treturn 0;\n\n\t \n\tret = hid_hw_open(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rmi_reset_attn_mode(hdev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = rmi_driver_resume(rmi_dev, false);\n\tif (ret) {\n\t\thid_warn(hdev, \"Failed to resume device: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\thid_hw_close(hdev);\n\treturn ret;\n}\n#endif  \n\nstatic int rmi_hid_reset(struct rmi_transport_dev *xport, u16 reset_addr)\n{\n\tstruct rmi_data *data = container_of(xport, struct rmi_data, xport);\n\tstruct hid_device *hdev = data->hdev;\n\n\treturn rmi_reset_attn_mode(hdev);\n}\n\nstatic int rmi_input_configured(struct hid_device *hdev, struct hid_input *hi)\n{\n\tstruct rmi_data *data = hid_get_drvdata(hdev);\n\tstruct input_dev *input = hi->input;\n\tint ret = 0;\n\n\tif (!(data->device_flags & RMI_DEVICE))\n\t\treturn 0;\n\n\tdata->xport.input = input;\n\n\thid_dbg(hdev, \"Opening low level driver\\n\");\n\tret = hid_hw_open(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\thid_device_io_start(hdev);\n\n\tret = rmi_set_mode(hdev, RMI_MODE_ATTN_REPORTS);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to set rmi mode\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = rmi_set_page(hdev, 0);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to set page select to 0.\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = rmi_register_transport_device(&data->xport);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to register transport driver\\n\");\n\t\tgoto exit;\n\t}\n\n\tset_bit(RMI_STARTED, &data->flags);\n\nexit:\n\thid_device_io_stop(hdev);\n\thid_hw_close(hdev);\n\treturn ret;\n}\n\nstatic int rmi_input_mapping(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tstruct rmi_data *data = hid_get_drvdata(hdev);\n\n\t \n\tif (data->device_flags & RMI_DEVICE) {\n\t\tif ((data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS) &&\n\t\t    ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON))\n\t\t\treturn 0;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_check_valid_report_id(struct hid_device *hdev, unsigned type,\n\t\tunsigned id, struct hid_report **report)\n{\n\tint i;\n\n\t*report = hdev->report_enum[type].report_id_hash[id];\n\tif (*report) {\n\t\tfor (i = 0; i < (*report)->maxfield; i++) {\n\t\t\tunsigned app = (*report)->field[i]->application;\n\t\t\tif ((app & HID_USAGE_PAGE) >= HID_UP_MSVENDOR)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct rmi_device_platform_data rmi_hid_pdata = {\n\t.sensor_pdata = {\n\t\t.sensor_type = rmi_sensor_touchpad,\n\t\t.axis_align.flip_y = true,\n\t\t.dribble = RMI_REG_STATE_ON,\n\t\t.palm_detect = RMI_REG_STATE_OFF,\n\t},\n};\n\nstatic const struct rmi_transport_ops hid_rmi_ops = {\n\t.write_block\t= rmi_hid_write_block,\n\t.read_block\t= rmi_hid_read_block,\n\t.reset\t\t= rmi_hid_reset,\n};\n\nstatic void rmi_irq_teardown(void *data)\n{\n\tstruct rmi_data *hdata = data;\n\tstruct irq_domain *domain = hdata->domain;\n\n\tif (!domain)\n\t\treturn;\n\n\tirq_dispose_mapping(irq_find_mapping(domain, 0));\n\n\tirq_domain_remove(domain);\n\thdata->domain = NULL;\n\thdata->rmi_irq = 0;\n}\n\nstatic int rmi_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t       irq_hw_number_t hw_irq_num)\n{\n\tirq_set_chip_and_handler(virq, &dummy_irq_chip, handle_simple_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops rmi_irq_ops = {\n\t.map = rmi_irq_map,\n};\n\nstatic int rmi_setup_irq_domain(struct hid_device *hdev)\n{\n\tstruct rmi_data *hdata = hid_get_drvdata(hdev);\n\tint ret;\n\n\thdata->domain = irq_domain_create_linear(hdev->dev.fwnode, 1,\n\t\t\t\t\t\t &rmi_irq_ops, hdata);\n\tif (!hdata->domain)\n\t\treturn -ENOMEM;\n\n\tret = devm_add_action_or_reset(&hdev->dev, &rmi_irq_teardown, hdata);\n\tif (ret)\n\t\treturn ret;\n\n\thdata->rmi_irq = irq_create_mapping(hdata->domain, 0);\n\tif (hdata->rmi_irq <= 0) {\n\t\thid_err(hdev, \"Can't allocate an IRQ\\n\");\n\t\treturn hdata->rmi_irq < 0 ? hdata->rmi_irq : -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmi_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct rmi_data *data = NULL;\n\tint ret;\n\tsize_t alloc_size;\n\tstruct hid_report *input_report;\n\tstruct hid_report *output_report;\n\tstruct hid_report *feature_report;\n\n\tdata = devm_kzalloc(&hdev->dev, sizeof(struct rmi_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&data->reset_work, rmi_reset_work);\n\tdata->hdev = hdev;\n\n\thid_set_drvdata(hdev, data);\n\n\thdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\n\thdev->quirks |= HID_QUIRK_NO_INPUT_SYNC;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (id->driver_data)\n\t\tdata->device_flags = id->driver_data;\n\n\t \n\tif (!rmi_check_valid_report_id(hdev, HID_FEATURE_REPORT,\n\t    RMI_SET_RMI_MODE_REPORT_ID, &feature_report)) {\n\t\thid_dbg(hdev, \"device does not have set mode feature report\\n\");\n\t\tgoto start;\n\t}\n\n\tif (!rmi_check_valid_report_id(hdev, HID_INPUT_REPORT,\n\t    RMI_ATTN_REPORT_ID, &input_report)) {\n\t\thid_dbg(hdev, \"device does not have attention input report\\n\");\n\t\tgoto start;\n\t}\n\n\tdata->input_report_size = hid_report_len(input_report);\n\n\tif (!rmi_check_valid_report_id(hdev, HID_OUTPUT_REPORT,\n\t    RMI_WRITE_REPORT_ID, &output_report)) {\n\t\thid_dbg(hdev,\n\t\t\t\"device does not have rmi write output report\\n\");\n\t\tgoto start;\n\t}\n\n\tdata->output_report_size = hid_report_len(output_report);\n\n\tdata->device_flags |= RMI_DEVICE;\n\talloc_size = data->output_report_size + data->input_report_size;\n\n\tdata->writeReport = devm_kzalloc(&hdev->dev, alloc_size, GFP_KERNEL);\n\tif (!data->writeReport) {\n\t\thid_err(hdev, \"failed to allocate buffer for HID reports\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->readReport = data->writeReport + data->output_report_size;\n\n\tinit_waitqueue_head(&data->wait);\n\n\tmutex_init(&data->page_mutex);\n\n\tret = rmi_setup_irq_domain(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"failed to allocate IRQ domain\\n\");\n\t\treturn ret;\n\t}\n\n\tif (data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS)\n\t\trmi_hid_pdata.gpio_data.disable = true;\n\n\tdata->xport.dev = hdev->dev.parent;\n\tdata->xport.pdata = rmi_hid_pdata;\n\tdata->xport.pdata.irq = data->rmi_irq;\n\tdata->xport.proto_name = \"hid\";\n\tdata->xport.ops = &hid_rmi_ops;\n\nstart:\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rmi_remove(struct hid_device *hdev)\n{\n\tstruct rmi_data *hdata = hid_get_drvdata(hdev);\n\n\tif ((hdata->device_flags & RMI_DEVICE)\n\t    && test_bit(RMI_STARTED, &hdata->flags)) {\n\t\tclear_bit(RMI_STARTED, &hdata->flags);\n\t\tcancel_work_sync(&hdata->reset_work);\n\t\trmi_unregister_transport_device(&hdata->xport);\n\t}\n\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id rmi_id[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_RAZER, USB_DEVICE_ID_RAZER_BLADE_14),\n\t\t.driver_data = RMI_DEVICE_HAS_PHYS_BUTTONS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_COVER) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PRIMAX, USB_DEVICE_ID_PRIMAX_REZEL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_ACER_SWITCH5),\n\t\t.driver_data = RMI_DEVICE_OUTPUT_SET_REPORT },\n\t{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_RMI, HID_ANY_ID, HID_ANY_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, rmi_id);\n\nstatic struct hid_driver rmi_driver = {\n\t.name = \"hid-rmi\",\n\t.id_table\t\t= rmi_id,\n\t.probe\t\t\t= rmi_probe,\n\t.remove\t\t\t= rmi_remove,\n\t.event\t\t\t= rmi_event,\n\t.raw_event\t\t= rmi_raw_event,\n\t.report\t\t\t= rmi_report,\n\t.input_mapping\t\t= rmi_input_mapping,\n\t.input_configured\t= rmi_input_configured,\n#ifdef CONFIG_PM\n\t.suspend\t\t= rmi_suspend,\n\t.resume\t\t\t= rmi_post_resume,\n\t.reset_resume\t\t= rmi_post_resume,\n#endif\n};\n\nmodule_hid_driver(rmi_driver);\n\nMODULE_AUTHOR(\"Andrew Duggan <aduggan@synaptics.com>\");\nMODULE_DESCRIPTION(\"RMI HID driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}