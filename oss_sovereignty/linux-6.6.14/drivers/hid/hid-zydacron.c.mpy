{
  "module_name": "hid-zydacron.c",
  "hash_id": "5da2b34d34b5afe0543b4c11dc7e51e2fe996aab84e4c536c305b1919c358655",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-zydacron.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\nstruct zc_device {\n\tstruct input_dev\t*input_ep81;\n\tunsigned short\t\tlast_key[4];\n};\n\n\n \nstatic __u8 *zc_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\tunsigned int *rsize)\n{\n\tif (*rsize >= 253 &&\n\t\trdesc[0x96] == 0xbc && rdesc[0x97] == 0xff &&\n\t\trdesc[0xca] == 0xbc && rdesc[0xcb] == 0xff &&\n\t\trdesc[0xe1] == 0xbc && rdesc[0xe2] == 0xff) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up zydacron remote control report descriptor\\n\");\n\t\t\trdesc[0x96] = rdesc[0xca] = rdesc[0xe1] = 0x0c;\n\t\t\trdesc[0x97] = rdesc[0xcb] = rdesc[0xe2] = 0x00;\n\t\t}\n\treturn rdesc;\n}\n\n#define zc_map_key_clear(c) \\\n\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, (c))\n\nstatic int zc_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\tstruct hid_field *field, struct hid_usage *usage,\n\tunsigned long **bit, int *max)\n{\n\tint i;\n\tstruct zc_device *zc = hid_get_drvdata(hdev);\n\tzc->input_ep81 = hi->input;\n\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\n\t\treturn 0;\n\n\tdbg_hid(\"zynacron input mapping event [0x%x]\\n\",\n\t\tusage->hid & HID_USAGE);\n\n\tswitch (usage->hid & HID_USAGE) {\n\t \n\tcase 0x10:\n\t\tzc_map_key_clear(KEY_MODE);\n\t\tbreak;\n\tcase 0x30:\n\t\tzc_map_key_clear(KEY_SCREEN);\n\t\tbreak;\n\tcase 0x70:\n\t\tzc_map_key_clear(KEY_INFO);\n\t\tbreak;\n\t \n\tcase 0x04:\n\t\tzc_map_key_clear(KEY_RADIO);\n\t\tbreak;\n\t \n\tcase 0x0d:\n\t\tzc_map_key_clear(KEY_PVR);\n\t\tbreak;\n\tcase 0x25:\n\t\tzc_map_key_clear(KEY_TV);\n\t\tbreak;\n\tcase 0x47:\n\t\tzc_map_key_clear(KEY_AUDIO);\n\t\tbreak;\n\tcase 0x49:\n\t\tzc_map_key_clear(KEY_AUX);\n\t\tbreak;\n\tcase 0x4a:\n\t\tzc_map_key_clear(KEY_VIDEO);\n\t\tbreak;\n\tcase 0x48:\n\t\tzc_map_key_clear(KEY_DVD);\n\t\tbreak;\n\tcase 0x24:\n\t\tzc_map_key_clear(KEY_MENU);\n\t\tbreak;\n\tcase 0x32:\n\t\tzc_map_key_clear(KEY_TEXT);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tzc->last_key[i] = 0;\n\n\treturn 1;\n}\n\nstatic int zc_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t u8 *data, int size)\n{\n\tstruct zc_device *zc = hid_get_drvdata(hdev);\n\tint ret = 0;\n\tunsigned key;\n\tunsigned short index;\n\n\tif (report->id == data[0]) {\n\n\t\t \n\t\tfor (index = 0; index < 4; index++) {\n\t\t\tkey = zc->last_key[index];\n\t\t\tif (key) {\n\t\t\t\tinput_event(zc->input_ep81, EV_KEY, key, 0);\n\t\t\t\tzc->last_key[index] = 0;\n\t\t\t}\n\t\t}\n\n\t\tkey = 0;\n\t\tswitch (report->id) {\n\t\tcase 0x02:\n\t\tcase 0x03:\n\t\t\tswitch (data[1]) {\n\t\t\tcase 0x10:\n\t\t\t\tkey = KEY_MODE;\n\t\t\t\tindex = 0;\n\t\t\t\tbreak;\n\t\t\tcase 0x30:\n\t\t\t\tkey = KEY_SCREEN;\n\t\t\t\tindex = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0x70:\n\t\t\t\tkey = KEY_INFO;\n\t\t\t\tindex = 2;\n\t\t\t\tbreak;\n\t\t\tcase 0x04:\n\t\t\t\tkey = KEY_RADIO;\n\t\t\t\tindex = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (key) {\n\t\t\t\tinput_event(zc->input_ep81, EV_KEY, key, 1);\n\t\t\t\tzc->last_key[index] = key;\n\t\t\t}\n\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int zc_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct zc_device *zc;\n\n\tzc = devm_kzalloc(&hdev->dev, sizeof(*zc), GFP_KERNEL);\n\tif (zc == NULL) {\n\t\thid_err(hdev, \"can't alloc descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thid_set_drvdata(hdev, zc);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id zc_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ZYDACRON, USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, zc_devices);\n\nstatic struct hid_driver zc_driver = {\n\t.name = \"zydacron\",\n\t.id_table = zc_devices,\n\t.report_fixup = zc_report_fixup,\n\t.input_mapping = zc_input_mapping,\n\t.raw_event = zc_raw_event,\n\t.probe = zc_probe,\n};\nmodule_hid_driver(zc_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}