{
  "module_name": "hid-axff.c",
  "hash_id": "8f311a329dd8659ea6bea04348de8e874bf994a0c06dc4dbcc778e08c90a56f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-axff.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#ifdef CONFIG_HID_ACRUX_FF\n\nstruct axff_device {\n\tstruct hid_report *report;\n};\n\nstatic int axff_play(struct input_dev *dev, void *data, struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct axff_device *axff = data;\n\tstruct hid_report *report = axff->report;\n\tint field_count = 0;\n\tint left, right;\n\tint i, j;\n\n\tleft = effect->u.rumble.strong_magnitude;\n\tright = effect->u.rumble.weak_magnitude;\n\n\tdbg_hid(\"called with 0x%04x 0x%04x\", left, right);\n\n\tleft = left * 0xff / 0xffff;\n\tright = right * 0xff / 0xffff;\n\n\tfor (i = 0; i < report->maxfield; i++) {\n\t\tfor (j = 0; j < report->field[i]->report_count; j++) {\n\t\t\treport->field[i]->value[j] =\n\t\t\t\tfield_count % 2 ? right : left;\n\t\t\tfield_count++;\n\t\t}\n\t}\n\n\tdbg_hid(\"running with 0x%02x 0x%02x\", left, right);\n\thid_hw_request(hid, axff->report, HID_REQ_SET_REPORT);\n\n\treturn 0;\n}\n\nstatic int axff_init(struct hid_device *hid)\n{\n\tstruct axff_device *axff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput;\n\tstruct list_head *report_list =&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev;\n\tint field_count = 0;\n\tint i, j;\n\tint error;\n\n\tif (list_empty(&hid->inputs)) {\n\t\thid_err(hid, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_first_entry(&hid->inputs, struct hid_input, list);\n\tdev = hidinput->input;\n\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tfor (i = 0; i < report->maxfield; i++) {\n\t\tfor (j = 0; j < report->field[i]->report_count; j++) {\n\t\t\treport->field[i]->value[j] = 0x00;\n\t\t\tfield_count++;\n\t\t}\n\t}\n\n\tif (field_count < 4 && hid->product != 0xf705) {\n\t\thid_err(hid, \"not enough fields in the report: %d\\n\",\n\t\t\tfield_count);\n\t\treturn -ENODEV;\n\t}\n\n\taxff = kzalloc(sizeof(struct axff_device), GFP_KERNEL);\n\tif (!axff)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\n\terror = input_ff_create_memless(dev, axff, axff_play);\n\tif (error)\n\t\tgoto err_free_mem;\n\n\taxff->report = report;\n\thid_hw_request(hid, axff->report, HID_REQ_SET_REPORT);\n\n\thid_info(hid, \"Force Feedback for ACRUX game controllers by Sergei Kolzun <x0r@dv-life.ru>\\n\");\n\n\treturn 0;\n\nerr_free_mem:\n\tkfree(axff);\n\treturn error;\n}\n#else\nstatic inline int axff_init(struct hid_device *hid)\n{\n\treturn 0;\n}\n#endif\n\nstatic int ax_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint error;\n\n\tdev_dbg(&hdev->dev, \"ACRUX HID hardware probe...\\n\");\n\n\terror = hid_parse(hdev);\n\tif (error) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\tif (error) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = axff_init(hdev);\n\tif (error) {\n\t\t \n\t\thid_warn(hdev,\n\t\t\t \"Failed to enable force feedback support, error: %d\\n\",\n\t\t\t error);\n\t}\n\n\t \n\terror = hid_hw_open(hdev);\n\tif (error) {\n\t\tdev_err(&hdev->dev, \"hw open failed\\n\");\n\t\thid_hw_stop(hdev);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic void ax_remove(struct hid_device *hdev)\n{\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic const struct hid_device_id ax_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0x0802), },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0xf705), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ax_devices);\n\nstatic struct hid_driver ax_driver = {\n\t.name\t\t= \"acrux\",\n\t.id_table\t= ax_devices,\n\t.probe\t\t= ax_probe,\n\t.remove\t\t= ax_remove,\n};\nmodule_hid_driver(ax_driver);\n\nMODULE_AUTHOR(\"Sergei Kolzun\");\nMODULE_DESCRIPTION(\"Force feedback support for ACRUX game controllers\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}