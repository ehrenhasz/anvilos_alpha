{
  "module_name": "hid-appleir.c",
  "hash_id": "d7a0d3663d77680edfc714ebd4508ecf5e85766674900094395e1d46fbfba764",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-appleir.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include \"hid-ids.h\"\n\nMODULE_AUTHOR(\"James McKenzie\");\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@redhat.com>\");\nMODULE_DESCRIPTION(\"HID Apple IR remote controls\");\nMODULE_LICENSE(\"GPL\");\n\n#define KEY_MASK\t\t0x0F\n#define TWO_PACKETS_MASK\t0x40\n\n \n\n \n\n \n\n \n\n \n\nstatic const unsigned short appleir_key_table[] = {\n\tKEY_RESERVED,\n\tKEY_MENU,\n\tKEY_PLAYPAUSE,\n\tKEY_FORWARD,\n\tKEY_BACK,\n\tKEY_VOLUMEUP,\n\tKEY_VOLUMEDOWN,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_ENTER,\n\tKEY_PLAYPAUSE,\n\tKEY_RESERVED,\n};\n\nstruct appleir {\n\tstruct input_dev *input_dev;\n\tstruct hid_device *hid;\n\tunsigned short keymap[ARRAY_SIZE(appleir_key_table)];\n\tstruct timer_list key_up_timer;\t \n\tspinlock_t lock;\t\t \n\tint current_key;\t\t \n\tint prev_key_idx;\t\t \n};\n\nstatic int get_key(int data)\n{\n\t \n\tint key = (data >> 1) & KEY_MASK;\n\n\tif ((data & TWO_PACKETS_MASK))\n\t\t \n\t\tkey = -key;\n\n\treturn key;\n}\n\nstatic void key_up(struct hid_device *hid, struct appleir *appleir, int key)\n{\n\tinput_report_key(appleir->input_dev, key, 0);\n\tinput_sync(appleir->input_dev);\n}\n\nstatic void key_down(struct hid_device *hid, struct appleir *appleir, int key)\n{\n\tinput_report_key(appleir->input_dev, key, 1);\n\tinput_sync(appleir->input_dev);\n}\n\nstatic void battery_flat(struct appleir *appleir)\n{\n\tdev_err(&appleir->input_dev->dev, \"possible flat battery?\\n\");\n}\n\nstatic void key_up_tick(struct timer_list *t)\n{\n\tstruct appleir *appleir = from_timer(appleir, t, key_up_timer);\n\tstruct hid_device *hid = appleir->hid;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&appleir->lock, flags);\n\tif (appleir->current_key) {\n\t\tkey_up(hid, appleir, appleir->current_key);\n\t\tappleir->current_key = 0;\n\t}\n\tspin_unlock_irqrestore(&appleir->lock, flags);\n}\n\nstatic int appleir_raw_event(struct hid_device *hid, struct hid_report *report,\n\t u8 *data, int len)\n{\n\tstruct appleir *appleir = hid_get_drvdata(hid);\n\tstatic const u8 keydown[] = { 0x25, 0x87, 0xee };\n\tstatic const u8 keyrepeat[] = { 0x26, };\n\tstatic const u8 flatbattery[] = { 0x25, 0x87, 0xe0 };\n\tunsigned long flags;\n\n\tif (len != 5)\n\t\tgoto out;\n\n\tif (!memcmp(data, keydown, sizeof(keydown))) {\n\t\tint index;\n\n\t\tspin_lock_irqsave(&appleir->lock, flags);\n\t\t \n\t\tif (appleir->current_key)\n\t\t\tkey_up(hid, appleir, appleir->current_key);\n\n\t\t \n\t\tif (appleir->prev_key_idx > 0)\n\t\t\tindex = appleir->prev_key_idx;\n\t\telse\n\t\t\tindex = get_key(data[4]);\n\n\t\tif (index >= 0) {\n\t\t\tappleir->current_key = appleir->keymap[index];\n\n\t\t\tkey_down(hid, appleir, appleir->current_key);\n\t\t\t \n\t\t\tmod_timer(&appleir->key_up_timer, jiffies + HZ / 8);\n\t\t\tappleir->prev_key_idx = 0;\n\t\t} else\n\t\t\t \n\t\t\tappleir->prev_key_idx = -index;\n\t\tspin_unlock_irqrestore(&appleir->lock, flags);\n\t\tgoto out;\n\t}\n\n\tappleir->prev_key_idx = 0;\n\n\tif (!memcmp(data, keyrepeat, sizeof(keyrepeat))) {\n\t\tkey_down(hid, appleir, appleir->current_key);\n\t\t \n\t\tmod_timer(&appleir->key_up_timer, jiffies + HZ / 8);\n\t\tgoto out;\n\t}\n\n\tif (!memcmp(data, flatbattery, sizeof(flatbattery))) {\n\t\tbattery_flat(appleir);\n\t\t \n\t}\n\nout:\n\t \n\treturn 0;\n}\n\nstatic int appleir_input_configured(struct hid_device *hid,\n\t\tstruct hid_input *hidinput)\n{\n\tstruct input_dev *input_dev = hidinput->input;\n\tstruct appleir *appleir = hid_get_drvdata(hid);\n\tint i;\n\n\tappleir->input_dev = input_dev;\n\n\tinput_dev->keycode = appleir->keymap;\n\tinput_dev->keycodesize = sizeof(unsigned short);\n\tinput_dev->keycodemax = ARRAY_SIZE(appleir->keymap);\n\n\tinput_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_REP);\n\n\tmemcpy(appleir->keymap, appleir_key_table, sizeof(appleir->keymap));\n\tfor (i = 0; i < ARRAY_SIZE(appleir_key_table); i++)\n\t\tset_bit(appleir->keymap[i], input_dev->keybit);\n\tclear_bit(KEY_RESERVED, input_dev->keybit);\n\n\treturn 0;\n}\n\nstatic int appleir_input_mapping(struct hid_device *hid,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\treturn -1;\n}\n\nstatic int appleir_probe(struct hid_device *hid, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct appleir *appleir;\n\n\tappleir = devm_kzalloc(&hid->dev, sizeof(struct appleir), GFP_KERNEL);\n\tif (!appleir)\n\t\treturn -ENOMEM;\n\n\tappleir->hid = hid;\n\n\t \n\thid->quirks |= HID_QUIRK_HIDINPUT_FORCE;\n\n\tspin_lock_init(&appleir->lock);\n\ttimer_setup(&appleir->key_up_timer, key_up_tick, 0);\n\n\thid_set_drvdata(hid, appleir);\n\n\tret = hid_parse(hid);\n\tif (ret) {\n\t\thid_err(hid, \"parse failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = hid_hw_start(hid, HID_CONNECT_DEFAULT | HID_CONNECT_HIDDEV_FORCE);\n\tif (ret) {\n\t\thid_err(hid, \"hw start failed\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdevm_kfree(&hid->dev, appleir);\n\treturn ret;\n}\n\nstatic void appleir_remove(struct hid_device *hid)\n{\n\tstruct appleir *appleir = hid_get_drvdata(hid);\n\thid_hw_stop(hid);\n\tdel_timer_sync(&appleir->key_up_timer);\n}\n\nstatic const struct hid_device_id appleir_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL3) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL4) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL5) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, appleir_devices);\n\nstatic struct hid_driver appleir_driver = {\n\t.name = \"appleir\",\n\t.id_table = appleir_devices,\n\t.raw_event = appleir_raw_event,\n\t.input_configured = appleir_input_configured,\n\t.probe = appleir_probe,\n\t.remove = appleir_remove,\n\t.input_mapping = appleir_input_mapping,\n};\nmodule_hid_driver(appleir_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}