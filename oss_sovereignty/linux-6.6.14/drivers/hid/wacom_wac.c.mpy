{
  "module_name": "wacom_wac.c",
  "hash_id": "5125f23ef8af7f2c7239952ea401d77a4dbad0c9d35dc61a013f596528f4df2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/wacom_wac.c",
  "human_readable_source": "\n \n\n#include \"wacom_wac.h\"\n#include \"wacom.h\"\n#include <linux/input/mt.h>\n#include <linux/jiffies.h>\n\n \n#define WACOM_PL_RES\t\t20\n#define WACOM_PENPRTN_RES\t40\n#define WACOM_VOLITO_RES\t50\n#define WACOM_GRAPHIRE_RES\t80\n#define WACOM_INTUOS_RES\t100\n#define WACOM_INTUOS3_RES\t200\n\n \n#define WACOM_DTU_OFFSET\t200\n#define WACOM_CINTIQ_OFFSET\t400\n\n \n#define WACOM_CONTACT_AREA_SCALE 2607\n\nstatic bool touch_arbitration = 1;\nmodule_param(touch_arbitration, bool, 0644);\nMODULE_PARM_DESC(touch_arbitration, \" on (Y) off (N)\");\n\nstatic void wacom_report_numbered_buttons(struct input_dev *input_dev,\n\t\t\t\tint button_count, int mask);\n\nstatic int wacom_numbered_button_to_key(int n);\n\nstatic void wacom_update_led(struct wacom *wacom, int button_count, int mask,\n\t\t\t     int group);\n\nstatic void wacom_force_proxout(struct wacom_wac *wacom_wac)\n{\n\tstruct input_dev *input = wacom_wac->pen_input;\n\n\twacom_wac->shared->stylus_in_proximity = 0;\n\n\tinput_report_key(input, BTN_TOUCH, 0);\n\tinput_report_key(input, BTN_STYLUS, 0);\n\tinput_report_key(input, BTN_STYLUS2, 0);\n\tinput_report_key(input, BTN_STYLUS3, 0);\n\tinput_report_key(input, wacom_wac->tool[0], 0);\n\tif (wacom_wac->serial[0]) {\n\t\tinput_report_abs(input, ABS_MISC, 0);\n\t}\n\tinput_report_abs(input, ABS_PRESSURE, 0);\n\n\twacom_wac->tool[0] = 0;\n\twacom_wac->id[0] = 0;\n\twacom_wac->serial[0] = 0;\n\n\tinput_sync(input);\n}\n\nvoid wacom_idleprox_timeout(struct timer_list *list)\n{\n\tstruct wacom *wacom = from_timer(wacom, list, idleprox_timer);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\n\tif (!wacom_wac->hid_data.sense_state) {\n\t\treturn;\n\t}\n\n\thid_warn(wacom->hdev, \"%s: tool appears to be hung in-prox. forcing it out.\\n\", __func__);\n\twacom_force_proxout(wacom_wac);\n}\n\n \nstatic unsigned short batcap_gr[8] = { 1, 15, 25, 35, 50, 70, 100, 100 };\n\n \nstatic unsigned short batcap_i4[8] = { 1, 15, 30, 45, 60, 70, 85, 100 };\n\nstatic void __wacom_notify_battery(struct wacom_battery *battery,\n\t\t\t\t   int bat_status, int bat_capacity,\n\t\t\t\t   bool bat_charging, bool bat_connected,\n\t\t\t\t   bool ps_connected)\n{\n\tbool changed = battery->bat_status       != bat_status    ||\n\t\t       battery->battery_capacity != bat_capacity  ||\n\t\t       battery->bat_charging     != bat_charging  ||\n\t\t       battery->bat_connected    != bat_connected ||\n\t\t       battery->ps_connected     != ps_connected;\n\n\tif (changed) {\n\t\tbattery->bat_status = bat_status;\n\t\tbattery->battery_capacity = bat_capacity;\n\t\tbattery->bat_charging = bat_charging;\n\t\tbattery->bat_connected = bat_connected;\n\t\tbattery->ps_connected = ps_connected;\n\n\t\tif (battery->battery)\n\t\t\tpower_supply_changed(battery->battery);\n\t}\n}\n\nstatic void wacom_notify_battery(struct wacom_wac *wacom_wac,\n\tint bat_status, int bat_capacity, bool bat_charging,\n\tbool bat_connected, bool ps_connected)\n{\n\tstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\n\tbool bat_initialized = wacom->battery.battery;\n\tbool has_quirk = wacom_wac->features.quirks & WACOM_QUIRK_BATTERY;\n\n\tif (bat_initialized != has_quirk)\n\t\twacom_schedule_work(wacom_wac, WACOM_WORKER_BATTERY);\n\n\t__wacom_notify_battery(&wacom->battery, bat_status, bat_capacity,\n\t\t\t       bat_charging, bat_connected, ps_connected);\n}\n\nstatic int wacom_penpartner_irq(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\n\tswitch (data[0]) {\n\tcase 1:\n\t\tif (data[5] & 0x80) {\n\t\t\twacom->tool[0] = (data[5] & 0x20) ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\n\t\t\twacom->id[0] = (data[5] & 0x20) ? ERASER_DEVICE_ID : STYLUS_DEVICE_ID;\n\t\t\tinput_report_key(input, wacom->tool[0], 1);\n\t\t\tinput_report_abs(input, ABS_MISC, wacom->id[0]);  \n\t\t\tinput_report_abs(input, ABS_X, get_unaligned_le16(&data[1]));\n\t\t\tinput_report_abs(input, ABS_Y, get_unaligned_le16(&data[3]));\n\t\t\tinput_report_abs(input, ABS_PRESSURE, (signed char)data[6] + 127);\n\t\t\tinput_report_key(input, BTN_TOUCH, ((signed char)data[6] > -127));\n\t\t\tinput_report_key(input, BTN_STYLUS, (data[5] & 0x40));\n\t\t} else {\n\t\t\tinput_report_key(input, wacom->tool[0], 0);\n\t\t\tinput_report_abs(input, ABS_MISC, 0);  \n\t\t\tinput_report_abs(input, ABS_PRESSURE, -1);\n\t\t\tinput_report_key(input, BTN_TOUCH, 0);\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tinput_report_key(input, BTN_TOOL_PEN, 1);\n\t\tinput_report_abs(input, ABS_MISC, STYLUS_DEVICE_ID);  \n\t\tinput_report_abs(input, ABS_X, get_unaligned_le16(&data[1]));\n\t\tinput_report_abs(input, ABS_Y, get_unaligned_le16(&data[3]));\n\t\tinput_report_abs(input, ABS_PRESSURE, (signed char)data[6] + 127);\n\t\tinput_report_key(input, BTN_TOUCH, ((signed char)data[6] > -80) && !(data[5] & 0x20));\n\t\tinput_report_key(input, BTN_STYLUS, (data[5] & 0x40));\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(input->dev.parent,\n\t\t\t\"%s: received unknown report #%d\\n\", __func__, data[0]);\n\t\treturn 0;\n        }\n\n\treturn 1;\n}\n\nstatic int wacom_pl_irq(struct wacom_wac *wacom)\n{\n\tstruct wacom_features *features = &wacom->features;\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\tint prox, pressure;\n\n\tif (data[0] != WACOM_REPORT_PENABLED) {\n\t\tdev_dbg(input->dev.parent,\n\t\t\t\"%s: received unknown report #%d\\n\", __func__, data[0]);\n\t\treturn 0;\n\t}\n\n\tprox = data[1] & 0x40;\n\n\tif (!wacom->id[0]) {\n\t\tif ((data[0] & 0x10) || (data[4] & 0x20)) {\n\t\t\twacom->tool[0] = BTN_TOOL_RUBBER;\n\t\t\twacom->id[0] = ERASER_DEVICE_ID;\n\t\t}\n\t\telse {\n\t\t\twacom->tool[0] = BTN_TOOL_PEN;\n\t\t\twacom->id[0] = STYLUS_DEVICE_ID;\n\t\t}\n\t}\n\n\t \n\tif (wacom->tool[0] == BTN_TOOL_RUBBER && !(data[4] & 0x20)) {\n\t\tinput_report_key(input, BTN_TOOL_RUBBER, 0);\n\t\tinput_report_abs(input, ABS_MISC, 0);\n\t\tinput_sync(input);\n\t\twacom->tool[0] = BTN_TOOL_PEN;\n\t\twacom->id[0] = STYLUS_DEVICE_ID;\n\t}\n\n\tif (prox) {\n\t\tpressure = (signed char)((data[7] << 1) | ((data[4] >> 2) & 1));\n\t\tif (features->pressure_max > 255)\n\t\t\tpressure = (pressure << 1) | ((data[4] >> 6) & 1);\n\t\tpressure += (features->pressure_max + 1) / 2;\n\n\t\tinput_report_abs(input, ABS_X, data[3] | (data[2] << 7) | ((data[1] & 0x03) << 14));\n\t\tinput_report_abs(input, ABS_Y, data[6] | (data[5] << 7) | ((data[4] & 0x03) << 14));\n\t\tinput_report_abs(input, ABS_PRESSURE, pressure);\n\n\t\tinput_report_key(input, BTN_TOUCH, data[4] & 0x08);\n\t\tinput_report_key(input, BTN_STYLUS, data[4] & 0x10);\n\t\t \n\t\tinput_report_key(input, BTN_STYLUS2, (wacom->tool[0] == BTN_TOOL_PEN) && (data[4] & 0x20));\n\t}\n\n\tif (!prox)\n\t\twacom->id[0] = 0;\n\tinput_report_key(input, wacom->tool[0], prox);\n\tinput_report_abs(input, ABS_MISC, wacom->id[0]);\n\treturn 1;\n}\n\nstatic int wacom_ptu_irq(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\n\tif (data[0] != WACOM_REPORT_PENABLED) {\n\t\tdev_dbg(input->dev.parent,\n\t\t\t\"%s: received unknown report #%d\\n\", __func__, data[0]);\n\t\treturn 0;\n\t}\n\n\tif (data[1] & 0x04) {\n\t\tinput_report_key(input, BTN_TOOL_RUBBER, data[1] & 0x20);\n\t\tinput_report_key(input, BTN_TOUCH, data[1] & 0x08);\n\t\twacom->id[0] = ERASER_DEVICE_ID;\n\t} else {\n\t\tinput_report_key(input, BTN_TOOL_PEN, data[1] & 0x20);\n\t\tinput_report_key(input, BTN_TOUCH, data[1] & 0x01);\n\t\twacom->id[0] = STYLUS_DEVICE_ID;\n\t}\n\tinput_report_abs(input, ABS_MISC, wacom->id[0]);  \n\tinput_report_abs(input, ABS_X, le16_to_cpup((__le16 *)&data[2]));\n\tinput_report_abs(input, ABS_Y, le16_to_cpup((__le16 *)&data[4]));\n\tinput_report_abs(input, ABS_PRESSURE, le16_to_cpup((__le16 *)&data[6]));\n\tinput_report_key(input, BTN_STYLUS, data[1] & 0x02);\n\tinput_report_key(input, BTN_STYLUS2, data[1] & 0x10);\n\treturn 1;\n}\n\nstatic int wacom_dtu_irq(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\tint prox = data[1] & 0x20;\n\n\tdev_dbg(input->dev.parent,\n\t\t\"%s: received report #%d\", __func__, data[0]);\n\n\tif (prox) {\n\t\t \n\t\twacom->tool[0] = (data[1] & 0x0c) ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\n\t\tif (wacom->tool[0] == BTN_TOOL_PEN)\n\t\t\twacom->id[0] = STYLUS_DEVICE_ID;\n\t\telse\n\t\t\twacom->id[0] = ERASER_DEVICE_ID;\n\t}\n\tinput_report_key(input, BTN_STYLUS, data[1] & 0x02);\n\tinput_report_key(input, BTN_STYLUS2, data[1] & 0x10);\n\tinput_report_abs(input, ABS_X, le16_to_cpup((__le16 *)&data[2]));\n\tinput_report_abs(input, ABS_Y, le16_to_cpup((__le16 *)&data[4]));\n\tinput_report_abs(input, ABS_PRESSURE, ((data[7] & 0x01) << 8) | data[6]);\n\tinput_report_key(input, BTN_TOUCH, data[1] & 0x05);\n\tif (!prox)  \n\t\twacom->id[0] = 0;\n\tinput_report_key(input, wacom->tool[0], prox);\n\tinput_report_abs(input, ABS_MISC, wacom->id[0]);\n\treturn 1;\n}\n\nstatic int wacom_dtus_irq(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\tunsigned short prox, pressure = 0;\n\n\tif (data[0] != WACOM_REPORT_DTUS && data[0] != WACOM_REPORT_DTUSPAD) {\n\t\tdev_dbg(input->dev.parent,\n\t\t\t\"%s: received unknown report #%d\", __func__, data[0]);\n\t\treturn 0;\n\t} else if (data[0] == WACOM_REPORT_DTUSPAD) {\n\t\tinput = wacom->pad_input;\n\t\tinput_report_key(input, BTN_0, (data[1] & 0x01));\n\t\tinput_report_key(input, BTN_1, (data[1] & 0x02));\n\t\tinput_report_key(input, BTN_2, (data[1] & 0x04));\n\t\tinput_report_key(input, BTN_3, (data[1] & 0x08));\n\t\tinput_report_abs(input, ABS_MISC,\n\t\t\t\t data[1] & 0x0f ? PAD_DEVICE_ID : 0);\n\t\treturn 1;\n\t} else {\n\t\tprox = data[1] & 0x80;\n\t\tif (prox) {\n\t\t\tswitch ((data[1] >> 3) & 3) {\n\t\t\tcase 1:  \n\t\t\t\twacom->tool[0] = BTN_TOOL_RUBBER;\n\t\t\t\twacom->id[0] = ERASER_DEVICE_ID;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:  \n\t\t\t\twacom->tool[0] = BTN_TOOL_PEN;\n\t\t\t\twacom->id[0] = STYLUS_DEVICE_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tinput_report_key(input, BTN_STYLUS, data[1] & 0x20);\n\t\tinput_report_key(input, BTN_STYLUS2, data[1] & 0x40);\n\t\tinput_report_abs(input, ABS_X, get_unaligned_be16(&data[3]));\n\t\tinput_report_abs(input, ABS_Y, get_unaligned_be16(&data[5]));\n\t\tpressure = ((data[1] & 0x03) << 8) | (data[2] & 0xff);\n\t\tinput_report_abs(input, ABS_PRESSURE, pressure);\n\t\tinput_report_key(input, BTN_TOUCH, pressure > 10);\n\n\t\tif (!prox)  \n\t\t\twacom->id[0] = 0;\n\t\tinput_report_key(input, wacom->tool[0], prox);\n\t\tinput_report_abs(input, ABS_MISC, wacom->id[0]);\n\t\treturn 1;\n\t}\n}\n\nstatic int wacom_graphire_irq(struct wacom_wac *wacom)\n{\n\tstruct wacom_features *features = &wacom->features;\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\tstruct input_dev *pad_input = wacom->pad_input;\n\tint battery_capacity, ps_connected;\n\tint prox;\n\tint rw = 0;\n\tint retval = 0;\n\n\tif (features->type == GRAPHIRE_BT) {\n\t\tif (data[0] != WACOM_REPORT_PENABLED_BT) {\n\t\t\tdev_dbg(input->dev.parent,\n\t\t\t\t\"%s: received unknown report #%d\\n\", __func__,\n\t\t\t\tdata[0]);\n\t\t\tgoto exit;\n\t\t}\n\t} else if (data[0] != WACOM_REPORT_PENABLED) {\n\t\tdev_dbg(input->dev.parent,\n\t\t\t\"%s: received unknown report #%d\\n\", __func__, data[0]);\n\t\tgoto exit;\n\t}\n\n\tprox = data[1] & 0x80;\n\tif (prox || wacom->id[0]) {\n\t\tif (prox) {\n\t\t\tswitch ((data[1] >> 5) & 3) {\n\n\t\t\tcase 0:\t \n\t\t\t\twacom->tool[0] = BTN_TOOL_PEN;\n\t\t\t\twacom->id[0] = STYLUS_DEVICE_ID;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:  \n\t\t\t\twacom->tool[0] = BTN_TOOL_RUBBER;\n\t\t\t\twacom->id[0] = ERASER_DEVICE_ID;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:  \n\t\t\t\tinput_report_key(input, BTN_MIDDLE, data[1] & 0x04);\n\t\t\t\tfallthrough;\n\n\t\t\tcase 3:  \n\t\t\t\twacom->tool[0] = BTN_TOOL_MOUSE;\n\t\t\t\twacom->id[0] = CURSOR_DEVICE_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tinput_report_abs(input, ABS_X, le16_to_cpup((__le16 *)&data[2]));\n\t\tinput_report_abs(input, ABS_Y, le16_to_cpup((__le16 *)&data[4]));\n\t\tif (wacom->tool[0] != BTN_TOOL_MOUSE) {\n\t\t\tif (features->type == GRAPHIRE_BT)\n\t\t\t\tinput_report_abs(input, ABS_PRESSURE, data[6] |\n\t\t\t\t\t(((__u16) (data[1] & 0x08)) << 5));\n\t\t\telse\n\t\t\t\tinput_report_abs(input, ABS_PRESSURE, data[6] |\n\t\t\t\t\t((data[7] & 0x03) << 8));\n\t\t\tinput_report_key(input, BTN_TOUCH, data[1] & 0x01);\n\t\t\tinput_report_key(input, BTN_STYLUS, data[1] & 0x02);\n\t\t\tinput_report_key(input, BTN_STYLUS2, data[1] & 0x04);\n\t\t} else {\n\t\t\tinput_report_key(input, BTN_LEFT, data[1] & 0x01);\n\t\t\tinput_report_key(input, BTN_RIGHT, data[1] & 0x02);\n\t\t\tif (features->type == WACOM_G4 ||\n\t\t\t\t\tfeatures->type == WACOM_MO) {\n\t\t\t\tinput_report_abs(input, ABS_DISTANCE, data[6] & 0x3f);\n\t\t\t\trw = (data[7] & 0x04) - (data[7] & 0x03);\n\t\t\t} else if (features->type == GRAPHIRE_BT) {\n\t\t\t\t \n\t\t\t\trw = 44 - (data[6] >> 2);\n\t\t\t\trw = clamp_val(rw, 0, 31);\n\t\t\t\tinput_report_abs(input, ABS_DISTANCE, rw);\n\t\t\t\tif (((data[1] >> 5) & 3) == 2) {\n\t\t\t\t\t \n\t\t\t\t\tinput_report_key(input, BTN_MIDDLE,\n\t\t\t\t\t\t\tdata[1] & 0x04);\n\t\t\t\t\trw = (data[6] & 0x01) ? -1 :\n\t\t\t\t\t\t(data[6] & 0x02) ? 1 : 0;\n\t\t\t\t} else {\n\t\t\t\t\trw = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinput_report_abs(input, ABS_DISTANCE, data[7] & 0x3f);\n\t\t\t\trw = -(signed char)data[6];\n\t\t\t}\n\t\t\tinput_report_rel(input, REL_WHEEL, rw);\n\t\t}\n\n\t\tif (!prox)\n\t\t\twacom->id[0] = 0;\n\t\tinput_report_abs(input, ABS_MISC, wacom->id[0]);  \n\t\tinput_report_key(input, wacom->tool[0], prox);\n\t\tinput_sync(input);  \n\t}\n\n\t \n\tswitch (features->type) {\n\tcase WACOM_G4:\n\t\tprox = data[7] & 0xf8;\n\t\tif (prox || wacom->id[1]) {\n\t\t\twacom->id[1] = PAD_DEVICE_ID;\n\t\t\tinput_report_key(pad_input, BTN_BACK, (data[7] & 0x40));\n\t\t\tinput_report_key(pad_input, BTN_FORWARD, (data[7] & 0x80));\n\t\t\trw = ((data[7] & 0x18) >> 3) - ((data[7] & 0x20) >> 3);\n\t\t\tinput_report_rel(pad_input, REL_WHEEL, rw);\n\t\t\tif (!prox)\n\t\t\t\twacom->id[1] = 0;\n\t\t\tinput_report_abs(pad_input, ABS_MISC, wacom->id[1]);\n\t\t\tretval = 1;\n\t\t}\n\t\tbreak;\n\n\tcase WACOM_MO:\n\t\tprox = (data[7] & 0xf8) || data[8];\n\t\tif (prox || wacom->id[1]) {\n\t\t\twacom->id[1] = PAD_DEVICE_ID;\n\t\t\tinput_report_key(pad_input, BTN_BACK, (data[7] & 0x08));\n\t\t\tinput_report_key(pad_input, BTN_LEFT, (data[7] & 0x20));\n\t\t\tinput_report_key(pad_input, BTN_FORWARD, (data[7] & 0x10));\n\t\t\tinput_report_key(pad_input, BTN_RIGHT, (data[7] & 0x40));\n\t\t\tinput_report_abs(pad_input, ABS_WHEEL, (data[8] & 0x7f));\n\t\t\tif (!prox)\n\t\t\t\twacom->id[1] = 0;\n\t\t\tinput_report_abs(pad_input, ABS_MISC, wacom->id[1]);\n\t\t\tretval = 1;\n\t\t}\n\t\tbreak;\n\tcase GRAPHIRE_BT:\n\t\tprox = data[7] & 0x03;\n\t\tif (prox || wacom->id[1]) {\n\t\t\twacom->id[1] = PAD_DEVICE_ID;\n\t\t\tinput_report_key(pad_input, BTN_0, (data[7] & 0x02));\n\t\t\tinput_report_key(pad_input, BTN_1, (data[7] & 0x01));\n\t\t\tif (!prox)\n\t\t\t\twacom->id[1] = 0;\n\t\t\tinput_report_abs(pad_input, ABS_MISC, wacom->id[1]);\n\t\t\tretval = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (features->type == GRAPHIRE_BT) {\n\t\trw = (data[7] >> 2 & 0x07);\n\t\tbattery_capacity = batcap_gr[rw];\n\t\tps_connected = rw == 7;\n\t\twacom_notify_battery(wacom, WACOM_POWER_SUPPLY_STATUS_AUTO,\n\t\t\t\t     battery_capacity, ps_connected, 1,\n\t\t\t\t     ps_connected);\n\t}\nexit:\n\treturn retval;\n}\n\nstatic void wacom_intuos_schedule_prox_event(struct wacom_wac *wacom_wac)\n{\n\tstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\n\tstruct wacom_features *features = &wacom_wac->features;\n\tstruct hid_report *r;\n\tstruct hid_report_enum *re;\n\n\tre = &(wacom->hdev->report_enum[HID_FEATURE_REPORT]);\n\tif (features->type == INTUOSHT2)\n\t\tr = re->report_id_hash[WACOM_REPORT_INTUOSHT2_ID];\n\telse\n\t\tr = re->report_id_hash[WACOM_REPORT_INTUOS_ID1];\n\tif (r) {\n\t\thid_hw_request(wacom->hdev, r, HID_REQ_GET_REPORT);\n\t}\n}\n\nstatic int wacom_intuos_pad(struct wacom_wac *wacom)\n{\n\tstruct wacom_features *features = &wacom->features;\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pad_input;\n\tint i;\n\tint buttons = 0, nbuttons = features->numbered_buttons;\n\tint keys = 0, nkeys = 0;\n\tint ring1 = 0, ring2 = 0;\n\tint strip1 = 0, strip2 = 0;\n\tbool prox = false;\n\tbool wrench = false, keyboard = false, mute_touch = false, menu = false,\n\t     info = false;\n\n\t \n\tif (!(data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||\n\t      data[0] == WACOM_REPORT_CINTIQPAD))\n\t\treturn 0;\n\n\tif (features->type >= INTUOS4S && features->type <= INTUOS4L) {\n\t\tbuttons = (data[3] << 1) | (data[2] & 0x01);\n\t\tring1 = data[1];\n\t} else if (features->type == DTK) {\n\t\tbuttons = data[6];\n\t} else if (features->type == WACOM_13HD) {\n\t\tbuttons = (data[4] << 1) | (data[3] & 0x01);\n\t} else if (features->type == WACOM_24HD) {\n\t\tbuttons = (data[8] << 8) | data[6];\n\t\tring1 = data[1];\n\t\tring2 = data[2];\n\n\t\t \n\t\tnkeys = 3;\n\t\tkeys = ((data[3] & 0x1C) ? 1<<2 : 0) |\n\t\t       ((data[4] & 0xE0) ? 1<<1 : 0) |\n\t\t       ((data[4] & 0x07) ? 1<<0 : 0);\n\t\tkeyboard = !!(data[4] & 0xE0);\n\t\tinfo = !!(data[3] & 0x1C);\n\n\t\tif (features->oPid) {\n\t\t\tmute_touch = !!(data[4] & 0x07);\n\t\t\tif (mute_touch)\n\t\t\t\twacom->shared->is_touch_on =\n\t\t\t\t\t!wacom->shared->is_touch_on;\n\t\t} else {\n\t\t\twrench = !!(data[4] & 0x07);\n\t\t}\n\t} else if (features->type == WACOM_27QHD) {\n\t\tnkeys = 3;\n\t\tkeys = data[2] & 0x07;\n\n\t\twrench = !!(data[2] & 0x01);\n\t\tkeyboard = !!(data[2] & 0x02);\n\n\t\tif (features->oPid) {\n\t\t\tmute_touch = !!(data[2] & 0x04);\n\t\t\tif (mute_touch)\n\t\t\t\twacom->shared->is_touch_on =\n\t\t\t\t\t!wacom->shared->is_touch_on;\n\t\t} else {\n\t\t\tmenu = !!(data[2] & 0x04);\n\t\t}\n\t\tinput_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));\n\t\tinput_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));\n\t\tinput_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));\n\t} else if (features->type == CINTIQ_HYBRID) {\n\t\t \n\t\tbuttons = (data[4] << 1) | (data[3] & 0x01);\n\t} else if (features->type == CINTIQ_COMPANION_2) {\n\t\t \n\t\tbuttons = ((data[2] >> 4) << 7) |\n\t\t          ((data[1] & 0x04) << 4) |\n\t\t          ((data[2] & 0x0F) << 2) |\n\t\t          (data[1] & 0x03);\n\t} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {\n\t\t \n\t\tbuttons = (data[4] << 1) | (data[3] & 0x01);\n\t\tring1 = data[2];\n\t} else {\n\t\tif (features->type == WACOM_21UX2 || features->type == WACOM_22HD) {\n\t\t\tbuttons = (data[8] << 10) | ((data[7] & 0x01) << 9) |\n\t\t\t          (data[6] << 1) | (data[5] & 0x01);\n\n\t\t\tif (features->type == WACOM_22HD) {\n\t\t\t\tnkeys = 3;\n\t\t\t\tkeys = data[9] & 0x07;\n\n\t\t\t\tinfo = !!(data[9] & 0x01);\n\t\t\t\twrench = !!(data[9] & 0x02);\n\t\t\t}\n\t\t} else {\n\t\t\tbuttons = ((data[6] & 0x10) << 5)  |\n\t\t\t          ((data[5] & 0x10) << 4)  |\n\t\t\t          ((data[6] & 0x0F) << 4)  |\n\t\t\t          (data[5] & 0x0F);\n\t\t}\n\t\tstrip1 = ((data[1] & 0x1f) << 8) | data[2];\n\t\tstrip2 = ((data[3] & 0x1f) << 8) | data[4];\n\t}\n\n\tprox = (buttons & ~(~0U << nbuttons)) | (keys & ~(~0U << nkeys)) |\n\t       (ring1 & 0x80) | (ring2 & 0x80) | strip1 | strip2;\n\n\twacom_report_numbered_buttons(input, nbuttons, buttons);\n\n\tfor (i = 0; i < nkeys; i++)\n\t\tinput_report_key(input, KEY_PROG1 + i, keys & (1 << i));\n\n\tinput_report_key(input, KEY_BUTTONCONFIG, wrench);\n\tinput_report_key(input, KEY_ONSCREEN_KEYBOARD, keyboard);\n\tinput_report_key(input, KEY_CONTROLPANEL, menu);\n\tinput_report_key(input, KEY_INFO, info);\n\n\tif (wacom->shared && wacom->shared->touch_input) {\n\t\tinput_report_switch(wacom->shared->touch_input,\n\t\t\t\t    SW_MUTE_DEVICE,\n\t\t\t\t    !wacom->shared->is_touch_on);\n\t\tinput_sync(wacom->shared->touch_input);\n\t}\n\n\tinput_report_abs(input, ABS_RX, strip1);\n\tinput_report_abs(input, ABS_RY, strip2);\n\n\tinput_report_abs(input, ABS_WHEEL,    (ring1 & 0x80) ? (ring1 & 0x7f) : 0);\n\tinput_report_abs(input, ABS_THROTTLE, (ring2 & 0x80) ? (ring2 & 0x7f) : 0);\n\n\tinput_report_key(input, wacom->tool[1], prox ? 1 : 0);\n\tinput_report_abs(input, ABS_MISC, prox ? PAD_DEVICE_ID : 0);\n\n\tinput_event(input, EV_MSC, MSC_SERIAL, 0xffffffff);\n\n\treturn 1;\n}\n\nstatic int wacom_intuos_id_mangle(int tool_id)\n{\n\treturn (tool_id & ~0xFFF) << 4 | (tool_id & 0xFFF);\n}\n\nstatic bool wacom_is_art_pen(int tool_id)\n{\n\tbool is_art_pen = false;\n\n\tswitch (tool_id) {\n\tcase 0x885:\t \n\tcase 0x804:\t \n\tcase 0x10804:\t \n\t\tis_art_pen = true;\n\t\tbreak;\n\t}\n\treturn is_art_pen;\n}\n\nstatic int wacom_intuos_get_tool_type(int tool_id)\n{\n\tint tool_type = BTN_TOOL_PEN;\n\n\tif (wacom_is_art_pen(tool_id))\n\t\treturn tool_type;\n\n\tswitch (tool_id) {\n\tcase 0x812:  \n\tcase 0x801:  \n\tcase 0x12802:  \n\tcase 0x012:\n\t\ttool_type = BTN_TOOL_PENCIL;\n\t\tbreak;\n\n\tcase 0x822:  \n\tcase 0x842:\n\tcase 0x852:\n\tcase 0x823:  \n\tcase 0x813:  \n\tcase 0x802:  \n\tcase 0x8e2:  \n\tcase 0x022:\n\tcase 0x200:  \n\tcase 0x04200:  \n\tcase 0x10842:  \n\tcase 0x14802:  \n\tcase 0x16802:  \n\tcase 0x18802:  \n\tcase 0x10802:  \n\tcase 0x80842:  \n\t\ttool_type = BTN_TOOL_PEN;\n\t\tbreak;\n\n\tcase 0x832:  \n\tcase 0x032:\n\t\ttool_type = BTN_TOOL_BRUSH;\n\t\tbreak;\n\n\tcase 0x007:  \n\tcase 0x09c:\n\tcase 0x094:\n\tcase 0x017:  \n\tcase 0x806:  \n\t\ttool_type = BTN_TOOL_MOUSE;\n\t\tbreak;\n\n\tcase 0x096:  \n\tcase 0x097:  \n\tcase 0x006:  \n\t\ttool_type = BTN_TOOL_LENS;\n\t\tbreak;\n\n\tcase 0x82a:  \n\tcase 0x84a:\n\tcase 0x85a:\n\tcase 0x91a:\n\tcase 0xd1a:\n\tcase 0x0fa:\n\tcase 0x82b:  \n\tcase 0x81b:  \n\tcase 0x91b:  \n\tcase 0x80c:  \n\tcase 0x80a:  \n\tcase 0x90a:  \n\tcase 0x1480a:  \n\tcase 0x1090a:  \n\tcase 0x1080c:  \n\tcase 0x1084a:  \n\tcase 0x1680a:  \n\tcase 0x1880a:  \n\tcase 0x1080a:  \n\t\ttool_type = BTN_TOOL_RUBBER;\n\t\tbreak;\n\n\tcase 0xd12:\n\tcase 0x912:\n\tcase 0x112:\n\tcase 0x913:  \n\tcase 0x902:  \n\tcase 0x10902:  \n\t\ttool_type = BTN_TOOL_AIRBRUSH;\n\t\tbreak;\n\t}\n\treturn tool_type;\n}\n\nstatic void wacom_exit_report(struct wacom_wac *wacom)\n{\n\tstruct input_dev *input = wacom->pen_input;\n\tstruct wacom_features *features = &wacom->features;\n\tunsigned char *data = wacom->data;\n\tint idx = (features->type == INTUOS) ? (data[1] & 0x01) : 0;\n\n\t \n\tinput_report_abs(input, ABS_X, 0);\n\tinput_report_abs(input, ABS_Y, 0);\n\tinput_report_abs(input, ABS_DISTANCE, 0);\n\tinput_report_abs(input, ABS_TILT_X, 0);\n\tinput_report_abs(input, ABS_TILT_Y, 0);\n\tif (wacom->tool[idx] >= BTN_TOOL_MOUSE) {\n\t\tinput_report_key(input, BTN_LEFT, 0);\n\t\tinput_report_key(input, BTN_MIDDLE, 0);\n\t\tinput_report_key(input, BTN_RIGHT, 0);\n\t\tinput_report_key(input, BTN_SIDE, 0);\n\t\tinput_report_key(input, BTN_EXTRA, 0);\n\t\tinput_report_abs(input, ABS_THROTTLE, 0);\n\t\tinput_report_abs(input, ABS_RZ, 0);\n\t} else {\n\t\tinput_report_abs(input, ABS_PRESSURE, 0);\n\t\tinput_report_key(input, BTN_STYLUS, 0);\n\t\tinput_report_key(input, BTN_STYLUS2, 0);\n\t\tinput_report_key(input, BTN_TOUCH, 0);\n\t\tinput_report_abs(input, ABS_WHEEL, 0);\n\t\tif (features->type >= INTUOS3S)\n\t\t\tinput_report_abs(input, ABS_Z, 0);\n\t}\n\tinput_report_key(input, wacom->tool[idx], 0);\n\tinput_report_abs(input, ABS_MISC, 0);  \n\tinput_event(input, EV_MSC, MSC_SERIAL, wacom->serial[idx]);\n\twacom->id[idx] = 0;\n}\n\nstatic int wacom_intuos_inout(struct wacom_wac *wacom)\n{\n\tstruct wacom_features *features = &wacom->features;\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\tint idx = (features->type == INTUOS) ? (data[1] & 0x01) : 0;\n\n\tif (!(((data[1] & 0xfc) == 0xc0) ||   \n\t    ((data[1] & 0xfe) == 0x20) ||     \n\t    ((data[1] & 0xfe) == 0x80)))      \n\t\treturn 0;\n\n\t \n\tif ((data[1] & 0xfc) == 0xc0) {\n\t\t \n\t\twacom->serial[idx] = ((__u64)(data[3] & 0x0f) << 28) +\n\t\t\t(data[4] << 20) + (data[5] << 12) +\n\t\t\t(data[6] << 4) + (data[7] >> 4);\n\n\t\twacom->id[idx] = (data[2] << 4) | (data[3] >> 4) |\n\t\t     ((data[7] & 0x0f) << 16) | ((data[8] & 0xf0) << 8);\n\n\t\twacom->tool[idx] = wacom_intuos_get_tool_type(wacom->id[idx]);\n\n\t\twacom->shared->stylus_in_proximity = true;\n\t\treturn 1;\n\t}\n\n\t \n\tif ((data[1] & 0xfe) == 0x20) {\n\t\tif (features->type != INTUOSHT2)\n\t\t\twacom->shared->stylus_in_proximity = true;\n\n\t\t \n\t\tif (wacom->reporting_data) {\n\t\t\tinput_report_key(input, BTN_TOUCH, 0);\n\t\t\tinput_report_abs(input, ABS_PRESSURE, 0);\n\t\t\tinput_report_abs(input, ABS_DISTANCE, wacom->features.distance_max);\n\t\t\treturn 2;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t \n\tif ((data[1] & 0xfe) == 0x80) {\n\t\twacom->shared->stylus_in_proximity = false;\n\t\twacom->reporting_data = false;\n\n\t\t \n\t\tif (!wacom->id[idx])\n\t\t\treturn 1;\n\n\t\twacom_exit_report(wacom);\n\t\treturn 2;\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool touch_is_muted(struct wacom_wac *wacom_wac)\n{\n\treturn wacom_wac->probe_complete &&\n\t       wacom_wac->shared->has_mute_touch_switch &&\n\t       !wacom_wac->shared->is_touch_on;\n}\n\nstatic inline bool report_touch_events(struct wacom_wac *wacom)\n{\n\treturn (touch_arbitration ? !wacom->shared->stylus_in_proximity : 1);\n}\n\nstatic inline bool delay_pen_events(struct wacom_wac *wacom)\n{\n\treturn (wacom->shared->touch_down && touch_arbitration);\n}\n\nstatic int wacom_intuos_general(struct wacom_wac *wacom)\n{\n\tstruct wacom_features *features = &wacom->features;\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\tint idx = (features->type == INTUOS) ? (data[1] & 0x01) : 0;\n\tunsigned char type = (data[1] >> 1) & 0x0F;\n\tunsigned int x, y, distance, t;\n\n\tif (data[0] != WACOM_REPORT_PENABLED && data[0] != WACOM_REPORT_CINTIQ &&\n\t\tdata[0] != WACOM_REPORT_INTUOS_PEN)\n\t\treturn 0;\n\n\tif (delay_pen_events(wacom))\n\t\treturn 1;\n\n\t \n\tif (!wacom->id[idx]) {\n\t\t \n\t\twacom_intuos_schedule_prox_event(wacom);\n\t\treturn 1;\n\t}\n\n\t \n\t \n\tif ((!((wacom->id[idx] >> 16) & 0x01) &&\n\t\t\t(features->type == WACOM_21UX2)) ||\n\t     \n\t    (wacom->tool[idx] == BTN_TOOL_LENS &&\n\t\t(features->type == INTUOS3 ||\n\t\t features->type == INTUOS3S ||\n\t\t features->type == INTUOS4 ||\n\t\t features->type == INTUOS4S ||\n\t\t features->type == INTUOS5 ||\n\t\t features->type == INTUOS5S ||\n\t\t features->type == INTUOSPM ||\n\t\t features->type == INTUOSPS)) ||\n\t    \n\t   (features->type == CINTIQ && !(data[1] & 0x40)))\n\t\treturn 1;\n\n\tx = (be16_to_cpup((__be16 *)&data[2]) << 1) | ((data[9] >> 1) & 1);\n\ty = (be16_to_cpup((__be16 *)&data[4]) << 1) | (data[9] & 1);\n\tdistance = data[9] >> 2;\n\tif (features->type < INTUOS3S) {\n\t\tx >>= 1;\n\t\ty >>= 1;\n\t\tdistance >>= 1;\n\t}\n\tif (features->type == INTUOSHT2)\n\t\tdistance = features->distance_max - distance;\n\tinput_report_abs(input, ABS_X, x);\n\tinput_report_abs(input, ABS_Y, y);\n\tinput_report_abs(input, ABS_DISTANCE, distance);\n\n\tswitch (type) {\n\tcase 0x00:\n\tcase 0x01:\n\tcase 0x02:\n\tcase 0x03:\n\t\t \n\t\tt = (data[6] << 3) | ((data[7] & 0xC0) >> 5) | (data[1] & 1);\n\t\tif (features->pressure_max < 2047)\n\t\t\tt >>= 1;\n\t\tinput_report_abs(input, ABS_PRESSURE, t);\n\t\tif (features->type != INTUOSHT2) {\n\t\t    input_report_abs(input, ABS_TILT_X,\n\t\t\t\t (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);\n\t\t    input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);\n\t\t}\n\t\tinput_report_key(input, BTN_STYLUS, data[1] & 2);\n\t\tinput_report_key(input, BTN_STYLUS2, data[1] & 4);\n\t\tinput_report_key(input, BTN_TOUCH, t > 10);\n\t\tbreak;\n\n\tcase 0x0a:\n\t\t \n\t\tinput_report_abs(input, ABS_WHEEL,\n\t\t\t\t(data[6] << 2) | ((data[7] >> 6) & 3));\n\t\tinput_report_abs(input, ABS_TILT_X,\n\t\t\t\t (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);\n\t\tinput_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);\n\t\tbreak;\n\n\tcase 0x05:\n\t\t \n\t\tif (features->type >= INTUOS3S) {\n\t\t\t \n\t\t\tt = (data[6] << 3) | ((data[7] >> 5) & 7);\n\t\t\tt = (data[7] & 0x20) ? ((t > 900) ? ((t-1) / 2 - 1350) :\n\t\t\t\t((t-1) / 2 + 450)) : (450 - t / 2) ;\n\t\t\tinput_report_abs(input, ABS_Z, t);\n\t\t} else {\n\t\t\t \n\t\t\tt = (data[6] << 3) | ((data[7] >> 5) & 7);\n\t\t\tinput_report_abs(input, ABS_RZ, (data[7] & 0x20) ?\n\t\t\t\t((t - 1) / 2) : -t / 2);\n\t\t}\n\t\tbreak;\n\n\tcase 0x04:\n\t\t \n\t\tinput_report_key(input, BTN_LEFT,   data[8] & 0x01);\n\t\tinput_report_key(input, BTN_MIDDLE, data[8] & 0x02);\n\t\tinput_report_key(input, BTN_RIGHT,  data[8] & 0x04);\n\n\t\tinput_report_key(input, BTN_SIDE,   data[8] & 0x20);\n\t\tinput_report_key(input, BTN_EXTRA,  data[8] & 0x10);\n\t\tt = (data[6] << 2) | ((data[7] >> 6) & 3);\n\t\tinput_report_abs(input, ABS_THROTTLE, (data[8] & 0x08) ? -t : t);\n\t\tbreak;\n\n\tcase 0x06:\n\t\t \n\t\tinput_report_key(input, BTN_LEFT,   data[6] & 0x01);\n\t\tinput_report_key(input, BTN_MIDDLE, data[6] & 0x02);\n\t\tinput_report_key(input, BTN_RIGHT,  data[6] & 0x04);\n\t\tinput_report_rel(input, REL_WHEEL, ((data[7] & 0x80) >> 7)\n\t\t\t\t - ((data[7] & 0x40) >> 6));\n\t\tinput_report_key(input, BTN_SIDE,   data[6] & 0x08);\n\t\tinput_report_key(input, BTN_EXTRA,  data[6] & 0x10);\n\n\t\tinput_report_abs(input, ABS_TILT_X,\n\t\t\t(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);\n\t\tinput_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);\n\t\tbreak;\n\n\tcase 0x08:\n\t\tif (wacom->tool[idx] == BTN_TOOL_MOUSE) {\n\t\t\t \n\t\t\tinput_report_key(input, BTN_LEFT,   data[8] & 0x04);\n\t\t\tinput_report_key(input, BTN_MIDDLE, data[8] & 0x08);\n\t\t\tinput_report_key(input, BTN_RIGHT,  data[8] & 0x10);\n\t\t\tinput_report_rel(input, REL_WHEEL, (data[8] & 0x01)\n\t\t\t\t\t - ((data[8] & 0x02) >> 1));\n\n\t\t\t \n\t\t\tif (features->type >= INTUOS3S && features->type <= INTUOS3L) {\n\t\t\t\tinput_report_key(input, BTN_SIDE,   data[8] & 0x40);\n\t\t\t\tinput_report_key(input, BTN_EXTRA,  data[8] & 0x20);\n\t\t\t}\n\t\t}\n\t\telse if (wacom->tool[idx] == BTN_TOOL_LENS) {\n\t\t\t \n\t\t\tinput_report_key(input, BTN_LEFT,   data[8] & 0x01);\n\t\t\tinput_report_key(input, BTN_MIDDLE, data[8] & 0x02);\n\t\t\tinput_report_key(input, BTN_RIGHT,  data[8] & 0x04);\n\t\t\tinput_report_key(input, BTN_SIDE,   data[8] & 0x10);\n\t\t\tinput_report_key(input, BTN_EXTRA,  data[8] & 0x08);\n\t\t}\n\t\tbreak;\n\n\tcase 0x07:\n\tcase 0x09:\n\tcase 0x0b:\n\tcase 0x0c:\n\tcase 0x0d:\n\tcase 0x0e:\n\tcase 0x0f:\n\t\t \n\t\tbreak;\n\t}\n\n\tinput_report_abs(input, ABS_MISC,\n\t\t\t wacom_intuos_id_mangle(wacom->id[idx]));  \n\tinput_report_key(input, wacom->tool[idx], 1);\n\tinput_event(input, EV_MSC, MSC_SERIAL, wacom->serial[idx]);\n\twacom->reporting_data = true;\n\treturn 2;\n}\n\nstatic int wacom_intuos_irq(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\tint result;\n\n\tif (data[0] != WACOM_REPORT_PENABLED &&\n\t    data[0] != WACOM_REPORT_INTUOS_ID1 &&\n\t    data[0] != WACOM_REPORT_INTUOS_ID2 &&\n\t    data[0] != WACOM_REPORT_INTUOSPAD &&\n\t    data[0] != WACOM_REPORT_INTUOS_PEN &&\n\t    data[0] != WACOM_REPORT_CINTIQ &&\n\t    data[0] != WACOM_REPORT_CINTIQPAD &&\n\t    data[0] != WACOM_REPORT_INTUOS5PAD) {\n\t\tdev_dbg(input->dev.parent,\n\t\t\t\"%s: received unknown report #%d\\n\", __func__, data[0]);\n                return 0;\n\t}\n\n\t \n\tresult = wacom_intuos_pad(wacom);\n\tif (result)\n\t\treturn result;\n\n\t \n\tresult = wacom_intuos_inout(wacom);\n\tif (result)\n\t\treturn result - 1;\n\n\t \n\tresult = wacom_intuos_general(wacom);\n\tif (result)\n\t\treturn result - 1;\n\n\treturn 0;\n}\n\nstatic int wacom_remote_irq(struct wacom_wac *wacom_wac, size_t len)\n{\n\tunsigned char *data = wacom_wac->data;\n\tstruct input_dev *input;\n\tstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\n\tstruct wacom_remote *remote = wacom->remote;\n\tint bat_charging, bat_percent, touch_ring_mode;\n\t__u32 serial;\n\tint i, index = -1;\n\tunsigned long flags;\n\n\tif (data[0] != WACOM_REPORT_REMOTE) {\n\t\thid_dbg(wacom->hdev, \"%s: received unknown report #%d\",\n\t\t\t__func__, data[0]);\n\t\treturn 0;\n\t}\n\n\tserial = data[3] + (data[4] << 8) + (data[5] << 16);\n\twacom_wac->id[0] = PAD_DEVICE_ID;\n\n\tspin_lock_irqsave(&remote->remote_lock, flags);\n\n\tfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\n\t\tif (remote->remotes[i].serial == serial) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (index < 0 || !remote->remotes[index].registered)\n\t\tgoto out;\n\n\tremote->remotes[i].active_time = ktime_get();\n\tinput = remote->remotes[index].input;\n\n\tinput_report_key(input, BTN_0, (data[9] & 0x01));\n\tinput_report_key(input, BTN_1, (data[9] & 0x02));\n\tinput_report_key(input, BTN_2, (data[9] & 0x04));\n\tinput_report_key(input, BTN_3, (data[9] & 0x08));\n\tinput_report_key(input, BTN_4, (data[9] & 0x10));\n\tinput_report_key(input, BTN_5, (data[9] & 0x20));\n\tinput_report_key(input, BTN_6, (data[9] & 0x40));\n\tinput_report_key(input, BTN_7, (data[9] & 0x80));\n\n\tinput_report_key(input, BTN_8, (data[10] & 0x01));\n\tinput_report_key(input, BTN_9, (data[10] & 0x02));\n\tinput_report_key(input, BTN_A, (data[10] & 0x04));\n\tinput_report_key(input, BTN_B, (data[10] & 0x08));\n\tinput_report_key(input, BTN_C, (data[10] & 0x10));\n\tinput_report_key(input, BTN_X, (data[10] & 0x20));\n\tinput_report_key(input, BTN_Y, (data[10] & 0x40));\n\tinput_report_key(input, BTN_Z, (data[10] & 0x80));\n\n\tinput_report_key(input, BTN_BASE, (data[11] & 0x01));\n\tinput_report_key(input, BTN_BASE2, (data[11] & 0x02));\n\n\tif (data[12] & 0x80)\n\t\tinput_report_abs(input, ABS_WHEEL, (data[12] & 0x7f) - 1);\n\telse\n\t\tinput_report_abs(input, ABS_WHEEL, 0);\n\n\tbat_percent = data[7] & 0x7f;\n\tbat_charging = !!(data[7] & 0x80);\n\n\tif (data[9] | data[10] | (data[11] & 0x03) | data[12])\n\t\tinput_report_abs(input, ABS_MISC, PAD_DEVICE_ID);\n\telse\n\t\tinput_report_abs(input, ABS_MISC, 0);\n\n\tinput_event(input, EV_MSC, MSC_SERIAL, serial);\n\n\tinput_sync(input);\n\n\t \n\ttouch_ring_mode = (data[11] & 0xC0) >> 6;\n\n\tfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\n\t\tif (remote->remotes[i].serial == serial)\n\t\t\twacom->led.groups[i].select = touch_ring_mode;\n\t}\n\n\t__wacom_notify_battery(&remote->remotes[index].battery,\n\t\t\t\tWACOM_POWER_SUPPLY_STATUS_AUTO, bat_percent,\n\t\t\t\tbat_charging, 1, bat_charging);\n\nout:\n\tspin_unlock_irqrestore(&remote->remote_lock, flags);\n\treturn 0;\n}\n\nstatic void wacom_remote_status_irq(struct wacom_wac *wacom_wac, size_t len)\n{\n\tstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\n\tunsigned char *data = wacom_wac->data;\n\tstruct wacom_remote *remote = wacom->remote;\n\tstruct wacom_remote_work_data remote_data;\n\tunsigned long flags;\n\tint i, ret;\n\n\tif (data[0] != WACOM_REPORT_DEVICE_LIST)\n\t\treturn;\n\n\tmemset(&remote_data, 0, sizeof(struct wacom_remote_work_data));\n\n\tfor (i = 0; i < WACOM_MAX_REMOTES; i++) {\n\t\tint j = i * 6;\n\t\tint serial = (data[j+6] << 16) + (data[j+5] << 8) + data[j+4];\n\n\t\tremote_data.remote[i].serial = serial;\n\t}\n\n\tspin_lock_irqsave(&remote->remote_lock, flags);\n\n\tret = kfifo_in(&remote->remote_fifo, &remote_data, sizeof(remote_data));\n\tif (ret != sizeof(remote_data)) {\n\t\tspin_unlock_irqrestore(&remote->remote_lock, flags);\n\t\thid_err(wacom->hdev, \"Can't queue Remote status event.\\n\");\n\t\treturn;\n\t}\n\n\tspin_unlock_irqrestore(&remote->remote_lock, flags);\n\n\twacom_schedule_work(wacom_wac, WACOM_WORKER_REMOTE);\n}\n\nstatic int int_dist(int x1, int y1, int x2, int y2)\n{\n\tint x = x2 - x1;\n\tint y = y2 - y1;\n\n\treturn int_sqrt(x*x + y*y);\n}\n\nstatic void wacom_intuos_bt_process_data(struct wacom_wac *wacom,\n\t\tunsigned char *data)\n{\n\tmemcpy(wacom->data, data, 10);\n\twacom_intuos_irq(wacom);\n\n\tinput_sync(wacom->pen_input);\n\tif (wacom->pad_input)\n\t\tinput_sync(wacom->pad_input);\n}\n\nstatic int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)\n{\n\tunsigned char data[WACOM_PKGLEN_MAX];\n\tint i = 1;\n\tunsigned power_raw, battery_capacity, bat_charging, ps_connected;\n\n\tmemcpy(data, wacom->data, len);\n\n\tswitch (data[0]) {\n\tcase 0x04:\n\t\twacom_intuos_bt_process_data(wacom, data + i);\n\t\ti += 10;\n\t\tfallthrough;\n\tcase 0x03:\n\t\twacom_intuos_bt_process_data(wacom, data + i);\n\t\ti += 10;\n\t\twacom_intuos_bt_process_data(wacom, data + i);\n\t\ti += 10;\n\t\tpower_raw = data[i];\n\t\tbat_charging = (power_raw & 0x08) ? 1 : 0;\n\t\tps_connected = (power_raw & 0x10) ? 1 : 0;\n\t\tbattery_capacity = batcap_i4[power_raw & 0x07];\n\t\twacom_notify_battery(wacom, WACOM_POWER_SUPPLY_STATUS_AUTO,\n\t\t\t\t     battery_capacity, bat_charging,\n\t\t\t\t     battery_capacity || bat_charging,\n\t\t\t\t     ps_connected);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(wacom->pen_input->dev.parent,\n\t\t\t\t\"Unknown report: %d,%d size:%zu\\n\",\n\t\t\t\tdata[0], data[1], len);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int wacom_wac_finger_count_touches(struct wacom_wac *wacom)\n{\n\tstruct input_dev *input = wacom->touch_input;\n\tunsigned touch_max = wacom->features.touch_max;\n\tint count = 0;\n\tint i;\n\n\tif (!touch_max)\n\t\treturn 0;\n\n\tif (touch_max == 1)\n\t\treturn test_bit(BTN_TOUCH, input->key) &&\n\t\t\treport_touch_events(wacom);\n\n\tfor (i = 0; i < input->mt->num_slots; i++) {\n\t\tstruct input_mt_slot *ps = &input->mt->slots[i];\n\t\tint id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);\n\t\tif (id >= 0)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic void wacom_intuos_pro2_bt_pen(struct wacom_wac *wacom)\n{\n\tint pen_frame_len, pen_frames;\n\n\tstruct input_dev *pen_input = wacom->pen_input;\n\tunsigned char *data = wacom->data;\n\tint number_of_valid_frames = 0;\n\tktime_t time_interval = 15000000;\n\tktime_t time_packet_received = ktime_get();\n\tint i;\n\n\tif (wacom->features.type == INTUOSP2_BT ||\n\t    wacom->features.type == INTUOSP2S_BT) {\n\t\twacom->serial[0] = get_unaligned_le64(&data[99]);\n\t\twacom->id[0]     = get_unaligned_le16(&data[107]);\n\t\tpen_frame_len = 14;\n\t\tpen_frames = 7;\n\t} else {\n\t\twacom->serial[0] = get_unaligned_le64(&data[33]);\n\t\twacom->id[0]     = get_unaligned_le16(&data[41]);\n\t\tpen_frame_len = 8;\n\t\tpen_frames = 4;\n\t}\n\n\tif (wacom->serial[0] >> 52 == 1) {\n\t\t \n\t\twacom->id[0] |= (wacom->serial[0] >> 32) & 0xFFFFF;\n\t}\n\n\t \n\tfor (i = 0; i < pen_frames; i++) {\n\t\tunsigned char *frame = &data[i*pen_frame_len + 1];\n\t\tbool valid = frame[0] & 0x80;\n\n\t\tif (valid)\n\t\t\tnumber_of_valid_frames++;\n\t}\n\n\tif (number_of_valid_frames) {\n\t\tif (wacom->hid_data.time_delayed)\n\t\t\ttime_interval = ktime_get() - wacom->hid_data.time_delayed;\n\t\ttime_interval = div_u64(time_interval, number_of_valid_frames);\n\t\twacom->hid_data.time_delayed = time_packet_received;\n\t}\n\n\tfor (i = 0; i < number_of_valid_frames; i++) {\n\t\tunsigned char *frame = &data[i*pen_frame_len + 1];\n\t\tbool valid = frame[0] & 0x80;\n\t\tbool prox = frame[0] & 0x40;\n\t\tbool range = frame[0] & 0x20;\n\t\tbool invert = frame[0] & 0x10;\n\t\tint frames_number_reversed = number_of_valid_frames - i - 1;\n\t\tktime_t event_timestamp = time_packet_received - frames_number_reversed * time_interval;\n\n\t\tif (!valid)\n\t\t\tcontinue;\n\n\t\tif (!prox) {\n\t\t\twacom->shared->stylus_in_proximity = false;\n\t\t\twacom_exit_report(wacom);\n\t\t\tinput_sync(pen_input);\n\n\t\t\twacom->tool[0] = 0;\n\t\t\twacom->id[0] = 0;\n\t\t\twacom->serial[0] = 0;\n\t\t\twacom->hid_data.time_delayed = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (range) {\n\t\t\tif (!wacom->tool[0]) {  \n\t\t\t\t \n\t\t\t\tif (invert)\n\t\t\t\t\twacom->tool[0] = BTN_TOOL_RUBBER;\n\t\t\t\telse if (wacom->id[0])\n\t\t\t\t\twacom->tool[0] = wacom_intuos_get_tool_type(wacom->id[0]);\n\t\t\t\telse\n\t\t\t\t\twacom->tool[0] = BTN_TOOL_PEN;\n\t\t\t}\n\n\t\t\tinput_report_abs(pen_input, ABS_X, get_unaligned_le16(&frame[1]));\n\t\t\tinput_report_abs(pen_input, ABS_Y, get_unaligned_le16(&frame[3]));\n\n\t\t\tif (wacom->features.type == INTUOSP2_BT ||\n\t\t\t    wacom->features.type == INTUOSP2S_BT) {\n\t\t\t\t \n\t\t\t\tint16_t rotation =\n\t\t\t\t\t(int16_t)get_unaligned_le16(&frame[9]);\n\t\t\t\trotation += 1800/4;\n\n\t\t\t\tif (rotation > 899)\n\t\t\t\t\trotation -= 1800;\n\n\t\t\t\tinput_report_abs(pen_input, ABS_TILT_X,\n\t\t\t\t\t\t (char)frame[7]);\n\t\t\t\tinput_report_abs(pen_input, ABS_TILT_Y,\n\t\t\t\t\t\t (char)frame[8]);\n\t\t\t\tinput_report_abs(pen_input, ABS_Z, rotation);\n\t\t\t\tinput_report_abs(pen_input, ABS_WHEEL,\n\t\t\t\t\t\t get_unaligned_le16(&frame[11]));\n\t\t\t}\n\t\t}\n\n\t\tif (wacom->tool[0]) {\n\t\t\tinput_report_abs(pen_input, ABS_PRESSURE, get_unaligned_le16(&frame[5]));\n\t\t\tif (wacom->features.type == INTUOSP2_BT ||\n\t\t\t    wacom->features.type == INTUOSP2S_BT) {\n\t\t\t\tinput_report_abs(pen_input, ABS_DISTANCE,\n\t\t\t\t\t\t range ? frame[13] : wacom->features.distance_max);\n\t\t\t} else {\n\t\t\t\tinput_report_abs(pen_input, ABS_DISTANCE,\n\t\t\t\t\t\t range ? frame[7] : wacom->features.distance_max);\n\t\t\t}\n\n\t\t\tinput_report_key(pen_input, BTN_TOUCH, frame[0] & 0x09);\n\t\t\tinput_report_key(pen_input, BTN_STYLUS, frame[0] & 0x02);\n\t\t\tinput_report_key(pen_input, BTN_STYLUS2, frame[0] & 0x04);\n\n\t\t\tinput_report_key(pen_input, wacom->tool[0], prox);\n\t\t\tinput_event(pen_input, EV_MSC, MSC_SERIAL, wacom->serial[0]);\n\t\t\tinput_report_abs(pen_input, ABS_MISC,\n\t\t\t\t\t wacom_intuos_id_mangle(wacom->id[0]));  \n\t\t}\n\n\t\twacom->shared->stylus_in_proximity = prox;\n\n\t\t \n\t\tinput_set_timestamp(pen_input, event_timestamp);\n\n\t\tinput_sync(pen_input);\n\t}\n}\n\nstatic void wacom_intuos_pro2_bt_touch(struct wacom_wac *wacom)\n{\n\tconst int finger_touch_len = 8;\n\tconst int finger_frames = 4;\n\tconst int finger_frame_len = 43;\n\n\tstruct input_dev *touch_input = wacom->touch_input;\n\tunsigned char *data = wacom->data;\n\tint num_contacts_left = 5;\n\tint i, j;\n\n\tfor (i = 0; i < finger_frames; i++) {\n\t\tunsigned char *frame = &data[i*finger_frame_len + 109];\n\t\tint current_num_contacts = frame[0] & 0x7F;\n\t\tint contacts_to_send;\n\n\t\tif (!(frame[0] & 0x80))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (current_num_contacts)\n\t\t\twacom->num_contacts_left = current_num_contacts;\n\n\t\tcontacts_to_send = min(num_contacts_left, wacom->num_contacts_left);\n\n\t\tfor (j = 0; j < contacts_to_send; j++) {\n\t\t\tunsigned char *touch = &frame[j*finger_touch_len + 1];\n\t\t\tint slot = input_mt_get_slot_by_key(touch_input, touch[0]);\n\t\t\tint x = get_unaligned_le16(&touch[2]);\n\t\t\tint y = get_unaligned_le16(&touch[4]);\n\t\t\tint w = touch[6] * input_abs_get_res(touch_input, ABS_MT_POSITION_X);\n\t\t\tint h = touch[7] * input_abs_get_res(touch_input, ABS_MT_POSITION_Y);\n\n\t\t\tif (slot < 0)\n\t\t\t\tcontinue;\n\n\t\t\tinput_mt_slot(touch_input, slot);\n\t\t\tinput_mt_report_slot_state(touch_input, MT_TOOL_FINGER, touch[1] & 0x01);\n\t\t\tinput_report_abs(touch_input, ABS_MT_POSITION_X, x);\n\t\t\tinput_report_abs(touch_input, ABS_MT_POSITION_Y, y);\n\t\t\tinput_report_abs(touch_input, ABS_MT_TOUCH_MAJOR, max(w, h));\n\t\t\tinput_report_abs(touch_input, ABS_MT_TOUCH_MINOR, min(w, h));\n\t\t\tinput_report_abs(touch_input, ABS_MT_ORIENTATION, w > h);\n\t\t}\n\n\t\tinput_mt_sync_frame(touch_input);\n\n\t\twacom->num_contacts_left -= contacts_to_send;\n\t\tif (wacom->num_contacts_left <= 0) {\n\t\t\twacom->num_contacts_left = 0;\n\t\t\twacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\n\t\t\tinput_sync(touch_input);\n\t\t}\n\t}\n\n\tif (wacom->num_contacts_left == 0) {\n\t\t \n\t\t \n\t\tinput_report_switch(touch_input, SW_MUTE_DEVICE, !(data[281] >> 7));\n\t\tinput_sync(touch_input);\n\t}\n\n}\n\nstatic void wacom_intuos_pro2_bt_pad(struct wacom_wac *wacom)\n{\n\tstruct input_dev *pad_input = wacom->pad_input;\n\tunsigned char *data = wacom->data;\n\tint nbuttons = wacom->features.numbered_buttons;\n\n\tint expresskeys = data[282];\n\tint center = (data[281] & 0x40) >> 6;\n\tint ring = data[285] & 0x7F;\n\tbool ringstatus = data[285] & 0x80;\n\tbool prox = expresskeys || center || ringstatus;\n\n\t \n\tring = 71 - ring;\n\tring += 3*72/16;\n\tif (ring > 71)\n\t\tring -= 72;\n\n\twacom_report_numbered_buttons(pad_input, nbuttons,\n                                      expresskeys | (center << (nbuttons - 1)));\n\n\tinput_report_abs(pad_input, ABS_WHEEL, ringstatus ? ring : 0);\n\n\tinput_report_key(pad_input, wacom->tool[1], prox ? 1 : 0);\n\tinput_report_abs(pad_input, ABS_MISC, prox ? PAD_DEVICE_ID : 0);\n\tinput_event(pad_input, EV_MSC, MSC_SERIAL, 0xffffffff);\n\n\tinput_sync(pad_input);\n}\n\nstatic void wacom_intuos_pro2_bt_battery(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\n\tbool chg = data[284] & 0x80;\n\tint battery_status = data[284] & 0x7F;\n\n\twacom_notify_battery(wacom, WACOM_POWER_SUPPLY_STATUS_AUTO,\n\t\t\t     battery_status, chg, 1, chg);\n}\n\nstatic void wacom_intuos_gen3_bt_pad(struct wacom_wac *wacom)\n{\n\tstruct input_dev *pad_input = wacom->pad_input;\n\tunsigned char *data = wacom->data;\n\n\tint buttons = data[44];\n\n\twacom_report_numbered_buttons(pad_input, 4, buttons);\n\n\tinput_report_key(pad_input, wacom->tool[1], buttons ? 1 : 0);\n\tinput_report_abs(pad_input, ABS_MISC, buttons ? PAD_DEVICE_ID : 0);\n\tinput_event(pad_input, EV_MSC, MSC_SERIAL, 0xffffffff);\n\n\tinput_sync(pad_input);\n}\n\nstatic void wacom_intuos_gen3_bt_battery(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\n\tbool chg = data[45] & 0x80;\n\tint battery_status = data[45] & 0x7F;\n\n\twacom_notify_battery(wacom, WACOM_POWER_SUPPLY_STATUS_AUTO,\n\t\t\t     battery_status, chg, 1, chg);\n}\n\nstatic int wacom_intuos_pro2_bt_irq(struct wacom_wac *wacom, size_t len)\n{\n\tunsigned char *data = wacom->data;\n\n\tif (data[0] != 0x80 && data[0] != 0x81) {\n\t\tdev_dbg(wacom->pen_input->dev.parent,\n\t\t\t\"%s: received unknown report #%d\\n\", __func__, data[0]);\n\t\treturn 0;\n\t}\n\n\twacom_intuos_pro2_bt_pen(wacom);\n\tif (wacom->features.type == INTUOSP2_BT ||\n\t    wacom->features.type == INTUOSP2S_BT) {\n\t\twacom_intuos_pro2_bt_touch(wacom);\n\t\twacom_intuos_pro2_bt_pad(wacom);\n\t\twacom_intuos_pro2_bt_battery(wacom);\n\t} else {\n\t\twacom_intuos_gen3_bt_pad(wacom);\n\t\twacom_intuos_gen3_bt_battery(wacom);\n\t}\n\treturn 0;\n}\n\nstatic int wacom_24hdt_irq(struct wacom_wac *wacom)\n{\n\tstruct input_dev *input = wacom->touch_input;\n\tunsigned char *data = wacom->data;\n\tint i;\n\tint current_num_contacts = data[61];\n\tint contacts_to_send = 0;\n\tint num_contacts_left = 4;  \n\tint byte_per_packet = WACOM_BYTES_PER_24HDT_PACKET;\n\tint y_offset = 2;\n\n\tif (touch_is_muted(wacom) && !wacom->shared->touch_down)\n\t\treturn 0;\n\n\tif (wacom->features.type == WACOM_27QHDT) {\n\t\tcurrent_num_contacts = data[63];\n\t\tnum_contacts_left = 10;\n\t\tbyte_per_packet = WACOM_BYTES_PER_QHDTHID_PACKET;\n\t\ty_offset = 0;\n\t}\n\n\t \n\tif (current_num_contacts)\n\t\twacom->num_contacts_left = current_num_contacts;\n\n\tcontacts_to_send = min(num_contacts_left, wacom->num_contacts_left);\n\n\tfor (i = 0; i < contacts_to_send; i++) {\n\t\tint offset = (byte_per_packet * i) + 1;\n\t\tbool touch = (data[offset] & 0x1) && report_touch_events(wacom);\n\t\tint slot = input_mt_get_slot_by_key(input, data[offset + 1]);\n\n\t\tif (slot < 0)\n\t\t\tcontinue;\n\t\tinput_mt_slot(input, slot);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\n\n\t\tif (touch) {\n\t\t\tint t_x = get_unaligned_le16(&data[offset + 2]);\n\t\t\tint t_y = get_unaligned_le16(&data[offset + 4 + y_offset]);\n\n\t\t\tinput_report_abs(input, ABS_MT_POSITION_X, t_x);\n\t\t\tinput_report_abs(input, ABS_MT_POSITION_Y, t_y);\n\n\t\t\tif (wacom->features.type != WACOM_27QHDT) {\n\t\t\t\tint c_x = get_unaligned_le16(&data[offset + 4]);\n\t\t\t\tint c_y = get_unaligned_le16(&data[offset + 8]);\n\t\t\t\tint w = get_unaligned_le16(&data[offset + 10]);\n\t\t\t\tint h = get_unaligned_le16(&data[offset + 12]);\n\n\t\t\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, min(w,h));\n\t\t\t\tinput_report_abs(input, ABS_MT_WIDTH_MAJOR,\n\t\t\t\t\t\t min(w, h) + int_dist(t_x, t_y, c_x, c_y));\n\t\t\t\tinput_report_abs(input, ABS_MT_WIDTH_MINOR, min(w, h));\n\t\t\t\tinput_report_abs(input, ABS_MT_ORIENTATION, w > h);\n\t\t\t}\n\t\t}\n\t}\n\tinput_mt_sync_frame(input);\n\n\twacom->num_contacts_left -= contacts_to_send;\n\tif (wacom->num_contacts_left <= 0) {\n\t\twacom->num_contacts_left = 0;\n\t\twacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\n\t}\n\treturn 1;\n}\n\nstatic int wacom_mt_touch(struct wacom_wac *wacom)\n{\n\tstruct input_dev *input = wacom->touch_input;\n\tunsigned char *data = wacom->data;\n\tint i;\n\tint current_num_contacts = data[2];\n\tint contacts_to_send = 0;\n\tint x_offset = 0;\n\n\t \n\tif (wacom->features.type == MTTPC || wacom->features.type == MTTPC_B)\n\t\tx_offset = -4;\n\n\t \n\tif (current_num_contacts)\n\t\twacom->num_contacts_left = current_num_contacts;\n\n\t \n\tcontacts_to_send = min(5, wacom->num_contacts_left);\n\n\tfor (i = 0; i < contacts_to_send; i++) {\n\t\tint offset = (WACOM_BYTES_PER_MT_PACKET + x_offset) * i + 3;\n\t\tbool touch = (data[offset] & 0x1) && report_touch_events(wacom);\n\t\tint id = get_unaligned_le16(&data[offset + 1]);\n\t\tint slot = input_mt_get_slot_by_key(input, id);\n\n\t\tif (slot < 0)\n\t\t\tcontinue;\n\n\t\tinput_mt_slot(input, slot);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\n\t\tif (touch) {\n\t\t\tint x = get_unaligned_le16(&data[offset + x_offset + 7]);\n\t\t\tint y = get_unaligned_le16(&data[offset + x_offset + 9]);\n\t\t\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\t\t\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\t\t}\n\t}\n\tinput_mt_sync_frame(input);\n\n\twacom->num_contacts_left -= contacts_to_send;\n\tif (wacom->num_contacts_left <= 0) {\n\t\twacom->num_contacts_left = 0;\n\t\twacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\n\t}\n\treturn 1;\n}\n\nstatic int wacom_tpc_mt_touch(struct wacom_wac *wacom)\n{\n\tstruct input_dev *input = wacom->touch_input;\n\tunsigned char *data = wacom->data;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tint p = data[1] & (1 << i);\n\t\tbool touch = p && report_touch_events(wacom);\n\n\t\tinput_mt_slot(input, i);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\n\t\tif (touch) {\n\t\t\tint x = le16_to_cpup((__le16 *)&data[i * 2 + 2]) & 0x7fff;\n\t\t\tint y = le16_to_cpup((__le16 *)&data[i * 2 + 6]) & 0x7fff;\n\n\t\t\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\t\t\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\t\t}\n\t}\n\tinput_mt_sync_frame(input);\n\n\t \n\twacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\n\n\treturn 1;\n}\n\nstatic int wacom_tpc_single_touch(struct wacom_wac *wacom, size_t len)\n{\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->touch_input;\n\tbool prox = report_touch_events(wacom);\n\tint x = 0, y = 0;\n\n\tif (wacom->features.touch_max > 1 || len > WACOM_PKGLEN_TPC2FG)\n\t\treturn 0;\n\n\tif (len == WACOM_PKGLEN_TPC1FG) {\n\t\tprox = prox && (data[0] & 0x01);\n\t\tx = get_unaligned_le16(&data[1]);\n\t\ty = get_unaligned_le16(&data[3]);\n\t} else if (len == WACOM_PKGLEN_TPC1FG_B) {\n\t\tprox = prox && (data[2] & 0x01);\n\t\tx = get_unaligned_le16(&data[3]);\n\t\ty = get_unaligned_le16(&data[5]);\n\t} else {\n\t\tprox = prox && (data[1] & 0x01);\n\t\tx = le16_to_cpup((__le16 *)&data[2]);\n\t\ty = le16_to_cpup((__le16 *)&data[4]);\n\t}\n\n\tif (prox) {\n\t\tinput_report_abs(input, ABS_X, x);\n\t\tinput_report_abs(input, ABS_Y, y);\n\t}\n\tinput_report_key(input, BTN_TOUCH, prox);\n\n\t \n\twacom->shared->touch_down = prox;\n\n\treturn 1;\n}\n\nstatic int wacom_tpc_pen(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\tstruct input_dev *input = wacom->pen_input;\n\tbool prox = data[1] & 0x20;\n\n\tif (!wacom->shared->stylus_in_proximity)  \n\t\t \n\t\twacom->tool[0] = (data[1] & 0x0c) ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\n\n\t \n\twacom->shared->stylus_in_proximity = prox;\n\n\t \n\tif (!delay_pen_events(wacom)) {\n\t\tinput_report_key(input, BTN_STYLUS, data[1] & 0x02);\n\t\tinput_report_key(input, BTN_STYLUS2, data[1] & 0x10);\n\t\tinput_report_abs(input, ABS_X, le16_to_cpup((__le16 *)&data[2]));\n\t\tinput_report_abs(input, ABS_Y, le16_to_cpup((__le16 *)&data[4]));\n\t\tinput_report_abs(input, ABS_PRESSURE, ((data[7] & 0x07) << 8) | data[6]);\n\t\tinput_report_key(input, BTN_TOUCH, data[1] & 0x05);\n\t\tinput_report_key(input, wacom->tool[0], prox);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int wacom_tpc_irq(struct wacom_wac *wacom, size_t len)\n{\n\tunsigned char *data = wacom->data;\n\n\tif (wacom->pen_input) {\n\t\tdev_dbg(wacom->pen_input->dev.parent,\n\t\t\t\"%s: received report #%d\\n\", __func__, data[0]);\n\n\t\tif (len == WACOM_PKGLEN_PENABLED ||\n\t\t    data[0] == WACOM_REPORT_PENABLED)\n\t\t\treturn wacom_tpc_pen(wacom);\n\t}\n\telse if (wacom->touch_input) {\n\t\tdev_dbg(wacom->touch_input->dev.parent,\n\t\t\t\"%s: received report #%d\\n\", __func__, data[0]);\n\n\t\tswitch (len) {\n\t\tcase WACOM_PKGLEN_TPC1FG:\n\t\t\treturn wacom_tpc_single_touch(wacom, len);\n\n\t\tcase WACOM_PKGLEN_TPC2FG:\n\t\t\treturn wacom_tpc_mt_touch(wacom);\n\n\t\tdefault:\n\t\t\tswitch (data[0]) {\n\t\t\tcase WACOM_REPORT_TPC1FG:\n\t\t\tcase WACOM_REPORT_TPCHID:\n\t\t\tcase WACOM_REPORT_TPCST:\n\t\t\tcase WACOM_REPORT_TPC1FGE:\n\t\t\t\treturn wacom_tpc_single_touch(wacom, len);\n\n\t\t\tcase WACOM_REPORT_TPCMT:\n\t\t\tcase WACOM_REPORT_TPCMT2:\n\t\t\t\treturn wacom_mt_touch(wacom);\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wacom_offset_rotation(struct input_dev *input, struct hid_usage *usage,\n\t\t\t\t int value, int num, int denom)\n{\n\tstruct input_absinfo *abs = &input->absinfo[usage->code];\n\tint range = (abs->maximum - abs->minimum + 1);\n\n\tvalue += num*range/denom;\n\tif (value > abs->maximum)\n\t\tvalue -= range;\n\telse if (value < abs->minimum)\n\t\tvalue += range;\n\treturn value;\n}\n\nint wacom_equivalent_usage(int usage)\n{\n\tif ((usage & HID_USAGE_PAGE) == WACOM_HID_UP_WACOMDIGITIZER) {\n\t\tint subpage = (usage & 0xFF00) << 8;\n\t\tint subusage = (usage & 0xFF);\n\n\t\tif (subpage == WACOM_HID_SP_PAD ||\n\t\t    subpage == WACOM_HID_SP_BUTTON ||\n\t\t    subpage == WACOM_HID_SP_DIGITIZER ||\n\t\t    subpage == WACOM_HID_SP_DIGITIZERINFO ||\n\t\t    usage == WACOM_HID_WD_SENSE ||\n\t\t    usage == WACOM_HID_WD_SERIALHI ||\n\t\t    usage == WACOM_HID_WD_TOOLTYPE ||\n\t\t    usage == WACOM_HID_WD_DISTANCE ||\n\t\t    usage == WACOM_HID_WD_TOUCHSTRIP ||\n\t\t    usage == WACOM_HID_WD_TOUCHSTRIP2 ||\n\t\t    usage == WACOM_HID_WD_TOUCHRING ||\n\t\t    usage == WACOM_HID_WD_TOUCHRINGSTATUS ||\n\t\t    usage == WACOM_HID_WD_REPORT_VALID ||\n\t\t    usage == WACOM_HID_WD_BARRELSWITCH3 ||\n\t\t    usage == WACOM_HID_WD_SEQUENCENUMBER) {\n\t\t\treturn usage;\n\t\t}\n\n\t\tif (subpage == HID_UP_UNDEFINED)\n\t\t\tsubpage = HID_UP_DIGITIZER;\n\n\t\treturn subpage | subusage;\n\t}\n\n\tif ((usage & HID_USAGE_PAGE) == WACOM_HID_UP_WACOMTOUCH) {\n\t\tint subpage = (usage & 0xFF00) << 8;\n\t\tint subusage = (usage & 0xFF);\n\n\t\tif (usage == WACOM_HID_WT_REPORT_VALID)\n\t\t\treturn usage;\n\n\t\tif (subpage == HID_UP_UNDEFINED)\n\t\t\tsubpage = WACOM_HID_SP_DIGITIZER;\n\n\t\treturn subpage | subusage;\n\t}\n\n\treturn usage;\n}\n\nstatic void wacom_map_usage(struct input_dev *input, struct hid_usage *usage,\n\t\tstruct hid_field *field, __u8 type, __u16 code, int fuzz)\n{\n\tstruct wacom *wacom = input_get_drvdata(input);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tint fmin = field->logical_minimum;\n\tint fmax = field->logical_maximum;\n\tunsigned int equivalent_usage = wacom_equivalent_usage(usage->hid);\n\tint resolution_code = code;\n\tint resolution = hidinput_calc_abs_res(field, resolution_code);\n\n\tif (equivalent_usage == HID_DG_TWIST) {\n\t\tresolution_code = ABS_RZ;\n\t}\n\n\tif (equivalent_usage == HID_GD_X) {\n\t\tfmin += features->offset_left;\n\t\tfmax -= features->offset_right;\n\t}\n\tif (equivalent_usage == HID_GD_Y) {\n\t\tfmin += features->offset_top;\n\t\tfmax -= features->offset_bottom;\n\t}\n\n\tusage->type = type;\n\tusage->code = code;\n\n\tswitch (type) {\n\tcase EV_ABS:\n\t\tinput_set_abs_params(input, code, fmin, fmax, fuzz, 0);\n\n\t\t \n\t\tif ((code == ABS_X || code == ABS_Y) && !resolution) {\n\t\t\tresolution = WACOM_INTUOS_RES;\n\t\t\thid_warn(input,\n\t\t\t\t \"Wacom usage (%d) missing resolution \\n\",\n\t\t\t\t code);\n\t\t}\n\t\tinput_abs_set_res(input, code, resolution);\n\t\tbreak;\n\tcase EV_KEY:\n\tcase EV_MSC:\n\tcase EV_SW:\n\t\tinput_set_capability(input, type, code);\n\t\tbreak;\n\t}\n}\n\nstatic void wacom_wac_battery_usage_mapping(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\treturn;\n}\n\nstatic void wacom_wac_battery_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tunsigned equivalent_usage = wacom_equivalent_usage(usage->hid);\n\n\tswitch (equivalent_usage) {\n\tcase HID_DG_BATTERYSTRENGTH:\n\t\tif (value == 0) {\n\t\t\twacom_wac->hid_data.bat_status = POWER_SUPPLY_STATUS_UNKNOWN;\n\t\t}\n\t\telse {\n\t\t\tvalue = value * 100 / (field->logical_maximum - field->logical_minimum);\n\t\t\twacom_wac->hid_data.battery_capacity = value;\n\t\t\twacom_wac->hid_data.bat_connected = 1;\n\t\t\twacom_wac->hid_data.bat_status = WACOM_POWER_SUPPLY_STATUS_AUTO;\n\t\t}\n\t\twacom_wac->features.quirks |= WACOM_QUIRK_BATTERY;\n\t\tbreak;\n\tcase WACOM_HID_WD_BATTERY_LEVEL:\n\t\tvalue = value * 100 / (field->logical_maximum - field->logical_minimum);\n\t\twacom_wac->hid_data.battery_capacity = value;\n\t\twacom_wac->hid_data.bat_connected = 1;\n\t\twacom_wac->hid_data.bat_status = WACOM_POWER_SUPPLY_STATUS_AUTO;\n\t\twacom_wac->features.quirks |= WACOM_QUIRK_BATTERY;\n\t\tbreak;\n\tcase WACOM_HID_WD_BATTERY_CHARGING:\n\t\twacom_wac->hid_data.bat_charging = value;\n\t\twacom_wac->hid_data.ps_connected = value;\n\t\twacom_wac->hid_data.bat_connected = 1;\n\t\twacom_wac->hid_data.bat_status = WACOM_POWER_SUPPLY_STATUS_AUTO;\n\t\twacom_wac->features.quirks |= WACOM_QUIRK_BATTERY;\n\t\tbreak;\n\t}\n}\n\nstatic void wacom_wac_battery_pre_report(struct hid_device *hdev,\n\t\tstruct hid_report *report)\n{\n\treturn;\n}\n\nstatic void wacom_wac_battery_report(struct hid_device *hdev,\n\t\tstruct hid_report *report)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\n\tint status = wacom_wac->hid_data.bat_status;\n\tint capacity = wacom_wac->hid_data.battery_capacity;\n\tbool charging = wacom_wac->hid_data.bat_charging;\n\tbool connected = wacom_wac->hid_data.bat_connected;\n\tbool powered = wacom_wac->hid_data.ps_connected;\n\n\twacom_notify_battery(wacom_wac, status, capacity, charging,\n\t\t\t     connected, powered);\n}\n\nstatic void wacom_wac_pad_usage_mapping(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tstruct input_dev *input = wacom_wac->pad_input;\n\tunsigned equivalent_usage = wacom_equivalent_usage(usage->hid);\n\n\tswitch (equivalent_usage) {\n\tcase WACOM_HID_WD_ACCELEROMETER_X:\n\t\t__set_bit(INPUT_PROP_ACCELEROMETER, input->propbit);\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_X, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_ACCELEROMETER_Y:\n\t\t__set_bit(INPUT_PROP_ACCELEROMETER, input->propbit);\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_ACCELEROMETER_Z:\n\t\t__set_bit(INPUT_PROP_ACCELEROMETER, input->propbit);\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_Z, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_BUTTONCENTER:\n\tcase WACOM_HID_WD_BUTTONHOME:\n\tcase WACOM_HID_WD_BUTTONUP:\n\tcase WACOM_HID_WD_BUTTONDOWN:\n\tcase WACOM_HID_WD_BUTTONLEFT:\n\tcase WACOM_HID_WD_BUTTONRIGHT:\n\t\twacom_map_usage(input, usage, field, EV_KEY,\n\t\t\t\twacom_numbered_button_to_key(features->numbered_buttons),\n\t\t\t\t0);\n\t\tfeatures->numbered_buttons++;\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_MUTE_DEVICE:\n\t\t \n\t\twacom_wac->is_soft_touch_switch = true;\n\t\tfallthrough;\n\tcase WACOM_HID_WD_TOUCHONOFF:\n\t\t \n\t\twacom_wac->has_mute_touch_switch = true;\n\t\tusage->type = EV_SW;\n\t\tusage->code = SW_MUTE_DEVICE;\n\t\tbreak;\n\tcase WACOM_HID_WD_TOUCHSTRIP:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_RX, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_TOUCHSTRIP2:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_RY, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_TOUCHRING:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_WHEEL, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_TOUCHRINGSTATUS:\n\t\t \n\t\tusage->type = EV_ABS;\n\t\tusage->code = ABS_WHEEL;\n\t\tset_bit(EV_ABS, input->evbit);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_BUTTONCONFIG:\n\t\twacom_map_usage(input, usage, field, EV_KEY, KEY_BUTTONCONFIG, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_ONSCREEN_KEYBOARD:\n\t\twacom_map_usage(input, usage, field, EV_KEY, KEY_ONSCREEN_KEYBOARD, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_CONTROLPANEL:\n\t\twacom_map_usage(input, usage, field, EV_KEY, KEY_CONTROLPANEL, 0);\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\tcase WACOM_HID_WD_MODE_CHANGE:\n\t\t \n\t\tif (!wacom_wac->has_mode_change) {\n\t\t\twacom_wac->has_mode_change = true;\n\t\t\twacom_wac->is_direct_mode = true;\n\t\t}\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\t}\n\n\tswitch (equivalent_usage & 0xfffffff0) {\n\tcase WACOM_HID_WD_EXPRESSKEY00:\n\t\twacom_map_usage(input, usage, field, EV_KEY,\n\t\t\t\twacom_numbered_button_to_key(features->numbered_buttons),\n\t\t\t\t0);\n\t\tfeatures->numbered_buttons++;\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\tbreak;\n\t}\n}\n\nstatic void wacom_wac_pad_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct input_dev *input = wacom_wac->pad_input;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tunsigned equivalent_usage = wacom_equivalent_usage(usage->hid);\n\tint i;\n\tbool do_report = false;\n\n\t \n\tif (!usage->type && equivalent_usage != WACOM_HID_WD_MODE_CHANGE)\n\t\treturn;\n\n\tif (wacom_equivalent_usage(field->physical) == HID_DG_TABLETFUNCTIONKEY) {\n\t\tif (usage->hid != WACOM_HID_WD_TOUCHRING)\n\t\t\twacom_wac->hid_data.inrange_state |= value;\n\t}\n\n\t \n\tif ((equivalent_usage == WACOM_HID_WD_MUTE_DEVICE) ||\n\t   (equivalent_usage == WACOM_HID_WD_TOUCHONOFF)) {\n\t\tif (wacom_wac->shared->touch_input) {\n\t\t\tbool *is_touch_on = &wacom_wac->shared->is_touch_on;\n\n\t\t\tif (equivalent_usage == WACOM_HID_WD_MUTE_DEVICE && value)\n\t\t\t\t*is_touch_on = !(*is_touch_on);\n\t\t\telse if (equivalent_usage == WACOM_HID_WD_TOUCHONOFF)\n\t\t\t\t*is_touch_on = value;\n\n\t\t\tinput_report_switch(wacom_wac->shared->touch_input,\n\t\t\t\t\t    SW_MUTE_DEVICE, !(*is_touch_on));\n\t\t\tinput_sync(wacom_wac->shared->touch_input);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!input)\n\t\treturn;\n\n\tswitch (equivalent_usage) {\n\tcase WACOM_HID_WD_TOUCHRING:\n\t\t \n\t\tif (hdev->vendor == 0x56a &&\n\t\t    (hdev->product == 0x34d || hdev->product == 0x34e ||   \n\t\t     hdev->product == 0x357 || hdev->product == 0x358 ||   \n\t\t     hdev->product == 0x392 ||\t\t\t\t   \n\t\t     hdev->product == 0x398 || hdev->product == 0x399 ||   \n\t\t     hdev->product == 0x3AA)) {\t\t\t\t   \n\t\t\tvalue = (field->logical_maximum - value);\n\n\t\t\tif (hdev->product == 0x357 || hdev->product == 0x358 ||\n\t\t\t    hdev->product == 0x392)\n\t\t\t\tvalue = wacom_offset_rotation(input, usage, value, 3, 16);\n\t\t\telse if (hdev->product == 0x34d || hdev->product == 0x34e ||\n\t\t\t\t hdev->product == 0x398 || hdev->product == 0x399 ||\n\t\t\t\t hdev->product == 0x3AA)\n\t\t\t\tvalue = wacom_offset_rotation(input, usage, value, 1, 2);\n\t\t}\n\t\telse {\n\t\t\tvalue = wacom_offset_rotation(input, usage, value, 1, 4);\n\t\t}\n\t\tdo_report = true;\n\t\tbreak;\n\tcase WACOM_HID_WD_TOUCHRINGSTATUS:\n\t\tif (!value)\n\t\t\tinput_event(input, usage->type, usage->code, 0);\n\t\tbreak;\n\n\tcase WACOM_HID_WD_MODE_CHANGE:\n\t\tif (wacom_wac->is_direct_mode != value) {\n\t\t\twacom_wac->is_direct_mode = value;\n\t\t\twacom_schedule_work(&wacom->wacom_wac, WACOM_WORKER_MODE_CHANGE);\n\t\t}\n\t\tbreak;\n\n\tcase WACOM_HID_WD_BUTTONCENTER:\n\t\tfor (i = 0; i < wacom->led.count; i++)\n\t\t\twacom_update_led(wacom, features->numbered_buttons,\n\t\t\t\t\t value, i);\n\t\tfallthrough;\n\tdefault:\n\t\tdo_report = true;\n\t\tbreak;\n\t}\n\n\tif (do_report) {\n\t\tinput_event(input, usage->type, usage->code, value);\n\t\tif (value)\n\t\t\twacom_wac->hid_data.pad_input_event_flag = true;\n\t}\n}\n\nstatic void wacom_wac_pad_pre_report(struct hid_device *hdev,\n\t\tstruct hid_report *report)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\n\twacom_wac->hid_data.inrange_state = 0;\n}\n\nstatic void wacom_wac_pad_report(struct hid_device *hdev,\n\t\tstruct hid_report *report, struct hid_field *field)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct input_dev *input = wacom_wac->pad_input;\n\tbool active = wacom_wac->hid_data.inrange_state != 0;\n\n\t \n\tif (wacom_wac->hid_data.pad_input_event_flag) {\n\t\tinput_event(input, EV_ABS, ABS_MISC, active ? PAD_DEVICE_ID : 0);\n\t\tinput_sync(input);\n\t\tif (!active)\n\t\t\twacom_wac->hid_data.pad_input_event_flag = false;\n\t}\n}\n\nstatic void wacom_set_barrel_switch3_usage(struct wacom_wac *wacom_wac)\n{\n\tstruct input_dev *input = wacom_wac->pen_input;\n\tstruct wacom_features *features = &wacom_wac->features;\n\n\tif (!(features->quirks & WACOM_QUIRK_AESPEN) &&\n\t    wacom_wac->hid_data.barrelswitch &&\n\t    wacom_wac->hid_data.barrelswitch2 &&\n\t    wacom_wac->hid_data.serialhi &&\n\t    !wacom_wac->hid_data.barrelswitch3) {\n\t\tinput_set_capability(input, EV_KEY, BTN_STYLUS3);\n\t\tfeatures->quirks |= WACOM_QUIRK_PEN_BUTTON3;\n\t}\n}\n\nstatic void wacom_wac_pen_usage_mapping(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tstruct input_dev *input = wacom_wac->pen_input;\n\tunsigned equivalent_usage = wacom_equivalent_usage(usage->hid);\n\n\tswitch (equivalent_usage) {\n\tcase HID_GD_X:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);\n\t\tbreak;\n\tcase HID_GD_Y:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);\n\t\tbreak;\n\tcase WACOM_HID_WD_DISTANCE:\n\tcase HID_GD_Z:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_DISTANCE, 0);\n\t\tbreak;\n\tcase HID_DG_TIPPRESSURE:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_PRESSURE, 0);\n\t\tbreak;\n\tcase HID_DG_INRANGE:\n\t\twacom_map_usage(input, usage, field, EV_KEY, BTN_TOOL_PEN, 0);\n\t\tbreak;\n\tcase HID_DG_INVERT:\n\t\twacom_map_usage(input, usage, field, EV_KEY,\n\t\t\t\tBTN_TOOL_RUBBER, 0);\n\t\tbreak;\n\tcase HID_DG_TILT_X:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_TILT_X, 0);\n\t\tbreak;\n\tcase HID_DG_TILT_Y:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_TILT_Y, 0);\n\t\tbreak;\n\tcase HID_DG_TWIST:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_Z, 0);\n\t\tbreak;\n\tcase HID_DG_ERASER:\n\t\tinput_set_capability(input, EV_KEY, BTN_TOOL_RUBBER);\n\t\twacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);\n\t\tbreak;\n\tcase HID_DG_TIPSWITCH:\n\t\tinput_set_capability(input, EV_KEY, BTN_TOOL_PEN);\n\t\twacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);\n\t\tbreak;\n\tcase HID_DG_BARRELSWITCH:\n\t\twacom_wac->hid_data.barrelswitch = true;\n\t\twacom_set_barrel_switch3_usage(wacom_wac);\n\t\twacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS, 0);\n\t\tbreak;\n\tcase HID_DG_BARRELSWITCH2:\n\t\twacom_wac->hid_data.barrelswitch2 = true;\n\t\twacom_set_barrel_switch3_usage(wacom_wac);\n\t\twacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS2, 0);\n\t\tbreak;\n\tcase HID_DG_TOOLSERIALNUMBER:\n\t\tfeatures->quirks |= WACOM_QUIRK_TOOLSERIAL;\n\t\twacom_map_usage(input, usage, field, EV_MSC, MSC_SERIAL, 0);\n\t\tbreak;\n\tcase HID_DG_SCANTIME:\n\t\twacom_map_usage(input, usage, field, EV_MSC, MSC_TIMESTAMP, 0);\n\t\tbreak;\n\tcase WACOM_HID_WD_SENSE:\n\t\tfeatures->quirks |= WACOM_QUIRK_SENSE;\n\t\twacom_map_usage(input, usage, field, EV_KEY, BTN_TOOL_PEN, 0);\n\t\tbreak;\n\tcase WACOM_HID_WD_SERIALHI:\n\t\twacom_wac->hid_data.serialhi = true;\n\t\twacom_set_barrel_switch3_usage(wacom_wac);\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_MISC, 0);\n\t\tbreak;\n\tcase WACOM_HID_WD_FINGERWHEEL:\n\t\tinput_set_capability(input, EV_KEY, BTN_TOOL_AIRBRUSH);\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_WHEEL, 0);\n\t\tbreak;\n\tcase WACOM_HID_WD_BARRELSWITCH3:\n\t\twacom_wac->hid_data.barrelswitch3 = true;\n\t\twacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS3, 0);\n\t\tfeatures->quirks &= ~WACOM_QUIRK_PEN_BUTTON3;\n\t\tbreak;\n\t}\n}\n\nstatic void wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\tstruct input_dev *input = wacom_wac->pen_input;\n\tunsigned equivalent_usage = wacom_equivalent_usage(usage->hid);\n\n\tif (wacom_wac->is_invalid_bt_frame)\n\t\treturn;\n\n\tswitch (equivalent_usage) {\n\tcase HID_GD_Z:\n\t\t \n\t\tvalue = field->logical_maximum - value;\n\t\tbreak;\n\tcase HID_DG_INRANGE:\n\t\tmod_timer(&wacom->idleprox_timer, jiffies + msecs_to_jiffies(100));\n\t\twacom_wac->hid_data.inrange_state = value;\n\t\tif (!(features->quirks & WACOM_QUIRK_SENSE))\n\t\t\twacom_wac->hid_data.sense_state = value;\n\t\treturn;\n\tcase HID_DG_INVERT:\n\t\twacom_wac->hid_data.invert_state = value;\n\t\treturn;\n\tcase HID_DG_ERASER:\n\tcase HID_DG_TIPSWITCH:\n\t\twacom_wac->hid_data.tipswitch |= value;\n\t\treturn;\n\tcase HID_DG_BARRELSWITCH:\n\t\twacom_wac->hid_data.barrelswitch = value;\n\t\treturn;\n\tcase HID_DG_BARRELSWITCH2:\n\t\twacom_wac->hid_data.barrelswitch2 = value;\n\t\treturn;\n\tcase HID_DG_TOOLSERIALNUMBER:\n\t\tif (value) {\n\t\t\twacom_wac->serial[0] = (wacom_wac->serial[0] & ~0xFFFFFFFFULL);\n\t\t\twacom_wac->serial[0] |= wacom_s32tou(value, field->report_size);\n\t\t}\n\t\treturn;\n\tcase HID_DG_TWIST:\n\t\t \n\t\tif (!wacom_is_art_pen(wacom_wac->id[0])) return;\n\n\t\t \n\t\tvalue = wacom_offset_rotation(input, usage, value, 1, 4);\n\t\tbreak;\n\tcase WACOM_HID_WD_SENSE:\n\t\twacom_wac->hid_data.sense_state = value;\n\t\treturn;\n\tcase WACOM_HID_WD_SERIALHI:\n\t\tif (value) {\n\t\t\t__u32 raw_value = wacom_s32tou(value, field->report_size);\n\n\t\t\twacom_wac->serial[0] = (wacom_wac->serial[0] & 0xFFFFFFFF);\n\t\t\twacom_wac->serial[0] |= ((__u64)raw_value) << 32;\n\t\t\t \n\t\t\tif (value >> 20 == 1) {\n\t\t\t\twacom_wac->id[0] |= raw_value & 0xFFFFF;\n\t\t\t}\n\t\t}\n\t\treturn;\n\tcase WACOM_HID_WD_TOOLTYPE:\n\t\t \n\t\twacom_wac->id[0] |= wacom_s32tou(value, field->report_size);\n\t\treturn;\n\tcase WACOM_HID_WD_OFFSETLEFT:\n\t\tif (features->offset_left && value != features->offset_left)\n\t\t\thid_warn(hdev, \"%s: overriding existing left offset \"\n\t\t\t\t \"%d -> %d\\n\", __func__, value,\n\t\t\t\t features->offset_left);\n\t\tfeatures->offset_left = value;\n\t\treturn;\n\tcase WACOM_HID_WD_OFFSETRIGHT:\n\t\tif (features->offset_right && value != features->offset_right)\n\t\t\thid_warn(hdev, \"%s: overriding existing right offset \"\n\t\t\t\t \"%d -> %d\\n\", __func__, value,\n\t\t\t\t features->offset_right);\n\t\tfeatures->offset_right = value;\n\t\treturn;\n\tcase WACOM_HID_WD_OFFSETTOP:\n\t\tif (features->offset_top && value != features->offset_top)\n\t\t\thid_warn(hdev, \"%s: overriding existing top offset \"\n\t\t\t\t \"%d -> %d\\n\", __func__, value,\n\t\t\t\t features->offset_top);\n\t\tfeatures->offset_top = value;\n\t\treturn;\n\tcase WACOM_HID_WD_OFFSETBOTTOM:\n\t\tif (features->offset_bottom && value != features->offset_bottom)\n\t\t\thid_warn(hdev, \"%s: overriding existing bottom offset \"\n\t\t\t\t \"%d -> %d\\n\", __func__, value,\n\t\t\t\t features->offset_bottom);\n\t\tfeatures->offset_bottom = value;\n\t\treturn;\n\tcase WACOM_HID_WD_REPORT_VALID:\n\t\twacom_wac->is_invalid_bt_frame = !value;\n\t\treturn;\n\tcase WACOM_HID_WD_BARRELSWITCH3:\n\t\twacom_wac->hid_data.barrelswitch3 = value;\n\t\treturn;\n\tcase WACOM_HID_WD_SEQUENCENUMBER:\n\t\tif (wacom_wac->hid_data.sequence_number != value)\n\t\t\thid_warn(hdev, \"Dropped %hu packets\", (unsigned short)(value - wacom_wac->hid_data.sequence_number));\n\t\twacom_wac->hid_data.sequence_number = value + 1;\n\t\treturn;\n\t}\n\n\t \n\tif (!usage->type || delay_pen_events(wacom_wac))\n\t\treturn;\n\n\t \n\tif (wacom_wac->hid_data.inrange_state)\n\t\tinput_event(input, usage->type, usage->code, value);\n\telse if (wacom_wac->shared->stylus_in_proximity && !wacom_wac->hid_data.sense_state)\n\t\tinput_event(input, usage->type, usage->code, 0);\n}\n\nstatic void wacom_wac_pen_pre_report(struct hid_device *hdev,\n\t\tstruct hid_report *report)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\n\twacom_wac->is_invalid_bt_frame = false;\n\treturn;\n}\n\nstatic void wacom_wac_pen_report(struct hid_device *hdev,\n\t\tstruct hid_report *report)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct input_dev *input = wacom_wac->pen_input;\n\tbool range = wacom_wac->hid_data.inrange_state;\n\tbool sense = wacom_wac->hid_data.sense_state;\n\n\tif (wacom_wac->is_invalid_bt_frame)\n\t\treturn;\n\n\tif (!wacom_wac->tool[0] && range) {  \n\t\t \n\t\tif (wacom_wac->hid_data.invert_state)\n\t\t\twacom_wac->tool[0] = BTN_TOOL_RUBBER;\n\t\telse if (wacom_wac->id[0])\n\t\t\twacom_wac->tool[0] = wacom_intuos_get_tool_type(wacom_wac->id[0]);\n\t\telse\n\t\t\twacom_wac->tool[0] = BTN_TOOL_PEN;\n\t}\n\n\t \n\twacom_wac->shared->stylus_in_proximity = sense;\n\n\tif (!delay_pen_events(wacom_wac) && wacom_wac->tool[0]) {\n\t\tint id = wacom_wac->id[0];\n\t\tif (wacom_wac->features.quirks & WACOM_QUIRK_PEN_BUTTON3) {\n\t\t\tint sw_state = wacom_wac->hid_data.barrelswitch |\n\t\t\t\t       (wacom_wac->hid_data.barrelswitch2 << 1);\n\t\t\twacom_wac->hid_data.barrelswitch = sw_state == 1;\n\t\t\twacom_wac->hid_data.barrelswitch2 = sw_state == 2;\n\t\t\twacom_wac->hid_data.barrelswitch3 = sw_state == 3;\n\t\t}\n\t\tinput_report_key(input, BTN_STYLUS, wacom_wac->hid_data.barrelswitch);\n\t\tinput_report_key(input, BTN_STYLUS2, wacom_wac->hid_data.barrelswitch2);\n\t\tinput_report_key(input, BTN_STYLUS3, wacom_wac->hid_data.barrelswitch3);\n\n\t\t \n\t\tif (wacom_wac->serial[0] >> 52 == 1)\n\t\t\tid = wacom_intuos_id_mangle(id);\n\n\t\t \n\t\tinput_report_key(input, BTN_TOUCH,\n\t\t\t\twacom_wac->hid_data.tipswitch);\n\t\tinput_report_key(input, wacom_wac->tool[0], sense);\n\t\tif (wacom_wac->serial[0]) {\n\t\t\tinput_event(input, EV_MSC, MSC_SERIAL, wacom_wac->serial[0]);\n\t\t\tinput_report_abs(input, ABS_MISC, sense ? id : 0);\n\t\t}\n\n\t\twacom_wac->hid_data.tipswitch = false;\n\n\t\tinput_sync(input);\n\t}\n\n\tif (!sense) {\n\t\twacom_wac->tool[0] = 0;\n\t\twacom_wac->id[0] = 0;\n\t\twacom_wac->serial[0] = 0;\n\t}\n}\n\nstatic void wacom_wac_finger_usage_mapping(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct input_dev *input = wacom_wac->touch_input;\n\tunsigned touch_max = wacom_wac->features.touch_max;\n\tunsigned equivalent_usage = wacom_equivalent_usage(usage->hid);\n\n\tswitch (equivalent_usage) {\n\tcase HID_GD_X:\n\t\tif (touch_max == 1)\n\t\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);\n\t\telse\n\t\t\twacom_map_usage(input, usage, field, EV_ABS,\n\t\t\t\t\tABS_MT_POSITION_X, 4);\n\t\tbreak;\n\tcase HID_GD_Y:\n\t\tif (touch_max == 1)\n\t\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);\n\t\telse\n\t\t\twacom_map_usage(input, usage, field, EV_ABS,\n\t\t\t\t\tABS_MT_POSITION_Y, 4);\n\t\tbreak;\n\tcase HID_DG_WIDTH:\n\tcase HID_DG_HEIGHT:\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);\n\t\twacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MINOR, 0);\n\t\tinput_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);\n\t\tbreak;\n\tcase HID_DG_TIPSWITCH:\n\t\twacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);\n\t\tbreak;\n\tcase HID_DG_CONTACTCOUNT:\n\t\twacom_wac->hid_data.cc_report = field->report->id;\n\t\twacom_wac->hid_data.cc_index = field->index;\n\t\twacom_wac->hid_data.cc_value_index = usage->usage_index;\n\t\tbreak;\n\tcase HID_DG_CONTACTID:\n\t\tif ((field->logical_maximum - field->logical_minimum) < touch_max) {\n\t\t\t \n\t\t\tfield->logical_maximum = 255;\n\t\t}\n\t\tbreak;\n\tcase HID_DG_SCANTIME:\n\t\twacom_map_usage(input, usage, field, EV_MSC, MSC_TIMESTAMP, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void wacom_wac_finger_slot(struct wacom_wac *wacom_wac,\n\t\tstruct input_dev *input)\n{\n\tstruct hid_data *hid_data = &wacom_wac->hid_data;\n\tbool mt = wacom_wac->features.touch_max > 1;\n\tbool touch_down = hid_data->tipswitch && hid_data->confidence;\n\tbool prox = touch_down && report_touch_events(wacom_wac);\n\n\tif (touch_is_muted(wacom_wac)) {\n\t\tif (!wacom_wac->shared->touch_down)\n\t\t\treturn;\n\t\tprox = false;\n\t}\n\n\twacom_wac->hid_data.num_received++;\n\tif (wacom_wac->hid_data.num_received > wacom_wac->hid_data.num_expected)\n\t\treturn;\n\n\tif (mt) {\n\t\tint slot;\n\n\t\tslot = input_mt_get_slot_by_key(input, hid_data->id);\n\t\tif (slot < 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tstruct input_mt_slot *ps = &input->mt->slots[slot];\n\t\t\tint mt_id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);\n\n\t\t\tif (!prox && mt_id < 0) {\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tinput_mt_slot(input, slot);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, prox);\n\t}\n\telse {\n\t\tinput_report_key(input, BTN_TOUCH, prox);\n\t}\n\n\tif (prox) {\n\t\tinput_report_abs(input, mt ? ABS_MT_POSITION_X : ABS_X,\n\t\t\t\t hid_data->x);\n\t\tinput_report_abs(input, mt ? ABS_MT_POSITION_Y : ABS_Y,\n\t\t\t\t hid_data->y);\n\n\t\tif (test_bit(ABS_MT_TOUCH_MAJOR, input->absbit)) {\n\t\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, max(hid_data->width, hid_data->height));\n\t\t\tinput_report_abs(input, ABS_MT_TOUCH_MINOR, min(hid_data->width, hid_data->height));\n\t\t\tif (hid_data->width != hid_data->height)\n\t\t\t\tinput_report_abs(input, ABS_MT_ORIENTATION, hid_data->width <= hid_data->height ? 0 : 1);\n\t\t}\n\t}\n}\n\nstatic void wacom_wac_finger_event(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage, __s32 value)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tunsigned equivalent_usage = wacom_equivalent_usage(usage->hid);\n\tstruct wacom_features *features = &wacom->wacom_wac.features;\n\n\tif (touch_is_muted(wacom_wac) && !wacom_wac->shared->touch_down)\n\t\treturn;\n\n\tif (wacom_wac->is_invalid_bt_frame)\n\t\treturn;\n\n\tswitch (equivalent_usage) {\n\tcase HID_DG_CONFIDENCE:\n\t\twacom_wac->hid_data.confidence = value;\n\t\tbreak;\n\tcase HID_GD_X:\n\t\twacom_wac->hid_data.x = value;\n\t\tbreak;\n\tcase HID_GD_Y:\n\t\twacom_wac->hid_data.y = value;\n\t\tbreak;\n\tcase HID_DG_WIDTH:\n\t\twacom_wac->hid_data.width = value;\n\t\tbreak;\n\tcase HID_DG_HEIGHT:\n\t\twacom_wac->hid_data.height = value;\n\t\tbreak;\n\tcase HID_DG_CONTACTID:\n\t\twacom_wac->hid_data.id = value;\n\t\tbreak;\n\tcase HID_DG_TIPSWITCH:\n\t\twacom_wac->hid_data.tipswitch = value;\n\t\tbreak;\n\tcase WACOM_HID_WT_REPORT_VALID:\n\t\twacom_wac->is_invalid_bt_frame = !value;\n\t\treturn;\n\tcase HID_DG_CONTACTMAX:\n\t\tif (!features->touch_max) {\n\t\t\tfeatures->touch_max = value;\n\t\t} else {\n\t\t\thid_warn(hdev, \"%s: ignoring attempt to overwrite non-zero touch_max \"\n\t\t\t\t \"%d -> %d\\n\", __func__, features->touch_max, value);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (usage->usage_index + 1 == field->report_count) {\n\t\tif (equivalent_usage == wacom_wac->hid_data.last_slot_field)\n\t\t\twacom_wac_finger_slot(wacom_wac, wacom_wac->touch_input);\n\t}\n}\n\nstatic void wacom_wac_finger_pre_report(struct hid_device *hdev,\n\t\tstruct hid_report *report)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct hid_data* hid_data = &wacom_wac->hid_data;\n\tint i;\n\n\tif (touch_is_muted(wacom_wac) && !wacom_wac->shared->touch_down)\n\t\treturn;\n\n\twacom_wac->is_invalid_bt_frame = false;\n\n\thid_data->confidence = true;\n\n\thid_data->cc_report = 0;\n\thid_data->cc_index = -1;\n\thid_data->cc_value_index = -1;\n\n\tfor (i = 0; i < report->maxfield; i++) {\n\t\tstruct hid_field *field = report->field[i];\n\t\tint j;\n\n\t\tfor (j = 0; j < field->maxusage; j++) {\n\t\t\tstruct hid_usage *usage = &field->usage[j];\n\t\t\tunsigned int equivalent_usage =\n\t\t\t\twacom_equivalent_usage(usage->hid);\n\n\t\t\tswitch (equivalent_usage) {\n\t\t\tcase HID_GD_X:\n\t\t\tcase HID_GD_Y:\n\t\t\tcase HID_DG_WIDTH:\n\t\t\tcase HID_DG_HEIGHT:\n\t\t\tcase HID_DG_CONTACTID:\n\t\t\tcase HID_DG_INRANGE:\n\t\t\tcase HID_DG_INVERT:\n\t\t\tcase HID_DG_TIPSWITCH:\n\t\t\t\thid_data->last_slot_field = equivalent_usage;\n\t\t\t\tbreak;\n\t\t\tcase HID_DG_CONTACTCOUNT:\n\t\t\t\thid_data->cc_report = report->id;\n\t\t\t\thid_data->cc_index = i;\n\t\t\t\thid_data->cc_value_index = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hid_data->cc_report != 0 &&\n\t    hid_data->cc_index >= 0) {\n\t\tstruct hid_field *field = report->field[hid_data->cc_index];\n\t\tint value = field->value[hid_data->cc_value_index];\n\t\tif (value) {\n\t\t\thid_data->num_expected = value;\n\t\t\thid_data->num_received = 0;\n\t\t}\n\t}\n\telse {\n\t\thid_data->num_expected = wacom_wac->features.touch_max;\n\t\thid_data->num_received = 0;\n\t}\n}\n\nstatic void wacom_wac_finger_report(struct hid_device *hdev,\n\t\tstruct hid_report *report)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct input_dev *input = wacom_wac->touch_input;\n\tunsigned touch_max = wacom_wac->features.touch_max;\n\n\t \n\tif (wacom_wac->hid_data.num_expected == 0)\n\t\treturn;\n\n\t \n\tif (wacom_wac->hid_data.num_received < wacom_wac->hid_data.num_expected)\n\t\treturn;\n\n\tif (touch_max > 1)\n\t\tinput_mt_sync_frame(input);\n\n\tinput_sync(input);\n\twacom_wac->hid_data.num_received = 0;\n\twacom_wac->hid_data.num_expected = 0;\n\n\t \n\twacom_wac->shared->touch_down = wacom_wac_finger_count_touches(wacom_wac);\n}\n\nvoid wacom_wac_usage_mapping(struct hid_device *hdev,\n\t\tstruct hid_field *field, struct hid_usage *usage)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom_wac->features;\n\n\tif (WACOM_DIRECT_DEVICE(field))\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_DIRECT;\n\n\t \n\tif (WACOM_BATTERY_USAGE(usage))\n\t\twacom_wac_battery_usage_mapping(hdev, field, usage);\n\telse if (WACOM_PAD_FIELD(field))\n\t\twacom_wac_pad_usage_mapping(hdev, field, usage);\n\telse if (WACOM_PEN_FIELD(field))\n\t\twacom_wac_pen_usage_mapping(hdev, field, usage);\n\telse if (WACOM_FINGER_FIELD(field))\n\t\twacom_wac_finger_usage_mapping(hdev, field, usage);\n}\n\nvoid wacom_wac_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\n\tif (wacom->wacom_wac.features.type != HID_GENERIC)\n\t\treturn;\n\n\tif (value > field->logical_maximum || value < field->logical_minimum)\n\t\treturn;\n\n\t \n\tif (WACOM_BATTERY_USAGE(usage))\n\t\twacom_wac_battery_event(hdev, field, usage, value);\n\telse if (WACOM_PAD_FIELD(field))\n\t\twacom_wac_pad_event(hdev, field, usage, value);\n\telse if (WACOM_PEN_FIELD(field) && wacom->wacom_wac.pen_input)\n\t\twacom_wac_pen_event(hdev, field, usage, value);\n\telse if (WACOM_FINGER_FIELD(field) && wacom->wacom_wac.touch_input)\n\t\twacom_wac_finger_event(hdev, field, usage, value);\n}\n\nstatic void wacom_report_events(struct hid_device *hdev,\n\t\t\t\tstruct hid_report *report, int collection_index,\n\t\t\t\tint field_index)\n{\n\tint r;\n\n\tfor (r = field_index; r < report->maxfield; r++) {\n\t\tstruct hid_field *field;\n\t\tunsigned count, n;\n\n\t\tfield = report->field[r];\n\t\tcount = field->report_count;\n\n\t\tif (!(HID_MAIN_ITEM_VARIABLE & field->flags))\n\t\t\tcontinue;\n\n\t\tfor (n = 0 ; n < count; n++) {\n\t\t\tif (field->usage[n].collection_index == collection_index)\n\t\t\t\twacom_wac_event(hdev, field, &field->usage[n],\n\t\t\t\t\t\tfield->value[n]);\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int wacom_wac_collection(struct hid_device *hdev, struct hid_report *report,\n\t\t\t int collection_index, struct hid_field *field,\n\t\t\t int field_index)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\n\twacom_report_events(hdev, report, collection_index, field_index);\n\n\t \n\tif (report->type != HID_INPUT_REPORT)\n\t\treturn -1;\n\n\tif (WACOM_PAD_FIELD(field))\n\t\treturn 0;\n\telse if (WACOM_PEN_FIELD(field) && wacom->wacom_wac.pen_input)\n\t\twacom_wac_pen_report(hdev, report);\n\telse if (WACOM_FINGER_FIELD(field) && wacom->wacom_wac.touch_input)\n\t\twacom_wac_finger_report(hdev, report);\n\n\treturn 0;\n}\n\nvoid wacom_wac_report(struct hid_device *hdev, struct hid_report *report)\n{\n\tstruct wacom *wacom = hid_get_drvdata(hdev);\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct hid_field *field;\n\tbool pad_in_hid_field = false, pen_in_hid_field = false,\n\t\tfinger_in_hid_field = false, true_pad = false;\n\tint r;\n\tint prev_collection = -1;\n\n\tif (wacom_wac->features.type != HID_GENERIC)\n\t\treturn;\n\n\tfor (r = 0; r < report->maxfield; r++) {\n\t\tfield = report->field[r];\n\n\t\tif (WACOM_PAD_FIELD(field))\n\t\t\tpad_in_hid_field = true;\n\t\tif (WACOM_PEN_FIELD(field))\n\t\t\tpen_in_hid_field = true;\n\t\tif (WACOM_FINGER_FIELD(field))\n\t\t\tfinger_in_hid_field = true;\n\t\tif (wacom_equivalent_usage(field->physical) == HID_DG_TABLETFUNCTIONKEY)\n\t\t\ttrue_pad = true;\n\t}\n\n\twacom_wac_battery_pre_report(hdev, report);\n\n\tif (pad_in_hid_field && wacom->wacom_wac.pad_input)\n\t\twacom_wac_pad_pre_report(hdev, report);\n\tif (pen_in_hid_field && wacom->wacom_wac.pen_input)\n\t\twacom_wac_pen_pre_report(hdev, report);\n\tif (finger_in_hid_field && wacom->wacom_wac.touch_input)\n\t\twacom_wac_finger_pre_report(hdev, report);\n\n\tfor (r = 0; r < report->maxfield; r++) {\n\t\tfield = report->field[r];\n\n\t\tif (field->usage[0].collection_index != prev_collection) {\n\t\t\tif (wacom_wac_collection(hdev, report,\n\t\t\t\tfield->usage[0].collection_index, field, r) < 0)\n\t\t\t\treturn;\n\t\t\tprev_collection = field->usage[0].collection_index;\n\t\t}\n\t}\n\n\twacom_wac_battery_report(hdev, report);\n\n\tif (true_pad && wacom->wacom_wac.pad_input)\n\t\twacom_wac_pad_report(hdev, report, field);\n}\n\nstatic int wacom_bpt_touch(struct wacom_wac *wacom)\n{\n\tstruct wacom_features *features = &wacom->features;\n\tstruct input_dev *input = wacom->touch_input;\n\tstruct input_dev *pad_input = wacom->pad_input;\n\tunsigned char *data = wacom->data;\n\tint i;\n\n\tif (data[0] != 0x02)\n\t    return 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tint offset = (data[1] & 0x80) ? (8 * i) : (9 * i);\n\t\tbool touch = report_touch_events(wacom)\n\t\t\t   && (data[offset + 3] & 0x80);\n\n\t\tinput_mt_slot(input, i);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\n\t\tif (touch) {\n\t\t\tint x = get_unaligned_be16(&data[offset + 3]) & 0x7ff;\n\t\t\tint y = get_unaligned_be16(&data[offset + 5]) & 0x7ff;\n\t\t\tif (features->quirks & WACOM_QUIRK_BBTOUCH_LOWRES) {\n\t\t\t\tx <<= 5;\n\t\t\t\ty <<= 5;\n\t\t\t}\n\t\t\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\t\t\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\t\t}\n\t}\n\n\tinput_mt_sync_frame(input);\n\n\tinput_report_key(pad_input, BTN_LEFT, (data[1] & 0x08) != 0);\n\tinput_report_key(pad_input, BTN_FORWARD, (data[1] & 0x04) != 0);\n\tinput_report_key(pad_input, BTN_BACK, (data[1] & 0x02) != 0);\n\tinput_report_key(pad_input, BTN_RIGHT, (data[1] & 0x01) != 0);\n\twacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\n\n\treturn 1;\n}\n\nstatic void wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data)\n{\n\tstruct wacom_features *features = &wacom->features;\n\tstruct input_dev *input = wacom->touch_input;\n\tbool touch = data[1] & 0x80;\n\tint slot = input_mt_get_slot_by_key(input, data[0]);\n\n\tif (slot < 0)\n\t\treturn;\n\n\ttouch = touch && report_touch_events(wacom);\n\n\tinput_mt_slot(input, slot);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\n\n\tif (touch) {\n\t\tint x = (data[2] << 4) | (data[4] >> 4);\n\t\tint y = (data[3] << 4) | (data[4] & 0x0f);\n\t\tint width, height;\n\n\t\tif (features->type >= INTUOSPS && features->type <= INTUOSHT2) {\n\t\t\twidth  = data[5] * 100;\n\t\t\theight = data[6] * 100;\n\t\t} else {\n\t\t\t \n\t\t\tint a = data[5];\n\t\t\tint x_res = input_abs_get_res(input, ABS_MT_POSITION_X);\n\t\t\tint y_res = input_abs_get_res(input, ABS_MT_POSITION_Y);\n\t\t\twidth = 2 * int_sqrt(a * WACOM_CONTACT_AREA_SCALE);\n\t\t\theight = width * y_res / x_res;\n\t\t}\n\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, width);\n\t\tinput_report_abs(input, ABS_MT_TOUCH_MINOR, height);\n\t}\n}\n\nstatic void wacom_bpt3_button_msg(struct wacom_wac *wacom, unsigned char *data)\n{\n\tstruct input_dev *input = wacom->pad_input;\n\tstruct wacom_features *features = &wacom->features;\n\n\tif (features->type == INTUOSHT || features->type == INTUOSHT2) {\n\t\tinput_report_key(input, BTN_LEFT, (data[1] & 0x02) != 0);\n\t\tinput_report_key(input, BTN_BACK, (data[1] & 0x08) != 0);\n\t} else {\n\t\tinput_report_key(input, BTN_BACK, (data[1] & 0x02) != 0);\n\t\tinput_report_key(input, BTN_LEFT, (data[1] & 0x08) != 0);\n\t}\n\tinput_report_key(input, BTN_FORWARD, (data[1] & 0x04) != 0);\n\tinput_report_key(input, BTN_RIGHT, (data[1] & 0x01) != 0);\n}\n\nstatic int wacom_bpt3_touch(struct wacom_wac *wacom)\n{\n\tunsigned char *data = wacom->data;\n\tint count = data[1] & 0x07;\n\tint  touch_changed = 0, i;\n\n\tif (data[0] != 0x02)\n\t    return 0;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tint offset = (8 * i) + 2;\n\t\tint msg_id = data[offset];\n\n\t\tif (msg_id >= 2 && msg_id <= 17) {\n\t\t\twacom_bpt3_touch_msg(wacom, data + offset);\n\t\t\ttouch_changed++;\n\t\t} else if (msg_id == 128)\n\t\t\twacom_bpt3_button_msg(wacom, data + offset);\n\n\t}\n\n\t \n\tif (wacom->touch_input && touch_changed) {\n\t\tinput_mt_sync_frame(wacom->touch_input);\n\t\twacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);\n\t}\n\n\treturn 1;\n}\n\nstatic int wacom_bpt_pen(struct wacom_wac *wacom)\n{\n\tstruct wacom_features *features = &wacom->features;\n\tstruct input_dev *input = wacom->pen_input;\n\tunsigned char *data = wacom->data;\n\tint x = 0, y = 0, p = 0, d = 0;\n\tbool pen = false, btn1 = false, btn2 = false;\n\tbool range, prox, rdy;\n\n\tif (data[0] != WACOM_REPORT_PENABLED)\n\t    return 0;\n\n\trange = (data[1] & 0x80) == 0x80;\n\tprox = (data[1] & 0x40) == 0x40;\n\trdy = (data[1] & 0x20) == 0x20;\n\n\twacom->shared->stylus_in_proximity = range;\n\tif (delay_pen_events(wacom))\n\t\treturn 0;\n\n\tif (rdy) {\n\t\tp = le16_to_cpup((__le16 *)&data[6]);\n\t\tpen = data[1] & 0x01;\n\t\tbtn1 = data[1] & 0x02;\n\t\tbtn2 = data[1] & 0x04;\n\t}\n\tif (prox) {\n\t\tx = le16_to_cpup((__le16 *)&data[2]);\n\t\ty = le16_to_cpup((__le16 *)&data[4]);\n\n\t\tif (data[1] & 0x08) {\n\t\t\twacom->tool[0] = BTN_TOOL_RUBBER;\n\t\t\twacom->id[0] = ERASER_DEVICE_ID;\n\t\t} else {\n\t\t\twacom->tool[0] = BTN_TOOL_PEN;\n\t\t\twacom->id[0] = STYLUS_DEVICE_ID;\n\t\t}\n\t\twacom->reporting_data = true;\n\t}\n\tif (range) {\n\t\t \n\t\tif (data[8] <= features->distance_max)\n\t\t\td = features->distance_max - data[8];\n\t} else {\n\t\twacom->id[0] = 0;\n\t}\n\n\tif (wacom->reporting_data) {\n\t\tinput_report_key(input, BTN_TOUCH, pen);\n\t\tinput_report_key(input, BTN_STYLUS, btn1);\n\t\tinput_report_key(input, BTN_STYLUS2, btn2);\n\n\t\tif (prox || !range) {\n\t\t\tinput_report_abs(input, ABS_X, x);\n\t\t\tinput_report_abs(input, ABS_Y, y);\n\t\t}\n\t\tinput_report_abs(input, ABS_PRESSURE, p);\n\t\tinput_report_abs(input, ABS_DISTANCE, d);\n\n\t\tinput_report_key(input, wacom->tool[0], range);  \n\t\tinput_report_abs(input, ABS_MISC, wacom->id[0]);  \n\t}\n\n\tif (!range) {\n\t\twacom->reporting_data = false;\n\t}\n\n\treturn 1;\n}\n\nstatic int wacom_bpt_irq(struct wacom_wac *wacom, size_t len)\n{\n\tstruct wacom_features *features = &wacom->features;\n\n\tif ((features->type == INTUOSHT2) &&\n\t    (features->device_type & WACOM_DEVICETYPE_PEN))\n\t\treturn wacom_intuos_irq(wacom);\n\telse if (len == WACOM_PKGLEN_BBTOUCH)\n\t\treturn wacom_bpt_touch(wacom);\n\telse if (len == WACOM_PKGLEN_BBTOUCH3)\n\t\treturn wacom_bpt3_touch(wacom);\n\telse if (len == WACOM_PKGLEN_BBFUN || len == WACOM_PKGLEN_BBPEN)\n\t\treturn wacom_bpt_pen(wacom);\n\n\treturn 0;\n}\n\nstatic void wacom_bamboo_pad_pen_event(struct wacom_wac *wacom,\n\t\tunsigned char *data)\n{\n\tunsigned char prefix;\n\n\t \n\tprefix = data[0];\n\tdata[0] = WACOM_REPORT_BPAD_PEN;\n\n\t \n\thid_input_report(wacom->shared->pen, HID_INPUT_REPORT, data,\n\t\t\t WACOM_PKGLEN_PENABLED, 1);\n\n\tdata[0] = prefix;\n}\n\nstatic int wacom_bamboo_pad_touch_event(struct wacom_wac *wacom,\n\t\tunsigned char *data)\n{\n\tstruct input_dev *input = wacom->touch_input;\n\tunsigned char *finger_data, prefix;\n\tunsigned id;\n\tint x, y;\n\tbool valid;\n\n\tprefix = data[0];\n\n\tfor (id = 0; id < wacom->features.touch_max; id++) {\n\t\tvalid = !!(prefix & BIT(id)) &&\n\t\t\treport_touch_events(wacom);\n\n\t\tinput_mt_slot(input, id);\n\t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, valid);\n\n\t\tif (!valid)\n\t\t\tcontinue;\n\n\t\tfinger_data = data + 1 + id * 3;\n\t\tx = finger_data[0] | ((finger_data[1] & 0x0f) << 8);\n\t\ty = (finger_data[2] << 4) | (finger_data[1] >> 4);\n\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\t}\n\n\tinput_mt_sync_frame(input);\n\n\tinput_report_key(input, BTN_LEFT, prefix & 0x40);\n\tinput_report_key(input, BTN_RIGHT, prefix & 0x80);\n\n\t \n\twacom->shared->touch_down = !!prefix && report_touch_events(wacom);\n\n\treturn 1;\n}\n\nstatic int wacom_bamboo_pad_irq(struct wacom_wac *wacom, size_t len)\n{\n\tunsigned char *data = wacom->data;\n\n\tif (!((len == WACOM_PKGLEN_BPAD_TOUCH) ||\n\t      (len == WACOM_PKGLEN_BPAD_TOUCH_USB)) ||\n\t    (data[0] != WACOM_REPORT_BPAD_TOUCH))\n\t\treturn 0;\n\n\tif (data[1] & 0x01)\n\t\twacom_bamboo_pad_pen_event(wacom, &data[1]);\n\n\tif (data[1] & 0x02)\n\t\treturn wacom_bamboo_pad_touch_event(wacom, &data[9]);\n\n\treturn 0;\n}\n\nstatic int wacom_wireless_irq(struct wacom_wac *wacom, size_t len)\n{\n\tunsigned char *data = wacom->data;\n\tint connected;\n\n\tif (len != WACOM_PKGLEN_WIRELESS || data[0] != WACOM_REPORT_WL)\n\t\treturn 0;\n\n\tconnected = data[1] & 0x01;\n\tif (connected) {\n\t\tint pid, battery, charging;\n\n\t\tif ((wacom->shared->type == INTUOSHT ||\n\t\t    wacom->shared->type == INTUOSHT2) &&\n\t\t    wacom->shared->touch_input &&\n\t\t    wacom->shared->touch_max) {\n\t\t\tinput_report_switch(wacom->shared->touch_input,\n\t\t\t\t\tSW_MUTE_DEVICE, data[5] & 0x40);\n\t\t\tinput_sync(wacom->shared->touch_input);\n\t\t}\n\n\t\tpid = get_unaligned_be16(&data[6]);\n\t\tbattery = (data[5] & 0x3f) * 100 / 31;\n\t\tcharging = !!(data[5] & 0x80);\n\t\tif (wacom->pid != pid) {\n\t\t\twacom->pid = pid;\n\t\t\twacom_schedule_work(wacom, WACOM_WORKER_WIRELESS);\n\t\t}\n\n\t\twacom_notify_battery(wacom, WACOM_POWER_SUPPLY_STATUS_AUTO,\n\t\t\t\t     battery, charging, 1, 0);\n\n\t} else if (wacom->pid != 0) {\n\t\t \n\t\twacom->pid = 0;\n\t\twacom_schedule_work(wacom, WACOM_WORKER_WIRELESS);\n\t\twacom_notify_battery(wacom, POWER_SUPPLY_STATUS_UNKNOWN, 0, 0, 0, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int wacom_status_irq(struct wacom_wac *wacom_wac, size_t len)\n{\n\tstruct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);\n\tstruct wacom_features *features = &wacom_wac->features;\n\tunsigned char *data = wacom_wac->data;\n\n\tif (data[0] != WACOM_REPORT_USB)\n\t\treturn 0;\n\n\tif ((features->type == INTUOSHT ||\n\t    features->type == INTUOSHT2) &&\n\t    wacom_wac->shared->touch_input &&\n\t    features->touch_max) {\n\t\tinput_report_switch(wacom_wac->shared->touch_input,\n\t\t\t\t    SW_MUTE_DEVICE, data[8] & 0x40);\n\t\tinput_sync(wacom_wac->shared->touch_input);\n\t}\n\n\tif (data[9] & 0x02) {  \n\t\tint battery = (data[8] & 0x3f) * 100 / 31;\n\t\tbool charging = !!(data[8] & 0x80);\n\n\t\tfeatures->quirks |= WACOM_QUIRK_BATTERY;\n\t\twacom_notify_battery(wacom_wac, WACOM_POWER_SUPPLY_STATUS_AUTO,\n\t\t\t\t     battery, charging, battery || charging, 1);\n\t}\n\telse if ((features->quirks & WACOM_QUIRK_BATTERY) &&\n\t\t wacom->battery.battery) {\n\t\tfeatures->quirks &= ~WACOM_QUIRK_BATTERY;\n\t\twacom_notify_battery(wacom_wac, POWER_SUPPLY_STATUS_UNKNOWN, 0, 0, 0, 0);\n\t}\n\treturn 0;\n}\n\nvoid wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len)\n{\n\tbool sync;\n\n\tswitch (wacom_wac->features.type) {\n\tcase PENPARTNER:\n\t\tsync = wacom_penpartner_irq(wacom_wac);\n\t\tbreak;\n\n\tcase PL:\n\t\tsync = wacom_pl_irq(wacom_wac);\n\t\tbreak;\n\n\tcase WACOM_G4:\n\tcase GRAPHIRE:\n\tcase GRAPHIRE_BT:\n\tcase WACOM_MO:\n\t\tsync = wacom_graphire_irq(wacom_wac);\n\t\tbreak;\n\n\tcase PTU:\n\t\tsync = wacom_ptu_irq(wacom_wac);\n\t\tbreak;\n\n\tcase DTU:\n\t\tsync = wacom_dtu_irq(wacom_wac);\n\t\tbreak;\n\n\tcase DTUS:\n\tcase DTUSX:\n\t\tsync = wacom_dtus_irq(wacom_wac);\n\t\tbreak;\n\n\tcase INTUOS:\n\tcase INTUOS3S:\n\tcase INTUOS3:\n\tcase INTUOS3L:\n\tcase INTUOS4S:\n\tcase INTUOS4:\n\tcase INTUOS4L:\n\tcase CINTIQ:\n\tcase WACOM_BEE:\n\tcase WACOM_13HD:\n\tcase WACOM_21UX2:\n\tcase WACOM_22HD:\n\tcase WACOM_24HD:\n\tcase WACOM_27QHD:\n\tcase DTK:\n\tcase CINTIQ_HYBRID:\n\tcase CINTIQ_COMPANION_2:\n\t\tsync = wacom_intuos_irq(wacom_wac);\n\t\tbreak;\n\n\tcase INTUOS4WL:\n\t\tsync = wacom_intuos_bt_irq(wacom_wac, len);\n\t\tbreak;\n\n\tcase WACOM_24HDT:\n\tcase WACOM_27QHDT:\n\t\tsync = wacom_24hdt_irq(wacom_wac);\n\t\tbreak;\n\n\tcase INTUOS5S:\n\tcase INTUOS5:\n\tcase INTUOS5L:\n\tcase INTUOSPS:\n\tcase INTUOSPM:\n\tcase INTUOSPL:\n\t\tif (len == WACOM_PKGLEN_BBTOUCH3)\n\t\t\tsync = wacom_bpt3_touch(wacom_wac);\n\t\telse if (wacom_wac->data[0] == WACOM_REPORT_USB)\n\t\t\tsync = wacom_status_irq(wacom_wac, len);\n\t\telse\n\t\t\tsync = wacom_intuos_irq(wacom_wac);\n\t\tbreak;\n\n\tcase INTUOSP2_BT:\n\tcase INTUOSP2S_BT:\n\tcase INTUOSHT3_BT:\n\t\tsync = wacom_intuos_pro2_bt_irq(wacom_wac, len);\n\t\tbreak;\n\n\tcase TABLETPC:\n\tcase TABLETPCE:\n\tcase TABLETPC2FG:\n\tcase MTSCREEN:\n\tcase MTTPC:\n\tcase MTTPC_B:\n\t\tsync = wacom_tpc_irq(wacom_wac, len);\n\t\tbreak;\n\n\tcase BAMBOO_PT:\n\tcase BAMBOO_PEN:\n\tcase BAMBOO_TOUCH:\n\tcase INTUOSHT:\n\tcase INTUOSHT2:\n\t\tif (wacom_wac->data[0] == WACOM_REPORT_USB)\n\t\t\tsync = wacom_status_irq(wacom_wac, len);\n\t\telse\n\t\t\tsync = wacom_bpt_irq(wacom_wac, len);\n\t\tbreak;\n\n\tcase BAMBOO_PAD:\n\t\tsync = wacom_bamboo_pad_irq(wacom_wac, len);\n\t\tbreak;\n\n\tcase WIRELESS:\n\t\tsync = wacom_wireless_irq(wacom_wac, len);\n\t\tbreak;\n\n\tcase REMOTE:\n\t\tsync = false;\n\t\tif (wacom_wac->data[0] == WACOM_REPORT_DEVICE_LIST)\n\t\t\twacom_remote_status_irq(wacom_wac, len);\n\t\telse\n\t\t\tsync = wacom_remote_irq(wacom_wac, len);\n\t\tbreak;\n\n\tdefault:\n\t\tsync = false;\n\t\tbreak;\n\t}\n\n\tif (sync) {\n\t\tif (wacom_wac->pen_input)\n\t\t\tinput_sync(wacom_wac->pen_input);\n\t\tif (wacom_wac->touch_input)\n\t\t\tinput_sync(wacom_wac->touch_input);\n\t\tif (wacom_wac->pad_input)\n\t\t\tinput_sync(wacom_wac->pad_input);\n\t}\n}\n\nstatic void wacom_setup_basic_pro_pen(struct wacom_wac *wacom_wac)\n{\n\tstruct input_dev *input_dev = wacom_wac->pen_input;\n\n\tinput_set_capability(input_dev, EV_MSC, MSC_SERIAL);\n\n\t__set_bit(BTN_TOOL_PEN, input_dev->keybit);\n\t__set_bit(BTN_STYLUS, input_dev->keybit);\n\t__set_bit(BTN_STYLUS2, input_dev->keybit);\n\n\tinput_set_abs_params(input_dev, ABS_DISTANCE,\n\t\t\t     0, wacom_wac->features.distance_max, wacom_wac->features.distance_fuzz, 0);\n}\n\nstatic void wacom_setup_cintiq(struct wacom_wac *wacom_wac)\n{\n\tstruct input_dev *input_dev = wacom_wac->pen_input;\n\tstruct wacom_features *features = &wacom_wac->features;\n\n\twacom_setup_basic_pro_pen(wacom_wac);\n\n\t__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\n\t__set_bit(BTN_TOOL_BRUSH, input_dev->keybit);\n\t__set_bit(BTN_TOOL_PENCIL, input_dev->keybit);\n\t__set_bit(BTN_TOOL_AIRBRUSH, input_dev->keybit);\n\n\tinput_set_abs_params(input_dev, ABS_WHEEL, 0, 1023, 0, 0);\n\tinput_set_abs_params(input_dev, ABS_TILT_X, -64, 63, features->tilt_fuzz, 0);\n\tinput_abs_set_res(input_dev, ABS_TILT_X, 57);\n\tinput_set_abs_params(input_dev, ABS_TILT_Y, -64, 63, features->tilt_fuzz, 0);\n\tinput_abs_set_res(input_dev, ABS_TILT_Y, 57);\n}\n\nstatic void wacom_setup_intuos(struct wacom_wac *wacom_wac)\n{\n\tstruct input_dev *input_dev = wacom_wac->pen_input;\n\n\tinput_set_capability(input_dev, EV_REL, REL_WHEEL);\n\n\twacom_setup_cintiq(wacom_wac);\n\n\t__set_bit(BTN_LEFT, input_dev->keybit);\n\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\t__set_bit(BTN_MIDDLE, input_dev->keybit);\n\t__set_bit(BTN_SIDE, input_dev->keybit);\n\t__set_bit(BTN_EXTRA, input_dev->keybit);\n\t__set_bit(BTN_TOOL_MOUSE, input_dev->keybit);\n\t__set_bit(BTN_TOOL_LENS, input_dev->keybit);\n\n\tinput_set_abs_params(input_dev, ABS_RZ, -900, 899, 0, 0);\n\tinput_abs_set_res(input_dev, ABS_RZ, 287);\n\tinput_set_abs_params(input_dev, ABS_THROTTLE, -1023, 1023, 0, 0);\n}\n\nvoid wacom_setup_device_quirks(struct wacom *wacom)\n{\n\tstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\n\tstruct wacom_features *features = &wacom->wacom_wac.features;\n\n\t \n\tif (features->type == GRAPHIRE_BT || features->type == WACOM_G4 ||\n\t    features->type == DTUS ||\n\t    (features->type >= INTUOS3S && features->type <= WACOM_MO)) {\n\t\tif (features->device_type & WACOM_DEVICETYPE_PEN)\n\t\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t}\n\n\t \n\tif (features->device_type & WACOM_DEVICETYPE_TOUCH && !features->x_max) {\n\t\tfeatures->x_max = 1023;\n\t\tfeatures->y_max = 1023;\n\t}\n\n\t \n\tif ((features->type >= INTUOS5S && features->type <= INTUOSPL) ||\n\t\t(features->type >= INTUOSHT && features->type <= BAMBOO_PT)) {\n\t\tif (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {\n\t\t\tif (features->touch_max)\n\t\t\t\tfeatures->device_type |= WACOM_DEVICETYPE_TOUCH;\n\t\t\tif (features->type >= INTUOSHT && features->type <= BAMBOO_PT)\n\t\t\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\n\t\t\tif (features->type == INTUOSHT2) {\n\t\t\t\tfeatures->x_max = features->x_max / 10;\n\t\t\t\tfeatures->y_max = features->y_max / 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfeatures->x_max = 4096;\n\t\t\t\tfeatures->y_max = 4096;\n\t\t\t}\n\t\t}\n\t\telse if (features->pktlen == WACOM_PKGLEN_BBTOUCH) {\n\t\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\t\t}\n\t}\n\n\t \n\tif (features->type == BAMBOO_PEN &&\n\t    features->pktlen == WACOM_PKGLEN_BBTOUCH3)\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\n\t \n\tif (features->type == BAMBOO_PAD)\n\t\tfeatures->device_type = WACOM_DEVICETYPE_TOUCH;\n\n\tif (features->type == REMOTE)\n\t\tfeatures->device_type = WACOM_DEVICETYPE_PAD;\n\n\tif (features->type == INTUOSP2_BT ||\n\t    features->type == INTUOSP2S_BT) {\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PEN |\n\t\t\t\t\t WACOM_DEVICETYPE_PAD |\n\t\t\t\t\t WACOM_DEVICETYPE_TOUCH;\n\t\tfeatures->quirks |= WACOM_QUIRK_BATTERY;\n\t}\n\n\tif (features->type == INTUOSHT3_BT) {\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PEN |\n\t\t\t\t\t WACOM_DEVICETYPE_PAD;\n\t\tfeatures->quirks |= WACOM_QUIRK_BATTERY;\n\t}\n\n\tswitch (features->type) {\n\tcase PL:\n\tcase DTU:\n\tcase DTUS:\n\tcase DTUSX:\n\tcase WACOM_21UX2:\n\tcase WACOM_22HD:\n\tcase DTK:\n\tcase WACOM_24HD:\n\tcase WACOM_27QHD:\n\tcase CINTIQ_HYBRID:\n\tcase CINTIQ_COMPANION_2:\n\tcase CINTIQ:\n\tcase WACOM_BEE:\n\tcase WACOM_13HD:\n\tcase WACOM_24HDT:\n\tcase WACOM_27QHDT:\n\tcase TABLETPC:\n\tcase TABLETPCE:\n\tcase TABLETPC2FG:\n\tcase MTSCREEN:\n\tcase MTTPC:\n\tcase MTTPC_B:\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_DIRECT;\n\t\tbreak;\n\t}\n\n\tif (wacom->hdev->bus == BUS_BLUETOOTH)\n\t\tfeatures->quirks |= WACOM_QUIRK_BATTERY;\n\n\t \n\tif ((features->type == BAMBOO_PT || features->type == BAMBOO_TOUCH) &&\n\t    features->pktlen == WACOM_PKGLEN_BBTOUCH) {\n\t\tfeatures->x_max <<= 5;\n\t\tfeatures->y_max <<= 5;\n\t\tfeatures->x_fuzz <<= 5;\n\t\tfeatures->y_fuzz <<= 5;\n\t\tfeatures->quirks |= WACOM_QUIRK_BBTOUCH_LOWRES;\n\t}\n\n\tif (features->type == WIRELESS) {\n\t\tif (features->device_type == WACOM_DEVICETYPE_WL_MONITOR) {\n\t\t\tfeatures->quirks |= WACOM_QUIRK_BATTERY;\n\t\t}\n\t}\n\n\tif (features->type == REMOTE)\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_WL_MONITOR;\n\n\t \n\tif (wacom->hdev->product == 0x382 || wacom->hdev->product == 0x37d) {\n\t\tfeatures->quirks &= ~WACOM_QUIRK_TOOLSERIAL;\n\t\t__clear_bit(BTN_TOOL_BRUSH, wacom_wac->pen_input->keybit);\n\t\t__clear_bit(BTN_TOOL_PENCIL, wacom_wac->pen_input->keybit);\n\t\t__clear_bit(BTN_TOOL_AIRBRUSH, wacom_wac->pen_input->keybit);\n\t\t__clear_bit(ABS_Z, wacom_wac->pen_input->absbit);\n\t\t__clear_bit(ABS_DISTANCE, wacom_wac->pen_input->absbit);\n\t\t__clear_bit(ABS_TILT_X, wacom_wac->pen_input->absbit);\n\t\t__clear_bit(ABS_TILT_Y, wacom_wac->pen_input->absbit);\n\t\t__clear_bit(ABS_WHEEL, wacom_wac->pen_input->absbit);\n\t\t__clear_bit(ABS_MISC, wacom_wac->pen_input->absbit);\n\t\t__clear_bit(MSC_SERIAL, wacom_wac->pen_input->mscbit);\n\t\t__clear_bit(EV_MSC, wacom_wac->pen_input->evbit);\n\t}\n}\n\nint wacom_setup_pen_input_capabilities(struct input_dev *input_dev,\n\t\t\t\t   struct wacom_wac *wacom_wac)\n{\n\tstruct wacom_features *features = &wacom_wac->features;\n\n\tif (!(features->device_type & WACOM_DEVICETYPE_PEN))\n\t\treturn -ENODEV;\n\n\tif (features->device_type & WACOM_DEVICETYPE_DIRECT)\n\t\t__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);\n\telse\n\t\t__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\n\n\tif (features->type == HID_GENERIC)\n\t\t \n\t\treturn 0;\n\n\tinput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\t__set_bit(ABS_MISC, input_dev->absbit);\n\n\tinput_set_abs_params(input_dev, ABS_X, 0 + features->offset_left,\n\t\t\t     features->x_max - features->offset_right,\n\t\t\t     features->x_fuzz, 0);\n\tinput_set_abs_params(input_dev, ABS_Y, 0 + features->offset_top,\n\t\t\t     features->y_max - features->offset_bottom,\n\t\t\t     features->y_fuzz, 0);\n\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0,\n\t\tfeatures->pressure_max, features->pressure_fuzz, 0);\n\n\t \n\tinput_abs_set_res(input_dev, ABS_X, features->x_resolution);\n\tinput_abs_set_res(input_dev, ABS_Y, features->y_resolution);\n\n\tswitch (features->type) {\n\tcase GRAPHIRE_BT:\n\t\t__clear_bit(ABS_MISC, input_dev->absbit);\n\t\tfallthrough;\n\n\tcase WACOM_MO:\n\tcase WACOM_G4:\n\t\tinput_set_abs_params(input_dev, ABS_DISTANCE, 0,\n\t\t\t\t\t      features->distance_max,\n\t\t\t\t\t      features->distance_fuzz, 0);\n\t\tfallthrough;\n\n\tcase GRAPHIRE:\n\t\tinput_set_capability(input_dev, EV_REL, REL_WHEEL);\n\n\t\t__set_bit(BTN_LEFT, input_dev->keybit);\n\t\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\t\t__set_bit(BTN_MIDDLE, input_dev->keybit);\n\n\t\t__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\n\t\t__set_bit(BTN_TOOL_PEN, input_dev->keybit);\n\t\t__set_bit(BTN_TOOL_MOUSE, input_dev->keybit);\n\t\t__set_bit(BTN_STYLUS, input_dev->keybit);\n\t\t__set_bit(BTN_STYLUS2, input_dev->keybit);\n\t\tbreak;\n\n\tcase WACOM_27QHD:\n\tcase WACOM_24HD:\n\tcase DTK:\n\tcase WACOM_22HD:\n\tcase WACOM_21UX2:\n\tcase WACOM_BEE:\n\tcase CINTIQ:\n\tcase WACOM_13HD:\n\tcase CINTIQ_HYBRID:\n\tcase CINTIQ_COMPANION_2:\n\t\tinput_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);\n\t\tinput_abs_set_res(input_dev, ABS_Z, 287);\n\t\twacom_setup_cintiq(wacom_wac);\n\t\tbreak;\n\n\tcase INTUOS3:\n\tcase INTUOS3L:\n\tcase INTUOS3S:\n\tcase INTUOS4:\n\tcase INTUOS4WL:\n\tcase INTUOS4L:\n\tcase INTUOS4S:\n\t\tinput_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);\n\t\tinput_abs_set_res(input_dev, ABS_Z, 287);\n\t\tfallthrough;\n\n\tcase INTUOS:\n\t\twacom_setup_intuos(wacom_wac);\n\t\tbreak;\n\n\tcase INTUOS5:\n\tcase INTUOS5L:\n\tcase INTUOSPM:\n\tcase INTUOSPL:\n\tcase INTUOS5S:\n\tcase INTUOSPS:\n\tcase INTUOSP2_BT:\n\tcase INTUOSP2S_BT:\n\t\tinput_set_abs_params(input_dev, ABS_DISTANCE, 0,\n\t\t\t\t      features->distance_max,\n\t\t\t\t      features->distance_fuzz, 0);\n\n\t\tinput_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);\n\t\tinput_abs_set_res(input_dev, ABS_Z, 287);\n\n\t\twacom_setup_intuos(wacom_wac);\n\t\tbreak;\n\n\tcase WACOM_24HDT:\n\tcase WACOM_27QHDT:\n\tcase MTSCREEN:\n\tcase MTTPC:\n\tcase MTTPC_B:\n\tcase TABLETPC2FG:\n\tcase TABLETPC:\n\tcase TABLETPCE:\n\t\t__clear_bit(ABS_MISC, input_dev->absbit);\n\t\tfallthrough;\n\n\tcase DTUS:\n\tcase DTUSX:\n\tcase PL:\n\tcase DTU:\n\t\t__set_bit(BTN_TOOL_PEN, input_dev->keybit);\n\t\t__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\n\t\t__set_bit(BTN_STYLUS, input_dev->keybit);\n\t\t__set_bit(BTN_STYLUS2, input_dev->keybit);\n\t\tbreak;\n\n\tcase PTU:\n\t\t__set_bit(BTN_STYLUS2, input_dev->keybit);\n\t\tfallthrough;\n\n\tcase PENPARTNER:\n\t\t__set_bit(BTN_TOOL_PEN, input_dev->keybit);\n\t\t__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\n\t\t__set_bit(BTN_STYLUS, input_dev->keybit);\n\t\tbreak;\n\n\tcase INTUOSHT:\n\tcase BAMBOO_PT:\n\tcase BAMBOO_PEN:\n\tcase INTUOSHT2:\n\tcase INTUOSHT3_BT:\n\t\tif (features->type == INTUOSHT2 ||\n\t\t    features->type == INTUOSHT3_BT) {\n\t\t\twacom_setup_basic_pro_pen(wacom_wac);\n\t\t} else {\n\t\t\t__clear_bit(ABS_MISC, input_dev->absbit);\n\t\t\t__set_bit(BTN_TOOL_PEN, input_dev->keybit);\n\t\t\t__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);\n\t\t\t__set_bit(BTN_STYLUS, input_dev->keybit);\n\t\t\t__set_bit(BTN_STYLUS2, input_dev->keybit);\n\t\t\tinput_set_abs_params(input_dev, ABS_DISTANCE, 0,\n\t\t\t\t      features->distance_max,\n\t\t\t\t      features->distance_fuzz, 0);\n\t\t}\n\t\tbreak;\n\tcase BAMBOO_PAD:\n\t\t__clear_bit(ABS_MISC, input_dev->absbit);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint wacom_setup_touch_input_capabilities(struct input_dev *input_dev,\n\t\t\t\t\t struct wacom_wac *wacom_wac)\n{\n\tstruct wacom_features *features = &wacom_wac->features;\n\n\tif (!(features->device_type & WACOM_DEVICETYPE_TOUCH))\n\t\treturn -ENODEV;\n\n\tif (features->device_type & WACOM_DEVICETYPE_DIRECT)\n\t\t__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);\n\telse\n\t\t__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\n\n\tif (features->type == HID_GENERIC)\n\t\t \n\t\treturn 0;\n\n\tinput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\t__set_bit(BTN_TOUCH, input_dev->keybit);\n\n\tif (features->touch_max == 1) {\n\t\tinput_set_abs_params(input_dev, ABS_X, 0,\n\t\t\tfeatures->x_max, features->x_fuzz, 0);\n\t\tinput_set_abs_params(input_dev, ABS_Y, 0,\n\t\t\tfeatures->y_max, features->y_fuzz, 0);\n\t\tinput_abs_set_res(input_dev, ABS_X,\n\t\t\t\t  features->x_resolution);\n\t\tinput_abs_set_res(input_dev, ABS_Y,\n\t\t\t\t  features->y_resolution);\n\t}\n\telse if (features->touch_max > 1) {\n\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,\n\t\t\tfeatures->x_max, features->x_fuzz, 0);\n\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,\n\t\t\tfeatures->y_max, features->y_fuzz, 0);\n\t\tinput_abs_set_res(input_dev, ABS_MT_POSITION_X,\n\t\t\t\t  features->x_resolution);\n\t\tinput_abs_set_res(input_dev, ABS_MT_POSITION_Y,\n\t\t\t\t  features->y_resolution);\n\t}\n\n\tswitch (features->type) {\n\tcase INTUOSP2_BT:\n\tcase INTUOSP2S_BT:\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_SW);\n\t\t__set_bit(SW_MUTE_DEVICE, input_dev->swbit);\n\n\t\tif (wacom_wac->shared->touch->product == 0x361) {\n\t\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X,\n\t\t\t\t\t     0, 12440, 4, 0);\n\t\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\n\t\t\t\t\t     0, 8640, 4, 0);\n\t\t}\n\t\telse if (wacom_wac->shared->touch->product == 0x360) {\n\t\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X,\n\t\t\t\t\t     0, 8960, 4, 0);\n\t\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\n\t\t\t\t\t     0, 5920, 4, 0);\n\t\t}\n\t\telse if (wacom_wac->shared->touch->product == 0x393) {\n\t\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_X,\n\t\t\t\t\t     0, 6400, 4, 0);\n\t\t\tinput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\n\t\t\t\t\t     0, 4000, 4, 0);\n\t\t}\n\t\tinput_abs_set_res(input_dev, ABS_MT_POSITION_X, 40);\n\t\tinput_abs_set_res(input_dev, ABS_MT_POSITION_Y, 40);\n\n\t\tfallthrough;\n\n\tcase INTUOS5:\n\tcase INTUOS5L:\n\tcase INTUOSPM:\n\tcase INTUOSPL:\n\tcase INTUOS5S:\n\tcase INTUOSPS:\n\t\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);\n\t\tinput_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);\n\t\tbreak;\n\n\tcase WACOM_24HDT:\n\t\tinput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);\n\t\tfallthrough;\n\n\tcase WACOM_27QHDT:\n\t\tif (wacom_wac->shared->touch->product == 0x32C ||\n\t\t    wacom_wac->shared->touch->product == 0xF6) {\n\t\t\tinput_dev->evbit[0] |= BIT_MASK(EV_SW);\n\t\t\t__set_bit(SW_MUTE_DEVICE, input_dev->swbit);\n\t\t\twacom_wac->has_mute_touch_switch = true;\n\t\t\twacom_wac->is_soft_touch_switch = true;\n\t\t}\n\t\tfallthrough;\n\n\tcase MTSCREEN:\n\tcase MTTPC:\n\tcase MTTPC_B:\n\tcase TABLETPC2FG:\n\t\tinput_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);\n\t\tfallthrough;\n\n\tcase TABLETPC:\n\tcase TABLETPCE:\n\t\tbreak;\n\n\tcase INTUOSHT:\n\tcase INTUOSHT2:\n\t\tinput_dev->evbit[0] |= BIT_MASK(EV_SW);\n\t\t__set_bit(SW_MUTE_DEVICE, input_dev->swbit);\n\t\tfallthrough;\n\n\tcase BAMBOO_PT:\n\tcase BAMBOO_TOUCH:\n\t\tif (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {\n\t\t\tinput_set_abs_params(input_dev,\n\t\t\t\t     ABS_MT_TOUCH_MAJOR,\n\t\t\t\t     0, features->x_max, 0, 0);\n\t\t\tinput_set_abs_params(input_dev,\n\t\t\t\t     ABS_MT_TOUCH_MINOR,\n\t\t\t\t     0, features->y_max, 0, 0);\n\t\t}\n\t\tinput_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);\n\t\tbreak;\n\n\tcase BAMBOO_PAD:\n\t\tinput_mt_init_slots(input_dev, features->touch_max,\n\t\t\t\t    INPUT_MT_POINTER);\n\t\t__set_bit(BTN_LEFT, input_dev->keybit);\n\t\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int wacom_numbered_button_to_key(int n)\n{\n\tif (n < 10)\n\t\treturn BTN_0 + n;\n\telse if (n < 16)\n\t\treturn BTN_A + (n-10);\n\telse if (n < 18)\n\t\treturn BTN_BASE + (n-16);\n\telse\n\t\treturn 0;\n}\n\nstatic void wacom_setup_numbered_buttons(struct input_dev *input_dev,\n\t\t\t\tint button_count)\n{\n\tint i;\n\n\tfor (i = 0; i < button_count; i++) {\n\t\tint key = wacom_numbered_button_to_key(i);\n\n\t\tif (key)\n\t\t\t__set_bit(key, input_dev->keybit);\n\t}\n}\n\nstatic void wacom_24hd_update_leds(struct wacom *wacom, int mask, int group)\n{\n\tstruct wacom_led *led;\n\tint i;\n\tbool updated = false;\n\n\t \n\tif (group == 0)\n\t\tmask >>= 8;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tled = wacom_led_find(wacom, group, i);\n\t\tif (!led) {\n\t\t\thid_err(wacom->hdev, \"can't find LED %d in group %d\\n\",\n\t\t\t\ti, group);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!updated && mask & BIT(i)) {\n\t\t\tled->held = true;\n\t\t\tled_trigger_event(&led->trigger, LED_FULL);\n\t\t} else {\n\t\t\tled->held = false;\n\t\t}\n\t}\n}\n\nstatic bool wacom_is_led_toggled(struct wacom *wacom, int button_count,\n\t\t\t\t int mask, int group)\n{\n\tint group_button;\n\n\t \n\tif (wacom->wacom_wac.features.type == WACOM_21UX2)\n\t\tgroup = 1 - group;\n\n\tgroup_button = group * (button_count/wacom->led.count);\n\n\tif (wacom->wacom_wac.features.type == INTUOSP2_BT)\n\t\tgroup_button = 8;\n\n\treturn mask & (1 << group_button);\n}\n\nstatic void wacom_update_led(struct wacom *wacom, int button_count, int mask,\n\t\t\t     int group)\n{\n\tstruct wacom_led *led, *next_led;\n\tint cur;\n\tbool pressed;\n\n\tif (wacom->wacom_wac.features.type == WACOM_24HD)\n\t\treturn wacom_24hd_update_leds(wacom, mask, group);\n\n\tpressed = wacom_is_led_toggled(wacom, button_count, mask, group);\n\tcur = wacom->led.groups[group].select;\n\n\tled = wacom_led_find(wacom, group, cur);\n\tif (!led) {\n\t\thid_err(wacom->hdev, \"can't find current LED %d in group %d\\n\",\n\t\t\tcur, group);\n\t\treturn;\n\t}\n\n\tif (!pressed) {\n\t\tled->held = false;\n\t\treturn;\n\t}\n\n\tif (led->held && pressed)\n\t\treturn;\n\n\tnext_led = wacom_led_next(wacom, led);\n\tif (!next_led) {\n\t\thid_err(wacom->hdev, \"can't find next LED in group %d\\n\",\n\t\t\tgroup);\n\t\treturn;\n\t}\n\tif (next_led == led)\n\t\treturn;\n\n\tnext_led->held = true;\n\tled_trigger_event(&next_led->trigger,\n\t\t\t  wacom_leds_brightness_get(next_led));\n}\n\nstatic void wacom_report_numbered_buttons(struct input_dev *input_dev,\n\t\t\t\tint button_count, int mask)\n{\n\tstruct wacom *wacom = input_get_drvdata(input_dev);\n\tint i;\n\n\tfor (i = 0; i < wacom->led.count; i++)\n\t\twacom_update_led(wacom,  button_count, mask, i);\n\n\tfor (i = 0; i < button_count; i++) {\n\t\tint key = wacom_numbered_button_to_key(i);\n\n\t\tif (key)\n\t\t\tinput_report_key(input_dev, key, mask & (1 << i));\n\t}\n}\n\nint wacom_setup_pad_input_capabilities(struct input_dev *input_dev,\n\t\t\t\t   struct wacom_wac *wacom_wac)\n{\n\tstruct wacom_features *features = &wacom_wac->features;\n\n\tif ((features->type == HID_GENERIC) && features->numbered_buttons > 0)\n\t\tfeatures->device_type |= WACOM_DEVICETYPE_PAD;\n\n\tif (!(features->device_type & WACOM_DEVICETYPE_PAD))\n\t\treturn -ENODEV;\n\n\tif (features->type == REMOTE && input_dev == wacom_wac->pad_input)\n\t\treturn -ENODEV;\n\n\tinput_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\n\t \n\t__set_bit(ABS_MISC, input_dev->absbit);\n\n\t \n\tif (!(input_dev->absinfo && (input_dev->absinfo[ABS_X].minimum ||\n\t      input_dev->absinfo[ABS_X].maximum)))\n\t\tinput_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);\n\tif (!(input_dev->absinfo && (input_dev->absinfo[ABS_Y].minimum ||\n\t      input_dev->absinfo[ABS_Y].maximum)))\n\t\tinput_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);\n\n\t \n\t__set_bit(BTN_STYLUS, input_dev->keybit);\n\n\twacom_setup_numbered_buttons(input_dev, features->numbered_buttons);\n\n\tswitch (features->type) {\n\n\tcase CINTIQ_HYBRID:\n\tcase CINTIQ_COMPANION_2:\n\tcase DTK:\n\tcase DTUS:\n\tcase GRAPHIRE_BT:\n\t\tbreak;\n\n\tcase WACOM_MO:\n\t\t__set_bit(BTN_BACK, input_dev->keybit);\n\t\t__set_bit(BTN_LEFT, input_dev->keybit);\n\t\t__set_bit(BTN_FORWARD, input_dev->keybit);\n\t\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\t\tinput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\n\t\tbreak;\n\n\tcase WACOM_G4:\n\t\t__set_bit(BTN_BACK, input_dev->keybit);\n\t\t__set_bit(BTN_FORWARD, input_dev->keybit);\n\t\tinput_set_capability(input_dev, EV_REL, REL_WHEEL);\n\t\tbreak;\n\n\tcase WACOM_24HD:\n\t\t__set_bit(KEY_PROG1, input_dev->keybit);\n\t\t__set_bit(KEY_PROG2, input_dev->keybit);\n\t\t__set_bit(KEY_PROG3, input_dev->keybit);\n\n\t\t__set_bit(KEY_ONSCREEN_KEYBOARD, input_dev->keybit);\n\t\t__set_bit(KEY_INFO, input_dev->keybit);\n\n\t\tif (!features->oPid)\n\t\t\t__set_bit(KEY_BUTTONCONFIG, input_dev->keybit);\n\n\t\tinput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);\n\t\tbreak;\n\n\tcase WACOM_27QHD:\n\t\t__set_bit(KEY_PROG1, input_dev->keybit);\n\t\t__set_bit(KEY_PROG2, input_dev->keybit);\n\t\t__set_bit(KEY_PROG3, input_dev->keybit);\n\n\t\t__set_bit(KEY_ONSCREEN_KEYBOARD, input_dev->keybit);\n\t\t__set_bit(KEY_BUTTONCONFIG, input_dev->keybit);\n\n\t\tif (!features->oPid)\n\t\t\t__set_bit(KEY_CONTROLPANEL, input_dev->keybit);\n\t\tinput_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);\n\t\tinput_abs_set_res(input_dev, ABS_X, 1024);  \n\t\tinput_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);\n\t\tinput_abs_set_res(input_dev, ABS_Y, 1024);\n\t\tinput_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);\n\t\tinput_abs_set_res(input_dev, ABS_Z, 1024);\n\t\t__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);\n\t\tbreak;\n\n\tcase WACOM_22HD:\n\t\t__set_bit(KEY_PROG1, input_dev->keybit);\n\t\t__set_bit(KEY_PROG2, input_dev->keybit);\n\t\t__set_bit(KEY_PROG3, input_dev->keybit);\n\n\t\t__set_bit(KEY_BUTTONCONFIG, input_dev->keybit);\n\t\t__set_bit(KEY_INFO, input_dev->keybit);\n\t\tfallthrough;\n\n\tcase WACOM_21UX2:\n\tcase WACOM_BEE:\n\tcase CINTIQ:\n\t\tinput_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);\n\t\tbreak;\n\n\tcase WACOM_13HD:\n\t\tinput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\n\t\tbreak;\n\n\tcase INTUOS3:\n\tcase INTUOS3L:\n\t\tinput_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);\n\t\tfallthrough;\n\n\tcase INTUOS3S:\n\t\tinput_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);\n\t\tbreak;\n\n\tcase INTUOS5:\n\tcase INTUOS5L:\n\tcase INTUOSPM:\n\tcase INTUOSPL:\n\tcase INTUOS5S:\n\tcase INTUOSPS:\n\tcase INTUOSP2_BT:\n\tcase INTUOSP2S_BT:\n\t\tinput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\n\t\tbreak;\n\n\tcase INTUOS4WL:\n\t\t \n\t\t__set_bit(BTN_STYLUS, input_dev->keybit);\n\t\tfallthrough;\n\n\tcase INTUOS4:\n\tcase INTUOS4L:\n\tcase INTUOS4S:\n\t\tinput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\n\t\tbreak;\n\n\tcase INTUOSHT:\n\tcase BAMBOO_PT:\n\tcase BAMBOO_TOUCH:\n\tcase INTUOSHT2:\n\t\t__clear_bit(ABS_MISC, input_dev->absbit);\n\n\t\t__set_bit(BTN_LEFT, input_dev->keybit);\n\t\t__set_bit(BTN_FORWARD, input_dev->keybit);\n\t\t__set_bit(BTN_BACK, input_dev->keybit);\n\t\t__set_bit(BTN_RIGHT, input_dev->keybit);\n\n\t\tbreak;\n\n\tcase REMOTE:\n\t\tinput_set_capability(input_dev, EV_MSC, MSC_SERIAL);\n\t\tinput_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);\n\t\tbreak;\n\n\tcase INTUOSHT3_BT:\n\tcase HID_GENERIC:\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic const struct wacom_features wacom_features_0x00 =\n\t{ \"Wacom Penpartner\", 5040, 3780, 255, 0,\n\t  PENPARTNER, WACOM_PENPRTN_RES, WACOM_PENPRTN_RES };\nstatic const struct wacom_features wacom_features_0x10 =\n\t{ \"Wacom Graphire\", 10206, 7422, 511, 63,\n\t  GRAPHIRE, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES };\nstatic const struct wacom_features wacom_features_0x81 =\n\t{ \"Wacom Graphire BT\", 16704, 12064, 511, 32,\n\t  GRAPHIRE_BT, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES, 2 };\nstatic const struct wacom_features wacom_features_0x11 =\n\t{ \"Wacom Graphire2 4x5\", 10206, 7422, 511, 63,\n\t  GRAPHIRE, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES };\nstatic const struct wacom_features wacom_features_0x12 =\n\t{ \"Wacom Graphire2 5x7\", 13918, 10206, 511, 63,\n\t  GRAPHIRE, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES };\nstatic const struct wacom_features wacom_features_0x13 =\n\t{ \"Wacom Graphire3\", 10208, 7424, 511, 63,\n\t  GRAPHIRE, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES };\nstatic const struct wacom_features wacom_features_0x14 =\n\t{ \"Wacom Graphire3 6x8\", 16704, 12064, 511, 63,\n\t  GRAPHIRE, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES };\nstatic const struct wacom_features wacom_features_0x15 =\n\t{ \"Wacom Graphire4 4x5\", 10208, 7424, 511, 63,\n\t  WACOM_G4, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES };\nstatic const struct wacom_features wacom_features_0x16 =\n\t{ \"Wacom Graphire4 6x8\", 16704, 12064, 511, 63,\n\t  WACOM_G4, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES };\nstatic const struct wacom_features wacom_features_0x17 =\n\t{ \"Wacom BambooFun 4x5\", 14760, 9225, 511, 63,\n\t  WACOM_MO, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x18 =\n\t{ \"Wacom BambooFun 6x8\", 21648, 13530, 511, 63,\n\t  WACOM_MO, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x19 =\n\t{ \"Wacom Bamboo1 Medium\", 16704, 12064, 511, 63,\n\t  GRAPHIRE, WACOM_GRAPHIRE_RES, WACOM_GRAPHIRE_RES };\nstatic const struct wacom_features wacom_features_0x60 =\n\t{ \"Wacom Volito\", 5104, 3712, 511, 63,\n\t  GRAPHIRE, WACOM_VOLITO_RES, WACOM_VOLITO_RES };\nstatic const struct wacom_features wacom_features_0x61 =\n\t{ \"Wacom PenStation2\", 3250, 2320, 255, 63,\n\t  GRAPHIRE, WACOM_VOLITO_RES, WACOM_VOLITO_RES };\nstatic const struct wacom_features wacom_features_0x62 =\n\t{ \"Wacom Volito2 4x5\", 5104, 3712, 511, 63,\n\t  GRAPHIRE, WACOM_VOLITO_RES, WACOM_VOLITO_RES };\nstatic const struct wacom_features wacom_features_0x63 =\n\t{ \"Wacom Volito2 2x3\", 3248, 2320, 511, 63,\n\t  GRAPHIRE, WACOM_VOLITO_RES, WACOM_VOLITO_RES };\nstatic const struct wacom_features wacom_features_0x64 =\n\t{ \"Wacom PenPartner2\", 3250, 2320, 511, 63,\n\t  GRAPHIRE, WACOM_VOLITO_RES, WACOM_VOLITO_RES };\nstatic const struct wacom_features wacom_features_0x65 =\n\t{ \"Wacom Bamboo\", 14760, 9225, 511, 63,\n\t  WACOM_MO, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x69 =\n\t{ \"Wacom Bamboo1\", 5104, 3712, 511, 63,\n\t  GRAPHIRE, WACOM_PENPRTN_RES, WACOM_PENPRTN_RES };\nstatic const struct wacom_features wacom_features_0x6A =\n\t{ \"Wacom Bamboo1 4x6\", 14760, 9225, 1023, 63,\n\t  GRAPHIRE, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x6B =\n\t{ \"Wacom Bamboo1 5x8\", 21648, 13530, 1023, 63,\n\t  GRAPHIRE, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x20 =\n\t{ \"Wacom Intuos 4x5\", 12700, 10600, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x21 =\n\t{ \"Wacom Intuos 6x8\", 20320, 16240, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x22 =\n\t{ \"Wacom Intuos 9x12\", 30480, 24060, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x23 =\n\t{ \"Wacom Intuos 12x12\", 30480, 31680, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x24 =\n\t{ \"Wacom Intuos 12x18\", 45720, 31680, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x30 =\n\t{ \"Wacom PL400\", 5408, 4056, 255, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x31 =\n\t{ \"Wacom PL500\", 6144, 4608, 255, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x32 =\n\t{ \"Wacom PL600\", 6126, 4604, 255, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x33 =\n\t{ \"Wacom PL600SX\", 6260, 5016, 255, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x34 =\n\t{ \"Wacom PL550\", 6144, 4608, 511, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x35 =\n\t{ \"Wacom PL800\", 7220, 5780, 511, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x37 =\n\t{ \"Wacom PL700\", 6758, 5406, 511, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x38 =\n\t{ \"Wacom PL510\", 6282, 4762, 511, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x39 =\n\t{ \"Wacom DTU710\", 34080, 27660, 511, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0xC4 =\n\t{ \"Wacom DTF521\", 6282, 4762, 511, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0xC0 =\n\t{ \"Wacom DTF720\", 6858, 5506, 511, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0xC2 =\n\t{ \"Wacom DTF720a\", 6858, 5506, 511, 0,\n\t  PL, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x03 =\n\t{ \"Wacom Cintiq Partner\", 20480, 15360, 511, 0,\n\t  PTU, WACOM_PL_RES, WACOM_PL_RES };\nstatic const struct wacom_features wacom_features_0x41 =\n\t{ \"Wacom Intuos2 4x5\", 12700, 10600, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x42 =\n\t{ \"Wacom Intuos2 6x8\", 20320, 16240, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x43 =\n\t{ \"Wacom Intuos2 9x12\", 30480, 24060, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x44 =\n\t{ \"Wacom Intuos2 12x12\", 30480, 31680, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x45 =\n\t{ \"Wacom Intuos2 12x18\", 45720, 31680, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0xB0 =\n\t{ \"Wacom Intuos3 4x5\", 25400, 20320, 1023, 63,\n\t  INTUOS3S, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 4 };\nstatic const struct wacom_features wacom_features_0xB1 =\n\t{ \"Wacom Intuos3 6x8\", 40640, 30480, 1023, 63,\n\t  INTUOS3, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 8 };\nstatic const struct wacom_features wacom_features_0xB2 =\n\t{ \"Wacom Intuos3 9x12\", 60960, 45720, 1023, 63,\n\t  INTUOS3, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 8 };\nstatic const struct wacom_features wacom_features_0xB3 =\n\t{ \"Wacom Intuos3 12x12\", 60960, 60960, 1023, 63,\n\t  INTUOS3L, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 8 };\nstatic const struct wacom_features wacom_features_0xB4 =\n\t{ \"Wacom Intuos3 12x19\", 97536, 60960, 1023, 63,\n\t  INTUOS3L, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 8 };\nstatic const struct wacom_features wacom_features_0xB5 =\n\t{ \"Wacom Intuos3 6x11\", 54204, 31750, 1023, 63,\n\t  INTUOS3, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 8 };\nstatic const struct wacom_features wacom_features_0xB7 =\n\t{ \"Wacom Intuos3 4x6\", 31496, 19685, 1023, 63,\n\t  INTUOS3S, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 4 };\nstatic const struct wacom_features wacom_features_0xB8 =\n\t{ \"Wacom Intuos4 4x6\", 31496, 19685, 2047, 63,\n\t  INTUOS4S, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 7 };\nstatic const struct wacom_features wacom_features_0xB9 =\n\t{ \"Wacom Intuos4 6x9\", 44704, 27940, 2047, 63,\n\t  INTUOS4, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9 };\nstatic const struct wacom_features wacom_features_0xBA =\n\t{ \"Wacom Intuos4 8x13\", 65024, 40640, 2047, 63,\n\t  INTUOS4L, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9 };\nstatic const struct wacom_features wacom_features_0xBB =\n\t{ \"Wacom Intuos4 12x19\", 97536, 60960, 2047, 63,\n\t  INTUOS4L, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9 };\nstatic const struct wacom_features wacom_features_0xBC =\n\t{ \"Wacom Intuos4 WL\", 40640, 25400, 2047, 63,\n\t  INTUOS4, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9 };\nstatic const struct wacom_features wacom_features_0xBD =\n\t{ \"Wacom Intuos4 WL\", 40640, 25400, 2047, 63,\n\t  INTUOS4WL, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9 };\nstatic const struct wacom_features wacom_features_0x26 =\n\t{ \"Wacom Intuos5 touch S\", 31496, 19685, 2047, 63,\n\t  INTUOS5S, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 7, .touch_max = 16 };\nstatic const struct wacom_features wacom_features_0x27 =\n\t{ \"Wacom Intuos5 touch M\", 44704, 27940, 2047, 63,\n\t  INTUOS5, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9, .touch_max = 16 };\nstatic const struct wacom_features wacom_features_0x28 =\n\t{ \"Wacom Intuos5 touch L\", 65024, 40640, 2047, 63,\n\t  INTUOS5L, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9, .touch_max = 16 };\nstatic const struct wacom_features wacom_features_0x29 =\n\t{ \"Wacom Intuos5 S\", 31496, 19685, 2047, 63,\n\t  INTUOS5S, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 7 };\nstatic const struct wacom_features wacom_features_0x2A =\n\t{ \"Wacom Intuos5 M\", 44704, 27940, 2047, 63,\n\t  INTUOS5, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9 };\nstatic const struct wacom_features wacom_features_0x314 =\n\t{ \"Wacom Intuos Pro S\", 31496, 19685, 2047, 63,\n\t  INTUOSPS, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 7, .touch_max = 16,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x315 =\n\t{ \"Wacom Intuos Pro M\", 44704, 27940, 2047, 63,\n\t  INTUOSPM, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9, .touch_max = 16,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x317 =\n\t{ \"Wacom Intuos Pro L\", 65024, 40640, 2047, 63,\n\t  INTUOSPL, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9, .touch_max = 16,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0xF4 =\n\t{ \"Wacom Cintiq 24HD\", 104480, 65600, 2047, 63,\n\t  WACOM_24HD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 16,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET };\nstatic const struct wacom_features wacom_features_0xF8 =\n\t{ \"Wacom Cintiq 24HD touch\", 104480, 65600, 2047, 63,  \n\t  WACOM_24HD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 16,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0xf6 };\nstatic const struct wacom_features wacom_features_0xF6 =\n\t{ \"Wacom Cintiq 24HD touch\", .type = WACOM_24HDT,  \n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0xf8, .touch_max = 10,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x32A =\n\t{ \"Wacom Cintiq 27QHD\", 120140, 67920, 2047, 63,\n\t  WACOM_27QHD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 0,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET };\nstatic const struct wacom_features wacom_features_0x32B =\n\t{ \"Wacom Cintiq 27QHD touch\", 120140, 67920, 2047, 63,\n\t  WACOM_27QHD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 0,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x32C };\nstatic const struct wacom_features wacom_features_0x32C =\n\t{ \"Wacom Cintiq 27QHD touch\", .type = WACOM_27QHDT,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x32B, .touch_max = 10 };\nstatic const struct wacom_features wacom_features_0x3F =\n\t{ \"Wacom Cintiq 21UX\", 87200, 65600, 1023, 63,\n\t  CINTIQ, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 8 };\nstatic const struct wacom_features wacom_features_0xC5 =\n\t{ \"Wacom Cintiq 20WSX\", 86680, 54180, 1023, 63,\n\t  WACOM_BEE, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 10 };\nstatic const struct wacom_features wacom_features_0xC6 =\n\t{ \"Wacom Cintiq 12WX\", 53020, 33440, 1023, 63,\n\t  WACOM_BEE, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 10 };\nstatic const struct wacom_features wacom_features_0x304 =\n\t{ \"Wacom Cintiq 13HD\", 59552, 33848, 1023, 63,\n\t  WACOM_13HD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET };\nstatic const struct wacom_features wacom_features_0x333 =\n\t{ \"Wacom Cintiq 13HD touch\", 59552, 33848, 2047, 63,\n\t  WACOM_13HD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x335 };\nstatic const struct wacom_features wacom_features_0x335 =\n\t{ \"Wacom Cintiq 13HD touch\", .type = WACOM_24HDT,  \n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x333, .touch_max = 10,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0xC7 =\n\t{ \"Wacom DTU1931\", 37832, 30305, 511, 0,\n\t  PL, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0xCE =\n\t{ \"Wacom DTU2231\", 47864, 27011, 511, 0,\n\t  DTU, WACOM_INTUOS_RES, WACOM_INTUOS_RES,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBMOUSE };\nstatic const struct wacom_features wacom_features_0xF0 =\n\t{ \"Wacom DTU1631\", 34623, 19553, 511, 0,\n\t  DTU, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0xFB =\n\t{ \"Wacom DTU1031\", 22096, 13960, 511, 0,\n\t  DTUS, WACOM_INTUOS_RES, WACOM_INTUOS_RES, 4,\n\t  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET,\n\t  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET };\nstatic const struct wacom_features wacom_features_0x32F =\n\t{ \"Wacom DTU1031X\", 22672, 12928, 511, 0,\n\t  DTUSX, WACOM_INTUOS_RES, WACOM_INTUOS_RES, 0,\n\t  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET,\n\t  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET };\nstatic const struct wacom_features wacom_features_0x336 =\n\t{ \"Wacom DTU1141\", 23672, 13403, 1023, 0,\n\t  DTUS, WACOM_INTUOS_RES, WACOM_INTUOS_RES, 4,\n\t  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET,\n\t  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET };\nstatic const struct wacom_features wacom_features_0x57 =\n\t{ \"Wacom DTK2241\", 95840, 54260, 2047, 63,\n\t  DTK, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 6,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET };\nstatic const struct wacom_features wacom_features_0x59 =  \n\t{ \"Wacom DTH2242\", 95840, 54260, 2047, 63,\n\t  DTK, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 6,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5D };\nstatic const struct wacom_features wacom_features_0x5D =  \n\t{ \"Wacom DTH2242\",       .type = WACOM_24HDT,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x59, .touch_max = 10,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0xCC =\n\t{ \"Wacom Cintiq 21UX2\", 87200, 65600, 2047, 63,\n\t  WACOM_21UX2, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 18,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET };\nstatic const struct wacom_features wacom_features_0xFA =\n\t{ \"Wacom Cintiq 22HD\", 95840, 54260, 2047, 63,\n\t  WACOM_22HD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 18,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET };\nstatic const struct wacom_features wacom_features_0x5B =\n\t{ \"Wacom Cintiq 22HDT\", 95840, 54260, 2047, 63,\n\t  WACOM_22HD, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 18,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5e };\nstatic const struct wacom_features wacom_features_0x5E =\n\t{ \"Wacom Cintiq 22HDT\", .type = WACOM_24HDT,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5b, .touch_max = 10,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x90 =\n\t{ \"Wacom ISDv4 90\", 26202, 16325, 255, 0,\n\t  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };  \nstatic const struct wacom_features wacom_features_0x93 =\n\t{ \"Wacom ISDv4 93\", 26202, 16325, 255, 0,\n\t  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 1 };\nstatic const struct wacom_features wacom_features_0x97 =\n\t{ \"Wacom ISDv4 97\", 26202, 16325, 511, 0,\n\t  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };  \nstatic const struct wacom_features wacom_features_0x9A =\n\t{ \"Wacom ISDv4 9A\", 26202, 16325, 255, 0,\n\t  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 1 };\nstatic const struct wacom_features wacom_features_0x9F =\n\t{ \"Wacom ISDv4 9F\", 26202, 16325, 255, 0,\n\t  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 1 };\nstatic const struct wacom_features wacom_features_0xE2 =\n\t{ \"Wacom ISDv4 E2\", 26202, 16325, 255, 0,\n\t  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xE3 =\n\t{ \"Wacom ISDv4 E3\", 26202, 16325, 255, 0,\n\t  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xE5 =\n\t{ \"Wacom ISDv4 E5\", 26202, 16325, 255, 0,\n\t  MTSCREEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0xE6 =\n\t{ \"Wacom ISDv4 E6\", 27760, 15694, 255, 0,\n\t  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xEC =\n\t{ \"Wacom ISDv4 EC\", 25710, 14500, 255, 0,\n\t  TABLETPC,    WACOM_INTUOS_RES, WACOM_INTUOS_RES };  \nstatic const struct wacom_features wacom_features_0xED =\n\t{ \"Wacom ISDv4 ED\", 26202, 16325, 255, 0,\n\t  TABLETPCE, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 1 };\nstatic const struct wacom_features wacom_features_0xEF =\n\t{ \"Wacom ISDv4 EF\", 26202, 16325, 255, 0,\n\t  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };  \nstatic const struct wacom_features wacom_features_0x100 =\n\t{ \"Wacom ISDv4 100\", 26202, 16325, 255, 0,\n\t  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x101 =\n\t{ \"Wacom ISDv4 101\", 26202, 16325, 255, 0,\n\t  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x10D =\n\t{ \"Wacom ISDv4 10D\", 26202, 16325, 255, 0,\n\t  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x10E =\n\t{ \"Wacom ISDv4 10E\", 27760, 15694, 255, 0,\n\t  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x10F =\n\t{ \"Wacom ISDv4 10F\", 27760, 15694, 255, 0,\n\t  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x116 =\n\t{ \"Wacom ISDv4 116\", 26202, 16325, 255, 0,\n\t  TABLETPCE, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 1 };\nstatic const struct wacom_features wacom_features_0x12C =\n\t{ \"Wacom ISDv4 12C\", 27848, 15752, 2047, 0,\n\t  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };  \nstatic const struct wacom_features wacom_features_0x4001 =\n\t{ \"Wacom ISDv4 4001\", 26202, 16325, 255, 0,\n\t  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x4004 =\n\t{ \"Wacom ISDv4 4004\", 11060, 6220, 255, 0,\n\t  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x5000 =\n\t{ \"Wacom ISDv4 5000\", 27848, 15752, 1023, 0,\n\t  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x5002 =\n\t{ \"Wacom ISDv4 5002\", 29576, 16724, 1023, 0,\n\t  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x47 =\n\t{ \"Wacom Intuos2 6x8\", 20320, 16240, 1023, 31,\n\t  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x84 =\n\t{ \"Wacom Wireless Receiver\", .type = WIRELESS, .touch_max = 16 };\nstatic const struct wacom_features wacom_features_0xD0 =\n\t{ \"Wacom Bamboo 2FG\", 14720, 9200, 1023, 31,\n\t  BAMBOO_TOUCH, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xD1 =\n\t{ \"Wacom Bamboo 2FG 4x5\", 14720, 9200, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xD2 =\n\t{ \"Wacom Bamboo Craft\", 14720, 9200, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xD3 =\n\t{ \"Wacom Bamboo 2FG 6x8\", 21648, 13700, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xD4 =\n\t{ \"Wacom Bamboo Pen\", 14720, 9200, 1023, 31,\n\t  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0xD5 =\n\t{ \"Wacom Bamboo Pen 6x8\", 21648, 13700, 1023, 31,\n\t  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0xD6 =\n\t{ \"Wacom BambooPT 2FG 4x5\", 14720, 9200, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xD7 =\n\t{ \"Wacom BambooPT 2FG Small\", 14720, 9200, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xD8 =\n\t{ \"Wacom Bamboo Comic 2FG\", 21648, 13700, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xDA =\n\t{ \"Wacom Bamboo 2FG 4x5 SE\", 14720, 9200, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xDB =\n\t{ \"Wacom Bamboo 2FG 6x8 SE\", 21648, 13700, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };\nstatic const struct wacom_features wacom_features_0xDD =\n        { \"Wacom Bamboo Connect\", 14720, 9200, 1023, 31,\n          BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0xDE =\n        { \"Wacom Bamboo 16FG 4x5\", 14720, 9200, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16 };\nstatic const struct wacom_features wacom_features_0xDF =\n        { \"Wacom Bamboo 16FG 6x8\", 21648, 13700, 1023, 31,\n\t  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16 };\nstatic const struct wacom_features wacom_features_0x300 =\n\t{ \"Wacom Bamboo One S\", 14720, 9225, 1023, 31,\n\t  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x301 =\n\t{ \"Wacom Bamboo One M\", 21648, 13530, 1023, 31,\n\t  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x302 =\n\t{ \"Wacom Intuos PT S\", 15200, 9500, 1023, 31,\n\t  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x303 =\n\t{ \"Wacom Intuos PT M\", 21600, 13500, 1023, 31,\n\t  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x30E =\n\t{ \"Wacom Intuos S\", 15200, 9500, 1023, 31,\n\t  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x6004 =\n\t{ \"ISD-V4\", 12800, 8000, 255, 0,\n\t  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x307 =\n\t{ \"Wacom ISDv5 307\", 59552, 33848, 2047, 63,\n\t  CINTIQ_HYBRID, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x309 };\nstatic const struct wacom_features wacom_features_0x309 =\n\t{ \"Wacom ISDv5 309\", .type = WACOM_24HDT,  \n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x0307, .touch_max = 10,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x30A =\n\t{ \"Wacom ISDv5 30A\", 59552, 33848, 2047, 63,\n\t  CINTIQ_HYBRID, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x30C };\nstatic const struct wacom_features wacom_features_0x30C =\n\t{ \"Wacom ISDv5 30C\", .type = WACOM_24HDT,  \n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x30A, .touch_max = 10,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x318 =\n\t{ \"Wacom USB Bamboo PAD\", 4095, 4095,  \n\t  .type = BAMBOO_PAD, 35, 48, .touch_max = 4 };\nstatic const struct wacom_features wacom_features_0x319 =\n\t{ \"Wacom Wireless Bamboo PAD\", 4095, 4095,  \n\t  .type = BAMBOO_PAD, 35, 48, .touch_max = 4 };\nstatic const struct wacom_features wacom_features_0x325 =\n\t{ \"Wacom ISDv5 325\", 59552, 33848, 2047, 63,\n\t  CINTIQ_COMPANION_2, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 11,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,\n\t  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x326 };\nstatic const struct wacom_features wacom_features_0x326 =  \n\t{ \"Wacom ISDv5 326\", .type = HID_GENERIC, .oVid = USB_VENDOR_ID_WACOM,\n\t  .oPid = 0x325 };\nstatic const struct wacom_features wacom_features_0x323 =\n\t{ \"Wacom Intuos P M\", 21600, 13500, 1023, 31,\n\t  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x331 =\n\t{ \"Wacom Express Key Remote\", .type = REMOTE,\n\t  .numbered_buttons = 18, .check_for_hid_type = true,\n\t  .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x33B =\n\t{ \"Wacom Intuos S 2\", 15200, 9500, 2047, 63,\n\t  INTUOSHT2, WACOM_INTUOS_RES, WACOM_INTUOS_RES,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x33C =\n\t{ \"Wacom Intuos PT S 2\", 15200, 9500, 2047, 63,\n\t  INTUOSHT2, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x33D =\n\t{ \"Wacom Intuos P M 2\", 21600, 13500, 2047, 63,\n\t  INTUOSHT2, WACOM_INTUOS_RES, WACOM_INTUOS_RES,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x33E =\n\t{ \"Wacom Intuos PT M 2\", 21600, 13500, 2047, 63,\n\t  INTUOSHT2, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,\n\t  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };\nstatic const struct wacom_features wacom_features_0x343 =\n\t{ \"Wacom DTK1651\", 34816, 19759, 1023, 0,\n\t  DTUS, WACOM_INTUOS_RES, WACOM_INTUOS_RES, 4,\n\t  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET,\n\t  WACOM_DTU_OFFSET, WACOM_DTU_OFFSET };\nstatic const struct wacom_features wacom_features_0x360 =\n\t{ \"Wacom Intuos Pro M\", 44800, 29600, 8191, 63,\n\t  INTUOSP2_BT, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9, .touch_max = 10 };\nstatic const struct wacom_features wacom_features_0x361 =\n\t{ \"Wacom Intuos Pro L\", 62200, 43200, 8191, 63,\n\t  INTUOSP2_BT, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9, .touch_max = 10 };\nstatic const struct wacom_features wacom_features_0x377 =\n\t{ \"Wacom Intuos BT S\", 15200, 9500, 4095, 63,\n\t  INTUOSHT3_BT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, 4 };\nstatic const struct wacom_features wacom_features_0x379 =\n\t{ \"Wacom Intuos BT M\", 21600, 13500, 4095, 63,\n\t  INTUOSHT3_BT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, 4 };\nstatic const struct wacom_features wacom_features_0x37A =\n\t{ \"Wacom One by Wacom S\", 15200, 9500, 2047, 63,\n\t  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x37B =\n\t{ \"Wacom One by Wacom M\", 21600, 13500, 2047, 63,\n\t  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };\nstatic const struct wacom_features wacom_features_0x393 =\n\t{ \"Wacom Intuos Pro S\", 31920, 19950, 8191, 63,\n\t  INTUOSP2S_BT, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 7,\n\t  .touch_max = 10 };\nstatic const struct wacom_features wacom_features_0x3c6 =\n\t{ \"Wacom Intuos BT S\", 15200, 9500, 4095, 63,\n\t  INTUOSHT3_BT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, 4 };\nstatic const struct wacom_features wacom_features_0x3c8 =\n\t{ \"Wacom Intuos BT M\", 21600, 13500, 4095, 63,\n\t  INTUOSHT3_BT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, 4 };\nstatic const struct wacom_features wacom_features_0x3dd =\n\t{ \"Wacom Intuos Pro S\", 31920, 19950, 8191, 63,\n\t  INTUOSP2S_BT, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 7,\n\t  .touch_max = 10 };\n\nstatic const struct wacom_features wacom_features_HID_ANY_ID =\n\t{ \"Wacom HID\", .type = HID_GENERIC, .oVid = HID_ANY_ID, .oPid = HID_ANY_ID };\n\nstatic const struct wacom_features wacom_features_0x94 =\n\t{ \"Wacom Bootloader\", .type = BOOTLOADER };\n\n#define USB_DEVICE_WACOM(prod)\t\t\t\t\t\t\\\n\tHID_DEVICE(BUS_USB, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\\\n\t.driver_data = (kernel_ulong_t)&wacom_features_##prod\n\n#define BT_DEVICE_WACOM(prod)\t\t\t\t\t\t\\\n\tHID_DEVICE(BUS_BLUETOOTH, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\\\n\t.driver_data = (kernel_ulong_t)&wacom_features_##prod\n\n#define I2C_DEVICE_WACOM(prod)\t\t\t\t\t\t\\\n\tHID_DEVICE(BUS_I2C, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\\\n\t.driver_data = (kernel_ulong_t)&wacom_features_##prod\n\n#define USB_DEVICE_LENOVO(prod)\t\t\t\t\t\\\n\tHID_USB_DEVICE(USB_VENDOR_ID_LENOVO, prod),\t\t\t\\\n\t.driver_data = (kernel_ulong_t)&wacom_features_##prod\n\nconst struct hid_device_id wacom_ids[] = {\n\t{ USB_DEVICE_WACOM(0x00) },\n\t{ USB_DEVICE_WACOM(0x03) },\n\t{ USB_DEVICE_WACOM(0x10) },\n\t{ USB_DEVICE_WACOM(0x11) },\n\t{ USB_DEVICE_WACOM(0x12) },\n\t{ USB_DEVICE_WACOM(0x13) },\n\t{ USB_DEVICE_WACOM(0x14) },\n\t{ USB_DEVICE_WACOM(0x15) },\n\t{ USB_DEVICE_WACOM(0x16) },\n\t{ USB_DEVICE_WACOM(0x17) },\n\t{ USB_DEVICE_WACOM(0x18) },\n\t{ USB_DEVICE_WACOM(0x19) },\n\t{ USB_DEVICE_WACOM(0x20) },\n\t{ USB_DEVICE_WACOM(0x21) },\n\t{ USB_DEVICE_WACOM(0x22) },\n\t{ USB_DEVICE_WACOM(0x23) },\n\t{ USB_DEVICE_WACOM(0x24) },\n\t{ USB_DEVICE_WACOM(0x26) },\n\t{ USB_DEVICE_WACOM(0x27) },\n\t{ USB_DEVICE_WACOM(0x28) },\n\t{ USB_DEVICE_WACOM(0x29) },\n\t{ USB_DEVICE_WACOM(0x2A) },\n\t{ USB_DEVICE_WACOM(0x30) },\n\t{ USB_DEVICE_WACOM(0x31) },\n\t{ USB_DEVICE_WACOM(0x32) },\n\t{ USB_DEVICE_WACOM(0x33) },\n\t{ USB_DEVICE_WACOM(0x34) },\n\t{ USB_DEVICE_WACOM(0x35) },\n\t{ USB_DEVICE_WACOM(0x37) },\n\t{ USB_DEVICE_WACOM(0x38) },\n\t{ USB_DEVICE_WACOM(0x39) },\n\t{ USB_DEVICE_WACOM(0x3F) },\n\t{ USB_DEVICE_WACOM(0x41) },\n\t{ USB_DEVICE_WACOM(0x42) },\n\t{ USB_DEVICE_WACOM(0x43) },\n\t{ USB_DEVICE_WACOM(0x44) },\n\t{ USB_DEVICE_WACOM(0x45) },\n\t{ USB_DEVICE_WACOM(0x47) },\n\t{ USB_DEVICE_WACOM(0x57) },\n\t{ USB_DEVICE_WACOM(0x59) },\n\t{ USB_DEVICE_WACOM(0x5B) },\n\t{ USB_DEVICE_WACOM(0x5D) },\n\t{ USB_DEVICE_WACOM(0x5E) },\n\t{ USB_DEVICE_WACOM(0x60) },\n\t{ USB_DEVICE_WACOM(0x61) },\n\t{ USB_DEVICE_WACOM(0x62) },\n\t{ USB_DEVICE_WACOM(0x63) },\n\t{ USB_DEVICE_WACOM(0x64) },\n\t{ USB_DEVICE_WACOM(0x65) },\n\t{ USB_DEVICE_WACOM(0x69) },\n\t{ USB_DEVICE_WACOM(0x6A) },\n\t{ USB_DEVICE_WACOM(0x6B) },\n\t{ BT_DEVICE_WACOM(0x81) },\n\t{ USB_DEVICE_WACOM(0x84) },\n\t{ USB_DEVICE_WACOM(0x90) },\n\t{ USB_DEVICE_WACOM(0x93) },\n\t{ USB_DEVICE_WACOM(0x94) },\n\t{ USB_DEVICE_WACOM(0x97) },\n\t{ USB_DEVICE_WACOM(0x9A) },\n\t{ USB_DEVICE_WACOM(0x9F) },\n\t{ USB_DEVICE_WACOM(0xB0) },\n\t{ USB_DEVICE_WACOM(0xB1) },\n\t{ USB_DEVICE_WACOM(0xB2) },\n\t{ USB_DEVICE_WACOM(0xB3) },\n\t{ USB_DEVICE_WACOM(0xB4) },\n\t{ USB_DEVICE_WACOM(0xB5) },\n\t{ USB_DEVICE_WACOM(0xB7) },\n\t{ USB_DEVICE_WACOM(0xB8) },\n\t{ USB_DEVICE_WACOM(0xB9) },\n\t{ USB_DEVICE_WACOM(0xBA) },\n\t{ USB_DEVICE_WACOM(0xBB) },\n\t{ USB_DEVICE_WACOM(0xBC) },\n\t{ BT_DEVICE_WACOM(0xBD) },\n\t{ USB_DEVICE_WACOM(0xC0) },\n\t{ USB_DEVICE_WACOM(0xC2) },\n\t{ USB_DEVICE_WACOM(0xC4) },\n\t{ USB_DEVICE_WACOM(0xC5) },\n\t{ USB_DEVICE_WACOM(0xC6) },\n\t{ USB_DEVICE_WACOM(0xC7) },\n\t{ USB_DEVICE_WACOM(0xCC) },\n\t{ USB_DEVICE_WACOM(0xCE) },\n\t{ USB_DEVICE_WACOM(0xD0) },\n\t{ USB_DEVICE_WACOM(0xD1) },\n\t{ USB_DEVICE_WACOM(0xD2) },\n\t{ USB_DEVICE_WACOM(0xD3) },\n\t{ USB_DEVICE_WACOM(0xD4) },\n\t{ USB_DEVICE_WACOM(0xD5) },\n\t{ USB_DEVICE_WACOM(0xD6) },\n\t{ USB_DEVICE_WACOM(0xD7) },\n\t{ USB_DEVICE_WACOM(0xD8) },\n\t{ USB_DEVICE_WACOM(0xDA) },\n\t{ USB_DEVICE_WACOM(0xDB) },\n\t{ USB_DEVICE_WACOM(0xDD) },\n\t{ USB_DEVICE_WACOM(0xDE) },\n\t{ USB_DEVICE_WACOM(0xDF) },\n\t{ USB_DEVICE_WACOM(0xE2) },\n\t{ USB_DEVICE_WACOM(0xE3) },\n\t{ USB_DEVICE_WACOM(0xE5) },\n\t{ USB_DEVICE_WACOM(0xE6) },\n\t{ USB_DEVICE_WACOM(0xEC) },\n\t{ USB_DEVICE_WACOM(0xED) },\n\t{ USB_DEVICE_WACOM(0xEF) },\n\t{ USB_DEVICE_WACOM(0xF0) },\n\t{ USB_DEVICE_WACOM(0xF4) },\n\t{ USB_DEVICE_WACOM(0xF6) },\n\t{ USB_DEVICE_WACOM(0xF8) },\n\t{ USB_DEVICE_WACOM(0xFA) },\n\t{ USB_DEVICE_WACOM(0xFB) },\n\t{ USB_DEVICE_WACOM(0x100) },\n\t{ USB_DEVICE_WACOM(0x101) },\n\t{ USB_DEVICE_WACOM(0x10D) },\n\t{ USB_DEVICE_WACOM(0x10E) },\n\t{ USB_DEVICE_WACOM(0x10F) },\n\t{ USB_DEVICE_WACOM(0x116) },\n\t{ USB_DEVICE_WACOM(0x12C) },\n\t{ USB_DEVICE_WACOM(0x300) },\n\t{ USB_DEVICE_WACOM(0x301) },\n\t{ USB_DEVICE_WACOM(0x302) },\n\t{ USB_DEVICE_WACOM(0x303) },\n\t{ USB_DEVICE_WACOM(0x304) },\n\t{ USB_DEVICE_WACOM(0x307) },\n\t{ USB_DEVICE_WACOM(0x309) },\n\t{ USB_DEVICE_WACOM(0x30A) },\n\t{ USB_DEVICE_WACOM(0x30C) },\n\t{ USB_DEVICE_WACOM(0x30E) },\n\t{ USB_DEVICE_WACOM(0x314) },\n\t{ USB_DEVICE_WACOM(0x315) },\n\t{ USB_DEVICE_WACOM(0x317) },\n\t{ USB_DEVICE_WACOM(0x318) },\n\t{ USB_DEVICE_WACOM(0x319) },\n\t{ USB_DEVICE_WACOM(0x323) },\n\t{ USB_DEVICE_WACOM(0x325) },\n\t{ USB_DEVICE_WACOM(0x326) },\n\t{ USB_DEVICE_WACOM(0x32A) },\n\t{ USB_DEVICE_WACOM(0x32B) },\n\t{ USB_DEVICE_WACOM(0x32C) },\n\t{ USB_DEVICE_WACOM(0x32F) },\n\t{ USB_DEVICE_WACOM(0x331) },\n\t{ USB_DEVICE_WACOM(0x333) },\n\t{ USB_DEVICE_WACOM(0x335) },\n\t{ USB_DEVICE_WACOM(0x336) },\n\t{ USB_DEVICE_WACOM(0x33B) },\n\t{ USB_DEVICE_WACOM(0x33C) },\n\t{ USB_DEVICE_WACOM(0x33D) },\n\t{ USB_DEVICE_WACOM(0x33E) },\n\t{ USB_DEVICE_WACOM(0x343) },\n\t{ BT_DEVICE_WACOM(0x360) },\n\t{ BT_DEVICE_WACOM(0x361) },\n\t{ BT_DEVICE_WACOM(0x377) },\n\t{ BT_DEVICE_WACOM(0x379) },\n\t{ USB_DEVICE_WACOM(0x37A) },\n\t{ USB_DEVICE_WACOM(0x37B) },\n\t{ BT_DEVICE_WACOM(0x393) },\n\t{ BT_DEVICE_WACOM(0x3c6) },\n\t{ BT_DEVICE_WACOM(0x3c8) },\n\t{ BT_DEVICE_WACOM(0x3dd) },\n\t{ USB_DEVICE_WACOM(0x4001) },\n\t{ USB_DEVICE_WACOM(0x4004) },\n\t{ USB_DEVICE_WACOM(0x5000) },\n\t{ USB_DEVICE_WACOM(0x5002) },\n\t{ USB_DEVICE_LENOVO(0x6004) },\n\n\t{ USB_DEVICE_WACOM(HID_ANY_ID) },\n\t{ I2C_DEVICE_WACOM(HID_ANY_ID) },\n\t{ BT_DEVICE_WACOM(HID_ANY_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, wacom_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}