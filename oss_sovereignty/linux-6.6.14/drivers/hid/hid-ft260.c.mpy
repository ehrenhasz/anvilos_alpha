{
  "module_name": "hid-ft260.c",
  "hash_id": "d2a49069dbef867d8b37bc7df3d2d46cb01754f5bfdd4fd682b7ec00a37c25c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-ft260.c",
  "human_readable_source": "\n \n\n#include \"hid-ids.h\"\n#include <linux/hidraw.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#ifdef DEBUG\nstatic int ft260_debug = 1;\n#else\nstatic int ft260_debug;\n#endif\nmodule_param_named(debug, ft260_debug, int, 0600);\nMODULE_PARM_DESC(debug, \"Toggle FT260 debugging messages\");\n\n#define ft260_dbg(format, arg...)\t\t\t\t\t  \\\n\tdo {\t\t\t\t\t\t\t\t  \\\n\t\tif (ft260_debug)\t\t\t\t\t  \\\n\t\t\tpr_info(\"%s: \" format, __func__, ##arg);\t  \\\n\t} while (0)\n\n#define FT260_REPORT_MAX_LENGTH (64)\n#define FT260_I2C_DATA_REPORT_ID(len) (FT260_I2C_REPORT_MIN + (len - 1) / 4)\n\n#define FT260_WAKEUP_NEEDED_AFTER_MS (4800)  \n\n \n#define FT260_RD_DATA_MAX (180)\n#define FT260_WR_DATA_MAX (60)\n\n \nenum {\n\tFT260_MODE_ALL\t\t\t= 0x00,\n\tFT260_MODE_I2C\t\t\t= 0x01,\n\tFT260_MODE_UART\t\t\t= 0x02,\n\tFT260_MODE_BOTH\t\t\t= 0x03,\n};\n\n \nenum {\n\tFT260_GET_RQST_TYPE\t\t= 0xA1,\n\tFT260_GET_REPORT\t\t= 0x01,\n\tFT260_SET_RQST_TYPE\t\t= 0x21,\n\tFT260_SET_REPORT\t\t= 0x09,\n\tFT260_FEATURE\t\t\t= 0x03,\n};\n\n \nenum {\n\tFT260_CHIP_VERSION\t\t= 0xA0,\n\tFT260_SYSTEM_SETTINGS\t\t= 0xA1,\n\tFT260_I2C_STATUS\t\t= 0xC0,\n\tFT260_I2C_READ_REQ\t\t= 0xC2,\n\tFT260_I2C_REPORT_MIN\t\t= 0xD0,\n\tFT260_I2C_REPORT_MAX\t\t= 0xDE,\n\tFT260_GPIO\t\t\t= 0xB0,\n\tFT260_UART_INTERRUPT_STATUS\t= 0xB1,\n\tFT260_UART_STATUS\t\t= 0xE0,\n\tFT260_UART_RI_DCD_STATUS\t= 0xE1,\n\tFT260_UART_REPORT\t\t= 0xF0,\n};\n\n \nenum {\n\tFT260_SET_CLOCK\t\t\t= 0x01,\n\tFT260_SET_I2C_MODE\t\t= 0x02,\n\tFT260_SET_UART_MODE\t\t= 0x03,\n\tFT260_ENABLE_INTERRUPT\t\t= 0x05,\n\tFT260_SELECT_GPIO2_FUNC\t\t= 0x06,\n\tFT260_ENABLE_UART_DCD_RI\t= 0x07,\n\tFT260_SELECT_GPIOA_FUNC\t\t= 0x08,\n\tFT260_SELECT_GPIOG_FUNC\t\t= 0x09,\n\tFT260_SET_INTERRUPT_TRIGGER\t= 0x0A,\n\tFT260_SET_SUSPEND_OUT_POLAR\t= 0x0B,\n\tFT260_ENABLE_UART_RI_WAKEUP\t= 0x0C,\n\tFT260_SET_UART_RI_WAKEUP_CFG\t= 0x0D,\n\tFT260_SET_I2C_RESET\t\t= 0x20,\n\tFT260_SET_I2C_CLOCK_SPEED\t= 0x22,\n\tFT260_SET_UART_RESET\t\t= 0x40,\n\tFT260_SET_UART_CONFIG\t\t= 0x41,\n\tFT260_SET_UART_BAUD_RATE\t= 0x42,\n\tFT260_SET_UART_DATA_BIT\t\t= 0x43,\n\tFT260_SET_UART_PARITY\t\t= 0x44,\n\tFT260_SET_UART_STOP_BIT\t\t= 0x45,\n\tFT260_SET_UART_BREAKING\t\t= 0x46,\n\tFT260_SET_UART_XON_XOFF\t\t= 0x49,\n};\n\n \nenum {\n\tFT260_I2C_STATUS_SUCCESS\t= 0x00,\n\tFT260_I2C_STATUS_CTRL_BUSY\t= 0x01,\n\tFT260_I2C_STATUS_ERROR\t\t= 0x02,\n\tFT260_I2C_STATUS_ADDR_NO_ACK\t= 0x04,\n\tFT260_I2C_STATUS_DATA_NO_ACK\t= 0x08,\n\tFT260_I2C_STATUS_ARBITR_LOST\t= 0x10,\n\tFT260_I2C_STATUS_CTRL_IDLE\t= 0x20,\n\tFT260_I2C_STATUS_BUS_BUSY\t= 0x40,\n};\n\n \nenum {\n\tFT260_FLAG_NONE\t\t\t= 0x00,\n\tFT260_FLAG_START\t\t= 0x02,\n\tFT260_FLAG_START_REPEATED\t= 0x03,\n\tFT260_FLAG_STOP\t\t\t= 0x04,\n\tFT260_FLAG_START_STOP\t\t= 0x06,\n\tFT260_FLAG_START_STOP_REPEATED\t= 0x07,\n};\n\n#define FT260_SET_REQUEST_VALUE(report_id) ((FT260_FEATURE << 8) | report_id)\n\n \n\nstruct ft260_get_chip_version_report {\n\tu8 report;\t\t \n\tu8 chip_code[4];\t \n\tu8 reserved[8];\n} __packed;\n\nstruct ft260_get_system_status_report {\n\tu8 report;\t\t \n\tu8 chip_mode;\t\t \n\tu8 clock_ctl;\t\t \n\tu8 suspend_status;\t \n\tu8 pwren_status;\t \n\tu8 i2c_enable;\t\t \n\tu8 uart_mode;\t\t \n\t\t\t\t \n\tu8 hid_over_i2c_en;\t \n\tu8 gpio2_function;\t \n\t\t\t\t \n\tu8 gpioA_function;\t \n\tu8 gpioG_function;\t \n\t\t\t\t \n\tu8 suspend_out_pol;\t \n\tu8 enable_wakeup_int;\t \n\tu8 intr_cond;\t\t \n\tu8 power_saving_en;\t \n\tu8 reserved[10];\n} __packed;\n\nstruct ft260_get_i2c_status_report {\n\tu8 report;\t\t \n\tu8 bus_status;\t\t \n\t__le16 clock;\t\t \n\tu8 reserved;\n} __packed;\n\n \n\nstruct ft260_set_system_clock_report {\n\tu8 report;\t\t \n\tu8 request;\t\t \n\tu8 clock_ctl;\t\t \n} __packed;\n\nstruct ft260_set_i2c_mode_report {\n\tu8 report;\t\t \n\tu8 request;\t\t \n\tu8 i2c_enable;\t\t \n} __packed;\n\nstruct ft260_set_uart_mode_report {\n\tu8 report;\t\t \n\tu8 request;\t\t \n\tu8 uart_mode;\t\t \n\t\t\t\t \n} __packed;\n\nstruct ft260_set_i2c_reset_report {\n\tu8 report;\t\t \n\tu8 request;\t\t \n} __packed;\n\nstruct ft260_set_i2c_speed_report {\n\tu8 report;\t\t \n\tu8 request;\t\t \n\t__le16 clock;\t\t \n} __packed;\n\n \n\nstruct ft260_i2c_write_request_report {\n\tu8 report;\t\t \n\tu8 address;\t\t \n\tu8 flag;\t\t \n\tu8 length;\t\t \n\tu8 data[FT260_WR_DATA_MAX];  \n} __packed;\n\nstruct ft260_i2c_read_request_report {\n\tu8 report;\t\t \n\tu8 address;\t\t \n\tu8 flag;\t\t \n\t__le16 length;\t\t \n} __packed;\n\nstruct ft260_i2c_input_report {\n\tu8 report;\t\t \n\tu8 length;\t\t \n\tu8 data[2];\t\t \n} __packed;\n\nstatic const struct hid_device_id ft260_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_FUTURE_TECHNOLOGY,\n\t\t\t USB_DEVICE_ID_FT260) },\n\t{   }\n};\nMODULE_DEVICE_TABLE(hid, ft260_devices);\n\nstruct ft260_device {\n\tstruct i2c_adapter adap;\n\tstruct hid_device *hdev;\n\tstruct completion wait;\n\tstruct mutex lock;\n\tu8 write_buf[FT260_REPORT_MAX_LENGTH];\n\tunsigned long need_wakeup_at;\n\tu8 *read_buf;\n\tu16 read_idx;\n\tu16 read_len;\n\tu16 clock;\n};\n\nstatic int ft260_hid_feature_report_get(struct hid_device *hdev,\n\t\t\t\t\tunsigned char report_id, u8 *data,\n\t\t\t\t\tsize_t len)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, report_id, buf, len, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (likely(ret == len))\n\t\tmemcpy(data, buf, len);\n\telse if (ret >= 0)\n\t\tret = -EIO;\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int ft260_hid_feature_report_set(struct hid_device *hdev, u8 *data,\n\t\t\t\t\tsize_t len)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = FT260_SYSTEM_SETTINGS;\n\n\tret = hid_hw_raw_request(hdev, buf[0], buf, len, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int ft260_i2c_reset(struct hid_device *hdev)\n{\n\tstruct ft260_set_i2c_reset_report report;\n\tint ret;\n\n\treport.request = FT260_SET_I2C_RESET;\n\n\tret = ft260_hid_feature_report_set(hdev, (u8 *)&report, sizeof(report));\n\tif (ret < 0) {\n\t\thid_err(hdev, \"failed to reset I2C controller: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tft260_dbg(\"done\\n\");\n\treturn ret;\n}\n\nstatic int ft260_xfer_status(struct ft260_device *dev, u8 bus_busy)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct ft260_get_i2c_status_report report;\n\tint ret;\n\n\tif (time_is_before_jiffies(dev->need_wakeup_at)) {\n\t\tret = ft260_hid_feature_report_get(hdev, FT260_I2C_STATUS,\n\t\t\t\t\t\t(u8 *)&report, sizeof(report));\n\t\tif (unlikely(ret < 0)) {\n\t\t\thid_err(hdev, \"failed to retrieve status: %d, no wakeup\\n\",\n\t\t\t\tret);\n\t\t} else {\n\t\t\tdev->need_wakeup_at = jiffies +\n\t\t\t\tmsecs_to_jiffies(FT260_WAKEUP_NEEDED_AFTER_MS);\n\t\t\tft260_dbg(\"bus_status %#02x, wakeup\\n\",\n\t\t\t\t  report.bus_status);\n\t\t}\n\t}\n\n\tret = ft260_hid_feature_report_get(hdev, FT260_I2C_STATUS,\n\t\t\t\t\t   (u8 *)&report, sizeof(report));\n\tif (unlikely(ret < 0)) {\n\t\thid_err(hdev, \"failed to retrieve status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev->clock = le16_to_cpu(report.clock);\n\tft260_dbg(\"bus_status %#02x, clock %u\\n\", report.bus_status,\n\t\t  dev->clock);\n\n\tif (report.bus_status & (FT260_I2C_STATUS_CTRL_BUSY | bus_busy))\n\t\treturn -EAGAIN;\n\n\t \n\tif (report.bus_status & FT260_I2C_STATUS_ERROR) {\n\t\thid_err(hdev, \"i2c bus error: %#02x\\n\", report.bus_status);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ft260_hid_output_report(struct hid_device *hdev, u8 *data,\n\t\t\t\t   size_t len)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_output_report(hdev, buf, len);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int ft260_hid_output_report_check_status(struct ft260_device *dev,\n\t\t\t\t\t\tu8 *data, int len)\n{\n\tu8 bus_busy;\n\tint ret, usec, try = 100;\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct ft260_i2c_write_request_report *rep =\n\t\t(struct ft260_i2c_write_request_report *)data;\n\n\tret = ft260_hid_output_report(hdev, data, len);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"%s: failed to start transfer, ret %d\\n\",\n\t\t\t__func__, ret);\n\t\tft260_i2c_reset(hdev);\n\t\treturn ret;\n\t}\n\n\t \n\tusec = len * 9000 / dev->clock;\n\tif (usec > 2000) {\n\t\tusec -= 1500;\n\t\tusleep_range(usec, usec + 100);\n\t\tft260_dbg(\"wait %d usec, len %d\\n\", usec, len);\n\t}\n\n\t \n\tif (rep->flag == FT260_FLAG_START)\n\t\tbus_busy = 0;\n\telse\n\t\tbus_busy = FT260_I2C_STATUS_BUS_BUSY;\n\n\tdo {\n\t\tret = ft260_xfer_status(dev, bus_busy);\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t} while (--try);\n\n\tif (ret == 0)\n\t\treturn 0;\n\n\tft260_i2c_reset(hdev);\n\treturn -EIO;\n}\n\nstatic int ft260_i2c_write(struct ft260_device *dev, u8 addr, u8 *data,\n\t\t\t   int len, u8 flag)\n{\n\tint ret, wr_len, idx = 0;\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct ft260_i2c_write_request_report *rep =\n\t\t(struct ft260_i2c_write_request_report *)dev->write_buf;\n\n\tif (len < 1)\n\t\treturn -EINVAL;\n\n\trep->flag = FT260_FLAG_START;\n\n\tdo {\n\t\tif (len <= FT260_WR_DATA_MAX) {\n\t\t\twr_len = len;\n\t\t\tif (flag == FT260_FLAG_START_STOP)\n\t\t\t\trep->flag |= FT260_FLAG_STOP;\n\t\t} else {\n\t\t\twr_len = FT260_WR_DATA_MAX;\n\t\t}\n\n\t\trep->report = FT260_I2C_DATA_REPORT_ID(wr_len);\n\t\trep->address = addr;\n\t\trep->length = wr_len;\n\n\t\tmemcpy(rep->data, &data[idx], wr_len);\n\n\t\tft260_dbg(\"rep %#02x addr %#02x off %d len %d wlen %d flag %#x d[0] %#02x\\n\",\n\t\t\t  rep->report, addr, idx, len, wr_len,\n\t\t\t  rep->flag, data[0]);\n\n\t\tret = ft260_hid_output_report_check_status(dev, (u8 *)rep,\n\t\t\t\t\t\t\t   wr_len + 4);\n\t\tif (ret < 0) {\n\t\t\thid_err(hdev, \"%s: failed with %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlen -= wr_len;\n\t\tidx += wr_len;\n\t\trep->flag = 0;\n\n\t} while (len > 0);\n\n\treturn 0;\n}\n\nstatic int ft260_smbus_write(struct ft260_device *dev, u8 addr, u8 cmd,\n\t\t\t     u8 *data, u8 data_len, u8 flag)\n{\n\tint ret = 0;\n\tint len = 4;\n\n\tstruct ft260_i2c_write_request_report *rep =\n\t\t(struct ft260_i2c_write_request_report *)dev->write_buf;\n\n\tif (data_len >= sizeof(rep->data))\n\t\treturn -EINVAL;\n\n\trep->address = addr;\n\trep->data[0] = cmd;\n\trep->length = data_len + 1;\n\trep->flag = flag;\n\tlen += rep->length;\n\n\trep->report = FT260_I2C_DATA_REPORT_ID(len);\n\n\tif (data_len > 0)\n\t\tmemcpy(&rep->data[1], data, data_len);\n\n\tft260_dbg(\"rep %#02x addr %#02x cmd %#02x datlen %d replen %d\\n\",\n\t\t  rep->report, addr, cmd, rep->length, len);\n\n\tret = ft260_hid_output_report_check_status(dev, (u8 *)rep, len);\n\n\treturn ret;\n}\n\nstatic int ft260_i2c_read(struct ft260_device *dev, u8 addr, u8 *data,\n\t\t\t  u16 len, u8 flag)\n{\n\tu16 rd_len;\n\tu16 rd_data_max = 60;\n\tint timeout, ret = 0;\n\tstruct ft260_i2c_read_request_report rep;\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 bus_busy = 0;\n\n\tif ((flag & FT260_FLAG_START_REPEATED) == FT260_FLAG_START_REPEATED)\n\t\tflag = FT260_FLAG_START_REPEATED;\n\telse\n\t\tflag = FT260_FLAG_START;\n\tdo {\n\t\tif (len <= rd_data_max) {\n\t\t\trd_len = len;\n\t\t\tflag |= FT260_FLAG_STOP;\n\t\t} else {\n\t\t\trd_len = rd_data_max;\n\t\t}\n\t\trd_data_max = FT260_RD_DATA_MAX;\n\n\t\trep.report = FT260_I2C_READ_REQ;\n\t\trep.length = cpu_to_le16(rd_len);\n\t\trep.address = addr;\n\t\trep.flag = flag;\n\n\t\tft260_dbg(\"rep %#02x addr %#02x len %d rlen %d flag %#x\\n\",\n\t\t\t  rep.report, rep.address, len, rd_len, flag);\n\n\t\treinit_completion(&dev->wait);\n\n\t\tdev->read_idx = 0;\n\t\tdev->read_buf = data;\n\t\tdev->read_len = rd_len;\n\n\t\tret = ft260_hid_output_report(hdev, (u8 *)&rep, sizeof(rep));\n\t\tif (ret < 0) {\n\t\t\thid_err(hdev, \"%s: failed with %d\\n\", __func__, ret);\n\t\t\tgoto ft260_i2c_read_exit;\n\t\t}\n\n\t\ttimeout = msecs_to_jiffies(5000);\n\t\tif (!wait_for_completion_timeout(&dev->wait, timeout)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tft260_i2c_reset(hdev);\n\t\t\tgoto ft260_i2c_read_exit;\n\t\t}\n\n\t\tdev->read_buf = NULL;\n\n\t\tif (flag & FT260_FLAG_STOP)\n\t\t\tbus_busy = FT260_I2C_STATUS_BUS_BUSY;\n\n\t\tret = ft260_xfer_status(dev, bus_busy);\n\t\tif (ret < 0) {\n\t\t\tret = -EIO;\n\t\t\tft260_i2c_reset(hdev);\n\t\t\tgoto ft260_i2c_read_exit;\n\t\t}\n\n\t\tlen -= rd_len;\n\t\tdata += rd_len;\n\t\tflag = 0;\n\n\t} while (len > 0);\n\nft260_i2c_read_exit:\n\tdev->read_buf = NULL;\n\treturn ret;\n}\n\n \nstatic int ft260_i2c_write_read(struct ft260_device *dev, struct i2c_msg *msgs)\n{\n\tint ret;\n\tint wr_len = msgs[0].len;\n\tint rd_len = msgs[1].len;\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 addr = msgs[0].addr;\n\tu16 read_off = 0;\n\n\tif (wr_len > 2) {\n\t\thid_err(hdev, \"%s: invalid wr_len: %d\\n\", __func__, wr_len);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ft260_debug) {\n\t\tif (wr_len == 2)\n\t\t\tread_off = be16_to_cpu(*(__be16 *)msgs[0].buf);\n\t\telse\n\t\t\tread_off = *msgs[0].buf;\n\n\t\tpr_info(\"%s: off %#x rlen %d wlen %d\\n\", __func__,\n\t\t\tread_off, rd_len, wr_len);\n\t}\n\n\tret = ft260_i2c_write(dev, addr, msgs[0].buf, wr_len,\n\t\t\t      FT260_FLAG_START);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ft260_i2c_read(dev, addr, msgs[1].buf, rd_len,\n\t\t\t     FT260_FLAG_START_STOP_REPEATED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ft260_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,\n\t\t\t  int num)\n{\n\tint ret;\n\tstruct ft260_device *dev = i2c_get_adapdata(adapter);\n\tstruct hid_device *hdev = dev->hdev;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"failed to enter FULLON power mode: %d\\n\", ret);\n\t\tmutex_unlock(&dev->lock);\n\t\treturn ret;\n\t}\n\n\tif (num == 1) {\n\t\tif (msgs->flags & I2C_M_RD)\n\t\t\tret = ft260_i2c_read(dev, msgs->addr, msgs->buf,\n\t\t\t\t\t     msgs->len, FT260_FLAG_START_STOP);\n\t\telse\n\t\t\tret = ft260_i2c_write(dev, msgs->addr, msgs->buf,\n\t\t\t\t\t      msgs->len, FT260_FLAG_START_STOP);\n\t\tif (ret < 0)\n\t\t\tgoto i2c_exit;\n\n\t} else {\n\t\t \n\t\tret = ft260_i2c_write_read(dev, msgs);\n\t\tif (ret < 0)\n\t\t\tgoto i2c_exit;\n\t}\n\n\tret = num;\ni2c_exit:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\nstatic int ft260_smbus_xfer(struct i2c_adapter *adapter, u16 addr, u16 flags,\n\t\t\t    char read_write, u8 cmd, int size,\n\t\t\t    union i2c_smbus_data *data)\n{\n\tint ret;\n\tstruct ft260_device *dev = i2c_get_adapdata(adapter);\n\tstruct hid_device *hdev = dev->hdev;\n\n\tft260_dbg(\"smbus size %d\\n\", size);\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\tmutex_unlock(&dev->lock);\n\t\treturn ret;\n\t}\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\tret = ft260_i2c_read(dev, addr, &data->byte, 1,\n\t\t\t\t\t     FT260_FLAG_START_STOP);\n\t\telse\n\t\t\tret = ft260_smbus_write(dev, addr, cmd, NULL, 0,\n\t\t\t\t\t\tFT260_FLAG_START_STOP);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = ft260_smbus_write(dev, addr, cmd, NULL, 0,\n\t\t\t\t\t\tFT260_FLAG_START);\n\t\t\tif (ret)\n\t\t\t\tgoto smbus_exit;\n\n\t\t\tret = ft260_i2c_read(dev, addr, &data->byte, 1,\n\t\t\t\t\t     FT260_FLAG_START_STOP_REPEATED);\n\t\t} else {\n\t\t\tret = ft260_smbus_write(dev, addr, cmd, &data->byte, 1,\n\t\t\t\t\t\tFT260_FLAG_START_STOP);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = ft260_smbus_write(dev, addr, cmd, NULL, 0,\n\t\t\t\t\t\tFT260_FLAG_START);\n\t\t\tif (ret)\n\t\t\t\tgoto smbus_exit;\n\n\t\t\tret = ft260_i2c_read(dev, addr, (u8 *)&data->word, 2,\n\t\t\t\t\t     FT260_FLAG_START_STOP_REPEATED);\n\t\t} else {\n\t\t\tret = ft260_smbus_write(dev, addr, cmd,\n\t\t\t\t\t\t(u8 *)&data->word, 2,\n\t\t\t\t\t\tFT260_FLAG_START_STOP);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = ft260_smbus_write(dev, addr, cmd, NULL, 0,\n\t\t\t\t\t\tFT260_FLAG_START);\n\t\t\tif (ret)\n\t\t\t\tgoto smbus_exit;\n\n\t\t\tret = ft260_i2c_read(dev, addr, data->block,\n\t\t\t\t\t     data->block[0] + 1,\n\t\t\t\t\t     FT260_FLAG_START_STOP_REPEATED);\n\t\t} else {\n\t\t\tret = ft260_smbus_write(dev, addr, cmd, data->block,\n\t\t\t\t\t\tdata->block[0] + 1,\n\t\t\t\t\t\tFT260_FLAG_START_STOP);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = ft260_smbus_write(dev, addr, cmd, NULL, 0,\n\t\t\t\t\t\tFT260_FLAG_START);\n\t\t\tif (ret)\n\t\t\t\tgoto smbus_exit;\n\n\t\t\tret = ft260_i2c_read(dev, addr, data->block + 1,\n\t\t\t\t\t     data->block[0],\n\t\t\t\t\t     FT260_FLAG_START_STOP_REPEATED);\n\t\t} else {\n\t\t\tret = ft260_smbus_write(dev, addr, cmd, data->block + 1,\n\t\t\t\t\t\tdata->block[0],\n\t\t\t\t\t\tFT260_FLAG_START_STOP);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\thid_err(hdev, \"unsupported smbus transaction size %d\\n\", size);\n\t\tret = -EOPNOTSUPP;\n\t}\n\nsmbus_exit:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\nstatic u32 ft260_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE |\n\t       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t       I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_I2C_BLOCK;\n}\n\nstatic const struct i2c_adapter_quirks ft260_i2c_quirks = {\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ,\n\t.max_comb_1st_msg_len = 2,\n};\n\nstatic const struct i2c_algorithm ft260_i2c_algo = {\n\t.master_xfer = ft260_i2c_xfer,\n\t.smbus_xfer = ft260_smbus_xfer,\n\t.functionality = ft260_functionality,\n};\n\nstatic int ft260_get_system_config(struct hid_device *hdev,\n\t\t\t\t   struct ft260_get_system_status_report *cfg)\n{\n\tint ret;\n\tint len = sizeof(struct ft260_get_system_status_report);\n\n\tret = ft260_hid_feature_report_get(hdev, FT260_SYSTEM_SETTINGS,\n\t\t\t\t\t   (u8 *)cfg, len);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"failed to retrieve system status\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int ft260_is_interface_enabled(struct hid_device *hdev)\n{\n\tstruct ft260_get_system_status_report cfg;\n\tstruct usb_interface *usbif = to_usb_interface(hdev->dev.parent);\n\tint interface = usbif->cur_altsetting->desc.bInterfaceNumber;\n\tint ret;\n\n\tret = ft260_get_system_config(hdev, &cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tft260_dbg(\"interface:  0x%02x\\n\", interface);\n\tft260_dbg(\"chip mode:  0x%02x\\n\", cfg.chip_mode);\n\tft260_dbg(\"clock_ctl:  0x%02x\\n\", cfg.clock_ctl);\n\tft260_dbg(\"i2c_enable: 0x%02x\\n\", cfg.i2c_enable);\n\tft260_dbg(\"uart_mode:  0x%02x\\n\", cfg.uart_mode);\n\n\tswitch (cfg.chip_mode) {\n\tcase FT260_MODE_ALL:\n\tcase FT260_MODE_BOTH:\n\t\tif (interface == 1)\n\t\t\thid_info(hdev, \"uart interface is not supported\\n\");\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\tcase FT260_MODE_UART:\n\t\thid_info(hdev, \"uart interface is not supported\\n\");\n\t\tbreak;\n\tcase FT260_MODE_I2C:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ft260_byte_show(struct hid_device *hdev, int id, u8 *cfg, int len,\n\t\t\t   u8 *field, u8 *buf)\n{\n\tint ret;\n\n\tret = ft260_hid_feature_report_get(hdev, id, cfg, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", *field);\n}\n\nstatic int ft260_word_show(struct hid_device *hdev, int id, u8 *cfg, int len,\n\t\t\t   __le16 *field, u8 *buf)\n{\n\tint ret;\n\n\tret = ft260_hid_feature_report_get(hdev, id, cfg, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", le16_to_cpu(*field));\n}\n\n#define FT260_ATTR_SHOW(name, reptype, id, type, func)\t\t\t       \\\n\tstatic ssize_t name##_show(struct device *kdev,\t\t\t       \\\n\t\t\t\t   struct device_attribute *attr, char *buf)   \\\n\t{\t\t\t\t\t\t\t\t       \\\n\t\tstruct reptype rep;\t\t\t\t\t       \\\n\t\tstruct hid_device *hdev = to_hid_device(kdev);\t\t       \\\n\t\ttype *field = &rep.name;\t\t\t\t       \\\n\t\tint len = sizeof(rep);\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\treturn func(hdev, id, (u8 *)&rep, len, field, buf);\t       \\\n\t}\n\n#define FT260_SSTAT_ATTR_SHOW(name)\t\t\t\t\t       \\\n\t\tFT260_ATTR_SHOW(name, ft260_get_system_status_report,\t       \\\n\t\t\t\tFT260_SYSTEM_SETTINGS, u8, ft260_byte_show)\n\n#define FT260_I2CST_ATTR_SHOW(name)\t\t\t\t\t       \\\n\t\tFT260_ATTR_SHOW(name, ft260_get_i2c_status_report,\t       \\\n\t\t\t\tFT260_I2C_STATUS, __le16, ft260_word_show)\n\n#define FT260_ATTR_STORE(name, reptype, id, req, type, ctype, func)\t       \\\n\tstatic ssize_t name##_store(struct device *kdev,\t\t       \\\n\t\t\t\t    struct device_attribute *attr,\t       \\\n\t\t\t\t    const char *buf, size_t count)\t       \\\n\t{\t\t\t\t\t\t\t\t       \\\n\t\tstruct reptype rep;\t\t\t\t\t       \\\n\t\tstruct hid_device *hdev = to_hid_device(kdev);\t\t       \\\n\t\ttype name;\t\t\t\t\t\t       \\\n\t\tint ret;\t\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tif (!func(buf, 10, (ctype *)&name)) {\t\t\t       \\\n\t\t\trep.name = name;\t\t\t\t       \\\n\t\t\trep.report = id;\t\t\t\t       \\\n\t\t\trep.request = req;\t\t\t\t       \\\n\t\t\tret = ft260_hid_feature_report_set(hdev, (u8 *)&rep,   \\\n\t\t\t\t\t\t\t   sizeof(rep));       \\\n\t\t\tif (!ret)\t\t\t\t\t       \\\n\t\t\t\tret = count;\t\t\t\t       \\\n\t\t} else {\t\t\t\t\t\t       \\\n\t\t\tret = -EINVAL;\t\t\t\t\t       \\\n\t\t}\t\t\t\t\t\t\t       \\\n\t\treturn ret;\t\t\t\t\t\t       \\\n\t}\n\n#define FT260_BYTE_ATTR_STORE(name, reptype, req)\t\t\t       \\\n\t\tFT260_ATTR_STORE(name, reptype, FT260_SYSTEM_SETTINGS, req,    \\\n\t\t\t\t u8, u8, kstrtou8)\n\n#define FT260_WORD_ATTR_STORE(name, reptype, req)\t\t\t       \\\n\t\tFT260_ATTR_STORE(name, reptype, FT260_SYSTEM_SETTINGS, req,    \\\n\t\t\t\t __le16, u16, kstrtou16)\n\nFT260_SSTAT_ATTR_SHOW(chip_mode);\nstatic DEVICE_ATTR_RO(chip_mode);\n\nFT260_SSTAT_ATTR_SHOW(pwren_status);\nstatic DEVICE_ATTR_RO(pwren_status);\n\nFT260_SSTAT_ATTR_SHOW(suspend_status);\nstatic DEVICE_ATTR_RO(suspend_status);\n\nFT260_SSTAT_ATTR_SHOW(hid_over_i2c_en);\nstatic DEVICE_ATTR_RO(hid_over_i2c_en);\n\nFT260_SSTAT_ATTR_SHOW(power_saving_en);\nstatic DEVICE_ATTR_RO(power_saving_en);\n\nFT260_SSTAT_ATTR_SHOW(i2c_enable);\nFT260_BYTE_ATTR_STORE(i2c_enable, ft260_set_i2c_mode_report,\n\t\t      FT260_SET_I2C_MODE);\nstatic DEVICE_ATTR_RW(i2c_enable);\n\nFT260_SSTAT_ATTR_SHOW(uart_mode);\nFT260_BYTE_ATTR_STORE(uart_mode, ft260_set_uart_mode_report,\n\t\t      FT260_SET_UART_MODE);\nstatic DEVICE_ATTR_RW(uart_mode);\n\nFT260_SSTAT_ATTR_SHOW(clock_ctl);\nFT260_BYTE_ATTR_STORE(clock_ctl, ft260_set_system_clock_report,\n\t\t      FT260_SET_CLOCK);\nstatic DEVICE_ATTR_RW(clock_ctl);\n\nFT260_I2CST_ATTR_SHOW(clock);\nFT260_WORD_ATTR_STORE(clock, ft260_set_i2c_speed_report,\n\t\t      FT260_SET_I2C_CLOCK_SPEED);\nstatic DEVICE_ATTR_RW(clock);\n\nstatic ssize_t i2c_reset_store(struct device *kdev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(kdev);\n\tint ret = ft260_i2c_reset(hdev);\n\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(i2c_reset);\n\nstatic const struct attribute_group ft260_attr_group = {\n\t.attrs = (struct attribute *[]) {\n\t\t  &dev_attr_chip_mode.attr,\n\t\t  &dev_attr_pwren_status.attr,\n\t\t  &dev_attr_suspend_status.attr,\n\t\t  &dev_attr_hid_over_i2c_en.attr,\n\t\t  &dev_attr_power_saving_en.attr,\n\t\t  &dev_attr_i2c_enable.attr,\n\t\t  &dev_attr_uart_mode.attr,\n\t\t  &dev_attr_clock_ctl.attr,\n\t\t  &dev_attr_i2c_reset.attr,\n\t\t  &dev_attr_clock.attr,\n\t\t  NULL\n\t}\n};\n\nstatic int ft260_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct ft260_device *dev;\n\tstruct ft260_get_chip_version_report version;\n\tint ret;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"failed to parse HID\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, 0);\n\tif (ret) {\n\t\thid_err(hdev, \"failed to start HID HW\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"failed to open HID HW\\n\");\n\t\tgoto err_hid_stop;\n\t}\n\n\tret = ft260_hid_feature_report_get(hdev, FT260_CHIP_VERSION,\n\t\t\t\t\t   (u8 *)&version, sizeof(version));\n\tif (ret < 0) {\n\t\thid_err(hdev, \"failed to retrieve chip version\\n\");\n\t\tgoto err_hid_close;\n\t}\n\n\thid_info(hdev, \"chip code: %02x%02x %02x%02x\\n\",\n\t\t version.chip_code[0], version.chip_code[1],\n\t\t version.chip_code[2], version.chip_code[3]);\n\n\tret = ft260_is_interface_enabled(hdev);\n\tif (ret <= 0)\n\t\tgoto err_hid_close;\n\n\thid_info(hdev, \"USB HID v%x.%02x Device [%s] on %s\\n\",\n\t\thdev->version >> 8, hdev->version & 0xff, hdev->name,\n\t\thdev->phys);\n\n\thid_set_drvdata(hdev, dev);\n\tdev->hdev = hdev;\n\tdev->adap.owner = THIS_MODULE;\n\tdev->adap.class = I2C_CLASS_HWMON;\n\tdev->adap.algo = &ft260_i2c_algo;\n\tdev->adap.quirks = &ft260_i2c_quirks;\n\tdev->adap.dev.parent = &hdev->dev;\n\tsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\t\t \"FT260 usb-i2c bridge\");\n\n\tmutex_init(&dev->lock);\n\tinit_completion(&dev->wait);\n\n\tret = ft260_xfer_status(dev, FT260_I2C_STATUS_BUS_BUSY);\n\tif (ret)\n\t\tft260_i2c_reset(hdev);\n\n\ti2c_set_adapdata(&dev->adap, dev);\n\tret = i2c_add_adapter(&dev->adap);\n\tif (ret) {\n\t\thid_err(hdev, \"failed to add i2c adapter\\n\");\n\t\tgoto err_hid_close;\n\t}\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &ft260_attr_group);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"failed to create sysfs attrs\\n\");\n\t\tgoto err_i2c_free;\n\t}\n\n\treturn 0;\n\nerr_i2c_free:\n\ti2c_del_adapter(&dev->adap);\nerr_hid_close:\n\thid_hw_close(hdev);\nerr_hid_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void ft260_remove(struct hid_device *hdev)\n{\n\tstruct ft260_device *dev = hid_get_drvdata(hdev);\n\n\tif (!dev)\n\t\treturn;\n\n\tsysfs_remove_group(&hdev->dev.kobj, &ft260_attr_group);\n\ti2c_del_adapter(&dev->adap);\n\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic int ft260_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\t\t   u8 *data, int size)\n{\n\tstruct ft260_device *dev = hid_get_drvdata(hdev);\n\tstruct ft260_i2c_input_report *xfer = (void *)data;\n\n\tif (xfer->report >= FT260_I2C_REPORT_MIN &&\n\t    xfer->report <= FT260_I2C_REPORT_MAX) {\n\t\tft260_dbg(\"i2c resp: rep %#02x len %d\\n\", xfer->report,\n\t\t\t  xfer->length);\n\n\t\tif ((dev->read_buf == NULL) ||\n\t\t    (xfer->length > dev->read_len - dev->read_idx)) {\n\t\t\thid_err(hdev, \"unexpected report %#02x, length %d\\n\",\n\t\t\t\txfer->report, xfer->length);\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(&dev->read_buf[dev->read_idx], &xfer->data,\n\t\t       xfer->length);\n\t\tdev->read_idx += xfer->length;\n\n\t\tif (dev->read_idx == dev->read_len)\n\t\t\tcomplete(&dev->wait);\n\n\t} else {\n\t\thid_err(hdev, \"unhandled report %#02x\\n\", xfer->report);\n\t}\n\treturn 0;\n}\n\nstatic struct hid_driver ft260_driver = {\n\t.name\t\t= \"ft260\",\n\t.id_table\t= ft260_devices,\n\t.probe\t\t= ft260_probe,\n\t.remove\t\t= ft260_remove,\n\t.raw_event\t= ft260_raw_event,\n};\n\nmodule_hid_driver(ft260_driver);\nMODULE_DESCRIPTION(\"FTDI FT260 USB HID to I2C host bridge\");\nMODULE_AUTHOR(\"Michael Zaidman <michael.zaidman@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}