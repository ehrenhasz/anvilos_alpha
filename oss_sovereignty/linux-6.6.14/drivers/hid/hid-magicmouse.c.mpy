{
  "module_name": "hid-magicmouse.c",
  "hash_id": "cbbd3439ff87b04f5ecb0364c3fb80bcb6065a022acc1bbfd8a05b0308da46b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-magicmouse.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/input/mt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"hid-ids.h\"\n\nstatic bool emulate_3button = true;\nmodule_param(emulate_3button, bool, 0644);\nMODULE_PARM_DESC(emulate_3button, \"Emulate a middle button\");\n\nstatic int middle_button_start = -350;\nstatic int middle_button_stop = +350;\n\nstatic bool emulate_scroll_wheel = true;\nmodule_param(emulate_scroll_wheel, bool, 0644);\nMODULE_PARM_DESC(emulate_scroll_wheel, \"Emulate a scroll wheel\");\n\nstatic unsigned int scroll_speed = 32;\nstatic int param_set_scroll_speed(const char *val,\n\t\t\t\t  const struct kernel_param *kp) {\n\tunsigned long speed;\n\tif (!val || kstrtoul(val, 0, &speed) || speed > 63)\n\t\treturn -EINVAL;\n\tscroll_speed = speed;\n\treturn 0;\n}\nmodule_param_call(scroll_speed, param_set_scroll_speed, param_get_uint, &scroll_speed, 0644);\nMODULE_PARM_DESC(scroll_speed, \"Scroll speed, value from 0 (slow) to 63 (fast)\");\n\nstatic bool scroll_acceleration = false;\nmodule_param(scroll_acceleration, bool, 0644);\nMODULE_PARM_DESC(scroll_acceleration, \"Accelerate sequential scroll events\");\n\nstatic bool report_undeciphered;\nmodule_param(report_undeciphered, bool, 0644);\nMODULE_PARM_DESC(report_undeciphered, \"Report undeciphered multi-touch state field using a MSC_RAW event\");\n\n#define TRACKPAD2_2021_BT_VERSION 0x110\n\n#define TRACKPAD_REPORT_ID 0x28\n#define TRACKPAD2_USB_REPORT_ID 0x02\n#define TRACKPAD2_BT_REPORT_ID 0x31\n#define MOUSE_REPORT_ID    0x29\n#define MOUSE2_REPORT_ID   0x12\n#define DOUBLE_REPORT_ID   0xf7\n#define USB_BATTERY_TIMEOUT_MS 60000\n\n \n#define TOUCH_STATE_MASK  0xf0\n#define TOUCH_STATE_NONE  0x00\n#define TOUCH_STATE_START 0x30\n#define TOUCH_STATE_DRAG  0x40\n\n \n#define SCROLL_HR_STEPS 10\n#define SCROLL_HR_MULT (120 / SCROLL_HR_STEPS)\n#define SCROLL_HR_THRESHOLD 90  \n#define SCROLL_ACCEL_DEFAULT 7\n\n \n#define MOUSE_DIMENSION_X (float)9056\n#define MOUSE_MIN_X -1100\n#define MOUSE_MAX_X 1258\n#define MOUSE_RES_X ((MOUSE_MAX_X - MOUSE_MIN_X) / (MOUSE_DIMENSION_X / 100))\n#define MOUSE_DIMENSION_Y (float)5152\n#define MOUSE_MIN_Y -1589\n#define MOUSE_MAX_Y 2047\n#define MOUSE_RES_Y ((MOUSE_MAX_Y - MOUSE_MIN_Y) / (MOUSE_DIMENSION_Y / 100))\n\n#define TRACKPAD_DIMENSION_X (float)13000\n#define TRACKPAD_MIN_X -2909\n#define TRACKPAD_MAX_X 3167\n#define TRACKPAD_RES_X \\\n\t((TRACKPAD_MAX_X - TRACKPAD_MIN_X) / (TRACKPAD_DIMENSION_X / 100))\n#define TRACKPAD_DIMENSION_Y (float)11000\n#define TRACKPAD_MIN_Y -2456\n#define TRACKPAD_MAX_Y 2565\n#define TRACKPAD_RES_Y \\\n\t((TRACKPAD_MAX_Y - TRACKPAD_MIN_Y) / (TRACKPAD_DIMENSION_Y / 100))\n\n#define TRACKPAD2_DIMENSION_X (float)16000\n#define TRACKPAD2_MIN_X -3678\n#define TRACKPAD2_MAX_X 3934\n#define TRACKPAD2_RES_X \\\n\t((TRACKPAD2_MAX_X - TRACKPAD2_MIN_X) / (TRACKPAD2_DIMENSION_X / 100))\n#define TRACKPAD2_DIMENSION_Y (float)11490\n#define TRACKPAD2_MIN_Y -2478\n#define TRACKPAD2_MAX_Y 2587\n#define TRACKPAD2_RES_Y \\\n\t((TRACKPAD2_MAX_Y - TRACKPAD2_MIN_Y) / (TRACKPAD2_DIMENSION_Y / 100))\n\n \nstruct magicmouse_sc {\n\tstruct input_dev *input;\n\tunsigned long quirks;\n\n\tint ntouches;\n\tint scroll_accel;\n\tunsigned long scroll_jiffies;\n\n\tstruct {\n\t\tshort x;\n\t\tshort y;\n\t\tshort scroll_x;\n\t\tshort scroll_y;\n\t\tshort scroll_x_hr;\n\t\tshort scroll_y_hr;\n\t\tu8 size;\n\t\tbool scroll_x_active;\n\t\tbool scroll_y_active;\n\t} touches[16];\n\tint tracking_ids[16];\n\n\tstruct hid_device *hdev;\n\tstruct delayed_work work;\n\tstruct timer_list battery_timer;\n};\n\nstatic int magicmouse_firm_touch(struct magicmouse_sc *msc)\n{\n\tint touch = -1;\n\tint ii;\n\n\t \n\tfor (ii = 0; ii < msc->ntouches; ii++) {\n\t\tint idx = msc->tracking_ids[ii];\n\t\tif (msc->touches[idx].size < 8) {\n\t\t\t \n\t\t} else if (touch >= 0) {\n\t\t\ttouch = -1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\ttouch = idx;\n\t\t}\n\t}\n\n\treturn touch;\n}\n\nstatic void magicmouse_emit_buttons(struct magicmouse_sc *msc, int state)\n{\n\tint last_state = test_bit(BTN_LEFT, msc->input->key) << 0 |\n\t\ttest_bit(BTN_RIGHT, msc->input->key) << 1 |\n\t\ttest_bit(BTN_MIDDLE, msc->input->key) << 2;\n\n\tif (emulate_3button) {\n\t\tint id;\n\n\t\t \n\t\tif (state == 0) {\n\t\t\t \n\t\t} else if (last_state != 0) {\n\t\t\tstate = last_state;\n\t\t} else if ((id = magicmouse_firm_touch(msc)) >= 0) {\n\t\t\tint x = msc->touches[id].x;\n\t\t\tif (x < middle_button_start)\n\t\t\t\tstate = 1;\n\t\t\telse if (x > middle_button_stop)\n\t\t\t\tstate = 2;\n\t\t\telse\n\t\t\t\tstate = 4;\n\t\t}  \n\n\t\tinput_report_key(msc->input, BTN_MIDDLE, state & 4);\n\t}\n\n\tinput_report_key(msc->input, BTN_LEFT, state & 1);\n\tinput_report_key(msc->input, BTN_RIGHT, state & 2);\n\n\tif (state != last_state)\n\t\tmsc->scroll_accel = SCROLL_ACCEL_DEFAULT;\n}\n\nstatic void magicmouse_emit_touch(struct magicmouse_sc *msc, int raw_id, u8 *tdata)\n{\n\tstruct input_dev *input = msc->input;\n\tint id, x, y, size, orientation, touch_major, touch_minor, state, down;\n\tint pressure = 0;\n\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE ||\n\t    input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE2) {\n\t\tid = (tdata[6] << 2 | tdata[5] >> 6) & 0xf;\n\t\tx = (tdata[1] << 28 | tdata[0] << 20) >> 20;\n\t\ty = -((tdata[2] << 24 | tdata[1] << 16) >> 20);\n\t\tsize = tdata[5] & 0x3f;\n\t\torientation = (tdata[6] >> 2) - 32;\n\t\ttouch_major = tdata[3];\n\t\ttouch_minor = tdata[4];\n\t\tstate = tdata[7] & TOUCH_STATE_MASK;\n\t\tdown = state != TOUCH_STATE_NONE;\n\t} else if (input->id.product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) {\n\t\tid = tdata[8] & 0xf;\n\t\tx = (tdata[1] << 27 | tdata[0] << 19) >> 19;\n\t\ty = -((tdata[3] << 30 | tdata[2] << 22 | tdata[1] << 14) >> 19);\n\t\tsize = tdata[6];\n\t\torientation = (tdata[8] >> 5) - 4;\n\t\ttouch_major = tdata[4];\n\t\ttouch_minor = tdata[5];\n\t\tpressure = tdata[7];\n\t\tstate = tdata[3] & 0xC0;\n\t\tdown = state == 0x80;\n\t} else {  \n\t\tid = (tdata[7] << 2 | tdata[6] >> 6) & 0xf;\n\t\tx = (tdata[1] << 27 | tdata[0] << 19) >> 19;\n\t\ty = -((tdata[3] << 30 | tdata[2] << 22 | tdata[1] << 14) >> 19);\n\t\tsize = tdata[6] & 0x3f;\n\t\torientation = (tdata[7] >> 2) - 32;\n\t\ttouch_major = tdata[4];\n\t\ttouch_minor = tdata[5];\n\t\tstate = tdata[8] & TOUCH_STATE_MASK;\n\t\tdown = state != TOUCH_STATE_NONE;\n\t}\n\n\t \n\tmsc->tracking_ids[raw_id] = id;\n\tmsc->touches[id].x = x;\n\tmsc->touches[id].y = y;\n\tmsc->touches[id].size = size;\n\n\t \n\tif (emulate_scroll_wheel && (input->id.product !=\n\t\t\tUSB_DEVICE_ID_APPLE_MAGICTRACKPAD2)) {\n\t\tunsigned long now = jiffies;\n\t\tint step_x = msc->touches[id].scroll_x - x;\n\t\tint step_y = msc->touches[id].scroll_y - y;\n\t\tint step_hr =\n\t\t\tmax_t(int,\n\t\t\t      ((64 - (int)scroll_speed) * msc->scroll_accel) /\n\t\t\t\t\tSCROLL_HR_STEPS,\n\t\t\t      1);\n\t\tint step_x_hr = msc->touches[id].scroll_x_hr - x;\n\t\tint step_y_hr = msc->touches[id].scroll_y_hr - y;\n\n\t\t \n\t\tswitch (state) {\n\t\tcase TOUCH_STATE_START:\n\t\t\tmsc->touches[id].scroll_x = x;\n\t\t\tmsc->touches[id].scroll_y = y;\n\t\t\tmsc->touches[id].scroll_x_hr = x;\n\t\t\tmsc->touches[id].scroll_y_hr = y;\n\t\t\tmsc->touches[id].scroll_x_active = false;\n\t\t\tmsc->touches[id].scroll_y_active = false;\n\n\t\t\t \n\t\t\tif (scroll_acceleration && time_before(now,\n\t\t\t\t\t\tmsc->scroll_jiffies + HZ / 2))\n\t\t\t\tmsc->scroll_accel = max_t(int,\n\t\t\t\t\t\tmsc->scroll_accel - 1, 1);\n\t\t\telse\n\t\t\t\tmsc->scroll_accel = SCROLL_ACCEL_DEFAULT;\n\n\t\t\tbreak;\n\t\tcase TOUCH_STATE_DRAG:\n\t\t\tstep_x /= (64 - (int)scroll_speed) * msc->scroll_accel;\n\t\t\tif (step_x != 0) {\n\t\t\t\tmsc->touches[id].scroll_x -= step_x *\n\t\t\t\t\t(64 - scroll_speed) * msc->scroll_accel;\n\t\t\t\tmsc->scroll_jiffies = now;\n\t\t\t\tinput_report_rel(input, REL_HWHEEL, -step_x);\n\t\t\t}\n\n\t\t\tstep_y /= (64 - (int)scroll_speed) * msc->scroll_accel;\n\t\t\tif (step_y != 0) {\n\t\t\t\tmsc->touches[id].scroll_y -= step_y *\n\t\t\t\t\t(64 - scroll_speed) * msc->scroll_accel;\n\t\t\t\tmsc->scroll_jiffies = now;\n\t\t\t\tinput_report_rel(input, REL_WHEEL, step_y);\n\t\t\t}\n\n\t\t\tif (!msc->touches[id].scroll_x_active &&\n\t\t\t    abs(step_x_hr) > SCROLL_HR_THRESHOLD) {\n\t\t\t\tmsc->touches[id].scroll_x_active = true;\n\t\t\t\tmsc->touches[id].scroll_x_hr = x;\n\t\t\t\tstep_x_hr = 0;\n\t\t\t}\n\n\t\t\tstep_x_hr /= step_hr;\n\t\t\tif (step_x_hr != 0 &&\n\t\t\t    msc->touches[id].scroll_x_active) {\n\t\t\t\tmsc->touches[id].scroll_x_hr -= step_x_hr *\n\t\t\t\t\tstep_hr;\n\t\t\t\tinput_report_rel(input,\n\t\t\t\t\t\t REL_HWHEEL_HI_RES,\n\t\t\t\t\t\t -step_x_hr * SCROLL_HR_MULT);\n\t\t\t}\n\n\t\t\tif (!msc->touches[id].scroll_y_active &&\n\t\t\t    abs(step_y_hr) > SCROLL_HR_THRESHOLD) {\n\t\t\t\tmsc->touches[id].scroll_y_active = true;\n\t\t\t\tmsc->touches[id].scroll_y_hr = y;\n\t\t\t\tstep_y_hr = 0;\n\t\t\t}\n\n\t\t\tstep_y_hr /= step_hr;\n\t\t\tif (step_y_hr != 0 &&\n\t\t\t    msc->touches[id].scroll_y_active) {\n\t\t\t\tmsc->touches[id].scroll_y_hr -= step_y_hr *\n\t\t\t\t\tstep_hr;\n\t\t\t\tinput_report_rel(input,\n\t\t\t\t\t\t REL_WHEEL_HI_RES,\n\t\t\t\t\t\t step_y_hr * SCROLL_HR_MULT);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (down)\n\t\tmsc->ntouches++;\n\n\tinput_mt_slot(input, id);\n\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, down);\n\n\t \n\tif (down) {\n\t\tinput_report_abs(input, ABS_MT_TOUCH_MAJOR, touch_major << 2);\n\t\tinput_report_abs(input, ABS_MT_TOUCH_MINOR, touch_minor << 2);\n\t\tinput_report_abs(input, ABS_MT_ORIENTATION, -orientation);\n\t\tinput_report_abs(input, ABS_MT_POSITION_X, x);\n\t\tinput_report_abs(input, ABS_MT_POSITION_Y, y);\n\n\t\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2)\n\t\t\tinput_report_abs(input, ABS_MT_PRESSURE, pressure);\n\n\t\tif (report_undeciphered) {\n\t\t\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE ||\n\t\t\t    input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE2)\n\t\t\t\tinput_event(input, EV_MSC, MSC_RAW, tdata[7]);\n\t\t\telse if (input->id.product !=\n\t\t\t\t\tUSB_DEVICE_ID_APPLE_MAGICTRACKPAD2)\n\t\t\t\tinput_event(input, EV_MSC, MSC_RAW, tdata[8]);\n\t\t}\n\t}\n}\n\nstatic int magicmouse_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = msc->input;\n\tint x = 0, y = 0, ii, clicks = 0, npoints;\n\n\tswitch (data[0]) {\n\tcase TRACKPAD_REPORT_ID:\n\tcase TRACKPAD2_BT_REPORT_ID:\n\t\t \n\t\tif (size < 4 || ((size - 4) % 9) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 4) / 9;\n\t\tif (npoints > 15) {\n\t\t\thid_warn(hdev, \"invalid size value (%d) for TRACKPAD_REPORT_ID\\n\",\n\t\t\t\t\tsize);\n\t\t\treturn 0;\n\t\t}\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\n\n\t\tclicks = data[1];\n\n\t\t \n\t\tbreak;\n\tcase TRACKPAD2_USB_REPORT_ID:\n\t\t \n\t\tif (size < 12 || ((size - 12) % 9) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 12) / 9;\n\t\tif (npoints > 15) {\n\t\t\thid_warn(hdev, \"invalid size value (%d) for TRACKPAD2_USB_REPORT_ID\\n\",\n\t\t\t\t\tsize);\n\t\t\treturn 0;\n\t\t}\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 12);\n\n\t\tclicks = data[1];\n\t\tbreak;\n\tcase MOUSE_REPORT_ID:\n\t\t \n\t\tif (size < 6 || ((size - 6) % 8) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 6) / 8;\n\t\tif (npoints > 15) {\n\t\t\thid_warn(hdev, \"invalid size value (%d) for MOUSE_REPORT_ID\\n\",\n\t\t\t\t\tsize);\n\t\t\treturn 0;\n\t\t}\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\n\n\t\t \n\t\tx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\n\t\ty = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\n\t\tclicks = data[3];\n\n\t\t \n\t\tbreak;\n\tcase MOUSE2_REPORT_ID:\n\t\t \n\t\tif (size != 8 && (size < 14 || (size - 14) % 8 != 0))\n\t\t\treturn 0;\n\t\tnpoints = (size - 14) / 8;\n\t\tif (npoints > 15) {\n\t\t\thid_warn(hdev, \"invalid size value (%d) for MOUSE2_REPORT_ID\\n\",\n\t\t\t\t\tsize);\n\t\t\treturn 0;\n\t\t}\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 14);\n\n\t\t \n\t\tx = (int)((data[3] << 24) | (data[2] << 16)) >> 16;\n\t\ty = (int)((data[5] << 24) | (data[4] << 16)) >> 16;\n\t\tclicks = data[1];\n\n\t\t \n\t\tbreak;\n\tcase DOUBLE_REPORT_ID:\n\t\t \n\t\tmagicmouse_raw_event(hdev, report, data + 2, data[1]);\n\t\tmagicmouse_raw_event(hdev, report, data + 2 + data[1],\n\t\t\tsize - 2 - data[1]);\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE ||\n\t    input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE2) {\n\t\tmagicmouse_emit_buttons(msc, clicks & 3);\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t} else if (input->id.product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) {\n\t\tinput_mt_sync_frame(input);\n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t} else {  \n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t\tinput_mt_report_pointer_emulation(input, true);\n\t}\n\n\tinput_sync(input);\n\treturn 1;\n}\n\nstatic int magicmouse_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tif (msc->input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE2 &&\n\t    field->report->id == MOUSE2_REPORT_ID) {\n\t\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int magicmouse_setup_input(struct input_dev *input, struct hid_device *hdev)\n{\n\tint error;\n\tint mt_flags = 0;\n\n\t__set_bit(EV_KEY, input->evbit);\n\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE ||\n\t    input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE2) {\n\t\t__set_bit(BTN_LEFT, input->keybit);\n\t\t__set_bit(BTN_RIGHT, input->keybit);\n\t\tif (emulate_3button)\n\t\t\t__set_bit(BTN_MIDDLE, input->keybit);\n\n\t\t__set_bit(EV_REL, input->evbit);\n\t\t__set_bit(REL_X, input->relbit);\n\t\t__set_bit(REL_Y, input->relbit);\n\t\tif (emulate_scroll_wheel) {\n\t\t\t__set_bit(REL_WHEEL, input->relbit);\n\t\t\t__set_bit(REL_HWHEEL, input->relbit);\n\t\t\t__set_bit(REL_WHEEL_HI_RES, input->relbit);\n\t\t\t__set_bit(REL_HWHEEL_HI_RES, input->relbit);\n\t\t}\n\t} else if (input->id.product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) {\n\t\t \n\t\tif (hdev->vendor == BT_VENDOR_ID_APPLE) {\n\t\t\tif (input->id.version == TRACKPAD2_2021_BT_VERSION)\n\t\t\t\tinput->name = \"Apple Inc. Magic Trackpad\";\n\t\t\telse\n\t\t\t\tinput->name = \"Apple Inc. Magic Trackpad 2\";\n\t\t} else {  \n\t\t\tinput->name = hdev->name;\n\t\t}\n\n\t\t__clear_bit(EV_MSC, input->evbit);\n\t\t__clear_bit(BTN_0, input->keybit);\n\t\t__clear_bit(BTN_RIGHT, input->keybit);\n\t\t__clear_bit(BTN_MIDDLE, input->keybit);\n\t\t__set_bit(BTN_MOUSE, input->keybit);\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\t\t__set_bit(BTN_TOOL_FINGER, input->keybit);\n\n\t\tmt_flags = INPUT_MT_POINTER | INPUT_MT_DROP_UNUSED |\n\t\t\t\tINPUT_MT_TRACK;\n\t} else {  \n\t\t \n\t\t__clear_bit(BTN_RIGHT, input->keybit);\n\t\t__clear_bit(BTN_MIDDLE, input->keybit);\n\t\t__set_bit(BTN_MOUSE, input->keybit);\n\t\t__set_bit(BTN_TOOL_FINGER, input->keybit);\n\t\t__set_bit(BTN_TOOL_DOUBLETAP, input->keybit);\n\t\t__set_bit(BTN_TOOL_TRIPLETAP, input->keybit);\n\t\t__set_bit(BTN_TOOL_QUADTAP, input->keybit);\n\t\t__set_bit(BTN_TOOL_QUINTTAP, input->keybit);\n\t\t__set_bit(BTN_TOUCH, input->keybit);\n\t\t__set_bit(INPUT_PROP_POINTER, input->propbit);\n\t\t__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\n\t}\n\n\n\t__set_bit(EV_ABS, input->evbit);\n\n\terror = input_mt_init_slots(input, 16, mt_flags);\n\tif (error)\n\t\treturn error;\n\tinput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255 << 2,\n\t\t\t     4, 0);\n\tinput_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 255 << 2,\n\t\t\t     4, 0);\n\n\t \n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE ||\n\t    input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE2) {\n\t\tinput_set_abs_params(input, ABS_MT_ORIENTATION, -31, 32, 1, 0);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_X,\n\t\t\t\t     MOUSE_MIN_X, MOUSE_MAX_X, 4, 0);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_Y,\n\t\t\t\t     MOUSE_MIN_Y, MOUSE_MAX_Y, 4, 0);\n\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_X,\n\t\t\t\t  MOUSE_RES_X);\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_Y,\n\t\t\t\t  MOUSE_RES_Y);\n\t} else if (input->id.product ==  USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) {\n\t\tinput_set_abs_params(input, ABS_MT_PRESSURE, 0, 253, 0, 0);\n\t\tinput_set_abs_params(input, ABS_PRESSURE, 0, 253, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_ORIENTATION, -3, 4, 0, 0);\n\t\tinput_set_abs_params(input, ABS_X, TRACKPAD2_MIN_X,\n\t\t\t\t     TRACKPAD2_MAX_X, 0, 0);\n\t\tinput_set_abs_params(input, ABS_Y, TRACKPAD2_MIN_Y,\n\t\t\t\t     TRACKPAD2_MAX_Y, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_X,\n\t\t\t\t     TRACKPAD2_MIN_X, TRACKPAD2_MAX_X, 0, 0);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_Y,\n\t\t\t\t     TRACKPAD2_MIN_Y, TRACKPAD2_MAX_Y, 0, 0);\n\n\t\tinput_abs_set_res(input, ABS_X, TRACKPAD2_RES_X);\n\t\tinput_abs_set_res(input, ABS_Y, TRACKPAD2_RES_Y);\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_X, TRACKPAD2_RES_X);\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_Y, TRACKPAD2_RES_Y);\n\t} else {  \n\t\tinput_set_abs_params(input, ABS_MT_ORIENTATION, -31, 32, 1, 0);\n\t\tinput_set_abs_params(input, ABS_X, TRACKPAD_MIN_X,\n\t\t\t\t     TRACKPAD_MAX_X, 4, 0);\n\t\tinput_set_abs_params(input, ABS_Y, TRACKPAD_MIN_Y,\n\t\t\t\t     TRACKPAD_MAX_Y, 4, 0);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_X,\n\t\t\t\t     TRACKPAD_MIN_X, TRACKPAD_MAX_X, 4, 0);\n\t\tinput_set_abs_params(input, ABS_MT_POSITION_Y,\n\t\t\t\t     TRACKPAD_MIN_Y, TRACKPAD_MAX_Y, 4, 0);\n\n\t\tinput_abs_set_res(input, ABS_X, TRACKPAD_RES_X);\n\t\tinput_abs_set_res(input, ABS_Y, TRACKPAD_RES_Y);\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_X,\n\t\t\t\t  TRACKPAD_RES_X);\n\t\tinput_abs_set_res(input, ABS_MT_POSITION_Y,\n\t\t\t\t  TRACKPAD_RES_Y);\n\t}\n\n\tinput_set_events_per_packet(input, 60);\n\n\tif (report_undeciphered &&\n\t    input->id.product != USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) {\n\t\t__set_bit(EV_MSC, input->evbit);\n\t\t__set_bit(MSC_RAW, input->mscbit);\n\t}\n\n\t \n\t__clear_bit(EV_REP, input->evbit);\n\n\treturn 0;\n}\n\nstatic int magicmouse_input_mapping(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\n\tif (!msc->input)\n\t\tmsc->input = hi->input;\n\n\t \n\tif ((hi->input->id.product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD ||\n\t     hi->input->id.product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) &&\n\t    field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int magicmouse_input_configured(struct hid_device *hdev,\n\t\tstruct hid_input *hi)\n\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tint ret;\n\n\tret = magicmouse_setup_input(msc->input, hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"magicmouse setup input failed (%d)\\n\", ret);\n\t\t \n\t\tmsc->input = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int magicmouse_enable_multitouch(struct hid_device *hdev)\n{\n\tconst u8 *feature;\n\tconst u8 feature_mt[] = { 0xD7, 0x01 };\n\tconst u8 feature_mt_mouse2[] = { 0xF1, 0x02, 0x01 };\n\tconst u8 feature_mt_trackpad2_usb[] = { 0x02, 0x01 };\n\tconst u8 feature_mt_trackpad2_bt[] = { 0xF1, 0x02, 0x01 };\n\tu8 *buf;\n\tint ret;\n\tint feature_size;\n\n\tif (hdev->product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) {\n\t\tif (hdev->vendor == BT_VENDOR_ID_APPLE) {\n\t\t\tfeature_size = sizeof(feature_mt_trackpad2_bt);\n\t\t\tfeature = feature_mt_trackpad2_bt;\n\t\t} else {  \n\t\t\tfeature_size = sizeof(feature_mt_trackpad2_usb);\n\t\t\tfeature = feature_mt_trackpad2_usb;\n\t\t}\n\t} else if (hdev->product == USB_DEVICE_ID_APPLE_MAGICMOUSE2) {\n\t\tfeature_size = sizeof(feature_mt_mouse2);\n\t\tfeature = feature_mt_mouse2;\n\t} else {\n\t\tfeature_size = sizeof(feature_mt);\n\t\tfeature = feature_mt;\n\t}\n\n\tbuf = kmemdup(feature, feature_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, buf[0], buf, feature_size,\n\t\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic void magicmouse_enable_mt_work(struct work_struct *work)\n{\n\tstruct magicmouse_sc *msc =\n\t\tcontainer_of(work, struct magicmouse_sc, work.work);\n\tint ret;\n\n\tret = magicmouse_enable_multitouch(msc->hdev);\n\tif (ret < 0)\n\t\thid_err(msc->hdev, \"unable to request touch data (%d)\\n\", ret);\n}\n\nstatic int magicmouse_fetch_battery(struct hid_device *hdev)\n{\n#ifdef CONFIG_HID_BATTERY_STRENGTH\n\tstruct hid_report_enum *report_enum;\n\tstruct hid_report *report;\n\n\tif (!hdev->battery || hdev->vendor != USB_VENDOR_ID_APPLE ||\n\t    (hdev->product != USB_DEVICE_ID_APPLE_MAGICMOUSE2 &&\n\t     hdev->product != USB_DEVICE_ID_APPLE_MAGICTRACKPAD2))\n\t\treturn -1;\n\n\treport_enum = &hdev->report_enum[hdev->battery_report_type];\n\treport = report_enum->report_id_hash[hdev->battery_report_id];\n\n\tif (!report || report->maxfield < 1)\n\t\treturn -1;\n\n\tif (hdev->battery_capacity == hdev->battery_max)\n\t\treturn -1;\n\n\thid_hw_request(hdev, report, HID_REQ_GET_REPORT);\n\treturn 0;\n#else\n\treturn -1;\n#endif\n}\n\nstatic void magicmouse_battery_timer_tick(struct timer_list *t)\n{\n\tstruct magicmouse_sc *msc = from_timer(msc, t, battery_timer);\n\tstruct hid_device *hdev = msc->hdev;\n\n\tif (magicmouse_fetch_battery(hdev) == 0) {\n\t\tmod_timer(&msc->battery_timer,\n\t\t\t  jiffies + msecs_to_jiffies(USB_BATTERY_TIMEOUT_MS));\n\t}\n}\n\nstatic int magicmouse_probe(struct hid_device *hdev,\n\tconst struct hid_device_id *id)\n{\n\tstruct magicmouse_sc *msc;\n\tstruct hid_report *report;\n\tint ret;\n\n\tmsc = devm_kzalloc(&hdev->dev, sizeof(*msc), GFP_KERNEL);\n\tif (msc == NULL) {\n\t\thid_err(hdev, \"can't alloc magicmouse descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmsc->scroll_accel = SCROLL_ACCEL_DEFAULT;\n\tmsc->hdev = hdev;\n\tINIT_DEFERRABLE_WORK(&msc->work, magicmouse_enable_mt_work);\n\n\tmsc->quirks = id->driver_data;\n\thid_set_drvdata(hdev, msc);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"magicmouse hid parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"magicmouse hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\ttimer_setup(&msc->battery_timer, magicmouse_battery_timer_tick, 0);\n\tmod_timer(&msc->battery_timer,\n\t\t  jiffies + msecs_to_jiffies(USB_BATTERY_TIMEOUT_MS));\n\tmagicmouse_fetch_battery(hdev);\n\n\tif (id->vendor == USB_VENDOR_ID_APPLE &&\n\t    (id->product == USB_DEVICE_ID_APPLE_MAGICMOUSE2 ||\n\t     (id->product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2 && hdev->type != HID_TYPE_USBMOUSE)))\n\t\treturn 0;\n\n\tif (!msc->input) {\n\t\thid_err(hdev, \"magicmouse input not registered\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\n\tif (id->product == USB_DEVICE_ID_APPLE_MAGICMOUSE)\n\t\treport = hid_register_report(hdev, HID_INPUT_REPORT,\n\t\t\tMOUSE_REPORT_ID, 0);\n\telse if (id->product == USB_DEVICE_ID_APPLE_MAGICMOUSE2)\n\t\treport = hid_register_report(hdev, HID_INPUT_REPORT,\n\t\t\tMOUSE2_REPORT_ID, 0);\n\telse if (id->product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) {\n\t\tif (id->vendor == BT_VENDOR_ID_APPLE)\n\t\t\treport = hid_register_report(hdev, HID_INPUT_REPORT,\n\t\t\t\tTRACKPAD2_BT_REPORT_ID, 0);\n\t\telse  \n\t\t\treport = hid_register_report(hdev, HID_INPUT_REPORT,\n\t\t\t\tTRACKPAD2_USB_REPORT_ID, 0);\n\t} else {  \n\t\treport = hid_register_report(hdev, HID_INPUT_REPORT,\n\t\t\tTRACKPAD_REPORT_ID, 0);\n\t\treport = hid_register_report(hdev, HID_INPUT_REPORT,\n\t\t\tDOUBLE_REPORT_ID, 0);\n\t}\n\n\tif (!report) {\n\t\thid_err(hdev, \"unable to register touch report\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_stop_hw;\n\t}\n\treport->size = 6;\n\n\t \n\tret = magicmouse_enable_multitouch(hdev);\n\tif (ret != -EIO && ret < 0) {\n\t\thid_err(hdev, \"unable to request touch data (%d)\\n\", ret);\n\t\tgoto err_stop_hw;\n\t}\n\tif (ret == -EIO && id->product == USB_DEVICE_ID_APPLE_MAGICMOUSE2) {\n\t\tschedule_delayed_work(&msc->work, msecs_to_jiffies(500));\n\t}\n\n\treturn 0;\nerr_stop_hw:\n\tdel_timer_sync(&msc->battery_timer);\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void magicmouse_remove(struct hid_device *hdev)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\n\tif (msc) {\n\t\tcancel_delayed_work_sync(&msc->work);\n\t\tdel_timer_sync(&msc->battery_timer);\n\t}\n\n\thid_hw_stop(hdev);\n}\n\nstatic __u8 *magicmouse_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\t\t\t     unsigned int *rsize)\n{\n\t \n\tif (hdev->vendor == USB_VENDOR_ID_APPLE &&\n\t    (hdev->product == USB_DEVICE_ID_APPLE_MAGICMOUSE2 ||\n\t     hdev->product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) &&\n\t    *rsize == 83 && rdesc[46] == 0x84 && rdesc[58] == 0x85) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up magicmouse battery report descriptor\\n\");\n\t\t*rsize = *rsize - 1;\n\t\trdesc = kmemdup(rdesc + 1, *rsize, GFP_KERNEL);\n\t\tif (!rdesc)\n\t\t\treturn NULL;\n\n\t\trdesc[0] = 0x05;\n\t\trdesc[1] = 0x01;\n\t\trdesc[2] = 0x09;\n\t\trdesc[3] = 0x02;\n\t}\n\n\treturn rdesc;\n}\n\nstatic const struct hid_device_id magic_mice[] = {\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_MAGICMOUSE), .driver_data = 0 },\n\t{ HID_BLUETOOTH_DEVICE(BT_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_MAGICMOUSE2), .driver_data = 0 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_MAGICMOUSE2), .driver_data = 0 },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_MAGICTRACKPAD), .driver_data = 0 },\n\t{ HID_BLUETOOTH_DEVICE(BT_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_MAGICTRACKPAD2), .driver_data = 0 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,\n\t\tUSB_DEVICE_ID_APPLE_MAGICTRACKPAD2), .driver_data = 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, magic_mice);\n\nstatic struct hid_driver magicmouse_driver = {\n\t.name = \"magicmouse\",\n\t.id_table = magic_mice,\n\t.probe = magicmouse_probe,\n\t.remove = magicmouse_remove,\n\t.report_fixup = magicmouse_report_fixup,\n\t.raw_event = magicmouse_raw_event,\n\t.event = magicmouse_event,\n\t.input_mapping = magicmouse_input_mapping,\n\t.input_configured = magicmouse_input_configured,\n};\nmodule_hid_driver(magicmouse_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}