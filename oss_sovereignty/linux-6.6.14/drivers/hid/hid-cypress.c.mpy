{
  "module_name": "hid-cypress.c",
  "hash_id": "1729bffadacaf4f37e21380e82946a294b32173e2a51e78f17690c6c43a25dae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-cypress.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define CP_RDESC_SWAPPED_MIN_MAX\t0x01\n#define CP_2WHEEL_MOUSE_HACK\t\t0x02\n#define CP_2WHEEL_MOUSE_HACK_ON\t\t0x04\n\n#define VA_INVAL_LOGICAL_BOUNDARY\t0x08\n\n \nstatic __u8 *cp_rdesc_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tunsigned int i;\n\n\tif (*rsize < 4)\n\t\treturn rdesc;\n\n\tfor (i = 0; i < *rsize - 4; i++)\n\t\tif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\n\t\t\trdesc[i] = 0x19;\n\t\t\trdesc[i + 2] = 0x29;\n\t\t\tswap(rdesc[i + 3], rdesc[i + 1]);\n\t\t}\n\treturn rdesc;\n}\n\nstatic __u8 *va_logical_boundary_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\t \n\tif (*rsize == 25 &&\n\t\t\trdesc[0] == 0x05 && rdesc[1] == 0x0c &&\n\t\t\trdesc[2] == 0x09 && rdesc[3] == 0x01 &&\n\t\t\trdesc[6] == 0x19 && rdesc[7] == 0x00 &&\n\t\t\trdesc[11] == 0x16 && rdesc[12] == 0x3c && rdesc[13] == 0x02) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up varmilo VA104M consumer control report descriptor\\n\");\n\t\trdesc[12] = 0x00;\n\t\trdesc[13] = 0x00;\n\t}\n\treturn rdesc;\n}\n\nstatic __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\n\tif (quirks & CP_RDESC_SWAPPED_MIN_MAX)\n\t\trdesc = cp_rdesc_fixup(hdev, rdesc, rsize);\n\tif (quirks & VA_INVAL_LOGICAL_BOUNDARY)\n\t\trdesc = va_logical_boundary_fixup(hdev, rdesc, rsize);\n\n\treturn rdesc;\n}\n\nstatic int cp_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\n\tif (!(quirks & CP_2WHEEL_MOUSE_HACK))\n\t\treturn 0;\n\n\tif (usage->type == EV_REL && usage->code == REL_WHEEL)\n\t\tset_bit(REL_HWHEEL, *bit);\n\tif (usage->hid == 0x00090005)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int cp_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput ||\n\t\t\t!usage->type || !(quirks & CP_2WHEEL_MOUSE_HACK))\n\t\treturn 0;\n\n\tif (usage->hid == 0x00090005) {\n\t\tif (value)\n\t\t\tquirks |=  CP_2WHEEL_MOUSE_HACK_ON;\n\t\telse\n\t\t\tquirks &= ~CP_2WHEEL_MOUSE_HACK_ON;\n\t\thid_set_drvdata(hdev, (void *)quirks);\n\t\treturn 1;\n\t}\n\n\tif (usage->code == REL_WHEEL && (quirks & CP_2WHEEL_MOUSE_HACK_ON)) {\n\t\tstruct input_dev *input = field->hidinput->input;\n\n\t\tinput_event(input, usage->type, REL_HWHEEL, value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int cp_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tunsigned long quirks = id->driver_data;\n\tint ret;\n\n\thid_set_drvdata(hdev, (void *)quirks);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\nerr_free:\n\treturn ret;\n}\n\nstatic const struct hid_device_id cp_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_1),\n\t\t.driver_data = CP_RDESC_SWAPPED_MIN_MAX },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_2),\n\t\t.driver_data = CP_RDESC_SWAPPED_MIN_MAX },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_3),\n\t\t.driver_data = CP_RDESC_SWAPPED_MIN_MAX },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_4),\n\t\t.driver_data = CP_RDESC_SWAPPED_MIN_MAX },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_MOUSE),\n\t\t.driver_data = CP_2WHEEL_MOUSE_HACK },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_VARMILO_VA104M_07B1),\n\t\t.driver_data = VA_INVAL_LOGICAL_BOUNDARY },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, cp_devices);\n\nstatic struct hid_driver cp_driver = {\n\t.name = \"cypress\",\n\t.id_table = cp_devices,\n\t.report_fixup = cp_report_fixup,\n\t.input_mapped = cp_input_mapped,\n\t.event = cp_event,\n\t.probe = cp_probe,\n};\nmodule_hid_driver(cp_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}