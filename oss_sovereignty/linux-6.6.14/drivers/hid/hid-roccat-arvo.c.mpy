{
  "module_name": "hid-roccat-arvo.c",
  "hash_id": "638d34cd556d20fe08bf33a7b9e473ef6c84157fea01c8de28169213c994a161",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-roccat-arvo.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/hid-roccat.h>\n#include \"hid-ids.h\"\n#include \"hid-roccat-common.h\"\n#include \"hid-roccat-arvo.h\"\n\nstatic ssize_t arvo_sysfs_show_mode_key(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct arvo_device *arvo =\n\t\t\thid_get_drvdata(dev_get_drvdata(dev->parent->parent));\n\tstruct usb_device *usb_dev =\n\t\t\tinterface_to_usbdev(to_usb_interface(dev->parent->parent));\n\tstruct arvo_mode_key temp_buf;\n\tint retval;\n\n\tmutex_lock(&arvo->arvo_lock);\n\tretval = roccat_common2_receive(usb_dev, ARVO_COMMAND_MODE_KEY,\n\t\t\t&temp_buf, sizeof(struct arvo_mode_key));\n\tmutex_unlock(&arvo->arvo_lock);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sysfs_emit(buf, \"%d\\n\", temp_buf.state);\n}\n\nstatic ssize_t arvo_sysfs_set_mode_key(struct device *dev,\n\t\tstruct device_attribute *attr, char const *buf, size_t size)\n{\n\tstruct arvo_device *arvo =\n\t\t\thid_get_drvdata(dev_get_drvdata(dev->parent->parent));\n\tstruct usb_device *usb_dev =\n\t\t\tinterface_to_usbdev(to_usb_interface(dev->parent->parent));\n\tstruct arvo_mode_key temp_buf;\n\tunsigned long state;\n\tint retval;\n\n\tretval = kstrtoul(buf, 10, &state);\n\tif (retval)\n\t\treturn retval;\n\n\ttemp_buf.command = ARVO_COMMAND_MODE_KEY;\n\ttemp_buf.state = state;\n\n\tmutex_lock(&arvo->arvo_lock);\n\tretval = roccat_common2_send(usb_dev, ARVO_COMMAND_MODE_KEY,\n\t\t\t&temp_buf, sizeof(struct arvo_mode_key));\n\tmutex_unlock(&arvo->arvo_lock);\n\tif (retval)\n\t\treturn retval;\n\n\treturn size;\n}\nstatic DEVICE_ATTR(mode_key, 0660,\n\t\t   arvo_sysfs_show_mode_key, arvo_sysfs_set_mode_key);\n\nstatic ssize_t arvo_sysfs_show_key_mask(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct arvo_device *arvo =\n\t\t\thid_get_drvdata(dev_get_drvdata(dev->parent->parent));\n\tstruct usb_device *usb_dev =\n\t\t\tinterface_to_usbdev(to_usb_interface(dev->parent->parent));\n\tstruct arvo_key_mask temp_buf;\n\tint retval;\n\n\tmutex_lock(&arvo->arvo_lock);\n\tretval = roccat_common2_receive(usb_dev, ARVO_COMMAND_KEY_MASK,\n\t\t\t&temp_buf, sizeof(struct arvo_key_mask));\n\tmutex_unlock(&arvo->arvo_lock);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sysfs_emit(buf, \"%d\\n\", temp_buf.key_mask);\n}\n\nstatic ssize_t arvo_sysfs_set_key_mask(struct device *dev,\n\t\tstruct device_attribute *attr, char const *buf, size_t size)\n{\n\tstruct arvo_device *arvo =\n\t\t\thid_get_drvdata(dev_get_drvdata(dev->parent->parent));\n\tstruct usb_device *usb_dev =\n\t\t\tinterface_to_usbdev(to_usb_interface(dev->parent->parent));\n\tstruct arvo_key_mask temp_buf;\n\tunsigned long key_mask;\n\tint retval;\n\n\tretval = kstrtoul(buf, 10, &key_mask);\n\tif (retval)\n\t\treturn retval;\n\n\ttemp_buf.command = ARVO_COMMAND_KEY_MASK;\n\ttemp_buf.key_mask = key_mask;\n\n\tmutex_lock(&arvo->arvo_lock);\n\tretval = roccat_common2_send(usb_dev, ARVO_COMMAND_KEY_MASK,\n\t\t\t&temp_buf, sizeof(struct arvo_key_mask));\n\tmutex_unlock(&arvo->arvo_lock);\n\tif (retval)\n\t\treturn retval;\n\n\treturn size;\n}\nstatic DEVICE_ATTR(key_mask, 0660,\n\t\t   arvo_sysfs_show_key_mask, arvo_sysfs_set_key_mask);\n\n \nstatic int arvo_get_actual_profile(struct usb_device *usb_dev)\n{\n\tstruct arvo_actual_profile temp_buf;\n\tint retval;\n\n\tretval = roccat_common2_receive(usb_dev, ARVO_COMMAND_ACTUAL_PROFILE,\n\t\t\t&temp_buf, sizeof(struct arvo_actual_profile));\n\n\tif (retval)\n\t\treturn retval;\n\n\treturn temp_buf.actual_profile;\n}\n\nstatic ssize_t arvo_sysfs_show_actual_profile(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct arvo_device *arvo =\n\t\t\thid_get_drvdata(dev_get_drvdata(dev->parent->parent));\n\n\treturn sysfs_emit(buf, \"%d\\n\", arvo->actual_profile);\n}\n\nstatic ssize_t arvo_sysfs_set_actual_profile(struct device *dev,\n\t\tstruct device_attribute *attr, char const *buf, size_t size)\n{\n\tstruct arvo_device *arvo =\n\t\t\thid_get_drvdata(dev_get_drvdata(dev->parent->parent));\n\tstruct usb_device *usb_dev =\n\t\t\tinterface_to_usbdev(to_usb_interface(dev->parent->parent));\n\tstruct arvo_actual_profile temp_buf;\n\tunsigned long profile;\n\tint retval;\n\n\tretval = kstrtoul(buf, 10, &profile);\n\tif (retval)\n\t\treturn retval;\n\n\tif (profile < 1 || profile > 5)\n\t\treturn -EINVAL;\n\n\ttemp_buf.command = ARVO_COMMAND_ACTUAL_PROFILE;\n\ttemp_buf.actual_profile = profile;\n\n\tmutex_lock(&arvo->arvo_lock);\n\tretval = roccat_common2_send(usb_dev, ARVO_COMMAND_ACTUAL_PROFILE,\n\t\t\t&temp_buf, sizeof(struct arvo_actual_profile));\n\tif (!retval) {\n\t\tarvo->actual_profile = profile;\n\t\tretval = size;\n\t}\n\tmutex_unlock(&arvo->arvo_lock);\n\treturn retval;\n}\nstatic DEVICE_ATTR(actual_profile, 0660,\n\t\t   arvo_sysfs_show_actual_profile,\n\t\t   arvo_sysfs_set_actual_profile);\n\nstatic ssize_t arvo_sysfs_write(struct file *fp,\n\t\tstruct kobject *kobj, void const *buf,\n\t\tloff_t off, size_t count, size_t real_size, uint command)\n{\n\tstruct device *dev = kobj_to_dev(kobj)->parent->parent;\n\tstruct arvo_device *arvo = hid_get_drvdata(dev_get_drvdata(dev));\n\tstruct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));\n\tint retval;\n\n\tif (off != 0 || count != real_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&arvo->arvo_lock);\n\tretval = roccat_common2_send(usb_dev, command, buf, real_size);\n\tmutex_unlock(&arvo->arvo_lock);\n\n\treturn (retval ? retval : real_size);\n}\n\nstatic ssize_t arvo_sysfs_read(struct file *fp,\n\t\tstruct kobject *kobj, void *buf, loff_t off,\n\t\tsize_t count, size_t real_size, uint command)\n{\n\tstruct device *dev = kobj_to_dev(kobj)->parent->parent;\n\tstruct arvo_device *arvo = hid_get_drvdata(dev_get_drvdata(dev));\n\tstruct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));\n\tint retval;\n\n\tif (off >= real_size)\n\t\treturn 0;\n\n\tif (off != 0 || count != real_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&arvo->arvo_lock);\n\tretval = roccat_common2_receive(usb_dev, command, buf, real_size);\n\tmutex_unlock(&arvo->arvo_lock);\n\n\treturn (retval ? retval : real_size);\n}\n\nstatic ssize_t arvo_sysfs_write_button(struct file *fp,\n\t\tstruct kobject *kobj, struct bin_attribute *attr, char *buf,\n\t\tloff_t off, size_t count)\n{\n\treturn arvo_sysfs_write(fp, kobj, buf, off, count,\n\t\t\tsizeof(struct arvo_button), ARVO_COMMAND_BUTTON);\n}\nstatic BIN_ATTR(button, 0220, NULL, arvo_sysfs_write_button,\n\t\tsizeof(struct arvo_button));\n\nstatic ssize_t arvo_sysfs_read_info(struct file *fp,\n\t\tstruct kobject *kobj, struct bin_attribute *attr, char *buf,\n\t\tloff_t off, size_t count)\n{\n\treturn arvo_sysfs_read(fp, kobj, buf, off, count,\n\t\t\tsizeof(struct arvo_info), ARVO_COMMAND_INFO);\n}\nstatic BIN_ATTR(info, 0440, arvo_sysfs_read_info, NULL,\n\t\tsizeof(struct arvo_info));\n\nstatic struct attribute *arvo_attrs[] = {\n\t&dev_attr_mode_key.attr,\n\t&dev_attr_key_mask.attr,\n\t&dev_attr_actual_profile.attr,\n\tNULL,\n};\n\nstatic struct bin_attribute *arvo_bin_attributes[] = {\n\t&bin_attr_button,\n\t&bin_attr_info,\n\tNULL,\n};\n\nstatic const struct attribute_group arvo_group = {\n\t.attrs = arvo_attrs,\n\t.bin_attrs = arvo_bin_attributes,\n};\n\nstatic const struct attribute_group *arvo_groups[] = {\n\t&arvo_group,\n\tNULL,\n};\n\nstatic const struct class arvo_class = {\n\t.name = \"arvo\",\n\t.dev_groups = arvo_groups,\n};\n\nstatic int arvo_init_arvo_device_struct(struct usb_device *usb_dev,\n\t\tstruct arvo_device *arvo)\n{\n\tint retval;\n\n\tmutex_init(&arvo->arvo_lock);\n\n\tretval = arvo_get_actual_profile(usb_dev);\n\tif (retval < 0)\n\t\treturn retval;\n\tarvo->actual_profile = retval;\n\n\treturn 0;\n}\n\nstatic int arvo_init_specials(struct hid_device *hdev)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct arvo_device *arvo;\n\tint retval;\n\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol\n\t\t\t== USB_INTERFACE_PROTOCOL_KEYBOARD) {\n\t\thid_set_drvdata(hdev, NULL);\n\t\treturn 0;\n\t}\n\n\tarvo = kzalloc(sizeof(*arvo), GFP_KERNEL);\n\tif (!arvo) {\n\t\thid_err(hdev, \"can't alloc device descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, arvo);\n\n\tretval = arvo_init_arvo_device_struct(usb_dev, arvo);\n\tif (retval) {\n\t\thid_err(hdev, \"couldn't init struct arvo_device\\n\");\n\t\tgoto exit_free;\n\t}\n\n\tretval = roccat_connect(&arvo_class, hdev,\n\t\t\tsizeof(struct arvo_roccat_report));\n\tif (retval < 0) {\n\t\thid_err(hdev, \"couldn't init char dev\\n\");\n\t} else {\n\t\tarvo->chrdev_minor = retval;\n\t\tarvo->roccat_claimed = 1;\n\t}\n\n\treturn 0;\nexit_free:\n\tkfree(arvo);\n\treturn retval;\n}\n\nstatic void arvo_remove_specials(struct hid_device *hdev)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct arvo_device *arvo;\n\n\tif (intf->cur_altsetting->desc.bInterfaceProtocol\n\t\t\t== USB_INTERFACE_PROTOCOL_KEYBOARD)\n\t\treturn;\n\n\tarvo = hid_get_drvdata(hdev);\n\tif (arvo->roccat_claimed)\n\t\troccat_disconnect(arvo->chrdev_minor);\n\tkfree(arvo);\n}\n\nstatic int arvo_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint retval;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (retval) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tretval = arvo_init_specials(hdev);\n\tif (retval) {\n\t\thid_err(hdev, \"couldn't install keyboard\\n\");\n\t\tgoto exit_stop;\n\t}\n\n\treturn 0;\n\nexit_stop:\n\thid_hw_stop(hdev);\nexit:\n\treturn retval;\n}\n\nstatic void arvo_remove(struct hid_device *hdev)\n{\n\tarvo_remove_specials(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic void arvo_report_to_chrdev(struct arvo_device const *arvo,\n\t\tu8 const *data)\n{\n\tstruct arvo_special_report const *special_report;\n\tstruct arvo_roccat_report roccat_report;\n\n\tspecial_report = (struct arvo_special_report const *)data;\n\n\troccat_report.profile = arvo->actual_profile;\n\troccat_report.button = special_report->event &\n\t\t\tARVO_SPECIAL_REPORT_EVENT_MASK_BUTTON;\n\tif ((special_report->event & ARVO_SPECIAL_REPORT_EVENT_MASK_ACTION) ==\n\t\t\tARVO_SPECIAL_REPORT_EVENT_ACTION_PRESS)\n\t\troccat_report.action = ARVO_ROCCAT_REPORT_ACTION_PRESS;\n\telse\n\t\troccat_report.action = ARVO_ROCCAT_REPORT_ACTION_RELEASE;\n\n\troccat_report_event(arvo->chrdev_minor,\n\t\t\t(uint8_t const *)&roccat_report);\n}\n\nstatic int arvo_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct arvo_device *arvo = hid_get_drvdata(hdev);\n\n\tif (size != 3)\n\t\treturn 0;\n\n\tif (arvo && arvo->roccat_claimed)\n\t\tarvo_report_to_chrdev(arvo, data);\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id arvo_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ARVO) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(hid, arvo_devices);\n\nstatic struct hid_driver arvo_driver = {\n\t.name = \"arvo\",\n\t.id_table = arvo_devices,\n\t.probe = arvo_probe,\n\t.remove = arvo_remove,\n\t.raw_event = arvo_raw_event\n};\n\nstatic int __init arvo_init(void)\n{\n\tint retval;\n\n\tretval = class_register(&arvo_class);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = hid_register_driver(&arvo_driver);\n\tif (retval)\n\t\tclass_unregister(&arvo_class);\n\treturn retval;\n}\n\nstatic void __exit arvo_exit(void)\n{\n\thid_unregister_driver(&arvo_driver);\n\tclass_unregister(&arvo_class);\n}\n\nmodule_init(arvo_init);\nmodule_exit(arvo_exit);\n\nMODULE_AUTHOR(\"Stefan Achatz\");\nMODULE_DESCRIPTION(\"USB Roccat Arvo driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}