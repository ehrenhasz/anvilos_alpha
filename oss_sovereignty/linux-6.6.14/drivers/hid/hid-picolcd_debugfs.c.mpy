{
  "module_name": "hid-picolcd_debugfs.c",
  "hash_id": "480e38fc51f8010e206a1543d33a6116af8617c7aabe080886dc399cee6ec8e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-picolcd_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/hid-debug.h>\n\n#include <linux/fb.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#include \"hid-picolcd.h\"\n\n\nstatic int picolcd_debug_reset_show(struct seq_file *f, void *p)\n{\n\tif (picolcd_fbinfo((struct picolcd_data *)f->private))\n\t\tseq_printf(f, \"all fb\\n\");\n\telse\n\t\tseq_printf(f, \"all\\n\");\n\treturn 0;\n}\n\nstatic int picolcd_debug_reset_open(struct inode *inode, struct file *f)\n{\n\treturn single_open(f, picolcd_debug_reset_show, inode->i_private);\n}\n\nstatic ssize_t picolcd_debug_reset_write(struct file *f, const char __user *user_buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct picolcd_data *data = ((struct seq_file *)f->private_data)->private;\n\tchar buf[32];\n\tsize_t cnt = min(count, sizeof(buf)-1);\n\tif (copy_from_user(buf, user_buf, cnt))\n\t\treturn -EFAULT;\n\n\twhile (cnt > 0 && (buf[cnt-1] == ' ' || buf[cnt-1] == '\\n'))\n\t\tcnt--;\n\tbuf[cnt] = '\\0';\n\tif (strcmp(buf, \"all\") == 0) {\n\t\tpicolcd_reset(data->hdev);\n\t\tpicolcd_fb_reset(data, 1);\n\t} else if (strcmp(buf, \"fb\") == 0) {\n\t\tpicolcd_fb_reset(data, 1);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations picolcd_debug_reset_fops = {\n\t.owner    = THIS_MODULE,\n\t.open     = picolcd_debug_reset_open,\n\t.read     = seq_read,\n\t.llseek   = seq_lseek,\n\t.write    = picolcd_debug_reset_write,\n\t.release  = single_release,\n};\n\n \nstatic ssize_t picolcd_debug_eeprom_read(struct file *f, char __user *u,\n\t\tsize_t s, loff_t *off)\n{\n\tstruct picolcd_data *data = f->private_data;\n\tstruct picolcd_pending *resp;\n\tu8 raw_data[3];\n\tssize_t ret = -EIO;\n\n\tif (s == 0)\n\t\treturn -EINVAL;\n\tif (*off > 0x0ff)\n\t\treturn 0;\n\n\t \n\traw_data[0] = *off & 0xff;\n\traw_data[1] = (*off >> 8) & 0xff;\n\traw_data[2] = s < 20 ? s : 20;\n\tif (*off + raw_data[2] > 0xff)\n\t\traw_data[2] = 0x100 - *off;\n\tresp = picolcd_send_and_wait(data->hdev, REPORT_EE_READ, raw_data,\n\t\t\tsizeof(raw_data));\n\tif (!resp)\n\t\treturn -EIO;\n\n\tif (resp->in_report && resp->in_report->id == REPORT_EE_DATA) {\n\t\t \n\t\tret = resp->raw_data[2];\n\t\tif (ret > s)\n\t\t\tret = s;\n\t\tif (copy_to_user(u, resp->raw_data+3, ret))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\t*off += ret;\n\t}  \n\n\tkfree(resp);\n\treturn ret;\n}\n\nstatic ssize_t picolcd_debug_eeprom_write(struct file *f, const char __user *u,\n\t\tsize_t s, loff_t *off)\n{\n\tstruct picolcd_data *data = f->private_data;\n\tstruct picolcd_pending *resp;\n\tssize_t ret = -EIO;\n\tu8 raw_data[23];\n\n\tif (s == 0)\n\t\treturn -EINVAL;\n\tif (*off > 0x0ff)\n\t\treturn -ENOSPC;\n\n\tmemset(raw_data, 0, sizeof(raw_data));\n\traw_data[0] = *off & 0xff;\n\traw_data[1] = (*off >> 8) & 0xff;\n\traw_data[2] = min_t(size_t, 20, s);\n\tif (*off + raw_data[2] > 0xff)\n\t\traw_data[2] = 0x100 - *off;\n\n\tif (copy_from_user(raw_data+3, u, min((u8)20, raw_data[2])))\n\t\treturn -EFAULT;\n\tresp = picolcd_send_and_wait(data->hdev, REPORT_EE_WRITE, raw_data,\n\t\t\tsizeof(raw_data));\n\n\tif (!resp)\n\t\treturn -EIO;\n\n\tif (resp->in_report && resp->in_report->id == REPORT_EE_DATA) {\n\t\t \n\t\tif (memcmp(raw_data, resp->raw_data, 3+raw_data[2]) == 0) {\n\t\t\t*off += raw_data[2];\n\t\t\tret = raw_data[2];\n\t\t}\n\t}\n\tkfree(resp);\n\treturn ret;\n}\n\n \nstatic const struct file_operations picolcd_debug_eeprom_fops = {\n\t.owner    = THIS_MODULE,\n\t.open     = simple_open,\n\t.read     = picolcd_debug_eeprom_read,\n\t.write    = picolcd_debug_eeprom_write,\n\t.llseek   = generic_file_llseek,\n};\n\n \n \nstatic int _picolcd_flash_setaddr(struct picolcd_data *data, u8 *buf, long off)\n{\n\tbuf[0] = off & 0xff;\n\tbuf[1] = (off >> 8) & 0xff;\n\tif (data->addr_sz == 3)\n\t\tbuf[2] = (off >> 16) & 0xff;\n\treturn data->addr_sz == 2 ? 2 : 3;\n}\n\n \nstatic ssize_t _picolcd_flash_read(struct picolcd_data *data, int report_id,\n\t\tchar __user *u, size_t s, loff_t *off)\n{\n\tstruct picolcd_pending *resp;\n\tu8 raw_data[4];\n\tssize_t ret = 0;\n\tint len_off, err = -EIO;\n\n\twhile (s > 0) {\n\t\terr = -EIO;\n\t\tlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\n\t\traw_data[len_off] = s > 32 ? 32 : s;\n\t\tresp = picolcd_send_and_wait(data->hdev, report_id, raw_data, len_off+1);\n\t\tif (!resp || !resp->in_report)\n\t\t\tgoto skip;\n\t\tif (resp->in_report->id == REPORT_MEMORY ||\n\t\t\tresp->in_report->id == REPORT_BL_READ_MEMORY) {\n\t\t\tif (memcmp(raw_data, resp->raw_data, len_off+1) != 0)\n\t\t\t\tgoto skip;\n\t\t\tif (copy_to_user(u+ret, resp->raw_data+len_off+1, raw_data[len_off])) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\t\t*off += raw_data[len_off];\n\t\t\ts    -= raw_data[len_off];\n\t\t\tret  += raw_data[len_off];\n\t\t\terr   = 0;\n\t\t}\nskip:\n\t\tkfree(resp);\n\t\tif (err)\n\t\t\treturn ret > 0 ? ret : err;\n\t}\n\treturn ret;\n}\n\nstatic ssize_t picolcd_debug_flash_read(struct file *f, char __user *u,\n\t\tsize_t s, loff_t *off)\n{\n\tstruct picolcd_data *data = f->private_data;\n\n\tif (s == 0)\n\t\treturn -EINVAL;\n\tif (*off > 0x05fff)\n\t\treturn 0;\n\tif (*off + s > 0x05fff)\n\t\ts = 0x06000 - *off;\n\n\tif (data->status & PICOLCD_BOOTLOADER)\n\t\treturn _picolcd_flash_read(data, REPORT_BL_READ_MEMORY, u, s, off);\n\telse\n\t\treturn _picolcd_flash_read(data, REPORT_READ_MEMORY, u, s, off);\n}\n\n \nstatic ssize_t _picolcd_flash_erase64(struct picolcd_data *data, int report_id,\n\t\tloff_t *off)\n{\n\tstruct picolcd_pending *resp;\n\tu8 raw_data[3];\n\tint len_off;\n\tssize_t ret = -EIO;\n\n\tif (*off & 0x3f)\n\t\treturn -EINVAL;\n\n\tlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\n\tresp = picolcd_send_and_wait(data->hdev, report_id, raw_data, len_off);\n\tif (!resp || !resp->in_report)\n\t\tgoto skip;\n\tif (resp->in_report->id == REPORT_MEMORY ||\n\t\tresp->in_report->id == REPORT_BL_ERASE_MEMORY) {\n\t\tif (memcmp(raw_data, resp->raw_data, len_off) != 0)\n\t\t\tgoto skip;\n\t\tret = 0;\n\t}\nskip:\n\tkfree(resp);\n\treturn ret;\n}\n\n \nstatic ssize_t _picolcd_flash_write(struct picolcd_data *data, int report_id,\n\t\tconst char __user *u, size_t s, loff_t *off)\n{\n\tstruct picolcd_pending *resp;\n\tu8 raw_data[36];\n\tssize_t ret = 0;\n\tint len_off, err = -EIO;\n\n\twhile (s > 0) {\n\t\terr = -EIO;\n\t\tlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\n\t\traw_data[len_off] = s > 32 ? 32 : s;\n\t\tif (copy_from_user(raw_data+len_off+1, u, raw_data[len_off])) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tresp = picolcd_send_and_wait(data->hdev, report_id, raw_data,\n\t\t\t\tlen_off+1+raw_data[len_off]);\n\t\tif (!resp || !resp->in_report)\n\t\t\tgoto skip;\n\t\tif (resp->in_report->id == REPORT_MEMORY ||\n\t\t\tresp->in_report->id == REPORT_BL_WRITE_MEMORY) {\n\t\t\tif (memcmp(raw_data, resp->raw_data, len_off+1+raw_data[len_off]) != 0)\n\t\t\t\tgoto skip;\n\t\t\t*off += raw_data[len_off];\n\t\t\ts    -= raw_data[len_off];\n\t\t\tret  += raw_data[len_off];\n\t\t\terr   = 0;\n\t\t}\nskip:\n\t\tkfree(resp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn ret > 0 ? ret : err;\n}\n\nstatic ssize_t picolcd_debug_flash_write(struct file *f, const char __user *u,\n\t\tsize_t s, loff_t *off)\n{\n\tstruct picolcd_data *data = f->private_data;\n\tssize_t err, ret = 0;\n\tint report_erase, report_write;\n\n\tif (s == 0)\n\t\treturn -EINVAL;\n\tif (*off > 0x5fff)\n\t\treturn -ENOSPC;\n\tif (s & 0x3f)\n\t\treturn -EINVAL;\n\tif (*off & 0x3f)\n\t\treturn -EINVAL;\n\n\tif (data->status & PICOLCD_BOOTLOADER) {\n\t\treport_erase = REPORT_BL_ERASE_MEMORY;\n\t\treport_write = REPORT_BL_WRITE_MEMORY;\n\t} else {\n\t\treport_erase = REPORT_ERASE_MEMORY;\n\t\treport_write = REPORT_WRITE_MEMORY;\n\t}\n\tmutex_lock(&data->mutex_flash);\n\twhile (s > 0) {\n\t\terr = _picolcd_flash_erase64(data, report_erase, off);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = _picolcd_flash_write(data, report_write, u, 64, off);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tret += err;\n\t\t*off += err;\n\t\ts -= err;\n\t\tif (err != 64)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&data->mutex_flash);\n\treturn ret > 0 ? ret : err;\n}\n\n \nstatic const struct file_operations picolcd_debug_flash_fops = {\n\t.owner    = THIS_MODULE,\n\t.open     = simple_open,\n\t.read     = picolcd_debug_flash_read,\n\t.write    = picolcd_debug_flash_write,\n\t.llseek   = generic_file_llseek,\n};\n\n\n \nstatic const char * const error_codes[] = {\n\t\"success\", \"parameter missing\", \"data_missing\", \"block readonly\",\n\t\"block not erasable\", \"block too big\", \"section overflow\",\n\t\"invalid command length\", \"invalid data length\",\n};\n\nstatic void dump_buff_as_hex(char *dst, size_t dst_sz, const u8 *data,\n\t\tconst size_t data_len)\n{\n\tint i, j;\n\tfor (i = j = 0; i < data_len && j + 4 < dst_sz; i++) {\n\t\tdst[j++] = hex_asc[(data[i] >> 4) & 0x0f];\n\t\tdst[j++] = hex_asc[data[i] & 0x0f];\n\t\tdst[j++] = ' ';\n\t}\n\tdst[j]   = '\\0';\n\tif (j > 0)\n\t\tdst[j-1] = '\\n';\n\tif (i < data_len && j > 2)\n\t\tdst[j-2] = dst[j-3] = '.';\n}\n\nvoid picolcd_debug_out_report(struct picolcd_data *data,\n\t\tstruct hid_device *hdev, struct hid_report *report)\n{\n\tu8 *raw_data;\n\tint raw_size = (report->size >> 3) + 1;\n\tchar *buff;\n#define BUFF_SZ 256\n\n\t \n\tif (list_empty(&hdev->debug_list))\n\t\treturn;\n\n\tbuff = kmalloc(BUFF_SZ, GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\traw_data = hid_alloc_report_buf(report, GFP_ATOMIC);\n\tif (!raw_data) {\n\t\tkfree(buff);\n\t\treturn;\n\t}\n\n\tsnprintf(buff, BUFF_SZ, \"\\nout report %d (size %d) =  \",\n\t\t\treport->id, raw_size);\n\thid_debug_event(hdev, buff);\n\traw_data[0] = report->id;\n\thid_output_report(report, raw_data);\n\tdump_buff_as_hex(buff, BUFF_SZ, raw_data, raw_size);\n\thid_debug_event(hdev, buff);\n\n\tswitch (report->id) {\n\tcase REPORT_LED_STATE:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_LED_STATE\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tGPO state: 0x%02x\\n\", raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_BRIGHTNESS:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_BRIGHTNESS\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tBrightness: 0x%02x\\n\", raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_CONTRAST:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_CONTRAST\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tContrast: 0x%02x\\n\", raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_RESET:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_RESET\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tDuration: 0x%02x%02x (%dms)\\n\",\n\t\t\t\traw_data[2], raw_data[1], raw_data[2] << 8 | raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_LCD_CMD:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_LCD_CMD\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\t \n\t\tbreak;\n\tcase REPORT_LCD_DATA:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_LCD_CMD\", report->id, raw_size-1);\n\t\t \n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_LCD_CMD_DATA:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_LCD_CMD\", report->id, raw_size-1);\n\t\t \n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_EE_READ:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_EE_READ\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x\\n\",\n\t\t\t\traw_data[2], raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[3]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_EE_WRITE:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_EE_WRITE\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x\\n\",\n\t\t\t\traw_data[2], raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[3]);\n\t\thid_debug_event(hdev, buff);\n\t\tif (raw_data[3] == 0) {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNo data\\n\");\n\t\t} else if (raw_data[3] + 4 <= raw_size) {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData: \");\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tdump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\n\t\t} else {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData overflowed\\n\");\n\t\t}\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_ERASE_MEMORY:\n\tcase REPORT_BL_ERASE_MEMORY:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_ERASE_MEMORY\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tswitch (data->addr_sz) {\n\t\tcase 2:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tAddress inside 64 byte block: 0x%02x%02x\\n\",\n\t\t\t\t\traw_data[2], raw_data[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tAddress inside 64 byte block: 0x%02x%02x%02x\\n\",\n\t\t\t\t\traw_data[3], raw_data[2], raw_data[1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNot supported\\n\");\n\t\t}\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_READ_MEMORY:\n\tcase REPORT_BL_READ_MEMORY:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_READ_MEMORY\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tswitch (data->addr_sz) {\n\t\tcase 2:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x\\n\",\n\t\t\t\t\traw_data[2], raw_data[1]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[3]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x%02x\\n\",\n\t\t\t\t\traw_data[3], raw_data[2], raw_data[1]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[4]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNot supported\\n\");\n\t\t}\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_WRITE_MEMORY:\n\tcase REPORT_BL_WRITE_MEMORY:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_WRITE_MEMORY\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tswitch (data->addr_sz) {\n\t\tcase 2:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x\\n\",\n\t\t\t\t\traw_data[2], raw_data[1]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[3]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tif (raw_data[3] == 0) {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNo data\\n\");\n\t\t\t} else if (raw_data[3] + 4 <= raw_size) {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData: \");\n\t\t\t\thid_debug_event(hdev, buff);\n\t\t\t\tdump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\n\t\t\t} else {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData overflowed\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x%02x\\n\",\n\t\t\t\t\traw_data[3], raw_data[2], raw_data[1]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[4]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tif (raw_data[4] == 0) {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNo data\\n\");\n\t\t\t} else if (raw_data[4] + 5 <= raw_size) {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData: \");\n\t\t\t\thid_debug_event(hdev, buff);\n\t\t\t\tdump_buff_as_hex(buff, BUFF_SZ, raw_data+5, raw_data[4]);\n\t\t\t} else {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData overflowed\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNot supported\\n\");\n\t\t}\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_SPLASH_RESTART:\n\t\t \n\t\tbreak;\n\tcase REPORT_EXIT_KEYBOARD:\n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_EXIT_KEYBOARD\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tRestart delay: %dms (0x%02x%02x)\\n\",\n\t\t\t\traw_data[1] | (raw_data[2] << 8),\n\t\t\t\traw_data[2], raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_VERSION:\n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_VERSION\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_DEVID:\n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_DEVID\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_SPLASH_SIZE:\n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_SPLASH_SIZE\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_HOOK_VERSION:\n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_HOOK_VERSION\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_EXIT_FLASHER:\n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_VERSION\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tRestart delay: %dms (0x%02x%02x)\\n\",\n\t\t\t\traw_data[1] | (raw_data[2] << 8),\n\t\t\t\traw_data[2], raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(buff, BUFF_SZ, \"out report %s (%d, size=%d)\\n\",\n\t\t\t\"<unknown>\", report->id, raw_size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\t}\n\twake_up_interruptible(&hdev->debug_wait);\n\tkfree(raw_data);\n\tkfree(buff);\n}\n\nvoid picolcd_debug_raw_event(struct picolcd_data *data,\n\t\tstruct hid_device *hdev, struct hid_report *report,\n\t\tu8 *raw_data, int size)\n{\n\tchar *buff;\n\n#define BUFF_SZ 256\n\t \n\tif (list_empty(&hdev->debug_list))\n\t\treturn;\n\n\tbuff = kmalloc(BUFF_SZ, GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\tswitch (report->id) {\n\tcase REPORT_ERROR_CODE:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_ERROR_CODE\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tif (raw_data[2] < ARRAY_SIZE(error_codes))\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tError code 0x%02x (%s) in reply to report 0x%02x\\n\",\n\t\t\t\t\traw_data[2], error_codes[raw_data[2]], raw_data[1]);\n\t\telse\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tError code 0x%02x in reply to report 0x%02x\\n\",\n\t\t\t\t\traw_data[2], raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_KEY_STATE:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_KEY_STATE\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tif (raw_data[1] == 0)\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNo key pressed\\n\");\n\t\telse if (raw_data[2] == 0)\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tOne key pressed: 0x%02x (%d)\\n\",\n\t\t\t\t\traw_data[1], raw_data[1]);\n\t\telse\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tTwo keys pressed: 0x%02x (%d), 0x%02x (%d)\\n\",\n\t\t\t\t\traw_data[1], raw_data[1], raw_data[2], raw_data[2]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_IR_DATA:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_IR_DATA\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tif (raw_data[1] == 0) {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tUnexpectedly 0 data length\\n\");\n\t\t\thid_debug_event(hdev, buff);\n\t\t} else if (raw_data[1] + 1 <= size) {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\\tIR Data: \",\n\t\t\t\t\traw_data[1]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tdump_buff_as_hex(buff, BUFF_SZ, raw_data+2, raw_data[1]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t} else {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tOverflowing data length: %d\\n\",\n\t\t\t\t\traw_data[1]-1);\n\t\t\thid_debug_event(hdev, buff);\n\t\t}\n\t\tbreak;\n\tcase REPORT_EE_DATA:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_EE_DATA\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x\\n\",\n\t\t\t\traw_data[2], raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[3]);\n\t\thid_debug_event(hdev, buff);\n\t\tif (raw_data[3] == 0) {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNo data\\n\");\n\t\t\thid_debug_event(hdev, buff);\n\t\t} else if (raw_data[3] + 4 <= size) {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData: \");\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tdump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t} else {\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData overflowed\\n\");\n\t\t\thid_debug_event(hdev, buff);\n\t\t}\n\t\tbreak;\n\tcase REPORT_MEMORY:\n\t\t \n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_MEMORY\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tswitch (data->addr_sz) {\n\t\tcase 2:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x\\n\",\n\t\t\t\t\traw_data[2], raw_data[1]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[3]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tif (raw_data[3] == 0) {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNo data\\n\");\n\t\t\t} else if (raw_data[3] + 4 <= size) {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData: \");\n\t\t\t\thid_debug_event(hdev, buff);\n\t\t\t\tdump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\n\t\t\t} else {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData overflowed\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData address: 0x%02x%02x%02x\\n\",\n\t\t\t\t\traw_data[3], raw_data[2], raw_data[1]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData length: %d\\n\", raw_data[4]);\n\t\t\thid_debug_event(hdev, buff);\n\t\t\tif (raw_data[4] == 0) {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNo data\\n\");\n\t\t\t} else if (raw_data[4] + 5 <= size) {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData: \");\n\t\t\t\thid_debug_event(hdev, buff);\n\t\t\t\tdump_buff_as_hex(buff, BUFF_SZ, raw_data+5, raw_data[4]);\n\t\t\t} else {\n\t\t\t\tsnprintf(buff, BUFF_SZ, \"\\tData overflowed\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(buff, BUFF_SZ, \"\\tNot supported\\n\");\n\t\t}\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_VERSION:\n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_VERSION\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tFirmware version: %d.%d\\n\",\n\t\t\t\traw_data[2], raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_BL_ERASE_MEMORY:\n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_BL_ERASE_MEMORY\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\t \n\t\tbreak;\n\tcase REPORT_BL_READ_MEMORY:\n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_BL_READ_MEMORY\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\t \n\t\tbreak;\n\tcase REPORT_BL_WRITE_MEMORY:\n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_BL_WRITE_MEMORY\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\t \n\t\tbreak;\n\tcase REPORT_DEVID:\n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_DEVID\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tSerial: 0x%02x%02x%02x%02x\\n\",\n\t\t\t\traw_data[1], raw_data[2], raw_data[3], raw_data[4]);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tType: 0x%02x\\n\",\n\t\t\t\traw_data[5]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_SPLASH_SIZE:\n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_SPLASH_SIZE\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tTotal splash space: %d\\n\",\n\t\t\t\t(raw_data[2] << 8) | raw_data[1]);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tUsed splash space: %d\\n\",\n\t\t\t\t(raw_data[4] << 8) | raw_data[3]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tcase REPORT_HOOK_VERSION:\n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"REPORT_HOOK_VERSION\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tsnprintf(buff, BUFF_SZ, \"\\tFirmware version: %d.%d\\n\",\n\t\t\t\traw_data[1], raw_data[2]);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(buff, BUFF_SZ, \"report %s (%d, size=%d)\\n\",\n\t\t\t\"<unknown>\", report->id, size-1);\n\t\thid_debug_event(hdev, buff);\n\t\tbreak;\n\t}\n\twake_up_interruptible(&hdev->debug_wait);\n\tkfree(buff);\n}\n\nvoid picolcd_init_devfs(struct picolcd_data *data,\n\t\tstruct hid_report *eeprom_r, struct hid_report *eeprom_w,\n\t\tstruct hid_report *flash_r, struct hid_report *flash_w,\n\t\tstruct hid_report *reset)\n{\n\tstruct hid_device *hdev = data->hdev;\n\n\tmutex_init(&data->mutex_flash);\n\n\t \n\tif (reset)\n\t\tdata->debug_reset = debugfs_create_file(\"reset\", 0600,\n\t\t\t\thdev->debug_dir, data, &picolcd_debug_reset_fops);\n\n\t \n\tif (eeprom_r || eeprom_w)\n\t\tdata->debug_eeprom = debugfs_create_file(\"eeprom\",\n\t\t\t(eeprom_w ? S_IWUSR : 0) | (eeprom_r ? S_IRUSR : 0),\n\t\t\thdev->debug_dir, data, &picolcd_debug_eeprom_fops);\n\n\t \n\tif (flash_r && flash_r->maxfield == 1 && flash_r->field[0]->report_size == 8)\n\t\tdata->addr_sz = flash_r->field[0]->report_count - 1;\n\telse\n\t\tdata->addr_sz = -1;\n\tif (data->addr_sz == 2 || data->addr_sz == 3) {\n\t\tdata->debug_flash = debugfs_create_file(\"flash\",\n\t\t\t(flash_w ? S_IWUSR : 0) | (flash_r ? S_IRUSR : 0),\n\t\t\thdev->debug_dir, data, &picolcd_debug_flash_fops);\n\t} else if (flash_r || flash_w)\n\t\thid_warn(hdev, \"Unexpected FLASH access reports, please submit rdesc for review\\n\");\n}\n\nvoid picolcd_exit_devfs(struct picolcd_data *data)\n{\n\tstruct dentry *dent;\n\n\tdent = data->debug_reset;\n\tdata->debug_reset = NULL;\n\tdebugfs_remove(dent);\n\tdent = data->debug_eeprom;\n\tdata->debug_eeprom = NULL;\n\tdebugfs_remove(dent);\n\tdent = data->debug_flash;\n\tdata->debug_flash = NULL;\n\tdebugfs_remove(dent);\n\tmutex_destroy(&data->mutex_flash);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}