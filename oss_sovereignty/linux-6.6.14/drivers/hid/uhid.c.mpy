{
  "module_name": "uhid.c",
  "hash_id": "2cec9b293d3187bdd39e1f0e55be854972994b0e0fa6adffab5c137eae01fb99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/uhid.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/atomic.h>\n#include <linux/compat.h>\n#include <linux/cred.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/uhid.h>\n#include <linux/wait.h>\n\n#define UHID_NAME\t\"uhid\"\n#define UHID_BUFSIZE\t32\n\nstruct uhid_device {\n\tstruct mutex devlock;\n\n\t \n\tbool running;\n\n\t__u8 *rd_data;\n\tuint rd_size;\n\n\t \n\tstruct hid_device *hid;\n\tstruct uhid_event input_buf;\n\n\twait_queue_head_t waitq;\n\tspinlock_t qlock;\n\t__u8 head;\n\t__u8 tail;\n\tstruct uhid_event *outq[UHID_BUFSIZE];\n\n\t \n\tstruct mutex report_lock;\n\twait_queue_head_t report_wait;\n\tbool report_running;\n\tu32 report_id;\n\tu32 report_type;\n\tstruct uhid_event report_buf;\n\tstruct work_struct worker;\n};\n\nstatic struct miscdevice uhid_misc;\n\nstatic void uhid_device_add_worker(struct work_struct *work)\n{\n\tstruct uhid_device *uhid = container_of(work, struct uhid_device, worker);\n\tint ret;\n\n\tret = hid_add_device(uhid->hid);\n\tif (ret) {\n\t\thid_err(uhid->hid, \"Cannot register HID device: error %d\\n\", ret);\n\n\t\t \n\t\tWRITE_ONCE(uhid->running, false);\n\t\twake_up_interruptible(&uhid->report_wait);\n\t}\n}\n\nstatic void uhid_queue(struct uhid_device *uhid, struct uhid_event *ev)\n{\n\t__u8 newhead;\n\n\tnewhead = (uhid->head + 1) % UHID_BUFSIZE;\n\n\tif (newhead != uhid->tail) {\n\t\tuhid->outq[uhid->head] = ev;\n\t\tuhid->head = newhead;\n\t\twake_up_interruptible(&uhid->waitq);\n\t} else {\n\t\thid_warn(uhid->hid, \"Output queue is full\\n\");\n\t\tkfree(ev);\n\t}\n}\n\nstatic int uhid_queue_event(struct uhid_device *uhid, __u32 event)\n{\n\tunsigned long flags;\n\tstruct uhid_event *ev;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev)\n\t\treturn -ENOMEM;\n\n\tev->type = event;\n\n\tspin_lock_irqsave(&uhid->qlock, flags);\n\tuhid_queue(uhid, ev);\n\tspin_unlock_irqrestore(&uhid->qlock, flags);\n\n\treturn 0;\n}\n\nstatic int uhid_hid_start(struct hid_device *hid)\n{\n\tstruct uhid_device *uhid = hid->driver_data;\n\tstruct uhid_event *ev;\n\tunsigned long flags;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev)\n\t\treturn -ENOMEM;\n\n\tev->type = UHID_START;\n\n\tif (hid->report_enum[HID_FEATURE_REPORT].numbered)\n\t\tev->u.start.dev_flags |= UHID_DEV_NUMBERED_FEATURE_REPORTS;\n\tif (hid->report_enum[HID_OUTPUT_REPORT].numbered)\n\t\tev->u.start.dev_flags |= UHID_DEV_NUMBERED_OUTPUT_REPORTS;\n\tif (hid->report_enum[HID_INPUT_REPORT].numbered)\n\t\tev->u.start.dev_flags |= UHID_DEV_NUMBERED_INPUT_REPORTS;\n\n\tspin_lock_irqsave(&uhid->qlock, flags);\n\tuhid_queue(uhid, ev);\n\tspin_unlock_irqrestore(&uhid->qlock, flags);\n\n\treturn 0;\n}\n\nstatic void uhid_hid_stop(struct hid_device *hid)\n{\n\tstruct uhid_device *uhid = hid->driver_data;\n\n\thid->claimed = 0;\n\tuhid_queue_event(uhid, UHID_STOP);\n}\n\nstatic int uhid_hid_open(struct hid_device *hid)\n{\n\tstruct uhid_device *uhid = hid->driver_data;\n\n\treturn uhid_queue_event(uhid, UHID_OPEN);\n}\n\nstatic void uhid_hid_close(struct hid_device *hid)\n{\n\tstruct uhid_device *uhid = hid->driver_data;\n\n\tuhid_queue_event(uhid, UHID_CLOSE);\n}\n\nstatic int uhid_hid_parse(struct hid_device *hid)\n{\n\tstruct uhid_device *uhid = hid->driver_data;\n\n\treturn hid_parse_report(hid, uhid->rd_data, uhid->rd_size);\n}\n\n \nstatic int __uhid_report_queue_and_wait(struct uhid_device *uhid,\n\t\t\t\t\tstruct uhid_event *ev,\n\t\t\t\t\t__u32 *report_id)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&uhid->qlock, flags);\n\t*report_id = ++uhid->report_id;\n\tuhid->report_type = ev->type + 1;\n\tuhid->report_running = true;\n\tuhid_queue(uhid, ev);\n\tspin_unlock_irqrestore(&uhid->qlock, flags);\n\n\tret = wait_event_interruptible_timeout(uhid->report_wait,\n\t\t\t\t!uhid->report_running || !READ_ONCE(uhid->running),\n\t\t\t\t5 * HZ);\n\tif (!ret || !READ_ONCE(uhid->running) || uhid->report_running)\n\t\tret = -EIO;\n\telse if (ret < 0)\n\t\tret = -ERESTARTSYS;\n\telse\n\t\tret = 0;\n\n\tuhid->report_running = false;\n\n\treturn ret;\n}\n\nstatic void uhid_report_wake_up(struct uhid_device *uhid, u32 id,\n\t\t\t\tconst struct uhid_event *ev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uhid->qlock, flags);\n\n\t \n\tif (uhid->report_type != ev->type || uhid->report_id != id)\n\t\tgoto unlock;\n\tif (!uhid->report_running)\n\t\tgoto unlock;\n\n\tmemcpy(&uhid->report_buf, ev, sizeof(*ev));\n\tuhid->report_running = false;\n\twake_up_interruptible(&uhid->report_wait);\n\nunlock:\n\tspin_unlock_irqrestore(&uhid->qlock, flags);\n}\n\nstatic int uhid_hid_get_report(struct hid_device *hid, unsigned char rnum,\n\t\t\t       u8 *buf, size_t count, u8 rtype)\n{\n\tstruct uhid_device *uhid = hid->driver_data;\n\tstruct uhid_get_report_reply_req *req;\n\tstruct uhid_event *ev;\n\tint ret;\n\n\tif (!READ_ONCE(uhid->running))\n\t\treturn -EIO;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev)\n\t\treturn -ENOMEM;\n\n\tev->type = UHID_GET_REPORT;\n\tev->u.get_report.rnum = rnum;\n\tev->u.get_report.rtype = rtype;\n\n\tret = mutex_lock_interruptible(&uhid->report_lock);\n\tif (ret) {\n\t\tkfree(ev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = __uhid_report_queue_and_wait(uhid, ev, &ev->u.get_report.id);\n\tif (ret)\n\t\tgoto unlock;\n\n\treq = &uhid->report_buf.u.get_report_reply;\n\tif (req->err) {\n\t\tret = -EIO;\n\t} else {\n\t\tret = min3(count, (size_t)req->size, (size_t)UHID_DATA_MAX);\n\t\tmemcpy(buf, req->data, ret);\n\t}\n\nunlock:\n\tmutex_unlock(&uhid->report_lock);\n\treturn ret;\n}\n\nstatic int uhid_hid_set_report(struct hid_device *hid, unsigned char rnum,\n\t\t\t       const u8 *buf, size_t count, u8 rtype)\n{\n\tstruct uhid_device *uhid = hid->driver_data;\n\tstruct uhid_event *ev;\n\tint ret;\n\n\tif (!READ_ONCE(uhid->running) || count > UHID_DATA_MAX)\n\t\treturn -EIO;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev)\n\t\treturn -ENOMEM;\n\n\tev->type = UHID_SET_REPORT;\n\tev->u.set_report.rnum = rnum;\n\tev->u.set_report.rtype = rtype;\n\tev->u.set_report.size = count;\n\tmemcpy(ev->u.set_report.data, buf, count);\n\n\tret = mutex_lock_interruptible(&uhid->report_lock);\n\tif (ret) {\n\t\tkfree(ev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = __uhid_report_queue_and_wait(uhid, ev, &ev->u.set_report.id);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (uhid->report_buf.u.set_report_reply.err)\n\t\tret = -EIO;\n\telse\n\t\tret = count;\n\nunlock:\n\tmutex_unlock(&uhid->report_lock);\n\treturn ret;\n}\n\nstatic int uhid_hid_raw_request(struct hid_device *hid, unsigned char reportnum,\n\t\t\t\t__u8 *buf, size_t len, unsigned char rtype,\n\t\t\t\tint reqtype)\n{\n\tu8 u_rtype;\n\n\tswitch (rtype) {\n\tcase HID_FEATURE_REPORT:\n\t\tu_rtype = UHID_FEATURE_REPORT;\n\t\tbreak;\n\tcase HID_OUTPUT_REPORT:\n\t\tu_rtype = UHID_OUTPUT_REPORT;\n\t\tbreak;\n\tcase HID_INPUT_REPORT:\n\t\tu_rtype = UHID_INPUT_REPORT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\treturn uhid_hid_get_report(hid, reportnum, buf, len, u_rtype);\n\tcase HID_REQ_SET_REPORT:\n\t\treturn uhid_hid_set_report(hid, reportnum, buf, len, u_rtype);\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int uhid_hid_output_raw(struct hid_device *hid, __u8 *buf, size_t count,\n\t\t\t       unsigned char report_type)\n{\n\tstruct uhid_device *uhid = hid->driver_data;\n\t__u8 rtype;\n\tunsigned long flags;\n\tstruct uhid_event *ev;\n\n\tswitch (report_type) {\n\tcase HID_FEATURE_REPORT:\n\t\trtype = UHID_FEATURE_REPORT;\n\t\tbreak;\n\tcase HID_OUTPUT_REPORT:\n\t\trtype = UHID_OUTPUT_REPORT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (count < 1 || count > UHID_DATA_MAX)\n\t\treturn -EINVAL;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev)\n\t\treturn -ENOMEM;\n\n\tev->type = UHID_OUTPUT;\n\tev->u.output.size = count;\n\tev->u.output.rtype = rtype;\n\tmemcpy(ev->u.output.data, buf, count);\n\n\tspin_lock_irqsave(&uhid->qlock, flags);\n\tuhid_queue(uhid, ev);\n\tspin_unlock_irqrestore(&uhid->qlock, flags);\n\n\treturn count;\n}\n\nstatic int uhid_hid_output_report(struct hid_device *hid, __u8 *buf,\n\t\t\t\t  size_t count)\n{\n\treturn uhid_hid_output_raw(hid, buf, count, HID_OUTPUT_REPORT);\n}\n\nstatic const struct hid_ll_driver uhid_hid_driver = {\n\t.start = uhid_hid_start,\n\t.stop = uhid_hid_stop,\n\t.open = uhid_hid_open,\n\t.close = uhid_hid_close,\n\t.parse = uhid_hid_parse,\n\t.raw_request = uhid_hid_raw_request,\n\t.output_report = uhid_hid_output_report,\n\t.max_buffer_size = UHID_DATA_MAX,\n};\n\n#ifdef CONFIG_COMPAT\n\n \nstruct uhid_create_req_compat {\n\t__u8 name[128];\n\t__u8 phys[64];\n\t__u8 uniq[64];\n\n\tcompat_uptr_t rd_data;\n\t__u16 rd_size;\n\n\t__u16 bus;\n\t__u32 vendor;\n\t__u32 product;\n\t__u32 version;\n\t__u32 country;\n} __attribute__((__packed__));\n\nstatic int uhid_event_from_user(const char __user *buffer, size_t len,\n\t\t\t\tstruct uhid_event *event)\n{\n\tif (in_compat_syscall()) {\n\t\tu32 type;\n\n\t\tif (get_user(type, buffer))\n\t\t\treturn -EFAULT;\n\n\t\tif (type == UHID_CREATE) {\n\t\t\t \n\t\t\tstruct uhid_create_req_compat *compat;\n\n\t\t\tcompat = kzalloc(sizeof(*compat), GFP_KERNEL);\n\t\t\tif (!compat)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbuffer += sizeof(type);\n\t\t\tlen -= sizeof(type);\n\t\t\tif (copy_from_user(compat, buffer,\n\t\t\t\t\t   min(len, sizeof(*compat)))) {\n\t\t\t\tkfree(compat);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\t \n\t\t\tevent->type = type;\n\n\t\t\tmemcpy(event->u.create.name, compat->name,\n\t\t\t\tsizeof(compat->name));\n\t\t\tmemcpy(event->u.create.phys, compat->phys,\n\t\t\t\tsizeof(compat->phys));\n\t\t\tmemcpy(event->u.create.uniq, compat->uniq,\n\t\t\t\tsizeof(compat->uniq));\n\n\t\t\tevent->u.create.rd_data = compat_ptr(compat->rd_data);\n\t\t\tevent->u.create.rd_size = compat->rd_size;\n\n\t\t\tevent->u.create.bus = compat->bus;\n\t\t\tevent->u.create.vendor = compat->vendor;\n\t\t\tevent->u.create.product = compat->product;\n\t\t\tevent->u.create.version = compat->version;\n\t\t\tevent->u.create.country = compat->country;\n\n\t\t\tkfree(compat);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t}\n\n\tif (copy_from_user(event, buffer, min(len, sizeof(*event))))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#else\nstatic int uhid_event_from_user(const char __user *buffer, size_t len,\n\t\t\t\tstruct uhid_event *event)\n{\n\tif (copy_from_user(event, buffer, min(len, sizeof(*event))))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n#endif\n\nstatic int uhid_dev_create2(struct uhid_device *uhid,\n\t\t\t    const struct uhid_event *ev)\n{\n\tstruct hid_device *hid;\n\tsize_t rd_size, len;\n\tvoid *rd_data;\n\tint ret;\n\n\tif (uhid->hid)\n\t\treturn -EALREADY;\n\n\trd_size = ev->u.create2.rd_size;\n\tif (rd_size <= 0 || rd_size > HID_MAX_DESCRIPTOR_SIZE)\n\t\treturn -EINVAL;\n\n\trd_data = kmemdup(ev->u.create2.rd_data, rd_size, GFP_KERNEL);\n\tif (!rd_data)\n\t\treturn -ENOMEM;\n\n\tuhid->rd_size = rd_size;\n\tuhid->rd_data = rd_data;\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\tret = PTR_ERR(hid);\n\t\tgoto err_free;\n\t}\n\n\t \n\tlen = min(sizeof(hid->name), sizeof(ev->u.create2.name)) - 1;\n\tstrncpy(hid->name, ev->u.create2.name, len);\n\tlen = min(sizeof(hid->phys), sizeof(ev->u.create2.phys)) - 1;\n\tstrncpy(hid->phys, ev->u.create2.phys, len);\n\tlen = min(sizeof(hid->uniq), sizeof(ev->u.create2.uniq)) - 1;\n\tstrncpy(hid->uniq, ev->u.create2.uniq, len);\n\n\thid->ll_driver = &uhid_hid_driver;\n\thid->bus = ev->u.create2.bus;\n\thid->vendor = ev->u.create2.vendor;\n\thid->product = ev->u.create2.product;\n\thid->version = ev->u.create2.version;\n\thid->country = ev->u.create2.country;\n\thid->driver_data = uhid;\n\thid->dev.parent = uhid_misc.this_device;\n\n\tuhid->hid = hid;\n\tuhid->running = true;\n\n\t \n\tschedule_work(&uhid->worker);\n\n\treturn 0;\n\nerr_free:\n\tkfree(uhid->rd_data);\n\tuhid->rd_data = NULL;\n\tuhid->rd_size = 0;\n\treturn ret;\n}\n\nstatic int uhid_dev_create(struct uhid_device *uhid,\n\t\t\t   struct uhid_event *ev)\n{\n\tstruct uhid_create_req orig;\n\n\torig = ev->u.create;\n\n\tif (orig.rd_size <= 0 || orig.rd_size > HID_MAX_DESCRIPTOR_SIZE)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&ev->u.create2.rd_data, orig.rd_data, orig.rd_size))\n\t\treturn -EFAULT;\n\n\tmemcpy(ev->u.create2.name, orig.name, sizeof(orig.name));\n\tmemcpy(ev->u.create2.phys, orig.phys, sizeof(orig.phys));\n\tmemcpy(ev->u.create2.uniq, orig.uniq, sizeof(orig.uniq));\n\tev->u.create2.rd_size = orig.rd_size;\n\tev->u.create2.bus = orig.bus;\n\tev->u.create2.vendor = orig.vendor;\n\tev->u.create2.product = orig.product;\n\tev->u.create2.version = orig.version;\n\tev->u.create2.country = orig.country;\n\n\treturn uhid_dev_create2(uhid, ev);\n}\n\nstatic int uhid_dev_destroy(struct uhid_device *uhid)\n{\n\tif (!uhid->hid)\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(uhid->running, false);\n\twake_up_interruptible(&uhid->report_wait);\n\n\tcancel_work_sync(&uhid->worker);\n\n\thid_destroy_device(uhid->hid);\n\tuhid->hid = NULL;\n\tkfree(uhid->rd_data);\n\n\treturn 0;\n}\n\nstatic int uhid_dev_input(struct uhid_device *uhid, struct uhid_event *ev)\n{\n\tif (!READ_ONCE(uhid->running))\n\t\treturn -EINVAL;\n\n\thid_input_report(uhid->hid, HID_INPUT_REPORT, ev->u.input.data,\n\t\t\t min_t(size_t, ev->u.input.size, UHID_DATA_MAX), 0);\n\n\treturn 0;\n}\n\nstatic int uhid_dev_input2(struct uhid_device *uhid, struct uhid_event *ev)\n{\n\tif (!READ_ONCE(uhid->running))\n\t\treturn -EINVAL;\n\n\thid_input_report(uhid->hid, HID_INPUT_REPORT, ev->u.input2.data,\n\t\t\t min_t(size_t, ev->u.input2.size, UHID_DATA_MAX), 0);\n\n\treturn 0;\n}\n\nstatic int uhid_dev_get_report_reply(struct uhid_device *uhid,\n\t\t\t\t     struct uhid_event *ev)\n{\n\tif (!READ_ONCE(uhid->running))\n\t\treturn -EINVAL;\n\n\tuhid_report_wake_up(uhid, ev->u.get_report_reply.id, ev);\n\treturn 0;\n}\n\nstatic int uhid_dev_set_report_reply(struct uhid_device *uhid,\n\t\t\t\t     struct uhid_event *ev)\n{\n\tif (!READ_ONCE(uhid->running))\n\t\treturn -EINVAL;\n\n\tuhid_report_wake_up(uhid, ev->u.set_report_reply.id, ev);\n\treturn 0;\n}\n\nstatic int uhid_char_open(struct inode *inode, struct file *file)\n{\n\tstruct uhid_device *uhid;\n\n\tuhid = kzalloc(sizeof(*uhid), GFP_KERNEL);\n\tif (!uhid)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&uhid->devlock);\n\tmutex_init(&uhid->report_lock);\n\tspin_lock_init(&uhid->qlock);\n\tinit_waitqueue_head(&uhid->waitq);\n\tinit_waitqueue_head(&uhid->report_wait);\n\tuhid->running = false;\n\tINIT_WORK(&uhid->worker, uhid_device_add_worker);\n\n\tfile->private_data = uhid;\n\tstream_open(inode, file);\n\n\treturn 0;\n}\n\nstatic int uhid_char_release(struct inode *inode, struct file *file)\n{\n\tstruct uhid_device *uhid = file->private_data;\n\tunsigned int i;\n\n\tuhid_dev_destroy(uhid);\n\n\tfor (i = 0; i < UHID_BUFSIZE; ++i)\n\t\tkfree(uhid->outq[i]);\n\n\tkfree(uhid);\n\n\treturn 0;\n}\n\nstatic ssize_t uhid_char_read(struct file *file, char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct uhid_device *uhid = file->private_data;\n\tint ret;\n\tunsigned long flags;\n\tsize_t len;\n\n\t \n\tif (count < sizeof(__u32))\n\t\treturn -EINVAL;\n\ntry_again:\n\tif (file->f_flags & O_NONBLOCK) {\n\t\tif (uhid->head == uhid->tail)\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tret = wait_event_interruptible(uhid->waitq,\n\t\t\t\t\t\tuhid->head != uhid->tail);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mutex_lock_interruptible(&uhid->devlock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (uhid->head == uhid->tail) {\n\t\tmutex_unlock(&uhid->devlock);\n\t\tgoto try_again;\n\t} else {\n\t\tlen = min(count, sizeof(**uhid->outq));\n\t\tif (copy_to_user(buffer, uhid->outq[uhid->tail], len)) {\n\t\t\tret = -EFAULT;\n\t\t} else {\n\t\t\tkfree(uhid->outq[uhid->tail]);\n\t\t\tuhid->outq[uhid->tail] = NULL;\n\n\t\t\tspin_lock_irqsave(&uhid->qlock, flags);\n\t\t\tuhid->tail = (uhid->tail + 1) % UHID_BUFSIZE;\n\t\t\tspin_unlock_irqrestore(&uhid->qlock, flags);\n\t\t}\n\t}\n\n\tmutex_unlock(&uhid->devlock);\n\treturn ret ? ret : len;\n}\n\nstatic ssize_t uhid_char_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct uhid_device *uhid = file->private_data;\n\tint ret;\n\tsize_t len;\n\n\t \n\tif (count < sizeof(__u32))\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&uhid->devlock);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&uhid->input_buf, 0, sizeof(uhid->input_buf));\n\tlen = min(count, sizeof(uhid->input_buf));\n\n\tret = uhid_event_from_user(buffer, len, &uhid->input_buf);\n\tif (ret)\n\t\tgoto unlock;\n\n\tswitch (uhid->input_buf.type) {\n\tcase UHID_CREATE:\n\t\t \n\t\tif (file->f_cred != current_cred()) {\n\t\t\tpr_err_once(\"UHID_CREATE from different security context by process %d (%s), this is not allowed.\\n\",\n\t\t\t\t    task_tgid_vnr(current), current->comm);\n\t\t\tret = -EACCES;\n\t\t\tgoto unlock;\n\t\t}\n\t\tret = uhid_dev_create(uhid, &uhid->input_buf);\n\t\tbreak;\n\tcase UHID_CREATE2:\n\t\tret = uhid_dev_create2(uhid, &uhid->input_buf);\n\t\tbreak;\n\tcase UHID_DESTROY:\n\t\tret = uhid_dev_destroy(uhid);\n\t\tbreak;\n\tcase UHID_INPUT:\n\t\tret = uhid_dev_input(uhid, &uhid->input_buf);\n\t\tbreak;\n\tcase UHID_INPUT2:\n\t\tret = uhid_dev_input2(uhid, &uhid->input_buf);\n\t\tbreak;\n\tcase UHID_GET_REPORT_REPLY:\n\t\tret = uhid_dev_get_report_reply(uhid, &uhid->input_buf);\n\t\tbreak;\n\tcase UHID_SET_REPORT_REPLY:\n\t\tret = uhid_dev_set_report_reply(uhid, &uhid->input_buf);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\nunlock:\n\tmutex_unlock(&uhid->devlock);\n\n\t \n\treturn ret ? ret : count;\n}\n\nstatic __poll_t uhid_char_poll(struct file *file, poll_table *wait)\n{\n\tstruct uhid_device *uhid = file->private_data;\n\t__poll_t mask = EPOLLOUT | EPOLLWRNORM;  \n\n\tpoll_wait(file, &uhid->waitq, wait);\n\n\tif (uhid->head != uhid->tail)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic const struct file_operations uhid_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= uhid_char_open,\n\t.release\t= uhid_char_release,\n\t.read\t\t= uhid_char_read,\n\t.write\t\t= uhid_char_write,\n\t.poll\t\t= uhid_char_poll,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice uhid_misc = {\n\t.fops\t\t= &uhid_fops,\n\t.minor\t\t= UHID_MINOR,\n\t.name\t\t= UHID_NAME,\n};\nmodule_misc_device(uhid_misc);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Herrmann <dh.herrmann@gmail.com>\");\nMODULE_DESCRIPTION(\"User-space I/O driver support for HID subsystem\");\nMODULE_ALIAS_MISCDEV(UHID_MINOR);\nMODULE_ALIAS(\"devname:\" UHID_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}