{
  "module_name": "hid-a4tech.c",
  "hash_id": "d10197f5aee785af1f752a62c230602742657d547074686e3d5362923ff1b0ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-a4tech.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"hid-ids.h\"\n\n#define A4_2WHEEL_MOUSE_HACK_7\t0x01\n#define A4_2WHEEL_MOUSE_HACK_B8\t0x02\n\n#define A4_WHEEL_ORIENTATION\t(HID_UP_GENDESK | 0x000000b8)\n\nstruct a4tech_sc {\n\tunsigned long quirks;\n\tunsigned int hw_wheel;\n\t__s32 delayed_value;\n};\n\nstatic int a4_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t    struct hid_field *field, struct hid_usage *usage,\n\t\t\t    unsigned long **bit, int *max)\n{\n\tstruct a4tech_sc *a4 = hid_get_drvdata(hdev);\n\n\tif (a4->quirks & A4_2WHEEL_MOUSE_HACK_B8 &&\n\t    usage->hid == A4_WHEEL_ORIENTATION) {\n\t\t \n\t\treturn -1;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int a4_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct a4tech_sc *a4 = hid_get_drvdata(hdev);\n\n\tif (usage->type == EV_REL && usage->code == REL_WHEEL_HI_RES) {\n\t\tset_bit(REL_HWHEEL, *bit);\n\t\tset_bit(REL_HWHEEL_HI_RES, *bit);\n\t}\n\n\tif ((a4->quirks & A4_2WHEEL_MOUSE_HACK_7) && usage->hid == 0x00090007)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int a4_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct a4tech_sc *a4 = hid_get_drvdata(hdev);\n\tstruct input_dev *input;\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput)\n\t\treturn 0;\n\n\tinput = field->hidinput->input;\n\n\tif (a4->quirks & A4_2WHEEL_MOUSE_HACK_B8) {\n\t\tif (usage->type == EV_REL && usage->code == REL_WHEEL_HI_RES) {\n\t\t\ta4->delayed_value = value;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (usage->hid == A4_WHEEL_ORIENTATION) {\n\t\t\tinput_event(input, EV_REL, value ? REL_HWHEEL :\n\t\t\t\t\tREL_WHEEL, a4->delayed_value);\n\t\t\tinput_event(input, EV_REL, value ? REL_HWHEEL_HI_RES :\n\t\t\t\t\tREL_WHEEL_HI_RES, a4->delayed_value * 120);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif ((a4->quirks & A4_2WHEEL_MOUSE_HACK_7) && usage->hid == 0x00090007) {\n\t\ta4->hw_wheel = !!value;\n\t\treturn 1;\n\t}\n\n\tif (usage->code == REL_WHEEL_HI_RES && a4->hw_wheel) {\n\t\tinput_event(input, usage->type, REL_HWHEEL, value);\n\t\tinput_event(input, usage->type, REL_HWHEEL_HI_RES, value * 120);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int a4_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct a4tech_sc *a4;\n\tint ret;\n\n\ta4 = devm_kzalloc(&hdev->dev, sizeof(*a4), GFP_KERNEL);\n\tif (a4 == NULL) {\n\t\thid_err(hdev, \"can't alloc device descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ta4->quirks = id->driver_data;\n\n\thid_set_drvdata(hdev, a4);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id a4_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU),\n\t\t.driver_data = A4_2WHEEL_MOUSE_HACK_7 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_X5_005D),\n\t\t.driver_data = A4_2WHEEL_MOUSE_HACK_B8 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_RP_649),\n\t\t.driver_data = A4_2WHEEL_MOUSE_HACK_B8 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_NB_95),\n\t\t.driver_data = A4_2WHEEL_MOUSE_HACK_B8 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, a4_devices);\n\nstatic struct hid_driver a4_driver = {\n\t.name = \"a4tech\",\n\t.id_table = a4_devices,\n\t.input_mapping = a4_input_mapping,\n\t.input_mapped = a4_input_mapped,\n\t.event = a4_event,\n\t.probe = a4_probe,\n};\nmodule_hid_driver(a4_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}