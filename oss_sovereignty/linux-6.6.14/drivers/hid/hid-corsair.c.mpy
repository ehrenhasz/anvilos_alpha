{
  "module_name": "hid-corsair.c",
  "hash_id": "35477de96e59cdeaf0bdea159f10259e7eec474b0e99115a75abe3f1a223e52c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-corsair.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/leds.h>\n\n#include \"hid-ids.h\"\n\n#define CORSAIR_USE_K90_MACRO\t(1<<0)\n#define CORSAIR_USE_K90_BACKLIGHT\t(1<<1)\n\nstruct k90_led {\n\tstruct led_classdev cdev;\n\tint brightness;\n\tstruct work_struct work;\n\tbool removed;\n};\n\nstruct k90_drvdata {\n\tstruct k90_led record_led;\n};\n\nstruct corsair_drvdata {\n\tunsigned long quirks;\n\tstruct k90_drvdata *k90;\n\tstruct k90_led *backlight;\n};\n\n#define K90_GKEY_COUNT\t18\n\nstatic int corsair_usage_to_gkey(unsigned int usage)\n{\n\t \n\tif (usage >= 0xd0 && usage <= 0xdf)\n\t\treturn usage - 0xd0 + 1;\n\t \n\tif (usage >= 0xe8 && usage <= 0xe9)\n\t\treturn usage - 0xe8 + 17;\n\treturn 0;\n}\n\nstatic unsigned short corsair_gkey_map[K90_GKEY_COUNT] = {\n\tBTN_TRIGGER_HAPPY1,\n\tBTN_TRIGGER_HAPPY2,\n\tBTN_TRIGGER_HAPPY3,\n\tBTN_TRIGGER_HAPPY4,\n\tBTN_TRIGGER_HAPPY5,\n\tBTN_TRIGGER_HAPPY6,\n\tBTN_TRIGGER_HAPPY7,\n\tBTN_TRIGGER_HAPPY8,\n\tBTN_TRIGGER_HAPPY9,\n\tBTN_TRIGGER_HAPPY10,\n\tBTN_TRIGGER_HAPPY11,\n\tBTN_TRIGGER_HAPPY12,\n\tBTN_TRIGGER_HAPPY13,\n\tBTN_TRIGGER_HAPPY14,\n\tBTN_TRIGGER_HAPPY15,\n\tBTN_TRIGGER_HAPPY16,\n\tBTN_TRIGGER_HAPPY17,\n\tBTN_TRIGGER_HAPPY18,\n};\n\nmodule_param_array_named(gkey_codes, corsair_gkey_map, ushort, NULL, S_IRUGO);\nMODULE_PARM_DESC(gkey_codes, \"Key codes for the G-keys\");\n\nstatic unsigned short corsair_record_keycodes[2] = {\n\tBTN_TRIGGER_HAPPY19,\n\tBTN_TRIGGER_HAPPY20\n};\n\nmodule_param_array_named(recordkey_codes, corsair_record_keycodes, ushort,\n\t\t\t NULL, S_IRUGO);\nMODULE_PARM_DESC(recordkey_codes, \"Key codes for the MR (start and stop record) button\");\n\nstatic unsigned short corsair_profile_keycodes[3] = {\n\tBTN_TRIGGER_HAPPY21,\n\tBTN_TRIGGER_HAPPY22,\n\tBTN_TRIGGER_HAPPY23\n};\n\nmodule_param_array_named(profilekey_codes, corsair_profile_keycodes, ushort,\n\t\t\t NULL, S_IRUGO);\nMODULE_PARM_DESC(profilekey_codes, \"Key codes for the profile buttons\");\n\n#define CORSAIR_USAGE_SPECIAL_MIN 0xf0\n#define CORSAIR_USAGE_SPECIAL_MAX 0xff\n\n#define CORSAIR_USAGE_MACRO_RECORD_START 0xf6\n#define CORSAIR_USAGE_MACRO_RECORD_STOP 0xf7\n\n#define CORSAIR_USAGE_PROFILE 0xf1\n#define CORSAIR_USAGE_M1 0xf1\n#define CORSAIR_USAGE_M2 0xf2\n#define CORSAIR_USAGE_M3 0xf3\n#define CORSAIR_USAGE_PROFILE_MAX 0xf3\n\n#define CORSAIR_USAGE_META_OFF 0xf4\n#define CORSAIR_USAGE_META_ON  0xf5\n\n#define CORSAIR_USAGE_LIGHT 0xfa\n#define CORSAIR_USAGE_LIGHT_OFF 0xfa\n#define CORSAIR_USAGE_LIGHT_DIM 0xfb\n#define CORSAIR_USAGE_LIGHT_MEDIUM 0xfc\n#define CORSAIR_USAGE_LIGHT_BRIGHT 0xfd\n#define CORSAIR_USAGE_LIGHT_MAX 0xfd\n\n \n\n#define K90_REQUEST_BRIGHTNESS 49\n#define K90_REQUEST_MACRO_MODE 2\n#define K90_REQUEST_STATUS 4\n#define K90_REQUEST_GET_MODE 5\n#define K90_REQUEST_PROFILE 20\n\n#define K90_MACRO_MODE_SW 0x0030\n#define K90_MACRO_MODE_HW 0x0001\n\n#define K90_MACRO_LED_ON  0x0020\n#define K90_MACRO_LED_OFF 0x0040\n\n \n\n#define K90_BACKLIGHT_LED_SUFFIX \"::backlight\"\n#define K90_RECORD_LED_SUFFIX \"::record\"\n\nstatic enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 5) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = brightness;\nout:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)\n{\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\n\treturn led->brightness;\n}\n\nstatic void k90_brightness_set(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness brightness)\n{\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\n\tled->brightness = brightness;\n\tschedule_work(&led->work);\n}\n\nstatic void k90_backlight_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(work, struct k90_led, work);\n\tstruct device *dev;\n\tstruct usb_interface *usbif;\n\tstruct usb_device *usbdev;\n\n\tif (led->removed)\n\t\treturn;\n\n\tdev = led->cdev.dev->parent;\n\tusbif = to_usb_interface(dev->parent);\n\tusbdev = interface_to_usbdev(usbif);\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_BRIGHTNESS,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, led->brightness, 0,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0)\n\t\tdev_warn(dev, \"Failed to set backlight brightness (error: %d).\\n\",\n\t\t\t ret);\n}\n\nstatic void k90_record_led_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(work, struct k90_led, work);\n\tstruct device *dev;\n\tstruct usb_interface *usbif;\n\tstruct usb_device *usbdev;\n\tint value;\n\n\tif (led->removed)\n\t\treturn;\n\n\tdev = led->cdev.dev->parent;\n\tusbif = to_usb_interface(dev->parent);\n\tusbdev = interface_to_usbdev(usbif);\n\n\tif (led->brightness > 0)\n\t\tvalue = K90_MACRO_LED_ON;\n\telse\n\t\tvalue = K90_MACRO_LED_OFF;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_MACRO_MODE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0)\n\t\tdev_warn(dev, \"Failed to set record LED state (error: %d).\\n\",\n\t\t\t ret);\n}\n\n \n\nstatic ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar *data;\n\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 1) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\nout:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic ssize_t k90_store_macro_mode(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\t__u16 value;\n\n\tif (strncmp(buf, \"SW\", 2) == 0)\n\t\tvalue = K90_MACRO_MODE_SW;\n\telse if (strncmp(buf, \"HW\", 2) == 0)\n\t\tvalue = K90_MACRO_MODE_HW;\n\telse\n\t\treturn -EINVAL;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_MACRO_MODE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0) {\n\t\tdev_warn(dev, \"Failed to set macro mode.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 8) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\nout:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic ssize_t k90_store_current_profile(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint profile;\n\n\tif (kstrtoint(buf, 10, &profile))\n\t\treturn -EINVAL;\n\tif (profile < 1 || profile > 3)\n\t\treturn -EINVAL;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_PROFILE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, profile, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0) {\n\t\tdev_warn(dev, \"Failed to change current profile (error %d).\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(macro_mode, 0644, k90_show_macro_mode, k90_store_macro_mode);\nstatic DEVICE_ATTR(current_profile, 0644, k90_show_current_profile,\n\t\t   k90_store_current_profile);\n\nstatic struct attribute *k90_attrs[] = {\n\t&dev_attr_macro_mode.attr,\n\t&dev_attr_current_profile.attr,\n\tNULL\n};\n\nstatic const struct attribute_group k90_attr_group = {\n\t.attrs = k90_attrs,\n};\n\n \n\nstatic int k90_init_backlight(struct hid_device *dev)\n{\n\tint ret;\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tsize_t name_sz;\n\tchar *name;\n\n\tdrvdata->backlight = kzalloc(sizeof(struct k90_led), GFP_KERNEL);\n\tif (!drvdata->backlight) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_backlight_alloc;\n\t}\n\n\tname_sz =\n\t    strlen(dev_name(&dev->dev)) + sizeof(K90_BACKLIGHT_LED_SUFFIX);\n\tname = kzalloc(name_sz, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_name_alloc;\n\t}\n\tsnprintf(name, name_sz, \"%s\" K90_BACKLIGHT_LED_SUFFIX,\n\t\t dev_name(&dev->dev));\n\tdrvdata->backlight->removed = false;\n\tdrvdata->backlight->cdev.name = name;\n\tdrvdata->backlight->cdev.max_brightness = 3;\n\tdrvdata->backlight->cdev.brightness_set = k90_brightness_set;\n\tdrvdata->backlight->cdev.brightness_get = k90_backlight_get;\n\tINIT_WORK(&drvdata->backlight->work, k90_backlight_work);\n\tret = led_classdev_register(&dev->dev, &drvdata->backlight->cdev);\n\tif (ret != 0)\n\t\tgoto fail_register_cdev;\n\n\treturn 0;\n\nfail_register_cdev:\n\tkfree(drvdata->backlight->cdev.name);\nfail_name_alloc:\n\tkfree(drvdata->backlight);\n\tdrvdata->backlight = NULL;\nfail_backlight_alloc:\n\treturn ret;\n}\n\nstatic int k90_init_macro_functions(struct hid_device *dev)\n{\n\tint ret;\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tstruct k90_drvdata *k90;\n\tsize_t name_sz;\n\tchar *name;\n\n\tk90 = kzalloc(sizeof(struct k90_drvdata), GFP_KERNEL);\n\tif (!k90) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_drvdata;\n\t}\n\tdrvdata->k90 = k90;\n\n\t \n\tname_sz = strlen(dev_name(&dev->dev)) + sizeof(K90_RECORD_LED_SUFFIX);\n\tname = kzalloc(name_sz, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_record_led_alloc;\n\t}\n\tsnprintf(name, name_sz, \"%s\" K90_RECORD_LED_SUFFIX,\n\t\t dev_name(&dev->dev));\n\tk90->record_led.removed = false;\n\tk90->record_led.cdev.name = name;\n\tk90->record_led.cdev.max_brightness = 1;\n\tk90->record_led.cdev.brightness_set = k90_brightness_set;\n\tk90->record_led.cdev.brightness_get = k90_record_led_get;\n\tINIT_WORK(&k90->record_led.work, k90_record_led_work);\n\tk90->record_led.brightness = 0;\n\tret = led_classdev_register(&dev->dev, &k90->record_led.cdev);\n\tif (ret != 0)\n\t\tgoto fail_record_led;\n\n\t \n\tret = sysfs_create_group(&dev->dev.kobj, &k90_attr_group);\n\tif (ret != 0)\n\t\tgoto fail_sysfs;\n\n\treturn 0;\n\nfail_sysfs:\n\tk90->record_led.removed = true;\n\tled_classdev_unregister(&k90->record_led.cdev);\n\tcancel_work_sync(&k90->record_led.work);\nfail_record_led:\n\tkfree(k90->record_led.cdev.name);\nfail_record_led_alloc:\n\tkfree(k90);\nfail_drvdata:\n\tdrvdata->k90 = NULL;\n\treturn ret;\n}\n\nstatic void k90_cleanup_backlight(struct hid_device *dev)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\n\tif (drvdata->backlight) {\n\t\tdrvdata->backlight->removed = true;\n\t\tled_classdev_unregister(&drvdata->backlight->cdev);\n\t\tcancel_work_sync(&drvdata->backlight->work);\n\t\tkfree(drvdata->backlight->cdev.name);\n\t\tkfree(drvdata->backlight);\n\t}\n}\n\nstatic void k90_cleanup_macro_functions(struct hid_device *dev)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tstruct k90_drvdata *k90 = drvdata->k90;\n\n\tif (k90) {\n\t\tsysfs_remove_group(&dev->dev.kobj, &k90_attr_group);\n\n\t\tk90->record_led.removed = true;\n\t\tled_classdev_unregister(&k90->record_led.cdev);\n\t\tcancel_work_sync(&k90->record_led.work);\n\t\tkfree(k90->record_led.cdev.name);\n\n\t\tkfree(k90);\n\t}\n}\n\nstatic int corsair_probe(struct hid_device *dev, const struct hid_device_id *id)\n{\n\tint ret;\n\tunsigned long quirks = id->driver_data;\n\tstruct corsair_drvdata *drvdata;\n\tstruct usb_interface *usbif;\n\n\tif (!hid_is_usb(dev))\n\t\treturn -EINVAL;\n\n\tusbif = to_usb_interface(dev->dev.parent);\n\n\tdrvdata = devm_kzalloc(&dev->dev, sizeof(struct corsair_drvdata),\n\t\t\t       GFP_KERNEL);\n\tif (drvdata == NULL)\n\t\treturn -ENOMEM;\n\tdrvdata->quirks = quirks;\n\thid_set_drvdata(dev, drvdata);\n\n\tret = hid_parse(dev);\n\tif (ret != 0) {\n\t\thid_err(dev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\tret = hid_hw_start(dev, HID_CONNECT_DEFAULT);\n\tif (ret != 0) {\n\t\thid_err(dev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (usbif->cur_altsetting->desc.bInterfaceNumber == 0) {\n\t\tif (quirks & CORSAIR_USE_K90_MACRO) {\n\t\t\tret = k90_init_macro_functions(dev);\n\t\t\tif (ret != 0)\n\t\t\t\thid_warn(dev, \"Failed to initialize K90 macro functions.\\n\");\n\t\t}\n\t\tif (quirks & CORSAIR_USE_K90_BACKLIGHT) {\n\t\t\tret = k90_init_backlight(dev);\n\t\t\tif (ret != 0)\n\t\t\t\thid_warn(dev, \"Failed to initialize K90 backlight.\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void corsair_remove(struct hid_device *dev)\n{\n\tk90_cleanup_macro_functions(dev);\n\tk90_cleanup_backlight(dev);\n\n\thid_hw_stop(dev);\n}\n\nstatic int corsair_event(struct hid_device *dev, struct hid_field *field,\n\t\t\t struct hid_usage *usage, __s32 value)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\n\tif (!drvdata->k90)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase CORSAIR_USAGE_MACRO_RECORD_START:\n\t\tdrvdata->k90->record_led.brightness = 1;\n\t\tbreak;\n\tcase CORSAIR_USAGE_MACRO_RECORD_STOP:\n\t\tdrvdata->k90->record_led.brightness = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int corsair_input_mapping(struct hid_device *dev,\n\t\t\t\t struct hid_input *input,\n\t\t\t\t struct hid_field *field,\n\t\t\t\t struct hid_usage *usage, unsigned long **bit,\n\t\t\t\t int *max)\n{\n\tint gkey;\n\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_KEYBOARD)\n\t\treturn 0;\n\n\tgkey = corsair_usage_to_gkey(usage->hid & HID_USAGE);\n\tif (gkey != 0) {\n\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t    corsair_gkey_map[gkey - 1]);\n\t\treturn 1;\n\t}\n\tif ((usage->hid & HID_USAGE) >= CORSAIR_USAGE_SPECIAL_MIN &&\n\t    (usage->hid & HID_USAGE) <= CORSAIR_USAGE_SPECIAL_MAX) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase CORSAIR_USAGE_MACRO_RECORD_START:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_record_keycodes[0]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_MACRO_RECORD_STOP:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_record_keycodes[1]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M1:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[0]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M2:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[1]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M3:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[2]);\n\t\t\treturn 1;\n\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic __u8 *corsair_mouse_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n        unsigned int *rsize)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\n\tif (intf->cur_altsetting->desc.bInterfaceNumber == 1) {\n\t\t \n\t\tswitch (hdev->product) {\n\t\tcase USB_DEVICE_ID_CORSAIR_GLAIVE_RGB:\n\t\tcase USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB:\n\t\t\tif (*rsize >= 172 && rdesc[75] == 0x15 && rdesc[77] == 0x16\n\t\t\t&& rdesc[78] == 0xff && rdesc[79] == 0x0f) {\n\t\t\t\thid_info(hdev, \"Fixing up report descriptor\\n\");\n\t\t\t\trdesc[77] = 0x26;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}\n\treturn rdesc;\n}\n\nstatic const struct hid_device_id corsair_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K90),\n\t\t.driver_data = CORSAIR_USE_K90_MACRO |\n\t\t\t       CORSAIR_USE_K90_BACKLIGHT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR,\n            USB_DEVICE_ID_CORSAIR_GLAIVE_RGB) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR,\n            USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB) },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR,\n            USB_DEVICE_ID_CORSAIR_K70R) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(hid, corsair_devices);\n\nstatic struct hid_driver corsair_driver = {\n\t.name = \"corsair\",\n\t.id_table = corsair_devices,\n\t.probe = corsair_probe,\n\t.event = corsair_event,\n\t.remove = corsair_remove,\n\t.input_mapping = corsair_input_mapping,\n\t.report_fixup = corsair_mouse_report_fixup,\n};\n\nmodule_hid_driver(corsair_driver);\n\nMODULE_LICENSE(\"GPL\");\n \nMODULE_AUTHOR(\"Clement Vuchener\");\n \nMODULE_AUTHOR(\"Oscar Campos\");\nMODULE_DESCRIPTION(\"HID driver for Corsair devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}