{
  "module_name": "hbm.c",
  "hash_id": "8562849f852a3bfa85c5b9198f0ce1d3abda6c3eaa37ff0f92b57398b7089ef5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/intel-ish-hid/ishtp/hbm.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include \"ishtp-dev.h\"\n#include \"hbm.h\"\n#include \"client.h\"\n\n \nstatic void ishtp_hbm_fw_cl_allocate(struct ishtp_device *dev)\n{\n\tstruct ishtp_fw_client *clients;\n\tint b;\n\n\t \n\tfor_each_set_bit(b, dev->fw_clients_map, ISHTP_CLIENTS_MAX)\n\t\tdev->fw_clients_num++;\n\n\tif (dev->fw_clients_num <= 0)\n\t\treturn;\n\n\t \n\tclients = kcalloc(dev->fw_clients_num, sizeof(struct ishtp_fw_client),\n\t\t\t  GFP_KERNEL);\n\tif (!clients) {\n\t\tdev->dev_state = ISHTP_DEV_RESETTING;\n\t\tish_hw_reset(dev);\n\t\treturn;\n\t}\n\tdev->fw_clients = clients;\n}\n\n \nstatic inline void ishtp_hbm_cl_hdr(struct ishtp_cl *cl, uint8_t hbm_cmd,\n\tvoid *buf, size_t len)\n{\n\tstruct ishtp_hbm_cl_cmd *cmd = buf;\n\n\tmemset(cmd, 0, len);\n\n\tcmd->hbm_cmd = hbm_cmd;\n\tcmd->host_addr = cl->host_client_id;\n\tcmd->fw_addr = cl->fw_client_id;\n}\n\n \nstatic inline bool ishtp_hbm_cl_addr_equal(struct ishtp_cl *cl, void *buf)\n{\n\tstruct ishtp_hbm_cl_cmd *cmd = buf;\n\n\treturn cl->host_client_id == cmd->host_addr &&\n\t\tcl->fw_client_id == cmd->fw_addr;\n}\n\n \nint ishtp_hbm_start_wait(struct ishtp_device *dev)\n{\n\tint ret;\n\n\tif (dev->hbm_state > ISHTP_HBM_START)\n\t\treturn 0;\n\n\tdev_dbg(dev->devc, \"Going to wait for ishtp start. hbm_state=%08X\\n\",\n\t\tdev->hbm_state);\n\tret = wait_event_interruptible_timeout(dev->wait_hbm_recvd_msg,\n\t\t\t\t\tdev->hbm_state >= ISHTP_HBM_STARTED,\n\t\t\t\t\t(ISHTP_INTEROP_TIMEOUT * HZ));\n\n\tdev_dbg(dev->devc,\n\t\t\"Woke up from waiting for ishtp start. hbm_state=%08X\\n\",\n\t\tdev->hbm_state);\n\n\tif (ret <= 0 && (dev->hbm_state <= ISHTP_HBM_START)) {\n\t\tdev->hbm_state = ISHTP_HBM_IDLE;\n\t\tdev_err(dev->devc,\n\t\t\"waiting for ishtp start failed. ret=%d hbm_state=%08X\\n\",\n\t\t\tret, dev->hbm_state);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\n \nint ishtp_hbm_start_req(struct ishtp_device *dev)\n{\n\tstruct ishtp_msg_hdr hdr;\n\tstruct hbm_host_version_request start_req = { 0 };\n\n\tishtp_hbm_hdr(&hdr, sizeof(start_req));\n\n\t \n\tstart_req.hbm_cmd = HOST_START_REQ_CMD;\n\tstart_req.host_version.major_version = HBM_MAJOR_VERSION;\n\tstart_req.host_version.minor_version = HBM_MINOR_VERSION;\n\n\t \n\tdev->hbm_state = ISHTP_HBM_START;\n\tif (ishtp_write_message(dev, &hdr, &start_req)) {\n\t\tdev_err(dev->devc, \"version message send failed\\n\");\n\t\tdev->dev_state = ISHTP_DEV_RESETTING;\n\t\tdev->hbm_state = ISHTP_HBM_IDLE;\n\t\tish_hw_reset(dev);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ishtp_hbm_enum_clients_req(struct ishtp_device *dev)\n{\n\tstruct ishtp_msg_hdr hdr;\n\tstruct hbm_host_enum_request enum_req = { 0 };\n\n\t \n\tishtp_hbm_hdr(&hdr, sizeof(enum_req));\n\tenum_req.hbm_cmd = HOST_ENUM_REQ_CMD;\n\n\tif (ishtp_write_message(dev, &hdr, &enum_req)) {\n\t\tdev->dev_state = ISHTP_DEV_RESETTING;\n\t\tdev_err(dev->devc, \"enumeration request send failed\\n\");\n\t\tish_hw_reset(dev);\n\t}\n\tdev->hbm_state = ISHTP_HBM_ENUM_CLIENTS;\n}\n\n \nstatic int ishtp_hbm_prop_req(struct ishtp_device *dev)\n{\n\tstruct ishtp_msg_hdr hdr;\n\tstruct hbm_props_request prop_req = { 0 };\n\tunsigned long next_client_index;\n\tuint8_t client_num;\n\n\tclient_num = dev->fw_client_presentation_num;\n\n\tnext_client_index = find_next_bit(dev->fw_clients_map,\n\t\tISHTP_CLIENTS_MAX, dev->fw_client_index);\n\n\t \n\tif (next_client_index == ISHTP_CLIENTS_MAX) {\n\t\tdev->hbm_state = ISHTP_HBM_WORKING;\n\t\tdev->dev_state = ISHTP_DEV_ENABLED;\n\n\t\tfor (dev->fw_client_presentation_num = 1;\n\t\t\tdev->fw_client_presentation_num < client_num + 1;\n\t\t\t\t++dev->fw_client_presentation_num)\n\t\t\t \n\t\t\tishtp_bus_new_client(dev);\n\t\treturn 0;\n\t}\n\n\tdev->fw_clients[client_num].client_id = next_client_index;\n\n\tishtp_hbm_hdr(&hdr, sizeof(prop_req));\n\n\tprop_req.hbm_cmd = HOST_CLIENT_PROPERTIES_REQ_CMD;\n\tprop_req.address = next_client_index;\n\n\tif (ishtp_write_message(dev, &hdr, &prop_req)) {\n\t\tdev->dev_state = ISHTP_DEV_RESETTING;\n\t\tdev_err(dev->devc, \"properties request send failed\\n\");\n\t\tish_hw_reset(dev);\n\t\treturn -EIO;\n\t}\n\n\tdev->fw_client_index = next_client_index;\n\n\treturn 0;\n}\n\n \nstatic void ishtp_hbm_stop_req(struct ishtp_device *dev)\n{\n\tstruct ishtp_msg_hdr hdr;\n\tstruct hbm_host_stop_request stop_req = { 0 } ;\n\n\tishtp_hbm_hdr(&hdr, sizeof(stop_req));\n\n\tstop_req.hbm_cmd = HOST_STOP_REQ_CMD;\n\tstop_req.reason = DRIVER_STOP_REQUEST;\n\n\tishtp_write_message(dev, &hdr, &stop_req);\n}\n\n \nint ishtp_hbm_cl_flow_control_req(struct ishtp_device *dev,\n\t\t\t\t  struct ishtp_cl *cl)\n{\n\tstruct ishtp_msg_hdr hdr;\n\tstruct hbm_flow_control flow_ctrl;\n\tconst size_t len = sizeof(flow_ctrl);\n\tint\trv;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&cl->fc_spinlock, flags);\n\n\tishtp_hbm_hdr(&hdr, len);\n\tishtp_hbm_cl_hdr(cl, ISHTP_FLOW_CONTROL_CMD, &flow_ctrl, len);\n\n\t \n\tif (cl->out_flow_ctrl_creds) {\n\t\tspin_unlock_irqrestore(&cl->fc_spinlock, flags);\n\t\treturn\t0;\n\t}\n\n\tcl->recv_msg_num_frags = 0;\n\n\trv = ishtp_write_message(dev, &hdr, &flow_ctrl);\n\tif (!rv) {\n\t\t++cl->out_flow_ctrl_creds;\n\t\t++cl->out_flow_ctrl_cnt;\n\t\tcl->ts_out_fc = ktime_get();\n\t\tif (cl->ts_rx) {\n\t\t\tktime_t ts_diff = ktime_sub(cl->ts_out_fc, cl->ts_rx);\n\t\t\tif (ktime_after(ts_diff, cl->ts_max_fc_delay))\n\t\t\t\tcl->ts_max_fc_delay = ts_diff;\n\t\t}\n\t} else {\n\t\t++cl->err_send_fc;\n\t}\n\n\tspin_unlock_irqrestore(&cl->fc_spinlock, flags);\n\treturn\trv;\n}\n\n \nint ishtp_hbm_cl_disconnect_req(struct ishtp_device *dev, struct ishtp_cl *cl)\n{\n\tstruct ishtp_msg_hdr hdr;\n\tstruct hbm_client_connect_request disconn_req;\n\tconst size_t len = sizeof(disconn_req);\n\n\tishtp_hbm_hdr(&hdr, len);\n\tishtp_hbm_cl_hdr(cl, CLIENT_DISCONNECT_REQ_CMD, &disconn_req, len);\n\n\treturn ishtp_write_message(dev, &hdr, &disconn_req);\n}\n\n \nstatic void ishtp_hbm_cl_disconnect_res(struct ishtp_device *dev,\n\tstruct hbm_client_connect_response *rs)\n{\n\tstruct ishtp_cl *cl = NULL;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&dev->cl_list_lock, flags);\n\tlist_for_each_entry(cl, &dev->cl_list, link) {\n\t\tif (!rs->status && ishtp_hbm_cl_addr_equal(cl, rs)) {\n\t\t\tcl->state = ISHTP_CL_DISCONNECTED;\n\t\t\twake_up_interruptible(&cl->wait_ctrl_res);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->cl_list_lock, flags);\n}\n\n \nint ishtp_hbm_cl_connect_req(struct ishtp_device *dev, struct ishtp_cl *cl)\n{\n\tstruct ishtp_msg_hdr hdr;\n\tstruct hbm_client_connect_request conn_req;\n\tconst size_t len = sizeof(conn_req);\n\n\tishtp_hbm_hdr(&hdr, len);\n\tishtp_hbm_cl_hdr(cl, CLIENT_CONNECT_REQ_CMD, &conn_req, len);\n\n\treturn ishtp_write_message(dev, &hdr, &conn_req);\n}\n\n \nstatic void ishtp_hbm_cl_connect_res(struct ishtp_device *dev,\n\tstruct hbm_client_connect_response *rs)\n{\n\tstruct ishtp_cl *cl = NULL;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&dev->cl_list_lock, flags);\n\tlist_for_each_entry(cl, &dev->cl_list, link) {\n\t\tif (ishtp_hbm_cl_addr_equal(cl, rs)) {\n\t\t\tif (!rs->status) {\n\t\t\t\tcl->state = ISHTP_CL_CONNECTED;\n\t\t\t\tcl->status = 0;\n\t\t\t} else {\n\t\t\t\tcl->state = ISHTP_CL_DISCONNECTED;\n\t\t\t\tcl->status = -ENODEV;\n\t\t\t}\n\t\t\twake_up_interruptible(&cl->wait_ctrl_res);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->cl_list_lock, flags);\n}\n\n \nstatic void ishtp_hbm_fw_disconnect_req(struct ishtp_device *dev,\n\tstruct hbm_client_connect_request *disconnect_req)\n{\n\tstruct ishtp_cl *cl;\n\tconst size_t len = sizeof(struct hbm_client_connect_response);\n\tunsigned long\tflags;\n\tstruct ishtp_msg_hdr hdr;\n\tunsigned char data[4];\t \n\n\tspin_lock_irqsave(&dev->cl_list_lock, flags);\n\tlist_for_each_entry(cl, &dev->cl_list, link) {\n\t\tif (ishtp_hbm_cl_addr_equal(cl, disconnect_req)) {\n\t\t\tcl->state = ISHTP_CL_DISCONNECTED;\n\n\t\t\t \n\t\t\tishtp_hbm_hdr(&hdr, len);\n\t\t\tishtp_hbm_cl_hdr(cl, CLIENT_DISCONNECT_RES_CMD, data,\n\t\t\t\tlen);\n\t\t\tishtp_write_message(dev, &hdr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->cl_list_lock, flags);\n}\n\n \nstatic void ishtp_hbm_dma_xfer_ack(struct ishtp_device *dev,\n\t\t\t\t   struct dma_xfer_hbm *dma_xfer)\n{\n\tvoid\t*msg;\n\tuint64_t\toffs;\n\tstruct ishtp_msg_hdr\t*ishtp_hdr =\n\t\t(struct ishtp_msg_hdr *)&dev->ishtp_msg_hdr;\n\tunsigned int\tmsg_offs;\n\tstruct ishtp_cl *cl;\n\n\tfor (msg_offs = 0; msg_offs < ishtp_hdr->length;\n\t\tmsg_offs += sizeof(struct dma_xfer_hbm)) {\n\t\toffs = dma_xfer->msg_addr - dev->ishtp_host_dma_tx_buf_phys;\n\t\tif (offs > dev->ishtp_host_dma_tx_buf_size) {\n\t\t\tdev_err(dev->devc, \"Bad DMA Tx ack message address\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (dma_xfer->msg_length >\n\t\t\t\tdev->ishtp_host_dma_tx_buf_size - offs) {\n\t\t\tdev_err(dev->devc, \"Bad DMA Tx ack message size\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tmsg = (unsigned char *)dev->ishtp_host_dma_tx_buf + offs;\n\t\tishtp_cl_release_dma_acked_mem(dev, msg, dma_xfer->msg_length);\n\n\t\tlist_for_each_entry(cl, &dev->cl_list, link) {\n\t\t\tif (cl->fw_client_id == dma_xfer->fw_client_id &&\n\t\t\t    cl->host_client_id == dma_xfer->host_client_id)\n\t\t\t\t \n\t\t\t\tif (cl->last_dma_addr >=\n\t\t\t\t\t\t\t(unsigned char *)msg &&\n\t\t\t\t\t\tcl->last_dma_addr <\n\t\t\t\t\t\t(unsigned char *)msg +\n\t\t\t\t\t\tdma_xfer->msg_length) {\n\t\t\t\t\tcl->last_dma_acked = 1;\n\n\t\t\t\t\tif (!list_empty(&cl->tx_list.list) &&\n\t\t\t\t\t\tcl->ishtp_flow_ctrl_creds) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tishtp_cl_send_msg(dev, cl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t++dma_xfer;\n\t}\n}\n\n \nstatic void ishtp_hbm_dma_xfer(struct ishtp_device *dev,\n\t\t\t       struct dma_xfer_hbm *dma_xfer)\n{\n\tvoid\t*msg;\n\tuint64_t\toffs;\n\tstruct ishtp_msg_hdr\thdr;\n\tstruct ishtp_msg_hdr\t*ishtp_hdr =\n\t\t(struct ishtp_msg_hdr *) &dev->ishtp_msg_hdr;\n\tstruct dma_xfer_hbm\t*prm = dma_xfer;\n\tunsigned int\tmsg_offs;\n\n\tfor (msg_offs = 0; msg_offs < ishtp_hdr->length;\n\t\tmsg_offs += sizeof(struct dma_xfer_hbm)) {\n\n\t\toffs = dma_xfer->msg_addr - dev->ishtp_host_dma_rx_buf_phys;\n\t\tif (offs > dev->ishtp_host_dma_rx_buf_size) {\n\t\t\tdev_err(dev->devc, \"Bad DMA Rx message address\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (dma_xfer->msg_length >\n\t\t\t\tdev->ishtp_host_dma_rx_buf_size - offs) {\n\t\t\tdev_err(dev->devc, \"Bad DMA Rx message size\\n\");\n\t\t\treturn;\n\t\t}\n\t\tmsg = dev->ishtp_host_dma_rx_buf + offs;\n\t\trecv_ishtp_cl_msg_dma(dev, msg, dma_xfer);\n\t\tdma_xfer->hbm = DMA_XFER_ACK;\t \n\t\t++dma_xfer;\n\t}\n\n\t \n\tishtp_hbm_hdr(&hdr, ishtp_hdr->length);\n\tishtp_write_message(dev, &hdr, (unsigned char *)prm);\n}\n\n \nvoid ishtp_hbm_dispatch(struct ishtp_device *dev,\n\t\t\tstruct ishtp_bus_message *hdr)\n{\n\tstruct ishtp_bus_message *ishtp_msg;\n\tstruct ishtp_fw_client *fw_client;\n\tstruct hbm_host_version_response *version_res;\n\tstruct hbm_client_connect_response *connect_res;\n\tstruct hbm_client_connect_response *disconnect_res;\n\tstruct hbm_client_connect_request *disconnect_req;\n\tstruct hbm_props_response *props_res;\n\tstruct hbm_host_enum_response *enum_res;\n\tstruct ishtp_msg_hdr ishtp_hdr;\n\tstruct dma_alloc_notify\tdma_alloc_notify;\n\tstruct dma_xfer_hbm\t*dma_xfer;\n\n\tishtp_msg = hdr;\n\n\tswitch (ishtp_msg->hbm_cmd) {\n\tcase HOST_START_RES_CMD:\n\t\tversion_res = (struct hbm_host_version_response *)ishtp_msg;\n\t\tif (!version_res->host_version_supported) {\n\t\t\tdev->version = version_res->fw_max_version;\n\n\t\t\tdev->hbm_state = ISHTP_HBM_STOPPED;\n\t\t\tishtp_hbm_stop_req(dev);\n\t\t\treturn;\n\t\t}\n\n\t\tdev->version.major_version = HBM_MAJOR_VERSION;\n\t\tdev->version.minor_version = HBM_MINOR_VERSION;\n\t\tif (dev->dev_state == ISHTP_DEV_INIT_CLIENTS &&\n\t\t\t\tdev->hbm_state == ISHTP_HBM_START) {\n\t\t\tdev->hbm_state = ISHTP_HBM_STARTED;\n\t\t\tishtp_hbm_enum_clients_req(dev);\n\t\t} else {\n\t\t\tdev_err(dev->devc,\n\t\t\t\t\"reset: wrong host start response\\n\");\n\t\t\t \n\t\t\tish_hw_reset(dev);\n\t\t\treturn;\n\t\t}\n\n\t\twake_up_interruptible(&dev->wait_hbm_recvd_msg);\n\t\tbreak;\n\n\tcase CLIENT_CONNECT_RES_CMD:\n\t\tconnect_res = (struct hbm_client_connect_response *)ishtp_msg;\n\t\tishtp_hbm_cl_connect_res(dev, connect_res);\n\t\tbreak;\n\n\tcase CLIENT_DISCONNECT_RES_CMD:\n\t\tdisconnect_res =\n\t\t\t(struct hbm_client_connect_response *)ishtp_msg;\n\t\tishtp_hbm_cl_disconnect_res(dev, disconnect_res);\n\t\tbreak;\n\n\tcase HOST_CLIENT_PROPERTIES_RES_CMD:\n\t\tprops_res = (struct hbm_props_response *)ishtp_msg;\n\t\tfw_client = &dev->fw_clients[dev->fw_client_presentation_num];\n\n\t\tif (props_res->status || !dev->fw_clients) {\n\t\t\tdev_err(dev->devc,\n\t\t\t\"reset: properties response hbm wrong status\\n\");\n\t\t\tish_hw_reset(dev);\n\t\t\treturn;\n\t\t}\n\n\t\tif (fw_client->client_id != props_res->address) {\n\t\t\tdev_err(dev->devc,\n\t\t\t\t\"reset: host properties response address mismatch [%02X %02X]\\n\",\n\t\t\t\tfw_client->client_id, props_res->address);\n\t\t\tish_hw_reset(dev);\n\t\t\treturn;\n\t\t}\n\n\t\tif (dev->dev_state != ISHTP_DEV_INIT_CLIENTS ||\n\t\t\tdev->hbm_state != ISHTP_HBM_CLIENT_PROPERTIES) {\n\t\t\tdev_err(dev->devc,\n\t\t\t\t\"reset: unexpected properties response\\n\");\n\t\t\tish_hw_reset(dev);\n\t\t\treturn;\n\t\t}\n\n\t\tfw_client->props = props_res->client_properties;\n\t\tdev->fw_client_index++;\n\t\tdev->fw_client_presentation_num++;\n\n\t\t \n\t\tishtp_hbm_prop_req(dev);\n\n\t\tif (dev->dev_state != ISHTP_DEV_ENABLED)\n\t\t\tbreak;\n\n\t\tif (!ishtp_use_dma_transfer())\n\t\t\tbreak;\n\n\t\tdev_dbg(dev->devc, \"Requesting to use DMA\\n\");\n\t\tishtp_cl_alloc_dma_buf(dev);\n\t\tif (dev->ishtp_host_dma_rx_buf) {\n\t\t\tconst size_t len = sizeof(dma_alloc_notify);\n\n\t\t\tmemset(&dma_alloc_notify, 0, sizeof(dma_alloc_notify));\n\t\t\tdma_alloc_notify.hbm = DMA_BUFFER_ALLOC_NOTIFY;\n\t\t\tdma_alloc_notify.buf_size =\n\t\t\t\t\tdev->ishtp_host_dma_rx_buf_size;\n\t\t\tdma_alloc_notify.buf_address =\n\t\t\t\t\tdev->ishtp_host_dma_rx_buf_phys;\n\t\t\tishtp_hbm_hdr(&ishtp_hdr, len);\n\t\t\tishtp_write_message(dev, &ishtp_hdr,\n\t\t\t\t(unsigned char *)&dma_alloc_notify);\n\t\t}\n\n\t\tbreak;\n\n\tcase HOST_ENUM_RES_CMD:\n\t\tenum_res = (struct hbm_host_enum_response *) ishtp_msg;\n\t\tmemcpy(dev->fw_clients_map, enum_res->valid_addresses, 32);\n\t\tif (dev->dev_state == ISHTP_DEV_INIT_CLIENTS &&\n\t\t\tdev->hbm_state == ISHTP_HBM_ENUM_CLIENTS) {\n\t\t\tdev->fw_client_presentation_num = 0;\n\t\t\tdev->fw_client_index = 0;\n\n\t\t\tishtp_hbm_fw_cl_allocate(dev);\n\t\t\tdev->hbm_state = ISHTP_HBM_CLIENT_PROPERTIES;\n\n\t\t\t \n\t\t\tishtp_hbm_prop_req(dev);\n\t\t} else {\n\t\t\tdev_err(dev->devc,\n\t\t\t      \"reset: unexpected enumeration response hbm\\n\");\n\t\t\tish_hw_reset(dev);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase HOST_STOP_RES_CMD:\n\t\tif (dev->hbm_state != ISHTP_HBM_STOPPED)\n\t\t\tdev_err(dev->devc, \"unexpected stop response\\n\");\n\n\t\tdev->dev_state = ISHTP_DEV_DISABLED;\n\t\tdev_info(dev->devc, \"reset: FW stop response\\n\");\n\t\tish_hw_reset(dev);\n\t\tbreak;\n\n\tcase CLIENT_DISCONNECT_REQ_CMD:\n\t\t \n\t\tdisconnect_req =\n\t\t\t(struct hbm_client_connect_request *)ishtp_msg;\n\t\tishtp_hbm_fw_disconnect_req(dev, disconnect_req);\n\t\tbreak;\n\n\tcase FW_STOP_REQ_CMD:\n\t\tdev->hbm_state = ISHTP_HBM_STOPPED;\n\t\tbreak;\n\n\tcase DMA_BUFFER_ALLOC_RESPONSE:\n\t\tdev->ishtp_host_dma_enabled = 1;\n\t\tbreak;\n\n\tcase DMA_XFER:\n\t\tdma_xfer = (struct dma_xfer_hbm *)ishtp_msg;\n\t\tif (!dev->ishtp_host_dma_enabled) {\n\t\t\tdev_err(dev->devc,\n\t\t\t\t\"DMA XFER requested but DMA is not enabled\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tishtp_hbm_dma_xfer(dev, dma_xfer);\n\t\tbreak;\n\n\tcase DMA_XFER_ACK:\n\t\tdma_xfer = (struct dma_xfer_hbm *)ishtp_msg;\n\t\tif (!dev->ishtp_host_dma_enabled ||\n\t\t    !dev->ishtp_host_dma_tx_buf) {\n\t\t\tdev_err(dev->devc,\n\t\t\t\t\"DMA XFER acked but DMA Tx is not enabled\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tishtp_hbm_dma_xfer_ack(dev, dma_xfer);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev->devc, \"unknown HBM: %u\\n\",\n\t\t\t(unsigned int)ishtp_msg->hbm_cmd);\n\n\t\tbreak;\n\t}\n}\n\n \nvoid\tbh_hbm_work_fn(struct work_struct *work)\n{\n\tunsigned long\tflags;\n\tstruct ishtp_device\t*dev;\n\tunsigned char\thbm[IPC_PAYLOAD_SIZE];\n\n\tdev = container_of(work, struct ishtp_device, bh_hbm_work);\n\tspin_lock_irqsave(&dev->rd_msg_spinlock, flags);\n\tif (dev->rd_msg_fifo_head != dev->rd_msg_fifo_tail) {\n\t\tmemcpy(hbm, dev->rd_msg_fifo + dev->rd_msg_fifo_head,\n\t\t\tIPC_PAYLOAD_SIZE);\n\t\tdev->rd_msg_fifo_head =\n\t\t\t(dev->rd_msg_fifo_head + IPC_PAYLOAD_SIZE) %\n\t\t\t(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);\n\t\tspin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);\n\t\tishtp_hbm_dispatch(dev, (struct ishtp_bus_message *)hbm);\n\t} else {\n\t\tspin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);\n\t}\n}\n\n \nvoid\trecv_hbm(struct ishtp_device *dev, struct ishtp_msg_hdr *ishtp_hdr)\n{\n\tuint8_t\trd_msg_buf[ISHTP_RD_MSG_BUF_SIZE];\n\tstruct ishtp_bus_message\t*ishtp_msg =\n\t\t(struct ishtp_bus_message *)rd_msg_buf;\n\tunsigned long\tflags;\n\n\tdev->ops->ishtp_read(dev, rd_msg_buf, ishtp_hdr->length);\n\n\t \n\tif (ishtp_msg->hbm_cmd == ISHTP_FLOW_CONTROL_CMD) {\n\t\tstruct hbm_flow_control *flow_control =\n\t\t\t(struct hbm_flow_control *)ishtp_msg;\n\t\tstruct ishtp_cl *cl = NULL;\n\t\tunsigned long\tflags, tx_flags;\n\n\t\tspin_lock_irqsave(&dev->cl_list_lock, flags);\n\t\tlist_for_each_entry(cl, &dev->cl_list, link) {\n\t\t\tif (cl->host_client_id == flow_control->host_addr &&\n\t\t\t\t\tcl->fw_client_id ==\n\t\t\t\t\tflow_control->fw_addr) {\n\t\t\t\t \n\t\t\t\tif (cl->ishtp_flow_ctrl_creds)\n\t\t\t\t\tdev_err(dev->devc,\n\t\t\t\t\t \"recv extra FC from FW client %u (host client %u) (FC count was %d)\\n\",\n\t\t\t\t\t (unsigned int)cl->fw_client_id,\n\t\t\t\t\t (unsigned int)cl->host_client_id,\n\t\t\t\t\t cl->ishtp_flow_ctrl_creds);\n\t\t\t\telse {\n\t\t\t\t\t++cl->ishtp_flow_ctrl_creds;\n\t\t\t\t\t++cl->ishtp_flow_ctrl_cnt;\n\t\t\t\t\tcl->last_ipc_acked = 1;\n\t\t\t\t\tspin_lock_irqsave(\n\t\t\t\t\t\t\t&cl->tx_list_spinlock,\n\t\t\t\t\t\t\ttx_flags);\n\t\t\t\t\tif (!list_empty(&cl->tx_list.list)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t\t&cl->tx_list_spinlock,\n\t\t\t\t\t\t\ttx_flags);\n\t\t\t\t\t\tishtp_cl_send_msg(dev, cl);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t\t&cl->tx_list_spinlock,\n\t\t\t\t\t\t\ttx_flags);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->cl_list_lock, flags);\n\t\tgoto\teoi;\n\t}\n\n\t \n\tif (ishtp_msg->hbm_cmd == CLIENT_CONNECT_RES_CMD ||\n\t\t\tishtp_msg->hbm_cmd == CLIENT_DISCONNECT_RES_CMD ||\n\t\t\tishtp_msg->hbm_cmd == CLIENT_DISCONNECT_REQ_CMD ||\n\t\t\tishtp_msg->hbm_cmd == DMA_XFER) {\n\t\tishtp_hbm_dispatch(dev, ishtp_msg);\n\t\tgoto\teoi;\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->rd_msg_spinlock, flags);\n\tif ((dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) %\n\t\t\t(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE) ==\n\t\t\tdev->rd_msg_fifo_head) {\n\t\tspin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);\n\t\tdev_err(dev->devc, \"BH buffer overflow, dropping HBM %u\\n\",\n\t\t\t(unsigned int)ishtp_msg->hbm_cmd);\n\t\tgoto\teoi;\n\t}\n\tmemcpy(dev->rd_msg_fifo + dev->rd_msg_fifo_tail, ishtp_msg,\n\t\tishtp_hdr->length);\n\tdev->rd_msg_fifo_tail = (dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) %\n\t\t(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);\n\tspin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);\n\tschedule_work(&dev->bh_hbm_work);\neoi:\n\treturn;\n}\n\n \nvoid recv_fixed_cl_msg(struct ishtp_device *dev,\n\tstruct ishtp_msg_hdr *ishtp_hdr)\n{\n\tuint8_t rd_msg_buf[ISHTP_RD_MSG_BUF_SIZE];\n\n\tdev->print_log(dev,\n\t\t\"%s() got fixed client msg from client #%d\\n\",\n\t\t__func__, ishtp_hdr->fw_addr);\n\tdev->ops->ishtp_read(dev, rd_msg_buf, ishtp_hdr->length);\n\tif (ishtp_hdr->fw_addr == ISHTP_SYSTEM_STATE_CLIENT_ADDR) {\n\t\tstruct ish_system_states_header *msg_hdr =\n\t\t\t(struct ish_system_states_header *)rd_msg_buf;\n\t\tif (msg_hdr->cmd == SYSTEM_STATE_SUBSCRIBE)\n\t\t\tishtp_send_resume(dev);\n\t\t \n\t\telse\n\t\t\tdev_err(dev->devc, \"unknown fixed client msg [%02X]\\n\",\n\t\t\t\tmsg_hdr->cmd);\n\t}\n}\n\n \nstatic inline void fix_cl_hdr(struct ishtp_msg_hdr *hdr, size_t length,\n\tuint8_t cl_addr)\n{\n\thdr->host_addr = 0;\n\thdr->fw_addr = cl_addr;\n\thdr->length = length;\n\thdr->msg_complete = 1;\n\thdr->reserved = 0;\n}\n\n \n\nstatic uint32_t current_state;\nstatic uint32_t supported_states = SUSPEND_STATE_BIT | CONNECTED_STANDBY_STATE_BIT;\n\n \nvoid ishtp_send_suspend(struct ishtp_device *dev)\n{\n\tstruct ishtp_msg_hdr\tishtp_hdr;\n\tstruct ish_system_states_status state_status_msg;\n\tconst size_t len = sizeof(struct ish_system_states_status);\n\n\tfix_cl_hdr(&ishtp_hdr, len, ISHTP_SYSTEM_STATE_CLIENT_ADDR);\n\n\tmemset(&state_status_msg, 0, len);\n\tstate_status_msg.hdr.cmd = SYSTEM_STATE_STATUS;\n\tstate_status_msg.supported_states = supported_states;\n\tcurrent_state |= (SUSPEND_STATE_BIT | CONNECTED_STANDBY_STATE_BIT);\n\tdev->print_log(dev, \"%s() sends SUSPEND notification\\n\", __func__);\n\tstate_status_msg.states_status = current_state;\n\n\tishtp_write_message(dev, &ishtp_hdr,\n\t\t(unsigned char *)&state_status_msg);\n}\nEXPORT_SYMBOL(ishtp_send_suspend);\n\n \nvoid ishtp_send_resume(struct ishtp_device *dev)\n{\n\tstruct ishtp_msg_hdr\tishtp_hdr;\n\tstruct ish_system_states_status state_status_msg;\n\tconst size_t len = sizeof(struct ish_system_states_status);\n\n\tfix_cl_hdr(&ishtp_hdr, len, ISHTP_SYSTEM_STATE_CLIENT_ADDR);\n\n\tmemset(&state_status_msg, 0, len);\n\tstate_status_msg.hdr.cmd = SYSTEM_STATE_STATUS;\n\tstate_status_msg.supported_states = supported_states;\n\tcurrent_state &= ~(CONNECTED_STANDBY_STATE_BIT | SUSPEND_STATE_BIT);\n\tdev->print_log(dev, \"%s() sends RESUME notification\\n\", __func__);\n\tstate_status_msg.states_status = current_state;\n\n\tishtp_write_message(dev, &ishtp_hdr,\n\t\t(unsigned char *)&state_status_msg);\n}\nEXPORT_SYMBOL(ishtp_send_resume);\n\n \nvoid ishtp_query_subscribers(struct ishtp_device *dev)\n{\n\tstruct ishtp_msg_hdr\tishtp_hdr;\n\tstruct ish_system_states_query_subscribers query_subscribers_msg;\n\tconst size_t len = sizeof(struct ish_system_states_query_subscribers);\n\n\tfix_cl_hdr(&ishtp_hdr, len, ISHTP_SYSTEM_STATE_CLIENT_ADDR);\n\n\tmemset(&query_subscribers_msg, 0, len);\n\tquery_subscribers_msg.hdr.cmd = SYSTEM_STATE_QUERY_SUBSCRIBERS;\n\n\tishtp_write_message(dev, &ishtp_hdr,\n\t\t(unsigned char *)&query_subscribers_msg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}