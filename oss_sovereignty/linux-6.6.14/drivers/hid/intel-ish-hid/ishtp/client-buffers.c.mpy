{
  "module_name": "client-buffers.c",
  "hash_id": "9bfa0ffdab61222e4baca7f23803d387a1e3f0d49a748293de5243c3437ee015",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/intel-ish-hid/ishtp/client-buffers.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"client.h\"\n\n \nint ishtp_cl_alloc_rx_ring(struct ishtp_cl *cl)\n{\n\tsize_t\tlen = cl->device->fw_client->props.max_msg_length;\n\tint\tj;\n\tstruct ishtp_cl_rb *rb;\n\tint\tret = 0;\n\tunsigned long\tflags;\n\n\tfor (j = 0; j < cl->rx_ring_size; ++j) {\n\t\trb = ishtp_io_rb_init(cl);\n\t\tif (!rb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = ishtp_io_rb_alloc_buf(rb, len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tspin_lock_irqsave(&cl->free_list_spinlock, flags);\n\t\tlist_add_tail(&rb->list, &cl->free_rb_list.list);\n\t\tspin_unlock_irqrestore(&cl->free_list_spinlock, flags);\n\t}\n\n\treturn\t0;\n\nout:\n\tdev_err(&cl->device->dev, \"error in allocating Rx buffers\\n\");\n\tishtp_cl_free_rx_ring(cl);\n\treturn\tret;\n}\n\n \nint ishtp_cl_alloc_tx_ring(struct ishtp_cl *cl)\n{\n\tsize_t\tlen = cl->device->fw_client->props.max_msg_length;\n\tint\tj;\n\tunsigned long\tflags;\n\n\tcl->tx_ring_free_size = 0;\n\n\t \n\tfor (j = 0; j < cl->tx_ring_size; ++j) {\n\t\tstruct ishtp_cl_tx_ring\t*tx_buf;\n\n\t\ttx_buf = kzalloc(sizeof(struct ishtp_cl_tx_ring), GFP_KERNEL);\n\t\tif (!tx_buf)\n\t\t\tgoto\tout;\n\n\t\ttx_buf->send_buf.data = kmalloc(len, GFP_KERNEL);\n\t\tif (!tx_buf->send_buf.data) {\n\t\t\tkfree(tx_buf);\n\t\t\tgoto\tout;\n\t\t}\n\n\t\tspin_lock_irqsave(&cl->tx_free_list_spinlock, flags);\n\t\tlist_add_tail(&tx_buf->list, &cl->tx_free_list.list);\n\t\t++cl->tx_ring_free_size;\n\t\tspin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);\n\t}\n\treturn\t0;\nout:\n\tdev_err(&cl->device->dev, \"error in allocating Tx pool\\n\");\n\tishtp_cl_free_tx_ring(cl);\n\treturn\t-ENOMEM;\n}\n\n \nvoid ishtp_cl_free_rx_ring(struct ishtp_cl *cl)\n{\n\tstruct ishtp_cl_rb *rb;\n\tunsigned long\tflags;\n\n\t \n\tspin_lock_irqsave(&cl->free_list_spinlock, flags);\n\twhile (!list_empty(&cl->free_rb_list.list)) {\n\t\trb = list_entry(cl->free_rb_list.list.next, struct ishtp_cl_rb,\n\t\t\t\tlist);\n\t\tlist_del(&rb->list);\n\t\tkfree(rb->buffer.data);\n\t\tkfree(rb);\n\t}\n\tspin_unlock_irqrestore(&cl->free_list_spinlock, flags);\n\t \n\tspin_lock_irqsave(&cl->in_process_spinlock, flags);\n\twhile (!list_empty(&cl->in_process_list.list)) {\n\t\trb = list_entry(cl->in_process_list.list.next,\n\t\t\t\tstruct ishtp_cl_rb, list);\n\t\tlist_del(&rb->list);\n\t\tkfree(rb->buffer.data);\n\t\tkfree(rb);\n\t}\n\tspin_unlock_irqrestore(&cl->in_process_spinlock, flags);\n}\n\n \nvoid ishtp_cl_free_tx_ring(struct ishtp_cl *cl)\n{\n\tstruct ishtp_cl_tx_ring\t*tx_buf;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&cl->tx_free_list_spinlock, flags);\n\t \n\twhile (!list_empty(&cl->tx_free_list.list)) {\n\t\ttx_buf = list_entry(cl->tx_free_list.list.next,\n\t\t\t\t    struct ishtp_cl_tx_ring, list);\n\t\tlist_del(&tx_buf->list);\n\t\t--cl->tx_ring_free_size;\n\t\tkfree(tx_buf->send_buf.data);\n\t\tkfree(tx_buf);\n\t}\n\tspin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);\n\n\tspin_lock_irqsave(&cl->tx_list_spinlock, flags);\n\t \n\twhile (!list_empty(&cl->tx_list.list)) {\n\t\ttx_buf = list_entry(cl->tx_list.list.next,\n\t\t\t\t    struct ishtp_cl_tx_ring, list);\n\t\tlist_del(&tx_buf->list);\n\t\tkfree(tx_buf->send_buf.data);\n\t\tkfree(tx_buf);\n\t}\n\tspin_unlock_irqrestore(&cl->tx_list_spinlock, flags);\n}\n\n \nvoid ishtp_io_rb_free(struct ishtp_cl_rb *rb)\n{\n\tif (rb == NULL)\n\t\treturn;\n\n\tkfree(rb->buffer.data);\n\tkfree(rb);\n}\n\n \nstruct ishtp_cl_rb *ishtp_io_rb_init(struct ishtp_cl *cl)\n{\n\tstruct ishtp_cl_rb *rb;\n\n\trb = kzalloc(sizeof(struct ishtp_cl_rb), GFP_KERNEL);\n\tif (!rb)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rb->list);\n\trb->cl = cl;\n\trb->buf_idx = 0;\n\treturn rb;\n}\n\n \nint ishtp_io_rb_alloc_buf(struct ishtp_cl_rb *rb, size_t length)\n{\n\tif (!rb)\n\t\treturn -EINVAL;\n\n\tif (length == 0)\n\t\treturn 0;\n\n\trb->buffer.data = kmalloc(length, GFP_KERNEL);\n\tif (!rb->buffer.data)\n\t\treturn -ENOMEM;\n\n\trb->buffer.size = length;\n\treturn 0;\n}\n\n \nint ishtp_cl_io_rb_recycle(struct ishtp_cl_rb *rb)\n{\n\tstruct ishtp_cl *cl;\n\tint\trets = 0;\n\tunsigned long\tflags;\n\n\tif (!rb || !rb->cl)\n\t\treturn\t-EFAULT;\n\n\tcl = rb->cl;\n\tspin_lock_irqsave(&cl->free_list_spinlock, flags);\n\tlist_add_tail(&rb->list, &cl->free_rb_list.list);\n\tspin_unlock_irqrestore(&cl->free_list_spinlock, flags);\n\n\t \n\tif (!cl->out_flow_ctrl_creds)\n\t\trets = ishtp_cl_read_start(cl);\n\n\treturn\trets;\n}\nEXPORT_SYMBOL(ishtp_cl_io_rb_recycle);\n\n \nbool ishtp_cl_tx_empty(struct ishtp_cl *cl)\n{\n\tint tx_list_empty;\n\tunsigned long tx_flags;\n\n\tspin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);\n\ttx_list_empty = list_empty(&cl->tx_list.list);\n\tspin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);\n\n\treturn !!tx_list_empty;\n}\nEXPORT_SYMBOL(ishtp_cl_tx_empty);\n\n \nstruct ishtp_cl_rb *ishtp_cl_rx_get_rb(struct ishtp_cl *cl)\n{\n\tunsigned long rx_flags;\n\tstruct ishtp_cl_rb *rb;\n\n\tspin_lock_irqsave(&cl->in_process_spinlock, rx_flags);\n\trb = list_first_entry_or_null(&cl->in_process_list.list,\n\t\t\t\tstruct ishtp_cl_rb, list);\n\tif (rb)\n\t\tlist_del_init(&rb->list);\n\tspin_unlock_irqrestore(&cl->in_process_spinlock, rx_flags);\n\n\treturn rb;\n}\nEXPORT_SYMBOL(ishtp_cl_rx_get_rb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}