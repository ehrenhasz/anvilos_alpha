{
  "module_name": "bus.c",
  "hash_id": "ae8f2122206cbc349e8b790b8d1e8bc50f30c76d8634f7a5d7ab11936c6c4fbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/intel-ish-hid/ishtp/bus.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include \"bus.h\"\n#include \"ishtp-dev.h\"\n#include \"client.h\"\n#include \"hbm.h\"\n\nstatic int ishtp_use_dma;\nmodule_param_named(ishtp_use_dma, ishtp_use_dma, int, 0600);\nMODULE_PARM_DESC(ishtp_use_dma, \"Use DMA to send messages\");\n\n#define to_ishtp_cl_driver(d) container_of(d, struct ishtp_cl_driver, driver)\n#define to_ishtp_cl_device(d) container_of(d, struct ishtp_cl_device, dev)\nstatic bool ishtp_device_ready;\n\n \nvoid ishtp_recv(struct ishtp_device *dev)\n{\n\tuint32_t\tmsg_hdr;\n\tstruct ishtp_msg_hdr\t*ishtp_hdr;\n\n\t \n\tmsg_hdr = dev->ops->ishtp_read_hdr(dev);\n\tif (!msg_hdr)\n\t\treturn;\n\n\tdev->ops->sync_fw_clock(dev);\n\n\tishtp_hdr = (struct ishtp_msg_hdr *)&msg_hdr;\n\tdev->ishtp_msg_hdr = msg_hdr;\n\n\t \n\tif (ishtp_hdr->length > dev->mtu) {\n\t\tdev_err(dev->devc,\n\t\t\t\"ISHTP hdr - bad length: %u; dropped [%08X]\\n\",\n\t\t\t(unsigned int)ishtp_hdr->length, msg_hdr);\n\t\treturn;\n\t}\n\n\t \n\tif (!ishtp_hdr->host_addr && !ishtp_hdr->fw_addr)\n\t\trecv_hbm(dev, ishtp_hdr);\n\t \n\telse if (!ishtp_hdr->host_addr)\n\t\trecv_fixed_cl_msg(dev, ishtp_hdr);\n\telse\n\t\t \n\t\trecv_ishtp_cl_msg(dev, ishtp_hdr);\n}\nEXPORT_SYMBOL(ishtp_recv);\n\n \nint ishtp_send_msg(struct ishtp_device *dev, struct ishtp_msg_hdr *hdr,\n\t\t       void *msg, void(*ipc_send_compl)(void *),\n\t\t       void *ipc_send_compl_prm)\n{\n\tunsigned char\tipc_msg[IPC_FULL_MSG_SIZE];\n\tuint32_t\tdrbl_val;\n\n\tdrbl_val = dev->ops->ipc_get_header(dev, hdr->length +\n\t\t\t\t\t    sizeof(struct ishtp_msg_hdr),\n\t\t\t\t\t    1);\n\n\tmemcpy(ipc_msg, &drbl_val, sizeof(uint32_t));\n\tmemcpy(ipc_msg + sizeof(uint32_t), hdr, sizeof(uint32_t));\n\tmemcpy(ipc_msg + 2 * sizeof(uint32_t), msg, hdr->length);\n\treturn\tdev->ops->write(dev, ipc_send_compl, ipc_send_compl_prm,\n\t\t\t\tipc_msg, 2 * sizeof(uint32_t) + hdr->length);\n}\n\n \nint ishtp_write_message(struct ishtp_device *dev, struct ishtp_msg_hdr *hdr,\n\t\t\tvoid *buf)\n{\n\treturn ishtp_send_msg(dev, hdr, buf, NULL, NULL);\n}\n\n \nint ishtp_fw_cl_by_uuid(struct ishtp_device *dev, const guid_t *uuid)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dev->fw_clients_num; ++i) {\n\t\tif (guid_equal(uuid, &dev->fw_clients[i].props.protocol_name))\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(ishtp_fw_cl_by_uuid);\n\n \nstruct ishtp_fw_client *ishtp_fw_cl_get_client(struct ishtp_device *dev,\n\t\t\t\t\t       const guid_t *uuid)\n{\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->fw_clients_lock, flags);\n\ti = ishtp_fw_cl_by_uuid(dev, uuid);\n\tspin_unlock_irqrestore(&dev->fw_clients_lock, flags);\n\tif (i < 0 || dev->fw_clients[i].props.fixed_address)\n\t\treturn NULL;\n\n\treturn &dev->fw_clients[i];\n}\nEXPORT_SYMBOL(ishtp_fw_cl_get_client);\n\n \nint ishtp_get_fw_client_id(struct ishtp_fw_client *fw_client)\n{\n\treturn fw_client->client_id;\n}\nEXPORT_SYMBOL(ishtp_get_fw_client_id);\n\n \nint ishtp_fw_cl_by_id(struct ishtp_device *dev, uint8_t client_id)\n{\n\tint i, res = -ENOENT;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&dev->fw_clients_lock, flags);\n\tfor (i = 0; i < dev->fw_clients_num; i++) {\n\t\tif (dev->fw_clients[i].client_id == client_id) {\n\t\t\tres = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->fw_clients_lock, flags);\n\n\treturn res;\n}\n\n \nstatic int ishtp_cl_device_probe(struct device *dev)\n{\n\tstruct ishtp_cl_device *device = to_ishtp_cl_device(dev);\n\tstruct ishtp_cl_driver *driver;\n\n\tif (!device)\n\t\treturn 0;\n\n\tdriver = to_ishtp_cl_driver(dev->driver);\n\tif (!driver || !driver->probe)\n\t\treturn -ENODEV;\n\n\treturn driver->probe(device);\n}\n\n \nstatic int ishtp_cl_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct ishtp_cl_device *device = to_ishtp_cl_device(dev);\n\tstruct ishtp_cl_driver *driver = to_ishtp_cl_driver(drv);\n\n\treturn(device->fw_client ? guid_equal(&driver->id[0].guid,\n\t       &device->fw_client->props.protocol_name) : 0);\n}\n\n \nstatic void ishtp_cl_device_remove(struct device *dev)\n{\n\tstruct ishtp_cl_device *device = to_ishtp_cl_device(dev);\n\tstruct ishtp_cl_driver *driver = to_ishtp_cl_driver(dev->driver);\n\n\tif (device->event_cb) {\n\t\tdevice->event_cb = NULL;\n\t\tcancel_work_sync(&device->event_work);\n\t}\n\n\tif (driver->remove)\n\t\tdriver->remove(device);\n}\n\n \nstatic int ishtp_cl_device_suspend(struct device *dev)\n{\n\tstruct ishtp_cl_device *device = to_ishtp_cl_device(dev);\n\tstruct ishtp_cl_driver *driver;\n\tint ret = 0;\n\n\tif (!device)\n\t\treturn 0;\n\n\tdriver = to_ishtp_cl_driver(dev->driver);\n\tif (driver && driver->driver.pm) {\n\t\tif (driver->driver.pm->suspend)\n\t\t\tret = driver->driver.pm->suspend(dev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ishtp_cl_device_resume(struct device *dev)\n{\n\tstruct ishtp_cl_device *device = to_ishtp_cl_device(dev);\n\tstruct ishtp_cl_driver *driver;\n\tint ret = 0;\n\n\tif (!device)\n\t\treturn 0;\n\n\tdriver = to_ishtp_cl_driver(dev->driver);\n\tif (driver && driver->driver.pm) {\n\t\tif (driver->driver.pm->resume)\n\t\t\tret = driver->driver.pm->resume(dev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ishtp_cl_device_reset(struct ishtp_cl_device *device)\n{\n\tstruct ishtp_cl_driver *driver;\n\tint ret = 0;\n\n\tdevice->event_cb = NULL;\n\tcancel_work_sync(&device->event_work);\n\n\tdriver = to_ishtp_cl_driver(device->dev.driver);\n\tif (driver && driver->reset)\n\t\tret = driver->reset(device);\n\n\treturn ret;\n}\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *a,\n\tchar *buf)\n{\n\tint len;\n\n\tlen = snprintf(buf, PAGE_SIZE, ISHTP_MODULE_PREFIX \"%s\\n\", dev_name(dev));\n\treturn (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *ishtp_cl_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ishtp_cl_dev);\n\nstatic int ishtp_cl_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tif (add_uevent_var(env, \"MODALIAS=\" ISHTP_MODULE_PREFIX \"%s\", dev_name(dev)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ishtp_cl_bus_dev_pm_ops = {\n\t \n\t.suspend = ishtp_cl_device_suspend,\n\t.resume = ishtp_cl_device_resume,\n\t \n\t.freeze = ishtp_cl_device_suspend,\n\t.thaw = ishtp_cl_device_resume,\n\t.restore = ishtp_cl_device_resume,\n};\n\nstatic struct bus_type ishtp_cl_bus_type = {\n\t.name\t\t= \"ishtp\",\n\t.dev_groups\t= ishtp_cl_dev_groups,\n\t.probe\t\t= ishtp_cl_device_probe,\n\t.match\t\t= ishtp_cl_bus_match,\n\t.remove\t\t= ishtp_cl_device_remove,\n\t.pm\t\t= &ishtp_cl_bus_dev_pm_ops,\n\t.uevent\t\t= ishtp_cl_uevent,\n};\n\nstatic void ishtp_cl_dev_release(struct device *dev)\n{\n\tkfree(to_ishtp_cl_device(dev));\n}\n\nstatic const struct device_type ishtp_cl_device_type = {\n\t.release\t= ishtp_cl_dev_release,\n};\n\n \nstatic struct ishtp_cl_device *ishtp_bus_add_device(struct ishtp_device *dev,\n\t\t\t\t\t\t    guid_t uuid, char *name)\n{\n\tstruct ishtp_cl_device *device;\n\tint status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->device_list_lock, flags);\n\tlist_for_each_entry(device, &dev->device_list, device_link) {\n\t\tif (!strcmp(name, dev_name(&device->dev))) {\n\t\t\tdevice->fw_client = &dev->fw_clients[\n\t\t\t\tdev->fw_client_presentation_num - 1];\n\t\t\tspin_unlock_irqrestore(&dev->device_list_lock, flags);\n\t\t\tishtp_cl_device_reset(device);\n\t\t\treturn device;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->device_list_lock, flags);\n\n\tdevice = kzalloc(sizeof(struct ishtp_cl_device), GFP_KERNEL);\n\tif (!device)\n\t\treturn NULL;\n\n\tdevice->dev.parent = dev->devc;\n\tdevice->dev.bus = &ishtp_cl_bus_type;\n\tdevice->dev.type = &ishtp_cl_device_type;\n\tdevice->ishtp_dev = dev;\n\n\tdevice->fw_client =\n\t\t&dev->fw_clients[dev->fw_client_presentation_num - 1];\n\n\tdev_set_name(&device->dev, \"%s\", name);\n\n\tspin_lock_irqsave(&dev->device_list_lock, flags);\n\tlist_add_tail(&device->device_link, &dev->device_list);\n\tspin_unlock_irqrestore(&dev->device_list_lock, flags);\n\n\tstatus = device_register(&device->dev);\n\tif (status) {\n\t\tspin_lock_irqsave(&dev->device_list_lock, flags);\n\t\tlist_del(&device->device_link);\n\t\tspin_unlock_irqrestore(&dev->device_list_lock, flags);\n\t\tdev_err(dev->devc, \"Failed to register ISHTP client device\\n\");\n\t\tput_device(&device->dev);\n\t\treturn NULL;\n\t}\n\n\tishtp_device_ready = true;\n\n\treturn device;\n}\n\n \nstatic void ishtp_bus_remove_device(struct ishtp_cl_device *device)\n{\n\tdevice_unregister(&device->dev);\n}\n\n \nint ishtp_cl_driver_register(struct ishtp_cl_driver *driver,\n\t\t\t     struct module *owner)\n{\n\tif (!ishtp_device_ready)\n\t\treturn -ENODEV;\n\n\tdriver->driver.name = driver->name;\n\tdriver->driver.owner = owner;\n\tdriver->driver.bus = &ishtp_cl_bus_type;\n\n\treturn driver_register(&driver->driver);\n}\nEXPORT_SYMBOL(ishtp_cl_driver_register);\n\n \nvoid ishtp_cl_driver_unregister(struct ishtp_cl_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL(ishtp_cl_driver_unregister);\n\n \nstatic void ishtp_bus_event_work(struct work_struct *work)\n{\n\tstruct ishtp_cl_device *device;\n\n\tdevice = container_of(work, struct ishtp_cl_device, event_work);\n\n\tif (device->event_cb)\n\t\tdevice->event_cb(device);\n}\n\n \nvoid ishtp_cl_bus_rx_event(struct ishtp_cl_device *device)\n{\n\tif (!device || !device->event_cb)\n\t\treturn;\n\n\tif (device->event_cb)\n\t\tschedule_work(&device->event_work);\n}\n\n \nint ishtp_register_event_cb(struct ishtp_cl_device *device,\n\tvoid (*event_cb)(struct ishtp_cl_device *))\n{\n\tif (device->event_cb)\n\t\treturn -EALREADY;\n\n\tdevice->event_cb = event_cb;\n\tINIT_WORK(&device->event_work, ishtp_bus_event_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ishtp_register_event_cb);\n\n \nvoid ishtp_get_device(struct ishtp_cl_device *cl_device)\n{\n\tcl_device->reference_count++;\n}\nEXPORT_SYMBOL(ishtp_get_device);\n\n \nvoid ishtp_put_device(struct ishtp_cl_device *cl_device)\n{\n\tcl_device->reference_count--;\n}\nEXPORT_SYMBOL(ishtp_put_device);\n\n \nvoid ishtp_set_drvdata(struct ishtp_cl_device *cl_device, void *data)\n{\n\tcl_device->driver_data = data;\n}\nEXPORT_SYMBOL(ishtp_set_drvdata);\n\n \nvoid *ishtp_get_drvdata(struct ishtp_cl_device *cl_device)\n{\n\treturn cl_device->driver_data;\n}\nEXPORT_SYMBOL(ishtp_get_drvdata);\n\n \nstruct ishtp_cl_device *ishtp_dev_to_cl_device(struct device *device)\n{\n\treturn to_ishtp_cl_device(device);\n}\nEXPORT_SYMBOL(ishtp_dev_to_cl_device);\n\n \nint ishtp_bus_new_client(struct ishtp_device *dev)\n{\n\tint\ti;\n\tchar\t*dev_name;\n\tstruct ishtp_cl_device\t*cl_device;\n\tguid_t\tdevice_uuid;\n\n\t \n\ti = dev->fw_client_presentation_num - 1;\n\tdevice_uuid = dev->fw_clients[i].props.protocol_name;\n\tdev_name = kasprintf(GFP_KERNEL, \"{%pUL}\", &device_uuid);\n\tif (!dev_name)\n\t\treturn\t-ENOMEM;\n\n\tcl_device = ishtp_bus_add_device(dev, device_uuid, dev_name);\n\tif (!cl_device) {\n\t\tkfree(dev_name);\n\t\treturn\t-ENOENT;\n\t}\n\n\tkfree(dev_name);\n\n\treturn\t0;\n}\n\n \nint ishtp_cl_device_bind(struct ishtp_cl *cl)\n{\n\tstruct ishtp_cl_device\t*cl_device;\n\tunsigned long flags;\n\tint\trv;\n\n\tif (!cl->fw_client_id || cl->state != ISHTP_CL_CONNECTED)\n\t\treturn\t-EFAULT;\n\n\trv = -ENOENT;\n\tspin_lock_irqsave(&cl->dev->device_list_lock, flags);\n\tlist_for_each_entry(cl_device, &cl->dev->device_list,\n\t\t\tdevice_link) {\n\t\tif (cl_device->fw_client &&\n\t\t    cl_device->fw_client->client_id == cl->fw_client_id) {\n\t\t\tcl->device = cl_device;\n\t\t\trv = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cl->dev->device_list_lock, flags);\n\treturn\trv;\n}\n\n \nvoid ishtp_bus_remove_all_clients(struct ishtp_device *ishtp_dev,\n\t\t\t\t  bool warm_reset)\n{\n\tstruct ishtp_cl_device\t*cl_device, *n;\n\tstruct ishtp_cl\t*cl;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&ishtp_dev->cl_list_lock, flags);\n\tlist_for_each_entry(cl, &ishtp_dev->cl_list, link) {\n\t\tcl->state = ISHTP_CL_DISCONNECTED;\n\n\t\t \n\t\twake_up_interruptible(&cl->wait_ctrl_res);\n\n\t\t \n\t\tishtp_cl_flush_queues(cl);\n\n\t\t \n\t\tishtp_cl_free_rx_ring(cl);\n\t\tishtp_cl_free_tx_ring(cl);\n\n\t\t \n\t}\n\tspin_unlock_irqrestore(&ishtp_dev->cl_list_lock, flags);\n\n\t \n\tishtp_cl_free_dma_buf(ishtp_dev);\n\n\t \n\tspin_lock_irqsave(&ishtp_dev->device_list_lock, flags);\n\tlist_for_each_entry_safe(cl_device, n, &ishtp_dev->device_list,\n\t\t\t\t device_link) {\n\t\tcl_device->fw_client = NULL;\n\t\tif (warm_reset && cl_device->reference_count)\n\t\t\tcontinue;\n\n\t\tlist_del(&cl_device->device_link);\n\t\tspin_unlock_irqrestore(&ishtp_dev->device_list_lock, flags);\n\t\tishtp_bus_remove_device(cl_device);\n\t\tspin_lock_irqsave(&ishtp_dev->device_list_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&ishtp_dev->device_list_lock, flags);\n\n\t \n\tspin_lock_irqsave(&ishtp_dev->fw_clients_lock, flags);\n\tkfree(ishtp_dev->fw_clients);\n\tishtp_dev->fw_clients = NULL;\n\tishtp_dev->fw_clients_num = 0;\n\tishtp_dev->fw_client_presentation_num = 0;\n\tishtp_dev->fw_client_index = 0;\n\tbitmap_zero(ishtp_dev->fw_clients_map, ISHTP_CLIENTS_MAX);\n\tspin_unlock_irqrestore(&ishtp_dev->fw_clients_lock, flags);\n}\nEXPORT_SYMBOL(ishtp_bus_remove_all_clients);\n\n \nvoid ishtp_reset_handler(struct ishtp_device *dev)\n{\n\tunsigned long\tflags;\n\n\t \n\tdev->dev_state = ISHTP_DEV_RESETTING;\n\n\t \n\tspin_lock_irqsave(&dev->rd_msg_spinlock, flags);\n\tdev->rd_msg_fifo_head = dev->rd_msg_fifo_tail = 0;\n\tspin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);\n\n\t \n\tishtp_bus_remove_all_clients(dev, true);\n}\nEXPORT_SYMBOL(ishtp_reset_handler);\n\n \nvoid ishtp_reset_compl_handler(struct ishtp_device *dev)\n{\n\tdev->dev_state = ISHTP_DEV_INIT_CLIENTS;\n\tdev->hbm_state = ISHTP_HBM_START;\n\tishtp_hbm_start_req(dev);\n}\nEXPORT_SYMBOL(ishtp_reset_compl_handler);\n\n \nint ishtp_use_dma_transfer(void)\n{\n\treturn ishtp_use_dma;\n}\n\n \nstruct device *ishtp_device(struct ishtp_cl_device *device)\n{\n\treturn &device->dev;\n}\nEXPORT_SYMBOL(ishtp_device);\n\n \nbool ishtp_wait_resume(struct ishtp_device *dev)\n{\n\t \n\t#define WAIT_FOR_RESUME_ACK_MS\t\t50\n\n\t \n\tif (dev->resume_flag)\n\t\twait_event_interruptible_timeout(dev->resume_wait,\n\t\t\t\t\t\t !dev->resume_flag,\n\t\t\t\t\t\t msecs_to_jiffies(WAIT_FOR_RESUME_ACK_MS));\n\n\treturn (!dev->resume_flag);\n}\nEXPORT_SYMBOL_GPL(ishtp_wait_resume);\n\n \nstruct device *ishtp_get_pci_device(struct ishtp_cl_device *device)\n{\n\treturn device->ishtp_dev->devc;\n}\nEXPORT_SYMBOL(ishtp_get_pci_device);\n\n \nishtp_print_log ishtp_trace_callback(struct ishtp_cl_device *cl_device)\n{\n\treturn cl_device->ishtp_dev->print_log;\n}\nEXPORT_SYMBOL(ishtp_trace_callback);\n\n \nint ish_hw_reset(struct ishtp_device *dev)\n{\n\treturn dev->ops->hw_reset(dev);\n}\nEXPORT_SYMBOL(ish_hw_reset);\n\n \nstatic int  __init ishtp_bus_register(void)\n{\n\treturn bus_register(&ishtp_cl_bus_type);\n}\n\n \nstatic void __exit ishtp_bus_unregister(void)\n{\n\tbus_unregister(&ishtp_cl_bus_type);\n}\n\nmodule_init(ishtp_bus_register);\nmodule_exit(ishtp_bus_unregister);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}