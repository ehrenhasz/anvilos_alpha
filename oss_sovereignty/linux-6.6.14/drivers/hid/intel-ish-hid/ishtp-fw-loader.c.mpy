{
  "module_name": "ishtp-fw-loader.c",
  "hash_id": "257ff9f8fd1e5b0472b930c5cde978cd51a39697fc4adf6740db89b5f67540d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/intel-ish-hid/ishtp-fw-loader.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/intel-ish-client-if.h>\n#include <linux/property.h>\n#include <asm/cacheflush.h>\n\n \n#define MAX_LOAD_ATTEMPTS\t\t\t3\n\n \n#define LOADER_CL_RX_RING_SIZE\t\t\t1\n#define LOADER_CL_TX_RING_SIZE\t\t\t1\n\n \n#define LOADER_SHIM_IPC_BUF_SIZE\t\t3968\n\n \nenum ish_loader_commands {\n\tLOADER_CMD_XFER_QUERY = 0,\n\tLOADER_CMD_XFER_FRAGMENT,\n\tLOADER_CMD_START,\n};\n\n \n#define\tCMD_MASK\t\t\t\tGENMASK(6, 0)\n#define\tIS_RESPONSE\t\t\t\tBIT(7)\n\n \n#define ISHTP_SEND_TIMEOUT\t\t\t(3 * HZ)\n\n \n#define LOADER_XFER_MODE_DIRECT_DMA\t\tBIT(0)\n#define LOADER_XFER_MODE_ISHTP\t\t\tBIT(1)\n\n \nstatic const struct ishtp_device_id loader_ishtp_id_table[] = {\n\t{ .guid = GUID_INIT(0xc804d06a, 0x55bd, 0x4ea7,\n\t\t  0xad, 0xed, 0x1e, 0x31, 0x22, 0x8c, 0x76, 0xdc) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(ishtp, loader_ishtp_id_table);\n\n#define FILENAME_SIZE\t\t\t\t256\n\n \nstatic int dma_buf_size_limit = 4 * PAGE_SIZE;\n\n \nstruct loader_msg_hdr {\n\tu8 command;\n\tu8 reserved[2];\n\tu8 status;\n} __packed;\n\nstruct loader_xfer_query {\n\tstruct loader_msg_hdr hdr;\n\tu32 image_size;\n} __packed;\n\nstruct ish_fw_version {\n\tu16 major;\n\tu16 minor;\n\tu16 hotfix;\n\tu16 build;\n} __packed;\n\nunion loader_version {\n\tu32 value;\n\tstruct {\n\t\tu8 major;\n\t\tu8 minor;\n\t\tu8 hotfix;\n\t\tu8 build;\n\t};\n} __packed;\n\nstruct loader_capability {\n\tu32 max_fw_image_size;\n\tu32 xfer_mode;\n\tu32 max_dma_buf_size;  \n} __packed;\n\nstruct shim_fw_info {\n\tstruct ish_fw_version ish_fw_version;\n\tu32 protocol_version;\n\tunion loader_version ldr_version;\n\tstruct loader_capability ldr_capability;\n} __packed;\n\nstruct loader_xfer_query_response {\n\tstruct loader_msg_hdr hdr;\n\tstruct shim_fw_info fw_info;\n} __packed;\n\nstruct loader_xfer_fragment {\n\tstruct loader_msg_hdr hdr;\n\tu32 xfer_mode;\n\tu32 offset;\n\tu32 size;\n\tu32 is_last;\n} __packed;\n\nstruct loader_xfer_ipc_fragment {\n\tstruct loader_xfer_fragment fragment;\n\tu8 data[] ____cacheline_aligned;  \n} __packed;\n\nstruct loader_xfer_dma_fragment {\n\tstruct loader_xfer_fragment fragment;\n\tu64 ddr_phys_addr;\n} __packed;\n\nstruct loader_start {\n\tstruct loader_msg_hdr hdr;\n} __packed;\n\n \nstruct response_info {\n\tvoid *data;\n\tsize_t max_size;\n\tsize_t size;\n\tint error;\n\tbool received;\n\twait_queue_head_t wait_queue;\n};\n\n \nstruct ishtp_cl_data {\n\tstruct ishtp_cl *loader_ishtp_cl;\n\tstruct ishtp_cl_device *cl_device;\n\n\t \n\tstruct response_info response;\n\n\tstruct work_struct work_ishtp_reset;\n\tstruct work_struct work_fw_load;\n\n\t \n\tbool flag_retry;\n\tint retry_count;\n};\n\n#define IPC_FRAGMENT_DATA_PREAMBLE\t\t\t\t\\\n\toffsetof(struct loader_xfer_ipc_fragment, data)\n\n#define cl_data_to_dev(client_data) ishtp_device((client_data)->cl_device)\n\n \nstatic int get_firmware_variant(struct ishtp_cl_data *client_data,\n\t\t\t\tchar *filename)\n{\n\tint rv;\n\tconst char *val;\n\tstruct device *devc = ishtp_get_pci_device(client_data->cl_device);\n\n\trv = device_property_read_string(devc, \"firmware-name\", &val);\n\tif (rv < 0) {\n\t\tdev_err(devc,\n\t\t\t\"Error: ISH firmware-name device property required\\n\");\n\t\treturn rv;\n\t}\n\treturn snprintf(filename, FILENAME_SIZE, \"intel/%s\", val);\n}\n\n \nstatic int loader_cl_send(struct ishtp_cl_data *client_data,\n\t\t\t  u8 *out_msg, size_t out_size,\n\t\t\t  u8 *in_msg, size_t in_size)\n{\n\tint rv;\n\tstruct loader_msg_hdr *out_hdr = (struct loader_msg_hdr *)out_msg;\n\tstruct ishtp_cl *loader_ishtp_cl = client_data->loader_ishtp_cl;\n\n\tdev_dbg(cl_data_to_dev(client_data),\n\t\t\"%s: command=%02lx is_response=%u status=%02x\\n\",\n\t\t__func__,\n\t\tout_hdr->command & CMD_MASK,\n\t\tout_hdr->command & IS_RESPONSE ? 1 : 0,\n\t\tout_hdr->status);\n\n\t \n\tclient_data->response.data = in_msg;\n\tclient_data->response.max_size = in_size;\n\tclient_data->response.error = 0;\n\tclient_data->response.received = false;\n\n\trv = ishtp_cl_send(loader_ishtp_cl, out_msg, out_size);\n\tif (rv < 0) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ishtp_cl_send error %d\\n\", rv);\n\t\treturn rv;\n\t}\n\n\twait_event_interruptible_timeout(client_data->response.wait_queue,\n\t\t\t\t\t client_data->response.received,\n\t\t\t\t\t ISHTP_SEND_TIMEOUT);\n\tif (!client_data->response.received) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Timed out for response to command=%02lx\",\n\t\t\tout_hdr->command & CMD_MASK);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (client_data->response.error < 0)\n\t\treturn client_data->response.error;\n\n\treturn client_data->response.size;\n}\n\n \nstatic void process_recv(struct ishtp_cl *loader_ishtp_cl,\n\t\t\t struct ishtp_cl_rb *rb_in_proc)\n{\n\tstruct loader_msg_hdr *hdr;\n\tsize_t data_len = rb_in_proc->buf_idx;\n\tstruct ishtp_cl_data *client_data =\n\t\tishtp_get_client_data(loader_ishtp_cl);\n\n\t \n\tif (!client_data->response.data) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Receiving buffer is null. Should be allocated by calling function\\n\");\n\t\tclient_data->response.error = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tif (client_data->response.received) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Previous firmware message not yet processed\\n\");\n\t\tclient_data->response.error = -EINVAL;\n\t\tgoto end;\n\t}\n\t \n\tif (!rb_in_proc->buffer.data) {\n\t\tdev_warn(cl_data_to_dev(client_data),\n\t\t\t \"rb_in_proc->buffer.data returned null\");\n\t\tclient_data->response.error = -EBADMSG;\n\t\tgoto end;\n\t}\n\n\tif (data_len < sizeof(struct loader_msg_hdr)) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"data size %zu is less than header %zu\\n\",\n\t\t\tdata_len, sizeof(struct loader_msg_hdr));\n\t\tclient_data->response.error = -EMSGSIZE;\n\t\tgoto end;\n\t}\n\n\thdr = (struct loader_msg_hdr *)rb_in_proc->buffer.data;\n\n\tdev_dbg(cl_data_to_dev(client_data),\n\t\t\"%s: command=%02lx is_response=%u status=%02x\\n\",\n\t\t__func__,\n\t\thdr->command & CMD_MASK,\n\t\thdr->command & IS_RESPONSE ? 1 : 0,\n\t\thdr->status);\n\n\tif (((hdr->command & CMD_MASK) != LOADER_CMD_XFER_QUERY) &&\n\t    ((hdr->command & CMD_MASK) != LOADER_CMD_XFER_FRAGMENT) &&\n\t    ((hdr->command & CMD_MASK) != LOADER_CMD_START)) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Invalid command=%02lx\\n\",\n\t\t\thdr->command & CMD_MASK);\n\t\tclient_data->response.error = -EPROTO;\n\t\tgoto end;\n\t}\n\n\tif (data_len > client_data->response.max_size) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Received buffer size %zu is larger than allocated buffer %zu\\n\",\n\t\t\tdata_len, client_data->response.max_size);\n\t\tclient_data->response.error = -EMSGSIZE;\n\t\tgoto end;\n\t}\n\n\t \n\tif (!(hdr->command & IS_RESPONSE)) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Invalid response to command\\n\");\n\t\tclient_data->response.error = -EIO;\n\t\tgoto end;\n\t}\n\n\tif (hdr->status) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Loader returned status %d\\n\",\n\t\t\thdr->status);\n\t\tclient_data->response.error = -EIO;\n\t\tgoto end;\n\t}\n\n\t \n\tclient_data->response.size = data_len;\n\n\t \n\tmemcpy(client_data->response.data,\n\t       rb_in_proc->buffer.data, data_len);\n\n\t \n\tclient_data->response.received = true;\n\nend:\n\t \n\tishtp_cl_io_rb_recycle(rb_in_proc);\n\trb_in_proc = NULL;\n\n\t \n\twake_up_interruptible(&client_data->response.wait_queue);\n}\n\n \nstatic void loader_cl_event_cb(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl_rb *rb_in_proc;\n\tstruct ishtp_cl\t*loader_ishtp_cl = ishtp_get_drvdata(cl_device);\n\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(loader_ishtp_cl)) != NULL) {\n\t\t \n\t\tprocess_recv(loader_ishtp_cl, rb_in_proc);\n\t}\n}\n\n \nstatic int ish_query_loader_prop(struct ishtp_cl_data *client_data,\n\t\t\t\t const struct firmware *fw,\n\t\t\t\t struct shim_fw_info *fw_info)\n{\n\tint rv;\n\tstruct loader_xfer_query ldr_xfer_query;\n\tstruct loader_xfer_query_response ldr_xfer_query_resp;\n\n\tmemset(&ldr_xfer_query, 0, sizeof(ldr_xfer_query));\n\tldr_xfer_query.hdr.command = LOADER_CMD_XFER_QUERY;\n\tldr_xfer_query.image_size = fw->size;\n\trv = loader_cl_send(client_data,\n\t\t\t    (u8 *)&ldr_xfer_query,\n\t\t\t    sizeof(ldr_xfer_query),\n\t\t\t    (u8 *)&ldr_xfer_query_resp,\n\t\t\t    sizeof(ldr_xfer_query_resp));\n\tif (rv < 0) {\n\t\tclient_data->flag_retry = true;\n\t\t*fw_info = (struct shim_fw_info){};\n\t\treturn rv;\n\t}\n\n\t \n\tif (rv != sizeof(struct loader_xfer_query_response)) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"data size %d is not equal to size of loader_xfer_query_response %zu\\n\",\n\t\t\trv, sizeof(struct loader_xfer_query_response));\n\t\tclient_data->flag_retry = true;\n\t\t*fw_info = (struct shim_fw_info){};\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\t*fw_info = ldr_xfer_query_resp.fw_info;\n\n\t \n\tdev_dbg(cl_data_to_dev(client_data),\n\t\t\"ish_fw_version: major=%d minor=%d hotfix=%d build=%d protocol_version=0x%x loader_version=%d\\n\",\n\t\tfw_info->ish_fw_version.major,\n\t\tfw_info->ish_fw_version.minor,\n\t\tfw_info->ish_fw_version.hotfix,\n\t\tfw_info->ish_fw_version.build,\n\t\tfw_info->protocol_version,\n\t\tfw_info->ldr_version.value);\n\n\tdev_dbg(cl_data_to_dev(client_data),\n\t\t\"loader_capability: max_fw_image_size=0x%x xfer_mode=%d max_dma_buf_size=0x%x dma_buf_size_limit=0x%x\\n\",\n\t\tfw_info->ldr_capability.max_fw_image_size,\n\t\tfw_info->ldr_capability.xfer_mode,\n\t\tfw_info->ldr_capability.max_dma_buf_size,\n\t\tdma_buf_size_limit);\n\n\t \n\tif (fw_info->ldr_capability.max_fw_image_size < fw->size) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ISH firmware size %zu is greater than Shim firmware loader max supported %d\\n\",\n\t\t\tfw->size,\n\t\t\tfw_info->ldr_capability.max_fw_image_size);\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tif ((fw_info->ldr_capability.xfer_mode & LOADER_XFER_MODE_DIRECT_DMA) &&\n\t    (fw_info->ldr_capability.max_dma_buf_size % L1_CACHE_BYTES)) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Shim firmware loader buffer size %d should be multiple of cacheline\\n\",\n\t\t\tfw_info->ldr_capability.max_dma_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ish_fw_xfer_ishtp(struct ishtp_cl_data *client_data,\n\t\t\t     const struct firmware *fw)\n{\n\tint rv;\n\tu32 fragment_offset, fragment_size, payload_max_size;\n\tstruct loader_xfer_ipc_fragment *ldr_xfer_ipc_frag;\n\tstruct loader_msg_hdr ldr_xfer_ipc_ack;\n\n\tpayload_max_size =\n\t\tLOADER_SHIM_IPC_BUF_SIZE - IPC_FRAGMENT_DATA_PREAMBLE;\n\n\tldr_xfer_ipc_frag = kzalloc(LOADER_SHIM_IPC_BUF_SIZE, GFP_KERNEL);\n\tif (!ldr_xfer_ipc_frag) {\n\t\tclient_data->flag_retry = true;\n\t\treturn -ENOMEM;\n\t}\n\n\tldr_xfer_ipc_frag->fragment.hdr.command = LOADER_CMD_XFER_FRAGMENT;\n\tldr_xfer_ipc_frag->fragment.xfer_mode = LOADER_XFER_MODE_ISHTP;\n\n\t \n\tfragment_offset = 0;\n\twhile (fragment_offset < fw->size) {\n\t\tif (fragment_offset + payload_max_size < fw->size) {\n\t\t\tfragment_size = payload_max_size;\n\t\t\tldr_xfer_ipc_frag->fragment.is_last = 0;\n\t\t} else {\n\t\t\tfragment_size = fw->size - fragment_offset;\n\t\t\tldr_xfer_ipc_frag->fragment.is_last = 1;\n\t\t}\n\n\t\tldr_xfer_ipc_frag->fragment.offset = fragment_offset;\n\t\tldr_xfer_ipc_frag->fragment.size = fragment_size;\n\t\tmemcpy(ldr_xfer_ipc_frag->data,\n\t\t       &fw->data[fragment_offset],\n\t\t       fragment_size);\n\n\t\tdev_dbg(cl_data_to_dev(client_data),\n\t\t\t\"xfer_mode=ipc offset=0x%08x size=0x%08x is_last=%d\\n\",\n\t\t\tldr_xfer_ipc_frag->fragment.offset,\n\t\t\tldr_xfer_ipc_frag->fragment.size,\n\t\t\tldr_xfer_ipc_frag->fragment.is_last);\n\n\t\trv = loader_cl_send(client_data,\n\t\t\t\t    (u8 *)ldr_xfer_ipc_frag,\n\t\t\t\t    IPC_FRAGMENT_DATA_PREAMBLE + fragment_size,\n\t\t\t\t    (u8 *)&ldr_xfer_ipc_ack,\n\t\t\t\t    sizeof(ldr_xfer_ipc_ack));\n\t\tif (rv < 0) {\n\t\t\tclient_data->flag_retry = true;\n\t\t\tgoto end_err_resp_buf_release;\n\t\t}\n\n\t\tfragment_offset += fragment_size;\n\t}\n\n\tkfree(ldr_xfer_ipc_frag);\n\treturn 0;\n\nend_err_resp_buf_release:\n\t \n\tkfree(ldr_xfer_ipc_frag);\n\treturn rv;\n}\n\n \nstatic int ish_fw_xfer_direct_dma(struct ishtp_cl_data *client_data,\n\t\t\t\t  const struct firmware *fw,\n\t\t\t\t  const struct shim_fw_info fw_info)\n{\n\tint rv;\n\tvoid *dma_buf;\n\tdma_addr_t dma_buf_phy;\n\tu32 fragment_offset, fragment_size, payload_max_size;\n\tstruct loader_msg_hdr ldr_xfer_dma_frag_ack;\n\tstruct loader_xfer_dma_fragment ldr_xfer_dma_frag;\n\tstruct device *devc = ishtp_get_pci_device(client_data->cl_device);\n\tu32 shim_fw_buf_size =\n\t\tfw_info.ldr_capability.max_dma_buf_size;\n\n\t \n\tpayload_max_size = min3(fw->size,\n\t\t\t\t(size_t)shim_fw_buf_size,\n\t\t\t\t(size_t)dma_buf_size_limit);\n\n\t \n\tpayload_max_size &= ~(L1_CACHE_BYTES - 1);\n\n\tdma_buf = dma_alloc_coherent(devc, payload_max_size, &dma_buf_phy, GFP_KERNEL);\n\tif (!dma_buf) {\n\t\tclient_data->flag_retry = true;\n\t\treturn -ENOMEM;\n\t}\n\n\tldr_xfer_dma_frag.fragment.hdr.command = LOADER_CMD_XFER_FRAGMENT;\n\tldr_xfer_dma_frag.fragment.xfer_mode = LOADER_XFER_MODE_DIRECT_DMA;\n\tldr_xfer_dma_frag.ddr_phys_addr = (u64)dma_buf_phy;\n\n\t \n\tfragment_offset = 0;\n\twhile (fragment_offset < fw->size) {\n\t\tif (fragment_offset + payload_max_size < fw->size) {\n\t\t\tfragment_size = payload_max_size;\n\t\t\tldr_xfer_dma_frag.fragment.is_last = 0;\n\t\t} else {\n\t\t\tfragment_size = fw->size - fragment_offset;\n\t\t\tldr_xfer_dma_frag.fragment.is_last = 1;\n\t\t}\n\n\t\tldr_xfer_dma_frag.fragment.offset = fragment_offset;\n\t\tldr_xfer_dma_frag.fragment.size = fragment_size;\n\t\tmemcpy(dma_buf, &fw->data[fragment_offset], fragment_size);\n\n\t\t \n\t\tclflush_cache_range(dma_buf, payload_max_size);\n\n\t\tdev_dbg(cl_data_to_dev(client_data),\n\t\t\t\"xfer_mode=dma offset=0x%08x size=0x%x is_last=%d ddr_phys_addr=0x%016llx\\n\",\n\t\t\tldr_xfer_dma_frag.fragment.offset,\n\t\t\tldr_xfer_dma_frag.fragment.size,\n\t\t\tldr_xfer_dma_frag.fragment.is_last,\n\t\t\tldr_xfer_dma_frag.ddr_phys_addr);\n\n\t\trv = loader_cl_send(client_data,\n\t\t\t\t    (u8 *)&ldr_xfer_dma_frag,\n\t\t\t\t    sizeof(ldr_xfer_dma_frag),\n\t\t\t\t    (u8 *)&ldr_xfer_dma_frag_ack,\n\t\t\t\t    sizeof(ldr_xfer_dma_frag_ack));\n\t\tif (rv < 0) {\n\t\t\tclient_data->flag_retry = true;\n\t\t\tgoto end_err_resp_buf_release;\n\t\t}\n\n\t\tfragment_offset += fragment_size;\n\t}\n\nend_err_resp_buf_release:\n\tdma_free_coherent(devc, payload_max_size, dma_buf, dma_buf_phy);\n\treturn rv;\n}\n\n \nstatic int ish_fw_start(struct ishtp_cl_data *client_data)\n{\n\tstruct loader_start ldr_start;\n\tstruct loader_msg_hdr ldr_start_ack;\n\n\tmemset(&ldr_start, 0, sizeof(ldr_start));\n\tldr_start.hdr.command = LOADER_CMD_START;\n\treturn loader_cl_send(client_data,\n\t\t\t    (u8 *)&ldr_start,\n\t\t\t    sizeof(ldr_start),\n\t\t\t    (u8 *)&ldr_start_ack,\n\t\t\t    sizeof(ldr_start_ack));\n}\n\n \nstatic int load_fw_from_host(struct ishtp_cl_data *client_data)\n{\n\tint rv;\n\tu32 xfer_mode;\n\tchar *filename;\n\tconst struct firmware *fw;\n\tstruct shim_fw_info fw_info;\n\tstruct ishtp_cl *loader_ishtp_cl = client_data->loader_ishtp_cl;\n\n\tclient_data->flag_retry = false;\n\n\tfilename = kzalloc(FILENAME_SIZE, GFP_KERNEL);\n\tif (!filename) {\n\t\tclient_data->flag_retry = true;\n\t\trv = -ENOMEM;\n\t\tgoto end_error;\n\t}\n\n\t \n\trv = get_firmware_variant(client_data, filename);\n\tif (rv < 0)\n\t\tgoto end_err_filename_buf_release;\n\n\trv = request_firmware(&fw, filename, cl_data_to_dev(client_data));\n\tif (rv < 0)\n\t\tgoto end_err_filename_buf_release;\n\n\t \n\n\trv = ish_query_loader_prop(client_data, fw, &fw_info);\n\tif (rv < 0)\n\t\tgoto end_err_fw_release;\n\n\t \n\n\txfer_mode = fw_info.ldr_capability.xfer_mode;\n\tif (xfer_mode & LOADER_XFER_MODE_DIRECT_DMA) {\n\t\trv = ish_fw_xfer_direct_dma(client_data, fw, fw_info);\n\t} else if (xfer_mode & LOADER_XFER_MODE_ISHTP) {\n\t\trv = ish_fw_xfer_ishtp(client_data, fw);\n\t} else {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"No transfer mode selected in firmware\\n\");\n\t\trv = -EINVAL;\n\t}\n\tif (rv < 0)\n\t\tgoto end_err_fw_release;\n\n\t \n\n\trv = ish_fw_start(client_data);\n\tif (rv < 0)\n\t\tgoto end_err_fw_release;\n\n\trelease_firmware(fw);\n\tdev_info(cl_data_to_dev(client_data), \"ISH firmware %s loaded\\n\",\n\t\t filename);\n\tkfree(filename);\n\treturn 0;\n\nend_err_fw_release:\n\trelease_firmware(fw);\nend_err_filename_buf_release:\n\tkfree(filename);\nend_error:\n\t \n\tif (client_data->flag_retry &&\n\t    client_data->retry_count++ < MAX_LOAD_ATTEMPTS) {\n\t\tdev_warn(cl_data_to_dev(client_data),\n\t\t\t \"ISH host firmware load failed %d. Resetting ISH, and trying again..\\n\",\n\t\t\t rv);\n\t\tish_hw_reset(ishtp_get_ishtp_device(loader_ishtp_cl));\n\t} else {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ISH host firmware load failed %d\\n\", rv);\n\t}\n\treturn rv;\n}\n\nstatic void load_fw_from_host_handler(struct work_struct *work)\n{\n\tstruct ishtp_cl_data *client_data;\n\n\tclient_data = container_of(work, struct ishtp_cl_data,\n\t\t\t\t   work_fw_load);\n\tload_fw_from_host(client_data);\n}\n\n \nstatic int loader_init(struct ishtp_cl *loader_ishtp_cl, int reset)\n{\n\tint rv;\n\tstruct ishtp_fw_client *fw_client;\n\tstruct ishtp_cl_data *client_data =\n\t\tishtp_get_client_data(loader_ishtp_cl);\n\n\tdev_dbg(cl_data_to_dev(client_data), \"reset flag: %d\\n\", reset);\n\n\trv = ishtp_cl_link(loader_ishtp_cl);\n\tif (rv < 0) {\n\t\tdev_err(cl_data_to_dev(client_data), \"ishtp_cl_link failed\\n\");\n\t\treturn rv;\n\t}\n\n\t \n\tishtp_set_tx_ring_size(loader_ishtp_cl, LOADER_CL_TX_RING_SIZE);\n\tishtp_set_rx_ring_size(loader_ishtp_cl, LOADER_CL_RX_RING_SIZE);\n\n\tfw_client =\n\t\tishtp_fw_cl_get_client(ishtp_get_ishtp_device(loader_ishtp_cl),\n\t\t\t\t       &loader_ishtp_id_table[0].guid);\n\tif (!fw_client) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ISH client uuid not found\\n\");\n\t\trv = -ENOENT;\n\t\tgoto err_cl_unlink;\n\t}\n\n\tishtp_cl_set_fw_client_id(loader_ishtp_cl,\n\t\t\t\t  ishtp_get_fw_client_id(fw_client));\n\tishtp_set_connection_state(loader_ishtp_cl, ISHTP_CL_CONNECTING);\n\n\trv = ishtp_cl_connect(loader_ishtp_cl);\n\tif (rv < 0) {\n\t\tdev_err(cl_data_to_dev(client_data), \"Client connect fail\\n\");\n\t\tgoto err_cl_unlink;\n\t}\n\n\tdev_dbg(cl_data_to_dev(client_data), \"Client connected\\n\");\n\n\tishtp_register_event_cb(client_data->cl_device, loader_cl_event_cb);\n\n\treturn 0;\n\nerr_cl_unlink:\n\tishtp_cl_unlink(loader_ishtp_cl);\n\treturn rv;\n}\n\nstatic void loader_deinit(struct ishtp_cl *loader_ishtp_cl)\n{\n\tishtp_set_connection_state(loader_ishtp_cl, ISHTP_CL_DISCONNECTING);\n\tishtp_cl_disconnect(loader_ishtp_cl);\n\tishtp_cl_unlink(loader_ishtp_cl);\n\tishtp_cl_flush_queues(loader_ishtp_cl);\n\n\t \n\tishtp_cl_free(loader_ishtp_cl);\n}\n\nstatic void reset_handler(struct work_struct *work)\n{\n\tint rv;\n\tstruct ishtp_cl_data *client_data;\n\tstruct ishtp_cl *loader_ishtp_cl;\n\tstruct ishtp_cl_device *cl_device;\n\n\tclient_data = container_of(work, struct ishtp_cl_data,\n\t\t\t\t   work_ishtp_reset);\n\n\tloader_ishtp_cl = client_data->loader_ishtp_cl;\n\tcl_device = client_data->cl_device;\n\n\t \n\tishtp_cl_unlink(loader_ishtp_cl);\n\tishtp_cl_flush_queues(loader_ishtp_cl);\n\tishtp_cl_free(loader_ishtp_cl);\n\n\tloader_ishtp_cl = ishtp_cl_allocate(cl_device);\n\tif (!loader_ishtp_cl)\n\t\treturn;\n\n\tishtp_set_drvdata(cl_device, loader_ishtp_cl);\n\tishtp_set_client_data(loader_ishtp_cl, client_data);\n\tclient_data->loader_ishtp_cl = loader_ishtp_cl;\n\tclient_data->cl_device = cl_device;\n\n\trv = loader_init(loader_ishtp_cl, 1);\n\tif (rv < 0) {\n\t\tdev_err(ishtp_device(cl_device), \"Reset Failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tload_fw_from_host(client_data);\n}\n\n \nstatic int loader_ishtp_cl_probe(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl *loader_ishtp_cl;\n\tstruct ishtp_cl_data *client_data;\n\tint rv;\n\n\tclient_data = devm_kzalloc(ishtp_device(cl_device),\n\t\t\t\t   sizeof(*client_data),\n\t\t\t\t   GFP_KERNEL);\n\tif (!client_data)\n\t\treturn -ENOMEM;\n\n\tloader_ishtp_cl = ishtp_cl_allocate(cl_device);\n\tif (!loader_ishtp_cl)\n\t\treturn -ENOMEM;\n\n\tishtp_set_drvdata(cl_device, loader_ishtp_cl);\n\tishtp_set_client_data(loader_ishtp_cl, client_data);\n\tclient_data->loader_ishtp_cl = loader_ishtp_cl;\n\tclient_data->cl_device = cl_device;\n\n\tinit_waitqueue_head(&client_data->response.wait_queue);\n\n\tINIT_WORK(&client_data->work_ishtp_reset,\n\t\t  reset_handler);\n\tINIT_WORK(&client_data->work_fw_load,\n\t\t  load_fw_from_host_handler);\n\n\trv = loader_init(loader_ishtp_cl, 0);\n\tif (rv < 0) {\n\t\tishtp_cl_free(loader_ishtp_cl);\n\t\treturn rv;\n\t}\n\tishtp_get_device(cl_device);\n\n\tclient_data->retry_count = 0;\n\n\t \n\tschedule_work(&client_data->work_fw_load);\n\n\treturn 0;\n}\n\n \nstatic void loader_ishtp_cl_remove(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl_data *client_data;\n\tstruct ishtp_cl\t*loader_ishtp_cl = ishtp_get_drvdata(cl_device);\n\n\tclient_data = ishtp_get_client_data(loader_ishtp_cl);\n\n\t \n\tcancel_work_sync(&client_data->work_fw_load);\n\tcancel_work_sync(&client_data->work_ishtp_reset);\n\tloader_deinit(loader_ishtp_cl);\n\tishtp_put_device(cl_device);\n}\n\n \nstatic int loader_ishtp_cl_reset(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl_data *client_data;\n\tstruct ishtp_cl\t*loader_ishtp_cl = ishtp_get_drvdata(cl_device);\n\n\tclient_data = ishtp_get_client_data(loader_ishtp_cl);\n\n\tschedule_work(&client_data->work_ishtp_reset);\n\n\treturn 0;\n}\n\nstatic struct ishtp_cl_driver\tloader_ishtp_cl_driver = {\n\t.name = \"ish-loader\",\n\t.id = loader_ishtp_id_table,\n\t.probe = loader_ishtp_cl_probe,\n\t.remove = loader_ishtp_cl_remove,\n\t.reset = loader_ishtp_cl_reset,\n};\n\nstatic int __init ish_loader_init(void)\n{\n\treturn ishtp_cl_driver_register(&loader_ishtp_cl_driver, THIS_MODULE);\n}\n\nstatic void __exit ish_loader_exit(void)\n{\n\tishtp_cl_driver_unregister(&loader_ishtp_cl_driver);\n}\n\nlate_initcall(ish_loader_init);\nmodule_exit(ish_loader_exit);\n\nmodule_param(dma_buf_size_limit, int, 0644);\nMODULE_PARM_DESC(dma_buf_size_limit, \"Limit the DMA buf size to this value in bytes\");\n\nMODULE_DESCRIPTION(\"ISH ISH-TP Host firmware Loader Client Driver\");\nMODULE_AUTHOR(\"Rushikesh S Kadam <rushikesh.s.kadam@intel.com>\");\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}