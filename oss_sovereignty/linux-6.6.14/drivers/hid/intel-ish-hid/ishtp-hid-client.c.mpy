{
  "module_name": "ishtp-hid-client.c",
  "hash_id": "bde0629149295cc88a68a598073b39644fb666eba773397fb97e27883137a2b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/intel-ish-hid/ishtp-hid-client.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/hid.h>\n#include <linux/intel-ish-client-if.h>\n#include <linux/sched.h>\n#include \"ishtp-hid.h\"\n\n \nstatic const struct ishtp_device_id hid_ishtp_id_table[] = {\n\t{ .guid = GUID_INIT(0x33AECD58, 0xB679, 0x4E54,\n\t\t  0x9B, 0xD9, 0xA0, 0x4D, 0x34, 0xF0, 0xC2, 0x26), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(ishtp, hid_ishtp_id_table);\n\n \n#define HID_CL_RX_RING_SIZE\t32\n#define HID_CL_TX_RING_SIZE\t16\n\n#define cl_data_to_dev(client_data) ishtp_device(client_data->cl_device)\n\n \nstatic void report_bad_packet(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t      size_t cur_pos,  size_t payload_len)\n{\n\tstruct hostif_msg *recv_msg = recv_buf;\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\n\tdev_err(cl_data_to_dev(client_data), \"[hid-ish]: BAD packet %02X\\n\"\n\t\t\"total_bad=%u cur_pos=%u\\n\"\n\t\t\"[%02X %02X %02X %02X]\\n\"\n\t\t\"payload_len=%u\\n\"\n\t\t\"multi_packet_cnt=%u\\n\"\n\t\t\"is_response=%02X\\n\",\n\t\trecv_msg->hdr.command, client_data->bad_recv_cnt,\n\t\t(unsigned int)cur_pos,\n\t\t((unsigned char *)recv_msg)[0], ((unsigned char *)recv_msg)[1],\n\t\t((unsigned char *)recv_msg)[2], ((unsigned char *)recv_msg)[3],\n\t\t(unsigned int)payload_len, client_data->multi_packet_cnt,\n\t\trecv_msg->hdr.command & ~CMD_MASK);\n}\n\n \nstatic void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\n\t\t\t size_t data_len)\n{\n\tstruct hostif_msg *recv_msg;\n\tunsigned char *payload;\n\tstruct device_info *dev_info;\n\tint i, j;\n\tsize_t\tpayload_len, total_len, cur_pos, raw_len;\n\tint report_type;\n\tstruct report_list *reports_list;\n\tchar *reports;\n\tsize_t report_len;\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint curr_hid_dev = client_data->cur_hid_dev;\n\tstruct ishtp_hid_data *hid_data = NULL;\n\tstruct hid_device *hid = NULL;\n\n\tpayload = recv_buf + sizeof(struct hostif_msg_hdr);\n\ttotal_len = data_len;\n\tcur_pos = 0;\n\n\tdo {\n\t\tif (cur_pos + sizeof(struct hostif_msg) > total_len) {\n\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\"[hid-ish]: error, received %u which is less than data header %u\\n\",\n\t\t\t\t(unsigned int)data_len,\n\t\t\t\t(unsigned int)sizeof(struct hostif_msg_hdr));\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\tish_hw_reset(ishtp_get_ishtp_device(hid_ishtp_cl));\n\t\t\tbreak;\n\t\t}\n\n\t\trecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\n\t\tpayload_len = recv_msg->hdr.size;\n\n\t\t \n\t\tif (cur_pos + payload_len + sizeof(struct hostif_msg) >\n\t\t\t\ttotal_len) {\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t\tish_hw_reset(ishtp_get_ishtp_device(hid_ishtp_cl));\n\t\t\tbreak;\n\t\t}\n\n\t\thid_ishtp_trace(client_data,  \"%s %d\\n\",\n\t\t\t\t__func__, recv_msg->hdr.command & CMD_MASK);\n\n\t\tswitch (recv_msg->hdr.command & CMD_MASK) {\n\t\tcase HOSTIF_DM_ENUM_DEVICES:\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg,\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\t\tish_hw_reset(ishtp_get_ishtp_device(hid_ishtp_cl));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tclient_data->hid_dev_count = (unsigned int)*payload;\n\t\t\tif (!client_data->hid_devices)\n\t\t\t\tclient_data->hid_devices = devm_kcalloc(\n\t\t\t\t\t\tcl_data_to_dev(client_data),\n\t\t\t\t\t\tclient_data->hid_dev_count,\n\t\t\t\t\t\tsizeof(struct device_info),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!client_data->hid_devices) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\"Mem alloc failed for hid device info\\n\");\n\t\t\t\twake_up_interruptible(&client_data->init_wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i < client_data->hid_dev_count; ++i) {\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tpayload_len) {\n\t\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\t\t\"[hid-ish]: [ENUM_DEVICES]: content size %zu is bigger than payload_len %zu\\n\",\n\t\t\t\t\t\t1 + sizeof(struct device_info)\n\t\t\t\t\t\t* i, payload_len);\n\t\t\t\t}\n\n\t\t\t\tif (1 + sizeof(struct device_info) * i >=\n\t\t\t\t\t\tdata_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tdev_info = (struct device_info *)(payload + 1 +\n\t\t\t\t\tsizeof(struct device_info) * i);\n\t\t\t\tif (client_data->hid_devices)\n\t\t\t\t\tmemcpy(client_data->hid_devices + i,\n\t\t\t\t\t       dev_info,\n\t\t\t\t\t       sizeof(struct device_info));\n\t\t\t}\n\n\t\t\tclient_data->enum_devices_done = true;\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\n\t\t\tbreak;\n\n\t\tcase HOSTIF_GET_HID_DESCRIPTOR:\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg,\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\t\tish_hw_reset(ishtp_get_ishtp_device(hid_ishtp_cl));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!client_data->hid_descr[curr_hid_dev])\n\t\t\t\tclient_data->hid_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->hid_descr[curr_hid_dev]) {\n\t\t\t\tmemcpy(client_data->hid_descr[curr_hid_dev],\n\t\t\t\t       payload, payload_len);\n\t\t\t\tclient_data->hid_descr_size[curr_hid_dev] =\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->hid_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\n\t\t\tbreak;\n\n\t\tcase HOSTIF_GET_REPORT_DESCRIPTOR:\n\t\t\tif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\n\t\t\t\t\tclient_data->init_done)) {\n\t\t\t\t++client_data->bad_recv_cnt;\n\t\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg,\n\t\t\t\t\t\t  cur_pos,\n\t\t\t\t\t\t  payload_len);\n\t\t\t\tish_hw_reset(ishtp_get_ishtp_device(hid_ishtp_cl));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!client_data->report_descr[curr_hid_dev])\n\t\t\t\tclient_data->report_descr[curr_hid_dev] =\n\t\t\t\tdevm_kmalloc(cl_data_to_dev(client_data),\n\t\t\t\t\t     payload_len, GFP_KERNEL);\n\t\t\tif (client_data->report_descr[curr_hid_dev])  {\n\t\t\t\tmemcpy(client_data->report_descr[curr_hid_dev],\n\t\t\t\t       payload,\n\t\t\t\t       payload_len);\n\t\t\t\tclient_data->report_descr_size[curr_hid_dev] =\n\t\t\t\t\tpayload_len;\n\t\t\t\tclient_data->report_descr_done = true;\n\t\t\t}\n\t\t\twake_up_interruptible(&client_data->init_wait);\n\n\t\t\tbreak;\n\n\t\tcase HOSTIF_GET_FEATURE_REPORT:\n\t\t\treport_type = HID_FEATURE_REPORT;\n\t\t\tgoto\tdo_get_report;\n\n\t\tcase HOSTIF_GET_INPUT_REPORT:\n\t\t\treport_type = HID_INPUT_REPORT;\ndo_get_report:\n\t\t\t \n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\t  client_data->hid_devices[i].dev_id) {\n\t\t\t\t\thid = client_data->hid_sensor_hubs[i];\n\t\t\t\t\tif (!hid)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\thid_data = hid->driver_data;\n\t\t\t\t\tif (hid_data->raw_get_req) {\n\t\t\t\t\t\traw_len =\n\t\t\t\t\t\t  (hid_data->raw_buf_size <\n\t\t\t\t\t\t\t\tpayload_len) ?\n\t\t\t\t\t\t  hid_data->raw_buf_size :\n\t\t\t\t\t\t  payload_len;\n\n\t\t\t\t\t\tmemcpy(hid_data->raw_buf,\n\t\t\t\t\t\t       payload, raw_len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thid_input_report\n\t\t\t\t\t\t\t(hid, report_type,\n\t\t\t\t\t\t\t payload, payload_len,\n\t\t\t\t\t\t\t 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tishtp_hid_wakeup(hid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HOSTIF_SET_FEATURE_REPORT:\n\t\t\t \n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id)\n\t\t\t\t\tif (client_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\tishtp_hid_wakeup(\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\t\ti]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HOSTIF_PUBLISH_INPUT_REPORT:\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\tfor (i = 0; i < client_data->num_hid_devices; ++i)\n\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id)\n\t\t\t\t\tif (client_data->hid_sensor_hubs[i])\n\t\t\t\t\t\thid_input_report(\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\t\t\t\ti],\n\t\t\t\t\t\treport_type, payload,\n\t\t\t\t\t\tpayload_len, 0);\n\t\t\tbreak;\n\n\t\tcase HOSTIF_PUBLISH_INPUT_REPORT_LIST:\n\t\t\treport_type = HID_INPUT_REPORT;\n\t\t\treports_list = (struct report_list *)payload;\n\t\t\treports = (char *)reports_list->reports;\n\n\t\t\tfor (j = 0; j < reports_list->num_of_reports; j++) {\n\t\t\t\trecv_msg = (struct hostif_msg *)(reports +\n\t\t\t\t\tsizeof(uint16_t));\n\t\t\t\treport_len = *(uint16_t *)reports;\n\t\t\t\tpayload = reports + sizeof(uint16_t) +\n\t\t\t\t\tsizeof(struct hostif_msg_hdr);\n\t\t\t\tpayload_len = report_len -\n\t\t\t\t\tsizeof(struct hostif_msg_hdr);\n\n\t\t\t\tfor (i = 0; i < client_data->num_hid_devices;\n\t\t\t\t     ++i)\n\t\t\t\t\tif (recv_msg->hdr.device_id ==\n\t\t\t\t\tclient_data->hid_devices[i].dev_id &&\n\t\t\t\t\tclient_data->hid_sensor_hubs[i]) {\n\t\t\t\t\t\thid_input_report(\n\t\t\t\t\t\tclient_data->hid_sensor_hubs[\n\t\t\t\t\t\t\t\t\ti],\n\t\t\t\t\t\treport_type,\n\t\t\t\t\t\tpayload, payload_len,\n\t\t\t\t\t\t0);\n\t\t\t\t\t}\n\n\t\t\t\treports += sizeof(uint16_t) + report_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t++client_data->bad_recv_cnt;\n\t\t\treport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\n\t\t\t\t\t  payload_len);\n\t\t\tish_hw_reset(ishtp_get_ishtp_device(hid_ishtp_cl));\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif (!cur_pos && cur_pos + payload_len +\n\t\t\t\tsizeof(struct hostif_msg) < total_len)\n\t\t\t++client_data->multi_packet_cnt;\n\n\t\tcur_pos += payload_len + sizeof(struct hostif_msg);\n\t\tpayload += payload_len + sizeof(struct hostif_msg);\n\n\t} while (cur_pos < total_len);\n}\n\n \nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\n{\n\tstruct ishtp_cl\t*hid_ishtp_cl = ishtp_get_drvdata(device);\n\tstruct ishtp_cl_rb *rb_in_proc;\n\tsize_t r_length;\n\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(hid_ishtp_cl)) != NULL) {\n\t\tif (!rb_in_proc->buffer.data)\n\t\t\treturn;\n\n\t\tr_length = rb_in_proc->buf_idx;\n\n\t\t \n\t\tprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\n\n\t\tishtp_cl_io_rb_recycle(rb_in_proc);\n\t}\n}\n\n \nvoid hid_ishtp_set_feature(struct hid_device *hid, char *buf, unsigned int len,\n\t\t\t   int report_id)\n{\n\tstruct ishtp_hid_data *hid_data =  hid->driver_data;\n\tstruct ishtp_cl_data *client_data = hid_data->client_data;\n\tstruct hostif_msg *msg = (struct hostif_msg *)buf;\n\tint\trv;\n\tint\ti;\n\n\thid_ishtp_trace(client_data,  \"%s hid %p\\n\", __func__, hid);\n\n\trv = ishtp_hid_link_ready_wait(client_data);\n\tif (rv) {\n\t\thid_ishtp_trace(client_data,  \"%s hid %p link not ready\\n\",\n\t\t\t\t__func__, hid);\n\t\treturn;\n\t}\n\n\tmemset(msg, 0, sizeof(struct hostif_msg));\n\tmsg->hdr.command = HOSTIF_SET_FEATURE_REPORT;\n\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\tif (hid == client_data->hid_sensor_hubs[i]) {\n\t\t\tmsg->hdr.device_id =\n\t\t\t\tclient_data->hid_devices[i].dev_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == client_data->num_hid_devices)\n\t\treturn;\n\n\trv = ishtp_cl_send(client_data->hid_ishtp_cl, buf, len);\n\tif (rv)\n\t\thid_ishtp_trace(client_data,  \"%s hid %p send failed\\n\",\n\t\t\t\t__func__, hid);\n}\n\n \nvoid hid_ishtp_get_report(struct hid_device *hid, int report_id,\n\t\t\t  int report_type)\n{\n\tstruct ishtp_hid_data *hid_data =  hid->driver_data;\n\tstruct ishtp_cl_data *client_data = hid_data->client_data;\n\tstruct hostif_msg_to_sensor msg = {};\n\tint\trv;\n\tint\ti;\n\n\thid_ishtp_trace(client_data,  \"%s hid %p\\n\", __func__, hid);\n\trv = ishtp_hid_link_ready_wait(client_data);\n\tif (rv) {\n\t\thid_ishtp_trace(client_data,  \"%s hid %p link not ready\\n\",\n\t\t\t\t__func__, hid);\n\t\treturn;\n\t}\n\n\tmsg.hdr.command = (report_type == HID_FEATURE_REPORT) ?\n\t\tHOSTIF_GET_FEATURE_REPORT : HOSTIF_GET_INPUT_REPORT;\n\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\tif (hid == client_data->hid_sensor_hubs[i]) {\n\t\t\tmsg.hdr.device_id =\n\t\t\t\tclient_data->hid_devices[i].dev_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == client_data->num_hid_devices)\n\t\treturn;\n\n\tmsg.report_id = report_id;\n\trv = ishtp_cl_send(client_data->hid_ishtp_cl, (uint8_t *)&msg,\n\t\t\t    sizeof(msg));\n\tif (rv)\n\t\thid_ishtp_trace(client_data,  \"%s hid %p send failed\\n\",\n\t\t\t\t__func__, hid);\n}\n\n \nint ishtp_hid_link_ready_wait(struct ishtp_cl_data *client_data)\n{\n\tint rc;\n\n\tif (client_data->suspended) {\n\t\thid_ishtp_trace(client_data,  \"wait for link ready\\n\");\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\t\tclient_data->ishtp_resume_wait,\n\t\t\t\t\t!client_data->suspended,\n\t\t\t\t\t5 * HZ);\n\n\t\tif (rc == 0) {\n\t\t\thid_ishtp_trace(client_data,  \"link not ready\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\thid_ishtp_trace(client_data,  \"link ready\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ishtp_enum_enum_devices(struct ishtp_cl *hid_ishtp_cl)\n{\n\tstruct hostif_msg msg;\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint retry_count;\n\tint rv;\n\n\t \n\tmemset(&msg, 0, sizeof(struct hostif_msg));\n\tmsg.hdr.command = HOSTIF_DM_ENUM_DEVICES;\n\trv = ishtp_cl_send(hid_ishtp_cl, (unsigned char *)&msg,\n\t\t\t   sizeof(struct hostif_msg));\n\tif (rv)\n\t\treturn rv;\n\n\tretry_count = 0;\n\twhile (!client_data->enum_devices_done &&\n\t       retry_count < 10) {\n\t\twait_event_interruptible_timeout(client_data->init_wait,\n\t\t\t\t\t client_data->enum_devices_done,\n\t\t\t\t\t 3 * HZ);\n\t\t++retry_count;\n\t\tif (!client_data->enum_devices_done)\n\t\t\t \n\t\t\trv = ishtp_cl_send(hid_ishtp_cl,\n\t\t\t\t\t   (unsigned char *) &msg,\n\t\t\t\t\t   sizeof(struct hostif_msg));\n\t}\n\tif (!client_data->enum_devices_done) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"[hid-ish]: timed out waiting for enum_devices\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!client_data->hid_devices) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"[hid-ish]: failed to allocate HID dev structures\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tclient_data->num_hid_devices = client_data->hid_dev_count;\n\tdev_info(ishtp_device(client_data->cl_device),\n\t\t\"[hid-ish]: enum_devices_done OK, num_hid_devices=%d\\n\",\n\t\tclient_data->num_hid_devices);\n\n\treturn\t0;\n}\n\n \nstatic int ishtp_get_hid_descriptor(struct ishtp_cl *hid_ishtp_cl, int index)\n{\n\tstruct hostif_msg msg;\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint rv;\n\n\t \n\tclient_data->hid_descr_done = false;\n\tmemset(&msg, 0, sizeof(struct hostif_msg));\n\tmsg.hdr.command = HOSTIF_GET_HID_DESCRIPTOR;\n\tmsg.hdr.device_id = client_data->hid_devices[index].dev_id;\n\trv = ishtp_cl_send(hid_ishtp_cl, (unsigned char *) &msg,\n\t\t\t   sizeof(struct hostif_msg));\n\tif (rv)\n\t\treturn rv;\n\n\tif (!client_data->hid_descr_done) {\n\t\twait_event_interruptible_timeout(client_data->init_wait,\n\t\t\t\t\t\t client_data->hid_descr_done,\n\t\t\t\t\t\t 3 * HZ);\n\t\tif (!client_data->hid_descr_done) {\n\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\"[hid-ish]: timed out for hid_descr_done\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (!client_data->hid_descr[index]) {\n\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\"[hid-ish]: allocation HID desc fail\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ishtp_get_report_descriptor(struct ishtp_cl *hid_ishtp_cl,\n\t\t\t\t       int index)\n{\n\tstruct hostif_msg msg;\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tint rv;\n\n\t \n\tclient_data->report_descr_done = false;\n\tmemset(&msg, 0, sizeof(struct hostif_msg));\n\tmsg.hdr.command = HOSTIF_GET_REPORT_DESCRIPTOR;\n\tmsg.hdr.device_id = client_data->hid_devices[index].dev_id;\n\trv = ishtp_cl_send(hid_ishtp_cl, (unsigned char *) &msg,\n\t\t\t   sizeof(struct hostif_msg));\n\tif (rv)\n\t\treturn rv;\n\n\tif (!client_data->report_descr_done)\n\t\twait_event_interruptible_timeout(client_data->init_wait,\n\t\t\t\t\t client_data->report_descr_done,\n\t\t\t\t\t 3 * HZ);\n\tif (!client_data->report_descr_done) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\"[hid-ish]: timed out for report descr\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!client_data->report_descr[index]) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"[hid-ish]: failed to alloc report descr\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hid_ishtp_cl_init(struct ishtp_cl *hid_ishtp_cl, int reset)\n{\n\tstruct ishtp_device *dev;\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\tstruct ishtp_fw_client *fw_client;\n\tint i;\n\tint rv;\n\n\tdev_dbg(cl_data_to_dev(client_data), \"%s\\n\", __func__);\n\thid_ishtp_trace(client_data,  \"%s reset flag: %d\\n\", __func__, reset);\n\n\trv = ishtp_cl_link(hid_ishtp_cl);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ishtp_cl_link failed\\n\");\n\t\treturn\t-ENOMEM;\n\t}\n\n\tclient_data->init_done = 0;\n\n\tdev = ishtp_get_ishtp_device(hid_ishtp_cl);\n\n\t \n\tishtp_set_tx_ring_size(hid_ishtp_cl, HID_CL_TX_RING_SIZE);\n\tishtp_set_rx_ring_size(hid_ishtp_cl, HID_CL_RX_RING_SIZE);\n\n\tfw_client = ishtp_fw_cl_get_client(dev, &hid_ishtp_id_table[0].guid);\n\tif (!fw_client) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ish client uuid not found\\n\");\n\t\treturn -ENOENT;\n\t}\n\tishtp_cl_set_fw_client_id(hid_ishtp_cl,\n\t\t\t\t  ishtp_get_fw_client_id(fw_client));\n\tishtp_set_connection_state(hid_ishtp_cl, ISHTP_CL_CONNECTING);\n\n\trv = ishtp_cl_connect(hid_ishtp_cl);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"client connect fail\\n\");\n\t\tgoto err_cl_unlink;\n\t}\n\n\thid_ishtp_trace(client_data,  \"%s client connected\\n\", __func__);\n\n\t \n\tishtp_register_event_cb(client_data->cl_device, ish_cl_event_cb);\n\n\trv = ishtp_enum_enum_devices(hid_ishtp_cl);\n\tif (rv)\n\t\tgoto err_cl_disconnect;\n\n\thid_ishtp_trace(client_data,  \"%s enumerated device count %d\\n\",\n\t\t\t__func__, client_data->num_hid_devices);\n\n\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\tclient_data->cur_hid_dev = i;\n\n\t\trv = ishtp_get_hid_descriptor(hid_ishtp_cl, i);\n\t\tif (rv)\n\t\t\tgoto err_cl_disconnect;\n\n\t\trv = ishtp_get_report_descriptor(hid_ishtp_cl, i);\n\t\tif (rv)\n\t\t\tgoto err_cl_disconnect;\n\n\t\tif (!reset) {\n\t\t\trv = ishtp_hid_probe(i, client_data);\n\t\t\tif (rv) {\n\t\t\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\t\"[hid-ish]: HID probe for #%u failed: %d\\n\",\n\t\t\t\ti, rv);\n\t\t\t\tgoto err_cl_disconnect;\n\t\t\t}\n\t\t}\n\t}  \n\n\tclient_data->init_done = 1;\n\tclient_data->suspended = false;\n\twake_up_interruptible(&client_data->ishtp_resume_wait);\n\thid_ishtp_trace(client_data,  \"%s successful init\\n\", __func__);\n\treturn 0;\n\nerr_cl_disconnect:\n\tishtp_set_connection_state(hid_ishtp_cl, ISHTP_CL_DISCONNECTING);\n\tishtp_cl_disconnect(hid_ishtp_cl);\nerr_cl_unlink:\n\tishtp_cl_unlink(hid_ishtp_cl);\n\treturn rv;\n}\n\n \nstatic void hid_ishtp_cl_deinit(struct ishtp_cl *hid_ishtp_cl)\n{\n\tishtp_cl_unlink(hid_ishtp_cl);\n\tishtp_cl_flush_queues(hid_ishtp_cl);\n\n\t \n\tishtp_cl_free(hid_ishtp_cl);\n}\n\nstatic void hid_ishtp_cl_reset_handler(struct work_struct *work)\n{\n\tstruct ishtp_cl_data *client_data;\n\tstruct ishtp_cl *hid_ishtp_cl;\n\tstruct ishtp_cl_device *cl_device;\n\tint retry;\n\tint rv;\n\n\tclient_data = container_of(work, struct ishtp_cl_data, work);\n\n\thid_ishtp_cl = client_data->hid_ishtp_cl;\n\tcl_device = client_data->cl_device;\n\n\thid_ishtp_trace(client_data, \"%s hid_ishtp_cl %p\\n\", __func__,\n\t\t\thid_ishtp_cl);\n\tdev_dbg(ishtp_device(client_data->cl_device), \"%s\\n\", __func__);\n\n\thid_ishtp_cl_deinit(hid_ishtp_cl);\n\n\thid_ishtp_cl = ishtp_cl_allocate(cl_device);\n\tif (!hid_ishtp_cl)\n\t\treturn;\n\n\tishtp_set_drvdata(cl_device, hid_ishtp_cl);\n\tishtp_set_client_data(hid_ishtp_cl, client_data);\n\tclient_data->hid_ishtp_cl = hid_ishtp_cl;\n\n\tclient_data->num_hid_devices = 0;\n\n\tfor (retry = 0; retry < 3; ++retry) {\n\t\trv = hid_ishtp_cl_init(hid_ishtp_cl, 1);\n\t\tif (!rv)\n\t\t\tbreak;\n\t\tdev_err(cl_data_to_dev(client_data), \"Retry reset init\\n\");\n\t}\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(client_data), \"Reset Failed\\n\");\n\t\thid_ishtp_trace(client_data, \"%s Failed hid_ishtp_cl %p\\n\",\n\t\t\t\t__func__, hid_ishtp_cl);\n\t}\n}\n\nstatic void hid_ishtp_cl_resume_handler(struct work_struct *work)\n{\n\tstruct ishtp_cl_data *client_data = container_of(work, struct ishtp_cl_data, resume_work);\n\tstruct ishtp_cl *hid_ishtp_cl = client_data->hid_ishtp_cl;\n\n\tif (ishtp_wait_resume(ishtp_get_ishtp_device(hid_ishtp_cl))) {\n\t\tclient_data->suspended = false;\n\t\twake_up_interruptible(&client_data->ishtp_resume_wait);\n\t}\n}\n\nishtp_print_log ishtp_hid_print_trace;\n\n \nstatic int hid_ishtp_cl_probe(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl *hid_ishtp_cl;\n\tstruct ishtp_cl_data *client_data;\n\tint rv;\n\n\tif (!cl_device)\n\t\treturn\t-ENODEV;\n\n\tclient_data = devm_kzalloc(ishtp_device(cl_device),\n\t\t\t\t   sizeof(*client_data),\n\t\t\t\t   GFP_KERNEL);\n\tif (!client_data)\n\t\treturn -ENOMEM;\n\n\thid_ishtp_cl = ishtp_cl_allocate(cl_device);\n\tif (!hid_ishtp_cl)\n\t\treturn -ENOMEM;\n\n\tishtp_set_drvdata(cl_device, hid_ishtp_cl);\n\tishtp_set_client_data(hid_ishtp_cl, client_data);\n\tclient_data->hid_ishtp_cl = hid_ishtp_cl;\n\tclient_data->cl_device = cl_device;\n\n\tinit_waitqueue_head(&client_data->init_wait);\n\tinit_waitqueue_head(&client_data->ishtp_resume_wait);\n\n\tINIT_WORK(&client_data->work, hid_ishtp_cl_reset_handler);\n\tINIT_WORK(&client_data->resume_work, hid_ishtp_cl_resume_handler);\n\n\n\tishtp_hid_print_trace = ishtp_trace_callback(cl_device);\n\n\trv = hid_ishtp_cl_init(hid_ishtp_cl, 0);\n\tif (rv) {\n\t\tishtp_cl_free(hid_ishtp_cl);\n\t\treturn rv;\n\t}\n\tishtp_get_device(cl_device);\n\n\treturn 0;\n}\n\n \nstatic void hid_ishtp_cl_remove(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl *hid_ishtp_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\n\thid_ishtp_trace(client_data, \"%s hid_ishtp_cl %p\\n\", __func__,\n\t\t\thid_ishtp_cl);\n\n\tdev_dbg(ishtp_device(cl_device), \"%s\\n\", __func__);\n\tishtp_set_connection_state(hid_ishtp_cl, ISHTP_CL_DISCONNECTING);\n\tishtp_cl_disconnect(hid_ishtp_cl);\n\tishtp_put_device(cl_device);\n\tishtp_hid_remove(client_data);\n\thid_ishtp_cl_deinit(hid_ishtp_cl);\n\n\thid_ishtp_cl = NULL;\n\n\tclient_data->num_hid_devices = 0;\n}\n\n \nstatic int hid_ishtp_cl_reset(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl *hid_ishtp_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\n\thid_ishtp_trace(client_data, \"%s hid_ishtp_cl %p\\n\", __func__,\n\t\t\thid_ishtp_cl);\n\n\tschedule_work(&client_data->work);\n\n\treturn 0;\n}\n\n \nstatic int hid_ishtp_cl_suspend(struct device *device)\n{\n\tstruct ishtp_cl_device *cl_device = ishtp_dev_to_cl_device(device);\n\tstruct ishtp_cl *hid_ishtp_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\n\thid_ishtp_trace(client_data, \"%s hid_ishtp_cl %p\\n\", __func__,\n\t\t\thid_ishtp_cl);\n\tclient_data->suspended = true;\n\n\treturn 0;\n}\n\n \nstatic int hid_ishtp_cl_resume(struct device *device)\n{\n\tstruct ishtp_cl_device *cl_device = ishtp_dev_to_cl_device(device);\n\tstruct ishtp_cl *hid_ishtp_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(hid_ishtp_cl);\n\n\thid_ishtp_trace(client_data, \"%s hid_ishtp_cl %p\\n\", __func__,\n\t\t\thid_ishtp_cl);\n\tschedule_work(&client_data->resume_work);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops hid_ishtp_pm_ops = {\n\t.suspend = hid_ishtp_cl_suspend,\n\t.resume = hid_ishtp_cl_resume,\n};\n\nstatic struct ishtp_cl_driver\thid_ishtp_cl_driver = {\n\t.name = \"ish-hid\",\n\t.id = hid_ishtp_id_table,\n\t.probe = hid_ishtp_cl_probe,\n\t.remove = hid_ishtp_cl_remove,\n\t.reset = hid_ishtp_cl_reset,\n\t.driver.pm = &hid_ishtp_pm_ops,\n};\n\nstatic int __init ish_hid_init(void)\n{\n\tint\trv;\n\n\t \n\trv = ishtp_cl_driver_register(&hid_ishtp_cl_driver, THIS_MODULE);\n\n\treturn rv;\n\n}\n\nstatic void __exit ish_hid_exit(void)\n{\n\tishtp_cl_driver_unregister(&hid_ishtp_cl_driver);\n}\n\nlate_initcall(ish_hid_init);\nmodule_exit(ish_hid_exit);\n\nMODULE_DESCRIPTION(\"ISH ISHTP HID client driver\");\n \nMODULE_AUTHOR(\"Daniel Drubin <daniel.drubin@intel.com>\");\n \nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}