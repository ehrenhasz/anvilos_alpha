{
  "module_name": "ishtp-hid.c",
  "hash_id": "037064afdc6e0dda5d161c99c3eea04e2d5d5496e23212cb4d8c20e397cebaed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/intel-ish-hid/ishtp-hid.c",
  "human_readable_source": "\n \n\n#include <linux/hid.h>\n#include <linux/intel-ish-client-if.h>\n#include <uapi/linux/input.h>\n#include \"ishtp-hid.h\"\n\n \nstatic int ishtp_hid_parse(struct hid_device *hid)\n{\n\tstruct ishtp_hid_data *hid_data =  hid->driver_data;\n\tstruct ishtp_cl_data *client_data = hid_data->client_data;\n\tint rv;\n\n\trv = hid_parse_report(hid, client_data->report_descr[hid_data->index],\n\t\t\t      client_data->report_descr_size[hid_data->index]);\n\tif (rv)\n\t\treturn\trv;\n\n\treturn 0;\n}\n\n \nstatic int ishtp_hid_start(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void ishtp_hid_stop(struct hid_device *hid)\n{\n}\n\nstatic int ishtp_hid_open(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void ishtp_hid_close(struct hid_device *hid)\n{\n}\n\nstatic int ishtp_raw_request(struct hid_device *hid, unsigned char reportnum,\n\t\t\t     __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t     int reqtype)\n{\n\tstruct ishtp_hid_data *hid_data =  hid->driver_data;\n\tchar *ishtp_buf = NULL;\n\tsize_t ishtp_buf_len;\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\n\tif (rtype == HID_OUTPUT_REPORT)\n\t\treturn -EINVAL;\n\n\thid_data->request_done = false;\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\thid_data->raw_buf = buf;\n\t\thid_data->raw_buf_size = len;\n\t\thid_data->raw_get_req = true;\n\n\t\thid_ishtp_get_report(hid, reportnum, rtype);\n\t\tbreak;\n\tcase HID_REQ_SET_REPORT:\n\t\t \n\t\tishtp_buf_len = len + header_size;\n\t\tishtp_buf = kzalloc(ishtp_buf_len + 7, GFP_KERNEL);\n\t\tif (!ishtp_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(ishtp_buf + header_size, buf, len);\n\t\thid_ishtp_set_feature(hid, ishtp_buf, ishtp_buf_len, reportnum);\n\t\tkfree(ishtp_buf);\n\t\tbreak;\n\t}\n\n\thid_hw_wait(hid);\n\n\treturn len;\n}\n\n \nstatic void ishtp_hid_request(struct hid_device *hid, struct hid_report *rep,\n\tint reqtype)\n{\n\tstruct ishtp_hid_data *hid_data =  hid->driver_data;\n\t \n\tunsigned int len = ((rep->size - 1) >> 3) + 1 + (rep->id > 0);\n\tchar *buf;\n\tunsigned int header_size = sizeof(struct hostif_msg);\n\n\tlen += header_size;\n\n\thid_data->request_done = false;\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\thid_data->raw_get_req = false;\n\t\thid_ishtp_get_report(hid, rep->id, rep->type);\n\t\tbreak;\n\tcase HID_REQ_SET_REPORT:\n\t\t \n\t\tbuf = kzalloc(len + 7, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn;\n\n\t\thid_output_report(rep, buf + header_size);\n\t\thid_ishtp_set_feature(hid, buf, len, rep->id);\n\t\tkfree(buf);\n\t\tbreak;\n\t}\n}\n\n \nstatic int ishtp_wait_for_response(struct hid_device *hid)\n{\n\tstruct ishtp_hid_data *hid_data =  hid->driver_data;\n\tint rv;\n\n\thid_ishtp_trace(client_data,  \"%s hid %p\\n\", __func__, hid);\n\n\trv = ishtp_hid_link_ready_wait(hid_data->client_data);\n\tif (rv)\n\t\treturn rv;\n\n\tif (!hid_data->request_done)\n\t\twait_event_interruptible_timeout(hid_data->hid_wait,\n\t\t\t\t\thid_data->request_done, 3 * HZ);\n\n\tif (!hid_data->request_done) {\n\t\thid_err(hid,\n\t\t\t\"timeout waiting for response from ISHTP device\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\thid_ishtp_trace(client_data,  \"%s hid %p done\\n\", __func__, hid);\n\n\thid_data->request_done = false;\n\n\treturn 0;\n}\n\n \nvoid ishtp_hid_wakeup(struct hid_device *hid)\n{\n\tstruct ishtp_hid_data *hid_data = hid->driver_data;\n\n\thid_data->request_done = true;\n\twake_up_interruptible(&hid_data->hid_wait);\n}\n\nstatic const struct hid_ll_driver ishtp_hid_ll_driver = {\n\t.parse = ishtp_hid_parse,\n\t.start = ishtp_hid_start,\n\t.stop = ishtp_hid_stop,\n\t.open = ishtp_hid_open,\n\t.close = ishtp_hid_close,\n\t.request = ishtp_hid_request,\n\t.wait = ishtp_wait_for_response,\n\t.raw_request = ishtp_raw_request\n};\n\n \nint ishtp_hid_probe(unsigned int cur_hid_dev,\n\t\t    struct ishtp_cl_data *client_data)\n{\n\tint rv;\n\tstruct hid_device *hid;\n\tstruct ishtp_hid_data *hid_data;\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid))\n\t\treturn PTR_ERR(hid);\n\n\thid_data = kzalloc(sizeof(*hid_data), GFP_KERNEL);\n\tif (!hid_data) {\n\t\trv = -ENOMEM;\n\t\tgoto err_hid_data;\n\t}\n\n\thid_data->index = cur_hid_dev;\n\thid_data->client_data = client_data;\n\tinit_waitqueue_head(&hid_data->hid_wait);\n\n\thid->driver_data = hid_data;\n\n\tclient_data->hid_sensor_hubs[cur_hid_dev] = hid;\n\n\thid->ll_driver = &ishtp_hid_ll_driver;\n\thid->bus = BUS_INTEL_ISHTP;\n\thid->dev.parent = ishtp_device(client_data->cl_device);\n\n\thid->version = le16_to_cpu(ISH_HID_VERSION);\n\thid->vendor = le16_to_cpu(client_data->hid_devices[cur_hid_dev].vid);\n\thid->product = le16_to_cpu(client_data->hid_devices[cur_hid_dev].pid);\n\tsnprintf(hid->name, sizeof(hid->name), \"%s %04X:%04X\", \"hid-ishtp\",\n\t\thid->vendor, hid->product);\n\n\trv = hid_add_device(hid);\n\tif (rv)\n\t\tgoto err_hid_device;\n\n\thid_ishtp_trace(client_data,  \"%s allocated hid %p\\n\", __func__, hid);\n\n\treturn 0;\n\nerr_hid_device:\n\tkfree(hid_data);\nerr_hid_data:\n\thid_destroy_device(hid);\n\treturn rv;\n}\n\n \nvoid ishtp_hid_remove(struct ishtp_cl_data *client_data)\n{\n\tint i;\n\n\tfor (i = 0; i < client_data->num_hid_devices; ++i) {\n\t\tif (client_data->hid_sensor_hubs[i]) {\n\t\t\tkfree(client_data->hid_sensor_hubs[i]->driver_data);\n\t\t\thid_destroy_device(client_data->hid_sensor_hubs[i]);\n\t\t\tclient_data->hid_sensor_hubs[i] = NULL;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}