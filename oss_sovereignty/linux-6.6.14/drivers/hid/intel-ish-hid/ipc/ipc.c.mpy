{
  "module_name": "ipc.c",
  "hash_id": "3d57d7da3aed6453761ea6b94b95a0f94ab19d3b3c67a52de5e1a90ea7ce6042",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/intel-ish-hid/ipc/ipc.c",
  "human_readable_source": "\n \n\n#include <linux/devm-helpers.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include \"client.h\"\n#include \"hw-ish.h\"\n#include \"hbm.h\"\n\n \nstatic struct work_struct fw_reset_work;\nstatic struct ishtp_device *ishtp_dev;\n\n \nstatic inline uint32_t ish_reg_read(const struct ishtp_device *dev,\n\tunsigned long offset)\n{\n\tstruct ish_hw *hw = to_ish_hw(dev);\n\n\treturn readl(hw->mem_addr + offset);\n}\n\n \nstatic inline void ish_reg_write(struct ishtp_device *dev,\n\t\t\t\t unsigned long offset,\n\t\t\t\t uint32_t value)\n{\n\tstruct ish_hw *hw = to_ish_hw(dev);\n\n\twritel(value, hw->mem_addr + offset);\n}\n\n \nstatic inline uint32_t _ish_read_fw_sts_reg(struct ishtp_device *dev)\n{\n\treturn ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);\n}\n\n \nstatic bool check_generated_interrupt(struct ishtp_device *dev)\n{\n\tbool interrupt_generated = true;\n\tuint32_t pisr_val = 0;\n\n\tif (dev->pdev->device == CHV_DEVICE_ID) {\n\t\tpisr_val = ish_reg_read(dev, IPC_REG_PISR_CHV_AB);\n\t\tinterrupt_generated =\n\t\t\tIPC_INT_FROM_ISH_TO_HOST_CHV_AB(pisr_val);\n\t} else {\n\t\tpisr_val = ish_reg_read(dev, IPC_REG_PISR_BXT);\n\t\tinterrupt_generated = !!pisr_val;\n\t\t \n\t\tif (pisr_val)\n\t\t\tish_reg_write(dev, IPC_REG_PISR_BXT, pisr_val);\n\t}\n\n\treturn interrupt_generated;\n}\n\n \nstatic bool ish_is_input_ready(struct ishtp_device *dev)\n{\n\tuint32_t doorbell_val;\n\n\tdoorbell_val = ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL);\n\treturn !IPC_IS_BUSY(doorbell_val);\n}\n\n \nstatic void set_host_ready(struct ishtp_device *dev)\n{\n\tif (dev->pdev->device == CHV_DEVICE_ID) {\n\t\tif (dev->pdev->revision == REVISION_ID_CHT_A0 ||\n\t\t\t\t(dev->pdev->revision & REVISION_ID_SI_MASK) ==\n\t\t\t\tREVISION_ID_CHT_Ax_SI)\n\t\t\tish_reg_write(dev, IPC_REG_HOST_COMM, 0x81);\n\t\telse if (dev->pdev->revision == REVISION_ID_CHT_B0 ||\n\t\t\t\t(dev->pdev->revision & REVISION_ID_SI_MASK) ==\n\t\t\t\tREVISION_ID_CHT_Bx_SI ||\n\t\t\t\t(dev->pdev->revision & REVISION_ID_SI_MASK) ==\n\t\t\t\tREVISION_ID_CHT_Kx_SI ||\n\t\t\t\t(dev->pdev->revision & REVISION_ID_SI_MASK) ==\n\t\t\t\tREVISION_ID_CHT_Dx_SI) {\n\t\t\tuint32_t host_comm_val;\n\n\t\t\thost_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);\n\t\t\thost_comm_val |= IPC_HOSTCOMM_INT_EN_BIT_CHV_AB | 0x81;\n\t\t\tish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);\n\t\t}\n\t} else {\n\t\t\tuint32_t host_pimr_val;\n\n\t\t\thost_pimr_val = ish_reg_read(dev, IPC_REG_PIMR_BXT);\n\t\t\thost_pimr_val |= IPC_PIMR_INT_EN_BIT_BXT;\n\t\t\t \n\t\t\thost_pimr_val &= ~IPC_HOST2ISH_BUSYCLEAR_MASK_BIT;\n\n\t\t\tish_reg_write(dev, IPC_REG_PIMR_BXT, host_pimr_val);\n\t}\n}\n\n \nstatic bool ishtp_fw_is_ready(struct ishtp_device *dev)\n{\n\tuint32_t ish_status = _ish_read_fw_sts_reg(dev);\n\n\treturn IPC_IS_ISH_ILUP(ish_status) &&\n\t\tIPC_IS_ISH_ISHTP_READY(ish_status);\n}\n\n \nstatic void ish_set_host_rdy(struct ishtp_device *dev)\n{\n\tuint32_t host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);\n\n\tIPC_SET_HOST_READY(host_status);\n\tish_reg_write(dev, IPC_REG_HOST_COMM, host_status);\n}\n\n \nstatic void ish_clr_host_rdy(struct ishtp_device *dev)\n{\n\tuint32_t host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);\n\n\tIPC_CLEAR_HOST_READY(host_status);\n\tish_reg_write(dev, IPC_REG_HOST_COMM, host_status);\n}\n\nstatic bool ish_chk_host_rdy(struct ishtp_device *dev)\n{\n\tuint32_t host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);\n\n\treturn (host_status & IPC_HOSTCOMM_READY_BIT);\n}\n\n \nvoid ish_set_host_ready(struct ishtp_device *dev)\n{\n\tif (ish_chk_host_rdy(dev))\n\t\treturn;\n\n\tish_set_host_rdy(dev);\n\tset_host_ready(dev);\n}\n\n \nstatic uint32_t _ishtp_read_hdr(const struct ishtp_device *dev)\n{\n\treturn ish_reg_read(dev, IPC_REG_ISH2HOST_MSG);\n}\n\n \nstatic int _ishtp_read(struct ishtp_device *dev, unsigned char *buffer,\n\tunsigned long buffer_length)\n{\n\tuint32_t\ti;\n\tuint32_t\t*r_buf = (uint32_t *)buffer;\n\tuint32_t\tmsg_offs;\n\n\tmsg_offs = IPC_REG_ISH2HOST_MSG + sizeof(struct ishtp_msg_hdr);\n\tfor (i = 0; i < buffer_length; i += sizeof(uint32_t))\n\t\t*r_buf++ = ish_reg_read(dev, msg_offs + i);\n\n\treturn 0;\n}\n\n \nstatic int write_ipc_from_queue(struct ishtp_device *dev)\n{\n\tstruct wr_msg_ctl_info\t*ipc_link;\n\tunsigned long\tlength;\n\tunsigned long\trem;\n\tunsigned long\tflags;\n\tuint32_t\tdoorbell_val;\n\tuint32_t\t*r_buf;\n\tuint32_t\treg_addr;\n\tint\ti;\n\tvoid\t(*ipc_send_compl)(void *);\n\tvoid\t*ipc_send_compl_prm;\n\n\tif (dev->dev_state == ISHTP_DEV_DISABLED)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->wr_processing_spinlock, flags);\n\tif (!ish_is_input_ready(dev)) {\n\t\tspin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (list_empty(&dev->wr_processing_list)) {\n\t\tspin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);\n\t\treturn\t0;\n\t}\n\n\tipc_link = list_first_entry(&dev->wr_processing_list,\n\t\t\t\t    struct wr_msg_ctl_info, link);\n\t \n\tlength = ipc_link->length - sizeof(uint32_t);\n\tdoorbell_val = *(uint32_t *)ipc_link->inline_data;\n\tr_buf = (uint32_t *)(ipc_link->inline_data + sizeof(uint32_t));\n\n\t \n\tif (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG &&\n\t\tIPC_HEADER_GET_MNG_CMD(doorbell_val) == MNG_SYNC_FW_CLOCK) {\n\t\tuint64_t usec_system, usec_utc;\n\t\tstruct ipc_time_update_msg time_update;\n\t\tstruct time_sync_format ts_format;\n\n\t\tusec_system = ktime_to_us(ktime_get_boottime());\n\t\tusec_utc = ktime_to_us(ktime_get_real());\n\t\tts_format.ts1_source = HOST_SYSTEM_TIME_USEC;\n\t\tts_format.ts2_source = HOST_UTC_TIME_USEC;\n\t\tts_format.reserved = 0;\n\n\t\ttime_update.primary_host_time = usec_system;\n\t\ttime_update.secondary_host_time = usec_utc;\n\t\ttime_update.sync_info = ts_format;\n\n\t\tmemcpy(r_buf, &time_update,\n\t\t       sizeof(struct ipc_time_update_msg));\n\t}\n\n\tfor (i = 0, reg_addr = IPC_REG_HOST2ISH_MSG; i < length >> 2; i++,\n\t\t\treg_addr += 4)\n\t\tish_reg_write(dev, reg_addr, r_buf[i]);\n\n\trem = length & 0x3;\n\tif (rem > 0) {\n\t\tuint32_t reg = 0;\n\n\t\tmemcpy(&reg, &r_buf[length >> 2], rem);\n\t\tish_reg_write(dev, reg_addr, reg);\n\t}\n\tish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, doorbell_val);\n\n\t \n\tish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);\n\n\t \n\t++dev->ipc_tx_cnt;\n\tdev->ipc_tx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);\n\n\tipc_send_compl = ipc_link->ipc_send_compl;\n\tipc_send_compl_prm = ipc_link->ipc_send_compl_prm;\n\tlist_del_init(&ipc_link->link);\n\tlist_add(&ipc_link->link, &dev->wr_free_list);\n\tspin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);\n\n\t \n\tif (ipc_send_compl)\n\t\tipc_send_compl(ipc_send_compl_prm);\n\n\treturn 0;\n}\n\n \nstatic int write_ipc_to_queue(struct ishtp_device *dev,\n\tvoid (*ipc_send_compl)(void *), void *ipc_send_compl_prm,\n\tunsigned char *msg, int length)\n{\n\tstruct wr_msg_ctl_info *ipc_link;\n\tunsigned long flags;\n\n\tif (length > IPC_FULL_MSG_SIZE)\n\t\treturn -EMSGSIZE;\n\n\tspin_lock_irqsave(&dev->wr_processing_spinlock, flags);\n\tif (list_empty(&dev->wr_free_list)) {\n\t\tspin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);\n\t\treturn -ENOMEM;\n\t}\n\tipc_link = list_first_entry(&dev->wr_free_list,\n\t\t\t\t    struct wr_msg_ctl_info, link);\n\tlist_del_init(&ipc_link->link);\n\n\tipc_link->ipc_send_compl = ipc_send_compl;\n\tipc_link->ipc_send_compl_prm = ipc_send_compl_prm;\n\tipc_link->length = length;\n\tmemcpy(ipc_link->inline_data, msg, length);\n\n\tlist_add_tail(&ipc_link->link, &dev->wr_processing_list);\n\tspin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);\n\n\twrite_ipc_from_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic int ipc_send_mng_msg(struct ishtp_device *dev, uint32_t msg_code,\n\tvoid *msg, size_t size)\n{\n\tunsigned char\tipc_msg[IPC_FULL_MSG_SIZE];\n\tuint32_t\tdrbl_val = IPC_BUILD_MNG_MSG(msg_code, size);\n\n\tmemcpy(ipc_msg, &drbl_val, sizeof(uint32_t));\n\tmemcpy(ipc_msg + sizeof(uint32_t), msg, size);\n\treturn\twrite_ipc_to_queue(dev, NULL, NULL, ipc_msg,\n\t\tsizeof(uint32_t) + size);\n}\n\n#define WAIT_FOR_FW_RDY\t\t\t0x1\n#define WAIT_FOR_INPUT_RDY\t\t0x2\n\n \nstatic int timed_wait_for_timeout(struct ishtp_device *dev, int condition,\n\t\t\t\tunsigned int timeinc, unsigned int timeout)\n{\n\tbool complete = false;\n\tint ret;\n\n\tdo {\n\t\tif (condition == WAIT_FOR_FW_RDY) {\n\t\t\tcomplete = ishtp_fw_is_ready(dev);\n\t\t} else if (condition == WAIT_FOR_INPUT_RDY) {\n\t\t\tcomplete = ish_is_input_ready(dev);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!complete) {\n\t\t\tunsigned long left_time;\n\n\t\t\tleft_time = msleep_interruptible(timeinc);\n\t\t\ttimeout -= (timeinc - left_time);\n\t\t}\n\t} while (!complete && timeout > 0);\n\n\tif (complete)\n\t\tret = 0;\n\telse\n\t\tret = -EBUSY;\n\nout:\n\treturn ret;\n}\n\n#define TIME_SLICE_FOR_FW_RDY_MS\t\t100\n#define TIME_SLICE_FOR_INPUT_RDY_MS\t\t100\n#define TIMEOUT_FOR_FW_RDY_MS\t\t\t2000\n#define TIMEOUT_FOR_INPUT_RDY_MS\t\t2000\n\n \nstatic int ish_fw_reset_handler(struct ishtp_device *dev)\n{\n\tuint32_t\treset_id;\n\tunsigned long\tflags;\n\n\t \n\treset_id = ish_reg_read(dev, IPC_REG_ISH2HOST_MSG) & 0xFFFF;\n\n\t \n\tspin_lock_irqsave(&dev->wr_processing_spinlock, flags);\n\tlist_splice_init(&dev->wr_processing_list, &dev->wr_free_list);\n\tspin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);\n\n\t \n\tishtp_reset_handler(dev);\n\n\tif (!ish_is_input_ready(dev))\n\t\ttimed_wait_for_timeout(dev, WAIT_FOR_INPUT_RDY,\n\t\t\tTIME_SLICE_FOR_INPUT_RDY_MS, TIMEOUT_FOR_INPUT_RDY_MS);\n\n\t \n\tif (!ish_is_input_ready(dev))\n\t\treturn\t-EPIPE;\n\t \n\tish_set_host_rdy(dev);\n\t \n\tipc_send_mng_msg(dev, MNG_RESET_NOTIFY_ACK, &reset_id,\n\t\t\t sizeof(uint32_t));\n\n\t \n\ttimed_wait_for_timeout(dev, WAIT_FOR_FW_RDY,\n\t\t\tTIME_SLICE_FOR_FW_RDY_MS, TIMEOUT_FOR_FW_RDY_MS);\n\tif (!ishtp_fw_is_ready(dev)) {\n\t\t \n\t\tuint32_t\tish_status;\n\n\t\tish_status = _ish_read_fw_sts_reg(dev);\n\t\tdev_err(dev->devc,\n\t\t\t\"[ishtp-ish]: completed reset, ISH is dead (FWSTS = %08X)\\n\",\n\t\t\tish_status);\n\t\treturn -ENODEV;\n\t}\n\treturn\t0;\n}\n\n#define TIMEOUT_FOR_HW_RDY_MS\t\t\t300\n\n \nstatic void fw_reset_work_fn(struct work_struct *unused)\n{\n\tint\trv;\n\n\trv = ish_fw_reset_handler(ishtp_dev);\n\tif (!rv) {\n\t\t \n\t\tmsleep_interruptible(TIMEOUT_FOR_HW_RDY_MS);\n\t\tishtp_dev->recvd_hw_ready = 1;\n\t\twake_up_interruptible(&ishtp_dev->wait_hw_ready);\n\n\t\t \n\t\tishtp_reset_compl_handler(ishtp_dev);\n\t} else\n\t\tdev_err(ishtp_dev->devc, \"[ishtp-ish]: FW reset failed (%d)\\n\",\n\t\t\trv);\n}\n\n \nstatic void _ish_sync_fw_clock(struct ishtp_device *dev)\n{\n\tstatic unsigned long\tprev_sync;\n\tuint64_t\tusec;\n\n\tif (prev_sync && time_before(jiffies, prev_sync + 20 * HZ))\n\t\treturn;\n\n\tprev_sync = jiffies;\n\tusec = ktime_to_us(ktime_get_boottime());\n\tipc_send_mng_msg(dev, MNG_SYNC_FW_CLOCK, &usec, sizeof(uint64_t));\n}\n\n \nstatic void\trecv_ipc(struct ishtp_device *dev, uint32_t doorbell_val)\n{\n\tuint32_t\tmng_cmd;\n\n\tmng_cmd = IPC_HEADER_GET_MNG_CMD(doorbell_val);\n\n\tswitch (mng_cmd) {\n\tdefault:\n\t\tbreak;\n\n\tcase MNG_RX_CMPL_INDICATION:\n\t\tif (dev->suspend_flag) {\n\t\t\tdev->suspend_flag = 0;\n\t\t\twake_up_interruptible(&dev->suspend_wait);\n\t\t}\n\t\tif (dev->resume_flag) {\n\t\t\tdev->resume_flag = 0;\n\t\t\twake_up_interruptible(&dev->resume_wait);\n\t\t}\n\n\t\twrite_ipc_from_queue(dev);\n\t\tbreak;\n\n\tcase MNG_RESET_NOTIFY:\n\t\tif (!ishtp_dev) {\n\t\t\tishtp_dev = dev;\n\t\t}\n\t\tschedule_work(&fw_reset_work);\n\t\tbreak;\n\n\tcase MNG_RESET_NOTIFY_ACK:\n\t\tdev->recvd_hw_ready = 1;\n\t\twake_up_interruptible(&dev->wait_hw_ready);\n\t\tbreak;\n\t}\n}\n\n \nirqreturn_t ish_irq_handler(int irq, void *dev_id)\n{\n\tstruct ishtp_device\t*dev = dev_id;\n\tuint32_t\tdoorbell_val;\n\tbool\tinterrupt_generated;\n\n\t \n\tinterrupt_generated = check_generated_interrupt(dev);\n\n\tif (!interrupt_generated)\n\t\treturn IRQ_NONE;\n\n\tdoorbell_val = ish_reg_read(dev, IPC_REG_ISH2HOST_DRBL);\n\tif (!IPC_IS_BUSY(doorbell_val))\n\t\treturn IRQ_HANDLED;\n\n\tif (dev->dev_state == ISHTP_DEV_DISABLED)\n\t\treturn\tIRQ_HANDLED;\n\n\t \n\tif (IPC_HEADER_GET_LENGTH(doorbell_val) > IPC_PAYLOAD_SIZE) {\n\t\tdev_err(dev->devc,\n\t\t\t\"IPC hdr - bad length: %u; dropped\\n\",\n\t\t\t(unsigned int)IPC_HEADER_GET_LENGTH(doorbell_val));\n\t\tgoto\teoi;\n\t}\n\n\tswitch (IPC_HEADER_GET_PROTOCOL(doorbell_val)) {\n\tdefault:\n\t\tbreak;\n\tcase IPC_PROTOCOL_MNG:\n\t\trecv_ipc(dev, doorbell_val);\n\t\tbreak;\n\tcase IPC_PROTOCOL_ISHTP:\n\t\tishtp_recv(dev);\n\t\tbreak;\n\t}\n\neoi:\n\t \n\t++dev->ipc_rx_cnt;\n\tdev->ipc_rx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);\n\n\tish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);\n\t \n\tish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);\n\n\treturn\tIRQ_HANDLED;\n}\n\n \nint ish_disable_dma(struct ishtp_device *dev)\n{\n\tunsigned int\tdma_delay;\n\n\t \n\tish_reg_write(dev, IPC_REG_ISH_RMP2, 0);\n\n\t \n\tfor (dma_delay = 0; dma_delay < MAX_DMA_DELAY &&\n\t\t_ish_read_fw_sts_reg(dev) & (IPC_ISH_IN_DMA);\n\t\tdma_delay += 5)\n\t\tmdelay(5);\n\n\tif (dma_delay >= MAX_DMA_DELAY) {\n\t\tdev_err(dev->devc,\n\t\t\t\"Wait for DMA inactive timeout\\n\");\n\t\treturn\t-EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ish_wakeup(struct ishtp_device *dev)\n{\n\t \n\tish_reg_write(dev, IPC_REG_ISH_RMP2, IPC_RMP2_DMA_ENABLED);\n\n\t \n\tish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, IPC_DRBL_BUSY_BIT);\n\n\t \n\tish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);\n}\n\n \nstatic int _ish_hw_reset(struct ishtp_device *dev)\n{\n\tstruct pci_dev *pdev = dev->pdev;\n\tint\trv;\n\tuint16_t csr;\n\n\tif (!pdev)\n\t\treturn\t-ENODEV;\n\n\trv = pci_reset_function(pdev);\n\tif (!rv)\n\t\tdev->dev_state = ISHTP_DEV_RESETTING;\n\n\tif (!pdev->pm_cap) {\n\t\tdev_err(&pdev->dev, \"Can't reset - no PM caps\\n\");\n\t\treturn\t-EINVAL;\n\t}\n\n\t \n\tif (ish_disable_dma(dev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Can't reset - stuck with DMA in-progress\\n\");\n\t\treturn\t-EBUSY;\n\t}\n\n\tpci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &csr);\n\n\tcsr &= ~PCI_PM_CTRL_STATE_MASK;\n\tcsr |= PCI_D3hot;\n\tpci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);\n\n\tmdelay(pdev->d3hot_delay);\n\n\tcsr &= ~PCI_PM_CTRL_STATE_MASK;\n\tcsr |= PCI_D0;\n\tpci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);\n\n\t \n\tish_wakeup(dev);\n\n\treturn\t0;\n}\n\n \nstatic int _ish_ipc_reset(struct ishtp_device *dev)\n{\n\tstruct ipc_rst_payload_type ipc_mng_msg;\n\tint\trv = 0;\n\n\tipc_mng_msg.reset_id = 1;\n\tipc_mng_msg.reserved = 0;\n\n\tset_host_ready(dev);\n\n\t \n\tish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);\n\t \n\tish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);\n\n\tdev->recvd_hw_ready = 0;\n\n\t \n\trv = ipc_send_mng_msg(dev, MNG_RESET_NOTIFY, &ipc_mng_msg,\n\t\tsizeof(struct ipc_rst_payload_type));\n\tif (rv) {\n\t\tdev_err(dev->devc, \"Failed to send IPC MNG_RESET_NOTIFY\\n\");\n\t\treturn\trv;\n\t}\n\n\twait_event_interruptible_timeout(dev->wait_hw_ready,\n\t\t\t\t\t dev->recvd_hw_ready, 2 * HZ);\n\tif (!dev->recvd_hw_ready) {\n\t\tdev_err(dev->devc, \"Timed out waiting for HW ready\\n\");\n\t\trv = -ENODEV;\n\t}\n\n\treturn rv;\n}\n\n \nint ish_hw_start(struct ishtp_device *dev)\n{\n\tish_set_host_rdy(dev);\n\n\tset_host_ready(dev);\n\n\t \n\tish_wakeup(dev);\n\n\t \n\tif (!dev->recvd_hw_ready)\n\t\twait_event_interruptible_timeout(dev->wait_hw_ready,\n\t\t\t\t\t\t dev->recvd_hw_ready,\n\t\t\t\t\t\t 10 * HZ);\n\n\tif (!dev->recvd_hw_ready) {\n\t\tdev_err(dev->devc,\n\t\t\t\"[ishtp-ish]: Timed out waiting for FW-initiated reset\\n\");\n\t\treturn\t-ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic uint32_t ish_ipc_get_header(struct ishtp_device *dev, int length,\n\t\t\t\t   int busy)\n{\n\tuint32_t drbl_val;\n\n\tdrbl_val = IPC_BUILD_HEADER(length, IPC_PROTOCOL_ISHTP, busy);\n\n\treturn drbl_val;\n}\n\n \nstatic bool _dma_no_cache_snooping(struct ishtp_device *dev)\n{\n\treturn (dev->pdev->device == EHL_Ax_DEVICE_ID ||\n\t\tdev->pdev->device == TGL_LP_DEVICE_ID ||\n\t\tdev->pdev->device == TGL_H_DEVICE_ID ||\n\t\tdev->pdev->device == ADL_S_DEVICE_ID ||\n\t\tdev->pdev->device == ADL_P_DEVICE_ID);\n}\n\nstatic const struct ishtp_hw_ops ish_hw_ops = {\n\t.hw_reset = _ish_hw_reset,\n\t.ipc_reset = _ish_ipc_reset,\n\t.ipc_get_header = ish_ipc_get_header,\n\t.ishtp_read = _ishtp_read,\n\t.write = write_ipc_to_queue,\n\t.get_fw_status = _ish_read_fw_sts_reg,\n\t.sync_fw_clock = _ish_sync_fw_clock,\n\t.ishtp_read_hdr = _ishtp_read_hdr,\n\t.dma_no_cache_snooping = _dma_no_cache_snooping\n};\n\n \nstruct ishtp_device *ish_dev_init(struct pci_dev *pdev)\n{\n\tstruct ishtp_device *dev;\n\tint\ti;\n\tint\tret;\n\n\tdev = devm_kzalloc(&pdev->dev,\n\t\t\t   sizeof(struct ishtp_device) + sizeof(struct ish_hw),\n\t\t\t   GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tishtp_device_init(dev);\n\n\tinit_waitqueue_head(&dev->wait_hw_ready);\n\n\tspin_lock_init(&dev->wr_processing_spinlock);\n\n\t \n\tINIT_LIST_HEAD(&dev->wr_processing_list);\n\tINIT_LIST_HEAD(&dev->wr_free_list);\n\tfor (i = 0; i < IPC_TX_FIFO_SIZE; i++) {\n\t\tstruct wr_msg_ctl_info\t*tx_buf;\n\n\t\ttx_buf = devm_kzalloc(&pdev->dev,\n\t\t\t\t      sizeof(struct wr_msg_ctl_info),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!tx_buf) {\n\t\t\t \n\t\t\tdev_err(dev->devc,\n\t\t\t\t\"[ishtp-ish]: failure in Tx FIFO allocations (%d)\\n\",\n\t\t\t\ti);\n\t\t\tbreak;\n\t\t}\n\t\tlist_add_tail(&tx_buf->link, &dev->wr_free_list);\n\t}\n\n\tret = devm_work_autocancel(&pdev->dev, &fw_reset_work, fw_reset_work_fn);\n\tif (ret) {\n\t\tdev_err(dev->devc, \"Failed to initialise FW reset work\\n\");\n\t\treturn NULL;\n\t}\n\n\tdev->ops = &ish_hw_ops;\n\tdev->devc = &pdev->dev;\n\tdev->mtu = IPC_PAYLOAD_SIZE - sizeof(struct ishtp_msg_hdr);\n\treturn dev;\n}\n\n \nvoid\tish_device_disable(struct ishtp_device *dev)\n{\n\tstruct pci_dev *pdev = dev->pdev;\n\n\tif (!pdev)\n\t\treturn;\n\n\t \n\tif (ish_disable_dma(dev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Can't reset - stuck with DMA in-progress\\n\");\n\t\treturn;\n\t}\n\n\t \n\tpci_set_power_state(pdev, PCI_D3hot);\n\n\tdev->dev_state = ISHTP_DEV_DISABLED;\n\tish_clr_host_rdy(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}