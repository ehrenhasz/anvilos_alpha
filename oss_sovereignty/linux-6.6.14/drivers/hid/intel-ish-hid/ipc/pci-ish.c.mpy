{
  "module_name": "pci-ish.c",
  "hash_id": "fc36b960c6e94adf8d9ea8583edd0ca0db809a7f6101ef8133a497b0556124a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/intel-ish-hid/ipc/pci-ish.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/sched.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/intel_ish.h>\n#include \"ishtp-dev.h\"\n#include \"hw-ish.h\"\n\nstatic const struct pci_device_id ish_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, CHV_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, BXT_Ax_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, BXT_Bx_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, APL_Ax_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, SPT_Ax_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, CNL_Ax_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, GLK_Ax_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, CNL_H_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ICL_MOBILE_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, SPT_H_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, CML_LP_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, CMP_H_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, EHL_Ax_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, TGL_LP_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, TGL_H_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ADL_S_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ADL_P_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ADL_N_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, RPL_S_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, MTL_P_DEVICE_ID)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, ARL_H_DEVICE_ID)},\n\t{0, }\n};\nMODULE_DEVICE_TABLE(pci, ish_pci_tbl);\n\n \nstatic __printf(2, 3)\nvoid ish_event_tracer(struct ishtp_device *dev, const char *format, ...)\n{\n\tif (trace_ishtp_dump_enabled()) {\n\t\tva_list args;\n\t\tchar tmp_buf[100];\n\n\t\tva_start(args, format);\n\t\tvsnprintf(tmp_buf, sizeof(tmp_buf), format, args);\n\t\tva_end(args);\n\n\t\ttrace_ishtp_dump(tmp_buf);\n\t}\n}\n\n \nstatic int ish_init(struct ishtp_device *dev)\n{\n\tint ret;\n\n\t \n\tret = ish_hw_start(dev);\n\tif (ret) {\n\t\tdev_err(dev->devc, \"ISH: hw start failed.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ishtp_start(dev);\n\tif (ret) {\n\t\tdev_err(dev->devc, \"ISHTP: Protocol init failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id ish_invalid_pci_ids[] = {\n\t \n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xA309)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xA30A)},\n\t{}\n};\n\nstatic inline bool ish_should_enter_d0i3(struct pci_dev *pdev)\n{\n\treturn !pm_suspend_via_firmware() || pdev->device == CHV_DEVICE_ID;\n}\n\nstatic inline bool ish_should_leave_d0i3(struct pci_dev *pdev)\n{\n\treturn !pm_resume_via_firmware() || pdev->device == CHV_DEVICE_ID;\n}\n\nstatic int enable_gpe(struct device *dev)\n{\n#ifdef CONFIG_ACPI\n\tacpi_status acpi_sts;\n\tstruct acpi_device *adev;\n\tstruct acpi_device_wakeup *wakeup;\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev) {\n\t\tdev_err(dev, \"get acpi handle failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\twakeup = &adev->wakeup;\n\n\t \n\tacpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);\n\n\tacpi_sts = acpi_enable_gpe(wakeup->gpe_device, wakeup->gpe_number);\n\tif (ACPI_FAILURE(acpi_sts)) {\n\t\tdev_err(dev, \"enable ose_gpe failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n#else\n\treturn -ENODEV;\n#endif\n}\n\nstatic void enable_pme_wake(struct pci_dev *pdev)\n{\n\tif ((pci_pme_capable(pdev, PCI_D0) ||\n\t     pci_pme_capable(pdev, PCI_D3hot) ||\n\t     pci_pme_capable(pdev, PCI_D3cold)) && !enable_gpe(&pdev->dev)) {\n\t\tpci_pme_active(pdev, true);\n\t\tdev_dbg(&pdev->dev, \"ish ipc driver pme wake enabled\\n\");\n\t}\n}\n\n \nstatic int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint ret;\n\tstruct ish_hw *hw;\n\tunsigned long irq_flag = 0;\n\tstruct ishtp_device *ishtp;\n\tstruct device *dev = &pdev->dev;\n\n\t \n\tif (pci_dev_present(ish_invalid_pci_ids))\n\t\treturn -ENODEV;\n\n\t \n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"ISH: Failed to enable PCI device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpci_set_master(pdev);\n\n\t \n\tret = pcim_iomap_regions(pdev, 1 << 0, KBUILD_MODNAME);\n\tif (ret) {\n\t\tdev_err(dev, \"ISH: Failed to get PCI regions\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tishtp = ish_dev_init(pdev);\n\tif (!ishtp) {\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\thw = to_ish_hw(ishtp);\n\tishtp->print_log = ish_event_tracer;\n\n\t \n\thw->mem_addr = pcim_iomap_table(pdev)[0];\n\tishtp->pdev = pdev;\n\n\t \n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (!pdev->msi_enabled && !pdev->msix_enabled)\n\t\tirq_flag = IRQF_SHARED;\n\n\tret = devm_request_irq(dev, pdev->irq, ish_irq_handler,\n\t\t\t       irq_flag, KBUILD_MODNAME, ishtp);\n\tif (ret) {\n\t\tdev_err(dev, \"ISH: request IRQ %d failed\\n\", pdev->irq);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(ishtp->devc, ishtp);\n\n\tinit_waitqueue_head(&ishtp->suspend_wait);\n\tinit_waitqueue_head(&ishtp->resume_wait);\n\n\t \n\tif (pdev->device == EHL_Ax_DEVICE_ID)\n\t\tenable_pme_wake(pdev);\n\n\tret = ish_init(ishtp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic void ish_remove(struct pci_dev *pdev)\n{\n\tstruct ishtp_device *ishtp_dev = pci_get_drvdata(pdev);\n\n\tishtp_bus_remove_all_clients(ishtp_dev, false);\n\tish_device_disable(ishtp_dev);\n}\n\nstatic struct device __maybe_unused *ish_resume_device;\n\n \n#define WAIT_FOR_RESUME_ACK_MS\t\t50\n\n \nstatic void __maybe_unused ish_resume_handler(struct work_struct *work)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ish_resume_device);\n\tstruct ishtp_device *dev = pci_get_drvdata(pdev);\n\tuint32_t fwsts = dev->ops->get_fw_status(dev);\n\n\tif (ish_should_leave_d0i3(pdev) && !dev->suspend_flag\n\t\t\t&& IPC_IS_ISH_ILUP(fwsts)) {\n\t\tif (device_may_wakeup(&pdev->dev))\n\t\t\tdisable_irq_wake(pdev->irq);\n\n\t\tish_set_host_ready(dev);\n\n\t\tishtp_send_resume(dev);\n\n\t\t \n\t\tif (dev->resume_flag)\n\t\t\twait_event_interruptible_timeout(dev->resume_wait,\n\t\t\t\t!dev->resume_flag,\n\t\t\t\tmsecs_to_jiffies(WAIT_FOR_RESUME_ACK_MS));\n\n\t\t \n\t\tif (dev->resume_flag)\n\t\t\tish_init(dev);\n\t} else {\n\t\t \n\t\tish_init(dev);\n\t}\n}\n\n \nstatic int __maybe_unused ish_suspend(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct ishtp_device *dev = pci_get_drvdata(pdev);\n\n\tif (ish_should_enter_d0i3(pdev)) {\n\t\t \n\t\tif (dev->suspend_flag)\n\t\t\treturn\t0;\n\n\t\tdev->resume_flag = 0;\n\t\tdev->suspend_flag = 1;\n\t\tishtp_send_suspend(dev);\n\n\t\t \n\t\tif (dev->suspend_flag)\n\t\t\twait_event_interruptible_timeout(dev->suspend_wait,\n\t\t\t\t\t!dev->suspend_flag,\n\t\t\t\t\tmsecs_to_jiffies(25));\n\n\t\tif (dev->suspend_flag) {\n\t\t\t \n\t\t\tish_disable_dma(dev);\n\t\t} else {\n\t\t\t \n\t\t\tpci_save_state(pdev);\n\n\t\t\tif (device_may_wakeup(&pdev->dev))\n\t\t\t\tenable_irq_wake(pdev->irq);\n\t\t}\n\t} else {\n\t\t \n\t\tish_disable_dma(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic __maybe_unused DECLARE_WORK(resume_work, ish_resume_handler);\n \nstatic int __maybe_unused ish_resume(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct ishtp_device *dev = pci_get_drvdata(pdev);\n\n\t \n\tif (dev->pdev->device == EHL_Ax_DEVICE_ID) {\n\t\tpci_set_power_state(pdev, PCI_D0);\n\t\tenable_pme_wake(pdev);\n\t\tdev_dbg(dev->devc, \"set power state to D0 for ehl\\n\");\n\t}\n\n\tish_resume_device = device;\n\tdev->resume_flag = 1;\n\n\tschedule_work(&resume_work);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ish_pm_ops, ish_suspend, ish_resume);\n\nstatic struct pci_driver ish_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = ish_pci_tbl,\n\t.probe = ish_probe,\n\t.remove = ish_remove,\n\t.driver.pm = &ish_pm_ops,\n};\n\nmodule_pci_driver(ish_driver);\n\n \nMODULE_AUTHOR(\"Daniel Drubin <daniel.drubin@intel.com>\");\n \nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\n\nMODULE_DESCRIPTION(\"Intel(R) Integrated Sensor Hub PCI Device Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}