{
  "module_name": "amd_sfh_hid.c",
  "hash_id": "7218bc95f26fd0a0ffdf2a8a1d7be2d12bda20dc2124f620d69b8dae6a86887c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/amd-sfh-hid/amd_sfh_hid.c",
  "human_readable_source": "\n \n#include <linux/hid.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n\n#include \"amd_sfh_hid.h\"\n#include \"amd_sfh_pcie.h\"\n\n#define AMD_SFH_RESPONSE_TIMEOUT\t1500\n\n \nstatic int amdtp_hid_parse(struct hid_device *hid)\n{\n\tstruct amdtp_hid_data *hid_data = hid->driver_data;\n\tstruct amdtp_cl_data *cli_data = hid_data->cli_data;\n\n\treturn hid_parse_report(hid, cli_data->report_descr[hid_data->index],\n\t\t\t      cli_data->report_descr_sz[hid_data->index]);\n}\n\n \nstatic int amdtp_hid_start(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void amdtp_hid_stop(struct hid_device *hid)\n{\n}\n\nstatic int amdtp_hid_open(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void amdtp_hid_close(struct hid_device *hid)\n{\n}\n\nstatic int amdtp_raw_request(struct hid_device *hdev, u8 reportnum,\n\t\t\t     u8 *buf, size_t len, u8 rtype, int reqtype)\n{\n\treturn 0;\n}\n\nstatic void amdtp_hid_request(struct hid_device *hid, struct hid_report *rep, int reqtype)\n{\n\tint rc;\n\n\tswitch (reqtype) {\n\tcase HID_REQ_GET_REPORT:\n\t\trc = amd_sfh_get_report(hid, rep->id, rep->type);\n\t\tif (rc)\n\t\t\tdev_err(&hid->dev, \"AMDSFH  get report error\\n\");\n\t\tbreak;\n\tcase HID_REQ_SET_REPORT:\n\t\tamd_sfh_set_report(hid, rep->id, reqtype);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int amdtp_wait_for_response(struct hid_device *hid)\n{\n\tstruct amdtp_hid_data *hid_data =  hid->driver_data;\n\tstruct amdtp_cl_data *cli_data = hid_data->cli_data;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < cli_data->num_hid_devices; i++) {\n\t\tif (cli_data->hid_sensor_hubs[i] == hid)\n\t\t\tbreak;\n\t}\n\n\tif (!cli_data->request_done[i])\n\t\tret = wait_event_interruptible_timeout(hid_data->hid_wait,\n\t\t\t\t\t\t       cli_data->request_done[i],\n\t\t\t\t\t\t       msecs_to_jiffies(AMD_SFH_RESPONSE_TIMEOUT));\n\tif (ret == -ERESTARTSYS)\n\t\treturn -ERESTARTSYS;\n\telse if (ret < 0)\n\t\treturn -ETIMEDOUT;\n\telse\n\t\treturn 0;\n}\n\nvoid amdtp_hid_wakeup(struct hid_device *hid)\n{\n\tstruct amdtp_hid_data *hid_data;\n\tstruct amdtp_cl_data *cli_data;\n\n\tif (hid) {\n\t\thid_data = hid->driver_data;\n\t\tcli_data = hid_data->cli_data;\n\t\tcli_data->request_done[cli_data->cur_hid_dev] = true;\n\t\twake_up_interruptible(&hid_data->hid_wait);\n\t}\n}\n\nstatic const struct hid_ll_driver amdtp_hid_ll_driver = {\n\t.parse\t=\tamdtp_hid_parse,\n\t.start\t=\tamdtp_hid_start,\n\t.stop\t=\tamdtp_hid_stop,\n\t.open\t=\tamdtp_hid_open,\n\t.close\t=\tamdtp_hid_close,\n\t.request  =\tamdtp_hid_request,\n\t.wait\t=\tamdtp_wait_for_response,\n\t.raw_request  =\tamdtp_raw_request,\n};\n\nint amdtp_hid_probe(u32 cur_hid_dev, struct amdtp_cl_data *cli_data)\n{\n\tstruct amd_mp2_dev *mp2 = container_of(cli_data->in_data, struct amd_mp2_dev, in_data);\n\tstruct device *dev = &mp2->pdev->dev;\n\tstruct hid_device *hid;\n\tstruct amdtp_hid_data *hid_data;\n\tint rc;\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid))\n\t\treturn PTR_ERR(hid);\n\n\thid_data = kzalloc(sizeof(*hid_data), GFP_KERNEL);\n\tif (!hid_data) {\n\t\trc = -ENOMEM;\n\t\tgoto err_hid_data;\n\t}\n\n\thid->ll_driver = &amdtp_hid_ll_driver;\n\thid_data->index = cur_hid_dev;\n\thid_data->cli_data = cli_data;\n\tinit_waitqueue_head(&hid_data->hid_wait);\n\n\thid->driver_data = hid_data;\n\tcli_data->hid_sensor_hubs[cur_hid_dev] = hid;\n\tstrscpy(hid->phys, dev->driver ? dev->driver->name : dev_name(dev),\n\t\tsizeof(hid->phys));\n\thid->bus = BUS_AMD_SFH;\n\thid->vendor = AMD_SFH_HID_VENDOR;\n\thid->product = AMD_SFH_HID_PRODUCT;\n\tsnprintf(hid->name, sizeof(hid->name), \"%s %04X:%04X\", \"hid-amdsfh\",\n\t\t hid->vendor, hid->product);\n\n\trc = hid_add_device(hid);\n\tif (rc)\n\t\tgoto err_hid_device;\n\treturn 0;\n\nerr_hid_device:\n\tkfree(hid_data);\nerr_hid_data:\n\thid_destroy_device(hid);\n\treturn rc;\n}\n\nvoid amdtp_hid_remove(struct amdtp_cl_data *cli_data)\n{\n\tint i;\n\n\tfor (i = 0; i < cli_data->num_hid_devices; ++i) {\n\t\tif (cli_data->hid_sensor_hubs[i]) {\n\t\t\tkfree(cli_data->hid_sensor_hubs[i]->driver_data);\n\t\t\thid_destroy_device(cli_data->hid_sensor_hubs[i]);\n\t\t\tcli_data->hid_sensor_hubs[i] = NULL;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}