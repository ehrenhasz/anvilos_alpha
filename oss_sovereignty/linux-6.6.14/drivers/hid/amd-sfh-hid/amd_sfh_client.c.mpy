{
  "module_name": "amd_sfh_client.c",
  "hash_id": "64fde79bbac4621a9425bc85fe5a2729774dc5d1438d96db76f7966c674e781d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/amd-sfh-hid/amd_sfh_client.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/hid.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/errno.h>\n\n#include \"hid_descriptor/amd_sfh_hid_desc.h\"\n#include \"amd_sfh_pcie.h\"\n#include \"amd_sfh_hid.h\"\n\nvoid amd_sfh_set_report(struct hid_device *hid, int report_id,\n\t\t\tint report_type)\n{\n\tstruct amdtp_hid_data *hid_data = hid->driver_data;\n\tstruct amdtp_cl_data *cli_data = hid_data->cli_data;\n\tint i;\n\n\tfor (i = 0; i < cli_data->num_hid_devices; i++) {\n\t\tif (cli_data->hid_sensor_hubs[i] == hid) {\n\t\t\tcli_data->cur_hid_dev = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tamdtp_hid_wakeup(hid);\n}\n\nint amd_sfh_get_report(struct hid_device *hid, int report_id, int report_type)\n{\n\tstruct amdtp_hid_data *hid_data = hid->driver_data;\n\tstruct amdtp_cl_data *cli_data = hid_data->cli_data;\n\tstruct request_list *req_list = &cli_data->req_list;\n\tint i;\n\n\tfor (i = 0; i < cli_data->num_hid_devices; i++) {\n\t\tif (cli_data->hid_sensor_hubs[i] == hid) {\n\t\t\tstruct request_list *new = kzalloc(sizeof(*new), GFP_KERNEL);\n\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnew->current_index = i;\n\t\t\tnew->sensor_idx = cli_data->sensor_idx[i];\n\t\t\tnew->hid = hid;\n\t\t\tnew->report_type = report_type;\n\t\t\tnew->report_id = report_id;\n\t\t\tcli_data->report_id[i] = report_id;\n\t\t\tcli_data->request_done[i] = false;\n\t\t\tlist_add(&new->list, &req_list->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tschedule_delayed_work(&cli_data->work, 0);\n\treturn 0;\n}\n\nvoid amd_sfh_work(struct work_struct *work)\n{\n\tstruct amdtp_cl_data *cli_data = container_of(work, struct amdtp_cl_data, work.work);\n\tstruct request_list *req_list = &cli_data->req_list;\n\tstruct amd_input_data *in_data = cli_data->in_data;\n\tstruct request_list *req_node;\n\tu8 current_index, sensor_index;\n\tstruct amd_mp2_ops *mp2_ops;\n\tstruct amd_mp2_dev *mp2;\n\tu8 report_id, node_type;\n\tu8 report_size = 0;\n\n\treq_node = list_last_entry(&req_list->list, struct request_list, list);\n\tlist_del(&req_node->list);\n\tcurrent_index = req_node->current_index;\n\tsensor_index = req_node->sensor_idx;\n\treport_id = req_node->report_id;\n\tnode_type = req_node->report_type;\n\tkfree(req_node);\n\n\tmp2 = container_of(in_data, struct amd_mp2_dev, in_data);\n\tmp2_ops = mp2->mp2_ops;\n\tif (node_type == HID_FEATURE_REPORT) {\n\t\treport_size = mp2_ops->get_feat_rep(sensor_index, report_id,\n\t\t\t\t\t\t    cli_data->feature_report[current_index]);\n\t\tif (report_size)\n\t\t\thid_input_report(cli_data->hid_sensor_hubs[current_index],\n\t\t\t\t\t cli_data->report_type[current_index],\n\t\t\t\t\t cli_data->feature_report[current_index], report_size, 0);\n\t\telse\n\t\t\tpr_err(\"AMDSFH: Invalid report size\\n\");\n\n\t} else if (node_type == HID_INPUT_REPORT) {\n\t\treport_size = mp2_ops->get_in_rep(current_index, sensor_index, report_id, in_data);\n\t\tif (report_size)\n\t\t\thid_input_report(cli_data->hid_sensor_hubs[current_index],\n\t\t\t\t\t cli_data->report_type[current_index],\n\t\t\t\t\t in_data->input_report[current_index], report_size, 0);\n\t\telse\n\t\t\tpr_err(\"AMDSFH: Invalid report size\\n\");\n\t}\n\tcli_data->cur_hid_dev = current_index;\n\tcli_data->sensor_requested_cnt[current_index] = 0;\n\tamdtp_hid_wakeup(cli_data->hid_sensor_hubs[current_index]);\n}\n\nvoid amd_sfh_work_buffer(struct work_struct *work)\n{\n\tstruct amdtp_cl_data *cli_data = container_of(work, struct amdtp_cl_data, work_buffer.work);\n\tstruct amd_input_data *in_data = cli_data->in_data;\n\tstruct amd_mp2_dev *mp2;\n\tu8 report_size;\n\tint i;\n\n\tfor (i = 0; i < cli_data->num_hid_devices; i++) {\n\t\tif (cli_data->sensor_sts[i] == SENSOR_ENABLED) {\n\t\t\tmp2 = container_of(in_data, struct amd_mp2_dev, in_data);\n\t\t\treport_size = mp2->mp2_ops->get_in_rep(i, cli_data->sensor_idx[i],\n\t\t\t\t\t\t\t       cli_data->report_id[i], in_data);\n\t\t\thid_input_report(cli_data->hid_sensor_hubs[i], HID_INPUT_REPORT,\n\t\t\t\t\t in_data->input_report[i], report_size, 0);\n\t\t}\n\t}\n\tschedule_delayed_work(&cli_data->work_buffer, msecs_to_jiffies(AMD_SFH_IDLE_LOOP));\n}\n\nstatic u32 amd_sfh_wait_for_response(struct amd_mp2_dev *mp2, u8 sid, u32 sensor_sts)\n{\n\tif (mp2->mp2_ops->response)\n\t\tsensor_sts = mp2->mp2_ops->response(mp2, sid, sensor_sts);\n\n\treturn sensor_sts;\n}\n\nstatic const char *get_sensor_name(int idx)\n{\n\tswitch (idx) {\n\tcase accel_idx:\n\t\treturn \"accelerometer\";\n\tcase gyro_idx:\n\t\treturn \"gyroscope\";\n\tcase mag_idx:\n\t\treturn \"magnetometer\";\n\tcase als_idx:\n\tcase ACS_IDX:  \n\t\treturn \"ALS\";\n\tcase HPD_IDX:\n\t\treturn \"HPD\";\n\tdefault:\n\t\treturn \"unknown sensor type\";\n\t}\n}\n\nstatic void amd_sfh_resume(struct amd_mp2_dev *mp2)\n{\n\tstruct amdtp_cl_data *cl_data = mp2->cl_data;\n\tstruct amd_mp2_sensor_info info;\n\tint i, status;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (cl_data->sensor_sts[i] == SENSOR_DISABLED) {\n\t\t\tinfo.period = AMD_SFH_IDLE_LOOP;\n\t\t\tinfo.sensor_idx = cl_data->sensor_idx[i];\n\t\t\tinfo.dma_address = cl_data->sensor_dma_addr[i];\n\t\t\tmp2->mp2_ops->start(mp2, info);\n\t\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t\t(mp2, cl_data->sensor_idx[i], SENSOR_ENABLED);\n\t\t\tif (status == SENSOR_ENABLED)\n\t\t\t\tcl_data->sensor_sts[i] = SENSOR_ENABLED;\n\t\t\tdev_dbg(&mp2->pdev->dev, \"resume sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\t\tcl_data->sensor_sts[i]);\n\t\t}\n\t}\n\n\tschedule_delayed_work(&cl_data->work_buffer, msecs_to_jiffies(AMD_SFH_IDLE_LOOP));\n\tamd_sfh_clear_intr(mp2);\n}\n\nstatic void amd_sfh_suspend(struct amd_mp2_dev *mp2)\n{\n\tstruct amdtp_cl_data *cl_data = mp2->cl_data;\n\tint i, status;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (cl_data->sensor_idx[i] != HPD_IDX &&\n\t\t    cl_data->sensor_sts[i] == SENSOR_ENABLED) {\n\t\t\tmp2->mp2_ops->stop(mp2, cl_data->sensor_idx[i]);\n\t\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t\t(mp2, cl_data->sensor_idx[i], SENSOR_DISABLED);\n\t\t\tif (status != SENSOR_ENABLED)\n\t\t\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\t\tdev_dbg(&mp2->pdev->dev, \"suspend sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\t\tcl_data->sensor_sts[i]);\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&cl_data->work_buffer);\n\tamd_sfh_clear_intr(mp2);\n}\n\nint amd_sfh_hid_client_init(struct amd_mp2_dev *privdata)\n{\n\tstruct amd_input_data *in_data = &privdata->in_data;\n\tstruct amdtp_cl_data *cl_data = privdata->cl_data;\n\tstruct amd_mp2_ops *mp2_ops = privdata->mp2_ops;\n\tstruct amd_mp2_sensor_info info;\n\tstruct request_list *req_list;\n\tstruct device *dev;\n\tu32 feature_report_size;\n\tu32 input_report_size;\n\tint rc, i;\n\tu8 cl_idx;\n\n\treq_list = &cl_data->req_list;\n\tdev = &privdata->pdev->dev;\n\tamd_sfh_set_desc_ops(mp2_ops);\n\n\tmp2_ops->suspend = amd_sfh_suspend;\n\tmp2_ops->resume = amd_sfh_resume;\n\n\tcl_data->num_hid_devices = amd_mp2_get_sensor_num(privdata, &cl_data->sensor_idx[0]);\n\tif (cl_data->num_hid_devices == 0)\n\t\treturn -ENODEV;\n\tcl_data->is_any_sensor_enabled = false;\n\n\tINIT_DELAYED_WORK(&cl_data->work, amd_sfh_work);\n\tINIT_DELAYED_WORK(&cl_data->work_buffer, amd_sfh_work_buffer);\n\tINIT_LIST_HEAD(&req_list->list);\n\tcl_data->in_data = in_data;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tin_data->sensor_virt_addr[i] = dma_alloc_coherent(dev, sizeof(int) * 8,\n\t\t\t\t\t\t\t\t  &cl_data->sensor_dma_addr[i],\n\t\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!in_data->sensor_virt_addr[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\tcl_data->sensor_requested_cnt[i] = 0;\n\t\tcl_data->cur_hid_dev = i;\n\t\tcl_idx = cl_data->sensor_idx[i];\n\t\tcl_data->report_descr_sz[i] = mp2_ops->get_desc_sz(cl_idx, descr_size);\n\t\tif (!cl_data->report_descr_sz[i]) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfeature_report_size = mp2_ops->get_desc_sz(cl_idx, feature_size);\n\t\tif (!feature_report_size) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinput_report_size =  mp2_ops->get_desc_sz(cl_idx, input_size);\n\t\tif (!input_report_size) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcl_data->feature_report[i] = devm_kzalloc(dev, feature_report_size, GFP_KERNEL);\n\t\tif (!cl_data->feature_report[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tin_data->input_report[i] = devm_kzalloc(dev, input_report_size, GFP_KERNEL);\n\t\tif (!in_data->input_report[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo.period = AMD_SFH_IDLE_LOOP;\n\t\tinfo.sensor_idx = cl_idx;\n\t\tinfo.dma_address = cl_data->sensor_dma_addr[i];\n\n\t\tcl_data->report_descr[i] =\n\t\t\tdevm_kzalloc(dev, cl_data->report_descr_sz[i], GFP_KERNEL);\n\t\tif (!cl_data->report_descr[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\trc = mp2_ops->get_rep_desc(cl_idx, cl_data->report_descr[i]);\n\t\tif (rc)\n\t\t\tgoto cleanup;\n\t\tmp2_ops->start(privdata, info);\n\t\tcl_data->sensor_sts[i] = amd_sfh_wait_for_response\n\t\t\t\t\t\t(privdata, cl_data->sensor_idx[i], SENSOR_ENABLED);\n\t}\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tcl_data->cur_hid_dev = i;\n\t\tif (cl_data->sensor_sts[i] == SENSOR_ENABLED) {\n\t\t\tcl_data->is_any_sensor_enabled = true;\n\t\t\trc = amdtp_hid_probe(i, cl_data);\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\t}\n\t\tdev_dbg(dev, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\tcl_data->sensor_sts[i]);\n\t}\n\n\tif (!cl_data->is_any_sensor_enabled ||\n\t   (mp2_ops->discovery_status && mp2_ops->discovery_status(privdata) == 0)) {\n\t\tdev_warn(dev, \"Failed to discover, sensors not enabled is %d\\n\", cl_data->is_any_sensor_enabled);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto cleanup;\n\t}\n\tschedule_delayed_work(&cl_data->work_buffer, msecs_to_jiffies(AMD_SFH_IDLE_LOOP));\n\treturn 0;\n\ncleanup:\n\tamd_sfh_hid_client_deinit(privdata);\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tdevm_kfree(dev, cl_data->feature_report[i]);\n\t\tdevm_kfree(dev, in_data->input_report[i]);\n\t\tdevm_kfree(dev, cl_data->report_descr[i]);\n\t}\n\treturn rc;\n}\n\nint amd_sfh_hid_client_deinit(struct amd_mp2_dev *privdata)\n{\n\tstruct amdtp_cl_data *cl_data = privdata->cl_data;\n\tstruct amd_input_data *in_data = cl_data->in_data;\n\tint i, status;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (cl_data->sensor_sts[i] == SENSOR_ENABLED) {\n\t\t\tprivdata->mp2_ops->stop(privdata, cl_data->sensor_idx[i]);\n\t\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t\t(privdata, cl_data->sensor_idx[i], SENSOR_DISABLED);\n\t\t\tif (status != SENSOR_ENABLED)\n\t\t\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\t\tdev_dbg(&privdata->pdev->dev, \"stopping sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\t\tcl_data->sensor_sts[i]);\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&cl_data->work);\n\tcancel_delayed_work_sync(&cl_data->work_buffer);\n\tamdtp_hid_remove(cl_data);\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (in_data->sensor_virt_addr[i]) {\n\t\t\tdma_free_coherent(&privdata->pdev->dev, 8 * sizeof(int),\n\t\t\t\t\t  in_data->sensor_virt_addr[i],\n\t\t\t\t\t  cl_data->sensor_dma_addr[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}