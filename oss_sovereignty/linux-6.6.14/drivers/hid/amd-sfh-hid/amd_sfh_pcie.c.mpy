{
  "module_name": "amd_sfh_pcie.c",
  "hash_id": "1c58bfba34dfb2164e09005af3396c22d222c3494eecbc06f8a428b4e2e039e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/amd-sfh-hid/amd_sfh_pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmi.h>\n#include <linux/interrupt.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"amd_sfh_pcie.h\"\n#include \"sfh1_1/amd_sfh_init.h\"\n\n#define DRIVER_NAME\t\"pcie_mp2_amd\"\n#define DRIVER_DESC\t\"AMD(R) PCIe MP2 Communication Driver\"\n\n#define ACEL_EN\t\tBIT(0)\n#define GYRO_EN\t\tBIT(1)\n#define MAGNO_EN\tBIT(2)\n#define HPD_EN\t\tBIT(16)\n#define ALS_EN\t\tBIT(19)\n#define ACS_EN\t\tBIT(22)\n\nstatic int sensor_mask_override = -1;\nmodule_param_named(sensor_mask, sensor_mask_override, int, 0444);\nMODULE_PARM_DESC(sensor_mask, \"override the detected sensors mask\");\n\nstatic int amd_sfh_wait_response_v2(struct amd_mp2_dev *mp2, u8 sid, u32 sensor_sts)\n{\n\tunion cmd_response cmd_resp;\n\n\t \n\tif (!readl_poll_timeout(mp2->mmio + AMD_P2C_MSG(0), cmd_resp.resp,\n\t\t\t\t(cmd_resp.response_v2.response == sensor_sts &&\n\t\t\t\tcmd_resp.response_v2.status == 0 && (sid == 0xff ||\n\t\t\t\tcmd_resp.response_v2.sensor_id == sid)), 500, 1600000))\n\t\treturn cmd_resp.response_v2.response;\n\n\treturn SENSOR_DISABLED;\n}\n\nstatic void amd_start_sensor_v2(struct amd_mp2_dev *privdata, struct amd_mp2_sensor_info info)\n{\n\tunion sfh_cmd_base cmd_base;\n\n\tcmd_base.ul = 0;\n\tcmd_base.cmd_v2.cmd_id = ENABLE_SENSOR;\n\tcmd_base.cmd_v2.intr_disable = 1;\n\tcmd_base.cmd_v2.period = info.period;\n\tcmd_base.cmd_v2.sensor_id = info.sensor_idx;\n\tcmd_base.cmd_v2.length = 16;\n\n\tif (info.sensor_idx == als_idx)\n\t\tcmd_base.cmd_v2.mem_type = USE_C2P_REG;\n\n\twriteq(info.dma_address, privdata->mmio + AMD_C2P_MSG1);\n\twritel(cmd_base.ul, privdata->mmio + AMD_C2P_MSG0);\n}\n\nstatic void amd_stop_sensor_v2(struct amd_mp2_dev *privdata, u16 sensor_idx)\n{\n\tunion sfh_cmd_base cmd_base;\n\n\tcmd_base.ul = 0;\n\tcmd_base.cmd_v2.cmd_id = DISABLE_SENSOR;\n\tcmd_base.cmd_v2.intr_disable = 1;\n\tcmd_base.cmd_v2.period = 0;\n\tcmd_base.cmd_v2.sensor_id = sensor_idx;\n\tcmd_base.cmd_v2.length  = 16;\n\n\twriteq(0x0, privdata->mmio + AMD_C2P_MSG1);\n\twritel(cmd_base.ul, privdata->mmio + AMD_C2P_MSG0);\n}\n\nstatic void amd_stop_all_sensor_v2(struct amd_mp2_dev *privdata)\n{\n\tunion sfh_cmd_base cmd_base;\n\n\tcmd_base.cmd_v2.cmd_id = STOP_ALL_SENSORS;\n\tcmd_base.cmd_v2.intr_disable = 1;\n\tcmd_base.cmd_v2.period = 0;\n\tcmd_base.cmd_v2.sensor_id = 0;\n\n\twritel(cmd_base.ul, privdata->mmio + AMD_C2P_MSG0);\n}\n\nvoid amd_sfh_clear_intr_v2(struct amd_mp2_dev *privdata)\n{\n\tif (readl(privdata->mmio + AMD_P2C_MSG(4))) {\n\t\twritel(0, privdata->mmio + AMD_P2C_MSG(4));\n\t\twritel(0xf, privdata->mmio + AMD_P2C_MSG(5));\n\t}\n}\n\nvoid amd_sfh_clear_intr(struct amd_mp2_dev *privdata)\n{\n\tif (privdata->mp2_ops->clear_intr)\n\t\tprivdata->mp2_ops->clear_intr(privdata);\n}\n\nstatic irqreturn_t amd_sfh_irq_handler(int irq, void *data)\n{\n\tamd_sfh_clear_intr(data);\n\n\treturn IRQ_HANDLED;\n}\n\nint amd_sfh_irq_init_v2(struct amd_mp2_dev *privdata)\n{\n\tint rc;\n\n\tpci_intx(privdata->pdev, true);\n\n\trc = devm_request_irq(&privdata->pdev->dev, privdata->pdev->irq,\n\t\t\t      amd_sfh_irq_handler, 0, DRIVER_NAME, privdata);\n\tif (rc) {\n\t\tdev_err(&privdata->pdev->dev, \"failed to request irq %d err=%d\\n\",\n\t\t\tprivdata->pdev->irq, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int amd_sfh_dis_sts_v2(struct amd_mp2_dev *privdata)\n{\n\treturn (readl(privdata->mmio + AMD_P2C_MSG(1)) &\n\t\t      SENSOR_DISCOVERY_STATUS_MASK) >> SENSOR_DISCOVERY_STATUS_SHIFT;\n}\n\nstatic void amd_start_sensor(struct amd_mp2_dev *privdata, struct amd_mp2_sensor_info info)\n{\n\tunion sfh_cmd_param cmd_param;\n\tunion sfh_cmd_base cmd_base;\n\n\t \n\tmemset(&cmd_base, 0, sizeof(cmd_base));\n\tcmd_base.s.cmd_id = ENABLE_SENSOR;\n\tcmd_base.s.period = info.period;\n\tcmd_base.s.sensor_id = info.sensor_idx;\n\n\t \n\tmemset(&cmd_param, 0, sizeof(cmd_param));\n\tcmd_param.s.buf_layout = 1;\n\tcmd_param.s.buf_length = 16;\n\n\twriteq(info.dma_address, privdata->mmio + AMD_C2P_MSG2);\n\twritel(cmd_param.ul, privdata->mmio + AMD_C2P_MSG1);\n\twritel(cmd_base.ul, privdata->mmio + AMD_C2P_MSG0);\n}\n\nstatic void amd_stop_sensor(struct amd_mp2_dev *privdata, u16 sensor_idx)\n{\n\tunion sfh_cmd_base cmd_base;\n\n\t \n\tmemset(&cmd_base, 0, sizeof(cmd_base));\n\tcmd_base.s.cmd_id = DISABLE_SENSOR;\n\tcmd_base.s.period = 0;\n\tcmd_base.s.sensor_id = sensor_idx;\n\n\twriteq(0x0, privdata->mmio + AMD_C2P_MSG2);\n\twritel(cmd_base.ul, privdata->mmio + AMD_C2P_MSG0);\n}\n\nstatic void amd_stop_all_sensors(struct amd_mp2_dev *privdata)\n{\n\tunion sfh_cmd_base cmd_base;\n\n\t \n\tmemset(&cmd_base, 0, sizeof(cmd_base));\n\tcmd_base.s.cmd_id = STOP_ALL_SENSORS;\n\tcmd_base.s.period = 0;\n\tcmd_base.s.sensor_id = 0;\n\n\twritel(cmd_base.ul, privdata->mmio + AMD_C2P_MSG0);\n}\n\nstatic const struct dmi_system_id dmi_sensor_mask_overrides[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP ENVY x360 Convertible 13-ag0xxx\"),\n\t\t},\n\t\t.driver_data = (void *)(ACEL_EN | MAGNO_EN),\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP ENVY x360 Convertible 15-cp0xxx\"),\n\t\t},\n\t\t.driver_data = (void *)(ACEL_EN | MAGNO_EN),\n\t},\n\t{ }\n};\n\nint amd_mp2_get_sensor_num(struct amd_mp2_dev *privdata, u8 *sensor_id)\n{\n\tint activestatus, num_of_sensors = 0;\n\tconst struct dmi_system_id *dmi_id;\n\n\tif (sensor_mask_override == -1) {\n\t\tdmi_id = dmi_first_match(dmi_sensor_mask_overrides);\n\t\tif (dmi_id)\n\t\t\tsensor_mask_override = (long)dmi_id->driver_data;\n\t}\n\n\tif (sensor_mask_override >= 0) {\n\t\tactivestatus = sensor_mask_override;\n\t} else {\n\t\tactivestatus = privdata->mp2_acs >> 4;\n\t}\n\n\tif (ACEL_EN  & activestatus)\n\t\tsensor_id[num_of_sensors++] = accel_idx;\n\n\tif (GYRO_EN & activestatus)\n\t\tsensor_id[num_of_sensors++] = gyro_idx;\n\n\tif (MAGNO_EN & activestatus)\n\t\tsensor_id[num_of_sensors++] = mag_idx;\n\n\tif (ALS_EN & activestatus)\n\t\tsensor_id[num_of_sensors++] = als_idx;\n\n\tif (HPD_EN & activestatus)\n\t\tsensor_id[num_of_sensors++] = HPD_IDX;\n\n\tif (ACS_EN & activestatus)\n\t\tsensor_id[num_of_sensors++] = ACS_IDX;\n\n\treturn num_of_sensors;\n}\n\nstatic void amd_mp2_pci_remove(void *privdata)\n{\n\tstruct amd_mp2_dev *mp2 = privdata;\n\tamd_sfh_hid_client_deinit(privdata);\n\tmp2->mp2_ops->stop_all(mp2);\n\tpci_intx(mp2->pdev, false);\n\tamd_sfh_clear_intr(mp2);\n}\n\nstatic struct amd_mp2_ops amd_sfh_ops_v2 = {\n\t.start = amd_start_sensor_v2,\n\t.stop = amd_stop_sensor_v2,\n\t.stop_all = amd_stop_all_sensor_v2,\n\t.response = amd_sfh_wait_response_v2,\n\t.clear_intr = amd_sfh_clear_intr_v2,\n\t.init_intr = amd_sfh_irq_init_v2,\n\t.discovery_status = amd_sfh_dis_sts_v2,\n\t.remove = amd_mp2_pci_remove,\n};\n\nstatic struct amd_mp2_ops amd_sfh_ops = {\n\t.start = amd_start_sensor,\n\t.stop = amd_stop_sensor,\n\t.stop_all = amd_stop_all_sensors,\n\t.remove = amd_mp2_pci_remove,\n};\n\nstatic void mp2_select_ops(struct amd_mp2_dev *privdata)\n{\n\tu8 acs;\n\n\tprivdata->mp2_acs = readl(privdata->mmio + AMD_P2C_MSG3);\n\tacs = privdata->mp2_acs & GENMASK(3, 0);\n\n\tswitch (acs) {\n\tcase V2_STATUS:\n\t\tprivdata->mp2_ops = &amd_sfh_ops_v2;\n\t\tbreak;\n\tdefault:\n\t\tprivdata->mp2_ops = &amd_sfh_ops;\n\t\tbreak;\n\t}\n}\n\nint amd_sfh_irq_init(struct amd_mp2_dev *privdata)\n{\n\tif (privdata->mp2_ops->init_intr)\n\t\treturn privdata->mp2_ops->init_intr(privdata);\n\n\treturn 0;\n}\n\nstatic const struct dmi_system_id dmi_nodevs[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int amd_mp2_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct amd_mp2_dev *privdata;\n\tint rc;\n\n\tif (dmi_first_match(dmi_nodevs))\n\t\treturn -ENODEV;\n\n\tprivdata = devm_kzalloc(&pdev->dev, sizeof(*privdata), GFP_KERNEL);\n\tif (!privdata)\n\t\treturn -ENOMEM;\n\n\tprivdata->pdev = pdev;\n\tdev_set_drvdata(&pdev->dev, privdata);\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pcim_iomap_regions(pdev, BIT(2), DRIVER_NAME);\n\tif (rc)\n\t\treturn rc;\n\n\tprivdata->mmio = pcim_iomap_table(pdev)[2];\n\tpci_set_master(pdev);\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to set DMA mask\\n\");\n\t\treturn rc;\n\t}\n\n\tprivdata->cl_data = devm_kzalloc(&pdev->dev, sizeof(struct amdtp_cl_data), GFP_KERNEL);\n\tif (!privdata->cl_data)\n\t\treturn -ENOMEM;\n\n\tprivdata->sfh1_1_ops = (const struct amd_sfh1_1_ops *)id->driver_data;\n\tif (privdata->sfh1_1_ops) {\n\t\trc = privdata->sfh1_1_ops->init(privdata);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tgoto init_done;\n\t}\n\n\tmp2_select_ops(privdata);\n\n\trc = amd_sfh_irq_init(privdata);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"amd_sfh_irq_init failed\\n\");\n\t\treturn rc;\n\t}\n\n\trc = amd_sfh_hid_client_init(privdata);\n\tif (rc) {\n\t\tamd_sfh_clear_intr(privdata);\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tdev_err(&pdev->dev, \"amd_sfh_hid_client_init failed\\n\");\n\t\treturn rc;\n\t}\n\ninit_done:\n\tamd_sfh_clear_intr(privdata);\n\n\treturn devm_add_action_or_reset(&pdev->dev, privdata->mp2_ops->remove, privdata);\n}\n\nstatic void amd_sfh_shutdown(struct pci_dev *pdev)\n{\n\tstruct amd_mp2_dev *mp2 = pci_get_drvdata(pdev);\n\n\tif (mp2 && mp2->mp2_ops)\n\t\tmp2->mp2_ops->stop_all(mp2);\n}\n\nstatic int __maybe_unused amd_mp2_pci_resume(struct device *dev)\n{\n\tstruct amd_mp2_dev *mp2 = dev_get_drvdata(dev);\n\n\tmp2->mp2_ops->resume(mp2);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused amd_mp2_pci_suspend(struct device *dev)\n{\n\tstruct amd_mp2_dev *mp2 = dev_get_drvdata(dev);\n\n\tmp2->mp2_ops->suspend(mp2);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(amd_mp2_pm_ops, amd_mp2_pci_suspend,\n\t\tamd_mp2_pci_resume);\n\nstatic const struct pci_device_id amd_mp2_pci_tbl[] = {\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_MP2) },\n\t{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_MP2_1_1),\n\t  .driver_data = (kernel_ulong_t)&sfh1_1_ops },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, amd_mp2_pci_tbl);\n\nstatic struct pci_driver amd_mp2_pci_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= amd_mp2_pci_tbl,\n\t.probe\t\t= amd_mp2_pci_probe,\n\t.driver.pm\t= &amd_mp2_pm_ops,\n\t.shutdown\t= amd_sfh_shutdown,\n};\nmodule_pci_driver(amd_mp2_pci_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Shyam Sundar S K <Shyam-sundar.S-k@amd.com>\");\nMODULE_AUTHOR(\"Sandeep Singh <Sandeep.singh@amd.com>\");\nMODULE_AUTHOR(\"Basavaraj Natikar <Basavaraj.Natikar@amd.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}