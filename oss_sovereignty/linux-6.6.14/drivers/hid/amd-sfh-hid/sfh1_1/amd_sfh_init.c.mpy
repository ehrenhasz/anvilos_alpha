{
  "module_name": "amd_sfh_init.c",
  "hash_id": "63ff9c3655b9544a5e9a9d38b6bbd2516198b2283fdb4e0a4d347426fd49cafc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/amd-sfh-hid/sfh1_1/amd_sfh_init.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/hid.h>\n\n#include \"amd_sfh_init.h\"\n#include \"amd_sfh_interface.h\"\n#include \"../hid_descriptor/amd_sfh_hid_desc.h\"\n\nstatic int amd_sfh_get_sensor_num(struct amd_mp2_dev *mp2, u8 *sensor_id)\n{\n\tstruct sfh_sensor_list *slist;\n\tstruct sfh_base_info binfo;\n\tint num_of_sensors = 0;\n\tint i;\n\n\tmemcpy_fromio(&binfo, mp2->vsbase, sizeof(struct sfh_base_info));\n\tslist = &binfo.sbase.s_list;\n\n\tfor (i = 0; i < MAX_IDX; i++) {\n\t\tswitch (i) {\n\t\tcase ACCEL_IDX:\n\t\tcase GYRO_IDX:\n\t\tcase MAG_IDX:\n\t\tcase ALS_IDX:\n\t\tcase HPD_IDX:\n\t\t\tif (BIT(i) & slist->sl.sensors)\n\t\t\t\tsensor_id[num_of_sensors++] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn num_of_sensors;\n}\n\nstatic u32 amd_sfh_wait_for_response(struct amd_mp2_dev *mp2, u8 sid, u32 cmd_id)\n{\n\tif (mp2->mp2_ops->response)\n\t\treturn mp2->mp2_ops->response(mp2, sid, cmd_id);\n\n\treturn 0;\n}\n\nstatic const char *get_sensor_name(int idx)\n{\n\tswitch (idx) {\n\tcase ACCEL_IDX:\n\t\treturn \"accelerometer\";\n\tcase GYRO_IDX:\n\t\treturn \"gyroscope\";\n\tcase MAG_IDX:\n\t\treturn \"magnetometer\";\n\tcase ALS_IDX:\n\t\treturn \"ALS\";\n\tcase HPD_IDX:\n\t\treturn \"HPD\";\n\tdefault:\n\t\treturn \"unknown sensor type\";\n\t}\n}\n\nstatic int amd_sfh_hid_client_deinit(struct amd_mp2_dev *privdata)\n{\n\tstruct amdtp_cl_data *cl_data = privdata->cl_data;\n\tint i, status;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (cl_data->sensor_sts[i] == SENSOR_ENABLED) {\n\t\t\tprivdata->mp2_ops->stop(privdata, cl_data->sensor_idx[i]);\n\t\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t\t(privdata, cl_data->sensor_idx[i], DISABLE_SENSOR);\n\t\t\tif (status == 0)\n\t\t\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\t\tdev_dbg(&privdata->pdev->dev, \"stopping sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\t\tcl_data->sensor_sts[i]);\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&cl_data->work);\n\tcancel_delayed_work_sync(&cl_data->work_buffer);\n\tamdtp_hid_remove(cl_data);\n\n\treturn 0;\n}\n\nstatic int amd_sfh1_1_hid_client_init(struct amd_mp2_dev *privdata)\n{\n\tstruct amd_input_data *in_data = &privdata->in_data;\n\tstruct amdtp_cl_data *cl_data = privdata->cl_data;\n\tstruct amd_mp2_ops *mp2_ops = privdata->mp2_ops;\n\tstruct amd_mp2_sensor_info info;\n\tstruct request_list *req_list;\n\tu32 feature_report_size;\n\tu32 input_report_size;\n\tstruct device *dev;\n\tint rc, i, status;\n\tu8 cl_idx;\n\n\treq_list = &cl_data->req_list;\n\tdev = &privdata->pdev->dev;\n\tamd_sfh1_1_set_desc_ops(mp2_ops);\n\n\tcl_data->num_hid_devices = amd_sfh_get_sensor_num(privdata, &cl_data->sensor_idx[0]);\n\tif (cl_data->num_hid_devices == 0)\n\t\treturn -ENODEV;\n\tcl_data->is_any_sensor_enabled = false;\n\n\tINIT_DELAYED_WORK(&cl_data->work, amd_sfh_work);\n\tINIT_DELAYED_WORK(&cl_data->work_buffer, amd_sfh_work_buffer);\n\tINIT_LIST_HEAD(&req_list->list);\n\tcl_data->in_data = in_data;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\tcl_data->sensor_requested_cnt[i] = 0;\n\t\tcl_data->cur_hid_dev = i;\n\t\tcl_idx = cl_data->sensor_idx[i];\n\n\t\tcl_data->report_descr_sz[i] = mp2_ops->get_desc_sz(cl_idx, descr_size);\n\t\tif (!cl_data->report_descr_sz[i]) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfeature_report_size = mp2_ops->get_desc_sz(cl_idx, feature_size);\n\t\tif (!feature_report_size) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinput_report_size =  mp2_ops->get_desc_sz(cl_idx, input_size);\n\t\tif (!input_report_size) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcl_data->feature_report[i] = devm_kzalloc(dev, feature_report_size, GFP_KERNEL);\n\t\tif (!cl_data->feature_report[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tin_data->input_report[i] = devm_kzalloc(dev, input_report_size, GFP_KERNEL);\n\t\tif (!in_data->input_report[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tinfo.sensor_idx = cl_idx;\n\n\t\tcl_data->report_descr[i] =\n\t\t\tdevm_kzalloc(dev, cl_data->report_descr_sz[i], GFP_KERNEL);\n\t\tif (!cl_data->report_descr[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\trc = mp2_ops->get_rep_desc(cl_idx, cl_data->report_descr[i]);\n\t\tif (rc)\n\t\t\tgoto cleanup;\n\n\t\twritel(0, privdata->mmio + AMD_P2C_MSG(0));\n\t\tmp2_ops->start(privdata, info);\n\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t(privdata, cl_data->sensor_idx[i], ENABLE_SENSOR);\n\n\t\tcl_data->sensor_sts[i] = (status == 0) ? SENSOR_ENABLED : SENSOR_DISABLED;\n\t}\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tcl_data->cur_hid_dev = i;\n\t\tif (cl_data->sensor_sts[i] == SENSOR_ENABLED) {\n\t\t\tcl_data->is_any_sensor_enabled = true;\n\t\t\trc = amdtp_hid_probe(i, cl_data);\n\t\t\tif (rc)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tdev_dbg(dev, \"sid 0x%x (%s) status 0x%x\\n\",\n\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\tcl_data->sensor_sts[i]);\n\t}\n\n\tif (!cl_data->is_any_sensor_enabled) {\n\t\tdev_warn(dev, \"Failed to discover, sensors not enabled is %d\\n\",\n\t\t\t cl_data->is_any_sensor_enabled);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto cleanup;\n\t}\n\n\tschedule_delayed_work(&cl_data->work_buffer, msecs_to_jiffies(AMD_SFH_IDLE_LOOP));\n\treturn 0;\n\ncleanup:\n\tamd_sfh_hid_client_deinit(privdata);\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tdevm_kfree(dev, cl_data->feature_report[i]);\n\t\tdevm_kfree(dev, in_data->input_report[i]);\n\t\tdevm_kfree(dev, cl_data->report_descr[i]);\n\t}\n\treturn rc;\n}\n\nstatic void amd_sfh_resume(struct amd_mp2_dev *mp2)\n{\n\tstruct amdtp_cl_data *cl_data = mp2->cl_data;\n\tstruct amd_mp2_sensor_info info;\n\tint i, status;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (cl_data->sensor_sts[i] == SENSOR_DISABLED) {\n\t\t\tinfo.sensor_idx = cl_data->sensor_idx[i];\n\t\t\tmp2->mp2_ops->start(mp2, info);\n\t\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t\t(mp2, cl_data->sensor_idx[i], ENABLE_SENSOR);\n\t\t\tif (status == 0)\n\t\t\t\tstatus = SENSOR_ENABLED;\n\t\t\tif (status == SENSOR_ENABLED)\n\t\t\t\tcl_data->sensor_sts[i] = SENSOR_ENABLED;\n\t\t\tdev_dbg(&mp2->pdev->dev, \"resume sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\t\tcl_data->sensor_sts[i]);\n\t\t}\n\t}\n\n\tschedule_delayed_work(&cl_data->work_buffer, msecs_to_jiffies(AMD_SFH_IDLE_LOOP));\n\tamd_sfh_clear_intr(mp2);\n}\n\nstatic void amd_sfh_suspend(struct amd_mp2_dev *mp2)\n{\n\tstruct amdtp_cl_data *cl_data = mp2->cl_data;\n\tint i, status;\n\n\tfor (i = 0; i < cl_data->num_hid_devices; i++) {\n\t\tif (cl_data->sensor_idx[i] != HPD_IDX &&\n\t\t    cl_data->sensor_sts[i] == SENSOR_ENABLED) {\n\t\t\tmp2->mp2_ops->stop(mp2, cl_data->sensor_idx[i]);\n\t\t\tstatus = amd_sfh_wait_for_response\n\t\t\t\t\t(mp2, cl_data->sensor_idx[i], DISABLE_SENSOR);\n\t\t\tif (status == 0)\n\t\t\t\tstatus = SENSOR_DISABLED;\n\t\t\tif (status != SENSOR_ENABLED)\n\t\t\t\tcl_data->sensor_sts[i] = SENSOR_DISABLED;\n\t\t\tdev_dbg(&mp2->pdev->dev, \"suspend sid 0x%x (%s) status 0x%x\\n\",\n\t\t\t\tcl_data->sensor_idx[i], get_sensor_name(cl_data->sensor_idx[i]),\n\t\t\t\tcl_data->sensor_sts[i]);\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&cl_data->work_buffer);\n\tamd_sfh_clear_intr(mp2);\n}\n\nstatic void amd_mp2_pci_remove(void *privdata)\n{\n\tstruct amd_mp2_dev *mp2 = privdata;\n\n\tamd_sfh_hid_client_deinit(privdata);\n\tmp2->mp2_ops->stop_all(mp2);\n\tpci_intx(mp2->pdev, false);\n\tamd_sfh_clear_intr(mp2);\n}\n\nstatic void amd_sfh_set_ops(struct amd_mp2_dev *mp2)\n{\n\tstruct amd_mp2_ops *mp2_ops;\n\n\tsfh_interface_init(mp2);\n\tmp2_ops = mp2->mp2_ops;\n\tmp2_ops->clear_intr = amd_sfh_clear_intr_v2,\n\tmp2_ops->init_intr = amd_sfh_irq_init_v2,\n\tmp2_ops->suspend = amd_sfh_suspend;\n\tmp2_ops->resume = amd_sfh_resume;\n\tmp2_ops->remove = amd_mp2_pci_remove;\n}\n\nint amd_sfh1_1_init(struct amd_mp2_dev *mp2)\n{\n\tu32 phy_base = readl(mp2->mmio + AMD_C2P_MSG(22));\n\tstruct device *dev = &mp2->pdev->dev;\n\tstruct sfh_base_info binfo;\n\tint rc;\n\n\tphy_base <<= 21;\n\tif (!devm_request_mem_region(dev, phy_base, 128 * 1024, \"amd_sfh\")) {\n\t\tdev_dbg(dev, \"can't reserve mmio registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmp2->vsbase = devm_ioremap(dev, phy_base, 128 * 1024);\n\tif (!mp2->vsbase) {\n\t\tdev_dbg(dev, \"failed to remap vsbase\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmsleep(5000);\n\n\tmemcpy_fromio(&binfo, mp2->vsbase, sizeof(struct sfh_base_info));\n\tif (binfo.sbase.fw_info.fw_ver == 0 || binfo.sbase.s_list.sl.sensors == 0) {\n\t\tdev_dbg(dev, \"failed to get sensors\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tdev_dbg(dev, \"firmware version 0x%x\\n\", binfo.sbase.fw_info.fw_ver);\n\n\tamd_sfh_set_ops(mp2);\n\n\trc = amd_sfh_irq_init(mp2);\n\tif (rc) {\n\t\tdev_err(dev, \"amd_sfh_irq_init failed\\n\");\n\t\treturn rc;\n\t}\n\n\trc = amd_sfh1_1_hid_client_init(mp2);\n\tif (rc) {\n\t\tdev_err(dev, \"amd_sfh1_1_hid_client_init failed\\n\");\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}