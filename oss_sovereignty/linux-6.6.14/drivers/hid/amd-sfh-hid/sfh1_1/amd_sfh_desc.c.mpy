{
  "module_name": "amd_sfh_desc.c",
  "hash_id": "6367175bcb92ba5c9869c9e879392a450df75ead65a73755eeeca4ef78931df8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/amd-sfh-hid/sfh1_1/amd_sfh_desc.c",
  "human_readable_source": "\n \n\n#include <linux/hid-sensor-ids.h>\n\n#include \"amd_sfh_interface.h\"\n#include \"../hid_descriptor/amd_sfh_hid_desc.h\"\n#include \"../hid_descriptor/amd_sfh_hid_report_desc.h\"\n\n#define SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM\t\t\t0x41\n#define SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM\t\t\t0x51\n#define HID_DEFAULT_REPORT_INTERVAL\t\t\t\t\t0x50\n#define HID_DEFAULT_MIN_VALUE\t\t\t\t\t\t0X7F\n#define HID_DEFAULT_MAX_VALUE\t\t\t\t\t\t0x80\n#define HID_DEFAULT_SENSITIVITY\t\t\t\t\t\t0x7F\n#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_ENUM\t0x01\n \n#define HID_USAGE_SENSOR_STATE_READY_ENUM\t\t\t\t0x02\n#define HID_USAGE_SENSOR_STATE_INITIALIZING_ENUM\t\t\t0x05\n#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_ENUM\t\t\t0x04\n\nstatic int get_report_desc(int sensor_idx, u8 *rep_desc)\n{\n\tswitch (sensor_idx) {\n\tcase ACCEL_IDX:  \n\t\tmemset(rep_desc, 0, sizeof(accel3_report_descriptor));\n\t\tmemcpy(rep_desc, accel3_report_descriptor,\n\t\t       sizeof(accel3_report_descriptor));\n\t\tbreak;\n\tcase GYRO_IDX:  \n\t\tmemset(rep_desc, 0, sizeof(gyro3_report_descriptor));\n\t\tmemcpy(rep_desc, gyro3_report_descriptor,\n\t\t       sizeof(gyro3_report_descriptor));\n\t\tbreak;\n\tcase MAG_IDX:  \n\t\tmemset(rep_desc, 0, sizeof(comp3_report_descriptor));\n\t\tmemcpy(rep_desc, comp3_report_descriptor,\n\t\t       sizeof(comp3_report_descriptor));\n\t\tbreak;\n\tcase ALS_IDX:  \n\t\tmemset(rep_desc, 0, sizeof(als_report_descriptor));\n\t\tmemcpy(rep_desc, als_report_descriptor,\n\t\t       sizeof(als_report_descriptor));\n\t\tbreak;\n\tcase HPD_IDX:  \n\t\tmemset(rep_desc, 0, sizeof(hpd_report_descriptor));\n\t\tmemcpy(rep_desc, hpd_report_descriptor,\n\t\t       sizeof(hpd_report_descriptor));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void get_common_features(struct common_feature_property *common, int report_id)\n{\n\tcommon->report_id = report_id;\n\tcommon->connection_type = HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_ENUM;\n\tcommon->report_state = SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM;\n\tcommon->power_state = SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM;\n\tcommon->sensor_state = HID_USAGE_SENSOR_STATE_INITIALIZING_ENUM;\n\tcommon->report_interval =  HID_DEFAULT_REPORT_INTERVAL;\n}\n\nstatic u8 get_feature_rep(int sensor_idx, int report_id, u8 *feature_report)\n{\n\tstruct magno_feature_report magno_feature;\n\tstruct accel3_feature_report acc_feature;\n\tstruct gyro_feature_report gyro_feature;\n\tstruct hpd_feature_report hpd_feature;\n\tstruct als_feature_report als_feature;\n\tu8 report_size = 0;\n\n\tif (!feature_report)\n\t\treturn report_size;\n\n\tswitch (sensor_idx) {\n\tcase ACCEL_IDX:  \n\t\tget_common_features(&acc_feature.common_property, report_id);\n\t\tacc_feature.accel_change_sesnitivity = HID_DEFAULT_SENSITIVITY;\n\t\tacc_feature.accel_sensitivity_min = HID_DEFAULT_MIN_VALUE;\n\t\tacc_feature.accel_sensitivity_max = HID_DEFAULT_MAX_VALUE;\n\t\tmemcpy(feature_report, &acc_feature, sizeof(acc_feature));\n\t\treport_size = sizeof(acc_feature);\n\t\tbreak;\n\tcase GYRO_IDX:  \n\t\tget_common_features(&gyro_feature.common_property, report_id);\n\t\tgyro_feature.gyro_change_sesnitivity = HID_DEFAULT_SENSITIVITY;\n\t\tgyro_feature.gyro_sensitivity_min = HID_DEFAULT_MIN_VALUE;\n\t\tgyro_feature.gyro_sensitivity_max = HID_DEFAULT_MAX_VALUE;\n\t\tmemcpy(feature_report, &gyro_feature, sizeof(gyro_feature));\n\t\treport_size = sizeof(gyro_feature);\n\t\tbreak;\n\tcase MAG_IDX:  \n\t\tget_common_features(&magno_feature.common_property, report_id);\n\t\tmagno_feature.magno_headingchange_sensitivity = HID_DEFAULT_SENSITIVITY;\n\t\tmagno_feature.heading_min = HID_DEFAULT_MIN_VALUE;\n\t\tmagno_feature.heading_max = HID_DEFAULT_MAX_VALUE;\n\t\tmagno_feature.flux_change_sensitivity = HID_DEFAULT_MIN_VALUE;\n\t\tmagno_feature.flux_min = HID_DEFAULT_MIN_VALUE;\n\t\tmagno_feature.flux_max = HID_DEFAULT_MAX_VALUE;\n\t\tmemcpy(feature_report, &magno_feature, sizeof(magno_feature));\n\t\treport_size = sizeof(magno_feature);\n\t\tbreak;\n\tcase ALS_IDX:   \n\t\tget_common_features(&als_feature.common_property, report_id);\n\t\tals_feature.als_change_sesnitivity = HID_DEFAULT_SENSITIVITY;\n\t\tals_feature.als_sensitivity_min = HID_DEFAULT_MIN_VALUE;\n\t\tals_feature.als_sensitivity_max = HID_DEFAULT_MAX_VALUE;\n\t\tmemcpy(feature_report, &als_feature, sizeof(als_feature));\n\t\treport_size = sizeof(als_feature);\n\t\tbreak;\n\tcase HPD_IDX:   \n\t\tget_common_features(&hpd_feature.common_property, report_id);\n\t\tmemcpy(feature_report, &hpd_feature, sizeof(hpd_feature));\n\t\treport_size = sizeof(hpd_feature);\n\t\tbreak;\n\t}\n\treturn report_size;\n}\n\nstatic void get_common_inputs(struct common_input_property *common, int report_id)\n{\n\tcommon->report_id = report_id;\n\tcommon->sensor_state = HID_USAGE_SENSOR_STATE_READY_ENUM;\n\tcommon->event_type = HID_USAGE_SENSOR_EVENT_DATA_UPDATED_ENUM;\n}\n\nstatic int float_to_int(u32 flt32_val)\n{\n\tint fraction, shift, mantissa, sign, exp, zeropre;\n\n\tmantissa = flt32_val & GENMASK(22, 0);\n\tsign = (flt32_val & BIT(31)) ? -1 : 1;\n\texp = (flt32_val & ~BIT(31)) >> 23;\n\n\tif (!exp && !mantissa)\n\t\treturn 0;\n\n\t \n\texp -= 127;\n\tif (exp < 0) {\n\t\texp = -exp;\n\t\tif (exp >= BITS_PER_TYPE(u32))\n\t\t\treturn 0;\n\t\tzeropre = (((BIT(23) + mantissa) * 100) >> 23) >> exp;\n\t\treturn zeropre >= 50 ? sign : 0;\n\t}\n\n\tshift = 23 - exp;\n\tif (abs(shift) >= BITS_PER_TYPE(u32))\n\t\treturn 0;\n\n\tif (shift < 0) {\n\t\tshift = -shift;\n\t\tflt32_val = BIT(exp) + (mantissa << shift);\n\t\tshift = 0;\n\t} else {\n\t\tflt32_val = BIT(exp) + (mantissa >> shift);\n\t}\n\n\tfraction = (shift == 0) ? 0 : mantissa & GENMASK(shift - 1, 0);\n\n\treturn (((fraction * 100) >> shift) >= 50) ? sign * (flt32_val + 1) : sign * flt32_val;\n}\n\nstatic u8 get_input_rep(u8 current_index, int sensor_idx, int report_id,\n\t\t\tstruct amd_input_data *in_data)\n{\n\tstruct amd_mp2_dev *mp2 = container_of(in_data, struct amd_mp2_dev, in_data);\n\tu8 *input_report = in_data->input_report[current_index];\n\tstruct magno_input_report magno_input;\n\tstruct accel3_input_report acc_input;\n\tstruct gyro_input_report gyro_input;\n\tstruct als_input_report als_input;\n\tstruct hpd_input_report hpd_input;\n\tstruct sfh_accel_data accel_data;\n\tstruct sfh_gyro_data gyro_data;\n\tstruct sfh_mag_data mag_data;\n\tstruct sfh_als_data als_data;\n\tstruct hpd_status hpdstatus;\n\tvoid __iomem *sensoraddr;\n\tu8 report_size = 0;\n\n\tif (!input_report)\n\t\treturn report_size;\n\n\tswitch (sensor_idx) {\n\tcase ACCEL_IDX:  \n\t\tsensoraddr = mp2->vsbase + (ACCEL_IDX * SENSOR_DATA_MEM_SIZE_DEFAULT) +\n\t\t\t     OFFSET_SENSOR_DATA_DEFAULT;\n\t\tmemcpy_fromio(&accel_data, sensoraddr, sizeof(struct sfh_accel_data));\n\t\tget_common_inputs(&acc_input.common_property, report_id);\n\t\tacc_input.in_accel_x_value = float_to_int(accel_data.acceldata.x) / 100;\n\t\tacc_input.in_accel_y_value = float_to_int(accel_data.acceldata.y) / 100;\n\t\tacc_input.in_accel_z_value = float_to_int(accel_data.acceldata.z) / 100;\n\t\tmemcpy(input_report, &acc_input, sizeof(acc_input));\n\t\treport_size = sizeof(acc_input);\n\t\tbreak;\n\tcase GYRO_IDX:  \n\t\tsensoraddr = mp2->vsbase + (GYRO_IDX * SENSOR_DATA_MEM_SIZE_DEFAULT) +\n\t\t\t     OFFSET_SENSOR_DATA_DEFAULT;\n\t\tmemcpy_fromio(&gyro_data, sensoraddr, sizeof(struct sfh_gyro_data));\n\t\tget_common_inputs(&gyro_input.common_property, report_id);\n\t\tgyro_input.in_angel_x_value = float_to_int(gyro_data.gyrodata.x) / 1000;\n\t\tgyro_input.in_angel_y_value = float_to_int(gyro_data.gyrodata.y) / 1000;\n\t\tgyro_input.in_angel_z_value = float_to_int(gyro_data.gyrodata.z) / 1000;\n\t\tmemcpy(input_report, &gyro_input, sizeof(gyro_input));\n\t\treport_size = sizeof(gyro_input);\n\t\tbreak;\n\tcase MAG_IDX:  \n\t\tsensoraddr = mp2->vsbase + (MAG_IDX * SENSOR_DATA_MEM_SIZE_DEFAULT) +\n\t\t\t     OFFSET_SENSOR_DATA_DEFAULT;\n\t\tmemcpy_fromio(&mag_data, sensoraddr, sizeof(struct sfh_mag_data));\n\t\tget_common_inputs(&magno_input.common_property, report_id);\n\t\tmagno_input.in_magno_x = float_to_int(mag_data.magdata.x) / 100;\n\t\tmagno_input.in_magno_y = float_to_int(mag_data.magdata.y) / 100;\n\t\tmagno_input.in_magno_z = float_to_int(mag_data.magdata.z) / 100;\n\t\tmagno_input.in_magno_accuracy = mag_data.accuracy / 100;\n\t\tmemcpy(input_report, &magno_input, sizeof(magno_input));\n\t\treport_size = sizeof(magno_input);\n\t\tbreak;\n\tcase ALS_IDX:\n\t\tsensoraddr = mp2->vsbase + (ALS_IDX * SENSOR_DATA_MEM_SIZE_DEFAULT) +\n\t\t\t     OFFSET_SENSOR_DATA_DEFAULT;\n\t\tmemcpy_fromio(&als_data, sensoraddr, sizeof(struct sfh_als_data));\n\t\tget_common_inputs(&als_input.common_property, report_id);\n\t\tals_input.illuminance_value = float_to_int(als_data.lux);\n\t\treport_size = sizeof(als_input);\n\t\tmemcpy(input_report, &als_input, sizeof(als_input));\n\t\tbreak;\n\tcase HPD_IDX:\n\t\tget_common_inputs(&hpd_input.common_property, report_id);\n\t\thpdstatus.val = readl(mp2->mmio + AMD_C2P_MSG(4));\n\t\thpd_input.human_presence = hpdstatus.shpd.presence;\n\t\treport_size = sizeof(hpd_input);\n\t\tmemcpy(input_report, &hpd_input, sizeof(hpd_input));\n\t\tbreak;\n\t}\n\treturn report_size;\n}\n\nstatic u32 get_desc_size(int sensor_idx, int descriptor_name)\n{\n\tswitch (sensor_idx) {\n\tcase ACCEL_IDX:\n\t\tswitch (descriptor_name) {\n\t\tcase descr_size:\n\t\t\treturn sizeof(accel3_report_descriptor);\n\t\tcase input_size:\n\t\t\treturn sizeof(struct accel3_input_report);\n\t\tcase feature_size:\n\t\t\treturn sizeof(struct accel3_feature_report);\n\t\t}\n\t\tbreak;\n\tcase GYRO_IDX:\n\t\tswitch (descriptor_name) {\n\t\tcase descr_size:\n\t\t\treturn sizeof(gyro3_report_descriptor);\n\t\tcase input_size:\n\t\t\treturn sizeof(struct gyro_input_report);\n\t\tcase feature_size:\n\t\t\treturn sizeof(struct gyro_feature_report);\n\t\t}\n\t\tbreak;\n\tcase MAG_IDX:\n\t\tswitch (descriptor_name) {\n\t\tcase descr_size:\n\t\t\treturn sizeof(comp3_report_descriptor);\n\t\tcase input_size:\n\t\t\treturn sizeof(struct magno_input_report);\n\t\tcase feature_size:\n\t\t\treturn sizeof(struct magno_feature_report);\n\t\t}\n\t\tbreak;\n\tcase ALS_IDX:\n\t\tswitch (descriptor_name) {\n\t\tcase descr_size:\n\t\t\treturn sizeof(als_report_descriptor);\n\t\tcase input_size:\n\t\t\treturn sizeof(struct als_input_report);\n\t\tcase feature_size:\n\t\t\treturn sizeof(struct als_feature_report);\n\t\t}\n\t\tbreak;\n\tcase HPD_IDX:\n\t\tswitch (descriptor_name) {\n\t\tcase descr_size:\n\t\t\treturn sizeof(hpd_report_descriptor);\n\t\tcase input_size:\n\t\t\treturn sizeof(struct hpd_input_report);\n\t\tcase feature_size:\n\t\t\treturn sizeof(struct hpd_feature_report);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid amd_sfh1_1_set_desc_ops(struct amd_mp2_ops *mp2_ops)\n{\n\tmp2_ops->get_rep_desc = get_report_desc;\n\tmp2_ops->get_feat_rep = get_feature_rep;\n\tmp2_ops->get_desc_sz = get_desc_size;\n\tmp2_ops->get_in_rep = get_input_rep;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}