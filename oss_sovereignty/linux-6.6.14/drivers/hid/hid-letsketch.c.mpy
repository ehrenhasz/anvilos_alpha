{
  "module_name": "hid-letsketch.c",
  "hash_id": "892af7c617040669c0fa0a3cde3475e63bd3cd4e944ca8c27e525341cfe608f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-letsketch.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n\n#include <asm/unaligned.h>\n\n#include \"hid-ids.h\"\n\n#define LETSKETCH_RAW_IF\t\t0\n\n#define LETSKETCH_RAW_DATA_LEN\t\t12\n#define LETSKETCH_RAW_REPORT_ID\t\t8\n\n#define LETSKETCH_PAD_BUTTONS\t\t5\n\n#define LETSKETCH_INFO_STR_IDX_BEGIN\t0xc8\n#define LETSKETCH_INFO_STR_IDX_END\t0xca\n\n#define LETSKETCH_GET_STRING_RETRIES\t5\n\nstruct letsketch_data {\n\tstruct hid_device *hdev;\n\tstruct input_dev *input_tablet;\n\tstruct input_dev *input_tablet_pad;\n\tstruct timer_list inrange_timer;\n};\n\nstatic int letsketch_open(struct input_dev *dev)\n{\n\tstruct letsketch_data *data = input_get_drvdata(dev);\n\n\treturn hid_hw_open(data->hdev);\n}\n\nstatic void letsketch_close(struct input_dev *dev)\n{\n\tstruct letsketch_data *data = input_get_drvdata(dev);\n\n\thid_hw_close(data->hdev);\n}\n\nstatic struct input_dev *letsketch_alloc_input_dev(struct letsketch_data *data)\n{\n\tstruct input_dev *input;\n\n\tinput = devm_input_allocate_device(&data->hdev->dev);\n\tif (!input)\n\t\treturn NULL;\n\n\tinput->id.bustype = data->hdev->bus;\n\tinput->id.vendor  = data->hdev->vendor;\n\tinput->id.product = data->hdev->product;\n\tinput->id.version = data->hdev->bus;\n\tinput->phys = data->hdev->phys;\n\tinput->uniq = data->hdev->uniq;\n\tinput->open = letsketch_open;\n\tinput->close = letsketch_close;\n\n\tinput_set_drvdata(input, data);\n\n\treturn input;\n}\n\nstatic int letsketch_setup_input_tablet(struct letsketch_data *data)\n{\n\tstruct input_dev *input;\n\n\tinput = letsketch_alloc_input_dev(data);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput_set_abs_params(input, ABS_X, 0, 50800, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, 31750, 0, 0);\n\tinput_set_abs_params(input, ABS_PRESSURE, 0, 8192, 0, 0);\n\tinput_abs_set_res(input, ABS_X, 240);\n\tinput_abs_set_res(input, ABS_Y, 225);\n\tinput_set_capability(input, EV_KEY, BTN_TOUCH);\n\tinput_set_capability(input, EV_KEY, BTN_TOOL_PEN);\n\tinput_set_capability(input, EV_KEY, BTN_STYLUS);\n\tinput_set_capability(input, EV_KEY, BTN_STYLUS2);\n\n\t \n\tinput->name = \"WP9620 Tablet\";\n\n\tdata->input_tablet = input;\n\n\treturn input_register_device(data->input_tablet);\n}\n\nstatic int letsketch_setup_input_tablet_pad(struct letsketch_data *data)\n{\n\tstruct input_dev *input;\n\tint i;\n\n\tinput = letsketch_alloc_input_dev(data);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LETSKETCH_PAD_BUTTONS; i++)\n\t\tinput_set_capability(input, EV_KEY, BTN_0 + i);\n\n\t \n\tinput_set_abs_params(input, ABS_X, 0, 1, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, 0, 1, 0, 0);\n\tinput_set_capability(input, EV_KEY, BTN_STYLUS);\n\n\tinput->name = \"WP9620 Pad\";\n\n\tdata->input_tablet_pad = input;\n\n\treturn input_register_device(data->input_tablet_pad);\n}\n\nstatic void letsketch_inrange_timeout(struct timer_list *t)\n{\n\tstruct letsketch_data *data = from_timer(data, t, inrange_timer);\n\tstruct input_dev *input = data->input_tablet;\n\n\tinput_report_key(input, BTN_TOOL_PEN, 0);\n\tinput_sync(input);\n}\n\nstatic int letsketch_raw_event(struct hid_device *hdev,\n\t\t\t       struct hid_report *report,\n\t\t\t       u8 *raw_data, int size)\n{\n\tstruct letsketch_data *data = hid_get_drvdata(hdev);\n\tstruct input_dev *input;\n\tint i;\n\n\tif (size != LETSKETCH_RAW_DATA_LEN || raw_data[0] != LETSKETCH_RAW_REPORT_ID)\n\t\treturn 0;\n\n\tswitch (raw_data[1] & 0xf0) {\n\tcase 0x80:  \n\t\tinput = data->input_tablet;\n\t\tinput_report_key(input, BTN_TOOL_PEN, 1);\n\t\tinput_report_key(input, BTN_TOUCH, raw_data[1] & 0x01);\n\t\tinput_report_key(input, BTN_STYLUS, raw_data[1] & 0x02);\n\t\tinput_report_key(input, BTN_STYLUS2, raw_data[1] & 0x04);\n\t\tinput_report_abs(input, ABS_X,\n\t\t\t\t get_unaligned_le16(raw_data + 2));\n\t\tinput_report_abs(input, ABS_Y,\n\t\t\t\t get_unaligned_le16(raw_data + 4));\n\t\tinput_report_abs(input, ABS_PRESSURE,\n\t\t\t\t get_unaligned_le16(raw_data + 6));\n\t\t \n\t\tmod_timer(&data->inrange_timer, jiffies + msecs_to_jiffies(100));\n\t\tbreak;\n\tcase 0xe0:  \n\t\tinput = data->input_tablet_pad;\n\t\tfor (i = 0; i < LETSKETCH_PAD_BUTTONS; i++)\n\t\t\tinput_report_key(input, BTN_0 + i, raw_data[4] == (i + 1));\n\t\tbreak;\n\tdefault:\n\t\thid_warn(data->hdev, \"Warning unknown data header: 0x%02x\\n\",\n\t\t\t raw_data[0]);\n\t\treturn 0;\n\t}\n\n\tinput_sync(input);\n\treturn 0;\n}\n\n \nstatic int letsketch_get_string(struct usb_device *udev, int index, char *buf, int size)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < LETSKETCH_GET_STRING_RETRIES; i++) {\n\t\tusleep_range(5000, 7000);\n\t\tret = usb_string(udev, index, buf, size);\n\t\tif (ret > 0)\n\t\t\treturn 0;\n\t}\n\n\tdev_err(&udev->dev, \"Max retries (%d) exceeded reading string descriptor %d\\n\",\n\t\tLETSKETCH_GET_STRING_RETRIES, index);\n\treturn ret ? ret : -EIO;\n}\n\nstatic int letsketch_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct device *dev = &hdev->dev;\n\tstruct letsketch_data *data;\n\tstruct usb_interface *intf;\n\tstruct usb_device *udev;\n\tchar buf[256];\n\tint i, ret;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -ENODEV;\n\n\tintf = to_usb_interface(hdev->dev.parent);\n\tif (intf->altsetting->desc.bInterfaceNumber != LETSKETCH_RAW_IF)\n\t\treturn -ENODEV;  \n\n\tudev = interface_to_usbdev(intf);\n\n\t \n\tfor (i = LETSKETCH_INFO_STR_IDX_BEGIN; i <= LETSKETCH_INFO_STR_IDX_END; i++) {\n\t\tret = letsketch_get_string(udev, i, buf, sizeof(buf));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\thid_info(hdev, \"Device info: %s\\n\", buf);\n\t}\n\n\tfor (i = 1; i <= 250; i++) {\n\t\tret = letsketch_get_string(udev, i, buf, sizeof(buf));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = letsketch_get_string(udev, 0x64, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\tret = letsketch_get_string(udev, LETSKETCH_INFO_STR_IDX_BEGIN, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(5000, 7000);\n\n\tret = hid_parse(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->hdev = hdev;\n\ttimer_setup(&data->inrange_timer, letsketch_inrange_timeout, 0);\n\thid_set_drvdata(hdev, data);\n\n\tret = letsketch_setup_input_tablet(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = letsketch_setup_input_tablet_pad(data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n}\n\nstatic const struct hid_device_id letsketch_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LETSKETCH, USB_DEVICE_ID_WP9620N) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, letsketch_devices);\n\nstatic struct hid_driver letsketch_driver = {\n\t.name = \"letsketch\",\n\t.id_table = letsketch_devices,\n\t.probe = letsketch_probe,\n\t.raw_event = letsketch_raw_event,\n};\nmodule_hid_driver(letsketch_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}