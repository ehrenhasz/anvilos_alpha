{
  "module_name": "hid-sony.c",
  "hash_id": "c39e954007b2ee76e180da7c38e030313e3c682ddfbc4de87d62e12bcf6043c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-sony.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/leds.h>\n#include <linux/power_supply.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/idr.h>\n#include <linux/input/mt.h>\n#include <linux/crc32.h>\n#include <linux/usb.h>\n#include <linux/timer.h>\n#include <asm/unaligned.h>\n\n#include \"hid-ids.h\"\n\n#define VAIO_RDESC_CONSTANT       BIT(0)\n#define SIXAXIS_CONTROLLER_USB    BIT(1)\n#define SIXAXIS_CONTROLLER_BT     BIT(2)\n#define BUZZ_CONTROLLER           BIT(3)\n#define PS3REMOTE                 BIT(4)\n#define MOTION_CONTROLLER_USB     BIT(5)\n#define MOTION_CONTROLLER_BT      BIT(6)\n#define NAVIGATION_CONTROLLER_USB BIT(7)\n#define NAVIGATION_CONTROLLER_BT  BIT(8)\n#define SINO_LITE_CONTROLLER      BIT(9)\n#define FUTUREMAX_DANCE_MAT       BIT(10)\n#define NSG_MR5U_REMOTE_BT        BIT(11)\n#define NSG_MR7U_REMOTE_BT        BIT(12)\n#define SHANWAN_GAMEPAD           BIT(13)\n#define GH_GUITAR_CONTROLLER      BIT(14)\n#define GHL_GUITAR_PS3WIIU        BIT(15)\n#define GHL_GUITAR_PS4            BIT(16)\n\n#define SIXAXIS_CONTROLLER (SIXAXIS_CONTROLLER_USB | SIXAXIS_CONTROLLER_BT)\n#define MOTION_CONTROLLER (MOTION_CONTROLLER_USB | MOTION_CONTROLLER_BT)\n#define NAVIGATION_CONTROLLER (NAVIGATION_CONTROLLER_USB |\\\n\t\t\t\tNAVIGATION_CONTROLLER_BT)\n#define SONY_LED_SUPPORT (SIXAXIS_CONTROLLER | BUZZ_CONTROLLER |\\\n\t\t\t\tMOTION_CONTROLLER | NAVIGATION_CONTROLLER)\n#define SONY_BATTERY_SUPPORT (SIXAXIS_CONTROLLER | MOTION_CONTROLLER_BT | NAVIGATION_CONTROLLER)\n#define SONY_FF_SUPPORT (SIXAXIS_CONTROLLER | MOTION_CONTROLLER)\n#define SONY_BT_DEVICE (SIXAXIS_CONTROLLER_BT | MOTION_CONTROLLER_BT | NAVIGATION_CONTROLLER_BT)\n#define NSG_MRXU_REMOTE (NSG_MR5U_REMOTE_BT | NSG_MR7U_REMOTE_BT)\n\n#define MAX_LEDS 4\n#define NSG_MRXU_MAX_X 1667\n#define NSG_MRXU_MAX_Y 1868\n\n \n#define GHL_GUITAR_POKE_INTERVAL 8  \n#define GUITAR_TILT_USAGE 44\n\n \nstatic const char ghl_ps3wiiu_magic_data[] = {\n\t0x02, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n \nstatic const char ghl_ps4_magic_data[] = {\n\t0x30, 0x02, 0x08, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n \nstatic u8 motion_rdesc[] = {\n\t0x05, 0x01,          \n\t0x09, 0x04,          \n\t0xA1, 0x01,          \n\t0xA1, 0x02,          \n\t0x85, 0x01,          \n\t0x75, 0x01,          \n\t0x95, 0x15,          \n\t0x15, 0x00,          \n\t0x25, 0x01,          \n\t0x35, 0x00,          \n\t0x45, 0x01,          \n\t0x05, 0x09,          \n\t0x19, 0x01,          \n\t0x29, 0x15,          \n\t0x81, 0x02,          \n\t0x95, 0x0B,          \n\t0x06, 0x00, 0xFF,    \n\t0x81, 0x03,          \n\t0x15, 0x00,          \n\t0x26, 0xFF, 0x00,    \n\t0x05, 0x01,          \n\t0xA1, 0x00,          \n\t0x75, 0x08,          \n\t0x95, 0x01,          \n\t0x35, 0x00,          \n\t0x46, 0xFF, 0x00,    \n\t0x09, 0x30,          \n\t0x81, 0x02,          \n\t0xC0,                \n\t0x06, 0x00, 0xFF,    \n\t0x75, 0x08,          \n\t0x95, 0x07,          \n\t0x81, 0x02,          \n\t0x05, 0x01,          \n\t0x75, 0x10,          \n\t0x46, 0xFF, 0xFF,    \n\t0x27, 0xFF, 0xFF, 0x00, 0x00,  \n\t0x95, 0x03,          \n\t0x09, 0x33,          \n\t0x09, 0x34,          \n\t0x09, 0x35,          \n\t0x81, 0x02,          \n\t0x06, 0x00, 0xFF,    \n\t0x95, 0x03,          \n\t0x81, 0x02,          \n\t0x05, 0x01,          \n\t0x09, 0x01,          \n\t0x95, 0x03,          \n\t0x81, 0x02,          \n\t0x06, 0x00, 0xFF,    \n\t0x95, 0x03,          \n\t0x81, 0x02,          \n\t0x75, 0x0C,          \n\t0x46, 0xFF, 0x0F,    \n\t0x26, 0xFF, 0x0F,    \n\t0x95, 0x04,          \n\t0x81, 0x02,          \n\t0x75, 0x08,          \n\t0x46, 0xFF, 0x00,    \n\t0x26, 0xFF, 0x00,    \n\t0x95, 0x06,          \n\t0x81, 0x02,          \n\t0x75, 0x08,          \n\t0x95, 0x30,          \n\t0x09, 0x01,          \n\t0x91, 0x02,          \n\t0x75, 0x08,          \n\t0x95, 0x30,          \n\t0x09, 0x01,          \n\t0xB1, 0x02,          \n\t0xC0,                \n\t0xA1, 0x02,          \n\t0x85, 0x02,          \n\t0x75, 0x08,          \n\t0x95, 0x30,          \n\t0x09, 0x01,          \n\t0xB1, 0x02,          \n\t0xC0,                \n\t0xA1, 0x02,          \n\t0x85, 0xEE,          \n\t0x75, 0x08,          \n\t0x95, 0x30,          \n\t0x09, 0x01,          \n\t0xB1, 0x02,          \n\t0xC0,                \n\t0xA1, 0x02,          \n\t0x85, 0xEF,          \n\t0x75, 0x08,          \n\t0x95, 0x30,          \n\t0x09, 0x01,          \n\t0xB1, 0x02,          \n\t0xC0,                \n\t0xC0                 \n};\n\nstatic u8 ps3remote_rdesc[] = {\n\t0x05, 0x01,           \n\t0x09, 0x05,           \n\t0xA1, 0x01,           \n\n\t  \n\t 0xA1, 0x02,          \n\n\t   \n\t  0x75, 0x08,         \n\t  0x95, 0x01,         \n\t  0x81, 0x01,         \n\n\t   \n\t  0x05, 0x09,         \n\t  0x19, 0x01,         \n\t  0x29, 0x18,         \n\t  0x14,               \n\t  0x25, 0x01,         \n\t  0x75, 0x01,         \n\t  0x95, 0x18,         \n\t  0x81, 0x02,         \n\n\t  0xC0,               \n\n\t  \n\t 0xA1, 0x02,          \n\n\t   \n\t  0x05, 0x09,         \n\t  0x18,               \n\t  0x29, 0xFE,         \n\t  0x14,               \n\t  0x26, 0xFE, 0x00,   \n\t  0x75, 0x08,         \n\t  0x95, 0x01,         \n\t  0x80,               \n\n\t   \n\t  0x75, 0x08,         \n\t  0x95, 0x06,         \n\t  0x81, 0x01,         \n\n\t   \n\t  0x05, 0x06,         \n\t  0x09, 0x20,         \n\t  0x14,               \n\t  0x25, 0x05,         \n\t  0x75, 0x08,         \n\t  0x95, 0x01,         \n\t  0x81, 0x02,         \n\n\t  0xC0,               \n\n\t 0xC0                 \n};\n\nstatic const unsigned int ps3remote_keymap_joypad_buttons[] = {\n\t[0x01] = KEY_SELECT,\n\t[0x02] = BTN_THUMBL,\t\t \n\t[0x03] = BTN_THUMBR,\t\t \n\t[0x04] = BTN_START,\n\t[0x05] = KEY_UP,\n\t[0x06] = KEY_RIGHT,\n\t[0x07] = KEY_DOWN,\n\t[0x08] = KEY_LEFT,\n\t[0x09] = BTN_TL2,\t\t \n\t[0x0a] = BTN_TR2,\t\t \n\t[0x0b] = BTN_TL,\t\t \n\t[0x0c] = BTN_TR,\t\t \n\t[0x0d] = KEY_OPTION,\t\t \n\t[0x0e] = KEY_BACK,\t\t \n\t[0x0f] = BTN_0,\t\t\t \n\t[0x10] = KEY_SCREEN,\t\t \n\t[0x11] = KEY_HOMEPAGE,\t\t \n\t[0x14] = KEY_ENTER,\n};\nstatic const unsigned int ps3remote_keymap_remote_buttons[] = {\n\t[0x00] = KEY_1,\n\t[0x01] = KEY_2,\n\t[0x02] = KEY_3,\n\t[0x03] = KEY_4,\n\t[0x04] = KEY_5,\n\t[0x05] = KEY_6,\n\t[0x06] = KEY_7,\n\t[0x07] = KEY_8,\n\t[0x08] = KEY_9,\n\t[0x09] = KEY_0,\n\t[0x0e] = KEY_ESC,\t\t \n\t[0x0f] = KEY_CLEAR,\n\t[0x16] = KEY_EJECTCD,\n\t[0x1a] = KEY_MENU,\t\t \n\t[0x28] = KEY_TIME,\n\t[0x30] = KEY_PREVIOUS,\n\t[0x31] = KEY_NEXT,\n\t[0x32] = KEY_PLAY,\n\t[0x33] = KEY_REWIND,\t\t \n\t[0x34] = KEY_FORWARD,\t\t \n\t[0x38] = KEY_STOP,\n\t[0x39] = KEY_PAUSE,\n\t[0x40] = KEY_CONTEXT_MENU,\t \n\t[0x60] = KEY_FRAMEBACK,\t\t \n\t[0x61] = KEY_FRAMEFORWARD,\t \n\t[0x63] = KEY_SUBTITLE,\n\t[0x64] = KEY_AUDIO,\n\t[0x65] = KEY_ANGLE,\n\t[0x70] = KEY_INFO,\t\t \n\t[0x80] = KEY_BLUE,\n\t[0x81] = KEY_RED,\n\t[0x82] = KEY_GREEN,\n\t[0x83] = KEY_YELLOW,\n};\n\nstatic const unsigned int buzz_keymap[] = {\n\t \n\t [1] = BTN_TRIGGER_HAPPY1,\n\t [2] = BTN_TRIGGER_HAPPY2,\n\t [3] = BTN_TRIGGER_HAPPY3,\n\t [4] = BTN_TRIGGER_HAPPY4,\n\t [5] = BTN_TRIGGER_HAPPY5,\n\t [6] = BTN_TRIGGER_HAPPY6,\n\t [7] = BTN_TRIGGER_HAPPY7,\n\t [8] = BTN_TRIGGER_HAPPY8,\n\t [9] = BTN_TRIGGER_HAPPY9,\n\t[10] = BTN_TRIGGER_HAPPY10,\n\t[11] = BTN_TRIGGER_HAPPY11,\n\t[12] = BTN_TRIGGER_HAPPY12,\n\t[13] = BTN_TRIGGER_HAPPY13,\n\t[14] = BTN_TRIGGER_HAPPY14,\n\t[15] = BTN_TRIGGER_HAPPY15,\n\t[16] = BTN_TRIGGER_HAPPY16,\n\t[17] = BTN_TRIGGER_HAPPY17,\n\t[18] = BTN_TRIGGER_HAPPY18,\n\t[19] = BTN_TRIGGER_HAPPY19,\n\t[20] = BTN_TRIGGER_HAPPY20,\n};\n\n \nstatic const unsigned int navigation_absmap[] = {\n\t[0x30] = ABS_X,\n\t[0x31] = ABS_Y,\n\t[0x33] = ABS_Z,  \n};\n\n \nstatic const unsigned int navigation_keymap[] = {\n\t[0x01] = 0,  \n\t[0x02] = BTN_THUMBL,  \n\t[0x03] = 0,  \n\t[0x04] = 0,  \n\t[0x05] = BTN_DPAD_UP,  \n\t[0x06] = BTN_DPAD_RIGHT,  \n\t[0x07] = BTN_DPAD_DOWN,  \n\t[0x08] = BTN_DPAD_LEFT,  \n\t[0x09] = BTN_TL2,  \n\t[0x0a] = 0,  \n\t[0x0b] = BTN_TL,  \n\t[0x0c] = 0,  \n\t[0x0d] = BTN_NORTH,  \n\t[0x0e] = BTN_EAST,  \n\t[0x0f] = BTN_SOUTH,  \n\t[0x10] = BTN_WEST,  \n\t[0x11] = BTN_MODE,  \n};\n\nstatic const unsigned int sixaxis_absmap[] = {\n\t[0x30] = ABS_X,\n\t[0x31] = ABS_Y,\n\t[0x32] = ABS_RX,  \n\t[0x35] = ABS_RY,  \n};\n\nstatic const unsigned int sixaxis_keymap[] = {\n\t[0x01] = BTN_SELECT,  \n\t[0x02] = BTN_THUMBL,  \n\t[0x03] = BTN_THUMBR,  \n\t[0x04] = BTN_START,  \n\t[0x05] = BTN_DPAD_UP,  \n\t[0x06] = BTN_DPAD_RIGHT,  \n\t[0x07] = BTN_DPAD_DOWN,  \n\t[0x08] = BTN_DPAD_LEFT,  \n\t[0x09] = BTN_TL2,  \n\t[0x0a] = BTN_TR2,  \n\t[0x0b] = BTN_TL,  \n\t[0x0c] = BTN_TR,  \n\t[0x0d] = BTN_NORTH,  \n\t[0x0e] = BTN_EAST,  \n\t[0x0f] = BTN_SOUTH,  \n\t[0x10] = BTN_WEST,  \n\t[0x11] = BTN_MODE,  \n};\n\nstatic enum power_supply_property sony_battery_props[] = {\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_STATUS,\n};\n\nstruct sixaxis_led {\n\tu8 time_enabled;  \n\tu8 duty_length;   \n\tu8 enabled;\n\tu8 duty_off;  \n\tu8 duty_on;   \n} __packed;\n\nstruct sixaxis_rumble {\n\tu8 padding;\n\tu8 right_duration;  \n\tu8 right_motor_on;  \n\tu8 left_duration;     \n\tu8 left_motor_force;  \n} __packed;\n\nstruct sixaxis_output_report {\n\tu8 report_id;\n\tstruct sixaxis_rumble rumble;\n\tu8 padding[4];\n\tu8 leds_bitmap;  \n\tstruct sixaxis_led led[4];     \n\tstruct sixaxis_led _reserved;  \n} __packed;\n\nunion sixaxis_output_report_01 {\n\tstruct sixaxis_output_report data;\n\tu8 buf[36];\n};\n\nstruct motion_output_report_02 {\n\tu8 type, zero;\n\tu8 r, g, b;\n\tu8 zero2;\n\tu8 rumble;\n};\n\n#define SIXAXIS_REPORT_0xF2_SIZE 17\n#define SIXAXIS_REPORT_0xF5_SIZE 8\n#define MOTION_REPORT_0x02_SIZE 49\n\n#define SENSOR_SUFFIX \" Motion Sensors\"\n#define TOUCHPAD_SUFFIX \" Touchpad\"\n\n#define SIXAXIS_INPUT_REPORT_ACC_X_OFFSET 41\n#define SIXAXIS_ACC_RES_PER_G 113\n\nstatic DEFINE_SPINLOCK(sony_dev_list_lock);\nstatic LIST_HEAD(sony_device_list);\nstatic DEFINE_IDA(sony_device_id_allocator);\n\nenum sony_worker {\n\tSONY_WORKER_STATE\n};\n\nstruct sony_sc {\n\tspinlock_t lock;\n\tstruct list_head list_node;\n\tstruct hid_device *hdev;\n\tstruct input_dev *touchpad;\n\tstruct input_dev *sensor_dev;\n\tstruct led_classdev *leds[MAX_LEDS];\n\tunsigned long quirks;\n\tstruct work_struct state_worker;\n\tvoid (*send_output_report)(struct sony_sc *);\n\tstruct power_supply *battery;\n\tstruct power_supply_desc battery_desc;\n\tint device_id;\n\tu8 *output_report_dmabuf;\n\n#ifdef CONFIG_SONY_FF\n\tu8 left;\n\tu8 right;\n#endif\n\n\tu8 mac_address[6];\n\tu8 state_worker_initialized;\n\tu8 defer_initialization;\n\tu8 battery_capacity;\n\tint battery_status;\n\tu8 led_state[MAX_LEDS];\n\tu8 led_delay_on[MAX_LEDS];\n\tu8 led_delay_off[MAX_LEDS];\n\tu8 led_count;\n\n\t \n\tstruct urb *ghl_urb;\n\tstruct timer_list ghl_poke_timer;\n};\n\nstatic void sony_set_leds(struct sony_sc *sc);\n\nstatic inline void sony_schedule_work(struct sony_sc *sc,\n\t\t\t\t      enum sony_worker which)\n{\n\tunsigned long flags;\n\n\tswitch (which) {\n\tcase SONY_WORKER_STATE:\n\t\tspin_lock_irqsave(&sc->lock, flags);\n\t\tif (!sc->defer_initialization && sc->state_worker_initialized)\n\t\t\tschedule_work(&sc->state_worker);\n\t\tspin_unlock_irqrestore(&sc->lock, flags);\n\t\tbreak;\n\t}\n}\n\nstatic void ghl_magic_poke_cb(struct urb *urb)\n{\n\tstruct sony_sc *sc = urb->context;\n\n\tif (urb->status < 0)\n\t\thid_err(sc->hdev, \"URB transfer failed : %d\", urb->status);\n\n\tmod_timer(&sc->ghl_poke_timer, jiffies + GHL_GUITAR_POKE_INTERVAL*HZ);\n}\n\nstatic void ghl_magic_poke(struct timer_list *t)\n{\n\tint ret;\n\tstruct sony_sc *sc = from_timer(sc, t, ghl_poke_timer);\n\n\tret = usb_submit_urb(sc->ghl_urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\thid_err(sc->hdev, \"usb_submit_urb failed: %d\", ret);\n}\n\nstatic int ghl_init_urb(struct sony_sc *sc, struct usb_device *usbdev,\n\t\t\t\t\t   const char ghl_magic_data[], u16 poke_size)\n{\n\tstruct usb_ctrlrequest *cr;\n\tu8 *databuf;\n\tunsigned int pipe;\n\tu16 ghl_magic_value = (((HID_OUTPUT_REPORT + 1) << 8) | ghl_magic_data[0]);\n\n\tpipe = usb_sndctrlpipe(usbdev, 0);\n\n\tcr = devm_kzalloc(&sc->hdev->dev, sizeof(*cr), GFP_ATOMIC);\n\tif (cr == NULL)\n\t\treturn -ENOMEM;\n\n\tdatabuf = devm_kzalloc(&sc->hdev->dev, poke_size, GFP_ATOMIC);\n\tif (databuf == NULL)\n\t\treturn -ENOMEM;\n\n\tcr->bRequestType =\n\t\tUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT;\n\tcr->bRequest = USB_REQ_SET_CONFIGURATION;\n\tcr->wValue = cpu_to_le16(ghl_magic_value);\n\tcr->wIndex = 0;\n\tcr->wLength = cpu_to_le16(poke_size);\n\tmemcpy(databuf, ghl_magic_data, poke_size);\n\tusb_fill_control_urb(\n\t\tsc->ghl_urb, usbdev, pipe,\n\t\t(unsigned char *) cr, databuf, poke_size,\n\t\tghl_magic_poke_cb, sc);\n\treturn 0;\n}\n\nstatic int guitar_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t  struct hid_field *field, struct hid_usage *usage,\n\t\t\t  unsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_MSVENDOR) {\n\t\tunsigned int abs = usage->hid & HID_USAGE;\n\n\t\tif (abs == GUITAR_TILT_USAGE) {\n\t\t\thid_map_usage_clear(hi, usage, bit, max, EV_ABS, ABS_RY);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic u8 *motion_fixup(struct hid_device *hdev, u8 *rdesc,\n\t\t\t     unsigned int *rsize)\n{\n\t*rsize = sizeof(motion_rdesc);\n\treturn motion_rdesc;\n}\n\nstatic u8 *ps3remote_fixup(struct hid_device *hdev, u8 *rdesc,\n\t\t\t     unsigned int *rsize)\n{\n\t*rsize = sizeof(ps3remote_rdesc);\n\treturn ps3remote_rdesc;\n}\n\nstatic int ps3remote_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t     struct hid_field *field, struct hid_usage *usage,\n\t\t\t     unsigned long **bit, int *max)\n{\n\tunsigned int key = usage->hid & HID_USAGE;\n\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)\n\t\treturn -1;\n\n\tswitch (usage->collection_index) {\n\tcase 1:\n\t\tif (key >= ARRAY_SIZE(ps3remote_keymap_joypad_buttons))\n\t\t\treturn -1;\n\n\t\tkey = ps3remote_keymap_joypad_buttons[key];\n\t\tif (!key)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase 2:\n\t\tif (key >= ARRAY_SIZE(ps3remote_keymap_remote_buttons))\n\t\t\treturn -1;\n\n\t\tkey = ps3remote_keymap_remote_buttons[key];\n\t\tif (!key)\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\n\treturn 1;\n}\n\nstatic int navigation_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t  struct hid_field *field, struct hid_usage *usage,\n\t\t\t  unsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\n\t\tunsigned int key = usage->hid & HID_USAGE;\n\n\t\tif (key >= ARRAY_SIZE(sixaxis_keymap))\n\t\t\treturn -1;\n\n\t\tkey = navigation_keymap[key];\n\t\tif (!key)\n\t\t\treturn -1;\n\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\n\t\treturn 1;\n\t} else if (usage->hid == HID_GD_POINTER) {\n\t\t \n\t\tswitch (usage->usage_index) {\n\t\tcase 8:  \n\t\t\tusage->hid = HID_GD_Z;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_ABS, usage->hid & 0xf);\n\t\treturn 1;\n\t} else if ((usage->hid & HID_USAGE_PAGE) == HID_UP_GENDESK) {\n\t\tunsigned int abs = usage->hid & HID_USAGE;\n\n\t\tif (abs >= ARRAY_SIZE(navigation_absmap))\n\t\t\treturn -1;\n\n\t\tabs = navigation_absmap[abs];\n\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_ABS, abs);\n\t\treturn 1;\n\t}\n\n\treturn -1;\n}\n\n\nstatic int sixaxis_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t  struct hid_field *field, struct hid_usage *usage,\n\t\t\t  unsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\n\t\tunsigned int key = usage->hid & HID_USAGE;\n\n\t\tif (key >= ARRAY_SIZE(sixaxis_keymap))\n\t\t\treturn -1;\n\n\t\tkey = sixaxis_keymap[key];\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\n\t\treturn 1;\n\t} else if (usage->hid == HID_GD_POINTER) {\n\t\t \n\t\tswitch (usage->usage_index) {\n\t\tcase 8:  \n\t\t\tusage->hid = HID_GD_Z;\n\t\t\tbreak;\n\t\tcase 9:  \n\t\t\tusage->hid = HID_GD_RZ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_ABS, usage->hid & 0xf);\n\t\treturn 1;\n\t} else if ((usage->hid & HID_USAGE_PAGE) == HID_UP_GENDESK) {\n\t\tunsigned int abs = usage->hid & HID_USAGE;\n\n\t\tif (abs >= ARRAY_SIZE(sixaxis_absmap))\n\t\t\treturn -1;\n\n\t\tabs = sixaxis_absmap[abs];\n\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_ABS, abs);\n\t\treturn 1;\n\t}\n\n\treturn -1;\n}\n\nstatic u8 *sony_report_fixup(struct hid_device *hdev, u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct sony_sc *sc = hid_get_drvdata(hdev);\n\n\tif (sc->quirks & (SINO_LITE_CONTROLLER | FUTUREMAX_DANCE_MAT))\n\t\treturn rdesc;\n\n\t \n\tif ((sc->quirks & VAIO_RDESC_CONSTANT) && *rsize >= 56 &&\n\t     \n\t     \n\t     \n\t    rdesc[2] == 0x09 && rdesc[3] == 0x02 &&\n\t     \n\t    rdesc[54] == 0x81 && rdesc[55] == 0x07) {\n\t\thid_info(hdev, \"Fixing up Sony RF Receiver report descriptor\\n\");\n\t\t \n\t\trdesc[55] = 0x06;\n\t}\n\n\tif (sc->quirks & MOTION_CONTROLLER)\n\t\treturn motion_fixup(hdev, rdesc, rsize);\n\n\tif (sc->quirks & PS3REMOTE)\n\t\treturn ps3remote_fixup(hdev, rdesc, rsize);\n\n\t \n\tif ((sc->quirks & SIXAXIS_CONTROLLER_USB) && *rsize >= 45 &&\n\t\t \n\t\trdesc[23] == 0x95 && rdesc[24] == 0x0D &&\n\t\t \n\t\trdesc[37] == 0x29 && rdesc[38] == 0x0D &&\n\t\t \n\t\trdesc[43] == 0x95 && rdesc[44] == 0x03) {\n\t\thid_info(hdev, \"Fixing up USB dongle report descriptor\\n\");\n\t\trdesc[24] = 0x10;\n\t\trdesc[38] = 0x10;\n\t\trdesc[44] = 0x00;\n\t}\n\n\treturn rdesc;\n}\n\nstatic void sixaxis_parse_report(struct sony_sc *sc, u8 *rd, int size)\n{\n\tstatic const u8 sixaxis_battery_capacity[] = { 0, 1, 25, 50, 75, 100 };\n\tunsigned long flags;\n\tint offset;\n\tu8 battery_capacity;\n\tint battery_status;\n\n\t \n\toffset = (sc->quirks & MOTION_CONTROLLER) ? 12 : 30;\n\n\tif (rd[offset] >= 0xee) {\n\t\tbattery_capacity = 100;\n\t\tbattery_status = (rd[offset] & 0x01) ? POWER_SUPPLY_STATUS_FULL : POWER_SUPPLY_STATUS_CHARGING;\n\t} else {\n\t\tu8 index = rd[offset] <= 5 ? rd[offset] : 5;\n\t\tbattery_capacity = sixaxis_battery_capacity[index];\n\t\tbattery_status = POWER_SUPPLY_STATUS_DISCHARGING;\n\t}\n\n\tspin_lock_irqsave(&sc->lock, flags);\n\tsc->battery_capacity = battery_capacity;\n\tsc->battery_status = battery_status;\n\tspin_unlock_irqrestore(&sc->lock, flags);\n\n\tif (sc->quirks & SIXAXIS_CONTROLLER) {\n\t\tint val;\n\n\t\toffset = SIXAXIS_INPUT_REPORT_ACC_X_OFFSET;\n\t\tval = ((rd[offset+1] << 8) | rd[offset]) - 511;\n\t\tinput_report_abs(sc->sensor_dev, ABS_X, val);\n\n\t\t \n\t\tval = 511 - ((rd[offset+5] << 8) | rd[offset+4]);\n\t\tinput_report_abs(sc->sensor_dev, ABS_Y, val);\n\n\t\tval = 511 - ((rd[offset+3] << 8) | rd[offset+2]);\n\t\tinput_report_abs(sc->sensor_dev, ABS_Z, val);\n\n\t\tinput_sync(sc->sensor_dev);\n\t}\n}\n\nstatic void nsg_mrxu_parse_report(struct sony_sc *sc, u8 *rd, int size)\n{\n\tint n, offset, relx, rely;\n\tu8 active;\n\n\t \n\toffset = 1;\n\n\tinput_report_key(sc->touchpad, BTN_LEFT, rd[offset] & 0x0F);\n\tactive = (rd[offset] >> 4);\n\trelx = (s8) rd[offset+5];\n\trely = ((s8) rd[offset+10]) * -1;\n\n\toffset++;\n\n\tfor (n = 0; n < 2; n++) {\n\t\tu16 x, y;\n\t\tu8 contactx, contacty;\n\n\t\tx = rd[offset] | ((rd[offset+1] & 0x0F) << 8);\n\t\ty = ((rd[offset+1] & 0xF0) >> 4) | (rd[offset+2] << 4);\n\n\t\tinput_mt_slot(sc->touchpad, n);\n\t\tinput_mt_report_slot_state(sc->touchpad, MT_TOOL_FINGER, active & 0x03);\n\n\t\tif (active & 0x03) {\n\t\t\tcontactx = rd[offset+3] & 0x0F;\n\t\t\tcontacty = rd[offset+3] >> 4;\n\t\t\tinput_report_abs(sc->touchpad, ABS_MT_TOUCH_MAJOR,\n\t\t\t\tmax(contactx, contacty));\n\t\t\tinput_report_abs(sc->touchpad, ABS_MT_TOUCH_MINOR,\n\t\t\t\tmin(contactx, contacty));\n\t\t\tinput_report_abs(sc->touchpad, ABS_MT_ORIENTATION,\n\t\t\t\t(bool) (contactx > contacty));\n\t\t\tinput_report_abs(sc->touchpad, ABS_MT_POSITION_X, x);\n\t\t\tinput_report_abs(sc->touchpad, ABS_MT_POSITION_Y,\n\t\t\t\tNSG_MRXU_MAX_Y - y);\n\t\t\t \n\t\t\tif ((n == 0) || ((n == 1) && (active & 0x01))) {\n\t\t\t\tinput_report_rel(sc->touchpad, REL_X, relx);\n\t\t\t\tinput_report_rel(sc->touchpad, REL_Y, rely);\n\t\t\t}\n\t\t}\n\n\t\toffset += 5;\n\t\tactive >>= 2;\n\t}\n\n\tinput_mt_sync_frame(sc->touchpad);\n\n\tinput_sync(sc->touchpad);\n}\n\nstatic int sony_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\tu8 *rd, int size)\n{\n\tstruct sony_sc *sc = hid_get_drvdata(hdev);\n\n\t \n\tif ((sc->quirks & SIXAXIS_CONTROLLER) && rd[0] == 0x01 && size == 49) {\n\t\t \n\t\tif (rd[1] == 0xff)\n\t\t\treturn -EINVAL;\n\n\t\tswap(rd[41], rd[42]);\n\t\tswap(rd[43], rd[44]);\n\t\tswap(rd[45], rd[46]);\n\t\tswap(rd[47], rd[48]);\n\n\t\tsixaxis_parse_report(sc, rd, size);\n\t} else if ((sc->quirks & MOTION_CONTROLLER_BT) && rd[0] == 0x01 && size == 49) {\n\t\tsixaxis_parse_report(sc, rd, size);\n\t} else if ((sc->quirks & NAVIGATION_CONTROLLER) && rd[0] == 0x01 &&\n\t\t\tsize == 49) {\n\t\tsixaxis_parse_report(sc, rd, size);\n\t} else if ((sc->quirks & NSG_MRXU_REMOTE) && rd[0] == 0x02) {\n\t\tnsg_mrxu_parse_report(sc, rd, size);\n\t\treturn 1;\n\t}\n\n\tif (sc->defer_initialization) {\n\t\tsc->defer_initialization = 0;\n\t\tsony_schedule_work(sc, SONY_WORKER_STATE);\n\t}\n\n\treturn 0;\n}\n\nstatic int sony_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\t\tunsigned long **bit, int *max)\n{\n\tstruct sony_sc *sc = hid_get_drvdata(hdev);\n\n\tif (sc->quirks & BUZZ_CONTROLLER) {\n\t\tunsigned int key = usage->hid & HID_USAGE;\n\n\t\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)\n\t\t\treturn -1;\n\n\t\tswitch (usage->collection_index) {\n\t\tcase 1:\n\t\t\tif (key >= ARRAY_SIZE(buzz_keymap))\n\t\t\t\treturn -1;\n\n\t\t\tkey = buzz_keymap[key];\n\t\t\tif (!key)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\n\t\treturn 1;\n\t}\n\n\tif (sc->quirks & PS3REMOTE)\n\t\treturn ps3remote_mapping(hdev, hi, field, usage, bit, max);\n\n\tif (sc->quirks & NAVIGATION_CONTROLLER)\n\t\treturn navigation_mapping(hdev, hi, field, usage, bit, max);\n\n\tif (sc->quirks & SIXAXIS_CONTROLLER)\n\t\treturn sixaxis_mapping(hdev, hi, field, usage, bit, max);\n\n\tif (sc->quirks & GH_GUITAR_CONTROLLER)\n\t\treturn guitar_mapping(hdev, hi, field, usage, bit, max);\n\n\t \n\treturn 0;\n}\n\nstatic int sony_register_touchpad(struct sony_sc *sc, int touch_count,\n\t\tint w, int h, int touch_major, int touch_minor, int orientation)\n{\n\tsize_t name_sz;\n\tchar *name;\n\tint ret;\n\n\tsc->touchpad = devm_input_allocate_device(&sc->hdev->dev);\n\tif (!sc->touchpad)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(sc->touchpad, sc);\n\tsc->touchpad->dev.parent = &sc->hdev->dev;\n\tsc->touchpad->phys = sc->hdev->phys;\n\tsc->touchpad->uniq = sc->hdev->uniq;\n\tsc->touchpad->id.bustype = sc->hdev->bus;\n\tsc->touchpad->id.vendor = sc->hdev->vendor;\n\tsc->touchpad->id.product = sc->hdev->product;\n\tsc->touchpad->id.version = sc->hdev->version;\n\n\t \n\tname_sz = strlen(sc->hdev->name) + sizeof(TOUCHPAD_SUFFIX);\n\tname = devm_kzalloc(&sc->hdev->dev, name_sz, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tsnprintf(name, name_sz, \"%s\" TOUCHPAD_SUFFIX, sc->hdev->name);\n\tsc->touchpad->name = name;\n\n\t \n\t__set_bit(EV_KEY, sc->touchpad->evbit);\n\t__set_bit(BTN_LEFT, sc->touchpad->keybit);\n\t__set_bit(INPUT_PROP_BUTTONPAD, sc->touchpad->propbit);\n\n\tinput_set_abs_params(sc->touchpad, ABS_MT_POSITION_X, 0, w, 0, 0);\n\tinput_set_abs_params(sc->touchpad, ABS_MT_POSITION_Y, 0, h, 0, 0);\n\n\tif (touch_major > 0) {\n\t\tinput_set_abs_params(sc->touchpad, ABS_MT_TOUCH_MAJOR, \n\t\t\t0, touch_major, 0, 0);\n\t\tif (touch_minor > 0)\n\t\t\tinput_set_abs_params(sc->touchpad, ABS_MT_TOUCH_MINOR, \n\t\t\t\t0, touch_minor, 0, 0);\n\t\tif (orientation > 0)\n\t\t\tinput_set_abs_params(sc->touchpad, ABS_MT_ORIENTATION, \n\t\t\t\t0, orientation, 0, 0);\n\t}\n\n\tif (sc->quirks & NSG_MRXU_REMOTE) {\n\t\t__set_bit(EV_REL, sc->touchpad->evbit);\n\t}\n\n\tret = input_mt_init_slots(sc->touchpad, touch_count, INPUT_MT_POINTER);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = input_register_device(sc->touchpad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int sony_register_sensors(struct sony_sc *sc)\n{\n\tsize_t name_sz;\n\tchar *name;\n\tint ret;\n\n\tsc->sensor_dev = devm_input_allocate_device(&sc->hdev->dev);\n\tif (!sc->sensor_dev)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(sc->sensor_dev, sc);\n\tsc->sensor_dev->dev.parent = &sc->hdev->dev;\n\tsc->sensor_dev->phys = sc->hdev->phys;\n\tsc->sensor_dev->uniq = sc->hdev->uniq;\n\tsc->sensor_dev->id.bustype = sc->hdev->bus;\n\tsc->sensor_dev->id.vendor = sc->hdev->vendor;\n\tsc->sensor_dev->id.product = sc->hdev->product;\n\tsc->sensor_dev->id.version = sc->hdev->version;\n\n\t \n\tname_sz = strlen(sc->hdev->name) + sizeof(SENSOR_SUFFIX);\n\tname = devm_kzalloc(&sc->hdev->dev, name_sz, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tsnprintf(name, name_sz, \"%s\" SENSOR_SUFFIX, sc->hdev->name);\n\tsc->sensor_dev->name = name;\n\n\tif (sc->quirks & SIXAXIS_CONTROLLER) {\n\t\t \n\t\tinput_set_abs_params(sc->sensor_dev, ABS_X, -512, 511, 4, 0);\n\t\tinput_set_abs_params(sc->sensor_dev, ABS_Y, -512, 511, 4, 0);\n\t\tinput_set_abs_params(sc->sensor_dev, ABS_Z, -512, 511, 4, 0);\n\t\tinput_abs_set_res(sc->sensor_dev, ABS_X, SIXAXIS_ACC_RES_PER_G);\n\t\tinput_abs_set_res(sc->sensor_dev, ABS_Y, SIXAXIS_ACC_RES_PER_G);\n\t\tinput_abs_set_res(sc->sensor_dev, ABS_Z, SIXAXIS_ACC_RES_PER_G);\n\t}\n\n\t__set_bit(INPUT_PROP_ACCELEROMETER, sc->sensor_dev->propbit);\n\n\tret = input_register_device(sc->sensor_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int sixaxis_set_operational_usb(struct hid_device *hdev)\n{\n\tstruct sony_sc *sc = hid_get_drvdata(hdev);\n\tconst int buf_size =\n\t\tmax(SIXAXIS_REPORT_0xF2_SIZE, SIXAXIS_REPORT_0xF5_SIZE);\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, 0xf2, buf, SIXAXIS_REPORT_0xF2_SIZE,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"can't set operational mode: step 1\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = hid_hw_raw_request(hdev, 0xf5, buf, SIXAXIS_REPORT_0xF5_SIZE,\n\t\t\t\t HID_FEATURE_REPORT, HID_REQ_GET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"can't set operational mode: step 2\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (sc->quirks & SHANWAN_GAMEPAD)\n\t\tgoto out;\n\n\tret = hid_hw_output_report(hdev, buf, 1);\n\tif (ret < 0) {\n\t\thid_info(hdev, \"can't set operational mode: step 3, ignoring\\n\");\n\t\tret = 0;\n\t}\n\nout:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int sixaxis_set_operational_bt(struct hid_device *hdev)\n{\n\tstatic const u8 report[] = { 0xf4, 0x42, 0x03, 0x00, 0x00 };\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(report, sizeof(report), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(report),\n\t\t\t\t  HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic void sixaxis_set_leds_from_id(struct sony_sc *sc)\n{\n\tstatic const u8 sixaxis_leds[10][4] = {\n\t\t\t\t{ 0x01, 0x00, 0x00, 0x00 },\n\t\t\t\t{ 0x00, 0x01, 0x00, 0x00 },\n\t\t\t\t{ 0x00, 0x00, 0x01, 0x00 },\n\t\t\t\t{ 0x00, 0x00, 0x00, 0x01 },\n\t\t\t\t{ 0x01, 0x00, 0x00, 0x01 },\n\t\t\t\t{ 0x00, 0x01, 0x00, 0x01 },\n\t\t\t\t{ 0x00, 0x00, 0x01, 0x01 },\n\t\t\t\t{ 0x01, 0x00, 0x01, 0x01 },\n\t\t\t\t{ 0x00, 0x01, 0x01, 0x01 },\n\t\t\t\t{ 0x01, 0x01, 0x01, 0x01 }\n\t};\n\n\tint id = sc->device_id;\n\n\tBUILD_BUG_ON(MAX_LEDS < ARRAY_SIZE(sixaxis_leds[0]));\n\n\tif (id < 0)\n\t\treturn;\n\n\tid %= 10;\n\tmemcpy(sc->led_state, sixaxis_leds[id], sizeof(sixaxis_leds[id]));\n}\n\nstatic void buzz_set_leds(struct sony_sc *sc)\n{\n\tstruct hid_device *hdev = sc->hdev;\n\tstruct list_head *report_list =\n\t\t&hdev->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct hid_report *report = list_entry(report_list->next,\n\t\tstruct hid_report, list);\n\ts32 *value = report->field[0]->value;\n\n\tBUILD_BUG_ON(MAX_LEDS < 4);\n\n\tvalue[0] = 0x00;\n\tvalue[1] = sc->led_state[0] ? 0xff : 0x00;\n\tvalue[2] = sc->led_state[1] ? 0xff : 0x00;\n\tvalue[3] = sc->led_state[2] ? 0xff : 0x00;\n\tvalue[4] = sc->led_state[3] ? 0xff : 0x00;\n\tvalue[5] = 0x00;\n\tvalue[6] = 0x00;\n\thid_hw_request(hdev, report, HID_REQ_SET_REPORT);\n}\n\nstatic void sony_set_leds(struct sony_sc *sc)\n{\n\tif (!(sc->quirks & BUZZ_CONTROLLER))\n\t\tsony_schedule_work(sc, SONY_WORKER_STATE);\n\telse\n\t\tbuzz_set_leds(sc);\n}\n\nstatic void sony_led_set_brightness(struct led_classdev *led,\n\t\t\t\t    enum led_brightness value)\n{\n\tstruct device *dev = led->dev->parent;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct sony_sc *drv_data;\n\n\tint n;\n\tint force_update;\n\n\tdrv_data = hid_get_drvdata(hdev);\n\tif (!drv_data) {\n\t\thid_err(hdev, \"No device data\\n\");\n\t\treturn;\n\t}\n\n\t \n\tforce_update = !!(drv_data->quirks & SIXAXIS_CONTROLLER_USB);\n\n\tfor (n = 0; n < drv_data->led_count; n++) {\n\t\tif (led == drv_data->leds[n] && (force_update ||\n\t\t\t(value != drv_data->led_state[n] ||\n\t\t\tdrv_data->led_delay_on[n] ||\n\t\t\tdrv_data->led_delay_off[n]))) {\n\n\t\t\tdrv_data->led_state[n] = value;\n\n\t\t\t \n\t\t\tdrv_data->led_delay_on[n] = 0;\n\t\t\tdrv_data->led_delay_off[n] = 0;\n\n\t\t\tsony_set_leds(drv_data);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic enum led_brightness sony_led_get_brightness(struct led_classdev *led)\n{\n\tstruct device *dev = led->dev->parent;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct sony_sc *drv_data;\n\n\tint n;\n\n\tdrv_data = hid_get_drvdata(hdev);\n\tif (!drv_data) {\n\t\thid_err(hdev, \"No device data\\n\");\n\t\treturn LED_OFF;\n\t}\n\n\tfor (n = 0; n < drv_data->led_count; n++) {\n\t\tif (led == drv_data->leds[n])\n\t\t\treturn drv_data->led_state[n];\n\t}\n\n\treturn LED_OFF;\n}\n\nstatic int sony_led_blink_set(struct led_classdev *led, unsigned long *delay_on,\n\t\t\t\tunsigned long *delay_off)\n{\n\tstruct device *dev = led->dev->parent;\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct sony_sc *drv_data = hid_get_drvdata(hdev);\n\tint n;\n\tu8 new_on, new_off;\n\n\tif (!drv_data) {\n\t\thid_err(hdev, \"No device data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (*delay_on > 2550)\n\t\t*delay_on = 2550;\n\tif (*delay_off > 2550)\n\t\t*delay_off = 2550;\n\n\t \n\tif (!*delay_on && !*delay_off)\n\t\t*delay_on = *delay_off = 500;\n\n\tnew_on = *delay_on / 10;\n\tnew_off = *delay_off / 10;\n\n\tfor (n = 0; n < drv_data->led_count; n++) {\n\t\tif (led == drv_data->leds[n])\n\t\t\tbreak;\n\t}\n\n\t \n\tif (n >= drv_data->led_count)\n\t\treturn -EINVAL;\n\n\t \n\tif (new_on != drv_data->led_delay_on[n] ||\n\t\tnew_off != drv_data->led_delay_off[n]) {\n\t\tdrv_data->led_delay_on[n] = new_on;\n\t\tdrv_data->led_delay_off[n] = new_off;\n\t\tsony_schedule_work(drv_data, SONY_WORKER_STATE);\n\t}\n\n\treturn 0;\n}\n\nstatic int sony_leds_init(struct sony_sc *sc)\n{\n\tstruct hid_device *hdev = sc->hdev;\n\tint n, ret = 0;\n\tint use_color_names;\n\tstruct led_classdev *led;\n\tsize_t name_sz;\n\tchar *name;\n\tsize_t name_len;\n\tconst char *name_fmt;\n\tstatic const char * const color_name_str[] = { \"red\", \"green\", \"blue\",\n\t\t\t\t\t\t  \"global\" };\n\tu8 max_brightness[MAX_LEDS] = { [0 ... (MAX_LEDS - 1)] = 1 };\n\tu8 use_hw_blink[MAX_LEDS] = { 0 };\n\n\tBUG_ON(!(sc->quirks & SONY_LED_SUPPORT));\n\n\tif (sc->quirks & BUZZ_CONTROLLER) {\n\t\tsc->led_count = 4;\n\t\tuse_color_names = 0;\n\t\tname_len = strlen(\"::buzz#\");\n\t\tname_fmt = \"%s::buzz%d\";\n\t\t \n\t\tif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\t\treturn -ENODEV;\n\t} else if (sc->quirks & MOTION_CONTROLLER) {\n\t\tsc->led_count = 3;\n\t\tmemset(max_brightness, 255, 3);\n\t\tuse_color_names = 1;\n\t\tname_len = 0;\n\t\tname_fmt = \"%s:%s\";\n\t} else if (sc->quirks & NAVIGATION_CONTROLLER) {\n\t\tstatic const u8 navigation_leds[4] = {0x01, 0x00, 0x00, 0x00};\n\n\t\tmemcpy(sc->led_state, navigation_leds, sizeof(navigation_leds));\n\t\tsc->led_count = 1;\n\t\tmemset(use_hw_blink, 1, 4);\n\t\tuse_color_names = 0;\n\t\tname_len = strlen(\"::sony#\");\n\t\tname_fmt = \"%s::sony%d\";\n\t} else {\n\t\tsixaxis_set_leds_from_id(sc);\n\t\tsc->led_count = 4;\n\t\tmemset(use_hw_blink, 1, 4);\n\t\tuse_color_names = 0;\n\t\tname_len = strlen(\"::sony#\");\n\t\tname_fmt = \"%s::sony%d\";\n\t}\n\n\t \n\tsony_set_leds(sc);\n\n\tname_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;\n\n\tfor (n = 0; n < sc->led_count; n++) {\n\n\t\tif (use_color_names)\n\t\t\tname_sz = strlen(dev_name(&hdev->dev)) + strlen(color_name_str[n]) + 2;\n\n\t\tled = devm_kzalloc(&hdev->dev, sizeof(struct led_classdev) + name_sz, GFP_KERNEL);\n\t\tif (!led) {\n\t\t\thid_err(hdev, \"Couldn't allocate memory for LED %d\\n\", n);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tname = (void *)(&led[1]);\n\t\tif (use_color_names)\n\t\t\tsnprintf(name, name_sz, name_fmt, dev_name(&hdev->dev),\n\t\t\tcolor_name_str[n]);\n\t\telse\n\t\t\tsnprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);\n\t\tled->name = name;\n\t\tled->brightness = sc->led_state[n];\n\t\tled->max_brightness = max_brightness[n];\n\t\tled->flags = LED_CORE_SUSPENDRESUME;\n\t\tled->brightness_get = sony_led_get_brightness;\n\t\tled->brightness_set = sony_led_set_brightness;\n\n\t\tif (use_hw_blink[n])\n\t\t\tled->blink_set = sony_led_blink_set;\n\n\t\tsc->leds[n] = led;\n\n\t\tret = devm_led_classdev_register(&hdev->dev, led);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"Failed to register LED %d\\n\", n);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sixaxis_send_output_report(struct sony_sc *sc)\n{\n\tstatic const union sixaxis_output_report_01 default_report = {\n\t\t.buf = {\n\t\t\t0x01,\n\t\t\t0x01, 0xff, 0x00, 0xff, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0xff, 0x27, 0x10, 0x00, 0x32,\n\t\t\t0xff, 0x27, 0x10, 0x00, 0x32,\n\t\t\t0xff, 0x27, 0x10, 0x00, 0x32,\n\t\t\t0xff, 0x27, 0x10, 0x00, 0x32,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00\n\t\t}\n\t};\n\tstruct sixaxis_output_report *report =\n\t\t(struct sixaxis_output_report *)sc->output_report_dmabuf;\n\tint n;\n\n\t \n\tmemcpy(report, &default_report, sizeof(struct sixaxis_output_report));\n\n#ifdef CONFIG_SONY_FF\n\treport->rumble.right_motor_on = sc->right ? 1 : 0;\n\treport->rumble.left_motor_force = sc->left;\n#endif\n\n\treport->leds_bitmap |= sc->led_state[0] << 1;\n\treport->leds_bitmap |= sc->led_state[1] << 2;\n\treport->leds_bitmap |= sc->led_state[2] << 3;\n\treport->leds_bitmap |= sc->led_state[3] << 4;\n\n\t \n\tif ((report->leds_bitmap & 0x1E) == 0)\n\t\treport->leds_bitmap |= 0x20;\n\n\t \n\tfor (n = 0; n < 4; n++) {\n\t\tif (sc->led_delay_on[n] || sc->led_delay_off[n]) {\n\t\t\treport->led[3 - n].duty_off = sc->led_delay_off[n];\n\t\t\treport->led[3 - n].duty_on = sc->led_delay_on[n];\n\t\t}\n\t}\n\n\t \n\tif (sc->quirks & SHANWAN_GAMEPAD)\n\t\thid_hw_output_report(sc->hdev, (u8 *)report,\n\t\t\t\tsizeof(struct sixaxis_output_report));\n\telse\n\t\thid_hw_raw_request(sc->hdev, report->report_id, (u8 *)report,\n\t\t\t\tsizeof(struct sixaxis_output_report),\n\t\t\t\tHID_OUTPUT_REPORT, HID_REQ_SET_REPORT);\n}\n\nstatic void motion_send_output_report(struct sony_sc *sc)\n{\n\tstruct hid_device *hdev = sc->hdev;\n\tstruct motion_output_report_02 *report =\n\t\t(struct motion_output_report_02 *)sc->output_report_dmabuf;\n\n\tmemset(report, 0, MOTION_REPORT_0x02_SIZE);\n\n\treport->type = 0x02;  \n\treport->r = sc->led_state[0];\n\treport->g = sc->led_state[1];\n\treport->b = sc->led_state[2];\n\n#ifdef CONFIG_SONY_FF\n\treport->rumble = max(sc->right, sc->left);\n#endif\n\n\thid_hw_output_report(hdev, (u8 *)report, MOTION_REPORT_0x02_SIZE);\n}\n\n#ifdef CONFIG_SONY_FF\nstatic inline void sony_send_output_report(struct sony_sc *sc)\n{\n\tif (sc->send_output_report)\n\t\tsc->send_output_report(sc);\n}\n#endif\n\nstatic void sony_state_worker(struct work_struct *work)\n{\n\tstruct sony_sc *sc = container_of(work, struct sony_sc, state_worker);\n\n\tsc->send_output_report(sc);\n}\n\nstatic int sony_allocate_output_report(struct sony_sc *sc)\n{\n\tif ((sc->quirks & SIXAXIS_CONTROLLER) ||\n\t\t\t(sc->quirks & NAVIGATION_CONTROLLER))\n\t\tsc->output_report_dmabuf =\n\t\t\tdevm_kmalloc(&sc->hdev->dev,\n\t\t\t\tsizeof(union sixaxis_output_report_01),\n\t\t\t\tGFP_KERNEL);\n\telse if (sc->quirks & MOTION_CONTROLLER)\n\t\tsc->output_report_dmabuf = devm_kmalloc(&sc->hdev->dev,\n\t\t\t\t\t\tMOTION_REPORT_0x02_SIZE,\n\t\t\t\t\t\tGFP_KERNEL);\n\telse\n\t\treturn 0;\n\n\tif (!sc->output_report_dmabuf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SONY_FF\nstatic int sony_play_effect(struct input_dev *dev, void *data,\n\t\t\t    struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct sony_sc *sc = hid_get_drvdata(hid);\n\n\tif (effect->type != FF_RUMBLE)\n\t\treturn 0;\n\n\tsc->left = effect->u.rumble.strong_magnitude / 256;\n\tsc->right = effect->u.rumble.weak_magnitude / 256;\n\n\tsony_schedule_work(sc, SONY_WORKER_STATE);\n\treturn 0;\n}\n\nstatic int sony_init_ff(struct sony_sc *sc)\n{\n\tstruct hid_input *hidinput;\n\tstruct input_dev *input_dev;\n\n\tif (list_empty(&sc->hdev->inputs)) {\n\t\thid_err(sc->hdev, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_entry(sc->hdev->inputs.next, struct hid_input, list);\n\tinput_dev = hidinput->input;\n\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, sony_play_effect);\n}\n\n#else\nstatic int sony_init_ff(struct sony_sc *sc)\n{\n\treturn 0;\n}\n\n#endif\n\nstatic int sony_battery_get_property(struct power_supply *psy,\n\t\t\t\t     enum power_supply_property psp,\n\t\t\t\t     union power_supply_propval *val)\n{\n\tstruct sony_sc *sc = power_supply_get_drvdata(psy);\n\tunsigned long flags;\n\tint ret = 0;\n\tu8 battery_capacity;\n\tint battery_status;\n\n\tspin_lock_irqsave(&sc->lock, flags);\n\tbattery_capacity = sc->battery_capacity;\n\tbattery_status = sc->battery_status;\n\tspin_unlock_irqrestore(&sc->lock, flags);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = 1;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = battery_capacity;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = battery_status;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int sony_battery_probe(struct sony_sc *sc, int append_dev_id)\n{\n\tconst char *battery_str_fmt = append_dev_id ?\n\t\t\"sony_controller_battery_%pMR_%i\" :\n\t\t\"sony_controller_battery_%pMR\";\n\tstruct power_supply_config psy_cfg = { .drv_data = sc, };\n\tstruct hid_device *hdev = sc->hdev;\n\tint ret;\n\n\t \n\tsc->battery_capacity = 100;\n\n\tsc->battery_desc.properties = sony_battery_props;\n\tsc->battery_desc.num_properties = ARRAY_SIZE(sony_battery_props);\n\tsc->battery_desc.get_property = sony_battery_get_property;\n\tsc->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\tsc->battery_desc.use_for_apm = 0;\n\tsc->battery_desc.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,\n\t\t\t\t\t  battery_str_fmt, sc->mac_address, sc->device_id);\n\tif (!sc->battery_desc.name)\n\t\treturn -ENOMEM;\n\n\tsc->battery = devm_power_supply_register(&hdev->dev, &sc->battery_desc,\n\t\t\t\t\t    &psy_cfg);\n\tif (IS_ERR(sc->battery)) {\n\t\tret = PTR_ERR(sc->battery);\n\t\thid_err(hdev, \"Unable to register battery device\\n\");\n\t\treturn ret;\n\t}\n\n\tpower_supply_powers(sc->battery, &hdev->dev);\n\treturn 0;\n}\n\n \nstatic inline int sony_compare_connection_type(struct sony_sc *sc0,\n\t\t\t\t\t\tstruct sony_sc *sc1)\n{\n\tconst int sc0_not_bt = !(sc0->quirks & SONY_BT_DEVICE);\n\tconst int sc1_not_bt = !(sc1->quirks & SONY_BT_DEVICE);\n\n\treturn sc0_not_bt == sc1_not_bt;\n}\n\nstatic int sony_check_add_dev_list(struct sony_sc *sc)\n{\n\tstruct sony_sc *entry;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&sony_dev_list_lock, flags);\n\n\tlist_for_each_entry(entry, &sony_device_list, list_node) {\n\t\tret = memcmp(sc->mac_address, entry->mac_address,\n\t\t\t\tsizeof(sc->mac_address));\n\t\tif (!ret) {\n\t\t\tif (sony_compare_connection_type(sc, entry)) {\n\t\t\t\tret = 1;\n\t\t\t} else {\n\t\t\t\tret = -EEXIST;\n\t\t\t\thid_info(sc->hdev,\n\t\t\t\t\"controller with MAC address %pMR already connected\\n\",\n\t\t\t\tsc->mac_address);\n\t\t\t}\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = 0;\n\tlist_add(&(sc->list_node), &sony_device_list);\n\nunlock:\n\tspin_unlock_irqrestore(&sony_dev_list_lock, flags);\n\treturn ret;\n}\n\nstatic void sony_remove_dev_list(struct sony_sc *sc)\n{\n\tunsigned long flags;\n\n\tif (sc->list_node.next) {\n\t\tspin_lock_irqsave(&sony_dev_list_lock, flags);\n\t\tlist_del(&(sc->list_node));\n\t\tspin_unlock_irqrestore(&sony_dev_list_lock, flags);\n\t}\n}\n\nstatic int sony_get_bt_devaddr(struct sony_sc *sc)\n{\n\tint ret;\n\n\t \n\tret = strlen(sc->hdev->uniq);\n\tif (ret != 17)\n\t\treturn -EINVAL;\n\n\tret = sscanf(sc->hdev->uniq,\n\t\t\"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\",\n\t\t&sc->mac_address[5], &sc->mac_address[4], &sc->mac_address[3],\n\t\t&sc->mac_address[2], &sc->mac_address[1], &sc->mac_address[0]);\n\n\tif (ret != 6)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sony_check_add(struct sony_sc *sc)\n{\n\tu8 *buf = NULL;\n\tint n, ret;\n\n\tif ((sc->quirks & MOTION_CONTROLLER_BT) ||\n\t    (sc->quirks & NAVIGATION_CONTROLLER_BT) ||\n\t    (sc->quirks & SIXAXIS_CONTROLLER_BT)) {\n\t\t \n\t\tif (sony_get_bt_devaddr(sc) < 0) {\n\t\t\thid_warn(sc->hdev, \"UNIQ does not contain a MAC address; duplicate check skipped\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else if ((sc->quirks & SIXAXIS_CONTROLLER_USB) ||\n\t\t\t(sc->quirks & NAVIGATION_CONTROLLER_USB)) {\n\t\tbuf = kmalloc(SIXAXIS_REPORT_0xF2_SIZE, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tret = hid_hw_raw_request(sc->hdev, 0xf2, buf,\n\t\t\t\tSIXAXIS_REPORT_0xF2_SIZE, HID_FEATURE_REPORT,\n\t\t\t\tHID_REQ_GET_REPORT);\n\n\t\tif (ret != SIXAXIS_REPORT_0xF2_SIZE) {\n\t\t\thid_err(sc->hdev, \"failed to retrieve feature report 0xf2 with the Sixaxis MAC address\\n\");\n\t\t\tret = ret < 0 ? ret : -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tfor (n = 0; n < 6; n++)\n\t\t\tsc->mac_address[5-n] = buf[4+n];\n\n\t\tsnprintf(sc->hdev->uniq, sizeof(sc->hdev->uniq),\n\t\t\t \"%pMR\", sc->mac_address);\n\t} else {\n\t\treturn 0;\n\t}\n\n\tret = sony_check_add_dev_list(sc);\n\nout_free:\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int sony_set_device_id(struct sony_sc *sc)\n{\n\tint ret;\n\n\t \n\tif (sc->quirks & SIXAXIS_CONTROLLER) {\n\t\tret = ida_simple_get(&sony_device_id_allocator, 0, 0,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tsc->device_id = -1;\n\t\t\treturn ret;\n\t\t}\n\t\tsc->device_id = ret;\n\t} else {\n\t\tsc->device_id = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void sony_release_device_id(struct sony_sc *sc)\n{\n\tif (sc->device_id >= 0) {\n\t\tida_simple_remove(&sony_device_id_allocator, sc->device_id);\n\t\tsc->device_id = -1;\n\t}\n}\n\nstatic inline void sony_init_output_report(struct sony_sc *sc,\n\t\t\t\tvoid (*send_output_report)(struct sony_sc *))\n{\n\tsc->send_output_report = send_output_report;\n\n\tif (!sc->state_worker_initialized)\n\t\tINIT_WORK(&sc->state_worker, sony_state_worker);\n\n\tsc->state_worker_initialized = 1;\n}\n\nstatic inline void sony_cancel_work_sync(struct sony_sc *sc)\n{\n\tunsigned long flags;\n\n\tif (sc->state_worker_initialized) {\n\t\tspin_lock_irqsave(&sc->lock, flags);\n\t\tsc->state_worker_initialized = 0;\n\t\tspin_unlock_irqrestore(&sc->lock, flags);\n\t\tcancel_work_sync(&sc->state_worker);\n\t}\n}\n\nstatic int sony_input_configured(struct hid_device *hdev,\n\t\t\t\t\tstruct hid_input *hidinput)\n{\n\tstruct sony_sc *sc = hid_get_drvdata(hdev);\n\tint append_dev_id;\n\tint ret;\n\n\tret = sony_set_device_id(sc);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"failed to allocate the device id\\n\");\n\t\tgoto err_stop;\n\t}\n\n\tret = append_dev_id = sony_check_add(sc);\n\tif (ret < 0)\n\t\tgoto err_stop;\n\n\tret = sony_allocate_output_report(sc);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"failed to allocate the output report buffer\\n\");\n\t\tgoto err_stop;\n\t}\n\n\tif (sc->quirks & NAVIGATION_CONTROLLER_USB) {\n\t\t \n\t\thdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\n\t\thdev->quirks |= HID_QUIRK_SKIP_OUTPUT_REPORT_ID;\n\t\tsc->defer_initialization = 1;\n\n\t\tret = sixaxis_set_operational_usb(hdev);\n\t\tif (ret < 0) {\n\t\t\thid_err(hdev, \"Failed to set controller into operational mode\\n\");\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tsony_init_output_report(sc, sixaxis_send_output_report);\n\t} else if (sc->quirks & NAVIGATION_CONTROLLER_BT) {\n\t\t \n\t\thdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\n\n\t\tret = sixaxis_set_operational_bt(hdev);\n\t\tif (ret < 0) {\n\t\t\thid_err(hdev, \"Failed to set controller into operational mode\\n\");\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tsony_init_output_report(sc, sixaxis_send_output_report);\n\t} else if (sc->quirks & SIXAXIS_CONTROLLER_USB) {\n\t\t \n\t\thdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\n\t\thdev->quirks |= HID_QUIRK_SKIP_OUTPUT_REPORT_ID;\n\t\tsc->defer_initialization = 1;\n\n\t\tret = sixaxis_set_operational_usb(hdev);\n\t\tif (ret < 0) {\n\t\t\thid_err(hdev, \"Failed to set controller into operational mode\\n\");\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tret = sony_register_sensors(sc);\n\t\tif (ret) {\n\t\t\thid_err(sc->hdev,\n\t\t\t\"Unable to initialize motion sensors: %d\\n\", ret);\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tsony_init_output_report(sc, sixaxis_send_output_report);\n\t} else if (sc->quirks & SIXAXIS_CONTROLLER_BT) {\n\t\t \n\t\thdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\n\n\t\tret = sixaxis_set_operational_bt(hdev);\n\t\tif (ret < 0) {\n\t\t\thid_err(hdev, \"Failed to set controller into operational mode\\n\");\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tret = sony_register_sensors(sc);\n\t\tif (ret) {\n\t\t\thid_err(sc->hdev,\n\t\t\t\"Unable to initialize motion sensors: %d\\n\", ret);\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tsony_init_output_report(sc, sixaxis_send_output_report);\n\t} else if (sc->quirks & NSG_MRXU_REMOTE) {\n\t\t \n\t\tret = sony_register_touchpad(sc, 2,\n\t\t\tNSG_MRXU_MAX_X, NSG_MRXU_MAX_Y, 15, 15, 1);\n\t\tif (ret) {\n\t\t\thid_err(sc->hdev,\n\t\t\t\"Unable to initialize multi-touch slots: %d\\n\",\n\t\t\tret);\n\t\t\tgoto err_stop;\n\t\t}\n\n\t} else if (sc->quirks & MOTION_CONTROLLER) {\n\t\tsony_init_output_report(sc, motion_send_output_report);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (sc->quirks & SONY_LED_SUPPORT) {\n\t\tret = sony_leds_init(sc);\n\t\tif (ret < 0)\n\t\t\tgoto err_stop;\n\t}\n\n\tif (sc->quirks & SONY_BATTERY_SUPPORT) {\n\t\tret = sony_battery_probe(sc, append_dev_id);\n\t\tif (ret < 0)\n\t\t\tgoto err_stop;\n\n\t\t \n\t\tret = hid_hw_open(hdev);\n\t\tif (ret < 0) {\n\t\t\thid_err(hdev, \"hw open failed\\n\");\n\t\t\tgoto err_stop;\n\t\t}\n\t}\n\n\tif (sc->quirks & SONY_FF_SUPPORT) {\n\t\tret = sony_init_ff(sc);\n\t\tif (ret < 0)\n\t\t\tgoto err_close;\n\t}\n\n\treturn 0;\nerr_close:\n\thid_hw_close(hdev);\nerr_stop:\n\tsony_cancel_work_sync(sc);\n\tsony_remove_dev_list(sc);\n\tsony_release_device_id(sc);\n\treturn ret;\n}\n\nstatic int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tunsigned long quirks = id->driver_data;\n\tstruct sony_sc *sc;\n\tstruct usb_device *usbdev;\n\tunsigned int connect_mask = HID_CONNECT_DEFAULT;\n\n\tif (!strcmp(hdev->name, \"FutureMax Dance Mat\"))\n\t\tquirks |= FUTUREMAX_DANCE_MAT;\n\n\tif (!strcmp(hdev->name, \"SHANWAN PS3 GamePad\") ||\n\t    !strcmp(hdev->name, \"ShanWan PS(R) Ga`epad\"))\n\t\tquirks |= SHANWAN_GAMEPAD;\n\n\tsc = devm_kzalloc(&hdev->dev, sizeof(*sc), GFP_KERNEL);\n\tif (sc == NULL) {\n\t\thid_err(hdev, \"can't alloc sony descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&sc->lock);\n\n\tsc->quirks = quirks;\n\thid_set_drvdata(hdev, sc);\n\tsc->hdev = hdev;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (sc->quirks & VAIO_RDESC_CONSTANT)\n\t\tconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\n\telse if (sc->quirks & SIXAXIS_CONTROLLER)\n\t\tconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\n\n\t \n\tif (sc->quirks & SIXAXIS_CONTROLLER)\n\t\thdev->version |= 0x8000;\n\n\tret = hid_hw_start(hdev, connect_mask);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!(hdev->claimed & HID_CLAIMED_INPUT)) {\n\t\thid_err(hdev, \"failed to claim input\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif (sc->quirks & (GHL_GUITAR_PS3WIIU | GHL_GUITAR_PS4)) {\n\t\tif (!hid_is_usb(hdev)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tusbdev = to_usb_device(sc->hdev->dev.parent->parent);\n\n\t\tsc->ghl_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!sc->ghl_urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (sc->quirks & GHL_GUITAR_PS3WIIU)\n\t\t\tret = ghl_init_urb(sc, usbdev, ghl_ps3wiiu_magic_data,\n\t\t\t\t\t\t\t   ARRAY_SIZE(ghl_ps3wiiu_magic_data));\n\t\telse if (sc->quirks & GHL_GUITAR_PS4)\n\t\t\tret = ghl_init_urb(sc, usbdev, ghl_ps4_magic_data,\n\t\t\t\t\t\t\t   ARRAY_SIZE(ghl_ps4_magic_data));\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"error preparing URB\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\ttimer_setup(&sc->ghl_poke_timer, ghl_magic_poke, 0);\n\t\tmod_timer(&sc->ghl_poke_timer,\n\t\t\t  jiffies + GHL_GUITAR_POKE_INTERVAL*HZ);\n\t}\n\n\treturn ret;\n\nerr:\n\tusb_free_urb(sc->ghl_urb);\n\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void sony_remove(struct hid_device *hdev)\n{\n\tstruct sony_sc *sc = hid_get_drvdata(hdev);\n\n\tif (sc->quirks & (GHL_GUITAR_PS3WIIU | GHL_GUITAR_PS4)) {\n\t\tdel_timer_sync(&sc->ghl_poke_timer);\n\t\tusb_free_urb(sc->ghl_urb);\n\t}\n\n\thid_hw_close(hdev);\n\n\tsony_cancel_work_sync(sc);\n\n\tsony_remove_dev_list(sc);\n\n\tsony_release_device_id(sc);\n\n\thid_hw_stop(hdev);\n}\n\n#ifdef CONFIG_PM\n\nstatic int sony_suspend(struct hid_device *hdev, pm_message_t message)\n{\n#ifdef CONFIG_SONY_FF\n\n\t \n\tif (SONY_FF_SUPPORT) {\n\t\tstruct sony_sc *sc = hid_get_drvdata(hdev);\n\n\t\tsc->left = sc->right = 0;\n\t\tsony_send_output_report(sc);\n\t}\n\n#endif\n\treturn 0;\n}\n\nstatic int sony_resume(struct hid_device *hdev)\n{\n\tstruct sony_sc *sc = hid_get_drvdata(hdev);\n\n\t \n\tif ((sc->quirks & SIXAXIS_CONTROLLER_USB) ||\n\t\t(sc->quirks & NAVIGATION_CONTROLLER_USB)) {\n\t\tsixaxis_set_operational_usb(sc->hdev);\n\t\tsc->defer_initialization = 1;\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nstatic const struct hid_device_id sony_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER),\n\t\t.driver_data = SIXAXIS_CONTROLLER_USB },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER),\n\t\t.driver_data = NAVIGATION_CONTROLLER_USB },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER),\n\t\t.driver_data = NAVIGATION_CONTROLLER_BT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_MOTION_CONTROLLER),\n\t\t.driver_data = MOTION_CONTROLLER_USB },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_MOTION_CONTROLLER),\n\t\t.driver_data = MOTION_CONTROLLER_BT },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER),\n\t\t.driver_data = SIXAXIS_CONTROLLER_BT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE),\n\t\t.driver_data = VAIO_RDESC_CONSTANT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE),\n\t\t.driver_data = VAIO_RDESC_CONSTANT },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_BUZZ_CONTROLLER),\n\t\t.driver_data = BUZZ_CONTROLLER },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER),\n\t\t.driver_data = BUZZ_CONTROLLER },\n\t \n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_BDREMOTE),\n\t\t.driver_data = PS3REMOTE },\n\t \n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_HARMONY_PS3),\n\t\t.driver_data = PS3REMOTE },\n\t \n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SMK, USB_DEVICE_ID_SMK_PS3_BDREMOTE),\n\t\t.driver_data = PS3REMOTE },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SINO_LITE, USB_DEVICE_ID_SINO_LITE_CONTROLLER),\n\t\t.driver_data = SIXAXIS_CONTROLLER_USB | SINO_LITE_CONTROLLER },\n\t \n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SMK, USB_DEVICE_ID_SMK_NSG_MR5U_REMOTE),\n\t\t.driver_data = NSG_MR5U_REMOTE_BT },\n\t \n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SMK, USB_DEVICE_ID_SMK_NSG_MR7U_REMOTE),\n\t\t.driver_data = NSG_MR7U_REMOTE_BT },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY_RHYTHM, USB_DEVICE_ID_SONY_PS3WIIU_GHLIVE_DONGLE),\n\t\t.driver_data = GHL_GUITAR_PS3WIIU | GH_GUITAR_CONTROLLER },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_REDOCTANE, USB_DEVICE_ID_REDOCTANE_GUITAR_DONGLE),\n\t\t.driver_data = GH_GUITAR_CONTROLLER },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SONY_RHYTHM, USB_DEVICE_ID_SONY_PS3_GUITAR_DONGLE),\n\t\t.driver_data = GH_GUITAR_CONTROLLER },\n\t \n\t{ HID_USB_DEVICE(USB_VENDOR_ID_REDOCTANE, USB_DEVICE_ID_REDOCTANE_PS4_GHLIVE_DONGLE),\n\t\t.driver_data = GHL_GUITAR_PS4 | GH_GUITAR_CONTROLLER },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, sony_devices);\n\nstatic struct hid_driver sony_driver = {\n\t.name             = \"sony\",\n\t.id_table         = sony_devices,\n\t.input_mapping    = sony_mapping,\n\t.input_configured = sony_input_configured,\n\t.probe            = sony_probe,\n\t.remove           = sony_remove,\n\t.report_fixup     = sony_report_fixup,\n\t.raw_event        = sony_raw_event,\n\n#ifdef CONFIG_PM\n\t.suspend          = sony_suspend,\n\t.resume\t          = sony_resume,\n\t.reset_resume     = sony_resume,\n#endif\n};\n\nstatic int __init sony_init(void)\n{\n\tdbg_hid(\"Sony:%s\\n\", __func__);\n\n\treturn hid_register_driver(&sony_driver);\n}\n\nstatic void __exit sony_exit(void)\n{\n\tdbg_hid(\"Sony:%s\\n\", __func__);\n\n\thid_unregister_driver(&sony_driver);\n\tida_destroy(&sony_device_id_allocator);\n}\nmodule_init(sony_init);\nmodule_exit(sony_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}