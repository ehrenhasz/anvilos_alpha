{
  "module_name": "hid-ntrig.c",
  "hash_id": "902a5a93d7fe8ff80ccda105a443dd5f4735e4714c691cbf777e80cdccfb9c64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-ntrig.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/usb.h>\n#include \"usbhid/usbhid.h\"\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"hid-ids.h\"\n\n#define NTRIG_DUPLICATE_USAGES\t0x001\n\nstatic unsigned int min_width;\nmodule_param(min_width, uint, 0644);\nMODULE_PARM_DESC(min_width, \"Minimum touch contact width to accept.\");\n\nstatic unsigned int min_height;\nmodule_param(min_height, uint, 0644);\nMODULE_PARM_DESC(min_height, \"Minimum touch contact height to accept.\");\n\nstatic unsigned int activate_slack = 1;\nmodule_param(activate_slack, uint, 0644);\nMODULE_PARM_DESC(activate_slack, \"Number of touch frames to ignore at \"\n\t\t \"the start of touch input.\");\n\nstatic unsigned int deactivate_slack = 4;\nmodule_param(deactivate_slack, uint, 0644);\nMODULE_PARM_DESC(deactivate_slack, \"Number of empty frames to ignore before \"\n\t\t \"deactivating touch.\");\n\nstatic unsigned int activation_width = 64;\nmodule_param(activation_width, uint, 0644);\nMODULE_PARM_DESC(activation_width, \"Width threshold to immediately start \"\n\t\t \"processing touch events.\");\n\nstatic unsigned int activation_height = 32;\nmodule_param(activation_height, uint, 0644);\nMODULE_PARM_DESC(activation_height, \"Height threshold to immediately start \"\n\t\t \"processing touch events.\");\n\nstruct ntrig_data {\n\t \n\t__u16 x, y, w, h;\n\t__u16 id;\n\n\tbool tipswitch;\n\tbool confidence;\n\tbool first_contact_touch;\n\n\tbool reading_mt;\n\n\t__u8 mt_footer[4];\n\t__u8 mt_foot_count;\n\n\t \n\t__s8 act_state;\n\n\t \n\t__s8 deactivate_slack;\n\n\t \n\t__s8 activate_slack;\n\n\t \n\t__u16 min_width;\n\t__u16 min_height;\n\n\t \n\t__u16 activation_width;\n\t__u16 activation_height;\n\n\t__u16 sensor_logical_width;\n\t__u16 sensor_logical_height;\n\t__u16 sensor_physical_width;\n\t__u16 sensor_physical_height;\n};\n\n\n \nstatic int ntrig_version_string(unsigned char *raw, char *buf)\n{\n\t__u8 a =  (raw[1] & 0x0e) >> 1;\n\t__u8 b =  (raw[0] & 0x3c) >> 2;\n\t__u8 c = ((raw[0] & 0x03) << 3) | ((raw[3] & 0xe0) >> 5);\n\t__u8 d = ((raw[3] & 0x07) << 3) | ((raw[2] & 0xe0) >> 5);\n\t__u8 e =   raw[2] & 0x07;\n\n\t \n\n\treturn sprintf(buf, \"%u.%u.%u.%u.%u\", a, b, c, d, e);\n}\n\nstatic inline int ntrig_get_mode(struct hid_device *hdev)\n{\n\tstruct hid_report *report = hdev->report_enum[HID_FEATURE_REPORT].\n\t\t\t\t    report_id_hash[0x0d];\n\n\tif (!report || report->maxfield < 1 ||\n\t    report->field[0]->report_count < 1)\n\t\treturn -EINVAL;\n\n\thid_hw_request(hdev, report, HID_REQ_GET_REPORT);\n\thid_hw_wait(hdev);\n\treturn (int)report->field[0]->value[0];\n}\n\nstatic inline void ntrig_set_mode(struct hid_device *hdev, const int mode)\n{\n\tstruct hid_report *report;\n\t__u8 mode_commands[4] = { 0xe, 0xf, 0x1b, 0x10 };\n\n\tif (mode < 0 || mode > 3)\n\t\treturn;\n\n\treport = hdev->report_enum[HID_FEATURE_REPORT].\n\t\t report_id_hash[mode_commands[mode]];\n\n\tif (!report)\n\t\treturn;\n\n\thid_hw_request(hdev, report, HID_REQ_GET_REPORT);\n}\n\nstatic void ntrig_report_version(struct hid_device *hdev)\n{\n\tint ret;\n\tchar buf[20];\n\tstruct usb_device *usb_dev = hid_to_usb_dev(hdev);\n\tunsigned char *data = kmalloc(8, GFP_KERNEL);\n\n\tif (!data)\n\t\tgoto err_free;\n\n\tret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t      USB_REQ_CLEAR_FEATURE,\n\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE |\n\t\t\t      USB_DIR_IN,\n\t\t\t      0x30c, 1, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\n\tif (ret == 8) {\n\t\tret = ntrig_version_string(&data[2], buf);\n\n\t\thid_info(hdev, \"Firmware version: %s (%02x%02x %02x%02x)\\n\",\n\t\t\t buf, data[2], data[3], data[4], data[5]);\n\t}\n\nerr_free:\n\tkfree(data);\n}\n\nstatic ssize_t show_phys_width(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->sensor_physical_width);\n}\n\nstatic DEVICE_ATTR(sensor_physical_width, S_IRUGO, show_phys_width, NULL);\n\nstatic ssize_t show_phys_height(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->sensor_physical_height);\n}\n\nstatic DEVICE_ATTR(sensor_physical_height, S_IRUGO, show_phys_height, NULL);\n\nstatic ssize_t show_log_width(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->sensor_logical_width);\n}\n\nstatic DEVICE_ATTR(sensor_logical_width, S_IRUGO, show_log_width, NULL);\n\nstatic ssize_t show_log_height(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->sensor_logical_height);\n}\n\nstatic DEVICE_ATTR(sensor_logical_height, S_IRUGO, show_log_height, NULL);\n\nstatic ssize_t show_min_width(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->min_width *\n\t\t\t\t    nd->sensor_physical_width /\n\t\t\t\t    nd->sensor_logical_width);\n}\n\nstatic ssize_t set_min_width(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > nd->sensor_physical_width)\n\t\treturn -EINVAL;\n\n\tnd->min_width = val * nd->sensor_logical_width /\n\t\t\t      nd->sensor_physical_width;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(min_width, S_IWUSR | S_IRUGO, show_min_width, set_min_width);\n\nstatic ssize_t show_min_height(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->min_height *\n\t\t\t\t    nd->sensor_physical_height /\n\t\t\t\t    nd->sensor_logical_height);\n}\n\nstatic ssize_t set_min_height(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > nd->sensor_physical_height)\n\t\treturn -EINVAL;\n\n\tnd->min_height = val * nd->sensor_logical_height /\n\t\t\t       nd->sensor_physical_height;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(min_height, S_IWUSR | S_IRUGO, show_min_height,\n\t\t   set_min_height);\n\nstatic ssize_t show_activate_slack(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->activate_slack);\n}\n\nstatic ssize_t set_activate_slack(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 0x7f)\n\t\treturn -EINVAL;\n\n\tnd->activate_slack = val;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(activate_slack, S_IWUSR | S_IRUGO, show_activate_slack,\n\t\t   set_activate_slack);\n\nstatic ssize_t show_activation_width(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->activation_width *\n\t\t\t\t    nd->sensor_physical_width /\n\t\t\t\t    nd->sensor_logical_width);\n}\n\nstatic ssize_t set_activation_width(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > nd->sensor_physical_width)\n\t\treturn -EINVAL;\n\n\tnd->activation_width = val * nd->sensor_logical_width /\n\t\t\t\t     nd->sensor_physical_width;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(activation_width, S_IWUSR | S_IRUGO, show_activation_width,\n\t\t   set_activation_width);\n\nstatic ssize_t show_activation_height(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", nd->activation_height *\n\t\t\t\t    nd->sensor_physical_height /\n\t\t\t\t    nd->sensor_logical_height);\n}\n\nstatic ssize_t set_activation_height(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > nd->sensor_physical_height)\n\t\treturn -EINVAL;\n\n\tnd->activation_height = val * nd->sensor_logical_height /\n\t\t\t\t      nd->sensor_physical_height;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(activation_height, S_IWUSR | S_IRUGO,\n\t\t   show_activation_height, set_activation_height);\n\nstatic ssize_t show_deactivate_slack(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\treturn sprintf(buf, \"%d\\n\", -nd->deactivate_slack);\n}\n\nstatic ssize_t set_deactivate_slack(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(dev);\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\t \n\tif (val > 7)\n\t\treturn -EINVAL;\n\n\tnd->deactivate_slack = -val;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(deactivate_slack, S_IWUSR | S_IRUGO, show_deactivate_slack,\n\t\t   set_deactivate_slack);\n\nstatic struct attribute *sysfs_attrs[] = {\n\t&dev_attr_sensor_physical_width.attr,\n\t&dev_attr_sensor_physical_height.attr,\n\t&dev_attr_sensor_logical_width.attr,\n\t&dev_attr_sensor_logical_height.attr,\n\t&dev_attr_min_height.attr,\n\t&dev_attr_min_width.attr,\n\t&dev_attr_activate_slack.attr,\n\t&dev_attr_activation_width.attr,\n\t&dev_attr_activation_height.attr,\n\t&dev_attr_deactivate_slack.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ntrig_attribute_group = {\n\t.attrs = sysfs_attrs\n};\n\n \n\nstatic int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t       struct hid_field *field, struct hid_usage *usage,\n\t\t\t       unsigned long **bit, int *max)\n{\n\tstruct ntrig_data *nd = hid_get_drvdata(hdev);\n\n\t \n\tif (field->physical)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\tcase HID_UP_GENDESK:\n\t\tswitch (usage->hid) {\n\t\tcase HID_GD_X:\n\t\t\thid_map_usage(hi, usage, bit, max,\n\t\t\t\t\tEV_ABS, ABS_MT_POSITION_X);\n\t\t\tinput_set_abs_params(hi->input, ABS_X,\n\t\t\t\t\tfield->logical_minimum,\n\t\t\t\t\tfield->logical_maximum, 0, 0);\n\n\t\t\tif (!nd->sensor_logical_width) {\n\t\t\t\tnd->sensor_logical_width =\n\t\t\t\t\tfield->logical_maximum -\n\t\t\t\t\tfield->logical_minimum;\n\t\t\t\tnd->sensor_physical_width =\n\t\t\t\t\tfield->physical_maximum -\n\t\t\t\t\tfield->physical_minimum;\n\t\t\t\tnd->activation_width = activation_width *\n\t\t\t\t\tnd->sensor_logical_width /\n\t\t\t\t\tnd->sensor_physical_width;\n\t\t\t\tnd->min_width = min_width *\n\t\t\t\t\tnd->sensor_logical_width /\n\t\t\t\t\tnd->sensor_physical_width;\n\t\t\t}\n\t\t\treturn 1;\n\t\tcase HID_GD_Y:\n\t\t\thid_map_usage(hi, usage, bit, max,\n\t\t\t\t\tEV_ABS, ABS_MT_POSITION_Y);\n\t\t\tinput_set_abs_params(hi->input, ABS_Y,\n\t\t\t\t\tfield->logical_minimum,\n\t\t\t\t\tfield->logical_maximum, 0, 0);\n\n\t\t\tif (!nd->sensor_logical_height) {\n\t\t\t\tnd->sensor_logical_height =\n\t\t\t\t\tfield->logical_maximum -\n\t\t\t\t\tfield->logical_minimum;\n\t\t\t\tnd->sensor_physical_height =\n\t\t\t\t\tfield->physical_maximum -\n\t\t\t\t\tfield->physical_minimum;\n\t\t\t\tnd->activation_height = activation_height *\n\t\t\t\t\tnd->sensor_logical_height /\n\t\t\t\t\tnd->sensor_physical_height;\n\t\t\t\tnd->min_height = min_height *\n\t\t\t\t\tnd->sensor_logical_height /\n\t\t\t\t\tnd->sensor_physical_height;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\n\tcase HID_UP_DIGITIZER:\n\t\tswitch (usage->hid) {\n\t\t \n\t\tcase HID_DG_CONTACTID:  \n\t\tcase HID_DG_INPUTMODE:\n\t\tcase HID_DG_DEVICEINDEX:\n\t\tcase HID_DG_CONTACTMAX:\n\t\t\treturn -1;\n\n\t\t \n\t\tcase HID_DG_WIDTH:\n\t\t\thid_map_usage(hi, usage, bit, max,\n\t\t\t\t      EV_ABS, ABS_MT_TOUCH_MAJOR);\n\t\t\treturn 1;\n\t\tcase HID_DG_HEIGHT:\n\t\t\thid_map_usage(hi, usage, bit, max,\n\t\t\t\t      EV_ABS, ABS_MT_TOUCH_MINOR);\n\t\t\tinput_set_abs_params(hi->input, ABS_MT_ORIENTATION,\n\t\t\t\t\t     0, 1, 0, 0);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\n\tcase 0xff000000:\n\t\t \n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ntrig_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\t\t      struct hid_field *field, struct hid_usage *usage,\n\t\t\t      unsigned long **bit, int *max)\n{\n\t \n\tif (field->physical)\n\t\treturn 0;\n\n\tif (usage->type == EV_KEY || usage->type == EV_REL\n\t\t\t|| usage->type == EV_ABS)\n\t\tclear_bit(usage->code, *bit);\n\n\treturn 0;\n}\n\n \nstatic int ntrig_event (struct hid_device *hid, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct ntrig_data *nd = hid_get_drvdata(hid);\n\tstruct input_dev *input;\n\n\t \n\tif (!(hid->claimed & HID_CLAIMED_INPUT))\n\t\tgoto not_claimed_input;\n\n\t \n\tif(!(field->hidinput && field->hidinput->input))\n\t\treturn -EINVAL;\n\n\tinput = field->hidinput->input;\n\n\t \n\tif (field->application == HID_DG_PEN)\n\t\treturn 0;\n\n\tswitch (usage->hid) {\n\tcase 0xff000001:\n\t\t \n\t\tnd->reading_mt = true;\n\t\tnd->first_contact_touch = false;\n\t\tbreak;\n\tcase HID_DG_TIPSWITCH:\n\t\tnd->tipswitch = value;\n\t\t \n\t\treturn 1;\n\tcase HID_DG_CONFIDENCE:\n\t\tnd->confidence = value;\n\t\tbreak;\n\tcase HID_GD_X:\n\t\tnd->x = value;\n\t\t \n\t\tnd->mt_foot_count = 0;\n\t\tbreak;\n\tcase HID_GD_Y:\n\t\tnd->y = value;\n\t\tbreak;\n\tcase HID_DG_CONTACTID:\n\t\tnd->id = value;\n\t\tbreak;\n\tcase HID_DG_WIDTH:\n\t\tnd->w = value;\n\t\tbreak;\n\tcase HID_DG_HEIGHT:\n\t\tnd->h = value;\n\t\t \n\t\tif (!nd->reading_mt) {\n\t\t\t \n\t\t\tinput_report_key(input, BTN_TOUCH,\n\t\t\t\t\t nd->tipswitch);\n\t\t\tinput_report_key(input, BTN_TOOL_DOUBLETAP,\n\t\t\t\t\t nd->tipswitch);\n\t\t\tinput_event(input, EV_ABS, ABS_X, nd->x);\n\t\t\tinput_event(input, EV_ABS, ABS_Y, nd->y);\n\t\t}\n\t\tbreak;\n\tcase 0xff000002:\n\t\t \n\n\t\t \n\t\tif (nd->mt_foot_count >= 4)\n\t\t\tbreak;\n\n\t\tnd->mt_footer[nd->mt_foot_count++] = value;\n\n\t\t \n\t\tif (nd->mt_foot_count != 4)\n\t\t\tbreak;\n\n\t\t \n\t\tif (nd->mt_footer[2]) {\n\t\t\t \n\t\t\tnd->act_state = deactivate_slack - 1;\n\t\t\tnd->confidence = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (nd->mt_footer[0]) {\n\t\t\t \n\t\t\tif (nd->w < nd->min_width ||\n\t\t\t    nd->h < nd->min_height)\n\t\t\t\tnd->confidence = false;\n\t\t} else\n\t\t\tbreak;\n\n\t\tif (nd->act_state > 0) {\n\t\t\t \n\t\t\tif (nd->w >= nd->activation_width &&\n\t\t\t    nd->h >= nd->activation_height) {\n\t\t\t\tif (nd->id)\n\t\t\t\t\t \n\t\t\t\t\tnd->act_state = 0;\n\t\t\t\telse {\n\t\t\t\t\t \n\t\t\t\t\tnd->act_state = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!nd->confidence)\n\t\t\tbreak;\n\n\t\t \n\t\tif (nd->id == 0) {\n\t\t\t \n\t\t\tnd->first_contact_touch = nd->confidence;\n\t\t\tinput_event(input, EV_ABS, ABS_X, nd->x);\n\t\t\tinput_event(input, EV_ABS, ABS_Y, nd->y);\n\t\t}\n\n\t\t \n\t\tinput_event(input, EV_ABS, ABS_MT_POSITION_X, nd->x);\n\t\tinput_event(input, EV_ABS, ABS_MT_POSITION_Y, nd->y);\n\n\t\t \n\t\tif (nd->w > nd->h) {\n\t\t\tinput_event(input, EV_ABS,\n\t\t\t\t\tABS_MT_ORIENTATION, 1);\n\t\t\tinput_event(input, EV_ABS,\n\t\t\t\t\tABS_MT_TOUCH_MAJOR, nd->w);\n\t\t\tinput_event(input, EV_ABS,\n\t\t\t\t\tABS_MT_TOUCH_MINOR, nd->h);\n\t\t} else {\n\t\t\tinput_event(input, EV_ABS,\n\t\t\t\t\tABS_MT_ORIENTATION, 0);\n\t\t\tinput_event(input, EV_ABS,\n\t\t\t\t\tABS_MT_TOUCH_MAJOR, nd->h);\n\t\t\tinput_event(input, EV_ABS,\n\t\t\t\t\tABS_MT_TOUCH_MINOR, nd->w);\n\t\t}\n\t\tinput_mt_sync(field->hidinput->input);\n\t\tbreak;\n\n\tcase HID_DG_CONTACTCOUNT:  \n\t\tif (!nd->reading_mt)  \n\t\t\tbreak;\n\n\t\tnd->reading_mt = false;\n\n\n\t\t \n\n\t\tif (nd->act_state > 0) {  \n\t\t\tif (value)\n\t\t\t\t \n\t\t\t\tnd->act_state = (nd->act_state > value)\n\t\t\t\t\t\t? nd->act_state - value\n\t\t\t\t\t\t: 0;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tnd->act_state = nd->activate_slack;\n\n\t\t\t \n\t\t\tbreak;\n\t\t} else {  \n\t\t\tif (value && nd->act_state >=\n\t\t\t\t     nd->deactivate_slack)\n\t\t\t\t \n\t\t\t\tnd->act_state = 0;\n\t\t\telse if (nd->act_state <= nd->deactivate_slack)\n\t\t\t\t \n\t\t\t\tnd->act_state =\n\t\t\t\t\tnd->activate_slack;\n\t\t\telse {  \n\t\t\t\tnd->act_state--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (nd->first_contact_touch && nd->act_state <= 0) {\n\t\t\t \n\t\t\tinput_report_key(input, BTN_TOOL_DOUBLETAP, 1);\n\t\t\tinput_report_key(input, BTN_TOUCH, 1);\n\t\t} else {\n\t\t\tinput_report_key(input, BTN_TOOL_DOUBLETAP, 0);\n\t\t\tinput_report_key(input, BTN_TOUCH, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\nnot_claimed_input:\n\n\t \n\tif ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_hid_event)\n\t\thid->hiddev_hid_event(hid, field, usage, value);\n\n\treturn 1;\n}\n\nstatic int ntrig_input_configured(struct hid_device *hid,\n\t\tstruct hid_input *hidinput)\n\n{\n\tstruct input_dev *input = hidinput->input;\n\n\tif (hidinput->report->maxfield < 1)\n\t\treturn 0;\n\n\tswitch (hidinput->report->field[0]->application) {\n\tcase HID_DG_PEN:\n\t\tinput->name = \"N-Trig Pen\";\n\t\tbreak;\n\tcase HID_DG_TOUCHSCREEN:\n\t\t \n\t\t__clear_bit(BTN_TOOL_PEN, input->keybit);\n\t\t__clear_bit(BTN_TOOL_FINGER, input->keybit);\n\t\t__clear_bit(BTN_0, input->keybit);\n\t\t__set_bit(BTN_TOOL_DOUBLETAP, input->keybit);\n\t\t \n\t\tinput->name = (hidinput->report->field[0]->physical) ?\n\t\t\t\t\t\t\t\"N-Trig Touchscreen\" :\n\t\t\t\t\t\t\t\"N-Trig MultiTouch\";\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\tstruct ntrig_data *nd;\n\tstruct hid_report *report;\n\n\tif (id->driver_data)\n\t\thdev->quirks |= HID_QUIRK_MULTI_INPUT\n\t\t\t\t| HID_QUIRK_NO_INIT_REPORTS;\n\n\tnd = kmalloc(sizeof(struct ntrig_data), GFP_KERNEL);\n\tif (!nd) {\n\t\thid_err(hdev, \"cannot allocate N-Trig data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnd->reading_mt = false;\n\tnd->min_width = 0;\n\tnd->min_height = 0;\n\tnd->activate_slack = activate_slack;\n\tnd->act_state = activate_slack;\n\tnd->deactivate_slack = -deactivate_slack;\n\tnd->sensor_logical_width = 1;\n\tnd->sensor_logical_height = 1;\n\tnd->sensor_physical_width = 1;\n\tnd->sensor_physical_height = 1;\n\n\thid_set_drvdata(hdev, nd);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\t \n\treport = hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[0x0a];\n\tif (report) {\n\t\t \n\t\thid_hw_wait(hdev);\n\t\thid_hw_request(hdev, report, HID_REQ_GET_REPORT);\n\n\t\t \n\t\tif (ntrig_get_mode(hdev) >= 4)\n\t\t\tntrig_set_mode(hdev, 3);\n\t}\n\n\tntrig_report_version(hdev);\n\n\tret = sysfs_create_group(&hdev->dev.kobj,\n\t\t\t&ntrig_attribute_group);\n\tif (ret)\n\t\thid_err(hdev, \"cannot create sysfs group\\n\");\n\n\treturn 0;\nerr_free:\n\tkfree(nd);\n\treturn ret;\n}\n\nstatic void ntrig_remove(struct hid_device *hdev)\n{\n\tsysfs_remove_group(&hdev->dev.kobj,\n\t\t\t   &ntrig_attribute_group);\n\thid_hw_stop(hdev);\n\tkfree(hid_get_drvdata(hdev));\n}\n\nstatic const struct hid_device_id ntrig_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_1),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_2),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_3),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_4),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_5),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_6),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_7),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_8),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_9),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_10),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_11),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_12),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_13),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_14),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_15),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_16),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_17),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18),\n\t\t.driver_data = NTRIG_DUPLICATE_USAGES },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ntrig_devices);\n\nstatic const struct hid_usage_id ntrig_grabbed_usages[] = {\n\t{ HID_ANY_ID, HID_ANY_ID, HID_ANY_ID },\n\t{ HID_ANY_ID - 1, HID_ANY_ID - 1, HID_ANY_ID - 1 }\n};\n\nstatic struct hid_driver ntrig_driver = {\n\t.name = \"ntrig\",\n\t.id_table = ntrig_devices,\n\t.probe = ntrig_probe,\n\t.remove = ntrig_remove,\n\t.input_mapping = ntrig_input_mapping,\n\t.input_mapped = ntrig_input_mapped,\n\t.input_configured = ntrig_input_configured,\n\t.usage_table = ntrig_grabbed_usages,\n\t.event = ntrig_event,\n};\nmodule_hid_driver(ntrig_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}