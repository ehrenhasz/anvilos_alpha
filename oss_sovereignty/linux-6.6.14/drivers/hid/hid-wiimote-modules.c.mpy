{
  "module_name": "hid-wiimote-modules.c",
  "hash_id": "96150179f9ffbb4acab5baa7d9e580e88e44a6b9aebe5a5a435f1ffb6f0d7b8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-wiimote-modules.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/spinlock.h>\n#include \"hid-wiimote.h\"\n\n \n\nstatic const __u16 wiimod_keys_map[] = {\n\tKEY_LEFT,\t \n\tKEY_RIGHT,\t \n\tKEY_UP,\t\t \n\tKEY_DOWN,\t \n\tKEY_NEXT,\t \n\tKEY_PREVIOUS,\t \n\tBTN_1,\t\t \n\tBTN_2,\t\t \n\tBTN_A,\t\t \n\tBTN_B,\t\t \n\tBTN_MODE,\t \n};\n\nstatic void wiimod_keys_in_keys(struct wiimote_data *wdata, const __u8 *keys)\n{\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_LEFT],\n\t\t\t\t\t\t\t!!(keys[0] & 0x01));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_RIGHT],\n\t\t\t\t\t\t\t!!(keys[0] & 0x02));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_DOWN],\n\t\t\t\t\t\t\t!!(keys[0] & 0x04));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_UP],\n\t\t\t\t\t\t\t!!(keys[0] & 0x08));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_PLUS],\n\t\t\t\t\t\t\t!!(keys[0] & 0x10));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_TWO],\n\t\t\t\t\t\t\t!!(keys[1] & 0x01));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_ONE],\n\t\t\t\t\t\t\t!!(keys[1] & 0x02));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_B],\n\t\t\t\t\t\t\t!!(keys[1] & 0x04));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_A],\n\t\t\t\t\t\t\t!!(keys[1] & 0x08));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_MINUS],\n\t\t\t\t\t\t\t!!(keys[1] & 0x10));\n\tinput_report_key(wdata->input, wiimod_keys_map[WIIPROTO_KEY_HOME],\n\t\t\t\t\t\t\t!!(keys[1] & 0x80));\n\tinput_sync(wdata->input);\n}\n\nstatic int wiimod_keys_probe(const struct wiimod_ops *ops,\n\t\t\t     struct wiimote_data *wdata)\n{\n\tunsigned int i;\n\n\tset_bit(EV_KEY, wdata->input->evbit);\n\tfor (i = 0; i < WIIPROTO_KEY_COUNT; ++i)\n\t\tset_bit(wiimod_keys_map[i], wdata->input->keybit);\n\n\treturn 0;\n}\n\nstatic const struct wiimod_ops wiimod_keys = {\n\t.flags = WIIMOD_FLAG_INPUT,\n\t.arg = 0,\n\t.probe = wiimod_keys_probe,\n\t.remove = NULL,\n\t.in_keys = wiimod_keys_in_keys,\n};\n\n \n\n \nstatic void wiimod_rumble_worker(struct work_struct *work)\n{\n\tstruct wiimote_data *wdata = container_of(work, struct wiimote_data,\n\t\t\t\t\t\t  rumble_worker);\n\n\tspin_lock_irq(&wdata->state.lock);\n\twiiproto_req_rumble(wdata, wdata->state.cache_rumble);\n\tspin_unlock_irq(&wdata->state.lock);\n}\n\nstatic int wiimod_rumble_play(struct input_dev *dev, void *data,\n\t\t\t      struct ff_effect *eff)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\t__u8 value;\n\n\t \n\n\tif (eff->u.rumble.strong_magnitude || eff->u.rumble.weak_magnitude)\n\t\tvalue = 1;\n\telse\n\t\tvalue = 0;\n\n\t \n\twdata->state.cache_rumble = value;\n\tschedule_work(&wdata->rumble_worker);\n\n\treturn 0;\n}\n\nstatic int wiimod_rumble_probe(const struct wiimod_ops *ops,\n\t\t\t       struct wiimote_data *wdata)\n{\n\tINIT_WORK(&wdata->rumble_worker, wiimod_rumble_worker);\n\n\tset_bit(FF_RUMBLE, wdata->input->ffbit);\n\tif (input_ff_create_memless(wdata->input, NULL, wiimod_rumble_play))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void wiimod_rumble_remove(const struct wiimod_ops *ops,\n\t\t\t\t struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\n\tcancel_work_sync(&wdata->rumble_worker);\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twiiproto_req_rumble(wdata, 0);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic const struct wiimod_ops wiimod_rumble = {\n\t.flags = WIIMOD_FLAG_INPUT,\n\t.arg = 0,\n\t.probe = wiimod_rumble_probe,\n\t.remove = wiimod_rumble_remove,\n};\n\n \n\nstatic enum power_supply_property wiimod_battery_props[] = {\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_SCOPE,\n};\n\nstatic int wiimod_battery_get_property(struct power_supply *psy,\n\t\t\t\t       enum power_supply_property psp,\n\t\t\t\t       union power_supply_propval *val)\n{\n\tstruct wiimote_data *wdata = power_supply_get_drvdata(psy);\n\tint ret = 0, state;\n\tunsigned long flags;\n\n\tif (psp == POWER_SUPPLY_PROP_SCOPE) {\n\t\tval->intval = POWER_SUPPLY_SCOPE_DEVICE;\n\t\treturn 0;\n\t} else if (psp != POWER_SUPPLY_PROP_CAPACITY) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = wiimote_cmd_acquire(wdata);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twiimote_cmd_set(wdata, WIIPROTO_REQ_SREQ, 0);\n\twiiproto_req_status(wdata);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\twiimote_cmd_wait(wdata);\n\twiimote_cmd_release(wdata);\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\tstate = wdata->state.cmd_battery;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tval->intval = state * 100 / 255;\n\treturn ret;\n}\n\nstatic int wiimod_battery_probe(const struct wiimod_ops *ops,\n\t\t\t\tstruct wiimote_data *wdata)\n{\n\tstruct power_supply_config psy_cfg = { .drv_data = wdata, };\n\tint ret;\n\n\twdata->battery_desc.properties = wiimod_battery_props;\n\twdata->battery_desc.num_properties = ARRAY_SIZE(wiimod_battery_props);\n\twdata->battery_desc.get_property = wiimod_battery_get_property;\n\twdata->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\n\twdata->battery_desc.use_for_apm = 0;\n\twdata->battery_desc.name = kasprintf(GFP_KERNEL, \"wiimote_battery_%s\",\n\t\t\t\t\t     wdata->hdev->uniq);\n\tif (!wdata->battery_desc.name)\n\t\treturn -ENOMEM;\n\n\twdata->battery = power_supply_register(&wdata->hdev->dev,\n\t\t\t\t\t       &wdata->battery_desc,\n\t\t\t\t\t       &psy_cfg);\n\tif (IS_ERR(wdata->battery)) {\n\t\thid_err(wdata->hdev, \"cannot register battery device\\n\");\n\t\tret = PTR_ERR(wdata->battery);\n\t\tgoto err_free;\n\t}\n\n\tpower_supply_powers(wdata->battery, &wdata->hdev->dev);\n\treturn 0;\n\nerr_free:\n\tkfree(wdata->battery_desc.name);\n\twdata->battery_desc.name = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_battery_remove(const struct wiimod_ops *ops,\n\t\t\t\t  struct wiimote_data *wdata)\n{\n\tif (!wdata->battery_desc.name)\n\t\treturn;\n\n\tpower_supply_unregister(wdata->battery);\n\tkfree(wdata->battery_desc.name);\n\twdata->battery_desc.name = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_battery = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_battery_probe,\n\t.remove = wiimod_battery_remove,\n};\n\n \n\nstatic enum led_brightness wiimod_led_get(struct led_classdev *led_dev)\n{\n\tstruct device *dev = led_dev->dev->parent;\n\tstruct wiimote_data *wdata = dev_to_wii(dev);\n\tint i;\n\tunsigned long flags;\n\tbool value = false;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (wdata->leds[i] == led_dev) {\n\t\t\tspin_lock_irqsave(&wdata->state.lock, flags);\n\t\t\tvalue = wdata->state.flags & WIIPROTO_FLAG_LED(i + 1);\n\t\t\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn value ? LED_FULL : LED_OFF;\n}\n\nstatic void wiimod_led_set(struct led_classdev *led_dev,\n\t\t\t   enum led_brightness value)\n{\n\tstruct device *dev = led_dev->dev->parent;\n\tstruct wiimote_data *wdata = dev_to_wii(dev);\n\tint i;\n\tunsigned long flags;\n\t__u8 state, flag;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (wdata->leds[i] == led_dev) {\n\t\t\tflag = WIIPROTO_FLAG_LED(i + 1);\n\t\t\tspin_lock_irqsave(&wdata->state.lock, flags);\n\t\t\tstate = wdata->state.flags;\n\t\t\tif (value == LED_OFF)\n\t\t\t\twiiproto_req_leds(wdata, state & ~flag);\n\t\t\telse\n\t\t\t\twiiproto_req_leds(wdata, state | flag);\n\t\t\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int wiimod_led_probe(const struct wiimod_ops *ops,\n\t\t\t    struct wiimote_data *wdata)\n{\n\tstruct device *dev = &wdata->hdev->dev;\n\tsize_t namesz = strlen(dev_name(dev)) + 9;\n\tstruct led_classdev *led;\n\tunsigned long flags;\n\tchar *name;\n\tint ret;\n\n\tled = kzalloc(sizeof(struct led_classdev) + namesz, GFP_KERNEL);\n\tif (!led)\n\t\treturn -ENOMEM;\n\n\tname = (void*)&led[1];\n\tsnprintf(name, namesz, \"%s:blue:p%lu\", dev_name(dev), ops->arg);\n\tled->name = name;\n\tled->brightness = 0;\n\tled->max_brightness = 1;\n\tled->brightness_get = wiimod_led_get;\n\tled->brightness_set = wiimod_led_set;\n\n\twdata->leds[ops->arg] = led;\n\tret = led_classdev_register(dev, led);\n\tif (ret)\n\t\tgoto err_free;\n\n\t \n\tif (ops->arg == 0) {\n\t\tspin_lock_irqsave(&wdata->state.lock, flags);\n\t\twiiproto_req_leds(wdata, WIIPROTO_FLAG_LED1);\n\t\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\t}\n\n\treturn 0;\n\nerr_free:\n\twdata->leds[ops->arg] = NULL;\n\tkfree(led);\n\treturn ret;\n}\n\nstatic void wiimod_led_remove(const struct wiimod_ops *ops,\n\t\t\t      struct wiimote_data *wdata)\n{\n\tif (!wdata->leds[ops->arg])\n\t\treturn;\n\n\tled_classdev_unregister(wdata->leds[ops->arg]);\n\tkfree(wdata->leds[ops->arg]);\n\twdata->leds[ops->arg] = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_leds[4] = {\n\t{\n\t\t.flags = 0,\n\t\t.arg = 0,\n\t\t.probe = wiimod_led_probe,\n\t\t.remove = wiimod_led_remove,\n\t},\n\t{\n\t\t.flags = 0,\n\t\t.arg = 1,\n\t\t.probe = wiimod_led_probe,\n\t\t.remove = wiimod_led_remove,\n\t},\n\t{\n\t\t.flags = 0,\n\t\t.arg = 2,\n\t\t.probe = wiimod_led_probe,\n\t\t.remove = wiimod_led_remove,\n\t},\n\t{\n\t\t.flags = 0,\n\t\t.arg = 3,\n\t\t.probe = wiimod_led_probe,\n\t\t.remove = wiimod_led_remove,\n\t},\n};\n\n \n\nstatic void wiimod_accel_in_accel(struct wiimote_data *wdata,\n\t\t\t\t  const __u8 *accel)\n{\n\t__u16 x, y, z;\n\n\tif (!(wdata->state.flags & WIIPROTO_FLAG_ACCEL))\n\t\treturn;\n\n\t \n\n\tx = accel[2] << 2;\n\ty = accel[3] << 2;\n\tz = accel[4] << 2;\n\n\tx |= (accel[0] >> 5) & 0x3;\n\ty |= (accel[1] >> 4) & 0x2;\n\tz |= (accel[1] >> 5) & 0x2;\n\n\tinput_report_abs(wdata->accel, ABS_RX, x - 0x200);\n\tinput_report_abs(wdata->accel, ABS_RY, y - 0x200);\n\tinput_report_abs(wdata->accel, ABS_RZ, z - 0x200);\n\tinput_sync(wdata->accel);\n}\n\nstatic int wiimod_accel_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twiiproto_req_accel(wdata, true);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_accel_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twiiproto_req_accel(wdata, false);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic int wiimod_accel_probe(const struct wiimod_ops *ops,\n\t\t\t      struct wiimote_data *wdata)\n{\n\tint ret;\n\n\twdata->accel = input_allocate_device();\n\tif (!wdata->accel)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(wdata->accel, wdata);\n\twdata->accel->open = wiimod_accel_open;\n\twdata->accel->close = wiimod_accel_close;\n\twdata->accel->dev.parent = &wdata->hdev->dev;\n\twdata->accel->id.bustype = wdata->hdev->bus;\n\twdata->accel->id.vendor = wdata->hdev->vendor;\n\twdata->accel->id.product = wdata->hdev->product;\n\twdata->accel->id.version = wdata->hdev->version;\n\twdata->accel->name = WIIMOTE_NAME \" Accelerometer\";\n\n\tset_bit(EV_ABS, wdata->accel->evbit);\n\tset_bit(ABS_RX, wdata->accel->absbit);\n\tset_bit(ABS_RY, wdata->accel->absbit);\n\tset_bit(ABS_RZ, wdata->accel->absbit);\n\tinput_set_abs_params(wdata->accel, ABS_RX, -500, 500, 2, 4);\n\tinput_set_abs_params(wdata->accel, ABS_RY, -500, 500, 2, 4);\n\tinput_set_abs_params(wdata->accel, ABS_RZ, -500, 500, 2, 4);\n\n\tret = input_register_device(wdata->accel);\n\tif (ret) {\n\t\thid_err(wdata->hdev, \"cannot register input device\\n\");\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\n\nerr_free:\n\tinput_free_device(wdata->accel);\n\twdata->accel = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_accel_remove(const struct wiimod_ops *ops,\n\t\t\t\tstruct wiimote_data *wdata)\n{\n\tif (!wdata->accel)\n\t\treturn;\n\n\tinput_unregister_device(wdata->accel);\n\twdata->accel = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_accel = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_accel_probe,\n\t.remove = wiimod_accel_remove,\n\t.in_accel = wiimod_accel_in_accel,\n};\n\n \n\nstatic void wiimod_ir_in_ir(struct wiimote_data *wdata, const __u8 *ir,\n\t\t\t    bool packed, unsigned int id)\n{\n\t__u16 x, y;\n\t__u8 xid, yid;\n\tbool sync = false;\n\n\tif (!(wdata->state.flags & WIIPROTO_FLAGS_IR))\n\t\treturn;\n\n\tswitch (id) {\n\tcase 0:\n\t\txid = ABS_HAT0X;\n\t\tyid = ABS_HAT0Y;\n\t\tbreak;\n\tcase 1:\n\t\txid = ABS_HAT1X;\n\t\tyid = ABS_HAT1Y;\n\t\tbreak;\n\tcase 2:\n\t\txid = ABS_HAT2X;\n\t\tyid = ABS_HAT2Y;\n\t\tbreak;\n\tcase 3:\n\t\txid = ABS_HAT3X;\n\t\tyid = ABS_HAT3Y;\n\t\tsync = true;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\n\tif (packed) {\n\t\tx = ir[1] | ((ir[0] & 0x03) << 8);\n\t\ty = ir[2] | ((ir[0] & 0x0c) << 6);\n\t} else {\n\t\tx = ir[0] | ((ir[2] & 0x30) << 4);\n\t\ty = ir[1] | ((ir[2] & 0xc0) << 2);\n\t}\n\n\tinput_report_abs(wdata->ir, xid, x);\n\tinput_report_abs(wdata->ir, yid, y);\n\n\tif (sync)\n\t\tinput_sync(wdata->ir);\n}\n\nstatic int wiimod_ir_change(struct wiimote_data *wdata, __u16 mode)\n{\n\tint ret;\n\tunsigned long flags;\n\t__u8 format = 0;\n\tstatic const __u8 data_enable[] = { 0x01 };\n\tstatic const __u8 data_sens1[] = { 0x02, 0x00, 0x00, 0x71, 0x01,\n\t\t\t\t\t\t0x00, 0xaa, 0x00, 0x64 };\n\tstatic const __u8 data_sens2[] = { 0x63, 0x03 };\n\tstatic const __u8 data_fin[] = { 0x08 };\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\n\tif (mode == (wdata->state.flags & WIIPROTO_FLAGS_IR)) {\n\t\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (mode == 0) {\n\t\twdata->state.flags &= ~WIIPROTO_FLAGS_IR;\n\t\twiiproto_req_ir1(wdata, 0);\n\t\twiiproto_req_ir2(wdata, 0);\n\t\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\t\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\t\treturn 0;\n\t}\n\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tret = wiimote_cmd_acquire(wdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twiimote_cmd_set(wdata, WIIPROTO_REQ_IR1, 0);\n\twiiproto_req_ir1(wdata, 0x06);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tret = wiimote_cmd_wait(wdata);\n\tif (ret)\n\t\tgoto unlock;\n\tif (wdata->state.cmd_err) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\t \n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twiimote_cmd_set(wdata, WIIPROTO_REQ_IR2, 0);\n\twiiproto_req_ir2(wdata, 0x06);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\tret = wiimote_cmd_wait(wdata);\n\tif (ret)\n\t\tgoto unlock;\n\tif (wdata->state.cmd_err) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = wiimote_cmd_write(wdata, 0xb00030, data_enable,\n\t\t\t\t\t\t\tsizeof(data_enable));\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = wiimote_cmd_write(wdata, 0xb00000, data_sens1,\n\t\t\t\t\t\t\tsizeof(data_sens1));\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = wiimote_cmd_write(wdata, 0xb0001a, data_sens2,\n\t\t\t\t\t\t\tsizeof(data_sens2));\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tswitch (mode) {\n\t\tcase WIIPROTO_FLAG_IR_FULL:\n\t\t\tformat = 5;\n\t\t\tbreak;\n\t\tcase WIIPROTO_FLAG_IR_EXT:\n\t\t\tformat = 3;\n\t\t\tbreak;\n\t\tcase WIIPROTO_FLAG_IR_BASIC:\n\t\t\tformat = 1;\n\t\t\tbreak;\n\t}\n\tret = wiimote_cmd_write(wdata, 0xb00033, &format, sizeof(format));\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = wiimote_cmd_write(wdata, 0xb00030, data_fin, sizeof(data_fin));\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAGS_IR;\n\twdata->state.flags |= mode & WIIPROTO_FLAGS_IR;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\nunlock:\n\twiimote_cmd_release(wdata);\n\treturn ret;\n}\n\nstatic int wiimod_ir_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\n\treturn wiimod_ir_change(wdata, WIIPROTO_FLAG_IR_BASIC);\n}\n\nstatic void wiimod_ir_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\n\twiimod_ir_change(wdata, 0);\n}\n\nstatic int wiimod_ir_probe(const struct wiimod_ops *ops,\n\t\t\t   struct wiimote_data *wdata)\n{\n\tint ret;\n\n\twdata->ir = input_allocate_device();\n\tif (!wdata->ir)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(wdata->ir, wdata);\n\twdata->ir->open = wiimod_ir_open;\n\twdata->ir->close = wiimod_ir_close;\n\twdata->ir->dev.parent = &wdata->hdev->dev;\n\twdata->ir->id.bustype = wdata->hdev->bus;\n\twdata->ir->id.vendor = wdata->hdev->vendor;\n\twdata->ir->id.product = wdata->hdev->product;\n\twdata->ir->id.version = wdata->hdev->version;\n\twdata->ir->name = WIIMOTE_NAME \" IR\";\n\n\tset_bit(EV_ABS, wdata->ir->evbit);\n\tset_bit(ABS_HAT0X, wdata->ir->absbit);\n\tset_bit(ABS_HAT0Y, wdata->ir->absbit);\n\tset_bit(ABS_HAT1X, wdata->ir->absbit);\n\tset_bit(ABS_HAT1Y, wdata->ir->absbit);\n\tset_bit(ABS_HAT2X, wdata->ir->absbit);\n\tset_bit(ABS_HAT2Y, wdata->ir->absbit);\n\tset_bit(ABS_HAT3X, wdata->ir->absbit);\n\tset_bit(ABS_HAT3Y, wdata->ir->absbit);\n\tinput_set_abs_params(wdata->ir, ABS_HAT0X, 0, 1023, 2, 4);\n\tinput_set_abs_params(wdata->ir, ABS_HAT0Y, 0, 767, 2, 4);\n\tinput_set_abs_params(wdata->ir, ABS_HAT1X, 0, 1023, 2, 4);\n\tinput_set_abs_params(wdata->ir, ABS_HAT1Y, 0, 767, 2, 4);\n\tinput_set_abs_params(wdata->ir, ABS_HAT2X, 0, 1023, 2, 4);\n\tinput_set_abs_params(wdata->ir, ABS_HAT2Y, 0, 767, 2, 4);\n\tinput_set_abs_params(wdata->ir, ABS_HAT3X, 0, 1023, 2, 4);\n\tinput_set_abs_params(wdata->ir, ABS_HAT3Y, 0, 767, 2, 4);\n\n\tret = input_register_device(wdata->ir);\n\tif (ret) {\n\t\thid_err(wdata->hdev, \"cannot register input device\\n\");\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\n\nerr_free:\n\tinput_free_device(wdata->ir);\n\twdata->ir = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_ir_remove(const struct wiimod_ops *ops,\n\t\t\t     struct wiimote_data *wdata)\n{\n\tif (!wdata->ir)\n\t\treturn;\n\n\tinput_unregister_device(wdata->ir);\n\twdata->ir = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_ir = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_ir_probe,\n\t.remove = wiimod_ir_remove,\n\t.in_ir = wiimod_ir_in_ir,\n};\n\n \n\nenum wiimod_nunchuk_keys {\n\tWIIMOD_NUNCHUK_KEY_C,\n\tWIIMOD_NUNCHUK_KEY_Z,\n\tWIIMOD_NUNCHUK_KEY_NUM,\n};\n\nstatic const __u16 wiimod_nunchuk_map[] = {\n\tBTN_C,\t\t \n\tBTN_Z,\t\t \n};\n\nstatic void wiimod_nunchuk_in_ext(struct wiimote_data *wdata, const __u8 *ext)\n{\n\t__s16 x, y, z, bx, by;\n\n\t \n\n\tbx = ext[0];\n\tby = ext[1];\n\tbx -= 128;\n\tby -= 128;\n\n\tx = ext[2] << 2;\n\ty = ext[3] << 2;\n\tz = ext[4] << 2;\n\n\tif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\n\t\tx |= (ext[5] >> 3) & 0x02;\n\t\ty |= (ext[5] >> 4) & 0x02;\n\t\tz &= ~0x4;\n\t\tz |= (ext[5] >> 5) & 0x06;\n\t} else {\n\t\tx |= (ext[5] >> 2) & 0x03;\n\t\ty |= (ext[5] >> 4) & 0x03;\n\t\tz |= (ext[5] >> 6) & 0x03;\n\t}\n\n\tx -= 0x200;\n\ty -= 0x200;\n\tz -= 0x200;\n\n\tinput_report_abs(wdata->extension.input, ABS_HAT0X, bx);\n\tinput_report_abs(wdata->extension.input, ABS_HAT0Y, by);\n\n\tinput_report_abs(wdata->extension.input, ABS_RX, x);\n\tinput_report_abs(wdata->extension.input, ABS_RY, y);\n\tinput_report_abs(wdata->extension.input, ABS_RZ, z);\n\n\tif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\n\t\tinput_report_key(wdata->extension.input,\n\t\t\twiimod_nunchuk_map[WIIMOD_NUNCHUK_KEY_Z],\n\t\t\t!(ext[5] & 0x04));\n\t\tinput_report_key(wdata->extension.input,\n\t\t\twiimod_nunchuk_map[WIIMOD_NUNCHUK_KEY_C],\n\t\t\t!(ext[5] & 0x08));\n\t} else {\n\t\tinput_report_key(wdata->extension.input,\n\t\t\twiimod_nunchuk_map[WIIMOD_NUNCHUK_KEY_Z],\n\t\t\t!(ext[5] & 0x01));\n\t\tinput_report_key(wdata->extension.input,\n\t\t\twiimod_nunchuk_map[WIIMOD_NUNCHUK_KEY_C],\n\t\t\t!(ext[5] & 0x02));\n\t}\n\n\tinput_sync(wdata->extension.input);\n}\n\nstatic int wiimod_nunchuk_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_nunchuk_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic int wiimod_nunchuk_probe(const struct wiimod_ops *ops,\n\t\t\t\tstruct wiimote_data *wdata)\n{\n\tint ret, i;\n\n\twdata->extension.input = input_allocate_device();\n\tif (!wdata->extension.input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(wdata->extension.input, wdata);\n\twdata->extension.input->open = wiimod_nunchuk_open;\n\twdata->extension.input->close = wiimod_nunchuk_close;\n\twdata->extension.input->dev.parent = &wdata->hdev->dev;\n\twdata->extension.input->id.bustype = wdata->hdev->bus;\n\twdata->extension.input->id.vendor = wdata->hdev->vendor;\n\twdata->extension.input->id.product = wdata->hdev->product;\n\twdata->extension.input->id.version = wdata->hdev->version;\n\twdata->extension.input->name = WIIMOTE_NAME \" Nunchuk\";\n\n\tset_bit(EV_KEY, wdata->extension.input->evbit);\n\tfor (i = 0; i < WIIMOD_NUNCHUK_KEY_NUM; ++i)\n\t\tset_bit(wiimod_nunchuk_map[i],\n\t\t\twdata->extension.input->keybit);\n\n\tset_bit(EV_ABS, wdata->extension.input->evbit);\n\tset_bit(ABS_HAT0X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT0Y, wdata->extension.input->absbit);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT0X, -120, 120, 2, 4);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT0Y, -120, 120, 2, 4);\n\tset_bit(ABS_RX, wdata->extension.input->absbit);\n\tset_bit(ABS_RY, wdata->extension.input->absbit);\n\tset_bit(ABS_RZ, wdata->extension.input->absbit);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_RX, -500, 500, 2, 4);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_RY, -500, 500, 2, 4);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_RZ, -500, 500, 2, 4);\n\n\tret = input_register_device(wdata->extension.input);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tinput_free_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_nunchuk_remove(const struct wiimod_ops *ops,\n\t\t\t\t  struct wiimote_data *wdata)\n{\n\tif (!wdata->extension.input)\n\t\treturn;\n\n\tinput_unregister_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_nunchuk = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_nunchuk_probe,\n\t.remove = wiimod_nunchuk_remove,\n\t.in_ext = wiimod_nunchuk_in_ext,\n};\n\n \n\nenum wiimod_classic_keys {\n\tWIIMOD_CLASSIC_KEY_A,\n\tWIIMOD_CLASSIC_KEY_B,\n\tWIIMOD_CLASSIC_KEY_X,\n\tWIIMOD_CLASSIC_KEY_Y,\n\tWIIMOD_CLASSIC_KEY_ZL,\n\tWIIMOD_CLASSIC_KEY_ZR,\n\tWIIMOD_CLASSIC_KEY_PLUS,\n\tWIIMOD_CLASSIC_KEY_MINUS,\n\tWIIMOD_CLASSIC_KEY_HOME,\n\tWIIMOD_CLASSIC_KEY_LEFT,\n\tWIIMOD_CLASSIC_KEY_RIGHT,\n\tWIIMOD_CLASSIC_KEY_UP,\n\tWIIMOD_CLASSIC_KEY_DOWN,\n\tWIIMOD_CLASSIC_KEY_LT,\n\tWIIMOD_CLASSIC_KEY_RT,\n\tWIIMOD_CLASSIC_KEY_NUM,\n};\n\nstatic const __u16 wiimod_classic_map[] = {\n\tBTN_A,\t\t \n\tBTN_B,\t\t \n\tBTN_X,\t\t \n\tBTN_Y,\t\t \n\tBTN_TL2,\t \n\tBTN_TR2,\t \n\tKEY_NEXT,\t \n\tKEY_PREVIOUS,\t \n\tBTN_MODE,\t \n\tKEY_LEFT,\t \n\tKEY_RIGHT,\t \n\tKEY_UP,\t\t \n\tKEY_DOWN,\t \n\tBTN_TL,\t\t \n\tBTN_TR,\t\t \n};\n\nstatic void wiimod_classic_in_ext(struct wiimote_data *wdata, const __u8 *ext)\n{\n\t__s8 rx, ry, lx, ly, lt, rt;\n\n\t \n\n\tstatic const s8 digital_to_analog[3] = {0x20, 0, -0x20};\n\n\tif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\n\t\tif (wiimote_dpad_as_analog) {\n\t\t\tlx = digital_to_analog[1 - !(ext[4] & 0x80)\n\t\t\t\t+ !(ext[1] & 0x01)];\n\t\t\tly = digital_to_analog[1 - !(ext[4] & 0x40)\n\t\t\t\t+ !(ext[0] & 0x01)];\n\t\t} else {\n\t\t\tlx = (ext[0] & 0x3e) - 0x20;\n\t\t\tly = (ext[1] & 0x3e) - 0x20;\n\t\t}\n\t} else {\n\t\tif (wiimote_dpad_as_analog) {\n\t\t\tlx = digital_to_analog[1 - !(ext[4] & 0x80)\n\t\t\t\t+ !(ext[5] & 0x02)];\n\t\t\tly = digital_to_analog[1 - !(ext[4] & 0x40)\n\t\t\t\t+ !(ext[5] & 0x01)];\n\t\t} else {\n\t\t\tlx = (ext[0] & 0x3f) - 0x20;\n\t\t\tly = (ext[1] & 0x3f) - 0x20;\n\t\t}\n\t}\n\n\trx = (ext[0] >> 3) & 0x18;\n\trx |= (ext[1] >> 5) & 0x06;\n\trx |= (ext[2] >> 7) & 0x01;\n\try = ext[2] & 0x1f;\n\n\trt = ext[3] & 0x1f;\n\tlt = (ext[2] >> 2) & 0x18;\n\tlt |= (ext[3] >> 5) & 0x07;\n\n\trx <<= 1;\n\try <<= 1;\n\trt <<= 1;\n\tlt <<= 1;\n\n\tinput_report_abs(wdata->extension.input, ABS_HAT1X, lx);\n\tinput_report_abs(wdata->extension.input, ABS_HAT1Y, ly);\n\tinput_report_abs(wdata->extension.input, ABS_HAT2X, rx - 0x20);\n\tinput_report_abs(wdata->extension.input, ABS_HAT2Y, ry - 0x20);\n\tinput_report_abs(wdata->extension.input, ABS_HAT3X, rt);\n\tinput_report_abs(wdata->extension.input, ABS_HAT3Y, lt);\n\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_LT],\n\t\t\t !(ext[4] & 0x20));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_MINUS],\n\t\t\t !(ext[4] & 0x10));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_HOME],\n\t\t\t !(ext[4] & 0x08));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_PLUS],\n\t\t\t !(ext[4] & 0x04));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_RT],\n\t\t\t !(ext[4] & 0x02));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_ZL],\n\t\t\t !(ext[5] & 0x80));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_B],\n\t\t\t !(ext[5] & 0x40));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_Y],\n\t\t\t !(ext[5] & 0x20));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_A],\n\t\t\t !(ext[5] & 0x10));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_X],\n\t\t\t !(ext[5] & 0x08));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_ZR],\n\t\t\t !(ext[5] & 0x04));\n\n\tif (!wiimote_dpad_as_analog) {\n\t\tinput_report_key(wdata->extension.input,\n\t\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_RIGHT],\n\t\t\t\t !(ext[4] & 0x80));\n\t\tinput_report_key(wdata->extension.input,\n\t\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_DOWN],\n\t\t\t\t !(ext[4] & 0x40));\n\n\t\tif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\n\t\t\tinput_report_key(wdata->extension.input,\n\t\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_LEFT],\n\t\t\t\t !(ext[1] & 0x01));\n\t\t\tinput_report_key(wdata->extension.input,\n\t\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_UP],\n\t\t\t\t !(ext[0] & 0x01));\n\t\t} else {\n\t\t\tinput_report_key(wdata->extension.input,\n\t\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_LEFT],\n\t\t\t\t !(ext[5] & 0x02));\n\t\t\tinput_report_key(wdata->extension.input,\n\t\t\t\t wiimod_classic_map[WIIMOD_CLASSIC_KEY_UP],\n\t\t\t\t !(ext[5] & 0x01));\n\t\t}\n\t}\n\n\tinput_sync(wdata->extension.input);\n}\n\nstatic int wiimod_classic_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_classic_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic int wiimod_classic_probe(const struct wiimod_ops *ops,\n\t\t\t\tstruct wiimote_data *wdata)\n{\n\tint ret, i;\n\n\twdata->extension.input = input_allocate_device();\n\tif (!wdata->extension.input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(wdata->extension.input, wdata);\n\twdata->extension.input->open = wiimod_classic_open;\n\twdata->extension.input->close = wiimod_classic_close;\n\twdata->extension.input->dev.parent = &wdata->hdev->dev;\n\twdata->extension.input->id.bustype = wdata->hdev->bus;\n\twdata->extension.input->id.vendor = wdata->hdev->vendor;\n\twdata->extension.input->id.product = wdata->hdev->product;\n\twdata->extension.input->id.version = wdata->hdev->version;\n\twdata->extension.input->name = WIIMOTE_NAME \" Classic Controller\";\n\n\tset_bit(EV_KEY, wdata->extension.input->evbit);\n\tfor (i = 0; i < WIIMOD_CLASSIC_KEY_NUM; ++i)\n\t\tset_bit(wiimod_classic_map[i],\n\t\t\twdata->extension.input->keybit);\n\n\tset_bit(EV_ABS, wdata->extension.input->evbit);\n\tset_bit(ABS_HAT1X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT1Y, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT2X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT2Y, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT3X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT3Y, wdata->extension.input->absbit);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT1X, -30, 30, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT1Y, -30, 30, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT2X, -30, 30, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT2Y, -30, 30, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT3X, -30, 30, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT3Y, -30, 30, 1, 1);\n\n\tret = input_register_device(wdata->extension.input);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tinput_free_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_classic_remove(const struct wiimod_ops *ops,\n\t\t\t\t  struct wiimote_data *wdata)\n{\n\tif (!wdata->extension.input)\n\t\treturn;\n\n\tinput_unregister_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_classic = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_classic_probe,\n\t.remove = wiimod_classic_remove,\n\t.in_ext = wiimod_classic_in_ext,\n};\n\n \n\nstatic void wiimod_bboard_in_keys(struct wiimote_data *wdata, const __u8 *keys)\n{\n\tinput_report_key(wdata->extension.input, BTN_A,\n\t\t\t !!(keys[1] & 0x08));\n\tinput_sync(wdata->extension.input);\n}\n\nstatic void wiimod_bboard_in_ext(struct wiimote_data *wdata,\n\t\t\t\t const __u8 *ext)\n{\n\t__s32 val[4], tmp, div;\n\tunsigned int i;\n\tstruct wiimote_state *s = &wdata->state;\n\n\t \n\n\tval[0] = ext[0];\n\tval[0] <<= 8;\n\tval[0] |= ext[1];\n\n\tval[1] = ext[2];\n\tval[1] <<= 8;\n\tval[1] |= ext[3];\n\n\tval[2] = ext[4];\n\tval[2] <<= 8;\n\tval[2] |= ext[5];\n\n\tval[3] = ext[6];\n\tval[3] <<= 8;\n\tval[3] |= ext[7];\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (val[i] <= s->calib_bboard[i][0]) {\n\t\t\ttmp = 0;\n\t\t} else if (val[i] < s->calib_bboard[i][1]) {\n\t\t\ttmp = val[i] - s->calib_bboard[i][0];\n\t\t\ttmp *= 1700;\n\t\t\tdiv = s->calib_bboard[i][1] - s->calib_bboard[i][0];\n\t\t\ttmp /= div ? div : 1;\n\t\t} else {\n\t\t\ttmp = val[i] - s->calib_bboard[i][1];\n\t\t\ttmp *= 1700;\n\t\t\tdiv = s->calib_bboard[i][2] - s->calib_bboard[i][1];\n\t\t\ttmp /= div ? div : 1;\n\t\t\ttmp += 1700;\n\t\t}\n\t\tval[i] = tmp;\n\t}\n\n\tinput_report_abs(wdata->extension.input, ABS_HAT0X, val[0]);\n\tinput_report_abs(wdata->extension.input, ABS_HAT0Y, val[1]);\n\tinput_report_abs(wdata->extension.input, ABS_HAT1X, val[2]);\n\tinput_report_abs(wdata->extension.input, ABS_HAT1Y, val[3]);\n\tinput_sync(wdata->extension.input);\n}\n\nstatic int wiimod_bboard_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_bboard_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic ssize_t wiimod_bboard_calib_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *out)\n{\n\tstruct wiimote_data *wdata = dev_to_wii(dev);\n\tint i, j, ret;\n\t__u16 val;\n\t__u8 buf[24], offs;\n\n\tret = wiimote_cmd_acquire(wdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wiimote_cmd_read(wdata, 0xa40024, buf, 12);\n\tif (ret != 12) {\n\t\twiimote_cmd_release(wdata);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\tret = wiimote_cmd_read(wdata, 0xa40024 + 12, buf + 12, 12);\n\tif (ret != 12) {\n\t\twiimote_cmd_release(wdata);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\twiimote_cmd_release(wdata);\n\n\tspin_lock_irq(&wdata->state.lock);\n\toffs = 0;\n\tfor (i = 0; i < 3; ++i) {\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\twdata->state.calib_bboard[j][i] = buf[offs];\n\t\t\twdata->state.calib_bboard[j][i] <<= 8;\n\t\t\twdata->state.calib_bboard[j][i] |= buf[offs + 1];\n\t\t\toffs += 2;\n\t\t}\n\t}\n\tspin_unlock_irq(&wdata->state.lock);\n\n\tret = 0;\n\tfor (i = 0; i < 3; ++i) {\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\tval = wdata->state.calib_bboard[j][i];\n\t\t\tif (i == 2 && j == 3)\n\t\t\t\tret += sprintf(&out[ret], \"%04x\\n\", val);\n\t\t\telse\n\t\t\t\tret += sprintf(&out[ret], \"%04x:\", val);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(bboard_calib, S_IRUGO, wiimod_bboard_calib_show, NULL);\n\nstatic int wiimod_bboard_probe(const struct wiimod_ops *ops,\n\t\t\t       struct wiimote_data *wdata)\n{\n\tint ret, i, j;\n\t__u8 buf[24], offs;\n\n\twiimote_cmd_acquire_noint(wdata);\n\n\tret = wiimote_cmd_read(wdata, 0xa40024, buf, 12);\n\tif (ret != 12) {\n\t\twiimote_cmd_release(wdata);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\tret = wiimote_cmd_read(wdata, 0xa40024 + 12, buf + 12, 12);\n\tif (ret != 12) {\n\t\twiimote_cmd_release(wdata);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\twiimote_cmd_release(wdata);\n\n\toffs = 0;\n\tfor (i = 0; i < 3; ++i) {\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\twdata->state.calib_bboard[j][i] = buf[offs];\n\t\t\twdata->state.calib_bboard[j][i] <<= 8;\n\t\t\twdata->state.calib_bboard[j][i] |= buf[offs + 1];\n\t\t\toffs += 2;\n\t\t}\n\t}\n\n\twdata->extension.input = input_allocate_device();\n\tif (!wdata->extension.input)\n\t\treturn -ENOMEM;\n\n\tret = device_create_file(&wdata->hdev->dev,\n\t\t\t\t &dev_attr_bboard_calib);\n\tif (ret) {\n\t\thid_err(wdata->hdev, \"cannot create sysfs attribute\\n\");\n\t\tgoto err_free;\n\t}\n\n\tinput_set_drvdata(wdata->extension.input, wdata);\n\twdata->extension.input->open = wiimod_bboard_open;\n\twdata->extension.input->close = wiimod_bboard_close;\n\twdata->extension.input->dev.parent = &wdata->hdev->dev;\n\twdata->extension.input->id.bustype = wdata->hdev->bus;\n\twdata->extension.input->id.vendor = wdata->hdev->vendor;\n\twdata->extension.input->id.product = wdata->hdev->product;\n\twdata->extension.input->id.version = wdata->hdev->version;\n\twdata->extension.input->name = WIIMOTE_NAME \" Balance Board\";\n\n\tset_bit(EV_KEY, wdata->extension.input->evbit);\n\tset_bit(BTN_A, wdata->extension.input->keybit);\n\n\tset_bit(EV_ABS, wdata->extension.input->evbit);\n\tset_bit(ABS_HAT0X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT0Y, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT1X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT1Y, wdata->extension.input->absbit);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT0X, 0, 65535, 2, 4);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT0Y, 0, 65535, 2, 4);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT1X, 0, 65535, 2, 4);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT1Y, 0, 65535, 2, 4);\n\n\tret = input_register_device(wdata->extension.input);\n\tif (ret)\n\t\tgoto err_file;\n\n\treturn 0;\n\nerr_file:\n\tdevice_remove_file(&wdata->hdev->dev,\n\t\t\t   &dev_attr_bboard_calib);\nerr_free:\n\tinput_free_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_bboard_remove(const struct wiimod_ops *ops,\n\t\t\t\t struct wiimote_data *wdata)\n{\n\tif (!wdata->extension.input)\n\t\treturn;\n\n\tinput_unregister_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\tdevice_remove_file(&wdata->hdev->dev,\n\t\t\t   &dev_attr_bboard_calib);\n}\n\nstatic const struct wiimod_ops wiimod_bboard = {\n\t.flags = WIIMOD_FLAG_EXT8,\n\t.arg = 0,\n\t.probe = wiimod_bboard_probe,\n\t.remove = wiimod_bboard_remove,\n\t.in_keys = wiimod_bboard_in_keys,\n\t.in_ext = wiimod_bboard_in_ext,\n};\n\n \n\nenum wiimod_pro_keys {\n\tWIIMOD_PRO_KEY_A,\n\tWIIMOD_PRO_KEY_B,\n\tWIIMOD_PRO_KEY_X,\n\tWIIMOD_PRO_KEY_Y,\n\tWIIMOD_PRO_KEY_PLUS,\n\tWIIMOD_PRO_KEY_MINUS,\n\tWIIMOD_PRO_KEY_HOME,\n\tWIIMOD_PRO_KEY_LEFT,\n\tWIIMOD_PRO_KEY_RIGHT,\n\tWIIMOD_PRO_KEY_UP,\n\tWIIMOD_PRO_KEY_DOWN,\n\tWIIMOD_PRO_KEY_TL,\n\tWIIMOD_PRO_KEY_TR,\n\tWIIMOD_PRO_KEY_ZL,\n\tWIIMOD_PRO_KEY_ZR,\n\tWIIMOD_PRO_KEY_THUMBL,\n\tWIIMOD_PRO_KEY_THUMBR,\n\tWIIMOD_PRO_KEY_NUM,\n};\n\nstatic const __u16 wiimod_pro_map[] = {\n\tBTN_EAST,\t \n\tBTN_SOUTH,\t \n\tBTN_NORTH,\t \n\tBTN_WEST,\t \n\tBTN_START,\t \n\tBTN_SELECT,\t \n\tBTN_MODE,\t \n\tBTN_DPAD_LEFT,\t \n\tBTN_DPAD_RIGHT,\t \n\tBTN_DPAD_UP,\t \n\tBTN_DPAD_DOWN,\t \n\tBTN_TL,\t\t \n\tBTN_TR,\t\t \n\tBTN_TL2,\t \n\tBTN_TR2,\t \n\tBTN_THUMBL,\t \n\tBTN_THUMBR,\t \n};\n\nstatic void wiimod_pro_in_ext(struct wiimote_data *wdata, const __u8 *ext)\n{\n\t__s16 rx, ry, lx, ly;\n\n\t \n\n\tlx = (ext[0] & 0xff) | ((ext[1] & 0x0f) << 8);\n\trx = (ext[2] & 0xff) | ((ext[3] & 0x0f) << 8);\n\tly = (ext[4] & 0xff) | ((ext[5] & 0x0f) << 8);\n\try = (ext[6] & 0xff) | ((ext[7] & 0x0f) << 8);\n\n\t \n\tlx -= 0x800;\n\tly = 0x800 - ly;\n\trx -= 0x800;\n\try = 0x800 - ry;\n\n\t \n\tif (!(wdata->state.flags & WIIPROTO_FLAG_PRO_CALIB_DONE)) {\n\t\twdata->state.flags |= WIIPROTO_FLAG_PRO_CALIB_DONE;\n\t\tif (abs(lx) < 500)\n\t\t\twdata->state.calib_pro_sticks[0] = -lx;\n\t\tif (abs(ly) < 500)\n\t\t\twdata->state.calib_pro_sticks[1] = -ly;\n\t\tif (abs(rx) < 500)\n\t\t\twdata->state.calib_pro_sticks[2] = -rx;\n\t\tif (abs(ry) < 500)\n\t\t\twdata->state.calib_pro_sticks[3] = -ry;\n\t}\n\n\t \n\tlx += wdata->state.calib_pro_sticks[0];\n\tly += wdata->state.calib_pro_sticks[1];\n\trx += wdata->state.calib_pro_sticks[2];\n\try += wdata->state.calib_pro_sticks[3];\n\n\tinput_report_abs(wdata->extension.input, ABS_X, lx);\n\tinput_report_abs(wdata->extension.input, ABS_Y, ly);\n\tinput_report_abs(wdata->extension.input, ABS_RX, rx);\n\tinput_report_abs(wdata->extension.input, ABS_RY, ry);\n\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_RIGHT],\n\t\t\t !(ext[8] & 0x80));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_DOWN],\n\t\t\t !(ext[8] & 0x40));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_TL],\n\t\t\t !(ext[8] & 0x20));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_MINUS],\n\t\t\t !(ext[8] & 0x10));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_HOME],\n\t\t\t !(ext[8] & 0x08));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_PLUS],\n\t\t\t !(ext[8] & 0x04));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_TR],\n\t\t\t !(ext[8] & 0x02));\n\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_ZL],\n\t\t\t !(ext[9] & 0x80));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_B],\n\t\t\t !(ext[9] & 0x40));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_Y],\n\t\t\t !(ext[9] & 0x20));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_A],\n\t\t\t !(ext[9] & 0x10));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_X],\n\t\t\t !(ext[9] & 0x08));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_ZR],\n\t\t\t !(ext[9] & 0x04));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_LEFT],\n\t\t\t !(ext[9] & 0x02));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_UP],\n\t\t\t !(ext[9] & 0x01));\n\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_THUMBL],\n\t\t\t !(ext[10] & 0x02));\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_pro_map[WIIMOD_PRO_KEY_THUMBR],\n\t\t\t !(ext[10] & 0x01));\n\n\tinput_sync(wdata->extension.input);\n}\n\nstatic int wiimod_pro_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_pro_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic int wiimod_pro_play(struct input_dev *dev, void *data,\n\t\t\t   struct ff_effect *eff)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\t__u8 value;\n\n\t \n\n\tif (eff->u.rumble.strong_magnitude || eff->u.rumble.weak_magnitude)\n\t\tvalue = 1;\n\telse\n\t\tvalue = 0;\n\n\t \n\twdata->state.cache_rumble = value;\n\tschedule_work(&wdata->rumble_worker);\n\n\treturn 0;\n}\n\nstatic ssize_t wiimod_pro_calib_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *out)\n{\n\tstruct wiimote_data *wdata = dev_to_wii(dev);\n\tint r;\n\n\tr = 0;\n\tr += sprintf(&out[r], \"%+06hd:\", wdata->state.calib_pro_sticks[0]);\n\tr += sprintf(&out[r], \"%+06hd \", wdata->state.calib_pro_sticks[1]);\n\tr += sprintf(&out[r], \"%+06hd:\", wdata->state.calib_pro_sticks[2]);\n\tr += sprintf(&out[r], \"%+06hd\\n\", wdata->state.calib_pro_sticks[3]);\n\n\treturn r;\n}\n\nstatic ssize_t wiimod_pro_calib_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct wiimote_data *wdata = dev_to_wii(dev);\n\tint r;\n\ts16 x1, y1, x2, y2;\n\n\tif (!strncmp(buf, \"scan\\n\", 5)) {\n\t\tspin_lock_irq(&wdata->state.lock);\n\t\twdata->state.flags &= ~WIIPROTO_FLAG_PRO_CALIB_DONE;\n\t\tspin_unlock_irq(&wdata->state.lock);\n\t} else {\n\t\tr = sscanf(buf, \"%hd:%hd %hd:%hd\", &x1, &y1, &x2, &y2);\n\t\tif (r != 4)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&wdata->state.lock);\n\t\twdata->state.flags |= WIIPROTO_FLAG_PRO_CALIB_DONE;\n\t\tspin_unlock_irq(&wdata->state.lock);\n\n\t\twdata->state.calib_pro_sticks[0] = x1;\n\t\twdata->state.calib_pro_sticks[1] = y1;\n\t\twdata->state.calib_pro_sticks[2] = x2;\n\t\twdata->state.calib_pro_sticks[3] = y2;\n\t}\n\n\treturn strnlen(buf, PAGE_SIZE);\n}\n\nstatic DEVICE_ATTR(pro_calib, S_IRUGO|S_IWUSR|S_IWGRP, wiimod_pro_calib_show,\n\t\t   wiimod_pro_calib_store);\n\nstatic int wiimod_pro_probe(const struct wiimod_ops *ops,\n\t\t\t    struct wiimote_data *wdata)\n{\n\tint ret, i;\n\tunsigned long flags;\n\n\tINIT_WORK(&wdata->rumble_worker, wiimod_rumble_worker);\n\twdata->state.calib_pro_sticks[0] = 0;\n\twdata->state.calib_pro_sticks[1] = 0;\n\twdata->state.calib_pro_sticks[2] = 0;\n\twdata->state.calib_pro_sticks[3] = 0;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_PRO_CALIB_DONE;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\twdata->extension.input = input_allocate_device();\n\tif (!wdata->extension.input)\n\t\treturn -ENOMEM;\n\n\tset_bit(FF_RUMBLE, wdata->extension.input->ffbit);\n\tinput_set_drvdata(wdata->extension.input, wdata);\n\n\tif (input_ff_create_memless(wdata->extension.input, NULL,\n\t\t\t\t    wiimod_pro_play)) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tret = device_create_file(&wdata->hdev->dev,\n\t\t\t\t &dev_attr_pro_calib);\n\tif (ret) {\n\t\thid_err(wdata->hdev, \"cannot create sysfs attribute\\n\");\n\t\tgoto err_free;\n\t}\n\n\twdata->extension.input->open = wiimod_pro_open;\n\twdata->extension.input->close = wiimod_pro_close;\n\twdata->extension.input->dev.parent = &wdata->hdev->dev;\n\twdata->extension.input->id.bustype = wdata->hdev->bus;\n\twdata->extension.input->id.vendor = wdata->hdev->vendor;\n\twdata->extension.input->id.product = wdata->hdev->product;\n\twdata->extension.input->id.version = wdata->hdev->version;\n\twdata->extension.input->name = WIIMOTE_NAME \" Pro Controller\";\n\n\tset_bit(EV_KEY, wdata->extension.input->evbit);\n\tfor (i = 0; i < WIIMOD_PRO_KEY_NUM; ++i)\n\t\tset_bit(wiimod_pro_map[i],\n\t\t\twdata->extension.input->keybit);\n\n\tset_bit(EV_ABS, wdata->extension.input->evbit);\n\tset_bit(ABS_X, wdata->extension.input->absbit);\n\tset_bit(ABS_Y, wdata->extension.input->absbit);\n\tset_bit(ABS_RX, wdata->extension.input->absbit);\n\tset_bit(ABS_RY, wdata->extension.input->absbit);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_X, -0x400, 0x400, 4, 100);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_Y, -0x400, 0x400, 4, 100);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_RX, -0x400, 0x400, 4, 100);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_RY, -0x400, 0x400, 4, 100);\n\n\tret = input_register_device(wdata->extension.input);\n\tif (ret)\n\t\tgoto err_file;\n\n\treturn 0;\n\nerr_file:\n\tdevice_remove_file(&wdata->hdev->dev,\n\t\t\t   &dev_attr_pro_calib);\nerr_free:\n\tinput_free_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_pro_remove(const struct wiimod_ops *ops,\n\t\t\t      struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\n\tif (!wdata->extension.input)\n\t\treturn;\n\n\tinput_unregister_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\tcancel_work_sync(&wdata->rumble_worker);\n\tdevice_remove_file(&wdata->hdev->dev,\n\t\t\t   &dev_attr_pro_calib);\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twiiproto_req_rumble(wdata, 0);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic const struct wiimod_ops wiimod_pro = {\n\t.flags = WIIMOD_FLAG_EXT16,\n\t.arg = 0,\n\t.probe = wiimod_pro_probe,\n\t.remove = wiimod_pro_remove,\n\t.in_ext = wiimod_pro_in_ext,\n};\n\n \n\nstatic inline void wiimod_drums_report_pressure(struct wiimote_data *wdata,\n\t\t\t\t\t\t__u8 none, __u8 which,\n\t\t\t\t\t\t__u8 pressure, __u8 onoff,\n\t\t\t\t\t\t__u8 *store, __u16 code,\n\t\t\t\t\t\t__u8 which_code)\n{\n\tstatic const __u8 default_pressure = 3;\n\n\tif (!none && which == which_code) {\n\t\t*store = pressure;\n\t\tinput_report_abs(wdata->extension.input, code, *store);\n\t} else if (onoff != !!*store) {\n\t\t*store = onoff ? default_pressure : 0;\n\t\tinput_report_abs(wdata->extension.input, code, *store);\n\t}\n}\n\nstatic void wiimod_drums_in_ext(struct wiimote_data *wdata, const __u8 *ext)\n{\n\t__u8 pressure, which, none, hhp, sx, sy;\n\t__u8 o, r, y, g, b, bass, bm, bp;\n\n\t \n\n\tpressure = 7 - (ext[3] >> 5);\n\twhich = (ext[2] >> 1) & 0x1f;\n\tnone = !!(ext[2] & 0x40);\n\thhp = !(ext[2] & 0x80);\n\tsx = ext[0] & 0x3f;\n\tsy = ext[1] & 0x3f;\n\to = !(ext[5] & 0x80);\n\tr = !(ext[5] & 0x40);\n\ty = !(ext[5] & 0x20);\n\tg = !(ext[5] & 0x10);\n\tb = !(ext[5] & 0x08);\n\tbass = !(ext[5] & 0x04);\n\tbm = !(ext[4] & 0x10);\n\tbp = !(ext[4] & 0x04);\n\n\tif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\n\t\tsx &= 0x3e;\n\t\tsy &= 0x3e;\n\t}\n\n\twiimod_drums_report_pressure(wdata, none, which, pressure,\n\t\t\t\t     o, &wdata->state.pressure_drums[0],\n\t\t\t\t     ABS_HAT2Y, 0x0e);\n\twiimod_drums_report_pressure(wdata, none, which, pressure,\n\t\t\t\t     r, &wdata->state.pressure_drums[1],\n\t\t\t\t     ABS_HAT0X, 0x19);\n\twiimod_drums_report_pressure(wdata, none, which, pressure,\n\t\t\t\t     y, &wdata->state.pressure_drums[2],\n\t\t\t\t     ABS_HAT2X, 0x11);\n\twiimod_drums_report_pressure(wdata, none, which, pressure,\n\t\t\t\t     g, &wdata->state.pressure_drums[3],\n\t\t\t\t     ABS_HAT1X, 0x12);\n\twiimod_drums_report_pressure(wdata, none, which, pressure,\n\t\t\t\t     b, &wdata->state.pressure_drums[4],\n\t\t\t\t     ABS_HAT0Y, 0x0f);\n\n\t \n\twiimod_drums_report_pressure(wdata, none, hhp ? 0xff : which, pressure,\n\t\t\t\t     bass, &wdata->state.pressure_drums[5],\n\t\t\t\t     ABS_HAT3X, 0x1b);\n\t \n\twiimod_drums_report_pressure(wdata, none, hhp ? which : 0xff, pressure,\n\t\t\t\t     0, &wdata->state.pressure_drums[6],\n\t\t\t\t     ABS_HAT3Y, 0x0e);\n\n\tinput_report_abs(wdata->extension.input, ABS_X, sx - 0x20);\n\tinput_report_abs(wdata->extension.input, ABS_Y, sy - 0x20);\n\n\tinput_report_key(wdata->extension.input, BTN_START, bp);\n\tinput_report_key(wdata->extension.input, BTN_SELECT, bm);\n\n\tinput_sync(wdata->extension.input);\n}\n\nstatic int wiimod_drums_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_drums_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic int wiimod_drums_probe(const struct wiimod_ops *ops,\n\t\t\t      struct wiimote_data *wdata)\n{\n\tint ret;\n\n\twdata->extension.input = input_allocate_device();\n\tif (!wdata->extension.input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(wdata->extension.input, wdata);\n\twdata->extension.input->open = wiimod_drums_open;\n\twdata->extension.input->close = wiimod_drums_close;\n\twdata->extension.input->dev.parent = &wdata->hdev->dev;\n\twdata->extension.input->id.bustype = wdata->hdev->bus;\n\twdata->extension.input->id.vendor = wdata->hdev->vendor;\n\twdata->extension.input->id.product = wdata->hdev->product;\n\twdata->extension.input->id.version = wdata->hdev->version;\n\twdata->extension.input->name = WIIMOTE_NAME \" Drums\";\n\n\tset_bit(EV_KEY, wdata->extension.input->evbit);\n\tset_bit(BTN_START, wdata->extension.input->keybit);\n\tset_bit(BTN_SELECT, wdata->extension.input->keybit);\n\n\tset_bit(EV_ABS, wdata->extension.input->evbit);\n\tset_bit(ABS_X, wdata->extension.input->absbit);\n\tset_bit(ABS_Y, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT0X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT0Y, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT1X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT2X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT2Y, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT3X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT3Y, wdata->extension.input->absbit);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_X, -32, 31, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_Y, -32, 31, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT0X, 0, 7, 0, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT0Y, 0, 7, 0, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT1X, 0, 7, 0, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT2X, 0, 7, 0, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT2Y, 0, 7, 0, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT3X, 0, 7, 0, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT3Y, 0, 7, 0, 0);\n\n\tret = input_register_device(wdata->extension.input);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tinput_free_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_drums_remove(const struct wiimod_ops *ops,\n\t\t\t\tstruct wiimote_data *wdata)\n{\n\tif (!wdata->extension.input)\n\t\treturn;\n\n\tinput_unregister_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_drums = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_drums_probe,\n\t.remove = wiimod_drums_remove,\n\t.in_ext = wiimod_drums_in_ext,\n};\n\n \n\nenum wiimod_guitar_keys {\n\tWIIMOD_GUITAR_KEY_G,\n\tWIIMOD_GUITAR_KEY_R,\n\tWIIMOD_GUITAR_KEY_Y,\n\tWIIMOD_GUITAR_KEY_B,\n\tWIIMOD_GUITAR_KEY_O,\n\tWIIMOD_GUITAR_KEY_UP,\n\tWIIMOD_GUITAR_KEY_DOWN,\n\tWIIMOD_GUITAR_KEY_PLUS,\n\tWIIMOD_GUITAR_KEY_MINUS,\n\tWIIMOD_GUITAR_KEY_NUM,\n};\n\nstatic const __u16 wiimod_guitar_map[] = {\n\tBTN_1,\t\t\t \n\tBTN_2,\t\t\t \n\tBTN_3,\t\t\t \n\tBTN_4,\t\t\t \n\tBTN_5,\t\t\t \n\tBTN_DPAD_UP,\t\t \n\tBTN_DPAD_DOWN,\t\t \n\tBTN_START,\t\t \n\tBTN_SELECT,\t\t \n};\n\nstatic void wiimod_guitar_in_ext(struct wiimote_data *wdata, const __u8 *ext)\n{\n\t__u8 sx, sy, tb, wb, bd, bm, bp, bo, br, bb, bg, by, bu;\n\n\t \n\n\tsx = ext[0] & 0x3f;\n\tsy = ext[1] & 0x3f;\n\ttb = ext[2] & 0x1f;\n\twb = ext[3] & 0x1f;\n\tbd = !(ext[4] & 0x40);\n\tbm = !(ext[4] & 0x10);\n\tbp = !(ext[4] & 0x04);\n\tbo = !(ext[5] & 0x80);\n\tbr = !(ext[5] & 0x40);\n\tbb = !(ext[5] & 0x20);\n\tbg = !(ext[5] & 0x10);\n\tby = !(ext[5] & 0x08);\n\tbu = !(ext[5] & 0x01);\n\n\tif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\n\t\tbu = !(ext[0] & 0x01);\n\t\tsx &= 0x3e;\n\t\tsy &= 0x3e;\n\t}\n\n\tinput_report_abs(wdata->extension.input, ABS_X, sx - 0x20);\n\tinput_report_abs(wdata->extension.input, ABS_Y, sy - 0x20);\n\tinput_report_abs(wdata->extension.input, ABS_HAT0X, tb);\n\tinput_report_abs(wdata->extension.input, ABS_HAT1X, wb - 0x10);\n\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_G],\n\t\t\t bg);\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_R],\n\t\t\t br);\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_Y],\n\t\t\t by);\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_B],\n\t\t\t bb);\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_O],\n\t\t\t bo);\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_UP],\n\t\t\t bu);\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_DOWN],\n\t\t\t bd);\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_PLUS],\n\t\t\t bp);\n\tinput_report_key(wdata->extension.input,\n\t\t\t wiimod_guitar_map[WIIMOD_GUITAR_KEY_MINUS],\n\t\t\t bm);\n\n\tinput_sync(wdata->extension.input);\n}\n\nstatic int wiimod_guitar_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_guitar_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic int wiimod_guitar_probe(const struct wiimod_ops *ops,\n\t\t\t       struct wiimote_data *wdata)\n{\n\tint ret, i;\n\n\twdata->extension.input = input_allocate_device();\n\tif (!wdata->extension.input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(wdata->extension.input, wdata);\n\twdata->extension.input->open = wiimod_guitar_open;\n\twdata->extension.input->close = wiimod_guitar_close;\n\twdata->extension.input->dev.parent = &wdata->hdev->dev;\n\twdata->extension.input->id.bustype = wdata->hdev->bus;\n\twdata->extension.input->id.vendor = wdata->hdev->vendor;\n\twdata->extension.input->id.product = wdata->hdev->product;\n\twdata->extension.input->id.version = wdata->hdev->version;\n\twdata->extension.input->name = WIIMOTE_NAME \" Guitar\";\n\n\tset_bit(EV_KEY, wdata->extension.input->evbit);\n\tfor (i = 0; i < WIIMOD_GUITAR_KEY_NUM; ++i)\n\t\tset_bit(wiimod_guitar_map[i],\n\t\t\twdata->extension.input->keybit);\n\n\tset_bit(EV_ABS, wdata->extension.input->evbit);\n\tset_bit(ABS_X, wdata->extension.input->absbit);\n\tset_bit(ABS_Y, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT0X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT1X, wdata->extension.input->absbit);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_X, -32, 31, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_Y, -32, 31, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT0X, 0, 0x1f, 1, 1);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT1X, 0, 0x0f, 1, 1);\n\n\tret = input_register_device(wdata->extension.input);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tinput_free_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_guitar_remove(const struct wiimod_ops *ops,\n\t\t\t\t struct wiimote_data *wdata)\n{\n\tif (!wdata->extension.input)\n\t\treturn;\n\n\tinput_unregister_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_guitar = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_guitar_probe,\n\t.remove = wiimod_guitar_remove,\n\t.in_ext = wiimod_guitar_in_ext,\n};\n\n \n\nenum wiimod_turntable_keys {\n\tWIIMOD_TURNTABLE_KEY_G_RIGHT,\n\tWIIMOD_TURNTABLE_KEY_R_RIGHT,\n\tWIIMOD_TURNTABLE_KEY_B_RIGHT,\n\tWIIMOD_TURNTABLE_KEY_G_LEFT,\n\tWIIMOD_TURNTABLE_KEY_R_LEFT,\n\tWIIMOD_TURNTABLE_KEY_B_LEFT,\n\tWIIMOD_TURNTABLE_KEY_EUPHORIA,\n\tWIIMOD_TURNTABLE_KEY_PLUS,\n\tWIIMOD_TURNTABLE_KEY_MINUS,\n\tWIIMOD_TURNTABLE_KEY_NUM\n};\n\nstatic const __u16 wiimod_turntable_map[] = {\n\tBTN_1,\t\t\t \n\tBTN_2,\t\t\t \n\tBTN_3,\t\t\t \n\tBTN_4,\t\t\t \n\tBTN_5,\t\t\t \n\tBTN_6,\t\t\t \n\tBTN_7,\t\t\t \n\tBTN_START,\t\t \n\tBTN_SELECT,\t\t \n};\n\nstatic void wiimod_turntable_in_ext(struct wiimote_data *wdata, const __u8 *ext)\n{\n\t__u8 be, cs, sx, sy, ed, rtt, rbg, rbr, rbb, ltt, lbg, lbr, lbb, bp, bm;\n\t \n\t\n\tbe = !(ext[5] & 0x10); \n\tcs = ((ext[2] & 0x1e));\n\tsx = ext[0] & 0x3f;\n\tsy = ext[1] & 0x3f;\n\ted = (ext[3] & 0xe0) >> 5;\n\trtt = ((ext[2] & 0x01) << 5 | (ext[0] & 0xc0) >> 3 | (ext[1] & 0xc0) >> 5 | ( ext[2] & 0x80 ) >> 7);\n\tltt = ((ext[4] & 0x01) << 5 | (ext[3] & 0x1f));\n\trbg = !(ext[5] & 0x20);\n\trbr = !(ext[4] & 0x02);\n\trbb = !(ext[5] & 0x04);\n\tlbg = !(ext[5] & 0x08);\n\tlbb = !(ext[5] & 0x80);\n\tlbr = !(ext[4] & 0x20);\n\tbm =  !(ext[4] & 0x10);\n\tbp =  !(ext[4] & 0x04);\n\n\tif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\n\t\tltt = (ext[4] & 0x01) << 5;\n\t\tsx &= 0x3e;\n\t\tsy &= 0x3e;\n\t}\n\n\tinput_report_abs(wdata->extension.input, ABS_X, sx);\n\tinput_report_abs(wdata->extension.input, ABS_Y, sy);\n\tinput_report_abs(wdata->extension.input, ABS_HAT0X, rtt);\n\tinput_report_abs(wdata->extension.input, ABS_HAT1X, ltt);\n\tinput_report_abs(wdata->extension.input, ABS_HAT2X, cs);\n\tinput_report_abs(wdata->extension.input, ABS_HAT3X, ed);\n\tinput_report_key(wdata->extension.input, \n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_G_RIGHT], \n\t\t\t\t\trbg);\n\tinput_report_key(wdata->extension.input,\n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_R_RIGHT],\n\t\t\t\t\trbr);\n\tinput_report_key(wdata->extension.input, \n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_B_RIGHT], \n\t\t\t\t\trbb);\n\tinput_report_key(wdata->extension.input, \n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_G_LEFT], \n\t\t\t\t\tlbg);\n\tinput_report_key(wdata->extension.input, \n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_R_LEFT], \n\t\t\t\t\tlbr);\n\tinput_report_key(wdata->extension.input, \n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_B_LEFT], \n\t\t\t\t\tlbb);\n\tinput_report_key(wdata->extension.input, \n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_EUPHORIA], \n\t\t\t\t\tbe);\n\tinput_report_key(wdata->extension.input, \n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_PLUS], \n\t\t\t\t\tbp);\n\tinput_report_key(wdata->extension.input, \n\t\t\t\t\twiimod_turntable_map[WIIMOD_TURNTABLE_KEY_MINUS], \n\t\t\t\t\tbm);\n\n\tinput_sync(wdata->extension.input);\n}\n\nstatic int wiimod_turntable_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_turntable_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic int wiimod_turntable_probe(const struct wiimod_ops *ops,\n\t\t\t       struct wiimote_data *wdata)\n{\n \tint ret, i;\n\n\twdata->extension.input = input_allocate_device();\n\tif (!wdata->extension.input)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(wdata->extension.input, wdata);\n\twdata->extension.input->open = wiimod_turntable_open;\n\twdata->extension.input->close = wiimod_turntable_close;\n\twdata->extension.input->dev.parent = &wdata->hdev->dev;\n\twdata->extension.input->id.bustype = wdata->hdev->bus;\n\twdata->extension.input->id.vendor = wdata->hdev->vendor;\n\twdata->extension.input->id.product = wdata->hdev->product;\n\twdata->extension.input->id.version = wdata->hdev->version;\n\twdata->extension.input->name = WIIMOTE_NAME \" Turntable\";\n\n\tset_bit(EV_KEY, wdata->extension.input->evbit);\n\tfor (i = 0; i < WIIMOD_TURNTABLE_KEY_NUM; ++i)\n\t\tset_bit(wiimod_turntable_map[i],\n\t\t\twdata->extension.input->keybit);\n\n\tset_bit(EV_ABS, wdata->extension.input->evbit);\n\tset_bit(ABS_X, wdata->extension.input->absbit);\n\tset_bit(ABS_Y, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT0X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT1X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT2X, wdata->extension.input->absbit);\n\tset_bit(ABS_HAT3X, wdata->extension.input->absbit);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_X, 0, 63, 1, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_Y, 63, 0, 1, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT0X, -8, 8, 0, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT1X, -8, 8, 0, 0);\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT2X, 0, 31, 1, 1);\t\n\tinput_set_abs_params(wdata->extension.input,\n\t\t\t     ABS_HAT3X, 0, 7, 0, 0);\t \n\tret = input_register_device(wdata->extension.input);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tinput_free_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_turntable_remove(const struct wiimod_ops *ops,\n\t\t\t\t struct wiimote_data *wdata)\n{\n\tif (!wdata->extension.input)\n\t\treturn;\n\n\tinput_unregister_device(wdata->extension.input);\n\twdata->extension.input = NULL;\n}\n\nstatic const struct wiimod_ops wiimod_turntable = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_turntable_probe,\n\t.remove = wiimod_turntable_remove,\n\t.in_ext = wiimod_turntable_in_ext,\n};\n\n \n\nstatic int wiimod_builtin_mp_probe(const struct wiimod_ops *ops,\n\t\t\t\t   struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_BUILTIN_MP;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_builtin_mp_remove(const struct wiimod_ops *ops,\n\t\t\t\t     struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_BUILTIN_MP;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic const struct wiimod_ops wiimod_builtin_mp = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_builtin_mp_probe,\n\t.remove = wiimod_builtin_mp_remove,\n};\n\n \n\nstatic int wiimod_no_mp_probe(const struct wiimod_ops *ops,\n\t\t\t      struct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_NO_MP;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_no_mp_remove(const struct wiimod_ops *ops,\n\t\t\t\tstruct wiimote_data *wdata)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_NO_MP;\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic const struct wiimod_ops wiimod_no_mp = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_no_mp_probe,\n\t.remove = wiimod_no_mp_remove,\n};\n\n \n\nstatic void wiimod_mp_in_mp(struct wiimote_data *wdata, const __u8 *ext)\n{\n\t__s32 x, y, z;\n\n\t \n\n\tx = ext[0];\n\ty = ext[1];\n\tz = ext[2];\n\n\tx |= (((__u16)ext[3]) << 6) & 0xff00;\n\ty |= (((__u16)ext[4]) << 6) & 0xff00;\n\tz |= (((__u16)ext[5]) << 6) & 0xff00;\n\n\tx -= 8192;\n\ty -= 8192;\n\tz -= 8192;\n\n\tif (!(ext[3] & 0x02))\n\t\tx = (x * 2000 * 9) / 440;\n\telse\n\t\tx *= 9;\n\tif (!(ext[4] & 0x02))\n\t\ty = (y * 2000 * 9) / 440;\n\telse\n\t\ty *= 9;\n\tif (!(ext[3] & 0x01))\n\t\tz = (z * 2000 * 9) / 440;\n\telse\n\t\tz *= 9;\n\n\tinput_report_abs(wdata->mp, ABS_RX, x);\n\tinput_report_abs(wdata->mp, ABS_RY, y);\n\tinput_report_abs(wdata->mp, ABS_RZ, z);\n\tinput_sync(wdata->mp);\n}\n\nstatic int wiimod_mp_open(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags |= WIIPROTO_FLAG_MP_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\t__wiimote_schedule(wdata);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n\n\treturn 0;\n}\n\nstatic void wiimod_mp_close(struct input_dev *dev)\n{\n\tstruct wiimote_data *wdata = input_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdata->state.lock, flags);\n\twdata->state.flags &= ~WIIPROTO_FLAG_MP_USED;\n\twiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\n\t__wiimote_schedule(wdata);\n\tspin_unlock_irqrestore(&wdata->state.lock, flags);\n}\n\nstatic int wiimod_mp_probe(const struct wiimod_ops *ops,\n\t\t\t   struct wiimote_data *wdata)\n{\n\tint ret;\n\n\twdata->mp = input_allocate_device();\n\tif (!wdata->mp)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(wdata->mp, wdata);\n\twdata->mp->open = wiimod_mp_open;\n\twdata->mp->close = wiimod_mp_close;\n\twdata->mp->dev.parent = &wdata->hdev->dev;\n\twdata->mp->id.bustype = wdata->hdev->bus;\n\twdata->mp->id.vendor = wdata->hdev->vendor;\n\twdata->mp->id.product = wdata->hdev->product;\n\twdata->mp->id.version = wdata->hdev->version;\n\twdata->mp->name = WIIMOTE_NAME \" Motion Plus\";\n\n\tset_bit(EV_ABS, wdata->mp->evbit);\n\tset_bit(ABS_RX, wdata->mp->absbit);\n\tset_bit(ABS_RY, wdata->mp->absbit);\n\tset_bit(ABS_RZ, wdata->mp->absbit);\n\tinput_set_abs_params(wdata->mp,\n\t\t\t     ABS_RX, -16000, 16000, 4, 8);\n\tinput_set_abs_params(wdata->mp,\n\t\t\t     ABS_RY, -16000, 16000, 4, 8);\n\tinput_set_abs_params(wdata->mp,\n\t\t\t     ABS_RZ, -16000, 16000, 4, 8);\n\n\tret = input_register_device(wdata->mp);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tinput_free_device(wdata->mp);\n\twdata->mp = NULL;\n\treturn ret;\n}\n\nstatic void wiimod_mp_remove(const struct wiimod_ops *ops,\n\t\t\t     struct wiimote_data *wdata)\n{\n\tif (!wdata->mp)\n\t\treturn;\n\n\tinput_unregister_device(wdata->mp);\n\twdata->mp = NULL;\n}\n\nconst struct wiimod_ops wiimod_mp = {\n\t.flags = 0,\n\t.arg = 0,\n\t.probe = wiimod_mp_probe,\n\t.remove = wiimod_mp_remove,\n\t.in_mp = wiimod_mp_in_mp,\n};\n\n \n\nstatic const struct wiimod_ops wiimod_dummy;\n\nconst struct wiimod_ops *wiimod_table[WIIMOD_NUM] = {\n\t[WIIMOD_KEYS] = &wiimod_keys,\n\t[WIIMOD_RUMBLE] = &wiimod_rumble,\n\t[WIIMOD_BATTERY] = &wiimod_battery,\n\t[WIIMOD_LED1] = &wiimod_leds[0],\n\t[WIIMOD_LED2] = &wiimod_leds[1],\n\t[WIIMOD_LED3] = &wiimod_leds[2],\n\t[WIIMOD_LED4] = &wiimod_leds[3],\n\t[WIIMOD_ACCEL] = &wiimod_accel,\n\t[WIIMOD_IR] = &wiimod_ir,\n\t[WIIMOD_BUILTIN_MP] = &wiimod_builtin_mp,\n\t[WIIMOD_NO_MP] = &wiimod_no_mp,\n};\n\nconst struct wiimod_ops *wiimod_ext_table[WIIMOTE_EXT_NUM] = {\n\t[WIIMOTE_EXT_NONE] = &wiimod_dummy,\n\t[WIIMOTE_EXT_UNKNOWN] = &wiimod_dummy,\n\t[WIIMOTE_EXT_NUNCHUK] = &wiimod_nunchuk,\n\t[WIIMOTE_EXT_CLASSIC_CONTROLLER] = &wiimod_classic,\n\t[WIIMOTE_EXT_BALANCE_BOARD] = &wiimod_bboard,\n\t[WIIMOTE_EXT_PRO_CONTROLLER] = &wiimod_pro,\n\t[WIIMOTE_EXT_DRUMS] = &wiimod_drums,\n\t[WIIMOTE_EXT_GUITAR] = &wiimod_guitar,\n\t[WIIMOTE_EXT_TURNTABLE] = &wiimod_turntable,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}