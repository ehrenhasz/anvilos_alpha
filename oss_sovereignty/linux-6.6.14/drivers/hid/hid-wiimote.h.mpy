{
  "module_name": "hid-wiimote.h",
  "hash_id": "99fe000f6752ef06c61936bc50cfd8fc232f65f7c67a1d21e63f52ddac0837cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-wiimote.h",
  "human_readable_source": " \n#ifndef __HID_WIIMOTE_H\n#define __HID_WIIMOTE_H\n\n \n\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/input.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/power_supply.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n\n#define WIIMOTE_NAME \"Nintendo Wii Remote\"\n#define WIIMOTE_BUFSIZE 32\n\n#define WIIPROTO_FLAG_LED1\t\t0x01\n#define WIIPROTO_FLAG_LED2\t\t0x02\n#define WIIPROTO_FLAG_LED3\t\t0x04\n#define WIIPROTO_FLAG_LED4\t\t0x08\n#define WIIPROTO_FLAG_RUMBLE\t\t0x10\n#define WIIPROTO_FLAG_ACCEL\t\t0x20\n#define WIIPROTO_FLAG_IR_BASIC\t\t0x40\n#define WIIPROTO_FLAG_IR_EXT\t\t0x80\n#define WIIPROTO_FLAG_IR_FULL\t\t0xc0  \n#define WIIPROTO_FLAG_EXT_PLUGGED\t0x0100\n#define WIIPROTO_FLAG_EXT_USED\t\t0x0200\n#define WIIPROTO_FLAG_EXT_ACTIVE\t0x0400\n#define WIIPROTO_FLAG_MP_PLUGGED\t0x0800\n#define WIIPROTO_FLAG_MP_USED\t\t0x1000\n#define WIIPROTO_FLAG_MP_ACTIVE\t\t0x2000\n#define WIIPROTO_FLAG_EXITING\t\t0x4000\n#define WIIPROTO_FLAG_DRM_LOCKED\t0x8000\n#define WIIPROTO_FLAG_BUILTIN_MP\t0x010000\n#define WIIPROTO_FLAG_NO_MP\t\t0x020000\n#define WIIPROTO_FLAG_PRO_CALIB_DONE\t0x040000\n\n#define WIIPROTO_FLAGS_LEDS (WIIPROTO_FLAG_LED1 | WIIPROTO_FLAG_LED2 | \\\n\t\t\t\t\tWIIPROTO_FLAG_LED3 | WIIPROTO_FLAG_LED4)\n#define WIIPROTO_FLAGS_IR (WIIPROTO_FLAG_IR_BASIC | WIIPROTO_FLAG_IR_EXT | \\\n\t\t\t\t\t\t\tWIIPROTO_FLAG_IR_FULL)\n\n \n#define WIIPROTO_FLAG_LED(num) (WIIPROTO_FLAG_LED1 << (num - 1))\n\nenum wiiproto_keys {\n\tWIIPROTO_KEY_LEFT,\n\tWIIPROTO_KEY_RIGHT,\n\tWIIPROTO_KEY_UP,\n\tWIIPROTO_KEY_DOWN,\n\tWIIPROTO_KEY_PLUS,\n\tWIIPROTO_KEY_MINUS,\n\tWIIPROTO_KEY_ONE,\n\tWIIPROTO_KEY_TWO,\n\tWIIPROTO_KEY_A,\n\tWIIPROTO_KEY_B,\n\tWIIPROTO_KEY_HOME,\n\tWIIPROTO_KEY_COUNT\n};\n\nenum wiimote_devtype {\n\tWIIMOTE_DEV_PENDING,\n\tWIIMOTE_DEV_UNKNOWN,\n\tWIIMOTE_DEV_GENERIC,\n\tWIIMOTE_DEV_GEN10,\n\tWIIMOTE_DEV_GEN20,\n\tWIIMOTE_DEV_BALANCE_BOARD,\n\tWIIMOTE_DEV_PRO_CONTROLLER,\n\tWIIMOTE_DEV_NUM,\n};\n\nenum wiimote_exttype {\n\tWIIMOTE_EXT_NONE,\n\tWIIMOTE_EXT_UNKNOWN,\n\tWIIMOTE_EXT_NUNCHUK,\n\tWIIMOTE_EXT_CLASSIC_CONTROLLER,\n\tWIIMOTE_EXT_BALANCE_BOARD,\n\tWIIMOTE_EXT_PRO_CONTROLLER,\n\tWIIMOTE_EXT_DRUMS,\n\tWIIMOTE_EXT_GUITAR,\n\tWIIMOTE_EXT_TURNTABLE,\n\tWIIMOTE_EXT_NUM,\n};\n\nenum wiimote_mptype {\n\tWIIMOTE_MP_NONE,\n\tWIIMOTE_MP_UNKNOWN,\n\tWIIMOTE_MP_SINGLE,\n\tWIIMOTE_MP_PASSTHROUGH_NUNCHUK,\n\tWIIMOTE_MP_PASSTHROUGH_CLASSIC,\n};\n\nstruct wiimote_buf {\n\t__u8 data[HID_MAX_BUFFER_SIZE];\n\tsize_t size;\n};\n\nstruct wiimote_queue {\n\tspinlock_t lock;\n\tstruct work_struct worker;\n\t__u8 head;\n\t__u8 tail;\n\tstruct wiimote_buf outq[WIIMOTE_BUFSIZE];\n};\n\nstruct wiimote_state {\n\tspinlock_t lock;\n\t__u32 flags;\n\t__u8 accel_split[2];\n\t__u8 drm;\n\t__u8 devtype;\n\t__u8 exttype;\n\t__u8 mp;\n\n\t \n\tstruct mutex sync;\n\tstruct completion ready;\n\tint cmd;\n\t__u32 opt;\n\n\t \n\t__u8 cmd_battery;\n\t__u8 cmd_err;\n\t__u8 *cmd_read_buf;\n\t__u8 cmd_read_size;\n\n\t \n\t__u16 calib_bboard[4][3];\n\t__s16 calib_pro_sticks[4];\n\t__u8 pressure_drums[7];\n\t__u8 cache_rumble;\n};\n\nstruct wiimote_data {\n\tstruct hid_device *hdev;\n\tstruct input_dev *input;\n\tstruct work_struct rumble_worker;\n\tstruct led_classdev *leds[4];\n\tstruct input_dev *accel;\n\tstruct input_dev *ir;\n\tstruct power_supply *battery;\n\tstruct power_supply_desc battery_desc;\n\tstruct input_dev *mp;\n\tstruct timer_list timer;\n\tstruct wiimote_debug *debug;\n\n\tunion {\n\t\tstruct input_dev *input;\n\t} extension;\n\n\tstruct wiimote_queue queue;\n\tstruct wiimote_state state;\n\tstruct work_struct init_worker;\n};\n\nextern bool wiimote_dpad_as_analog;\n\n \n\nenum wiimod_module {\n\tWIIMOD_KEYS,\n\tWIIMOD_RUMBLE,\n\tWIIMOD_BATTERY,\n\tWIIMOD_LED1,\n\tWIIMOD_LED2,\n\tWIIMOD_LED3,\n\tWIIMOD_LED4,\n\tWIIMOD_ACCEL,\n\tWIIMOD_IR,\n\tWIIMOD_BUILTIN_MP,\n\tWIIMOD_NO_MP,\n\tWIIMOD_NUM,\n\tWIIMOD_NULL = WIIMOD_NUM,\n};\n\n#define WIIMOD_FLAG_INPUT\t\t0x0001\n#define WIIMOD_FLAG_EXT8\t\t0x0002\n#define WIIMOD_FLAG_EXT16\t\t0x0004\n\nstruct wiimod_ops {\n\t__u16 flags;\n\tunsigned long arg;\n\tint (*probe) (const struct wiimod_ops *ops,\n\t\t      struct wiimote_data *wdata);\n\tvoid (*remove) (const struct wiimod_ops *ops,\n\t\t\tstruct wiimote_data *wdata);\n\n\tvoid (*in_keys) (struct wiimote_data *wdata, const __u8 *keys);\n\tvoid (*in_accel) (struct wiimote_data *wdata, const __u8 *accel);\n\tvoid (*in_ir) (struct wiimote_data *wdata, const __u8 *ir, bool packed,\n\t\t       unsigned int id);\n\tvoid (*in_mp) (struct wiimote_data *wdata, const __u8 *mp);\n\tvoid (*in_ext) (struct wiimote_data *wdata, const __u8 *ext);\n};\n\nextern const struct wiimod_ops *wiimod_table[WIIMOD_NUM];\nextern const struct wiimod_ops *wiimod_ext_table[WIIMOTE_EXT_NUM];\nextern const struct wiimod_ops wiimod_mp;\n\n \n\nenum wiiproto_reqs {\n\tWIIPROTO_REQ_NULL = 0x0,\n\tWIIPROTO_REQ_RUMBLE = 0x10,\n\tWIIPROTO_REQ_LED = 0x11,\n\tWIIPROTO_REQ_DRM = 0x12,\n\tWIIPROTO_REQ_IR1 = 0x13,\n\tWIIPROTO_REQ_SREQ = 0x15,\n\tWIIPROTO_REQ_WMEM = 0x16,\n\tWIIPROTO_REQ_RMEM = 0x17,\n\tWIIPROTO_REQ_IR2 = 0x1a,\n\tWIIPROTO_REQ_STATUS = 0x20,\n\tWIIPROTO_REQ_DATA = 0x21,\n\tWIIPROTO_REQ_RETURN = 0x22,\n\n\t \n\tWIIPROTO_REQ_DRM_K = 0x30,\n\n\t \n\tWIIPROTO_REQ_DRM_KA = 0x31,\n\n\t \n\tWIIPROTO_REQ_DRM_KE = 0x32,\n\n\t \n\tWIIPROTO_REQ_DRM_KAI = 0x33,\n\n\t \n\tWIIPROTO_REQ_DRM_KEE = 0x34,\n\n\t \n\tWIIPROTO_REQ_DRM_KAE = 0x35,\n\n\t \n\tWIIPROTO_REQ_DRM_KIE = 0x36,\n\n\t \n\tWIIPROTO_REQ_DRM_KAIE = 0x37,\n\n\t \n\tWIIPROTO_REQ_DRM_E = 0x3d,\n\n\t \n\tWIIPROTO_REQ_DRM_SKAI1 = 0x3e,\n\n\t \n\tWIIPROTO_REQ_DRM_SKAI2 = 0x3f,\n\n\tWIIPROTO_REQ_MAX\n};\n\n#define dev_to_wii(pdev) hid_get_drvdata(to_hid_device(pdev))\n\nvoid __wiimote_schedule(struct wiimote_data *wdata);\n\nextern void wiiproto_req_drm(struct wiimote_data *wdata, __u8 drm);\nextern void wiiproto_req_rumble(struct wiimote_data *wdata, __u8 rumble);\nextern void wiiproto_req_leds(struct wiimote_data *wdata, int leds);\nextern void wiiproto_req_status(struct wiimote_data *wdata);\nextern void wiiproto_req_accel(struct wiimote_data *wdata, __u8 accel);\nextern void wiiproto_req_ir1(struct wiimote_data *wdata, __u8 flags);\nextern void wiiproto_req_ir2(struct wiimote_data *wdata, __u8 flags);\nextern int wiimote_cmd_write(struct wiimote_data *wdata, __u32 offset,\n\t\t\t\t\t\tconst __u8 *wmem, __u8 size);\nextern ssize_t wiimote_cmd_read(struct wiimote_data *wdata, __u32 offset,\n\t\t\t\t\t\t\t__u8 *rmem, __u8 size);\n\n#define wiiproto_req_rreg(wdata, os, sz) \\\n\t\t\t\twiiproto_req_rmem((wdata), false, (os), (sz))\n#define wiiproto_req_reeprom(wdata, os, sz) \\\n\t\t\t\twiiproto_req_rmem((wdata), true, (os), (sz))\nextern void wiiproto_req_rmem(struct wiimote_data *wdata, bool eeprom,\n\t\t\t\t\t\t__u32 offset, __u16 size);\n\n#ifdef CONFIG_DEBUG_FS\n\nextern int wiidebug_init(struct wiimote_data *wdata);\nextern void wiidebug_deinit(struct wiimote_data *wdata);\n\n#else\n\nstatic inline int wiidebug_init(void *u) { return 0; }\nstatic inline void wiidebug_deinit(void *u) { }\n\n#endif\n\n \nstatic inline bool wiimote_cmd_pending(struct wiimote_data *wdata, int cmd,\n\t\t\t\t\t\t\t\t__u32 opt)\n{\n\treturn wdata->state.cmd == cmd && wdata->state.opt == opt;\n}\n\n \nstatic inline void wiimote_cmd_complete(struct wiimote_data *wdata)\n{\n\twdata->state.cmd = WIIPROTO_REQ_NULL;\n\tcomplete(&wdata->state.ready);\n}\n\n \nstatic inline void wiimote_cmd_abort(struct wiimote_data *wdata)\n{\n\t \n\twdata->state.cmd = WIIPROTO_REQ_MAX;\n\tcomplete(&wdata->state.ready);\n}\n\nstatic inline int wiimote_cmd_acquire(struct wiimote_data *wdata)\n{\n\treturn mutex_lock_interruptible(&wdata->state.sync) ? -ERESTARTSYS : 0;\n}\n\nstatic inline void wiimote_cmd_acquire_noint(struct wiimote_data *wdata)\n{\n\tmutex_lock(&wdata->state.sync);\n}\n\n \nstatic inline void wiimote_cmd_set(struct wiimote_data *wdata, int cmd,\n\t\t\t\t\t\t\t\t__u32 opt)\n{\n\treinit_completion(&wdata->state.ready);\n\twdata->state.cmd = cmd;\n\twdata->state.opt = opt;\n}\n\nstatic inline void wiimote_cmd_release(struct wiimote_data *wdata)\n{\n\tmutex_unlock(&wdata->state.sync);\n}\n\nstatic inline int wiimote_cmd_wait(struct wiimote_data *wdata)\n{\n\tint ret;\n\n\t \n\n\tret = wait_for_completion_interruptible_timeout(&wdata->state.ready, HZ);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\telse if (ret == 0)\n\t\treturn -EIO;\n\telse if (wdata->state.cmd != WIIPROTO_REQ_NULL)\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\nstatic inline int wiimote_cmd_wait_noint(struct wiimote_data *wdata)\n{\n\tunsigned long ret;\n\n\t \n\tret = wait_for_completion_timeout(&wdata->state.ready, HZ);\n\tif (!ret)\n\t\treturn -EIO;\n\telse if (wdata->state.cmd != WIIPROTO_REQ_NULL)\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}