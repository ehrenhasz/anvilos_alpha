{
  "module_name": "hid-sensor-custom.c",
  "hash_id": "a402fcda75639dfe54eab9f28c35d0383e09b27c2d980ecd9dc3ba73c54b89e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-sensor-custom.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/dmi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/kfifo.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/bsearch.h>\n#include <linux/platform_device.h>\n#include <linux/hid-sensor-hub.h>\n\n#define HID_CUSTOM_NAME_LENGTH\t\t64\n#define HID_CUSTOM_MAX_CORE_ATTRS\t10\n#define HID_CUSTOM_TOTAL_ATTRS\t\t(HID_CUSTOM_MAX_CORE_ATTRS + 1)\n#define HID_CUSTOM_FIFO_SIZE\t\t4096\n#define HID_CUSTOM_MAX_FEATURE_BYTES\t64\n#define HID_SENSOR_USAGE_LENGTH (4 + 1)\n\nstruct hid_sensor_custom_field {\n\tint report_id;\n\tchar group_name[HID_CUSTOM_NAME_LENGTH];\n\tstruct hid_sensor_hub_attribute_info attribute;\n\tstruct device_attribute sd_attrs[HID_CUSTOM_MAX_CORE_ATTRS];\n\tchar attr_name[HID_CUSTOM_TOTAL_ATTRS][HID_CUSTOM_NAME_LENGTH];\n\tstruct attribute *attrs[HID_CUSTOM_TOTAL_ATTRS];\n\tstruct attribute_group hid_custom_attribute_group;\n};\n\nstruct hid_sensor_custom {\n\tstruct mutex mutex;\n\tstruct platform_device *pdev;\n\tstruct hid_sensor_hub_device *hsdev;\n\tstruct hid_sensor_hub_callbacks callbacks;\n\tint sensor_field_count;\n\tstruct hid_sensor_custom_field *fields;\n\tint input_field_count;\n\tint input_report_size;\n\tint input_report_recd_size;\n\tbool input_skip_sample;\n\tbool enable;\n\tstruct hid_sensor_custom_field *power_state;\n\tstruct hid_sensor_custom_field *report_state;\n\tstruct miscdevice custom_dev;\n\tstruct kfifo data_fifo;\n\tunsigned long misc_opened;\n\twait_queue_head_t wait;\n\tstruct platform_device *custom_pdev;\n};\n\n \nstruct hid_sensor_sample {\n\tu32 usage_id;\n\tu64 timestamp;\n\tu32 raw_len;\n} __packed;\n\nstatic struct attribute hid_custom_attrs[HID_CUSTOM_TOTAL_ATTRS] = {\n\t{.name = \"name\", .mode = S_IRUGO},\n\t{.name = \"units\", .mode = S_IRUGO},\n\t{.name = \"unit-expo\", .mode = S_IRUGO},\n\t{.name = \"minimum\", .mode = S_IRUGO},\n\t{.name = \"maximum\", .mode = S_IRUGO},\n\t{.name = \"size\", .mode = S_IRUGO},\n\t{.name = \"value\", .mode = S_IWUSR | S_IRUGO},\n\t{.name = NULL}\n};\n\nstatic const struct hid_custom_usage_desc {\n\tint usage_id;\n\tchar *desc;\n} hid_custom_usage_desc_table[] = {\n\t{0x200201,\t\"event-sensor-state\"},\n\t{0x200202,\t\"event-sensor-event\"},\n\t{0x200301,\t\"property-friendly-name\"},\n\t{0x200302,\t\"property-persistent-unique-id\"},\n\t{0x200303,\t\"property-sensor-status\"},\n\t{0x200304,\t\"property-min-report-interval\"},\n\t{0x200305,\t\"property-sensor-manufacturer\"},\n\t{0x200306,\t\"property-sensor-model\"},\n\t{0x200307,\t\"property-sensor-serial-number\"},\n\t{0x200308,\t\"property-sensor-description\"},\n\t{0x200309,\t\"property-sensor-connection-type\"},\n\t{0x20030A,\t\"property-sensor-device-path\"},\n\t{0x20030B,\t\"property-hardware-revision\"},\n\t{0x20030C,\t\"property-firmware-version\"},\n\t{0x20030D,\t\"property-release-date\"},\n\t{0x20030E,\t\"property-report-interval\"},\n\t{0x20030F,\t\"property-change-sensitivity-absolute\"},\n\t{0x200310,\t\"property-change-sensitivity-percent-range\"},\n\t{0x200311,\t\"property-change-sensitivity-percent-relative\"},\n\t{0x200312,\t\"property-accuracy\"},\n\t{0x200313,\t\"property-resolution\"},\n\t{0x200314,\t\"property-maximum\"},\n\t{0x200315,\t\"property-minimum\"},\n\t{0x200316,\t\"property-reporting-state\"},\n\t{0x200317,\t\"property-sampling-rate\"},\n\t{0x200318,\t\"property-response-curve\"},\n\t{0x200319,\t\"property-power-state\"},\n\t{0x200540,\t\"data-field-custom\"},\n\t{0x200541,\t\"data-field-custom-usage\"},\n\t{0x200542,\t\"data-field-custom-boolean-array\"},\n\t{0x200543,\t\"data-field-custom-value\"},\n\t{0x200544,\t\"data-field-custom-value_1\"},\n\t{0x200545,\t\"data-field-custom-value_2\"},\n\t{0x200546,\t\"data-field-custom-value_3\"},\n\t{0x200547,\t\"data-field-custom-value_4\"},\n\t{0x200548,\t\"data-field-custom-value_5\"},\n\t{0x200549,\t\"data-field-custom-value_6\"},\n\t{0x20054A,\t\"data-field-custom-value_7\"},\n\t{0x20054B,\t\"data-field-custom-value_8\"},\n\t{0x20054C,\t\"data-field-custom-value_9\"},\n\t{0x20054D,\t\"data-field-custom-value_10\"},\n\t{0x20054E,\t\"data-field-custom-value_11\"},\n\t{0x20054F,\t\"data-field-custom-value_12\"},\n\t{0x200550,\t\"data-field-custom-value_13\"},\n\t{0x200551,\t\"data-field-custom-value_14\"},\n\t{0x200552,\t\"data-field-custom-value_15\"},\n\t{0x200553,\t\"data-field-custom-value_16\"},\n\t{0x200554,\t\"data-field-custom-value_17\"},\n\t{0x200555,\t\"data-field-custom-value_18\"},\n\t{0x200556,\t\"data-field-custom-value_19\"},\n\t{0x200557,\t\"data-field-custom-value_20\"},\n\t{0x200558,\t\"data-field-custom-value_21\"},\n\t{0x200559,\t\"data-field-custom-value_22\"},\n\t{0x20055A,\t\"data-field-custom-value_23\"},\n\t{0x20055B,\t\"data-field-custom-value_24\"},\n\t{0x20055C,\t\"data-field-custom-value_25\"},\n\t{0x20055D,\t\"data-field-custom-value_26\"},\n\t{0x20055E,\t\"data-field-custom-value_27\"},\n\t{0x20055F,\t\"data-field-custom-value_28\"},\n};\n\nstatic int usage_id_cmp(const void *p1, const void *p2)\n{\n\tif (*(int *)p1 < *(int *)p2)\n\t\treturn -1;\n\n\tif (*(int *)p1 > *(int *)p2)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic ssize_t enable_sensor_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct hid_sensor_custom *sensor_inst = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", sensor_inst->enable);\n}\n\nstatic int set_power_report_state(struct hid_sensor_custom *sensor_inst,\n\t\t\t\t  bool state)\n{\n\tint power_val = -1;\n\tint report_val = -1;\n\tu32 power_state_usage_id;\n\tu32 report_state_usage_id;\n\tint ret;\n\n\t \n\tif (state) {\n\t\tpower_state_usage_id =\n\t\t\tHID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM;\n\t\treport_state_usage_id =\n\t\t\tHID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM;\n\t} else {\n\t\tpower_state_usage_id =\n\t\t\tHID_USAGE_SENSOR_PROP_POWER_STATE_D4_POWER_OFF_ENUM;\n\t\treport_state_usage_id =\n\t\t\tHID_USAGE_SENSOR_PROP_REPORTING_STATE_NO_EVENTS_ENUM;\n\t}\n\n\tif (sensor_inst->power_state)\n\t\tpower_val = hid_sensor_get_usage_index(sensor_inst->hsdev,\n\t\t\t\tsensor_inst->power_state->attribute.report_id,\n\t\t\t\tsensor_inst->power_state->attribute.index,\n\t\t\t\tpower_state_usage_id);\n\tif (sensor_inst->report_state)\n\t\treport_val = hid_sensor_get_usage_index(sensor_inst->hsdev,\n\t\t\t\tsensor_inst->report_state->attribute.report_id,\n\t\t\t\tsensor_inst->report_state->attribute.index,\n\t\t\t\treport_state_usage_id);\n\n\tif (power_val >= 0) {\n\t\tpower_val +=\n\t\t\tsensor_inst->power_state->attribute.logical_minimum;\n\t\tret = sensor_hub_set_feature(sensor_inst->hsdev,\n\t\t\t\tsensor_inst->power_state->attribute.report_id,\n\t\t\t\tsensor_inst->power_state->attribute.index,\n\t\t\t\tsizeof(power_val),\n\t\t\t\t&power_val);\n\t\tif (ret) {\n\t\t\thid_err(sensor_inst->hsdev->hdev,\n\t\t\t\t\"Set power state failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (report_val >= 0) {\n\t\treport_val +=\n\t\t\tsensor_inst->report_state->attribute.logical_minimum;\n\t\tret = sensor_hub_set_feature(sensor_inst->hsdev,\n\t\t\t\tsensor_inst->report_state->attribute.report_id,\n\t\t\t\tsensor_inst->report_state->attribute.index,\n\t\t\t\tsizeof(report_val),\n\t\t\t\t&report_val);\n\t\tif (ret) {\n\t\t\thid_err(sensor_inst->hsdev->hdev,\n\t\t\t\t\"Set report state failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t enable_sensor_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct hid_sensor_custom *sensor_inst = dev_get_drvdata(dev);\n\tint value;\n\tint ret = -EINVAL;\n\n\tif (kstrtoint(buf, 0, &value) != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sensor_inst->mutex);\n\tif (value && !sensor_inst->enable) {\n\t\tret = sensor_hub_device_open(sensor_inst->hsdev);\n\t\tif (ret)\n\t\t\tgoto unlock_state;\n\n\t\tret = set_power_report_state(sensor_inst, true);\n\t\tif (ret) {\n\t\t\tsensor_hub_device_close(sensor_inst->hsdev);\n\t\t\tgoto unlock_state;\n\t\t}\n\t\tsensor_inst->enable = true;\n\t} else if (!value && sensor_inst->enable) {\n\t\tret = set_power_report_state(sensor_inst, false);\n\t\tsensor_hub_device_close(sensor_inst->hsdev);\n\t\tsensor_inst->enable = false;\n\t}\nunlock_state:\n\tmutex_unlock(&sensor_inst->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(enable_sensor);\n\nstatic struct attribute *enable_sensor_attrs[] = {\n\t&dev_attr_enable_sensor.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group enable_sensor_attr_group = {\n\t.attrs = enable_sensor_attrs,\n};\n\nstatic ssize_t show_value(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct hid_sensor_custom *sensor_inst = dev_get_drvdata(dev);\n\tstruct hid_sensor_hub_attribute_info *attribute;\n\tint index, usage, field_index;\n\tchar name[HID_CUSTOM_NAME_LENGTH];\n\tbool feature = false;\n\tbool input = false;\n\tint value = 0;\n\n\tif (sscanf(attr->attr.name, \"feature-%x-%x-%s\", &index, &usage,\n\t\t   name) == 3) {\n\t\tfeature = true;\n\t\tfield_index = index + sensor_inst->input_field_count;\n\t} else if (sscanf(attr->attr.name, \"input-%x-%x-%s\", &index, &usage,\n\t\t   name) == 3) {\n\t\tinput = true;\n\t\tfield_index = index;\n\t} else\n\t\treturn -EINVAL;\n\n\tif (!strncmp(name, \"value\", strlen(\"value\"))) {\n\t\tu32 report_id;\n\t\tint ret;\n\n\t\tattribute = &sensor_inst->fields[field_index].attribute;\n\t\treport_id = attribute->report_id;\n\t\tif (feature) {\n\t\t\tu8 values[HID_CUSTOM_MAX_FEATURE_BYTES];\n\t\t\tint len = 0;\n\t\t\tu64 value = 0;\n\t\t\tint i = 0;\n\n\t\t\tret = sensor_hub_get_feature(sensor_inst->hsdev,\n\t\t\t\t\t\t     report_id,\n\t\t\t\t\t\t     index,\n\t\t\t\t\t\t     sizeof(values), values);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\twhile (i < ret) {\n\t\t\t\tif (i + attribute->size > ret) {\n\t\t\t\t\tlen += scnprintf(&buf[len],\n\t\t\t\t\t\t\tPAGE_SIZE - len,\n\t\t\t\t\t\t\t\"%d \", values[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (attribute->size) {\n\t\t\t\tcase 2:\n\t\t\t\t\tvalue = (u64) *(u16 *)&values[i];\n\t\t\t\t\ti += attribute->size;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tvalue = (u64) *(u32 *)&values[i];\n\t\t\t\t\ti += attribute->size;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tvalue = *(u64 *)&values[i];\n\t\t\t\t\ti += attribute->size;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvalue = (u64) values[i];\n\t\t\t\t\t++i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlen += scnprintf(&buf[len], PAGE_SIZE - len,\n\t\t\t\t\t\t\"%lld \", value);\n\t\t\t}\n\t\t\tlen += scnprintf(&buf[len], PAGE_SIZE - len, \"\\n\");\n\n\t\t\treturn len;\n\t\t} else if (input)\n\t\t\tvalue = sensor_hub_input_attr_get_raw_value(\n\t\t\t\t\t\tsensor_inst->hsdev,\n\t\t\t\t\t\tsensor_inst->hsdev->usage,\n\t\t\t\t\t\tusage, report_id,\n\t\t\t\t\t\tSENSOR_HUB_SYNC, false);\n\t} else if (!strncmp(name, \"units\", strlen(\"units\")))\n\t\tvalue = sensor_inst->fields[field_index].attribute.units;\n\telse if (!strncmp(name, \"unit-expo\", strlen(\"unit-expo\")))\n\t\tvalue = sensor_inst->fields[field_index].attribute.unit_expo;\n\telse if (!strncmp(name, \"size\", strlen(\"size\")))\n\t\tvalue = sensor_inst->fields[field_index].attribute.size;\n\telse if (!strncmp(name, \"minimum\", strlen(\"minimum\")))\n\t\tvalue = sensor_inst->fields[field_index].attribute.\n\t\t\t\t\t\t\tlogical_minimum;\n\telse if (!strncmp(name, \"maximum\", strlen(\"maximum\")))\n\t\tvalue = sensor_inst->fields[field_index].attribute.\n\t\t\t\t\t\t\tlogical_maximum;\n\telse if (!strncmp(name, \"name\", strlen(\"name\"))) {\n\t\tstruct hid_custom_usage_desc *usage_desc;\n\n\t\tusage_desc = bsearch(&usage, hid_custom_usage_desc_table,\n\t\t\t\t     ARRAY_SIZE(hid_custom_usage_desc_table),\n\t\t\t\t     sizeof(struct hid_custom_usage_desc),\n\t\t\t\t     usage_id_cmp);\n\t\tif (usage_desc)\n\t\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t\t\tusage_desc->desc);\n\t\telse\n\t\t\treturn sprintf(buf, \"not-specified\\n\");\n\t } else\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t store_value(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct hid_sensor_custom *sensor_inst = dev_get_drvdata(dev);\n\tint index, field_index, usage;\n\tchar name[HID_CUSTOM_NAME_LENGTH];\n\tint value, ret;\n\n\tif (sscanf(attr->attr.name, \"feature-%x-%x-%s\", &index, &usage,\n\t\t   name) == 3) {\n\t\tfield_index = index + sensor_inst->input_field_count;\n\t} else\n\t\treturn -EINVAL;\n\n\tif (!strncmp(name, \"value\", strlen(\"value\"))) {\n\t\tu32 report_id;\n\n\t\tif (kstrtoint(buf, 0, &value) != 0)\n\t\t\treturn -EINVAL;\n\n\t\treport_id = sensor_inst->fields[field_index].attribute.\n\t\t\t\t\t\t\t\treport_id;\n\t\tret = sensor_hub_set_feature(sensor_inst->hsdev, report_id,\n\t\t\t\t\t     index, sizeof(value), &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic int hid_sensor_capture_sample(struct hid_sensor_hub_device *hsdev,\n\t\t\t\t  unsigned usage_id, size_t raw_len,\n\t\t\t\t  char *raw_data, void *priv)\n{\n\tstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(priv);\n\tstruct hid_sensor_sample header;\n\n\t \n\tif (sensor_inst->input_skip_sample) {\n\t\thid_err(sensor_inst->hsdev->hdev, \"Skipped remaining data\\n\");\n\t\treturn 0;\n\t}\n\n\thid_dbg(sensor_inst->hsdev->hdev, \"%s received %d of %d\\n\", __func__,\n\t\t(int) (sensor_inst->input_report_recd_size + raw_len),\n\t\tsensor_inst->input_report_size);\n\n\tif (!test_bit(0, &sensor_inst->misc_opened))\n\t\treturn 0;\n\n\tif (!sensor_inst->input_report_recd_size) {\n\t\tint required_size = sizeof(struct hid_sensor_sample) +\n\t\t\t\t\t\tsensor_inst->input_report_size;\n\t\theader.usage_id = hsdev->usage;\n\t\theader.raw_len = sensor_inst->input_report_size;\n\t\theader.timestamp = ktime_get_real_ns();\n\t\tif (kfifo_avail(&sensor_inst->data_fifo) >= required_size) {\n\t\t\tkfifo_in(&sensor_inst->data_fifo,\n\t\t\t\t (unsigned char *)&header,\n\t\t\t\t sizeof(header));\n\t\t} else\n\t\t\tsensor_inst->input_skip_sample = true;\n\t}\n\tif (kfifo_avail(&sensor_inst->data_fifo) >= raw_len)\n\t\tkfifo_in(&sensor_inst->data_fifo, (unsigned char *)raw_data,\n\t\t\t raw_len);\n\n\tsensor_inst->input_report_recd_size += raw_len;\n\n\treturn 0;\n}\n\nstatic int hid_sensor_send_event(struct hid_sensor_hub_device *hsdev,\n\t\t\t\t unsigned usage_id, void *priv)\n{\n\tstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(priv);\n\n\tif (!test_bit(0, &sensor_inst->misc_opened))\n\t\treturn 0;\n\n\tsensor_inst->input_report_recd_size = 0;\n\tsensor_inst->input_skip_sample = false;\n\n\twake_up(&sensor_inst->wait);\n\n\treturn 0;\n}\n\nstatic int hid_sensor_custom_add_field(struct hid_sensor_custom *sensor_inst,\n\t\t\t\t       int index, int report_type,\n\t\t\t\t       struct hid_report *report,\n\t\t\t\t       struct hid_field *field)\n{\n\tstruct hid_sensor_custom_field *sensor_field;\n\tvoid *fields;\n\n\tfields = krealloc(sensor_inst->fields,\n\t\t\t  (sensor_inst->sensor_field_count + 1) *\n\t\t\t   sizeof(struct hid_sensor_custom_field), GFP_KERNEL);\n\tif (!fields) {\n\t\tkfree(sensor_inst->fields);\n\t\treturn -ENOMEM;\n\t}\n\tsensor_inst->fields = fields;\n\tsensor_field = &sensor_inst->fields[sensor_inst->sensor_field_count];\n\tsensor_field->attribute.usage_id = sensor_inst->hsdev->usage;\n\tif (field->logical)\n\t\tsensor_field->attribute.attrib_id = field->logical;\n\telse\n\t\tsensor_field->attribute.attrib_id = field->usage[0].hid;\n\n\tsensor_field->attribute.index = index;\n\tsensor_field->attribute.report_id = report->id;\n\tsensor_field->attribute.units = field->unit;\n\tsensor_field->attribute.unit_expo = field->unit_exponent;\n\tsensor_field->attribute.size = (field->report_size / 8);\n\tsensor_field->attribute.logical_minimum = field->logical_minimum;\n\tsensor_field->attribute.logical_maximum = field->logical_maximum;\n\n\tif (report_type == HID_FEATURE_REPORT)\n\t\tsnprintf(sensor_field->group_name,\n\t\t\t sizeof(sensor_field->group_name), \"feature-%x-%x\",\n\t\t\t sensor_field->attribute.index,\n\t\t\t sensor_field->attribute.attrib_id);\n\telse if (report_type == HID_INPUT_REPORT) {\n\t\tsnprintf(sensor_field->group_name,\n\t\t\t sizeof(sensor_field->group_name),\n\t\t\t \"input-%x-%x\", sensor_field->attribute.index,\n\t\t\t sensor_field->attribute.attrib_id);\n\t\tsensor_inst->input_field_count++;\n\t\tsensor_inst->input_report_size += (field->report_size *\n\t\t\t\t\t\t   field->report_count) / 8;\n\t}\n\n\tmemset(&sensor_field->hid_custom_attribute_group, 0,\n\t       sizeof(struct attribute_group));\n\tsensor_inst->sensor_field_count++;\n\n\treturn 0;\n}\n\nstatic int hid_sensor_custom_add_fields(struct hid_sensor_custom *sensor_inst,\n\t\t\t\t\tstruct hid_report_enum *report_enum,\n\t\t\t\t\tint report_type)\n{\n\tint i;\n\tint ret;\n\tstruct hid_report *report;\n\tstruct hid_field *field;\n\tstruct hid_sensor_hub_device *hsdev = sensor_inst->hsdev;\n\n\tlist_for_each_entry(report, &report_enum->report_list, list) {\n\t\tfor (i = 0; i < report->maxfield; ++i) {\n\t\t\tfield = report->field[i];\n\t\t\tif (field->maxusage &&\n\t\t\t    ((field->usage[0].collection_index >=\n\t\t\t      hsdev->start_collection_index) &&\n\t\t\t      (field->usage[0].collection_index <\n\t\t\t       hsdev->end_collection_index))) {\n\n\t\t\t\tret = hid_sensor_custom_add_field(sensor_inst,\n\t\t\t\t\t\t\t\t  i,\n\t\t\t\t\t\t\t\t  report_type,\n\t\t\t\t\t\t\t\t  report,\n\t\t\t\t\t\t\t\t  field);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hid_sensor_custom_add_attributes(struct hid_sensor_custom\n\t\t\t\t\t\t\t\t*sensor_inst)\n{\n\tstruct hid_sensor_hub_device *hsdev = sensor_inst->hsdev;\n\tstruct hid_device *hdev = hsdev->hdev;\n\tint ret = -1;\n\tint i, j;\n\n\tfor (j = 0; j < HID_REPORT_TYPES; ++j) {\n\t\tif (j == HID_OUTPUT_REPORT)\n\t\t\tcontinue;\n\n\t\tret = hid_sensor_custom_add_fields(sensor_inst,\n\t\t\t\t\t\t   &hdev->report_enum[j], j);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\t \n\tfor (i = 0; i < sensor_inst->sensor_field_count; ++i) {\n\t\tj = 0;\n\t\twhile (j < HID_CUSTOM_TOTAL_ATTRS &&\n\t\t       hid_custom_attrs[j].name) {\n\t\t\tstruct device_attribute *device_attr;\n\n\t\t\tdevice_attr = &sensor_inst->fields[i].sd_attrs[j];\n\n\t\t\tsnprintf((char *)&sensor_inst->fields[i].attr_name[j],\n\t\t\t\t HID_CUSTOM_NAME_LENGTH, \"%s-%s\",\n\t\t\t\t sensor_inst->fields[i].group_name,\n\t\t\t\t hid_custom_attrs[j].name);\n\t\t\tsysfs_attr_init(&device_attr->attr);\n\t\t\tdevice_attr->attr.name =\n\t\t\t\t(char *)&sensor_inst->fields[i].attr_name[j];\n\t\t\tdevice_attr->attr.mode = hid_custom_attrs[j].mode;\n\t\t\tdevice_attr->show = show_value;\n\t\t\tif (hid_custom_attrs[j].mode & S_IWUSR)\n\t\t\t\tdevice_attr->store = store_value;\n\t\t\tsensor_inst->fields[i].attrs[j] = &device_attr->attr;\n\t\t\t++j;\n\t\t}\n\t\tsensor_inst->fields[i].attrs[j] = NULL;\n\t\tsensor_inst->fields[i].hid_custom_attribute_group.attrs =\n\t\t\t\t\t\tsensor_inst->fields[i].attrs;\n\t\tsensor_inst->fields[i].hid_custom_attribute_group.name =\n\t\t\t\t\tsensor_inst->fields[i].group_name;\n\t\tret = sysfs_create_group(&sensor_inst->pdev->dev.kobj,\n\t\t\t\t\t &sensor_inst->fields[i].\n\t\t\t\t\t hid_custom_attribute_group);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (sensor_inst->fields[i].attribute.attrib_id ==\n\t\t\t\t\tHID_USAGE_SENSOR_PROY_POWER_STATE)\n\t\t\tsensor_inst->power_state = &sensor_inst->fields[i];\n\t\telse if (sensor_inst->fields[i].attribute.attrib_id ==\n\t\t\t\t\tHID_USAGE_SENSOR_PROP_REPORT_STATE)\n\t\t\tsensor_inst->report_state = &sensor_inst->fields[i];\n\t}\n\n\treturn ret;\n}\n\nstatic void hid_sensor_custom_remove_attributes(struct hid_sensor_custom *\n\t\t\t\t\t\t\t\tsensor_inst)\n{\n\tint i;\n\n\tfor (i = 0; i < sensor_inst->sensor_field_count; ++i)\n\t\tsysfs_remove_group(&sensor_inst->pdev->dev.kobj,\n\t\t\t\t   &sensor_inst->fields[i].\n\t\t\t\t   hid_custom_attribute_group);\n\n\tkfree(sensor_inst->fields);\n}\n\nstatic ssize_t hid_sensor_custom_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t count, loff_t *f_ps)\n{\n\tstruct hid_sensor_custom *sensor_inst;\n\tunsigned int copied;\n\tint ret;\n\n\tsensor_inst = container_of(file->private_data,\n\t\t\t\t   struct hid_sensor_custom, custom_dev);\n\n\tif (count < sizeof(struct hid_sensor_sample))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tif (kfifo_is_empty(&sensor_inst->data_fifo)) {\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tret = wait_event_interruptible(sensor_inst->wait,\n\t\t\t\t!kfifo_is_empty(&sensor_inst->data_fifo));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = kfifo_to_user(&sensor_inst->data_fifo, buf, count,\n\t\t\t\t    &copied);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t} while (copied == 0);\n\n\treturn copied;\n}\n\nstatic int hid_sensor_custom_release(struct inode *inode, struct file *file)\n{\n\tstruct hid_sensor_custom *sensor_inst;\n\n\tsensor_inst = container_of(file->private_data,\n\t\t\t\t   struct hid_sensor_custom, custom_dev);\n\n\tclear_bit(0, &sensor_inst->misc_opened);\n\n\treturn 0;\n}\n\nstatic int hid_sensor_custom_open(struct inode *inode, struct file *file)\n{\n\tstruct hid_sensor_custom *sensor_inst;\n\n\tsensor_inst = container_of(file->private_data,\n\t\t\t\t   struct hid_sensor_custom, custom_dev);\n\t \n\tif (test_and_set_bit(0, &sensor_inst->misc_opened))\n\t\treturn -EBUSY;\n\n\treturn stream_open(inode, file);\n}\n\nstatic __poll_t hid_sensor_custom_poll(struct file *file,\n\t\t\t\t\t   struct poll_table_struct *wait)\n{\n\tstruct hid_sensor_custom *sensor_inst;\n\t__poll_t mask = 0;\n\n\tsensor_inst = container_of(file->private_data,\n\t\t\t\t   struct hid_sensor_custom, custom_dev);\n\n\tpoll_wait(file, &sensor_inst->wait, wait);\n\n\tif (!kfifo_is_empty(&sensor_inst->data_fifo))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic const struct file_operations hid_sensor_custom_fops = {\n\t.open =  hid_sensor_custom_open,\n\t.read =  hid_sensor_custom_read,\n\t.release = hid_sensor_custom_release,\n\t.poll = hid_sensor_custom_poll,\n\t.llseek = noop_llseek,\n};\n\nstatic int hid_sensor_custom_dev_if_add(struct hid_sensor_custom *sensor_inst)\n{\n\tint ret;\n\n\tret = kfifo_alloc(&sensor_inst->data_fifo, HID_CUSTOM_FIFO_SIZE,\n\t\t\t  GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_waitqueue_head(&sensor_inst->wait);\n\n\tsensor_inst->custom_dev.minor = MISC_DYNAMIC_MINOR;\n\tsensor_inst->custom_dev.name = dev_name(&sensor_inst->pdev->dev);\n\tsensor_inst->custom_dev.fops = &hid_sensor_custom_fops,\n\tret = misc_register(&sensor_inst->custom_dev);\n\tif (ret) {\n\t\tkfifo_free(&sensor_inst->data_fifo);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void hid_sensor_custom_dev_if_remove(struct hid_sensor_custom\n\t\t\t\t\t\t\t\t*sensor_inst)\n{\n\twake_up(&sensor_inst->wait);\n\tmisc_deregister(&sensor_inst->custom_dev);\n\tkfifo_free(&sensor_inst->data_fifo);\n\n}\n\n \nstruct hid_sensor_custom_match {\n\tconst char *tag;\n\tconst char *luid;\n\tconst char *model;\n\tconst char *manufacturer;\n\tbool check_dmi;\n\tstruct dmi_system_id dmi;\n};\n\n \nstruct hid_sensor_custom_properties {\n\tu16 serial_num[HID_CUSTOM_MAX_FEATURE_BYTES];\n\tu16 model[HID_CUSTOM_MAX_FEATURE_BYTES];\n\tu16 manufacturer[HID_CUSTOM_MAX_FEATURE_BYTES];\n};\n\nstatic const struct hid_sensor_custom_match hid_sensor_custom_known_table[] = {\n\t \n\t{\t \n\t\t.tag = \"INT\",\n\t\t.luid = \"020B000000000000\",\n\t\t.manufacturer = \"INTEL\",\n\t},\n\t \n\t{\t \n\t\t.tag = \"LISS\",\n\t\t.luid = \"0041010200000082\",\n\t\t.model = \"STK3X3X Sensor\",\n\t\t.manufacturer = \"Vendor 258\",\n\t\t.check_dmi = true,\n\t\t.dmi.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t}\n\t},\n\t{\t \n\t\t.tag = \"LISS\",\n\t\t.luid = \"0226000171AC0081\",\n\t\t.model = \"VL53L1_HOD Sensor\",\n\t\t.manufacturer = \"ST_MICRO\",\n\t\t.check_dmi = true,\n\t\t.dmi.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t}\n\t},\n\t{}\n};\n\nstatic bool hid_sensor_custom_prop_match_str(const u16 *prop, const char *match,\n\t\t\t\t\t     size_t count)\n{\n\twhile (count-- && *prop && *match) {\n\t\tif (*prop != (u16) *match)\n\t\t\treturn false;\n\t\tprop++;\n\t\tmatch++;\n\t}\n\n\treturn (count == -1) || *prop == (u16)*match;\n}\n\nstatic int hid_sensor_custom_get_prop(struct hid_sensor_hub_device *hsdev,\n\t\t\t\t      u32 prop_usage_id, size_t prop_size,\n\t\t\t\t      u16 *prop)\n{\n\tstruct hid_sensor_hub_attribute_info prop_attr = { 0 };\n\tint ret;\n\n\tmemset(prop, 0, prop_size);\n\n\tret = sensor_hub_input_get_attribute_info(hsdev, HID_FEATURE_REPORT,\n\t\t\t\t\t\t  hsdev->usage, prop_usage_id,\n\t\t\t\t\t\t  &prop_attr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sensor_hub_get_feature(hsdev, prop_attr.report_id,\n\t\t\t\t     prop_attr.index, prop_size, prop);\n\tif (ret < 0) {\n\t\thid_err(hsdev->hdev, \"Failed to get sensor property %08x %d\\n\",\n\t\t\tprop_usage_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nhid_sensor_custom_do_match(struct hid_sensor_hub_device *hsdev,\n\t\t\t   const struct hid_sensor_custom_match *match,\n\t\t\t   const struct hid_sensor_custom_properties *prop)\n{\n\tstruct dmi_system_id dmi[] = { match->dmi, { 0 } };\n\n\tif (!hid_sensor_custom_prop_match_str(prop->serial_num, \"LUID:\", 5) ||\n\t    !hid_sensor_custom_prop_match_str(prop->serial_num + 5, match->luid,\n\t\t\t\t\t      HID_CUSTOM_MAX_FEATURE_BYTES - 5))\n\t\treturn false;\n\n\tif (match->model &&\n\t    !hid_sensor_custom_prop_match_str(prop->model, match->model,\n\t\t\t\t\t      HID_CUSTOM_MAX_FEATURE_BYTES))\n\t\treturn false;\n\n\tif (match->manufacturer &&\n\t    !hid_sensor_custom_prop_match_str(prop->manufacturer, match->manufacturer,\n\t\t\t\t\t      HID_CUSTOM_MAX_FEATURE_BYTES))\n\t\treturn false;\n\n\tif (match->check_dmi && !dmi_check_system(dmi))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\nhid_sensor_custom_properties_get(struct hid_sensor_hub_device *hsdev,\n\t\t\t\t struct hid_sensor_custom_properties *prop)\n{\n\tint ret;\n\n\tret = hid_sensor_custom_get_prop(hsdev,\n\t\t\t\t\t HID_USAGE_SENSOR_PROP_SERIAL_NUM,\n\t\t\t\t\t HID_CUSTOM_MAX_FEATURE_BYTES,\n\t\t\t\t\t prop->serial_num);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\thid_sensor_custom_get_prop(hsdev, HID_USAGE_SENSOR_PROP_MODEL,\n\t\t\t\t   HID_CUSTOM_MAX_FEATURE_BYTES,\n\t\t\t\t   prop->model);\n\n\thid_sensor_custom_get_prop(hsdev, HID_USAGE_SENSOR_PROP_MANUFACTURER,\n\t\t\t\t   HID_CUSTOM_MAX_FEATURE_BYTES,\n\t\t\t\t   prop->manufacturer);\n\n\treturn 0;\n}\n\nstatic int\nhid_sensor_custom_get_known(struct hid_sensor_hub_device *hsdev,\n\t\t\t    const struct hid_sensor_custom_match **known)\n{\n\tint ret;\n\tconst struct hid_sensor_custom_match *match =\n\t\thid_sensor_custom_known_table;\n\tstruct hid_sensor_custom_properties *prop;\n\n\tprop = kmalloc(sizeof(struct hid_sensor_custom_properties), GFP_KERNEL);\n\tif (!prop)\n\t\treturn -ENOMEM;\n\n\tret = hid_sensor_custom_properties_get(hsdev, prop);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (match->tag) {\n\t\tif (hid_sensor_custom_do_match(hsdev, match, prop)) {\n\t\t\t*known = match;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tmatch++;\n\t}\n\tret = -ENODATA;\nout:\n\tkfree(prop);\n\treturn ret;\n}\n\nstatic struct platform_device *\nhid_sensor_register_platform_device(struct platform_device *pdev,\n\t\t\t\t    struct hid_sensor_hub_device *hsdev,\n\t\t\t\t    const struct hid_sensor_custom_match *match)\n{\n\tchar real_usage[HID_SENSOR_USAGE_LENGTH] = { 0 };\n\tstruct platform_device *custom_pdev;\n\tconst char *dev_name;\n\tchar *c;\n\n\tmemcpy(real_usage, match->luid, 4);\n\n\t \n\tfor (c = real_usage; *c != '\\0'; c++)\n\t\t*c = tolower(*c);\n\n\t \n\tdev_name = kasprintf(GFP_KERNEL, \"HID-SENSOR-%s-%s\",\n\t\t\t     match->tag, real_usage);\n\tif (!dev_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcustom_pdev = platform_device_register_data(pdev->dev.parent, dev_name,\n\t\t\t\t\t\t    PLATFORM_DEVID_AUTO, hsdev,\n\t\t\t\t\t\t    sizeof(*hsdev));\n\tkfree(dev_name);\n\treturn custom_pdev;\n}\n\nstatic int hid_sensor_custom_probe(struct platform_device *pdev)\n{\n\tstruct hid_sensor_custom *sensor_inst;\n\tstruct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;\n\tint ret;\n\tconst struct hid_sensor_custom_match *match;\n\n\tsensor_inst = devm_kzalloc(&pdev->dev, sizeof(*sensor_inst),\n\t\t\t\t   GFP_KERNEL);\n\tif (!sensor_inst)\n\t\treturn -ENOMEM;\n\n\tsensor_inst->callbacks.capture_sample = hid_sensor_capture_sample;\n\tsensor_inst->callbacks.send_event = hid_sensor_send_event;\n\tsensor_inst->callbacks.pdev = pdev;\n\tsensor_inst->hsdev = hsdev;\n\tsensor_inst->pdev = pdev;\n\tmutex_init(&sensor_inst->mutex);\n\tplatform_set_drvdata(pdev, sensor_inst);\n\n\tret = hid_sensor_custom_get_known(hsdev, &match);\n\tif (!ret) {\n\t\tsensor_inst->custom_pdev =\n\t\t\thid_sensor_register_platform_device(pdev, hsdev, match);\n\n\t\tret = PTR_ERR_OR_ZERO(sensor_inst->custom_pdev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"register_platform_device failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tret = sensor_hub_register_callback(hsdev, hsdev->usage,\n\t\t\t\t\t   &sensor_inst->callbacks);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"callback reg failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sysfs_create_group(&sensor_inst->pdev->dev.kobj,\n\t\t\t\t &enable_sensor_attr_group);\n\tif (ret)\n\t\tgoto err_remove_callback;\n\n\tret = hid_sensor_custom_add_attributes(sensor_inst);\n\tif (ret)\n\t\tgoto err_remove_group;\n\n\tret = hid_sensor_custom_dev_if_add(sensor_inst);\n\tif (ret)\n\t\tgoto err_remove_attributes;\n\n\treturn 0;\n\nerr_remove_attributes:\n\thid_sensor_custom_remove_attributes(sensor_inst);\nerr_remove_group:\n\tsysfs_remove_group(&sensor_inst->pdev->dev.kobj,\n\t\t\t   &enable_sensor_attr_group);\nerr_remove_callback:\n\tsensor_hub_remove_callback(hsdev, hsdev->usage);\n\n\treturn ret;\n}\n\nstatic int hid_sensor_custom_remove(struct platform_device *pdev)\n{\n\tstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(pdev);\n\tstruct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;\n\n\tif (sensor_inst->custom_pdev) {\n\t\tplatform_device_unregister(sensor_inst->custom_pdev);\n\t\treturn 0;\n\t}\n\n\thid_sensor_custom_dev_if_remove(sensor_inst);\n\thid_sensor_custom_remove_attributes(sensor_inst);\n\tsysfs_remove_group(&sensor_inst->pdev->dev.kobj,\n\t\t\t   &enable_sensor_attr_group);\n\tsensor_hub_remove_callback(hsdev, hsdev->usage);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id hid_sensor_custom_ids[] = {\n\t{\n\t\t.name = \"HID-SENSOR-2000e1\",\n\t},\n\t{\n\t\t.name = \"HID-SENSOR-2000e2\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, hid_sensor_custom_ids);\n\nstatic struct platform_driver hid_sensor_custom_platform_driver = {\n\t.id_table = hid_sensor_custom_ids,\n\t.driver = {\n\t\t.name\t= KBUILD_MODNAME,\n\t},\n\t.probe\t\t= hid_sensor_custom_probe,\n\t.remove\t\t= hid_sensor_custom_remove,\n};\nmodule_platform_driver(hid_sensor_custom_platform_driver);\n\nMODULE_DESCRIPTION(\"HID Sensor Custom and Generic sensor Driver\");\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}