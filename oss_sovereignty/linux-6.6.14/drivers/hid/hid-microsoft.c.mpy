{
  "module_name": "hid-microsoft.c",
  "hash_id": "3b873c3ffbcb2f21d80c604d7118491d04b21b54cf2ef7a4a0731148cd06df56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-microsoft.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define MS_HIDINPUT\t\tBIT(0)\n#define MS_ERGONOMY\t\tBIT(1)\n#define MS_PRESENTER\t\tBIT(2)\n#define MS_RDESC\t\tBIT(3)\n#define MS_NOGET\t\tBIT(4)\n#define MS_DUPLICATE_USAGES\tBIT(5)\n#define MS_SURFACE_DIAL\t\tBIT(6)\n#define MS_QUIRK_FF\t\tBIT(7)\n\nstruct ms_data {\n\tunsigned long quirks;\n\tstruct hid_device *hdev;\n\tstruct work_struct ff_worker;\n\t__u8 strong;\n\t__u8 weak;\n\tvoid *output_report_dmabuf;\n};\n\n#define XB1S_FF_REPORT\t\t3\n#define ENABLE_WEAK\t\tBIT(0)\n#define ENABLE_STRONG\t\tBIT(1)\n\nenum {\n\tMAGNITUDE_STRONG = 2,\n\tMAGNITUDE_WEAK,\n\tMAGNITUDE_NUM\n};\n\nstruct xb1s_ff_report {\n\t__u8\treport_id;\n\t__u8\tenable;\n\t__u8\tmagnitude[MAGNITUDE_NUM];\n\t__u8\tduration_10ms;\n\t__u8\tstart_delay_10ms;\n\t__u8\tloop_count;\n} __packed;\n\nstatic __u8 *ms_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tunsigned long quirks = ms->quirks;\n\n\t \n\tif ((quirks & MS_RDESC) && *rsize == 571 && rdesc[557] == 0x19 &&\n\t\t\trdesc[559] == 0x29) {\n\t\thid_info(hdev, \"fixing up Microsoft Wireless Receiver Model 1028 report descriptor\\n\");\n\t\trdesc[557] = 0x35;\n\t\trdesc[559] = 0x45;\n\t}\n\treturn rdesc;\n}\n\n#define ms_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int ms_ergonomy_kb_quirk(struct hid_input *hi, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct input_dev *input = hi->input;\n\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_CONSUMER) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\t \n\t\tcase 0x29d:\n\t\t\tms_map_key_clear(KEY_PROG1);\n\t\t\treturn 1;\n\t\tcase 0x29e:\n\t\t\tms_map_key_clear(KEY_PROG2);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_MSVENDOR)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0xfd06: ms_map_key_clear(KEY_CHAT);\tbreak;\n\tcase 0xfd07: ms_map_key_clear(KEY_PHONE);\tbreak;\n\tcase 0xff00:\n\t\t \n\t\tms_map_key_clear(KEY_KPEQUAL);\n\t\tset_bit(KEY_KPLEFTPAREN, input->keybit);\n\t\tset_bit(KEY_KPRIGHTPAREN, input->keybit);\n\t\tbreak;\n\tcase 0xff01:\n\t\t \n\t\thid_map_usage_clear(hi, usage, bit, max, EV_REL, REL_WHEEL);\n\t\tbreak;\n\tcase 0xff02:\n\t\t \n\t\treturn -1;\n\tcase 0xff05:\n\t\tset_bit(EV_REP, input->evbit);\n\t\tms_map_key_clear(KEY_F13);\n\t\tset_bit(KEY_F14, input->keybit);\n\t\tset_bit(KEY_F15, input->keybit);\n\t\tset_bit(KEY_F16, input->keybit);\n\t\tset_bit(KEY_F17, input->keybit);\n\t\tset_bit(KEY_F18, input->keybit);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int ms_presenter_8k_quirk(struct hid_input *hi, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_MSVENDOR)\n\t\treturn 0;\n\n\tset_bit(EV_REP, hi->input->evbit);\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0xfd08: ms_map_key_clear(KEY_FORWARD);\tbreak;\n\tcase 0xfd09: ms_map_key_clear(KEY_BACK);\tbreak;\n\tcase 0xfd0b: ms_map_key_clear(KEY_PLAYPAUSE);\tbreak;\n\tcase 0xfd0e: ms_map_key_clear(KEY_CLOSE);\tbreak;\n\tcase 0xfd0f: ms_map_key_clear(KEY_PLAY);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int ms_surface_dial_quirk(struct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\tcase 0xff070000:\n\tcase HID_UP_DIGITIZER:\n\t\t \n\t\treturn -1;\n\tcase HID_UP_GENDESK:\n\t\tswitch (usage->hid) {\n\t\tcase HID_GD_X:\n\t\tcase HID_GD_Y:\n\t\tcase HID_GD_RFKILL_BTN:\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ms_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tunsigned long quirks = ms->quirks;\n\n\tif (quirks & MS_ERGONOMY) {\n\t\tint ret = ms_ergonomy_kb_quirk(hi, usage, bit, max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((quirks & MS_PRESENTER) &&\n\t\t\tms_presenter_8k_quirk(hi, usage, bit, max))\n\t\treturn 1;\n\n\tif (quirks & MS_SURFACE_DIAL) {\n\t\tint ret = ms_surface_dial_quirk(hi, field, usage, bit, max);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ms_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tunsigned long quirks = ms->quirks;\n\n\tif (quirks & MS_DUPLICATE_USAGES)\n\t\tclear_bit(usage->code, *bit);\n\n\treturn 0;\n}\n\nstatic int ms_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tunsigned long quirks = ms->quirks;\n\tstruct input_dev *input;\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput ||\n\t\t\t!usage->type)\n\t\treturn 0;\n\n\tinput = field->hidinput->input;\n\n\t \n\tif (quirks & MS_ERGONOMY && usage->hid == (HID_UP_MSVENDOR | 0xff00)) {\n\t\t \n\t\tinput_report_key(input, KEY_KPEQUAL, value & 0x01);\n\t\tinput_report_key(input, KEY_KPLEFTPAREN, value & 0x02);\n\t\tinput_report_key(input, KEY_KPRIGHTPAREN, value & 0x04);\n\t\treturn 1;\n\t}\n\n\tif (quirks & MS_ERGONOMY && usage->hid == (HID_UP_MSVENDOR | 0xff01)) {\n\t\t \n\t\tint step = ((value & 0x60) >> 5) + 1;\n\n\t\tswitch (value & 0x1f) {\n\t\tcase 0x01:\n\t\t\tinput_report_rel(input, REL_WHEEL, step);\n\t\t\tbreak;\n\t\tcase 0x1f:\n\t\t\tinput_report_rel(input, REL_WHEEL, -step);\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (quirks & MS_ERGONOMY && usage->hid == (HID_UP_MSVENDOR | 0xff05)) {\n\t\tstatic unsigned int last_key = 0;\n\t\tunsigned int key = 0;\n\t\tswitch (value) {\n\t\tcase 0x01: key = KEY_F14; break;\n\t\tcase 0x02: key = KEY_F15; break;\n\t\tcase 0x04: key = KEY_F16; break;\n\t\tcase 0x08: key = KEY_F17; break;\n\t\tcase 0x10: key = KEY_F18; break;\n\t\t}\n\t\tif (key) {\n\t\t\tinput_event(input, usage->type, key, 1);\n\t\t\tlast_key = key;\n\t\t} else\n\t\t\tinput_event(input, usage->type, last_key, 0);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void ms_ff_worker(struct work_struct *work)\n{\n\tstruct ms_data *ms = container_of(work, struct ms_data, ff_worker);\n\tstruct hid_device *hdev = ms->hdev;\n\tstruct xb1s_ff_report *r = ms->output_report_dmabuf;\n\tint ret;\n\n\tmemset(r, 0, sizeof(*r));\n\n\tr->report_id = XB1S_FF_REPORT;\n\tr->enable = ENABLE_WEAK | ENABLE_STRONG;\n\t \n\tr->duration_10ms = U8_MAX;\n\tr->loop_count = U8_MAX;\n\tr->magnitude[MAGNITUDE_STRONG] = ms->strong;  \n\tr->magnitude[MAGNITUDE_WEAK] = ms->weak;      \n\n\tret = hid_hw_output_report(hdev, (__u8 *)r, sizeof(*r));\n\tif (ret < 0)\n\t\thid_warn(hdev, \"failed to send FF report\\n\");\n}\n\nstatic int ms_play_effect(struct input_dev *dev, void *data,\n\t\t\t  struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct ms_data *ms = hid_get_drvdata(hid);\n\n\tif (effect->type != FF_RUMBLE)\n\t\treturn 0;\n\n\t \n\tms->strong = ((u32) effect->u.rumble.strong_magnitude * 100) / U16_MAX;\n\tms->weak = ((u32) effect->u.rumble.weak_magnitude * 100) / U16_MAX;\n\n\tschedule_work(&ms->ff_worker);\n\treturn 0;\n}\n\nstatic int ms_init_ff(struct hid_device *hdev)\n{\n\tstruct hid_input *hidinput;\n\tstruct input_dev *input_dev;\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\n\tif (list_empty(&hdev->inputs)) {\n\t\thid_err(hdev, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_entry(hdev->inputs.next, struct hid_input, list);\n\tinput_dev = hidinput->input;\n\n\tif (!(ms->quirks & MS_QUIRK_FF))\n\t\treturn 0;\n\n\tms->hdev = hdev;\n\tINIT_WORK(&ms->ff_worker, ms_ff_worker);\n\n\tms->output_report_dmabuf = devm_kzalloc(&hdev->dev,\n\t\t\t\t\t\tsizeof(struct xb1s_ff_report),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (ms->output_report_dmabuf == NULL)\n\t\treturn -ENOMEM;\n\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, ms_play_effect);\n}\n\nstatic void ms_remove_ff(struct hid_device *hdev)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\n\tif (!(ms->quirks & MS_QUIRK_FF))\n\t\treturn;\n\n\tcancel_work_sync(&ms->ff_worker);\n}\n\nstatic int ms_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tunsigned long quirks = id->driver_data;\n\tstruct ms_data *ms;\n\tint ret;\n\n\tms = devm_kzalloc(&hdev->dev, sizeof(*ms), GFP_KERNEL);\n\tif (ms == NULL)\n\t\treturn -ENOMEM;\n\n\tms->quirks = quirks;\n\n\thid_set_drvdata(hdev, ms);\n\n\tif (quirks & MS_NOGET)\n\t\thdev->quirks |= HID_QUIRK_NOGET;\n\n\tif (quirks & MS_SURFACE_DIAL)\n\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT | ((quirks & MS_HIDINPUT) ?\n\t\t\t\tHID_CONNECT_HIDINPUT_FORCE : 0));\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = ms_init_ff(hdev);\n\tif (ret)\n\t\thid_err(hdev, \"could not initialize ff, continuing anyway\");\n\n\treturn 0;\nerr_free:\n\treturn ret;\n}\n\nstatic void ms_remove(struct hid_device *hdev)\n{\n\thid_hw_stop(hdev);\n\tms_remove_ff(hdev);\n}\n\nstatic const struct hid_device_id ms_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_SIDEWINDER_GV),\n\t\t.driver_data = MS_HIDINPUT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_OFFICE_KB),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K_JP),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE7K),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_LK6K),\n\t\t.driver_data = MS_ERGONOMY | MS_RDESC },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_USB),\n\t\t.driver_data = MS_PRESENTER },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_7K),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_600),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_3KV1),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0),\n\t\t.driver_data = MS_NOGET },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_MOUSE_4500),\n\t\t.driver_data = MS_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_POWER_COVER),\n\t\t.driver_data = MS_HIDINPUT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_KEYBOARD),\n\t\t.driver_data = MS_ERGONOMY},\n\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_BT),\n\t\t.driver_data = MS_PRESENTER },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, 0x091B),\n\t\t.driver_data = MS_SURFACE_DIAL },\n\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_XBOX_CONTROLLER_MODEL_1708),\n\t\t.driver_data = MS_QUIRK_FF },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_XBOX_CONTROLLER_MODEL_1708_BLE),\n\t\t.driver_data = MS_QUIRK_FF },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_XBOX_CONTROLLER_MODEL_1914),\n\t\t.driver_data = MS_QUIRK_FF },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_XBOX_CONTROLLER_MODEL_1797),\n\t\t.driver_data = MS_QUIRK_FF },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_XBOX_CONTROLLER_MODEL_1797_BLE),\n\t\t.driver_data = MS_QUIRK_FF },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_8BITDO_SN30_PRO_PLUS),\n\t\t.driver_data = MS_QUIRK_FF },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ms_devices);\n\nstatic struct hid_driver ms_driver = {\n\t.name = \"microsoft\",\n\t.id_table = ms_devices,\n\t.report_fixup = ms_report_fixup,\n\t.input_mapping = ms_input_mapping,\n\t.input_mapped = ms_input_mapped,\n\t.event = ms_event,\n\t.probe = ms_probe,\n\t.remove = ms_remove,\n};\nmodule_hid_driver(ms_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}