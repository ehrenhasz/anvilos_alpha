{
  "module_name": "hid-saitek.c",
  "hash_id": "8cb926d63fe4cd32218875ad1aa549ac424892ffb79a5659fc14ae133377c2e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hid/hid-saitek.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include \"hid-ids.h\"\n\n#define SAITEK_FIX_PS1000\t0x0001\n#define SAITEK_RELEASE_MODE_RAT7\t0x0002\n#define SAITEK_RELEASE_MODE_MMO7\t0x0004\n\nstruct saitek_sc {\n\tunsigned long quirks;\n\tint mode;\n};\n\nstatic int saitek_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tunsigned long quirks = id->driver_data;\n\tstruct saitek_sc *ssc;\n\tint ret;\n\n\tssc = devm_kzalloc(&hdev->dev, sizeof(*ssc), GFP_KERNEL);\n\tif (ssc == NULL) {\n\t\thid_err(hdev, \"can't alloc saitek descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tssc->quirks = quirks;\n\tssc->mode = -1;\n\n\thid_set_drvdata(hdev, ssc);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic __u8 *saitek_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct saitek_sc *ssc = hid_get_drvdata(hdev);\n\n\tif ((ssc->quirks & SAITEK_FIX_PS1000) && *rsize == 137 &&\n\t\t\trdesc[20] == 0x09 && rdesc[21] == 0x33 &&\n\t\t\trdesc[94] == 0x81 && rdesc[95] == 0x03 &&\n\t\t\trdesc[110] == 0x81 && rdesc[111] == 0x03) {\n\n\t\thid_info(hdev, \"Fixing up Saitek PS1000 report descriptor\\n\");\n\n\t\t \n\t\trdesc[20] = 0x15;\n\t\trdesc[21] = 0x00;\n\n\t\t \n\t\trdesc[95] = 0x02;\n\t\trdesc[111] = 0x02;\n\n\t}\n\treturn rdesc;\n}\n\nstatic int saitek_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct saitek_sc *ssc = hid_get_drvdata(hdev);\n\n\tif (ssc->quirks & SAITEK_RELEASE_MODE_RAT7 && size == 7) {\n\t\t \n\t\tint mode = -1;\n\t\tif (raw_data[1] & 0x01)\n\t\t\tmode = 0;\n\t\telse if (raw_data[1] & 0x02)\n\t\t\tmode = 1;\n\t\telse if (raw_data[1] & 0x04)\n\t\t\tmode = 2;\n\n\t\t \n\t\traw_data[1] &= ~0x07;\n\n\t\tif (mode != ssc->mode) {\n\t\t\thid_dbg(hdev, \"entered mode %d\\n\", mode);\n\t\t\tif (ssc->mode != -1) {\n\t\t\t\t \n\t\t\t\traw_data[1] |= 0x04;\n\t\t\t}\n\t\t\tssc->mode = mode;\n\t\t}\n\t} else if (ssc->quirks & SAITEK_RELEASE_MODE_MMO7 && size == 8) {\n\n\t\t \n\t\tint mode = -1;\n\t\tif (raw_data[1] & 0x80)\n\t\t\tmode = 0;\n\t\telse if (raw_data[2] & 0x01)\n\t\t\tmode = 1;\n\t\telse if (raw_data[2] & 0x02)\n\t\t\tmode = 2;\n\n\t\t \n\t\traw_data[1] &= ~0x80;\n\t\traw_data[2] &= ~0x03;\n\n\t\tif (mode != ssc->mode) {\n\t\t\thid_dbg(hdev, \"entered mode %d\\n\", mode);\n\t\t\tif (ssc->mode != -1) {\n\t\t\t\t \n\t\t\t\traw_data[1] |= 0x80;\n\t\t\t}\n\t\t\tssc->mode = mode;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int saitek_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct saitek_sc *ssc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = field->hidinput->input;\n\n\tif (usage->type == EV_KEY && value &&\n\t\t\t(((ssc->quirks & SAITEK_RELEASE_MODE_RAT7) &&\n\t\t\t  usage->code - BTN_MOUSE == 10) ||\n\t\t\t((ssc->quirks & SAITEK_RELEASE_MODE_MMO7) &&\n\t\t\t usage->code - BTN_MOUSE == 15))) {\n\n\t\tinput_report_key(input, usage->code, 1);\n\n\t\t \n\t\tinput_report_key(input, usage->code, 0);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id saitek_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_PS1000),\n\t\t.driver_data = SAITEK_FIX_PS1000 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_RAT5),\n\t\t.driver_data = SAITEK_RELEASE_MODE_RAT7 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7_OLD),\n\t\t.driver_data = SAITEK_RELEASE_MODE_RAT7 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7),\n\t\t.driver_data = SAITEK_RELEASE_MODE_RAT7 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7_CONTAGION),\n\t\t.driver_data = SAITEK_RELEASE_MODE_RAT7 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT9),\n\t\t.driver_data = SAITEK_RELEASE_MODE_RAT7 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_RAT9),\n\t\t.driver_data = SAITEK_RELEASE_MODE_RAT7 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_MMO7),\n\t\t.driver_data = SAITEK_RELEASE_MODE_MMO7 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_MMO7),\n\t\t.driver_data = SAITEK_RELEASE_MODE_MMO7 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(hid, saitek_devices);\n\nstatic struct hid_driver saitek_driver = {\n\t.name = \"saitek\",\n\t.id_table = saitek_devices,\n\t.probe = saitek_probe,\n\t.report_fixup = saitek_report_fixup,\n\t.raw_event = saitek_raw_event,\n\t.event = saitek_event,\n};\nmodule_hid_driver(saitek_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}