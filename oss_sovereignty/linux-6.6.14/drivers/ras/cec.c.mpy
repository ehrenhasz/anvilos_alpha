{
  "module_name": "cec.c",
  "hash_id": "0d756008c101f32a06158fb0e07a14f6ff2fc4eeeb8a6a20307e43cd74de96ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ras/cec.c",
  "human_readable_source": "\n \n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/ras.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n\n#include <asm/mce.h>\n\n#include \"debugfs.h\"\n\n \n\n#undef pr_fmt\n#define pr_fmt(fmt) \"RAS: \" fmt\n\n \n#define DECAY_BITS\t\t2\n#define DECAY_MASK\t\t((1ULL << DECAY_BITS) - 1)\n#define MAX_ELEMS\t\t(PAGE_SIZE / sizeof(u64))\n\n \n#define CLEAN_ELEMS\t\t(MAX_ELEMS >> DECAY_BITS)\n\n \n#define COUNT_BITS\t\t(PAGE_SHIFT - DECAY_BITS)\n#define COUNT_MASK\t\t((1ULL << COUNT_BITS) - 1)\n#define FULL_COUNT_MASK\t\t(PAGE_SIZE - 1)\n\n \n\n#define PFN(e)\t\t\t((e) >> PAGE_SHIFT)\n#define DECAY(e)\t\t(((e) >> COUNT_BITS) & DECAY_MASK)\n#define COUNT(e)\t\t((unsigned int)(e) & COUNT_MASK)\n#define FULL_COUNT(e)\t\t((e) & (PAGE_SIZE - 1))\n\nstatic struct ce_array {\n\tu64 *array;\t\t\t \n\tunsigned int n;\t\t\t \n\n\tunsigned int decay_count;\t \n\n\tu64 pfns_poisoned;\t\t \n\n\tu64 ces_entered;\t\t \n\n\tu64 decays_done;\t\t \n\n\tunion {\n\t\tstruct {\n\t\t\t__u32\tdisabled : 1,\t \n\t\t\t__resv   : 31;\n\t\t};\n\t\t__u32 flags;\n\t};\n} ce_arr;\n\nstatic DEFINE_MUTEX(ce_mutex);\nstatic u64 dfs_pfn;\n\n \nstatic u64 action_threshold = COUNT_MASK;\n\n \n#define CEC_DECAY_DEFAULT_INTERVAL\t24 * 60 * 60\t \n#define CEC_DECAY_MIN_INTERVAL\t\t 1 * 60 * 60\t \n#define CEC_DECAY_MAX_INTERVAL\t   30 *\t24 * 60 * 60\t \nstatic struct delayed_work cec_work;\nstatic u64 decay_interval = CEC_DECAY_DEFAULT_INTERVAL;\n\n \nstatic void do_spring_cleaning(struct ce_array *ca)\n{\n\tint i;\n\n\tfor (i = 0; i < ca->n; i++) {\n\t\tu8 decay = DECAY(ca->array[i]);\n\n\t\tif (!decay)\n\t\t\tcontinue;\n\n\t\tdecay--;\n\n\t\tca->array[i] &= ~(DECAY_MASK << COUNT_BITS);\n\t\tca->array[i] |= (decay << COUNT_BITS);\n\t}\n\tca->decay_count = 0;\n\tca->decays_done++;\n}\n\n \nstatic void cec_mod_work(unsigned long interval)\n{\n\tunsigned long iv;\n\n\tiv = interval * HZ;\n\tmod_delayed_work(system_wq, &cec_work, round_jiffies(iv));\n}\n\nstatic void cec_work_fn(struct work_struct *work)\n{\n\tmutex_lock(&ce_mutex);\n\tdo_spring_cleaning(&ce_arr);\n\tmutex_unlock(&ce_mutex);\n\n\tcec_mod_work(decay_interval);\n}\n\n \nstatic int __find_elem(struct ce_array *ca, u64 pfn, unsigned int *to)\n{\n\tint min = 0, max = ca->n - 1;\n\tu64 this_pfn;\n\n\twhile (min <= max) {\n\t\tint i = (min + max) >> 1;\n\n\t\tthis_pfn = PFN(ca->array[i]);\n\n\t\tif (this_pfn < pfn)\n\t\t\tmin = i + 1;\n\t\telse if (this_pfn > pfn)\n\t\t\tmax = i - 1;\n\t\telse if (this_pfn == pfn) {\n\t\t\tif (to)\n\t\t\t\t*to = i;\n\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t \n\tif (to)\n\t\t*to = min;\n\n\treturn -ENOKEY;\n}\n\nstatic int find_elem(struct ce_array *ca, u64 pfn, unsigned int *to)\n{\n\tWARN_ON(!to);\n\n\tif (!ca->n) {\n\t\t*to = 0;\n\t\treturn -ENOKEY;\n\t}\n\treturn __find_elem(ca, pfn, to);\n}\n\nstatic void del_elem(struct ce_array *ca, int idx)\n{\n\t \n\tif (ca->n - (idx + 1))\n\t\tmemmove((void *)&ca->array[idx],\n\t\t\t(void *)&ca->array[idx + 1],\n\t\t\t(ca->n - (idx + 1)) * sizeof(u64));\n\n\tca->n--;\n}\n\nstatic u64 del_lru_elem_unlocked(struct ce_array *ca)\n{\n\tunsigned int min = FULL_COUNT_MASK;\n\tint i, min_idx = 0;\n\n\tfor (i = 0; i < ca->n; i++) {\n\t\tunsigned int this = FULL_COUNT(ca->array[i]);\n\n\t\tif (min > this) {\n\t\t\tmin = this;\n\t\t\tmin_idx = i;\n\t\t}\n\t}\n\n\tdel_elem(ca, min_idx);\n\n\treturn PFN(ca->array[min_idx]);\n}\n\n \nstatic u64 __maybe_unused del_lru_elem(void)\n{\n\tstruct ce_array *ca = &ce_arr;\n\tu64 pfn;\n\n\tif (!ca->n)\n\t\treturn 0;\n\n\tmutex_lock(&ce_mutex);\n\tpfn = del_lru_elem_unlocked(ca);\n\tmutex_unlock(&ce_mutex);\n\n\treturn pfn;\n}\n\nstatic bool sanity_check(struct ce_array *ca)\n{\n\tbool ret = false;\n\tu64 prev = 0;\n\tint i;\n\n\tfor (i = 0; i < ca->n; i++) {\n\t\tu64 this = PFN(ca->array[i]);\n\n\t\tif (WARN(prev > this, \"prev: 0x%016llx <-> this: 0x%016llx\\n\", prev, this))\n\t\t\tret = true;\n\n\t\tprev = this;\n\t}\n\n\tif (!ret)\n\t\treturn ret;\n\n\tpr_info(\"Sanity check dump:\\n{ n: %d\\n\", ca->n);\n\tfor (i = 0; i < ca->n; i++) {\n\t\tu64 this = PFN(ca->array[i]);\n\n\t\tpr_info(\" %03d: [%016llx|%03llx]\\n\", i, this, FULL_COUNT(ca->array[i]));\n\t}\n\tpr_info(\"}\\n\");\n\n\treturn ret;\n}\n\n \nstatic int cec_add_elem(u64 pfn)\n{\n\tstruct ce_array *ca = &ce_arr;\n\tint count, err, ret = 0;\n\tunsigned int to = 0;\n\n\t \n\tif (!ce_arr.array || ce_arr.disabled)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&ce_mutex);\n\n\tca->ces_entered++;\n\n\t \n\tif (ca->n == MAX_ELEMS)\n\t\tWARN_ON(!del_lru_elem_unlocked(ca));\n\n\terr = find_elem(ca, pfn, &to);\n\tif (err < 0) {\n\t\t \n\t\tmemmove((void *)&ca->array[to + 1],\n\t\t\t(void *)&ca->array[to],\n\t\t\t(ca->n - to) * sizeof(u64));\n\n\t\tca->array[to] = pfn << PAGE_SHIFT;\n\t\tca->n++;\n\t}\n\n\t \n\tca->array[to] |= DECAY_MASK << COUNT_BITS;\n\tca->array[to]++;\n\n\t \n\tcount = COUNT(ca->array[to]);\n\tif (count >= action_threshold) {\n\t\tu64 pfn = ca->array[to] >> PAGE_SHIFT;\n\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpr_warn(\"CEC: Invalid pfn: 0x%llx\\n\", pfn);\n\t\t} else {\n\t\t\t \n\t\t\tpr_err(\"Soft-offlining pfn: 0x%llx\\n\", pfn);\n\t\t\tmemory_failure_queue(pfn, MF_SOFT_OFFLINE);\n\t\t\tca->pfns_poisoned++;\n\t\t}\n\n\t\tdel_elem(ca, to);\n\n\t\t \n\t\tret = 1;\n\n\t\tgoto unlock;\n\t}\n\n\tca->decay_count++;\n\n\tif (ca->decay_count >= CLEAN_ELEMS)\n\t\tdo_spring_cleaning(ca);\n\n\tWARN_ON_ONCE(sanity_check(ca));\n\nunlock:\n\tmutex_unlock(&ce_mutex);\n\n\treturn ret;\n}\n\nstatic int u64_get(void *data, u64 *val)\n{\n\t*val = *(u64 *)data;\n\n\treturn 0;\n}\n\nstatic int pfn_set(void *data, u64 val)\n{\n\t*(u64 *)data = val;\n\n\tcec_add_elem(val);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(pfn_ops, u64_get, pfn_set, \"0x%llx\\n\");\n\nstatic int decay_interval_set(void *data, u64 val)\n{\n\tif (val < CEC_DECAY_MIN_INTERVAL)\n\t\treturn -EINVAL;\n\n\tif (val > CEC_DECAY_MAX_INTERVAL)\n\t\treturn -EINVAL;\n\n\t*(u64 *)data   = val;\n\tdecay_interval = val;\n\n\tcec_mod_work(decay_interval);\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(decay_interval_ops, u64_get, decay_interval_set, \"%lld\\n\");\n\nstatic int action_threshold_set(void *data, u64 val)\n{\n\t*(u64 *)data = val;\n\n\tif (val > COUNT_MASK)\n\t\tval = COUNT_MASK;\n\n\taction_threshold = val;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(action_threshold_ops, u64_get, action_threshold_set, \"%lld\\n\");\n\nstatic const char * const bins[] = { \"00\", \"01\", \"10\", \"11\" };\n\nstatic int array_show(struct seq_file *m, void *v)\n{\n\tstruct ce_array *ca = &ce_arr;\n\tint i;\n\n\tmutex_lock(&ce_mutex);\n\n\tseq_printf(m, \"{ n: %d\\n\", ca->n);\n\tfor (i = 0; i < ca->n; i++) {\n\t\tu64 this = PFN(ca->array[i]);\n\n\t\tseq_printf(m, \" %3d: [%016llx|%s|%03llx]\\n\",\n\t\t\t   i, this, bins[DECAY(ca->array[i])], COUNT(ca->array[i]));\n\t}\n\n\tseq_printf(m, \"}\\n\");\n\n\tseq_printf(m, \"Stats:\\nCEs: %llu\\nofflined pages: %llu\\n\",\n\t\t   ca->ces_entered, ca->pfns_poisoned);\n\n\tseq_printf(m, \"Flags: 0x%x\\n\", ca->flags);\n\n\tseq_printf(m, \"Decay interval: %lld seconds\\n\", decay_interval);\n\tseq_printf(m, \"Decays: %lld\\n\", ca->decays_done);\n\n\tseq_printf(m, \"Action threshold: %lld\\n\", action_threshold);\n\n\tmutex_unlock(&ce_mutex);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(array);\n\nstatic int __init create_debugfs_nodes(void)\n{\n\tstruct dentry *d, *pfn, *decay, *count, *array;\n\n\td = debugfs_create_dir(\"cec\", ras_debugfs_dir);\n\tif (!d) {\n\t\tpr_warn(\"Error creating cec debugfs node!\\n\");\n\t\treturn -1;\n\t}\n\n\tdecay = debugfs_create_file(\"decay_interval\", S_IRUSR | S_IWUSR, d,\n\t\t\t\t    &decay_interval, &decay_interval_ops);\n\tif (!decay) {\n\t\tpr_warn(\"Error creating decay_interval debugfs node!\\n\");\n\t\tgoto err;\n\t}\n\n\tcount = debugfs_create_file(\"action_threshold\", S_IRUSR | S_IWUSR, d,\n\t\t\t\t    &action_threshold, &action_threshold_ops);\n\tif (!count) {\n\t\tpr_warn(\"Error creating action_threshold debugfs node!\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_RAS_CEC_DEBUG))\n\t\treturn 0;\n\n\tpfn = debugfs_create_file(\"pfn\", S_IRUSR | S_IWUSR, d, &dfs_pfn, &pfn_ops);\n\tif (!pfn) {\n\t\tpr_warn(\"Error creating pfn debugfs node!\\n\");\n\t\tgoto err;\n\t}\n\n\tarray = debugfs_create_file(\"array\", S_IRUSR, d, NULL, &array_fops);\n\tif (!array) {\n\t\tpr_warn(\"Error creating array debugfs node!\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdebugfs_remove_recursive(d);\n\n\treturn 1;\n}\n\nstatic int cec_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\tvoid *data)\n{\n\tstruct mce *m = (struct mce *)data;\n\n\tif (!m)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (mce_is_memory_error(m) &&\n\t    mce_is_correctable(m)  &&\n\t    mce_usable_address(m)) {\n\t\tif (!cec_add_elem(m->addr >> PAGE_SHIFT)) {\n\t\t\tm->kflags |= MCE_HANDLED_CEC;\n\t\t\treturn NOTIFY_OK;\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block cec_nb = {\n\t.notifier_call\t= cec_notifier,\n\t.priority\t= MCE_PRIO_CEC,\n};\n\nstatic int __init cec_init(void)\n{\n\tif (ce_arr.disabled)\n\t\treturn -ENODEV;\n\n\t \n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL)\n\t\taction_threshold = 2;\n\n\tce_arr.array = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!ce_arr.array) {\n\t\tpr_err(\"Error allocating CE array page!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (create_debugfs_nodes()) {\n\t\tfree_page((unsigned long)ce_arr.array);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&cec_work, cec_work_fn);\n\tschedule_delayed_work(&cec_work, CEC_DECAY_DEFAULT_INTERVAL);\n\n\tmce_register_decode_chain(&cec_nb);\n\n\tpr_info(\"Correctable Errors collector initialized.\\n\");\n\treturn 0;\n}\nlate_initcall(cec_init);\n\nint __init parse_cec_param(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (*str == '=')\n\t\tstr++;\n\n\tif (!strcmp(str, \"cec_disable\"))\n\t\tce_arr.disabled = 1;\n\telse\n\t\treturn 0;\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}