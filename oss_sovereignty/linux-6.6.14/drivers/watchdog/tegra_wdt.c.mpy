{
  "module_name": "tegra_wdt.c",
  "hash_id": "ffc82cb309960741fd52bbd9888ff5c88b860bcd4ea3bb5e2aa719f865c3988e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/tegra_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n \n#define MIN_WDT_TIMEOUT\t\t\t1\n#define MAX_WDT_TIMEOUT\t\t\t255\n\n \n#define WDT_BASE\t\t\t0x100\n#define WDT_ID\t\t\t\t0\n\n \n#define WDT_TIMER_BASE\t\t\t0x60\n#define WDT_TIMER_ID\t\t\t5\n\n \n#define WDT_CFG\t\t\t\t0x0\n#define WDT_CFG_PERIOD_SHIFT\t\t4\n#define WDT_CFG_PERIOD_MASK\t\t0xff\n#define WDT_CFG_INT_EN\t\t\t(1 << 12)\n#define WDT_CFG_PMC2CAR_RST_EN\t\t(1 << 15)\n#define WDT_STS\t\t\t\t0x4\n#define WDT_STS_COUNT_SHIFT\t\t4\n#define WDT_STS_COUNT_MASK\t\t0xff\n#define WDT_STS_EXP_SHIFT\t\t12\n#define WDT_STS_EXP_MASK\t\t0x3\n#define WDT_CMD\t\t\t\t0x8\n#define WDT_CMD_START_COUNTER\t\t(1 << 0)\n#define WDT_CMD_DISABLE_COUNTER\t\t(1 << 1)\n#define WDT_UNLOCK\t\t\t(0xc)\n#define WDT_UNLOCK_PATTERN\t\t(0xc45a << 0)\n\n \n#define TIMER_PTV\t\t\t0x0\n#define TIMER_EN\t\t\t(1 << 31)\n#define TIMER_PERIODIC\t\t\t(1 << 30)\n\nstruct tegra_wdt {\n\tstruct watchdog_device\twdd;\n\tvoid __iomem\t\t*wdt_regs;\n\tvoid __iomem\t\t*tmr_regs;\n};\n\n#define WDT_HEARTBEAT 120\nstatic int heartbeat = WDT_HEARTBEAT;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\"Watchdog heartbeats in seconds. (default = \"\n\t__MODULE_STRING(WDT_HEARTBEAT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int tegra_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct tegra_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu32 val;\n\n\t \n\tval = 1000000ul / 4;\n\tval |= (TIMER_EN | TIMER_PERIODIC);\n\twritel(val, wdt->tmr_regs + TIMER_PTV);\n\n\t \n\tval = WDT_TIMER_ID |\n\t      (wdd->timeout << WDT_CFG_PERIOD_SHIFT) |\n\t      WDT_CFG_PMC2CAR_RST_EN;\n\twritel(val, wdt->wdt_regs + WDT_CFG);\n\n\twritel(WDT_CMD_START_COUNTER, wdt->wdt_regs + WDT_CMD);\n\n\treturn 0;\n}\n\nstatic int tegra_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct tegra_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twritel(WDT_UNLOCK_PATTERN, wdt->wdt_regs + WDT_UNLOCK);\n\twritel(WDT_CMD_DISABLE_COUNTER, wdt->wdt_regs + WDT_CMD);\n\twritel(0, wdt->tmr_regs + TIMER_PTV);\n\n\treturn 0;\n}\n\nstatic int tegra_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct tegra_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twritel(WDT_CMD_START_COUNTER, wdt->wdt_regs + WDT_CMD);\n\n\treturn 0;\n}\n\nstatic int tegra_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t unsigned int timeout)\n{\n\twdd->timeout = timeout;\n\n\tif (watchdog_active(wdd)) {\n\t\ttegra_wdt_stop(wdd);\n\t\treturn tegra_wdt_start(wdd);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int tegra_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct tegra_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu32 val;\n\tint count;\n\tint exp;\n\n\tval = readl(wdt->wdt_regs + WDT_STS);\n\n\t \n\tcount = (val >> WDT_STS_COUNT_SHIFT) & WDT_STS_COUNT_MASK;\n\n\t \n\texp = (val >> WDT_STS_EXP_SHIFT) & WDT_STS_EXP_MASK;\n\n\t \n\treturn (((3 - exp) * wdd->timeout) + count) / 4;\n}\n\nstatic const struct watchdog_info tegra_wdt_info = {\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_MAGICCLOSE |\n\t\t\t  WDIOF_KEEPALIVEPING,\n\t.firmware_version = 0,\n\t.identity\t= \"Tegra Watchdog\",\n};\n\nstatic const struct watchdog_ops tegra_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = tegra_wdt_start,\n\t.stop = tegra_wdt_stop,\n\t.ping = tegra_wdt_ping,\n\t.set_timeout = tegra_wdt_set_timeout,\n\t.get_timeleft = tegra_wdt_get_timeleft,\n};\n\nstatic int tegra_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct tegra_wdt *wdt;\n\tvoid __iomem *regs;\n\tint ret;\n\n\t \n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\t \n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\t \n\twdt->wdt_regs = regs + WDT_BASE;\n\twdt->tmr_regs = regs + WDT_TIMER_BASE;\n\n\t \n\twdd = &wdt->wdd;\n\twdd->timeout = heartbeat;\n\twdd->info = &tegra_wdt_info;\n\twdd->ops = &tegra_wdt_ops;\n\twdd->min_timeout = MIN_WDT_TIMEOUT;\n\twdd->max_timeout = MAX_WDT_TIMEOUT;\n\twdd->parent = dev;\n\n\twatchdog_set_drvdata(wdd, wdt);\n\n\twatchdog_set_nowayout(wdd, nowayout);\n\n\twatchdog_stop_on_unregister(wdd);\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\tdev_info(dev, \"initialized (heartbeat = %d sec, nowayout = %d)\\n\",\n\t\t heartbeat, nowayout);\n\n\treturn 0;\n}\n\nstatic int tegra_wdt_suspend(struct device *dev)\n{\n\tstruct tegra_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\ttegra_wdt_stop(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic int tegra_wdt_resume(struct device *dev)\n{\n\tstruct tegra_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\ttegra_wdt_start(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra_wdt_of_match[] = {\n\t{ .compatible = \"nvidia,tegra30-timer\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_wdt_of_match);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tegra_wdt_pm_ops,\n\t\t\t\ttegra_wdt_suspend, tegra_wdt_resume);\n\nstatic struct platform_driver tegra_wdt_driver = {\n\t.probe\t\t= tegra_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"tegra-wdt\",\n\t\t.pm\t= pm_sleep_ptr(&tegra_wdt_pm_ops),\n\t\t.of_match_table = tegra_wdt_of_match,\n\t},\n};\nmodule_platform_driver(tegra_wdt_driver);\n\nMODULE_AUTHOR(\"NVIDIA Corporation\");\nMODULE_DESCRIPTION(\"Tegra Watchdog Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}