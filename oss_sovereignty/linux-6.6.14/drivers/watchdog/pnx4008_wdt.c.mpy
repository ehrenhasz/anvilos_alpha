{
  "module_name": "pnx4008_wdt.c",
  "hash_id": "8f7da8732f1a3e6b48cd3f1d4594194cb245cb40ba484d55f4e4d71b1cb3cfaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pnx4008_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n\n \n\n#define DEFAULT_HEARTBEAT 19\n#define MAX_HEARTBEAT     60\n\n \n#define WDTIM_INT(p)     ((p) + 0x0)\n#define WDTIM_CTRL(p)    ((p) + 0x4)\n#define WDTIM_COUNTER(p) ((p) + 0x8)\n#define WDTIM_MCTRL(p)   ((p) + 0xC)\n#define WDTIM_MATCH0(p)  ((p) + 0x10)\n#define WDTIM_EMR(p)     ((p) + 0x14)\n#define WDTIM_PULSE(p)   ((p) + 0x18)\n#define WDTIM_RES(p)     ((p) + 0x1C)\n\n \n#define MATCH_INT      1\n\n \n#define COUNT_ENAB     1\n#define RESET_COUNT    (1 << 1)\n#define DEBUG_EN       (1 << 2)\n\n \n#define MR0_INT        1\n#undef  RESET_COUNT0\n#define RESET_COUNT0   (1 << 2)\n#define STOP_COUNT0    (1 << 2)\n#define M_RES1         (1 << 3)\n#define M_RES2         (1 << 4)\n#define RESFRC1        (1 << 5)\n#define RESFRC2        (1 << 6)\n\n \n#define EXT_MATCH0      1\n#define MATCH_OUTPUT_HIGH (2 << 4)\t \n\n \n#define WDOG_RESET      1\t \n\n#define WDOG_COUNTER_RATE 13000000\t \n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic unsigned int heartbeat;\n\nstatic DEFINE_SPINLOCK(io_lock);\nstatic void __iomem\t*wdt_base;\nstatic struct clk\t*wdt_clk;\n\nstatic int pnx4008_wdt_start(struct watchdog_device *wdd)\n{\n\tspin_lock(&io_lock);\n\n\t \n\twritel(RESET_COUNT, WDTIM_CTRL(wdt_base));\n\t \n\twhile (readl(WDTIM_COUNTER(wdt_base)))\n\t\tcpu_relax();\n\t \n\twritel(M_RES2 | STOP_COUNT0 | RESET_COUNT0, WDTIM_MCTRL(wdt_base));\n\t \n\twritel(MATCH_OUTPUT_HIGH, WDTIM_EMR(wdt_base));\n\t \n\twritel(MATCH_INT, WDTIM_INT(wdt_base));\n\t \n\twritel(0xFFFF, WDTIM_PULSE(wdt_base));\n\twritel(wdd->timeout * WDOG_COUNTER_RATE, WDTIM_MATCH0(wdt_base));\n\t \n\twritel(COUNT_ENAB | DEBUG_EN, WDTIM_CTRL(wdt_base));\n\n\tspin_unlock(&io_lock);\n\treturn 0;\n}\n\nstatic int pnx4008_wdt_stop(struct watchdog_device *wdd)\n{\n\tspin_lock(&io_lock);\n\n\twritel(0, WDTIM_CTRL(wdt_base));\t \n\n\tspin_unlock(&io_lock);\n\treturn 0;\n}\n\nstatic int pnx4008_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t    unsigned int new_timeout)\n{\n\twdd->timeout = new_timeout;\n\treturn 0;\n}\n\nstatic int pnx4008_restart_handler(struct watchdog_device *wdd,\n\t\t\t\t   unsigned long mode, void *cmd)\n{\n\tconst char *boot_cmd = cmd;\n\n\t \n\tif (boot_cmd) {\n\t\tif (boot_cmd[0] == 'h')\n\t\t\tmode = REBOOT_HARD;\n\t\telse if (boot_cmd[0] == 's')\n\t\t\tmode = REBOOT_SOFT;\n\t}\n\n\tif (mode == REBOOT_SOFT) {\n\t\t \n\t\twritel(EXT_MATCH0, WDTIM_EMR(wdt_base));\n\t\t \n\t\twritel(M_RES1, WDTIM_MCTRL(wdt_base));\n\t} else {\n\t\t \n\t\twritel(13000, WDTIM_PULSE(wdt_base));\n\t\twritel(M_RES2 | RESFRC1 | RESFRC2, WDTIM_MCTRL(wdt_base));\n\t}\n\n\t \n\tmdelay(1000);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct watchdog_info pnx4008_wdt_ident = {\n\t.options = WDIOF_CARDRESET | WDIOF_MAGICCLOSE |\n\t    WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n\t.identity = \"PNX4008 Watchdog\",\n};\n\nstatic const struct watchdog_ops pnx4008_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = pnx4008_wdt_start,\n\t.stop = pnx4008_wdt_stop,\n\t.set_timeout = pnx4008_wdt_set_timeout,\n\t.restart = pnx4008_restart_handler,\n};\n\nstatic struct watchdog_device pnx4008_wdd = {\n\t.info = &pnx4008_wdt_ident,\n\t.ops = &pnx4008_wdt_ops,\n\t.timeout = DEFAULT_HEARTBEAT,\n\t.min_timeout = 1,\n\t.max_timeout = MAX_HEARTBEAT,\n};\n\nstatic int pnx4008_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret = 0;\n\n\twatchdog_init_timeout(&pnx4008_wdd, heartbeat, dev);\n\n\twdt_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt_base))\n\t\treturn PTR_ERR(wdt_base);\n\n\twdt_clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(wdt_clk))\n\t\treturn PTR_ERR(wdt_clk);\n\n\tpnx4008_wdd.bootstatus = (readl(WDTIM_RES(wdt_base)) & WDOG_RESET) ?\n\t\t\tWDIOF_CARDRESET : 0;\n\tpnx4008_wdd.parent = dev;\n\twatchdog_set_nowayout(&pnx4008_wdd, nowayout);\n\twatchdog_set_restart_priority(&pnx4008_wdd, 128);\n\n\tif (readl(WDTIM_CTRL(wdt_base)) & COUNT_ENAB)\n\t\tset_bit(WDOG_HW_RUNNING, &pnx4008_wdd.status);\n\n\tret = devm_watchdog_register_device(dev, &pnx4008_wdd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, \"heartbeat %d sec\\n\", pnx4008_wdd.timeout);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pnx4008_wdt_match[] = {\n\t{ .compatible = \"nxp,pnx4008-wdt\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pnx4008_wdt_match);\n#endif\n\nstatic struct platform_driver platform_wdt_driver = {\n\t.driver = {\n\t\t.name = \"pnx4008-watchdog\",\n\t\t.of_match_table = of_match_ptr(pnx4008_wdt_match),\n\t},\n\t.probe = pnx4008_wdt_probe,\n};\n\nmodule_platform_driver(platform_wdt_driver);\n\nMODULE_AUTHOR(\"MontaVista Software, Inc. <source@mvista.com>\");\nMODULE_AUTHOR(\"Wolfram Sang <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"PNX4008 Watchdog Driver\");\n\nmodule_param(heartbeat, uint, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\t \"Watchdog heartbeat period in seconds from 1 to \"\n\t\t __MODULE_STRING(MAX_HEARTBEAT) \", default \"\n\t\t __MODULE_STRING(DEFAULT_HEARTBEAT));\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Set to 1 to keep watchdog running after device release\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pnx4008-watchdog\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}