{
  "module_name": "via_wdt.c",
  "hash_id": "20e5c1374da842c1e7606f1f404885e8aa84ec75641fd2f683a2da1bbf805bd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/via_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/timer.h>\n#include <linux/watchdog.h>\n\n \n#define VIA_WDT_MMIO_BASE\t0xe8\t \n#define VIA_WDT_CONF\t\t0xec\t \n\n \n#define VIA_WDT_CONF_ENABLE\t0x01\t \n#define VIA_WDT_CONF_MMIO\t0x02\t \n\n \n#define VIA_WDT_MMIO_LEN\t8\t \n#define VIA_WDT_CTL\t\t0\t \n#define VIA_WDT_COUNT\t\t4\t \n\n \n#define VIA_WDT_RUNNING\t\t0x01\t \n#define VIA_WDT_FIRED\t\t0x02\t \n#define VIA_WDT_PWROFF\t\t0x04\t \n#define VIA_WDT_DISABLED\t0x08\t \n#define VIA_WDT_TRIGGER\t\t0x80\t \n\n \n#define WDT_HW_HEARTBEAT 1\n\n \n#define WDT_HEARTBEAT\t(HZ/2)\t \n\n \n#define WDT_TIMEOUT_MAX\t1023\t \n#define WDT_TIMEOUT\t60\nstatic int timeout = WDT_TIMEOUT;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds, between 1 and 1023 \"\n\t\"(default = \" __MODULE_STRING(WDT_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\"(default = \" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic struct watchdog_device wdt_dev;\nstatic struct resource wdt_res;\nstatic void __iomem *wdt_mem;\nstatic unsigned int mmio;\nstatic void wdt_timer_tick(struct timer_list *unused);\nstatic DEFINE_TIMER(timer, wdt_timer_tick);\n\t\t\t\t\t \nstatic unsigned long next_heartbeat;\t \n\nstatic inline void wdt_reset(void)\n{\n\tunsigned int ctl = readl(wdt_mem);\n\n\twritel(ctl | VIA_WDT_TRIGGER, wdt_mem);\n}\n\n \nstatic void wdt_timer_tick(struct timer_list *unused)\n{\n\tif (time_before(jiffies, next_heartbeat) ||\n\t   (!watchdog_active(&wdt_dev))) {\n\t\twdt_reset();\n\t\tmod_timer(&timer, jiffies + WDT_HEARTBEAT);\n\t} else\n\t\tpr_crit(\"I will reboot your machine !\\n\");\n}\n\nstatic int wdt_ping(struct watchdog_device *wdd)\n{\n\t \n\tnext_heartbeat = jiffies + wdd->timeout * HZ;\n\treturn 0;\n}\n\nstatic int wdt_start(struct watchdog_device *wdd)\n{\n\tunsigned int ctl = readl(wdt_mem);\n\n\twritel(wdd->timeout, wdt_mem + VIA_WDT_COUNT);\n\twritel(ctl | VIA_WDT_RUNNING | VIA_WDT_TRIGGER, wdt_mem);\n\twdt_ping(wdd);\n\tmod_timer(&timer, jiffies + WDT_HEARTBEAT);\n\treturn 0;\n}\n\nstatic int wdt_stop(struct watchdog_device *wdd)\n{\n\tunsigned int ctl = readl(wdt_mem);\n\n\twritel(ctl & ~VIA_WDT_RUNNING, wdt_mem);\n\treturn 0;\n}\n\nstatic int wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t   unsigned int new_timeout)\n{\n\twritel(new_timeout, wdt_mem + VIA_WDT_COUNT);\n\twdd->timeout = new_timeout;\n\treturn 0;\n}\n\nstatic const struct watchdog_info wdt_info = {\n\t.identity =\t\"VIA watchdog\",\n\t.options =\tWDIOF_CARDRESET |\n\t\t\tWDIOF_SETTIMEOUT |\n\t\t\tWDIOF_MAGICCLOSE |\n\t\t\tWDIOF_KEEPALIVEPING,\n};\n\nstatic const struct watchdog_ops wdt_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.start =\twdt_start,\n\t.stop =\t\twdt_stop,\n\t.ping =\t\twdt_ping,\n\t.set_timeout =\twdt_set_timeout,\n};\n\nstatic struct watchdog_device wdt_dev = {\n\t.info =\t\t&wdt_info,\n\t.ops =\t\t&wdt_ops,\n\t.min_timeout =\t1,\n\t.max_timeout =\tWDT_TIMEOUT_MAX,\n};\n\nstatic int wdt_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent)\n{\n\tunsigned char conf;\n\tint ret = -ENODEV;\n\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev, \"cannot enable PCI device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (allocate_resource(&iomem_resource, &wdt_res, VIA_WDT_MMIO_LEN,\n\t\t\t      0xf0000000, 0xffffff00, 0xff, NULL, NULL)) {\n\t\tdev_err(&pdev->dev, \"MMIO allocation failed\\n\");\n\t\tgoto err_out_disable_device;\n\t}\n\n\tpci_write_config_dword(pdev, VIA_WDT_MMIO_BASE, wdt_res.start);\n\tpci_read_config_byte(pdev, VIA_WDT_CONF, &conf);\n\tconf |= VIA_WDT_CONF_ENABLE | VIA_WDT_CONF_MMIO;\n\tpci_write_config_byte(pdev, VIA_WDT_CONF, conf);\n\n\tpci_read_config_dword(pdev, VIA_WDT_MMIO_BASE, &mmio);\n\tif (mmio) {\n\t\tdev_info(&pdev->dev, \"VIA Chipset watchdog MMIO: %x\\n\", mmio);\n\t} else {\n\t\tdev_err(&pdev->dev, \"MMIO setting failed. Check BIOS.\\n\");\n\t\tgoto err_out_resource;\n\t}\n\n\tif (!request_mem_region(mmio, VIA_WDT_MMIO_LEN, \"via_wdt\")) {\n\t\tdev_err(&pdev->dev, \"MMIO region busy\\n\");\n\t\tgoto err_out_resource;\n\t}\n\n\twdt_mem = ioremap(mmio, VIA_WDT_MMIO_LEN);\n\tif (wdt_mem == NULL) {\n\t\tdev_err(&pdev->dev, \"cannot remap VIA wdt MMIO registers\\n\");\n\t\tgoto err_out_release;\n\t}\n\n\tif (timeout < 1 || timeout > WDT_TIMEOUT_MAX)\n\t\ttimeout = WDT_TIMEOUT;\n\n\twdt_dev.timeout = timeout;\n\twdt_dev.parent = &pdev->dev;\n\twatchdog_set_nowayout(&wdt_dev, nowayout);\n\tif (readl(wdt_mem) & VIA_WDT_FIRED)\n\t\twdt_dev.bootstatus |= WDIOF_CARDRESET;\n\n\tret = watchdog_register_device(&wdt_dev);\n\tif (ret)\n\t\tgoto err_out_iounmap;\n\n\t \n\tmod_timer(&timer, jiffies + WDT_HEARTBEAT);\n\treturn 0;\n\nerr_out_iounmap:\n\tiounmap(wdt_mem);\nerr_out_release:\n\trelease_mem_region(mmio, VIA_WDT_MMIO_LEN);\nerr_out_resource:\n\trelease_resource(&wdt_res);\nerr_out_disable_device:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void wdt_remove(struct pci_dev *pdev)\n{\n\twatchdog_unregister_device(&wdt_dev);\n\tdel_timer_sync(&timer);\n\tiounmap(wdt_mem);\n\trelease_mem_region(mmio, VIA_WDT_MMIO_LEN);\n\trelease_resource(&wdt_res);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id wdt_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_CX700) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_VX800) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_VX855) },\n\t{ 0 }\n};\n\nstatic struct pci_driver wdt_driver = {\n\t.name\t\t= \"via_wdt\",\n\t.id_table\t= wdt_pci_table,\n\t.probe\t\t= wdt_probe,\n\t.remove\t\t= wdt_remove,\n};\n\nmodule_pci_driver(wdt_driver);\n\nMODULE_AUTHOR(\"Marc Vertes\");\nMODULE_DESCRIPTION(\"Driver for watchdog timer on VIA chipset\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}