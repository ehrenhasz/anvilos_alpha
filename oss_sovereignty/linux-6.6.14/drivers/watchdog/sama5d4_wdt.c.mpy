{
  "module_name": "sama5d4_wdt.c",
  "hash_id": "0d34ec76ab30222c31f15c16716ce33f0ca0dad34efa12f5e438ff445efab827",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sama5d4_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/watchdog.h>\n\n#include \"at91sam9_wdt.h\"\n\n \n#define MIN_WDT_TIMEOUT\t\t1\n#define MAX_WDT_TIMEOUT\t\t16\n#define WDT_DEFAULT_TIMEOUT\tMAX_WDT_TIMEOUT\n\n#define WDT_SEC2TICKS(s)\t((s) ? (((s) << 8) - 1) : 0)\n\nstruct sama5d4_wdt {\n\tstruct watchdog_device\twdd;\n\tvoid __iomem\t\t*reg_base;\n\tu32\t\t\tmr;\n\tu32\t\t\tir;\n\tunsigned long\t\tlast_ping;\n\tbool\t\t\tneed_irq;\n\tbool\t\t\tsam9x60_support;\n};\n\nstatic int wdt_timeout;\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\nmodule_param(wdt_timeout, int, 0);\nMODULE_PARM_DESC(wdt_timeout,\n\t\"Watchdog timeout in seconds. (default = \"\n\t__MODULE_STRING(WDT_DEFAULT_TIMEOUT) \")\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n#define wdt_enabled (!(wdt->mr & AT91_WDT_WDDIS))\n\n#define wdt_read(wdt, field) \\\n\treadl_relaxed((wdt)->reg_base + (field))\n\n \n#define WDT_DELAY\tusecs_to_jiffies(123)\n\nstatic void wdt_write(struct sama5d4_wdt *wdt, u32 field, u32 val)\n{\n\t \n\twhile (time_before(jiffies, wdt->last_ping + WDT_DELAY))\n\t\tusleep_range(30, 125);\n\twritel_relaxed(val, wdt->reg_base + field);\n\twdt->last_ping = jiffies;\n}\n\nstatic void wdt_write_nosleep(struct sama5d4_wdt *wdt, u32 field, u32 val)\n{\n\tif (time_before(jiffies, wdt->last_ping + WDT_DELAY))\n\t\tudelay(123);\n\twritel_relaxed(val, wdt->reg_base + field);\n\twdt->last_ping = jiffies;\n}\n\nstatic int sama5d4_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct sama5d4_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tif (wdt->sam9x60_support) {\n\t\twritel_relaxed(wdt->ir, wdt->reg_base + AT91_SAM9X60_IER);\n\t\twdt->mr &= ~AT91_SAM9X60_WDDIS;\n\t} else {\n\t\twdt->mr &= ~AT91_WDT_WDDIS;\n\t}\n\twdt_write(wdt, AT91_WDT_MR, wdt->mr);\n\n\treturn 0;\n}\n\nstatic int sama5d4_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct sama5d4_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tif (wdt->sam9x60_support) {\n\t\twritel_relaxed(wdt->ir, wdt->reg_base + AT91_SAM9X60_IDR);\n\t\twdt->mr |= AT91_SAM9X60_WDDIS;\n\t} else {\n\t\twdt->mr |= AT91_WDT_WDDIS;\n\t}\n\twdt_write(wdt, AT91_WDT_MR, wdt->mr);\n\n\treturn 0;\n}\n\nstatic int sama5d4_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct sama5d4_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twdt_write(wdt, AT91_WDT_CR, AT91_WDT_KEY | AT91_WDT_WDRSTT);\n\n\treturn 0;\n}\n\nstatic int sama5d4_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t unsigned int timeout)\n{\n\tstruct sama5d4_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu32 value = WDT_SEC2TICKS(timeout);\n\n\tif (wdt->sam9x60_support) {\n\t\twdt_write(wdt, AT91_SAM9X60_WLR,\n\t\t\t  AT91_SAM9X60_SET_COUNTER(value));\n\n\t\twdd->timeout = timeout;\n\t\treturn 0;\n\t}\n\n\twdt->mr &= ~AT91_WDT_WDV;\n\twdt->mr |= AT91_WDT_SET_WDV(value);\n\n\t \n\tif (wdt_enabled)\n\t\twdt_write(wdt, AT91_WDT_MR, wdt->mr & ~AT91_WDT_WDDIS);\n\n\twdd->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info sama5d4_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"Atmel SAMA5D4 Watchdog\",\n};\n\nstatic const struct watchdog_ops sama5d4_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = sama5d4_wdt_start,\n\t.stop = sama5d4_wdt_stop,\n\t.ping = sama5d4_wdt_ping,\n\t.set_timeout = sama5d4_wdt_set_timeout,\n};\n\nstatic irqreturn_t sama5d4_wdt_irq_handler(int irq, void *dev_id)\n{\n\tstruct sama5d4_wdt *wdt = platform_get_drvdata(dev_id);\n\tu32 reg;\n\n\tif (wdt->sam9x60_support)\n\t\treg = wdt_read(wdt, AT91_SAM9X60_ISR);\n\telse\n\t\treg = wdt_read(wdt, AT91_WDT_SR);\n\n\tif (reg) {\n\t\tpr_crit(\"Atmel Watchdog Software Reset\\n\");\n\t\temergency_restart();\n\t\tpr_crit(\"Reboot didn't succeed\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int of_sama5d4_wdt_init(struct device_node *np, struct sama5d4_wdt *wdt)\n{\n\tconst char *tmp;\n\n\tif (wdt->sam9x60_support)\n\t\twdt->mr = AT91_SAM9X60_WDDIS;\n\telse\n\t\twdt->mr = AT91_WDT_WDDIS;\n\n\tif (!of_property_read_string(np, \"atmel,watchdog-type\", &tmp) &&\n\t    !strcmp(tmp, \"software\"))\n\t\twdt->need_irq = true;\n\n\tif (of_property_read_bool(np, \"atmel,idle-halt\"))\n\t\twdt->mr |= AT91_WDT_WDIDLEHLT;\n\n\tif (of_property_read_bool(np, \"atmel,dbg-halt\"))\n\t\twdt->mr |= AT91_WDT_WDDBGHLT;\n\n\treturn 0;\n}\n\nstatic int sama5d4_wdt_init(struct sama5d4_wdt *wdt)\n{\n\tu32 reg, val;\n\n\tval = WDT_SEC2TICKS(WDT_DEFAULT_TIMEOUT);\n\t \n\tif (!wdt_enabled) {\n\t\treg = wdt_read(wdt, AT91_WDT_MR);\n\t\tif (wdt->sam9x60_support && (!(reg & AT91_SAM9X60_WDDIS)))\n\t\t\twdt_write_nosleep(wdt, AT91_WDT_MR,\n\t\t\t\t\t  reg | AT91_SAM9X60_WDDIS);\n\t\telse if (!wdt->sam9x60_support &&\n\t\t\t (!(reg & AT91_WDT_WDDIS)))\n\t\t\twdt_write_nosleep(wdt, AT91_WDT_MR,\n\t\t\t\t\t  reg | AT91_WDT_WDDIS);\n\t}\n\n\tif (wdt->sam9x60_support) {\n\t\tif (wdt->need_irq)\n\t\t\twdt->ir = AT91_SAM9X60_PERINT;\n\t\telse\n\t\t\twdt->mr |= AT91_SAM9X60_PERIODRST;\n\n\t\twdt_write(wdt, AT91_SAM9X60_IER, wdt->ir);\n\t\twdt_write(wdt, AT91_SAM9X60_WLR, AT91_SAM9X60_SET_COUNTER(val));\n\t} else {\n\t\twdt->mr |= AT91_WDT_SET_WDD(WDT_SEC2TICKS(MAX_WDT_TIMEOUT));\n\t\twdt->mr |= AT91_WDT_SET_WDV(val);\n\n\t\tif (wdt->need_irq)\n\t\t\twdt->mr |= AT91_WDT_WDFIEN;\n\t\telse\n\t\t\twdt->mr |= AT91_WDT_WDRSTEN;\n\t}\n\n\twdt_write_nosleep(wdt, AT91_WDT_MR, wdt->mr);\n\n\treturn 0;\n}\n\nstatic int sama5d4_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct sama5d4_wdt *wdt;\n\tvoid __iomem *regs;\n\tu32 irq = 0;\n\tu32 reg;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdd = &wdt->wdd;\n\twdd->timeout = WDT_DEFAULT_TIMEOUT;\n\twdd->info = &sama5d4_wdt_info;\n\twdd->ops = &sama5d4_wdt_ops;\n\twdd->min_timeout = MIN_WDT_TIMEOUT;\n\twdd->max_timeout = MAX_WDT_TIMEOUT;\n\twdt->last_ping = jiffies;\n\n\tif (of_device_is_compatible(dev->of_node, \"microchip,sam9x60-wdt\") ||\n\t    of_device_is_compatible(dev->of_node, \"microchip,sama7g5-wdt\"))\n\t\twdt->sam9x60_support = true;\n\n\twatchdog_set_drvdata(wdd, wdt);\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\twdt->reg_base = regs;\n\n\tret = of_sama5d4_wdt_init(dev->of_node, wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (wdt->need_irq) {\n\t\tirq = irq_of_parse_and_map(dev->of_node, 0);\n\t\tif (!irq) {\n\t\t\tdev_warn(dev, \"failed to get IRQ from DT\\n\");\n\t\t\twdt->need_irq = false;\n\t\t}\n\t}\n\n\tif (wdt->need_irq) {\n\t\tret = devm_request_irq(dev, irq, sama5d4_wdt_irq_handler,\n\t\t\t\t       IRQF_SHARED | IRQF_IRQPOLL |\n\t\t\t\t       IRQF_NO_SUSPEND, pdev->name, pdev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"cannot register interrupt handler\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\twatchdog_init_timeout(wdd, wdt_timeout, dev);\n\n\treg = wdt_read(wdt, AT91_WDT_MR);\n\tif (!(reg & AT91_WDT_WDDIS)) {\n\t\twdt->mr &= ~AT91_WDT_WDDIS;\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t}\n\n\tret = sama5d4_wdt_init(wdt);\n\tif (ret)\n\t\treturn ret;\n\n\twatchdog_set_nowayout(wdd, nowayout);\n\n\twatchdog_stop_on_unregister(wdd);\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\tdev_info(dev, \"initialized (timeout = %d sec, nowayout = %d)\\n\",\n\t\t wdd->timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sama5d4_wdt_of_match[] = {\n\t{\n\t\t.compatible = \"atmel,sama5d4-wdt\",\n\t},\n\t{\n\t\t.compatible = \"microchip,sam9x60-wdt\",\n\t},\n\t{\n\t\t.compatible = \"microchip,sama7g5-wdt\",\n\t},\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sama5d4_wdt_of_match);\n\nstatic int sama5d4_wdt_suspend_late(struct device *dev)\n{\n\tstruct sama5d4_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\tsama5d4_wdt_stop(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic int sama5d4_wdt_resume_early(struct device *dev)\n{\n\tstruct sama5d4_wdt *wdt = dev_get_drvdata(dev);\n\n\t \n\tsama5d4_wdt_init(wdt);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\tsama5d4_wdt_start(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sama5d4_wdt_pm_ops = {\n\tLATE_SYSTEM_SLEEP_PM_OPS(sama5d4_wdt_suspend_late,\n\t\t\t\t sama5d4_wdt_resume_early)\n};\n\nstatic struct platform_driver sama5d4_wdt_driver = {\n\t.probe\t\t= sama5d4_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"sama5d4_wdt\",\n\t\t.pm\t= pm_sleep_ptr(&sama5d4_wdt_pm_ops),\n\t\t.of_match_table = sama5d4_wdt_of_match,\n\t}\n};\nmodule_platform_driver(sama5d4_wdt_driver);\n\nMODULE_AUTHOR(\"Atmel Corporation\");\nMODULE_DESCRIPTION(\"Atmel SAMA5D4 Watchdog Timer driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}