{
  "module_name": "meson_wdt.c",
  "hash_id": "f19e0e442ef6ac9a3385d1f80bd62e4c6e60c3c7db08004289edb6ff2c9719a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/meson_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#define DRV_NAME\t\t\"meson_wdt\"\n\n#define MESON_WDT_TC\t\t0x00\n#define MESON_WDT_DC_RESET\t(3 << 24)\n\n#define MESON_WDT_RESET\t\t0x04\n\n#define MESON_WDT_TIMEOUT\t30\n#define MESON_WDT_MIN_TIMEOUT\t1\n\n#define MESON_SEC_TO_TC(s, c)\t((s) * (c))\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic unsigned int timeout;\n\nstruct meson_wdt_data {\n\tunsigned int enable;\n\tunsigned int terminal_count_mask;\n\tunsigned int count_unit;\n};\n\nstatic struct meson_wdt_data meson6_wdt_data = {\n\t.enable\t\t\t= BIT(22),\n\t.terminal_count_mask\t= 0x3fffff,\n\t.count_unit\t\t= 100000,  \n};\n\nstatic struct meson_wdt_data meson8b_wdt_data = {\n\t.enable\t\t\t= BIT(19),\n\t.terminal_count_mask\t= 0xffff,\n\t.count_unit\t\t= 7812,  \n};\n\nstruct meson_wdt_dev {\n\tstruct watchdog_device wdt_dev;\n\tvoid __iomem *wdt_base;\n\tconst struct meson_wdt_data *data;\n};\n\nstatic int meson_wdt_restart(struct watchdog_device *wdt_dev,\n\t\t\t     unsigned long action, void *data)\n{\n\tstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\n\tu32 tc_reboot = MESON_WDT_DC_RESET;\n\n\ttc_reboot |= meson_wdt->data->enable;\n\n\twhile (1) {\n\t\twritel(tc_reboot, meson_wdt->wdt_base + MESON_WDT_TC);\n\t\tmdelay(5);\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\n\n\twritel(0, meson_wdt->wdt_base + MESON_WDT_RESET);\n\n\treturn 0;\n}\n\nstatic void meson_wdt_change_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t     unsigned int timeout)\n{\n\tstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\n\tu32 reg;\n\n\treg = readl(meson_wdt->wdt_base + MESON_WDT_TC);\n\treg &= ~meson_wdt->data->terminal_count_mask;\n\treg |= MESON_SEC_TO_TC(timeout, meson_wdt->data->count_unit);\n\twritel(reg, meson_wdt->wdt_base + MESON_WDT_TC);\n}\n\nstatic int meson_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t unsigned int timeout)\n{\n\twdt_dev->timeout = timeout;\n\n\tmeson_wdt_change_timeout(wdt_dev, timeout);\n\tmeson_wdt_ping(wdt_dev);\n\n\treturn 0;\n}\n\nstatic int meson_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\n\tu32 reg;\n\n\treg = readl(meson_wdt->wdt_base + MESON_WDT_TC);\n\treg &= ~meson_wdt->data->enable;\n\twritel(reg, meson_wdt->wdt_base + MESON_WDT_TC);\n\n\treturn 0;\n}\n\nstatic int meson_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\n\tu32 reg;\n\n\tmeson_wdt_change_timeout(wdt_dev, meson_wdt->wdt_dev.timeout);\n\tmeson_wdt_ping(wdt_dev);\n\n\treg = readl(meson_wdt->wdt_base + MESON_WDT_TC);\n\treg |= meson_wdt->data->enable;\n\twritel(reg, meson_wdt->wdt_base + MESON_WDT_TC);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info meson_wdt_info = {\n\t.identity\t= DRV_NAME,\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops meson_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= meson_wdt_start,\n\t.stop\t\t= meson_wdt_stop,\n\t.ping\t\t= meson_wdt_ping,\n\t.set_timeout\t= meson_wdt_set_timeout,\n\t.restart        = meson_wdt_restart,\n};\n\nstatic const struct of_device_id meson_wdt_dt_ids[] = {\n\t{ .compatible = \"amlogic,meson6-wdt\", .data = &meson6_wdt_data },\n\t{ .compatible = \"amlogic,meson8-wdt\", .data = &meson6_wdt_data },\n\t{ .compatible = \"amlogic,meson8b-wdt\", .data = &meson8b_wdt_data },\n\t{ .compatible = \"amlogic,meson8m2-wdt\", .data = &meson8b_wdt_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_wdt_dt_ids);\n\nstatic int meson_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_wdt_dev *meson_wdt;\n\tint err;\n\n\tmeson_wdt = devm_kzalloc(dev, sizeof(*meson_wdt), GFP_KERNEL);\n\tif (!meson_wdt)\n\t\treturn -ENOMEM;\n\n\tmeson_wdt->wdt_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(meson_wdt->wdt_base))\n\t\treturn PTR_ERR(meson_wdt->wdt_base);\n\n\tmeson_wdt->data = device_get_match_data(dev);\n\n\tmeson_wdt->wdt_dev.parent = dev;\n\tmeson_wdt->wdt_dev.info = &meson_wdt_info;\n\tmeson_wdt->wdt_dev.ops = &meson_wdt_ops;\n\tmeson_wdt->wdt_dev.max_timeout =\n\t\tmeson_wdt->data->terminal_count_mask / meson_wdt->data->count_unit;\n\tmeson_wdt->wdt_dev.min_timeout = MESON_WDT_MIN_TIMEOUT;\n\tmeson_wdt->wdt_dev.timeout = min_t(unsigned int,\n\t\t\t\t\t   MESON_WDT_TIMEOUT,\n\t\t\t\t\t   meson_wdt->wdt_dev.max_timeout);\n\n\twatchdog_set_drvdata(&meson_wdt->wdt_dev, meson_wdt);\n\n\twatchdog_init_timeout(&meson_wdt->wdt_dev, timeout, dev);\n\twatchdog_set_nowayout(&meson_wdt->wdt_dev, nowayout);\n\twatchdog_set_restart_priority(&meson_wdt->wdt_dev, 128);\n\n\tmeson_wdt_stop(&meson_wdt->wdt_dev);\n\n\twatchdog_stop_on_reboot(&meson_wdt->wdt_dev);\n\terr = devm_watchdog_register_device(dev, &meson_wdt->wdt_dev);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(dev, \"Watchdog enabled (timeout=%d sec, nowayout=%d)\",\n\t\t meson_wdt->wdt_dev.timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic struct platform_driver meson_wdt_driver = {\n\t.probe\t\t= meson_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= meson_wdt_dt_ids,\n\t},\n};\n\nmodule_platform_driver(meson_wdt_driver);\n\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog heartbeat in seconds\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Carlo Caione <carlo@caione.org>\");\nMODULE_DESCRIPTION(\"Meson Watchdog Timer Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}