{
  "module_name": "cpu5wdt.c",
  "hash_id": "a2ad3aa83d7797a4a6bf8bc123e8ce6edb6748eaa1cf75d04fb4518a28de7ddc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/cpu5wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/timer.h>\n#include <linux/completion.h>\n#include <linux/jiffies.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/watchdog.h>\n\n \n\nstatic int verbose;\nstatic int port = 0x91;\nstatic int ticks = 10000;\nstatic DEFINE_SPINLOCK(cpu5wdt_lock);\n\n#define PFX\t\t\t\"cpu5wdt: \"\n\n#define CPU5WDT_EXTENT          0x0A\n\n#define CPU5WDT_STATUS_REG      0x00\n#define CPU5WDT_TIME_A_REG      0x02\n#define CPU5WDT_TIME_B_REG      0x03\n#define CPU5WDT_MODE_REG        0x04\n#define CPU5WDT_TRIGGER_REG     0x07\n#define CPU5WDT_ENABLE_REG      0x08\n#define CPU5WDT_RESET_REG       0x09\n\n#define CPU5WDT_INTERVAL\t(HZ/10+1)\n\n \n\nstatic struct {\n\tstruct completion stop;\n\tint running;\n\tstruct timer_list timer;\n\tint queue;\n\tint default_ticks;\n\tunsigned long inuse;\n} cpu5wdt_device;\n\n \n\nstatic void cpu5wdt_trigger(struct timer_list *unused)\n{\n\tif (verbose > 2)\n\t\tpr_debug(\"trigger at %i ticks\\n\", ticks);\n\n\tif (cpu5wdt_device.running)\n\t\tticks--;\n\n\tspin_lock(&cpu5wdt_lock);\n\t \n\toutb(1, port + CPU5WDT_TRIGGER_REG);\n\n\t \n\tif (cpu5wdt_device.queue && ticks)\n\t\tmod_timer(&cpu5wdt_device.timer, jiffies + CPU5WDT_INTERVAL);\n\telse {\n\t\t \n\t\tcomplete(&cpu5wdt_device.stop);\n\t}\n\tspin_unlock(&cpu5wdt_lock);\n\n}\n\nstatic void cpu5wdt_reset(void)\n{\n\tticks = cpu5wdt_device.default_ticks;\n\n\tif (verbose)\n\t\tpr_debug(\"reset (%i ticks)\\n\", (int) ticks);\n\n}\n\nstatic void cpu5wdt_start(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cpu5wdt_lock, flags);\n\tif (!cpu5wdt_device.queue) {\n\t\tcpu5wdt_device.queue = 1;\n\t\toutb(0, port + CPU5WDT_TIME_A_REG);\n\t\toutb(0, port + CPU5WDT_TIME_B_REG);\n\t\toutb(1, port + CPU5WDT_MODE_REG);\n\t\toutb(0, port + CPU5WDT_RESET_REG);\n\t\toutb(0, port + CPU5WDT_ENABLE_REG);\n\t\tmod_timer(&cpu5wdt_device.timer, jiffies + CPU5WDT_INTERVAL);\n\t}\n\t \n\tcpu5wdt_device.running++;\n\tspin_unlock_irqrestore(&cpu5wdt_lock, flags);\n}\n\nstatic int cpu5wdt_stop(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cpu5wdt_lock, flags);\n\tif (cpu5wdt_device.running)\n\t\tcpu5wdt_device.running = 0;\n\tticks = cpu5wdt_device.default_ticks;\n\tspin_unlock_irqrestore(&cpu5wdt_lock, flags);\n\tif (verbose)\n\t\tpr_crit(\"stop not possible\\n\");\n\treturn -EIO;\n}\n\n \n\nstatic int cpu5wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &cpu5wdt_device.inuse))\n\t\treturn -EBUSY;\n\treturn stream_open(inode, file);\n}\n\nstatic int cpu5wdt_release(struct inode *inode, struct file *file)\n{\n\tclear_bit(0, &cpu5wdt_device.inuse);\n\treturn 0;\n}\n\nstatic long cpu5wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tunsigned int value;\n\tstatic const struct watchdog_info ident = {\n\t\t.options = WDIOF_CARDRESET,\n\t\t.identity = \"CPU5 WDT\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase WDIOC_GETSTATUS:\n\t\tvalue = inb(port + CPU5WDT_STATUS_REG);\n\t\tvalue = (value >> 2) & 1;\n\t\treturn put_user(value, p);\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(value, p))\n\t\t\treturn -EFAULT;\n\t\tif (value & WDIOS_ENABLECARD)\n\t\t\tcpu5wdt_start();\n\t\tif (value & WDIOS_DISABLECARD)\n\t\t\tcpu5wdt_stop();\n\t\tbreak;\n\tcase WDIOC_KEEPALIVE:\n\t\tcpu5wdt_reset();\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t cpu5wdt_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tif (!count)\n\t\treturn -EIO;\n\tcpu5wdt_reset();\n\treturn count;\n}\n\nstatic const struct file_operations cpu5wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl\t= cpu5wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= cpu5wdt_open,\n\t.write\t\t= cpu5wdt_write,\n\t.release\t= cpu5wdt_release,\n};\n\nstatic struct miscdevice cpu5wdt_misc = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &cpu5wdt_fops,\n};\n\n \n\nstatic int cpu5wdt_init(void)\n{\n\tunsigned int val;\n\tint err;\n\n\tif (verbose)\n\t\tpr_debug(\"port=0x%x, verbose=%i\\n\", port, verbose);\n\n\tinit_completion(&cpu5wdt_device.stop);\n\tcpu5wdt_device.queue = 0;\n\ttimer_setup(&cpu5wdt_device.timer, cpu5wdt_trigger, 0);\n\tcpu5wdt_device.default_ticks = ticks;\n\n\tif (!request_region(port, CPU5WDT_EXTENT, PFX)) {\n\t\tpr_err(\"request_region failed\\n\");\n\t\terr = -EBUSY;\n\t\tgoto no_port;\n\t}\n\n\t \n\tval = inb(port + CPU5WDT_STATUS_REG);\n\tval = (val >> 2) & 1;\n\tif (!val)\n\t\tpr_info(\"sorry, was my fault\\n\");\n\n\terr = misc_register(&cpu5wdt_misc);\n\tif (err < 0) {\n\t\tpr_err(\"misc_register failed\\n\");\n\t\tgoto no_misc;\n\t}\n\n\n\tpr_info(\"init success\\n\");\n\treturn 0;\n\nno_misc:\n\trelease_region(port, CPU5WDT_EXTENT);\nno_port:\n\treturn err;\n}\n\nstatic int cpu5wdt_init_module(void)\n{\n\treturn cpu5wdt_init();\n}\n\nstatic void cpu5wdt_exit(void)\n{\n\tif (cpu5wdt_device.queue) {\n\t\tcpu5wdt_device.queue = 0;\n\t\twait_for_completion(&cpu5wdt_device.stop);\n\t\tdel_timer(&cpu5wdt_device.timer);\n\t}\n\n\tmisc_deregister(&cpu5wdt_misc);\n\n\trelease_region(port, CPU5WDT_EXTENT);\n\n}\n\nstatic void cpu5wdt_exit_module(void)\n{\n\tcpu5wdt_exit();\n}\n\n \n\nmodule_init(cpu5wdt_init_module);\nmodule_exit(cpu5wdt_exit_module);\n\nMODULE_AUTHOR(\"Heiko Ronsdorf <hero@ihg.uni-duisburg.de>\");\nMODULE_DESCRIPTION(\"sma cpu5 watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_hw(port, int, ioport, 0);\nMODULE_PARM_DESC(port, \"base address of watchdog card, default is 0x91\");\n\nmodule_param(verbose, int, 0);\nMODULE_PARM_DESC(verbose, \"be verbose, default is 0 (no)\");\n\nmodule_param(ticks, int, 0);\nMODULE_PARM_DESC(ticks, \"count down ticks, default is 10000\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}