{
  "module_name": "mpc8xxx_wdt.c",
  "hash_id": "a900dc56f88176c28eb79c7605d7d01ffe9f6c8ba1673a9da1d28898c5bf0de8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/mpc8xxx_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/watchdog.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <sysdev/fsl_soc.h>\n\n#define WATCHDOG_TIMEOUT 10\n\nstruct mpc8xxx_wdt {\n\t__be32 res0;\n\t__be32 swcrr;  \n#define SWCRR_SWTC 0xFFFF0000  \n#define SWCRR_SWF  0x00000008  \n#define SWCRR_SWEN 0x00000004  \n#define SWCRR_SWRI 0x00000002  \n#define SWCRR_SWPR 0x00000001  \n\t__be32 swcnr;  \n\tu8 res1[2];\n\t__be16 swsrr;  \n\tu8 res2[0xF0];\n};\n\nstruct mpc8xxx_wdt_type {\n\tint prescaler;\n\tbool hw_enabled;\n\tu32 rsr_mask;\n};\n\nstruct mpc8xxx_wdt_ddata {\n\tstruct mpc8xxx_wdt __iomem *base;\n\tstruct watchdog_device wdd;\n\tspinlock_t lock;\n\tu16 swtc;\n};\n\nstatic u16 timeout;\nmodule_param(timeout, ushort, 0);\nMODULE_PARM_DESC(timeout,\n\t\"Watchdog timeout in seconds. (1<timeout<65535, default=\"\n\t__MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic bool reset = 1;\nmodule_param(reset, bool, 0);\nMODULE_PARM_DESC(reset,\n\t\"Watchdog Interrupt/Reset Mode. 0 = interrupt, 1 = reset\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\t \"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic void mpc8xxx_wdt_keepalive(struct mpc8xxx_wdt_ddata *ddata)\n{\n\t \n\tspin_lock(&ddata->lock);\n\tout_be16(&ddata->base->swsrr, 0x556c);\n\tout_be16(&ddata->base->swsrr, 0xaa39);\n\tspin_unlock(&ddata->lock);\n}\n\nstatic int mpc8xxx_wdt_start(struct watchdog_device *w)\n{\n\tstruct mpc8xxx_wdt_ddata *ddata =\n\t\tcontainer_of(w, struct mpc8xxx_wdt_ddata, wdd);\n\tu32 tmp = in_be32(&ddata->base->swcrr);\n\n\t \n\ttmp &= ~(SWCRR_SWTC | SWCRR_SWF | SWCRR_SWEN | SWCRR_SWRI | SWCRR_SWPR);\n\ttmp |= SWCRR_SWEN | SWCRR_SWPR | (ddata->swtc << 16);\n\n\tif (reset)\n\t\ttmp |= SWCRR_SWRI;\n\n\tout_be32(&ddata->base->swcrr, tmp);\n\n\ttmp = in_be32(&ddata->base->swcrr);\n\tif (!(tmp & SWCRR_SWEN))\n\t\treturn -EOPNOTSUPP;\n\n\tddata->swtc = tmp >> 16;\n\tset_bit(WDOG_HW_RUNNING, &ddata->wdd.status);\n\n\treturn 0;\n}\n\nstatic int mpc8xxx_wdt_ping(struct watchdog_device *w)\n{\n\tstruct mpc8xxx_wdt_ddata *ddata =\n\t\tcontainer_of(w, struct mpc8xxx_wdt_ddata, wdd);\n\n\tmpc8xxx_wdt_keepalive(ddata);\n\treturn 0;\n}\n\nstatic struct watchdog_info mpc8xxx_wdt_info = {\n\t.options = WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT,\n\t.firmware_version = 1,\n\t.identity = \"MPC8xxx\",\n};\n\nstatic const struct watchdog_ops mpc8xxx_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = mpc8xxx_wdt_start,\n\t.ping = mpc8xxx_wdt_ping,\n};\n\nstatic int mpc8xxx_wdt_probe(struct platform_device *ofdev)\n{\n\tint ret;\n\tstruct resource *res;\n\tconst struct mpc8xxx_wdt_type *wdt_type;\n\tstruct mpc8xxx_wdt_ddata *ddata;\n\tu32 freq = fsl_get_sys_freq();\n\tbool enabled;\n\tstruct device *dev = &ofdev->dev;\n\n\twdt_type = of_device_get_match_data(dev);\n\tif (!wdt_type)\n\t\treturn -EINVAL;\n\n\tif (!freq || freq == -1)\n\t\treturn -EINVAL;\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->base = devm_platform_ioremap_resource(ofdev, 0);\n\tif (IS_ERR(ddata->base))\n\t\treturn PTR_ERR(ddata->base);\n\n\tenabled = in_be32(&ddata->base->swcrr) & SWCRR_SWEN;\n\tif (!enabled && wdt_type->hw_enabled) {\n\t\tdev_info(dev, \"could not be enabled in software\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\tbool status;\n\t\tu32 __iomem *rsr = ioremap(res->start, resource_size(res));\n\n\t\tif (!rsr)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = in_be32(rsr) & wdt_type->rsr_mask;\n\t\tddata->wdd.bootstatus = status ? WDIOF_CARDRESET : 0;\n\t\t  \n\t\tout_be32(rsr, wdt_type->rsr_mask);\n\t\tiounmap(rsr);\n\n\t\tdev_info(dev, \"Last boot was %scaused by watchdog\\n\",\n\t\t\t status ? \"\" : \"not \");\n\t}\n\n\tspin_lock_init(&ddata->lock);\n\n\tddata->wdd.info = &mpc8xxx_wdt_info;\n\tddata->wdd.ops = &mpc8xxx_wdt_ops;\n\n\tddata->wdd.timeout = WATCHDOG_TIMEOUT;\n\twatchdog_init_timeout(&ddata->wdd, timeout, dev);\n\n\twatchdog_set_nowayout(&ddata->wdd, nowayout);\n\n\tddata->swtc = min(ddata->wdd.timeout * freq / wdt_type->prescaler,\n\t\t\t  0xffffU);\n\n\t \n\tif (enabled)\n\t\tmpc8xxx_wdt_start(&ddata->wdd);\n\n\tddata->wdd.max_hw_heartbeat_ms = (ddata->swtc * wdt_type->prescaler) /\n\t\t\t\t\t (freq / 1000);\n\tddata->wdd.min_timeout = ddata->wdd.max_hw_heartbeat_ms / 1000;\n\tif (ddata->wdd.timeout < ddata->wdd.min_timeout)\n\t\tddata->wdd.timeout = ddata->wdd.min_timeout;\n\n\tret = devm_watchdog_register_device(dev, &ddata->wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev,\n\t\t \"WDT driver for MPC8xxx initialized. mode:%s timeout=%d sec\\n\",\n\t\t reset ? \"reset\" : \"interrupt\", ddata->wdd.timeout);\n\n\tplatform_set_drvdata(ofdev, ddata);\n\treturn 0;\n}\n\nstatic const struct of_device_id mpc8xxx_wdt_match[] = {\n\t{\n\t\t.compatible = \"mpc83xx_wdt\",\n\t\t.data = &(struct mpc8xxx_wdt_type) {\n\t\t\t.prescaler = 0x10000,\n\t\t\t.rsr_mask = BIT(3),  \n\t\t},\n\t},\n\t{\n\t\t.compatible = \"fsl,mpc8610-wdt\",\n\t\t.data = &(struct mpc8xxx_wdt_type) {\n\t\t\t.prescaler = 0x10000,\n\t\t\t.hw_enabled = true,\n\t\t\t.rsr_mask = BIT(20),  \n\t\t},\n\t},\n\t{\n\t\t.compatible = \"fsl,mpc823-wdt\",\n\t\t.data = &(struct mpc8xxx_wdt_type) {\n\t\t\t.prescaler = 0x800,\n\t\t\t.hw_enabled = true,\n\t\t\t.rsr_mask = BIT(28),  \n\t\t},\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpc8xxx_wdt_match);\n\nstatic struct platform_driver mpc8xxx_wdt_driver = {\n\t.probe\t\t= mpc8xxx_wdt_probe,\n\t.driver = {\n\t\t.name = \"mpc8xxx_wdt\",\n\t\t.of_match_table = mpc8xxx_wdt_match,\n\t},\n};\n\nstatic int __init mpc8xxx_wdt_init(void)\n{\n\treturn platform_driver_register(&mpc8xxx_wdt_driver);\n}\narch_initcall(mpc8xxx_wdt_init);\n\nstatic void __exit mpc8xxx_wdt_exit(void)\n{\n\tplatform_driver_unregister(&mpc8xxx_wdt_driver);\n}\nmodule_exit(mpc8xxx_wdt_exit);\n\nMODULE_AUTHOR(\"Dave Updegraff, Kumar Gala\");\nMODULE_DESCRIPTION(\"Driver for watchdog timer in MPC8xx/MPC83xx/MPC86xx \"\n\t\t   \"uProcessors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}