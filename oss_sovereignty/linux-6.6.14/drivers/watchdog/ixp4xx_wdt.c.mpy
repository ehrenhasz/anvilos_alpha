{
  "module_name": "ixp4xx_wdt.c",
  "hash_id": "edd2896504968a48bca70dcb0620a809af38575b085e2470dab22a531128d800",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ixp4xx_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/watchdog.h>\n#include <linux/bits.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/soc/ixp4xx/cpu.h>\n\nstruct ixp4xx_wdt {\n\tstruct watchdog_device wdd;\n\tvoid __iomem *base;\n\tunsigned long rate;\n};\n\n \n#define IXP4XX_TIMER_FREQ\t66666000\n\n \n#define IXP4XX_OSWT_OFFSET\t0x14   \n#define IXP4XX_OSWE_OFFSET\t0x18   \n#define IXP4XX_OSWK_OFFSET\t0x1C   \n#define IXP4XX_OSST_OFFSET\t0x20   \n\n#define IXP4XX_OSST_TIMER_WDOG_PEND\t0x00000008\n#define IXP4XX_OSST_TIMER_WARM_RESET\t0x00000010\n#define IXP4XX_WDT_KEY\t\t\t0x0000482E\n#define IXP4XX_WDT_RESET_ENABLE\t\t0x00000001\n#define IXP4XX_WDT_IRQ_ENABLE\t\t0x00000002\n#define IXP4XX_WDT_COUNT_ENABLE\t\t0x00000004\n\nstatic inline\nstruct ixp4xx_wdt *to_ixp4xx_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct ixp4xx_wdt, wdd);\n}\n\nstatic int ixp4xx_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct ixp4xx_wdt *iwdt = to_ixp4xx_wdt(wdd);\n\n\t__raw_writel(IXP4XX_WDT_KEY, iwdt->base + IXP4XX_OSWK_OFFSET);\n\t__raw_writel(0, iwdt->base + IXP4XX_OSWE_OFFSET);\n\t__raw_writel(wdd->timeout * iwdt->rate,\n\t\t     iwdt->base + IXP4XX_OSWT_OFFSET);\n\t__raw_writel(IXP4XX_WDT_COUNT_ENABLE | IXP4XX_WDT_RESET_ENABLE,\n\t\t     iwdt->base + IXP4XX_OSWE_OFFSET);\n\t__raw_writel(0, iwdt->base + IXP4XX_OSWK_OFFSET);\n\n\treturn 0;\n}\n\nstatic int ixp4xx_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct ixp4xx_wdt *iwdt = to_ixp4xx_wdt(wdd);\n\n\t__raw_writel(IXP4XX_WDT_KEY, iwdt->base + IXP4XX_OSWK_OFFSET);\n\t__raw_writel(0, iwdt->base + IXP4XX_OSWE_OFFSET);\n\t__raw_writel(0, iwdt->base + IXP4XX_OSWK_OFFSET);\n\n\treturn 0;\n}\n\nstatic int ixp4xx_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\twdd->timeout = timeout;\n\tif (watchdog_active(wdd))\n\t\tixp4xx_wdt_start(wdd);\n\n\treturn 0;\n}\n\nstatic int ixp4xx_wdt_restart(struct watchdog_device *wdd,\n                              unsigned long action, void *data)\n{\n\tstruct ixp4xx_wdt *iwdt = to_ixp4xx_wdt(wdd);\n\n\t__raw_writel(IXP4XX_WDT_KEY, iwdt->base + IXP4XX_OSWK_OFFSET);\n\t__raw_writel(0, iwdt->base + IXP4XX_OSWT_OFFSET);\n\t__raw_writel(IXP4XX_WDT_COUNT_ENABLE | IXP4XX_WDT_RESET_ENABLE,\n\t\t     iwdt->base + IXP4XX_OSWE_OFFSET);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops ixp4xx_wdt_ops = {\n\t.start = ixp4xx_wdt_start,\n\t.stop = ixp4xx_wdt_stop,\n\t.set_timeout = ixp4xx_wdt_set_timeout,\n\t.restart = ixp4xx_wdt_restart,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic int ixp4xx_wdt_dummy(struct watchdog_device *wdd)\n{\n\treturn 0;\n}\n\nstatic const struct watchdog_ops ixp4xx_wdt_restart_only_ops = {\n\t.start = ixp4xx_wdt_dummy,\n\t.stop = ixp4xx_wdt_dummy,\n\t.restart = ixp4xx_wdt_restart,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct watchdog_info ixp4xx_wdt_info = {\n\t.options = WDIOF_KEEPALIVEPING\n\t\t| WDIOF_MAGICCLOSE\n\t\t| WDIOF_SETTIMEOUT,\n\t.identity = KBUILD_MODNAME,\n};\n\nstatic int ixp4xx_wdt_probe(struct platform_device *pdev)\n{\n\tstatic const struct watchdog_ops *iwdt_ops;\n\tstruct device *dev = &pdev->dev;\n\tstruct ixp4xx_wdt *iwdt;\n\tstruct clk *clk;\n\tint ret;\n\n\tif (!(read_cpuid_id() & 0xf) && !cpu_is_ixp46x()) {\n\t\tdev_info(dev, \"Rev. A0 IXP42x CPU detected - only restart supported\\n\");\n\t\tiwdt_ops = &ixp4xx_wdt_restart_only_ops;\n\t} else {\n\t\tiwdt_ops = &ixp4xx_wdt_ops;\n\t}\n\n\tiwdt = devm_kzalloc(dev, sizeof(*iwdt), GFP_KERNEL);\n\tif (!iwdt)\n\t\treturn -ENOMEM;\n\tiwdt->base = (void __iomem *)dev->platform_data;\n\n\t \n\tclk = devm_clk_get_enabled(dev->parent, NULL);\n\tif (!IS_ERR(clk))\n\t\tiwdt->rate = clk_get_rate(clk);\n\n\tif (!iwdt->rate)\n\t\tiwdt->rate = IXP4XX_TIMER_FREQ;\n\n\tiwdt->wdd.info = &ixp4xx_wdt_info;\n\tiwdt->wdd.ops = iwdt_ops;\n\tiwdt->wdd.min_timeout = 1;\n\tiwdt->wdd.max_timeout = U32_MAX / iwdt->rate;\n\tiwdt->wdd.parent = dev;\n\t \n\tiwdt->wdd.timeout = 60U;\n\twatchdog_init_timeout(&iwdt->wdd, 0, dev);\n\n\tif (__raw_readl(iwdt->base + IXP4XX_OSST_OFFSET) &\n\t    IXP4XX_OSST_TIMER_WARM_RESET)\n\t\tiwdt->wdd.bootstatus = WDIOF_CARDRESET;\n\n\tret = devm_watchdog_register_device(dev, &iwdt->wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"IXP4xx watchdog available\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver ixp4xx_wdt_driver = {\n\t.probe = ixp4xx_wdt_probe,\n\t.driver = {\n\t\t.name   = \"ixp4xx-watchdog\",\n\t},\n};\nmodule_platform_driver(ixp4xx_wdt_driver);\n\nMODULE_AUTHOR(\"Deepak Saxena <dsaxena@plexity.net>\");\nMODULE_DESCRIPTION(\"IXP4xx Network Processor Watchdog\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}