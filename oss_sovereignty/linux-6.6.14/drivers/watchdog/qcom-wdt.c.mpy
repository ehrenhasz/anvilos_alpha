{
  "module_name": "qcom-wdt.c",
  "hash_id": "c4b1721db47a7178aa22474bc21199e5a2bc76f03e20fa60bfeb299ae2b80fa5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/qcom-wdt.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\nenum wdt_reg {\n\tWDT_RST,\n\tWDT_EN,\n\tWDT_STS,\n\tWDT_BARK_TIME,\n\tWDT_BITE_TIME,\n};\n\n#define QCOM_WDT_ENABLE\t\tBIT(0)\n\nstatic const u32 reg_offset_data_apcs_tmr[] = {\n\t[WDT_RST] = 0x38,\n\t[WDT_EN] = 0x40,\n\t[WDT_STS] = 0x44,\n\t[WDT_BARK_TIME] = 0x4C,\n\t[WDT_BITE_TIME] = 0x5C,\n};\n\nstatic const u32 reg_offset_data_kpss[] = {\n\t[WDT_RST] = 0x4,\n\t[WDT_EN] = 0x8,\n\t[WDT_STS] = 0xC,\n\t[WDT_BARK_TIME] = 0x10,\n\t[WDT_BITE_TIME] = 0x14,\n};\n\nstruct qcom_wdt_match_data {\n\tconst u32 *offset;\n\tbool pretimeout;\n};\n\nstruct qcom_wdt {\n\tstruct watchdog_device\twdd;\n\tunsigned long\t\trate;\n\tvoid __iomem\t\t*base;\n\tconst u32\t\t*layout;\n};\n\nstatic void __iomem *wdt_addr(struct qcom_wdt *wdt, enum wdt_reg reg)\n{\n\treturn wdt->base + wdt->layout[reg];\n}\n\nstatic inline\nstruct qcom_wdt *to_qcom_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct qcom_wdt, wdd);\n}\n\nstatic irqreturn_t qcom_wdt_isr(int irq, void *arg)\n{\n\tstruct watchdog_device *wdd = arg;\n\n\twatchdog_notify_pretimeout(wdd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qcom_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct qcom_wdt *wdt = to_qcom_wdt(wdd);\n\tunsigned int bark = wdd->timeout - wdd->pretimeout;\n\n\twritel(0, wdt_addr(wdt, WDT_EN));\n\twritel(1, wdt_addr(wdt, WDT_RST));\n\twritel(bark * wdt->rate, wdt_addr(wdt, WDT_BARK_TIME));\n\twritel(wdd->timeout * wdt->rate, wdt_addr(wdt, WDT_BITE_TIME));\n\twritel(QCOM_WDT_ENABLE, wdt_addr(wdt, WDT_EN));\n\treturn 0;\n}\n\nstatic int qcom_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct qcom_wdt *wdt = to_qcom_wdt(wdd);\n\n\twritel(0, wdt_addr(wdt, WDT_EN));\n\treturn 0;\n}\n\nstatic int qcom_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct qcom_wdt *wdt = to_qcom_wdt(wdd);\n\n\twritel(1, wdt_addr(wdt, WDT_RST));\n\treturn 0;\n}\n\nstatic int qcom_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\tunsigned int timeout)\n{\n\twdd->timeout = timeout;\n\treturn qcom_wdt_start(wdd);\n}\n\nstatic int qcom_wdt_set_pretimeout(struct watchdog_device *wdd,\n\t\t\t\t   unsigned int timeout)\n{\n\twdd->pretimeout = timeout;\n\treturn qcom_wdt_start(wdd);\n}\n\nstatic int qcom_wdt_restart(struct watchdog_device *wdd, unsigned long action,\n\t\t\t    void *data)\n{\n\tstruct qcom_wdt *wdt = to_qcom_wdt(wdd);\n\tu32 timeout;\n\n\t \n\ttimeout = 128 * wdt->rate / 1000;\n\n\twritel(0, wdt_addr(wdt, WDT_EN));\n\twritel(1, wdt_addr(wdt, WDT_RST));\n\twritel(timeout, wdt_addr(wdt, WDT_BARK_TIME));\n\twritel(timeout, wdt_addr(wdt, WDT_BITE_TIME));\n\twritel(QCOM_WDT_ENABLE, wdt_addr(wdt, WDT_EN));\n\n\t \n\twmb();\n\n\tmdelay(150);\n\treturn 0;\n}\n\nstatic int qcom_wdt_is_running(struct watchdog_device *wdd)\n{\n\tstruct qcom_wdt *wdt = to_qcom_wdt(wdd);\n\n\treturn (readl(wdt_addr(wdt, WDT_EN)) & QCOM_WDT_ENABLE);\n}\n\nstatic const struct watchdog_ops qcom_wdt_ops = {\n\t.start\t\t= qcom_wdt_start,\n\t.stop\t\t= qcom_wdt_stop,\n\t.ping\t\t= qcom_wdt_ping,\n\t.set_timeout\t= qcom_wdt_set_timeout,\n\t.set_pretimeout\t= qcom_wdt_set_pretimeout,\n\t.restart        = qcom_wdt_restart,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct watchdog_info qcom_wdt_info = {\n\t.options\t= WDIOF_KEEPALIVEPING\n\t\t\t| WDIOF_MAGICCLOSE\n\t\t\t| WDIOF_SETTIMEOUT\n\t\t\t| WDIOF_CARDRESET,\n\t.identity\t= KBUILD_MODNAME,\n};\n\nstatic const struct watchdog_info qcom_wdt_pt_info = {\n\t.options\t= WDIOF_KEEPALIVEPING\n\t\t\t| WDIOF_MAGICCLOSE\n\t\t\t| WDIOF_SETTIMEOUT\n\t\t\t| WDIOF_PRETIMEOUT\n\t\t\t| WDIOF_CARDRESET,\n\t.identity\t= KBUILD_MODNAME,\n};\n\nstatic const struct qcom_wdt_match_data match_data_apcs_tmr = {\n\t.offset = reg_offset_data_apcs_tmr,\n\t.pretimeout = false,\n};\n\nstatic const struct qcom_wdt_match_data match_data_kpss = {\n\t.offset = reg_offset_data_kpss,\n\t.pretimeout = true,\n};\n\nstatic int qcom_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_wdt *wdt;\n\tstruct resource *res;\n\tstruct device_node *np = dev->of_node;\n\tconst struct qcom_wdt_match_data *data;\n\tu32 percpu_offset;\n\tint irq, ret;\n\tstruct clk *clk;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data) {\n\t\tdev_err(dev, \"Unsupported QCOM WDT module\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\t \n\tif (of_property_read_u32(np, \"cpu-offset\", &percpu_offset))\n\t\tpercpu_offset = 0;\n\n\tres->start += percpu_offset;\n\tres->end += percpu_offset;\n\n\twdt->base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to get input clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\t \n\twdt->rate = clk_get_rate(clk);\n\tif (wdt->rate == 0 ||\n\t    wdt->rate > 0x10000000U) {\n\t\tdev_err(dev, \"invalid clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (data->pretimeout && irq > 0) {\n\t\tret = devm_request_irq(dev, irq, qcom_wdt_isr, 0,\n\t\t\t\t       \"wdt_bark\", &wdt->wdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twdt->wdd.info = &qcom_wdt_pt_info;\n\t\twdt->wdd.pretimeout = 1;\n\t} else {\n\t\tif (irq == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\twdt->wdd.info = &qcom_wdt_info;\n\t}\n\n\twdt->wdd.ops = &qcom_wdt_ops;\n\twdt->wdd.min_timeout = 1;\n\twdt->wdd.max_timeout = 0x10000000U / wdt->rate;\n\twdt->wdd.parent = dev;\n\twdt->layout = data->offset;\n\n\tif (readl(wdt_addr(wdt, WDT_STS)) & 1)\n\t\twdt->wdd.bootstatus = WDIOF_CARDRESET;\n\n\t \n\twdt->wdd.timeout = min(wdt->wdd.max_timeout, 30U);\n\twatchdog_init_timeout(&wdt->wdd, 0, dev);\n\n\t \n\tif (qcom_wdt_is_running(&wdt->wdd)) {\n\t\tqcom_wdt_start(&wdt->wdd);\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdd.status);\n\t}\n\n\tret = devm_watchdog_register_device(dev, &wdt->wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdt);\n\treturn 0;\n}\n\nstatic int __maybe_unused qcom_wdt_suspend(struct device *dev)\n{\n\tstruct qcom_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\tqcom_wdt_stop(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused qcom_wdt_resume(struct device *dev)\n{\n\tstruct qcom_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\tqcom_wdt_start(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops qcom_wdt_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(qcom_wdt_suspend, qcom_wdt_resume)\n};\n\nstatic const struct of_device_id qcom_wdt_of_table[] = {\n\t{ .compatible = \"qcom,kpss-timer\", .data = &match_data_apcs_tmr },\n\t{ .compatible = \"qcom,scss-timer\", .data = &match_data_apcs_tmr },\n\t{ .compatible = \"qcom,kpss-wdt\", .data = &match_data_kpss },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qcom_wdt_of_table);\n\nstatic struct platform_driver qcom_watchdog_driver = {\n\t.probe\t= qcom_wdt_probe,\n\t.driver\t= {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= qcom_wdt_of_table,\n\t\t.pm\t\t= &qcom_wdt_pm_ops,\n\t},\n};\nmodule_platform_driver(qcom_watchdog_driver);\n\nMODULE_DESCRIPTION(\"QCOM KPSS Watchdog Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}