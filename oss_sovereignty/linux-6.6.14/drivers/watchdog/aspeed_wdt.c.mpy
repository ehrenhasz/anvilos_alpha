{
  "module_name": "aspeed_wdt.c",
  "hash_id": "d9b5bcf7880e5615c41cbbee4c3f232dbfd16c0836e1dc3b5a17200c352bc081",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/aspeed_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct aspeed_wdt_config {\n\tu32 ext_pulse_width_mask;\n\tu32 irq_shift;\n\tu32 irq_mask;\n};\n\nstruct aspeed_wdt {\n\tstruct watchdog_device\twdd;\n\tvoid __iomem\t\t*base;\n\tu32\t\t\tctrl;\n\tconst struct aspeed_wdt_config *cfg;\n};\n\nstatic const struct aspeed_wdt_config ast2400_config = {\n\t.ext_pulse_width_mask = 0xff,\n\t.irq_shift = 0,\n\t.irq_mask = 0,\n};\n\nstatic const struct aspeed_wdt_config ast2500_config = {\n\t.ext_pulse_width_mask = 0xfffff,\n\t.irq_shift = 12,\n\t.irq_mask = GENMASK(31, 12),\n};\n\nstatic const struct aspeed_wdt_config ast2600_config = {\n\t.ext_pulse_width_mask = 0xfffff,\n\t.irq_shift = 0,\n\t.irq_mask = GENMASK(31, 10),\n};\n\nstatic const struct of_device_id aspeed_wdt_of_table[] = {\n\t{ .compatible = \"aspeed,ast2400-wdt\", .data = &ast2400_config },\n\t{ .compatible = \"aspeed,ast2500-wdt\", .data = &ast2500_config },\n\t{ .compatible = \"aspeed,ast2600-wdt\", .data = &ast2600_config },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, aspeed_wdt_of_table);\n\n#define WDT_STATUS\t\t0x00\n#define WDT_RELOAD_VALUE\t0x04\n#define WDT_RESTART\t\t0x08\n#define WDT_CTRL\t\t0x0C\n#define   WDT_CTRL_BOOT_SECONDARY\tBIT(7)\n#define   WDT_CTRL_RESET_MODE_SOC\t(0x00 << 5)\n#define   WDT_CTRL_RESET_MODE_FULL_CHIP\t(0x01 << 5)\n#define   WDT_CTRL_RESET_MODE_ARM_CPU\t(0x10 << 5)\n#define   WDT_CTRL_1MHZ_CLK\t\tBIT(4)\n#define   WDT_CTRL_WDT_EXT\t\tBIT(3)\n#define   WDT_CTRL_WDT_INTR\t\tBIT(2)\n#define   WDT_CTRL_RESET_SYSTEM\t\tBIT(1)\n#define   WDT_CTRL_ENABLE\t\tBIT(0)\n#define WDT_TIMEOUT_STATUS\t0x10\n#define   WDT_TIMEOUT_STATUS_IRQ\t\tBIT(2)\n#define   WDT_TIMEOUT_STATUS_BOOT_SECONDARY\tBIT(1)\n#define WDT_CLEAR_TIMEOUT_STATUS\t0x14\n#define   WDT_CLEAR_TIMEOUT_AND_BOOT_CODE_SELECTION\tBIT(0)\n\n \n#define WDT_RESET_WIDTH\t\t0x18\n#define   WDT_RESET_WIDTH_ACTIVE_HIGH\tBIT(31)\n#define     WDT_ACTIVE_HIGH_MAGIC\t(0xA5 << 24)\n#define     WDT_ACTIVE_LOW_MAGIC\t(0x5A << 24)\n#define   WDT_RESET_WIDTH_PUSH_PULL\tBIT(30)\n#define     WDT_PUSH_PULL_MAGIC\t\t(0xA8 << 24)\n#define     WDT_OPEN_DRAIN_MAGIC\t(0x8A << 24)\n\n#define WDT_RESTART_MAGIC\t0x4755\n\n \n#define WDT_MAX_TIMEOUT_MS\t4294967\n#define WDT_DEFAULT_TIMEOUT\t30\n#define WDT_RATE_1MHZ\t\t1000000\n\nstatic struct aspeed_wdt *to_aspeed_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct aspeed_wdt, wdd);\n}\n\nstatic void aspeed_wdt_enable(struct aspeed_wdt *wdt, int count)\n{\n\twdt->ctrl |= WDT_CTRL_ENABLE;\n\n\twritel(0, wdt->base + WDT_CTRL);\n\twritel(count, wdt->base + WDT_RELOAD_VALUE);\n\twritel(WDT_RESTART_MAGIC, wdt->base + WDT_RESTART);\n\twritel(wdt->ctrl, wdt->base + WDT_CTRL);\n}\n\nstatic int aspeed_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\n\n\taspeed_wdt_enable(wdt, wdd->timeout * WDT_RATE_1MHZ);\n\n\treturn 0;\n}\n\nstatic int aspeed_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\n\n\twdt->ctrl &= ~WDT_CTRL_ENABLE;\n\twritel(wdt->ctrl, wdt->base + WDT_CTRL);\n\n\treturn 0;\n}\n\nstatic int aspeed_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\n\n\twritel(WDT_RESTART_MAGIC, wdt->base + WDT_RESTART);\n\n\treturn 0;\n}\n\nstatic int aspeed_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\n\tu32 actual;\n\n\twdd->timeout = timeout;\n\n\tactual = min(timeout, wdd->max_hw_heartbeat_ms / 1000);\n\n\twritel(actual * WDT_RATE_1MHZ, wdt->base + WDT_RELOAD_VALUE);\n\twritel(WDT_RESTART_MAGIC, wdt->base + WDT_RESTART);\n\n\treturn 0;\n}\n\nstatic int aspeed_wdt_set_pretimeout(struct watchdog_device *wdd,\n\t\t\t\t     unsigned int pretimeout)\n{\n\tstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\n\tu32 actual = pretimeout * WDT_RATE_1MHZ;\n\tu32 s = wdt->cfg->irq_shift;\n\tu32 m = wdt->cfg->irq_mask;\n\n\twdd->pretimeout = pretimeout;\n\twdt->ctrl &= ~m;\n\tif (pretimeout)\n\t\twdt->ctrl |= ((actual << s) & m) | WDT_CTRL_WDT_INTR;\n\telse\n\t\twdt->ctrl &= ~WDT_CTRL_WDT_INTR;\n\n\twritel(wdt->ctrl, wdt->base + WDT_CTRL);\n\n\treturn 0;\n}\n\nstatic int aspeed_wdt_restart(struct watchdog_device *wdd,\n\t\t\t      unsigned long action, void *data)\n{\n\tstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\n\n\twdt->ctrl &= ~WDT_CTRL_BOOT_SECONDARY;\n\taspeed_wdt_enable(wdt, 128 * WDT_RATE_1MHZ / 1000);\n\n\tmdelay(1000);\n\n\treturn 0;\n}\n\n \nstatic ssize_t access_cs0_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct aspeed_wdt *wdt = dev_get_drvdata(dev);\n\tu32 status = readl(wdt->base + WDT_TIMEOUT_STATUS);\n\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  !(status & WDT_TIMEOUT_STATUS_BOOT_SECONDARY));\n}\n\nstatic ssize_t access_cs0_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t size)\n{\n\tstruct aspeed_wdt *wdt = dev_get_drvdata(dev);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\twritel(WDT_CLEAR_TIMEOUT_AND_BOOT_CODE_SELECTION,\n\t\t       wdt->base + WDT_CLEAR_TIMEOUT_STATUS);\n\n\treturn size;\n}\n\n \nstatic DEVICE_ATTR_RW(access_cs0);\n\nstatic struct attribute *bswitch_attrs[] = {\n\t&dev_attr_access_cs0.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(bswitch);\n\nstatic const struct watchdog_ops aspeed_wdt_ops = {\n\t.start\t\t= aspeed_wdt_start,\n\t.stop\t\t= aspeed_wdt_stop,\n\t.ping\t\t= aspeed_wdt_ping,\n\t.set_timeout\t= aspeed_wdt_set_timeout,\n\t.set_pretimeout = aspeed_wdt_set_pretimeout,\n\t.restart\t= aspeed_wdt_restart,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct watchdog_info aspeed_wdt_info = {\n\t.options\t= WDIOF_KEEPALIVEPING\n\t\t\t| WDIOF_MAGICCLOSE\n\t\t\t| WDIOF_SETTIMEOUT,\n\t.identity\t= KBUILD_MODNAME,\n};\n\nstatic const struct watchdog_info aspeed_wdt_pretimeout_info = {\n\t.options\t= WDIOF_KEEPALIVEPING\n\t\t\t| WDIOF_PRETIMEOUT\n\t\t\t| WDIOF_MAGICCLOSE\n\t\t\t| WDIOF_SETTIMEOUT,\n\t.identity\t= KBUILD_MODNAME,\n};\n\nstatic irqreturn_t aspeed_wdt_irq(int irq, void *arg)\n{\n\tstruct watchdog_device *wdd = arg;\n\tstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\n\tu32 status = readl(wdt->base + WDT_TIMEOUT_STATUS);\n\n\tif (status & WDT_TIMEOUT_STATUS_IRQ)\n\t\twatchdog_notify_pretimeout(wdd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int aspeed_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *ofdid;\n\tstruct aspeed_wdt *wdt;\n\tstruct device_node *np;\n\tconst char *reset_type;\n\tu32 duration;\n\tu32 status;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tnp = dev->of_node;\n\n\tofdid = of_match_node(aspeed_wdt_of_table, np);\n\tif (!ofdid)\n\t\treturn -EINVAL;\n\twdt->cfg = ofdid->data;\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\twdt->wdd.info = &aspeed_wdt_info;\n\n\tif (wdt->cfg->irq_mask) {\n\t\tint irq = platform_get_irq_optional(pdev, 0);\n\n\t\tif (irq > 0) {\n\t\t\tret = devm_request_irq(dev, irq, aspeed_wdt_irq,\n\t\t\t\t\t       IRQF_SHARED, dev_name(dev),\n\t\t\t\t\t       wdt);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twdt->wdd.info = &aspeed_wdt_pretimeout_info;\n\t\t}\n\t}\n\n\twdt->wdd.ops = &aspeed_wdt_ops;\n\twdt->wdd.max_hw_heartbeat_ms = WDT_MAX_TIMEOUT_MS;\n\twdt->wdd.parent = dev;\n\n\twdt->wdd.timeout = WDT_DEFAULT_TIMEOUT;\n\twatchdog_init_timeout(&wdt->wdd, 0, dev);\n\n\twatchdog_set_nowayout(&wdt->wdd, nowayout);\n\n\t \n\tif (of_device_is_compatible(np, \"aspeed,ast2400-wdt\"))\n\t\twdt->ctrl = WDT_CTRL_1MHZ_CLK;\n\n\t \n\tret = of_property_read_string(np, \"aspeed,reset-type\", &reset_type);\n\tif (ret) {\n\t\twdt->ctrl |= WDT_CTRL_RESET_MODE_SOC | WDT_CTRL_RESET_SYSTEM;\n\t} else {\n\t\tif (!strcmp(reset_type, \"cpu\"))\n\t\t\twdt->ctrl |= WDT_CTRL_RESET_MODE_ARM_CPU |\n\t\t\t\t     WDT_CTRL_RESET_SYSTEM;\n\t\telse if (!strcmp(reset_type, \"soc\"))\n\t\t\twdt->ctrl |= WDT_CTRL_RESET_MODE_SOC |\n\t\t\t\t     WDT_CTRL_RESET_SYSTEM;\n\t\telse if (!strcmp(reset_type, \"system\"))\n\t\t\twdt->ctrl |= WDT_CTRL_RESET_MODE_FULL_CHIP |\n\t\t\t\t     WDT_CTRL_RESET_SYSTEM;\n\t\telse if (strcmp(reset_type, \"none\"))\n\t\t\treturn -EINVAL;\n\t}\n\tif (of_property_read_bool(np, \"aspeed,external-signal\"))\n\t\twdt->ctrl |= WDT_CTRL_WDT_EXT;\n\tif (of_property_read_bool(np, \"aspeed,alt-boot\"))\n\t\twdt->ctrl |= WDT_CTRL_BOOT_SECONDARY;\n\n\tif (readl(wdt->base + WDT_CTRL) & WDT_CTRL_ENABLE)  {\n\t\t \n\t\taspeed_wdt_start(&wdt->wdd);\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdd.status);\n\t}\n\n\tif ((of_device_is_compatible(np, \"aspeed,ast2500-wdt\")) ||\n\t\t(of_device_is_compatible(np, \"aspeed,ast2600-wdt\"))) {\n\t\tu32 reg = readl(wdt->base + WDT_RESET_WIDTH);\n\n\t\treg &= wdt->cfg->ext_pulse_width_mask;\n\t\tif (of_property_read_bool(np, \"aspeed,ext-active-high\"))\n\t\t\treg |= WDT_ACTIVE_HIGH_MAGIC;\n\t\telse\n\t\t\treg |= WDT_ACTIVE_LOW_MAGIC;\n\n\t\twritel(reg, wdt->base + WDT_RESET_WIDTH);\n\n\t\treg &= wdt->cfg->ext_pulse_width_mask;\n\t\tif (of_property_read_bool(np, \"aspeed,ext-push-pull\"))\n\t\t\treg |= WDT_PUSH_PULL_MAGIC;\n\t\telse\n\t\t\treg |= WDT_OPEN_DRAIN_MAGIC;\n\n\t\twritel(reg, wdt->base + WDT_RESET_WIDTH);\n\t}\n\n\tif (!of_property_read_u32(np, \"aspeed,ext-pulse-duration\", &duration)) {\n\t\tu32 max_duration = wdt->cfg->ext_pulse_width_mask + 1;\n\n\t\tif (duration == 0 || duration > max_duration) {\n\t\t\tdev_err(dev, \"Invalid pulse duration: %uus\\n\",\n\t\t\t\tduration);\n\t\t\tduration = max(1U, min(max_duration, duration));\n\t\t\tdev_info(dev, \"Pulse duration set to %uus\\n\",\n\t\t\t\t duration);\n\t\t}\n\n\t\t \n\t\twritel(duration - 1, wdt->base + WDT_RESET_WIDTH);\n\t}\n\n\tstatus = readl(wdt->base + WDT_TIMEOUT_STATUS);\n\tif (status & WDT_TIMEOUT_STATUS_BOOT_SECONDARY) {\n\t\twdt->wdd.bootstatus = WDIOF_CARDRESET;\n\n\t\tif (of_device_is_compatible(np, \"aspeed,ast2400-wdt\") ||\n\t\t    of_device_is_compatible(np, \"aspeed,ast2500-wdt\"))\n\t\t\twdt->wdd.groups = bswitch_groups;\n\t}\n\n\tdev_set_drvdata(dev, wdt);\n\n\treturn devm_watchdog_register_device(dev, &wdt->wdd);\n}\n\nstatic struct platform_driver aspeed_watchdog_driver = {\n\t.probe = aspeed_wdt_probe,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = aspeed_wdt_of_table,\n\t},\n};\n\nstatic int __init aspeed_wdt_init(void)\n{\n\treturn platform_driver_register(&aspeed_watchdog_driver);\n}\narch_initcall(aspeed_wdt_init);\n\nstatic void __exit aspeed_wdt_exit(void)\n{\n\tplatform_driver_unregister(&aspeed_watchdog_driver);\n}\nmodule_exit(aspeed_wdt_exit);\n\nMODULE_DESCRIPTION(\"Aspeed Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}