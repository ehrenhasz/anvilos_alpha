{
  "module_name": "da9062_wdt.c",
  "hash_id": "25a485cae5bc150648eaa6c43191c29d0b7ec076a2ebfd1bd4daf3dfd5e0d11d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/da9062_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/mfd/da9062/registers.h>\n#include <linux/mfd/da9062/core.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n\nstatic const unsigned int wdt_timeout[] = { 0, 2, 4, 8, 16, 32, 65, 131 };\n#define DA9062_TWDSCALE_DISABLE\t\t0\n#define DA9062_TWDSCALE_MIN\t\t1\n#define DA9062_TWDSCALE_MAX\t\t(ARRAY_SIZE(wdt_timeout) - 1)\n#define DA9062_WDT_MIN_TIMEOUT\t\twdt_timeout[DA9062_TWDSCALE_MIN]\n#define DA9062_WDT_MAX_TIMEOUT\t\twdt_timeout[DA9062_TWDSCALE_MAX]\n#define DA9062_WDG_DEFAULT_TIMEOUT\twdt_timeout[DA9062_TWDSCALE_MAX-1]\n#define DA9062_RESET_PROTECTION_MS\t300\n\nstruct da9062_watchdog {\n\tstruct da9062 *hw;\n\tstruct watchdog_device wdtdev;\n\tbool use_sw_pm;\n};\n\nstatic unsigned int da9062_wdt_read_timeout(struct da9062_watchdog *wdt)\n{\n\tunsigned int val;\n\n\tregmap_read(wdt->hw->regmap, DA9062AA_CONTROL_D, &val);\n\n\treturn wdt_timeout[val & DA9062AA_TWDSCALE_MASK];\n}\n\nstatic unsigned int da9062_wdt_timeout_to_sel(unsigned int secs)\n{\n\tunsigned int i;\n\n\tfor (i = DA9062_TWDSCALE_MIN; i <= DA9062_TWDSCALE_MAX; i++) {\n\t\tif (wdt_timeout[i] >= secs)\n\t\t\treturn i;\n\t}\n\n\treturn DA9062_TWDSCALE_MAX;\n}\n\nstatic int da9062_reset_watchdog_timer(struct da9062_watchdog *wdt)\n{\n\treturn regmap_update_bits(wdt->hw->regmap, DA9062AA_CONTROL_F,\n\t\t\t\t  DA9062AA_WATCHDOG_MASK,\n\t\t\t\t  DA9062AA_WATCHDOG_MASK);\n}\n\nstatic int da9062_wdt_update_timeout_register(struct da9062_watchdog *wdt,\n\t\t\t\t\t      unsigned int regval)\n{\n\tstruct da9062 *chip = wdt->hw;\n\n\tregmap_update_bits(chip->regmap,\n\t\t\t\t  DA9062AA_CONTROL_D,\n\t\t\t\t  DA9062AA_TWDSCALE_MASK,\n\t\t\t\t  DA9062_TWDSCALE_DISABLE);\n\n\tusleep_range(150, 300);\n\n\treturn regmap_update_bits(chip->regmap,\n\t\t\t\t  DA9062AA_CONTROL_D,\n\t\t\t\t  DA9062AA_TWDSCALE_MASK,\n\t\t\t\t  regval);\n}\n\nstatic int da9062_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct da9062_watchdog *wdt = watchdog_get_drvdata(wdd);\n\tunsigned int selector;\n\tint ret;\n\n\tselector = da9062_wdt_timeout_to_sel(wdt->wdtdev.timeout);\n\tret = da9062_wdt_update_timeout_register(wdt, selector);\n\tif (ret)\n\t\tdev_err(wdt->hw->dev, \"Watchdog failed to start (err = %d)\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int da9062_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct da9062_watchdog *wdt = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tret = regmap_update_bits(wdt->hw->regmap,\n\t\t\t\t DA9062AA_CONTROL_D,\n\t\t\t\t DA9062AA_TWDSCALE_MASK,\n\t\t\t\t DA9062_TWDSCALE_DISABLE);\n\tif (ret)\n\t\tdev_err(wdt->hw->dev, \"Watchdog failed to stop (err = %d)\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int da9062_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct da9062_watchdog *wdt = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\t \n\tif (system_state > SYSTEM_RUNNING)\n\t\treturn 0;\n\n\tret = da9062_reset_watchdog_timer(wdt);\n\tif (ret)\n\t\tdev_err(wdt->hw->dev, \"Failed to ping the watchdog (err = %d)\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int da9062_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct da9062_watchdog *wdt = watchdog_get_drvdata(wdd);\n\tunsigned int selector;\n\tint ret;\n\n\tselector = da9062_wdt_timeout_to_sel(timeout);\n\tret = da9062_wdt_update_timeout_register(wdt, selector);\n\tif (ret)\n\t\tdev_err(wdt->hw->dev, \"Failed to set watchdog timeout (err = %d)\\n\",\n\t\t\tret);\n\telse\n\t\twdd->timeout = wdt_timeout[selector];\n\n\treturn ret;\n}\n\nstatic int da9062_wdt_restart(struct watchdog_device *wdd, unsigned long action,\n\t\t\t      void *data)\n{\n\tstruct da9062_watchdog *wdt = watchdog_get_drvdata(wdd);\n\tstruct i2c_client *client = to_i2c_client(wdt->hw->dev);\n\tunion i2c_smbus_data msg;\n\tint ret;\n\n\t \n\tmsg.byte = DA9062AA_SHUTDOWN_MASK;\n\tret = __i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t       I2C_SMBUS_WRITE, DA9062AA_CONTROL_F,\n\t\t\t       I2C_SMBUS_BYTE_DATA, &msg);\n\n\tif (ret < 0)\n\t\tdev_alert(wdt->hw->dev, \"Failed to shutdown (err = %d)\\n\",\n\t\t\t  ret);\n\n\t \n\tmdelay(500);\n\n\treturn ret;\n}\n\nstatic const struct watchdog_info da9062_watchdog_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n\t.identity = \"DA9062 WDT\",\n};\n\nstatic const struct watchdog_ops da9062_watchdog_ops = {\n\t.owner = THIS_MODULE,\n\t.start = da9062_wdt_start,\n\t.stop = da9062_wdt_stop,\n\t.ping = da9062_wdt_ping,\n\t.set_timeout = da9062_wdt_set_timeout,\n\t.restart = da9062_wdt_restart,\n};\n\nstatic const struct of_device_id da9062_compatible_id_table[] = {\n\t{ .compatible = \"dlg,da9062-watchdog\", },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, da9062_compatible_id_table);\n\nstatic int da9062_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tunsigned int timeout;\n\tstruct da9062 *chip;\n\tstruct da9062_watchdog *wdt;\n\n\tchip = dev_get_drvdata(dev->parent);\n\tif (!chip)\n\t\treturn -EINVAL;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->use_sw_pm = device_property_present(dev, \"dlg,use-sw-pm\");\n\n\twdt->hw = chip;\n\n\twdt->wdtdev.info = &da9062_watchdog_info;\n\twdt->wdtdev.ops = &da9062_watchdog_ops;\n\twdt->wdtdev.min_timeout = DA9062_WDT_MIN_TIMEOUT;\n\twdt->wdtdev.max_timeout = DA9062_WDT_MAX_TIMEOUT;\n\twdt->wdtdev.min_hw_heartbeat_ms = DA9062_RESET_PROTECTION_MS;\n\twdt->wdtdev.timeout = DA9062_WDG_DEFAULT_TIMEOUT;\n\twdt->wdtdev.status = WATCHDOG_NOWAYOUT_INIT_STATUS;\n\twdt->wdtdev.parent = dev;\n\n\twatchdog_set_restart_priority(&wdt->wdtdev, 128);\n\n\twatchdog_set_drvdata(&wdt->wdtdev, wdt);\n\tdev_set_drvdata(dev, &wdt->wdtdev);\n\n\ttimeout = da9062_wdt_read_timeout(wdt);\n\tif (timeout)\n\t\twdt->wdtdev.timeout = timeout;\n\n\t \n\twatchdog_init_timeout(&wdt->wdtdev, 0, dev);\n\n\tif (timeout) {\n\t\tda9062_wdt_set_timeout(&wdt->wdtdev, wdt->wdtdev.timeout);\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdtdev.status);\n\t}\n\n\treturn devm_watchdog_register_device(dev, &wdt->wdtdev);\n}\n\nstatic int __maybe_unused da9062_wdt_suspend(struct device *dev)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\tstruct da9062_watchdog *wdt = watchdog_get_drvdata(wdd);\n\n\tif (!wdt->use_sw_pm)\n\t\treturn 0;\n\n\tif (watchdog_active(wdd))\n\t\treturn da9062_wdt_stop(wdd);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused da9062_wdt_resume(struct device *dev)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\tstruct da9062_watchdog *wdt = watchdog_get_drvdata(wdd);\n\n\tif (!wdt->use_sw_pm)\n\t\treturn 0;\n\n\tif (watchdog_active(wdd))\n\t\treturn da9062_wdt_start(wdd);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(da9062_wdt_pm_ops,\n\t\t\t da9062_wdt_suspend, da9062_wdt_resume);\n\nstatic struct platform_driver da9062_wdt_driver = {\n\t.probe = da9062_wdt_probe,\n\t.driver = {\n\t\t.name = \"da9062-watchdog\",\n\t\t.pm = &da9062_wdt_pm_ops,\n\t\t.of_match_table = da9062_compatible_id_table,\n\t},\n};\nmodule_platform_driver(da9062_wdt_driver);\n\nMODULE_AUTHOR(\"S Twiss <stwiss.opensource@diasemi.com>\");\nMODULE_DESCRIPTION(\"WDT device driver for Dialog DA9062 and DA9061\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9062-watchdog\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}