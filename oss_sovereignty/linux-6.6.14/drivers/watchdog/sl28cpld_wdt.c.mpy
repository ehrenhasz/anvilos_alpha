{
  "module_name": "sl28cpld_wdt.c",
  "hash_id": "eff9123ad62cc439eba0be00f39a4c2f4cf5b614b67893648e1073c12dfabdda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sl28cpld_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\n \n#define WDT_CTRL\t\t\t0x00\n#define  WDT_CTRL_EN\t\t\tBIT(0)\n#define  WDT_CTRL_LOCK\t\t\tBIT(2)\n#define  WDT_CTRL_ASSERT_SYS_RESET\tBIT(6)\n#define  WDT_CTRL_ASSERT_WDT_TIMEOUT\tBIT(7)\n#define WDT_TIMEOUT\t\t\t0x01\n#define WDT_KICK\t\t\t0x02\n#define  WDT_KICK_VALUE\t\t\t0x6b\n#define WDT_COUNT\t\t\t0x03\n\n#define WDT_DEFAULT_TIMEOUT\t\t10\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int timeout;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Initial watchdog timeout in seconds\");\n\nstruct sl28cpld_wdt {\n\tstruct watchdog_device wdd;\n\tstruct regmap *regmap;\n\tu32 offset;\n\tbool assert_wdt_timeout;\n};\n\nstatic int sl28cpld_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct sl28cpld_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\treturn regmap_write(wdt->regmap, wdt->offset + WDT_KICK,\n\t\t\t    WDT_KICK_VALUE);\n}\n\nstatic int sl28cpld_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct sl28cpld_wdt *wdt = watchdog_get_drvdata(wdd);\n\tunsigned int val;\n\n\tval = WDT_CTRL_EN | WDT_CTRL_ASSERT_SYS_RESET;\n\tif (wdt->assert_wdt_timeout)\n\t\tval |= WDT_CTRL_ASSERT_WDT_TIMEOUT;\n\tif (nowayout)\n\t\tval |= WDT_CTRL_LOCK;\n\n\treturn regmap_update_bits(wdt->regmap, wdt->offset + WDT_CTRL,\n\t\t\t\t  val, val);\n}\n\nstatic int sl28cpld_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct sl28cpld_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\treturn regmap_update_bits(wdt->regmap, wdt->offset + WDT_CTRL,\n\t\t\t\t  WDT_CTRL_EN, 0);\n}\n\nstatic unsigned int sl28cpld_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct sl28cpld_wdt *wdt = watchdog_get_drvdata(wdd);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(wdt->regmap, wdt->offset + WDT_COUNT, &val);\n\tif (ret)\n\t\treturn 0;\n\n\treturn val;\n}\n\nstatic int sl28cpld_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t    unsigned int timeout)\n{\n\tstruct sl28cpld_wdt *wdt = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tret = regmap_write(wdt->regmap, wdt->offset + WDT_TIMEOUT, timeout);\n\tif (ret)\n\t\treturn ret;\n\n\twdd->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info sl28cpld_wdt_info = {\n\t.options = WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n\t.identity = \"sl28cpld watchdog\",\n};\n\nstatic const struct watchdog_ops sl28cpld_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = sl28cpld_wdt_start,\n\t.stop = sl28cpld_wdt_stop,\n\t.ping = sl28cpld_wdt_ping,\n\t.set_timeout = sl28cpld_wdt_set_timeout,\n\t.get_timeleft = sl28cpld_wdt_get_timeleft,\n};\n\nstatic int sl28cpld_wdt_probe(struct platform_device *pdev)\n{\n\tstruct watchdog_device *wdd;\n\tstruct sl28cpld_wdt *wdt;\n\tunsigned int status;\n\tunsigned int val;\n\tint ret;\n\n\tif (!pdev->dev.parent)\n\t\treturn -ENODEV;\n\n\twdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!wdt->regmap)\n\t\treturn -ENODEV;\n\n\tret = device_property_read_u32(&pdev->dev, \"reg\", &wdt->offset);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\twdt->assert_wdt_timeout = device_property_read_bool(&pdev->dev,\n\t\t\t\t\t\t\t    \"kontron,assert-wdt-timeout-pin\");\n\n\t \n\twdd = &wdt->wdd;\n\twdd->parent = &pdev->dev;\n\twdd->info = &sl28cpld_wdt_info;\n\twdd->ops = &sl28cpld_wdt_ops;\n\twdd->min_timeout = 1;\n\twdd->max_timeout = 255;\n\n\twatchdog_set_drvdata(wdd, wdt);\n\twatchdog_stop_on_reboot(wdd);\n\n\t \n\tret = regmap_read(wdt->regmap, wdt->offset + WDT_CTRL, &status);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(wdt->regmap, wdt->offset + WDT_TIMEOUT, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val)\n\t\twdd->timeout = val;\n\telse\n\t\twdd->timeout = WDT_DEFAULT_TIMEOUT;\n\n\twatchdog_init_timeout(wdd, timeout, &pdev->dev);\n\tsl28cpld_wdt_set_timeout(wdd, wdd->timeout);\n\n\t \n\tif (status & WDT_CTRL_LOCK)\n\t\tnowayout = true;\n\twatchdog_set_nowayout(wdd, nowayout);\n\n\t \n\tif (status & WDT_CTRL_EN) {\n\t\tsl28cpld_wdt_start(wdd);\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t}\n\n\tret = devm_watchdog_register_device(&pdev->dev, wdd);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register watchdog device\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"initial timeout %d sec%s\\n\",\n\t\t wdd->timeout, nowayout ? \", nowayout\" : \"\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sl28cpld_wdt_of_match[] = {\n\t{ .compatible = \"kontron,sl28cpld-wdt\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sl28cpld_wdt_of_match);\n\nstatic struct platform_driver sl28cpld_wdt_driver = {\n\t.probe = sl28cpld_wdt_probe,\n\t.driver = {\n\t\t.name = \"sl28cpld-wdt\",\n\t\t.of_match_table = sl28cpld_wdt_of_match,\n\t},\n};\nmodule_platform_driver(sl28cpld_wdt_driver);\n\nMODULE_DESCRIPTION(\"sl28cpld Watchdog Driver\");\nMODULE_AUTHOR(\"Michael Walle <michael@walle.cc>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}