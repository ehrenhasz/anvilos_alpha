{
  "module_name": "hpwdt.c",
  "hash_id": "58709ad6a82df04637ea68ac19f77190cea06aec8b1ab8b852f07ee43de01a0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/hpwdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#ifdef CONFIG_HPWDT_NMI_DECODING\n#include <asm/nmi.h>\n#endif\n#include <linux/crash_dump.h>\n\n#define HPWDT_VERSION\t\t\t\"2.0.4\"\n#define SECS_TO_TICKS(secs)\t\t((secs) * 1000 / 128)\n#define TICKS_TO_SECS(ticks)\t\t((ticks) * 128 / 1000)\n#define HPWDT_MAX_TICKS\t\t\t65535\n#define HPWDT_MAX_TIMER\t\t\tTICKS_TO_SECS(HPWDT_MAX_TICKS)\n#define DEFAULT_MARGIN\t\t\t30\n#define PRETIMEOUT_SEC\t\t\t9\n\nstatic bool ilo5;\nstatic unsigned int soft_margin = DEFAULT_MARGIN;\t \nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic bool pretimeout = IS_ENABLED(CONFIG_HPWDT_NMI_DECODING);\nstatic int kdumptimeout = -1;\n\nstatic void __iomem *pci_mem_addr;\t\t \nstatic unsigned long __iomem *hpwdt_nmistat;\nstatic unsigned long __iomem *hpwdt_timer_reg;\nstatic unsigned long __iomem *hpwdt_timer_con;\n\nstatic const struct pci_device_id hpwdt_devices[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_COMPAQ, 0xB203) },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_HP, 0x3306) },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_HP_3PAR, 0x0389) },\t \n\t{0},\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, hpwdt_devices);\n\nstatic const struct pci_device_id hpwdt_blacklist[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_HP, 0x3306, PCI_VENDOR_ID_HP, 0x1979) },  \n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_HP, 0x3306, PCI_VENDOR_ID_HP_3PAR, 0x0289) },   \n\t{0},\t\t\t \n};\n\nstatic struct watchdog_device hpwdt_dev;\n \nstatic int hpwdt_hw_is_running(void)\n{\n\treturn ioread8(hpwdt_timer_con) & 0x01;\n}\n\nstatic int hpwdt_start(struct watchdog_device *wdd)\n{\n\tint control = 0x81 | (pretimeout ? 0x4 : 0);\n\tint reload = SECS_TO_TICKS(min(wdd->timeout, wdd->max_hw_heartbeat_ms/1000));\n\n\tdev_dbg(wdd->parent, \"start watchdog 0x%08x:0x%08x:0x%02x\\n\", wdd->timeout, reload, control);\n\tiowrite16(reload, hpwdt_timer_reg);\n\tiowrite8(control, hpwdt_timer_con);\n\n\treturn 0;\n}\n\nstatic void hpwdt_stop(void)\n{\n\tunsigned long data;\n\n\tpr_debug(\"stop  watchdog\\n\");\n\n\tdata = ioread8(hpwdt_timer_con);\n\tdata &= 0xFE;\n\tiowrite8(data, hpwdt_timer_con);\n}\n\nstatic int hpwdt_stop_core(struct watchdog_device *wdd)\n{\n\thpwdt_stop();\n\n\treturn 0;\n}\n\nstatic void hpwdt_ping_ticks(int val)\n{\n\tval = min(val, HPWDT_MAX_TICKS);\n\tiowrite16(val, hpwdt_timer_reg);\n}\n\nstatic int hpwdt_ping(struct watchdog_device *wdd)\n{\n\tint reload = SECS_TO_TICKS(min(wdd->timeout, wdd->max_hw_heartbeat_ms/1000));\n\n\tdev_dbg(wdd->parent, \"ping  watchdog 0x%08x:0x%08x\\n\", wdd->timeout, reload);\n\thpwdt_ping_ticks(reload);\n\n\treturn 0;\n}\n\nstatic unsigned int hpwdt_gettimeleft(struct watchdog_device *wdd)\n{\n\treturn TICKS_TO_SECS(ioread16(hpwdt_timer_reg));\n}\n\nstatic int hpwdt_settimeout(struct watchdog_device *wdd, unsigned int val)\n{\n\tdev_dbg(wdd->parent, \"set_timeout = %d\\n\", val);\n\n\twdd->timeout = val;\n\tif (val <= wdd->pretimeout) {\n\t\tdev_dbg(wdd->parent, \"pretimeout < timeout. Setting to zero\\n\");\n\t\twdd->pretimeout = 0;\n\t\tpretimeout = false;\n\t\tif (watchdog_active(wdd))\n\t\t\thpwdt_start(wdd);\n\t}\n\thpwdt_ping(wdd);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HPWDT_NMI_DECODING\nstatic int hpwdt_set_pretimeout(struct watchdog_device *wdd, unsigned int req)\n{\n\tunsigned int val = 0;\n\n\tdev_dbg(wdd->parent, \"set_pretimeout = %d\\n\", req);\n\tif (req) {\n\t\tval = PRETIMEOUT_SEC;\n\t\tif (val >= wdd->timeout)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (val != req)\n\t\tdev_dbg(wdd->parent, \"Rounding pretimeout to: %d\\n\", val);\n\n\twdd->pretimeout = val;\n\tpretimeout = !!val;\n\n\tif (watchdog_active(wdd))\n\t\thpwdt_start(wdd);\n\n\treturn 0;\n}\n\nstatic int hpwdt_my_nmi(void)\n{\n\treturn ioread8(hpwdt_nmistat) & 0x6;\n}\n\n \nstatic int hpwdt_pretimeout(unsigned int ulReason, struct pt_regs *regs)\n{\n\tunsigned int mynmi = hpwdt_my_nmi();\n\tstatic char panic_msg[] =\n\t\t\"00: An NMI occurred. Depending on your system the reason \"\n\t\t\"for the NMI is logged in any one of the following resources:\\n\"\n\t\t\"1. Integrated Management Log (IML)\\n\"\n\t\t\"2. OA Syslog\\n\"\n\t\t\"3. OA Forward Progress Log\\n\"\n\t\t\"4. iLO Event Log\";\n\n\tif (ulReason == NMI_UNKNOWN && !mynmi)\n\t\treturn NMI_DONE;\n\n\tif (ilo5 && !pretimeout && !mynmi)\n\t\treturn NMI_DONE;\n\n\tif (kdumptimeout < 0)\n\t\thpwdt_stop();\n\telse if (kdumptimeout == 0)\n\t\t;\n\telse {\n\t\tunsigned int val = max((unsigned int)kdumptimeout, hpwdt_dev.timeout);\n\t\thpwdt_ping_ticks(SECS_TO_TICKS(val));\n\t}\n\n\thex_byte_pack(panic_msg, mynmi);\n\tnmi_panic(regs, panic_msg);\n\n\treturn NMI_HANDLED;\n}\n#endif  \n\n\nstatic const struct watchdog_info ident = {\n\t.options = WDIOF_PRETIMEOUT    |\n\t\t   WDIOF_SETTIMEOUT    |\n\t\t   WDIOF_KEEPALIVEPING |\n\t\t   WDIOF_MAGICCLOSE,\n\t.identity = \"HPE iLO2+ HW Watchdog Timer\",\n};\n\n \n\nstatic const struct watchdog_ops hpwdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= hpwdt_start,\n\t.stop\t\t= hpwdt_stop_core,\n\t.ping\t\t= hpwdt_ping,\n\t.set_timeout\t= hpwdt_settimeout,\n\t.get_timeleft\t= hpwdt_gettimeleft,\n#ifdef CONFIG_HPWDT_NMI_DECODING\n\t.set_pretimeout\t= hpwdt_set_pretimeout,\n#endif\n};\n\nstatic struct watchdog_device hpwdt_dev = {\n\t.info\t\t= &ident,\n\t.ops\t\t= &hpwdt_ops,\n\t.min_timeout\t= 1,\n\t.timeout\t= DEFAULT_MARGIN,\n\t.pretimeout\t= PRETIMEOUT_SEC,\n\t.max_hw_heartbeat_ms\t= HPWDT_MAX_TIMER * 1000,\n};\n\n\n \n\nstatic int hpwdt_init_nmi_decoding(struct pci_dev *dev)\n{\n#ifdef CONFIG_HPWDT_NMI_DECODING\n\tint retval;\n\t \n\tretval = register_nmi_handler(NMI_UNKNOWN, hpwdt_pretimeout, 0, \"hpwdt\");\n\tif (retval)\n\t\tgoto error;\n\tretval = register_nmi_handler(NMI_SERR, hpwdt_pretimeout, 0, \"hpwdt\");\n\tif (retval)\n\t\tgoto error1;\n\tretval = register_nmi_handler(NMI_IO_CHECK, hpwdt_pretimeout, 0, \"hpwdt\");\n\tif (retval)\n\t\tgoto error2;\n\n\tdev_info(&dev->dev,\n\t\t\"HPE Watchdog Timer Driver: NMI decoding initialized\\n\");\n\n\treturn 0;\n\nerror2:\n\tunregister_nmi_handler(NMI_SERR, \"hpwdt\");\nerror1:\n\tunregister_nmi_handler(NMI_UNKNOWN, \"hpwdt\");\nerror:\n\tdev_warn(&dev->dev,\n\t\t\"Unable to register a die notifier (err=%d).\\n\",\n\t\tretval);\n\treturn retval;\n#endif\t \n\treturn 0;\n}\n\nstatic void hpwdt_exit_nmi_decoding(void)\n{\n#ifdef CONFIG_HPWDT_NMI_DECODING\n\tunregister_nmi_handler(NMI_UNKNOWN, \"hpwdt\");\n\tunregister_nmi_handler(NMI_SERR, \"hpwdt\");\n\tunregister_nmi_handler(NMI_IO_CHECK, \"hpwdt\");\n#endif\n}\n\nstatic int hpwdt_init_one(struct pci_dev *dev,\n\t\t\t\t\tconst struct pci_device_id *ent)\n{\n\tint retval;\n\n\t \n\tif (dev->subsystem_vendor != PCI_VENDOR_ID_HP &&\n\t    dev->subsystem_vendor != PCI_VENDOR_ID_HP_3PAR) {\n\t\tdev_warn(&dev->dev,\n\t\t\t\"This server does not have an iLO2+ ASIC.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pci_match_id(hpwdt_blacklist, dev)) {\n\t\tdev_dbg(&dev->dev, \"Not supported on this device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pci_enable_device(dev)) {\n\t\tdev_warn(&dev->dev,\n\t\t\t\"Not possible to enable PCI Device: 0x%x:0x%x.\\n\",\n\t\t\tent->vendor, ent->device);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_mem_addr = pci_iomap(dev, 1, 0x80);\n\tif (!pci_mem_addr) {\n\t\tdev_warn(&dev->dev,\n\t\t\t\"Unable to detect the iLO2+ server memory.\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto error_pci_iomap;\n\t}\n\thpwdt_nmistat\t= pci_mem_addr + 0x6e;\n\thpwdt_timer_reg = pci_mem_addr + 0x70;\n\thpwdt_timer_con = pci_mem_addr + 0x72;\n\n\t \n\tif (hpwdt_hw_is_running()) {\n\t\tdev_info(&dev->dev, \"timer is running\\n\");\n\t\tset_bit(WDOG_HW_RUNNING, &hpwdt_dev.status);\n\t}\n\n\t \n\tretval = hpwdt_init_nmi_decoding(dev);\n\tif (retval != 0)\n\t\tgoto error_init_nmi_decoding;\n\n\twatchdog_stop_on_unregister(&hpwdt_dev);\n\twatchdog_set_nowayout(&hpwdt_dev, nowayout);\n\twatchdog_init_timeout(&hpwdt_dev, soft_margin, NULL);\n\n\tif (is_kdump_kernel()) {\n\t\tpretimeout = false;\n\t\tkdumptimeout = 0;\n\t}\n\n\tif (pretimeout && hpwdt_dev.timeout <= PRETIMEOUT_SEC) {\n\t\tdev_warn(&dev->dev, \"timeout <= pretimeout. Setting pretimeout to zero\\n\");\n\t\tpretimeout = false;\n\t}\n\thpwdt_dev.pretimeout = pretimeout ? PRETIMEOUT_SEC : 0;\n\tkdumptimeout = min(kdumptimeout, HPWDT_MAX_TIMER);\n\n\thpwdt_dev.parent = &dev->dev;\n\tretval = watchdog_register_device(&hpwdt_dev);\n\tif (retval < 0)\n\t\tgoto error_wd_register;\n\n\tdev_info(&dev->dev, \"HPE Watchdog Timer Driver: Version: %s\\n\",\n\t\t\t\tHPWDT_VERSION);\n\tdev_info(&dev->dev, \"timeout: %d seconds (nowayout=%d)\\n\",\n\t\t\t\thpwdt_dev.timeout, nowayout);\n\tdev_info(&dev->dev, \"pretimeout: %s.\\n\",\n\t\t\t\tpretimeout ? \"on\" : \"off\");\n\tdev_info(&dev->dev, \"kdumptimeout: %d.\\n\", kdumptimeout);\n\n\tif (dev->subsystem_vendor == PCI_VENDOR_ID_HP_3PAR)\n\t\tilo5 = true;\n\n\treturn 0;\n\nerror_wd_register:\n\thpwdt_exit_nmi_decoding();\nerror_init_nmi_decoding:\n\tpci_iounmap(dev, pci_mem_addr);\nerror_pci_iomap:\n\tpci_disable_device(dev);\n\treturn retval;\n}\n\nstatic void hpwdt_exit(struct pci_dev *dev)\n{\n\twatchdog_unregister_device(&hpwdt_dev);\n\thpwdt_exit_nmi_decoding();\n\tpci_iounmap(dev, pci_mem_addr);\n\tpci_disable_device(dev);\n}\n\nstatic struct pci_driver hpwdt_driver = {\n\t.name = \"hpwdt\",\n\t.id_table = hpwdt_devices,\n\t.probe = hpwdt_init_one,\n\t.remove = hpwdt_exit,\n};\n\nMODULE_AUTHOR(\"Tom Mingarelli\");\nMODULE_DESCRIPTION(\"hpe watchdog driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(HPWDT_VERSION);\n\nmodule_param(soft_margin, int, 0);\nMODULE_PARM_DESC(soft_margin, \"Watchdog timeout in seconds\");\n\nmodule_param_named(timeout, soft_margin, int, 0);\nMODULE_PARM_DESC(timeout, \"Alias of soft_margin\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nmodule_param(kdumptimeout, int, 0444);\nMODULE_PARM_DESC(kdumptimeout, \"Timeout applied for crash kernel transition in seconds\");\n\n#ifdef CONFIG_HPWDT_NMI_DECODING\nmodule_param(pretimeout, bool, 0);\nMODULE_PARM_DESC(pretimeout, \"Watchdog pretimeout enabled\");\n#endif\n\nmodule_pci_driver(hpwdt_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}