{
  "module_name": "at91sam9_wdt.c",
  "hash_id": "54d6105f7b77c209c145d779894f48080fb30160b33666f41d3dc4d712b4e010",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/at91sam9_wdt.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n\n#include \"at91sam9_wdt.h\"\n\n#define DRV_NAME \"AT91SAM9 Watchdog\"\n\n#define wdt_read(wdt, field) \\\n\treadl_relaxed((wdt)->base + (field))\n#define wdt_write(wtd, field, val) \\\n\twritel_relaxed((val), (wdt)->base + (field))\n\n \n#define ticks_to_hz_rounddown(t)\t((((t) + 1) * HZ) >> 8)\n#define ticks_to_hz_roundup(t)\t\t(((((t) + 1) * HZ) + 255) >> 8)\n#define ticks_to_secs(t)\t\t(((t) + 1) >> 8)\n#define secs_to_ticks(s)\t\t((s) ? (((s) << 8) - 1) : 0)\n\n#define WDT_MR_RESET\t0x3FFF2FFF\n\n \n#define WDT_COUNTER_MAX_TICKS\t0xFFF\n\n \n#define WDT_COUNTER_MAX_SECS\tticks_to_secs(WDT_COUNTER_MAX_TICKS)\n\n \n#define WDT_HW_TIMEOUT 2\n\n \n#define WDT_TIMEOUT\t(HZ/2)\n\n \n#define WDT_HEARTBEAT 15\nstatic int heartbeat;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeats in seconds. \"\n\t\"(default = \" __MODULE_STRING(WDT_HEARTBEAT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n#define to_wdt(wdd) container_of(wdd, struct at91wdt, wdd)\nstruct at91wdt {\n\tstruct watchdog_device wdd;\n\tvoid __iomem *base;\n\tunsigned long next_heartbeat;\t \n\tstruct timer_list timer;\t \n\tu32 mr;\n\tu32 mr_mask;\n\tunsigned long heartbeat;\t \n\tbool nowayout;\n\tunsigned int irq;\n\tstruct clk *sclk;\n};\n\n \n\nstatic irqreturn_t wdt_interrupt(int irq, void *dev_id)\n{\n\tstruct at91wdt *wdt = (struct at91wdt *)dev_id;\n\n\tif (wdt_read(wdt, AT91_WDT_SR)) {\n\t\tpr_crit(\"at91sam9 WDT software reset\\n\");\n\t\temergency_restart();\n\t\tpr_crit(\"Reboot didn't ?????\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic inline void at91_wdt_reset(struct at91wdt *wdt)\n{\n\twdt_write(wdt, AT91_WDT_CR, AT91_WDT_KEY | AT91_WDT_WDRSTT);\n}\n\n \nstatic void at91_ping(struct timer_list *t)\n{\n\tstruct at91wdt *wdt = from_timer(wdt, t, timer);\n\tif (time_before(jiffies, wdt->next_heartbeat) ||\n\t    !watchdog_active(&wdt->wdd)) {\n\t\tat91_wdt_reset(wdt);\n\t\tmod_timer(&wdt->timer, jiffies + wdt->heartbeat);\n\t} else {\n\t\tpr_crit(\"I will reset your machine !\\n\");\n\t}\n}\n\nstatic int at91_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct at91wdt *wdt = to_wdt(wdd);\n\t \n\twdt->next_heartbeat = jiffies + wdd->timeout * HZ;\n\treturn 0;\n}\n\nstatic int at91_wdt_stop(struct watchdog_device *wdd)\n{\n\t \n\treturn 0;\n}\n\nstatic int at91_wdt_set_timeout(struct watchdog_device *wdd, unsigned int new_timeout)\n{\n\twdd->timeout = new_timeout;\n\treturn at91_wdt_start(wdd);\n}\n\nstatic int at91_wdt_init(struct platform_device *pdev, struct at91wdt *wdt)\n{\n\tu32 tmp;\n\tu32 delta;\n\tu32 value;\n\tint err;\n\tu32 mask = wdt->mr_mask;\n\tunsigned long min_heartbeat = 1;\n\tunsigned long max_heartbeat;\n\tstruct device *dev = &pdev->dev;\n\n\ttmp = wdt_read(wdt, AT91_WDT_MR);\n\tif ((tmp & mask) != (wdt->mr & mask)) {\n\t\tif (tmp == WDT_MR_RESET) {\n\t\t\twdt_write(wdt, AT91_WDT_MR, wdt->mr);\n\t\t\ttmp = wdt_read(wdt, AT91_WDT_MR);\n\t\t}\n\t}\n\n\tif (tmp & AT91_WDT_WDDIS) {\n\t\tif (wdt->mr & AT91_WDT_WDDIS)\n\t\t\treturn 0;\n\t\tdev_err(dev, \"watchdog is disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvalue = tmp & AT91_WDT_WDV;\n\tdelta = (tmp & AT91_WDT_WDD) >> 16;\n\n\tif (delta < value)\n\t\tmin_heartbeat = ticks_to_hz_roundup(value - delta);\n\n\tmax_heartbeat = ticks_to_hz_rounddown(value);\n\tif (!max_heartbeat) {\n\t\tdev_err(dev,\n\t\t\t\"heartbeat is too small for the system to handle it correctly\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((max_heartbeat / 4) >= min_heartbeat)\n\t\twdt->heartbeat = max_heartbeat / 4;\n\telse if ((max_heartbeat / 2) >= min_heartbeat)\n\t\twdt->heartbeat = max_heartbeat / 2;\n\telse\n\t\twdt->heartbeat = min_heartbeat;\n\n\tif (max_heartbeat < min_heartbeat + 4)\n\t\tdev_warn(dev,\n\t\t\t \"min heartbeat and max heartbeat might be too close for the system to handle it correctly\\n\");\n\n\tif ((tmp & AT91_WDT_WDFIEN) && wdt->irq) {\n\t\terr = devm_request_irq(dev, wdt->irq, wdt_interrupt,\n\t\t\t\t       IRQF_SHARED | IRQF_IRQPOLL | IRQF_NO_SUSPEND,\n\t\t\t\t       pdev->name, wdt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif ((tmp & wdt->mr_mask) != (wdt->mr & wdt->mr_mask))\n\t\tdev_warn(dev,\n\t\t\t \"watchdog already configured differently (mr = %x expecting %x)\\n\",\n\t\t\t tmp & wdt->mr_mask, wdt->mr & wdt->mr_mask);\n\n\ttimer_setup(&wdt->timer, at91_ping, 0);\n\n\t \n\tmod_timer(&wdt->timer, jiffies + min_heartbeat);\n\n\t \n\tif (watchdog_init_timeout(&wdt->wdd, 0, dev))\n\t\twatchdog_init_timeout(&wdt->wdd, heartbeat, dev);\n\twatchdog_set_nowayout(&wdt->wdd, wdt->nowayout);\n\terr = watchdog_register_device(&wdt->wdd);\n\tif (err)\n\t\tgoto out_stop_timer;\n\n\twdt->next_heartbeat = jiffies + wdt->wdd.timeout * HZ;\n\n\treturn 0;\n\nout_stop_timer:\n\tdel_timer(&wdt->timer);\n\treturn err;\n}\n\n \n\nstatic const struct watchdog_info at91_wdt_info = {\n\t.identity\t= DRV_NAME,\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t\t\t\tWDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops at91_wdt_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.start =\tat91_wdt_start,\n\t.stop =\t\tat91_wdt_stop,\n\t.set_timeout =\tat91_wdt_set_timeout,\n};\n\n#if defined(CONFIG_OF)\nstatic int of_at91wdt_init(struct device_node *np, struct at91wdt *wdt)\n{\n\tu32 min = 0;\n\tu32 max = WDT_COUNTER_MAX_SECS;\n\tconst char *tmp;\n\n\t \n\twdt->irq = irq_of_parse_and_map(np, 0);\n\tif (!wdt->irq)\n\t\tdev_warn(wdt->wdd.parent, \"failed to get IRQ from DT\\n\");\n\n\tif (!of_property_read_u32_index(np, \"atmel,max-heartbeat-sec\", 0,\n\t\t\t\t\t&max)) {\n\t\tif (!max || max > WDT_COUNTER_MAX_SECS)\n\t\t\tmax = WDT_COUNTER_MAX_SECS;\n\n\t\tif (!of_property_read_u32_index(np, \"atmel,min-heartbeat-sec\",\n\t\t\t\t\t\t0, &min)) {\n\t\t\tif (min >= max)\n\t\t\t\tmin = max - 1;\n\t\t}\n\t}\n\n\tmin = secs_to_ticks(min);\n\tmax = secs_to_ticks(max);\n\n\twdt->mr_mask = 0x3FFFFFFF;\n\twdt->mr = 0;\n\tif (!of_property_read_string(np, \"atmel,watchdog-type\", &tmp) &&\n\t    !strcmp(tmp, \"software\")) {\n\t\twdt->mr |= AT91_WDT_WDFIEN;\n\t\twdt->mr_mask &= ~AT91_WDT_WDRPROC;\n\t} else {\n\t\twdt->mr |= AT91_WDT_WDRSTEN;\n\t}\n\n\tif (!of_property_read_string(np, \"atmel,reset-type\", &tmp) &&\n\t    !strcmp(tmp, \"proc\"))\n\t\twdt->mr |= AT91_WDT_WDRPROC;\n\n\tif (of_property_read_bool(np, \"atmel,disable\")) {\n\t\twdt->mr |= AT91_WDT_WDDIS;\n\t\twdt->mr_mask &= AT91_WDT_WDDIS;\n\t}\n\n\tif (of_property_read_bool(np, \"atmel,idle-halt\"))\n\t\twdt->mr |= AT91_WDT_WDIDLEHLT;\n\n\tif (of_property_read_bool(np, \"atmel,dbg-halt\"))\n\t\twdt->mr |= AT91_WDT_WDDBGHLT;\n\n\twdt->mr |= max | ((max - min) << 16);\n\n\treturn 0;\n}\n#else\nstatic inline int of_at91wdt_init(struct device_node *np, struct at91wdt *wdt)\n{\n\treturn 0;\n}\n#endif\n\nstatic int __init at91wdt_probe(struct platform_device *pdev)\n{\n\tint err;\n\tstruct at91wdt *wdt;\n\n\twdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->mr = (WDT_HW_TIMEOUT * 256) | AT91_WDT_WDRSTEN | AT91_WDT_WDD |\n\t\t  AT91_WDT_WDDBGHLT | AT91_WDT_WDIDLEHLT;\n\twdt->mr_mask = 0x3FFFFFFF;\n\twdt->nowayout = nowayout;\n\twdt->wdd.parent = &pdev->dev;\n\twdt->wdd.info = &at91_wdt_info;\n\twdt->wdd.ops = &at91_wdt_ops;\n\twdt->wdd.timeout = WDT_HEARTBEAT;\n\twdt->wdd.min_timeout = 1;\n\twdt->wdd.max_timeout = 0xFFFF;\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\twdt->sclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(wdt->sclk))\n\t\treturn PTR_ERR(wdt->sclk);\n\n\terr = clk_prepare_enable(wdt->sclk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Could not enable slow clock\\n\");\n\t\treturn err;\n\t}\n\n\tif (pdev->dev.of_node) {\n\t\terr = of_at91wdt_init(pdev->dev.of_node, wdt);\n\t\tif (err)\n\t\t\tgoto err_clk;\n\t}\n\n\terr = at91_wdt_init(pdev, wdt);\n\tif (err)\n\t\tgoto err_clk;\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\tpr_info(\"enabled (heartbeat=%d sec, nowayout=%d)\\n\",\n\t\twdt->wdd.timeout, wdt->nowayout);\n\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(wdt->sclk);\n\n\treturn err;\n}\n\nstatic int __exit at91wdt_remove(struct platform_device *pdev)\n{\n\tstruct at91wdt *wdt = platform_get_drvdata(pdev);\n\twatchdog_unregister_device(&wdt->wdd);\n\n\tpr_warn(\"I quit now, hardware will probably reboot!\\n\");\n\tdel_timer(&wdt->timer);\n\tclk_disable_unprepare(wdt->sclk);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id at91_wdt_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9260-wdt\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, at91_wdt_dt_ids);\n#endif\n\nstatic struct platform_driver at91wdt_driver = {\n\t.remove\t\t= __exit_p(at91wdt_remove),\n\t.driver\t\t= {\n\t\t.name\t= \"at91_wdt\",\n\t\t.of_match_table = of_match_ptr(at91_wdt_dt_ids),\n\t},\n};\n\nmodule_platform_driver_probe(at91wdt_driver, at91wdt_probe);\n\nMODULE_AUTHOR(\"Renaud CERRATO <r.cerrato@til-technologies.fr>\");\nMODULE_DESCRIPTION(\"Watchdog driver for Atmel AT91SAM9x processors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}