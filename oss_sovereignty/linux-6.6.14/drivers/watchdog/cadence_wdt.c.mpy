{
  "module_name": "cadence_wdt.c",
  "hash_id": "40b9541ee672dcabe8a5c636f8d50c4959da2f033ead669c05f4b740fedae7ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/cadence_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define CDNS_WDT_DEFAULT_TIMEOUT\t10\n \n#define CDNS_WDT_MIN_TIMEOUT\t1\n#define CDNS_WDT_MAX_TIMEOUT\t516\n\n \n#define CDNS_WDT_RESTART_KEY 0x00001999\n\n \n#define CDNS_WDT_REGISTER_ACCESS_KEY 0x00920000\n\n \n#define CDNS_WDT_COUNTER_VALUE_DIVISOR 0x1000\n\n \n#define CDNS_WDT_PRESCALE_64\t64\n#define CDNS_WDT_PRESCALE_512\t512\n#define CDNS_WDT_PRESCALE_4096\t4096\n#define CDNS_WDT_PRESCALE_SELECT_64\t1\n#define CDNS_WDT_PRESCALE_SELECT_512\t2\n#define CDNS_WDT_PRESCALE_SELECT_4096\t3\n\n \n#define CDNS_WDT_CLK_10MHZ\t10000000\n#define CDNS_WDT_CLK_75MHZ\t75000000\n\n \n#define CDNS_WDT_COUNTER_MAX 0xFFF\n\nstatic int wdt_timeout;\nstatic int nowayout = WATCHDOG_NOWAYOUT;\n\nmodule_param(wdt_timeout, int, 0644);\nMODULE_PARM_DESC(wdt_timeout,\n\t\t \"Watchdog time in seconds. (default=\"\n\t\t __MODULE_STRING(CDNS_WDT_DEFAULT_TIMEOUT) \")\");\n\nmodule_param(nowayout, int, 0644);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \nstruct cdns_wdt {\n\tvoid __iomem\t\t*regs;\n\tbool\t\t\trst;\n\tstruct clk\t\t*clk;\n\tu32\t\t\tprescaler;\n\tu32\t\t\tctrl_clksel;\n\tspinlock_t\t\tio_lock;\n\tstruct watchdog_device\tcdns_wdt_device;\n};\n\n \nstatic inline void cdns_wdt_writereg(struct cdns_wdt *wdt, u32 offset, u32 val)\n{\n\twritel_relaxed(val, wdt->regs + offset);\n}\n\n \n\n \n#define CDNS_WDT_ZMR_OFFSET\t0x0\t \n#define CDNS_WDT_CCR_OFFSET\t0x4\t \n#define CDNS_WDT_RESTART_OFFSET\t0x8\t \n#define CDNS_WDT_SR_OFFSET\t0xC\t \n\n \n#define CDNS_WDT_ZMR_WDEN_MASK\t0x00000001  \n#define CDNS_WDT_ZMR_RSTEN_MASK\t0x00000002  \n#define CDNS_WDT_ZMR_IRQEN_MASK\t0x00000004  \n#define CDNS_WDT_ZMR_RSTLEN_16\t0x00000030  \n#define CDNS_WDT_ZMR_ZKEY_VAL\t0x00ABC000  \n \n#define CDNS_WDT_CCR_CRV_MASK\t0x00003FFC  \n\n \nstatic int cdns_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct cdns_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tspin_lock(&wdt->io_lock);\n\tcdns_wdt_writereg(wdt, CDNS_WDT_ZMR_OFFSET,\n\t\t\t  CDNS_WDT_ZMR_ZKEY_VAL & (~CDNS_WDT_ZMR_WDEN_MASK));\n\tspin_unlock(&wdt->io_lock);\n\n\treturn 0;\n}\n\n \nstatic int cdns_wdt_reload(struct watchdog_device *wdd)\n{\n\tstruct cdns_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tspin_lock(&wdt->io_lock);\n\tcdns_wdt_writereg(wdt, CDNS_WDT_RESTART_OFFSET,\n\t\t\t  CDNS_WDT_RESTART_KEY);\n\tspin_unlock(&wdt->io_lock);\n\n\treturn 0;\n}\n\n \nstatic int cdns_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct cdns_wdt *wdt = watchdog_get_drvdata(wdd);\n\tunsigned int data = 0;\n\tunsigned short count;\n\tunsigned long clock_f = clk_get_rate(wdt->clk);\n\n\t \n\tcount = (wdd->timeout * (clock_f / wdt->prescaler)) /\n\t\t CDNS_WDT_COUNTER_VALUE_DIVISOR + 1;\n\n\tif (count > CDNS_WDT_COUNTER_MAX)\n\t\tcount = CDNS_WDT_COUNTER_MAX;\n\n\tspin_lock(&wdt->io_lock);\n\tcdns_wdt_writereg(wdt, CDNS_WDT_ZMR_OFFSET,\n\t\t\t  CDNS_WDT_ZMR_ZKEY_VAL);\n\n\tcount = (count << 2) & CDNS_WDT_CCR_CRV_MASK;\n\n\t \n\tdata = count | CDNS_WDT_REGISTER_ACCESS_KEY | wdt->ctrl_clksel;\n\tcdns_wdt_writereg(wdt, CDNS_WDT_CCR_OFFSET, data);\n\tdata = CDNS_WDT_ZMR_WDEN_MASK | CDNS_WDT_ZMR_RSTLEN_16 |\n\t       CDNS_WDT_ZMR_ZKEY_VAL;\n\n\t \n\tif (wdt->rst) {\n\t\tdata |= CDNS_WDT_ZMR_RSTEN_MASK;\n\t\tdata &= ~CDNS_WDT_ZMR_IRQEN_MASK;\n\t} else {\n\t\tdata &= ~CDNS_WDT_ZMR_RSTEN_MASK;\n\t\tdata |= CDNS_WDT_ZMR_IRQEN_MASK;\n\t}\n\tcdns_wdt_writereg(wdt, CDNS_WDT_ZMR_OFFSET, data);\n\tcdns_wdt_writereg(wdt, CDNS_WDT_RESTART_OFFSET,\n\t\t\t  CDNS_WDT_RESTART_KEY);\n\tspin_unlock(&wdt->io_lock);\n\n\treturn 0;\n}\n\n \nstatic int cdns_wdt_settimeout(struct watchdog_device *wdd,\n\t\t\t       unsigned int new_time)\n{\n\twdd->timeout = new_time;\n\n\treturn cdns_wdt_start(wdd);\n}\n\n \nstatic irqreturn_t cdns_wdt_irq_handler(int irq, void *dev_id)\n{\n\tstruct platform_device *pdev = dev_id;\n\n\tdev_info(&pdev->dev,\n\t\t \"Watchdog timed out. Internal reset not enabled\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const struct watchdog_info cdns_wdt_info = {\n\t.identity\t= \"cdns_wdt watchdog\",\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\n \nstatic const struct watchdog_ops cdns_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = cdns_wdt_start,\n\t.stop = cdns_wdt_stop,\n\t.ping = cdns_wdt_reload,\n\t.set_timeout = cdns_wdt_settimeout,\n};\n\n \n \nstatic int cdns_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret, irq;\n\tunsigned long clock_f;\n\tstruct cdns_wdt *wdt;\n\tstruct watchdog_device *cdns_wdt_device;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tcdns_wdt_device = &wdt->cdns_wdt_device;\n\tcdns_wdt_device->info = &cdns_wdt_info;\n\tcdns_wdt_device->ops = &cdns_wdt_ops;\n\tcdns_wdt_device->timeout = CDNS_WDT_DEFAULT_TIMEOUT;\n\tcdns_wdt_device->min_timeout = CDNS_WDT_MIN_TIMEOUT;\n\tcdns_wdt_device->max_timeout = CDNS_WDT_MAX_TIMEOUT;\n\n\twdt->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->regs))\n\t\treturn PTR_ERR(wdt->regs);\n\n\t \n\twdt->rst = of_property_read_bool(dev->of_node, \"reset-on-timeout\");\n\tirq = platform_get_irq(pdev, 0);\n\tif (!wdt->rst && irq >= 0) {\n\t\tret = devm_request_irq(dev, irq, cdns_wdt_irq_handler, 0,\n\t\t\t\t       pdev->name, pdev);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"cannot register interrupt handler err=%d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tcdns_wdt_device->parent = dev;\n\n\twatchdog_init_timeout(cdns_wdt_device, wdt_timeout, dev);\n\twatchdog_set_nowayout(cdns_wdt_device, nowayout);\n\twatchdog_stop_on_reboot(cdns_wdt_device);\n\twatchdog_set_drvdata(cdns_wdt_device, wdt);\n\n\twdt->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(wdt->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(wdt->clk),\n\t\t\t\t     \"input clock not found\\n\");\n\n\tclock_f = clk_get_rate(wdt->clk);\n\tif (clock_f <= CDNS_WDT_CLK_75MHZ) {\n\t\twdt->prescaler = CDNS_WDT_PRESCALE_512;\n\t\twdt->ctrl_clksel = CDNS_WDT_PRESCALE_SELECT_512;\n\t} else {\n\t\twdt->prescaler = CDNS_WDT_PRESCALE_4096;\n\t\twdt->ctrl_clksel = CDNS_WDT_PRESCALE_SELECT_4096;\n\t}\n\n\tspin_lock_init(&wdt->io_lock);\n\n\twatchdog_stop_on_reboot(cdns_wdt_device);\n\twatchdog_stop_on_unregister(cdns_wdt_device);\n\tret = devm_watchdog_register_device(dev, cdns_wdt_device);\n\tif (ret)\n\t\treturn ret;\n\tplatform_set_drvdata(pdev, wdt);\n\n\tdev_info(dev, \"Xilinx Watchdog Timer with timeout %ds%s\\n\",\n\t\t cdns_wdt_device->timeout, nowayout ? \", nowayout\" : \"\");\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused cdns_wdt_suspend(struct device *dev)\n{\n\tstruct cdns_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->cdns_wdt_device)) {\n\t\tcdns_wdt_stop(&wdt->cdns_wdt_device);\n\t\tclk_disable_unprepare(wdt->clk);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused cdns_wdt_resume(struct device *dev)\n{\n\tint ret;\n\tstruct cdns_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->cdns_wdt_device)) {\n\t\tret = clk_prepare_enable(wdt->clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"unable to enable clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tcdns_wdt_start(&wdt->cdns_wdt_device);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cdns_wdt_pm_ops, cdns_wdt_suspend, cdns_wdt_resume);\n\nstatic const struct of_device_id cdns_wdt_of_match[] = {\n\t{ .compatible = \"cdns,wdt-r1p2\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, cdns_wdt_of_match);\n\n \nstatic struct platform_driver cdns_wdt_driver = {\n\t.probe\t\t= cdns_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"cdns-wdt\",\n\t\t.of_match_table = cdns_wdt_of_match,\n\t\t.pm\t= &cdns_wdt_pm_ops,\n\t},\n};\n\nmodule_platform_driver(cdns_wdt_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Watchdog driver for Cadence WDT\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}