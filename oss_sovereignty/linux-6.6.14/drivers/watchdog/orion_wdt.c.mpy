{
  "module_name": "orion_wdt.c",
  "hash_id": "8c7bb924b6617a6cb75180b938b041fafe28edf4317e49b32eea8a68b86fb593",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/orion_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n \n#define ORION_RSTOUT_MASK_OFFSET\t0x20108\n\n \n#define INTERNAL_REGS_MASK\t\t~(SZ_1M - 1)\n\n \n#define TIMER_CTRL\t\t0x0000\n#define TIMER1_FIXED_ENABLE_BIT\tBIT(12)\n#define WDT_AXP_FIXED_ENABLE_BIT BIT(10)\n#define TIMER1_ENABLE_BIT\tBIT(2)\n\n#define TIMER_A370_STATUS\t0x0004\n#define WDT_A370_EXPIRED\tBIT(31)\n#define TIMER1_STATUS_BIT\tBIT(8)\n\n#define TIMER1_VAL_OFF\t\t0x001c\n\n#define WDT_MAX_CYCLE_COUNT\t0xffffffff\n\n#define WDT_A370_RATIO_MASK(v)\t((v) << 16)\n#define WDT_A370_RATIO_SHIFT\t5\n#define WDT_A370_RATIO\t\t(1 << WDT_A370_RATIO_SHIFT)\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic int heartbeat;\t\t \n\nstruct orion_watchdog;\n\nstruct orion_watchdog_data {\n\tint wdt_counter_offset;\n\tint wdt_enable_bit;\n\tint rstout_enable_bit;\n\tint rstout_mask_bit;\n\tint (*clock_init)(struct platform_device *,\n\t\t\t  struct orion_watchdog *);\n\tint (*enabled)(struct orion_watchdog *);\n\tint (*start)(struct watchdog_device *);\n\tint (*stop)(struct watchdog_device *);\n};\n\nstruct orion_watchdog {\n\tstruct watchdog_device wdt;\n\tvoid __iomem *reg;\n\tvoid __iomem *rstout;\n\tvoid __iomem *rstout_mask;\n\tunsigned long clk_rate;\n\tstruct clk *clk;\n\tconst struct orion_watchdog_data *data;\n};\n\nstatic int orion_wdt_clock_init(struct platform_device *pdev,\n\t\t\t\tstruct orion_watchdog *dev)\n{\n\tint ret;\n\n\tdev->clk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn PTR_ERR(dev->clk);\n\tret = clk_prepare_enable(dev->clk);\n\tif (ret) {\n\t\tclk_put(dev->clk);\n\t\treturn ret;\n\t}\n\n\tdev->clk_rate = clk_get_rate(dev->clk);\n\treturn 0;\n}\n\nstatic int armada370_wdt_clock_init(struct platform_device *pdev,\n\t\t\t\t    struct orion_watchdog *dev)\n{\n\tint ret;\n\n\tdev->clk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn PTR_ERR(dev->clk);\n\tret = clk_prepare_enable(dev->clk);\n\tif (ret) {\n\t\tclk_put(dev->clk);\n\t\treturn ret;\n\t}\n\n\t \n\tatomic_io_modify(dev->reg + TIMER_CTRL,\n\t\t\tWDT_A370_RATIO_MASK(WDT_A370_RATIO_SHIFT),\n\t\t\tWDT_A370_RATIO_MASK(WDT_A370_RATIO_SHIFT));\n\n\tdev->clk_rate = clk_get_rate(dev->clk) / WDT_A370_RATIO;\n\treturn 0;\n}\n\nstatic int armada375_wdt_clock_init(struct platform_device *pdev,\n\t\t\t\t    struct orion_watchdog *dev)\n{\n\tint ret;\n\n\tdev->clk = of_clk_get_by_name(pdev->dev.of_node, \"fixed\");\n\tif (!IS_ERR(dev->clk)) {\n\t\tret = clk_prepare_enable(dev->clk);\n\t\tif (ret) {\n\t\t\tclk_put(dev->clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tatomic_io_modify(dev->reg + TIMER_CTRL,\n\t\t\t\tWDT_AXP_FIXED_ENABLE_BIT,\n\t\t\t\tWDT_AXP_FIXED_ENABLE_BIT);\n\t\tdev->clk_rate = clk_get_rate(dev->clk);\n\n\t\treturn 0;\n\t}\n\n\t \n\tdev->clk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn PTR_ERR(dev->clk);\n\n\tret = clk_prepare_enable(dev->clk);\n\tif (ret) {\n\t\tclk_put(dev->clk);\n\t\treturn ret;\n\t}\n\n\tatomic_io_modify(dev->reg + TIMER_CTRL,\n\t\t\tWDT_A370_RATIO_MASK(WDT_A370_RATIO_SHIFT),\n\t\t\tWDT_A370_RATIO_MASK(WDT_A370_RATIO_SHIFT));\n\tdev->clk_rate = clk_get_rate(dev->clk) / WDT_A370_RATIO;\n\n\treturn 0;\n}\n\nstatic int armadaxp_wdt_clock_init(struct platform_device *pdev,\n\t\t\t\t   struct orion_watchdog *dev)\n{\n\tint ret;\n\tu32 val;\n\n\tdev->clk = of_clk_get_by_name(pdev->dev.of_node, \"fixed\");\n\tif (IS_ERR(dev->clk))\n\t\treturn PTR_ERR(dev->clk);\n\tret = clk_prepare_enable(dev->clk);\n\tif (ret) {\n\t\tclk_put(dev->clk);\n\t\treturn ret;\n\t}\n\n\t \n\tval = WDT_AXP_FIXED_ENABLE_BIT | TIMER1_FIXED_ENABLE_BIT;\n\tatomic_io_modify(dev->reg + TIMER_CTRL, val, val);\n\n\tdev->clk_rate = clk_get_rate(dev->clk);\n\treturn 0;\n}\n\nstatic int orion_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\t \n\twritel(dev->clk_rate * wdt_dev->timeout,\n\t       dev->reg + dev->data->wdt_counter_offset);\n\tif (dev->wdt.info->options & WDIOF_PRETIMEOUT)\n\t\twritel(dev->clk_rate * (wdt_dev->timeout - wdt_dev->pretimeout),\n\t\t       dev->reg + TIMER1_VAL_OFF);\n\n\treturn 0;\n}\n\nstatic int armada375_start(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\tu32 reg;\n\n\t \n\twritel(dev->clk_rate * wdt_dev->timeout,\n\t       dev->reg + dev->data->wdt_counter_offset);\n\tif (dev->wdt.info->options & WDIOF_PRETIMEOUT)\n\t\twritel(dev->clk_rate * (wdt_dev->timeout - wdt_dev->pretimeout),\n\t\t       dev->reg + TIMER1_VAL_OFF);\n\n\t \n\tatomic_io_modify(dev->reg + TIMER_A370_STATUS, WDT_A370_EXPIRED, 0);\n\n\t \n\treg = dev->data->wdt_enable_bit;\n\tif (dev->wdt.info->options & WDIOF_PRETIMEOUT)\n\t\treg |= TIMER1_ENABLE_BIT;\n\tatomic_io_modify(dev->reg + TIMER_CTRL, reg, reg);\n\n\t \n\treg = readl(dev->rstout);\n\treg |= dev->data->rstout_enable_bit;\n\twritel(reg, dev->rstout);\n\n\tatomic_io_modify(dev->rstout_mask, dev->data->rstout_mask_bit, 0);\n\treturn 0;\n}\n\nstatic int armada370_start(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\tu32 reg;\n\n\t \n\twritel(dev->clk_rate * wdt_dev->timeout,\n\t       dev->reg + dev->data->wdt_counter_offset);\n\n\t \n\tatomic_io_modify(dev->reg + TIMER_A370_STATUS, WDT_A370_EXPIRED, 0);\n\n\t \n\treg = dev->data->wdt_enable_bit;\n\tif (dev->wdt.info->options & WDIOF_PRETIMEOUT)\n\t\treg |= TIMER1_ENABLE_BIT;\n\tatomic_io_modify(dev->reg + TIMER_CTRL, reg, reg);\n\n\t \n\treg = readl(dev->rstout);\n\treg |= dev->data->rstout_enable_bit;\n\twritel(reg, dev->rstout);\n\treturn 0;\n}\n\nstatic int orion_start(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\n\t \n\twritel(dev->clk_rate * wdt_dev->timeout,\n\t       dev->reg + dev->data->wdt_counter_offset);\n\n\t \n\tatomic_io_modify(dev->reg + TIMER_CTRL, dev->data->wdt_enable_bit,\n\t\t\t\t\t\tdev->data->wdt_enable_bit);\n\n\t \n\tatomic_io_modify(dev->rstout, dev->data->rstout_enable_bit,\n\t\t\t\t      dev->data->rstout_enable_bit);\n\n\treturn 0;\n}\n\nstatic int orion_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\n\t \n\treturn dev->data->start(wdt_dev);\n}\n\nstatic int orion_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\n\t \n\tatomic_io_modify(dev->rstout, dev->data->rstout_enable_bit, 0);\n\n\t \n\tatomic_io_modify(dev->reg + TIMER_CTRL, dev->data->wdt_enable_bit, 0);\n\n\treturn 0;\n}\n\nstatic int armada375_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\tu32 reg, mask;\n\n\t \n\tatomic_io_modify(dev->rstout_mask, dev->data->rstout_mask_bit,\n\t\t\t\t\t   dev->data->rstout_mask_bit);\n\treg = readl(dev->rstout);\n\treg &= ~dev->data->rstout_enable_bit;\n\twritel(reg, dev->rstout);\n\n\t \n\tmask = dev->data->wdt_enable_bit;\n\tif (wdt_dev->info->options & WDIOF_PRETIMEOUT)\n\t\tmask |= TIMER1_ENABLE_BIT;\n\tatomic_io_modify(dev->reg + TIMER_CTRL, mask, 0);\n\n\treturn 0;\n}\n\nstatic int armada370_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\tu32 reg, mask;\n\n\t \n\treg = readl(dev->rstout);\n\treg &= ~dev->data->rstout_enable_bit;\n\twritel(reg, dev->rstout);\n\n\t \n\tmask = dev->data->wdt_enable_bit;\n\tif (wdt_dev->info->options & WDIOF_PRETIMEOUT)\n\t\tmask |= TIMER1_ENABLE_BIT;\n\tatomic_io_modify(dev->reg + TIMER_CTRL, mask, 0);\n\n\treturn 0;\n}\n\nstatic int orion_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\n\treturn dev->data->stop(wdt_dev);\n}\n\nstatic int orion_enabled(struct orion_watchdog *dev)\n{\n\tbool enabled, running;\n\n\tenabled = readl(dev->rstout) & dev->data->rstout_enable_bit;\n\trunning = readl(dev->reg + TIMER_CTRL) & dev->data->wdt_enable_bit;\n\n\treturn enabled && running;\n}\n\nstatic int armada375_enabled(struct orion_watchdog *dev)\n{\n\tbool masked, enabled, running;\n\n\tmasked = readl(dev->rstout_mask) & dev->data->rstout_mask_bit;\n\tenabled = readl(dev->rstout) & dev->data->rstout_enable_bit;\n\trunning = readl(dev->reg + TIMER_CTRL) & dev->data->wdt_enable_bit;\n\n\treturn !masked && enabled && running;\n}\n\nstatic int orion_wdt_enabled(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\n\treturn dev->data->enabled(dev);\n}\n\nstatic unsigned int orion_wdt_get_timeleft(struct watchdog_device *wdt_dev)\n{\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\treturn readl(dev->reg + dev->data->wdt_counter_offset) / dev->clk_rate;\n}\n\nstatic struct watchdog_info orion_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"Orion Watchdog\",\n};\n\nstatic const struct watchdog_ops orion_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = orion_wdt_start,\n\t.stop = orion_wdt_stop,\n\t.ping = orion_wdt_ping,\n\t.get_timeleft = orion_wdt_get_timeleft,\n};\n\nstatic irqreturn_t orion_wdt_irq(int irq, void *devid)\n{\n\tpanic(\"Watchdog Timeout\");\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t orion_wdt_pre_irq(int irq, void *devid)\n{\n\tstruct orion_watchdog *dev = devid;\n\n\tatomic_io_modify(dev->reg + TIMER_A370_STATUS,\n\t\t\t TIMER1_STATUS_BIT, 0);\n\twatchdog_notify_pretimeout(&dev->wdt);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void __iomem *orion_wdt_ioremap_rstout(struct platform_device *pdev,\n\t\t\t\t\t      phys_addr_t internal_regs)\n{\n\tstruct resource *res;\n\tphys_addr_t rstout;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res)\n\t\treturn devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t    resource_size(res));\n\n\trstout = internal_regs + ORION_RSTOUT_MASK_OFFSET;\n\n\tWARN(1, FW_BUG \"falling back to hardcoded RSTOUT reg %pa\\n\", &rstout);\n\treturn devm_ioremap(&pdev->dev, rstout, 0x4);\n}\n\nstatic const struct orion_watchdog_data orion_data = {\n\t.rstout_enable_bit = BIT(1),\n\t.wdt_enable_bit = BIT(4),\n\t.wdt_counter_offset = 0x24,\n\t.clock_init = orion_wdt_clock_init,\n\t.enabled = orion_enabled,\n\t.start = orion_start,\n\t.stop = orion_stop,\n};\n\nstatic const struct orion_watchdog_data armada370_data = {\n\t.rstout_enable_bit = BIT(8),\n\t.wdt_enable_bit = BIT(8),\n\t.wdt_counter_offset = 0x34,\n\t.clock_init = armada370_wdt_clock_init,\n\t.enabled = orion_enabled,\n\t.start = armada370_start,\n\t.stop = armada370_stop,\n};\n\nstatic const struct orion_watchdog_data armadaxp_data = {\n\t.rstout_enable_bit = BIT(8),\n\t.wdt_enable_bit = BIT(8),\n\t.wdt_counter_offset = 0x34,\n\t.clock_init = armadaxp_wdt_clock_init,\n\t.enabled = orion_enabled,\n\t.start = armada370_start,\n\t.stop = armada370_stop,\n};\n\nstatic const struct orion_watchdog_data armada375_data = {\n\t.rstout_enable_bit = BIT(8),\n\t.rstout_mask_bit = BIT(10),\n\t.wdt_enable_bit = BIT(8),\n\t.wdt_counter_offset = 0x34,\n\t.clock_init = armada375_wdt_clock_init,\n\t.enabled = armada375_enabled,\n\t.start = armada375_start,\n\t.stop = armada375_stop,\n};\n\nstatic const struct orion_watchdog_data armada380_data = {\n\t.rstout_enable_bit = BIT(8),\n\t.rstout_mask_bit = BIT(10),\n\t.wdt_enable_bit = BIT(8),\n\t.wdt_counter_offset = 0x34,\n\t.clock_init = armadaxp_wdt_clock_init,\n\t.enabled = armada375_enabled,\n\t.start = armada375_start,\n\t.stop = armada375_stop,\n};\n\nstatic const struct of_device_id orion_wdt_of_match_table[] = {\n\t{\n\t\t.compatible = \"marvell,orion-wdt\",\n\t\t.data = &orion_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-370-wdt\",\n\t\t.data = &armada370_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-xp-wdt\",\n\t\t.data = &armadaxp_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-375-wdt\",\n\t\t.data = &armada375_data,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-380-wdt\",\n\t\t.data = &armada380_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, orion_wdt_of_match_table);\n\nstatic int orion_wdt_get_regs(struct platform_device *pdev,\n\t\t\t      struct orion_watchdog *dev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\tdev->reg = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\tresource_size(res));\n\tif (!dev->reg)\n\t\treturn -ENOMEM;\n\n\t \n\tif (of_device_is_compatible(node, \"marvell,orion-wdt\")) {\n\n\t\tdev->rstout = orion_wdt_ioremap_rstout(pdev, res->start &\n\t\t\t\t\t\t       INTERNAL_REGS_MASK);\n\t\tif (!dev->rstout)\n\t\t\treturn -ENODEV;\n\n\t} else if (of_device_is_compatible(node, \"marvell,armada-370-wdt\") ||\n\t\t   of_device_is_compatible(node, \"marvell,armada-xp-wdt\")) {\n\n\t\t \n\t\tdev->rstout = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(dev->rstout))\n\t\t\treturn PTR_ERR(dev->rstout);\n\n\t} else if (of_device_is_compatible(node, \"marvell,armada-375-wdt\") ||\n\t\t   of_device_is_compatible(node, \"marvell,armada-380-wdt\")) {\n\n\t\t \n\t\tdev->rstout = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(dev->rstout))\n\t\t\treturn PTR_ERR(dev->rstout);\n\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\t\tif (!res)\n\t\t\treturn -ENODEV;\n\t\tdev->rstout_mask = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\t\tif (!dev->rstout_mask)\n\t\t\treturn -ENOMEM;\n\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int orion_wdt_probe(struct platform_device *pdev)\n{\n\tstruct orion_watchdog *dev;\n\tconst struct of_device_id *match;\n\tunsigned int wdt_max_duration;\t \n\tint ret, irq;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(struct orion_watchdog),\n\t\t\t   GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_device(orion_wdt_of_match_table, &pdev->dev);\n\tif (!match)\n\t\t \n\t\tmatch = &orion_wdt_of_match_table[0];\n\n\tdev->wdt.info = &orion_wdt_info;\n\tdev->wdt.ops = &orion_wdt_ops;\n\tdev->wdt.min_timeout = 1;\n\tdev->data = match->data;\n\n\tret = orion_wdt_get_regs(pdev, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dev->data->clock_init(pdev, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot initialize clock\\n\");\n\t\treturn ret;\n\t}\n\n\twdt_max_duration = WDT_MAX_CYCLE_COUNT / dev->clk_rate;\n\n\tdev->wdt.timeout = wdt_max_duration;\n\tdev->wdt.max_timeout = wdt_max_duration;\n\tdev->wdt.parent = &pdev->dev;\n\twatchdog_init_timeout(&dev->wdt, heartbeat, &pdev->dev);\n\n\tplatform_set_drvdata(pdev, &dev->wdt);\n\twatchdog_set_drvdata(&dev->wdt, dev);\n\n\t \n\tif (!orion_wdt_enabled(&dev->wdt))\n\t\torion_wdt_stop(&dev->wdt);\n\telse\n\t\tset_bit(WDOG_HW_RUNNING, &dev->wdt.status);\n\n\t \n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq > 0) {\n\t\t \n\t\tret = devm_request_irq(&pdev->dev, irq, orion_wdt_irq, 0,\n\t\t\t\t       pdev->name, dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\t\tgoto disable_clk;\n\t\t}\n\t}\n\n\t \n\tirq = platform_get_irq_optional(pdev, 1);\n\tif (irq > 0) {\n\t\torion_wdt_info.options |= WDIOF_PRETIMEOUT;\n\t\tret = devm_request_irq(&pdev->dev, irq, orion_wdt_pre_irq,\n\t\t\t\t       0, pdev->name, dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to request IRQ\\n\");\n\t\t\tgoto disable_clk;\n\t\t}\n\t}\n\n\n\twatchdog_set_nowayout(&dev->wdt, nowayout);\n\tret = watchdog_register_device(&dev->wdt);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tpr_info(\"Initial timeout %d sec%s\\n\",\n\t\tdev->wdt.timeout, nowayout ? \", nowayout\" : \"\");\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(dev->clk);\n\tclk_put(dev->clk);\n\treturn ret;\n}\n\nstatic void orion_wdt_remove(struct platform_device *pdev)\n{\n\tstruct watchdog_device *wdt_dev = platform_get_drvdata(pdev);\n\tstruct orion_watchdog *dev = watchdog_get_drvdata(wdt_dev);\n\n\twatchdog_unregister_device(wdt_dev);\n\tclk_disable_unprepare(dev->clk);\n\tclk_put(dev->clk);\n}\n\nstatic void orion_wdt_shutdown(struct platform_device *pdev)\n{\n\tstruct watchdog_device *wdt_dev = platform_get_drvdata(pdev);\n\torion_wdt_stop(wdt_dev);\n}\n\nstatic struct platform_driver orion_wdt_driver = {\n\t.probe\t\t= orion_wdt_probe,\n\t.remove_new\t= orion_wdt_remove,\n\t.shutdown\t= orion_wdt_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"orion_wdt\",\n\t\t.of_match_table = orion_wdt_of_match_table,\n\t},\n};\n\nmodule_platform_driver(orion_wdt_driver);\n\nMODULE_AUTHOR(\"Sylver Bruneau <sylver.bruneau@googlemail.com>\");\nMODULE_DESCRIPTION(\"Orion Processor Watchdog\");\n\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Initial watchdog heartbeat in seconds\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:orion_wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}