{
  "module_name": "ziirave_wdt.c",
  "hash_id": "484a88d89abeabaa94c1049792ab76877c27df2337ec3115d0a5a9257591790b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ziirave_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/ihex.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#include <asm/unaligned.h>\n\n#define ZIIRAVE_TIMEOUT_MIN\t3\n#define ZIIRAVE_TIMEOUT_MAX\t255\n#define ZIIRAVE_TIMEOUT_DEFAULT\t30\n\n#define ZIIRAVE_PING_VALUE\t0x0\n\n#define ZIIRAVE_STATE_INITIAL\t0x0\n#define ZIIRAVE_STATE_OFF\t0x1\n#define ZIIRAVE_STATE_ON\t0x2\n\n#define ZIIRAVE_FW_NAME\t\t\"ziirave_wdt.fw\"\n\nstatic char *ziirave_reasons[] = {\"power cycle\", \"hw watchdog\", NULL, NULL,\n\t\t\t\t  \"host request\", NULL, \"illegal configuration\",\n\t\t\t\t  \"illegal instruction\", \"illegal trap\",\n\t\t\t\t  \"unknown\"};\n\n#define ZIIRAVE_WDT_FIRM_VER_MAJOR\t0x1\n#define ZIIRAVE_WDT_BOOT_VER_MAJOR\t0x3\n#define ZIIRAVE_WDT_RESET_REASON\t0x5\n#define ZIIRAVE_WDT_STATE\t\t0x6\n#define ZIIRAVE_WDT_TIMEOUT\t\t0x7\n#define ZIIRAVE_WDT_TIME_LEFT\t\t0x8\n#define ZIIRAVE_WDT_PING\t\t0x9\n#define ZIIRAVE_WDT_RESET_DURATION\t0xa\n\n#define ZIIRAVE_FIRM_PKT_TOTAL_SIZE\t20\n#define ZIIRAVE_FIRM_PKT_DATA_SIZE\t16\n#define ZIIRAVE_FIRM_FLASH_MEMORY_START\t(2 * 0x1600)\n#define ZIIRAVE_FIRM_FLASH_MEMORY_END\t(2 * 0x2bbf)\n#define ZIIRAVE_FIRM_PAGE_SIZE\t\t128\n\n \n#define ZIIRAVE_FIRM_DOWNLOAD_ACK\t1\n\n \n#define ZIIRAVE_CMD_DOWNLOAD_START\t\t0x10\n#define ZIIRAVE_CMD_DOWNLOAD_END\t\t0x11\n#define ZIIRAVE_CMD_DOWNLOAD_SET_READ_ADDR\t0x12\n#define ZIIRAVE_CMD_DOWNLOAD_READ_BYTE\t\t0x13\n#define ZIIRAVE_CMD_RESET_PROCESSOR\t\t0x0b\n#define ZIIRAVE_CMD_JUMP_TO_BOOTLOADER\t\t0x0c\n#define ZIIRAVE_CMD_DOWNLOAD_PACKET\t\t0x0e\n\n#define ZIIRAVE_CMD_JUMP_TO_BOOTLOADER_MAGIC\t1\n#define ZIIRAVE_CMD_RESET_PROCESSOR_MAGIC\t1\n\nstruct ziirave_wdt_rev {\n\tunsigned char major;\n\tunsigned char minor;\n};\n\nstruct ziirave_wdt_data {\n\tstruct mutex sysfs_mutex;\n\tstruct watchdog_device wdd;\n\tstruct ziirave_wdt_rev bootloader_rev;\n\tstruct ziirave_wdt_rev firmware_rev;\n\tint reset_reason;\n};\n\nstatic int wdt_timeout;\nmodule_param(wdt_timeout, int, 0);\nMODULE_PARM_DESC(wdt_timeout, \"Watchdog timeout in seconds\");\n\nstatic int reset_duration;\nmodule_param(reset_duration, int, 0);\nMODULE_PARM_DESC(reset_duration,\n\t\t \"Watchdog reset pulse duration in milliseconds\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int ziirave_wdt_revision(struct i2c_client *client,\n\t\t\t\tstruct ziirave_wdt_rev *rev, u8 command)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, command);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trev->major = ret;\n\n\tret = i2c_smbus_read_byte_data(client, command + 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trev->minor = ret;\n\n\treturn 0;\n}\n\nstatic int ziirave_wdt_set_state(struct watchdog_device *wdd, int state)\n{\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\n\treturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_STATE, state);\n}\n\nstatic int ziirave_wdt_start(struct watchdog_device *wdd)\n{\n\treturn ziirave_wdt_set_state(wdd, ZIIRAVE_STATE_ON);\n}\n\nstatic int ziirave_wdt_stop(struct watchdog_device *wdd)\n{\n\treturn ziirave_wdt_set_state(wdd, ZIIRAVE_STATE_OFF);\n}\n\nstatic int ziirave_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\n\treturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_PING,\n\t\t\t\t\t ZIIRAVE_PING_VALUE);\n}\n\nstatic int ziirave_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t   unsigned int timeout)\n{\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_TIMEOUT, timeout);\n\tif (!ret)\n\t\twdd->timeout = timeout;\n\n\treturn ret;\n}\n\nstatic unsigned int ziirave_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_TIME_LEFT);\n\tif (ret < 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int ziirave_firm_read_ack(struct watchdog_device *wdd)\n{\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\tint ret;\n\n\tret = i2c_smbus_read_byte(client);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to read status byte\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret == ZIIRAVE_FIRM_DOWNLOAD_ACK ? 0 : -EIO;\n}\n\nstatic int ziirave_firm_set_read_addr(struct watchdog_device *wdd, u32 addr)\n{\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\tconst u16 addr16 = (u16)addr / 2;\n\tu8 address[2];\n\n\tput_unaligned_le16(addr16, address);\n\n\treturn i2c_smbus_write_block_data(client,\n\t\t\t\t\t  ZIIRAVE_CMD_DOWNLOAD_SET_READ_ADDR,\n\t\t\t\t\t  sizeof(address), address);\n}\n\nstatic bool ziirave_firm_addr_readonly(u32 addr)\n{\n\treturn addr < ZIIRAVE_FIRM_FLASH_MEMORY_START ||\n\t       addr > ZIIRAVE_FIRM_FLASH_MEMORY_END;\n}\n\n \nstatic int __ziirave_firm_write_pkt(struct watchdog_device *wdd,\n\t\t\t\t    u32 addr, const u8 *data, u8 len)\n{\n\tconst u16 addr16 = (u16)addr / 2;\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\tu8 i, checksum = 0, packet[ZIIRAVE_FIRM_PKT_TOTAL_SIZE];\n\tint ret;\n\n\t \n\tif (len > ZIIRAVE_FIRM_PKT_DATA_SIZE) {\n\t\tdev_err(&client->dev, \"Firmware packet too long (%d)\\n\",\n\t\t\tlen);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tif (len && ziirave_firm_addr_readonly(addr))\n\t\treturn 0;\n\n\t \n\tpacket[0] = len;\n\t \n\tput_unaligned_le16(addr16, packet + 1);\n\n\tmemcpy(packet + 3, data, len);\n\tmemset(packet + 3 + len, 0, ZIIRAVE_FIRM_PKT_DATA_SIZE - len);\n\n\t \n\tfor (i = 0; i < len + 3; i++)\n\t\tchecksum += packet[i];\n\tpacket[ZIIRAVE_FIRM_PKT_TOTAL_SIZE - 1] = checksum;\n\n\tret = i2c_smbus_write_block_data(client, ZIIRAVE_CMD_DOWNLOAD_PACKET,\n\t\t\t\t\t sizeof(packet), packet);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to send DOWNLOAD_PACKET: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ziirave_firm_read_ack(wdd);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t      \"Failed to write firmware packet at address 0x%04x: %d\\n\",\n\t\t      addr, ret);\n\n\treturn ret;\n}\n\nstatic int ziirave_firm_write_pkt(struct watchdog_device *wdd,\n\t\t\t\t  u32 addr, const u8 *data, u8 len)\n{\n\tconst u8 max_write_len = ZIIRAVE_FIRM_PAGE_SIZE -\n\t\t(addr - ALIGN_DOWN(addr, ZIIRAVE_FIRM_PAGE_SIZE));\n\tint ret;\n\n\tif (len > max_write_len) {\n\t\t \n\t\tret = __ziirave_firm_write_pkt(wdd, addr, data, max_write_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taddr += max_write_len;\n\t\tdata += max_write_len;\n\t\tlen  -= max_write_len;\n\t}\n\n\treturn __ziirave_firm_write_pkt(wdd, addr, data, len);\n}\n\nstatic int ziirave_firm_verify(struct watchdog_device *wdd,\n\t\t\t       const struct firmware *fw)\n{\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\tconst struct ihex_binrec *rec;\n\tint i, ret;\n\tu8 data[ZIIRAVE_FIRM_PKT_DATA_SIZE];\n\n\tfor (rec = (void *)fw->data; rec; rec = ihex_next_binrec(rec)) {\n\t\tconst u16 len = be16_to_cpu(rec->len);\n\t\tconst u32 addr = be32_to_cpu(rec->addr);\n\n\t\tif (ziirave_firm_addr_readonly(addr))\n\t\t\tcontinue;\n\n\t\tret = ziirave_firm_set_read_addr(wdd, addr);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to send SET_READ_ADDR command: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tZIIRAVE_CMD_DOWNLOAD_READ_BYTE);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Failed to READ DATA: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata[i] = ret;\n\t\t}\n\n\t\tif (memcmp(data, rec->data, len)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Firmware mismatch at address 0x%04x\\n\", addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ziirave_firm_upload(struct watchdog_device *wdd,\n\t\t\t       const struct firmware *fw)\n{\n\tstruct i2c_client *client = to_i2c_client(wdd->parent);\n\tconst struct ihex_binrec *rec;\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tZIIRAVE_CMD_JUMP_TO_BOOTLOADER,\n\t\t\t\t\tZIIRAVE_CMD_JUMP_TO_BOOTLOADER_MAGIC);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to jump to bootloader\\n\");\n\t\treturn ret;\n\t}\n\n\tmsleep(500);\n\n\tret = i2c_smbus_write_byte(client, ZIIRAVE_CMD_DOWNLOAD_START);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to start download\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ziirave_firm_read_ack(wdd);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"No ACK for start download\\n\");\n\t\treturn ret;\n\t}\n\n\tmsleep(500);\n\n\tfor (rec = (void *)fw->data; rec; rec = ihex_next_binrec(rec)) {\n\t\tret = ziirave_firm_write_pkt(wdd, be32_to_cpu(rec->addr),\n\t\t\t\t\t     rec->data, be16_to_cpu(rec->len));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = ziirave_firm_write_pkt(wdd, 0, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to send EMPTY packet: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(20);\n\n\t \n\tret = ziirave_firm_verify(wdd, fw);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to verify firmware: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = i2c_smbus_write_byte(client, ZIIRAVE_CMD_DOWNLOAD_END);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to end firmware download: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = i2c_smbus_write_byte_data(client,\n\t\t\t\t\tZIIRAVE_CMD_RESET_PROCESSOR,\n\t\t\t\t\tZIIRAVE_CMD_RESET_PROCESSOR_MAGIC);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to reset the watchdog: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmsleep(500);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info ziirave_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"RAVE Switch Watchdog\",\n};\n\nstatic const struct watchdog_ops ziirave_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= ziirave_wdt_start,\n\t.stop\t\t= ziirave_wdt_stop,\n\t.ping\t\t= ziirave_wdt_ping,\n\t.set_timeout\t= ziirave_wdt_set_timeout,\n\t.get_timeleft\t= ziirave_wdt_get_timeleft,\n};\n\nstatic ssize_t ziirave_wdt_sysfs_show_firm(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = mutex_lock_interruptible(&w_priv->sysfs_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_emit(buf, \"02.%02u.%02u\\n\",\n\t\t\t w_priv->firmware_rev.major,\n\t\t\t w_priv->firmware_rev.minor);\n\n\tmutex_unlock(&w_priv->sysfs_mutex);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(firmware_version, S_IRUGO, ziirave_wdt_sysfs_show_firm,\n\t\t   NULL);\n\nstatic ssize_t ziirave_wdt_sysfs_show_boot(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = mutex_lock_interruptible(&w_priv->sysfs_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_emit(buf, \"01.%02u.%02u\\n\",\n\t\t\t w_priv->bootloader_rev.major,\n\t\t\t w_priv->bootloader_rev.minor);\n\n\tmutex_unlock(&w_priv->sysfs_mutex);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(bootloader_version, S_IRUGO, ziirave_wdt_sysfs_show_boot,\n\t\t   NULL);\n\nstatic ssize_t ziirave_wdt_sysfs_show_reason(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\n\tint ret;\n\n\tret = mutex_lock_interruptible(&w_priv->sysfs_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_emit(buf, \"%s\\n\", ziirave_reasons[w_priv->reset_reason]);\n\n\tmutex_unlock(&w_priv->sysfs_mutex);\n\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(reset_reason, S_IRUGO, ziirave_wdt_sysfs_show_reason,\n\t\t   NULL);\n\nstatic ssize_t ziirave_wdt_sysfs_store_firm(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev->parent);\n\tstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\n\tconst struct firmware *fw;\n\tint err;\n\n\terr = request_ihex_firmware(&fw, ZIIRAVE_FW_NAME, dev);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Failed to request ihex firmware\\n\");\n\t\treturn err;\n\t}\n\n\terr = mutex_lock_interruptible(&w_priv->sysfs_mutex);\n\tif (err)\n\t\tgoto release_firmware;\n\n\terr = ziirave_firm_upload(&w_priv->wdd, fw);\n\tif (err) {\n\t\tdev_err(&client->dev, \"The firmware update failed: %d\\n\", err);\n\t\tgoto unlock_mutex;\n\t}\n\n\t \n\terr = ziirave_wdt_revision(client, &w_priv->firmware_rev,\n\t\t\t\t   ZIIRAVE_WDT_FIRM_VER_MAJOR);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Failed to read firmware version: %d\\n\",\n\t\t\terr);\n\t\tgoto unlock_mutex;\n\t}\n\n\tdev_info(&client->dev,\n\t\t \"Firmware updated to version 02.%02u.%02u\\n\",\n\t\t w_priv->firmware_rev.major, w_priv->firmware_rev.minor);\n\n\t \n\terr = ziirave_wdt_set_timeout(&w_priv->wdd, w_priv->wdd.timeout);\n\tif (err)\n\t\tdev_err(&client->dev, \"Failed to set timeout: %d\\n\", err);\n\nunlock_mutex:\n\tmutex_unlock(&w_priv->sysfs_mutex);\n\nrelease_firmware:\n\trelease_firmware(fw);\n\n\treturn err ? err : count;\n}\n\nstatic DEVICE_ATTR(update_firmware, S_IWUSR, NULL,\n\t\t   ziirave_wdt_sysfs_store_firm);\n\nstatic struct attribute *ziirave_wdt_attrs[] = {\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_bootloader_version.attr,\n\t&dev_attr_reset_reason.attr,\n\t&dev_attr_update_firmware.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(ziirave_wdt);\n\nstatic int ziirave_wdt_init_duration(struct i2c_client *client)\n{\n\tint ret;\n\n\tif (!reset_duration) {\n\t\t \n\t\tif (!client->dev.of_node)\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tret = of_property_read_u32(client->dev.of_node,\n\t\t\t\t\t\t   \"reset-duration-ms\",\n\t\t\t\t\t\t   &reset_duration);\n\t\tif (ret) {\n\t\t\tdev_info(&client->dev,\n\t\t\t \"No reset pulse duration specified, using default\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (reset_duration < 1 || reset_duration > 255)\n\t\treturn -EINVAL;\n\n\tdev_info(&client->dev, \"Setting reset duration to %dms\",\n\t\t reset_duration);\n\n\treturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_RESET_DURATION,\n\t\t\t\t\t reset_duration);\n}\n\nstatic int ziirave_wdt_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct ziirave_wdt_data *w_priv;\n\tint val;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE |\n\t\t\t\t     I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_BLOCK_DATA))\n\t\treturn -ENODEV;\n\n\tw_priv = devm_kzalloc(&client->dev, sizeof(*w_priv), GFP_KERNEL);\n\tif (!w_priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&w_priv->sysfs_mutex);\n\n\tw_priv->wdd.info = &ziirave_wdt_info;\n\tw_priv->wdd.ops = &ziirave_wdt_ops;\n\tw_priv->wdd.min_timeout = ZIIRAVE_TIMEOUT_MIN;\n\tw_priv->wdd.max_timeout = ZIIRAVE_TIMEOUT_MAX;\n\tw_priv->wdd.parent = &client->dev;\n\tw_priv->wdd.groups = ziirave_wdt_groups;\n\n\twatchdog_init_timeout(&w_priv->wdd, wdt_timeout, &client->dev);\n\n\t \n\tif (w_priv->wdd.timeout == 0) {\n\t\tval = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_TIMEOUT);\n\t\tif (val < 0) {\n\t\t\tdev_err(&client->dev, \"Failed to read timeout\\n\");\n\t\t\treturn val;\n\t\t}\n\n\t\tif (val > ZIIRAVE_TIMEOUT_MAX ||\n\t\t    val < ZIIRAVE_TIMEOUT_MIN)\n\t\t\tval = ZIIRAVE_TIMEOUT_DEFAULT;\n\n\t\tw_priv->wdd.timeout = val;\n\t}\n\n\tret = ziirave_wdt_set_timeout(&w_priv->wdd, w_priv->wdd.timeout);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to set timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&client->dev, \"Timeout set to %ds\\n\", w_priv->wdd.timeout);\n\n\twatchdog_set_nowayout(&w_priv->wdd, nowayout);\n\n\ti2c_set_clientdata(client, w_priv);\n\n\t \n\tval = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_STATE);\n\tif (val < 0) {\n\t\tdev_err(&client->dev, \"Failed to read state\\n\");\n\t\treturn val;\n\t}\n\n\tif (val == ZIIRAVE_STATE_INITIAL)\n\t\tziirave_wdt_stop(&w_priv->wdd);\n\n\tret = ziirave_wdt_init_duration(client);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to init duration\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ziirave_wdt_revision(client, &w_priv->firmware_rev,\n\t\t\t\t   ZIIRAVE_WDT_FIRM_VER_MAJOR);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to read firmware version\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&client->dev,\n\t\t \"Firmware version: 02.%02u.%02u\\n\",\n\t\t w_priv->firmware_rev.major, w_priv->firmware_rev.minor);\n\n\tret = ziirave_wdt_revision(client, &w_priv->bootloader_rev,\n\t\t\t\t   ZIIRAVE_WDT_BOOT_VER_MAJOR);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to read bootloader version\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&client->dev,\n\t\t \"Bootloader version: 01.%02u.%02u\\n\",\n\t\t w_priv->bootloader_rev.major, w_priv->bootloader_rev.minor);\n\n\tw_priv->reset_reason = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\tZIIRAVE_WDT_RESET_REASON);\n\tif (w_priv->reset_reason < 0) {\n\t\tdev_err(&client->dev, \"Failed to read reset reason\\n\");\n\t\treturn w_priv->reset_reason;\n\t}\n\n\tif (w_priv->reset_reason >= ARRAY_SIZE(ziirave_reasons) ||\n\t    !ziirave_reasons[w_priv->reset_reason]) {\n\t\tdev_err(&client->dev, \"Invalid reset reason\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = watchdog_register_device(&w_priv->wdd);\n\n\treturn ret;\n}\n\nstatic void ziirave_wdt_remove(struct i2c_client *client)\n{\n\tstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\n\n\twatchdog_unregister_device(&w_priv->wdd);\n}\n\nstatic const struct i2c_device_id ziirave_wdt_id[] = {\n\t{ \"rave-wdt\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ziirave_wdt_id);\n\nstatic const struct of_device_id zrv_wdt_of_match[] = {\n\t{ .compatible = \"zii,rave-wdt\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, zrv_wdt_of_match);\n\nstatic struct i2c_driver ziirave_wdt_driver = {\n\t.driver = {\n\t\t.name = \"ziirave_wdt\",\n\t\t.of_match_table = zrv_wdt_of_match,\n\t},\n\t.probe = ziirave_wdt_probe,\n\t.remove = ziirave_wdt_remove,\n\t.id_table = ziirave_wdt_id,\n};\n\nmodule_i2c_driver(ziirave_wdt_driver);\n\nMODULE_AUTHOR(\"Martyn Welch <martyn.welch@collabora.co.uk\");\nMODULE_DESCRIPTION(\"Zodiac Aerospace RAVE Switch Watchdog Processor Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}