{
  "module_name": "wdt.c",
  "hash_id": "793743c72d34fb9c28b1bf7b7380b877b7f4cec192880905dbe46c15e66b2219",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include \"wd501p.h\"\n\nstatic unsigned long wdt_is_open;\nstatic char expect_close;\n\n \n\n#define WD_TIMO 60\t\t\t \n\nstatic int heartbeat = WD_TIMO;\nstatic int wd_heartbeat;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\"Watchdog heartbeat in seconds. (0 < heartbeat < 65536, default=\"\n\t\t\t\t__MODULE_STRING(WD_TIMO) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \nstatic int io = 0x240;\nstatic int irq = 11;\n\nstatic DEFINE_SPINLOCK(wdt_lock);\n\nmodule_param_hw(io, int, ioport, 0);\nMODULE_PARM_DESC(io, \"WDT io port (default=0x240)\");\nmodule_param_hw(irq, int, irq, 0);\nMODULE_PARM_DESC(irq, \"WDT irq (default=11)\");\n\n \nstatic int tachometer;\nmodule_param(tachometer, int, 0);\nMODULE_PARM_DESC(tachometer,\n\t\t\"WDT501-P Fan Tachometer support (0=disable, default=0)\");\n\nstatic int type = 500;\nmodule_param(type, int, 0);\nMODULE_PARM_DESC(type,\n\t\t\"WDT501-P Card type (500 or 501, default=500)\");\n\n \n\nstatic void wdt_ctr_mode(int ctr, int mode)\n{\n\tctr <<= 6;\n\tctr |= 0x30;\n\tctr |= (mode << 1);\n\toutb_p(ctr, WDT_CR);\n}\n\nstatic void wdt_ctr_load(int ctr, int val)\n{\n\toutb_p(val&0xFF, WDT_COUNT0+ctr);\n\toutb_p(val>>8, WDT_COUNT0+ctr);\n}\n\n \n\nstatic int wdt_start(void)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&wdt_lock, flags);\n\tinb_p(WDT_DC);\t\t\t \n\twdt_ctr_mode(0, 3);\t\t \n\twdt_ctr_mode(1, 2);\t\t \n\twdt_ctr_mode(2, 0);\t\t \n\twdt_ctr_load(0, 8948);\t\t \n\twdt_ctr_load(1, wd_heartbeat);\t \n\twdt_ctr_load(2, 65535);\t\t \n\toutb_p(0, WDT_DC);\t\t \n\tspin_unlock_irqrestore(&wdt_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int wdt_stop(void)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&wdt_lock, flags);\n\t \n\tinb_p(WDT_DC);\t\t\t \n\twdt_ctr_load(2, 0);\t\t \n\tspin_unlock_irqrestore(&wdt_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic void wdt_ping(void)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&wdt_lock, flags);\n\t \n\tinb_p(WDT_DC);\t\t\t \n\twdt_ctr_mode(1, 2);\t\t \n\twdt_ctr_load(1, wd_heartbeat);\t \n\toutb_p(0, WDT_DC);\t\t \n\tspin_unlock_irqrestore(&wdt_lock, flags);\n}\n\n \n\nstatic int wdt_set_heartbeat(int t)\n{\n\tif (t < 1 || t > 65535)\n\t\treturn -EINVAL;\n\n\theartbeat = t;\n\twd_heartbeat = t * 100;\n\treturn 0;\n}\n\n \n\nstatic int wdt_get_status(void)\n{\n\tunsigned char new_status;\n\tint status = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt_lock, flags);\n\tnew_status = inb_p(WDT_SR);\n\tspin_unlock_irqrestore(&wdt_lock, flags);\n\n\tif (new_status & WDC_SR_ISOI0)\n\t\tstatus |= WDIOF_EXTERN1;\n\tif (new_status & WDC_SR_ISII1)\n\t\tstatus |= WDIOF_EXTERN2;\n\tif (type == 501) {\n\t\tif (!(new_status & WDC_SR_TGOOD))\n\t\t\tstatus |= WDIOF_OVERHEAT;\n\t\tif (!(new_status & WDC_SR_PSUOVER))\n\t\t\tstatus |= WDIOF_POWEROVER;\n\t\tif (!(new_status & WDC_SR_PSUUNDR))\n\t\t\tstatus |= WDIOF_POWERUNDER;\n\t\tif (tachometer) {\n\t\t\tif (!(new_status & WDC_SR_FANGOOD))\n\t\t\t\tstatus |= WDIOF_FANFAULT;\n\t\t}\n\t}\n\treturn status;\n}\n\n \n\nstatic int wdt_get_temperature(void)\n{\n\tunsigned short c;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt_lock, flags);\n\tc = inb_p(WDT_RT);\n\tspin_unlock_irqrestore(&wdt_lock, flags);\n\treturn (c * 11 / 15) + 7;\n}\n\nstatic void wdt_decode_501(int status)\n{\n\tif (!(status & WDC_SR_TGOOD))\n\t\tpr_crit(\"Overheat alarm (%d)\\n\", inb_p(WDT_RT));\n\tif (!(status & WDC_SR_PSUOVER))\n\t\tpr_crit(\"PSU over voltage\\n\");\n\tif (!(status & WDC_SR_PSUUNDR))\n\t\tpr_crit(\"PSU under voltage\\n\");\n}\n\n \n\nstatic irqreturn_t wdt_interrupt(int irq, void *dev_id)\n{\n\t \n\tunsigned char status;\n\n\tspin_lock(&wdt_lock);\n\tstatus = inb_p(WDT_SR);\n\n\tpr_crit(\"WDT status %d\\n\", status);\n\n\tif (type == 501) {\n\t\twdt_decode_501(status);\n\t\tif (tachometer) {\n\t\t\tif (!(status & WDC_SR_FANGOOD))\n\t\t\t\tpr_crit(\"Possible fan fault\\n\");\n\t\t}\n\t}\n\tif (!(status & WDC_SR_WCCR)) {\n#ifdef SOFTWARE_REBOOT\n#ifdef ONLY_TESTING\n\t\tpr_crit(\"Would Reboot\\n\");\n#else\n\t\tpr_crit(\"Initiating system reboot\\n\");\n\t\temergency_restart();\n#endif\n#else\n\t\tpr_crit(\"Reset in 5ms\\n\");\n#endif\n\t}\n\tspin_unlock(&wdt_lock);\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic ssize_t wdt_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\tfor (i = 0; i != count; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\t\twdt_ping();\n\t}\n\treturn count;\n}\n\n \n\nstatic long wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint new_heartbeat;\n\tint status;\n\n\tstruct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_SETTIMEOUT|\n\t\t\t\t\tWDIOF_MAGICCLOSE|\n\t\t\t\t\tWDIOF_KEEPALIVEPING,\n\t\t.firmware_version =\t1,\n\t\t.identity =\t\t\"WDT500/501\",\n\t};\n\n\t \n\tident.options |= (WDIOF_EXTERN1|WDIOF_EXTERN2);\n\tif (type == 501) {\n\t\tident.options |= (WDIOF_OVERHEAT|WDIOF_POWERUNDER|\n\t\t\t\t\t\t\tWDIOF_POWEROVER);\n\t\tif (tachometer)\n\t\t\tident.options |= WDIOF_FANFAULT;\n\t}\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\tcase WDIOC_GETSTATUS:\n\t\tstatus = wdt_get_status();\n\t\treturn put_user(status, p);\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_KEEPALIVE:\n\t\twdt_ping();\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_heartbeat, p))\n\t\t\treturn -EFAULT;\n\t\tif (wdt_set_heartbeat(new_heartbeat))\n\t\t\treturn -EINVAL;\n\t\twdt_ping();\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(heartbeat, p);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \n\nstatic int wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &wdt_is_open))\n\t\treturn -EBUSY;\n\t \n\twdt_start();\n\treturn stream_open(inode, file);\n}\n\n \n\nstatic int wdt_release(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42) {\n\t\twdt_stop();\n\t\tclear_bit(0, &wdt_is_open);\n\t} else {\n\t\tpr_crit(\"WDT device closed unexpectedly.  WDT will not stop!\\n\");\n\t\twdt_ping();\n\t}\n\texpect_close = 0;\n\treturn 0;\n}\n\n \n\nstatic ssize_t wdt_temp_read(struct file *file, char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ptr)\n{\n\tint temperature = wdt_get_temperature();\n\n\tif (copy_to_user(buf, &temperature, 1))\n\t\treturn -EFAULT;\n\n\treturn 1;\n}\n\n \n\nstatic int wdt_temp_open(struct inode *inode, struct file *file)\n{\n\treturn stream_open(inode, file);\n}\n\n \n\nstatic int wdt_temp_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\n \n\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\n\tvoid *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\twdt_stop();\n\treturn NOTIFY_DONE;\n}\n\n \n\n\nstatic const struct file_operations wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= wdt_write,\n\t.unlocked_ioctl\t= wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= wdt_open,\n\t.release\t= wdt_release,\n};\n\nstatic struct miscdevice wdt_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &wdt_fops,\n};\n\nstatic const struct file_operations wdt_temp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= wdt_temp_read,\n\t.open\t\t= wdt_temp_open,\n\t.release\t= wdt_temp_release,\n};\n\nstatic struct miscdevice temp_miscdev = {\n\t.minor\t= TEMP_MINOR,\n\t.name\t= \"temperature\",\n\t.fops\t= &wdt_temp_fops,\n};\n\n \n\nstatic struct notifier_block wdt_notifier = {\n\t.notifier_call = wdt_notify_sys,\n};\n\n \n\nstatic void __exit wdt_exit(void)\n{\n\tmisc_deregister(&wdt_miscdev);\n\tif (type == 501)\n\t\tmisc_deregister(&temp_miscdev);\n\tunregister_reboot_notifier(&wdt_notifier);\n\tfree_irq(irq, NULL);\n\trelease_region(io, 8);\n}\n\n \n\nstatic int __init wdt_init(void)\n{\n\tint ret;\n\n\tif (type != 500 && type != 501) {\n\t\tpr_err(\"unknown card type '%d'\\n\", type);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (wdt_set_heartbeat(heartbeat)) {\n\t\twdt_set_heartbeat(WD_TIMO);\n\t\tpr_info(\"heartbeat value must be 0 < heartbeat < 65536, using %d\\n\",\n\t\t\tWD_TIMO);\n\t}\n\n\tif (!request_region(io, 8, \"wdt501p\")) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\", io);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = request_irq(irq, wdt_interrupt, 0, \"wdt501p\", NULL);\n\tif (ret) {\n\t\tpr_err(\"IRQ %d is not free\\n\", irq);\n\t\tgoto outreg;\n\t}\n\n\tret = register_reboot_notifier(&wdt_notifier);\n\tif (ret) {\n\t\tpr_err(\"cannot register reboot notifier (err=%d)\\n\", ret);\n\t\tgoto outirq;\n\t}\n\n\tif (type == 501) {\n\t\tret = misc_register(&temp_miscdev);\n\t\tif (ret) {\n\t\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t\t       TEMP_MINOR, ret);\n\t\t\tgoto outrbt;\n\t\t}\n\t}\n\n\tret = misc_register(&wdt_miscdev);\n\tif (ret) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, ret);\n\t\tgoto outmisc;\n\t}\n\n\tpr_info(\"WDT500/501-P driver 0.10 at 0x%04x (Interrupt %d). heartbeat=%d sec (nowayout=%d)\\n\",\n\t\tio, irq, heartbeat, nowayout);\n\tif (type == 501)\n\t\tpr_info(\"Fan Tachometer is %s\\n\",\n\t\t\ttachometer ? \"Enabled\" : \"Disabled\");\n\treturn 0;\n\noutmisc:\n\tif (type == 501)\n\t\tmisc_deregister(&temp_miscdev);\noutrbt:\n\tunregister_reboot_notifier(&wdt_notifier);\noutirq:\n\tfree_irq(irq, NULL);\noutreg:\n\trelease_region(io, 8);\nout:\n\treturn ret;\n}\n\nmodule_init(wdt_init);\nmodule_exit(wdt_exit);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"Driver for ISA ICS watchdog cards (WDT500/501)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}