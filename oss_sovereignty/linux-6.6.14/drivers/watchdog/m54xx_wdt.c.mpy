{
  "module_name": "m54xx_wdt.c",
  "hash_id": "c65f591f718665947a7900eb462c0a515d88753162d012be1a6c69abc73d8a05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/m54xx_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/ioport.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#include <asm/coldfire.h>\n#include <asm/m54xxsim.h>\n#include <asm/m54xxgpt.h>\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic unsigned int heartbeat = 30;\t \nstatic unsigned long wdt_status;\n\n#define\tWDT_IN_USE\t\t0\n#define\tWDT_OK_TO_CLOSE\t\t1\n\nstatic void wdt_enable(void)\n{\n\tunsigned int gms0;\n\n\t \n\tgms0 = __raw_readl(MCF_GPT_GMS0);\n\tif (gms0 & MCF_GPT_GMS_TMS_GPIO)\n\t\tgms0 &= (MCF_GPT_GMS_TMS_GPIO | MCF_GPT_GMS_GPIO_MASK\n\t\t\t\t\t\t\t| MCF_GPT_GMS_OD);\n\telse\n\t\tgms0 = MCF_GPT_GMS_TMS_GPIO | MCF_GPT_GMS_OD;\n\t__raw_writel(gms0, MCF_GPT_GMS0);\n\t__raw_writel(MCF_GPT_GCIR_PRE(heartbeat*(MCF_BUSCLK/0xffff)) |\n\t\t\tMCF_GPT_GCIR_CNT(0xffff), MCF_GPT_GCIR0);\n\tgms0 |= MCF_GPT_GMS_OCPW(0xA5) | MCF_GPT_GMS_WDEN | MCF_GPT_GMS_CE;\n\t__raw_writel(gms0, MCF_GPT_GMS0);\n}\n\nstatic void wdt_disable(void)\n{\n\tunsigned int gms0;\n\n\t \n\tgms0 = __raw_readl(MCF_GPT_GMS0);\n\tgms0 &= ~(MCF_GPT_GMS_WDEN | MCF_GPT_GMS_CE);\n\t__raw_writel(gms0, MCF_GPT_GMS0);\n}\n\nstatic void wdt_keepalive(void)\n{\n\tunsigned int gms0;\n\n\tgms0 = __raw_readl(MCF_GPT_GMS0);\n\tgms0 |= MCF_GPT_GMS_OCPW(0xA5);\n\t__raw_writel(gms0, MCF_GPT_GMS0);\n}\n\nstatic int m54xx_wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(WDT_IN_USE, &wdt_status))\n\t\treturn -EBUSY;\n\n\tclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\n\twdt_enable();\n\treturn stream_open(inode, file);\n}\n\nstatic ssize_t m54xx_wdt_write(struct file *file, const char *data,\n\t\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\tclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\n\n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\tset_bit(WDT_OK_TO_CLOSE, &wdt_status);\n\t\t\t}\n\t\t}\n\t\twdt_keepalive();\n\t}\n\treturn len;\n}\n\nstatic const struct watchdog_info ident = {\n\t.options\t= WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT |\n\t\t\t\tWDIOF_KEEPALIVEPING,\n\t.identity\t= \"Coldfire M54xx Watchdog\",\n};\n\nstatic long m54xx_wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\t unsigned long arg)\n{\n\tint ret = -ENOTTY;\n\tint time;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tret = copy_to_user((struct watchdog_info *)arg, &ident,\n\t\t\t\t   sizeof(ident)) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\t\tret = put_user(0, (int *)arg);\n\t\tbreak;\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tret = put_user(0, (int *)arg);\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\twdt_keepalive();\n\t\tret = 0;\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tret = get_user(time, (int *)arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (time <= 0 || time > 30) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\theartbeat = time;\n\t\twdt_enable();\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\tret = put_user(heartbeat, (int *)arg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int m54xx_wdt_release(struct inode *inode, struct file *file)\n{\n\tif (test_bit(WDT_OK_TO_CLOSE, &wdt_status))\n\t\twdt_disable();\n\telse {\n\t\tpr_crit(\"Device closed unexpectedly - timer will not stop\\n\");\n\t\twdt_keepalive();\n\t}\n\tclear_bit(WDT_IN_USE, &wdt_status);\n\tclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\n\n\treturn 0;\n}\n\n\nstatic const struct file_operations m54xx_wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= m54xx_wdt_write,\n\t.unlocked_ioctl\t= m54xx_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= m54xx_wdt_open,\n\t.release\t= m54xx_wdt_release,\n};\n\nstatic struct miscdevice m54xx_wdt_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &m54xx_wdt_fops,\n};\n\nstatic int __init m54xx_wdt_init(void)\n{\n\tif (!request_mem_region(MCF_GPT_GCIR0, 4, \"Coldfire M54xx Watchdog\")) {\n\t\tpr_warn(\"I/O region busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\tpr_info(\"driver is loaded\\n\");\n\n\treturn misc_register(&m54xx_wdt_miscdev);\n}\n\nstatic void __exit m54xx_wdt_exit(void)\n{\n\tmisc_deregister(&m54xx_wdt_miscdev);\n\trelease_mem_region(MCF_GPT_GCIR0, 4);\n}\n\nmodule_init(m54xx_wdt_init);\nmodule_exit(m54xx_wdt_exit);\n\nMODULE_AUTHOR(\"Philippe De Muyter <phdm@macqel.be>\");\nMODULE_DESCRIPTION(\"Coldfire M54xx Watchdog\");\n\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeat in seconds (default 30s)\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started\");\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}