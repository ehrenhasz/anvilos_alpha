{
  "module_name": "ath79_wdt.c",
  "hash_id": "51d3e993f7e6d301dc25fee1ebbca222f5eb9df5a0b719c8de4318a428962477",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ath79_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/uaccess.h>\n\n#define DRIVER_NAME\t\"ath79-wdt\"\n\n#define WDT_TIMEOUT\t15\t \n\n#define WDOG_REG_CTRL\t\t0x00\n#define WDOG_REG_TIMER\t\t0x04\n\n#define WDOG_CTRL_LAST_RESET\tBIT(31)\n#define WDOG_CTRL_ACTION_MASK\t3\n#define WDOG_CTRL_ACTION_NONE\t0\t \n#define WDOG_CTRL_ACTION_GPI\t1\t \n#define WDOG_CTRL_ACTION_NMI\t2\t \n#define WDOG_CTRL_ACTION_FCR\t3\t \n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\t\t   \"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int timeout = WDT_TIMEOUT;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds \"\n\t\t\t  \"(default=\" __MODULE_STRING(WDT_TIMEOUT) \"s)\");\n\nstatic unsigned long wdt_flags;\n\n#define WDT_FLAGS_BUSY\t\t0\n#define WDT_FLAGS_EXPECT_CLOSE\t1\n\nstatic struct clk *wdt_clk;\nstatic unsigned long wdt_freq;\nstatic int boot_status;\nstatic int max_timeout;\nstatic void __iomem *wdt_base;\n\nstatic inline void ath79_wdt_wr(unsigned reg, u32 val)\n{\n\tiowrite32(val, wdt_base + reg);\n}\n\nstatic inline u32 ath79_wdt_rr(unsigned reg)\n{\n\treturn ioread32(wdt_base + reg);\n}\n\nstatic inline void ath79_wdt_keepalive(void)\n{\n\tath79_wdt_wr(WDOG_REG_TIMER, wdt_freq * timeout);\n\t \n\tath79_wdt_rr(WDOG_REG_TIMER);\n}\n\nstatic inline void ath79_wdt_enable(void)\n{\n\tath79_wdt_keepalive();\n\n\t \n\tudelay(2);\n\n\tath79_wdt_wr(WDOG_REG_CTRL, WDOG_CTRL_ACTION_FCR);\n\t \n\tath79_wdt_rr(WDOG_REG_CTRL);\n}\n\nstatic inline void ath79_wdt_disable(void)\n{\n\tath79_wdt_wr(WDOG_REG_CTRL, WDOG_CTRL_ACTION_NONE);\n\t \n\tath79_wdt_rr(WDOG_REG_CTRL);\n}\n\nstatic int ath79_wdt_set_timeout(int val)\n{\n\tif (val < 1 || val > max_timeout)\n\t\treturn -EINVAL;\n\n\ttimeout = val;\n\tath79_wdt_keepalive();\n\n\treturn 0;\n}\n\nstatic int ath79_wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(WDT_FLAGS_BUSY, &wdt_flags))\n\t\treturn -EBUSY;\n\n\tclear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);\n\tath79_wdt_enable();\n\n\treturn stream_open(inode, file);\n}\n\nstatic int ath79_wdt_release(struct inode *inode, struct file *file)\n{\n\tif (test_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags))\n\t\tath79_wdt_disable();\n\telse {\n\t\tpr_crit(\"device closed unexpectedly, watchdog timer will not stop!\\n\");\n\t\tath79_wdt_keepalive();\n\t}\n\n\tclear_bit(WDT_FLAGS_BUSY, &wdt_flags);\n\tclear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);\n\n\treturn 0;\n}\n\nstatic ssize_t ath79_wdt_write(struct file *file, const char *data,\n\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\tclear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);\n\n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tif (c == 'V')\n\t\t\t\t\tset_bit(WDT_FLAGS_EXPECT_CLOSE,\n\t\t\t\t\t\t&wdt_flags);\n\t\t\t}\n\t\t}\n\n\t\tath79_wdt_keepalive();\n\t}\n\n\treturn len;\n}\n\nstatic const struct watchdog_info ath79_wdt_info = {\n\t.options\t\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t\t  WDIOF_MAGICCLOSE | WDIOF_CARDRESET,\n\t.firmware_version\t= 0,\n\t.identity\t\t= \"ATH79 watchdog\",\n};\n\nstatic long ath79_wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint err;\n\tint t;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\terr = copy_to_user(argp, &ath79_wdt_info,\n\t\t\t\t   sizeof(ath79_wdt_info)) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\t\terr = put_user(0, p);\n\t\tbreak;\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\terr = put_user(boot_status, p);\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tath79_wdt_keepalive();\n\t\terr = 0;\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\terr = get_user(t, p);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = ath79_wdt_set_timeout(t);\n\t\tif (err)\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\terr = put_user(timeout, p);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic const struct file_operations ath79_wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= ath79_wdt_write,\n\t.unlocked_ioctl\t= ath79_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= ath79_wdt_open,\n\t.release\t= ath79_wdt_release,\n};\n\nstatic struct miscdevice ath79_wdt_miscdev = {\n\t.minor = WATCHDOG_MINOR,\n\t.name = \"watchdog\",\n\t.fops = &ath79_wdt_fops,\n};\n\nstatic int ath79_wdt_probe(struct platform_device *pdev)\n{\n\tu32 ctrl;\n\tint err;\n\n\tif (wdt_base)\n\t\treturn -EBUSY;\n\n\twdt_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt_base))\n\t\treturn PTR_ERR(wdt_base);\n\n\twdt_clk = devm_clk_get(&pdev->dev, \"wdt\");\n\tif (IS_ERR(wdt_clk))\n\t\treturn PTR_ERR(wdt_clk);\n\n\terr = clk_prepare_enable(wdt_clk);\n\tif (err)\n\t\treturn err;\n\n\twdt_freq = clk_get_rate(wdt_clk);\n\tif (!wdt_freq) {\n\t\terr = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\tmax_timeout = (0xfffffffful / wdt_freq);\n\tif (timeout < 1 || timeout > max_timeout) {\n\t\ttimeout = max_timeout;\n\t\tdev_info(&pdev->dev,\n\t\t\t\"timeout value must be 0 < timeout < %d, using %d\\n\",\n\t\t\tmax_timeout, timeout);\n\t}\n\n\tctrl = ath79_wdt_rr(WDOG_REG_CTRL);\n\tboot_status = (ctrl & WDOG_CTRL_LAST_RESET) ? WDIOF_CARDRESET : 0;\n\n\terr = misc_register(&ath79_wdt_miscdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unable to register misc device, err=%d\\n\", err);\n\t\tgoto err_clk_disable;\n\t}\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(wdt_clk);\n\treturn err;\n}\n\nstatic void ath79_wdt_remove(struct platform_device *pdev)\n{\n\tmisc_deregister(&ath79_wdt_miscdev);\n\tclk_disable_unprepare(wdt_clk);\n}\n\nstatic void ath79_wdt_shutdown(struct platform_device *pdev)\n{\n\tath79_wdt_disable();\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ath79_wdt_match[] = {\n\t{ .compatible = \"qca,ar7130-wdt\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ath79_wdt_match);\n#endif\n\nstatic struct platform_driver ath79_wdt_driver = {\n\t.probe\t\t= ath79_wdt_probe,\n\t.remove_new\t= ath79_wdt_remove,\n\t.shutdown\t= ath79_wdt_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(ath79_wdt_match),\n\t},\n};\n\nmodule_platform_driver(ath79_wdt_driver);\n\nMODULE_DESCRIPTION(\"Atheros AR71XX/AR724X/AR913X hardware watchdog driver\");\nMODULE_AUTHOR(\"Gabor Juhos <juhosg@openwrt.org\");\nMODULE_AUTHOR(\"Imre Kaloz <kaloz@openwrt.org\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}