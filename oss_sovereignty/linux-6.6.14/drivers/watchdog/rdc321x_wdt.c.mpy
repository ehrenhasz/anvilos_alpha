{
  "module_name": "rdc321x_wdt.c",
  "hash_id": "88c71cf233728afde2a0f59149adfd648702337705e381314ea95fe28340237d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rdc321x_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/timer.h>\n#include <linux/completion.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/mfd/rdc321x.h>\n\n#define RDC_WDT_MASK\t0x80000000  \n#define RDC_WDT_EN\t0x00800000  \n#define RDC_WDT_WTI\t0x00200000  \n#define RDC_WDT_RST\t0x00100000  \n#define RDC_WDT_WIF\t0x00040000  \n#define RDC_WDT_IRT\t0x00000100  \n#define RDC_WDT_CNT\t0x00000001  \n\n#define RDC_CLS_TMR\t0x80003844  \n\n#define RDC_WDT_INTERVAL\t(HZ/10+1)\n\nstatic int ticks = 1000;\n\n \n\nstatic struct {\n\tstruct completion stop;\n\tint running;\n\tstruct timer_list timer;\n\tint queue;\n\tint default_ticks;\n\tunsigned long inuse;\n\tspinlock_t lock;\n\tstruct pci_dev *sb_pdev;\n\tint base_reg;\n} rdc321x_wdt_device;\n\n \n\nstatic void rdc321x_wdt_trigger(struct timer_list *unused)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tif (rdc321x_wdt_device.running)\n\t\tticks--;\n\n\t \n\tspin_lock_irqsave(&rdc321x_wdt_device.lock, flags);\n\tpci_read_config_dword(rdc321x_wdt_device.sb_pdev,\n\t\t\t\t\trdc321x_wdt_device.base_reg, &val);\n\tval |= RDC_WDT_EN;\n\tpci_write_config_dword(rdc321x_wdt_device.sb_pdev,\n\t\t\t\t\trdc321x_wdt_device.base_reg, val);\n\tspin_unlock_irqrestore(&rdc321x_wdt_device.lock, flags);\n\n\t \n\tif (rdc321x_wdt_device.queue && ticks)\n\t\tmod_timer(&rdc321x_wdt_device.timer,\n\t\t\t\tjiffies + RDC_WDT_INTERVAL);\n\telse {\n\t\t \n\t\tcomplete(&rdc321x_wdt_device.stop);\n\t}\n\n}\n\nstatic void rdc321x_wdt_reset(void)\n{\n\tticks = rdc321x_wdt_device.default_ticks;\n}\n\nstatic void rdc321x_wdt_start(void)\n{\n\tunsigned long flags;\n\n\tif (!rdc321x_wdt_device.queue) {\n\t\trdc321x_wdt_device.queue = 1;\n\n\t\t \n\t\tspin_lock_irqsave(&rdc321x_wdt_device.lock, flags);\n\t\tpci_write_config_dword(rdc321x_wdt_device.sb_pdev,\n\t\t\t\trdc321x_wdt_device.base_reg, RDC_CLS_TMR);\n\n\t\t \n\t\tpci_write_config_dword(rdc321x_wdt_device.sb_pdev,\n\t\t\t\t\trdc321x_wdt_device.base_reg,\n\t\t\t\t\tRDC_WDT_EN | RDC_WDT_CNT);\n\t\tspin_unlock_irqrestore(&rdc321x_wdt_device.lock, flags);\n\n\t\tmod_timer(&rdc321x_wdt_device.timer,\n\t\t\t\tjiffies + RDC_WDT_INTERVAL);\n\t}\n\n\t \n\trdc321x_wdt_device.running++;\n}\n\nstatic int rdc321x_wdt_stop(void)\n{\n\tif (rdc321x_wdt_device.running)\n\t\trdc321x_wdt_device.running = 0;\n\n\tticks = rdc321x_wdt_device.default_ticks;\n\n\treturn -EIO;\n}\n\n \nstatic int rdc321x_wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &rdc321x_wdt_device.inuse))\n\t\treturn -EBUSY;\n\n\treturn stream_open(inode, file);\n}\n\nstatic int rdc321x_wdt_release(struct inode *inode, struct file *file)\n{\n\tclear_bit(0, &rdc321x_wdt_device.inuse);\n\treturn 0;\n}\n\nstatic long rdc321x_wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tu32 value;\n\tstatic const struct watchdog_info ident = {\n\t\t.options = WDIOF_CARDRESET,\n\t\t.identity = \"RDC321x WDT\",\n\t};\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\tcase WDIOC_KEEPALIVE:\n\t\trdc321x_wdt_reset();\n\t\tbreak;\n\tcase WDIOC_GETSTATUS:\n\t\t \n\t\tspin_lock_irqsave(&rdc321x_wdt_device.lock, flags);\n\t\tpci_read_config_dword(rdc321x_wdt_device.sb_pdev,\n\t\t\t\t\trdc321x_wdt_device.base_reg, &value);\n\t\tspin_unlock_irqrestore(&rdc321x_wdt_device.lock, flags);\n\t\tif (copy_to_user(argp, &value, sizeof(u32)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase WDIOC_SETOPTIONS:\n\t\tif (copy_from_user(&value, argp, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tswitch (value) {\n\t\tcase WDIOS_ENABLECARD:\n\t\t\trdc321x_wdt_start();\n\t\t\tbreak;\n\t\tcase WDIOS_DISABLECARD:\n\t\t\treturn rdc321x_wdt_stop();\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t rdc321x_wdt_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tif (!count)\n\t\treturn -EIO;\n\n\trdc321x_wdt_reset();\n\n\treturn count;\n}\n\nstatic const struct file_operations rdc321x_wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl\t= rdc321x_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= rdc321x_wdt_open,\n\t.write\t\t= rdc321x_wdt_write,\n\t.release\t= rdc321x_wdt_release,\n};\n\nstatic struct miscdevice rdc321x_wdt_misc = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &rdc321x_wdt_fops,\n};\n\nstatic int rdc321x_wdt_probe(struct platform_device *pdev)\n{\n\tint err;\n\tstruct resource *r;\n\tstruct rdc321x_wdt_pdata *pdata;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data supplied\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_IO, \"wdt-reg\");\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"failed to get wdt-reg resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trdc321x_wdt_device.sb_pdev = pdata->sb_pdev;\n\trdc321x_wdt_device.base_reg = r->start;\n\trdc321x_wdt_device.queue = 0;\n\trdc321x_wdt_device.default_ticks = ticks;\n\n\terr = misc_register(&rdc321x_wdt_misc);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"misc_register failed\\n\");\n\t\treturn err;\n\t}\n\n\tspin_lock_init(&rdc321x_wdt_device.lock);\n\n\t \n\tpci_write_config_dword(rdc321x_wdt_device.sb_pdev,\n\t\t\t\trdc321x_wdt_device.base_reg, RDC_WDT_RST);\n\n\tinit_completion(&rdc321x_wdt_device.stop);\n\n\tclear_bit(0, &rdc321x_wdt_device.inuse);\n\n\ttimer_setup(&rdc321x_wdt_device.timer, rdc321x_wdt_trigger, 0);\n\n\tdev_info(&pdev->dev, \"watchdog init success\\n\");\n\n\treturn 0;\n}\n\nstatic void rdc321x_wdt_remove(struct platform_device *pdev)\n{\n\tif (rdc321x_wdt_device.queue) {\n\t\trdc321x_wdt_device.queue = 0;\n\t\twait_for_completion(&rdc321x_wdt_device.stop);\n\t}\n\n\tmisc_deregister(&rdc321x_wdt_misc);\n}\n\nstatic struct platform_driver rdc321x_wdt_driver = {\n\t.probe = rdc321x_wdt_probe,\n\t.remove_new = rdc321x_wdt_remove,\n\t.driver = {\n\t\t.name = \"rdc321x-wdt\",\n\t},\n};\n\nmodule_platform_driver(rdc321x_wdt_driver);\n\nMODULE_AUTHOR(\"Florian Fainelli <florian@openwrt.org>\");\nMODULE_DESCRIPTION(\"RDC321x watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}