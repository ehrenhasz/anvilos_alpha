{
  "module_name": "ar7_wdt.c",
  "hash_id": "585aebbf8c9740f9e72c1164abea3c883505cf95b41ecb8009718663c5ac6a9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ar7_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/clk.h>\n\n#include <asm/addrspace.h>\n#include <asm/mach-ar7/ar7.h>\n\n#define LONGNAME \"TI AR7 Watchdog Timer\"\n\nMODULE_AUTHOR(\"Nicolas Thill <nico@openwrt.org>\");\nMODULE_DESCRIPTION(LONGNAME);\nMODULE_LICENSE(\"GPL\");\n\nstatic int margin = 60;\nmodule_param(margin, int, 0);\nMODULE_PARM_DESC(margin, \"Watchdog margin in seconds\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Disable watchdog shutdown on close\");\n\n#define READ_REG(x) readl((void __iomem *)&(x))\n#define WRITE_REG(x, v) writel((v), (void __iomem *)&(x))\n\nstruct ar7_wdt {\n\tu32 kick_lock;\n\tu32 kick;\n\tu32 change_lock;\n\tu32 change;\n\tu32 disable_lock;\n\tu32 disable;\n\tu32 prescale_lock;\n\tu32 prescale;\n};\n\nstatic unsigned long wdt_is_open;\nstatic unsigned expect_close;\nstatic DEFINE_SPINLOCK(wdt_lock);\n\n \n#define prescale_value 0xffff\n\n \nstatic struct ar7_wdt *ar7_wdt;\n\nstatic struct clk *vbus_clk;\n\nstatic void ar7_wdt_kick(u32 value)\n{\n\tWRITE_REG(ar7_wdt->kick_lock, 0x5555);\n\tif ((READ_REG(ar7_wdt->kick_lock) & 3) == 1) {\n\t\tWRITE_REG(ar7_wdt->kick_lock, 0xaaaa);\n\t\tif ((READ_REG(ar7_wdt->kick_lock) & 3) == 3) {\n\t\t\tWRITE_REG(ar7_wdt->kick, value);\n\t\t\treturn;\n\t\t}\n\t}\n\tpr_err(\"failed to unlock WDT kick reg\\n\");\n}\n\nstatic void ar7_wdt_prescale(u32 value)\n{\n\tWRITE_REG(ar7_wdt->prescale_lock, 0x5a5a);\n\tif ((READ_REG(ar7_wdt->prescale_lock) & 3) == 1) {\n\t\tWRITE_REG(ar7_wdt->prescale_lock, 0xa5a5);\n\t\tif ((READ_REG(ar7_wdt->prescale_lock) & 3) == 3) {\n\t\t\tWRITE_REG(ar7_wdt->prescale, value);\n\t\t\treturn;\n\t\t}\n\t}\n\tpr_err(\"failed to unlock WDT prescale reg\\n\");\n}\n\nstatic void ar7_wdt_change(u32 value)\n{\n\tWRITE_REG(ar7_wdt->change_lock, 0x6666);\n\tif ((READ_REG(ar7_wdt->change_lock) & 3) == 1) {\n\t\tWRITE_REG(ar7_wdt->change_lock, 0xbbbb);\n\t\tif ((READ_REG(ar7_wdt->change_lock) & 3) == 3) {\n\t\t\tWRITE_REG(ar7_wdt->change, value);\n\t\t\treturn;\n\t\t}\n\t}\n\tpr_err(\"failed to unlock WDT change reg\\n\");\n}\n\nstatic void ar7_wdt_disable(u32 value)\n{\n\tWRITE_REG(ar7_wdt->disable_lock, 0x7777);\n\tif ((READ_REG(ar7_wdt->disable_lock) & 3) == 1) {\n\t\tWRITE_REG(ar7_wdt->disable_lock, 0xcccc);\n\t\tif ((READ_REG(ar7_wdt->disable_lock) & 3) == 2) {\n\t\t\tWRITE_REG(ar7_wdt->disable_lock, 0xdddd);\n\t\t\tif ((READ_REG(ar7_wdt->disable_lock) & 3) == 3) {\n\t\t\t\tWRITE_REG(ar7_wdt->disable, value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tpr_err(\"failed to unlock WDT disable reg\\n\");\n}\n\nstatic void ar7_wdt_update_margin(int new_margin)\n{\n\tu32 change;\n\tu32 vbus_rate;\n\n\tvbus_rate = clk_get_rate(vbus_clk);\n\tchange = new_margin * (vbus_rate / prescale_value);\n\tif (change < 1)\n\t\tchange = 1;\n\tif (change > 0xffff)\n\t\tchange = 0xffff;\n\tar7_wdt_change(change);\n\tmargin = change * prescale_value / vbus_rate;\n\tpr_info(\"timer margin %d seconds (prescale %d, change %d, freq %d)\\n\",\n\t\tmargin, prescale_value, change, vbus_rate);\n}\n\nstatic void ar7_wdt_enable_wdt(void)\n{\n\tpr_debug(\"enabling watchdog timer\\n\");\n\tar7_wdt_disable(1);\n\tar7_wdt_kick(1);\n}\n\nstatic void ar7_wdt_disable_wdt(void)\n{\n\tpr_debug(\"disabling watchdog timer\\n\");\n\tar7_wdt_disable(0);\n}\n\nstatic int ar7_wdt_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &wdt_is_open))\n\t\treturn -EBUSY;\n\tar7_wdt_enable_wdt();\n\texpect_close = 0;\n\n\treturn stream_open(inode, file);\n}\n\nstatic int ar7_wdt_release(struct inode *inode, struct file *file)\n{\n\tif (!expect_close)\n\t\tpr_warn(\"watchdog device closed unexpectedly, will not disable the watchdog timer\\n\");\n\telse if (!nowayout)\n\t\tar7_wdt_disable_wdt();\n\tclear_bit(0, &wdt_is_open);\n\treturn 0;\n}\n\nstatic ssize_t ar7_wdt_write(struct file *file, const char *data,\n\t\t\t     size_t len, loff_t *ppos)\n{\n\t \n\tif (len) {\n\t\tsize_t i;\n\n\t\tspin_lock(&wdt_lock);\n\t\tar7_wdt_kick(1);\n\t\tspin_unlock(&wdt_lock);\n\n\t\texpect_close = 0;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tchar c;\n\t\t\tif (get_user(c, data + i))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (c == 'V')\n\t\t\t\texpect_close = 1;\n\t\t}\n\n\t}\n\treturn len;\n}\n\nstatic long ar7_wdt_ioctl(struct file *file,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstatic const struct watchdog_info ident = {\n\t\t.identity = LONGNAME,\n\t\t.firmware_version = 1,\n\t\t.options = (WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t\t\t\tWDIOF_MAGICCLOSE),\n\t};\n\tint new_margin;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user((struct watchdog_info *)arg, &ident,\n\t\t\t\tsizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tif (put_user(0, (int *)arg))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase WDIOC_KEEPALIVE:\n\t\tar7_wdt_kick(1);\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_margin, (int *)arg))\n\t\t\treturn -EFAULT;\n\t\tif (new_margin < 1)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock(&wdt_lock);\n\t\tar7_wdt_update_margin(new_margin);\n\t\tar7_wdt_kick(1);\n\t\tspin_unlock(&wdt_lock);\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\tif (put_user(margin, (int *)arg))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic const struct file_operations ar7_wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= ar7_wdt_write,\n\t.unlocked_ioctl\t= ar7_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= ar7_wdt_open,\n\t.release\t= ar7_wdt_release,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice ar7_wdt_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &ar7_wdt_fops,\n};\n\nstatic int ar7_wdt_probe(struct platform_device *pdev)\n{\n\tint rc;\n\n\tar7_wdt = devm_platform_ioremap_resource_byname(pdev, \"regs\");\n\tif (IS_ERR(ar7_wdt))\n\t\treturn PTR_ERR(ar7_wdt);\n\n\tvbus_clk = clk_get(NULL, \"vbus\");\n\tif (IS_ERR(vbus_clk)) {\n\t\tpr_err(\"could not get vbus clock\\n\");\n\t\treturn PTR_ERR(vbus_clk);\n\t}\n\n\tar7_wdt_disable_wdt();\n\tar7_wdt_prescale(prescale_value);\n\tar7_wdt_update_margin(margin);\n\n\trc = misc_register(&ar7_wdt_miscdev);\n\tif (rc) {\n\t\tpr_err(\"unable to register misc device\\n\");\n\t\tgoto out;\n\t}\n\treturn 0;\n\nout:\n\tclk_put(vbus_clk);\n\tvbus_clk = NULL;\n\treturn rc;\n}\n\nstatic void ar7_wdt_remove(struct platform_device *pdev)\n{\n\tmisc_deregister(&ar7_wdt_miscdev);\n\tclk_put(vbus_clk);\n\tvbus_clk = NULL;\n}\n\nstatic void ar7_wdt_shutdown(struct platform_device *pdev)\n{\n\tif (!nowayout)\n\t\tar7_wdt_disable_wdt();\n}\n\nstatic struct platform_driver ar7_wdt_driver = {\n\t.probe = ar7_wdt_probe,\n\t.remove_new = ar7_wdt_remove,\n\t.shutdown = ar7_wdt_shutdown,\n\t.driver = {\n\t\t.name = \"ar7_wdt\",\n\t},\n};\n\nmodule_platform_driver(ar7_wdt_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}