{
  "module_name": "simatic-ipc-wdt.c",
  "hash_id": "96ca66dca3308a98ed23dba98b6e51447413305f0d46580eb77367aa1f826fe0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/simatic-ipc-wdt.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_data/x86/p2sb.h>\n#include <linux/platform_data/x86/simatic-ipc-base.h>\n#include <linux/platform_device.h>\n#include <linux/sizes.h>\n#include <linux/util_macros.h>\n#include <linux/watchdog.h>\n\n#define WD_ENABLE_IOADR\t\t\t0x62\n#define WD_TRIGGER_IOADR\t\t0x66\n#define GPIO_COMMUNITY0_PORT_ID\t\t0xaf\n#define PAD_CFG_DW0_GPP_A_23\t\t0x4b8\n#define SAFE_EN_N_427E\t\t\t0x01\n#define SAFE_EN_N_227E\t\t\t0x04\n#define WD_ENABLED\t\t\t0x01\n#define WD_TRIGGERED\t\t\t0x80\n#define WD_MACROMODE\t\t\t0x02\n\n#define TIMEOUT_MIN\t2\n#define TIMEOUT_DEF\t64\n#define TIMEOUT_MAX\t64\n\n#define GP_STATUS_REG_227E\t0x404D\t \n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0000);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic struct resource gp_status_reg_227e_res =\n\tDEFINE_RES_IO_NAMED(GP_STATUS_REG_227E, SZ_1, KBUILD_MODNAME);\n\nstatic struct resource io_resource_enable =\n\tDEFINE_RES_IO_NAMED(WD_ENABLE_IOADR, SZ_1,\n\t\t\t    KBUILD_MODNAME \" WD_ENABLE_IOADR\");\n\nstatic struct resource io_resource_trigger =\n\tDEFINE_RES_IO_NAMED(WD_TRIGGER_IOADR, SZ_1,\n\t\t\t    KBUILD_MODNAME \" WD_TRIGGER_IOADR\");\n\n \nstatic struct resource mem_resource =\n\tDEFINE_RES_MEM_NAMED(0, 0, \"WD_RESET_BASE_ADR\");\n\nstatic u32 wd_timeout_table[] = {2, 4, 6, 8, 16, 32, 48, 64 };\nstatic void __iomem *wd_reset_base_addr;\n\nstatic int wd_start(struct watchdog_device *wdd)\n{\n\toutb(inb(WD_ENABLE_IOADR) | WD_ENABLED, WD_ENABLE_IOADR);\n\treturn 0;\n}\n\nstatic int wd_stop(struct watchdog_device *wdd)\n{\n\toutb(inb(WD_ENABLE_IOADR) & ~WD_ENABLED, WD_ENABLE_IOADR);\n\treturn 0;\n}\n\nstatic int wd_ping(struct watchdog_device *wdd)\n{\n\tinb(WD_TRIGGER_IOADR);\n\treturn 0;\n}\n\nstatic int wd_set_timeout(struct watchdog_device *wdd, unsigned int t)\n{\n\tint timeout_idx = find_closest(t, wd_timeout_table,\n\t\t\t\t       ARRAY_SIZE(wd_timeout_table));\n\n\toutb((inb(WD_ENABLE_IOADR) & 0xc7) | timeout_idx << 3, WD_ENABLE_IOADR);\n\twdd->timeout = wd_timeout_table[timeout_idx];\n\treturn 0;\n}\n\nstatic const struct watchdog_info wdt_ident = {\n\t.options\t= WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_SETTIMEOUT,\n\t.identity\t= KBUILD_MODNAME,\n};\n\nstatic const struct watchdog_ops wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= wd_start,\n\t.stop\t\t= wd_stop,\n\t.ping\t\t= wd_ping,\n\t.set_timeout\t= wd_set_timeout,\n};\n\nstatic void wd_secondary_enable(u32 wdtmode)\n{\n\tu16 resetbit;\n\n\t \n\tif (wdtmode == SIMATIC_IPC_DEVICE_227E) {\n\t\t \n\t\tresetbit = inb(GP_STATUS_REG_227E);\n\t\toutb(resetbit & ~SAFE_EN_N_227E, GP_STATUS_REG_227E);\n\t} else {\n\t\t \n\t\tresetbit = ioread16(wd_reset_base_addr);\n\t\tiowrite16(resetbit & ~SAFE_EN_N_427E, wd_reset_base_addr);\n\t}\n}\n\nstatic int wd_setup(u32 wdtmode)\n{\n\tunsigned int bootstatus = 0;\n\tint timeout_idx;\n\n\ttimeout_idx = find_closest(TIMEOUT_DEF, wd_timeout_table,\n\t\t\t\t   ARRAY_SIZE(wd_timeout_table));\n\n\tif (inb(WD_ENABLE_IOADR) & WD_TRIGGERED)\n\t\tbootstatus |= WDIOF_CARDRESET;\n\n\t \n\toutb(WD_TRIGGERED | WD_MACROMODE | timeout_idx << 3, WD_ENABLE_IOADR);\n\n\twd_secondary_enable(wdtmode);\n\n\treturn bootstatus;\n}\n\nstatic struct watchdog_device wdd_data = {\n\t.info = &wdt_ident,\n\t.ops = &wdt_ops,\n\t.min_timeout = TIMEOUT_MIN,\n\t.max_timeout = TIMEOUT_MAX\n};\n\nstatic int simatic_ipc_wdt_probe(struct platform_device *pdev)\n{\n\tstruct simatic_ipc_platform *plat = pdev->dev.platform_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint ret;\n\n\tswitch (plat->devmode) {\n\tcase SIMATIC_IPC_DEVICE_227E:\n\t\tres = &gp_status_reg_227e_res;\n\t\tif (!request_muxed_region(res->start, resource_size(res), res->name)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Unable to register IO resource at %pR\\n\",\n\t\t\t\t&gp_status_reg_227e_res);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tfallthrough;\n\tcase SIMATIC_IPC_DEVICE_427E:\n\t\twdd_data.parent = dev;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!devm_request_region(dev, io_resource_enable.start,\n\t\t\t\t resource_size(&io_resource_enable),\n\t\t\t\t io_resource_enable.name)) {\n\t\tdev_err(dev,\n\t\t\t\"Unable to register IO resource at %#x\\n\",\n\t\t\tWD_ENABLE_IOADR);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!devm_request_region(dev, io_resource_trigger.start,\n\t\t\t\t resource_size(&io_resource_trigger),\n\t\t\t\t io_resource_trigger.name)) {\n\t\tdev_err(dev,\n\t\t\t\"Unable to register IO resource at %#x\\n\",\n\t\t\tWD_TRIGGER_IOADR);\n\t\treturn -EBUSY;\n\t}\n\n\tif (plat->devmode == SIMATIC_IPC_DEVICE_427E) {\n\t\tres = &mem_resource;\n\n\t\tret = p2sb_bar(NULL, 0, res);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tres->start = res->start + (GPIO_COMMUNITY0_PORT_ID << 16) +\n\t\t\t     PAD_CFG_DW0_GPP_A_23;\n\t\tres->end = res->start + SZ_4 - 1;\n\n\t\twd_reset_base_addr = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(wd_reset_base_addr))\n\t\t\treturn PTR_ERR(wd_reset_base_addr);\n\t}\n\n\twdd_data.bootstatus = wd_setup(plat->devmode);\n\tif (wdd_data.bootstatus)\n\t\tdev_warn(dev, \"last reboot caused by watchdog reset\\n\");\n\n\tif (plat->devmode == SIMATIC_IPC_DEVICE_227E)\n\t\trelease_region(gp_status_reg_227e_res.start,\n\t\t\t       resource_size(&gp_status_reg_227e_res));\n\n\twatchdog_set_nowayout(&wdd_data, nowayout);\n\twatchdog_stop_on_reboot(&wdd_data);\n\treturn devm_watchdog_register_device(dev, &wdd_data);\n}\n\nstatic struct platform_driver simatic_ipc_wdt_driver = {\n\t.probe = simatic_ipc_wdt_probe,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t},\n};\n\nmodule_platform_driver(simatic_ipc_wdt_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" KBUILD_MODNAME);\nMODULE_AUTHOR(\"Gerd Haeussler <gerd.haeussler.ext@siemens.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}