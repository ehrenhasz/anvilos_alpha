{
  "module_name": "shwdt.c",
  "hash_id": "a4333893fc404dd1ff054ab22af23f41b8f4a13919510d48333a202604838649",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/shwdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/watchdog.h>\n#include <linux/pm_runtime.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <asm/watchdog.h>\n\n#define DRV_NAME \"sh-wdt\"\n\n \nstatic int clock_division_ratio = WTCSR_CKS_4096;\n#define next_ping_period(cks)\t(jiffies + msecs_to_jiffies(cks - 4))\n\n#define WATCHDOG_HEARTBEAT 30\t\t\t \nstatic int heartbeat = WATCHDOG_HEARTBEAT;\t \nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic unsigned long next_heartbeat;\n\nstruct sh_wdt {\n\tvoid __iomem\t\t*base;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tspinlock_t\t\tlock;\n\n\tstruct timer_list\ttimer;\n};\n\nstatic int sh_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tstruct sh_wdt *wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned long flags;\n\tu8 csr;\n\n\tpm_runtime_get_sync(wdt->dev);\n\tclk_enable(wdt->clk);\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\n\tnext_heartbeat = jiffies + (heartbeat * HZ);\n\tmod_timer(&wdt->timer, next_ping_period(clock_division_ratio));\n\n\tcsr = sh_wdt_read_csr();\n\tcsr |= WTCSR_WT | clock_division_ratio;\n\tsh_wdt_write_csr(csr);\n\n\tsh_wdt_write_cnt(0);\n\n\t \n\tcsr = sh_wdt_read_csr();\n\tcsr |= WTCSR_TME;\n\tcsr &= ~WTCSR_RSTS;\n\tsh_wdt_write_csr(csr);\n\n#ifdef CONFIG_CPU_SH2\n\tcsr = sh_wdt_read_rstcsr();\n\tcsr &= ~RSTCSR_RSTS;\n\tsh_wdt_write_rstcsr(csr);\n#endif\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sh_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct sh_wdt *wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned long flags;\n\tu8 csr;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\n\tdel_timer(&wdt->timer);\n\n\tcsr = sh_wdt_read_csr();\n\tcsr &= ~WTCSR_TME;\n\tsh_wdt_write_csr(csr);\n\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\tclk_disable(wdt->clk);\n\tpm_runtime_put_sync(wdt->dev);\n\n\treturn 0;\n}\n\nstatic int sh_wdt_keepalive(struct watchdog_device *wdt_dev)\n{\n\tstruct sh_wdt *wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\tnext_heartbeat = jiffies + (heartbeat * HZ);\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic int sh_wdt_set_heartbeat(struct watchdog_device *wdt_dev, unsigned t)\n{\n\tstruct sh_wdt *wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned long flags;\n\n\tif (unlikely(t < 1 || t > 3600))  \n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\theartbeat = t;\n\twdt_dev->timeout = t;\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic void sh_wdt_ping(struct timer_list *t)\n{\n\tstruct sh_wdt *wdt = from_timer(wdt, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\tif (time_before(jiffies, next_heartbeat)) {\n\t\tu8 csr;\n\n\t\tcsr = sh_wdt_read_csr();\n\t\tcsr &= ~WTCSR_IOVF;\n\t\tsh_wdt_write_csr(csr);\n\n\t\tsh_wdt_write_cnt(0);\n\n\t\tmod_timer(&wdt->timer, next_ping_period(clock_division_ratio));\n\t} else\n\t\tdev_warn(wdt->dev, \"Heartbeat lost! Will not ping \"\n\t\t         \"the watchdog\\n\");\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n}\n\nstatic const struct watchdog_info sh_wdt_info = {\n\t.options\t\t= WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\n\t\t\t\t  WDIOF_MAGICCLOSE,\n\t.firmware_version\t= 1,\n\t.identity\t\t= \"SH WDT\",\n};\n\nstatic const struct watchdog_ops sh_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= sh_wdt_start,\n\t.stop\t\t= sh_wdt_stop,\n\t.ping\t\t= sh_wdt_keepalive,\n\t.set_timeout\t= sh_wdt_set_heartbeat,\n};\n\nstatic struct watchdog_device sh_wdt_dev = {\n\t.info\t= &sh_wdt_info,\n\t.ops\t= &sh_wdt_ops,\n};\n\nstatic int sh_wdt_probe(struct platform_device *pdev)\n{\n\tstruct sh_wdt *wdt;\n\tint rc;\n\n\t \n\tif (pdev->id != -1)\n\t\treturn -EINVAL;\n\n\twdt = devm_kzalloc(&pdev->dev, sizeof(struct sh_wdt), GFP_KERNEL);\n\tif (unlikely(!wdt))\n\t\treturn -ENOMEM;\n\n\twdt->dev = &pdev->dev;\n\n\twdt->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(wdt->clk)) {\n\t\t \n\t\twdt->clk = NULL;\n\t}\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\twatchdog_set_nowayout(&sh_wdt_dev, nowayout);\n\twatchdog_set_drvdata(&sh_wdt_dev, wdt);\n\tsh_wdt_dev.parent = &pdev->dev;\n\n\tspin_lock_init(&wdt->lock);\n\n\trc = sh_wdt_set_heartbeat(&sh_wdt_dev, heartbeat);\n\tif (unlikely(rc)) {\n\t\t \n\t\tsh_wdt_set_heartbeat(&sh_wdt_dev, WATCHDOG_HEARTBEAT);\n\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"heartbeat value must be 1<=x<=3600, using %d\\n\",\n\t\t\t sh_wdt_dev.timeout);\n\t}\n\n\tdev_info(&pdev->dev, \"configured with heartbeat=%d sec (nowayout=%d)\\n\",\n\t\t sh_wdt_dev.timeout, nowayout);\n\n\trc = watchdog_register_device(&sh_wdt_dev);\n\tif (unlikely(rc)) {\n\t\tdev_err(&pdev->dev, \"Can't register watchdog (err=%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\ttimer_setup(&wdt->timer, sh_wdt_ping, 0);\n\twdt->timer.expires\t= next_ping_period(clock_division_ratio);\n\n\tdev_info(&pdev->dev, \"initialized.\\n\");\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void sh_wdt_remove(struct platform_device *pdev)\n{\n\twatchdog_unregister_device(&sh_wdt_dev);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic void sh_wdt_shutdown(struct platform_device *pdev)\n{\n\tsh_wdt_stop(&sh_wdt_dev);\n}\n\nstatic struct platform_driver sh_wdt_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t},\n\n\t.probe\t\t= sh_wdt_probe,\n\t.remove_new\t= sh_wdt_remove,\n\t.shutdown\t= sh_wdt_shutdown,\n};\n\nstatic int __init sh_wdt_init(void)\n{\n\tif (unlikely(clock_division_ratio < 0x5 ||\n\t\t     clock_division_ratio > 0x7)) {\n\t\tclock_division_ratio = WTCSR_CKS_4096;\n\n\t\tpr_info(\"divisor must be 0x5<=x<=0x7, using %d\\n\",\n\t\t\tclock_division_ratio);\n\t}\n\n\treturn platform_driver_register(&sh_wdt_driver);\n}\n\nstatic void __exit sh_wdt_exit(void)\n{\n\tplatform_driver_unregister(&sh_wdt_driver);\n}\nmodule_init(sh_wdt_init);\nmodule_exit(sh_wdt_exit);\n\nMODULE_AUTHOR(\"Paul Mundt <lethal@linux-sh.org>\");\nMODULE_DESCRIPTION(\"SuperH watchdog driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n\nmodule_param(clock_division_ratio, int, 0);\nMODULE_PARM_DESC(clock_division_ratio,\n\t\"Clock division ratio. Valid ranges are from 0x5 (1.31ms) \"\n\t\"to 0x7 (5.25ms). (default=\" __MODULE_STRING(WTCSR_CKS_4096) \")\");\n\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\"Watchdog heartbeat in seconds. (1 <= heartbeat <= 3600, default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_HEARTBEAT) \")\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}