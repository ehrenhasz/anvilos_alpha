{
  "module_name": "realtek_otto_wdt.c",
  "hash_id": "625d7e1e04bcd67771b198587281035af5a066075054324a44e6a296ded367eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/realtek_otto_wdt.c",
  "human_readable_source": "\n\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/reboot.h>\n#include <linux/watchdog.h>\n\n#define OTTO_WDT_REG_CNTR\t\t0x0\n#define OTTO_WDT_CNTR_PING\t\tBIT(31)\n\n#define OTTO_WDT_REG_INTR\t\t0x4\n#define OTTO_WDT_INTR_PHASE_1\t\tBIT(31)\n#define OTTO_WDT_INTR_PHASE_2\t\tBIT(30)\n\n#define OTTO_WDT_REG_CTRL\t\t0x8\n#define OTTO_WDT_CTRL_ENABLE\t\tBIT(31)\n#define OTTO_WDT_CTRL_PRESCALE\t\tGENMASK(30, 29)\n#define OTTO_WDT_CTRL_PHASE1\t\tGENMASK(26, 22)\n#define OTTO_WDT_CTRL_PHASE2\t\tGENMASK(19, 15)\n#define OTTO_WDT_CTRL_RST_MODE\t\tGENMASK(1, 0)\n#define OTTO_WDT_MODE_SOC\t\t0\n#define OTTO_WDT_MODE_CPU\t\t1\n#define OTTO_WDT_MODE_SOFTWARE\t\t2\n#define OTTO_WDT_CTRL_DEFAULT\t\tOTTO_WDT_MODE_CPU\n\n#define OTTO_WDT_PRESCALE_MAX\t\t3\n\n \n#define OTTO_WDT_PHASE_TICKS_MAX\t32\n\n \n#define OTTO_WDT_TIMEOUT_TICKS_MAX\t(OTTO_WDT_PHASE_TICKS_MAX + 1)\n\nstruct otto_wdt_ctrl {\n\tstruct watchdog_device wdev;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tunsigned int clk_rate_khz;\n\tint irq_phase1;\n};\n\nstatic int otto_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct otto_wdt_ctrl *ctrl = watchdog_get_drvdata(wdev);\n\tu32 v;\n\n\tv = ioread32(ctrl->base + OTTO_WDT_REG_CTRL);\n\tv |= OTTO_WDT_CTRL_ENABLE;\n\tiowrite32(v, ctrl->base + OTTO_WDT_REG_CTRL);\n\n\treturn 0;\n}\n\nstatic int otto_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct otto_wdt_ctrl *ctrl = watchdog_get_drvdata(wdev);\n\tu32 v;\n\n\tv = ioread32(ctrl->base + OTTO_WDT_REG_CTRL);\n\tv &= ~OTTO_WDT_CTRL_ENABLE;\n\tiowrite32(v, ctrl->base + OTTO_WDT_REG_CTRL);\n\n\treturn 0;\n}\n\nstatic int otto_wdt_ping(struct watchdog_device *wdev)\n{\n\tstruct otto_wdt_ctrl *ctrl = watchdog_get_drvdata(wdev);\n\n\tiowrite32(OTTO_WDT_CNTR_PING, ctrl->base + OTTO_WDT_REG_CNTR);\n\n\treturn 0;\n}\n\nstatic int otto_wdt_tick_ms(struct otto_wdt_ctrl *ctrl, int prescale)\n{\n\treturn DIV_ROUND_CLOSEST(1 << (25 + prescale), ctrl->clk_rate_khz);\n}\n\n \nstatic inline unsigned int div_round_ticks(unsigned int val, unsigned int tick_duration,\n\t\tunsigned int min_ticks)\n{\n\treturn max(min_ticks, DIV_ROUND_UP(val, tick_duration));\n}\n\nstatic int otto_wdt_determine_timeouts(struct watchdog_device *wdev, unsigned int timeout,\n\t\tunsigned int pretimeout)\n{\n\tstruct otto_wdt_ctrl *ctrl = watchdog_get_drvdata(wdev);\n\tunsigned int pretimeout_ms = pretimeout * 1000;\n\tunsigned int timeout_ms = timeout * 1000;\n\tunsigned int prescale_next = 0;\n\tunsigned int phase1_ticks;\n\tunsigned int phase2_ticks;\n\tunsigned int total_ticks;\n\tunsigned int prescale;\n\tunsigned int tick_ms;\n\tu32 v;\n\n\tdo {\n\t\tprescale = prescale_next;\n\t\tif (prescale > OTTO_WDT_PRESCALE_MAX)\n\t\t\treturn -EINVAL;\n\n\t\ttick_ms = otto_wdt_tick_ms(ctrl, prescale);\n\t\ttotal_ticks = div_round_ticks(timeout_ms, tick_ms, 2);\n\t\tphase1_ticks = div_round_ticks(timeout_ms - pretimeout_ms, tick_ms, 1);\n\t\tphase2_ticks = total_ticks - phase1_ticks;\n\n\t\tprescale_next++;\n\t} while (phase1_ticks > OTTO_WDT_PHASE_TICKS_MAX\n\t\t|| phase2_ticks > OTTO_WDT_PHASE_TICKS_MAX);\n\n\tv = ioread32(ctrl->base + OTTO_WDT_REG_CTRL);\n\n\tv &= ~(OTTO_WDT_CTRL_PRESCALE | OTTO_WDT_CTRL_PHASE1 | OTTO_WDT_CTRL_PHASE2);\n\tv |= FIELD_PREP(OTTO_WDT_CTRL_PHASE1, phase1_ticks - 1);\n\tv |= FIELD_PREP(OTTO_WDT_CTRL_PHASE2, phase2_ticks - 1);\n\tv |= FIELD_PREP(OTTO_WDT_CTRL_PRESCALE, prescale);\n\n\tiowrite32(v, ctrl->base + OTTO_WDT_REG_CTRL);\n\n\ttimeout_ms = total_ticks * tick_ms;\n\tctrl->wdev.timeout = timeout_ms / 1000;\n\n\tpretimeout_ms = phase2_ticks * tick_ms;\n\tctrl->wdev.pretimeout = pretimeout_ms / 1000;\n\n\treturn 0;\n}\n\nstatic int otto_wdt_set_timeout(struct watchdog_device *wdev, unsigned int val)\n{\n\treturn otto_wdt_determine_timeouts(wdev, val, min(wdev->pretimeout, val - 1));\n}\n\nstatic int otto_wdt_set_pretimeout(struct watchdog_device *wdev, unsigned int val)\n{\n\treturn otto_wdt_determine_timeouts(wdev, wdev->timeout, val);\n}\n\nstatic int otto_wdt_restart(struct watchdog_device *wdev, unsigned long reboot_mode,\n\t\tvoid *data)\n{\n\tstruct otto_wdt_ctrl *ctrl = watchdog_get_drvdata(wdev);\n\tu32 reset_mode;\n\tu32 v;\n\n\tdisable_irq(ctrl->irq_phase1);\n\n\tswitch (reboot_mode) {\n\tcase REBOOT_SOFT:\n\t\treset_mode = OTTO_WDT_MODE_SOFTWARE;\n\t\tbreak;\n\tcase REBOOT_WARM:\n\t\treset_mode = OTTO_WDT_MODE_CPU;\n\t\tbreak;\n\tdefault:\n\t\treset_mode = OTTO_WDT_MODE_SOC;\n\t\tbreak;\n\t}\n\n\t \n\tv = FIELD_PREP(OTTO_WDT_CTRL_RST_MODE, reset_mode) | OTTO_WDT_CTRL_ENABLE;\n\tiowrite32(v, ctrl->base + OTTO_WDT_REG_CTRL);\n\n\tmdelay(3 * otto_wdt_tick_ms(ctrl, 0));\n\n\treturn 0;\n}\n\nstatic irqreturn_t otto_wdt_phase1_isr(int irq, void *dev_id)\n{\n\tstruct otto_wdt_ctrl *ctrl = dev_id;\n\n\tiowrite32(OTTO_WDT_INTR_PHASE_1, ctrl->base + OTTO_WDT_REG_INTR);\n\tdev_crit(ctrl->dev, \"phase 1 timeout\\n\");\n\twatchdog_notify_pretimeout(&ctrl->wdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct watchdog_ops otto_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = otto_wdt_start,\n\t.stop = otto_wdt_stop,\n\t.ping = otto_wdt_ping,\n\t.set_timeout = otto_wdt_set_timeout,\n\t.set_pretimeout = otto_wdt_set_pretimeout,\n\t.restart = otto_wdt_restart,\n};\n\nstatic const struct watchdog_info otto_wdt_info = {\n\t.identity = \"Realtek Otto watchdog timer\",\n\t.options = WDIOF_KEEPALIVEPING |\n\t\tWDIOF_MAGICCLOSE |\n\t\tWDIOF_SETTIMEOUT |\n\t\tWDIOF_PRETIMEOUT,\n};\n\nstatic int otto_wdt_probe_clk(struct otto_wdt_ctrl *ctrl)\n{\n\tstruct clk *clk;\n\n\tclk = devm_clk_get_enabled(ctrl->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(ctrl->dev, PTR_ERR(clk), \"Failed to get clock\\n\");\n\n\tctrl->clk_rate_khz = clk_get_rate(clk) / 1000;\n\tif (ctrl->clk_rate_khz == 0)\n\t\treturn dev_err_probe(ctrl->dev, -ENXIO, \"Failed to get clock rate\\n\");\n\n\treturn 0;\n}\n\nstatic int otto_wdt_probe_reset_mode(struct otto_wdt_ctrl *ctrl)\n{\n\tstatic const char *mode_property = \"realtek,reset-mode\";\n\tconst struct fwnode_handle *node = ctrl->dev->fwnode;\n\tint mode_count;\n\tu32 mode;\n\tu32 v;\n\n\tif (!node)\n\t\treturn -ENXIO;\n\n\tmode_count = fwnode_property_string_array_count(node, mode_property);\n\tif (mode_count < 0)\n\t\treturn mode_count;\n\telse if (mode_count == 0)\n\t\treturn 0;\n\telse if (mode_count != 1)\n\t\treturn -EINVAL;\n\n\tif (fwnode_property_match_string(node, mode_property, \"soc\") == 0)\n\t\tmode = OTTO_WDT_MODE_SOC;\n\telse if (fwnode_property_match_string(node, mode_property, \"cpu\") == 0)\n\t\tmode = OTTO_WDT_MODE_CPU;\n\telse if (fwnode_property_match_string(node, mode_property, \"software\") == 0)\n\t\tmode = OTTO_WDT_MODE_SOFTWARE;\n\telse\n\t\treturn -EINVAL;\n\n\tv = ioread32(ctrl->base + OTTO_WDT_REG_CTRL);\n\tv &= ~OTTO_WDT_CTRL_RST_MODE;\n\tv |= FIELD_PREP(OTTO_WDT_CTRL_RST_MODE, mode);\n\tiowrite32(v, ctrl->base + OTTO_WDT_REG_CTRL);\n\n\treturn 0;\n}\n\nstatic int otto_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct otto_wdt_ctrl *ctrl;\n\tunsigned int max_tick_ms;\n\tint ret;\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = dev;\n\tctrl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctrl->base))\n\t\treturn PTR_ERR(ctrl->base);\n\n\t \n\tiowrite32(OTTO_WDT_INTR_PHASE_1 | OTTO_WDT_INTR_PHASE_2,\n\t\t\tctrl->base + OTTO_WDT_REG_INTR);\n\tiowrite32(OTTO_WDT_CTRL_DEFAULT, ctrl->base + OTTO_WDT_REG_CTRL);\n\n\tret = otto_wdt_probe_clk(ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl->irq_phase1 = platform_get_irq_byname(pdev, \"phase1\");\n\tif (ctrl->irq_phase1 < 0)\n\t\treturn ctrl->irq_phase1;\n\n\tret = devm_request_irq(dev, ctrl->irq_phase1, otto_wdt_phase1_isr, 0,\n\t\t\t\"realtek-otto-wdt\", ctrl);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get IRQ for phase1\\n\");\n\n\tret = otto_wdt_probe_reset_mode(ctrl);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Invalid reset mode specified\\n\");\n\n\tctrl->wdev.parent = dev;\n\tctrl->wdev.info = &otto_wdt_info;\n\tctrl->wdev.ops = &otto_wdt_ops;\n\n\t \n\tctrl->wdev.min_timeout = 2;\n\tmax_tick_ms = otto_wdt_tick_ms(ctrl, OTTO_WDT_PRESCALE_MAX);\n\tctrl->wdev.max_hw_heartbeat_ms = max_tick_ms * OTTO_WDT_TIMEOUT_TICKS_MAX;\n\tctrl->wdev.timeout = min(30U, ctrl->wdev.max_hw_heartbeat_ms / 1000);\n\n\twatchdog_set_drvdata(&ctrl->wdev, ctrl);\n\twatchdog_init_timeout(&ctrl->wdev, 0, dev);\n\twatchdog_stop_on_reboot(&ctrl->wdev);\n\twatchdog_set_restart_priority(&ctrl->wdev, 128);\n\n\tret = otto_wdt_determine_timeouts(&ctrl->wdev, ctrl->wdev.timeout, 1);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to set timeout\\n\");\n\n\treturn devm_watchdog_register_device(dev, &ctrl->wdev);\n}\n\nstatic const struct of_device_id otto_wdt_ids[] = {\n\t{ .compatible = \"realtek,rtl8380-wdt\" },\n\t{ .compatible = \"realtek,rtl8390-wdt\" },\n\t{ .compatible = \"realtek,rtl9300-wdt\" },\n\t{ .compatible = \"realtek,rtl9310-wdt\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, otto_wdt_ids);\n\nstatic struct platform_driver otto_wdt_driver = {\n\t.probe = otto_wdt_probe,\n\t.driver = {\n\t\t.name = \"realtek-otto-watchdog\",\n\t\t.of_match_table\t= otto_wdt_ids,\n\t},\n};\nmodule_platform_driver(otto_wdt_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Sander Vanheule <sander@svanheule.net>\");\nMODULE_DESCRIPTION(\"Realtek Otto watchdog timer driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}