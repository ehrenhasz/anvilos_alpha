{
  "module_name": "rn5t618_wdt.c",
  "hash_id": "4ed8438bb2d09c3e699f3ad59a20b0baa57edb6d6d931c608e1528858b9c04f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rn5t618_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mfd/rn5t618.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define DRIVER_NAME \"rn5t618-wdt\"\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic unsigned int timeout;\n\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Initial watchdog timeout in seconds\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct rn5t618_wdt {\n\tstruct watchdog_device wdt_dev;\n\tstruct rn5t618 *rn5t618;\n};\n\n \nstatic const struct {\n\tu8 reg_val;\n\tunsigned int time;\n} rn5t618_wdt_map[] = {\n\t{ 0, 1 },\n\t{ 1, 8 },\n\t{ 2, 32 },\n\t{ 3, 128 },\n};\n\nstatic int rn5t618_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t   unsigned int t)\n{\n\tstruct rn5t618_wdt *wdt = watchdog_get_drvdata(wdt_dev);\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rn5t618_wdt_map); i++) {\n\t\tif (rn5t618_wdt_map[i].time + 1 >= t)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(rn5t618_wdt_map))\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(wdt->rn5t618->regmap, RN5T618_WATCHDOG,\n\t\t\t\t RN5T618_WATCHDOG_WDOGTIM_M,\n\t\t\t\t rn5t618_wdt_map[i].reg_val);\n\tif (!ret)\n\t\twdt_dev->timeout = rn5t618_wdt_map[i].time;\n\n\treturn ret;\n}\n\nstatic int rn5t618_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tstruct rn5t618_wdt *wdt = watchdog_get_drvdata(wdt_dev);\n\tint ret;\n\n\tret = rn5t618_wdt_set_timeout(wdt_dev, wdt_dev->timeout);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(wdt->rn5t618->regmap, RN5T618_REPCNT,\n\t\t\t\t RN5T618_REPCNT_REPWRON,\n\t\t\t\t RN5T618_REPCNT_REPWRON);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(wdt->rn5t618->regmap, RN5T618_WATCHDOG,\n\t\t\t\t RN5T618_WATCHDOG_WDOGEN,\n\t\t\t\t RN5T618_WATCHDOG_WDOGEN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(wdt->rn5t618->regmap, RN5T618_PWRIREN,\n\t\t\t\t  RN5T618_PWRIRQ_IR_WDOG,\n\t\t\t\t  RN5T618_PWRIRQ_IR_WDOG);\n}\n\nstatic int rn5t618_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct rn5t618_wdt *wdt = watchdog_get_drvdata(wdt_dev);\n\n\treturn regmap_update_bits(wdt->rn5t618->regmap, RN5T618_WATCHDOG,\n\t\t\t\t  RN5T618_WATCHDOG_WDOGEN, 0);\n}\n\nstatic int rn5t618_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct rn5t618_wdt *wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(wdt->rn5t618->regmap, RN5T618_WATCHDOG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(wdt->rn5t618->regmap, RN5T618_WATCHDOG, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(wdt->rn5t618->regmap, RN5T618_PWRIRQ,\n\t\t\t\t  RN5T618_PWRIRQ_IR_WDOG, 0);\n}\n\nstatic const struct watchdog_info rn5t618_wdt_info = {\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE |\n\t\t\t  WDIOF_KEEPALIVEPING,\n\t.identity\t= DRIVER_NAME,\n};\n\nstatic const struct watchdog_ops rn5t618_wdt_ops = {\n\t.owner          = THIS_MODULE,\n\t.start          = rn5t618_wdt_start,\n\t.stop           = rn5t618_wdt_stop,\n\t.ping           = rn5t618_wdt_ping,\n\t.set_timeout    = rn5t618_wdt_set_timeout,\n};\n\nstatic int rn5t618_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rn5t618 *rn5t618 = dev_get_drvdata(dev->parent);\n\tstruct rn5t618_wdt *wdt;\n\tint min_timeout, max_timeout;\n\tint ret;\n\tunsigned int val;\n\n\twdt = devm_kzalloc(dev, sizeof(struct rn5t618_wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tmin_timeout = rn5t618_wdt_map[0].time;\n\tmax_timeout = rn5t618_wdt_map[ARRAY_SIZE(rn5t618_wdt_map) - 1].time;\n\n\twdt->rn5t618 = rn5t618;\n\twdt->wdt_dev.info = &rn5t618_wdt_info;\n\twdt->wdt_dev.ops = &rn5t618_wdt_ops;\n\twdt->wdt_dev.min_timeout = min_timeout;\n\twdt->wdt_dev.max_timeout = max_timeout;\n\twdt->wdt_dev.timeout = max_timeout;\n\twdt->wdt_dev.parent = dev;\n\n\t \n\tret = regmap_read(wdt->rn5t618->regmap, RN5T618_POFFHIS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & RN5T618_POFFHIS_VINDET)\n\t\twdt->wdt_dev.bootstatus = WDIOF_POWERUNDER;\n\telse if (val & RN5T618_POFFHIS_WDG)\n\t\twdt->wdt_dev.bootstatus = WDIOF_CARDRESET;\n\n\twatchdog_set_drvdata(&wdt->wdt_dev, wdt);\n\twatchdog_init_timeout(&wdt->wdt_dev, timeout, dev);\n\twatchdog_set_nowayout(&wdt->wdt_dev, nowayout);\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\treturn devm_watchdog_register_device(dev, &wdt->wdt_dev);\n}\n\nstatic struct platform_driver rn5t618_wdt_driver = {\n\t.probe = rn5t618_wdt_probe,\n\t.driver = {\n\t\t.name\t= DRIVER_NAME,\n\t},\n};\n\nmodule_platform_driver(rn5t618_wdt_driver);\n\nMODULE_ALIAS(\"platform:rn5t618-wdt\");\nMODULE_AUTHOR(\"Beniamino Galvani <b.galvani@gmail.com>\");\nMODULE_DESCRIPTION(\"RN5T618 watchdog driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}