{
  "module_name": "da9055_wdt.c",
  "hash_id": "1c036f4b0c60da9a3b07a2c43cf859315c3a9adb35866642f4f6070fd0f96cfc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/da9055_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n#include <linux/delay.h>\n\n#include <linux/mfd/da9055/core.h>\n#include <linux/mfd/da9055/reg.h>\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n#define DA9055_DEF_TIMEOUT\t4\n#define DA9055_TWDMIN\t\t256\n\nstruct da9055_wdt_data {\n\tstruct watchdog_device wdt;\n\tstruct da9055 *da9055;\n};\n\nstatic const struct {\n\tu8 reg_val;\n\tint user_time;   \n} da9055_wdt_maps[] = {\n\t{ 0, 0 },\n\t{ 1, 2 },\n\t{ 2, 4 },\n\t{ 3, 8 },\n\t{ 4, 16 },\n\t{ 5, 32 },\n\t{ 5, 33 },   \n\t{ 6, 65 },\n\t{ 6, 66 },   \n\t{ 7, 131 },\n};\n\nstatic int da9055_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct da9055_wdt_data *driver_data = watchdog_get_drvdata(wdt_dev);\n\tstruct da9055 *da9055 = driver_data->da9055;\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(da9055_wdt_maps); i++)\n\t\tif (da9055_wdt_maps[i].user_time == timeout)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(da9055_wdt_maps))\n\t\tret = -EINVAL;\n\telse\n\t\tret = da9055_reg_update(da9055, DA9055_REG_CONTROL_B,\n\t\t\t\t\tDA9055_TWDSCALE_MASK,\n\t\t\t\t\tda9055_wdt_maps[i].reg_val <<\n\t\t\t\t\tDA9055_TWDSCALE_SHIFT);\n\tif (ret < 0) {\n\t\tdev_err(da9055->dev,\n\t\t\t\"Failed to update timescale bit, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twdt_dev->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic int da9055_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct da9055_wdt_data *driver_data = watchdog_get_drvdata(wdt_dev);\n\tstruct da9055 *da9055 = driver_data->da9055;\n\n\t \n\tmdelay(DA9055_TWDMIN);\n\n\t \n\treturn da9055_reg_update(da9055, DA9055_REG_CONTROL_E,\n\t\t\t\t DA9055_WATCHDOG_MASK, 1);\n}\n\nstatic int da9055_wdt_start(struct watchdog_device *wdt_dev)\n{\n\treturn da9055_wdt_set_timeout(wdt_dev, wdt_dev->timeout);\n}\n\nstatic int da9055_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\treturn da9055_wdt_set_timeout(wdt_dev, 0);\n}\n\nstatic const struct watchdog_info da9055_wdt_info = {\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n\t.identity\t= \"DA9055 Watchdog\",\n};\n\nstatic const struct watchdog_ops da9055_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = da9055_wdt_start,\n\t.stop = da9055_wdt_stop,\n\t.ping = da9055_wdt_ping,\n\t.set_timeout = da9055_wdt_set_timeout,\n};\n\nstatic int da9055_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da9055 *da9055 = dev_get_drvdata(dev->parent);\n\tstruct da9055_wdt_data *driver_data;\n\tstruct watchdog_device *da9055_wdt;\n\tint ret;\n\n\tdriver_data = devm_kzalloc(dev, sizeof(*driver_data), GFP_KERNEL);\n\tif (!driver_data)\n\t\treturn -ENOMEM;\n\n\tdriver_data->da9055 = da9055;\n\n\tda9055_wdt = &driver_data->wdt;\n\n\tda9055_wdt->timeout = DA9055_DEF_TIMEOUT;\n\tda9055_wdt->info = &da9055_wdt_info;\n\tda9055_wdt->ops = &da9055_wdt_ops;\n\tda9055_wdt->parent = dev;\n\twatchdog_set_nowayout(da9055_wdt, nowayout);\n\twatchdog_set_drvdata(da9055_wdt, driver_data);\n\n\tret = da9055_wdt_stop(da9055_wdt);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to stop watchdog, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_watchdog_register_device(dev, &driver_data->wdt);\n\tif (ret != 0)\n\t\tdev_err(da9055->dev, \"watchdog_register_device() failed: %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver da9055_wdt_driver = {\n\t.probe = da9055_wdt_probe,\n\t.driver = {\n\t\t.name\t= \"da9055-watchdog\",\n\t},\n};\n\nmodule_platform_driver(da9055_wdt_driver);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"DA9055 watchdog\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9055-watchdog\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}