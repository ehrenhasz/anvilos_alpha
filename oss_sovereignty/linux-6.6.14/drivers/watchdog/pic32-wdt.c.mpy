{
  "module_name": "pic32-wdt.c",
  "hash_id": "7b2ca556383cddfd30d95f9bb5795c4aef0316612268d6982d5426a0efa7605a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pic32-wdt.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/watchdog.h>\n\n#include <asm/mach-pic32/pic32.h>\n\n \n#define WDTCON_REG\t\t0x00\n\n \n#define WDTCON_WIN_EN\t\tBIT(0)\n#define WDTCON_RMCS_MASK\t0x0003\n#define WDTCON_RMCS_SHIFT\t0x0006\n#define WDTCON_RMPS_MASK\t0x001F\n#define WDTCON_RMPS_SHIFT\t0x0008\n#define WDTCON_ON\t\tBIT(15)\n#define WDTCON_CLR_KEY\t\t0x5743\n\n \n#define RESETCON_TIMEOUT_IDLE\tBIT(2)\n#define RESETCON_TIMEOUT_SLEEP\tBIT(3)\n#define RESETCON_WDT_TIMEOUT\tBIT(4)\n\nstruct pic32_wdt {\n\tvoid __iomem\t*regs;\n\tvoid __iomem\t*rst_base;\n\tstruct clk\t*clk;\n};\n\nstatic inline bool pic32_wdt_is_win_enabled(struct pic32_wdt *wdt)\n{\n\treturn !!(readl(wdt->regs + WDTCON_REG) & WDTCON_WIN_EN);\n}\n\nstatic inline u32 pic32_wdt_get_post_scaler(struct pic32_wdt *wdt)\n{\n\tu32 v = readl(wdt->regs + WDTCON_REG);\n\n\treturn (v >> WDTCON_RMPS_SHIFT) & WDTCON_RMPS_MASK;\n}\n\nstatic inline u32 pic32_wdt_get_clk_id(struct pic32_wdt *wdt)\n{\n\tu32 v = readl(wdt->regs + WDTCON_REG);\n\n\treturn (v >> WDTCON_RMCS_SHIFT) & WDTCON_RMCS_MASK;\n}\n\nstatic int pic32_wdt_bootstatus(struct pic32_wdt *wdt)\n{\n\tu32 v = readl(wdt->rst_base);\n\n\twritel(RESETCON_WDT_TIMEOUT, PIC32_CLR(wdt->rst_base));\n\n\treturn v & RESETCON_WDT_TIMEOUT;\n}\n\nstatic u32 pic32_wdt_get_timeout_secs(struct pic32_wdt *wdt, struct device *dev)\n{\n\tunsigned long rate;\n\tu32 period, ps, terminal;\n\n\trate = clk_get_rate(wdt->clk);\n\n\tdev_dbg(dev, \"wdt: clk_id %d, clk_rate %lu (prescale)\\n\",\n\t\tpic32_wdt_get_clk_id(wdt), rate);\n\n\t \n\trate >>= 5;\n\tif (!rate)\n\t\treturn 0;\n\n\t \n\tps = pic32_wdt_get_post_scaler(wdt);\n\tterminal = BIT(ps);\n\n\t \n\tperiod = terminal / rate;\n\tdev_dbg(dev,\n\t\t\"wdt: clk_rate %lu (postscale) / terminal %d, timeout %dsec\\n\",\n\t\trate, terminal, period);\n\n\treturn period;\n}\n\nstatic void pic32_wdt_keepalive(struct pic32_wdt *wdt)\n{\n\t \n\twritew(WDTCON_CLR_KEY, wdt->regs + WDTCON_REG + 2);\n}\n\nstatic int pic32_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct pic32_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twritel(WDTCON_ON, PIC32_SET(wdt->regs + WDTCON_REG));\n\tpic32_wdt_keepalive(wdt);\n\n\treturn 0;\n}\n\nstatic int pic32_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct pic32_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twritel(WDTCON_ON, PIC32_CLR(wdt->regs + WDTCON_REG));\n\n\t \n\tnop();\n\n\treturn 0;\n}\n\nstatic int pic32_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct pic32_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tpic32_wdt_keepalive(wdt);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops pic32_wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= pic32_wdt_start,\n\t.stop\t\t= pic32_wdt_stop,\n\t.ping\t\t= pic32_wdt_ping,\n};\n\nstatic const struct watchdog_info pic32_wdt_ident = {\n\t.options = WDIOF_KEEPALIVEPING |\n\t\t\tWDIOF_MAGICCLOSE | WDIOF_CARDRESET,\n\t.identity = \"PIC32 Watchdog\",\n};\n\nstatic struct watchdog_device pic32_wdd = {\n\t.info\t\t= &pic32_wdt_ident,\n\t.ops\t\t= &pic32_wdt_fops,\n};\n\nstatic const struct of_device_id pic32_wdt_dt_ids[] = {\n\t{ .compatible = \"microchip,pic32mzda-wdt\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pic32_wdt_dt_ids);\n\nstatic int pic32_wdt_drv_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tstruct watchdog_device *wdd = &pic32_wdd;\n\tstruct pic32_wdt *wdt;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->regs))\n\t\treturn PTR_ERR(wdt->regs);\n\n\twdt->rst_base = devm_ioremap(dev, PIC32_BASE_RESET, 0x10);\n\tif (!wdt->rst_base)\n\t\treturn -ENOMEM;\n\n\twdt->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(wdt->clk)) {\n\t\tdev_err(dev, \"clk not found\\n\");\n\t\treturn PTR_ERR(wdt->clk);\n\t}\n\n\tif (pic32_wdt_is_win_enabled(wdt)) {\n\t\tdev_err(dev, \"windowed-clear mode is not supported.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twdd->timeout = pic32_wdt_get_timeout_secs(wdt, dev);\n\tif (!wdd->timeout) {\n\t\tdev_err(dev, \"failed to read watchdog register timeout\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(dev, \"timeout %d\\n\", wdd->timeout);\n\n\twdd->bootstatus = pic32_wdt_bootstatus(wdt) ? WDIOF_CARDRESET : 0;\n\n\twatchdog_set_nowayout(wdd, WATCHDOG_NOWAYOUT);\n\twatchdog_set_drvdata(wdd, wdt);\n\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdd);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pic32_wdt_driver = {\n\t.probe\t\t= pic32_wdt_drv_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"pic32-wdt\",\n\t\t.of_match_table = of_match_ptr(pic32_wdt_dt_ids),\n\t}\n};\n\nmodule_platform_driver(pic32_wdt_driver);\n\nMODULE_AUTHOR(\"Joshua Henderson <joshua.henderson@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip PIC32 Watchdog Timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}