{
  "module_name": "riowd.c",
  "hash_id": "9886630feeb1a82829f753ba684af9ab48a7cc531461980258f8b660b879ea00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/riowd.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n\n \n\nMODULE_AUTHOR(\"David S. Miller <davem@davemloft.net>\");\nMODULE_DESCRIPTION(\"Hardware watchdog driver for Sun RIO\");\nMODULE_LICENSE(\"GPL\");\n\n#define DRIVER_NAME\t\"riowd\"\n#define PFX\t\tDRIVER_NAME \": \"\n\nstruct riowd {\n\tvoid __iomem\t\t*regs;\n\tspinlock_t\t\tlock;\n};\n\nstatic struct riowd *riowd_device;\n\n#define WDTO_INDEX\t0x05\n\nstatic int riowd_timeout = 1;\t\t \nmodule_param(riowd_timeout, int, 0);\nMODULE_PARM_DESC(riowd_timeout, \"Watchdog timeout in minutes\");\n\nstatic void riowd_writereg(struct riowd *p, u8 val, int index)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&p->lock, flags);\n\twriteb(index, p->regs + 0);\n\twriteb(val, p->regs + 1);\n\tspin_unlock_irqrestore(&p->lock, flags);\n}\n\nstatic int riowd_open(struct inode *inode, struct file *filp)\n{\n\tstream_open(inode, filp);\n\treturn 0;\n}\n\nstatic int riowd_release(struct inode *inode, struct file *filp)\n{\n\treturn 0;\n}\n\nstatic long riowd_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstatic const struct watchdog_info info = {\n\t\t.options\t\t= WDIOF_SETTIMEOUT,\n\t\t.firmware_version\t= 1,\n\t\t.identity\t\t= DRIVER_NAME,\n\t};\n\tvoid __user *argp = (void __user *)arg;\n\tstruct riowd *p = riowd_device;\n\tunsigned int options;\n\tint new_margin;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tif (put_user(0, (int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\triowd_writereg(p, riowd_timeout, WDTO_INDEX);\n\t\tbreak;\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (copy_from_user(&options, argp, sizeof(options)))\n\t\t\treturn -EFAULT;\n\n\t\tif (options & WDIOS_DISABLECARD)\n\t\t\triowd_writereg(p, 0, WDTO_INDEX);\n\t\telse if (options & WDIOS_ENABLECARD)\n\t\t\triowd_writereg(p, riowd_timeout, WDTO_INDEX);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_margin, (int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\tif ((new_margin < 60) || (new_margin > (255 * 60)))\n\t\t\treturn -EINVAL;\n\t\triowd_timeout = (new_margin + 59) / 60;\n\t\triowd_writereg(p, riowd_timeout, WDTO_INDEX);\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(riowd_timeout * 60, (int __user *)argp);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t riowd_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct riowd *p = riowd_device;\n\n\tif (count) {\n\t\triowd_writereg(p, riowd_timeout, WDTO_INDEX);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations riowd_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.llseek =\t\tno_llseek,\n\t.unlocked_ioctl =\triowd_ioctl,\n\t.compat_ioctl\t=\tcompat_ptr_ioctl,\n\t.open =\t\t\triowd_open,\n\t.write =\t\triowd_write,\n\t.release =\t\triowd_release,\n};\n\nstatic struct miscdevice riowd_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &riowd_fops\n};\n\nstatic int riowd_probe(struct platform_device *op)\n{\n\tstruct riowd *p;\n\tint err = -EINVAL;\n\n\tif (riowd_device)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tp = devm_kzalloc(&op->dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\tgoto out;\n\n\tspin_lock_init(&p->lock);\n\n\tp->regs = of_ioremap(&op->resource[0], 0, 2, DRIVER_NAME);\n\tif (!p->regs) {\n\t\tpr_err(\"Cannot map registers\\n\");\n\t\tgoto out;\n\t}\n\t \n\triowd_device = p;\n\n\terr = misc_register(&riowd_miscdev);\n\tif (err) {\n\t\tpr_err(\"Cannot register watchdog misc device\\n\");\n\t\tgoto out_iounmap;\n\t}\n\n\tpr_info(\"Hardware watchdog [%i minutes], regs at %p\\n\",\n\t\triowd_timeout, p->regs);\n\n\tplatform_set_drvdata(op, p);\n\treturn 0;\n\nout_iounmap:\n\triowd_device = NULL;\n\tof_iounmap(&op->resource[0], p->regs, 2);\n\nout:\n\treturn err;\n}\n\nstatic void riowd_remove(struct platform_device *op)\n{\n\tstruct riowd *p = platform_get_drvdata(op);\n\n\tmisc_deregister(&riowd_miscdev);\n\tof_iounmap(&op->resource[0], p->regs, 2);\n}\n\nstatic const struct of_device_id riowd_match[] = {\n\t{\n\t\t.name = \"pmc\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, riowd_match);\n\nstatic struct platform_driver riowd_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = riowd_match,\n\t},\n\t.probe\t\t= riowd_probe,\n\t.remove_new\t= riowd_remove,\n};\n\nmodule_platform_driver(riowd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}