{
  "module_name": "watchdog_core.c",
  "hash_id": "12d49da098b6f0d1c8d0e77481b7effad503fd6fbd7f9cf7ca06292de24038d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/watchdog_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\t \n#include <linux/types.h>\t \n#include <linux/errno.h>\t \n#include <linux/kernel.h>\t \n#include <linux/reboot.h>\t \n#include <linux/watchdog.h>\t \n#include <linux/init.h>\t\t \n#include <linux/idr.h>\t\t \n#include <linux/err.h>\t\t \n#include <linux/of.h>\t\t \n#include <linux/suspend.h>\n\n#include \"watchdog_core.h\"\t \n\n#define CREATE_TRACE_POINTS\n#include <trace/events/watchdog.h>\n\nstatic DEFINE_IDA(watchdog_ida);\n\nstatic int stop_on_reboot = -1;\nmodule_param(stop_on_reboot, int, 0444);\nMODULE_PARM_DESC(stop_on_reboot, \"Stop watchdogs on reboot (0=keep watching, 1=stop)\");\n\n \n\nstatic DEFINE_MUTEX(wtd_deferred_reg_mutex);\nstatic LIST_HEAD(wtd_deferred_reg_list);\nstatic bool wtd_deferred_reg_done;\n\nstatic void watchdog_deferred_registration_add(struct watchdog_device *wdd)\n{\n\tlist_add_tail(&wdd->deferred,\n\t\t      &wtd_deferred_reg_list);\n}\n\nstatic void watchdog_deferred_registration_del(struct watchdog_device *wdd)\n{\n\tstruct list_head *p, *n;\n\tstruct watchdog_device *wdd_tmp;\n\n\tlist_for_each_safe(p, n, &wtd_deferred_reg_list) {\n\t\twdd_tmp = list_entry(p, struct watchdog_device,\n\t\t\t\t     deferred);\n\t\tif (wdd_tmp == wdd) {\n\t\t\tlist_del(&wdd_tmp->deferred);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void watchdog_check_min_max_timeout(struct watchdog_device *wdd)\n{\n\t \n\tif (!wdd->max_hw_heartbeat_ms && wdd->min_timeout > wdd->max_timeout) {\n\t\tpr_info(\"Invalid min and max timeout values, resetting to 0!\\n\");\n\t\twdd->min_timeout = 0;\n\t\twdd->max_timeout = 0;\n\t}\n}\n\n \nint watchdog_init_timeout(struct watchdog_device *wdd,\n\t\t\t\tunsigned int timeout_parm, struct device *dev)\n{\n\tconst char *dev_str = wdd->parent ? dev_name(wdd->parent) :\n\t\t\t      (const char *)wdd->info->identity;\n\tunsigned int t = 0;\n\tint ret = 0;\n\n\twatchdog_check_min_max_timeout(wdd);\n\n\t \n\tif (timeout_parm) {\n\t\tif (!watchdog_timeout_invalid(wdd, timeout_parm)) {\n\t\t\twdd->timeout = timeout_parm;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"%s: driver supplied timeout (%u) out of range\\n\",\n\t\t\tdev_str, timeout_parm);\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tif (dev && dev->of_node &&\n\t    of_property_read_u32(dev->of_node, \"timeout-sec\", &t) == 0) {\n\t\tif (t && !watchdog_timeout_invalid(wdd, t)) {\n\t\t\twdd->timeout = t;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"%s: DT supplied timeout (%u) out of range\\n\", dev_str, t);\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret < 0 && wdd->timeout)\n\t\tpr_warn(\"%s: falling back to default timeout (%u)\\n\", dev_str,\n\t\t\twdd->timeout);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(watchdog_init_timeout);\n\nstatic int watchdog_reboot_notifier(struct notifier_block *nb,\n\t\t\t\t    unsigned long code, void *data)\n{\n\tstruct watchdog_device *wdd;\n\n\twdd = container_of(nb, struct watchdog_device, reboot_nb);\n\tif (code == SYS_DOWN || code == SYS_HALT || code == SYS_POWER_OFF) {\n\t\tif (watchdog_hw_running(wdd)) {\n\t\t\tint ret;\n\n\t\t\tret = wdd->ops->stop(wdd);\n\t\t\ttrace_watchdog_stop(wdd, ret);\n\t\t\tif (ret)\n\t\t\t\treturn NOTIFY_BAD;\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int watchdog_restart_notifier(struct notifier_block *nb,\n\t\t\t\t     unsigned long action, void *data)\n{\n\tstruct watchdog_device *wdd = container_of(nb, struct watchdog_device,\n\t\t\t\t\t\t   restart_nb);\n\n\tint ret;\n\n\tret = wdd->ops->restart(wdd, action, data);\n\tif (ret)\n\t\treturn NOTIFY_BAD;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int watchdog_pm_notifier(struct notifier_block *nb, unsigned long mode,\n\t\t\t\tvoid *data)\n{\n\tstruct watchdog_device *wdd;\n\tint ret = 0;\n\n\twdd = container_of(nb, struct watchdog_device, pm_nb);\n\n\tswitch (mode) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\tret = watchdog_dev_suspend(wdd);\n\t\tbreak;\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\tcase PM_POST_SUSPEND:\n\t\tret = watchdog_dev_resume(wdd);\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn NOTIFY_BAD;\n\n\treturn NOTIFY_DONE;\n}\n\n \nvoid watchdog_set_restart_priority(struct watchdog_device *wdd, int priority)\n{\n\twdd->restart_nb.priority = priority;\n}\nEXPORT_SYMBOL_GPL(watchdog_set_restart_priority);\n\nstatic int __watchdog_register_device(struct watchdog_device *wdd)\n{\n\tint ret, id = -1;\n\n\tif (wdd == NULL || wdd->info == NULL || wdd->ops == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (!wdd->ops->start || (!wdd->ops->stop && !wdd->max_hw_heartbeat_ms))\n\t\treturn -EINVAL;\n\n\twatchdog_check_min_max_timeout(wdd);\n\n\t \n\n\t \n\tif (wdd->parent) {\n\t\tret = of_alias_get_id(wdd->parent->of_node, \"watchdog\");\n\t\tif (ret >= 0)\n\t\t\tid = ida_simple_get(&watchdog_ida, ret,\n\t\t\t\t\t    ret + 1, GFP_KERNEL);\n\t}\n\n\tif (id < 0)\n\t\tid = ida_simple_get(&watchdog_ida, 0, MAX_DOGS, GFP_KERNEL);\n\n\tif (id < 0)\n\t\treturn id;\n\twdd->id = id;\n\n\tret = watchdog_dev_register(wdd);\n\tif (ret) {\n\t\tida_simple_remove(&watchdog_ida, id);\n\t\tif (!(id == 0 && ret == -EBUSY))\n\t\t\treturn ret;\n\n\t\t \n\t\tid = ida_simple_get(&watchdog_ida, 1, MAX_DOGS, GFP_KERNEL);\n\t\tif (id < 0)\n\t\t\treturn id;\n\t\twdd->id = id;\n\n\t\tret = watchdog_dev_register(wdd);\n\t\tif (ret) {\n\t\t\tida_simple_remove(&watchdog_ida, id);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (stop_on_reboot != -1) {\n\t\tif (stop_on_reboot)\n\t\t\tset_bit(WDOG_STOP_ON_REBOOT, &wdd->status);\n\t\telse\n\t\t\tclear_bit(WDOG_STOP_ON_REBOOT, &wdd->status);\n\t}\n\n\tif (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status)) {\n\t\tif (!wdd->ops->stop)\n\t\t\tpr_warn(\"watchdog%d: stop_on_reboot not supported\\n\", wdd->id);\n\t\telse {\n\t\t\twdd->reboot_nb.notifier_call = watchdog_reboot_notifier;\n\n\t\t\tret = register_reboot_notifier(&wdd->reboot_nb);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"watchdog%d: Cannot register reboot notifier (%d)\\n\",\n\t\t\t\t\twdd->id, ret);\n\t\t\t\twatchdog_dev_unregister(wdd);\n\t\t\t\tida_simple_remove(&watchdog_ida, id);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (wdd->ops->restart) {\n\t\twdd->restart_nb.notifier_call = watchdog_restart_notifier;\n\n\t\tret = register_restart_handler(&wdd->restart_nb);\n\t\tif (ret)\n\t\t\tpr_warn(\"watchdog%d: Cannot register restart handler (%d)\\n\",\n\t\t\t\twdd->id, ret);\n\t}\n\n\tif (test_bit(WDOG_NO_PING_ON_SUSPEND, &wdd->status)) {\n\t\twdd->pm_nb.notifier_call = watchdog_pm_notifier;\n\n\t\tret = register_pm_notifier(&wdd->pm_nb);\n\t\tif (ret)\n\t\t\tpr_warn(\"watchdog%d: Cannot register pm handler (%d)\\n\",\n\t\t\t\twdd->id, ret);\n\t}\n\n\treturn 0;\n}\n\n \n\nint watchdog_register_device(struct watchdog_device *wdd)\n{\n\tconst char *dev_str;\n\tint ret = 0;\n\n\tmutex_lock(&wtd_deferred_reg_mutex);\n\tif (wtd_deferred_reg_done)\n\t\tret = __watchdog_register_device(wdd);\n\telse\n\t\twatchdog_deferred_registration_add(wdd);\n\tmutex_unlock(&wtd_deferred_reg_mutex);\n\n\tif (ret) {\n\t\tdev_str = wdd->parent ? dev_name(wdd->parent) :\n\t\t\t  (const char *)wdd->info->identity;\n\t\tpr_err(\"%s: failed to register watchdog device (err = %d)\\n\",\n\t\t\tdev_str, ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(watchdog_register_device);\n\nstatic void __watchdog_unregister_device(struct watchdog_device *wdd)\n{\n\tif (wdd == NULL)\n\t\treturn;\n\n\tif (wdd->ops->restart)\n\t\tunregister_restart_handler(&wdd->restart_nb);\n\n\tif (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status))\n\t\tunregister_reboot_notifier(&wdd->reboot_nb);\n\n\twatchdog_dev_unregister(wdd);\n\tida_simple_remove(&watchdog_ida, wdd->id);\n}\n\n \n\nvoid watchdog_unregister_device(struct watchdog_device *wdd)\n{\n\tmutex_lock(&wtd_deferred_reg_mutex);\n\tif (wtd_deferred_reg_done)\n\t\t__watchdog_unregister_device(wdd);\n\telse\n\t\twatchdog_deferred_registration_del(wdd);\n\tmutex_unlock(&wtd_deferred_reg_mutex);\n}\n\nEXPORT_SYMBOL_GPL(watchdog_unregister_device);\n\nstatic void devm_watchdog_unregister_device(struct device *dev, void *res)\n{\n\twatchdog_unregister_device(*(struct watchdog_device **)res);\n}\n\n \nint devm_watchdog_register_device(struct device *dev,\n\t\t\t\tstruct watchdog_device *wdd)\n{\n\tstruct watchdog_device **rcwdd;\n\tint ret;\n\n\trcwdd = devres_alloc(devm_watchdog_unregister_device, sizeof(*rcwdd),\n\t\t\t     GFP_KERNEL);\n\tif (!rcwdd)\n\t\treturn -ENOMEM;\n\n\tret = watchdog_register_device(wdd);\n\tif (!ret) {\n\t\t*rcwdd = wdd;\n\t\tdevres_add(dev, rcwdd);\n\t} else {\n\t\tdevres_free(rcwdd);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_watchdog_register_device);\n\nstatic int __init watchdog_deferred_registration(void)\n{\n\tmutex_lock(&wtd_deferred_reg_mutex);\n\twtd_deferred_reg_done = true;\n\twhile (!list_empty(&wtd_deferred_reg_list)) {\n\t\tstruct watchdog_device *wdd;\n\n\t\twdd = list_first_entry(&wtd_deferred_reg_list,\n\t\t\t\t       struct watchdog_device, deferred);\n\t\tlist_del(&wdd->deferred);\n\t\t__watchdog_register_device(wdd);\n\t}\n\tmutex_unlock(&wtd_deferred_reg_mutex);\n\treturn 0;\n}\n\nstatic int __init watchdog_init(void)\n{\n\tint err;\n\n\terr = watchdog_dev_init();\n\tif (err < 0)\n\t\treturn err;\n\n\twatchdog_deferred_registration();\n\treturn 0;\n}\n\nstatic void __exit watchdog_exit(void)\n{\n\twatchdog_dev_exit();\n\tida_destroy(&watchdog_ida);\n}\n\nsubsys_initcall_sync(watchdog_init);\nmodule_exit(watchdog_exit);\n\nMODULE_AUTHOR(\"Alan Cox <alan@lxorguk.ukuu.org.uk>\");\nMODULE_AUTHOR(\"Wim Van Sebroeck <wim@iguana.be>\");\nMODULE_DESCRIPTION(\"WatchDog Timer Driver Core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}