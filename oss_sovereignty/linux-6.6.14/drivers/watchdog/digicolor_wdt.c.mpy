{
  "module_name": "digicolor_wdt.c",
  "hash_id": "29775dac65b54d8c394e03266f02051ea8f2a9f7f76a4ef768f203535ec80b6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/digicolor_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n\n#define TIMER_A_CONTROL\t\t0\n#define TIMER_A_COUNT\t\t4\n\n#define TIMER_A_ENABLE_COUNT\tBIT(0)\n#define TIMER_A_ENABLE_WATCHDOG\tBIT(1)\n\nstruct dc_wdt {\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tspinlock_t\t\tlock;\n};\n\nstatic unsigned timeout;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds\");\n\nstatic void dc_wdt_set(struct dc_wdt *wdt, u32 ticks)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\n\twritel_relaxed(0, wdt->base + TIMER_A_CONTROL);\n\twritel_relaxed(ticks, wdt->base + TIMER_A_COUNT);\n\twritel_relaxed(TIMER_A_ENABLE_COUNT | TIMER_A_ENABLE_WATCHDOG,\n\t\t       wdt->base + TIMER_A_CONTROL);\n\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n}\n\nstatic int dc_wdt_restart(struct watchdog_device *wdog, unsigned long action,\n\t\t\t  void *data)\n{\n\tstruct dc_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\tdc_wdt_set(wdt, 1);\n\t \n\tmdelay(500);\n\n\treturn 0;\n}\n\nstatic int dc_wdt_start(struct watchdog_device *wdog)\n{\n\tstruct dc_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\tdc_wdt_set(wdt, wdog->timeout * clk_get_rate(wdt->clk));\n\n\treturn 0;\n}\n\nstatic int dc_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct dc_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\twritel_relaxed(0, wdt->base + TIMER_A_CONTROL);\n\n\treturn 0;\n}\n\nstatic int dc_wdt_set_timeout(struct watchdog_device *wdog, unsigned int t)\n{\n\tstruct dc_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\tdc_wdt_set(wdt, t * clk_get_rate(wdt->clk));\n\twdog->timeout = t;\n\n\treturn 0;\n}\n\nstatic unsigned int dc_wdt_get_timeleft(struct watchdog_device *wdog)\n{\n\tstruct dc_wdt *wdt = watchdog_get_drvdata(wdog);\n\tuint32_t count = readl_relaxed(wdt->base + TIMER_A_COUNT);\n\n\treturn count / clk_get_rate(wdt->clk);\n}\n\nstatic const struct watchdog_ops dc_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= dc_wdt_start,\n\t.stop\t\t= dc_wdt_stop,\n\t.set_timeout\t= dc_wdt_set_timeout,\n\t.get_timeleft\t= dc_wdt_get_timeleft,\n\t.restart        = dc_wdt_restart,\n};\n\nstatic const struct watchdog_info dc_wdt_info = {\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE\n\t\t\t| WDIOF_KEEPALIVEPING,\n\t.identity\t= \"Conexant Digicolor Watchdog\",\n};\n\nstatic struct watchdog_device dc_wdt_wdd = {\n\t.info\t\t= &dc_wdt_info,\n\t.ops\t\t= &dc_wdt_ops,\n\t.min_timeout\t= 1,\n};\n\nstatic int dc_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dc_wdt *wdt;\n\n\twdt = devm_kzalloc(dev, sizeof(struct dc_wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\twdt->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(wdt->clk))\n\t\treturn PTR_ERR(wdt->clk);\n\tdc_wdt_wdd.max_timeout = U32_MAX / clk_get_rate(wdt->clk);\n\tdc_wdt_wdd.timeout = dc_wdt_wdd.max_timeout;\n\tdc_wdt_wdd.parent = dev;\n\n\tspin_lock_init(&wdt->lock);\n\n\twatchdog_set_drvdata(&dc_wdt_wdd, wdt);\n\twatchdog_set_restart_priority(&dc_wdt_wdd, 128);\n\twatchdog_init_timeout(&dc_wdt_wdd, timeout, dev);\n\twatchdog_stop_on_reboot(&dc_wdt_wdd);\n\treturn devm_watchdog_register_device(dev, &dc_wdt_wdd);\n}\n\nstatic const struct of_device_id dc_wdt_of_match[] = {\n\t{ .compatible = \"cnxt,cx92755-wdt\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dc_wdt_of_match);\n\nstatic struct platform_driver dc_wdt_driver = {\n\t.probe\t\t= dc_wdt_probe,\n\t.driver = {\n\t\t.name =\t\t\"digicolor-wdt\",\n\t\t.of_match_table = dc_wdt_of_match,\n\t},\n};\nmodule_platform_driver(dc_wdt_driver);\n\nMODULE_AUTHOR(\"Baruch Siach <baruch@tkos.co.il>\");\nMODULE_DESCRIPTION(\"Driver for Conexant Digicolor watchdog timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}