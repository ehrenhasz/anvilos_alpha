{
  "module_name": "dw_wdt.c",
  "hash_id": "df957c6711307466850c0480256e71cfddcdb8aaa7fae29616936b149b550d0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/dw_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/reset.h>\n#include <linux/watchdog.h>\n\n#define WDOG_CONTROL_REG_OFFSET\t\t    0x00\n#define WDOG_CONTROL_REG_WDT_EN_MASK\t    0x01\n#define WDOG_CONTROL_REG_RESP_MODE_MASK\t    0x02\n#define WDOG_TIMEOUT_RANGE_REG_OFFSET\t    0x04\n#define WDOG_TIMEOUT_RANGE_TOPINIT_SHIFT    4\n#define WDOG_CURRENT_COUNT_REG_OFFSET\t    0x08\n#define WDOG_COUNTER_RESTART_REG_OFFSET     0x0c\n#define WDOG_COUNTER_RESTART_KICK_VALUE\t    0x76\n#define WDOG_INTERRUPT_STATUS_REG_OFFSET    0x10\n#define WDOG_INTERRUPT_CLEAR_REG_OFFSET     0x14\n#define WDOG_COMP_PARAMS_5_REG_OFFSET       0xe4\n#define WDOG_COMP_PARAMS_4_REG_OFFSET       0xe8\n#define WDOG_COMP_PARAMS_3_REG_OFFSET       0xec\n#define WDOG_COMP_PARAMS_2_REG_OFFSET       0xf0\n#define WDOG_COMP_PARAMS_1_REG_OFFSET       0xf4\n#define WDOG_COMP_PARAMS_1_USE_FIX_TOP      BIT(6)\n#define WDOG_COMP_VERSION_REG_OFFSET        0xf8\n#define WDOG_COMP_TYPE_REG_OFFSET           0xfc\n\n \n#define DW_WDT_NUM_TOPS\t\t16\n#define DW_WDT_FIX_TOP(_idx)\t(1U << (16 + _idx))\n\n#define DW_WDT_DEFAULT_SECONDS\t30\n\nstatic const u32 dw_wdt_fix_tops[DW_WDT_NUM_TOPS] = {\n\tDW_WDT_FIX_TOP(0), DW_WDT_FIX_TOP(1), DW_WDT_FIX_TOP(2),\n\tDW_WDT_FIX_TOP(3), DW_WDT_FIX_TOP(4), DW_WDT_FIX_TOP(5),\n\tDW_WDT_FIX_TOP(6), DW_WDT_FIX_TOP(7), DW_WDT_FIX_TOP(8),\n\tDW_WDT_FIX_TOP(9), DW_WDT_FIX_TOP(10), DW_WDT_FIX_TOP(11),\n\tDW_WDT_FIX_TOP(12), DW_WDT_FIX_TOP(13), DW_WDT_FIX_TOP(14),\n\tDW_WDT_FIX_TOP(15)\n};\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\t \"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nenum dw_wdt_rmod {\n\tDW_WDT_RMOD_RESET = 1,\n\tDW_WDT_RMOD_IRQ = 2\n};\n\nstruct dw_wdt_timeout {\n\tu32 top_val;\n\tunsigned int sec;\n\tunsigned int msec;\n};\n\nstruct dw_wdt {\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk;\n\tstruct clk\t\t*pclk;\n\tunsigned long\t\trate;\n\tenum dw_wdt_rmod\trmod;\n\tstruct dw_wdt_timeout\ttimeouts[DW_WDT_NUM_TOPS];\n\tstruct watchdog_device\twdd;\n\tstruct reset_control\t*rst;\n\t \n\tu32\t\t\tcontrol;\n\tu32\t\t\ttimeout;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry\t\t*dbgfs_dir;\n#endif\n};\n\n#define to_dw_wdt(wdd)\tcontainer_of(wdd, struct dw_wdt, wdd)\n\nstatic inline int dw_wdt_is_enabled(struct dw_wdt *dw_wdt)\n{\n\treturn readl(dw_wdt->regs + WDOG_CONTROL_REG_OFFSET) &\n\t\tWDOG_CONTROL_REG_WDT_EN_MASK;\n}\n\nstatic void dw_wdt_update_mode(struct dw_wdt *dw_wdt, enum dw_wdt_rmod rmod)\n{\n\tu32 val;\n\n\tval = readl(dw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\n\tif (rmod == DW_WDT_RMOD_IRQ)\n\t\tval |= WDOG_CONTROL_REG_RESP_MODE_MASK;\n\telse\n\t\tval &= ~WDOG_CONTROL_REG_RESP_MODE_MASK;\n\twritel(val, dw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\n\n\tdw_wdt->rmod = rmod;\n}\n\nstatic unsigned int dw_wdt_find_best_top(struct dw_wdt *dw_wdt,\n\t\t\t\t\t unsigned int timeout, u32 *top_val)\n{\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < DW_WDT_NUM_TOPS; ++idx) {\n\t\tif (dw_wdt->timeouts[idx].sec >= timeout)\n\t\t\tbreak;\n\t}\n\n\tif (idx == DW_WDT_NUM_TOPS)\n\t\t--idx;\n\n\t*top_val = dw_wdt->timeouts[idx].top_val;\n\n\treturn dw_wdt->timeouts[idx].sec;\n}\n\nstatic unsigned int dw_wdt_get_min_timeout(struct dw_wdt *dw_wdt)\n{\n\tint idx;\n\n\t \n\tfor (idx = 0; idx < DW_WDT_NUM_TOPS; ++idx) {\n\t\tif (dw_wdt->timeouts[idx].sec)\n\t\t\tbreak;\n\t}\n\n\treturn dw_wdt->timeouts[idx].sec;\n}\n\nstatic unsigned int dw_wdt_get_max_timeout_ms(struct dw_wdt *dw_wdt)\n{\n\tstruct dw_wdt_timeout *timeout = &dw_wdt->timeouts[DW_WDT_NUM_TOPS - 1];\n\tu64 msec;\n\n\tmsec = (u64)timeout->sec * MSEC_PER_SEC + timeout->msec;\n\n\treturn msec < UINT_MAX ? msec : UINT_MAX;\n}\n\nstatic unsigned int dw_wdt_get_timeout(struct dw_wdt *dw_wdt)\n{\n\tint top_val = readl(dw_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET) & 0xF;\n\tint idx;\n\n\tfor (idx = 0; idx < DW_WDT_NUM_TOPS; ++idx) {\n\t\tif (dw_wdt->timeouts[idx].top_val == top_val)\n\t\t\tbreak;\n\t}\n\n\t \n\treturn dw_wdt->timeouts[idx].sec * dw_wdt->rmod;\n}\n\nstatic int dw_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\n\n\twritel(WDOG_COUNTER_RESTART_KICK_VALUE, dw_wdt->regs +\n\t       WDOG_COUNTER_RESTART_REG_OFFSET);\n\n\treturn 0;\n}\n\nstatic int dw_wdt_set_timeout(struct watchdog_device *wdd, unsigned int top_s)\n{\n\tstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\n\tunsigned int timeout;\n\tu32 top_val;\n\n\t \n\ttimeout = dw_wdt_find_best_top(dw_wdt, DIV_ROUND_UP(top_s, dw_wdt->rmod),\n\t\t\t\t       &top_val);\n\tif (dw_wdt->rmod == DW_WDT_RMOD_IRQ)\n\t\twdd->pretimeout = timeout;\n\telse\n\t\twdd->pretimeout = 0;\n\n\t \n\twritel(top_val | top_val << WDOG_TIMEOUT_RANGE_TOPINIT_SHIFT,\n\t       dw_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);\n\n\t \n\tif (watchdog_active(wdd))\n\t\tdw_wdt_ping(wdd);\n\n\t \n\tif (top_s * 1000 <= wdd->max_hw_heartbeat_ms)\n\t\twdd->timeout = timeout * dw_wdt->rmod;\n\telse\n\t\twdd->timeout = top_s;\n\n\treturn 0;\n}\n\nstatic int dw_wdt_set_pretimeout(struct watchdog_device *wdd, unsigned int req)\n{\n\tstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\n\n\t \n\tdw_wdt_update_mode(dw_wdt, req ? DW_WDT_RMOD_IRQ : DW_WDT_RMOD_RESET);\n\tdw_wdt_set_timeout(wdd, wdd->timeout);\n\n\treturn 0;\n}\n\nstatic void dw_wdt_arm_system_reset(struct dw_wdt *dw_wdt)\n{\n\tu32 val = readl(dw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\n\n\t \n\tif (dw_wdt->rmod == DW_WDT_RMOD_IRQ)\n\t\tval |= WDOG_CONTROL_REG_RESP_MODE_MASK;\n\telse\n\t\tval &= ~WDOG_CONTROL_REG_RESP_MODE_MASK;\n\t \n\tval |= WDOG_CONTROL_REG_WDT_EN_MASK;\n\twritel(val, dw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\n}\n\nstatic int dw_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\n\n\tdw_wdt_set_timeout(wdd, wdd->timeout);\n\tdw_wdt_ping(&dw_wdt->wdd);\n\tdw_wdt_arm_system_reset(dw_wdt);\n\n\treturn 0;\n}\n\nstatic int dw_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\n\n\tif (!dw_wdt->rst) {\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t\treturn 0;\n\t}\n\n\treset_control_assert(dw_wdt->rst);\n\treset_control_deassert(dw_wdt->rst);\n\n\treturn 0;\n}\n\nstatic int dw_wdt_restart(struct watchdog_device *wdd,\n\t\t\t  unsigned long action, void *data)\n{\n\tstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\n\n\twritel(0, dw_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);\n\tdw_wdt_update_mode(dw_wdt, DW_WDT_RMOD_RESET);\n\tif (dw_wdt_is_enabled(dw_wdt))\n\t\twritel(WDOG_COUNTER_RESTART_KICK_VALUE,\n\t\t       dw_wdt->regs + WDOG_COUNTER_RESTART_REG_OFFSET);\n\telse\n\t\tdw_wdt_arm_system_reset(dw_wdt);\n\n\t \n\tmdelay(500);\n\n\treturn 0;\n}\n\nstatic unsigned int dw_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct dw_wdt *dw_wdt = to_dw_wdt(wdd);\n\tunsigned int sec;\n\tu32 val;\n\n\tval = readl(dw_wdt->regs + WDOG_CURRENT_COUNT_REG_OFFSET);\n\tsec = val / dw_wdt->rate;\n\n\tif (dw_wdt->rmod == DW_WDT_RMOD_IRQ) {\n\t\tval = readl(dw_wdt->regs + WDOG_INTERRUPT_STATUS_REG_OFFSET);\n\t\tif (!val)\n\t\t\tsec += wdd->pretimeout;\n\t}\n\n\treturn sec;\n}\n\nstatic const struct watchdog_info dw_wdt_ident = {\n\t.options\t= WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_MAGICCLOSE,\n\t.identity\t= \"Synopsys DesignWare Watchdog\",\n};\n\nstatic const struct watchdog_info dw_wdt_pt_ident = {\n\t.options\t= WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_PRETIMEOUT | WDIOF_MAGICCLOSE,\n\t.identity\t= \"Synopsys DesignWare Watchdog\",\n};\n\nstatic const struct watchdog_ops dw_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= dw_wdt_start,\n\t.stop\t\t= dw_wdt_stop,\n\t.ping\t\t= dw_wdt_ping,\n\t.set_timeout\t= dw_wdt_set_timeout,\n\t.set_pretimeout\t= dw_wdt_set_pretimeout,\n\t.get_timeleft\t= dw_wdt_get_timeleft,\n\t.restart\t= dw_wdt_restart,\n};\n\nstatic irqreturn_t dw_wdt_irq(int irq, void *devid)\n{\n\tstruct dw_wdt *dw_wdt = devid;\n\tu32 val;\n\n\t \n\tval = readl(dw_wdt->regs + WDOG_INTERRUPT_STATUS_REG_OFFSET);\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\twatchdog_notify_pretimeout(&dw_wdt->wdd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dw_wdt_suspend(struct device *dev)\n{\n\tstruct dw_wdt *dw_wdt = dev_get_drvdata(dev);\n\n\tdw_wdt->control = readl(dw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\n\tdw_wdt->timeout = readl(dw_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);\n\n\tclk_disable_unprepare(dw_wdt->pclk);\n\tclk_disable_unprepare(dw_wdt->clk);\n\n\treturn 0;\n}\n\nstatic int dw_wdt_resume(struct device *dev)\n{\n\tstruct dw_wdt *dw_wdt = dev_get_drvdata(dev);\n\tint err = clk_prepare_enable(dw_wdt->clk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = clk_prepare_enable(dw_wdt->pclk);\n\tif (err) {\n\t\tclk_disable_unprepare(dw_wdt->clk);\n\t\treturn err;\n\t}\n\n\twritel(dw_wdt->timeout, dw_wdt->regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);\n\twritel(dw_wdt->control, dw_wdt->regs + WDOG_CONTROL_REG_OFFSET);\n\n\tdw_wdt_ping(&dw_wdt->wdd);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(dw_wdt_pm_ops, dw_wdt_suspend, dw_wdt_resume);\n\n \n\nstatic void dw_wdt_handle_tops(struct dw_wdt *dw_wdt, const u32 *tops)\n{\n\tstruct dw_wdt_timeout tout, *dst;\n\tint val, tidx;\n\tu64 msec;\n\n\t \n\tfor (val = 0; val < DW_WDT_NUM_TOPS; ++val) {\n\t\ttout.top_val = val;\n\t\ttout.sec = tops[val] / dw_wdt->rate;\n\t\tmsec = (u64)tops[val] * MSEC_PER_SEC;\n\t\tdo_div(msec, dw_wdt->rate);\n\t\ttout.msec = msec - ((u64)tout.sec * MSEC_PER_SEC);\n\n\t\t \n\t\tfor (tidx = 0; tidx < val; ++tidx) {\n\t\t\tdst = &dw_wdt->timeouts[tidx];\n\t\t\tif (tout.sec > dst->sec || (tout.sec == dst->sec &&\n\t\t\t    tout.msec >= dst->msec))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tswap(*dst, tout);\n\t\t}\n\n\t\tdw_wdt->timeouts[val] = tout;\n\t}\n}\n\nstatic int dw_wdt_init_timeouts(struct dw_wdt *dw_wdt, struct device *dev)\n{\n\tu32 data, of_tops[DW_WDT_NUM_TOPS];\n\tconst u32 *tops;\n\tint ret;\n\n\t \n\tdata = readl(dw_wdt->regs + WDOG_COMP_PARAMS_1_REG_OFFSET);\n\tif (data & WDOG_COMP_PARAMS_1_USE_FIX_TOP) {\n\t\ttops = dw_wdt_fix_tops;\n\t} else {\n\t\tret = of_property_read_variable_u32_array(dev_of_node(dev),\n\t\t\t\"snps,watchdog-tops\", of_tops, DW_WDT_NUM_TOPS,\n\t\t\tDW_WDT_NUM_TOPS);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(dev, \"No valid TOPs array specified\\n\");\n\t\t\ttops = dw_wdt_fix_tops;\n\t\t} else {\n\t\t\ttops = of_tops;\n\t\t}\n\t}\n\n\t \n\tdw_wdt_handle_tops(dw_wdt, tops);\n\tif (!dw_wdt->timeouts[DW_WDT_NUM_TOPS - 1].sec) {\n\t\tdev_err(dev, \"No any valid TOP detected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\n\n#define DW_WDT_DBGFS_REG(_name, _off) \\\n{\t\t\t\t      \\\n\t.name = _name,\t\t      \\\n\t.offset = _off\t\t      \\\n}\n\nstatic const struct debugfs_reg32 dw_wdt_dbgfs_regs[] = {\n\tDW_WDT_DBGFS_REG(\"cr\", WDOG_CONTROL_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"torr\", WDOG_TIMEOUT_RANGE_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"ccvr\", WDOG_CURRENT_COUNT_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"crr\", WDOG_COUNTER_RESTART_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"stat\", WDOG_INTERRUPT_STATUS_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"param5\", WDOG_COMP_PARAMS_5_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"param4\", WDOG_COMP_PARAMS_4_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"param3\", WDOG_COMP_PARAMS_3_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"param2\", WDOG_COMP_PARAMS_2_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"param1\", WDOG_COMP_PARAMS_1_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"version\", WDOG_COMP_VERSION_REG_OFFSET),\n\tDW_WDT_DBGFS_REG(\"type\", WDOG_COMP_TYPE_REG_OFFSET)\n};\n\nstatic void dw_wdt_dbgfs_init(struct dw_wdt *dw_wdt)\n{\n\tstruct device *dev = dw_wdt->wdd.parent;\n\tstruct debugfs_regset32 *regset;\n\n\tregset = devm_kzalloc(dev, sizeof(*regset), GFP_KERNEL);\n\tif (!regset)\n\t\treturn;\n\n\tregset->regs = dw_wdt_dbgfs_regs;\n\tregset->nregs = ARRAY_SIZE(dw_wdt_dbgfs_regs);\n\tregset->base = dw_wdt->regs;\n\n\tdw_wdt->dbgfs_dir = debugfs_create_dir(dev_name(dev), NULL);\n\n\tdebugfs_create_regset32(\"registers\", 0444, dw_wdt->dbgfs_dir, regset);\n}\n\nstatic void dw_wdt_dbgfs_clear(struct dw_wdt *dw_wdt)\n{\n\tdebugfs_remove_recursive(dw_wdt->dbgfs_dir);\n}\n\n#else  \n\nstatic void dw_wdt_dbgfs_init(struct dw_wdt *dw_wdt) {}\nstatic void dw_wdt_dbgfs_clear(struct dw_wdt *dw_wdt) {}\n\n#endif  \n\nstatic int dw_wdt_drv_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct dw_wdt *dw_wdt;\n\tint ret;\n\n\tdw_wdt = devm_kzalloc(dev, sizeof(*dw_wdt), GFP_KERNEL);\n\tif (!dw_wdt)\n\t\treturn -ENOMEM;\n\n\tdw_wdt->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dw_wdt->regs))\n\t\treturn PTR_ERR(dw_wdt->regs);\n\n\t \n\tdw_wdt->clk = devm_clk_get_enabled(dev, \"tclk\");\n\tif (IS_ERR(dw_wdt->clk)) {\n\t\tdw_wdt->clk = devm_clk_get_enabled(dev, NULL);\n\t\tif (IS_ERR(dw_wdt->clk))\n\t\t\treturn PTR_ERR(dw_wdt->clk);\n\t}\n\n\tdw_wdt->rate = clk_get_rate(dw_wdt->clk);\n\tif (dw_wdt->rate == 0)\n\t\treturn -EINVAL;\n\n\t \n\tdw_wdt->pclk = devm_clk_get_optional_enabled(dev, \"pclk\");\n\tif (IS_ERR(dw_wdt->pclk))\n\t\treturn PTR_ERR(dw_wdt->pclk);\n\n\tdw_wdt->rst = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\n\tif (IS_ERR(dw_wdt->rst))\n\t\treturn PTR_ERR(dw_wdt->rst);\n\n\t \n\tdw_wdt_update_mode(dw_wdt, DW_WDT_RMOD_RESET);\n\n\t \n\tret = platform_get_irq_optional(pdev, 0);\n\tif (ret > 0) {\n\t\tret = devm_request_irq(dev, ret, dw_wdt_irq,\n\t\t\t\t       IRQF_SHARED | IRQF_TRIGGER_RISING,\n\t\t\t\t       pdev->name, dw_wdt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdw_wdt->wdd.info = &dw_wdt_pt_ident;\n\t} else {\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\tdw_wdt->wdd.info = &dw_wdt_ident;\n\t}\n\n\treset_control_deassert(dw_wdt->rst);\n\n\tret = dw_wdt_init_timeouts(dw_wdt, dev);\n\tif (ret)\n\t\tgoto out_assert_rst;\n\n\twdd = &dw_wdt->wdd;\n\twdd->ops = &dw_wdt_ops;\n\twdd->min_timeout = dw_wdt_get_min_timeout(dw_wdt);\n\twdd->max_hw_heartbeat_ms = dw_wdt_get_max_timeout_ms(dw_wdt);\n\twdd->parent = dev;\n\n\twatchdog_set_drvdata(wdd, dw_wdt);\n\twatchdog_set_nowayout(wdd, nowayout);\n\twatchdog_init_timeout(wdd, 0, dev);\n\n\t \n\tif (dw_wdt_is_enabled(dw_wdt)) {\n\t\twdd->timeout = dw_wdt_get_timeout(dw_wdt);\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t} else {\n\t\twdd->timeout = DW_WDT_DEFAULT_SECONDS;\n\t\twatchdog_init_timeout(wdd, 0, dev);\n\t}\n\n\tplatform_set_drvdata(pdev, dw_wdt);\n\n\twatchdog_set_restart_priority(wdd, 128);\n\twatchdog_stop_on_reboot(wdd);\n\n\tret = watchdog_register_device(wdd);\n\tif (ret)\n\t\tgoto out_assert_rst;\n\n\tdw_wdt_dbgfs_init(dw_wdt);\n\n\treturn 0;\n\nout_assert_rst:\n\treset_control_assert(dw_wdt->rst);\n\treturn ret;\n}\n\nstatic void dw_wdt_drv_remove(struct platform_device *pdev)\n{\n\tstruct dw_wdt *dw_wdt = platform_get_drvdata(pdev);\n\n\tdw_wdt_dbgfs_clear(dw_wdt);\n\n\twatchdog_unregister_device(&dw_wdt->wdd);\n\treset_control_assert(dw_wdt->rst);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id dw_wdt_of_match[] = {\n\t{ .compatible = \"snps,dw-wdt\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dw_wdt_of_match);\n#endif\n\nstatic struct platform_driver dw_wdt_driver = {\n\t.probe\t\t= dw_wdt_drv_probe,\n\t.remove_new\t= dw_wdt_drv_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"dw_wdt\",\n\t\t.of_match_table = of_match_ptr(dw_wdt_of_match),\n\t\t.pm\t= pm_sleep_ptr(&dw_wdt_pm_ops),\n\t},\n};\n\nmodule_platform_driver(dw_wdt_driver);\n\nMODULE_AUTHOR(\"Jamie Iles\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}