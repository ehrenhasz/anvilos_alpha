{
  "module_name": "mtx-1_wdt.c",
  "hash_id": "8888c299d63f0413cdb240e45f5ba64fef44222462f5fdae9ce2d81fad4751ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/mtx-1_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/timer.h>\n#include <linux/completion.h>\n#include <linux/jiffies.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/gpio/consumer.h>\n\n#define MTX1_WDT_INTERVAL\t(5 * HZ)\n\nstatic int ticks = 100 * HZ;\n\nstatic struct {\n\tstruct completion stop;\n\tspinlock_t lock;\n\tint running;\n\tstruct timer_list timer;\n\tint queue;\n\tint default_ticks;\n\tunsigned long inuse;\n\tstruct gpio_desc *gpiod;\n\tunsigned int gstate;\n} mtx1_wdt_device;\n\nstatic void mtx1_wdt_trigger(struct timer_list *unused)\n{\n\tspin_lock(&mtx1_wdt_device.lock);\n\tif (mtx1_wdt_device.running)\n\t\tticks--;\n\n\t \n\tmtx1_wdt_device.gstate = !mtx1_wdt_device.gstate;\n\tgpiod_set_value(mtx1_wdt_device.gpiod, mtx1_wdt_device.gstate);\n\n\tif (mtx1_wdt_device.queue && ticks)\n\t\tmod_timer(&mtx1_wdt_device.timer, jiffies + MTX1_WDT_INTERVAL);\n\telse\n\t\tcomplete(&mtx1_wdt_device.stop);\n\tspin_unlock(&mtx1_wdt_device.lock);\n}\n\nstatic void mtx1_wdt_reset(void)\n{\n\tticks = mtx1_wdt_device.default_ticks;\n}\n\n\nstatic void mtx1_wdt_start(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtx1_wdt_device.lock, flags);\n\tif (!mtx1_wdt_device.queue) {\n\t\tmtx1_wdt_device.queue = 1;\n\t\tmtx1_wdt_device.gstate = 1;\n\t\tgpiod_set_value(mtx1_wdt_device.gpiod, 1);\n\t\tmod_timer(&mtx1_wdt_device.timer, jiffies + MTX1_WDT_INTERVAL);\n\t}\n\tmtx1_wdt_device.running++;\n\tspin_unlock_irqrestore(&mtx1_wdt_device.lock, flags);\n}\n\nstatic int mtx1_wdt_stop(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtx1_wdt_device.lock, flags);\n\tif (mtx1_wdt_device.queue) {\n\t\tmtx1_wdt_device.queue = 0;\n\t\tmtx1_wdt_device.gstate = 0;\n\t\tgpiod_set_value(mtx1_wdt_device.gpiod, 0);\n\t}\n\tticks = mtx1_wdt_device.default_ticks;\n\tspin_unlock_irqrestore(&mtx1_wdt_device.lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int mtx1_wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &mtx1_wdt_device.inuse))\n\t\treturn -EBUSY;\n\treturn stream_open(inode, file);\n}\n\n\nstatic int mtx1_wdt_release(struct inode *inode, struct file *file)\n{\n\tclear_bit(0, &mtx1_wdt_device.inuse);\n\treturn 0;\n}\n\nstatic long mtx1_wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = (int __user *)argp;\n\tunsigned int value;\n\tstatic const struct watchdog_info ident = {\n\t\t.options = WDIOF_CARDRESET,\n\t\t.identity = \"MTX-1 WDT\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tput_user(0, p);\n\t\tbreak;\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(value, p))\n\t\t\treturn -EFAULT;\n\t\tif (value & WDIOS_ENABLECARD)\n\t\t\tmtx1_wdt_start();\n\t\telse if (value & WDIOS_DISABLECARD)\n\t\t\tmtx1_wdt_stop();\n\t\telse\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\tcase WDIOC_KEEPALIVE:\n\t\tmtx1_wdt_reset();\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\n\nstatic ssize_t mtx1_wdt_write(struct file *file, const char *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tif (!count)\n\t\treturn -EIO;\n\tmtx1_wdt_reset();\n\treturn count;\n}\n\nstatic const struct file_operations mtx1_wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl\t= mtx1_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= mtx1_wdt_open,\n\t.write\t\t= mtx1_wdt_write,\n\t.release\t= mtx1_wdt_release,\n};\n\n\nstatic struct miscdevice mtx1_wdt_misc = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &mtx1_wdt_fops,\n};\n\n\nstatic int mtx1_wdt_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tmtx1_wdt_device.gpiod = devm_gpiod_get(&pdev->dev,\n\t\t\t\t\t       NULL, GPIOD_OUT_HIGH);\n\tif (IS_ERR(mtx1_wdt_device.gpiod)) {\n\t\tdev_err(&pdev->dev, \"failed to request gpio\");\n\t\treturn PTR_ERR(mtx1_wdt_device.gpiod);\n\t}\n\n\tspin_lock_init(&mtx1_wdt_device.lock);\n\tinit_completion(&mtx1_wdt_device.stop);\n\tmtx1_wdt_device.queue = 0;\n\tclear_bit(0, &mtx1_wdt_device.inuse);\n\ttimer_setup(&mtx1_wdt_device.timer, mtx1_wdt_trigger, 0);\n\tmtx1_wdt_device.default_ticks = ticks;\n\n\tret = misc_register(&mtx1_wdt_misc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register\\n\");\n\t\treturn ret;\n\t}\n\tmtx1_wdt_start();\n\tdev_info(&pdev->dev, \"MTX-1 Watchdog driver\\n\");\n\treturn 0;\n}\n\nstatic void mtx1_wdt_remove(struct platform_device *pdev)\n{\n\t \n\tif (mtx1_wdt_device.queue) {\n\t\tmtx1_wdt_device.queue = 0;\n\t\twait_for_completion(&mtx1_wdt_device.stop);\n\t}\n\n\tmisc_deregister(&mtx1_wdt_misc);\n}\n\nstatic struct platform_driver mtx1_wdt_driver = {\n\t.probe = mtx1_wdt_probe,\n\t.remove_new = mtx1_wdt_remove,\n\t.driver.name = \"mtx1-wdt\",\n\t.driver.owner = THIS_MODULE,\n};\n\nmodule_platform_driver(mtx1_wdt_driver);\n\nMODULE_AUTHOR(\"Michael Stickel, Florian Fainelli\");\nMODULE_DESCRIPTION(\"Driver for the MTX-1 watchdog\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mtx1-wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}