{
  "module_name": "armada_37xx_wdt.c",
  "hash_id": "7dfac8069705e5a818077b7cc77801b360fb2bfb9238910c0f27921b2ffebc6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/armada_37xx_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n \n\n#define CNTR_ID_RETRIGGER\t\t0\n#define CNTR_ID_WDOG\t\t\t1\n\n \n#define WDT_TIMER_SELECT\t\t0x64\n#define WDT_TIMER_SELECT_MASK\t\t0xf\n#define WDT_TIMER_SELECT_VAL\t\tBIT(CNTR_ID_WDOG)\n\n \n#define CNTR_CTRL(id)\t\t\t((id) * 0x10)\n#define CNTR_CTRL_ENABLE\t\t0x0001\n#define CNTR_CTRL_ACTIVE\t\t0x0002\n#define CNTR_CTRL_MODE_MASK\t\t0x000c\n#define CNTR_CTRL_MODE_ONESHOT\t\t0x0000\n#define CNTR_CTRL_MODE_HWSIG\t\t0x000c\n#define CNTR_CTRL_TRIG_SRC_MASK\t\t0x00f0\n#define CNTR_CTRL_TRIG_SRC_PREV_CNTR\t0x0050\n#define CNTR_CTRL_PRESCALE_MASK\t\t0xff00\n#define CNTR_CTRL_PRESCALE_MIN\t\t2\n#define CNTR_CTRL_PRESCALE_SHIFT\t8\n\n#define CNTR_COUNT_LOW(id)\t\t(CNTR_CTRL(id) + 0x4)\n#define CNTR_COUNT_HIGH(id)\t\t(CNTR_CTRL(id) + 0x8)\n\n#define WATCHDOG_TIMEOUT\t\t120\n\nstatic unsigned int timeout;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t   __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct armada_37xx_watchdog {\n\tstruct watchdog_device wdt;\n\tstruct regmap *cpu_misc;\n\tvoid __iomem *reg;\n\tu64 timeout;  \n\tunsigned long clk_rate;\n\tstruct clk *clk;\n};\n\nstatic u64 get_counter_value(struct armada_37xx_watchdog *dev, int id)\n{\n\tu64 val;\n\n\t \n\tval = readl(dev->reg + CNTR_COUNT_LOW(id));\n\tval |= ((u64)readl(dev->reg + CNTR_COUNT_HIGH(id))) << 32;\n\n\treturn val;\n}\n\nstatic void set_counter_value(struct armada_37xx_watchdog *dev, int id, u64 val)\n{\n\twritel(val & 0xffffffff, dev->reg + CNTR_COUNT_LOW(id));\n\twritel(val >> 32, dev->reg + CNTR_COUNT_HIGH(id));\n}\n\nstatic void counter_enable(struct armada_37xx_watchdog *dev, int id)\n{\n\tu32 reg;\n\n\treg = readl(dev->reg + CNTR_CTRL(id));\n\treg |= CNTR_CTRL_ENABLE;\n\twritel(reg, dev->reg + CNTR_CTRL(id));\n}\n\nstatic void counter_disable(struct armada_37xx_watchdog *dev, int id)\n{\n\tu32 reg;\n\n\treg = readl(dev->reg + CNTR_CTRL(id));\n\treg &= ~CNTR_CTRL_ENABLE;\n\twritel(reg, dev->reg + CNTR_CTRL(id));\n}\n\nstatic void init_counter(struct armada_37xx_watchdog *dev, int id, u32 mode,\n\t\t\t u32 trig_src)\n{\n\tu32 reg;\n\n\treg = readl(dev->reg + CNTR_CTRL(id));\n\n\treg &= ~(CNTR_CTRL_MODE_MASK | CNTR_CTRL_PRESCALE_MASK |\n\t\t CNTR_CTRL_TRIG_SRC_MASK);\n\n\t \n\treg |= mode & CNTR_CTRL_MODE_MASK;\n\n\t \n\treg |= CNTR_CTRL_PRESCALE_MIN << CNTR_CTRL_PRESCALE_SHIFT;\n\n\t \n\treg |= trig_src & CNTR_CTRL_TRIG_SRC_MASK;\n\n\twritel(reg, dev->reg + CNTR_CTRL(id));\n}\n\nstatic int armada_37xx_wdt_ping(struct watchdog_device *wdt)\n{\n\tstruct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);\n\n\t \n\tcounter_disable(dev, CNTR_ID_RETRIGGER);\n\tcounter_enable(dev, CNTR_ID_RETRIGGER);\n\n\treturn 0;\n}\n\nstatic unsigned int armada_37xx_wdt_get_timeleft(struct watchdog_device *wdt)\n{\n\tstruct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);\n\tu64 res;\n\n\tres = get_counter_value(dev, CNTR_ID_WDOG) * CNTR_CTRL_PRESCALE_MIN;\n\tdo_div(res, dev->clk_rate);\n\n\treturn res;\n}\n\nstatic int armada_37xx_wdt_set_timeout(struct watchdog_device *wdt,\n\t\t\t\t       unsigned int timeout)\n{\n\tstruct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);\n\n\twdt->timeout = timeout;\n\n\t \n\tdev->timeout = (u64)dev->clk_rate * timeout;\n\tdo_div(dev->timeout, CNTR_CTRL_PRESCALE_MIN);\n\n\tset_counter_value(dev, CNTR_ID_WDOG, dev->timeout);\n\n\treturn 0;\n}\n\nstatic bool armada_37xx_wdt_is_running(struct armada_37xx_watchdog *dev)\n{\n\tu32 reg;\n\n\tregmap_read(dev->cpu_misc, WDT_TIMER_SELECT, &reg);\n\tif ((reg & WDT_TIMER_SELECT_MASK) != WDT_TIMER_SELECT_VAL)\n\t\treturn false;\n\n\treg = readl(dev->reg + CNTR_CTRL(CNTR_ID_WDOG));\n\treturn !!(reg & CNTR_CTRL_ACTIVE);\n}\n\nstatic int armada_37xx_wdt_start(struct watchdog_device *wdt)\n{\n\tstruct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);\n\n\t \n\tregmap_write(dev->cpu_misc, WDT_TIMER_SELECT, WDT_TIMER_SELECT_VAL);\n\n\t \n\tinit_counter(dev, CNTR_ID_RETRIGGER, CNTR_CTRL_MODE_ONESHOT, 0);\n\tset_counter_value(dev, CNTR_ID_RETRIGGER, 0);\n\n\t \n\tinit_counter(dev, CNTR_ID_WDOG, CNTR_CTRL_MODE_HWSIG,\n\t\t     CNTR_CTRL_TRIG_SRC_PREV_CNTR);\n\tset_counter_value(dev, CNTR_ID_WDOG, dev->timeout);\n\n\t \n\tcounter_enable(dev, CNTR_ID_WDOG);\n\n\t \n\tcounter_enable(dev, CNTR_ID_RETRIGGER);\n\n\treturn 0;\n}\n\nstatic int armada_37xx_wdt_stop(struct watchdog_device *wdt)\n{\n\tstruct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);\n\n\tcounter_disable(dev, CNTR_ID_WDOG);\n\tcounter_disable(dev, CNTR_ID_RETRIGGER);\n\tregmap_write(dev->cpu_misc, WDT_TIMER_SELECT, 0);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info armada_37xx_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"Armada 37xx Watchdog\",\n};\n\nstatic const struct watchdog_ops armada_37xx_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = armada_37xx_wdt_start,\n\t.stop = armada_37xx_wdt_stop,\n\t.ping = armada_37xx_wdt_ping,\n\t.set_timeout = armada_37xx_wdt_set_timeout,\n\t.get_timeleft = armada_37xx_wdt_get_timeleft,\n};\n\nstatic int armada_37xx_wdt_probe(struct platform_device *pdev)\n{\n\tstruct armada_37xx_watchdog *dev;\n\tstruct resource *res;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(struct armada_37xx_watchdog),\n\t\t\t   GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->wdt.info = &armada_37xx_wdt_info;\n\tdev->wdt.ops = &armada_37xx_wdt_ops;\n\n\tregmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t \"marvell,system-controller\");\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\tdev->cpu_misc = regmap;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\tdev->reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!dev->reg)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn PTR_ERR(dev->clk);\n\n\tdev->clk_rate = clk_get_rate(dev->clk);\n\tif (!dev->clk_rate)\n\t\treturn -EINVAL;\n\n\t \n\tdev->wdt.min_timeout = 1;\n\tdev->wdt.max_timeout = UINT_MAX;\n\tdev->wdt.parent = &pdev->dev;\n\n\t \n\tdev->wdt.timeout = WATCHDOG_TIMEOUT;\n\twatchdog_init_timeout(&dev->wdt, timeout, &pdev->dev);\n\n\tplatform_set_drvdata(pdev, &dev->wdt);\n\twatchdog_set_drvdata(&dev->wdt, dev);\n\n\tarmada_37xx_wdt_set_timeout(&dev->wdt, dev->wdt.timeout);\n\n\tif (armada_37xx_wdt_is_running(dev))\n\t\tset_bit(WDOG_HW_RUNNING, &dev->wdt.status);\n\n\twatchdog_set_nowayout(&dev->wdt, nowayout);\n\twatchdog_stop_on_reboot(&dev->wdt);\n\tret = devm_watchdog_register_device(&pdev->dev, &dev->wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&pdev->dev, \"Initial timeout %d sec%s\\n\",\n\t\t dev->wdt.timeout, nowayout ? \", nowayout\" : \"\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused armada_37xx_wdt_suspend(struct device *dev)\n{\n\tstruct watchdog_device *wdt = dev_get_drvdata(dev);\n\n\treturn armada_37xx_wdt_stop(wdt);\n}\n\nstatic int __maybe_unused armada_37xx_wdt_resume(struct device *dev)\n{\n\tstruct watchdog_device *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(wdt))\n\t\treturn armada_37xx_wdt_start(wdt);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops armada_37xx_wdt_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(armada_37xx_wdt_suspend,\n\t\t\t\tarmada_37xx_wdt_resume)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id armada_37xx_wdt_match[] = {\n\t{ .compatible = \"marvell,armada-3700-wdt\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, armada_37xx_wdt_match);\n#endif\n\nstatic struct platform_driver armada_37xx_wdt_driver = {\n\t.probe\t\t= armada_37xx_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"armada_37xx_wdt\",\n\t\t.of_match_table = of_match_ptr(armada_37xx_wdt_match),\n\t\t.pm = &armada_37xx_wdt_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(armada_37xx_wdt_driver);\n\nMODULE_AUTHOR(\"Marek Behun <kabel@kernel.org>\");\nMODULE_DESCRIPTION(\"Armada 37xx CPU Watchdog\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:armada_37xx_wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}