{
  "module_name": "xen_wdt.c",
  "hash_id": "7e8f33a2630ed5f73eb4daf631f47c5a422e2971aa609fada02e9ca4f4f887cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/xen_wdt.c",
  "human_readable_source": "\n \n\n#define DRV_NAME\t\"xen_wdt\"\n\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/hrtimer.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n#include <xen/xen.h>\n#include <asm/xen/hypercall.h>\n#include <xen/interface/sched.h>\n\nstatic struct platform_device *platform_device;\nstatic struct sched_watchdog wdt;\nstatic time64_t wdt_expires;\n\n#define WATCHDOG_TIMEOUT 60  \nstatic unsigned int timeout;\nmodule_param(timeout, uint, S_IRUGO);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds \"\n\t\"(default=\" __MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, S_IRUGO);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic inline time64_t set_timeout(struct watchdog_device *wdd)\n{\n\twdt.timeout = wdd->timeout;\n\treturn ktime_get_seconds() + wdd->timeout;\n}\n\nstatic int xen_wdt_start(struct watchdog_device *wdd)\n{\n\ttime64_t expires;\n\tint err;\n\n\texpires = set_timeout(wdd);\n\tif (!wdt.id)\n\t\terr = HYPERVISOR_sched_op(SCHEDOP_watchdog, &wdt);\n\telse\n\t\terr = -EBUSY;\n\tif (err > 0) {\n\t\twdt.id = err;\n\t\twdt_expires = expires;\n\t\terr = 0;\n\t} else\n\t\tBUG_ON(!err);\n\n\treturn err;\n}\n\nstatic int xen_wdt_stop(struct watchdog_device *wdd)\n{\n\tint err = 0;\n\n\twdt.timeout = 0;\n\tif (wdt.id)\n\t\terr = HYPERVISOR_sched_op(SCHEDOP_watchdog, &wdt);\n\tif (!err)\n\t\twdt.id = 0;\n\n\treturn err;\n}\n\nstatic int xen_wdt_kick(struct watchdog_device *wdd)\n{\n\ttime64_t expires;\n\tint err;\n\n\texpires = set_timeout(wdd);\n\tif (wdt.id)\n\t\terr = HYPERVISOR_sched_op(SCHEDOP_watchdog, &wdt);\n\telse\n\t\terr = -ENXIO;\n\tif (!err)\n\t\twdt_expires = expires;\n\n\treturn err;\n}\n\nstatic unsigned int xen_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\treturn wdt_expires - ktime_get_seconds();\n}\n\nstatic struct watchdog_info xen_wdt_info = {\n\t.identity = DRV_NAME,\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops xen_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = xen_wdt_start,\n\t.stop = xen_wdt_stop,\n\t.ping = xen_wdt_kick,\n\t.get_timeleft = xen_wdt_get_timeleft,\n};\n\nstatic struct watchdog_device xen_wdt_dev = {\n\t.info = &xen_wdt_info,\n\t.ops = &xen_wdt_ops,\n\t.timeout = WATCHDOG_TIMEOUT,\n};\n\nstatic int xen_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sched_watchdog wd = { .id = ~0 };\n\tint ret = HYPERVISOR_sched_op(SCHEDOP_watchdog, &wd);\n\n\tif (ret == -ENOSYS) {\n\t\tdev_err(dev, \"watchdog not supported by hypervisor\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (ret != -EINVAL) {\n\t\tdev_err(dev, \"unexpected hypervisor error (%d)\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\twatchdog_init_timeout(&xen_wdt_dev, timeout, NULL);\n\twatchdog_set_nowayout(&xen_wdt_dev, nowayout);\n\twatchdog_stop_on_reboot(&xen_wdt_dev);\n\twatchdog_stop_on_unregister(&xen_wdt_dev);\n\n\tret = devm_watchdog_register_device(dev, &xen_wdt_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"initialized (timeout=%ds, nowayout=%d)\\n\",\n\t\t xen_wdt_dev.timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic int xen_wdt_suspend(struct platform_device *dev, pm_message_t state)\n{\n\ttypeof(wdt.id) id = wdt.id;\n\tint rc = xen_wdt_stop(&xen_wdt_dev);\n\n\twdt.id = id;\n\treturn rc;\n}\n\nstatic int xen_wdt_resume(struct platform_device *dev)\n{\n\tif (!wdt.id)\n\t\treturn 0;\n\twdt.id = 0;\n\treturn xen_wdt_start(&xen_wdt_dev);\n}\n\nstatic struct platform_driver xen_wdt_driver = {\n\t.probe          = xen_wdt_probe,\n\t.suspend        = xen_wdt_suspend,\n\t.resume         = xen_wdt_resume,\n\t.driver         = {\n\t\t.name   = DRV_NAME,\n\t},\n};\n\nstatic int __init xen_wdt_init_module(void)\n{\n\tint err;\n\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\terr = platform_driver_register(&xen_wdt_driver);\n\tif (err)\n\t\treturn err;\n\n\tplatform_device = platform_device_register_simple(DRV_NAME,\n\t\t\t\t\t\t\t\t  -1, NULL, 0);\n\tif (IS_ERR(platform_device)) {\n\t\terr = PTR_ERR(platform_device);\n\t\tplatform_driver_unregister(&xen_wdt_driver);\n\t}\n\n\treturn err;\n}\n\nstatic void __exit xen_wdt_cleanup_module(void)\n{\n\tplatform_device_unregister(platform_device);\n\tplatform_driver_unregister(&xen_wdt_driver);\n}\n\nmodule_init(xen_wdt_init_module);\nmodule_exit(xen_wdt_cleanup_module);\n\nMODULE_AUTHOR(\"Jan Beulich <jbeulich@novell.com>\");\nMODULE_DESCRIPTION(\"Xen WatchDog Timer Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}