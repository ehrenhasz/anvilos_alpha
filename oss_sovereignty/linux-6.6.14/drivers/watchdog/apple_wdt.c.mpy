{
  "module_name": "apple_wdt.c",
  "hash_id": "6788c5597f92776e50a616bc2e21b88809bc856de1c8bb69cf3251a0d5bac0dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/apple_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n \n#define APPLE_WDT_WD0_CUR_TIME\t\t0x00\n#define APPLE_WDT_WD0_BITE_TIME\t\t0x04\n#define APPLE_WDT_WD0_BARK_TIME\t\t0x08\n#define APPLE_WDT_WD0_CTRL\t\t0x0c\n\n#define APPLE_WDT_WD1_CUR_TIME\t\t0x10\n#define APPLE_WDT_WD1_BITE_TIME\t\t0x14\n#define APPLE_WDT_WD1_CTRL\t\t0x1c\n\n#define APPLE_WDT_WD2_CUR_TIME\t\t0x20\n#define APPLE_WDT_WD2_BITE_TIME\t\t0x24\n#define APPLE_WDT_WD2_CTRL\t\t0x2c\n\n#define APPLE_WDT_CTRL_IRQ_EN\t\tBIT(0)\n#define APPLE_WDT_CTRL_IRQ_STATUS\tBIT(1)\n#define APPLE_WDT_CTRL_RESET_EN\t\tBIT(2)\n\n#define APPLE_WDT_TIMEOUT_DEFAULT\t30\n\nstruct apple_wdt {\n\tstruct watchdog_device wdd;\n\tvoid __iomem *regs;\n\tunsigned long clk_rate;\n};\n\nstatic struct apple_wdt *to_apple_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct apple_wdt, wdd);\n}\n\nstatic int apple_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct apple_wdt *wdt = to_apple_wdt(wdd);\n\n\twritel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CUR_TIME);\n\twritel_relaxed(APPLE_WDT_CTRL_RESET_EN, wdt->regs + APPLE_WDT_WD1_CTRL);\n\n\treturn 0;\n}\n\nstatic int apple_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct apple_wdt *wdt = to_apple_wdt(wdd);\n\n\twritel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CTRL);\n\n\treturn 0;\n}\n\nstatic int apple_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct apple_wdt *wdt = to_apple_wdt(wdd);\n\n\twritel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CUR_TIME);\n\n\treturn 0;\n}\n\nstatic int apple_wdt_set_timeout(struct watchdog_device *wdd, unsigned int s)\n{\n\tstruct apple_wdt *wdt = to_apple_wdt(wdd);\n\n\twritel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CUR_TIME);\n\twritel_relaxed(wdt->clk_rate * s, wdt->regs + APPLE_WDT_WD1_BITE_TIME);\n\n\twdd->timeout = s;\n\n\treturn 0;\n}\n\nstatic unsigned int apple_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct apple_wdt *wdt = to_apple_wdt(wdd);\n\tu32 cur_time, reset_time;\n\n\tcur_time = readl_relaxed(wdt->regs + APPLE_WDT_WD1_CUR_TIME);\n\treset_time = readl_relaxed(wdt->regs + APPLE_WDT_WD1_BITE_TIME);\n\n\treturn (reset_time - cur_time) / wdt->clk_rate;\n}\n\nstatic int apple_wdt_restart(struct watchdog_device *wdd, unsigned long mode,\n\t\t\t     void *cmd)\n{\n\tstruct apple_wdt *wdt = to_apple_wdt(wdd);\n\n\twritel_relaxed(APPLE_WDT_CTRL_RESET_EN, wdt->regs + APPLE_WDT_WD1_CTRL);\n\twritel_relaxed(0, wdt->regs + APPLE_WDT_WD1_BITE_TIME);\n\twritel_relaxed(0, wdt->regs + APPLE_WDT_WD1_CUR_TIME);\n\n\t \n\t(void)readl_relaxed(wdt->regs + APPLE_WDT_WD1_CUR_TIME);\n\tmdelay(50);\n\n\treturn 0;\n}\n\nstatic struct watchdog_ops apple_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = apple_wdt_start,\n\t.stop = apple_wdt_stop,\n\t.ping = apple_wdt_ping,\n\t.set_timeout = apple_wdt_set_timeout,\n\t.get_timeleft = apple_wdt_get_timeleft,\n\t.restart = apple_wdt_restart,\n};\n\nstatic struct watchdog_info apple_wdt_info = {\n\t.identity = \"Apple SoC Watchdog\",\n\t.options = WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT,\n};\n\nstatic int apple_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct apple_wdt *wdt;\n\tstruct clk *clk;\n\tu32 wdt_ctrl;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->regs))\n\t\treturn PTR_ERR(wdt->regs);\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\twdt->clk_rate = clk_get_rate(clk);\n\tif (!wdt->clk_rate)\n\t\treturn -EINVAL;\n\n\twdt->wdd.ops = &apple_wdt_ops;\n\twdt->wdd.info = &apple_wdt_info;\n\twdt->wdd.max_timeout = U32_MAX / wdt->clk_rate;\n\twdt->wdd.timeout = APPLE_WDT_TIMEOUT_DEFAULT;\n\n\twdt_ctrl = readl_relaxed(wdt->regs + APPLE_WDT_WD1_CTRL);\n\tif (wdt_ctrl & APPLE_WDT_CTRL_RESET_EN)\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdd.status);\n\n\twatchdog_init_timeout(&wdt->wdd, 0, dev);\n\tapple_wdt_set_timeout(&wdt->wdd, wdt->wdd.timeout);\n\twatchdog_stop_on_unregister(&wdt->wdd);\n\twatchdog_set_restart_priority(&wdt->wdd, 128);\n\n\treturn devm_watchdog_register_device(dev, &wdt->wdd);\n}\n\nstatic const struct of_device_id apple_wdt_of_match[] = {\n\t{ .compatible = \"apple,wdt\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, apple_wdt_of_match);\n\nstatic struct platform_driver apple_wdt_driver = {\n\t.driver = {\n\t\t.name = \"apple-watchdog\",\n\t\t.of_match_table = apple_wdt_of_match,\n\t},\n\t.probe = apple_wdt_probe,\n};\nmodule_platform_driver(apple_wdt_driver);\n\nMODULE_DESCRIPTION(\"Apple SoC watchdog driver\");\nMODULE_AUTHOR(\"Sven Peter <sven@svenpeter.dev>\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}