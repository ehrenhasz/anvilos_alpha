{
  "module_name": "pseries-wdt.c",
  "hash_id": "cd69f349dbc41f2325dd469379b4c508b0502377f06ef3512f4acc5407ca9198",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pseries-wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/math.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/time64.h>\n#include <linux/watchdog.h>\n\n#define DRV_NAME \"pseries-wdt\"\n\n \n#define PSERIES_WDTF_OP_START\t0x100UL\t\t \n#define PSERIES_WDTF_OP_STOP\t0x200UL\t\t \n#define PSERIES_WDTF_OP_QUERY\t0x300UL\t\t \n\n \n#define PSERIES_WDTF_ACTION_HARD_POWEROFF\t0x1UL\t \n#define PSERIES_WDTF_ACTION_HARD_RESTART\t0x2UL\t \n#define PSERIES_WDTF_ACTION_DUMP_RESTART\t0x3UL\t \n\n \n#define PSERIES_WDTQ_MIN_TIMEOUT(cap)\t(((cap) >> 48) & 0xffff)\n#define PSERIES_WDTQ_MAX_NUMBER(cap)\t(((cap) >> 32) & 0xffff)\n\nstatic const unsigned long pseries_wdt_action[] = {\n\t[0] = PSERIES_WDTF_ACTION_HARD_POWEROFF,\n\t[1] = PSERIES_WDTF_ACTION_HARD_RESTART,\n\t[2] = PSERIES_WDTF_ACTION_DUMP_RESTART,\n};\n\n#define WATCHDOG_ACTION 1\nstatic unsigned int action = WATCHDOG_ACTION;\nmodule_param(action, uint, 0444);\nMODULE_PARM_DESC(action, \"Action taken when watchdog expires (default=\"\n\t\t __MODULE_STRING(WATCHDOG_ACTION) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0444);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n#define WATCHDOG_TIMEOUT 60\nstatic unsigned int timeout = WATCHDOG_TIMEOUT;\nmodule_param(timeout, uint, 0444);\nMODULE_PARM_DESC(timeout, \"Initial watchdog timeout in seconds (default=\"\n\t\t __MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstruct pseries_wdt {\n\tstruct watchdog_device wd;\n\tunsigned long action;\n\tunsigned long num;\t\t \n};\n\nstatic int pseries_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct pseries_wdt *pw = watchdog_get_drvdata(wdd);\n\tstruct device *dev = wdd->parent;\n\tunsigned long flags, msecs;\n\tlong rc;\n\n\tflags = pw->action | PSERIES_WDTF_OP_START;\n\tmsecs = wdd->timeout * MSEC_PER_SEC;\n\trc = plpar_hcall_norets(H_WATCHDOG, flags, pw->num, msecs);\n\tif (rc != H_SUCCESS) {\n\t\tdev_crit(dev, \"H_WATCHDOG: %ld: failed to start timer %lu\",\n\t\t\t rc, pw->num);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int pseries_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct pseries_wdt *pw = watchdog_get_drvdata(wdd);\n\tstruct device *dev = wdd->parent;\n\tlong rc;\n\n\trc = plpar_hcall_norets(H_WATCHDOG, PSERIES_WDTF_OP_STOP, pw->num);\n\tif (rc != H_SUCCESS && rc != H_NOOP) {\n\t\tdev_crit(dev, \"H_WATCHDOG: %ld: failed to stop timer %lu\",\n\t\t\t rc, pw->num);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic struct watchdog_info pseries_wdt_info = {\n\t.identity = DRV_NAME,\n\t.options = WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT\n\t    | WDIOF_PRETIMEOUT,\n};\n\nstatic const struct watchdog_ops pseries_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = pseries_wdt_start,\n\t.stop = pseries_wdt_stop,\n};\n\nstatic int pseries_wdt_probe(struct platform_device *pdev)\n{\n\tunsigned long ret[PLPAR_HCALL_BUFSIZE] = { 0 };\n\tstruct pseries_wdt *pw;\n\tunsigned long cap;\n\tlong msecs, rc;\n\tint err;\n\n\trc = plpar_hcall(H_WATCHDOG, ret, PSERIES_WDTF_OP_QUERY);\n\tif (rc == H_FUNCTION)\n\t\treturn -ENODEV;\n\tif (rc != H_SUCCESS)\n\t\treturn -EIO;\n\tcap = ret[0];\n\n\tpw = devm_kzalloc(&pdev->dev, sizeof(*pw), GFP_KERNEL);\n\tif (!pw)\n\t\treturn -ENOMEM;\n\n\t \n\tpw->num = 1;\n\tif (PSERIES_WDTQ_MAX_NUMBER(cap) < pw->num)\n\t\treturn -ENODEV;\n\n\tif (action >= ARRAY_SIZE(pseries_wdt_action))\n\t\treturn -EINVAL;\n\tpw->action = pseries_wdt_action[action];\n\n\tpw->wd.parent = &pdev->dev;\n\tpw->wd.info = &pseries_wdt_info;\n\tpw->wd.ops = &pseries_wdt_ops;\n\tmsecs = PSERIES_WDTQ_MIN_TIMEOUT(cap);\n\tpw->wd.min_timeout = DIV_ROUND_UP(msecs, MSEC_PER_SEC);\n\tpw->wd.max_timeout = UINT_MAX / 1000;\t \n\tpw->wd.timeout = timeout;\n\tif (watchdog_init_timeout(&pw->wd, 0, NULL))\n\t\treturn -EINVAL;\n\twatchdog_set_nowayout(&pw->wd, nowayout);\n\twatchdog_stop_on_reboot(&pw->wd);\n\twatchdog_stop_on_unregister(&pw->wd);\n\twatchdog_set_drvdata(&pw->wd, pw);\n\n\terr = devm_watchdog_register_device(&pdev->dev, &pw->wd);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, &pw->wd);\n\n\treturn 0;\n}\n\nstatic int pseries_wdt_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct watchdog_device *wd = platform_get_drvdata(pdev);\n\n\tif (watchdog_active(wd))\n\t\treturn pseries_wdt_stop(wd);\n\treturn 0;\n}\n\nstatic int pseries_wdt_resume(struct platform_device *pdev)\n{\n\tstruct watchdog_device *wd = platform_get_drvdata(pdev);\n\n\tif (watchdog_active(wd))\n\t\treturn pseries_wdt_start(wd);\n\treturn 0;\n}\n\nstatic const struct platform_device_id pseries_wdt_id[] = {\n\t{ .name = \"pseries-wdt\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, pseries_wdt_id);\n\nstatic struct platform_driver pseries_wdt_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.id_table = pseries_wdt_id,\n\t.probe = pseries_wdt_probe,\n\t.resume = pseries_wdt_resume,\n\t.suspend = pseries_wdt_suspend,\n};\nmodule_platform_driver(pseries_wdt_driver);\n\nMODULE_AUTHOR(\"Alexey Kardashevskiy\");\nMODULE_AUTHOR(\"Scott Cheloha\");\nMODULE_DESCRIPTION(\"POWER Architecture Platform Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}