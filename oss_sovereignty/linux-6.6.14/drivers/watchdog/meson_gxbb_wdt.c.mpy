{
  "module_name": "meson_gxbb_wdt.c",
  "hash_id": "2a3e8b027a0fadbaf4538fced1a563397f2f8e2e8a340e4c969b7879505c9e75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/meson_gxbb_wdt.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#define DEFAULT_TIMEOUT\t30\t \n\n#define GXBB_WDT_CTRL_REG\t\t\t0x0\n#define GXBB_WDT_TCNT_REG\t\t\t0x8\n#define GXBB_WDT_RSET_REG\t\t\t0xc\n\n#define GXBB_WDT_CTRL_CLKDIV_EN\t\t\tBIT(25)\n#define GXBB_WDT_CTRL_CLK_EN\t\t\tBIT(24)\n#define GXBB_WDT_CTRL_EN\t\t\tBIT(18)\n#define GXBB_WDT_CTRL_DIV_MASK\t\t\t(BIT(18) - 1)\n\n#define GXBB_WDT_TCNT_SETUP_MASK\t\t(BIT(16) - 1)\n#define GXBB_WDT_TCNT_CNT_SHIFT\t\t\t16\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic unsigned int timeout;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog heartbeat in seconds=\"\n\t\t __MODULE_STRING(DEFAULT_TIMEOUT) \")\");\n\nstruct meson_gxbb_wdt {\n\tvoid __iomem *reg_base;\n\tstruct watchdog_device wdt_dev;\n\tstruct clk *clk;\n};\n\nstruct wdt_params {\n\tu32 rst;\n};\n\nstatic int meson_gxbb_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tstruct meson_gxbb_wdt *data = watchdog_get_drvdata(wdt_dev);\n\n\twritel(readl(data->reg_base + GXBB_WDT_CTRL_REG) | GXBB_WDT_CTRL_EN,\n\t       data->reg_base + GXBB_WDT_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int meson_gxbb_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct meson_gxbb_wdt *data = watchdog_get_drvdata(wdt_dev);\n\n\twritel(readl(data->reg_base + GXBB_WDT_CTRL_REG) & ~GXBB_WDT_CTRL_EN,\n\t       data->reg_base + GXBB_WDT_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int meson_gxbb_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct meson_gxbb_wdt *data = watchdog_get_drvdata(wdt_dev);\n\n\twritel(0, data->reg_base + GXBB_WDT_RSET_REG);\n\n\treturn 0;\n}\n\nstatic int meson_gxbb_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t      unsigned int timeout)\n{\n\tstruct meson_gxbb_wdt *data = watchdog_get_drvdata(wdt_dev);\n\tunsigned long tcnt = timeout * 1000;\n\n\tif (tcnt > GXBB_WDT_TCNT_SETUP_MASK)\n\t\ttcnt = GXBB_WDT_TCNT_SETUP_MASK;\n\n\twdt_dev->timeout = timeout;\n\n\tmeson_gxbb_wdt_ping(wdt_dev);\n\n\twritel(tcnt, data->reg_base + GXBB_WDT_TCNT_REG);\n\n\treturn 0;\n}\n\nstatic unsigned int meson_gxbb_wdt_get_timeleft(struct watchdog_device *wdt_dev)\n{\n\tstruct meson_gxbb_wdt *data = watchdog_get_drvdata(wdt_dev);\n\tunsigned long reg;\n\n\treg = readl(data->reg_base + GXBB_WDT_TCNT_REG);\n\n\treturn ((reg & GXBB_WDT_TCNT_SETUP_MASK) -\n\t\t(reg >> GXBB_WDT_TCNT_CNT_SHIFT)) / 1000;\n}\n\nstatic const struct watchdog_ops meson_gxbb_wdt_ops = {\n\t.start = meson_gxbb_wdt_start,\n\t.stop = meson_gxbb_wdt_stop,\n\t.ping = meson_gxbb_wdt_ping,\n\t.set_timeout = meson_gxbb_wdt_set_timeout,\n\t.get_timeleft = meson_gxbb_wdt_get_timeleft,\n};\n\nstatic const struct watchdog_info meson_gxbb_wdt_info = {\n\t.identity = \"Meson GXBB Watchdog\",\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n};\n\nstatic int __maybe_unused meson_gxbb_wdt_resume(struct device *dev)\n{\n\tstruct meson_gxbb_wdt *data = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&data->wdt_dev))\n\t\tmeson_gxbb_wdt_start(&data->wdt_dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused meson_gxbb_wdt_suspend(struct device *dev)\n{\n\tstruct meson_gxbb_wdt *data = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&data->wdt_dev))\n\t\tmeson_gxbb_wdt_stop(&data->wdt_dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops meson_gxbb_wdt_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(meson_gxbb_wdt_suspend, meson_gxbb_wdt_resume)\n};\n\nstatic const struct wdt_params gxbb_params = {\n\t.rst = BIT(21),\n};\n\nstatic const struct wdt_params t7_params = {\n\t.rst = BIT(22),\n};\n\nstatic const struct of_device_id meson_gxbb_wdt_dt_ids[] = {\n\t { .compatible = \"amlogic,meson-gxbb-wdt\", .data = &gxbb_params, },\n\t { .compatible = \"amlogic,t7-wdt\", .data = &t7_params, },\n\t {   },\n};\nMODULE_DEVICE_TABLE(of, meson_gxbb_wdt_dt_ids);\n\nstatic int meson_gxbb_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_gxbb_wdt *data;\n\tstruct wdt_params *params;\n\tu32 ctrl_reg;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->reg_base))\n\t\treturn PTR_ERR(data->reg_base);\n\n\tdata->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(data->clk))\n\t\treturn PTR_ERR(data->clk);\n\n\tparams = (struct wdt_params *)of_device_get_match_data(dev);\n\n\tplatform_set_drvdata(pdev, data);\n\n\tdata->wdt_dev.parent = dev;\n\tdata->wdt_dev.info = &meson_gxbb_wdt_info;\n\tdata->wdt_dev.ops = &meson_gxbb_wdt_ops;\n\tdata->wdt_dev.max_hw_heartbeat_ms = GXBB_WDT_TCNT_SETUP_MASK;\n\tdata->wdt_dev.min_timeout = 1;\n\tdata->wdt_dev.timeout = DEFAULT_TIMEOUT;\n\twatchdog_init_timeout(&data->wdt_dev, timeout, dev);\n\twatchdog_set_nowayout(&data->wdt_dev, nowayout);\n\twatchdog_set_drvdata(&data->wdt_dev, data);\n\n\tctrl_reg = readl(data->reg_base + GXBB_WDT_CTRL_REG) &\n\t\t\t\tGXBB_WDT_CTRL_EN;\n\n\tif (ctrl_reg) {\n\t\t \n\t\tset_bit(WDOG_HW_RUNNING, &data->wdt_dev.status);\n\t\tmeson_gxbb_wdt_set_timeout(&data->wdt_dev,\n\t\t\t\tGXBB_WDT_TCNT_SETUP_MASK / 1000);\n\t}\n\n\t \n\tctrl_reg |= ((clk_get_rate(data->clk) / 1000) &\n\t\t\tGXBB_WDT_CTRL_DIV_MASK) |\n\t\t\tparams->rst |\n\t\t\tGXBB_WDT_CTRL_CLK_EN |\n\t\t\tGXBB_WDT_CTRL_CLKDIV_EN;\n\n\twritel(ctrl_reg, data->reg_base + GXBB_WDT_CTRL_REG);\n\tmeson_gxbb_wdt_set_timeout(&data->wdt_dev, data->wdt_dev.timeout);\n\n\treturn devm_watchdog_register_device(dev, &data->wdt_dev);\n}\n\nstatic struct platform_driver meson_gxbb_wdt_driver = {\n\t.probe\t= meson_gxbb_wdt_probe,\n\t.driver = {\n\t\t.name = \"meson-gxbb-wdt\",\n\t\t.pm = &meson_gxbb_wdt_pm_ops,\n\t\t.of_match_table\t= meson_gxbb_wdt_dt_ids,\n\t},\n};\n\nmodule_platform_driver(meson_gxbb_wdt_driver);\n\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_DESCRIPTION(\"Amlogic Meson GXBB Watchdog timer driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}