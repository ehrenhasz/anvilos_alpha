{
  "module_name": "mixcomwd.c",
  "hash_id": "e5c5f08590fdce1cee9631b809bb76e9415f9d02854cc12dedc0fc449b95809a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/mixcomwd.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define VERSION \"0.6\"\n#define WATCHDOG_NAME \"mixcomwd\"\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/miscdevice.h>\n#include <linux/ioport.h>\n#include <linux/watchdog.h>\n#include <linux/fs.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n \n#define MIXCOM_ID 0x11\n#define FLASHCOM_ID 0x18\nstatic struct {\n\tint ioport;\n\tint id;\n} mixcomwd_io_info[] = {\n\t \n\t{0x0d90, MIXCOM_ID},\n\t{0x0e90, MIXCOM_ID},\n\t{0x0f90, MIXCOM_ID},\n\t \n\t{0x0304, FLASHCOM_ID},\n\t{0x030c, FLASHCOM_ID},\n\t{0x0314, FLASHCOM_ID},\n\t{0x031c, FLASHCOM_ID},\n\t{0x0324, FLASHCOM_ID},\n\t{0x032c, FLASHCOM_ID},\n\t{0x0334, FLASHCOM_ID},\n\t{0x033c, FLASHCOM_ID},\n\t{0x0344, FLASHCOM_ID},\n\t{0x034c, FLASHCOM_ID},\n\t{0x0354, FLASHCOM_ID},\n\t{0x035c, FLASHCOM_ID},\n\t{0x0364, FLASHCOM_ID},\n\t{0x036c, FLASHCOM_ID},\n\t{0x0374, FLASHCOM_ID},\n\t{0x037c, FLASHCOM_ID},\n\t \n\t{0x0000, 0},\n};\n\nstatic void mixcomwd_timerfun(struct timer_list *unused);\n\nstatic unsigned long mixcomwd_opened;  \n\nstatic int watchdog_port;\nstatic int mixcomwd_timer_alive;\nstatic DEFINE_TIMER(mixcomwd_timer, mixcomwd_timerfun);\nstatic char expect_close;\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic void mixcomwd_ping(void)\n{\n\toutb_p(55, watchdog_port);\n\treturn;\n}\n\nstatic void mixcomwd_timerfun(struct timer_list *unused)\n{\n\tmixcomwd_ping();\n\tmod_timer(&mixcomwd_timer, jiffies + 5 * HZ);\n}\n\n \n\nstatic int mixcomwd_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &mixcomwd_opened))\n\t\treturn -EBUSY;\n\n\tmixcomwd_ping();\n\n\tif (nowayout)\n\t\t \n\t\t__module_get(THIS_MODULE);\n\telse {\n\t\tif (mixcomwd_timer_alive) {\n\t\t\tdel_timer(&mixcomwd_timer);\n\t\t\tmixcomwd_timer_alive = 0;\n\t\t}\n\t}\n\treturn stream_open(inode, file);\n}\n\nstatic int mixcomwd_release(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42) {\n\t\tif (mixcomwd_timer_alive) {\n\t\t\tpr_err(\"release called while internal timer alive\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tmixcomwd_timer_alive = 1;\n\t\tmod_timer(&mixcomwd_timer, jiffies + 5 * HZ);\n\t} else\n\t\tpr_crit(\"WDT device closed unexpectedly.  WDT will not stop!\\n\");\n\n\tclear_bit(0, &mixcomwd_opened);\n\texpect_close = 0;\n\treturn 0;\n}\n\n\nstatic ssize_t mixcomwd_write(struct file *file, const char __user *data,\n\t\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\t\tmixcomwd_ping();\n\t}\n\treturn len;\n}\n\nstatic long mixcomwd_ioctl(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint status;\n\tstatic const struct watchdog_info ident = {\n\t\t.options = WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t\t.firmware_version = 1,\n\t\t.identity = \"MixCOM watchdog\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase WDIOC_GETSTATUS:\n\t\tstatus = mixcomwd_opened;\n\t\tif (!nowayout)\n\t\t\tstatus |= mixcomwd_timer_alive;\n\t\treturn put_user(status, p);\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_KEEPALIVE:\n\t\tmixcomwd_ping();\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations mixcomwd_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= mixcomwd_write,\n\t.unlocked_ioctl\t= mixcomwd_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= mixcomwd_open,\n\t.release\t= mixcomwd_release,\n};\n\nstatic struct miscdevice mixcomwd_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &mixcomwd_fops,\n};\n\nstatic int __init checkcard(int port, int card_id)\n{\n\tint id;\n\n\tif (!request_region(port, 1, \"MixCOM watchdog\"))\n\t\treturn 0;\n\n\tid = inb_p(port);\n\tif (card_id == MIXCOM_ID)\n\t\tid &= 0x3f;\n\n\tif (id != card_id) {\n\t\trelease_region(port, 1);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int __init mixcomwd_init(void)\n{\n\tint i, ret, found = 0;\n\n\tfor (i = 0; !found && mixcomwd_io_info[i].ioport != 0; i++) {\n\t\tif (checkcard(mixcomwd_io_info[i].ioport,\n\t\t\t      mixcomwd_io_info[i].id)) {\n\t\t\tfound = 1;\n\t\t\twatchdog_port = mixcomwd_io_info[i].ioport;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tpr_err(\"No card detected, or port not available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = misc_register(&mixcomwd_miscdev);\n\tif (ret) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, ret);\n\t\tgoto error_misc_register_watchdog;\n\t}\n\n\tpr_info(\"MixCOM watchdog driver v%s, watchdog port at 0x%3x\\n\",\n\t\tVERSION, watchdog_port);\n\n\treturn 0;\n\nerror_misc_register_watchdog:\n\trelease_region(watchdog_port, 1);\n\twatchdog_port = 0x0000;\n\treturn ret;\n}\n\nstatic void __exit mixcomwd_exit(void)\n{\n\tif (!nowayout) {\n\t\tif (mixcomwd_timer_alive) {\n\t\t\tpr_warn(\"I quit now, hardware will probably reboot!\\n\");\n\t\t\tdel_timer_sync(&mixcomwd_timer);\n\t\t\tmixcomwd_timer_alive = 0;\n\t\t}\n\t}\n\tmisc_deregister(&mixcomwd_miscdev);\n\trelease_region(watchdog_port, 1);\n}\n\nmodule_init(mixcomwd_init);\nmodule_exit(mixcomwd_exit);\n\nMODULE_AUTHOR(\"Gergely Madarasz <gorgo@itc.hu>\");\nMODULE_DESCRIPTION(\"MixCom Watchdog driver\");\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}