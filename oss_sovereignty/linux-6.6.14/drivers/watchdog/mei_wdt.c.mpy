{
  "module_name": "mei_wdt.c",
  "hash_id": "2dbc38d7a6f973936a80f1514cf4eb93a259df096920824bd0eb4fd5ddaefe98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/mei_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/debugfs.h>\n#include <linux/completion.h>\n#include <linux/watchdog.h>\n\n#include <linux/uuid.h>\n#include <linux/mei_cl_bus.h>\n\n \n#define INTEL_AMT_WATCHDOG_ID \"iamt_wdt\"\n\n#define MEI_WDT_DEFAULT_TIMEOUT   120   \n#define MEI_WDT_MIN_TIMEOUT       120   \n#define MEI_WDT_MAX_TIMEOUT     65535   \n\n \n#define MEI_MANAGEMENT_CONTROL 0x02\n\n \n#define MEI_MC_VERSION_NUMBER  0x10\n\n \n#define MEI_MC_START_WD_TIMER_REQ  0x13\n#define MEI_MC_START_WD_TIMER_RES  0x83\n#define   MEI_WDT_STATUS_SUCCESS 0\n#define   MEI_WDT_WDSTATE_NOT_REQUIRED 0x1\n#define MEI_MC_STOP_WD_TIMER_REQ   0x14\n\n \nenum mei_wdt_state {\n\tMEI_WDT_PROBE,\n\tMEI_WDT_IDLE,\n\tMEI_WDT_START,\n\tMEI_WDT_RUNNING,\n\tMEI_WDT_STOPPING,\n\tMEI_WDT_NOT_REQUIRED,\n};\n\nstatic const char *mei_wdt_state_str(enum mei_wdt_state state)\n{\n\tswitch (state) {\n\tcase MEI_WDT_PROBE:\n\t\treturn \"PROBE\";\n\tcase MEI_WDT_IDLE:\n\t\treturn \"IDLE\";\n\tcase MEI_WDT_START:\n\t\treturn \"START\";\n\tcase MEI_WDT_RUNNING:\n\t\treturn \"RUNNING\";\n\tcase MEI_WDT_STOPPING:\n\t\treturn \"STOPPING\";\n\tcase MEI_WDT_NOT_REQUIRED:\n\t\treturn \"NOT_REQUIRED\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n \nstruct mei_wdt {\n\tstruct watchdog_device wdd;\n\n\tstruct mei_cl_device *cldev;\n\tenum mei_wdt_state state;\n\tbool resp_required;\n\tstruct completion response;\n\tstruct work_struct unregister;\n\tstruct mutex reg_lock;\n\tu16 timeout;\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\n\tstruct dentry *dbgfs_dir;\n#endif  \n};\n\n \nstruct mei_mc_hdr {\n\tu8 command;\n\tu8 bytecount;\n\tu8 subcommand;\n\tu8 versionnumber;\n};\n\n \nstruct mei_wdt_start_request {\n\tstruct mei_mc_hdr hdr;\n\tu16 timeout;\n\tu8 reserved[17];\n} __packed;\n\n \nstruct mei_wdt_start_response {\n\tstruct mei_mc_hdr hdr;\n\tu8 status;\n\tu8 wdstate;\n} __packed;\n\n \nstruct mei_wdt_stop_request {\n\tstruct mei_mc_hdr hdr;\n} __packed;\n\n \nstatic int mei_wdt_ping(struct mei_wdt *wdt)\n{\n\tstruct mei_wdt_start_request req;\n\tconst size_t req_len = sizeof(req);\n\tint ret;\n\n\tmemset(&req, 0, req_len);\n\treq.hdr.command = MEI_MANAGEMENT_CONTROL;\n\treq.hdr.bytecount = req_len - offsetof(struct mei_mc_hdr, subcommand);\n\treq.hdr.subcommand = MEI_MC_START_WD_TIMER_REQ;\n\treq.hdr.versionnumber = MEI_MC_VERSION_NUMBER;\n\treq.timeout = wdt->timeout;\n\n\tret = mei_cldev_send(wdt->cldev, (u8 *)&req, req_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int mei_wdt_stop(struct mei_wdt *wdt)\n{\n\tstruct mei_wdt_stop_request req;\n\tconst size_t req_len = sizeof(req);\n\tint ret;\n\n\tmemset(&req, 0, req_len);\n\treq.hdr.command = MEI_MANAGEMENT_CONTROL;\n\treq.hdr.bytecount = req_len - offsetof(struct mei_mc_hdr, subcommand);\n\treq.hdr.subcommand = MEI_MC_STOP_WD_TIMER_REQ;\n\treq.hdr.versionnumber = MEI_MC_VERSION_NUMBER;\n\n\tret = mei_cldev_send(wdt->cldev, (u8 *)&req, req_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int mei_wdt_ops_start(struct watchdog_device *wdd)\n{\n\tstruct mei_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twdt->state = MEI_WDT_START;\n\twdd->timeout = wdt->timeout;\n\treturn 0;\n}\n\n \nstatic int mei_wdt_ops_stop(struct watchdog_device *wdd)\n{\n\tstruct mei_wdt *wdt = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tif (wdt->state != MEI_WDT_RUNNING)\n\t\treturn 0;\n\n\twdt->state = MEI_WDT_STOPPING;\n\n\tret = mei_wdt_stop(wdt);\n\tif (ret)\n\t\treturn ret;\n\n\twdt->state = MEI_WDT_IDLE;\n\n\treturn 0;\n}\n\n \nstatic int mei_wdt_ops_ping(struct watchdog_device *wdd)\n{\n\tstruct mei_wdt *wdt = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tif (wdt->state != MEI_WDT_START && wdt->state != MEI_WDT_RUNNING)\n\t\treturn 0;\n\n\tif (wdt->resp_required)\n\t\tinit_completion(&wdt->response);\n\n\twdt->state = MEI_WDT_RUNNING;\n\tret = mei_wdt_ping(wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (wdt->resp_required)\n\t\tret = wait_for_completion_killable(&wdt->response);\n\n\treturn ret;\n}\n\n \nstatic int mei_wdt_ops_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t   unsigned int timeout)\n{\n\n\tstruct mei_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\t \n\twdt->timeout = timeout;\n\twdd->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops wd_ops = {\n\t.owner       = THIS_MODULE,\n\t.start       = mei_wdt_ops_start,\n\t.stop        = mei_wdt_ops_stop,\n\t.ping        = mei_wdt_ops_ping,\n\t.set_timeout = mei_wdt_ops_set_timeout,\n};\n\n \nstatic struct watchdog_info wd_info = {\n\t.identity = INTEL_AMT_WATCHDOG_ID,\n\t.options  = WDIOF_KEEPALIVEPING |\n\t\t    WDIOF_SETTIMEOUT |\n\t\t    WDIOF_ALARMONLY,\n};\n\n \nstatic inline bool __mei_wdt_is_registered(struct mei_wdt *wdt)\n{\n\treturn !!watchdog_get_drvdata(&wdt->wdd);\n}\n\n \nstatic void mei_wdt_unregister(struct mei_wdt *wdt)\n{\n\tmutex_lock(&wdt->reg_lock);\n\n\tif (__mei_wdt_is_registered(wdt)) {\n\t\twatchdog_unregister_device(&wdt->wdd);\n\t\twatchdog_set_drvdata(&wdt->wdd, NULL);\n\t\tmemset(&wdt->wdd, 0, sizeof(wdt->wdd));\n\t}\n\n\tmutex_unlock(&wdt->reg_lock);\n}\n\n \nstatic int mei_wdt_register(struct mei_wdt *wdt)\n{\n\tstruct device *dev;\n\tint ret;\n\n\tif (!wdt || !wdt->cldev)\n\t\treturn -EINVAL;\n\n\tdev = &wdt->cldev->dev;\n\n\tmutex_lock(&wdt->reg_lock);\n\n\tif (__mei_wdt_is_registered(wdt)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twdt->wdd.info = &wd_info;\n\twdt->wdd.ops = &wd_ops;\n\twdt->wdd.parent = dev;\n\twdt->wdd.timeout = MEI_WDT_DEFAULT_TIMEOUT;\n\twdt->wdd.min_timeout = MEI_WDT_MIN_TIMEOUT;\n\twdt->wdd.max_timeout = MEI_WDT_MAX_TIMEOUT;\n\n\twatchdog_set_drvdata(&wdt->wdd, wdt);\n\twatchdog_stop_on_reboot(&wdt->wdd);\n\twatchdog_stop_on_unregister(&wdt->wdd);\n\n\tret = watchdog_register_device(&wdt->wdd);\n\tif (ret)\n\t\twatchdog_set_drvdata(&wdt->wdd, NULL);\n\n\twdt->state = MEI_WDT_IDLE;\n\nout:\n\tmutex_unlock(&wdt->reg_lock);\n\treturn ret;\n}\n\nstatic void mei_wdt_unregister_work(struct work_struct *work)\n{\n\tstruct mei_wdt *wdt = container_of(work, struct mei_wdt, unregister);\n\n\tmei_wdt_unregister(wdt);\n}\n\n \nstatic void mei_wdt_rx(struct mei_cl_device *cldev)\n{\n\tstruct mei_wdt *wdt = mei_cldev_get_drvdata(cldev);\n\tstruct mei_wdt_start_response res;\n\tconst size_t res_len = sizeof(res);\n\tint ret;\n\n\tret = mei_cldev_recv(wdt->cldev, (u8 *)&res, res_len);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"failure in recv %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tif (ret == 0)\n\t\treturn;\n\n\tif (ret < sizeof(struct mei_mc_hdr)) {\n\t\tdev_err(&cldev->dev, \"recv small data %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (res.hdr.command != MEI_MANAGEMENT_CONTROL ||\n\t    res.hdr.versionnumber != MEI_MC_VERSION_NUMBER) {\n\t\tdev_err(&cldev->dev, \"wrong command received\\n\");\n\t\treturn;\n\t}\n\n\tif (res.hdr.subcommand != MEI_MC_START_WD_TIMER_RES) {\n\t\tdev_warn(&cldev->dev, \"unsupported command %d :%s[%d]\\n\",\n\t\t\t res.hdr.subcommand,\n\t\t\t mei_wdt_state_str(wdt->state),\n\t\t\t wdt->state);\n\t\treturn;\n\t}\n\n\t \n\tif (wdt->state == MEI_WDT_RUNNING) {\n\t\tif (res.wdstate & MEI_WDT_WDSTATE_NOT_REQUIRED) {\n\t\t\twdt->state = MEI_WDT_NOT_REQUIRED;\n\t\t\tschedule_work(&wdt->unregister);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (wdt->state == MEI_WDT_PROBE) {\n\t\tif (res.wdstate & MEI_WDT_WDSTATE_NOT_REQUIRED) {\n\t\t\twdt->state = MEI_WDT_NOT_REQUIRED;\n\t\t} else {\n\t\t\t \n\t\t\tmei_wdt_stop(wdt);\n\t\t\tmei_wdt_register(wdt);\n\t\t}\n\t\treturn;\n\t}\n\n\tdev_warn(&cldev->dev, \"not in correct state %s[%d]\\n\",\n\t\t\t mei_wdt_state_str(wdt->state), wdt->state);\n\nout:\n\tif (!completion_done(&wdt->response))\n\t\tcomplete(&wdt->response);\n}\n\n \nstatic void mei_wdt_notif(struct mei_cl_device *cldev)\n{\n\tstruct mei_wdt *wdt = mei_cldev_get_drvdata(cldev);\n\n\tif (wdt->state != MEI_WDT_NOT_REQUIRED)\n\t\treturn;\n\n\tmei_wdt_register(wdt);\n}\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\n\nstatic ssize_t mei_dbgfs_read_activation(struct file *file, char __user *ubuf,\n\t\t\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct mei_wdt *wdt = file->private_data;\n\tconst size_t bufsz = 32;\n\tchar buf[32];\n\tssize_t pos;\n\n\tmutex_lock(&wdt->reg_lock);\n\tpos = scnprintf(buf, bufsz, \"%s\\n\",\n\t\t__mei_wdt_is_registered(wdt) ? \"activated\" : \"deactivated\");\n\tmutex_unlock(&wdt->reg_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);\n}\n\nstatic const struct file_operations dbgfs_fops_activation = {\n\t.open    = simple_open,\n\t.read    = mei_dbgfs_read_activation,\n\t.llseek  = generic_file_llseek,\n};\n\nstatic ssize_t mei_dbgfs_read_state(struct file *file, char __user *ubuf,\n\t\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tstruct mei_wdt *wdt = file->private_data;\n\tchar buf[32];\n\tssize_t pos;\n\n\tpos = scnprintf(buf, sizeof(buf), \"state: %s\\n\",\n\t\t\tmei_wdt_state_str(wdt->state));\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);\n}\n\nstatic const struct file_operations dbgfs_fops_state = {\n\t.open = simple_open,\n\t.read = mei_dbgfs_read_state,\n\t.llseek = generic_file_llseek,\n};\n\nstatic void dbgfs_unregister(struct mei_wdt *wdt)\n{\n\tdebugfs_remove_recursive(wdt->dbgfs_dir);\n\twdt->dbgfs_dir = NULL;\n}\n\nstatic void dbgfs_register(struct mei_wdt *wdt)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\twdt->dbgfs_dir = dir;\n\n\tdebugfs_create_file(\"state\", S_IRUSR, dir, wdt, &dbgfs_fops_state);\n\n\tdebugfs_create_file(\"activation\", S_IRUSR, dir, wdt,\n\t\t\t    &dbgfs_fops_activation);\n}\n\n#else\n\nstatic inline void dbgfs_unregister(struct mei_wdt *wdt) {}\nstatic inline void dbgfs_register(struct mei_wdt *wdt) {}\n#endif  \n\nstatic int mei_wdt_probe(struct mei_cl_device *cldev,\n\t\t\t const struct mei_cl_device_id *id)\n{\n\tstruct mei_wdt *wdt;\n\tint ret;\n\n\twdt = kzalloc(sizeof(struct mei_wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->timeout = MEI_WDT_DEFAULT_TIMEOUT;\n\twdt->state = MEI_WDT_PROBE;\n\twdt->cldev = cldev;\n\twdt->resp_required = mei_cldev_ver(cldev) > 0x1;\n\tmutex_init(&wdt->reg_lock);\n\tinit_completion(&wdt->response);\n\tINIT_WORK(&wdt->unregister, mei_wdt_unregister_work);\n\n\tmei_cldev_set_drvdata(cldev, wdt);\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"Could not enable cl device\\n\");\n\t\tgoto err_out;\n\t}\n\n\tret = mei_cldev_register_rx_cb(wdt->cldev, mei_wdt_rx);\n\tif (ret) {\n\t\tdev_err(&cldev->dev, \"Could not reg rx event ret=%d\\n\", ret);\n\t\tgoto err_disable;\n\t}\n\n\tret = mei_cldev_register_notif_cb(wdt->cldev, mei_wdt_notif);\n\t \n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tdev_err(&cldev->dev, \"Could not reg notif event ret=%d\\n\", ret);\n\t\tgoto err_disable;\n\t}\n\n\twd_info.firmware_version = mei_cldev_ver(cldev);\n\n\tif (wdt->resp_required)\n\t\tret = mei_wdt_ping(wdt);\n\telse\n\t\tret = mei_wdt_register(wdt);\n\n\tif (ret)\n\t\tgoto err_disable;\n\n\tdbgfs_register(wdt);\n\n\treturn 0;\n\nerr_disable:\n\tmei_cldev_disable(cldev);\n\nerr_out:\n\tkfree(wdt);\n\n\treturn ret;\n}\n\nstatic void mei_wdt_remove(struct mei_cl_device *cldev)\n{\n\tstruct mei_wdt *wdt = mei_cldev_get_drvdata(cldev);\n\n\t \n\tif (!completion_done(&wdt->response))\n\t\tcomplete(&wdt->response);\n\n\tcancel_work_sync(&wdt->unregister);\n\n\tmei_wdt_unregister(wdt);\n\n\tmei_cldev_disable(cldev);\n\n\tdbgfs_unregister(wdt);\n\n\tkfree(wdt);\n}\n\n#define MEI_UUID_WD UUID_LE(0x05B79A6F, 0x4628, 0x4D7F, \\\n\t\t\t    0x89, 0x9D, 0xA9, 0x15, 0x14, 0xCB, 0x32, 0xAB)\n\nstatic const struct mei_cl_device_id mei_wdt_tbl[] = {\n\t{ .uuid = MEI_UUID_WD, .version = MEI_CL_VERSION_ANY },\n\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(mei, mei_wdt_tbl);\n\nstatic struct mei_cl_driver mei_wdt_driver = {\n\t.id_table = mei_wdt_tbl,\n\t.name = KBUILD_MODNAME,\n\n\t.probe = mei_wdt_probe,\n\t.remove = mei_wdt_remove,\n};\n\nmodule_mei_cl_driver(mei_wdt_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Device driver for Intel MEI iAMT watchdog\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}