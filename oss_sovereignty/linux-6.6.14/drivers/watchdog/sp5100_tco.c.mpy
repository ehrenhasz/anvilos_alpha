{
  "module_name": "sp5100_tco.c",
  "hash_id": "8afd84abb9c520d5c951c05ae0aaeb62698a31be4b22b0c180b27a1ac57ec9b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sp5100_tco.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#include \"sp5100_tco.h\"\n\n#define TCO_DRIVER_NAME\t\"sp5100-tco\"\n\n \n\nenum tco_reg_layout {\n\tsp5100, sb800, efch, efch_mmio\n};\n\nstruct sp5100_tco {\n\tstruct watchdog_device wdd;\n\tvoid __iomem *tcobase;\n\tenum tco_reg_layout tco_reg_layout;\n};\n\n \nstatic struct platform_device *sp5100_tco_platform_device;\n \nstatic struct pci_dev *sp5100_tco_pci;\n\n \n\n#define WATCHDOG_ACTION 0\nstatic bool action = WATCHDOG_ACTION;\nmodule_param(action, bool, 0);\nMODULE_PARM_DESC(action, \"Action taken when watchdog expires, 0 to reset, 1 to poweroff (default=\"\n\t\t __MODULE_STRING(WATCHDOG_ACTION) \")\");\n\n#define WATCHDOG_HEARTBEAT 60\t \nstatic int heartbeat = WATCHDOG_HEARTBEAT;   \nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeat in seconds. (default=\"\n\t\t __MODULE_STRING(WATCHDOG_HEARTBEAT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started.\"\n\t\t\" (default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n\nstatic enum tco_reg_layout tco_reg_layout(struct pci_dev *dev)\n{\n\tif (dev->vendor == PCI_VENDOR_ID_ATI &&\n\t    dev->device == PCI_DEVICE_ID_ATI_SBX00_SMBUS &&\n\t    dev->revision < 0x40) {\n\t\treturn sp5100;\n\t} else if (dev->vendor == PCI_VENDOR_ID_AMD &&\n\t    sp5100_tco_pci->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS &&\n\t    sp5100_tco_pci->revision >= AMD_ZEN_SMBUS_PCI_REV) {\n\t\treturn efch_mmio;\n\t} else if ((dev->vendor == PCI_VENDOR_ID_AMD || dev->vendor == PCI_VENDOR_ID_HYGON) &&\n\t    ((dev->device == PCI_DEVICE_ID_AMD_HUDSON2_SMBUS &&\n\t     dev->revision >= 0x41) ||\n\t    (dev->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS &&\n\t     dev->revision >= 0x49))) {\n\t\treturn efch;\n\t}\n\treturn sb800;\n}\n\nstatic int tco_timer_start(struct watchdog_device *wdd)\n{\n\tstruct sp5100_tco *tco = watchdog_get_drvdata(wdd);\n\tu32 val;\n\n\tval = readl(SP5100_WDT_CONTROL(tco->tcobase));\n\tval |= SP5100_WDT_START_STOP_BIT;\n\twritel(val, SP5100_WDT_CONTROL(tco->tcobase));\n\n\t \n\tval |= SP5100_WDT_TRIGGER_BIT;\n\twritel(val, SP5100_WDT_CONTROL(tco->tcobase));\n\n\treturn 0;\n}\n\nstatic int tco_timer_stop(struct watchdog_device *wdd)\n{\n\tstruct sp5100_tco *tco = watchdog_get_drvdata(wdd);\n\tu32 val;\n\n\tval = readl(SP5100_WDT_CONTROL(tco->tcobase));\n\tval &= ~SP5100_WDT_START_STOP_BIT;\n\twritel(val, SP5100_WDT_CONTROL(tco->tcobase));\n\n\treturn 0;\n}\n\nstatic int tco_timer_ping(struct watchdog_device *wdd)\n{\n\tstruct sp5100_tco *tco = watchdog_get_drvdata(wdd);\n\tu32 val;\n\n\tval = readl(SP5100_WDT_CONTROL(tco->tcobase));\n\tval |= SP5100_WDT_TRIGGER_BIT;\n\twritel(val, SP5100_WDT_CONTROL(tco->tcobase));\n\n\treturn 0;\n}\n\nstatic int tco_timer_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t unsigned int t)\n{\n\tstruct sp5100_tco *tco = watchdog_get_drvdata(wdd);\n\n\t \n\twritel(t, SP5100_WDT_COUNT(tco->tcobase));\n\n\twdd->timeout = t;\n\n\treturn 0;\n}\n\nstatic unsigned int tco_timer_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct sp5100_tco *tco = watchdog_get_drvdata(wdd);\n\n\treturn readl(SP5100_WDT_COUNT(tco->tcobase));\n}\n\nstatic u8 sp5100_tco_read_pm_reg8(u8 index)\n{\n\toutb(index, SP5100_IO_PM_INDEX_REG);\n\treturn inb(SP5100_IO_PM_DATA_REG);\n}\n\nstatic void sp5100_tco_update_pm_reg8(u8 index, u8 reset, u8 set)\n{\n\tu8 val;\n\n\toutb(index, SP5100_IO_PM_INDEX_REG);\n\tval = inb(SP5100_IO_PM_DATA_REG);\n\tval &= reset;\n\tval |= set;\n\toutb(val, SP5100_IO_PM_DATA_REG);\n}\n\nstatic void tco_timer_enable(struct sp5100_tco *tco)\n{\n\tu32 val;\n\n\tswitch (tco->tco_reg_layout) {\n\tcase sb800:\n\t\t \n\t\t \n\t\tsp5100_tco_update_pm_reg8(SB800_PM_WATCHDOG_CONFIG,\n\t\t\t\t\t  0xff, SB800_PM_WATCHDOG_SECOND_RES);\n\n\t\t \n\t\tsp5100_tco_update_pm_reg8(SB800_PM_WATCHDOG_CONTROL,\n\t\t\t\t\t  ~SB800_PM_WATCHDOG_DISABLE,\n\t\t\t\t\t  SB800_PCI_WATCHDOG_DECODE_EN);\n\t\tbreak;\n\tcase sp5100:\n\t\t \n\t\t \n\t\tpci_read_config_dword(sp5100_tco_pci,\n\t\t\t\t      SP5100_PCI_WATCHDOG_MISC_REG,\n\t\t\t\t      &val);\n\n\t\tval |= SP5100_PCI_WATCHDOG_DECODE_EN;\n\n\t\tpci_write_config_dword(sp5100_tco_pci,\n\t\t\t\t       SP5100_PCI_WATCHDOG_MISC_REG,\n\t\t\t\t       val);\n\n\t\t \n\t\tsp5100_tco_update_pm_reg8(SP5100_PM_WATCHDOG_CONTROL,\n\t\t\t\t\t  ~SP5100_PM_WATCHDOG_DISABLE,\n\t\t\t\t\t  SP5100_PM_WATCHDOG_SECOND_RES);\n\t\tbreak;\n\tcase efch:\n\t\t \n\t\tsp5100_tco_update_pm_reg8(EFCH_PM_DECODEEN3,\n\t\t\t\t\t  ~EFCH_PM_WATCHDOG_DISABLE,\n\t\t\t\t\t  EFCH_PM_DECODEEN_SECOND_RES);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u32 sp5100_tco_read_pm_reg32(u8 index)\n{\n\tu32 val = 0;\n\tint i;\n\n\tfor (i = 3; i >= 0; i--)\n\t\tval = (val << 8) + sp5100_tco_read_pm_reg8(index + i);\n\n\treturn val;\n}\n\nstatic u32 sp5100_tco_request_region(struct device *dev,\n\t\t\t\t     u32 mmio_addr,\n\t\t\t\t     const char *dev_name)\n{\n\tif (!devm_request_mem_region(dev, mmio_addr, SP5100_WDT_MEM_MAP_SIZE,\n\t\t\t\t     dev_name)) {\n\t\tdev_dbg(dev, \"MMIO address 0x%08x already in use\\n\", mmio_addr);\n\t\treturn 0;\n\t}\n\n\treturn mmio_addr;\n}\n\nstatic u32 sp5100_tco_prepare_base(struct sp5100_tco *tco,\n\t\t\t\t   u32 mmio_addr,\n\t\t\t\t   u32 alt_mmio_addr,\n\t\t\t\t   const char *dev_name)\n{\n\tstruct device *dev = tco->wdd.parent;\n\n\tdev_dbg(dev, \"Got 0x%08x from SBResource_MMIO register\\n\", mmio_addr);\n\n\tif (!mmio_addr && !alt_mmio_addr)\n\t\treturn -ENODEV;\n\n\t \n\tif (mmio_addr)\n\t\tmmio_addr = sp5100_tco_request_region(dev, mmio_addr, dev_name);\n\n\tif (!mmio_addr && alt_mmio_addr)\n\t\tmmio_addr = sp5100_tco_request_region(dev, alt_mmio_addr, dev_name);\n\n\tif (!mmio_addr) {\n\t\tdev_err(dev, \"Failed to reserve MMIO or alternate MMIO region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\ttco->tcobase = devm_ioremap(dev, mmio_addr, SP5100_WDT_MEM_MAP_SIZE);\n\tif (!tco->tcobase) {\n\t\tdev_err(dev, \"MMIO address 0x%08x failed mapping\\n\", mmio_addr);\n\t\tdevm_release_mem_region(dev, mmio_addr, SP5100_WDT_MEM_MAP_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_info(dev, \"Using 0x%08x for watchdog MMIO address\\n\", mmio_addr);\n\n\treturn 0;\n}\n\nstatic int sp5100_tco_timer_init(struct sp5100_tco *tco)\n{\n\tstruct watchdog_device *wdd = &tco->wdd;\n\tstruct device *dev = wdd->parent;\n\tu32 val;\n\n\tval = readl(SP5100_WDT_CONTROL(tco->tcobase));\n\tif (val & SP5100_WDT_DISABLED) {\n\t\tdev_err(dev, \"Watchdog hardware is disabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (val & SP5100_WDT_FIRED)\n\t\twdd->bootstatus = WDIOF_CARDRESET;\n\n\t \n\tif (action)\n\t\tval |= SP5100_WDT_ACTION_RESET;\n\telse\n\t\tval &= ~SP5100_WDT_ACTION_RESET;\n\twritel(val, SP5100_WDT_CONTROL(tco->tcobase));\n\n\t \n\ttco_timer_set_timeout(wdd, wdd->timeout);\n\n\t \n\ttco_timer_stop(wdd);\n\n\treturn 0;\n}\n\nstatic u8 efch_read_pm_reg8(void __iomem *addr, u8 index)\n{\n\treturn readb(addr + index);\n}\n\nstatic void efch_update_pm_reg8(void __iomem *addr, u8 index, u8 reset, u8 set)\n{\n\tu8 val;\n\n\tval = readb(addr + index);\n\tval &= reset;\n\tval |= set;\n\twriteb(val, addr + index);\n}\n\nstatic void tco_timer_enable_mmio(void __iomem *addr)\n{\n\tefch_update_pm_reg8(addr, EFCH_PM_DECODEEN3,\n\t\t\t    ~EFCH_PM_WATCHDOG_DISABLE,\n\t\t\t    EFCH_PM_DECODEEN_SECOND_RES);\n}\n\nstatic int sp5100_tco_setupdevice_mmio(struct device *dev,\n\t\t\t\t       struct watchdog_device *wdd)\n{\n\tstruct sp5100_tco *tco = watchdog_get_drvdata(wdd);\n\tconst char *dev_name = SB800_DEVNAME;\n\tu32 mmio_addr = 0, alt_mmio_addr = 0;\n\tstruct resource *res;\n\tvoid __iomem *addr;\n\tint ret;\n\tu32 val;\n\n\tres = request_mem_region_muxed(EFCH_PM_ACPI_MMIO_PM_ADDR,\n\t\t\t\t       EFCH_PM_ACPI_MMIO_PM_SIZE,\n\t\t\t\t       \"sp5100_tco\");\n\n\tif (!res) {\n\t\tdev_err(dev,\n\t\t\t\"Memory region 0x%08x already in use\\n\",\n\t\t\tEFCH_PM_ACPI_MMIO_PM_ADDR);\n\t\treturn -EBUSY;\n\t}\n\n\taddr = ioremap(EFCH_PM_ACPI_MMIO_PM_ADDR, EFCH_PM_ACPI_MMIO_PM_SIZE);\n\tif (!addr) {\n\t\tdev_err(dev, \"Address mapping failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tval = efch_read_pm_reg8(addr, EFCH_PM_DECODEEN);\n\tif (!(val & EFCH_PM_DECODEEN_WDT_TMREN)) {\n\t\tefch_update_pm_reg8(addr, EFCH_PM_DECODEEN, 0xff,\n\t\t\t\t    EFCH_PM_DECODEEN_WDT_TMREN);\n\t}\n\n\t \n\tval = efch_read_pm_reg8(addr, EFCH_PM_DECODEEN);\n\tif (!(val & EFCH_PM_DECODEEN_WDT_TMREN)) {\n\t\tdev_err(dev, \"Failed to enable the timer\\n\");\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tmmio_addr = EFCH_PM_WDT_ADDR;\n\n\t \n\tval = efch_read_pm_reg8(addr, EFCH_PM_ISACONTROL);\n\tif (val & EFCH_PM_ISACONTROL_MMIOEN)\n\t\talt_mmio_addr = EFCH_PM_ACPI_MMIO_ADDR +\n\t\t\tEFCH_PM_ACPI_MMIO_WDT_OFFSET;\n\n\tret = sp5100_tco_prepare_base(tco, mmio_addr, alt_mmio_addr, dev_name);\n\tif (!ret) {\n\t\ttco_timer_enable_mmio(addr);\n\t\tret = sp5100_tco_timer_init(tco);\n\t}\n\nout:\n\tif (addr)\n\t\tiounmap(addr);\n\n\trelease_resource(res);\n\tkfree(res);\n\n\treturn ret;\n}\n\nstatic int sp5100_tco_setupdevice(struct device *dev,\n\t\t\t\t  struct watchdog_device *wdd)\n{\n\tstruct sp5100_tco *tco = watchdog_get_drvdata(wdd);\n\tconst char *dev_name;\n\tu32 mmio_addr = 0, val;\n\tu32 alt_mmio_addr = 0;\n\tint ret;\n\n\tif (tco->tco_reg_layout == efch_mmio)\n\t\treturn sp5100_tco_setupdevice_mmio(dev, wdd);\n\n\t \n\tif (!request_muxed_region(SP5100_IO_PM_INDEX_REG,\n\t\t\t\t  SP5100_PM_IOPORTS_SIZE, \"sp5100_tco\")) {\n\t\tdev_err(dev, \"I/O address 0x%04x already in use\\n\",\n\t\t\tSP5100_IO_PM_INDEX_REG);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tswitch (tco->tco_reg_layout) {\n\tcase sp5100:\n\t\tdev_name = SP5100_DEVNAME;\n\t\tmmio_addr = sp5100_tco_read_pm_reg32(SP5100_PM_WATCHDOG_BASE) &\n\t\t\t\t\t\t\t\t0xfffffff8;\n\n\t\t \n\n\t\t \n\t\tpci_read_config_dword(sp5100_tco_pci,\n\t\t\t\t      SP5100_SB_RESOURCE_MMIO_BASE,\n\t\t\t\t      &val);\n\n\t\t \n\t\tif ((val & SB800_ACPI_MMIO_MASK) == SB800_ACPI_MMIO_DECODE_EN)\n\t\t\talt_mmio_addr = (val & ~0xfff) + SB800_PM_WDT_MMIO_OFFSET;\n\t\tbreak;\n\tcase sb800:\n\t\tdev_name = SB800_DEVNAME;\n\t\tmmio_addr = sp5100_tco_read_pm_reg32(SB800_PM_WATCHDOG_BASE) &\n\t\t\t\t\t\t\t\t0xfffffff8;\n\n\t\t \n\t\tval = sp5100_tco_read_pm_reg32(SB800_PM_ACPI_MMIO_EN);\n\n\t\t \n\t\tif ((val & SB800_ACPI_MMIO_MASK) == SB800_ACPI_MMIO_DECODE_EN)\n\t\t\talt_mmio_addr = (val & ~0xfff) + SB800_PM_WDT_MMIO_OFFSET;\n\t\tbreak;\n\tcase efch:\n\t\tdev_name = SB800_DEVNAME;\n\t\tval = sp5100_tco_read_pm_reg8(EFCH_PM_DECODEEN);\n\t\tif (val & EFCH_PM_DECODEEN_WDT_TMREN)\n\t\t\tmmio_addr = EFCH_PM_WDT_ADDR;\n\n\t\tval = sp5100_tco_read_pm_reg8(EFCH_PM_ISACONTROL);\n\t\tif (val & EFCH_PM_ISACONTROL_MMIOEN)\n\t\t\talt_mmio_addr = EFCH_PM_ACPI_MMIO_ADDR +\n\t\t\t\tEFCH_PM_ACPI_MMIO_WDT_OFFSET;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tret = sp5100_tco_prepare_base(tco, mmio_addr, alt_mmio_addr, dev_name);\n\tif (!ret) {\n\t\t \n\t\ttco_timer_enable(tco);\n\t\tret = sp5100_tco_timer_init(tco);\n\t}\n\n\trelease_region(SP5100_IO_PM_INDEX_REG, SP5100_PM_IOPORTS_SIZE);\n\treturn ret;\n}\n\nstatic struct watchdog_info sp5100_tco_wdt_info = {\n\t.identity = \"SP5100 TCO timer\",\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops sp5100_tco_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = tco_timer_start,\n\t.stop = tco_timer_stop,\n\t.ping = tco_timer_ping,\n\t.set_timeout = tco_timer_set_timeout,\n\t.get_timeleft = tco_timer_get_timeleft,\n};\n\nstatic int sp5100_tco_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct sp5100_tco *tco;\n\tint ret;\n\n\ttco = devm_kzalloc(dev, sizeof(*tco), GFP_KERNEL);\n\tif (!tco)\n\t\treturn -ENOMEM;\n\n\ttco->tco_reg_layout = tco_reg_layout(sp5100_tco_pci);\n\n\twdd = &tco->wdd;\n\twdd->parent = dev;\n\twdd->info = &sp5100_tco_wdt_info;\n\twdd->ops = &sp5100_tco_wdt_ops;\n\twdd->timeout = WATCHDOG_HEARTBEAT;\n\twdd->min_timeout = 1;\n\twdd->max_timeout = 0xffff;\n\n\twatchdog_init_timeout(wdd, heartbeat, NULL);\n\twatchdog_set_nowayout(wdd, nowayout);\n\twatchdog_stop_on_reboot(wdd);\n\twatchdog_stop_on_unregister(wdd);\n\twatchdog_set_drvdata(wdd, tco);\n\n\tret = sp5100_tco_setupdevice(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdev_info(dev, \"initialized. heartbeat=%d sec (nowayout=%d)\\n\",\n\t\t wdd->timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sp5100_tco_driver = {\n\t.probe\t\t= sp5100_tco_probe,\n\t.driver\t\t= {\n\t\t.name\t= TCO_DRIVER_NAME,\n\t},\n};\n\n \nstatic const struct pci_device_id sp5100_tco_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS, PCI_ANY_ID,\n\t  PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_HUDSON2_SMBUS, PCI_ANY_ID,\n\t  PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_KERNCZ_SMBUS, PCI_ANY_ID,\n\t  PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_HYGON, PCI_DEVICE_ID_AMD_KERNCZ_SMBUS, PCI_ANY_ID,\n\t  PCI_ANY_ID, },\n\t{ 0, },\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, sp5100_tco_pci_tbl);\n\nstatic int __init sp5100_tco_init(void)\n{\n\tstruct pci_dev *dev = NULL;\n\tint err;\n\n\t \n\tfor_each_pci_dev(dev) {\n\t\tif (pci_match_id(sp5100_tco_pci_tbl, dev) != NULL) {\n\t\t\tsp5100_tco_pci = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!sp5100_tco_pci)\n\t\treturn -ENODEV;\n\n\tpr_info(\"SP5100/SB800 TCO WatchDog Timer Driver\\n\");\n\n\terr = platform_driver_register(&sp5100_tco_driver);\n\tif (err)\n\t\treturn err;\n\n\tsp5100_tco_platform_device =\n\t\tplatform_device_register_simple(TCO_DRIVER_NAME, -1, NULL, 0);\n\tif (IS_ERR(sp5100_tco_platform_device)) {\n\t\terr = PTR_ERR(sp5100_tco_platform_device);\n\t\tgoto unreg_platform_driver;\n\t}\n\n\treturn 0;\n\nunreg_platform_driver:\n\tplatform_driver_unregister(&sp5100_tco_driver);\n\treturn err;\n}\n\nstatic void __exit sp5100_tco_exit(void)\n{\n\tplatform_device_unregister(sp5100_tco_platform_device);\n\tplatform_driver_unregister(&sp5100_tco_driver);\n}\n\nmodule_init(sp5100_tco_init);\nmodule_exit(sp5100_tco_exit);\n\nMODULE_AUTHOR(\"Priyanka Gupta\");\nMODULE_DESCRIPTION(\"TCO timer driver for SP5100/SB800 chipset\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}