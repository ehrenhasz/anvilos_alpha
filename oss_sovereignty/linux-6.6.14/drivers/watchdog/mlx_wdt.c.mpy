{
  "module_name": "mlx_wdt.c",
  "hash_id": "d45f5cea8890c1f20f201c7529c49c6843e8c4d4af599b3dd7f144a3a0838b9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/mlx_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/platform_data/mlxreg.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#define MLXREG_WDT_CLOCK_SCALE\t\t1000\n#define MLXREG_WDT_MAX_TIMEOUT_TYPE1\t32\n#define MLXREG_WDT_MAX_TIMEOUT_TYPE2\t255\n#define MLXREG_WDT_MAX_TIMEOUT_TYPE3\t65535\n#define MLXREG_WDT_MIN_TIMEOUT\t\t1\n#define MLXREG_WDT_OPTIONS_BASE (WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE | \\\n\t\t\t\t WDIOF_SETTIMEOUT)\n\n \nstruct mlxreg_wdt {\n\tstruct watchdog_device wdd;\n\tstruct mlxreg_core_platform_data *pdata;\n\tvoid *regmap;\n\tint action_idx;\n\tint timeout_idx;\n\tint tleft_idx;\n\tint ping_idx;\n\tint reset_idx;\n\tint regmap_val_sz;\n\tenum mlxreg_wdt_type wdt_type;\n};\n\nstatic void mlxreg_wdt_check_card_reset(struct mlxreg_wdt *wdt)\n{\n\tstruct mlxreg_core_data *reg_data;\n\tu32 regval;\n\tint rc;\n\n\tif (wdt->reset_idx == -EINVAL)\n\t\treturn;\n\n\tif (!(wdt->wdd.info->options & WDIOF_CARDRESET))\n\t\treturn;\n\n\treg_data = &wdt->pdata->data[wdt->reset_idx];\n\trc = regmap_read(wdt->regmap, reg_data->reg, &regval);\n\tif (!rc) {\n\t\tif (regval & ~reg_data->mask) {\n\t\t\twdt->wdd.bootstatus = WDIOF_CARDRESET;\n\t\t\tdev_info(wdt->wdd.parent,\n\t\t\t\t \"watchdog previously reset the CPU\\n\");\n\t\t}\n\t}\n}\n\nstatic int mlxreg_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);\n\tstruct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->action_idx];\n\n\treturn regmap_update_bits(wdt->regmap, reg_data->reg, ~reg_data->mask,\n\t\t\t\t  BIT(reg_data->bit));\n}\n\nstatic int mlxreg_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);\n\tstruct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->action_idx];\n\n\treturn regmap_update_bits(wdt->regmap, reg_data->reg, ~reg_data->mask,\n\t\t\t\t  ~BIT(reg_data->bit));\n}\n\nstatic int mlxreg_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);\n\tstruct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->ping_idx];\n\n\treturn regmap_write_bits(wdt->regmap, reg_data->reg, ~reg_data->mask,\n\t\t\t\t BIT(reg_data->bit));\n}\n\nstatic int mlxreg_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);\n\tstruct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->timeout_idx];\n\tu32 regval, set_time, hw_timeout;\n\tint rc;\n\n\tswitch (wdt->wdt_type) {\n\tcase MLX_WDT_TYPE1:\n\t\trc = regmap_read(wdt->regmap, reg_data->reg, &regval);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\thw_timeout = order_base_2(timeout * MLXREG_WDT_CLOCK_SCALE);\n\t\tregval = (regval & reg_data->mask) | hw_timeout;\n\t\t \n\t\tset_time = BIT(hw_timeout) / MLXREG_WDT_CLOCK_SCALE;\n\t\trc = regmap_write(wdt->regmap, reg_data->reg, regval);\n\t\tbreak;\n\tcase MLX_WDT_TYPE2:\n\t\tset_time = timeout;\n\t\trc = regmap_write(wdt->regmap, reg_data->reg, timeout);\n\t\tbreak;\n\tcase MLX_WDT_TYPE3:\n\t\t \n\t\tset_time = timeout;\n\t\tif (wdt->regmap_val_sz == 1) {\n\t\t\tregval = timeout & 0xff;\n\t\t\trc = regmap_write(wdt->regmap, reg_data->reg, regval);\n\t\t\tif (!rc) {\n\t\t\t\tregval = (timeout & 0xff00) >> 8;\n\t\t\t\trc = regmap_write(wdt->regmap,\n\t\t\t\t\t\treg_data->reg + 1, regval);\n\t\t\t}\n\t\t} else {\n\t\t\trc = regmap_write(wdt->regmap, reg_data->reg, timeout);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twdd->timeout = set_time;\n\tif (!rc) {\n\t\t \n\t\tif (watchdog_active(wdd)) {\n\t\t\trc = mlxreg_wdt_stop(wdd);\n\t\t\tif (!rc)\n\t\t\t\trc = mlxreg_wdt_start(wdd);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic unsigned int mlxreg_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct mlxreg_wdt *wdt = watchdog_get_drvdata(wdd);\n\tstruct mlxreg_core_data *reg_data = &wdt->pdata->data[wdt->tleft_idx];\n\tu32 regval, msb, lsb;\n\tint rc;\n\n\tif (wdt->wdt_type == MLX_WDT_TYPE2) {\n\t\trc = regmap_read(wdt->regmap, reg_data->reg, &regval);\n\t} else {\n\t\t \n\t\tif (wdt->regmap_val_sz == 1) {\n\t\t\trc = regmap_read(wdt->regmap, reg_data->reg, &lsb);\n\t\t\tif (!rc) {\n\t\t\t\trc = regmap_read(wdt->regmap,\n\t\t\t\t\t\treg_data->reg + 1, &msb);\n\t\t\t\tregval = (msb & 0xff) << 8 | (lsb & 0xff);\n\t\t\t}\n\t\t} else {\n\t\t\trc = regmap_read(wdt->regmap, reg_data->reg, &regval);\n\t\t}\n\t}\n\n\t \n\treturn rc == 0 ? regval : 0;\n}\n\nstatic const struct watchdog_ops mlxreg_wdt_ops_type1 = {\n\t.start\t\t= mlxreg_wdt_start,\n\t.stop\t\t= mlxreg_wdt_stop,\n\t.ping\t\t= mlxreg_wdt_ping,\n\t.set_timeout\t= mlxreg_wdt_set_timeout,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct watchdog_ops mlxreg_wdt_ops_type2 = {\n\t.start\t\t= mlxreg_wdt_start,\n\t.stop\t\t= mlxreg_wdt_stop,\n\t.ping\t\t= mlxreg_wdt_ping,\n\t.set_timeout\t= mlxreg_wdt_set_timeout,\n\t.get_timeleft\t= mlxreg_wdt_get_timeleft,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct watchdog_info mlxreg_wdt_main_info = {\n\t.options\t= MLXREG_WDT_OPTIONS_BASE\n\t\t\t| WDIOF_CARDRESET,\n\t.identity\t= \"mlx-wdt-main\",\n};\n\nstatic const struct watchdog_info mlxreg_wdt_aux_info = {\n\t.options\t= MLXREG_WDT_OPTIONS_BASE\n\t\t\t| WDIOF_ALARMONLY,\n\t.identity\t= \"mlx-wdt-aux\",\n};\n\nstatic void mlxreg_wdt_config(struct mlxreg_wdt *wdt,\n\t\t\t      struct mlxreg_core_platform_data *pdata)\n{\n\tstruct mlxreg_core_data *data = pdata->data;\n\tint i;\n\n\twdt->reset_idx = -EINVAL;\n\tfor (i = 0; i < pdata->counter; i++, data++) {\n\t\tif (strnstr(data->label, \"action\", sizeof(data->label)))\n\t\t\twdt->action_idx = i;\n\t\telse if (strnstr(data->label, \"timeout\", sizeof(data->label)))\n\t\t\twdt->timeout_idx = i;\n\t\telse if (strnstr(data->label, \"timeleft\", sizeof(data->label)))\n\t\t\twdt->tleft_idx = i;\n\t\telse if (strnstr(data->label, \"ping\", sizeof(data->label)))\n\t\t\twdt->ping_idx = i;\n\t\telse if (strnstr(data->label, \"reset\", sizeof(data->label)))\n\t\t\twdt->reset_idx = i;\n\t}\n\n\twdt->pdata = pdata;\n\tif (strnstr(pdata->identity, mlxreg_wdt_main_info.identity,\n\t\t    sizeof(mlxreg_wdt_main_info.identity)))\n\t\twdt->wdd.info = &mlxreg_wdt_main_info;\n\telse\n\t\twdt->wdd.info = &mlxreg_wdt_aux_info;\n\n\twdt->wdt_type = pdata->version;\n\tswitch (wdt->wdt_type) {\n\tcase MLX_WDT_TYPE1:\n\t\twdt->wdd.ops = &mlxreg_wdt_ops_type1;\n\t\twdt->wdd.max_timeout = MLXREG_WDT_MAX_TIMEOUT_TYPE1;\n\t\tbreak;\n\tcase MLX_WDT_TYPE2:\n\t\twdt->wdd.ops = &mlxreg_wdt_ops_type2;\n\t\twdt->wdd.max_timeout = MLXREG_WDT_MAX_TIMEOUT_TYPE2;\n\t\tbreak;\n\tcase MLX_WDT_TYPE3:\n\t\twdt->wdd.ops = &mlxreg_wdt_ops_type2;\n\t\twdt->wdd.max_timeout = MLXREG_WDT_MAX_TIMEOUT_TYPE3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twdt->wdd.min_timeout = MLXREG_WDT_MIN_TIMEOUT;\n}\n\nstatic int mlxreg_wdt_init_timeout(struct mlxreg_wdt *wdt,\n\t\t\t\t   struct mlxreg_core_platform_data *pdata)\n{\n\tu32 timeout;\n\n\ttimeout = pdata->data[wdt->timeout_idx].health_cntr;\n\treturn mlxreg_wdt_set_timeout(&wdt->wdd, timeout);\n}\n\nstatic int mlxreg_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mlxreg_core_platform_data *pdata;\n\tstruct mlxreg_wdt *wdt;\n\tint rc;\n\n\tpdata = dev_get_platdata(dev);\n\tif (!pdata) {\n\t\tdev_err(dev, \"Failed to get platform data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->wdd.parent = dev;\n\twdt->regmap = pdata->regmap;\n\trc = regmap_get_val_bytes(wdt->regmap);\n\tif (rc < 0)\n\t\treturn -EINVAL;\n\n\twdt->regmap_val_sz = rc;\n\tmlxreg_wdt_config(wdt, pdata);\n\n\tif ((pdata->features & MLXREG_CORE_WD_FEATURE_NOWAYOUT))\n\t\twatchdog_set_nowayout(&wdt->wdd, WATCHDOG_NOWAYOUT);\n\twatchdog_stop_on_reboot(&wdt->wdd);\n\twatchdog_stop_on_unregister(&wdt->wdd);\n\twatchdog_set_drvdata(&wdt->wdd, wdt);\n\trc = mlxreg_wdt_init_timeout(wdt, pdata);\n\tif (rc)\n\t\tgoto register_error;\n\n\tif ((pdata->features & MLXREG_CORE_WD_FEATURE_START_AT_BOOT)) {\n\t\trc = mlxreg_wdt_start(&wdt->wdd);\n\t\tif (rc)\n\t\t\tgoto register_error;\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdd.status);\n\t}\n\tmlxreg_wdt_check_card_reset(wdt);\n\trc = devm_watchdog_register_device(dev, &wdt->wdd);\n\nregister_error:\n\tif (rc)\n\t\tdev_err(dev, \"Cannot register watchdog device (err=%d)\\n\", rc);\n\treturn rc;\n}\n\nstatic struct platform_driver mlxreg_wdt_driver = {\n\t.probe\t= mlxreg_wdt_probe,\n\t.driver\t= {\n\t\t\t.name = \"mlx-wdt\",\n\t},\n};\n\nmodule_platform_driver(mlxreg_wdt_driver);\n\nMODULE_AUTHOR(\"Michael Shych <michaelsh@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox watchdog driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mlx-wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}