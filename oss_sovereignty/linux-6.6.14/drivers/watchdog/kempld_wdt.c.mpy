{
  "module_name": "kempld_wdt.c",
  "hash_id": "06311b46b9c9b770059088adbdf801317509ecffafa7768f902d03b6eb9a57a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/kempld_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/uaccess.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/kempld.h>\n\n#define KEMPLD_WDT_STAGE_TIMEOUT(x)\t(0x1b + (x) * 4)\n#define KEMPLD_WDT_STAGE_CFG(x)\t\t(0x18 + (x))\n#define STAGE_CFG_GET_PRESCALER(x)\t(((x) & 0x30) >> 4)\n#define STAGE_CFG_SET_PRESCALER(x)\t(((x) & 0x3) << 4)\n#define STAGE_CFG_PRESCALER_MASK\t0x30\n#define STAGE_CFG_ACTION_MASK\t\t0x7\n#define STAGE_CFG_ASSERT\t\t(1 << 3)\n\n#define KEMPLD_WDT_MAX_STAGES\t\t2\n#define KEMPLD_WDT_KICK\t\t\t0x16\n#define KEMPLD_WDT_CFG\t\t\t0x17\n#define KEMPLD_WDT_CFG_ENABLE\t\t0x10\n#define KEMPLD_WDT_CFG_ENABLE_LOCK\t0x8\n#define KEMPLD_WDT_CFG_GLOBAL_LOCK\t0x80\n\nenum {\n\tACTION_NONE = 0,\n\tACTION_RESET,\n\tACTION_NMI,\n\tACTION_SMI,\n\tACTION_SCI,\n\tACTION_DELAY,\n};\n\nenum {\n\tSTAGE_TIMEOUT = 0,\n\tSTAGE_PRETIMEOUT,\n};\n\nenum {\n\tPRESCALER_21 = 0,\n\tPRESCALER_17,\n\tPRESCALER_12,\n};\n\nstatic const u32 kempld_prescaler[] = {\n\t[PRESCALER_21] = (1 << 21) - 1,\n\t[PRESCALER_17] = (1 << 17) - 1,\n\t[PRESCALER_12] = (1 << 12) - 1,\n\t0,\n};\n\nstruct kempld_wdt_stage {\n\tunsigned int\tid;\n\tu32\t\tmask;\n};\n\nstruct kempld_wdt_data {\n\tstruct kempld_device_data\t*pld;\n\tstruct watchdog_device\t\twdd;\n\tunsigned int\t\t\tpretimeout;\n\tstruct kempld_wdt_stage\t\tstage[KEMPLD_WDT_MAX_STAGES];\n\tu8\t\t\t\tpm_status_store;\n};\n\n#define DEFAULT_TIMEOUT\t\t30  \n#define DEFAULT_PRETIMEOUT\t0\n\nstatic unsigned int timeout = DEFAULT_TIMEOUT;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout,\n\t\"Watchdog timeout in seconds. (>=0, default=\"\n\t__MODULE_STRING(DEFAULT_TIMEOUT) \")\");\n\nstatic unsigned int pretimeout = DEFAULT_PRETIMEOUT;\nmodule_param(pretimeout, uint, 0);\nMODULE_PARM_DESC(pretimeout,\n\t\"Watchdog pretimeout in seconds. (>=0, default=\"\n\t__MODULE_STRING(DEFAULT_PRETIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int kempld_wdt_set_stage_action(struct kempld_wdt_data *wdt_data,\n\t\t\t\t\tstruct kempld_wdt_stage *stage,\n\t\t\t\t\tu8 action)\n{\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\tu8 stage_cfg;\n\n\tif (!stage || !stage->mask)\n\t\treturn -EINVAL;\n\n\tkempld_get_mutex(pld);\n\tstage_cfg = kempld_read8(pld, KEMPLD_WDT_STAGE_CFG(stage->id));\n\tstage_cfg &= ~STAGE_CFG_ACTION_MASK;\n\tstage_cfg |= (action & STAGE_CFG_ACTION_MASK);\n\n\tif (action == ACTION_RESET)\n\t\tstage_cfg |= STAGE_CFG_ASSERT;\n\telse\n\t\tstage_cfg &= ~STAGE_CFG_ASSERT;\n\n\tkempld_write8(pld, KEMPLD_WDT_STAGE_CFG(stage->id), stage_cfg);\n\tkempld_release_mutex(pld);\n\n\treturn 0;\n}\n\nstatic int kempld_wdt_set_stage_timeout(struct kempld_wdt_data *wdt_data,\n\t\t\t\t\tstruct kempld_wdt_stage *stage,\n\t\t\t\t\tunsigned int timeout)\n{\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\tu32 prescaler;\n\tu64 stage_timeout64;\n\tu32 stage_timeout;\n\tu32 remainder;\n\tu8 stage_cfg;\n\n\tprescaler = kempld_prescaler[PRESCALER_21];\n\n\tif (!stage)\n\t\treturn -EINVAL;\n\n\tstage_timeout64 = (u64)timeout * pld->pld_clock;\n\tremainder = do_div(stage_timeout64, prescaler);\n\tif (remainder)\n\t\tstage_timeout64++;\n\n\tif (stage_timeout64 > stage->mask)\n\t\treturn -EINVAL;\n\n\tstage_timeout = stage_timeout64 & stage->mask;\n\n\tkempld_get_mutex(pld);\n\tstage_cfg = kempld_read8(pld, KEMPLD_WDT_STAGE_CFG(stage->id));\n\tstage_cfg &= ~STAGE_CFG_PRESCALER_MASK;\n\tstage_cfg |= STAGE_CFG_SET_PRESCALER(PRESCALER_21);\n\tkempld_write8(pld, KEMPLD_WDT_STAGE_CFG(stage->id), stage_cfg);\n\tkempld_write32(pld, KEMPLD_WDT_STAGE_TIMEOUT(stage->id),\n\t\t\tstage_timeout);\n\tkempld_release_mutex(pld);\n\n\treturn 0;\n}\n\n \nstatic unsigned int kempld_wdt_get_timeout(struct kempld_wdt_data *wdt_data,\n\t\t\t\t\t\tstruct kempld_wdt_stage *stage)\n{\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\tunsigned int timeout;\n\tu64 stage_timeout;\n\tu32 prescaler;\n\tu32 remainder;\n\tu8 stage_cfg;\n\n\tif (!stage->mask)\n\t\treturn 0;\n\n\tstage_cfg = kempld_read8(pld, KEMPLD_WDT_STAGE_CFG(stage->id));\n\tstage_timeout = kempld_read32(pld, KEMPLD_WDT_STAGE_TIMEOUT(stage->id));\n\tprescaler = kempld_prescaler[STAGE_CFG_GET_PRESCALER(stage_cfg)];\n\n\tstage_timeout = (stage_timeout & stage->mask) * prescaler;\n\tremainder = do_div(stage_timeout, pld->pld_clock);\n\tif (remainder)\n\t\tstage_timeout++;\n\n\ttimeout = stage_timeout;\n\tWARN_ON_ONCE(timeout != stage_timeout);\n\n\treturn timeout;\n}\n\nstatic int kempld_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t\tunsigned int timeout)\n{\n\tstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\n\tstruct kempld_wdt_stage *pretimeout_stage;\n\tstruct kempld_wdt_stage *timeout_stage;\n\tint ret;\n\n\ttimeout_stage = &wdt_data->stage[STAGE_TIMEOUT];\n\tpretimeout_stage = &wdt_data->stage[STAGE_PRETIMEOUT];\n\n\tif (pretimeout_stage->mask && wdt_data->pretimeout > 0)\n\t\ttimeout = wdt_data->pretimeout;\n\n\tret = kempld_wdt_set_stage_action(wdt_data, timeout_stage,\n\t\t\t\t\t\tACTION_RESET);\n\tif (ret)\n\t\treturn ret;\n\tret = kempld_wdt_set_stage_timeout(wdt_data, timeout_stage,\n\t\t\t\t\t\ttimeout);\n\tif (ret)\n\t\treturn ret;\n\n\twdd->timeout = timeout;\n\treturn 0;\n}\n\nstatic int kempld_wdt_set_pretimeout(struct watchdog_device *wdd,\n\t\t\t\t\tunsigned int pretimeout)\n{\n\tstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\n\tstruct kempld_wdt_stage *pretimeout_stage;\n\tu8 action = ACTION_NONE;\n\tint ret;\n\n\tpretimeout_stage = &wdt_data->stage[STAGE_PRETIMEOUT];\n\n\tif (!pretimeout_stage->mask)\n\t\treturn -ENXIO;\n\n\tif (pretimeout > wdd->timeout)\n\t\treturn -EINVAL;\n\n\tif (pretimeout > 0)\n\t\taction = ACTION_NMI;\n\n\tret = kempld_wdt_set_stage_action(wdt_data, pretimeout_stage,\n\t\t\t\t\t\taction);\n\tif (ret)\n\t\treturn ret;\n\tret = kempld_wdt_set_stage_timeout(wdt_data, pretimeout_stage,\n\t\t\t\t\t\twdd->timeout - pretimeout);\n\tif (ret)\n\t\treturn ret;\n\n\twdt_data->pretimeout = pretimeout;\n\treturn 0;\n}\n\nstatic void kempld_wdt_update_timeouts(struct kempld_wdt_data *wdt_data)\n{\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\tstruct kempld_wdt_stage *pretimeout_stage;\n\tstruct kempld_wdt_stage *timeout_stage;\n\tunsigned int pretimeout, timeout;\n\n\tpretimeout_stage = &wdt_data->stage[STAGE_PRETIMEOUT];\n\ttimeout_stage = &wdt_data->stage[STAGE_TIMEOUT];\n\n\tkempld_get_mutex(pld);\n\tpretimeout = kempld_wdt_get_timeout(wdt_data, pretimeout_stage);\n\ttimeout = kempld_wdt_get_timeout(wdt_data, timeout_stage);\n\tkempld_release_mutex(pld);\n\n\tif (pretimeout)\n\t\twdt_data->pretimeout = timeout;\n\telse\n\t\twdt_data->pretimeout = 0;\n\n\twdt_data->wdd.timeout = pretimeout + timeout;\n}\n\nstatic int kempld_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\tu8 status;\n\tint ret;\n\n\tret = kempld_wdt_set_timeout(wdd, wdd->timeout);\n\tif (ret)\n\t\treturn ret;\n\n\tkempld_get_mutex(pld);\n\tstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\n\tstatus |= KEMPLD_WDT_CFG_ENABLE;\n\tkempld_write8(pld, KEMPLD_WDT_CFG, status);\n\tstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\n\tkempld_release_mutex(pld);\n\n\t \n\tif (!(status & KEMPLD_WDT_CFG_ENABLE))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int kempld_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\tu8 status;\n\n\tkempld_get_mutex(pld);\n\tstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\n\tstatus &= ~KEMPLD_WDT_CFG_ENABLE;\n\tkempld_write8(pld, KEMPLD_WDT_CFG, status);\n\tstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\n\tkempld_release_mutex(pld);\n\n\t \n\tif (status & KEMPLD_WDT_CFG_ENABLE)\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int kempld_wdt_keepalive(struct watchdog_device *wdd)\n{\n\tstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\n\tkempld_get_mutex(pld);\n\tkempld_write8(pld, KEMPLD_WDT_KICK, 'K');\n\tkempld_release_mutex(pld);\n\n\treturn 0;\n}\n\nstatic long kempld_wdt_ioctl(struct watchdog_device *wdd, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\n\tvoid __user *argp = (void __user *)arg;\n\tint ret = -ENOIOCTLCMD;\n\tint __user *p = argp;\n\tint new_value;\n\n\tswitch (cmd) {\n\tcase WDIOC_SETPRETIMEOUT:\n\t\tif (get_user(new_value, p))\n\t\t\treturn -EFAULT;\n\t\tret = kempld_wdt_set_pretimeout(wdd, new_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = kempld_wdt_keepalive(wdd);\n\t\tbreak;\n\tcase WDIOC_GETPRETIMEOUT:\n\t\tret = put_user(wdt_data->pretimeout, (int __user *)arg);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int kempld_wdt_probe_stages(struct watchdog_device *wdd)\n{\n\tstruct kempld_wdt_data *wdt_data = watchdog_get_drvdata(wdd);\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\tstruct kempld_wdt_stage *pretimeout_stage;\n\tstruct kempld_wdt_stage *timeout_stage;\n\tu8 index, data, data_orig;\n\tu32 mask;\n\tint i, j;\n\n\tpretimeout_stage = &wdt_data->stage[STAGE_PRETIMEOUT];\n\ttimeout_stage = &wdt_data->stage[STAGE_TIMEOUT];\n\n\tpretimeout_stage->mask = 0;\n\ttimeout_stage->mask = 0;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tindex = KEMPLD_WDT_STAGE_TIMEOUT(i);\n\t\tmask = 0;\n\n\t\tkempld_get_mutex(pld);\n\t\t \n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tdata_orig = kempld_read8(pld, index + j);\n\t\t\tkempld_write8(pld, index + j, 0x00);\n\t\t\tdata = kempld_read8(pld, index + j);\n\t\t\t \n\t\t\tif (data != 0x00)\n\t\t\t\tbreak;\n\t\t\tkempld_write8(pld, index + j, data_orig);\n\t\t\tmask |= 0xff << (j * 8);\n\t\t}\n\t\tkempld_release_mutex(pld);\n\n\t\t \n\t\tif (!timeout_stage->mask) {\n\t\t\ttimeout_stage->mask = mask;\n\t\t\ttimeout_stage->id = i;\n\t\t} else {\n\t\t\tif (pld->feature_mask & KEMPLD_FEATURE_BIT_NMI) {\n\t\t\t\tpretimeout_stage->mask = timeout_stage->mask;\n\t\t\t\ttimeout_stage->mask = mask;\n\t\t\t\tpretimeout_stage->id = timeout_stage->id;\n\t\t\t\ttimeout_stage->id = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timeout_stage->mask)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info kempld_wdt_info = {\n\t.identity\t= \"KEMPLD Watchdog\",\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\tWDIOF_KEEPALIVEPING |\n\t\t\tWDIOF_MAGICCLOSE |\n\t\t\tWDIOF_PRETIMEOUT\n};\n\nstatic const struct watchdog_ops kempld_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= kempld_wdt_start,\n\t.stop\t\t= kempld_wdt_stop,\n\t.ping\t\t= kempld_wdt_keepalive,\n\t.set_timeout\t= kempld_wdt_set_timeout,\n\t.ioctl\t\t= kempld_wdt_ioctl,\n};\n\nstatic int kempld_wdt_probe(struct platform_device *pdev)\n{\n\tstruct kempld_device_data *pld = dev_get_drvdata(pdev->dev.parent);\n\tstruct kempld_wdt_data *wdt_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tu8 status;\n\tint ret = 0;\n\n\twdt_data = devm_kzalloc(dev, sizeof(*wdt_data), GFP_KERNEL);\n\tif (!wdt_data)\n\t\treturn -ENOMEM;\n\n\twdt_data->pld = pld;\n\twdd = &wdt_data->wdd;\n\twdd->parent = dev;\n\n\tkempld_get_mutex(pld);\n\tstatus = kempld_read8(pld, KEMPLD_WDT_CFG);\n\tkempld_release_mutex(pld);\n\n\t \n\tif (status & (KEMPLD_WDT_CFG_ENABLE_LOCK |\n\t\t\tKEMPLD_WDT_CFG_GLOBAL_LOCK)) {\n\t\tif (!nowayout)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Forcing nowayout - watchdog lock enabled!\\n\");\n\t\tnowayout = true;\n\t}\n\n\twdd->info = &kempld_wdt_info;\n\twdd->ops = &kempld_wdt_ops;\n\n\twatchdog_set_drvdata(wdd, wdt_data);\n\twatchdog_set_nowayout(wdd, nowayout);\n\n\tret = kempld_wdt_probe_stages(wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tkempld_wdt_set_timeout(wdd, timeout);\n\tkempld_wdt_set_pretimeout(wdd, pretimeout);\n\n\t \n\tif (status & KEMPLD_WDT_CFG_ENABLE) {\n\t\t \n\t\tkempld_wdt_update_timeouts(wdt_data);\n\t\tdev_info(dev, \"Watchdog was already enabled\\n\");\n\t}\n\n\tplatform_set_drvdata(pdev, wdt_data);\n\twatchdog_stop_on_reboot(wdd);\n\twatchdog_stop_on_unregister(wdd);\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"Watchdog registered with %ds timeout\\n\", wdd->timeout);\n\n\treturn 0;\n}\n\n \nstatic int kempld_wdt_suspend(struct platform_device *pdev,\n\t\t\t\tpm_message_t message)\n{\n\tstruct kempld_wdt_data *wdt_data = platform_get_drvdata(pdev);\n\tstruct kempld_device_data *pld = wdt_data->pld;\n\tstruct watchdog_device *wdd = &wdt_data->wdd;\n\n\tkempld_get_mutex(pld);\n\twdt_data->pm_status_store = kempld_read8(pld, KEMPLD_WDT_CFG);\n\tkempld_release_mutex(pld);\n\n\tkempld_wdt_update_timeouts(wdt_data);\n\n\tif (wdt_data->pm_status_store & KEMPLD_WDT_CFG_ENABLE)\n\t\treturn kempld_wdt_stop(wdd);\n\n\treturn 0;\n}\n\n \nstatic int kempld_wdt_resume(struct platform_device *pdev)\n{\n\tstruct kempld_wdt_data *wdt_data = platform_get_drvdata(pdev);\n\tstruct watchdog_device *wdd = &wdt_data->wdd;\n\n\t \n\tif (wdt_data->pm_status_store & KEMPLD_WDT_CFG_ENABLE)\n\t\treturn kempld_wdt_start(wdd);\n\telse\n\t\treturn kempld_wdt_stop(wdd);\n}\n\nstatic struct platform_driver kempld_wdt_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"kempld-wdt\",\n\t},\n\t.probe\t\t= kempld_wdt_probe,\n\t.suspend\t= pm_ptr(kempld_wdt_suspend),\n\t.resume\t\t= pm_ptr(kempld_wdt_resume),\n};\n\nmodule_platform_driver(kempld_wdt_driver);\n\nMODULE_DESCRIPTION(\"KEM PLD Watchdog Driver\");\nMODULE_AUTHOR(\"Michael Brunner <michael.brunner@kontron.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}