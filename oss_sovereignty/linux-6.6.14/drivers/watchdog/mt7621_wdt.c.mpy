{
  "module_name": "mt7621_wdt.c",
  "hash_id": "ca00e25c626731c65b13b1cfe3f9242b4d53534ba59d2225bb7c160aa1004c57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/mt7621_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/watchdog.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#define SYSC_RSTSTAT\t\t\t0x38\n#define WDT_RST_CAUSE\t\t\tBIT(1)\n\n#define RALINK_WDT_TIMEOUT\t\t30\n\n#define TIMER_REG_TMRSTAT\t\t0x00\n#define TIMER_REG_TMR1LOAD\t\t0x24\n#define TIMER_REG_TMR1CTL\t\t0x20\n\n#define TMR1CTL_ENABLE\t\t\tBIT(7)\n#define TMR1CTL_RESTART\t\t\tBIT(9)\n#define TMR1CTL_PRESCALE_SHIFT\t\t16\n\nstruct mt7621_wdt_data {\n\tvoid __iomem *base;\n\tstruct reset_control *rst;\n\tstruct regmap *sysc;\n\tstruct watchdog_device wdt;\n};\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic inline void rt_wdt_w32(void __iomem *base, unsigned int reg, u32 val)\n{\n\tiowrite32(val, base + reg);\n}\n\nstatic inline u32 rt_wdt_r32(void __iomem *base, unsigned int reg)\n{\n\treturn ioread32(base + reg);\n}\n\nstatic int mt7621_wdt_ping(struct watchdog_device *w)\n{\n\tstruct mt7621_wdt_data *drvdata = watchdog_get_drvdata(w);\n\n\trt_wdt_w32(drvdata->base, TIMER_REG_TMRSTAT, TMR1CTL_RESTART);\n\n\treturn 0;\n}\n\nstatic int mt7621_wdt_set_timeout(struct watchdog_device *w, unsigned int t)\n{\n\tstruct mt7621_wdt_data *drvdata = watchdog_get_drvdata(w);\n\n\tw->timeout = t;\n\trt_wdt_w32(drvdata->base, TIMER_REG_TMR1LOAD, t * 1000);\n\tmt7621_wdt_ping(w);\n\n\treturn 0;\n}\n\nstatic int mt7621_wdt_start(struct watchdog_device *w)\n{\n\tstruct mt7621_wdt_data *drvdata = watchdog_get_drvdata(w);\n\tu32 t;\n\n\t \n\trt_wdt_w32(drvdata->base, TIMER_REG_TMR1CTL, 1000 << TMR1CTL_PRESCALE_SHIFT);\n\n\tmt7621_wdt_set_timeout(w, w->timeout);\n\n\tt = rt_wdt_r32(drvdata->base, TIMER_REG_TMR1CTL);\n\tt |= TMR1CTL_ENABLE;\n\trt_wdt_w32(drvdata->base, TIMER_REG_TMR1CTL, t);\n\n\treturn 0;\n}\n\nstatic int mt7621_wdt_stop(struct watchdog_device *w)\n{\n\tstruct mt7621_wdt_data *drvdata = watchdog_get_drvdata(w);\n\tu32 t;\n\n\tmt7621_wdt_ping(w);\n\n\tt = rt_wdt_r32(drvdata->base, TIMER_REG_TMR1CTL);\n\tt &= ~TMR1CTL_ENABLE;\n\trt_wdt_w32(drvdata->base, TIMER_REG_TMR1CTL, t);\n\n\treturn 0;\n}\n\nstatic int mt7621_wdt_bootcause(struct mt7621_wdt_data *d)\n{\n\tu32 val;\n\n\tregmap_read(d->sysc, SYSC_RSTSTAT, &val);\n\tif (val & WDT_RST_CAUSE)\n\t\treturn WDIOF_CARDRESET;\n\n\treturn 0;\n}\n\nstatic int mt7621_wdt_is_running(struct watchdog_device *w)\n{\n\tstruct mt7621_wdt_data *drvdata = watchdog_get_drvdata(w);\n\n\treturn !!(rt_wdt_r32(drvdata->base, TIMER_REG_TMR1CTL) & TMR1CTL_ENABLE);\n}\n\nstatic const struct watchdog_info mt7621_wdt_info = {\n\t.identity = \"Mediatek Watchdog\",\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops mt7621_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = mt7621_wdt_start,\n\t.stop = mt7621_wdt_stop,\n\t.ping = mt7621_wdt_ping,\n\t.set_timeout = mt7621_wdt_set_timeout,\n};\n\nstatic int mt7621_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *mt7621_wdt;\n\tstruct mt7621_wdt_data *drvdata;\n\tint err;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->sysc = syscon_regmap_lookup_by_phandle(np, \"mediatek,sysctl\");\n\tif (IS_ERR(drvdata->sysc)) {\n\t\tdrvdata->sysc = syscon_regmap_lookup_by_compatible(\"mediatek,mt7621-sysc\");\n\t\tif (IS_ERR(drvdata->sysc))\n\t\t\treturn PTR_ERR(drvdata->sysc);\n\t}\n\n\tdrvdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drvdata->base))\n\t\treturn PTR_ERR(drvdata->base);\n\n\tdrvdata->rst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (!IS_ERR(drvdata->rst))\n\t\treset_control_deassert(drvdata->rst);\n\n\tmt7621_wdt = &drvdata->wdt;\n\tmt7621_wdt->info = &mt7621_wdt_info;\n\tmt7621_wdt->ops = &mt7621_wdt_ops;\n\tmt7621_wdt->min_timeout = 1;\n\tmt7621_wdt->max_timeout = 0xfffful / 1000;\n\tmt7621_wdt->parent = dev;\n\n\tmt7621_wdt->bootstatus = mt7621_wdt_bootcause(drvdata);\n\n\twatchdog_init_timeout(mt7621_wdt, mt7621_wdt->max_timeout, dev);\n\twatchdog_set_nowayout(mt7621_wdt, nowayout);\n\twatchdog_set_drvdata(mt7621_wdt, drvdata);\n\n\tif (mt7621_wdt_is_running(mt7621_wdt)) {\n\t\t \n\t\tmt7621_wdt_stop(mt7621_wdt);\n\t\tmt7621_wdt_start(mt7621_wdt);\n\t\tset_bit(WDOG_HW_RUNNING, &mt7621_wdt->status);\n\t}\n\n\terr = devm_watchdog_register_device(dev, &drvdata->wdt);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\treturn 0;\n}\n\nstatic void mt7621_wdt_shutdown(struct platform_device *pdev)\n{\n\tstruct mt7621_wdt_data *drvdata = platform_get_drvdata(pdev);\n\n\tmt7621_wdt_stop(&drvdata->wdt);\n}\n\nstatic const struct of_device_id mt7621_wdt_match[] = {\n\t{ .compatible = \"mediatek,mt7621-wdt\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mt7621_wdt_match);\n\nstatic struct platform_driver mt7621_wdt_driver = {\n\t.probe\t\t= mt7621_wdt_probe,\n\t.shutdown\t= mt7621_wdt_shutdown,\n\t.driver\t\t= {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= mt7621_wdt_match,\n\t},\n};\n\nmodule_platform_driver(mt7621_wdt_driver);\n\nMODULE_DESCRIPTION(\"MediaTek MT762x hardware watchdog driver\");\nMODULE_AUTHOR(\"John Crispin <john@phrozen.org\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}