{
  "module_name": "sa1100_wdt.c",
  "hash_id": "df85e524a8bfd60e4beeaea5fb2555260dc385e7d05a9ac3150c7668a4f175cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sa1100_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/clk.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/platform_device.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/timex.h>\n\n#define REG_OSMR0  \t0x0000   \n#define REG_OSMR1  \t0x0004   \n#define REG_OSMR2  \t0x0008   \n#define REG_OSMR3  \t0x000c   \n#define REG_OSCR   \t0x0010   \n#define REG_OSSR   \t0x0014   \n#define REG_OWER   \t0x0018   \n#define REG_OIER  \t0x001C   \n\n#define OSSR_M3\t\t(1 << 3)\t \n#define OSSR_M2\t\t(1 << 2)\t \n#define OSSR_M1\t\t(1 << 1)\t \n#define OSSR_M0\t\t(1 << 0)\t \n\n#define OWER_WME\t(1 << 0)\t \n\n#define OIER_E3\t\t(1 << 3)\t \n#define OIER_E2\t\t(1 << 2)\t \n#define OIER_E1\t\t(1 << 1)\t \n#define OIER_E0\t\t(1 << 0)\t \n\nstatic unsigned long oscr_freq;\nstatic unsigned long sa1100wdt_users;\nstatic unsigned int pre_margin;\nstatic int boot_status;\nstatic void __iomem *reg_base;\n\nstatic inline void sa1100_wr(u32 val, u32 offset)\n{\n\twritel_relaxed(val, reg_base + offset);\n}\n\nstatic inline u32 sa1100_rd(u32 offset)\n{\n\treturn readl_relaxed(reg_base + offset);\n}\n\n \nstatic int sa1100dog_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(1, &sa1100wdt_users))\n\t\treturn -EBUSY;\n\n\t \n\tsa1100_wr(sa1100_rd(REG_OSCR) + pre_margin, REG_OSMR3);\n\tsa1100_wr(OSSR_M3, REG_OSSR);\n\tsa1100_wr(OWER_WME, REG_OWER);\n\tsa1100_wr(sa1100_rd(REG_OIER) | OIER_E3, REG_OIER);\n\treturn stream_open(inode, file);\n}\n\n \nstatic int sa1100dog_release(struct inode *inode, struct file *file)\n{\n\tpr_crit(\"Device closed - timer will not stop\\n\");\n\tclear_bit(1, &sa1100wdt_users);\n\treturn 0;\n}\n\nstatic ssize_t sa1100dog_write(struct file *file, const char __user *data,\n\t\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tif (len)\n\t\t \n\t\tsa1100_wr(sa1100_rd(REG_OSCR) + pre_margin, REG_OSMR3);\n\treturn len;\n}\n\nstatic const struct watchdog_info ident = {\n\t.options\t= WDIOF_CARDRESET | WDIOF_SETTIMEOUT\n\t\t\t\t| WDIOF_KEEPALIVEPING,\n\t.identity\t= \"SA1100/PXA255 Watchdog\",\n\t.firmware_version\t= 1,\n};\n\nstatic long sa1100dog_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint ret = -ENOTTY;\n\tint time;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tret = copy_to_user(argp, &ident,\n\t\t\t\t   sizeof(ident)) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\t\tret = put_user(0, p);\n\t\tbreak;\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tret = put_user(boot_status, p);\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tsa1100_wr(sa1100_rd(REG_OSCR) + pre_margin, REG_OSMR3);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tret = get_user(time, p);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (time <= 0 || (oscr_freq * (long long)time >= 0xffffffff)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpre_margin = oscr_freq * time;\n\t\tsa1100_wr(sa1100_rd(REG_OSCR) + pre_margin, REG_OSMR3);\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\tret = put_user(pre_margin / oscr_freq, p);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations sa1100dog_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= sa1100dog_write,\n\t.unlocked_ioctl\t= sa1100dog_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= sa1100dog_open,\n\t.release\t= sa1100dog_release,\n};\n\nstatic struct miscdevice sa1100dog_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &sa1100dog_fops,\n};\n\nstatic int margin = 60;\t\t \nstatic struct clk *clk;\n\nstatic int sa1100dog_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tint *platform_data;\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\treg_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tret = PTR_ERR_OR_ZERO(reg_base);\n\tif (ret)\n\t\treturn ret;\n\n\tclk = clk_get(NULL, \"OSTIMER0\");\n\tif (IS_ERR(clk)) {\n\t\tpr_err(\"SA1100/PXA2xx Watchdog Timer: clock not found: %d\\n\",\n\t\t       (int) PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tpr_err(\"SA1100/PXA2xx Watchdog Timer: clock failed to prepare+enable: %d\\n\",\n\t\t       ret);\n\t\tgoto err;\n\t}\n\n\toscr_freq = clk_get_rate(clk);\n\n\tplatform_data = pdev->dev.platform_data;\n\tif (platform_data && *platform_data)\n\t\tboot_status = WDIOF_CARDRESET;\n\tpre_margin = oscr_freq * margin;\n\n\tret = misc_register(&sa1100dog_miscdev);\n\tif (ret == 0) {\n\t\tpr_info(\"SA1100/PXA2xx Watchdog Timer: timer margin %d sec\\n\",\n\t\t\tmargin);\n\t\treturn 0;\n\t}\n\n\tclk_disable_unprepare(clk);\nerr:\n\tclk_put(clk);\n\treturn ret;\n}\n\nstatic void sa1100dog_remove(struct platform_device *pdev)\n{\n\tmisc_deregister(&sa1100dog_miscdev);\n\tclk_disable_unprepare(clk);\n\tclk_put(clk);\n}\n\nstatic struct platform_driver sa1100dog_driver = {\n\t.driver.name = \"sa1100_wdt\",\n\t.probe\t  = sa1100dog_probe,\n\t.remove_new\t  = sa1100dog_remove,\n};\nmodule_platform_driver(sa1100dog_driver);\n\nMODULE_AUTHOR(\"Oleg Drokin <green@crimea.edu>\");\nMODULE_DESCRIPTION(\"SA1100/PXA2xx Watchdog\");\n\nmodule_param(margin, int, 0);\nMODULE_PARM_DESC(margin, \"Watchdog margin in seconds (default 60s)\");\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}