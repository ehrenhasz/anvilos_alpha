{
  "module_name": "sb_wdog.c",
  "hash_id": "6ed2b2b72d4710ae9d3ac7db3fd4f41437dc4fe5a2d72e39c46f8241de82e5f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sb_wdog.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/reboot.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/interrupt.h>\n\n#include <asm/sibyte/sb1250.h>\n#include <asm/sibyte/sb1250_regs.h>\n#include <asm/sibyte/sb1250_int.h>\n#include <asm/sibyte/sb1250_scd.h>\n\nstatic DEFINE_SPINLOCK(sbwd_lock);\n\n \nstatic void sbwdog_set(char __iomem *wdog, unsigned long t)\n{\n\tspin_lock(&sbwd_lock);\n\t__raw_writeb(0, wdog);\n\t__raw_writeq(t & 0x7fffffUL, wdog - 0x10);\n\tspin_unlock(&sbwd_lock);\n}\n\n \nstatic void sbwdog_pet(char __iomem *wdog)\n{\n\tspin_lock(&sbwd_lock);\n\t__raw_writeb(__raw_readb(wdog) | 1, wdog);\n\tspin_unlock(&sbwd_lock);\n}\n\nstatic unsigned long sbwdog_gate;  \nstatic char __iomem *kern_dog = (char __iomem *)(IO_BASE + (A_SCD_WDOG_CFG_0));\nstatic char __iomem *user_dog = (char __iomem *)(IO_BASE + (A_SCD_WDOG_CFG_1));\nstatic unsigned long timeout = 0x7fffffUL;\t \nstatic int expect_close;\n\nstatic const struct watchdog_info ident = {\n\t.options\t= WDIOF_CARDRESET | WDIOF_SETTIMEOUT |\n\t\t\t\t\tWDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity\t= \"SiByte Watchdog\",\n};\n\n \nstatic int sbwdog_open(struct inode *inode, struct file *file)\n{\n\tstream_open(inode, file);\n\tif (test_and_set_bit(0, &sbwdog_gate))\n\t\treturn -EBUSY;\n\t__module_get(THIS_MODULE);\n\n\t \n\tsbwdog_set(user_dog, timeout);\n\t__raw_writeb(1, user_dog);\n\n\treturn 0;\n}\n\n \nstatic int sbwdog_release(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42) {\n\t\t__raw_writeb(0, user_dog);\n\t\tmodule_put(THIS_MODULE);\n\t} else {\n\t\tpr_crit(\"%s: Unexpected close, not stopping watchdog!\\n\",\n\t\t\tident.identity);\n\t\tsbwdog_pet(user_dog);\n\t}\n\tclear_bit(0, &sbwdog_gate);\n\texpect_close = 0;\n\n\treturn 0;\n}\n\n \nstatic ssize_t sbwdog_write(struct file *file, const char __user *data,\n\t\t\tsize_t len, loff_t *ppos)\n{\n\tint i;\n\n\tif (len) {\n\t\t \n\t\texpect_close = 0;\n\n\t\tfor (i = 0; i != len; i++) {\n\t\t\tchar c;\n\n\t\t\tif (get_user(c, data + i))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (c == 'V')\n\t\t\t\texpect_close = 42;\n\t\t}\n\t\tsbwdog_pet(user_dog);\n\t}\n\n\treturn len;\n}\n\nstatic long sbwdog_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\tunsigned long arg)\n{\n\tint ret = -ENOTTY;\n\tunsigned long time;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tret = copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tret = put_user(0, p);\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tsbwdog_pet(user_dog);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tret = get_user(time, p);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\ttime *= 1000000;\n\t\tif (time > 0x7fffffUL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\ttimeout = time;\n\t\tsbwdog_set(user_dog, timeout);\n\t\tsbwdog_pet(user_dog);\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\t \n\t\tret = put_user((u32)__raw_readq(user_dog - 8) / 1000000, p);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int sbwdog_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t\t\t\t\t\tvoid *erf)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT) {\n\t\t \n\t\t__raw_writeb(0, user_dog);\n\t\t__raw_writeb(0, kern_dog);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct file_operations sbwdog_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= sbwdog_write,\n\t.unlocked_ioctl\t= sbwdog_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= sbwdog_open,\n\t.release\t= sbwdog_release,\n};\n\nstatic struct miscdevice sbwdog_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &sbwdog_fops,\n};\n\nstatic struct notifier_block sbwdog_notifier = {\n\t.notifier_call\t= sbwdog_notify_sys,\n};\n\n \nirqreturn_t sbwdog_interrupt(int irq, void *addr)\n{\n\tunsigned long wd_init;\n\tchar *wd_cfg_reg = (char *)addr;\n\tu8 cfg;\n\n\tcfg = __raw_readb(wd_cfg_reg);\n\twd_init = __raw_readq(wd_cfg_reg - 8) & 0x7fffff;\n\n\t \n\tif (wd_cfg_reg == user_dog)\n\t\tpr_crit(\"%s in danger of initiating system reset \"\n\t\t\t\"in %ld.%01ld seconds\\n\",\n\t\t\tident.identity,\n\t\t\twd_init / 1000000, (wd_init / 100000) % 10);\n\telse\n\t\tcfg |= 1;\n\n\t__raw_writeb(cfg, wd_cfg_reg);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __init sbwdog_init(void)\n{\n\tint ret;\n\n\t \n\tret = register_reboot_notifier(&sbwdog_notifier);\n\tif (ret) {\n\t\tpr_err(\"%s: cannot register reboot notifier (err=%d)\\n\",\n\t\t       ident.identity, ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tret = request_irq(1, sbwdog_interrupt, IRQF_SHARED,\n\t\tident.identity, (void *)user_dog);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to request irq 1 - %d\\n\",\n\t\t       ident.identity, ret);\n\t\tgoto out;\n\t}\n\n\tret = misc_register(&sbwdog_miscdev);\n\tif (ret == 0) {\n\t\tpr_info(\"%s: timeout is %ld.%ld secs\\n\",\n\t\t\tident.identity,\n\t\t\ttimeout / 1000000, (timeout / 100000) % 10);\n\t\treturn 0;\n\t}\n\tfree_irq(1, (void *)user_dog);\nout:\n\tunregister_reboot_notifier(&sbwdog_notifier);\n\n\treturn ret;\n}\n\nstatic void __exit sbwdog_exit(void)\n{\n\tmisc_deregister(&sbwdog_miscdev);\n\tfree_irq(1, (void *)user_dog);\n\tunregister_reboot_notifier(&sbwdog_notifier);\n}\n\nmodule_init(sbwdog_init);\nmodule_exit(sbwdog_exit);\n\nMODULE_AUTHOR(\"Andrew Sharp <andy.sharp@lsi.com>\");\nMODULE_DESCRIPTION(\"SiByte Watchdog\");\n\nmodule_param(timeout, ulong, 0);\nMODULE_PARM_DESC(timeout,\n      \"Watchdog timeout in microseconds (max/default 8388607 or 8.3ish secs)\");\n\nMODULE_LICENSE(\"GPL\");\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}