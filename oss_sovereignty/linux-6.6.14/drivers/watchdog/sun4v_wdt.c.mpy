{
  "module_name": "sun4v_wdt.c",
  "hash_id": "4f4e9ace5c9729d42857bb0b6f3ab064ad291ab20e13838634b8a1c8f60b5b07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sun4v_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/watchdog.h>\n#include <asm/hypervisor.h>\n#include <asm/mdesc.h>\n\n#define WDT_TIMEOUT\t\t\t60\n#define WDT_MAX_TIMEOUT\t\t\t31536000\n#define WDT_MIN_TIMEOUT\t\t\t1\n#define WDT_DEFAULT_RESOLUTION_MS\t1000\t \n\nstatic unsigned int timeout;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds (default=\"\n\t__MODULE_STRING(WDT_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, S_IRUGO);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int sun4v_wdt_stop(struct watchdog_device *wdd)\n{\n\tsun4v_mach_set_watchdog(0, NULL);\n\n\treturn 0;\n}\n\nstatic int sun4v_wdt_ping(struct watchdog_device *wdd)\n{\n\tint hverr;\n\n\t \n\thverr = sun4v_mach_set_watchdog(wdd->timeout * 1000, NULL);\n\tif (hverr == HV_EINVAL)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sun4v_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t unsigned int timeout)\n{\n\twdd->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info sun4v_wdt_ident = {\n\t.options =\tWDIOF_SETTIMEOUT |\n\t\t\tWDIOF_MAGICCLOSE |\n\t\t\tWDIOF_KEEPALIVEPING,\n\t.identity =\t\"sun4v hypervisor watchdog\",\n\t.firmware_version = 0,\n};\n\nstatic const struct watchdog_ops sun4v_wdt_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.start =\tsun4v_wdt_ping,\n\t.stop =\t\tsun4v_wdt_stop,\n\t.ping =\t\tsun4v_wdt_ping,\n\t.set_timeout =\tsun4v_wdt_set_timeout,\n};\n\nstatic struct watchdog_device wdd = {\n\t.info = &sun4v_wdt_ident,\n\t.ops = &sun4v_wdt_ops,\n\t.min_timeout = WDT_MIN_TIMEOUT,\n\t.max_timeout = WDT_MAX_TIMEOUT,\n\t.timeout = WDT_TIMEOUT,\n};\n\nstatic int __init sun4v_wdt_init(void)\n{\n\tstruct mdesc_handle *handle;\n\tu64 node;\n\tconst u64 *value;\n\tint err = 0;\n\tunsigned long major = 1, minor = 1;\n\n\t \n\n\thandle = mdesc_grab();\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tnode = mdesc_node_by_name(handle, MDESC_NODE_NULL, \"platform\");\n\terr = -ENODEV;\n\tif (node == MDESC_NODE_NULL)\n\t\tgoto out_release;\n\n\t \n\tif (sun4v_hvapi_register(HV_GRP_CORE, major, &minor))\n\t\tgoto out_hv_unreg;\n\n\t \n\tvalue = mdesc_get_property(handle, node, \"watchdog-resolution\", NULL);\n\terr = -EINVAL;\n\tif (value) {\n\t\tif (*value == 0 ||\n\t\t    *value > WDT_DEFAULT_RESOLUTION_MS)\n\t\t\tgoto out_hv_unreg;\n\t}\n\n\tvalue = mdesc_get_property(handle, node, \"watchdog-max-timeout\", NULL);\n\tif (value) {\n\t\t \n\t\tif (*value < wdd.min_timeout * 1000)\n\t\t\tgoto out_hv_unreg;\n\n\t\t \n\t\tif (*value < wdd.max_timeout * 1000)\n\t\t\twdd.max_timeout = *value  / 1000;\n\t}\n\n\twatchdog_init_timeout(&wdd, timeout, NULL);\n\n\twatchdog_set_nowayout(&wdd, nowayout);\n\n\terr = watchdog_register_device(&wdd);\n\tif (err)\n\t\tgoto out_hv_unreg;\n\n\tpr_info(\"initialized (timeout=%ds, nowayout=%d)\\n\",\n\t\t wdd.timeout, nowayout);\n\n\tmdesc_release(handle);\n\n\treturn 0;\n\nout_hv_unreg:\n\tsun4v_hvapi_unregister(HV_GRP_CORE);\n\nout_release:\n\tmdesc_release(handle);\n\treturn err;\n}\n\nstatic void __exit sun4v_wdt_exit(void)\n{\n\tsun4v_hvapi_unregister(HV_GRP_CORE);\n\twatchdog_unregister_device(&wdd);\n}\n\nmodule_init(sun4v_wdt_init);\nmodule_exit(sun4v_wdt_exit);\n\nMODULE_AUTHOR(\"Wim Coekaerts <wim.coekaerts@oracle.com>\");\nMODULE_DESCRIPTION(\"sun4v watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}