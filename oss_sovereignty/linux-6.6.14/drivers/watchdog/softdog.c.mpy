{
  "module_name": "softdog.c",
  "hash_id": "d41264d99240aefdbf69557c701bfcde6e81adba3ecdf1d1469c090beb1e8c4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/softdog.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/hrtimer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/reboot.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/workqueue.h>\n\n#define TIMER_MARGIN\t60\t\t \nstatic unsigned int soft_margin = TIMER_MARGIN;\t \nmodule_param(soft_margin, uint, 0);\nMODULE_PARM_DESC(soft_margin,\n\t\"Watchdog soft_margin in seconds. (0 < soft_margin < 65536, default=\"\n\t\t\t\t\t__MODULE_STRING(TIMER_MARGIN) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int soft_noboot;\nmodule_param(soft_noboot, int, 0);\nMODULE_PARM_DESC(soft_noboot,\n\t\"Softdog action, set to 1 to ignore reboots, 0 to reboot (default=0)\");\n\nstatic int soft_panic;\nmodule_param(soft_panic, int, 0);\nMODULE_PARM_DESC(soft_panic,\n\t\"Softdog action, set to 1 to panic, 0 to reboot (default=0)\");\n\nstatic char *soft_reboot_cmd;\nmodule_param(soft_reboot_cmd, charp, 0000);\nMODULE_PARM_DESC(soft_reboot_cmd,\n\t\"Set reboot command. Emergency reboot takes place if unset\");\n\nstatic bool soft_active_on_boot;\nmodule_param(soft_active_on_boot, bool, 0000);\nMODULE_PARM_DESC(soft_active_on_boot,\n\t\"Set to true to active Softdog on boot (default=false)\");\n\nstatic struct hrtimer softdog_ticktock;\nstatic struct hrtimer softdog_preticktock;\n\nstatic int reboot_kthread_fn(void *data)\n{\n\tkernel_restart(soft_reboot_cmd);\n\treturn -EPERM;  \n}\n\nstatic void reboot_work_fn(struct work_struct *unused)\n{\n\tkthread_run(reboot_kthread_fn, NULL, \"softdog_reboot\");\n}\n\nstatic enum hrtimer_restart softdog_fire(struct hrtimer *timer)\n{\n\tstatic bool soft_reboot_fired;\n\n\tmodule_put(THIS_MODULE);\n\tif (soft_noboot) {\n\t\tpr_crit(\"Triggered - Reboot ignored\\n\");\n\t} else if (soft_panic) {\n\t\tpr_crit(\"Initiating panic\\n\");\n\t\tpanic(\"Software Watchdog Timer expired\");\n\t} else {\n\t\tpr_crit(\"Initiating system reboot\\n\");\n\t\tif (!soft_reboot_fired && soft_reboot_cmd != NULL) {\n\t\t\tstatic DECLARE_WORK(reboot_work, reboot_work_fn);\n\t\t\t \n\t\t\tsoft_reboot_fired = true;\n\t\t\tschedule_work(&reboot_work);\n\t\t\thrtimer_add_expires_ns(timer,\n\t\t\t\t\t(u64)TIMER_MARGIN * NSEC_PER_SEC);\n\n\t\t\treturn HRTIMER_RESTART;\n\t\t}\n\t\temergency_restart();\n\t\tpr_crit(\"Reboot didn't ?????\\n\");\n\t}\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic struct watchdog_device softdog_dev;\n\nstatic enum hrtimer_restart softdog_pretimeout(struct hrtimer *timer)\n{\n\twatchdog_notify_pretimeout(&softdog_dev);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic int softdog_ping(struct watchdog_device *w)\n{\n\tif (!hrtimer_active(&softdog_ticktock))\n\t\t__module_get(THIS_MODULE);\n\thrtimer_start(&softdog_ticktock, ktime_set(w->timeout, 0),\n\t\t      HRTIMER_MODE_REL);\n\n\tif (IS_ENABLED(CONFIG_SOFT_WATCHDOG_PRETIMEOUT)) {\n\t\tif (w->pretimeout)\n\t\t\thrtimer_start(&softdog_preticktock,\n\t\t\t\t      ktime_set(w->timeout - w->pretimeout, 0),\n\t\t\t\t      HRTIMER_MODE_REL);\n\t\telse\n\t\t\thrtimer_cancel(&softdog_preticktock);\n\t}\n\n\treturn 0;\n}\n\nstatic int softdog_stop(struct watchdog_device *w)\n{\n\tif (hrtimer_cancel(&softdog_ticktock))\n\t\tmodule_put(THIS_MODULE);\n\n\tif (IS_ENABLED(CONFIG_SOFT_WATCHDOG_PRETIMEOUT))\n\t\thrtimer_cancel(&softdog_preticktock);\n\n\treturn 0;\n}\n\nstatic struct watchdog_info softdog_info = {\n\t.identity = \"Software Watchdog\",\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops softdog_ops = {\n\t.owner = THIS_MODULE,\n\t.start = softdog_ping,\n\t.stop = softdog_stop,\n};\n\nstatic struct watchdog_device softdog_dev = {\n\t.info = &softdog_info,\n\t.ops = &softdog_ops,\n\t.min_timeout = 1,\n\t.max_timeout = 65535,\n\t.timeout = TIMER_MARGIN,\n};\n\nstatic int __init softdog_init(void)\n{\n\tint ret;\n\n\twatchdog_init_timeout(&softdog_dev, soft_margin, NULL);\n\twatchdog_set_nowayout(&softdog_dev, nowayout);\n\twatchdog_stop_on_reboot(&softdog_dev);\n\n\thrtimer_init(&softdog_ticktock, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsoftdog_ticktock.function = softdog_fire;\n\n\tif (IS_ENABLED(CONFIG_SOFT_WATCHDOG_PRETIMEOUT)) {\n\t\tsoftdog_info.options |= WDIOF_PRETIMEOUT;\n\t\thrtimer_init(&softdog_preticktock, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL);\n\t\tsoftdog_preticktock.function = softdog_pretimeout;\n\t}\n\n\tif (soft_active_on_boot)\n\t\tsoftdog_ping(&softdog_dev);\n\n\tret = watchdog_register_device(&softdog_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"initialized. soft_noboot=%d soft_margin=%d sec soft_panic=%d (nowayout=%d)\\n\",\n\t\tsoft_noboot, softdog_dev.timeout, soft_panic, nowayout);\n\tpr_info(\"             soft_reboot_cmd=%s soft_active_on_boot=%d\\n\",\n\t\tsoft_reboot_cmd ?: \"<not set>\", soft_active_on_boot);\n\n\treturn 0;\n}\nmodule_init(softdog_init);\n\nstatic void __exit softdog_exit(void)\n{\n\twatchdog_unregister_device(&softdog_dev);\n}\nmodule_exit(softdog_exit);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"Software Watchdog Device Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}