{
  "module_name": "ftwdt010_wdt.c",
  "hash_id": "e9048786223aeacabe87111da42a25b9d9cbd1a85a7ed969508694b2d1f8b4a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ftwdt010_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/watchdog.h>\n\n#define FTWDT010_WDCOUNTER\t0x0\n#define FTWDT010_WDLOAD\t\t0x4\n#define FTWDT010_WDRESTART\t0x8\n#define FTWDT010_WDCR\t\t0xC\n\n#define WDRESTART_MAGIC\t\t0x5AB9\n\n#define WDCR_CLOCK_5MHZ\t\tBIT(4)\n#define WDCR_WDEXT\t\tBIT(3)\n#define WDCR_WDINTR\t\tBIT(2)\n#define WDCR_SYS_RST\t\tBIT(1)\n#define WDCR_ENABLE\t\tBIT(0)\n\n#define WDT_CLOCK\t\t5000000\t\t \n\nstruct ftwdt010_wdt {\n\tstruct watchdog_device\twdd;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tbool\t\t\thas_irq;\n};\n\nstatic inline\nstruct ftwdt010_wdt *to_ftwdt010_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct ftwdt010_wdt, wdd);\n}\n\nstatic void ftwdt010_enable(struct ftwdt010_wdt *gwdt,\n\t\t\t    unsigned int timeout,\n\t\t\t    bool need_irq)\n{\n\tu32 enable;\n\n\twritel(timeout * WDT_CLOCK, gwdt->base + FTWDT010_WDLOAD);\n\twritel(WDRESTART_MAGIC, gwdt->base + FTWDT010_WDRESTART);\n\t \n\tenable = WDCR_CLOCK_5MHZ | WDCR_SYS_RST;\n\twritel(enable, gwdt->base + FTWDT010_WDCR);\n\tif (need_irq)\n\t\tenable |= WDCR_WDINTR;\n\tenable |= WDCR_ENABLE;\n\twritel(enable, gwdt->base + FTWDT010_WDCR);\n}\n\nstatic int ftwdt010_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct ftwdt010_wdt *gwdt = to_ftwdt010_wdt(wdd);\n\n\tftwdt010_enable(gwdt, wdd->timeout, gwdt->has_irq);\n\treturn 0;\n}\n\nstatic int ftwdt010_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct ftwdt010_wdt *gwdt = to_ftwdt010_wdt(wdd);\n\n\twritel(0, gwdt->base + FTWDT010_WDCR);\n\n\treturn 0;\n}\n\nstatic int ftwdt010_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct ftwdt010_wdt *gwdt = to_ftwdt010_wdt(wdd);\n\n\twritel(WDRESTART_MAGIC, gwdt->base + FTWDT010_WDRESTART);\n\n\treturn 0;\n}\n\nstatic int ftwdt010_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\twdd->timeout = timeout;\n\tif (watchdog_active(wdd))\n\t\tftwdt010_wdt_start(wdd);\n\n\treturn 0;\n}\n\nstatic int ftwdt010_wdt_restart(struct watchdog_device *wdd,\n\t\t\t\tunsigned long action, void *data)\n{\n\tftwdt010_enable(to_ftwdt010_wdt(wdd), 0, false);\n\treturn 0;\n}\n\nstatic irqreturn_t ftwdt010_wdt_interrupt(int irq, void *data)\n{\n\tstruct ftwdt010_wdt *gwdt = data;\n\n\twatchdog_notify_pretimeout(&gwdt->wdd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct watchdog_ops ftwdt010_wdt_ops = {\n\t.start\t\t= ftwdt010_wdt_start,\n\t.stop\t\t= ftwdt010_wdt_stop,\n\t.ping\t\t= ftwdt010_wdt_ping,\n\t.set_timeout\t= ftwdt010_wdt_set_timeout,\n\t.restart\t= ftwdt010_wdt_restart,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct watchdog_info ftwdt010_wdt_info = {\n\t.options\t= WDIOF_KEEPALIVEPING\n\t\t\t| WDIOF_MAGICCLOSE\n\t\t\t| WDIOF_SETTIMEOUT,\n\t.identity\t= KBUILD_MODNAME,\n};\n\n\nstatic int ftwdt010_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ftwdt010_wdt *gwdt;\n\tunsigned int reg;\n\tint irq;\n\tint ret;\n\n\tgwdt = devm_kzalloc(dev, sizeof(*gwdt), GFP_KERNEL);\n\tif (!gwdt)\n\t\treturn -ENOMEM;\n\n\tgwdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gwdt->base))\n\t\treturn PTR_ERR(gwdt->base);\n\n\tgwdt->dev = dev;\n\tgwdt->wdd.info = &ftwdt010_wdt_info;\n\tgwdt->wdd.ops = &ftwdt010_wdt_ops;\n\tgwdt->wdd.min_timeout = 1;\n\tgwdt->wdd.max_timeout = 0xFFFFFFFF / WDT_CLOCK;\n\tgwdt->wdd.parent = dev;\n\n\t \n\tgwdt->wdd.timeout = 13U;\n\twatchdog_init_timeout(&gwdt->wdd, 0, dev);\n\n\treg = readw(gwdt->base + FTWDT010_WDCR);\n\tif (reg & WDCR_ENABLE) {\n\t\t \n\t\treg &= ~WDCR_ENABLE;\n\t\twritel(reg, gwdt->base + FTWDT010_WDCR);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq > 0) {\n\t\tret = devm_request_irq(dev, irq, ftwdt010_wdt_interrupt, 0,\n\t\t\t\t       \"watchdog bark\", gwdt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tgwdt->has_irq = true;\n\t}\n\n\tret = devm_watchdog_register_device(dev, &gwdt->wdd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tplatform_set_drvdata(pdev, gwdt);\n\tdev_info(dev, \"FTWDT010 watchdog driver enabled\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ftwdt010_wdt_suspend(struct device *dev)\n{\n\tstruct ftwdt010_wdt *gwdt = dev_get_drvdata(dev);\n\tunsigned int reg;\n\n\treg = readw(gwdt->base + FTWDT010_WDCR);\n\treg &= ~WDCR_ENABLE;\n\twritel(reg, gwdt->base + FTWDT010_WDCR);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ftwdt010_wdt_resume(struct device *dev)\n{\n\tstruct ftwdt010_wdt *gwdt = dev_get_drvdata(dev);\n\tunsigned int reg;\n\n\tif (watchdog_active(&gwdt->wdd)) {\n\t\treg = readw(gwdt->base + FTWDT010_WDCR);\n\t\treg |= WDCR_ENABLE;\n\t\twritel(reg, gwdt->base + FTWDT010_WDCR);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ftwdt010_wdt_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ftwdt010_wdt_suspend,\n\t\t\t\tftwdt010_wdt_resume)\n};\n\nstatic const struct of_device_id ftwdt010_wdt_match[] = {\n\t{ .compatible = \"faraday,ftwdt010\" },\n\t{ .compatible = \"cortina,gemini-watchdog\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ftwdt010_wdt_match);\n\nstatic struct platform_driver ftwdt010_wdt_driver = {\n\t.probe\t\t= ftwdt010_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ftwdt010-wdt\",\n\t\t.of_match_table = ftwdt010_wdt_match,\n\t\t.pm = &ftwdt010_wdt_dev_pm_ops,\n\t},\n};\nmodule_platform_driver(ftwdt010_wdt_driver);\nMODULE_AUTHOR(\"Linus Walleij\");\nMODULE_DESCRIPTION(\"Watchdog driver for Faraday Technology FTWDT010\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}