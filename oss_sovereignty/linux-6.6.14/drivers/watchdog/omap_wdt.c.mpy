{
  "module_name": "omap_wdt.c",
  "hash_id": "d94f450337661d3015f150e0095a95ae0ebb086b83e9b9f396ca8cf4ea33210e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/omap_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/watchdog.h>\n#include <linux/reboot.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/moduleparam.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_data/omap-wd-timer.h>\n\n#include \"omap_wdt.h\"\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic unsigned timer_margin;\nmodule_param(timer_margin, uint, 0);\nMODULE_PARM_DESC(timer_margin, \"initial watchdog timeout (in seconds)\");\n\n#define to_omap_wdt_dev(_wdog)\tcontainer_of(_wdog, struct omap_wdt_dev, wdog)\n\nstatic bool early_enable;\nmodule_param(early_enable, bool, 0);\nMODULE_PARM_DESC(early_enable,\n\t\"Watchdog is started on module insertion (default=0)\");\n\nstruct omap_wdt_dev {\n\tstruct watchdog_device wdog;\n\tvoid __iomem    *base;           \n\tstruct device   *dev;\n\tbool\t\tomap_wdt_users;\n\tint\t\twdt_trgr_pattern;\n\tstruct mutex\tlock;\t\t \n};\n\nstatic void omap_wdt_reload(struct omap_wdt_dev *wdev)\n{\n\tvoid __iomem    *base = wdev->base;\n\n\t \n\twhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x08)\n\t\tcpu_relax();\n\n\twdev->wdt_trgr_pattern = ~wdev->wdt_trgr_pattern;\n\twritel_relaxed(wdev->wdt_trgr_pattern, (base + OMAP_WATCHDOG_TGR));\n\n\t \n\twhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x08)\n\t\tcpu_relax();\n\t \n}\n\nstatic void omap_wdt_enable(struct omap_wdt_dev *wdev)\n{\n\tvoid __iomem *base = wdev->base;\n\n\t \n\twritel_relaxed(0xBBBB, base + OMAP_WATCHDOG_SPR);\n\twhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x10)\n\t\tcpu_relax();\n\n\twritel_relaxed(0x4444, base + OMAP_WATCHDOG_SPR);\n\twhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x10)\n\t\tcpu_relax();\n}\n\nstatic void omap_wdt_disable(struct omap_wdt_dev *wdev)\n{\n\tvoid __iomem *base = wdev->base;\n\n\t \n\twritel_relaxed(0xAAAA, base + OMAP_WATCHDOG_SPR);\t \n\twhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x10)\n\t\tcpu_relax();\n\n\twritel_relaxed(0x5555, base + OMAP_WATCHDOG_SPR);\t \n\twhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x10)\n\t\tcpu_relax();\n}\n\nstatic void omap_wdt_set_timer(struct omap_wdt_dev *wdev,\n\t\t\t\t   unsigned int timeout)\n{\n\tu32 pre_margin = GET_WLDR_VAL(timeout);\n\tvoid __iomem *base = wdev->base;\n\n\t \n\twhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x04)\n\t\tcpu_relax();\n\n\twritel_relaxed(pre_margin, base + OMAP_WATCHDOG_LDR);\n\twhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x04)\n\t\tcpu_relax();\n}\n\nstatic int omap_wdt_start(struct watchdog_device *wdog)\n{\n\tstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\n\tvoid __iomem *base = wdev->base;\n\n\tmutex_lock(&wdev->lock);\n\n\twdev->omap_wdt_users = true;\n\n\tpm_runtime_get_sync(wdev->dev);\n\n\t \n\tomap_wdt_disable(wdev);\n\n\t \n\twhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x01)\n\t\tcpu_relax();\n\n\twritel_relaxed((1 << 5) | (PTV << 2), base + OMAP_WATCHDOG_CNTRL);\n\twhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x01)\n\t\tcpu_relax();\n\n\tomap_wdt_set_timer(wdev, wdog->timeout);\n\tomap_wdt_reload(wdev);  \n\tomap_wdt_enable(wdev);\n\n\tmutex_unlock(&wdev->lock);\n\n\treturn 0;\n}\n\nstatic int omap_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\n\n\tmutex_lock(&wdev->lock);\n\tomap_wdt_disable(wdev);\n\tpm_runtime_put_sync(wdev->dev);\n\twdev->omap_wdt_users = false;\n\tmutex_unlock(&wdev->lock);\n\treturn 0;\n}\n\nstatic int omap_wdt_ping(struct watchdog_device *wdog)\n{\n\tstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\n\n\tmutex_lock(&wdev->lock);\n\tomap_wdt_reload(wdev);\n\tmutex_unlock(&wdev->lock);\n\n\treturn 0;\n}\n\nstatic int omap_wdt_set_timeout(struct watchdog_device *wdog,\n\t\t\t\tunsigned int timeout)\n{\n\tstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\n\n\tmutex_lock(&wdev->lock);\n\tomap_wdt_disable(wdev);\n\tomap_wdt_set_timer(wdev, timeout);\n\tomap_wdt_enable(wdev);\n\tomap_wdt_reload(wdev);\n\twdog->timeout = timeout;\n\tmutex_unlock(&wdev->lock);\n\n\treturn 0;\n}\n\nstatic unsigned int omap_wdt_get_timeleft(struct watchdog_device *wdog)\n{\n\tstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\n\tvoid __iomem *base = wdev->base;\n\tu32 value;\n\n\tvalue = readl_relaxed(base + OMAP_WATCHDOG_CRR);\n\treturn GET_WCCR_SECS(value);\n}\n\nstatic const struct watchdog_info omap_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"OMAP Watchdog\",\n};\n\nstatic const struct watchdog_ops omap_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= omap_wdt_start,\n\t.stop\t\t= omap_wdt_stop,\n\t.ping\t\t= omap_wdt_ping,\n\t.set_timeout\t= omap_wdt_set_timeout,\n\t.get_timeleft\t= omap_wdt_get_timeleft,\n};\n\nstatic int omap_wdt_probe(struct platform_device *pdev)\n{\n\tstruct omap_wd_timer_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct omap_wdt_dev *wdev;\n\tint ret;\n\n\twdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);\n\tif (!wdev)\n\t\treturn -ENOMEM;\n\n\twdev->omap_wdt_users\t= false;\n\twdev->dev\t\t= &pdev->dev;\n\twdev->wdt_trgr_pattern\t= 0x1234;\n\tmutex_init(&wdev->lock);\n\n\t \n\twdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdev->base))\n\t\treturn PTR_ERR(wdev->base);\n\n\twdev->wdog.info = &omap_wdt_info;\n\twdev->wdog.ops = &omap_wdt_ops;\n\twdev->wdog.min_timeout = TIMER_MARGIN_MIN;\n\twdev->wdog.max_timeout = TIMER_MARGIN_MAX;\n\twdev->wdog.timeout = TIMER_MARGIN_DEFAULT;\n\twdev->wdog.parent = &pdev->dev;\n\n\twatchdog_init_timeout(&wdev->wdog, timer_margin, &pdev->dev);\n\n\twatchdog_set_nowayout(&wdev->wdog, nowayout);\n\n\tplatform_set_drvdata(pdev, wdev);\n\n\tpm_runtime_enable(wdev->dev);\n\tpm_runtime_get_sync(wdev->dev);\n\n\tif (pdata && pdata->read_reset_sources) {\n\t\tu32 rs = pdata->read_reset_sources();\n\t\tif (rs & (1 << OMAP_MPU_WD_RST_SRC_ID_SHIFT))\n\t\t\twdev->wdog.bootstatus = WDIOF_CARDRESET;\n\t}\n\n\tif (early_enable) {\n\t\tomap_wdt_start(&wdev->wdog);\n\t\tset_bit(WDOG_HW_RUNNING, &wdev->wdog.status);\n\t} else {\n\t\tomap_wdt_disable(wdev);\n\t}\n\n\tret = watchdog_register_device(&wdev->wdog);\n\tif (ret) {\n\t\tpm_runtime_put(wdev->dev);\n\t\tpm_runtime_disable(wdev->dev);\n\t\treturn ret;\n\t}\n\n\tpr_info(\"OMAP Watchdog Timer Rev 0x%02x: initial timeout %d sec\\n\",\n\t\treadl_relaxed(wdev->base + OMAP_WATCHDOG_REV) & 0xFF,\n\t\twdev->wdog.timeout);\n\n\tif (early_enable)\n\t\tomap_wdt_start(&wdev->wdog);\n\n\tpm_runtime_put(wdev->dev);\n\n\treturn 0;\n}\n\nstatic void omap_wdt_shutdown(struct platform_device *pdev)\n{\n\tstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\n\n\tmutex_lock(&wdev->lock);\n\tif (wdev->omap_wdt_users) {\n\t\tomap_wdt_disable(wdev);\n\t\tpm_runtime_put_sync(wdev->dev);\n\t}\n\tmutex_unlock(&wdev->lock);\n}\n\nstatic void omap_wdt_remove(struct platform_device *pdev)\n{\n\tstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(wdev->dev);\n\twatchdog_unregister_device(&wdev->wdog);\n}\n\n \n\nstatic int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\n\n\tmutex_lock(&wdev->lock);\n\tif (wdev->omap_wdt_users) {\n\t\tomap_wdt_disable(wdev);\n\t\tpm_runtime_put_sync(wdev->dev);\n\t}\n\tmutex_unlock(&wdev->lock);\n\n\treturn 0;\n}\n\nstatic int omap_wdt_resume(struct platform_device *pdev)\n{\n\tstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\n\n\tmutex_lock(&wdev->lock);\n\tif (wdev->omap_wdt_users) {\n\t\tpm_runtime_get_sync(wdev->dev);\n\t\tomap_wdt_enable(wdev);\n\t\tomap_wdt_reload(wdev);\n\t}\n\tmutex_unlock(&wdev->lock);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id omap_wdt_of_match[] = {\n\t{ .compatible = \"ti,omap3-wdt\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_wdt_of_match);\n\nstatic struct platform_driver omap_wdt_driver = {\n\t.probe\t\t= omap_wdt_probe,\n\t.remove_new\t= omap_wdt_remove,\n\t.shutdown\t= omap_wdt_shutdown,\n\t.suspend\t= pm_ptr(omap_wdt_suspend),\n\t.resume\t\t= pm_ptr(omap_wdt_resume),\n\t.driver\t\t= {\n\t\t.name\t= \"omap_wdt\",\n\t\t.of_match_table = omap_wdt_of_match,\n\t},\n};\n\nmodule_platform_driver(omap_wdt_driver);\n\nMODULE_AUTHOR(\"George G. Davis\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:omap_wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}