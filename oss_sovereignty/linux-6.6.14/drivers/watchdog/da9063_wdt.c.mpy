{
  "module_name": "da9063_wdt.c",
  "hash_id": "0af1f3cb04b09e95bd405b0000d2efc33985d1346f2e3f354b3ac839e09ba6e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/da9063_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/mfd/da9063/registers.h>\n#include <linux/mfd/da9063/core.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n \nstatic const unsigned int wdt_timeout[] = { 0, 2, 4, 8, 16, 32, 65, 131 };\nstatic bool use_sw_pm;\n\n#define DA9063_TWDSCALE_DISABLE\t\t0\n#define DA9063_TWDSCALE_MIN\t\t1\n#define DA9063_TWDSCALE_MAX\t\t(ARRAY_SIZE(wdt_timeout) - 1)\n#define DA9063_WDT_MIN_TIMEOUT\t\twdt_timeout[DA9063_TWDSCALE_MIN]\n#define DA9063_WDT_MAX_TIMEOUT\t\twdt_timeout[DA9063_TWDSCALE_MAX]\n#define DA9063_WDG_TIMEOUT\t\twdt_timeout[3]\n#define DA9063_RESET_PROTECTION_MS\t256\n\nstatic unsigned int da9063_wdt_timeout_to_sel(unsigned int secs)\n{\n\tunsigned int i;\n\n\tfor (i = DA9063_TWDSCALE_MIN; i <= DA9063_TWDSCALE_MAX; i++) {\n\t\tif (wdt_timeout[i] >= secs)\n\t\t\treturn i;\n\t}\n\n\treturn DA9063_TWDSCALE_MAX;\n}\n\n \nstatic unsigned int da9063_wdt_read_timeout(struct da9063 *da9063)\n{\n\tunsigned int val;\n\n\tregmap_read(da9063->regmap, DA9063_REG_CONTROL_D, &val);\n\n\treturn wdt_timeout[val & DA9063_TWDSCALE_MASK];\n}\n\nstatic int da9063_wdt_disable_timer(struct da9063 *da9063)\n{\n\treturn regmap_update_bits(da9063->regmap, DA9063_REG_CONTROL_D,\n\t\t\t\t  DA9063_TWDSCALE_MASK,\n\t\t\t\t  DA9063_TWDSCALE_DISABLE);\n}\n\nstatic int\nda9063_wdt_update_timeout(struct da9063 *da9063, unsigned int timeout)\n{\n\tunsigned int regval;\n\tint ret;\n\n\t \n\tret = da9063_wdt_disable_timer(da9063);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(150, 300);\n\tregval = da9063_wdt_timeout_to_sel(timeout);\n\n\treturn regmap_update_bits(da9063->regmap, DA9063_REG_CONTROL_D,\n\t\t\t\t  DA9063_TWDSCALE_MASK, regval);\n}\n\nstatic int da9063_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct da9063 *da9063 = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tret = da9063_wdt_update_timeout(da9063, wdd->timeout);\n\tif (ret)\n\t\tdev_err(da9063->dev, \"Watchdog failed to start (err = %d)\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int da9063_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct da9063 *da9063 = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tret = da9063_wdt_disable_timer(da9063);\n\tif (ret)\n\t\tdev_alert(da9063->dev, \"Watchdog failed to stop (err = %d)\\n\",\n\t\t\t  ret);\n\n\treturn ret;\n}\n\nstatic int da9063_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct da9063 *da9063 = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\t \n\tif (system_state > SYSTEM_RUNNING)\n\t\treturn 0;\n\n\tret = regmap_write(da9063->regmap, DA9063_REG_CONTROL_F,\n\t\t\t   DA9063_WATCHDOG);\n\tif (ret)\n\t\tdev_alert(da9063->dev, \"Failed to ping the watchdog (err = %d)\\n\",\n\t\t\t  ret);\n\n\treturn ret;\n}\n\nstatic int da9063_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct da9063 *da9063 = watchdog_get_drvdata(wdd);\n\tint ret = 0;\n\n\t \n\tif (watchdog_active(wdd))\n\t\tret = da9063_wdt_update_timeout(da9063, timeout);\n\n\tif (ret)\n\t\tdev_err(da9063->dev, \"Failed to set watchdog timeout (err = %d)\\n\",\n\t\t\tret);\n\telse\n\t\twdd->timeout = wdt_timeout[da9063_wdt_timeout_to_sel(timeout)];\n\n\treturn ret;\n}\n\nstatic int da9063_wdt_restart(struct watchdog_device *wdd, unsigned long action,\n\t\t\t      void *data)\n{\n\tstruct da9063 *da9063 = watchdog_get_drvdata(wdd);\n\tstruct i2c_client *client = to_i2c_client(da9063->dev);\n\tunion i2c_smbus_data msg;\n\tint ret;\n\n\t \n\tmsg.byte = DA9063_SHUTDOWN;\n\tret = __i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\tI2C_SMBUS_WRITE, DA9063_REG_CONTROL_F,\n\t\t\tI2C_SMBUS_BYTE_DATA, &msg);\n\n\tif (ret < 0)\n\t\tdev_alert(da9063->dev, \"Failed to shutdown (err = %d)\\n\",\n\t\t\t  ret);\n\n\t \n\tmdelay(500);\n\n\treturn ret;\n}\n\nstatic const struct watchdog_info da9063_watchdog_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n\t.identity = \"DA9063 Watchdog\",\n};\n\nstatic const struct watchdog_ops da9063_watchdog_ops = {\n\t.owner = THIS_MODULE,\n\t.start = da9063_wdt_start,\n\t.stop = da9063_wdt_stop,\n\t.ping = da9063_wdt_ping,\n\t.set_timeout = da9063_wdt_set_timeout,\n\t.restart = da9063_wdt_restart,\n};\n\nstatic int da9063_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da9063 *da9063;\n\tstruct watchdog_device *wdd;\n\tunsigned int timeout;\n\n\tif (!dev->parent)\n\t\treturn -EINVAL;\n\n\tda9063 = dev_get_drvdata(dev->parent);\n\tif (!da9063)\n\t\treturn -EINVAL;\n\n\twdd = devm_kzalloc(dev, sizeof(*wdd), GFP_KERNEL);\n\tif (!wdd)\n\t\treturn -ENOMEM;\n\n\tuse_sw_pm = device_property_present(dev, \"dlg,use-sw-pm\");\n\n\twdd->info = &da9063_watchdog_info;\n\twdd->ops = &da9063_watchdog_ops;\n\twdd->min_timeout = DA9063_WDT_MIN_TIMEOUT;\n\twdd->max_timeout = DA9063_WDT_MAX_TIMEOUT;\n\twdd->min_hw_heartbeat_ms = DA9063_RESET_PROTECTION_MS;\n\twdd->parent = dev;\n\twdd->status = WATCHDOG_NOWAYOUT_INIT_STATUS;\n\n\twatchdog_set_restart_priority(wdd, 128);\n\twatchdog_set_drvdata(wdd, da9063);\n\tdev_set_drvdata(dev, wdd);\n\n\twdd->timeout = DA9063_WDG_TIMEOUT;\n\n\t \n\ttimeout = da9063_wdt_read_timeout(da9063);\n\tif (timeout)\n\t\twdd->timeout = timeout;\n\n\t \n\twatchdog_init_timeout(wdd, 0, dev);\n\tda9063_wdt_set_timeout(wdd, wdd->timeout);\n\n\t \n\tif (timeout) {\n\t\tda9063_wdt_update_timeout(da9063, wdd->timeout);\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t}\n\n\treturn devm_watchdog_register_device(dev, wdd);\n}\n\nstatic int __maybe_unused da9063_wdt_suspend(struct device *dev)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\tif (!use_sw_pm)\n\t\treturn 0;\n\n\tif (watchdog_active(wdd))\n\t\treturn da9063_wdt_stop(wdd);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused da9063_wdt_resume(struct device *dev)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\tif (!use_sw_pm)\n\t\treturn 0;\n\n\tif (watchdog_active(wdd))\n\t\treturn da9063_wdt_start(wdd);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(da9063_wdt_pm_ops,\n\t\t\tda9063_wdt_suspend, da9063_wdt_resume);\n\nstatic struct platform_driver da9063_wdt_driver = {\n\t.probe = da9063_wdt_probe,\n\t.driver = {\n\t\t.name = DA9063_DRVNAME_WATCHDOG,\n\t\t.pm = &da9063_wdt_pm_ops,\n\t},\n};\nmodule_platform_driver(da9063_wdt_driver);\n\nMODULE_AUTHOR(\"Mariusz Wojtasik <mariusz.wojtasik@diasemi.com>\");\nMODULE_DESCRIPTION(\"Watchdog driver for Dialog DA9063\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DA9063_DRVNAME_WATCHDOG);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}