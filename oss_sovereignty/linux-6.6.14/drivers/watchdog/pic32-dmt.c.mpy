{
  "module_name": "pic32-dmt.c",
  "hash_id": "8de33179022cd113079857c86ae66bce7b73ea33a5022149247b6dd1d9040a22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pic32-dmt.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/watchdog.h>\n\n#include <asm/mach-pic32/pic32.h>\n\n \n#define DMTCON_REG\t0x00\n#define DMTPRECLR_REG\t0x10\n#define DMTCLR_REG\t0x20\n#define DMTSTAT_REG\t0x30\n#define DMTCNT_REG\t0x40\n#define DMTPSCNT_REG\t0x60\n#define DMTPSINTV_REG\t0x70\n\n \n#define DMT_ON\t\t\tBIT(15)\n#define DMT_STEP1_KEY\t\tBIT(6)\n#define DMT_STEP2_KEY\t\tBIT(3)\n#define DMTSTAT_WINOPN\t\tBIT(0)\n#define DMTSTAT_EVENT\t\tBIT(5)\n#define DMTSTAT_BAD2\t\tBIT(6)\n#define DMTSTAT_BAD1\t\tBIT(7)\n\n \n#define RESETCON_DMT_TIMEOUT\tBIT(5)\n\nstruct pic32_dmt {\n\tvoid __iomem\t*regs;\n\tstruct clk\t*clk;\n};\n\nstatic inline void dmt_enable(struct pic32_dmt *dmt)\n{\n\twritel(DMT_ON, PIC32_SET(dmt->regs + DMTCON_REG));\n}\n\nstatic inline void dmt_disable(struct pic32_dmt *dmt)\n{\n\twritel(DMT_ON, PIC32_CLR(dmt->regs + DMTCON_REG));\n\t \n\tnop();\n}\n\nstatic inline int dmt_bad_status(struct pic32_dmt *dmt)\n{\n\tu32 val;\n\n\tval = readl(dmt->regs + DMTSTAT_REG);\n\tval &= (DMTSTAT_BAD1 | DMTSTAT_BAD2 | DMTSTAT_EVENT);\n\tif (val)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic inline int dmt_keepalive(struct pic32_dmt *dmt)\n{\n\tu32 v;\n\tu32 timeout = 500;\n\n\t \n\twritel(DMT_STEP1_KEY << 8, dmt->regs + DMTPRECLR_REG);\n\n\t \n\twhile (--timeout) {\n\t\tv = readl(dmt->regs + DMTSTAT_REG) & DMTSTAT_WINOPN;\n\t\tif (v == DMTSTAT_WINOPN)\n\t\t\tbreak;\n\t}\n\n\t \n\twritel(DMT_STEP2_KEY, dmt->regs + DMTCLR_REG);\n\n\t \n\treturn dmt_bad_status(dmt);\n}\n\nstatic inline u32 pic32_dmt_get_timeout_secs(struct pic32_dmt *dmt)\n{\n\tunsigned long rate;\n\n\trate = clk_get_rate(dmt->clk);\n\tif (rate)\n\t\treturn readl(dmt->regs + DMTPSCNT_REG) / rate;\n\n\treturn 0;\n}\n\nstatic inline u32 pic32_dmt_bootstatus(struct pic32_dmt *dmt)\n{\n\tu32 v;\n\tvoid __iomem *rst_base;\n\n\trst_base = ioremap(PIC32_BASE_RESET, 0x10);\n\tif (!rst_base)\n\t\treturn 0;\n\n\tv = readl(rst_base);\n\n\twritel(RESETCON_DMT_TIMEOUT, PIC32_CLR(rst_base));\n\n\tiounmap(rst_base);\n\treturn v & RESETCON_DMT_TIMEOUT;\n}\n\nstatic int pic32_dmt_start(struct watchdog_device *wdd)\n{\n\tstruct pic32_dmt *dmt = watchdog_get_drvdata(wdd);\n\n\tdmt_enable(dmt);\n\treturn dmt_keepalive(dmt);\n}\n\nstatic int pic32_dmt_stop(struct watchdog_device *wdd)\n{\n\tstruct pic32_dmt *dmt = watchdog_get_drvdata(wdd);\n\n\tdmt_disable(dmt);\n\n\treturn 0;\n}\n\nstatic int pic32_dmt_ping(struct watchdog_device *wdd)\n{\n\tstruct pic32_dmt *dmt = watchdog_get_drvdata(wdd);\n\n\treturn dmt_keepalive(dmt);\n}\n\nstatic const struct watchdog_ops pic32_dmt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= pic32_dmt_start,\n\t.stop\t\t= pic32_dmt_stop,\n\t.ping\t\t= pic32_dmt_ping,\n};\n\nstatic const struct watchdog_info pic32_dmt_ident = {\n\t.options\t= WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n\t.identity\t= \"PIC32 Deadman Timer\",\n};\n\nstatic struct watchdog_device pic32_dmt_wdd = {\n\t.info\t\t= &pic32_dmt_ident,\n\t.ops\t\t= &pic32_dmt_fops,\n};\n\nstatic int pic32_dmt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tstruct pic32_dmt *dmt;\n\tstruct watchdog_device *wdd = &pic32_dmt_wdd;\n\n\tdmt = devm_kzalloc(dev, sizeof(*dmt), GFP_KERNEL);\n\tif (!dmt)\n\t\treturn -ENOMEM;\n\n\tdmt->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dmt->regs))\n\t\treturn PTR_ERR(dmt->regs);\n\n\tdmt->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(dmt->clk)) {\n\t\tdev_err(dev, \"clk not found\\n\");\n\t\treturn PTR_ERR(dmt->clk);\n\t}\n\n\twdd->timeout = pic32_dmt_get_timeout_secs(dmt);\n\tif (!wdd->timeout) {\n\t\tdev_err(dev, \"failed to read watchdog register timeout\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(dev, \"timeout %d\\n\", wdd->timeout);\n\n\twdd->bootstatus = pic32_dmt_bootstatus(dmt) ? WDIOF_CARDRESET : 0;\n\n\twatchdog_set_nowayout(wdd, WATCHDOG_NOWAYOUT);\n\twatchdog_set_drvdata(wdd, dmt);\n\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdd);\n\treturn 0;\n}\n\nstatic const struct of_device_id pic32_dmt_of_ids[] = {\n\t{ .compatible = \"microchip,pic32mzda-dmt\",},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pic32_dmt_of_ids);\n\nstatic struct platform_driver pic32_dmt_driver = {\n\t.probe\t\t= pic32_dmt_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"pic32-dmt\",\n\t\t.of_match_table = of_match_ptr(pic32_dmt_of_ids),\n\t}\n};\n\nmodule_platform_driver(pic32_dmt_driver);\n\nMODULE_AUTHOR(\"Purna Chandra Mandal <purna.mandal@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip PIC32 DMT Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}