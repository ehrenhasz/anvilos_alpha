{
  "module_name": "rtd119x_wdt.c",
  "hash_id": "1f3d03dc72065e3d1e875af161e8373537823cd426807455657124f4bae33609",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rtd119x_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define RTD119X_TCWCR\t\t0x0\n#define RTD119X_TCWTR\t\t0x4\n#define RTD119X_TCWOV\t\t0xc\n\n#define RTD119X_TCWCR_WDEN_DISABLED\t\t0xa5\n#define RTD119X_TCWCR_WDEN_ENABLED\t\t0xff\n#define RTD119X_TCWCR_WDEN_MASK\t\t\t0xff\n\n#define RTD119X_TCWTR_WDCLR\t\t\tBIT(0)\n\nstruct rtd119x_watchdog_device {\n\tstruct watchdog_device wdt_dev;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic int rtd119x_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct rtd119x_watchdog_device *data = watchdog_get_drvdata(wdev);\n\tu32 val;\n\n\tval = readl_relaxed(data->base + RTD119X_TCWCR);\n\tval &= ~RTD119X_TCWCR_WDEN_MASK;\n\tval |= RTD119X_TCWCR_WDEN_ENABLED;\n\twritel(val, data->base + RTD119X_TCWCR);\n\n\treturn 0;\n}\n\nstatic int rtd119x_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct rtd119x_watchdog_device *data = watchdog_get_drvdata(wdev);\n\tu32 val;\n\n\tval = readl_relaxed(data->base + RTD119X_TCWCR);\n\tval &= ~RTD119X_TCWCR_WDEN_MASK;\n\tval |= RTD119X_TCWCR_WDEN_DISABLED;\n\twritel(val, data->base + RTD119X_TCWCR);\n\n\treturn 0;\n}\n\nstatic int rtd119x_wdt_ping(struct watchdog_device *wdev)\n{\n\tstruct rtd119x_watchdog_device *data = watchdog_get_drvdata(wdev);\n\n\twritel_relaxed(RTD119X_TCWTR_WDCLR, data->base + RTD119X_TCWTR);\n\n\treturn rtd119x_wdt_start(wdev);\n}\n\nstatic int rtd119x_wdt_set_timeout(struct watchdog_device *wdev, unsigned int val)\n{\n\tstruct rtd119x_watchdog_device *data = watchdog_get_drvdata(wdev);\n\n\twritel(val * clk_get_rate(data->clk), data->base + RTD119X_TCWOV);\n\n\tdata->wdt_dev.timeout = val;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops rtd119x_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start\t\t= rtd119x_wdt_start,\n\t.stop\t\t= rtd119x_wdt_stop,\n\t.ping\t\t= rtd119x_wdt_ping,\n\t.set_timeout\t= rtd119x_wdt_set_timeout,\n};\n\nstatic const struct watchdog_info rtd119x_wdt_info = {\n\t.identity = \"rtd119x-wdt\",\n\t.options = 0,\n};\n\nstatic const struct of_device_id rtd119x_wdt_dt_ids[] = {\n\t { .compatible = \"realtek,rtd1295-watchdog\" },\n\t { }\n};\n\nstatic int rtd119x_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rtd119x_watchdog_device *data;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->base))\n\t\treturn PTR_ERR(data->base);\n\n\tdata->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(data->clk))\n\t\treturn PTR_ERR(data->clk);\n\n\tdata->wdt_dev.info = &rtd119x_wdt_info;\n\tdata->wdt_dev.ops = &rtd119x_wdt_ops;\n\tdata->wdt_dev.timeout = 120;\n\tdata->wdt_dev.max_timeout = 0xffffffff / clk_get_rate(data->clk);\n\tdata->wdt_dev.min_timeout = 1;\n\tdata->wdt_dev.parent = dev;\n\n\twatchdog_stop_on_reboot(&data->wdt_dev);\n\twatchdog_set_drvdata(&data->wdt_dev, data);\n\tplatform_set_drvdata(pdev, data);\n\n\twritel_relaxed(RTD119X_TCWTR_WDCLR, data->base + RTD119X_TCWTR);\n\trtd119x_wdt_set_timeout(&data->wdt_dev, data->wdt_dev.timeout);\n\trtd119x_wdt_stop(&data->wdt_dev);\n\n\treturn devm_watchdog_register_device(dev, &data->wdt_dev);\n}\n\nstatic struct platform_driver rtd119x_wdt_driver = {\n\t.probe = rtd119x_wdt_probe,\n\t.driver = {\n\t\t.name = \"rtd1295-watchdog\",\n\t\t.of_match_table\t= rtd119x_wdt_dt_ids,\n\t},\n};\nbuiltin_platform_driver(rtd119x_wdt_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}