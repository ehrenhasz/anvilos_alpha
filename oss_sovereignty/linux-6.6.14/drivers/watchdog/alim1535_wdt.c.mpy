{
  "module_name": "alim1535_wdt.c",
  "hash_id": "65772157b20d6ddce0489af1633cf1628b62b69b51d61c1e1e2858fbbdf00285",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/alim1535_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/ioport.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#define WATCHDOG_NAME \"ALi_M1535\"\n#define WATCHDOG_TIMEOUT 60\t \n\n \nstatic unsigned long ali_is_open;\nstatic char ali_expect_release;\nstatic struct pci_dev *ali_pci;\nstatic u32 ali_timeout_bits;\t\t \nstatic DEFINE_SPINLOCK(ali_lock);\t \n\n \nstatic int timeout = WATCHDOG_TIMEOUT;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\t\"Watchdog timeout in seconds. (0 < timeout < 18000, default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n\nstatic void ali_start(void)\n{\n\tu32 val;\n\n\tspin_lock(&ali_lock);\n\n\tpci_read_config_dword(ali_pci, 0xCC, &val);\n\tval &= ~0x3F;\t \n\tval |= (1 << 25) | ali_timeout_bits;\n\tpci_write_config_dword(ali_pci, 0xCC, val);\n\n\tspin_unlock(&ali_lock);\n}\n\n \n\nstatic void ali_stop(void)\n{\n\tu32 val;\n\n\tspin_lock(&ali_lock);\n\n\tpci_read_config_dword(ali_pci, 0xCC, &val);\n\tval &= ~0x3F;\t\t \n\tval &= ~(1 << 25);\t \n\tpci_write_config_dword(ali_pci, 0xCC, val);\n\n\tspin_unlock(&ali_lock);\n}\n\n \n\nstatic void ali_keepalive(void)\n{\n\tali_start();\n}\n\n \n\nstatic int ali_settimer(int t)\n{\n\tif (t < 0)\n\t\treturn -EINVAL;\n\telse if (t < 60)\n\t\tali_timeout_bits = t|(1 << 6);\n\telse if (t < 3600)\n\t\tali_timeout_bits = (t / 60)|(1 << 7);\n\telse if (t < 18000)\n\t\tali_timeout_bits = (t / 300)|(1 << 6)|(1 << 7);\n\telse\n\t\treturn -EINVAL;\n\n\ttimeout = t;\n\treturn 0;\n}\n\n \n\n \n\nstatic ssize_t ali_write(struct file *file, const char __user *data,\n\t\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\t \n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\tali_expect_release = 0;\n\n\t\t\t \n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\tali_expect_release = 42;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tali_start();\n\t}\n\treturn len;\n}\n\n \n\nstatic long ali_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\t\tWDIOF_SETTIMEOUT |\n\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.firmware_version =\t0,\n\t\t.identity =\t\t\"ALi M1535 WatchDog Timer\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint new_options, retval = -EINVAL;\n\n\t\tif (get_user(new_options, p))\n\t\t\treturn -EFAULT;\n\t\tif (new_options & WDIOS_DISABLECARD) {\n\t\t\tali_stop();\n\t\t\tretval = 0;\n\t\t}\n\t\tif (new_options & WDIOS_ENABLECARD) {\n\t\t\tali_start();\n\t\t\tretval = 0;\n\t\t}\n\t\treturn retval;\n\t}\n\tcase WDIOC_KEEPALIVE:\n\t\tali_keepalive();\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t{\n\t\tint new_timeout;\n\t\tif (get_user(new_timeout, p))\n\t\t\treturn -EFAULT;\n\t\tif (ali_settimer(new_timeout))\n\t\t\treturn -EINVAL;\n\t\tali_keepalive();\n\t}\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(timeout, p);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \n\nstatic int ali_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &ali_is_open))\n\t\treturn -EBUSY;\n\n\t \n\tali_start();\n\treturn stream_open(inode, file);\n}\n\n \n\nstatic int ali_release(struct inode *inode, struct file *file)\n{\n\t \n\tif (ali_expect_release == 42)\n\t\tali_stop();\n\telse {\n\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\tali_keepalive();\n\t}\n\tclear_bit(0, &ali_is_open);\n\tali_expect_release = 0;\n\treturn 0;\n}\n\n \n\n\nstatic int ali_notify_sys(struct notifier_block *this,\n\t\t\t\t\tunsigned long code, void *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\tali_stop();\t\t \n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic const struct pci_device_id ali_pci_tbl[] __used = {\n\t{ PCI_VENDOR_ID_AL, 0x1533, PCI_ANY_ID, PCI_ANY_ID,},\n\t{ PCI_VENDOR_ID_AL, 0x1535, PCI_ANY_ID, PCI_ANY_ID,},\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, ali_pci_tbl);\n\n \n\nstatic int __init ali_find_watchdog(void)\n{\n\tstruct pci_dev *pdev;\n\tu32 wdog;\n\n\t \n\tpdev = pci_get_device(PCI_VENDOR_ID_AL, 0x1535, NULL);\n\tif (pdev == NULL)\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_AL, 0x1533, NULL);\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\tpci_dev_put(pdev);\n\n\t \n\tpdev = pci_get_device(PCI_VENDOR_ID_AL, 0x7101, NULL);\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tif (pci_enable_device(pdev)) {\n\t\tpci_dev_put(pdev);\n\t\treturn -EIO;\n\t}\n\n\tali_pci = pdev;\n\n\t \n\tpci_read_config_dword(pdev, 0xCC, &wdog);\n\n\t \n\twdog &= ~0x3F;\n\t \n\twdog &= ~((1 << 27)|(1 << 26)|(1 << 25)|(1 << 24));\n\t \n\twdog &= ~((1 << 16)|(1 << 13)|(1 << 12)|(1 << 11)|(1 << 10)|(1 << 9));\n\n\tpci_write_config_dword(pdev, 0xCC, wdog);\n\n\treturn 0;\n}\n\n \n\nstatic const struct file_operations ali_fops = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.llseek\t\t=\tno_llseek,\n\t.write\t\t=\tali_write,\n\t.unlocked_ioctl =\tali_ioctl,\n\t.compat_ioctl\t= \tcompat_ptr_ioctl,\n\t.open\t\t=\tali_open,\n\t.release\t=\tali_release,\n};\n\nstatic struct miscdevice ali_miscdev = {\n\t.minor =\tWATCHDOG_MINOR,\n\t.name =\t\t\"watchdog\",\n\t.fops =\t\t&ali_fops,\n};\n\nstatic struct notifier_block ali_notifier = {\n\t.notifier_call =\tali_notify_sys,\n};\n\n \n\nstatic int __init watchdog_init(void)\n{\n\tint ret;\n\n\t \n\tif (ali_find_watchdog() != 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (timeout < 1 || timeout >= 18000) {\n\t\ttimeout = WATCHDOG_TIMEOUT;\n\t\tpr_info(\"timeout value must be 0 < timeout < 18000, using %d\\n\",\n\t\t\ttimeout);\n\t}\n\n\t \n\tali_settimer(timeout);\n\n\tret = register_reboot_notifier(&ali_notifier);\n\tif (ret != 0) {\n\t\tpr_err(\"cannot register reboot notifier (err=%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = misc_register(&ali_miscdev);\n\tif (ret != 0) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, ret);\n\t\tgoto unreg_reboot;\n\t}\n\n\tpr_info(\"initialized. timeout=%d sec (nowayout=%d)\\n\",\n\t\ttimeout, nowayout);\n\nout:\n\treturn ret;\nunreg_reboot:\n\tunregister_reboot_notifier(&ali_notifier);\n\tgoto out;\n}\n\n \n\nstatic void __exit watchdog_exit(void)\n{\n\t \n\tali_stop();\n\n\t \n\tmisc_deregister(&ali_miscdev);\n\tunregister_reboot_notifier(&ali_notifier);\n\tpci_dev_put(ali_pci);\n}\n\nmodule_init(watchdog_init);\nmodule_exit(watchdog_exit);\n\nMODULE_AUTHOR(\"Alan Cox\");\nMODULE_DESCRIPTION(\"ALi M1535 PMU Watchdog Timer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}