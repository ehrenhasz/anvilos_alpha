{
  "module_name": "npcm_wdt.c",
  "hash_id": "2c19026832f087f065dde7032e76f3635eaf10b2036201c4930c86fe266a0677",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/npcm_wdt.c",
  "human_readable_source": "\n\n\n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/watchdog.h>\n\n#define NPCM_WTCR\t0x1C\n\n#define NPCM_WTCLK\t(BIT(10) | BIT(11))\t \n#define NPCM_WTE\tBIT(7)\t\t\t \n#define NPCM_WTIE\tBIT(6)\t\t\t \n#define NPCM_WTIS\t(BIT(4) | BIT(5))\t \n#define NPCM_WTIF\tBIT(3)\t\t\t \n#define NPCM_WTRF\tBIT(2)\t\t\t \n#define NPCM_WTRE\tBIT(1)\t\t\t \n#define NPCM_WTR\tBIT(0)\t\t\t \n\n \n\nstruct npcm_wdt {\n\tstruct watchdog_device  wdd;\n\tvoid __iomem\t\t*reg;\n\tstruct clk\t\t*clk;\n};\n\nstatic inline struct npcm_wdt *to_npcm_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct npcm_wdt, wdd);\n}\n\nstatic int npcm_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct npcm_wdt *wdt = to_npcm_wdt(wdd);\n\tu32 val;\n\n\tval = readl(wdt->reg);\n\twritel(val | NPCM_WTR, wdt->reg);\n\n\treturn 0;\n}\n\nstatic int npcm_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct npcm_wdt *wdt = to_npcm_wdt(wdd);\n\tu32 val;\n\n\tif (wdt->clk)\n\t\tclk_prepare_enable(wdt->clk);\n\n\tif (wdd->timeout < 2)\n\t\tval = 0x800;\n\telse if (wdd->timeout < 3)\n\t\tval = 0x420;\n\telse if (wdd->timeout < 6)\n\t\tval = 0x810;\n\telse if (wdd->timeout < 11)\n\t\tval = 0x430;\n\telse if (wdd->timeout < 22)\n\t\tval = 0x820;\n\telse if (wdd->timeout < 44)\n\t\tval = 0xC00;\n\telse if (wdd->timeout < 87)\n\t\tval = 0x830;\n\telse if (wdd->timeout < 173)\n\t\tval = 0xC10;\n\telse if (wdd->timeout < 688)\n\t\tval = 0xC20;\n\telse\n\t\tval = 0xC30;\n\n\tval |= NPCM_WTRE | NPCM_WTE | NPCM_WTR | NPCM_WTIE;\n\n\twritel(val, wdt->reg);\n\n\treturn 0;\n}\n\nstatic int npcm_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct npcm_wdt *wdt = to_npcm_wdt(wdd);\n\n\twritel(0, wdt->reg);\n\n\tif (wdt->clk)\n\t\tclk_disable_unprepare(wdt->clk);\n\n\treturn 0;\n}\n\nstatic int npcm_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\tunsigned int timeout)\n{\n\tif (timeout < 2)\n\t\twdd->timeout = 1;\n\telse if (timeout < 3)\n\t\twdd->timeout = 2;\n\telse if (timeout < 6)\n\t\twdd->timeout = 5;\n\telse if (timeout < 11)\n\t\twdd->timeout = 10;\n\telse if (timeout < 22)\n\t\twdd->timeout = 21;\n\telse if (timeout < 44)\n\t\twdd->timeout = 43;\n\telse if (timeout < 87)\n\t\twdd->timeout = 86;\n\telse if (timeout < 173)\n\t\twdd->timeout = 172;\n\telse if (timeout < 688)\n\t\twdd->timeout = 687;\n\telse\n\t\twdd->timeout = 2750;\n\n\tif (watchdog_active(wdd))\n\t\tnpcm_wdt_start(wdd);\n\n\treturn 0;\n}\n\nstatic irqreturn_t npcm_wdt_interrupt(int irq, void *data)\n{\n\tstruct npcm_wdt *wdt = data;\n\n\twatchdog_notify_pretimeout(&wdt->wdd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int npcm_wdt_restart(struct watchdog_device *wdd,\n\t\t\t    unsigned long action, void *data)\n{\n\tstruct npcm_wdt *wdt = to_npcm_wdt(wdd);\n\n\t \n\tif (wdt->clk)\n\t\tclk_prepare_enable(wdt->clk);\n\n\twritel(NPCM_WTR | NPCM_WTRE | NPCM_WTE, wdt->reg);\n\tudelay(1000);\n\n\treturn 0;\n}\n\nstatic bool npcm_is_running(struct watchdog_device *wdd)\n{\n\tstruct npcm_wdt *wdt = to_npcm_wdt(wdd);\n\n\treturn readl(wdt->reg) & NPCM_WTE;\n}\n\nstatic const struct watchdog_info npcm_wdt_info = {\n\t.identity\t= KBUILD_MODNAME,\n\t.options\t= WDIOF_SETTIMEOUT\n\t\t\t| WDIOF_KEEPALIVEPING\n\t\t\t| WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops npcm_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = npcm_wdt_start,\n\t.stop = npcm_wdt_stop,\n\t.ping = npcm_wdt_ping,\n\t.set_timeout = npcm_wdt_set_timeout,\n\t.restart = npcm_wdt_restart,\n};\n\nstatic int npcm_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct npcm_wdt *wdt;\n\tint irq;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->reg))\n\t\treturn PTR_ERR(wdt->reg);\n\n\twdt->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(wdt->clk))\n\t\treturn PTR_ERR(wdt->clk);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\twdt->wdd.info = &npcm_wdt_info;\n\twdt->wdd.ops = &npcm_wdt_ops;\n\twdt->wdd.min_timeout = 1;\n\twdt->wdd.max_timeout = 2750;\n\twdt->wdd.parent = dev;\n\n\twdt->wdd.timeout = 86;\n\twatchdog_init_timeout(&wdt->wdd, 0, dev);\n\n\t \n\tnpcm_wdt_set_timeout(&wdt->wdd, wdt->wdd.timeout);\n\n\tif (npcm_is_running(&wdt->wdd)) {\n\t\t \n\t\tnpcm_wdt_start(&wdt->wdd);\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdd.status);\n\t}\n\n\tret = devm_request_irq(dev, irq, npcm_wdt_interrupt, 0, \"watchdog\",\n\t\t\t       wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_watchdog_register_device(dev, &wdt->wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"NPCM watchdog driver enabled\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id npcm_wdt_match[] = {\n\t{.compatible = \"nuvoton,wpcm450-wdt\"},\n\t{.compatible = \"nuvoton,npcm750-wdt\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, npcm_wdt_match);\n#endif\n\nstatic struct platform_driver npcm_wdt_driver = {\n\t.probe\t\t= npcm_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"npcm-wdt\",\n\t\t.of_match_table = of_match_ptr(npcm_wdt_match),\n\t},\n};\nmodule_platform_driver(npcm_wdt_driver);\n\nMODULE_AUTHOR(\"Joel Stanley\");\nMODULE_DESCRIPTION(\"Watchdog driver for NPCM\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}