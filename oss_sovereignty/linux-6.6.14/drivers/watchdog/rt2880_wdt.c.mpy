{
  "module_name": "rt2880_wdt.c",
  "hash_id": "3d056e972867a38b61b18fec0db9995b58692bde43fd3f3f20929c660619b5c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rt2880_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/watchdog.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n\n#include <asm/mach-ralink/ralink_regs.h>\n\n#define SYSC_RSTSTAT\t\t\t0x38\n#define WDT_RST_CAUSE\t\t\tBIT(1)\n\n#define RALINK_WDT_TIMEOUT\t\t30\n#define RALINK_WDT_PRESCALE\t\t65536\n\n#define TIMER_REG_TMR1LOAD\t\t0x00\n#define TIMER_REG_TMR1CTL\t\t0x08\n\n#define TMRSTAT_TMR1RST\t\t\tBIT(5)\n\n#define TMR1CTL_ENABLE\t\t\tBIT(7)\n#define TMR1CTL_MODE_SHIFT\t\t4\n#define TMR1CTL_MODE_MASK\t\t0x3\n#define TMR1CTL_MODE_FREE_RUNNING\t0x0\n#define TMR1CTL_MODE_PERIODIC\t\t0x1\n#define TMR1CTL_MODE_TIMEOUT\t\t0x2\n#define TMR1CTL_MODE_WDT\t\t0x3\n#define TMR1CTL_PRESCALE_MASK\t\t0xf\n#define TMR1CTL_PRESCALE_65536\t\t0xf\n\nstruct rt2880_wdt_data {\n\tvoid __iomem *base;\n\tunsigned long freq;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tstruct watchdog_device wdt;\n};\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic inline void rt_wdt_w32(void __iomem *base, unsigned int reg, u32 val)\n{\n\tiowrite32(val, base + reg);\n}\n\nstatic inline u32 rt_wdt_r32(void __iomem *base, unsigned int reg)\n{\n\treturn ioread32(base + reg);\n}\n\nstatic int rt288x_wdt_ping(struct watchdog_device *w)\n{\n\tstruct rt2880_wdt_data *drvdata = watchdog_get_drvdata(w);\n\n\trt_wdt_w32(drvdata->base, TIMER_REG_TMR1LOAD, w->timeout * drvdata->freq);\n\n\treturn 0;\n}\n\nstatic int rt288x_wdt_start(struct watchdog_device *w)\n{\n\tstruct rt2880_wdt_data *drvdata = watchdog_get_drvdata(w);\n\tu32 t;\n\n\tt = rt_wdt_r32(drvdata->base, TIMER_REG_TMR1CTL);\n\tt &= ~(TMR1CTL_MODE_MASK << TMR1CTL_MODE_SHIFT |\n\t\tTMR1CTL_PRESCALE_MASK);\n\tt |= (TMR1CTL_MODE_WDT << TMR1CTL_MODE_SHIFT |\n\t\tTMR1CTL_PRESCALE_65536);\n\trt_wdt_w32(drvdata->base, TIMER_REG_TMR1CTL, t);\n\n\trt288x_wdt_ping(w);\n\n\tt = rt_wdt_r32(drvdata->base, TIMER_REG_TMR1CTL);\n\tt |= TMR1CTL_ENABLE;\n\trt_wdt_w32(drvdata->base, TIMER_REG_TMR1CTL, t);\n\n\treturn 0;\n}\n\nstatic int rt288x_wdt_stop(struct watchdog_device *w)\n{\n\tstruct rt2880_wdt_data *drvdata = watchdog_get_drvdata(w);\n\tu32 t;\n\n\trt288x_wdt_ping(w);\n\n\tt = rt_wdt_r32(drvdata->base, TIMER_REG_TMR1CTL);\n\tt &= ~TMR1CTL_ENABLE;\n\trt_wdt_w32(drvdata->base, TIMER_REG_TMR1CTL, t);\n\n\treturn 0;\n}\n\nstatic int rt288x_wdt_set_timeout(struct watchdog_device *w, unsigned int t)\n{\n\tw->timeout = t;\n\trt288x_wdt_ping(w);\n\n\treturn 0;\n}\n\nstatic int rt288x_wdt_bootcause(void)\n{\n\tif (rt_sysc_r32(SYSC_RSTSTAT) & WDT_RST_CAUSE)\n\t\treturn WDIOF_CARDRESET;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info rt288x_wdt_info = {\n\t.identity = \"Ralink Watchdog\",\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops rt288x_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = rt288x_wdt_start,\n\t.stop = rt288x_wdt_stop,\n\t.ping = rt288x_wdt_ping,\n\t.set_timeout = rt288x_wdt_set_timeout,\n};\n\nstatic int rt288x_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdt;\n\tstruct rt2880_wdt_data *drvdata;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drvdata->base))\n\t\treturn PTR_ERR(drvdata->base);\n\n\tdrvdata->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(drvdata->clk))\n\t\treturn PTR_ERR(drvdata->clk);\n\n\tdrvdata->rst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (!IS_ERR(drvdata->rst))\n\t\treset_control_deassert(drvdata->rst);\n\n\tdrvdata->freq = clk_get_rate(drvdata->clk) / RALINK_WDT_PRESCALE;\n\n\twdt = &drvdata->wdt;\n\twdt->info = &rt288x_wdt_info;\n\twdt->ops = &rt288x_wdt_ops;\n\twdt->min_timeout = 1;\n\twdt->max_timeout = (0xfffful / drvdata->freq);\n\twdt->parent = dev;\n\twdt->bootstatus = rt288x_wdt_bootcause();\n\n\twatchdog_init_timeout(wdt, wdt->max_timeout, dev);\n\twatchdog_set_nowayout(wdt, nowayout);\n\twatchdog_set_drvdata(wdt, drvdata);\n\n\twatchdog_stop_on_reboot(wdt);\n\tret = devm_watchdog_register_device(dev, &drvdata->wdt);\n\tif (!ret)\n\t\tdev_info(dev, \"Initialized\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rt288x_wdt_match[] = {\n\t{ .compatible = \"ralink,rt2880-wdt\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt288x_wdt_match);\n\nstatic struct platform_driver rt288x_wdt_driver = {\n\t.probe\t\t= rt288x_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= rt288x_wdt_match,\n\t},\n};\n\nmodule_platform_driver(rt288x_wdt_driver);\n\nMODULE_DESCRIPTION(\"MediaTek/Ralink RT288x/RT3xxx hardware watchdog driver\");\nMODULE_AUTHOR(\"Gabor Juhos <juhosg@openwrt.org\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}