{
  "module_name": "davinci_wdt.c",
  "hash_id": "8eb2e1361b796bee01d6ff27b75fe16ea4ef458bd3f66b494c4d6332ca42714e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/davinci_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n\n#define MODULE_NAME \"DAVINCI-WDT: \"\n\n#define DEFAULT_HEARTBEAT 60\n#define MAX_HEARTBEAT     600\t \n\n \n#define PID12\t(0x0)\n#define EMUMGT\t(0x4)\n#define TIM12\t(0x10)\n#define TIM34\t(0x14)\n#define PRD12\t(0x18)\n#define PRD34\t(0x1C)\n#define TCR\t(0x20)\n#define TGCR\t(0x24)\n#define WDTCR\t(0x28)\n\n \n#define ENAMODE12_DISABLED\t(0 << 6)\n#define ENAMODE12_ONESHOT\t(1 << 6)\n#define ENAMODE12_PERIODIC\t(2 << 6)\n\n \n#define TIM12RS_UNRESET\t\t(1 << 0)\n#define TIM34RS_UNRESET\t\t(1 << 1)\n#define TIMMODE_64BIT_WDOG      (2 << 2)\n\n \n#define WDEN\t\t\t(1 << 14)\n#define WDFLAG\t\t\t(1 << 15)\n#define WDKEY_SEQ0\t\t(0xa5c6 << 16)\n#define WDKEY_SEQ1\t\t(0xda7e << 16)\n\nstatic int heartbeat;\n\n \nstruct davinci_wdt_device {\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tstruct watchdog_device\twdd;\n};\n\nstatic int davinci_wdt_start(struct watchdog_device *wdd)\n{\n\tu32 tgcr;\n\tu32 timer_margin;\n\tunsigned long wdt_freq;\n\tstruct davinci_wdt_device *davinci_wdt = watchdog_get_drvdata(wdd);\n\n\twdt_freq = clk_get_rate(davinci_wdt->clk);\n\n\t \n\tiowrite32(0, davinci_wdt->base + TCR);\n\t \n\tiowrite32(0, davinci_wdt->base + TGCR);\n\ttgcr = TIMMODE_64BIT_WDOG | TIM12RS_UNRESET | TIM34RS_UNRESET;\n\tiowrite32(tgcr, davinci_wdt->base + TGCR);\n\t \n\tiowrite32(0, davinci_wdt->base + TIM12);\n\tiowrite32(0, davinci_wdt->base + TIM34);\n\t \n\ttimer_margin = (((u64)wdd->timeout * wdt_freq) & 0xffffffff);\n\tiowrite32(timer_margin, davinci_wdt->base + PRD12);\n\ttimer_margin = (((u64)wdd->timeout * wdt_freq) >> 32);\n\tiowrite32(timer_margin, davinci_wdt->base + PRD34);\n\t \n\tiowrite32(ENAMODE12_PERIODIC, davinci_wdt->base + TCR);\n\t \n\t \n\tiowrite32(WDKEY_SEQ0 | WDEN, davinci_wdt->base + WDTCR);\n\t \n\tiowrite32(WDKEY_SEQ1 | WDEN, davinci_wdt->base + WDTCR);\n\treturn 0;\n}\n\nstatic int davinci_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct davinci_wdt_device *davinci_wdt = watchdog_get_drvdata(wdd);\n\n\t \n\tiowrite32(WDKEY_SEQ0, davinci_wdt->base + WDTCR);\n\t \n\tiowrite32(WDKEY_SEQ1, davinci_wdt->base + WDTCR);\n\treturn 0;\n}\n\nstatic unsigned int davinci_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tu64 timer_counter;\n\tunsigned long freq;\n\tu32 val;\n\tstruct davinci_wdt_device *davinci_wdt = watchdog_get_drvdata(wdd);\n\n\t \n\tval = ioread32(davinci_wdt->base + WDTCR);\n\tif (val & WDFLAG)\n\t\treturn 0;\n\n\tfreq = clk_get_rate(davinci_wdt->clk);\n\n\tif (!freq)\n\t\treturn 0;\n\n\ttimer_counter = ioread32(davinci_wdt->base + TIM12);\n\ttimer_counter |= ((u64)ioread32(davinci_wdt->base + TIM34) << 32);\n\n\ttimer_counter = div64_ul(timer_counter, freq);\n\n\treturn wdd->timeout - timer_counter;\n}\n\nstatic int davinci_wdt_restart(struct watchdog_device *wdd,\n\t\t\t       unsigned long action, void *data)\n{\n\tstruct davinci_wdt_device *davinci_wdt = watchdog_get_drvdata(wdd);\n\tu32 tgcr, wdtcr;\n\n\t \n\tiowrite32(0, davinci_wdt->base + TCR);\n\n\t \n\ttgcr = 0;\n\tiowrite32(tgcr, davinci_wdt->base + TGCR);\n\ttgcr = TIMMODE_64BIT_WDOG | TIM12RS_UNRESET | TIM34RS_UNRESET;\n\tiowrite32(tgcr, davinci_wdt->base + TGCR);\n\n\t \n\tiowrite32(0, davinci_wdt->base + TIM12);\n\tiowrite32(0, davinci_wdt->base + TIM34);\n\tiowrite32(0, davinci_wdt->base + PRD12);\n\tiowrite32(0, davinci_wdt->base + PRD34);\n\n\t \n\twdtcr = WDKEY_SEQ0 | WDEN;\n\tiowrite32(wdtcr, davinci_wdt->base + WDTCR);\n\n\t \n\twdtcr = WDKEY_SEQ1 | WDEN;\n\tiowrite32(wdtcr, davinci_wdt->base + WDTCR);\n\n\t \n\twdtcr = 0x00004000;\n\tiowrite32(wdtcr, davinci_wdt->base + WDTCR);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info davinci_wdt_info = {\n\t.options = WDIOF_KEEPALIVEPING,\n\t.identity = \"DaVinci/Keystone Watchdog\",\n};\n\nstatic const struct watchdog_ops davinci_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= davinci_wdt_start,\n\t.stop\t\t= davinci_wdt_ping,\n\t.ping\t\t= davinci_wdt_ping,\n\t.get_timeleft\t= davinci_wdt_get_timeleft,\n\t.restart\t= davinci_wdt_restart,\n};\n\nstatic int davinci_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct davinci_wdt_device *davinci_wdt;\n\n\tdavinci_wdt = devm_kzalloc(dev, sizeof(*davinci_wdt), GFP_KERNEL);\n\tif (!davinci_wdt)\n\t\treturn -ENOMEM;\n\n\tdavinci_wdt->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(davinci_wdt->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(davinci_wdt->clk),\n\t\t\t\t     \"failed to get clock node\\n\");\n\n\tplatform_set_drvdata(pdev, davinci_wdt);\n\n\twdd\t\t\t= &davinci_wdt->wdd;\n\twdd->info\t\t= &davinci_wdt_info;\n\twdd->ops\t\t= &davinci_wdt_ops;\n\twdd->min_timeout\t= 1;\n\twdd->max_timeout\t= MAX_HEARTBEAT;\n\twdd->timeout\t\t= DEFAULT_HEARTBEAT;\n\twdd->parent\t\t= dev;\n\n\twatchdog_init_timeout(wdd, heartbeat, dev);\n\n\tdev_info(dev, \"heartbeat %d sec\\n\", wdd->timeout);\n\n\twatchdog_set_drvdata(wdd, davinci_wdt);\n\twatchdog_set_nowayout(wdd, 1);\n\twatchdog_set_restart_priority(wdd, 128);\n\n\tdavinci_wdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(davinci_wdt->base))\n\t\treturn PTR_ERR(davinci_wdt->base);\n\n\treturn devm_watchdog_register_device(dev, wdd);\n}\n\nstatic const struct of_device_id davinci_wdt_of_match[] = {\n\t{ .compatible = \"ti,davinci-wdt\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, davinci_wdt_of_match);\n\nstatic struct platform_driver platform_wdt_driver = {\n\t.driver = {\n\t\t.name = \"davinci-wdt\",\n\t\t.of_match_table = davinci_wdt_of_match,\n\t},\n\t.probe = davinci_wdt_probe,\n};\n\nmodule_platform_driver(platform_wdt_driver);\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"DaVinci Watchdog Driver\");\n\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\t \"Watchdog heartbeat period in seconds from 1 to \"\n\t\t __MODULE_STRING(MAX_HEARTBEAT) \", default \"\n\t\t __MODULE_STRING(DEFAULT_HEARTBEAT));\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:davinci-wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}