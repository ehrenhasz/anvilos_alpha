{
  "module_name": "imx_sc_wdt.c",
  "hash_id": "01fc28d428776fd0a1e644af555ed695ea09a1e8982793682d65b6b1559e0343",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/imx_sc_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define DEFAULT_TIMEOUT 60\n \n#define MAX_TIMEOUT 128\n\n#define IMX_SIP_TIMER\t\t\t0xC2000002\n#define IMX_SIP_TIMER_START_WDOG\t\t0x01\n#define IMX_SIP_TIMER_STOP_WDOG\t\t0x02\n#define IMX_SIP_TIMER_SET_WDOG_ACT\t0x03\n#define IMX_SIP_TIMER_PING_WDOG\t\t0x04\n#define IMX_SIP_TIMER_SET_TIMEOUT_WDOG\t0x05\n#define IMX_SIP_TIMER_GET_WDOG_STAT\t0x06\n#define IMX_SIP_TIMER_SET_PRETIME_WDOG\t0x07\n\n#define SC_TIMER_WDOG_ACTION_PARTITION\t0\n\n#define SC_IRQ_WDOG\t\t\t1\n#define SC_IRQ_GROUP_WDOG\t\t1\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0000);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct imx_sc_wdt_device {\n\tstruct watchdog_device wdd;\n\tstruct notifier_block wdt_notifier;\n};\n\nstatic int imx_sc_wdt_ping(struct watchdog_device *wdog)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(IMX_SIP_TIMER, IMX_SIP_TIMER_PING_WDOG,\n\t\t      0, 0, 0, 0, 0, 0, &res);\n\n\treturn 0;\n}\n\nstatic int imx_sc_wdt_start(struct watchdog_device *wdog)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(IMX_SIP_TIMER, IMX_SIP_TIMER_START_WDOG,\n\t\t      0, 0, 0, 0, 0, 0, &res);\n\tif (res.a0)\n\t\treturn -EACCES;\n\n\tarm_smccc_smc(IMX_SIP_TIMER, IMX_SIP_TIMER_SET_WDOG_ACT,\n\t\t      SC_TIMER_WDOG_ACTION_PARTITION,\n\t\t      0, 0, 0, 0, 0, &res);\n\treturn res.a0 ? -EACCES : 0;\n}\n\nstatic int imx_sc_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(IMX_SIP_TIMER, IMX_SIP_TIMER_STOP_WDOG,\n\t\t      0, 0, 0, 0, 0, 0, &res);\n\n\treturn res.a0 ? -EACCES : 0;\n}\n\nstatic int imx_sc_wdt_set_timeout(struct watchdog_device *wdog,\n\t\t\t\tunsigned int timeout)\n{\n\tstruct arm_smccc_res res;\n\n\twdog->timeout = timeout;\n\tarm_smccc_smc(IMX_SIP_TIMER, IMX_SIP_TIMER_SET_TIMEOUT_WDOG,\n\t\t      timeout * 1000, 0, 0, 0, 0, 0, &res);\n\n\treturn res.a0 ? -EACCES : 0;\n}\n\nstatic int imx_sc_wdt_set_pretimeout(struct watchdog_device *wdog,\n\t\t\t\t     unsigned int pretimeout)\n{\n\tstruct arm_smccc_res res;\n\n\t \n\tarm_smccc_smc(IMX_SIP_TIMER, IMX_SIP_TIMER_SET_PRETIME_WDOG,\n\t\t      (wdog->timeout - pretimeout) * 1000, 0, 0, 0,\n\t\t      0, 0, &res);\n\tif (res.a0)\n\t\treturn -EACCES;\n\n\twdog->pretimeout = pretimeout;\n\n\treturn 0;\n}\n\nstatic int imx_sc_wdt_notify(struct notifier_block *nb,\n\t\t\t     unsigned long event, void *group)\n{\n\tstruct imx_sc_wdt_device *imx_sc_wdd =\n\t\t\t\t container_of(nb,\n\t\t\t\t\t      struct imx_sc_wdt_device,\n\t\t\t\t\t      wdt_notifier);\n\n\tif (event & SC_IRQ_WDOG &&\n\t    *(u8 *)group == SC_IRQ_GROUP_WDOG)\n\t\twatchdog_notify_pretimeout(&imx_sc_wdd->wdd);\n\n\treturn 0;\n}\n\nstatic void imx_sc_wdt_action(void *data)\n{\n\tstruct notifier_block *wdt_notifier = data;\n\n\timx_scu_irq_unregister_notifier(wdt_notifier);\n\timx_scu_irq_group_enable(SC_IRQ_GROUP_WDOG,\n\t\t\t\t SC_IRQ_WDOG,\n\t\t\t\t false);\n}\n\nstatic const struct watchdog_ops imx_sc_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = imx_sc_wdt_start,\n\t.stop  = imx_sc_wdt_stop,\n\t.ping  = imx_sc_wdt_ping,\n\t.set_timeout = imx_sc_wdt_set_timeout,\n\t.set_pretimeout = imx_sc_wdt_set_pretimeout,\n};\n\nstatic struct watchdog_info imx_sc_wdt_info = {\n\t.identity\t= \"i.MX SC watchdog timer\",\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\nstatic int imx_sc_wdt_probe(struct platform_device *pdev)\n{\n\tstruct imx_sc_wdt_device *imx_sc_wdd;\n\tstruct watchdog_device *wdog;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\timx_sc_wdd = devm_kzalloc(dev, sizeof(*imx_sc_wdd), GFP_KERNEL);\n\tif (!imx_sc_wdd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, imx_sc_wdd);\n\n\twdog = &imx_sc_wdd->wdd;\n\twdog->info = &imx_sc_wdt_info;\n\twdog->ops = &imx_sc_wdt_ops;\n\twdog->min_timeout = 1;\n\twdog->max_timeout = MAX_TIMEOUT;\n\twdog->parent = dev;\n\twdog->timeout = DEFAULT_TIMEOUT;\n\n\twatchdog_init_timeout(wdog, 0, dev);\n\n\tret = imx_sc_wdt_set_timeout(wdog, wdog->timeout);\n\tif (ret)\n\t\treturn ret;\n\n\twatchdog_stop_on_reboot(wdog);\n\twatchdog_stop_on_unregister(wdog);\n\n\tret = imx_scu_irq_group_enable(SC_IRQ_GROUP_WDOG,\n\t\t\t\t       SC_IRQ_WDOG,\n\t\t\t\t       true);\n\tif (ret) {\n\t\tdev_warn(dev, \"Enable irq failed, pretimeout NOT supported\\n\");\n\t\tgoto register_device;\n\t}\n\n\timx_sc_wdd->wdt_notifier.notifier_call = imx_sc_wdt_notify;\n\tret = imx_scu_irq_register_notifier(&imx_sc_wdd->wdt_notifier);\n\tif (ret) {\n\t\timx_scu_irq_group_enable(SC_IRQ_GROUP_WDOG,\n\t\t\t\t\t SC_IRQ_WDOG,\n\t\t\t\t\t false);\n\t\tdev_warn(dev,\n\t\t\t \"Register irq notifier failed, pretimeout NOT supported\\n\");\n\t\tgoto register_device;\n\t}\n\n\tret = devm_add_action_or_reset(dev, imx_sc_wdt_action,\n\t\t\t\t       &imx_sc_wdd->wdt_notifier);\n\tif (!ret)\n\t\timx_sc_wdt_info.options |= WDIOF_PRETIMEOUT;\n\telse\n\t\tdev_warn(dev, \"Add action failed, pretimeout NOT supported\\n\");\n\nregister_device:\n\treturn devm_watchdog_register_device(dev, wdog);\n}\n\nstatic int __maybe_unused imx_sc_wdt_suspend(struct device *dev)\n{\n\tstruct imx_sc_wdt_device *imx_sc_wdd = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&imx_sc_wdd->wdd))\n\t\timx_sc_wdt_stop(&imx_sc_wdd->wdd);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_sc_wdt_resume(struct device *dev)\n{\n\tstruct imx_sc_wdt_device *imx_sc_wdd = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&imx_sc_wdd->wdd))\n\t\timx_sc_wdt_start(&imx_sc_wdd->wdd);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(imx_sc_wdt_pm_ops,\n\t\t\t imx_sc_wdt_suspend, imx_sc_wdt_resume);\n\nstatic const struct of_device_id imx_sc_wdt_dt_ids[] = {\n\t{ .compatible = \"fsl,imx-sc-wdt\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_sc_wdt_dt_ids);\n\nstatic struct platform_driver imx_sc_wdt_driver = {\n\t.probe\t\t= imx_sc_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"imx-sc-wdt\",\n\t\t.of_match_table = imx_sc_wdt_dt_ids,\n\t\t.pm\t= &imx_sc_wdt_pm_ops,\n\t},\n};\nmodule_platform_driver(imx_sc_wdt_driver);\n\nMODULE_AUTHOR(\"Robin Gong <yibin.gong@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP i.MX system controller watchdog driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}