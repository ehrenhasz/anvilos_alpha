{
  "module_name": "iTCO_wdt.c",
  "hash_id": "490e9a484531d9457a8feab0d7dd0963e8b119b9bae073a50230de5771dd80df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/iTCO_wdt.c",
  "human_readable_source": "\n \n\n \n\n \n#define DRV_NAME\t\"iTCO_wdt\"\n#define DRV_VERSION\t\"1.11\"\n\n \n#include <linux/acpi.h>\t\t\t \n#include <linux/bits.h>\t\t\t \n#include <linux/module.h>\t\t \n#include <linux/moduleparam.h>\t\t \n#include <linux/types.h>\t\t \n#include <linux/errno.h>\t\t \n#include <linux/kernel.h>\t\t \n#include <linux/watchdog.h>\t\t \n#include <linux/init.h>\t\t\t \n#include <linux/fs.h>\t\t\t \n#include <linux/platform_device.h>\t \n#include <linux/pci.h>\t\t\t \n#include <linux/ioport.h>\t\t \n#include <linux/spinlock.h>\t\t \n#include <linux/uaccess.h>\t\t \n#include <linux/io.h>\t\t\t \n#include <linux/platform_data/itco_wdt.h>\n#include <linux/mfd/intel_pmc_bxt.h>\n\n#include \"iTCO_vendor.h\"\n\n \n \n#define TCOBASE(p)\t((p)->tco_res->start)\n \n#define SMI_EN(p)\t((p)->smi_res->start)\n\n#define TCO_RLD(p)\t(TCOBASE(p) + 0x00)  \n#define TCOv1_TMR(p)\t(TCOBASE(p) + 0x01)  \n#define TCO_DAT_IN(p)\t(TCOBASE(p) + 0x02)  \n#define TCO_DAT_OUT(p)\t(TCOBASE(p) + 0x03)  \n#define TCO1_STS(p)\t(TCOBASE(p) + 0x04)  \n#define TCO2_STS(p)\t(TCOBASE(p) + 0x06)  \n#define TCO1_CNT(p)\t(TCOBASE(p) + 0x08)  \n#define TCO2_CNT(p)\t(TCOBASE(p) + 0x0a)  \n#define TCOv2_TMR(p)\t(TCOBASE(p) + 0x12)  \n\n \nstruct iTCO_wdt_private {\n\tstruct watchdog_device wddev;\n\n\t \n\tunsigned int iTCO_version;\n\tstruct resource *tco_res;\n\tstruct resource *smi_res;\n\t \n\tunsigned long __iomem *gcs_pmc;\n\t \n\tspinlock_t io_lock;\n\t \n\tstruct pci_dev *pci_dev;\n\t \n\tbool suspended;\n\t \n\tvoid *no_reboot_priv;\n\t \n\tint (*update_no_reboot_bit)(void *p, bool set);\n};\n\n \n#define WATCHDOG_TIMEOUT 30\t \nstatic int heartbeat = WATCHDOG_TIMEOUT;   \nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog timeout in seconds. \"\n\t\"5..76 (TCO v1) or 3..614 (TCO v2), default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int turn_SMI_watchdog_clear_off = 1;\nmodule_param(turn_SMI_watchdog_clear_off, int, 0);\nMODULE_PARM_DESC(turn_SMI_watchdog_clear_off,\n\t\"Turn off SMI clearing watchdog (depends on TCO-version)(default=1)\");\n\n \n\n \nstatic inline unsigned int seconds_to_ticks(struct iTCO_wdt_private *p,\n\t\t\t\t\t    int secs)\n{\n\treturn p->iTCO_version == 3 ? secs : (secs * 10) / 6;\n}\n\nstatic inline unsigned int ticks_to_seconds(struct iTCO_wdt_private *p,\n\t\t\t\t\t    int ticks)\n{\n\treturn p->iTCO_version == 3 ? ticks : (ticks * 6) / 10;\n}\n\nstatic inline u32 no_reboot_bit(struct iTCO_wdt_private *p)\n{\n\tu32 enable_bit;\n\n\tswitch (p->iTCO_version) {\n\tcase 5:\n\tcase 3:\n\t\tenable_bit = 0x00000010;\n\t\tbreak;\n\tcase 2:\n\t\tenable_bit = 0x00000020;\n\t\tbreak;\n\tcase 4:\n\tcase 1:\n\tdefault:\n\t\tenable_bit = 0x00000002;\n\t\tbreak;\n\t}\n\n\treturn enable_bit;\n}\n\nstatic int update_no_reboot_bit_def(void *priv, bool set)\n{\n\treturn 0;\n}\n\nstatic int update_no_reboot_bit_pci(void *priv, bool set)\n{\n\tstruct iTCO_wdt_private *p = priv;\n\tu32 val32 = 0, newval32 = 0;\n\n\tpci_read_config_dword(p->pci_dev, 0xd4, &val32);\n\tif (set)\n\t\tval32 |= no_reboot_bit(p);\n\telse\n\t\tval32 &= ~no_reboot_bit(p);\n\tpci_write_config_dword(p->pci_dev, 0xd4, val32);\n\tpci_read_config_dword(p->pci_dev, 0xd4, &newval32);\n\n\t \n\tif (val32 != newval32)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int update_no_reboot_bit_mem(void *priv, bool set)\n{\n\tstruct iTCO_wdt_private *p = priv;\n\tu32 val32 = 0, newval32 = 0;\n\n\tval32 = readl(p->gcs_pmc);\n\tif (set)\n\t\tval32 |= no_reboot_bit(p);\n\telse\n\t\tval32 &= ~no_reboot_bit(p);\n\twritel(val32, p->gcs_pmc);\n\tnewval32 = readl(p->gcs_pmc);\n\n\t \n\tif (val32 != newval32)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int update_no_reboot_bit_cnt(void *priv, bool set)\n{\n\tstruct iTCO_wdt_private *p = priv;\n\tu16 val, newval;\n\n\tval = inw(TCO1_CNT(p));\n\tif (set)\n\t\tval |= BIT(0);\n\telse\n\t\tval &= ~BIT(0);\n\toutw(val, TCO1_CNT(p));\n\tnewval = inw(TCO1_CNT(p));\n\n\t \n\treturn val != newval ? -EIO : 0;\n}\n\nstatic int update_no_reboot_bit_pmc(void *priv, bool set)\n{\n\tstruct intel_pmc_dev *pmc = priv;\n\tu32 bits = PMC_CFG_NO_REBOOT_EN;\n\tu32 value = set ? bits : 0;\n\n\treturn intel_pmc_gcr_update(pmc, PMC_GCR_PMC_CFG_REG, bits, value);\n}\n\nstatic void iTCO_wdt_no_reboot_bit_setup(struct iTCO_wdt_private *p,\n\t\t\t\t\t struct platform_device *pdev,\n\t\t\t\t\t struct itco_wdt_platform_data *pdata)\n{\n\tif (pdata->no_reboot_use_pmc) {\n\t\tstruct intel_pmc_dev *pmc = dev_get_drvdata(pdev->dev.parent);\n\n\t\tp->update_no_reboot_bit = update_no_reboot_bit_pmc;\n\t\tp->no_reboot_priv = pmc;\n\t\treturn;\n\t}\n\n\tif (p->iTCO_version >= 6)\n\t\tp->update_no_reboot_bit = update_no_reboot_bit_cnt;\n\telse if (p->iTCO_version >= 2)\n\t\tp->update_no_reboot_bit = update_no_reboot_bit_mem;\n\telse if (p->iTCO_version == 1)\n\t\tp->update_no_reboot_bit = update_no_reboot_bit_pci;\n\telse\n\t\tp->update_no_reboot_bit = update_no_reboot_bit_def;\n\n\tp->no_reboot_priv = p;\n}\n\nstatic int iTCO_wdt_start(struct watchdog_device *wd_dev)\n{\n\tstruct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);\n\tunsigned int val;\n\n\tspin_lock(&p->io_lock);\n\n\tiTCO_vendor_pre_start(p->smi_res, wd_dev->timeout);\n\n\t \n\tif (p->update_no_reboot_bit(p->no_reboot_priv, false)) {\n\t\tspin_unlock(&p->io_lock);\n\t\tdev_err(wd_dev->parent, \"failed to reset NO_REBOOT flag, reboot disabled by hardware/BIOS\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (p->iTCO_version >= 2)\n\t\toutw(0x01, TCO_RLD(p));\n\telse if (p->iTCO_version == 1)\n\t\toutb(0x01, TCO_RLD(p));\n\n\t \n\tval = inw(TCO1_CNT(p));\n\tval &= 0xf7ff;\n\toutw(val, TCO1_CNT(p));\n\tval = inw(TCO1_CNT(p));\n\tspin_unlock(&p->io_lock);\n\n\tif (val & 0x0800)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int iTCO_wdt_stop(struct watchdog_device *wd_dev)\n{\n\tstruct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);\n\tunsigned int val;\n\n\tspin_lock(&p->io_lock);\n\n\tiTCO_vendor_pre_stop(p->smi_res);\n\n\t \n\tval = inw(TCO1_CNT(p));\n\tval |= 0x0800;\n\toutw(val, TCO1_CNT(p));\n\tval = inw(TCO1_CNT(p));\n\n\t \n\tp->update_no_reboot_bit(p->no_reboot_priv, true);\n\n\tspin_unlock(&p->io_lock);\n\n\tif ((val & 0x0800) == 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int iTCO_wdt_ping(struct watchdog_device *wd_dev)\n{\n\tstruct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);\n\n\tspin_lock(&p->io_lock);\n\n\t \n\tif (p->iTCO_version >= 2) {\n\t\toutw(0x01, TCO_RLD(p));\n\t} else if (p->iTCO_version == 1) {\n\t\t \n\t\toutw(0x0008, TCO1_STS(p));\t \n\n\t\toutb(0x01, TCO_RLD(p));\n\t}\n\n\tspin_unlock(&p->io_lock);\n\treturn 0;\n}\n\nstatic int iTCO_wdt_set_timeout(struct watchdog_device *wd_dev, unsigned int t)\n{\n\tstruct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);\n\tunsigned int val16;\n\tunsigned char val8;\n\tunsigned int tmrval;\n\n\ttmrval = seconds_to_ticks(p, t);\n\n\t \n\tif (p->iTCO_version == 1)\n\t\ttmrval /= 2;\n\n\t \n\t \n\tif (tmrval < 0x04)\n\t\treturn -EINVAL;\n\tif ((p->iTCO_version >= 2 && tmrval > 0x3ff) ||\n\t    (p->iTCO_version == 1 && tmrval > 0x03f))\n\t\treturn -EINVAL;\n\n\t \n\tif (p->iTCO_version >= 2) {\n\t\tspin_lock(&p->io_lock);\n\t\tval16 = inw(TCOv2_TMR(p));\n\t\tval16 &= 0xfc00;\n\t\tval16 |= tmrval;\n\t\toutw(val16, TCOv2_TMR(p));\n\t\tval16 = inw(TCOv2_TMR(p));\n\t\tspin_unlock(&p->io_lock);\n\n\t\tif ((val16 & 0x3ff) != tmrval)\n\t\t\treturn -EINVAL;\n\t} else if (p->iTCO_version == 1) {\n\t\tspin_lock(&p->io_lock);\n\t\tval8 = inb(TCOv1_TMR(p));\n\t\tval8 &= 0xc0;\n\t\tval8 |= (tmrval & 0xff);\n\t\toutb(val8, TCOv1_TMR(p));\n\t\tval8 = inb(TCOv1_TMR(p));\n\t\tspin_unlock(&p->io_lock);\n\n\t\tif ((val8 & 0x3f) != tmrval)\n\t\t\treturn -EINVAL;\n\t}\n\n\twd_dev->timeout = t;\n\treturn 0;\n}\n\nstatic unsigned int iTCO_wdt_get_timeleft(struct watchdog_device *wd_dev)\n{\n\tstruct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);\n\tunsigned int val16;\n\tunsigned char val8;\n\tunsigned int time_left = 0;\n\n\t \n\tif (p->iTCO_version >= 2) {\n\t\tspin_lock(&p->io_lock);\n\t\tval16 = inw(TCO_RLD(p));\n\t\tval16 &= 0x3ff;\n\t\tspin_unlock(&p->io_lock);\n\n\t\ttime_left = ticks_to_seconds(p, val16);\n\t} else if (p->iTCO_version == 1) {\n\t\tspin_lock(&p->io_lock);\n\t\tval8 = inb(TCO_RLD(p));\n\t\tval8 &= 0x3f;\n\t\tif (!(inw(TCO1_STS(p)) & 0x0008))\n\t\t\tval8 += (inb(TCOv1_TMR(p)) & 0x3f);\n\t\tspin_unlock(&p->io_lock);\n\n\t\ttime_left = ticks_to_seconds(p, val8);\n\t}\n\treturn time_left;\n}\n\n \nstatic bool iTCO_wdt_set_running(struct iTCO_wdt_private *p)\n{\n\tu16 val;\n\n\t \n\tval = inw(TCO1_CNT(p));\n\tif (!(val & BIT(11))) {\n\t\tset_bit(WDOG_HW_RUNNING, &p->wddev.status);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \n\nstatic struct watchdog_info ident = {\n\t.options =\t\tWDIOF_SETTIMEOUT |\n\t\t\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\tWDIOF_MAGICCLOSE,\n\t.identity =\t\tDRV_NAME,\n};\n\nstatic const struct watchdog_ops iTCO_wdt_ops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.start =\t\tiTCO_wdt_start,\n\t.stop =\t\t\tiTCO_wdt_stop,\n\t.ping =\t\t\tiTCO_wdt_ping,\n\t.set_timeout =\t\tiTCO_wdt_set_timeout,\n\t.get_timeleft =\t\tiTCO_wdt_get_timeleft,\n};\n\n \n\nstatic int iTCO_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct itco_wdt_platform_data *pdata = dev_get_platdata(dev);\n\tstruct iTCO_wdt_private *p;\n\tunsigned long val32;\n\tint ret;\n\n\tif (!pdata)\n\t\treturn -ENODEV;\n\n\tp = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&p->io_lock);\n\n\tp->tco_res = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_IO_TCO);\n\tif (!p->tco_res)\n\t\treturn -ENODEV;\n\n\tp->iTCO_version = pdata->version;\n\tp->pci_dev = to_pci_dev(dev->parent);\n\n\tp->smi_res = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_IO_SMI);\n\tif (p->smi_res) {\n\t\t \n\t\tif (!devm_request_region(dev, p->smi_res->start,\n\t\t\t\t\t resource_size(p->smi_res),\n\t\t\t\t\t pdev->name)) {\n\t\t\tdev_err(dev, \"I/O address 0x%04llx already in use, device disabled\\n\",\n\t\t\t       (u64)SMI_EN(p));\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else if (iTCO_vendorsupport ||\n\t\t   turn_SMI_watchdog_clear_off >= p->iTCO_version) {\n\t\tdev_err(dev, \"SMI I/O resource is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tiTCO_wdt_no_reboot_bit_setup(p, pdev, pdata);\n\n\t \n\tif (p->iTCO_version >= 2 && p->iTCO_version < 6 &&\n\t    !pdata->no_reboot_use_pmc) {\n\t\tp->gcs_pmc = devm_platform_ioremap_resource(pdev, ICH_RES_MEM_GCS_PMC);\n\t\tif (IS_ERR(p->gcs_pmc))\n\t\t\treturn PTR_ERR(p->gcs_pmc);\n\t}\n\n\t \n\tif (p->update_no_reboot_bit(p->no_reboot_priv, false) &&\n\t    iTCO_vendor_check_noreboot_on()) {\n\t\tdev_info(dev, \"unable to reset NO_REBOOT flag, device disabled by hardware/BIOS\\n\");\n\t\treturn -ENODEV;\t \n\t}\n\n\tif (turn_SMI_watchdog_clear_off >= p->iTCO_version) {\n\t\t \n\t\tval32 = inl(SMI_EN(p));\n\t\tval32 &= 0xffffdfff;\t \n\t\toutl(val32, SMI_EN(p));\n\t}\n\n\tif (!devm_request_region(dev, p->tco_res->start,\n\t\t\t\t resource_size(p->tco_res),\n\t\t\t\t pdev->name)) {\n\t\tdev_err(dev, \"I/O address 0x%04llx already in use, device disabled\\n\",\n\t\t       (u64)TCOBASE(p));\n\t\treturn -EBUSY;\n\t}\n\n\tdev_info(dev, \"Found a %s TCO device (Version=%d, TCOBASE=0x%04llx)\\n\",\n\t\tpdata->name, pdata->version, (u64)TCOBASE(p));\n\n\t \n\tswitch (p->iTCO_version) {\n\tcase 6:\n\tcase 5:\n\tcase 4:\n\t\toutw(0x0008, TCO1_STS(p));  \n\t\toutw(0x0002, TCO2_STS(p));  \n\t\tbreak;\n\tcase 3:\n\t\toutl(0x20008, TCO1_STS(p));\n\t\tbreak;\n\tcase 2:\n\tcase 1:\n\tdefault:\n\t\toutw(0x0008, TCO1_STS(p));  \n\t\toutw(0x0002, TCO2_STS(p));  \n\t\toutw(0x0004, TCO2_STS(p));  \n\t\tbreak;\n\t}\n\n\tident.firmware_version = p->iTCO_version;\n\tp->wddev.info = &ident,\n\tp->wddev.ops = &iTCO_wdt_ops,\n\tp->wddev.bootstatus = 0;\n\tp->wddev.timeout = WATCHDOG_TIMEOUT;\n\twatchdog_set_nowayout(&p->wddev, nowayout);\n\tp->wddev.parent = dev;\n\n\twatchdog_set_drvdata(&p->wddev, p);\n\tplatform_set_drvdata(pdev, p);\n\n\tif (!iTCO_wdt_set_running(p)) {\n\t\t \n\t\tp->update_no_reboot_bit(p->no_reboot_priv, true);\n\t}\n\n\t \n\tif (iTCO_wdt_set_timeout(&p->wddev, heartbeat)) {\n\t\tiTCO_wdt_set_timeout(&p->wddev, WATCHDOG_TIMEOUT);\n\t\tdev_info(dev, \"timeout value out of range, using %d\\n\",\n\t\t\tWATCHDOG_TIMEOUT);\n\t}\n\n\twatchdog_stop_on_reboot(&p->wddev);\n\twatchdog_stop_on_unregister(&p->wddev);\n\tret = devm_watchdog_register_device(dev, &p->wddev);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"cannot register watchdog device (err=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"initialized. heartbeat=%d sec (nowayout=%d)\\n\",\n\t\theartbeat, nowayout);\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_ACPI\nstatic inline bool __maybe_unused need_suspend(void)\n{\n\treturn acpi_target_system_state() == ACPI_STATE_S0;\n}\n#else\nstatic inline bool __maybe_unused need_suspend(void) { return true; }\n#endif\n\nstatic int __maybe_unused iTCO_wdt_suspend_noirq(struct device *dev)\n{\n\tstruct iTCO_wdt_private *p = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tp->suspended = false;\n\tif (watchdog_active(&p->wddev) && need_suspend()) {\n\t\tret = iTCO_wdt_stop(&p->wddev);\n\t\tif (!ret)\n\t\t\tp->suspended = true;\n\t}\n\treturn ret;\n}\n\nstatic int __maybe_unused iTCO_wdt_resume_noirq(struct device *dev)\n{\n\tstruct iTCO_wdt_private *p = dev_get_drvdata(dev);\n\n\tif (p->suspended)\n\t\tiTCO_wdt_start(&p->wddev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops iTCO_wdt_pm = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(iTCO_wdt_suspend_noirq,\n\t\t\t\t      iTCO_wdt_resume_noirq)\n};\n\nstatic struct platform_driver iTCO_wdt_driver = {\n\t.probe          = iTCO_wdt_probe,\n\t.driver         = {\n\t\t.name   = DRV_NAME,\n\t\t.pm     = &iTCO_wdt_pm,\n\t},\n};\n\nmodule_platform_driver(iTCO_wdt_driver);\n\nMODULE_AUTHOR(\"Wim Van Sebroeck <wim@iguana.be>\");\nMODULE_DESCRIPTION(\"Intel TCO WatchDog Timer Driver\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}