{
  "module_name": "sc1200wdt.c",
  "hash_id": "073c6973dd00c13789090b23ca541704b2bc8ff8dac97d64d32c0cfd58b57b1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sc1200wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/ioport.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/pnp.h>\n#include <linux/fs.h>\n#include <linux/semaphore.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#define SC1200_MODULE_VER\t\"build 20020303\"\n#define SC1200_MODULE_NAME\t\"sc1200wdt\"\n\n#define\tMAX_TIMEOUT\t255\t \n#define PMIR\t\t(io)\t \n#define PMDR\t\t(io+1)\t \n\n \n#define FER1\t\t0x00\t \n#define FER2\t\t0x01\t \n#define PMC1\t\t0x02\t \n#define PMC2\t\t0x03\t \n#define PMC3\t\t0x04\t \n#define WDTO\t\t0x05\t \n#define\tWDCF\t\t0x06\t \n#define WDST\t\t0x07\t \n\n \n#define KBC_IRQ\t\t0x01\t \n#define MSE_IRQ\t\t0x02\t \n#define UART1_IRQ\t0x03\t \n#define UART2_IRQ\t0x04\t \n \n\nstatic int timeout = 1;\nstatic int io = -1;\nstatic int io_len = 2;\t\t \nstatic unsigned long open_flag;\nstatic char expect_close;\nstatic DEFINE_SPINLOCK(sc1200wdt_lock);\t \n\n#if defined CONFIG_PNP\nstatic int isapnp = 1;\nstatic struct pnp_dev *wdt_dev;\n\nmodule_param(isapnp, int, 0);\nMODULE_PARM_DESC(isapnp,\n\t\"When set to 0 driver ISA PnP support will be disabled\");\n#endif\n\nmodule_param_hw(io, int, ioport, 0);\nMODULE_PARM_DESC(io, \"io port\");\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"range is 0-255 minutes, default is 1\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n\n\n \nstatic inline void __sc1200wdt_read_data(unsigned char index,\n\t\t\t\t\t\tunsigned char *data)\n{\n\toutb_p(index, PMIR);\n\t*data = inb(PMDR);\n}\n\nstatic void sc1200wdt_read_data(unsigned char index, unsigned char *data)\n{\n\tspin_lock(&sc1200wdt_lock);\n\t__sc1200wdt_read_data(index, data);\n\tspin_unlock(&sc1200wdt_lock);\n}\n\n \nstatic inline void __sc1200wdt_write_data(unsigned char index,\n\t\t\t\t\t\tunsigned char data)\n{\n\toutb_p(index, PMIR);\n\toutb(data, PMDR);\n}\n\nstatic inline void sc1200wdt_write_data(unsigned char index,\n\t\t\t\t\t\tunsigned char data)\n{\n\tspin_lock(&sc1200wdt_lock);\n\t__sc1200wdt_write_data(index, data);\n\tspin_unlock(&sc1200wdt_lock);\n}\n\n\nstatic void sc1200wdt_start(void)\n{\n\tunsigned char reg;\n\tspin_lock(&sc1200wdt_lock);\n\n\t__sc1200wdt_read_data(WDCF, &reg);\n\t \n\treg |= (KBC_IRQ | MSE_IRQ | UART1_IRQ | UART2_IRQ);\n\t__sc1200wdt_write_data(WDCF, reg);\n\t \n\t__sc1200wdt_write_data(WDTO, timeout);\n\n\tspin_unlock(&sc1200wdt_lock);\n}\n\nstatic void sc1200wdt_stop(void)\n{\n\tsc1200wdt_write_data(WDTO, 0);\n}\n\n \nstatic inline int sc1200wdt_status(void)\n{\n\tunsigned char ret;\n\n\tsc1200wdt_read_data(WDST, &ret);\n\t \n\treturn (ret & 0x01) ? 0 : WDIOF_KEEPALIVEPING;\n}\n\nstatic int sc1200wdt_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &open_flag))\n\t\treturn -EBUSY;\n\n\tif (timeout > MAX_TIMEOUT)\n\t\ttimeout = MAX_TIMEOUT;\n\n\tsc1200wdt_start();\n\tpr_info(\"Watchdog enabled, timeout = %d min(s)\", timeout);\n\n\treturn stream_open(inode, file);\n}\n\n\nstatic long sc1200wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\tunsigned long arg)\n{\n\tint new_timeout;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\n\t\t\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.firmware_version = 0,\n\t\t.identity = \"PC87307/PC97307\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase WDIOC_GETSTATUS:\n\t\treturn put_user(sc1200wdt_status(), p);\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint options, retval = -EINVAL;\n\n\t\tif (get_user(options, p))\n\t\t\treturn -EFAULT;\n\n\t\tif (options & WDIOS_DISABLECARD) {\n\t\t\tsc1200wdt_stop();\n\t\t\tretval = 0;\n\t\t}\n\n\t\tif (options & WDIOS_ENABLECARD) {\n\t\t\tsc1200wdt_start();\n\t\t\tretval = 0;\n\t\t}\n\n\t\treturn retval;\n\t}\n\tcase WDIOC_KEEPALIVE:\n\t\tsc1200wdt_write_data(WDTO, timeout);\n\t\treturn 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_timeout, p))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tnew_timeout /= 60;\n\t\tif (new_timeout < 0 || new_timeout > MAX_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\ttimeout = new_timeout;\n\t\tsc1200wdt_write_data(WDTO, timeout);\n\t\tfallthrough;\t \n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(timeout * 60, p);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n\nstatic int sc1200wdt_release(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42) {\n\t\tsc1200wdt_stop();\n\t\tpr_info(\"Watchdog disabled\\n\");\n\t} else {\n\t\tsc1200wdt_write_data(WDTO, timeout);\n\t\tpr_crit(\"Unexpected close!, timeout = %d min(s)\\n\", timeout);\n\t}\n\tclear_bit(0, &open_flag);\n\texpect_close = 0;\n\n\treturn 0;\n}\n\n\nstatic ssize_t sc1200wdt_write(struct file *file, const char __user *data,\n\t\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\texpect_close = 0;\n\n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\n\t\tsc1200wdt_write_data(WDTO, timeout);\n\t\treturn len;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int sc1200wdt_notify_sys(struct notifier_block *this,\n\t\t\t\t\tunsigned long code, void *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\tsc1200wdt_stop();\n\n\treturn NOTIFY_DONE;\n}\n\n\nstatic struct notifier_block sc1200wdt_notifier = {\n\t.notifier_call =\tsc1200wdt_notify_sys,\n};\n\nstatic const struct file_operations sc1200wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= sc1200wdt_write,\n\t.unlocked_ioctl = sc1200wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= sc1200wdt_open,\n\t.release\t= sc1200wdt_release,\n};\n\nstatic struct miscdevice sc1200wdt_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &sc1200wdt_fops,\n};\n\n\nstatic int __init sc1200wdt_probe(void)\n{\n\t \n\n\tunsigned char reg;\n\n\tsc1200wdt_read_data(PMC3, &reg);\n\treg &= 0x0f;\t\t \n\treturn (reg == 0x0e) ? 0 : -ENODEV;\n}\n\n\n#if defined CONFIG_PNP\n\nstatic const struct pnp_device_id scl200wdt_pnp_devices[] = {\n\t \n\t{.id = \"NSC0800\", .driver_data = 0},\n\t{.id = \"\"},\n};\n\nstatic int scl200wdt_pnp_probe(struct pnp_dev *dev,\n\t\t\t\t\tconst struct pnp_device_id *dev_id)\n{\n\t \n\tif (wdt_dev || !isapnp)\n\t\treturn -EBUSY;\n\n\twdt_dev = dev;\n\tio = pnp_port_start(wdt_dev, 0);\n\tio_len = pnp_port_len(wdt_dev, 0);\n\n\tif (!request_region(io, io_len, SC1200_MODULE_NAME)) {\n\t\tpr_err(\"Unable to register IO port %#x\\n\", io);\n\t\treturn -EBUSY;\n\t}\n\n\tpr_info(\"PnP device found at io port %#x/%d\\n\", io, io_len);\n\treturn 0;\n}\n\nstatic void scl200wdt_pnp_remove(struct pnp_dev *dev)\n{\n\tif (wdt_dev) {\n\t\trelease_region(io, io_len);\n\t\twdt_dev = NULL;\n\t}\n}\n\nstatic struct pnp_driver scl200wdt_pnp_driver = {\n\t.name\t\t= \"scl200wdt\",\n\t.id_table\t= scl200wdt_pnp_devices,\n\t.probe\t\t= scl200wdt_pnp_probe,\n\t.remove\t\t= scl200wdt_pnp_remove,\n};\n\n#endif  \n\n\nstatic int __init sc1200wdt_init(void)\n{\n\tint ret;\n\n\tpr_info(\"%s\\n\", SC1200_MODULE_VER);\n\n#if defined CONFIG_PNP\n\tif (isapnp) {\n\t\tret = pnp_register_driver(&scl200wdt_pnp_driver);\n\t\tif (ret)\n\t\t\tgoto out_clean;\n\t}\n#endif\n\n\tif (io == -1) {\n\t\tpr_err(\"io parameter must be specified\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_pnp;\n\t}\n\n#if defined CONFIG_PNP\n\t \n\tif (isapnp)\n\t\tpnp_unregister_driver(&scl200wdt_pnp_driver);\n\tisapnp = 0;\n#endif\n\n\tif (!request_region(io, io_len, SC1200_MODULE_NAME)) {\n\t\tpr_err(\"Unable to register IO port %#x\\n\", io);\n\t\tret = -EBUSY;\n\t\tgoto out_pnp;\n\t}\n\n\tret = sc1200wdt_probe();\n\tif (ret)\n\t\tgoto out_io;\n\n\tret = register_reboot_notifier(&sc1200wdt_notifier);\n\tif (ret) {\n\t\tpr_err(\"Unable to register reboot notifier err = %d\\n\", ret);\n\t\tgoto out_io;\n\t}\n\n\tret = misc_register(&sc1200wdt_miscdev);\n\tif (ret) {\n\t\tpr_err(\"Unable to register miscdev on minor %d\\n\",\n\t\t       WATCHDOG_MINOR);\n\t\tgoto out_rbt;\n\t}\n\n\t \n\nout_clean:\n\treturn ret;\n\nout_rbt:\n\tunregister_reboot_notifier(&sc1200wdt_notifier);\n\nout_io:\n\trelease_region(io, io_len);\n\nout_pnp:\n#if defined CONFIG_PNP\n\tif (isapnp)\n\t\tpnp_unregister_driver(&scl200wdt_pnp_driver);\n#endif\n\tgoto out_clean;\n}\n\n\nstatic void __exit sc1200wdt_exit(void)\n{\n\tmisc_deregister(&sc1200wdt_miscdev);\n\tunregister_reboot_notifier(&sc1200wdt_notifier);\n\n#if defined CONFIG_PNP\n\tif (isapnp)\n\t\tpnp_unregister_driver(&scl200wdt_pnp_driver);\n\telse\n#endif\n\trelease_region(io, io_len);\n}\n\nmodule_init(sc1200wdt_init);\nmodule_exit(sc1200wdt_exit);\n\nMODULE_AUTHOR(\"Zwane Mwaikambo <zwane@commfireservices.com>\");\nMODULE_DESCRIPTION(\n\t\"Driver for National Semiconductor PC87307/PC97307 watchdog component\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}