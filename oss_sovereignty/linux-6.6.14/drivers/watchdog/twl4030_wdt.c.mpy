{
  "module_name": "twl4030_wdt.c",
  "hash_id": "4cff56a5c4177feffbf3442abf0ee5f6edc50a132fdcc6b8315c148c5db09043",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/twl4030_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/twl.h>\n\n#define TWL4030_WATCHDOG_CFG_REG_OFFS\t0x3\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int twl4030_wdt_write(unsigned char val)\n{\n\treturn twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, val,\n\t\t\t\t\tTWL4030_WATCHDOG_CFG_REG_OFFS);\n}\n\nstatic int twl4030_wdt_start(struct watchdog_device *wdt)\n{\n\treturn twl4030_wdt_write(wdt->timeout + 1);\n}\n\nstatic int twl4030_wdt_stop(struct watchdog_device *wdt)\n{\n\treturn twl4030_wdt_write(0);\n}\n\nstatic int twl4030_wdt_set_timeout(struct watchdog_device *wdt,\n\t\t\t\t   unsigned int timeout)\n{\n\twdt->timeout = timeout;\n\treturn 0;\n}\n\nstatic const struct watchdog_info twl4030_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"TWL4030 Watchdog\",\n};\n\nstatic const struct watchdog_ops twl4030_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= twl4030_wdt_start,\n\t.stop\t\t= twl4030_wdt_stop,\n\t.set_timeout\t= twl4030_wdt_set_timeout,\n};\n\nstatic int twl4030_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdt;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->info\t\t= &twl4030_wdt_info;\n\twdt->ops\t\t= &twl4030_wdt_ops;\n\twdt->status\t\t= 0;\n\twdt->timeout\t\t= 30;\n\twdt->min_timeout\t= 1;\n\twdt->max_timeout\t= 30;\n\twdt->parent = dev;\n\n\twatchdog_set_nowayout(wdt, nowayout);\n\tplatform_set_drvdata(pdev, wdt);\n\n\ttwl4030_wdt_stop(wdt);\n\n\treturn devm_watchdog_register_device(dev, wdt);\n}\n\nstatic int twl4030_wdt_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct watchdog_device *wdt = platform_get_drvdata(pdev);\n\tif (watchdog_active(wdt))\n\t\treturn twl4030_wdt_stop(wdt);\n\n\treturn 0;\n}\n\nstatic int twl4030_wdt_resume(struct platform_device *pdev)\n{\n\tstruct watchdog_device *wdt = platform_get_drvdata(pdev);\n\tif (watchdog_active(wdt))\n\t\treturn twl4030_wdt_start(wdt);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id twl_wdt_of_match[] = {\n\t{ .compatible = \"ti,twl4030-wdt\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, twl_wdt_of_match);\n\nstatic struct platform_driver twl4030_wdt_driver = {\n\t.probe\t\t= twl4030_wdt_probe,\n\t.suspend\t= pm_ptr(twl4030_wdt_suspend),\n\t.resume\t\t= pm_ptr(twl4030_wdt_resume),\n\t.driver\t\t= {\n\t\t.name\t\t= \"twl4030_wdt\",\n\t\t.of_match_table\t= twl_wdt_of_match,\n\t},\n};\n\nmodule_platform_driver(twl4030_wdt_driver);\n\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:twl4030_wdt\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}