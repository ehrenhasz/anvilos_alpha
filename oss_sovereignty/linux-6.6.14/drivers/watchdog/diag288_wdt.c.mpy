{
  "module_name": "diag288_wdt.c",
  "hash_id": "7bdc81f06fd17e997735cb62c4f1f9dc2ef4ca9324b05e096f088c0661db5b8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/diag288_wdt.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"diag288_wdt\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/watchdog.h>\n#include <asm/ebcdic.h>\n#include <asm/diag.h>\n#include <linux/io.h>\n\n#define MAX_CMDLEN 240\n#define DEFAULT_CMD \"SYSTEM RESTART\"\n\n#define MIN_INTERVAL 15      \n#define MAX_INTERVAL 3600    \n\n#define WDT_DEFAULT_TIMEOUT 30\n\n \n#define WDT_FUNC_INIT 0\n#define WDT_FUNC_CHANGE 1\n#define WDT_FUNC_CANCEL 2\n#define WDT_FUNC_CONCEAL 0x80000000\n\n \n#define LPARWDT_RESTART 0\n\nstatic char wdt_cmd[MAX_CMDLEN] = DEFAULT_CMD;\nstatic bool conceal_on;\nstatic bool nowayout_info = WATCHDOG_NOWAYOUT;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arnd Bergmann <arndb@de.ibm.com>\");\nMODULE_AUTHOR(\"Philipp Hachtmann <phacht@de.ibm.com>\");\n\nMODULE_DESCRIPTION(\"System z diag288  Watchdog Timer\");\n\nmodule_param_string(cmd, wdt_cmd, MAX_CMDLEN, 0644);\nMODULE_PARM_DESC(cmd, \"CP command that is run when the watchdog triggers (z/VM only)\");\n\nmodule_param_named(conceal, conceal_on, bool, 0644);\nMODULE_PARM_DESC(conceal, \"Enable the CONCEAL CP option while the watchdog is active (z/VM only)\");\n\nmodule_param_named(nowayout, nowayout_info, bool, 0444);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default = CONFIG_WATCHDOG_NOWAYOUT)\");\n\nMODULE_ALIAS(\"vmwatchdog\");\n\nstatic char *cmd_buf;\n\nstatic int diag288(unsigned int func, unsigned int timeout,\n\t\t   unsigned long action, unsigned int len)\n{\n\tunion register_pair r1 = { .even = func, .odd = timeout, };\n\tunion register_pair r3 = { .even = action, .odd = len, };\n\tint err;\n\n\tdiag_stat_inc(DIAG_STAT_X288);\n\n\terr = -EINVAL;\n\tasm volatile(\n\t\t\"\tdiag\t%[r1],%[r3],0x288\\n\"\n\t\t\"0:\tla\t%[err],0\\n\"\n\t\t\"1:\\n\"\n\t\tEX_TABLE(0b, 1b)\n\t\t: [err] \"+d\" (err)\n\t\t: [r1] \"d\" (r1.pair), [r3] \"d\" (r3.pair)\n\t\t: \"cc\", \"memory\");\n\treturn err;\n}\n\nstatic int diag288_str(unsigned int func, unsigned int timeout, char *cmd)\n{\n\tssize_t len;\n\n\tlen = strscpy(cmd_buf, cmd, MAX_CMDLEN);\n\tif (len < 0)\n\t\treturn len;\n\tASCEBC(cmd_buf, MAX_CMDLEN);\n\tEBC_TOUPPER(cmd_buf, MAX_CMDLEN);\n\n\treturn diag288(func, timeout, virt_to_phys(cmd_buf), len);\n}\n\nstatic int wdt_start(struct watchdog_device *dev)\n{\n\tint ret;\n\tunsigned int func;\n\n\tif (MACHINE_IS_VM) {\n\t\tfunc = conceal_on ? (WDT_FUNC_INIT | WDT_FUNC_CONCEAL)\n\t\t\t: WDT_FUNC_INIT;\n\t\tret = diag288_str(func, dev->timeout, wdt_cmd);\n\t\tWARN_ON(ret != 0);\n\t} else {\n\t\tret = diag288(WDT_FUNC_INIT, dev->timeout, LPARWDT_RESTART, 0);\n\t}\n\n\tif (ret) {\n\t\tpr_err(\"The watchdog cannot be activated\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int wdt_stop(struct watchdog_device *dev)\n{\n\treturn diag288(WDT_FUNC_CANCEL, 0, 0, 0);\n}\n\nstatic int wdt_ping(struct watchdog_device *dev)\n{\n\tint ret;\n\tunsigned int func;\n\n\tif (MACHINE_IS_VM) {\n\t\t \n\t\tfunc = conceal_on ? (WDT_FUNC_INIT | WDT_FUNC_CONCEAL)\n\t\t\t: WDT_FUNC_INIT;\n\n\t\tret = diag288_str(func, dev->timeout, wdt_cmd);\n\t\tWARN_ON(ret != 0);\n\t} else {\n\t\tret = diag288(WDT_FUNC_CHANGE, dev->timeout, 0, 0);\n\t}\n\n\tif (ret)\n\t\tpr_err(\"The watchdog timer cannot be started or reset\\n\");\n\treturn ret;\n}\n\nstatic int wdt_set_timeout(struct watchdog_device * dev, unsigned int new_to)\n{\n\tdev->timeout = new_to;\n\treturn wdt_ping(dev);\n}\n\nstatic const struct watchdog_ops wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = wdt_start,\n\t.stop = wdt_stop,\n\t.ping = wdt_ping,\n\t.set_timeout = wdt_set_timeout,\n};\n\nstatic const struct watchdog_info wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.firmware_version = 0,\n\t.identity = \"z Watchdog\",\n};\n\nstatic struct watchdog_device wdt_dev = {\n\t.parent = NULL,\n\t.info = &wdt_info,\n\t.ops = &wdt_ops,\n\t.bootstatus = 0,\n\t.timeout = WDT_DEFAULT_TIMEOUT,\n\t.min_timeout = MIN_INTERVAL,\n\t.max_timeout = MAX_INTERVAL,\n};\n\nstatic int __init diag288_init(void)\n{\n\tint ret;\n\n\twatchdog_set_nowayout(&wdt_dev, nowayout_info);\n\n\tif (MACHINE_IS_VM) {\n\t\tcmd_buf = kmalloc(MAX_CMDLEN, GFP_KERNEL);\n\t\tif (!cmd_buf) {\n\t\t\tpr_err(\"The watchdog cannot be initialized\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = diag288_str(WDT_FUNC_INIT, MIN_INTERVAL, \"BEGIN\");\n\t\tif (ret != 0) {\n\t\t\tpr_err(\"The watchdog cannot be initialized\\n\");\n\t\t\tkfree(cmd_buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (diag288(WDT_FUNC_INIT, WDT_DEFAULT_TIMEOUT,\n\t\t\t    LPARWDT_RESTART, 0)) {\n\t\t\tpr_err(\"The watchdog cannot be initialized\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (diag288(WDT_FUNC_CANCEL, 0, 0, 0)) {\n\t\tpr_err(\"The watchdog cannot be deactivated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn watchdog_register_device(&wdt_dev);\n}\n\nstatic void __exit diag288_exit(void)\n{\n\twatchdog_unregister_device(&wdt_dev);\n\tkfree(cmd_buf);\n}\n\nmodule_init(diag288_init);\nmodule_exit(diag288_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}