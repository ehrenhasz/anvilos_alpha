{
  "module_name": "mena21_wdt.c",
  "hash_id": "977ed3e1c636381b8c362ed7fdc23fe5f6b4a8dd275b827da0f726056a57f3ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/mena21_wdt.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n#include <linux/uaccess.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/of.h>\n\n#define NUM_GPIOS 6\n\nenum a21_wdt_gpios {\n\tGPIO_WD_ENAB,\n\tGPIO_WD_FAST,\n\tGPIO_WD_TRIG,\n\tGPIO_WD_RST0,\n\tGPIO_WD_RST1,\n\tGPIO_WD_RST2,\n};\n\nstruct a21_wdt_drv {\n\tstruct watchdog_device wdt;\n\tstruct gpio_desc *gpios[NUM_GPIOS];\n};\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t    __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic unsigned int a21_wdt_get_bootstatus(struct a21_wdt_drv *drv)\n{\n\tint reset = 0;\n\n\treset |= gpiod_get_value(drv->gpios[GPIO_WD_RST0]) ? (1 << 0) : 0;\n\treset |= gpiod_get_value(drv->gpios[GPIO_WD_RST1]) ? (1 << 1) : 0;\n\treset |= gpiod_get_value(drv->gpios[GPIO_WD_RST2]) ? (1 << 2) : 0;\n\n\treturn reset;\n}\n\nstatic int a21_wdt_start(struct watchdog_device *wdt)\n{\n\tstruct a21_wdt_drv *drv = watchdog_get_drvdata(wdt);\n\n\tgpiod_set_value(drv->gpios[GPIO_WD_ENAB], 1);\n\n\treturn 0;\n}\n\nstatic int a21_wdt_stop(struct watchdog_device *wdt)\n{\n\tstruct a21_wdt_drv *drv = watchdog_get_drvdata(wdt);\n\n\tgpiod_set_value(drv->gpios[GPIO_WD_ENAB], 0);\n\n\treturn 0;\n}\n\nstatic int a21_wdt_ping(struct watchdog_device *wdt)\n{\n\tstruct a21_wdt_drv *drv = watchdog_get_drvdata(wdt);\n\n\tgpiod_set_value(drv->gpios[GPIO_WD_TRIG], 0);\n\tndelay(10);\n\tgpiod_set_value(drv->gpios[GPIO_WD_TRIG], 1);\n\n\treturn 0;\n}\n\nstatic int a21_wdt_set_timeout(struct watchdog_device *wdt,\n\t\t\t       unsigned int timeout)\n{\n\tstruct a21_wdt_drv *drv = watchdog_get_drvdata(wdt);\n\n\tif (timeout != 1 && timeout != 30) {\n\t\tdev_err(wdt->parent, \"Only 1 and 30 allowed as timeout\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (timeout == 30 && wdt->timeout == 1) {\n\t\tdev_err(wdt->parent,\n\t\t\t\"Transition from fast to slow mode not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (timeout == 1)\n\t\tgpiod_set_value(drv->gpios[GPIO_WD_FAST], 1);\n\telse\n\t\tgpiod_set_value(drv->gpios[GPIO_WD_FAST], 0);\n\n\twdt->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info a21_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"MEN A21 Watchdog\",\n};\n\nstatic const struct watchdog_ops a21_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = a21_wdt_start,\n\t.stop = a21_wdt_stop,\n\t.ping = a21_wdt_ping,\n\t.set_timeout = a21_wdt_set_timeout,\n};\n\nstatic struct watchdog_device a21_wdt = {\n\t.info = &a21_wdt_info,\n\t.ops = &a21_wdt_ops,\n\t.min_timeout = 1,\n\t.max_timeout = 30,\n};\n\nstatic int a21_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct a21_wdt_drv *drv;\n\tunsigned int reset = 0;\n\tint num_gpios;\n\tint ret;\n\tint i;\n\n\tdrv = devm_kzalloc(dev, sizeof(struct a21_wdt_drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tnum_gpios = gpiod_count(dev, NULL);\n\tif (num_gpios != NUM_GPIOS) {\n\t\tdev_err(dev, \"gpios DT property wrong, got %d want %d\",\n\t\t\tnum_gpios, NUM_GPIOS);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < num_gpios; i++) {\n\t\tenum gpiod_flags gflags;\n\n\t\tif (i < GPIO_WD_RST0)\n\t\t\tgflags = GPIOD_ASIS;\n\t\telse\n\t\t\tgflags = GPIOD_IN;\n\t\tdrv->gpios[i] = devm_gpiod_get_index(dev, NULL, i, gflags);\n\t\tif (IS_ERR(drv->gpios[i]))\n\t\t\treturn PTR_ERR(drv->gpios[i]);\n\n\t\tgpiod_set_consumer_name(drv->gpios[i], \"MEN A21 Watchdog\");\n\n\t\t \n\t\tif (i < GPIO_WD_RST0) {\n\t\t\tint val;\n\n\t\t\tval = gpiod_get_value(drv->gpios[i]);\n\t\t\tgpiod_direction_output(drv->gpios[i], val);\n\t\t}\n\t}\n\n\twatchdog_init_timeout(&a21_wdt, 30, dev);\n\twatchdog_set_nowayout(&a21_wdt, nowayout);\n\twatchdog_set_drvdata(&a21_wdt, drv);\n\ta21_wdt.parent = dev;\n\n\treset = a21_wdt_get_bootstatus(drv);\n\tif (reset == 2)\n\t\ta21_wdt.bootstatus |= WDIOF_EXTERN1;\n\telse if (reset == 4)\n\t\ta21_wdt.bootstatus |= WDIOF_CARDRESET;\n\telse if (reset == 5)\n\t\ta21_wdt.bootstatus |= WDIOF_POWERUNDER;\n\telse if (reset == 7)\n\t\ta21_wdt.bootstatus |= WDIOF_EXTERN2;\n\n\tdrv->wdt = a21_wdt;\n\tdev_set_drvdata(dev, drv);\n\n\tret = devm_watchdog_register_device(dev, &a21_wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"MEN A21 watchdog timer driver enabled\\n\");\n\n\treturn 0;\n}\n\nstatic void a21_wdt_shutdown(struct platform_device *pdev)\n{\n\tstruct a21_wdt_drv *drv = dev_get_drvdata(&pdev->dev);\n\n\tgpiod_set_value(drv->gpios[GPIO_WD_ENAB], 0);\n}\n\nstatic const struct of_device_id a21_wdt_ids[] = {\n\t{ .compatible = \"men,a021-wdt\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, a21_wdt_ids);\n\nstatic struct platform_driver a21_wdt_driver = {\n\t.probe = a21_wdt_probe,\n\t.shutdown = a21_wdt_shutdown,\n\t.driver = {\n\t\t.name = \"a21-watchdog\",\n\t\t.of_match_table = a21_wdt_ids,\n\t},\n};\n\nmodule_platform_driver(a21_wdt_driver);\n\nMODULE_AUTHOR(\"MEN Mikro Elektronik\");\nMODULE_DESCRIPTION(\"MEN A21 Watchdog\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:a21-watchdog\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}