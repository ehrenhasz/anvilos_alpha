{
  "module_name": "nv_tco.c",
  "hash_id": "1ad7ababea19b4797016dc7e71947ee3766b9f07bcf6326dad1e300b606e3483",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/nv_tco.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#include \"nv_tco.h\"\n\n \n#define TCO_VERSION \"0.01\"\n#define TCO_MODULE_NAME \"NV_TCO\"\n#define TCO_DRIVER_NAME   TCO_MODULE_NAME \", v\" TCO_VERSION\n\n \nstatic unsigned int tcobase;\nstatic DEFINE_SPINLOCK(tco_lock);\t \nstatic unsigned long timer_alive;\nstatic char tco_expect_close;\nstatic struct pci_dev *tco_pci;\n\n \nstatic struct platform_device *nv_tco_platform_device;\n\n \n#define WATCHDOG_HEARTBEAT 30\t \nstatic int heartbeat = WATCHDOG_HEARTBEAT;   \nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeat in seconds. (2<heartbeat<39, \"\n\t\t\t    \"default=\" __MODULE_STRING(WATCHDOG_HEARTBEAT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started\"\n\t\t\" (default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \nstatic inline unsigned char seconds_to_ticks(int seconds)\n{\n\t \n\treturn (seconds * 10) / 6;\n}\n\nstatic void tco_timer_start(void)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tco_lock, flags);\n\tval = inl(TCO_CNT(tcobase));\n\tval &= ~TCO_CNT_TCOHALT;\n\toutl(val, TCO_CNT(tcobase));\n\tspin_unlock_irqrestore(&tco_lock, flags);\n}\n\nstatic void tco_timer_stop(void)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tco_lock, flags);\n\tval = inl(TCO_CNT(tcobase));\n\tval |= TCO_CNT_TCOHALT;\n\toutl(val, TCO_CNT(tcobase));\n\tspin_unlock_irqrestore(&tco_lock, flags);\n}\n\nstatic void tco_timer_keepalive(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tco_lock, flags);\n\toutb(0x01, TCO_RLD(tcobase));\n\tspin_unlock_irqrestore(&tco_lock, flags);\n}\n\nstatic int tco_timer_set_heartbeat(int t)\n{\n\tint ret = 0;\n\tunsigned char tmrval;\n\tunsigned long flags;\n\tu8 val;\n\n\t \n\tif (t < 0 || t > 0x3f)\n\t\treturn -EINVAL;\n\ttmrval = seconds_to_ticks(t);\n\n\t \n\tif (tmrval > 0x3f || tmrval < 0x04)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_irqsave(&tco_lock, flags);\n\tval = inb(TCO_TMR(tcobase));\n\tval &= 0xc0;\n\tval |= tmrval;\n\toutb(val, TCO_TMR(tcobase));\n\tval = inb(TCO_TMR(tcobase));\n\n\tif ((val & 0x3f) != tmrval)\n\t\tret = -EINVAL;\n\tspin_unlock_irqrestore(&tco_lock, flags);\n\n\tif (ret)\n\t\treturn ret;\n\n\theartbeat = t;\n\treturn 0;\n}\n\n \n\nstatic int nv_tco_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &timer_alive))\n\t\treturn -EBUSY;\n\n\t \n\ttco_timer_keepalive();\n\ttco_timer_start();\n\treturn stream_open(inode, file);\n}\n\nstatic int nv_tco_release(struct inode *inode, struct file *file)\n{\n\t \n\tif (tco_expect_close == 42) {\n\t\ttco_timer_stop();\n\t} else {\n\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\ttco_timer_keepalive();\n\t}\n\tclear_bit(0, &timer_alive);\n\ttco_expect_close = 0;\n\treturn 0;\n}\n\nstatic ssize_t nv_tco_write(struct file *file, const char __user *data,\n\t\t\t    size_t len, loff_t *ppos)\n{\n\t \n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\ttco_expect_close = 0;\n\n\t\t\t \n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\ttco_expect_close = 42;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttco_timer_keepalive();\n\t}\n\treturn len;\n}\n\nstatic long nv_tco_ioctl(struct file *file, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tint new_options, retval = -EINVAL;\n\tint new_heartbeat;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_SETTIMEOUT |\n\t\t\t\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.firmware_version =\t0,\n\t\t.identity =\t\tTCO_MODULE_NAME,\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(new_options, p))\n\t\t\treturn -EFAULT;\n\t\tif (new_options & WDIOS_DISABLECARD) {\n\t\t\ttco_timer_stop();\n\t\t\tretval = 0;\n\t\t}\n\t\tif (new_options & WDIOS_ENABLECARD) {\n\t\t\ttco_timer_keepalive();\n\t\t\ttco_timer_start();\n\t\t\tretval = 0;\n\t\t}\n\t\treturn retval;\n\tcase WDIOC_KEEPALIVE:\n\t\ttco_timer_keepalive();\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_heartbeat, p))\n\t\t\treturn -EFAULT;\n\t\tif (tco_timer_set_heartbeat(new_heartbeat))\n\t\t\treturn -EINVAL;\n\t\ttco_timer_keepalive();\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(heartbeat, p);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \n\nstatic const struct file_operations nv_tco_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.llseek =\t\tno_llseek,\n\t.write =\t\tnv_tco_write,\n\t.unlocked_ioctl =\tnv_tco_ioctl,\n\t.compat_ioctl =\t\tcompat_ptr_ioctl,\n\t.open =\t\t\tnv_tco_open,\n\t.release =\t\tnv_tco_release,\n};\n\nstatic struct miscdevice nv_tco_miscdev = {\n\t.minor =\tWATCHDOG_MINOR,\n\t.name =\t\t\"watchdog\",\n\t.fops =\t\t&nv_tco_fops,\n};\n\n \nstatic const struct pci_device_id tco_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SMBUS,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SMBUS,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP78S_SMBUS,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP79_SMBUS,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, },\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, tco_pci_tbl);\n\n \n\nstatic unsigned char nv_tco_getdevice(void)\n{\n\tstruct pci_dev *dev = NULL;\n\tu32 val;\n\n\t \n\tfor_each_pci_dev(dev) {\n\t\tif (pci_match_id(tco_pci_tbl, dev) != NULL) {\n\t\t\ttco_pci = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tco_pci)\n\t\treturn 0;\n\n\t \n\tpci_read_config_dword(tco_pci, 0x64, &val);\n\tval &= 0xffff;\n\tif (val == 0x0001 || val == 0x0000) {\n\t\t \n\t\tpr_err(\"failed to get tcobase address\\n\");\n\t\treturn 0;\n\t}\n\tval &= 0xff00;\n\ttcobase = val + 0x40;\n\n\tif (!request_region(tcobase, 0x10, \"NV TCO\")) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\", tcobase);\n\t\treturn 0;\n\t}\n\n\t \n\ttco_timer_set_heartbeat(30);\n\n\t \n\ttco_timer_keepalive();\n\ttco_timer_stop();\n\n\t \n\tif (!request_region(MCP51_SMI_EN(tcobase), 4, \"NV TCO\")) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\",\n\t\t       MCP51_SMI_EN(tcobase));\n\t\tgoto out;\n\t}\n\tval = inl(MCP51_SMI_EN(tcobase));\n\tval &= ~MCP51_SMI_EN_TCO;\n\toutl(val, MCP51_SMI_EN(tcobase));\n\tval = inl(MCP51_SMI_EN(tcobase));\n\trelease_region(MCP51_SMI_EN(tcobase), 4);\n\tif (val & MCP51_SMI_EN_TCO) {\n\t\tpr_err(\"Could not disable SMI caused by TCO\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tpci_read_config_dword(tco_pci, MCP51_SMBUS_SETUP_B, &val);\n\tval |= MCP51_SMBUS_SETUP_B_TCO_REBOOT;\n\tpci_write_config_dword(tco_pci, MCP51_SMBUS_SETUP_B, val);\n\tpci_read_config_dword(tco_pci, MCP51_SMBUS_SETUP_B, &val);\n\tif (!(val & MCP51_SMBUS_SETUP_B_TCO_REBOOT)) {\n\t\tpr_err(\"failed to reset NO_REBOOT flag, reboot disabled by hardware\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 1;\nout:\n\trelease_region(tcobase, 0x10);\n\treturn 0;\n}\n\nstatic int nv_tco_init(struct platform_device *dev)\n{\n\tint ret;\n\n\t \n\tif (!nv_tco_getdevice())\n\t\treturn -ENODEV;\n\n\t \n\tpr_info(\"Watchdog reboot %sdetected\\n\",\n\t\tinl(TCO_STS(tcobase)) & TCO_STS_TCO2TO_STS ? \"\" : \"not \");\n\n\t \n\toutl(TCO_STS_RESET, TCO_STS(tcobase));\n\n\t \n\tif (tco_timer_set_heartbeat(heartbeat)) {\n\t\theartbeat = WATCHDOG_HEARTBEAT;\n\t\ttco_timer_set_heartbeat(heartbeat);\n\t\tpr_info(\"heartbeat value must be 2<heartbeat<39, using %d\\n\",\n\t\t\theartbeat);\n\t}\n\n\tret = misc_register(&nv_tco_miscdev);\n\tif (ret != 0) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, ret);\n\t\tgoto unreg_region;\n\t}\n\n\tclear_bit(0, &timer_alive);\n\n\ttco_timer_stop();\n\n\tpr_info(\"initialized (0x%04x). heartbeat=%d sec (nowayout=%d)\\n\",\n\t\ttcobase, heartbeat, nowayout);\n\n\treturn 0;\n\nunreg_region:\n\trelease_region(tcobase, 0x10);\n\treturn ret;\n}\n\nstatic void nv_tco_cleanup(void)\n{\n\tu32 val;\n\n\t \n\tif (!nowayout)\n\t\ttco_timer_stop();\n\n\t \n\tpci_read_config_dword(tco_pci, MCP51_SMBUS_SETUP_B, &val);\n\tval &= ~MCP51_SMBUS_SETUP_B_TCO_REBOOT;\n\tpci_write_config_dword(tco_pci, MCP51_SMBUS_SETUP_B, val);\n\tpci_read_config_dword(tco_pci, MCP51_SMBUS_SETUP_B, &val);\n\tif (val & MCP51_SMBUS_SETUP_B_TCO_REBOOT) {\n\t\tpr_crit(\"Couldn't unset REBOOT bit.  Machine may soon reset\\n\");\n\t}\n\n\t \n\tmisc_deregister(&nv_tco_miscdev);\n\trelease_region(tcobase, 0x10);\n}\n\nstatic void nv_tco_remove(struct platform_device *dev)\n{\n\tif (tcobase)\n\t\tnv_tco_cleanup();\n}\n\nstatic void nv_tco_shutdown(struct platform_device *dev)\n{\n\tu32 val;\n\n\ttco_timer_stop();\n\n\t \n\tpci_read_config_dword(tco_pci, MCP51_SMBUS_SETUP_B, &val);\n\tval &= ~MCP51_SMBUS_SETUP_B_TCO_REBOOT;\n\tpci_write_config_dword(tco_pci, MCP51_SMBUS_SETUP_B, val);\n}\n\nstatic struct platform_driver nv_tco_driver = {\n\t.probe\t\t= nv_tco_init,\n\t.remove_new\t= nv_tco_remove,\n\t.shutdown\t= nv_tco_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= TCO_MODULE_NAME,\n\t},\n};\n\nstatic int __init nv_tco_init_module(void)\n{\n\tint err;\n\n\tpr_info(\"NV TCO WatchDog Timer Driver v%s\\n\", TCO_VERSION);\n\n\terr = platform_driver_register(&nv_tco_driver);\n\tif (err)\n\t\treturn err;\n\n\tnv_tco_platform_device = platform_device_register_simple(\n\t\t\t\t\tTCO_MODULE_NAME, -1, NULL, 0);\n\tif (IS_ERR(nv_tco_platform_device)) {\n\t\terr = PTR_ERR(nv_tco_platform_device);\n\t\tgoto unreg_platform_driver;\n\t}\n\n\treturn 0;\n\nunreg_platform_driver:\n\tplatform_driver_unregister(&nv_tco_driver);\n\treturn err;\n}\n\nstatic void __exit nv_tco_cleanup_module(void)\n{\n\tplatform_device_unregister(nv_tco_platform_device);\n\tplatform_driver_unregister(&nv_tco_driver);\n\tpr_info(\"NV TCO Watchdog Module Unloaded\\n\");\n}\n\nmodule_init(nv_tco_init_module);\nmodule_exit(nv_tco_cleanup_module);\n\nMODULE_AUTHOR(\"Mike Waychison\");\nMODULE_DESCRIPTION(\"TCO timer driver for NV chipsets\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}