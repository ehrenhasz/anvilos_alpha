{
  "module_name": "xilinx_wwdt.c",
  "hash_id": "6c3af2fda515ae30ab6fa9b02b330a83dd6cfc1c02829858512ab9c9b5eaf124",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/xilinx_wwdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/math64.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n \n#define XWWDT_DEFAULT_TIMEOUT\t42\n#define XWWDT_MIN_TIMEOUT\t1\n\n \n#define XWWDT_MWR_OFFSET\t0x00\n#define XWWDT_ESR_OFFSET\t0x04\n#define XWWDT_FCR_OFFSET\t0x08\n#define XWWDT_FWR_OFFSET\t0x0c\n#define XWWDT_SWR_OFFSET\t0x10\n\n \n#define XWWDT_MWR_MASK\t\tBIT(0)\n\n \n#define XWWDT_ESR_WINT_MASK\tBIT(16)\n#define XWWDT_ESR_WSW_MASK\tBIT(8)\n#define XWWDT_ESR_WEN_MASK\tBIT(0)\n\n#define XWWDT_CLOSE_WINDOW_PERCENT\t50\n\nstatic int wwdt_timeout;\nstatic int closed_window_percent;\n\nmodule_param(wwdt_timeout, int, 0);\nMODULE_PARM_DESC(wwdt_timeout,\n\t\t \"Watchdog time in seconds. (default=\"\n\t\t __MODULE_STRING(XWWDT_DEFAULT_TIMEOUT) \")\");\nmodule_param(closed_window_percent, int, 0);\nMODULE_PARM_DESC(closed_window_percent,\n\t\t \"Watchdog closed window percentage. (default=\"\n\t\t __MODULE_STRING(XWWDT_CLOSE_WINDOW_PERCENT) \")\");\n \nstruct xwwdt_device {\n\tvoid __iomem *base;\n\tspinlock_t spinlock;  \n\tstruct watchdog_device xilinx_wwdt_wdd;\n\tunsigned long freq;\n\tu32 close_percent;\n};\n\nstatic int xilinx_wwdt_start(struct watchdog_device *wdd)\n{\n\tstruct xwwdt_device *xdev = watchdog_get_drvdata(wdd);\n\tstruct watchdog_device *xilinx_wwdt_wdd = &xdev->xilinx_wwdt_wdd;\n\tu64 time_out, closed_timeout, open_timeout;\n\tu32 control_status_reg;\n\n\t \n\ttime_out = xdev->freq * wdd->timeout;\n\tclosed_timeout = div_u64(time_out * xdev->close_percent, 100);\n\topen_timeout = time_out - closed_timeout;\n\twdd->min_hw_heartbeat_ms = xdev->close_percent * 10 * wdd->timeout;\n\n\tspin_lock(&xdev->spinlock);\n\n\tiowrite32(XWWDT_MWR_MASK, xdev->base + XWWDT_MWR_OFFSET);\n\tiowrite32(~(u32)XWWDT_ESR_WEN_MASK, xdev->base + XWWDT_ESR_OFFSET);\n\tiowrite32((u32)closed_timeout, xdev->base + XWWDT_FWR_OFFSET);\n\tiowrite32((u32)open_timeout, xdev->base + XWWDT_SWR_OFFSET);\n\n\t \n\tcontrol_status_reg = ioread32(xdev->base + XWWDT_ESR_OFFSET);\n\tcontrol_status_reg |= XWWDT_ESR_WEN_MASK;\n\tiowrite32(control_status_reg, xdev->base + XWWDT_ESR_OFFSET);\n\n\tspin_unlock(&xdev->spinlock);\n\n\tdev_dbg(xilinx_wwdt_wdd->parent, \"Watchdog Started!\\n\");\n\n\treturn 0;\n}\n\nstatic int xilinx_wwdt_keepalive(struct watchdog_device *wdd)\n{\n\tstruct xwwdt_device *xdev = watchdog_get_drvdata(wdd);\n\tu32 control_status_reg;\n\n\tspin_lock(&xdev->spinlock);\n\n\t \n\tiowrite32(XWWDT_MWR_MASK, xdev->base + XWWDT_MWR_OFFSET);\n\n\t \n\tcontrol_status_reg = ioread32(xdev->base + XWWDT_ESR_OFFSET);\n\tcontrol_status_reg |= XWWDT_ESR_WSW_MASK;\n\tiowrite32(control_status_reg, xdev->base + XWWDT_ESR_OFFSET);\n\n\tspin_unlock(&xdev->spinlock);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info xilinx_wwdt_ident = {\n\t.options = WDIOF_KEEPALIVEPING |\n\t\tWDIOF_SETTIMEOUT,\n\t.firmware_version = 1,\n\t.identity = \"xlnx_window watchdog\",\n};\n\nstatic const struct watchdog_ops xilinx_wwdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = xilinx_wwdt_start,\n\t.ping = xilinx_wwdt_keepalive,\n};\n\nstatic int xwwdt_probe(struct platform_device *pdev)\n{\n\tstruct watchdog_device *xilinx_wwdt_wdd;\n\tstruct device *dev = &pdev->dev;\n\tstruct xwwdt_device *xdev;\n\tstruct clk *clk;\n\tint ret;\n\n\txdev = devm_kzalloc(dev, sizeof(*xdev), GFP_KERNEL);\n\tif (!xdev)\n\t\treturn -ENOMEM;\n\n\txilinx_wwdt_wdd = &xdev->xilinx_wwdt_wdd;\n\txilinx_wwdt_wdd->info = &xilinx_wwdt_ident;\n\txilinx_wwdt_wdd->ops = &xilinx_wwdt_ops;\n\txilinx_wwdt_wdd->parent = dev;\n\n\txdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xdev->base))\n\t\treturn PTR_ERR(xdev->base);\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\txdev->freq = clk_get_rate(clk);\n\tif (!xdev->freq)\n\t\treturn -EINVAL;\n\n\txilinx_wwdt_wdd->min_timeout = XWWDT_MIN_TIMEOUT;\n\txilinx_wwdt_wdd->timeout = XWWDT_DEFAULT_TIMEOUT;\n\txilinx_wwdt_wdd->max_hw_heartbeat_ms = 1000 * xilinx_wwdt_wdd->timeout;\n\n\tif (closed_window_percent == 0 || closed_window_percent >= 100)\n\t\txdev->close_percent = XWWDT_CLOSE_WINDOW_PERCENT;\n\telse\n\t\txdev->close_percent = closed_window_percent;\n\n\twatchdog_init_timeout(xilinx_wwdt_wdd, wwdt_timeout, &pdev->dev);\n\tspin_lock_init(&xdev->spinlock);\n\twatchdog_set_drvdata(xilinx_wwdt_wdd, xdev);\n\twatchdog_set_nowayout(xilinx_wwdt_wdd, 1);\n\n\tret = devm_watchdog_register_device(dev, xilinx_wwdt_wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"Xilinx window watchdog Timer with timeout %ds\\n\",\n\t\t xilinx_wwdt_wdd->timeout);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xwwdt_of_match[] = {\n\t{ .compatible = \"xlnx,versal-wwdt\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xwwdt_of_match);\n\nstatic struct platform_driver xwwdt_driver = {\n\t.probe = xwwdt_probe,\n\t.driver = {\n\t\t.name = \"Xilinx window watchdog\",\n\t\t.of_match_table = xwwdt_of_match,\n\t},\n};\n\nmodule_platform_driver(xwwdt_driver);\n\nMODULE_AUTHOR(\"Neeli Srinivas <srinivas.neeli@amd.com>\");\nMODULE_DESCRIPTION(\"Xilinx window watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}