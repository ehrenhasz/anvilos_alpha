{
  "module_name": "mtk_wdt.c",
  "hash_id": "fa8409ccf7bda4dc552ce889a201ca28585618779f5f0f543286b3a83c60ee1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/mtk_wdt.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/reset/mt2712-resets.h>\n#include <dt-bindings/reset/mediatek,mt6795-resets.h>\n#include <dt-bindings/reset/mt7986-resets.h>\n#include <dt-bindings/reset/mt8183-resets.h>\n#include <dt-bindings/reset/mt8186-resets.h>\n#include <dt-bindings/reset/mt8188-resets.h>\n#include <dt-bindings/reset/mt8192-resets.h>\n#include <dt-bindings/reset/mt8195-resets.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/interrupt.h>\n\n#define WDT_MAX_TIMEOUT\t\t31\n#define WDT_MIN_TIMEOUT\t\t2\n#define WDT_LENGTH_TIMEOUT(n)\t((n) << 5)\n\n#define WDT_LENGTH\t\t0x04\n#define WDT_LENGTH_KEY\t\t0x8\n\n#define WDT_RST\t\t\t0x08\n#define WDT_RST_RELOAD\t\t0x1971\n\n#define WDT_MODE\t\t0x00\n#define WDT_MODE_EN\t\t(1 << 0)\n#define WDT_MODE_EXT_POL_LOW\t(0 << 1)\n#define WDT_MODE_EXT_POL_HIGH\t(1 << 1)\n#define WDT_MODE_EXRST_EN\t(1 << 2)\n#define WDT_MODE_IRQ_EN\t\t(1 << 3)\n#define WDT_MODE_AUTO_START\t(1 << 4)\n#define WDT_MODE_DUAL_EN\t(1 << 6)\n#define WDT_MODE_CNT_SEL\t(1 << 8)\n#define WDT_MODE_KEY\t\t0x22000000\n\n#define WDT_SWRST\t\t0x14\n#define WDT_SWRST_KEY\t\t0x1209\n\n#define WDT_SWSYSRST\t\t0x18U\n#define WDT_SWSYS_RST_KEY\t0x88000000\n\n#define DRV_NAME\t\t\"mtk-wdt\"\n#define DRV_VERSION\t\t\"1.0\"\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic unsigned int timeout;\n\nstruct mtk_wdt_dev {\n\tstruct watchdog_device wdt_dev;\n\tvoid __iomem *wdt_base;\n\tspinlock_t lock;  \n\tstruct reset_controller_dev rcdev;\n\tbool disable_wdt_extrst;\n\tbool reset_by_toprgu;\n};\n\nstruct mtk_wdt_data {\n\tint toprgu_sw_rst_num;\n};\n\nstatic const struct mtk_wdt_data mt2712_data = {\n\t.toprgu_sw_rst_num = MT2712_TOPRGU_SW_RST_NUM,\n};\n\nstatic const struct mtk_wdt_data mt6795_data = {\n\t.toprgu_sw_rst_num = MT6795_TOPRGU_SW_RST_NUM,\n};\n\nstatic const struct mtk_wdt_data mt7986_data = {\n\t.toprgu_sw_rst_num = MT7986_TOPRGU_SW_RST_NUM,\n};\n\nstatic const struct mtk_wdt_data mt8183_data = {\n\t.toprgu_sw_rst_num = MT8183_TOPRGU_SW_RST_NUM,\n};\n\nstatic const struct mtk_wdt_data mt8186_data = {\n\t.toprgu_sw_rst_num = MT8186_TOPRGU_SW_RST_NUM,\n};\n\nstatic const struct mtk_wdt_data mt8188_data = {\n\t.toprgu_sw_rst_num = MT8188_TOPRGU_SW_RST_NUM,\n};\n\nstatic const struct mtk_wdt_data mt8192_data = {\n\t.toprgu_sw_rst_num = MT8192_TOPRGU_SW_RST_NUM,\n};\n\nstatic const struct mtk_wdt_data mt8195_data = {\n\t.toprgu_sw_rst_num = MT8195_TOPRGU_SW_RST_NUM,\n};\n\nstatic int toprgu_reset_update(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id, bool assert)\n{\n\tunsigned int tmp;\n\tunsigned long flags;\n\tstruct mtk_wdt_dev *data =\n\t\t container_of(rcdev, struct mtk_wdt_dev, rcdev);\n\n\tspin_lock_irqsave(&data->lock, flags);\n\n\ttmp = readl(data->wdt_base + WDT_SWSYSRST);\n\tif (assert)\n\t\ttmp |= BIT(id);\n\telse\n\t\ttmp &= ~BIT(id);\n\ttmp |= WDT_SWSYS_RST_KEY;\n\twritel(tmp, data->wdt_base + WDT_SWSYSRST);\n\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\treturn 0;\n}\n\nstatic int toprgu_reset_assert(struct reset_controller_dev *rcdev,\n\t\t\t       unsigned long id)\n{\n\treturn toprgu_reset_update(rcdev, id, true);\n}\n\nstatic int toprgu_reset_deassert(struct reset_controller_dev *rcdev,\n\t\t\t\t unsigned long id)\n{\n\treturn toprgu_reset_update(rcdev, id, false);\n}\n\nstatic int toprgu_reset(struct reset_controller_dev *rcdev,\n\t\t\tunsigned long id)\n{\n\tint ret;\n\n\tret = toprgu_reset_assert(rcdev, id);\n\tif (ret)\n\t\treturn ret;\n\n\treturn toprgu_reset_deassert(rcdev, id);\n}\n\nstatic const struct reset_control_ops toprgu_reset_ops = {\n\t.assert = toprgu_reset_assert,\n\t.deassert = toprgu_reset_deassert,\n\t.reset = toprgu_reset,\n};\n\nstatic int toprgu_register_reset_controller(struct platform_device *pdev,\n\t\t\t\t\t    int rst_num)\n{\n\tint ret;\n\tstruct mtk_wdt_dev *mtk_wdt = platform_get_drvdata(pdev);\n\n\tspin_lock_init(&mtk_wdt->lock);\n\n\tmtk_wdt->rcdev.owner = THIS_MODULE;\n\tmtk_wdt->rcdev.nr_resets = rst_num;\n\tmtk_wdt->rcdev.ops = &toprgu_reset_ops;\n\tmtk_wdt->rcdev.of_node = pdev->dev.of_node;\n\tret = devm_reset_controller_register(&pdev->dev, &mtk_wdt->rcdev);\n\tif (ret != 0)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"couldn't register wdt reset controller: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mtk_wdt_restart(struct watchdog_device *wdt_dev,\n\t\t\t   unsigned long action, void *data)\n{\n\tstruct mtk_wdt_dev *mtk_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base;\n\n\twdt_base = mtk_wdt->wdt_base;\n\n\twhile (1) {\n\t\twritel(WDT_SWRST_KEY, wdt_base + WDT_SWRST);\n\t\tmdelay(5);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct mtk_wdt_dev *mtk_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = mtk_wdt->wdt_base;\n\n\tiowrite32(WDT_RST_RELOAD, wdt_base + WDT_RST);\n\n\treturn 0;\n}\n\nstatic int mtk_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\tunsigned int timeout)\n{\n\tstruct mtk_wdt_dev *mtk_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = mtk_wdt->wdt_base;\n\tu32 reg;\n\n\twdt_dev->timeout = timeout;\n\t \n\tif (wdt_dev->pretimeout)\n\t\twdt_dev->pretimeout = timeout / 2;\n\n\t \n\treg = WDT_LENGTH_TIMEOUT((timeout - wdt_dev->pretimeout) << 6)\n\t\t\t| WDT_LENGTH_KEY;\n\tiowrite32(reg, wdt_base + WDT_LENGTH);\n\n\tmtk_wdt_ping(wdt_dev);\n\n\treturn 0;\n}\n\nstatic void mtk_wdt_init(struct watchdog_device *wdt_dev)\n{\n\tstruct mtk_wdt_dev *mtk_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base;\n\n\twdt_base = mtk_wdt->wdt_base;\n\n\tif (readl(wdt_base + WDT_MODE) & WDT_MODE_EN) {\n\t\tset_bit(WDOG_HW_RUNNING, &wdt_dev->status);\n\t\tmtk_wdt_set_timeout(wdt_dev, wdt_dev->timeout);\n\t}\n}\n\nstatic int mtk_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct mtk_wdt_dev *mtk_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = mtk_wdt->wdt_base;\n\tu32 reg;\n\n\treg = readl(wdt_base + WDT_MODE);\n\treg &= ~WDT_MODE_EN;\n\treg |= WDT_MODE_KEY;\n\tiowrite32(reg, wdt_base + WDT_MODE);\n\n\treturn 0;\n}\n\nstatic int mtk_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tu32 reg;\n\tstruct mtk_wdt_dev *mtk_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = mtk_wdt->wdt_base;\n\tint ret;\n\n\tret = mtk_wdt_set_timeout(wdt_dev, wdt_dev->timeout);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg = ioread32(wdt_base + WDT_MODE);\n\tif (wdt_dev->pretimeout)\n\t\treg |= (WDT_MODE_IRQ_EN | WDT_MODE_DUAL_EN);\n\telse\n\t\treg &= ~(WDT_MODE_IRQ_EN | WDT_MODE_DUAL_EN);\n\tif (mtk_wdt->disable_wdt_extrst)\n\t\treg &= ~WDT_MODE_EXRST_EN;\n\tif (mtk_wdt->reset_by_toprgu)\n\t\treg |= WDT_MODE_CNT_SEL;\n\treg |= (WDT_MODE_EN | WDT_MODE_KEY);\n\tiowrite32(reg, wdt_base + WDT_MODE);\n\n\treturn 0;\n}\n\nstatic int mtk_wdt_set_pretimeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct mtk_wdt_dev *mtk_wdt = watchdog_get_drvdata(wdd);\n\tvoid __iomem *wdt_base = mtk_wdt->wdt_base;\n\tu32 reg = ioread32(wdt_base + WDT_MODE);\n\n\tif (timeout && !wdd->pretimeout) {\n\t\twdd->pretimeout = wdd->timeout / 2;\n\t\treg |= (WDT_MODE_IRQ_EN | WDT_MODE_DUAL_EN);\n\t} else if (!timeout && wdd->pretimeout) {\n\t\twdd->pretimeout = 0;\n\t\treg &= ~(WDT_MODE_IRQ_EN | WDT_MODE_DUAL_EN);\n\t} else {\n\t\treturn 0;\n\t}\n\n\treg |= WDT_MODE_KEY;\n\tiowrite32(reg, wdt_base + WDT_MODE);\n\n\treturn mtk_wdt_set_timeout(wdd, wdd->timeout);\n}\n\nstatic irqreturn_t mtk_wdt_isr(int irq, void *arg)\n{\n\tstruct watchdog_device *wdd = arg;\n\n\twatchdog_notify_pretimeout(wdd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct watchdog_info mtk_wdt_info = {\n\t.identity\t= DRV_NAME,\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_info mtk_wdt_pt_info = {\n\t.identity\t= DRV_NAME,\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_PRETIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops mtk_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= mtk_wdt_start,\n\t.stop\t\t= mtk_wdt_stop,\n\t.ping\t\t= mtk_wdt_ping,\n\t.set_timeout\t= mtk_wdt_set_timeout,\n\t.set_pretimeout\t= mtk_wdt_set_pretimeout,\n\t.restart\t= mtk_wdt_restart,\n};\n\nstatic int mtk_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_wdt_dev *mtk_wdt;\n\tconst struct mtk_wdt_data *wdt_data;\n\tint err, irq;\n\n\tmtk_wdt = devm_kzalloc(dev, sizeof(*mtk_wdt), GFP_KERNEL);\n\tif (!mtk_wdt)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mtk_wdt);\n\n\tmtk_wdt->wdt_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mtk_wdt->wdt_base))\n\t\treturn PTR_ERR(mtk_wdt->wdt_base);\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq > 0) {\n\t\terr = devm_request_irq(&pdev->dev, irq, mtk_wdt_isr, 0, \"wdt_bark\",\n\t\t\t\t       &mtk_wdt->wdt_dev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmtk_wdt->wdt_dev.info = &mtk_wdt_pt_info;\n\t\tmtk_wdt->wdt_dev.pretimeout = WDT_MAX_TIMEOUT / 2;\n\t} else {\n\t\tif (irq == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tmtk_wdt->wdt_dev.info = &mtk_wdt_info;\n\t}\n\n\tmtk_wdt->wdt_dev.ops = &mtk_wdt_ops;\n\tmtk_wdt->wdt_dev.timeout = WDT_MAX_TIMEOUT;\n\tmtk_wdt->wdt_dev.max_hw_heartbeat_ms = WDT_MAX_TIMEOUT * 1000;\n\tmtk_wdt->wdt_dev.min_timeout = WDT_MIN_TIMEOUT;\n\tmtk_wdt->wdt_dev.parent = dev;\n\n\twatchdog_init_timeout(&mtk_wdt->wdt_dev, timeout, dev);\n\twatchdog_set_nowayout(&mtk_wdt->wdt_dev, nowayout);\n\twatchdog_set_restart_priority(&mtk_wdt->wdt_dev, 128);\n\n\twatchdog_set_drvdata(&mtk_wdt->wdt_dev, mtk_wdt);\n\n\tmtk_wdt_init(&mtk_wdt->wdt_dev);\n\n\twatchdog_stop_on_reboot(&mtk_wdt->wdt_dev);\n\terr = devm_watchdog_register_device(dev, &mtk_wdt->wdt_dev);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tdev_info(dev, \"Watchdog enabled (timeout=%d sec, nowayout=%d)\\n\",\n\t\t mtk_wdt->wdt_dev.timeout, nowayout);\n\n\twdt_data = of_device_get_match_data(dev);\n\tif (wdt_data) {\n\t\terr = toprgu_register_reset_controller(pdev,\n\t\t\t\t\t\t       wdt_data->toprgu_sw_rst_num);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmtk_wdt->disable_wdt_extrst =\n\t\tof_property_read_bool(dev->of_node, \"mediatek,disable-extrst\");\n\n\tmtk_wdt->reset_by_toprgu =\n\t\tof_property_read_bool(dev->of_node, \"mediatek,reset-by-toprgu\");\n\n\treturn 0;\n}\n\nstatic int mtk_wdt_suspend(struct device *dev)\n{\n\tstruct mtk_wdt_dev *mtk_wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&mtk_wdt->wdt_dev))\n\t\tmtk_wdt_stop(&mtk_wdt->wdt_dev);\n\n\treturn 0;\n}\n\nstatic int mtk_wdt_resume(struct device *dev)\n{\n\tstruct mtk_wdt_dev *mtk_wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&mtk_wdt->wdt_dev)) {\n\t\tmtk_wdt_start(&mtk_wdt->wdt_dev);\n\t\tmtk_wdt_ping(&mtk_wdt->wdt_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mtk_wdt_dt_ids[] = {\n\t{ .compatible = \"mediatek,mt2712-wdt\", .data = &mt2712_data },\n\t{ .compatible = \"mediatek,mt6589-wdt\" },\n\t{ .compatible = \"mediatek,mt6795-wdt\", .data = &mt6795_data },\n\t{ .compatible = \"mediatek,mt7986-wdt\", .data = &mt7986_data },\n\t{ .compatible = \"mediatek,mt8183-wdt\", .data = &mt8183_data },\n\t{ .compatible = \"mediatek,mt8186-wdt\", .data = &mt8186_data },\n\t{ .compatible = \"mediatek,mt8188-wdt\", .data = &mt8188_data },\n\t{ .compatible = \"mediatek,mt8192-wdt\", .data = &mt8192_data },\n\t{ .compatible = \"mediatek,mt8195-wdt\", .data = &mt8195_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mtk_wdt_dt_ids);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mtk_wdt_pm_ops,\n\t\t\t\tmtk_wdt_suspend, mtk_wdt_resume);\n\nstatic struct platform_driver mtk_wdt_driver = {\n\t.probe\t\t= mtk_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.pm\t\t= pm_sleep_ptr(&mtk_wdt_pm_ops),\n\t\t.of_match_table\t= mtk_wdt_dt_ids,\n\t},\n};\n\nmodule_platform_driver(mtk_wdt_driver);\n\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog heartbeat in seconds\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Matthias Brugger <matthias.bgg@gmail.com>\");\nMODULE_DESCRIPTION(\"Mediatek WatchDog Timer Driver\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}