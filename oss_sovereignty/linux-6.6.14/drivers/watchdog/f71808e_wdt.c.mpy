{
  "module_name": "f71808e_wdt.c",
  "hash_id": "31b2486b6e2fd243c9bda151cbb7d1a720c79977d59a732ac06cc937663584ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/f71808e_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define DRVNAME \"f71808e_wdt\"\n\n#define SIO_F71808FG_LD_WDT\t0x07\t \n#define SIO_UNLOCK_KEY\t\t0x87\t \n#define SIO_LOCK_KEY\t\t0xAA\t \n\n#define SIO_REG_LDSEL\t\t0x07\t \n#define SIO_REG_DEVID\t\t0x20\t \n#define SIO_REG_DEVREV\t\t0x22\t \n#define SIO_REG_MANID\t\t0x23\t \n#define SIO_REG_CLOCK_SEL\t0x26\t \n#define SIO_REG_ROM_ADDR_SEL\t0x27\t \n#define SIO_F81866_REG_PORT_SEL\t0x27\t \n#define SIO_REG_TSI_LEVEL_SEL\t0x28\t \n#define SIO_REG_MFUNCT1\t\t0x29\t \n#define SIO_REG_MFUNCT2\t\t0x2a\t \n#define SIO_REG_MFUNCT3\t\t0x2b\t \n#define SIO_F81866_REG_GPIO1\t0x2c\t \n#define SIO_REG_ENABLE\t\t0x30\t \n#define SIO_REG_ADDR\t\t0x60\t \n\n#define SIO_FINTEK_ID\t\t0x1934\t \n#define SIO_F71808_ID\t\t0x0901\t \n#define SIO_F71858_ID\t\t0x0507\t \n#define SIO_F71862_ID\t\t0x0601\t \n#define SIO_F71868_ID\t\t0x1106\t \n#define SIO_F71869_ID\t\t0x0814\t \n#define SIO_F71869A_ID\t\t0x1007\t \n#define SIO_F71882_ID\t\t0x0541\t \n#define SIO_F71889_ID\t\t0x0723\t \n#define SIO_F81803_ID\t\t0x1210\t \n#define SIO_F81865_ID\t\t0x0704\t \n#define SIO_F81866_ID\t\t0x1010\t \n#define SIO_F81966_ID\t\t0x1502   \n\n#define F71808FG_REG_WDO_CONF\t\t0xf0\n#define F71808FG_REG_WDT_CONF\t\t0xf5\n#define F71808FG_REG_WD_TIME\t\t0xf6\n\n#define F71808FG_FLAG_WDOUT_EN\t\t7\n\n#define F71808FG_FLAG_WDTMOUT_STS\t6\n#define F71808FG_FLAG_WD_EN\t\t5\n#define F71808FG_FLAG_WD_PULSE\t\t4\n#define F71808FG_FLAG_WD_UNIT\t\t3\n\n#define F81865_REG_WDO_CONF\t\t0xfa\n#define F81865_FLAG_WDOUT_EN\t\t0\n\n \n#define WATCHDOG_TIMEOUT\t60\t \n#define WATCHDOG_MAX_TIMEOUT\t(60 * 255)\n#define WATCHDOG_PULSE_WIDTH\t125\t \n#define WATCHDOG_F71862FG_PIN\t63\t \n\nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\nstatic int timeout = WATCHDOG_TIMEOUT;\t \nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\"Watchdog timeout in seconds. 1<= timeout <=\"\n\t\t\t__MODULE_STRING(WATCHDOG_MAX_TIMEOUT) \" (default=\"\n\t\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic unsigned int pulse_width = WATCHDOG_PULSE_WIDTH;\nmodule_param(pulse_width, uint, 0);\nMODULE_PARM_DESC(pulse_width,\n\t\"Watchdog signal pulse width. 0(=level), 1, 25, 30, 125, 150, 5000 or 6000 ms\"\n\t\t\t\" (default=\" __MODULE_STRING(WATCHDOG_PULSE_WIDTH) \")\");\n\nstatic unsigned int f71862fg_pin = WATCHDOG_F71862FG_PIN;\nmodule_param(f71862fg_pin, uint, 0);\nMODULE_PARM_DESC(f71862fg_pin,\n\t\"Watchdog f71862fg reset output pin configuration. Choose pin 56 or 63\"\n\t\t\t\" (default=\" __MODULE_STRING(WATCHDOG_F71862FG_PIN)\")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0444);\nMODULE_PARM_DESC(nowayout, \"Disable watchdog shutdown on close\");\n\nstatic unsigned int start_withtimeout;\nmodule_param(start_withtimeout, uint, 0);\nMODULE_PARM_DESC(start_withtimeout, \"Start watchdog timer on module load with\"\n\t\" given initial timeout. Zero (default) disables this feature.\");\n\nenum chips { f71808fg, f71858fg, f71862fg, f71868, f71869, f71882fg, f71889fg,\n\t     f81803, f81865, f81866, f81966};\n\nstatic const char * const fintek_wdt_names[] = {\n\t\"f71808fg\",\n\t\"f71858fg\",\n\t\"f71862fg\",\n\t\"f71868\",\n\t\"f71869\",\n\t\"f71882fg\",\n\t\"f71889fg\",\n\t\"f81803\",\n\t\"f81865\",\n\t\"f81866\",\n\t\"f81966\"\n};\n\n \nstatic inline int superio_inb(int base, int reg);\nstatic inline int superio_inw(int base, int reg);\nstatic inline void superio_outb(int base, int reg, u8 val);\nstatic inline void superio_set_bit(int base, int reg, int bit);\nstatic inline void superio_clear_bit(int base, int reg, int bit);\nstatic inline int superio_enter(int base);\nstatic inline void superio_select(int base, int ld);\nstatic inline void superio_exit(int base);\n\nstruct fintek_wdt {\n\tstruct watchdog_device wdd;\n\tunsigned short\tsioaddr;\n\tenum chips\ttype;\n\tstruct watchdog_info ident;\n\n\tu8\t\ttimer_val;\t \n\tchar\t\tminutes_mode;\n\tu8\t\tpulse_val;\t \n\tchar\t\tpulse_mode;\t \n};\n\nstruct fintek_wdt_pdata {\n\tenum chips\ttype;\n};\n\n \nstatic inline int superio_inb(int base, int reg)\n{\n\toutb(reg, base);\n\treturn inb(base + 1);\n}\n\nstatic int superio_inw(int base, int reg)\n{\n\tint val;\n\tval  = superio_inb(base, reg) << 8;\n\tval |= superio_inb(base, reg + 1);\n\treturn val;\n}\n\nstatic inline void superio_outb(int base, int reg, u8 val)\n{\n\toutb(reg, base);\n\toutb(val, base + 1);\n}\n\nstatic inline void superio_set_bit(int base, int reg, int bit)\n{\n\tunsigned long val = superio_inb(base, reg);\n\t__set_bit(bit, &val);\n\tsuperio_outb(base, reg, val);\n}\n\nstatic inline void superio_clear_bit(int base, int reg, int bit)\n{\n\tunsigned long val = superio_inb(base, reg);\n\t__clear_bit(bit, &val);\n\tsuperio_outb(base, reg, val);\n}\n\nstatic inline int superio_enter(int base)\n{\n\t \n\tif (!request_muxed_region(base, 2, DRVNAME)) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\", (int)base);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\toutb(SIO_UNLOCK_KEY, base);\n\toutb(SIO_UNLOCK_KEY, base);\n\n\treturn 0;\n}\n\nstatic inline void superio_select(int base, int ld)\n{\n\toutb(SIO_REG_LDSEL, base);\n\toutb(ld, base + 1);\n}\n\nstatic inline void superio_exit(int base)\n{\n\toutb(SIO_LOCK_KEY, base);\n\trelease_region(base, 2);\n}\n\nstatic int fintek_wdt_set_timeout(struct watchdog_device *wdd, unsigned int timeout)\n{\n\tstruct fintek_wdt *wd = watchdog_get_drvdata(wdd);\n\n\tif (timeout > 0xff) {\n\t\twd->timer_val = DIV_ROUND_UP(timeout, 60);\n\t\twd->minutes_mode = true;\n\t\ttimeout = wd->timer_val * 60;\n\t} else {\n\t\twd->timer_val = timeout;\n\t\twd->minutes_mode = false;\n\t}\n\n\twdd->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic int fintek_wdt_set_pulse_width(struct fintek_wdt *wd, unsigned int pw)\n{\n\tunsigned int t1 = 25, t2 = 125, t3 = 5000;\n\n\tif (wd->type == f71868) {\n\t\tt1 = 30;\n\t\tt2 = 150;\n\t\tt3 = 6000;\n\t}\n\n\tif        (pw <=  1) {\n\t\twd->pulse_val = 0;\n\t} else if (pw <= t1) {\n\t\twd->pulse_val = 1;\n\t} else if (pw <= t2) {\n\t\twd->pulse_val = 2;\n\t} else if (pw <= t3) {\n\t\twd->pulse_val = 3;\n\t} else {\n\t\tpr_err(\"pulse width out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twd->pulse_mode = pw;\n\n\treturn 0;\n}\n\nstatic int fintek_wdt_keepalive(struct watchdog_device *wdd)\n{\n\tstruct fintek_wdt *wd = watchdog_get_drvdata(wdd);\n\tint err;\n\n\terr = superio_enter(wd->sioaddr);\n\tif (err)\n\t\treturn err;\n\tsuperio_select(wd->sioaddr, SIO_F71808FG_LD_WDT);\n\n\tif (wd->minutes_mode)\n\t\t \n\t\tsuperio_set_bit(wd->sioaddr, F71808FG_REG_WDT_CONF,\n\t\t\t\tF71808FG_FLAG_WD_UNIT);\n\telse\n\t\t \n\t\tsuperio_clear_bit(wd->sioaddr, F71808FG_REG_WDT_CONF,\n\t\t\t\tF71808FG_FLAG_WD_UNIT);\n\n\t \n\tsuperio_outb(wd->sioaddr, F71808FG_REG_WD_TIME,\n\t\t\t   wd->timer_val);\n\n\tsuperio_exit(wd->sioaddr);\n\n\treturn 0;\n}\n\nstatic int fintek_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct fintek_wdt *wd = watchdog_get_drvdata(wdd);\n\tint err;\n\tu8 tmp;\n\n\t \n\terr = fintek_wdt_keepalive(wdd);\n\tif (err)\n\t\treturn err;\n\n\terr = superio_enter(wd->sioaddr);\n\tif (err)\n\t\treturn err;\n\tsuperio_select(wd->sioaddr, SIO_F71808FG_LD_WDT);\n\n\t \n\tswitch (wd->type) {\n\tcase f71808fg:\n\t\t \n\t\tsuperio_clear_bit(wd->sioaddr, SIO_REG_MFUNCT2, 3);\n\t\tsuperio_clear_bit(wd->sioaddr, SIO_REG_MFUNCT3, 3);\n\t\tbreak;\n\n\tcase f71862fg:\n\t\tif (f71862fg_pin == 63) {\n\t\t\t \n\t\t\tsuperio_clear_bit(wd->sioaddr, SIO_REG_ROM_ADDR_SEL, 6);\n\t\t\tsuperio_set_bit(wd->sioaddr, SIO_REG_MFUNCT3, 4);\n\t\t} else if (f71862fg_pin == 56) {\n\t\t\tsuperio_set_bit(wd->sioaddr, SIO_REG_MFUNCT1, 1);\n\t\t}\n\t\tbreak;\n\n\tcase f71868:\n\tcase f71869:\n\t\t \n\t\tsuperio_clear_bit(wd->sioaddr, SIO_REG_MFUNCT1, 4);\n\t\tbreak;\n\n\tcase f71882fg:\n\t\t \n\t\tsuperio_set_bit(wd->sioaddr, SIO_REG_MFUNCT1, 1);\n\t\tbreak;\n\n\tcase f71889fg:\n\t\t \n\t\tsuperio_outb(wd->sioaddr, SIO_REG_MFUNCT3,\n\t\t\tsuperio_inb(wd->sioaddr, SIO_REG_MFUNCT3) & 0xcf);\n\t\tbreak;\n\n\tcase f81803:\n\t\t \n\t\tsuperio_clear_bit(wd->sioaddr, SIO_REG_CLOCK_SEL, 3);\n\t\t \n\t\tsuperio_outb(wd->sioaddr, SIO_REG_TSI_LEVEL_SEL, 0x5f &\n\t\t\tsuperio_inb(wd->sioaddr, SIO_REG_TSI_LEVEL_SEL));\n\t\tbreak;\n\n\tcase f81865:\n\t\t \n\t\tsuperio_clear_bit(wd->sioaddr, SIO_REG_MFUNCT3, 5);\n\t\tbreak;\n\n\tcase f81866:\n\tcase f81966:\n\t\t \n\t\ttmp = superio_inb(wd->sioaddr, SIO_F81866_REG_PORT_SEL);\n\t\ttmp &= ~(BIT(3) | BIT(0));\n\t\ttmp |= BIT(2);\n\t\tsuperio_outb(wd->sioaddr, SIO_F81866_REG_PORT_SEL, tmp);\n\n\t\tsuperio_clear_bit(wd->sioaddr, SIO_F81866_REG_GPIO1, 5);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\terr = -ENODEV;\n\t\tgoto exit_superio;\n\t}\n\n\tsuperio_select(wd->sioaddr, SIO_F71808FG_LD_WDT);\n\tsuperio_set_bit(wd->sioaddr, SIO_REG_ENABLE, 0);\n\n\tif (wd->type == f81865 || wd->type == f81866 || wd->type == f81966)\n\t\tsuperio_set_bit(wd->sioaddr, F81865_REG_WDO_CONF,\n\t\t\t\tF81865_FLAG_WDOUT_EN);\n\telse\n\t\tsuperio_set_bit(wd->sioaddr, F71808FG_REG_WDO_CONF,\n\t\t\t\tF71808FG_FLAG_WDOUT_EN);\n\n\tsuperio_set_bit(wd->sioaddr, F71808FG_REG_WDT_CONF,\n\t\t\tF71808FG_FLAG_WD_EN);\n\n\tif (wd->pulse_mode) {\n\t\t \n\t\tu8 wdt_conf = superio_inb(wd->sioaddr,\n\t\t\t\tF71808FG_REG_WDT_CONF);\n\n\t\t \n\t\twdt_conf = (wdt_conf & 0xfc) | (wd->pulse_val & 0x03);\n\t\t \n\t\twdt_conf |= BIT(F71808FG_FLAG_WD_PULSE);\n\n\t\tsuperio_outb(wd->sioaddr, F71808FG_REG_WDT_CONF,\n\t\t\t\twdt_conf);\n\t} else {\n\t\t \n\t\tsuperio_clear_bit(wd->sioaddr, F71808FG_REG_WDT_CONF,\n\t\t\t\tF71808FG_FLAG_WD_PULSE);\n\t}\n\nexit_superio:\n\tsuperio_exit(wd->sioaddr);\n\n\treturn err;\n}\n\nstatic int fintek_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct fintek_wdt *wd = watchdog_get_drvdata(wdd);\n\tint err;\n\n\terr = superio_enter(wd->sioaddr);\n\tif (err)\n\t\treturn err;\n\tsuperio_select(wd->sioaddr, SIO_F71808FG_LD_WDT);\n\n\tsuperio_clear_bit(wd->sioaddr, F71808FG_REG_WDT_CONF,\n\t\t\tF71808FG_FLAG_WD_EN);\n\n\tsuperio_exit(wd->sioaddr);\n\n\treturn 0;\n}\n\nstatic bool fintek_wdt_is_running(struct fintek_wdt *wd, u8 wdt_conf)\n{\n\treturn (superio_inb(wd->sioaddr, SIO_REG_ENABLE) & BIT(0))\n\t\t&& (wdt_conf & BIT(F71808FG_FLAG_WD_EN));\n}\n\nstatic const struct watchdog_ops fintek_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = fintek_wdt_start,\n\t.stop = fintek_wdt_stop,\n\t.ping = fintek_wdt_keepalive,\n\t.set_timeout = fintek_wdt_set_timeout,\n};\n\nstatic int fintek_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fintek_wdt_pdata *pdata;\n\tstruct watchdog_device *wdd;\n\tstruct fintek_wdt *wd;\n\tint wdt_conf, err = 0;\n\tstruct resource *res;\n\tint sioaddr;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\n\tsioaddr = res->start;\n\n\twd = devm_kzalloc(dev, sizeof(*wd), GFP_KERNEL);\n\tif (!wd)\n\t\treturn -ENOMEM;\n\n\tpdata = dev->platform_data;\n\n\twd->type = pdata->type;\n\twd->sioaddr = sioaddr;\n\twd->ident.options = WDIOF_SETTIMEOUT\n\t\t\t| WDIOF_MAGICCLOSE\n\t\t\t| WDIOF_KEEPALIVEPING\n\t\t\t| WDIOF_CARDRESET;\n\n\tsnprintf(wd->ident.identity,\n\t\tsizeof(wd->ident.identity), \"%s watchdog\",\n\t\tfintek_wdt_names[wd->type]);\n\n\terr = superio_enter(sioaddr);\n\tif (err)\n\t\treturn err;\n\tsuperio_select(wd->sioaddr, SIO_F71808FG_LD_WDT);\n\n\twdt_conf = superio_inb(sioaddr, F71808FG_REG_WDT_CONF);\n\n\t \n\tsuperio_outb(sioaddr, F71808FG_REG_WDT_CONF,\n\t\t     wdt_conf | BIT(F71808FG_FLAG_WDTMOUT_STS));\n\n\twdd = &wd->wdd;\n\n\tif (fintek_wdt_is_running(wd, wdt_conf))\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\n\tsuperio_exit(sioaddr);\n\n\twdd->parent\t\t= dev;\n\twdd->info               = &wd->ident;\n\twdd->ops                = &fintek_wdt_ops;\n\twdd->min_timeout        = 1;\n\twdd->max_timeout        = WATCHDOG_MAX_TIMEOUT;\n\n\twatchdog_set_drvdata(wdd, wd);\n\twatchdog_set_nowayout(wdd, nowayout);\n\twatchdog_stop_on_unregister(wdd);\n\twatchdog_stop_on_reboot(wdd);\n\twatchdog_init_timeout(wdd, start_withtimeout ?: timeout, NULL);\n\n\tif (wdt_conf & BIT(F71808FG_FLAG_WDTMOUT_STS))\n\t\twdd->bootstatus = WDIOF_CARDRESET;\n\n\t \n\tfintek_wdt_set_timeout(wdd, wdd->timeout);\n\tfintek_wdt_set_pulse_width(wd, pulse_width);\n\n\tif (start_withtimeout) {\n\t\terr = fintek_wdt_start(wdd);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"cannot start watchdog timer\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t\tdev_info(dev, \"watchdog started with initial timeout of %u sec\\n\",\n\t\t\t start_withtimeout);\n\t}\n\n\treturn devm_watchdog_register_device(dev, wdd);\n}\n\nstatic int __init fintek_wdt_find(int sioaddr)\n{\n\tenum chips type;\n\tu16 devid;\n\tint err = superio_enter(sioaddr);\n\tif (err)\n\t\treturn err;\n\n\tdevid = superio_inw(sioaddr, SIO_REG_MANID);\n\tif (devid != SIO_FINTEK_ID) {\n\t\tpr_debug(\"Not a Fintek device\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdevid = force_id ? force_id : superio_inw(sioaddr, SIO_REG_DEVID);\n\tswitch (devid) {\n\tcase SIO_F71808_ID:\n\t\ttype = f71808fg;\n\t\tbreak;\n\tcase SIO_F71862_ID:\n\t\ttype = f71862fg;\n\t\tbreak;\n\tcase SIO_F71868_ID:\n\t\ttype = f71868;\n\t\tbreak;\n\tcase SIO_F71869_ID:\n\tcase SIO_F71869A_ID:\n\t\ttype = f71869;\n\t\tbreak;\n\tcase SIO_F71882_ID:\n\t\ttype = f71882fg;\n\t\tbreak;\n\tcase SIO_F71889_ID:\n\t\ttype = f71889fg;\n\t\tbreak;\n\tcase SIO_F71858_ID:\n\t\t \n\t\terr = -ENODEV;\n\t\tgoto exit;\n\tcase SIO_F81803_ID:\n\t\ttype = f81803;\n\t\tbreak;\n\tcase SIO_F81865_ID:\n\t\ttype = f81865;\n\t\tbreak;\n\tcase SIO_F81866_ID:\n\t\ttype = f81866;\n\t\tbreak;\n\tcase SIO_F81966_ID:\n\t\ttype = f81966;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Unrecognized Fintek device: %04x\\n\",\n\t\t\t(unsigned int)devid);\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tpr_info(\"Found %s watchdog chip, revision %d\\n\",\n\t\tfintek_wdt_names[type],\n\t\t(int)superio_inb(sioaddr, SIO_REG_DEVREV));\n\nexit:\n\tsuperio_exit(sioaddr);\n\treturn err ? err : type;\n}\n\nstatic struct platform_driver fintek_wdt_driver = {\n\t.probe          = fintek_wdt_probe,\n\t.driver         = {\n\t\t.name   = DRVNAME,\n\t},\n};\n\nstatic struct platform_device *fintek_wdt_pdev;\n\nstatic int __init fintek_wdt_init(void)\n{\n\tstatic const unsigned short addrs[] = { 0x2e, 0x4e };\n\tstruct fintek_wdt_pdata pdata;\n\tstruct resource wdt_res = {};\n\tint ret;\n\tint i;\n\n\tif (f71862fg_pin != 63 && f71862fg_pin != 56) {\n\t\tpr_err(\"Invalid argument f71862fg_pin=%d\\n\", f71862fg_pin);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(addrs); i++) {\n\t\tret = fintek_wdt_find(addrs[i]);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(addrs))\n\t\treturn ret;\n\n\tpdata.type = ret;\n\n\tret = platform_driver_register(&fintek_wdt_driver);\n\tif (ret)\n\t\treturn ret;\n\n\twdt_res.name = \"superio port\";\n\twdt_res.flags = IORESOURCE_IO;\n\twdt_res.start = addrs[i];\n\twdt_res.end   = addrs[i] + 1;\n\n\tfintek_wdt_pdev = platform_device_register_resndata(NULL, DRVNAME, -1,\n\t\t\t\t\t\t\t    &wdt_res, 1,\n\t\t\t\t\t\t\t    &pdata, sizeof(pdata));\n\tif (IS_ERR(fintek_wdt_pdev)) {\n\t\tplatform_driver_unregister(&fintek_wdt_driver);\n\t\treturn PTR_ERR(fintek_wdt_pdev);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit fintek_wdt_exit(void)\n{\n\tplatform_device_unregister(fintek_wdt_pdev);\n\tplatform_driver_unregister(&fintek_wdt_driver);\n}\n\nMODULE_DESCRIPTION(\"F71808E Watchdog Driver\");\nMODULE_AUTHOR(\"Giel van Schijndel <me@mortis.eu>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(fintek_wdt_init);\nmodule_exit(fintek_wdt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}