{
  "module_name": "asm9260_wdt.c",
  "hash_id": "39ea50bbd21abaf36cbaff4ff93d6ade2c24e24a1bb1e9802829b89a2851ef8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/asm9260_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/watchdog.h>\n\n#define CLOCK_FREQ\t1000000\n\n \n#define HW_WDMOD\t\t\t0x00\n \n#define BM_MOD_WDINT\t\t\tBIT(3)\n \n#define BM_MOD_WDTOF\t\t\tBIT(2)\n \n#define BM_MOD_WDRESET\t\t\tBIT(1)\n \n#define BM_MOD_WDEN\t\t\tBIT(0)\n\n \n#define HW_WDTC\t\t\t\t0x04\n#define BM_WDTC_MAX(freq)\t\t(0x7fffffff / (freq))\n\n \n#define HW_WDFEED\t\t\t0x08\n\n \n#define HW_WDTV\t\t\t\t0x0c\n\n#define ASM9260_WDT_DEFAULT_TIMEOUT\t30\n\nenum asm9260_wdt_mode {\n\tHW_RESET,\n\tSW_RESET,\n\tDEBUG,\n};\n\nstruct asm9260_wdt_priv {\n\tstruct device\t\t*dev;\n\tstruct watchdog_device\twdd;\n\tstruct clk\t\t*clk;\n\tstruct clk\t\t*clk_ahb;\n\tstruct reset_control\t*rst;\n\n\tvoid __iomem\t\t*iobase;\n\tint\t\t\tirq;\n\tunsigned long\t\twdt_freq;\n\tenum asm9260_wdt_mode\tmode;\n};\n\nstatic int asm9260_wdt_feed(struct watchdog_device *wdd)\n{\n\tstruct asm9260_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\tiowrite32(0xaa, priv->iobase + HW_WDFEED);\n\tiowrite32(0x55, priv->iobase + HW_WDFEED);\n\n\treturn 0;\n}\n\nstatic unsigned int asm9260_wdt_gettimeleft(struct watchdog_device *wdd)\n{\n\tstruct asm9260_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\tu32 counter;\n\n\tcounter = ioread32(priv->iobase + HW_WDTV);\n\n\treturn counter / priv->wdt_freq;\n}\n\nstatic int asm9260_wdt_updatetimeout(struct watchdog_device *wdd)\n{\n\tstruct asm9260_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\tu32 counter;\n\n\tcounter = wdd->timeout * priv->wdt_freq;\n\n\tiowrite32(counter, priv->iobase + HW_WDTC);\n\n\treturn 0;\n}\n\nstatic int asm9260_wdt_enable(struct watchdog_device *wdd)\n{\n\tstruct asm9260_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\tu32 mode = 0;\n\n\tif (priv->mode == HW_RESET)\n\t\tmode = BM_MOD_WDRESET;\n\n\tiowrite32(BM_MOD_WDEN | mode, priv->iobase + HW_WDMOD);\n\n\tasm9260_wdt_updatetimeout(wdd);\n\n\tasm9260_wdt_feed(wdd);\n\n\treturn 0;\n}\n\nstatic int asm9260_wdt_disable(struct watchdog_device *wdd)\n{\n\tstruct asm9260_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\t \n\treset_control_assert(priv->rst);\n\treset_control_deassert(priv->rst);\n\n\treturn 0;\n}\n\nstatic int asm9260_wdt_settimeout(struct watchdog_device *wdd, unsigned int to)\n{\n\twdd->timeout = to;\n\tasm9260_wdt_updatetimeout(wdd);\n\n\treturn 0;\n}\n\nstatic void asm9260_wdt_sys_reset(struct asm9260_wdt_priv *priv)\n{\n\t \n\n\tiowrite32(BM_MOD_WDEN | BM_MOD_WDRESET, priv->iobase + HW_WDMOD);\n\n\tiowrite32(0xff, priv->iobase + HW_WDTC);\n\t \n\tasm9260_wdt_feed(&priv->wdd);\n\t \n\tiowrite32(0xff, priv->iobase + HW_WDFEED);\n\n\tmdelay(1000);\n}\n\nstatic irqreturn_t asm9260_wdt_irq(int irq, void *devid)\n{\n\tstruct asm9260_wdt_priv *priv = devid;\n\tu32 stat;\n\n\tstat = ioread32(priv->iobase + HW_WDMOD);\n\tif (!(stat & BM_MOD_WDINT))\n\t\treturn IRQ_NONE;\n\n\tif (priv->mode == DEBUG) {\n\t\tdev_info(priv->dev, \"Watchdog Timeout. Do nothing.\\n\");\n\t} else {\n\t\tdev_info(priv->dev, \"Watchdog Timeout. Doing SW Reset.\\n\");\n\t\tasm9260_wdt_sys_reset(priv);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int asm9260_restart(struct watchdog_device *wdd, unsigned long action,\n\t\t\t   void *data)\n{\n\tstruct asm9260_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\tasm9260_wdt_sys_reset(priv);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info asm9260_wdt_ident = {\n\t.options          =     WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING\n\t\t\t\t| WDIOF_MAGICCLOSE,\n\t.identity         =\t\"Alphascale asm9260 Watchdog\",\n};\n\nstatic const struct watchdog_ops asm9260_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= asm9260_wdt_enable,\n\t.stop\t\t= asm9260_wdt_disable,\n\t.get_timeleft\t= asm9260_wdt_gettimeleft,\n\t.ping\t\t= asm9260_wdt_feed,\n\t.set_timeout\t= asm9260_wdt_settimeout,\n\t.restart\t= asm9260_restart,\n};\n\nstatic void asm9260_clk_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int asm9260_wdt_get_dt_clks(struct asm9260_wdt_priv *priv)\n{\n\tint err;\n\tunsigned long clk;\n\n\tpriv->clk = devm_clk_get(priv->dev, \"mod\");\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(priv->dev, \"Failed to get \\\"mod\\\" clk\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\t \n\tpriv->clk_ahb = devm_clk_get(priv->dev, \"ahb\");\n\tif (IS_ERR(priv->clk_ahb)) {\n\t\tdev_err(priv->dev, \"Failed to get \\\"ahb\\\" clk\\n\");\n\t\treturn PTR_ERR(priv->clk_ahb);\n\t}\n\n\terr = clk_prepare_enable(priv->clk_ahb);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Failed to enable ahb_clk!\\n\");\n\t\treturn err;\n\t}\n\terr = devm_add_action_or_reset(priv->dev,\n\t\t\t\t       asm9260_clk_disable_unprepare,\n\t\t\t\t       priv->clk_ahb);\n\tif (err)\n\t\treturn err;\n\n\terr = clk_set_rate(priv->clk, CLOCK_FREQ);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Failed to set rate!\\n\");\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Failed to enable clk!\\n\");\n\t\treturn err;\n\t}\n\terr = devm_add_action_or_reset(priv->dev,\n\t\t\t\t       asm9260_clk_disable_unprepare,\n\t\t\t\t       priv->clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\tclk = clk_get_rate(priv->clk);\n\tif (!clk) {\n\t\tdev_err(priv->dev, \"Failed, clk is 0!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->wdt_freq = clk / 2;\n\n\treturn 0;\n}\n\nstatic void asm9260_wdt_get_dt_mode(struct asm9260_wdt_priv *priv)\n{\n\tconst char *tmp;\n\tint ret;\n\n\t \n\tpriv->mode = HW_RESET;\n\n\tret = of_property_read_string(priv->dev->of_node,\n\t\t\t\t      \"alphascale,mode\", &tmp);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (!strcmp(tmp, \"hw\"))\n\t\tpriv->mode = HW_RESET;\n\telse if (!strcmp(tmp, \"sw\"))\n\t\tpriv->mode = SW_RESET;\n\telse if (!strcmp(tmp, \"debug\"))\n\t\tpriv->mode = DEBUG;\n\telse\n\t\tdev_warn(priv->dev, \"unknown reset-type: %s. Using default \\\"hw\\\" mode.\",\n\t\t\t tmp);\n}\n\nstatic int asm9260_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct asm9260_wdt_priv *priv;\n\tstruct watchdog_device *wdd;\n\tint ret;\n\tstatic const char * const mode_name[] = { \"hw\", \"sw\", \"debug\", };\n\n\tpriv = devm_kzalloc(dev, sizeof(struct asm9260_wdt_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tpriv->iobase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->iobase))\n\t\treturn PTR_ERR(priv->iobase);\n\n\tpriv->rst = devm_reset_control_get_exclusive(dev, \"wdt_rst\");\n\tif (IS_ERR(priv->rst))\n\t\treturn PTR_ERR(priv->rst);\n\n\tret = asm9260_wdt_get_dt_clks(priv);\n\tif (ret)\n\t\treturn ret;\n\n\twdd = &priv->wdd;\n\twdd->info = &asm9260_wdt_ident;\n\twdd->ops = &asm9260_wdt_ops;\n\twdd->min_timeout = 1;\n\twdd->max_timeout = BM_WDTC_MAX(priv->wdt_freq);\n\twdd->parent = dev;\n\n\twatchdog_set_drvdata(wdd, priv);\n\n\t \n\twdd->timeout = ASM9260_WDT_DEFAULT_TIMEOUT;\n\twatchdog_init_timeout(wdd, 0, dev);\n\n\tasm9260_wdt_get_dt_mode(priv);\n\n\tif (priv->mode != HW_RESET)\n\t\tpriv->irq = platform_get_irq(pdev, 0);\n\n\tif (priv->irq > 0) {\n\t\t \n\t\tret = devm_request_irq(dev, priv->irq, asm9260_wdt_irq, 0,\n\t\t\t\t       pdev->name, priv);\n\t\tif (ret < 0)\n\t\t\tdev_warn(dev, \"failed to request IRQ\\n\");\n\t}\n\n\twatchdog_set_restart_priority(wdd, 128);\n\n\twatchdog_stop_on_reboot(wdd);\n\twatchdog_stop_on_unregister(wdd);\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(dev, \"Watchdog enabled (timeout: %d sec, mode: %s)\\n\",\n\t\t wdd->timeout, mode_name[priv->mode]);\n\treturn 0;\n}\n\nstatic const struct of_device_id asm9260_wdt_of_match[] = {\n\t{ .compatible = \"alphascale,asm9260-wdt\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, asm9260_wdt_of_match);\n\nstatic struct platform_driver asm9260_wdt_driver = {\n\t.driver = {\n\t\t.name = \"asm9260-wdt\",\n\t\t.of_match_table\t= asm9260_wdt_of_match,\n\t},\n\t.probe = asm9260_wdt_probe,\n};\nmodule_platform_driver(asm9260_wdt_driver);\n\nMODULE_DESCRIPTION(\"asm9260 WatchDog Timer Driver\");\nMODULE_AUTHOR(\"Oleksij Rempel <linux@rempel-privat.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}