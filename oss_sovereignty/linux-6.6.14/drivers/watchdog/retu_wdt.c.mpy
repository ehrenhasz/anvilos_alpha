{
  "module_name": "retu_wdt.c",
  "hash_id": "b3de2664e2763fed61df89fa1720789e4ed24a58d3fa27ca4b34a6d8733e9b16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/retu_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/devm-helpers.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mfd/retu.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n\n \n#define RETU_WDT_MAX_TIMER\t63\n\nstruct retu_wdt_dev {\n\tstruct retu_dev\t\t*rdev;\n\tstruct device\t\t*dev;\n\tstruct delayed_work\tping_work;\n};\n\n \nstatic void retu_wdt_ping_enable(struct retu_wdt_dev *wdev)\n{\n\tretu_write(wdev->rdev, RETU_REG_WATCHDOG, RETU_WDT_MAX_TIMER);\n\tschedule_delayed_work(&wdev->ping_work,\n\t\t\tround_jiffies_relative(RETU_WDT_MAX_TIMER * HZ / 2));\n}\n\nstatic void retu_wdt_ping_disable(struct retu_wdt_dev *wdev)\n{\n\tretu_write(wdev->rdev, RETU_REG_WATCHDOG, RETU_WDT_MAX_TIMER);\n\tcancel_delayed_work_sync(&wdev->ping_work);\n}\n\nstatic void retu_wdt_ping_work(struct work_struct *work)\n{\n\tstruct retu_wdt_dev *wdev = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct retu_wdt_dev, ping_work);\n\tretu_wdt_ping_enable(wdev);\n}\n\nstatic int retu_wdt_start(struct watchdog_device *wdog)\n{\n\tstruct retu_wdt_dev *wdev = watchdog_get_drvdata(wdog);\n\n\tretu_wdt_ping_disable(wdev);\n\n\treturn retu_write(wdev->rdev, RETU_REG_WATCHDOG, wdog->timeout);\n}\n\nstatic int retu_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct retu_wdt_dev *wdev = watchdog_get_drvdata(wdog);\n\n\tretu_wdt_ping_enable(wdev);\n\n\treturn 0;\n}\n\nstatic int retu_wdt_ping(struct watchdog_device *wdog)\n{\n\tstruct retu_wdt_dev *wdev = watchdog_get_drvdata(wdog);\n\n\treturn retu_write(wdev->rdev, RETU_REG_WATCHDOG, wdog->timeout);\n}\n\nstatic int retu_wdt_set_timeout(struct watchdog_device *wdog,\n\t\t\t\tunsigned int timeout)\n{\n\tstruct retu_wdt_dev *wdev = watchdog_get_drvdata(wdog);\n\n\twdog->timeout = timeout;\n\treturn retu_write(wdev->rdev, RETU_REG_WATCHDOG, wdog->timeout);\n}\n\nstatic const struct watchdog_info retu_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"Retu watchdog\",\n};\n\nstatic const struct watchdog_ops retu_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= retu_wdt_start,\n\t.stop\t\t= retu_wdt_stop,\n\t.ping\t\t= retu_wdt_ping,\n\t.set_timeout\t= retu_wdt_set_timeout,\n};\n\nstatic int retu_wdt_probe(struct platform_device *pdev)\n{\n\tstruct retu_dev *rdev = dev_get_drvdata(pdev->dev.parent);\n\tbool nowayout = WATCHDOG_NOWAYOUT;\n\tstruct watchdog_device *retu_wdt;\n\tstruct retu_wdt_dev *wdev;\n\tint ret;\n\n\tretu_wdt = devm_kzalloc(&pdev->dev, sizeof(*retu_wdt), GFP_KERNEL);\n\tif (!retu_wdt)\n\t\treturn -ENOMEM;\n\n\twdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);\n\tif (!wdev)\n\t\treturn -ENOMEM;\n\n\tretu_wdt->info\t\t= &retu_wdt_info;\n\tretu_wdt->ops\t\t= &retu_wdt_ops;\n\tretu_wdt->timeout\t= RETU_WDT_MAX_TIMER;\n\tretu_wdt->min_timeout\t= 0;\n\tretu_wdt->max_timeout\t= RETU_WDT_MAX_TIMER;\n\tretu_wdt->parent\t= &pdev->dev;\n\n\twatchdog_set_drvdata(retu_wdt, wdev);\n\twatchdog_set_nowayout(retu_wdt, nowayout);\n\n\twdev->rdev\t\t= rdev;\n\twdev->dev\t\t= &pdev->dev;\n\n\tret = devm_delayed_work_autocancel(&pdev->dev, &wdev->ping_work,\n\t\t\t\t\t   retu_wdt_ping_work);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_watchdog_register_device(&pdev->dev, retu_wdt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (nowayout)\n\t\tretu_wdt_ping(retu_wdt);\n\telse\n\t\tretu_wdt_ping_enable(wdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver retu_wdt_driver = {\n\t.probe\t\t= retu_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"retu-wdt\",\n\t},\n};\nmodule_platform_driver(retu_wdt_driver);\n\nMODULE_ALIAS(\"platform:retu-wdt\");\nMODULE_DESCRIPTION(\"Retu watchdog\");\nMODULE_AUTHOR(\"Amit Kucheria\");\nMODULE_AUTHOR(\"Aaro Koskinen <aaro.koskinen@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}