{
  "module_name": "pm8916_wdt.c",
  "hash_id": "f5b3dc2355c9dadd32d51f120a9643681dae383b4ea397da650db152c8630370",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pm8916_wdt.c",
  "human_readable_source": "\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\n#define PON_POFF_REASON1\t\t0x0c\n#define PON_POFF_REASON1_PMIC_WD\tBIT(2)\n#define PON_POFF_REASON2\t\t0x0d\n#define PON_POFF_REASON2_UVLO\t\tBIT(5)\n#define PON_POFF_REASON2_OTST3\t\tBIT(6)\n\n#define PON_INT_RT_STS\t\t\t0x10\n#define PMIC_WD_BARK_STS_BIT\t\tBIT(6)\n\n#define PON_PMIC_WD_RESET_S1_TIMER\t0x54\n#define PON_PMIC_WD_RESET_S2_TIMER\t0x55\n\n#define PON_PMIC_WD_RESET_S2_CTL\t0x56\n#define RESET_TYPE_WARM\t\t\t0x01\n#define RESET_TYPE_SHUTDOWN\t\t0x04\n#define RESET_TYPE_HARD\t\t\t0x07\n\n#define PON_PMIC_WD_RESET_S2_CTL2\t0x57\n#define S2_RESET_EN_BIT\t\t\tBIT(7)\n\n#define PON_PMIC_WD_RESET_PET\t\t0x58\n#define WATCHDOG_PET_BIT\t\tBIT(0)\n\n#define PM8916_WDT_DEFAULT_TIMEOUT\t32\n#define PM8916_WDT_MIN_TIMEOUT\t\t1\n#define PM8916_WDT_MAX_TIMEOUT\t\t127\n\nstruct pm8916_wdt {\n\tstruct regmap *regmap;\n\tstruct watchdog_device wdev;\n\tu32 baseaddr;\n};\n\nstatic int pm8916_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct pm8916_wdt *wdt = watchdog_get_drvdata(wdev);\n\n\treturn regmap_update_bits(wdt->regmap,\n\t\t\t\t  wdt->baseaddr + PON_PMIC_WD_RESET_S2_CTL2,\n\t\t\t\t  S2_RESET_EN_BIT, S2_RESET_EN_BIT);\n}\n\nstatic int pm8916_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct pm8916_wdt *wdt = watchdog_get_drvdata(wdev);\n\n\treturn regmap_update_bits(wdt->regmap,\n\t\t\t\t  wdt->baseaddr + PON_PMIC_WD_RESET_S2_CTL2,\n\t\t\t\t  S2_RESET_EN_BIT, 0);\n}\n\nstatic int pm8916_wdt_ping(struct watchdog_device *wdev)\n{\n\tstruct pm8916_wdt *wdt = watchdog_get_drvdata(wdev);\n\n\treturn regmap_write(wdt->regmap, wdt->baseaddr + PON_PMIC_WD_RESET_PET,\n\t\t\t    WATCHDOG_PET_BIT);\n}\n\nstatic int pm8916_wdt_configure_timers(struct watchdog_device *wdev)\n{\n\tstruct pm8916_wdt *wdt = watchdog_get_drvdata(wdev);\n\tint err;\n\n\terr = regmap_write(wdt->regmap,\n\t\t\t   wdt->baseaddr + PON_PMIC_WD_RESET_S1_TIMER,\n\t\t\t   wdev->timeout - wdev->pretimeout);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_write(wdt->regmap,\n\t\t\t    wdt->baseaddr + PON_PMIC_WD_RESET_S2_TIMER,\n\t\t\t    wdev->pretimeout);\n}\n\nstatic int pm8916_wdt_set_timeout(struct watchdog_device *wdev,\n\t\t\t\t  unsigned int timeout)\n{\n\twdev->timeout = timeout;\n\n\treturn pm8916_wdt_configure_timers(wdev);\n}\n\nstatic int pm8916_wdt_set_pretimeout(struct watchdog_device *wdev,\n\t\t\t\t     unsigned int pretimeout)\n{\n\twdev->pretimeout = pretimeout;\n\n\treturn pm8916_wdt_configure_timers(wdev);\n}\n\nstatic irqreturn_t pm8916_wdt_isr(int irq, void *arg)\n{\n\tstruct pm8916_wdt *wdt = arg;\n\tint err, sts;\n\n\terr = regmap_read(wdt->regmap, wdt->baseaddr + PON_INT_RT_STS, &sts);\n\tif (err)\n\t\treturn IRQ_HANDLED;\n\n\tif (sts & PMIC_WD_BARK_STS_BIT)\n\t\twatchdog_notify_pretimeout(&wdt->wdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct watchdog_info pm8916_wdt_ident = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE |\n\t\t   WDIOF_OVERHEAT | WDIOF_CARDRESET | WDIOF_POWERUNDER,\n\t.identity = \"QCOM PM8916 PON WDT\",\n};\n\nstatic const struct watchdog_info pm8916_wdt_pt_ident = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE |\n\t\t   WDIOF_OVERHEAT | WDIOF_CARDRESET | WDIOF_POWERUNDER |\n\t\t   WDIOF_PRETIMEOUT,\n\t.identity = \"QCOM PM8916 PON WDT\",\n};\n\nstatic const struct watchdog_ops pm8916_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = pm8916_wdt_start,\n\t.stop = pm8916_wdt_stop,\n\t.ping = pm8916_wdt_ping,\n\t.set_timeout = pm8916_wdt_set_timeout,\n\t.set_pretimeout = pm8916_wdt_set_pretimeout,\n};\n\nstatic int pm8916_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pm8916_wdt *wdt;\n\tstruct device *parent;\n\tunsigned int val;\n\tint err, irq;\n\tu8 poff[2];\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tparent = dev->parent;\n\n\t \n\twdt->regmap = dev_get_regmap(parent->parent, NULL);\n\tif (!wdt->regmap) {\n\t\tdev_err(dev, \"failed to locate regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = device_property_read_u32(parent, \"reg\", &wdt->baseaddr);\n\tif (err) {\n\t\tdev_err(dev, \"failed to get pm8916-pon address\\n\");\n\t\treturn err;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq > 0) {\n\t\terr = devm_request_irq(dev, irq, pm8916_wdt_isr, 0,\n\t\t\t\t       \"pm8916_wdt\", wdt);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\twdt->wdev.info = &pm8916_wdt_pt_ident;\n\t} else {\n\t\tif (irq == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\twdt->wdev.info = &pm8916_wdt_ident;\n\t}\n\n\terr = regmap_bulk_read(wdt->regmap, wdt->baseaddr + PON_POFF_REASON1,\n\t\t\t       &poff, ARRAY_SIZE(poff));\n\tif (err) {\n\t\tdev_err(dev, \"failed to read POFF reason: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdev_dbg(dev, \"POFF reason: %#x %#x\\n\", poff[0], poff[1]);\n\tif (poff[0] & PON_POFF_REASON1_PMIC_WD)\n\t\twdt->wdev.bootstatus |= WDIOF_CARDRESET;\n\tif (poff[1] & PON_POFF_REASON2_UVLO)\n\t\twdt->wdev.bootstatus |= WDIOF_POWERUNDER;\n\tif (poff[1] & PON_POFF_REASON2_OTST3)\n\t\twdt->wdev.bootstatus |= WDIOF_OVERHEAT;\n\n\terr = regmap_read(wdt->regmap, wdt->baseaddr + PON_PMIC_WD_RESET_S2_CTL2,\n\t\t\t  &val);\n\tif (err)  {\n\t\tdev_err(dev, \"failed to check if watchdog is active: %d\\n\", err);\n\t\treturn err;\n\t}\n\tif (val & S2_RESET_EN_BIT)\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdev.status);\n\n\t \n\terr = regmap_write(wdt->regmap,\n\t\t\t   wdt->baseaddr + PON_PMIC_WD_RESET_S2_CTL,\n\t\t\t   RESET_TYPE_HARD);\n\tif (err) {\n\t\tdev_err(dev, \"failed configure watchdog\\n\");\n\t\treturn err;\n\t}\n\n\twdt->wdev.ops = &pm8916_wdt_ops,\n\twdt->wdev.parent = dev;\n\twdt->wdev.min_timeout = PM8916_WDT_MIN_TIMEOUT;\n\twdt->wdev.max_timeout = PM8916_WDT_MAX_TIMEOUT;\n\twdt->wdev.timeout = PM8916_WDT_DEFAULT_TIMEOUT;\n\twdt->wdev.pretimeout = 0;\n\twatchdog_set_drvdata(&wdt->wdev, wdt);\n\tplatform_set_drvdata(pdev, wdt);\n\n\twatchdog_init_timeout(&wdt->wdev, 0, dev);\n\tpm8916_wdt_configure_timers(&wdt->wdev);\n\n\treturn devm_watchdog_register_device(dev, &wdt->wdev);\n}\n\nstatic int __maybe_unused pm8916_wdt_suspend(struct device *dev)\n{\n\tstruct pm8916_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdev))\n\t\treturn pm8916_wdt_stop(&wdt->wdev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pm8916_wdt_resume(struct device *dev)\n{\n\tstruct pm8916_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdev))\n\t\treturn pm8916_wdt_start(&wdt->wdev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pm8916_wdt_pm_ops, pm8916_wdt_suspend,\n\t\t\t pm8916_wdt_resume);\n\nstatic const struct of_device_id pm8916_wdt_id_table[] = {\n\t{ .compatible = \"qcom,pm8916-wdt\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pm8916_wdt_id_table);\n\nstatic struct platform_driver pm8916_wdt_driver = {\n\t.probe = pm8916_wdt_probe,\n\t.driver = {\n\t\t.name = \"pm8916-wdt\",\n\t\t.of_match_table = pm8916_wdt_id_table,\n\t\t.pm = &pm8916_wdt_pm_ops,\n\t},\n};\nmodule_platform_driver(pm8916_wdt_driver);\n\nMODULE_AUTHOR(\"Loic Poulain <loic.poulain@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm pm8916 watchdog driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}