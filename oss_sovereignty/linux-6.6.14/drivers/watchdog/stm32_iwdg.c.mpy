{
  "module_name": "stm32_iwdg.c",
  "hash_id": "8edee9eeadd90cfb55038c66d567758179757089f704dc7b835bb68c2f1c1458",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/stm32_iwdg.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n \n#define IWDG_KR\t\t0x00  \n#define IWDG_PR\t\t0x04  \n#define IWDG_RLR\t0x08  \n#define IWDG_SR\t\t0x0C  \n#define IWDG_WINR\t0x10  \n\n \n#define KR_KEY_RELOAD\t0xAAAA  \n#define KR_KEY_ENABLE\t0xCCCC  \n#define KR_KEY_EWA\t0x5555  \n#define KR_KEY_DWA\t0x0000  \n\n \n#define PR_SHIFT\t2\n#define PR_MIN\t\tBIT(PR_SHIFT)\n\n \n#define RLR_MIN\t\t0x2\t\t \n#define RLR_MAX\t\tGENMASK(11, 0)\t \n\n \n#define SR_PVU\tBIT(0)  \n#define SR_RVU\tBIT(1)  \n\n \n#define TIMEOUT_US\t100000\n#define SLEEP_US\t1000\n\nstruct stm32_iwdg_data {\n\tbool has_pclk;\n\tu32 max_prescaler;\n};\n\nstatic const struct stm32_iwdg_data stm32_iwdg_data = {\n\t.has_pclk = false,\n\t.max_prescaler = 256,\n};\n\nstatic const struct stm32_iwdg_data stm32mp1_iwdg_data = {\n\t.has_pclk = true,\n\t.max_prescaler = 1024,\n};\n\nstruct stm32_iwdg {\n\tstruct watchdog_device\twdd;\n\tconst struct stm32_iwdg_data *data;\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk_lsi;\n\tstruct clk\t\t*clk_pclk;\n\tunsigned int\t\trate;\n};\n\nstatic inline u32 reg_read(void __iomem *base, u32 reg)\n{\n\treturn readl_relaxed(base + reg);\n}\n\nstatic inline void reg_write(void __iomem *base, u32 reg, u32 val)\n{\n\twritel_relaxed(val, base + reg);\n}\n\nstatic int stm32_iwdg_start(struct watchdog_device *wdd)\n{\n\tstruct stm32_iwdg *wdt = watchdog_get_drvdata(wdd);\n\tu32 tout, presc, iwdg_rlr, iwdg_pr, iwdg_sr;\n\tint ret;\n\n\tdev_dbg(wdd->parent, \"%s\\n\", __func__);\n\n\ttout = clamp_t(unsigned int, wdd->timeout,\n\t\t       wdd->min_timeout, wdd->max_hw_heartbeat_ms / 1000);\n\n\tpresc = DIV_ROUND_UP(tout * wdt->rate, RLR_MAX + 1);\n\n\t \n\tpresc = roundup_pow_of_two(presc);\n\tiwdg_pr = presc <= 1 << PR_SHIFT ? 0 : ilog2(presc) - PR_SHIFT;\n\tiwdg_rlr = ((tout * wdt->rate) / presc) - 1;\n\n\t \n\treg_write(wdt->regs, IWDG_KR, KR_KEY_EWA);\n\n\t \n\treg_write(wdt->regs, IWDG_PR, iwdg_pr);\n\treg_write(wdt->regs, IWDG_RLR, iwdg_rlr);\n\treg_write(wdt->regs, IWDG_KR, KR_KEY_ENABLE);\n\n\t \n\tret = readl_relaxed_poll_timeout(wdt->regs + IWDG_SR, iwdg_sr,\n\t\t\t\t\t !(iwdg_sr & (SR_PVU | SR_RVU)),\n\t\t\t\t\t SLEEP_US, TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(wdd->parent, \"Fail to set prescaler, reload regs\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treg_write(wdt->regs, IWDG_KR, KR_KEY_RELOAD);\n\n\treturn 0;\n}\n\nstatic int stm32_iwdg_ping(struct watchdog_device *wdd)\n{\n\tstruct stm32_iwdg *wdt = watchdog_get_drvdata(wdd);\n\n\tdev_dbg(wdd->parent, \"%s\\n\", __func__);\n\n\t \n\treg_write(wdt->regs, IWDG_KR, KR_KEY_RELOAD);\n\n\treturn 0;\n}\n\nstatic int stm32_iwdg_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\tdev_dbg(wdd->parent, \"%s timeout: %d sec\\n\", __func__, timeout);\n\n\twdd->timeout = timeout;\n\n\tif (watchdog_active(wdd))\n\t\treturn stm32_iwdg_start(wdd);\n\n\treturn 0;\n}\n\nstatic void stm32_clk_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int stm32_iwdg_clk_init(struct platform_device *pdev,\n\t\t\t       struct stm32_iwdg *wdt)\n{\n\tstruct device *dev = &pdev->dev;\n\tu32 ret;\n\n\twdt->clk_lsi = devm_clk_get(dev, \"lsi\");\n\tif (IS_ERR(wdt->clk_lsi))\n\t\treturn dev_err_probe(dev, PTR_ERR(wdt->clk_lsi), \"Unable to get lsi clock\\n\");\n\n\t \n\tif (wdt->data->has_pclk) {\n\t\twdt->clk_pclk = devm_clk_get(dev, \"pclk\");\n\t\tif (IS_ERR(wdt->clk_pclk))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(wdt->clk_pclk),\n\t\t\t\t\t     \"Unable to get pclk clock\\n\");\n\n\t\tret = clk_prepare_enable(wdt->clk_pclk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to prepare pclk clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = devm_add_action_or_reset(dev,\n\t\t\t\t\t       stm32_clk_disable_unprepare,\n\t\t\t\t\t       wdt->clk_pclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(wdt->clk_lsi);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to prepare lsi clock\\n\");\n\t\treturn ret;\n\t}\n\tret = devm_add_action_or_reset(dev, stm32_clk_disable_unprepare,\n\t\t\t\t       wdt->clk_lsi);\n\tif (ret)\n\t\treturn ret;\n\n\twdt->rate = clk_get_rate(wdt->clk_lsi);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info stm32_iwdg_info = {\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_MAGICCLOSE |\n\t\t\t  WDIOF_KEEPALIVEPING,\n\t.identity\t= \"STM32 Independent Watchdog\",\n};\n\nstatic const struct watchdog_ops stm32_iwdg_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= stm32_iwdg_start,\n\t.ping\t\t= stm32_iwdg_ping,\n\t.set_timeout\t= stm32_iwdg_set_timeout,\n};\n\nstatic const struct of_device_id stm32_iwdg_of_match[] = {\n\t{ .compatible = \"st,stm32-iwdg\", .data = &stm32_iwdg_data },\n\t{ .compatible = \"st,stm32mp1-iwdg\", .data = &stm32mp1_iwdg_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, stm32_iwdg_of_match);\n\nstatic int stm32_iwdg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct stm32_iwdg *wdt;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->data = of_device_get_match_data(&pdev->dev);\n\tif (!wdt->data)\n\t\treturn -ENODEV;\n\n\t \n\twdt->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->regs))\n\t\treturn PTR_ERR(wdt->regs);\n\n\tret = stm32_iwdg_clk_init(pdev, wdt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twdd = &wdt->wdd;\n\twdd->parent = dev;\n\twdd->info = &stm32_iwdg_info;\n\twdd->ops = &stm32_iwdg_ops;\n\twdd->min_timeout = DIV_ROUND_UP((RLR_MIN + 1) * PR_MIN, wdt->rate);\n\twdd->max_hw_heartbeat_ms = ((RLR_MAX + 1) * wdt->data->max_prescaler *\n\t\t\t\t    1000) / wdt->rate;\n\n\twatchdog_set_drvdata(wdd, wdt);\n\twatchdog_set_nowayout(wdd, WATCHDOG_NOWAYOUT);\n\twatchdog_init_timeout(wdd, 0, dev);\n\n\t \n\tif (IS_ENABLED(CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED)) {\n\t\tret = stm32_iwdg_start(wdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t}\n\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\treturn 0;\n}\n\nstatic struct platform_driver stm32_iwdg_driver = {\n\t.probe\t\t= stm32_iwdg_probe,\n\t.driver = {\n\t\t.name\t= \"iwdg\",\n\t\t.of_match_table = stm32_iwdg_of_match,\n\t},\n};\nmodule_platform_driver(stm32_iwdg_driver);\n\nMODULE_AUTHOR(\"Yannick Fertre <yannick.fertre@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 Independent Watchdog Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}