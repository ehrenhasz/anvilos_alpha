{
  "module_name": "wafer5823wdt.c",
  "hash_id": "6d099b40f109facccc71444140e6fc164cd2ea3437d86749b2f1655bae272a52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/wafer5823wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#define WATCHDOG_NAME \"Wafer 5823 WDT\"\n#define PFX WATCHDOG_NAME \": \"\n#define WD_TIMO 60\t\t\t \n\nstatic unsigned long wafwdt_is_open;\nstatic char expect_close;\nstatic DEFINE_SPINLOCK(wafwdt_lock);\n\n \n\nstatic int wdt_stop = 0x843;\nstatic int wdt_start = 0x443;\n\nstatic int timeout = WD_TIMO;   \nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\t\"Watchdog timeout in seconds. 1 <= timeout <= 255, default=\"\n\t\t\t\t__MODULE_STRING(WD_TIMO) \".\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic void wafwdt_ping(void)\n{\n\t \n\tspin_lock(&wafwdt_lock);\n\tinb_p(wdt_stop);\n\tinb_p(wdt_start);\n\tspin_unlock(&wafwdt_lock);\n}\n\nstatic void wafwdt_start(void)\n{\n\t \n\toutb_p(timeout, wdt_start);\n\tinb_p(wdt_start);\n}\n\nstatic void wafwdt_stop(void)\n{\n\t \n\tinb_p(wdt_stop);\n}\n\nstatic ssize_t wafwdt_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\t \n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\t \n\t\t\tfor (i = 0; i != count; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\t\t \n\t\twafwdt_ping();\n\t}\n\treturn count;\n}\n\nstatic long wafwdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint new_timeout;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\n\t\t\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.firmware_version = 1,\n\t\t.identity = \"Wafer 5823 WDT\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint options, retval = -EINVAL;\n\n\t\tif (get_user(options, p))\n\t\t\treturn -EFAULT;\n\n\t\tif (options & WDIOS_DISABLECARD) {\n\t\t\twafwdt_stop();\n\t\t\tretval = 0;\n\t\t}\n\n\t\tif (options & WDIOS_ENABLECARD) {\n\t\t\twafwdt_start();\n\t\t\tretval = 0;\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tcase WDIOC_KEEPALIVE:\n\t\twafwdt_ping();\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_timeout, p))\n\t\t\treturn -EFAULT;\n\t\tif ((new_timeout < 1) || (new_timeout > 255))\n\t\t\treturn -EINVAL;\n\t\ttimeout = new_timeout;\n\t\twafwdt_stop();\n\t\twafwdt_start();\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(timeout, p);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic int wafwdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &wafwdt_is_open))\n\t\treturn -EBUSY;\n\n\t \n\twafwdt_start();\n\treturn stream_open(inode, file);\n}\n\nstatic int wafwdt_close(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42)\n\t\twafwdt_stop();\n\telse {\n\t\tpr_crit(\"WDT device closed unexpectedly.  WDT will not stop!\\n\");\n\t\twafwdt_ping();\n\t}\n\tclear_bit(0, &wafwdt_is_open);\n\texpect_close = 0;\n\treturn 0;\n}\n\n \n\nstatic int wafwdt_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t\t\t\t\t\tvoid *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\twafwdt_stop();\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic const struct file_operations wafwdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= wafwdt_write,\n\t.unlocked_ioctl\t= wafwdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= wafwdt_open,\n\t.release\t= wafwdt_close,\n};\n\nstatic struct miscdevice wafwdt_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &wafwdt_fops,\n};\n\n \n\nstatic struct notifier_block wafwdt_notifier = {\n\t.notifier_call = wafwdt_notify_sys,\n};\n\nstatic int __init wafwdt_init(void)\n{\n\tint ret;\n\n\tpr_info(\"WDT driver for Wafer 5823 single board computer initialising\\n\");\n\n\tif (timeout < 1 || timeout > 255) {\n\t\ttimeout = WD_TIMO;\n\t\tpr_info(\"timeout value must be 1 <= x <= 255, using %d\\n\",\n\t\t\ttimeout);\n\t}\n\n\tif (wdt_stop != wdt_start) {\n\t\tif (!request_region(wdt_stop, 1, \"Wafer 5823 WDT\")) {\n\t\t\tpr_err(\"I/O address 0x%04x already in use\\n\", wdt_stop);\n\t\t\tret = -EIO;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (!request_region(wdt_start, 1, \"Wafer 5823 WDT\")) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\", wdt_start);\n\t\tret = -EIO;\n\t\tgoto error2;\n\t}\n\n\tret = register_reboot_notifier(&wafwdt_notifier);\n\tif (ret != 0) {\n\t\tpr_err(\"cannot register reboot notifier (err=%d)\\n\", ret);\n\t\tgoto error3;\n\t}\n\n\tret = misc_register(&wafwdt_miscdev);\n\tif (ret != 0) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, ret);\n\t\tgoto error4;\n\t}\n\n\tpr_info(\"initialized. timeout=%d sec (nowayout=%d)\\n\",\n\t\ttimeout, nowayout);\n\n\treturn ret;\nerror4:\n\tunregister_reboot_notifier(&wafwdt_notifier);\nerror3:\n\trelease_region(wdt_start, 1);\nerror2:\n\tif (wdt_stop != wdt_start)\n\t\trelease_region(wdt_stop, 1);\nerror:\n\treturn ret;\n}\n\nstatic void __exit wafwdt_exit(void)\n{\n\tmisc_deregister(&wafwdt_miscdev);\n\tunregister_reboot_notifier(&wafwdt_notifier);\n\tif (wdt_stop != wdt_start)\n\t\trelease_region(wdt_stop, 1);\n\trelease_region(wdt_start, 1);\n}\n\nmodule_init(wafwdt_init);\nmodule_exit(wafwdt_exit);\n\nMODULE_AUTHOR(\"Justin Cormack\");\nMODULE_DESCRIPTION(\"ICP Wafer 5823 Single Board Computer WDT driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}