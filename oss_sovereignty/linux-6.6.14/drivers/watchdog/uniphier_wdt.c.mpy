{
  "module_name": "uniphier_wdt.c",
  "hash_id": "6b8f00a80cd7f038193d32a992ad86db3656e2de001f28009a36787bcd6f505e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/uniphier_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\n \n#define WDTTIMSET\t\t\t0x3004\n#define   WDTTIMSET_PERIOD_MASK\t\t(0xf << 0)\n#define   WDTTIMSET_PERIOD_1_SEC\t(0x3 << 0)\n\n \n#define WDTRSTSEL\t\t\t0x3008\n#define   WDTRSTSEL_RSTSEL_MASK\t\t(0x3 << 0)\n#define   WDTRSTSEL_RSTSEL_BOTH\t\t(0x0 << 0)\n#define   WDTRSTSEL_RSTSEL_IRQ_ONLY\t(0x2 << 0)\n\n \n#define WDTCTRL\t\t\t\t0x300c\n#define   WDTCTRL_STATUS\t\tBIT(8)\n#define   WDTCTRL_CLEAR\t\t\tBIT(1)\n#define   WDTCTRL_ENABLE\t\tBIT(0)\n\n#define SEC_TO_WDTTIMSET_PRD(sec) \\\n\t\t(ilog2(sec) + WDTTIMSET_PERIOD_1_SEC)\n\n#define WDTST_TIMEOUT\t\t\t1000  \n\n#define WDT_DEFAULT_TIMEOUT\t\t64    \n#define WDT_PERIOD_MIN\t\t\t1\n#define WDT_PERIOD_MAX\t\t\t128\n\nstatic unsigned int timeout = 0;\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\nstruct uniphier_wdt_dev {\n\tstruct watchdog_device wdt_dev;\n\tstruct regmap\t*regmap;\n};\n\n \nstatic int uniphier_watchdog_ping(struct watchdog_device *w)\n{\n\tstruct uniphier_wdt_dev *wdev = watchdog_get_drvdata(w);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_write_bits(wdev->regmap, WDTCTRL,\n\t\t\t\tWDTCTRL_CLEAR, WDTCTRL_CLEAR);\n\tif (!ret)\n\t\t \n\t\tret = regmap_read_poll_timeout(wdev->regmap, WDTCTRL, val,\n\t\t\t\t\t       (val & WDTCTRL_STATUS),\n\t\t\t\t\t       0, WDTST_TIMEOUT);\n\n\treturn ret;\n}\n\nstatic int __uniphier_watchdog_start(struct regmap *regmap, unsigned int sec)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(regmap, WDTCTRL, val,\n\t\t\t\t       !(val & WDTCTRL_STATUS),\n\t\t\t\t       0, WDTST_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(regmap, WDTTIMSET,\n\t\t\t   SEC_TO_WDTTIMSET_PRD(sec));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(regmap, WDTCTRL, WDTCTRL_ENABLE | WDTCTRL_CLEAR);\n\tif (!ret)\n\t\t \n\t\tret = regmap_read_poll_timeout(regmap, WDTCTRL, val,\n\t\t\t\t\t       (val & WDTCTRL_STATUS),\n\t\t\t\t\t       0, WDTST_TIMEOUT);\n\n\treturn ret;\n}\n\nstatic int __uniphier_watchdog_stop(struct regmap *regmap)\n{\n\t \n\treturn regmap_write_bits(regmap, WDTCTRL, WDTCTRL_ENABLE, 0);\n}\n\nstatic int __uniphier_watchdog_restart(struct regmap *regmap, unsigned int sec)\n{\n\tint ret;\n\n\tret = __uniphier_watchdog_stop(regmap);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __uniphier_watchdog_start(regmap, sec);\n}\n\nstatic int uniphier_watchdog_start(struct watchdog_device *w)\n{\n\tstruct uniphier_wdt_dev *wdev = watchdog_get_drvdata(w);\n\tunsigned int tmp_timeout;\n\n\ttmp_timeout = roundup_pow_of_two(w->timeout);\n\n\treturn __uniphier_watchdog_start(wdev->regmap, tmp_timeout);\n}\n\nstatic int uniphier_watchdog_stop(struct watchdog_device *w)\n{\n\tstruct uniphier_wdt_dev *wdev = watchdog_get_drvdata(w);\n\n\treturn __uniphier_watchdog_stop(wdev->regmap);\n}\n\nstatic int uniphier_watchdog_set_timeout(struct watchdog_device *w,\n\t\t\t\t\t unsigned int t)\n{\n\tstruct uniphier_wdt_dev *wdev = watchdog_get_drvdata(w);\n\tunsigned int tmp_timeout;\n\tint ret;\n\n\ttmp_timeout = roundup_pow_of_two(t);\n\tif (tmp_timeout == w->timeout)\n\t\treturn 0;\n\n\tif (watchdog_active(w)) {\n\t\tret = __uniphier_watchdog_restart(wdev->regmap, tmp_timeout);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tw->timeout = tmp_timeout;\n\n\treturn 0;\n}\n\n \nstatic const struct watchdog_info uniphier_wdt_info = {\n\t.identity\t= \"uniphier-wdt\",\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE |\n\t\t\t  WDIOF_OVERHEAT,\n};\n\nstatic const struct watchdog_ops uniphier_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= uniphier_watchdog_start,\n\t.stop\t\t= uniphier_watchdog_stop,\n\t.ping\t\t= uniphier_watchdog_ping,\n\t.set_timeout\t= uniphier_watchdog_set_timeout,\n};\n\nstatic int uniphier_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_wdt_dev *wdev;\n\tstruct regmap *regmap;\n\tstruct device_node *parent;\n\tint ret;\n\n\twdev = devm_kzalloc(dev, sizeof(*wdev), GFP_KERNEL);\n\tif (!wdev)\n\t\treturn -ENOMEM;\n\n\tparent = of_get_parent(dev->of_node);  \n\tregmap = syscon_node_to_regmap(parent);\n\tof_node_put(parent);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\twdev->regmap = regmap;\n\twdev->wdt_dev.info = &uniphier_wdt_info;\n\twdev->wdt_dev.ops = &uniphier_wdt_ops;\n\twdev->wdt_dev.max_timeout = WDT_PERIOD_MAX;\n\twdev->wdt_dev.min_timeout = WDT_PERIOD_MIN;\n\twdev->wdt_dev.timeout = WDT_DEFAULT_TIMEOUT;\n\twdev->wdt_dev.parent = dev;\n\n\twatchdog_init_timeout(&wdev->wdt_dev, timeout, dev);\n\twatchdog_set_nowayout(&wdev->wdt_dev, nowayout);\n\twatchdog_stop_on_reboot(&wdev->wdt_dev);\n\n\twatchdog_set_drvdata(&wdev->wdt_dev, wdev);\n\n\tuniphier_watchdog_stop(&wdev->wdt_dev);\n\tret = regmap_write(wdev->regmap, WDTRSTSEL, WDTRSTSEL_RSTSEL_BOTH);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_watchdog_register_device(dev, &wdev->wdt_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"watchdog driver (timeout=%d sec, nowayout=%d)\\n\",\n\t\t wdev->wdt_dev.timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id uniphier_wdt_dt_ids[] = {\n\t{ .compatible = \"socionext,uniphier-wdt\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_wdt_dt_ids);\n\nstatic struct platform_driver uniphier_wdt_driver = {\n\t.probe\t\t= uniphier_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"uniphier-wdt\",\n\t\t.of_match_table\t= uniphier_wdt_dt_ids,\n\t},\n};\n\nmodule_platform_driver(uniphier_wdt_driver);\n\nmodule_param(timeout, uint, 0000);\nMODULE_PARM_DESC(timeout,\n\t\"Watchdog timeout seconds in power of 2. (0 < timeout < 128, default=\"\n\t\t\t\t__MODULE_STRING(WDT_DEFAULT_TIMEOUT) \")\");\n\nmodule_param(nowayout, bool, 0000);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nMODULE_AUTHOR(\"Keiji Hayashibara <hayashibara.keiji@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier Watchdog Device Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}