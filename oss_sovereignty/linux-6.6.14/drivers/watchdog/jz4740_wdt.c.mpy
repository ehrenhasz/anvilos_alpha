{
  "module_name": "jz4740_wdt.c",
  "hash_id": "2383328cdf40971eff731e7df8832e9b9a3a8d924577eb93d0cb87424ca16bfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/jz4740_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/ingenic-tcu.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define DEFAULT_HEARTBEAT 5\n#define MAX_HEARTBEAT     2048\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic unsigned int heartbeat = DEFAULT_HEARTBEAT;\nmodule_param(heartbeat, uint, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\t\"Watchdog heartbeat period in seconds from 1 to \"\n\t\t__MODULE_STRING(MAX_HEARTBEAT) \", default \"\n\t\t__MODULE_STRING(DEFAULT_HEARTBEAT));\n\nstruct jz4740_wdt_drvdata {\n\tstruct watchdog_device wdt;\n\tstruct regmap *map;\n\tstruct clk *clk;\n\tunsigned long clk_rate;\n};\n\nstatic int jz4740_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct jz4740_wdt_drvdata *drvdata = watchdog_get_drvdata(wdt_dev);\n\n\tregmap_write(drvdata->map, TCU_REG_WDT_TCNT, 0);\n\n\treturn 0;\n}\n\nstatic int jz4740_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t    unsigned int new_timeout)\n{\n\tstruct jz4740_wdt_drvdata *drvdata = watchdog_get_drvdata(wdt_dev);\n\tu16 timeout_value = (u16)(drvdata->clk_rate * new_timeout);\n\tunsigned int tcer;\n\n\tregmap_read(drvdata->map, TCU_REG_WDT_TCER, &tcer);\n\tregmap_write(drvdata->map, TCU_REG_WDT_TCER, 0);\n\n\tregmap_write(drvdata->map, TCU_REG_WDT_TDR, timeout_value);\n\tregmap_write(drvdata->map, TCU_REG_WDT_TCNT, 0);\n\n\tif (tcer & TCU_WDT_TCER_TCEN)\n\t\tregmap_write(drvdata->map, TCU_REG_WDT_TCER, TCU_WDT_TCER_TCEN);\n\n\twdt_dev->timeout = new_timeout;\n\treturn 0;\n}\n\nstatic int jz4740_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tstruct jz4740_wdt_drvdata *drvdata = watchdog_get_drvdata(wdt_dev);\n\tunsigned int tcer;\n\tint ret;\n\n\tret = clk_prepare_enable(drvdata->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_read(drvdata->map, TCU_REG_WDT_TCER, &tcer);\n\n\tjz4740_wdt_set_timeout(wdt_dev, wdt_dev->timeout);\n\n\t \n\tif (!(tcer & TCU_WDT_TCER_TCEN))\n\t\tregmap_write(drvdata->map, TCU_REG_WDT_TCER, TCU_WDT_TCER_TCEN);\n\n\treturn 0;\n}\n\nstatic int jz4740_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct jz4740_wdt_drvdata *drvdata = watchdog_get_drvdata(wdt_dev);\n\n\tregmap_write(drvdata->map, TCU_REG_WDT_TCER, 0);\n\tclk_disable_unprepare(drvdata->clk);\n\n\treturn 0;\n}\n\nstatic int jz4740_wdt_restart(struct watchdog_device *wdt_dev,\n\t\t\t      unsigned long action, void *data)\n{\n\twdt_dev->timeout = 0;\n\tjz4740_wdt_start(wdt_dev);\n\treturn 0;\n}\n\nstatic const struct watchdog_info jz4740_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"jz4740 Watchdog\",\n};\n\nstatic const struct watchdog_ops jz4740_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = jz4740_wdt_start,\n\t.stop = jz4740_wdt_stop,\n\t.ping = jz4740_wdt_ping,\n\t.set_timeout = jz4740_wdt_set_timeout,\n\t.restart = jz4740_wdt_restart,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id jz4740_wdt_of_matches[] = {\n\t{ .compatible = \"ingenic,jz4740-watchdog\", },\n\t{ .compatible = \"ingenic,jz4780-watchdog\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, jz4740_wdt_of_matches);\n#endif\n\nstatic int jz4740_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct jz4740_wdt_drvdata *drvdata;\n\tstruct watchdog_device *jz4740_wdt;\n\tlong rate;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(struct jz4740_wdt_drvdata),\n\t\t\t       GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->clk = devm_clk_get(&pdev->dev, \"wdt\");\n\tif (IS_ERR(drvdata->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot find WDT clock\\n\");\n\t\treturn PTR_ERR(drvdata->clk);\n\t}\n\n\t \n\trate = clk_round_rate(drvdata->clk, 1);\n\tif (rate < 0)\n\t\treturn rate;\n\n\tret = clk_set_rate(drvdata->clk, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tdrvdata->clk_rate = rate;\n\tjz4740_wdt = &drvdata->wdt;\n\tjz4740_wdt->info = &jz4740_wdt_info;\n\tjz4740_wdt->ops = &jz4740_wdt_ops;\n\tjz4740_wdt->min_timeout = 1;\n\tjz4740_wdt->max_timeout = 0xffff / rate;\n\tjz4740_wdt->timeout = clamp(heartbeat,\n\t\t\t\t    jz4740_wdt->min_timeout,\n\t\t\t\t    jz4740_wdt->max_timeout);\n\tjz4740_wdt->parent = dev;\n\twatchdog_set_nowayout(jz4740_wdt, nowayout);\n\twatchdog_set_drvdata(jz4740_wdt, drvdata);\n\n\tdrvdata->map = device_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(drvdata->map)) {\n\t\tdev_err(dev, \"regmap not found\\n\");\n\t\treturn PTR_ERR(drvdata->map);\n\t}\n\n\treturn devm_watchdog_register_device(dev, &drvdata->wdt);\n}\n\nstatic struct platform_driver jz4740_wdt_driver = {\n\t.probe = jz4740_wdt_probe,\n\t.driver = {\n\t\t.name = \"jz4740-wdt\",\n\t\t.of_match_table = of_match_ptr(jz4740_wdt_of_matches),\n\t},\n};\n\nmodule_platform_driver(jz4740_wdt_driver);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_DESCRIPTION(\"jz4740 Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:jz4740-wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}