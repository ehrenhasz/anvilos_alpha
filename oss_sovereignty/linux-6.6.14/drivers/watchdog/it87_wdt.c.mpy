{
  "module_name": "it87_wdt.c",
  "hash_id": "8a8245f1b3f2c81bdeb9e38cecfb6e4bc476900a731f7af2ff2639cb2364b16a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/it87_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#define WATCHDOG_NAME\t\t\"IT87 WDT\"\n\n \n#define DEFAULT_TIMEOUT\t\t60\n#define DEFAULT_TESTMODE\t0\n#define DEFAULT_NOWAYOUT\tWATCHDOG_NOWAYOUT\n\n \n#define REG\t\t0x2e\n#define VAL\t\t0x2f\n\n \n#define GPIO\t\t0x07\n\n \n#define LDNREG\t\t0x07\n#define CHIPID\t\t0x20\n#define CHIPREV\t\t0x22\n\n \n#define NO_DEV_ID\t0xffff\n#define IT8607_ID\t0x8607\n#define IT8620_ID\t0x8620\n#define IT8622_ID\t0x8622\n#define IT8625_ID\t0x8625\n#define IT8628_ID\t0x8628\n#define IT8655_ID\t0x8655\n#define IT8665_ID\t0x8665\n#define IT8686_ID\t0x8686\n#define IT8702_ID\t0x8702\n#define IT8705_ID\t0x8705\n#define IT8712_ID\t0x8712\n#define IT8716_ID\t0x8716\n#define IT8718_ID\t0x8718\n#define IT8720_ID\t0x8720\n#define IT8721_ID\t0x8721\n#define IT8726_ID\t0x8726\t \n#define IT8728_ID\t0x8728\n#define IT8772_ID\t0x8772\n#define IT8783_ID\t0x8783\n#define IT8784_ID\t0x8784\n#define IT8786_ID\t0x8786\n\n \n#define WDTCTRL\t\t0x71\n#define WDTCFG\t\t0x72\n#define WDTVALLSB\t0x73\n#define WDTVALMSB\t0x74\n\n \n#define WDT_TOV1\t0x80\n#define WDT_KRST\t0x40\n#define WDT_TOVE\t0x20\n#define WDT_PWROK\t0x10  \n#define WDT_INT_MASK\t0x0f\n\nstatic unsigned int max_units, chip_type;\n\nstatic unsigned int timeout = DEFAULT_TIMEOUT;\nstatic int testmode = DEFAULT_TESTMODE;\nstatic bool nowayout = DEFAULT_NOWAYOUT;\n\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds, default=\"\n\t\t__MODULE_STRING(DEFAULT_TIMEOUT));\nmodule_param(testmode, int, 0);\nMODULE_PARM_DESC(testmode, \"Watchdog test mode (1 = no reboot), default=\"\n\t\t__MODULE_STRING(DEFAULT_TESTMODE));\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started, default=\"\n\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT));\n\n \n\nstatic inline int superio_enter(void)\n{\n\t \n\tif (!request_muxed_region(REG, 2, WATCHDOG_NAME))\n\t\treturn -EBUSY;\n\n\toutb(0x87, REG);\n\toutb(0x01, REG);\n\toutb(0x55, REG);\n\toutb(0x55, REG);\n\treturn 0;\n}\n\nstatic inline void superio_exit(void)\n{\n\toutb(0x02, REG);\n\toutb(0x02, VAL);\n\trelease_region(REG, 2);\n}\n\nstatic inline void superio_select(int ldn)\n{\n\toutb(LDNREG, REG);\n\toutb(ldn, VAL);\n}\n\nstatic inline int superio_inb(int reg)\n{\n\toutb(reg, REG);\n\treturn inb(VAL);\n}\n\nstatic inline void superio_outb(int val, int reg)\n{\n\toutb(reg, REG);\n\toutb(val, VAL);\n}\n\nstatic inline int superio_inw(int reg)\n{\n\tint val;\n\toutb(reg++, REG);\n\tval = inb(VAL) << 8;\n\toutb(reg, REG);\n\tval |= inb(VAL);\n\treturn val;\n}\n\n \nstatic void _wdt_update_timeout(unsigned int t)\n{\n\tunsigned char cfg = WDT_KRST;\n\n\tif (testmode)\n\t\tcfg = 0;\n\n\tif (t <= max_units)\n\t\tcfg |= WDT_TOV1;\n\telse\n\t\tt /= 60;\n\n\tif (chip_type != IT8721_ID)\n\t\tcfg |= WDT_PWROK;\n\n\tsuperio_outb(cfg, WDTCFG);\n\tsuperio_outb(t, WDTVALLSB);\n\tif (max_units > 255)\n\t\tsuperio_outb(t >> 8, WDTVALMSB);\n}\n\nstatic int wdt_update_timeout(unsigned int t)\n{\n\tint ret;\n\n\tret = superio_enter();\n\tif (ret)\n\t\treturn ret;\n\n\tsuperio_select(GPIO);\n\t_wdt_update_timeout(t);\n\tsuperio_exit();\n\n\treturn 0;\n}\n\nstatic int wdt_round_time(int t)\n{\n\tt += 59;\n\tt -= t % 60;\n\treturn t;\n}\n\n \n\nstatic int wdt_start(struct watchdog_device *wdd)\n{\n\treturn wdt_update_timeout(wdd->timeout);\n}\n\nstatic int wdt_stop(struct watchdog_device *wdd)\n{\n\treturn wdt_update_timeout(0);\n}\n\n \n\nstatic int wdt_set_timeout(struct watchdog_device *wdd, unsigned int t)\n{\n\tint ret = 0;\n\n\tif (t > max_units)\n\t\tt = wdt_round_time(t);\n\n\twdd->timeout = t;\n\n\tif (watchdog_hw_running(wdd))\n\t\tret = wdt_update_timeout(t);\n\n\treturn ret;\n}\n\nstatic const struct watchdog_info ident = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.firmware_version = 1,\n\t.identity = WATCHDOG_NAME,\n};\n\nstatic const struct watchdog_ops wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = wdt_start,\n\t.stop = wdt_stop,\n\t.set_timeout = wdt_set_timeout,\n};\n\nstatic struct watchdog_device wdt_dev = {\n\t.info = &ident,\n\t.ops = &wdt_ops,\n\t.min_timeout = 1,\n};\n\nstatic int __init it87_wdt_init(void)\n{\n\tu8  chip_rev;\n\tint rc;\n\n\trc = superio_enter();\n\tif (rc)\n\t\treturn rc;\n\n\tchip_type = superio_inw(CHIPID);\n\tchip_rev  = superio_inb(CHIPREV) & 0x0f;\n\tsuperio_exit();\n\n\tswitch (chip_type) {\n\tcase IT8702_ID:\n\t\tmax_units = 255;\n\t\tbreak;\n\tcase IT8712_ID:\n\t\tmax_units = (chip_rev < 8) ? 255 : 65535;\n\t\tbreak;\n\tcase IT8716_ID:\n\tcase IT8726_ID:\n\t\tmax_units = 65535;\n\t\tbreak;\n\tcase IT8607_ID:\n\tcase IT8620_ID:\n\tcase IT8622_ID:\n\tcase IT8625_ID:\n\tcase IT8628_ID:\n\tcase IT8655_ID:\n\tcase IT8665_ID:\n\tcase IT8686_ID:\n\tcase IT8718_ID:\n\tcase IT8720_ID:\n\tcase IT8721_ID:\n\tcase IT8728_ID:\n\tcase IT8772_ID:\n\tcase IT8783_ID:\n\tcase IT8784_ID:\n\tcase IT8786_ID:\n\t\tmax_units = 65535;\n\t\tbreak;\n\tcase IT8705_ID:\n\t\tpr_err(\"Unsupported Chip found, Chip %04x Revision %02x\\n\",\n\t\t       chip_type, chip_rev);\n\t\treturn -ENODEV;\n\tcase NO_DEV_ID:\n\t\tpr_err(\"no device\\n\");\n\t\treturn -ENODEV;\n\tdefault:\n\t\tpr_err(\"Unknown Chip found, Chip %04x Revision %04x\\n\",\n\t\t       chip_type, chip_rev);\n\t\treturn -ENODEV;\n\t}\n\n\trc = superio_enter();\n\tif (rc)\n\t\treturn rc;\n\n\tsuperio_select(GPIO);\n\tsuperio_outb(WDT_TOV1, WDTCFG);\n\tsuperio_outb(0x00, WDTCTRL);\n\tsuperio_exit();\n\n\tif (timeout < 1 || timeout > max_units * 60) {\n\t\ttimeout = DEFAULT_TIMEOUT;\n\t\tpr_warn(\"Timeout value out of range, use default %d sec\\n\",\n\t\t\tDEFAULT_TIMEOUT);\n\t}\n\n\tif (timeout > max_units)\n\t\ttimeout = wdt_round_time(timeout);\n\n\twdt_dev.timeout = timeout;\n\twdt_dev.max_timeout = max_units * 60;\n\n\twatchdog_stop_on_reboot(&wdt_dev);\n\trc = watchdog_register_device(&wdt_dev);\n\tif (rc) {\n\t\tpr_err(\"Cannot register watchdog device (err=%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tpr_info(\"Chip IT%04x revision %d initialized. timeout=%d sec (nowayout=%d testmode=%d)\\n\",\n\t\tchip_type, chip_rev, timeout, nowayout, testmode);\n\n\treturn 0;\n}\n\nstatic void __exit it87_wdt_exit(void)\n{\n\twatchdog_unregister_device(&wdt_dev);\n}\n\nmodule_init(it87_wdt_init);\nmodule_exit(it87_wdt_exit);\n\nMODULE_AUTHOR(\"Oliver Schuster\");\nMODULE_DESCRIPTION(\"Hardware Watchdog Device Driver for IT87xx EC-LPC I/O\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}