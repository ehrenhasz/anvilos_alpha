{
  "module_name": "at91rm9200_wdt.c",
  "hash_id": "9271b8b4a91eda213326aa94846bbbd8ebd2052b5083eca642203ba498b7c1b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/at91rm9200_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/atmel-st.h>\n#include <linux/miscdevice.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/uaccess.h>\n\n#define WDT_DEFAULT_TIME\t5\t \n#define WDT_MAX_TIME\t\t256\t \n\nstatic int wdt_time = WDT_DEFAULT_TIME;\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic struct regmap *regmap_st;\n\nmodule_param(wdt_time, int, 0);\nMODULE_PARM_DESC(wdt_time, \"Watchdog time in seconds. (default=\"\n\t\t\t\t__MODULE_STRING(WDT_DEFAULT_TIME) \")\");\n\n#ifdef CONFIG_WATCHDOG_NOWAYOUT\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n#endif\n\n\nstatic unsigned long at91wdt_busy;\n\n \n\nstatic int at91rm9200_restart(struct notifier_block *this,\n\t\t\t\t\tunsigned long mode, void *cmd)\n{\n\t \n\tregmap_write(regmap_st, AT91_ST_WDMR,\n\t\t     AT91_ST_RSTEN | AT91_ST_EXTEN | 1);\n\tregmap_write(regmap_st, AT91_ST_CR, AT91_ST_WDRST);\n\n\tmdelay(2000);\n\n\tpr_emerg(\"Unable to restart system\\n\");\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block at91rm9200_restart_nb = {\n\t.notifier_call = at91rm9200_restart,\n\t.priority = 192,\n};\n\n \nstatic inline void at91_wdt_stop(void)\n{\n\tregmap_write(regmap_st, AT91_ST_WDMR, AT91_ST_EXTEN);\n}\n\n \nstatic inline void at91_wdt_start(void)\n{\n\tregmap_write(regmap_st, AT91_ST_WDMR, AT91_ST_EXTEN | AT91_ST_RSTEN |\n\t\t\t\t(((65536 * wdt_time) >> 8) & AT91_ST_WDV));\n\tregmap_write(regmap_st, AT91_ST_CR, AT91_ST_WDRST);\n}\n\n \nstatic inline void at91_wdt_reload(void)\n{\n\tregmap_write(regmap_st, AT91_ST_CR, AT91_ST_WDRST);\n}\n\n \n\n \nstatic int at91_wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &at91wdt_busy))\n\t\treturn -EBUSY;\n\n\tat91_wdt_start();\n\treturn stream_open(inode, file);\n}\n\n \nstatic int at91_wdt_close(struct inode *inode, struct file *file)\n{\n\t \n\tif (!nowayout)\n\t\tat91_wdt_stop();\n\n\tclear_bit(0, &at91wdt_busy);\n\treturn 0;\n}\n\n \nstatic int at91_wdt_settimeout(int new_time)\n{\n\t \n\tif ((new_time <= 0) || (new_time > WDT_MAX_TIME))\n\t\treturn -EINVAL;\n\n\t \n\twdt_time = new_time;\n\treturn 0;\n}\n\nstatic const struct watchdog_info at91_wdt_info = {\n\t.identity\t= \"at91 watchdog\",\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n};\n\n \nstatic long at91_wdt_ioctl(struct file *file,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint new_value;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &at91_wdt_info,\n\t\t\t\tsizeof(at91_wdt_info)) ? -EFAULT : 0;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(new_value, p))\n\t\t\treturn -EFAULT;\n\t\tif (new_value & WDIOS_DISABLECARD)\n\t\t\tat91_wdt_stop();\n\t\tif (new_value & WDIOS_ENABLECARD)\n\t\t\tat91_wdt_start();\n\t\treturn 0;\n\tcase WDIOC_KEEPALIVE:\n\t\tat91_wdt_reload();\t \n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_value, p))\n\t\t\treturn -EFAULT;\n\t\tif (at91_wdt_settimeout(new_value))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tat91_wdt_start();\n\t\t \n\t\treturn put_user(wdt_time, p);\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(wdt_time, p);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \nstatic ssize_t at91_wdt_write(struct file *file, const char *data,\n\t\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tat91_wdt_reload();\t\t \n\treturn len;\n}\n\n \n\nstatic const struct file_operations at91wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl\t= at91_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= at91_wdt_open,\n\t.release\t= at91_wdt_close,\n\t.write\t\t= at91_wdt_write,\n};\n\nstatic struct miscdevice at91wdt_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &at91wdt_fops,\n};\n\nstatic int at91wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device *parent;\n\tint res;\n\n\tif (at91wdt_miscdev.parent)\n\t\treturn -EBUSY;\n\tat91wdt_miscdev.parent = &pdev->dev;\n\n\tparent = dev->parent;\n\tif (!parent) {\n\t\tdev_err(dev, \"no parent\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregmap_st = syscon_node_to_regmap(parent->of_node);\n\tif (IS_ERR(regmap_st))\n\t\treturn -ENODEV;\n\n\tres = misc_register(&at91wdt_miscdev);\n\tif (res)\n\t\treturn res;\n\n\tres = register_restart_handler(&at91rm9200_restart_nb);\n\tif (res)\n\t\tdev_warn(dev, \"failed to register restart handler\\n\");\n\n\tpr_info(\"AT91 Watchdog Timer enabled (%d seconds%s)\\n\",\n\t\twdt_time, nowayout ? \", nowayout\" : \"\");\n\treturn 0;\n}\n\nstatic void at91wdt_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint res;\n\n\tres = unregister_restart_handler(&at91rm9200_restart_nb);\n\tif (res)\n\t\tdev_warn(dev, \"failed to unregister restart handler\\n\");\n\n\tmisc_deregister(&at91wdt_miscdev);\n\tat91wdt_miscdev.parent = NULL;\n}\n\nstatic void at91wdt_shutdown(struct platform_device *pdev)\n{\n\tat91_wdt_stop();\n}\n\nstatic int at91wdt_suspend(struct platform_device *pdev, pm_message_t message)\n{\n\tat91_wdt_stop();\n\treturn 0;\n}\n\nstatic int at91wdt_resume(struct platform_device *pdev)\n{\n\tif (at91wdt_busy)\n\t\tat91_wdt_start();\n\treturn 0;\n}\n\nstatic const struct of_device_id at91_wdt_dt_ids[] = {\n\t{ .compatible = \"atmel,at91rm9200-wdt\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, at91_wdt_dt_ids);\n\nstatic struct platform_driver at91wdt_driver = {\n\t.probe\t\t= at91wdt_probe,\n\t.remove_new\t= at91wdt_remove,\n\t.shutdown\t= at91wdt_shutdown,\n\t.suspend\t= pm_ptr(at91wdt_suspend),\n\t.resume\t\t= pm_ptr(at91wdt_resume),\n\t.driver\t\t= {\n\t\t.name\t= \"atmel_st_watchdog\",\n\t\t.of_match_table = at91_wdt_dt_ids,\n\t},\n};\n\nstatic int __init at91_wdt_init(void)\n{\n\t \n\tif (at91_wdt_settimeout(wdt_time)) {\n\t\tat91_wdt_settimeout(WDT_DEFAULT_TIME);\n\t\tpr_info(\"wdt_time value must be 1 <= wdt_time <= 256, using %d\\n\",\n\t\t\twdt_time);\n\t}\n\n\treturn platform_driver_register(&at91wdt_driver);\n}\n\nstatic void __exit at91_wdt_exit(void)\n{\n\tplatform_driver_unregister(&at91wdt_driver);\n}\n\nmodule_init(at91_wdt_init);\nmodule_exit(at91_wdt_exit);\n\nMODULE_AUTHOR(\"Andrew Victor\");\nMODULE_DESCRIPTION(\"Watchdog driver for Atmel AT91RM9200\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:atmel_st_watchdog\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}