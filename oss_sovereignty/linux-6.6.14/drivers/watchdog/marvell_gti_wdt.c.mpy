{
  "module_name": "marvell_gti_wdt.c",
  "hash_id": "7fc198483d30c8174404aa4048e729dfc72f62bbe3e3fdaa1cb872aab2b60c70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/marvell_gti_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n \n\n \n#define GTI_CWD_WDOG(reg_offset)\t(0x8 * (reg_offset))\n#define GTI_CWD_WDOG_MODE_INT_DEL3T_RST\t0x3\n#define GTI_CWD_WDOG_MODE_MASK\t\tGENMASK_ULL(1, 0)\n#define GTI_CWD_WDOG_LEN_SHIFT\t\t4\n#define GTI_CWD_WDOG_LEN_MASK\t\tGENMASK_ULL(19, 4)\n#define GTI_CWD_WDOG_CNT_SHIFT\t\t20\n#define GTI_CWD_WDOG_CNT_MASK\t\tGENMASK_ULL(43, 20)\n\n \n#define GTI_CWD_INT\t\t\t0x200\n#define GTI_CWD_INT_PENDING_STATUS(bit)\tBIT_ULL(bit)\n\n \n#define GTI_CWD_INT_ENA_CLR\t\t0x210\n#define GTI_CWD_INT_ENA_CLR_VAL(bit)\tBIT_ULL(bit)\n\n \n#define GTI_CWD_INT_ENA_SET\t\t0x218\n#define GTI_CWD_INT_ENA_SET_VAL(bit)\tBIT_ULL(bit)\n\n \n#define GTI_CWD_POKE(reg_offset)\t(0x10000 + 0x8 * (reg_offset))\n#define GTI_CWD_POKE_VAL\t\t1\n\nstruct gti_match_data {\n\tu32 gti_num_timers;\n};\n\nstatic const struct gti_match_data match_data_octeontx2 = {\n\t.gti_num_timers = 54,\n};\n\nstatic const struct gti_match_data match_data_cn10k = {\n\t.gti_num_timers = 64,\n};\n\nstruct gti_wdt_priv {\n\tstruct watchdog_device wdev;\n\tvoid __iomem *base;\n\tu32 clock_freq;\n\tstruct clk *sclk;\n\t \n\tu32 wdt_timer_idx;\n\tconst struct gti_match_data *data;\n};\n\nstatic irqreturn_t gti_wdt_interrupt(int irq, void *data)\n{\n\tstruct watchdog_device *wdev = data;\n\tstruct gti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\t \n\twriteq(GTI_CWD_INT_PENDING_STATUS(priv->wdt_timer_idx),\n\t       priv->base + GTI_CWD_INT);\n\n\twatchdog_notify_pretimeout(wdev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int gti_wdt_ping(struct watchdog_device *wdev)\n{\n\tstruct gti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\twriteq(GTI_CWD_POKE_VAL,\n\t       priv->base + GTI_CWD_POKE(priv->wdt_timer_idx));\n\n\treturn 0;\n}\n\nstatic int gti_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct gti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu64 regval;\n\n\tif (!wdev->pretimeout)\n\t\treturn -EINVAL;\n\n\tset_bit(WDOG_HW_RUNNING, &wdev->status);\n\n\t \n\twriteq(GTI_CWD_INT_PENDING_STATUS(priv->wdt_timer_idx),\n\t       priv->base + GTI_CWD_INT);\n\n\t \n\twriteq(GTI_CWD_INT_ENA_SET_VAL(priv->wdt_timer_idx),\n\t       priv->base + GTI_CWD_INT_ENA_SET);\n\n\t \n\tregval = readq(priv->base + GTI_CWD_WDOG(priv->wdt_timer_idx));\n\tregval |= GTI_CWD_WDOG_MODE_INT_DEL3T_RST;\n\twriteq(regval, priv->base + GTI_CWD_WDOG(priv->wdt_timer_idx));\n\n\treturn 0;\n}\n\nstatic int gti_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct gti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu64 regval;\n\n\t \n\twriteq(GTI_CWD_INT_ENA_CLR_VAL(priv->wdt_timer_idx),\n\t       priv->base + GTI_CWD_INT_ENA_CLR);\n\n\t \n\tregval = readq(priv->base + GTI_CWD_WDOG(priv->wdt_timer_idx));\n\tregval &= ~GTI_CWD_WDOG_MODE_MASK;\n\twriteq(regval, priv->base + GTI_CWD_WDOG(priv->wdt_timer_idx));\n\n\treturn 0;\n}\n\nstatic int gti_wdt_settimeout(struct watchdog_device *wdev,\n\t\t\t\t\tunsigned int timeout)\n{\n\tstruct gti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu64 timeout_wdog, regval;\n\n\t \n\twdev->timeout = timeout;\n\n\t \n\twdev->pretimeout = timeout / 3;\n\n\t \n\ttimeout_wdog = (u64)priv->clock_freq * wdev->pretimeout;\n\n\t \n\ttimeout_wdog = timeout_wdog >> 10;\n\n\t \n\ttimeout_wdog = (timeout_wdog + 0xff) >> 8;\n\tif (timeout_wdog >= 0x10000)\n\t\ttimeout_wdog = 0xffff;\n\n\t \n\tregval = readq(priv->base + GTI_CWD_WDOG(priv->wdt_timer_idx));\n\tregval &= GTI_CWD_WDOG_MODE_MASK;\n\tregval |= (timeout_wdog << (GTI_CWD_WDOG_CNT_SHIFT + 8)) |\n\t\t   (timeout_wdog << GTI_CWD_WDOG_LEN_SHIFT);\n\twriteq(regval, priv->base + GTI_CWD_WDOG(priv->wdt_timer_idx));\n\n\treturn 0;\n}\n\nstatic int gti_wdt_set_pretimeout(struct watchdog_device *wdev,\n\t\t\t\t\tunsigned int timeout)\n{\n\tstruct gti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tstruct watchdog_device *wdog_dev = &priv->wdev;\n\n\t \n\tif (timeout * 3 <= wdog_dev->max_timeout)\n\t\treturn gti_wdt_settimeout(wdev, timeout * 3);\n\n\treturn -EINVAL;\n}\n\nstatic void gti_clk_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int gti_wdt_get_cntfrq(struct platform_device *pdev,\n\t\t\t      struct gti_wdt_priv *priv)\n{\n\tint err;\n\n\tpriv->sclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(priv->sclk))\n\t\treturn PTR_ERR(priv->sclk);\n\n\terr = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       gti_clk_disable_unprepare, priv->sclk);\n\tif (err)\n\t\treturn err;\n\n\tpriv->clock_freq = clk_get_rate(priv->sclk);\n\tif (!priv->clock_freq)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info gti_wdt_ident = {\n\t.identity = \"Marvell GTI watchdog\",\n\t.options = WDIOF_SETTIMEOUT | WDIOF_PRETIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t   WDIOF_MAGICCLOSE | WDIOF_CARDRESET,\n};\n\nstatic const struct watchdog_ops gti_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = gti_wdt_start,\n\t.stop = gti_wdt_stop,\n\t.ping = gti_wdt_ping,\n\t.set_timeout = gti_wdt_settimeout,\n\t.set_pretimeout = gti_wdt_set_pretimeout,\n};\n\nstatic int gti_wdt_probe(struct platform_device *pdev)\n{\n\tstruct gti_wdt_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdog_dev;\n\tu64 max_pretimeout;\n\tu32 wdt_idx;\n\tint irq;\n\tint err;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->base),\n\t\t\t      \"reg property not valid/found\\n\");\n\n\terr = gti_wdt_get_cntfrq(pdev, priv);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err,\n\t\t\t\t     \"GTI clock frequency not valid/found\");\n\n\tpriv->data = of_device_get_match_data(dev);\n\n\t \n\tpriv->wdt_timer_idx = priv->data->gti_num_timers - 1;\n\n\terr = of_property_read_u32(dev->of_node, \"marvell,wdt-timer-index\",\n\t\t\t\t   &wdt_idx);\n\tif (!err) {\n\t\tif (wdt_idx >= priv->data->gti_num_timers)\n\t\t\treturn dev_err_probe(&pdev->dev, -EINVAL,\n\t\t\t\t\"GTI wdog timer index not valid\");\n\n\t\tpriv->wdt_timer_idx = wdt_idx;\n\t}\n\n\twdog_dev = &priv->wdev;\n\twdog_dev->info = &gti_wdt_ident,\n\twdog_dev->ops = &gti_wdt_ops,\n\twdog_dev->parent = dev;\n\t \n\tmax_pretimeout = (GTI_CWD_WDOG_CNT_MASK >> GTI_CWD_WDOG_CNT_SHIFT);\n\tmax_pretimeout &= ~0xFFUL;\n\tmax_pretimeout = (max_pretimeout * 1024) / priv->clock_freq;\n\twdog_dev->pretimeout = max_pretimeout;\n\n\t \n\twdog_dev->max_timeout = max_pretimeout * 3;\n\t \n\twdog_dev->min_timeout = 3;\n\twdog_dev->timeout = wdog_dev->pretimeout;\n\n\twatchdog_set_drvdata(wdog_dev, priv);\n\tplatform_set_drvdata(pdev, priv);\n\tgti_wdt_settimeout(wdog_dev, wdog_dev->timeout);\n\twatchdog_stop_on_reboot(wdog_dev);\n\twatchdog_stop_on_unregister(wdog_dev);\n\n\terr = devm_watchdog_register_device(dev, wdog_dev);\n\tif (err)\n\t\treturn err;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn dev_err_probe(&pdev->dev, irq, \"IRQ resource not found\\n\");\n\n\terr = devm_request_irq(dev, irq, gti_wdt_interrupt, 0,\n\t\t\t       pdev->name, &priv->wdev);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to register interrupt handler\\n\");\n\n\tdev_info(dev, \"Watchdog enabled (timeout=%d sec)\\n\", wdog_dev->timeout);\n\treturn 0;\n}\n\nstatic const struct of_device_id gti_wdt_of_match[] = {\n\t{ .compatible = \"marvell,cn9670-wdt\", .data = &match_data_octeontx2},\n\t{ .compatible = \"marvell,cn10624-wdt\", .data = &match_data_cn10k},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, gti_wdt_of_match);\n\nstatic struct platform_driver gti_wdt_driver = {\n\t.driver = {\n\t\t.name = \"gti-wdt\",\n\t\t.of_match_table = gti_wdt_of_match,\n\t},\n\t.probe = gti_wdt_probe,\n};\nmodule_platform_driver(gti_wdt_driver);\n\nMODULE_AUTHOR(\"Bharat Bhushan <bbhushan2@marvell.com>\");\nMODULE_DESCRIPTION(\"Marvell GTI watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}