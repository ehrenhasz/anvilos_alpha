{
  "module_name": "alim7101_wdt.c",
  "hash_id": "051e1d03de8eb35b82a809af542490037d3670ffecc296f86c5d910a5d530e1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/alim7101_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/ioport.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n\n#define WDT_ENABLE 0x9C\n#define WDT_DISABLE 0x8C\n\n#define ALI_7101_WDT    0x92\n#define ALI_7101_GPIO   0x7D\n#define ALI_7101_GPIO_O 0x7E\n#define ALI_WDT_ARM     0x01\n\n \n\n#define WDT_INTERVAL (HZ/4+1)\n\n \n\n#define WATCHDOG_TIMEOUT 30             \n \nstatic int timeout = WATCHDOG_TIMEOUT;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\t\"Watchdog timeout in seconds. (1<=timeout<=3600, default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic int use_gpio;  \nmodule_param(use_gpio, int, 0);\nMODULE_PARM_DESC(use_gpio,\n\t\t\"Use the gpio watchdog (required by old cobalt boards).\");\n\nstatic void wdt_timer_ping(struct timer_list *);\nstatic DEFINE_TIMER(timer, wdt_timer_ping);\nstatic unsigned long next_heartbeat;\nstatic unsigned long wdt_is_open;\nstatic char wdt_expect_close;\nstatic struct pci_dev *alim7101_pmu;\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n\nstatic void wdt_timer_ping(struct timer_list *unused)\n{\n\t \n\tchar tmp;\n\n\tif (time_before(jiffies, next_heartbeat)) {\n\t\t \n\t\tpci_read_config_byte(alim7101_pmu, 0x92, &tmp);\n\t\tpci_write_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_WDT, (tmp & ~ALI_WDT_ARM));\n\t\tpci_write_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_WDT, (tmp | ALI_WDT_ARM));\n\t\tif (use_gpio) {\n\t\t\tpci_read_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_GPIO_O, &tmp);\n\t\t\tpci_write_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_GPIO_O, tmp | 0x20);\n\t\t\tpci_write_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_GPIO_O, tmp & ~0x20);\n\t\t}\n\t} else {\n\t\tpr_warn(\"Heartbeat lost! Will not ping the watchdog\\n\");\n\t}\n\t \n\tmod_timer(&timer, jiffies + WDT_INTERVAL);\n}\n\n \n\nstatic void wdt_change(int writeval)\n{\n\tchar tmp;\n\n\tpci_read_config_byte(alim7101_pmu, ALI_7101_WDT, &tmp);\n\tif (writeval == WDT_ENABLE) {\n\t\tpci_write_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_WDT, (tmp | ALI_WDT_ARM));\n\t\tif (use_gpio) {\n\t\t\tpci_read_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_GPIO_O, &tmp);\n\t\t\tpci_write_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_GPIO_O, tmp & ~0x20);\n\t\t}\n\n\t} else {\n\t\tpci_write_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_WDT, (tmp & ~ALI_WDT_ARM));\n\t\tif (use_gpio) {\n\t\t\tpci_read_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_GPIO_O, &tmp);\n\t\t\tpci_write_config_byte(alim7101_pmu,\n\t\t\t\t\tALI_7101_GPIO_O, tmp | 0x20);\n\t\t}\n\t}\n}\n\nstatic void wdt_startup(void)\n{\n\tnext_heartbeat = jiffies + (timeout * HZ);\n\n\t \n\n\twdt_change(WDT_ENABLE);\n\n\t \n\tmod_timer(&timer, jiffies + WDT_INTERVAL);\n\n\tpr_info(\"Watchdog timer is now enabled\\n\");\n}\n\nstatic void wdt_turnoff(void)\n{\n\t \n\tdel_timer_sync(&timer);\n\twdt_change(WDT_DISABLE);\n\tpr_info(\"Watchdog timer is now disabled...\\n\");\n}\n\nstatic void wdt_keepalive(void)\n{\n\t \n\tnext_heartbeat = jiffies + (timeout * HZ);\n}\n\n \n\nstatic ssize_t fop_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\t \n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t ofs;\n\n\t\t\t \n\t\t\twdt_expect_close = 0;\n\n\t\t\t \n\t\t\tfor (ofs = 0; ofs != count; ofs++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + ofs))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\twdt_expect_close = 42;\n\t\t\t}\n\t\t}\n\t\t \n\t\twdt_keepalive();\n\t}\n\treturn count;\n}\n\nstatic int fop_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &wdt_is_open))\n\t\treturn -EBUSY;\n\t \n\twdt_startup();\n\treturn stream_open(inode, file);\n}\n\nstatic int fop_close(struct inode *inode, struct file *file)\n{\n\tif (wdt_expect_close == 42)\n\t\twdt_turnoff();\n\telse {\n\t\t \n\t\tpr_crit(\"device file closed unexpectedly. Will not stop the WDT!\\n\");\n\t}\n\tclear_bit(0, &wdt_is_open);\n\twdt_expect_close = 0;\n\treturn 0;\n}\n\nstatic long fop_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT\n\t\t\t\t\t\t\t| WDIOF_MAGICCLOSE,\n\t\t.firmware_version = 1,\n\t\t.identity = \"ALiM7101\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint new_options, retval = -EINVAL;\n\n\t\tif (get_user(new_options, p))\n\t\t\treturn -EFAULT;\n\t\tif (new_options & WDIOS_DISABLECARD) {\n\t\t\twdt_turnoff();\n\t\t\tretval = 0;\n\t\t}\n\t\tif (new_options & WDIOS_ENABLECARD) {\n\t\t\twdt_startup();\n\t\t\tretval = 0;\n\t\t}\n\t\treturn retval;\n\t}\n\tcase WDIOC_KEEPALIVE:\n\t\twdt_keepalive();\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t{\n\t\tint new_timeout;\n\n\t\tif (get_user(new_timeout, p))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tif (new_timeout < 1 || new_timeout > 3600)\n\t\t\treturn -EINVAL;\n\t\ttimeout = new_timeout;\n\t\twdt_keepalive();\n\t}\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(timeout, p);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic const struct file_operations wdt_fops = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.llseek\t\t=\tno_llseek,\n\t.write\t\t=\tfop_write,\n\t.open\t\t=\tfop_open,\n\t.release\t=\tfop_close,\n\t.unlocked_ioctl\t=\tfop_ioctl,\n\t.compat_ioctl\t= \tcompat_ptr_ioctl,\n};\n\nstatic struct miscdevice wdt_miscdev = {\n\t.minor\t=\tWATCHDOG_MINOR,\n\t.name\t=\t\"watchdog\",\n\t.fops\t=\t&wdt_fops,\n};\n\nstatic int wdt_restart_handle(struct notifier_block *this, unsigned long mode,\n\t\t\t      void *cmd)\n{\n\t \n\twdt_change(WDT_ENABLE);\n\n\t \n\twhile (true)\n\t\t;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block wdt_restart_handler = {\n\t.notifier_call = wdt_restart_handle,\n\t.priority = 128,\n};\n\n \n\nstatic int wdt_notify_sys(struct notifier_block *this,\n\t\t\t\t\tunsigned long code, void *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\twdt_turnoff();\n\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic struct notifier_block wdt_notifier = {\n\t.notifier_call = wdt_notify_sys,\n};\n\nstatic void __exit alim7101_wdt_unload(void)\n{\n\twdt_turnoff();\n\t \n\tmisc_deregister(&wdt_miscdev);\n\tunregister_reboot_notifier(&wdt_notifier);\n\tunregister_restart_handler(&wdt_restart_handler);\n\tpci_dev_put(alim7101_pmu);\n}\n\nstatic int __init alim7101_wdt_init(void)\n{\n\tint rc = -EBUSY;\n\tstruct pci_dev *ali1543_south;\n\tchar tmp;\n\n\tpr_info(\"Steve Hill <steve@navaho.co.uk>\\n\");\n\talim7101_pmu = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101,\n\t\tNULL);\n\tif (!alim7101_pmu) {\n\t\tpr_info(\"ALi M7101 PMU not present - WDT not set\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tpci_write_config_byte(alim7101_pmu, ALI_7101_WDT, 0x02);\n\n\tali1543_south = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533,\n\t\tNULL);\n\tif (!ali1543_south) {\n\t\tpr_info(\"ALi 1543 South-Bridge not present - WDT not set\\n\");\n\t\tgoto err_out;\n\t}\n\tpci_read_config_byte(ali1543_south, 0x5e, &tmp);\n\tpci_dev_put(ali1543_south);\n\tif ((tmp & 0x1e) == 0x00) {\n\t\tif (!use_gpio) {\n\t\t\tpr_info(\"Detected old alim7101 revision 'a1d'.  If this is a cobalt board, set the 'use_gpio' module parameter.\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tnowayout = 1;\n\t} else if ((tmp & 0x1e) != 0x12 && (tmp & 0x1e) != 0x00) {\n\t\tpr_info(\"ALi 1543 South-Bridge does not have the correct revision number (???1001?) - WDT not set\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (timeout < 1 || timeout > 3600) {\n\t\t \n\t\ttimeout = WATCHDOG_TIMEOUT;\n\t\tpr_info(\"timeout value must be 1 <= x <= 3600, using %d\\n\",\n\t\t\ttimeout);\n\t}\n\n\trc = register_reboot_notifier(&wdt_notifier);\n\tif (rc) {\n\t\tpr_err(\"cannot register reboot notifier (err=%d)\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\trc = register_restart_handler(&wdt_restart_handler);\n\tif (rc) {\n\t\tpr_err(\"cannot register restart handler (err=%d)\\n\", rc);\n\t\tgoto err_out_reboot;\n\t}\n\n\trc = misc_register(&wdt_miscdev);\n\tif (rc) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       wdt_miscdev.minor, rc);\n\t\tgoto err_out_restart;\n\t}\n\n\tif (nowayout)\n\t\t__module_get(THIS_MODULE);\n\n\tpr_info(\"WDT driver for ALi M7101 initialised. timeout=%d sec (nowayout=%d)\\n\",\n\t\ttimeout, nowayout);\n\treturn 0;\n\nerr_out_restart:\n\tunregister_restart_handler(&wdt_restart_handler);\nerr_out_reboot:\n\tunregister_reboot_notifier(&wdt_notifier);\nerr_out:\n\tpci_dev_put(alim7101_pmu);\n\treturn rc;\n}\n\nmodule_init(alim7101_wdt_init);\nmodule_exit(alim7101_wdt_unload);\n\nstatic const struct pci_device_id alim7101_pci_tbl[] __used = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, alim7101_pci_tbl);\n\nMODULE_AUTHOR(\"Steve Hill\");\nMODULE_DESCRIPTION(\"ALi M7101 PMU Computer Watchdog Timer driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}