{
  "module_name": "wdt_pci.c",
  "hash_id": "78efaa5798584b7665aa5de4de4fe1ab37916e77e12a69e9a7add14d5b8dc80d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/wdt_pci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/fs.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n\n#define WDT_IS_PCI\n#include \"wd501p.h\"\n\n \nstatic int dev_count;\n\nstatic unsigned long open_lock;\nstatic DEFINE_SPINLOCK(wdtpci_lock);\nstatic char expect_close;\n\nstatic resource_size_t io;\nstatic int irq;\n\n \n#define WD_TIMO 60\t\t\t \n\nstatic int heartbeat = WD_TIMO;\nstatic int wd_heartbeat;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\t\"Watchdog heartbeat in seconds. (0<heartbeat<65536, default=\"\n\t\t\t\t__MODULE_STRING(WD_TIMO) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \nstatic int tachometer;\nmodule_param(tachometer, int, 0);\nMODULE_PARM_DESC(tachometer,\n\t\t\"PCI-WDT501 Fan Tachometer support (0=disable, default=0)\");\n\nstatic int type = 500;\nmodule_param(type, int, 0);\nMODULE_PARM_DESC(type,\n\t\t\"PCI-WDT501 Card type (500 or 501 , default=500)\");\n\n \n\nstatic void wdtpci_ctr_mode(int ctr, int mode)\n{\n\tctr <<= 6;\n\tctr |= 0x30;\n\tctr |= (mode << 1);\n\toutb(ctr, WDT_CR);\n\tudelay(8);\n}\n\nstatic void wdtpci_ctr_load(int ctr, int val)\n{\n\toutb(val & 0xFF, WDT_COUNT0 + ctr);\n\tudelay(8);\n\toutb(val >> 8, WDT_COUNT0 + ctr);\n\tudelay(8);\n}\n\n \n\nstatic int wdtpci_start(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdtpci_lock, flags);\n\n\t \n\tinb(WDT_DC);\t\t\t \n\tudelay(8);\n\twdtpci_ctr_mode(2, 0);\t\t \n\toutb(0, WDT_DC);\t\t \n\tudelay(8);\n\tinb(WDT_DC);\t\t\t \n\tudelay(8);\n\toutb(0, WDT_CLOCK);\t\t \n\tudelay(8);\n\tinb(WDT_BUZZER);\t\t \n\tudelay(8);\n\tinb(WDT_OPTONOTRST);\t\t \n\tudelay(8);\n\tinb(WDT_OPTORST);\t\t \n\tudelay(8);\n\tinb(WDT_PROGOUT);\t\t \n\tudelay(8);\n\twdtpci_ctr_mode(0, 3);\t\t \n\twdtpci_ctr_mode(1, 2);\t\t \n\twdtpci_ctr_mode(2, 1);\t\t \n\twdtpci_ctr_load(0, 20833);\t \n\twdtpci_ctr_load(1, wd_heartbeat); \n\t \n\toutb(0, WDT_DC);\t\t \n\tudelay(8);\n\n\tspin_unlock_irqrestore(&wdtpci_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int wdtpci_stop(void)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&wdtpci_lock, flags);\n\tinb(WDT_DC);\t\t\t \n\tudelay(8);\n\twdtpci_ctr_load(2, 0);\t\t \n\tspin_unlock_irqrestore(&wdtpci_lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int wdtpci_ping(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdtpci_lock, flags);\n\t \n\tinb(WDT_DC);\t\t\t \n\tudelay(8);\n\twdtpci_ctr_mode(1, 2);\t\t \n\twdtpci_ctr_load(1, wd_heartbeat); \n\toutb(0, WDT_DC);\t\t \n\tudelay(8);\n\tspin_unlock_irqrestore(&wdtpci_lock, flags);\n\treturn 0;\n}\n\n \nstatic int wdtpci_set_heartbeat(int t)\n{\n\t \n\tif (t < 1 || t > 65535)\n\t\treturn -EINVAL;\n\n\theartbeat = t;\n\twd_heartbeat = t * 100;\n\treturn 0;\n}\n\n \n\nstatic int wdtpci_get_status(int *status)\n{\n\tunsigned char new_status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdtpci_lock, flags);\n\tnew_status = inb(WDT_SR);\n\tspin_unlock_irqrestore(&wdtpci_lock, flags);\n\n\t*status = 0;\n\tif (new_status & WDC_SR_ISOI0)\n\t\t*status |= WDIOF_EXTERN1;\n\tif (new_status & WDC_SR_ISII1)\n\t\t*status |= WDIOF_EXTERN2;\n\tif (type == 501) {\n\t\tif (!(new_status & WDC_SR_TGOOD))\n\t\t\t*status |= WDIOF_OVERHEAT;\n\t\tif (!(new_status & WDC_SR_PSUOVER))\n\t\t\t*status |= WDIOF_POWEROVER;\n\t\tif (!(new_status & WDC_SR_PSUUNDR))\n\t\t\t*status |= WDIOF_POWERUNDER;\n\t\tif (tachometer) {\n\t\t\tif (!(new_status & WDC_SR_FANGOOD))\n\t\t\t\t*status |= WDIOF_FANFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic int wdtpci_get_temperature(int *temperature)\n{\n\tunsigned short c;\n\tunsigned long flags;\n\tspin_lock_irqsave(&wdtpci_lock, flags);\n\tc = inb(WDT_RT);\n\tudelay(8);\n\tspin_unlock_irqrestore(&wdtpci_lock, flags);\n\t*temperature = (c * 11 / 15) + 7;\n\treturn 0;\n}\n\n \n\nstatic irqreturn_t wdtpci_interrupt(int irq, void *dev_id)\n{\n\t \n\tunsigned char status;\n\n\tspin_lock(&wdtpci_lock);\n\n\tstatus = inb(WDT_SR);\n\tudelay(8);\n\n\tpr_crit(\"status %d\\n\", status);\n\n\tif (type == 501) {\n\t\tif (!(status & WDC_SR_TGOOD)) {\n\t\t\tpr_crit(\"Overheat alarm (%d)\\n\", inb(WDT_RT));\n\t\t\tudelay(8);\n\t\t}\n\t\tif (!(status & WDC_SR_PSUOVER))\n\t\t\tpr_crit(\"PSU over voltage\\n\");\n\t\tif (!(status & WDC_SR_PSUUNDR))\n\t\t\tpr_crit(\"PSU under voltage\\n\");\n\t\tif (tachometer) {\n\t\t\tif (!(status & WDC_SR_FANGOOD))\n\t\t\t\tpr_crit(\"Possible fan fault\\n\");\n\t\t}\n\t}\n\tif (!(status & WDC_SR_WCCR)) {\n#ifdef SOFTWARE_REBOOT\n#ifdef ONLY_TESTING\n\t\tpr_crit(\"Would Reboot\\n\");\n#else\n\t\tpr_crit(\"Initiating system reboot\\n\");\n\t\temergency_restart();\n#endif\n#else\n\t\tpr_crit(\"Reset in 5ms\\n\");\n#endif\n\t}\n\tspin_unlock(&wdtpci_lock);\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic ssize_t wdtpci_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\tfor (i = 0; i != count; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\t\twdtpci_ping();\n\t}\n\treturn count;\n}\n\n \n\nstatic long wdtpci_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint new_heartbeat;\n\tint status;\n\n\tstruct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_SETTIMEOUT|\n\t\t\t\t\tWDIOF_MAGICCLOSE|\n\t\t\t\t\tWDIOF_KEEPALIVEPING,\n\t\t.firmware_version =\t1,\n\t\t.identity =\t\t\"PCI-WDT500/501\",\n\t};\n\n\t \n\tident.options |= (WDIOF_EXTERN1|WDIOF_EXTERN2);\n\tif (type == 501) {\n\t\tident.options |= (WDIOF_OVERHEAT|WDIOF_POWERUNDER|\n\t\t\t\t\t\t\tWDIOF_POWEROVER);\n\t\tif (tachometer)\n\t\t\tident.options |= WDIOF_FANFAULT;\n\t}\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\tcase WDIOC_GETSTATUS:\n\t\twdtpci_get_status(&status);\n\t\treturn put_user(status, p);\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_KEEPALIVE:\n\t\twdtpci_ping();\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_heartbeat, p))\n\t\t\treturn -EFAULT;\n\t\tif (wdtpci_set_heartbeat(new_heartbeat))\n\t\t\treturn -EINVAL;\n\t\twdtpci_ping();\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(heartbeat, p);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \n\nstatic int wdtpci_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &open_lock))\n\t\treturn -EBUSY;\n\n\tif (nowayout)\n\t\t__module_get(THIS_MODULE);\n\t \n\twdtpci_start();\n\treturn stream_open(inode, file);\n}\n\n \n\nstatic int wdtpci_release(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42) {\n\t\twdtpci_stop();\n\t} else {\n\t\tpr_crit(\"Unexpected close, not stopping timer!\\n\");\n\t\twdtpci_ping();\n\t}\n\texpect_close = 0;\n\tclear_bit(0, &open_lock);\n\treturn 0;\n}\n\n \n\nstatic ssize_t wdtpci_temp_read(struct file *file, char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ptr)\n{\n\tint temperature;\n\n\tif (wdtpci_get_temperature(&temperature))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(buf, &temperature, 1))\n\t\treturn -EFAULT;\n\n\treturn 1;\n}\n\n \n\nstatic int wdtpci_temp_open(struct inode *inode, struct file *file)\n{\n\treturn stream_open(inode, file);\n}\n\n \n\nstatic int wdtpci_temp_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\n \n\nstatic int wdtpci_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t\t\t\t\tvoid *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\twdtpci_stop();\n\treturn NOTIFY_DONE;\n}\n\n \n\n\nstatic const struct file_operations wdtpci_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= wdtpci_write,\n\t.unlocked_ioctl\t= wdtpci_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= wdtpci_open,\n\t.release\t= wdtpci_release,\n};\n\nstatic struct miscdevice wdtpci_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &wdtpci_fops,\n};\n\nstatic const struct file_operations wdtpci_temp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= wdtpci_temp_read,\n\t.open\t\t= wdtpci_temp_open,\n\t.release\t= wdtpci_temp_release,\n};\n\nstatic struct miscdevice temp_miscdev = {\n\t.minor\t= TEMP_MINOR,\n\t.name\t= \"temperature\",\n\t.fops\t= &wdtpci_temp_fops,\n};\n\n \n\nstatic struct notifier_block wdtpci_notifier = {\n\t.notifier_call = wdtpci_notify_sys,\n};\n\n\nstatic int wdtpci_init_one(struct pci_dev *dev,\n\t\t\t\t\tconst struct pci_device_id *ent)\n{\n\tint ret = -EIO;\n\n\tdev_count++;\n\tif (dev_count > 1) {\n\t\tpr_err(\"This driver only supports one device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (type != 500 && type != 501) {\n\t\tpr_err(\"unknown card type '%d'\\n\", type);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pci_enable_device(dev)) {\n\t\tpr_err(\"Not possible to enable PCI Device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pci_resource_start(dev, 2) == 0x0000) {\n\t\tpr_err(\"No I/O-Address for card detected\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_pci;\n\t}\n\n\tif (pci_request_region(dev, 2, \"wdt_pci\")) {\n\t\tpr_err(\"I/O address 0x%llx already in use\\n\",\n\t\t       (unsigned long long)pci_resource_start(dev, 2));\n\t\tgoto out_pci;\n\t}\n\n\tirq = dev->irq;\n\tio = pci_resource_start(dev, 2);\n\n\tif (request_irq(irq, wdtpci_interrupt, IRQF_SHARED,\n\t\t\t \"wdt_pci\", &wdtpci_miscdev)) {\n\t\tpr_err(\"IRQ %d is not free\\n\", irq);\n\t\tgoto out_reg;\n\t}\n\n\tpr_info(\"PCI-WDT500/501 (PCI-WDG-CSM) driver 0.10 at 0x%llx (Interrupt %d)\\n\",\n\t\t(unsigned long long)io, irq);\n\n\t \n\tif (wdtpci_set_heartbeat(heartbeat)) {\n\t\twdtpci_set_heartbeat(WD_TIMO);\n\t\tpr_info(\"heartbeat value must be 0 < heartbeat < 65536, using %d\\n\",\n\t\t\tWD_TIMO);\n\t}\n\n\tret = register_reboot_notifier(&wdtpci_notifier);\n\tif (ret) {\n\t\tpr_err(\"cannot register reboot notifier (err=%d)\\n\", ret);\n\t\tgoto out_irq;\n\t}\n\n\tif (type == 501) {\n\t\tret = misc_register(&temp_miscdev);\n\t\tif (ret) {\n\t\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t\t       TEMP_MINOR, ret);\n\t\t\tgoto out_rbt;\n\t\t}\n\t}\n\n\tret = misc_register(&wdtpci_miscdev);\n\tif (ret) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, ret);\n\t\tgoto out_misc;\n\t}\n\n\tpr_info(\"initialized. heartbeat=%d sec (nowayout=%d)\\n\",\n\t\theartbeat, nowayout);\n\tif (type == 501)\n\t\tpr_info(\"Fan Tachometer is %s\\n\",\n\t\t\ttachometer ? \"Enabled\" : \"Disabled\");\n\n\tret = 0;\nout:\n\treturn ret;\n\nout_misc:\n\tif (type == 501)\n\t\tmisc_deregister(&temp_miscdev);\nout_rbt:\n\tunregister_reboot_notifier(&wdtpci_notifier);\nout_irq:\n\tfree_irq(irq, &wdtpci_miscdev);\nout_reg:\n\tpci_release_region(dev, 2);\nout_pci:\n\tpci_disable_device(dev);\n\tgoto out;\n}\n\n\nstatic void wdtpci_remove_one(struct pci_dev *pdev)\n{\n\t \n\tmisc_deregister(&wdtpci_miscdev);\n\tif (type == 501)\n\t\tmisc_deregister(&temp_miscdev);\n\tunregister_reboot_notifier(&wdtpci_notifier);\n\tfree_irq(irq, &wdtpci_miscdev);\n\tpci_release_region(pdev, 2);\n\tpci_disable_device(pdev);\n\tdev_count--;\n}\n\n\nstatic const struct pci_device_id wdtpci_pci_tbl[] = {\n\t{\n\t\t.vendor\t   = PCI_VENDOR_ID_ACCESSIO,\n\t\t.device\t   = PCI_DEVICE_ID_ACCESSIO_WDG_CSM,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t},\n\t{ 0, },  \n};\nMODULE_DEVICE_TABLE(pci, wdtpci_pci_tbl);\n\n\nstatic struct pci_driver wdtpci_driver = {\n\t.name\t\t= \"wdt_pci\",\n\t.id_table\t= wdtpci_pci_tbl,\n\t.probe\t\t= wdtpci_init_one,\n\t.remove\t\t= wdtpci_remove_one,\n};\n\nmodule_pci_driver(wdtpci_driver);\n\nMODULE_AUTHOR(\"JP Nollmann, Alan Cox\");\nMODULE_DESCRIPTION(\"Driver for the ICS PCI-WDT500/501 watchdog cards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}