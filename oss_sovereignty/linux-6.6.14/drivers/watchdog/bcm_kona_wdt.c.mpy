{
  "module_name": "bcm_kona_wdt.c",
  "hash_id": "d65ac24dad2b74a0c36488ac99c0d0c4ac36411d085935d5629b1d2ace0139a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/bcm_kona_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define SECWDOG_CTRL_REG\t\t0x00000000\n#define SECWDOG_COUNT_REG\t\t0x00000004\n\n#define SECWDOG_RESERVED_MASK\t\t0x1dffffff\n#define SECWDOG_WD_LOAD_FLAG\t\t0x10000000\n#define SECWDOG_EN_MASK\t\t\t0x08000000\n#define SECWDOG_SRSTEN_MASK\t\t0x04000000\n#define SECWDOG_RES_MASK\t\t0x00f00000\n#define SECWDOG_COUNT_MASK\t\t0x000fffff\n\n#define SECWDOG_MAX_COUNT\t\tSECWDOG_COUNT_MASK\n#define SECWDOG_CLKS_SHIFT\t\t20\n#define SECWDOG_MAX_RES\t\t\t15\n#define SECWDOG_DEFAULT_RESOLUTION\t4\n#define SECWDOG_MAX_TRY\t\t\t1000\n\n#define SECS_TO_TICKS(x, w)\t\t((x) << (w)->resolution)\n#define TICKS_TO_SECS(x, w)\t\t((x) >> (w)->resolution)\n\n#define BCM_KONA_WDT_NAME\t\t\"bcm_kona_wdt\"\n\nstruct bcm_kona_wdt {\n\tvoid __iomem *base;\n\t \n\tint resolution;\n\tspinlock_t lock;\n#ifdef CONFIG_BCM_KONA_WDT_DEBUG\n\tunsigned long busy_count;\n\tstruct dentry *debugfs;\n#endif\n};\n\nstatic int secure_register_read(struct bcm_kona_wdt *wdt, uint32_t offset)\n{\n\tuint32_t val;\n\tunsigned count = 0;\n\n\t \n\tdo {\n\t\tif (unlikely(count > 1))\n\t\t\tudelay(5);\n\t\tval = readl_relaxed(wdt->base + offset);\n\t\tcount++;\n\t} while ((val & SECWDOG_WD_LOAD_FLAG) && count < SECWDOG_MAX_TRY);\n\n#ifdef CONFIG_BCM_KONA_WDT_DEBUG\n\t \n\tif (count > wdt->busy_count)\n\t\twdt->busy_count = count;\n#endif\n\n\t \n\tif (val & SECWDOG_WD_LOAD_FLAG)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tval &= SECWDOG_RESERVED_MASK;\n\n\treturn val;\n}\n\n#ifdef CONFIG_BCM_KONA_WDT_DEBUG\n\nstatic int bcm_kona_show(struct seq_file *s, void *data)\n{\n\tint ctl_val, cur_val;\n\tunsigned long flags;\n\tstruct bcm_kona_wdt *wdt = s->private;\n\n\tif (!wdt) {\n\t\tseq_puts(s, \"No device pointer\\n\");\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\tctl_val = secure_register_read(wdt, SECWDOG_CTRL_REG);\n\tcur_val = secure_register_read(wdt, SECWDOG_COUNT_REG);\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\tif (ctl_val < 0 || cur_val < 0) {\n\t\tseq_puts(s, \"Error accessing hardware\\n\");\n\t} else {\n\t\tint ctl, cur, ctl_sec, cur_sec, res;\n\n\t\tctl = ctl_val & SECWDOG_COUNT_MASK;\n\t\tres = (ctl_val & SECWDOG_RES_MASK) >> SECWDOG_CLKS_SHIFT;\n\t\tcur = cur_val & SECWDOG_COUNT_MASK;\n\t\tctl_sec = TICKS_TO_SECS(ctl, wdt);\n\t\tcur_sec = TICKS_TO_SECS(cur, wdt);\n\t\tseq_printf(s,\n\t\t\t   \"Resolution: %d / %d\\n\"\n\t\t\t   \"Control: %d s / %d (%#x) ticks\\n\"\n\t\t\t   \"Current: %d s / %d (%#x) ticks\\n\"\n\t\t\t   \"Busy count: %lu\\n\",\n\t\t\t   res, wdt->resolution,\n\t\t\t   ctl_sec, ctl, ctl,\n\t\t\t   cur_sec, cur, cur,\n\t\t\t   wdt->busy_count);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(bcm_kona);\n\nstatic void bcm_kona_wdt_debug_init(struct platform_device *pdev)\n{\n\tstruct dentry *dir;\n\tstruct bcm_kona_wdt *wdt = platform_get_drvdata(pdev);\n\n\tif (!wdt)\n\t\treturn;\n\n\twdt->debugfs = NULL;\n\n\tdir = debugfs_create_dir(BCM_KONA_WDT_NAME, NULL);\n\n\tdebugfs_create_file(\"info\", S_IFREG | S_IRUGO, dir, wdt,\n\t\t\t    &bcm_kona_fops);\n\twdt->debugfs = dir;\n}\n\nstatic void bcm_kona_wdt_debug_exit(struct platform_device *pdev)\n{\n\tstruct bcm_kona_wdt *wdt = platform_get_drvdata(pdev);\n\n\tif (wdt)\n\t\tdebugfs_remove_recursive(wdt->debugfs);\n}\n\n#else\n\nstatic void bcm_kona_wdt_debug_init(struct platform_device *pdev) {}\nstatic void bcm_kona_wdt_debug_exit(struct platform_device *pdev) {}\n\n#endif  \n\nstatic int bcm_kona_wdt_ctrl_reg_modify(struct bcm_kona_wdt *wdt,\n\t\t\t\t\tunsigned mask, unsigned newval)\n{\n\tint val;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\n\tval = secure_register_read(wdt, SECWDOG_CTRL_REG);\n\tif (val < 0) {\n\t\tret = val;\n\t} else {\n\t\tval &= ~mask;\n\t\tval |= newval;\n\t\twritel_relaxed(val, wdt->base + SECWDOG_CTRL_REG);\n\t}\n\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\treturn ret;\n}\n\nstatic int bcm_kona_wdt_set_resolution_reg(struct bcm_kona_wdt *wdt)\n{\n\tif (wdt->resolution > SECWDOG_MAX_RES)\n\t\treturn -EINVAL;\n\n\treturn bcm_kona_wdt_ctrl_reg_modify(wdt, SECWDOG_RES_MASK,\n\t\t\t\t\twdt->resolution << SECWDOG_CLKS_SHIFT);\n}\n\nstatic int bcm_kona_wdt_set_timeout_reg(struct watchdog_device *wdog,\n\t\t\t\t\tunsigned watchdog_flags)\n{\n\tstruct bcm_kona_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\treturn bcm_kona_wdt_ctrl_reg_modify(wdt, SECWDOG_COUNT_MASK,\n\t\t\t\t\tSECS_TO_TICKS(wdog->timeout, wdt) |\n\t\t\t\t\twatchdog_flags);\n}\n\nstatic int bcm_kona_wdt_set_timeout(struct watchdog_device *wdog,\n\tunsigned int t)\n{\n\twdog->timeout = t;\n\treturn 0;\n}\n\nstatic unsigned int bcm_kona_wdt_get_timeleft(struct watchdog_device *wdog)\n{\n\tstruct bcm_kona_wdt *wdt = watchdog_get_drvdata(wdog);\n\tint val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\tval = secure_register_read(wdt, SECWDOG_COUNT_REG);\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\tif (val < 0)\n\t\treturn val;\n\n\treturn TICKS_TO_SECS(val & SECWDOG_COUNT_MASK, wdt);\n}\n\nstatic int bcm_kona_wdt_start(struct watchdog_device *wdog)\n{\n\treturn bcm_kona_wdt_set_timeout_reg(wdog,\n\t\t\t\t\tSECWDOG_EN_MASK | SECWDOG_SRSTEN_MASK);\n}\n\nstatic int bcm_kona_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct bcm_kona_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\treturn bcm_kona_wdt_ctrl_reg_modify(wdt, SECWDOG_EN_MASK |\n\t\t\t\t\t    SECWDOG_SRSTEN_MASK, 0);\n}\n\nstatic const struct watchdog_ops bcm_kona_wdt_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.start =\tbcm_kona_wdt_start,\n\t.stop =\t\tbcm_kona_wdt_stop,\n\t.set_timeout =\tbcm_kona_wdt_set_timeout,\n\t.get_timeleft =\tbcm_kona_wdt_get_timeleft,\n};\n\nstatic const struct watchdog_info bcm_kona_wdt_info = {\n\t.options =\tWDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE |\n\t\t\tWDIOF_KEEPALIVEPING,\n\t.identity =\t\"Broadcom Kona Watchdog Timer\",\n};\n\nstatic struct watchdog_device bcm_kona_wdt_wdd = {\n\t.info =\t\t&bcm_kona_wdt_info,\n\t.ops =\t\t&bcm_kona_wdt_ops,\n\t.min_timeout =\t1,\n\t.max_timeout =\tSECWDOG_MAX_COUNT >> SECWDOG_DEFAULT_RESOLUTION,\n\t.timeout =\tSECWDOG_MAX_COUNT >> SECWDOG_DEFAULT_RESOLUTION,\n};\n\nstatic int bcm_kona_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm_kona_wdt *wdt;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&wdt->lock);\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\twdt->resolution = SECWDOG_DEFAULT_RESOLUTION;\n\tret = bcm_kona_wdt_set_resolution_reg(wdt);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set resolution (error: %d)\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, wdt);\n\twatchdog_set_drvdata(&bcm_kona_wdt_wdd, wdt);\n\tbcm_kona_wdt_wdd.parent = dev;\n\n\tret = bcm_kona_wdt_set_timeout_reg(&bcm_kona_wdt_wdd, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed set watchdog timeout\");\n\t\treturn ret;\n\t}\n\n\twatchdog_stop_on_reboot(&bcm_kona_wdt_wdd);\n\twatchdog_stop_on_unregister(&bcm_kona_wdt_wdd);\n\tret = devm_watchdog_register_device(dev, &bcm_kona_wdt_wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tbcm_kona_wdt_debug_init(pdev);\n\tdev_dbg(dev, \"Broadcom Kona Watchdog Timer\");\n\n\treturn 0;\n}\n\nstatic void bcm_kona_wdt_remove(struct platform_device *pdev)\n{\n\tbcm_kona_wdt_debug_exit(pdev);\n\tdev_dbg(&pdev->dev, \"Watchdog driver disabled\");\n}\n\nstatic const struct of_device_id bcm_kona_wdt_of_match[] = {\n\t{ .compatible = \"brcm,kona-wdt\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm_kona_wdt_of_match);\n\nstatic struct platform_driver bcm_kona_wdt_driver = {\n\t.driver = {\n\t\t\t.name = BCM_KONA_WDT_NAME,\n\t\t\t.of_match_table = bcm_kona_wdt_of_match,\n\t\t  },\n\t.probe = bcm_kona_wdt_probe,\n\t.remove_new = bcm_kona_wdt_remove,\n};\n\nmodule_platform_driver(bcm_kona_wdt_driver);\n\nMODULE_ALIAS(\"platform:\" BCM_KONA_WDT_NAME);\nMODULE_AUTHOR(\"Markus Mayer <mmayer@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom Kona Watchdog Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}