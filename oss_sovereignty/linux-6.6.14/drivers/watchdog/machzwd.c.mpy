{
  "module_name": "machzwd.c",
  "hash_id": "5805a310b2b11dba1c9029cedaffe78b20b32195929a09e68c2636485033b18d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/machzwd.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n\n \n#define ZF_IOBASE\t0x218\n#define INDEX\t\t0x218\n#define DATA_B\t\t0x219\n#define DATA_W\t\t0x21A\n#define DATA_D\t\t0x21A\n\n \t\t\t \n#define ZFL_VERSION\t0x02\t \n#define CONTROL\t\t0x10\t \n#define STATUS\t\t0x12\t \n#define COUNTER_1\t0x0C\t \n#define COUNTER_2\t0x0E\t \n#define PULSE_LEN\t0x0F\t \n\n \n#define ENABLE_WD1\t0x0001\n#define ENABLE_WD2\t0x0002\n#define RESET_WD1\t0x0010\n#define RESET_WD2\t0x0020\n#define GEN_SCI\t\t0x0100\n#define GEN_NMI\t\t0x0200\n#define GEN_SMI\t\t0x0400\n#define GEN_RESET\t0x0800\n\n\n \n\n#define WD1\t0\n#define WD2\t1\n\n#define zf_writew(port, data)  { outb(port, INDEX); outw(data, DATA_W); }\n#define zf_writeb(port, data)  { outb(port, INDEX); outb(data, DATA_B); }\n#define zf_get_ZFL_version()   zf_readw(ZFL_VERSION)\n\n\nstatic unsigned short zf_readw(unsigned char port)\n{\n\toutb(port, INDEX);\n\treturn inw(DATA_W);\n}\n\n\nMODULE_AUTHOR(\"Fernando Fuganti <fuganti@conectiva.com.br>\");\nMODULE_DESCRIPTION(\"MachZ ZF-Logic Watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n#define PFX \"machzwd\"\n\nstatic const struct watchdog_info zf_info = {\n\t.options\t\t= WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.firmware_version\t= 1,\n\t.identity\t\t= \"ZF-Logic watchdog\",\n};\n\n\n \nstatic int action;\nmodule_param(action, int, 0);\nMODULE_PARM_DESC(action, \"after watchdog resets, generate: \"\n\t\t\t\t\"0 = RESET(*)  1 = SMI  2 = NMI  3 = SCI\");\n\nstatic void zf_ping(struct timer_list *unused);\n\nstatic int zf_action = GEN_RESET;\nstatic unsigned long zf_is_open;\nstatic char zf_expect_close;\nstatic DEFINE_SPINLOCK(zf_port_lock);\nstatic DEFINE_TIMER(zf_timer, zf_ping);\nstatic unsigned long next_heartbeat;\n\n\n \n#define ZF_USER_TIMEO (HZ*10)\n\n \n#define ZF_HW_TIMEO (HZ/2)\n\n \n#define ZF_CTIMEOUT 0xffff\n\n#ifndef ZF_DEBUG\n#define dprintk(format, args...)\n#else\n#define dprintk(format, args...)\t\t\t\t\t\\\n\tpr_debug(\":%s:%d: \" format, __func__, __LINE__ , ## args)\n#endif\n\n\nstatic inline void zf_set_status(unsigned char new)\n{\n\tzf_writeb(STATUS, new);\n}\n\n\n \n\nstatic inline unsigned short zf_get_control(void)\n{\n\treturn zf_readw(CONTROL);\n}\n\nstatic inline void zf_set_control(unsigned short new)\n{\n\tzf_writew(CONTROL, new);\n}\n\n\n \n \n\nstatic inline void zf_set_timer(unsigned short new, unsigned char n)\n{\n\tswitch (n) {\n\tcase WD1:\n\t\tzf_writew(COUNTER_1, new);\n\t\tfallthrough;\n\tcase WD2:\n\t\tzf_writeb(COUNTER_2, new > 0xff ? 0xff : new);\n\t\tfallthrough;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nstatic void zf_timer_off(void)\n{\n\tunsigned int ctrl_reg = 0;\n\tunsigned long flags;\n\n\t \n\tdel_timer_sync(&zf_timer);\n\n\tspin_lock_irqsave(&zf_port_lock, flags);\n\t \n\tctrl_reg = zf_get_control();\n\tctrl_reg |= (ENABLE_WD1|ENABLE_WD2);\t \n\tctrl_reg &= ~(ENABLE_WD1|ENABLE_WD2);\n\tzf_set_control(ctrl_reg);\n\tspin_unlock_irqrestore(&zf_port_lock, flags);\n\n\tpr_info(\"Watchdog timer is now disabled\\n\");\n}\n\n\n \nstatic void zf_timer_on(void)\n{\n\tunsigned int ctrl_reg = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&zf_port_lock, flags);\n\n\tzf_writeb(PULSE_LEN, 0xff);\n\n\tzf_set_timer(ZF_CTIMEOUT, WD1);\n\n\t \n\tnext_heartbeat = jiffies + ZF_USER_TIMEO;\n\n\t \n\tmod_timer(&zf_timer, jiffies + ZF_HW_TIMEO);\n\n\t \n\tctrl_reg = zf_get_control();\n\tctrl_reg |= (ENABLE_WD1|zf_action);\n\tzf_set_control(ctrl_reg);\n\tspin_unlock_irqrestore(&zf_port_lock, flags);\n\n\tpr_info(\"Watchdog timer is now enabled\\n\");\n}\n\n\nstatic void zf_ping(struct timer_list *unused)\n{\n\tunsigned int ctrl_reg = 0;\n\tunsigned long flags;\n\n\tzf_writeb(COUNTER_2, 0xff);\n\n\tif (time_before(jiffies, next_heartbeat)) {\n\t\tdprintk(\"time_before: %ld\\n\", next_heartbeat - jiffies);\n\t\t \n\n\t\tspin_lock_irqsave(&zf_port_lock, flags);\n\t\tctrl_reg = zf_get_control();\n\t\tctrl_reg |= RESET_WD1;\n\t\tzf_set_control(ctrl_reg);\n\n\t\t \n\t\tctrl_reg &= ~(RESET_WD1);\n\t\tzf_set_control(ctrl_reg);\n\t\tspin_unlock_irqrestore(&zf_port_lock, flags);\n\n\t\tmod_timer(&zf_timer, jiffies + ZF_HW_TIMEO);\n\t} else\n\t\tpr_crit(\"I will reset your machine\\n\");\n}\n\nstatic ssize_t zf_write(struct file *file, const char __user *buf, size_t count,\n\t\t\t\t\t\t\t\tloff_t *ppos)\n{\n\t \n\tif (count) {\n\t\t \n\t\tif (!nowayout) {\n\t\t\tsize_t ofs;\n\t\t\t \n\t\t\tzf_expect_close = 0;\n\n\t\t\t \n\t\t\tfor (ofs = 0; ofs != count; ofs++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + ofs))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V') {\n\t\t\t\t\tzf_expect_close = 42;\n\t\t\t\t\tdprintk(\"zf_expect_close = 42\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tnext_heartbeat = jiffies + ZF_USER_TIMEO;\n\t\tdprintk(\"user ping at %ld\\n\", jiffies);\n\t}\n\treturn count;\n}\n\nstatic long zf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &zf_info, sizeof(zf_info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_KEEPALIVE:\n\t\tzf_ping(NULL);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic int zf_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &zf_is_open))\n\t\treturn -EBUSY;\n\tif (nowayout)\n\t\t__module_get(THIS_MODULE);\n\tzf_timer_on();\n\treturn stream_open(inode, file);\n}\n\nstatic int zf_close(struct inode *inode, struct file *file)\n{\n\tif (zf_expect_close == 42)\n\t\tzf_timer_off();\n\telse {\n\t\tdel_timer(&zf_timer);\n\t\tpr_err(\"device file closed unexpectedly. Will not stop the WDT!\\n\");\n\t}\n\tclear_bit(0, &zf_is_open);\n\tzf_expect_close = 0;\n\treturn 0;\n}\n\n \n\nstatic int zf_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t\t\t\t\t\tvoid *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\tzf_timer_off();\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct file_operations zf_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= zf_write,\n\t.unlocked_ioctl = zf_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= zf_open,\n\t.release\t= zf_close,\n};\n\nstatic struct miscdevice zf_miscdev = {\n\t.minor = WATCHDOG_MINOR,\n\t.name = \"watchdog\",\n\t.fops = &zf_fops,\n};\n\n\n \nstatic struct notifier_block zf_notifier = {\n\t.notifier_call = zf_notify_sys,\n};\n\nstatic void __init zf_show_action(int act)\n{\n\tstatic const char * const str[] = { \"RESET\", \"SMI\", \"NMI\", \"SCI\" };\n\n\tpr_info(\"Watchdog using action = %s\\n\", str[act]);\n}\n\nstatic int __init zf_init(void)\n{\n\tint ret;\n\n\tpr_info(\"MachZ ZF-Logic Watchdog driver initializing\\n\");\n\n\tret = zf_get_ZFL_version();\n\tif (!ret || ret == 0xffff) {\n\t\tpr_warn(\"no ZF-Logic found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (action <= 3 && action >= 0)\n\t\tzf_action = zf_action >> action;\n\telse\n\t\taction = 0;\n\n\tzf_show_action(action);\n\n\tif (!request_region(ZF_IOBASE, 3, \"MachZ ZFL WDT\")) {\n\t\tpr_err(\"cannot reserve I/O ports at %d\\n\", ZF_IOBASE);\n\t\tret = -EBUSY;\n\t\tgoto no_region;\n\t}\n\n\tret = register_reboot_notifier(&zf_notifier);\n\tif (ret) {\n\t\tpr_err(\"can't register reboot notifier (err=%d)\\n\", ret);\n\t\tgoto no_reboot;\n\t}\n\n\tret = misc_register(&zf_miscdev);\n\tif (ret) {\n\t\tpr_err(\"can't misc_register on minor=%d\\n\", WATCHDOG_MINOR);\n\t\tgoto no_misc;\n\t}\n\n\tzf_set_status(0);\n\tzf_set_control(0);\n\n\treturn 0;\n\nno_misc:\n\tunregister_reboot_notifier(&zf_notifier);\nno_reboot:\n\trelease_region(ZF_IOBASE, 3);\nno_region:\n\treturn ret;\n}\n\n\nstatic void __exit zf_exit(void)\n{\n\tzf_timer_off();\n\n\tmisc_deregister(&zf_miscdev);\n\tunregister_reboot_notifier(&zf_notifier);\n\trelease_region(ZF_IOBASE, 3);\n}\n\nmodule_init(zf_init);\nmodule_exit(zf_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}