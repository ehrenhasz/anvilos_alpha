{
  "module_name": "rave-sp-wdt.c",
  "hash_id": "44ed4552b6ff27abb15f57e0e2a03e277ce12ddbd7a397fe20fcc216760e929d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rave-sp-wdt.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/mfd/rave-sp.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/watchdog.h>\n\nenum {\n\tRAVE_SP_RESET_BYTE = 1,\n\tRAVE_SP_RESET_REASON_NORMAL = 0,\n\tRAVE_SP_RESET_DELAY_MS = 500,\n};\n\n \nstruct rave_sp_wdt_variant {\n\tunsigned int max_timeout;\n\tunsigned int min_timeout;\n\n\tint (*configure)(struct watchdog_device *, bool);\n\tint (*restart)(struct watchdog_device *);\n};\n\n \nstruct rave_sp_wdt {\n\tstruct watchdog_device wdd;\n\tstruct rave_sp *sp;\n\tconst struct rave_sp_wdt_variant *variant;\n\tstruct notifier_block reboot_notifier;\n};\n\nstatic struct rave_sp_wdt *to_rave_sp_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct rave_sp_wdt, wdd);\n}\n\nstatic int rave_sp_wdt_exec(struct watchdog_device *wdd, void *data,\n\t\t\t    size_t data_size)\n{\n\treturn rave_sp_exec(to_rave_sp_wdt(wdd)->sp,\n\t\t\t    data, data_size, NULL, 0);\n}\n\nstatic int rave_sp_wdt_legacy_configure(struct watchdog_device *wdd, bool on)\n{\n\tu8 cmd[] = {\n\t\t[0] = RAVE_SP_CMD_SW_WDT,\n\t\t[1] = 0,\n\t\t[2] = 0,\n\t\t[3] = on,\n\t\t[4] = on ? wdd->timeout : 0,\n\t};\n\n\treturn rave_sp_wdt_exec(wdd, cmd, sizeof(cmd));\n}\n\nstatic int rave_sp_wdt_rdu_configure(struct watchdog_device *wdd, bool on)\n{\n\tu8 cmd[] = {\n\t\t[0] = RAVE_SP_CMD_SW_WDT,\n\t\t[1] = 0,\n\t\t[2] = on,\n\t\t[3] = (u8)wdd->timeout,\n\t\t[4] = (u8)(wdd->timeout >> 8),\n\t};\n\n\treturn rave_sp_wdt_exec(wdd, cmd, sizeof(cmd));\n}\n\n \nstatic int rave_sp_wdt_configure(struct watchdog_device *wdd, bool on)\n{\n\treturn to_rave_sp_wdt(wdd)->variant->configure(wdd, on);\n}\n\nstatic int rave_sp_wdt_legacy_restart(struct watchdog_device *wdd)\n{\n\tu8 cmd[] = {\n\t\t[0] = RAVE_SP_CMD_RESET,\n\t\t[1] = 0,\n\t\t[2] = RAVE_SP_RESET_BYTE\n\t};\n\n\treturn rave_sp_wdt_exec(wdd, cmd, sizeof(cmd));\n}\n\nstatic int rave_sp_wdt_rdu_restart(struct watchdog_device *wdd)\n{\n\tu8 cmd[] = {\n\t\t[0] = RAVE_SP_CMD_RESET,\n\t\t[1] = 0,\n\t\t[2] = RAVE_SP_RESET_BYTE,\n\t\t[3] = RAVE_SP_RESET_REASON_NORMAL\n\t};\n\n\treturn rave_sp_wdt_exec(wdd, cmd, sizeof(cmd));\n}\n\nstatic int rave_sp_wdt_reboot_notifier(struct notifier_block *nb,\n\t\t\t\t       unsigned long action, void *data)\n{\n\t \n\tif (action == SYS_DOWN || action == SYS_HALT) {\n\t\tstruct rave_sp_wdt *sp_wd =\n\t\t\tcontainer_of(nb, struct rave_sp_wdt, reboot_notifier);\n\n\t\tconst int ret = sp_wd->variant->restart(&sp_wd->wdd);\n\n\t\tif (ret < 0)\n\t\t\tdev_err(sp_wd->wdd.parent,\n\t\t\t\t\"Failed to issue restart command (%d)\", ret);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int rave_sp_wdt_restart(struct watchdog_device *wdd,\n\t\t\t       unsigned long action, void *data)\n{\n\t \n\tmdelay(2 * RAVE_SP_RESET_DELAY_MS);\n\n\treturn -EIO;\n}\n\nstatic int rave_sp_wdt_start(struct watchdog_device *wdd)\n{\n\tint ret;\n\n\tret = rave_sp_wdt_configure(wdd, true);\n\tif (!ret)\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\n\treturn ret;\n}\n\nstatic int rave_sp_wdt_stop(struct watchdog_device *wdd)\n{\n\treturn rave_sp_wdt_configure(wdd, false);\n}\n\nstatic int rave_sp_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t   unsigned int timeout)\n{\n\twdd->timeout = timeout;\n\n\treturn rave_sp_wdt_configure(wdd, watchdog_active(wdd));\n}\n\nstatic int rave_sp_wdt_ping(struct watchdog_device *wdd)\n{\n\tu8 cmd[] = {\n\t\t[0] = RAVE_SP_CMD_PET_WDT,\n\t\t[1] = 0,\n\t};\n\n\treturn rave_sp_wdt_exec(wdd, cmd, sizeof(cmd));\n}\n\nstatic const struct watchdog_info rave_sp_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"RAVE SP Watchdog\",\n};\n\nstatic const struct watchdog_ops rave_sp_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = rave_sp_wdt_start,\n\t.stop = rave_sp_wdt_stop,\n\t.ping = rave_sp_wdt_ping,\n\t.set_timeout = rave_sp_wdt_set_timeout,\n\t.restart = rave_sp_wdt_restart,\n};\n\nstatic const struct rave_sp_wdt_variant rave_sp_wdt_legacy = {\n\t.max_timeout = 255,\n\t.min_timeout = 1,\n\t.configure = rave_sp_wdt_legacy_configure,\n\t.restart   = rave_sp_wdt_legacy_restart,\n};\n\nstatic const struct rave_sp_wdt_variant rave_sp_wdt_rdu = {\n\t.max_timeout = 180,\n\t.min_timeout = 60,\n\t.configure = rave_sp_wdt_rdu_configure,\n\t.restart   = rave_sp_wdt_rdu_restart,\n};\n\nstatic const struct of_device_id rave_sp_wdt_of_match[] = {\n\t{\n\t\t.compatible = \"zii,rave-sp-watchdog-legacy\",\n\t\t.data = &rave_sp_wdt_legacy,\n\t},\n\t{\n\t\t.compatible = \"zii,rave-sp-watchdog\",\n\t\t.data = &rave_sp_wdt_rdu,\n\t},\n\t{   }\n};\n\nstatic int rave_sp_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct rave_sp_wdt *sp_wd;\n\tstruct nvmem_cell *cell;\n\t__le16 timeout = 0;\n\tint ret;\n\n\tsp_wd = devm_kzalloc(dev, sizeof(*sp_wd), GFP_KERNEL);\n\tif (!sp_wd)\n\t\treturn -ENOMEM;\n\n\tsp_wd->variant = of_device_get_match_data(dev);\n\tsp_wd->sp      = dev_get_drvdata(dev->parent);\n\n\twdd              = &sp_wd->wdd;\n\twdd->parent      = dev;\n\twdd->info        = &rave_sp_wdt_info;\n\twdd->ops         = &rave_sp_wdt_ops;\n\twdd->min_timeout = sp_wd->variant->min_timeout;\n\twdd->max_timeout = sp_wd->variant->max_timeout;\n\twdd->status      = WATCHDOG_NOWAYOUT_INIT_STATUS;\n\twdd->timeout     = 60;\n\n\tcell = nvmem_cell_get(dev, \"wdt-timeout\");\n\tif (!IS_ERR(cell)) {\n\t\tsize_t len;\n\t\tvoid *value = nvmem_cell_read(cell, &len);\n\n\t\tif (!IS_ERR(value)) {\n\t\t\tmemcpy(&timeout, value, min(len, sizeof(timeout)));\n\t\t\tkfree(value);\n\t\t}\n\t\tnvmem_cell_put(cell);\n\t}\n\twatchdog_init_timeout(wdd, le16_to_cpu(timeout), dev);\n\twatchdog_set_restart_priority(wdd, 255);\n\twatchdog_stop_on_unregister(wdd);\n\n\tsp_wd->reboot_notifier.notifier_call = rave_sp_wdt_reboot_notifier;\n\tret = devm_register_reboot_notifier(dev, &sp_wd->reboot_notifier);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register reboot notifier\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twdd->max_hw_heartbeat_ms = wdd->max_timeout * 1000;\n\tret = rave_sp_wdt_start(wdd);\n\tif (ret) {\n\t\tdev_err(dev, \"Watchdog didn't start\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret) {\n\t\trave_sp_wdt_stop(wdd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver rave_sp_wdt_driver = {\n\t.probe = rave_sp_wdt_probe,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = rave_sp_wdt_of_match,\n\t},\n};\n\nmodule_platform_driver(rave_sp_wdt_driver);\n\nMODULE_DEVICE_TABLE(of, rave_sp_wdt_of_match);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrey Vostrikov <andrey.vostrikov@cogentembedded.com>\");\nMODULE_AUTHOR(\"Nikita Yushchenko <nikita.yoush@cogentembedded.com>\");\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_DESCRIPTION(\"RAVE SP Watchdog driver\");\nMODULE_ALIAS(\"platform:rave-sp-watchdog\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}