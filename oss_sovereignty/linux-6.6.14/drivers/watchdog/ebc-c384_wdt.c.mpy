{
  "module_name": "ebc-c384_wdt.c",
  "hash_id": "0de9776cab8086fa9a98b59ac6d9d08e8fadf8ab34bacde54d729d7d5502480f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ebc-c384_wdt.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/isa.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#define MODULE_NAME\t\t\"ebc-c384_wdt\"\n#define WATCHDOG_TIMEOUT\t60\n \n#define WATCHDOG_MAX_TIMEOUT\t15300\n#define BASE_ADDR\t\t0x564\n#define ADDR_EXTENT\t\t5\n#define CFG_ADDR\t\t(BASE_ADDR + 1)\n#define PET_ADDR\t\t(BASE_ADDR + 2)\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic unsigned timeout;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds (default=\"\n\t__MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic int ebc_c384_wdt_start(struct watchdog_device *wdev)\n{\n\tunsigned t = wdev->timeout;\n\n\t \n\tif (t > 255)\n\t\tt = DIV_ROUND_UP(t, 60);\n\n\toutb(t, PET_ADDR);\n\n\treturn 0;\n}\n\nstatic int ebc_c384_wdt_stop(struct watchdog_device *wdev)\n{\n\toutb(0x00, PET_ADDR);\n\n\treturn 0;\n}\n\nstatic int ebc_c384_wdt_set_timeout(struct watchdog_device *wdev, unsigned t)\n{\n\t \n\tif (t > 255) {\n\t\t \n\t\twdev->timeout = roundup(t, 60);\n\n\t\t \n\t\toutb(0x00, CFG_ADDR);\n\t} else {\n\t\twdev->timeout = t;\n\n\t\t \n\t\toutb(0x80, CFG_ADDR);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops ebc_c384_wdt_ops = {\n\t.start = ebc_c384_wdt_start,\n\t.stop = ebc_c384_wdt_stop,\n\t.set_timeout = ebc_c384_wdt_set_timeout\n};\n\nstatic const struct watchdog_info ebc_c384_wdt_info = {\n\t.options = WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT,\n\t.identity = MODULE_NAME\n};\n\nstatic int ebc_c384_wdt_probe(struct device *dev, unsigned int id)\n{\n\tstruct watchdog_device *wdd;\n\n\tif (!devm_request_region(dev, BASE_ADDR, ADDR_EXTENT, dev_name(dev))) {\n\t\tdev_err(dev, \"Unable to lock port addresses (0x%X-0x%X)\\n\",\n\t\t\tBASE_ADDR, BASE_ADDR + ADDR_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\twdd = devm_kzalloc(dev, sizeof(*wdd), GFP_KERNEL);\n\tif (!wdd)\n\t\treturn -ENOMEM;\n\n\twdd->info = &ebc_c384_wdt_info;\n\twdd->ops = &ebc_c384_wdt_ops;\n\twdd->timeout = WATCHDOG_TIMEOUT;\n\twdd->min_timeout = 1;\n\twdd->max_timeout = WATCHDOG_MAX_TIMEOUT;\n\n\twatchdog_set_nowayout(wdd, nowayout);\n\twatchdog_init_timeout(wdd, timeout, dev);\n\n\treturn devm_watchdog_register_device(dev, wdd);\n}\n\nstatic struct isa_driver ebc_c384_wdt_driver = {\n\t.probe = ebc_c384_wdt_probe,\n\t.driver = {\n\t\t.name = MODULE_NAME\n\t},\n};\n\nstatic int __init ebc_c384_wdt_init(void)\n{\n\tif (!dmi_match(DMI_BOARD_NAME, \"EBC-C384 SBC\"))\n\t\treturn -ENODEV;\n\n\treturn isa_register_driver(&ebc_c384_wdt_driver, 1);\n}\n\nstatic void __exit ebc_c384_wdt_exit(void)\n{\n\tisa_unregister_driver(&ebc_c384_wdt_driver);\n}\n\nmodule_init(ebc_c384_wdt_init);\nmodule_exit(ebc_c384_wdt_exit);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"WinSystems EBC-C384 watchdog timer driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"isa:\" MODULE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}