{
  "module_name": "keembay_wdt.c",
  "hash_id": "74f7de80bbe30d7a0ad89385768c97175ce186e7a2dce3e034e4253c531d5500",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/keembay_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/watchdog.h>\n\n \n#define TIM_WATCHDOG\t\t0x0\n#define TIM_WATCHDOG_INT_THRES\t0x4\n#define TIM_WDOG_EN\t\t0x8\n#define TIM_SAFE\t\t0xc\n\n#define WDT_TH_INT_MASK\t\tBIT(8)\n#define WDT_TO_INT_MASK\t\tBIT(9)\n#define WDT_INT_CLEAR_SMC\t0x8200ff18\n\n#define WDT_UNLOCK\t\t0xf1d0dead\n#define WDT_DISABLE\t\t0x0\n#define WDT_ENABLE\t\t0x1\n\n#define WDT_LOAD_MAX\t\tU32_MAX\n#define WDT_LOAD_MIN\t\t1\n\n#define WDT_TIMEOUT\t\t5\n#define WDT_PRETIMEOUT\t\t4\n\nstatic unsigned int timeout = WDT_TIMEOUT;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout period in seconds (default = \"\n\t\t __MODULE_STRING(WDT_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default = \"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct keembay_wdt {\n\tstruct watchdog_device\twdd;\n\tstruct clk\t\t*clk;\n\tunsigned int\t\trate;\n\tint\t\t\tto_irq;\n\tint\t\t\tth_irq;\n\tvoid __iomem\t\t*base;\n};\n\nstatic inline u32 keembay_wdt_readl(struct keembay_wdt *wdt, u32 offset)\n{\n\treturn readl(wdt->base + offset);\n}\n\nstatic inline void keembay_wdt_writel(struct keembay_wdt *wdt, u32 offset, u32 val)\n{\n\twritel(WDT_UNLOCK, wdt->base + TIM_SAFE);\n\twritel(val, wdt->base + offset);\n}\n\nstatic void keembay_wdt_set_timeout_reg(struct watchdog_device *wdog)\n{\n\tstruct keembay_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\tkeembay_wdt_writel(wdt, TIM_WATCHDOG, wdog->timeout * wdt->rate);\n}\n\nstatic void keembay_wdt_set_pretimeout_reg(struct watchdog_device *wdog)\n{\n\tstruct keembay_wdt *wdt = watchdog_get_drvdata(wdog);\n\tu32 th_val = 0;\n\n\tif (wdog->pretimeout)\n\t\tth_val = wdog->timeout - wdog->pretimeout;\n\n\tkeembay_wdt_writel(wdt, TIM_WATCHDOG_INT_THRES, th_val * wdt->rate);\n}\n\nstatic int keembay_wdt_start(struct watchdog_device *wdog)\n{\n\tstruct keembay_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\tkeembay_wdt_writel(wdt, TIM_WDOG_EN, WDT_ENABLE);\n\n\treturn 0;\n}\n\nstatic int keembay_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct keembay_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\tkeembay_wdt_writel(wdt, TIM_WDOG_EN, WDT_DISABLE);\n\n\treturn 0;\n}\n\nstatic int keembay_wdt_ping(struct watchdog_device *wdog)\n{\n\tkeembay_wdt_set_timeout_reg(wdog);\n\n\treturn 0;\n}\n\nstatic int keembay_wdt_set_timeout(struct watchdog_device *wdog, u32 t)\n{\n\twdog->timeout = t;\n\tkeembay_wdt_set_timeout_reg(wdog);\n\tkeembay_wdt_set_pretimeout_reg(wdog);\n\n\treturn 0;\n}\n\nstatic int keembay_wdt_set_pretimeout(struct watchdog_device *wdog, u32 t)\n{\n\tif (t > wdog->timeout)\n\t\treturn -EINVAL;\n\n\twdog->pretimeout = t;\n\tkeembay_wdt_set_pretimeout_reg(wdog);\n\n\treturn 0;\n}\n\nstatic unsigned int keembay_wdt_get_timeleft(struct watchdog_device *wdog)\n{\n\tstruct keembay_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\treturn keembay_wdt_readl(wdt, TIM_WATCHDOG) / wdt->rate;\n}\n\n \nstatic irqreturn_t keembay_wdt_to_isr(int irq, void *dev_id)\n{\n\tstruct keembay_wdt *wdt = dev_id;\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(WDT_INT_CLEAR_SMC, WDT_TO_INT_MASK, 0, 0, 0, 0, 0, 0, &res);\n\tdev_crit(wdt->wdd.parent, \"Intel Keem Bay non-secure wdt timeout.\\n\");\n\temergency_restart();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t keembay_wdt_th_isr(int irq, void *dev_id)\n{\n\tstruct keembay_wdt *wdt = dev_id;\n\tstruct arm_smccc_res res;\n\n\tkeembay_wdt_set_pretimeout(&wdt->wdd, 0x0);\n\n\tarm_smccc_smc(WDT_INT_CLEAR_SMC, WDT_TH_INT_MASK, 0, 0, 0, 0, 0, 0, &res);\n\tdev_crit(wdt->wdd.parent, \"Intel Keem Bay non-secure wdt pre-timeout.\\n\");\n\twatchdog_notify_pretimeout(&wdt->wdd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct watchdog_info keembay_wdt_info = {\n\t.identity\t= \"Intel Keem Bay Watchdog Timer\",\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_PRETIMEOUT |\n\t\t\t  WDIOF_MAGICCLOSE |\n\t\t\t  WDIOF_KEEPALIVEPING,\n};\n\nstatic const struct watchdog_ops keembay_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= keembay_wdt_start,\n\t.stop\t\t= keembay_wdt_stop,\n\t.ping\t\t= keembay_wdt_ping,\n\t.set_timeout\t= keembay_wdt_set_timeout,\n\t.set_pretimeout\t= keembay_wdt_set_pretimeout,\n\t.get_timeleft\t= keembay_wdt_get_timeleft,\n};\n\nstatic int keembay_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct keembay_wdt *wdt;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\t \n\twdt->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(wdt->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(wdt->clk), \"Failed to get clock\\n\");\n\n\twdt->rate = clk_get_rate(wdt->clk);\n\tif (!wdt->rate)\n\t\treturn dev_err_probe(dev, -EINVAL, \"Failed to get clock rate\\n\");\n\n\twdt->th_irq = platform_get_irq_byname(pdev, \"threshold\");\n\tif (wdt->th_irq < 0)\n\t\treturn dev_err_probe(dev, wdt->th_irq, \"Failed to get IRQ for threshold\\n\");\n\n\tret = devm_request_irq(dev, wdt->th_irq, keembay_wdt_th_isr, 0,\n\t\t\t       \"keembay-wdt\", wdt);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to request IRQ for threshold\\n\");\n\n\twdt->to_irq = platform_get_irq_byname(pdev, \"timeout\");\n\tif (wdt->to_irq < 0)\n\t\treturn dev_err_probe(dev, wdt->to_irq, \"Failed to get IRQ for timeout\\n\");\n\n\tret = devm_request_irq(dev, wdt->to_irq, keembay_wdt_to_isr, 0,\n\t\t\t       \"keembay-wdt\", wdt);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to request IRQ for timeout\\n\");\n\n\twdt->wdd.parent\t\t= dev;\n\twdt->wdd.info\t\t= &keembay_wdt_info;\n\twdt->wdd.ops\t\t= &keembay_wdt_ops;\n\twdt->wdd.min_timeout\t= WDT_LOAD_MIN;\n\twdt->wdd.max_timeout\t= WDT_LOAD_MAX / wdt->rate;\n\twdt->wdd.timeout\t= WDT_TIMEOUT;\n\twdt->wdd.pretimeout\t= WDT_PRETIMEOUT;\n\n\twatchdog_set_drvdata(&wdt->wdd, wdt);\n\twatchdog_set_nowayout(&wdt->wdd, nowayout);\n\twatchdog_init_timeout(&wdt->wdd, timeout, dev);\n\tkeembay_wdt_set_timeout(&wdt->wdd, wdt->wdd.timeout);\n\tkeembay_wdt_set_pretimeout(&wdt->wdd, wdt->wdd.pretimeout);\n\n\tret = devm_watchdog_register_device(dev, &wdt->wdd);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to register watchdog device.\\n\");\n\n\tplatform_set_drvdata(pdev, wdt);\n\tdev_info(dev, \"Initial timeout %d sec%s.\\n\",\n\t\t wdt->wdd.timeout, nowayout ? \", nowayout\" : \"\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused keembay_wdt_suspend(struct device *dev)\n{\n\tstruct keembay_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\treturn keembay_wdt_stop(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused keembay_wdt_resume(struct device *dev)\n{\n\tstruct keembay_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\treturn keembay_wdt_start(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(keembay_wdt_pm_ops, keembay_wdt_suspend,\n\t\t\t keembay_wdt_resume);\n\nstatic const struct of_device_id keembay_wdt_match[] = {\n\t{ .compatible = \"intel,keembay-wdt\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, keembay_wdt_match);\n\nstatic struct platform_driver keembay_wdt_driver = {\n\t.probe\t= keembay_wdt_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"keembay_wdt\",\n\t\t.of_match_table\t= keembay_wdt_match,\n\t\t.pm\t\t= &keembay_wdt_pm_ops,\n\t},\n};\n\nmodule_platform_driver(keembay_wdt_driver);\n\nMODULE_DESCRIPTION(\"Intel Keem Bay SoC watchdog driver\");\nMODULE_AUTHOR(\"Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}