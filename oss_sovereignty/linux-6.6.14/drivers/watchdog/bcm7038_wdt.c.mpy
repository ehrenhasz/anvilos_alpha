{
  "module_name": "bcm7038_wdt.c",
  "hash_id": "a9865742b663768c96f9cd2547bc7e5b53010ac97011ddf7046787299eba98b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/bcm7038_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/bcm7038_wdt.h>\n#include <linux/pm.h>\n#include <linux/watchdog.h>\n\n#define WDT_START_1\t\t0xff00\n#define WDT_START_2\t\t0x00ff\n#define WDT_STOP_1\t\t0xee00\n#define WDT_STOP_2\t\t0x00ee\n\n#define WDT_TIMEOUT_REG\t\t0x0\n#define WDT_CMD_REG\t\t0x4\n\n#define WDT_MIN_TIMEOUT\t\t1  \n#define WDT_DEFAULT_TIMEOUT\t30  \n#define WDT_DEFAULT_RATE\t27000000\n\nstruct bcm7038_watchdog {\n\tvoid __iomem\t\t*base;\n\tstruct watchdog_device\twdd;\n\tu32\t\t\trate;\n\tstruct clk\t\t*clk;\n};\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\nstatic inline void bcm7038_wdt_write(u32 value, void __iomem *addr)\n{\n\t \n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\t__raw_writel(value, addr);\n\telse\n\t\twritel_relaxed(value, addr);\n}\n\nstatic inline u32 bcm7038_wdt_read(void __iomem *addr)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\treturn __raw_readl(addr);\n\telse\n\t\treturn readl_relaxed(addr);\n}\n\nstatic void bcm7038_wdt_set_timeout_reg(struct watchdog_device *wdog)\n{\n\tstruct bcm7038_watchdog *wdt = watchdog_get_drvdata(wdog);\n\tu32 timeout;\n\n\ttimeout = wdt->rate * wdog->timeout;\n\n\tbcm7038_wdt_write(timeout, wdt->base + WDT_TIMEOUT_REG);\n}\n\nstatic int bcm7038_wdt_ping(struct watchdog_device *wdog)\n{\n\tstruct bcm7038_watchdog *wdt = watchdog_get_drvdata(wdog);\n\n\tbcm7038_wdt_write(WDT_START_1, wdt->base + WDT_CMD_REG);\n\tbcm7038_wdt_write(WDT_START_2, wdt->base + WDT_CMD_REG);\n\n\treturn 0;\n}\n\nstatic int bcm7038_wdt_start(struct watchdog_device *wdog)\n{\n\tbcm7038_wdt_set_timeout_reg(wdog);\n\tbcm7038_wdt_ping(wdog);\n\n\treturn 0;\n}\n\nstatic int bcm7038_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct bcm7038_watchdog *wdt = watchdog_get_drvdata(wdog);\n\n\tbcm7038_wdt_write(WDT_STOP_1, wdt->base + WDT_CMD_REG);\n\tbcm7038_wdt_write(WDT_STOP_2, wdt->base + WDT_CMD_REG);\n\n\treturn 0;\n}\n\nstatic int bcm7038_wdt_set_timeout(struct watchdog_device *wdog,\n\t\t\t\t   unsigned int t)\n{\n\t \n\tbcm7038_wdt_stop(wdog);\n\twdog->timeout = t;\n\tbcm7038_wdt_start(wdog);\n\n\treturn 0;\n}\n\nstatic unsigned int bcm7038_wdt_get_timeleft(struct watchdog_device *wdog)\n{\n\tstruct bcm7038_watchdog *wdt = watchdog_get_drvdata(wdog);\n\tu32 time_left;\n\n\ttime_left = bcm7038_wdt_read(wdt->base + WDT_CMD_REG);\n\n\treturn time_left / wdt->rate;\n}\n\nstatic const struct watchdog_info bcm7038_wdt_info = {\n\t.identity\t= \"Broadcom BCM7038 Watchdog Timer\",\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t\tWDIOF_MAGICCLOSE\n};\n\nstatic const struct watchdog_ops bcm7038_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= bcm7038_wdt_start,\n\t.stop\t\t= bcm7038_wdt_stop,\n\t.set_timeout\t= bcm7038_wdt_set_timeout,\n\t.get_timeleft\t= bcm7038_wdt_get_timeleft,\n};\n\nstatic int bcm7038_wdt_probe(struct platform_device *pdev)\n{\n\tstruct bcm7038_wdt_platform_data *pdata = pdev->dev.platform_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm7038_watchdog *wdt;\n\tconst char *clk_name = NULL;\n\tint err;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\tif (pdata && pdata->clk_name)\n\t\tclk_name = pdata->clk_name;\n\n\twdt->clk = devm_clk_get_enabled(dev, clk_name);\n\t \n\tif (!IS_ERR(wdt->clk)) {\n\t\twdt->rate = clk_get_rate(wdt->clk);\n\t\t \n\t\tif (!wdt->rate)\n\t\t\twdt->rate = WDT_DEFAULT_RATE;\n\t} else {\n\t\twdt->rate = WDT_DEFAULT_RATE;\n\t\twdt->clk = NULL;\n\t}\n\n\twdt->wdd.info\t\t= &bcm7038_wdt_info;\n\twdt->wdd.ops\t\t= &bcm7038_wdt_ops;\n\twdt->wdd.min_timeout\t= WDT_MIN_TIMEOUT;\n\twdt->wdd.timeout\t= WDT_DEFAULT_TIMEOUT;\n\twdt->wdd.max_timeout\t= 0xffffffff / wdt->rate;\n\twdt->wdd.parent\t\t= dev;\n\twatchdog_set_drvdata(&wdt->wdd, wdt);\n\n\twatchdog_stop_on_reboot(&wdt->wdd);\n\twatchdog_stop_on_unregister(&wdt->wdd);\n\terr = devm_watchdog_register_device(dev, &wdt->wdd);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(dev, \"Registered BCM7038 Watchdog\\n\");\n\n\treturn 0;\n}\n\nstatic int bcm7038_wdt_suspend(struct device *dev)\n{\n\tstruct bcm7038_watchdog *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\treturn bcm7038_wdt_stop(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic int bcm7038_wdt_resume(struct device *dev)\n{\n\tstruct bcm7038_watchdog *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\treturn bcm7038_wdt_start(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(bcm7038_wdt_pm_ops,\n\t\t\t\tbcm7038_wdt_suspend, bcm7038_wdt_resume);\n\nstatic const struct of_device_id bcm7038_wdt_match[] = {\n\t{ .compatible = \"brcm,bcm6345-wdt\" },\n\t{ .compatible = \"brcm,bcm7038-wdt\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm7038_wdt_match);\n\nstatic const struct platform_device_id bcm7038_wdt_devtype[] = {\n\t{ .name = \"bcm63xx-wdt\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(platform, bcm7038_wdt_devtype);\n\nstatic struct platform_driver bcm7038_wdt_driver = {\n\t.probe\t\t= bcm7038_wdt_probe,\n\t.id_table\t= bcm7038_wdt_devtype,\n\t.driver\t\t= {\n\t\t.name\t\t= \"bcm7038-wdt\",\n\t\t.of_match_table\t= bcm7038_wdt_match,\n\t\t.pm\t\t= pm_sleep_ptr(&bcm7038_wdt_pm_ops),\n\t}\n};\nmodule_platform_driver(bcm7038_wdt_driver);\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Driver for Broadcom 7038 SoCs Watchdog\");\nMODULE_AUTHOR(\"Justin Chen\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}