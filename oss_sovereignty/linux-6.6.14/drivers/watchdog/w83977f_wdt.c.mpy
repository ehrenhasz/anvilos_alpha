{
  "module_name": "w83977f_wdt.c",
  "hash_id": "5e2c113c9dc778428d6478b16557b0f11b58aeddf9bd2a69596f65ddf38e0130",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/w83977f_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/watchdog.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n\n#define WATCHDOG_VERSION  \"1.00\"\n#define WATCHDOG_NAME     \"W83977F WDT\"\n\n#define IO_INDEX_PORT     0x3F0\n#define IO_DATA_PORT      (IO_INDEX_PORT+1)\n\n#define UNLOCK_DATA       0x87\n#define LOCK_DATA         0xAA\n#define DEVICE_REGISTER   0x07\n\n#define\tDEFAULT_TIMEOUT   45\t\t \n\nstatic\tint timeout = DEFAULT_TIMEOUT;\nstatic\tint timeoutW;\t\t\t \nstatic\tunsigned long timer_alive;\nstatic\tint testmode;\nstatic\tchar expect_close;\nstatic\tDEFINE_SPINLOCK(spinlock);\n\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\t\"Watchdog timeout in seconds (15..7635), default=\"\n\t\t\t\t__MODULE_STRING(DEFAULT_TIMEOUT) \")\");\nmodule_param(testmode, int, 0);\nMODULE_PARM_DESC(testmode, \"Watchdog testmode (1 = no reboot), default=0\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n\nstatic int wdt_start(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&spinlock, flags);\n\n\t \n\toutb_p(UNLOCK_DATA, IO_INDEX_PORT);\n\toutb_p(UNLOCK_DATA, IO_INDEX_PORT);\n\n\t \n\toutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\n\toutb_p(0x08, IO_DATA_PORT);\n\toutb_p(0xF2, IO_INDEX_PORT);\n\toutb_p(timeoutW, IO_DATA_PORT);\n\toutb_p(0xF3, IO_INDEX_PORT);\n\toutb_p(0x08, IO_DATA_PORT);\n\toutb_p(0xF4, IO_INDEX_PORT);\n\toutb_p(0x00, IO_DATA_PORT);\n\n\t \n\toutb_p(0x30, IO_INDEX_PORT);\n\toutb_p(0x01, IO_DATA_PORT);\n\n\t \n\toutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\n\toutb_p(0x07, IO_DATA_PORT);\n\tif (!testmode) {\n\t\tunsigned pin_map;\n\n\t\toutb_p(0xE6, IO_INDEX_PORT);\n\t\toutb_p(0x0A, IO_DATA_PORT);\n\t\toutb_p(0x2C, IO_INDEX_PORT);\n\t\tpin_map = inb_p(IO_DATA_PORT);\n\t\tpin_map |= 0x10;\n\t\tpin_map &= ~(0x20);\n\t\toutb_p(0x2C, IO_INDEX_PORT);\n\t\toutb_p(pin_map, IO_DATA_PORT);\n\t}\n\toutb_p(0xE3, IO_INDEX_PORT);\n\toutb_p(0x08, IO_DATA_PORT);\n\n\t \n\toutb_p(0x30, IO_INDEX_PORT);\n\toutb_p(0x01, IO_DATA_PORT);\n\n\t \n\toutb_p(LOCK_DATA, IO_INDEX_PORT);\n\n\tspin_unlock_irqrestore(&spinlock, flags);\n\n\tpr_info(\"activated\\n\");\n\n\treturn 0;\n}\n\n \n\nstatic int wdt_stop(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&spinlock, flags);\n\n\t \n\toutb_p(UNLOCK_DATA, IO_INDEX_PORT);\n\toutb_p(UNLOCK_DATA, IO_INDEX_PORT);\n\n\t \n\toutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\n\toutb_p(0x08, IO_DATA_PORT);\n\toutb_p(0xF2, IO_INDEX_PORT);\n\toutb_p(0xFF, IO_DATA_PORT);\n\toutb_p(0xF3, IO_INDEX_PORT);\n\toutb_p(0x00, IO_DATA_PORT);\n\toutb_p(0xF4, IO_INDEX_PORT);\n\toutb_p(0x00, IO_DATA_PORT);\n\toutb_p(0xF2, IO_INDEX_PORT);\n\toutb_p(0x00, IO_DATA_PORT);\n\n\t \n\toutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\n\toutb_p(0x07, IO_DATA_PORT);\n\tif (!testmode) {\n\t\toutb_p(0xE6, IO_INDEX_PORT);\n\t\toutb_p(0x01, IO_DATA_PORT);\n\t}\n\toutb_p(0xE3, IO_INDEX_PORT);\n\toutb_p(0x01, IO_DATA_PORT);\n\n\t \n\toutb_p(LOCK_DATA, IO_INDEX_PORT);\n\n\tspin_unlock_irqrestore(&spinlock, flags);\n\n\tpr_info(\"shutdown\\n\");\n\n\treturn 0;\n}\n\n \n\nstatic int wdt_keepalive(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&spinlock, flags);\n\n\t \n\toutb_p(UNLOCK_DATA, IO_INDEX_PORT);\n\toutb_p(UNLOCK_DATA, IO_INDEX_PORT);\n\n\t \n\toutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\n\toutb_p(0x08, IO_DATA_PORT);\n\toutb_p(0xF2, IO_INDEX_PORT);\n\toutb_p(timeoutW, IO_DATA_PORT);\n\n\t \n\toutb_p(LOCK_DATA, IO_INDEX_PORT);\n\n\tspin_unlock_irqrestore(&spinlock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic int wdt_set_timeout(int t)\n{\n\tunsigned int tmrval;\n\n\t \n\tif (t < 15)\n\t\treturn -EINVAL;\n\n\ttmrval = ((t + 15) + 29) / 30;\n\n\tif (tmrval > 255)\n\t\treturn -EINVAL;\n\n\t \n\ttimeoutW = tmrval;\n\ttimeout = (timeoutW * 30) - 15;\n\treturn 0;\n}\n\n \n\nstatic int wdt_get_status(int *status)\n{\n\tint new_status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&spinlock, flags);\n\n\t \n\toutb_p(UNLOCK_DATA, IO_INDEX_PORT);\n\toutb_p(UNLOCK_DATA, IO_INDEX_PORT);\n\n\t \n\toutb_p(DEVICE_REGISTER, IO_INDEX_PORT);\n\toutb_p(0x08, IO_DATA_PORT);\n\toutb_p(0xF4, IO_INDEX_PORT);\n\tnew_status = inb_p(IO_DATA_PORT);\n\n\t \n\toutb_p(LOCK_DATA, IO_INDEX_PORT);\n\n\tspin_unlock_irqrestore(&spinlock, flags);\n\n\t*status = 0;\n\tif (new_status & 1)\n\t\t*status |= WDIOF_CARDRESET;\n\n\treturn 0;\n}\n\n\n \n\nstatic int wdt_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &timer_alive))\n\t\treturn -EBUSY;\n\n\tif (nowayout)\n\t\t__module_get(THIS_MODULE);\n\n\twdt_start();\n\treturn stream_open(inode, file);\n}\n\nstatic int wdt_release(struct inode *inode, struct file *file)\n{\n\t \n\tif (expect_close == 42) {\n\t\twdt_stop();\n\t\tclear_bit(0, &timer_alive);\n\t} else {\n\t\twdt_keepalive();\n\t\tpr_crit(\"unexpected close, not stopping watchdog!\\n\");\n\t}\n\texpect_close = 0;\n\treturn 0;\n}\n\n \n\nstatic ssize_t wdt_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\t \n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t ofs;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\t \n\t\t\tfor (ofs = 0; ofs != count; ofs++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + ofs))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twdt_keepalive();\n\t}\n\treturn count;\n}\n\n \n\nstatic const struct watchdog_info ident = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.firmware_version =\t1,\n\t.identity = WATCHDOG_NAME,\n};\n\nstatic long wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint status;\n\tint new_options, retval = -EINVAL;\n\tint new_timeout;\n\tunion {\n\t\tstruct watchdog_info __user *ident;\n\t\tint __user *i;\n\t} uarg;\n\n\tuarg.i = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(uarg.ident, &ident,\n\t\t\t\t\t\tsizeof(ident)) ? -EFAULT : 0;\n\n\tcase WDIOC_GETSTATUS:\n\t\twdt_get_status(&status);\n\t\treturn put_user(status, uarg.i);\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, uarg.i);\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(new_options, uarg.i))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_options & WDIOS_DISABLECARD) {\n\t\t\twdt_stop();\n\t\t\tretval = 0;\n\t\t}\n\n\t\tif (new_options & WDIOS_ENABLECARD) {\n\t\t\twdt_start();\n\t\t\tretval = 0;\n\t\t}\n\n\t\treturn retval;\n\n\tcase WDIOC_KEEPALIVE:\n\t\twdt_keepalive();\n\t\treturn 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_timeout, uarg.i))\n\t\t\treturn -EFAULT;\n\n\t\tif (wdt_set_timeout(new_timeout))\n\t\t\treturn -EINVAL;\n\n\t\twdt_keepalive();\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(timeout, uarg.i);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\n\t}\n}\n\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\n\tvoid *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\twdt_stop();\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct file_operations wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= wdt_write,\n\t.unlocked_ioctl\t= wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= wdt_open,\n\t.release\t= wdt_release,\n};\n\nstatic struct miscdevice wdt_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &wdt_fops,\n};\n\nstatic struct notifier_block wdt_notifier = {\n\t.notifier_call = wdt_notify_sys,\n};\n\nstatic int __init w83977f_wdt_init(void)\n{\n\tint rc;\n\n\tpr_info(\"driver v%s\\n\", WATCHDOG_VERSION);\n\n\t \n\tif (wdt_set_timeout(timeout)) {\n\t\twdt_set_timeout(DEFAULT_TIMEOUT);\n\t\tpr_info(\"timeout value must be 15 <= timeout <= 7635, using %d\\n\",\n\t\t\tDEFAULT_TIMEOUT);\n\t}\n\n\tif (!request_region(IO_INDEX_PORT, 2, WATCHDOG_NAME)) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\", IO_INDEX_PORT);\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\trc = register_reboot_notifier(&wdt_notifier);\n\tif (rc) {\n\t\tpr_err(\"cannot register reboot notifier (err=%d)\\n\", rc);\n\t\tgoto err_out_region;\n\t}\n\n\trc = misc_register(&wdt_miscdev);\n\tif (rc) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       wdt_miscdev.minor, rc);\n\t\tgoto err_out_reboot;\n\t}\n\n\tpr_info(\"initialized. timeout=%d sec (nowayout=%d testmode=%d)\\n\",\n\t\ttimeout, nowayout, testmode);\n\n\treturn 0;\n\nerr_out_reboot:\n\tunregister_reboot_notifier(&wdt_notifier);\nerr_out_region:\n\trelease_region(IO_INDEX_PORT, 2);\nerr_out:\n\treturn rc;\n}\n\nstatic void __exit w83977f_wdt_exit(void)\n{\n\twdt_stop();\n\tmisc_deregister(&wdt_miscdev);\n\tunregister_reboot_notifier(&wdt_notifier);\n\trelease_region(IO_INDEX_PORT, 2);\n}\n\nmodule_init(w83977f_wdt_init);\nmodule_exit(w83977f_wdt_exit);\n\nMODULE_AUTHOR(\"Jose Goncalves <jose.goncalves@inov.pt>\");\nMODULE_DESCRIPTION(\"Driver for watchdog timer in W83977F I/O chip\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}