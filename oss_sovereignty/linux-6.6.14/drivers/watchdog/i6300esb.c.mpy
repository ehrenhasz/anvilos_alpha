{
  "module_name": "i6300esb.c",
  "hash_id": "f66390e46dc7b255f5c118fb27fc67a4a8222c5b88cf27a91952e24840b2291e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/i6300esb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n \n#define ESB_MODULE_NAME \"i6300ESB timer\"\n\n \n#define ESB_CONFIG_REG  0x60             \n#define ESB_LOCK_REG    0x68             \n\n \n#define ESB_TIMER1_REG(w) ((w)->base + 0x00) \n#define ESB_TIMER2_REG(w) ((w)->base + 0x04) \n#define ESB_GINTSR_REG(w) ((w)->base + 0x08) \n#define ESB_RELOAD_REG(w) ((w)->base + 0x0c) \n\n \n#define ESB_WDT_FUNC    (0x01 << 2)    \n#define ESB_WDT_ENABLE  (0x01 << 1)    \n#define ESB_WDT_LOCK    (0x01 << 0)    \n\n \n#define ESB_WDT_REBOOT  (0x01 << 5)    \n#define ESB_WDT_FREQ    (0x01 << 2)    \n#define ESB_WDT_INTTYPE (0x03 << 0)    \n\n \n#define ESB_WDT_TIMEOUT (0x01 << 9)     \n#define ESB_WDT_RELOAD  (0x01 << 8)     \n\n \n#define ESB_UNLOCK1     0x80             \n#define ESB_UNLOCK2     0x86             \n\n \n \n#define ESB_HEARTBEAT_MIN\t1\n#define ESB_HEARTBEAT_MAX\t2046\n#define ESB_HEARTBEAT_DEFAULT\t30\n#define ESB_HEARTBEAT_RANGE __MODULE_STRING(ESB_HEARTBEAT_MIN) \\\n\t\"<heartbeat<\" __MODULE_STRING(ESB_HEARTBEAT_MAX)\nstatic int heartbeat;  \nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\"Watchdog heartbeat in seconds. (\" ESB_HEARTBEAT_RANGE\n\t\", default=\" __MODULE_STRING(ESB_HEARTBEAT_DEFAULT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \nstruct esb_dev {\n\tstruct watchdog_device wdd;\n\tvoid __iomem *base;\n\tstruct pci_dev *pdev;\n};\n\n#define to_esb_dev(wptr) container_of(wptr, struct esb_dev, wdd)\n\n \n\n \nstatic inline void esb_unlock_registers(struct esb_dev *edev)\n{\n\twritew(ESB_UNLOCK1, ESB_RELOAD_REG(edev));\n\twritew(ESB_UNLOCK2, ESB_RELOAD_REG(edev));\n}\n\nstatic int esb_timer_start(struct watchdog_device *wdd)\n{\n\tstruct esb_dev *edev = to_esb_dev(wdd);\n\tint _wdd_nowayout = test_bit(WDOG_NO_WAY_OUT, &wdd->status);\n\tu8 val;\n\n\tesb_unlock_registers(edev);\n\twritew(ESB_WDT_RELOAD, ESB_RELOAD_REG(edev));\n\t \n\tval = ESB_WDT_ENABLE | (_wdd_nowayout ? ESB_WDT_LOCK : 0x00);\n\tpci_write_config_byte(edev->pdev, ESB_LOCK_REG, val);\n\treturn 0;\n}\n\nstatic int esb_timer_stop(struct watchdog_device *wdd)\n{\n\tstruct esb_dev *edev = to_esb_dev(wdd);\n\tu8 val;\n\n\t \n\tesb_unlock_registers(edev);\n\twritew(ESB_WDT_RELOAD, ESB_RELOAD_REG(edev));\n\t \n\tpci_write_config_byte(edev->pdev, ESB_LOCK_REG, 0x0);\n\tpci_read_config_byte(edev->pdev, ESB_LOCK_REG, &val);\n\n\t \n\treturn val & ESB_WDT_ENABLE;\n}\n\nstatic int esb_timer_keepalive(struct watchdog_device *wdd)\n{\n\tstruct esb_dev *edev = to_esb_dev(wdd);\n\n\tesb_unlock_registers(edev);\n\twritew(ESB_WDT_RELOAD, ESB_RELOAD_REG(edev));\n\t \n\treturn 0;\n}\n\nstatic int esb_timer_set_heartbeat(struct watchdog_device *wdd,\n\t\tunsigned int time)\n{\n\tstruct esb_dev *edev = to_esb_dev(wdd);\n\tu32 val;\n\n\t \n\tval = time << 9;\n\n\t \n\tesb_unlock_registers(edev);\n\twritel(val, ESB_TIMER1_REG(edev));\n\n\t \n\tesb_unlock_registers(edev);\n\twritel(val, ESB_TIMER2_REG(edev));\n\n\t \n\tesb_unlock_registers(edev);\n\twritew(ESB_WDT_RELOAD, ESB_RELOAD_REG(edev));\n\n\t \n\n\t \n\twdd->timeout = time;\n\treturn 0;\n}\n\n \n\nstatic struct watchdog_info esb_info = {\n\t.identity = ESB_MODULE_NAME,\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops esb_ops = {\n\t.owner = THIS_MODULE,\n\t.start = esb_timer_start,\n\t.stop = esb_timer_stop,\n\t.set_timeout = esb_timer_set_heartbeat,\n\t.ping = esb_timer_keepalive,\n};\n\n \nstatic const struct pci_device_id esb_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ESB_9), },\n\t{ 0, },                  \n};\nMODULE_DEVICE_TABLE(pci, esb_pci_tbl);\n\n \n\nstatic unsigned char esb_getdevice(struct esb_dev *edev)\n{\n\tif (pci_enable_device(edev->pdev)) {\n\t\tdev_err(&edev->pdev->dev, \"failed to enable device\\n\");\n\t\tgoto err_devput;\n\t}\n\n\tif (pci_request_region(edev->pdev, 0, ESB_MODULE_NAME)) {\n\t\tdev_err(&edev->pdev->dev, \"failed to request region\\n\");\n\t\tgoto err_disable;\n\t}\n\n\tedev->base = pci_ioremap_bar(edev->pdev, 0);\n\tif (edev->base == NULL) {\n\t\t \n\t\tdev_err(&edev->pdev->dev, \"failed to get BASEADDR\\n\");\n\t\tgoto err_release;\n\t}\n\n\t \n\tdev_set_drvdata(&edev->pdev->dev, edev);\n\treturn 1;\n\nerr_release:\n\tpci_release_region(edev->pdev, 0);\nerr_disable:\n\tpci_disable_device(edev->pdev);\nerr_devput:\n\treturn 0;\n}\n\nstatic void esb_initdevice(struct esb_dev *edev)\n{\n\tu8 val1;\n\tu16 val2;\n\n\t \n\tpci_write_config_word(edev->pdev, ESB_CONFIG_REG, 0x0003);\n\n\t \n\tpci_read_config_byte(edev->pdev, ESB_LOCK_REG, &val1);\n\tif (val1 & ESB_WDT_LOCK)\n\t\tdev_warn(&edev->pdev->dev, \"nowayout already set\\n\");\n\n\t \n\tpci_write_config_byte(edev->pdev, ESB_LOCK_REG, 0x00);\n\n\t \n\tesb_unlock_registers(edev);\n\tval2 = readw(ESB_RELOAD_REG(edev));\n\tif (val2 & ESB_WDT_TIMEOUT)\n\t\tedev->wdd.bootstatus = WDIOF_CARDRESET;\n\n\t \n\tesb_unlock_registers(edev);\n\twritew((ESB_WDT_TIMEOUT | ESB_WDT_RELOAD), ESB_RELOAD_REG(edev));\n\n\t \n\tesb_timer_set_heartbeat(&edev->wdd, edev->wdd.timeout);\n}\n\nstatic int esb_probe(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *ent)\n{\n\tstruct esb_dev *edev;\n\tint ret;\n\n\tedev = devm_kzalloc(&pdev->dev, sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn -ENOMEM;\n\n\t \n\tedev->pdev = pdev;\n\tif (!esb_getdevice(edev))\n\t\treturn -ENODEV;\n\n\t \n\tedev->wdd.info = &esb_info;\n\tedev->wdd.ops = &esb_ops;\n\tedev->wdd.min_timeout = ESB_HEARTBEAT_MIN;\n\tedev->wdd.max_timeout = ESB_HEARTBEAT_MAX;\n\tedev->wdd.timeout = ESB_HEARTBEAT_DEFAULT;\n\twatchdog_init_timeout(&edev->wdd, heartbeat, NULL);\n\twatchdog_set_nowayout(&edev->wdd, nowayout);\n\twatchdog_stop_on_reboot(&edev->wdd);\n\twatchdog_stop_on_unregister(&edev->wdd);\n\tesb_initdevice(edev);\n\n\t \n\tret = watchdog_register_device(&edev->wdd);\n\tif (ret != 0)\n\t\tgoto err_unmap;\n\tdev_info(&pdev->dev,\n\t\t\"initialized. heartbeat=%d sec (nowayout=%d)\\n\",\n\t\tedev->wdd.timeout, nowayout);\n\treturn 0;\n\nerr_unmap:\n\tiounmap(edev->base);\n\tpci_release_region(edev->pdev, 0);\n\tpci_disable_device(edev->pdev);\n\treturn ret;\n}\n\nstatic void esb_remove(struct pci_dev *pdev)\n{\n\tstruct esb_dev *edev = dev_get_drvdata(&pdev->dev);\n\n\twatchdog_unregister_device(&edev->wdd);\n\tiounmap(edev->base);\n\tpci_release_region(edev->pdev, 0);\n\tpci_disable_device(edev->pdev);\n}\n\nstatic struct pci_driver esb_driver = {\n\t.name\t\t= ESB_MODULE_NAME,\n\t.id_table\t= esb_pci_tbl,\n\t.probe          = esb_probe,\n\t.remove         = esb_remove,\n};\n\nmodule_pci_driver(esb_driver);\n\nMODULE_AUTHOR(\"Ross Biro and David H\u00e4rdeman\");\nMODULE_DESCRIPTION(\"Watchdog driver for Intel 6300ESB chipsets\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}