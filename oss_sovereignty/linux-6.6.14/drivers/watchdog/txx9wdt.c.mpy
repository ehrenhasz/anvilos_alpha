{
  "module_name": "txx9wdt.c",
  "hash_id": "d3fbf11103a146cf377a04ac5cecdb0124403411c04ad18d7c90eaa244be49e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/txx9wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <asm/txx9tmr.h>\n\n#define WD_TIMER_CCD\t7\t\t \n#define WD_TIMER_CLK\t(clk_get_rate(txx9_imclk) / (2 << WD_TIMER_CCD))\n#define WD_MAX_TIMEOUT\t((0xffffffff >> (32 - TXX9_TIMER_BITS)) / WD_TIMER_CLK)\n#define TIMER_MARGIN\t60\t\t \n\nstatic unsigned int timeout = TIMER_MARGIN;\t \nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout,\n\t\"Watchdog timeout in seconds. \"\n\t\"(0<timeout<((2^\" __MODULE_STRING(TXX9_TIMER_BITS) \")/(IMCLK/256)), \"\n\t\"default=\" __MODULE_STRING(TIMER_MARGIN) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started \"\n\t\"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic struct txx9_tmr_reg __iomem *txx9wdt_reg;\nstatic struct clk *txx9_imclk;\nstatic DEFINE_SPINLOCK(txx9_lock);\n\nstatic int txx9wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tspin_lock(&txx9_lock);\n\t__raw_writel(TXx9_TMWTMR_TWIE | TXx9_TMWTMR_TWC, &txx9wdt_reg->wtmr);\n\tspin_unlock(&txx9_lock);\n\treturn 0;\n}\n\nstatic int txx9wdt_start(struct watchdog_device *wdt_dev)\n{\n\tspin_lock(&txx9_lock);\n\t__raw_writel(WD_TIMER_CLK * wdt_dev->timeout, &txx9wdt_reg->cpra);\n\t__raw_writel(WD_TIMER_CCD, &txx9wdt_reg->ccdr);\n\t__raw_writel(0, &txx9wdt_reg->tisr);\t \n\t__raw_writel(TXx9_TMTCR_TCE | TXx9_TMTCR_CCDE | TXx9_TMTCR_TMODE_WDOG,\n\t\t     &txx9wdt_reg->tcr);\n\t__raw_writel(TXx9_TMWTMR_TWIE | TXx9_TMWTMR_TWC, &txx9wdt_reg->wtmr);\n\tspin_unlock(&txx9_lock);\n\treturn 0;\n}\n\nstatic int txx9wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tspin_lock(&txx9_lock);\n\t__raw_writel(TXx9_TMWTMR_WDIS, &txx9wdt_reg->wtmr);\n\t__raw_writel(__raw_readl(&txx9wdt_reg->tcr) & ~TXx9_TMTCR_TCE,\n\t\t     &txx9wdt_reg->tcr);\n\tspin_unlock(&txx9_lock);\n\treturn 0;\n}\n\nstatic int txx9wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t       unsigned int new_timeout)\n{\n\twdt_dev->timeout = new_timeout;\n\ttxx9wdt_stop(wdt_dev);\n\ttxx9wdt_start(wdt_dev);\n\treturn 0;\n}\n\nstatic const struct watchdog_info txx9wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"Hardware Watchdog for TXx9\",\n};\n\nstatic const struct watchdog_ops txx9wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = txx9wdt_start,\n\t.stop = txx9wdt_stop,\n\t.ping = txx9wdt_ping,\n\t.set_timeout = txx9wdt_set_timeout,\n};\n\nstatic struct watchdog_device txx9wdt = {\n\t.info = &txx9wdt_info,\n\t.ops = &txx9wdt_ops,\n};\n\nstatic int __init txx9wdt_probe(struct platform_device *dev)\n{\n\tint ret;\n\n\ttxx9_imclk = clk_get(NULL, \"imbus_clk\");\n\tif (IS_ERR(txx9_imclk)) {\n\t\tret = PTR_ERR(txx9_imclk);\n\t\ttxx9_imclk = NULL;\n\t\tgoto exit;\n\t}\n\tret = clk_prepare_enable(txx9_imclk);\n\tif (ret) {\n\t\tclk_put(txx9_imclk);\n\t\ttxx9_imclk = NULL;\n\t\tgoto exit;\n\t}\n\n\ttxx9wdt_reg = devm_platform_ioremap_resource(dev, 0);\n\tif (IS_ERR(txx9wdt_reg)) {\n\t\tret = PTR_ERR(txx9wdt_reg);\n\t\tgoto exit;\n\t}\n\n\tif (timeout < 1 || timeout > WD_MAX_TIMEOUT)\n\t\ttimeout = TIMER_MARGIN;\n\ttxx9wdt.timeout = timeout;\n\ttxx9wdt.min_timeout = 1;\n\ttxx9wdt.max_timeout = WD_MAX_TIMEOUT;\n\ttxx9wdt.parent = &dev->dev;\n\twatchdog_set_nowayout(&txx9wdt, nowayout);\n\n\tret = watchdog_register_device(&txx9wdt);\n\tif (ret)\n\t\tgoto exit;\n\n\tpr_info(\"Hardware Watchdog Timer: timeout=%d sec (max %ld) (nowayout= %d)\\n\",\n\t\ttimeout, WD_MAX_TIMEOUT, nowayout);\n\n\treturn 0;\nexit:\n\tif (txx9_imclk) {\n\t\tclk_disable_unprepare(txx9_imclk);\n\t\tclk_put(txx9_imclk);\n\t}\n\treturn ret;\n}\n\nstatic int __exit txx9wdt_remove(struct platform_device *dev)\n{\n\twatchdog_unregister_device(&txx9wdt);\n\tclk_disable_unprepare(txx9_imclk);\n\tclk_put(txx9_imclk);\n\treturn 0;\n}\n\nstatic void txx9wdt_shutdown(struct platform_device *dev)\n{\n\ttxx9wdt_stop(&txx9wdt);\n}\n\nstatic struct platform_driver txx9wdt_driver = {\n\t.remove = __exit_p(txx9wdt_remove),\n\t.shutdown = txx9wdt_shutdown,\n\t.driver = {\n\t\t.name = \"txx9wdt\",\n\t},\n};\n\nmodule_platform_driver_probe(txx9wdt_driver, txx9wdt_probe);\n\nMODULE_DESCRIPTION(\"TXx9 Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:txx9wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}