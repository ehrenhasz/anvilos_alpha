{
  "module_name": "imx2_wdt.c",
  "hash_id": "7a4c67b41fb64611ec7405fadf9bdd50f6ef2640927324b95f0618f68612527a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/imx2_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\n#define DRIVER_NAME \"imx2-wdt\"\n\n#define IMX2_WDT_WCR\t\t0x00\t\t \n#define IMX2_WDT_WCR_WT\t\t(0xFF << 8)\t \n#define IMX2_WDT_WCR_WDW\tBIT(7)\t\t \n#define IMX2_WDT_WCR_WDA\tBIT(5)\t\t \n#define IMX2_WDT_WCR_SRS\tBIT(4)\t\t \n#define IMX2_WDT_WCR_WRE\tBIT(3)\t\t \n#define IMX2_WDT_WCR_WDE\tBIT(2)\t\t \n#define IMX2_WDT_WCR_WDZST\tBIT(0)\t\t \n\n#define IMX2_WDT_WSR\t\t0x02\t\t \n#define IMX2_WDT_SEQ1\t\t0x5555\t\t \n#define IMX2_WDT_SEQ2\t\t0xAAAA\t\t \n\n#define IMX2_WDT_WRSR\t\t0x04\t\t \n#define IMX2_WDT_WRSR_TOUT\tBIT(1)\t\t \n\n#define IMX2_WDT_WICR\t\t0x06\t\t \n#define IMX2_WDT_WICR_WIE\tBIT(15)\t\t \n#define IMX2_WDT_WICR_WTIS\tBIT(14)\t\t \n#define IMX2_WDT_WICR_WICT\t0xFF\t\t \n\n#define IMX2_WDT_WMCR\t\t0x08\t\t \n\n#define IMX2_WDT_MAX_TIME\t128U\n#define IMX2_WDT_DEFAULT_TIME\t60\t\t \n\n#define WDOG_SEC_TO_COUNT(s)\t((s * 2 - 1) << 8)\n\nstruct imx2_wdt_data {\n\tbool wdw_supported;\n};\n\nstruct imx2_wdt_device {\n\tstruct clk *clk;\n\tstruct regmap *regmap;\n\tstruct watchdog_device wdog;\n\tconst struct imx2_wdt_data *data;\n\tbool ext_reset;\n\tbool clk_is_on;\n\tbool no_ping;\n\tbool sleep_wait;\n};\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic unsigned timeout;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds (default=\"\n\t\t\t\t__MODULE_STRING(IMX2_WDT_DEFAULT_TIME) \")\");\n\nstatic const struct watchdog_info imx2_wdt_info = {\n\t.identity = \"imx2+ watchdog\",\n\t.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_info imx2_wdt_pretimeout_info = {\n\t.identity = \"imx2+ watchdog\",\n\t.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE |\n\t\t   WDIOF_PRETIMEOUT,\n};\n\nstatic int imx2_wdt_restart(struct watchdog_device *wdog, unsigned long action,\n\t\t\t    void *data)\n{\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\tunsigned int wcr_enable = IMX2_WDT_WCR_WDE;\n\n\t \n\tif (wdev->ext_reset)\n\t\twcr_enable |= IMX2_WDT_WCR_SRS;  \n\telse\n\t\twcr_enable |= IMX2_WDT_WCR_WDA;  \n\n\t \n\tregmap_write(wdev->regmap, IMX2_WDT_WCR, wcr_enable);\n\t \n\tregmap_write(wdev->regmap, IMX2_WDT_WCR, wcr_enable);\n\tregmap_write(wdev->regmap, IMX2_WDT_WCR, wcr_enable);\n\n\t \n\tmdelay(500);\n\n\treturn 0;\n}\n\nstatic inline void imx2_wdt_setup(struct watchdog_device *wdog)\n{\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\tu32 val;\n\n\tregmap_read(wdev->regmap, IMX2_WDT_WCR, &val);\n\n\t \n\tval |= IMX2_WDT_WCR_WDZST;\n\t \n\tif (wdev->sleep_wait)\n\t\tval |= IMX2_WDT_WCR_WDW;\n\t \n\tval &= ~IMX2_WDT_WCR_WT;\n\t \n\tif (!wdev->ext_reset)\n\t\tval &= ~IMX2_WDT_WCR_WRE;\n\t \n\telse\n\t\tval |= IMX2_WDT_WCR_WRE;\n\t \n\tval &= ~IMX2_WDT_WCR_WDE;\n\t \n\tval |= WDOG_SEC_TO_COUNT(wdog->timeout);\n\n\tregmap_write(wdev->regmap, IMX2_WDT_WCR, val);\n\n\t \n\tval |= IMX2_WDT_WCR_WDE;\n\tregmap_write(wdev->regmap, IMX2_WDT_WCR, val);\n}\n\nstatic inline bool imx2_wdt_is_running(struct imx2_wdt_device *wdev)\n{\n\tu32 val;\n\n\tregmap_read(wdev->regmap, IMX2_WDT_WCR, &val);\n\n\treturn val & IMX2_WDT_WCR_WDE;\n}\n\nstatic int imx2_wdt_ping(struct watchdog_device *wdog)\n{\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\n\tif (!wdev->clk_is_on)\n\t\treturn 0;\n\n\tregmap_write(wdev->regmap, IMX2_WDT_WSR, IMX2_WDT_SEQ1);\n\tregmap_write(wdev->regmap, IMX2_WDT_WSR, IMX2_WDT_SEQ2);\n\treturn 0;\n}\n\nstatic void __imx2_wdt_set_timeout(struct watchdog_device *wdog,\n\t\t\t\t   unsigned int new_timeout)\n{\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\n\tregmap_update_bits(wdev->regmap, IMX2_WDT_WCR, IMX2_WDT_WCR_WT,\n\t\t\t   WDOG_SEC_TO_COUNT(new_timeout));\n}\n\nstatic int imx2_wdt_set_timeout(struct watchdog_device *wdog,\n\t\t\t\tunsigned int new_timeout)\n{\n\tunsigned int actual;\n\n\tactual = min(new_timeout, IMX2_WDT_MAX_TIME);\n\t__imx2_wdt_set_timeout(wdog, actual);\n\twdog->timeout = new_timeout;\n\treturn 0;\n}\n\nstatic int imx2_wdt_set_pretimeout(struct watchdog_device *wdog,\n\t\t\t\t   unsigned int new_pretimeout)\n{\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\n\tif (new_pretimeout >= IMX2_WDT_MAX_TIME)\n\t\treturn -EINVAL;\n\n\twdog->pretimeout = new_pretimeout;\n\n\tregmap_update_bits(wdev->regmap, IMX2_WDT_WICR,\n\t\t\t   IMX2_WDT_WICR_WIE | IMX2_WDT_WICR_WICT,\n\t\t\t   IMX2_WDT_WICR_WIE | (new_pretimeout << 1));\n\treturn 0;\n}\n\nstatic irqreturn_t imx2_wdt_isr(int irq, void *wdog_arg)\n{\n\tstruct watchdog_device *wdog = wdog_arg;\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\n\tregmap_write_bits(wdev->regmap, IMX2_WDT_WICR,\n\t\t\t  IMX2_WDT_WICR_WTIS, IMX2_WDT_WICR_WTIS);\n\n\twatchdog_notify_pretimeout(wdog);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int imx2_wdt_start(struct watchdog_device *wdog)\n{\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\n\tif (imx2_wdt_is_running(wdev))\n\t\timx2_wdt_set_timeout(wdog, wdog->timeout);\n\telse\n\t\timx2_wdt_setup(wdog);\n\n\tset_bit(WDOG_HW_RUNNING, &wdog->status);\n\n\treturn imx2_wdt_ping(wdog);\n}\n\nstatic const struct watchdog_ops imx2_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = imx2_wdt_start,\n\t.ping = imx2_wdt_ping,\n\t.set_timeout = imx2_wdt_set_timeout,\n\t.set_pretimeout = imx2_wdt_set_pretimeout,\n\t.restart = imx2_wdt_restart,\n};\n\nstatic const struct regmap_config imx2_wdt_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_stride = 2,\n\t.val_bits = 16,\n\t.max_register = 0x8,\n};\n\nstatic void imx2_wdt_action(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int __init imx2_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct imx2_wdt_device *wdev;\n\tstruct watchdog_device *wdog;\n\tvoid __iomem *base;\n\tint ret;\n\tu32 val;\n\n\twdev = devm_kzalloc(dev, sizeof(*wdev), GFP_KERNEL);\n\tif (!wdev)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\twdev->regmap = devm_regmap_init_mmio_clk(dev, NULL, base,\n\t\t\t\t\t\t &imx2_wdt_regmap_config);\n\tif (IS_ERR(wdev->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(wdev->regmap);\n\t}\n\n\twdev->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(wdev->clk)) {\n\t\tdev_err(dev, \"can't get Watchdog clock\\n\");\n\t\treturn PTR_ERR(wdev->clk);\n\t}\n\n\twdog\t\t\t= &wdev->wdog;\n\twdog->info\t\t= &imx2_wdt_info;\n\twdog->ops\t\t= &imx2_wdt_ops;\n\twdog->min_timeout\t= 1;\n\twdog->timeout\t\t= IMX2_WDT_DEFAULT_TIME;\n\twdog->max_hw_heartbeat_ms = IMX2_WDT_MAX_TIME * 1000;\n\twdog->parent\t\t= dev;\n\n\twdev->data = of_device_get_match_data(dev);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret > 0)\n\t\tif (!devm_request_irq(dev, ret, imx2_wdt_isr, 0,\n\t\t\t\t      dev_name(dev), wdog))\n\t\t\twdog->info = &imx2_wdt_pretimeout_info;\n\n\tret = clk_prepare_enable(wdev->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, imx2_wdt_action, wdev->clk);\n\tif (ret)\n\t\treturn ret;\n\n\twdev->clk_is_on = true;\n\n\tregmap_read(wdev->regmap, IMX2_WDT_WRSR, &val);\n\twdog->bootstatus = val & IMX2_WDT_WRSR_TOUT ? WDIOF_CARDRESET : 0;\n\n\twdev->ext_reset = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\"fsl,ext-reset-output\");\n\n\tif (of_property_read_bool(dev->of_node, \"fsl,suspend-in-wait\")) {\n\t\tif (!wdev->data->wdw_supported) {\n\t\t\tdev_err(dev, \"suspend-in-wait not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twdev->sleep_wait = true;\n\t}\n\n\t \n\twdev->no_ping = !of_device_is_compatible(dev->of_node, \"fsl,imx7d-wdt\");\n\tplatform_set_drvdata(pdev, wdog);\n\twatchdog_set_drvdata(wdog, wdev);\n\twatchdog_set_nowayout(wdog, nowayout);\n\twatchdog_set_restart_priority(wdog, 128);\n\twatchdog_init_timeout(wdog, timeout, dev);\n\tif (wdev->no_ping)\n\t\twatchdog_stop_ping_on_suspend(wdog);\n\n\tif (imx2_wdt_is_running(wdev)) {\n\t\timx2_wdt_set_timeout(wdog, wdog->timeout);\n\t\tset_bit(WDOG_HW_RUNNING, &wdog->status);\n\t}\n\n\t \n\tregmap_write(wdev->regmap, IMX2_WDT_WMCR, 0);\n\n\treturn devm_watchdog_register_device(dev, wdog);\n}\n\nstatic void imx2_wdt_shutdown(struct platform_device *pdev)\n{\n\tstruct watchdog_device *wdog = platform_get_drvdata(pdev);\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\n\tif (imx2_wdt_is_running(wdev)) {\n\t\t \n\t\timx2_wdt_set_timeout(wdog, IMX2_WDT_MAX_TIME);\n\t\timx2_wdt_ping(wdog);\n\t\tdev_crit(&pdev->dev, \"Device shutdown.\\n\");\n\t}\n}\n\n \nstatic int __maybe_unused imx2_wdt_suspend(struct device *dev)\n{\n\tstruct watchdog_device *wdog = dev_get_drvdata(dev);\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\n\t \n\tif (imx2_wdt_is_running(wdev)) {\n\t\t \n\t\t__imx2_wdt_set_timeout(wdog, IMX2_WDT_MAX_TIME);\n\t\timx2_wdt_ping(wdog);\n\t}\n\n\tif (wdev->no_ping) {\n\t\tclk_disable_unprepare(wdev->clk);\n\n\t\twdev->clk_is_on = false;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused imx2_wdt_resume(struct device *dev)\n{\n\tstruct watchdog_device *wdog = dev_get_drvdata(dev);\n\tstruct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\tint ret;\n\n\tif (wdev->no_ping) {\n\t\tret = clk_prepare_enable(wdev->clk);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twdev->clk_is_on = true;\n\t}\n\n\tif (watchdog_active(wdog) && !imx2_wdt_is_running(wdev)) {\n\t\t \n\t\timx2_wdt_setup(wdog);\n\t}\n\tif (imx2_wdt_is_running(wdev)) {\n\t\timx2_wdt_set_timeout(wdog, wdog->timeout);\n\t\timx2_wdt_ping(wdog);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(imx2_wdt_pm_ops, imx2_wdt_suspend,\n\t\t\t imx2_wdt_resume);\n\nstatic struct imx2_wdt_data imx_wdt = {\n\t.wdw_supported = true,\n};\n\nstatic struct imx2_wdt_data imx_wdt_legacy = {\n\t.wdw_supported = false,\n};\n\nstatic const struct of_device_id imx2_wdt_dt_ids[] = {\n\t{ .compatible = \"fsl,imx21-wdt\", .data = &imx_wdt_legacy },\n\t{ .compatible = \"fsl,imx25-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx27-wdt\", .data = &imx_wdt_legacy },\n\t{ .compatible = \"fsl,imx31-wdt\", .data = &imx_wdt_legacy },\n\t{ .compatible = \"fsl,imx35-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx50-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx51-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx53-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx6q-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx6sl-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx6sll-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx6sx-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx6ul-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx7d-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx8mm-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx8mn-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx8mp-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,imx8mq-wdt\", .data = &imx_wdt },\n\t{ .compatible = \"fsl,ls1012a-wdt\", .data = &imx_wdt_legacy },\n\t{ .compatible = \"fsl,ls1043a-wdt\", .data = &imx_wdt_legacy },\n\t{ .compatible = \"fsl,vf610-wdt\", .data = &imx_wdt },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx2_wdt_dt_ids);\n\nstatic struct platform_driver imx2_wdt_driver = {\n\t.shutdown\t= imx2_wdt_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm     = &imx2_wdt_pm_ops,\n\t\t.of_match_table = imx2_wdt_dt_ids,\n\t},\n};\n\nmodule_platform_driver_probe(imx2_wdt_driver, imx2_wdt_probe);\n\nMODULE_AUTHOR(\"Wolfram Sang\");\nMODULE_DESCRIPTION(\"Watchdog driver for IMX2 and later\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}