{
  "module_name": "max63xx_wdt.c",
  "hash_id": "3b3d073d7a7b4e93f1c5d673e95d0d6a6ce7608a2a7bfe9356c25a00d339e247",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/max63xx_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/watchdog.h>\n#include <linux/bitops.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/property.h>\n\n#define DEFAULT_HEARTBEAT 60\n#define MAX_HEARTBEAT     60\n\nstatic unsigned int heartbeat = DEFAULT_HEARTBEAT;\nstatic bool nowayout  = WATCHDOG_NOWAYOUT;\n\n \n#define MAX6369_WDSET\t(7 << 0)\n#define MAX6369_WDI\t(1 << 3)\n\n#define MAX6369_WDSET_DISABLED\t3\n\nstatic int nodelay;\n\nstruct max63xx_wdt {\n\tstruct watchdog_device wdd;\n\tconst struct max63xx_timeout *timeout;\n\n\t \n\tvoid __iomem *base;\n\tspinlock_t lock;\n\n\t \n\tvoid (*ping)(struct max63xx_wdt *wdt);\n\tvoid (*set)(struct max63xx_wdt *wdt, u8 set);\n};\n\n \n\n \nstruct max63xx_timeout {\n\tconst u8 wdset;\n\tconst u8 tdelay;\n\tconst u8 twd;\n};\n\nstatic const struct max63xx_timeout max6369_table[] = {\n\t{ 5,  1,  1 },\n\t{ 6, 10, 10 },\n\t{ 7, 60, 60 },\n\t{ },\n};\n\nstatic const struct max63xx_timeout max6371_table[] = {\n\t{ 6, 60,  3 },\n\t{ 7, 60, 60 },\n\t{ },\n};\n\nstatic const struct max63xx_timeout max6373_table[] = {\n\t{ 2, 60,  1 },\n\t{ 5,  0,  1 },\n\t{ 1,  3,  3 },\n\t{ 7, 60, 10 },\n\t{ 6,  0, 10 },\n\t{ },\n};\n\nstatic const struct max63xx_timeout *\nmax63xx_select_timeout(const struct max63xx_timeout *table, int value)\n{\n\twhile (table->twd) {\n\t\tif (value <= table->twd) {\n\t\t\tif (nodelay && table->tdelay == 0)\n\t\t\t\treturn table;\n\n\t\t\tif (!nodelay)\n\t\t\t\treturn table;\n\t\t}\n\n\t\ttable++;\n\t}\n\n\treturn NULL;\n}\n\nstatic int max63xx_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct max63xx_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twdt->ping(wdt);\n\treturn 0;\n}\n\nstatic int max63xx_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct max63xx_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twdt->set(wdt, wdt->timeout->wdset);\n\n\t \n\tif (wdt->timeout->tdelay == 0)\n\t\twdt->ping(wdt);\n\treturn 0;\n}\n\nstatic int max63xx_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct max63xx_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twdt->set(wdt, MAX6369_WDSET_DISABLED);\n\treturn 0;\n}\n\nstatic const struct watchdog_ops max63xx_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = max63xx_wdt_start,\n\t.stop = max63xx_wdt_stop,\n\t.ping = max63xx_wdt_ping,\n};\n\nstatic const struct watchdog_info max63xx_wdt_info = {\n\t.options = WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"max63xx Watchdog\",\n};\n\nstatic void max63xx_mmap_ping(struct max63xx_wdt *wdt)\n{\n\tu8 val;\n\n\tspin_lock(&wdt->lock);\n\n\tval = __raw_readb(wdt->base);\n\n\t__raw_writeb(val | MAX6369_WDI, wdt->base);\n\t__raw_writeb(val & ~MAX6369_WDI, wdt->base);\n\n\tspin_unlock(&wdt->lock);\n}\n\nstatic void max63xx_mmap_set(struct max63xx_wdt *wdt, u8 set)\n{\n\tu8 val;\n\n\tspin_lock(&wdt->lock);\n\n\tval = __raw_readb(wdt->base);\n\tval &= ~MAX6369_WDSET;\n\tval |= set & MAX6369_WDSET;\n\t__raw_writeb(val, wdt->base);\n\n\tspin_unlock(&wdt->lock);\n}\n\nstatic int max63xx_mmap_init(struct platform_device *p, struct max63xx_wdt *wdt)\n{\n\twdt->base = devm_platform_ioremap_resource(p, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\tspin_lock_init(&wdt->lock);\n\n\twdt->ping = max63xx_mmap_ping;\n\twdt->set = max63xx_mmap_set;\n\treturn 0;\n}\n\nstatic int max63xx_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct max63xx_wdt *wdt;\n\tconst struct max63xx_timeout *table;\n\tint err;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\t \n\ttable = device_get_match_data(dev);\n\tif (!table)\n\t\ttable = (struct max63xx_timeout *)pdev->id_entry->driver_data;\n\n\tif (heartbeat < 1 || heartbeat > MAX_HEARTBEAT)\n\t\theartbeat = DEFAULT_HEARTBEAT;\n\n\twdt->timeout = max63xx_select_timeout(table, heartbeat);\n\tif (!wdt->timeout) {\n\t\tdev_err(dev, \"unable to satisfy %ds heartbeat request\\n\",\n\t\t\theartbeat);\n\t\treturn -EINVAL;\n\t}\n\n\terr = max63xx_mmap_init(pdev, wdt);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, &wdt->wdd);\n\twatchdog_set_drvdata(&wdt->wdd, wdt);\n\n\twdt->wdd.parent = dev;\n\twdt->wdd.timeout = wdt->timeout->twd;\n\twdt->wdd.info = &max63xx_wdt_info;\n\twdt->wdd.ops = &max63xx_wdt_ops;\n\n\twatchdog_set_nowayout(&wdt->wdd, nowayout);\n\n\terr = devm_watchdog_register_device(dev, &wdt->wdd);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(dev, \"using %ds heartbeat with %ds initial delay\\n\",\n\t\t wdt->timeout->twd, wdt->timeout->tdelay);\n\treturn 0;\n}\n\nstatic const struct platform_device_id max63xx_id_table[] = {\n\t{ \"max6369_wdt\", (kernel_ulong_t)max6369_table, },\n\t{ \"max6370_wdt\", (kernel_ulong_t)max6369_table, },\n\t{ \"max6371_wdt\", (kernel_ulong_t)max6371_table, },\n\t{ \"max6372_wdt\", (kernel_ulong_t)max6371_table, },\n\t{ \"max6373_wdt\", (kernel_ulong_t)max6373_table, },\n\t{ \"max6374_wdt\", (kernel_ulong_t)max6373_table, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, max63xx_id_table);\n\nstatic const struct of_device_id max63xx_dt_id_table[] = {\n\t{ .compatible = \"maxim,max6369\", .data = max6369_table, },\n\t{ .compatible = \"maxim,max6370\", .data = max6369_table, },\n\t{ .compatible = \"maxim,max6371\", .data = max6371_table, },\n\t{ .compatible = \"maxim,max6372\", .data = max6371_table, },\n\t{ .compatible = \"maxim,max6373\", .data = max6373_table, },\n\t{ .compatible = \"maxim,max6374\", .data = max6373_table, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max63xx_dt_id_table);\n\nstatic struct platform_driver max63xx_wdt_driver = {\n\t.probe\t\t= max63xx_wdt_probe,\n\t.id_table\t= max63xx_id_table,\n\t.driver\t\t= {\n\t\t.name\t= \"max63xx_wdt\",\n\t\t.of_match_table = max63xx_dt_id_table,\n\t},\n};\n\nmodule_platform_driver(max63xx_wdt_driver);\n\nMODULE_AUTHOR(\"Marc Zyngier <maz@misterjones.org>\");\nMODULE_DESCRIPTION(\"max63xx Watchdog Driver\");\n\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\t \"Watchdog heartbeat period in seconds from 1 to \"\n\t\t __MODULE_STRING(MAX_HEARTBEAT) \", default \"\n\t\t __MODULE_STRING(DEFAULT_HEARTBEAT));\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nmodule_param(nodelay, int, 0);\nMODULE_PARM_DESC(nodelay,\n\t\t \"Force selection of a timeout setting without initial delay \"\n\t\t \"(max6373/74 only, default=0)\");\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}