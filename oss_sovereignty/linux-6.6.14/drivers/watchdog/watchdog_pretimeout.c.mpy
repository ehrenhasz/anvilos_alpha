{
  "module_name": "watchdog_pretimeout.c",
  "hash_id": "5fbc53974a848e2c157d9e989230631637619c0abfe21359ab13b1cd4dc6b312",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/watchdog_pretimeout.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/watchdog.h>\n\n#include \"watchdog_core.h\"\n#include \"watchdog_pretimeout.h\"\n\n \nstatic struct watchdog_governor *default_gov;\n\n \nstatic DEFINE_SPINLOCK(pretimeout_lock);\n\n \nstatic LIST_HEAD(pretimeout_list);\n\nstruct watchdog_pretimeout {\n\tstruct watchdog_device\t\t*wdd;\n\tstruct list_head\t\tentry;\n};\n\n \nstatic DEFINE_MUTEX(governor_lock);\n\n \nstatic LIST_HEAD(governor_list);\n\nstruct governor_priv {\n\tstruct watchdog_governor\t*gov;\n\tstruct list_head\t\tentry;\n};\n\nstatic struct governor_priv *find_governor_by_name(const char *gov_name)\n{\n\tstruct governor_priv *priv;\n\n\tlist_for_each_entry(priv, &governor_list, entry)\n\t\tif (sysfs_streq(gov_name, priv->gov->name))\n\t\t\treturn priv;\n\n\treturn NULL;\n}\n\nint watchdog_pretimeout_available_governors_get(char *buf)\n{\n\tstruct governor_priv *priv;\n\tint count = 0;\n\n\tmutex_lock(&governor_lock);\n\n\tlist_for_each_entry(priv, &governor_list, entry)\n\t\tcount += sysfs_emit_at(buf, count, \"%s\\n\", priv->gov->name);\n\n\tmutex_unlock(&governor_lock);\n\n\treturn count;\n}\n\nint watchdog_pretimeout_governor_get(struct watchdog_device *wdd, char *buf)\n{\n\tint count = 0;\n\n\tspin_lock_irq(&pretimeout_lock);\n\tif (wdd->gov)\n\t\tcount = sysfs_emit(buf, \"%s\\n\", wdd->gov->name);\n\tspin_unlock_irq(&pretimeout_lock);\n\n\treturn count;\n}\n\nint watchdog_pretimeout_governor_set(struct watchdog_device *wdd,\n\t\t\t\t     const char *buf)\n{\n\tstruct governor_priv *priv;\n\n\tmutex_lock(&governor_lock);\n\n\tpriv = find_governor_by_name(buf);\n\tif (!priv) {\n\t\tmutex_unlock(&governor_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&pretimeout_lock);\n\twdd->gov = priv->gov;\n\tspin_unlock_irq(&pretimeout_lock);\n\n\tmutex_unlock(&governor_lock);\n\n\treturn 0;\n}\n\nvoid watchdog_notify_pretimeout(struct watchdog_device *wdd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pretimeout_lock, flags);\n\tif (!wdd->gov) {\n\t\tspin_unlock_irqrestore(&pretimeout_lock, flags);\n\t\treturn;\n\t}\n\n\twdd->gov->pretimeout(wdd);\n\tspin_unlock_irqrestore(&pretimeout_lock, flags);\n}\nEXPORT_SYMBOL_GPL(watchdog_notify_pretimeout);\n\nint watchdog_register_governor(struct watchdog_governor *gov)\n{\n\tstruct watchdog_pretimeout *p;\n\tstruct governor_priv *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&governor_lock);\n\n\tif (find_governor_by_name(gov->name)) {\n\t\tmutex_unlock(&governor_lock);\n\t\tkfree(priv);\n\t\treturn -EBUSY;\n\t}\n\n\tpriv->gov = gov;\n\tlist_add(&priv->entry, &governor_list);\n\n\tif (!strncmp(gov->name, WATCHDOG_PRETIMEOUT_DEFAULT_GOV,\n\t\t     WATCHDOG_GOV_NAME_MAXLEN)) {\n\t\tspin_lock_irq(&pretimeout_lock);\n\t\tdefault_gov = gov;\n\n\t\tlist_for_each_entry(p, &pretimeout_list, entry)\n\t\t\tif (!p->wdd->gov)\n\t\t\t\tp->wdd->gov = default_gov;\n\t\tspin_unlock_irq(&pretimeout_lock);\n\t}\n\n\tmutex_unlock(&governor_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(watchdog_register_governor);\n\nvoid watchdog_unregister_governor(struct watchdog_governor *gov)\n{\n\tstruct watchdog_pretimeout *p;\n\tstruct governor_priv *priv, *t;\n\n\tmutex_lock(&governor_lock);\n\n\tlist_for_each_entry_safe(priv, t, &governor_list, entry) {\n\t\tif (priv->gov == gov) {\n\t\t\tlist_del(&priv->entry);\n\t\t\tkfree(priv);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_lock_irq(&pretimeout_lock);\n\tlist_for_each_entry(p, &pretimeout_list, entry)\n\t\tif (p->wdd->gov == gov)\n\t\t\tp->wdd->gov = default_gov;\n\tspin_unlock_irq(&pretimeout_lock);\n\n\tmutex_unlock(&governor_lock);\n}\nEXPORT_SYMBOL(watchdog_unregister_governor);\n\nint watchdog_register_pretimeout(struct watchdog_device *wdd)\n{\n\tstruct watchdog_pretimeout *p;\n\n\tif (!watchdog_have_pretimeout(wdd))\n\t\treturn 0;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&pretimeout_lock);\n\tlist_add(&p->entry, &pretimeout_list);\n\tp->wdd = wdd;\n\twdd->gov = default_gov;\n\tspin_unlock_irq(&pretimeout_lock);\n\n\treturn 0;\n}\n\nvoid watchdog_unregister_pretimeout(struct watchdog_device *wdd)\n{\n\tstruct watchdog_pretimeout *p, *t;\n\n\tif (!watchdog_have_pretimeout(wdd))\n\t\treturn;\n\n\tspin_lock_irq(&pretimeout_lock);\n\twdd->gov = NULL;\n\n\tlist_for_each_entry_safe(p, t, &pretimeout_list, entry) {\n\t\tif (p->wdd == wdd) {\n\t\t\tlist_del(&p->entry);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&pretimeout_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}