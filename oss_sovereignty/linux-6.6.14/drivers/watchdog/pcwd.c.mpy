{
  "module_name": "pcwd.c",
  "hash_id": "21c5a6501ad95ff019787a59ce8d70dfb32d0b2c11e726449a3d8e2191148518",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pcwd.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\t \n#include <linux/moduleparam.h>\t \n#include <linux/types.h>\t \n#include <linux/errno.h>\t \n#include <linux/kernel.h>\t \n#include <linux/delay.h>\t \n#include <linux/timer.h>\t \n#include <linux/jiffies.h>\t \n#include <linux/miscdevice.h>\t \n#include <linux/watchdog.h>\t \n#include <linux/reboot.h>\t \n#include <linux/init.h>\t\t \n#include <linux/fs.h>\t\t \n#include <linux/isa.h>\t\t \n#include <linux/ioport.h>\t \n#include <linux/spinlock.h>\t \n#include <linux/uaccess.h>\t \n#include <linux/io.h>\t\t \n\n \n#define WATCHDOG_VERSION \"1.20\"\n#define WATCHDOG_DATE \"18 Feb 2007\"\n#define WATCHDOG_DRIVER_NAME \"ISA-PC Watchdog\"\n#define WATCHDOG_NAME \"pcwd\"\n#define DRIVER_VERSION WATCHDOG_DRIVER_NAME \" driver, v\" WATCHDOG_VERSION \"\\n\"\n\n \n#define\tPCWD_REVISION_A\t\t1\n#define\tPCWD_REVISION_C\t\t2\n\n \n#define PCWD_ISA_NR_CARDS\t3\nstatic int pcwd_ioports[] = { 0x270, 0x350, 0x370, 0x000 };\n\n \n \n#define WD_WDRST\t\t0x01\t \n#define WD_T110\t\t\t0x02\t \n#define WD_HRTBT\t\t0x04\t \n#define WD_RLY2\t\t\t0x08\t \n#define WD_SRLY2\t\t0x80\t \n \n#define WD_REVC_WTRP\t\t0x01\t \n#define WD_REVC_HRBT\t\t0x02\t \n#define WD_REVC_TTRP\t\t0x04\t \n#define WD_REVC_RL2A\t\t0x08\t \n#define WD_REVC_RL1A\t\t0x10\t \n#define WD_REVC_R2DS\t\t0x40\t \n#define WD_REVC_RLY2\t\t0x80\t \n \n#define WD_WDIS\t\t\t0x10\t \n#define WD_ENTP\t\t\t0x20\t \n#define WD_SSEL\t\t\t0x40\t \n#define WD_WCMD\t\t\t0x80\t \n\n \n \n#define ISA_COMMAND_TIMEOUT     1000\n\n \n#define CMD_ISA_IDLE\t\t\t0x00\n#define CMD_ISA_VERSION_INTEGER\t\t0x01\n#define CMD_ISA_VERSION_TENTH\t\t0x02\n#define CMD_ISA_VERSION_HUNDRETH\t0x03\n#define CMD_ISA_VERSION_MINOR\t\t0x04\n#define CMD_ISA_SWITCH_SETTINGS\t\t0x05\n#define CMD_ISA_RESET_PC\t\t0x06\n#define CMD_ISA_ARM_0\t\t\t0x07\n#define CMD_ISA_ARM_30\t\t\t0x08\n#define CMD_ISA_ARM_60\t\t\t0x09\n#define CMD_ISA_DELAY_TIME_2SECS\t0x0A\n#define CMD_ISA_DELAY_TIME_4SECS\t0x0B\n#define CMD_ISA_DELAY_TIME_8SECS\t0x0C\n#define CMD_ISA_RESET_RELAYS\t\t0x0D\n\n \nstatic const int heartbeat_tbl[] = {\n\t20,\t \n\t40,\t \n\t60,\t \n\t300,\t \n\t600,\t \n\t1800,\t \n\t3600,\t \n\t7200,\t \n};\n\n \n\n#define WDT_INTERVAL (HZ/2+1)\n\n \nstatic int cards_found;\n\n \nstatic unsigned long open_allowed;\nstatic char expect_close;\nstatic int temp_panic;\n\n \nstatic struct {\n\tchar fw_ver_str[6];\t\t \n\tint revision;\t\t\t \n\tint supports_temp;\t\t \n\tint command_mode;\t\t \n\tint boot_status;\t\t \n\tint io_addr;\t\t\t \n\tspinlock_t io_lock;\t\t \n\tstruct timer_list timer;\t \n\tunsigned long next_heartbeat;\t \n} pcwd_private;\n\n \n#define QUIET\t0\t \n#define VERBOSE\t1\t \n#define DEBUG\t2\t \nstatic int debug = QUIET;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug,\n\t\t\"Debug level: 0=Quiet, 1=Verbose, 2=Debug (default=0)\");\n\n \n#define WATCHDOG_HEARTBEAT 0\nstatic int heartbeat = WATCHDOG_HEARTBEAT;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeat in seconds. \"\n\t\"(2 <= heartbeat <= 7200 or 0=delay-time from dip-switches, default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_HEARTBEAT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n\nstatic int send_isa_command(int cmd)\n{\n\tint i;\n\tint control_status;\n\tint port0, last_port0;\t \n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"sending following data cmd=0x%02x\\n\", cmd);\n\n\t \n\tcontrol_status = (cmd & 0x0F) | WD_WCMD;\n\toutb_p(control_status, pcwd_private.io_addr + 2);\n\tudelay(ISA_COMMAND_TIMEOUT);\n\n\tport0 = inb_p(pcwd_private.io_addr);\n\tfor (i = 0; i < 25; ++i) {\n\t\tlast_port0 = port0;\n\t\tport0 = inb_p(pcwd_private.io_addr);\n\n\t\tif (port0 == last_port0)\n\t\t\tbreak;\t \n\n\t\tudelay(250);\n\t}\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"received following data for cmd=0x%02x: port0=0x%02x last_port0=0x%02x\\n\",\n\t\t\t cmd, port0, last_port0);\n\n\treturn port0;\n}\n\nstatic int set_command_mode(void)\n{\n\tint i, found = 0, count = 0;\n\n\t \n\tspin_lock(&pcwd_private.io_lock);\n\twhile ((!found) && (count < 3)) {\n\t\ti = send_isa_command(CMD_ISA_IDLE);\n\n\t\tif (i == 0x00)\n\t\t\tfound = 1;\n\t\telse if (i == 0xF3) {\n\t\t\t \n\t\t\toutb_p(0x00, pcwd_private.io_addr + 2);\n\t\t\tudelay(1200);\t \n\t\t\toutb_p(0x00, pcwd_private.io_addr + 2);\n\t\t\tudelay(ISA_COMMAND_TIMEOUT);\n\t\t}\n\t\tcount++;\n\t}\n\tspin_unlock(&pcwd_private.io_lock);\n\tpcwd_private.command_mode = found;\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"command_mode=%d\\n\", pcwd_private.command_mode);\n\n\treturn found;\n}\n\nstatic void unset_command_mode(void)\n{\n\t \n\tspin_lock(&pcwd_private.io_lock);\n\toutb_p(0x00, pcwd_private.io_addr + 2);\n\tudelay(ISA_COMMAND_TIMEOUT);\n\tspin_unlock(&pcwd_private.io_lock);\n\n\tpcwd_private.command_mode = 0;\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"command_mode=%d\\n\", pcwd_private.command_mode);\n}\n\nstatic inline void pcwd_check_temperature_support(void)\n{\n\tif (inb(pcwd_private.io_addr) != 0xF0)\n\t\tpcwd_private.supports_temp = 1;\n}\n\nstatic inline void pcwd_get_firmware(void)\n{\n\tint one, ten, hund, minor;\n\n\tstrcpy(pcwd_private.fw_ver_str, \"ERROR\");\n\n\tif (set_command_mode()) {\n\t\tone = send_isa_command(CMD_ISA_VERSION_INTEGER);\n\t\tten = send_isa_command(CMD_ISA_VERSION_TENTH);\n\t\thund = send_isa_command(CMD_ISA_VERSION_HUNDRETH);\n\t\tminor = send_isa_command(CMD_ISA_VERSION_MINOR);\n\t\tsprintf(pcwd_private.fw_ver_str, \"%c.%c%c%c\",\n\t\t\t\t\tone, ten, hund, minor);\n\t}\n\tunset_command_mode();\n\n\treturn;\n}\n\nstatic inline int pcwd_get_option_switches(void)\n{\n\tint option_switches = 0;\n\n\tif (set_command_mode()) {\n\t\t \n\t\toption_switches = send_isa_command(CMD_ISA_SWITCH_SETTINGS);\n\t}\n\n\tunset_command_mode();\n\treturn option_switches;\n}\n\nstatic void pcwd_show_card_info(void)\n{\n\tint option_switches;\n\n\t \n\tif (pcwd_private.revision == PCWD_REVISION_A)\n\t\tpr_info(\"ISA-PC Watchdog (REV.A) detected at port 0x%04x\\n\",\n\t\t\tpcwd_private.io_addr);\n\telse if (pcwd_private.revision == PCWD_REVISION_C) {\n\t\tpcwd_get_firmware();\n\t\tpr_info(\"ISA-PC Watchdog (REV.C) detected at port 0x%04x (Firmware version: %s)\\n\",\n\t\t\tpcwd_private.io_addr, pcwd_private.fw_ver_str);\n\t\toption_switches = pcwd_get_option_switches();\n\t\tpr_info(\"Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s\\n\",\n\t\t\toption_switches,\n\t\t\t((option_switches & 0x10) ? \"ON\" : \"OFF\"),\n\t\t\t((option_switches & 0x08) ? \"ON\" : \"OFF\"));\n\n\t\t \n\t\tif (set_command_mode()) {\n\t\t\tsend_isa_command(CMD_ISA_DELAY_TIME_2SECS);\n\t\t\tunset_command_mode();\n\t\t}\n\t}\n\n\tif (pcwd_private.supports_temp)\n\t\tpr_info(\"Temperature Option Detected\\n\");\n\n\tif (pcwd_private.boot_status & WDIOF_CARDRESET)\n\t\tpr_info(\"Previous reboot was caused by the card\\n\");\n\n\tif (pcwd_private.boot_status & WDIOF_OVERHEAT) {\n\t\tpr_emerg(\"Card senses a CPU Overheat. Panicking!\\n\");\n\t\tpr_emerg(\"CPU Overheat\\n\");\n\t}\n\n\tif (pcwd_private.boot_status == 0)\n\t\tpr_info(\"No previous trip detected - Cold boot or reset\\n\");\n}\n\nstatic void pcwd_timer_ping(struct timer_list *unused)\n{\n\tint wdrst_stat;\n\n\t \n\tif (time_before(jiffies, pcwd_private.next_heartbeat)) {\n\t\t \n\t\tspin_lock(&pcwd_private.io_lock);\n\t\tif (pcwd_private.revision == PCWD_REVISION_A) {\n\t\t\t \n\t\t\twdrst_stat = inb_p(pcwd_private.io_addr);\n\t\t\twdrst_stat &= 0x0F;\n\t\t\twdrst_stat |= WD_WDRST;\n\n\t\t\toutb_p(wdrst_stat, pcwd_private.io_addr + 1);\n\t\t} else {\n\t\t\t \n\t\t\toutb_p(0x00, pcwd_private.io_addr);\n\t\t}\n\n\t\t \n\t\tmod_timer(&pcwd_private.timer, jiffies + WDT_INTERVAL);\n\n\t\tspin_unlock(&pcwd_private.io_lock);\n\t} else {\n\t\tpr_warn(\"Heartbeat lost! Will not ping the watchdog\\n\");\n\t}\n}\n\nstatic int pcwd_start(void)\n{\n\tint stat_reg;\n\n\tpcwd_private.next_heartbeat = jiffies + (heartbeat * HZ);\n\n\t \n\tmod_timer(&pcwd_private.timer, jiffies + WDT_INTERVAL);\n\n\t \n\tif (pcwd_private.revision == PCWD_REVISION_C) {\n\t\tspin_lock(&pcwd_private.io_lock);\n\t\toutb_p(0x00, pcwd_private.io_addr + 3);\n\t\tudelay(ISA_COMMAND_TIMEOUT);\n\t\tstat_reg = inb_p(pcwd_private.io_addr + 2);\n\t\tspin_unlock(&pcwd_private.io_lock);\n\t\tif (stat_reg & WD_WDIS) {\n\t\t\tpr_info(\"Could not start watchdog\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (debug >= VERBOSE)\n\t\tpr_debug(\"Watchdog started\\n\");\n\n\treturn 0;\n}\n\nstatic int pcwd_stop(void)\n{\n\tint stat_reg;\n\n\t \n\tdel_timer(&pcwd_private.timer);\n\n\t \n\tif (pcwd_private.revision == PCWD_REVISION_C) {\n\t\tspin_lock(&pcwd_private.io_lock);\n\t\toutb_p(0xA5, pcwd_private.io_addr + 3);\n\t\tudelay(ISA_COMMAND_TIMEOUT);\n\t\toutb_p(0xA5, pcwd_private.io_addr + 3);\n\t\tudelay(ISA_COMMAND_TIMEOUT);\n\t\tstat_reg = inb_p(pcwd_private.io_addr + 2);\n\t\tspin_unlock(&pcwd_private.io_lock);\n\t\tif ((stat_reg & WD_WDIS) == 0) {\n\t\t\tpr_info(\"Could not stop watchdog\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (debug >= VERBOSE)\n\t\tpr_debug(\"Watchdog stopped\\n\");\n\n\treturn 0;\n}\n\nstatic int pcwd_keepalive(void)\n{\n\t \n\tpcwd_private.next_heartbeat = jiffies + (heartbeat * HZ);\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"Watchdog keepalive signal send\\n\");\n\n\treturn 0;\n}\n\nstatic int pcwd_set_heartbeat(int t)\n{\n\tif (t < 2 || t > 7200)  \n\t\treturn -EINVAL;\n\n\theartbeat = t;\n\n\tif (debug >= VERBOSE)\n\t\tpr_debug(\"New heartbeat: %d\\n\", heartbeat);\n\n\treturn 0;\n}\n\nstatic int pcwd_get_status(int *status)\n{\n\tint control_status;\n\n\t*status = 0;\n\tspin_lock(&pcwd_private.io_lock);\n\tif (pcwd_private.revision == PCWD_REVISION_A)\n\t\t \n\t\tcontrol_status = inb(pcwd_private.io_addr);\n\telse {\n\t\t \n\t\tcontrol_status = inb(pcwd_private.io_addr + 1);\n\t}\n\tspin_unlock(&pcwd_private.io_lock);\n\n\tif (pcwd_private.revision == PCWD_REVISION_A) {\n\t\tif (control_status & WD_WDRST)\n\t\t\t*status |= WDIOF_CARDRESET;\n\n\t\tif (control_status & WD_T110) {\n\t\t\t*status |= WDIOF_OVERHEAT;\n\t\t\tif (temp_panic) {\n\t\t\t\tpr_info(\"Temperature overheat trip!\\n\");\n\t\t\t\tkernel_power_off();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (control_status & WD_REVC_WTRP)\n\t\t\t*status |= WDIOF_CARDRESET;\n\n\t\tif (control_status & WD_REVC_TTRP) {\n\t\t\t*status |= WDIOF_OVERHEAT;\n\t\t\tif (temp_panic) {\n\t\t\t\tpr_info(\"Temperature overheat trip!\\n\");\n\t\t\t\tkernel_power_off();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pcwd_clear_status(void)\n{\n\tint control_status;\n\n\tif (pcwd_private.revision == PCWD_REVISION_C) {\n\t\tspin_lock(&pcwd_private.io_lock);\n\n\t\tif (debug >= VERBOSE)\n\t\t\tpr_info(\"clearing watchdog trip status\\n\");\n\n\t\tcontrol_status = inb_p(pcwd_private.io_addr + 1);\n\n\t\tif (debug >= DEBUG) {\n\t\t\tpr_debug(\"status was: 0x%02x\\n\", control_status);\n\t\t\tpr_debug(\"sending: 0x%02x\\n\",\n\t\t\t\t (control_status & WD_REVC_R2DS));\n\t\t}\n\n\t\t \n\t\toutb_p((control_status & WD_REVC_R2DS),\n\t\t\t\t\t\tpcwd_private.io_addr + 1);\n\n\t\tspin_unlock(&pcwd_private.io_lock);\n\t}\n\treturn 0;\n}\n\nstatic int pcwd_get_temperature(int *temperature)\n{\n\t \n\tif (pcwd_private.command_mode)\n\t\treturn -1;\n\n\t*temperature = 0;\n\tif (!pcwd_private.supports_temp)\n\t\treturn -ENODEV;\n\n\t \n\tspin_lock(&pcwd_private.io_lock);\n\t*temperature = ((inb(pcwd_private.io_addr)) * 9 / 5) + 32;\n\tspin_unlock(&pcwd_private.io_lock);\n\n\tif (debug >= DEBUG) {\n\t\tpr_debug(\"temperature is: %d F\\n\", *temperature);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic long pcwd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint rv;\n\tint status;\n\tint temperature;\n\tint new_heartbeat;\n\tint __user *argp = (int __user *)arg;\n\tstatic const struct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_OVERHEAT |\n\t\t\t\t\tWDIOF_CARDRESET |\n\t\t\t\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\t\tWDIOF_SETTIMEOUT |\n\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.firmware_version =\t1,\n\t\t.identity =\t\t\"PCWD\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase WDIOC_GETSTATUS:\n\t\tpcwd_get_status(&status);\n\t\treturn put_user(status, argp);\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(pcwd_private.boot_status, argp);\n\n\tcase WDIOC_GETTEMP:\n\t\tif (pcwd_get_temperature(&temperature))\n\t\t\treturn -EFAULT;\n\n\t\treturn put_user(temperature, argp);\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (pcwd_private.revision == PCWD_REVISION_C) {\n\t\t\tif (get_user(rv, argp))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (rv & WDIOS_DISABLECARD) {\n\t\t\t\tstatus = pcwd_stop();\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tif (rv & WDIOS_ENABLECARD) {\n\t\t\t\tstatus = pcwd_start();\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t\tif (rv & WDIOS_TEMPPANIC)\n\t\t\t\ttemp_panic = 1;\n\t\t}\n\t\treturn -EINVAL;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tpcwd_keepalive();\n\t\treturn 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_heartbeat, argp))\n\t\t\treturn -EFAULT;\n\n\t\tif (pcwd_set_heartbeat(new_heartbeat))\n\t\t\treturn -EINVAL;\n\n\t\tpcwd_keepalive();\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(heartbeat, argp);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t pcwd_write(struct file *file, const char __user *buf, size_t len,\n\t\t\t  loff_t *ppos)\n{\n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\t\tpcwd_keepalive();\n\t}\n\treturn len;\n}\n\nstatic int pcwd_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &open_allowed))\n\t\treturn -EBUSY;\n\tif (nowayout)\n\t\t__module_get(THIS_MODULE);\n\t \n\tpcwd_start();\n\tpcwd_keepalive();\n\treturn stream_open(inode, file);\n}\n\nstatic int pcwd_close(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42)\n\t\tpcwd_stop();\n\telse {\n\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\tpcwd_keepalive();\n\t}\n\texpect_close = 0;\n\tclear_bit(0, &open_allowed);\n\treturn 0;\n}\n\n \n\nstatic ssize_t pcwd_temp_read(struct file *file, char __user *buf, size_t count,\n\t\t\t loff_t *ppos)\n{\n\tint temperature;\n\n\tif (pcwd_get_temperature(&temperature))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(buf, &temperature, 1))\n\t\treturn -EFAULT;\n\n\treturn 1;\n}\n\nstatic int pcwd_temp_open(struct inode *inode, struct file *file)\n{\n\tif (!pcwd_private.supports_temp)\n\t\treturn -ENODEV;\n\n\treturn stream_open(inode, file);\n}\n\nstatic int pcwd_temp_close(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\n \n\nstatic const struct file_operations pcwd_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= pcwd_write,\n\t.unlocked_ioctl\t= pcwd_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= pcwd_open,\n\t.release\t= pcwd_close,\n};\n\nstatic struct miscdevice pcwd_miscdev = {\n\t.minor =\tWATCHDOG_MINOR,\n\t.name =\t\t\"watchdog\",\n\t.fops =\t\t&pcwd_fops,\n};\n\nstatic const struct file_operations pcwd_temp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= pcwd_temp_read,\n\t.open\t\t= pcwd_temp_open,\n\t.release\t= pcwd_temp_close,\n};\n\nstatic struct miscdevice temp_miscdev = {\n\t.minor =\tTEMP_MINOR,\n\t.name =\t\t\"temperature\",\n\t.fops =\t\t&pcwd_temp_fops,\n};\n\n \n\nstatic inline int get_revision(void)\n{\n\tint r = PCWD_REVISION_C;\n\n\tspin_lock(&pcwd_private.io_lock);\n\t \n\tif ((inb(pcwd_private.io_addr + 2) == 0xFF) ||\n\t    (inb(pcwd_private.io_addr + 3) == 0xFF))\n\t\tr = PCWD_REVISION_A;\n\tspin_unlock(&pcwd_private.io_lock);\n\n\treturn r;\n}\n\n \nstatic int pcwd_isa_match(struct device *dev, unsigned int id)\n{\n\tint base_addr = pcwd_ioports[id];\n\tint port0, last_port0;\t \n\tint port1, last_port1;\t \n\tint i;\n\tint retval;\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"pcwd_isa_match id=%d\\n\", id);\n\n\tif (!request_region(base_addr, 4, \"PCWD\")) {\n\t\tpr_info(\"Port 0x%04x unavailable\\n\", base_addr);\n\t\treturn 0;\n\t}\n\n\tretval = 0;\n\n\tport0 = inb_p(base_addr);\t \n\tport1 = inb_p(base_addr + 1);\t \n\tif (port0 != 0xff || port1 != 0xff) {\n\t\t \n\t\tfor (i = 0; i < 4; ++i) {\n\n\t\t\tmsleep(500);\n\n\t\t\tlast_port0 = port0;\n\t\t\tlast_port1 = port1;\n\n\t\t\tport0 = inb_p(base_addr);\n\t\t\tport1 = inb_p(base_addr + 1);\n\n\t\t\t \n\t\t\tif ((port0 ^ last_port0) & WD_HRTBT ||\n\t\t\t    (port1 ^ last_port1) & WD_REVC_HRBT) {\n\t\t\t\tretval = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trelease_region(base_addr, 4);\n\n\treturn retval;\n}\n\nstatic int pcwd_isa_probe(struct device *dev, unsigned int id)\n{\n\tint ret;\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"pcwd_isa_probe id=%d\\n\", id);\n\n\tcards_found++;\n\tif (cards_found == 1)\n\t\tpr_info(\"v%s Ken Hollis (kenji@bitgate.com)\\n\",\n\t\t\t\t\t\t\tWATCHDOG_VERSION);\n\n\tif (cards_found > 1) {\n\t\tpr_err(\"This driver only supports 1 device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pcwd_ioports[id] == 0x0000) {\n\t\tpr_err(\"No I/O-Address for card detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpcwd_private.io_addr = pcwd_ioports[id];\n\n\tspin_lock_init(&pcwd_private.io_lock);\n\n\t \n\tpcwd_private.revision = get_revision();\n\n\tif (!request_region(pcwd_private.io_addr,\n\t\t(pcwd_private.revision == PCWD_REVISION_A) ? 2 : 4, \"PCWD\")) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\",\n\t\t       pcwd_private.io_addr);\n\t\tret = -EIO;\n\t\tgoto error_request_region;\n\t}\n\n\t \n\tpcwd_private.supports_temp = 0;\n\ttemp_panic = 0;\n\tpcwd_private.boot_status = 0x0000;\n\n\t \n\tpcwd_get_status(&pcwd_private.boot_status);\n\n\t \n\tpcwd_clear_status();\n\n\ttimer_setup(&pcwd_private.timer, pcwd_timer_ping, 0);\n\n\t \n\tpcwd_stop();\n\n\t \n\tpcwd_check_temperature_support();\n\n\t \n\tpcwd_show_card_info();\n\n\t \n\tif (heartbeat == 0)\n\t\theartbeat = heartbeat_tbl[(pcwd_get_option_switches() & 0x07)];\n\n\t \n\tif (pcwd_set_heartbeat(heartbeat)) {\n\t\tpcwd_set_heartbeat(WATCHDOG_HEARTBEAT);\n\t\tpr_info(\"heartbeat value must be 2 <= heartbeat <= 7200, using %d\\n\",\n\t\t\tWATCHDOG_HEARTBEAT);\n\t}\n\n\tif (pcwd_private.supports_temp) {\n\t\tret = misc_register(&temp_miscdev);\n\t\tif (ret) {\n\t\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t\t       TEMP_MINOR, ret);\n\t\t\tgoto error_misc_register_temp;\n\t\t}\n\t}\n\n\tret = misc_register(&pcwd_miscdev);\n\tif (ret) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, ret);\n\t\tgoto error_misc_register_watchdog;\n\t}\n\n\tpr_info(\"initialized. heartbeat=%d sec (nowayout=%d)\\n\",\n\t\theartbeat, nowayout);\n\n\treturn 0;\n\nerror_misc_register_watchdog:\n\tif (pcwd_private.supports_temp)\n\t\tmisc_deregister(&temp_miscdev);\nerror_misc_register_temp:\n\trelease_region(pcwd_private.io_addr,\n\t\t\t(pcwd_private.revision == PCWD_REVISION_A) ? 2 : 4);\nerror_request_region:\n\tpcwd_private.io_addr = 0x0000;\n\tcards_found--;\n\treturn ret;\n}\n\nstatic void pcwd_isa_remove(struct device *dev, unsigned int id)\n{\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"pcwd_isa_remove id=%d\\n\", id);\n\n\t \n\tif (!nowayout)\n\t\tpcwd_stop();\n\n\t \n\tmisc_deregister(&pcwd_miscdev);\n\tif (pcwd_private.supports_temp)\n\t\tmisc_deregister(&temp_miscdev);\n\trelease_region(pcwd_private.io_addr,\n\t\t\t(pcwd_private.revision == PCWD_REVISION_A) ? 2 : 4);\n\tpcwd_private.io_addr = 0x0000;\n\tcards_found--;\n}\n\nstatic void pcwd_isa_shutdown(struct device *dev, unsigned int id)\n{\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"pcwd_isa_shutdown id=%d\\n\", id);\n\n\tpcwd_stop();\n}\n\nstatic struct isa_driver pcwd_isa_driver = {\n\t.match\t\t= pcwd_isa_match,\n\t.probe\t\t= pcwd_isa_probe,\n\t.remove\t\t= pcwd_isa_remove,\n\t.shutdown\t= pcwd_isa_shutdown,\n\t.driver\t\t= {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= WATCHDOG_NAME,\n\t},\n};\n\nmodule_isa_driver(pcwd_isa_driver, PCWD_ISA_NR_CARDS);\n\nMODULE_AUTHOR(\"Ken Hollis <kenji@bitgate.com>, \"\n\t\t\"Wim Van Sebroeck <wim@iguana.be>\");\nMODULE_DESCRIPTION(\"Berkshire ISA-PC Watchdog driver\");\nMODULE_VERSION(WATCHDOG_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}