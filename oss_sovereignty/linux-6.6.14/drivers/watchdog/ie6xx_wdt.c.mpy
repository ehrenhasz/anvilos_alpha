{
  "module_name": "ie6xx_wdt.c",
  "hash_id": "30eef0c37f289397d6f2930395c59cfd4534e4e8093f31c183aa46b0b6b14bcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ie6xx_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n\n#define DRIVER_NAME \"ie6xx_wdt\"\n\n#define PV1\t0x00\n#define PV2\t0x04\n\n#define RR0\t0x0c\n#define RR1\t0x0d\n#define WDT_RELOAD\t0x01\n#define WDT_TOUT\t0x02\n\n#define WDTCR\t0x10\n#define WDT_PRE_SEL\t0x04\n#define WDT_RESET_SEL\t0x08\n#define WDT_RESET_EN\t0x10\n#define WDT_TOUT_EN\t0x20\n\n#define DCR\t0x14\n\n#define WDTLR\t0x18\n#define WDT_LOCK\t0x01\n#define WDT_ENABLE\t0x02\n#define WDT_TOUT_CNF\t0x03\n\n#define MIN_TIME\t1\n#define MAX_TIME\t(10 * 60)  \n#define DEFAULT_TIME\t60\n\nstatic unsigned int timeout = DEFAULT_TIME;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout,\n\t\t\"Default Watchdog timer setting (\"\n\t\t__MODULE_STRING(DEFAULT_TIME) \"s).\"\n\t\t\"The range is from 1 to 600\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic u8 resetmode = 0x10;\nmodule_param(resetmode, byte, 0);\nMODULE_PARM_DESC(resetmode,\n\t\"Resetmode bits: 0x08 warm reset (cold reset otherwise), \"\n\t\"0x10 reset enable, 0x20 disable toggle GPIO[4] (default=0x10)\");\n\nstatic struct {\n\tunsigned short sch_wdtba;\n\tspinlock_t unlock_sequence;\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs;\n#endif\n} ie6xx_wdt_data;\n\n \nstatic void ie6xx_wdt_unlock_registers(void)\n{\n\toutb(0x80, ie6xx_wdt_data.sch_wdtba + RR0);\n\toutb(0x86, ie6xx_wdt_data.sch_wdtba + RR0);\n}\n\nstatic int ie6xx_wdt_ping(struct watchdog_device *wdd)\n{\n\tspin_lock(&ie6xx_wdt_data.unlock_sequence);\n\tie6xx_wdt_unlock_registers();\n\toutb(WDT_RELOAD, ie6xx_wdt_data.sch_wdtba + RR1);\n\tspin_unlock(&ie6xx_wdt_data.unlock_sequence);\n\treturn 0;\n}\n\nstatic int ie6xx_wdt_set_timeout(struct watchdog_device *wdd, unsigned int t)\n{\n\tu32 preload;\n\tu64 clock;\n\tu8 wdtcr;\n\n\t \n\tclock = 33000000;\n\t \n\tpreload = (t * clock) >> 15;\n\t \n\tpreload -= 1;\n\n\tspin_lock(&ie6xx_wdt_data.unlock_sequence);\n\n\t \n\twdtcr = resetmode & 0x38;\n\toutb(wdtcr, ie6xx_wdt_data.sch_wdtba + WDTCR);\n\n\tie6xx_wdt_unlock_registers();\n\toutl(0, ie6xx_wdt_data.sch_wdtba + PV1);\n\n\tie6xx_wdt_unlock_registers();\n\toutl(preload, ie6xx_wdt_data.sch_wdtba + PV2);\n\n\tie6xx_wdt_unlock_registers();\n\toutb(WDT_RELOAD | WDT_TOUT, ie6xx_wdt_data.sch_wdtba + RR1);\n\n\tspin_unlock(&ie6xx_wdt_data.unlock_sequence);\n\n\twdd->timeout = t;\n\treturn 0;\n}\n\nstatic int ie6xx_wdt_start(struct watchdog_device *wdd)\n{\n\tie6xx_wdt_set_timeout(wdd, wdd->timeout);\n\n\t \n\tspin_lock(&ie6xx_wdt_data.unlock_sequence);\n\toutb(WDT_ENABLE, ie6xx_wdt_data.sch_wdtba + WDTLR);\n\tspin_unlock(&ie6xx_wdt_data.unlock_sequence);\n\n\treturn 0;\n}\n\nstatic int ie6xx_wdt_stop(struct watchdog_device *wdd)\n{\n\tif (inb(ie6xx_wdt_data.sch_wdtba + WDTLR) & WDT_LOCK)\n\t\treturn -1;\n\n\t \n\tspin_lock(&ie6xx_wdt_data.unlock_sequence);\n\toutb(0, ie6xx_wdt_data.sch_wdtba + WDTLR);\n\tspin_unlock(&ie6xx_wdt_data.unlock_sequence);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info ie6xx_wdt_info = {\n\t.identity =\t\"Intel Atom E6xx Watchdog\",\n\t.options =\tWDIOF_SETTIMEOUT |\n\t\t\tWDIOF_MAGICCLOSE |\n\t\t\tWDIOF_KEEPALIVEPING,\n};\n\nstatic const struct watchdog_ops ie6xx_wdt_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.start =\tie6xx_wdt_start,\n\t.stop =\t\tie6xx_wdt_stop,\n\t.ping =\t\tie6xx_wdt_ping,\n\t.set_timeout =\tie6xx_wdt_set_timeout,\n};\n\nstatic struct watchdog_device ie6xx_wdt_dev = {\n\t.info =\t\t&ie6xx_wdt_info,\n\t.ops =\t\t&ie6xx_wdt_ops,\n\t.min_timeout =\tMIN_TIME,\n\t.max_timeout =\tMAX_TIME,\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int ie6xx_wdt_show(struct seq_file *s, void *unused)\n{\n\tseq_printf(s, \"PV1   = 0x%08x\\n\",\n\t\tinl(ie6xx_wdt_data.sch_wdtba + PV1));\n\tseq_printf(s, \"PV2   = 0x%08x\\n\",\n\t\tinl(ie6xx_wdt_data.sch_wdtba + PV2));\n\tseq_printf(s, \"RR    = 0x%08x\\n\",\n\t\tinw(ie6xx_wdt_data.sch_wdtba + RR0));\n\tseq_printf(s, \"WDTCR = 0x%08x\\n\",\n\t\tinw(ie6xx_wdt_data.sch_wdtba + WDTCR));\n\tseq_printf(s, \"DCR   = 0x%08x\\n\",\n\t\tinl(ie6xx_wdt_data.sch_wdtba + DCR));\n\tseq_printf(s, \"WDTLR = 0x%08x\\n\",\n\t\tinw(ie6xx_wdt_data.sch_wdtba + WDTLR));\n\n\tseq_printf(s, \"\\n\");\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(ie6xx_wdt);\n\nstatic void ie6xx_wdt_debugfs_init(void)\n{\n\t \n\tie6xx_wdt_data.debugfs = debugfs_create_file(\"ie6xx_wdt\",\n\t\tS_IFREG | S_IRUGO, NULL, NULL, &ie6xx_wdt_fops);\n}\n\nstatic void ie6xx_wdt_debugfs_exit(void)\n{\n\tdebugfs_remove(ie6xx_wdt_data.debugfs);\n}\n\n#else\nstatic void ie6xx_wdt_debugfs_init(void)\n{\n}\n\nstatic void ie6xx_wdt_debugfs_exit(void)\n{\n}\n#endif\n\nstatic int ie6xx_wdt_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tu8 wdtlr;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tif (!request_region(res->start, resource_size(res), pdev->name)) {\n\t\tdev_err(&pdev->dev, \"Watchdog region 0x%llx already in use!\\n\",\n\t\t\t(u64)res->start);\n\t\treturn -EBUSY;\n\t}\n\n\tie6xx_wdt_data.sch_wdtba = res->start;\n\tdev_dbg(&pdev->dev, \"WDT = 0x%X\\n\", ie6xx_wdt_data.sch_wdtba);\n\n\tie6xx_wdt_dev.timeout = timeout;\n\twatchdog_set_nowayout(&ie6xx_wdt_dev, nowayout);\n\tie6xx_wdt_dev.parent = &pdev->dev;\n\n\tspin_lock_init(&ie6xx_wdt_data.unlock_sequence);\n\n\twdtlr = inb(ie6xx_wdt_data.sch_wdtba + WDTLR);\n\tif (wdtlr & WDT_LOCK)\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"Watchdog Timer is Locked (Reg=0x%x)\\n\", wdtlr);\n\n\tie6xx_wdt_debugfs_init();\n\n\tret = watchdog_register_device(&ie6xx_wdt_dev);\n\tif (ret)\n\t\tgoto misc_register_error;\n\n\treturn 0;\n\nmisc_register_error:\n\tie6xx_wdt_debugfs_exit();\n\trelease_region(res->start, resource_size(res));\n\tie6xx_wdt_data.sch_wdtba = 0;\n\treturn ret;\n}\n\nstatic void ie6xx_wdt_remove(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tie6xx_wdt_stop(NULL);\n\twatchdog_unregister_device(&ie6xx_wdt_dev);\n\tie6xx_wdt_debugfs_exit();\n\trelease_region(res->start, resource_size(res));\n\tie6xx_wdt_data.sch_wdtba = 0;\n}\n\nstatic struct platform_driver ie6xx_wdt_driver = {\n\t.probe\t\t= ie6xx_wdt_probe,\n\t.remove_new\t= ie6xx_wdt_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t},\n};\n\nstatic int __init ie6xx_wdt_init(void)\n{\n\t \n\t \n\tif ((timeout < MIN_TIME) ||\n\t    (timeout > MAX_TIME)) {\n\t\tpr_err(\"Watchdog timer: value of timeout %d (dec) \"\n\t\t  \"is out of range from %d to %d (dec)\\n\",\n\t\t  timeout, MIN_TIME, MAX_TIME);\n\t\treturn -EINVAL;\n\t}\n\n\treturn platform_driver_register(&ie6xx_wdt_driver);\n}\n\nstatic void __exit ie6xx_wdt_exit(void)\n{\n\tplatform_driver_unregister(&ie6xx_wdt_driver);\n}\n\nlate_initcall(ie6xx_wdt_init);\nmodule_exit(ie6xx_wdt_exit);\n\nMODULE_AUTHOR(\"Alexander Stein <alexander.stein@systec-electronic.com>\");\nMODULE_DESCRIPTION(\"Intel Atom E6xx Watchdog Device Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}