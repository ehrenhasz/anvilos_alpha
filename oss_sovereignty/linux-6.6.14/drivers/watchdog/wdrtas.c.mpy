{
  "module_name": "wdrtas.c",
  "hash_id": "8e638a24e9a12c5f1dc9de171efd9f483964650aa698e2c9b7ffaef8a26e491d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/wdrtas.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/uaccess.h>\n\n#include <asm/rtas.h>\n\n#define WDRTAS_MAGIC_CHAR\t\t42\n#define WDRTAS_SUPPORTED_MASK\t\t(WDIOF_SETTIMEOUT | \\\n\t\t\t\t\t WDIOF_MAGICCLOSE)\n\nMODULE_AUTHOR(\"Utz Bacher <utz.bacher@de.ibm.com>\");\nMODULE_DESCRIPTION(\"RTAS watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool wdrtas_nowayout = WATCHDOG_NOWAYOUT;\nstatic atomic_t wdrtas_miscdev_open = ATOMIC_INIT(0);\nstatic char wdrtas_expect_close;\n\nstatic int wdrtas_interval;\n\n#define WDRTAS_THERMAL_SENSOR\t\t3\nstatic int wdrtas_token_get_sensor_state;\n#define WDRTAS_SURVEILLANCE_IND\t\t9000\nstatic int wdrtas_token_set_indicator;\n#define WDRTAS_SP_SPI\t\t\t28\nstatic int wdrtas_token_get_sp;\nstatic int wdrtas_token_event_scan;\n\n#define WDRTAS_DEFAULT_INTERVAL\t\t300\n\n#define WDRTAS_LOGBUFFER_LEN\t\t128\nstatic char wdrtas_logbuffer[WDRTAS_LOGBUFFER_LEN];\n\n\n \n\n \n\nstatic int wdrtas_set_interval(int interval)\n{\n\tlong result;\n\tstatic int print_msg = 10;\n\n\t \n\tinterval = (interval + 59) / 60;\n\n\tresult = rtas_call(wdrtas_token_set_indicator, 3, 1, NULL,\n\t\t\t   WDRTAS_SURVEILLANCE_IND, 0, interval);\n\tif (result < 0 && print_msg) {\n\t\tpr_err(\"setting the watchdog to %i timeout failed: %li\\n\",\n\t\t       interval, result);\n\t\tprint_msg--;\n\t}\n\n\treturn result;\n}\n\n#define WDRTAS_SP_SPI_LEN 4\n\n \nstatic int wdrtas_get_interval(int fallback_value)\n{\n\tlong result;\n\tchar value[WDRTAS_SP_SPI_LEN];\n\n\tspin_lock(&rtas_data_buf_lock);\n\tmemset(rtas_data_buf, 0, WDRTAS_SP_SPI_LEN);\n\tresult = rtas_call(wdrtas_token_get_sp, 3, 1, NULL,\n\t\t\t   WDRTAS_SP_SPI, __pa(rtas_data_buf),\n\t\t\t   WDRTAS_SP_SPI_LEN);\n\n\tmemcpy(value, rtas_data_buf, WDRTAS_SP_SPI_LEN);\n\tspin_unlock(&rtas_data_buf_lock);\n\n\tif (value[0] != 0 || value[1] != 2 || value[3] != 0 || result < 0) {\n\t\tpr_warn(\"could not get sp_spi watchdog timeout (%li). Continuing\\n\",\n\t\t\tresult);\n\t\treturn fallback_value;\n\t}\n\n\t \n\treturn ((int)value[2]) * 60;\n}\n\n \nstatic void wdrtas_timer_start(void)\n{\n\twdrtas_set_interval(wdrtas_interval);\n}\n\n \nstatic void wdrtas_timer_stop(void)\n{\n\twdrtas_set_interval(0);\n}\n\n \nstatic void wdrtas_timer_keepalive(void)\n{\n\tlong result;\n\n\tdo {\n\t\tresult = rtas_call(wdrtas_token_event_scan, 4, 1, NULL,\n\t\t\t\t   RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t   (void *)__pa(wdrtas_logbuffer),\n\t\t\t\t   WDRTAS_LOGBUFFER_LEN);\n\t\tif (result < 0)\n\t\t\tpr_err(\"event-scan failed: %li\\n\", result);\n\t\tif (result == 0)\n\t\t\tprint_hex_dump(KERN_INFO, \"dumping event, data: \",\n\t\t\t\tDUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\twdrtas_logbuffer, WDRTAS_LOGBUFFER_LEN, false);\n\t} while (result == 0);\n}\n\n \nstatic int wdrtas_get_temperature(void)\n{\n\tint result;\n\tint temperature = 0;\n\n\tresult = rtas_get_sensor(WDRTAS_THERMAL_SENSOR, 0, &temperature);\n\n\tif (result < 0)\n\t\tpr_warn(\"reading the thermal sensor failed: %i\\n\", result);\n\telse\n\t\ttemperature = ((temperature * 9) / 5) + 32;  \n\n\treturn temperature;\n}\n\n \nstatic int wdrtas_get_status(void)\n{\n\treturn 0;  \n}\n\n \nstatic int wdrtas_get_boot_status(void)\n{\n\treturn 0;  \n}\n\n \n\n \nstatic ssize_t wdrtas_write(struct file *file, const char __user *buf,\n\t     size_t len, loff_t *ppos)\n{\n\tint i;\n\tchar c;\n\n\tif (!len)\n\t\tgoto out;\n\n\tif (!wdrtas_nowayout) {\n\t\twdrtas_expect_close = 0;\n\t\t \n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (get_user(c, buf + i))\n\t\t\t\treturn -EFAULT;\n\t\t\t \n\t\t\tif (c == 'V')\n\t\t\t\twdrtas_expect_close = WDRTAS_MAGIC_CHAR;\n\t\t}\n\t}\n\n\twdrtas_timer_keepalive();\n\nout:\n\treturn len;\n}\n\n \n\nstatic long wdrtas_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint __user *argp = (void __user *)arg;\n\tint i;\n\tstatic const struct watchdog_info wdinfo = {\n\t\t.options = WDRTAS_SUPPORTED_MASK,\n\t\t.firmware_version = 0,\n\t\t.identity = \"wdrtas\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &wdinfo, sizeof(wdinfo)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase WDIOC_GETSTATUS:\n\t\ti = wdrtas_get_status();\n\t\treturn put_user(i, argp);\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\ti = wdrtas_get_boot_status();\n\t\treturn put_user(i, argp);\n\n\tcase WDIOC_GETTEMP:\n\t\tif (wdrtas_token_get_sensor_state == RTAS_UNKNOWN_SERVICE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\ti = wdrtas_get_temperature();\n\t\treturn put_user(i, argp);\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(i, argp))\n\t\t\treturn -EFAULT;\n\t\tif (i & WDIOS_DISABLECARD)\n\t\t\twdrtas_timer_stop();\n\t\tif (i & WDIOS_ENABLECARD) {\n\t\t\twdrtas_timer_keepalive();\n\t\t\twdrtas_timer_start();\n\t\t}\n\t\t \n\t\treturn 0;\n\n\tcase WDIOC_KEEPALIVE:\n\t\twdrtas_timer_keepalive();\n\t\treturn 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(i, argp))\n\t\t\treturn -EFAULT;\n\n\t\tif (wdrtas_set_interval(i))\n\t\t\treturn -EINVAL;\n\n\t\twdrtas_timer_keepalive();\n\n\t\tif (wdrtas_token_get_sp == RTAS_UNKNOWN_SERVICE)\n\t\t\twdrtas_interval = i;\n\t\telse\n\t\t\twdrtas_interval = wdrtas_get_interval(i);\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(wdrtas_interval, argp);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \nstatic int wdrtas_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (atomic_inc_return(&wdrtas_miscdev_open) > 1) {\n\t\tatomic_dec(&wdrtas_miscdev_open);\n\t\treturn -EBUSY;\n\t}\n\n\twdrtas_timer_start();\n\twdrtas_timer_keepalive();\n\n\treturn stream_open(inode, file);\n}\n\n \nstatic int wdrtas_close(struct inode *inode, struct file *file)\n{\n\t \n\tif (wdrtas_expect_close == WDRTAS_MAGIC_CHAR)\n\t\twdrtas_timer_stop();\n\telse {\n\t\tpr_warn(\"got unexpected close. Watchdog not stopped.\\n\");\n\t\twdrtas_timer_keepalive();\n\t}\n\n\twdrtas_expect_close = 0;\n\tatomic_dec(&wdrtas_miscdev_open);\n\treturn 0;\n}\n\n \nstatic ssize_t wdrtas_temp_read(struct file *file, char __user *buf,\n\t\t size_t count, loff_t *ppos)\n{\n\tint temperature = 0;\n\n\ttemperature = wdrtas_get_temperature();\n\tif (temperature < 0)\n\t\treturn temperature;\n\n\tif (copy_to_user(buf, &temperature, 1))\n\t\treturn -EFAULT;\n\n\treturn 1;\n}\n\n \nstatic int wdrtas_temp_open(struct inode *inode, struct file *file)\n{\n\treturn stream_open(inode, file);\n}\n\n \nstatic int wdrtas_temp_close(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\n \nstatic int wdrtas_reboot(struct notifier_block *this,\n\t\t\t\t\tunsigned long code, void *ptr)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\twdrtas_timer_stop();\n\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic const struct file_operations wdrtas_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= wdrtas_write,\n\t.unlocked_ioctl\t= wdrtas_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= wdrtas_open,\n\t.release\t= wdrtas_close,\n};\n\nstatic struct miscdevice wdrtas_miscdev = {\n\t.minor =\tWATCHDOG_MINOR,\n\t.name =\t\t\"watchdog\",\n\t.fops =\t\t&wdrtas_fops,\n};\n\nstatic const struct file_operations wdrtas_temp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= wdrtas_temp_read,\n\t.open\t\t= wdrtas_temp_open,\n\t.release\t= wdrtas_temp_close,\n};\n\nstatic struct miscdevice wdrtas_tempdev = {\n\t.minor =\tTEMP_MINOR,\n\t.name =\t\t\"temperature\",\n\t.fops =\t\t&wdrtas_temp_fops,\n};\n\nstatic struct notifier_block wdrtas_notifier = {\n\t.notifier_call =\twdrtas_reboot,\n};\n\n \nstatic int wdrtas_get_tokens(void)\n{\n\twdrtas_token_get_sensor_state = rtas_token(\"get-sensor-state\");\n\tif (wdrtas_token_get_sensor_state == RTAS_UNKNOWN_SERVICE) {\n\t\tpr_warn(\"couldn't get token for get-sensor-state. Trying to continue without temperature support.\\n\");\n\t}\n\n\twdrtas_token_get_sp = rtas_token(\"ibm,get-system-parameter\");\n\tif (wdrtas_token_get_sp == RTAS_UNKNOWN_SERVICE) {\n\t\tpr_warn(\"couldn't get token for ibm,get-system-parameter. Trying to continue with a default timeout value of %i seconds.\\n\",\n\t\t\tWDRTAS_DEFAULT_INTERVAL);\n\t}\n\n\twdrtas_token_set_indicator = rtas_token(\"set-indicator\");\n\tif (wdrtas_token_set_indicator == RTAS_UNKNOWN_SERVICE) {\n\t\tpr_err(\"couldn't get token for set-indicator. Terminating watchdog code.\\n\");\n\t\treturn -EIO;\n\t}\n\n\twdrtas_token_event_scan = rtas_token(\"event-scan\");\n\tif (wdrtas_token_event_scan == RTAS_UNKNOWN_SERVICE) {\n\t\tpr_err(\"couldn't get token for event-scan. Terminating watchdog code.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void wdrtas_unregister_devs(void)\n{\n\tmisc_deregister(&wdrtas_miscdev);\n\tif (wdrtas_token_get_sensor_state != RTAS_UNKNOWN_SERVICE)\n\t\tmisc_deregister(&wdrtas_tempdev);\n}\n\n \nstatic int wdrtas_register_devs(void)\n{\n\tint result;\n\n\tresult = misc_register(&wdrtas_miscdev);\n\tif (result) {\n\t\tpr_err(\"couldn't register watchdog misc device. Terminating watchdog code.\\n\");\n\t\treturn result;\n\t}\n\n\tif (wdrtas_token_get_sensor_state != RTAS_UNKNOWN_SERVICE) {\n\t\tresult = misc_register(&wdrtas_tempdev);\n\t\tif (result) {\n\t\t\tpr_warn(\"couldn't register watchdog temperature misc device. Continuing without temperature support.\\n\");\n\t\t\twdrtas_token_get_sensor_state = RTAS_UNKNOWN_SERVICE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __init wdrtas_init(void)\n{\n\tif (wdrtas_get_tokens())\n\t\treturn -ENODEV;\n\n\tif (wdrtas_register_devs())\n\t\treturn -ENODEV;\n\n\tif (register_reboot_notifier(&wdrtas_notifier)) {\n\t\tpr_err(\"could not register reboot notifier. Terminating watchdog code.\\n\");\n\t\twdrtas_unregister_devs();\n\t\treturn -ENODEV;\n\t}\n\n\tif (wdrtas_token_get_sp == RTAS_UNKNOWN_SERVICE)\n\t\twdrtas_interval = WDRTAS_DEFAULT_INTERVAL;\n\telse\n\t\twdrtas_interval = wdrtas_get_interval(WDRTAS_DEFAULT_INTERVAL);\n\n\treturn 0;\n}\n\n \nstatic void __exit wdrtas_exit(void)\n{\n\tif (!wdrtas_nowayout)\n\t\twdrtas_timer_stop();\n\n\twdrtas_unregister_devs();\n\n\tunregister_reboot_notifier(&wdrtas_notifier);\n}\n\nmodule_init(wdrtas_init);\nmodule_exit(wdrtas_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}