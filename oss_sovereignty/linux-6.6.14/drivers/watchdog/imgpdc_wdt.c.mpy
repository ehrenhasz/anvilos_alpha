{
  "module_name": "imgpdc_wdt.c",
  "hash_id": "213c4c5994b22aca4b35e4960d00c939f4d28cc524c184631129c6e2d69387b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/imgpdc_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/watchdog.h>\n\n \n#define PDC_WDT_SOFT_RESET\t\t0x00\n#define PDC_WDT_CONFIG\t\t\t0x04\n  #define PDC_WDT_CONFIG_ENABLE\t\tBIT(31)\n  #define PDC_WDT_CONFIG_DELAY_MASK\t0x1f\n\n#define PDC_WDT_TICKLE1\t\t\t0x08\n#define PDC_WDT_TICKLE1_MAGIC\t\t0xabcd1234\n#define PDC_WDT_TICKLE2\t\t\t0x0c\n#define PDC_WDT_TICKLE2_MAGIC\t\t0x4321dcba\n\n#define PDC_WDT_TICKLE_STATUS_MASK\t0x7\n#define PDC_WDT_TICKLE_STATUS_SHIFT\t0\n#define PDC_WDT_TICKLE_STATUS_HRESET\t0x0   \n#define PDC_WDT_TICKLE_STATUS_TIMEOUT\t0x1   \n#define PDC_WDT_TICKLE_STATUS_TICKLE\t0x2   \n#define PDC_WDT_TICKLE_STATUS_SRESET\t0x3   \n#define PDC_WDT_TICKLE_STATUS_USER\t0x4   \n\n \n#define PDC_WDT_MIN_TIMEOUT\t\t1\n#define PDC_WDT_DEF_TIMEOUT\t\t64\n\nstatic int heartbeat;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeats in seconds \"\n\t\"(default=\" __MODULE_STRING(PDC_WDT_DEF_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct pdc_wdt_dev {\n\tstruct watchdog_device wdt_dev;\n\tstruct clk *wdt_clk;\n\tstruct clk *sys_clk;\n\tvoid __iomem *base;\n};\n\nstatic int pdc_wdt_keepalive(struct watchdog_device *wdt_dev)\n{\n\tstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\n\n\twritel(PDC_WDT_TICKLE1_MAGIC, wdt->base + PDC_WDT_TICKLE1);\n\twritel(PDC_WDT_TICKLE2_MAGIC, wdt->base + PDC_WDT_TICKLE2);\n\n\treturn 0;\n}\n\nstatic int pdc_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tunsigned int val;\n\tstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\n\n\tval = readl(wdt->base + PDC_WDT_CONFIG);\n\tval &= ~PDC_WDT_CONFIG_ENABLE;\n\twritel(val, wdt->base + PDC_WDT_CONFIG);\n\n\t \n\tpdc_wdt_keepalive(wdt_dev);\n\n\treturn 0;\n}\n\nstatic void __pdc_wdt_set_timeout(struct pdc_wdt_dev *wdt)\n{\n\tunsigned long clk_rate = clk_get_rate(wdt->wdt_clk);\n\tunsigned int val;\n\n\tval = readl(wdt->base + PDC_WDT_CONFIG) & ~PDC_WDT_CONFIG_DELAY_MASK;\n\tval |= order_base_2(wdt->wdt_dev.timeout * clk_rate) - 1;\n\twritel(val, wdt->base + PDC_WDT_CONFIG);\n}\n\nstatic int pdc_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t       unsigned int new_timeout)\n{\n\tstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\n\n\twdt->wdt_dev.timeout = new_timeout;\n\n\t__pdc_wdt_set_timeout(wdt);\n\n\treturn 0;\n}\n\n \nstatic int pdc_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tunsigned int val;\n\tstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\n\n\t__pdc_wdt_set_timeout(wdt);\n\n\tval = readl(wdt->base + PDC_WDT_CONFIG);\n\tval |= PDC_WDT_CONFIG_ENABLE;\n\twritel(val, wdt->base + PDC_WDT_CONFIG);\n\n\treturn 0;\n}\n\nstatic int pdc_wdt_restart(struct watchdog_device *wdt_dev,\n\t\t\t   unsigned long action, void *data)\n{\n\tstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\n\n\t \n\twritel(0x1, wdt->base + PDC_WDT_SOFT_RESET);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info pdc_wdt_info = {\n\t.identity\t= \"IMG PDC Watchdog\",\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops pdc_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= pdc_wdt_start,\n\t.stop\t\t= pdc_wdt_stop,\n\t.ping\t\t= pdc_wdt_keepalive,\n\t.set_timeout\t= pdc_wdt_set_timeout,\n\t.restart        = pdc_wdt_restart,\n};\n\nstatic int pdc_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tu64 div;\n\tint val;\n\tunsigned long clk_rate;\n\tstruct pdc_wdt_dev *pdc_wdt;\n\n\tpdc_wdt = devm_kzalloc(dev, sizeof(*pdc_wdt), GFP_KERNEL);\n\tif (!pdc_wdt)\n\t\treturn -ENOMEM;\n\n\tpdc_wdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pdc_wdt->base))\n\t\treturn PTR_ERR(pdc_wdt->base);\n\n\tpdc_wdt->sys_clk = devm_clk_get_enabled(dev, \"sys\");\n\tif (IS_ERR(pdc_wdt->sys_clk)) {\n\t\tdev_err(dev, \"failed to get the sys clock\\n\");\n\t\treturn PTR_ERR(pdc_wdt->sys_clk);\n\t}\n\n\tpdc_wdt->wdt_clk = devm_clk_get_enabled(dev, \"wdt\");\n\tif (IS_ERR(pdc_wdt->wdt_clk)) {\n\t\tdev_err(dev, \"failed to get the wdt clock\\n\");\n\t\treturn PTR_ERR(pdc_wdt->wdt_clk);\n\t}\n\n\t \n\tclk_rate = clk_get_rate(pdc_wdt->wdt_clk);\n\tif (clk_rate == 0) {\n\t\tdev_err(dev, \"failed to get clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (order_base_2(clk_rate) > PDC_WDT_CONFIG_DELAY_MASK + 1) {\n\t\tdev_err(dev, \"invalid clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (order_base_2(clk_rate) == 0)\n\t\tpdc_wdt->wdt_dev.min_timeout = PDC_WDT_MIN_TIMEOUT + 1;\n\telse\n\t\tpdc_wdt->wdt_dev.min_timeout = PDC_WDT_MIN_TIMEOUT;\n\n\tpdc_wdt->wdt_dev.info = &pdc_wdt_info;\n\tpdc_wdt->wdt_dev.ops = &pdc_wdt_ops;\n\n\tdiv = 1ULL << (PDC_WDT_CONFIG_DELAY_MASK + 1);\n\tdo_div(div, clk_rate);\n\tpdc_wdt->wdt_dev.max_timeout = div;\n\tpdc_wdt->wdt_dev.timeout = PDC_WDT_DEF_TIMEOUT;\n\tpdc_wdt->wdt_dev.parent = dev;\n\twatchdog_set_drvdata(&pdc_wdt->wdt_dev, pdc_wdt);\n\n\twatchdog_init_timeout(&pdc_wdt->wdt_dev, heartbeat, dev);\n\n\tpdc_wdt_stop(&pdc_wdt->wdt_dev);\n\n\t \n\tval = readl(pdc_wdt->base + PDC_WDT_TICKLE1);\n\tval = (val & PDC_WDT_TICKLE_STATUS_MASK) >> PDC_WDT_TICKLE_STATUS_SHIFT;\n\tswitch (val) {\n\tcase PDC_WDT_TICKLE_STATUS_TICKLE:\n\tcase PDC_WDT_TICKLE_STATUS_TIMEOUT:\n\t\tpdc_wdt->wdt_dev.bootstatus |= WDIOF_CARDRESET;\n\t\tdev_info(dev, \"watchdog module last reset due to timeout\\n\");\n\t\tbreak;\n\tcase PDC_WDT_TICKLE_STATUS_HRESET:\n\t\tdev_info(dev,\n\t\t\t \"watchdog module last reset due to hard reset\\n\");\n\t\tbreak;\n\tcase PDC_WDT_TICKLE_STATUS_SRESET:\n\t\tdev_info(dev,\n\t\t\t \"watchdog module last reset due to soft reset\\n\");\n\t\tbreak;\n\tcase PDC_WDT_TICKLE_STATUS_USER:\n\t\tdev_info(dev,\n\t\t\t \"watchdog module last reset due to user reset\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"contains an illegal status code (%08x)\\n\", val);\n\t\tbreak;\n\t}\n\n\twatchdog_set_nowayout(&pdc_wdt->wdt_dev, nowayout);\n\twatchdog_set_restart_priority(&pdc_wdt->wdt_dev, 128);\n\n\tplatform_set_drvdata(pdev, pdc_wdt);\n\n\twatchdog_stop_on_reboot(&pdc_wdt->wdt_dev);\n\twatchdog_stop_on_unregister(&pdc_wdt->wdt_dev);\n\treturn devm_watchdog_register_device(dev, &pdc_wdt->wdt_dev);\n}\n\nstatic const struct of_device_id pdc_wdt_match[] = {\n\t{ .compatible = \"img,pdc-wdt\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pdc_wdt_match);\n\nstatic struct platform_driver pdc_wdt_driver = {\n\t.driver = {\n\t\t.name = \"imgpdc-wdt\",\n\t\t.of_match_table\t= pdc_wdt_match,\n\t},\n\t.probe = pdc_wdt_probe,\n};\nmodule_platform_driver(pdc_wdt_driver);\n\nMODULE_AUTHOR(\"Jude Abraham <Jude.Abraham@imgtec.com>\");\nMODULE_AUTHOR(\"Naidu Tellapati <Naidu.Tellapati@imgtec.com>\");\nMODULE_DESCRIPTION(\"Imagination Technologies PDC Watchdog Timer Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}