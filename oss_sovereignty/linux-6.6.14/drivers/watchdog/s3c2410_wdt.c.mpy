{
  "module_name": "s3c2410_wdt.c",
  "hash_id": "2b0def4be85575f6a3769366371c4e6d73543b034c8a84155c651f1c8653efcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/s3c2410_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/cpufreq.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n\n#define S3C2410_WTCON\t\t0x00\n#define S3C2410_WTDAT\t\t0x04\n#define S3C2410_WTCNT\t\t0x08\n#define S3C2410_WTCLRINT\t0x0c\n\n#define S3C2410_WTCNT_MAXCNT\t0xffff\n\n#define S3C2410_WTCON_RSTEN\t(1 << 0)\n#define S3C2410_WTCON_INTEN\t(1 << 2)\n#define S3C2410_WTCON_ENABLE\t(1 << 5)\n\n#define S3C2410_WTCON_DIV16\t(0 << 3)\n#define S3C2410_WTCON_DIV32\t(1 << 3)\n#define S3C2410_WTCON_DIV64\t(2 << 3)\n#define S3C2410_WTCON_DIV128\t(3 << 3)\n\n#define S3C2410_WTCON_MAXDIV\t0x80\n\n#define S3C2410_WTCON_PRESCALE(x)\t((x) << 8)\n#define S3C2410_WTCON_PRESCALE_MASK\t(0xff << 8)\n#define S3C2410_WTCON_PRESCALE_MAX\t0xff\n\n#define S3C2410_WATCHDOG_ATBOOT\t\t(0)\n#define S3C2410_WATCHDOG_DEFAULT_TIME\t(15)\n\n#define EXYNOS5_RST_STAT_REG_OFFSET\t\t0x0404\n#define EXYNOS5_WDT_DISABLE_REG_OFFSET\t\t0x0408\n#define EXYNOS5_WDT_MASK_RESET_REG_OFFSET\t0x040c\n#define EXYNOS850_CLUSTER0_NONCPU_OUT\t\t0x1220\n#define EXYNOS850_CLUSTER0_NONCPU_INT_EN\t0x1244\n#define EXYNOS850_CLUSTER1_NONCPU_OUT\t\t0x1620\n#define EXYNOS850_CLUSTER1_NONCPU_INT_EN\t0x1644\n#define EXYNOSAUTOV9_CLUSTER1_NONCPU_OUT\t0x1520\n#define EXYNOSAUTOV9_CLUSTER1_NONCPU_INT_EN\t0x1544\n\n#define EXYNOS850_CLUSTER0_WDTRESET_BIT\t\t24\n#define EXYNOS850_CLUSTER1_WDTRESET_BIT\t\t23\n#define EXYNOSAUTOV9_CLUSTER0_WDTRESET_BIT\t25\n#define EXYNOSAUTOV9_CLUSTER1_WDTRESET_BIT\t24\n\n \n#define QUIRK_HAS_WTCLRINT_REG\t\t\t(1 << 0)\n#define QUIRK_HAS_PMU_MASK_RESET\t\t(1 << 1)\n#define QUIRK_HAS_PMU_RST_STAT\t\t\t(1 << 2)\n#define QUIRK_HAS_PMU_AUTO_DISABLE\t\t(1 << 3)\n#define QUIRK_HAS_PMU_CNT_EN\t\t\t(1 << 4)\n\n \n#define QUIRKS_HAVE_PMUREG \\\n\t(QUIRK_HAS_PMU_MASK_RESET | QUIRK_HAS_PMU_RST_STAT | \\\n\t QUIRK_HAS_PMU_AUTO_DISABLE | QUIRK_HAS_PMU_CNT_EN)\n\nstatic bool nowayout\t= WATCHDOG_NOWAYOUT;\nstatic int tmr_margin;\nstatic int tmr_atboot\t= S3C2410_WATCHDOG_ATBOOT;\nstatic int soft_noboot;\n\nmodule_param(tmr_margin,  int, 0);\nmodule_param(tmr_atboot,  int, 0);\nmodule_param(nowayout,   bool, 0);\nmodule_param(soft_noboot, int, 0);\n\nMODULE_PARM_DESC(tmr_margin, \"Watchdog tmr_margin in seconds. (default=\"\n\t\t__MODULE_STRING(S3C2410_WATCHDOG_DEFAULT_TIME) \")\");\nMODULE_PARM_DESC(tmr_atboot,\n\t\t\"Watchdog is started at boot time if set to 1, default=\"\n\t\t\t__MODULE_STRING(S3C2410_WATCHDOG_ATBOOT));\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\nMODULE_PARM_DESC(soft_noboot, \"Watchdog action, set to 1 to ignore reboots, 0 to reboot (default 0)\");\n\n \n\nstruct s3c2410_wdt_variant {\n\tint disable_reg;\n\tint mask_reset_reg;\n\tbool mask_reset_inv;\n\tint mask_bit;\n\tint rst_stat_reg;\n\tint rst_stat_bit;\n\tint cnt_en_reg;\n\tint cnt_en_bit;\n\tu32 quirks;\n};\n\nstruct s3c2410_wdt {\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*bus_clk;  \n\tstruct clk\t\t*src_clk;  \n\tvoid __iomem\t\t*reg_base;\n\tunsigned int\t\tcount;\n\tspinlock_t\t\tlock;\n\tunsigned long\t\twtcon_save;\n\tunsigned long\t\twtdat_save;\n\tstruct watchdog_device\twdt_device;\n\tstruct notifier_block\tfreq_transition;\n\tconst struct s3c2410_wdt_variant *drv_data;\n\tstruct regmap *pmureg;\n};\n\nstatic const struct s3c2410_wdt_variant drv_data_s3c2410 = {\n\t.quirks = 0\n};\n\n#ifdef CONFIG_OF\nstatic const struct s3c2410_wdt_variant drv_data_s3c6410 = {\n\t.quirks = QUIRK_HAS_WTCLRINT_REG,\n};\n\nstatic const struct s3c2410_wdt_variant drv_data_exynos5250  = {\n\t.disable_reg = EXYNOS5_WDT_DISABLE_REG_OFFSET,\n\t.mask_reset_reg = EXYNOS5_WDT_MASK_RESET_REG_OFFSET,\n\t.mask_bit = 20,\n\t.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,\n\t.rst_stat_bit = 20,\n\t.quirks = QUIRK_HAS_WTCLRINT_REG | QUIRK_HAS_PMU_MASK_RESET | \\\n\t\t  QUIRK_HAS_PMU_RST_STAT | QUIRK_HAS_PMU_AUTO_DISABLE,\n};\n\nstatic const struct s3c2410_wdt_variant drv_data_exynos5420 = {\n\t.disable_reg = EXYNOS5_WDT_DISABLE_REG_OFFSET,\n\t.mask_reset_reg = EXYNOS5_WDT_MASK_RESET_REG_OFFSET,\n\t.mask_bit = 0,\n\t.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,\n\t.rst_stat_bit = 9,\n\t.quirks = QUIRK_HAS_WTCLRINT_REG | QUIRK_HAS_PMU_MASK_RESET | \\\n\t\t  QUIRK_HAS_PMU_RST_STAT | QUIRK_HAS_PMU_AUTO_DISABLE,\n};\n\nstatic const struct s3c2410_wdt_variant drv_data_exynos7 = {\n\t.disable_reg = EXYNOS5_WDT_DISABLE_REG_OFFSET,\n\t.mask_reset_reg = EXYNOS5_WDT_MASK_RESET_REG_OFFSET,\n\t.mask_bit = 23,\n\t.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,\n\t.rst_stat_bit = 23,\t \n\t.quirks = QUIRK_HAS_WTCLRINT_REG | QUIRK_HAS_PMU_MASK_RESET | \\\n\t\t  QUIRK_HAS_PMU_RST_STAT | QUIRK_HAS_PMU_AUTO_DISABLE,\n};\n\nstatic const struct s3c2410_wdt_variant drv_data_exynos850_cl0 = {\n\t.mask_reset_reg = EXYNOS850_CLUSTER0_NONCPU_INT_EN,\n\t.mask_bit = 2,\n\t.mask_reset_inv = true,\n\t.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,\n\t.rst_stat_bit = EXYNOS850_CLUSTER0_WDTRESET_BIT,\n\t.cnt_en_reg = EXYNOS850_CLUSTER0_NONCPU_OUT,\n\t.cnt_en_bit = 7,\n\t.quirks = QUIRK_HAS_WTCLRINT_REG | QUIRK_HAS_PMU_MASK_RESET | \\\n\t\t  QUIRK_HAS_PMU_RST_STAT | QUIRK_HAS_PMU_CNT_EN,\n};\n\nstatic const struct s3c2410_wdt_variant drv_data_exynos850_cl1 = {\n\t.mask_reset_reg = EXYNOS850_CLUSTER1_NONCPU_INT_EN,\n\t.mask_bit = 2,\n\t.mask_reset_inv = true,\n\t.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,\n\t.rst_stat_bit = EXYNOS850_CLUSTER1_WDTRESET_BIT,\n\t.cnt_en_reg = EXYNOS850_CLUSTER1_NONCPU_OUT,\n\t.cnt_en_bit = 7,\n\t.quirks = QUIRK_HAS_WTCLRINT_REG | QUIRK_HAS_PMU_MASK_RESET | \\\n\t\t  QUIRK_HAS_PMU_RST_STAT | QUIRK_HAS_PMU_CNT_EN,\n};\n\nstatic const struct s3c2410_wdt_variant drv_data_exynosautov9_cl0 = {\n\t.mask_reset_reg = EXYNOS850_CLUSTER0_NONCPU_INT_EN,\n\t.mask_bit = 2,\n\t.mask_reset_inv = true,\n\t.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,\n\t.rst_stat_bit = EXYNOSAUTOV9_CLUSTER0_WDTRESET_BIT,\n\t.cnt_en_reg = EXYNOS850_CLUSTER0_NONCPU_OUT,\n\t.cnt_en_bit = 7,\n\t.quirks = QUIRK_HAS_WTCLRINT_REG | QUIRK_HAS_PMU_MASK_RESET |\n\t\t  QUIRK_HAS_PMU_RST_STAT | QUIRK_HAS_PMU_CNT_EN,\n};\n\nstatic const struct s3c2410_wdt_variant drv_data_exynosautov9_cl1 = {\n\t.mask_reset_reg = EXYNOSAUTOV9_CLUSTER1_NONCPU_INT_EN,\n\t.mask_bit = 2,\n\t.mask_reset_inv = true,\n\t.rst_stat_reg = EXYNOS5_RST_STAT_REG_OFFSET,\n\t.rst_stat_bit = EXYNOSAUTOV9_CLUSTER1_WDTRESET_BIT,\n\t.cnt_en_reg = EXYNOSAUTOV9_CLUSTER1_NONCPU_OUT,\n\t.cnt_en_bit = 7,\n\t.quirks = QUIRK_HAS_WTCLRINT_REG | QUIRK_HAS_PMU_MASK_RESET |\n\t\t  QUIRK_HAS_PMU_RST_STAT | QUIRK_HAS_PMU_CNT_EN,\n};\n\nstatic const struct of_device_id s3c2410_wdt_match[] = {\n\t{ .compatible = \"samsung,s3c2410-wdt\",\n\t  .data = &drv_data_s3c2410 },\n\t{ .compatible = \"samsung,s3c6410-wdt\",\n\t  .data = &drv_data_s3c6410 },\n\t{ .compatible = \"samsung,exynos5250-wdt\",\n\t  .data = &drv_data_exynos5250 },\n\t{ .compatible = \"samsung,exynos5420-wdt\",\n\t  .data = &drv_data_exynos5420 },\n\t{ .compatible = \"samsung,exynos7-wdt\",\n\t  .data = &drv_data_exynos7 },\n\t{ .compatible = \"samsung,exynos850-wdt\",\n\t  .data = &drv_data_exynos850_cl0 },\n\t{ .compatible = \"samsung,exynosautov9-wdt\",\n\t  .data = &drv_data_exynosautov9_cl0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, s3c2410_wdt_match);\n#endif\n\nstatic const struct platform_device_id s3c2410_wdt_ids[] = {\n\t{\n\t\t.name = \"s3c2410-wdt\",\n\t\t.driver_data = (unsigned long)&drv_data_s3c2410,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, s3c2410_wdt_ids);\n\n \n\nstatic inline unsigned long s3c2410wdt_get_freq(struct s3c2410_wdt *wdt)\n{\n\treturn clk_get_rate(wdt->src_clk ? wdt->src_clk : wdt->bus_clk);\n}\n\nstatic inline unsigned int s3c2410wdt_max_timeout(struct s3c2410_wdt *wdt)\n{\n\tconst unsigned long freq = s3c2410wdt_get_freq(wdt);\n\n\treturn S3C2410_WTCNT_MAXCNT / (freq / (S3C2410_WTCON_PRESCALE_MAX + 1)\n\t\t\t\t       / S3C2410_WTCON_MAXDIV);\n}\n\nstatic int s3c2410wdt_disable_wdt_reset(struct s3c2410_wdt *wdt, bool mask)\n{\n\tconst u32 mask_val = BIT(wdt->drv_data->mask_bit);\n\tconst u32 val = mask ? mask_val : 0;\n\tint ret;\n\n\tret = regmap_update_bits(wdt->pmureg, wdt->drv_data->disable_reg,\n\t\t\t\t mask_val, val);\n\tif (ret < 0)\n\t\tdev_err(wdt->dev, \"failed to update reg(%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int s3c2410wdt_mask_wdt_reset(struct s3c2410_wdt *wdt, bool mask)\n{\n\tconst u32 mask_val = BIT(wdt->drv_data->mask_bit);\n\tconst bool val_inv = wdt->drv_data->mask_reset_inv;\n\tconst u32 val = (mask ^ val_inv) ? mask_val : 0;\n\tint ret;\n\n\tret = regmap_update_bits(wdt->pmureg, wdt->drv_data->mask_reset_reg,\n\t\t\t\t mask_val, val);\n\tif (ret < 0)\n\t\tdev_err(wdt->dev, \"failed to update reg(%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int s3c2410wdt_enable_counter(struct s3c2410_wdt *wdt, bool en)\n{\n\tconst u32 mask_val = BIT(wdt->drv_data->cnt_en_bit);\n\tconst u32 val = en ? mask_val : 0;\n\tint ret;\n\n\tret = regmap_update_bits(wdt->pmureg, wdt->drv_data->cnt_en_reg,\n\t\t\t\t mask_val, val);\n\tif (ret < 0)\n\t\tdev_err(wdt->dev, \"failed to update reg(%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int s3c2410wdt_enable(struct s3c2410_wdt *wdt, bool en)\n{\n\tint ret;\n\n\tif (wdt->drv_data->quirks & QUIRK_HAS_PMU_AUTO_DISABLE) {\n\t\tret = s3c2410wdt_disable_wdt_reset(wdt, !en);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (wdt->drv_data->quirks & QUIRK_HAS_PMU_MASK_RESET) {\n\t\tret = s3c2410wdt_mask_wdt_reset(wdt, !en);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (wdt->drv_data->quirks & QUIRK_HAS_PMU_CNT_EN) {\n\t\tret = s3c2410wdt_enable_counter(wdt, en);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int s3c2410wdt_keepalive(struct watchdog_device *wdd)\n{\n\tstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\twritel(wdt->count, wdt->reg_base + S3C2410_WTCNT);\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic void __s3c2410wdt_stop(struct s3c2410_wdt *wdt)\n{\n\tunsigned long wtcon;\n\n\twtcon = readl(wdt->reg_base + S3C2410_WTCON);\n\twtcon &= ~(S3C2410_WTCON_ENABLE | S3C2410_WTCON_RSTEN);\n\twritel(wtcon, wdt->reg_base + S3C2410_WTCON);\n}\n\nstatic int s3c2410wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\t__s3c2410wdt_stop(wdt);\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic int s3c2410wdt_start(struct watchdog_device *wdd)\n{\n\tunsigned long wtcon;\n\tstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\n\t__s3c2410wdt_stop(wdt);\n\n\twtcon = readl(wdt->reg_base + S3C2410_WTCON);\n\twtcon |= S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV128;\n\n\tif (soft_noboot) {\n\t\twtcon |= S3C2410_WTCON_INTEN;\n\t\twtcon &= ~S3C2410_WTCON_RSTEN;\n\t} else {\n\t\twtcon &= ~S3C2410_WTCON_INTEN;\n\t\twtcon |= S3C2410_WTCON_RSTEN;\n\t}\n\n\tdev_dbg(wdt->dev, \"Starting watchdog: count=0x%08x, wtcon=%08lx\\n\",\n\t\twdt->count, wtcon);\n\n\twritel(wdt->count, wdt->reg_base + S3C2410_WTDAT);\n\twritel(wdt->count, wdt->reg_base + S3C2410_WTCNT);\n\twritel(wtcon, wdt->reg_base + S3C2410_WTCON);\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic int s3c2410wdt_set_heartbeat(struct watchdog_device *wdd,\n\t\t\t\t    unsigned int timeout)\n{\n\tstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\n\tunsigned long freq = s3c2410wdt_get_freq(wdt);\n\tunsigned int count;\n\tunsigned int divisor = 1;\n\tunsigned long wtcon;\n\n\tif (timeout < 1)\n\t\treturn -EINVAL;\n\n\tfreq = DIV_ROUND_UP(freq, 128);\n\tcount = timeout * freq;\n\n\tdev_dbg(wdt->dev, \"Heartbeat: count=%d, timeout=%d, freq=%lu\\n\",\n\t\tcount, timeout, freq);\n\n\t \n\n\tif (count >= 0x10000) {\n\t\tdivisor = DIV_ROUND_UP(count, 0xffff);\n\n\t\tif (divisor > 0x100) {\n\t\t\tdev_err(wdt->dev, \"timeout %d too big\\n\", timeout);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_dbg(wdt->dev, \"Heartbeat: timeout=%d, divisor=%d, count=%d (%08x)\\n\",\n\t\ttimeout, divisor, count, DIV_ROUND_UP(count, divisor));\n\n\tcount = DIV_ROUND_UP(count, divisor);\n\twdt->count = count;\n\n\t \n\twtcon = readl(wdt->reg_base + S3C2410_WTCON);\n\twtcon &= ~S3C2410_WTCON_PRESCALE_MASK;\n\twtcon |= S3C2410_WTCON_PRESCALE(divisor-1);\n\n\twritel(count, wdt->reg_base + S3C2410_WTDAT);\n\twritel(wtcon, wdt->reg_base + S3C2410_WTCON);\n\n\twdd->timeout = (count * divisor) / freq;\n\n\treturn 0;\n}\n\nstatic int s3c2410wdt_restart(struct watchdog_device *wdd, unsigned long action,\n\t\t\t      void *data)\n{\n\tstruct s3c2410_wdt *wdt = watchdog_get_drvdata(wdd);\n\tvoid __iomem *wdt_base = wdt->reg_base;\n\n\t \n\twritel(0, wdt_base + S3C2410_WTCON);\n\n\t \n\twritel(0x80, wdt_base + S3C2410_WTCNT);\n\twritel(0x80, wdt_base + S3C2410_WTDAT);\n\n\t \n\twritel(S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV16 |\n\t\tS3C2410_WTCON_RSTEN | S3C2410_WTCON_PRESCALE(0x20),\n\t\twdt_base + S3C2410_WTCON);\n\n\t \n\tmdelay(500);\n\n\treturn 0;\n}\n\n#define OPTIONS (WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE)\n\nstatic const struct watchdog_info s3c2410_wdt_ident = {\n\t.options          =     OPTIONS,\n\t.firmware_version =\t0,\n\t.identity         =\t\"S3C2410 Watchdog\",\n};\n\nstatic const struct watchdog_ops s3c2410wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = s3c2410wdt_start,\n\t.stop = s3c2410wdt_stop,\n\t.ping = s3c2410wdt_keepalive,\n\t.set_timeout = s3c2410wdt_set_heartbeat,\n\t.restart = s3c2410wdt_restart,\n};\n\nstatic const struct watchdog_device s3c2410_wdd = {\n\t.info = &s3c2410_wdt_ident,\n\t.ops = &s3c2410wdt_ops,\n\t.timeout = S3C2410_WATCHDOG_DEFAULT_TIME,\n};\n\n \n\nstatic irqreturn_t s3c2410wdt_irq(int irqno, void *param)\n{\n\tstruct s3c2410_wdt *wdt = platform_get_drvdata(param);\n\n\tdev_info(wdt->dev, \"watchdog timer expired (irq)\\n\");\n\n\ts3c2410wdt_keepalive(&wdt->wdt_device);\n\n\tif (wdt->drv_data->quirks & QUIRK_HAS_WTCLRINT_REG)\n\t\twritel(0x1, wdt->reg_base + S3C2410_WTCLRINT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline unsigned int s3c2410wdt_get_bootstatus(struct s3c2410_wdt *wdt)\n{\n\tunsigned int rst_stat;\n\tint ret;\n\n\tif (!(wdt->drv_data->quirks & QUIRK_HAS_PMU_RST_STAT))\n\t\treturn 0;\n\n\tret = regmap_read(wdt->pmureg, wdt->drv_data->rst_stat_reg, &rst_stat);\n\tif (ret)\n\t\tdev_warn(wdt->dev, \"Couldn't get RST_STAT register\\n\");\n\telse if (rst_stat & BIT(wdt->drv_data->rst_stat_bit))\n\t\treturn WDIOF_CARDRESET;\n\n\treturn 0;\n}\n\nstatic inline int\ns3c2410_get_wdt_drv_data(struct platform_device *pdev, struct s3c2410_wdt *wdt)\n{\n\tconst struct s3c2410_wdt_variant *variant;\n\tstruct device *dev = &pdev->dev;\n\n\tvariant = of_device_get_match_data(dev);\n\tif (!variant) {\n\t\t \n\t\tvariant = (struct s3c2410_wdt_variant *)\n\t\t\t   platform_get_device_id(pdev)->driver_data;\n\t}\n\n#ifdef CONFIG_OF\n\t \n\tif (variant == &drv_data_exynos850_cl0 ||\n\t    variant == &drv_data_exynosautov9_cl0) {\n\t\tu32 index;\n\t\tint err;\n\n\t\terr = of_property_read_u32(dev->of_node,\n\t\t\t\t\t   \"samsung,cluster-index\", &index);\n\t\tif (err)\n\t\t\treturn dev_err_probe(dev, -EINVAL, \"failed to get cluster index\\n\");\n\n\t\tswitch (index) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tvariant = (variant == &drv_data_exynos850_cl0) ?\n\t\t\t\t&drv_data_exynos850_cl1 :\n\t\t\t\t&drv_data_exynosautov9_cl1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn dev_err_probe(dev, -EINVAL, \"wrong cluster index: %u\\n\", index);\n\t\t}\n\t}\n#endif\n\n\twdt->drv_data = variant;\n\treturn 0;\n}\n\nstatic void s3c2410wdt_wdt_disable_action(void *data)\n{\n\ts3c2410wdt_enable(data, false);\n}\n\nstatic int s3c2410wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct s3c2410_wdt *wdt;\n\tunsigned int wtcon;\n\tint wdt_irq;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->dev = dev;\n\tspin_lock_init(&wdt->lock);\n\twdt->wdt_device = s3c2410_wdd;\n\n\tret = s3c2410_get_wdt_drv_data(pdev, wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (wdt->drv_data->quirks & QUIRKS_HAVE_PMUREG) {\n\t\twdt->pmureg = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\"samsung,syscon-phandle\");\n\t\tif (IS_ERR(wdt->pmureg))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(wdt->pmureg),\n\t\t\t\t\t     \"syscon regmap lookup failed.\\n\");\n\t}\n\n\twdt_irq = platform_get_irq(pdev, 0);\n\tif (wdt_irq < 0)\n\t\treturn wdt_irq;\n\n\t \n\twdt->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->reg_base))\n\t\treturn PTR_ERR(wdt->reg_base);\n\n\twdt->bus_clk = devm_clk_get_enabled(dev, \"watchdog\");\n\tif (IS_ERR(wdt->bus_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(wdt->bus_clk), \"failed to get bus clock\\n\");\n\n\t \n\twdt->src_clk = devm_clk_get_optional_enabled(dev, \"watchdog_src\");\n\tif (IS_ERR(wdt->src_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(wdt->src_clk), \"failed to get source clock\\n\");\n\n\twdt->wdt_device.min_timeout = 1;\n\twdt->wdt_device.max_timeout = s3c2410wdt_max_timeout(wdt);\n\n\twatchdog_set_drvdata(&wdt->wdt_device, wdt);\n\n\t \n\n\twatchdog_init_timeout(&wdt->wdt_device, tmr_margin, dev);\n\tret = s3c2410wdt_set_heartbeat(&wdt->wdt_device,\n\t\t\t\t\twdt->wdt_device.timeout);\n\tif (ret) {\n\t\tret = s3c2410wdt_set_heartbeat(&wdt->wdt_device,\n\t\t\t\t\t       S3C2410_WATCHDOG_DEFAULT_TIME);\n\t\tif (ret == 0)\n\t\t\tdev_warn(dev, \"tmr_margin value out of range, default %d used\\n\",\n\t\t\t\t S3C2410_WATCHDOG_DEFAULT_TIME);\n\t\telse\n\t\t\treturn dev_err_probe(dev, ret, \"failed to use default timeout\\n\");\n\t}\n\n\tret = devm_request_irq(dev, wdt_irq, s3c2410wdt_irq, 0,\n\t\t\t       pdev->name, pdev);\n\tif (ret != 0)\n\t\treturn dev_err_probe(dev, ret, \"failed to install irq (%d)\\n\", ret);\n\n\twatchdog_set_nowayout(&wdt->wdt_device, nowayout);\n\twatchdog_set_restart_priority(&wdt->wdt_device, 128);\n\n\twdt->wdt_device.bootstatus = s3c2410wdt_get_bootstatus(wdt);\n\twdt->wdt_device.parent = dev;\n\n\t \n\tif (tmr_atboot) {\n\t\tdev_info(dev, \"starting watchdog timer\\n\");\n\t\ts3c2410wdt_start(&wdt->wdt_device);\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdt_device.status);\n\t} else {\n\t\ts3c2410wdt_stop(&wdt->wdt_device);\n\t}\n\n\tret = devm_watchdog_register_device(dev, &wdt->wdt_device);\n\tif (ret)\n\t\treturn ret;\n\n\tret = s3c2410wdt_enable(wdt, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, s3c2410wdt_wdt_disable_action, wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\t \n\n\twtcon = readl(wdt->reg_base + S3C2410_WTCON);\n\n\tdev_info(dev, \"watchdog %sactive, reset %sabled, irq %sabled\\n\",\n\t\t (wtcon & S3C2410_WTCON_ENABLE) ?  \"\" : \"in\",\n\t\t (wtcon & S3C2410_WTCON_RSTEN) ? \"en\" : \"dis\",\n\t\t (wtcon & S3C2410_WTCON_INTEN) ? \"en\" : \"dis\");\n\n\treturn 0;\n}\n\nstatic void s3c2410wdt_shutdown(struct platform_device *dev)\n{\n\tstruct s3c2410_wdt *wdt = platform_get_drvdata(dev);\n\n\ts3c2410wdt_enable(wdt, false);\n\ts3c2410wdt_stop(&wdt->wdt_device);\n}\n\nstatic int s3c2410wdt_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct s3c2410_wdt *wdt = dev_get_drvdata(dev);\n\n\t \n\twdt->wtcon_save = readl(wdt->reg_base + S3C2410_WTCON);\n\twdt->wtdat_save = readl(wdt->reg_base + S3C2410_WTDAT);\n\n\tret = s3c2410wdt_enable(wdt, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ts3c2410wdt_stop(&wdt->wdt_device);\n\n\treturn 0;\n}\n\nstatic int s3c2410wdt_resume(struct device *dev)\n{\n\tint ret;\n\tstruct s3c2410_wdt *wdt = dev_get_drvdata(dev);\n\n\t \n\twritel(wdt->wtdat_save, wdt->reg_base + S3C2410_WTDAT);\n\twritel(wdt->wtdat_save, wdt->reg_base + S3C2410_WTCNT); \n\twritel(wdt->wtcon_save, wdt->reg_base + S3C2410_WTCON);\n\n\tret = s3c2410wdt_enable(wdt, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, \"watchdog %sabled\\n\",\n\t\t(wdt->wtcon_save & S3C2410_WTCON_ENABLE) ? \"en\" : \"dis\");\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(s3c2410wdt_pm_ops,\n\t\t\t\ts3c2410wdt_suspend, s3c2410wdt_resume);\n\nstatic struct platform_driver s3c2410wdt_driver = {\n\t.probe\t\t= s3c2410wdt_probe,\n\t.shutdown\t= s3c2410wdt_shutdown,\n\t.id_table\t= s3c2410_wdt_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"s3c2410-wdt\",\n\t\t.pm\t= pm_sleep_ptr(&s3c2410wdt_pm_ops),\n\t\t.of_match_table\t= of_match_ptr(s3c2410_wdt_match),\n\t},\n};\n\nmodule_platform_driver(s3c2410wdt_driver);\n\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>, Dimitry Andric <dimitry.andric@tomtom.com>\");\nMODULE_DESCRIPTION(\"S3C2410 Watchdog Device Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}