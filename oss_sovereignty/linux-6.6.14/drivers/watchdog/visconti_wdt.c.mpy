{
  "module_name": "visconti_wdt.c",
  "hash_id": "f9bce31636bb95ce9defa3159d44e90dec98478b5074c75b099dfae67be8650c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/visconti_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define WDT_CNT\t\t\t0x00\n#define WDT_MIN\t\t\t0x04\n#define WDT_MAX\t\t\t0x08\n#define WDT_CTL\t\t\t0x0c\n#define WDT_CMD\t\t\t0x10\n#define WDT_CMD_CLEAR\t\t0x4352\n#define WDT_CMD_START_STOP\t0x5354\n#define WDT_DIV\t\t\t0x30\n\n#define VISCONTI_WDT_FREQ\t2000000  \n#define WDT_DEFAULT_TIMEOUT\t10U  \n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(\n\tnowayout,\n\t\"Watchdog cannot be stopped once started (default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT)\")\");\n\nstruct visconti_wdt_priv {\n\tstruct watchdog_device wdev;\n\tvoid __iomem *base;\n\tu32 div;\n};\n\nstatic int visconti_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct visconti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu32 timeout = wdev->timeout * VISCONTI_WDT_FREQ;\n\n\twritel(priv->div, priv->base + WDT_DIV);\n\twritel(0, priv->base + WDT_MIN);\n\twritel(timeout, priv->base + WDT_MAX);\n\twritel(0, priv->base + WDT_CTL);\n\twritel(WDT_CMD_START_STOP, priv->base + WDT_CMD);\n\n\treturn 0;\n}\n\nstatic int visconti_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct visconti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\twritel(1, priv->base + WDT_CTL);\n\twritel(WDT_CMD_START_STOP, priv->base + WDT_CMD);\n\n\treturn 0;\n}\n\nstatic int visconti_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct visconti_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\twritel(WDT_CMD_CLEAR, priv->base + WDT_CMD);\n\n\treturn 0;\n}\n\nstatic unsigned int visconti_wdt_get_timeleft(struct watchdog_device *wdev)\n{\n\tstruct visconti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu32 timeout = wdev->timeout * VISCONTI_WDT_FREQ;\n\tu32 cnt = readl(priv->base + WDT_CNT);\n\n\tif (timeout <= cnt)\n\t\treturn 0;\n\ttimeout -= cnt;\n\n\treturn timeout / VISCONTI_WDT_FREQ;\n}\n\nstatic int visconti_wdt_set_timeout(struct watchdog_device *wdev, unsigned int timeout)\n{\n\tu32 val;\n\tstruct visconti_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\twdev->timeout = timeout;\n\tval = wdev->timeout * VISCONTI_WDT_FREQ;\n\n\t \n\twritel(WDT_CMD_CLEAR, priv->base + WDT_CMD);\n\twritel(val, priv->base + WDT_MAX);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info visconti_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"Visconti Watchdog\",\n};\n\nstatic const struct watchdog_ops visconti_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= visconti_wdt_start,\n\t.stop\t\t= visconti_wdt_stop,\n\t.ping\t\t= visconti_wdt_ping,\n\t.get_timeleft\t= visconti_wdt_get_timeleft,\n\t.set_timeout\t= visconti_wdt_set_timeout,\n};\n\nstatic int visconti_wdt_probe(struct platform_device *pdev)\n{\n\tstruct watchdog_device *wdev;\n\tstruct visconti_wdt_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct clk *clk;\n\tint ret;\n\tunsigned long clk_freq;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"Could not get clock\\n\");\n\n\tclk_freq = clk_get_rate(clk);\n\tif (!clk_freq)\n\t\treturn -EINVAL;\n\n\tpriv->div = clk_freq / VISCONTI_WDT_FREQ;\n\n\t \n\twdev = &priv->wdev;\n\twdev->info = &visconti_wdt_info;\n\twdev->ops = &visconti_wdt_ops;\n\twdev->parent = dev;\n\twdev->min_timeout = 1;\n\twdev->max_timeout = 0xffffffff / VISCONTI_WDT_FREQ;\n\twdev->timeout = min(wdev->max_timeout, WDT_DEFAULT_TIMEOUT);\n\n\twatchdog_set_drvdata(wdev, priv);\n\twatchdog_set_nowayout(wdev, nowayout);\n\twatchdog_stop_on_unregister(wdev);\n\n\t \n\tret = watchdog_init_timeout(wdev, 0, dev);\n\tif (ret)\n\t\tdev_warn(dev, \"Specified timeout value invalid, using default\\n\");\n\n\treturn devm_watchdog_register_device(dev, wdev);\n}\n\nstatic const struct of_device_id visconti_wdt_of_match[] = {\n\t{ .compatible = \"toshiba,visconti-wdt\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, visconti_wdt_of_match);\n\nstatic struct platform_driver visconti_wdt_driver = {\n\t.driver = {\n\t\t\t.name = \"visconti_wdt\",\n\t\t\t.of_match_table = visconti_wdt_of_match,\n\t\t},\n\t.probe = visconti_wdt_probe,\n};\nmodule_platform_driver(visconti_wdt_driver);\n\nMODULE_DESCRIPTION(\"TOSHIBA Visconti Watchdog Driver\");\nMODULE_AUTHOR(\"Nobuhiro Iwamatsu <nobuhiro1.iwamatsu@toshiba.co.jp\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}