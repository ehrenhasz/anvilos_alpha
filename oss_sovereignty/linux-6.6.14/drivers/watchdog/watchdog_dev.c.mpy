{
  "module_name": "watchdog_dev.c",
  "hash_id": "9603608ac7224883489a820164fe549e4dfa3f1225b8a29aea62a467f836490f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/watchdog_dev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cdev.h>\t\t \n#include <linux/errno.h>\t \n#include <linux/fs.h>\t\t \n#include <linux/init.h>\t\t \n#include <linux/hrtimer.h>\t \n#include <linux/kernel.h>\t \n#include <linux/kstrtox.h>\t \n#include <linux/kthread.h>\t \n#include <linux/miscdevice.h>\t \n#include <linux/module.h>\t \n#include <linux/mutex.h>\t \n#include <linux/slab.h>\t\t \n#include <linux/types.h>\t \n#include <linux/watchdog.h>\t \n#include <linux/uaccess.h>\t \n\n#include \"watchdog_core.h\"\n#include \"watchdog_pretimeout.h\"\n\n#include <trace/events/watchdog.h>\n\n \nstatic dev_t watchdog_devt;\n \nstatic struct watchdog_core_data *old_wd_data;\n\nstatic struct kthread_worker *watchdog_kworker;\n\nstatic bool handle_boot_enabled =\n\tIS_ENABLED(CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED);\n\nstatic unsigned open_timeout = CONFIG_WATCHDOG_OPEN_TIMEOUT;\n\nstatic bool watchdog_past_open_deadline(struct watchdog_core_data *data)\n{\n\treturn ktime_after(ktime_get(), data->open_deadline);\n}\n\nstatic void watchdog_set_open_deadline(struct watchdog_core_data *data)\n{\n\tdata->open_deadline = open_timeout ?\n\t\tktime_get() + ktime_set(open_timeout, 0) : KTIME_MAX;\n}\n\nstatic inline bool watchdog_need_worker(struct watchdog_device *wdd)\n{\n\t \n\tunsigned int hm = wdd->max_hw_heartbeat_ms;\n\tunsigned int t = wdd->timeout * 1000;\n\n\t \n\treturn (hm && watchdog_active(wdd) && t > hm) ||\n\t\t(t && !watchdog_active(wdd) && watchdog_hw_running(wdd));\n}\n\nstatic ktime_t watchdog_next_keepalive(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\tunsigned int timeout_ms = wdd->timeout * 1000;\n\tktime_t keepalive_interval;\n\tktime_t last_heartbeat, latest_heartbeat;\n\tktime_t virt_timeout;\n\tunsigned int hw_heartbeat_ms;\n\n\tif (watchdog_active(wdd))\n\t\tvirt_timeout = ktime_add(wd_data->last_keepalive,\n\t\t\t\t\t ms_to_ktime(timeout_ms));\n\telse\n\t\tvirt_timeout = wd_data->open_deadline;\n\n\thw_heartbeat_ms = min_not_zero(timeout_ms, wdd->max_hw_heartbeat_ms);\n\tkeepalive_interval = ms_to_ktime(hw_heartbeat_ms / 2);\n\n\t \n\tlast_heartbeat = ktime_sub(virt_timeout, ms_to_ktime(hw_heartbeat_ms));\n\tlatest_heartbeat = ktime_sub(last_heartbeat, ktime_get());\n\tif (ktime_before(latest_heartbeat, keepalive_interval))\n\t\treturn latest_heartbeat;\n\treturn keepalive_interval;\n}\n\nstatic inline void watchdog_update_worker(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\n\tif (watchdog_need_worker(wdd)) {\n\t\tktime_t t = watchdog_next_keepalive(wdd);\n\n\t\tif (t > 0)\n\t\t\thrtimer_start(&wd_data->timer, t,\n\t\t\t\t      HRTIMER_MODE_REL_HARD);\n\t} else {\n\t\thrtimer_cancel(&wd_data->timer);\n\t}\n}\n\nstatic int __watchdog_ping(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\tktime_t earliest_keepalive, now;\n\tint err;\n\n\tearliest_keepalive = ktime_add(wd_data->last_hw_keepalive,\n\t\t\t\t       ms_to_ktime(wdd->min_hw_heartbeat_ms));\n\tnow = ktime_get();\n\n\tif (ktime_after(earliest_keepalive, now)) {\n\t\thrtimer_start(&wd_data->timer,\n\t\t\t      ktime_sub(earliest_keepalive, now),\n\t\t\t      HRTIMER_MODE_REL_HARD);\n\t\treturn 0;\n\t}\n\n\twd_data->last_hw_keepalive = now;\n\n\tif (wdd->ops->ping) {\n\t\terr = wdd->ops->ping(wdd);   \n\t\ttrace_watchdog_ping(wdd, err);\n\t} else {\n\t\terr = wdd->ops->start(wdd);  \n\t\ttrace_watchdog_start(wdd, err);\n\t}\n\n\tif (err == 0)\n\t\twatchdog_hrtimer_pretimeout_start(wdd);\n\n\twatchdog_update_worker(wdd);\n\n\treturn err;\n}\n\n \nstatic int watchdog_ping(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\n\tif (!watchdog_hw_running(wdd))\n\t\treturn 0;\n\n\tset_bit(_WDOG_KEEPALIVE, &wd_data->status);\n\n\twd_data->last_keepalive = ktime_get();\n\treturn __watchdog_ping(wdd);\n}\n\nstatic bool watchdog_worker_should_ping(struct watchdog_core_data *wd_data)\n{\n\tstruct watchdog_device *wdd = wd_data->wdd;\n\n\tif (!wdd)\n\t\treturn false;\n\n\tif (watchdog_active(wdd))\n\t\treturn true;\n\n\treturn watchdog_hw_running(wdd) && !watchdog_past_open_deadline(wd_data);\n}\n\nstatic void watchdog_ping_work(struct kthread_work *work)\n{\n\tstruct watchdog_core_data *wd_data;\n\n\twd_data = container_of(work, struct watchdog_core_data, work);\n\n\tmutex_lock(&wd_data->lock);\n\tif (watchdog_worker_should_ping(wd_data))\n\t\t__watchdog_ping(wd_data->wdd);\n\tmutex_unlock(&wd_data->lock);\n}\n\nstatic enum hrtimer_restart watchdog_timer_expired(struct hrtimer *timer)\n{\n\tstruct watchdog_core_data *wd_data;\n\n\twd_data = container_of(timer, struct watchdog_core_data, timer);\n\n\tkthread_queue_work(watchdog_kworker, &wd_data->work);\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic int watchdog_start(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\tktime_t started_at;\n\tint err;\n\n\tif (watchdog_active(wdd))\n\t\treturn 0;\n\n\tset_bit(_WDOG_KEEPALIVE, &wd_data->status);\n\n\tstarted_at = ktime_get();\n\tif (watchdog_hw_running(wdd) && wdd->ops->ping) {\n\t\terr = __watchdog_ping(wdd);\n\t\tif (err == 0) {\n\t\t\tset_bit(WDOG_ACTIVE, &wdd->status);\n\t\t\twatchdog_hrtimer_pretimeout_start(wdd);\n\t\t}\n\t} else {\n\t\terr = wdd->ops->start(wdd);\n\t\ttrace_watchdog_start(wdd, err);\n\t\tif (err == 0) {\n\t\t\tset_bit(WDOG_ACTIVE, &wdd->status);\n\t\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t\t\twd_data->last_keepalive = started_at;\n\t\t\twd_data->last_hw_keepalive = started_at;\n\t\t\twatchdog_update_worker(wdd);\n\t\t\twatchdog_hrtimer_pretimeout_start(wdd);\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic int watchdog_stop(struct watchdog_device *wdd)\n{\n\tint err = 0;\n\n\tif (!watchdog_active(wdd))\n\t\treturn 0;\n\n\tif (test_bit(WDOG_NO_WAY_OUT, &wdd->status)) {\n\t\tpr_info(\"watchdog%d: nowayout prevents watchdog being stopped!\\n\",\n\t\t\twdd->id);\n\t\treturn -EBUSY;\n\t}\n\n\tif (wdd->ops->stop) {\n\t\tclear_bit(WDOG_HW_RUNNING, &wdd->status);\n\t\terr = wdd->ops->stop(wdd);\n\t\ttrace_watchdog_stop(wdd, err);\n\t} else {\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t}\n\n\tif (err == 0) {\n\t\tclear_bit(WDOG_ACTIVE, &wdd->status);\n\t\twatchdog_update_worker(wdd);\n\t\twatchdog_hrtimer_pretimeout_stop(wdd);\n\t}\n\n\treturn err;\n}\n\n \nstatic unsigned int watchdog_get_status(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\tunsigned int status;\n\n\tif (wdd->ops->status)\n\t\tstatus = wdd->ops->status(wdd);\n\telse\n\t\tstatus = wdd->bootstatus & (WDIOF_CARDRESET |\n\t\t\t\t\t    WDIOF_OVERHEAT |\n\t\t\t\t\t    WDIOF_FANFAULT |\n\t\t\t\t\t    WDIOF_EXTERN1 |\n\t\t\t\t\t    WDIOF_EXTERN2 |\n\t\t\t\t\t    WDIOF_POWERUNDER |\n\t\t\t\t\t    WDIOF_POWEROVER);\n\n\tif (test_bit(_WDOG_ALLOW_RELEASE, &wd_data->status))\n\t\tstatus |= WDIOF_MAGICCLOSE;\n\n\tif (test_and_clear_bit(_WDOG_KEEPALIVE, &wd_data->status))\n\t\tstatus |= WDIOF_KEEPALIVEPING;\n\n\tif (IS_ENABLED(CONFIG_WATCHDOG_HRTIMER_PRETIMEOUT))\n\t\tstatus |= WDIOF_PRETIMEOUT;\n\n\treturn status;\n}\n\n \nstatic int watchdog_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t\t\t\tunsigned int timeout)\n{\n\tint err = 0;\n\n\tif (!(wdd->info->options & WDIOF_SETTIMEOUT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (watchdog_timeout_invalid(wdd, timeout))\n\t\treturn -EINVAL;\n\n\tif (wdd->ops->set_timeout) {\n\t\terr = wdd->ops->set_timeout(wdd, timeout);\n\t\ttrace_watchdog_set_timeout(wdd, timeout, err);\n\t} else {\n\t\twdd->timeout = timeout;\n\t\t \n\t\tif (wdd->pretimeout >= wdd->timeout)\n\t\t\twdd->pretimeout = 0;\n\t}\n\n\twatchdog_update_worker(wdd);\n\n\treturn err;\n}\n\n \nstatic int watchdog_set_pretimeout(struct watchdog_device *wdd,\n\t\t\t\t   unsigned int timeout)\n{\n\tint err = 0;\n\n\tif (!watchdog_have_pretimeout(wdd))\n\t\treturn -EOPNOTSUPP;\n\n\tif (watchdog_pretimeout_invalid(wdd, timeout))\n\t\treturn -EINVAL;\n\n\tif (wdd->ops->set_pretimeout && (wdd->info->options & WDIOF_PRETIMEOUT))\n\t\terr = wdd->ops->set_pretimeout(wdd, timeout);\n\telse\n\t\twdd->pretimeout = timeout;\n\n\treturn err;\n}\n\n \nstatic int watchdog_get_timeleft(struct watchdog_device *wdd,\n\t\t\t\t\t\t\tunsigned int *timeleft)\n{\n\t*timeleft = 0;\n\n\tif (!wdd->ops->get_timeleft)\n\t\treturn -EOPNOTSUPP;\n\n\t*timeleft = wdd->ops->get_timeleft(wdd);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_WATCHDOG_SYSFS\nstatic ssize_t nowayout_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!test_bit(WDOG_NO_WAY_OUT,\n\t\t\t\t\t\t  &wdd->status));\n}\n\nstatic ssize_t nowayout_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\tunsigned int value;\n\tint ret;\n\n\tret = kstrtouint(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\t \n\tif (test_bit(WDOG_NO_WAY_OUT, &wdd->status) && !value)\n\t\treturn -EPERM;\n\twatchdog_set_nowayout(wdd, value);\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(nowayout);\n\nstatic ssize_t status_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\tunsigned int status;\n\n\tmutex_lock(&wd_data->lock);\n\tstatus = watchdog_get_status(wdd);\n\tmutex_unlock(&wd_data->lock);\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", status);\n}\nstatic DEVICE_ATTR_RO(status);\n\nstatic ssize_t bootstatus_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", wdd->bootstatus);\n}\nstatic DEVICE_ATTR_RO(bootstatus);\n\nstatic ssize_t timeleft_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\tssize_t status;\n\tunsigned int val;\n\n\tmutex_lock(&wd_data->lock);\n\tstatus = watchdog_get_timeleft(wdd, &val);\n\tmutex_unlock(&wd_data->lock);\n\tif (!status)\n\t\tstatus = sysfs_emit(buf, \"%u\\n\", val);\n\n\treturn status;\n}\nstatic DEVICE_ATTR_RO(timeleft);\n\nstatic ssize_t timeout_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", wdd->timeout);\n}\nstatic DEVICE_ATTR_RO(timeout);\n\nstatic ssize_t min_timeout_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", wdd->min_timeout);\n}\nstatic DEVICE_ATTR_RO(min_timeout);\n\nstatic ssize_t max_timeout_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", wdd->max_timeout);\n}\nstatic DEVICE_ATTR_RO(max_timeout);\n\nstatic ssize_t pretimeout_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", wdd->pretimeout);\n}\nstatic DEVICE_ATTR_RO(pretimeout);\n\nstatic ssize_t options_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", wdd->info->options);\n}\nstatic DEVICE_ATTR_RO(options);\n\nstatic ssize_t fw_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", wdd->info->firmware_version);\n}\nstatic DEVICE_ATTR_RO(fw_version);\n\nstatic ssize_t identity_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", wdd->info->identity);\n}\nstatic DEVICE_ATTR_RO(identity);\n\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\tif (watchdog_active(wdd))\n\t\treturn sysfs_emit(buf, \"active\\n\");\n\n\treturn sysfs_emit(buf, \"inactive\\n\");\n}\nstatic DEVICE_ATTR_RO(state);\n\nstatic ssize_t pretimeout_available_governors_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn watchdog_pretimeout_available_governors_get(buf);\n}\nstatic DEVICE_ATTR_RO(pretimeout_available_governors);\n\nstatic ssize_t pretimeout_governor_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\n\treturn watchdog_pretimeout_governor_get(wdd, buf);\n}\n\nstatic ssize_t pretimeout_governor_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\tint ret = watchdog_pretimeout_governor_set(wdd, buf);\n\n\tif (!ret)\n\t\tret = count;\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(pretimeout_governor);\n\nstatic umode_t wdt_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\tint n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct watchdog_device *wdd = dev_get_drvdata(dev);\n\tumode_t mode = attr->mode;\n\n\tif (attr == &dev_attr_timeleft.attr && !wdd->ops->get_timeleft)\n\t\tmode = 0;\n\telse if (attr == &dev_attr_pretimeout.attr && !watchdog_have_pretimeout(wdd))\n\t\tmode = 0;\n\telse if ((attr == &dev_attr_pretimeout_governor.attr ||\n\t\t  attr == &dev_attr_pretimeout_available_governors.attr) &&\n\t\t (!watchdog_have_pretimeout(wdd) || !IS_ENABLED(CONFIG_WATCHDOG_PRETIMEOUT_GOV)))\n\t\tmode = 0;\n\n\treturn mode;\n}\nstatic struct attribute *wdt_attrs[] = {\n\t&dev_attr_state.attr,\n\t&dev_attr_options.attr,\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_identity.attr,\n\t&dev_attr_timeout.attr,\n\t&dev_attr_min_timeout.attr,\n\t&dev_attr_max_timeout.attr,\n\t&dev_attr_pretimeout.attr,\n\t&dev_attr_timeleft.attr,\n\t&dev_attr_bootstatus.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_nowayout.attr,\n\t&dev_attr_pretimeout_governor.attr,\n\t&dev_attr_pretimeout_available_governors.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group wdt_group = {\n\t.attrs = wdt_attrs,\n\t.is_visible = wdt_is_visible,\n};\n__ATTRIBUTE_GROUPS(wdt);\n#else\n#define wdt_groups\tNULL\n#endif\n\n \nstatic int watchdog_ioctl_op(struct watchdog_device *wdd, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tif (!wdd->ops->ioctl)\n\t\treturn -ENOIOCTLCMD;\n\n\treturn wdd->ops->ioctl(wdd, cmd, arg);\n}\n\n \nstatic ssize_t watchdog_write(struct file *file, const char __user *data,\n\t\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tstruct watchdog_core_data *wd_data = file->private_data;\n\tstruct watchdog_device *wdd;\n\tint err;\n\tsize_t i;\n\tchar c;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\t \n\tclear_bit(_WDOG_ALLOW_RELEASE, &wd_data->status);\n\n\t \n\tfor (i = 0; i != len; i++) {\n\t\tif (get_user(c, data + i))\n\t\t\treturn -EFAULT;\n\t\tif (c == 'V')\n\t\t\tset_bit(_WDOG_ALLOW_RELEASE, &wd_data->status);\n\t}\n\n\t \n\n\terr = -ENODEV;\n\tmutex_lock(&wd_data->lock);\n\twdd = wd_data->wdd;\n\tif (wdd)\n\t\terr = watchdog_ping(wdd);\n\tmutex_unlock(&wd_data->lock);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn len;\n}\n\n \n\nstatic long watchdog_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tstruct watchdog_core_data *wd_data = file->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct watchdog_device *wdd;\n\tint __user *p = argp;\n\tunsigned int val;\n\tint err;\n\n\tmutex_lock(&wd_data->lock);\n\n\twdd = wd_data->wdd;\n\tif (!wdd) {\n\t\terr = -ENODEV;\n\t\tgoto out_ioctl;\n\t}\n\n\terr = watchdog_ioctl_op(wdd, cmd, arg);\n\tif (err != -ENOIOCTLCMD)\n\t\tgoto out_ioctl;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\terr = copy_to_user(argp, wdd->info,\n\t\t\tsizeof(struct watchdog_info)) ? -EFAULT : 0;\n\t\tbreak;\n\tcase WDIOC_GETSTATUS:\n\t\tval = watchdog_get_status(wdd);\n\t\terr = put_user(val, p);\n\t\tbreak;\n\tcase WDIOC_GETBOOTSTATUS:\n\t\terr = put_user(wdd->bootstatus, p);\n\t\tbreak;\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(val, p)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (val & WDIOS_DISABLECARD) {\n\t\t\terr = watchdog_stop(wdd);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (val & WDIOS_ENABLECARD)\n\t\t\terr = watchdog_start(wdd);\n\t\tbreak;\n\tcase WDIOC_KEEPALIVE:\n\t\tif (!(wdd->info->options & WDIOF_KEEPALIVEPING)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\terr = watchdog_ping(wdd);\n\t\tbreak;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(val, p)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = watchdog_set_timeout(wdd, val);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t \n\t\terr = watchdog_ping(wdd);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\t \n\t\tif (wdd->timeout == 0) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\terr = put_user(wdd->timeout, p);\n\t\tbreak;\n\tcase WDIOC_GETTIMELEFT:\n\t\terr = watchdog_get_timeleft(wdd, &val);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\terr = put_user(val, p);\n\t\tbreak;\n\tcase WDIOC_SETPRETIMEOUT:\n\t\tif (get_user(val, p)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = watchdog_set_pretimeout(wdd, val);\n\t\tbreak;\n\tcase WDIOC_GETPRETIMEOUT:\n\t\terr = put_user(wdd->pretimeout, p);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t\tbreak;\n\t}\n\nout_ioctl:\n\tmutex_unlock(&wd_data->lock);\n\treturn err;\n}\n\n \nstatic int watchdog_open(struct inode *inode, struct file *file)\n{\n\tstruct watchdog_core_data *wd_data;\n\tstruct watchdog_device *wdd;\n\tbool hw_running;\n\tint err;\n\n\t \n\tif (imajor(inode) == MISC_MAJOR)\n\t\twd_data = old_wd_data;\n\telse\n\t\twd_data = container_of(inode->i_cdev, struct watchdog_core_data,\n\t\t\t\t       cdev);\n\n\t \n\tif (test_and_set_bit(_WDOG_DEV_OPEN, &wd_data->status))\n\t\treturn -EBUSY;\n\n\twdd = wd_data->wdd;\n\n\t \n\thw_running = watchdog_hw_running(wdd);\n\tif (!hw_running && !try_module_get(wdd->ops->owner)) {\n\t\terr = -EBUSY;\n\t\tgoto out_clear;\n\t}\n\n\terr = watchdog_start(wdd);\n\tif (err < 0)\n\t\tgoto out_mod;\n\n\tfile->private_data = wd_data;\n\n\tif (!hw_running)\n\t\tget_device(&wd_data->dev);\n\n\t \n\twd_data->open_deadline = KTIME_MAX;\n\n\t \n\treturn stream_open(inode, file);\n\nout_mod:\n\tmodule_put(wd_data->wdd->ops->owner);\nout_clear:\n\tclear_bit(_WDOG_DEV_OPEN, &wd_data->status);\n\treturn err;\n}\n\nstatic void watchdog_core_data_release(struct device *dev)\n{\n\tstruct watchdog_core_data *wd_data;\n\n\twd_data = container_of(dev, struct watchdog_core_data, dev);\n\n\tkfree(wd_data);\n}\n\n \nstatic int watchdog_release(struct inode *inode, struct file *file)\n{\n\tstruct watchdog_core_data *wd_data = file->private_data;\n\tstruct watchdog_device *wdd;\n\tint err = -EBUSY;\n\tbool running;\n\n\tmutex_lock(&wd_data->lock);\n\n\twdd = wd_data->wdd;\n\tif (!wdd)\n\t\tgoto done;\n\n\t \n\tif (!watchdog_active(wdd))\n\t\terr = 0;\n\telse if (test_and_clear_bit(_WDOG_ALLOW_RELEASE, &wd_data->status) ||\n\t\t !(wdd->info->options & WDIOF_MAGICCLOSE))\n\t\terr = watchdog_stop(wdd);\n\n\t \n\tif (err < 0) {\n\t\tpr_crit(\"watchdog%d: watchdog did not stop!\\n\", wdd->id);\n\t\twatchdog_ping(wdd);\n\t}\n\n\twatchdog_update_worker(wdd);\n\n\t \n\tclear_bit(_WDOG_DEV_OPEN, &wd_data->status);\n\ndone:\n\trunning = wdd && watchdog_hw_running(wdd);\n\tmutex_unlock(&wd_data->lock);\n\t \n\tif (!running) {\n\t\tmodule_put(wd_data->cdev.owner);\n\t\tput_device(&wd_data->dev);\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations watchdog_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= watchdog_write,\n\t.unlocked_ioctl\t= watchdog_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= watchdog_open,\n\t.release\t= watchdog_release,\n};\n\nstatic struct miscdevice watchdog_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &watchdog_fops,\n};\n\nstatic struct class watchdog_class = {\n\t.name =\t\t\"watchdog\",\n\t.dev_groups =\twdt_groups,\n};\n\n \nstatic int watchdog_cdev_register(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data;\n\tint err;\n\n\twd_data = kzalloc(sizeof(struct watchdog_core_data), GFP_KERNEL);\n\tif (!wd_data)\n\t\treturn -ENOMEM;\n\tmutex_init(&wd_data->lock);\n\n\twd_data->wdd = wdd;\n\twdd->wd_data = wd_data;\n\n\tif (IS_ERR_OR_NULL(watchdog_kworker)) {\n\t\tkfree(wd_data);\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_initialize(&wd_data->dev);\n\twd_data->dev.devt = MKDEV(MAJOR(watchdog_devt), wdd->id);\n\twd_data->dev.class = &watchdog_class;\n\twd_data->dev.parent = wdd->parent;\n\twd_data->dev.groups = wdd->groups;\n\twd_data->dev.release = watchdog_core_data_release;\n\tdev_set_drvdata(&wd_data->dev, wdd);\n\terr = dev_set_name(&wd_data->dev, \"watchdog%d\", wdd->id);\n\tif (err) {\n\t\tput_device(&wd_data->dev);\n\t\treturn err;\n\t}\n\n\tkthread_init_work(&wd_data->work, watchdog_ping_work);\n\thrtimer_init(&wd_data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\twd_data->timer.function = watchdog_timer_expired;\n\twatchdog_hrtimer_pretimeout_init(wdd);\n\n\tif (wdd->id == 0) {\n\t\told_wd_data = wd_data;\n\t\twatchdog_miscdev.parent = wdd->parent;\n\t\terr = misc_register(&watchdog_miscdev);\n\t\tif (err != 0) {\n\t\t\tpr_err(\"%s: cannot register miscdev on minor=%d (err=%d).\\n\",\n\t\t\t\twdd->info->identity, WATCHDOG_MINOR, err);\n\t\t\tif (err == -EBUSY)\n\t\t\t\tpr_err(\"%s: a legacy watchdog module is probably present.\\n\",\n\t\t\t\t\twdd->info->identity);\n\t\t\told_wd_data = NULL;\n\t\t\tput_device(&wd_data->dev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tcdev_init(&wd_data->cdev, &watchdog_fops);\n\twd_data->cdev.owner = wdd->ops->owner;\n\n\t \n\terr = cdev_device_add(&wd_data->cdev, &wd_data->dev);\n\tif (err) {\n\t\tpr_err(\"watchdog%d unable to add device %d:%d\\n\",\n\t\t\twdd->id,  MAJOR(watchdog_devt), wdd->id);\n\t\tif (wdd->id == 0) {\n\t\t\tmisc_deregister(&watchdog_miscdev);\n\t\t\told_wd_data = NULL;\n\t\t}\n\t\tput_device(&wd_data->dev);\n\t\treturn err;\n\t}\n\n\t \n\twd_data->last_hw_keepalive = ktime_sub(ktime_get(), 1);\n\twatchdog_set_open_deadline(wd_data);\n\n\t \n\tif (watchdog_hw_running(wdd)) {\n\t\t__module_get(wdd->ops->owner);\n\t\tget_device(&wd_data->dev);\n\t\tif (handle_boot_enabled)\n\t\t\thrtimer_start(&wd_data->timer, 0,\n\t\t\t\t      HRTIMER_MODE_REL_HARD);\n\t\telse\n\t\t\tpr_info(\"watchdog%d running and kernel based pre-userspace handler disabled\\n\",\n\t\t\t\twdd->id);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void watchdog_cdev_unregister(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\n\tcdev_device_del(&wd_data->cdev, &wd_data->dev);\n\tif (wdd->id == 0) {\n\t\tmisc_deregister(&watchdog_miscdev);\n\t\told_wd_data = NULL;\n\t}\n\n\tif (watchdog_active(wdd) &&\n\t    test_bit(WDOG_STOP_ON_UNREGISTER, &wdd->status)) {\n\t\twatchdog_stop(wdd);\n\t}\n\n\twatchdog_hrtimer_pretimeout_stop(wdd);\n\n\tmutex_lock(&wd_data->lock);\n\twd_data->wdd = NULL;\n\twdd->wd_data = NULL;\n\tmutex_unlock(&wd_data->lock);\n\n\thrtimer_cancel(&wd_data->timer);\n\tkthread_cancel_work_sync(&wd_data->work);\n\n\tput_device(&wd_data->dev);\n}\n\n \nint watchdog_dev_register(struct watchdog_device *wdd)\n{\n\tint ret;\n\n\tret = watchdog_cdev_register(wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = watchdog_register_pretimeout(wdd);\n\tif (ret)\n\t\twatchdog_cdev_unregister(wdd);\n\n\treturn ret;\n}\n\n \nvoid watchdog_dev_unregister(struct watchdog_device *wdd)\n{\n\twatchdog_unregister_pretimeout(wdd);\n\twatchdog_cdev_unregister(wdd);\n}\n\n \nint watchdog_set_last_hw_keepalive(struct watchdog_device *wdd,\n\t\t\t\t   unsigned int last_ping_ms)\n{\n\tstruct watchdog_core_data *wd_data;\n\tktime_t now;\n\n\tif (!wdd)\n\t\treturn -EINVAL;\n\n\twd_data = wdd->wd_data;\n\n\tnow = ktime_get();\n\n\twd_data->last_hw_keepalive = ktime_sub(now, ms_to_ktime(last_ping_ms));\n\n\tif (watchdog_hw_running(wdd) && handle_boot_enabled)\n\t\treturn __watchdog_ping(wdd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(watchdog_set_last_hw_keepalive);\n\n \nint __init watchdog_dev_init(void)\n{\n\tint err;\n\n\twatchdog_kworker = kthread_create_worker(0, \"watchdogd\");\n\tif (IS_ERR(watchdog_kworker)) {\n\t\tpr_err(\"Failed to create watchdog kworker\\n\");\n\t\treturn PTR_ERR(watchdog_kworker);\n\t}\n\tsched_set_fifo(watchdog_kworker->task);\n\n\terr = class_register(&watchdog_class);\n\tif (err < 0) {\n\t\tpr_err(\"couldn't register class\\n\");\n\t\tgoto err_register;\n\t}\n\n\terr = alloc_chrdev_region(&watchdog_devt, 0, MAX_DOGS, \"watchdog\");\n\tif (err < 0) {\n\t\tpr_err(\"watchdog: unable to allocate char dev region\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\treturn 0;\n\nerr_alloc:\n\tclass_unregister(&watchdog_class);\nerr_register:\n\tkthread_destroy_worker(watchdog_kworker);\n\treturn err;\n}\n\n \nvoid __exit watchdog_dev_exit(void)\n{\n\tunregister_chrdev_region(watchdog_devt, MAX_DOGS);\n\tclass_unregister(&watchdog_class);\n\tkthread_destroy_worker(watchdog_kworker);\n}\n\nint watchdog_dev_suspend(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\tint ret = 0;\n\n\tif (!wdd->wd_data)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&wd_data->lock);\n\tif (watchdog_worker_should_ping(wd_data))\n\t\tret = __watchdog_ping(wd_data->wdd);\n\tmutex_unlock(&wd_data->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\thrtimer_cancel(&wd_data->timer);\n\tkthread_cancel_work_sync(&wd_data->work);\n\n\treturn 0;\n}\n\nint watchdog_dev_resume(struct watchdog_device *wdd)\n{\n\tstruct watchdog_core_data *wd_data = wdd->wd_data;\n\tint ret = 0;\n\n\tif (!wdd->wd_data)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&wd_data->lock);\n\tif (watchdog_worker_should_ping(wd_data))\n\t\tret = __watchdog_ping(wd_data->wdd);\n\tmutex_unlock(&wd_data->lock);\n\n\treturn ret;\n}\n\nmodule_param(handle_boot_enabled, bool, 0444);\nMODULE_PARM_DESC(handle_boot_enabled,\n\t\"Watchdog core auto-updates boot enabled watchdogs before userspace takes over (default=\"\n\t__MODULE_STRING(IS_ENABLED(CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED)) \")\");\n\nmodule_param(open_timeout, uint, 0644);\nMODULE_PARM_DESC(open_timeout,\n\t\"Maximum time (in seconds, 0 means infinity) for userspace to take over a running watchdog (default=\"\n\t__MODULE_STRING(CONFIG_WATCHDOG_OPEN_TIMEOUT) \")\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}