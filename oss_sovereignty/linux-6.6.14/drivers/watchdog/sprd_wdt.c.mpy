{
  "module_name": "sprd_wdt.c",
  "hash_id": "a43b36e23b2b50ff93b0a9cee31362c756dc61b4d881b2cab657c1ca2c898927",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sprd_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define SPRD_WDT_LOAD_LOW\t\t0x0\n#define SPRD_WDT_LOAD_HIGH\t\t0x4\n#define SPRD_WDT_CTRL\t\t\t0x8\n#define SPRD_WDT_INT_CLR\t\t0xc\n#define SPRD_WDT_INT_RAW\t\t0x10\n#define SPRD_WDT_INT_MSK\t\t0x14\n#define SPRD_WDT_CNT_LOW\t\t0x18\n#define SPRD_WDT_CNT_HIGH\t\t0x1c\n#define SPRD_WDT_LOCK\t\t\t0x20\n#define SPRD_WDT_IRQ_LOAD_LOW\t\t0x2c\n#define SPRD_WDT_IRQ_LOAD_HIGH\t\t0x30\n\n \n#define SPRD_WDT_INT_EN_BIT\t\tBIT(0)\n#define SPRD_WDT_CNT_EN_BIT\t\tBIT(1)\n#define SPRD_WDT_NEW_VER_EN\t\tBIT(2)\n#define SPRD_WDT_RST_EN_BIT\t\tBIT(3)\n\n \n#define SPRD_WDT_INT_CLEAR_BIT\t\tBIT(0)\n#define SPRD_WDT_RST_CLEAR_BIT\t\tBIT(3)\n\n \n#define SPRD_WDT_INT_RAW_BIT\t\tBIT(0)\n#define SPRD_WDT_RST_RAW_BIT\t\tBIT(3)\n#define SPRD_WDT_LD_BUSY_BIT\t\tBIT(4)\n\n \n#define SPRD_WDT_CNT_STEP\t\t32768\n\n#define SPRD_WDT_UNLOCK_KEY\t\t0xe551\n#define SPRD_WDT_MIN_TIMEOUT\t\t3\n#define SPRD_WDT_MAX_TIMEOUT\t\t60\n\n#define SPRD_WDT_CNT_HIGH_SHIFT\t\t16\n#define SPRD_WDT_LOW_VALUE_MASK\t\tGENMASK(15, 0)\n#define SPRD_WDT_LOAD_TIMEOUT\t\t11\n\nstruct sprd_wdt {\n\tvoid __iomem *base;\n\tstruct watchdog_device wdd;\n\tstruct clk *enable;\n\tstruct clk *rtc_enable;\n\tint irq;\n};\n\nstatic inline struct sprd_wdt *to_sprd_wdt(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct sprd_wdt, wdd);\n}\n\nstatic inline void sprd_wdt_lock(void __iomem *addr)\n{\n\twritel_relaxed(0x0, addr + SPRD_WDT_LOCK);\n}\n\nstatic inline void sprd_wdt_unlock(void __iomem *addr)\n{\n\twritel_relaxed(SPRD_WDT_UNLOCK_KEY, addr + SPRD_WDT_LOCK);\n}\n\nstatic irqreturn_t sprd_wdt_isr(int irq, void *dev_id)\n{\n\tstruct sprd_wdt *wdt = (struct sprd_wdt *)dev_id;\n\n\tsprd_wdt_unlock(wdt->base);\n\twritel_relaxed(SPRD_WDT_INT_CLEAR_BIT, wdt->base + SPRD_WDT_INT_CLR);\n\tsprd_wdt_lock(wdt->base);\n\twatchdog_notify_pretimeout(&wdt->wdd);\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 sprd_wdt_get_cnt_value(struct sprd_wdt *wdt)\n{\n\tu32 val;\n\n\tval = readl_relaxed(wdt->base + SPRD_WDT_CNT_HIGH) <<\n\t\tSPRD_WDT_CNT_HIGH_SHIFT;\n\tval |= readl_relaxed(wdt->base + SPRD_WDT_CNT_LOW) &\n\t\tSPRD_WDT_LOW_VALUE_MASK;\n\n\treturn val;\n}\n\nstatic int sprd_wdt_load_value(struct sprd_wdt *wdt, u32 timeout,\n\t\t\t       u32 pretimeout)\n{\n\tu32 val, delay_cnt = 0;\n\tu32 tmr_step = timeout * SPRD_WDT_CNT_STEP;\n\tu32 prtmr_step = pretimeout * SPRD_WDT_CNT_STEP;\n\n\t \n\tdo {\n\t\tval = readl_relaxed(wdt->base + SPRD_WDT_INT_RAW);\n\t\tif (!(val & SPRD_WDT_LD_BUSY_BIT))\n\t\t\tbreak;\n\n\t\tusleep_range(10, 100);\n\t} while (delay_cnt++ < SPRD_WDT_LOAD_TIMEOUT);\n\n\tif (delay_cnt >= SPRD_WDT_LOAD_TIMEOUT)\n\t\treturn -EBUSY;\n\n\tsprd_wdt_unlock(wdt->base);\n\twritel_relaxed((tmr_step >> SPRD_WDT_CNT_HIGH_SHIFT) &\n\t\t      SPRD_WDT_LOW_VALUE_MASK, wdt->base + SPRD_WDT_LOAD_HIGH);\n\twritel_relaxed((tmr_step & SPRD_WDT_LOW_VALUE_MASK),\n\t\t       wdt->base + SPRD_WDT_LOAD_LOW);\n\twritel_relaxed((prtmr_step >> SPRD_WDT_CNT_HIGH_SHIFT) &\n\t\t\tSPRD_WDT_LOW_VALUE_MASK,\n\t\t       wdt->base + SPRD_WDT_IRQ_LOAD_HIGH);\n\twritel_relaxed(prtmr_step & SPRD_WDT_LOW_VALUE_MASK,\n\t\t       wdt->base + SPRD_WDT_IRQ_LOAD_LOW);\n\tsprd_wdt_lock(wdt->base);\n\n\treturn 0;\n}\n\nstatic int sprd_wdt_enable(struct sprd_wdt *wdt)\n{\n\tu32 val;\n\tint ret;\n\n\tret = clk_prepare_enable(wdt->enable);\n\tif (ret)\n\t\treturn ret;\n\tret = clk_prepare_enable(wdt->rtc_enable);\n\tif (ret) {\n\t\tclk_disable_unprepare(wdt->enable);\n\t\treturn ret;\n\t}\n\n\tsprd_wdt_unlock(wdt->base);\n\tval = readl_relaxed(wdt->base + SPRD_WDT_CTRL);\n\tval |= SPRD_WDT_NEW_VER_EN;\n\twritel_relaxed(val, wdt->base + SPRD_WDT_CTRL);\n\tsprd_wdt_lock(wdt->base);\n\treturn 0;\n}\n\nstatic void sprd_wdt_disable(void *_data)\n{\n\tstruct sprd_wdt *wdt = _data;\n\n\tsprd_wdt_unlock(wdt->base);\n\twritel_relaxed(0x0, wdt->base + SPRD_WDT_CTRL);\n\tsprd_wdt_lock(wdt->base);\n\n\tclk_disable_unprepare(wdt->rtc_enable);\n\tclk_disable_unprepare(wdt->enable);\n}\n\nstatic int sprd_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct sprd_wdt *wdt = to_sprd_wdt(wdd);\n\tu32 val;\n\tint ret;\n\n\tret = sprd_wdt_load_value(wdt, wdd->timeout, wdd->pretimeout);\n\tif (ret)\n\t\treturn ret;\n\n\tsprd_wdt_unlock(wdt->base);\n\tval = readl_relaxed(wdt->base + SPRD_WDT_CTRL);\n\tval |= SPRD_WDT_CNT_EN_BIT | SPRD_WDT_INT_EN_BIT | SPRD_WDT_RST_EN_BIT;\n\twritel_relaxed(val, wdt->base + SPRD_WDT_CTRL);\n\tsprd_wdt_lock(wdt->base);\n\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\n\treturn 0;\n}\n\nstatic int sprd_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct sprd_wdt *wdt = to_sprd_wdt(wdd);\n\tu32 val;\n\n\tsprd_wdt_unlock(wdt->base);\n\tval = readl_relaxed(wdt->base + SPRD_WDT_CTRL);\n\tval &= ~(SPRD_WDT_CNT_EN_BIT | SPRD_WDT_RST_EN_BIT |\n\t\tSPRD_WDT_INT_EN_BIT);\n\twritel_relaxed(val, wdt->base + SPRD_WDT_CTRL);\n\tsprd_wdt_lock(wdt->base);\n\treturn 0;\n}\n\nstatic int sprd_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\tu32 timeout)\n{\n\tstruct sprd_wdt *wdt = to_sprd_wdt(wdd);\n\n\tif (timeout == wdd->timeout)\n\t\treturn 0;\n\n\twdd->timeout = timeout;\n\n\treturn sprd_wdt_load_value(wdt, timeout, wdd->pretimeout);\n}\n\nstatic int sprd_wdt_set_pretimeout(struct watchdog_device *wdd,\n\t\t\t\t   u32 new_pretimeout)\n{\n\tstruct sprd_wdt *wdt = to_sprd_wdt(wdd);\n\n\tif (new_pretimeout < wdd->min_timeout)\n\t\treturn -EINVAL;\n\n\twdd->pretimeout = new_pretimeout;\n\n\treturn sprd_wdt_load_value(wdt, wdd->timeout, new_pretimeout);\n}\n\nstatic u32 sprd_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct sprd_wdt *wdt = to_sprd_wdt(wdd);\n\tu32 val;\n\n\tval = sprd_wdt_get_cnt_value(wdt);\n\treturn val / SPRD_WDT_CNT_STEP;\n}\n\nstatic const struct watchdog_ops sprd_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = sprd_wdt_start,\n\t.stop = sprd_wdt_stop,\n\t.set_timeout = sprd_wdt_set_timeout,\n\t.set_pretimeout = sprd_wdt_set_pretimeout,\n\t.get_timeleft = sprd_wdt_get_timeleft,\n};\n\nstatic const struct watchdog_info sprd_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT |\n\t\t   WDIOF_PRETIMEOUT |\n\t\t   WDIOF_MAGICCLOSE |\n\t\t   WDIOF_KEEPALIVEPING,\n\t.identity = \"Spreadtrum Watchdog Timer\",\n};\n\nstatic int sprd_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sprd_wdt *wdt;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\twdt->enable = devm_clk_get(dev, \"enable\");\n\tif (IS_ERR(wdt->enable)) {\n\t\tdev_err(dev, \"can't get the enable clock\\n\");\n\t\treturn PTR_ERR(wdt->enable);\n\t}\n\n\twdt->rtc_enable = devm_clk_get(dev, \"rtc_enable\");\n\tif (IS_ERR(wdt->rtc_enable)) {\n\t\tdev_err(dev, \"can't get the rtc enable clock\\n\");\n\t\treturn PTR_ERR(wdt->rtc_enable);\n\t}\n\n\twdt->irq = platform_get_irq(pdev, 0);\n\tif (wdt->irq < 0)\n\t\treturn wdt->irq;\n\n\tret = devm_request_irq(dev, wdt->irq, sprd_wdt_isr, IRQF_NO_SUSPEND,\n\t\t\t       \"sprd-wdt\", (void *)wdt);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register irq\\n\");\n\t\treturn ret;\n\t}\n\n\twdt->wdd.info = &sprd_wdt_info;\n\twdt->wdd.ops = &sprd_wdt_ops;\n\twdt->wdd.parent = dev;\n\twdt->wdd.min_timeout = SPRD_WDT_MIN_TIMEOUT;\n\twdt->wdd.max_timeout = SPRD_WDT_MAX_TIMEOUT;\n\twdt->wdd.timeout = SPRD_WDT_MAX_TIMEOUT;\n\n\tret = sprd_wdt_enable(wdt);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable wdt\\n\");\n\t\treturn ret;\n\t}\n\tret = devm_add_action_or_reset(dev, sprd_wdt_disable, wdt);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add wdt disable action\\n\");\n\t\treturn ret;\n\t}\n\n\twatchdog_set_nowayout(&wdt->wdd, WATCHDOG_NOWAYOUT);\n\twatchdog_init_timeout(&wdt->wdd, 0, dev);\n\n\tret = devm_watchdog_register_device(dev, &wdt->wdd);\n\tif (ret) {\n\t\tsprd_wdt_disable(wdt);\n\t\treturn ret;\n\t}\n\tplatform_set_drvdata(pdev, wdt);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sprd_wdt_pm_suspend(struct device *dev)\n{\n\tstruct sprd_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\tsprd_wdt_stop(&wdt->wdd);\n\tsprd_wdt_disable(wdt);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sprd_wdt_pm_resume(struct device *dev)\n{\n\tstruct sprd_wdt *wdt = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = sprd_wdt_enable(wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (watchdog_active(&wdt->wdd))\n\t\tret = sprd_wdt_start(&wdt->wdd);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops sprd_wdt_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sprd_wdt_pm_suspend,\n\t\t\t\tsprd_wdt_pm_resume)\n};\n\nstatic const struct of_device_id sprd_wdt_match_table[] = {\n\t{ .compatible = \"sprd,sp9860-wdt\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sprd_wdt_match_table);\n\nstatic struct platform_driver sprd_watchdog_driver = {\n\t.probe\t= sprd_wdt_probe,\n\t.driver\t= {\n\t\t.name = \"sprd-wdt\",\n\t\t.of_match_table = sprd_wdt_match_table,\n\t\t.pm = &sprd_wdt_pm_ops,\n\t},\n};\nmodule_platform_driver(sprd_watchdog_driver);\n\nMODULE_AUTHOR(\"Eric Long <eric.long@spreadtrum.com>\");\nMODULE_DESCRIPTION(\"Spreadtrum Watchdog Timer Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}