{
  "module_name": "msc313e_wdt.c",
  "hash_id": "e1c6f72a51c910b7411b7e96241de657b7140d6f863c576652e81a7cb95edb15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/msc313e_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define REG_WDT_CLR\t\t\t0x0\n#define REG_WDT_MAX_PRD_L\t\t0x10\n#define REG_WDT_MAX_PRD_H\t\t0x14\n\n#define MSC313E_WDT_MIN_TIMEOUT\t\t1\n#define MSC313E_WDT_DEFAULT_TIMEOUT\t30\n\nstatic unsigned int timeout;\n\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds\");\n\nstruct msc313e_wdt_priv {\n\tvoid __iomem *base;\n\tstruct watchdog_device wdev;\n\tstruct clk *clk;\n};\n\nstatic int msc313e_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct msc313e_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu32 timeout;\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\ttimeout = wdev->timeout * clk_get_rate(priv->clk);\n\twritew(timeout & 0xffff, priv->base + REG_WDT_MAX_PRD_L);\n\twritew((timeout >> 16) & 0xffff, priv->base + REG_WDT_MAX_PRD_H);\n\twritew(1, priv->base + REG_WDT_CLR);\n\treturn 0;\n}\n\nstatic int msc313e_wdt_ping(struct watchdog_device *wdev)\n{\n\tstruct msc313e_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\twritew(1, priv->base + REG_WDT_CLR);\n\treturn 0;\n}\n\nstatic int msc313e_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct msc313e_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\twritew(0, priv->base + REG_WDT_MAX_PRD_L);\n\twritew(0, priv->base + REG_WDT_MAX_PRD_H);\n\twritew(0, priv->base + REG_WDT_CLR);\n\tclk_disable_unprepare(priv->clk);\n\treturn 0;\n}\n\nstatic int msc313e_wdt_settimeout(struct watchdog_device *wdev, unsigned int new_time)\n{\n\twdev->timeout = new_time;\n\n\treturn msc313e_wdt_start(wdev);\n}\n\nstatic const struct watchdog_info msc313e_wdt_ident = {\n\t.identity = \"MSC313e watchdog\",\n\t.options = WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT,\n};\n\nstatic const struct watchdog_ops msc313e_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = msc313e_wdt_start,\n\t.stop = msc313e_wdt_stop,\n\t.ping = msc313e_wdt_ping,\n\t.set_timeout = msc313e_wdt_settimeout,\n};\n\nstatic const struct of_device_id msc313e_wdt_of_match[] = {\n\t{ .compatible = \"mstar,msc313e-wdt\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, msc313e_wdt_of_match);\n\nstatic int msc313e_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct msc313e_wdt_priv *priv;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"No input clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tpriv->wdev.info = &msc313e_wdt_ident,\n\tpriv->wdev.ops = &msc313e_wdt_ops,\n\tpriv->wdev.parent = dev;\n\tpriv->wdev.min_timeout = MSC313E_WDT_MIN_TIMEOUT;\n\tpriv->wdev.max_timeout = U32_MAX / clk_get_rate(priv->clk);\n\tpriv->wdev.timeout = MSC313E_WDT_DEFAULT_TIMEOUT;\n\n\t \n\tif (readw(priv->base + REG_WDT_MAX_PRD_L) | (readw(priv->base + REG_WDT_MAX_PRD_H) << 16))\n\t\tset_bit(WDOG_HW_RUNNING, &priv->wdev.status);\n\n\twatchdog_set_drvdata(&priv->wdev, priv);\n\n\twatchdog_init_timeout(&priv->wdev, timeout, dev);\n\twatchdog_stop_on_reboot(&priv->wdev);\n\twatchdog_stop_on_unregister(&priv->wdev);\n\n\treturn devm_watchdog_register_device(dev, &priv->wdev);\n}\n\nstatic int __maybe_unused msc313e_wdt_suspend(struct device *dev)\n{\n\tstruct msc313e_wdt_priv *priv = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&priv->wdev))\n\t\tmsc313e_wdt_stop(&priv->wdev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused msc313e_wdt_resume(struct device *dev)\n{\n\tstruct msc313e_wdt_priv *priv = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&priv->wdev))\n\t\tmsc313e_wdt_start(&priv->wdev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(msc313e_wdt_pm_ops, msc313e_wdt_suspend, msc313e_wdt_resume);\n\nstatic struct platform_driver msc313e_wdt_driver = {\n\t.driver = {\n\t\t.name = \"msc313e-wdt\",\n\t\t.of_match_table = msc313e_wdt_of_match,\n\t\t.pm = &msc313e_wdt_pm_ops,\n\t},\n\t.probe = msc313e_wdt_probe,\n};\nmodule_platform_driver(msc313e_wdt_driver);\n\nMODULE_AUTHOR(\"Daniel Palmer <daniel@thingy.jp>\");\nMODULE_DESCRIPTION(\"Watchdog driver for MStar MSC313e\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}