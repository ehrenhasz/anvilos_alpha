{
  "module_name": "gxp-wdt.c",
  "hash_id": "342442158166034d0305e68990d71297aa37c236c37dfe18f0b1132dce425fd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/gxp-wdt.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#define MASK_WDGCS_ENABLE\t0x01\n#define MASK_WDGCS_RELOAD\t0x04\n#define MASK_WDGCS_NMIEN\t0x08\n#define MASK_WDGCS_WARN\t\t0x80\n\n#define WDT_MAX_TIMEOUT_MS\t655350\n#define WDT_DEFAULT_TIMEOUT\t30\n#define SECS_TO_WDOG_TICKS(x) ((x) * 100)\n#define WDOG_TICKS_TO_SECS(x) ((x) / 100)\n\n#define GXP_WDT_CNT_OFS\t\t0x10\n#define GXP_WDT_CTRL_OFS\t0x16\n\nstruct gxp_wdt {\n\tvoid __iomem *base;\n\tstruct watchdog_device wdd;\n};\n\nstatic void gxp_wdt_enable_reload(struct gxp_wdt *drvdata)\n{\n\tu8 val;\n\n\tval = readb(drvdata->base + GXP_WDT_CTRL_OFS);\n\tval |= (MASK_WDGCS_ENABLE | MASK_WDGCS_RELOAD);\n\twriteb(val, drvdata->base + GXP_WDT_CTRL_OFS);\n}\n\nstatic int gxp_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct gxp_wdt *drvdata = watchdog_get_drvdata(wdd);\n\n\twritew(SECS_TO_WDOG_TICKS(wdd->timeout), drvdata->base + GXP_WDT_CNT_OFS);\n\tgxp_wdt_enable_reload(drvdata);\n\treturn 0;\n}\n\nstatic int gxp_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct gxp_wdt *drvdata = watchdog_get_drvdata(wdd);\n\tu8 val;\n\n\tval = readb_relaxed(drvdata->base + GXP_WDT_CTRL_OFS);\n\tval &= ~MASK_WDGCS_ENABLE;\n\twriteb(val, drvdata->base + GXP_WDT_CTRL_OFS);\n\treturn 0;\n}\n\nstatic int gxp_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t       unsigned int timeout)\n{\n\tstruct gxp_wdt *drvdata = watchdog_get_drvdata(wdd);\n\tu32 actual;\n\n\twdd->timeout = timeout;\n\tactual = min(timeout * 100, wdd->max_hw_heartbeat_ms / 10);\n\twritew(actual, drvdata->base + GXP_WDT_CNT_OFS);\n\n\treturn 0;\n}\n\nstatic unsigned int gxp_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct gxp_wdt *drvdata = watchdog_get_drvdata(wdd);\n\tu32 val = readw(drvdata->base + GXP_WDT_CNT_OFS);\n\n\treturn WDOG_TICKS_TO_SECS(val);\n}\n\nstatic int gxp_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct gxp_wdt *drvdata = watchdog_get_drvdata(wdd);\n\n\tgxp_wdt_enable_reload(drvdata);\n\treturn 0;\n}\n\nstatic int gxp_restart(struct watchdog_device *wdd, unsigned long action,\n\t\t       void *data)\n{\n\tstruct gxp_wdt *drvdata = watchdog_get_drvdata(wdd);\n\n\twritew(1, drvdata->base + GXP_WDT_CNT_OFS);\n\tgxp_wdt_enable_reload(drvdata);\n\tmdelay(100);\n\treturn 0;\n}\n\nstatic const struct watchdog_ops gxp_wdt_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.start =\tgxp_wdt_start,\n\t.stop =\t\tgxp_wdt_stop,\n\t.ping =\t\tgxp_wdt_ping,\n\t.set_timeout =\tgxp_wdt_set_timeout,\n\t.get_timeleft =\tgxp_wdt_get_timeleft,\n\t.restart =\tgxp_restart,\n};\n\nstatic const struct watchdog_info gxp_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"HPE GXP Watchdog timer\",\n};\n\nstatic int gxp_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gxp_wdt *drvdata;\n\tint err;\n\tu8 val;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(struct gxp_wdt), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\t \n\n\tdrvdata->base = (void __iomem *)dev->platform_data;\n\n\tdrvdata->wdd.info = &gxp_wdt_info;\n\tdrvdata->wdd.ops = &gxp_wdt_ops;\n\tdrvdata->wdd.max_hw_heartbeat_ms = WDT_MAX_TIMEOUT_MS;\n\tdrvdata->wdd.parent = dev;\n\tdrvdata->wdd.timeout = WDT_DEFAULT_TIMEOUT;\n\n\twatchdog_set_drvdata(&drvdata->wdd, drvdata);\n\twatchdog_set_nowayout(&drvdata->wdd, WATCHDOG_NOWAYOUT);\n\n\tval = readb(drvdata->base + GXP_WDT_CTRL_OFS);\n\n\tif (val & MASK_WDGCS_ENABLE)\n\t\tset_bit(WDOG_HW_RUNNING, &drvdata->wdd.status);\n\n\twatchdog_set_restart_priority(&drvdata->wdd, 128);\n\n\twatchdog_stop_on_reboot(&drvdata->wdd);\n\terr = devm_watchdog_register_device(dev, &drvdata->wdd);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register watchdog device\");\n\t\treturn err;\n\t}\n\n\tdev_info(dev, \"HPE GXP watchdog timer\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver gxp_wdt_driver = {\n\t.probe = gxp_wdt_probe,\n\t.driver = {\n\t\t.name =\t\"gxp-wdt\",\n\t},\n};\nmodule_platform_driver(gxp_wdt_driver);\n\nMODULE_AUTHOR(\"Nick Hawkins <nick.hawkins@hpe.com>\");\nMODULE_AUTHOR(\"Jean-Marie Verdun <verdun@hpe.com>\");\nMODULE_DESCRIPTION(\"Driver for GXP watchdog timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}