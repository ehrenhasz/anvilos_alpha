{
  "module_name": "scx200_wdt.c",
  "hash_id": "f8ac2c67f0cb8df7a68f3f4a70ba74fc1c007730eb82fc0d5a9ff18f4a51ef35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/scx200_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/scx200.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#define DEBUG\n\nMODULE_AUTHOR(\"Christer Weinigel <wingel@nano-system.com>\");\nMODULE_DESCRIPTION(\"NatSemi SCx200 Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int margin = 60;\t\t \nmodule_param(margin, int, 0);\nMODULE_PARM_DESC(margin, \"Watchdog margin in seconds\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Disable watchdog shutdown on close\");\n\nstatic u16 wdto_restart;\nstatic char expect_close;\nstatic unsigned long open_lock;\nstatic DEFINE_SPINLOCK(scx_lock);\n\n \n#define W_ENABLE 0x00fa\t\t \n#define W_DISABLE 0x0000\t \n\n \n#define W_SCALE (32768/1024)\n\nstatic void scx200_wdt_ping(void)\n{\n\tspin_lock(&scx_lock);\n\toutw(wdto_restart, scx200_cb_base + SCx200_WDT_WDTO);\n\tspin_unlock(&scx_lock);\n}\n\nstatic void scx200_wdt_update_margin(void)\n{\n\tpr_info(\"timer margin %d seconds\\n\", margin);\n\twdto_restart = margin * W_SCALE;\n}\n\nstatic void scx200_wdt_enable(void)\n{\n\tpr_debug(\"enabling watchdog timer, wdto_restart = %d\\n\", wdto_restart);\n\n\tspin_lock(&scx_lock);\n\toutw(0, scx200_cb_base + SCx200_WDT_WDTO);\n\toutb(SCx200_WDT_WDSTS_WDOVF, scx200_cb_base + SCx200_WDT_WDSTS);\n\toutw(W_ENABLE, scx200_cb_base + SCx200_WDT_WDCNFG);\n\tspin_unlock(&scx_lock);\n\n\tscx200_wdt_ping();\n}\n\nstatic void scx200_wdt_disable(void)\n{\n\tpr_debug(\"disabling watchdog timer\\n\");\n\n\tspin_lock(&scx_lock);\n\toutw(0, scx200_cb_base + SCx200_WDT_WDTO);\n\toutb(SCx200_WDT_WDSTS_WDOVF, scx200_cb_base + SCx200_WDT_WDSTS);\n\toutw(W_DISABLE, scx200_cb_base + SCx200_WDT_WDCNFG);\n\tspin_unlock(&scx_lock);\n}\n\nstatic int scx200_wdt_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &open_lock))\n\t\treturn -EBUSY;\n\tscx200_wdt_enable();\n\n\treturn stream_open(inode, file);\n}\n\nstatic int scx200_wdt_release(struct inode *inode, struct file *file)\n{\n\tif (expect_close != 42)\n\t\tpr_warn(\"watchdog device closed unexpectedly, will not disable the watchdog timer\\n\");\n\telse if (!nowayout)\n\t\tscx200_wdt_disable();\n\texpect_close = 0;\n\tclear_bit(0, &open_lock);\n\n\treturn 0;\n}\n\nstatic int scx200_wdt_notify_sys(struct notifier_block *this,\n\t\t\t\t      unsigned long code, void *unused)\n{\n\tif (code == SYS_HALT || code == SYS_POWER_OFF)\n\t\tif (!nowayout)\n\t\t\tscx200_wdt_disable();\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block scx200_wdt_notifier = {\n\t.notifier_call = scx200_wdt_notify_sys,\n};\n\nstatic ssize_t scx200_wdt_write(struct file *file, const char __user *data,\n\t\t\t\t     size_t len, loff_t *ppos)\n{\n\t \n\tif (len) {\n\t\tsize_t i;\n\n\t\tscx200_wdt_ping();\n\n\t\texpect_close = 0;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tchar c;\n\t\t\tif (get_user(c, data + i))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (c == 'V')\n\t\t\t\texpect_close = 42;\n\t\t}\n\n\t\treturn len;\n\t}\n\n\treturn 0;\n}\n\nstatic long scx200_wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.identity = \"NatSemi SCx200 Watchdog\",\n\t\t.firmware_version = 1,\n\t\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t};\n\tint new_margin;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tif (put_user(0, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase WDIOC_KEEPALIVE:\n\t\tscx200_wdt_ping();\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_margin, p))\n\t\t\treturn -EFAULT;\n\t\tif (new_margin < 1)\n\t\t\treturn -EINVAL;\n\t\tmargin = new_margin;\n\t\tscx200_wdt_update_margin();\n\t\tscx200_wdt_ping();\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\tif (put_user(margin, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic const struct file_operations scx200_wdt_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.write = scx200_wdt_write,\n\t.unlocked_ioctl = scx200_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open = scx200_wdt_open,\n\t.release = scx200_wdt_release,\n};\n\nstatic struct miscdevice scx200_wdt_miscdev = {\n\t.minor = WATCHDOG_MINOR,\n\t.name = \"watchdog\",\n\t.fops = &scx200_wdt_fops,\n};\n\nstatic int __init scx200_wdt_init(void)\n{\n\tint r;\n\n\tpr_debug(\"NatSemi SCx200 Watchdog Driver\\n\");\n\n\t \n\tif (!scx200_cb_present())\n\t\treturn -ENODEV;\n\n\tif (!request_region(scx200_cb_base + SCx200_WDT_OFFSET,\n\t\t\t    SCx200_WDT_SIZE,\n\t\t\t    \"NatSemi SCx200 Watchdog\")) {\n\t\tpr_warn(\"watchdog I/O region busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tscx200_wdt_update_margin();\n\tscx200_wdt_disable();\n\n\tr = register_reboot_notifier(&scx200_wdt_notifier);\n\tif (r) {\n\t\tpr_err(\"unable to register reboot notifier\\n\");\n\t\trelease_region(scx200_cb_base + SCx200_WDT_OFFSET,\n\t\t\t\tSCx200_WDT_SIZE);\n\t\treturn r;\n\t}\n\n\tr = misc_register(&scx200_wdt_miscdev);\n\tif (r) {\n\t\tunregister_reboot_notifier(&scx200_wdt_notifier);\n\t\trelease_region(scx200_cb_base + SCx200_WDT_OFFSET,\n\t\t\t\tSCx200_WDT_SIZE);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit scx200_wdt_cleanup(void)\n{\n\tmisc_deregister(&scx200_wdt_miscdev);\n\tunregister_reboot_notifier(&scx200_wdt_notifier);\n\trelease_region(scx200_cb_base + SCx200_WDT_OFFSET,\n\t\t       SCx200_WDT_SIZE);\n}\n\nmodule_init(scx200_wdt_init);\nmodule_exit(scx200_wdt_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}