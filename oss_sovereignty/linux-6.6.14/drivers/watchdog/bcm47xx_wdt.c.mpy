{
  "module_name": "bcm47xx_wdt.c",
  "hash_id": "718f6948f6872deb76ed60db039c7354bc2661a097691b7aad562a73fa36ebb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/bcm47xx_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bcm47xx_wdt.h>\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n\n#define DRV_NAME\t\t\"bcm47xx_wdt\"\n\n#define WDT_DEFAULT_TIME\t30\t \n#define WDT_SOFTTIMER_MAX\t255\t \n#define WDT_SOFTTIMER_THRESHOLD\t60\t \n\nstatic int timeout = WDT_DEFAULT_TIME;\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog time in seconds. (default=\"\n\t\t\t\t__MODULE_STRING(WDT_DEFAULT_TIME) \")\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic inline struct bcm47xx_wdt *bcm47xx_wdt_get(struct watchdog_device *wdd)\n{\n\treturn container_of(wdd, struct bcm47xx_wdt, wdd);\n}\n\nstatic int bcm47xx_wdt_hard_keepalive(struct watchdog_device *wdd)\n{\n\tstruct bcm47xx_wdt *wdt = bcm47xx_wdt_get(wdd);\n\n\twdt->timer_set_ms(wdt, wdd->timeout * 1000);\n\n\treturn 0;\n}\n\nstatic int bcm47xx_wdt_hard_start(struct watchdog_device *wdd)\n{\n\treturn 0;\n}\n\nstatic int bcm47xx_wdt_hard_stop(struct watchdog_device *wdd)\n{\n\tstruct bcm47xx_wdt *wdt = bcm47xx_wdt_get(wdd);\n\n\twdt->timer_set(wdt, 0);\n\n\treturn 0;\n}\n\nstatic int bcm47xx_wdt_hard_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t\tunsigned int new_time)\n{\n\tstruct bcm47xx_wdt *wdt = bcm47xx_wdt_get(wdd);\n\tu32 max_timer = wdt->max_timer_ms;\n\n\tif (new_time < 1 || new_time > max_timer / 1000) {\n\t\tpr_warn(\"timeout value must be 1<=x<=%d, using %d\\n\",\n\t\t\tmax_timer / 1000, new_time);\n\t\treturn -EINVAL;\n\t}\n\n\twdd->timeout = new_time;\n\treturn 0;\n}\n\nstatic int bcm47xx_wdt_restart(struct watchdog_device *wdd,\n\t\t\t       unsigned long action, void *data)\n{\n\tstruct bcm47xx_wdt *wdt = bcm47xx_wdt_get(wdd);\n\n\twdt->timer_set(wdt, 1);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops bcm47xx_wdt_hard_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= bcm47xx_wdt_hard_start,\n\t.stop\t\t= bcm47xx_wdt_hard_stop,\n\t.ping\t\t= bcm47xx_wdt_hard_keepalive,\n\t.set_timeout\t= bcm47xx_wdt_hard_set_timeout,\n\t.restart        = bcm47xx_wdt_restart,\n};\n\nstatic void bcm47xx_wdt_soft_timer_tick(struct timer_list *t)\n{\n\tstruct bcm47xx_wdt *wdt = from_timer(wdt, t, soft_timer);\n\tu32 next_tick = min(wdt->wdd.timeout * 1000, wdt->max_timer_ms);\n\n\tif (!atomic_dec_and_test(&wdt->soft_ticks)) {\n\t\twdt->timer_set_ms(wdt, next_tick);\n\t\tmod_timer(&wdt->soft_timer, jiffies + HZ);\n\t} else {\n\t\tpr_crit(\"Watchdog will fire soon!!!\\n\");\n\t}\n}\n\nstatic int bcm47xx_wdt_soft_keepalive(struct watchdog_device *wdd)\n{\n\tstruct bcm47xx_wdt *wdt = bcm47xx_wdt_get(wdd);\n\n\tatomic_set(&wdt->soft_ticks, wdd->timeout);\n\n\treturn 0;\n}\n\nstatic int bcm47xx_wdt_soft_start(struct watchdog_device *wdd)\n{\n\tstruct bcm47xx_wdt *wdt = bcm47xx_wdt_get(wdd);\n\n\tbcm47xx_wdt_soft_keepalive(wdd);\n\tbcm47xx_wdt_soft_timer_tick(&wdt->soft_timer);\n\n\treturn 0;\n}\n\nstatic int bcm47xx_wdt_soft_stop(struct watchdog_device *wdd)\n{\n\tstruct bcm47xx_wdt *wdt = bcm47xx_wdt_get(wdd);\n\n\tdel_timer_sync(&wdt->soft_timer);\n\twdt->timer_set(wdt, 0);\n\n\treturn 0;\n}\n\nstatic int bcm47xx_wdt_soft_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t\tunsigned int new_time)\n{\n\tif (new_time < 1 || new_time > WDT_SOFTTIMER_MAX) {\n\t\tpr_warn(\"timeout value must be 1<=x<=%d, using %d\\n\",\n\t\t\tWDT_SOFTTIMER_MAX, new_time);\n\t\treturn -EINVAL;\n\t}\n\n\twdd->timeout = new_time;\n\treturn 0;\n}\n\nstatic const struct watchdog_info bcm47xx_wdt_info = {\n\t.identity\t= DRV_NAME,\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\tWDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops bcm47xx_wdt_soft_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= bcm47xx_wdt_soft_start,\n\t.stop\t\t= bcm47xx_wdt_soft_stop,\n\t.ping\t\t= bcm47xx_wdt_soft_keepalive,\n\t.set_timeout\t= bcm47xx_wdt_soft_set_timeout,\n\t.restart        = bcm47xx_wdt_restart,\n};\n\nstatic int bcm47xx_wdt_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tbool soft;\n\tstruct bcm47xx_wdt *wdt = dev_get_platdata(&pdev->dev);\n\n\tif (!wdt)\n\t\treturn -ENXIO;\n\n\tsoft = wdt->max_timer_ms < WDT_SOFTTIMER_THRESHOLD * 1000;\n\n\tif (soft) {\n\t\twdt->wdd.ops = &bcm47xx_wdt_soft_ops;\n\t\ttimer_setup(&wdt->soft_timer, bcm47xx_wdt_soft_timer_tick, 0);\n\t} else {\n\t\twdt->wdd.ops = &bcm47xx_wdt_hard_ops;\n\t}\n\n\twdt->wdd.info = &bcm47xx_wdt_info;\n\twdt->wdd.timeout = WDT_DEFAULT_TIME;\n\twdt->wdd.parent = &pdev->dev;\n\tret = wdt->wdd.ops->set_timeout(&wdt->wdd, timeout);\n\tif (ret)\n\t\tgoto err_timer;\n\twatchdog_set_nowayout(&wdt->wdd, nowayout);\n\twatchdog_set_restart_priority(&wdt->wdd, 64);\n\twatchdog_stop_on_reboot(&wdt->wdd);\n\n\tret = devm_watchdog_register_device(&pdev->dev, &wdt->wdd);\n\tif (ret)\n\t\tgoto err_timer;\n\n\tdev_info(&pdev->dev, \"BCM47xx Watchdog Timer enabled (%d seconds%s%s)\\n\",\n\t\ttimeout, nowayout ? \", nowayout\" : \"\",\n\t\tsoft ? \", Software Timer\" : \"\");\n\treturn 0;\n\nerr_timer:\n\tif (soft)\n\t\tdel_timer_sync(&wdt->soft_timer);\n\n\treturn ret;\n}\n\nstatic struct platform_driver bcm47xx_wdt_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"bcm47xx-wdt\",\n\t},\n\t.probe\t\t= bcm47xx_wdt_probe,\n};\n\nmodule_platform_driver(bcm47xx_wdt_driver);\n\nMODULE_AUTHOR(\"Aleksandar Radovanovic\");\nMODULE_AUTHOR(\"Hauke Mehrtens <hauke@hauke-m.de>\");\nMODULE_DESCRIPTION(\"Watchdog driver for Broadcom BCM47xx\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}