{
  "module_name": "pcwd_usb.c",
  "hash_id": "217f4d8c6203c3cf8fc260e0a8a4bc4b4813d1cad8eb16932d6faf64fe6f4a3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pcwd_usb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\t \n#include <linux/moduleparam.h>\t \n#include <linux/types.h>\t \n#include <linux/errno.h>\t \n#include <linux/kernel.h>\t \n#include <linux/delay.h>\t \n#include <linux/miscdevice.h>\t \n#include <linux/watchdog.h>\t \n#include <linux/notifier.h>\t \n#include <linux/reboot.h>\t \n#include <linux/init.h>\t\t \n#include <linux/fs.h>\t\t \n#include <linux/usb.h>\t\t \n#include <linux/slab.h>\t\t \n#include <linux/mutex.h>\t \n#include <linux/hid.h>\t\t \n#include <linux/uaccess.h>\t \n\n\n \n#define DRIVER_VERSION \"1.02\"\n#define DRIVER_AUTHOR \"Wim Van Sebroeck <wim@iguana.be>\"\n#define DRIVER_DESC \"Berkshire USB-PC Watchdog driver\"\n#define DRIVER_NAME \"pcwd_usb\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define WATCHDOG_HEARTBEAT 0\t \nstatic int heartbeat = WATCHDOG_HEARTBEAT;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeat in seconds. \"\n\t\"(0<heartbeat<65536 or 0=delay-time from dip-switches, default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_HEARTBEAT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n#define USB_PCWD_VENDOR_ID\t0x0c98\n#define USB_PCWD_PRODUCT_ID\t0x1140\n\n \nstatic const struct usb_device_id usb_pcwd_table[] = {\n\t{ USB_DEVICE(USB_PCWD_VENDOR_ID, USB_PCWD_PRODUCT_ID) },\n\t{ }\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, usb_pcwd_table);\n\n \n#define USB_COMMAND_TIMEOUT\t250\n\n \n#define CMD_READ_TEMP\t\t\t0x02\t \n#define CMD_TRIGGER\t\t\tCMD_READ_TEMP\n#define CMD_GET_STATUS\t\t\t0x04\t \n#define CMD_GET_FIRMWARE_VERSION\t0x08\t \n#define CMD_GET_DIP_SWITCH_SETTINGS\t0x0c\t \n#define CMD_READ_WATCHDOG_TIMEOUT\t0x18\t \n#define CMD_WRITE_WATCHDOG_TIMEOUT\t0x19\t \n#define CMD_ENABLE_WATCHDOG\t\t0x30\t \n#define CMD_DISABLE_WATCHDOG\t\tCMD_ENABLE_WATCHDOG\n\n \nstatic const int heartbeat_tbl[] = {\n\t5,\t \n\t10,\t \n\t30,\t \n\t60,\t \n\t300,\t \n\t600,\t \n\t1800,\t \n\t3600,\t \n};\n\n \nstatic int cards_found;\n\n \nstatic unsigned long is_active;\nstatic char expect_release;\n\n \nstruct usb_pcwd_private {\n\t \n\tstruct usb_device\t*udev;\n\t \n\tstruct usb_interface\t*interface;\n\n\t \n\tunsigned int\t\tinterface_number;\n\n\t \n\tunsigned char\t\t*intr_buffer;\n\t \n\tdma_addr_t\t\tintr_dma;\n\t \n\tsize_t\t\t\tintr_size;\n\t \n\tstruct urb\t\t*intr_urb;\n\n\t \n\tunsigned char\t\tcmd_command;\n\t \n\tunsigned char\t\tcmd_data_msb;\n\t \n\tunsigned char\t\tcmd_data_lsb;\n\t \n\tatomic_t\t\tcmd_received;\n\n\t \n\tint\t\t\texists;\n\t \n\tstruct mutex\t\tmtx;\n};\nstatic struct usb_pcwd_private *usb_pcwd_device;\n\n \nstatic DEFINE_MUTEX(disconnect_mutex);\n\n \nstatic int usb_pcwd_probe(struct usb_interface *interface,\n\t\t\t\t\t\tconst struct usb_device_id *id);\nstatic void usb_pcwd_disconnect(struct usb_interface *interface);\n\n \nstatic struct usb_driver usb_pcwd_driver = {\n\t.name =\t\tDRIVER_NAME,\n\t.probe =\tusb_pcwd_probe,\n\t.disconnect =\tusb_pcwd_disconnect,\n\t.id_table =\tusb_pcwd_table,\n};\n\n\nstatic void usb_pcwd_intr_done(struct urb *urb)\n{\n\tstruct usb_pcwd_private *usb_pcwd =\n\t\t\t\t(struct usb_pcwd_private *)urb->context;\n\tunsigned char *data = usb_pcwd->intr_buffer;\n\tstruct device *dev = &usb_pcwd->interface->dev;\n\tint retval;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\t \n\tdefault:\t\t \n\t\tdev_dbg(dev, \"%s - nonzero urb status received: %d\",\n\t\t\t__func__, urb->status);\n\t\tgoto resubmit;\n\t}\n\n\tdev_dbg(dev, \"received following data cmd=0x%02x msb=0x%02x lsb=0x%02x\",\n\t\tdata[0], data[1], data[2]);\n\n\tusb_pcwd->cmd_command  = data[0];\n\tusb_pcwd->cmd_data_msb = data[1];\n\tusb_pcwd->cmd_data_lsb = data[2];\n\n\t \n\tatomic_set(&usb_pcwd->cmd_received, 1);\n\nresubmit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tpr_err(\"can't resubmit intr, usb_submit_urb failed with result %d\\n\",\n\t\t       retval);\n}\n\nstatic int usb_pcwd_send_command(struct usb_pcwd_private *usb_pcwd,\n\t\tunsigned char cmd, unsigned char *msb, unsigned char *lsb)\n{\n\tint got_response, count;\n\tunsigned char *buf;\n\n\t \n\tif ((!usb_pcwd) || (!usb_pcwd->exists))\n\t\treturn -1;\n\n\tbuf = kmalloc(6, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn 0;\n\n\t \n\tbuf[0] = cmd;\t\t\t \n\tbuf[1] = *msb;\t\t\t \n\tbuf[2] = *lsb;\t\t\t \n\tbuf[3] = buf[4] = buf[5] = 0;\t \n\n\tdev_dbg(&usb_pcwd->interface->dev,\n\t\t\"sending following data cmd=0x%02x msb=0x%02x lsb=0x%02x\",\n\t\tbuf[0], buf[1], buf[2]);\n\n\tatomic_set(&usb_pcwd->cmd_received, 0);\n\n\tif (usb_control_msg(usb_pcwd->udev, usb_sndctrlpipe(usb_pcwd->udev, 0),\n\t\t\tHID_REQ_SET_REPORT, HID_DT_REPORT,\n\t\t\t0x0200, usb_pcwd->interface_number, buf, 6,\n\t\t\tUSB_COMMAND_TIMEOUT) != 6) {\n\t\tdev_dbg(&usb_pcwd->interface->dev,\n\t\t\t\"usb_pcwd_send_command: error in usb_control_msg for cmd 0x%x 0x%x 0x%x\\n\",\n\t\t\tcmd, *msb, *lsb);\n\t}\n\t \n\tgot_response = 0;\n\tfor (count = 0; (count < USB_COMMAND_TIMEOUT) && (!got_response);\n\t\t\t\t\t\t\t\tcount++) {\n\t\tmdelay(1);\n\t\tif (atomic_read(&usb_pcwd->cmd_received))\n\t\t\tgot_response = 1;\n\t}\n\n\tif ((got_response) && (cmd == usb_pcwd->cmd_command)) {\n\t\t \n\t\t*msb = usb_pcwd->cmd_data_msb;\n\t\t*lsb = usb_pcwd->cmd_data_lsb;\n\t}\n\n\tkfree(buf);\n\n\treturn got_response;\n}\n\nstatic int usb_pcwd_start(struct usb_pcwd_private *usb_pcwd)\n{\n\tunsigned char msb = 0x00;\n\tunsigned char lsb = 0x00;\n\tint retval;\n\n\t \n\tretval = usb_pcwd_send_command(usb_pcwd, CMD_ENABLE_WATCHDOG,\n\t\t\t\t\t\t\t\t&msb, &lsb);\n\n\tif ((retval == 0) || (lsb == 0)) {\n\t\tpr_err(\"Card did not acknowledge enable attempt\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int usb_pcwd_stop(struct usb_pcwd_private *usb_pcwd)\n{\n\tunsigned char msb = 0xA5;\n\tunsigned char lsb = 0xC3;\n\tint retval;\n\n\t \n\tretval = usb_pcwd_send_command(usb_pcwd, CMD_DISABLE_WATCHDOG,\n\t\t\t\t\t\t\t\t&msb, &lsb);\n\n\tif ((retval == 0) || (lsb != 0)) {\n\t\tpr_err(\"Card did not acknowledge disable attempt\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int usb_pcwd_keepalive(struct usb_pcwd_private *usb_pcwd)\n{\n\tunsigned char dummy;\n\n\t \n\tusb_pcwd_send_command(usb_pcwd, CMD_TRIGGER, &dummy, &dummy);\n\n\treturn 0;\n}\n\nstatic int usb_pcwd_set_heartbeat(struct usb_pcwd_private *usb_pcwd, int t)\n{\n\tunsigned char msb = t / 256;\n\tunsigned char lsb = t % 256;\n\n\tif ((t < 0x0001) || (t > 0xFFFF))\n\t\treturn -EINVAL;\n\n\t \n\tusb_pcwd_send_command(usb_pcwd, CMD_WRITE_WATCHDOG_TIMEOUT, &msb, &lsb);\n\n\theartbeat = t;\n\treturn 0;\n}\n\nstatic int usb_pcwd_get_temperature(struct usb_pcwd_private *usb_pcwd,\n\t\t\t\t\t\t\tint *temperature)\n{\n\tunsigned char msb = 0x00;\n\tunsigned char lsb = 0x00;\n\n\tusb_pcwd_send_command(usb_pcwd, CMD_READ_TEMP, &msb, &lsb);\n\n\t \n\t*temperature = (lsb * 9 / 5) + 32;\n\n\treturn 0;\n}\n\nstatic int usb_pcwd_get_timeleft(struct usb_pcwd_private *usb_pcwd,\n\t\t\t\t\t\t\t\tint *time_left)\n{\n\tunsigned char msb = 0x00;\n\tunsigned char lsb = 0x00;\n\n\t \n\t \n\tusb_pcwd_send_command(usb_pcwd, CMD_READ_WATCHDOG_TIMEOUT, &msb, &lsb);\n\n\t*time_left = (msb << 8) + lsb;\n\n\treturn 0;\n}\n\n \n\nstatic ssize_t usb_pcwd_write(struct file *file, const char __user *data,\n\t\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\t \n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_release = 0;\n\n\t\t\t \n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_release = 42;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tusb_pcwd_keepalive(usb_pcwd_device);\n\t}\n\treturn len;\n}\n\nstatic long usb_pcwd_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\t\tWDIOF_SETTIMEOUT |\n\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.firmware_version =\t1,\n\t\t.identity =\t\tDRIVER_NAME,\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\n\tcase WDIOC_GETTEMP:\n\t{\n\t\tint temperature;\n\n\t\tif (usb_pcwd_get_temperature(usb_pcwd_device, &temperature))\n\t\t\treturn -EFAULT;\n\n\t\treturn put_user(temperature, p);\n\t}\n\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint new_options, retval = -EINVAL;\n\n\t\tif (get_user(new_options, p))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_options & WDIOS_DISABLECARD) {\n\t\t\tusb_pcwd_stop(usb_pcwd_device);\n\t\t\tretval = 0;\n\t\t}\n\n\t\tif (new_options & WDIOS_ENABLECARD) {\n\t\t\tusb_pcwd_start(usb_pcwd_device);\n\t\t\tretval = 0;\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tcase WDIOC_KEEPALIVE:\n\t\tusb_pcwd_keepalive(usb_pcwd_device);\n\t\treturn 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t{\n\t\tint new_heartbeat;\n\n\t\tif (get_user(new_heartbeat, p))\n\t\t\treturn -EFAULT;\n\n\t\tif (usb_pcwd_set_heartbeat(usb_pcwd_device, new_heartbeat))\n\t\t\treturn -EINVAL;\n\n\t\tusb_pcwd_keepalive(usb_pcwd_device);\n\t}\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(heartbeat, p);\n\n\tcase WDIOC_GETTIMELEFT:\n\t{\n\t\tint time_left;\n\n\t\tif (usb_pcwd_get_timeleft(usb_pcwd_device, &time_left))\n\t\t\treturn -EFAULT;\n\n\t\treturn put_user(time_left, p);\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int usb_pcwd_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &is_active))\n\t\treturn -EBUSY;\n\n\t \n\tusb_pcwd_start(usb_pcwd_device);\n\tusb_pcwd_keepalive(usb_pcwd_device);\n\treturn stream_open(inode, file);\n}\n\nstatic int usb_pcwd_release(struct inode *inode, struct file *file)\n{\n\t \n\tif (expect_release == 42) {\n\t\tusb_pcwd_stop(usb_pcwd_device);\n\t} else {\n\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\tusb_pcwd_keepalive(usb_pcwd_device);\n\t}\n\texpect_release = 0;\n\tclear_bit(0, &is_active);\n\treturn 0;\n}\n\n \n\nstatic ssize_t usb_pcwd_temperature_read(struct file *file, char __user *data,\n\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tint temperature;\n\n\tif (usb_pcwd_get_temperature(usb_pcwd_device, &temperature))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(data, &temperature, 1))\n\t\treturn -EFAULT;\n\n\treturn 1;\n}\n\nstatic int usb_pcwd_temperature_open(struct inode *inode, struct file *file)\n{\n\treturn stream_open(inode, file);\n}\n\nstatic int usb_pcwd_temperature_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\n \n\nstatic int usb_pcwd_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t\t\t\t\t\tvoid *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\tusb_pcwd_stop(usb_pcwd_device);\t \n\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic const struct file_operations usb_pcwd_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.write =\tusb_pcwd_write,\n\t.unlocked_ioctl = usb_pcwd_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.open =\t\tusb_pcwd_open,\n\t.release =\tusb_pcwd_release,\n};\n\nstatic struct miscdevice usb_pcwd_miscdev = {\n\t.minor =\tWATCHDOG_MINOR,\n\t.name =\t\t\"watchdog\",\n\t.fops =\t\t&usb_pcwd_fops,\n};\n\nstatic const struct file_operations usb_pcwd_temperature_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.read =\t\tusb_pcwd_temperature_read,\n\t.open =\t\tusb_pcwd_temperature_open,\n\t.release =\tusb_pcwd_temperature_release,\n};\n\nstatic struct miscdevice usb_pcwd_temperature_miscdev = {\n\t.minor =\tTEMP_MINOR,\n\t.name =\t\t\"temperature\",\n\t.fops =\t\t&usb_pcwd_temperature_fops,\n};\n\nstatic struct notifier_block usb_pcwd_notifier = {\n\t.notifier_call =\tusb_pcwd_notify_sys,\n};\n\n \nstatic inline void usb_pcwd_delete(struct usb_pcwd_private *usb_pcwd)\n{\n\tusb_free_urb(usb_pcwd->intr_urb);\n\tusb_free_coherent(usb_pcwd->udev, usb_pcwd->intr_size,\n\t\t\t  usb_pcwd->intr_buffer, usb_pcwd->intr_dma);\n\tkfree(usb_pcwd);\n}\n\n \nstatic int usb_pcwd_probe(struct usb_interface *interface,\n\t\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_pcwd_private *usb_pcwd = NULL;\n\tint pipe;\n\tint retval = -ENOMEM;\n\tint got_fw_rev;\n\tunsigned char fw_rev_major, fw_rev_minor;\n\tchar fw_ver_str[20];\n\tunsigned char option_switches, dummy;\n\n\tcards_found++;\n\tif (cards_found > 1) {\n\t\tpr_err(\"This driver only supports 1 device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tiface_desc = interface->cur_altsetting;\n\n\t \n\tif (!(iface_desc->desc.bInterfaceClass == USB_CLASS_HID)) {\n\t\tpr_err(\"The device isn't a Human Interface Device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (iface_desc->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\t \n\tendpoint = &iface_desc->endpoint[0].desc;\n\n\tif (!usb_endpoint_is_int_in(endpoint)) {\n\t\t \n\t\tpr_err(\"Couldn't find an INTR & IN endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\n\n\t \n\tusb_pcwd = kzalloc(sizeof(struct usb_pcwd_private), GFP_KERNEL);\n\tif (usb_pcwd == NULL)\n\t\tgoto error;\n\n\tusb_pcwd_device = usb_pcwd;\n\n\tmutex_init(&usb_pcwd->mtx);\n\tusb_pcwd->udev = udev;\n\tusb_pcwd->interface = interface;\n\tusb_pcwd->interface_number = iface_desc->desc.bInterfaceNumber;\n\tusb_pcwd->intr_size = (le16_to_cpu(endpoint->wMaxPacketSize) > 8 ?\n\t\t\t\tle16_to_cpu(endpoint->wMaxPacketSize) : 8);\n\n\t \n\tusb_pcwd->intr_buffer = usb_alloc_coherent(udev, usb_pcwd->intr_size,\n\t\t\t\t\tGFP_KERNEL, &usb_pcwd->intr_dma);\n\tif (!usb_pcwd->intr_buffer) {\n\t\tpr_err(\"Out of memory\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tusb_pcwd->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!usb_pcwd->intr_urb)\n\t\tgoto error;\n\n\t \n\tusb_fill_int_urb(usb_pcwd->intr_urb, udev, pipe,\n\t\t\tusb_pcwd->intr_buffer, usb_pcwd->intr_size,\n\t\t\tusb_pcwd_intr_done, usb_pcwd, endpoint->bInterval);\n\tusb_pcwd->intr_urb->transfer_dma = usb_pcwd->intr_dma;\n\tusb_pcwd->intr_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t \n\tif (usb_submit_urb(usb_pcwd->intr_urb, GFP_KERNEL)) {\n\t\tpr_err(\"Problem registering interrupt URB\\n\");\n\t\tretval = -EIO;  \n\t\tgoto error;\n\t}\n\n\t \n\tusb_pcwd->exists = 1;\n\n\t \n\tusb_pcwd_stop(usb_pcwd);\n\n\t \n\tgot_fw_rev = usb_pcwd_send_command(usb_pcwd, CMD_GET_FIRMWARE_VERSION,\n\t\t\t\t\t\t&fw_rev_major, &fw_rev_minor);\n\tif (got_fw_rev)\n\t\tsprintf(fw_ver_str, \"%u.%02u\", fw_rev_major, fw_rev_minor);\n\telse\n\t\tsprintf(fw_ver_str, \"<card no answer>\");\n\n\tpr_info(\"Found card (Firmware: %s) with temp option\\n\", fw_ver_str);\n\n\t \n\tusb_pcwd_send_command(usb_pcwd, CMD_GET_DIP_SWITCH_SETTINGS, &dummy,\n\t\t\t\t\t\t\t&option_switches);\n\n\tpr_info(\"Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s\\n\",\n\t\toption_switches,\n\t\t((option_switches & 0x10) ? \"ON\" : \"OFF\"),\n\t\t((option_switches & 0x08) ? \"ON\" : \"OFF\"));\n\n\t \n\tif (heartbeat == 0)\n\t\theartbeat = heartbeat_tbl[(option_switches & 0x07)];\n\n\t \n\tif (usb_pcwd_set_heartbeat(usb_pcwd, heartbeat)) {\n\t\tusb_pcwd_set_heartbeat(usb_pcwd, WATCHDOG_HEARTBEAT);\n\t\tpr_info(\"heartbeat value must be 0<heartbeat<65536, using %d\\n\",\n\t\t\tWATCHDOG_HEARTBEAT);\n\t}\n\n\tretval = register_reboot_notifier(&usb_pcwd_notifier);\n\tif (retval != 0) {\n\t\tpr_err(\"cannot register reboot notifier (err=%d)\\n\", retval);\n\t\tgoto error;\n\t}\n\n\tretval = misc_register(&usb_pcwd_temperature_miscdev);\n\tif (retval != 0) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       TEMP_MINOR, retval);\n\t\tgoto err_out_unregister_reboot;\n\t}\n\n\tretval = misc_register(&usb_pcwd_miscdev);\n\tif (retval != 0) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, retval);\n\t\tgoto err_out_misc_deregister;\n\t}\n\n\t \n\tusb_set_intfdata(interface, usb_pcwd);\n\n\tpr_info(\"initialized. heartbeat=%d sec (nowayout=%d)\\n\",\n\t\theartbeat, nowayout);\n\n\treturn 0;\n\nerr_out_misc_deregister:\n\tmisc_deregister(&usb_pcwd_temperature_miscdev);\nerr_out_unregister_reboot:\n\tunregister_reboot_notifier(&usb_pcwd_notifier);\nerror:\n\tif (usb_pcwd)\n\t\tusb_pcwd_delete(usb_pcwd);\n\tusb_pcwd_device = NULL;\n\treturn retval;\n}\n\n\n \nstatic void usb_pcwd_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_pcwd_private *usb_pcwd;\n\n\t \n\tmutex_lock(&disconnect_mutex);\n\n\tusb_pcwd = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\tmutex_lock(&usb_pcwd->mtx);\n\n\t \n\tif (!nowayout)\n\t\tusb_pcwd_stop(usb_pcwd);\n\n\t \n\tusb_pcwd->exists = 0;\n\n\t \n\tmisc_deregister(&usb_pcwd_miscdev);\n\tmisc_deregister(&usb_pcwd_temperature_miscdev);\n\tunregister_reboot_notifier(&usb_pcwd_notifier);\n\n\tmutex_unlock(&usb_pcwd->mtx);\n\n\t \n\tusb_pcwd_delete(usb_pcwd);\n\n\tcards_found--;\n\n\tmutex_unlock(&disconnect_mutex);\n\n\tpr_info(\"USB PC Watchdog disconnected\\n\");\n}\n\nmodule_usb_driver(usb_pcwd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}