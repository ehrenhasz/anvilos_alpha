{
  "module_name": "smsc37b787_wdt.c",
  "hash_id": "1d21acf4b9e0bac3d6c1d4b2d4e77fde07f90f41e4d34b5fc70a086175d13834",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/smsc37b787_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n\n \n \n#define SMSC_SUPPORT_MINUTES\n#undef SMSC_SUPPORT_MINUTES\n\n#define MAX_TIMEOUT     255\n\n#define UNIT_SECOND     0\n#define UNIT_MINUTE     1\n\n#define VERSION\t\t\"1.1\"\n\n#define IOPORT\t\t0x3F0\n#define IOPORT_SIZE     2\n#define IODEV_NO\t8\n\nstatic int unit = UNIT_SECOND;\t \nstatic int timeout = 60;\t \nstatic unsigned long timer_enabled;    \n\nstatic char expect_close;        \n\nstatic DEFINE_SPINLOCK(io_lock); \n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\n \n\n \n\nstatic inline void open_io_config(void)\n{\n\toutb(0x55, IOPORT);\n\tmdelay(1);\n\toutb(0x55, IOPORT);\n}\n\n \nstatic inline void close_io_config(void)\n{\n\toutb(0xAA, IOPORT);\n}\n\n \nstatic inline void select_io_device(unsigned char devno)\n{\n\toutb(0x07, IOPORT);\n\toutb(devno, IOPORT+1);\n}\n\n \nstatic inline void write_io_cr(unsigned char reg, unsigned char data)\n{\n\toutb(reg, IOPORT);\n\toutb(data, IOPORT+1);\n}\n\n \nstatic inline char read_io_cr(unsigned char reg)\n{\n\toutb(reg, IOPORT);\n\treturn inb(IOPORT+1);\n}\n\n \n\nstatic inline void gpio_bit12(unsigned char reg)\n{\n\t \n\twrite_io_cr(0xE2, reg);\n}\n\nstatic inline void gpio_bit13(unsigned char reg)\n{\n\t \n\twrite_io_cr(0xE3, reg);\n}\n\nstatic inline void wdt_timer_units(unsigned char new_units)\n{\n\t \n\twrite_io_cr(0xF1, new_units);\n}\n\nstatic inline void wdt_timeout_value(unsigned char new_timeout)\n{\n\t \n\twrite_io_cr(0xF2, new_timeout);\n}\n\nstatic inline void wdt_timer_conf(unsigned char conf)\n{\n\t \n\twrite_io_cr(0xF3, conf);\n}\n\nstatic inline void wdt_timer_ctrl(unsigned char reg)\n{\n\t \n\twrite_io_cr(0xF4, reg);\n}\n\n \n\n \n\nstatic void wb_smsc_wdt_initialize(void)\n{\n\tunsigned char old;\n\n\tspin_lock(&io_lock);\n\topen_io_config();\n\tselect_io_device(IODEV_NO);\n\n\t \n\tgpio_bit13(0x08);   \n\tgpio_bit12(0x0A);   \n\t \n\twdt_timeout_value(0);\n\n\t \n\twdt_timer_ctrl(0x00);\n\n\t \n\twdt_timer_conf(0x00);\n\n\t \n\told = read_io_cr(0xF1) & 0x7F;\n\tif (unit == UNIT_SECOND)\n\t\told |= 0x80;\t \n\n\t \n\twdt_timer_units(old);\n\n\tclose_io_config();\n\tspin_unlock(&io_lock);\n}\n\n \n\nstatic void wb_smsc_wdt_shutdown(void)\n{\n\tspin_lock(&io_lock);\n\topen_io_config();\n\tselect_io_device(IODEV_NO);\n\n\t \n\tgpio_bit13(0x09);\n\tgpio_bit12(0x09);\n\n\t \n\twdt_timer_conf(0x00);\n\n\t \n\twdt_timer_ctrl(0x00);\n\n\t \n\twdt_timeout_value(0x00);\n\n\tclose_io_config();\n\tspin_unlock(&io_lock);\n}\n\n \n\nstatic void wb_smsc_wdt_set_timeout(unsigned char new_timeout)\n{\n\tspin_lock(&io_lock);\n\topen_io_config();\n\tselect_io_device(IODEV_NO);\n\n\t \n\twdt_timer_ctrl((new_timeout == 0) ? 0x00 : 0x02);\n\n\t \n\twdt_timeout_value(new_timeout);\n\n\tclose_io_config();\n\tspin_unlock(&io_lock);\n}\n\n \n\nstatic unsigned char wb_smsc_wdt_get_timeout(void)\n{\n\tunsigned char set_timeout;\n\n\tspin_lock(&io_lock);\n\topen_io_config();\n\tselect_io_device(IODEV_NO);\n\tset_timeout = read_io_cr(0xF2);\n\tclose_io_config();\n\tspin_unlock(&io_lock);\n\n\treturn set_timeout;\n}\n\n \n\nstatic void wb_smsc_wdt_disable(void)\n{\n\t \n\twb_smsc_wdt_set_timeout(0);\n}\n\n \n\nstatic void wb_smsc_wdt_enable(void)\n{\n\t \n\twb_smsc_wdt_set_timeout(timeout);\n}\n\n \n\nstatic void wb_smsc_wdt_reset_timer(void)\n{\n\tspin_lock(&io_lock);\n\topen_io_config();\n\tselect_io_device(IODEV_NO);\n\n\t \n\twdt_timeout_value(timeout);\n\twdt_timer_conf(0x08);\n\n\tclose_io_config();\n\tspin_unlock(&io_lock);\n}\n\n \n\nstatic int wb_smsc_wdt_status(void)\n{\n\treturn (wb_smsc_wdt_get_timeout() == 0) ? 0 : WDIOF_KEEPALIVEPING;\n}\n\n\n \n\n \n\nstatic int wb_smsc_wdt_open(struct inode *inode, struct file *file)\n{\n\t \n\n\tif (test_and_set_bit(0, &timer_enabled))\n\t\treturn -EBUSY;\n\n\tif (nowayout)\n\t\t__module_get(THIS_MODULE);\n\n\t \n\twb_smsc_wdt_enable();\n\n\tpr_info(\"Watchdog enabled. Timeout set to %d %s\\n\",\n\t\ttimeout, (unit == UNIT_SECOND) ? \"second(s)\" : \"minute(s)\");\n\n\treturn stream_open(inode, file);\n}\n\n \n\nstatic int wb_smsc_wdt_release(struct inode *inode, struct file *file)\n{\n\t \n\n\tif (expect_close == 42) {\n\t\twb_smsc_wdt_disable();\n\t\tpr_info(\"Watchdog disabled, sleeping again...\\n\");\n\t} else {\n\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\twb_smsc_wdt_reset_timer();\n\t}\n\n\tclear_bit(0, &timer_enabled);\n\texpect_close = 0;\n\treturn 0;\n}\n\n \n\nstatic ssize_t wb_smsc_wdt_write(struct file *file, const char __user *data,\n\t\t\t\t size_t len, loff_t *ppos)\n{\n\t \n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\t \n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twb_smsc_wdt_reset_timer();\n\t}\n\treturn len;\n}\n\n \n\nstatic long wb_smsc_wdt_ioctl(struct file *file,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tint new_timeout;\n\n\tunion {\n\t\tstruct watchdog_info __user *ident;\n\t\tint __user *i;\n\t} uarg;\n\n\tstatic const struct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\t\tWDIOF_SETTIMEOUT |\n\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.firmware_version =\t0,\n\t\t.identity =\t\t\"SMsC 37B787 Watchdog\",\n\t};\n\n\tuarg.i = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(uarg.ident, &ident, sizeof(ident))\n\t\t\t\t\t\t\t\t? -EFAULT : 0;\n\tcase WDIOC_GETSTATUS:\n\t\treturn put_user(wb_smsc_wdt_status(), uarg.i);\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, uarg.i);\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint options, retval = -EINVAL;\n\n\t\tif (get_user(options, uarg.i))\n\t\t\treturn -EFAULT;\n\n\t\tif (options & WDIOS_DISABLECARD) {\n\t\t\twb_smsc_wdt_disable();\n\t\t\tretval = 0;\n\t\t}\n\t\tif (options & WDIOS_ENABLECARD) {\n\t\t\twb_smsc_wdt_enable();\n\t\t\tretval = 0;\n\t\t}\n\t\treturn retval;\n\t}\n\tcase WDIOC_KEEPALIVE:\n\t\twb_smsc_wdt_reset_timer();\n\t\treturn 0;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_timeout, uarg.i))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tif (unit == UNIT_MINUTE)\n\t\t\tnew_timeout /= 60;\n\t\tif (new_timeout < 0 || new_timeout > MAX_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\ttimeout = new_timeout;\n\t\twb_smsc_wdt_set_timeout(timeout);\n\t\tfallthrough;\t \n\tcase WDIOC_GETTIMEOUT:\n\t\tnew_timeout = timeout;\n\t\tif (unit == UNIT_MINUTE)\n\t\t\tnew_timeout *= 60;\n\t\treturn put_user(new_timeout, uarg.i);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \n\nstatic int wb_smsc_wdt_notify_sys(struct notifier_block *this,\n\t\t\t\t\tunsigned long code, void *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT) {\n\t\t \n\t\ttimeout = 0;\n\t\twb_smsc_wdt_disable();\n\t}\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic const struct file_operations wb_smsc_wdt_fops = {\n\t.owner\t  = THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= wb_smsc_wdt_write,\n\t.unlocked_ioctl\t= wb_smsc_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= wb_smsc_wdt_open,\n\t.release\t= wb_smsc_wdt_release,\n};\n\nstatic struct notifier_block wb_smsc_wdt_notifier = {\n\t.notifier_call  = wb_smsc_wdt_notify_sys,\n};\n\nstatic struct miscdevice wb_smsc_wdt_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &wb_smsc_wdt_fops,\n};\n\n \n\n \n\nstatic int __init wb_smsc_wdt_init(void)\n{\n\tint ret;\n\n\tpr_info(\"SMsC 37B787 watchdog component driver \"\n\t\tVERSION \" initialising...\\n\");\n\n\tif (!request_region(IOPORT, IOPORT_SIZE, \"SMsC 37B787 watchdog\")) {\n\t\tpr_err(\"Unable to register IO port %#x\\n\", IOPORT);\n\t\tret = -EBUSY;\n\t\tgoto out_pnp;\n\t}\n\n\t \n\tif (timeout > MAX_TIMEOUT)\n\t\ttimeout = MAX_TIMEOUT;\n\n\t \n\twb_smsc_wdt_initialize();\n\n\tret = register_reboot_notifier(&wb_smsc_wdt_notifier);\n\tif (ret) {\n\t\tpr_err(\"Unable to register reboot notifier err = %d\\n\", ret);\n\t\tgoto out_io;\n\t}\n\n\tret = misc_register(&wb_smsc_wdt_miscdev);\n\tif (ret) {\n\t\tpr_err(\"Unable to register miscdev on minor %d\\n\",\n\t\t       WATCHDOG_MINOR);\n\t\tgoto out_rbt;\n\t}\n\n\t \n\tpr_info(\"Timeout set to %d %s\\n\",\n\t\ttimeout, (unit == UNIT_SECOND) ? \"second(s)\" : \"minute(s)\");\n\tpr_info(\"Watchdog initialized and sleeping (nowayout=%d)...\\n\",\n\t\tnowayout);\nout_clean:\n\treturn ret;\n\nout_rbt:\n\tunregister_reboot_notifier(&wb_smsc_wdt_notifier);\n\nout_io:\n\trelease_region(IOPORT, IOPORT_SIZE);\n\nout_pnp:\n\tgoto out_clean;\n}\n\n \n\nstatic void __exit wb_smsc_wdt_exit(void)\n{\n\t \n\tif (!nowayout) {\n\t\twb_smsc_wdt_shutdown();\n\t\tpr_info(\"Watchdog disabled\\n\");\n\t}\n\n\tmisc_deregister(&wb_smsc_wdt_miscdev);\n\tunregister_reboot_notifier(&wb_smsc_wdt_notifier);\n\trelease_region(IOPORT, IOPORT_SIZE);\n\n\tpr_info(\"SMsC 37B787 watchdog component driver removed\\n\");\n}\n\nmodule_init(wb_smsc_wdt_init);\nmodule_exit(wb_smsc_wdt_exit);\n\nMODULE_AUTHOR(\"Sven Anders <anders@anduras.de>\");\nMODULE_DESCRIPTION(\"Driver for SMsC 37B787 watchdog component (Version \"\n\t\t\t\t\t\t\t\tVERSION \")\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef SMSC_SUPPORT_MINUTES\nmodule_param(unit, int, 0);\nMODULE_PARM_DESC(unit,\n\t\t\"set unit to use, 0=seconds or 1=minutes, default is 0\");\n#endif\n\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"range is 1-255 units, default is 60\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}