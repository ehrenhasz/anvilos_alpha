{
  "module_name": "rza_wdt.c",
  "hash_id": "bfaec46506cdbc4994709d620570dce21ad32d78a3e1503e4fc3a7bacf97dccf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rza_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define DEFAULT_TIMEOUT\t\t30\n\n \n#define WTCSR\t\t\t0\n#define WTCSR_MAGIC\t\t0xA500\n#define WTSCR_WT\t\tBIT(6)\n#define WTSCR_TME\t\tBIT(5)\n#define WTSCR_CKS(i)\t\t(i)\n\n#define WTCNT\t\t\t2\n#define WTCNT_MAGIC\t\t0x5A00\n\n#define WRCSR\t\t\t4\n#define WRCSR_MAGIC\t\t0x5A00\n#define WRCSR_RSTE\t\tBIT(6)\n#define WRCSR_CLEAR_WOVF\t0xA500\t \n\n \n#define CKS_3BIT\t\t0x7\n#define CKS_4BIT\t\t0xF\n\n#define DIVIDER_3BIT\t\t16384\t \n#define DIVIDER_4BIT\t\t4194304\t \n\nstruct rza_wdt {\n\tstruct watchdog_device wdev;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tu8 count;\n\tu8 cks;\n};\n\nstatic void rza_wdt_calc_timeout(struct rza_wdt *priv, int timeout)\n{\n\tunsigned long rate = clk_get_rate(priv->clk);\n\tunsigned int ticks;\n\n\tif (priv->cks == CKS_4BIT) {\n\t\tticks = DIV_ROUND_UP(timeout * rate, DIVIDER_4BIT);\n\n\t\t \n\t\tpriv->count = 256 - ticks;\n\n\t} else {\n\t\t \n\t\tpriv->count = 0;\n\t}\n\n\tpr_debug(\"%s: timeout set to %u (WTCNT=%d)\\n\", __func__,\n\t\t timeout, priv->count);\n}\n\nstatic int rza_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct rza_wdt *priv = watchdog_get_drvdata(wdev);\n\n\t \n\twritew(WTCSR_MAGIC | 0, priv->base + WTCSR);\n\n\t \n\treadb(priv->base + WRCSR);\n\twritew(WRCSR_CLEAR_WOVF, priv->base + WRCSR);\n\n\trza_wdt_calc_timeout(priv, wdev->timeout);\n\n\twritew(WRCSR_MAGIC | WRCSR_RSTE, priv->base + WRCSR);\n\twritew(WTCNT_MAGIC | priv->count, priv->base + WTCNT);\n\twritew(WTCSR_MAGIC | WTSCR_WT | WTSCR_TME |\n\t       WTSCR_CKS(priv->cks), priv->base + WTCSR);\n\n\treturn 0;\n}\n\nstatic int rza_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct rza_wdt *priv = watchdog_get_drvdata(wdev);\n\n\twritew(WTCSR_MAGIC | 0, priv->base + WTCSR);\n\n\treturn 0;\n}\n\nstatic int rza_wdt_ping(struct watchdog_device *wdev)\n{\n\tstruct rza_wdt *priv = watchdog_get_drvdata(wdev);\n\n\twritew(WTCNT_MAGIC | priv->count, priv->base + WTCNT);\n\n\tpr_debug(\"%s: timeout = %u\\n\", __func__, wdev->timeout);\n\n\treturn 0;\n}\n\nstatic int rza_set_timeout(struct watchdog_device *wdev, unsigned int timeout)\n{\n\twdev->timeout = timeout;\n\trza_wdt_start(wdev);\n\treturn 0;\n}\n\nstatic int rza_wdt_restart(struct watchdog_device *wdev, unsigned long action,\n\t\t\t    void *data)\n{\n\tstruct rza_wdt *priv = watchdog_get_drvdata(wdev);\n\n\t \n\twritew(WTCSR_MAGIC | 0, priv->base + WTCSR);\n\n\t \n\treadb(priv->base + WRCSR);\n\twritew(WRCSR_CLEAR_WOVF, priv->base + WRCSR);\n\n\t \n\twritew(WRCSR_MAGIC | WRCSR_RSTE, priv->base + WRCSR);\n\twritew(WTCNT_MAGIC | 255, priv->base + WTCNT);\n\twritew(WTCSR_MAGIC | WTSCR_WT | WTSCR_TME, priv->base + WTCSR);\n\n\t \n\twmb();\n\n\t \n\tudelay(20);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info rza_wdt_ident = {\n\t.options = WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT,\n\t.identity = \"Renesas RZ/A WDT Watchdog\",\n};\n\nstatic const struct watchdog_ops rza_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = rza_wdt_start,\n\t.stop = rza_wdt_stop,\n\t.ping = rza_wdt_ping,\n\t.set_timeout = rza_set_timeout,\n\t.restart = rza_wdt_restart,\n};\n\nstatic int rza_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rza_wdt *priv;\n\tunsigned long rate;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\trate = clk_get_rate(priv->clk);\n\tif (rate < 16384) {\n\t\tdev_err(dev, \"invalid clock rate (%ld)\\n\", rate);\n\t\treturn -ENOENT;\n\t}\n\n\tpriv->wdev.info = &rza_wdt_ident;\n\tpriv->wdev.ops = &rza_wdt_ops;\n\tpriv->wdev.parent = dev;\n\n\tpriv->cks = (u8)(uintptr_t) of_device_get_match_data(dev);\n\tif (priv->cks == CKS_4BIT) {\n\t\t \n\t\tpriv->wdev.max_timeout = (DIVIDER_4BIT * U8_MAX) / rate;\n\n\t} else if (priv->cks == CKS_3BIT) {\n\t\t \n\t\trate /= DIVIDER_3BIT;\n\n\t\t \n\t\tpriv->wdev.max_hw_heartbeat_ms = (1000 * U8_MAX) / rate;\n\t\tdev_dbg(dev, \"max hw timeout of %dms\\n\",\n\t\t\tpriv->wdev.max_hw_heartbeat_ms);\n\t}\n\n\tpriv->wdev.min_timeout = 1;\n\tpriv->wdev.timeout = DEFAULT_TIMEOUT;\n\n\twatchdog_init_timeout(&priv->wdev, 0, dev);\n\twatchdog_set_drvdata(&priv->wdev, priv);\n\n\tret = devm_watchdog_register_device(dev, &priv->wdev);\n\tif (ret)\n\t\tdev_err(dev, \"Cannot register watchdog device\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id rza_wdt_of_match[] = {\n\t{ .compatible = \"renesas,r7s9210-wdt\",\t.data = (void *)CKS_4BIT, },\n\t{ .compatible = \"renesas,rza-wdt\",\t.data = (void *)CKS_3BIT, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rza_wdt_of_match);\n\nstatic struct platform_driver rza_wdt_driver = {\n\t.probe = rza_wdt_probe,\n\t.driver = {\n\t\t.name = \"rza_wdt\",\n\t\t.of_match_table = rza_wdt_of_match,\n\t},\n};\n\nmodule_platform_driver(rza_wdt_driver);\n\nMODULE_DESCRIPTION(\"Renesas RZ/A WDT Driver\");\nMODULE_AUTHOR(\"Chris Brandt <chris.brandt@renesas.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}