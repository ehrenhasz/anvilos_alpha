{
  "module_name": "bd9576_wdt.c",
  "hash_id": "badc654e4ab51a176a0fe4183757a503dbf89d8097cd2a7ecae745e659ba4182",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/bd9576_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mfd/rohm-bd957x.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\nstatic bool nowayout;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\\\"false\\\")\");\n\n#define HW_MARGIN_MIN 2\n#define HW_MARGIN_MAX 4416\n#define BD957X_WDT_DEFAULT_MARGIN 4416\n#define WATCHDOG_TIMEOUT 30\n\nstruct bd9576_wdt_priv {\n\tstruct gpio_desc\t*gpiod_ping;\n\tstruct gpio_desc\t*gpiod_en;\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*regmap;\n\tbool\t\t\talways_running;\n\tstruct watchdog_device\twdd;\n};\n\nstatic void bd9576_wdt_disable(struct bd9576_wdt_priv *priv)\n{\n\tgpiod_set_value_cansleep(priv->gpiod_en, 0);\n}\n\nstatic int bd9576_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct bd9576_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\t \n\tgpiod_set_value_cansleep(priv->gpiod_ping, 1);\n\tgpiod_set_value_cansleep(priv->gpiod_ping, 0);\n\n\treturn 0;\n}\n\nstatic int bd9576_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct bd9576_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\tgpiod_set_value_cansleep(priv->gpiod_en, 1);\n\n\treturn bd9576_wdt_ping(wdd);\n}\n\nstatic int bd9576_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct bd9576_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\tif (!priv->always_running)\n\t\tbd9576_wdt_disable(priv);\n\telse\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info bd957x_wdt_ident = {\n\t.options\t= WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_SETTIMEOUT,\n\t.identity\t= \"BD957x Watchdog\",\n};\n\nstatic const struct watchdog_ops bd957x_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= bd9576_wdt_start,\n\t.stop\t\t= bd9576_wdt_stop,\n\t.ping\t\t= bd9576_wdt_ping,\n};\n\n \n#define FASTNG_MIN 23\n\nstatic int find_closest_fast(int target, int *sel, int *val)\n{\n\tint i;\n\tint window = FASTNG_MIN;\n\n\tfor (i = 0; i < 8 && window < target; i++)\n\t\twindow <<= 1;\n\n\t*val = window;\n\t*sel = i;\n\n\tif (i == 8)\n\t\treturn -EINVAL;\n\n\treturn 0;\n\n}\n\nstatic int find_closest_slow_by_fast(int fast_val, int target, int *slowsel)\n{\n\tint sel;\n\tstatic const int multipliers[] = {2, 3, 7, 15};\n\n\tfor (sel = 0; sel < ARRAY_SIZE(multipliers) &&\n\t     multipliers[sel] * fast_val < target; sel++)\n\t\t;\n\n\tif (sel == ARRAY_SIZE(multipliers))\n\t\treturn -EINVAL;\n\n\t*slowsel = sel;\n\n\treturn 0;\n}\n\nstatic int find_closest_slow(int target, int *slow_sel, int *fast_sel)\n{\n\tstatic const int multipliers[] = {2, 3, 7, 15};\n\tint i, j;\n\tint val = 0;\n\tint window = FASTNG_MIN;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(multipliers); j++) {\n\t\t\tint slow;\n\n\t\t\tslow = window * multipliers[j];\n\t\t\tif (slow >= target && (!val || slow < val)) {\n\t\t\t\tval = slow;\n\t\t\t\t*fast_sel = i;\n\t\t\t\t*slow_sel = j;\n\t\t\t}\n\t\t}\n\t\twindow <<= 1;\n\t}\n\tif (!val)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#define BD957X_WDG_TYPE_WINDOW BIT(5)\n#define BD957X_WDG_TYPE_SLOW 0\n#define BD957X_WDG_TYPE_MASK BIT(5)\n#define BD957X_WDG_NG_RATIO_MASK 0x18\n#define BD957X_WDG_FASTNG_MASK 0x7\n\nstatic int bd957x_set_wdt_mode(struct bd9576_wdt_priv *priv, int hw_margin,\n\t\t\t       int hw_margin_min)\n{\n\tint ret, fastng, slowng, type, reg, mask;\n\tstruct device *dev = priv->dev;\n\n\t \n\thw_margin *= 10;\n\thw_margin_min *= 10;\n\tif (hw_margin_min) {\n\t\tint min;\n\n\t\ttype = BD957X_WDG_TYPE_WINDOW;\n\t\tdev_dbg(dev, \"Setting type WINDOW 0x%x\\n\", type);\n\t\tret = find_closest_fast(hw_margin_min, &fastng, &min);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"bad WDT window for fast timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = find_closest_slow_by_fast(min, hw_margin, &slowng);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"bad WDT window\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t} else {\n\t\ttype = BD957X_WDG_TYPE_SLOW;\n\t\tdev_dbg(dev, \"Setting type SLOW 0x%x\\n\", type);\n\t\tret = find_closest_slow(hw_margin, &slowng, &fastng);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"bad WDT window\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tslowng <<= ffs(BD957X_WDG_NG_RATIO_MASK) - 1;\n\treg = type | slowng | fastng;\n\tmask = BD957X_WDG_TYPE_MASK | BD957X_WDG_NG_RATIO_MASK |\n\t       BD957X_WDG_FASTNG_MASK;\n\tret = regmap_update_bits(priv->regmap, BD957X_REG_WDT_CONF,\n\t\t\t\t mask, reg);\n\n\treturn ret;\n}\n\nstatic int bd9576_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bd9576_wdt_priv *priv;\n\tu32 hw_margin[2];\n\tu32 hw_margin_max = BD957X_WDT_DEFAULT_MARGIN, hw_margin_min = 0;\n\tint count;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->dev = dev;\n\tpriv->regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!priv->regmap) {\n\t\tdev_err(dev, \"No regmap found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->gpiod_en = devm_fwnode_gpiod_get(dev, dev_fwnode(dev->parent),\n\t\t\t\t\t       \"rohm,watchdog-enable\",\n\t\t\t\t\t       GPIOD_OUT_LOW,\n\t\t\t\t\t       \"watchdog-enable\");\n\tif (IS_ERR(priv->gpiod_en))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->gpiod_en),\n\t\t\t      \"getting watchdog-enable GPIO failed\\n\");\n\n\tpriv->gpiod_ping = devm_fwnode_gpiod_get(dev, dev_fwnode(dev->parent),\n\t\t\t\t\t\t \"rohm,watchdog-ping\",\n\t\t\t\t\t\t GPIOD_OUT_LOW,\n\t\t\t\t\t\t \"watchdog-ping\");\n\tif (IS_ERR(priv->gpiod_ping))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->gpiod_ping),\n\t\t\t\t     \"getting watchdog-ping GPIO failed\\n\");\n\n\tcount = device_property_count_u32(dev->parent, \"rohm,hw-timeout-ms\");\n\tif (count < 0 && count != -EINVAL)\n\t\treturn count;\n\n\tif (count > 0) {\n\t\tif (count > ARRAY_SIZE(hw_margin))\n\t\t\treturn -EINVAL;\n\n\t\tret = device_property_read_u32_array(dev->parent,\n\t\t\t\t\t\t     \"rohm,hw-timeout-ms\",\n\t\t\t\t\t\t     hw_margin, count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (count == 1)\n\t\t\thw_margin_max = hw_margin[0];\n\n\t\tif (count == 2) {\n\t\t\thw_margin_max = hw_margin[1];\n\t\t\thw_margin_min = hw_margin[0];\n\t\t}\n\t}\n\n\tret = bd957x_set_wdt_mode(priv, hw_margin_max, hw_margin_min);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->always_running = device_property_read_bool(dev->parent,\n\t\t\t\t\t\t\t \"always-running\");\n\n\twatchdog_set_drvdata(&priv->wdd, priv);\n\n\tpriv->wdd.info\t\t\t= &bd957x_wdt_ident;\n\tpriv->wdd.ops\t\t\t= &bd957x_wdt_ops;\n\tpriv->wdd.min_hw_heartbeat_ms\t= hw_margin_min;\n\tpriv->wdd.max_hw_heartbeat_ms\t= hw_margin_max;\n\tpriv->wdd.parent\t\t= dev;\n\tpriv->wdd.timeout\t\t= WATCHDOG_TIMEOUT;\n\n\twatchdog_init_timeout(&priv->wdd, 0, dev);\n\twatchdog_set_nowayout(&priv->wdd, nowayout);\n\n\twatchdog_stop_on_reboot(&priv->wdd);\n\n\tif (priv->always_running)\n\t\tbd9576_wdt_start(&priv->wdd);\n\n\treturn devm_watchdog_register_device(dev, &priv->wdd);\n}\n\nstatic struct platform_driver bd9576_wdt_driver = {\n\t.driver\t= {\n\t\t.name = \"bd9576-wdt\",\n\t},\n\t.probe\t= bd9576_wdt_probe,\n};\n\nmodule_platform_driver(bd9576_wdt_driver);\n\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"ROHM BD9576/BD9573 Watchdog driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:bd9576-wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}