{
  "module_name": "sunxi_wdt.c",
  "hash_id": "1479a5bf192f80f707408010e0619c46a9e9d7712b0e04341e4a83f4892bf3bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sunxi_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#define WDT_MAX_TIMEOUT         16\n#define WDT_MIN_TIMEOUT         1\n#define WDT_TIMEOUT_MASK        0x0F\n\n#define WDT_CTRL_RELOAD         ((1 << 0) | (0x0a57 << 1))\n\n#define WDT_MODE_EN             (1 << 0)\n\n#define DRV_NAME\t\t\"sunxi-wdt\"\n#define DRV_VERSION\t\t\"1.0\"\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic unsigned int timeout;\n\n \nstruct sunxi_wdt_reg {\n\tu8 wdt_ctrl;\n\tu8 wdt_cfg;\n\tu8 wdt_mode;\n\tu8 wdt_timeout_shift;\n\tu8 wdt_reset_mask;\n\tu8 wdt_reset_val;\n\tu32 wdt_key_val;\n};\n\nstruct sunxi_wdt_dev {\n\tstruct watchdog_device wdt_dev;\n\tvoid __iomem *wdt_base;\n\tconst struct sunxi_wdt_reg *wdt_regs;\n};\n\n \n\nstatic const int wdt_timeout_map[] = {\n\t[1] = 0x1,   \n\t[2] = 0x2,   \n\t[3] = 0x3,   \n\t[4] = 0x4,   \n\t[5] = 0x5,   \n\t[6] = 0x6,   \n\t[8] = 0x7,   \n\t[10] = 0x8,  \n\t[12] = 0x9,  \n\t[14] = 0xA,  \n\t[16] = 0xB,  \n};\n\n\nstatic int sunxi_wdt_restart(struct watchdog_device *wdt_dev,\n\t\t\t     unsigned long action, void *data)\n{\n\tstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\n\tconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\n\tu32 val;\n\n\t \n\tval = readl(wdt_base + regs->wdt_cfg);\n\tval &= ~(regs->wdt_reset_mask);\n\tval |= regs->wdt_reset_val;\n\tval |= regs->wdt_key_val;\n\twritel(val, wdt_base + regs->wdt_cfg);\n\n\t \n\tval = readl(wdt_base + regs->wdt_mode);\n\tval &= ~(WDT_TIMEOUT_MASK << regs->wdt_timeout_shift);\n\tval |= WDT_MODE_EN;\n\tval |= regs->wdt_key_val;\n\twritel(val, wdt_base + regs->wdt_mode);\n\n\t \n\twritel(WDT_CTRL_RELOAD, wdt_base + regs->wdt_ctrl);\n\n\twhile (1) {\n\t\tmdelay(5);\n\t\tval = readl(wdt_base + regs->wdt_mode);\n\t\tval |= WDT_MODE_EN;\n\t\tval |= regs->wdt_key_val;\n\t\twritel(val, wdt_base + regs->wdt_mode);\n\t}\n\treturn 0;\n}\n\nstatic int sunxi_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\n\tconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\n\n\twritel(WDT_CTRL_RELOAD, wdt_base + regs->wdt_ctrl);\n\n\treturn 0;\n}\n\nstatic int sunxi_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\tunsigned int timeout)\n{\n\tstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\n\tconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\n\tu32 reg;\n\n\tif (wdt_timeout_map[timeout] == 0)\n\t\ttimeout++;\n\n\tsunxi_wdt->wdt_dev.timeout = timeout;\n\n\treg = readl(wdt_base + regs->wdt_mode);\n\treg &= ~(WDT_TIMEOUT_MASK << regs->wdt_timeout_shift);\n\treg |= wdt_timeout_map[timeout] << regs->wdt_timeout_shift;\n\treg |= regs->wdt_key_val;\n\twritel(reg, wdt_base + regs->wdt_mode);\n\n\tsunxi_wdt_ping(wdt_dev);\n\n\treturn 0;\n}\n\nstatic int sunxi_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\n\tconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\n\n\twritel(regs->wdt_key_val, wdt_base + regs->wdt_mode);\n\n\treturn 0;\n}\n\nstatic int sunxi_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tu32 reg;\n\tstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\n\tvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\n\tconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\n\tint ret;\n\n\tret = sunxi_wdt_set_timeout(&sunxi_wdt->wdt_dev,\n\t\t\tsunxi_wdt->wdt_dev.timeout);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treg = readl(wdt_base + regs->wdt_cfg);\n\treg &= ~(regs->wdt_reset_mask);\n\treg |= regs->wdt_reset_val;\n\treg |= regs->wdt_key_val;\n\twritel(reg, wdt_base + regs->wdt_cfg);\n\n\t \n\treg = readl(wdt_base + regs->wdt_mode);\n\treg |= WDT_MODE_EN;\n\treg |= regs->wdt_key_val;\n\twritel(reg, wdt_base + regs->wdt_mode);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info sunxi_wdt_info = {\n\t.identity\t= DRV_NAME,\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops sunxi_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= sunxi_wdt_start,\n\t.stop\t\t= sunxi_wdt_stop,\n\t.ping\t\t= sunxi_wdt_ping,\n\t.set_timeout\t= sunxi_wdt_set_timeout,\n\t.restart\t= sunxi_wdt_restart,\n};\n\nstatic const struct sunxi_wdt_reg sun4i_wdt_reg = {\n\t.wdt_ctrl = 0x00,\n\t.wdt_cfg = 0x04,\n\t.wdt_mode = 0x04,\n\t.wdt_timeout_shift = 3,\n\t.wdt_reset_mask = 0x02,\n\t.wdt_reset_val = 0x02,\n};\n\nstatic const struct sunxi_wdt_reg sun6i_wdt_reg = {\n\t.wdt_ctrl = 0x10,\n\t.wdt_cfg = 0x14,\n\t.wdt_mode = 0x18,\n\t.wdt_timeout_shift = 4,\n\t.wdt_reset_mask = 0x03,\n\t.wdt_reset_val = 0x01,\n};\n\nstatic const struct sunxi_wdt_reg sun20i_wdt_reg = {\n\t.wdt_ctrl = 0x10,\n\t.wdt_cfg = 0x14,\n\t.wdt_mode = 0x18,\n\t.wdt_timeout_shift = 4,\n\t.wdt_reset_mask = 0x03,\n\t.wdt_reset_val = 0x01,\n\t.wdt_key_val = 0x16aa0000,\n};\n\nstatic const struct of_device_id sunxi_wdt_dt_ids[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-wdt\", .data = &sun4i_wdt_reg },\n\t{ .compatible = \"allwinner,sun6i-a31-wdt\", .data = &sun6i_wdt_reg },\n\t{ .compatible = \"allwinner,sun20i-d1-wdt\", .data = &sun20i_wdt_reg },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sunxi_wdt_dt_ids);\n\nstatic int sunxi_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sunxi_wdt_dev *sunxi_wdt;\n\tint err;\n\n\tsunxi_wdt = devm_kzalloc(dev, sizeof(*sunxi_wdt), GFP_KERNEL);\n\tif (!sunxi_wdt)\n\t\treturn -ENOMEM;\n\n\tsunxi_wdt->wdt_regs = of_device_get_match_data(dev);\n\tif (!sunxi_wdt->wdt_regs)\n\t\treturn -ENODEV;\n\n\tsunxi_wdt->wdt_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sunxi_wdt->wdt_base))\n\t\treturn PTR_ERR(sunxi_wdt->wdt_base);\n\n\tsunxi_wdt->wdt_dev.info = &sunxi_wdt_info;\n\tsunxi_wdt->wdt_dev.ops = &sunxi_wdt_ops;\n\tsunxi_wdt->wdt_dev.timeout = WDT_MAX_TIMEOUT;\n\tsunxi_wdt->wdt_dev.max_timeout = WDT_MAX_TIMEOUT;\n\tsunxi_wdt->wdt_dev.min_timeout = WDT_MIN_TIMEOUT;\n\tsunxi_wdt->wdt_dev.parent = dev;\n\n\twatchdog_init_timeout(&sunxi_wdt->wdt_dev, timeout, dev);\n\twatchdog_set_nowayout(&sunxi_wdt->wdt_dev, nowayout);\n\twatchdog_set_restart_priority(&sunxi_wdt->wdt_dev, 128);\n\n\twatchdog_set_drvdata(&sunxi_wdt->wdt_dev, sunxi_wdt);\n\n\tsunxi_wdt_stop(&sunxi_wdt->wdt_dev);\n\n\twatchdog_stop_on_reboot(&sunxi_wdt->wdt_dev);\n\terr = devm_watchdog_register_device(dev, &sunxi_wdt->wdt_dev);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tdev_info(dev, \"Watchdog enabled (timeout=%d sec, nowayout=%d)\",\n\t\t sunxi_wdt->wdt_dev.timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sunxi_wdt_driver = {\n\t.probe\t\t= sunxi_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= sunxi_wdt_dt_ids,\n\t},\n};\n\nmodule_platform_driver(sunxi_wdt_driver);\n\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog heartbeat in seconds\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\t\"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Carlo Caione <carlo.caione@gmail.com>\");\nMODULE_AUTHOR(\"Henrik Nordstrom <henrik@henriknordstrom.net>\");\nMODULE_DESCRIPTION(\"sunxi WatchDog Timer Driver\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}