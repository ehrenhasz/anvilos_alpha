{
  "module_name": "octeon-wdt-main.c",
  "hash_id": "493d9525958a56a56d49f867a45373127b9f16d3f4a4fff3338f0aad2a00395d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/octeon-wdt-main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/watchdog.h>\n#include <linux/cpumask.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\n#include <asm/mipsregs.h>\n#include <asm/uasm.h>\n\n#include <asm/octeon/octeon.h>\n#include <asm/octeon/cvmx-boot-vector.h>\n#include <asm/octeon/cvmx-ciu2-defs.h>\n#include <asm/octeon/cvmx-rst-defs.h>\n\n \n#define WD_BLOCK_NUMBER\t\t0x01\n\nstatic int divisor;\n\n \nstatic unsigned int timeout_cnt;\n\n \nstatic unsigned int max_timeout_sec;\n\n \nstatic unsigned int timeout_sec;\n\n \nstatic bool do_countdown;\nstatic unsigned int countdown_reset;\nstatic unsigned int per_cpu_countdown[NR_CPUS];\n\nstatic cpumask_t irq_enabled_cpus;\n\n#define WD_TIMO 60\t\t\t \n\n#define CVMX_GSERX_SCRATCH(offset) (CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((offset) & 15) * 0x1000000ull)\n\nstatic int heartbeat = WD_TIMO;\nmodule_param(heartbeat, int, 0444);\nMODULE_PARM_DESC(heartbeat,\n\t\"Watchdog heartbeat in seconds. (0 < heartbeat, default=\"\n\t\t\t\t__MODULE_STRING(WD_TIMO) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0444);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int disable;\nmodule_param(disable, int, 0444);\nMODULE_PARM_DESC(disable,\n\t\"Disable the watchdog entirely (default=0)\");\n\nstatic struct cvmx_boot_vector_element *octeon_wdt_bootvector;\n\nvoid octeon_wdt_nmi_stage2(void);\n\nstatic int cpu2core(int cpu)\n{\n#ifdef CONFIG_SMP\n\treturn cpu_logical_map(cpu) & 0x3f;\n#else\n\treturn cvmx_get_core_num();\n#endif\n}\n\n \nstatic irqreturn_t octeon_wdt_poke_irq(int cpl, void *dev_id)\n{\n\tint cpu = raw_smp_processor_id();\n\tunsigned int core = cpu2core(cpu);\n\tint node = cpu_to_node(cpu);\n\n\tif (do_countdown) {\n\t\tif (per_cpu_countdown[cpu] > 0) {\n\t\t\t \n\t\t\tcvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);\n\t\t\tper_cpu_countdown[cpu]--;\n\t\t} else {\n\t\t\t \n\t\t\tdisable_irq_nosync(cpl);\n\t\t\tcpumask_clear_cpu(cpu, &irq_enabled_cpus);\n\t\t}\n\t} else {\n\t\t \n\t\tcvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nextern int prom_putchar(char c);\n\n \nstatic void octeon_wdt_write_string(const char *str)\n{\n\t \n\twhile (*str)\n\t\tprom_putchar(*str++);\n}\n\n \nstatic void octeon_wdt_write_hex(u64 value, int digits)\n{\n\tint d;\n\tint v;\n\n\tfor (d = 0; d < digits; d++) {\n\t\tv = (value >> ((digits - d - 1) * 4)) & 0xf;\n\t\tif (v >= 10)\n\t\t\tprom_putchar('a' + v - 10);\n\t\telse\n\t\t\tprom_putchar('0' + v);\n\t}\n}\n\nstatic const char reg_name[][3] = {\n\t\"$0\", \"at\", \"v0\", \"v1\", \"a0\", \"a1\", \"a2\", \"a3\",\n\t\"a4\", \"a5\", \"a6\", \"a7\", \"t0\", \"t1\", \"t2\", \"t3\",\n\t\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\",\n\t\"t8\", \"t9\", \"k0\", \"k1\", \"gp\", \"sp\", \"s8\", \"ra\"\n};\n\n \nvoid octeon_wdt_nmi_stage3(u64 reg[32])\n{\n\tu64 i;\n\n\tunsigned int coreid = cvmx_get_core_num();\n\t \n\tu64 cp0_cause = read_c0_cause();\n\tu64 cp0_status = read_c0_status();\n\tu64 cp0_error_epc = read_c0_errorepc();\n\tu64 cp0_epc = read_c0_epc();\n\n\t \n\tudelay(85000 * coreid);\n\n\tocteon_wdt_write_string(\"\\r\\n*** NMI Watchdog interrupt on Core 0x\");\n\tocteon_wdt_write_hex(coreid, 2);\n\tocteon_wdt_write_string(\" ***\\r\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tocteon_wdt_write_string(\"\\t\");\n\t\tocteon_wdt_write_string(reg_name[i]);\n\t\tocteon_wdt_write_string(\"\\t0x\");\n\t\tocteon_wdt_write_hex(reg[i], 16);\n\t\tif (i & 1)\n\t\t\tocteon_wdt_write_string(\"\\r\\n\");\n\t}\n\tocteon_wdt_write_string(\"\\terr_epc\\t0x\");\n\tocteon_wdt_write_hex(cp0_error_epc, 16);\n\n\tocteon_wdt_write_string(\"\\tepc\\t0x\");\n\tocteon_wdt_write_hex(cp0_epc, 16);\n\tocteon_wdt_write_string(\"\\r\\n\");\n\n\tocteon_wdt_write_string(\"\\tstatus\\t0x\");\n\tocteon_wdt_write_hex(cp0_status, 16);\n\tocteon_wdt_write_string(\"\\tcause\\t0x\");\n\tocteon_wdt_write_hex(cp0_cause, 16);\n\tocteon_wdt_write_string(\"\\r\\n\");\n\n\t \n\tif (OCTEON_IS_MODEL(OCTEON_CN68XX)) {\n\t\tocteon_wdt_write_string(\"\\tsrc_wd\\t0x\");\n\t\tocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_SRC_PPX_IP2_WDOG(coreid)), 16);\n\t\tocteon_wdt_write_string(\"\\ten_wd\\t0x\");\n\t\tocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_EN_PPX_IP2_WDOG(coreid)), 16);\n\t\tocteon_wdt_write_string(\"\\r\\n\");\n\t\tocteon_wdt_write_string(\"\\tsrc_rml\\t0x\");\n\t\tocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_SRC_PPX_IP2_RML(coreid)), 16);\n\t\tocteon_wdt_write_string(\"\\ten_rml\\t0x\");\n\t\tocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_EN_PPX_IP2_RML(coreid)), 16);\n\t\tocteon_wdt_write_string(\"\\r\\n\");\n\t\tocteon_wdt_write_string(\"\\tsum\\t0x\");\n\t\tocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_SUM_PPX_IP2(coreid)), 16);\n\t\tocteon_wdt_write_string(\"\\r\\n\");\n\t} else if (!octeon_has_feature(OCTEON_FEATURE_CIU3)) {\n\t\tocteon_wdt_write_string(\"\\tsum0\\t0x\");\n\t\tocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU_INTX_SUM0(coreid * 2)), 16);\n\t\tocteon_wdt_write_string(\"\\ten0\\t0x\");\n\t\tocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2)), 16);\n\t\tocteon_wdt_write_string(\"\\r\\n\");\n\t}\n\n\tocteon_wdt_write_string(\"*** Chip soft reset soon ***\\r\\n\");\n\n\t \n\tif (OCTEON_IS_OCTEON3() && !OCTEON_IS_MODEL(OCTEON_CN70XX)) {\n\t\tu64 scr;\n\t\tunsigned int node = cvmx_get_node_num();\n\t\tunsigned int lcore = cvmx_get_local_core_num();\n\t\tunion cvmx_ciu_wdogx ciu_wdog;\n\n\t\t \n\t\tdo {\n\t\t\tciu_wdog.u64 = cvmx_read_csr_node(node, CVMX_CIU_WDOGX(lcore));\n\t\t} while (ciu_wdog.s.cnt > 0x10000);\n\n\t\tscr = cvmx_read_csr_node(0, CVMX_GSERX_SCRATCH(0));\n\t\tscr |= 1 << 11;  \n\t\tcvmx_write_csr_node(0, CVMX_GSERX_SCRATCH(0), scr);\n\t\tcvmx_write_csr_node(0, CVMX_RST_SOFT_RST, 1);\n\t}\n}\n\nstatic int octeon_wdt_cpu_to_irq(int cpu)\n{\n\tunsigned int coreid;\n\tint node;\n\tint irq;\n\n\tcoreid = cpu2core(cpu);\n\tnode = cpu_to_node(cpu);\n\n\tif (octeon_has_feature(OCTEON_FEATURE_CIU3)) {\n\t\tstruct irq_domain *domain;\n\t\tint hwirq;\n\n\t\tdomain = octeon_irq_get_block_domain(node,\n\t\t\t\t\t\t     WD_BLOCK_NUMBER);\n\t\thwirq = WD_BLOCK_NUMBER << 12 | 0x200 | coreid;\n\t\tirq = irq_find_mapping(domain, hwirq);\n\t} else {\n\t\tirq = OCTEON_IRQ_WDOG0 + coreid;\n\t}\n\treturn irq;\n}\n\nstatic int octeon_wdt_cpu_pre_down(unsigned int cpu)\n{\n\tunsigned int core;\n\tint node;\n\tunion cvmx_ciu_wdogx ciu_wdog;\n\n\tcore = cpu2core(cpu);\n\n\tnode = cpu_to_node(cpu);\n\n\t \n\tcvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);\n\n\t \n\tciu_wdog.u64 = 0;\n\tcvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);\n\n\tfree_irq(octeon_wdt_cpu_to_irq(cpu), octeon_wdt_poke_irq);\n\treturn 0;\n}\n\nstatic int octeon_wdt_cpu_online(unsigned int cpu)\n{\n\tunsigned int core;\n\tunsigned int irq;\n\tunion cvmx_ciu_wdogx ciu_wdog;\n\tint node;\n\tstruct irq_domain *domain;\n\tint hwirq;\n\n\tcore = cpu2core(cpu);\n\tnode = cpu_to_node(cpu);\n\n\tocteon_wdt_bootvector[core].target_ptr = (u64)octeon_wdt_nmi_stage2;\n\n\t \n\tciu_wdog.u64 = 0;\n\tcvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);\n\n\tper_cpu_countdown[cpu] = countdown_reset;\n\n\tif (octeon_has_feature(OCTEON_FEATURE_CIU3)) {\n\t\t \n\t\tdomain = octeon_irq_get_block_domain(node, WD_BLOCK_NUMBER);\n\n\t\t \n\t\thwirq = WD_BLOCK_NUMBER << 12 | 0x200 | core;\n\t\tirq = irq_create_mapping(domain, hwirq);\n\t\tirqd_set_trigger_type(irq_get_irq_data(irq),\n\t\t\t\t      IRQ_TYPE_EDGE_RISING);\n\t} else\n\t\tirq = OCTEON_IRQ_WDOG0 + core;\n\n\tif (request_irq(irq, octeon_wdt_poke_irq,\n\t\t\tIRQF_NO_THREAD, \"octeon_wdt\", octeon_wdt_poke_irq))\n\t\tpanic(\"octeon_wdt: Couldn't obtain irq %d\", irq);\n\n\t \n\tif (octeon_has_feature(OCTEON_FEATURE_CIU3)) {\n\t\tcpumask_t mask;\n\n\t\tcpumask_clear(&mask);\n\t\tcpumask_set_cpu(cpu, &mask);\n\t\tirq_set_affinity(irq, &mask);\n\t}\n\n\tcpumask_set_cpu(cpu, &irq_enabled_cpus);\n\n\t \n\tcvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);\n\n\t \n\tciu_wdog.u64 = 0;\n\tciu_wdog.s.len = timeout_cnt;\n\tciu_wdog.s.mode = 3;\t \n\tcvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);\n\n\treturn 0;\n}\n\nstatic int octeon_wdt_ping(struct watchdog_device __always_unused *wdog)\n{\n\tint cpu;\n\tint coreid;\n\tint node;\n\n\tif (disable)\n\t\treturn 0;\n\n\tfor_each_online_cpu(cpu) {\n\t\tcoreid = cpu2core(cpu);\n\t\tnode = cpu_to_node(cpu);\n\t\tcvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);\n\t\tper_cpu_countdown[cpu] = countdown_reset;\n\t\tif ((countdown_reset || !do_countdown) &&\n\t\t    !cpumask_test_cpu(cpu, &irq_enabled_cpus)) {\n\t\t\t \n\t\t\tenable_irq(octeon_wdt_cpu_to_irq(cpu));\n\t\t\tcpumask_set_cpu(cpu, &irq_enabled_cpus);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void octeon_wdt_calc_parameters(int t)\n{\n\tunsigned int periods;\n\n\ttimeout_sec = max_timeout_sec;\n\n\n\t \n\twhile ((t % timeout_sec) != 0)\n\t\ttimeout_sec--;\n\n\tperiods = t / timeout_sec;\n\n\t \n\n\tcountdown_reset = periods > 2 ? periods - 2 : 0;\n\theartbeat = t;\n\ttimeout_cnt = ((octeon_get_io_clock_rate() / divisor) * timeout_sec) >> 8;\n}\n\nstatic int octeon_wdt_set_timeout(struct watchdog_device *wdog,\n\t\t\t\t  unsigned int t)\n{\n\tint cpu;\n\tint coreid;\n\tunion cvmx_ciu_wdogx ciu_wdog;\n\tint node;\n\n\tif (t <= 0)\n\t\treturn -1;\n\n\tocteon_wdt_calc_parameters(t);\n\n\tif (disable)\n\t\treturn 0;\n\n\tfor_each_online_cpu(cpu) {\n\t\tcoreid = cpu2core(cpu);\n\t\tnode = cpu_to_node(cpu);\n\t\tcvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);\n\t\tciu_wdog.u64 = 0;\n\t\tciu_wdog.s.len = timeout_cnt;\n\t\tciu_wdog.s.mode = 3;\t \n\t\tcvmx_write_csr_node(node, CVMX_CIU_WDOGX(coreid), ciu_wdog.u64);\n\t\tcvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);\n\t}\n\tocteon_wdt_ping(wdog);  \n\treturn 0;\n}\n\nstatic int octeon_wdt_start(struct watchdog_device *wdog)\n{\n\tocteon_wdt_ping(wdog);\n\tdo_countdown = 1;\n\treturn 0;\n}\n\nstatic int octeon_wdt_stop(struct watchdog_device *wdog)\n{\n\tdo_countdown = 0;\n\tocteon_wdt_ping(wdog);\n\treturn 0;\n}\n\nstatic const struct watchdog_info octeon_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"OCTEON\",\n};\n\nstatic const struct watchdog_ops octeon_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= octeon_wdt_start,\n\t.stop\t\t= octeon_wdt_stop,\n\t.ping\t\t= octeon_wdt_ping,\n\t.set_timeout\t= octeon_wdt_set_timeout,\n};\n\nstatic struct watchdog_device octeon_wdt = {\n\t.info\t= &octeon_wdt_info,\n\t.ops\t= &octeon_wdt_ops,\n};\n\nstatic enum cpuhp_state octeon_wdt_online;\n \nstatic int __init octeon_wdt_init(void)\n{\n\tint ret;\n\n\tocteon_wdt_bootvector = cvmx_boot_vector_get();\n\tif (!octeon_wdt_bootvector) {\n\t\tpr_err(\"Error: Cannot allocate boot vector.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (OCTEON_IS_MODEL(OCTEON_CN68XX))\n\t\tdivisor = 0x200;\n\telse if (OCTEON_IS_MODEL(OCTEON_CN78XX))\n\t\tdivisor = 0x400;\n\telse\n\t\tdivisor = 0x100;\n\n\t \n\tmax_timeout_sec = 6;\n\tdo {\n\t\tmax_timeout_sec--;\n\t\ttimeout_cnt = ((octeon_get_io_clock_rate() / divisor) * max_timeout_sec) >> 8;\n\t} while (timeout_cnt > 65535);\n\n\tBUG_ON(timeout_cnt == 0);\n\n\tocteon_wdt_calc_parameters(heartbeat);\n\n\tpr_info(\"Initial granularity %d Sec\\n\", timeout_sec);\n\n\tocteon_wdt.timeout\t= timeout_sec;\n\tocteon_wdt.max_timeout\t= UINT_MAX;\n\n\twatchdog_set_nowayout(&octeon_wdt, nowayout);\n\n\tret = watchdog_register_device(&octeon_wdt);\n\tif (ret) {\n\t\tpr_err(\"watchdog_register_device() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (disable) {\n\t\tpr_notice(\"disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tcpumask_clear(&irq_enabled_cpus);\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"watchdog/octeon:online\",\n\t\t\t\tocteon_wdt_cpu_online, octeon_wdt_cpu_pre_down);\n\tif (ret < 0)\n\t\tgoto err;\n\tocteon_wdt_online = ret;\n\treturn 0;\nerr:\n\tcvmx_write_csr(CVMX_MIO_BOOT_LOC_CFGX(0), 0);\n\twatchdog_unregister_device(&octeon_wdt);\n\treturn ret;\n}\n\n \nstatic void __exit octeon_wdt_cleanup(void)\n{\n\twatchdog_unregister_device(&octeon_wdt);\n\n\tif (disable)\n\t\treturn;\n\n\tcpuhp_remove_state(octeon_wdt_online);\n\n\t \n\tcvmx_write_csr(CVMX_MIO_BOOT_LOC_CFGX(0), 0);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cavium Inc. <support@cavium.com>\");\nMODULE_DESCRIPTION(\"Cavium Inc. OCTEON Watchdog driver.\");\nmodule_init(octeon_wdt_init);\nmodule_exit(octeon_wdt_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}