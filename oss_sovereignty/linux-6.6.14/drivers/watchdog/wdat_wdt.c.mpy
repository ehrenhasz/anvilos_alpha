{
  "module_name": "wdat_wdt.c",
  "hash_id": "fe05d30d4639c745d322cb39e2d560c98fe7730ab0c3473269676f1d6a4b29f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/wdat_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/watchdog.h>\n\n#define MAX_WDAT_ACTIONS ACPI_WDAT_ACTION_RESERVED\n\n \nstruct wdat_instruction {\n\tstruct acpi_wdat_entry entry;\n\tvoid __iomem *reg;\n\tstruct list_head node;\n};\n\n \nstruct wdat_wdt {\n\tstruct platform_device *pdev;\n\tstruct watchdog_device wdd;\n\tunsigned int period;\n\tbool stopped_in_sleep;\n\tbool stopped;\n\tstruct list_head *instructions[MAX_WDAT_ACTIONS];\n};\n\n#define to_wdat_wdt(wdd) container_of(wdd, struct wdat_wdt, wdd)\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n#define WDAT_DEFAULT_TIMEOUT\t30\n\nstatic int timeout = WDAT_DEFAULT_TIMEOUT;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds (default=\"\n\t\t __MODULE_STRING(WDAT_DEFAULT_TIMEOUT) \")\");\n\nstatic int wdat_wdt_read(struct wdat_wdt *wdat,\n\t const struct wdat_instruction *instr, u32 *value)\n{\n\tconst struct acpi_generic_address *gas = &instr->entry.register_region;\n\n\tswitch (gas->access_width) {\n\tcase 1:\n\t\t*value = ioread8(instr->reg);\n\t\tbreak;\n\tcase 2:\n\t\t*value = ioread16(instr->reg);\n\t\tbreak;\n\tcase 3:\n\t\t*value = ioread32(instr->reg);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&wdat->pdev->dev, \"Read %#x from 0x%08llx\\n\", *value,\n\t\tgas->address);\n\n\treturn 0;\n}\n\nstatic int wdat_wdt_write(struct wdat_wdt *wdat,\n\tconst struct wdat_instruction *instr, u32 value)\n{\n\tconst struct acpi_generic_address *gas = &instr->entry.register_region;\n\n\tswitch (gas->access_width) {\n\tcase 1:\n\t\tiowrite8((u8)value, instr->reg);\n\t\tbreak;\n\tcase 2:\n\t\tiowrite16((u16)value, instr->reg);\n\t\tbreak;\n\tcase 3:\n\t\tiowrite32(value, instr->reg);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&wdat->pdev->dev, \"Wrote %#x to 0x%08llx\\n\", value,\n\t\tgas->address);\n\n\treturn 0;\n}\n\nstatic int wdat_wdt_run_action(struct wdat_wdt *wdat, unsigned int action,\n\t\t\t       u32 param, u32 *retval)\n{\n\tstruct wdat_instruction *instr;\n\n\tif (action >= ARRAY_SIZE(wdat->instructions))\n\t\treturn -EINVAL;\n\n\tif (!wdat->instructions[action])\n\t\treturn -EOPNOTSUPP;\n\n\tdev_dbg(&wdat->pdev->dev, \"Running action %#x\\n\", action);\n\n\t \n\tlist_for_each_entry(instr, wdat->instructions[action], node) {\n\t\tconst struct acpi_wdat_entry *entry = &instr->entry;\n\t\tconst struct acpi_generic_address *gas;\n\t\tu32 flags, value, mask, x, y;\n\t\tbool preserve;\n\t\tint ret;\n\n\t\tgas = &entry->register_region;\n\n\t\tpreserve = entry->instruction & ACPI_WDAT_PRESERVE_REGISTER;\n\t\tflags = entry->instruction & ~ACPI_WDAT_PRESERVE_REGISTER;\n\t\tvalue = entry->value;\n\t\tmask = entry->mask;\n\n\t\tswitch (flags) {\n\t\tcase ACPI_WDAT_READ_VALUE:\n\t\t\tret = wdat_wdt_read(wdat, instr, &x);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tx >>= gas->bit_offset;\n\t\t\tx &= mask;\n\t\t\tif (retval)\n\t\t\t\t*retval = x == value;\n\t\t\tbreak;\n\n\t\tcase ACPI_WDAT_READ_COUNTDOWN:\n\t\t\tret = wdat_wdt_read(wdat, instr, &x);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tx >>= gas->bit_offset;\n\t\t\tx &= mask;\n\t\t\tif (retval)\n\t\t\t\t*retval = x;\n\t\t\tbreak;\n\n\t\tcase ACPI_WDAT_WRITE_VALUE:\n\t\t\tx = value & mask;\n\t\t\tx <<= gas->bit_offset;\n\t\t\tif (preserve) {\n\t\t\t\tret = wdat_wdt_read(wdat, instr, &y);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\ty = y & ~(mask << gas->bit_offset);\n\t\t\t\tx |= y;\n\t\t\t}\n\t\t\tret = wdat_wdt_write(wdat, instr, x);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase ACPI_WDAT_WRITE_COUNTDOWN:\n\t\t\tx = param;\n\t\t\tx &= mask;\n\t\t\tx <<= gas->bit_offset;\n\t\t\tif (preserve) {\n\t\t\t\tret = wdat_wdt_read(wdat, instr, &y);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\ty = y & ~(mask << gas->bit_offset);\n\t\t\t\tx |= y;\n\t\t\t}\n\t\t\tret = wdat_wdt_write(wdat, instr, x);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&wdat->pdev->dev, \"Unknown instruction: %u\\n\",\n\t\t\t\tflags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wdat_wdt_enable_reboot(struct wdat_wdt *wdat)\n{\n\tint ret;\n\n\t \n\tret = wdat_wdt_run_action(wdat, ACPI_WDAT_SET_REBOOT, 0, NULL);\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tdev_err(&wdat->pdev->dev,\n\t\t\t\"Failed to enable reboot when watchdog triggers\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void wdat_wdt_boot_status(struct wdat_wdt *wdat)\n{\n\tu32 boot_status = 0;\n\tint ret;\n\n\tret = wdat_wdt_run_action(wdat, ACPI_WDAT_GET_STATUS, 0, &boot_status);\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tdev_err(&wdat->pdev->dev, \"Failed to read boot status\\n\");\n\t\treturn;\n\t}\n\n\tif (boot_status)\n\t\twdat->wdd.bootstatus = WDIOF_CARDRESET;\n\n\t \n\tret = wdat_wdt_run_action(wdat, ACPI_WDAT_SET_STATUS, 0, NULL);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tdev_err(&wdat->pdev->dev, \"Failed to clear boot status\\n\");\n}\n\nstatic void wdat_wdt_set_running(struct wdat_wdt *wdat)\n{\n\tu32 running = 0;\n\tint ret;\n\n\tret = wdat_wdt_run_action(wdat, ACPI_WDAT_GET_RUNNING_STATE, 0,\n\t\t\t\t  &running);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tdev_err(&wdat->pdev->dev, \"Failed to read running state\\n\");\n\n\tif (running)\n\t\tset_bit(WDOG_HW_RUNNING, &wdat->wdd.status);\n}\n\nstatic int wdat_wdt_start(struct watchdog_device *wdd)\n{\n\treturn wdat_wdt_run_action(to_wdat_wdt(wdd),\n\t\t\t\t   ACPI_WDAT_SET_RUNNING_STATE, 0, NULL);\n}\n\nstatic int wdat_wdt_stop(struct watchdog_device *wdd)\n{\n\treturn wdat_wdt_run_action(to_wdat_wdt(wdd),\n\t\t\t\t   ACPI_WDAT_SET_STOPPED_STATE, 0, NULL);\n}\n\nstatic int wdat_wdt_ping(struct watchdog_device *wdd)\n{\n\treturn wdat_wdt_run_action(to_wdat_wdt(wdd), ACPI_WDAT_RESET, 0, NULL);\n}\n\nstatic int wdat_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\tunsigned int timeout)\n{\n\tstruct wdat_wdt *wdat = to_wdat_wdt(wdd);\n\tunsigned int periods;\n\tint ret;\n\n\tperiods = timeout * 1000 / wdat->period;\n\tret = wdat_wdt_run_action(wdat, ACPI_WDAT_SET_COUNTDOWN, periods, NULL);\n\tif (!ret)\n\t\twdd->timeout = timeout;\n\treturn ret;\n}\n\nstatic unsigned int wdat_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct wdat_wdt *wdat = to_wdat_wdt(wdd);\n\tu32 periods = 0;\n\n\twdat_wdt_run_action(wdat, ACPI_WDAT_GET_CURRENT_COUNTDOWN, 0, &periods);\n\treturn periods * wdat->period / 1000;\n}\n\nstatic const struct watchdog_info wdat_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.firmware_version = 0,\n\t.identity = \"wdat_wdt\",\n};\n\nstatic struct watchdog_ops wdat_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = wdat_wdt_start,\n\t.stop = wdat_wdt_stop,\n\t.ping = wdat_wdt_ping,\n\t.set_timeout = wdat_wdt_set_timeout,\n};\n\nstatic int wdat_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct acpi_wdat_entry *entries;\n\tconst struct acpi_table_wdat *tbl;\n\tstruct wdat_wdt *wdat;\n\tstruct resource *res;\n\tvoid __iomem **regs;\n\tacpi_status status;\n\tint i, ret;\n\n\tstatus = acpi_get_table(ACPI_SIG_WDAT, 0,\n\t\t\t\t(struct acpi_table_header **)&tbl);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\twdat = devm_kzalloc(dev, sizeof(*wdat), GFP_KERNEL);\n\tif (!wdat)\n\t\treturn -ENOMEM;\n\n\tregs = devm_kcalloc(dev, pdev->num_resources, sizeof(*regs),\n\t\t\t    GFP_KERNEL);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\t \n\tif (tbl->timer_period < 1)\n\t\treturn -EINVAL;\n\tif (tbl->min_count > tbl->max_count)\n\t\treturn -EINVAL;\n\n\twdat->period = tbl->timer_period;\n\twdat->wdd.min_timeout = DIV_ROUND_UP(wdat->period * tbl->min_count, 1000);\n\twdat->wdd.max_timeout = wdat->period * tbl->max_count / 1000;\n\twdat->stopped_in_sleep = tbl->flags & ACPI_WDAT_STOPPED;\n\twdat->wdd.info = &wdat_wdt_info;\n\twdat->wdd.ops = &wdat_wdt_ops;\n\twdat->pdev = pdev;\n\n\t \n\tfor (i = 0; i < pdev->num_resources; i++) {\n\t\tvoid __iomem *reg;\n\n\t\tres = &pdev->resource[i];\n\t\tif (resource_type(res) == IORESOURCE_MEM) {\n\t\t\treg = devm_ioremap_resource(dev, res);\n\t\t\tif (IS_ERR(reg))\n\t\t\t\treturn PTR_ERR(reg);\n\t\t} else if (resource_type(res) == IORESOURCE_IO) {\n\t\t\treg = devm_ioport_map(dev, res->start, 1);\n\t\t\tif (!reg)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tdev_err(dev, \"Unsupported resource\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregs[i] = reg;\n\t}\n\n\tentries = (struct acpi_wdat_entry *)(tbl + 1);\n\tfor (i = 0; i < tbl->entries; i++) {\n\t\tconst struct acpi_generic_address *gas;\n\t\tstruct wdat_instruction *instr;\n\t\tstruct list_head *instructions;\n\t\tunsigned int action;\n\t\tstruct resource r;\n\t\tint j;\n\n\t\taction = entries[i].action;\n\t\tif (action >= MAX_WDAT_ACTIONS) {\n\t\t\tdev_dbg(dev, \"Skipping unknown action: %u\\n\", action);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinstr = devm_kzalloc(dev, sizeof(*instr), GFP_KERNEL);\n\t\tif (!instr)\n\t\t\treturn -ENOMEM;\n\n\t\tINIT_LIST_HEAD(&instr->node);\n\t\tinstr->entry = entries[i];\n\n\t\tgas = &entries[i].register_region;\n\n\t\tmemset(&r, 0, sizeof(r));\n\t\tr.start = gas->address;\n\t\tr.end = r.start + ACPI_ACCESS_BYTE_WIDTH(gas->access_width) - 1;\n\t\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n\t\t\tr.flags = IORESOURCE_MEM;\n\t\t} else if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\n\t\t\tr.flags = IORESOURCE_IO;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"Unsupported address space: %d\\n\",\n\t\t\t\tgas->space_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < pdev->num_resources; j++) {\n\t\t\tres = &pdev->resource[j];\n\t\t\tif (resource_contains(res, &r)) {\n\t\t\t\tinstr->reg = regs[j] + r.start - res->start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!instr->reg) {\n\t\t\tdev_err(dev, \"I/O resource not found\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinstructions = wdat->instructions[action];\n\t\tif (!instructions) {\n\t\t\tinstructions = devm_kzalloc(dev,\n\t\t\t\t\t\t    sizeof(*instructions),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (!instructions)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tINIT_LIST_HEAD(instructions);\n\t\t\twdat->instructions[action] = instructions;\n\t\t}\n\n\t\tlist_add_tail(&instr->node, instructions);\n\t}\n\n\tif (wdat->instructions[ACPI_WDAT_GET_CURRENT_COUNTDOWN])\n\t\twdat_wdt_ops.get_timeleft = wdat_wdt_get_timeleft;\n\n\twdat_wdt_boot_status(wdat);\n\twdat_wdt_set_running(wdat);\n\n\tret = wdat_wdt_enable_reboot(wdat);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdat);\n\n\t \n\tif (watchdog_timeout_invalid(&wdat->wdd, timeout)) {\n\t\tdev_warn(dev, \"Invalid timeout %d given, using %d\\n\",\n\t\t\t timeout, WDAT_DEFAULT_TIMEOUT);\n\t\ttimeout = WDAT_DEFAULT_TIMEOUT;\n\t}\n\n\tret = wdat_wdt_set_timeout(&wdat->wdd, timeout);\n\tif (ret)\n\t\treturn ret;\n\n\twatchdog_set_nowayout(&wdat->wdd, nowayout);\n\twatchdog_stop_on_reboot(&wdat->wdd);\n\twatchdog_stop_on_unregister(&wdat->wdd);\n\treturn devm_watchdog_register_device(dev, &wdat->wdd);\n}\n\nstatic int wdat_wdt_suspend_noirq(struct device *dev)\n{\n\tstruct wdat_wdt *wdat = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!watchdog_active(&wdat->wdd))\n\t\treturn 0;\n\n\t \n\twdat->stopped = false;\n\tif (acpi_target_system_state() == ACPI_STATE_S0 ||\n\t    !wdat->stopped_in_sleep) {\n\t\tret = wdat_wdt_stop(&wdat->wdd);\n\t\tif (!ret)\n\t\t\twdat->stopped = true;\n\t} else {\n\t\tret = wdat_wdt_ping(&wdat->wdd);\n\t}\n\n\treturn ret;\n}\n\nstatic int wdat_wdt_resume_noirq(struct device *dev)\n{\n\tstruct wdat_wdt *wdat = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!watchdog_active(&wdat->wdd))\n\t\treturn 0;\n\n\tif (!wdat->stopped) {\n\t\t \n\t\tret = wdat_wdt_stop(&wdat->wdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = wdat_wdt_set_timeout(&wdat->wdd, wdat->wdd.timeout);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = wdat_wdt_enable_reboot(wdat);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = wdat_wdt_ping(&wdat->wdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn wdat_wdt_start(&wdat->wdd);\n}\n\nstatic const struct dev_pm_ops wdat_wdt_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(wdat_wdt_suspend_noirq, wdat_wdt_resume_noirq)\n};\n\nstatic struct platform_driver wdat_wdt_driver = {\n\t.probe = wdat_wdt_probe,\n\t.driver = {\n\t\t.name = \"wdat_wdt\",\n\t\t.pm = pm_sleep_ptr(&wdat_wdt_pm_ops),\n\t},\n};\n\nmodule_platform_driver(wdat_wdt_driver);\n\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_DESCRIPTION(\"ACPI Hardware Watchdog (WDAT) driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:wdat_wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}