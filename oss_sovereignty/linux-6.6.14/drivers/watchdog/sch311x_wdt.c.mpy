{
  "module_name": "sch311x_wdt.c",
  "hash_id": "da535db625585d10fb39a566c98d75e521ba55e27d93d8a4a212f44a3c3bcef3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sch311x_wdt.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n \n#include <linux/module.h>\t\t \n#include <linux/moduleparam.h>\t\t \n#include <linux/types.h>\t\t \n#include <linux/errno.h>\t\t \n#include <linux/kernel.h>\t\t \n#include <linux/miscdevice.h>\t\t \n#include <linux/watchdog.h>\t\t \n#include <linux/init.h>\t\t\t \n#include <linux/fs.h>\t\t\t \n#include <linux/platform_device.h>\t \n#include <linux/ioport.h>\t\t \n#include <linux/spinlock.h>\t\t \n#include <linux/uaccess.h>\t\t \n#include <linux/io.h>\t\t\t \n\n \n#define DRV_NAME\t\"sch311x_wdt\"\n\n \n#define GP60\t\t\t0x47\n#define WDT_TIME_OUT\t\t0x65\n#define WDT_VAL\t\t\t0x66\n#define WDT_CFG\t\t\t0x67\n#define WDT_CTRL\t\t0x68\n\n \nstatic unsigned long sch311x_wdt_is_open;\nstatic char sch311x_wdt_expect_close;\nstatic struct platform_device *sch311x_wdt_pdev;\n\nstatic int sch311x_ioports[] = { 0x2e, 0x4e, 0x162e, 0x164e, 0x00 };\n\nstatic struct {\t \n\t \n\tunsigned short runtime_reg;\n\t \n\tint boot_status;\n\t \n\tspinlock_t io_lock;\n} sch311x_wdt_data;\n\n \nstatic unsigned short force_id;\nmodule_param(force_id, ushort, 0);\nMODULE_PARM_DESC(force_id, \"Override the detected device ID\");\n\n#define WATCHDOG_TIMEOUT 60\t\t \nstatic int timeout = WATCHDOG_TIMEOUT;\t \nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\"Watchdog timeout in seconds. 1<= timeout <=15300, default=\"\n\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \".\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n\nstatic inline void sch311x_sio_enter(int sio_config_port)\n{\n\toutb(0x55, sio_config_port);\n}\n\nstatic inline void sch311x_sio_exit(int sio_config_port)\n{\n\toutb(0xaa, sio_config_port);\n}\n\nstatic inline int sch311x_sio_inb(int sio_config_port, int reg)\n{\n\toutb(reg, sio_config_port);\n\treturn inb(sio_config_port + 1);\n}\n\nstatic inline void sch311x_sio_outb(int sio_config_port, int reg, int val)\n{\n\toutb(reg, sio_config_port);\n\toutb(val, sio_config_port + 1);\n}\n\n \n\nstatic void sch311x_wdt_set_timeout(int t)\n{\n\tunsigned char timeout_unit = 0x80;\n\n\t \n\tif (t > 255) {\n\t\ttimeout_unit = 0;\n\t\tt /= 60;\n\t}\n\n\t \n\toutb(timeout_unit, sch311x_wdt_data.runtime_reg + WDT_TIME_OUT);\n\n\t \n\toutb(t, sch311x_wdt_data.runtime_reg + WDT_VAL);\n}\n\nstatic void sch311x_wdt_start(void)\n{\n\tunsigned char t;\n\n\tspin_lock(&sch311x_wdt_data.io_lock);\n\n\t \n\tsch311x_wdt_set_timeout(timeout);\n\t \n\t \n\tt = inb(sch311x_wdt_data.runtime_reg + GP60);\n\toutb((t & ~0x0d) | 0x0c, sch311x_wdt_data.runtime_reg + GP60);\n\n\tspin_unlock(&sch311x_wdt_data.io_lock);\n\n}\n\nstatic void sch311x_wdt_stop(void)\n{\n\tunsigned char t;\n\n\tspin_lock(&sch311x_wdt_data.io_lock);\n\n\t \n\tt = inb(sch311x_wdt_data.runtime_reg + GP60);\n\toutb((t & ~0x0d) | 0x01, sch311x_wdt_data.runtime_reg + GP60);\n\t \n\tsch311x_wdt_set_timeout(0);\n\n\tspin_unlock(&sch311x_wdt_data.io_lock);\n}\n\nstatic void sch311x_wdt_keepalive(void)\n{\n\tspin_lock(&sch311x_wdt_data.io_lock);\n\tsch311x_wdt_set_timeout(timeout);\n\tspin_unlock(&sch311x_wdt_data.io_lock);\n}\n\nstatic int sch311x_wdt_set_heartbeat(int t)\n{\n\tif (t < 1 || t > (255*60))\n\t\treturn -EINVAL;\n\n\t \n\tif (t > 255)\n\t\tt = (((t - 1) / 60) + 1) * 60;\n\n\ttimeout = t;\n\treturn 0;\n}\n\nstatic void sch311x_wdt_get_status(int *status)\n{\n\tunsigned char new_status;\n\n\t*status = 0;\n\n\tspin_lock(&sch311x_wdt_data.io_lock);\n\n\t \n\tnew_status = inb(sch311x_wdt_data.runtime_reg + WDT_CTRL);\n\tif (new_status & 0x01)\n\t\t*status |= WDIOF_CARDRESET;\n\n\tspin_unlock(&sch311x_wdt_data.io_lock);\n}\n\n \n\nstatic ssize_t sch311x_wdt_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\tsch311x_wdt_expect_close = 0;\n\n\t\t\tfor (i = 0; i != count; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\tsch311x_wdt_expect_close = 42;\n\t\t\t}\n\t\t}\n\t\tsch311x_wdt_keepalive();\n\t}\n\treturn count;\n}\n\nstatic long sch311x_wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint status;\n\tint new_timeout;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options\t\t= WDIOF_KEEPALIVEPING |\n\t\t\t\t\t  WDIOF_SETTIMEOUT |\n\t\t\t\t\t  WDIOF_MAGICCLOSE,\n\t\t.firmware_version\t= 1,\n\t\t.identity\t\t= DRV_NAME,\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\t{\n\t\tsch311x_wdt_get_status(&status);\n\t\treturn put_user(status, p);\n\t}\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(sch311x_wdt_data.boot_status, p);\n\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint options, retval = -EINVAL;\n\n\t\tif (get_user(options, p))\n\t\t\treturn -EFAULT;\n\t\tif (options & WDIOS_DISABLECARD) {\n\t\t\tsch311x_wdt_stop();\n\t\t\tretval = 0;\n\t\t}\n\t\tif (options & WDIOS_ENABLECARD) {\n\t\t\tsch311x_wdt_start();\n\t\t\tretval = 0;\n\t\t}\n\t\treturn retval;\n\t}\n\tcase WDIOC_KEEPALIVE:\n\t\tsch311x_wdt_keepalive();\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_timeout, p))\n\t\t\treturn -EFAULT;\n\t\tif (sch311x_wdt_set_heartbeat(new_timeout))\n\t\t\treturn -EINVAL;\n\t\tsch311x_wdt_keepalive();\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(timeout, p);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\nstatic int sch311x_wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &sch311x_wdt_is_open))\n\t\treturn -EBUSY;\n\t \n\tsch311x_wdt_start();\n\treturn stream_open(inode, file);\n}\n\nstatic int sch311x_wdt_close(struct inode *inode, struct file *file)\n{\n\tif (sch311x_wdt_expect_close == 42) {\n\t\tsch311x_wdt_stop();\n\t} else {\n\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\tsch311x_wdt_keepalive();\n\t}\n\tclear_bit(0, &sch311x_wdt_is_open);\n\tsch311x_wdt_expect_close = 0;\n\treturn 0;\n}\n\n \n\nstatic const struct file_operations sch311x_wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= sch311x_wdt_write,\n\t.unlocked_ioctl\t= sch311x_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= sch311x_wdt_open,\n\t.release\t= sch311x_wdt_close,\n};\n\nstatic struct miscdevice sch311x_wdt_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &sch311x_wdt_fops,\n};\n\n \n\nstatic int sch311x_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\tspin_lock_init(&sch311x_wdt_data.io_lock);\n\n\tif (!request_region(sch311x_wdt_data.runtime_reg + GP60, 1, DRV_NAME)) {\n\t\tdev_err(dev, \"Failed to request region 0x%04x-0x%04x.\\n\",\n\t\t\tsch311x_wdt_data.runtime_reg + GP60,\n\t\t\tsch311x_wdt_data.runtime_reg + GP60);\n\t\terr = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tif (!request_region(sch311x_wdt_data.runtime_reg + WDT_TIME_OUT, 4,\n\t\t\t\t\t\t\t\tDRV_NAME)) {\n\t\tdev_err(dev, \"Failed to request region 0x%04x-0x%04x.\\n\",\n\t\t\tsch311x_wdt_data.runtime_reg + WDT_TIME_OUT,\n\t\t\tsch311x_wdt_data.runtime_reg + WDT_CTRL);\n\t\terr = -EBUSY;\n\t\tgoto exit_release_region;\n\t}\n\n\t \n\tsch311x_wdt_stop();\n\n\t \n\t \n\toutb(0, sch311x_wdt_data.runtime_reg + WDT_CFG);\n\n\t \n\tif (sch311x_wdt_set_heartbeat(timeout)) {\n\t\tsch311x_wdt_set_heartbeat(WATCHDOG_TIMEOUT);\n\t\tdev_info(dev, \"timeout value must be 1<=x<=15300, using %d\\n\",\n\t\t\ttimeout);\n\t}\n\n\t \n\tsch311x_wdt_get_status(&sch311x_wdt_data.boot_status);\n\n\tsch311x_wdt_miscdev.parent = dev;\n\n\terr = misc_register(&sch311x_wdt_miscdev);\n\tif (err != 0) {\n\t\tdev_err(dev, \"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t\t\t\t\t\tWATCHDOG_MINOR, err);\n\t\tgoto exit_release_region2;\n\t}\n\n\tdev_info(dev,\n\t\t\"SMSC SCH311x WDT initialized. timeout=%d sec (nowayout=%d)\\n\",\n\t\ttimeout, nowayout);\n\n\treturn 0;\n\nexit_release_region2:\n\trelease_region(sch311x_wdt_data.runtime_reg + WDT_TIME_OUT, 4);\nexit_release_region:\n\trelease_region(sch311x_wdt_data.runtime_reg + GP60, 1);\n\tsch311x_wdt_data.runtime_reg = 0;\nexit:\n\treturn err;\n}\n\nstatic void sch311x_wdt_remove(struct platform_device *pdev)\n{\n\t \n\tif (!nowayout)\n\t\tsch311x_wdt_stop();\n\n\t \n\tmisc_deregister(&sch311x_wdt_miscdev);\n\trelease_region(sch311x_wdt_data.runtime_reg + WDT_TIME_OUT, 4);\n\trelease_region(sch311x_wdt_data.runtime_reg + GP60, 1);\n\tsch311x_wdt_data.runtime_reg = 0;\n}\n\nstatic void sch311x_wdt_shutdown(struct platform_device *dev)\n{\n\t \n\tsch311x_wdt_stop();\n}\n\nstatic struct platform_driver sch311x_wdt_driver = {\n\t.probe\t\t= sch311x_wdt_probe,\n\t.remove_new\t= sch311x_wdt_remove,\n\t.shutdown\t= sch311x_wdt_shutdown,\n\t.driver\t\t= {\n\t\t.name = DRV_NAME,\n\t},\n};\n\nstatic int __init sch311x_detect(int sio_config_port, unsigned short *addr)\n{\n\tint err = 0, reg;\n\tunsigned short base_addr;\n\tunsigned char dev_id;\n\n\tsch311x_sio_enter(sio_config_port);\n\n\t \n\treg = force_id ? force_id : sch311x_sio_inb(sio_config_port, 0x20);\n\tif (!(reg == 0x7c || reg == 0x7d || reg == 0x7f)) {\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\tdev_id = reg == 0x7c ? 2 : reg == 0x7d ? 4 : 6;\n\n\t \n\tsch311x_sio_outb(sio_config_port, 0x07, 0x0a);\n\n\t \n\tif ((sch311x_sio_inb(sio_config_port, 0x30) & 0x01) == 0)\n\t\tpr_info(\"Seems that LDN 0x0a is not active...\\n\");\n\n\t \n\tbase_addr = (sch311x_sio_inb(sio_config_port, 0x60) << 8) |\n\t\t\t   sch311x_sio_inb(sio_config_port, 0x61);\n\tif (!base_addr) {\n\t\tpr_err(\"Base address not set\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\t*addr = base_addr;\n\n\tpr_info(\"Found an SMSC SCH311%d chip at 0x%04x\\n\", dev_id, base_addr);\n\nexit:\n\tsch311x_sio_exit(sio_config_port);\n\treturn err;\n}\n\nstatic int __init sch311x_wdt_init(void)\n{\n\tint err, i, found = 0;\n\tunsigned short addr = 0;\n\n\tfor (i = 0; !found && sch311x_ioports[i]; i++)\n\t\tif (sch311x_detect(sch311x_ioports[i], &addr) == 0)\n\t\t\tfound++;\n\n\tif (!found)\n\t\treturn -ENODEV;\n\n\tsch311x_wdt_data.runtime_reg = addr;\n\n\terr = platform_driver_register(&sch311x_wdt_driver);\n\tif (err)\n\t\treturn err;\n\n\tsch311x_wdt_pdev = platform_device_register_simple(DRV_NAME, addr,\n\t\t\t\t\t\t\t\tNULL, 0);\n\n\tif (IS_ERR(sch311x_wdt_pdev)) {\n\t\terr = PTR_ERR(sch311x_wdt_pdev);\n\t\tgoto unreg_platform_driver;\n\t}\n\n\treturn 0;\n\nunreg_platform_driver:\n\tplatform_driver_unregister(&sch311x_wdt_driver);\n\treturn err;\n}\n\nstatic void __exit sch311x_wdt_exit(void)\n{\n\tplatform_device_unregister(sch311x_wdt_pdev);\n\tplatform_driver_unregister(&sch311x_wdt_driver);\n}\n\nmodule_init(sch311x_wdt_init);\nmodule_exit(sch311x_wdt_exit);\n\nMODULE_AUTHOR(\"Wim Van Sebroeck <wim@iguana.be>\");\nMODULE_DESCRIPTION(\"SMSC SCH311x WatchDog Timer Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}