{
  "module_name": "da9052_wdt.c",
  "hash_id": "2704bb86ff8aa5e39dc9187f5d4528460042e586978f87589923c1ad0eebffe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/da9052_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/platform_device.h>\n#include <linux/time.h>\n#include <linux/watchdog.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n\n#include <linux/mfd/da9052/reg.h>\n#include <linux/mfd/da9052/da9052.h>\n\n#define DA9052_DEF_TIMEOUT\t4\n#define DA9052_TWDMIN\t\t256\n\nstruct da9052_wdt_data {\n\tstruct watchdog_device wdt;\n\tstruct da9052 *da9052;\n\tunsigned long jpast;\n};\n\nstatic const struct {\n\tu8 reg_val;\n\tint time;   \n} da9052_wdt_maps[] = {\n\t{ 1, 2 },\n\t{ 2, 4 },\n\t{ 3, 8 },\n\t{ 4, 16 },\n\t{ 5, 32 },\n\t{ 5, 33 },   \n\t{ 6, 65 },\n\t{ 6, 66 },   \n\t{ 7, 131 },\n};\n\n\nstatic int da9052_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct da9052_wdt_data *driver_data = watchdog_get_drvdata(wdt_dev);\n\tstruct da9052 *da9052 = driver_data->da9052;\n\tint ret, i;\n\n\t \n\tret = da9052_reg_update(da9052, DA9052_CONTROL_D_REG,\n\t\t\t\tDA9052_CONTROLD_TWDSCALE, 0);\n\tif (ret < 0) {\n\t\tdev_err(da9052->dev, \"Failed to disable watchdog bit, %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tif (timeout) {\n\t\t \n\t\tudelay(150);\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(da9052_wdt_maps); i++)\n\t\t\tif (da9052_wdt_maps[i].time == timeout)\n\t\t\t\tbreak;\n\n\t\tif (i == ARRAY_SIZE(da9052_wdt_maps))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = da9052_reg_update(da9052, DA9052_CONTROL_D_REG,\n\t\t\t\t\t\tDA9052_CONTROLD_TWDSCALE,\n\t\t\t\t\t\tda9052_wdt_maps[i].reg_val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(da9052->dev,\n\t\t\t\t\"Failed to update timescale bit, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\twdt_dev->timeout = timeout;\n\t\tdriver_data->jpast = jiffies;\n\t}\n\n\treturn 0;\n}\n\nstatic int da9052_wdt_start(struct watchdog_device *wdt_dev)\n{\n\treturn da9052_wdt_set_timeout(wdt_dev, wdt_dev->timeout);\n}\n\nstatic int da9052_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\treturn da9052_wdt_set_timeout(wdt_dev, 0);\n}\n\nstatic int da9052_wdt_ping(struct watchdog_device *wdt_dev)\n{\n\tstruct da9052_wdt_data *driver_data = watchdog_get_drvdata(wdt_dev);\n\tstruct da9052 *da9052 = driver_data->da9052;\n\tunsigned long msec, jnow = jiffies;\n\tint ret;\n\n\t \n\tmsec = (jnow - driver_data->jpast) * 1000/HZ;\n\tif (msec < DA9052_TWDMIN)\n\t\tmdelay(msec);\n\n\t \n\tret = da9052_reg_update(da9052, DA9052_CONTROL_D_REG,\n\t\t\t\tDA9052_CONTROLD_WATCHDOG, 1 << 7);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn da9052_reg_update(da9052, DA9052_CONTROL_D_REG,\n\t\t\t\t DA9052_CONTROLD_WATCHDOG, 0 << 7);\n}\n\nstatic const struct watchdog_info da9052_wdt_info = {\n\t.options\t= WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n\t.identity\t= \"DA9052 Watchdog\",\n};\n\nstatic const struct watchdog_ops da9052_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = da9052_wdt_start,\n\t.stop = da9052_wdt_stop,\n\t.ping = da9052_wdt_ping,\n\t.set_timeout = da9052_wdt_set_timeout,\n};\n\n\nstatic int da9052_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da9052 *da9052 = dev_get_drvdata(dev->parent);\n\tstruct da9052_wdt_data *driver_data;\n\tstruct watchdog_device *da9052_wdt;\n\tint ret;\n\n\tdriver_data = devm_kzalloc(dev, sizeof(*driver_data), GFP_KERNEL);\n\tif (!driver_data)\n\t\treturn -ENOMEM;\n\tdriver_data->da9052 = da9052;\n\n\tda9052_wdt = &driver_data->wdt;\n\n\tda9052_wdt->timeout = DA9052_DEF_TIMEOUT;\n\tda9052_wdt->info = &da9052_wdt_info;\n\tda9052_wdt->ops = &da9052_wdt_ops;\n\tda9052_wdt->parent = dev;\n\twatchdog_set_drvdata(da9052_wdt, driver_data);\n\n\tret = da9052_reg_update(da9052, DA9052_CONTROL_D_REG,\n\t\t\t\tDA9052_CONTROLD_TWDSCALE, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to disable watchdog bits, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_watchdog_register_device(dev, &driver_data->wdt);\n}\n\nstatic struct platform_driver da9052_wdt_driver = {\n\t.probe = da9052_wdt_probe,\n\t.driver = {\n\t\t.name\t= \"da9052-watchdog\",\n\t},\n};\n\nmodule_platform_driver(da9052_wdt_driver);\n\nMODULE_AUTHOR(\"Anthony Olech <Anthony.Olech@diasemi.com>\");\nMODULE_DESCRIPTION(\"DA9052 SM Device Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9052-watchdog\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}