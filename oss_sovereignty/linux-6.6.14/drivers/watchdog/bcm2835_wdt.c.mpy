{
  "module_name": "bcm2835_wdt.c",
  "hash_id": "624b1e58037027d108c5565b51018f3982e128029249c43aa103be05b08eaf68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/bcm2835_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/mfd/bcm2835-pm.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n\n#define PM_RSTC\t\t\t\t0x1c\n#define PM_RSTS\t\t\t\t0x20\n#define PM_WDOG\t\t\t\t0x24\n\n#define PM_PASSWORD\t\t\t0x5a000000\n\n#define PM_WDOG_TIME_SET\t\t0x000fffff\n#define PM_RSTC_WRCFG_CLR\t\t0xffffffcf\n#define PM_RSTS_HADWRH_SET\t\t0x00000040\n#define PM_RSTC_WRCFG_SET\t\t0x00000030\n#define PM_RSTC_WRCFG_FULL_RESET\t0x00000020\n#define PM_RSTC_RESET\t\t\t0x00000102\n\n \n#define PM_RSTS_RASPBERRYPI_HALT\t0x555\n\n#define SECS_TO_WDOG_TICKS(x) ((x) << 16)\n#define WDOG_TICKS_TO_SECS(x) ((x) >> 16)\n#define WDOG_TICKS_TO_MSECS(x) ((x) * 1000 >> 16)\n\nstruct bcm2835_wdt {\n\tvoid __iomem\t\t*base;\n\tspinlock_t\t\tlock;\n};\n\nstatic struct bcm2835_wdt *bcm2835_power_off_wdt;\n\nstatic unsigned int heartbeat;\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\nstatic bool bcm2835_wdt_is_running(struct bcm2835_wdt *wdt)\n{\n\tuint32_t cur;\n\n\tcur = readl(wdt->base + PM_RSTC);\n\n\treturn !!(cur & PM_RSTC_WRCFG_FULL_RESET);\n}\n\nstatic int bcm2835_wdt_start(struct watchdog_device *wdog)\n{\n\tstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\n\tuint32_t cur;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdt->lock, flags);\n\n\twritel_relaxed(PM_PASSWORD | (SECS_TO_WDOG_TICKS(wdog->timeout) &\n\t\t\t\tPM_WDOG_TIME_SET), wdt->base + PM_WDOG);\n\tcur = readl_relaxed(wdt->base + PM_RSTC);\n\twritel_relaxed(PM_PASSWORD | (cur & PM_RSTC_WRCFG_CLR) |\n\t\t  PM_RSTC_WRCFG_FULL_RESET, wdt->base + PM_RSTC);\n\n\tspin_unlock_irqrestore(&wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bcm2835_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\twritel_relaxed(PM_PASSWORD | PM_RSTC_RESET, wdt->base + PM_RSTC);\n\treturn 0;\n}\n\nstatic unsigned int bcm2835_wdt_get_timeleft(struct watchdog_device *wdog)\n{\n\tstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\tuint32_t ret = readl_relaxed(wdt->base + PM_WDOG);\n\treturn WDOG_TICKS_TO_SECS(ret & PM_WDOG_TIME_SET);\n}\n\nstatic void __bcm2835_restart(struct bcm2835_wdt *wdt)\n{\n\tu32 val;\n\n\t \n\twritel_relaxed(10 | PM_PASSWORD, wdt->base + PM_WDOG);\n\tval = readl_relaxed(wdt->base + PM_RSTC);\n\tval &= PM_RSTC_WRCFG_CLR;\n\tval |= PM_PASSWORD | PM_RSTC_WRCFG_FULL_RESET;\n\twritel_relaxed(val, wdt->base + PM_RSTC);\n\n\t \n\tmdelay(1);\n}\n\nstatic int bcm2835_restart(struct watchdog_device *wdog,\n\t\t\t   unsigned long action, void *data)\n{\n\tstruct bcm2835_wdt *wdt = watchdog_get_drvdata(wdog);\n\n\t__bcm2835_restart(wdt);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops bcm2835_wdt_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.start =\tbcm2835_wdt_start,\n\t.stop =\t\tbcm2835_wdt_stop,\n\t.get_timeleft =\tbcm2835_wdt_get_timeleft,\n\t.restart =\tbcm2835_restart,\n};\n\nstatic const struct watchdog_info bcm2835_wdt_info = {\n\t.options =\tWDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE |\n\t\t\tWDIOF_KEEPALIVEPING,\n\t.identity =\t\"Broadcom BCM2835 Watchdog timer\",\n};\n\nstatic struct watchdog_device bcm2835_wdt_wdd = {\n\t.info =\t\t&bcm2835_wdt_info,\n\t.ops =\t\t&bcm2835_wdt_ops,\n\t.min_timeout =\t1,\n\t.max_hw_heartbeat_ms =\tWDOG_TICKS_TO_MSECS(PM_WDOG_TIME_SET),\n\t.timeout =\tWDOG_TICKS_TO_SECS(PM_WDOG_TIME_SET),\n};\n\n \nstatic void bcm2835_power_off(void)\n{\n\tstruct bcm2835_wdt *wdt = bcm2835_power_off_wdt;\n\tu32 val;\n\n\t \n\tval = readl_relaxed(wdt->base + PM_RSTS);\n\tval |= PM_PASSWORD | PM_RSTS_RASPBERRYPI_HALT;\n\twritel_relaxed(val, wdt->base + PM_RSTS);\n\n\t \n\t__bcm2835_restart(wdt);\n}\n\nstatic int bcm2835_wdt_probe(struct platform_device *pdev)\n{\n\tstruct bcm2835_pm *pm = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm2835_wdt *wdt;\n\tint err;\n\n\twdt = devm_kzalloc(dev, sizeof(struct bcm2835_wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&wdt->lock);\n\n\twdt->base = pm->base;\n\n\twatchdog_set_drvdata(&bcm2835_wdt_wdd, wdt);\n\twatchdog_init_timeout(&bcm2835_wdt_wdd, heartbeat, dev);\n\twatchdog_set_nowayout(&bcm2835_wdt_wdd, nowayout);\n\tbcm2835_wdt_wdd.parent = dev;\n\tif (bcm2835_wdt_is_running(wdt)) {\n\t\t \n\t\tset_bit(WDOG_HW_RUNNING, &bcm2835_wdt_wdd.status);\n\t}\n\n\twatchdog_set_restart_priority(&bcm2835_wdt_wdd, 128);\n\n\twatchdog_stop_on_reboot(&bcm2835_wdt_wdd);\n\terr = devm_watchdog_register_device(dev, &bcm2835_wdt_wdd);\n\tif (err)\n\t\treturn err;\n\n\tif (of_device_is_system_power_controller(pdev->dev.parent->of_node)) {\n\t\tif (!pm_power_off) {\n\t\t\tpm_power_off = bcm2835_power_off;\n\t\t\tbcm2835_power_off_wdt = wdt;\n\t\t} else {\n\t\t\tdev_info(dev, \"Poweroff handler already present!\\n\");\n\t\t}\n\t}\n\n\tdev_info(dev, \"Broadcom BCM2835 watchdog timer\");\n\treturn 0;\n}\n\nstatic void bcm2835_wdt_remove(struct platform_device *pdev)\n{\n\tif (pm_power_off == bcm2835_power_off)\n\t\tpm_power_off = NULL;\n}\n\nstatic struct platform_driver bcm2835_wdt_driver = {\n\t.probe\t\t= bcm2835_wdt_probe,\n\t.remove_new\t= bcm2835_wdt_remove,\n\t.driver = {\n\t\t.name =\t\t\"bcm2835-wdt\",\n\t},\n};\nmodule_platform_driver(bcm2835_wdt_driver);\n\nmodule_param(heartbeat, uint, 0);\nMODULE_PARM_DESC(heartbeat, \"Initial watchdog heartbeat in seconds\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nMODULE_ALIAS(\"platform:bcm2835-wdt\");\nMODULE_AUTHOR(\"Lubomir Rintel <lkundrak@v3.sk>\");\nMODULE_DESCRIPTION(\"Driver for Broadcom BCM2835 watchdog timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}