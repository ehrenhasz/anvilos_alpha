{
  "module_name": "rzg2l_wdt.c",
  "hash_id": "40ca4f0aee764754b501f47ea63b94926dc82ef73a69218570b73dfee450548a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rzg2l_wdt.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/units.h>\n#include <linux/watchdog.h>\n\n#define WDTCNT\t\t0x00\n#define WDTSET\t\t0x04\n#define WDTTIM\t\t0x08\n#define WDTINT\t\t0x0C\n#define PECR\t\t0x10\n#define PEEN\t\t0x14\n#define WDTCNT_WDTEN\tBIT(0)\n#define WDTINT_INTDISP\tBIT(0)\n#define PEEN_FORCE\tBIT(0)\n\n#define WDT_DEFAULT_TIMEOUT\t\t60U\n\n \n#define WDTSET_COUNTER_MASK\t\t(0xFFF00000)\n#define WDTSET_COUNTER_VAL(f)\t\t((f) << 20)\n\n#define F2CYCLE_NSEC(f)\t\t\t(1000000000 / (f))\n\n#define RZV2M_A_NSEC\t\t\t730\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nenum rz_wdt_type {\n\tWDT_RZG2L,\n\tWDT_RZV2M,\n};\n\nstruct rzg2l_wdt_priv {\n\tvoid __iomem *base;\n\tstruct watchdog_device wdev;\n\tstruct reset_control *rstc;\n\tunsigned long osc_clk_rate;\n\tunsigned long delay;\n\tunsigned long minimum_assertion_period;\n\tstruct clk *pclk;\n\tstruct clk *osc_clk;\n\tenum rz_wdt_type devtype;\n};\n\nstatic int rzg2l_wdt_reset(struct rzg2l_wdt_priv *priv)\n{\n\tint err, status;\n\n\tif (priv->devtype == WDT_RZV2M) {\n\t\t \n\t\terr = reset_control_assert(priv->rstc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tndelay(priv->minimum_assertion_period);\n\t\terr = reset_control_deassert(priv->rstc);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = read_poll_timeout(reset_control_status, status,\n\t\t\t\t\tstatus != 1, 0, 1000, false,\n\t\t\t\t\tpriv->rstc);\n\t} else {\n\t\terr = reset_control_reset(priv->rstc);\n\t}\n\n\treturn err;\n}\n\nstatic void rzg2l_wdt_wait_delay(struct rzg2l_wdt_priv *priv)\n{\n\t \n\tndelay(priv->delay);\n}\n\nstatic u32 rzg2l_wdt_get_cycle_usec(unsigned long cycle, u32 wdttime)\n{\n\tu64 timer_cycle_us = 1024 * 1024ULL * (wdttime + 1) * MICRO;\n\n\treturn div64_ul(timer_cycle_us, cycle);\n}\n\nstatic void rzg2l_wdt_write(struct rzg2l_wdt_priv *priv, u32 val, unsigned int reg)\n{\n\tif (reg == WDTSET)\n\t\tval &= WDTSET_COUNTER_MASK;\n\n\twritel_relaxed(val, priv->base + reg);\n\t \n\tif (reg != WDTINT)\n\t\trzg2l_wdt_wait_delay(priv);\n}\n\nstatic void rzg2l_wdt_init_timeout(struct watchdog_device *wdev)\n{\n\tstruct rzg2l_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu32 time_out;\n\n\t \n\trzg2l_wdt_write(priv, WDTINT_INTDISP, WDTINT);\n\t \n\ttime_out = (wdev->timeout * (MICRO / 2)) /\n\t\t   rzg2l_wdt_get_cycle_usec(priv->osc_clk_rate, 0);\n\trzg2l_wdt_write(priv, WDTSET_COUNTER_VAL(time_out), WDTSET);\n}\n\nstatic int rzg2l_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct rzg2l_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\tpm_runtime_get_sync(wdev->parent);\n\n\t \n\trzg2l_wdt_init_timeout(wdev);\n\n\t \n\trzg2l_wdt_write(priv, 0, WDTTIM);\n\n\t \n\trzg2l_wdt_write(priv, WDTCNT_WDTEN, WDTCNT);\n\n\treturn 0;\n}\n\nstatic int rzg2l_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct rzg2l_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\trzg2l_wdt_reset(priv);\n\tpm_runtime_put(wdev->parent);\n\n\treturn 0;\n}\n\nstatic int rzg2l_wdt_set_timeout(struct watchdog_device *wdev, unsigned int timeout)\n{\n\twdev->timeout = timeout;\n\n\t \n\tif (watchdog_active(wdev)) {\n\t\trzg2l_wdt_stop(wdev);\n\t\trzg2l_wdt_start(wdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int rzg2l_wdt_restart(struct watchdog_device *wdev,\n\t\t\t     unsigned long action, void *data)\n{\n\tstruct rzg2l_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\tclk_prepare_enable(priv->pclk);\n\tclk_prepare_enable(priv->osc_clk);\n\n\tif (priv->devtype == WDT_RZG2L) {\n\t\t \n\t\trzg2l_wdt_write(priv, 0, PECR);\n\n\t\t \n\t\trzg2l_wdt_write(priv, PEEN_FORCE, PEEN);\n\t} else {\n\t\t \n\t\trzg2l_wdt_reset(priv);\n\n\t\twdev->timeout = 0;\n\n\t\t \n\t\trzg2l_wdt_init_timeout(wdev);\n\n\t\t \n\t\trzg2l_wdt_write(priv, 0, WDTTIM);\n\n\t\t \n\t\trzg2l_wdt_write(priv, WDTCNT_WDTEN, WDTCNT);\n\n\t\t \n\t\tmdelay(DIV_ROUND_UP(2 * 0xFFFFF * 1000, priv->osc_clk_rate));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info rzg2l_wdt_ident = {\n\t.options = WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT,\n\t.identity = \"Renesas RZ/G2L WDT Watchdog\",\n};\n\nstatic int rzg2l_wdt_ping(struct watchdog_device *wdev)\n{\n\tstruct rzg2l_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\trzg2l_wdt_write(priv, WDTINT_INTDISP, WDTINT);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops rzg2l_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = rzg2l_wdt_start,\n\t.stop = rzg2l_wdt_stop,\n\t.ping = rzg2l_wdt_ping,\n\t.set_timeout = rzg2l_wdt_set_timeout,\n\t.restart = rzg2l_wdt_restart,\n};\n\nstatic void rzg2l_wdt_reset_assert_pm_disable(void *data)\n{\n\tstruct watchdog_device *wdev = data;\n\tstruct rzg2l_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\tpm_runtime_disable(wdev->parent);\n\treset_control_assert(priv->rstc);\n}\n\nstatic int rzg2l_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rzg2l_wdt_priv *priv;\n\tunsigned long pclk_rate;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\t \n\tpriv->osc_clk = devm_clk_get(&pdev->dev, \"oscclk\");\n\tif (IS_ERR(priv->osc_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->osc_clk), \"no oscclk\");\n\n\tpriv->osc_clk_rate = clk_get_rate(priv->osc_clk);\n\tif (!priv->osc_clk_rate)\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL, \"oscclk rate is 0\");\n\n\t \n\tpriv->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(priv->pclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->pclk), \"no pclk\");\n\n\tpclk_rate = clk_get_rate(priv->pclk);\n\tif (!pclk_rate)\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL, \"pclk rate is 0\");\n\n\tpriv->delay = F2CYCLE_NSEC(priv->osc_clk_rate) * 6 + F2CYCLE_NSEC(pclk_rate) * 9;\n\n\tpriv->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(priv->rstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->rstc),\n\t\t\t\t     \"failed to get cpg reset\");\n\n\tret = reset_control_deassert(priv->rstc);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to deassert\");\n\n\tpriv->devtype = (uintptr_t)of_device_get_match_data(dev);\n\n\tif (priv->devtype == WDT_RZV2M) {\n\t\tpriv->minimum_assertion_period = RZV2M_A_NSEC +\n\t\t\t3 * F2CYCLE_NSEC(pclk_rate) + 5 *\n\t\t\tmax(F2CYCLE_NSEC(priv->osc_clk_rate),\n\t\t\t    F2CYCLE_NSEC(pclk_rate));\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tpriv->wdev.info = &rzg2l_wdt_ident;\n\tpriv->wdev.ops = &rzg2l_wdt_ops;\n\tpriv->wdev.parent = dev;\n\tpriv->wdev.min_timeout = 1;\n\tpriv->wdev.max_timeout = rzg2l_wdt_get_cycle_usec(priv->osc_clk_rate, 0xfff) /\n\t\t\t\t USEC_PER_SEC;\n\tpriv->wdev.timeout = WDT_DEFAULT_TIMEOUT;\n\n\twatchdog_set_drvdata(&priv->wdev, priv);\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       rzg2l_wdt_reset_assert_pm_disable,\n\t\t\t\t       &priv->wdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twatchdog_set_nowayout(&priv->wdev, nowayout);\n\twatchdog_stop_on_unregister(&priv->wdev);\n\n\tret = watchdog_init_timeout(&priv->wdev, 0, dev);\n\tif (ret)\n\t\tdev_warn(dev, \"Specified timeout invalid, using default\");\n\n\treturn devm_watchdog_register_device(&pdev->dev, &priv->wdev);\n}\n\nstatic const struct of_device_id rzg2l_wdt_ids[] = {\n\t{ .compatible = \"renesas,rzg2l-wdt\", .data = (void *)WDT_RZG2L },\n\t{ .compatible = \"renesas,rzv2m-wdt\", .data = (void *)WDT_RZV2M },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rzg2l_wdt_ids);\n\nstatic struct platform_driver rzg2l_wdt_driver = {\n\t.driver = {\n\t\t.name = \"rzg2l_wdt\",\n\t\t.of_match_table = rzg2l_wdt_ids,\n\t},\n\t.probe = rzg2l_wdt_probe,\n};\nmodule_platform_driver(rzg2l_wdt_driver);\n\nMODULE_DESCRIPTION(\"Renesas RZ/G2L WDT Watchdog Driver\");\nMODULE_AUTHOR(\"Biju Das <biju.das.jz@bp.renesas.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}