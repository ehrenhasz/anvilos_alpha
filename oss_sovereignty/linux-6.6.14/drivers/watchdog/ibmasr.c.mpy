{
  "module_name": "ibmasr.c",
  "hash_id": "714529f8839e5b4a48bb2ad336f191b9b0ecc4e86367ae660e86fd0ff42724db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ibmasr.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/timer.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/dmi.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n\nenum {\n\tASMTYPE_UNKNOWN,\n\tASMTYPE_TOPAZ,\n\tASMTYPE_JASPER,\n\tASMTYPE_PEARL,\n\tASMTYPE_JUNIPER,\n\tASMTYPE_SPRUCE,\n};\n\n#define TOPAZ_ASR_REG_OFFSET\t4\n#define TOPAZ_ASR_TOGGLE\t0x40\n#define TOPAZ_ASR_DISABLE\t0x80\n\n \n#define PEARL_BASE\t0xe04\n#define PEARL_WRITE\t0xe06\n#define PEARL_READ\t0xe07\n\n#define PEARL_ASR_DISABLE_MASK\t0x80\t \n#define PEARL_ASR_TOGGLE_MASK\t0x40\t \n\n \n#define JASPER_ASR_REG_OFFSET\t0x38\n\n#define JASPER_ASR_DISABLE_MASK\t0x01\t \n#define JASPER_ASR_TOGGLE_MASK\t0x02\t \n\n#define JUNIPER_BASE_ADDRESS\t0x54b\t \n#define JUNIPER_ASR_DISABLE_MASK 0x01\t \n#define JUNIPER_ASR_TOGGLE_MASK\t0x02\t \n\n#define SPRUCE_BASE_ADDRESS\t0x118e\t \n#define SPRUCE_ASR_DISABLE_MASK\t0x01\t \n#define SPRUCE_ASR_TOGGLE_MASK\t0x02\t \n\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\nstatic unsigned long asr_is_open;\nstatic char asr_expect_close;\n\nstatic unsigned int asr_type, asr_base, asr_length;\nstatic unsigned int asr_read_addr, asr_write_addr;\nstatic unsigned char asr_toggle_mask, asr_disable_mask;\nstatic DEFINE_SPINLOCK(asr_lock);\n\nstatic void __asr_toggle(void)\n{\n\tunsigned char reg;\n\n\treg = inb(asr_read_addr);\n\n\toutb(reg & ~asr_toggle_mask, asr_write_addr);\n\treg = inb(asr_read_addr);\n\n\toutb(reg | asr_toggle_mask, asr_write_addr);\n\treg = inb(asr_read_addr);\n\n\toutb(reg & ~asr_toggle_mask, asr_write_addr);\n\treg = inb(asr_read_addr);\n}\n\nstatic void asr_toggle(void)\n{\n\tspin_lock(&asr_lock);\n\t__asr_toggle();\n\tspin_unlock(&asr_lock);\n}\n\nstatic void asr_enable(void)\n{\n\tunsigned char reg;\n\n\tspin_lock(&asr_lock);\n\tif (asr_type == ASMTYPE_TOPAZ) {\n\t\t \n\t\treg = inb(asr_read_addr);\n\t\toutb(reg & ~(TOPAZ_ASR_TOGGLE | TOPAZ_ASR_DISABLE),\n\t\t     asr_read_addr);\n\t} else {\n\t\t \n\t\t__asr_toggle();\n\n\t\treg = inb(asr_read_addr);\n\t\toutb(reg & ~asr_disable_mask, asr_write_addr);\n\t}\n\treg = inb(asr_read_addr);\n\tspin_unlock(&asr_lock);\n}\n\nstatic void asr_disable(void)\n{\n\tunsigned char reg;\n\n\tspin_lock(&asr_lock);\n\treg = inb(asr_read_addr);\n\n\tif (asr_type == ASMTYPE_TOPAZ)\n\t\t \n\t\toutb(reg | TOPAZ_ASR_TOGGLE | TOPAZ_ASR_DISABLE,\n\t\t     asr_read_addr);\n\telse {\n\t\toutb(reg | asr_toggle_mask, asr_write_addr);\n\t\treg = inb(asr_read_addr);\n\n\t\toutb(reg | asr_disable_mask, asr_write_addr);\n\t}\n\treg = inb(asr_read_addr);\n\tspin_unlock(&asr_lock);\n}\n\nstatic int __init asr_get_base_address(void)\n{\n\tunsigned char low, high;\n\tconst char *type = \"\";\n\n\tasr_length = 1;\n\n\tswitch (asr_type) {\n\tcase ASMTYPE_TOPAZ:\n\t\t \n\t\toutb(0x07, 0x2e);\n\t\toutb(0x07, 0x2f);\n\n\t\t \n\t\toutb(0x60, 0x2e);\n\t\thigh = inb(0x2f);\n\n\t\t \n\t\toutb(0x61, 0x2e);\n\t\tlow = inb(0x2f);\n\n\t\tasr_base = (high << 16) | low;\n\t\tasr_read_addr = asr_write_addr =\n\t\t\tasr_base + TOPAZ_ASR_REG_OFFSET;\n\t\tasr_length = 5;\n\n\t\tbreak;\n\n\tcase ASMTYPE_JASPER:\n\t\ttype = \"Jaspers \";\n#if 0\n\t\tu32 r;\n\t\t \n\t\tpdev = pci_get_bus_and_slot(0, DEVFN(0x1f, 0));\n\t\tif (pdev == NULL)\n\t\t\treturn -ENODEV;\n\t\tpci_read_config_dword(pdev, 0x58, &r);\n\t\tasr_base = r & 0xFFFE;\n\t\tpci_dev_put(pdev);\n#else\n\t\t \n\n \n\n\t\t \n\t\toutl(0x8000f858, 0xcf8);\n\n\t\t \n\n\t\t \n\t\tasr_base = inl(0xcfc) & 0xfffe;\n\n \n#endif\n\t\tasr_read_addr = asr_write_addr =\n\t\t\tasr_base + JASPER_ASR_REG_OFFSET;\n\t\tasr_toggle_mask = JASPER_ASR_TOGGLE_MASK;\n\t\tasr_disable_mask = JASPER_ASR_DISABLE_MASK;\n\t\tasr_length = JASPER_ASR_REG_OFFSET + 1;\n\n\t\tbreak;\n\n\tcase ASMTYPE_PEARL:\n\t\ttype = \"Pearls \";\n\t\tasr_base = PEARL_BASE;\n\t\tasr_read_addr = PEARL_READ;\n\t\tasr_write_addr = PEARL_WRITE;\n\t\tasr_toggle_mask = PEARL_ASR_TOGGLE_MASK;\n\t\tasr_disable_mask = PEARL_ASR_DISABLE_MASK;\n\t\tasr_length = 4;\n\t\tbreak;\n\n\tcase ASMTYPE_JUNIPER:\n\t\ttype = \"Junipers \";\n\t\tasr_base = JUNIPER_BASE_ADDRESS;\n\t\tasr_read_addr = asr_write_addr = asr_base;\n\t\tasr_toggle_mask = JUNIPER_ASR_TOGGLE_MASK;\n\t\tasr_disable_mask = JUNIPER_ASR_DISABLE_MASK;\n\t\tbreak;\n\n\tcase ASMTYPE_SPRUCE:\n\t\ttype = \"Spruce's \";\n\t\tasr_base = SPRUCE_BASE_ADDRESS;\n\t\tasr_read_addr = asr_write_addr = asr_base;\n\t\tasr_toggle_mask = SPRUCE_ASR_TOGGLE_MASK;\n\t\tasr_disable_mask = SPRUCE_ASR_DISABLE_MASK;\n\t\tbreak;\n\t}\n\n\tif (!request_region(asr_base, asr_length, \"ibmasr\")) {\n\t\tpr_err(\"address %#x already in use\\n\", asr_base);\n\t\treturn -EBUSY;\n\t}\n\n\tpr_info(\"found %sASR @ addr %#x\\n\", type, asr_base);\n\n\treturn 0;\n}\n\n\nstatic ssize_t asr_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\tasr_expect_close = 0;\n\n\t\t\tfor (i = 0; i != count; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\tasr_expect_close = 42;\n\t\t\t}\n\t\t}\n\t\tasr_toggle();\n\t}\n\treturn count;\n}\n\nstatic long asr_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstatic const struct watchdog_info ident = {\n\t\t.options =\tWDIOF_KEEPALIVEPING |\n\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.identity =\t\"IBM ASR\",\n\t};\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint heartbeat;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint new_options, retval = -EINVAL;\n\t\tif (get_user(new_options, p))\n\t\t\treturn -EFAULT;\n\t\tif (new_options & WDIOS_DISABLECARD) {\n\t\t\tasr_disable();\n\t\t\tretval = 0;\n\t\t}\n\t\tif (new_options & WDIOS_ENABLECARD) {\n\t\t\tasr_enable();\n\t\t\tasr_toggle();\n\t\t\tretval = 0;\n\t\t}\n\t\treturn retval;\n\t}\n\tcase WDIOC_KEEPALIVE:\n\t\tasr_toggle();\n\t\treturn 0;\n\t \n\tcase WDIOC_GETTIMEOUT:\n\t\theartbeat = 256;\n\t\treturn put_user(heartbeat, p);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int asr_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &asr_is_open))\n\t\treturn -EBUSY;\n\n\tasr_toggle();\n\tasr_enable();\n\n\treturn stream_open(inode, file);\n}\n\nstatic int asr_release(struct inode *inode, struct file *file)\n{\n\tif (asr_expect_close == 42)\n\t\tasr_disable();\n\telse {\n\t\tpr_crit(\"unexpected close, not stopping watchdog!\\n\");\n\t\tasr_toggle();\n\t}\n\tclear_bit(0, &asr_is_open);\n\tasr_expect_close = 0;\n\treturn 0;\n}\n\nstatic const struct file_operations asr_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.llseek =\t\tno_llseek,\n\t.write =\t\tasr_write,\n\t.unlocked_ioctl =\tasr_ioctl,\n\t.compat_ioctl =\t\tcompat_ptr_ioctl,\n\t.open =\t\t\tasr_open,\n\t.release =\t\tasr_release,\n};\n\nstatic struct miscdevice asr_miscdev = {\n\t.minor =\tWATCHDOG_MINOR,\n\t.name =\t\t\"watchdog\",\n\t.fops =\t\t&asr_fops,\n};\n\n\nstruct ibmasr_id {\n\tconst char *desc;\n\tint type;\n};\n\nstatic struct ibmasr_id ibmasr_id_table[] __initdata = {\n\t{ \"IBM Automatic Server Restart - eserver xSeries 220\", ASMTYPE_TOPAZ },\n\t{ \"IBM Automatic Server Restart - Machine Type 8673\", ASMTYPE_PEARL },\n\t{ \"IBM Automatic Server Restart - Machine Type 8480\", ASMTYPE_JASPER },\n\t{ \"IBM Automatic Server Restart - Machine Type 8482\", ASMTYPE_JUNIPER },\n\t{ \"IBM Automatic Server Restart - Machine Type 8648\", ASMTYPE_SPRUCE },\n\t{ NULL }\n};\n\nstatic int __init ibmasr_init(void)\n{\n\tstruct ibmasr_id *id;\n\tint rc;\n\n\tfor (id = ibmasr_id_table; id->desc; id++) {\n\t\tif (dmi_find_device(DMI_DEV_TYPE_OTHER, id->desc, NULL)) {\n\t\t\tasr_type = id->type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!asr_type)\n\t\treturn -ENODEV;\n\n\trc = asr_get_base_address();\n\tif (rc)\n\t\treturn rc;\n\n\trc = misc_register(&asr_miscdev);\n\tif (rc < 0) {\n\t\trelease_region(asr_base, asr_length);\n\t\tpr_err(\"failed to register misc device\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit ibmasr_exit(void)\n{\n\tif (!nowayout)\n\t\tasr_disable();\n\n\tmisc_deregister(&asr_miscdev);\n\n\trelease_region(asr_base, asr_length);\n}\n\nmodule_init(ibmasr_init);\nmodule_exit(ibmasr_exit);\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nMODULE_DESCRIPTION(\"IBM Automatic Server Restart driver\");\nMODULE_AUTHOR(\"Andrey Panin\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}