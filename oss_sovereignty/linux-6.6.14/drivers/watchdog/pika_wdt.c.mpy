{
  "module_name": "pika_wdt.c",
  "hash_id": "f79723e5c11ce1be5bf3fca41bbafd990d59c48db968e49337857acffd5585e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pika_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/reboot.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#define DRV_NAME \"PIKA-WDT\"\n\n \n#define WDT_HW_TIMEOUT 2\n\n \n#define WDT_TIMEOUT\t(HZ/2)\n\n \n#define WDT_HEARTBEAT 15\nstatic int heartbeat = WDT_HEARTBEAT;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeats in seconds. \"\n\t\"(default = \" __MODULE_STRING(WDT_HEARTBEAT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\"(default=\" __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic struct {\n\tvoid __iomem *fpga;\n\tunsigned long next_heartbeat;\t \n\tunsigned long open;\n\tchar expect_close;\n\tint bootstatus;\n\tstruct timer_list timer;\t \n} pikawdt_private;\n\nstatic struct watchdog_info ident __ro_after_init = {\n\t.identity\t= DRV_NAME,\n\t.options\t= WDIOF_CARDRESET |\n\t\t\t  WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\n \nstatic inline void pikawdt_reset(void)\n{\n\t \n\tunsigned reset = in_be32(pikawdt_private.fpga + 0x14);\n\t \n\treset |= (1 << 7) + (WDT_HW_TIMEOUT << 8);\n\tout_be32(pikawdt_private.fpga + 0x14, reset);\n}\n\n \nstatic void pikawdt_ping(struct timer_list *unused)\n{\n\tif (time_before(jiffies, pikawdt_private.next_heartbeat) ||\n\t\t\t(!nowayout && !pikawdt_private.open)) {\n\t\tpikawdt_reset();\n\t\tmod_timer(&pikawdt_private.timer, jiffies + WDT_TIMEOUT);\n\t} else\n\t\tpr_crit(\"I will reset your machine !\\n\");\n}\n\n\nstatic void pikawdt_keepalive(void)\n{\n\tpikawdt_private.next_heartbeat = jiffies + heartbeat * HZ;\n}\n\nstatic void pikawdt_start(void)\n{\n\tpikawdt_keepalive();\n\tmod_timer(&pikawdt_private.timer, jiffies + WDT_TIMEOUT);\n}\n\n \nstatic int pikawdt_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &pikawdt_private.open))\n\t\treturn -EBUSY;\n\n\tpikawdt_start();\n\n\treturn stream_open(inode, file);\n}\n\n \nstatic int pikawdt_release(struct inode *inode, struct file *file)\n{\n\t \n\tif (!pikawdt_private.expect_close)\n\t\tdel_timer(&pikawdt_private.timer);\n\n\tclear_bit(0, &pikawdt_private.open);\n\tpikawdt_private.expect_close = 0;\n\treturn 0;\n}\n\n \nstatic ssize_t pikawdt_write(struct file *file, const char __user *data,\n\t\t\t     size_t len, loff_t *ppos)\n{\n\tif (!len)\n\t\treturn 0;\n\n\t \n\tif (!nowayout) {\n\t\tsize_t i;\n\n\t\tpikawdt_private.expect_close = 0;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tchar c;\n\t\t\tif (get_user(c, data + i))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (c == 'V') {\n\t\t\t\tpikawdt_private.expect_close = 42;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpikawdt_keepalive();\n\n\treturn len;\n}\n\n \nstatic long pikawdt_ioctl(struct file *file,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint new_value;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\n\tcase WDIOC_GETSTATUS:\n\t\treturn put_user(0, p);\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(pikawdt_private.bootstatus, p);\n\n\tcase WDIOC_KEEPALIVE:\n\t\tpikawdt_keepalive();\n\t\treturn 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(new_value, p))\n\t\t\treturn -EFAULT;\n\n\t\theartbeat = new_value;\n\t\tpikawdt_keepalive();\n\n\t\treturn put_user(new_value, p);   \n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(heartbeat, p);\n\t}\n\treturn -ENOTTY;\n}\n\n\nstatic const struct file_operations pikawdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.open\t\t= pikawdt_open,\n\t.release\t= pikawdt_release,\n\t.write\t\t= pikawdt_write,\n\t.unlocked_ioctl\t= pikawdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n\nstatic struct miscdevice pikawdt_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &pikawdt_fops,\n};\n\nstatic int __init pikawdt_init(void)\n{\n\tstruct device_node *np;\n\tvoid __iomem *fpga;\n\tu32 post1;\n\tint ret;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"pika,fpga\");\n\tif (np == NULL) {\n\t\tpr_err(\"Unable to find fpga\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tpikawdt_private.fpga = of_iomap(np, 0);\n\tof_node_put(np);\n\tif (pikawdt_private.fpga == NULL) {\n\t\tpr_err(\"Unable to map fpga\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tident.firmware_version = in_be32(pikawdt_private.fpga + 0x1c) & 0xffff;\n\n\t \n\tnp = of_find_compatible_node(NULL, NULL, \"pika,fpga-sd\");\n\tif (np == NULL) {\n\t\tpr_err(\"Unable to find fpga-sd\\n\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tfpga = of_iomap(np, 0);\n\tof_node_put(np);\n\tif (fpga == NULL) {\n\t\tpr_err(\"Unable to map fpga-sd\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tpost1 = in_be32(fpga + 0x40);\n\tif (post1 & 0x80000000)\n\t\tpikawdt_private.bootstatus = WDIOF_CARDRESET;\n\n\tiounmap(fpga);\n\n\ttimer_setup(&pikawdt_private.timer, pikawdt_ping, 0);\n\n\tret = misc_register(&pikawdt_miscdev);\n\tif (ret) {\n\t\tpr_err(\"Unable to register miscdev\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_info(\"initialized. heartbeat=%d sec (nowayout=%d)\\n\",\n\t\theartbeat, nowayout);\n\treturn 0;\n\nout:\n\tiounmap(pikawdt_private.fpga);\n\treturn ret;\n}\n\nstatic void __exit pikawdt_exit(void)\n{\n\tmisc_deregister(&pikawdt_miscdev);\n\n\tiounmap(pikawdt_private.fpga);\n}\n\nmodule_init(pikawdt_init);\nmodule_exit(pikawdt_exit);\n\nMODULE_AUTHOR(\"Sean MacLennan <smaclennan@pikatech.com>\");\nMODULE_DESCRIPTION(\"PIKA FPGA based Watchdog Timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}