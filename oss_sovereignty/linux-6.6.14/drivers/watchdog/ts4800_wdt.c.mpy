{
  "module_name": "ts4800_wdt.c",
  "hash_id": "08260a7f54d40dec24ffca35b7a3ceb449ac19bf991d465e70feab273be36ee0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ts4800_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n#define TS4800_WDT_FEED_2S       0x1\n#define TS4800_WDT_FEED_10S      0x2\n#define TS4800_WDT_DISABLE       0x3\n\nstruct ts4800_wdt {\n\tstruct watchdog_device  wdd;\n\tstruct regmap           *regmap;\n\tu32                     feed_offset;\n\tu32                     feed_val;\n};\n\n \nstatic const struct {\n\tconst int timeout;\n\tconst int regval;\n} ts4800_wdt_map[] = {\n\t{ 2,  TS4800_WDT_FEED_2S },\n\t{ 10, TS4800_WDT_FEED_10S },\n};\n\n#define MAX_TIMEOUT_INDEX       (ARRAY_SIZE(ts4800_wdt_map) - 1)\n\nstatic void ts4800_write_feed(struct ts4800_wdt *wdt, u32 val)\n{\n\tregmap_write(wdt->regmap, wdt->feed_offset, val);\n}\n\nstatic int ts4800_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct ts4800_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tts4800_write_feed(wdt, wdt->feed_val);\n\treturn 0;\n}\n\nstatic int ts4800_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct ts4800_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tts4800_write_feed(wdt, TS4800_WDT_DISABLE);\n\treturn 0;\n}\n\nstatic int ts4800_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct ts4800_wdt *wdt = watchdog_get_drvdata(wdd);\n\tint i;\n\n\tfor (i = 0; i < MAX_TIMEOUT_INDEX; i++) {\n\t\tif (ts4800_wdt_map[i].timeout >= timeout)\n\t\t\tbreak;\n\t}\n\n\twdd->timeout = ts4800_wdt_map[i].timeout;\n\twdt->feed_val = ts4800_wdt_map[i].regval;\n\n\treturn 0;\n}\n\nstatic const struct watchdog_ops ts4800_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = ts4800_wdt_start,\n\t.stop = ts4800_wdt_stop,\n\t.set_timeout = ts4800_wdt_set_timeout,\n};\n\nstatic const struct watchdog_info ts4800_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING,\n\t.identity = \"TS-4800 Watchdog\",\n};\n\nstatic int ts4800_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *syscon_np;\n\tstruct watchdog_device *wdd;\n\tstruct ts4800_wdt *wdt;\n\tu32 reg;\n\tint ret;\n\n\tsyscon_np = of_parse_phandle(np, \"syscon\", 0);\n\tif (!syscon_np) {\n\t\tdev_err(dev, \"no syscon property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32_index(np, \"syscon\", 1, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"no offset in syscon\\n\");\n\t\tof_node_put(syscon_np);\n\t\treturn ret;\n\t}\n\n\t \n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt) {\n\t\tof_node_put(syscon_np);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\twdt->feed_offset = reg;\n\twdt->regmap = syscon_node_to_regmap(syscon_np);\n\tof_node_put(syscon_np);\n\tif (IS_ERR(wdt->regmap)) {\n\t\tdev_err(dev, \"cannot get parent's regmap\\n\");\n\t\treturn PTR_ERR(wdt->regmap);\n\t}\n\n\t \n\twdd = &wdt->wdd;\n\twdd->parent = dev;\n\twdd->info = &ts4800_wdt_info;\n\twdd->ops = &ts4800_wdt_ops;\n\twdd->min_timeout = ts4800_wdt_map[0].timeout;\n\twdd->max_timeout = ts4800_wdt_map[MAX_TIMEOUT_INDEX].timeout;\n\n\twatchdog_set_drvdata(wdd, wdt);\n\twatchdog_set_nowayout(wdd, nowayout);\n\twatchdog_init_timeout(wdd, 0, dev);\n\n\t \n\tif (!wdd->timeout)\n\t\twdd->timeout = wdd->max_timeout;\n\tts4800_wdt_set_timeout(wdd, wdd->timeout);\n\n\t \n\tts4800_wdt_stop(wdd);\n\n\tret = devm_watchdog_register_device(dev, wdd);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\tdev_info(dev, \"initialized (timeout = %d sec, nowayout = %d)\\n\",\n\t\t wdd->timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ts4800_wdt_of_match[] = {\n\t{ .compatible = \"technologic,ts4800-wdt\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ts4800_wdt_of_match);\n\nstatic struct platform_driver ts4800_wdt_driver = {\n\t.probe\t\t= ts4800_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ts4800_wdt\",\n\t\t.of_match_table = ts4800_wdt_of_match,\n\t},\n};\n\nmodule_platform_driver(ts4800_wdt_driver);\n\nMODULE_AUTHOR(\"Damien Riegel <damien.riegel@savoirfairelinux.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:ts4800_wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}