{
  "module_name": "rc32434_wdt.c",
  "hash_id": "2ef1ecb1f2e58bc69d8022d8ad7b87145fdb717f9c5e508130d1561a3e80cdcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rc32434_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\t\t \n#include <linux/moduleparam.h>\t\t \n#include <linux/types.h>\t\t \n#include <linux/errno.h>\t\t \n#include <linux/kernel.h>\t\t \n#include <linux/fs.h>\t\t\t \n#include <linux/miscdevice.h>\t\t \n#include <linux/watchdog.h>\t\t \n#include <linux/init.h>\t\t\t \n#include <linux/platform_device.h>\t \n#include <linux/spinlock.h>\t\t \n#include <linux/uaccess.h>\t\t \n#include <linux/io.h>\t\t\t \n\n#include <asm/mach-rc32434/integ.h>\t \n\n#define VERSION \"1.0\"\n\nstatic struct {\n\tunsigned long inuse;\n\tspinlock_t io_lock;\n} rc32434_wdt_device;\n\nstatic struct integ __iomem *wdt_reg;\n\nstatic int expect_close;\n\n \nextern unsigned int idt_cpu_freq;\n\n \n#define WTCOMP2SEC(x)\t(x / idt_cpu_freq)\n#define SEC2WTCOMP(x)\t(x * idt_cpu_freq)\n\n \n#define WATCHDOG_TIMEOUT 20\n\nstatic int timeout = WATCHDOG_TIMEOUT;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout value, in seconds (default=\"\n\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n#define SET_BITS(addr, or, nand) \\\n\twritel((readl(&addr) | or) & ~nand, &addr)\n\nstatic int rc32434_wdt_set(int new_timeout)\n{\n\tint max_to = WTCOMP2SEC((u32)-1);\n\n\tif (new_timeout < 0 || new_timeout > max_to) {\n\t\tpr_err(\"timeout value must be between 0 and %d\\n\", max_to);\n\t\treturn -EINVAL;\n\t}\n\ttimeout = new_timeout;\n\tspin_lock(&rc32434_wdt_device.io_lock);\n\twritel(SEC2WTCOMP(timeout), &wdt_reg->wtcompare);\n\tspin_unlock(&rc32434_wdt_device.io_lock);\n\n\treturn 0;\n}\n\nstatic void rc32434_wdt_start(void)\n{\n\tu32 or, nand;\n\n\tspin_lock(&rc32434_wdt_device.io_lock);\n\n\t \n\twritel(0, &wdt_reg->wtcount);\n\n\t \n\tnand = 1 << RC32434_ERR_WNE;\n\tor = 1 << RC32434_ERR_WRE;\n\n\t \n\tnand |= 1 << RC32434_ERR_WTO;\n\n\tSET_BITS(wdt_reg->errcs, or, nand);\n\n\t \n\trc32434_wdt_set(timeout);\n\n\t \n\tnand = 1 << RC32434_WTC_TO;\n\tor = 1 << RC32434_WTC_EN;\n\n\tSET_BITS(wdt_reg->wtc, or, nand);\n\n\tspin_unlock(&rc32434_wdt_device.io_lock);\n\tpr_info(\"Started watchdog timer\\n\");\n}\n\nstatic void rc32434_wdt_stop(void)\n{\n\tspin_lock(&rc32434_wdt_device.io_lock);\n\n\t \n\tSET_BITS(wdt_reg->wtc, 0, 1 << RC32434_WTC_EN);\n\n\tspin_unlock(&rc32434_wdt_device.io_lock);\n\tpr_info(\"Stopped watchdog timer\\n\");\n}\n\nstatic void rc32434_wdt_ping(void)\n{\n\tspin_lock(&rc32434_wdt_device.io_lock);\n\twritel(0, &wdt_reg->wtcount);\n\tspin_unlock(&rc32434_wdt_device.io_lock);\n}\n\nstatic int rc32434_wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &rc32434_wdt_device.inuse))\n\t\treturn -EBUSY;\n\n\tif (nowayout)\n\t\t__module_get(THIS_MODULE);\n\n\trc32434_wdt_start();\n\trc32434_wdt_ping();\n\n\treturn stream_open(inode, file);\n}\n\nstatic int rc32434_wdt_release(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42) {\n\t\trc32434_wdt_stop();\n\t\tmodule_put(THIS_MODULE);\n\t} else {\n\t\tpr_crit(\"device closed unexpectedly. WDT will not stop!\\n\");\n\t\trc32434_wdt_ping();\n\t}\n\tclear_bit(0, &rc32434_wdt_device.inuse);\n\treturn 0;\n}\n\nstatic ssize_t rc32434_wdt_write(struct file *file, const char *data,\n\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\t\trc32434_wdt_ping();\n\t\treturn len;\n\t}\n\treturn 0;\n}\n\nstatic long rc32434_wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint new_timeout;\n\tunsigned int value;\n\tstatic const struct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_SETTIMEOUT |\n\t\t\t\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.identity =\t\t\"RC32434_WDT Watchdog\",\n\t};\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &ident, sizeof(ident)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tvalue = 0;\n\t\tif (copy_to_user(argp, &value, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase WDIOC_SETOPTIONS:\n\t\tif (copy_from_user(&value, argp, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tswitch (value) {\n\t\tcase WDIOS_ENABLECARD:\n\t\t\trc32434_wdt_start();\n\t\t\tbreak;\n\t\tcase WDIOS_DISABLECARD:\n\t\t\trc32434_wdt_stop();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase WDIOC_KEEPALIVE:\n\t\trc32434_wdt_ping();\n\t\tbreak;\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (copy_from_user(&new_timeout, argp, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tif (rc32434_wdt_set(new_timeout))\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn copy_to_user(argp, &timeout, sizeof(int)) ? -EFAULT : 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations rc32434_wdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= rc32434_wdt_write,\n\t.unlocked_ioctl\t= rc32434_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= rc32434_wdt_open,\n\t.release\t= rc32434_wdt_release,\n};\n\nstatic struct miscdevice rc32434_wdt_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &rc32434_wdt_fops,\n};\n\nstatic int rc32434_wdt_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct resource *r;\n\n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"rb532_wdt_res\");\n\tif (!r) {\n\t\tpr_err(\"failed to retrieve resources\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twdt_reg = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!wdt_reg) {\n\t\tpr_err(\"failed to remap I/O resources\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_init(&rc32434_wdt_device.io_lock);\n\n\t \n\trc32434_wdt_stop();\n\n\t \n\tif (rc32434_wdt_set(timeout)) {\n\t\trc32434_wdt_set(WATCHDOG_TIMEOUT);\n\t\tpr_info(\"timeout value must be between 0 and %d\\n\",\n\t\t\tWTCOMP2SEC((u32)-1));\n\t}\n\n\tret = misc_register(&rc32434_wdt_miscdev);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register watchdog device\\n\");\n\t\treturn ret;\n\t}\n\n\tpr_info(\"Watchdog Timer version \" VERSION \", timer margin: %d sec\\n\",\n\t\ttimeout);\n\n\treturn 0;\n}\n\nstatic void rc32434_wdt_remove(struct platform_device *pdev)\n{\n\tmisc_deregister(&rc32434_wdt_miscdev);\n}\n\nstatic void rc32434_wdt_shutdown(struct platform_device *pdev)\n{\n\trc32434_wdt_stop();\n}\n\nstatic struct platform_driver rc32434_wdt_driver = {\n\t.probe\t\t= rc32434_wdt_probe,\n\t.remove_new\t= rc32434_wdt_remove,\n\t.shutdown\t= rc32434_wdt_shutdown,\n\t.driver\t\t= {\n\t\t\t.name = \"rc32434_wdt\",\n\t}\n};\n\nmodule_platform_driver(rc32434_wdt_driver);\n\nMODULE_AUTHOR(\"Ondrej Zajicek <santiago@crfreenet.org>,\"\n\t\t\"Florian Fainelli <florian@openwrt.org>\");\nMODULE_DESCRIPTION(\"Driver for the IDT RC32434 SoC watchdog\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}