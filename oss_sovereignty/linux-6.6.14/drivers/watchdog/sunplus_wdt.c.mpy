{
  "module_name": "sunplus_wdt.c",
  "hash_id": "20977d70ad41d2c6f52115a132197d81d8b0799c6b46b14d3851721c9257986c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sunplus_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/watchdog.h>\n\n#define WDT_CTRL\t\t0x00\n#define WDT_CNT\t\t\t0x04\n\n#define WDT_STOP\t\t0x3877\n#define WDT_RESUME\t\t0x4A4B\n#define WDT_CLRIRQ\t\t0x7482\n#define WDT_UNLOCK\t\t0xAB00\n#define WDT_LOCK\t\t0xAB01\n#define WDT_CONMAX\t\t0xDEAF\n\n \n#define SP_WDT_MAX_TIMEOUT\t11U\n#define SP_WDT_DEFAULT_TIMEOUT\t10\n\n#define STC_CLK\t\t\t90000\n\n#define DEVICE_NAME\t\t\"sunplus-wdt\"\n\nstatic unsigned int timeout;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog timeout in seconds\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct sp_wdt_priv {\n\tstruct watchdog_device wdev;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct reset_control *rstc;\n};\n\nstatic int sp_wdt_restart(struct watchdog_device *wdev,\n\t\t\t  unsigned long action, void *data)\n{\n\tstruct sp_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tvoid __iomem *base = priv->base;\n\n\twritel(WDT_STOP, base + WDT_CTRL);\n\twritel(WDT_UNLOCK, base + WDT_CTRL);\n\twritel(0x0001, base + WDT_CNT);\n\twritel(WDT_LOCK, base + WDT_CTRL);\n\twritel(WDT_RESUME, base + WDT_CTRL);\n\n\treturn 0;\n}\n\nstatic int sp_wdt_ping(struct watchdog_device *wdev)\n{\n\tstruct sp_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tvoid __iomem *base = priv->base;\n\tu32 count;\n\n\tif (wdev->timeout > SP_WDT_MAX_TIMEOUT) {\n\t\t \n\t\twritel(WDT_CONMAX, base + WDT_CTRL);\n\t} else {\n\t\twritel(WDT_UNLOCK, base + WDT_CTRL);\n\t\t \n\t\tcount = (wdev->timeout * STC_CLK) >> 4;\n\t\twritel(count, base + WDT_CNT);\n\t\twritel(WDT_LOCK, base + WDT_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic int sp_wdt_stop(struct watchdog_device *wdev)\n{\n\tstruct sp_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tvoid __iomem *base = priv->base;\n\n\twritel(WDT_STOP, base + WDT_CTRL);\n\n\treturn 0;\n}\n\nstatic int sp_wdt_start(struct watchdog_device *wdev)\n{\n\tstruct sp_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tvoid __iomem *base = priv->base;\n\n\twritel(WDT_RESUME, base + WDT_CTRL);\n\n\treturn 0;\n}\n\nstatic unsigned int sp_wdt_get_timeleft(struct watchdog_device *wdev)\n{\n\tstruct sp_wdt_priv *priv = watchdog_get_drvdata(wdev);\n\tvoid __iomem *base = priv->base;\n\tu32 val;\n\n\tval = readl(base + WDT_CNT);\n\tval &= 0xffff;\n\tval = val << 4;\n\n\treturn val;\n}\n\nstatic const struct watchdog_info sp_wdt_info = {\n\t.identity\t= DEVICE_NAME,\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_MAGICCLOSE |\n\t\t\t  WDIOF_KEEPALIVEPING,\n};\n\nstatic const struct watchdog_ops sp_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= sp_wdt_start,\n\t.stop\t\t= sp_wdt_stop,\n\t.ping\t\t= sp_wdt_ping,\n\t.get_timeleft\t= sp_wdt_get_timeleft,\n\t.restart\t= sp_wdt_restart,\n};\n\nstatic void sp_clk_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic void sp_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int sp_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sp_wdt_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk), \"Failed to get clock\\n\");\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable clock\\n\");\n\n\tret = devm_add_action_or_reset(dev, sp_clk_disable_unprepare, priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->rstc = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(priv->rstc))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->rstc), \"Failed to get reset\\n\");\n\n\treset_control_deassert(priv->rstc);\n\n\tret = devm_add_action_or_reset(dev, sp_reset_control_assert, priv->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->wdev.info = &sp_wdt_info;\n\tpriv->wdev.ops = &sp_wdt_ops;\n\tpriv->wdev.timeout = SP_WDT_DEFAULT_TIMEOUT;\n\tpriv->wdev.max_hw_heartbeat_ms = SP_WDT_MAX_TIMEOUT * 1000;\n\tpriv->wdev.min_timeout = 1;\n\tpriv->wdev.parent = dev;\n\n\twatchdog_set_drvdata(&priv->wdev, priv);\n\twatchdog_init_timeout(&priv->wdev, timeout, dev);\n\twatchdog_set_nowayout(&priv->wdev, nowayout);\n\twatchdog_stop_on_reboot(&priv->wdev);\n\twatchdog_set_restart_priority(&priv->wdev, 128);\n\n\treturn devm_watchdog_register_device(dev, &priv->wdev);\n}\n\nstatic const struct of_device_id sp_wdt_of_match[] = {\n\t{.compatible = \"sunplus,sp7021-wdt\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sp_wdt_of_match);\n\nstatic struct platform_driver sp_wdt_driver = {\n\t.probe = sp_wdt_probe,\n\t.driver = {\n\t\t   .name = DEVICE_NAME,\n\t\t   .of_match_table = sp_wdt_of_match,\n\t},\n};\n\nmodule_platform_driver(sp_wdt_driver);\n\nMODULE_AUTHOR(\"Xiantao Hu <xt.hu@cqplus1.com>\");\nMODULE_DESCRIPTION(\"Sunplus Watchdog Timer Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}