{
  "module_name": "sp805_wdt.c",
  "hash_id": "a927b8925e77c0401fbb49db948578edfe9056ff8d2beff8e91bca6ffced87c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/sp805_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/resource.h>\n#include <linux/amba/bus.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n \n#define DEFAULT_TIMEOUT\t\t60\n\n#define MODULE_NAME\t\t\"sp805-wdt\"\n\n \n#define WDTLOAD\t\t\t0x000\n\t#define LOAD_MIN\t0x00000001\n\t#define LOAD_MAX\t0xFFFFFFFF\n#define WDTVALUE\t\t0x004\n#define WDTCONTROL\t\t0x008\n\t \n\t#define\tINT_ENABLE\t(1 << 0)\n\t#define\tRESET_ENABLE\t(1 << 1)\n\t#define\tENABLE_MASK\t(INT_ENABLE | RESET_ENABLE)\n#define WDTINTCLR\t\t0x00C\n#define WDTRIS\t\t\t0x010\n#define WDTMIS\t\t\t0x014\n\t#define INT_MASK\t(1 << 0)\n#define WDTLOCK\t\t\t0xC00\n\t#define\tUNLOCK\t\t0x1ACCE551\n\t#define\tLOCK\t\t0x00000001\n\n \nstruct sp805_wdt {\n\tstruct watchdog_device\t\twdd;\n\tspinlock_t\t\t\tlock;\n\tvoid __iomem\t\t\t*base;\n\tstruct clk\t\t\t*clk;\n\tu64\t\t\t\trate;\n\tstruct amba_device\t\t*adev;\n\tunsigned int\t\t\tload_val;\n};\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Set to 1 to keep watchdog running after device release\");\n\n \nstatic bool wdt_is_running(struct watchdog_device *wdd)\n{\n\tstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu32 wdtcontrol = readl_relaxed(wdt->base + WDTCONTROL);\n\n\treturn (wdtcontrol & ENABLE_MASK) == ENABLE_MASK;\n}\n\n \nstatic int wdt_setload(struct watchdog_device *wdd, unsigned int timeout)\n{\n\tstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu64 load, rate;\n\n\trate = wdt->rate;\n\n\t \n\tload = div_u64(rate, 2) * timeout - 1;\n\n\tload = (load > LOAD_MAX) ? LOAD_MAX : load;\n\tload = (load < LOAD_MIN) ? LOAD_MIN : load;\n\n\tspin_lock(&wdt->lock);\n\twdt->load_val = load;\n\t \n\twdd->timeout = div_u64((load + 1) * 2 + (rate / 2), rate);\n\tspin_unlock(&wdt->lock);\n\n\treturn 0;\n}\n\n \nstatic unsigned int wdt_timeleft(struct watchdog_device *wdd)\n{\n\tstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu64 load;\n\n\tspin_lock(&wdt->lock);\n\tload = readl_relaxed(wdt->base + WDTVALUE);\n\n\t \n\tif (!(readl_relaxed(wdt->base + WDTRIS) & INT_MASK))\n\t\tload += wdt->load_val + 1;\n\tspin_unlock(&wdt->lock);\n\n\treturn div_u64(load, wdt->rate);\n}\n\nstatic int\nwdt_restart(struct watchdog_device *wdd, unsigned long mode, void *cmd)\n{\n\tstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twritel_relaxed(UNLOCK, wdt->base + WDTLOCK);\n\twritel_relaxed(0, wdt->base + WDTCONTROL);\n\twritel_relaxed(0, wdt->base + WDTLOAD);\n\twritel_relaxed(INT_ENABLE | RESET_ENABLE, wdt->base + WDTCONTROL);\n\n\t \n\treadl_relaxed(wdt->base + WDTLOCK);\n\n\treturn 0;\n}\n\nstatic int wdt_config(struct watchdog_device *wdd, bool ping)\n{\n\tstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tif (!ping) {\n\n\t\tret = clk_prepare_enable(wdt->clk);\n\t\tif (ret) {\n\t\t\tdev_err(&wdt->adev->dev, \"clock enable fail\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tspin_lock(&wdt->lock);\n\n\twritel_relaxed(UNLOCK, wdt->base + WDTLOCK);\n\twritel_relaxed(wdt->load_val, wdt->base + WDTLOAD);\n\twritel_relaxed(INT_MASK, wdt->base + WDTINTCLR);\n\n\tif (!ping)\n\t\twritel_relaxed(INT_ENABLE | RESET_ENABLE, wdt->base +\n\t\t\t\tWDTCONTROL);\n\n\twritel_relaxed(LOCK, wdt->base + WDTLOCK);\n\n\t \n\treadl_relaxed(wdt->base + WDTLOCK);\n\tspin_unlock(&wdt->lock);\n\n\treturn 0;\n}\n\nstatic int wdt_ping(struct watchdog_device *wdd)\n{\n\treturn wdt_config(wdd, true);\n}\n\n \nstatic int wdt_enable(struct watchdog_device *wdd)\n{\n\treturn wdt_config(wdd, false);\n}\n\n \nstatic int wdt_disable(struct watchdog_device *wdd)\n{\n\tstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tspin_lock(&wdt->lock);\n\n\twritel_relaxed(UNLOCK, wdt->base + WDTLOCK);\n\twritel_relaxed(0, wdt->base + WDTCONTROL);\n\twritel_relaxed(LOCK, wdt->base + WDTLOCK);\n\n\t \n\treadl_relaxed(wdt->base + WDTLOCK);\n\tspin_unlock(&wdt->lock);\n\n\tclk_disable_unprepare(wdt->clk);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info wdt_info = {\n\t.options = WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n\t.identity = MODULE_NAME,\n};\n\nstatic const struct watchdog_ops wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= wdt_enable,\n\t.stop\t\t= wdt_disable,\n\t.ping\t\t= wdt_ping,\n\t.set_timeout\t= wdt_setload,\n\t.get_timeleft\t= wdt_timeleft,\n\t.restart\t= wdt_restart,\n};\n\nstatic int\nsp805_wdt_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tstruct sp805_wdt *wdt;\n\tu64 rate = 0;\n\tint ret = 0;\n\n\twdt = devm_kzalloc(&adev->dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twdt->base = devm_ioremap_resource(&adev->dev, &adev->res);\n\tif (IS_ERR(wdt->base))\n\t\treturn PTR_ERR(wdt->base);\n\n\t \n\tdevice_property_read_u64(&adev->dev, \"clock-frequency\", &rate);\n\n\twdt->clk = devm_clk_get_optional(&adev->dev, NULL);\n\tif (IS_ERR(wdt->clk))\n\t\treturn dev_err_probe(&adev->dev, PTR_ERR(wdt->clk), \"Clock not found\\n\");\n\n\twdt->rate = clk_get_rate(wdt->clk);\n\tif (!wdt->rate)\n\t\twdt->rate = rate;\n\tif (!wdt->rate) {\n\t\tdev_err(&adev->dev, \"no clock-frequency property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twdt->adev = adev;\n\twdt->wdd.info = &wdt_info;\n\twdt->wdd.ops = &wdt_ops;\n\twdt->wdd.parent = &adev->dev;\n\n\tspin_lock_init(&wdt->lock);\n\twatchdog_set_nowayout(&wdt->wdd, nowayout);\n\twatchdog_set_drvdata(&wdt->wdd, wdt);\n\twatchdog_set_restart_priority(&wdt->wdd, 128);\n\twatchdog_stop_on_unregister(&wdt->wdd);\n\n\t \n\twdt->wdd.timeout = DEFAULT_TIMEOUT;\n\twatchdog_init_timeout(&wdt->wdd, 0, &adev->dev);\n\twdt_setload(&wdt->wdd, wdt->wdd.timeout);\n\n\t \n\tif (wdt_is_running(&wdt->wdd)) {\n\t\twdt_enable(&wdt->wdd);\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdd.status);\n\t}\n\n\twatchdog_stop_on_reboot(&wdt->wdd);\n\tret = watchdog_register_device(&wdt->wdd);\n\tif (ret)\n\t\tgoto err;\n\tamba_set_drvdata(adev, wdt);\n\n\tdev_info(&adev->dev, \"registration successful\\n\");\n\treturn 0;\n\nerr:\n\tdev_err(&adev->dev, \"Probe Failed!!!\\n\");\n\treturn ret;\n}\n\nstatic void sp805_wdt_remove(struct amba_device *adev)\n{\n\tstruct sp805_wdt *wdt = amba_get_drvdata(adev);\n\n\twatchdog_unregister_device(&wdt->wdd);\n\twatchdog_set_drvdata(&wdt->wdd, NULL);\n}\n\nstatic int __maybe_unused sp805_wdt_suspend(struct device *dev)\n{\n\tstruct sp805_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\treturn wdt_disable(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sp805_wdt_resume(struct device *dev)\n{\n\tstruct sp805_wdt *wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&wdt->wdd))\n\t\treturn wdt_enable(&wdt->wdd);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(sp805_wdt_dev_pm_ops, sp805_wdt_suspend,\n\t\tsp805_wdt_resume);\n\nstatic const struct amba_id sp805_wdt_ids[] = {\n\t{\n\t\t.id\t= 0x00141805,\n\t\t.mask\t= 0x00ffffff,\n\t},\n\t{\n\t\t.id     = 0x001bb824,\n\t\t.mask   = 0x00ffffff,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, sp805_wdt_ids);\n\nstatic struct amba_driver sp805_wdt_driver = {\n\t.drv = {\n\t\t.name\t= MODULE_NAME,\n\t\t.pm\t= &sp805_wdt_dev_pm_ops,\n\t},\n\t.id_table\t= sp805_wdt_ids,\n\t.probe\t\t= sp805_wdt_probe,\n\t.remove = sp805_wdt_remove,\n};\n\nmodule_amba_driver(sp805_wdt_driver);\n\nMODULE_AUTHOR(\"Viresh Kumar <vireshk@kernel.org>\");\nMODULE_DESCRIPTION(\"ARM SP805 Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}