{
  "module_name": "advantech_ec_wdt.c",
  "hash_id": "17533b2ed26496ccd406389936af6ea8293154be89696fb5c8d1275ce6606349",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/advantech_ec_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/isa.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/watchdog.h>\n\n#define DRIVER_NAME\t\t\"advantech_ec_wdt\"\n\n \n#define EC_BASE_ADDR\t\t0x299\n#define EC_ADDR_EXTENT\t\t2\n\n \n#define EC_MIN_DELAY\t\t10\n\n \n#define EC_ADDR_CMD\t\t(EC_BASE_ADDR + 1)\n#define EC_ADDR_DATA\t\tEC_BASE_ADDR\n#define EC_CMD_EC_PROBE\t\t0x30\n#define EC_CMD_COMM\t\t0x89\n#define EC_CMD_WDT_START\t0x28\n#define EC_CMD_WDT_STOP\t\t0x29\n#define EC_CMD_WDT_RESET\t0x2A\n#define EC_DAT_EN_DLY_H\t\t0x58\n#define EC_DAT_EN_DLY_L\t\t0x59\n#define EC_DAT_RST_DLY_H\t0x5E\n#define EC_DAT_RST_DLY_L\t0x5F\n#define EC_MAGIC\t\t0x95\n\n \n#define MIN_TIME\t\t1\n#define MAX_TIME\t\t6000  \n#define DEFAULT_TIME\t\t60\n\nstatic unsigned int timeout;\nstatic ktime_t ec_timestamp;\n\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout,\n\t\t \"Default Watchdog timer setting (\" __MODULE_STRING(DEFAULT_TIME) \"s). The range is from \" __MODULE_STRING(MIN_TIME) \" to \" __MODULE_STRING(MAX_TIME) \".\");\n\nstatic void adv_ec_wdt_timing_gate(void)\n{\n\tktime_t time_cur, time_delta;\n\n\t \n\ttime_cur = ktime_get();\n\ttime_delta = ktime_to_ms(ktime_sub(time_cur, ec_timestamp));\n\tif (time_delta < EC_MIN_DELAY) {\n\t\ttime_delta = EC_MIN_DELAY - time_delta;\n\t\tusleep_range(time_delta * 1000, (time_delta + 1) * 1000);\n\t}\n\tec_timestamp = ktime_get();\n}\n\nstatic void adv_ec_wdt_outb(unsigned char value, unsigned short port)\n{\n\tadv_ec_wdt_timing_gate();\n\toutb(value, port);\n}\n\nstatic unsigned char adv_ec_wdt_inb(unsigned short port)\n{\n\tadv_ec_wdt_timing_gate();\n\treturn inb(port);\n}\n\nstatic int adv_ec_wdt_ping(struct watchdog_device *wdd)\n{\n\tadv_ec_wdt_outb(EC_CMD_WDT_RESET, EC_ADDR_CMD);\n\treturn 0;\n}\n\nstatic int adv_ec_wdt_set_timeout(struct watchdog_device *wdd, unsigned int t)\n{\n\tunsigned int val;\n\n\t \n\tval = t * 10;\n\n\t \n\tadv_ec_wdt_outb(EC_CMD_COMM, EC_ADDR_CMD);\n\tadv_ec_wdt_outb(EC_DAT_EN_DLY_H, EC_ADDR_DATA);\n\tadv_ec_wdt_outb(0, EC_ADDR_DATA);\n\n\tadv_ec_wdt_outb(EC_CMD_COMM, EC_ADDR_CMD);\n\tadv_ec_wdt_outb(EC_DAT_EN_DLY_L, EC_ADDR_DATA);\n\tadv_ec_wdt_outb(0, EC_ADDR_DATA);\n\n\t \n\tadv_ec_wdt_outb(EC_CMD_COMM, EC_ADDR_CMD);\n\tadv_ec_wdt_outb(EC_DAT_RST_DLY_H, EC_ADDR_DATA);\n\tadv_ec_wdt_outb(val >> 8, EC_ADDR_DATA);\n\n\tadv_ec_wdt_outb(EC_CMD_COMM, EC_ADDR_CMD);\n\tadv_ec_wdt_outb(EC_DAT_RST_DLY_L, EC_ADDR_DATA);\n\tadv_ec_wdt_outb(val & 0xFF, EC_ADDR_DATA);\n\n\twdd->timeout = t;\n\treturn 0;\n}\n\nstatic int adv_ec_wdt_start(struct watchdog_device *wdd)\n{\n\tadv_ec_wdt_set_timeout(wdd, wdd->timeout);\n\tadv_ec_wdt_outb(EC_CMD_WDT_START, EC_ADDR_CMD);\n\n\treturn 0;\n}\n\nstatic int adv_ec_wdt_stop(struct watchdog_device *wdd)\n{\n\tadv_ec_wdt_outb(EC_CMD_WDT_STOP, EC_ADDR_CMD);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info adv_ec_wdt_info = {\n\t.identity =\tDRIVER_NAME,\n\t.options =\tWDIOF_SETTIMEOUT |\n\t\t\tWDIOF_MAGICCLOSE |\n\t\t\tWDIOF_KEEPALIVEPING,\n};\n\nstatic const struct watchdog_ops adv_ec_wdt_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.start =\tadv_ec_wdt_start,\n\t.stop =\t\tadv_ec_wdt_stop,\n\t.ping =\t\tadv_ec_wdt_ping,\n\t.set_timeout =\tadv_ec_wdt_set_timeout,\n};\n\nstatic struct watchdog_device adv_ec_wdt_dev = {\n\t.info =\t\t&adv_ec_wdt_info,\n\t.ops =\t\t&adv_ec_wdt_ops,\n\t.min_timeout =\tMIN_TIME,\n\t.max_timeout =\tMAX_TIME,\n\t.timeout =\tDEFAULT_TIME,\n};\n\nstatic int adv_ec_wdt_probe(struct device *dev, unsigned int id)\n{\n\tif (!devm_request_region(dev, EC_BASE_ADDR, EC_ADDR_EXTENT, dev_name(dev))) {\n\t\tdev_err(dev, \"Unable to lock port addresses (0x%X-0x%X)\\n\",\n\t\t\tEC_BASE_ADDR, EC_BASE_ADDR + EC_ADDR_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\twatchdog_init_timeout(&adv_ec_wdt_dev, timeout, dev);\n\twatchdog_stop_on_reboot(&adv_ec_wdt_dev);\n\twatchdog_stop_on_unregister(&adv_ec_wdt_dev);\n\n\treturn devm_watchdog_register_device(dev, &adv_ec_wdt_dev);\n}\n\nstatic struct isa_driver adv_ec_wdt_driver = {\n\t.probe\t\t= adv_ec_wdt_probe,\n\t.driver\t\t= {\n\t.name\t\t= DRIVER_NAME,\n\t},\n};\n\nstatic int __init adv_ec_wdt_init(void)\n{\n\tunsigned int val;\n\n\t \n\tif (!request_region(EC_BASE_ADDR, EC_ADDR_EXTENT, DRIVER_NAME))\n\t\treturn -EBUSY;\n\n\tadv_ec_wdt_outb(EC_CMD_EC_PROBE, EC_ADDR_CMD);\n\tval = adv_ec_wdt_inb(EC_ADDR_DATA);\n\trelease_region(EC_BASE_ADDR, EC_ADDR_EXTENT);\n\n\tif (val != EC_MAGIC)\n\t\treturn -ENODEV;\n\n\treturn isa_register_driver(&adv_ec_wdt_driver, 1);\n}\n\nstatic void __exit adv_ec_wdt_exit(void)\n{\n\tisa_unregister_driver(&adv_ec_wdt_driver);\n}\n\nmodule_init(adv_ec_wdt_init);\nmodule_exit(adv_ec_wdt_exit);\n\nMODULE_AUTHOR(\"Thomas Kastner <thomas.kastner@advantech.com>\");\nMODULE_DESCRIPTION(\"Advantech Embedded Controller Watchdog Device Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"20221019\");\nMODULE_ALIAS(\"isa:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}