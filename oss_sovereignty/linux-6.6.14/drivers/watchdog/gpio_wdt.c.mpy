{
  "module_name": "gpio_wdt.c",
  "hash_id": "60ecfe885c82d30c87e369a2af2e63112ff92fd80130ce16697c080148f14135",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/gpio_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n#define SOFT_TIMEOUT_MIN\t1\n#define SOFT_TIMEOUT_DEF\t60\n\nenum {\n\tHW_ALGO_TOGGLE,\n\tHW_ALGO_LEVEL,\n};\n\nstruct gpio_wdt_priv {\n\tstruct gpio_desc\t*gpiod;\n\tbool\t\t\tstate;\n\tbool\t\t\talways_running;\n\tunsigned int\t\thw_algo;\n\tstruct watchdog_device\twdd;\n};\n\nstatic void gpio_wdt_disable(struct gpio_wdt_priv *priv)\n{\n\t \n\tgpiod_set_value_cansleep(priv->gpiod, 1);\n\n\t \n\tif (priv->hw_algo == HW_ALGO_TOGGLE)\n\t\tgpiod_direction_input(priv->gpiod);\n}\n\nstatic int gpio_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\tswitch (priv->hw_algo) {\n\tcase HW_ALGO_TOGGLE:\n\t\t \n\t\tpriv->state = !priv->state;\n\t\tgpiod_set_value_cansleep(priv->gpiod, priv->state);\n\t\tbreak;\n\tcase HW_ALGO_LEVEL:\n\t\t \n\t\tgpiod_set_value_cansleep(priv->gpiod, 1);\n\t\tudelay(1);\n\t\tgpiod_set_value_cansleep(priv->gpiod, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int gpio_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\tpriv->state = 0;\n\tgpiod_direction_output(priv->gpiod, priv->state);\n\n\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\n\treturn gpio_wdt_ping(wdd);\n}\n\nstatic int gpio_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\n\n\tif (!priv->always_running) {\n\t\tgpio_wdt_disable(priv);\n\t} else {\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info gpio_wdt_ident = {\n\t.options\t= WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_SETTIMEOUT,\n\t.identity\t= \"GPIO Watchdog\",\n};\n\nstatic const struct watchdog_ops gpio_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= gpio_wdt_start,\n\t.stop\t\t= gpio_wdt_stop,\n\t.ping\t\t= gpio_wdt_ping,\n};\n\nstatic int gpio_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct gpio_wdt_priv *priv;\n\tenum gpiod_flags gflags;\n\tunsigned int hw_margin;\n\tconst char *algo;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = of_property_read_string(np, \"hw_algo\", &algo);\n\tif (ret)\n\t\treturn ret;\n\tif (!strcmp(algo, \"toggle\")) {\n\t\tpriv->hw_algo = HW_ALGO_TOGGLE;\n\t\tgflags = GPIOD_IN;\n\t} else if (!strcmp(algo, \"level\")) {\n\t\tpriv->hw_algo = HW_ALGO_LEVEL;\n\t\tgflags = GPIOD_OUT_LOW;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->gpiod = devm_gpiod_get(dev, NULL, gflags);\n\tif (IS_ERR(priv->gpiod))\n\t\treturn PTR_ERR(priv->gpiod);\n\n\tret = of_property_read_u32(np,\n\t\t\t\t   \"hw_margin_ms\", &hw_margin);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (hw_margin < 2 || hw_margin > 65535)\n\t\treturn -EINVAL;\n\n\tpriv->always_running = of_property_read_bool(np,\n\t\t\t\t\t\t     \"always-running\");\n\n\twatchdog_set_drvdata(&priv->wdd, priv);\n\n\tpriv->wdd.info\t\t= &gpio_wdt_ident;\n\tpriv->wdd.ops\t\t= &gpio_wdt_ops;\n\tpriv->wdd.min_timeout\t= SOFT_TIMEOUT_MIN;\n\tpriv->wdd.max_hw_heartbeat_ms = hw_margin;\n\tpriv->wdd.parent\t= dev;\n\tpriv->wdd.timeout\t= SOFT_TIMEOUT_DEF;\n\n\twatchdog_init_timeout(&priv->wdd, 0, dev);\n\twatchdog_set_nowayout(&priv->wdd, nowayout);\n\n\twatchdog_stop_on_reboot(&priv->wdd);\n\n\tif (priv->always_running)\n\t\tgpio_wdt_start(&priv->wdd);\n\n\treturn devm_watchdog_register_device(dev, &priv->wdd);\n}\n\nstatic const struct of_device_id gpio_wdt_dt_ids[] = {\n\t{ .compatible = \"linux,wdt-gpio\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gpio_wdt_dt_ids);\n\nstatic struct platform_driver gpio_wdt_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"gpio-wdt\",\n\t\t.of_match_table\t= gpio_wdt_dt_ids,\n\t},\n\t.probe\t= gpio_wdt_probe,\n};\n\n#ifdef CONFIG_GPIO_WATCHDOG_ARCH_INITCALL\nstatic int __init gpio_wdt_init(void)\n{\n\treturn platform_driver_register(&gpio_wdt_driver);\n}\narch_initcall(gpio_wdt_init);\n#else\nmodule_platform_driver(gpio_wdt_driver);\n#endif\n\nMODULE_AUTHOR(\"Alexander Shiyan <shc_work@mail.ru>\");\nMODULE_DESCRIPTION(\"GPIO Watchdog\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}