{
  "module_name": "cpwd.c",
  "hash_id": "f80b7b29d18c74a1db7969ac770009058fd858262620f5c6689861a26e9a0057",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/cpwd.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/miscdevice.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/timer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n\n#include <asm/irq.h>\n#include <asm/watchdog.h>\n\n#define DRIVER_NAME\t\"cpwd\"\n\n#define WD_OBPNAME\t\"watchdog\"\n#define WD_BADMODEL\t\"SUNW,501-5336\"\n#define WD_BTIMEOUT\t(jiffies + (HZ * 1000))\n#define WD_BLIMIT\t0xFFFF\n\n#define WD0_MINOR\t212\n#define WD1_MINOR\t213\n#define WD2_MINOR\t214\n\n \n#define WD0_ID\t\t\t0\n#define WD1_ID\t\t\t1\n#define WD2_ID\t\t\t2\n#define WD_NUMDEVS\t\t3\n\n#define WD_INTR_OFF\t\t0\n#define WD_INTR_ON\t\t1\n\n#define WD_STAT_INIT\t0x01\t \n#define WD_STAT_BSTOP\t0x02\t \n#define WD_STAT_SVCD\t0x04\t \n\n \n#define WD0_INTR_MASK\t0x01\t \n#define WD1_INTR_MASK\t0x02\n#define WD2_INTR_MASK\t0x04\n\n#define WD_S_RUNNING\t0x01\t \n#define WD_S_EXPIRED\t0x02\t \n\nstruct cpwd {\n\tvoid __iomem\t*regs;\n\tspinlock_t\tlock;\n\n\tunsigned int\tirq;\n\n\tunsigned long\ttimeout;\n\tbool\t\tenabled;\n\tbool\t\treboot;\n\tbool\t\tbroken;\n\tbool\t\tinitialized;\n\n\tstruct {\n\t\tstruct miscdevice\tmisc;\n\t\tvoid __iomem\t\t*regs;\n\t\tu8\t\t\tintr_mask;\n\t\tu8\t\t\trunstatus;\n\t\tu16\t\t\ttimeout;\n\t} devs[WD_NUMDEVS];\n};\n\nstatic DEFINE_MUTEX(cpwd_mutex);\nstatic struct cpwd *cpwd_device;\n\n \n#define WD_TIMER_REGSZ\t16\n#define WD0_OFF\t\t0\n#define WD1_OFF\t\t(WD_TIMER_REGSZ * 1)\n#define WD2_OFF\t\t(WD_TIMER_REGSZ * 2)\n#define PLD_OFF\t\t(WD_TIMER_REGSZ * 3)\n\n#define WD_DCNTR\t0x00\n#define WD_LIMIT\t0x04\n#define WD_STATUS\t0x08\n\n#define PLD_IMASK\t(PLD_OFF + 0x00)\n#define PLD_STATUS\t(PLD_OFF + 0x04)\n\nstatic struct timer_list cpwd_timer;\n\nstatic int wd0_timeout;\nstatic int wd1_timeout;\nstatic int wd2_timeout;\n\nmodule_param(wd0_timeout, int, 0);\nMODULE_PARM_DESC(wd0_timeout, \"Default watchdog0 timeout in 1/10secs\");\nmodule_param(wd1_timeout, int, 0);\nMODULE_PARM_DESC(wd1_timeout, \"Default watchdog1 timeout in 1/10secs\");\nmodule_param(wd2_timeout, int, 0);\nMODULE_PARM_DESC(wd2_timeout, \"Default watchdog2 timeout in 1/10secs\");\n\nMODULE_AUTHOR(\"Eric Brower <ebrower@usa.net>\");\nMODULE_DESCRIPTION(\"Hardware watchdog driver for Sun Microsystems CP1400/1500\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void cpwd_writew(u16 val, void __iomem *addr)\n{\n\twritew(cpu_to_le16(val), addr);\n}\nstatic u16 cpwd_readw(void __iomem *addr)\n{\n\tu16 val = readw(addr);\n\n\treturn le16_to_cpu(val);\n}\n\nstatic void cpwd_writeb(u8 val, void __iomem *addr)\n{\n\twriteb(val, addr);\n}\n\nstatic u8 cpwd_readb(void __iomem *addr)\n{\n\treturn readb(addr);\n}\n\n \nstatic void cpwd_toggleintr(struct cpwd *p, int index, int enable)\n{\n\tunsigned char curregs = cpwd_readb(p->regs + PLD_IMASK);\n\tunsigned char setregs =\n\t\t(index == -1) ?\n\t\t(WD0_INTR_MASK | WD1_INTR_MASK | WD2_INTR_MASK) :\n\t\t(p->devs[index].intr_mask);\n\n\tif (enable == WD_INTR_ON)\n\t\tcurregs &= ~setregs;\n\telse\n\t\tcurregs |= setregs;\n\n\tcpwd_writeb(curregs, p->regs + PLD_IMASK);\n}\n\n \nstatic void cpwd_resetbrokentimer(struct cpwd *p, int index)\n{\n\tcpwd_toggleintr(p, index, WD_INTR_ON);\n\tcpwd_writew(WD_BLIMIT, p->devs[index].regs + WD_LIMIT);\n}\n\n \nstatic void cpwd_brokentimer(struct timer_list *unused)\n{\n\tstruct cpwd *p = cpwd_device;\n\tint id, tripped = 0;\n\n\t \n\tif (timer_pending(&cpwd_timer))\n\t\tdel_timer(&cpwd_timer);\n\n\tfor (id = 0; id < WD_NUMDEVS; id++) {\n\t\tif (p->devs[id].runstatus & WD_STAT_BSTOP) {\n\t\t\t++tripped;\n\t\t\tcpwd_resetbrokentimer(p, id);\n\t\t}\n\t}\n\n\tif (tripped) {\n\t\t \n\t\tcpwd_timer.expires = WD_BTIMEOUT;\n\t\tadd_timer(&cpwd_timer);\n\t}\n}\n\n \nstatic void cpwd_pingtimer(struct cpwd *p, int index)\n{\n\tif (cpwd_readb(p->devs[index].regs + WD_STATUS) & WD_S_RUNNING)\n\t\tcpwd_readw(p->devs[index].regs + WD_DCNTR);\n}\n\n \nstatic void cpwd_stoptimer(struct cpwd *p, int index)\n{\n\tif (cpwd_readb(p->devs[index].regs + WD_STATUS) & WD_S_RUNNING) {\n\t\tcpwd_toggleintr(p, index, WD_INTR_OFF);\n\n\t\tif (p->broken) {\n\t\t\tp->devs[index].runstatus |= WD_STAT_BSTOP;\n\t\t\tcpwd_brokentimer(NULL);\n\t\t}\n\t}\n}\n\n \nstatic void cpwd_starttimer(struct cpwd *p, int index)\n{\n\tif (p->broken)\n\t\tp->devs[index].runstatus &= ~WD_STAT_BSTOP;\n\n\tp->devs[index].runstatus &= ~WD_STAT_SVCD;\n\n\tcpwd_writew(p->devs[index].timeout, p->devs[index].regs + WD_LIMIT);\n\tcpwd_toggleintr(p, index, WD_INTR_ON);\n}\n\nstatic int cpwd_getstatus(struct cpwd *p, int index)\n{\n\tunsigned char stat = cpwd_readb(p->devs[index].regs + WD_STATUS);\n\tunsigned char intr = cpwd_readb(p->devs[index].regs + PLD_IMASK);\n\tunsigned char ret  = WD_STOPPED;\n\n\t \n\tif (!stat)\n\t\treturn ret;\n\n\t \n\telse if (WD_S_EXPIRED & stat) {\n\t\tret = WD_EXPIRED;\n\t} else if (WD_S_RUNNING & stat) {\n\t\tif (intr & p->devs[index].intr_mask) {\n\t\t\tret = WD_FREERUN;\n\t\t} else {\n\t\t\t \n\t\t\tif (p->broken &&\n\t\t\t    (p->devs[index].runstatus & WD_STAT_BSTOP)) {\n\t\t\t\tif (p->devs[index].runstatus & WD_STAT_SVCD) {\n\t\t\t\t\tret = WD_EXPIRED;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tret = WD_FREERUN;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret = WD_RUNNING;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (p->devs[index].runstatus & WD_STAT_SVCD)\n\t\tret |= WD_SERVICED;\n\n\treturn ret;\n}\n\nstatic irqreturn_t cpwd_interrupt(int irq, void *dev_id)\n{\n\tstruct cpwd *p = dev_id;\n\n\t \n\tspin_lock_irq(&p->lock);\n\n\tcpwd_stoptimer(p, WD0_ID);\n\tp->devs[WD0_ID].runstatus |=  WD_STAT_SVCD;\n\n\tspin_unlock_irq(&p->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cpwd_open(struct inode *inode, struct file *f)\n{\n\tstruct cpwd *p = cpwd_device;\n\n\tmutex_lock(&cpwd_mutex);\n\tswitch (iminor(inode)) {\n\tcase WD0_MINOR:\n\tcase WD1_MINOR:\n\tcase WD2_MINOR:\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&cpwd_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!p->initialized) {\n\t\tif (request_irq(p->irq, &cpwd_interrupt,\n\t\t\t\tIRQF_SHARED, DRIVER_NAME, p)) {\n\t\t\tpr_err(\"Cannot register IRQ %d\\n\", p->irq);\n\t\t\tmutex_unlock(&cpwd_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tp->initialized = true;\n\t}\n\n\tmutex_unlock(&cpwd_mutex);\n\n\treturn stream_open(inode, f);\n}\n\nstatic int cpwd_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic long cpwd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstatic const struct watchdog_info info = {\n\t\t.options\t\t= WDIOF_SETTIMEOUT,\n\t\t.firmware_version\t= 1,\n\t\t.identity\t\t= DRIVER_NAME,\n\t};\n\tvoid __user *argp = (void __user *)arg;\n\tstruct inode *inode = file_inode(file);\n\tint index = iminor(inode) - WD0_MINOR;\n\tstruct cpwd *p = cpwd_device;\n\tint setopt = 0;\n\n\tswitch (cmd) {\n\t \n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &info, sizeof(struct watchdog_info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tif (put_user(0, (int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tcpwd_pingtimer(p, index);\n\t\tbreak;\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (copy_from_user(&setopt, argp, sizeof(unsigned int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (setopt & WDIOS_DISABLECARD) {\n\t\t\tif (p->enabled)\n\t\t\t\treturn -EINVAL;\n\t\t\tcpwd_stoptimer(p, index);\n\t\t} else if (setopt & WDIOS_ENABLECARD) {\n\t\t\tcpwd_starttimer(p, index);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase WIOCGSTAT:\n\t\tsetopt = cpwd_getstatus(p, index);\n\t\tif (copy_to_user(argp, &setopt, sizeof(unsigned int)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase WIOCSTART:\n\t\tcpwd_starttimer(p, index);\n\t\tbreak;\n\n\tcase WIOCSTOP:\n\t\tif (p->enabled)\n\t\t\treturn -EINVAL;\n\n\t\tcpwd_stoptimer(p, index);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic long cpwd_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\treturn cpwd_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n\nstatic ssize_t cpwd_write(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct cpwd *p = cpwd_device;\n\tint index = iminor(inode);\n\n\tif (count) {\n\t\tcpwd_pingtimer(p, index);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t cpwd_read(struct file *file, char __user *buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct file_operations cpwd_fops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.unlocked_ioctl =\tcpwd_ioctl,\n\t.compat_ioctl =\t\tcpwd_compat_ioctl,\n\t.open =\t\t\tcpwd_open,\n\t.write =\t\tcpwd_write,\n\t.read =\t\t\tcpwd_read,\n\t.release =\t\tcpwd_release,\n\t.llseek =\t\tno_llseek,\n};\n\nstatic int cpwd_probe(struct platform_device *op)\n{\n\tstruct device_node *options;\n\tconst char *str_prop;\n\tconst void *prop_val;\n\tint i, err = -EINVAL;\n\tstruct cpwd *p;\n\n\tif (cpwd_device)\n\t\treturn -EINVAL;\n\n\tp = devm_kzalloc(&op->dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->irq = op->archdata.irqs[0];\n\n\tspin_lock_init(&p->lock);\n\n\tp->regs = of_ioremap(&op->resource[0], 0,\n\t\t\t     4 * WD_TIMER_REGSZ, DRIVER_NAME);\n\tif (!p->regs) {\n\t\tpr_err(\"Unable to map registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\toptions = of_find_node_by_path(\"/options\");\n\tif (!options) {\n\t\terr = -ENODEV;\n\t\tpr_err(\"Unable to find /options node\\n\");\n\t\tgoto out_iounmap;\n\t}\n\n\tprop_val = of_get_property(options, \"watchdog-enable?\", NULL);\n\tp->enabled = (prop_val ? true : false);\n\n\tprop_val = of_get_property(options, \"watchdog-reboot?\", NULL);\n\tp->reboot = (prop_val ? true : false);\n\n\tstr_prop = of_get_property(options, \"watchdog-timeout\", NULL);\n\tif (str_prop)\n\t\tp->timeout = simple_strtoul(str_prop, NULL, 10);\n\n\tof_node_put(options);\n\n\t \n\tstr_prop = of_get_property(op->dev.of_node, \"model\", NULL);\n\tp->broken = (str_prop && !strcmp(str_prop, WD_BADMODEL));\n\n\tif (!p->enabled)\n\t\tcpwd_toggleintr(p, -1, WD_INTR_OFF);\n\n\tfor (i = 0; i < WD_NUMDEVS; i++) {\n\t\tstatic const char *cpwd_names[] = { \"RIC\", \"XIR\", \"POR\" };\n\t\tstatic int *parms[] = { &wd0_timeout,\n\t\t\t\t\t&wd1_timeout,\n\t\t\t\t\t&wd2_timeout };\n\t\tstruct miscdevice *mp = &p->devs[i].misc;\n\n\t\tmp->minor = WD0_MINOR + i;\n\t\tmp->name = cpwd_names[i];\n\t\tmp->fops = &cpwd_fops;\n\n\t\tp->devs[i].regs = p->regs + (i * WD_TIMER_REGSZ);\n\t\tp->devs[i].intr_mask = (WD0_INTR_MASK << i);\n\t\tp->devs[i].runstatus &= ~WD_STAT_BSTOP;\n\t\tp->devs[i].runstatus |= WD_STAT_INIT;\n\t\tp->devs[i].timeout = p->timeout;\n\t\tif (*parms[i])\n\t\t\tp->devs[i].timeout = *parms[i];\n\n\t\terr = misc_register(&p->devs[i].misc);\n\t\tif (err) {\n\t\t\tpr_err(\"Could not register misc device for dev %d\\n\",\n\t\t\t       i);\n\t\t\tgoto out_unregister;\n\t\t}\n\t}\n\n\tif (p->broken) {\n\t\ttimer_setup(&cpwd_timer, cpwd_brokentimer, 0);\n\t\tcpwd_timer.expires\t= WD_BTIMEOUT;\n\n\t\tpr_info(\"PLD defect workaround enabled for model %s\\n\",\n\t\t\tWD_BADMODEL);\n\t}\n\n\tplatform_set_drvdata(op, p);\n\tcpwd_device = p;\n\treturn 0;\n\nout_unregister:\n\tfor (i--; i >= 0; i--)\n\t\tmisc_deregister(&p->devs[i].misc);\n\nout_iounmap:\n\tof_iounmap(&op->resource[0], p->regs, 4 * WD_TIMER_REGSZ);\n\n\treturn err;\n}\n\nstatic void cpwd_remove(struct platform_device *op)\n{\n\tstruct cpwd *p = platform_get_drvdata(op);\n\tint i;\n\n\tfor (i = 0; i < WD_NUMDEVS; i++) {\n\t\tmisc_deregister(&p->devs[i].misc);\n\n\t\tif (!p->enabled) {\n\t\t\tcpwd_stoptimer(p, i);\n\t\t\tif (p->devs[i].runstatus & WD_STAT_BSTOP)\n\t\t\t\tcpwd_resetbrokentimer(p, i);\n\t\t}\n\t}\n\n\tif (p->broken)\n\t\tdel_timer_sync(&cpwd_timer);\n\n\tif (p->initialized)\n\t\tfree_irq(p->irq, p);\n\n\tof_iounmap(&op->resource[0], p->regs, 4 * WD_TIMER_REGSZ);\n\n\tcpwd_device = NULL;\n}\n\nstatic const struct of_device_id cpwd_match[] = {\n\t{\n\t\t.name = \"watchdog\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cpwd_match);\n\nstatic struct platform_driver cpwd_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = cpwd_match,\n\t},\n\t.probe\t\t= cpwd_probe,\n\t.remove_new\t= cpwd_remove,\n};\n\nmodule_platform_driver(cpwd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}