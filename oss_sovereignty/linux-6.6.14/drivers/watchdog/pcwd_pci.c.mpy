{
  "module_name": "pcwd_pci.c",
  "hash_id": "41f1442febadbb8024ec24aaa298a006800f24189acbd867adf6060f130c3c7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/pcwd_pci.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\t \n#include <linux/moduleparam.h>\t \n#include <linux/types.h>\t \n#include <linux/errno.h>\t \n#include <linux/kernel.h>\t \n#include <linux/delay.h>\t \n#include <linux/miscdevice.h>\t \n#include <linux/watchdog.h>\t \n#include <linux/notifier.h>\t \n#include <linux/reboot.h>\t \n#include <linux/init.h>\t\t \n#include <linux/fs.h>\t\t \n#include <linux/pci.h>\t\t \n#include <linux/ioport.h>\t \n#include <linux/spinlock.h>\t \n#include <linux/uaccess.h>\t \n#include <linux/io.h>\t\t \n\n \n#define WATCHDOG_VERSION \"1.03\"\n#define WATCHDOG_DRIVER_NAME \"PCI-PC Watchdog\"\n#define WATCHDOG_NAME \"pcwd_pci\"\n#define DRIVER_VERSION WATCHDOG_DRIVER_NAME \" driver, v\" WATCHDOG_VERSION\n\n \n#ifndef PCI_VENDOR_ID_QUICKLOGIC\n#define PCI_VENDOR_ID_QUICKLOGIC    0x11e3\n#endif\n\n#ifndef PCI_DEVICE_ID_WATCHDOG_PCIPCWD\n#define PCI_DEVICE_ID_WATCHDOG_PCIPCWD 0x5030\n#endif\n\n \n \n#define WD_PCI_WTRP\t\t0x01\t \n#define WD_PCI_HRBT\t\t0x02\t \n#define WD_PCI_TTRP\t\t0x04\t \n#define WD_PCI_RL2A\t\t0x08\t \n#define WD_PCI_RL1A\t\t0x10\t \n#define WD_PCI_R2DS\t\t0x40\t \n#define WD_PCI_RLY2\t\t0x80\t \n \n#define WD_PCI_WDIS\t\t0x10\t \n#define WD_PCI_ENTP\t\t0x20\t \n#define WD_PCI_WRSP\t\t0x40\t \n#define WD_PCI_PCMD\t\t0x80\t \n\n \n#define PCI_COMMAND_TIMEOUT\t150\n\n \n#define CMD_GET_STATUS\t\t\t\t0x04\n#define CMD_GET_FIRMWARE_VERSION\t\t0x08\n#define CMD_READ_WATCHDOG_TIMEOUT\t\t0x18\n#define CMD_WRITE_WATCHDOG_TIMEOUT\t\t0x19\n#define CMD_GET_CLEAR_RESET_COUNT\t\t0x84\n\n \nstatic const int heartbeat_tbl[] = {\n\t5,\t \n\t10,\t \n\t30,\t \n\t60,\t \n\t300,\t \n\t600,\t \n\t1800,\t \n\t3600,\t \n};\n\n \nstatic int cards_found;\n\n \nstatic int temp_panic;\nstatic unsigned long is_active;\nstatic char expect_release;\n \nstatic struct {\n\t \n\tint supports_temp;\n\t \n\tint boot_status;\n\t \n\tunsigned long io_addr;\n\t \n\tspinlock_t io_lock;\n\t \n\tstruct pci_dev *pdev;\n} pcipcwd_private;\n\n \n#define QUIET\t0\t \n#define VERBOSE\t1\t \n#define DEBUG\t2\t \nstatic int debug = QUIET;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level: 0=Quiet, 1=Verbose, 2=Debug (default=0)\");\n\n#define WATCHDOG_HEARTBEAT 0\t \nstatic int heartbeat = WATCHDOG_HEARTBEAT;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeat in seconds. \"\n\t\"(0<heartbeat<65536 or 0=delay-time from dip-switches, default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_HEARTBEAT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n\nstatic int send_command(int cmd, int *msb, int *lsb)\n{\n\tint got_response, count;\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"sending following data cmd=0x%02x msb=0x%02x lsb=0x%02x\\n\",\n\t\t\t cmd, *msb, *lsb);\n\n\tspin_lock(&pcipcwd_private.io_lock);\n\t \n\toutb_p(*lsb, pcipcwd_private.io_addr + 4);\n\toutb_p(*msb, pcipcwd_private.io_addr + 5);\n\toutb_p(cmd, pcipcwd_private.io_addr + 6);\n\n\t \n\tgot_response = inb_p(pcipcwd_private.io_addr + 2) & WD_PCI_WRSP;\n\tfor (count = 0; (count < PCI_COMMAND_TIMEOUT) && (!got_response);\n\t\t\t\t\t\t\t\tcount++) {\n\t\tmdelay(1);\n\t\tgot_response = inb_p(pcipcwd_private.io_addr + 2) & WD_PCI_WRSP;\n\t}\n\n\tif (debug >= DEBUG) {\n\t\tif (got_response) {\n\t\t\tpr_debug(\"time to process command was: %d ms\\n\",\n\t\t\t\t count);\n\t\t} else {\n\t\t\tpr_debug(\"card did not respond on command!\\n\");\n\t\t}\n\t}\n\n\tif (got_response) {\n\t\t \n\t\t*lsb = inb_p(pcipcwd_private.io_addr + 4);\n\t\t*msb = inb_p(pcipcwd_private.io_addr + 5);\n\n\t\t \n\t\tinb_p(pcipcwd_private.io_addr + 6);\n\n\t\tif (debug >= DEBUG)\n\t\t\tpr_debug(\"received following data for cmd=0x%02x: msb=0x%02x lsb=0x%02x\\n\",\n\t\t\t\t cmd, *msb, *lsb);\n\t}\n\n\tspin_unlock(&pcipcwd_private.io_lock);\n\n\treturn got_response;\n}\n\nstatic inline void pcipcwd_check_temperature_support(void)\n{\n\tif (inb_p(pcipcwd_private.io_addr) != 0xF0)\n\t\tpcipcwd_private.supports_temp = 1;\n}\n\nstatic int pcipcwd_get_option_switches(void)\n{\n\tint option_switches;\n\n\toption_switches = inb_p(pcipcwd_private.io_addr + 3);\n\treturn option_switches;\n}\n\nstatic void pcipcwd_show_card_info(void)\n{\n\tint got_fw_rev, fw_rev_major, fw_rev_minor;\n\tchar fw_ver_str[20];\t\t \n\tint option_switches;\n\n\tgot_fw_rev = send_command(CMD_GET_FIRMWARE_VERSION, &fw_rev_major,\n\t\t\t\t\t\t\t\t&fw_rev_minor);\n\tif (got_fw_rev)\n\t\tsprintf(fw_ver_str, \"%u.%02u\", fw_rev_major, fw_rev_minor);\n\telse\n\t\tsprintf(fw_ver_str, \"<card no answer>\");\n\n\t \n\toption_switches = pcipcwd_get_option_switches();\n\n\tpr_info(\"Found card at port 0x%04x (Firmware: %s) %s temp option\\n\",\n\t\t(int) pcipcwd_private.io_addr, fw_ver_str,\n\t\t(pcipcwd_private.supports_temp ? \"with\" : \"without\"));\n\n\tpr_info(\"Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s\\n\",\n\t\toption_switches,\n\t\t((option_switches & 0x10) ? \"ON\" : \"OFF\"),\n\t\t((option_switches & 0x08) ? \"ON\" : \"OFF\"));\n\n\tif (pcipcwd_private.boot_status & WDIOF_CARDRESET)\n\t\tpr_info(\"Previous reset was caused by the Watchdog card\\n\");\n\n\tif (pcipcwd_private.boot_status & WDIOF_OVERHEAT)\n\t\tpr_info(\"Card sensed a CPU Overheat\\n\");\n\n\tif (pcipcwd_private.boot_status == 0)\n\t\tpr_info(\"No previous trip detected - Cold boot or reset\\n\");\n}\n\nstatic int pcipcwd_start(void)\n{\n\tint stat_reg;\n\n\tspin_lock(&pcipcwd_private.io_lock);\n\toutb_p(0x00, pcipcwd_private.io_addr + 3);\n\tudelay(1000);\n\n\tstat_reg = inb_p(pcipcwd_private.io_addr + 2);\n\tspin_unlock(&pcipcwd_private.io_lock);\n\n\tif (stat_reg & WD_PCI_WDIS) {\n\t\tpr_err(\"Card timer not enabled\\n\");\n\t\treturn -1;\n\t}\n\n\tif (debug >= VERBOSE)\n\t\tpr_debug(\"Watchdog started\\n\");\n\n\treturn 0;\n}\n\nstatic int pcipcwd_stop(void)\n{\n\tint stat_reg;\n\n\tspin_lock(&pcipcwd_private.io_lock);\n\toutb_p(0xA5, pcipcwd_private.io_addr + 3);\n\tudelay(1000);\n\n\toutb_p(0xA5, pcipcwd_private.io_addr + 3);\n\tudelay(1000);\n\n\tstat_reg = inb_p(pcipcwd_private.io_addr + 2);\n\tspin_unlock(&pcipcwd_private.io_lock);\n\n\tif (!(stat_reg & WD_PCI_WDIS)) {\n\t\tpr_err(\"Card did not acknowledge disable attempt\\n\");\n\t\treturn -1;\n\t}\n\n\tif (debug >= VERBOSE)\n\t\tpr_debug(\"Watchdog stopped\\n\");\n\n\treturn 0;\n}\n\nstatic int pcipcwd_keepalive(void)\n{\n\t \n\tspin_lock(&pcipcwd_private.io_lock);\n\toutb_p(0x42, pcipcwd_private.io_addr);\t \n\tspin_unlock(&pcipcwd_private.io_lock);\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"Watchdog keepalive signal send\\n\");\n\n\treturn 0;\n}\n\nstatic int pcipcwd_set_heartbeat(int t)\n{\n\tint t_msb = t / 256;\n\tint t_lsb = t % 256;\n\n\tif ((t < 0x0001) || (t > 0xFFFF))\n\t\treturn -EINVAL;\n\n\t \n\tsend_command(CMD_WRITE_WATCHDOG_TIMEOUT, &t_msb, &t_lsb);\n\n\theartbeat = t;\n\tif (debug >= VERBOSE)\n\t\tpr_debug(\"New heartbeat: %d\\n\", heartbeat);\n\n\treturn 0;\n}\n\nstatic int pcipcwd_get_status(int *status)\n{\n\tint control_status;\n\n\t*status = 0;\n\tcontrol_status = inb_p(pcipcwd_private.io_addr + 1);\n\tif (control_status & WD_PCI_WTRP)\n\t\t*status |= WDIOF_CARDRESET;\n\tif (control_status & WD_PCI_TTRP) {\n\t\t*status |= WDIOF_OVERHEAT;\n\t\tif (temp_panic)\n\t\t\tpanic(KBUILD_MODNAME \": Temperature overheat trip!\\n\");\n\t}\n\n\tif (debug >= DEBUG)\n\t\tpr_debug(\"Control Status #1: 0x%02x\\n\", control_status);\n\n\treturn 0;\n}\n\nstatic int pcipcwd_clear_status(void)\n{\n\tint control_status;\n\tint msb;\n\tint reset_counter;\n\n\tif (debug >= VERBOSE)\n\t\tpr_info(\"clearing watchdog trip status & LED\\n\");\n\n\tcontrol_status = inb_p(pcipcwd_private.io_addr + 1);\n\n\tif (debug >= DEBUG) {\n\t\tpr_debug(\"status was: 0x%02x\\n\", control_status);\n\t\tpr_debug(\"sending: 0x%02x\\n\",\n\t\t\t (control_status & WD_PCI_R2DS) | WD_PCI_WTRP);\n\t}\n\n\t \n\toutb_p((control_status & WD_PCI_R2DS) | WD_PCI_WTRP,\n\t\t\t\t\t\tpcipcwd_private.io_addr + 1);\n\n\t \n\tmsb = 0;\n\treset_counter = 0xff;\n\tsend_command(CMD_GET_CLEAR_RESET_COUNT, &msb, &reset_counter);\n\n\tif (debug >= DEBUG) {\n\t\tpr_debug(\"reset count was: 0x%02x\\n\", reset_counter);\n\t}\n\n\treturn 0;\n}\n\nstatic int pcipcwd_get_temperature(int *temperature)\n{\n\t*temperature = 0;\n\tif (!pcipcwd_private.supports_temp)\n\t\treturn -ENODEV;\n\n\tspin_lock(&pcipcwd_private.io_lock);\n\t*temperature = inb_p(pcipcwd_private.io_addr);\n\tspin_unlock(&pcipcwd_private.io_lock);\n\n\t \n\t*temperature = (*temperature * 9 / 5) + 32;\n\n\tif (debug >= DEBUG) {\n\t\tpr_debug(\"temperature is: %d F\\n\", *temperature);\n\t}\n\n\treturn 0;\n}\n\nstatic int pcipcwd_get_timeleft(int *time_left)\n{\n\tint msb;\n\tint lsb;\n\n\t \n\t \n\tsend_command(CMD_READ_WATCHDOG_TIMEOUT, &msb, &lsb);\n\n\t*time_left = (msb << 8) + lsb;\n\n\tif (debug >= VERBOSE)\n\t\tpr_debug(\"Time left before next reboot: %d\\n\", *time_left);\n\n\treturn 0;\n}\n\n \n\nstatic ssize_t pcipcwd_write(struct file *file, const char __user *data,\n\t\t\t     size_t len, loff_t *ppos)\n{\n\t \n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_release = 0;\n\n\t\t\t \n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_release = 42;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpcipcwd_keepalive();\n\t}\n\treturn len;\n}\n\nstatic long pcipcwd_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options =\t\tWDIOF_OVERHEAT |\n\t\t\t\t\tWDIOF_CARDRESET |\n\t\t\t\t\tWDIOF_KEEPALIVEPING |\n\t\t\t\t\tWDIOF_SETTIMEOUT |\n\t\t\t\t\tWDIOF_MAGICCLOSE,\n\t\t.firmware_version =\t1,\n\t\t.identity =\t\tWATCHDOG_DRIVER_NAME,\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\n\tcase WDIOC_GETSTATUS:\n\t{\n\t\tint status;\n\t\tpcipcwd_get_status(&status);\n\t\treturn put_user(status, p);\n\t}\n\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(pcipcwd_private.boot_status, p);\n\n\tcase WDIOC_GETTEMP:\n\t{\n\t\tint temperature;\n\n\t\tif (pcipcwd_get_temperature(&temperature))\n\t\t\treturn -EFAULT;\n\n\t\treturn put_user(temperature, p);\n\t}\n\n\tcase WDIOC_SETOPTIONS:\n\t{\n\t\tint new_options, retval = -EINVAL;\n\n\t\tif (get_user(new_options, p))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_options & WDIOS_DISABLECARD) {\n\t\t\tif (pcipcwd_stop())\n\t\t\t\treturn -EIO;\n\t\t\tretval = 0;\n\t\t}\n\n\t\tif (new_options & WDIOS_ENABLECARD) {\n\t\t\tif (pcipcwd_start())\n\t\t\t\treturn -EIO;\n\t\t\tretval = 0;\n\t\t}\n\n\t\tif (new_options & WDIOS_TEMPPANIC) {\n\t\t\ttemp_panic = 1;\n\t\t\tretval = 0;\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tcase WDIOC_KEEPALIVE:\n\t\tpcipcwd_keepalive();\n\t\treturn 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t{\n\t\tint new_heartbeat;\n\n\t\tif (get_user(new_heartbeat, p))\n\t\t\treturn -EFAULT;\n\n\t\tif (pcipcwd_set_heartbeat(new_heartbeat))\n\t\t\treturn -EINVAL;\n\n\t\tpcipcwd_keepalive();\n\t}\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(heartbeat, p);\n\n\tcase WDIOC_GETTIMELEFT:\n\t{\n\t\tint time_left;\n\n\t\tif (pcipcwd_get_timeleft(&time_left))\n\t\t\treturn -EFAULT;\n\n\t\treturn put_user(time_left, p);\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int pcipcwd_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (test_and_set_bit(0, &is_active)) {\n\t\tif (debug >= VERBOSE)\n\t\t\tpr_err(\"Attempt to open already opened device\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tpcipcwd_start();\n\tpcipcwd_keepalive();\n\treturn stream_open(inode, file);\n}\n\nstatic int pcipcwd_release(struct inode *inode, struct file *file)\n{\n\t \n\tif (expect_release == 42) {\n\t\tpcipcwd_stop();\n\t} else {\n\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\tpcipcwd_keepalive();\n\t}\n\texpect_release = 0;\n\tclear_bit(0, &is_active);\n\treturn 0;\n}\n\n \n\nstatic ssize_t pcipcwd_temp_read(struct file *file, char __user *data,\n\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tint temperature;\n\n\tif (pcipcwd_get_temperature(&temperature))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(data, &temperature, 1))\n\t\treturn -EFAULT;\n\n\treturn 1;\n}\n\nstatic int pcipcwd_temp_open(struct inode *inode, struct file *file)\n{\n\tif (!pcipcwd_private.supports_temp)\n\t\treturn -ENODEV;\n\n\treturn stream_open(inode, file);\n}\n\nstatic int pcipcwd_temp_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\n \n\nstatic int pcipcwd_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t\t\t\t\t\tvoid *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\tpcipcwd_stop();\t \n\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic const struct file_operations pcipcwd_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.write =\tpcipcwd_write,\n\t.unlocked_ioctl = pcipcwd_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.open =\t\tpcipcwd_open,\n\t.release =\tpcipcwd_release,\n};\n\nstatic struct miscdevice pcipcwd_miscdev = {\n\t.minor =\tWATCHDOG_MINOR,\n\t.name =\t\t\"watchdog\",\n\t.fops =\t\t&pcipcwd_fops,\n};\n\nstatic const struct file_operations pcipcwd_temp_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.read =\t\tpcipcwd_temp_read,\n\t.open =\t\tpcipcwd_temp_open,\n\t.release =\tpcipcwd_temp_release,\n};\n\nstatic struct miscdevice pcipcwd_temp_miscdev = {\n\t.minor =\tTEMP_MINOR,\n\t.name =\t\t\"temperature\",\n\t.fops =\t\t&pcipcwd_temp_fops,\n};\n\nstatic struct notifier_block pcipcwd_notifier = {\n\t.notifier_call =\tpcipcwd_notify_sys,\n};\n\n \n\nstatic int pcipcwd_card_init(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *ent)\n{\n\tint ret = -EIO;\n\n\tcards_found++;\n\tif (cards_found == 1)\n\t\tpr_info(\"%s\\n\", DRIVER_VERSION);\n\n\tif (cards_found > 1) {\n\t\tpr_err(\"This driver only supports 1 device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pci_enable_device(pdev)) {\n\t\tpr_err(\"Not possible to enable PCI Device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pci_resource_start(pdev, 0) == 0x0000) {\n\t\tpr_err(\"No I/O-Address for card detected\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_out_disable_device;\n\t}\n\n\tspin_lock_init(&pcipcwd_private.io_lock);\n\tpcipcwd_private.pdev = pdev;\n\tpcipcwd_private.io_addr = pci_resource_start(pdev, 0);\n\n\tif (pci_request_regions(pdev, WATCHDOG_NAME)) {\n\t\tpr_err(\"I/O address 0x%04x already in use\\n\",\n\t\t       (int) pcipcwd_private.io_addr);\n\t\tret = -EIO;\n\t\tgoto err_out_disable_device;\n\t}\n\n\t \n\tpcipcwd_get_status(&pcipcwd_private.boot_status);\n\n\t \n\tpcipcwd_clear_status();\n\n\t \n\tpcipcwd_stop();\n\n\t \n\tpcipcwd_check_temperature_support();\n\n\t \n\tpcipcwd_show_card_info();\n\n\t \n\tif (heartbeat == 0)\n\t\theartbeat =\n\t\t\theartbeat_tbl[(pcipcwd_get_option_switches() & 0x07)];\n\n\t \n\tif (pcipcwd_set_heartbeat(heartbeat)) {\n\t\tpcipcwd_set_heartbeat(WATCHDOG_HEARTBEAT);\n\t\tpr_info(\"heartbeat value must be 0<heartbeat<65536, using %d\\n\",\n\t\t\tWATCHDOG_HEARTBEAT);\n\t}\n\n\tret = register_reboot_notifier(&pcipcwd_notifier);\n\tif (ret != 0) {\n\t\tpr_err(\"cannot register reboot notifier (err=%d)\\n\", ret);\n\t\tgoto err_out_release_region;\n\t}\n\n\tif (pcipcwd_private.supports_temp) {\n\t\tret = misc_register(&pcipcwd_temp_miscdev);\n\t\tif (ret != 0) {\n\t\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t\t       TEMP_MINOR, ret);\n\t\t\tgoto err_out_unregister_reboot;\n\t\t}\n\t}\n\n\tret = misc_register(&pcipcwd_miscdev);\n\tif (ret != 0) {\n\t\tpr_err(\"cannot register miscdev on minor=%d (err=%d)\\n\",\n\t\t       WATCHDOG_MINOR, ret);\n\t\tgoto err_out_misc_deregister;\n\t}\n\n\tpr_info(\"initialized. heartbeat=%d sec (nowayout=%d)\\n\",\n\t\theartbeat, nowayout);\n\n\treturn 0;\n\nerr_out_misc_deregister:\n\tif (pcipcwd_private.supports_temp)\n\t\tmisc_deregister(&pcipcwd_temp_miscdev);\nerr_out_unregister_reboot:\n\tunregister_reboot_notifier(&pcipcwd_notifier);\nerr_out_release_region:\n\tpci_release_regions(pdev);\nerr_out_disable_device:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void pcipcwd_card_exit(struct pci_dev *pdev)\n{\n\t \n\tif (!nowayout)\n\t\tpcipcwd_stop();\n\n\t \n\tmisc_deregister(&pcipcwd_miscdev);\n\tif (pcipcwd_private.supports_temp)\n\t\tmisc_deregister(&pcipcwd_temp_miscdev);\n\tunregister_reboot_notifier(&pcipcwd_notifier);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tcards_found--;\n}\n\nstatic const struct pci_device_id pcipcwd_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_QUICKLOGIC, PCI_DEVICE_ID_WATCHDOG_PCIPCWD,\n\t\tPCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0 },\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, pcipcwd_pci_tbl);\n\nstatic struct pci_driver pcipcwd_driver = {\n\t.name\t\t= WATCHDOG_NAME,\n\t.id_table\t= pcipcwd_pci_tbl,\n\t.probe\t\t= pcipcwd_card_init,\n\t.remove\t\t= pcipcwd_card_exit,\n};\n\nmodule_pci_driver(pcipcwd_driver);\n\nMODULE_AUTHOR(\"Wim Van Sebroeck <wim@iguana.be>\");\nMODULE_DESCRIPTION(\"Berkshire PCI-PC Watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}