{
  "module_name": "wdt285.c",
  "hash_id": "60c4be33e26f4f90b38936fb11d50e957c16a484606b8491e8de76c2bc4fb6ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/wdt285.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/uaccess.h>\n#include <linux/irq.h>\n#include <mach/hardware.h>\n\n#include <asm/mach-types.h>\n#include <asm/system_info.h>\n#include <asm/hardware/dec21285.h>\n\n \n#undef ONLY_TESTING\n\nstatic unsigned int soft_margin = 60;\t\t \nstatic unsigned int reload;\nstatic unsigned long timer_alive;\n\n#ifdef ONLY_TESTING\n \nstatic void watchdog_fire(int irq, void *dev_id)\n{\n\tpr_crit(\"Would Reboot\\n\");\n\t*CSR_TIMER4_CNTL = 0;\n\t*CSR_TIMER4_CLR = 0;\n}\n#endif\n\n \nstatic void watchdog_ping(void)\n{\n\t*CSR_TIMER4_LOAD = reload;\n}\n\n \nstatic int watchdog_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tif (*CSR_SA110_CNTL & (1 << 13))\n\t\treturn -EBUSY;\n\n\tif (test_and_set_bit(1, &timer_alive))\n\t\treturn -EBUSY;\n\n\treload = soft_margin * (mem_fclk_21285 / 256);\n\n\t*CSR_TIMER4_CLR = 0;\n\twatchdog_ping();\n\t*CSR_TIMER4_CNTL = TIMER_CNTL_ENABLE | TIMER_CNTL_AUTORELOAD\n\t\t| TIMER_CNTL_DIV256;\n\n#ifdef ONLY_TESTING\n\tret = request_irq(IRQ_TIMER4, watchdog_fire, 0, \"watchdog\", NULL);\n\tif (ret) {\n\t\t*CSR_TIMER4_CNTL = 0;\n\t\tclear_bit(1, &timer_alive);\n\t}\n#else\n\t \n\t*CSR_SA110_CNTL |= 1 << 13;\n\n\tret = 0;\n#endif\n\tstream_open(inode, file);\n\treturn ret;\n}\n\n \nstatic int watchdog_release(struct inode *inode, struct file *file)\n{\n#ifdef ONLY_TESTING\n\tfree_irq(IRQ_TIMER4, NULL);\n\tclear_bit(1, &timer_alive);\n#endif\n\treturn 0;\n}\n\nstatic ssize_t watchdog_write(struct file *file, const char __user *data,\n\t\t\t      size_t len, loff_t *ppos)\n{\n\t \n\tif (len)\n\t\twatchdog_ping();\n\n\treturn len;\n}\n\nstatic const struct watchdog_info ident = {\n\t.options\t= WDIOF_SETTIMEOUT,\n\t.identity\t= \"Footbridge Watchdog\",\n};\n\nstatic long watchdog_ioctl(struct file *file, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tint __user *int_arg = (int __user *)arg;\n\tint new_margin, ret = -ENOTTY;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tret = 0;\n\t\tif (copy_to_user((void __user *)arg, &ident, sizeof(ident)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tret = put_user(0, int_arg);\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\twatchdog_ping();\n\t\tret = 0;\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tret = get_user(new_margin, int_arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (new_margin < 0 || new_margin > 60) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsoft_margin = new_margin;\n\t\treload = soft_margin * (mem_fclk_21285 / 256);\n\t\twatchdog_ping();\n\t\tfallthrough;\n\tcase WDIOC_GETTIMEOUT:\n\t\tret = put_user(soft_margin, int_arg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations watchdog_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= watchdog_write,\n\t.unlocked_ioctl\t= watchdog_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= watchdog_open,\n\t.release\t= watchdog_release,\n};\n\nstatic struct miscdevice watchdog_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &watchdog_fops,\n};\n\nstatic int __init footbridge_watchdog_init(void)\n{\n\tint retval;\n\n\tif (machine_is_netwinder())\n\t\treturn -ENODEV;\n\n\tretval = misc_register(&watchdog_miscdev);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tpr_info(\"Footbridge Watchdog Timer: 0.01, timer margin: %d sec\\n\",\n\t\tsoft_margin);\n\n\treturn 0;\n}\n\nstatic void __exit footbridge_watchdog_exit(void)\n{\n\tmisc_deregister(&watchdog_miscdev);\n}\n\nMODULE_AUTHOR(\"Phil Blundell <pb@nexus.co.uk>\");\nMODULE_DESCRIPTION(\"Footbridge watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(soft_margin, int, 0);\nMODULE_PARM_DESC(soft_margin, \"Watchdog timeout in seconds\");\n\nmodule_init(footbridge_watchdog_init);\nmodule_exit(footbridge_watchdog_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}