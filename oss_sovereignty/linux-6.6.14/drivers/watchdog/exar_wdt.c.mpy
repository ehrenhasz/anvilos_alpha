{
  "module_name": "exar_wdt.c",
  "hash_id": "9b5522f07a403b17291505e71edf8390e365086aefaa807d7f169c3963885f58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/exar_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/watchdog.h>\n\n#define DRV_NAME\t\"exar_wdt\"\n\nstatic const unsigned short sio_config_ports[] = { 0x2e, 0x4e };\nstatic const unsigned char sio_enter_keys[] = { 0x67, 0x77, 0x87, 0xA0 };\n#define EXAR_EXIT_KEY\t0xAA\n\n#define EXAR_LDN\t0x07\n#define EXAR_DID\t0x20\n#define EXAR_VID\t0x23\n#define EXAR_WDT\t0x26\n#define EXAR_ACT\t0x30\n#define EXAR_RTBASE\t0x60\n\n#define EXAR_WDT_LDEV\t0x08\n\n#define EXAR_VEN_ID\t0x13A8\n#define EXAR_DEV_382\t0x0382\n#define EXAR_DEV_384\t0x0384\n\n \n#define WDT_CTRL\t0x00\n#define WDT_VAL\t\t0x01\n\n#define WDT_UNITS_10MS\t0x0\t \n#define WDT_UNITS_SEC\t0x2\n#define WDT_UNITS_MIN\t0x4\n\n \n#define EXAR_WDT_DEF_CONF\t0\n\nstruct wdt_pdev_node {\n\tstruct list_head list;\n\tstruct platform_device *pdev;\n\tconst char name[16];\n};\n\nstruct wdt_priv {\n\t \n\tspinlock_t io_lock;\n\tstruct resource wdt_res;\n\tstruct watchdog_device wdt_dev;\n\tunsigned short did;\n\tunsigned short config_port;\n\tunsigned char enter_key;\n\tunsigned char unit;\n\tunsigned char timeout;\n};\n\n#define WATCHDOG_TIMEOUT 60\n\nstatic int timeout = WATCHDOG_TIMEOUT;\nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\t \"Watchdog timeout in seconds. 1<=timeout<=15300, default=\"\n\t\t __MODULE_STRING(WATCHDOG_TIMEOUT) \".\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int exar_sio_enter(const unsigned short config_port,\n\t\t\t  const unsigned char key)\n{\n\tif (!request_muxed_region(config_port, 2, DRV_NAME))\n\t\treturn -EBUSY;\n\n\t \n\toutb(key, config_port);\n\toutb(key, config_port);\n\n\treturn 0;\n}\n\nstatic void exar_sio_exit(const unsigned short config_port)\n{\n\toutb(EXAR_EXIT_KEY, config_port);\n\trelease_region(config_port, 2);\n}\n\nstatic unsigned char exar_sio_read(const unsigned short config_port,\n\t\t\t\t   const unsigned char reg)\n{\n\toutb(reg, config_port);\n\treturn inb(config_port + 1);\n}\n\nstatic void exar_sio_write(const unsigned short config_port,\n\t\t\t   const unsigned char reg, const unsigned char val)\n{\n\toutb(reg, config_port);\n\toutb(val, config_port + 1);\n}\n\nstatic unsigned short exar_sio_read16(const unsigned short config_port,\n\t\t\t\t      const unsigned char reg)\n{\n\tunsigned char msb, lsb;\n\n\tmsb = exar_sio_read(config_port, reg);\n\tlsb = exar_sio_read(config_port, reg + 1);\n\n\treturn (msb << 8) | lsb;\n}\n\nstatic void exar_sio_select_wdt(const unsigned short config_port)\n{\n\texar_sio_write(config_port, EXAR_LDN, EXAR_WDT_LDEV);\n}\n\nstatic void exar_wdt_arm(const struct wdt_priv *priv)\n{\n\tunsigned short rt_base = priv->wdt_res.start;\n\n\t \n\toutb(priv->timeout, rt_base + WDT_VAL);\n\toutb(priv->timeout, rt_base + WDT_VAL);\n}\n\nstatic void exar_wdt_disarm(const struct wdt_priv *priv)\n{\n\tunsigned short rt_base = priv->wdt_res.start;\n\n\t \n\toutb(0xFF, rt_base + WDT_VAL);\n\toutb(0, rt_base + WDT_VAL);\n}\n\nstatic int exar_wdt_start(struct watchdog_device *wdog)\n{\n\tstruct wdt_priv *priv = watchdog_get_drvdata(wdog);\n\tunsigned short rt_base = priv->wdt_res.start;\n\n\tspin_lock(&priv->io_lock);\n\n\texar_wdt_disarm(priv);\n\toutb(priv->unit, rt_base + WDT_CTRL);\n\texar_wdt_arm(priv);\n\n\tspin_unlock(&priv->io_lock);\n\treturn 0;\n}\n\nstatic int exar_wdt_stop(struct watchdog_device *wdog)\n{\n\tstruct wdt_priv *priv = watchdog_get_drvdata(wdog);\n\n\tspin_lock(&priv->io_lock);\n\n\texar_wdt_disarm(priv);\n\n\tspin_unlock(&priv->io_lock);\n\treturn 0;\n}\n\nstatic int exar_wdt_keepalive(struct watchdog_device *wdog)\n{\n\tstruct wdt_priv *priv = watchdog_get_drvdata(wdog);\n\tunsigned short rt_base = priv->wdt_res.start;\n\n\tspin_lock(&priv->io_lock);\n\n\t \n\tinb(rt_base + WDT_VAL);\n\n\tspin_unlock(&priv->io_lock);\n\treturn 0;\n}\n\nstatic int exar_wdt_set_timeout(struct watchdog_device *wdog, unsigned int t)\n{\n\tstruct wdt_priv *priv = watchdog_get_drvdata(wdog);\n\tbool unit_min = false;\n\n\t \n\tif (t > 255) {\n\t\tunit_min = true;\n\t\tt = DIV_ROUND_UP(t, 60);\n\t}\n\n\t \n\tpriv->unit = unit_min ? WDT_UNITS_MIN : WDT_UNITS_SEC;\n\tpriv->timeout = t;\n\n\twdog->timeout = unit_min ? t * 60 : t;\n\n\tif (watchdog_hw_running(wdog))\n\t\texar_wdt_start(wdog);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info exar_wdt_info = {\n\t.options\t= WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_MAGICCLOSE,\n\t.identity\t= \"Exar/MaxLinear XR28V38x Watchdog\",\n};\n\nstatic const struct watchdog_ops exar_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= exar_wdt_start,\n\t.stop\t\t= exar_wdt_stop,\n\t.ping\t\t= exar_wdt_keepalive,\n\t.set_timeout\t= exar_wdt_set_timeout,\n};\n\nstatic int exar_wdt_config(struct watchdog_device *wdog,\n\t\t\t   const unsigned char conf)\n{\n\tstruct wdt_priv *priv = watchdog_get_drvdata(wdog);\n\tint ret;\n\n\tret = exar_sio_enter(priv->config_port, priv->enter_key);\n\tif (ret)\n\t\treturn ret;\n\n\texar_sio_select_wdt(priv->config_port);\n\texar_sio_write(priv->config_port, EXAR_WDT, conf);\n\n\texar_sio_exit(priv->config_port);\n\n\treturn 0;\n}\n\nstatic int __init exar_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct wdt_priv *priv = dev->platform_data;\n\tstruct watchdog_device *wdt_dev = &priv->wdt_dev;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\n\tspin_lock_init(&priv->io_lock);\n\n\twdt_dev->info = &exar_wdt_info;\n\twdt_dev->ops = &exar_wdt_ops;\n\twdt_dev->min_timeout = 1;\n\twdt_dev->max_timeout = 255 * 60;\n\n\twatchdog_init_timeout(wdt_dev, timeout, NULL);\n\twatchdog_set_nowayout(wdt_dev, nowayout);\n\twatchdog_stop_on_reboot(wdt_dev);\n\twatchdog_stop_on_unregister(wdt_dev);\n\twatchdog_set_drvdata(wdt_dev, priv);\n\n\tret = exar_wdt_config(wdt_dev, EXAR_WDT_DEF_CONF);\n\tif (ret)\n\t\treturn ret;\n\n\texar_wdt_set_timeout(wdt_dev, timeout);\n\t \n\texar_wdt_stop(wdt_dev);\n\n\tret = devm_watchdog_register_device(dev, wdt_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"XR28V%X WDT initialized. timeout=%d sec (nowayout=%d)\\n\",\n\t\t priv->did, timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic unsigned short __init exar_detect(const unsigned short config_port,\n\t\t\t\t\t const unsigned char key,\n\t\t\t\t\t unsigned short *rt_base)\n{\n\tint ret;\n\tunsigned short base = 0;\n\tunsigned short vid, did;\n\n\tret = exar_sio_enter(config_port, key);\n\tif (ret)\n\t\treturn 0;\n\n\tvid = exar_sio_read16(config_port, EXAR_VID);\n\tdid = exar_sio_read16(config_port, EXAR_DID);\n\n\t \n\tif (vid == EXAR_VEN_ID &&\n\t    (did == EXAR_DEV_382 ||\n\t     did == EXAR_DEV_384)) {\n\t\texar_sio_select_wdt(config_port);\n\t\t \n\t\tif (exar_sio_read(config_port, EXAR_ACT) == 0x01)\n\t\t\tbase = exar_sio_read16(config_port, EXAR_RTBASE);\n\t}\n\n\texar_sio_exit(config_port);\n\n\tif (base) {\n\t\tpr_debug(\"Found a XR28V%X WDT (conf: 0x%x / rt: 0x%04x)\\n\",\n\t\t\t did, config_port, base);\n\t\t*rt_base = base;\n\t\treturn did;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver exar_wdt_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n};\n\nstatic LIST_HEAD(pdev_list);\n\nstatic int __init exar_wdt_register(struct wdt_priv *priv, const int idx)\n{\n\tstruct wdt_pdev_node *n;\n\n\tn = kzalloc(sizeof(*n), GFP_KERNEL);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&n->list);\n\n\tscnprintf((char *)n->name, sizeof(n->name), DRV_NAME \".%d\", idx);\n\tpriv->wdt_res.name = n->name;\n\n\tn->pdev = platform_device_register_resndata(NULL, DRV_NAME, idx,\n\t\t\t\t\t\t    &priv->wdt_res, 1,\n\t\t\t\t\t\t    priv, sizeof(*priv));\n\tif (IS_ERR(n->pdev)) {\n\t\tint err = PTR_ERR(n->pdev);\n\n\t\tkfree(n);\n\t\treturn err;\n\t}\n\n\tlist_add_tail(&n->list, &pdev_list);\n\n\treturn 0;\n}\n\nstatic void exar_wdt_unregister(void)\n{\n\tstruct wdt_pdev_node *n, *t;\n\n\tlist_for_each_entry_safe(n, t, &pdev_list, list) {\n\t\tplatform_device_unregister(n->pdev);\n\t\tlist_del(&n->list);\n\t\tkfree(n);\n\t}\n}\n\nstatic int __init exar_wdt_init(void)\n{\n\tint ret, i, j, idx = 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sio_config_ports); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(sio_enter_keys); j++) {\n\t\t\tunsigned short did, rt_base = 0;\n\n\t\t\tdid = exar_detect(sio_config_ports[i],\n\t\t\t\t\t  sio_enter_keys[j],\n\t\t\t\t\t  &rt_base);\n\n\t\t\tif (did) {\n\t\t\t\tstruct wdt_priv priv = {\n\t\t\t\t\t.wdt_res = DEFINE_RES_IO(rt_base, 2),\n\t\t\t\t\t.did = did,\n\t\t\t\t\t.config_port = sio_config_ports[i],\n\t\t\t\t\t.enter_key = sio_enter_keys[j],\n\t\t\t\t};\n\n\t\t\t\tret = exar_wdt_register(&priv, idx);\n\t\t\t\tif (!ret)\n\t\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!idx)\n\t\treturn -ENODEV;\n\n\tret = platform_driver_probe(&exar_wdt_driver, exar_wdt_probe);\n\tif (ret)\n\t\texar_wdt_unregister();\n\n\treturn ret;\n}\n\nstatic void __exit exar_wdt_exit(void)\n{\n\texar_wdt_unregister();\n\tplatform_driver_unregister(&exar_wdt_driver);\n}\n\nmodule_init(exar_wdt_init);\nmodule_exit(exar_wdt_exit);\n\nMODULE_AUTHOR(\"David M\u00fcller <d.mueller@elsoft.ch>\");\nMODULE_DESCRIPTION(\"Exar/MaxLinear Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}