{
  "module_name": "starfive-wdt.c",
  "hash_id": "b9f9d25f64fec3a0b96cc07f8daad67fcf04a25ec9c79892d687c01fed3e4ce9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/starfive-wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/watchdog.h>\n\n \n#define STARFIVE_WDT_JH7100_INTSTAUS\t0x000\n#define STARFIVE_WDT_JH7100_CONTROL\t0x104\n#define STARFIVE_WDT_JH7100_LOAD\t0x108\n#define STARFIVE_WDT_JH7100_EN\t\t0x110\n#define STARFIVE_WDT_JH7100_RELOAD\t0x114\t \n#define STARFIVE_WDT_JH7100_VALUE\t0x118\n#define STARFIVE_WDT_JH7100_INTCLR\t0x120\t \n#define STARFIVE_WDT_JH7100_LOCK\t0x13c\t \n\n \n#define STARFIVE_WDT_JH7110_LOAD\t0x000\n#define STARFIVE_WDT_JH7110_VALUE\t0x004\n#define STARFIVE_WDT_JH7110_CONTROL\t0x008\t \n#define STARFIVE_WDT_JH7110_INTCLR\t0x00c\t \n#define STARFIVE_WDT_JH7110_IMS\t\t0x014\n#define STARFIVE_WDT_JH7110_LOCK\t0xc00\t \n\n \n#define STARFIVE_WDT_ENABLE\t\t\t0x1\n#define STARFIVE_WDT_EN_SHIFT\t\t\t0\n#define STARFIVE_WDT_RESET_EN\t\t\t0x1\n#define STARFIVE_WDT_JH7100_RST_EN_SHIFT\t0\n#define STARFIVE_WDT_JH7110_RST_EN_SHIFT\t1\n\n \n#define STARFIVE_WDT_JH7100_UNLOCK_KEY\t\t0x378f0765\n#define STARFIVE_WDT_JH7110_UNLOCK_KEY\t\t0x1acce551\n\n \n#define STARFIVE_WDT_INTCLR\t\t\t0x1\n#define STARFIVE_WDT_JH7100_INTCLR_AVA_SHIFT\t1\t \n\n#define STARFIVE_WDT_MAXCNT\t\t\t0xffffffff\n#define STARFIVE_WDT_DEFAULT_TIME\t\t(15)\n#define STARFIVE_WDT_DELAY_US\t\t\t0\n#define STARFIVE_WDT_TIMEOUT_US\t\t\t10000\n\n \n#define STARFIVE_WDT_EARLY_ENA\t\t\t0\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic int heartbeat;\nstatic bool early_enable = STARFIVE_WDT_EARLY_ENA;\n\nmodule_param(heartbeat, int, 0);\nmodule_param(early_enable, bool, 0);\nmodule_param(nowayout, bool, 0);\n\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeat in seconds. (default=\"\n\t\t __MODULE_STRING(STARFIVE_WDT_DEFAULT_TIME) \")\");\nMODULE_PARM_DESC(early_enable,\n\t\t \"Watchdog is started at boot time if set to 1, default=\"\n\t\t __MODULE_STRING(STARFIVE_WDT_EARLY_ENA));\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct starfive_wdt_variant {\n\tunsigned int control;\t\t \n\tunsigned int load;\t\t \n\tunsigned int reload;\t\t \n\tunsigned int enable;\t\t \n\tunsigned int value;\t\t \n\tunsigned int int_clr;\t\t \n\tunsigned int unlock;\t\t \n\tunsigned int int_status;\t \n\n\tu32 unlock_key;\n\tchar enrst_shift;\n\tchar en_shift;\n\tbool intclr_check;\t\t \n\tchar intclr_ava_shift;\n\tbool double_timeout;\t\t \n};\n\nstruct starfive_wdt {\n\tstruct watchdog_device wdd;\n\tspinlock_t lock;\t\t \n\tvoid __iomem *base;\n\tstruct clk *core_clk;\n\tstruct clk *apb_clk;\n\tconst struct starfive_wdt_variant *variant;\n\tunsigned long freq;\n\tu32 count;\t\t\t \n\tu32 reload;\t\t\t \n};\n\n \nstatic const struct starfive_wdt_variant starfive_wdt_jh7100_variant = {\n\t.control = STARFIVE_WDT_JH7100_CONTROL,\n\t.load = STARFIVE_WDT_JH7100_LOAD,\n\t.reload = STARFIVE_WDT_JH7100_RELOAD,\n\t.enable = STARFIVE_WDT_JH7100_EN,\n\t.value = STARFIVE_WDT_JH7100_VALUE,\n\t.int_clr = STARFIVE_WDT_JH7100_INTCLR,\n\t.unlock = STARFIVE_WDT_JH7100_LOCK,\n\t.unlock_key = STARFIVE_WDT_JH7100_UNLOCK_KEY,\n\t.int_status = STARFIVE_WDT_JH7100_INTSTAUS,\n\t.enrst_shift = STARFIVE_WDT_JH7100_RST_EN_SHIFT,\n\t.en_shift = STARFIVE_WDT_EN_SHIFT,\n\t.intclr_check = true,\n\t.intclr_ava_shift = STARFIVE_WDT_JH7100_INTCLR_AVA_SHIFT,\n\t.double_timeout = false,\n};\n\n \nstatic const struct starfive_wdt_variant starfive_wdt_jh7110_variant = {\n\t.control = STARFIVE_WDT_JH7110_CONTROL,\n\t.load = STARFIVE_WDT_JH7110_LOAD,\n\t.enable = STARFIVE_WDT_JH7110_CONTROL,\n\t.value = STARFIVE_WDT_JH7110_VALUE,\n\t.int_clr = STARFIVE_WDT_JH7110_INTCLR,\n\t.unlock = STARFIVE_WDT_JH7110_LOCK,\n\t.unlock_key = STARFIVE_WDT_JH7110_UNLOCK_KEY,\n\t.int_status = STARFIVE_WDT_JH7110_IMS,\n\t.enrst_shift = STARFIVE_WDT_JH7110_RST_EN_SHIFT,\n\t.en_shift = STARFIVE_WDT_EN_SHIFT,\n\t.intclr_check = false,\n\t.double_timeout = true,\n};\n\nstatic int starfive_wdt_enable_clock(struct starfive_wdt *wdt)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(wdt->apb_clk);\n\tif (ret)\n\t\treturn dev_err_probe(wdt->wdd.parent, ret, \"failed to enable apb clock\\n\");\n\n\tret = clk_prepare_enable(wdt->core_clk);\n\tif (ret)\n\t\treturn dev_err_probe(wdt->wdd.parent, ret, \"failed to enable core clock\\n\");\n\n\treturn 0;\n}\n\nstatic void starfive_wdt_disable_clock(struct starfive_wdt *wdt)\n{\n\tclk_disable_unprepare(wdt->core_clk);\n\tclk_disable_unprepare(wdt->apb_clk);\n}\n\nstatic inline int starfive_wdt_get_clock(struct starfive_wdt *wdt)\n{\n\tstruct device *dev = wdt->wdd.parent;\n\n\twdt->apb_clk = devm_clk_get(dev, \"apb\");\n\tif (IS_ERR(wdt->apb_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(wdt->apb_clk), \"failed to get apb clock\\n\");\n\n\twdt->core_clk = devm_clk_get(dev, \"core\");\n\tif (IS_ERR(wdt->core_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(wdt->core_clk), \"failed to get core clock\\n\");\n\n\treturn 0;\n}\n\nstatic inline int starfive_wdt_reset_init(struct device *dev)\n{\n\tstruct reset_control *rsts;\n\tint ret;\n\n\trsts = devm_reset_control_array_get_exclusive(dev);\n\tif (IS_ERR(rsts))\n\t\treturn dev_err_probe(dev, PTR_ERR(rsts), \"failed to get resets\\n\");\n\n\tret = reset_control_deassert(rsts);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to deassert resets\\n\");\n\n\treturn 0;\n}\n\nstatic u32 starfive_wdt_ticks_to_sec(struct starfive_wdt *wdt, u32 ticks)\n{\n\treturn DIV_ROUND_CLOSEST(ticks, wdt->freq);\n}\n\n \nstatic void starfive_wdt_unlock(struct starfive_wdt *wdt)\n{\n\tspin_lock(&wdt->lock);\n\twritel(wdt->variant->unlock_key, wdt->base + wdt->variant->unlock);\n}\n\nstatic void starfive_wdt_lock(struct starfive_wdt *wdt)\n{\n\twritel(~wdt->variant->unlock_key, wdt->base + wdt->variant->unlock);\n\tspin_unlock(&wdt->lock);\n}\n\n \nstatic void starfive_wdt_enable_reset(struct starfive_wdt *wdt)\n{\n\tu32 val;\n\n\tval = readl(wdt->base + wdt->variant->control);\n\tval |= STARFIVE_WDT_RESET_EN << wdt->variant->enrst_shift;\n\twritel(val, wdt->base + wdt->variant->control);\n}\n\n \nstatic bool starfive_wdt_raise_irq_status(struct starfive_wdt *wdt)\n{\n\treturn !!readl(wdt->base + wdt->variant->int_status);\n}\n\n \nstatic int starfive_wdt_wait_int_free(struct starfive_wdt *wdt)\n{\n\tu32 value;\n\n\treturn readl_poll_timeout_atomic(wdt->base + wdt->variant->int_clr, value,\n\t\t\t\t\t !(value & BIT(wdt->variant->intclr_ava_shift)),\n\t\t\t\t\t STARFIVE_WDT_DELAY_US, STARFIVE_WDT_TIMEOUT_US);\n}\n\n \nstatic int starfive_wdt_int_clr(struct starfive_wdt *wdt)\n{\n\tint ret;\n\n\tif (wdt->variant->intclr_check) {\n\t\tret = starfive_wdt_wait_int_free(wdt);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(wdt->wdd.parent, ret,\n\t\t\t\t\t     \"watchdog is not ready to clear interrupt.\\n\");\n\t}\n\twritel(STARFIVE_WDT_INTCLR, wdt->base + wdt->variant->int_clr);\n\n\treturn 0;\n}\n\nstatic inline void starfive_wdt_set_count(struct starfive_wdt *wdt, u32 val)\n{\n\twritel(val, wdt->base + wdt->variant->load);\n}\n\nstatic inline u32 starfive_wdt_get_count(struct starfive_wdt *wdt)\n{\n\treturn readl(wdt->base + wdt->variant->value);\n}\n\n \nstatic inline void starfive_wdt_enable(struct starfive_wdt *wdt)\n{\n\tu32 val;\n\n\tval = readl(wdt->base + wdt->variant->enable);\n\tval |= STARFIVE_WDT_ENABLE << wdt->variant->en_shift;\n\twritel(val, wdt->base + wdt->variant->enable);\n}\n\n \nstatic inline void starfive_wdt_disable(struct starfive_wdt *wdt)\n{\n\tu32 val;\n\n\tval = readl(wdt->base + wdt->variant->enable);\n\tval &= ~(STARFIVE_WDT_ENABLE << wdt->variant->en_shift);\n\twritel(val, wdt->base + wdt->variant->enable);\n}\n\nstatic inline void starfive_wdt_set_reload_count(struct starfive_wdt *wdt, u32 count)\n{\n\tstarfive_wdt_set_count(wdt, count);\n\n\t \n\tif (wdt->variant->reload)\n\t\twritel(0x1, wdt->base + wdt->variant->reload);\n}\n\nstatic unsigned int starfive_wdt_max_timeout(struct starfive_wdt *wdt)\n{\n\tif (wdt->variant->double_timeout)\n\t\treturn DIV_ROUND_UP(STARFIVE_WDT_MAXCNT, (wdt->freq / 2)) - 1;\n\n\treturn DIV_ROUND_UP(STARFIVE_WDT_MAXCNT, wdt->freq) - 1;\n}\n\nstatic unsigned int starfive_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct starfive_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu32 count;\n\n\t \n\tcount = starfive_wdt_get_count(wdt);\n\tif (wdt->variant->double_timeout && !starfive_wdt_raise_irq_status(wdt))\n\t\tcount += wdt->count;\n\n\treturn starfive_wdt_ticks_to_sec(wdt, count);\n}\n\nstatic int starfive_wdt_keepalive(struct watchdog_device *wdd)\n{\n\tstruct starfive_wdt *wdt = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tstarfive_wdt_unlock(wdt);\n\tret = starfive_wdt_int_clr(wdt);\n\tif (ret)\n\t\tgoto exit;\n\n\tstarfive_wdt_set_reload_count(wdt, wdt->count);\n\nexit:\n\t \n\tstarfive_wdt_lock(wdt);\n\treturn ret;\n}\n\nstatic int starfive_wdt_start(struct starfive_wdt *wdt)\n{\n\tint ret;\n\n\tstarfive_wdt_unlock(wdt);\n\t \n\tstarfive_wdt_disable(wdt);\n\n\tstarfive_wdt_enable_reset(wdt);\n\tret = starfive_wdt_int_clr(wdt);\n\tif (ret)\n\t\tgoto exit;\n\n\tstarfive_wdt_set_count(wdt, wdt->count);\n\tstarfive_wdt_enable(wdt);\n\nexit:\n\tstarfive_wdt_lock(wdt);\n\treturn ret;\n}\n\nstatic void starfive_wdt_stop(struct starfive_wdt *wdt)\n{\n\tstarfive_wdt_unlock(wdt);\n\tstarfive_wdt_disable(wdt);\n\tstarfive_wdt_lock(wdt);\n}\n\nstatic int starfive_wdt_pm_start(struct watchdog_device *wdd)\n{\n\tstruct starfive_wdt *wdt = watchdog_get_drvdata(wdd);\n\tint ret = pm_runtime_get_sync(wdd->parent);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn starfive_wdt_start(wdt);\n}\n\nstatic int starfive_wdt_pm_stop(struct watchdog_device *wdd)\n{\n\tstruct starfive_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\tstarfive_wdt_stop(wdt);\n\treturn pm_runtime_put_sync(wdd->parent);\n}\n\nstatic int starfive_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t    unsigned int timeout)\n{\n\tstruct starfive_wdt *wdt = watchdog_get_drvdata(wdd);\n\tunsigned long count = timeout * wdt->freq;\n\n\t \n\tif (wdt->variant->double_timeout)\n\t\tcount /= 2;\n\n\twdt->count = count;\n\twdd->timeout = timeout;\n\n\tstarfive_wdt_unlock(wdt);\n\tstarfive_wdt_disable(wdt);\n\tstarfive_wdt_set_reload_count(wdt, wdt->count);\n\tstarfive_wdt_enable(wdt);\n\tstarfive_wdt_lock(wdt);\n\n\treturn 0;\n}\n\n#define STARFIVE_WDT_OPTIONS (WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE)\n\nstatic const struct watchdog_info starfive_wdt_info = {\n\t.options = STARFIVE_WDT_OPTIONS,\n\t.identity = \"StarFive Watchdog\",\n};\n\nstatic const struct watchdog_ops starfive_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = starfive_wdt_pm_start,\n\t.stop = starfive_wdt_pm_stop,\n\t.ping = starfive_wdt_keepalive,\n\t.set_timeout = starfive_wdt_set_timeout,\n\t.get_timeleft = starfive_wdt_get_timeleft,\n};\n\nstatic int starfive_wdt_probe(struct platform_device *pdev)\n{\n\tstruct starfive_wdt *wdt;\n\tint ret;\n\n\twdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(wdt->base), \"error mapping registers\\n\");\n\n\twdt->wdd.parent = &pdev->dev;\n\tret = starfive_wdt_get_clock(wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, wdt);\n\tpm_runtime_enable(&pdev->dev);\n\tif (pm_runtime_enabled(&pdev->dev)) {\n\t\tret = pm_runtime_get_sync(&pdev->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tret = starfive_wdt_enable_clock(wdt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = starfive_wdt_reset_init(&pdev->dev);\n\tif (ret)\n\t\tgoto err_exit;\n\n\twatchdog_set_drvdata(&wdt->wdd, wdt);\n\twdt->wdd.info = &starfive_wdt_info;\n\twdt->wdd.ops = &starfive_wdt_ops;\n\twdt->variant = of_device_get_match_data(&pdev->dev);\n\tspin_lock_init(&wdt->lock);\n\n\twdt->freq = clk_get_rate(wdt->core_clk);\n\tif (!wdt->freq) {\n\t\tdev_err(&pdev->dev, \"get clock rate failed.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_exit;\n\t}\n\n\twdt->wdd.min_timeout = 1;\n\twdt->wdd.max_timeout = starfive_wdt_max_timeout(wdt);\n\twdt->wdd.timeout = STARFIVE_WDT_DEFAULT_TIME;\n\twatchdog_init_timeout(&wdt->wdd, heartbeat, &pdev->dev);\n\tstarfive_wdt_set_timeout(&wdt->wdd, wdt->wdd.timeout);\n\n\twatchdog_set_nowayout(&wdt->wdd, nowayout);\n\twatchdog_stop_on_reboot(&wdt->wdd);\n\twatchdog_stop_on_unregister(&wdt->wdd);\n\n\tif (early_enable) {\n\t\tret = starfive_wdt_start(wdt);\n\t\tif (ret)\n\t\t\tgoto err_exit;\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->wdd.status);\n\t} else {\n\t\tstarfive_wdt_stop(wdt);\n\t}\n\n\tret = watchdog_register_device(&wdt->wdd);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tif (!early_enable)\n\t\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn 0;\n\nerr_exit:\n\tstarfive_wdt_disable_clock(wdt);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int starfive_wdt_remove(struct platform_device *pdev)\n{\n\tstruct starfive_wdt *wdt = platform_get_drvdata(pdev);\n\n\tstarfive_wdt_stop(wdt);\n\twatchdog_unregister_device(&wdt->wdd);\n\n\tif (pm_runtime_enabled(&pdev->dev))\n\t\tpm_runtime_disable(&pdev->dev);\n\telse\n\t\t \n\t\tstarfive_wdt_disable_clock(wdt);\n\n\treturn 0;\n}\n\nstatic void starfive_wdt_shutdown(struct platform_device *pdev)\n{\n\tstruct starfive_wdt *wdt = platform_get_drvdata(pdev);\n\n\tstarfive_wdt_pm_stop(&wdt->wdd);\n}\n\nstatic int starfive_wdt_suspend(struct device *dev)\n{\n\tstruct starfive_wdt *wdt = dev_get_drvdata(dev);\n\n\t \n\twdt->reload = starfive_wdt_get_count(wdt);\n\n\t \n\tstarfive_wdt_stop(wdt);\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int starfive_wdt_resume(struct device *dev)\n{\n\tstruct starfive_wdt *wdt = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tstarfive_wdt_unlock(wdt);\n\t \n\tstarfive_wdt_set_reload_count(wdt, wdt->reload);\n\tstarfive_wdt_lock(wdt);\n\n\treturn starfive_wdt_start(wdt);\n}\n\nstatic int starfive_wdt_runtime_suspend(struct device *dev)\n{\n\tstruct starfive_wdt *wdt = dev_get_drvdata(dev);\n\n\tstarfive_wdt_disable_clock(wdt);\n\n\treturn 0;\n}\n\nstatic int starfive_wdt_runtime_resume(struct device *dev)\n{\n\tstruct starfive_wdt *wdt = dev_get_drvdata(dev);\n\n\treturn starfive_wdt_enable_clock(wdt);\n}\n\nstatic const struct dev_pm_ops starfive_wdt_pm_ops = {\n\tRUNTIME_PM_OPS(starfive_wdt_runtime_suspend, starfive_wdt_runtime_resume, NULL)\n\tSYSTEM_SLEEP_PM_OPS(starfive_wdt_suspend, starfive_wdt_resume)\n};\n\nstatic const struct of_device_id starfive_wdt_match[] = {\n\t{ .compatible = \"starfive,jh7100-wdt\", .data = &starfive_wdt_jh7100_variant },\n\t{ .compatible = \"starfive,jh7110-wdt\", .data = &starfive_wdt_jh7110_variant },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, starfive_wdt_match);\n\nstatic struct platform_driver starfive_wdt_driver = {\n\t.probe = starfive_wdt_probe,\n\t.remove = starfive_wdt_remove,\n\t.shutdown = starfive_wdt_shutdown,\n\t.driver = {\n\t\t.name = \"starfive-wdt\",\n\t\t.pm = pm_ptr(&starfive_wdt_pm_ops),\n\t\t.of_match_table = starfive_wdt_match,\n\t},\n};\nmodule_platform_driver(starfive_wdt_driver);\n\nMODULE_AUTHOR(\"Xingyu Wu <xingyu.wu@starfivetech.com>\");\nMODULE_AUTHOR(\"Samin Guo <samin.guo@starfivetech.com>\");\nMODULE_DESCRIPTION(\"StarFive Watchdog Device Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}