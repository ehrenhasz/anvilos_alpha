{
  "module_name": "w83627hf_wdt.c",
  "hash_id": "aca9b0229496aaec6db4c51d8a700c0376f3dbf8277699eb53bd55457e4e6156",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/w83627hf_wdt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/dmi.h>\n\n#define WATCHDOG_NAME \"w83627hf/thf/hg/dhg WDT\"\n#define WATCHDOG_TIMEOUT 60\t\t \n\nstatic int wdt_io;\nstatic int cr_wdt_timeout;\t \nstatic int cr_wdt_control;\t \nstatic int cr_wdt_csr;\t\t \nstatic int wdt_cfg_enter = 0x87; \nstatic int wdt_cfg_leave = 0xAA; \n\nenum chips { w83627hf, w83627s, w83697hf, w83697ug, w83637hf, w83627thf,\n\t     w83687thf, w83627ehf, w83627dhg, w83627uhg, w83667hg, w83627dhg_p,\n\t     w83667hg_b, nct6775, nct6776, nct6779, nct6791, nct6792, nct6793,\n\t     nct6795, nct6796, nct6102, nct6116 };\n\nstatic int timeout;\t\t\t \nmodule_param(timeout, int, 0);\nMODULE_PARM_DESC(timeout,\n\t\t\"Watchdog timeout in seconds. 1 <= timeout <= 255, default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_TIMEOUT) \".\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int early_disable;\nmodule_param(early_disable, int, 0);\nMODULE_PARM_DESC(early_disable, \"Disable watchdog at boot time (default=0)\");\n\n \n\n#define WDT_EFER (wdt_io+0)    \n#define WDT_EFIR (wdt_io+0)    \n#define WDT_EFDR (WDT_EFIR+1)  \n\n#define W83627HF_LD_WDT\t\t0x08\n\n#define W83627HF_ID\t\t0x52\n#define W83627S_ID\t\t0x59\n#define W83697HF_ID\t\t0x60\n#define W83697UG_ID\t\t0x68\n#define W83637HF_ID\t\t0x70\n#define W83627THF_ID\t\t0x82\n#define W83687THF_ID\t\t0x85\n#define W83627EHF_ID\t\t0x88\n#define W83627DHG_ID\t\t0xa0\n#define W83627UHG_ID\t\t0xa2\n#define W83667HG_ID\t\t0xa5\n#define W83627DHG_P_ID\t\t0xb0\n#define W83667HG_B_ID\t\t0xb3\n#define NCT6775_ID\t\t0xb4\n#define NCT6776_ID\t\t0xc3\n#define NCT6102_ID\t\t0xc4\n#define NCT6116_ID\t\t0xd2\n#define NCT6779_ID\t\t0xc5\n#define NCT6791_ID\t\t0xc8\n#define NCT6792_ID\t\t0xc9\n#define NCT6793_ID\t\t0xd1\n#define NCT6795_ID\t\t0xd3\n#define NCT6796_ID\t\t0xd4\t \n\n#define W83627HF_WDT_TIMEOUT\t0xf6\n#define W83697HF_WDT_TIMEOUT\t0xf4\n#define NCT6102D_WDT_TIMEOUT\t0xf1\n\n#define W83627HF_WDT_CONTROL\t0xf5\n#define W83697HF_WDT_CONTROL\t0xf3\n#define NCT6102D_WDT_CONTROL\t0xf0\n\n#define W836X7HF_WDT_CSR\t0xf7\n#define NCT6102D_WDT_CSR\t0xf2\n\n#define WDT_CSR_STATUS\t\t0x10\n#define WDT_CSR_KBD\t\t0x40\n#define WDT_CSR_MOUSE\t\t0x80\n\nstatic void superio_outb(int reg, int val)\n{\n\toutb(reg, WDT_EFER);\n\toutb(val, WDT_EFDR);\n}\n\nstatic inline int superio_inb(int reg)\n{\n\toutb(reg, WDT_EFER);\n\treturn inb(WDT_EFDR);\n}\n\nstatic int superio_enter(void)\n{\n\tif (!request_muxed_region(wdt_io, 2, WATCHDOG_NAME))\n\t\treturn -EBUSY;\n\n\toutb_p(wdt_cfg_enter, WDT_EFER);  \n\toutb_p(wdt_cfg_enter, WDT_EFER);  \n\n\treturn 0;\n}\n\nstatic void superio_select(int ld)\n{\n\tsuperio_outb(0x07, ld);\n}\n\nstatic void superio_exit(void)\n{\n\toutb_p(wdt_cfg_leave, WDT_EFER);  \n\trelease_region(wdt_io, 2);\n}\n\nstatic int w83627hf_init(struct watchdog_device *wdog, enum chips chip)\n{\n\tint ret;\n\tunsigned char t;\n\n\tret = superio_enter();\n\tif (ret)\n\t\treturn ret;\n\n\tsuperio_select(W83627HF_LD_WDT);\n\n\t \n\tt = superio_inb(0x30);\n\tif (!(t & 0x01))\n\t\tsuperio_outb(0x30, t | 0x01);\n\n\tswitch (chip) {\n\tcase w83627hf:\n\tcase w83627s:\n\t\tt = superio_inb(0x2B) & ~0x10;\n\t\tsuperio_outb(0x2B, t);  \n\t\tbreak;\n\tcase w83697hf:\n\t\t \n\t\tt = superio_inb(0x29) & ~0x60;\n\t\tt |= 0x20;\n\t\tsuperio_outb(0x29, t);\n\t\tbreak;\n\tcase w83697ug:\n\t\t \n\t\tt = superio_inb(0x2b) & ~0x04;\n\t\tsuperio_outb(0x2b, t);\n\t\tbreak;\n\tcase w83627thf:\n\t\tt = (superio_inb(0x2B) & ~0x08) | 0x04;\n\t\tsuperio_outb(0x2B, t);  \n\t\tbreak;\n\tcase w83627dhg:\n\tcase w83627dhg_p:\n\t\tt = superio_inb(0x2D) & ~0x01;  \n\t\tsuperio_outb(0x2D, t);  \n\t\tt = superio_inb(cr_wdt_control);\n\t\tt |= 0x02;\t \n\t\tsuperio_outb(cr_wdt_control, t);\n\t\tbreak;\n\tcase w83637hf:\n\t\tbreak;\n\tcase w83687thf:\n\t\tt = superio_inb(0x2C) & ~0x80;  \n\t\tsuperio_outb(0x2C, t);\n\t\tbreak;\n\tcase w83627ehf:\n\tcase w83627uhg:\n\tcase w83667hg:\n\tcase w83667hg_b:\n\tcase nct6775:\n\tcase nct6776:\n\tcase nct6779:\n\tcase nct6791:\n\tcase nct6792:\n\tcase nct6793:\n\tcase nct6795:\n\tcase nct6796:\n\tcase nct6102:\n\tcase nct6116:\n\t\t \n\t\tt = superio_inb(cr_wdt_control);\n\t\tt |= 0x02;\t \n\t\tsuperio_outb(cr_wdt_control, t);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt = superio_inb(cr_wdt_timeout);\n\tif (t != 0) {\n\t\tif (early_disable) {\n\t\t\tpr_warn(\"Stopping previously enabled watchdog until userland kicks in\\n\");\n\t\t\tsuperio_outb(cr_wdt_timeout, 0);\n\t\t} else {\n\t\t\tpr_info(\"Watchdog already running. Resetting timeout to %d sec\\n\",\n\t\t\t\twdog->timeout);\n\t\t\tsuperio_outb(cr_wdt_timeout, wdog->timeout);\n\t\t}\n\t}\n\n\t \n\tt = superio_inb(cr_wdt_control) & ~0x0C;\n\tsuperio_outb(cr_wdt_control, t);\n\n\tt = superio_inb(cr_wdt_csr);\n\tif (t & WDT_CSR_STATUS)\n\t\twdog->bootstatus |= WDIOF_CARDRESET;\n\n\t \n\tt &= ~(WDT_CSR_STATUS | WDT_CSR_KBD | WDT_CSR_MOUSE);\n\tsuperio_outb(cr_wdt_csr, t);\n\n\tsuperio_exit();\n\n\treturn 0;\n}\n\nstatic int wdt_set_time(unsigned int timeout)\n{\n\tint ret;\n\n\tret = superio_enter();\n\tif (ret)\n\t\treturn ret;\n\n\tsuperio_select(W83627HF_LD_WDT);\n\tsuperio_outb(cr_wdt_timeout, timeout);\n\tsuperio_exit();\n\n\treturn 0;\n}\n\nstatic int wdt_start(struct watchdog_device *wdog)\n{\n\treturn wdt_set_time(wdog->timeout);\n}\n\nstatic int wdt_stop(struct watchdog_device *wdog)\n{\n\treturn wdt_set_time(0);\n}\n\nstatic int wdt_set_timeout(struct watchdog_device *wdog, unsigned int timeout)\n{\n\twdog->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic unsigned int wdt_get_time(struct watchdog_device *wdog)\n{\n\tunsigned int timeleft;\n\tint ret;\n\n\tret = superio_enter();\n\tif (ret)\n\t\treturn 0;\n\n\tsuperio_select(W83627HF_LD_WDT);\n\ttimeleft = superio_inb(cr_wdt_timeout);\n\tsuperio_exit();\n\n\treturn timeleft;\n}\n\n \n\nstatic const struct watchdog_info wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"W83627HF Watchdog\",\n};\n\nstatic const struct watchdog_ops wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = wdt_start,\n\t.stop = wdt_stop,\n\t.set_timeout = wdt_set_timeout,\n\t.get_timeleft = wdt_get_time,\n};\n\nstatic struct watchdog_device wdt_dev = {\n\t.info = &wdt_info,\n\t.ops = &wdt_ops,\n\t.timeout = WATCHDOG_TIMEOUT,\n\t.min_timeout = 1,\n\t.max_timeout = 255,\n};\n\n \n\nstatic int wdt_find(int addr)\n{\n\tu8 val;\n\tint ret;\n\n\tcr_wdt_timeout = W83627HF_WDT_TIMEOUT;\n\tcr_wdt_control = W83627HF_WDT_CONTROL;\n\tcr_wdt_csr = W836X7HF_WDT_CSR;\n\n\tret = superio_enter();\n\tif (ret)\n\t\treturn ret;\n\tsuperio_select(W83627HF_LD_WDT);\n\tval = superio_inb(0x20);\n\tswitch (val) {\n\tcase W83627HF_ID:\n\t\tret = w83627hf;\n\t\tbreak;\n\tcase W83627S_ID:\n\t\tret = w83627s;\n\t\tbreak;\n\tcase W83697HF_ID:\n\t\tret = w83697hf;\n\t\tcr_wdt_timeout = W83697HF_WDT_TIMEOUT;\n\t\tcr_wdt_control = W83697HF_WDT_CONTROL;\n\t\tbreak;\n\tcase W83697UG_ID:\n\t\tret = w83697ug;\n\t\tcr_wdt_timeout = W83697HF_WDT_TIMEOUT;\n\t\tcr_wdt_control = W83697HF_WDT_CONTROL;\n\t\tbreak;\n\tcase W83637HF_ID:\n\t\tret = w83637hf;\n\t\tbreak;\n\tcase W83627THF_ID:\n\t\tret = w83627thf;\n\t\tbreak;\n\tcase W83687THF_ID:\n\t\tret = w83687thf;\n\t\tbreak;\n\tcase W83627EHF_ID:\n\t\tret = w83627ehf;\n\t\tbreak;\n\tcase W83627DHG_ID:\n\t\tret = w83627dhg;\n\t\tbreak;\n\tcase W83627DHG_P_ID:\n\t\tret = w83627dhg_p;\n\t\tbreak;\n\tcase W83627UHG_ID:\n\t\tret = w83627uhg;\n\t\tbreak;\n\tcase W83667HG_ID:\n\t\tret = w83667hg;\n\t\tbreak;\n\tcase W83667HG_B_ID:\n\t\tret = w83667hg_b;\n\t\tbreak;\n\tcase NCT6775_ID:\n\t\tret = nct6775;\n\t\tbreak;\n\tcase NCT6776_ID:\n\t\tret = nct6776;\n\t\tbreak;\n\tcase NCT6779_ID:\n\t\tret = nct6779;\n\t\tbreak;\n\tcase NCT6791_ID:\n\t\tret = nct6791;\n\t\tbreak;\n\tcase NCT6792_ID:\n\t\tret = nct6792;\n\t\tbreak;\n\tcase NCT6793_ID:\n\t\tret = nct6793;\n\t\tbreak;\n\tcase NCT6795_ID:\n\t\tret = nct6795;\n\t\tbreak;\n\tcase NCT6796_ID:\n\t\tret = nct6796;\n\t\tbreak;\n\tcase NCT6102_ID:\n\t\tret = nct6102;\n\t\tcr_wdt_timeout = NCT6102D_WDT_TIMEOUT;\n\t\tcr_wdt_control = NCT6102D_WDT_CONTROL;\n\t\tcr_wdt_csr = NCT6102D_WDT_CSR;\n\t\tbreak;\n\tcase NCT6116_ID:\n\t\tret = nct6116;\n\t\tcr_wdt_timeout = NCT6102D_WDT_TIMEOUT;\n\t\tcr_wdt_control = NCT6102D_WDT_CONTROL;\n\t\tcr_wdt_csr = NCT6102D_WDT_CSR;\n\t\tbreak;\n\tcase 0xff:\n\t\tret = -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tpr_err(\"Unsupported chip ID: 0x%02x\\n\", val);\n\t\tbreak;\n\t}\n\tsuperio_exit();\n\treturn ret;\n}\n\n \nstatic int __init wdt_use_alt_key(const struct dmi_system_id *d)\n{\n\twdt_cfg_enter = 0x88;\n\twdt_cfg_leave = 0xBB;\n\n\treturn 0;\n}\n\nstatic const struct dmi_system_id wdt_dmi_table[] __initconst = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"INVES\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"CTS\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"INVES\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"SHARKBAY\"),\n\t\t},\n\t\t.callback = wdt_use_alt_key,\n\t},\n\t{}\n};\n\nstatic int __init wdt_init(void)\n{\n\tint ret;\n\tint chip;\n\tstatic const char * const chip_name[] = {\n\t\t\"W83627HF\",\n\t\t\"W83627S\",\n\t\t\"W83697HF\",\n\t\t\"W83697UG\",\n\t\t\"W83637HF\",\n\t\t\"W83627THF\",\n\t\t\"W83687THF\",\n\t\t\"W83627EHF\",\n\t\t\"W83627DHG\",\n\t\t\"W83627UHG\",\n\t\t\"W83667HG\",\n\t\t\"W83667DHG-P\",\n\t\t\"W83667HG-B\",\n\t\t\"NCT6775\",\n\t\t\"NCT6776\",\n\t\t\"NCT6779\",\n\t\t\"NCT6791\",\n\t\t\"NCT6792\",\n\t\t\"NCT6793\",\n\t\t\"NCT6795\",\n\t\t\"NCT6796\",\n\t\t\"NCT6102\",\n\t\t\"NCT6116\",\n\t};\n\n\t \n\tdmi_check_system(wdt_dmi_table);\n\n\twdt_io = 0x2e;\n\tchip = wdt_find(0x2e);\n\tif (chip < 0) {\n\t\twdt_io = 0x4e;\n\t\tchip = wdt_find(0x4e);\n\t\tif (chip < 0)\n\t\t\treturn chip;\n\t}\n\n\tpr_info(\"WDT driver for %s Super I/O chip initialising\\n\",\n\t\tchip_name[chip]);\n\n\twatchdog_init_timeout(&wdt_dev, timeout, NULL);\n\twatchdog_set_nowayout(&wdt_dev, nowayout);\n\twatchdog_stop_on_reboot(&wdt_dev);\n\n\tret = w83627hf_init(&wdt_dev, chip);\n\tif (ret) {\n\t\tpr_err(\"failed to initialize watchdog (err=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = watchdog_register_device(&wdt_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"initialized. timeout=%d sec (nowayout=%d)\\n\",\n\t\twdt_dev.timeout, nowayout);\n\n\treturn ret;\n}\n\nstatic void __exit wdt_exit(void)\n{\n\twatchdog_unregister_device(&wdt_dev);\n}\n\nmodule_init(wdt_init);\nmodule_exit(wdt_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"P\u00e1draig  Brady <P@draigBrady.com>\");\nMODULE_DESCRIPTION(\"w83627hf/thf WDT driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}