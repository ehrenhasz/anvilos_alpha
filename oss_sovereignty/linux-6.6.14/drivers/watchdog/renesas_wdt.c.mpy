{
  "module_name": "renesas_wdt.c",
  "hash_id": "c98d4ea9f2cd03ffcee21b07345032283626ab85a2323e35a700629ca3875b67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/renesas_wdt.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/smp.h>\n#include <linux/sys_soc.h>\n#include <linux/watchdog.h>\n\n#define RWTCNT\t\t0\n#define RWTCSRA\t\t4\n#define RWTCSRA_WOVF\tBIT(4)\n#define RWTCSRA_WRFLG\tBIT(5)\n#define RWTCSRA_TME\tBIT(7)\n#define RWTCSRB\t\t8\n\n#define RWDT_DEFAULT_TIMEOUT 60U\n\n \n#define MUL_BY_CLKS_PER_SEC(p, d) \\\n\tDIV_ROUND_UP((d) * (p)->clk_rate, clk_divs[(p)->cks])\n\n \n#define DIV_BY_CLKS_PER_SEC(p, d) ((d) * clk_divs[(p)->cks] / (p)->clk_rate)\n\nstatic const unsigned int clk_divs[] = { 1, 4, 16, 32, 64, 128, 1024, 4096 };\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct rwdt_priv {\n\tvoid __iomem *base;\n\tstruct watchdog_device wdev;\n\tunsigned long clk_rate;\n\tu8 cks;\n\tstruct clk *clk;\n};\n\nstatic void rwdt_write(struct rwdt_priv *priv, u32 val, unsigned int reg)\n{\n\tif (reg == RWTCNT)\n\t\tval |= 0x5a5a0000;\n\telse\n\t\tval |= 0xa5a5a500;\n\n\twritel_relaxed(val, priv->base + reg);\n}\n\nstatic int rwdt_init_timeout(struct watchdog_device *wdev)\n{\n\tstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\trwdt_write(priv, 65536 - MUL_BY_CLKS_PER_SEC(priv, wdev->timeout), RWTCNT);\n\n\treturn 0;\n}\n\nstatic void rwdt_wait_cycles(struct rwdt_priv *priv, unsigned int cycles)\n{\n\tunsigned int delay;\n\n\tdelay = DIV_ROUND_UP(cycles * 1000000, priv->clk_rate);\n\n\tusleep_range(delay, 2 * delay);\n}\n\nstatic int rwdt_start(struct watchdog_device *wdev)\n{\n\tstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu8 val;\n\n\tpm_runtime_get_sync(wdev->parent);\n\n\t \n\tval = readb_relaxed(priv->base + RWTCSRA) & ~RWTCSRA_TME;\n\trwdt_write(priv, val, RWTCSRA);\n\t \n\trwdt_wait_cycles(priv, 2);\n\n\trwdt_init_timeout(wdev);\n\trwdt_write(priv, priv->cks, RWTCSRA);\n\trwdt_write(priv, 0, RWTCSRB);\n\n\twhile (readb_relaxed(priv->base + RWTCSRA) & RWTCSRA_WRFLG)\n\t\tcpu_relax();\n\n\trwdt_write(priv, priv->cks | RWTCSRA_TME, RWTCSRA);\n\n\treturn 0;\n}\n\nstatic int rwdt_stop(struct watchdog_device *wdev)\n{\n\tstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\n\n\trwdt_write(priv, priv->cks, RWTCSRA);\n\t \n\trwdt_wait_cycles(priv, 3);\n\tpm_runtime_put(wdev->parent);\n\n\treturn 0;\n}\n\nstatic unsigned int rwdt_get_timeleft(struct watchdog_device *wdev)\n{\n\tstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu16 val = readw_relaxed(priv->base + RWTCNT);\n\n\treturn DIV_BY_CLKS_PER_SEC(priv, 65536 - val);\n}\n\n \nstatic int rwdt_restart(struct watchdog_device *wdev, unsigned long action,\n\t\t\tvoid *data)\n{\n\tstruct rwdt_priv *priv = watchdog_get_drvdata(wdev);\n\tu8 val;\n\n\tclk_prepare_enable(priv->clk);\n\n\t \n\tval = readb_relaxed(priv->base + RWTCSRA) & ~RWTCSRA_TME;\n\trwdt_write(priv, val, RWTCSRA);\n\t \n\tudelay(DIV_ROUND_UP(2 * 1000000, priv->clk_rate));\n\n\trwdt_write(priv, 0xffff, RWTCNT);\n\t \n\trwdt_write(priv, 0, RWTCSRA);\n\n\treadb_poll_timeout_atomic(priv->base + RWTCSRA, val,\n\t\t\t\t  !(val & RWTCSRA_WRFLG), 1, 100);\n\n\trwdt_write(priv, RWTCSRA_TME, RWTCSRA);\n\n\t \n\tudelay(DIV_ROUND_UP(2 * 1000000, priv->clk_rate));\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info rwdt_ident = {\n\t.options = WDIOF_MAGICCLOSE | WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\n\t\tWDIOF_CARDRESET,\n\t.identity = \"Renesas WDT Watchdog\",\n};\n\nstatic const struct watchdog_ops rwdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = rwdt_start,\n\t.stop = rwdt_stop,\n\t.ping = rwdt_init_timeout,\n\t.get_timeleft = rwdt_get_timeleft,\n\t.restart = rwdt_restart,\n};\n\n#if defined(CONFIG_ARCH_RCAR_GEN2) && defined(CONFIG_SMP)\n \nstatic const struct soc_device_attribute rwdt_quirks_match[] = {\n\t{\n\t\t.soc_id = \"r8a7790\",\n\t\t.revision = \"ES1.*\",\n\t\t.data = (void *)1,\t \n\t}, {\n\t\t.soc_id = \"r8a7791\",\n\t\t.revision = \"ES1.*\",\n\t\t.data = (void *)1,\t \n\t}, {\n\t\t.soc_id = \"r8a7792\",\n\t\t.data = (void *)0,\t \n\t},\n\t{   }\n};\n\nstatic bool rwdt_blacklisted(struct device *dev)\n{\n\tconst struct soc_device_attribute *attr;\n\n\tattr = soc_device_match(rwdt_quirks_match);\n\tif (attr && setup_max_cpus > (uintptr_t)attr->data) {\n\t\tdev_info(dev, \"Watchdog blacklisted on %s %s\\n\", attr->soc_id,\n\t\t\t attr->revision);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n#else  \nstatic inline bool rwdt_blacklisted(struct device *dev) { return false; }\n#endif  \n\nstatic int rwdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rwdt_priv *priv;\n\tunsigned long clks_per_sec;\n\tint ret, i;\n\tu8 csra;\n\n\tif (rwdt_blacklisted(dev))\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\tpriv->clk_rate = clk_get_rate(priv->clk);\n\tcsra = readb_relaxed(priv->base + RWTCSRA);\n\tpriv->wdev.bootstatus = csra & RWTCSRA_WOVF ? WDIOF_CARDRESET : 0;\n\tpm_runtime_put(dev);\n\n\tif (!priv->clk_rate) {\n\t\tret = -ENOENT;\n\t\tgoto out_pm_disable;\n\t}\n\n\tfor (i = ARRAY_SIZE(clk_divs) - 1; i >= 0; i--) {\n\t\tclks_per_sec = priv->clk_rate / clk_divs[i];\n\t\tif (clks_per_sec && clks_per_sec < 65536) {\n\t\t\tpriv->cks = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i < 0) {\n\t\tdev_err(dev, \"Can't find suitable clock divider\\n\");\n\t\tret = -ERANGE;\n\t\tgoto out_pm_disable;\n\t}\n\n\tpriv->wdev.info = &rwdt_ident;\n\tpriv->wdev.ops = &rwdt_ops;\n\tpriv->wdev.parent = dev;\n\tpriv->wdev.min_timeout = 1;\n\tpriv->wdev.max_timeout = DIV_BY_CLKS_PER_SEC(priv, 65536);\n\tpriv->wdev.timeout = min(priv->wdev.max_timeout, RWDT_DEFAULT_TIMEOUT);\n\n\tplatform_set_drvdata(pdev, priv);\n\twatchdog_set_drvdata(&priv->wdev, priv);\n\twatchdog_set_nowayout(&priv->wdev, nowayout);\n\twatchdog_set_restart_priority(&priv->wdev, 0);\n\twatchdog_stop_on_unregister(&priv->wdev);\n\n\t \n\twatchdog_init_timeout(&priv->wdev, 0, dev);\n\n\t \n\tif (csra & RWTCSRA_TME) {\n\t\t \n\t\trwdt_start(&priv->wdev);\n\t\tset_bit(WDOG_HW_RUNNING, &priv->wdev.status);\n\t}\n\n\tret = watchdog_register_device(&priv->wdev);\n\tif (ret < 0)\n\t\tgoto out_pm_disable;\n\n\treturn 0;\n\n out_pm_disable:\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void rwdt_remove(struct platform_device *pdev)\n{\n\tstruct rwdt_priv *priv = platform_get_drvdata(pdev);\n\n\twatchdog_unregister_device(&priv->wdev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused rwdt_suspend(struct device *dev)\n{\n\tstruct rwdt_priv *priv = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&priv->wdev))\n\t\trwdt_stop(&priv->wdev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rwdt_resume(struct device *dev)\n{\n\tstruct rwdt_priv *priv = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&priv->wdev))\n\t\trwdt_start(&priv->wdev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rwdt_pm_ops, rwdt_suspend, rwdt_resume);\n\nstatic const struct of_device_id rwdt_ids[] = {\n\t{ .compatible = \"renesas,rcar-gen2-wdt\", },\n\t{ .compatible = \"renesas,rcar-gen3-wdt\", },\n\t{ .compatible = \"renesas,rcar-gen4-wdt\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rwdt_ids);\n\nstatic struct platform_driver rwdt_driver = {\n\t.driver = {\n\t\t.name = \"renesas_wdt\",\n\t\t.of_match_table = rwdt_ids,\n\t\t.pm = &rwdt_pm_ops,\n\t},\n\t.probe = rwdt_probe,\n\t.remove_new = rwdt_remove,\n};\nmodule_platform_driver(rwdt_driver);\n\nMODULE_DESCRIPTION(\"Renesas WDT Watchdog Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Wolfram Sang <wsa@sang-engineering.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}