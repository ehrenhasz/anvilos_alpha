{
  "module_name": "st_lpc_wdt.c",
  "hash_id": "37a9a2fe841eef15f802a6b12693e04f8ab1f71fb711bb0eeea9ca3beac87661",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/st_lpc_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/watchdog.h>\n\n#include <dt-bindings/mfd/st-lpc.h>\n\n \n#define LPC_LPA_LSB_OFF\t\t\t0x410\n#define LPC_LPA_START_OFF\t\t0x418\n\n \n#define LPC_WDT_OFF\t\t\t0x510\n\nstatic struct watchdog_device st_wdog_dev;\n\nstruct st_wdog_syscfg {\n\tunsigned int reset_type_reg;\n\tunsigned int reset_type_mask;\n\tunsigned int enable_reg;\n\tunsigned int enable_mask;\n};\n\nstruct st_wdog {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct st_wdog_syscfg *syscfg;\n\tstruct clk *clk;\n\tunsigned long clkrate;\n\tbool warm_reset;\n};\n\nstatic struct st_wdog_syscfg stih407_syscfg = {\n\t.enable_reg\t\t= 0x204,\n\t.enable_mask\t\t= BIT(19),\n};\n\nstatic const struct of_device_id st_wdog_match[] = {\n\t{\n\t\t.compatible = \"st,stih407-lpc\",\n\t\t.data = &stih407_syscfg,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, st_wdog_match);\n\nstatic void st_wdog_setup(struct st_wdog *st_wdog, bool enable)\n{\n\t \n\tif (st_wdog->syscfg->reset_type_reg)\n\t\tregmap_update_bits(st_wdog->regmap,\n\t\t\t\t   st_wdog->syscfg->reset_type_reg,\n\t\t\t\t   st_wdog->syscfg->reset_type_mask,\n\t\t\t\t   st_wdog->warm_reset);\n\n\t \n\tregmap_update_bits(st_wdog->regmap,\n\t\t\t   st_wdog->syscfg->enable_reg,\n\t\t\t   st_wdog->syscfg->enable_mask,\n\t\t\t   enable ? 0 : st_wdog->syscfg->enable_mask);\n}\n\nstatic void st_wdog_load_timer(struct st_wdog *st_wdog, unsigned int timeout)\n{\n\tunsigned long clkrate = st_wdog->clkrate;\n\n\twritel_relaxed(timeout * clkrate, st_wdog->base + LPC_LPA_LSB_OFF);\n\twritel_relaxed(1, st_wdog->base + LPC_LPA_START_OFF);\n}\n\nstatic int st_wdog_start(struct watchdog_device *wdd)\n{\n\tstruct st_wdog *st_wdog = watchdog_get_drvdata(wdd);\n\n\twritel_relaxed(1, st_wdog->base + LPC_WDT_OFF);\n\n\treturn 0;\n}\n\nstatic int st_wdog_stop(struct watchdog_device *wdd)\n{\n\tstruct st_wdog *st_wdog = watchdog_get_drvdata(wdd);\n\n\twritel_relaxed(0, st_wdog->base + LPC_WDT_OFF);\n\n\treturn 0;\n}\n\nstatic int st_wdog_set_timeout(struct watchdog_device *wdd,\n\t\t\t       unsigned int timeout)\n{\n\tstruct st_wdog *st_wdog = watchdog_get_drvdata(wdd);\n\n\twdd->timeout = timeout;\n\tst_wdog_load_timer(st_wdog, timeout);\n\n\treturn 0;\n}\n\nstatic int st_wdog_keepalive(struct watchdog_device *wdd)\n{\n\tstruct st_wdog *st_wdog = watchdog_get_drvdata(wdd);\n\n\tst_wdog_load_timer(st_wdog, wdd->timeout);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info st_wdog_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"ST LPC WDT\",\n};\n\nstatic const struct watchdog_ops st_wdog_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= st_wdog_start,\n\t.stop\t\t= st_wdog_stop,\n\t.ping\t\t= st_wdog_keepalive,\n\t.set_timeout\t= st_wdog_set_timeout,\n};\n\nstatic struct watchdog_device st_wdog_dev = {\n\t.info\t\t= &st_wdog_info,\n\t.ops\t\t= &st_wdog_ops,\n};\n\nstatic void st_clk_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int st_wdog_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tstruct device_node *np = dev->of_node;\n\tstruct st_wdog *st_wdog;\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tuint32_t mode;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"st,lpc-mode\", &mode);\n\tif (ret) {\n\t\tdev_err(dev, \"An LPC mode must be provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mode != ST_LPC_MODE_WDT)\n\t\treturn -ENODEV;\n\n\tst_wdog = devm_kzalloc(dev, sizeof(*st_wdog), GFP_KERNEL);\n\tif (!st_wdog)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_device(st_wdog_match, dev);\n\tif (!match) {\n\t\tdev_err(dev, \"Couldn't match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tst_wdog->syscfg\t= (struct st_wdog_syscfg *)match->data;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tregmap = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"No syscfg phandle specified\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"Unable to request clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tst_wdog->dev\t\t= dev;\n\tst_wdog->base\t\t= base;\n\tst_wdog->clk\t\t= clk;\n\tst_wdog->regmap\t\t= regmap;\n\tst_wdog->warm_reset\t= of_property_read_bool(np, \"st,warm_reset\");\n\tst_wdog->clkrate\t= clk_get_rate(st_wdog->clk);\n\n\tif (!st_wdog->clkrate) {\n\t\tdev_err(dev, \"Unable to fetch clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\tst_wdog_dev.max_timeout = 0xFFFFFFFF / st_wdog->clkrate;\n\tst_wdog_dev.parent = dev;\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable clock\\n\");\n\t\treturn ret;\n\t}\n\tret = devm_add_action_or_reset(dev, st_clk_disable_unprepare, clk);\n\tif (ret)\n\t\treturn ret;\n\n\twatchdog_set_drvdata(&st_wdog_dev, st_wdog);\n\twatchdog_set_nowayout(&st_wdog_dev, WATCHDOG_NOWAYOUT);\n\n\t \n\tret = watchdog_init_timeout(&st_wdog_dev, 0, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_watchdog_register_device(dev, &st_wdog_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tst_wdog_setup(st_wdog, true);\n\n\tdev_info(dev, \"LPC Watchdog driver registered, reset type is %s\",\n\t\t st_wdog->warm_reset ? \"warm\" : \"cold\");\n\n\treturn ret;\n}\n\nstatic void st_wdog_remove(struct platform_device *pdev)\n{\n\tstruct st_wdog *st_wdog = watchdog_get_drvdata(&st_wdog_dev);\n\n\tst_wdog_setup(st_wdog, false);\n}\n\nstatic int st_wdog_suspend(struct device *dev)\n{\n\tstruct st_wdog *st_wdog = watchdog_get_drvdata(&st_wdog_dev);\n\n\tif (watchdog_active(&st_wdog_dev))\n\t\tst_wdog_stop(&st_wdog_dev);\n\n\tst_wdog_setup(st_wdog, false);\n\n\tclk_disable(st_wdog->clk);\n\n\treturn 0;\n}\n\nstatic int st_wdog_resume(struct device *dev)\n{\n\tstruct st_wdog *st_wdog = watchdog_get_drvdata(&st_wdog_dev);\n\tint ret;\n\n\tret = clk_enable(st_wdog->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to re-enable clock\\n\");\n\t\twatchdog_unregister_device(&st_wdog_dev);\n\t\tclk_unprepare(st_wdog->clk);\n\t\treturn ret;\n\t}\n\n\tst_wdog_setup(st_wdog, true);\n\n\tif (watchdog_active(&st_wdog_dev)) {\n\t\tst_wdog_load_timer(st_wdog, st_wdog_dev.timeout);\n\t\tst_wdog_start(&st_wdog_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(st_wdog_pm_ops,\n\t\t\t\tst_wdog_suspend, st_wdog_resume);\n\nstatic struct platform_driver st_wdog_driver = {\n\t.driver\t= {\n\t\t.name = \"st-lpc-wdt\",\n\t\t.pm = pm_sleep_ptr(&st_wdog_pm_ops),\n\t\t.of_match_table = st_wdog_match,\n\t},\n\t.probe = st_wdog_probe,\n\t.remove_new = st_wdog_remove,\n};\nmodule_platform_driver(st_wdog_driver);\n\nMODULE_AUTHOR(\"David Paris <david.paris@st.com>\");\nMODULE_DESCRIPTION(\"ST LPC Watchdog Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}