{
  "module_name": "gef_wdt.c",
  "hash_id": "ad3d0eb76fce33bc27e440f23fb8a15d88fc3b31cf0b155a99712928d232aaaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/gef_wdt.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/fs.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include <sysdev/fsl_soc.h>\n\n \n#define GEF_WDC_ENABLE_SHIFT\t24\n#define GEF_WDC_SERVICE_SHIFT\t26\n#define GEF_WDC_ENABLED_SHIFT\t31\n\n#define GEF_WDC_ENABLED_TRUE\t1\n#define GEF_WDC_ENABLED_FALSE\t0\n\n \n#define GEF_WDOG_FLAG_OPENED\t0\n\nstatic unsigned long wdt_flags;\nstatic int wdt_status;\nstatic void __iomem *gef_wdt_regs;\nstatic int gef_wdt_timeout;\nstatic int gef_wdt_count;\nstatic unsigned int bus_clk;\nstatic char expect_close;\nstatic DEFINE_SPINLOCK(gef_wdt_spinlock);\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n\nstatic int gef_wdt_toggle_wdc(int enabled_predicate, int field_shift)\n{\n\tu32 data;\n\tu32 enabled;\n\tint ret = 0;\n\n\tspin_lock(&gef_wdt_spinlock);\n\tdata = ioread32be(gef_wdt_regs);\n\tenabled = (data >> GEF_WDC_ENABLED_SHIFT) & 1;\n\n\t \n\tif ((enabled ^ enabled_predicate) == 0) {\n\t\t \n\t\tdata = (1 << field_shift) | gef_wdt_count;\n\t\tiowrite32be(data, gef_wdt_regs);\n\n\t\tdata = (2 << field_shift) | gef_wdt_count;\n\t\tiowrite32be(data, gef_wdt_regs);\n\t\tret = 1;\n\t}\n\tspin_unlock(&gef_wdt_spinlock);\n\n\treturn ret;\n}\n\nstatic void gef_wdt_service(void)\n{\n\tgef_wdt_toggle_wdc(GEF_WDC_ENABLED_TRUE,\n\t\tGEF_WDC_SERVICE_SHIFT);\n}\n\nstatic void gef_wdt_handler_enable(void)\n{\n\tif (gef_wdt_toggle_wdc(GEF_WDC_ENABLED_FALSE,\n\t\t\t\t   GEF_WDC_ENABLE_SHIFT)) {\n\t\tgef_wdt_service();\n\t\tpr_notice(\"watchdog activated\\n\");\n\t}\n}\n\nstatic void gef_wdt_handler_disable(void)\n{\n\tif (gef_wdt_toggle_wdc(GEF_WDC_ENABLED_TRUE,\n\t\t\t\t   GEF_WDC_ENABLE_SHIFT))\n\t\tpr_notice(\"watchdog deactivated\\n\");\n}\n\nstatic void gef_wdt_set_timeout(unsigned int timeout)\n{\n\t \n\tif (timeout > 0xFFFFFFFF / bus_clk)\n\t\ttimeout = 0xFFFFFFFF / bus_clk;\n\n\t \n\tgef_wdt_count = (timeout * bus_clk) >> 8;\n\tgef_wdt_timeout = timeout;\n}\n\n\nstatic ssize_t gef_wdt_write(struct file *file, const char __user *data,\n\t\t\t\t size_t len, loff_t *ppos)\n{\n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\texpect_close = 0;\n\n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, data + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\t\tgef_wdt_service();\n\t}\n\n\treturn len;\n}\n\nstatic long gef_wdt_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint timeout;\n\tint options;\n\tvoid __user *argp = (void __user *)arg;\n\tstatic const struct watchdog_info info = {\n\t\t.options =\tWDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE |\n\t\t\t\tWDIOF_KEEPALIVEPING,\n\t\t.firmware_version = 0,\n\t\t.identity = \"GE watchdog\",\n\t};\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\tif (copy_to_user(argp, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\tif (put_user(wdt_status, (int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\twdt_status &= ~WDIOF_KEEPALIVEPING;\n\t\tbreak;\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(options, (int __user *)argp))\n\t\t\treturn -EFAULT;\n\n\t\tif (options & WDIOS_DISABLECARD)\n\t\t\tgef_wdt_handler_disable();\n\n\t\tif (options & WDIOS_ENABLECARD)\n\t\t\tgef_wdt_handler_enable();\n\t\tbreak;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tgef_wdt_service();\n\t\twdt_status |= WDIOF_KEEPALIVEPING;\n\t\tbreak;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (get_user(timeout, (int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\tgef_wdt_set_timeout(timeout);\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\tif (put_user(gef_wdt_timeout, (int __user *)argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\nstatic int gef_wdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(GEF_WDOG_FLAG_OPENED, &wdt_flags))\n\t\treturn -EBUSY;\n\n\tif (nowayout)\n\t\t__module_get(THIS_MODULE);\n\n\tgef_wdt_handler_enable();\n\n\treturn stream_open(inode, file);\n}\n\nstatic int gef_wdt_release(struct inode *inode, struct file *file)\n{\n\tif (expect_close == 42)\n\t\tgef_wdt_handler_disable();\n\telse {\n\t\tpr_crit(\"unexpected close, not stopping timer!\\n\");\n\t\tgef_wdt_service();\n\t}\n\texpect_close = 0;\n\n\tclear_bit(GEF_WDOG_FLAG_OPENED, &wdt_flags);\n\n\treturn 0;\n}\n\nstatic const struct file_operations gef_wdt_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.write = gef_wdt_write,\n\t.unlocked_ioctl = gef_wdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open = gef_wdt_open,\n\t.release = gef_wdt_release,\n};\n\nstatic struct miscdevice gef_wdt_miscdev = {\n\t.minor = WATCHDOG_MINOR,\n\t.name = \"watchdog\",\n\t.fops = &gef_wdt_fops,\n};\n\n\nstatic int gef_wdt_probe(struct platform_device *dev)\n{\n\tint timeout = 10;\n\tu32 freq;\n\n\tbus_clk = 133;  \n\n\tfreq = fsl_get_sys_freq();\n\tif (freq != -1)\n\t\tbus_clk = freq;\n\n\t \n\tgef_wdt_regs = of_iomap(dev->dev.of_node, 0);\n\tif (gef_wdt_regs == NULL)\n\t\treturn -ENOMEM;\n\n\tgef_wdt_set_timeout(timeout);\n\n\tgef_wdt_handler_disable();\t \n\n\treturn misc_register(&gef_wdt_miscdev);\n}\n\nstatic void gef_wdt_remove(struct platform_device *dev)\n{\n\tmisc_deregister(&gef_wdt_miscdev);\n\n\tgef_wdt_handler_disable();\n\n\tiounmap(gef_wdt_regs);\n}\n\nstatic const struct of_device_id gef_wdt_ids[] = {\n\t{\n\t\t.compatible = \"gef,fpga-wdt\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gef_wdt_ids);\n\nstatic struct platform_driver gef_wdt_driver = {\n\t.driver = {\n\t\t.name = \"gef_wdt\",\n\t\t.of_match_table = gef_wdt_ids,\n\t},\n\t.probe\t\t= gef_wdt_probe,\n\t.remove_new\t= gef_wdt_remove,\n};\n\nstatic int __init gef_wdt_init(void)\n{\n\tpr_info(\"GE watchdog driver\\n\");\n\treturn platform_driver_register(&gef_wdt_driver);\n}\n\nstatic void __exit gef_wdt_exit(void)\n{\n\tplatform_driver_unregister(&gef_wdt_driver);\n}\n\nmodule_init(gef_wdt_init);\nmodule_exit(gef_wdt_exit);\n\nMODULE_AUTHOR(\"Martyn Welch <martyn.welch@ge.com>\");\nMODULE_DESCRIPTION(\"GE watchdog driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:gef_wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}