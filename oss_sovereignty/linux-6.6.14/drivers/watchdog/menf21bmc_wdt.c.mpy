{
  "module_name": "menf21bmc_wdt.c",
  "hash_id": "8921918e2be6dc804b8a9047d191518d01cedf9ff738a512c0976457c7d11597",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/menf21bmc_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/watchdog.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n\n#define DEVNAME \"menf21bmc_wdt\"\n\n#define BMC_CMD_WD_ON\t\t0x11\n#define BMC_CMD_WD_OFF\t\t0x12\n#define BMC_CMD_WD_TRIG\t\t0x13\n#define BMC_CMD_WD_TIME\t\t0x14\n#define BMC_CMD_WD_STATE\t0x17\n#define BMC_WD_OFF_VAL\t\t0x69\n#define BMC_CMD_RST_RSN\t\t0x92\n\n#define BMC_WD_TIMEOUT_MIN\t1\t \n#define BMC_WD_TIMEOUT_MAX\t6553\t \n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct menf21bmc_wdt {\n\tstruct watchdog_device wdt;\n\tstruct i2c_client *i2c_client;\n};\n\nstatic int menf21bmc_wdt_set_bootstatus(struct menf21bmc_wdt *data)\n{\n\tint rst_rsn;\n\n\trst_rsn = i2c_smbus_read_byte_data(data->i2c_client, BMC_CMD_RST_RSN);\n\tif (rst_rsn < 0)\n\t\treturn rst_rsn;\n\n\tif (rst_rsn == 0x02)\n\t\tdata->wdt.bootstatus |= WDIOF_CARDRESET;\n\telse if (rst_rsn == 0x05)\n\t\tdata->wdt.bootstatus |= WDIOF_EXTERN1;\n\telse if (rst_rsn == 0x06)\n\t\tdata->wdt.bootstatus |= WDIOF_EXTERN2;\n\telse if (rst_rsn == 0x0A)\n\t\tdata->wdt.bootstatus |= WDIOF_POWERUNDER;\n\n\treturn 0;\n}\n\nstatic int menf21bmc_wdt_start(struct watchdog_device *wdt)\n{\n\tstruct menf21bmc_wdt *drv_data = watchdog_get_drvdata(wdt);\n\n\treturn i2c_smbus_write_byte(drv_data->i2c_client, BMC_CMD_WD_ON);\n}\n\nstatic int menf21bmc_wdt_stop(struct watchdog_device *wdt)\n{\n\tstruct menf21bmc_wdt *drv_data = watchdog_get_drvdata(wdt);\n\n\treturn i2c_smbus_write_byte_data(drv_data->i2c_client,\n\t\t\t\t\t BMC_CMD_WD_OFF, BMC_WD_OFF_VAL);\n}\n\nstatic int\nmenf21bmc_wdt_settimeout(struct watchdog_device *wdt, unsigned int timeout)\n{\n\tint ret;\n\tstruct menf21bmc_wdt *drv_data = watchdog_get_drvdata(wdt);\n\n\t \n\tret = i2c_smbus_write_word_data(drv_data->i2c_client,\n\t\t\t\t\tBMC_CMD_WD_TIME, timeout * 10);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twdt->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic int menf21bmc_wdt_ping(struct watchdog_device *wdt)\n{\n\tstruct menf21bmc_wdt *drv_data = watchdog_get_drvdata(wdt);\n\n\treturn i2c_smbus_write_byte(drv_data->i2c_client, BMC_CMD_WD_TRIG);\n}\n\nstatic const struct watchdog_info menf21bmc_wdt_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,\n\t.identity = DEVNAME,\n};\n\nstatic const struct watchdog_ops menf21bmc_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= menf21bmc_wdt_start,\n\t.stop\t\t= menf21bmc_wdt_stop,\n\t.ping\t\t= menf21bmc_wdt_ping,\n\t.set_timeout\t= menf21bmc_wdt_settimeout,\n};\n\nstatic int menf21bmc_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret, bmc_timeout;\n\tstruct menf21bmc_wdt *drv_data;\n\tstruct i2c_client *i2c_client = to_i2c_client(dev->parent);\n\n\tdrv_data = devm_kzalloc(dev, sizeof(struct menf21bmc_wdt), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tdrv_data->wdt.ops = &menf21bmc_wdt_ops;\n\tdrv_data->wdt.info = &menf21bmc_wdt_info;\n\tdrv_data->wdt.min_timeout = BMC_WD_TIMEOUT_MIN;\n\tdrv_data->wdt.max_timeout = BMC_WD_TIMEOUT_MAX;\n\tdrv_data->wdt.parent = dev;\n\tdrv_data->i2c_client = i2c_client;\n\n\t \n\tbmc_timeout = i2c_smbus_read_word_data(drv_data->i2c_client,\n\t\t\t\t\t       BMC_CMD_WD_TIME);\n\tif (bmc_timeout < 0) {\n\t\tdev_err(dev, \"failed to get current WDT timeout\\n\");\n\t\treturn bmc_timeout;\n\t}\n\n\twatchdog_init_timeout(&drv_data->wdt, bmc_timeout / 10, dev);\n\twatchdog_set_nowayout(&drv_data->wdt, nowayout);\n\twatchdog_set_drvdata(&drv_data->wdt, drv_data);\n\tplatform_set_drvdata(pdev, drv_data);\n\n\tret = menf21bmc_wdt_set_bootstatus(drv_data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set Watchdog bootstatus\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_watchdog_register_device(dev, &drv_data->wdt);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"MEN 14F021P00 BMC Watchdog device enabled\\n\");\n\n\treturn 0;\n}\n\nstatic void menf21bmc_wdt_shutdown(struct platform_device *pdev)\n{\n\tstruct menf21bmc_wdt *drv_data = platform_get_drvdata(pdev);\n\n\ti2c_smbus_write_word_data(drv_data->i2c_client,\n\t\t\t\t  BMC_CMD_WD_OFF, BMC_WD_OFF_VAL);\n}\n\nstatic struct  platform_driver menf21bmc_wdt = {\n\t.driver\t\t= {\n\t\t.name\t= DEVNAME,\n\t},\n\t.probe\t\t= menf21bmc_wdt_probe,\n\t.shutdown\t= menf21bmc_wdt_shutdown,\n};\n\nmodule_platform_driver(menf21bmc_wdt);\n\nMODULE_DESCRIPTION(\"MEN 14F021P00 BMC Watchdog driver\");\nMODULE_AUTHOR(\"Andreas Werner <andreas.werner@men.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:menf21bmc_wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}