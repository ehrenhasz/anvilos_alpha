{
  "module_name": "lpc18xx_wdt.c",
  "hash_id": "17e8dd5da4ac4ab80124837ee4438468259ae3f90ddce99de0398da438f16291",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/lpc18xx_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n \n#define LPC18XX_WDT_MOD\t\t\t0x00\n#define LPC18XX_WDT_MOD_WDEN\t\tBIT(0)\n#define LPC18XX_WDT_MOD_WDRESET\t\tBIT(1)\n\n#define LPC18XX_WDT_TC\t\t\t0x04\n#define LPC18XX_WDT_TC_MIN\t\t0xff\n#define LPC18XX_WDT_TC_MAX\t\t0xffffff\n\n#define LPC18XX_WDT_FEED\t\t0x08\n#define LPC18XX_WDT_FEED_MAGIC1\t\t0xaa\n#define LPC18XX_WDT_FEED_MAGIC2\t\t0x55\n\n#define LPC18XX_WDT_TV\t\t\t0x0c\n\n \n#define LPC18XX_WDT_CLK_DIV\t\t4\n\n \n#define LPC18XX_WDT_DEF_TIMEOUT\t\t30U\n\nstatic int heartbeat;\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat, \"Watchdog heartbeats in seconds (default=\"\n\t\t __MODULE_STRING(LPC18XX_WDT_DEF_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct lpc18xx_wdt_dev {\n\tstruct watchdog_device\twdt_dev;\n\tstruct clk\t\t*reg_clk;\n\tstruct clk\t\t*wdt_clk;\n\tunsigned long\t\tclk_rate;\n\tvoid __iomem\t\t*base;\n\tstruct timer_list\ttimer;\n\tspinlock_t\t\tlock;\n};\n\nstatic int lpc18xx_wdt_feed(struct watchdog_device *wdt_dev)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&lpc18xx_wdt->lock, flags);\n\twritel(LPC18XX_WDT_FEED_MAGIC1, lpc18xx_wdt->base + LPC18XX_WDT_FEED);\n\twritel(LPC18XX_WDT_FEED_MAGIC2, lpc18xx_wdt->base + LPC18XX_WDT_FEED);\n\tspin_unlock_irqrestore(&lpc18xx_wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic void lpc18xx_wdt_timer_feed(struct timer_list *t)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt = from_timer(lpc18xx_wdt, t, timer);\n\tstruct watchdog_device *wdt_dev = &lpc18xx_wdt->wdt_dev;\n\n\tlpc18xx_wdt_feed(wdt_dev);\n\n\t \n\tmod_timer(&lpc18xx_wdt->timer, jiffies +\n\t\t  msecs_to_jiffies((wdt_dev->timeout * MSEC_PER_SEC) / 2));\n}\n\n \nstatic int lpc18xx_wdt_stop(struct watchdog_device *wdt_dev)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt = watchdog_get_drvdata(wdt_dev);\n\n\tlpc18xx_wdt_timer_feed(&lpc18xx_wdt->timer);\n\n\treturn 0;\n}\n\nstatic void __lpc18xx_wdt_set_timeout(struct lpc18xx_wdt_dev *lpc18xx_wdt)\n{\n\tunsigned int val;\n\n\tval = DIV_ROUND_UP(lpc18xx_wdt->wdt_dev.timeout * lpc18xx_wdt->clk_rate,\n\t\t\t   LPC18XX_WDT_CLK_DIV);\n\twritel(val, lpc18xx_wdt->base + LPC18XX_WDT_TC);\n}\n\nstatic int lpc18xx_wdt_set_timeout(struct watchdog_device *wdt_dev,\n\t\t\t\t   unsigned int new_timeout)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt = watchdog_get_drvdata(wdt_dev);\n\n\tlpc18xx_wdt->wdt_dev.timeout = new_timeout;\n\t__lpc18xx_wdt_set_timeout(lpc18xx_wdt);\n\n\treturn 0;\n}\n\nstatic unsigned int lpc18xx_wdt_get_timeleft(struct watchdog_device *wdt_dev)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned int val;\n\n\tval = readl(lpc18xx_wdt->base + LPC18XX_WDT_TV);\n\treturn (val * LPC18XX_WDT_CLK_DIV) / lpc18xx_wdt->clk_rate;\n}\n\nstatic int lpc18xx_wdt_start(struct watchdog_device *wdt_dev)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned int val;\n\n\tif (timer_pending(&lpc18xx_wdt->timer))\n\t\tdel_timer(&lpc18xx_wdt->timer);\n\n\tval = readl(lpc18xx_wdt->base + LPC18XX_WDT_MOD);\n\tval |= LPC18XX_WDT_MOD_WDEN;\n\tval |= LPC18XX_WDT_MOD_WDRESET;\n\twritel(val, lpc18xx_wdt->base + LPC18XX_WDT_MOD);\n\n\t \n\tlpc18xx_wdt_feed(wdt_dev);\n\n\treturn 0;\n}\n\nstatic int lpc18xx_wdt_restart(struct watchdog_device *wdt_dev,\n\t\t\t       unsigned long action, void *data)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt = watchdog_get_drvdata(wdt_dev);\n\tunsigned long flags;\n\tint val;\n\n\t \n\tspin_lock_irqsave(&lpc18xx_wdt->lock, flags);\n\n\tval = readl(lpc18xx_wdt->base + LPC18XX_WDT_MOD);\n\tval |= LPC18XX_WDT_MOD_WDEN;\n\tval |= LPC18XX_WDT_MOD_WDRESET;\n\twritel(val, lpc18xx_wdt->base + LPC18XX_WDT_MOD);\n\n\twritel(LPC18XX_WDT_FEED_MAGIC1, lpc18xx_wdt->base + LPC18XX_WDT_FEED);\n\twritel(LPC18XX_WDT_FEED_MAGIC2, lpc18xx_wdt->base + LPC18XX_WDT_FEED);\n\n\twritel(LPC18XX_WDT_FEED_MAGIC1, lpc18xx_wdt->base + LPC18XX_WDT_FEED);\n\twritel(LPC18XX_WDT_FEED_MAGIC1, lpc18xx_wdt->base + LPC18XX_WDT_FEED);\n\n\tspin_unlock_irqrestore(&lpc18xx_wdt->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info lpc18xx_wdt_info = {\n\t.identity\t= \"NXP LPC18xx Watchdog\",\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops lpc18xx_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= lpc18xx_wdt_start,\n\t.stop\t\t= lpc18xx_wdt_stop,\n\t.ping\t\t= lpc18xx_wdt_feed,\n\t.set_timeout\t= lpc18xx_wdt_set_timeout,\n\t.get_timeleft\t= lpc18xx_wdt_get_timeleft,\n\t.restart        = lpc18xx_wdt_restart,\n};\n\nstatic int lpc18xx_wdt_probe(struct platform_device *pdev)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt;\n\tstruct device *dev = &pdev->dev;\n\n\tlpc18xx_wdt = devm_kzalloc(dev, sizeof(*lpc18xx_wdt), GFP_KERNEL);\n\tif (!lpc18xx_wdt)\n\t\treturn -ENOMEM;\n\n\tlpc18xx_wdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lpc18xx_wdt->base))\n\t\treturn PTR_ERR(lpc18xx_wdt->base);\n\n\tlpc18xx_wdt->reg_clk = devm_clk_get_enabled(dev, \"reg\");\n\tif (IS_ERR(lpc18xx_wdt->reg_clk)) {\n\t\tdev_err(dev, \"failed to get the reg clock\\n\");\n\t\treturn PTR_ERR(lpc18xx_wdt->reg_clk);\n\t}\n\n\tlpc18xx_wdt->wdt_clk = devm_clk_get_enabled(dev, \"wdtclk\");\n\tif (IS_ERR(lpc18xx_wdt->wdt_clk)) {\n\t\tdev_err(dev, \"failed to get the wdt clock\\n\");\n\t\treturn PTR_ERR(lpc18xx_wdt->wdt_clk);\n\t}\n\n\t \n\tlpc18xx_wdt->clk_rate = clk_get_rate(lpc18xx_wdt->wdt_clk);\n\tif (lpc18xx_wdt->clk_rate == 0) {\n\t\tdev_err(dev, \"failed to get clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlpc18xx_wdt->wdt_dev.info = &lpc18xx_wdt_info;\n\tlpc18xx_wdt->wdt_dev.ops = &lpc18xx_wdt_ops;\n\n\tlpc18xx_wdt->wdt_dev.min_timeout = DIV_ROUND_UP(LPC18XX_WDT_TC_MIN *\n\t\t\t\tLPC18XX_WDT_CLK_DIV, lpc18xx_wdt->clk_rate);\n\n\tlpc18xx_wdt->wdt_dev.max_timeout = (LPC18XX_WDT_TC_MAX *\n\t\t\t\tLPC18XX_WDT_CLK_DIV) / lpc18xx_wdt->clk_rate;\n\n\tlpc18xx_wdt->wdt_dev.timeout = min(lpc18xx_wdt->wdt_dev.max_timeout,\n\t\t\t\t\t   LPC18XX_WDT_DEF_TIMEOUT);\n\n\tspin_lock_init(&lpc18xx_wdt->lock);\n\n\tlpc18xx_wdt->wdt_dev.parent = dev;\n\twatchdog_set_drvdata(&lpc18xx_wdt->wdt_dev, lpc18xx_wdt);\n\n\twatchdog_init_timeout(&lpc18xx_wdt->wdt_dev, heartbeat, dev);\n\n\t__lpc18xx_wdt_set_timeout(lpc18xx_wdt);\n\n\ttimer_setup(&lpc18xx_wdt->timer, lpc18xx_wdt_timer_feed, 0);\n\n\twatchdog_set_nowayout(&lpc18xx_wdt->wdt_dev, nowayout);\n\twatchdog_set_restart_priority(&lpc18xx_wdt->wdt_dev, 128);\n\n\tplatform_set_drvdata(pdev, lpc18xx_wdt);\n\n\twatchdog_stop_on_reboot(&lpc18xx_wdt->wdt_dev);\n\treturn devm_watchdog_register_device(dev, &lpc18xx_wdt->wdt_dev);\n}\n\nstatic void lpc18xx_wdt_remove(struct platform_device *pdev)\n{\n\tstruct lpc18xx_wdt_dev *lpc18xx_wdt = platform_get_drvdata(pdev);\n\n\tdev_warn(&pdev->dev, \"I quit now, hardware will probably reboot!\\n\");\n\tdel_timer_sync(&lpc18xx_wdt->timer);\n}\n\nstatic const struct of_device_id lpc18xx_wdt_match[] = {\n\t{ .compatible = \"nxp,lpc1850-wwdt\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lpc18xx_wdt_match);\n\nstatic struct platform_driver lpc18xx_wdt_driver = {\n\t.driver = {\n\t\t.name = \"lpc18xx-wdt\",\n\t\t.of_match_table\t= lpc18xx_wdt_match,\n\t},\n\t.probe = lpc18xx_wdt_probe,\n\t.remove_new = lpc18xx_wdt_remove,\n};\nmodule_platform_driver(lpc18xx_wdt_driver);\n\nMODULE_AUTHOR(\"Ariel D'Alessandro <ariel@vanguardiasur.com.ar>\");\nMODULE_DESCRIPTION(\"NXP LPC18xx Watchdog Timer Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}