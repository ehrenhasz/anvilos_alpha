{
  "module_name": "of_xilinx_wdt.c",
  "hash_id": "3f0540cc4397c335d5718796660db35d6e4544a5658130e57a9915a0223d508e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/of_xilinx_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/watchdog.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n \n#define XWT_TWCSR0_OFFSET   0x0  \n#define XWT_TWCSR1_OFFSET   0x4  \n#define XWT_TBR_OFFSET      0x8  \n\n \n#define XWT_CSR0_WRS_MASK\tBIT(3)  \n#define XWT_CSR0_WDS_MASK\tBIT(2)  \n#define XWT_CSR0_EWDT1_MASK\tBIT(1)  \n\n \n#define XWT_CSRX_EWDT2_MASK\tBIT(0)  \n\n \n#define XWT_MAX_SELFTEST_LOOP_COUNT 0x00010000\n#define XWT_TIMER_FAILED            0xFFFFFFFF\n\n#define WATCHDOG_NAME     \"Xilinx Watchdog\"\n\nstruct xwdt_device {\n\tvoid __iomem *base;\n\tu32 wdt_interval;\n\tspinlock_t spinlock;  \n\tstruct watchdog_device xilinx_wdt_wdd;\n\tstruct clk\t\t*clk;\n};\n\nstatic int xilinx_wdt_start(struct watchdog_device *wdd)\n{\n\tint ret;\n\tu32 control_status_reg;\n\tstruct xwdt_device *xdev = watchdog_get_drvdata(wdd);\n\n\tret = clk_enable(xdev->clk);\n\tif (ret) {\n\t\tdev_err(wdd->parent, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tspin_lock(&xdev->spinlock);\n\n\t \n\tcontrol_status_reg = ioread32(xdev->base + XWT_TWCSR0_OFFSET);\n\tcontrol_status_reg |= (XWT_CSR0_WRS_MASK | XWT_CSR0_WDS_MASK);\n\n\tiowrite32((control_status_reg | XWT_CSR0_EWDT1_MASK),\n\t\t  xdev->base + XWT_TWCSR0_OFFSET);\n\n\tiowrite32(XWT_CSRX_EWDT2_MASK, xdev->base + XWT_TWCSR1_OFFSET);\n\n\tspin_unlock(&xdev->spinlock);\n\n\tdev_dbg(wdd->parent, \"Watchdog Started!\\n\");\n\n\treturn 0;\n}\n\nstatic int xilinx_wdt_stop(struct watchdog_device *wdd)\n{\n\tu32 control_status_reg;\n\tstruct xwdt_device *xdev = watchdog_get_drvdata(wdd);\n\n\tspin_lock(&xdev->spinlock);\n\n\tcontrol_status_reg = ioread32(xdev->base + XWT_TWCSR0_OFFSET);\n\n\tiowrite32((control_status_reg & ~XWT_CSR0_EWDT1_MASK),\n\t\t  xdev->base + XWT_TWCSR0_OFFSET);\n\n\tiowrite32(0, xdev->base + XWT_TWCSR1_OFFSET);\n\n\tspin_unlock(&xdev->spinlock);\n\n\tclk_disable(xdev->clk);\n\n\tdev_dbg(wdd->parent, \"Watchdog Stopped!\\n\");\n\n\treturn 0;\n}\n\nstatic int xilinx_wdt_keepalive(struct watchdog_device *wdd)\n{\n\tu32 control_status_reg;\n\tstruct xwdt_device *xdev = watchdog_get_drvdata(wdd);\n\n\tspin_lock(&xdev->spinlock);\n\n\tcontrol_status_reg = ioread32(xdev->base + XWT_TWCSR0_OFFSET);\n\tcontrol_status_reg |= (XWT_CSR0_WRS_MASK | XWT_CSR0_WDS_MASK);\n\tiowrite32(control_status_reg, xdev->base + XWT_TWCSR0_OFFSET);\n\n\tspin_unlock(&xdev->spinlock);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info xilinx_wdt_ident = {\n\t.options =  WDIOF_MAGICCLOSE |\n\t\t    WDIOF_KEEPALIVEPING,\n\t.firmware_version =\t1,\n\t.identity =\tWATCHDOG_NAME,\n};\n\nstatic const struct watchdog_ops xilinx_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = xilinx_wdt_start,\n\t.stop = xilinx_wdt_stop,\n\t.ping = xilinx_wdt_keepalive,\n};\n\nstatic u32 xwdt_selftest(struct xwdt_device *xdev)\n{\n\tint i;\n\tu32 timer_value1;\n\tu32 timer_value2;\n\n\tspin_lock(&xdev->spinlock);\n\n\ttimer_value1 = ioread32(xdev->base + XWT_TBR_OFFSET);\n\ttimer_value2 = ioread32(xdev->base + XWT_TBR_OFFSET);\n\n\tfor (i = 0;\n\t\t((i <= XWT_MAX_SELFTEST_LOOP_COUNT) &&\n\t\t\t(timer_value2 == timer_value1)); i++) {\n\t\ttimer_value2 = ioread32(xdev->base + XWT_TBR_OFFSET);\n\t}\n\n\tspin_unlock(&xdev->spinlock);\n\n\tif (timer_value2 != timer_value1)\n\t\treturn ~XWT_TIMER_FAILED;\n\telse\n\t\treturn XWT_TIMER_FAILED;\n}\n\nstatic int xwdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint rc;\n\tu32 pfreq = 0, enable_once = 0;\n\tstruct xwdt_device *xdev;\n\tstruct watchdog_device *xilinx_wdt_wdd;\n\n\txdev = devm_kzalloc(dev, sizeof(*xdev), GFP_KERNEL);\n\tif (!xdev)\n\t\treturn -ENOMEM;\n\n\txilinx_wdt_wdd = &xdev->xilinx_wdt_wdd;\n\txilinx_wdt_wdd->info = &xilinx_wdt_ident;\n\txilinx_wdt_wdd->ops = &xilinx_wdt_ops;\n\txilinx_wdt_wdd->parent = dev;\n\n\txdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(xdev->base))\n\t\treturn PTR_ERR(xdev->base);\n\n\trc = of_property_read_u32(dev->of_node, \"xlnx,wdt-interval\",\n\t\t\t\t  &xdev->wdt_interval);\n\tif (rc)\n\t\tdev_warn(dev, \"Parameter \\\"xlnx,wdt-interval\\\" not found\\n\");\n\n\trc = of_property_read_u32(dev->of_node, \"xlnx,wdt-enable-once\",\n\t\t\t\t  &enable_once);\n\tif (rc)\n\t\tdev_warn(dev,\n\t\t\t \"Parameter \\\"xlnx,wdt-enable-once\\\" not found\\n\");\n\n\twatchdog_set_nowayout(xilinx_wdt_wdd, enable_once);\n\n\txdev->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(xdev->clk)) {\n\t\tif (PTR_ERR(xdev->clk) != -ENOENT)\n\t\t\treturn PTR_ERR(xdev->clk);\n\n\t\t \n\t\txdev->clk = NULL;\n\n\t\trc = of_property_read_u32(dev->of_node, \"clock-frequency\",\n\t\t\t\t\t  &pfreq);\n\t\tif (rc)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"The watchdog clock freq cannot be obtained\\n\");\n\t} else {\n\t\tpfreq = clk_get_rate(xdev->clk);\n\t}\n\n\t \n\tif (pfreq && xdev->wdt_interval)\n\t\txilinx_wdt_wdd->timeout = 2 * ((1 << xdev->wdt_interval) /\n\t\t\t\t\t  pfreq);\n\n\tspin_lock_init(&xdev->spinlock);\n\twatchdog_set_drvdata(xilinx_wdt_wdd, xdev);\n\n\trc = xwdt_selftest(xdev);\n\tif (rc == XWT_TIMER_FAILED) {\n\t\tdev_err(dev, \"SelfTest routine error\\n\");\n\t\treturn rc;\n\t}\n\n\trc = devm_watchdog_register_device(dev, xilinx_wdt_wdd);\n\tif (rc)\n\t\treturn rc;\n\n\tclk_disable(xdev->clk);\n\n\tdev_info(dev, \"Xilinx Watchdog Timer with timeout %ds\\n\",\n\t\t xilinx_wdt_wdd->timeout);\n\n\tplatform_set_drvdata(pdev, xdev);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused xwdt_suspend(struct device *dev)\n{\n\tstruct xwdt_device *xdev = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&xdev->xilinx_wdt_wdd))\n\t\txilinx_wdt_stop(&xdev->xilinx_wdt_wdd);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused xwdt_resume(struct device *dev)\n{\n\tstruct xwdt_device *xdev = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (watchdog_active(&xdev->xilinx_wdt_wdd))\n\t\tret = xilinx_wdt_start(&xdev->xilinx_wdt_wdd);\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(xwdt_pm_ops, xwdt_suspend, xwdt_resume);\n\n \nstatic const struct of_device_id xwdt_of_match[] = {\n\t{ .compatible = \"xlnx,xps-timebase-wdt-1.00.a\", },\n\t{ .compatible = \"xlnx,xps-timebase-wdt-1.01.a\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xwdt_of_match);\n\nstatic struct platform_driver xwdt_driver = {\n\t.probe       = xwdt_probe,\n\t.driver = {\n\t\t.name  = WATCHDOG_NAME,\n\t\t.of_match_table = xwdt_of_match,\n\t\t.pm = &xwdt_pm_ops,\n\t},\n};\n\nmodule_platform_driver(xwdt_driver);\n\nMODULE_AUTHOR(\"Alejandro Cabrera <aldaya@gmail.com>\");\nMODULE_DESCRIPTION(\"Xilinx Watchdog driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}