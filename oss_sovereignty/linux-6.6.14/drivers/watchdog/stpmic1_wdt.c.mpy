{
  "module_name": "stpmic1_wdt.c",
  "hash_id": "a387de309c602b8f63e1ecf4ee630a27de119d0504fdbf34aede286f481a51b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/stpmic1_wdt.c",
  "human_readable_source": "\n\n\n\n#include <linux/kernel.h>\n#include <linux/mfd/stpmic1.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/watchdog.h>\n\n \n#define WDT_START\t\tBIT(0)\n#define WDT_PING\t\tBIT(1)\n#define WDT_START_MASK\t\tBIT(0)\n#define WDT_PING_MASK\t\tBIT(1)\n#define WDT_STOP\t\t0\n\n#define PMIC_WDT_MIN_TIMEOUT 1\n#define PMIC_WDT_MAX_TIMEOUT 256\n#define PMIC_WDT_DEFAULT_TIMEOUT 30\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct stpmic1_wdt {\n\tstruct stpmic1 *pmic;\n\tstruct watchdog_device wdtdev;\n};\n\nstatic int pmic_wdt_start(struct watchdog_device *wdd)\n{\n\tstruct stpmic1_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\treturn regmap_update_bits(wdt->pmic->regmap,\n\t\t\t\t  WCHDG_CR, WDT_START_MASK, WDT_START);\n}\n\nstatic int pmic_wdt_stop(struct watchdog_device *wdd)\n{\n\tstruct stpmic1_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\treturn regmap_update_bits(wdt->pmic->regmap,\n\t\t\t\t  WCHDG_CR, WDT_START_MASK, WDT_STOP);\n}\n\nstatic int pmic_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct stpmic1_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\treturn regmap_update_bits(wdt->pmic->regmap,\n\t\t\t\t  WCHDG_CR, WDT_PING_MASK, WDT_PING);\n}\n\nstatic int pmic_wdt_set_timeout(struct watchdog_device *wdd,\n\t\t\t\tunsigned int timeout)\n{\n\tstruct stpmic1_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\twdd->timeout = timeout;\n\t \n\treturn regmap_write(wdt->pmic->regmap, WCHDG_TIMER_CR, timeout - 1);\n}\n\nstatic const struct watchdog_info pmic_watchdog_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"STPMIC1 PMIC Watchdog\",\n};\n\nstatic const struct watchdog_ops pmic_watchdog_ops = {\n\t.owner = THIS_MODULE,\n\t.start = pmic_wdt_start,\n\t.stop = pmic_wdt_stop,\n\t.ping = pmic_wdt_ping,\n\t.set_timeout = pmic_wdt_set_timeout,\n};\n\nstatic int pmic_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tstruct stpmic1 *pmic;\n\tstruct stpmic1_wdt *wdt;\n\n\tif (!dev->parent)\n\t\treturn -EINVAL;\n\n\tpmic = dev_get_drvdata(dev->parent);\n\tif (!pmic)\n\t\treturn -EINVAL;\n\n\twdt = devm_kzalloc(dev, sizeof(struct stpmic1_wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\twdt->pmic = pmic;\n\n\twdt->wdtdev.info = &pmic_watchdog_info;\n\twdt->wdtdev.ops = &pmic_watchdog_ops;\n\twdt->wdtdev.min_timeout = PMIC_WDT_MIN_TIMEOUT;\n\twdt->wdtdev.max_timeout = PMIC_WDT_MAX_TIMEOUT;\n\twdt->wdtdev.parent = dev;\n\n\twdt->wdtdev.timeout = PMIC_WDT_DEFAULT_TIMEOUT;\n\twatchdog_init_timeout(&wdt->wdtdev, 0, dev);\n\n\twatchdog_set_nowayout(&wdt->wdtdev, nowayout);\n\twatchdog_set_drvdata(&wdt->wdtdev, wdt);\n\n\tret = devm_watchdog_register_device(dev, &wdt->wdtdev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(wdt->pmic->dev, \"PMIC Watchdog driver probed\\n\");\n\treturn 0;\n}\n\nstatic const struct of_device_id of_pmic_wdt_match[] = {\n\t{ .compatible = \"st,stpmic1-wdt\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, of_pmic_wdt_match);\n\nstatic struct platform_driver stpmic1_wdt_driver = {\n\t.probe = pmic_wdt_probe,\n\t.driver = {\n\t\t.name = \"stpmic1-wdt\",\n\t\t.of_match_table = of_pmic_wdt_match,\n\t},\n};\nmodule_platform_driver(stpmic1_wdt_driver);\n\nMODULE_DESCRIPTION(\"Watchdog driver for STPMIC1 device\");\nMODULE_AUTHOR(\"Pascal Paillet <p.paillet@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}