{
  "module_name": "nic7018_wdt.c",
  "hash_id": "c7f95261c34d6ef67e87782797496116817d36f11472a0982c5d672d6fc4a7f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/nic7018_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/watchdog.h>\n\n#define LOCK\t\t\t0xA5\n#define UNLOCK\t\t\t0x5A\n\n#define WDT_CTRL_RESET_EN\tBIT(7)\n#define WDT_RELOAD_PORT_EN\tBIT(7)\n\n#define WDT_CTRL\t\t1\n#define WDT_RELOAD_CTRL\t\t2\n#define WDT_PRESET_PRESCALE\t4\n#define WDT_REG_LOCK\t\t5\n#define WDT_COUNT\t\t6\n#define WDT_RELOAD_PORT\t\t7\n\n#define WDT_MIN_TIMEOUT\t\t1\n#define WDT_MAX_TIMEOUT\t\t464\n#define WDT_DEFAULT_TIMEOUT\t80\n\n#define WDT_MAX_COUNTER\t\t15\n\nstatic unsigned int timeout;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout,\n\t\t \"Watchdog timeout in seconds. (default=\"\n\t\t __MODULE_STRING(WDT_DEFAULT_TIMEOUT) \")\");\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Watchdog cannot be stopped once started. (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct nic7018_wdt {\n\tu16 io_base;\n\tu32 period;\n\tstruct watchdog_device wdd;\n};\n\nstruct nic7018_config {\n\tu32 period;\n\tu8 divider;\n};\n\nstatic const struct nic7018_config nic7018_configs[] = {\n\t{  2, 4 },\n\t{ 32, 5 },\n};\n\nstatic inline u32 nic7018_timeout(u32 period, u8 counter)\n{\n\treturn period * counter - period / 2;\n}\n\nstatic const struct nic7018_config *nic7018_get_config(u32 timeout,\n\t\t\t\t\t\t       u8 *counter)\n{\n\tconst struct nic7018_config *config;\n\tu8 count;\n\n\tif (timeout < 30 && timeout != 16) {\n\t\tconfig = &nic7018_configs[0];\n\t\tcount = timeout / 2 + 1;\n\t} else {\n\t\tconfig = &nic7018_configs[1];\n\t\tcount = DIV_ROUND_UP(timeout + 16, 32);\n\n\t\tif (count > WDT_MAX_COUNTER)\n\t\t\tcount = WDT_MAX_COUNTER;\n\t}\n\t*counter = count;\n\treturn config;\n}\n\nstatic int nic7018_set_timeout(struct watchdog_device *wdd,\n\t\t\t       unsigned int timeout)\n{\n\tstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\n\tconst struct nic7018_config *config;\n\tu8 counter;\n\n\tconfig = nic7018_get_config(timeout, &counter);\n\n\toutb(counter << 4 | config->divider,\n\t     wdt->io_base + WDT_PRESET_PRESCALE);\n\n\twdd->timeout = nic7018_timeout(config->period, counter);\n\twdt->period = config->period;\n\n\treturn 0;\n}\n\nstatic int nic7018_start(struct watchdog_device *wdd)\n{\n\tstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu8 control;\n\n\tnic7018_set_timeout(wdd, wdd->timeout);\n\n\tcontrol = inb(wdt->io_base + WDT_RELOAD_CTRL);\n\toutb(control | WDT_RELOAD_PORT_EN, wdt->io_base + WDT_RELOAD_CTRL);\n\n\toutb(1, wdt->io_base + WDT_RELOAD_PORT);\n\n\tcontrol = inb(wdt->io_base + WDT_CTRL);\n\toutb(control | WDT_CTRL_RESET_EN, wdt->io_base + WDT_CTRL);\n\n\treturn 0;\n}\n\nstatic int nic7018_stop(struct watchdog_device *wdd)\n{\n\tstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\toutb(0, wdt->io_base + WDT_CTRL);\n\toutb(0, wdt->io_base + WDT_RELOAD_CTRL);\n\toutb(0xF0, wdt->io_base + WDT_PRESET_PRESCALE);\n\n\treturn 0;\n}\n\nstatic int nic7018_ping(struct watchdog_device *wdd)\n{\n\tstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\toutb(1, wdt->io_base + WDT_RELOAD_PORT);\n\n\treturn 0;\n}\n\nstatic unsigned int nic7018_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct nic7018_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu8 count;\n\n\tcount = inb(wdt->io_base + WDT_COUNT) & 0xF;\n\tif (!count)\n\t\treturn 0;\n\n\treturn nic7018_timeout(wdt->period, count);\n}\n\nstatic const struct watchdog_info nic7018_wdd_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"NIC7018 Watchdog\",\n};\n\nstatic const struct watchdog_ops nic7018_wdd_ops = {\n\t.owner = THIS_MODULE,\n\t.start = nic7018_start,\n\t.stop = nic7018_stop,\n\t.ping = nic7018_ping,\n\t.set_timeout = nic7018_set_timeout,\n\t.get_timeleft = nic7018_get_timeleft,\n};\n\nstatic int nic7018_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct nic7018_wdt *wdt;\n\tstruct resource *io_rc;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\tio_rc = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!io_rc) {\n\t\tdev_err(dev, \"missing IO resources\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!devm_request_region(dev, io_rc->start, resource_size(io_rc),\n\t\t\t\t KBUILD_MODNAME)) {\n\t\tdev_err(dev, \"failed to get IO region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\twdt->io_base = io_rc->start;\n\twdd = &wdt->wdd;\n\twdd->info = &nic7018_wdd_info;\n\twdd->ops = &nic7018_wdd_ops;\n\twdd->min_timeout = WDT_MIN_TIMEOUT;\n\twdd->max_timeout = WDT_MAX_TIMEOUT;\n\twdd->timeout = WDT_DEFAULT_TIMEOUT;\n\twdd->parent = dev;\n\n\twatchdog_set_drvdata(wdd, wdt);\n\twatchdog_set_nowayout(wdd, nowayout);\n\twatchdog_init_timeout(wdd, timeout, dev);\n\n\t \n\toutb(UNLOCK, wdt->io_base + WDT_REG_LOCK);\n\n\tret = watchdog_register_device(wdd);\n\tif (ret) {\n\t\toutb(LOCK, wdt->io_base + WDT_REG_LOCK);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"io_base=0x%04X, timeout=%d, nowayout=%d\\n\",\n\t\twdt->io_base, timeout, nowayout);\n\treturn 0;\n}\n\nstatic void nic7018_remove(struct platform_device *pdev)\n{\n\tstruct nic7018_wdt *wdt = platform_get_drvdata(pdev);\n\n\twatchdog_unregister_device(&wdt->wdd);\n\n\t \n\toutb(LOCK, wdt->io_base + WDT_REG_LOCK);\n}\n\nstatic const struct acpi_device_id nic7018_device_ids[] = {\n\t{\"NIC7018\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, nic7018_device_ids);\n\nstatic struct platform_driver watchdog_driver = {\n\t.probe = nic7018_probe,\n\t.remove_new = nic7018_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.acpi_match_table = ACPI_PTR(nic7018_device_ids),\n\t},\n};\n\nmodule_platform_driver(watchdog_driver);\n\nMODULE_DESCRIPTION(\"National Instruments NIC7018 Watchdog driver\");\nMODULE_AUTHOR(\"Hui Chun Ong <hui.chun.ong@ni.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}