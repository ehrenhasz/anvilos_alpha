{
  "module_name": "lantiq_wdt.c",
  "hash_id": "ded0b31a4e7363a2834de735073e0c7d23d27c8b2c5dde3ea628d2f9c46cccc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/lantiq_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/watchdog.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#include <lantiq_soc.h>\n\n#define LTQ_XRX_RCU_RST_STAT\t\t0x0014\n#define LTQ_XRX_RCU_RST_STAT_WDT\tBIT(31)\n\n \n#define LTQ_FALCON_SYS1_CPU0RS\t\t0x0060\n \n#define LTQ_FALCON_SYS1_CPU0RS_MASK\t0x0007\n#define LTQ_FALCON_SYS1_CPU0RS_WDT\t0x02\n\n \n#define LTQ_WDT_CR_PW1\t\t0x00BE0000\n#define LTQ_WDT_CR_PW2\t\t0x00DC0000\n\n#define LTQ_WDT_CR\t\t0x0\t\t \n#define  LTQ_WDT_CR_GEN\t\tBIT(31)\t\t \n \n#define  LTQ_WDT_CR_PWL\t\t(0x3 << 26)\n \n#define  LTQ_WDT_CR_CLKDIV\t(0x3 << 24)\n#define  LTQ_WDT_CR_PW_MASK\tGENMASK(23, 16)\t \n#define  LTQ_WDT_CR_MAX_TIMEOUT\t((1 << 16) - 1)\t \n#define LTQ_WDT_SR\t\t0x8\t\t \n#define  LTQ_WDT_SR_EN\t\tBIT(31)\t\t \n#define  LTQ_WDT_SR_VALUE_MASK\tGENMASK(15, 0)\t \n\n#define LTQ_WDT_DIVIDER\t\t0x40000\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\nstruct ltq_wdt_hw {\n\tint (*bootstatus_get)(struct device *dev);\n};\n\nstruct ltq_wdt_priv {\n\tstruct watchdog_device wdt;\n\tvoid __iomem *membase;\n\tunsigned long clk_rate;\n};\n\nstatic u32 ltq_wdt_r32(struct ltq_wdt_priv *priv, u32 offset)\n{\n\treturn __raw_readl(priv->membase + offset);\n}\n\nstatic void ltq_wdt_w32(struct ltq_wdt_priv *priv, u32 val, u32 offset)\n{\n\t__raw_writel(val, priv->membase + offset);\n}\n\nstatic void ltq_wdt_mask(struct ltq_wdt_priv *priv, u32 clear, u32 set,\n\t\t\t u32 offset)\n{\n\tu32 val = ltq_wdt_r32(priv, offset);\n\n\tval &= ~(clear);\n\tval |= set;\n\tltq_wdt_w32(priv, val, offset);\n}\n\nstatic struct ltq_wdt_priv *ltq_wdt_get_priv(struct watchdog_device *wdt)\n{\n\treturn container_of(wdt, struct ltq_wdt_priv, wdt);\n}\n\nstatic struct watchdog_info ltq_wdt_info = {\n\t.options = WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t   WDIOF_CARDRESET,\n\t.identity = \"ltq_wdt\",\n};\n\nstatic int ltq_wdt_start(struct watchdog_device *wdt)\n{\n\tstruct ltq_wdt_priv *priv = ltq_wdt_get_priv(wdt);\n\tu32 timeout;\n\n\ttimeout = wdt->timeout * priv->clk_rate;\n\n\tltq_wdt_mask(priv, LTQ_WDT_CR_PW_MASK, LTQ_WDT_CR_PW1, LTQ_WDT_CR);\n\t \n\tltq_wdt_mask(priv, LTQ_WDT_CR_PW_MASK | LTQ_WDT_CR_MAX_TIMEOUT,\n\t\t     LTQ_WDT_CR_GEN | LTQ_WDT_CR_PWL | LTQ_WDT_CR_CLKDIV |\n\t\t     LTQ_WDT_CR_PW2 | timeout,\n\t\t     LTQ_WDT_CR);\n\n\treturn 0;\n}\n\nstatic int ltq_wdt_stop(struct watchdog_device *wdt)\n{\n\tstruct ltq_wdt_priv *priv = ltq_wdt_get_priv(wdt);\n\n\tltq_wdt_mask(priv, LTQ_WDT_CR_PW_MASK, LTQ_WDT_CR_PW1, LTQ_WDT_CR);\n\tltq_wdt_mask(priv, LTQ_WDT_CR_GEN | LTQ_WDT_CR_PW_MASK,\n\t\t     LTQ_WDT_CR_PW2, LTQ_WDT_CR);\n\n\treturn 0;\n}\n\nstatic int ltq_wdt_ping(struct watchdog_device *wdt)\n{\n\tstruct ltq_wdt_priv *priv = ltq_wdt_get_priv(wdt);\n\tu32 timeout;\n\n\ttimeout = wdt->timeout * priv->clk_rate;\n\n\tltq_wdt_mask(priv, LTQ_WDT_CR_PW_MASK, LTQ_WDT_CR_PW1, LTQ_WDT_CR);\n\t \n\tltq_wdt_mask(priv, LTQ_WDT_CR_PW_MASK | LTQ_WDT_CR_MAX_TIMEOUT,\n\t\t     LTQ_WDT_CR_PW2 | timeout, LTQ_WDT_CR);\n\n\treturn 0;\n}\n\nstatic unsigned int ltq_wdt_get_timeleft(struct watchdog_device *wdt)\n{\n\tstruct ltq_wdt_priv *priv = ltq_wdt_get_priv(wdt);\n\tu64 timeout;\n\n\ttimeout = ltq_wdt_r32(priv, LTQ_WDT_SR) & LTQ_WDT_SR_VALUE_MASK;\n\treturn do_div(timeout, priv->clk_rate);\n}\n\nstatic const struct watchdog_ops ltq_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= ltq_wdt_start,\n\t.stop\t\t= ltq_wdt_stop,\n\t.ping\t\t= ltq_wdt_ping,\n\t.get_timeleft\t= ltq_wdt_get_timeleft,\n};\n\nstatic int ltq_wdt_xrx_bootstatus_get(struct device *dev)\n{\n\tstruct regmap *rcu_regmap;\n\tu32 val;\n\tint err;\n\n\trcu_regmap = syscon_regmap_lookup_by_phandle(dev->of_node, \"regmap\");\n\tif (IS_ERR(rcu_regmap))\n\t\treturn PTR_ERR(rcu_regmap);\n\n\terr = regmap_read(rcu_regmap, LTQ_XRX_RCU_RST_STAT, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val & LTQ_XRX_RCU_RST_STAT_WDT)\n\t\treturn WDIOF_CARDRESET;\n\n\treturn 0;\n}\n\nstatic int ltq_wdt_falcon_bootstatus_get(struct device *dev)\n{\n\tstruct regmap *rcu_regmap;\n\tu32 val;\n\tint err;\n\n\trcu_regmap = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t     \"lantiq,rcu\");\n\tif (IS_ERR(rcu_regmap))\n\t\treturn PTR_ERR(rcu_regmap);\n\n\terr = regmap_read(rcu_regmap, LTQ_FALCON_SYS1_CPU0RS, &val);\n\tif (err)\n\t\treturn err;\n\n\tif ((val & LTQ_FALCON_SYS1_CPU0RS_MASK) == LTQ_FALCON_SYS1_CPU0RS_WDT)\n\t\treturn WDIOF_CARDRESET;\n\n\treturn 0;\n}\n\nstatic int ltq_wdt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ltq_wdt_priv *priv;\n\tstruct watchdog_device *wdt;\n\tstruct clk *clk;\n\tconst struct ltq_wdt_hw *ltq_wdt_hw;\n\tint ret;\n\tu32 status;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->membase))\n\t\treturn PTR_ERR(priv->membase);\n\n\t \n\tclk = clk_get_io();\n\tpriv->clk_rate = clk_get_rate(clk) / LTQ_WDT_DIVIDER;\n\tif (!priv->clk_rate) {\n\t\tdev_err(dev, \"clock rate less than divider %i\\n\",\n\t\t\tLTQ_WDT_DIVIDER);\n\t\treturn -EINVAL;\n\t}\n\n\twdt = &priv->wdt;\n\twdt->info\t\t= &ltq_wdt_info;\n\twdt->ops\t\t= &ltq_wdt_ops;\n\twdt->min_timeout\t= 1;\n\twdt->max_timeout\t= LTQ_WDT_CR_MAX_TIMEOUT / priv->clk_rate;\n\twdt->timeout\t\t= wdt->max_timeout;\n\twdt->parent\t\t= dev;\n\n\tltq_wdt_hw = of_device_get_match_data(dev);\n\tif (ltq_wdt_hw && ltq_wdt_hw->bootstatus_get) {\n\t\tret = ltq_wdt_hw->bootstatus_get(dev);\n\t\tif (ret >= 0)\n\t\t\twdt->bootstatus = ret;\n\t}\n\n\twatchdog_set_nowayout(wdt, nowayout);\n\twatchdog_init_timeout(wdt, 0, dev);\n\n\tstatus = ltq_wdt_r32(priv, LTQ_WDT_SR);\n\tif (status & LTQ_WDT_SR_EN) {\n\t\t \n\t\tltq_wdt_start(wdt);\n\t\tset_bit(WDOG_HW_RUNNING, &wdt->status);\n\t}\n\n\treturn devm_watchdog_register_device(dev, wdt);\n}\n\nstatic const struct ltq_wdt_hw ltq_wdt_xrx100 = {\n\t.bootstatus_get = ltq_wdt_xrx_bootstatus_get,\n};\n\nstatic const struct ltq_wdt_hw ltq_wdt_falcon = {\n\t.bootstatus_get = ltq_wdt_falcon_bootstatus_get,\n};\n\nstatic const struct of_device_id ltq_wdt_match[] = {\n\t{ .compatible = \"lantiq,wdt\", .data = NULL },\n\t{ .compatible = \"lantiq,xrx100-wdt\", .data = &ltq_wdt_xrx100 },\n\t{ .compatible = \"lantiq,falcon-wdt\", .data = &ltq_wdt_falcon },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ltq_wdt_match);\n\nstatic struct platform_driver ltq_wdt_driver = {\n\t.probe = ltq_wdt_probe,\n\t.driver = {\n\t\t.name = \"wdt\",\n\t\t.of_match_table = ltq_wdt_match,\n\t},\n};\n\nmodule_platform_driver(ltq_wdt_driver);\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started\");\nMODULE_AUTHOR(\"John Crispin <john@phrozen.org>\");\nMODULE_DESCRIPTION(\"Lantiq SoC Watchdog\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}