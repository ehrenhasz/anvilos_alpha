{
  "module_name": "imx7ulp_wdt.c",
  "hash_id": "81651d92664d0c0eb3b5a9b426dd9facbd5caa9bb899ce732aa7b8b9e7fccf17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/imx7ulp_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/watchdog.h>\n\n#define WDOG_CS\t\t\t0x0\n#define WDOG_CS_FLG\t\tBIT(14)\n#define WDOG_CS_CMD32EN\t\tBIT(13)\n#define WDOG_CS_PRES\t\tBIT(12)\n#define WDOG_CS_ULK\t\tBIT(11)\n#define WDOG_CS_RCS\t\tBIT(10)\n#define LPO_CLK\t\t\t0x1\n#define LPO_CLK_SHIFT\t\t8\n#define WDOG_CS_CLK\t\t(LPO_CLK << LPO_CLK_SHIFT)\n#define WDOG_CS_EN\t\tBIT(7)\n#define WDOG_CS_UPDATE\t\tBIT(5)\n#define WDOG_CS_WAIT\t\tBIT(1)\n#define WDOG_CS_STOP\t\tBIT(0)\n\n#define WDOG_CNT\t0x4\n#define WDOG_TOVAL\t0x8\n\n#define REFRESH_SEQ0\t0xA602\n#define REFRESH_SEQ1\t0xB480\n#define REFRESH\t\t((REFRESH_SEQ1 << 16) | REFRESH_SEQ0)\n\n#define UNLOCK_SEQ0\t0xC520\n#define UNLOCK_SEQ1\t0xD928\n#define UNLOCK\t\t((UNLOCK_SEQ1 << 16) | UNLOCK_SEQ0)\n\n#define DEFAULT_TIMEOUT\t60\n#define MAX_TIMEOUT\t128\n#define WDOG_CLOCK_RATE\t1000\n#define WDOG_ULK_WAIT_TIMEOUT\t1000\n#define WDOG_RCS_WAIT_TIMEOUT\t10000\n#define WDOG_RCS_POST_WAIT 3000\n\n#define RETRY_MAX 5\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0000);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstruct imx_wdt_hw_feature {\n\tbool prescaler_enable;\n\tu32 wdog_clock_rate;\n};\n\nstruct imx7ulp_wdt_device {\n\tstruct watchdog_device wdd;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tbool post_rcs_wait;\n\tconst struct imx_wdt_hw_feature *hw;\n};\n\nstatic int imx7ulp_wdt_wait_ulk(void __iomem *base)\n{\n\tu32 val = readl(base + WDOG_CS);\n\n\tif (!(val & WDOG_CS_ULK) &&\n\t    readl_poll_timeout_atomic(base + WDOG_CS, val,\n\t\t\t\t      val & WDOG_CS_ULK, 0,\n\t\t\t\t      WDOG_ULK_WAIT_TIMEOUT))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int imx7ulp_wdt_wait_rcs(struct imx7ulp_wdt_device *wdt)\n{\n\tint ret = 0;\n\tu32 val = readl(wdt->base + WDOG_CS);\n\tu64 timeout = (val & WDOG_CS_PRES) ?\n\t\tWDOG_RCS_WAIT_TIMEOUT * 256 : WDOG_RCS_WAIT_TIMEOUT;\n\tunsigned long wait_min = (val & WDOG_CS_PRES) ?\n\t\tWDOG_RCS_POST_WAIT * 256 : WDOG_RCS_POST_WAIT;\n\n\tif (!(val & WDOG_CS_RCS) &&\n\t    readl_poll_timeout(wdt->base + WDOG_CS, val, val & WDOG_CS_RCS, 100,\n\t\t\t       timeout))\n\t\tret = -ETIMEDOUT;\n\n\t \n\tif (wdt->post_rcs_wait)\n\t\tusleep_range(wait_min, wait_min + 2000);\n\n\treturn ret;\n}\n\nstatic int _imx7ulp_wdt_enable(struct imx7ulp_wdt_device *wdt, bool enable)\n{\n\tu32 val = readl(wdt->base + WDOG_CS);\n\tint ret;\n\n\tlocal_irq_disable();\n\twritel(UNLOCK, wdt->base + WDOG_CNT);\n\tret = imx7ulp_wdt_wait_ulk(wdt->base);\n\tif (ret)\n\t\tgoto enable_out;\n\tif (enable)\n\t\twritel(val | WDOG_CS_EN, wdt->base + WDOG_CS);\n\telse\n\t\twritel(val & ~WDOG_CS_EN, wdt->base + WDOG_CS);\n\n\tlocal_irq_enable();\n\tret = imx7ulp_wdt_wait_rcs(wdt);\n\n\treturn ret;\n\nenable_out:\n\tlocal_irq_enable();\n\treturn ret;\n}\n\nstatic int imx7ulp_wdt_enable(struct watchdog_device *wdog, bool enable)\n{\n\tstruct imx7ulp_wdt_device *wdt = watchdog_get_drvdata(wdog);\n\tint ret;\n\tu32 val;\n\tu32 loop = RETRY_MAX;\n\n\tdo {\n\t\tret = _imx7ulp_wdt_enable(wdt, enable);\n\t\tval = readl(wdt->base + WDOG_CS);\n\t} while (--loop > 0 && ((!!(val & WDOG_CS_EN)) != enable || ret));\n\n\tif (loop == 0)\n\t\treturn -EBUSY;\n\n\treturn ret;\n}\n\nstatic int imx7ulp_wdt_ping(struct watchdog_device *wdog)\n{\n\tstruct imx7ulp_wdt_device *wdt = watchdog_get_drvdata(wdog);\n\n\twritel(REFRESH, wdt->base + WDOG_CNT);\n\n\treturn 0;\n}\n\nstatic int imx7ulp_wdt_start(struct watchdog_device *wdog)\n{\n\treturn imx7ulp_wdt_enable(wdog, true);\n}\n\nstatic int imx7ulp_wdt_stop(struct watchdog_device *wdog)\n{\n\treturn imx7ulp_wdt_enable(wdog, false);\n}\n\nstatic int _imx7ulp_wdt_set_timeout(struct imx7ulp_wdt_device *wdt,\n\t\t\t\t   unsigned int toval)\n{\n\tint ret;\n\n\tlocal_irq_disable();\n\twritel(UNLOCK, wdt->base + WDOG_CNT);\n\tret = imx7ulp_wdt_wait_ulk(wdt->base);\n\tif (ret)\n\t\tgoto timeout_out;\n\twritel(toval, wdt->base + WDOG_TOVAL);\n\tlocal_irq_enable();\n\tret = imx7ulp_wdt_wait_rcs(wdt);\n\treturn ret;\n\ntimeout_out:\n\tlocal_irq_enable();\n\treturn ret;\n}\n\nstatic int imx7ulp_wdt_set_timeout(struct watchdog_device *wdog,\n\t\t\t\t   unsigned int timeout)\n{\n\tstruct imx7ulp_wdt_device *wdt = watchdog_get_drvdata(wdog);\n\tu32 toval = wdt->hw->wdog_clock_rate * timeout;\n\tu32 val;\n\tint ret;\n\tu32 loop = RETRY_MAX;\n\n\tdo {\n\t\tret = _imx7ulp_wdt_set_timeout(wdt, toval);\n\t\tval = readl(wdt->base + WDOG_TOVAL);\n\t} while (--loop > 0 && (val != toval || ret));\n\n\tif (loop == 0)\n\t\treturn -EBUSY;\n\n\twdog->timeout = timeout;\n\treturn ret;\n}\n\nstatic int imx7ulp_wdt_restart(struct watchdog_device *wdog,\n\t\t\t       unsigned long action, void *data)\n{\n\tstruct imx7ulp_wdt_device *wdt = watchdog_get_drvdata(wdog);\n\tint ret;\n\n\tret = imx7ulp_wdt_enable(wdog, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx7ulp_wdt_set_timeout(&wdt->wdd, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twhile (true)\n\t\t;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct watchdog_ops imx7ulp_wdt_ops = {\n\t.owner = THIS_MODULE,\n\t.start = imx7ulp_wdt_start,\n\t.stop  = imx7ulp_wdt_stop,\n\t.ping  = imx7ulp_wdt_ping,\n\t.set_timeout = imx7ulp_wdt_set_timeout,\n\t.restart = imx7ulp_wdt_restart,\n};\n\nstatic const struct watchdog_info imx7ulp_wdt_info = {\n\t.identity = \"i.MX7ULP watchdog timer\",\n\t.options  = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\n\t\t    WDIOF_MAGICCLOSE,\n};\n\nstatic int _imx7ulp_wdt_init(struct imx7ulp_wdt_device *wdt, unsigned int timeout, unsigned int cs)\n{\n\tu32 val;\n\tint ret;\n\n\tlocal_irq_disable();\n\n\tval = readl(wdt->base + WDOG_CS);\n\tif (val & WDOG_CS_CMD32EN) {\n\t\twritel(UNLOCK, wdt->base + WDOG_CNT);\n\t} else {\n\t\tmb();\n\t\t \n\t\twritel_relaxed(UNLOCK_SEQ0, wdt->base + WDOG_CNT);\n\t\twritel_relaxed(UNLOCK_SEQ1, wdt->base + WDOG_CNT);\n\t\tmb();\n\t}\n\n\tret = imx7ulp_wdt_wait_ulk(wdt->base);\n\tif (ret)\n\t\tgoto init_out;\n\n\t \n\twritel(timeout, wdt->base + WDOG_TOVAL);\n\twritel(cs, wdt->base + WDOG_CS);\n\tlocal_irq_enable();\n\tret = imx7ulp_wdt_wait_rcs(wdt);\n\n\treturn ret;\n\ninit_out:\n\tlocal_irq_enable();\n\treturn ret;\n}\n\nstatic int imx7ulp_wdt_init(struct imx7ulp_wdt_device *wdt, unsigned int timeout)\n{\n\t \n\tu32 val = WDOG_CS_CMD32EN | WDOG_CS_CLK | WDOG_CS_UPDATE |\n\t\t  WDOG_CS_WAIT | WDOG_CS_STOP;\n\tu32 cs, toval;\n\tint ret;\n\tu32 loop = RETRY_MAX;\n\n\tif (wdt->hw->prescaler_enable)\n\t\tval |= WDOG_CS_PRES;\n\n\tdo {\n\t\tret = _imx7ulp_wdt_init(wdt, timeout, val);\n\t\ttoval = readl(wdt->base + WDOG_TOVAL);\n\t\tcs = readl(wdt->base + WDOG_CS);\n\t\tcs &= ~(WDOG_CS_FLG | WDOG_CS_ULK | WDOG_CS_RCS);\n\t} while (--loop > 0 && (cs != val || toval != timeout || ret));\n\n\tif (loop == 0)\n\t\treturn -EBUSY;\n\n\treturn ret;\n}\n\nstatic int imx7ulp_wdt_probe(struct platform_device *pdev)\n{\n\tstruct imx7ulp_wdt_device *imx7ulp_wdt;\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdog;\n\tint ret;\n\n\timx7ulp_wdt = devm_kzalloc(dev, sizeof(*imx7ulp_wdt), GFP_KERNEL);\n\tif (!imx7ulp_wdt)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, imx7ulp_wdt);\n\n\timx7ulp_wdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(imx7ulp_wdt->base))\n\t\treturn PTR_ERR(imx7ulp_wdt->base);\n\n\timx7ulp_wdt->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(imx7ulp_wdt->clk)) {\n\t\tdev_err(dev, \"Failed to get watchdog clock\\n\");\n\t\treturn PTR_ERR(imx7ulp_wdt->clk);\n\t}\n\n\timx7ulp_wdt->post_rcs_wait = true;\n\tif (of_device_is_compatible(dev->of_node,\n\t\t\t\t    \"fsl,imx8ulp-wdt\")) {\n\t\tdev_info(dev, \"imx8ulp wdt probe\\n\");\n\t\timx7ulp_wdt->post_rcs_wait = false;\n\t} else {\n\t\tdev_info(dev, \"imx7ulp wdt probe\\n\");\n\t}\n\n\twdog = &imx7ulp_wdt->wdd;\n\twdog->info = &imx7ulp_wdt_info;\n\twdog->ops = &imx7ulp_wdt_ops;\n\twdog->min_timeout = 1;\n\twdog->max_timeout = MAX_TIMEOUT;\n\twdog->parent = dev;\n\twdog->timeout = DEFAULT_TIMEOUT;\n\n\twatchdog_init_timeout(wdog, 0, dev);\n\twatchdog_stop_on_reboot(wdog);\n\twatchdog_stop_on_unregister(wdog);\n\twatchdog_set_drvdata(wdog, imx7ulp_wdt);\n\n\timx7ulp_wdt->hw = of_device_get_match_data(dev);\n\tret = imx7ulp_wdt_init(imx7ulp_wdt, wdog->timeout * imx7ulp_wdt->hw->wdog_clock_rate);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_watchdog_register_device(dev, wdog);\n}\n\nstatic int __maybe_unused imx7ulp_wdt_suspend_noirq(struct device *dev)\n{\n\tstruct imx7ulp_wdt_device *imx7ulp_wdt = dev_get_drvdata(dev);\n\n\tif (watchdog_active(&imx7ulp_wdt->wdd))\n\t\timx7ulp_wdt_stop(&imx7ulp_wdt->wdd);\n\n\tclk_disable_unprepare(imx7ulp_wdt->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx7ulp_wdt_resume_noirq(struct device *dev)\n{\n\tstruct imx7ulp_wdt_device *imx7ulp_wdt = dev_get_drvdata(dev);\n\tu32 timeout = imx7ulp_wdt->wdd.timeout * imx7ulp_wdt->hw->wdog_clock_rate;\n\tint ret;\n\n\tret = clk_prepare_enable(imx7ulp_wdt->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (watchdog_active(&imx7ulp_wdt->wdd)) {\n\t\timx7ulp_wdt_init(imx7ulp_wdt, timeout);\n\t\timx7ulp_wdt_start(&imx7ulp_wdt->wdd);\n\t\timx7ulp_wdt_ping(&imx7ulp_wdt->wdd);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx7ulp_wdt_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(imx7ulp_wdt_suspend_noirq,\n\t\t\t\t      imx7ulp_wdt_resume_noirq)\n};\n\nstatic const struct imx_wdt_hw_feature imx7ulp_wdt_hw = {\n\t.prescaler_enable = false,\n\t.wdog_clock_rate = 1000,\n};\n\nstatic const struct imx_wdt_hw_feature imx93_wdt_hw = {\n\t.prescaler_enable = true,\n\t.wdog_clock_rate = 125,\n};\n\nstatic const struct of_device_id imx7ulp_wdt_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8ulp-wdt\", .data = &imx7ulp_wdt_hw, },\n\t{ .compatible = \"fsl,imx7ulp-wdt\", .data = &imx7ulp_wdt_hw, },\n\t{ .compatible = \"fsl,imx93-wdt\", .data = &imx93_wdt_hw, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx7ulp_wdt_dt_ids);\n\nstatic struct platform_driver imx7ulp_wdt_driver = {\n\t.probe\t\t= imx7ulp_wdt_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"imx7ulp-wdt\",\n\t\t.pm\t= &imx7ulp_wdt_pm_ops,\n\t\t.of_match_table = imx7ulp_wdt_dt_ids,\n\t},\n};\nmodule_platform_driver(imx7ulp_wdt_driver);\n\nMODULE_AUTHOR(\"Anson Huang <Anson.Huang@nxp.com>\");\nMODULE_DESCRIPTION(\"Freescale i.MX7ULP watchdog driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}