{
  "module_name": "ni903x_wdt.c",
  "hash_id": "130d7164916171be0d04452dd8c6e26159e4f9104f12af29bbbfc233f14b8e27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/ni903x_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/watchdog.h>\n\n#define NIWD_CONTROL\t0x01\n#define NIWD_COUNTER2\t0x02\n#define NIWD_COUNTER1\t0x03\n#define NIWD_COUNTER0\t0x04\n#define NIWD_SEED2\t0x05\n#define NIWD_SEED1\t0x06\n#define NIWD_SEED0\t0x07\n\n#define NIWD_IO_SIZE\t0x08\n\n#define NIWD_CONTROL_MODE\t\t0x80\n#define NIWD_CONTROL_PROC_RESET\t\t0x20\n#define NIWD_CONTROL_PET\t\t0x10\n#define NIWD_CONTROL_RUNNING\t\t0x08\n#define NIWD_CONTROL_CAPTURECOUNTER\t0x04\n#define NIWD_CONTROL_RESET\t\t0x02\n#define NIWD_CONTROL_ALARM\t\t0x01\n\n#define NIWD_PERIOD_NS\t\t30720\n#define NIWD_MIN_TIMEOUT\t1\n#define NIWD_MAX_TIMEOUT\t515\n#define NIWD_DEFAULT_TIMEOUT\t60\n\n#define NIWD_NAME\t\t\"ni903x_wdt\"\n\nstruct ni903x_wdt {\n\tstruct device *dev;\n\tu16 io_base;\n\tstruct watchdog_device wdd;\n};\n\nstatic unsigned int timeout;\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout,\n\t\t \"Watchdog timeout in seconds. (default=\"\n\t\t __MODULE_STRING(NIWD_DEFAULT_TIMEOUT) \")\");\n\nstatic int nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, int, S_IRUGO);\nMODULE_PARM_DESC(nowayout,\n\t\t \"Watchdog cannot be stopped once started (default=\"\n\t\t __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic void ni903x_start(struct ni903x_wdt *wdt)\n{\n\tu8 control = inb(wdt->io_base + NIWD_CONTROL);\n\n\toutb(control | NIWD_CONTROL_RESET, wdt->io_base + NIWD_CONTROL);\n\toutb(control | NIWD_CONTROL_PET, wdt->io_base + NIWD_CONTROL);\n}\n\nstatic int ni903x_wdd_set_timeout(struct watchdog_device *wdd,\n\t\t\t\t  unsigned int timeout)\n{\n\tstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu32 counter = timeout * (1000000000 / NIWD_PERIOD_NS);\n\n\toutb(((0x00FF0000 & counter) >> 16), wdt->io_base + NIWD_SEED2);\n\toutb(((0x0000FF00 & counter) >> 8), wdt->io_base + NIWD_SEED1);\n\toutb((0x000000FF & counter), wdt->io_base + NIWD_SEED0);\n\n\twdd->timeout = timeout;\n\n\treturn 0;\n}\n\nstatic unsigned int ni903x_wdd_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu8 control, counter0, counter1, counter2;\n\tu32 counter;\n\n\tcontrol = inb(wdt->io_base + NIWD_CONTROL);\n\tcontrol |= NIWD_CONTROL_CAPTURECOUNTER;\n\toutb(control, wdt->io_base + NIWD_CONTROL);\n\n\tcounter2 = inb(wdt->io_base + NIWD_COUNTER2);\n\tcounter1 = inb(wdt->io_base + NIWD_COUNTER1);\n\tcounter0 = inb(wdt->io_base + NIWD_COUNTER0);\n\n\tcounter = (counter2 << 16) | (counter1 << 8) | counter0;\n\n\treturn counter / (1000000000 / NIWD_PERIOD_NS);\n}\n\nstatic int ni903x_wdd_ping(struct watchdog_device *wdd)\n{\n\tstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\n\tu8 control;\n\n\tcontrol = inb(wdt->io_base + NIWD_CONTROL);\n\toutb(control | NIWD_CONTROL_PET, wdt->io_base + NIWD_CONTROL);\n\n\treturn 0;\n}\n\nstatic int ni903x_wdd_start(struct watchdog_device *wdd)\n{\n\tstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\toutb(NIWD_CONTROL_RESET | NIWD_CONTROL_PROC_RESET,\n\t     wdt->io_base + NIWD_CONTROL);\n\n\tni903x_wdd_set_timeout(wdd, wdd->timeout);\n\tni903x_start(wdt);\n\n\treturn 0;\n}\n\nstatic int ni903x_wdd_stop(struct watchdog_device *wdd)\n{\n\tstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\n\n\toutb(NIWD_CONTROL_RESET, wdt->io_base + NIWD_CONTROL);\n\n\treturn 0;\n}\n\nstatic acpi_status ni903x_resources(struct acpi_resource *res, void *data)\n{\n\tstruct ni903x_wdt *wdt = data;\n\tu16 io_size;\n\n\tswitch (res->type) {\n\tcase ACPI_RESOURCE_TYPE_IO:\n\t\tif (wdt->io_base != 0) {\n\t\t\tdev_err(wdt->dev, \"too many IO resources\\n\");\n\t\t\treturn AE_ERROR;\n\t\t}\n\n\t\twdt->io_base = res->data.io.minimum;\n\t\tio_size = res->data.io.address_length;\n\n\t\tif (io_size < NIWD_IO_SIZE) {\n\t\t\tdev_err(wdt->dev, \"memory region too small\\n\");\n\t\t\treturn AE_ERROR;\n\t\t}\n\n\t\tif (!devm_request_region(wdt->dev, wdt->io_base, io_size,\n\t\t\t\t\t NIWD_NAME)) {\n\t\t\tdev_err(wdt->dev, \"failed to get memory region\\n\");\n\t\t\treturn AE_ERROR;\n\t\t}\n\n\t\treturn AE_OK;\n\n\tcase ACPI_RESOURCE_TYPE_END_TAG:\n\tdefault:\n\t\t \n\t\treturn AE_OK;\n\t}\n}\n\nstatic const struct watchdog_info ni903x_wdd_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"NI Watchdog\",\n};\n\nstatic const struct watchdog_ops ni903x_wdd_ops = {\n\t.owner = THIS_MODULE,\n\t.start = ni903x_wdd_start,\n\t.stop = ni903x_wdd_stop,\n\t.ping = ni903x_wdd_ping,\n\t.set_timeout = ni903x_wdd_set_timeout,\n\t.get_timeleft = ni903x_wdd_get_timeleft,\n};\n\nstatic int ni903x_acpi_add(struct acpi_device *device)\n{\n\tstruct device *dev = &device->dev;\n\tstruct watchdog_device *wdd;\n\tstruct ni903x_wdt *wdt;\n\tacpi_status status;\n\tint ret;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tdevice->driver_data = wdt;\n\twdt->dev = dev;\n\n\tstatus = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\n\t\t\t\t     ni903x_resources, wdt);\n\tif (ACPI_FAILURE(status) || wdt->io_base == 0) {\n\t\tdev_err(dev, \"failed to get resources\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twdd = &wdt->wdd;\n\twdd->info = &ni903x_wdd_info;\n\twdd->ops = &ni903x_wdd_ops;\n\twdd->min_timeout = NIWD_MIN_TIMEOUT;\n\twdd->max_timeout = NIWD_MAX_TIMEOUT;\n\twdd->timeout = NIWD_DEFAULT_TIMEOUT;\n\twdd->parent = dev;\n\twatchdog_set_drvdata(wdd, wdt);\n\twatchdog_set_nowayout(wdd, nowayout);\n\twatchdog_init_timeout(wdd, timeout, dev);\n\n\tret = watchdog_register_device(wdd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\toutb(NIWD_CONTROL_RESET | NIWD_CONTROL_MODE,\n\t     wdt->io_base + NIWD_CONTROL);\n\n\tdev_dbg(dev, \"io_base=0x%04X, timeout=%d, nowayout=%d\\n\",\n\t\twdt->io_base, timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic void ni903x_acpi_remove(struct acpi_device *device)\n{\n\tstruct ni903x_wdt *wdt = acpi_driver_data(device);\n\n\tni903x_wdd_stop(&wdt->wdd);\n\twatchdog_unregister_device(&wdt->wdd);\n}\n\nstatic const struct acpi_device_id ni903x_device_ids[] = {\n\t{\"NIC775C\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, ni903x_device_ids);\n\nstatic struct acpi_driver ni903x_acpi_driver = {\n\t.name = NIWD_NAME,\n\t.ids = ni903x_device_ids,\n\t.ops = {\n\t\t.add = ni903x_acpi_add,\n\t\t.remove = ni903x_acpi_remove,\n\t},\n};\n\nmodule_acpi_driver(ni903x_acpi_driver);\n\nMODULE_DESCRIPTION(\"NI 903x Watchdog\");\nMODULE_AUTHOR(\"Jeff Westfahl <jeff.westfahl@ni.com>\");\nMODULE_AUTHOR(\"Kyle Roeschley <kyle.roeschley@ni.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}