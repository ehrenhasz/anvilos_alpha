{
  "module_name": "eurotechwdt.c",
  "hash_id": "24a734885b90d88810abdada048d54daf9d70f9b70da8d99f31f67c154ab4f0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/eurotechwdt.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/miscdevice.h>\n#include <linux/watchdog.h>\n#include <linux/fs.h>\n#include <linux/ioport.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n\nstatic unsigned long eurwdt_is_open;\nstatic int eurwdt_timeout;\nstatic char eur_expect_close;\nstatic DEFINE_SPINLOCK(eurwdt_lock);\n\n \n\nstatic int io = 0x3f0;\nstatic int irq = 10;\nstatic char *ev = \"int\";\n\n#define WDT_TIMEOUT\t\t60                 \n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout,\n\t\t\"Watchdog cannot be stopped once started (default=\"\n\t\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\n \n\n#define WDT_CTRL_REG\t\t0x30\n#define WDT_OUTPIN_CFG\t\t0xe2\n#define WDT_EVENT_INT\t\t0x00\n#define WDT_EVENT_REBOOT\t0x08\n#define WDT_UNIT_SEL\t\t0xf1\n#define WDT_UNIT_SECS\t\t0x80\n#define WDT_TIMEOUT_VAL\t\t0xf2\n#define WDT_TIMER_CFG\t\t0xf3\n\n\nmodule_param_hw(io, int, ioport, 0);\nMODULE_PARM_DESC(io, \"Eurotech WDT io port (default=0x3f0)\");\nmodule_param_hw(irq, int, irq, 0);\nMODULE_PARM_DESC(irq, \"Eurotech WDT irq (default=10)\");\nmodule_param(ev, charp, 0);\nMODULE_PARM_DESC(ev, \"Eurotech WDT event type (default is `int')\");\n\n\n \n\nstatic inline void eurwdt_write_reg(u8 index, u8 data)\n{\n\toutb(index, io);\n\toutb(data, io+1);\n}\n\nstatic inline void eurwdt_lock_chip(void)\n{\n\toutb(0xaa, io);\n}\n\nstatic inline void eurwdt_unlock_chip(void)\n{\n\toutb(0x55, io);\n\teurwdt_write_reg(0x07, 0x08);\t \n}\n\nstatic inline void eurwdt_set_timeout(int timeout)\n{\n\teurwdt_write_reg(WDT_TIMEOUT_VAL, (u8) timeout);\n}\n\nstatic inline void eurwdt_disable_timer(void)\n{\n\teurwdt_set_timeout(0);\n}\n\nstatic void eurwdt_activate_timer(void)\n{\n\teurwdt_disable_timer();\n\teurwdt_write_reg(WDT_CTRL_REG, 0x01);\t \n\teurwdt_write_reg(WDT_OUTPIN_CFG,\n\t\t!strcmp(\"int\", ev) ? WDT_EVENT_INT : WDT_EVENT_REBOOT);\n\n\t \n\tif (irq == 2 || irq > 15 || irq < 0) {\n\t\tpr_err(\"invalid irq number\\n\");\n\t\tirq = 0;\t \n\t}\n\tif (irq == 0)\n\t\tpr_info(\"interrupt disabled\\n\");\n\n\teurwdt_write_reg(WDT_TIMER_CFG, irq << 4);\n\n\teurwdt_write_reg(WDT_UNIT_SEL, WDT_UNIT_SECS);\t \n\teurwdt_set_timeout(0);\t \n}\n\n\n \n\nstatic irqreturn_t eurwdt_interrupt(int irq, void *dev_id)\n{\n\tpr_crit(\"timeout WDT timeout\\n\");\n\n#ifdef ONLY_TESTING\n\tpr_crit(\"Would Reboot\\n\");\n#else\n\tpr_crit(\"Initiating system reboot\\n\");\n\temergency_restart();\n#endif\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic void eurwdt_ping(void)\n{\n\t \n\teurwdt_set_timeout(eurwdt_timeout);\n}\n\n \n\nstatic ssize_t eurwdt_write(struct file *file, const char __user *buf,\nsize_t count, loff_t *ppos)\n{\n\tif (count) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\teur_expect_close = 0;\n\n\t\t\tfor (i = 0; i != count; i++) {\n\t\t\t\tchar c;\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\teur_expect_close = 42;\n\t\t\t}\n\t\t}\n\t\tspin_lock(&eurwdt_lock);\n\t\teurwdt_ping();\t \n\t\tspin_unlock(&eurwdt_lock);\n\t}\n\treturn count;\n}\n\n \n\nstatic long eurwdt_ioctl(struct file *file,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tstatic const struct watchdog_info ident = {\n\t\t.options\t  = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT\n\t\t\t\t\t\t\t| WDIOF_MAGICCLOSE,\n\t\t.firmware_version = 1,\n\t\t.identity\t  = \"WDT Eurotech CPU-1220/1410\",\n\t};\n\n\tint time;\n\tint options, retval = -EINVAL;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\treturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\n\n\tcase WDIOC_GETSTATUS:\n\tcase WDIOC_GETBOOTSTATUS:\n\t\treturn put_user(0, p);\n\n\tcase WDIOC_SETOPTIONS:\n\t\tif (get_user(options, p))\n\t\t\treturn -EFAULT;\n\t\tspin_lock(&eurwdt_lock);\n\t\tif (options & WDIOS_DISABLECARD) {\n\t\t\teurwdt_disable_timer();\n\t\t\tretval = 0;\n\t\t}\n\t\tif (options & WDIOS_ENABLECARD) {\n\t\t\teurwdt_activate_timer();\n\t\t\teurwdt_ping();\n\t\t\tretval = 0;\n\t\t}\n\t\tspin_unlock(&eurwdt_lock);\n\t\treturn retval;\n\n\tcase WDIOC_KEEPALIVE:\n\t\tspin_lock(&eurwdt_lock);\n\t\teurwdt_ping();\n\t\tspin_unlock(&eurwdt_lock);\n\t\treturn 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\tif (copy_from_user(&time, p, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (time < 0 || time > 255)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock(&eurwdt_lock);\n\t\teurwdt_timeout = time;\n\t\teurwdt_set_timeout(time);\n\t\tspin_unlock(&eurwdt_lock);\n\t\tfallthrough;\n\n\tcase WDIOC_GETTIMEOUT:\n\t\treturn put_user(eurwdt_timeout, p);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \n\nstatic int eurwdt_open(struct inode *inode, struct file *file)\n{\n\tif (test_and_set_bit(0, &eurwdt_is_open))\n\t\treturn -EBUSY;\n\teurwdt_timeout = WDT_TIMEOUT;\t \n\t \n\teurwdt_activate_timer();\n\treturn stream_open(inode, file);\n}\n\n \n\nstatic int eurwdt_release(struct inode *inode, struct file *file)\n{\n\tif (eur_expect_close == 42)\n\t\teurwdt_disable_timer();\n\telse {\n\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\teurwdt_ping();\n\t}\n\tclear_bit(0, &eurwdt_is_open);\n\teur_expect_close = 0;\n\treturn 0;\n}\n\n \n\nstatic int eurwdt_notify_sys(struct notifier_block *this, unsigned long code,\n\tvoid *unused)\n{\n\tif (code == SYS_DOWN || code == SYS_HALT)\n\t\teurwdt_disable_timer();\t \n\n\treturn NOTIFY_DONE;\n}\n\n \n\n\nstatic const struct file_operations eurwdt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.write\t\t= eurwdt_write,\n\t.unlocked_ioctl\t= eurwdt_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open\t\t= eurwdt_open,\n\t.release\t= eurwdt_release,\n};\n\nstatic struct miscdevice eurwdt_miscdev = {\n\t.minor\t= WATCHDOG_MINOR,\n\t.name\t= \"watchdog\",\n\t.fops\t= &eurwdt_fops,\n};\n\n \n\nstatic struct notifier_block eurwdt_notifier = {\n\t.notifier_call = eurwdt_notify_sys,\n};\n\n \n\nstatic void __exit eurwdt_exit(void)\n{\n\teurwdt_lock_chip();\n\n\tmisc_deregister(&eurwdt_miscdev);\n\n\tunregister_reboot_notifier(&eurwdt_notifier);\n\trelease_region(io, 2);\n\tfree_irq(irq, NULL);\n}\n\n \n\nstatic int __init eurwdt_init(void)\n{\n\tint ret;\n\n\tret = request_irq(irq, eurwdt_interrupt, 0, \"eurwdt\", NULL);\n\tif (ret) {\n\t\tpr_err(\"IRQ %d is not free\\n\", irq);\n\t\tgoto out;\n\t}\n\n\tif (!request_region(io, 2, \"eurwdt\")) {\n\t\tpr_err(\"IO %X is not free\\n\", io);\n\t\tret = -EBUSY;\n\t\tgoto outirq;\n\t}\n\n\tret = register_reboot_notifier(&eurwdt_notifier);\n\tif (ret) {\n\t\tpr_err(\"can't register reboot notifier (err=%d)\\n\", ret);\n\t\tgoto outreg;\n\t}\n\n\tret = misc_register(&eurwdt_miscdev);\n\tif (ret) {\n\t\tpr_err(\"can't misc_register on minor=%d\\n\", WATCHDOG_MINOR);\n\t\tgoto outreboot;\n\t}\n\n\teurwdt_unlock_chip();\n\n\tret = 0;\n\tpr_info(\"Eurotech WDT driver 0.01 at %X (Interrupt %d) - timeout event: %s\\n\",\n\t\tio, irq, (!strcmp(\"int\", ev) ? \"int\" : \"reboot\"));\n\nout:\n\treturn ret;\n\noutreboot:\n\tunregister_reboot_notifier(&eurwdt_notifier);\n\noutreg:\n\trelease_region(io, 2);\n\noutirq:\n\tfree_irq(irq, NULL);\n\tgoto out;\n}\n\nmodule_init(eurwdt_init);\nmodule_exit(eurwdt_exit);\n\nMODULE_AUTHOR(\"Rodolfo Giometti\");\nMODULE_DESCRIPTION(\"Driver for Eurotech CPU-1220/1410 on board watchdog\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}