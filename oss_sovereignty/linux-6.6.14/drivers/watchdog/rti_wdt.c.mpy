{
  "module_name": "rti_wdt.c",
  "hash_id": "5ebc5608d6a122b48c92a888f8248e0df82d8b7a63bf9c0b76a096c03fbe4766",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/rti_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\n#define DEFAULT_HEARTBEAT 60\n\n \n#define MAX_HEARTBEAT\t1000\n\n \n#define RTIDWDCTRL\t0x90\n#define RTIDWDPRLD\t0x94\n#define RTIWDSTATUS\t0x98\n#define RTIWDKEY\t0x9c\n#define RTIDWDCNTR\t0xa0\n#define RTIWWDRXCTRL\t0xa4\n#define RTIWWDSIZECTRL\t0xa8\n\n#define RTIWWDRX_NMI\t0xa\n\n#define RTIWWDSIZE_50P\t\t0x50\n#define RTIWWDSIZE_25P\t\t0x500\n#define RTIWWDSIZE_12P5\t\t0x5000\n#define RTIWWDSIZE_6P25\t\t0x50000\n#define RTIWWDSIZE_3P125\t0x500000\n\n#define WDENABLE_KEY\t0xa98559da\n\n#define WDKEY_SEQ0\t\t0xe51a\n#define WDKEY_SEQ1\t\t0xa35c\n\n#define WDT_PRELOAD_SHIFT\t13\n\n#define WDT_PRELOAD_MAX\t\t0xfff\n\n#define DWDST\t\t\tBIT(1)\n\n#define PON_REASON_SOF_NUM\t0xBBBBCCCC\n#define PON_REASON_MAGIC_NUM\t0xDDDDDDDD\n#define PON_REASON_EOF_NUM\t0xCCCCBBBB\n#define RESERVED_MEM_MIN_SIZE\t12\n\nstatic int heartbeat = DEFAULT_HEARTBEAT;\n\n \nstruct rti_wdt_device {\n\tvoid __iomem\t\t*base;\n\tunsigned long\t\tfreq;\n\tstruct watchdog_device\twdd;\n};\n\nstatic int rti_wdt_start(struct watchdog_device *wdd)\n{\n\tu32 timer_margin;\n\tstruct rti_wdt_device *wdt = watchdog_get_drvdata(wdd);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(wdd->parent);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttimer_margin = (u64)wdd->timeout * wdt->freq;\n\ttimer_margin >>= WDT_PRELOAD_SHIFT;\n\tif (timer_margin > WDT_PRELOAD_MAX)\n\t\ttimer_margin = WDT_PRELOAD_MAX;\n\twritel_relaxed(timer_margin, wdt->base + RTIDWDPRLD);\n\n\t \n\twdd->min_hw_heartbeat_ms = 500 * wdd->timeout;\n\n\t \n\twritel_relaxed(RTIWWDRX_NMI, wdt->base + RTIWWDRXCTRL);\n\n\t \n\twritel_relaxed(RTIWWDSIZE_50P, wdt->base + RTIWWDSIZECTRL);\n\n\treadl_relaxed(wdt->base + RTIWWDSIZECTRL);\n\n\t \n\twritel_relaxed(WDENABLE_KEY, wdt->base + RTIDWDCTRL);\n\treturn 0;\n}\n\nstatic int rti_wdt_ping(struct watchdog_device *wdd)\n{\n\tstruct rti_wdt_device *wdt = watchdog_get_drvdata(wdd);\n\n\t \n\twritel_relaxed(WDKEY_SEQ0, wdt->base + RTIWDKEY);\n\t \n\twritel_relaxed(WDKEY_SEQ1, wdt->base + RTIWDKEY);\n\n\treturn 0;\n}\n\nstatic int rti_wdt_setup_hw_hb(struct watchdog_device *wdd, u32 wsize)\n{\n\t \n\tswitch (wsize) {\n\tcase RTIWWDSIZE_50P:\n\t\t \n\t\twdd->min_hw_heartbeat_ms = 500 * heartbeat;\n\t\tbreak;\n\n\tcase RTIWWDSIZE_25P:\n\t\t \n\t\twdd->min_hw_heartbeat_ms = 750 * heartbeat;\n\t\tbreak;\n\n\tcase RTIWWDSIZE_12P5:\n\t\t \n\t\twdd->min_hw_heartbeat_ms = 875 * heartbeat;\n\t\tbreak;\n\n\tcase RTIWWDSIZE_6P25:\n\t\t \n\t\twdd->min_hw_heartbeat_ms = 935 * heartbeat;\n\t\tbreak;\n\n\tcase RTIWWDSIZE_3P125:\n\t\t \n\t\twdd->min_hw_heartbeat_ms = 969 * heartbeat;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int rti_wdt_get_timeleft_ms(struct watchdog_device *wdd)\n{\n\tu64 timer_counter;\n\tu32 val;\n\tstruct rti_wdt_device *wdt = watchdog_get_drvdata(wdd);\n\n\t \n\tval = readl_relaxed(wdt->base + RTIWDSTATUS);\n\tif (val & DWDST)\n\t\treturn 0;\n\n\ttimer_counter = readl_relaxed(wdt->base + RTIDWDCNTR);\n\n\ttimer_counter *= 1000;\n\n\tdo_div(timer_counter, wdt->freq);\n\n\treturn timer_counter;\n}\n\nstatic unsigned int rti_wdt_get_timeleft(struct watchdog_device *wdd)\n{\n\treturn rti_wdt_get_timeleft_ms(wdd) / 1000;\n}\n\nstatic const struct watchdog_info rti_wdt_info = {\n\t.options = WDIOF_KEEPALIVEPING,\n\t.identity = \"K3 RTI Watchdog\",\n};\n\nstatic const struct watchdog_ops rti_wdt_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.start\t\t= rti_wdt_start,\n\t.ping\t\t= rti_wdt_ping,\n\t.get_timeleft\t= rti_wdt_get_timeleft,\n};\n\nstatic int rti_wdt_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct device *dev = &pdev->dev;\n\tstruct watchdog_device *wdd;\n\tstruct rti_wdt_device *wdt;\n\tstruct clk *clk;\n\tu32 last_ping = 0;\n\tstruct device_node *node;\n\tu32 reserved_mem_size;\n\tstruct resource res;\n\tu32 *vaddr;\n\tu64 paddr;\n\n\twdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\n\tif (!wdt)\n\t\treturn -ENOMEM;\n\n\tclk = clk_get(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"failed to get clock\\n\");\n\n\twdt->freq = clk_get_rate(clk);\n\n\tclk_put(clk);\n\n\tif (!wdt->freq) {\n\t\tdev_err(dev, \"Failed to get fck rate.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (wdt->freq < 32768)\n\t\twdt->freq = wdt->freq * 9 / 10;\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\treturn dev_err_probe(dev, ret, \"runtime pm failed\\n\");\n\t}\n\n\tplatform_set_drvdata(pdev, wdt);\n\n\twdd = &wdt->wdd;\n\twdd->info = &rti_wdt_info;\n\twdd->ops = &rti_wdt_ops;\n\twdd->min_timeout = 1;\n\twdd->max_hw_heartbeat_ms = (WDT_PRELOAD_MAX << WDT_PRELOAD_SHIFT) /\n\t\twdt->freq * 1000;\n\twdd->parent = dev;\n\n\twatchdog_set_drvdata(wdd, wdt);\n\twatchdog_set_nowayout(wdd, 1);\n\twatchdog_set_restart_priority(wdd, 128);\n\n\twdt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wdt->base)) {\n\t\tret = PTR_ERR(wdt->base);\n\t\tgoto err_iomap;\n\t}\n\n\tif (readl(wdt->base + RTIDWDCTRL) == WDENABLE_KEY) {\n\t\tint preset_heartbeat;\n\t\tu32 time_left_ms;\n\t\tu64 heartbeat_ms;\n\t\tu32 wsize;\n\n\t\tset_bit(WDOG_HW_RUNNING, &wdd->status);\n\t\ttime_left_ms = rti_wdt_get_timeleft_ms(wdd);\n\t\theartbeat_ms = readl(wdt->base + RTIDWDPRLD);\n\t\theartbeat_ms <<= WDT_PRELOAD_SHIFT;\n\t\theartbeat_ms *= 1000;\n\t\tdo_div(heartbeat_ms, wdt->freq);\n\t\tpreset_heartbeat = heartbeat_ms + 500;\n\t\tpreset_heartbeat /= 1000;\n\t\tif (preset_heartbeat != heartbeat)\n\t\t\tdev_warn(dev, \"watchdog already running, ignoring heartbeat config!\\n\");\n\n\t\theartbeat = preset_heartbeat;\n\n\t\twsize = readl(wdt->base + RTIWWDSIZECTRL);\n\t\tret = rti_wdt_setup_hw_hb(wdd, wsize);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"bad window size.\\n\");\n\t\t\tgoto err_iomap;\n\t\t}\n\n\t\tlast_ping = heartbeat_ms - time_left_ms;\n\t\tif (time_left_ms > heartbeat_ms) {\n\t\t\tdev_warn(dev, \"time_left > heartbeat? Assuming last ping just before now.\\n\");\n\t\t\tlast_ping = 0;\n\t\t}\n\t}\n\n\tnode = of_parse_phandle(pdev->dev.of_node, \"memory-region\", 0);\n\tif (node) {\n\t\tret = of_address_to_resource(node, 0, &res);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"No memory address assigned to the region.\\n\");\n\t\t\tgoto err_iomap;\n\t\t}\n\n\t\t \n\t\tpaddr = res.start;\n\t\treserved_mem_size = resource_size(&res);\n\t\tif (reserved_mem_size < RESERVED_MEM_MIN_SIZE) {\n\t\t\tdev_err(dev, \"The size of reserved memory is too small.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_iomap;\n\t\t}\n\n\t\tvaddr = memremap(paddr, reserved_mem_size, MEMREMAP_WB);\n\t\tif (!vaddr) {\n\t\t\tdev_err(dev, \"Failed to map memory-region.\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_iomap;\n\t\t}\n\n\t\tif (vaddr[0] == PON_REASON_SOF_NUM &&\n\t\t    vaddr[1] == PON_REASON_MAGIC_NUM &&\n\t\t    vaddr[2] == PON_REASON_EOF_NUM) {\n\t\t\twdd->bootstatus |= WDIOF_CARDRESET;\n\t\t}\n\t\tmemset(vaddr, 0, reserved_mem_size);\n\t\tmemunmap(vaddr);\n\t}\n\n\twatchdog_init_timeout(wdd, heartbeat, dev);\n\n\tret = watchdog_register_device(wdd);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot register watchdog device\\n\");\n\t\tgoto err_iomap;\n\t}\n\n\tif (last_ping)\n\t\twatchdog_set_last_hw_keepalive(wdd, last_ping);\n\n\tif (!watchdog_hw_running(wdd))\n\t\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn 0;\n\nerr_iomap:\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void rti_wdt_remove(struct platform_device *pdev)\n{\n\tstruct rti_wdt_device *wdt = platform_get_drvdata(pdev);\n\n\twatchdog_unregister_device(&wdt->wdd);\n\n\tif (!pm_runtime_suspended(&pdev->dev))\n\t\tpm_runtime_put(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id rti_wdt_of_match[] = {\n\t{ .compatible = \"ti,j7-rti-wdt\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rti_wdt_of_match);\n\nstatic struct platform_driver rti_wdt_driver = {\n\t.driver = {\n\t\t.name = \"rti-wdt\",\n\t\t.of_match_table = rti_wdt_of_match,\n\t},\n\t.probe = rti_wdt_probe,\n\t.remove_new = rti_wdt_remove,\n};\n\nmodule_platform_driver(rti_wdt_driver);\n\nMODULE_AUTHOR(\"Tero Kristo <t-kristo@ti.com>\");\nMODULE_DESCRIPTION(\"K3 RTI Watchdog Driver\");\n\nmodule_param(heartbeat, int, 0);\nMODULE_PARM_DESC(heartbeat,\n\t\t \"Watchdog heartbeat period in seconds from 1 to \"\n\t\t __MODULE_STRING(MAX_HEARTBEAT) \", default \"\n\t\t __MODULE_STRING(DEFAULT_HEARTBEAT));\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:rti-wdt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}