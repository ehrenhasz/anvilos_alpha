{
  "module_name": "arm_smc_wdt.c",
  "hash_id": "13ae8ca2d356b589ac30b0ceb34f6291d46d4ff6e9c8a9baec3bd00d26c872c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/arm_smc_wdt.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n#include <uapi/linux/psci.h>\n\n#define DRV_NAME\t\t\"arm_smc_wdt\"\n#define DRV_VERSION\t\t\"1.0\"\n\nenum smcwd_call {\n\tSMCWD_INIT\t\t= 0,\n\tSMCWD_SET_TIMEOUT\t= 1,\n\tSMCWD_ENABLE\t\t= 2,\n\tSMCWD_PET\t\t= 3,\n\tSMCWD_GET_TIMELEFT\t= 4,\n};\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nstatic unsigned int timeout;\n\nstatic int smcwd_call(struct watchdog_device *wdd, enum smcwd_call call,\n\t\t      unsigned long arg, struct arm_smccc_res *res)\n{\n\tstruct arm_smccc_res local_res;\n\n\tif (!res)\n\t\tres = &local_res;\n\n\tarm_smccc_smc((u32)(uintptr_t)watchdog_get_drvdata(wdd), call, arg, 0,\n\t\t      0, 0, 0, 0, res);\n\n\tif (res->a0 == PSCI_RET_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\tif (res->a0 == PSCI_RET_INVALID_PARAMS)\n\t\treturn -EINVAL;\n\tif (res->a0 != PSCI_RET_SUCCESS)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int smcwd_ping(struct watchdog_device *wdd)\n{\n\treturn smcwd_call(wdd, SMCWD_PET, 0, NULL);\n}\n\nstatic unsigned int smcwd_get_timeleft(struct watchdog_device *wdd)\n{\n\tstruct arm_smccc_res res;\n\n\tsmcwd_call(wdd, SMCWD_GET_TIMELEFT, 0, &res);\n\tif (res.a0)\n\t\treturn 0;\n\treturn res.a1;\n}\n\nstatic int smcwd_set_timeout(struct watchdog_device *wdd, unsigned int timeout)\n{\n\tint res;\n\n\tres = smcwd_call(wdd, SMCWD_SET_TIMEOUT, timeout, NULL);\n\tif (!res)\n\t\twdd->timeout = timeout;\n\treturn res;\n}\n\nstatic int smcwd_stop(struct watchdog_device *wdd)\n{\n\treturn smcwd_call(wdd, SMCWD_ENABLE, 0, NULL);\n}\n\nstatic int smcwd_start(struct watchdog_device *wdd)\n{\n\treturn smcwd_call(wdd, SMCWD_ENABLE, 1, NULL);\n}\n\nstatic const struct watchdog_info smcwd_info = {\n\t.identity\t= DRV_NAME,\n\t.options\t= WDIOF_SETTIMEOUT |\n\t\t\t  WDIOF_KEEPALIVEPING |\n\t\t\t  WDIOF_MAGICCLOSE,\n};\n\nstatic const struct watchdog_ops smcwd_ops = {\n\t.start\t\t= smcwd_start,\n\t.stop\t\t= smcwd_stop,\n\t.ping\t\t= smcwd_ping,\n\t.set_timeout\t= smcwd_set_timeout,\n};\n\nstatic const struct watchdog_ops smcwd_timeleft_ops = {\n\t.start\t\t= smcwd_start,\n\t.stop\t\t= smcwd_stop,\n\t.ping\t\t= smcwd_ping,\n\t.set_timeout\t= smcwd_set_timeout,\n\t.get_timeleft\t= smcwd_get_timeleft,\n};\n\nstatic int smcwd_probe(struct platform_device *pdev)\n{\n\tstruct watchdog_device *wdd;\n\tint err;\n\tstruct arm_smccc_res res;\n\tu32 smc_func_id;\n\n\twdd = devm_kzalloc(&pdev->dev, sizeof(*wdd), GFP_KERNEL);\n\tif (!wdd)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, wdd);\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"arm,smc-id\",\n\t\t\t\t &smc_func_id))\n\t\tsmc_func_id = 0x82003D06;\n\twatchdog_set_drvdata(wdd, (void *)(uintptr_t)smc_func_id);\n\n\terr = smcwd_call(wdd, SMCWD_INIT, 0, &res);\n\tif (err < 0)\n\t\treturn err;\n\n\twdd->info = &smcwd_info;\n\t \n\tif (smcwd_call(wdd, SMCWD_GET_TIMELEFT, 0, NULL))\n\t\twdd->ops = &smcwd_ops;\n\telse\n\t\twdd->ops = &smcwd_timeleft_ops;\n\twdd->timeout = res.a2;\n\twdd->max_timeout = res.a2;\n\twdd->min_timeout = res.a1;\n\twdd->parent = &pdev->dev;\n\n\twatchdog_stop_on_reboot(wdd);\n\twatchdog_stop_on_unregister(wdd);\n\twatchdog_set_nowayout(wdd, nowayout);\n\twatchdog_init_timeout(wdd, timeout, &pdev->dev);\n\terr = smcwd_set_timeout(wdd, wdd->timeout);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_watchdog_register_device(&pdev->dev, wdd);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(&pdev->dev,\n\t\t \"Watchdog registered (timeout=%d sec, nowayout=%d)\\n\",\n\t\t wdd->timeout, nowayout);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id smcwd_dt_ids[] = {\n\t{ .compatible = \"arm,smc-wdt\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, smcwd_dt_ids);\n\nstatic struct platform_driver smcwd_driver = {\n\t.probe\t\t= smcwd_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= smcwd_dt_ids,\n\t},\n};\n\nmodule_platform_driver(smcwd_driver);\n\nmodule_param(timeout, uint, 0);\nMODULE_PARM_DESC(timeout, \"Watchdog heartbeat in seconds\");\n\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t__MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Julius Werner <jwerner@chromium.org>\");\nMODULE_DESCRIPTION(\"ARM Secure Monitor Call Watchdog Driver\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}