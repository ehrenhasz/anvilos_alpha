{
  "module_name": "menz69_wdt.c",
  "hash_id": "8badcda805ab9306bb269bcd16690ac028fc2db29e1493578d8eb8567a58a96f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/watchdog/menz69_wdt.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mcb.h>\n#include <linux/module.h>\n#include <linux/watchdog.h>\n\nstruct men_z069_drv {\n\tstruct watchdog_device wdt;\n\tvoid __iomem *base;\n\tstruct resource *mem;\n};\n\n#define MEN_Z069_WTR\t\t\t0x10\n#define MEN_Z069_WTR_WDEN\t\tBIT(15)\n#define MEN_Z069_WTR_WDET_MASK\t\t0x7fff\n#define MEN_Z069_WVR\t\t\t0x14\n\n#define MEN_Z069_TIMER_FREQ\t\t500  \n#define MEN_Z069_WDT_COUNTER_MIN\t1\n#define MEN_Z069_WDT_COUNTER_MAX\t0x7fff\n#define MEN_Z069_DEFAULT_TIMEOUT\t30\n\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\nmodule_param(nowayout, bool, 0);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started (default=\"\n\t\t\t    __MODULE_STRING(WATCHDOG_NOWAYOUT) \")\");\n\nstatic int men_z069_wdt_start(struct watchdog_device *wdt)\n{\n\tstruct men_z069_drv *drv = watchdog_get_drvdata(wdt);\n\tu16 val;\n\n\tval = readw(drv->base + MEN_Z069_WTR);\n\tval |= MEN_Z069_WTR_WDEN;\n\twritew(val, drv->base + MEN_Z069_WTR);\n\n\treturn 0;\n}\n\nstatic int men_z069_wdt_stop(struct watchdog_device *wdt)\n{\n\tstruct men_z069_drv *drv = watchdog_get_drvdata(wdt);\n\tu16 val;\n\n\tval = readw(drv->base + MEN_Z069_WTR);\n\tval &= ~MEN_Z069_WTR_WDEN;\n\twritew(val, drv->base + MEN_Z069_WTR);\n\n\treturn 0;\n}\n\nstatic int men_z069_wdt_ping(struct watchdog_device *wdt)\n{\n\tstruct men_z069_drv *drv = watchdog_get_drvdata(wdt);\n\tu16 val;\n\n\t \n\tval = readw(drv->base + MEN_Z069_WVR);\n\tval ^= 0xffff;\n\twritew(val, drv->base + MEN_Z069_WVR);\n\n\treturn 0;\n}\n\nstatic int men_z069_wdt_set_timeout(struct watchdog_device *wdt,\n\t\t\t\t    unsigned int timeout)\n{\n\tstruct men_z069_drv *drv = watchdog_get_drvdata(wdt);\n\tu16 reg, val, ena;\n\n\twdt->timeout = timeout;\n\tval = timeout * MEN_Z069_TIMER_FREQ;\n\n\treg = readw(drv->base + MEN_Z069_WTR);\n\tena = reg & MEN_Z069_WTR_WDEN;\n\treg = ena | val;\n\twritew(reg, drv->base + MEN_Z069_WTR);\n\n\treturn 0;\n}\n\nstatic const struct watchdog_info men_z069_info = {\n\t.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,\n\t.identity = \"MEN z069 Watchdog\",\n};\n\nstatic const struct watchdog_ops men_z069_ops = {\n\t.owner = THIS_MODULE,\n\t.start = men_z069_wdt_start,\n\t.stop = men_z069_wdt_stop,\n\t.ping = men_z069_wdt_ping,\n\t.set_timeout = men_z069_wdt_set_timeout,\n};\n\nstatic int men_z069_probe(struct mcb_device *dev,\n\t\t\t  const struct mcb_device_id *id)\n{\n\tstruct men_z069_drv *drv;\n\tstruct resource *mem;\n\n\tdrv = devm_kzalloc(&dev->dev, sizeof(struct men_z069_drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tmem = mcb_request_mem(dev, \"z069-wdt\");\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tdrv->base = devm_ioremap(&dev->dev, mem->start, resource_size(mem));\n\tif (drv->base == NULL)\n\t\tgoto release_mem;\n\n\tdrv->mem = mem;\n\tdrv->wdt.info = &men_z069_info;\n\tdrv->wdt.ops = &men_z069_ops;\n\tdrv->wdt.timeout = MEN_Z069_DEFAULT_TIMEOUT;\n\tdrv->wdt.min_timeout = 1;\n\tdrv->wdt.max_timeout = MEN_Z069_WDT_COUNTER_MAX / MEN_Z069_TIMER_FREQ;\n\n\twatchdog_init_timeout(&drv->wdt, 0, &dev->dev);\n\twatchdog_set_nowayout(&drv->wdt, nowayout);\n\twatchdog_set_drvdata(&drv->wdt, drv);\n\tdrv->wdt.parent = &dev->dev;\n\tmcb_set_drvdata(dev, drv);\n\n\treturn watchdog_register_device(&drv->wdt);\n\nrelease_mem:\n\tmcb_release_mem(mem);\n\treturn -ENOMEM;\n}\n\nstatic void men_z069_remove(struct mcb_device *dev)\n{\n\tstruct men_z069_drv *drv = mcb_get_drvdata(dev);\n\n\twatchdog_unregister_device(&drv->wdt);\n\tmcb_release_mem(drv->mem);\n}\n\nstatic const struct mcb_device_id men_z069_ids[] = {\n\t{ .device = 0x45 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mcb, men_z069_ids);\n\nstatic struct mcb_driver men_z069_driver = {\n\t.driver = {\n\t\t.name = \"z069-wdt\",\n\t},\n\t.probe = men_z069_probe,\n\t.remove = men_z069_remove,\n\t.id_table = men_z069_ids,\n};\nmodule_mcb_driver(men_z069_driver);\n\nMODULE_AUTHOR(\"Johannes Thumshirn <jth@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"mcb:16z069\");\nMODULE_IMPORT_NS(MCB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}