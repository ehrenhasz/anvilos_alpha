{
  "module_name": "manager.c",
  "hash_id": "6180e82ce1285fba2ac90bd6594729898f84c73b9f99277defdc0842518dbffe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/manager.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/pnp.h>\n#include <linux/bitmap.h>\n#include <linux/mutex.h>\n#include \"base.h\"\n\nDEFINE_MUTEX(pnp_res_mutex);\n\nstatic struct resource *pnp_find_resource(struct pnp_dev *dev,\n\t\t\t\t\t  unsigned char rule,\n\t\t\t\t\t  unsigned long type,\n\t\t\t\t\t  unsigned int bar)\n{\n\tstruct resource *res = pnp_get_resource(dev, type, bar);\n\n\t \n\tif (res) {\n\t\tres->flags &= ~IORESOURCE_BITS;\n\t\tres->flags |= rule & IORESOURCE_BITS;\n\t}\n\n\treturn res;\n}\n\nstatic int pnp_assign_port(struct pnp_dev *dev, struct pnp_port *rule, int idx)\n{\n\tstruct resource *res, local_res;\n\n\tres = pnp_find_resource(dev, rule->flags, IORESOURCE_IO, idx);\n\tif (res) {\n\t\tpnp_dbg(&dev->dev, \"  io %d already set to %#llx-%#llx \"\n\t\t\t\"flags %#lx\\n\", idx, (unsigned long long) res->start,\n\t\t\t(unsigned long long) res->end, res->flags);\n\t\treturn 0;\n\t}\n\n\tres = &local_res;\n\tres->flags = rule->flags | IORESOURCE_AUTO;\n\tres->start = 0;\n\tres->end = 0;\n\n\tif (!rule->size) {\n\t\tres->flags |= IORESOURCE_DISABLED;\n\t\tpnp_dbg(&dev->dev, \"  io %d disabled\\n\", idx);\n\t\tgoto __add;\n\t}\n\n\tres->start = rule->min;\n\tres->end = res->start + rule->size - 1;\n\n\twhile (!pnp_check_port(dev, res)) {\n\t\tres->start += rule->align;\n\t\tres->end = res->start + rule->size - 1;\n\t\tif (res->start > rule->max || !rule->align) {\n\t\t\tpnp_dbg(&dev->dev, \"  couldn't assign io %d \"\n\t\t\t\t\"(min %#llx max %#llx)\\n\", idx,\n\t\t\t\t(unsigned long long) rule->min,\n\t\t\t\t(unsigned long long) rule->max);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n__add:\n\tpnp_add_io_resource(dev, res->start, res->end, res->flags);\n\treturn 0;\n}\n\nstatic int pnp_assign_mem(struct pnp_dev *dev, struct pnp_mem *rule, int idx)\n{\n\tstruct resource *res, local_res;\n\n\tres = pnp_find_resource(dev, rule->flags, IORESOURCE_MEM, idx);\n\tif (res) {\n\t\tpnp_dbg(&dev->dev, \"  mem %d already set to %#llx-%#llx \"\n\t\t\t\"flags %#lx\\n\", idx, (unsigned long long) res->start,\n\t\t\t(unsigned long long) res->end, res->flags);\n\t\treturn 0;\n\t}\n\n\tres = &local_res;\n\tres->flags = rule->flags | IORESOURCE_AUTO;\n\tres->start = 0;\n\tres->end = 0;\n\n\t \n\tif (!(rule->flags & IORESOURCE_MEM_WRITEABLE))\n\t\tres->flags |= IORESOURCE_READONLY;\n\tif (rule->flags & IORESOURCE_MEM_RANGELENGTH)\n\t\tres->flags |= IORESOURCE_RANGELENGTH;\n\tif (rule->flags & IORESOURCE_MEM_SHADOWABLE)\n\t\tres->flags |= IORESOURCE_SHADOWABLE;\n\n\tif (!rule->size) {\n\t\tres->flags |= IORESOURCE_DISABLED;\n\t\tpnp_dbg(&dev->dev, \"  mem %d disabled\\n\", idx);\n\t\tgoto __add;\n\t}\n\n\tres->start = rule->min;\n\tres->end = res->start + rule->size - 1;\n\n\twhile (!pnp_check_mem(dev, res)) {\n\t\tres->start += rule->align;\n\t\tres->end = res->start + rule->size - 1;\n\t\tif (res->start > rule->max || !rule->align) {\n\t\t\tpnp_dbg(&dev->dev, \"  couldn't assign mem %d \"\n\t\t\t\t\"(min %#llx max %#llx)\\n\", idx,\n\t\t\t\t(unsigned long long) rule->min,\n\t\t\t\t(unsigned long long) rule->max);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n__add:\n\tpnp_add_mem_resource(dev, res->start, res->end, res->flags);\n\treturn 0;\n}\n\nstatic int pnp_assign_irq(struct pnp_dev *dev, struct pnp_irq *rule, int idx)\n{\n\tstruct resource *res, local_res;\n\tint i;\n\n\t \n\tstatic unsigned short xtab[16] = {\n\t\t5, 10, 11, 12, 9, 14, 15, 7, 3, 4, 13, 0, 1, 6, 8, 2\n\t};\n\n\tres = pnp_find_resource(dev, rule->flags, IORESOURCE_IRQ, idx);\n\tif (res) {\n\t\tpnp_dbg(&dev->dev, \"  irq %d already set to %d flags %#lx\\n\",\n\t\t\tidx, (int) res->start, res->flags);\n\t\treturn 0;\n\t}\n\n\tres = &local_res;\n\tres->flags = rule->flags | IORESOURCE_AUTO;\n\tres->start = -1;\n\tres->end = -1;\n\n\tif (bitmap_empty(rule->map.bits, PNP_IRQ_NR)) {\n\t\tres->flags |= IORESOURCE_DISABLED;\n\t\tpnp_dbg(&dev->dev, \"  irq %d disabled\\n\", idx);\n\t\tgoto __add;\n\t}\n\n\t \n\tres->start = find_next_bit(rule->map.bits, PNP_IRQ_NR, 16);\n\tif (res->start < PNP_IRQ_NR) {\n\t\tres->end = res->start;\n\t\tgoto __add;\n\t}\n\tfor (i = 0; i < 16; i++) {\n\t\tif (test_bit(xtab[i], rule->map.bits)) {\n\t\t\tres->start = res->end = xtab[i];\n\t\t\tif (pnp_check_irq(dev, res))\n\t\t\t\tgoto __add;\n\t\t}\n\t}\n\n\tif (rule->flags & IORESOURCE_IRQ_OPTIONAL) {\n\t\tres->start = -1;\n\t\tres->end = -1;\n\t\tres->flags |= IORESOURCE_DISABLED;\n\t\tpnp_dbg(&dev->dev, \"  irq %d disabled (optional)\\n\", idx);\n\t\tgoto __add;\n\t}\n\n\tpnp_dbg(&dev->dev, \"  couldn't assign irq %d\\n\", idx);\n\treturn -EBUSY;\n\n__add:\n\tpnp_add_irq_resource(dev, res->start, res->flags);\n\treturn 0;\n}\n\n#ifdef CONFIG_ISA_DMA_API\nstatic int pnp_assign_dma(struct pnp_dev *dev, struct pnp_dma *rule, int idx)\n{\n\tstruct resource *res, local_res;\n\tint i;\n\n\t \n\tstatic unsigned short xtab[8] = {\n\t\t1, 3, 5, 6, 7, 0, 2, 4\n\t};\n\n\tres = pnp_find_resource(dev, rule->flags, IORESOURCE_DMA, idx);\n\tif (res) {\n\t\tpnp_dbg(&dev->dev, \"  dma %d already set to %d flags %#lx\\n\",\n\t\t\tidx, (int) res->start, res->flags);\n\t\treturn 0;\n\t}\n\n\tres = &local_res;\n\tres->flags = rule->flags | IORESOURCE_AUTO;\n\tres->start = -1;\n\tres->end = -1;\n\n\tif (!rule->map) {\n\t\tres->flags |= IORESOURCE_DISABLED;\n\t\tpnp_dbg(&dev->dev, \"  dma %d disabled\\n\", idx);\n\t\tgoto __add;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (rule->map & (1 << xtab[i])) {\n\t\t\tres->start = res->end = xtab[i];\n\t\t\tif (pnp_check_dma(dev, res))\n\t\t\t\tgoto __add;\n\t\t}\n\t}\n\n\tpnp_dbg(&dev->dev, \"  couldn't assign dma %d\\n\", idx);\n\treturn -EBUSY;\n\n__add:\n\tpnp_add_dma_resource(dev, res->start, res->flags);\n\treturn 0;\n}\n#endif  \n\nvoid pnp_init_resources(struct pnp_dev *dev)\n{\n\tpnp_free_resources(dev);\n}\n\nstatic void pnp_clean_resource_table(struct pnp_dev *dev)\n{\n\tstruct pnp_resource *pnp_res, *tmp;\n\n\tlist_for_each_entry_safe(pnp_res, tmp, &dev->resources, list) {\n\t\tif (pnp_res->res.flags & IORESOURCE_AUTO)\n\t\t\tpnp_free_resource(pnp_res);\n\t}\n}\n\n \nstatic int pnp_assign_resources(struct pnp_dev *dev, int set)\n{\n\tstruct pnp_option *option;\n\tint nport = 0, nmem = 0, nirq = 0;\n\tint ndma __maybe_unused = 0;\n\tint ret = 0;\n\n\tpnp_dbg(&dev->dev, \"pnp_assign_resources, try dependent set %d\\n\", set);\n\tmutex_lock(&pnp_res_mutex);\n\tpnp_clean_resource_table(dev);\n\n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (pnp_option_is_dependent(option) &&\n\t\t    pnp_option_set(option) != set)\n\t\t\t\tcontinue;\n\n\t\tswitch (option->type) {\n\t\tcase IORESOURCE_IO:\n\t\t\tret = pnp_assign_port(dev, &option->u.port, nport++);\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tret = pnp_assign_mem(dev, &option->u.mem, nmem++);\n\t\t\tbreak;\n\t\tcase IORESOURCE_IRQ:\n\t\t\tret = pnp_assign_irq(dev, &option->u.irq, nirq++);\n\t\t\tbreak;\n#ifdef CONFIG_ISA_DMA_API\n\t\tcase IORESOURCE_DMA:\n\t\t\tret = pnp_assign_dma(dev, &option->u.dma, ndma++);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&pnp_res_mutex);\n\tif (ret < 0) {\n\t\tpnp_dbg(&dev->dev, \"pnp_assign_resources failed (%d)\\n\", ret);\n\t\tpnp_clean_resource_table(dev);\n\t} else\n\t\tdbg_pnp_show_resources(dev, \"pnp_assign_resources succeeded\");\n\treturn ret;\n}\n\n \nint pnp_auto_config_dev(struct pnp_dev *dev)\n{\n\tint i, ret;\n\n\tif (!pnp_can_configure(dev)) {\n\t\tpnp_dbg(&dev->dev, \"configuration not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pnp_assign_resources(dev, 0);\n\tif (ret == 0)\n\t\treturn 0;\n\n\tfor (i = 1; i < dev->num_dependent_sets; i++) {\n\t\tret = pnp_assign_resources(dev, i);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\n\tdev_err(&dev->dev, \"unable to assign resources\\n\");\n\treturn ret;\n}\n\n \nint pnp_start_dev(struct pnp_dev *dev)\n{\n\tif (!pnp_can_write(dev)) {\n\t\tpnp_dbg(&dev->dev, \"activation not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdbg_pnp_show_resources(dev, \"pnp_start_dev\");\n\tif (dev->protocol->set(dev) < 0) {\n\t\tdev_err(&dev->dev, \"activation failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_info(&dev->dev, \"activated\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL(pnp_start_dev);\n\n \nint pnp_stop_dev(struct pnp_dev *dev)\n{\n\tif (!pnp_can_disable(dev)) {\n\t\tpnp_dbg(&dev->dev, \"disabling not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (dev->protocol->disable(dev) < 0) {\n\t\tdev_err(&dev->dev, \"disable failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_info(&dev->dev, \"disabled\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL(pnp_stop_dev);\n\n \nint pnp_activate_dev(struct pnp_dev *dev)\n{\n\tint error;\n\n\tif (dev->active)\n\t\treturn 0;\n\n\t \n\tif (pnp_auto_config_dev(dev))\n\t\treturn -EBUSY;\n\n\terror = pnp_start_dev(dev);\n\tif (error)\n\t\treturn error;\n\n\tdev->active = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(pnp_activate_dev);\n\n \nint pnp_disable_dev(struct pnp_dev *dev)\n{\n\tint error;\n\n\tif (!dev->active)\n\t\treturn 0;\n\n\terror = pnp_stop_dev(dev);\n\tif (error)\n\t\treturn error;\n\n\tdev->active = 0;\n\n\t \n\tmutex_lock(&pnp_res_mutex);\n\tpnp_clean_resource_table(dev);\n\tmutex_unlock(&pnp_res_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pnp_disable_dev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}