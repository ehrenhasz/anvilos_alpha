{
  "module_name": "interface.c",
  "hash_id": "5a1869707ba864c288aa7a2eaa12bfb16dc552aa2a8f9308644e4a3a29d9a44b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/interface.c",
  "human_readable_source": "\n \n\n#include <linux/pnp.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/stat.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#include <linux/uaccess.h>\n\n#include \"base.h\"\n\nstruct pnp_info_buffer {\n\tchar *buffer;\t\t \n\tchar *curr;\t\t \n\tunsigned long size;\t \n\tunsigned long len;\t \n\tint stop;\t\t \n\tint error;\t\t \n};\n\ntypedef struct pnp_info_buffer pnp_info_buffer_t;\n\n__printf(2, 3)\nstatic int pnp_printf(pnp_info_buffer_t * buffer, char *fmt, ...)\n{\n\tva_list args;\n\tint res;\n\n\tif (buffer->stop || buffer->error)\n\t\treturn 0;\n\tva_start(args, fmt);\n\tres = vsnprintf(buffer->curr, buffer->len - buffer->size, fmt, args);\n\tva_end(args);\n\tif (buffer->size + res >= buffer->len) {\n\t\tbuffer->stop = 1;\n\t\treturn 0;\n\t}\n\tbuffer->curr += res;\n\tbuffer->size += res;\n\treturn res;\n}\n\nstatic void pnp_print_port(pnp_info_buffer_t * buffer, char *space,\n\t\t\t   struct pnp_port *port)\n{\n\tpnp_printf(buffer, \"%sport %#llx-%#llx, align %#llx, size %#llx, \"\n\t\t   \"%i-bit address decoding\\n\", space,\n\t\t   (unsigned long long) port->min,\n\t\t   (unsigned long long) port->max,\n\t\t   port->align ? ((unsigned long long) port->align - 1) : 0,\n\t\t   (unsigned long long) port->size,\n\t\t   port->flags & IORESOURCE_IO_16BIT_ADDR ? 16 : 10);\n}\n\nstatic void pnp_print_irq(pnp_info_buffer_t * buffer, char *space,\n\t\t\t  struct pnp_irq *irq)\n{\n\tint first = 1, i;\n\n\tpnp_printf(buffer, \"%sirq \", space);\n\tfor (i = 0; i < PNP_IRQ_NR; i++)\n\t\tif (test_bit(i, irq->map.bits)) {\n\t\t\tif (!first) {\n\t\t\t\tpnp_printf(buffer, \",\");\n\t\t\t} else {\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tif (i == 2 || i == 9)\n\t\t\t\tpnp_printf(buffer, \"2/9\");\n\t\t\telse\n\t\t\t\tpnp_printf(buffer, \"%i\", i);\n\t\t}\n\tif (bitmap_empty(irq->map.bits, PNP_IRQ_NR))\n\t\tpnp_printf(buffer, \"<none>\");\n\tif (irq->flags & IORESOURCE_IRQ_HIGHEDGE)\n\t\tpnp_printf(buffer, \" High-Edge\");\n\tif (irq->flags & IORESOURCE_IRQ_LOWEDGE)\n\t\tpnp_printf(buffer, \" Low-Edge\");\n\tif (irq->flags & IORESOURCE_IRQ_HIGHLEVEL)\n\t\tpnp_printf(buffer, \" High-Level\");\n\tif (irq->flags & IORESOURCE_IRQ_LOWLEVEL)\n\t\tpnp_printf(buffer, \" Low-Level\");\n\tif (irq->flags & IORESOURCE_IRQ_OPTIONAL)\n\t\tpnp_printf(buffer, \" (optional)\");\n\tpnp_printf(buffer, \"\\n\");\n}\n\nstatic void pnp_print_dma(pnp_info_buffer_t * buffer, char *space,\n\t\t\t  struct pnp_dma *dma)\n{\n\tint first = 1, i;\n\tchar *s;\n\n\tpnp_printf(buffer, \"%sdma \", space);\n\tfor (i = 0; i < 8; i++)\n\t\tif (dma->map & (1 << i)) {\n\t\t\tif (!first) {\n\t\t\t\tpnp_printf(buffer, \",\");\n\t\t\t} else {\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tpnp_printf(buffer, \"%i\", i);\n\t\t}\n\tif (!dma->map)\n\t\tpnp_printf(buffer, \"<none>\");\n\tswitch (dma->flags & IORESOURCE_DMA_TYPE_MASK) {\n\tcase IORESOURCE_DMA_8BIT:\n\t\ts = \"8-bit\";\n\t\tbreak;\n\tcase IORESOURCE_DMA_8AND16BIT:\n\t\ts = \"8-bit&16-bit\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"16-bit\";\n\t}\n\tpnp_printf(buffer, \" %s\", s);\n\tif (dma->flags & IORESOURCE_DMA_MASTER)\n\t\tpnp_printf(buffer, \" master\");\n\tif (dma->flags & IORESOURCE_DMA_BYTE)\n\t\tpnp_printf(buffer, \" byte-count\");\n\tif (dma->flags & IORESOURCE_DMA_WORD)\n\t\tpnp_printf(buffer, \" word-count\");\n\tswitch (dma->flags & IORESOURCE_DMA_SPEED_MASK) {\n\tcase IORESOURCE_DMA_TYPEA:\n\t\ts = \"type-A\";\n\t\tbreak;\n\tcase IORESOURCE_DMA_TYPEB:\n\t\ts = \"type-B\";\n\t\tbreak;\n\tcase IORESOURCE_DMA_TYPEF:\n\t\ts = \"type-F\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"compatible\";\n\t\tbreak;\n\t}\n\tpnp_printf(buffer, \" %s\\n\", s);\n}\n\nstatic void pnp_print_mem(pnp_info_buffer_t * buffer, char *space,\n\t\t\t  struct pnp_mem *mem)\n{\n\tchar *s;\n\n\tpnp_printf(buffer, \"%sMemory %#llx-%#llx, align %#llx, size %#llx\",\n\t\t   space, (unsigned long long) mem->min,\n\t\t   (unsigned long long) mem->max,\n\t\t   (unsigned long long) mem->align,\n\t\t   (unsigned long long) mem->size);\n\tif (mem->flags & IORESOURCE_MEM_WRITEABLE)\n\t\tpnp_printf(buffer, \", writeable\");\n\tif (mem->flags & IORESOURCE_MEM_CACHEABLE)\n\t\tpnp_printf(buffer, \", cacheable\");\n\tif (mem->flags & IORESOURCE_MEM_RANGELENGTH)\n\t\tpnp_printf(buffer, \", range-length\");\n\tif (mem->flags & IORESOURCE_MEM_SHADOWABLE)\n\t\tpnp_printf(buffer, \", shadowable\");\n\tif (mem->flags & IORESOURCE_MEM_EXPANSIONROM)\n\t\tpnp_printf(buffer, \", expansion ROM\");\n\tswitch (mem->flags & IORESOURCE_MEM_TYPE_MASK) {\n\tcase IORESOURCE_MEM_8BIT:\n\t\ts = \"8-bit\";\n\t\tbreak;\n\tcase IORESOURCE_MEM_8AND16BIT:\n\t\ts = \"8-bit&16-bit\";\n\t\tbreak;\n\tcase IORESOURCE_MEM_32BIT:\n\t\ts = \"32-bit\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"16-bit\";\n\t}\n\tpnp_printf(buffer, \", %s\\n\", s);\n}\n\nstatic void pnp_print_option(pnp_info_buffer_t * buffer, char *space,\n\t\t\t     struct pnp_option *option)\n{\n\tswitch (option->type) {\n\tcase IORESOURCE_IO:\n\t\tpnp_print_port(buffer, space, &option->u.port);\n\t\tbreak;\n\tcase IORESOURCE_MEM:\n\t\tpnp_print_mem(buffer, space, &option->u.mem);\n\t\tbreak;\n\tcase IORESOURCE_IRQ:\n\t\tpnp_print_irq(buffer, space, &option->u.irq);\n\t\tbreak;\n\tcase IORESOURCE_DMA:\n\t\tpnp_print_dma(buffer, space, &option->u.dma);\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t options_show(struct device *dmdev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct pnp_dev *dev = to_pnp_dev(dmdev);\n\tpnp_info_buffer_t *buffer;\n\tstruct pnp_option *option;\n\tint ret, dep = 0, set = 0;\n\tchar *indent;\n\n\tbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer->len = PAGE_SIZE;\n\tbuffer->buffer = buf;\n\tbuffer->curr = buffer->buffer;\n\n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (pnp_option_is_dependent(option)) {\n\t\t\tindent = \"  \";\n\t\t\tif (!dep || pnp_option_set(option) != set) {\n\t\t\t\tset = pnp_option_set(option);\n\t\t\t\tdep = 1;\n\t\t\t\tpnp_printf(buffer, \"Dependent: %02i - \"\n\t\t\t\t\t   \"Priority %s\\n\", set,\n\t\t\t\t\t   pnp_option_priority_name(option));\n\t\t\t}\n\t\t} else {\n\t\t\tdep = 0;\n\t\t\tindent = \"\";\n\t\t}\n\t\tpnp_print_option(buffer, indent, option);\n\t}\n\n\tret = (buffer->curr - buf);\n\tkfree(buffer);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(options);\n\nstatic ssize_t resources_show(struct device *dmdev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct pnp_dev *dev = to_pnp_dev(dmdev);\n\tpnp_info_buffer_t *buffer;\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\tint ret;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer->len = PAGE_SIZE;\n\tbuffer->buffer = buf;\n\tbuffer->curr = buffer->buffer;\n\n\tpnp_printf(buffer, \"state = %s\\n\", dev->active ? \"active\" : \"disabled\");\n\n\tlist_for_each_entry(pnp_res, &dev->resources, list) {\n\t\tres = &pnp_res->res;\n\n\t\tpnp_printf(buffer, pnp_resource_type_name(res));\n\n\t\tif (res->flags & IORESOURCE_DISABLED) {\n\t\t\tpnp_printf(buffer, \" disabled\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (pnp_resource_type(res)) {\n\t\tcase IORESOURCE_IO:\n\t\tcase IORESOURCE_MEM:\n\t\tcase IORESOURCE_BUS:\n\t\t\tpnp_printf(buffer, \" %#llx-%#llx%s\\n\",\n\t\t\t\t   (unsigned long long) res->start,\n\t\t\t\t   (unsigned long long) res->end,\n\t\t\t\t   res->flags & IORESOURCE_WINDOW ?\n\t\t\t\t\t\" window\" : \"\");\n\t\t\tbreak;\n\t\tcase IORESOURCE_IRQ:\n\t\tcase IORESOURCE_DMA:\n\t\t\tpnp_printf(buffer, \" %lld\\n\",\n\t\t\t\t   (unsigned long long) res->start);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = (buffer->curr - buf);\n\tkfree(buffer);\n\treturn ret;\n}\n\nstatic char *pnp_get_resource_value(char *buf,\n\t\t\t\t    unsigned long type,\n\t\t\t\t    resource_size_t *start,\n\t\t\t\t    resource_size_t *end,\n\t\t\t\t    unsigned long *flags)\n{\n\tif (start)\n\t\t*start = 0;\n\tif (end)\n\t\t*end = 0;\n\tif (flags)\n\t\t*flags = 0;\n\n\t \n\n\tbuf = skip_spaces(buf);\n\tif (start) {\n\t\t*start = simple_strtoull(buf, &buf, 0);\n\t\tif (end) {\n\t\t\tbuf = skip_spaces(buf);\n\t\t\tif (*buf == '-') {\n\t\t\t\tbuf = skip_spaces(buf + 1);\n\t\t\t\t*end = simple_strtoull(buf, &buf, 0);\n\t\t\t} else\n\t\t\t\t*end = *start;\n\t\t}\n\t}\n\n\t \n\n\treturn buf;\n}\n\nstatic ssize_t resources_store(struct device *dmdev,\n\t\t\t       struct device_attribute *attr, const char *ubuf,\n\t\t\t       size_t count)\n{\n\tstruct pnp_dev *dev = to_pnp_dev(dmdev);\n\tchar *buf = (void *)ubuf;\n\tint retval = 0;\n\n\tif (dev->status & PNP_ATTACHED) {\n\t\tretval = -EBUSY;\n\t\tdev_info(&dev->dev, \"in use; can't configure\\n\");\n\t\tgoto done;\n\t}\n\n\tbuf = skip_spaces(buf);\n\tif (!strncasecmp(buf, \"disable\", 7)) {\n\t\tretval = pnp_disable_dev(dev);\n\t\tgoto done;\n\t}\n\tif (!strncasecmp(buf, \"activate\", 8)) {\n\t\tretval = pnp_activate_dev(dev);\n\t\tgoto done;\n\t}\n\tif (!strncasecmp(buf, \"fill\", 4)) {\n\t\tif (dev->active)\n\t\t\tgoto done;\n\t\tretval = pnp_auto_config_dev(dev);\n\t\tgoto done;\n\t}\n\tif (!strncasecmp(buf, \"auto\", 4)) {\n\t\tif (dev->active)\n\t\t\tgoto done;\n\t\tpnp_init_resources(dev);\n\t\tretval = pnp_auto_config_dev(dev);\n\t\tgoto done;\n\t}\n\tif (!strncasecmp(buf, \"clear\", 5)) {\n\t\tif (dev->active)\n\t\t\tgoto done;\n\t\tpnp_init_resources(dev);\n\t\tgoto done;\n\t}\n\tif (!strncasecmp(buf, \"get\", 3)) {\n\t\tmutex_lock(&pnp_res_mutex);\n\t\tif (pnp_can_read(dev))\n\t\t\tdev->protocol->get(dev);\n\t\tmutex_unlock(&pnp_res_mutex);\n\t\tgoto done;\n\t}\n\tif (!strncasecmp(buf, \"set\", 3)) {\n\t\tresource_size_t start;\n\t\tresource_size_t end;\n\t\tunsigned long flags;\n\n\t\tif (dev->active)\n\t\t\tgoto done;\n\t\tbuf += 3;\n\t\tpnp_init_resources(dev);\n\t\tmutex_lock(&pnp_res_mutex);\n\t\twhile (1) {\n\t\t\tbuf = skip_spaces(buf);\n\t\t\tif (!strncasecmp(buf, \"io\", 2)) {\n\t\t\t\tbuf = pnp_get_resource_value(buf + 2,\n\t\t\t\t\t\t\t     IORESOURCE_IO,\n\t\t\t\t\t\t\t     &start, &end,\n\t\t\t\t\t\t\t     &flags);\n\t\t\t\tpnp_add_io_resource(dev, start, end, flags);\n\t\t\t} else if (!strncasecmp(buf, \"mem\", 3)) {\n\t\t\t\tbuf = pnp_get_resource_value(buf + 3,\n\t\t\t\t\t\t\t     IORESOURCE_MEM,\n\t\t\t\t\t\t\t     &start, &end,\n\t\t\t\t\t\t\t     &flags);\n\t\t\t\tpnp_add_mem_resource(dev, start, end, flags);\n\t\t\t} else if (!strncasecmp(buf, \"irq\", 3)) {\n\t\t\t\tbuf = pnp_get_resource_value(buf + 3,\n\t\t\t\t\t\t\t     IORESOURCE_IRQ,\n\t\t\t\t\t\t\t     &start, NULL,\n\t\t\t\t\t\t\t     &flags);\n\t\t\t\tpnp_add_irq_resource(dev, start, flags);\n\t\t\t} else if (!strncasecmp(buf, \"dma\", 3)) {\n\t\t\t\tbuf = pnp_get_resource_value(buf + 3,\n\t\t\t\t\t\t\t     IORESOURCE_DMA,\n\t\t\t\t\t\t\t     &start, NULL,\n\t\t\t\t\t\t\t     &flags);\n\t\t\t\tpnp_add_dma_resource(dev, start, flags);\n\t\t\t} else if (!strncasecmp(buf, \"bus\", 3)) {\n\t\t\t\tbuf = pnp_get_resource_value(buf + 3,\n\t\t\t\t\t\t\t     IORESOURCE_BUS,\n\t\t\t\t\t\t\t     &start, &end,\n\t\t\t\t\t\t\t     NULL);\n\t\t\t\tpnp_add_bus_resource(dev, start, end);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&pnp_res_mutex);\n\t\tgoto done;\n\t}\n\ndone:\n\tif (retval < 0)\n\t\treturn retval;\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(resources);\n\nstatic ssize_t id_show(struct device *dmdev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tchar *str = buf;\n\tstruct pnp_dev *dev = to_pnp_dev(dmdev);\n\tstruct pnp_id *pos = dev->id;\n\n\twhile (pos) {\n\t\tstr += sprintf(str, \"%s\\n\", pos->id);\n\t\tpos = pos->next;\n\t}\n\treturn (str - buf);\n}\nstatic DEVICE_ATTR_RO(id);\n\nstatic struct attribute *pnp_dev_attrs[] = {\n\t&dev_attr_resources.attr,\n\t&dev_attr_options.attr,\n\t&dev_attr_id.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group pnp_dev_group = {\n\t.attrs = pnp_dev_attrs,\n};\n\nconst struct attribute_group *pnp_dev_groups[] = {\n\t&pnp_dev_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}