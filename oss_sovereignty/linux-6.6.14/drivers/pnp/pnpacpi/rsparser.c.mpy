{
  "module_name": "rsparser.c",
  "hash_id": "db47aba5e318f67885e62663c1af5a74b64dc664adb3f721719fcd7793e81029",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/pnpacpi/rsparser.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/pnp.h>\n#include <linux/slab.h>\n#include \"../base.h\"\n#include \"pnpacpi.h\"\n\nstatic void decode_irq_flags(struct pnp_dev *dev, int flags, u8 *triggering,\n\t\t\t     u8 *polarity, u8 *shareable)\n{\n\tswitch (flags & (IORESOURCE_IRQ_LOWLEVEL | IORESOURCE_IRQ_HIGHLEVEL |\n\t\t\t IORESOURCE_IRQ_LOWEDGE  | IORESOURCE_IRQ_HIGHEDGE)) {\n\tcase IORESOURCE_IRQ_LOWLEVEL:\n\t\t*triggering = ACPI_LEVEL_SENSITIVE;\n\t\t*polarity = ACPI_ACTIVE_LOW;\n\t\tbreak;\n\tcase IORESOURCE_IRQ_HIGHLEVEL:\n\t\t*triggering = ACPI_LEVEL_SENSITIVE;\n\t\t*polarity = ACPI_ACTIVE_HIGH;\n\t\tbreak;\n\tcase IORESOURCE_IRQ_LOWEDGE:\n\t\t*triggering = ACPI_EDGE_SENSITIVE;\n\t\t*polarity = ACPI_ACTIVE_LOW;\n\t\tbreak;\n\tcase IORESOURCE_IRQ_HIGHEDGE:\n\t\t*triggering = ACPI_EDGE_SENSITIVE;\n\t\t*polarity = ACPI_ACTIVE_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"can't encode invalid IRQ mode %#x\\n\",\n\t\t\tflags);\n\t\t*triggering = ACPI_EDGE_SENSITIVE;\n\t\t*polarity = ACPI_ACTIVE_HIGH;\n\t\tbreak;\n\t}\n\n\tif (flags & IORESOURCE_IRQ_SHAREABLE)\n\t\t*shareable = ACPI_SHARED;\n\telse\n\t\t*shareable = ACPI_EXCLUSIVE;\n}\n\nstatic int dma_flags(struct pnp_dev *dev, int type, int bus_master,\n\t\t     int transfer)\n{\n\tint flags = 0;\n\n\tif (bus_master)\n\t\tflags |= IORESOURCE_DMA_MASTER;\n\tswitch (type) {\n\tcase ACPI_COMPATIBILITY:\n\t\tflags |= IORESOURCE_DMA_COMPATIBLE;\n\t\tbreak;\n\tcase ACPI_TYPE_A:\n\t\tflags |= IORESOURCE_DMA_TYPEA;\n\t\tbreak;\n\tcase ACPI_TYPE_B:\n\t\tflags |= IORESOURCE_DMA_TYPEB;\n\t\tbreak;\n\tcase ACPI_TYPE_F:\n\t\tflags |= IORESOURCE_DMA_TYPEF;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tflags |= IORESOURCE_DMA_COMPATIBLE;\n\t\tdev_err(&dev->dev, \"invalid DMA type %d\\n\", type);\n\t}\n\tswitch (transfer) {\n\tcase ACPI_TRANSFER_8:\n\t\tflags |= IORESOURCE_DMA_8BIT;\n\t\tbreak;\n\tcase ACPI_TRANSFER_8_16:\n\t\tflags |= IORESOURCE_DMA_8AND16BIT;\n\t\tbreak;\n\tcase ACPI_TRANSFER_16:\n\t\tflags |= IORESOURCE_DMA_16BIT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tflags |= IORESOURCE_DMA_8AND16BIT;\n\t\tdev_err(&dev->dev, \"invalid DMA transfer type %d\\n\", transfer);\n\t}\n\n\treturn flags;\n}\n\n \n\nstatic void pnpacpi_add_irqresource(struct pnp_dev *dev, struct resource *r)\n{\n\tif (!(r->flags & IORESOURCE_DISABLED))\n\t\tpcibios_penalize_isa_irq(r->start, 1);\n\n\tpnp_add_resource(dev, r);\n}\n\n \nstatic struct acpi_vendor_uuid hp_ccsr_uuid = {\n\t.subtype = 2,\n\t.data = { 0xf9, 0xad, 0xe9, 0x69, 0x4f, 0x92, 0x5f, 0xab, 0xf6, 0x4a,\n\t    0x24, 0xd2, 0x01, 0x37, 0x0e, 0xad },\n};\n\nstatic int vendor_resource_matches(struct pnp_dev *dev,\n\t\t\t\t   struct acpi_resource_vendor_typed *vendor,\n\t\t\t\t   struct acpi_vendor_uuid *match,\n\t\t\t\t   int expected_len)\n{\n\tint uuid_len = sizeof(vendor->uuid);\n\tu8 uuid_subtype = vendor->uuid_subtype;\n\tu8 *uuid = vendor->uuid;\n\tint actual_len;\n\n\t \n\tactual_len = vendor->byte_length - uuid_len - 1;\n\n\tif (uuid_subtype == match->subtype &&\n\t    uuid_len == sizeof(match->data) &&\n\t    memcmp(uuid, match->data, uuid_len) == 0) {\n\t\tif (expected_len && expected_len != actual_len) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"wrong vendor descriptor size; expected %d, found %d bytes\\n\",\n\t\t\t\texpected_len, actual_len);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void pnpacpi_parse_allocated_vendor(struct pnp_dev *dev,\n\t\t\t\t    struct acpi_resource_vendor_typed *vendor)\n{\n\tif (vendor_resource_matches(dev, vendor, &hp_ccsr_uuid, 16)) {\n\t\tu64 start, length;\n\n\t\tmemcpy(&start, vendor->byte_data, sizeof(start));\n\t\tmemcpy(&length, vendor->byte_data + 8, sizeof(length));\n\n\t\tpnp_add_mem_resource(dev, start, start + length - 1, 0);\n\t}\n}\n\nstatic acpi_status pnpacpi_allocated_resource(struct acpi_resource *res,\n\t\t\t\t\t      void *data)\n{\n\tstruct pnp_dev *dev = data;\n\tstruct acpi_resource_dma *dma;\n\tstruct acpi_resource_vendor_typed *vendor_typed;\n\tstruct acpi_resource_gpio *gpio;\n\tstruct resource_win win = {{0}, 0};\n\tstruct resource *r = &win.res;\n\tint i, flags;\n\n\tif (acpi_dev_resource_address_space(res, &win)\n\t    || acpi_dev_resource_ext_address_space(res, &win)) {\n\t\tpnp_add_resource(dev, &win.res);\n\t\treturn AE_OK;\n\t}\n\n\tr->flags = 0;\n\tif (acpi_dev_resource_interrupt(res, 0, r)) {\n\t\tpnpacpi_add_irqresource(dev, r);\n\t\tfor (i = 1; acpi_dev_resource_interrupt(res, i, r); i++)\n\t\t\tpnpacpi_add_irqresource(dev, r);\n\n\t\tif (i > 1) {\n\t\t\t \n\t\t\tif (pnp_can_write(dev)) {\n\t\t\t\tdev_warn(&dev->dev,\n\t\t\t\t\t \"multiple interrupts in _CRS descriptor; configuration can't be changed\\n\");\n\t\t\t\tdev->capabilities &= ~PNP_WRITE;\n\t\t\t}\n\t\t}\n\t\treturn AE_OK;\n\t} else if (acpi_gpio_get_irq_resource(res, &gpio)) {\n\t\t \n\t\ti = acpi_dev_gpio_irq_get(dev->data, 0);\n\t\tif (i >= 0) {\n\t\t\tflags = acpi_dev_irq_flags(gpio->triggering,\n\t\t\t\t\t\t   gpio->polarity,\n\t\t\t\t\t\t   gpio->shareable,\n\t\t\t\t\t\t   gpio->wake_capable);\n\t\t} else {\n\t\t\tflags = IORESOURCE_DISABLED;\n\t\t}\n\t\tpnp_add_irq_resource(dev, i, flags);\n\t\treturn AE_OK;\n\t} else if (r->flags & IORESOURCE_DISABLED) {\n\t\tpnp_add_irq_resource(dev, 0, IORESOURCE_DISABLED);\n\t\treturn AE_OK;\n\t}\n\n\tswitch (res->type) {\n\tcase ACPI_RESOURCE_TYPE_MEMORY24:\n\tcase ACPI_RESOURCE_TYPE_MEMORY32:\n\tcase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\n\t\tif (acpi_dev_resource_memory(res, r))\n\t\t\tpnp_add_resource(dev, r);\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_IO:\n\tcase ACPI_RESOURCE_TYPE_FIXED_IO:\n\t\tif (acpi_dev_resource_io(res, r))\n\t\t\tpnp_add_resource(dev, r);\n\t\tbreak;\n\tcase ACPI_RESOURCE_TYPE_DMA:\n\t\tdma = &res->data.dma;\n\t\tif (dma->channel_count > 0 && dma->channels[0] != (u8) -1)\n\t\t\tflags = dma_flags(dev, dma->type, dma->bus_master,\n\t\t\t\t\t  dma->transfer);\n\t\telse\n\t\t\tflags = IORESOURCE_DISABLED;\n\t\tpnp_add_dma_resource(dev, dma->channels[0], flags);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_START_DEPENDENT:\n\tcase ACPI_RESOURCE_TYPE_END_DEPENDENT:\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_VENDOR:\n\t\tvendor_typed = &res->data.vendor_typed;\n\t\tpnpacpi_parse_allocated_vendor(dev, vendor_typed);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_END_TAG:\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_GENERIC_REGISTER:\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_SERIAL_BUS:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&dev->dev, \"unknown resource type %d in _CRS\\n\",\n\t\t\t res->type);\n\t\treturn AE_ERROR;\n\t}\n\n\treturn AE_OK;\n}\n\nint pnpacpi_parse_allocated_resource(struct pnp_dev *dev)\n{\n\tstruct acpi_device *acpi_dev = dev->data;\n\tacpi_handle handle = acpi_dev->handle;\n\tacpi_status status;\n\n\tpnp_dbg(&dev->dev, \"parse allocated resources\\n\");\n\n\tpnp_init_resources(dev);\n\n\tstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\t     pnpacpi_allocated_resource, dev);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tdev_err(&dev->dev, \"can't evaluate _CRS: %d\", status);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic __init void pnpacpi_parse_dma_option(struct pnp_dev *dev,\n\t\t\t\t\t    unsigned int option_flags,\n\t\t\t\t\t    struct acpi_resource_dma *p)\n{\n\tint i;\n\tunsigned char map = 0, flags;\n\n\tfor (i = 0; i < p->channel_count; i++)\n\t\tmap |= 1 << p->channels[i];\n\n\tflags = dma_flags(dev, p->type, p->bus_master, p->transfer);\n\tpnp_register_dma_resource(dev, option_flags, map, flags);\n}\n\nstatic __init void pnpacpi_parse_irq_option(struct pnp_dev *dev,\n\t\t\t\t\t    unsigned int option_flags,\n\t\t\t\t\t    struct acpi_resource_irq *p)\n{\n\tint i;\n\tpnp_irq_mask_t map;\n\tunsigned char flags;\n\n\tbitmap_zero(map.bits, PNP_IRQ_NR);\n\tfor (i = 0; i < p->interrupt_count; i++)\n\t\tif (p->interrupts[i])\n\t\t\t__set_bit(p->interrupts[i], map.bits);\n\n\tflags = acpi_dev_irq_flags(p->triggering, p->polarity, p->shareable, p->wake_capable);\n\tpnp_register_irq_resource(dev, option_flags, &map, flags);\n}\n\nstatic __init void pnpacpi_parse_ext_irq_option(struct pnp_dev *dev,\n\t\t\t\t\tunsigned int option_flags,\n\t\t\t\t\tstruct acpi_resource_extended_irq *p)\n{\n\tint i;\n\tpnp_irq_mask_t map;\n\tunsigned char flags;\n\n\tbitmap_zero(map.bits, PNP_IRQ_NR);\n\tfor (i = 0; i < p->interrupt_count; i++) {\n\t\tif (p->interrupts[i]) {\n\t\t\tif (p->interrupts[i] < PNP_IRQ_NR)\n\t\t\t\t__set_bit(p->interrupts[i], map.bits);\n\t\t\telse\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\"ignoring IRQ %d option (too large for %d entry bitmap)\\n\",\n\t\t\t\t\tp->interrupts[i], PNP_IRQ_NR);\n\t\t}\n\t}\n\n\tflags = acpi_dev_irq_flags(p->triggering, p->polarity, p->shareable, p->wake_capable);\n\tpnp_register_irq_resource(dev, option_flags, &map, flags);\n}\n\nstatic __init void pnpacpi_parse_port_option(struct pnp_dev *dev,\n\t\t\t\t\t     unsigned int option_flags,\n\t\t\t\t\t     struct acpi_resource_io *io)\n{\n\tunsigned char flags = 0;\n\n\tif (io->io_decode == ACPI_DECODE_16)\n\t\tflags = IORESOURCE_IO_16BIT_ADDR;\n\tpnp_register_port_resource(dev, option_flags, io->minimum, io->maximum,\n\t\t\t\t   io->alignment, io->address_length, flags);\n}\n\nstatic __init void pnpacpi_parse_fixed_port_option(struct pnp_dev *dev,\n\t\t\t\t\tunsigned int option_flags,\n\t\t\t\t\tstruct acpi_resource_fixed_io *io)\n{\n\tpnp_register_port_resource(dev, option_flags, io->address, io->address,\n\t\t\t\t   0, io->address_length, IORESOURCE_IO_FIXED);\n}\n\nstatic __init void pnpacpi_parse_mem24_option(struct pnp_dev *dev,\n\t\t\t\t\t      unsigned int option_flags,\n\t\t\t\t\t      struct acpi_resource_memory24 *p)\n{\n\tunsigned char flags = 0;\n\n\tif (p->write_protect == ACPI_READ_WRITE_MEMORY)\n\t\tflags = IORESOURCE_MEM_WRITEABLE;\n\tpnp_register_mem_resource(dev, option_flags, p->minimum, p->maximum,\n\t\t\t\t  p->alignment, p->address_length, flags);\n}\n\nstatic __init void pnpacpi_parse_mem32_option(struct pnp_dev *dev,\n\t\t\t\t\t      unsigned int option_flags,\n\t\t\t\t\t      struct acpi_resource_memory32 *p)\n{\n\tunsigned char flags = 0;\n\n\tif (p->write_protect == ACPI_READ_WRITE_MEMORY)\n\t\tflags = IORESOURCE_MEM_WRITEABLE;\n\tpnp_register_mem_resource(dev, option_flags, p->minimum, p->maximum,\n\t\t\t\t  p->alignment, p->address_length, flags);\n}\n\nstatic __init void pnpacpi_parse_fixed_mem32_option(struct pnp_dev *dev,\n\t\t\t\t\tunsigned int option_flags,\n\t\t\t\t\tstruct acpi_resource_fixed_memory32 *p)\n{\n\tunsigned char flags = 0;\n\n\tif (p->write_protect == ACPI_READ_WRITE_MEMORY)\n\t\tflags = IORESOURCE_MEM_WRITEABLE;\n\tpnp_register_mem_resource(dev, option_flags, p->address, p->address,\n\t\t\t\t  0, p->address_length, flags);\n}\n\nstatic __init void pnpacpi_parse_address_option(struct pnp_dev *dev,\n\t\t\t\t\t\tunsigned int option_flags,\n\t\t\t\t\t\tstruct acpi_resource *r)\n{\n\tstruct acpi_resource_address64 addr, *p = &addr;\n\tacpi_status status;\n\tunsigned char flags = 0;\n\n\tstatus = acpi_resource_to_address64(r, p);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(&dev->dev, \"can't convert resource type %d\\n\",\n\t\t\t r->type);\n\t\treturn;\n\t}\n\n\tif (p->resource_type == ACPI_MEMORY_RANGE) {\n\t\tif (p->info.mem.write_protect == ACPI_READ_WRITE_MEMORY)\n\t\t\tflags = IORESOURCE_MEM_WRITEABLE;\n\t\tpnp_register_mem_resource(dev, option_flags, p->address.minimum,\n\t\t\t\t\t  p->address.minimum, 0, p->address.address_length,\n\t\t\t\t\t  flags);\n\t} else if (p->resource_type == ACPI_IO_RANGE)\n\t\tpnp_register_port_resource(dev, option_flags, p->address.minimum,\n\t\t\t\t\t   p->address.minimum, 0, p->address.address_length,\n\t\t\t\t\t   IORESOURCE_IO_FIXED);\n}\n\nstatic __init void pnpacpi_parse_ext_address_option(struct pnp_dev *dev,\n\t\t\t\t\t\t    unsigned int option_flags,\n\t\t\t\t\t\t    struct acpi_resource *r)\n{\n\tstruct acpi_resource_extended_address64 *p = &r->data.ext_address64;\n\tunsigned char flags = 0;\n\n\tif (p->resource_type == ACPI_MEMORY_RANGE) {\n\t\tif (p->info.mem.write_protect == ACPI_READ_WRITE_MEMORY)\n\t\t\tflags = IORESOURCE_MEM_WRITEABLE;\n\t\tpnp_register_mem_resource(dev, option_flags, p->address.minimum,\n\t\t\t\t\t  p->address.minimum, 0, p->address.address_length,\n\t\t\t\t\t  flags);\n\t} else if (p->resource_type == ACPI_IO_RANGE)\n\t\tpnp_register_port_resource(dev, option_flags, p->address.minimum,\n\t\t\t\t\t   p->address.minimum, 0, p->address.address_length,\n\t\t\t\t\t   IORESOURCE_IO_FIXED);\n}\n\nstruct acpipnp_parse_option_s {\n\tstruct pnp_dev *dev;\n\tunsigned int option_flags;\n};\n\nstatic __init acpi_status pnpacpi_option_resource(struct acpi_resource *res,\n\t\t\t\t\t\t  void *data)\n{\n\tint priority;\n\tstruct acpipnp_parse_option_s *parse_data = data;\n\tstruct pnp_dev *dev = parse_data->dev;\n\tunsigned int option_flags = parse_data->option_flags;\n\n\tswitch (res->type) {\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\tpnpacpi_parse_irq_option(dev, option_flags, &res->data.irq);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_DMA:\n\t\tpnpacpi_parse_dma_option(dev, option_flags, &res->data.dma);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_START_DEPENDENT:\n\t\tswitch (res->data.start_dpf.compatibility_priority) {\n\t\tcase ACPI_GOOD_CONFIGURATION:\n\t\t\tpriority = PNP_RES_PRIORITY_PREFERRED;\n\t\t\tbreak;\n\n\t\tcase ACPI_ACCEPTABLE_CONFIGURATION:\n\t\t\tpriority = PNP_RES_PRIORITY_ACCEPTABLE;\n\t\t\tbreak;\n\n\t\tcase ACPI_SUB_OPTIMAL_CONFIGURATION:\n\t\t\tpriority = PNP_RES_PRIORITY_FUNCTIONAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpriority = PNP_RES_PRIORITY_INVALID;\n\t\t\tbreak;\n\t\t}\n\t\tparse_data->option_flags = pnp_new_dependent_set(dev, priority);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_END_DEPENDENT:\n\t\tparse_data->option_flags = 0;\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_IO:\n\t\tpnpacpi_parse_port_option(dev, option_flags, &res->data.io);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_FIXED_IO:\n\t\tpnpacpi_parse_fixed_port_option(dev, option_flags,\n\t\t\t\t\t        &res->data.fixed_io);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_VENDOR:\n\tcase ACPI_RESOURCE_TYPE_END_TAG:\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_MEMORY24:\n\t\tpnpacpi_parse_mem24_option(dev, option_flags,\n\t\t\t\t\t   &res->data.memory24);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_MEMORY32:\n\t\tpnpacpi_parse_mem32_option(dev, option_flags,\n\t\t\t\t\t   &res->data.memory32);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\n\t\tpnpacpi_parse_fixed_mem32_option(dev, option_flags,\n\t\t\t\t\t\t &res->data.fixed_memory32);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_ADDRESS16:\n\tcase ACPI_RESOURCE_TYPE_ADDRESS32:\n\tcase ACPI_RESOURCE_TYPE_ADDRESS64:\n\t\tpnpacpi_parse_address_option(dev, option_flags, res);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64:\n\t\tpnpacpi_parse_ext_address_option(dev, option_flags, res);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\tpnpacpi_parse_ext_irq_option(dev, option_flags,\n\t\t\t\t\t     &res->data.extended_irq);\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_GENERIC_REGISTER:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&dev->dev, \"unknown resource type %d in _PRS\\n\",\n\t\t\t res->type);\n\t\treturn AE_ERROR;\n\t}\n\n\treturn AE_OK;\n}\n\nint __init pnpacpi_parse_resource_option_data(struct pnp_dev *dev)\n{\n\tstruct acpi_device *acpi_dev = dev->data;\n\tacpi_handle handle = acpi_dev->handle;\n\tacpi_status status;\n\tstruct acpipnp_parse_option_s parse_data;\n\n\tpnp_dbg(&dev->dev, \"parse resource options\\n\");\n\n\tparse_data.dev = dev;\n\tparse_data.option_flags = 0;\n\n\tstatus = acpi_walk_resources(handle, METHOD_NAME__PRS,\n\t\t\t\t     pnpacpi_option_resource, &parse_data);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tdev_err(&dev->dev, \"can't evaluate _PRS: %d\", status);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic int pnpacpi_supported_resource(struct acpi_resource *res)\n{\n\tswitch (res->type) {\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\tcase ACPI_RESOURCE_TYPE_DMA:\n\tcase ACPI_RESOURCE_TYPE_IO:\n\tcase ACPI_RESOURCE_TYPE_FIXED_IO:\n\tcase ACPI_RESOURCE_TYPE_MEMORY24:\n\tcase ACPI_RESOURCE_TYPE_MEMORY32:\n\tcase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\n\tcase ACPI_RESOURCE_TYPE_ADDRESS16:\n\tcase ACPI_RESOURCE_TYPE_ADDRESS32:\n\tcase ACPI_RESOURCE_TYPE_ADDRESS64:\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64:\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic acpi_status pnpacpi_count_resources(struct acpi_resource *res,\n\t\t\t\t\t   void *data)\n{\n\tint *res_cnt = data;\n\n\tif (pnpacpi_supported_resource(res))\n\t\t(*res_cnt)++;\n\treturn AE_OK;\n}\n\nstatic acpi_status pnpacpi_type_resources(struct acpi_resource *res, void *data)\n{\n\tstruct acpi_resource **resource = data;\n\n\tif (pnpacpi_supported_resource(res)) {\n\t\t(*resource)->type = res->type;\n\t\t(*resource)->length = sizeof(struct acpi_resource);\n\t\tif (res->type == ACPI_RESOURCE_TYPE_IRQ)\n\t\t\t(*resource)->data.irq.descriptor_length =\n\t\t\t\t\tres->data.irq.descriptor_length;\n\t\t(*resource)++;\n\t}\n\n\treturn AE_OK;\n}\n\nint pnpacpi_build_resource_template(struct pnp_dev *dev,\n\t\t\t\t    struct acpi_buffer *buffer)\n{\n\tstruct acpi_device *acpi_dev = dev->data;\n\tacpi_handle handle = acpi_dev->handle;\n\tstruct acpi_resource *resource;\n\tint res_cnt = 0;\n\tacpi_status status;\n\n\tstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\t     pnpacpi_count_resources, &res_cnt);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&dev->dev, \"can't evaluate _CRS: %d\\n\", status);\n\t\treturn -EINVAL;\n\t}\n\tif (!res_cnt)\n\t\treturn -EINVAL;\n\tbuffer->length = sizeof(struct acpi_resource) * (res_cnt + 1) + 1;\n\tbuffer->pointer = kzalloc(buffer->length - 1, GFP_KERNEL);\n\tif (!buffer->pointer)\n\t\treturn -ENOMEM;\n\n\tresource = (struct acpi_resource *)buffer->pointer;\n\tstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\t     pnpacpi_type_resources, &resource);\n\tif (ACPI_FAILURE(status)) {\n\t\tkfree(buffer->pointer);\n\t\tdev_err(&dev->dev, \"can't evaluate _CRS: %d\\n\", status);\n\t\treturn -EINVAL;\n\t}\n\t \n\tresource->type = ACPI_RESOURCE_TYPE_END_TAG;\n\tresource->length = sizeof(struct acpi_resource);\n\n\treturn 0;\n}\n\nstatic void pnpacpi_encode_irq(struct pnp_dev *dev,\n\t\t\t       struct acpi_resource *resource,\n\t\t\t       struct resource *p)\n{\n\tstruct acpi_resource_irq *irq = &resource->data.irq;\n\tu8 triggering, polarity, shareable;\n\n\tif (!pnp_resource_enabled(p)) {\n\t\tirq->interrupt_count = 0;\n\t\tpnp_dbg(&dev->dev, \"  encode irq (%s)\\n\",\n\t\t\tp ? \"disabled\" : \"missing\");\n\t\treturn;\n\t}\n\n\tdecode_irq_flags(dev, p->flags, &triggering, &polarity, &shareable);\n\tirq->triggering = triggering;\n\tirq->polarity = polarity;\n\tirq->shareable = shareable;\n\tirq->interrupt_count = 1;\n\tirq->interrupts[0] = p->start;\n\n\tpnp_dbg(&dev->dev, \"  encode irq %d %s %s %s (%d-byte descriptor)\\n\",\n\t\t(int) p->start,\n\t\ttriggering == ACPI_LEVEL_SENSITIVE ? \"level\" : \"edge\",\n\t\tpolarity == ACPI_ACTIVE_LOW ? \"low\" : \"high\",\n\t\tirq->shareable == ACPI_SHARED ? \"shared\" : \"exclusive\",\n\t\tirq->descriptor_length);\n}\n\nstatic void pnpacpi_encode_ext_irq(struct pnp_dev *dev,\n\t\t\t\t   struct acpi_resource *resource,\n\t\t\t\t   struct resource *p)\n{\n\tstruct acpi_resource_extended_irq *extended_irq = &resource->data.extended_irq;\n\tu8 triggering, polarity, shareable;\n\n\tif (!pnp_resource_enabled(p)) {\n\t\textended_irq->interrupt_count = 0;\n\t\tpnp_dbg(&dev->dev, \"  encode extended irq (%s)\\n\",\n\t\t\tp ? \"disabled\" : \"missing\");\n\t\treturn;\n\t}\n\n\tdecode_irq_flags(dev, p->flags, &triggering, &polarity, &shareable);\n\textended_irq->producer_consumer = ACPI_CONSUMER;\n\textended_irq->triggering = triggering;\n\textended_irq->polarity = polarity;\n\textended_irq->shareable = shareable;\n\textended_irq->interrupt_count = 1;\n\textended_irq->interrupts[0] = p->start;\n\n\tpnp_dbg(&dev->dev, \"  encode irq %d %s %s %s\\n\", (int) p->start,\n\t\ttriggering == ACPI_LEVEL_SENSITIVE ? \"level\" : \"edge\",\n\t\tpolarity == ACPI_ACTIVE_LOW ? \"low\" : \"high\",\n\t\textended_irq->shareable == ACPI_SHARED ? \"shared\" : \"exclusive\");\n}\n\nstatic void pnpacpi_encode_dma(struct pnp_dev *dev,\n\t\t\t       struct acpi_resource *resource,\n\t\t\t       struct resource *p)\n{\n\tstruct acpi_resource_dma *dma = &resource->data.dma;\n\n\tif (!pnp_resource_enabled(p)) {\n\t\tdma->channel_count = 0;\n\t\tpnp_dbg(&dev->dev, \"  encode dma (%s)\\n\",\n\t\t\tp ? \"disabled\" : \"missing\");\n\t\treturn;\n\t}\n\n\t \n\tswitch (p->flags & IORESOURCE_DMA_SPEED_MASK) {\n\tcase IORESOURCE_DMA_TYPEA:\n\t\tdma->type = ACPI_TYPE_A;\n\t\tbreak;\n\tcase IORESOURCE_DMA_TYPEB:\n\t\tdma->type = ACPI_TYPE_B;\n\t\tbreak;\n\tcase IORESOURCE_DMA_TYPEF:\n\t\tdma->type = ACPI_TYPE_F;\n\t\tbreak;\n\tdefault:\n\t\tdma->type = ACPI_COMPATIBILITY;\n\t}\n\n\tswitch (p->flags & IORESOURCE_DMA_TYPE_MASK) {\n\tcase IORESOURCE_DMA_8BIT:\n\t\tdma->transfer = ACPI_TRANSFER_8;\n\t\tbreak;\n\tcase IORESOURCE_DMA_8AND16BIT:\n\t\tdma->transfer = ACPI_TRANSFER_8_16;\n\t\tbreak;\n\tdefault:\n\t\tdma->transfer = ACPI_TRANSFER_16;\n\t}\n\n\tdma->bus_master = !!(p->flags & IORESOURCE_DMA_MASTER);\n\tdma->channel_count = 1;\n\tdma->channels[0] = p->start;\n\n\tpnp_dbg(&dev->dev, \"  encode dma %d \"\n\t\t\"type %#x transfer %#x master %d\\n\",\n\t\t(int) p->start, dma->type, dma->transfer, dma->bus_master);\n}\n\nstatic void pnpacpi_encode_io(struct pnp_dev *dev,\n\t\t\t      struct acpi_resource *resource,\n\t\t\t      struct resource *p)\n{\n\tstruct acpi_resource_io *io = &resource->data.io;\n\n\tif (pnp_resource_enabled(p)) {\n\t\t \n\t\tio->io_decode = (p->flags & IORESOURCE_IO_16BIT_ADDR) ?\n\t\t    ACPI_DECODE_16 : ACPI_DECODE_10;\n\t\tio->minimum = p->start;\n\t\tio->maximum = p->end;\n\t\tio->alignment = 0;\t \n\t\tio->address_length = resource_size(p);\n\t} else {\n\t\tio->minimum = 0;\n\t\tio->address_length = 0;\n\t}\n\n\tpnp_dbg(&dev->dev, \"  encode io %#x-%#x decode %#x\\n\", io->minimum,\n\t\tio->minimum + io->address_length - 1, io->io_decode);\n}\n\nstatic void pnpacpi_encode_fixed_io(struct pnp_dev *dev,\n\t\t\t\t    struct acpi_resource *resource,\n\t\t\t\t    struct resource *p)\n{\n\tstruct acpi_resource_fixed_io *fixed_io = &resource->data.fixed_io;\n\n\tif (pnp_resource_enabled(p)) {\n\t\tfixed_io->address = p->start;\n\t\tfixed_io->address_length = resource_size(p);\n\t} else {\n\t\tfixed_io->address = 0;\n\t\tfixed_io->address_length = 0;\n\t}\n\n\tpnp_dbg(&dev->dev, \"  encode fixed_io %#x-%#x\\n\", fixed_io->address,\n\t\tfixed_io->address + fixed_io->address_length - 1);\n}\n\nstatic void pnpacpi_encode_mem24(struct pnp_dev *dev,\n\t\t\t\t struct acpi_resource *resource,\n\t\t\t\t struct resource *p)\n{\n\tstruct acpi_resource_memory24 *memory24 = &resource->data.memory24;\n\n\tif (pnp_resource_enabled(p)) {\n\t\t \n\t\tmemory24->write_protect = p->flags & IORESOURCE_MEM_WRITEABLE ?\n\t\t    ACPI_READ_WRITE_MEMORY : ACPI_READ_ONLY_MEMORY;\n\t\tmemory24->minimum = p->start;\n\t\tmemory24->maximum = p->end;\n\t\tmemory24->alignment = 0;\n\t\tmemory24->address_length = resource_size(p);\n\t} else {\n\t\tmemory24->minimum = 0;\n\t\tmemory24->address_length = 0;\n\t}\n\n\tpnp_dbg(&dev->dev, \"  encode mem24 %#x-%#x write_protect %#x\\n\",\n\t\tmemory24->minimum,\n\t\tmemory24->minimum + memory24->address_length - 1,\n\t\tmemory24->write_protect);\n}\n\nstatic void pnpacpi_encode_mem32(struct pnp_dev *dev,\n\t\t\t\t struct acpi_resource *resource,\n\t\t\t\t struct resource *p)\n{\n\tstruct acpi_resource_memory32 *memory32 = &resource->data.memory32;\n\n\tif (pnp_resource_enabled(p)) {\n\t\tmemory32->write_protect = p->flags & IORESOURCE_MEM_WRITEABLE ?\n\t\t    ACPI_READ_WRITE_MEMORY : ACPI_READ_ONLY_MEMORY;\n\t\tmemory32->minimum = p->start;\n\t\tmemory32->maximum = p->end;\n\t\tmemory32->alignment = 0;\n\t\tmemory32->address_length = resource_size(p);\n\t} else {\n\t\tmemory32->minimum = 0;\n\t\tmemory32->alignment = 0;\n\t}\n\n\tpnp_dbg(&dev->dev, \"  encode mem32 %#x-%#x write_protect %#x\\n\",\n\t\tmemory32->minimum,\n\t\tmemory32->minimum + memory32->address_length - 1,\n\t\tmemory32->write_protect);\n}\n\nstatic void pnpacpi_encode_fixed_mem32(struct pnp_dev *dev,\n\t\t\t\t       struct acpi_resource *resource,\n\t\t\t\t       struct resource *p)\n{\n\tstruct acpi_resource_fixed_memory32 *fixed_memory32 = &resource->data.fixed_memory32;\n\n\tif (pnp_resource_enabled(p)) {\n\t\tfixed_memory32->write_protect =\n\t\t    p->flags & IORESOURCE_MEM_WRITEABLE ?\n\t\t    ACPI_READ_WRITE_MEMORY : ACPI_READ_ONLY_MEMORY;\n\t\tfixed_memory32->address = p->start;\n\t\tfixed_memory32->address_length = resource_size(p);\n\t} else {\n\t\tfixed_memory32->address = 0;\n\t\tfixed_memory32->address_length = 0;\n\t}\n\n\tpnp_dbg(&dev->dev, \"  encode fixed_mem32 %#x-%#x write_protect %#x\\n\",\n\t\tfixed_memory32->address,\n\t\tfixed_memory32->address + fixed_memory32->address_length - 1,\n\t\tfixed_memory32->write_protect);\n}\n\nint pnpacpi_encode_resources(struct pnp_dev *dev, struct acpi_buffer *buffer)\n{\n\tint i = 0;\n\t \n\tint res_cnt = (buffer->length - 1) / sizeof(struct acpi_resource) - 1;\n\tstruct acpi_resource *resource = buffer->pointer;\n\tunsigned int port = 0, irq = 0, dma = 0, mem = 0;\n\n\tpnp_dbg(&dev->dev, \"encode %d resources\\n\", res_cnt);\n\twhile (i < res_cnt) {\n\t\tswitch (resource->type) {\n\t\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\t\tpnpacpi_encode_irq(dev, resource,\n\t\t\t       pnp_get_resource(dev, IORESOURCE_IRQ, irq));\n\t\t\tirq++;\n\t\t\tbreak;\n\n\t\tcase ACPI_RESOURCE_TYPE_DMA:\n\t\t\tpnpacpi_encode_dma(dev, resource,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_DMA, dma));\n\t\t\tdma++;\n\t\t\tbreak;\n\t\tcase ACPI_RESOURCE_TYPE_IO:\n\t\t\tpnpacpi_encode_io(dev, resource,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_IO, port));\n\t\t\tport++;\n\t\t\tbreak;\n\t\tcase ACPI_RESOURCE_TYPE_FIXED_IO:\n\t\t\tpnpacpi_encode_fixed_io(dev, resource,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_IO, port));\n\t\t\tport++;\n\t\t\tbreak;\n\t\tcase ACPI_RESOURCE_TYPE_MEMORY24:\n\t\t\tpnpacpi_encode_mem24(dev, resource,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_MEM, mem));\n\t\t\tmem++;\n\t\t\tbreak;\n\t\tcase ACPI_RESOURCE_TYPE_MEMORY32:\n\t\t\tpnpacpi_encode_mem32(dev, resource,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_MEM, mem));\n\t\t\tmem++;\n\t\t\tbreak;\n\t\tcase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\n\t\t\tpnpacpi_encode_fixed_mem32(dev, resource,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_MEM, mem));\n\t\t\tmem++;\n\t\t\tbreak;\n\t\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\t\tpnpacpi_encode_ext_irq(dev, resource,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_IRQ, irq));\n\t\t\tirq++;\n\t\t\tbreak;\n\t\tcase ACPI_RESOURCE_TYPE_START_DEPENDENT:\n\t\tcase ACPI_RESOURCE_TYPE_END_DEPENDENT:\n\t\tcase ACPI_RESOURCE_TYPE_VENDOR:\n\t\tcase ACPI_RESOURCE_TYPE_END_TAG:\n\t\tcase ACPI_RESOURCE_TYPE_ADDRESS16:\n\t\tcase ACPI_RESOURCE_TYPE_ADDRESS32:\n\t\tcase ACPI_RESOURCE_TYPE_ADDRESS64:\n\t\tcase ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64:\n\t\tcase ACPI_RESOURCE_TYPE_GENERIC_REGISTER:\n\t\tdefault:\t \n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"can't encode unknown resource type %d\\n\",\n\t\t\t\t resource->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tresource++;\n\t\ti++;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}