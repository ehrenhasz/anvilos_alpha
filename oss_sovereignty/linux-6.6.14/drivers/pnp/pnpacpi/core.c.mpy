{
  "module_name": "core.c",
  "hash_id": "91b261884d88fdad6bc5902ceea583267e8fee8643555da924a8b4b336b2a71a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/pnpacpi/core.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/acpi.h>\n#include <linux/pnp.h>\n#include <linux/slab.h>\n#include <linux/mod_devicetable.h>\n\n#include \"../base.h\"\n#include \"pnpacpi.h\"\n\nstatic int num;\n\n \n#define TEST_HEX(c) \\\n\tif (!(('0' <= (c) && (c) <= '9') || ('A' <= (c) && (c) <= 'F'))) \\\n\t\treturn 0\n#define TEST_ALPHA(c) \\\n\tif (!('A' <= (c) && (c) <= 'Z')) \\\n\t\treturn 0\nstatic int __init ispnpidacpi(const char *id)\n{\n\tTEST_ALPHA(id[0]);\n\tTEST_ALPHA(id[1]);\n\tTEST_ALPHA(id[2]);\n\tTEST_HEX(id[3]);\n\tTEST_HEX(id[4]);\n\tTEST_HEX(id[5]);\n\tTEST_HEX(id[6]);\n\tif (id[7] != '\\0')\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int pnpacpi_get_resources(struct pnp_dev *dev)\n{\n\tpnp_dbg(&dev->dev, \"get resources\\n\");\n\treturn pnpacpi_parse_allocated_resource(dev);\n}\n\nstatic int pnpacpi_set_resources(struct pnp_dev *dev)\n{\n\tstruct acpi_device *acpi_dev;\n\tacpi_handle handle;\n\tint ret = 0;\n\n\tpnp_dbg(&dev->dev, \"set resources\\n\");\n\n\tacpi_dev = ACPI_COMPANION(&dev->dev);\n\tif (!acpi_dev) {\n\t\tdev_dbg(&dev->dev, \"ACPI device not found in %s!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (WARN_ON_ONCE(acpi_dev != dev->data))\n\t\tdev->data = acpi_dev;\n\n\thandle = acpi_dev->handle;\n\tif (acpi_has_method(handle, METHOD_NAME__SRS)) {\n\t\tstruct acpi_buffer buffer;\n\n\t\tret = pnpacpi_build_resource_template(dev, &buffer);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = pnpacpi_encode_resources(dev, &buffer);\n\t\tif (!ret) {\n\t\t\tacpi_status status;\n\n\t\t\tstatus = acpi_set_current_resources(handle, &buffer);\n\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\tret = -EIO;\n\t\t}\n\t\tkfree(buffer.pointer);\n\t}\n\tif (!ret && acpi_device_power_manageable(acpi_dev))\n\t\tret = acpi_device_set_power(acpi_dev, ACPI_STATE_D0);\n\n\treturn ret;\n}\n\nstatic int pnpacpi_disable_resources(struct pnp_dev *dev)\n{\n\tstruct acpi_device *acpi_dev;\n\tacpi_status status;\n\n\tdev_dbg(&dev->dev, \"disable resources\\n\");\n\n\tacpi_dev = ACPI_COMPANION(&dev->dev);\n\tif (!acpi_dev) {\n\t\tdev_dbg(&dev->dev, \"ACPI device not found in %s!\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t \n\tif (acpi_device_power_manageable(acpi_dev))\n\t\tacpi_device_set_power(acpi_dev, ACPI_STATE_D3_COLD);\n\n\t \n\tstatus = acpi_evaluate_object(acpi_dev->handle, \"_DIS\", NULL, NULL);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI_SLEEP\nstatic bool pnpacpi_can_wakeup(struct pnp_dev *dev)\n{\n\tstruct acpi_device *acpi_dev = ACPI_COMPANION(&dev->dev);\n\n\tif (!acpi_dev) {\n\t\tdev_dbg(&dev->dev, \"ACPI device not found in %s!\\n\", __func__);\n\t\treturn false;\n\t}\n\n\treturn acpi_bus_can_wakeup(acpi_dev->handle);\n}\n\nstatic int pnpacpi_suspend(struct pnp_dev *dev, pm_message_t state)\n{\n\tstruct acpi_device *acpi_dev = ACPI_COMPANION(&dev->dev);\n\tint error = 0;\n\n\tif (!acpi_dev) {\n\t\tdev_dbg(&dev->dev, \"ACPI device not found in %s!\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (device_can_wakeup(&dev->dev)) {\n\t\terror = acpi_pm_set_device_wakeup(&dev->dev,\n\t\t\t\t\t      device_may_wakeup(&dev->dev));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (acpi_device_power_manageable(acpi_dev)) {\n\t\tint power_state = acpi_pm_device_sleep_state(&dev->dev, NULL,\n\t\t\t\t\t\t\tACPI_STATE_D3_COLD);\n\t\tif (power_state < 0)\n\t\t\tpower_state = (state.event == PM_EVENT_ON) ?\n\t\t\t\t\tACPI_STATE_D0 : ACPI_STATE_D3_COLD;\n\n\t\t \n\t\terror = acpi_device_set_power(acpi_dev, power_state);\n\t}\n\n\treturn error;\n}\n\nstatic int pnpacpi_resume(struct pnp_dev *dev)\n{\n\tstruct acpi_device *acpi_dev = ACPI_COMPANION(&dev->dev);\n\tint error = 0;\n\n\tif (!acpi_dev) {\n\t\tdev_dbg(&dev->dev, \"ACPI device not found in %s!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (device_may_wakeup(&dev->dev))\n\t\tacpi_pm_set_device_wakeup(&dev->dev, false);\n\n\tif (acpi_device_power_manageable(acpi_dev))\n\t\terror = acpi_device_set_power(acpi_dev, ACPI_STATE_D0);\n\n\treturn error;\n}\n#endif\n\nstruct pnp_protocol pnpacpi_protocol = {\n\t.name\t = \"Plug and Play ACPI\",\n\t.get\t = pnpacpi_get_resources,\n\t.set\t = pnpacpi_set_resources,\n\t.disable = pnpacpi_disable_resources,\n#ifdef CONFIG_ACPI_SLEEP\n\t.can_wakeup = pnpacpi_can_wakeup,\n\t.suspend = pnpacpi_suspend,\n\t.resume = pnpacpi_resume,\n#endif\n};\nEXPORT_SYMBOL(pnpacpi_protocol);\n\nstatic const char *__init pnpacpi_get_id(struct acpi_device *device)\n{\n\tstruct acpi_hardware_id *id;\n\n\tlist_for_each_entry(id, &device->pnp.ids, list) {\n\t\tif (ispnpidacpi(id->id))\n\t\t\treturn id->id;\n\t}\n\n\treturn NULL;\n}\n\nstatic int __init pnpacpi_add_device(struct acpi_device *device)\n{\n\tstruct pnp_dev *dev;\n\tconst char *pnpid;\n\tstruct acpi_hardware_id *id;\n\tint error;\n\n\t \n\tif (device->physical_node_count)\n\t\treturn 0;\n\n\t \n\tif (!acpi_has_method(device->handle, \"_CRS\"))\n\t\treturn 0;\n\n\tpnpid = pnpacpi_get_id(device);\n\tif (!pnpid)\n\t\treturn 0;\n\n\tif (!device->status.present)\n\t\treturn 0;\n\n\tdev = pnp_alloc_dev(&pnpacpi_protocol, num, pnpid);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tACPI_COMPANION_SET(&dev->dev, device);\n\tdev->data = device;\n\t \n\tdev->active = device->status.enabled;\n\tif (acpi_has_method(device->handle, \"_SRS\"))\n\t\tdev->capabilities |= PNP_CONFIGURABLE;\n\tdev->capabilities |= PNP_READ;\n\tif (device->flags.dynamic_status && (dev->capabilities & PNP_CONFIGURABLE))\n\t\tdev->capabilities |= PNP_WRITE;\n\tif (device->flags.removable)\n\t\tdev->capabilities |= PNP_REMOVABLE;\n\tif (acpi_has_method(device->handle, \"_DIS\"))\n\t\tdev->capabilities |= PNP_DISABLE;\n\n\tif (strlen(acpi_device_name(device)))\n\t\tstrncpy(dev->name, acpi_device_name(device), sizeof(dev->name));\n\telse\n\t\tstrncpy(dev->name, acpi_device_bid(device), sizeof(dev->name));\n\n\t \n\tdev->name[sizeof(dev->name) - 1] = '\\0';\n\n\tif (dev->active)\n\t\tpnpacpi_parse_allocated_resource(dev);\n\n\tif (dev->capabilities & PNP_CONFIGURABLE)\n\t\tpnpacpi_parse_resource_option_data(dev);\n\n\tlist_for_each_entry(id, &device->pnp.ids, list) {\n\t\tif (!strcmp(id->id, pnpid))\n\t\t\tcontinue;\n\t\tif (!ispnpidacpi(id->id))\n\t\t\tcontinue;\n\t\tpnp_add_id(dev, id->id);\n\t}\n\n\t \n\tif (!dev->active)\n\t\tpnp_init_resources(dev);\n\n\terror = pnp_add_device(dev);\n\tif (error) {\n\t\tput_device(&dev->dev);\n\t\treturn error;\n\t}\n\n\tnum++;\n\n\treturn 0;\n}\n\nstatic acpi_status __init pnpacpi_add_device_handler(acpi_handle handle,\n\t\t\t\t\t\t     u32 lvl, void *context,\n\t\t\t\t\t\t     void **rv)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\n\tif (!device)\n\t\treturn AE_CTRL_DEPTH;\n\tif (acpi_is_pnp_device(device))\n\t\tpnpacpi_add_device(device);\n\treturn AE_OK;\n}\n\nint pnpacpi_disabled __initdata;\nstatic int __init pnpacpi_init(void)\n{\n\tif (acpi_disabled || pnpacpi_disabled) {\n\t\tprintk(KERN_INFO \"pnp: PnP ACPI: disabled\\n\");\n\t\treturn 0;\n\t}\n\tprintk(KERN_INFO \"pnp: PnP ACPI init\\n\");\n\tpnp_register_protocol(&pnpacpi_protocol);\n\tacpi_get_devices(NULL, pnpacpi_add_device_handler, NULL, NULL);\n\tprintk(KERN_INFO \"pnp: PnP ACPI: found %d devices\\n\", num);\n\tpnp_platform_devices = 1;\n\treturn 0;\n}\n\nfs_initcall(pnpacpi_init);\n\nstatic int __init pnpacpi_setup(char *str)\n{\n\tif (str == NULL)\n\t\treturn 1;\n\tif (!strncmp(str, \"off\", 3))\n\t\tpnpacpi_disabled = 1;\n\treturn 1;\n}\n\n__setup(\"pnpacpi=\", pnpacpi_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}