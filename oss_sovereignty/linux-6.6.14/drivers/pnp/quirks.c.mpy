{
  "module_name": "quirks.c",
  "hash_id": "1676dccdf1a516e8612e045b65e7727dd49f697c9d8252952cacd6ac840c8009",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/quirks.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/pnp.h>\n#include <linux/io.h>\n#include \"base.h\"\n\nstatic void quirk_awe32_add_ports(struct pnp_dev *dev,\n\t\t\t\t  struct pnp_option *option,\n\t\t\t\t  unsigned int offset)\n{\n\tstruct pnp_option *new_option;\n\n\tnew_option = kmalloc(sizeof(struct pnp_option), GFP_KERNEL);\n\tif (!new_option) {\n\t\tdev_err(&dev->dev, \"couldn't add ioport region to option set \"\n\t\t\t\"%d\\n\", pnp_option_set(option));\n\t\treturn;\n\t}\n\n\t*new_option = *option;\n\tnew_option->u.port.min += offset;\n\tnew_option->u.port.max += offset;\n\tlist_add(&new_option->list, &option->list);\n\n\tdev_info(&dev->dev, \"added ioport region %#llx-%#llx to set %d\\n\",\n\t\t(unsigned long long) new_option->u.port.min,\n\t\t(unsigned long long) new_option->u.port.max,\n\t\tpnp_option_set(option));\n}\n\nstatic void quirk_awe32_resources(struct pnp_dev *dev)\n{\n\tstruct pnp_option *option;\n\tunsigned int set = ~0;\n\n\t \n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (pnp_option_is_dependent(option) &&\n\t\t    pnp_option_set(option) != set) {\n\t\t\tset = pnp_option_set(option);\n\t\t\tquirk_awe32_add_ports(dev, option, 0x800);\n\t\t\tquirk_awe32_add_ports(dev, option, 0x400);\n\t\t}\n\t}\n}\n\nstatic void quirk_cmi8330_resources(struct pnp_dev *dev)\n{\n\tstruct pnp_option *option;\n\tstruct pnp_irq *irq;\n\tstruct pnp_dma *dma;\n\n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (!pnp_option_is_dependent(option))\n\t\t\tcontinue;\n\n\t\tif (option->type == IORESOURCE_IRQ) {\n\t\t\tirq = &option->u.irq;\n\t\t\tbitmap_zero(irq->map.bits, PNP_IRQ_NR);\n\t\t\t__set_bit(5, irq->map.bits);\n\t\t\t__set_bit(7, irq->map.bits);\n\t\t\t__set_bit(10, irq->map.bits);\n\t\t\tdev_info(&dev->dev, \"set possible IRQs in \"\n\t\t\t\t \"option set %d to 5, 7, 10\\n\",\n\t\t\t\t pnp_option_set(option));\n\t\t} else if (option->type == IORESOURCE_DMA) {\n\t\t\tdma = &option->u.dma;\n\t\t\tif ((dma->flags & IORESOURCE_DMA_TYPE_MASK) ==\n\t\t\t\t\t\tIORESOURCE_DMA_8BIT &&\n\t\t\t    dma->map != 0x0A) {\n\t\t\t\tdev_info(&dev->dev, \"changing possible \"\n\t\t\t\t\t \"DMA channel mask in option set %d \"\n\t\t\t\t\t \"from %#02x to 0x0A (1, 3)\\n\",\n\t\t\t\t\t pnp_option_set(option), dma->map);\n\t\t\t\tdma->map = 0x0A;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void quirk_sb16audio_resources(struct pnp_dev *dev)\n{\n\tstruct pnp_option *option;\n\tunsigned int prev_option_flags = ~0, n = 0;\n\tstruct pnp_port *port;\n\n\t \n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (prev_option_flags != option->flags) {\n\t\t\tprev_option_flags = option->flags;\n\t\t\tn = 0;\n\t\t}\n\n\t\tif (pnp_option_is_dependent(option) &&\n\t\t    option->type == IORESOURCE_IO) {\n\t\t\tn++;\n\t\t\tport = &option->u.port;\n\t\t\tif (n == 3 && port->min == port->max) {\n\t\t\t\tport->max += 0x70;\n\t\t\t\tdev_info(&dev->dev, \"increased option port \"\n\t\t\t\t\t \"range from %#llx-%#llx to \"\n\t\t\t\t\t \"%#llx-%#llx\\n\",\n\t\t\t\t\t (unsigned long long) port->min,\n\t\t\t\t\t (unsigned long long) port->min,\n\t\t\t\t\t (unsigned long long) port->min,\n\t\t\t\t\t (unsigned long long) port->max);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct pnp_option *pnp_clone_dependent_set(struct pnp_dev *dev,\n\t\t\t\t\t\t  unsigned int set)\n{\n\tstruct pnp_option *tail = NULL, *first_new_option = NULL;\n\tstruct pnp_option *option, *new_option;\n\tunsigned int flags;\n\n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (pnp_option_is_dependent(option))\n\t\t\ttail = option;\n\t}\n\tif (!tail) {\n\t\tdev_err(&dev->dev, \"no dependent option sets\\n\");\n\t\treturn NULL;\n\t}\n\n\tflags = pnp_new_dependent_set(dev, PNP_RES_PRIORITY_FUNCTIONAL);\n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (pnp_option_is_dependent(option) &&\n\t\t    pnp_option_set(option) == set) {\n\t\t\tnew_option = kmalloc(sizeof(struct pnp_option),\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!new_option) {\n\t\t\t\tdev_err(&dev->dev, \"couldn't clone dependent \"\n\t\t\t\t\t\"set %d\\n\", set);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*new_option = *option;\n\t\t\tnew_option->flags = flags;\n\t\t\tif (!first_new_option)\n\t\t\t\tfirst_new_option = new_option;\n\n\t\t\tlist_add(&new_option->list, &tail->list);\n\t\t\ttail = new_option;\n\t\t}\n\t}\n\n\treturn first_new_option;\n}\n\n\nstatic void quirk_add_irq_optional_dependent_sets(struct pnp_dev *dev)\n{\n\tstruct pnp_option *new_option;\n\tunsigned int num_sets, i, set;\n\tstruct pnp_irq *irq;\n\n\tnum_sets = dev->num_dependent_sets;\n\tfor (i = 0; i < num_sets; i++) {\n\t\tnew_option = pnp_clone_dependent_set(dev, i);\n\t\tif (!new_option)\n\t\t\treturn;\n\n\t\tset = pnp_option_set(new_option);\n\t\twhile (new_option && pnp_option_set(new_option) == set) {\n\t\t\tif (new_option->type == IORESOURCE_IRQ) {\n\t\t\t\tirq = &new_option->u.irq;\n\t\t\t\tirq->flags |= IORESOURCE_IRQ_OPTIONAL;\n\t\t\t}\n\t\t\tdbg_pnp_show_option(dev, new_option);\n\t\t\tnew_option = list_entry(new_option->list.next,\n\t\t\t\t\t\tstruct pnp_option, list);\n\t\t}\n\n\t\tdev_info(&dev->dev, \"added dependent option set %d (same as \"\n\t\t\t \"set %d except IRQ optional)\\n\", set, i);\n\t}\n}\n\nstatic void quirk_ad1815_mpu_resources(struct pnp_dev *dev)\n{\n\tstruct pnp_option *option;\n\tstruct pnp_irq *irq = NULL;\n\tunsigned int independent_irqs = 0;\n\n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (option->type == IORESOURCE_IRQ &&\n\t\t    !pnp_option_is_dependent(option)) {\n\t\t\tindependent_irqs++;\n\t\t\tirq = &option->u.irq;\n\t\t}\n\t}\n\n\tif (independent_irqs != 1)\n\t\treturn;\n\n\tirq->flags |= IORESOURCE_IRQ_OPTIONAL;\n\tdev_info(&dev->dev, \"made independent IRQ optional\\n\");\n}\n\nstatic void quirk_system_pci_resources(struct pnp_dev *dev)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct resource *res, *r;\n\tint i, j;\n\n\t \n\tfor_each_pci_dev(pdev) {\n\t\tpci_dev_for_each_resource(pdev, r, i) {\n\t\t\tunsigned long type = resource_type(r);\n\n\t\t\tif (!(type == IORESOURCE_IO || type == IORESOURCE_MEM) ||\n\t\t\t    resource_size(r) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (r->flags & IORESOURCE_UNSET)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0;\n\t\t\t     (res = pnp_get_resource(dev, type, j)); j++) {\n\t\t\t\tif (res->start == 0 && res->end == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (!resource_overlaps(res, r))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (res->start <= r->start && res->end >= r->end)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tdev_warn(&dev->dev,\n\t\t\t\t\t \"disabling %pR because it overlaps %s BAR %d %pR\\n\",\n\t\t\t\t\t res, pci_name(pdev), i, r);\n\t\t\t\tres->flags |= IORESOURCE_DISABLED;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_AMD_NB\n\n#include <asm/amd_nb.h>\n\nstatic void quirk_amd_mmconfig_area(struct pnp_dev *dev)\n{\n\tresource_size_t start, end;\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\tstruct resource mmconfig_res, *mmconfig;\n\n\tmmconfig = amd_get_mmconfig_range(&mmconfig_res);\n\tif (!mmconfig)\n\t\treturn;\n\n\tlist_for_each_entry(pnp_res, &dev->resources, list) {\n\t\tres = &pnp_res->res;\n\t\tif (res->end < mmconfig->start || res->start > mmconfig->end ||\n\t\t    (res->start == mmconfig->start && res->end == mmconfig->end))\n\t\t\tcontinue;\n\n\t\tdev_info(&dev->dev, FW_BUG\n\t\t\t \"%pR covers only part of AMD MMCONFIG area %pR; adding more reservations\\n\",\n\t\t\t res, mmconfig);\n\t\tif (mmconfig->start < res->start) {\n\t\t\tstart = mmconfig->start;\n\t\t\tend = res->start - 1;\n\t\t\tpnp_add_mem_resource(dev, start, end, 0);\n\t\t}\n\t\tif (mmconfig->end > res->end) {\n\t\t\tstart = res->end + 1;\n\t\t\tend = mmconfig->end;\n\t\t\tpnp_add_mem_resource(dev, start, end, 0);\n\t\t}\n\t\tbreak;\n\t}\n}\n#endif\n\n#ifdef CONFIG_PCI\n \nstatic const unsigned int mch_quirk_devices[] = {\n\t0x0154,\t \n\t0x0a04,  \n\t0x0c00,\t \n\t0x1604,  \n};\n\nstatic struct pci_dev *get_intel_host(void)\n{\n\tint i;\n\tstruct pci_dev *host;\n\n\tfor (i = 0; i < ARRAY_SIZE(mch_quirk_devices); i++) {\n\t\thost = pci_get_device(PCI_VENDOR_ID_INTEL, mch_quirk_devices[i],\n\t\t\t\t      NULL);\n\t\tif (host)\n\t\t\treturn host;\n\t}\n\treturn NULL;\n}\n\nstatic void quirk_intel_mch(struct pnp_dev *dev)\n{\n\tstruct pci_dev *host;\n\tu32 addr_lo, addr_hi;\n\tstruct pci_bus_region region;\n\tstruct resource mch;\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\n\thost = get_intel_host();\n\tif (!host)\n\t\treturn;\n\n\t \n\n\t \n\tpci_read_config_dword(host, 0x48, &addr_lo);\n\tregion.start = addr_lo & ~0x7fff;\n\tpci_read_config_dword(host, 0x4c, &addr_hi);\n\tregion.start |= (u64) addr_hi << 32;\n\tregion.end = region.start + 32*1024 - 1;\n\n\tmemset(&mch, 0, sizeof(mch));\n\tmch.flags = IORESOURCE_MEM;\n\tpcibios_bus_to_resource(host->bus, &mch, &region);\n\n\tlist_for_each_entry(pnp_res, &dev->resources, list) {\n\t\tres = &pnp_res->res;\n\t\tif (res->end < mch.start || res->start > mch.end)\n\t\t\tcontinue;\t \n\t\tif (res->start == mch.start && res->end == mch.end)\n\t\t\tcontinue;\t \n\n\t\tdev_info(&dev->dev, FW_BUG \"PNP resource %pR covers only part of %s Intel MCH; extending to %pR\\n\",\n\t\t\t res, pci_name(host), &mch);\n\t\tres->start = mch.start;\n\t\tres->end = mch.end;\n\t\tbreak;\n\t}\n\n\tpci_dev_put(host);\n}\n#endif\n\n \n\nstatic struct pnp_fixup pnp_fixups[] = {\n\t \n\t{\"CTL0021\", quirk_awe32_resources},\n\t{\"CTL0022\", quirk_awe32_resources},\n\t{\"CTL0023\", quirk_awe32_resources},\n\t \n\t{\"@X@0001\", quirk_cmi8330_resources},\n\t \n\t{\"CTL0001\", quirk_sb16audio_resources},\n\t{\"CTL0031\", quirk_sb16audio_resources},\n\t{\"CTL0041\", quirk_sb16audio_resources},\n\t{\"CTL0042\", quirk_sb16audio_resources},\n\t{\"CTL0043\", quirk_sb16audio_resources},\n\t{\"CTL0044\", quirk_sb16audio_resources},\n\t{\"CTL0045\", quirk_sb16audio_resources},\n\t \n\t{\"ADS7151\", quirk_ad1815_mpu_resources},\n\t{\"ADS7181\", quirk_add_irq_optional_dependent_sets},\n\t{\"AZT0002\", quirk_add_irq_optional_dependent_sets},\n\t \n\t{\"PNP0c01\", quirk_system_pci_resources},\n\t{\"PNP0c02\", quirk_system_pci_resources},\n#ifdef CONFIG_AMD_NB\n\t{\"PNP0c01\", quirk_amd_mmconfig_area},\n#endif\n#ifdef CONFIG_PCI\n\t{\"PNP0c02\", quirk_intel_mch},\n#endif\n\t{\"\"}\n};\n\nvoid pnp_fixup_device(struct pnp_dev *dev)\n{\n\tstruct pnp_fixup *f;\n\n\tfor (f = pnp_fixups; *f->id; f++) {\n\t\tif (!compare_pnp_id(dev->id, f->id))\n\t\t\tcontinue;\n\t\tpnp_dbg(&dev->dev, \"%s: calling %pS\\n\", f->id,\n\t\t\tf->quirk_function);\n\t\tf->quirk_function(dev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}