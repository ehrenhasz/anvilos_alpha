{
  "module_name": "core.c",
  "hash_id": "f310b4e1e9b6e83dc3510a50d7abf9afad4c7b5769bfd520ff9843d38ebf17e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/isapnp/core.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/isapnp.h>\n#include <linux/mutex.h>\n#include <asm/io.h>\n\n#include \"../base.h\"\n\n#if 0\n#define ISAPNP_REGION_OK\n#endif\n\nint isapnp_disable;\t\t \nstatic int isapnp_rdp;\t\t \nstatic int isapnp_reset = 1;\t \nstatic int isapnp_verbose = 1;\t \n\nmodule_param(isapnp_disable, int, 0);\nMODULE_PARM_DESC(isapnp_disable, \"ISA Plug & Play disable\");\nmodule_param(isapnp_rdp, int, 0);\nMODULE_PARM_DESC(isapnp_rdp, \"ISA Plug & Play read data port\");\nmodule_param(isapnp_reset, int, 0);\nMODULE_PARM_DESC(isapnp_reset, \"ISA Plug & Play reset all cards\");\nmodule_param(isapnp_verbose, int, 0);\nMODULE_PARM_DESC(isapnp_verbose, \"ISA Plug & Play verbose mode\");\n\n#define _PIDXR\t\t0x279\n#define _PNPWRP\t\t0xa79\n\n \n#define _STAG_PNPVERNO\t\t0x01\n#define _STAG_LOGDEVID\t\t0x02\n#define _STAG_COMPATDEVID\t0x03\n#define _STAG_IRQ\t\t0x04\n#define _STAG_DMA\t\t0x05\n#define _STAG_STARTDEP\t\t0x06\n#define _STAG_ENDDEP\t\t0x07\n#define _STAG_IOPORT\t\t0x08\n#define _STAG_FIXEDIO\t\t0x09\n#define _STAG_VENDOR\t\t0x0e\n#define _STAG_END\t\t0x0f\n \n#define _LTAG_MEMRANGE\t\t0x81\n#define _LTAG_ANSISTR\t\t0x82\n#define _LTAG_UNICODESTR\t0x83\n#define _LTAG_VENDOR\t\t0x84\n#define _LTAG_MEM32RANGE\t0x85\n#define _LTAG_FIXEDMEM32RANGE\t0x86\n\n \n\n#define ISAPNP_CFG_ACTIVATE\t0x30\t \n#define ISAPNP_CFG_MEM\t\t0x40\t \n#define ISAPNP_CFG_PORT\t\t0x60\t \n#define ISAPNP_CFG_IRQ\t\t0x70\t \n#define ISAPNP_CFG_DMA\t\t0x74\t \n\n \n#define ISAPNP_MAX_MEM\t\t4\n#define ISAPNP_MAX_PORT\t\t8\n#define ISAPNP_MAX_IRQ\t\t2\n#define ISAPNP_MAX_DMA\t\t2\n\nstatic unsigned char isapnp_checksum_value;\nstatic DEFINE_MUTEX(isapnp_cfg_mutex);\nstatic int isapnp_csn_count;\n\n \n\nstatic inline void write_data(unsigned char x)\n{\n\toutb(x, _PNPWRP);\n}\n\nstatic inline void write_address(unsigned char x)\n{\n\toutb(x, _PIDXR);\n\tudelay(20);\n}\n\nstatic inline unsigned char read_data(void)\n{\n\tunsigned char val = inb(isapnp_rdp);\n\treturn val;\n}\n\nunsigned char isapnp_read_byte(unsigned char idx)\n{\n\twrite_address(idx);\n\treturn read_data();\n}\n\nstatic unsigned short isapnp_read_word(unsigned char idx)\n{\n\tunsigned short val;\n\n\tval = isapnp_read_byte(idx);\n\tval = (val << 8) + isapnp_read_byte(idx + 1);\n\treturn val;\n}\n\nvoid isapnp_write_byte(unsigned char idx, unsigned char val)\n{\n\twrite_address(idx);\n\twrite_data(val);\n}\n\nstatic void isapnp_write_word(unsigned char idx, unsigned short val)\n{\n\tisapnp_write_byte(idx, val >> 8);\n\tisapnp_write_byte(idx + 1, val);\n}\n\nstatic void isapnp_key(void)\n{\n\tunsigned char code = 0x6a, msb;\n\tint i;\n\n\tmdelay(1);\n\twrite_address(0x00);\n\twrite_address(0x00);\n\n\twrite_address(code);\n\n\tfor (i = 1; i < 32; i++) {\n\t\tmsb = ((code & 0x01) ^ ((code & 0x02) >> 1)) << 7;\n\t\tcode = (code >> 1) | msb;\n\t\twrite_address(code);\n\t}\n}\n\n \nstatic void isapnp_wait(void)\n{\n\tisapnp_write_byte(0x02, 0x02);\n}\n\nstatic void isapnp_wake(unsigned char csn)\n{\n\tisapnp_write_byte(0x03, csn);\n}\n\nstatic void isapnp_device(unsigned char logdev)\n{\n\tisapnp_write_byte(0x07, logdev);\n}\n\nstatic void isapnp_activate(unsigned char logdev)\n{\n\tisapnp_device(logdev);\n\tisapnp_write_byte(ISAPNP_CFG_ACTIVATE, 1);\n\tudelay(250);\n}\n\nstatic void isapnp_deactivate(unsigned char logdev)\n{\n\tisapnp_device(logdev);\n\tisapnp_write_byte(ISAPNP_CFG_ACTIVATE, 0);\n\tudelay(500);\n}\n\nstatic void __init isapnp_peek(unsigned char *data, int bytes)\n{\n\tint i, j;\n\tunsigned char d = 0;\n\n\tfor (i = 1; i <= bytes; i++) {\n\t\tfor (j = 0; j < 20; j++) {\n\t\t\td = isapnp_read_byte(0x05);\n\t\t\tif (d & 1)\n\t\t\t\tbreak;\n\t\t\tudelay(100);\n\t\t}\n\t\tif (!(d & 1)) {\n\t\t\tif (data != NULL)\n\t\t\t\t*data++ = 0xff;\n\t\t\tcontinue;\n\t\t}\n\t\td = isapnp_read_byte(0x04);\t \n\t\tisapnp_checksum_value += d;\n\t\tif (data != NULL)\n\t\t\t*data++ = d;\n\t}\n}\n\n#define RDP_STEP\t32\t \n\nstatic int isapnp_next_rdp(void)\n{\n\tint rdp = isapnp_rdp;\n\tstatic int old_rdp = 0;\n\n\tif (old_rdp) {\n\t\trelease_region(old_rdp, 1);\n\t\told_rdp = 0;\n\t}\n\twhile (rdp <= 0x3ff) {\n\t\t \n\t\tif ((rdp < 0x280 || rdp > 0x380)\n\t\t    && request_region(rdp, 1, \"ISAPnP\")) {\n\t\t\tisapnp_rdp = rdp;\n\t\t\told_rdp = rdp;\n\t\t\treturn 0;\n\t\t}\n\t\trdp += RDP_STEP;\n\t}\n\treturn -1;\n}\n\n \nstatic inline void isapnp_set_rdp(void)\n{\n\tisapnp_write_byte(0x00, isapnp_rdp >> 2);\n\tudelay(100);\n}\n\n \nstatic int __init isapnp_isolate_rdp_select(void)\n{\n\tisapnp_wait();\n\tisapnp_key();\n\n\t \n\tisapnp_write_byte(0x02, isapnp_reset ? 0x05 : 0x04);\n\tmdelay(2);\n\n\tisapnp_wait();\n\tisapnp_key();\n\tisapnp_wake(0x00);\n\n\tif (isapnp_next_rdp() < 0) {\n\t\tisapnp_wait();\n\t\treturn -1;\n\t}\n\n\tisapnp_set_rdp();\n\tudelay(1000);\n\twrite_address(0x01);\n\tudelay(1000);\n\treturn 0;\n}\n\n \nstatic int __init isapnp_isolate(void)\n{\n\tunsigned char checksum = 0x6a;\n\tunsigned char chksum = 0x00;\n\tunsigned char bit = 0x00;\n\tint data;\n\tint csn = 0;\n\tint i;\n\tint iteration = 1;\n\n\tisapnp_rdp = 0x213;\n\tif (isapnp_isolate_rdp_select() < 0)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tfor (i = 1; i <= 64; i++) {\n\t\t\tdata = read_data() << 8;\n\t\t\tudelay(250);\n\t\t\tdata = data | read_data();\n\t\t\tudelay(250);\n\t\t\tif (data == 0x55aa)\n\t\t\t\tbit = 0x01;\n\t\t\tchecksum =\n\t\t\t    ((((checksum ^ (checksum >> 1)) & 0x01) ^ bit) << 7)\n\t\t\t    | (checksum >> 1);\n\t\t\tbit = 0x00;\n\t\t}\n\t\tfor (i = 65; i <= 72; i++) {\n\t\t\tdata = read_data() << 8;\n\t\t\tudelay(250);\n\t\t\tdata = data | read_data();\n\t\t\tudelay(250);\n\t\t\tif (data == 0x55aa)\n\t\t\t\tchksum |= (1 << (i - 65));\n\t\t}\n\t\tif (checksum != 0x00 && checksum == chksum) {\n\t\t\tcsn++;\n\n\t\t\tisapnp_write_byte(0x06, csn);\n\t\t\tudelay(250);\n\t\t\titeration++;\n\t\t\tisapnp_wake(0x00);\n\t\t\tisapnp_set_rdp();\n\t\t\tudelay(1000);\n\t\t\twrite_address(0x01);\n\t\t\tudelay(1000);\n\t\t\tgoto __next;\n\t\t}\n\t\tif (iteration == 1) {\n\t\t\tisapnp_rdp += RDP_STEP;\n\t\t\tif (isapnp_isolate_rdp_select() < 0)\n\t\t\t\treturn -1;\n\t\t} else if (iteration > 1) {\n\t\t\tbreak;\n\t\t}\n__next:\n\t\tif (csn == 255)\n\t\t\tbreak;\n\t\tchecksum = 0x6a;\n\t\tchksum = 0x00;\n\t\tbit = 0x00;\n\t}\n\tisapnp_wait();\n\tisapnp_csn_count = csn;\n\treturn csn;\n}\n\n \nstatic int __init isapnp_read_tag(unsigned char *type, unsigned short *size)\n{\n\tunsigned char tag, tmp[2];\n\n\tisapnp_peek(&tag, 1);\n\tif (tag == 0)\t\t \n\t\treturn -1;\n\tif (tag & 0x80) {\t \n\t\t*type = tag;\n\t\tisapnp_peek(tmp, 2);\n\t\t*size = (tmp[1] << 8) | tmp[0];\n\t} else {\n\t\t*type = (tag >> 3) & 0x0f;\n\t\t*size = tag & 0x07;\n\t}\n\tif (*type == 0xff && *size == 0xffff)\t \n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic void __init isapnp_skip_bytes(int count)\n{\n\tisapnp_peek(NULL, count);\n}\n\n \nstatic struct pnp_dev *__init isapnp_parse_device(struct pnp_card *card,\n\t\t\t\t\t\t  int size, int number)\n{\n\tunsigned char tmp[6];\n\tstruct pnp_dev *dev;\n\tu32 eisa_id;\n\tchar id[8];\n\n\tisapnp_peek(tmp, size);\n\teisa_id = tmp[0] | tmp[1] << 8 | tmp[2] << 16 | tmp[3] << 24;\n\tpnp_eisa_id_to_string(eisa_id, id);\n\n\tdev = pnp_alloc_dev(&isapnp_protocol, number, id);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->card = card;\n\tdev->capabilities |= PNP_CONFIGURABLE;\n\tdev->capabilities |= PNP_READ;\n\tdev->capabilities |= PNP_WRITE;\n\tdev->capabilities |= PNP_DISABLE;\n\tpnp_init_resources(dev);\n\treturn dev;\n}\n\n \nstatic void __init isapnp_parse_irq_resource(struct pnp_dev *dev,\n\t\t\t\t\t     unsigned int option_flags,\n\t\t\t\t\t     int size)\n{\n\tunsigned char tmp[3];\n\tunsigned long bits;\n\tpnp_irq_mask_t map;\n\tunsigned char flags = IORESOURCE_IRQ_HIGHEDGE;\n\n\tisapnp_peek(tmp, size);\n\tbits = (tmp[1] << 8) | tmp[0];\n\n\tbitmap_zero(map.bits, PNP_IRQ_NR);\n\tbitmap_copy(map.bits, &bits, 16);\n\n\tif (size > 2)\n\t\tflags = tmp[2];\n\n\tpnp_register_irq_resource(dev, option_flags, &map, flags);\n}\n\n \nstatic void __init isapnp_parse_dma_resource(struct pnp_dev *dev,\n\t\t\t\t\t     unsigned int option_flags,\n\t\t\t\t\t     int size)\n{\n\tunsigned char tmp[2];\n\n\tisapnp_peek(tmp, size);\n\tpnp_register_dma_resource(dev, option_flags, tmp[0], tmp[1]);\n}\n\n \nstatic void __init isapnp_parse_port_resource(struct pnp_dev *dev,\n\t\t\t\t\t      unsigned int option_flags,\n\t\t\t\t\t      int size)\n{\n\tunsigned char tmp[7];\n\tresource_size_t min, max, align, len;\n\tunsigned char flags;\n\n\tisapnp_peek(tmp, size);\n\tmin = (tmp[2] << 8) | tmp[1];\n\tmax = (tmp[4] << 8) | tmp[3];\n\talign = tmp[5];\n\tlen = tmp[6];\n\tflags = tmp[0] ? IORESOURCE_IO_16BIT_ADDR : 0;\n\tpnp_register_port_resource(dev, option_flags,\n\t\t\t\t   min, max, align, len, flags);\n}\n\n \nstatic void __init isapnp_parse_fixed_port_resource(struct pnp_dev *dev,\n\t\t\t\t\t\t    unsigned int option_flags,\n\t\t\t\t\t\t    int size)\n{\n\tunsigned char tmp[3];\n\tresource_size_t base, len;\n\n\tisapnp_peek(tmp, size);\n\tbase = (tmp[1] << 8) | tmp[0];\n\tlen = tmp[2];\n\tpnp_register_port_resource(dev, option_flags, base, base, 0, len,\n\t\t\t\t   IORESOURCE_IO_FIXED);\n}\n\n \nstatic void __init isapnp_parse_mem_resource(struct pnp_dev *dev,\n\t\t\t\t\t     unsigned int option_flags,\n\t\t\t\t\t     int size)\n{\n\tunsigned char tmp[9];\n\tresource_size_t min, max, align, len;\n\tunsigned char flags;\n\n\tisapnp_peek(tmp, size);\n\tmin = ((tmp[2] << 8) | tmp[1]) << 8;\n\tmax = ((tmp[4] << 8) | tmp[3]) << 8;\n\talign = (tmp[6] << 8) | tmp[5];\n\tlen = ((tmp[8] << 8) | tmp[7]) << 8;\n\tflags = tmp[0];\n\tpnp_register_mem_resource(dev, option_flags,\n\t\t\t\t  min, max, align, len, flags);\n}\n\n \nstatic void __init isapnp_parse_mem32_resource(struct pnp_dev *dev,\n\t\t\t\t\t       unsigned int option_flags,\n\t\t\t\t\t       int size)\n{\n\tunsigned char tmp[17];\n\tresource_size_t min, max, align, len;\n\tunsigned char flags;\n\n\tisapnp_peek(tmp, size);\n\tmin = (tmp[4] << 24) | (tmp[3] << 16) | (tmp[2] << 8) | tmp[1];\n\tmax = (tmp[8] << 24) | (tmp[7] << 16) | (tmp[6] << 8) | tmp[5];\n\talign = (tmp[12] << 24) | (tmp[11] << 16) | (tmp[10] << 8) | tmp[9];\n\tlen = (tmp[16] << 24) | (tmp[15] << 16) | (tmp[14] << 8) | tmp[13];\n\tflags = tmp[0];\n\tpnp_register_mem_resource(dev, option_flags,\n\t\t\t\t  min, max, align, len, flags);\n}\n\n \nstatic void __init isapnp_parse_fixed_mem32_resource(struct pnp_dev *dev,\n\t\t\t\t\t\t     unsigned int option_flags,\n\t\t\t\t\t\t     int size)\n{\n\tunsigned char tmp[9];\n\tresource_size_t base, len;\n\tunsigned char flags;\n\n\tisapnp_peek(tmp, size);\n\tbase = (tmp[4] << 24) | (tmp[3] << 16) | (tmp[2] << 8) | tmp[1];\n\tlen = (tmp[8] << 24) | (tmp[7] << 16) | (tmp[6] << 8) | tmp[5];\n\tflags = tmp[0];\n\tpnp_register_mem_resource(dev, option_flags, base, base, 0, len, flags);\n}\n\n \nstatic void __init\nisapnp_parse_name(char *name, unsigned int name_max, unsigned short *size)\n{\n\tif (name[0] == '\\0') {\n\t\tunsigned short size1 =\n\t\t    *size >= name_max ? (name_max - 1) : *size;\n\t\tisapnp_peek(name, size1);\n\t\tname[size1] = '\\0';\n\t\t*size -= size1;\n\n\t\t \n\t\twhile (size1 > 0 && name[--size1] == ' ')\n\t\t\tname[size1] = '\\0';\n\t}\n}\n\n \nstatic int __init isapnp_create_device(struct pnp_card *card,\n\t\t\t\t       unsigned short size)\n{\n\tint number = 0, skip = 0, priority, compat = 0;\n\tunsigned char type, tmp[17];\n\tunsigned int option_flags;\n\tstruct pnp_dev *dev;\n\tu32 eisa_id;\n\tchar id[8];\n\n\tif ((dev = isapnp_parse_device(card, size, number++)) == NULL)\n\t\treturn 1;\n\toption_flags = 0;\n\tpnp_add_card_device(card, dev);\n\n\twhile (1) {\n\t\tif (isapnp_read_tag(&type, &size) < 0)\n\t\t\treturn 1;\n\t\tif (skip && type != _STAG_LOGDEVID && type != _STAG_END)\n\t\t\tgoto __skip;\n\t\tswitch (type) {\n\t\tcase _STAG_LOGDEVID:\n\t\t\tif (size >= 5 && size <= 6) {\n\t\t\t\tif ((dev =\n\t\t\t\t     isapnp_parse_device(card, size,\n\t\t\t\t\t\t\t number++)) == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tsize = 0;\n\t\t\t\tskip = 0;\n\t\t\t\toption_flags = 0;\n\t\t\t\tpnp_add_card_device(card, dev);\n\t\t\t} else {\n\t\t\t\tskip = 1;\n\t\t\t}\n\t\t\tcompat = 0;\n\t\t\tbreak;\n\t\tcase _STAG_COMPATDEVID:\n\t\t\tif (size == 4 && compat < DEVICE_COUNT_COMPATIBLE) {\n\t\t\t\tisapnp_peek(tmp, 4);\n\t\t\t\teisa_id = tmp[0] | tmp[1] << 8 |\n\t\t\t\t\t  tmp[2] << 16 | tmp[3] << 24;\n\t\t\t\tpnp_eisa_id_to_string(eisa_id, id);\n\t\t\t\tpnp_add_id(dev, id);\n\t\t\t\tcompat++;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase _STAG_IRQ:\n\t\t\tif (size < 2 || size > 3)\n\t\t\t\tgoto __skip;\n\t\t\tisapnp_parse_irq_resource(dev, option_flags, size);\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase _STAG_DMA:\n\t\t\tif (size != 2)\n\t\t\t\tgoto __skip;\n\t\t\tisapnp_parse_dma_resource(dev, option_flags, size);\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase _STAG_STARTDEP:\n\t\t\tif (size > 1)\n\t\t\t\tgoto __skip;\n\t\t\tpriority = PNP_RES_PRIORITY_ACCEPTABLE;\n\t\t\tif (size > 0) {\n\t\t\t\tisapnp_peek(tmp, size);\n\t\t\t\tpriority = tmp[0];\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\toption_flags = pnp_new_dependent_set(dev, priority);\n\t\t\tbreak;\n\t\tcase _STAG_ENDDEP:\n\t\t\tif (size != 0)\n\t\t\t\tgoto __skip;\n\t\t\toption_flags = 0;\n\t\t\tbreak;\n\t\tcase _STAG_IOPORT:\n\t\t\tif (size != 7)\n\t\t\t\tgoto __skip;\n\t\t\tisapnp_parse_port_resource(dev, option_flags, size);\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase _STAG_FIXEDIO:\n\t\t\tif (size != 3)\n\t\t\t\tgoto __skip;\n\t\t\tisapnp_parse_fixed_port_resource(dev, option_flags,\n\t\t\t\t\t\t\t size);\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase _STAG_VENDOR:\n\t\t\tbreak;\n\t\tcase _LTAG_MEMRANGE:\n\t\t\tif (size != 9)\n\t\t\t\tgoto __skip;\n\t\t\tisapnp_parse_mem_resource(dev, option_flags, size);\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase _LTAG_ANSISTR:\n\t\t\tisapnp_parse_name(dev->name, sizeof(dev->name), &size);\n\t\t\tbreak;\n\t\tcase _LTAG_UNICODESTR:\n\t\t\t \n\t\t\t \n\t\t\tbreak;\n\t\tcase _LTAG_VENDOR:\n\t\t\tbreak;\n\t\tcase _LTAG_MEM32RANGE:\n\t\t\tif (size != 17)\n\t\t\t\tgoto __skip;\n\t\t\tisapnp_parse_mem32_resource(dev, option_flags, size);\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase _LTAG_FIXEDMEM32RANGE:\n\t\t\tif (size != 9)\n\t\t\t\tgoto __skip;\n\t\t\tisapnp_parse_fixed_mem32_resource(dev, option_flags,\n\t\t\t\t\t\t\t  size);\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase _STAG_END:\n\t\t\tif (size > 0)\n\t\t\t\tisapnp_skip_bytes(size);\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tdev_err(&dev->dev, \"unknown tag %#x (card %i), \"\n\t\t\t\t\"ignored\\n\", type, card->number);\n\t\t}\n__skip:\n\t\tif (size > 0)\n\t\t\tisapnp_skip_bytes(size);\n\t}\n\treturn 0;\n}\n\n \nstatic void __init isapnp_parse_resource_map(struct pnp_card *card)\n{\n\tunsigned char type, tmp[17];\n\tunsigned short size;\n\n\twhile (1) {\n\t\tif (isapnp_read_tag(&type, &size) < 0)\n\t\t\treturn;\n\t\tswitch (type) {\n\t\tcase _STAG_PNPVERNO:\n\t\t\tif (size != 2)\n\t\t\t\tgoto __skip;\n\t\t\tisapnp_peek(tmp, 2);\n\t\t\tcard->pnpver = tmp[0];\n\t\t\tcard->productver = tmp[1];\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase _STAG_LOGDEVID:\n\t\t\tif (size >= 5 && size <= 6) {\n\t\t\t\tif (isapnp_create_device(card, size) == 1)\n\t\t\t\t\treturn;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase _STAG_VENDOR:\n\t\t\tbreak;\n\t\tcase _LTAG_ANSISTR:\n\t\t\tisapnp_parse_name(card->name, sizeof(card->name),\n\t\t\t\t\t  &size);\n\t\t\tbreak;\n\t\tcase _LTAG_UNICODESTR:\n\t\t\t \n\t\t\t \n\t\t\tbreak;\n\t\tcase _LTAG_VENDOR:\n\t\t\tbreak;\n\t\tcase _STAG_END:\n\t\t\tif (size > 0)\n\t\t\t\tisapnp_skip_bytes(size);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tdev_err(&card->dev, \"unknown tag %#x, ignored\\n\",\n\t\t\t       type);\n\t\t}\n__skip:\n\t\tif (size > 0)\n\t\t\tisapnp_skip_bytes(size);\n\t}\n}\n\n \nstatic int __init isapnp_build_device_list(void)\n{\n\tint csn;\n\tunsigned char header[9];\n\tstruct pnp_card *card;\n\tu32 eisa_id;\n\tchar id[8];\n\n\tisapnp_wait();\n\tisapnp_key();\n\tfor (csn = 1; csn <= isapnp_csn_count; csn++) {\n\t\tisapnp_wake(csn);\n\t\tisapnp_peek(header, 9);\n\t\teisa_id = header[0] | header[1] << 8 |\n\t\t\t  header[2] << 16 | header[3] << 24;\n\t\tpnp_eisa_id_to_string(eisa_id, id);\n\t\tcard = pnp_alloc_card(&isapnp_protocol, csn, id);\n\t\tif (!card)\n\t\t\tcontinue;\n\n\t\tINIT_LIST_HEAD(&card->devices);\n\t\tcard->serial =\n\t\t    (header[7] << 24) | (header[6] << 16) | (header[5] << 8) |\n\t\t    header[4];\n\t\tisapnp_checksum_value = 0x00;\n\t\tisapnp_parse_resource_map(card);\n\t\tif (isapnp_checksum_value != 0x00)\n\t\t\tdev_err(&card->dev, \"invalid checksum %#x\\n\",\n\t\t\t\tisapnp_checksum_value);\n\t\tcard->checksum = isapnp_checksum_value;\n\n\t\tpnp_add_card(card);\n\t}\n\tisapnp_wait();\n\treturn 0;\n}\n\n \n\nint isapnp_present(void)\n{\n\tstruct pnp_card *card;\n\n\tpnp_for_each_card(card) {\n\t\tif (card->protocol == &isapnp_protocol)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint isapnp_cfg_begin(int csn, int logdev)\n{\n\tif (csn < 1 || csn > isapnp_csn_count || logdev > 10)\n\t\treturn -EINVAL;\n\tmutex_lock(&isapnp_cfg_mutex);\n\tisapnp_wait();\n\tisapnp_key();\n\tisapnp_wake(csn);\n#if 0\n\t \n\t \n\t \n\t \n\tisapnp_write_byte(0x02, 0x04);\t \n\tmdelay(2);\t\t \n\tisapnp_wake(csn);\t \n\tisapnp_wake(0);\t\t \n\tisapnp_set_rdp();\t \n\tudelay(1000);\t\t \n\tisapnp_write_byte(0x06, csn);\t \n\tudelay(250);\t\t \n#endif\n\tif (logdev >= 0)\n\t\tisapnp_device(logdev);\n\treturn 0;\n}\n\nint isapnp_cfg_end(void)\n{\n\tisapnp_wait();\n\tmutex_unlock(&isapnp_cfg_mutex);\n\treturn 0;\n}\n\n \n\nEXPORT_SYMBOL(isapnp_protocol);\nEXPORT_SYMBOL(isapnp_present);\nEXPORT_SYMBOL(isapnp_cfg_begin);\nEXPORT_SYMBOL(isapnp_cfg_end);\nEXPORT_SYMBOL(isapnp_write_byte);\n\nstatic int isapnp_get_resources(struct pnp_dev *dev)\n{\n\tint i, ret;\n\n\tpnp_dbg(&dev->dev, \"get resources\\n\");\n\tpnp_init_resources(dev);\n\tisapnp_cfg_begin(dev->card->number, dev->number);\n\tdev->active = isapnp_read_byte(ISAPNP_CFG_ACTIVATE);\n\tif (!dev->active)\n\t\tgoto __end;\n\n\tfor (i = 0; i < ISAPNP_MAX_PORT; i++) {\n\t\tret = isapnp_read_word(ISAPNP_CFG_PORT + (i << 1));\n\t\tpnp_add_io_resource(dev, ret, ret,\n\t\t\t\t    ret == 0 ? IORESOURCE_DISABLED : 0);\n\t}\n\tfor (i = 0; i < ISAPNP_MAX_MEM; i++) {\n\t\tret = isapnp_read_word(ISAPNP_CFG_MEM + (i << 3)) << 8;\n\t\tpnp_add_mem_resource(dev, ret, ret,\n\t\t\t\t     ret == 0 ? IORESOURCE_DISABLED : 0);\n\t}\n\tfor (i = 0; i < ISAPNP_MAX_IRQ; i++) {\n\t\tret = isapnp_read_word(ISAPNP_CFG_IRQ + (i << 1)) >> 8;\n\t\tpnp_add_irq_resource(dev, ret,\n\t\t\t\t     ret == 0 ? IORESOURCE_DISABLED : 0);\n\t}\n\tfor (i = 0; i < ISAPNP_MAX_DMA; i++) {\n\t\tret = isapnp_read_byte(ISAPNP_CFG_DMA + i);\n\t\tpnp_add_dma_resource(dev, ret,\n\t\t\t\t     ret == 4 ? IORESOURCE_DISABLED : 0);\n\t}\n\n__end:\n\tisapnp_cfg_end();\n\treturn 0;\n}\n\nstatic int isapnp_set_resources(struct pnp_dev *dev)\n{\n\tstruct resource *res;\n\tint tmp;\n\n\tpnp_dbg(&dev->dev, \"set resources\\n\");\n\tisapnp_cfg_begin(dev->card->number, dev->number);\n\tdev->active = 1;\n\tfor (tmp = 0; tmp < ISAPNP_MAX_PORT; tmp++) {\n\t\tres = pnp_get_resource(dev, IORESOURCE_IO, tmp);\n\t\tif (pnp_resource_enabled(res)) {\n\t\t\tpnp_dbg(&dev->dev, \"  set io  %d to %#llx\\n\",\n\t\t\t\ttmp, (unsigned long long) res->start);\n\t\t\tisapnp_write_word(ISAPNP_CFG_PORT + (tmp << 1),\n\t\t\t\t\t  res->start);\n\t\t}\n\t}\n\tfor (tmp = 0; tmp < ISAPNP_MAX_IRQ; tmp++) {\n\t\tres = pnp_get_resource(dev, IORESOURCE_IRQ, tmp);\n\t\tif (pnp_resource_enabled(res)) {\n\t\t\tint irq = res->start;\n\t\t\tif (irq == 2)\n\t\t\t\tirq = 9;\n\t\t\tpnp_dbg(&dev->dev, \"  set irq %d to %d\\n\", tmp, irq);\n\t\t\tisapnp_write_byte(ISAPNP_CFG_IRQ + (tmp << 1), irq);\n\t\t}\n\t}\n\tfor (tmp = 0; tmp < ISAPNP_MAX_DMA; tmp++) {\n\t\tres = pnp_get_resource(dev, IORESOURCE_DMA, tmp);\n\t\tif (pnp_resource_enabled(res)) {\n\t\t\tpnp_dbg(&dev->dev, \"  set dma %d to %lld\\n\",\n\t\t\t\ttmp, (unsigned long long) res->start);\n\t\t\tisapnp_write_byte(ISAPNP_CFG_DMA + tmp, res->start);\n\t\t}\n\t}\n\tfor (tmp = 0; tmp < ISAPNP_MAX_MEM; tmp++) {\n\t\tres = pnp_get_resource(dev, IORESOURCE_MEM, tmp);\n\t\tif (pnp_resource_enabled(res)) {\n\t\t\tpnp_dbg(&dev->dev, \"  set mem %d to %#llx\\n\",\n\t\t\t\ttmp, (unsigned long long) res->start);\n\t\t\tisapnp_write_word(ISAPNP_CFG_MEM + (tmp << 3),\n\t\t\t\t\t  (res->start >> 8) & 0xffff);\n\t\t}\n\t}\n\t \n\tisapnp_activate(dev->number);\n\tisapnp_cfg_end();\n\treturn 0;\n}\n\nstatic int isapnp_disable_resources(struct pnp_dev *dev)\n{\n\tif (!dev->active)\n\t\treturn -EINVAL;\n\tisapnp_cfg_begin(dev->card->number, dev->number);\n\tisapnp_deactivate(dev->number);\n\tdev->active = 0;\n\tisapnp_cfg_end();\n\treturn 0;\n}\n\nstruct pnp_protocol isapnp_protocol = {\n\t.name = \"ISA Plug and Play\",\n\t.get = isapnp_get_resources,\n\t.set = isapnp_set_resources,\n\t.disable = isapnp_disable_resources,\n};\n\nstatic int __init isapnp_init(void)\n{\n\tint cards;\n\tstruct pnp_card *card;\n\tstruct pnp_dev *dev;\n\n\tif (isapnp_disable) {\n\t\tprintk(KERN_INFO \"isapnp: ISA Plug & Play support disabled\\n\");\n\t\treturn 0;\n\t}\n#ifdef CONFIG_PPC\n\tif (check_legacy_ioport(_PIDXR) || check_legacy_ioport(_PNPWRP))\n\t\treturn -EINVAL;\n#endif\n#ifdef ISAPNP_REGION_OK\n\tif (!request_region(_PIDXR, 1, \"isapnp index\")) {\n\t\tprintk(KERN_ERR \"isapnp: Index Register 0x%x already used\\n\",\n\t\t       _PIDXR);\n\t\treturn -EBUSY;\n\t}\n#endif\n\tif (!request_region(_PNPWRP, 1, \"isapnp write\")) {\n\t\tprintk(KERN_ERR\n\t\t       \"isapnp: Write Data Register 0x%x already used\\n\",\n\t\t       _PNPWRP);\n#ifdef ISAPNP_REGION_OK\n\t\trelease_region(_PIDXR, 1);\n#endif\n\t\treturn -EBUSY;\n\t}\n\n\tif (pnp_register_protocol(&isapnp_protocol) < 0)\n\t\treturn -EBUSY;\n\n\t \n\n\tprintk(KERN_INFO \"isapnp: Scanning for PnP cards...\\n\");\n\tif (isapnp_rdp >= 0x203 && isapnp_rdp <= 0x3ff) {\n\t\tisapnp_rdp |= 3;\n\t\tif (!request_region(isapnp_rdp, 1, \"isapnp read\")) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"isapnp: Read Data Register 0x%x already used\\n\",\n\t\t\t       isapnp_rdp);\n#ifdef ISAPNP_REGION_OK\n\t\t\trelease_region(_PIDXR, 1);\n#endif\n\t\t\trelease_region(_PNPWRP, 1);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tisapnp_set_rdp();\n\t}\n\tif (isapnp_rdp < 0x203 || isapnp_rdp > 0x3ff) {\n\t\tcards = isapnp_isolate();\n\t\tif (cards < 0 || (isapnp_rdp < 0x203 || isapnp_rdp > 0x3ff)) {\n#ifdef ISAPNP_REGION_OK\n\t\t\trelease_region(_PIDXR, 1);\n#endif\n\t\t\trelease_region(_PNPWRP, 1);\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"isapnp: No Plug & Play device found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\trequest_region(isapnp_rdp, 1, \"isapnp read\");\n\t}\n\tisapnp_build_device_list();\n\tcards = 0;\n\n\tprotocol_for_each_card(&isapnp_protocol, card) {\n\t\tcards++;\n\t\tif (isapnp_verbose) {\n\t\t\tdev_info(&card->dev, \"card '%s'\\n\",\n\t\t\t       card->name[0] ? card->name : \"unknown\");\n\t\t\tif (isapnp_verbose < 2)\n\t\t\t\tcontinue;\n\t\t\tcard_for_each_dev(card, dev) {\n\t\t\t\tdev_info(&card->dev, \"device '%s'\\n\",\n\t\t\t\t       dev->name[0] ? dev->name : \"unknown\");\n\t\t\t}\n\t\t}\n\t}\n\tif (cards)\n\t\tprintk(KERN_INFO\n\t\t       \"isapnp: %i Plug & Play card%s detected total\\n\", cards,\n\t\t       cards > 1 ? \"s\" : \"\");\n\telse\n\t\tprintk(KERN_INFO \"isapnp: No Plug & Play card found\\n\");\n\n\tisapnp_proc_init();\n\treturn 0;\n}\n\ndevice_initcall(isapnp_init);\n\n \n\nstatic int __init isapnp_setup_disable(char *str)\n{\n\tisapnp_disable = 1;\n\treturn 1;\n}\n\n__setup(\"noisapnp\", isapnp_setup_disable);\n\n \n\nstatic int __init isapnp_setup_isapnp(char *str)\n{\n\t(void)((get_option(&str, &isapnp_rdp) == 2) &&\n\t       (get_option(&str, &isapnp_reset) == 2) &&\n\t       (get_option(&str, &isapnp_verbose) == 2));\n\treturn 1;\n}\n\n__setup(\"isapnp=\", isapnp_setup_isapnp);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}