{
  "module_name": "core.c",
  "hash_id": "72abc0a232dc57af3d5d9bbb992e080c2483d08850bc65c0b059c5a10bac13d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/core.c",
  "human_readable_source": "\n \n\n#include <linux/pnp.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/dma-mapping.h>\n\n#include \"base.h\"\n\nstatic LIST_HEAD(pnp_protocols);\nLIST_HEAD(pnp_global);\nDEFINE_MUTEX(pnp_lock);\n\n \nint pnp_platform_devices;\nEXPORT_SYMBOL(pnp_platform_devices);\n\nstatic void pnp_remove_protocol(struct pnp_protocol *protocol)\n{\n\tmutex_lock(&pnp_lock);\n\tlist_del(&protocol->protocol_list);\n\tmutex_unlock(&pnp_lock);\n}\n\n \nint pnp_register_protocol(struct pnp_protocol *protocol)\n{\n\tstruct list_head *pos;\n\tint nodenum, ret;\n\n\tINIT_LIST_HEAD(&protocol->devices);\n\tINIT_LIST_HEAD(&protocol->cards);\n\tnodenum = 0;\n\n\tmutex_lock(&pnp_lock);\n\n\t \n\tlist_for_each(pos, &pnp_protocols) {\n\t\tstruct pnp_protocol *cur = to_pnp_protocol(pos);\n\t\tif (cur->number == nodenum) {\n\t\t\tpos = &pnp_protocols;\n\t\t\tnodenum++;\n\t\t}\n\t}\n\n\tprotocol->number = nodenum;\n\tdev_set_name(&protocol->dev, \"pnp%d\", nodenum);\n\n\tlist_add_tail(&protocol->protocol_list, &pnp_protocols);\n\n\tmutex_unlock(&pnp_lock);\n\n\tret = device_register(&protocol->dev);\n\tif (ret)\n\t\tpnp_remove_protocol(protocol);\n\n\treturn ret;\n}\n\n \nvoid pnp_unregister_protocol(struct pnp_protocol *protocol)\n{\n\tpnp_remove_protocol(protocol);\n\tdevice_unregister(&protocol->dev);\n}\n\nstatic void pnp_free_ids(struct pnp_dev *dev)\n{\n\tstruct pnp_id *id;\n\tstruct pnp_id *next;\n\n\tid = dev->id;\n\twhile (id) {\n\t\tnext = id->next;\n\t\tkfree(id);\n\t\tid = next;\n\t}\n}\n\nvoid pnp_free_resource(struct pnp_resource *pnp_res)\n{\n\tlist_del(&pnp_res->list);\n\tkfree(pnp_res);\n}\n\nvoid pnp_free_resources(struct pnp_dev *dev)\n{\n\tstruct pnp_resource *pnp_res, *tmp;\n\n\tlist_for_each_entry_safe(pnp_res, tmp, &dev->resources, list) {\n\t\tpnp_free_resource(pnp_res);\n\t}\n}\n\nstatic void pnp_release_device(struct device *dmdev)\n{\n\tstruct pnp_dev *dev = to_pnp_dev(dmdev);\n\n\tpnp_free_ids(dev);\n\tpnp_free_resources(dev);\n\tpnp_free_options(dev);\n\tkfree(dev);\n}\n\nstruct pnp_dev *pnp_alloc_dev(struct pnp_protocol *protocol, int id,\n\t\t\t      const char *pnpid)\n{\n\tstruct pnp_dev *dev;\n\tstruct pnp_id *dev_id;\n\n\tdev = kzalloc(sizeof(struct pnp_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&dev->resources);\n\tINIT_LIST_HEAD(&dev->options);\n\tdev->protocol = protocol;\n\tdev->number = id;\n\tdev->dma_mask = DMA_BIT_MASK(24);\n\n\tdev->dev.parent = &dev->protocol->dev;\n\tdev->dev.bus = &pnp_bus_type;\n\tdev->dev.dma_mask = &dev->dma_mask;\n\tdev->dev.coherent_dma_mask = dev->dma_mask;\n\tdev->dev.release = &pnp_release_device;\n\n\tdev_id = pnp_add_id(dev, pnpid);\n\tif (!dev_id) {\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\n\tdev_set_name(&dev->dev, \"%02x:%02x\", dev->protocol->number, dev->number);\n\n\treturn dev;\n}\n\nstatic void pnp_delist_device(struct pnp_dev *dev)\n{\n\tmutex_lock(&pnp_lock);\n\tlist_del(&dev->global_list);\n\tlist_del(&dev->protocol_list);\n\tmutex_unlock(&pnp_lock);\n}\n\nint __pnp_add_device(struct pnp_dev *dev)\n{\n\tint ret;\n\n\tpnp_fixup_device(dev);\n\tdev->status = PNP_READY;\n\n\tmutex_lock(&pnp_lock);\n\n\tlist_add_tail(&dev->global_list, &pnp_global);\n\tlist_add_tail(&dev->protocol_list, &dev->protocol->devices);\n\n\tmutex_unlock(&pnp_lock);\n\n\tret = device_register(&dev->dev);\n\tif (ret)\n\t\tpnp_delist_device(dev);\n\telse if (dev->protocol->can_wakeup)\n\t\tdevice_set_wakeup_capable(&dev->dev,\n\t\t\t\tdev->protocol->can_wakeup(dev));\n\n\treturn ret;\n}\n\n \nint pnp_add_device(struct pnp_dev *dev)\n{\n\tint ret;\n\tchar buf[128];\n\tint len = 0;\n\tstruct pnp_id *id;\n\n\tif (dev->card)\n\t\treturn -EINVAL;\n\n\tret = __pnp_add_device(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf[0] = '\\0';\n\tfor (id = dev->id; id; id = id->next)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" %s\", id->id);\n\n\tdev_dbg(&dev->dev, \"%s device, IDs%s (%s)\\n\", dev->protocol->name, buf,\n\t\tdev->active ? \"active\" : \"disabled\");\n\treturn 0;\n}\n\nvoid __pnp_remove_device(struct pnp_dev *dev)\n{\n\tpnp_delist_device(dev);\n\tdevice_unregister(&dev->dev);\n}\n\nstatic int __init pnp_init(void)\n{\n\treturn bus_register(&pnp_bus_type);\n}\n\nsubsys_initcall(pnp_init);\n\nint pnp_debug;\n\n#if defined(CONFIG_PNP_DEBUG_MESSAGES)\nmodule_param_named(debug, pnp_debug, int, 0644);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}