{
  "module_name": "card.c",
  "hash_id": "e54b588e7c855eeb6b137e5a0b8f17820d127ba483e3a85fe1a24c85fac46fc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/card.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/pnp.h>\n#include <linux/dma-mapping.h>\n#include \"base.h\"\n\nLIST_HEAD(pnp_cards);\nstatic LIST_HEAD(pnp_card_drivers);\n\nstatic const struct pnp_card_device_id *match_card(struct pnp_card_driver *drv,\n\t\t\t\t\t\t   struct pnp_card *card)\n{\n\tconst struct pnp_card_device_id *drv_id = drv->id_table;\n\n\twhile (*drv_id->id) {\n\t\tif (compare_pnp_id(card->id, drv_id->id)) {\n\t\t\tint i = 0;\n\n\t\t\tfor (;;) {\n\t\t\t\tint found;\n\t\t\t\tstruct pnp_dev *dev;\n\n\t\t\t\tif (i == PNP_MAX_DEVICES ||\n\t\t\t\t    !*drv_id->devs[i].id)\n\t\t\t\t\treturn drv_id;\n\t\t\t\tfound = 0;\n\t\t\t\tcard_for_each_dev(card, dev) {\n\t\t\t\t\tif (compare_pnp_id(dev->id,\n\t\t\t\t\t\t   drv_id->devs[i].id)) {\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found)\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tdrv_id++;\n\t}\n\treturn NULL;\n}\n\nstatic void card_remove(struct pnp_dev *dev)\n{\n\tdev->card_link = NULL;\n}\n\nstatic void card_remove_first(struct pnp_dev *dev)\n{\n\tstruct pnp_card_driver *drv = to_pnp_card_driver(dev->driver);\n\n\tif (!dev->card || !drv)\n\t\treturn;\n\tif (drv->remove)\n\t\tdrv->remove(dev->card_link);\n\tdrv->link.remove = &card_remove;\n\tkfree(dev->card_link);\n\tcard_remove(dev);\n}\n\nstatic int card_probe(struct pnp_card *card, struct pnp_card_driver *drv)\n{\n\tconst struct pnp_card_device_id *id;\n\tstruct pnp_card_link *clink;\n\tstruct pnp_dev *dev;\n\n\tif (!drv->probe)\n\t\treturn 0;\n\tid = match_card(drv, card);\n\tif (!id)\n\t\treturn 0;\n\n\tclink = kzalloc(sizeof(*clink), GFP_KERNEL);\n\tif (!clink)\n\t\treturn 0;\n\tclink->card = card;\n\tclink->driver = drv;\n\tclink->pm_state = PMSG_ON;\n\n\tif (drv->probe(clink, id) >= 0)\n\t\treturn 1;\n\n\t \n\tcard_for_each_dev(card, dev) {\n\t\tif (dev->card_link == clink)\n\t\t\tpnp_release_card_device(dev);\n\t}\n\tkfree(clink);\n\treturn 0;\n}\n\n \nstatic struct pnp_id *pnp_add_card_id(struct pnp_card *card, char *id)\n{\n\tstruct pnp_id *dev_id, *ptr;\n\n\tdev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);\n\tif (!dev_id)\n\t\treturn NULL;\n\n\tdev_id->id[0] = id[0];\n\tdev_id->id[1] = id[1];\n\tdev_id->id[2] = id[2];\n\tdev_id->id[3] = tolower(id[3]);\n\tdev_id->id[4] = tolower(id[4]);\n\tdev_id->id[5] = tolower(id[5]);\n\tdev_id->id[6] = tolower(id[6]);\n\tdev_id->id[7] = '\\0';\n\n\tdev_id->next = NULL;\n\tptr = card->id;\n\twhile (ptr && ptr->next)\n\t\tptr = ptr->next;\n\tif (ptr)\n\t\tptr->next = dev_id;\n\telse\n\t\tcard->id = dev_id;\n\n\treturn dev_id;\n}\n\nstatic void pnp_free_card_ids(struct pnp_card *card)\n{\n\tstruct pnp_id *id;\n\tstruct pnp_id *next;\n\n\tid = card->id;\n\twhile (id) {\n\t\tnext = id->next;\n\t\tkfree(id);\n\t\tid = next;\n\t}\n}\n\nstatic void pnp_release_card(struct device *dmdev)\n{\n\tstruct pnp_card *card = to_pnp_card(dmdev);\n\n\tpnp_free_card_ids(card);\n\tkfree(card);\n}\n\nstruct pnp_card *pnp_alloc_card(struct pnp_protocol *protocol, int id, char *pnpid)\n{\n\tstruct pnp_card *card;\n\tstruct pnp_id *dev_id;\n\n\tcard = kzalloc(sizeof(struct pnp_card), GFP_KERNEL);\n\tif (!card)\n\t\treturn NULL;\n\n\tcard->protocol = protocol;\n\tcard->number = id;\n\n\tcard->dev.parent = &card->protocol->dev;\n\tdev_set_name(&card->dev, \"%02x:%02x\", card->protocol->number, card->number);\n\n\tcard->dev.coherent_dma_mask = DMA_BIT_MASK(24);\n\tcard->dev.dma_mask = &card->dev.coherent_dma_mask;\n\n\tdev_id = pnp_add_card_id(card, pnpid);\n\tif (!dev_id) {\n\t\tkfree(card);\n\t\treturn NULL;\n\t}\n\n\treturn card;\n}\n\nstatic ssize_t name_show(struct device *dmdev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tchar *str = buf;\n\tstruct pnp_card *card = to_pnp_card(dmdev);\n\n\tstr += sprintf(str, \"%s\\n\", card->name);\n\treturn (str - buf);\n}\n\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t card_id_show(struct device *dmdev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tchar *str = buf;\n\tstruct pnp_card *card = to_pnp_card(dmdev);\n\tstruct pnp_id *pos = card->id;\n\n\twhile (pos) {\n\t\tstr += sprintf(str, \"%s\\n\", pos->id);\n\t\tpos = pos->next;\n\t}\n\treturn (str - buf);\n}\n\nstatic DEVICE_ATTR_RO(card_id);\n\nstatic int pnp_interface_attach_card(struct pnp_card *card)\n{\n\tint rc = device_create_file(&card->dev, &dev_attr_name);\n\n\tif (rc)\n\t\treturn rc;\n\n\trc = device_create_file(&card->dev, &dev_attr_card_id);\n\tif (rc)\n\t\tgoto err_name;\n\n\treturn 0;\n\nerr_name:\n\tdevice_remove_file(&card->dev, &dev_attr_name);\n\treturn rc;\n}\n\n \nint pnp_add_card(struct pnp_card *card)\n{\n\tint error;\n\tstruct list_head *pos, *temp;\n\n\tcard->dev.bus = NULL;\n\tcard->dev.release = &pnp_release_card;\n\terror = device_register(&card->dev);\n\tif (error) {\n\t\tdev_err(&card->dev, \"could not register (err=%d)\\n\", error);\n\t\tput_device(&card->dev);\n\t\treturn error;\n\t}\n\n\tpnp_interface_attach_card(card);\n\tmutex_lock(&pnp_lock);\n\tlist_add_tail(&card->global_list, &pnp_cards);\n\tlist_add_tail(&card->protocol_list, &card->protocol->cards);\n\tmutex_unlock(&pnp_lock);\n\n\t \n\tlist_for_each(pos, &card->devices) {\n\t\tstruct pnp_dev *dev = card_to_pnp_dev(pos);\n\t\t__pnp_add_device(dev);\n\t}\n\n\t \n\tlist_for_each_safe(pos, temp, &pnp_card_drivers) {\n\t\tstruct pnp_card_driver *drv =\n\t\t    list_entry(pos, struct pnp_card_driver,\n\t\t\t       global_list);\n\t\tcard_probe(card, drv);\n\t}\n\treturn 0;\n}\n\n \nvoid pnp_remove_card(struct pnp_card *card)\n{\n\tstruct list_head *pos, *temp;\n\n\tdevice_unregister(&card->dev);\n\tmutex_lock(&pnp_lock);\n\tlist_del(&card->global_list);\n\tlist_del(&card->protocol_list);\n\tmutex_unlock(&pnp_lock);\n\tlist_for_each_safe(pos, temp, &card->devices) {\n\t\tstruct pnp_dev *dev = card_to_pnp_dev(pos);\n\t\tpnp_remove_card_device(dev);\n\t}\n}\n\n \nint pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev)\n{\n\tdev->dev.parent = &card->dev;\n\tdev->card_link = NULL;\n\tdev_set_name(&dev->dev, \"%02x:%02x.%02x\",\n\t\t     dev->protocol->number, card->number, dev->number);\n\tmutex_lock(&pnp_lock);\n\tdev->card = card;\n\tlist_add_tail(&dev->card_list, &card->devices);\n\tmutex_unlock(&pnp_lock);\n\treturn 0;\n}\n\n \nvoid pnp_remove_card_device(struct pnp_dev *dev)\n{\n\tmutex_lock(&pnp_lock);\n\tdev->card = NULL;\n\tlist_del(&dev->card_list);\n\tmutex_unlock(&pnp_lock);\n\t__pnp_remove_device(dev);\n}\n\n \nstruct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink,\n\t\t\t\t\tconst char *id, struct pnp_dev *from)\n{\n\tstruct list_head *pos;\n\tstruct pnp_dev *dev;\n\tstruct pnp_card_driver *drv;\n\tstruct pnp_card *card;\n\n\tif (!clink || !id)\n\t\treturn NULL;\n\n\tcard = clink->card;\n\tdrv = clink->driver;\n\tif (!from) {\n\t\tpos = card->devices.next;\n\t} else {\n\t\tif (from->card != card)\n\t\t\treturn NULL;\n\t\tpos = from->card_list.next;\n\t}\n\twhile (pos != &card->devices) {\n\t\tdev = card_to_pnp_dev(pos);\n\t\tif ((!dev->card_link) && compare_pnp_id(dev->id, id))\n\t\t\tgoto found;\n\t\tpos = pos->next;\n\t}\n\n\treturn NULL;\n\nfound:\n\tdev->card_link = clink;\n\tdev->dev.driver = &drv->link.driver;\n\tif (pnp_bus_type.probe(&dev->dev))\n\t\tgoto err_out;\n\tif (device_bind_driver(&dev->dev))\n\t\tgoto err_out;\n\n\treturn dev;\n\nerr_out:\n\tdev->dev.driver = NULL;\n\tdev->card_link = NULL;\n\treturn NULL;\n}\nEXPORT_SYMBOL(pnp_request_card_device);\n\n \nvoid pnp_release_card_device(struct pnp_dev *dev)\n{\n\tstruct pnp_card_driver *drv = dev->card_link->driver;\n\n\tdrv->link.remove = &card_remove;\n\tdevice_release_driver(&dev->dev);\n\tdrv->link.remove = &card_remove_first;\n}\nEXPORT_SYMBOL(pnp_release_card_device);\n\n \nstatic int card_suspend(struct pnp_dev *dev, pm_message_t state)\n{\n\tstruct pnp_card_link *link = dev->card_link;\n\n\tif (link->pm_state.event == state.event)\n\t\treturn 0;\n\tlink->pm_state = state;\n\treturn link->driver->suspend(link, state);\n}\n\nstatic int card_resume(struct pnp_dev *dev)\n{\n\tstruct pnp_card_link *link = dev->card_link;\n\n\tif (link->pm_state.event == PM_EVENT_ON)\n\t\treturn 0;\n\tlink->pm_state = PMSG_ON;\n\tlink->driver->resume(link);\n\treturn 0;\n}\n\n \nint pnp_register_card_driver(struct pnp_card_driver *drv)\n{\n\tint error;\n\tstruct list_head *pos, *temp;\n\n\tdrv->link.name = drv->name;\n\tdrv->link.id_table = NULL;\t \n\tdrv->link.flags = drv->flags;\n\tdrv->link.probe = NULL;\n\tdrv->link.remove = &card_remove_first;\n\tdrv->link.suspend = drv->suspend ? card_suspend : NULL;\n\tdrv->link.resume = drv->resume ? card_resume : NULL;\n\n\terror = pnp_register_driver(&drv->link);\n\tif (error < 0)\n\t\treturn error;\n\n\tmutex_lock(&pnp_lock);\n\tlist_add_tail(&drv->global_list, &pnp_card_drivers);\n\tmutex_unlock(&pnp_lock);\n\n\tlist_for_each_safe(pos, temp, &pnp_cards) {\n\t\tstruct pnp_card *card =\n\t\t    list_entry(pos, struct pnp_card, global_list);\n\t\tcard_probe(card, drv);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(pnp_register_card_driver);\n\n \nvoid pnp_unregister_card_driver(struct pnp_card_driver *drv)\n{\n\tmutex_lock(&pnp_lock);\n\tlist_del(&drv->global_list);\n\tmutex_unlock(&pnp_lock);\n\tpnp_unregister_driver(&drv->link);\n}\nEXPORT_SYMBOL(pnp_unregister_card_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}