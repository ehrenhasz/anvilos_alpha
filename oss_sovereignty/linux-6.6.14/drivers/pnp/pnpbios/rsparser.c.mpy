{
  "module_name": "rsparser.c",
  "hash_id": "59a25aae00b95d81142153735b8d53c8ed4e7e23efbd234639ff751d24d0efee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/pnpbios/rsparser.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/pnp.h>\n#include <linux/string.h>\n\n#ifdef CONFIG_PCI\n#include <linux/pci.h>\n#else\ninline void pcibios_penalize_isa_irq(int irq, int active)\n{\n}\n#endif\t\t\t\t \n\n#include \"../base.h\"\n#include \"pnpbios.h\"\n\n \n#define SMALL_TAG_PNPVERNO\t\t0x01\n#define SMALL_TAG_LOGDEVID\t\t0x02\n#define SMALL_TAG_COMPATDEVID\t\t0x03\n#define SMALL_TAG_IRQ\t\t\t0x04\n#define SMALL_TAG_DMA\t\t\t0x05\n#define SMALL_TAG_STARTDEP\t\t0x06\n#define SMALL_TAG_ENDDEP\t\t0x07\n#define SMALL_TAG_PORT\t\t\t0x08\n#define SMALL_TAG_FIXEDPORT\t\t0x09\n#define SMALL_TAG_VENDOR\t\t0x0e\n#define SMALL_TAG_END\t\t\t0x0f\n#define LARGE_TAG\t\t\t0x80\n#define LARGE_TAG_MEM\t\t\t0x81\n#define LARGE_TAG_ANSISTR\t\t0x82\n#define LARGE_TAG_UNICODESTR\t\t0x83\n#define LARGE_TAG_VENDOR\t\t0x84\n#define LARGE_TAG_MEM32\t\t\t0x85\n#define LARGE_TAG_FIXEDMEM32\t\t0x86\n\n \n\n \n\nstatic void pnpbios_parse_allocated_ioresource(struct pnp_dev *dev,\n\t\t\t\t\t       int start, int len)\n{\n\tint flags = 0;\n\tint end = start + len - 1;\n\n\tif (len <= 0 || end >= 0x10003)\n\t\tflags |= IORESOURCE_DISABLED;\n\n\tpnp_add_io_resource(dev, start, end, flags);\n}\n\nstatic void pnpbios_parse_allocated_memresource(struct pnp_dev *dev,\n\t\t\t\t\t\tint start, int len)\n{\n\tint flags = 0;\n\tint end = start + len - 1;\n\n\tif (len <= 0)\n\t\tflags |= IORESOURCE_DISABLED;\n\n\tpnp_add_mem_resource(dev, start, end, flags);\n}\n\nstatic unsigned char *pnpbios_parse_allocated_resource_data(struct pnp_dev *dev,\n\t\t\t\t\t\t\t    unsigned char *p,\n\t\t\t\t\t\t\t    unsigned char *end)\n{\n\tunsigned int len, tag;\n\tint io, size, mask, i, flags;\n\n\tif (!p)\n\t\treturn NULL;\n\n\tpnp_dbg(&dev->dev, \"parse allocated resources\\n\");\n\n\tpnp_init_resources(dev);\n\n\twhile ((char *)p < (char *)end) {\n\n\t\t \n\t\tif (p[0] & LARGE_TAG) {\t \n\t\t\tlen = (p[2] << 8) | p[1];\n\t\t\ttag = p[0];\n\t\t} else {\t \n\t\t\tlen = p[0] & 0x07;\n\t\t\ttag = ((p[0] >> 3) & 0x0f);\n\t\t}\n\n\t\tswitch (tag) {\n\n\t\tcase LARGE_TAG_MEM:\n\t\t\tif (len != 9)\n\t\t\t\tgoto len_err;\n\t\t\tio = *(short *)&p[4];\n\t\t\tsize = *(short *)&p[10];\n\t\t\tpnpbios_parse_allocated_memresource(dev, io, size);\n\t\t\tbreak;\n\n\t\tcase LARGE_TAG_ANSISTR:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase LARGE_TAG_VENDOR:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase LARGE_TAG_MEM32:\n\t\t\tif (len != 17)\n\t\t\t\tgoto len_err;\n\t\t\tio = *(int *)&p[4];\n\t\t\tsize = *(int *)&p[16];\n\t\t\tpnpbios_parse_allocated_memresource(dev, io, size);\n\t\t\tbreak;\n\n\t\tcase LARGE_TAG_FIXEDMEM32:\n\t\t\tif (len != 9)\n\t\t\t\tgoto len_err;\n\t\t\tio = *(int *)&p[4];\n\t\t\tsize = *(int *)&p[8];\n\t\t\tpnpbios_parse_allocated_memresource(dev, io, size);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_IRQ:\n\t\t\tif (len < 2 || len > 3)\n\t\t\t\tgoto len_err;\n\t\t\tflags = 0;\n\t\t\tio = -1;\n\t\t\tmask = p[1] + p[2] * 256;\n\t\t\tfor (i = 0; i < 16; i++, mask = mask >> 1)\n\t\t\t\tif (mask & 0x01)\n\t\t\t\t\tio = i;\n\t\t\tif (io != -1)\n\t\t\t\tpcibios_penalize_isa_irq(io, 1);\n\t\t\telse\n\t\t\t\tflags = IORESOURCE_DISABLED;\n\t\t\tpnp_add_irq_resource(dev, io, flags);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_DMA:\n\t\t\tif (len != 2)\n\t\t\t\tgoto len_err;\n\t\t\tflags = 0;\n\t\t\tio = -1;\n\t\t\tmask = p[1];\n\t\t\tfor (i = 0; i < 8; i++, mask = mask >> 1)\n\t\t\t\tif (mask & 0x01)\n\t\t\t\t\tio = i;\n\t\t\tif (io == -1)\n\t\t\t\tflags = IORESOURCE_DISABLED;\n\t\t\tpnp_add_dma_resource(dev, io, flags);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_PORT:\n\t\t\tif (len != 7)\n\t\t\t\tgoto len_err;\n\t\t\tio = p[2] + p[3] * 256;\n\t\t\tsize = p[7];\n\t\t\tpnpbios_parse_allocated_ioresource(dev, io, size);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_VENDOR:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_FIXEDPORT:\n\t\t\tif (len != 3)\n\t\t\t\tgoto len_err;\n\t\t\tio = p[1] + p[2] * 256;\n\t\t\tsize = p[3];\n\t\t\tpnpbios_parse_allocated_ioresource(dev, io, size);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_END:\n\t\t\tp = p + 2;\n\t\t\treturn (unsigned char *)p;\n\t\t\tbreak;\n\n\t\tdefault:\t \nlen_err:\n\t\t\tdev_err(&dev->dev, \"unknown tag %#x length %d\\n\",\n\t\t\t\ttag, len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (p[0] & LARGE_TAG)\n\t\t\tp += len + 3;\n\t\telse\n\t\t\tp += len + 1;\n\t}\n\n\tdev_err(&dev->dev, \"no end tag in resource structure\\n\");\n\n\treturn NULL;\n}\n\n \n\nstatic __init void pnpbios_parse_mem_option(struct pnp_dev *dev,\n\t\t\t\t\t    unsigned char *p, int size,\n\t\t\t\t\t    unsigned int option_flags)\n{\n\tresource_size_t min, max, align, len;\n\tunsigned char flags;\n\n\tmin = ((p[5] << 8) | p[4]) << 8;\n\tmax = ((p[7] << 8) | p[6]) << 8;\n\talign = (p[9] << 8) | p[8];\n\tlen = ((p[11] << 8) | p[10]) << 8;\n\tflags = p[3];\n\tpnp_register_mem_resource(dev, option_flags, min, max, align, len,\n\t\t\t\t  flags);\n}\n\nstatic __init void pnpbios_parse_mem32_option(struct pnp_dev *dev,\n\t\t\t\t\t      unsigned char *p, int size,\n\t\t\t\t\t      unsigned int option_flags)\n{\n\tresource_size_t min, max, align, len;\n\tunsigned char flags;\n\n\tmin = (p[7] << 24) | (p[6] << 16) | (p[5] << 8) | p[4];\n\tmax = (p[11] << 24) | (p[10] << 16) | (p[9] << 8) | p[8];\n\talign = (p[15] << 24) | (p[14] << 16) | (p[13] << 8) | p[12];\n\tlen = (p[19] << 24) | (p[18] << 16) | (p[17] << 8) | p[16];\n\tflags = p[3];\n\tpnp_register_mem_resource(dev, option_flags, min, max, align, len,\n\t\t\t\t  flags);\n}\n\nstatic __init void pnpbios_parse_fixed_mem32_option(struct pnp_dev *dev,\n\t\t\t\t\t\t    unsigned char *p, int size,\n\t\t\t\t\t\t    unsigned int option_flags)\n{\n\tresource_size_t base, len;\n\tunsigned char flags;\n\n\tbase = (p[7] << 24) | (p[6] << 16) | (p[5] << 8) | p[4];\n\tlen = (p[11] << 24) | (p[10] << 16) | (p[9] << 8) | p[8];\n\tflags = p[3];\n\tpnp_register_mem_resource(dev, option_flags, base, base, 0, len, flags);\n}\n\nstatic __init void pnpbios_parse_irq_option(struct pnp_dev *dev,\n\t\t\t\t\t    unsigned char *p, int size,\n\t\t\t\t\t    unsigned int option_flags)\n{\n\tunsigned long bits;\n\tpnp_irq_mask_t map;\n\tunsigned char flags = IORESOURCE_IRQ_HIGHEDGE;\n\n\tbits = (p[2] << 8) | p[1];\n\n\tbitmap_zero(map.bits, PNP_IRQ_NR);\n\tbitmap_copy(map.bits, &bits, 16);\n\n\tif (size > 2)\n\t\tflags = p[3];\n\n\tpnp_register_irq_resource(dev, option_flags, &map, flags);\n}\n\nstatic __init void pnpbios_parse_dma_option(struct pnp_dev *dev,\n\t\t\t\t\t    unsigned char *p, int size,\n\t\t\t\t\t    unsigned int option_flags)\n{\n\tpnp_register_dma_resource(dev, option_flags, p[1], p[2]);\n}\n\nstatic __init void pnpbios_parse_port_option(struct pnp_dev *dev,\n\t\t\t\t\t     unsigned char *p, int size,\n\t\t\t\t\t     unsigned int option_flags)\n{\n\tresource_size_t min, max, align, len;\n\tunsigned char flags;\n\n\tmin = (p[3] << 8) | p[2];\n\tmax = (p[5] << 8) | p[4];\n\talign = p[6];\n\tlen = p[7];\n\tflags = p[1] ? IORESOURCE_IO_16BIT_ADDR : 0;\n\tpnp_register_port_resource(dev, option_flags, min, max, align, len,\n\t\t\t\t   flags);\n}\n\nstatic __init void pnpbios_parse_fixed_port_option(struct pnp_dev *dev,\n\t\t\t\t\t\t   unsigned char *p, int size,\n\t\t\t\t\t\t   unsigned int option_flags)\n{\n\tresource_size_t base, len;\n\n\tbase = (p[2] << 8) | p[1];\n\tlen = p[3];\n\tpnp_register_port_resource(dev, option_flags, base, base, 0, len,\n\t\t\t\t   IORESOURCE_IO_FIXED);\n}\n\nstatic __init unsigned char *\npnpbios_parse_resource_option_data(unsigned char *p, unsigned char *end,\n\t\t\t\t   struct pnp_dev *dev)\n{\n\tunsigned int len, tag;\n\tint priority;\n\tunsigned int option_flags;\n\n\tif (!p)\n\t\treturn NULL;\n\n\tpnp_dbg(&dev->dev, \"parse resource options\\n\");\n\toption_flags = 0;\n\twhile ((char *)p < (char *)end) {\n\n\t\t \n\t\tif (p[0] & LARGE_TAG) {\t \n\t\t\tlen = (p[2] << 8) | p[1];\n\t\t\ttag = p[0];\n\t\t} else {\t \n\t\t\tlen = p[0] & 0x07;\n\t\t\ttag = ((p[0] >> 3) & 0x0f);\n\t\t}\n\n\t\tswitch (tag) {\n\n\t\tcase LARGE_TAG_MEM:\n\t\t\tif (len != 9)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_parse_mem_option(dev, p, len, option_flags);\n\t\t\tbreak;\n\n\t\tcase LARGE_TAG_MEM32:\n\t\t\tif (len != 17)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_parse_mem32_option(dev, p, len, option_flags);\n\t\t\tbreak;\n\n\t\tcase LARGE_TAG_FIXEDMEM32:\n\t\t\tif (len != 9)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_parse_fixed_mem32_option(dev, p, len,\n\t\t\t\t\t\t\t option_flags);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_IRQ:\n\t\t\tif (len < 2 || len > 3)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_parse_irq_option(dev, p, len, option_flags);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_DMA:\n\t\t\tif (len != 2)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_parse_dma_option(dev, p, len, option_flags);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_PORT:\n\t\t\tif (len != 7)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_parse_port_option(dev, p, len, option_flags);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_VENDOR:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_FIXEDPORT:\n\t\t\tif (len != 3)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_parse_fixed_port_option(dev, p, len,\n\t\t\t\t\t\t\toption_flags);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_STARTDEP:\n\t\t\tif (len > 1)\n\t\t\t\tgoto len_err;\n\t\t\tpriority = PNP_RES_PRIORITY_ACCEPTABLE;\n\t\t\tif (len > 0)\n\t\t\t\tpriority = p[1];\n\t\t\toption_flags = pnp_new_dependent_set(dev, priority);\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_ENDDEP:\n\t\t\tif (len != 0)\n\t\t\t\tgoto len_err;\n\t\t\toption_flags = 0;\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_END:\n\t\t\treturn p + 2;\n\n\t\tdefault:\t \nlen_err:\n\t\t\tdev_err(&dev->dev, \"unknown tag %#x length %d\\n\",\n\t\t\t\ttag, len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (p[0] & LARGE_TAG)\n\t\t\tp += len + 3;\n\t\telse\n\t\t\tp += len + 1;\n\t}\n\n\tdev_err(&dev->dev, \"no end tag in resource structure\\n\");\n\n\treturn NULL;\n}\n\n \n\nstatic unsigned char *pnpbios_parse_compatible_ids(unsigned char *p,\n\t\t\t\t\t\t   unsigned char *end,\n\t\t\t\t\t\t   struct pnp_dev *dev)\n{\n\tint len, tag;\n\tu32 eisa_id;\n\tchar id[8];\n\tstruct pnp_id *dev_id;\n\n\tif (!p)\n\t\treturn NULL;\n\n\twhile ((char *)p < (char *)end) {\n\n\t\t \n\t\tif (p[0] & LARGE_TAG) {\t \n\t\t\tlen = (p[2] << 8) | p[1];\n\t\t\ttag = p[0];\n\t\t} else {\t \n\t\t\tlen = p[0] & 0x07;\n\t\t\ttag = ((p[0] >> 3) & 0x0f);\n\t\t}\n\n\t\tswitch (tag) {\n\n\t\tcase LARGE_TAG_ANSISTR:\n\t\t\tstrncpy(dev->name, p + 3,\n\t\t\t\tlen >= PNP_NAME_LEN ? PNP_NAME_LEN - 2 : len);\n\t\t\tdev->name[len >=\n\t\t\t\t  PNP_NAME_LEN ? PNP_NAME_LEN - 1 : len] = '\\0';\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_COMPATDEVID:\t \n\t\t\tif (len != 4)\n\t\t\t\tgoto len_err;\n\t\t\teisa_id = p[1] | p[2] << 8 | p[3] << 16 | p[4] << 24;\n\t\t\tpnp_eisa_id_to_string(eisa_id & PNP_EISA_ID_MASK, id);\n\t\t\tdev_id = pnp_add_id(dev, id);\n\t\t\tif (!dev_id)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_END:\n\t\t\tp = p + 2;\n\t\t\treturn (unsigned char *)p;\n\t\t\tbreak;\n\n\t\tdefault:\t \nlen_err:\n\t\t\tdev_err(&dev->dev, \"unknown tag %#x length %d\\n\",\n\t\t\t\ttag, len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (p[0] & LARGE_TAG)\n\t\t\tp += len + 3;\n\t\telse\n\t\t\tp += len + 1;\n\t}\n\n\tdev_err(&dev->dev, \"no end tag in resource structure\\n\");\n\n\treturn NULL;\n}\n\n \n\nstatic void pnpbios_encode_mem(struct pnp_dev *dev, unsigned char *p,\n\t\t\t       struct resource *res)\n{\n\tunsigned long base;\n\tunsigned long len;\n\n\tif (pnp_resource_enabled(res)) {\n\t\tbase = res->start;\n\t\tlen = resource_size(res);\n\t} else {\n\t\tbase = 0;\n\t\tlen = 0;\n\t}\n\n\tp[4] = (base >> 8) & 0xff;\n\tp[5] = ((base >> 8) >> 8) & 0xff;\n\tp[6] = (base >> 8) & 0xff;\n\tp[7] = ((base >> 8) >> 8) & 0xff;\n\tp[10] = (len >> 8) & 0xff;\n\tp[11] = ((len >> 8) >> 8) & 0xff;\n\n\tpnp_dbg(&dev->dev, \"  encode mem %#lx-%#lx\\n\", base, base + len - 1);\n}\n\nstatic void pnpbios_encode_mem32(struct pnp_dev *dev, unsigned char *p,\n\t\t\t\t struct resource *res)\n{\n\tunsigned long base;\n\tunsigned long len;\n\n\tif (pnp_resource_enabled(res)) {\n\t\tbase = res->start;\n\t\tlen = resource_size(res);\n\t} else {\n\t\tbase = 0;\n\t\tlen = 0;\n\t}\n\n\tp[4] = base & 0xff;\n\tp[5] = (base >> 8) & 0xff;\n\tp[6] = (base >> 16) & 0xff;\n\tp[7] = (base >> 24) & 0xff;\n\tp[8] = base & 0xff;\n\tp[9] = (base >> 8) & 0xff;\n\tp[10] = (base >> 16) & 0xff;\n\tp[11] = (base >> 24) & 0xff;\n\tp[16] = len & 0xff;\n\tp[17] = (len >> 8) & 0xff;\n\tp[18] = (len >> 16) & 0xff;\n\tp[19] = (len >> 24) & 0xff;\n\n\tpnp_dbg(&dev->dev, \"  encode mem32 %#lx-%#lx\\n\", base, base + len - 1);\n}\n\nstatic void pnpbios_encode_fixed_mem32(struct pnp_dev *dev, unsigned char *p,\n\t\t\t\t       struct resource *res)\n{\n\tunsigned long base;\n\tunsigned long len;\n\n\tif (pnp_resource_enabled(res)) {\n\t\tbase = res->start;\n\t\tlen = resource_size(res);\n\t} else {\n\t\tbase = 0;\n\t\tlen = 0;\n\t}\n\n\tp[4] = base & 0xff;\n\tp[5] = (base >> 8) & 0xff;\n\tp[6] = (base >> 16) & 0xff;\n\tp[7] = (base >> 24) & 0xff;\n\tp[8] = len & 0xff;\n\tp[9] = (len >> 8) & 0xff;\n\tp[10] = (len >> 16) & 0xff;\n\tp[11] = (len >> 24) & 0xff;\n\n\tpnp_dbg(&dev->dev, \"  encode fixed_mem32 %#lx-%#lx\\n\", base,\n\t\tbase + len - 1);\n}\n\nstatic void pnpbios_encode_irq(struct pnp_dev *dev, unsigned char *p,\n\t\t\t       struct resource *res)\n{\n\tunsigned long map;\n\n\tif (pnp_resource_enabled(res))\n\t\tmap = 1 << res->start;\n\telse\n\t\tmap = 0;\n\n\tp[1] = map & 0xff;\n\tp[2] = (map >> 8) & 0xff;\n\n\tpnp_dbg(&dev->dev, \"  encode irq mask %#lx\\n\", map);\n}\n\nstatic void pnpbios_encode_dma(struct pnp_dev *dev, unsigned char *p,\n\t\t\t       struct resource *res)\n{\n\tunsigned long map;\n\n\tif (pnp_resource_enabled(res))\n\t\tmap = 1 << res->start;\n\telse\n\t\tmap = 0;\n\n\tp[1] = map & 0xff;\n\n\tpnp_dbg(&dev->dev, \"  encode dma mask %#lx\\n\", map);\n}\n\nstatic void pnpbios_encode_port(struct pnp_dev *dev, unsigned char *p,\n\t\t\t\tstruct resource *res)\n{\n\tunsigned long base;\n\tunsigned long len;\n\n\tif (pnp_resource_enabled(res)) {\n\t\tbase = res->start;\n\t\tlen = resource_size(res);\n\t} else {\n\t\tbase = 0;\n\t\tlen = 0;\n\t}\n\n\tp[2] = base & 0xff;\n\tp[3] = (base >> 8) & 0xff;\n\tp[4] = base & 0xff;\n\tp[5] = (base >> 8) & 0xff;\n\tp[7] = len & 0xff;\n\n\tpnp_dbg(&dev->dev, \"  encode io %#lx-%#lx\\n\", base, base + len - 1);\n}\n\nstatic void pnpbios_encode_fixed_port(struct pnp_dev *dev, unsigned char *p,\n\t\t\t\t      struct resource *res)\n{\n\tunsigned long base = res->start;\n\tunsigned long len = resource_size(res);\n\n\tif (pnp_resource_enabled(res)) {\n\t\tbase = res->start;\n\t\tlen = resource_size(res);\n\t} else {\n\t\tbase = 0;\n\t\tlen = 0;\n\t}\n\n\tp[1] = base & 0xff;\n\tp[2] = (base >> 8) & 0xff;\n\tp[3] = len & 0xff;\n\n\tpnp_dbg(&dev->dev, \"  encode fixed_io %#lx-%#lx\\n\", base,\n\t\tbase + len - 1);\n}\n\nstatic unsigned char *pnpbios_encode_allocated_resource_data(struct pnp_dev\n\t\t\t\t\t\t\t\t*dev,\n\t\t\t\t\t\t\t     unsigned char *p,\n\t\t\t\t\t\t\t     unsigned char *end)\n{\n\tunsigned int len, tag;\n\tint port = 0, irq = 0, dma = 0, mem = 0;\n\n\tif (!p)\n\t\treturn NULL;\n\n\twhile ((char *)p < (char *)end) {\n\n\t\t \n\t\tif (p[0] & LARGE_TAG) {\t \n\t\t\tlen = (p[2] << 8) | p[1];\n\t\t\ttag = p[0];\n\t\t} else {\t \n\t\t\tlen = p[0] & 0x07;\n\t\t\ttag = ((p[0] >> 3) & 0x0f);\n\t\t}\n\n\t\tswitch (tag) {\n\n\t\tcase LARGE_TAG_MEM:\n\t\t\tif (len != 9)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_encode_mem(dev, p,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_MEM, mem));\n\t\t\tmem++;\n\t\t\tbreak;\n\n\t\tcase LARGE_TAG_MEM32:\n\t\t\tif (len != 17)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_encode_mem32(dev, p,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_MEM, mem));\n\t\t\tmem++;\n\t\t\tbreak;\n\n\t\tcase LARGE_TAG_FIXEDMEM32:\n\t\t\tif (len != 9)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_encode_fixed_mem32(dev, p,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_MEM, mem));\n\t\t\tmem++;\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_IRQ:\n\t\t\tif (len < 2 || len > 3)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_encode_irq(dev, p,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_IRQ, irq));\n\t\t\tirq++;\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_DMA:\n\t\t\tif (len != 2)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_encode_dma(dev, p,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_DMA, dma));\n\t\t\tdma++;\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_PORT:\n\t\t\tif (len != 7)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_encode_port(dev, p,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_IO, port));\n\t\t\tport++;\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_VENDOR:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_FIXEDPORT:\n\t\t\tif (len != 3)\n\t\t\t\tgoto len_err;\n\t\t\tpnpbios_encode_fixed_port(dev, p,\n\t\t\t\tpnp_get_resource(dev, IORESOURCE_IO, port));\n\t\t\tport++;\n\t\t\tbreak;\n\n\t\tcase SMALL_TAG_END:\n\t\t\tp = p + 2;\n\t\t\treturn (unsigned char *)p;\n\t\t\tbreak;\n\n\t\tdefault:\t \nlen_err:\n\t\t\tdev_err(&dev->dev, \"unknown tag %#x length %d\\n\",\n\t\t\t\ttag, len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (p[0] & LARGE_TAG)\n\t\t\tp += len + 3;\n\t\telse\n\t\t\tp += len + 1;\n\t}\n\n\tdev_err(&dev->dev, \"no end tag in resource structure\\n\");\n\n\treturn NULL;\n}\n\n \n\nint __init pnpbios_parse_data_stream(struct pnp_dev *dev,\n\t\t\t\t\tstruct pnp_bios_node *node)\n{\n\tunsigned char *p = (char *)node->data;\n\tunsigned char *end = (char *)(node->data + node->size);\n\n\tp = pnpbios_parse_allocated_resource_data(dev, p, end);\n\tif (!p)\n\t\treturn -EIO;\n\tp = pnpbios_parse_resource_option_data(p, end, dev);\n\tif (!p)\n\t\treturn -EIO;\n\tp = pnpbios_parse_compatible_ids(p, end, dev);\n\tif (!p)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nint pnpbios_read_resources_from_node(struct pnp_dev *dev,\n\t\t\t\t     struct pnp_bios_node *node)\n{\n\tunsigned char *p = (char *)node->data;\n\tunsigned char *end = (char *)(node->data + node->size);\n\n\tp = pnpbios_parse_allocated_resource_data(dev, p, end);\n\tif (!p)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nint pnpbios_write_resources_to_node(struct pnp_dev *dev,\n\t\t\t\t    struct pnp_bios_node *node)\n{\n\tunsigned char *p = (char *)node->data;\n\tunsigned char *end = (char *)(node->data + node->size);\n\n\tp = pnpbios_encode_allocated_resource_data(dev, p, end);\n\tif (!p)\n\t\treturn -EIO;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}