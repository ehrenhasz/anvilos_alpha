{
  "module_name": "core.c",
  "hash_id": "a4b0b84b88a96adb597a6abe40a4fbcfacadc5eeb79721778436ef91bab6d5fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/pnpbios/core.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/pnp.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/dmi.h>\n#include <linux/delay.h>\n#include <linux/acpi.h>\n#include <linux/freezer.h>\n#include <linux/kmod.h>\n#include <linux/kthread.h>\n\n#include <asm/page.h>\n#include <asm/desc.h>\n#include <asm/byteorder.h>\n\n#include \"../base.h\"\n#include \"pnpbios.h\"\n\n \n\nstatic union pnp_bios_install_struct *pnp_bios_install = NULL;\n\nint pnp_bios_present(void)\n{\n\treturn (pnp_bios_install != NULL);\n}\n\nstruct pnp_dev_node_info node_info;\n\n \n\nstatic struct completion unload_sem;\n\n \nstatic int pnp_dock_event(int dock, struct pnp_docking_station_info *info)\n{\n\tstatic char const sbin_pnpbios[] = \"/sbin/pnpbios\";\n\tchar *argv[3], **envp, *buf, *scratch;\n\tint i = 0, value;\n\n\tif (!(envp = kcalloc(20, sizeof(char *), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tif (!(buf = kzalloc(256, GFP_KERNEL))) {\n\t\tkfree(envp);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\targv[0] = (char *)sbin_pnpbios;\n\targv[1] = \"dock\";\n\targv[2] = NULL;\n\n\t \n\tenvp[i++] = \"HOME=/\";\n\tenvp[i++] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\n#ifdef\tDEBUG\n\t \n\tenvp[i++] = \"DEBUG=kernel\";\n#endif\n\t \n\tscratch = buf;\n\n\t \n\tenvp[i++] = scratch;\n\tscratch += sprintf(scratch, \"ACTION=%s\", dock ? \"add\" : \"remove\") + 1;\n\n\t \n\tenvp[i++] = scratch;\n\tscratch += sprintf(scratch, \"DOCK=%x/%x/%x\",\n\t\t\t   info->location_id, info->serial, info->capabilities);\n\tenvp[i] = NULL;\n\n\tvalue = call_usermodehelper(sbin_pnpbios, argv, envp, UMH_WAIT_EXEC);\n\tkfree(buf);\n\tkfree(envp);\n\treturn 0;\n}\n\n \nstatic int pnp_dock_thread(void *unused)\n{\n\tstatic struct pnp_docking_station_info now;\n\tint docked = -1, d = 0;\n\n\tset_freezable();\n\twhile (1) {\n\t\tint status;\n\n\t\t \n\t\tmsleep_interruptible(2000);\n\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tstatus = pnp_bios_dock_station_info(&now);\n\n\t\tswitch (status) {\n\t\t\t \n\t\tcase PNP_FUNCTION_NOT_SUPPORTED:\n\t\t\tkthread_complete_and_exit(&unload_sem, 0);\n\t\tcase PNP_SYSTEM_NOT_DOCKED:\n\t\t\td = 0;\n\t\t\tbreak;\n\t\tcase PNP_SUCCESS:\n\t\t\td = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpnpbios_print_status(\"pnp_dock_thread\", status);\n\t\t\tprintk(KERN_WARNING \"PnPBIOS: disabling dock monitoring.\\n\");\n\t\t\tkthread_complete_and_exit(&unload_sem, 0);\n\t\t}\n\t\tif (d != docked) {\n\t\t\tif (pnp_dock_event(d, &now) == 0) {\n\t\t\t\tdocked = d;\n#if 0\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"PnPBIOS: Docking station %stached\\n\",\n\t\t\t\t       docked ? \"at\" : \"de\");\n#endif\n\t\t\t}\n\t\t}\n\t}\n\tkthread_complete_and_exit(&unload_sem, 0);\n}\n\nstatic int pnpbios_get_resources(struct pnp_dev *dev)\n{\n\tu8 nodenum = dev->number;\n\tstruct pnp_bios_node *node;\n\n\tif (!pnpbios_is_dynamic(dev))\n\t\treturn -EPERM;\n\n\tpnp_dbg(&dev->dev, \"get resources\\n\");\n\tnode = kzalloc(node_info.max_node_size, GFP_KERNEL);\n\tif (!node)\n\t\treturn -1;\n\tif (pnp_bios_get_dev_node(&nodenum, (char)PNPMODE_DYNAMIC, node)) {\n\t\tkfree(node);\n\t\treturn -ENODEV;\n\t}\n\tpnpbios_read_resources_from_node(dev, node);\n\tdev->active = pnp_is_active(dev);\n\tkfree(node);\n\treturn 0;\n}\n\nstatic int pnpbios_set_resources(struct pnp_dev *dev)\n{\n\tu8 nodenum = dev->number;\n\tstruct pnp_bios_node *node;\n\tint ret;\n\n\tif (!pnpbios_is_dynamic(dev))\n\t\treturn -EPERM;\n\n\tpnp_dbg(&dev->dev, \"set resources\\n\");\n\tnode = kzalloc(node_info.max_node_size, GFP_KERNEL);\n\tif (!node)\n\t\treturn -1;\n\tif (pnp_bios_get_dev_node(&nodenum, (char)PNPMODE_DYNAMIC, node)) {\n\t\tkfree(node);\n\t\treturn -ENODEV;\n\t}\n\tif (pnpbios_write_resources_to_node(dev, node) < 0) {\n\t\tkfree(node);\n\t\treturn -1;\n\t}\n\tret = pnp_bios_set_dev_node(node->handle, (char)PNPMODE_DYNAMIC, node);\n\tkfree(node);\n\tif (ret > 0)\n\t\tret = -1;\n\treturn ret;\n}\n\nstatic void pnpbios_zero_data_stream(struct pnp_bios_node *node)\n{\n\tunsigned char *p = (char *)node->data;\n\tunsigned char *end = (char *)(node->data + node->size);\n\tunsigned int len;\n\tint i;\n\n\twhile ((char *)p < (char *)end) {\n\t\tif (p[0] & 0x80) {\t \n\t\t\tlen = (p[2] << 8) | p[1];\n\t\t\tp += 3;\n\t\t} else {\n\t\t\tif (((p[0] >> 3) & 0x0f) == 0x0f)\n\t\t\t\treturn;\n\t\t\tlen = p[0] & 0x07;\n\t\t\tp += 1;\n\t\t}\n\t\tfor (i = 0; i < len; i++)\n\t\t\tp[i] = 0;\n\t\tp += len;\n\t}\n\tprintk(KERN_ERR\n\t       \"PnPBIOS: Resource structure did not contain an end tag.\\n\");\n}\n\nstatic int pnpbios_disable_resources(struct pnp_dev *dev)\n{\n\tstruct pnp_bios_node *node;\n\tu8 nodenum = dev->number;\n\tint ret;\n\n\tif (dev->flags & PNPBIOS_NO_DISABLE || !pnpbios_is_dynamic(dev))\n\t\treturn -EPERM;\n\n\tnode = kzalloc(node_info.max_node_size, GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tif (pnp_bios_get_dev_node(&nodenum, (char)PNPMODE_DYNAMIC, node)) {\n\t\tkfree(node);\n\t\treturn -ENODEV;\n\t}\n\tpnpbios_zero_data_stream(node);\n\n\tret = pnp_bios_set_dev_node(dev->number, (char)PNPMODE_DYNAMIC, node);\n\tkfree(node);\n\tif (ret > 0)\n\t\tret = -1;\n\treturn ret;\n}\n\n \n\nstruct pnp_protocol pnpbios_protocol = {\n\t.name = \"Plug and Play BIOS\",\n\t.get = pnpbios_get_resources,\n\t.set = pnpbios_set_resources,\n\t.disable = pnpbios_disable_resources,\n};\n\nstatic int __init insert_device(struct pnp_bios_node *node)\n{\n\tstruct pnp_dev *dev;\n\tchar id[8];\n\tint error;\n\n\t \n\tlist_for_each_entry(dev, &pnpbios_protocol.devices, protocol_list) {\n\t\tif (dev->number == node->handle)\n\t\t\treturn -EEXIST;\n\t}\n\n\tpnp_eisa_id_to_string(node->eisa_id & PNP_EISA_ID_MASK, id);\n\tdev = pnp_alloc_dev(&pnpbios_protocol, node->handle, id);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tpnpbios_parse_data_stream(dev, node);\n\tdev->active = pnp_is_active(dev);\n\tdev->flags = node->flags;\n\tif (!(dev->flags & PNPBIOS_NO_CONFIG))\n\t\tdev->capabilities |= PNP_CONFIGURABLE;\n\tif (!(dev->flags & PNPBIOS_NO_DISABLE) && pnpbios_is_dynamic(dev))\n\t\tdev->capabilities |= PNP_DISABLE;\n\tdev->capabilities |= PNP_READ;\n\tif (pnpbios_is_dynamic(dev))\n\t\tdev->capabilities |= PNP_WRITE;\n\tif (dev->flags & PNPBIOS_REMOVABLE)\n\t\tdev->capabilities |= PNP_REMOVABLE;\n\n\t \n\tif (!dev->active)\n\t\tpnp_init_resources(dev);\n\n\terror = pnp_add_device(dev);\n\tif (error) {\n\t\tput_device(&dev->dev);\n\t\treturn error;\n\t}\n\n\tpnpbios_interface_attach_device(node);\n\n\treturn 0;\n}\n\nstatic void __init build_devlist(void)\n{\n\tu8 nodenum;\n\tunsigned int nodes_got = 0;\n\tunsigned int devs = 0;\n\tstruct pnp_bios_node *node;\n\n\tnode = kzalloc(node_info.max_node_size, GFP_KERNEL);\n\tif (!node)\n\t\treturn;\n\n\tfor (nodenum = 0; nodenum < 0xff;) {\n\t\tu8 thisnodenum = nodenum;\n\t\t \n\t\tif (!pnpbios_dont_use_current_config) {\n\t\t\tif (pnp_bios_get_dev_node\n\t\t\t    (&nodenum, (char)PNPMODE_DYNAMIC, node))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (pnp_bios_get_dev_node\n\t\t\t    (&nodenum, (char)PNPMODE_STATIC, node))\n\t\t\t\tbreak;\n\t\t}\n\t\tnodes_got++;\n\t\tif (insert_device(node) == 0)\n\t\t\tdevs++;\n\t\tif (nodenum <= thisnodenum) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"PnPBIOS: build_devlist: Node number 0x%x is out of sequence following node 0x%x. Aborting.\\n\",\n\t\t\t       (unsigned int)nodenum,\n\t\t\t       (unsigned int)thisnodenum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(node);\n\n\tprintk(KERN_INFO\n\t       \"PnPBIOS: %i node%s reported by PnP BIOS; %i recorded by driver\\n\",\n\t       nodes_got, nodes_got != 1 ? \"s\" : \"\", devs);\n}\n\n \n\nstatic int pnpbios_disabled;\nint pnpbios_dont_use_current_config;\n\nstatic int __init pnpbios_setup(char *str)\n{\n\tint invert;\n\n\twhile ((str != NULL) && (*str != '\\0')) {\n\t\tif (strncmp(str, \"off\", 3) == 0)\n\t\t\tpnpbios_disabled = 1;\n\t\tif (strncmp(str, \"on\", 2) == 0)\n\t\t\tpnpbios_disabled = 0;\n\t\tinvert = (strncmp(str, \"no-\", 3) == 0);\n\t\tif (invert)\n\t\t\tstr += 3;\n\t\tif (strncmp(str, \"curr\", 4) == 0)\n\t\t\tpnpbios_dont_use_current_config = invert;\n\t\tstr = strchr(str, ',');\n\t\tif (str != NULL)\n\t\t\tstr += strspn(str, \", \\t\");\n\t}\n\n\treturn 1;\n}\n\n__setup(\"pnpbios=\", pnpbios_setup);\n\n \n#define PNP_SIGNATURE   (('$' << 0) + ('P' << 8) + ('n' << 16) + ('P' << 24))\n\nstatic int __init pnpbios_probe_system(void)\n{\n\tunion pnp_bios_install_struct *check;\n\tu8 sum;\n\tint length, i;\n\n\tprintk(KERN_INFO \"PnPBIOS: Scanning system for PnP BIOS support...\\n\");\n\n\t \n\tfor (check = (union pnp_bios_install_struct *)__va(0xf0000);\n\t     check < (union pnp_bios_install_struct *)__va(0xffff0);\n\t     check = (void *)check + 16) {\n\t\tif (check->fields.signature != PNP_SIGNATURE)\n\t\t\tcontinue;\n\t\tprintk(KERN_INFO\n\t\t       \"PnPBIOS: Found PnP BIOS installation structure at 0x%p\\n\",\n\t\t       check);\n\t\tlength = check->fields.length;\n\t\tif (!length) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"PnPBIOS: installation structure is invalid, skipping\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (sum = 0, i = 0; i < length; i++)\n\t\t\tsum += check->chars[i];\n\t\tif (sum) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"PnPBIOS: installation structure is corrupted, skipping\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (check->fields.version < 0x10) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"PnPBIOS: PnP BIOS version %d.%d is not supported\\n\",\n\t\t\t       check->fields.version >> 4,\n\t\t\t       check->fields.version & 15);\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(KERN_INFO\n\t\t       \"PnPBIOS: PnP BIOS version %d.%d, entry 0x%x:0x%x, dseg 0x%x\\n\",\n\t\t       check->fields.version >> 4, check->fields.version & 15,\n\t\t       check->fields.pm16cseg, check->fields.pm16offset,\n\t\t       check->fields.pm16dseg);\n\t\tpnp_bios_install = check;\n\t\treturn 1;\n\t}\n\n\tprintk(KERN_INFO \"PnPBIOS: PnP BIOS support was not detected.\\n\");\n\treturn 0;\n}\n\nstatic int __init exploding_pnp_bios(const struct dmi_system_id *d)\n{\n\tprintk(KERN_WARNING \"%s detected. Disabling PnPBIOS\\n\", d->ident);\n\treturn 0;\n}\n\nstatic const struct dmi_system_id pnpbios_dmi_table[] __initconst = {\n\t{\t\t\t \n\t .callback = exploding_pnp_bios,\n\t .ident = \"Higraded P14H\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_BIOS_VENDOR, \"American Megatrends Inc.\"),\n\t\t     DMI_MATCH(DMI_BIOS_VERSION, \"07.00T\"),\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Higraded\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"P14H\"),\n\t\t     },\n\t },\n\t{\t\t\t \n\t .callback = exploding_pnp_bios,\n\t .ident = \"ASUS P4P800\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\t     DMI_MATCH(DMI_BOARD_NAME, \"P4P800\"),\n\t\t     },\n\t },\n\t{}\n};\n\nstatic int __init pnpbios_init(void)\n{\n\tint ret;\n\n\tif (pnpbios_disabled || dmi_check_system(pnpbios_dmi_table) ||\n\t    arch_pnpbios_disabled()) {\n\t\tprintk(KERN_INFO \"PnPBIOS: Disabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n#ifdef CONFIG_PNPACPI\n\tif (!acpi_disabled && !pnpacpi_disabled) {\n\t\tpnpbios_disabled = 1;\n\t\tprintk(KERN_INFO \"PnPBIOS: Disabled by ACPI PNP\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\t\t\t\t \n\n\t \n\tif (!pnpbios_probe_system())\n\t\treturn -ENODEV;\n\n\t \n\tpnpbios_calls_init(pnp_bios_install);\n\n\t \n\tret = pnp_bios_dev_node_info(&node_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: Unable to get node info.  Aborting.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = pnp_register_protocol(&pnpbios_protocol);\n\tif (ret) {\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: Unable to register driver.  Aborting.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = pnpbios_proc_init();\n\tif (ret)\n\t\tprintk(KERN_ERR \"PnPBIOS: Failed to create proc interface.\\n\");\n\n\t \n\tbuild_devlist();\n\n\tpnp_platform_devices = 1;\n\treturn 0;\n}\n\nfs_initcall(pnpbios_init);\n\nstatic int __init pnpbios_thread_init(void)\n{\n\tstruct task_struct *task;\n\n\tif (pnpbios_disabled)\n\t\treturn 0;\n\n\tinit_completion(&unload_sem);\n\ttask = kthread_run(pnp_dock_thread, NULL, \"kpnpbiosd\");\n\treturn PTR_ERR_OR_ZERO(task);\n}\n\n \ndevice_initcall(pnpbios_thread_init);\n\nEXPORT_SYMBOL(pnpbios_protocol);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}