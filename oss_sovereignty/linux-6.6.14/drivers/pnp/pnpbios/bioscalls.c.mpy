{
  "module_name": "bioscalls.c",
  "hash_id": "b14a6fb684599acce88a2dc824e05d71f8a3a4c82ca079633bc33710dd83dc18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/pnpbios/bioscalls.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/pnp.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/kmod.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\n#include <asm/page.h>\n#include <asm/desc.h>\n#include <asm/byteorder.h>\n\n#include \"pnpbios.h\"\n\n__visible struct {\n\tu16 offset;\n\tu16 segment;\n} pnp_bios_callpoint;\n\n \n\nasmlinkage __visible void pnp_bios_callfunc(void);\n\n__asm__(\".text\t\t\t\\n\"\n\t__ALIGN_STR \"\\n\"\n\t\".globl pnp_bios_callfunc\\n\"\n\t\"pnp_bios_callfunc:\\n\"\n\t\"\tpushl %edx\t\\n\"\n\t\"\tpushl %ecx\t\\n\"\n\t\"\tpushl %ebx\t\\n\"\n\t\"\tpushl %eax\t\\n\"\n\t\"\tlcallw *pnp_bios_callpoint\\n\"\n\t\"\taddl $16, %esp\t\\n\"\n\t\"\tlret\t\t\\n\"\n\t\".previous\t\t\\n\");\n\n#define Q2_SET_SEL(cpu, selname, address, size) \\\ndo { \\\n\tstruct desc_struct *gdt = get_cpu_gdt_rw((cpu)); \\\n\tset_desc_base(&gdt[(selname) >> 3], (u32)(address)); \\\n\tset_desc_limit(&gdt[(selname) >> 3], (size) - 1); \\\n} while(0)\n\nstatic struct desc_struct bad_bios_desc = GDT_ENTRY_INIT(0x4092,\n\t\t\t(unsigned long)__va(0x400UL), PAGE_SIZE - 0x400 - 1);\n\n \n\n__visible u32 pnp_bios_fault_esp;\n__visible u32 pnp_bios_fault_eip;\n__visible u32 pnp_bios_is_utter_crap = 0;\n\nstatic DEFINE_SPINLOCK(pnp_bios_lock);\n\n \n\nstatic inline u16 call_pnp_bios(u16 func, u16 arg1, u16 arg2, u16 arg3,\n\t\t\t\tu16 arg4, u16 arg5, u16 arg6, u16 arg7,\n\t\t\t\tvoid *ts1_base, u32 ts1_size,\n\t\t\t\tvoid *ts2_base, u32 ts2_size)\n{\n\tunsigned long flags;\n\tu16 status;\n\tstruct desc_struct save_desc_40;\n\tint cpu;\n\n\t \n\tif (pnp_bios_is_utter_crap)\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\n\tcpu = get_cpu();\n\tsave_desc_40 = get_cpu_gdt_rw(cpu)[0x40 / 8];\n\tget_cpu_gdt_rw(cpu)[0x40 / 8] = bad_bios_desc;\n\n\t \n\tspin_lock_irqsave(&pnp_bios_lock, flags);\n\n\t \n\tif (ts1_size)\n\t\tQ2_SET_SEL(smp_processor_id(), PNP_TS1, ts1_base, ts1_size);\n\tif (ts2_size)\n\t\tQ2_SET_SEL(smp_processor_id(), PNP_TS2, ts2_base, ts2_size);\n\n\t__asm__ __volatile__(\"pushl %%ebp\\n\\t\"\n\t\t\t     \"pushl %%edi\\n\\t\"\n\t\t\t     \"pushl %%esi\\n\\t\"\n\t\t\t     \"pushl %%ds\\n\\t\"\n\t\t\t     \"pushl %%es\\n\\t\"\n\t\t\t     \"pushl %%fs\\n\\t\"\n\t\t\t     \"pushl %%gs\\n\\t\"\n\t\t\t     \"pushfl\\n\\t\"\n\t\t\t     \"movl %%esp, pnp_bios_fault_esp\\n\\t\"\n\t\t\t     \"movl $1f, pnp_bios_fault_eip\\n\\t\"\n\t\t\t     \"lcall %5,%6\\n\\t\"\n\t\t\t     \"1:popfl\\n\\t\"\n\t\t\t     \"popl %%gs\\n\\t\"\n\t\t\t     \"popl %%fs\\n\\t\"\n\t\t\t     \"popl %%es\\n\\t\"\n\t\t\t     \"popl %%ds\\n\\t\"\n\t\t\t     \"popl %%esi\\n\\t\"\n\t\t\t     \"popl %%edi\\n\\t\"\n\t\t\t     \"popl %%ebp\\n\\t\":\"=a\"(status)\n\t\t\t     :\"0\"((func) | (((u32) arg1) << 16)),\n\t\t\t     \"b\"((arg2) | (((u32) arg3) << 16)),\n\t\t\t     \"c\"((arg4) | (((u32) arg5) << 16)),\n\t\t\t     \"d\"((arg6) | (((u32) arg7) << 16)),\n\t\t\t     \"i\"(PNP_CS32), \"i\"(0)\n\t\t\t     :\"memory\");\n\tspin_unlock_irqrestore(&pnp_bios_lock, flags);\n\n\tget_cpu_gdt_rw(cpu)[0x40 / 8] = save_desc_40;\n\tput_cpu();\n\n\t \n\tif (pnp_bios_is_utter_crap) {\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: Warning! Your PnP BIOS caused a fatal error. Attempting to continue\\n\");\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: You may need to reboot with the \\\"pnpbios=off\\\" option to operate stably\\n\");\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: Check with your vendor for an updated BIOS\\n\");\n\t}\n\n\treturn status;\n}\n\nvoid pnpbios_print_status(const char *module, u16 status)\n{\n\tswitch (status) {\n\tcase PNP_SUCCESS:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: function successful\\n\", module);\n\t\tbreak;\n\tcase PNP_NOT_SET_STATICALLY:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: unable to set static resources\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_UNKNOWN_FUNCTION:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: invalid function number passed\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_FUNCTION_NOT_SUPPORTED:\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: %s: function not supported on this system\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_INVALID_HANDLE:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: invalid handle\\n\", module);\n\t\tbreak;\n\tcase PNP_BAD_PARAMETER:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: invalid parameters were passed\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_SET_FAILED:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: unable to set resources\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_EVENTS_NOT_PENDING:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: no events are pending\\n\", module);\n\t\tbreak;\n\tcase PNP_SYSTEM_NOT_DOCKED:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: the system is not docked\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_NO_ISA_PNP_CARDS:\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: %s: no isapnp cards are installed on this system\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_UNABLE_TO_DETERMINE_DOCK_CAPABILITIES:\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: %s: cannot determine the capabilities of the docking station\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_CONFIG_CHANGE_FAILED_NO_BATTERY:\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: %s: unable to undock, the system does not have a battery\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_CONFIG_CHANGE_FAILED_RESOURCE_CONFLICT:\n\t\tprintk(KERN_ERR\n\t\t       \"PnPBIOS: %s: could not dock due to resource conflicts\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_BUFFER_TOO_SMALL:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: the buffer passed is too small\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_USE_ESCD_SUPPORT:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: use ESCD instead\\n\", module);\n\t\tbreak;\n\tcase PNP_MESSAGE_NOT_SUPPORTED:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: the message is unsupported\\n\",\n\t\t       module);\n\t\tbreak;\n\tcase PNP_HARDWARE_ERROR:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: a hardware failure has occurred\\n\",\n\t\t       module);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"PnPBIOS: %s: unexpected status 0x%x\\n\", module,\n\t\t       status);\n\t\tbreak;\n\t}\n}\n\n \n\n#define PNP_GET_NUM_SYS_DEV_NODES\t\t0x00\n#define PNP_GET_SYS_DEV_NODE\t\t\t0x01\n#define PNP_SET_SYS_DEV_NODE\t\t\t0x02\n#define PNP_GET_EVENT\t\t\t\t0x03\n#define PNP_SEND_MESSAGE\t\t\t0x04\n#define PNP_GET_DOCKING_STATION_INFORMATION\t0x05\n#define PNP_SET_STATIC_ALLOCED_RES_INFO\t\t0x09\n#define PNP_GET_STATIC_ALLOCED_RES_INFO\t\t0x0a\n#define PNP_GET_APM_ID_TABLE\t\t\t0x0b\n#define PNP_GET_PNP_ISA_CONFIG_STRUC\t\t0x40\n#define PNP_GET_ESCD_INFO\t\t\t0x41\n#define PNP_READ_ESCD\t\t\t\t0x42\n#define PNP_WRITE_ESCD\t\t\t\t0x43\n\n \nstatic int __pnp_bios_dev_node_info(struct pnp_dev_node_info *data)\n{\n\tu16 status;\n\n\tif (!pnp_bios_present())\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\tstatus = call_pnp_bios(PNP_GET_NUM_SYS_DEV_NODES, 0, PNP_TS1, 2,\n\t\t\t       PNP_TS1, PNP_DS, 0, 0, data,\n\t\t\t       sizeof(struct pnp_dev_node_info), NULL, 0);\n\tdata->no_nodes &= 0xff;\n\treturn status;\n}\n\nint pnp_bios_dev_node_info(struct pnp_dev_node_info *data)\n{\n\tint status = __pnp_bios_dev_node_info(data);\n\n\tif (status)\n\t\tpnpbios_print_status(\"dev_node_info\", status);\n\treturn status;\n}\n\n \n\n \nstatic int __pnp_bios_get_dev_node(u8 *nodenum, char boot,\n\t\t\t\t   struct pnp_bios_node *data)\n{\n\tu16 status;\n\tu16 tmp_nodenum;\n\n\tif (!pnp_bios_present())\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\tif (!boot && pnpbios_dont_use_current_config)\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\ttmp_nodenum = *nodenum;\n\tstatus = call_pnp_bios(PNP_GET_SYS_DEV_NODE, 0, PNP_TS1, 0, PNP_TS2,\n\t\t\t       boot ? 2 : 1, PNP_DS, 0, &tmp_nodenum,\n\t\t\t       sizeof(tmp_nodenum), data, 65536);\n\t*nodenum = tmp_nodenum;\n\treturn status;\n}\n\nint pnp_bios_get_dev_node(u8 *nodenum, char boot, struct pnp_bios_node *data)\n{\n\tint status;\n\n\tstatus = __pnp_bios_get_dev_node(nodenum, boot, data);\n\tif (status)\n\t\tpnpbios_print_status(\"get_dev_node\", status);\n\treturn status;\n}\n\n \nstatic int __pnp_bios_set_dev_node(u8 nodenum, char boot,\n\t\t\t\t   struct pnp_bios_node *data)\n{\n\tu16 status;\n\n\tif (!pnp_bios_present())\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\tif (!boot && pnpbios_dont_use_current_config)\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\tstatus = call_pnp_bios(PNP_SET_SYS_DEV_NODE, nodenum, 0, PNP_TS1,\n\t\t\t       boot ? 2 : 1, PNP_DS, 0, 0, data, 65536, NULL,\n\t\t\t       0);\n\treturn status;\n}\n\nint pnp_bios_set_dev_node(u8 nodenum, char boot, struct pnp_bios_node *data)\n{\n\tint status;\n\n\tstatus = __pnp_bios_set_dev_node(nodenum, boot, data);\n\tif (status) {\n\t\tpnpbios_print_status(\"set_dev_node\", status);\n\t\treturn status;\n\t}\n\tif (!boot) {\t\t \n\t\tstatus = pnp_bios_get_dev_node(&nodenum, boot, data);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn status;\n}\n\n \nint pnp_bios_dock_station_info(struct pnp_docking_station_info *data)\n{\n\tu16 status;\n\n\tif (!pnp_bios_present())\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\tstatus = call_pnp_bios(PNP_GET_DOCKING_STATION_INFORMATION, 0, PNP_TS1,\n\t\t\t       PNP_DS, 0, 0, 0, 0, data,\n\t\t\t       sizeof(struct pnp_docking_station_info), NULL,\n\t\t\t       0);\n\treturn status;\n}\n\n \nstatic int __pnp_bios_get_stat_res(char *info)\n{\n\tu16 status;\n\n\tif (!pnp_bios_present())\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\tstatus = call_pnp_bios(PNP_GET_STATIC_ALLOCED_RES_INFO, 0, PNP_TS1,\n\t\t\t       PNP_DS, 0, 0, 0, 0, info, 65536, NULL, 0);\n\treturn status;\n}\n\nint pnp_bios_get_stat_res(char *info)\n{\n\tint status;\n\n\tstatus = __pnp_bios_get_stat_res(info);\n\tif (status)\n\t\tpnpbios_print_status(\"get_stat_res\", status);\n\treturn status;\n}\n\n \nstatic int __pnp_bios_isapnp_config(struct pnp_isa_config_struc *data)\n{\n\tu16 status;\n\n\tif (!pnp_bios_present())\n\t\treturn PNP_FUNCTION_NOT_SUPPORTED;\n\tstatus = call_pnp_bios(PNP_GET_PNP_ISA_CONFIG_STRUC, 0, PNP_TS1, PNP_DS,\n\t\t\t       0, 0, 0, 0, data,\n\t\t\t       sizeof(struct pnp_isa_config_struc), NULL, 0);\n\treturn status;\n}\n\nint pnp_bios_isapnp_config(struct pnp_isa_config_struc *data)\n{\n\tint status;\n\n\tstatus = __pnp_bios_isapnp_config(data);\n\tif (status)\n\t\tpnpbios_print_status(\"isapnp_config\", status);\n\treturn status;\n}\n\n \nstatic int __pnp_bios_escd_info(struct escd_info_struc *data)\n{\n\tu16 status;\n\n\tif (!pnp_bios_present())\n\t\treturn ESCD_FUNCTION_NOT_SUPPORTED;\n\tstatus = call_pnp_bios(PNP_GET_ESCD_INFO, 0, PNP_TS1, 2, PNP_TS1, 4,\n\t\t\t       PNP_TS1, PNP_DS, data,\n\t\t\t       sizeof(struct escd_info_struc), NULL, 0);\n\treturn status;\n}\n\nint pnp_bios_escd_info(struct escd_info_struc *data)\n{\n\tint status;\n\n\tstatus = __pnp_bios_escd_info(data);\n\tif (status)\n\t\tpnpbios_print_status(\"escd_info\", status);\n\treturn status;\n}\n\n \nstatic int __pnp_bios_read_escd(char *data, u32 nvram_base)\n{\n\tu16 status;\n\n\tif (!pnp_bios_present())\n\t\treturn ESCD_FUNCTION_NOT_SUPPORTED;\n\tstatus = call_pnp_bios(PNP_READ_ESCD, 0, PNP_TS1, PNP_TS2, PNP_DS, 0, 0,\n\t\t\t       0, data, 65536, __va(nvram_base), 65536);\n\treturn status;\n}\n\nint pnp_bios_read_escd(char *data, u32 nvram_base)\n{\n\tint status;\n\n\tstatus = __pnp_bios_read_escd(data, nvram_base);\n\tif (status)\n\t\tpnpbios_print_status(\"read_escd\", status);\n\treturn status;\n}\n\nvoid pnpbios_calls_init(union pnp_bios_install_struct *header)\n{\n\tint i;\n\n\tpnp_bios_callpoint.offset = header->fields.pm16offset;\n\tpnp_bios_callpoint.segment = PNP_CS16;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct desc_struct *gdt = get_cpu_gdt_rw(i);\n\t\tif (!gdt)\n\t\t\tcontinue;\n\t\tset_desc_base(&gdt[GDT_ENTRY_PNPBIOS_CS32],\n\t\t\t (unsigned long)&pnp_bios_callfunc);\n\t\tset_desc_base(&gdt[GDT_ENTRY_PNPBIOS_CS16],\n\t\t\t (unsigned long)__va(header->fields.pm16cseg));\n\t\tset_desc_base(&gdt[GDT_ENTRY_PNPBIOS_DS],\n\t\t\t (unsigned long)__va(header->fields.pm16dseg));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}