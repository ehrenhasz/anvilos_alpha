{
  "module_name": "Kconfig",
  "hash_id": "2fa04f3491a486c43dde3dd0363e5c3ee33f39ba1b5e3b69b273da5f05e56019",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Plug and Play configuration\n#\n\nmenuconfig PNP\n\tbool \"Plug and Play support\"\n\tdepends on HAS_IOMEM\n\tdepends on ISA || ACPI\n\thelp\n\t  Plug and Play (PnP) is a standard for peripherals which allows those\n\t  peripherals to be configured by software, e.g. assign IRQ's or other\n\t  parameters. No jumpers on the cards are needed, instead the values\n\t  are provided to the cards from the BIOS, from the operating system,\n\t  or using a user-space utility.\n\n\t  Say Y here if you would like Linux to configure your Plug and Play\n\t  devices. You should then also say Y to all of the protocols below.\n\t  Alternatively, you can say N here and configure your PnP devices\n\t  using user space utilities such as the isapnptools package.\n\n\t  If unsure, say Y.\n\nconfig PNP_DEBUG_MESSAGES\n\tdefault y\n\tbool \"PNP debugging messages\"\n\tdepends on PNP\n\thelp\n\t  Say Y here if you want the PNP layer to be able to produce debugging\n\t  messages if needed.  The messages can be enabled at boot-time with\n\t  the pnp.debug kernel parameter.\n\n\t  This option allows you to save a bit of space if you do not want\n\t  the messages to even be built into the kernel.\n\n\t  If you have any doubts about this, say Y here.\n\nif PNP\n\ncomment \"Protocols\"\n\nsource \"drivers/pnp/isapnp/Kconfig\"\n\nsource \"drivers/pnp/pnpbios/Kconfig\"\n\nsource \"drivers/pnp/pnpacpi/Kconfig\"\n\nendif # PNP\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}