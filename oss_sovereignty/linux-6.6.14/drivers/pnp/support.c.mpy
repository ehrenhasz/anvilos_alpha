{
  "module_name": "support.c",
  "hash_id": "719afdd5b968c65e2e1dbeafc1b1789996bb4c46135d7e0999ac20f8d26d83f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/support.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/pnp.h>\n#include \"base.h\"\n\n \nint pnp_is_active(struct pnp_dev *dev)\n{\n\t \n\tif (!pnp_port_start(dev, 0) && pnp_port_len(dev, 0) <= 1 &&\n\t    !pnp_mem_start(dev, 0) && pnp_mem_len(dev, 0) <= 1 &&\n\t    pnp_irq(dev, 0) == -1 && pnp_dma(dev, 0) == -1)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\nEXPORT_SYMBOL(pnp_is_active);\n\n \nvoid pnp_eisa_id_to_string(u32 id, char *str)\n{\n\tid = be32_to_cpu(id);\n\n\t \n\tstr[0] = 'A' + ((id >> 26) & 0x3f) - 1;\n\tstr[1] = 'A' + ((id >> 21) & 0x1f) - 1;\n\tstr[2] = 'A' + ((id >> 16) & 0x1f) - 1;\n\tstr[3] = hex_asc_hi(id >> 8);\n\tstr[4] = hex_asc_lo(id >> 8);\n\tstr[5] = hex_asc_hi(id);\n\tstr[6] = hex_asc_lo(id);\n\tstr[7] = '\\0';\n}\n\nchar *pnp_resource_type_name(struct resource *res)\n{\n\tswitch (pnp_resource_type(res)) {\n\tcase IORESOURCE_IO:\n\t\treturn \"io\";\n\tcase IORESOURCE_MEM:\n\t\treturn \"mem\";\n\tcase IORESOURCE_IRQ:\n\t\treturn \"irq\";\n\tcase IORESOURCE_DMA:\n\t\treturn \"dma\";\n\tcase IORESOURCE_BUS:\n\t\treturn \"bus\";\n\t}\n\treturn \"unknown\";\n}\n\nvoid dbg_pnp_show_resources(struct pnp_dev *dev, char *desc)\n{\n\tstruct pnp_resource *pnp_res;\n\n\tif (list_empty(&dev->resources))\n\t\tpnp_dbg(&dev->dev, \"%s: no current resources\\n\", desc);\n\telse {\n\t\tpnp_dbg(&dev->dev, \"%s: current resources:\\n\", desc);\n\t\tlist_for_each_entry(pnp_res, &dev->resources, list)\n\t\t\tpnp_dbg(&dev->dev, \"%pr\\n\", &pnp_res->res);\n\t}\n}\n\nchar *pnp_option_priority_name(struct pnp_option *option)\n{\n\tswitch (pnp_option_priority(option)) {\n\tcase PNP_RES_PRIORITY_PREFERRED:\n\t\treturn \"preferred\";\n\tcase PNP_RES_PRIORITY_ACCEPTABLE:\n\t\treturn \"acceptable\";\n\tcase PNP_RES_PRIORITY_FUNCTIONAL:\n\t\treturn \"functional\";\n\t}\n\treturn \"invalid\";\n}\n\nvoid dbg_pnp_show_option(struct pnp_dev *dev, struct pnp_option *option)\n{\n\tchar buf[128];\n\tint len = 0, i;\n\tstruct pnp_port *port;\n\tstruct pnp_mem *mem;\n\tstruct pnp_irq *irq;\n\tstruct pnp_dma *dma;\n\n\tif (pnp_option_is_dependent(option))\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t \"  dependent set %d (%s) \",\n\t\t\t\t pnp_option_set(option),\n\t\t\t\t pnp_option_priority_name(option));\n\telse\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t \"  independent \");\n\n\tswitch (option->type) {\n\tcase IORESOURCE_IO:\n\t\tport = &option->u.port;\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \"io  min %#llx \"\n\t\t\t\t \"max %#llx align %lld size %lld flags %#x\",\n\t\t\t\t (unsigned long long) port->min,\n\t\t\t\t (unsigned long long) port->max,\n\t\t\t\t (unsigned long long) port->align,\n\t\t\t\t (unsigned long long) port->size, port->flags);\n\t\tbreak;\n\tcase IORESOURCE_MEM:\n\t\tmem = &option->u.mem;\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \"mem min %#llx \"\n\t\t\t\t \"max %#llx align %lld size %lld flags %#x\",\n\t\t\t\t (unsigned long long) mem->min,\n\t\t\t\t (unsigned long long) mem->max,\n\t\t\t\t (unsigned long long) mem->align,\n\t\t\t\t (unsigned long long) mem->size, mem->flags);\n\t\tbreak;\n\tcase IORESOURCE_IRQ:\n\t\tirq = &option->u.irq;\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \"irq\");\n\t\tif (bitmap_empty(irq->map.bits, PNP_IRQ_NR))\n\t\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t\t \" <none>\");\n\t\telse {\n\t\t\tfor (i = 0; i < PNP_IRQ_NR; i++)\n\t\t\t\tif (test_bit(i, irq->map.bits))\n\t\t\t\t\tlen += scnprintf(buf + len,\n\t\t\t\t\t\t\t sizeof(buf) - len,\n\t\t\t\t\t\t\t \" %d\", i);\n\t\t}\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" flags %#x\",\n\t\t\t\t irq->flags);\n\t\tif (irq->flags & IORESOURCE_IRQ_OPTIONAL)\n\t\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t\t \" (optional)\");\n\t\tbreak;\n\tcase IORESOURCE_DMA:\n\t\tdma = &option->u.dma;\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \"dma\");\n\t\tif (!dma->map)\n\t\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t\t \" <none>\");\n\t\telse {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tif (dma->map & (1 << i))\n\t\t\t\t\tlen += scnprintf(buf + len,\n\t\t\t\t\t\t\t sizeof(buf) - len,\n\t\t\t\t\t\t\t \" %d\", i);\n\t\t}\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" (bitmask %#x) \"\n\t\t\t\t \"flags %#x\", dma->map, dma->flags);\n\t\tbreak;\n\t}\n\tpnp_dbg(&dev->dev, \"%s\\n\", buf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}