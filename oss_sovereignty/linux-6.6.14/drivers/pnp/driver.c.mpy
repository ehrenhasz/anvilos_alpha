{
  "module_name": "driver.c",
  "hash_id": "4664ecc8598d4c5fb2811675203db5490d5c7b47a4994c6a1a668c88fc786626",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/driver.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/pnp.h>\n#include \"base.h\"\n\nstatic int compare_func(const char *ida, const char *idb)\n{\n\tint i;\n\n\t \n\tfor (i = 3; i < 7; i++) {\n\t\tif (ida[i] != 'X' &&\n\t\t    idb[i] != 'X' && toupper(ida[i]) != toupper(idb[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint compare_pnp_id(struct pnp_id *pos, const char *id)\n{\n\tif (!pos || !id || (strlen(id) != 7))\n\t\treturn 0;\n\tif (memcmp(id, \"ANYDEVS\", 7) == 0)\n\t\treturn 1;\n\twhile (pos) {\n\t\tif (memcmp(pos->id, id, 3) == 0)\n\t\t\tif (compare_func(pos->id, id) == 1)\n\t\t\t\treturn 1;\n\t\tpos = pos->next;\n\t}\n\treturn 0;\n}\n\nstatic const struct pnp_device_id *match_device(struct pnp_driver *drv,\n\t\t\t\t\t\tstruct pnp_dev *dev)\n{\n\tconst struct pnp_device_id *drv_id = drv->id_table;\n\n\tif (!drv_id)\n\t\treturn NULL;\n\n\twhile (*drv_id->id) {\n\t\tif (compare_pnp_id(dev->id, drv_id->id))\n\t\t\treturn drv_id;\n\t\tdrv_id++;\n\t}\n\treturn NULL;\n}\n\nint pnp_device_attach(struct pnp_dev *pnp_dev)\n{\n\tmutex_lock(&pnp_lock);\n\tif (pnp_dev->status != PNP_READY) {\n\t\tmutex_unlock(&pnp_lock);\n\t\treturn -EBUSY;\n\t}\n\tpnp_dev->status = PNP_ATTACHED;\n\tmutex_unlock(&pnp_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(pnp_device_attach);\n\nvoid pnp_device_detach(struct pnp_dev *pnp_dev)\n{\n\tmutex_lock(&pnp_lock);\n\tif (pnp_dev->status == PNP_ATTACHED)\n\t\tpnp_dev->status = PNP_READY;\n\tmutex_unlock(&pnp_lock);\n}\nEXPORT_SYMBOL(pnp_device_detach);\n\nstatic int pnp_device_probe(struct device *dev)\n{\n\tint error;\n\tstruct pnp_driver *pnp_drv;\n\tstruct pnp_dev *pnp_dev;\n\tconst struct pnp_device_id *dev_id = NULL;\n\tpnp_dev = to_pnp_dev(dev);\n\tpnp_drv = to_pnp_driver(dev->driver);\n\n\terror = pnp_device_attach(pnp_dev);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (pnp_dev->active == 0) {\n\t\tif (!(pnp_drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE)) {\n\t\t\terror = pnp_activate_dev(pnp_dev);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t} else if ((pnp_drv->flags & PNP_DRIVER_RES_DISABLE)\n\t\t   == PNP_DRIVER_RES_DISABLE) {\n\t\terror = pnp_disable_dev(pnp_dev);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = 0;\n\tif (pnp_drv->probe) {\n\t\tdev_id = match_device(pnp_drv, pnp_dev);\n\t\tif (dev_id != NULL)\n\t\t\terror = pnp_drv->probe(pnp_dev, dev_id);\n\t}\n\tif (error >= 0) {\n\t\tpnp_dev->driver = pnp_drv;\n\t\terror = 0;\n\t} else\n\t\tgoto fail;\n\n\treturn error;\n\nfail:\n\tpnp_device_detach(pnp_dev);\n\treturn error;\n}\n\nstatic void pnp_device_remove(struct device *dev)\n{\n\tstruct pnp_dev *pnp_dev = to_pnp_dev(dev);\n\tstruct pnp_driver *drv = pnp_dev->driver;\n\n\tif (drv) {\n\t\tif (drv->remove)\n\t\t\tdrv->remove(pnp_dev);\n\t\tpnp_dev->driver = NULL;\n\t}\n\n\tif (pnp_dev->active &&\n\t    (!drv || !(drv->flags & PNP_DRIVER_RES_DO_NOT_CHANGE)))\n\t\tpnp_disable_dev(pnp_dev);\n\n\tpnp_device_detach(pnp_dev);\n}\n\nstatic void pnp_device_shutdown(struct device *dev)\n{\n\tstruct pnp_dev *pnp_dev = to_pnp_dev(dev);\n\tstruct pnp_driver *drv = pnp_dev->driver;\n\n\tif (drv && drv->shutdown)\n\t\tdrv->shutdown(pnp_dev);\n}\n\nstatic int pnp_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct pnp_dev *pnp_dev = to_pnp_dev(dev);\n\tstruct pnp_driver *pnp_drv = to_pnp_driver(drv);\n\n\tif (match_device(pnp_drv, pnp_dev) == NULL)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int __pnp_bus_suspend(struct device *dev, pm_message_t state)\n{\n\tstruct pnp_dev *pnp_dev = to_pnp_dev(dev);\n\tstruct pnp_driver *pnp_drv = pnp_dev->driver;\n\tint error;\n\n\tif (!pnp_drv)\n\t\treturn 0;\n\n\tif (pnp_drv->driver.pm && pnp_drv->driver.pm->suspend) {\n\t\terror = pnp_drv->driver.pm->suspend(dev);\n\t\tsuspend_report_result(dev, pnp_drv->driver.pm->suspend, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (pnp_drv->suspend) {\n\t\terror = pnp_drv->suspend(pnp_dev, state);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (pnp_can_disable(pnp_dev) && pnp_can_write(pnp_dev)) {\n\t\terror = pnp_stop_dev(pnp_dev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (pnp_can_suspend(pnp_dev))\n\t\tpnp_dev->protocol->suspend(pnp_dev, state);\n\treturn 0;\n}\n\nstatic int pnp_bus_suspend(struct device *dev)\n{\n\treturn __pnp_bus_suspend(dev, PMSG_SUSPEND);\n}\n\nstatic int pnp_bus_freeze(struct device *dev)\n{\n\treturn __pnp_bus_suspend(dev, PMSG_FREEZE);\n}\n\nstatic int pnp_bus_poweroff(struct device *dev)\n{\n\treturn __pnp_bus_suspend(dev, PMSG_HIBERNATE);\n}\n\nstatic int pnp_bus_resume(struct device *dev)\n{\n\tstruct pnp_dev *pnp_dev = to_pnp_dev(dev);\n\tstruct pnp_driver *pnp_drv = pnp_dev->driver;\n\tint error;\n\n\tif (!pnp_drv)\n\t\treturn 0;\n\n\tif (pnp_dev->protocol->resume) {\n\t\terror = pnp_dev->protocol->resume(pnp_dev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (pnp_can_write(pnp_dev)) {\n\t\terror = pnp_start_dev(pnp_dev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (pnp_drv->driver.pm && pnp_drv->driver.pm->resume) {\n\t\terror = pnp_drv->driver.pm->resume(dev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (pnp_drv->resume) {\n\t\terror = pnp_drv->resume(pnp_dev);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops pnp_bus_dev_pm_ops = {\n\t \n\t.suspend = pnp_bus_suspend,\n\t.resume = pnp_bus_resume,\n\t \n\t.freeze = pnp_bus_freeze,\n\t.thaw = pnp_bus_resume,\n\t.poweroff = pnp_bus_poweroff,\n\t.restore = pnp_bus_resume,\n};\n\nstruct bus_type pnp_bus_type = {\n\t.name    = \"pnp\",\n\t.match   = pnp_bus_match,\n\t.probe   = pnp_device_probe,\n\t.remove  = pnp_device_remove,\n\t.shutdown = pnp_device_shutdown,\n\t.pm\t = &pnp_bus_dev_pm_ops,\n\t.dev_groups = pnp_dev_groups,\n};\n\nint pnp_register_driver(struct pnp_driver *drv)\n{\n\tdrv->driver.name = drv->name;\n\tdrv->driver.bus = &pnp_bus_type;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL(pnp_register_driver);\n\nvoid pnp_unregister_driver(struct pnp_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL(pnp_unregister_driver);\n\n \nstruct pnp_id *pnp_add_id(struct pnp_dev *dev, const char *id)\n{\n\tstruct pnp_id *dev_id, *ptr;\n\n\tdev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);\n\tif (!dev_id)\n\t\treturn NULL;\n\n\tdev_id->id[0] = id[0];\n\tdev_id->id[1] = id[1];\n\tdev_id->id[2] = id[2];\n\tdev_id->id[3] = tolower(id[3]);\n\tdev_id->id[4] = tolower(id[4]);\n\tdev_id->id[5] = tolower(id[5]);\n\tdev_id->id[6] = tolower(id[6]);\n\tdev_id->id[7] = '\\0';\n\n\tdev_id->next = NULL;\n\tptr = dev->id;\n\twhile (ptr && ptr->next)\n\t\tptr = ptr->next;\n\tif (ptr)\n\t\tptr->next = dev_id;\n\telse\n\t\tdev->id = dev_id;\n\n\treturn dev_id;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}