{
  "module_name": "system.c",
  "hash_id": "6d23550207f9d0327fcf80fb05c9ee6c10d396d87571e98853b300856230f9f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/system.c",
  "human_readable_source": "\n \n\n#include <linux/pnp.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n\nstatic const struct pnp_device_id pnp_dev_table[] = {\n\t \n\t{\"PNP0c02\", 0},\n\t \n\t{\"PNP0c01\", 0},\n\t{\"\", 0}\n};\n\nstatic void reserve_range(struct pnp_dev *dev, struct resource *r, int port)\n{\n\tchar *regionid;\n\tconst char *pnpid = dev_name(&dev->dev);\n\tresource_size_t start = r->start, end = r->end;\n\tstruct resource *res;\n\n\tregionid = kmalloc(16, GFP_KERNEL);\n\tif (!regionid)\n\t\treturn;\n\n\tsnprintf(regionid, 16, \"pnp %s\", pnpid);\n\tif (port)\n\t\tres = request_region(start, end - start + 1, regionid);\n\telse\n\t\tres = request_mem_region(start, end - start + 1, regionid);\n\tif (res)\n\t\tres->flags &= ~IORESOURCE_BUSY;\n\telse\n\t\tkfree(regionid);\n\n\t \n\tdev_info(&dev->dev, \"%pR %s reserved\\n\", r,\n\t\t res ? \"has been\" : \"could not be\");\n}\n\nstatic void reserve_resources_of_dev(struct pnp_dev *dev)\n{\n\tstruct resource *res;\n\tint i;\n\n\tfor (i = 0; (res = pnp_get_resource(dev, IORESOURCE_IO, i)); i++) {\n\t\tif (res->flags & IORESOURCE_DISABLED)\n\t\t\tcontinue;\n\t\tif (res->start == 0)\n\t\t\tcontinue;\t \n\t\tif (res->start < 0x100)\n\t\t\t \n\t\t\tcontinue;\n\t\tif (res->end < res->start)\n\t\t\tcontinue;\t \n\n\t\treserve_range(dev, res, 1);\n\t}\n\n\tfor (i = 0; (res = pnp_get_resource(dev, IORESOURCE_MEM, i)); i++) {\n\t\tif (res->flags & IORESOURCE_DISABLED)\n\t\t\tcontinue;\n\n\t\treserve_range(dev, res, 0);\n\t}\n}\n\nstatic int system_pnp_probe(struct pnp_dev *dev,\n\t\t\t    const struct pnp_device_id *dev_id)\n{\n\treserve_resources_of_dev(dev);\n\treturn 0;\n}\n\nstatic struct pnp_driver system_pnp_driver = {\n\t.name     = \"system\",\n\t.id_table = pnp_dev_table,\n\t.flags    = PNP_DRIVER_RES_DO_NOT_CHANGE,\n\t.probe    = system_pnp_probe,\n};\n\nstatic int __init pnp_system_init(void)\n{\n\treturn pnp_register_driver(&system_pnp_driver);\n}\n\n \nfs_initcall(pnp_system_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}