{
  "module_name": "resource.c",
  "hash_id": "94362b00fe5ec6067de2f12af4d3bbb6f434f6c1c0813d0c458ef26df14aed1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pnp/resource.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <asm/irq.h>\n#include <linux/pci.h>\n#include <linux/libata.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n\n#include <linux/pnp.h>\n#include \"base.h\"\n\nstatic int pnp_reserve_irq[16] = {[0 ... 15] = -1 };\t \nstatic int pnp_reserve_dma[8] = {[0 ... 7] = -1 };\t \nstatic int pnp_reserve_io[16] = {[0 ... 15] = -1 };\t \nstatic int pnp_reserve_mem[16] = {[0 ... 15] = -1 };\t \n\n \n\nstatic struct pnp_option *pnp_build_option(struct pnp_dev *dev, unsigned long type,\n\t\t\t\t    unsigned int option_flags)\n{\n\tstruct pnp_option *option;\n\n\toption = kzalloc(sizeof(struct pnp_option), GFP_KERNEL);\n\tif (!option)\n\t\treturn NULL;\n\n\toption->flags = option_flags;\n\toption->type = type;\n\n\tlist_add_tail(&option->list, &dev->options);\n\treturn option;\n}\n\nint pnp_register_irq_resource(struct pnp_dev *dev, unsigned int option_flags,\n\t\t\t      pnp_irq_mask_t *map, unsigned char flags)\n{\n\tstruct pnp_option *option;\n\tstruct pnp_irq *irq;\n\n\toption = pnp_build_option(dev, IORESOURCE_IRQ, option_flags);\n\tif (!option)\n\t\treturn -ENOMEM;\n\n\tirq = &option->u.irq;\n\tirq->map = *map;\n\tirq->flags = flags;\n\n#ifdef CONFIG_PCI\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (test_bit(i, irq->map.bits))\n\t\t\t\tpcibios_penalize_isa_irq(i, 0);\n\t}\n#endif\n\n\tdbg_pnp_show_option(dev, option);\n\treturn 0;\n}\n\nint pnp_register_dma_resource(struct pnp_dev *dev, unsigned int option_flags,\n\t\t\t      unsigned char map, unsigned char flags)\n{\n\tstruct pnp_option *option;\n\tstruct pnp_dma *dma;\n\n\toption = pnp_build_option(dev, IORESOURCE_DMA, option_flags);\n\tif (!option)\n\t\treturn -ENOMEM;\n\n\tdma = &option->u.dma;\n\tdma->map = map;\n\tdma->flags = flags;\n\n\tdbg_pnp_show_option(dev, option);\n\treturn 0;\n}\n\nint pnp_register_port_resource(struct pnp_dev *dev, unsigned int option_flags,\n\t\t\t       resource_size_t min, resource_size_t max,\n\t\t\t       resource_size_t align, resource_size_t size,\n\t\t\t       unsigned char flags)\n{\n\tstruct pnp_option *option;\n\tstruct pnp_port *port;\n\n\toption = pnp_build_option(dev, IORESOURCE_IO, option_flags);\n\tif (!option)\n\t\treturn -ENOMEM;\n\n\tport = &option->u.port;\n\tport->min = min;\n\tport->max = max;\n\tport->align = align;\n\tport->size = size;\n\tport->flags = flags;\n\n\tdbg_pnp_show_option(dev, option);\n\treturn 0;\n}\n\nint pnp_register_mem_resource(struct pnp_dev *dev, unsigned int option_flags,\n\t\t\t      resource_size_t min, resource_size_t max,\n\t\t\t      resource_size_t align, resource_size_t size,\n\t\t\t      unsigned char flags)\n{\n\tstruct pnp_option *option;\n\tstruct pnp_mem *mem;\n\n\toption = pnp_build_option(dev, IORESOURCE_MEM, option_flags);\n\tif (!option)\n\t\treturn -ENOMEM;\n\n\tmem = &option->u.mem;\n\tmem->min = min;\n\tmem->max = max;\n\tmem->align = align;\n\tmem->size = size;\n\tmem->flags = flags;\n\n\tdbg_pnp_show_option(dev, option);\n\treturn 0;\n}\n\nvoid pnp_free_options(struct pnp_dev *dev)\n{\n\tstruct pnp_option *option, *tmp;\n\n\tlist_for_each_entry_safe(option, tmp, &dev->options, list) {\n\t\tlist_del(&option->list);\n\t\tkfree(option);\n\t}\n}\n\n \n\n#define length(start, end) (*(end) - *(start) + 1)\n\n \n#define ranged_conflict(starta, enda, startb, endb) \\\n\t!((*(enda) < *(startb)) || (*(endb) < *(starta)))\n\n#define cannot_compare(flags) \\\n((flags) & IORESOURCE_DISABLED)\n\nint pnp_check_port(struct pnp_dev *dev, struct resource *res)\n{\n\tint i;\n\tstruct pnp_dev *tdev;\n\tstruct resource *tres;\n\tresource_size_t *port, *end, *tport, *tend;\n\n\tport = &res->start;\n\tend = &res->end;\n\n\t \n\tif (cannot_compare(res->flags))\n\t\treturn 1;\n\n\t \n\tif (!dev->active) {\n\t\tif (!request_region(*port, length(port, end), \"pnp\"))\n\t\t\treturn 0;\n\t\trelease_region(*port, length(port, end));\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tint rport = pnp_reserve_io[i << 1];\n\t\tint rend = pnp_reserve_io[(i << 1) + 1] + rport - 1;\n\t\tif (ranged_conflict(port, end, &rport, &rend))\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; (tres = pnp_get_resource(dev, IORESOURCE_IO, i)); i++) {\n\t\tif (tres != res && tres->flags & IORESOURCE_IO) {\n\t\t\ttport = &tres->start;\n\t\t\ttend = &tres->end;\n\t\t\tif (ranged_conflict(port, end, tport, tend))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tpnp_for_each_dev(tdev) {\n\t\tif (tdev == dev)\n\t\t\tcontinue;\n\t\tfor (i = 0;\n\t\t     (tres = pnp_get_resource(tdev, IORESOURCE_IO, i));\n\t\t     i++) {\n\t\t\tif (tres->flags & IORESOURCE_IO) {\n\t\t\t\tif (cannot_compare(tres->flags))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tres->flags & IORESOURCE_WINDOW)\n\t\t\t\t\tcontinue;\n\t\t\t\ttport = &tres->start;\n\t\t\t\ttend = &tres->end;\n\t\t\t\tif (ranged_conflict(port, end, tport, tend))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nint pnp_check_mem(struct pnp_dev *dev, struct resource *res)\n{\n\tint i;\n\tstruct pnp_dev *tdev;\n\tstruct resource *tres;\n\tresource_size_t *addr, *end, *taddr, *tend;\n\n\taddr = &res->start;\n\tend = &res->end;\n\n\t \n\tif (cannot_compare(res->flags))\n\t\treturn 1;\n\n\t \n\tif (!dev->active) {\n\t\tif (!request_mem_region(*addr, length(addr, end), \"pnp\"))\n\t\t\treturn 0;\n\t\trelease_mem_region(*addr, length(addr, end));\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tint raddr = pnp_reserve_mem[i << 1];\n\t\tint rend = pnp_reserve_mem[(i << 1) + 1] + raddr - 1;\n\t\tif (ranged_conflict(addr, end, &raddr, &rend))\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; (tres = pnp_get_resource(dev, IORESOURCE_MEM, i)); i++) {\n\t\tif (tres != res && tres->flags & IORESOURCE_MEM) {\n\t\t\ttaddr = &tres->start;\n\t\t\ttend = &tres->end;\n\t\t\tif (ranged_conflict(addr, end, taddr, tend))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tpnp_for_each_dev(tdev) {\n\t\tif (tdev == dev)\n\t\t\tcontinue;\n\t\tfor (i = 0;\n\t\t     (tres = pnp_get_resource(tdev, IORESOURCE_MEM, i));\n\t\t     i++) {\n\t\t\tif (tres->flags & IORESOURCE_MEM) {\n\t\t\t\tif (cannot_compare(tres->flags))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tres->flags & IORESOURCE_WINDOW)\n\t\t\t\t\tcontinue;\n\t\t\t\ttaddr = &tres->start;\n\t\t\t\ttend = &tres->end;\n\t\t\t\tif (ranged_conflict(addr, end, taddr, tend))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic irqreturn_t pnp_test_handler(int irq, void *dev_id)\n{\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_PCI\nstatic int pci_dev_uses_irq(struct pnp_dev *pnp, struct pci_dev *pci,\n\t\t\t    unsigned int irq)\n{\n\tu32 class;\n\tu8 progif;\n\n\tif (pci->irq == irq) {\n\t\tpnp_dbg(&pnp->dev, \"  device %s using irq %d\\n\",\n\t\t\tpci_name(pci), irq);\n\t\treturn 1;\n\t}\n\n\t \n\tpci_read_config_dword(pci, PCI_CLASS_REVISION, &class);\n\tclass >>= 8;\t\t \n\tprogif = class & 0xff;\n\tclass >>= 8;\n\n\tif (class == PCI_CLASS_STORAGE_IDE) {\n\t\t \n\t\tif ((progif & 0x5) != 0x5)\n\t\t\tif (ATA_PRIMARY_IRQ(pci) == irq ||\n\t\t\t    ATA_SECONDARY_IRQ(pci) == irq) {\n\t\t\t\tpnp_dbg(&pnp->dev, \"  legacy IDE device %s \"\n\t\t\t\t\t\"using irq %d\\n\", pci_name(pci), irq);\n\t\t\t\treturn 1;\n\t\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int pci_uses_irq(struct pnp_dev *pnp, unsigned int irq)\n{\n#ifdef CONFIG_PCI\n\tstruct pci_dev *pci = NULL;\n\n\tfor_each_pci_dev(pci) {\n\t\tif (pci_dev_uses_irq(pnp, pci, irq)) {\n\t\t\tpci_dev_put(pci);\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nint pnp_check_irq(struct pnp_dev *dev, struct resource *res)\n{\n\tint i;\n\tstruct pnp_dev *tdev;\n\tstruct resource *tres;\n\tresource_size_t *irq;\n\n\tirq = &res->start;\n\n\t \n\tif (cannot_compare(res->flags))\n\t\treturn 1;\n\n\t \n\tif (*irq > 15)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tif (pnp_reserve_irq[i] == *irq)\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; (tres = pnp_get_resource(dev, IORESOURCE_IRQ, i)); i++) {\n\t\tif (tres != res && tres->flags & IORESOURCE_IRQ) {\n\t\t\tif (tres->start == *irq)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (pci_uses_irq(dev, *irq))\n\t\treturn 0;\n\n\t \n\tif (!dev->active) {\n\t\tif (request_irq(*irq, pnp_test_handler,\n\t\t\t\tIRQF_PROBE_SHARED, \"pnp\", NULL))\n\t\t\treturn 0;\n\t\tfree_irq(*irq, NULL);\n\t}\n\n\t \n\tpnp_for_each_dev(tdev) {\n\t\tif (tdev == dev)\n\t\t\tcontinue;\n\t\tfor (i = 0;\n\t\t     (tres = pnp_get_resource(tdev, IORESOURCE_IRQ, i));\n\t\t     i++) {\n\t\t\tif (tres->flags & IORESOURCE_IRQ) {\n\t\t\t\tif (cannot_compare(tres->flags))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tres->start == *irq)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n#ifdef CONFIG_ISA_DMA_API\nint pnp_check_dma(struct pnp_dev *dev, struct resource *res)\n{\n\tint i;\n\tstruct pnp_dev *tdev;\n\tstruct resource *tres;\n\tresource_size_t *dma;\n\n\tdma = &res->start;\n\n\t \n\tif (cannot_compare(res->flags))\n\t\treturn 1;\n\n\t \n\tif (*dma == 4 || *dma > 7)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif (pnp_reserve_dma[i] == *dma)\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; (tres = pnp_get_resource(dev, IORESOURCE_DMA, i)); i++) {\n\t\tif (tres != res && tres->flags & IORESOURCE_DMA) {\n\t\t\tif (tres->start == *dma)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (!dev->active) {\n\t\tif (request_dma(*dma, \"pnp\"))\n\t\t\treturn 0;\n\t\tfree_dma(*dma);\n\t}\n\n\t \n\tpnp_for_each_dev(tdev) {\n\t\tif (tdev == dev)\n\t\t\tcontinue;\n\t\tfor (i = 0;\n\t\t     (tres = pnp_get_resource(tdev, IORESOURCE_DMA, i));\n\t\t     i++) {\n\t\t\tif (tres->flags & IORESOURCE_DMA) {\n\t\t\t\tif (cannot_compare(tres->flags))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tres->start == *dma)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n#endif  \n\nunsigned long pnp_resource_type(struct resource *res)\n{\n\treturn res->flags & (IORESOURCE_IO  | IORESOURCE_MEM |\n\t\t\t     IORESOURCE_IRQ | IORESOURCE_DMA |\n\t\t\t     IORESOURCE_BUS);\n}\n\nstruct resource *pnp_get_resource(struct pnp_dev *dev,\n\t\t\t\t  unsigned long type, unsigned int num)\n{\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\n\tlist_for_each_entry(pnp_res, &dev->resources, list) {\n\t\tres = &pnp_res->res;\n\t\tif (pnp_resource_type(res) == type && num-- == 0)\n\t\t\treturn res;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(pnp_get_resource);\n\nstatic struct pnp_resource *pnp_new_resource(struct pnp_dev *dev)\n{\n\tstruct pnp_resource *pnp_res;\n\n\tpnp_res = kzalloc(sizeof(struct pnp_resource), GFP_KERNEL);\n\tif (!pnp_res)\n\t\treturn NULL;\n\n\tlist_add_tail(&pnp_res->list, &dev->resources);\n\treturn pnp_res;\n}\n\nstruct pnp_resource *pnp_add_resource(struct pnp_dev *dev,\n\t\t\t\t      struct resource *res)\n{\n\tstruct pnp_resource *pnp_res;\n\n\tpnp_res = pnp_new_resource(dev);\n\tif (!pnp_res) {\n\t\tdev_err(&dev->dev, \"can't add resource %pR\\n\", res);\n\t\treturn NULL;\n\t}\n\n\tpnp_res->res = *res;\n\tpnp_res->res.name = dev->name;\n\tdev_dbg(&dev->dev, \"%pR\\n\", res);\n\treturn pnp_res;\n}\n\nstruct pnp_resource *pnp_add_irq_resource(struct pnp_dev *dev, int irq,\n\t\t\t\t\t  int flags)\n{\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\n\tpnp_res = pnp_new_resource(dev);\n\tif (!pnp_res) {\n\t\tdev_err(&dev->dev, \"can't add resource for IRQ %d\\n\", irq);\n\t\treturn NULL;\n\t}\n\n\tres = &pnp_res->res;\n\tres->flags = IORESOURCE_IRQ | flags;\n\tres->start = irq;\n\tres->end = irq;\n\n\tdev_dbg(&dev->dev, \"%pR\\n\", res);\n\treturn pnp_res;\n}\n\nstruct pnp_resource *pnp_add_dma_resource(struct pnp_dev *dev, int dma,\n\t\t\t\t\t  int flags)\n{\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\n\tpnp_res = pnp_new_resource(dev);\n\tif (!pnp_res) {\n\t\tdev_err(&dev->dev, \"can't add resource for DMA %d\\n\", dma);\n\t\treturn NULL;\n\t}\n\n\tres = &pnp_res->res;\n\tres->flags = IORESOURCE_DMA | flags;\n\tres->start = dma;\n\tres->end = dma;\n\n\tdev_printk(KERN_DEBUG, &dev->dev, \"%pR\\n\", res);\n\treturn pnp_res;\n}\n\nstruct pnp_resource *pnp_add_io_resource(struct pnp_dev *dev,\n\t\t\t\t\t resource_size_t start,\n\t\t\t\t\t resource_size_t end, int flags)\n{\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\n\tpnp_res = pnp_new_resource(dev);\n\tif (!pnp_res) {\n\t\tdev_err(&dev->dev, \"can't add resource for IO %#llx-%#llx\\n\",\n\t\t\t(unsigned long long) start,\n\t\t\t(unsigned long long) end);\n\t\treturn NULL;\n\t}\n\n\tres = &pnp_res->res;\n\tres->flags = IORESOURCE_IO | flags;\n\tres->start = start;\n\tres->end = end;\n\n\tdev_printk(KERN_DEBUG, &dev->dev, \"%pR\\n\", res);\n\treturn pnp_res;\n}\n\nstruct pnp_resource *pnp_add_mem_resource(struct pnp_dev *dev,\n\t\t\t\t\t  resource_size_t start,\n\t\t\t\t\t  resource_size_t end, int flags)\n{\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\n\tpnp_res = pnp_new_resource(dev);\n\tif (!pnp_res) {\n\t\tdev_err(&dev->dev, \"can't add resource for MEM %#llx-%#llx\\n\",\n\t\t\t(unsigned long long) start,\n\t\t\t(unsigned long long) end);\n\t\treturn NULL;\n\t}\n\n\tres = &pnp_res->res;\n\tres->flags = IORESOURCE_MEM | flags;\n\tres->start = start;\n\tres->end = end;\n\n\tdev_printk(KERN_DEBUG, &dev->dev, \"%pR\\n\", res);\n\treturn pnp_res;\n}\n\nstruct pnp_resource *pnp_add_bus_resource(struct pnp_dev *dev,\n\t\t\t\t\t  resource_size_t start,\n\t\t\t\t\t  resource_size_t end)\n{\n\tstruct pnp_resource *pnp_res;\n\tstruct resource *res;\n\n\tpnp_res = pnp_new_resource(dev);\n\tif (!pnp_res) {\n\t\tdev_err(&dev->dev, \"can't add resource for BUS %#llx-%#llx\\n\",\n\t\t\t(unsigned long long) start,\n\t\t\t(unsigned long long) end);\n\t\treturn NULL;\n\t}\n\n\tres = &pnp_res->res;\n\tres->flags = IORESOURCE_BUS;\n\tres->start = start;\n\tres->end = end;\n\n\tdev_printk(KERN_DEBUG, &dev->dev, \"%pR\\n\", res);\n\treturn pnp_res;\n}\n\n \nint pnp_possible_config(struct pnp_dev *dev, int type, resource_size_t start,\n\t\t\tresource_size_t size)\n{\n\tstruct pnp_option *option;\n\tstruct pnp_port *port;\n\tstruct pnp_mem *mem;\n\tstruct pnp_irq *irq;\n\tstruct pnp_dma *dma;\n\n\tlist_for_each_entry(option, &dev->options, list) {\n\t\tif (option->type != type)\n\t\t\tcontinue;\n\n\t\tswitch (option->type) {\n\t\tcase IORESOURCE_IO:\n\t\t\tport = &option->u.port;\n\t\t\tif (port->min == start && port->size == size)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tmem = &option->u.mem;\n\t\t\tif (mem->min == start && mem->size == size)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase IORESOURCE_IRQ:\n\t\t\tirq = &option->u.irq;\n\t\t\tif (start < PNP_IRQ_NR &&\n\t\t\t    test_bit(start, irq->map.bits))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase IORESOURCE_DMA:\n\t\t\tdma = &option->u.dma;\n\t\t\tif (dma->map & (1 << start))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pnp_possible_config);\n\nint pnp_range_reserved(resource_size_t start, resource_size_t end)\n{\n\tstruct pnp_dev *dev;\n\tstruct pnp_resource *pnp_res;\n\tresource_size_t *dev_start, *dev_end;\n\n\tpnp_for_each_dev(dev) {\n\t\tlist_for_each_entry(pnp_res, &dev->resources, list) {\n\t\t\tdev_start = &pnp_res->res.start;\n\t\t\tdev_end   = &pnp_res->res.end;\n\t\t\tif (ranged_conflict(&start, &end, dev_start, dev_end))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(pnp_range_reserved);\n\n \nstatic int __init pnp_setup_reserve_irq(char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tif (get_option(&str, &pnp_reserve_irq[i]) != 2)\n\t\t\tbreak;\n\treturn 1;\n}\n\n__setup(\"pnp_reserve_irq=\", pnp_setup_reserve_irq);\n\n \nstatic int __init pnp_setup_reserve_dma(char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tif (get_option(&str, &pnp_reserve_dma[i]) != 2)\n\t\t\tbreak;\n\treturn 1;\n}\n\n__setup(\"pnp_reserve_dma=\", pnp_setup_reserve_dma);\n\n \nstatic int __init pnp_setup_reserve_io(char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tif (get_option(&str, &pnp_reserve_io[i]) != 2)\n\t\t\tbreak;\n\treturn 1;\n}\n\n__setup(\"pnp_reserve_io=\", pnp_setup_reserve_io);\n\n \nstatic int __init pnp_setup_reserve_mem(char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tif (get_option(&str, &pnp_reserve_mem[i]) != 2)\n\t\t\tbreak;\n\treturn 1;\n}\n\n__setup(\"pnp_reserve_mem=\", pnp_setup_reserve_mem);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}