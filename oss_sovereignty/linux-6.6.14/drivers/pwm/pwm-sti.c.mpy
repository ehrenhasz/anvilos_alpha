{
  "module_name": "pwm-sti.c",
  "hash_id": "3db41607560a8d151b2d94b82958d8f9af8e81840905833a0174c21bc7ebd591",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-sti.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/math64.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n\n#define PWM_OUT_VAL(x)\t(0x00 + (4 * (x)))  \n#define PWM_CPT_VAL(x)\t(0x10 + (4 * (x)))  \n#define PWM_CPT_EDGE(x) (0x30 + (4 * (x)))  \n\n#define STI_PWM_CTRL\t\t0x50\t \n#define STI_INT_EN\t\t0x54\t \n#define STI_INT_STA\t\t0x58\t \n#define PWM_INT_ACK\t\t0x5c\n#define PWM_PRESCALE_LOW_MASK\t0x0f\n#define PWM_PRESCALE_HIGH_MASK\t0xf0\n#define PWM_CPT_EDGE_MASK\t0x03\n#define PWM_INT_ACK_MASK\t0x1ff\n\n#define STI_MAX_CPT_DEVS\t4\n#define CPT_DC_MAX\t\t0xff\n\n \nenum {\n\t \n\tPWMCLK_PRESCALE_LOW,\n\tPWMCLK_PRESCALE_HIGH,\n\tCPTCLK_PRESCALE,\n\n\tPWM_OUT_EN,\n\tPWM_CPT_EN,\n\n\tPWM_CPT_INT_EN,\n\tPWM_CPT_INT_STAT,\n\n\t \n\tMAX_REGFIELDS\n};\n\n \nenum sti_cpt_edge {\n\tCPT_EDGE_DISABLED,\n\tCPT_EDGE_RISING,\n\tCPT_EDGE_FALLING,\n\tCPT_EDGE_BOTH,\n};\n\nstruct sti_cpt_ddata {\n\tu32 snapshot[3];\n\tunsigned int index;\n\tstruct mutex lock;\n\twait_queue_head_t wait;\n};\n\nstruct sti_pwm_compat_data {\n\tconst struct reg_field *reg_fields;\n\tunsigned int pwm_num_devs;\n\tunsigned int cpt_num_devs;\n\tunsigned int max_pwm_cnt;\n\tunsigned int max_prescale;\n\tstruct sti_cpt_ddata *ddata;\n};\n\nstruct sti_pwm_chip {\n\tstruct device *dev;\n\tstruct clk *pwm_clk;\n\tstruct clk *cpt_clk;\n\tstruct regmap *regmap;\n\tstruct sti_pwm_compat_data *cdata;\n\tstruct regmap_field *prescale_low;\n\tstruct regmap_field *prescale_high;\n\tstruct regmap_field *pwm_out_en;\n\tstruct regmap_field *pwm_cpt_en;\n\tstruct regmap_field *pwm_cpt_int_en;\n\tstruct regmap_field *pwm_cpt_int_stat;\n\tstruct pwm_chip chip;\n\tstruct pwm_device *cur;\n\tunsigned long configured;\n\tunsigned int en_count;\n\tstruct mutex sti_pwm_lock;  \n\tvoid __iomem *mmio;\n};\n\nstatic const struct reg_field sti_pwm_regfields[MAX_REGFIELDS] = {\n\t[PWMCLK_PRESCALE_LOW] = REG_FIELD(STI_PWM_CTRL, 0, 3),\n\t[PWMCLK_PRESCALE_HIGH] = REG_FIELD(STI_PWM_CTRL, 11, 14),\n\t[CPTCLK_PRESCALE] = REG_FIELD(STI_PWM_CTRL, 4, 8),\n\t[PWM_OUT_EN] = REG_FIELD(STI_PWM_CTRL, 9, 9),\n\t[PWM_CPT_EN] = REG_FIELD(STI_PWM_CTRL, 10, 10),\n\t[PWM_CPT_INT_EN] = REG_FIELD(STI_INT_EN, 1, 4),\n\t[PWM_CPT_INT_STAT] = REG_FIELD(STI_INT_STA, 1, 4),\n};\n\nstatic inline struct sti_pwm_chip *to_sti_pwmchip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct sti_pwm_chip, chip);\n}\n\n \nstatic int sti_pwm_get_prescale(struct sti_pwm_chip *pc, unsigned long period,\n\t\t\t\tunsigned int *prescale)\n{\n\tstruct sti_pwm_compat_data *cdata = pc->cdata;\n\tunsigned long clk_rate;\n\tunsigned long value;\n\tunsigned int ps;\n\n\tclk_rate = clk_get_rate(pc->pwm_clk);\n\tif (!clk_rate) {\n\t\tdev_err(pc->dev, \"failed to get clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvalue = NSEC_PER_SEC / clk_rate;\n\tvalue *= cdata->max_pwm_cnt + 1;\n\n\tif (period % value)\n\t\treturn -EINVAL;\n\n\tps  = period / value - 1;\n\tif (ps > cdata->max_prescale)\n\t\treturn -EINVAL;\n\n\t*prescale = ps;\n\n\treturn 0;\n}\n\n \nstatic int sti_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  int duty_ns, int period_ns)\n{\n\tstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\n\tstruct sti_pwm_compat_data *cdata = pc->cdata;\n\tunsigned int ncfg, value, prescale = 0;\n\tstruct pwm_device *cur = pc->cur;\n\tstruct device *dev = pc->dev;\n\tbool period_same = false;\n\tint ret;\n\n\tncfg = hweight_long(pc->configured);\n\tif (ncfg)\n\t\tperiod_same = (period_ns == pwm_get_period(cur));\n\n\t \n\tif (!ncfg ||\n\t    ((ncfg == 1) && (pwm->hwpwm == cur->hwpwm)) ||\n\t    ((ncfg == 1) && (pwm->hwpwm != cur->hwpwm) && period_same) ||\n\t    ((ncfg > 1) && period_same)) {\n\t\t \n\t\tret = clk_enable(pc->pwm_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_enable(pc->cpt_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!period_same) {\n\t\t\tret = sti_pwm_get_prescale(pc, period_ns, &prescale);\n\t\t\tif (ret)\n\t\t\t\tgoto clk_dis;\n\n\t\t\tvalue = prescale & PWM_PRESCALE_LOW_MASK;\n\n\t\t\tret = regmap_field_write(pc->prescale_low, value);\n\t\t\tif (ret)\n\t\t\t\tgoto clk_dis;\n\n\t\t\tvalue = (prescale & PWM_PRESCALE_HIGH_MASK) >> 4;\n\n\t\t\tret = regmap_field_write(pc->prescale_high, value);\n\t\t\tif (ret)\n\t\t\t\tgoto clk_dis;\n\t\t}\n\n\t\t \n\t\tvalue = cdata->max_pwm_cnt * duty_ns / period_ns;\n\n\t\tret = regmap_write(pc->regmap, PWM_OUT_VAL(pwm->hwpwm), value);\n\t\tif (ret)\n\t\t\tgoto clk_dis;\n\n\t\tret = regmap_field_write(pc->pwm_cpt_int_en, 0);\n\n\t\tset_bit(pwm->hwpwm, &pc->configured);\n\t\tpc->cur = pwm;\n\n\t\tdev_dbg(dev, \"prescale:%u, period:%i, duty:%i, value:%u\\n\",\n\t\t\tprescale, period_ns, duty_ns, value);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\nclk_dis:\n\tclk_disable(pc->pwm_clk);\n\tclk_disable(pc->cpt_clk);\n\treturn ret;\n}\n\nstatic int sti_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\n\tstruct device *dev = pc->dev;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&pc->sti_pwm_lock);\n\n\tif (!pc->en_count) {\n\t\tret = clk_enable(pc->pwm_clk);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = clk_enable(pc->cpt_clk);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = regmap_field_write(pc->pwm_out_en, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable PWM device %u: %d\\n\",\n\t\t\t\tpwm->hwpwm, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpc->en_count++;\n\nout:\n\tmutex_unlock(&pc->sti_pwm_lock);\n\treturn ret;\n}\n\nstatic void sti_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\n\n\tmutex_lock(&pc->sti_pwm_lock);\n\n\tif (--pc->en_count) {\n\t\tmutex_unlock(&pc->sti_pwm_lock);\n\t\treturn;\n\t}\n\n\tregmap_field_write(pc->pwm_out_en, 0);\n\n\tclk_disable(pc->pwm_clk);\n\tclk_disable(pc->cpt_clk);\n\n\tmutex_unlock(&pc->sti_pwm_lock);\n}\n\nstatic void sti_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\n\n\tclear_bit(pwm->hwpwm, &pc->configured);\n}\n\nstatic int sti_pwm_capture(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   struct pwm_capture *result, unsigned long timeout)\n{\n\tstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\n\tstruct sti_pwm_compat_data *cdata = pc->cdata;\n\tstruct sti_cpt_ddata *ddata = &cdata->ddata[pwm->hwpwm];\n\tstruct device *dev = pc->dev;\n\tunsigned int effective_ticks;\n\tunsigned long long high, low;\n\tint ret;\n\n\tif (pwm->hwpwm >= cdata->cpt_num_devs) {\n\t\tdev_err(dev, \"device %u is not valid\\n\", pwm->hwpwm);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ddata->lock);\n\tddata->index = 0;\n\n\t \n\tregmap_write(pc->regmap, PWM_CPT_EDGE(pwm->hwpwm), CPT_EDGE_RISING);\n\tregmap_field_write(pc->pwm_cpt_int_en, BIT(pwm->hwpwm));\n\n\t \n\tret = regmap_field_write(pc->pwm_cpt_en, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable PWM capture %u: %d\\n\",\n\t\t\tpwm->hwpwm, ret);\n\t\tgoto out;\n\t}\n\n\tret = wait_event_interruptible_timeout(ddata->wait, ddata->index > 1,\n\t\t\t\t\t       msecs_to_jiffies(timeout));\n\n\tregmap_write(pc->regmap, PWM_CPT_EDGE(pwm->hwpwm), CPT_EDGE_DISABLED);\n\n\tif (ret == -ERESTARTSYS)\n\t\tgoto out;\n\n\tswitch (ddata->index) {\n\tcase 0:\n\tcase 1:\n\t\t \n\t\tresult->period = 0;\n\t\tresult->duty_cycle = 0;\n\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\thigh = ddata->snapshot[1] - ddata->snapshot[0];\n\t\tlow = ddata->snapshot[2] - ddata->snapshot[1];\n\n\t\teffective_ticks = clk_get_rate(pc->cpt_clk);\n\n\t\tresult->period = (high + low) * NSEC_PER_SEC;\n\t\tresult->period /= effective_ticks;\n\n\t\tresult->duty_cycle = high * NSEC_PER_SEC;\n\t\tresult->duty_cycle /= effective_ticks;\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"internal error\\n\");\n\t\tbreak;\n\t}\n\nout:\n\t \n\tregmap_field_write(pc->pwm_cpt_en, 0);\n\n\tmutex_unlock(&ddata->lock);\n\treturn ret;\n}\n\nstatic int sti_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled)\n\t\t\tsti_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\terr = sti_pwm_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\terr = sti_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops sti_pwm_ops = {\n\t.capture = sti_pwm_capture,\n\t.apply = sti_pwm_apply,\n\t.free = sti_pwm_free,\n\t.owner = THIS_MODULE,\n};\n\nstatic irqreturn_t sti_pwm_interrupt(int irq, void *data)\n{\n\tstruct sti_pwm_chip *pc = data;\n\tstruct device *dev = pc->dev;\n\tstruct sti_cpt_ddata *ddata;\n\tint devicenum;\n\tunsigned int cpt_int_stat;\n\tunsigned int reg;\n\tint ret = IRQ_NONE;\n\n\tret = regmap_field_read(pc->pwm_cpt_int_stat, &cpt_int_stat);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (cpt_int_stat) {\n\t\tdevicenum = ffs(cpt_int_stat) - 1;\n\n\t\tddata = &pc->cdata->ddata[devicenum];\n\n\t\t \n\n\t\tregmap_read(pc->regmap,\n\t\t\t    PWM_CPT_VAL(devicenum),\n\t\t\t    &ddata->snapshot[ddata->index]);\n\n\t\tswitch (ddata->index) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tregmap_read(pc->regmap, PWM_CPT_EDGE(devicenum), &reg);\n\t\t\treg ^= PWM_CPT_EDGE_MASK;\n\t\t\tregmap_write(pc->regmap, PWM_CPT_EDGE(devicenum), reg);\n\n\t\t\tddata->index++;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tregmap_write(pc->regmap,\n\t\t\t\t     PWM_CPT_EDGE(devicenum),\n\t\t\t\t     CPT_EDGE_DISABLED);\n\t\t\twake_up(&ddata->wait);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(dev, \"Internal error\\n\");\n\t\t}\n\n\t\tcpt_int_stat &= ~BIT_MASK(devicenum);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tregmap_write(pc->regmap, PWM_INT_ACK, PWM_INT_ACK_MASK);\n\n\treturn ret;\n}\n\nstatic int sti_pwm_probe_dt(struct sti_pwm_chip *pc)\n{\n\tstruct device *dev = pc->dev;\n\tconst struct reg_field *reg_fields;\n\tstruct device_node *np = dev->of_node;\n\tstruct sti_pwm_compat_data *cdata = pc->cdata;\n\tu32 num_devs;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"st,pwm-num-chan\", &num_devs);\n\tif (!ret)\n\t\tcdata->pwm_num_devs = num_devs;\n\n\tret = of_property_read_u32(np, \"st,capture-num-chan\", &num_devs);\n\tif (!ret)\n\t\tcdata->cpt_num_devs = num_devs;\n\n\tif (!cdata->pwm_num_devs && !cdata->cpt_num_devs) {\n\t\tdev_err(dev, \"No channels configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg_fields = cdata->reg_fields;\n\n\tpc->prescale_low = devm_regmap_field_alloc(dev, pc->regmap,\n\t\t\t\t\treg_fields[PWMCLK_PRESCALE_LOW]);\n\tif (IS_ERR(pc->prescale_low))\n\t\treturn PTR_ERR(pc->prescale_low);\n\n\tpc->prescale_high = devm_regmap_field_alloc(dev, pc->regmap,\n\t\t\t\t\treg_fields[PWMCLK_PRESCALE_HIGH]);\n\tif (IS_ERR(pc->prescale_high))\n\t\treturn PTR_ERR(pc->prescale_high);\n\n\tpc->pwm_out_en = devm_regmap_field_alloc(dev, pc->regmap,\n\t\t\t\t\t\t reg_fields[PWM_OUT_EN]);\n\tif (IS_ERR(pc->pwm_out_en))\n\t\treturn PTR_ERR(pc->pwm_out_en);\n\n\tpc->pwm_cpt_en = devm_regmap_field_alloc(dev, pc->regmap,\n\t\t\t\t\t\t reg_fields[PWM_CPT_EN]);\n\tif (IS_ERR(pc->pwm_cpt_en))\n\t\treturn PTR_ERR(pc->pwm_cpt_en);\n\n\tpc->pwm_cpt_int_en = devm_regmap_field_alloc(dev, pc->regmap,\n\t\t\t\t\t\treg_fields[PWM_CPT_INT_EN]);\n\tif (IS_ERR(pc->pwm_cpt_int_en))\n\t\treturn PTR_ERR(pc->pwm_cpt_int_en);\n\n\tpc->pwm_cpt_int_stat = devm_regmap_field_alloc(dev, pc->regmap,\n\t\t\t\t\t\treg_fields[PWM_CPT_INT_STAT]);\n\tif (PTR_ERR_OR_ZERO(pc->pwm_cpt_int_stat))\n\t\treturn PTR_ERR(pc->pwm_cpt_int_stat);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config sti_pwm_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic int sti_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sti_pwm_compat_data *cdata;\n\tstruct sti_pwm_chip *pc;\n\tunsigned int i;\n\tint irq, ret;\n\n\tpc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tcdata = devm_kzalloc(dev, sizeof(*cdata), GFP_KERNEL);\n\tif (!cdata)\n\t\treturn -ENOMEM;\n\n\tpc->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->mmio))\n\t\treturn PTR_ERR(pc->mmio);\n\n\tpc->regmap = devm_regmap_init_mmio(dev, pc->mmio,\n\t\t\t\t\t   &sti_pwm_regmap_config);\n\tif (IS_ERR(pc->regmap))\n\t\treturn PTR_ERR(pc->regmap);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, sti_pwm_interrupt, 0,\n\t\t\t       pdev->name, pc);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcdata->reg_fields = sti_pwm_regfields;\n\tcdata->max_prescale = 0xff;\n\tcdata->max_pwm_cnt = 255;\n\tcdata->pwm_num_devs = 0;\n\tcdata->cpt_num_devs = 0;\n\n\tpc->cdata = cdata;\n\tpc->dev = dev;\n\tpc->en_count = 0;\n\tmutex_init(&pc->sti_pwm_lock);\n\n\tret = sti_pwm_probe_dt(pc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cdata->pwm_num_devs) {\n\t\tpc->pwm_clk = of_clk_get_by_name(dev->of_node, \"pwm\");\n\t\tif (IS_ERR(pc->pwm_clk)) {\n\t\t\tdev_err(dev, \"failed to get PWM clock\\n\");\n\t\t\treturn PTR_ERR(pc->pwm_clk);\n\t\t}\n\n\t\tret = clk_prepare(pc->pwm_clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to prepare clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (cdata->cpt_num_devs) {\n\t\tpc->cpt_clk = of_clk_get_by_name(dev->of_node, \"capture\");\n\t\tif (IS_ERR(pc->cpt_clk)) {\n\t\t\tdev_err(dev, \"failed to get PWM capture clock\\n\");\n\t\t\treturn PTR_ERR(pc->cpt_clk);\n\t\t}\n\n\t\tret = clk_prepare(pc->cpt_clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to prepare clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tcdata->ddata = devm_kzalloc(dev, cdata->cpt_num_devs * sizeof(*cdata->ddata), GFP_KERNEL);\n\t\tif (!cdata->ddata)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpc->chip.dev = dev;\n\tpc->chip.ops = &sti_pwm_ops;\n\tpc->chip.npwm = pc->cdata->pwm_num_devs;\n\n\tfor (i = 0; i < cdata->cpt_num_devs; i++) {\n\t\tstruct sti_cpt_ddata *ddata = &cdata->ddata[i];\n\n\t\tinit_waitqueue_head(&ddata->wait);\n\t\tmutex_init(&ddata->lock);\n\t}\n\n\tret = pwmchip_add(&pc->chip);\n\tif (ret < 0) {\n\t\tclk_unprepare(pc->pwm_clk);\n\t\tclk_unprepare(pc->cpt_clk);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, pc);\n\n\treturn 0;\n}\n\nstatic void sti_pwm_remove(struct platform_device *pdev)\n{\n\tstruct sti_pwm_chip *pc = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&pc->chip);\n\n\tclk_unprepare(pc->pwm_clk);\n\tclk_unprepare(pc->cpt_clk);\n}\n\nstatic const struct of_device_id sti_pwm_of_match[] = {\n\t{ .compatible = \"st,sti-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sti_pwm_of_match);\n\nstatic struct platform_driver sti_pwm_driver = {\n\t.driver = {\n\t\t.name = \"sti-pwm\",\n\t\t.of_match_table = sti_pwm_of_match,\n\t},\n\t.probe = sti_pwm_probe,\n\t.remove_new = sti_pwm_remove,\n};\nmodule_platform_driver(sti_pwm_driver);\n\nMODULE_AUTHOR(\"Ajit Pal Singh <ajitpal.singh@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics ST PWM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}