{
  "module_name": "pwm-rcar.c",
  "hash_id": "1a1f3d669d581a5df3c5b2a300de8f81514eba5745c87aef35e66cf6937b3af7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-rcar.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n#define RCAR_PWM_MAX_DIVISION\t24\n#define RCAR_PWM_MAX_CYCLE\t1023\n\n#define RCAR_PWMCR\t\t0x00\n#define  RCAR_PWMCR_CC0_MASK\t0x000f0000\n#define  RCAR_PWMCR_CC0_SHIFT\t16\n#define  RCAR_PWMCR_CCMD\tBIT(15)\n#define  RCAR_PWMCR_SYNC\tBIT(11)\n#define  RCAR_PWMCR_SS0\t\tBIT(4)\n#define  RCAR_PWMCR_EN0\t\tBIT(0)\n\n#define RCAR_PWMCNT\t\t0x04\n#define  RCAR_PWMCNT_CYC0_MASK\t0x03ff0000\n#define  RCAR_PWMCNT_CYC0_SHIFT\t16\n#define  RCAR_PWMCNT_PH0_MASK\t0x000003ff\n#define  RCAR_PWMCNT_PH0_SHIFT\t0\n\nstruct rcar_pwm_chip {\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic inline struct rcar_pwm_chip *to_rcar_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct rcar_pwm_chip, chip);\n}\n\nstatic void rcar_pwm_write(struct rcar_pwm_chip *rp, u32 data,\n\t\t\t   unsigned int offset)\n{\n\twritel(data, rp->base + offset);\n}\n\nstatic u32 rcar_pwm_read(struct rcar_pwm_chip *rp, unsigned int offset)\n{\n\treturn readl(rp->base + offset);\n}\n\nstatic void rcar_pwm_update(struct rcar_pwm_chip *rp, u32 mask, u32 data,\n\t\t\t    unsigned int offset)\n{\n\tu32 value;\n\n\tvalue = rcar_pwm_read(rp, offset);\n\tvalue &= ~mask;\n\tvalue |= data & mask;\n\trcar_pwm_write(rp, value, offset);\n}\n\nstatic int rcar_pwm_get_clock_division(struct rcar_pwm_chip *rp, int period_ns)\n{\n\tunsigned long clk_rate = clk_get_rate(rp->clk);\n\tu64 div, tmp;\n\n\tif (clk_rate == 0)\n\t\treturn -EINVAL;\n\n\tdiv = (u64)NSEC_PER_SEC * RCAR_PWM_MAX_CYCLE;\n\ttmp = (u64)period_ns * clk_rate + div - 1;\n\ttmp = div64_u64(tmp, div);\n\tdiv = ilog2(tmp - 1) + 1;\n\n\treturn (div <= RCAR_PWM_MAX_DIVISION) ? div : -ERANGE;\n}\n\nstatic void rcar_pwm_set_clock_control(struct rcar_pwm_chip *rp,\n\t\t\t\t       unsigned int div)\n{\n\tu32 value;\n\n\tvalue = rcar_pwm_read(rp, RCAR_PWMCR);\n\tvalue &= ~(RCAR_PWMCR_CCMD | RCAR_PWMCR_CC0_MASK);\n\n\tif (div & 1)\n\t\tvalue |= RCAR_PWMCR_CCMD;\n\n\tdiv >>= 1;\n\n\tvalue |= div << RCAR_PWMCR_CC0_SHIFT;\n\trcar_pwm_write(rp, value, RCAR_PWMCR);\n}\n\nstatic int rcar_pwm_set_counter(struct rcar_pwm_chip *rp, int div, int duty_ns,\n\t\t\t\tint period_ns)\n{\n\tunsigned long long one_cycle, tmp;\t \n\tunsigned long clk_rate = clk_get_rate(rp->clk);\n\tu32 cyc, ph;\n\n\tone_cycle = NSEC_PER_SEC * 100ULL << div;\n\tdo_div(one_cycle, clk_rate);\n\n\ttmp = period_ns * 100ULL;\n\tdo_div(tmp, one_cycle);\n\tcyc = (tmp << RCAR_PWMCNT_CYC0_SHIFT) & RCAR_PWMCNT_CYC0_MASK;\n\n\ttmp = duty_ns * 100ULL;\n\tdo_div(tmp, one_cycle);\n\tph = tmp & RCAR_PWMCNT_PH0_MASK;\n\n\t \n\tif (cyc == 0 || ph == 0)\n\t\treturn -EINVAL;\n\n\trcar_pwm_write(rp, cyc | ph, RCAR_PWMCNT);\n\n\treturn 0;\n}\n\nstatic int rcar_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\treturn pm_runtime_get_sync(chip->dev);\n}\n\nstatic void rcar_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tpm_runtime_put(chip->dev);\n}\n\nstatic int rcar_pwm_enable(struct rcar_pwm_chip *rp)\n{\n\tu32 value;\n\n\t \n\tvalue = rcar_pwm_read(rp, RCAR_PWMCNT);\n\tif ((value & RCAR_PWMCNT_CYC0_MASK) == 0 ||\n\t    (value & RCAR_PWMCNT_PH0_MASK) == 0)\n\t\treturn -EINVAL;\n\n\trcar_pwm_update(rp, RCAR_PWMCR_EN0, RCAR_PWMCR_EN0, RCAR_PWMCR);\n\n\treturn 0;\n}\n\nstatic void rcar_pwm_disable(struct rcar_pwm_chip *rp)\n{\n\trcar_pwm_update(rp, RCAR_PWMCR_EN0, 0, RCAR_PWMCR);\n}\n\nstatic int rcar_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  const struct pwm_state *state)\n{\n\tstruct rcar_pwm_chip *rp = to_rcar_pwm_chip(chip);\n\tint div, ret;\n\n\t \n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\trcar_pwm_disable(rp);\n\t\treturn 0;\n\t}\n\n\tdiv = rcar_pwm_get_clock_division(rp, state->period);\n\tif (div < 0)\n\t\treturn div;\n\n\trcar_pwm_update(rp, RCAR_PWMCR_SYNC, RCAR_PWMCR_SYNC, RCAR_PWMCR);\n\n\tret = rcar_pwm_set_counter(rp, div, state->duty_cycle, state->period);\n\tif (!ret)\n\t\trcar_pwm_set_clock_control(rp, div);\n\n\t \n\trcar_pwm_update(rp, RCAR_PWMCR_SYNC, 0, RCAR_PWMCR);\n\n\tif (!ret)\n\t\tret = rcar_pwm_enable(rp);\n\n\treturn ret;\n}\n\nstatic const struct pwm_ops rcar_pwm_ops = {\n\t.request = rcar_pwm_request,\n\t.free = rcar_pwm_free,\n\t.apply = rcar_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int rcar_pwm_probe(struct platform_device *pdev)\n{\n\tstruct rcar_pwm_chip *rcar_pwm;\n\tint ret;\n\n\trcar_pwm = devm_kzalloc(&pdev->dev, sizeof(*rcar_pwm), GFP_KERNEL);\n\tif (rcar_pwm == NULL)\n\t\treturn -ENOMEM;\n\n\trcar_pwm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rcar_pwm->base))\n\t\treturn PTR_ERR(rcar_pwm->base);\n\n\trcar_pwm->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(rcar_pwm->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(rcar_pwm->clk);\n\t}\n\n\tplatform_set_drvdata(pdev, rcar_pwm);\n\n\trcar_pwm->chip.dev = &pdev->dev;\n\trcar_pwm->chip.ops = &rcar_pwm_ops;\n\trcar_pwm->chip.npwm = 1;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = pwmchip_add(&rcar_pwm->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register PWM chip: %d\\n\", ret);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rcar_pwm_remove(struct platform_device *pdev)\n{\n\tstruct rcar_pwm_chip *rcar_pwm = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&rcar_pwm->chip);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id rcar_pwm_of_table[] = {\n\t{ .compatible = \"renesas,pwm-rcar\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rcar_pwm_of_table);\n\nstatic struct platform_driver rcar_pwm_driver = {\n\t.probe = rcar_pwm_probe,\n\t.remove_new = rcar_pwm_remove,\n\t.driver = {\n\t\t.name = \"pwm-rcar\",\n\t\t.of_match_table = rcar_pwm_of_table,\n\t}\n};\nmodule_platform_driver(rcar_pwm_driver);\n\nMODULE_AUTHOR(\"Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas PWM Timer Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:pwm-rcar\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}