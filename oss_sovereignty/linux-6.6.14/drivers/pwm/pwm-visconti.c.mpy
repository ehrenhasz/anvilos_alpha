{
  "module_name": "pwm-visconti.c",
  "hash_id": "1bb4d3541e190c4523a9c9ec079c8869d4a58694a2eaeea2949f30fff5f39319",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-visconti.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n#define PIPGM_PCSR(ch) (0x400 + 4 * (ch))\n#define PIPGM_PDUT(ch) (0x420 + 4 * (ch))\n#define PIPGM_PWMC(ch) (0x440 + 4 * (ch))\n\n#define PIPGM_PWMC_PWMACT\t\tBIT(5)\n#define PIPGM_PWMC_CLK_MASK\t\tGENMASK(1, 0)\n#define PIPGM_PWMC_POLARITY_MASK\tGENMASK(5, 5)\n\nstruct visconti_pwm_chip {\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n};\n\nstatic inline struct visconti_pwm_chip *visconti_pwm_from_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct visconti_pwm_chip, chip);\n}\n\nstatic int visconti_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      const struct pwm_state *state)\n{\n\tstruct visconti_pwm_chip *priv = visconti_pwm_from_chip(chip);\n\tu32 period, duty_cycle, pwmc0;\n\n\tif (!state->enabled) {\n\t\twritel(0, priv->base + PIPGM_PCSR(pwm->hwpwm));\n\t\treturn 0;\n\t}\n\n\t \n\tif (state->period > (0xffff << 3) * 1000)\n\t\tperiod = (0xffff << 3) * 1000;\n\telse\n\t\tperiod = state->period;\n\n\tif (state->duty_cycle > period)\n\t\tduty_cycle = period;\n\telse\n\t\tduty_cycle = state->duty_cycle;\n\n\t \n\tperiod /= 1000;\n\tduty_cycle /= 1000;\n\n\tif (!period)\n\t\treturn -ERANGE;\n\n\t \n\tpwmc0 = fls(period >> 16);\n\tif (WARN_ON(pwmc0 > 3))\n\t\treturn -EINVAL;\n\n\tperiod >>= pwmc0;\n\tduty_cycle >>= pwmc0;\n\n\tif (state->polarity == PWM_POLARITY_INVERSED)\n\t\tpwmc0 |= PIPGM_PWMC_PWMACT;\n\twritel(pwmc0, priv->base + PIPGM_PWMC(pwm->hwpwm));\n\twritel(duty_cycle, priv->base + PIPGM_PDUT(pwm->hwpwm));\n\twritel(period, priv->base + PIPGM_PCSR(pwm->hwpwm));\n\n\treturn 0;\n}\n\nstatic int visconti_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t  struct pwm_state *state)\n{\n\tstruct visconti_pwm_chip *priv = visconti_pwm_from_chip(chip);\n\tu32 period, duty, pwmc0, pwmc0_clk;\n\n\tperiod = readl(priv->base + PIPGM_PCSR(pwm->hwpwm));\n\tduty = readl(priv->base + PIPGM_PDUT(pwm->hwpwm));\n\tpwmc0 = readl(priv->base + PIPGM_PWMC(pwm->hwpwm));\n\tpwmc0_clk = pwmc0 & PIPGM_PWMC_CLK_MASK;\n\n\tstate->period = (period << pwmc0_clk) * NSEC_PER_USEC;\n\tstate->duty_cycle = (duty << pwmc0_clk) * NSEC_PER_USEC;\n\tif (pwmc0 & PIPGM_PWMC_POLARITY_MASK)\n\t\tstate->polarity = PWM_POLARITY_INVERSED;\n\telse\n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\tstate->enabled = true;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops visconti_pwm_ops = {\n\t.apply = visconti_pwm_apply,\n\t.get_state = visconti_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic int visconti_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct visconti_pwm_chip *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->chip.dev = dev;\n\tpriv->chip.ops = &visconti_pwm_ops;\n\tpriv->chip.npwm = 4;\n\n\tret = devm_pwmchip_add(&pdev->dev, &priv->chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Cannot register visconti PWM\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id visconti_pwm_of_match[] = {\n\t{ .compatible = \"toshiba,visconti-pwm\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, visconti_pwm_of_match);\n\nstatic struct platform_driver visconti_pwm_driver = {\n\t.driver = {\n\t\t.name = \"pwm-visconti\",\n\t\t.of_match_table = visconti_pwm_of_match,\n\t},\n\t.probe = visconti_pwm_probe,\n};\nmodule_platform_driver(visconti_pwm_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Nobuhiro Iwamatsu <nobuhiro1.iwamatsu@toshiba.co.jp>\");\nMODULE_ALIAS(\"platform:pwm-visconti\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}