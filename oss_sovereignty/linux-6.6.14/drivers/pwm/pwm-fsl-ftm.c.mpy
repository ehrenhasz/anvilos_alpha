{
  "module_name": "pwm-fsl-ftm.c",
  "hash_id": "fac1a9de7538bc598086962b51dacf2e93852676af7e3941dd4602cf3787252f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-fsl-ftm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/fsl/ftm.h>\n\n#define FTM_SC_CLK(c)\t(((c) + 1) << FTM_SC_CLK_MASK_SHIFT)\n\nenum fsl_pwm_clk {\n\tFSL_PWM_CLK_SYS,\n\tFSL_PWM_CLK_FIX,\n\tFSL_PWM_CLK_EXT,\n\tFSL_PWM_CLK_CNTEN,\n\tFSL_PWM_CLK_MAX\n};\n\nstruct fsl_ftm_soc {\n\tbool has_enable_bits;\n};\n\nstruct fsl_pwm_periodcfg {\n\tenum fsl_pwm_clk clk_select;\n\tunsigned int clk_ps;\n\tunsigned int mod_period;\n};\n\nstruct fsl_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct mutex lock;\n\tstruct regmap *regmap;\n\n\t \n\tstruct fsl_pwm_periodcfg period;\n\n\tstruct clk *ipg_clk;\n\tstruct clk *clk[FSL_PWM_CLK_MAX];\n\n\tconst struct fsl_ftm_soc *soc;\n};\n\nstatic inline struct fsl_pwm_chip *to_fsl_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct fsl_pwm_chip, chip);\n}\n\nstatic void ftm_clear_write_protection(struct fsl_pwm_chip *fpc)\n{\n\tu32 val;\n\n\tregmap_read(fpc->regmap, FTM_FMS, &val);\n\tif (val & FTM_FMS_WPEN)\n\t\tregmap_set_bits(fpc->regmap, FTM_MODE, FTM_MODE_WPDIS);\n}\n\nstatic void ftm_set_write_protection(struct fsl_pwm_chip *fpc)\n{\n\tregmap_set_bits(fpc->regmap, FTM_FMS, FTM_FMS_WPEN);\n}\n\nstatic bool fsl_pwm_periodcfg_are_equal(const struct fsl_pwm_periodcfg *a,\n\t\t\t\t\tconst struct fsl_pwm_periodcfg *b)\n{\n\tif (a->clk_select != b->clk_select)\n\t\treturn false;\n\tif (a->clk_ps != b->clk_ps)\n\t\treturn false;\n\tif (a->mod_period != b->mod_period)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int fsl_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tint ret;\n\tstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\n\n\tret = clk_prepare_enable(fpc->ipg_clk);\n\tif (!ret && fpc->soc->has_enable_bits) {\n\t\tmutex_lock(&fpc->lock);\n\t\tregmap_set_bits(fpc->regmap, FTM_SC, BIT(pwm->hwpwm + 16));\n\t\tmutex_unlock(&fpc->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic void fsl_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\n\n\tif (fpc->soc->has_enable_bits) {\n\t\tmutex_lock(&fpc->lock);\n\t\tregmap_clear_bits(fpc->regmap, FTM_SC, BIT(pwm->hwpwm + 16));\n\t\tmutex_unlock(&fpc->lock);\n\t}\n\n\tclk_disable_unprepare(fpc->ipg_clk);\n}\n\nstatic unsigned int fsl_pwm_ticks_to_ns(struct fsl_pwm_chip *fpc,\n\t\t\t\t\t  unsigned int ticks)\n{\n\tunsigned long rate;\n\tunsigned long long exval;\n\n\trate = clk_get_rate(fpc->clk[fpc->period.clk_select]);\n\texval = ticks;\n\texval *= 1000000000UL;\n\tdo_div(exval, rate >> fpc->period.clk_ps);\n\treturn exval;\n}\n\nstatic bool fsl_pwm_calculate_period_clk(struct fsl_pwm_chip *fpc,\n\t\t\t\t\t unsigned int period_ns,\n\t\t\t\t\t enum fsl_pwm_clk index,\n\t\t\t\t\t struct fsl_pwm_periodcfg *periodcfg\n\t\t\t\t\t )\n{\n\tunsigned long long c;\n\tunsigned int ps;\n\n\tc = clk_get_rate(fpc->clk[index]);\n\tc = c * period_ns;\n\tdo_div(c, 1000000000UL);\n\n\tif (c == 0)\n\t\treturn false;\n\n\tfor (ps = 0; ps < 8 ; ++ps, c >>= 1) {\n\t\tif (c <= 0x10000) {\n\t\t\tperiodcfg->clk_select = index;\n\t\t\tperiodcfg->clk_ps = ps;\n\t\t\tperiodcfg->mod_period = c - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool fsl_pwm_calculate_period(struct fsl_pwm_chip *fpc,\n\t\t\t\t     unsigned int period_ns,\n\t\t\t\t     struct fsl_pwm_periodcfg *periodcfg)\n{\n\tenum fsl_pwm_clk m0, m1;\n\tunsigned long fix_rate, ext_rate;\n\tbool ret;\n\n\tret = fsl_pwm_calculate_period_clk(fpc, period_ns, FSL_PWM_CLK_SYS,\n\t\t\t\t\t   periodcfg);\n\tif (ret)\n\t\treturn true;\n\n\tfix_rate = clk_get_rate(fpc->clk[FSL_PWM_CLK_FIX]);\n\text_rate = clk_get_rate(fpc->clk[FSL_PWM_CLK_EXT]);\n\n\tif (fix_rate > ext_rate) {\n\t\tm0 = FSL_PWM_CLK_FIX;\n\t\tm1 = FSL_PWM_CLK_EXT;\n\t} else {\n\t\tm0 = FSL_PWM_CLK_EXT;\n\t\tm1 = FSL_PWM_CLK_FIX;\n\t}\n\n\tret = fsl_pwm_calculate_period_clk(fpc, period_ns, m0, periodcfg);\n\tif (ret)\n\t\treturn true;\n\n\treturn fsl_pwm_calculate_period_clk(fpc, period_ns, m1, periodcfg);\n}\n\nstatic unsigned int fsl_pwm_calculate_duty(struct fsl_pwm_chip *fpc,\n\t\t\t\t\t   unsigned int duty_ns)\n{\n\tunsigned long long duty;\n\n\tunsigned int period = fpc->period.mod_period + 1;\n\tunsigned int period_ns = fsl_pwm_ticks_to_ns(fpc, period);\n\n\tduty = (unsigned long long)duty_ns * period;\n\tdo_div(duty, period_ns);\n\n\treturn (unsigned int)duty;\n}\n\nstatic bool fsl_pwm_is_any_pwm_enabled(struct fsl_pwm_chip *fpc,\n\t\t\t\t       struct pwm_device *pwm)\n{\n\tu32 val;\n\n\tregmap_read(fpc->regmap, FTM_OUTMASK, &val);\n\tif (~val & 0xFF)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool fsl_pwm_is_other_pwm_enabled(struct fsl_pwm_chip *fpc,\n\t\t\t\t\t struct pwm_device *pwm)\n{\n\tu32 val;\n\n\tregmap_read(fpc->regmap, FTM_OUTMASK, &val);\n\tif (~(val | BIT(pwm->hwpwm)) & 0xFF)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int fsl_pwm_apply_config(struct fsl_pwm_chip *fpc,\n\t\t\t\tstruct pwm_device *pwm,\n\t\t\t\tconst struct pwm_state *newstate)\n{\n\tunsigned int duty;\n\tu32 reg_polarity;\n\n\tstruct fsl_pwm_periodcfg periodcfg;\n\tbool do_write_period = false;\n\n\tif (!fsl_pwm_calculate_period(fpc, newstate->period, &periodcfg)) {\n\t\tdev_err(fpc->chip.dev, \"failed to calculate new period\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fsl_pwm_is_any_pwm_enabled(fpc, pwm))\n\t\tdo_write_period = true;\n\t \n\telse if (!fsl_pwm_periodcfg_are_equal(&fpc->period, &periodcfg)) {\n\t\tif (fsl_pwm_is_other_pwm_enabled(fpc, pwm)) {\n\t\t\tdev_err(fpc->chip.dev,\n\t\t\t\t\"Cannot change period for PWM %u, disable other PWMs first\\n\",\n\t\t\t\tpwm->hwpwm);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (fpc->period.clk_select != periodcfg.clk_select) {\n\t\t\tint ret;\n\t\t\tenum fsl_pwm_clk oldclk = fpc->period.clk_select;\n\t\t\tenum fsl_pwm_clk newclk = periodcfg.clk_select;\n\n\t\t\tret = clk_prepare_enable(fpc->clk[newclk]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tclk_disable_unprepare(fpc->clk[oldclk]);\n\t\t}\n\t\tdo_write_period = true;\n\t}\n\n\tftm_clear_write_protection(fpc);\n\n\tif (do_write_period) {\n\t\tregmap_update_bits(fpc->regmap, FTM_SC, FTM_SC_CLK_MASK,\n\t\t\t\t   FTM_SC_CLK(periodcfg.clk_select));\n\t\tregmap_update_bits(fpc->regmap, FTM_SC, FTM_SC_PS_MASK,\n\t\t\t\t   periodcfg.clk_ps);\n\t\tregmap_write(fpc->regmap, FTM_MOD, periodcfg.mod_period);\n\n\t\tfpc->period = periodcfg;\n\t}\n\n\tduty = fsl_pwm_calculate_duty(fpc, newstate->duty_cycle);\n\n\tregmap_write(fpc->regmap, FTM_CSC(pwm->hwpwm),\n\t\t     FTM_CSC_MSB | FTM_CSC_ELSB);\n\tregmap_write(fpc->regmap, FTM_CV(pwm->hwpwm), duty);\n\n\treg_polarity = 0;\n\tif (newstate->polarity == PWM_POLARITY_INVERSED)\n\t\treg_polarity = BIT(pwm->hwpwm);\n\n\tregmap_update_bits(fpc->regmap, FTM_POL, BIT(pwm->hwpwm), reg_polarity);\n\n\tftm_set_write_protection(fpc);\n\n\treturn 0;\n}\n\nstatic int fsl_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *newstate)\n{\n\tstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\n\tstruct pwm_state *oldstate = &pwm->state;\n\tint ret = 0;\n\n\t \n\n\tmutex_lock(&fpc->lock);\n\n\tif (!newstate->enabled) {\n\t\tif (oldstate->enabled) {\n\t\t\tregmap_set_bits(fpc->regmap, FTM_OUTMASK,\n\t\t\t\t\tBIT(pwm->hwpwm));\n\t\t\tclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_CNTEN]);\n\t\t\tclk_disable_unprepare(fpc->clk[fpc->period.clk_select]);\n\t\t}\n\n\t\tgoto end_mutex;\n\t}\n\n\tret = fsl_pwm_apply_config(fpc, pwm, newstate);\n\tif (ret)\n\t\tgoto end_mutex;\n\n\t \n\tif (!oldstate->enabled) {\n\t\tret = clk_prepare_enable(fpc->clk[fpc->period.clk_select]);\n\t\tif (ret)\n\t\t\tgoto end_mutex;\n\n\t\tret = clk_prepare_enable(fpc->clk[FSL_PWM_CLK_CNTEN]);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(fpc->clk[fpc->period.clk_select]);\n\t\t\tgoto end_mutex;\n\t\t}\n\n\t\tregmap_clear_bits(fpc->regmap, FTM_OUTMASK, BIT(pwm->hwpwm));\n\t}\n\nend_mutex:\n\tmutex_unlock(&fpc->lock);\n\treturn ret;\n}\n\nstatic const struct pwm_ops fsl_pwm_ops = {\n\t.request = fsl_pwm_request,\n\t.free = fsl_pwm_free,\n\t.apply = fsl_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int fsl_pwm_init(struct fsl_pwm_chip *fpc)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(fpc->ipg_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(fpc->regmap, FTM_CNTIN, 0x00);\n\tregmap_write(fpc->regmap, FTM_OUTINIT, 0x00);\n\tregmap_write(fpc->regmap, FTM_OUTMASK, 0xFF);\n\n\tclk_disable_unprepare(fpc->ipg_clk);\n\n\treturn 0;\n}\n\nstatic bool fsl_pwm_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase FTM_FMS:\n\tcase FTM_MODE:\n\tcase FTM_CNT:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config fsl_pwm_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\n\t.max_register = FTM_PWMLOAD,\n\t.volatile_reg = fsl_pwm_volatile_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int fsl_pwm_probe(struct platform_device *pdev)\n{\n\tstruct fsl_pwm_chip *fpc;\n\tvoid __iomem *base;\n\tint ret;\n\n\tfpc = devm_kzalloc(&pdev->dev, sizeof(*fpc), GFP_KERNEL);\n\tif (!fpc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&fpc->lock);\n\n\tfpc->soc = of_device_get_match_data(&pdev->dev);\n\tfpc->chip.dev = &pdev->dev;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tfpc->regmap = devm_regmap_init_mmio_clk(&pdev->dev, \"ftm_sys\", base,\n\t\t\t\t\t\t&fsl_pwm_regmap_config);\n\tif (IS_ERR(fpc->regmap)) {\n\t\tdev_err(&pdev->dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(fpc->regmap);\n\t}\n\n\tfpc->clk[FSL_PWM_CLK_SYS] = devm_clk_get(&pdev->dev, \"ftm_sys\");\n\tif (IS_ERR(fpc->clk[FSL_PWM_CLK_SYS])) {\n\t\tdev_err(&pdev->dev, \"failed to get \\\"ftm_sys\\\" clock\\n\");\n\t\treturn PTR_ERR(fpc->clk[FSL_PWM_CLK_SYS]);\n\t}\n\n\tfpc->clk[FSL_PWM_CLK_FIX] = devm_clk_get(fpc->chip.dev, \"ftm_fix\");\n\tif (IS_ERR(fpc->clk[FSL_PWM_CLK_FIX]))\n\t\treturn PTR_ERR(fpc->clk[FSL_PWM_CLK_FIX]);\n\n\tfpc->clk[FSL_PWM_CLK_EXT] = devm_clk_get(fpc->chip.dev, \"ftm_ext\");\n\tif (IS_ERR(fpc->clk[FSL_PWM_CLK_EXT]))\n\t\treturn PTR_ERR(fpc->clk[FSL_PWM_CLK_EXT]);\n\n\tfpc->clk[FSL_PWM_CLK_CNTEN] =\n\t\t\t\tdevm_clk_get(fpc->chip.dev, \"ftm_cnt_clk_en\");\n\tif (IS_ERR(fpc->clk[FSL_PWM_CLK_CNTEN]))\n\t\treturn PTR_ERR(fpc->clk[FSL_PWM_CLK_CNTEN]);\n\n\t \n\tfpc->ipg_clk = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fpc->ipg_clk))\n\t\tfpc->ipg_clk = fpc->clk[FSL_PWM_CLK_SYS];\n\n\n\tfpc->chip.ops = &fsl_pwm_ops;\n\tfpc->chip.npwm = 8;\n\n\tret = devm_pwmchip_add(&pdev->dev, &fpc->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, fpc);\n\n\treturn fsl_pwm_init(fpc);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fsl_pwm_suspend(struct device *dev)\n{\n\tstruct fsl_pwm_chip *fpc = dev_get_drvdata(dev);\n\tint i;\n\n\tregcache_cache_only(fpc->regmap, true);\n\tregcache_mark_dirty(fpc->regmap);\n\n\tfor (i = 0; i < fpc->chip.npwm; i++) {\n\t\tstruct pwm_device *pwm = &fpc->chip.pwms[i];\n\n\t\tif (!test_bit(PWMF_REQUESTED, &pwm->flags))\n\t\t\tcontinue;\n\n\t\tclk_disable_unprepare(fpc->ipg_clk);\n\n\t\tif (!pwm_is_enabled(pwm))\n\t\t\tcontinue;\n\n\t\tclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_CNTEN]);\n\t\tclk_disable_unprepare(fpc->clk[fpc->period.clk_select]);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_pwm_resume(struct device *dev)\n{\n\tstruct fsl_pwm_chip *fpc = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < fpc->chip.npwm; i++) {\n\t\tstruct pwm_device *pwm = &fpc->chip.pwms[i];\n\n\t\tif (!test_bit(PWMF_REQUESTED, &pwm->flags))\n\t\t\tcontinue;\n\n\t\tclk_prepare_enable(fpc->ipg_clk);\n\n\t\tif (!pwm_is_enabled(pwm))\n\t\t\tcontinue;\n\n\t\tclk_prepare_enable(fpc->clk[fpc->period.clk_select]);\n\t\tclk_prepare_enable(fpc->clk[FSL_PWM_CLK_CNTEN]);\n\t}\n\n\t \n\tregcache_cache_only(fpc->regmap, false);\n\tregcache_sync(fpc->regmap);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops fsl_pwm_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(fsl_pwm_suspend, fsl_pwm_resume)\n};\n\nstatic const struct fsl_ftm_soc vf610_ftm_pwm = {\n\t.has_enable_bits = false,\n};\n\nstatic const struct fsl_ftm_soc imx8qm_ftm_pwm = {\n\t.has_enable_bits = true,\n};\n\nstatic const struct of_device_id fsl_pwm_dt_ids[] = {\n\t{ .compatible = \"fsl,vf610-ftm-pwm\", .data = &vf610_ftm_pwm },\n\t{ .compatible = \"fsl,imx8qm-ftm-pwm\", .data = &imx8qm_ftm_pwm },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, fsl_pwm_dt_ids);\n\nstatic struct platform_driver fsl_pwm_driver = {\n\t.driver = {\n\t\t.name = \"fsl-ftm-pwm\",\n\t\t.of_match_table = fsl_pwm_dt_ids,\n\t\t.pm = &fsl_pwm_pm_ops,\n\t},\n\t.probe = fsl_pwm_probe,\n};\nmodule_platform_driver(fsl_pwm_driver);\n\nMODULE_DESCRIPTION(\"Freescale FlexTimer Module PWM Driver\");\nMODULE_AUTHOR(\"Xiubo Li <Li.Xiubo@freescale.com>\");\nMODULE_ALIAS(\"platform:fsl-ftm-pwm\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}