{
  "module_name": "pwm-keembay.c",
  "hash_id": "e068dd47cc8baecba0e977643c413b33dc1dbf2861a8619aaa4078fdc90d1176",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-keembay.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n\n#define KMB_TOTAL_PWM_CHANNELS\t\t6\n#define KMB_PWM_COUNT_MAX\t\tU16_MAX\n#define KMB_PWM_EN_BIT\t\t\tBIT(31)\n\n \n#define KMB_PWM_HIGH_MASK\t\tGENMASK(31, 16)\n#define KMB_PWM_LOW_MASK\t\tGENMASK(15, 0)\n#define KMB_PWM_LEADIN_MASK\t\tGENMASK(30, 0)\n\n \n#define KMB_PWM_LEADIN_OFFSET(ch)\t(0x00 + 4 * (ch))\n#define KMB_PWM_HIGHLOW_OFFSET(ch)\t(0x20 + 4 * (ch))\n\nstruct keembay_pwm {\n\tstruct pwm_chip chip;\n\tstruct device *dev;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n};\n\nstatic inline struct keembay_pwm *to_keembay_pwm_dev(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct keembay_pwm, chip);\n}\n\nstatic void keembay_clk_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int keembay_clk_enable(struct device *dev, struct clk *clk)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, keembay_clk_unprepare, clk);\n}\n\n \nstatic __always_inline void keembay_pwm_update_bits(struct keembay_pwm *priv, u32 mask,\n\t\t\t\t\t   u32 val, u32 offset)\n{\n\tu32 buff = readl(priv->base + offset);\n\n\tbuff = u32_replace_bits(buff, val, mask);\n\twritel(buff, priv->base + offset);\n}\n\nstatic void keembay_pwm_enable(struct keembay_pwm *priv, int ch)\n{\n\tkeembay_pwm_update_bits(priv, KMB_PWM_EN_BIT, 1,\n\t\t\t\tKMB_PWM_LEADIN_OFFSET(ch));\n}\n\nstatic void keembay_pwm_disable(struct keembay_pwm *priv, int ch)\n{\n\tkeembay_pwm_update_bits(priv, KMB_PWM_EN_BIT, 0,\n\t\t\t\tKMB_PWM_LEADIN_OFFSET(ch));\n}\n\nstatic int keembay_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t struct pwm_state *state)\n{\n\tstruct keembay_pwm *priv = to_keembay_pwm_dev(chip);\n\tunsigned long long high, low;\n\tunsigned long clk_rate;\n\tu32 highlow;\n\n\tclk_rate = clk_get_rate(priv->clk);\n\n\t \n\thighlow = readl(priv->base + KMB_PWM_LEADIN_OFFSET(pwm->hwpwm));\n\tif (highlow & KMB_PWM_EN_BIT)\n\t\tstate->enabled = true;\n\telse\n\t\tstate->enabled = false;\n\n\t \n\thighlow = readl(priv->base + KMB_PWM_HIGHLOW_OFFSET(pwm->hwpwm));\n\tlow = FIELD_GET(KMB_PWM_LOW_MASK, highlow) * NSEC_PER_SEC;\n\thigh = FIELD_GET(KMB_PWM_HIGH_MASK, highlow) * NSEC_PER_SEC;\n\tstate->duty_cycle = DIV_ROUND_UP_ULL(high, clk_rate);\n\tstate->period = DIV_ROUND_UP_ULL(high + low, clk_rate);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\treturn 0;\n}\n\nstatic int keembay_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tstruct keembay_pwm *priv = to_keembay_pwm_dev(chip);\n\tstruct pwm_state current_state;\n\tunsigned long long div;\n\tunsigned long clk_rate;\n\tu32 pwm_count = 0;\n\tu16 high, low;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\t \n\tkeembay_pwm_update_bits(priv, KMB_PWM_LEADIN_MASK, 0,\n\t\t\t\tKMB_PWM_LEADIN_OFFSET(pwm->hwpwm));\n\n\tkeembay_pwm_get_state(chip, pwm, &current_state);\n\n\tif (!state->enabled) {\n\t\tif (current_state.enabled)\n\t\t\tkeembay_pwm_disable(priv, pwm->hwpwm);\n\t\treturn 0;\n\t}\n\n\t \n\n\tclk_rate = clk_get_rate(priv->clk);\n\tdiv = clk_rate * state->duty_cycle;\n\tdiv = DIV_ROUND_DOWN_ULL(div, NSEC_PER_SEC);\n\tif (div > KMB_PWM_COUNT_MAX)\n\t\treturn -ERANGE;\n\n\thigh = div;\n\tdiv = clk_rate * state->period;\n\tdiv = DIV_ROUND_DOWN_ULL(div, NSEC_PER_SEC);\n\tdiv = div - high;\n\tif (div > KMB_PWM_COUNT_MAX)\n\t\treturn -ERANGE;\n\n\tlow = div;\n\n\tpwm_count = FIELD_PREP(KMB_PWM_HIGH_MASK, high) |\n\t\t    FIELD_PREP(KMB_PWM_LOW_MASK, low);\n\n\twritel(pwm_count, priv->base + KMB_PWM_HIGHLOW_OFFSET(pwm->hwpwm));\n\n\tif (state->enabled && !current_state.enabled)\n\t\tkeembay_pwm_enable(priv, pwm->hwpwm);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops keembay_pwm_ops = {\n\t.owner = THIS_MODULE,\n\t.apply = keembay_pwm_apply,\n\t.get_state = keembay_pwm_get_state,\n};\n\nstatic int keembay_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct keembay_pwm *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk), \"Failed to get clock\\n\");\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tret = keembay_clk_enable(dev, priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->chip.dev = dev;\n\tpriv->chip.ops = &keembay_pwm_ops;\n\tpriv->chip.npwm = KMB_TOTAL_PWM_CHANNELS;\n\n\tret = devm_pwmchip_add(dev, &priv->chip);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to add PWM chip\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id keembay_pwm_of_match[] = {\n\t{ .compatible = \"intel,keembay-pwm\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, keembay_pwm_of_match);\n\nstatic struct platform_driver keembay_pwm_driver = {\n\t.probe\t= keembay_pwm_probe,\n\t.driver\t= {\n\t\t.name = \"pwm-keembay\",\n\t\t.of_match_table = keembay_pwm_of_match,\n\t},\n};\nmodule_platform_driver(keembay_pwm_driver);\n\nMODULE_ALIAS(\"platform:pwm-keembay\");\nMODULE_DESCRIPTION(\"Intel Keem Bay PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}