{
  "module_name": "pwm-jz4740.c",
  "hash_id": "5eaad7b2d11236dc22235b4b31c7145d4d388aaa2dacac5ad6eef4290a651cf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-jz4740.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/kernel.h>\n#include <linux/mfd/ingenic-tcu.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n\nstruct soc_info {\n\tunsigned int num_pwms;\n};\n\nstruct jz4740_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct regmap *map;\n};\n\nstatic inline struct jz4740_pwm_chip *to_jz4740(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct jz4740_pwm_chip, chip);\n}\n\nstatic bool jz4740_pwm_can_use_chn(struct jz4740_pwm_chip *jz,\n\t\t\t\t   unsigned int channel)\n{\n\t \n\tu32 pwm_channels_mask = GENMASK(jz->chip.npwm - 1, 2);\n\n\tdevice_property_read_u32(jz->chip.dev->parent,\n\t\t\t\t \"ingenic,pwm-channels-mask\",\n\t\t\t\t &pwm_channels_mask);\n\n\treturn !!(pwm_channels_mask & BIT(channel));\n}\n\nstatic int jz4740_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct jz4740_pwm_chip *jz = to_jz4740(chip);\n\tstruct clk *clk;\n\tchar name[16];\n\tint err;\n\n\tif (!jz4740_pwm_can_use_chn(jz, pwm->hwpwm))\n\t\treturn -EBUSY;\n\n\tsnprintf(name, sizeof(name), \"timer%u\", pwm->hwpwm);\n\n\tclk = clk_get(chip->dev, name);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(chip->dev, \"error %pe: Failed to get clock\\n\", clk);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\terr = clk_prepare_enable(clk);\n\tif (err < 0) {\n\t\tclk_put(clk);\n\t\treturn err;\n\t}\n\n\tpwm_set_chip_data(pwm, clk);\n\n\treturn 0;\n}\n\nstatic void jz4740_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct clk *clk = pwm_get_chip_data(pwm);\n\n\tclk_disable_unprepare(clk);\n\tclk_put(clk);\n}\n\nstatic int jz4740_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct jz4740_pwm_chip *jz = to_jz4740(chip);\n\n\t \n\tregmap_set_bits(jz->map, TCU_REG_TCSRc(pwm->hwpwm), TCU_TCSR_PWM_EN);\n\n\t \n\tregmap_write(jz->map, TCU_REG_TESR, BIT(pwm->hwpwm));\n\n\treturn 0;\n}\n\nstatic void jz4740_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct jz4740_pwm_chip *jz = to_jz4740(chip);\n\n\t \n\tregmap_write(jz->map, TCU_REG_TDHRc(pwm->hwpwm), 0xffff);\n\tregmap_write(jz->map, TCU_REG_TDFRc(pwm->hwpwm), 0x0);\n\n\t \n\tregmap_clear_bits(jz->map, TCU_REG_TCSRc(pwm->hwpwm), TCU_TCSR_PWM_EN);\n\n\t \n\tregmap_write(jz->map, TCU_REG_TECR, BIT(pwm->hwpwm));\n}\n\nstatic int jz4740_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tstruct jz4740_pwm_chip *jz4740 = to_jz4740(pwm->chip);\n\tunsigned long long tmp = 0xffffull * NSEC_PER_SEC;\n\tstruct clk *clk = pwm_get_chip_data(pwm);\n\tunsigned long period, duty;\n\tlong rate;\n\tint err;\n\n\t \n\tdo_div(tmp, state->period);\n\n\t \n\trate = clk_round_rate(clk, tmp);\n\tif (rate < 0) {\n\t\tdev_err(chip->dev, \"Unable to round rate: %ld\", rate);\n\t\treturn rate;\n\t}\n\n\t \n\ttmp = (unsigned long long)rate * state->period;\n\tdo_div(tmp, NSEC_PER_SEC);\n\tperiod = tmp;\n\n\t \n\ttmp = (unsigned long long)rate * state->duty_cycle;\n\tdo_div(tmp, NSEC_PER_SEC);\n\tduty = tmp;\n\n\tif (duty >= period)\n\t\tduty = period - 1;\n\n\tjz4740_pwm_disable(chip, pwm);\n\n\terr = clk_set_rate(clk, rate);\n\tif (err) {\n\t\tdev_err(chip->dev, \"Unable to set rate: %d\", err);\n\t\treturn err;\n\t}\n\n\t \n\tregmap_write(jz4740->map, TCU_REG_TCNTc(pwm->hwpwm), 0);\n\n\t \n\tregmap_write(jz4740->map, TCU_REG_TDHRc(pwm->hwpwm), duty);\n\n\t \n\tregmap_write(jz4740->map, TCU_REG_TDFRc(pwm->hwpwm), period);\n\n\t \n\tregmap_set_bits(jz4740->map, TCU_REG_TCSRc(pwm->hwpwm),\n\t\t\tTCU_TCSR_PWM_SD);\n\n\t \n\tif ((state->polarity == PWM_POLARITY_NORMAL) ^ state->enabled)\n\t\tregmap_update_bits(jz4740->map, TCU_REG_TCSRc(pwm->hwpwm),\n\t\t\t\t   TCU_TCSR_PWM_INITL_HIGH, 0);\n\telse\n\t\tregmap_update_bits(jz4740->map, TCU_REG_TCSRc(pwm->hwpwm),\n\t\t\t\t   TCU_TCSR_PWM_INITL_HIGH,\n\t\t\t\t   TCU_TCSR_PWM_INITL_HIGH);\n\n\tif (state->enabled)\n\t\tjz4740_pwm_enable(chip, pwm);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops jz4740_pwm_ops = {\n\t.request = jz4740_pwm_request,\n\t.free = jz4740_pwm_free,\n\t.apply = jz4740_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int jz4740_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct jz4740_pwm_chip *jz4740;\n\tconst struct soc_info *info;\n\n\tinfo = device_get_match_data(dev);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tjz4740 = devm_kzalloc(dev, sizeof(*jz4740), GFP_KERNEL);\n\tif (!jz4740)\n\t\treturn -ENOMEM;\n\n\tjz4740->map = device_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(jz4740->map)) {\n\t\tdev_err(dev, \"regmap not found: %ld\\n\", PTR_ERR(jz4740->map));\n\t\treturn PTR_ERR(jz4740->map);\n\t}\n\n\tjz4740->chip.dev = dev;\n\tjz4740->chip.ops = &jz4740_pwm_ops;\n\tjz4740->chip.npwm = info->num_pwms;\n\n\treturn devm_pwmchip_add(dev, &jz4740->chip);\n}\n\nstatic const struct soc_info jz4740_soc_info = {\n\t.num_pwms = 8,\n};\n\nstatic const struct soc_info jz4725b_soc_info = {\n\t.num_pwms = 6,\n};\n\nstatic const struct soc_info x1000_soc_info = {\n\t.num_pwms = 5,\n};\n\nstatic const struct of_device_id jz4740_pwm_dt_ids[] = {\n\t{ .compatible = \"ingenic,jz4740-pwm\", .data = &jz4740_soc_info },\n\t{ .compatible = \"ingenic,jz4725b-pwm\", .data = &jz4725b_soc_info },\n\t{ .compatible = \"ingenic,x1000-pwm\", .data = &x1000_soc_info },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, jz4740_pwm_dt_ids);\n\nstatic struct platform_driver jz4740_pwm_driver = {\n\t.driver = {\n\t\t.name = \"jz4740-pwm\",\n\t\t.of_match_table = jz4740_pwm_dt_ids,\n\t},\n\t.probe = jz4740_pwm_probe,\n};\nmodule_platform_driver(jz4740_pwm_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"Ingenic JZ4740 PWM driver\");\nMODULE_ALIAS(\"platform:jz4740-pwm\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}