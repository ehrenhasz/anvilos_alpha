{
  "module_name": "pwm-spear.c",
  "hash_id": "84917242311aaa0b92f752843dc245d953bfd752166cb402dda225b30c2510fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-spear.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NUM_PWM\t\t4\n\n \n#define PWMCR\t\t\t0x00\t \n#define PWMCR_PWM_ENABLE\t0x1\n#define PWMCR_PRESCALE_SHIFT\t2\n#define PWMCR_MIN_PRESCALE\t0x00\n#define PWMCR_MAX_PRESCALE\t0x3FFF\n\n#define PWMDCR\t\t\t0x04\t \n#define PWMDCR_MIN_DUTY\t\t0x0001\n#define PWMDCR_MAX_DUTY\t\t0xFFFF\n\n#define PWMPCR\t\t\t0x08\t \n#define PWMPCR_MIN_PERIOD\t0x0001\n#define PWMPCR_MAX_PERIOD\t0xFFFF\n\n \n#define PWMMCR\t\t\t0x3C\t \n#define PWMMCR_PWM_ENABLE\t0x1\n\n \nstruct spear_pwm_chip {\n\tvoid __iomem *mmio_base;\n\tstruct clk *clk;\n\tstruct pwm_chip chip;\n};\n\nstatic inline struct spear_pwm_chip *to_spear_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct spear_pwm_chip, chip);\n}\n\nstatic inline u32 spear_pwm_readl(struct spear_pwm_chip *chip, unsigned int num,\n\t\t\t\t  unsigned long offset)\n{\n\treturn readl_relaxed(chip->mmio_base + (num << 4) + offset);\n}\n\nstatic inline void spear_pwm_writel(struct spear_pwm_chip *chip,\n\t\t\t\t    unsigned int num, unsigned long offset,\n\t\t\t\t    unsigned long val)\n{\n\twritel_relaxed(val, chip->mmio_base + (num << 4) + offset);\n}\n\nstatic int spear_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    u64 duty_ns, u64 period_ns)\n{\n\tstruct spear_pwm_chip *pc = to_spear_pwm_chip(chip);\n\tu64 val, div, clk_rate;\n\tunsigned long prescale = PWMCR_MIN_PRESCALE, pv, dc;\n\tint ret;\n\n\t \n\tclk_rate = clk_get_rate(pc->clk);\n\twhile (1) {\n\t\tdiv = 1000000000;\n\t\tdiv *= 1 + prescale;\n\t\tval = clk_rate * period_ns;\n\t\tpv = div64_u64(val, div);\n\t\tval = clk_rate * duty_ns;\n\t\tdc = div64_u64(val, div);\n\n\t\t \n\t\tif (pv < PWMPCR_MIN_PERIOD || dc < PWMDCR_MIN_DUTY)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (pv > PWMPCR_MAX_PERIOD || dc > PWMDCR_MAX_DUTY) {\n\t\t\tif (++prescale > PWMCR_MAX_PRESCALE)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tret = clk_enable(pc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tspear_pwm_writel(pc, pwm->hwpwm, PWMCR,\n\t\t\tprescale << PWMCR_PRESCALE_SHIFT);\n\tspear_pwm_writel(pc, pwm->hwpwm, PWMDCR, dc);\n\tspear_pwm_writel(pc, pwm->hwpwm, PWMPCR, pv);\n\tclk_disable(pc->clk);\n\n\treturn 0;\n}\n\nstatic int spear_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct spear_pwm_chip *pc = to_spear_pwm_chip(chip);\n\tint rc = 0;\n\tu32 val;\n\n\trc = clk_enable(pc->clk);\n\tif (rc)\n\t\treturn rc;\n\n\tval = spear_pwm_readl(pc, pwm->hwpwm, PWMCR);\n\tval |= PWMCR_PWM_ENABLE;\n\tspear_pwm_writel(pc, pwm->hwpwm, PWMCR, val);\n\n\treturn 0;\n}\n\nstatic void spear_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct spear_pwm_chip *pc = to_spear_pwm_chip(chip);\n\tu32 val;\n\n\tval = spear_pwm_readl(pc, pwm->hwpwm, PWMCR);\n\tval &= ~PWMCR_PWM_ENABLE;\n\tspear_pwm_writel(pc, pwm->hwpwm, PWMCR, val);\n\n\tclk_disable(pc->clk);\n}\n\nstatic int spear_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled)\n\t\t\tspear_pwm_disable(chip, pwm);\n\t\treturn 0;\n\t}\n\n\terr = spear_pwm_config(chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\treturn spear_pwm_enable(chip, pwm);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops spear_pwm_ops = {\n\t.apply = spear_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int spear_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spear_pwm_chip *pc;\n\tint ret;\n\tu32 val;\n\n\tpc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tpc->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->mmio_base))\n\t\treturn PTR_ERR(pc->mmio_base);\n\n\tpc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pc->clk))\n\t\treturn PTR_ERR(pc->clk);\n\n\tplatform_set_drvdata(pdev, pc);\n\n\tpc->chip.dev = &pdev->dev;\n\tpc->chip.ops = &spear_pwm_ops;\n\tpc->chip.npwm = NUM_PWM;\n\n\tret = clk_prepare(pc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_device_is_compatible(np, \"st,spear1340-pwm\")) {\n\t\tret = clk_enable(pc->clk);\n\t\tif (ret) {\n\t\t\tclk_unprepare(pc->clk);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tval = readl_relaxed(pc->mmio_base + PWMMCR);\n\t\tval |= PWMMCR_PWM_ENABLE;\n\t\twritel_relaxed(val, pc->mmio_base + PWMMCR);\n\n\t\tclk_disable(pc->clk);\n\t}\n\n\tret = pwmchip_add(&pc->chip);\n\tif (ret < 0) {\n\t\tclk_unprepare(pc->clk);\n\t\tdev_err(&pdev->dev, \"pwmchip_add() failed: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void spear_pwm_remove(struct platform_device *pdev)\n{\n\tstruct spear_pwm_chip *pc = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&pc->chip);\n\n\t \n\tclk_unprepare(pc->clk);\n}\n\nstatic const struct of_device_id spear_pwm_of_match[] = {\n\t{ .compatible = \"st,spear320-pwm\" },\n\t{ .compatible = \"st,spear1340-pwm\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, spear_pwm_of_match);\n\nstatic struct platform_driver spear_pwm_driver = {\n\t.driver = {\n\t\t.name = \"spear-pwm\",\n\t\t.of_match_table = spear_pwm_of_match,\n\t},\n\t.probe = spear_pwm_probe,\n\t.remove_new = spear_pwm_remove,\n};\n\nmodule_platform_driver(spear_pwm_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Shiraz Hashim <shiraz.linux.kernel@gmail.com>\");\nMODULE_AUTHOR(\"Viresh Kumar <viresh.kumar@linaro.com>\");\nMODULE_ALIAS(\"platform:spear-pwm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}