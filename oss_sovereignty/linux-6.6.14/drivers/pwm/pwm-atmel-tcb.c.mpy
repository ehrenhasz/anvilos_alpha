{
  "module_name": "pwm-atmel-tcb.c",
  "hash_id": "20ef45ed7a76457de27c6e6f1038a0769fb5a685b2d14ccc762ae8f4c33e0e89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-atmel-tcb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/clockchips.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <soc/at91/atmel_tcb.h>\n\n#define NPWM\t2\n\n#define ATMEL_TC_ACMR_MASK\t(ATMEL_TC_ACPA | ATMEL_TC_ACPC |\t\\\n\t\t\t\t ATMEL_TC_AEEVT | ATMEL_TC_ASWTRG)\n\n#define ATMEL_TC_BCMR_MASK\t(ATMEL_TC_BCPB | ATMEL_TC_BCPC |\t\\\n\t\t\t\t ATMEL_TC_BEEVT | ATMEL_TC_BSWTRG)\n\nstruct atmel_tcb_pwm_device {\n\tunsigned div;\t\t\t \n\tunsigned duty;\t\t\t \n\tunsigned period;\t\t \n};\n\nstruct atmel_tcb_channel {\n\tu32 enabled;\n\tu32 cmr;\n\tu32 ra;\n\tu32 rb;\n\tu32 rc;\n};\n\nstruct atmel_tcb_pwm_chip {\n\tstruct pwm_chip chip;\n\tspinlock_t lock;\n\tu8 channel;\n\tu8 width;\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tstruct clk *gclk;\n\tstruct clk *slow_clk;\n\tstruct atmel_tcb_pwm_device pwms[NPWM];\n\tstruct atmel_tcb_channel bkup;\n};\n\nstatic const u8 atmel_tcb_divisors[] = { 2, 8, 32, 128, 0, };\n\nstatic inline struct atmel_tcb_pwm_chip *to_tcb_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct atmel_tcb_pwm_chip, chip);\n}\n\nstatic int atmel_tcb_pwm_request(struct pwm_chip *chip,\n\t\t\t\t struct pwm_device *pwm)\n{\n\tstruct atmel_tcb_pwm_chip *tcbpwmc = to_tcb_chip(chip);\n\tstruct atmel_tcb_pwm_device *tcbpwm = &tcbpwmc->pwms[pwm->hwpwm];\n\tunsigned cmr;\n\tint ret;\n\n\tret = clk_prepare_enable(tcbpwmc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\ttcbpwm->duty = 0;\n\ttcbpwm->period = 0;\n\ttcbpwm->div = 0;\n\n\tspin_lock(&tcbpwmc->lock);\n\tregmap_read(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, CMR), &cmr);\n\t \n\tif (cmr & ATMEL_TC_WAVE) {\n\t\tif (pwm->hwpwm == 0)\n\t\t\tregmap_read(tcbpwmc->regmap,\n\t\t\t\t    ATMEL_TC_REG(tcbpwmc->channel, RA),\n\t\t\t\t    &tcbpwm->duty);\n\t\telse\n\t\t\tregmap_read(tcbpwmc->regmap,\n\t\t\t\t    ATMEL_TC_REG(tcbpwmc->channel, RB),\n\t\t\t\t    &tcbpwm->duty);\n\n\t\ttcbpwm->div = cmr & ATMEL_TC_TCCLKS;\n\t\tregmap_read(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, RC),\n\t\t\t    &tcbpwm->period);\n\t\tcmr &= (ATMEL_TC_TCCLKS | ATMEL_TC_ACMR_MASK |\n\t\t\tATMEL_TC_BCMR_MASK);\n\t} else\n\t\tcmr = 0;\n\n\tcmr |= ATMEL_TC_WAVE | ATMEL_TC_WAVESEL_UP_AUTO | ATMEL_TC_EEVT_XC0;\n\tregmap_write(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, CMR), cmr);\n\tspin_unlock(&tcbpwmc->lock);\n\n\treturn 0;\n}\n\nstatic void atmel_tcb_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct atmel_tcb_pwm_chip *tcbpwmc = to_tcb_chip(chip);\n\n\tclk_disable_unprepare(tcbpwmc->clk);\n}\n\nstatic void atmel_tcb_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t  enum pwm_polarity polarity)\n{\n\tstruct atmel_tcb_pwm_chip *tcbpwmc = to_tcb_chip(chip);\n\tstruct atmel_tcb_pwm_device *tcbpwm = &tcbpwmc->pwms[pwm->hwpwm];\n\tunsigned cmr;\n\n\t \n\tif (tcbpwm->duty == 0)\n\t\tpolarity = !polarity;\n\n\tspin_lock(&tcbpwmc->lock);\n\tregmap_read(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, CMR), &cmr);\n\n\t \n\tif (pwm->hwpwm == 0) {\n\t\tcmr &= ~ATMEL_TC_ACMR_MASK;\n\t\tif (polarity == PWM_POLARITY_INVERSED)\n\t\t\tcmr |= ATMEL_TC_ASWTRG_CLEAR;\n\t\telse\n\t\t\tcmr |= ATMEL_TC_ASWTRG_SET;\n\t} else {\n\t\tcmr &= ~ATMEL_TC_BCMR_MASK;\n\t\tif (polarity == PWM_POLARITY_INVERSED)\n\t\t\tcmr |= ATMEL_TC_BSWTRG_CLEAR;\n\t\telse\n\t\t\tcmr |= ATMEL_TC_BSWTRG_SET;\n\t}\n\n\tregmap_write(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, CMR), cmr);\n\n\t \n\tif (!(cmr & (ATMEL_TC_ACPC | ATMEL_TC_BCPC))) {\n\t\tregmap_write(tcbpwmc->regmap,\n\t\t\t     ATMEL_TC_REG(tcbpwmc->channel, CCR),\n\t\t\t     ATMEL_TC_SWTRG | ATMEL_TC_CLKDIS);\n\t\ttcbpwmc->bkup.enabled = 1;\n\t} else {\n\t\tregmap_write(tcbpwmc->regmap,\n\t\t\t     ATMEL_TC_REG(tcbpwmc->channel, CCR),\n\t\t\t     ATMEL_TC_SWTRG);\n\t\ttcbpwmc->bkup.enabled = 0;\n\t}\n\n\tspin_unlock(&tcbpwmc->lock);\n}\n\nstatic int atmel_tcb_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\tenum pwm_polarity polarity)\n{\n\tstruct atmel_tcb_pwm_chip *tcbpwmc = to_tcb_chip(chip);\n\tstruct atmel_tcb_pwm_device *tcbpwm = &tcbpwmc->pwms[pwm->hwpwm];\n\tu32 cmr;\n\n\t \n\tif (tcbpwm->duty == 0)\n\t\tpolarity = !polarity;\n\n\tspin_lock(&tcbpwmc->lock);\n\tregmap_read(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, CMR), &cmr);\n\n\t \n\tcmr &= ~ATMEL_TC_TCCLKS;\n\n\tif (pwm->hwpwm == 0) {\n\t\tcmr &= ~ATMEL_TC_ACMR_MASK;\n\n\t\t \n\t\tif (polarity == PWM_POLARITY_INVERSED)\n\t\t\tcmr |= ATMEL_TC_ASWTRG_CLEAR;\n\t\telse\n\t\t\tcmr |= ATMEL_TC_ASWTRG_SET;\n\t} else {\n\t\tcmr &= ~ATMEL_TC_BCMR_MASK;\n\t\tif (polarity == PWM_POLARITY_INVERSED)\n\t\t\tcmr |= ATMEL_TC_BSWTRG_CLEAR;\n\t\telse\n\t\t\tcmr |= ATMEL_TC_BSWTRG_SET;\n\t}\n\n\t \n\tif (tcbpwm->duty != tcbpwm->period && tcbpwm->duty > 0) {\n\t\tif (pwm->hwpwm == 0) {\n\t\t\tif (polarity == PWM_POLARITY_INVERSED)\n\t\t\t\tcmr |= ATMEL_TC_ACPA_SET | ATMEL_TC_ACPC_CLEAR;\n\t\t\telse\n\t\t\t\tcmr |= ATMEL_TC_ACPA_CLEAR | ATMEL_TC_ACPC_SET;\n\t\t} else {\n\t\t\tif (polarity == PWM_POLARITY_INVERSED)\n\t\t\t\tcmr |= ATMEL_TC_BCPB_SET | ATMEL_TC_BCPC_CLEAR;\n\t\t\telse\n\t\t\t\tcmr |= ATMEL_TC_BCPB_CLEAR | ATMEL_TC_BCPC_SET;\n\t\t}\n\t}\n\n\tcmr |= (tcbpwm->div & ATMEL_TC_TCCLKS);\n\n\tregmap_write(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, CMR), cmr);\n\n\tif (pwm->hwpwm == 0)\n\t\tregmap_write(tcbpwmc->regmap,\n\t\t\t     ATMEL_TC_REG(tcbpwmc->channel, RA),\n\t\t\t     tcbpwm->duty);\n\telse\n\t\tregmap_write(tcbpwmc->regmap,\n\t\t\t     ATMEL_TC_REG(tcbpwmc->channel, RB),\n\t\t\t     tcbpwm->duty);\n\n\tregmap_write(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, RC),\n\t\t     tcbpwm->period);\n\n\t \n\tregmap_write(tcbpwmc->regmap, ATMEL_TC_REG(tcbpwmc->channel, CCR),\n\t\t     ATMEL_TC_SWTRG | ATMEL_TC_CLKEN);\n\ttcbpwmc->bkup.enabled = 1;\n\tspin_unlock(&tcbpwmc->lock);\n\treturn 0;\n}\n\nstatic int atmel_tcb_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\tint duty_ns, int period_ns)\n{\n\tstruct atmel_tcb_pwm_chip *tcbpwmc = to_tcb_chip(chip);\n\tstruct atmel_tcb_pwm_device *tcbpwm = &tcbpwmc->pwms[pwm->hwpwm];\n\tstruct atmel_tcb_pwm_device *atcbpwm = NULL;\n\tint i = 0;\n\tint slowclk = 0;\n\tunsigned period;\n\tunsigned duty;\n\tunsigned rate = clk_get_rate(tcbpwmc->clk);\n\tunsigned long long min;\n\tunsigned long long max;\n\n\t \n\tif (tcbpwmc->gclk)\n\t\ti = 1;\n\tfor (; i < ARRAY_SIZE(atmel_tcb_divisors); ++i) {\n\t\tif (atmel_tcb_divisors[i] == 0) {\n\t\t\tslowclk = i;\n\t\t\tcontinue;\n\t\t}\n\t\tmin = div_u64((u64)NSEC_PER_SEC * atmel_tcb_divisors[i], rate);\n\t\tmax = min << tcbpwmc->width;\n\t\tif (max >= period_ns)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == ARRAY_SIZE(atmel_tcb_divisors)) {\n\t\ti = slowclk;\n\t\trate = clk_get_rate(tcbpwmc->slow_clk);\n\t\tmin = div_u64(NSEC_PER_SEC, rate);\n\t\tmax = min << tcbpwmc->width;\n\n\t\t \n\t\tif (max < period_ns)\n\t\t\treturn -ERANGE;\n\t}\n\n\tduty = div_u64(duty_ns, min);\n\tperiod = div_u64(period_ns, min);\n\n\tif (pwm->hwpwm == 0)\n\t\tatcbpwm = &tcbpwmc->pwms[1];\n\telse\n\t\tatcbpwm = &tcbpwmc->pwms[0];\n\n\t \n\tif ((atcbpwm && atcbpwm->duty > 0 &&\n\t\t\tatcbpwm->duty != atcbpwm->period) &&\n\t\t(atcbpwm->div != i || atcbpwm->period != period)) {\n\t\tdev_err(chip->dev,\n\t\t\t\"failed to configure period_ns: PWM group already configured with a different value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttcbpwm->period = period;\n\ttcbpwm->div = i;\n\ttcbpwm->duty = duty;\n\n\treturn 0;\n}\n\nstatic int atmel_tcb_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       const struct pwm_state *state)\n{\n\tint duty_cycle, period;\n\tint ret;\n\n\tif (!state->enabled) {\n\t\tatmel_tcb_pwm_disable(chip, pwm, state->polarity);\n\t\treturn 0;\n\t}\n\n\tperiod = state->period < INT_MAX ? state->period : INT_MAX;\n\tduty_cycle = state->duty_cycle < INT_MAX ? state->duty_cycle : INT_MAX;\n\n\tret = atmel_tcb_pwm_config(chip, pwm, duty_cycle, period);\n\tif (ret)\n\t\treturn ret;\n\n\treturn atmel_tcb_pwm_enable(chip, pwm, state->polarity);\n}\n\nstatic const struct pwm_ops atmel_tcb_pwm_ops = {\n\t.request = atmel_tcb_pwm_request,\n\t.free = atmel_tcb_pwm_free,\n\t.apply = atmel_tcb_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct atmel_tcb_config tcb_rm9200_config = {\n\t.counter_width = 16,\n};\n\nstatic struct atmel_tcb_config tcb_sam9x5_config = {\n\t.counter_width = 32,\n};\n\nstatic struct atmel_tcb_config tcb_sama5d2_config = {\n\t.counter_width = 32,\n\t.has_gclk = 1,\n};\n\nstatic const struct of_device_id atmel_tcb_of_match[] = {\n\t{ .compatible = \"atmel,at91rm9200-tcb\", .data = &tcb_rm9200_config, },\n\t{ .compatible = \"atmel,at91sam9x5-tcb\", .data = &tcb_sam9x5_config, },\n\t{ .compatible = \"atmel,sama5d2-tcb\", .data = &tcb_sama5d2_config, },\n\t{   }\n};\n\nstatic int atmel_tcb_pwm_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct atmel_tcb_pwm_chip *tcbpwm;\n\tconst struct atmel_tcb_config *config;\n\tstruct device_node *np = pdev->dev.of_node;\n\tchar clk_name[] = \"t0_clk\";\n\tint err;\n\tint channel;\n\n\ttcbpwm = devm_kzalloc(&pdev->dev, sizeof(*tcbpwm), GFP_KERNEL);\n\tif (tcbpwm == NULL)\n\t\treturn -ENOMEM;\n\n\terr = of_property_read_u32(np, \"reg\", &channel);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get Timer Counter Block channel from device tree (error: %d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\ttcbpwm->regmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(tcbpwm->regmap))\n\t\treturn PTR_ERR(tcbpwm->regmap);\n\n\ttcbpwm->slow_clk = of_clk_get_by_name(np->parent, \"slow_clk\");\n\tif (IS_ERR(tcbpwm->slow_clk))\n\t\treturn PTR_ERR(tcbpwm->slow_clk);\n\n\tclk_name[1] += channel;\n\ttcbpwm->clk = of_clk_get_by_name(np->parent, clk_name);\n\tif (IS_ERR(tcbpwm->clk))\n\t\ttcbpwm->clk = of_clk_get_by_name(np->parent, \"t0_clk\");\n\tif (IS_ERR(tcbpwm->clk)) {\n\t\terr = PTR_ERR(tcbpwm->clk);\n\t\tgoto err_slow_clk;\n\t}\n\n\tmatch = of_match_node(atmel_tcb_of_match, np->parent);\n\tconfig = match->data;\n\n\tif (config->has_gclk) {\n\t\ttcbpwm->gclk = of_clk_get_by_name(np->parent, \"gclk\");\n\t\tif (IS_ERR(tcbpwm->gclk)) {\n\t\t\terr = PTR_ERR(tcbpwm->gclk);\n\t\t\tgoto err_clk;\n\t\t}\n\t}\n\n\ttcbpwm->chip.dev = &pdev->dev;\n\ttcbpwm->chip.ops = &atmel_tcb_pwm_ops;\n\ttcbpwm->chip.npwm = NPWM;\n\ttcbpwm->channel = channel;\n\ttcbpwm->width = config->counter_width;\n\n\terr = clk_prepare_enable(tcbpwm->slow_clk);\n\tif (err)\n\t\tgoto err_gclk;\n\n\tspin_lock_init(&tcbpwm->lock);\n\n\terr = pwmchip_add(&tcbpwm->chip);\n\tif (err < 0)\n\t\tgoto err_disable_clk;\n\n\tplatform_set_drvdata(pdev, tcbpwm);\n\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(tcbpwm->slow_clk);\n\nerr_gclk:\n\tclk_put(tcbpwm->gclk);\n\nerr_clk:\n\tclk_put(tcbpwm->clk);\n\nerr_slow_clk:\n\tclk_put(tcbpwm->slow_clk);\n\n\treturn err;\n}\n\nstatic void atmel_tcb_pwm_remove(struct platform_device *pdev)\n{\n\tstruct atmel_tcb_pwm_chip *tcbpwm = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&tcbpwm->chip);\n\n\tclk_disable_unprepare(tcbpwm->slow_clk);\n\tclk_put(tcbpwm->gclk);\n\tclk_put(tcbpwm->clk);\n\tclk_put(tcbpwm->slow_clk);\n}\n\nstatic const struct of_device_id atmel_tcb_pwm_dt_ids[] = {\n\t{ .compatible = \"atmel,tcb-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, atmel_tcb_pwm_dt_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int atmel_tcb_pwm_suspend(struct device *dev)\n{\n\tstruct atmel_tcb_pwm_chip *tcbpwm = dev_get_drvdata(dev);\n\tstruct atmel_tcb_channel *chan = &tcbpwm->bkup;\n\tunsigned int channel = tcbpwm->channel;\n\n\tregmap_read(tcbpwm->regmap, ATMEL_TC_REG(channel, CMR), &chan->cmr);\n\tregmap_read(tcbpwm->regmap, ATMEL_TC_REG(channel, RA), &chan->ra);\n\tregmap_read(tcbpwm->regmap, ATMEL_TC_REG(channel, RB), &chan->rb);\n\tregmap_read(tcbpwm->regmap, ATMEL_TC_REG(channel, RC), &chan->rc);\n\n\treturn 0;\n}\n\nstatic int atmel_tcb_pwm_resume(struct device *dev)\n{\n\tstruct atmel_tcb_pwm_chip *tcbpwm = dev_get_drvdata(dev);\n\tstruct atmel_tcb_channel *chan = &tcbpwm->bkup;\n\tunsigned int channel = tcbpwm->channel;\n\n\tregmap_write(tcbpwm->regmap, ATMEL_TC_REG(channel, CMR), chan->cmr);\n\tregmap_write(tcbpwm->regmap, ATMEL_TC_REG(channel, RA), chan->ra);\n\tregmap_write(tcbpwm->regmap, ATMEL_TC_REG(channel, RB), chan->rb);\n\tregmap_write(tcbpwm->regmap, ATMEL_TC_REG(channel, RC), chan->rc);\n\n\tif (chan->enabled)\n\t\tregmap_write(tcbpwm->regmap,\n\t\t\t     ATMEL_TC_CLKEN | ATMEL_TC_SWTRG,\n\t\t\t     ATMEL_TC_REG(channel, CCR));\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(atmel_tcb_pwm_pm_ops, atmel_tcb_pwm_suspend,\n\t\t\t atmel_tcb_pwm_resume);\n\nstatic struct platform_driver atmel_tcb_pwm_driver = {\n\t.driver = {\n\t\t.name = \"atmel-tcb-pwm\",\n\t\t.of_match_table = atmel_tcb_pwm_dt_ids,\n\t\t.pm = &atmel_tcb_pwm_pm_ops,\n\t},\n\t.probe = atmel_tcb_pwm_probe,\n\t.remove_new = atmel_tcb_pwm_remove,\n};\nmodule_platform_driver(atmel_tcb_pwm_driver);\n\nMODULE_AUTHOR(\"Boris BREZILLON <b.brezillon@overkiz.com>\");\nMODULE_DESCRIPTION(\"Atmel Timer Counter Pulse Width Modulation Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}