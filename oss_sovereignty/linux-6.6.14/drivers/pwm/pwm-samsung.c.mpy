{
  "module_name": "pwm-samsung.c",
  "hash_id": "d003929e635026b976e05023cd048254190603a4383b08ddc92d771b242c9b8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-samsung.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n\n \n#include <clocksource/samsung_pwm.h>\n\n#define REG_TCFG0\t\t\t0x00\n#define REG_TCFG1\t\t\t0x04\n#define REG_TCON\t\t\t0x08\n\n#define REG_TCNTB(chan)\t\t\t(0x0c + ((chan) * 0xc))\n#define REG_TCMPB(chan)\t\t\t(0x10 + ((chan) * 0xc))\n\n#define TCFG0_PRESCALER_MASK\t\t0xff\n#define TCFG0_PRESCALER1_SHIFT\t\t8\n\n#define TCFG1_MUX_MASK\t\t\t0xf\n#define TCFG1_SHIFT(chan)\t\t(4 * (chan))\n\n \n#define TCON_START(chan)\t\tBIT(4 * (chan) + 0)\n#define TCON_MANUALUPDATE(chan)\t\tBIT(4 * (chan) + 1)\n#define TCON_INVERT(chan)\t\tBIT(4 * (chan) + 2)\n#define _TCON_AUTORELOAD(chan)\t\tBIT(4 * (chan) + 3)\n#define _TCON_AUTORELOAD4(chan)\t\tBIT(4 * (chan) + 2)\n#define TCON_AUTORELOAD(chan)\t\t\\\n\t((chan < 5) ? _TCON_AUTORELOAD(chan) : _TCON_AUTORELOAD4(chan))\n\n \nstruct samsung_pwm_channel {\n\tu32 period_ns;\n\tu32 duty_ns;\n\tu32 tin_ns;\n};\n\n \nstruct samsung_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct samsung_pwm_variant variant;\n\tu8 inverter_mask;\n\tu8 disabled_mask;\n\n\tvoid __iomem *base;\n\tstruct clk *base_clk;\n\tstruct clk *tclk0;\n\tstruct clk *tclk1;\n};\n\n#ifndef CONFIG_CLKSRC_SAMSUNG_PWM\n \nstatic DEFINE_SPINLOCK(samsung_pwm_lock);\n#endif\n\nstatic inline\nstruct samsung_pwm_chip *to_samsung_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct samsung_pwm_chip, chip);\n}\n\nstatic inline unsigned int to_tcon_channel(unsigned int channel)\n{\n\t \n\treturn (channel == 0) ? 0 : (channel + 1);\n}\n\nstatic void __pwm_samsung_manual_update(struct samsung_pwm_chip *chip,\n\t\t\t\t      struct pwm_device *pwm)\n{\n\tunsigned int tcon_chan = to_tcon_channel(pwm->hwpwm);\n\tu32 tcon;\n\n\ttcon = readl(chip->base + REG_TCON);\n\ttcon |= TCON_MANUALUPDATE(tcon_chan);\n\twritel(tcon, chip->base + REG_TCON);\n\n\ttcon &= ~TCON_MANUALUPDATE(tcon_chan);\n\twritel(tcon, chip->base + REG_TCON);\n}\n\nstatic void pwm_samsung_set_divisor(struct samsung_pwm_chip *pwm,\n\t\t\t\t    unsigned int channel, u8 divisor)\n{\n\tu8 shift = TCFG1_SHIFT(channel);\n\tunsigned long flags;\n\tu32 reg;\n\tu8 bits;\n\n\tbits = (fls(divisor) - 1) - pwm->variant.div_base;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\treg = readl(pwm->base + REG_TCFG1);\n\treg &= ~(TCFG1_MUX_MASK << shift);\n\treg |= bits << shift;\n\twritel(reg, pwm->base + REG_TCFG1);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic int pwm_samsung_is_tdiv(struct samsung_pwm_chip *chip, unsigned int chan)\n{\n\tstruct samsung_pwm_variant *variant = &chip->variant;\n\tu32 reg;\n\n\treg = readl(chip->base + REG_TCFG1);\n\treg >>= TCFG1_SHIFT(chan);\n\treg &= TCFG1_MUX_MASK;\n\n\treturn (BIT(reg) & variant->tclk_mask) == 0;\n}\n\nstatic unsigned long pwm_samsung_get_tin_rate(struct samsung_pwm_chip *chip,\n\t\t\t\t\t      unsigned int chan)\n{\n\tunsigned long rate;\n\tu32 reg;\n\n\trate = clk_get_rate(chip->base_clk);\n\n\treg = readl(chip->base + REG_TCFG0);\n\tif (chan >= 2)\n\t\treg >>= TCFG0_PRESCALER1_SHIFT;\n\treg &= TCFG0_PRESCALER_MASK;\n\n\treturn rate / (reg + 1);\n}\n\nstatic unsigned long pwm_samsung_calc_tin(struct samsung_pwm_chip *chip,\n\t\t\t\t\t  unsigned int chan, unsigned long freq)\n{\n\tstruct samsung_pwm_variant *variant = &chip->variant;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tu8 div;\n\n\tif (!pwm_samsung_is_tdiv(chip, chan)) {\n\t\tclk = (chan < 2) ? chip->tclk0 : chip->tclk1;\n\t\tif (!IS_ERR(clk)) {\n\t\t\trate = clk_get_rate(clk);\n\t\t\tif (rate)\n\t\t\t\treturn rate;\n\t\t}\n\n\t\tdev_warn(chip->chip.dev,\n\t\t\t\"tclk of PWM %d is inoperational, using tdiv\\n\", chan);\n\t}\n\n\trate = pwm_samsung_get_tin_rate(chip, chan);\n\tdev_dbg(chip->chip.dev, \"tin parent at %lu\\n\", rate);\n\n\t \n\tif (variant->bits < 32) {\n\t\t \n\t\tfor (div = variant->div_base; div < 4; ++div)\n\t\t\tif ((rate >> (variant->bits + div)) < freq)\n\t\t\t\tbreak;\n\t} else {\n\t\t \n\t\tdiv = variant->div_base;\n\t}\n\n\tpwm_samsung_set_divisor(chip, chan, BIT(div));\n\n\treturn rate >> div;\n}\n\nstatic int pwm_samsung_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\n\tstruct samsung_pwm_channel *our_chan;\n\n\tif (!(our_chip->variant.output_mask & BIT(pwm->hwpwm))) {\n\t\tdev_warn(chip->dev,\n\t\t\t\"tried to request PWM channel %d without output\\n\",\n\t\t\tpwm->hwpwm);\n\t\treturn -EINVAL;\n\t}\n\n\tour_chan = kzalloc(sizeof(*our_chan), GFP_KERNEL);\n\tif (!our_chan)\n\t\treturn -ENOMEM;\n\n\tpwm_set_chip_data(pwm, our_chan);\n\n\treturn 0;\n}\n\nstatic void pwm_samsung_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tkfree(pwm_get_chip_data(pwm));\n}\n\nstatic int pwm_samsung_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\n\tunsigned int tcon_chan = to_tcon_channel(pwm->hwpwm);\n\tunsigned long flags;\n\tu32 tcon;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\ttcon = readl(our_chip->base + REG_TCON);\n\n\ttcon &= ~TCON_START(tcon_chan);\n\ttcon |= TCON_MANUALUPDATE(tcon_chan);\n\twritel(tcon, our_chip->base + REG_TCON);\n\n\ttcon &= ~TCON_MANUALUPDATE(tcon_chan);\n\ttcon |= TCON_START(tcon_chan) | TCON_AUTORELOAD(tcon_chan);\n\twritel(tcon, our_chip->base + REG_TCON);\n\n\tour_chip->disabled_mask &= ~BIT(pwm->hwpwm);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n\n\treturn 0;\n}\n\nstatic void pwm_samsung_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\n\tunsigned int tcon_chan = to_tcon_channel(pwm->hwpwm);\n\tunsigned long flags;\n\tu32 tcon;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\ttcon = readl(our_chip->base + REG_TCON);\n\ttcon &= ~TCON_AUTORELOAD(tcon_chan);\n\twritel(tcon, our_chip->base + REG_TCON);\n\n\t \n\tif (readl(our_chip->base + REG_TCMPB(pwm->hwpwm)) == (u32)-1U)\n\t\t__pwm_samsung_manual_update(our_chip, pwm);\n\n\tour_chip->disabled_mask |= BIT(pwm->hwpwm);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic void pwm_samsung_manual_update(struct samsung_pwm_chip *chip,\n\t\t\t\t      struct pwm_device *pwm)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\t__pwm_samsung_manual_update(chip, pwm);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic int __pwm_samsung_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\tint duty_ns, int period_ns, bool force_period)\n{\n\tstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\n\tstruct samsung_pwm_channel *chan = pwm_get_chip_data(pwm);\n\tu32 tin_ns = chan->tin_ns, tcnt, tcmp, oldtcmp;\n\n\ttcnt = readl(our_chip->base + REG_TCNTB(pwm->hwpwm));\n\toldtcmp = readl(our_chip->base + REG_TCMPB(pwm->hwpwm));\n\n\t \n\t++tcnt;\n\n\t \n\tif (chan->period_ns != period_ns || force_period) {\n\t\tunsigned long tin_rate;\n\t\tu32 period;\n\n\t\tperiod = NSEC_PER_SEC / period_ns;\n\n\t\tdev_dbg(our_chip->chip.dev, \"duty_ns=%d, period_ns=%d (%u)\\n\",\n\t\t\t\t\t\tduty_ns, period_ns, period);\n\n\t\ttin_rate = pwm_samsung_calc_tin(our_chip, pwm->hwpwm, period);\n\n\t\tdev_dbg(our_chip->chip.dev, \"tin_rate=%lu\\n\", tin_rate);\n\n\t\ttin_ns = NSEC_PER_SEC / tin_rate;\n\t\ttcnt = period_ns / tin_ns;\n\t}\n\n\t \n\tif (tcnt <= 1)\n\t\treturn -ERANGE;\n\n\t \n\ttcmp = duty_ns / tin_ns;\n\n\t \n\tif (!tcmp)\n\t\t++tcmp;\n\n\ttcmp = tcnt - tcmp;\n\n\t \n\t--tcnt;\n\t \n\t--tcmp;\n\n\tdev_dbg(our_chip->chip.dev,\n\t\t\t\t\"tin_ns=%u, tcmp=%u/%u\\n\", tin_ns, tcmp, tcnt);\n\n\t \n\twritel(tcnt, our_chip->base + REG_TCNTB(pwm->hwpwm));\n\twritel(tcmp, our_chip->base + REG_TCMPB(pwm->hwpwm));\n\n\t \n\tif (oldtcmp == (u32) -1) {\n\t\tdev_dbg(our_chip->chip.dev, \"Forcing manual update\");\n\t\tpwm_samsung_manual_update(our_chip, pwm);\n\t}\n\n\tchan->period_ns = period_ns;\n\tchan->tin_ns = tin_ns;\n\tchan->duty_ns = duty_ns;\n\n\treturn 0;\n}\n\nstatic int pwm_samsung_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      int duty_ns, int period_ns)\n{\n\treturn __pwm_samsung_config(chip, pwm, duty_ns, period_ns, false);\n}\n\nstatic void pwm_samsung_set_invert(struct samsung_pwm_chip *chip,\n\t\t\t\t   unsigned int channel, bool invert)\n{\n\tunsigned int tcon_chan = to_tcon_channel(channel);\n\tunsigned long flags;\n\tu32 tcon;\n\n\tspin_lock_irqsave(&samsung_pwm_lock, flags);\n\n\ttcon = readl(chip->base + REG_TCON);\n\n\tif (invert) {\n\t\tchip->inverter_mask |= BIT(channel);\n\t\ttcon |= TCON_INVERT(tcon_chan);\n\t} else {\n\t\tchip->inverter_mask &= ~BIT(channel);\n\t\ttcon &= ~TCON_INVERT(tcon_chan);\n\t}\n\n\twritel(tcon, chip->base + REG_TCON);\n\n\tspin_unlock_irqrestore(&samsung_pwm_lock, flags);\n}\n\nstatic int pwm_samsung_set_polarity(struct pwm_chip *chip,\n\t\t\t\t    struct pwm_device *pwm,\n\t\t\t\t    enum pwm_polarity polarity)\n{\n\tstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\n\tbool invert = (polarity == PWM_POLARITY_NORMAL);\n\n\t \n\tpwm_samsung_set_invert(our_chip, pwm->hwpwm, invert);\n\n\treturn 0;\n}\n\nstatic int pwm_samsung_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tint err, enabled = pwm->state.enabled;\n\n\tif (state->polarity != pwm->state.polarity) {\n\t\tif (enabled) {\n\t\t\tpwm_samsung_disable(chip, pwm);\n\t\t\tenabled = false;\n\t\t}\n\n\t\terr = pwm_samsung_set_polarity(chip, pwm, state->polarity);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\tpwm_samsung_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (state->period > NSEC_PER_SEC)\n\t\treturn -ERANGE;\n\n\terr = pwm_samsung_config(chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\terr = pwm_samsung_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops pwm_samsung_ops = {\n\t.request\t= pwm_samsung_request,\n\t.free\t\t= pwm_samsung_free,\n\t.apply\t\t= pwm_samsung_apply,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_OF\nstatic const struct samsung_pwm_variant s3c24xx_variant = {\n\t.bits\t\t= 16,\n\t.div_base\t= 1,\n\t.has_tint_cstat\t= false,\n\t.tclk_mask\t= BIT(4),\n};\n\nstatic const struct samsung_pwm_variant s3c64xx_variant = {\n\t.bits\t\t= 32,\n\t.div_base\t= 0,\n\t.has_tint_cstat\t= true,\n\t.tclk_mask\t= BIT(7) | BIT(6) | BIT(5),\n};\n\nstatic const struct samsung_pwm_variant s5p64x0_variant = {\n\t.bits\t\t= 32,\n\t.div_base\t= 0,\n\t.has_tint_cstat\t= true,\n\t.tclk_mask\t= 0,\n};\n\nstatic const struct samsung_pwm_variant s5pc100_variant = {\n\t.bits\t\t= 32,\n\t.div_base\t= 0,\n\t.has_tint_cstat\t= true,\n\t.tclk_mask\t= BIT(5),\n};\n\nstatic const struct of_device_id samsung_pwm_matches[] = {\n\t{ .compatible = \"samsung,s3c2410-pwm\", .data = &s3c24xx_variant },\n\t{ .compatible = \"samsung,s3c6400-pwm\", .data = &s3c64xx_variant },\n\t{ .compatible = \"samsung,s5p6440-pwm\", .data = &s5p64x0_variant },\n\t{ .compatible = \"samsung,s5pc100-pwm\", .data = &s5pc100_variant },\n\t{ .compatible = \"samsung,exynos4210-pwm\", .data = &s5p64x0_variant },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, samsung_pwm_matches);\n\nstatic int pwm_samsung_parse_dt(struct samsung_pwm_chip *chip)\n{\n\tstruct device_node *np = chip->chip.dev->of_node;\n\tconst struct of_device_id *match;\n\tstruct property *prop;\n\tconst __be32 *cur;\n\tu32 val;\n\n\tmatch = of_match_node(samsung_pwm_matches, np);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tmemcpy(&chip->variant, match->data, sizeof(chip->variant));\n\n\tof_property_for_each_u32(np, \"samsung,pwm-outputs\", prop, cur, val) {\n\t\tif (val >= SAMSUNG_PWM_NUM) {\n\t\t\tdev_err(chip->chip.dev,\n\t\t\t\t\"%s: invalid channel index in samsung,pwm-outputs property\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\t\tcontinue;\n\t\t}\n\t\tchip->variant.output_mask |= BIT(val);\n\t}\n\n\treturn 0;\n}\n#else\nstatic int pwm_samsung_parse_dt(struct samsung_pwm_chip *chip)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int pwm_samsung_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct samsung_pwm_chip *chip;\n\tunsigned int chan;\n\tint ret;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\tchip->chip.dev = &pdev->dev;\n\tchip->chip.ops = &pwm_samsung_ops;\n\tchip->chip.npwm = SAMSUNG_PWM_NUM;\n\tchip->inverter_mask = BIT(SAMSUNG_PWM_NUM) - 1;\n\n\tif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\n\t\tret = pwm_samsung_parse_dt(chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tif (!pdev->dev.platform_data) {\n\t\t\tdev_err(&pdev->dev, \"no platform data specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(&chip->variant, pdev->dev.platform_data,\n\t\t\t\t\t\t\tsizeof(chip->variant));\n\t}\n\n\tchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->base))\n\t\treturn PTR_ERR(chip->base);\n\n\tchip->base_clk = devm_clk_get(&pdev->dev, \"timers\");\n\tif (IS_ERR(chip->base_clk)) {\n\t\tdev_err(dev, \"failed to get timer base clk\\n\");\n\t\treturn PTR_ERR(chip->base_clk);\n\t}\n\n\tret = clk_prepare_enable(chip->base_clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable base clock\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (chan = 0; chan < SAMSUNG_PWM_NUM; ++chan)\n\t\tif (chip->variant.output_mask & BIT(chan))\n\t\t\tpwm_samsung_set_invert(chip, chan, true);\n\n\t \n\tchip->tclk0 = devm_clk_get(&pdev->dev, \"pwm-tclk0\");\n\tchip->tclk1 = devm_clk_get(&pdev->dev, \"pwm-tclk1\");\n\n\tplatform_set_drvdata(pdev, chip);\n\n\tret = pwmchip_add(&chip->chip);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register PWM chip\\n\");\n\t\tclk_disable_unprepare(chip->base_clk);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"base_clk at %lu, tclk0 at %lu, tclk1 at %lu\\n\",\n\t\tclk_get_rate(chip->base_clk),\n\t\t!IS_ERR(chip->tclk0) ? clk_get_rate(chip->tclk0) : 0,\n\t\t!IS_ERR(chip->tclk1) ? clk_get_rate(chip->tclk1) : 0);\n\n\treturn 0;\n}\n\nstatic void pwm_samsung_remove(struct platform_device *pdev)\n{\n\tstruct samsung_pwm_chip *chip = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&chip->chip);\n\n\tclk_disable_unprepare(chip->base_clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pwm_samsung_resume(struct device *dev)\n{\n\tstruct samsung_pwm_chip *our_chip = dev_get_drvdata(dev);\n\tstruct pwm_chip *chip = &our_chip->chip;\n\tunsigned int i;\n\n\tfor (i = 0; i < SAMSUNG_PWM_NUM; i++) {\n\t\tstruct pwm_device *pwm = &chip->pwms[i];\n\t\tstruct samsung_pwm_channel *chan = pwm_get_chip_data(pwm);\n\n\t\tif (!chan)\n\t\t\tcontinue;\n\n\t\tif (our_chip->variant.output_mask & BIT(i))\n\t\t\tpwm_samsung_set_invert(our_chip, i,\n\t\t\t\t\tour_chip->inverter_mask & BIT(i));\n\n\t\tif (chan->period_ns) {\n\t\t\t__pwm_samsung_config(chip, pwm, chan->duty_ns,\n\t\t\t\t\t     chan->period_ns, true);\n\t\t\t \n\t\t\tpwm_samsung_manual_update(our_chip, pwm);\n\t\t}\n\n\t\tif (our_chip->disabled_mask & BIT(i))\n\t\t\tpwm_samsung_disable(chip, pwm);\n\t\telse\n\t\t\tpwm_samsung_enable(chip, pwm);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(pwm_samsung_pm_ops, NULL, pwm_samsung_resume);\n\nstatic struct platform_driver pwm_samsung_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"samsung-pwm\",\n\t\t.pm\t= &pwm_samsung_pm_ops,\n\t\t.of_match_table = of_match_ptr(samsung_pwm_matches),\n\t},\n\t.probe\t\t= pwm_samsung_probe,\n\t.remove_new\t= pwm_samsung_remove,\n};\nmodule_platform_driver(pwm_samsung_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tomasz Figa <tomasz.figa@gmail.com>\");\nMODULE_ALIAS(\"platform:samsung-pwm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}