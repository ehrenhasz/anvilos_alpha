{
  "module_name": "pwm-sunplus.c",
  "hash_id": "a432089a9b57f4b03debee1d5ea9cc462738e18e0624e768ac7e08b6a3cee346",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-sunplus.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n#define SP7021_PWM_MODE0\t\t0x000\n#define SP7021_PWM_MODE0_PWMEN(ch)\tBIT(ch)\n#define SP7021_PWM_MODE0_BYPASS(ch)\tBIT(8 + (ch))\n#define SP7021_PWM_MODE1\t\t0x004\n#define SP7021_PWM_MODE1_CNT_EN(ch)\tBIT(ch)\n#define SP7021_PWM_FREQ(ch)\t\t(0x008 + 4 * (ch))\n#define SP7021_PWM_FREQ_MAX\t\tGENMASK(15, 0)\n#define SP7021_PWM_DUTY(ch)\t\t(0x018 + 4 * (ch))\n#define SP7021_PWM_DUTY_DD_SEL(ch)\tFIELD_PREP(GENMASK(9, 8), ch)\n#define SP7021_PWM_DUTY_MAX\t\tGENMASK(7, 0)\n#define SP7021_PWM_DUTY_MASK\t\tSP7021_PWM_DUTY_MAX\n#define SP7021_PWM_FREQ_SCALER\t\t256\n#define SP7021_PWM_NUM\t\t\t4\n\nstruct sunplus_pwm {\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic inline struct sunplus_pwm *to_sunplus_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct sunplus_pwm, chip);\n}\n\nstatic int sunplus_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tstruct sunplus_pwm *priv = to_sunplus_pwm(chip);\n\tu32 dd_freq, duty, mode0, mode1;\n\tu64 clk_rate;\n\n\tif (state->polarity != pwm->state.polarity)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\t \n\t\tmode0 = readl(priv->base + SP7021_PWM_MODE0);\n\t\tmode0 &= ~SP7021_PWM_MODE0_PWMEN(pwm->hwpwm);\n\t\twritel(mode0, priv->base + SP7021_PWM_MODE0);\n\t\t \n\t\tmode1 = readl(priv->base + SP7021_PWM_MODE1);\n\t\tmode1 &= ~SP7021_PWM_MODE1_CNT_EN(pwm->hwpwm);\n\t\twritel(mode1, priv->base + SP7021_PWM_MODE1);\n\t\treturn 0;\n\t}\n\n\tclk_rate = clk_get_rate(priv->clk);\n\n\t \n\tif (clk_rate > (u64)SP7021_PWM_FREQ_SCALER * NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\t \n\tdd_freq = mul_u64_u64_div_u64(clk_rate, state->period, (u64)SP7021_PWM_FREQ_SCALER\n\t\t\t\t* NSEC_PER_SEC);\n\n\tif (dd_freq == 0)\n\t\treturn -EINVAL;\n\n\tif (dd_freq > SP7021_PWM_FREQ_MAX)\n\t\tdd_freq = SP7021_PWM_FREQ_MAX;\n\n\twritel(dd_freq, priv->base + SP7021_PWM_FREQ(pwm->hwpwm));\n\n\t \n\tmode0 = readl(priv->base + SP7021_PWM_MODE0);\n\tmode0 |= SP7021_PWM_MODE0_PWMEN(pwm->hwpwm);\n\tmode1 = readl(priv->base + SP7021_PWM_MODE1);\n\tmode1 |= SP7021_PWM_MODE1_CNT_EN(pwm->hwpwm);\n\tif (state->duty_cycle == state->period) {\n\t\t \n\t\tmode0 |= SP7021_PWM_MODE0_BYPASS(pwm->hwpwm);\n\t\tduty = SP7021_PWM_DUTY_DD_SEL(pwm->hwpwm) | SP7021_PWM_DUTY_MAX;\n\t} else {\n\t\tmode0 &= ~SP7021_PWM_MODE0_BYPASS(pwm->hwpwm);\n\t\t \n\t\tduty = mul_u64_u64_div_u64(state->duty_cycle, clk_rate,\n\t\t\t\t\t   (u64)dd_freq * NSEC_PER_SEC);\n\t\tduty = SP7021_PWM_DUTY_DD_SEL(pwm->hwpwm) | duty;\n\t}\n\twritel(duty, priv->base + SP7021_PWM_DUTY(pwm->hwpwm));\n\twritel(mode1, priv->base + SP7021_PWM_MODE1);\n\twritel(mode0, priv->base + SP7021_PWM_MODE0);\n\n\treturn 0;\n}\n\nstatic int sunplus_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t struct pwm_state *state)\n{\n\tstruct sunplus_pwm *priv = to_sunplus_pwm(chip);\n\tu32 mode0, dd_freq, duty;\n\tu64 clk_rate;\n\n\tmode0 = readl(priv->base + SP7021_PWM_MODE0);\n\n\tif (mode0 & BIT(pwm->hwpwm)) {\n\t\tclk_rate = clk_get_rate(priv->clk);\n\t\tdd_freq = readl(priv->base + SP7021_PWM_FREQ(pwm->hwpwm));\n\t\tduty = readl(priv->base + SP7021_PWM_DUTY(pwm->hwpwm));\n\t\tduty = FIELD_GET(SP7021_PWM_DUTY_MASK, duty);\n\t\t \n\t\tstate->period = DIV64_U64_ROUND_UP((u64)dd_freq * (u64)SP7021_PWM_FREQ_SCALER\n\t\t\t\t\t\t* NSEC_PER_SEC, clk_rate);\n\t\t \n\t\tstate->duty_cycle = DIV64_U64_ROUND_UP((u64)dd_freq * (u64)duty * NSEC_PER_SEC,\n\t\t\t\t\t\t       clk_rate);\n\t\tstate->enabled = true;\n\t} else {\n\t\tstate->enabled = false;\n\t}\n\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops sunplus_pwm_ops = {\n\t.apply = sunplus_pwm_apply,\n\t.get_state = sunplus_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic void sunplus_pwm_clk_release(void *data)\n{\n\tstruct clk *clk = data;\n\n\tclk_disable_unprepare(clk);\n}\n\nstatic int sunplus_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sunplus_pwm *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"get pwm clock failed\\n\");\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, sunplus_pwm_clk_release, priv->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to release clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->chip.dev = dev;\n\tpriv->chip.ops = &sunplus_pwm_ops;\n\tpriv->chip.npwm = SP7021_PWM_NUM;\n\n\tret = devm_pwmchip_add(dev, &priv->chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Cannot register sunplus PWM\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sunplus_pwm_of_match[] = {\n\t{ .compatible = \"sunplus,sp7021-pwm\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sunplus_pwm_of_match);\n\nstatic struct platform_driver sunplus_pwm_driver = {\n\t.probe\t\t= sunplus_pwm_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"sunplus-pwm\",\n\t\t.of_match_table = sunplus_pwm_of_match,\n\t},\n};\nmodule_platform_driver(sunplus_pwm_driver);\n\nMODULE_DESCRIPTION(\"Sunplus SoC PWM Driver\");\nMODULE_AUTHOR(\"Hammer Hsieh <hammerh0314@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}