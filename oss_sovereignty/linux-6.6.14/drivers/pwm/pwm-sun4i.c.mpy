{
  "module_name": "pwm-sun4i.c",
  "hash_id": "71240d297cc9b203e95e0f050cf0f2ec36fbedaa60cc188913c6e5b41b46c133",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-sun4i.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n\n#define PWM_CTRL_REG\t\t0x0\n\n#define PWM_CH_PRD_BASE\t\t0x4\n#define PWM_CH_PRD_OFFSET\t0x4\n#define PWM_CH_PRD(ch)\t\t(PWM_CH_PRD_BASE + PWM_CH_PRD_OFFSET * (ch))\n\n#define PWMCH_OFFSET\t\t15\n#define PWM_PRESCAL_MASK\tGENMASK(3, 0)\n#define PWM_PRESCAL_OFF\t\t0\n#define PWM_EN\t\t\tBIT(4)\n#define PWM_ACT_STATE\t\tBIT(5)\n#define PWM_CLK_GATING\t\tBIT(6)\n#define PWM_MODE\t\tBIT(7)\n#define PWM_PULSE\t\tBIT(8)\n#define PWM_BYPASS\t\tBIT(9)\n\n#define PWM_RDY_BASE\t\t28\n#define PWM_RDY_OFFSET\t\t1\n#define PWM_RDY(ch)\t\tBIT(PWM_RDY_BASE + PWM_RDY_OFFSET * (ch))\n\n#define PWM_PRD(prd)\t\t(((prd) - 1) << 16)\n#define PWM_PRD_MASK\t\tGENMASK(15, 0)\n\n#define PWM_DTY_MASK\t\tGENMASK(15, 0)\n\n#define PWM_REG_PRD(reg)\t((((reg) >> 16) & PWM_PRD_MASK) + 1)\n#define PWM_REG_DTY(reg)\t((reg) & PWM_DTY_MASK)\n#define PWM_REG_PRESCAL(reg, chan)\t(((reg) >> ((chan) * PWMCH_OFFSET)) & PWM_PRESCAL_MASK)\n\n#define BIT_CH(bit, chan)\t((bit) << ((chan) * PWMCH_OFFSET))\n\nstatic const u32 prescaler_table[] = {\n\t120,\n\t180,\n\t240,\n\t360,\n\t480,\n\t0,\n\t0,\n\t0,\n\t12000,\n\t24000,\n\t36000,\n\t48000,\n\t72000,\n\t0,\n\t0,\n\t0,  \n};\n\nstruct sun4i_pwm_data {\n\tbool has_prescaler_bypass;\n\tbool has_direct_mod_clk_output;\n\tunsigned int npwm;\n};\n\nstruct sun4i_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct clk *bus_clk;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tvoid __iomem *base;\n\tspinlock_t ctrl_lock;\n\tconst struct sun4i_pwm_data *data;\n};\n\nstatic inline struct sun4i_pwm_chip *to_sun4i_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct sun4i_pwm_chip, chip);\n}\n\nstatic inline u32 sun4i_pwm_readl(struct sun4i_pwm_chip *chip,\n\t\t\t\t  unsigned long offset)\n{\n\treturn readl(chip->base + offset);\n}\n\nstatic inline void sun4i_pwm_writel(struct sun4i_pwm_chip *chip,\n\t\t\t\t    u32 val, unsigned long offset)\n{\n\twritel(val, chip->base + offset);\n}\n\nstatic int sun4i_pwm_get_state(struct pwm_chip *chip,\n\t\t\t       struct pwm_device *pwm,\n\t\t\t       struct pwm_state *state)\n{\n\tstruct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);\n\tu64 clk_rate, tmp;\n\tu32 val;\n\tunsigned int prescaler;\n\n\tclk_rate = clk_get_rate(sun4i_pwm->clk);\n\tif (!clk_rate)\n\t\treturn -EINVAL;\n\n\tval = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\n\n\t \n\tif ((val & BIT_CH(PWM_BYPASS, pwm->hwpwm)) &&\n\t    sun4i_pwm->data->has_direct_mod_clk_output) {\n\t\tstate->period = DIV_ROUND_UP_ULL(NSEC_PER_SEC, clk_rate);\n\t\tstate->duty_cycle = DIV_ROUND_UP_ULL(state->period, 2);\n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\t\tstate->enabled = true;\n\t\treturn 0;\n\t}\n\n\tif ((PWM_REG_PRESCAL(val, pwm->hwpwm) == PWM_PRESCAL_MASK) &&\n\t    sun4i_pwm->data->has_prescaler_bypass)\n\t\tprescaler = 1;\n\telse\n\t\tprescaler = prescaler_table[PWM_REG_PRESCAL(val, pwm->hwpwm)];\n\n\tif (prescaler == 0)\n\t\treturn -EINVAL;\n\n\tif (val & BIT_CH(PWM_ACT_STATE, pwm->hwpwm))\n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\telse\n\t\tstate->polarity = PWM_POLARITY_INVERSED;\n\n\tif ((val & BIT_CH(PWM_CLK_GATING | PWM_EN, pwm->hwpwm)) ==\n\t    BIT_CH(PWM_CLK_GATING | PWM_EN, pwm->hwpwm))\n\t\tstate->enabled = true;\n\telse\n\t\tstate->enabled = false;\n\n\tval = sun4i_pwm_readl(sun4i_pwm, PWM_CH_PRD(pwm->hwpwm));\n\n\ttmp = (u64)prescaler * NSEC_PER_SEC * PWM_REG_DTY(val);\n\tstate->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);\n\n\ttmp = (u64)prescaler * NSEC_PER_SEC * PWM_REG_PRD(val);\n\tstate->period = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);\n\n\treturn 0;\n}\n\nstatic int sun4i_pwm_calculate(struct sun4i_pwm_chip *sun4i_pwm,\n\t\t\t       const struct pwm_state *state,\n\t\t\t       u32 *dty, u32 *prd, unsigned int *prsclr,\n\t\t\t       bool *bypass)\n{\n\tu64 clk_rate, div = 0;\n\tunsigned int prescaler = 0;\n\n\tclk_rate = clk_get_rate(sun4i_pwm->clk);\n\n\t*bypass = sun4i_pwm->data->has_direct_mod_clk_output &&\n\t\t  state->enabled &&\n\t\t  (state->period * clk_rate >= NSEC_PER_SEC) &&\n\t\t  (state->period * clk_rate < 2 * NSEC_PER_SEC) &&\n\t\t  (state->duty_cycle * clk_rate * 2 >= NSEC_PER_SEC);\n\n\t \n\tif (*bypass)\n\t\treturn 0;\n\n\tif (sun4i_pwm->data->has_prescaler_bypass) {\n\t\t \n\t\tprescaler = PWM_PRESCAL_MASK;\n\t\t \n\t\tdiv = clk_rate * state->period + NSEC_PER_SEC / 2;\n\t\tdo_div(div, NSEC_PER_SEC);\n\t\tif (div - 1 > PWM_PRD_MASK)\n\t\t\tprescaler = 0;\n\t}\n\n\tif (prescaler == 0) {\n\t\t \n\t\tfor (prescaler = 0; prescaler < PWM_PRESCAL_MASK; prescaler++) {\n\t\t\tunsigned int pval = prescaler_table[prescaler];\n\n\t\t\tif (!pval)\n\t\t\t\tcontinue;\n\n\t\t\tdiv = clk_rate;\n\t\t\tdo_div(div, pval);\n\t\t\tdiv = div * state->period;\n\t\t\tdo_div(div, NSEC_PER_SEC);\n\t\t\tif (div - 1 <= PWM_PRD_MASK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (div - 1 > PWM_PRD_MASK)\n\t\t\treturn -EINVAL;\n\t}\n\n\t*prd = div;\n\tdiv *= state->duty_cycle;\n\tdo_div(div, state->period);\n\t*dty = div;\n\t*prsclr = prescaler;\n\n\treturn 0;\n}\n\nstatic int sun4i_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tstruct sun4i_pwm_chip *sun4i_pwm = to_sun4i_pwm_chip(chip);\n\tstruct pwm_state cstate;\n\tu32 ctrl, duty = 0, period = 0, val;\n\tint ret;\n\tunsigned int delay_us, prescaler = 0;\n\tbool bypass;\n\n\tpwm_get_state(pwm, &cstate);\n\n\tif (!cstate.enabled) {\n\t\tret = clk_prepare_enable(sun4i_pwm->clk);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev, \"failed to enable PWM clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = sun4i_pwm_calculate(sun4i_pwm, state, &duty, &period, &prescaler,\n\t\t\t\t  &bypass);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"period exceeds the maximum value\\n\");\n\t\tif (!cstate.enabled)\n\t\t\tclk_disable_unprepare(sun4i_pwm->clk);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&sun4i_pwm->ctrl_lock);\n\tctrl = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\n\n\tif (sun4i_pwm->data->has_direct_mod_clk_output) {\n\t\tif (bypass) {\n\t\t\tctrl |= BIT_CH(PWM_BYPASS, pwm->hwpwm);\n\t\t\t \n\t\t\tsun4i_pwm_writel(sun4i_pwm, ctrl, PWM_CTRL_REG);\n\t\t\tspin_unlock(&sun4i_pwm->ctrl_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tctrl &= ~BIT_CH(PWM_BYPASS, pwm->hwpwm);\n\t}\n\n\tif (PWM_REG_PRESCAL(ctrl, pwm->hwpwm) != prescaler) {\n\t\t \n\t\tctrl &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\n\t\tsun4i_pwm_writel(sun4i_pwm, ctrl, PWM_CTRL_REG);\n\n\t\tctrl &= ~BIT_CH(PWM_PRESCAL_MASK, pwm->hwpwm);\n\t\tctrl |= BIT_CH(prescaler, pwm->hwpwm);\n\t}\n\n\tval = (duty & PWM_DTY_MASK) | PWM_PRD(period);\n\tsun4i_pwm_writel(sun4i_pwm, val, PWM_CH_PRD(pwm->hwpwm));\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\tctrl &= ~BIT_CH(PWM_ACT_STATE, pwm->hwpwm);\n\telse\n\t\tctrl |= BIT_CH(PWM_ACT_STATE, pwm->hwpwm);\n\n\tctrl |= BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\n\n\tif (state->enabled)\n\t\tctrl |= BIT_CH(PWM_EN, pwm->hwpwm);\n\n\tsun4i_pwm_writel(sun4i_pwm, ctrl, PWM_CTRL_REG);\n\n\tspin_unlock(&sun4i_pwm->ctrl_lock);\n\n\tif (state->enabled)\n\t\treturn 0;\n\n\t \n\tdelay_us = DIV_ROUND_UP_ULL(cstate.period, NSEC_PER_USEC);\n\tif ((delay_us / 500) > MAX_UDELAY_MS)\n\t\tmsleep(delay_us / 1000 + 1);\n\telse\n\t\tusleep_range(delay_us, delay_us * 2);\n\n\tspin_lock(&sun4i_pwm->ctrl_lock);\n\tctrl = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);\n\tctrl &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);\n\tctrl &= ~BIT_CH(PWM_EN, pwm->hwpwm);\n\tsun4i_pwm_writel(sun4i_pwm, ctrl, PWM_CTRL_REG);\n\tspin_unlock(&sun4i_pwm->ctrl_lock);\n\n\tclk_disable_unprepare(sun4i_pwm->clk);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops sun4i_pwm_ops = {\n\t.apply = sun4i_pwm_apply,\n\t.get_state = sun4i_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct sun4i_pwm_data sun4i_pwm_dual_nobypass = {\n\t.has_prescaler_bypass = false,\n\t.npwm = 2,\n};\n\nstatic const struct sun4i_pwm_data sun4i_pwm_dual_bypass = {\n\t.has_prescaler_bypass = true,\n\t.npwm = 2,\n};\n\nstatic const struct sun4i_pwm_data sun4i_pwm_single_bypass = {\n\t.has_prescaler_bypass = true,\n\t.npwm = 1,\n};\n\nstatic const struct sun4i_pwm_data sun50i_a64_pwm_data = {\n\t.has_prescaler_bypass = true,\n\t.has_direct_mod_clk_output = true,\n\t.npwm = 1,\n};\n\nstatic const struct sun4i_pwm_data sun50i_h6_pwm_data = {\n\t.has_prescaler_bypass = true,\n\t.has_direct_mod_clk_output = true,\n\t.npwm = 2,\n};\n\nstatic const struct of_device_id sun4i_pwm_dt_ids[] = {\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-pwm\",\n\t\t.data = &sun4i_pwm_dual_nobypass,\n\t}, {\n\t\t.compatible = \"allwinner,sun5i-a10s-pwm\",\n\t\t.data = &sun4i_pwm_dual_bypass,\n\t}, {\n\t\t.compatible = \"allwinner,sun5i-a13-pwm\",\n\t\t.data = &sun4i_pwm_single_bypass,\n\t}, {\n\t\t.compatible = \"allwinner,sun7i-a20-pwm\",\n\t\t.data = &sun4i_pwm_dual_bypass,\n\t}, {\n\t\t.compatible = \"allwinner,sun8i-h3-pwm\",\n\t\t.data = &sun4i_pwm_single_bypass,\n\t}, {\n\t\t.compatible = \"allwinner,sun50i-a64-pwm\",\n\t\t.data = &sun50i_a64_pwm_data,\n\t}, {\n\t\t.compatible = \"allwinner,sun50i-h6-pwm\",\n\t\t.data = &sun50i_h6_pwm_data,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, sun4i_pwm_dt_ids);\n\nstatic int sun4i_pwm_probe(struct platform_device *pdev)\n{\n\tstruct sun4i_pwm_chip *sun4ichip;\n\tint ret;\n\n\tsun4ichip = devm_kzalloc(&pdev->dev, sizeof(*sun4ichip), GFP_KERNEL);\n\tif (!sun4ichip)\n\t\treturn -ENOMEM;\n\n\tsun4ichip->data = of_device_get_match_data(&pdev->dev);\n\tif (!sun4ichip->data)\n\t\treturn -ENODEV;\n\n\tsun4ichip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sun4ichip->base))\n\t\treturn PTR_ERR(sun4ichip->base);\n\n\t \n\tsun4ichip->clk = devm_clk_get_optional(&pdev->dev, \"mod\");\n\tif (IS_ERR(sun4ichip->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sun4ichip->clk),\n\t\t\t\t     \"get mod clock failed\\n\");\n\n\tif (!sun4ichip->clk) {\n\t\tsun4ichip->clk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(sun4ichip->clk))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sun4ichip->clk),\n\t\t\t\t\t     \"get unnamed clock failed\\n\");\n\t}\n\n\tsun4ichip->bus_clk = devm_clk_get_optional(&pdev->dev, \"bus\");\n\tif (IS_ERR(sun4ichip->bus_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sun4ichip->bus_clk),\n\t\t\t\t     \"get bus clock failed\\n\");\n\n\tsun4ichip->rst = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\n\tif (IS_ERR(sun4ichip->rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sun4ichip->rst),\n\t\t\t\t     \"get reset failed\\n\");\n\n\t \n\tret = reset_control_deassert(sun4ichip->rst);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot deassert reset control: %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_prepare_enable(sun4ichip->bus_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot prepare and enable bus_clk %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t\tgoto err_bus;\n\t}\n\n\tsun4ichip->chip.dev = &pdev->dev;\n\tsun4ichip->chip.ops = &sun4i_pwm_ops;\n\tsun4ichip->chip.npwm = sun4ichip->data->npwm;\n\n\tspin_lock_init(&sun4ichip->ctrl_lock);\n\n\tret = pwmchip_add(&sun4ichip->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip: %d\\n\", ret);\n\t\tgoto err_pwm_add;\n\t}\n\n\tplatform_set_drvdata(pdev, sun4ichip);\n\n\treturn 0;\n\nerr_pwm_add:\n\tclk_disable_unprepare(sun4ichip->bus_clk);\nerr_bus:\n\treset_control_assert(sun4ichip->rst);\n\n\treturn ret;\n}\n\nstatic void sun4i_pwm_remove(struct platform_device *pdev)\n{\n\tstruct sun4i_pwm_chip *sun4ichip = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&sun4ichip->chip);\n\n\tclk_disable_unprepare(sun4ichip->bus_clk);\n\treset_control_assert(sun4ichip->rst);\n}\n\nstatic struct platform_driver sun4i_pwm_driver = {\n\t.driver = {\n\t\t.name = \"sun4i-pwm\",\n\t\t.of_match_table = sun4i_pwm_dt_ids,\n\t},\n\t.probe = sun4i_pwm_probe,\n\t.remove_new = sun4i_pwm_remove,\n};\nmodule_platform_driver(sun4i_pwm_driver);\n\nMODULE_ALIAS(\"platform:sun4i-pwm\");\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner sun4i PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}