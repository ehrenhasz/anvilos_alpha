{
  "module_name": "pwm-bcm-iproc.c",
  "hash_id": "3ebeb63da1ff6ecc32e1c4e9b7fda62f5f497bce2a59c143ceb88d67c3e57139",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-bcm-iproc.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n#define IPROC_PWM_CTRL_OFFSET\t\t\t0x00\n#define IPROC_PWM_CTRL_TYPE_SHIFT(ch)\t\t(15 + (ch))\n#define IPROC_PWM_CTRL_POLARITY_SHIFT(ch)\t(8 + (ch))\n#define IPROC_PWM_CTRL_EN_SHIFT(ch)\t\t(ch)\n\n#define IPROC_PWM_PERIOD_OFFSET(ch)\t\t(0x04 + ((ch) << 3))\n#define IPROC_PWM_PERIOD_MIN\t\t\t0x02\n#define IPROC_PWM_PERIOD_MAX\t\t\t0xffff\n\n#define IPROC_PWM_DUTY_CYCLE_OFFSET(ch)\t\t(0x08 + ((ch) << 3))\n#define IPROC_PWM_DUTY_CYCLE_MIN\t\t0x00\n#define IPROC_PWM_DUTY_CYCLE_MAX\t\t0xffff\n\n#define IPROC_PWM_PRESCALE_OFFSET\t\t0x24\n#define IPROC_PWM_PRESCALE_BITS\t\t\t0x06\n#define IPROC_PWM_PRESCALE_SHIFT(ch)\t\t((3 - (ch)) * \\\n\t\t\t\t\t\t IPROC_PWM_PRESCALE_BITS)\n#define IPROC_PWM_PRESCALE_MASK(ch)\t\t(IPROC_PWM_PRESCALE_MAX << \\\n\t\t\t\t\t\t IPROC_PWM_PRESCALE_SHIFT(ch))\n#define IPROC_PWM_PRESCALE_MIN\t\t\t0x00\n#define IPROC_PWM_PRESCALE_MAX\t\t\t0x3f\n\nstruct iproc_pwmc {\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic inline struct iproc_pwmc *to_iproc_pwmc(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct iproc_pwmc, chip);\n}\n\nstatic void iproc_pwmc_enable(struct iproc_pwmc *ip, unsigned int channel)\n{\n\tu32 value;\n\n\tvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\n\tvalue |= 1 << IPROC_PWM_CTRL_EN_SHIFT(channel);\n\twritel(value, ip->base + IPROC_PWM_CTRL_OFFSET);\n\n\t \n\tndelay(400);\n}\n\nstatic void iproc_pwmc_disable(struct iproc_pwmc *ip, unsigned int channel)\n{\n\tu32 value;\n\n\tvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\n\tvalue &= ~(1 << IPROC_PWM_CTRL_EN_SHIFT(channel));\n\twritel(value, ip->base + IPROC_PWM_CTRL_OFFSET);\n\n\t \n\tndelay(400);\n}\n\nstatic int iproc_pwmc_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\tstruct pwm_state *state)\n{\n\tstruct iproc_pwmc *ip = to_iproc_pwmc(chip);\n\tu64 tmp, multi, rate;\n\tu32 value, prescale;\n\n\tvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\n\n\tif (value & BIT(IPROC_PWM_CTRL_EN_SHIFT(pwm->hwpwm)))\n\t\tstate->enabled = true;\n\telse\n\t\tstate->enabled = false;\n\n\tif (value & BIT(IPROC_PWM_CTRL_POLARITY_SHIFT(pwm->hwpwm)))\n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\telse\n\t\tstate->polarity = PWM_POLARITY_INVERSED;\n\n\trate = clk_get_rate(ip->clk);\n\tif (rate == 0) {\n\t\tstate->period = 0;\n\t\tstate->duty_cycle = 0;\n\t\treturn 0;\n\t}\n\n\tvalue = readl(ip->base + IPROC_PWM_PRESCALE_OFFSET);\n\tprescale = value >> IPROC_PWM_PRESCALE_SHIFT(pwm->hwpwm);\n\tprescale &= IPROC_PWM_PRESCALE_MAX;\n\n\tmulti = NSEC_PER_SEC * (prescale + 1);\n\n\tvalue = readl(ip->base + IPROC_PWM_PERIOD_OFFSET(pwm->hwpwm));\n\ttmp = (value & IPROC_PWM_PERIOD_MAX) * multi;\n\tstate->period = div64_u64(tmp, rate);\n\n\tvalue = readl(ip->base + IPROC_PWM_DUTY_CYCLE_OFFSET(pwm->hwpwm));\n\ttmp = (value & IPROC_PWM_PERIOD_MAX) * multi;\n\tstate->duty_cycle = div64_u64(tmp, rate);\n\n\treturn 0;\n}\n\nstatic int iproc_pwmc_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tunsigned long prescale = IPROC_PWM_PRESCALE_MIN;\n\tstruct iproc_pwmc *ip = to_iproc_pwmc(chip);\n\tu32 value, period, duty;\n\tu64 rate;\n\n\trate = clk_get_rate(ip->clk);\n\n\t \n\twhile (1) {\n\t\tu64 value, div;\n\n\t\tdiv = NSEC_PER_SEC * (prescale + 1);\n\t\tvalue = rate * state->period;\n\t\tperiod = div64_u64(value, div);\n\t\tvalue = rate * state->duty_cycle;\n\t\tduty = div64_u64(value, div);\n\n\t\tif (period < IPROC_PWM_PERIOD_MIN)\n\t\t\treturn -EINVAL;\n\n\t\tif (period <= IPROC_PWM_PERIOD_MAX &&\n\t\t     duty <= IPROC_PWM_DUTY_CYCLE_MAX)\n\t\t\tbreak;\n\n\t\t \n\t\tif (++prescale > IPROC_PWM_PRESCALE_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tiproc_pwmc_disable(ip, pwm->hwpwm);\n\n\t \n\tvalue = readl(ip->base + IPROC_PWM_PRESCALE_OFFSET);\n\tvalue &= ~IPROC_PWM_PRESCALE_MASK(pwm->hwpwm);\n\tvalue |= prescale << IPROC_PWM_PRESCALE_SHIFT(pwm->hwpwm);\n\twritel(value, ip->base + IPROC_PWM_PRESCALE_OFFSET);\n\n\t \n\twritel(period, ip->base + IPROC_PWM_PERIOD_OFFSET(pwm->hwpwm));\n\twritel(duty, ip->base + IPROC_PWM_DUTY_CYCLE_OFFSET(pwm->hwpwm));\n\n\t \n\tvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\n\n\tif (state->polarity == PWM_POLARITY_NORMAL)\n\t\tvalue |= 1 << IPROC_PWM_CTRL_POLARITY_SHIFT(pwm->hwpwm);\n\telse\n\t\tvalue &= ~(1 << IPROC_PWM_CTRL_POLARITY_SHIFT(pwm->hwpwm));\n\n\twritel(value, ip->base + IPROC_PWM_CTRL_OFFSET);\n\n\tif (state->enabled)\n\t\tiproc_pwmc_enable(ip, pwm->hwpwm);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops iproc_pwm_ops = {\n\t.apply = iproc_pwmc_apply,\n\t.get_state = iproc_pwmc_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic int iproc_pwmc_probe(struct platform_device *pdev)\n{\n\tstruct iproc_pwmc *ip;\n\tunsigned int i;\n\tu32 value;\n\tint ret;\n\n\tip = devm_kzalloc(&pdev->dev, sizeof(*ip), GFP_KERNEL);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ip);\n\n\tip->chip.dev = &pdev->dev;\n\tip->chip.ops = &iproc_pwm_ops;\n\tip->chip.npwm = 4;\n\n\tip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ip->base))\n\t\treturn PTR_ERR(ip->base);\n\n\tip->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(ip->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock: %ld\\n\",\n\t\t\tPTR_ERR(ip->clk));\n\t\treturn PTR_ERR(ip->clk);\n\t}\n\n\tret = clk_prepare_enable(ip->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\n\n\tfor (i = 0; i < ip->chip.npwm; i++) {\n\t\tvalue &= ~(1 << IPROC_PWM_CTRL_TYPE_SHIFT(i));\n\t\tvalue |= 1 << IPROC_PWM_CTRL_POLARITY_SHIFT(i);\n\t}\n\n\twritel(value, ip->base + IPROC_PWM_CTRL_OFFSET);\n\n\tret = pwmchip_add(&ip->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip: %d\\n\", ret);\n\t\tclk_disable_unprepare(ip->clk);\n\t}\n\n\treturn ret;\n}\n\nstatic void iproc_pwmc_remove(struct platform_device *pdev)\n{\n\tstruct iproc_pwmc *ip = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&ip->chip);\n\n\tclk_disable_unprepare(ip->clk);\n}\n\nstatic const struct of_device_id bcm_iproc_pwmc_dt[] = {\n\t{ .compatible = \"brcm,iproc-pwm\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm_iproc_pwmc_dt);\n\nstatic struct platform_driver iproc_pwmc_driver = {\n\t.driver = {\n\t\t.name = \"bcm-iproc-pwm\",\n\t\t.of_match_table = bcm_iproc_pwmc_dt,\n\t},\n\t.probe = iproc_pwmc_probe,\n\t.remove_new = iproc_pwmc_remove,\n};\nmodule_platform_driver(iproc_pwmc_driver);\n\nMODULE_AUTHOR(\"Yendapally Reddy Dhananjaya Reddy <yendapally.reddy@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom iProc PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}