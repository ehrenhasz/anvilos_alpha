{
  "module_name": "pwm-imx27.c",
  "hash_id": "9340ddf196232cded84b46c6e8e08ca145ce83f9cbe414fe78c9d5a3d7afecea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-imx27.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n#define MX3_PWMCR\t\t\t0x00     \n#define MX3_PWMSR\t\t\t0x04     \n#define MX3_PWMSAR\t\t\t0x0C     \n#define MX3_PWMPR\t\t\t0x10     \n\n#define MX3_PWMCR_FWM\t\t\tGENMASK(27, 26)\n#define MX3_PWMCR_STOPEN\t\tBIT(25)\n#define MX3_PWMCR_DOZEN\t\t\tBIT(24)\n#define MX3_PWMCR_WAITEN\t\tBIT(23)\n#define MX3_PWMCR_DBGEN\t\t\tBIT(22)\n#define MX3_PWMCR_BCTR\t\t\tBIT(21)\n#define MX3_PWMCR_HCTR\t\t\tBIT(20)\n\n#define MX3_PWMCR_POUTC\t\t\tGENMASK(19, 18)\n#define MX3_PWMCR_POUTC_NORMAL\t\t0\n#define MX3_PWMCR_POUTC_INVERTED\t1\n#define MX3_PWMCR_POUTC_OFF\t\t2\n\n#define MX3_PWMCR_CLKSRC\t\tGENMASK(17, 16)\n#define MX3_PWMCR_CLKSRC_OFF\t\t0\n#define MX3_PWMCR_CLKSRC_IPG\t\t1\n#define MX3_PWMCR_CLKSRC_IPG_HIGH\t2\n#define MX3_PWMCR_CLKSRC_IPG_32K\t3\n\n#define MX3_PWMCR_PRESCALER\t\tGENMASK(15, 4)\n\n#define MX3_PWMCR_SWR\t\t\tBIT(3)\n\n#define MX3_PWMCR_REPEAT\t\tGENMASK(2, 1)\n#define MX3_PWMCR_REPEAT_1X\t\t0\n#define MX3_PWMCR_REPEAT_2X\t\t1\n#define MX3_PWMCR_REPEAT_4X\t\t2\n#define MX3_PWMCR_REPEAT_8X\t\t3\n\n#define MX3_PWMCR_EN\t\t\tBIT(0)\n\n#define MX3_PWMSR_FWE\t\t\tBIT(6)\n#define MX3_PWMSR_CMP\t\t\tBIT(5)\n#define MX3_PWMSR_ROV\t\t\tBIT(4)\n#define MX3_PWMSR_FE\t\t\tBIT(3)\n\n#define MX3_PWMSR_FIFOAV\t\tGENMASK(2, 0)\n#define MX3_PWMSR_FIFOAV_EMPTY\t\t0\n#define MX3_PWMSR_FIFOAV_1WORD\t\t1\n#define MX3_PWMSR_FIFOAV_2WORDS\t\t2\n#define MX3_PWMSR_FIFOAV_3WORDS\t\t3\n#define MX3_PWMSR_FIFOAV_4WORDS\t\t4\n\n#define MX3_PWMCR_PRESCALER_SET(x)\tFIELD_PREP(MX3_PWMCR_PRESCALER, (x) - 1)\n#define MX3_PWMCR_PRESCALER_GET(x)\t(FIELD_GET(MX3_PWMCR_PRESCALER, \\\n\t\t\t\t\t\t   (x)) + 1)\n\n#define MX3_PWM_SWR_LOOP\t\t5\n\n \n#define MX3_PWMPR_MAX\t\t\t0xfffe\n\nstruct pwm_imx27_chip {\n\tstruct clk\t*clk_ipg;\n\tstruct clk\t*clk_per;\n\tvoid __iomem\t*mmio_base;\n\tstruct pwm_chip\tchip;\n\n\t \n\tunsigned int duty_cycle;\n};\n\n#define to_pwm_imx27_chip(chip)\tcontainer_of(chip, struct pwm_imx27_chip, chip)\n\nstatic int pwm_imx27_clk_prepare_enable(struct pwm_imx27_chip *imx)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(imx->clk_ipg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(imx->clk_per);\n\tif (ret) {\n\t\tclk_disable_unprepare(imx->clk_ipg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void pwm_imx27_clk_disable_unprepare(struct pwm_imx27_chip *imx)\n{\n\tclk_disable_unprepare(imx->clk_per);\n\tclk_disable_unprepare(imx->clk_ipg);\n}\n\nstatic int pwm_imx27_get_state(struct pwm_chip *chip,\n\t\t\t       struct pwm_device *pwm, struct pwm_state *state)\n{\n\tstruct pwm_imx27_chip *imx = to_pwm_imx27_chip(chip);\n\tu32 period, prescaler, pwm_clk, val;\n\tu64 tmp;\n\tint ret;\n\n\tret = pwm_imx27_clk_prepare_enable(imx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = readl(imx->mmio_base + MX3_PWMCR);\n\n\tif (val & MX3_PWMCR_EN)\n\t\tstate->enabled = true;\n\telse\n\t\tstate->enabled = false;\n\n\tswitch (FIELD_GET(MX3_PWMCR_POUTC, val)) {\n\tcase MX3_PWMCR_POUTC_NORMAL:\n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\t\tbreak;\n\tcase MX3_PWMCR_POUTC_INVERTED:\n\t\tstate->polarity = PWM_POLARITY_INVERSED;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(chip->dev, \"can't set polarity, output disconnected\");\n\t}\n\n\tprescaler = MX3_PWMCR_PRESCALER_GET(val);\n\tpwm_clk = clk_get_rate(imx->clk_per);\n\tval = readl(imx->mmio_base + MX3_PWMPR);\n\tperiod = val >= MX3_PWMPR_MAX ? MX3_PWMPR_MAX : val;\n\n\t \n\ttmp = NSEC_PER_SEC * (u64)(period + 2) * prescaler;\n\tstate->period = DIV_ROUND_UP_ULL(tmp, pwm_clk);\n\n\t \n\tif (state->enabled)\n\t\tval = readl(imx->mmio_base + MX3_PWMSAR);\n\telse\n\t\tval = imx->duty_cycle;\n\n\ttmp = NSEC_PER_SEC * (u64)(val) * prescaler;\n\tstate->duty_cycle = DIV_ROUND_UP_ULL(tmp, pwm_clk);\n\n\tpwm_imx27_clk_disable_unprepare(imx);\n\n\treturn 0;\n}\n\nstatic void pwm_imx27_sw_reset(struct pwm_chip *chip)\n{\n\tstruct pwm_imx27_chip *imx = to_pwm_imx27_chip(chip);\n\tstruct device *dev = chip->dev;\n\tint wait_count = 0;\n\tu32 cr;\n\n\twritel(MX3_PWMCR_SWR, imx->mmio_base + MX3_PWMCR);\n\tdo {\n\t\tusleep_range(200, 1000);\n\t\tcr = readl(imx->mmio_base + MX3_PWMCR);\n\t} while ((cr & MX3_PWMCR_SWR) &&\n\t\t (wait_count++ < MX3_PWM_SWR_LOOP));\n\n\tif (cr & MX3_PWMCR_SWR)\n\t\tdev_warn(dev, \"software reset timeout\\n\");\n}\n\nstatic void pwm_imx27_wait_fifo_slot(struct pwm_chip *chip,\n\t\t\t\t     struct pwm_device *pwm)\n{\n\tstruct pwm_imx27_chip *imx = to_pwm_imx27_chip(chip);\n\tstruct device *dev = chip->dev;\n\tunsigned int period_ms;\n\tint fifoav;\n\tu32 sr;\n\n\tsr = readl(imx->mmio_base + MX3_PWMSR);\n\tfifoav = FIELD_GET(MX3_PWMSR_FIFOAV, sr);\n\tif (fifoav == MX3_PWMSR_FIFOAV_4WORDS) {\n\t\tperiod_ms = DIV_ROUND_UP_ULL(pwm_get_period(pwm),\n\t\t\t\t\t NSEC_PER_MSEC);\n\t\tmsleep(period_ms);\n\n\t\tsr = readl(imx->mmio_base + MX3_PWMSR);\n\t\tif (fifoav == FIELD_GET(MX3_PWMSR_FIFOAV, sr))\n\t\t\tdev_warn(dev, \"there is no free FIFO slot\\n\");\n\t}\n}\n\nstatic int pwm_imx27_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tunsigned long period_cycles, duty_cycles, prescale;\n\tstruct pwm_imx27_chip *imx = to_pwm_imx27_chip(chip);\n\tstruct pwm_state cstate;\n\tunsigned long long c;\n\tunsigned long long clkrate;\n\tint ret;\n\tu32 cr;\n\n\tpwm_get_state(pwm, &cstate);\n\n\tclkrate = clk_get_rate(imx->clk_per);\n\tc = clkrate * state->period;\n\n\tdo_div(c, NSEC_PER_SEC);\n\tperiod_cycles = c;\n\n\tprescale = period_cycles / 0x10000 + 1;\n\n\tperiod_cycles /= prescale;\n\tc = clkrate * state->duty_cycle;\n\tdo_div(c, NSEC_PER_SEC);\n\tduty_cycles = c;\n\tduty_cycles /= prescale;\n\n\t \n\tif (period_cycles > 2)\n\t\tperiod_cycles -= 2;\n\telse\n\t\tperiod_cycles = 0;\n\n\t \n\tif (cstate.enabled) {\n\t\tpwm_imx27_wait_fifo_slot(chip, pwm);\n\t} else {\n\t\tret = pwm_imx27_clk_prepare_enable(imx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpwm_imx27_sw_reset(chip);\n\t}\n\n\twritel(duty_cycles, imx->mmio_base + MX3_PWMSAR);\n\twritel(period_cycles, imx->mmio_base + MX3_PWMPR);\n\n\t \n\timx->duty_cycle = duty_cycles;\n\n\tcr = MX3_PWMCR_PRESCALER_SET(prescale) |\n\t     MX3_PWMCR_STOPEN | MX3_PWMCR_DOZEN | MX3_PWMCR_WAITEN |\n\t     FIELD_PREP(MX3_PWMCR_CLKSRC, MX3_PWMCR_CLKSRC_IPG_HIGH) |\n\t     MX3_PWMCR_DBGEN;\n\n\tif (state->polarity == PWM_POLARITY_INVERSED)\n\t\tcr |= FIELD_PREP(MX3_PWMCR_POUTC,\n\t\t\t\tMX3_PWMCR_POUTC_INVERTED);\n\n\tif (state->enabled)\n\t\tcr |= MX3_PWMCR_EN;\n\n\twritel(cr, imx->mmio_base + MX3_PWMCR);\n\n\tif (!state->enabled)\n\t\tpwm_imx27_clk_disable_unprepare(imx);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops pwm_imx27_ops = {\n\t.apply = pwm_imx27_apply,\n\t.get_state = pwm_imx27_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id pwm_imx27_dt_ids[] = {\n\t{ .compatible = \"fsl,imx27-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pwm_imx27_dt_ids);\n\nstatic int pwm_imx27_probe(struct platform_device *pdev)\n{\n\tstruct pwm_imx27_chip *imx;\n\tint ret;\n\tu32 pwmcr;\n\n\timx = devm_kzalloc(&pdev->dev, sizeof(*imx), GFP_KERNEL);\n\tif (imx == NULL)\n\t\treturn -ENOMEM;\n\n\timx->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(imx->clk_ipg))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(imx->clk_ipg),\n\t\t\t\t     \"getting ipg clock failed\\n\");\n\n\timx->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(imx->clk_per))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(imx->clk_per),\n\t\t\t\t     \"failed to get peripheral clock\\n\");\n\n\timx->chip.ops = &pwm_imx27_ops;\n\timx->chip.dev = &pdev->dev;\n\timx->chip.npwm = 1;\n\n\timx->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(imx->mmio_base))\n\t\treturn PTR_ERR(imx->mmio_base);\n\n\tret = pwm_imx27_clk_prepare_enable(imx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpwmcr = readl(imx->mmio_base + MX3_PWMCR);\n\tif (!(pwmcr & MX3_PWMCR_EN))\n\t\tpwm_imx27_clk_disable_unprepare(imx);\n\n\treturn devm_pwmchip_add(&pdev->dev, &imx->chip);\n}\n\nstatic struct platform_driver imx_pwm_driver = {\n\t.driver = {\n\t\t.name = \"pwm-imx27\",\n\t\t.of_match_table = pwm_imx27_dt_ids,\n\t},\n\t.probe = pwm_imx27_probe,\n};\nmodule_platform_driver(imx_pwm_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}