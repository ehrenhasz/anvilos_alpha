{
  "module_name": "pwm-dwc.c",
  "hash_id": "22a64cfe0d9953861a9db16c2b107aae6951e38384ea6d30841cdd98ce2bcddc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-dwc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n\n#define DWC_TIM_LD_CNT(n)\t((n) * 0x14)\n#define DWC_TIM_LD_CNT2(n)\t(((n) * 4) + 0xb0)\n#define DWC_TIM_CUR_VAL(n)\t(((n) * 0x14) + 0x04)\n#define DWC_TIM_CTRL(n)\t\t(((n) * 0x14) + 0x08)\n#define DWC_TIM_EOI(n)\t\t(((n) * 0x14) + 0x0c)\n#define DWC_TIM_INT_STS(n)\t(((n) * 0x14) + 0x10)\n\n#define DWC_TIMERS_INT_STS\t0xa0\n#define DWC_TIMERS_EOI\t\t0xa4\n#define DWC_TIMERS_RAW_INT_STS\t0xa8\n#define DWC_TIMERS_COMP_VERSION\t0xac\n\n#define DWC_TIMERS_TOTAL\t8\n#define DWC_CLK_PERIOD_NS\t10\n\n \n#define DWC_TIM_CTRL_EN\t\tBIT(0)\n#define DWC_TIM_CTRL_MODE\tBIT(1)\n#define DWC_TIM_CTRL_MODE_FREE\t(0 << 1)\n#define DWC_TIM_CTRL_MODE_USER\t(1 << 1)\n#define DWC_TIM_CTRL_INT_MASK\tBIT(2)\n#define DWC_TIM_CTRL_PWM\tBIT(3)\n\nstruct dwc_pwm_ctx {\n\tu32 cnt;\n\tu32 cnt2;\n\tu32 ctrl;\n};\n\nstruct dwc_pwm {\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n\tstruct dwc_pwm_ctx ctx[DWC_TIMERS_TOTAL];\n};\n#define to_dwc_pwm(p)\t(container_of((p), struct dwc_pwm, chip))\n\nstatic inline u32 dwc_pwm_readl(struct dwc_pwm *dwc, u32 offset)\n{\n\treturn readl(dwc->base + offset);\n}\n\nstatic inline void dwc_pwm_writel(struct dwc_pwm *dwc, u32 value, u32 offset)\n{\n\twritel(value, dwc->base + offset);\n}\n\nstatic void __dwc_pwm_set_enable(struct dwc_pwm *dwc, int pwm, int enabled)\n{\n\tu32 reg;\n\n\treg = dwc_pwm_readl(dwc, DWC_TIM_CTRL(pwm));\n\n\tif (enabled)\n\t\treg |= DWC_TIM_CTRL_EN;\n\telse\n\t\treg &= ~DWC_TIM_CTRL_EN;\n\n\tdwc_pwm_writel(dwc, reg, DWC_TIM_CTRL(pwm));\n}\n\nstatic int __dwc_pwm_configure_timer(struct dwc_pwm *dwc,\n\t\t\t\t     struct pwm_device *pwm,\n\t\t\t\t     const struct pwm_state *state)\n{\n\tu64 tmp;\n\tu32 ctrl;\n\tu32 high;\n\tu32 low;\n\n\t \n\ttmp = DIV_ROUND_CLOSEST_ULL(state->duty_cycle, DWC_CLK_PERIOD_NS);\n\tif (tmp < 1 || tmp > (1ULL << 32))\n\t\treturn -ERANGE;\n\tlow = tmp - 1;\n\n\ttmp = DIV_ROUND_CLOSEST_ULL(state->period - state->duty_cycle,\n\t\t\t\t    DWC_CLK_PERIOD_NS);\n\tif (tmp < 1 || tmp > (1ULL << 32))\n\t\treturn -ERANGE;\n\thigh = tmp - 1;\n\n\t \n\t__dwc_pwm_set_enable(dwc, pwm->hwpwm, false);\n\n\t \n\tdwc_pwm_writel(dwc, low, DWC_TIM_LD_CNT(pwm->hwpwm));\n\tdwc_pwm_writel(dwc, high, DWC_TIM_LD_CNT2(pwm->hwpwm));\n\n\t \n\tctrl = DWC_TIM_CTRL_MODE_USER | DWC_TIM_CTRL_PWM;\n\tdwc_pwm_writel(dwc, ctrl, DWC_TIM_CTRL(pwm->hwpwm));\n\n\t \n\t__dwc_pwm_set_enable(dwc, pwm->hwpwm, state->enabled);\n\n\treturn 0;\n}\n\nstatic int dwc_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tstruct dwc_pwm *dwc = to_dwc_pwm(chip);\n\n\tif (state->polarity != PWM_POLARITY_INVERSED)\n\t\treturn -EINVAL;\n\n\tif (state->enabled) {\n\t\tif (!pwm->state.enabled)\n\t\t\tpm_runtime_get_sync(chip->dev);\n\t\treturn __dwc_pwm_configure_timer(dwc, pwm, state);\n\t} else {\n\t\tif (pwm->state.enabled) {\n\t\t\t__dwc_pwm_set_enable(dwc, pwm->hwpwm, false);\n\t\t\tpm_runtime_put_sync(chip->dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     struct pwm_state *state)\n{\n\tstruct dwc_pwm *dwc = to_dwc_pwm(chip);\n\tu64 duty, period;\n\n\tpm_runtime_get_sync(chip->dev);\n\n\tstate->enabled = !!(dwc_pwm_readl(dwc,\n\t\t\t\tDWC_TIM_CTRL(pwm->hwpwm)) & DWC_TIM_CTRL_EN);\n\n\tduty = dwc_pwm_readl(dwc, DWC_TIM_LD_CNT(pwm->hwpwm));\n\tduty += 1;\n\tduty *= DWC_CLK_PERIOD_NS;\n\tstate->duty_cycle = duty;\n\n\tperiod = dwc_pwm_readl(dwc, DWC_TIM_LD_CNT2(pwm->hwpwm));\n\tperiod += 1;\n\tperiod *= DWC_CLK_PERIOD_NS;\n\tperiod += duty;\n\tstate->period = period;\n\n\tstate->polarity = PWM_POLARITY_INVERSED;\n\n\tpm_runtime_put_sync(chip->dev);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops dwc_pwm_ops = {\n\t.apply = dwc_pwm_apply,\n\t.get_state = dwc_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct dwc_pwm *dwc_pwm_alloc(struct device *dev)\n{\n\tstruct dwc_pwm *dwc;\n\n\tdwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);\n\tif (!dwc)\n\t\treturn NULL;\n\n\tdwc->chip.dev = dev;\n\tdwc->chip.ops = &dwc_pwm_ops;\n\tdwc->chip.npwm = DWC_TIMERS_TOTAL;\n\n\tdev_set_drvdata(dev, dwc);\n\treturn dwc;\n}\n\nstatic int dwc_pwm_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pci->dev;\n\tstruct dwc_pwm *dwc;\n\tint ret;\n\n\tdwc = dwc_pwm_alloc(dev);\n\tif (!dwc)\n\t\treturn -ENOMEM;\n\n\tret = pcim_enable_device(pci);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable device (%pe)\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pci);\n\n\tret = pcim_iomap_regions(pci, BIT(0), pci_name(pci));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to iomap PCI BAR (%pe)\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tdwc->base = pcim_iomap_table(pci)[0];\n\tif (!dwc->base) {\n\t\tdev_err(dev, \"Base address missing\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_pwmchip_add(dev, &dwc->chip);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_put(dev);\n\tpm_runtime_allow(dev);\n\n\treturn 0;\n}\n\nstatic void dwc_pwm_remove(struct pci_dev *pci)\n{\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dwc_pwm_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = container_of(dev, struct pci_dev, dev);\n\tstruct dwc_pwm *dwc = pci_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < DWC_TIMERS_TOTAL; i++) {\n\t\tif (dwc->chip.pwms[i].state.enabled) {\n\t\t\tdev_err(dev, \"PWM %u in use by consumer (%s)\\n\",\n\t\t\t\ti, dwc->chip.pwms[i].label);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tdwc->ctx[i].cnt = dwc_pwm_readl(dwc, DWC_TIM_LD_CNT(i));\n\t\tdwc->ctx[i].cnt2 = dwc_pwm_readl(dwc, DWC_TIM_LD_CNT2(i));\n\t\tdwc->ctx[i].ctrl = dwc_pwm_readl(dwc, DWC_TIM_CTRL(i));\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc_pwm_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = container_of(dev, struct pci_dev, dev);\n\tstruct dwc_pwm *dwc = pci_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < DWC_TIMERS_TOTAL; i++) {\n\t\tdwc_pwm_writel(dwc, dwc->ctx[i].cnt, DWC_TIM_LD_CNT(i));\n\t\tdwc_pwm_writel(dwc, dwc->ctx[i].cnt2, DWC_TIM_LD_CNT2(i));\n\t\tdwc_pwm_writel(dwc, dwc->ctx[i].ctrl, DWC_TIM_CTRL(i));\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(dwc_pwm_pm_ops, dwc_pwm_suspend, dwc_pwm_resume);\n\nstatic const struct pci_device_id dwc_pwm_id_table[] = {\n\t{ PCI_VDEVICE(INTEL, 0x4bb7) },  \n\t{  }\t \n};\nMODULE_DEVICE_TABLE(pci, dwc_pwm_id_table);\n\nstatic struct pci_driver dwc_pwm_driver = {\n\t.name = \"pwm-dwc\",\n\t.probe = dwc_pwm_probe,\n\t.remove = dwc_pwm_remove,\n\t.id_table = dwc_pwm_id_table,\n\t.driver = {\n\t\t.pm = &dwc_pwm_pm_ops,\n\t},\n};\n\nmodule_pci_driver(dwc_pwm_driver);\n\nMODULE_AUTHOR(\"Felipe Balbi (Intel)\");\nMODULE_AUTHOR(\"Jarkko Nikula <jarkko.nikula@linux.intel.com>\");\nMODULE_AUTHOR(\"Raymond Tan <raymond.tan@intel.com>\");\nMODULE_DESCRIPTION(\"DesignWare PWM Controller\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}