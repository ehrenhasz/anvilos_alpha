{
  "module_name": "pwm-atmel-hlcdc.c",
  "hash_id": "a3ec17f41eddef44bac40798084ff4f7248c4722f654d974670fd7960a471c79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-atmel-hlcdc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mfd/atmel-hlcdc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n\n#define ATMEL_HLCDC_PWMCVAL_MASK\tGENMASK(15, 8)\n#define ATMEL_HLCDC_PWMCVAL(x)\t\t(((x) << 8) & ATMEL_HLCDC_PWMCVAL_MASK)\n#define ATMEL_HLCDC_PWMPOL\t\tBIT(4)\n#define ATMEL_HLCDC_PWMPS_MASK\t\tGENMASK(2, 0)\n#define ATMEL_HLCDC_PWMPS_MAX\t\t0x6\n#define ATMEL_HLCDC_PWMPS(x)\t\t((x) & ATMEL_HLCDC_PWMPS_MASK)\n\nstruct atmel_hlcdc_pwm_errata {\n\tbool slow_clk_erratum;\n\tbool div1_clk_erratum;\n};\n\nstruct atmel_hlcdc_pwm {\n\tstruct pwm_chip chip;\n\tstruct atmel_hlcdc *hlcdc;\n\tstruct clk *cur_clk;\n\tconst struct atmel_hlcdc_pwm_errata *errata;\n};\n\nstatic inline struct atmel_hlcdc_pwm *to_atmel_hlcdc_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct atmel_hlcdc_pwm, chip);\n}\n\nstatic int atmel_hlcdc_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t const struct pwm_state *state)\n{\n\tstruct atmel_hlcdc_pwm *atmel = to_atmel_hlcdc_pwm(chip);\n\tstruct atmel_hlcdc *hlcdc = atmel->hlcdc;\n\tunsigned int status;\n\tint ret;\n\n\tif (state->enabled) {\n\t\tstruct clk *new_clk = hlcdc->slow_clk;\n\t\tu64 pwmcval = state->duty_cycle * 256;\n\t\tunsigned long clk_freq;\n\t\tu64 clk_period_ns;\n\t\tu32 pwmcfg;\n\t\tint pres;\n\n\t\tif (!atmel->errata || !atmel->errata->slow_clk_erratum) {\n\t\t\tclk_freq = clk_get_rate(new_clk);\n\t\t\tif (!clk_freq)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tclk_period_ns = (u64)NSEC_PER_SEC * 256;\n\t\t\tdo_div(clk_period_ns, clk_freq);\n\t\t}\n\n\t\t \n\t\tif ((atmel->errata && atmel->errata->slow_clk_erratum) ||\n\t\t    clk_period_ns > state->period) {\n\t\t\tnew_clk = hlcdc->sys_clk;\n\t\t\tclk_freq = clk_get_rate(new_clk);\n\t\t\tif (!clk_freq)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tclk_period_ns = (u64)NSEC_PER_SEC * 256;\n\t\t\tdo_div(clk_period_ns, clk_freq);\n\t\t}\n\n\t\tfor (pres = 0; pres <= ATMEL_HLCDC_PWMPS_MAX; pres++) {\n\t\t \n\t\t\tif (!pres && atmel->errata &&\n\t\t\t    atmel->errata->div1_clk_erratum)\n\t\t\t\tcontinue;\n\n\t\t\tif ((clk_period_ns << pres) >= state->period)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (pres > ATMEL_HLCDC_PWMPS_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tpwmcfg = ATMEL_HLCDC_PWMPS(pres);\n\n\t\tif (new_clk != atmel->cur_clk) {\n\t\t\tu32 gencfg = 0;\n\t\t\tint ret;\n\n\t\t\tret = clk_prepare_enable(new_clk);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tclk_disable_unprepare(atmel->cur_clk);\n\t\t\tatmel->cur_clk = new_clk;\n\n\t\t\tif (new_clk == hlcdc->sys_clk)\n\t\t\t\tgencfg = ATMEL_HLCDC_CLKPWMSEL;\n\n\t\t\tret = regmap_update_bits(hlcdc->regmap,\n\t\t\t\t\t\t ATMEL_HLCDC_CFG(0),\n\t\t\t\t\t\t ATMEL_HLCDC_CLKPWMSEL,\n\t\t\t\t\t\t gencfg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tdo_div(pwmcval, state->period);\n\n\t\t \n\t\tif (pwmcval > 255)\n\t\t\tpwmcval = 255;\n\n\t\tpwmcfg |= ATMEL_HLCDC_PWMCVAL(pwmcval);\n\n\t\tif (state->polarity == PWM_POLARITY_NORMAL)\n\t\t\tpwmcfg |= ATMEL_HLCDC_PWMPOL;\n\n\t\tret = regmap_update_bits(hlcdc->regmap, ATMEL_HLCDC_CFG(6),\n\t\t\t\t\t ATMEL_HLCDC_PWMCVAL_MASK |\n\t\t\t\t\t ATMEL_HLCDC_PWMPS_MASK |\n\t\t\t\t\t ATMEL_HLCDC_PWMPOL,\n\t\t\t\t\t pwmcfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(hlcdc->regmap, ATMEL_HLCDC_EN,\n\t\t\t\t   ATMEL_HLCDC_PWM);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(hlcdc->regmap, ATMEL_HLCDC_SR,\n\t\t\t\t\t       status,\n\t\t\t\t\t       status & ATMEL_HLCDC_PWM,\n\t\t\t\t\t       10, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = regmap_write(hlcdc->regmap, ATMEL_HLCDC_DIS,\n\t\t\t\t   ATMEL_HLCDC_PWM);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(hlcdc->regmap, ATMEL_HLCDC_SR,\n\t\t\t\t\t       status,\n\t\t\t\t\t       !(status & ATMEL_HLCDC_PWM),\n\t\t\t\t\t       10, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tclk_disable_unprepare(atmel->cur_clk);\n\t\tatmel->cur_clk = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops atmel_hlcdc_pwm_ops = {\n\t.apply = atmel_hlcdc_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct atmel_hlcdc_pwm_errata atmel_hlcdc_pwm_at91sam9x5_errata = {\n\t.slow_clk_erratum = true,\n};\n\nstatic const struct atmel_hlcdc_pwm_errata atmel_hlcdc_pwm_sama5d3_errata = {\n\t.div1_clk_erratum = true,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int atmel_hlcdc_pwm_suspend(struct device *dev)\n{\n\tstruct atmel_hlcdc_pwm *atmel = dev_get_drvdata(dev);\n\n\t \n\tif (pwm_is_enabled(&atmel->chip.pwms[0]))\n\t\tclk_disable_unprepare(atmel->hlcdc->periph_clk);\n\n\treturn 0;\n}\n\nstatic int atmel_hlcdc_pwm_resume(struct device *dev)\n{\n\tstruct atmel_hlcdc_pwm *atmel = dev_get_drvdata(dev);\n\tstruct pwm_state state;\n\tint ret;\n\n\tpwm_get_state(&atmel->chip.pwms[0], &state);\n\n\t \n\tif (!state.enabled) {\n\t\tret = clk_prepare_enable(atmel->hlcdc->periph_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn atmel_hlcdc_pwm_apply(&atmel->chip, &atmel->chip.pwms[0],\n\t\t\t\t     &state);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(atmel_hlcdc_pwm_pm_ops,\n\t\t\t atmel_hlcdc_pwm_suspend, atmel_hlcdc_pwm_resume);\n\nstatic const struct of_device_id atmel_hlcdc_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9n12-hlcdc\",\n\t\t \n\t\t.data = &atmel_hlcdc_pwm_at91sam9x5_errata,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9x5-hlcdc\",\n\t\t.data = &atmel_hlcdc_pwm_at91sam9x5_errata,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d2-hlcdc\",\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d3-hlcdc\",\n\t\t.data = &atmel_hlcdc_pwm_sama5d3_errata,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d4-hlcdc\",\n\t\t.data = &atmel_hlcdc_pwm_sama5d3_errata,\n\t},\n\t{\t.compatible = \"microchip,sam9x60-hlcdc\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, atmel_hlcdc_dt_ids);\n\nstatic int atmel_hlcdc_pwm_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct device *dev = &pdev->dev;\n\tstruct atmel_hlcdc_pwm *atmel;\n\tstruct atmel_hlcdc *hlcdc;\n\tint ret;\n\n\thlcdc = dev_get_drvdata(dev->parent);\n\n\tatmel = devm_kzalloc(dev, sizeof(*atmel), GFP_KERNEL);\n\tif (!atmel)\n\t\treturn -ENOMEM;\n\n\tret = clk_prepare_enable(hlcdc->periph_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmatch = of_match_node(atmel_hlcdc_dt_ids, dev->parent->of_node);\n\tif (match)\n\t\tatmel->errata = match->data;\n\n\tatmel->hlcdc = hlcdc;\n\tatmel->chip.ops = &atmel_hlcdc_pwm_ops;\n\tatmel->chip.dev = dev;\n\tatmel->chip.npwm = 1;\n\n\tret = pwmchip_add(&atmel->chip);\n\tif (ret) {\n\t\tclk_disable_unprepare(hlcdc->periph_clk);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, atmel);\n\n\treturn 0;\n}\n\nstatic void atmel_hlcdc_pwm_remove(struct platform_device *pdev)\n{\n\tstruct atmel_hlcdc_pwm *atmel = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&atmel->chip);\n\n\tclk_disable_unprepare(atmel->hlcdc->periph_clk);\n}\n\nstatic const struct of_device_id atmel_hlcdc_pwm_dt_ids[] = {\n\t{ .compatible = \"atmel,hlcdc-pwm\" },\n\t{   },\n};\n\nstatic struct platform_driver atmel_hlcdc_pwm_driver = {\n\t.driver = {\n\t\t.name = \"atmel-hlcdc-pwm\",\n\t\t.of_match_table = atmel_hlcdc_pwm_dt_ids,\n\t\t.pm = &atmel_hlcdc_pwm_pm_ops,\n\t},\n\t.probe = atmel_hlcdc_pwm_probe,\n\t.remove_new = atmel_hlcdc_pwm_remove,\n};\nmodule_platform_driver(atmel_hlcdc_pwm_driver);\n\nMODULE_ALIAS(\"platform:atmel-hlcdc-pwm\");\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Atmel HLCDC PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}