{
  "module_name": "core.c",
  "hash_id": "fea0f27279f0b9f7beb894cdcf1b2323c889972e20c1906bd982ac3351001508",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/core.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pwm.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <dt-bindings/pwm/pwm.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/pwm.h>\n\n#define MAX_PWMS 1024\n\nstatic DEFINE_MUTEX(pwm_lookup_lock);\nstatic LIST_HEAD(pwm_lookup_list);\n\n \nstatic DEFINE_MUTEX(pwm_lock);\n\nstatic LIST_HEAD(pwm_chips);\nstatic DECLARE_BITMAP(allocated_pwms, MAX_PWMS);\n\n \nstatic int alloc_pwms(unsigned int count)\n{\n\tunsigned int start;\n\n\tstart = bitmap_find_next_zero_area(allocated_pwms, MAX_PWMS, 0,\n\t\t\t\t\t   count, 0);\n\n\tif (start + count > MAX_PWMS)\n\t\treturn -ENOSPC;\n\n\tbitmap_set(allocated_pwms, start, count);\n\n\treturn start;\n}\n\n \nstatic void free_pwms(struct pwm_chip *chip)\n{\n\tbitmap_clear(allocated_pwms, chip->base, chip->npwm);\n\n\tkfree(chip->pwms);\n\tchip->pwms = NULL;\n}\n\nstatic struct pwm_chip *pwmchip_find_by_name(const char *name)\n{\n\tstruct pwm_chip *chip;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tmutex_lock(&pwm_lock);\n\n\tlist_for_each_entry(chip, &pwm_chips, list) {\n\t\tconst char *chip_name = dev_name(chip->dev);\n\n\t\tif (chip_name && strcmp(chip_name, name) == 0) {\n\t\t\tmutex_unlock(&pwm_lock);\n\t\t\treturn chip;\n\t\t}\n\t}\n\n\tmutex_unlock(&pwm_lock);\n\n\treturn NULL;\n}\n\nstatic int pwm_device_request(struct pwm_device *pwm, const char *label)\n{\n\tint err;\n\n\tif (test_bit(PWMF_REQUESTED, &pwm->flags))\n\t\treturn -EBUSY;\n\n\tif (!try_module_get(pwm->chip->ops->owner))\n\t\treturn -ENODEV;\n\n\tif (pwm->chip->ops->request) {\n\t\terr = pwm->chip->ops->request(pwm->chip, pwm);\n\t\tif (err) {\n\t\t\tmodule_put(pwm->chip->ops->owner);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pwm->chip->ops->get_state) {\n\t\t \n\t\tstruct pwm_state state = { 0, };\n\n\t\terr = pwm->chip->ops->get_state(pwm->chip, pwm, &state);\n\t\ttrace_pwm_get(pwm, &state, err);\n\n\t\tif (!err)\n\t\t\tpwm->state = state;\n\n\t\tif (IS_ENABLED(CONFIG_PWM_DEBUG))\n\t\t\tpwm->last = pwm->state;\n\t}\n\n\tset_bit(PWMF_REQUESTED, &pwm->flags);\n\tpwm->label = label;\n\n\treturn 0;\n}\n\nstruct pwm_device *\nof_pwm_xlate_with_flags(struct pwm_chip *chip, const struct of_phandle_args *args)\n{\n\tstruct pwm_device *pwm;\n\n\tif (chip->of_pwm_n_cells < 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (args->args_count < 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (args->args[0] >= chip->npwm)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpwm = pwm_request_from_chip(chip, args->args[0], NULL);\n\tif (IS_ERR(pwm))\n\t\treturn pwm;\n\n\tpwm->args.period = args->args[1];\n\tpwm->args.polarity = PWM_POLARITY_NORMAL;\n\n\tif (chip->of_pwm_n_cells >= 3) {\n\t\tif (args->args_count > 2 && args->args[2] & PWM_POLARITY_INVERTED)\n\t\t\tpwm->args.polarity = PWM_POLARITY_INVERSED;\n\t}\n\n\treturn pwm;\n}\nEXPORT_SYMBOL_GPL(of_pwm_xlate_with_flags);\n\nstruct pwm_device *\nof_pwm_single_xlate(struct pwm_chip *chip, const struct of_phandle_args *args)\n{\n\tstruct pwm_device *pwm;\n\n\tif (chip->of_pwm_n_cells < 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (args->args_count != 1 && args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpwm = pwm_request_from_chip(chip, 0, NULL);\n\tif (IS_ERR(pwm))\n\t\treturn pwm;\n\n\tpwm->args.period = args->args[0];\n\tpwm->args.polarity = PWM_POLARITY_NORMAL;\n\n\tif (args->args_count == 2 && args->args[1] & PWM_POLARITY_INVERTED)\n\t\tpwm->args.polarity = PWM_POLARITY_INVERSED;\n\n\treturn pwm;\n}\nEXPORT_SYMBOL_GPL(of_pwm_single_xlate);\n\nstatic void of_pwmchip_add(struct pwm_chip *chip)\n{\n\tif (!chip->dev || !chip->dev->of_node)\n\t\treturn;\n\n\tif (!chip->of_xlate) {\n\t\tu32 pwm_cells;\n\n\t\tif (of_property_read_u32(chip->dev->of_node, \"#pwm-cells\",\n\t\t\t\t\t &pwm_cells))\n\t\t\tpwm_cells = 2;\n\n\t\tchip->of_xlate = of_pwm_xlate_with_flags;\n\t\tchip->of_pwm_n_cells = pwm_cells;\n\t}\n\n\tof_node_get(chip->dev->of_node);\n}\n\nstatic void of_pwmchip_remove(struct pwm_chip *chip)\n{\n\tif (chip->dev)\n\t\tof_node_put(chip->dev->of_node);\n}\n\n \nint pwm_set_chip_data(struct pwm_device *pwm, void *data)\n{\n\tif (!pwm)\n\t\treturn -EINVAL;\n\n\tpwm->chip_data = data;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pwm_set_chip_data);\n\n \nvoid *pwm_get_chip_data(struct pwm_device *pwm)\n{\n\treturn pwm ? pwm->chip_data : NULL;\n}\nEXPORT_SYMBOL_GPL(pwm_get_chip_data);\n\nstatic bool pwm_ops_check(const struct pwm_chip *chip)\n{\n\tconst struct pwm_ops *ops = chip->ops;\n\n\tif (!ops->apply)\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_PWM_DEBUG) && !ops->get_state)\n\t\tdev_warn(chip->dev,\n\t\t\t \"Please implement the .get_state() callback\\n\");\n\n\treturn true;\n}\n\n \nint pwmchip_add(struct pwm_chip *chip)\n{\n\tstruct pwm_device *pwm;\n\tunsigned int i;\n\tint ret;\n\n\tif (!chip || !chip->dev || !chip->ops || !chip->npwm)\n\t\treturn -EINVAL;\n\n\tif (!pwm_ops_check(chip))\n\t\treturn -EINVAL;\n\n\tchip->pwms = kcalloc(chip->npwm, sizeof(*pwm), GFP_KERNEL);\n\tif (!chip->pwms)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&pwm_lock);\n\n\tret = alloc_pwms(chip->npwm);\n\tif (ret < 0) {\n\t\tmutex_unlock(&pwm_lock);\n\t\tkfree(chip->pwms);\n\t\treturn ret;\n\t}\n\n\tchip->base = ret;\n\n\tfor (i = 0; i < chip->npwm; i++) {\n\t\tpwm = &chip->pwms[i];\n\n\t\tpwm->chip = chip;\n\t\tpwm->pwm = chip->base + i;\n\t\tpwm->hwpwm = i;\n\t}\n\n\tlist_add(&chip->list, &pwm_chips);\n\n\tmutex_unlock(&pwm_lock);\n\n\tif (IS_ENABLED(CONFIG_OF))\n\t\tof_pwmchip_add(chip);\n\n\tpwmchip_sysfs_export(chip);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pwmchip_add);\n\n \nvoid pwmchip_remove(struct pwm_chip *chip)\n{\n\tpwmchip_sysfs_unexport(chip);\n\n\tif (IS_ENABLED(CONFIG_OF))\n\t\tof_pwmchip_remove(chip);\n\n\tmutex_lock(&pwm_lock);\n\n\tlist_del_init(&chip->list);\n\n\tfree_pwms(chip);\n\n\tmutex_unlock(&pwm_lock);\n}\nEXPORT_SYMBOL_GPL(pwmchip_remove);\n\nstatic void devm_pwmchip_remove(void *data)\n{\n\tstruct pwm_chip *chip = data;\n\n\tpwmchip_remove(chip);\n}\n\nint devm_pwmchip_add(struct device *dev, struct pwm_chip *chip)\n{\n\tint ret;\n\n\tret = pwmchip_add(chip);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, devm_pwmchip_remove, chip);\n}\nEXPORT_SYMBOL_GPL(devm_pwmchip_add);\n\n \nstruct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,\n\t\t\t\t\t unsigned int index,\n\t\t\t\t\t const char *label)\n{\n\tstruct pwm_device *pwm;\n\tint err;\n\n\tif (!chip || index >= chip->npwm)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&pwm_lock);\n\tpwm = &chip->pwms[index];\n\n\terr = pwm_device_request(pwm, label);\n\tif (err < 0)\n\t\tpwm = ERR_PTR(err);\n\n\tmutex_unlock(&pwm_lock);\n\treturn pwm;\n}\nEXPORT_SYMBOL_GPL(pwm_request_from_chip);\n\nstatic void pwm_apply_state_debug(struct pwm_device *pwm,\n\t\t\t\t  const struct pwm_state *state)\n{\n\tstruct pwm_state *last = &pwm->last;\n\tstruct pwm_chip *chip = pwm->chip;\n\tstruct pwm_state s1 = { 0 }, s2 = { 0 };\n\tint err;\n\n\tif (!IS_ENABLED(CONFIG_PWM_DEBUG))\n\t\treturn;\n\n\t \n\tif (!chip->ops->get_state)\n\t\treturn;\n\n\t \n\n\terr = chip->ops->get_state(chip, pwm, &s1);\n\ttrace_pwm_get(pwm, &s1, err);\n\tif (err)\n\t\t \n\t\treturn;\n\n\t \n\tif (s1.enabled && s1.polarity != state->polarity) {\n\t\ts2.polarity = state->polarity;\n\t\ts2.duty_cycle = s1.period - s1.duty_cycle;\n\t\ts2.period = s1.period;\n\t\ts2.enabled = s1.enabled;\n\t} else {\n\t\ts2 = s1;\n\t}\n\n\tif (s2.polarity != state->polarity &&\n\t    state->duty_cycle < state->period)\n\t\tdev_warn(chip->dev, \".apply ignored .polarity\\n\");\n\n\tif (state->enabled &&\n\t    last->polarity == state->polarity &&\n\t    last->period > s2.period &&\n\t    last->period <= state->period)\n\t\tdev_warn(chip->dev,\n\t\t\t \".apply didn't pick the best available period (requested: %llu, applied: %llu, possible: %llu)\\n\",\n\t\t\t state->period, s2.period, last->period);\n\n\tif (state->enabled && state->period < s2.period)\n\t\tdev_warn(chip->dev,\n\t\t\t \".apply is supposed to round down period (requested: %llu, applied: %llu)\\n\",\n\t\t\t state->period, s2.period);\n\n\tif (state->enabled &&\n\t    last->polarity == state->polarity &&\n\t    last->period == s2.period &&\n\t    last->duty_cycle > s2.duty_cycle &&\n\t    last->duty_cycle <= state->duty_cycle)\n\t\tdev_warn(chip->dev,\n\t\t\t \".apply didn't pick the best available duty cycle (requested: %llu/%llu, applied: %llu/%llu, possible: %llu/%llu)\\n\",\n\t\t\t state->duty_cycle, state->period,\n\t\t\t s2.duty_cycle, s2.period,\n\t\t\t last->duty_cycle, last->period);\n\n\tif (state->enabled && state->duty_cycle < s2.duty_cycle)\n\t\tdev_warn(chip->dev,\n\t\t\t \".apply is supposed to round down duty_cycle (requested: %llu/%llu, applied: %llu/%llu)\\n\",\n\t\t\t state->duty_cycle, state->period,\n\t\t\t s2.duty_cycle, s2.period);\n\n\tif (!state->enabled && s2.enabled && s2.duty_cycle > 0)\n\t\tdev_warn(chip->dev,\n\t\t\t \"requested disabled, but yielded enabled with duty > 0\\n\");\n\n\t \n\terr = chip->ops->apply(chip, pwm, &s1);\n\ttrace_pwm_apply(pwm, &s1, err);\n\tif (err) {\n\t\t*last = s1;\n\t\tdev_err(chip->dev, \"failed to reapply current setting\\n\");\n\t\treturn;\n\t}\n\n\t*last = (struct pwm_state){ 0 };\n\terr = chip->ops->get_state(chip, pwm, last);\n\ttrace_pwm_get(pwm, last, err);\n\tif (err)\n\t\treturn;\n\n\t \n\tif (s1.enabled != last->enabled ||\n\t    s1.polarity != last->polarity ||\n\t    (s1.enabled && s1.period != last->period) ||\n\t    (s1.enabled && s1.duty_cycle != last->duty_cycle)) {\n\t\tdev_err(chip->dev,\n\t\t\t\".apply is not idempotent (ena=%d pol=%d %llu/%llu) -> (ena=%d pol=%d %llu/%llu)\\n\",\n\t\t\ts1.enabled, s1.polarity, s1.duty_cycle, s1.period,\n\t\t\tlast->enabled, last->polarity, last->duty_cycle,\n\t\t\tlast->period);\n\t}\n}\n\n \nint pwm_apply_state(struct pwm_device *pwm, const struct pwm_state *state)\n{\n\tstruct pwm_chip *chip;\n\tint err;\n\n\t \n\tmight_sleep();\n\n\tif (!pwm || !state || !state->period ||\n\t    state->duty_cycle > state->period)\n\t\treturn -EINVAL;\n\n\tchip = pwm->chip;\n\n\tif (state->period == pwm->state.period &&\n\t    state->duty_cycle == pwm->state.duty_cycle &&\n\t    state->polarity == pwm->state.polarity &&\n\t    state->enabled == pwm->state.enabled &&\n\t    state->usage_power == pwm->state.usage_power)\n\t\treturn 0;\n\n\terr = chip->ops->apply(chip, pwm, state);\n\ttrace_pwm_apply(pwm, state, err);\n\tif (err)\n\t\treturn err;\n\n\tpwm->state = *state;\n\n\t \n\tpwm_apply_state_debug(pwm, state);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pwm_apply_state);\n\n \nint pwm_capture(struct pwm_device *pwm, struct pwm_capture *result,\n\t\tunsigned long timeout)\n{\n\tint err;\n\n\tif (!pwm || !pwm->chip->ops)\n\t\treturn -EINVAL;\n\n\tif (!pwm->chip->ops->capture)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&pwm_lock);\n\terr = pwm->chip->ops->capture(pwm->chip, pwm, result, timeout);\n\tmutex_unlock(&pwm_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(pwm_capture);\n\n \nint pwm_adjust_config(struct pwm_device *pwm)\n{\n\tstruct pwm_state state;\n\tstruct pwm_args pargs;\n\n\tpwm_get_args(pwm, &pargs);\n\tpwm_get_state(pwm, &state);\n\n\t \n\tif (!state.period) {\n\t\tstate.duty_cycle = 0;\n\t\tstate.period = pargs.period;\n\t\tstate.polarity = pargs.polarity;\n\n\t\treturn pwm_apply_state(pwm, &state);\n\t}\n\n\t \n\tif (pargs.period != state.period) {\n\t\tu64 dutycycle = (u64)state.duty_cycle * pargs.period;\n\n\t\tdo_div(dutycycle, state.period);\n\t\tstate.duty_cycle = dutycycle;\n\t\tstate.period = pargs.period;\n\t}\n\n\t \n\tif (pargs.polarity != state.polarity) {\n\t\tstate.polarity = pargs.polarity;\n\t\tstate.duty_cycle = state.period - state.duty_cycle;\n\t}\n\n\treturn pwm_apply_state(pwm, &state);\n}\nEXPORT_SYMBOL_GPL(pwm_adjust_config);\n\nstatic struct pwm_chip *fwnode_to_pwmchip(struct fwnode_handle *fwnode)\n{\n\tstruct pwm_chip *chip;\n\n\tmutex_lock(&pwm_lock);\n\n\tlist_for_each_entry(chip, &pwm_chips, list)\n\t\tif (chip->dev && device_match_fwnode(chip->dev, fwnode)) {\n\t\t\tmutex_unlock(&pwm_lock);\n\t\t\treturn chip;\n\t\t}\n\n\tmutex_unlock(&pwm_lock);\n\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\n\nstatic struct device_link *pwm_device_link_add(struct device *dev,\n\t\t\t\t\t       struct pwm_device *pwm)\n{\n\tstruct device_link *dl;\n\n\tif (!dev) {\n\t\t \n\t\tdev_warn(pwm->chip->dev,\n\t\t\t \"No consumer device specified to create a link to\\n\");\n\t\treturn NULL;\n\t}\n\n\tdl = device_link_add(dev, pwm->chip->dev, DL_FLAG_AUTOREMOVE_CONSUMER);\n\tif (!dl) {\n\t\tdev_err(dev, \"failed to create device link to %s\\n\",\n\t\t\tdev_name(pwm->chip->dev));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn dl;\n}\n\n \nstatic struct pwm_device *of_pwm_get(struct device *dev, struct device_node *np,\n\t\t\t\t     const char *con_id)\n{\n\tstruct pwm_device *pwm = NULL;\n\tstruct of_phandle_args args;\n\tstruct device_link *dl;\n\tstruct pwm_chip *chip;\n\tint index = 0;\n\tint err;\n\n\tif (con_id) {\n\t\tindex = of_property_match_string(np, \"pwm-names\", con_id);\n\t\tif (index < 0)\n\t\t\treturn ERR_PTR(index);\n\t}\n\n\terr = of_parse_phandle_with_args(np, \"pwms\", \"#pwm-cells\", index,\n\t\t\t\t\t &args);\n\tif (err) {\n\t\tpr_err(\"%s(): can't parse \\\"pwms\\\" property\\n\", __func__);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tchip = fwnode_to_pwmchip(of_fwnode_handle(args.np));\n\tif (IS_ERR(chip)) {\n\t\tif (PTR_ERR(chip) != -EPROBE_DEFER)\n\t\t\tpr_err(\"%s(): PWM chip not found\\n\", __func__);\n\n\t\tpwm = ERR_CAST(chip);\n\t\tgoto put;\n\t}\n\n\tpwm = chip->of_xlate(chip, &args);\n\tif (IS_ERR(pwm))\n\t\tgoto put;\n\n\tdl = pwm_device_link_add(dev, pwm);\n\tif (IS_ERR(dl)) {\n\t\t \n\t\tpwm_put(pwm);\n\t\tpwm = ERR_CAST(dl);\n\t\tgoto put;\n\t}\n\n\t \n\tif (!con_id) {\n\t\terr = of_property_read_string_index(np, \"pwm-names\", index,\n\t\t\t\t\t\t    &con_id);\n\t\tif (err < 0)\n\t\t\tcon_id = np->name;\n\t}\n\n\tpwm->label = con_id;\n\nput:\n\tof_node_put(args.np);\n\n\treturn pwm;\n}\n\n \nstatic struct pwm_device *acpi_pwm_get(const struct fwnode_handle *fwnode)\n{\n\tstruct pwm_device *pwm;\n\tstruct fwnode_reference_args args;\n\tstruct pwm_chip *chip;\n\tint ret;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tret = __acpi_node_get_property_reference(fwnode, \"pwms\", 0, 3, &args);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (args.nargs < 2)\n\t\treturn ERR_PTR(-EPROTO);\n\n\tchip = fwnode_to_pwmchip(args.fwnode);\n\tif (IS_ERR(chip))\n\t\treturn ERR_CAST(chip);\n\n\tpwm = pwm_request_from_chip(chip, args.args[0], NULL);\n\tif (IS_ERR(pwm))\n\t\treturn pwm;\n\n\tpwm->args.period = args.args[1];\n\tpwm->args.polarity = PWM_POLARITY_NORMAL;\n\n\tif (args.nargs > 2 && args.args[2] & PWM_POLARITY_INVERTED)\n\t\tpwm->args.polarity = PWM_POLARITY_INVERSED;\n\n\treturn pwm;\n}\n\n \nvoid pwm_add_table(struct pwm_lookup *table, size_t num)\n{\n\tmutex_lock(&pwm_lookup_lock);\n\n\twhile (num--) {\n\t\tlist_add_tail(&table->list, &pwm_lookup_list);\n\t\ttable++;\n\t}\n\n\tmutex_unlock(&pwm_lookup_lock);\n}\n\n \nvoid pwm_remove_table(struct pwm_lookup *table, size_t num)\n{\n\tmutex_lock(&pwm_lookup_lock);\n\n\twhile (num--) {\n\t\tlist_del(&table->list);\n\t\ttable++;\n\t}\n\n\tmutex_unlock(&pwm_lookup_lock);\n}\n\n \nstruct pwm_device *pwm_get(struct device *dev, const char *con_id)\n{\n\tconst struct fwnode_handle *fwnode = dev ? dev_fwnode(dev) : NULL;\n\tconst char *dev_id = dev ? dev_name(dev) : NULL;\n\tstruct pwm_device *pwm;\n\tstruct pwm_chip *chip;\n\tstruct device_link *dl;\n\tunsigned int best = 0;\n\tstruct pwm_lookup *p, *chosen = NULL;\n\tunsigned int match;\n\tint err;\n\n\t \n\tif (is_of_node(fwnode))\n\t\treturn of_pwm_get(dev, to_of_node(fwnode), con_id);\n\n\t \n\tif (is_acpi_node(fwnode)) {\n\t\tpwm = acpi_pwm_get(fwnode);\n\t\tif (!IS_ERR(pwm) || PTR_ERR(pwm) != -ENOENT)\n\t\t\treturn pwm;\n\t}\n\n\t \n\tmutex_lock(&pwm_lookup_lock);\n\n\tlist_for_each_entry(p, &pwm_lookup_list, list) {\n\t\tmatch = 0;\n\n\t\tif (p->dev_id) {\n\t\t\tif (!dev_id || strcmp(p->dev_id, dev_id))\n\t\t\t\tcontinue;\n\n\t\t\tmatch += 2;\n\t\t}\n\n\t\tif (p->con_id) {\n\t\t\tif (!con_id || strcmp(p->con_id, con_id))\n\t\t\t\tcontinue;\n\n\t\t\tmatch += 1;\n\t\t}\n\n\t\tif (match > best) {\n\t\t\tchosen = p;\n\n\t\t\tif (match != 3)\n\t\t\t\tbest = match;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&pwm_lookup_lock);\n\n\tif (!chosen)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tchip = pwmchip_find_by_name(chosen->provider);\n\n\t \n\tif (!chip && chosen->module) {\n\t\terr = request_module(chosen->module);\n\t\tif (err == 0)\n\t\t\tchip = pwmchip_find_by_name(chosen->provider);\n\t}\n\n\tif (!chip)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tpwm = pwm_request_from_chip(chip, chosen->index, con_id ?: dev_id);\n\tif (IS_ERR(pwm))\n\t\treturn pwm;\n\n\tdl = pwm_device_link_add(dev, pwm);\n\tif (IS_ERR(dl)) {\n\t\tpwm_put(pwm);\n\t\treturn ERR_CAST(dl);\n\t}\n\n\tpwm->args.period = chosen->period;\n\tpwm->args.polarity = chosen->polarity;\n\n\treturn pwm;\n}\nEXPORT_SYMBOL_GPL(pwm_get);\n\n \nvoid pwm_put(struct pwm_device *pwm)\n{\n\tif (!pwm)\n\t\treturn;\n\n\tmutex_lock(&pwm_lock);\n\n\tif (!test_and_clear_bit(PWMF_REQUESTED, &pwm->flags)) {\n\t\tpr_warn(\"PWM device already freed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (pwm->chip->ops->free)\n\t\tpwm->chip->ops->free(pwm->chip, pwm);\n\n\tpwm_set_chip_data(pwm, NULL);\n\tpwm->label = NULL;\n\n\tmodule_put(pwm->chip->ops->owner);\nout:\n\tmutex_unlock(&pwm_lock);\n}\nEXPORT_SYMBOL_GPL(pwm_put);\n\nstatic void devm_pwm_release(void *pwm)\n{\n\tpwm_put(pwm);\n}\n\n \nstruct pwm_device *devm_pwm_get(struct device *dev, const char *con_id)\n{\n\tstruct pwm_device *pwm;\n\tint ret;\n\n\tpwm = pwm_get(dev, con_id);\n\tif (IS_ERR(pwm))\n\t\treturn pwm;\n\n\tret = devm_add_action_or_reset(dev, devm_pwm_release, pwm);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn pwm;\n}\nEXPORT_SYMBOL_GPL(devm_pwm_get);\n\n \nstruct pwm_device *devm_fwnode_pwm_get(struct device *dev,\n\t\t\t\t       struct fwnode_handle *fwnode,\n\t\t\t\t       const char *con_id)\n{\n\tstruct pwm_device *pwm = ERR_PTR(-ENODEV);\n\tint ret;\n\n\tif (is_of_node(fwnode))\n\t\tpwm = of_pwm_get(dev, to_of_node(fwnode), con_id);\n\telse if (is_acpi_node(fwnode))\n\t\tpwm = acpi_pwm_get(fwnode);\n\tif (IS_ERR(pwm))\n\t\treturn pwm;\n\n\tret = devm_add_action_or_reset(dev, devm_pwm_release, pwm);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn pwm;\n}\nEXPORT_SYMBOL_GPL(devm_fwnode_pwm_get);\n\n#ifdef CONFIG_DEBUG_FS\nstatic void pwm_dbg_show(struct pwm_chip *chip, struct seq_file *s)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < chip->npwm; i++) {\n\t\tstruct pwm_device *pwm = &chip->pwms[i];\n\t\tstruct pwm_state state;\n\n\t\tpwm_get_state(pwm, &state);\n\n\t\tseq_printf(s, \" pwm-%-3d (%-20.20s):\", i, pwm->label);\n\n\t\tif (test_bit(PWMF_REQUESTED, &pwm->flags))\n\t\t\tseq_puts(s, \" requested\");\n\n\t\tif (state.enabled)\n\t\t\tseq_puts(s, \" enabled\");\n\n\t\tseq_printf(s, \" period: %llu ns\", state.period);\n\t\tseq_printf(s, \" duty: %llu ns\", state.duty_cycle);\n\t\tseq_printf(s, \" polarity: %s\",\n\t\t\t   state.polarity ? \"inverse\" : \"normal\");\n\n\t\tif (state.usage_power)\n\t\t\tseq_puts(s, \" usage_power\");\n\n\t\tseq_puts(s, \"\\n\");\n\t}\n}\n\nstatic void *pwm_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tmutex_lock(&pwm_lock);\n\ts->private = \"\";\n\n\treturn seq_list_start(&pwm_chips, *pos);\n}\n\nstatic void *pwm_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\ts->private = \"\\n\";\n\n\treturn seq_list_next(v, &pwm_chips, pos);\n}\n\nstatic void pwm_seq_stop(struct seq_file *s, void *v)\n{\n\tmutex_unlock(&pwm_lock);\n}\n\nstatic int pwm_seq_show(struct seq_file *s, void *v)\n{\n\tstruct pwm_chip *chip = list_entry(v, struct pwm_chip, list);\n\n\tseq_printf(s, \"%s%s/%s, %d PWM device%s\\n\", (char *)s->private,\n\t\t   chip->dev->bus ? chip->dev->bus->name : \"no-bus\",\n\t\t   dev_name(chip->dev), chip->npwm,\n\t\t   (chip->npwm != 1) ? \"s\" : \"\");\n\n\tpwm_dbg_show(chip, s);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations pwm_debugfs_sops = {\n\t.start = pwm_seq_start,\n\t.next = pwm_seq_next,\n\t.stop = pwm_seq_stop,\n\t.show = pwm_seq_show,\n};\n\nDEFINE_SEQ_ATTRIBUTE(pwm_debugfs);\n\nstatic int __init pwm_debugfs_init(void)\n{\n\tdebugfs_create_file(\"pwm\", 0444, NULL, NULL, &pwm_debugfs_fops);\n\n\treturn 0;\n}\nsubsys_initcall(pwm_debugfs_init);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}