{
  "module_name": "pwm-cros-ec.c",
  "hash_id": "edcd1fc1b58e02eb8eab838b249de462d5fc13e82fb06c73b7a227340c0182f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-cros-ec.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/mfd/cros_ec.h>\n\n \nstruct cros_ec_pwm_device {\n\tstruct device *dev;\n\tstruct cros_ec_device *ec;\n\tstruct pwm_chip chip;\n\tbool use_pwm_type;\n};\n\n \nstruct cros_ec_pwm {\n\tu16 duty_cycle;\n};\n\nstatic inline struct cros_ec_pwm_device *pwm_to_cros_ec_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct cros_ec_pwm_device, chip);\n}\n\nstatic int cros_ec_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct cros_ec_pwm *channel;\n\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn -ENOMEM;\n\n\tpwm_set_chip_data(pwm, channel);\n\n\treturn 0;\n}\n\nstatic void cros_ec_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct cros_ec_pwm *channel = pwm_get_chip_data(pwm);\n\n\tkfree(channel);\n}\n\nstatic int cros_ec_dt_type_to_pwm_type(u8 dt_index, u8 *pwm_type)\n{\n\tswitch (dt_index) {\n\tcase CROS_EC_PWM_DT_KB_LIGHT:\n\t\t*pwm_type = EC_PWM_TYPE_KB_LIGHT;\n\t\treturn 0;\n\tcase CROS_EC_PWM_DT_DISPLAY_LIGHT:\n\t\t*pwm_type = EC_PWM_TYPE_DISPLAY_LIGHT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int cros_ec_pwm_set_duty(struct cros_ec_pwm_device *ec_pwm, u8 index,\n\t\t\t\tu16 duty)\n{\n\tstruct cros_ec_device *ec = ec_pwm->ec;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tstruct ec_params_pwm_set_duty params;\n\t} __packed buf;\n\tstruct ec_params_pwm_set_duty *params = &buf.params;\n\tstruct cros_ec_command *msg = &buf.msg;\n\tint ret;\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_PWM_SET_DUTY;\n\tmsg->insize = 0;\n\tmsg->outsize = sizeof(*params);\n\n\tparams->duty = duty;\n\n\tif (ec_pwm->use_pwm_type) {\n\t\tret = cros_ec_dt_type_to_pwm_type(index, &params->pwm_type);\n\t\tif (ret) {\n\t\t\tdev_err(ec->dev, \"Invalid PWM type index: %d\\n\", index);\n\t\t\treturn ret;\n\t\t}\n\t\tparams->index = 0;\n\t} else {\n\t\tparams->pwm_type = EC_PWM_TYPE_GENERIC;\n\t\tparams->index = index;\n\t}\n\n\treturn cros_ec_cmd_xfer_status(ec, msg);\n}\n\nstatic int cros_ec_pwm_get_duty(struct cros_ec_pwm_device *ec_pwm, u8 index)\n{\n\tstruct cros_ec_device *ec = ec_pwm->ec;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tunion {\n\t\t\tstruct ec_params_pwm_get_duty params;\n\t\t\tstruct ec_response_pwm_get_duty resp;\n\t\t};\n\t} __packed buf;\n\tstruct ec_params_pwm_get_duty *params = &buf.params;\n\tstruct ec_response_pwm_get_duty *resp = &buf.resp;\n\tstruct cros_ec_command *msg = &buf.msg;\n\tint ret;\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_PWM_GET_DUTY;\n\tmsg->insize = sizeof(*resp);\n\tmsg->outsize = sizeof(*params);\n\n\tif (ec_pwm->use_pwm_type) {\n\t\tret = cros_ec_dt_type_to_pwm_type(index, &params->pwm_type);\n\t\tif (ret) {\n\t\t\tdev_err(ec->dev, \"Invalid PWM type index: %d\\n\", index);\n\t\t\treturn ret;\n\t\t}\n\t\tparams->index = 0;\n\t} else {\n\t\tparams->pwm_type = EC_PWM_TYPE_GENERIC;\n\t\tparams->index = index;\n\t}\n\n\tret = cros_ec_cmd_xfer_status(ec, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn resp->duty;\n}\n\nstatic int cros_ec_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tstruct cros_ec_pwm_device *ec_pwm = pwm_to_cros_ec_pwm(chip);\n\tstruct cros_ec_pwm *channel = pwm_get_chip_data(pwm);\n\tu16 duty_cycle;\n\tint ret;\n\n\t \n\tif (state->period != EC_PWM_MAX_DUTY)\n\t\treturn -EINVAL;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\t \n\tduty_cycle = state->enabled ? state->duty_cycle : 0;\n\n\tret = cros_ec_pwm_set_duty(ec_pwm, pwm->hwpwm, duty_cycle);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchannel->duty_cycle = state->duty_cycle;\n\n\treturn 0;\n}\n\nstatic int cros_ec_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t struct pwm_state *state)\n{\n\tstruct cros_ec_pwm_device *ec_pwm = pwm_to_cros_ec_pwm(chip);\n\tstruct cros_ec_pwm *channel = pwm_get_chip_data(pwm);\n\tint ret;\n\n\tret = cros_ec_pwm_get_duty(ec_pwm, pwm->hwpwm);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"error getting initial duty: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tstate->enabled = (ret > 0);\n\tstate->period = EC_PWM_MAX_DUTY;\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\t \n\tif (ret == 0 && channel->duty_cycle > 0)\n\t\tstate->duty_cycle = channel->duty_cycle;\n\telse\n\t\tstate->duty_cycle = ret;\n\n\treturn 0;\n}\n\nstatic struct pwm_device *\ncros_ec_pwm_xlate(struct pwm_chip *chip, const struct of_phandle_args *args)\n{\n\tstruct pwm_device *pwm;\n\n\tif (args->args[0] >= chip->npwm)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpwm = pwm_request_from_chip(chip, args->args[0], NULL);\n\tif (IS_ERR(pwm))\n\t\treturn pwm;\n\n\t \n\tpwm->args.period = EC_PWM_MAX_DUTY;\n\n\treturn pwm;\n}\n\nstatic const struct pwm_ops cros_ec_pwm_ops = {\n\t.request = cros_ec_pwm_request,\n\t.free = cros_ec_pwm_free,\n\t.get_state\t= cros_ec_pwm_get_state,\n\t.apply\t\t= cros_ec_pwm_apply,\n\t.owner\t\t= THIS_MODULE,\n};\n\n \nstatic int cros_ec_num_pwms(struct cros_ec_pwm_device *ec_pwm)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0; i <= U8_MAX; i++) {\n\t\tret = cros_ec_pwm_get_duty(ec_pwm, i);\n\t\t \n\t\tswitch (ret) {\n\t\tcase -EOPNOTSUPP:\t \n\t\t\treturn -ENODEV;\n\t\tcase -EINVAL:\t\t \n\t\t\treturn i;\n\t\tdefault:\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn U8_MAX;\n}\n\nstatic int cros_ec_pwm_probe(struct platform_device *pdev)\n{\n\tstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct cros_ec_pwm_device *ec_pwm;\n\tstruct pwm_chip *chip;\n\tint ret;\n\n\tif (!ec) {\n\t\tdev_err(dev, \"no parent EC device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tec_pwm = devm_kzalloc(dev, sizeof(*ec_pwm), GFP_KERNEL);\n\tif (!ec_pwm)\n\t\treturn -ENOMEM;\n\tchip = &ec_pwm->chip;\n\tec_pwm->ec = ec;\n\n\tif (of_device_is_compatible(np, \"google,cros-ec-pwm-type\"))\n\t\tec_pwm->use_pwm_type = true;\n\n\t \n\tchip->dev = dev;\n\tchip->ops = &cros_ec_pwm_ops;\n\tchip->of_xlate = cros_ec_pwm_xlate;\n\tchip->of_pwm_n_cells = 1;\n\n\tif (ec_pwm->use_pwm_type) {\n\t\tchip->npwm = CROS_EC_PWM_DT_COUNT;\n\t} else {\n\t\tret = cros_ec_num_pwms(ec_pwm);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Couldn't find PWMs: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tchip->npwm = ret;\n\t}\n\n\tdev_dbg(dev, \"Probed %u PWMs\\n\", chip->npwm);\n\n\tret = pwmchip_add(chip);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot register PWM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, ec_pwm);\n\n\treturn ret;\n}\n\nstatic void cros_ec_pwm_remove(struct platform_device *dev)\n{\n\tstruct cros_ec_pwm_device *ec_pwm = platform_get_drvdata(dev);\n\tstruct pwm_chip *chip = &ec_pwm->chip;\n\n\tpwmchip_remove(chip);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cros_ec_pwm_of_match[] = {\n\t{ .compatible = \"google,cros-ec-pwm\" },\n\t{ .compatible = \"google,cros-ec-pwm-type\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cros_ec_pwm_of_match);\n#endif\n\nstatic struct platform_driver cros_ec_pwm_driver = {\n\t.probe = cros_ec_pwm_probe,\n\t.remove_new = cros_ec_pwm_remove,\n\t.driver = {\n\t\t.name = \"cros-ec-pwm\",\n\t\t.of_match_table = of_match_ptr(cros_ec_pwm_of_match),\n\t},\n};\nmodule_platform_driver(cros_ec_pwm_driver);\n\nMODULE_ALIAS(\"platform:cros-ec-pwm\");\nMODULE_DESCRIPTION(\"ChromeOS EC PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}