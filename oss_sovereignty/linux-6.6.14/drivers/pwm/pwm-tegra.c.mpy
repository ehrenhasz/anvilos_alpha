{
  "module_name": "pwm-tegra.c",
  "hash_id": "1c1bce19f803024f678c7c3ce3b3f4c61f6a3bbec6d64b0f558f05251e788f7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_opp.h>\n#include <linux/pwm.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/common.h>\n\n#define PWM_ENABLE\t(1 << 31)\n#define PWM_DUTY_WIDTH\t8\n#define PWM_DUTY_SHIFT\t16\n#define PWM_SCALE_WIDTH\t13\n#define PWM_SCALE_SHIFT\t0\n\nstruct tegra_pwm_soc {\n\tunsigned int num_channels;\n\n\t \n\tunsigned long max_frequency;\n};\n\nstruct tegra_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct device *dev;\n\n\tstruct clk *clk;\n\tstruct reset_control*rst;\n\n\tunsigned long clk_rate;\n\tunsigned long min_period_ns;\n\n\tvoid __iomem *regs;\n\n\tconst struct tegra_pwm_soc *soc;\n};\n\nstatic inline struct tegra_pwm_chip *to_tegra_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct tegra_pwm_chip, chip);\n}\n\nstatic inline u32 pwm_readl(struct tegra_pwm_chip *pc, unsigned int offset)\n{\n\treturn readl(pc->regs + (offset << 4));\n}\n\nstatic inline void pwm_writel(struct tegra_pwm_chip *pc, unsigned int offset, u32 value)\n{\n\twritel(value, pc->regs + (offset << 4));\n}\n\nstatic int tegra_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    int duty_ns, int period_ns)\n{\n\tstruct tegra_pwm_chip *pc = to_tegra_pwm_chip(chip);\n\tunsigned long long c = duty_ns;\n\tunsigned long rate, required_clk_rate;\n\tu32 val = 0;\n\tint err;\n\n\t \n\tc *= (1 << PWM_DUTY_WIDTH);\n\tc = DIV_ROUND_CLOSEST_ULL(c, period_ns);\n\n\tval = (u32)c << PWM_DUTY_SHIFT;\n\n\t \n\tif (period_ns < pc->min_period_ns)\n\t\treturn -EINVAL;\n\n\t \n\tif (pc->soc->num_channels == 1) {\n\t\t \n\t\trequired_clk_rate = DIV_ROUND_UP_ULL((u64)NSEC_PER_SEC << PWM_DUTY_WIDTH,\n\t\t\t\t\t\t     period_ns);\n\n\t\tif (required_clk_rate > clk_round_rate(pc->clk, required_clk_rate))\n\t\t\t \n\t\t\trequired_clk_rate *= 2;\n\n\t\terr = dev_pm_opp_set_rate(pc->dev, required_clk_rate);\n\t\tif (err < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tpc->clk_rate = clk_get_rate(pc->clk);\n\t}\n\n\t \n\trate = mul_u64_u64_div_u64(pc->clk_rate, period_ns,\n\t\t\t\t   (u64)NSEC_PER_SEC << PWM_DUTY_WIDTH);\n\n\t \n\tif (rate > 0)\n\t\trate--;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tif (rate >> PWM_SCALE_WIDTH)\n\t\treturn -EINVAL;\n\n\tval |= rate << PWM_SCALE_SHIFT;\n\n\t \n\tif (!pwm_is_enabled(pwm)) {\n\t\terr = pm_runtime_resume_and_get(pc->dev);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\tval |= PWM_ENABLE;\n\n\tpwm_writel(pc, pwm->hwpwm, val);\n\n\t \n\tif (!pwm_is_enabled(pwm))\n\t\tpm_runtime_put(pc->dev);\n\n\treturn 0;\n}\n\nstatic int tegra_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct tegra_pwm_chip *pc = to_tegra_pwm_chip(chip);\n\tint rc = 0;\n\tu32 val;\n\n\trc = pm_runtime_resume_and_get(pc->dev);\n\tif (rc)\n\t\treturn rc;\n\n\tval = pwm_readl(pc, pwm->hwpwm);\n\tval |= PWM_ENABLE;\n\tpwm_writel(pc, pwm->hwpwm, val);\n\n\treturn 0;\n}\n\nstatic void tegra_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct tegra_pwm_chip *pc = to_tegra_pwm_chip(chip);\n\tu32 val;\n\n\tval = pwm_readl(pc, pwm->hwpwm);\n\tval &= ~PWM_ENABLE;\n\tpwm_writel(pc, pwm->hwpwm, val);\n\n\tpm_runtime_put_sync(pc->dev);\n}\n\nstatic int tegra_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tint err;\n\tbool enabled = pwm->state.enabled;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\ttegra_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\terr = tegra_pwm_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!enabled)\n\t\terr = tegra_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops tegra_pwm_ops = {\n\t.apply = tegra_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int tegra_pwm_probe(struct platform_device *pdev)\n{\n\tstruct tegra_pwm_chip *pc;\n\tint ret;\n\n\tpc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tpc->soc = of_device_get_match_data(&pdev->dev);\n\tpc->dev = &pdev->dev;\n\n\tpc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->regs))\n\t\treturn PTR_ERR(pc->regs);\n\n\tplatform_set_drvdata(pdev, pc);\n\n\tpc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pc->clk))\n\t\treturn PTR_ERR(pc->clk);\n\n\tret = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = dev_pm_opp_set_rate(pc->dev, pc->soc->max_frequency);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to set max frequency: %d\\n\", ret);\n\t\tgoto put_pm;\n\t}\n\n\t \n\tpc->clk_rate = clk_get_rate(pc->clk);\n\n\t \n\tpc->min_period_ns =\n\t    (NSEC_PER_SEC / (pc->soc->max_frequency >> PWM_DUTY_WIDTH)) + 1;\n\n\tpc->rst = devm_reset_control_get_exclusive(&pdev->dev, \"pwm\");\n\tif (IS_ERR(pc->rst)) {\n\t\tret = PTR_ERR(pc->rst);\n\t\tdev_err(&pdev->dev, \"Reset control is not found: %d\\n\", ret);\n\t\tgoto put_pm;\n\t}\n\n\treset_control_deassert(pc->rst);\n\n\tpc->chip.dev = &pdev->dev;\n\tpc->chip.ops = &tegra_pwm_ops;\n\tpc->chip.npwm = pc->soc->num_channels;\n\n\tret = pwmchip_add(&pc->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pwmchip_add() failed: %d\\n\", ret);\n\t\treset_control_assert(pc->rst);\n\t\tgoto put_pm;\n\t}\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\nput_pm:\n\tpm_runtime_put_sync_suspend(&pdev->dev);\n\tpm_runtime_force_suspend(&pdev->dev);\n\treturn ret;\n}\n\nstatic void tegra_pwm_remove(struct platform_device *pdev)\n{\n\tstruct tegra_pwm_chip *pc = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&pc->chip);\n\n\treset_control_assert(pc->rst);\n\n\tpm_runtime_force_suspend(&pdev->dev);\n}\n\nstatic int __maybe_unused tegra_pwm_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_pwm_chip *pc = dev_get_drvdata(dev);\n\tint err;\n\n\tclk_disable_unprepare(pc->clk);\n\n\terr = pinctrl_pm_select_sleep_state(dev);\n\tif (err) {\n\t\tclk_prepare_enable(pc->clk);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_pwm_runtime_resume(struct device *dev)\n{\n\tstruct tegra_pwm_chip *pc = dev_get_drvdata(dev);\n\tint err;\n\n\terr = pinctrl_pm_select_default_state(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = clk_prepare_enable(pc->clk);\n\tif (err) {\n\t\tpinctrl_pm_select_sleep_state(dev);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tegra_pwm_soc tegra20_pwm_soc = {\n\t.num_channels = 4,\n\t.max_frequency = 48000000UL,\n};\n\nstatic const struct tegra_pwm_soc tegra186_pwm_soc = {\n\t.num_channels = 1,\n\t.max_frequency = 102000000UL,\n};\n\nstatic const struct tegra_pwm_soc tegra194_pwm_soc = {\n\t.num_channels = 1,\n\t.max_frequency = 408000000UL,\n};\n\nstatic const struct of_device_id tegra_pwm_of_match[] = {\n\t{ .compatible = \"nvidia,tegra20-pwm\", .data = &tegra20_pwm_soc },\n\t{ .compatible = \"nvidia,tegra186-pwm\", .data = &tegra186_pwm_soc },\n\t{ .compatible = \"nvidia,tegra194-pwm\", .data = &tegra194_pwm_soc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_pwm_of_match);\n\nstatic const struct dev_pm_ops tegra_pwm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra_pwm_runtime_suspend, tegra_pwm_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver tegra_pwm_driver = {\n\t.driver = {\n\t\t.name = \"tegra-pwm\",\n\t\t.of_match_table = tegra_pwm_of_match,\n\t\t.pm = &tegra_pwm_pm_ops,\n\t},\n\t.probe = tegra_pwm_probe,\n\t.remove_new = tegra_pwm_remove,\n};\n\nmodule_platform_driver(tegra_pwm_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sandipan Patra <spatra@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra PWM controller driver\");\nMODULE_ALIAS(\"platform:tegra-pwm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}