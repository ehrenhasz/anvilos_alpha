{
  "module_name": "pwm-stm32.c",
  "hash_id": "d9f817feba0391908fdc6cac8e92873758d8ca7d09a9e7385c243a04b82632b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-stm32.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/mfd/stm32-timers.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n#define CCMR_CHANNEL_SHIFT 8\n#define CCMR_CHANNEL_MASK  0xFF\n#define MAX_BREAKINPUT 2\n\nstruct stm32_breakinput {\n\tu32 index;\n\tu32 level;\n\tu32 filter;\n};\n\nstruct stm32_pwm {\n\tstruct pwm_chip chip;\n\tstruct mutex lock;  \n\tstruct clk *clk;\n\tstruct regmap *regmap;\n\tu32 max_arr;\n\tbool have_complementary_output;\n\tstruct stm32_breakinput breakinputs[MAX_BREAKINPUT];\n\tunsigned int num_breakinputs;\n\tu32 capture[4] ____cacheline_aligned;  \n};\n\nstatic inline struct stm32_pwm *to_stm32_pwm_dev(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct stm32_pwm, chip);\n}\n\nstatic u32 active_channels(struct stm32_pwm *dev)\n{\n\tu32 ccer;\n\n\tregmap_read(dev->regmap, TIM_CCER, &ccer);\n\n\treturn ccer & TIM_CCER_CCXE;\n}\n\nstatic int write_ccrx(struct stm32_pwm *dev, int ch, u32 value)\n{\n\tswitch (ch) {\n\tcase 0:\n\t\treturn regmap_write(dev->regmap, TIM_CCR1, value);\n\tcase 1:\n\t\treturn regmap_write(dev->regmap, TIM_CCR2, value);\n\tcase 2:\n\t\treturn regmap_write(dev->regmap, TIM_CCR3, value);\n\tcase 3:\n\t\treturn regmap_write(dev->regmap, TIM_CCR4, value);\n\t}\n\treturn -EINVAL;\n}\n\n#define TIM_CCER_CC12P (TIM_CCER_CC1P | TIM_CCER_CC2P)\n#define TIM_CCER_CC12E (TIM_CCER_CC1E | TIM_CCER_CC2E)\n#define TIM_CCER_CC34P (TIM_CCER_CC3P | TIM_CCER_CC4P)\n#define TIM_CCER_CC34E (TIM_CCER_CC3E | TIM_CCER_CC4E)\n\n \nstatic int stm32_pwm_raw_capture(struct stm32_pwm *priv, struct pwm_device *pwm,\n\t\t\t\t unsigned long tmo_ms, u32 *raw_prd,\n\t\t\t\t u32 *raw_dty)\n{\n\tstruct device *parent = priv->chip.dev->parent;\n\tenum stm32_timers_dmas dma_id;\n\tu32 ccen, ccr;\n\tint ret;\n\n\t \n\tregmap_set_bits(priv->regmap, TIM_EGR, TIM_EGR_UG);\n\tregmap_set_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN);\n\n\t \n\tdma_id = pwm->hwpwm < 2 ? STM32_TIMERS_DMA_CH1 : STM32_TIMERS_DMA_CH3;\n\tccen = pwm->hwpwm < 2 ? TIM_CCER_CC12E : TIM_CCER_CC34E;\n\tccr = pwm->hwpwm < 2 ? TIM_CCR1 : TIM_CCR3;\n\tregmap_set_bits(priv->regmap, TIM_CCER, ccen);\n\n\t \n\tret = stm32_timers_dma_burst_read(parent, priv->capture, dma_id, ccr, 2,\n\t\t\t\t\t  2, tmo_ms);\n\tif (ret)\n\t\tgoto stop;\n\n\t \n\tif (priv->capture[0] <= priv->capture[2])\n\t\t*raw_prd = priv->capture[2] - priv->capture[0];\n\telse\n\t\t*raw_prd = priv->max_arr - priv->capture[0] + priv->capture[2];\n\n\t \n\tif (pwm->chip->npwm < 2)\n\t\t*raw_dty = 0;\n\telse if (priv->capture[0] <= priv->capture[3])\n\t\t*raw_dty = priv->capture[3] - priv->capture[0];\n\telse\n\t\t*raw_dty = priv->max_arr - priv->capture[0] + priv->capture[3];\n\n\tif (*raw_dty > *raw_prd) {\n\t\t \n\t\t*raw_dty -= *raw_prd;\n\t}\n\nstop:\n\tregmap_clear_bits(priv->regmap, TIM_CCER, ccen);\n\tregmap_clear_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN);\n\n\treturn ret;\n}\n\nstatic int stm32_pwm_capture(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     struct pwm_capture *result, unsigned long tmo_ms)\n{\n\tstruct stm32_pwm *priv = to_stm32_pwm_dev(chip);\n\tunsigned long long prd, div, dty;\n\tunsigned long rate;\n\tunsigned int psc = 0, icpsc, scale;\n\tu32 raw_prd = 0, raw_dty = 0;\n\tint ret = 0;\n\n\tmutex_lock(&priv->lock);\n\n\tif (active_channels(priv)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tret = clk_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(priv->chip.dev, \"failed to enable counter clock\\n\");\n\t\tgoto unlock;\n\t}\n\n\trate = clk_get_rate(priv->clk);\n\tif (!rate) {\n\t\tret = -EINVAL;\n\t\tgoto clk_dis;\n\t}\n\n\t \n\tdiv = (unsigned long long)rate * (unsigned long long)tmo_ms;\n\tdo_div(div, MSEC_PER_SEC);\n\tprd = div;\n\twhile ((div > priv->max_arr) && (psc < MAX_TIM_PSC)) {\n\t\tpsc++;\n\t\tdiv = prd;\n\t\tdo_div(div, psc + 1);\n\t}\n\tregmap_write(priv->regmap, TIM_ARR, priv->max_arr);\n\tregmap_write(priv->regmap, TIM_PSC, psc);\n\n\t \n\tregmap_write(priv->regmap, TIM_TISEL, 0x0);\n\tregmap_write(priv->regmap, TIM_SMCR, 0x0);\n\n\t \n\tregmap_update_bits(priv->regmap,\n\t\t\t   pwm->hwpwm < 2 ? TIM_CCMR1 : TIM_CCMR2,\n\t\t\t   TIM_CCMR_CC1S | TIM_CCMR_CC2S, pwm->hwpwm & 0x1 ?\n\t\t\t   TIM_CCMR_CC1S_TI2 | TIM_CCMR_CC2S_TI2 :\n\t\t\t   TIM_CCMR_CC1S_TI1 | TIM_CCMR_CC2S_TI1);\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_CCER, pwm->hwpwm < 2 ?\n\t\t\t   TIM_CCER_CC12P : TIM_CCER_CC34P, pwm->hwpwm < 2 ?\n\t\t\t   TIM_CCER_CC2P : TIM_CCER_CC4P);\n\n\tret = stm32_pwm_raw_capture(priv, pwm, tmo_ms, &raw_prd, &raw_dty);\n\tif (ret)\n\t\tgoto stop;\n\n\t \n\tif (raw_prd) {\n\t\tu32 max_arr = priv->max_arr - 0x1000;  \n\n\t\tscale = max_arr / min(max_arr, raw_prd);\n\t} else {\n\t\tscale = priv->max_arr;  \n\t}\n\n\tif (psc && scale > 1) {\n\t\t \n\t\tpsc /= scale;\n\t\tregmap_write(priv->regmap, TIM_PSC, psc);\n\t\tret = stm32_pwm_raw_capture(priv, pwm, tmo_ms, &raw_prd,\n\t\t\t\t\t    &raw_dty);\n\t\tif (ret)\n\t\t\tgoto stop;\n\t}\n\n\t \n\tprd = (unsigned long long)raw_prd * (psc + 1) * NSEC_PER_SEC;\n\tdo_div(prd, rate);\n\n\tfor (icpsc = 0; icpsc < MAX_TIM_ICPSC ; icpsc++) {\n\t\t \n\t\tif (raw_prd >= (priv->max_arr - 0x1000) >> (icpsc + 1))\n\t\t\tbreak;\n\t\tif (prd >= (tmo_ms * NSEC_PER_MSEC) >> (icpsc + 2))\n\t\t\tbreak;\n\t}\n\n\tif (!icpsc)\n\t\tgoto done;\n\n\t \n\tregmap_update_bits(priv->regmap,\n\t\t\t   pwm->hwpwm < 2 ? TIM_CCMR1 : TIM_CCMR2,\n\t\t\t   TIM_CCMR_IC1PSC | TIM_CCMR_IC2PSC,\n\t\t\t   FIELD_PREP(TIM_CCMR_IC1PSC, icpsc) |\n\t\t\t   FIELD_PREP(TIM_CCMR_IC2PSC, icpsc));\n\n\tret = stm32_pwm_raw_capture(priv, pwm, tmo_ms, &raw_prd, &raw_dty);\n\tif (ret)\n\t\tgoto stop;\n\n\tif (raw_dty >= (raw_prd >> icpsc)) {\n\t\t \n\t\traw_dty = (raw_prd >> icpsc) - (raw_prd - raw_dty);\n\t}\n\ndone:\n\tprd = (unsigned long long)raw_prd * (psc + 1) * NSEC_PER_SEC;\n\tresult->period = DIV_ROUND_UP_ULL(prd, rate << icpsc);\n\tdty = (unsigned long long)raw_dty * (psc + 1) * NSEC_PER_SEC;\n\tresult->duty_cycle = DIV_ROUND_UP_ULL(dty, rate);\nstop:\n\tregmap_write(priv->regmap, TIM_CCER, 0);\n\tregmap_write(priv->regmap, pwm->hwpwm < 2 ? TIM_CCMR1 : TIM_CCMR2, 0);\n\tregmap_write(priv->regmap, TIM_PSC, 0);\nclk_dis:\n\tclk_disable(priv->clk);\nunlock:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int stm32_pwm_config(struct stm32_pwm *priv, int ch,\n\t\t\t    int duty_ns, int period_ns)\n{\n\tunsigned long long prd, div, dty;\n\tunsigned int prescaler = 0;\n\tu32 ccmr, mask, shift;\n\n\t \n\tdiv = (unsigned long long)clk_get_rate(priv->clk) * period_ns;\n\n\tdo_div(div, NSEC_PER_SEC);\n\tprd = div;\n\n\twhile (div > priv->max_arr) {\n\t\tprescaler++;\n\t\tdiv = prd;\n\t\tdo_div(div, prescaler + 1);\n\t}\n\n\tprd = div;\n\n\tif (prescaler > MAX_TIM_PSC)\n\t\treturn -EINVAL;\n\n\t \n\tif (active_channels(priv) & ~(1 << ch * 4)) {\n\t\tu32 psc, arr;\n\n\t\tregmap_read(priv->regmap, TIM_PSC, &psc);\n\t\tregmap_read(priv->regmap, TIM_ARR, &arr);\n\n\t\tif ((psc != prescaler) || (arr != prd - 1))\n\t\t\treturn -EBUSY;\n\t}\n\n\tregmap_write(priv->regmap, TIM_PSC, prescaler);\n\tregmap_write(priv->regmap, TIM_ARR, prd - 1);\n\tregmap_set_bits(priv->regmap, TIM_CR1, TIM_CR1_ARPE);\n\n\t \n\tdty = prd * duty_ns;\n\tdo_div(dty, period_ns);\n\n\twrite_ccrx(priv, ch, dty);\n\n\t \n\tshift = (ch & 0x1) * CCMR_CHANNEL_SHIFT;\n\tccmr = (TIM_CCMR_PE | TIM_CCMR_M1) << shift;\n\tmask = CCMR_CHANNEL_MASK << shift;\n\n\tif (ch < 2)\n\t\tregmap_update_bits(priv->regmap, TIM_CCMR1, mask, ccmr);\n\telse\n\t\tregmap_update_bits(priv->regmap, TIM_CCMR2, mask, ccmr);\n\n\tregmap_set_bits(priv->regmap, TIM_BDTR, TIM_BDTR_MOE);\n\n\treturn 0;\n}\n\nstatic int stm32_pwm_set_polarity(struct stm32_pwm *priv, int ch,\n\t\t\t\t  enum pwm_polarity polarity)\n{\n\tu32 mask;\n\n\tmask = TIM_CCER_CC1P << (ch * 4);\n\tif (priv->have_complementary_output)\n\t\tmask |= TIM_CCER_CC1NP << (ch * 4);\n\n\tregmap_update_bits(priv->regmap, TIM_CCER, mask,\n\t\t\t   polarity == PWM_POLARITY_NORMAL ? 0 : mask);\n\n\treturn 0;\n}\n\nstatic int stm32_pwm_enable(struct stm32_pwm *priv, int ch)\n{\n\tu32 mask;\n\tint ret;\n\n\tret = clk_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmask = TIM_CCER_CC1E << (ch * 4);\n\tif (priv->have_complementary_output)\n\t\tmask |= TIM_CCER_CC1NE << (ch * 4);\n\n\tregmap_set_bits(priv->regmap, TIM_CCER, mask);\n\n\t \n\tregmap_set_bits(priv->regmap, TIM_EGR, TIM_EGR_UG);\n\n\t \n\tregmap_set_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN);\n\n\treturn 0;\n}\n\nstatic void stm32_pwm_disable(struct stm32_pwm *priv, int ch)\n{\n\tu32 mask;\n\n\t \n\tmask = TIM_CCER_CC1E << (ch * 4);\n\tif (priv->have_complementary_output)\n\t\tmask |= TIM_CCER_CC1NE << (ch * 4);\n\n\tregmap_clear_bits(priv->regmap, TIM_CCER, mask);\n\n\t \n\tif (!active_channels(priv))\n\t\tregmap_clear_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN);\n\n\tclk_disable(priv->clk);\n}\n\nstatic int stm32_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tbool enabled;\n\tstruct stm32_pwm *priv = to_stm32_pwm_dev(chip);\n\tint ret;\n\n\tenabled = pwm->state.enabled;\n\n\tif (enabled && !state->enabled) {\n\t\tstm32_pwm_disable(priv, pwm->hwpwm);\n\t\treturn 0;\n\t}\n\n\tif (state->polarity != pwm->state.polarity)\n\t\tstm32_pwm_set_polarity(priv, pwm->hwpwm, state->polarity);\n\n\tret = stm32_pwm_config(priv, pwm->hwpwm,\n\t\t\t       state->duty_cycle, state->period);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!enabled && state->enabled)\n\t\tret = stm32_pwm_enable(priv, pwm->hwpwm);\n\n\treturn ret;\n}\n\nstatic int stm32_pwm_apply_locked(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t  const struct pwm_state *state)\n{\n\tstruct stm32_pwm *priv = to_stm32_pwm_dev(chip);\n\tint ret;\n\n\t \n\tmutex_lock(&priv->lock);\n\tret = stm32_pwm_apply(chip, pwm, state);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic const struct pwm_ops stm32pwm_ops = {\n\t.owner = THIS_MODULE,\n\t.apply = stm32_pwm_apply_locked,\n\t.capture = IS_ENABLED(CONFIG_DMA_ENGINE) ? stm32_pwm_capture : NULL,\n};\n\nstatic int stm32_pwm_set_breakinput(struct stm32_pwm *priv,\n\t\t\t\t    const struct stm32_breakinput *bi)\n{\n\tu32 shift = TIM_BDTR_BKF_SHIFT(bi->index);\n\tu32 bke = TIM_BDTR_BKE(bi->index);\n\tu32 bkp = TIM_BDTR_BKP(bi->index);\n\tu32 bkf = TIM_BDTR_BKF(bi->index);\n\tu32 mask = bkf | bkp | bke;\n\tu32 bdtr;\n\n\tbdtr = (bi->filter & TIM_BDTR_BKF_MASK) << shift | bke;\n\n\tif (bi->level)\n\t\tbdtr |= bkp;\n\n\tregmap_update_bits(priv->regmap, TIM_BDTR, mask, bdtr);\n\n\tregmap_read(priv->regmap, TIM_BDTR, &bdtr);\n\n\treturn (bdtr & bke) ? 0 : -EINVAL;\n}\n\nstatic int stm32_pwm_apply_breakinputs(struct stm32_pwm *priv)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < priv->num_breakinputs; i++) {\n\t\tret = stm32_pwm_set_breakinput(priv, &priv->breakinputs[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_pwm_probe_breakinputs(struct stm32_pwm *priv,\n\t\t\t\t       struct device_node *np)\n{\n\tint nb, ret, array_size;\n\tunsigned int i;\n\n\tnb = of_property_count_elems_of_size(np, \"st,breakinput\",\n\t\t\t\t\t     sizeof(struct stm32_breakinput));\n\n\t \n\tif (nb <= 0)\n\t\treturn 0;\n\n\tif (nb > MAX_BREAKINPUT)\n\t\treturn -EINVAL;\n\n\tpriv->num_breakinputs = nb;\n\tarray_size = nb * sizeof(struct stm32_breakinput) / sizeof(u32);\n\tret = of_property_read_u32_array(np, \"st,breakinput\",\n\t\t\t\t\t (u32 *)priv->breakinputs, array_size);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < priv->num_breakinputs; i++) {\n\t\tif (priv->breakinputs[i].index > 1 ||\n\t\t    priv->breakinputs[i].level > 1 ||\n\t\t    priv->breakinputs[i].filter > 15)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn stm32_pwm_apply_breakinputs(priv);\n}\n\nstatic void stm32_pwm_detect_complementary(struct stm32_pwm *priv)\n{\n\tu32 ccer;\n\n\t \n\tregmap_set_bits(priv->regmap, TIM_CCER, TIM_CCER_CC1NE);\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tregmap_clear_bits(priv->regmap, TIM_CCER, TIM_CCER_CC1NE);\n\n\tpriv->have_complementary_output = (ccer != 0);\n}\n\nstatic unsigned int stm32_pwm_detect_channels(struct stm32_pwm *priv,\n\t\t\t\t\t      unsigned int *num_enabled)\n{\n\tu32 ccer, ccer_backup;\n\n\t \n\tregmap_read(priv->regmap, TIM_CCER, &ccer_backup);\n\tregmap_set_bits(priv->regmap, TIM_CCER, TIM_CCER_CCXE);\n\tregmap_read(priv->regmap, TIM_CCER, &ccer);\n\tregmap_write(priv->regmap, TIM_CCER, ccer_backup);\n\n\t*num_enabled = hweight32(ccer_backup & TIM_CCER_CCXE);\n\n\treturn hweight32(ccer & TIM_CCER_CCXE);\n}\n\nstatic int stm32_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct stm32_timers *ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct stm32_pwm *priv;\n\tunsigned int num_enabled;\n\tunsigned int i;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->lock);\n\tpriv->regmap = ddata->regmap;\n\tpriv->clk = ddata->clk;\n\tpriv->max_arr = ddata->max_arr;\n\n\tif (!priv->regmap || !priv->clk)\n\t\treturn -EINVAL;\n\n\tret = stm32_pwm_probe_breakinputs(priv, np);\n\tif (ret)\n\t\treturn ret;\n\n\tstm32_pwm_detect_complementary(priv);\n\n\tpriv->chip.dev = dev;\n\tpriv->chip.ops = &stm32pwm_ops;\n\tpriv->chip.npwm = stm32_pwm_detect_channels(priv, &num_enabled);\n\n\t \n\tfor (i = 0; i < num_enabled; i++)\n\t\tclk_enable(priv->clk);\n\n\tret = devm_pwmchip_add(dev, &priv->chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_pwm_suspend(struct device *dev)\n{\n\tstruct stm32_pwm *priv = dev_get_drvdata(dev);\n\tunsigned int i;\n\tu32 ccer, mask;\n\n\t \n\tccer = active_channels(priv);\n\n\tfor (i = 0; i < priv->chip.npwm; i++) {\n\t\tmask = TIM_CCER_CC1E << (i * 4);\n\t\tif (ccer & mask) {\n\t\t\tdev_err(dev, \"PWM %u still in use by consumer %s\\n\",\n\t\t\t\ti, priv->chip.pwms[i].label);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int __maybe_unused stm32_pwm_resume(struct device *dev)\n{\n\tstruct stm32_pwm *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn stm32_pwm_apply_breakinputs(priv);\n}\n\nstatic SIMPLE_DEV_PM_OPS(stm32_pwm_pm_ops, stm32_pwm_suspend, stm32_pwm_resume);\n\nstatic const struct of_device_id stm32_pwm_of_match[] = {\n\t{ .compatible = \"st,stm32-pwm\",\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, stm32_pwm_of_match);\n\nstatic struct platform_driver stm32_pwm_driver = {\n\t.probe\t= stm32_pwm_probe,\n\t.driver\t= {\n\t\t.name = \"stm32-pwm\",\n\t\t.of_match_table = stm32_pwm_of_match,\n\t\t.pm = &stm32_pwm_pm_ops,\n\t},\n};\nmodule_platform_driver(stm32_pwm_driver);\n\nMODULE_ALIAS(\"platform:stm32-pwm\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}