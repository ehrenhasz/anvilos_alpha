{
  "module_name": "pwm-bcm2835.c",
  "hash_id": "c7adae2557b47f42ccfa5790fbc8b20e3f164ef35ff6089878affa612fc90e02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-bcm2835.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n#define PWM_CONTROL\t\t0x000\n#define PWM_CONTROL_SHIFT(x)\t((x) * 8)\n#define PWM_CONTROL_MASK\t0xff\n#define PWM_MODE\t\t0x80\t\t \n#define PWM_ENABLE\t\t(1 << 0)\n#define PWM_POLARITY\t\t(1 << 4)\n\n#define PERIOD(x)\t\t(((x) * 0x10) + 0x10)\n#define DUTY(x)\t\t\t(((x) * 0x10) + 0x14)\n\n#define PERIOD_MIN\t\t0x2\n\nstruct bcm2835_pwm {\n\tstruct pwm_chip chip;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic inline struct bcm2835_pwm *to_bcm2835_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct bcm2835_pwm, chip);\n}\n\nstatic int bcm2835_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct bcm2835_pwm *pc = to_bcm2835_pwm(chip);\n\tu32 value;\n\n\tvalue = readl(pc->base + PWM_CONTROL);\n\tvalue &= ~(PWM_CONTROL_MASK << PWM_CONTROL_SHIFT(pwm->hwpwm));\n\tvalue |= (PWM_MODE << PWM_CONTROL_SHIFT(pwm->hwpwm));\n\twritel(value, pc->base + PWM_CONTROL);\n\n\treturn 0;\n}\n\nstatic void bcm2835_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct bcm2835_pwm *pc = to_bcm2835_pwm(chip);\n\tu32 value;\n\n\tvalue = readl(pc->base + PWM_CONTROL);\n\tvalue &= ~(PWM_CONTROL_MASK << PWM_CONTROL_SHIFT(pwm->hwpwm));\n\twritel(value, pc->base + PWM_CONTROL);\n}\n\nstatic int bcm2835_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\n\tstruct bcm2835_pwm *pc = to_bcm2835_pwm(chip);\n\tunsigned long rate = clk_get_rate(pc->clk);\n\tunsigned long long period_cycles;\n\tu64 max_period;\n\n\tu32 val;\n\n\tif (!rate) {\n\t\tdev_err(pc->dev, \"failed to get clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmax_period = DIV_ROUND_UP_ULL((u64)U32_MAX * NSEC_PER_SEC + NSEC_PER_SEC / 2, rate) - 1;\n\n\tif (state->period > max_period)\n\t\treturn -EINVAL;\n\n\t \n\tperiod_cycles = DIV_ROUND_CLOSEST_ULL(state->period * rate, NSEC_PER_SEC);\n\n\t \n\tif (period_cycles < PERIOD_MIN)\n\t\treturn -EINVAL;\n\n\twritel(period_cycles, pc->base + PERIOD(pwm->hwpwm));\n\n\t \n\tval = DIV_ROUND_CLOSEST_ULL(state->duty_cycle * rate, NSEC_PER_SEC);\n\twritel(val, pc->base + DUTY(pwm->hwpwm));\n\n\t \n\tval = readl(pc->base + PWM_CONTROL);\n\n\tif (state->polarity == PWM_POLARITY_NORMAL)\n\t\tval &= ~(PWM_POLARITY << PWM_CONTROL_SHIFT(pwm->hwpwm));\n\telse\n\t\tval |= PWM_POLARITY << PWM_CONTROL_SHIFT(pwm->hwpwm);\n\n\t \n\tif (state->enabled)\n\t\tval |= PWM_ENABLE << PWM_CONTROL_SHIFT(pwm->hwpwm);\n\telse\n\t\tval &= ~(PWM_ENABLE << PWM_CONTROL_SHIFT(pwm->hwpwm));\n\n\twritel(val, pc->base + PWM_CONTROL);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops bcm2835_pwm_ops = {\n\t.request = bcm2835_pwm_request,\n\t.free = bcm2835_pwm_free,\n\t.apply = bcm2835_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int bcm2835_pwm_probe(struct platform_device *pdev)\n{\n\tstruct bcm2835_pwm *pc;\n\tint ret;\n\n\tpc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tpc->dev = &pdev->dev;\n\n\tpc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->base))\n\t\treturn PTR_ERR(pc->base);\n\n\tpc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pc->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(pc->clk),\n\t\t\t\t     \"clock not found\\n\");\n\n\tret = clk_prepare_enable(pc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tpc->chip.dev = &pdev->dev;\n\tpc->chip.ops = &bcm2835_pwm_ops;\n\tpc->chip.npwm = 2;\n\n\tplatform_set_drvdata(pdev, pc);\n\n\tret = pwmchip_add(&pc->chip);\n\tif (ret < 0)\n\t\tgoto add_fail;\n\n\treturn 0;\n\nadd_fail:\n\tclk_disable_unprepare(pc->clk);\n\treturn ret;\n}\n\nstatic void bcm2835_pwm_remove(struct platform_device *pdev)\n{\n\tstruct bcm2835_pwm *pc = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&pc->chip);\n\n\tclk_disable_unprepare(pc->clk);\n}\n\nstatic const struct of_device_id bcm2835_pwm_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, bcm2835_pwm_of_match);\n\nstatic struct platform_driver bcm2835_pwm_driver = {\n\t.driver = {\n\t\t.name = \"bcm2835-pwm\",\n\t\t.of_match_table = bcm2835_pwm_of_match,\n\t},\n\t.probe = bcm2835_pwm_probe,\n\t.remove_new = bcm2835_pwm_remove,\n};\nmodule_platform_driver(bcm2835_pwm_driver);\n\nMODULE_AUTHOR(\"Bart Tanghe <bart.tanghe@thomasmore.be>\");\nMODULE_DESCRIPTION(\"Broadcom BCM2835 PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}