{
  "module_name": "pwm-sifive.c",
  "hash_id": "b4d4829896a0f0636fd4a82c572a57c717a58418409938f8ee39f0909e42f2af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-sifive.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n#include <linux/bitfield.h>\n\n \n#define PWM_SIFIVE_PWMCFG\t\t0x0\n#define PWM_SIFIVE_PWMCOUNT\t\t0x8\n#define PWM_SIFIVE_PWMS\t\t\t0x10\n#define PWM_SIFIVE_PWMCMP(i)\t\t(0x20 + 4 * (i))\n\n \n#define PWM_SIFIVE_PWMCFG_SCALE\t\tGENMASK(3, 0)\n#define PWM_SIFIVE_PWMCFG_STICKY\tBIT(8)\n#define PWM_SIFIVE_PWMCFG_ZERO_CMP\tBIT(9)\n#define PWM_SIFIVE_PWMCFG_DEGLITCH\tBIT(10)\n#define PWM_SIFIVE_PWMCFG_EN_ALWAYS\tBIT(12)\n#define PWM_SIFIVE_PWMCFG_EN_ONCE\tBIT(13)\n#define PWM_SIFIVE_PWMCFG_CENTER\tBIT(16)\n#define PWM_SIFIVE_PWMCFG_GANG\t\tBIT(24)\n#define PWM_SIFIVE_PWMCFG_IP\t\tBIT(28)\n\n#define PWM_SIFIVE_CMPWIDTH\t\t16\n#define PWM_SIFIVE_DEFAULT_PERIOD\t10000000\n\nstruct pwm_sifive_ddata {\n\tstruct pwm_chip\tchip;\n\tstruct mutex lock;  \n\tstruct notifier_block notifier;\n\tstruct clk *clk;\n\tvoid __iomem *regs;\n\tunsigned int real_period;\n\tunsigned int approx_period;\n\tint user_count;\n};\n\nstatic inline\nstruct pwm_sifive_ddata *pwm_sifive_chip_to_ddata(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct pwm_sifive_ddata, chip);\n}\n\nstatic int pwm_sifive_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct pwm_sifive_ddata *ddata = pwm_sifive_chip_to_ddata(chip);\n\n\tmutex_lock(&ddata->lock);\n\tddata->user_count++;\n\tmutex_unlock(&ddata->lock);\n\n\treturn 0;\n}\n\nstatic void pwm_sifive_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct pwm_sifive_ddata *ddata = pwm_sifive_chip_to_ddata(chip);\n\n\tmutex_lock(&ddata->lock);\n\tddata->user_count--;\n\tmutex_unlock(&ddata->lock);\n}\n\n \nstatic void pwm_sifive_update_clock(struct pwm_sifive_ddata *ddata,\n\t\t\t\t    unsigned long rate)\n{\n\tunsigned long long num;\n\tunsigned long scale_pow;\n\tint scale;\n\tu32 val;\n\t \n\tscale_pow = div64_ul(ddata->approx_period * (u64)rate, NSEC_PER_SEC);\n\tscale = clamp(ilog2(scale_pow) - PWM_SIFIVE_CMPWIDTH, 0, 0xf);\n\n\tval = PWM_SIFIVE_PWMCFG_EN_ALWAYS |\n\t      FIELD_PREP(PWM_SIFIVE_PWMCFG_SCALE, scale);\n\twritel(val, ddata->regs + PWM_SIFIVE_PWMCFG);\n\n\t \n\tnum = (unsigned long long)NSEC_PER_SEC << (PWM_SIFIVE_CMPWIDTH + scale);\n\tddata->real_period = div64_ul(num, rate);\n\tdev_dbg(ddata->chip.dev,\n\t\t\"New real_period = %u ns\\n\", ddata->real_period);\n}\n\nstatic int pwm_sifive_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\tstruct pwm_state *state)\n{\n\tstruct pwm_sifive_ddata *ddata = pwm_sifive_chip_to_ddata(chip);\n\tu32 duty, val;\n\n\tduty = readl(ddata->regs + PWM_SIFIVE_PWMCMP(pwm->hwpwm));\n\n\tstate->enabled = duty > 0;\n\n\tval = readl(ddata->regs + PWM_SIFIVE_PWMCFG);\n\tif (!(val & PWM_SIFIVE_PWMCFG_EN_ALWAYS))\n\t\tstate->enabled = false;\n\n\tstate->period = ddata->real_period;\n\tstate->duty_cycle =\n\t\t(u64)duty * ddata->real_period >> PWM_SIFIVE_CMPWIDTH;\n\tstate->polarity = PWM_POLARITY_INVERSED;\n\n\treturn 0;\n}\n\nstatic int pwm_sifive_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tstruct pwm_sifive_ddata *ddata = pwm_sifive_chip_to_ddata(chip);\n\tstruct pwm_state cur_state;\n\tunsigned int duty_cycle;\n\tunsigned long long num;\n\tbool enabled;\n\tint ret = 0;\n\tu32 frac;\n\n\tif (state->polarity != PWM_POLARITY_INVERSED)\n\t\treturn -EINVAL;\n\n\tcur_state = pwm->state;\n\tenabled = cur_state.enabled;\n\n\tduty_cycle = state->duty_cycle;\n\tif (!state->enabled)\n\t\tduty_cycle = 0;\n\n\t \n\tnum = (u64)duty_cycle * (1U << PWM_SIFIVE_CMPWIDTH);\n\tfrac = DIV64_U64_ROUND_CLOSEST(num, state->period);\n\t \n\tfrac = min(frac, (1U << PWM_SIFIVE_CMPWIDTH) - 1);\n\n\tmutex_lock(&ddata->lock);\n\tif (state->period != ddata->approx_period) {\n\t\t \n\t\tif (ddata->user_count != 1 && ddata->approx_period) {\n\t\t\tmutex_unlock(&ddata->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tddata->approx_period = state->period;\n\t\tpwm_sifive_update_clock(ddata, clk_get_rate(ddata->clk));\n\t}\n\tmutex_unlock(&ddata->lock);\n\n\t \n\tif (!enabled) {\n\t\tret = clk_enable(ddata->clk);\n\t\tif (ret) {\n\t\t\tdev_err(ddata->chip.dev, \"Enable clk failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\twritel(frac, ddata->regs + PWM_SIFIVE_PWMCMP(pwm->hwpwm));\n\n\tif (!state->enabled)\n\t\tclk_disable(ddata->clk);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops pwm_sifive_ops = {\n\t.request = pwm_sifive_request,\n\t.free = pwm_sifive_free,\n\t.get_state = pwm_sifive_get_state,\n\t.apply = pwm_sifive_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pwm_sifive_clock_notifier(struct notifier_block *nb,\n\t\t\t\t     unsigned long event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct pwm_sifive_ddata *ddata =\n\t\tcontainer_of(nb, struct pwm_sifive_ddata, notifier);\n\n\tif (event == POST_RATE_CHANGE) {\n\t\tmutex_lock(&ddata->lock);\n\t\tpwm_sifive_update_clock(ddata, ndata->new_rate);\n\t\tmutex_unlock(&ddata->lock);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int pwm_sifive_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pwm_sifive_ddata *ddata;\n\tstruct pwm_chip *chip;\n\tint ret;\n\tu32 val;\n\tunsigned int enabled_pwms = 0, enabled_clks = 1;\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ddata->lock);\n\tchip = &ddata->chip;\n\tchip->dev = dev;\n\tchip->ops = &pwm_sifive_ops;\n\tchip->npwm = 4;\n\n\tddata->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ddata->regs))\n\t\treturn PTR_ERR(ddata->regs);\n\n\tddata->clk = devm_clk_get_prepared(dev, NULL);\n\tif (IS_ERR(ddata->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(ddata->clk),\n\t\t\t\t     \"Unable to find controller clock\\n\");\n\n\tret = clk_enable(ddata->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clock for pwm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval = readl(ddata->regs + PWM_SIFIVE_PWMCFG);\n\tif (val & PWM_SIFIVE_PWMCFG_EN_ALWAYS) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < chip->npwm; ++i) {\n\t\t\tval = readl(ddata->regs + PWM_SIFIVE_PWMCMP(i));\n\t\t\tif (val > 0)\n\t\t\t\t++enabled_pwms;\n\t\t}\n\t}\n\n\t \n\tif (enabled_pwms) {\n\t\twhile (enabled_clks < enabled_pwms) {\n\t\t\t \n\t\t\tret = clk_enable(ddata->clk);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tdev_err_probe(dev, ret, \"Failed to enable clk\\n\");\n\t\t\t\tgoto disable_clk;\n\t\t\t}\n\t\t\t++enabled_clks;\n\t\t}\n\t} else {\n\t\tclk_disable(ddata->clk);\n\t\tenabled_clks = 0;\n\t}\n\n\t \n\tddata->notifier.notifier_call = pwm_sifive_clock_notifier;\n\tret = clk_notifier_register(ddata->clk, &ddata->notifier);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register clock notifier: %d\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\n\tret = pwmchip_add(chip);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot register PWM: %d\\n\", ret);\n\t\tgoto unregister_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, ddata);\n\tdev_dbg(dev, \"SiFive PWM chip registered %d PWMs\\n\", chip->npwm);\n\n\treturn 0;\n\nunregister_clk:\n\tclk_notifier_unregister(ddata->clk, &ddata->notifier);\ndisable_clk:\n\twhile (enabled_clks) {\n\t\tclk_disable(ddata->clk);\n\t\t--enabled_clks;\n\t}\n\n\treturn ret;\n}\n\nstatic void pwm_sifive_remove(struct platform_device *dev)\n{\n\tstruct pwm_sifive_ddata *ddata = platform_get_drvdata(dev);\n\tstruct pwm_device *pwm;\n\tint ch;\n\n\tpwmchip_remove(&ddata->chip);\n\tclk_notifier_unregister(ddata->clk, &ddata->notifier);\n\n\tfor (ch = 0; ch < ddata->chip.npwm; ch++) {\n\t\tpwm = &ddata->chip.pwms[ch];\n\t\tif (pwm->state.enabled)\n\t\t\tclk_disable(ddata->clk);\n\t}\n}\n\nstatic const struct of_device_id pwm_sifive_of_match[] = {\n\t{ .compatible = \"sifive,pwm0\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pwm_sifive_of_match);\n\nstatic struct platform_driver pwm_sifive_driver = {\n\t.probe = pwm_sifive_probe,\n\t.remove_new = pwm_sifive_remove,\n\t.driver = {\n\t\t.name = \"pwm-sifive\",\n\t\t.of_match_table = pwm_sifive_of_match,\n\t},\n};\nmodule_platform_driver(pwm_sifive_driver);\n\nMODULE_DESCRIPTION(\"SiFive PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}