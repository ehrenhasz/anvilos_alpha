{
  "module_name": "pwm-omap-dmtimer.c",
  "hash_id": "0a853264feaf1de3426f8bf3ac0fa245a27648f235eed3a8ff2c2c0847571d4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-omap-dmtimer.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <clocksource/timer-ti-dm.h>\n#include <linux/platform_data/dmtimer-omap.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define DM_TIMER_LOAD_MIN 0xfffffffe\n#define DM_TIMER_MAX      0xffffffff\n\n \nstruct pwm_omap_dmtimer_chip {\n\tstruct pwm_chip chip;\n\t \n\tstruct mutex mutex;\n\tstruct omap_dm_timer *dm_timer;\n\tconst struct omap_dm_timer_ops *pdata;\n\tstruct platform_device *dm_timer_pdev;\n};\n\nstatic inline struct pwm_omap_dmtimer_chip *\nto_pwm_omap_dmtimer_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct pwm_omap_dmtimer_chip, chip);\n}\n\n \nstatic u32 pwm_omap_dmtimer_get_clock_cycles(unsigned long clk_rate, int ns)\n{\n\treturn DIV_ROUND_CLOSEST_ULL((u64)clk_rate * ns, NSEC_PER_SEC);\n}\n\n \nstatic void pwm_omap_dmtimer_start(struct pwm_omap_dmtimer_chip *omap)\n{\n\t \n\tomap->pdata->enable(omap->dm_timer);\n\tomap->pdata->write_counter(omap->dm_timer, DM_TIMER_LOAD_MIN);\n\tomap->pdata->disable(omap->dm_timer);\n\n\tomap->pdata->start(omap->dm_timer);\n}\n\n \nstatic bool pwm_omap_dmtimer_is_enabled(struct pwm_omap_dmtimer_chip *omap)\n{\n\tu32 status;\n\n\tstatus = omap->pdata->get_pwm_status(omap->dm_timer);\n\n\treturn !!(status & OMAP_TIMER_CTRL_ST);\n}\n\n \nstatic int pwm_omap_dmtimer_polarity(struct pwm_omap_dmtimer_chip *omap)\n{\n\tu32 status;\n\n\tstatus = omap->pdata->get_pwm_status(omap->dm_timer);\n\n\treturn !!(status & OMAP_TIMER_CTRL_SCPWM);\n}\n\n \nstatic int pwm_omap_dmtimer_config(struct pwm_chip *chip,\n\t\t\t\t   struct pwm_device *pwm,\n\t\t\t\t   int duty_ns, int period_ns)\n{\n\tstruct pwm_omap_dmtimer_chip *omap = to_pwm_omap_dmtimer_chip(chip);\n\tu32 period_cycles, duty_cycles;\n\tu32 load_value, match_value;\n\tunsigned long clk_rate;\n\tstruct clk *fclk;\n\n\tdev_dbg(chip->dev, \"requested duty cycle: %d ns, period: %d ns\\n\",\n\t\tduty_ns, period_ns);\n\n\tif (duty_ns == pwm_get_duty_cycle(pwm) &&\n\t    period_ns == pwm_get_period(pwm))\n\t\treturn 0;\n\n\tfclk = omap->pdata->get_fclk(omap->dm_timer);\n\tif (!fclk) {\n\t\tdev_err(chip->dev, \"invalid pmtimer fclk\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclk_rate = clk_get_rate(fclk);\n\tif (!clk_rate) {\n\t\tdev_err(chip->dev, \"invalid pmtimer fclk rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(chip->dev, \"clk rate: %luHz\\n\", clk_rate);\n\n\t \n\tperiod_cycles = pwm_omap_dmtimer_get_clock_cycles(clk_rate, period_ns);\n\tduty_cycles = pwm_omap_dmtimer_get_clock_cycles(clk_rate, duty_ns);\n\n\tif (period_cycles < 2) {\n\t\tdev_info(chip->dev,\n\t\t\t \"period %d ns too short for clock rate %lu Hz\\n\",\n\t\t\t period_ns, clk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (duty_cycles < 1) {\n\t\tdev_dbg(chip->dev,\n\t\t\t\"duty cycle %d ns is too short for clock rate %lu Hz\\n\",\n\t\t\tduty_ns, clk_rate);\n\t\tdev_dbg(chip->dev, \"using minimum of 1 clock cycle\\n\");\n\t\tduty_cycles = 1;\n\t} else if (duty_cycles >= period_cycles) {\n\t\tdev_dbg(chip->dev,\n\t\t\t\"duty cycle %d ns is too long for period %d ns at clock rate %lu Hz\\n\",\n\t\t\tduty_ns, period_ns, clk_rate);\n\t\tdev_dbg(chip->dev, \"using maximum of 1 clock cycle less than period\\n\");\n\t\tduty_cycles = period_cycles - 1;\n\t}\n\n\tdev_dbg(chip->dev, \"effective duty cycle: %lld ns, period: %lld ns\\n\",\n\t\tDIV_ROUND_CLOSEST_ULL((u64)NSEC_PER_SEC * duty_cycles,\n\t\t\t\t      clk_rate),\n\t\tDIV_ROUND_CLOSEST_ULL((u64)NSEC_PER_SEC * period_cycles,\n\t\t\t\t      clk_rate));\n\n\tload_value = (DM_TIMER_MAX - period_cycles) + 1;\n\tmatch_value = load_value + duty_cycles - 1;\n\n\tomap->pdata->set_load(omap->dm_timer, load_value);\n\tomap->pdata->set_match(omap->dm_timer, true, match_value);\n\n\tdev_dbg(chip->dev, \"load value: %#08x (%d), match value: %#08x (%d)\\n\",\n\t\tload_value, load_value,\tmatch_value, match_value);\n\n\treturn 0;\n}\n\n \nstatic void pwm_omap_dmtimer_set_polarity(struct pwm_chip *chip,\n\t\t\t\t\t  struct pwm_device *pwm,\n\t\t\t\t\t  enum pwm_polarity polarity)\n{\n\tstruct pwm_omap_dmtimer_chip *omap = to_pwm_omap_dmtimer_chip(chip);\n\tbool enabled;\n\n\t \n\tenabled = pwm_omap_dmtimer_is_enabled(omap);\n\tif (enabled)\n\t\tomap->pdata->stop(omap->dm_timer);\n\n\tomap->pdata->set_pwm(omap->dm_timer,\n\t\t\t     polarity == PWM_POLARITY_INVERSED,\n\t\t\t     true, OMAP_TIMER_TRIGGER_OVERFLOW_AND_COMPARE,\n\t\t\t     true);\n\n\tif (enabled)\n\t\tpwm_omap_dmtimer_start(omap);\n}\n\n \nstatic int pwm_omap_dmtimer_apply(struct pwm_chip *chip,\n\t\t\t\t  struct pwm_device *pwm,\n\t\t\t\t  const struct pwm_state *state)\n{\n\tstruct pwm_omap_dmtimer_chip *omap = to_pwm_omap_dmtimer_chip(chip);\n\tint ret = 0;\n\n\tmutex_lock(&omap->mutex);\n\n\tif (pwm_omap_dmtimer_is_enabled(omap) && !state->enabled) {\n\t\tomap->pdata->stop(omap->dm_timer);\n\t\tgoto unlock_mutex;\n\t}\n\n\tif (pwm_omap_dmtimer_polarity(omap) != state->polarity)\n\t\tpwm_omap_dmtimer_set_polarity(chip, pwm, state->polarity);\n\n\tret = pwm_omap_dmtimer_config(chip, pwm, state->duty_cycle,\n\t\t\t\t      state->period);\n\tif (ret)\n\t\tgoto unlock_mutex;\n\n\tif (!pwm_omap_dmtimer_is_enabled(omap) && state->enabled) {\n\t\tomap->pdata->set_pwm(omap->dm_timer,\n\t\t\t\t     state->polarity == PWM_POLARITY_INVERSED,\n\t\t\t\t     true,\n\t\t\t\t     OMAP_TIMER_TRIGGER_OVERFLOW_AND_COMPARE,\n\t\t\t\t     true);\n\t\tpwm_omap_dmtimer_start(omap);\n\t}\n\nunlock_mutex:\n\tmutex_unlock(&omap->mutex);\n\n\treturn ret;\n}\n\nstatic const struct pwm_ops pwm_omap_dmtimer_ops = {\n\t.apply = pwm_omap_dmtimer_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pwm_omap_dmtimer_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct dmtimer_platform_data *timer_pdata;\n\tconst struct omap_dm_timer_ops *pdata;\n\tstruct platform_device *timer_pdev;\n\tstruct pwm_omap_dmtimer_chip *omap;\n\tstruct omap_dm_timer *dm_timer;\n\tstruct device_node *timer;\n\tint ret = 0;\n\tu32 v;\n\n\ttimer = of_parse_phandle(np, \"ti,timers\", 0);\n\tif (!timer)\n\t\treturn -ENODEV;\n\n\ttimer_pdev = of_find_device_by_node(timer);\n\tif (!timer_pdev) {\n\t\tdev_err(&pdev->dev, \"Unable to find Timer pdev\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_find_timer_pdev;\n\t}\n\n\ttimer_pdata = dev_get_platdata(&timer_pdev->dev);\n\tif (!timer_pdata) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t \"dmtimer pdata structure NULL, deferring probe\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_platdata;\n\t}\n\n\tpdata = timer_pdata->timer_ops;\n\n\tif (!pdata || !pdata->request_by_node ||\n\t    !pdata->free ||\n\t    !pdata->enable ||\n\t    !pdata->disable ||\n\t    !pdata->get_fclk ||\n\t    !pdata->start ||\n\t    !pdata->stop ||\n\t    !pdata->set_load ||\n\t    !pdata->set_match ||\n\t    !pdata->set_pwm ||\n\t    !pdata->get_pwm_status ||\n\t    !pdata->set_prescaler ||\n\t    !pdata->write_counter) {\n\t\tdev_err(&pdev->dev, \"Incomplete dmtimer pdata structure\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_platdata;\n\t}\n\n\tif (!of_get_property(timer, \"ti,timer-pwm\", NULL)) {\n\t\tdev_err(&pdev->dev, \"Missing ti,timer-pwm capability\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_timer_property;\n\t}\n\n\tdm_timer = pdata->request_by_node(timer);\n\tif (!dm_timer) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_request_timer;\n\t}\n\n\tomap = devm_kzalloc(&pdev->dev, sizeof(*omap), GFP_KERNEL);\n\tif (!omap) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_omap;\n\t}\n\n\tomap->pdata = pdata;\n\tomap->dm_timer = dm_timer;\n\tomap->dm_timer_pdev = timer_pdev;\n\n\t \n\tif (pm_runtime_active(&omap->dm_timer_pdev->dev))\n\t\tomap->pdata->stop(omap->dm_timer);\n\n\tif (!of_property_read_u32(pdev->dev.of_node, \"ti,prescaler\", &v))\n\t\tomap->pdata->set_prescaler(omap->dm_timer, v);\n\n\t \n\tif (!of_property_read_u32(pdev->dev.of_node, \"ti,clock-source\", &v))\n\t\tomap->pdata->set_source(omap->dm_timer, v);\n\n\tomap->chip.dev = &pdev->dev;\n\tomap->chip.ops = &pwm_omap_dmtimer_ops;\n\tomap->chip.npwm = 1;\n\n\tmutex_init(&omap->mutex);\n\n\tret = pwmchip_add(&omap->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register PWM\\n\");\n\t\tgoto err_pwmchip_add;\n\t}\n\n\tof_node_put(timer);\n\n\tplatform_set_drvdata(pdev, omap);\n\n\treturn 0;\n\nerr_pwmchip_add:\n\n\t \nerr_alloc_omap:\n\n\tpdata->free(dm_timer);\nerr_request_timer:\n\nerr_timer_property:\nerr_platdata:\n\n\tput_device(&timer_pdev->dev);\nerr_find_timer_pdev:\n\n\tof_node_put(timer);\n\n\treturn ret;\n}\n\nstatic void pwm_omap_dmtimer_remove(struct platform_device *pdev)\n{\n\tstruct pwm_omap_dmtimer_chip *omap = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&omap->chip);\n\n\tif (pm_runtime_active(&omap->dm_timer_pdev->dev))\n\t\tomap->pdata->stop(omap->dm_timer);\n\n\tomap->pdata->free(omap->dm_timer);\n\n\tput_device(&omap->dm_timer_pdev->dev);\n\n\tmutex_destroy(&omap->mutex);\n}\n\nstatic const struct of_device_id pwm_omap_dmtimer_of_match[] = {\n\t{.compatible = \"ti,omap-dmtimer-pwm\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pwm_omap_dmtimer_of_match);\n\nstatic struct platform_driver pwm_omap_dmtimer_driver = {\n\t.driver = {\n\t\t.name = \"omap-dmtimer-pwm\",\n\t\t.of_match_table = of_match_ptr(pwm_omap_dmtimer_of_match),\n\t},\n\t.probe = pwm_omap_dmtimer_probe,\n\t.remove_new = pwm_omap_dmtimer_remove,\n};\nmodule_platform_driver(pwm_omap_dmtimer_driver);\n\nMODULE_AUTHOR(\"Grant Erickson <marathon96@gmail.com>\");\nMODULE_AUTHOR(\"NeilBrown <neilb@suse.de>\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"OMAP PWM Driver using Dual-mode Timers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}