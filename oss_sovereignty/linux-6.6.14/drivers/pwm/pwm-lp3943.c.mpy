{
  "module_name": "pwm-lp3943.c",
  "hash_id": "e35b612743d9909f3b0331a533d913c8f0d3ae1aaedeb3bf670b6acf1b5de629",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-lp3943.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/mfd/lp3943.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n#define LP3943_MAX_DUTY\t\t\t255\n#define LP3943_MIN_PERIOD\t\t6250\n#define LP3943_MAX_PERIOD\t\t1600000\n\nstruct lp3943_pwm {\n\tstruct pwm_chip chip;\n\tstruct lp3943 *lp3943;\n\tstruct lp3943_platform_data *pdata;\n};\n\nstatic inline struct lp3943_pwm *to_lp3943_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct lp3943_pwm, chip);\n}\n\nstatic struct lp3943_pwm_map *\nlp3943_pwm_request_map(struct lp3943_pwm *lp3943_pwm, int hwpwm)\n{\n\tstruct lp3943_platform_data *pdata = lp3943_pwm->pdata;\n\tstruct lp3943 *lp3943 = lp3943_pwm->lp3943;\n\tstruct lp3943_pwm_map *pwm_map;\n\tint i, offset;\n\n\tpwm_map = kzalloc(sizeof(*pwm_map), GFP_KERNEL);\n\tif (!pwm_map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpwm_map->output = pdata->pwms[hwpwm]->output;\n\tpwm_map->num_outputs = pdata->pwms[hwpwm]->num_outputs;\n\n\tfor (i = 0; i < pwm_map->num_outputs; i++) {\n\t\toffset = pwm_map->output[i];\n\n\t\t \n\t\tif (test_and_set_bit(offset, &lp3943->pin_used)) {\n\t\t\tkfree(pwm_map);\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\t}\n\t}\n\n\treturn pwm_map;\n}\n\nstatic int lp3943_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct lp3943_pwm *lp3943_pwm = to_lp3943_pwm(chip);\n\tstruct lp3943_pwm_map *pwm_map;\n\n\tpwm_map = lp3943_pwm_request_map(lp3943_pwm, pwm->hwpwm);\n\tif (IS_ERR(pwm_map))\n\t\treturn PTR_ERR(pwm_map);\n\n\treturn pwm_set_chip_data(pwm, pwm_map);\n}\n\nstatic void lp3943_pwm_free_map(struct lp3943_pwm *lp3943_pwm,\n\t\t\t\tstruct lp3943_pwm_map *pwm_map)\n{\n\tstruct lp3943 *lp3943 = lp3943_pwm->lp3943;\n\tint i, offset;\n\n\tfor (i = 0; i < pwm_map->num_outputs; i++) {\n\t\toffset = pwm_map->output[i];\n\t\tclear_bit(offset, &lp3943->pin_used);\n\t}\n\n\tkfree(pwm_map);\n}\n\nstatic void lp3943_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct lp3943_pwm *lp3943_pwm = to_lp3943_pwm(chip);\n\tstruct lp3943_pwm_map *pwm_map = pwm_get_chip_data(pwm);\n\n\tlp3943_pwm_free_map(lp3943_pwm, pwm_map);\n}\n\nstatic int lp3943_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     u64 duty_ns, u64 period_ns)\n{\n\tstruct lp3943_pwm *lp3943_pwm = to_lp3943_pwm(chip);\n\tstruct lp3943 *lp3943 = lp3943_pwm->lp3943;\n\tu8 val, reg_duty, reg_prescale;\n\tint err;\n\n\t \n\n\tif (pwm->hwpwm == 0) {\n\t\treg_prescale = LP3943_REG_PRESCALE0;\n\t\treg_duty     = LP3943_REG_PWM0;\n\t} else {\n\t\treg_prescale = LP3943_REG_PRESCALE1;\n\t\treg_duty     = LP3943_REG_PWM1;\n\t}\n\n\t \n\tperiod_ns = clamp(period_ns, (u64)LP3943_MIN_PERIOD, (u64)LP3943_MAX_PERIOD);\n\tval       = (u8)((int)period_ns / LP3943_MIN_PERIOD - 1);\n\n\terr = lp3943_write_byte(lp3943, reg_prescale, val);\n\tif (err)\n\t\treturn err;\n\n\tduty_ns = min(duty_ns, period_ns);\n\tval = (u8)((int)duty_ns * LP3943_MAX_DUTY / (int)period_ns);\n\n\treturn lp3943_write_byte(lp3943, reg_duty, val);\n}\n\nstatic int lp3943_pwm_set_mode(struct lp3943_pwm *lp3943_pwm,\n\t\t\t       struct lp3943_pwm_map *pwm_map,\n\t\t\t       u8 val)\n{\n\tstruct lp3943 *lp3943 = lp3943_pwm->lp3943;\n\tconst struct lp3943_reg_cfg *mux = lp3943->mux_cfg;\n\tint i, index, err;\n\n\tfor (i = 0; i < pwm_map->num_outputs; i++) {\n\t\tindex = pwm_map->output[i];\n\t\terr = lp3943_update_bits(lp3943, mux[index].reg,\n\t\t\t\t\t mux[index].mask,\n\t\t\t\t\t val << mux[index].shift);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int lp3943_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct lp3943_pwm *lp3943_pwm = to_lp3943_pwm(chip);\n\tstruct lp3943_pwm_map *pwm_map = pwm_get_chip_data(pwm);\n\tu8 val;\n\n\tif (pwm->hwpwm == 0)\n\t\tval = LP3943_DIM_PWM0;\n\telse\n\t\tval = LP3943_DIM_PWM1;\n\n\t \n\n\treturn lp3943_pwm_set_mode(lp3943_pwm, pwm_map, val);\n}\n\nstatic void lp3943_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct lp3943_pwm *lp3943_pwm = to_lp3943_pwm(chip);\n\tstruct lp3943_pwm_map *pwm_map = pwm_get_chip_data(pwm);\n\n\t \n\n\tlp3943_pwm_set_mode(lp3943_pwm, pwm_map, LP3943_GPIO_OUT_HIGH);\n}\n\nstatic int lp3943_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled)\n\t\t\tlp3943_pwm_disable(chip, pwm);\n\t\treturn 0;\n\t}\n\n\terr = lp3943_pwm_config(chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\terr = lp3943_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops lp3943_pwm_ops = {\n\t.request\t= lp3943_pwm_request,\n\t.free\t\t= lp3943_pwm_free,\n\t.apply\t\t= lp3943_pwm_apply,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int lp3943_pwm_parse_dt(struct device *dev,\n\t\t\t       struct lp3943_pwm *lp3943_pwm)\n{\n\tstatic const char * const name[] = { \"ti,pwm0\", \"ti,pwm1\", };\n\tstruct device_node *node = dev->of_node;\n\tstruct lp3943_platform_data *pdata;\n\tstruct lp3943_pwm_map *pwm_map;\n\tenum lp3943_pwm_output *output;\n\tint i, err, proplen, count = 0;\n\tu32 num_outputs;\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\t \n\n\tfor (i = 0; i < LP3943_NUM_PWMS; i++) {\n\t\tif (!of_get_property(node, name[i], &proplen))\n\t\t\tcontinue;\n\n\t\tnum_outputs = proplen / sizeof(u32);\n\t\tif (num_outputs == 0)\n\t\t\tcontinue;\n\n\t\toutput = devm_kcalloc(dev, num_outputs, sizeof(*output),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!output)\n\t\t\treturn -ENOMEM;\n\n\t\terr = of_property_read_u32_array(node, name[i], output,\n\t\t\t\t\t\t num_outputs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tpwm_map = devm_kzalloc(dev, sizeof(*pwm_map), GFP_KERNEL);\n\t\tif (!pwm_map)\n\t\t\treturn -ENOMEM;\n\n\t\tpwm_map->output = output;\n\t\tpwm_map->num_outputs = num_outputs;\n\t\tpdata->pwms[i] = pwm_map;\n\n\t\tcount++;\n\t}\n\n\tif (count == 0)\n\t\treturn -ENODATA;\n\n\tlp3943_pwm->pdata = pdata;\n\treturn 0;\n}\n\nstatic int lp3943_pwm_probe(struct platform_device *pdev)\n{\n\tstruct lp3943 *lp3943 = dev_get_drvdata(pdev->dev.parent);\n\tstruct lp3943_pwm *lp3943_pwm;\n\tint ret;\n\n\tlp3943_pwm = devm_kzalloc(&pdev->dev, sizeof(*lp3943_pwm), GFP_KERNEL);\n\tif (!lp3943_pwm)\n\t\treturn -ENOMEM;\n\n\tlp3943_pwm->pdata = lp3943->pdata;\n\tif (!lp3943_pwm->pdata) {\n\t\tif (IS_ENABLED(CONFIG_OF))\n\t\t\tret = lp3943_pwm_parse_dt(&pdev->dev, lp3943_pwm);\n\t\telse\n\t\t\tret = -ENODEV;\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tlp3943_pwm->lp3943 = lp3943;\n\tlp3943_pwm->chip.dev = &pdev->dev;\n\tlp3943_pwm->chip.ops = &lp3943_pwm_ops;\n\tlp3943_pwm->chip.npwm = LP3943_NUM_PWMS;\n\n\treturn devm_pwmchip_add(&pdev->dev, &lp3943_pwm->chip);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id lp3943_pwm_of_match[] = {\n\t{ .compatible = \"ti,lp3943-pwm\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lp3943_pwm_of_match);\n#endif\n\nstatic struct platform_driver lp3943_pwm_driver = {\n\t.probe = lp3943_pwm_probe,\n\t.driver = {\n\t\t.name = \"lp3943-pwm\",\n\t\t.of_match_table = of_match_ptr(lp3943_pwm_of_match),\n\t},\n};\nmodule_platform_driver(lp3943_pwm_driver);\n\nMODULE_DESCRIPTION(\"LP3943 PWM driver\");\nMODULE_ALIAS(\"platform:lp3943-pwm\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}