{
  "module_name": "pwm-renesas-tpu.c",
  "hash_id": "0afccdfffecde84573783ac36f9fbeb4be62aa354c001e4e1390dc46dc075a2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-renesas-tpu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define TPU_CHANNEL_MAX\t\t4\n\n#define TPU_TSTR\t\t0x00\t \n\n#define TPU_TCRn\t\t0x00\t \n#define TPU_TCR_CCLR_NONE\t(0 << 5)\n#define TPU_TCR_CCLR_TGRA\t(1 << 5)\n#define TPU_TCR_CCLR_TGRB\t(2 << 5)\n#define TPU_TCR_CCLR_TGRC\t(5 << 5)\n#define TPU_TCR_CCLR_TGRD\t(6 << 5)\n#define TPU_TCR_CKEG_RISING\t(0 << 3)\n#define TPU_TCR_CKEG_FALLING\t(1 << 3)\n#define TPU_TCR_CKEG_BOTH\t(2 << 3)\n#define TPU_TMDRn\t\t0x04\t \n#define TPU_TMDR_BFWT\t\t(1 << 6)\n#define TPU_TMDR_BFB\t\t(1 << 5)\n#define TPU_TMDR_BFA\t\t(1 << 4)\n#define TPU_TMDR_MD_NORMAL\t(0 << 0)\n#define TPU_TMDR_MD_PWM\t\t(2 << 0)\n#define TPU_TIORn\t\t0x08\t \n#define TPU_TIOR_IOA_0\t\t(0 << 0)\n#define TPU_TIOR_IOA_0_CLR\t(1 << 0)\n#define TPU_TIOR_IOA_0_SET\t(2 << 0)\n#define TPU_TIOR_IOA_0_TOGGLE\t(3 << 0)\n#define TPU_TIOR_IOA_1\t\t(4 << 0)\n#define TPU_TIOR_IOA_1_CLR\t(5 << 0)\n#define TPU_TIOR_IOA_1_SET\t(6 << 0)\n#define TPU_TIOR_IOA_1_TOGGLE\t(7 << 0)\n#define TPU_TIERn\t\t0x0c\t \n#define TPU_TSRn\t\t0x10\t \n#define TPU_TCNTn\t\t0x14\t \n#define TPU_TGRAn\t\t0x18\t \n#define TPU_TGRBn\t\t0x1c\t \n#define TPU_TGRCn\t\t0x20\t \n#define TPU_TGRDn\t\t0x24\t \n\n#define TPU_CHANNEL_OFFSET\t0x10\n#define TPU_CHANNEL_SIZE\t0x40\n\nenum tpu_pin_state {\n\tTPU_PIN_INACTIVE,\t\t \n\tTPU_PIN_PWM,\t\t\t \n\tTPU_PIN_ACTIVE,\t\t\t \n};\n\nstruct tpu_device;\n\nstruct tpu_pwm_device {\n\tbool timer_on;\t\t\t \n\n\tstruct tpu_device *tpu;\n\tunsigned int channel;\t\t \n\n\tenum pwm_polarity polarity;\n\tunsigned int prescaler;\n\tu16 period;\n\tu16 duty;\n};\n\nstruct tpu_device {\n\tstruct platform_device *pdev;\n\tstruct pwm_chip chip;\n\tspinlock_t lock;\n\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\n#define to_tpu_device(c)\tcontainer_of(c, struct tpu_device, chip)\n\nstatic void tpu_pwm_write(struct tpu_pwm_device *tpd, int reg_nr, u16 value)\n{\n\tvoid __iomem *base = tpd->tpu->base + TPU_CHANNEL_OFFSET\n\t\t\t   + tpd->channel * TPU_CHANNEL_SIZE;\n\n\tiowrite16(value, base + reg_nr);\n}\n\nstatic void tpu_pwm_set_pin(struct tpu_pwm_device *tpd,\n\t\t\t    enum tpu_pin_state state)\n{\n\tstatic const char * const states[] = { \"inactive\", \"PWM\", \"active\" };\n\n\tdev_dbg(&tpd->tpu->pdev->dev, \"%u: configuring pin as %s\\n\",\n\t\ttpd->channel, states[state]);\n\n\tswitch (state) {\n\tcase TPU_PIN_INACTIVE:\n\t\ttpu_pwm_write(tpd, TPU_TIORn,\n\t\t\t      tpd->polarity == PWM_POLARITY_INVERSED ?\n\t\t\t      TPU_TIOR_IOA_1 : TPU_TIOR_IOA_0);\n\t\tbreak;\n\tcase TPU_PIN_PWM:\n\t\ttpu_pwm_write(tpd, TPU_TIORn,\n\t\t\t      tpd->polarity == PWM_POLARITY_INVERSED ?\n\t\t\t      TPU_TIOR_IOA_0_SET : TPU_TIOR_IOA_1_CLR);\n\t\tbreak;\n\tcase TPU_PIN_ACTIVE:\n\t\ttpu_pwm_write(tpd, TPU_TIORn,\n\t\t\t      tpd->polarity == PWM_POLARITY_INVERSED ?\n\t\t\t      TPU_TIOR_IOA_0 : TPU_TIOR_IOA_1);\n\t\tbreak;\n\t}\n}\n\nstatic void tpu_pwm_start_stop(struct tpu_pwm_device *tpd, int start)\n{\n\tunsigned long flags;\n\tu16 value;\n\n\tspin_lock_irqsave(&tpd->tpu->lock, flags);\n\tvalue = ioread16(tpd->tpu->base + TPU_TSTR);\n\n\tif (start)\n\t\tvalue |= 1 << tpd->channel;\n\telse\n\t\tvalue &= ~(1 << tpd->channel);\n\n\tiowrite16(value, tpd->tpu->base + TPU_TSTR);\n\tspin_unlock_irqrestore(&tpd->tpu->lock, flags);\n}\n\nstatic int tpu_pwm_timer_start(struct tpu_pwm_device *tpd)\n{\n\tint ret;\n\n\tif (!tpd->timer_on) {\n\t\t \n\t\tpm_runtime_get_sync(&tpd->tpu->pdev->dev);\n\t\tret = clk_prepare_enable(tpd->tpu->clk);\n\t\tif (ret) {\n\t\t\tdev_err(&tpd->tpu->pdev->dev, \"cannot enable clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\ttpd->timer_on = true;\n\t}\n\n\t \n\ttpu_pwm_set_pin(tpd, TPU_PIN_INACTIVE);\n\ttpu_pwm_start_stop(tpd, false);\n\n\t \n\ttpu_pwm_write(tpd, TPU_TCRn, TPU_TCR_CCLR_TGRB | TPU_TCR_CKEG_RISING |\n\t\t      tpd->prescaler);\n\ttpu_pwm_write(tpd, TPU_TMDRn, TPU_TMDR_MD_PWM);\n\ttpu_pwm_set_pin(tpd, TPU_PIN_PWM);\n\ttpu_pwm_write(tpd, TPU_TGRAn, tpd->duty);\n\ttpu_pwm_write(tpd, TPU_TGRBn, tpd->period);\n\n\tdev_dbg(&tpd->tpu->pdev->dev, \"%u: TGRA 0x%04x TGRB 0x%04x\\n\",\n\t\ttpd->channel, tpd->duty, tpd->period);\n\n\t \n\ttpu_pwm_start_stop(tpd, true);\n\n\treturn 0;\n}\n\nstatic void tpu_pwm_timer_stop(struct tpu_pwm_device *tpd)\n{\n\tif (!tpd->timer_on)\n\t\treturn;\n\n\t \n\ttpu_pwm_start_stop(tpd, false);\n\n\t \n\tclk_disable_unprepare(tpd->tpu->clk);\n\tpm_runtime_put(&tpd->tpu->pdev->dev);\n\n\ttpd->timer_on = false;\n}\n\n \n\nstatic int tpu_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct tpu_device *tpu = to_tpu_device(chip);\n\tstruct tpu_pwm_device *tpd;\n\n\tif (pwm->hwpwm >= TPU_CHANNEL_MAX)\n\t\treturn -EINVAL;\n\n\ttpd = kzalloc(sizeof(*tpd), GFP_KERNEL);\n\tif (tpd == NULL)\n\t\treturn -ENOMEM;\n\n\ttpd->tpu = tpu;\n\ttpd->channel = pwm->hwpwm;\n\ttpd->polarity = PWM_POLARITY_NORMAL;\n\ttpd->prescaler = 0;\n\ttpd->period = 0;\n\ttpd->duty = 0;\n\n\ttpd->timer_on = false;\n\n\tpwm_set_chip_data(pwm, tpd);\n\n\treturn 0;\n}\n\nstatic void tpu_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct tpu_pwm_device *tpd = pwm_get_chip_data(pwm);\n\n\ttpu_pwm_timer_stop(tpd);\n\tkfree(tpd);\n}\n\nstatic int tpu_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  u64 duty_ns, u64 period_ns, bool enabled)\n{\n\tstruct tpu_pwm_device *tpd = pwm_get_chip_data(pwm);\n\tstruct tpu_device *tpu = to_tpu_device(chip);\n\tunsigned int prescaler;\n\tbool duty_only = false;\n\tu32 clk_rate;\n\tu64 period;\n\tu32 duty;\n\tint ret;\n\n\tclk_rate = clk_get_rate(tpu->clk);\n\tif (unlikely(clk_rate > NSEC_PER_SEC)) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tperiod = mul_u64_u64_div_u64(clk_rate, period_ns, NSEC_PER_SEC);\n\n\t \n\tswitch (period) {\n\tcase 1 ... 0xffff:\n\t\tprescaler = 0;\n\t\tbreak;\n\n\tcase 0x10000 ... 0x3ffff:\n\t\tprescaler = 1;\n\t\tbreak;\n\n\tcase 0x40000 ... 0xfffff:\n\t\tprescaler = 2;\n\t\tbreak;\n\n\tcase 0x100000 ... 0x3fffff:\n\t\tprescaler = 3;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tperiod >>= 2 * prescaler;\n\n\tif (duty_ns)\n\t\tduty = mul_u64_u64_div_u64(clk_rate, duty_ns,\n\t\t\t\t\t   (u64)NSEC_PER_SEC << (2 * prescaler));\n\telse\n\t\tduty = 0;\n\n\tdev_dbg(&tpu->pdev->dev,\n\t\t\"rate %u, prescaler %u, period %u, duty %u\\n\",\n\t\tclk_rate, 1 << (2 * prescaler), (u32)period, duty);\n\n\tif (tpd->prescaler == prescaler && tpd->period == period)\n\t\tduty_only = true;\n\n\ttpd->prescaler = prescaler;\n\ttpd->period = period;\n\ttpd->duty = duty;\n\n\t \n\tif (!enabled)\n\t\treturn 0;\n\n\tif (duty_only && tpd->timer_on) {\n\t\t \n\t\ttpu_pwm_write(tpd, TPU_TGRAn, tpd->duty);\n\t\tdev_dbg(&tpu->pdev->dev, \"%u: TGRA 0x%04x\\n\", tpd->channel,\n\t\t\ttpd->duty);\n\t} else {\n\t\t \n\t\tret = tpu_pwm_timer_start(tpd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (duty == 0 || duty == period) {\n\t\t \n\t\ttpu_pwm_set_pin(tpd, duty ? TPU_PIN_ACTIVE : TPU_PIN_INACTIVE);\n\t\ttpu_pwm_timer_stop(tpd);\n\t}\n\n\treturn 0;\n}\n\nstatic int tpu_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\tenum pwm_polarity polarity)\n{\n\tstruct tpu_pwm_device *tpd = pwm_get_chip_data(pwm);\n\n\ttpd->polarity = polarity;\n\n\treturn 0;\n}\n\nstatic int tpu_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct tpu_pwm_device *tpd = pwm_get_chip_data(pwm);\n\tint ret;\n\n\tret = tpu_pwm_timer_start(tpd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (tpd->duty == 0 || tpd->duty == tpd->period) {\n\t\ttpu_pwm_set_pin(tpd, tpd->duty ?\n\t\t\t\tTPU_PIN_ACTIVE : TPU_PIN_INACTIVE);\n\t\ttpu_pwm_timer_stop(tpd);\n\t}\n\n\treturn 0;\n}\n\nstatic void tpu_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct tpu_pwm_device *tpd = pwm_get_chip_data(pwm);\n\n\t \n\ttpu_pwm_timer_start(tpd);\n\ttpu_pwm_set_pin(tpd, TPU_PIN_INACTIVE);\n\ttpu_pwm_timer_stop(tpd);\n}\n\nstatic int tpu_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tint err;\n\tbool enabled = pwm->state.enabled;\n\n\tif (state->polarity != pwm->state.polarity) {\n\t\tif (enabled) {\n\t\t\ttpu_pwm_disable(chip, pwm);\n\t\t\tenabled = false;\n\t\t}\n\n\t\terr = tpu_pwm_set_polarity(chip, pwm, state->polarity);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\ttpu_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\terr = tpu_pwm_config(pwm->chip, pwm,\n\t\t\t     state->duty_cycle, state->period, enabled);\n\tif (err)\n\t\treturn err;\n\n\tif (!enabled)\n\t\terr = tpu_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops tpu_pwm_ops = {\n\t.request = tpu_pwm_request,\n\t.free = tpu_pwm_free,\n\t.apply = tpu_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\n \n\nstatic int tpu_probe(struct platform_device *pdev)\n{\n\tstruct tpu_device *tpu;\n\tint ret;\n\n\ttpu = devm_kzalloc(&pdev->dev, sizeof(*tpu), GFP_KERNEL);\n\tif (tpu == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&tpu->lock);\n\ttpu->pdev = pdev;\n\n\t \n\ttpu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tpu->base))\n\t\treturn PTR_ERR(tpu->base);\n\n\ttpu->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(tpu->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(tpu->clk), \"Failed to get clock\\n\");\n\n\t \n\tplatform_set_drvdata(pdev, tpu);\n\n\ttpu->chip.dev = &pdev->dev;\n\ttpu->chip.ops = &tpu_pwm_ops;\n\ttpu->chip.npwm = TPU_CHANNEL_MAX;\n\n\tret = devm_pm_runtime_enable(&pdev->dev);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to enable runtime PM\\n\");\n\n\tret = devm_pwmchip_add(&pdev->dev, &tpu->chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to register PWM chip\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tpu_of_table[] = {\n\t{ .compatible = \"renesas,tpu-r8a73a4\", },\n\t{ .compatible = \"renesas,tpu-r8a7740\", },\n\t{ .compatible = \"renesas,tpu-r8a7790\", },\n\t{ .compatible = \"renesas,tpu\", },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, tpu_of_table);\n#endif\n\nstatic struct platform_driver tpu_driver = {\n\t.probe\t\t= tpu_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"renesas-tpu-pwm\",\n\t\t.of_match_table = of_match_ptr(tpu_of_table),\n\t}\n};\n\nmodule_platform_driver(tpu_driver);\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"Renesas TPU PWM Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:renesas-tpu-pwm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}