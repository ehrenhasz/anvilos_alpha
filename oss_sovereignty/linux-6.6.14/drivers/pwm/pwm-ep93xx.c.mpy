{
  "module_name": "pwm-ep93xx.c",
  "hash_id": "0ad627ed382810c0e907e5c16e22e3d07689e02198bef55e4da784df59387ac3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-ep93xx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/pwm.h>\n\n#include <asm/div64.h>\n\n#include <linux/soc/cirrus/ep93xx.h>\t \n\n#define EP93XX_PWMx_TERM_COUNT\t0x00\n#define EP93XX_PWMx_DUTY_CYCLE\t0x04\n#define EP93XX_PWMx_ENABLE\t0x08\n#define EP93XX_PWMx_INVERT\t0x0c\n\nstruct ep93xx_pwm {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct pwm_chip chip;\n};\n\nstatic inline struct ep93xx_pwm *to_ep93xx_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct ep93xx_pwm, chip);\n}\n\nstatic int ep93xx_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct platform_device *pdev = to_platform_device(chip->dev);\n\n\treturn ep93xx_pwm_acquire_gpio(pdev);\n}\n\nstatic void ep93xx_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct platform_device *pdev = to_platform_device(chip->dev);\n\n\tep93xx_pwm_release_gpio(pdev);\n}\n\nstatic int ep93xx_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tint ret;\n\tstruct ep93xx_pwm *ep93xx_pwm = to_ep93xx_pwm(chip);\n\tbool enabled = state->enabled;\n\tvoid __iomem *base = ep93xx_pwm->base;\n\tunsigned long long c;\n\tunsigned long period_cycles;\n\tunsigned long duty_cycles;\n\tunsigned long term;\n\n\tif (state->polarity != pwm->state.polarity) {\n\t\tif (enabled) {\n\t\t\twritew(0x0, ep93xx_pwm->base + EP93XX_PWMx_ENABLE);\n\t\t\tclk_disable_unprepare(ep93xx_pwm->clk);\n\t\t\tenabled = false;\n\t\t}\n\n\t\t \n\t\tret = clk_prepare_enable(ep93xx_pwm->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (state->polarity == PWM_POLARITY_INVERSED)\n\t\t\twritew(0x1, ep93xx_pwm->base + EP93XX_PWMx_INVERT);\n\t\telse\n\t\t\twritew(0x0, ep93xx_pwm->base + EP93XX_PWMx_INVERT);\n\n\t\tclk_disable_unprepare(ep93xx_pwm->clk);\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled) {\n\t\t\twritew(0x0, ep93xx_pwm->base + EP93XX_PWMx_ENABLE);\n\t\t\tclk_disable_unprepare(ep93xx_pwm->clk);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (!pwm_is_enabled(pwm)) {\n\t\tret = clk_prepare_enable(ep93xx_pwm->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tc = clk_get_rate(ep93xx_pwm->clk);\n\tc *= state->period;\n\tdo_div(c, 1000000000);\n\tperiod_cycles = c;\n\n\tc = period_cycles;\n\tc *= state->duty_cycle;\n\tdo_div(c, state->period);\n\tduty_cycles = c;\n\n\tif (period_cycles < 0x10000 && duty_cycles < 0x10000) {\n\t\tterm = readw(base + EP93XX_PWMx_TERM_COUNT);\n\n\t\t \n\t\tif (period_cycles > term) {\n\t\t\twritew(period_cycles, base + EP93XX_PWMx_TERM_COUNT);\n\t\t\twritew(duty_cycles, base + EP93XX_PWMx_DUTY_CYCLE);\n\t\t} else {\n\t\t\twritew(duty_cycles, base + EP93XX_PWMx_DUTY_CYCLE);\n\t\t\twritew(period_cycles, base + EP93XX_PWMx_TERM_COUNT);\n\t\t}\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (!pwm_is_enabled(pwm))\n\t\tclk_disable_unprepare(ep93xx_pwm->clk);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (!enabled) {\n\t\tret = clk_prepare_enable(ep93xx_pwm->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twritew(0x1, ep93xx_pwm->base + EP93XX_PWMx_ENABLE);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops ep93xx_pwm_ops = {\n\t.request = ep93xx_pwm_request,\n\t.free = ep93xx_pwm_free,\n\t.apply = ep93xx_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int ep93xx_pwm_probe(struct platform_device *pdev)\n{\n\tstruct ep93xx_pwm *ep93xx_pwm;\n\tint ret;\n\n\tep93xx_pwm = devm_kzalloc(&pdev->dev, sizeof(*ep93xx_pwm), GFP_KERNEL);\n\tif (!ep93xx_pwm)\n\t\treturn -ENOMEM;\n\n\tep93xx_pwm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ep93xx_pwm->base))\n\t\treturn PTR_ERR(ep93xx_pwm->base);\n\n\tep93xx_pwm->clk = devm_clk_get(&pdev->dev, \"pwm_clk\");\n\tif (IS_ERR(ep93xx_pwm->clk))\n\t\treturn PTR_ERR(ep93xx_pwm->clk);\n\n\tep93xx_pwm->chip.dev = &pdev->dev;\n\tep93xx_pwm->chip.ops = &ep93xx_pwm_ops;\n\tep93xx_pwm->chip.npwm = 1;\n\n\tret = devm_pwmchip_add(&pdev->dev, &ep93xx_pwm->chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct platform_driver ep93xx_pwm_driver = {\n\t.driver = {\n\t\t.name = \"ep93xx-pwm\",\n\t},\n\t.probe = ep93xx_pwm_probe,\n};\nmodule_platform_driver(ep93xx_pwm_driver);\n\nMODULE_DESCRIPTION(\"Cirrus Logic EP93xx PWM driver\");\nMODULE_AUTHOR(\"Matthieu Crapet <mcrapet@gmail.com>\");\nMODULE_AUTHOR(\"H Hartley Sweeten <hsweeten@visionengravers.com>\");\nMODULE_ALIAS(\"platform:ep93xx-pwm\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}