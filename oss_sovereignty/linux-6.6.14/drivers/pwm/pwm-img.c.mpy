{
  "module_name": "pwm-img.c",
  "hash_id": "f09de670aca240d83a973b4113f2ba881667441faff9ab72ac7d052d3bdc3510",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-img.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \n#define PWM_CTRL_CFG\t\t\t\t0x0000\n#define PWM_CTRL_CFG_NO_SUB_DIV\t\t\t0\n#define PWM_CTRL_CFG_SUB_DIV0\t\t\t1\n#define PWM_CTRL_CFG_SUB_DIV1\t\t\t2\n#define PWM_CTRL_CFG_SUB_DIV0_DIV1\t\t3\n#define PWM_CTRL_CFG_DIV_SHIFT(ch)\t\t((ch) * 2 + 4)\n#define PWM_CTRL_CFG_DIV_MASK\t\t\t0x3\n\n#define PWM_CH_CFG(ch)\t\t\t\t(0x4 + (ch) * 4)\n#define PWM_CH_CFG_TMBASE_SHIFT\t\t\t0\n#define PWM_CH_CFG_DUTY_SHIFT\t\t\t16\n\n#define PERIP_PWM_PDM_CONTROL\t\t\t0x0140\n#define PERIP_PWM_PDM_CONTROL_CH_MASK\t\t0x1\n#define PERIP_PWM_PDM_CONTROL_CH_SHIFT(ch)\t((ch) * 4)\n\n#define IMG_PWM_PM_TIMEOUT\t\t\t1000  \n\n \n#define MIN_TMBASE_STEPS\t\t\t16\n\n#define IMG_PWM_NPWM\t\t\t\t4\n\nstruct img_pwm_soc_data {\n\tu32 max_timebase;\n};\n\nstruct img_pwm_chip {\n\tstruct device\t*dev;\n\tstruct pwm_chip\tchip;\n\tstruct clk\t*pwm_clk;\n\tstruct clk\t*sys_clk;\n\tvoid __iomem\t*base;\n\tstruct regmap\t*periph_regs;\n\tint\t\tmax_period_ns;\n\tint\t\tmin_period_ns;\n\tconst struct img_pwm_soc_data   *data;\n\tu32\t\tsuspend_ctrl_cfg;\n\tu32\t\tsuspend_ch_cfg[IMG_PWM_NPWM];\n};\n\nstatic inline struct img_pwm_chip *to_img_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct img_pwm_chip, chip);\n}\n\nstatic inline void img_pwm_writel(struct img_pwm_chip *imgchip,\n\t\t\t\t  u32 reg, u32 val)\n{\n\twritel(val, imgchip->base + reg);\n}\n\nstatic inline u32 img_pwm_readl(struct img_pwm_chip *imgchip, u32 reg)\n{\n\treturn readl(imgchip->base + reg);\n}\n\nstatic int img_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  int duty_ns, int period_ns)\n{\n\tu32 val, div, duty, timebase;\n\tunsigned long mul, output_clk_hz, input_clk_hz;\n\tstruct img_pwm_chip *imgchip = to_img_pwm_chip(chip);\n\tunsigned int max_timebase = imgchip->data->max_timebase;\n\tint ret;\n\n\tif (period_ns < imgchip->min_period_ns ||\n\t    period_ns > imgchip->max_period_ns) {\n\t\tdev_err(chip->dev, \"configured period not in range\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tinput_clk_hz = clk_get_rate(imgchip->pwm_clk);\n\toutput_clk_hz = DIV_ROUND_UP(NSEC_PER_SEC, period_ns);\n\n\tmul = DIV_ROUND_UP(input_clk_hz, output_clk_hz);\n\tif (mul <= max_timebase) {\n\t\tdiv = PWM_CTRL_CFG_NO_SUB_DIV;\n\t\ttimebase = DIV_ROUND_UP(mul, 1);\n\t} else if (mul <= max_timebase * 8) {\n\t\tdiv = PWM_CTRL_CFG_SUB_DIV0;\n\t\ttimebase = DIV_ROUND_UP(mul, 8);\n\t} else if (mul <= max_timebase * 64) {\n\t\tdiv = PWM_CTRL_CFG_SUB_DIV1;\n\t\ttimebase = DIV_ROUND_UP(mul, 64);\n\t} else if (mul <= max_timebase * 512) {\n\t\tdiv = PWM_CTRL_CFG_SUB_DIV0_DIV1;\n\t\ttimebase = DIV_ROUND_UP(mul, 512);\n\t} else {\n\t\tdev_err(chip->dev,\n\t\t\t\"failed to configure timebase steps/divider value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tduty = DIV_ROUND_UP(timebase * duty_ns, period_ns);\n\n\tret = pm_runtime_resume_and_get(chip->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = img_pwm_readl(imgchip, PWM_CTRL_CFG);\n\tval &= ~(PWM_CTRL_CFG_DIV_MASK << PWM_CTRL_CFG_DIV_SHIFT(pwm->hwpwm));\n\tval |= (div & PWM_CTRL_CFG_DIV_MASK) <<\n\t\tPWM_CTRL_CFG_DIV_SHIFT(pwm->hwpwm);\n\timg_pwm_writel(imgchip, PWM_CTRL_CFG, val);\n\n\tval = (duty << PWM_CH_CFG_DUTY_SHIFT) |\n\t      (timebase << PWM_CH_CFG_TMBASE_SHIFT);\n\timg_pwm_writel(imgchip, PWM_CH_CFG(pwm->hwpwm), val);\n\n\tpm_runtime_mark_last_busy(chip->dev);\n\tpm_runtime_put_autosuspend(chip->dev);\n\n\treturn 0;\n}\n\nstatic int img_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tu32 val;\n\tstruct img_pwm_chip *imgchip = to_img_pwm_chip(chip);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(chip->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = img_pwm_readl(imgchip, PWM_CTRL_CFG);\n\tval |= BIT(pwm->hwpwm);\n\timg_pwm_writel(imgchip, PWM_CTRL_CFG, val);\n\n\tregmap_clear_bits(imgchip->periph_regs, PERIP_PWM_PDM_CONTROL,\n\t\t\t  PERIP_PWM_PDM_CONTROL_CH_MASK <<\n\t\t\t  PERIP_PWM_PDM_CONTROL_CH_SHIFT(pwm->hwpwm));\n\n\treturn 0;\n}\n\nstatic void img_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tu32 val;\n\tstruct img_pwm_chip *imgchip = to_img_pwm_chip(chip);\n\n\tval = img_pwm_readl(imgchip, PWM_CTRL_CFG);\n\tval &= ~BIT(pwm->hwpwm);\n\timg_pwm_writel(imgchip, PWM_CTRL_CFG, val);\n\n\tpm_runtime_mark_last_busy(chip->dev);\n\tpm_runtime_put_autosuspend(chip->dev);\n}\n\nstatic int img_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled)\n\t\t\timg_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\terr = img_pwm_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\terr = img_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops img_pwm_ops = {\n\t.apply = img_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct img_pwm_soc_data pistachio_pwm = {\n\t.max_timebase = 255,\n};\n\nstatic const struct of_device_id img_pwm_of_match[] = {\n\t{\n\t\t.compatible = \"img,pistachio-pwm\",\n\t\t.data = &pistachio_pwm,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, img_pwm_of_match);\n\nstatic int img_pwm_runtime_suspend(struct device *dev)\n{\n\tstruct img_pwm_chip *imgchip = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(imgchip->pwm_clk);\n\tclk_disable_unprepare(imgchip->sys_clk);\n\n\treturn 0;\n}\n\nstatic int img_pwm_runtime_resume(struct device *dev)\n{\n\tstruct img_pwm_chip *imgchip = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(imgchip->sys_clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not prepare or enable sys clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(imgchip->pwm_clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not prepare or enable pwm clock\\n\");\n\t\tclk_disable_unprepare(imgchip->sys_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int img_pwm_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tu64 val;\n\tunsigned long clk_rate;\n\tstruct img_pwm_chip *imgchip;\n\tconst struct of_device_id *of_dev_id;\n\n\timgchip = devm_kzalloc(&pdev->dev, sizeof(*imgchip), GFP_KERNEL);\n\tif (!imgchip)\n\t\treturn -ENOMEM;\n\n\timgchip->dev = &pdev->dev;\n\n\timgchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(imgchip->base))\n\t\treturn PTR_ERR(imgchip->base);\n\n\tof_dev_id = of_match_device(img_pwm_of_match, &pdev->dev);\n\tif (!of_dev_id)\n\t\treturn -ENODEV;\n\timgchip->data = of_dev_id->data;\n\n\timgchip->periph_regs = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t       \"img,cr-periph\");\n\tif (IS_ERR(imgchip->periph_regs))\n\t\treturn PTR_ERR(imgchip->periph_regs);\n\n\timgchip->sys_clk = devm_clk_get(&pdev->dev, \"sys\");\n\tif (IS_ERR(imgchip->sys_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get system clock\\n\");\n\t\treturn PTR_ERR(imgchip->sys_clk);\n\t}\n\n\timgchip->pwm_clk = devm_clk_get(&pdev->dev, \"imgchip\");\n\tif (IS_ERR(imgchip->pwm_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get imgchip clock\\n\");\n\t\treturn PTR_ERR(imgchip->pwm_clk);\n\t}\n\n\tplatform_set_drvdata(pdev, imgchip);\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, IMG_PWM_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = img_pwm_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\tclk_rate = clk_get_rate(imgchip->pwm_clk);\n\tif (!clk_rate) {\n\t\tdev_err(&pdev->dev, \"imgchip clock has no frequency\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_suspend;\n\t}\n\n\t \n\tval = (u64)NSEC_PER_SEC * 512 * imgchip->data->max_timebase;\n\tdo_div(val, clk_rate);\n\timgchip->max_period_ns = val;\n\n\tval = (u64)NSEC_PER_SEC * MIN_TMBASE_STEPS;\n\tdo_div(val, clk_rate);\n\timgchip->min_period_ns = val;\n\n\timgchip->chip.dev = &pdev->dev;\n\timgchip->chip.ops = &img_pwm_ops;\n\timgchip->chip.npwm = IMG_PWM_NPWM;\n\n\tret = pwmchip_add(&imgchip->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pwmchip_add failed: %d\\n\", ret);\n\t\tgoto err_suspend;\n\t}\n\n\treturn 0;\n\nerr_suspend:\n\tif (!pm_runtime_enabled(&pdev->dev))\n\t\timg_pwm_runtime_suspend(&pdev->dev);\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\treturn ret;\n}\n\nstatic void img_pwm_remove(struct platform_device *pdev)\n{\n\tstruct img_pwm_chip *imgchip = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\timg_pwm_runtime_suspend(&pdev->dev);\n\n\tpwmchip_remove(&imgchip->chip);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int img_pwm_suspend(struct device *dev)\n{\n\tstruct img_pwm_chip *imgchip = dev_get_drvdata(dev);\n\tint i, ret;\n\n\tif (pm_runtime_status_suspended(dev)) {\n\t\tret = img_pwm_runtime_resume(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < imgchip->chip.npwm; i++)\n\t\timgchip->suspend_ch_cfg[i] = img_pwm_readl(imgchip,\n\t\t\t\t\t\t\t   PWM_CH_CFG(i));\n\n\timgchip->suspend_ctrl_cfg = img_pwm_readl(imgchip, PWM_CTRL_CFG);\n\n\timg_pwm_runtime_suspend(dev);\n\n\treturn 0;\n}\n\nstatic int img_pwm_resume(struct device *dev)\n{\n\tstruct img_pwm_chip *imgchip = dev_get_drvdata(dev);\n\tint ret;\n\tint i;\n\n\tret = img_pwm_runtime_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < imgchip->chip.npwm; i++)\n\t\timg_pwm_writel(imgchip, PWM_CH_CFG(i),\n\t\t\t       imgchip->suspend_ch_cfg[i]);\n\n\timg_pwm_writel(imgchip, PWM_CTRL_CFG, imgchip->suspend_ctrl_cfg);\n\n\tfor (i = 0; i < imgchip->chip.npwm; i++)\n\t\tif (imgchip->suspend_ctrl_cfg & BIT(i))\n\t\t\tregmap_clear_bits(imgchip->periph_regs,\n\t\t\t\t\t  PERIP_PWM_PDM_CONTROL,\n\t\t\t\t\t  PERIP_PWM_PDM_CONTROL_CH_MASK <<\n\t\t\t\t\t  PERIP_PWM_PDM_CONTROL_CH_SHIFT(i));\n\n\tif (pm_runtime_status_suspended(dev))\n\t\timg_pwm_runtime_suspend(dev);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops img_pwm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(img_pwm_runtime_suspend,\n\t\t\t   img_pwm_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(img_pwm_suspend, img_pwm_resume)\n};\n\nstatic struct platform_driver img_pwm_driver = {\n\t.driver = {\n\t\t.name = \"img-pwm\",\n\t\t.pm = &img_pwm_pm_ops,\n\t\t.of_match_table = img_pwm_of_match,\n\t},\n\t.probe = img_pwm_probe,\n\t.remove_new = img_pwm_remove,\n};\nmodule_platform_driver(img_pwm_driver);\n\nMODULE_AUTHOR(\"Sai Masarapu <Sai.Masarapu@imgtec.com>\");\nMODULE_DESCRIPTION(\"Imagination Technologies PWM DAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}