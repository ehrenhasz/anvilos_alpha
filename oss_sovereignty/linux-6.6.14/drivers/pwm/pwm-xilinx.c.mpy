{
  "module_name": "pwm-xilinx.c",
  "hash_id": "23608cd1779a01968de0565d35c7724f86746f2883e46a48aba77830c17eb15c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-xilinx.c",
  "human_readable_source": "\n \n\n#include <clocksource/timer-xilinx.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n\n \nu32 xilinx_timer_tlr_cycles(struct xilinx_timer_priv *priv, u32 tcsr,\n\t\t\t    u64 cycles)\n{\n\tWARN_ON(cycles < 2 || cycles - 2 > priv->max);\n\n\tif (tcsr & TCSR_UDT)\n\t\treturn cycles - 2;\n\treturn priv->max - cycles + 2;\n}\n\nunsigned int xilinx_timer_get_period(struct xilinx_timer_priv *priv,\n\t\t\t\t     u32 tlr, u32 tcsr)\n{\n\tu64 cycles;\n\n\tif (tcsr & TCSR_UDT)\n\t\tcycles = tlr + 2;\n\telse\n\t\tcycles = (u64)priv->max - tlr + 2;\n\n\t \n\treturn DIV64_U64_ROUND_UP(cycles * NSEC_PER_SEC,\n\t\t\t\t  clk_get_rate(priv->clk));\n}\n\n \n#define TCSR_PWM_SET (TCSR_GENT | TCSR_ARHT | TCSR_ENT | TCSR_PWMA)\n#define TCSR_PWM_CLEAR (TCSR_MDT | TCSR_LOAD)\n#define TCSR_PWM_MASK (TCSR_PWM_SET | TCSR_PWM_CLEAR)\n\nstruct xilinx_pwm_device {\n\tstruct pwm_chip chip;\n\tstruct xilinx_timer_priv priv;\n};\n\nstatic inline struct xilinx_timer_priv\n*xilinx_pwm_chip_to_priv(struct pwm_chip *chip)\n{\n\treturn &container_of(chip, struct xilinx_pwm_device, chip)->priv;\n}\n\nstatic bool xilinx_timer_pwm_enabled(u32 tcsr0, u32 tcsr1)\n{\n\treturn ((TCSR_PWM_MASK | TCSR_CASC) & tcsr0) == TCSR_PWM_SET &&\n\t\t(TCSR_PWM_MASK & tcsr1) == TCSR_PWM_SET;\n}\n\nstatic int xilinx_pwm_apply(struct pwm_chip *chip, struct pwm_device *unused,\n\t\t\t    const struct pwm_state *state)\n{\n\tstruct xilinx_timer_priv *priv = xilinx_pwm_chip_to_priv(chip);\n\tu32 tlr0, tlr1, tcsr0, tcsr1;\n\tu64 period_cycles, duty_cycles;\n\tunsigned long rate;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\t \n\trate = clk_get_rate(priv->clk);\n\t \n\tperiod_cycles = min_t(u64, state->period, U32_MAX * NSEC_PER_SEC);\n\tperiod_cycles = mul_u64_u32_div(period_cycles, rate, NSEC_PER_SEC);\n\tperiod_cycles = min_t(u64, period_cycles, priv->max + 2);\n\tif (period_cycles < 2)\n\t\treturn -ERANGE;\n\n\t \n\tduty_cycles = min_t(u64, state->duty_cycle, U32_MAX * NSEC_PER_SEC);\n\tduty_cycles = mul_u64_u32_div(duty_cycles, rate, NSEC_PER_SEC);\n\tduty_cycles = min_t(u64, duty_cycles, priv->max + 2);\n\n\t \n\tif (duty_cycles >= period_cycles)\n\t\tduty_cycles = period_cycles - 1;\n\n\t \n\tif (duty_cycles < 2)\n\t\tduty_cycles = period_cycles;\n\n\tregmap_read(priv->map, TCSR0, &tcsr0);\n\tregmap_read(priv->map, TCSR1, &tcsr1);\n\ttlr0 = xilinx_timer_tlr_cycles(priv, tcsr0, period_cycles);\n\ttlr1 = xilinx_timer_tlr_cycles(priv, tcsr1, duty_cycles);\n\tregmap_write(priv->map, TLR0, tlr0);\n\tregmap_write(priv->map, TLR1, tlr1);\n\n\tif (state->enabled) {\n\t\t \n\t\tif (!xilinx_timer_pwm_enabled(tcsr0, tcsr1)) {\n\t\t\t \n\t\t\tregmap_write(priv->map, TCSR0, tcsr0 | TCSR_LOAD);\n\t\t\tregmap_write(priv->map, TCSR1, tcsr1 | TCSR_LOAD);\n\t\t\t \n\t\t\ttcsr0 = (TCSR_PWM_SET & ~TCSR_ENT) | (tcsr0 & TCSR_UDT);\n\t\t\ttcsr1 = TCSR_PWM_SET | TCSR_ENALL | (tcsr1 & TCSR_UDT);\n\t\t\tregmap_write(priv->map, TCSR0, tcsr0);\n\t\t\tregmap_write(priv->map, TCSR1, tcsr1);\n\t\t}\n\t} else {\n\t\tregmap_write(priv->map, TCSR0, 0);\n\t\tregmap_write(priv->map, TCSR1, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int xilinx_pwm_get_state(struct pwm_chip *chip,\n\t\t\t\tstruct pwm_device *unused,\n\t\t\t\tstruct pwm_state *state)\n{\n\tstruct xilinx_timer_priv *priv = xilinx_pwm_chip_to_priv(chip);\n\tu32 tlr0, tlr1, tcsr0, tcsr1;\n\n\tregmap_read(priv->map, TLR0, &tlr0);\n\tregmap_read(priv->map, TLR1, &tlr1);\n\tregmap_read(priv->map, TCSR0, &tcsr0);\n\tregmap_read(priv->map, TCSR1, &tcsr1);\n\tstate->period = xilinx_timer_get_period(priv, tlr0, tcsr0);\n\tstate->duty_cycle = xilinx_timer_get_period(priv, tlr1, tcsr1);\n\tstate->enabled = xilinx_timer_pwm_enabled(tcsr0, tcsr1);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\t \n\tif (state->period == state->duty_cycle)\n\t\tstate->duty_cycle = 0;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops xilinx_pwm_ops = {\n\t.apply = xilinx_pwm_apply,\n\t.get_state = xilinx_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct regmap_config xilinx_pwm_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.max_register = TCR1,\n};\n\nstatic int xilinx_pwm_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct xilinx_timer_priv *priv;\n\tstruct xilinx_pwm_device *xilinx_pwm;\n\tu32 pwm_cells, one_timer, width;\n\tvoid __iomem *regs;\n\n\t \n\tret = of_property_read_u32(np, \"#pwm-cells\", &pwm_cells);\n\tif (ret == -EINVAL)\n\t\treturn -ENODEV;\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not read #pwm-cells\\n\");\n\n\txilinx_pwm = devm_kzalloc(dev, sizeof(*xilinx_pwm), GFP_KERNEL);\n\tif (!xilinx_pwm)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, xilinx_pwm);\n\tpriv = &xilinx_pwm->priv;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tpriv->map = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t  &xilinx_pwm_regmap_config);\n\tif (IS_ERR(priv->map))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->map),\n\t\t\t\t     \"Could not create regmap\\n\");\n\n\tret = of_property_read_u32(np, \"xlnx,one-timer-only\", &one_timer);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Could not read xlnx,one-timer-only\\n\");\n\n\tif (one_timer)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Two timers required for PWM mode\\n\");\n\n\tret = of_property_read_u32(np, \"xlnx,count-width\", &width);\n\tif (ret == -EINVAL)\n\t\twidth = 32;\n\telse if (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Could not read xlnx,count-width\\n\");\n\n\tif (width != 8 && width != 16 && width != 32)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"Invalid counter width %d\\n\", width);\n\tpriv->max = BIT_ULL(width) - 1;\n\n\t \n\n\tpriv->clk = devm_clk_get(dev, \"s_axi_aclk\");\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"Could not get clock\\n\");\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Clock enable failed\\n\");\n\tclk_rate_exclusive_get(priv->clk);\n\n\txilinx_pwm->chip.dev = dev;\n\txilinx_pwm->chip.ops = &xilinx_pwm_ops;\n\txilinx_pwm->chip.npwm = 1;\n\tret = pwmchip_add(&xilinx_pwm->chip);\n\tif (ret) {\n\t\tclk_rate_exclusive_put(priv->clk);\n\t\tclk_disable_unprepare(priv->clk);\n\t\treturn dev_err_probe(dev, ret, \"Could not register PWM chip\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void xilinx_pwm_remove(struct platform_device *pdev)\n{\n\tstruct xilinx_pwm_device *xilinx_pwm = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&xilinx_pwm->chip);\n\tclk_rate_exclusive_put(xilinx_pwm->priv.clk);\n\tclk_disable_unprepare(xilinx_pwm->priv.clk);\n}\n\nstatic const struct of_device_id xilinx_pwm_of_match[] = {\n\t{ .compatible = \"xlnx,xps-timer-1.00.a\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xilinx_pwm_of_match);\n\nstatic struct platform_driver xilinx_pwm_driver = {\n\t.probe = xilinx_pwm_probe,\n\t.remove_new = xilinx_pwm_remove,\n\t.driver = {\n\t\t.name = \"xilinx-pwm\",\n\t\t.of_match_table = of_match_ptr(xilinx_pwm_of_match),\n\t},\n};\nmodule_platform_driver(xilinx_pwm_driver);\n\nMODULE_ALIAS(\"platform:xilinx-pwm\");\nMODULE_DESCRIPTION(\"PWM driver for Xilinx LogiCORE IP AXI Timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}