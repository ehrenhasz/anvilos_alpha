{
  "module_name": "pwm-pca9685.c",
  "hash_id": "14383b508948c1a6118fd50d213ced7490f98f9cd95f999ac74dcee280aaaa2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-pca9685.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/bitmap.h>\n\n \n\n#define PCA9685_MODE1\t\t0x00\n#define PCA9685_MODE2\t\t0x01\n#define PCA9685_SUBADDR1\t0x02\n#define PCA9685_SUBADDR2\t0x03\n#define PCA9685_SUBADDR3\t0x04\n#define PCA9685_ALLCALLADDR\t0x05\n#define PCA9685_LEDX_ON_L\t0x06\n#define PCA9685_LEDX_ON_H\t0x07\n#define PCA9685_LEDX_OFF_L\t0x08\n#define PCA9685_LEDX_OFF_H\t0x09\n\n#define PCA9685_ALL_LED_ON_L\t0xFA\n#define PCA9685_ALL_LED_ON_H\t0xFB\n#define PCA9685_ALL_LED_OFF_L\t0xFC\n#define PCA9685_ALL_LED_OFF_H\t0xFD\n#define PCA9685_PRESCALE\t0xFE\n\n#define PCA9685_PRESCALE_MIN\t0x03\t \n#define PCA9685_PRESCALE_MAX\t0xFF\t \n\n#define PCA9685_COUNTER_RANGE\t4096\n#define PCA9685_OSC_CLOCK_MHZ\t25\t \n\n#define PCA9685_NUMREGS\t\t0xFF\n#define PCA9685_MAXCHAN\t\t0x10\n\n#define LED_FULL\t\tBIT(4)\n#define MODE1_ALLCALL\t\tBIT(0)\n#define MODE1_SUB3\t\tBIT(1)\n#define MODE1_SUB2\t\tBIT(2)\n#define MODE1_SUB1\t\tBIT(3)\n#define MODE1_SLEEP\t\tBIT(4)\n#define MODE2_INVRT\t\tBIT(4)\n#define MODE2_OUTDRV\t\tBIT(2)\n\n#define LED_N_ON_H(N)\t(PCA9685_LEDX_ON_H + (4 * (N)))\n#define LED_N_ON_L(N)\t(PCA9685_LEDX_ON_L + (4 * (N)))\n#define LED_N_OFF_H(N)\t(PCA9685_LEDX_OFF_H + (4 * (N)))\n#define LED_N_OFF_L(N)\t(PCA9685_LEDX_OFF_L + (4 * (N)))\n\n#define REG_ON_H(C)\t((C) >= PCA9685_MAXCHAN ? PCA9685_ALL_LED_ON_H : LED_N_ON_H((C)))\n#define REG_ON_L(C)\t((C) >= PCA9685_MAXCHAN ? PCA9685_ALL_LED_ON_L : LED_N_ON_L((C)))\n#define REG_OFF_H(C)\t((C) >= PCA9685_MAXCHAN ? PCA9685_ALL_LED_OFF_H : LED_N_OFF_H((C)))\n#define REG_OFF_L(C)\t((C) >= PCA9685_MAXCHAN ? PCA9685_ALL_LED_OFF_L : LED_N_OFF_L((C)))\n\nstruct pca9685 {\n\tstruct pwm_chip chip;\n\tstruct regmap *regmap;\n\tstruct mutex lock;\n\tDECLARE_BITMAP(pwms_enabled, PCA9685_MAXCHAN + 1);\n#if IS_ENABLED(CONFIG_GPIOLIB)\n\tstruct gpio_chip gpio;\n\tDECLARE_BITMAP(pwms_inuse, PCA9685_MAXCHAN + 1);\n#endif\n};\n\nstatic inline struct pca9685 *to_pca(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct pca9685, chip);\n}\n\n \nstatic bool pca9685_prescaler_can_change(struct pca9685 *pca, int channel)\n{\n\t \n\tif (bitmap_empty(pca->pwms_enabled, PCA9685_MAXCHAN + 1))\n\t\treturn true;\n\t \n\tif (bitmap_weight(pca->pwms_enabled, PCA9685_MAXCHAN + 1) > 1)\n\t\treturn false;\n\t \n\treturn test_bit(channel, pca->pwms_enabled);\n}\n\nstatic int pca9685_read_reg(struct pca9685 *pca, unsigned int reg, unsigned int *val)\n{\n\tstruct device *dev = pca->chip.dev;\n\tint err;\n\n\terr = regmap_read(pca->regmap, reg, val);\n\tif (err)\n\t\tdev_err(dev, \"regmap_read of register 0x%x failed: %pe\\n\", reg, ERR_PTR(err));\n\n\treturn err;\n}\n\nstatic int pca9685_write_reg(struct pca9685 *pca, unsigned int reg, unsigned int val)\n{\n\tstruct device *dev = pca->chip.dev;\n\tint err;\n\n\terr = regmap_write(pca->regmap, reg, val);\n\tif (err)\n\t\tdev_err(dev, \"regmap_write to register 0x%x failed: %pe\\n\", reg, ERR_PTR(err));\n\n\treturn err;\n}\n\n \nstatic void pca9685_pwm_set_duty(struct pca9685 *pca, int channel, unsigned int duty)\n{\n\tstruct pwm_device *pwm = &pca->chip.pwms[channel];\n\tunsigned int on, off;\n\n\tif (duty == 0) {\n\t\t \n\t\tpca9685_write_reg(pca, REG_OFF_H(channel), LED_FULL);\n\t\treturn;\n\t} else if (duty >= PCA9685_COUNTER_RANGE) {\n\t\t \n\t\tpca9685_write_reg(pca, REG_ON_H(channel), LED_FULL);\n\t\tpca9685_write_reg(pca, REG_OFF_H(channel), 0);\n\t\treturn;\n\t}\n\n\n\tif (pwm->state.usage_power && channel < PCA9685_MAXCHAN) {\n\t\t \n\t\ton = channel * PCA9685_COUNTER_RANGE / PCA9685_MAXCHAN;\n\t} else\n\t\ton = 0;\n\n\toff = (on + duty) % PCA9685_COUNTER_RANGE;\n\n\t \n\tpca9685_write_reg(pca, REG_ON_L(channel), on & 0xff);\n\tpca9685_write_reg(pca, REG_ON_H(channel), (on >> 8) & 0xf);\n\t \n\tpca9685_write_reg(pca, REG_OFF_L(channel), off & 0xff);\n\tpca9685_write_reg(pca, REG_OFF_H(channel), (off >> 8) & 0xf);\n}\n\nstatic unsigned int pca9685_pwm_get_duty(struct pca9685 *pca, int channel)\n{\n\tstruct pwm_device *pwm = &pca->chip.pwms[channel];\n\tunsigned int off = 0, on = 0, val = 0;\n\n\tif (WARN_ON(channel >= PCA9685_MAXCHAN)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tpca9685_read_reg(pca, LED_N_OFF_H(channel), &off);\n\tif (off & LED_FULL) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tpca9685_read_reg(pca, LED_N_ON_H(channel), &on);\n\tif (on & LED_FULL) {\n\t\t \n\t\treturn PCA9685_COUNTER_RANGE;\n\t}\n\n\tpca9685_read_reg(pca, LED_N_OFF_L(channel), &val);\n\toff = ((off & 0xf) << 8) | (val & 0xff);\n\tif (!pwm->state.usage_power)\n\t\treturn off;\n\n\t \n\tif (pca9685_read_reg(pca, LED_N_ON_L(channel), &val)) {\n\t\t \n\t\tval = 0;\n\t}\n\ton = ((on & 0xf) << 8) | (val & 0xff);\n\treturn (off - on) & (PCA9685_COUNTER_RANGE - 1);\n}\n\n#if IS_ENABLED(CONFIG_GPIOLIB)\nstatic bool pca9685_pwm_test_and_set_inuse(struct pca9685 *pca, int pwm_idx)\n{\n\tbool is_inuse;\n\n\tmutex_lock(&pca->lock);\n\tif (pwm_idx >= PCA9685_MAXCHAN) {\n\t\t \n\t\tif (!bitmap_empty(pca->pwms_inuse, PCA9685_MAXCHAN)) {\n\t\t\tis_inuse = true;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tif (test_bit(PCA9685_MAXCHAN, pca->pwms_inuse)) {\n\t\t\tis_inuse = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tis_inuse = test_and_set_bit(pwm_idx, pca->pwms_inuse);\nout:\n\tmutex_unlock(&pca->lock);\n\treturn is_inuse;\n}\n\nstatic void pca9685_pwm_clear_inuse(struct pca9685 *pca, int pwm_idx)\n{\n\tmutex_lock(&pca->lock);\n\tclear_bit(pwm_idx, pca->pwms_inuse);\n\tmutex_unlock(&pca->lock);\n}\n\nstatic int pca9685_pwm_gpio_request(struct gpio_chip *gpio, unsigned int offset)\n{\n\tstruct pca9685 *pca = gpiochip_get_data(gpio);\n\n\tif (pca9685_pwm_test_and_set_inuse(pca, offset))\n\t\treturn -EBUSY;\n\tpm_runtime_get_sync(pca->chip.dev);\n\treturn 0;\n}\n\nstatic int pca9685_pwm_gpio_get(struct gpio_chip *gpio, unsigned int offset)\n{\n\tstruct pca9685 *pca = gpiochip_get_data(gpio);\n\n\treturn pca9685_pwm_get_duty(pca, offset) != 0;\n}\n\nstatic void pca9685_pwm_gpio_set(struct gpio_chip *gpio, unsigned int offset,\n\t\t\t\t int value)\n{\n\tstruct pca9685 *pca = gpiochip_get_data(gpio);\n\n\tpca9685_pwm_set_duty(pca, offset, value ? PCA9685_COUNTER_RANGE : 0);\n}\n\nstatic void pca9685_pwm_gpio_free(struct gpio_chip *gpio, unsigned int offset)\n{\n\tstruct pca9685 *pca = gpiochip_get_data(gpio);\n\n\tpca9685_pwm_set_duty(pca, offset, 0);\n\tpm_runtime_put(pca->chip.dev);\n\tpca9685_pwm_clear_inuse(pca, offset);\n}\n\nstatic int pca9685_pwm_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned int offset)\n{\n\t \n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int pca9685_pwm_gpio_direction_input(struct gpio_chip *gpio,\n\t\t\t\t\t    unsigned int offset)\n{\n\treturn -EINVAL;\n}\n\nstatic int pca9685_pwm_gpio_direction_output(struct gpio_chip *gpio,\n\t\t\t\t\t     unsigned int offset, int value)\n{\n\tpca9685_pwm_gpio_set(gpio, offset, value);\n\n\treturn 0;\n}\n\n \nstatic int pca9685_pwm_gpio_probe(struct pca9685 *pca)\n{\n\tstruct device *dev = pca->chip.dev;\n\n\tpca->gpio.label = dev_name(dev);\n\tpca->gpio.parent = dev;\n\tpca->gpio.request = pca9685_pwm_gpio_request;\n\tpca->gpio.free = pca9685_pwm_gpio_free;\n\tpca->gpio.get_direction = pca9685_pwm_gpio_get_direction;\n\tpca->gpio.direction_input = pca9685_pwm_gpio_direction_input;\n\tpca->gpio.direction_output = pca9685_pwm_gpio_direction_output;\n\tpca->gpio.get = pca9685_pwm_gpio_get;\n\tpca->gpio.set = pca9685_pwm_gpio_set;\n\tpca->gpio.base = -1;\n\tpca->gpio.ngpio = PCA9685_MAXCHAN;\n\tpca->gpio.can_sleep = true;\n\n\treturn devm_gpiochip_add_data(dev, &pca->gpio, pca);\n}\n#else\nstatic inline bool pca9685_pwm_test_and_set_inuse(struct pca9685 *pca,\n\t\t\t\t\t\t  int pwm_idx)\n{\n\treturn false;\n}\n\nstatic inline void\npca9685_pwm_clear_inuse(struct pca9685 *pca, int pwm_idx)\n{\n}\n\nstatic inline int pca9685_pwm_gpio_probe(struct pca9685 *pca)\n{\n\treturn 0;\n}\n#endif\n\nstatic void pca9685_set_sleep_mode(struct pca9685 *pca, bool enable)\n{\n\tstruct device *dev = pca->chip.dev;\n\tint err = regmap_update_bits(pca->regmap, PCA9685_MODE1,\n\t\t\t\t     MODE1_SLEEP, enable ? MODE1_SLEEP : 0);\n\tif (err) {\n\t\tdev_err(dev, \"regmap_update_bits of register 0x%x failed: %pe\\n\",\n\t\t\tPCA9685_MODE1, ERR_PTR(err));\n\t\treturn;\n\t}\n\n\tif (!enable) {\n\t\t \n\t\tudelay(500);\n\t}\n}\n\nstatic int __pca9685_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       const struct pwm_state *state)\n{\n\tstruct pca9685 *pca = to_pca(chip);\n\tunsigned long long duty, prescale;\n\tunsigned int val = 0;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tprescale = DIV_ROUND_CLOSEST_ULL(PCA9685_OSC_CLOCK_MHZ * state->period,\n\t\t\t\t\t PCA9685_COUNTER_RANGE * 1000) - 1;\n\tif (prescale < PCA9685_PRESCALE_MIN || prescale > PCA9685_PRESCALE_MAX) {\n\t\tdev_err(chip->dev, \"pwm not changed: period out of bounds!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!state->enabled) {\n\t\tpca9685_pwm_set_duty(pca, pwm->hwpwm, 0);\n\t\treturn 0;\n\t}\n\n\tpca9685_read_reg(pca, PCA9685_PRESCALE, &val);\n\tif (prescale != val) {\n\t\tif (!pca9685_prescaler_can_change(pca, pwm->hwpwm)) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"pwm not changed: periods of enabled pwms must match!\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\t \n\t\tpca9685_set_sleep_mode(pca, true);\n\n\t\t \n\t\tpca9685_write_reg(pca, PCA9685_PRESCALE, prescale);\n\n\t\t \n\t\tpca9685_set_sleep_mode(pca, false);\n\t}\n\n\tduty = PCA9685_COUNTER_RANGE * state->duty_cycle;\n\tduty = DIV_ROUND_UP_ULL(duty, state->period);\n\tpca9685_pwm_set_duty(pca, pwm->hwpwm, duty);\n\treturn 0;\n}\n\nstatic int pca9685_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tstruct pca9685 *pca = to_pca(chip);\n\tint ret;\n\n\tmutex_lock(&pca->lock);\n\tret = __pca9685_pwm_apply(chip, pwm, state);\n\tif (ret == 0) {\n\t\tif (state->enabled)\n\t\t\tset_bit(pwm->hwpwm, pca->pwms_enabled);\n\t\telse\n\t\t\tclear_bit(pwm->hwpwm, pca->pwms_enabled);\n\t}\n\tmutex_unlock(&pca->lock);\n\n\treturn ret;\n}\n\nstatic int pca9685_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t struct pwm_state *state)\n{\n\tstruct pca9685 *pca = to_pca(chip);\n\tunsigned long long duty;\n\tunsigned int val = 0;\n\n\t \n\tpca9685_read_reg(pca, PCA9685_PRESCALE, &val);\n\t \n\tstate->period = (PCA9685_COUNTER_RANGE * 1000 / PCA9685_OSC_CLOCK_MHZ) *\n\t\t\t(val + 1);\n\n\t \n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\tif (pwm->hwpwm >= PCA9685_MAXCHAN) {\n\t\t \n\t\tstate->duty_cycle = 0;\n\t\tstate->enabled = false;\n\t\treturn 0;\n\t}\n\n\tstate->enabled = true;\n\tduty = pca9685_pwm_get_duty(pca, pwm->hwpwm);\n\tstate->duty_cycle = DIV_ROUND_DOWN_ULL(duty * state->period, PCA9685_COUNTER_RANGE);\n\n\treturn 0;\n}\n\nstatic int pca9685_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct pca9685 *pca = to_pca(chip);\n\n\tif (pca9685_pwm_test_and_set_inuse(pca, pwm->hwpwm))\n\t\treturn -EBUSY;\n\n\tif (pwm->hwpwm < PCA9685_MAXCHAN) {\n\t\t \n\t\tmutex_lock(&pca->lock);\n\t\tset_bit(pwm->hwpwm, pca->pwms_enabled);\n\t\tmutex_unlock(&pca->lock);\n\t}\n\n\tpm_runtime_get_sync(chip->dev);\n\n\treturn 0;\n}\n\nstatic void pca9685_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct pca9685 *pca = to_pca(chip);\n\n\tmutex_lock(&pca->lock);\n\tpca9685_pwm_set_duty(pca, pwm->hwpwm, 0);\n\tclear_bit(pwm->hwpwm, pca->pwms_enabled);\n\tmutex_unlock(&pca->lock);\n\n\tpm_runtime_put(chip->dev);\n\tpca9685_pwm_clear_inuse(pca, pwm->hwpwm);\n}\n\nstatic const struct pwm_ops pca9685_pwm_ops = {\n\t.apply = pca9685_pwm_apply,\n\t.get_state = pca9685_pwm_get_state,\n\t.request = pca9685_pwm_request,\n\t.free = pca9685_pwm_free,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct regmap_config pca9685_regmap_i2c_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = PCA9685_NUMREGS,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int pca9685_pwm_probe(struct i2c_client *client)\n{\n\tstruct pca9685 *pca;\n\tunsigned int reg;\n\tint ret;\n\n\tpca = devm_kzalloc(&client->dev, sizeof(*pca), GFP_KERNEL);\n\tif (!pca)\n\t\treturn -ENOMEM;\n\n\tpca->regmap = devm_regmap_init_i2c(client, &pca9685_regmap_i2c_config);\n\tif (IS_ERR(pca->regmap)) {\n\t\tret = PTR_ERR(pca->regmap);\n\t\tdev_err(&client->dev, \"Failed to initialize register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, pca);\n\n\tmutex_init(&pca->lock);\n\n\tret = pca9685_read_reg(pca, PCA9685_MODE2, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_property_read_bool(&client->dev, \"invert\"))\n\t\treg |= MODE2_INVRT;\n\telse\n\t\treg &= ~MODE2_INVRT;\n\n\tif (device_property_read_bool(&client->dev, \"open-drain\"))\n\t\treg &= ~MODE2_OUTDRV;\n\telse\n\t\treg |= MODE2_OUTDRV;\n\n\tret = pca9685_write_reg(pca, PCA9685_MODE2, reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpca9685_read_reg(pca, PCA9685_MODE1, &reg);\n\treg &= ~(MODE1_ALLCALL | MODE1_SUB1 | MODE1_SUB2 | MODE1_SUB3);\n\tpca9685_write_reg(pca, PCA9685_MODE1, reg);\n\n\t \n\tpca9685_write_reg(pca, PCA9685_ALL_LED_OFF_L, 0);\n\tpca9685_write_reg(pca, PCA9685_ALL_LED_OFF_H, LED_FULL);\n\tpca9685_write_reg(pca, PCA9685_ALL_LED_ON_L, 0);\n\tpca9685_write_reg(pca, PCA9685_ALL_LED_ON_H, LED_FULL);\n\n\tpca->chip.ops = &pca9685_pwm_ops;\n\t \n\tpca->chip.npwm = PCA9685_MAXCHAN + 1;\n\n\tpca->chip.dev = &client->dev;\n\n\tret = pwmchip_add(&pca->chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pca9685_pwm_gpio_probe(pca);\n\tif (ret < 0) {\n\t\tpwmchip_remove(&pca->chip);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&client->dev);\n\n\tif (pm_runtime_enabled(&client->dev)) {\n\t\t \n\t\tpca9685_set_sleep_mode(pca, true);\n\t\tpm_runtime_set_suspended(&client->dev);\n\t} else {\n\t\t \n\t\tpca9685_set_sleep_mode(pca, false);\n\t}\n\n\treturn 0;\n}\n\nstatic void pca9685_pwm_remove(struct i2c_client *client)\n{\n\tstruct pca9685 *pca = i2c_get_clientdata(client);\n\n\tpwmchip_remove(&pca->chip);\n\n\tif (!pm_runtime_enabled(&client->dev)) {\n\t\t \n\t\tpca9685_set_sleep_mode(pca, true);\n\t}\n\n\tpm_runtime_disable(&client->dev);\n}\n\nstatic int __maybe_unused pca9685_pwm_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pca9685 *pca = i2c_get_clientdata(client);\n\n\tpca9685_set_sleep_mode(pca, true);\n\treturn 0;\n}\n\nstatic int __maybe_unused pca9685_pwm_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pca9685 *pca = i2c_get_clientdata(client);\n\n\tpca9685_set_sleep_mode(pca, false);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id pca9685_id[] = {\n\t{ \"pca9685\", 0 },\n\t{   },\n};\nMODULE_DEVICE_TABLE(i2c, pca9685_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id pca9685_acpi_ids[] = {\n\t{ \"INT3492\", 0 },\n\t{   },\n};\nMODULE_DEVICE_TABLE(acpi, pca9685_acpi_ids);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pca9685_dt_ids[] = {\n\t{ .compatible = \"nxp,pca9685-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pca9685_dt_ids);\n#endif\n\nstatic const struct dev_pm_ops pca9685_pwm_pm = {\n\tSET_RUNTIME_PM_OPS(pca9685_pwm_runtime_suspend,\n\t\t\t   pca9685_pwm_runtime_resume, NULL)\n};\n\nstatic struct i2c_driver pca9685_i2c_driver = {\n\t.driver = {\n\t\t.name = \"pca9685-pwm\",\n\t\t.acpi_match_table = ACPI_PTR(pca9685_acpi_ids),\n\t\t.of_match_table = of_match_ptr(pca9685_dt_ids),\n\t\t.pm = &pca9685_pwm_pm,\n\t},\n\t.probe = pca9685_pwm_probe,\n\t.remove = pca9685_pwm_remove,\n\t.id_table = pca9685_id,\n};\n\nmodule_i2c_driver(pca9685_i2c_driver);\n\nMODULE_AUTHOR(\"Steffen Trumtrar <s.trumtrar@pengutronix.de>\");\nMODULE_DESCRIPTION(\"PWM driver for PCA9685\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}