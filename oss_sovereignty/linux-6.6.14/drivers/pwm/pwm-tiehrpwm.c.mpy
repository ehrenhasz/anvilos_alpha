{
  "module_name": "pwm-tiehrpwm.c",
  "hash_id": "132f3db60e9cbeb4db376f10062eca9558548037fbd0f22eeeb5b804a44e788a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-tiehrpwm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n\n \n\n \n#define TBCTL\t\t\t0x00\n#define TBPRD\t\t\t0x0A\n\n#define TBCTL_PRDLD_MASK\tBIT(3)\n#define TBCTL_PRDLD_SHDW\t0\n#define TBCTL_PRDLD_IMDT\tBIT(3)\n#define TBCTL_CLKDIV_MASK\t(BIT(12) | BIT(11) | BIT(10) | BIT(9) | \\\n\t\t\t\tBIT(8) | BIT(7))\n#define TBCTL_CTRMODE_MASK\t(BIT(1) | BIT(0))\n#define TBCTL_CTRMODE_UP\t0\n#define TBCTL_CTRMODE_DOWN\tBIT(0)\n#define TBCTL_CTRMODE_UPDOWN\tBIT(1)\n#define TBCTL_CTRMODE_FREEZE\t(BIT(1) | BIT(0))\n\n#define TBCTL_HSPCLKDIV_SHIFT\t7\n#define TBCTL_CLKDIV_SHIFT\t10\n\n#define CLKDIV_MAX\t\t7\n#define HSPCLKDIV_MAX\t\t7\n#define PERIOD_MAX\t\t0xFFFF\n\n \n#define CMPA\t\t\t0x12\n#define CMPB\t\t\t0x14\n\n \n#define AQCTLA\t\t\t0x16\n#define AQCTLB\t\t\t0x18\n#define AQSFRC\t\t\t0x1A\n#define AQCSFRC\t\t\t0x1C\n\n#define AQCTL_CBU_MASK\t\t(BIT(9) | BIT(8))\n#define AQCTL_CBU_FRCLOW\tBIT(8)\n#define AQCTL_CBU_FRCHIGH\tBIT(9)\n#define AQCTL_CBU_FRCTOGGLE\t(BIT(9) | BIT(8))\n#define AQCTL_CAU_MASK\t\t(BIT(5) | BIT(4))\n#define AQCTL_CAU_FRCLOW\tBIT(4)\n#define AQCTL_CAU_FRCHIGH\tBIT(5)\n#define AQCTL_CAU_FRCTOGGLE\t(BIT(5) | BIT(4))\n#define AQCTL_PRD_MASK\t\t(BIT(3) | BIT(2))\n#define AQCTL_PRD_FRCLOW\tBIT(2)\n#define AQCTL_PRD_FRCHIGH\tBIT(3)\n#define AQCTL_PRD_FRCTOGGLE\t(BIT(3) | BIT(2))\n#define AQCTL_ZRO_MASK\t\t(BIT(1) | BIT(0))\n#define AQCTL_ZRO_FRCLOW\tBIT(0)\n#define AQCTL_ZRO_FRCHIGH\tBIT(1)\n#define AQCTL_ZRO_FRCTOGGLE\t(BIT(1) | BIT(0))\n\n#define AQCTL_CHANA_POLNORMAL\t(AQCTL_CAU_FRCLOW | AQCTL_PRD_FRCHIGH | \\\n\t\t\t\tAQCTL_ZRO_FRCHIGH)\n#define AQCTL_CHANA_POLINVERSED\t(AQCTL_CAU_FRCHIGH | AQCTL_PRD_FRCLOW | \\\n\t\t\t\tAQCTL_ZRO_FRCLOW)\n#define AQCTL_CHANB_POLNORMAL\t(AQCTL_CBU_FRCLOW | AQCTL_PRD_FRCHIGH | \\\n\t\t\t\tAQCTL_ZRO_FRCHIGH)\n#define AQCTL_CHANB_POLINVERSED\t(AQCTL_CBU_FRCHIGH | AQCTL_PRD_FRCLOW | \\\n\t\t\t\tAQCTL_ZRO_FRCLOW)\n\n#define AQSFRC_RLDCSF_MASK\t(BIT(7) | BIT(6))\n#define AQSFRC_RLDCSF_ZRO\t0\n#define AQSFRC_RLDCSF_PRD\tBIT(6)\n#define AQSFRC_RLDCSF_ZROPRD\tBIT(7)\n#define AQSFRC_RLDCSF_IMDT\t(BIT(7) | BIT(6))\n\n#define AQCSFRC_CSFB_MASK\t(BIT(3) | BIT(2))\n#define AQCSFRC_CSFB_FRCDIS\t0\n#define AQCSFRC_CSFB_FRCLOW\tBIT(2)\n#define AQCSFRC_CSFB_FRCHIGH\tBIT(3)\n#define AQCSFRC_CSFB_DISSWFRC\t(BIT(3) | BIT(2))\n#define AQCSFRC_CSFA_MASK\t(BIT(1) | BIT(0))\n#define AQCSFRC_CSFA_FRCDIS\t0\n#define AQCSFRC_CSFA_FRCLOW\tBIT(0)\n#define AQCSFRC_CSFA_FRCHIGH\tBIT(1)\n#define AQCSFRC_CSFA_DISSWFRC\t(BIT(1) | BIT(0))\n\n#define NUM_PWM_CHANNEL\t\t2\t \n\nstruct ehrpwm_context {\n\tu16 tbctl;\n\tu16 tbprd;\n\tu16 cmpa;\n\tu16 cmpb;\n\tu16 aqctla;\n\tu16 aqctlb;\n\tu16 aqsfrc;\n\tu16 aqcsfrc;\n};\n\nstruct ehrpwm_pwm_chip {\n\tstruct pwm_chip chip;\n\tunsigned long clk_rate;\n\tvoid __iomem *mmio_base;\n\tunsigned long period_cycles[NUM_PWM_CHANNEL];\n\tenum pwm_polarity polarity[NUM_PWM_CHANNEL];\n\tstruct clk *tbclk;\n\tstruct ehrpwm_context ctx;\n};\n\nstatic inline struct ehrpwm_pwm_chip *to_ehrpwm_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct ehrpwm_pwm_chip, chip);\n}\n\nstatic inline u16 ehrpwm_read(void __iomem *base, unsigned int offset)\n{\n\treturn readw(base + offset);\n}\n\nstatic inline void ehrpwm_write(void __iomem *base, unsigned int offset,\n\t\t\t\tu16 value)\n{\n\twritew(value, base + offset);\n}\n\nstatic void ehrpwm_modify(void __iomem *base, unsigned int offset, u16 mask,\n\t\t\t  u16 value)\n{\n\tunsigned short val;\n\n\tval = readw(base + offset);\n\tval &= ~mask;\n\tval |= value & mask;\n\twritew(val, base + offset);\n}\n\n \nstatic int set_prescale_div(unsigned long rqst_prescaler, u16 *prescale_div,\n\t\t\t    u16 *tb_clk_div)\n{\n\tunsigned int clkdiv, hspclkdiv;\n\n\tfor (clkdiv = 0; clkdiv <= CLKDIV_MAX; clkdiv++) {\n\t\tfor (hspclkdiv = 0; hspclkdiv <= HSPCLKDIV_MAX; hspclkdiv++) {\n\t\t\t \n\n\t\t\t*prescale_div = (1 << clkdiv) *\n\t\t\t\t\t(hspclkdiv ? (hspclkdiv * 2) : 1);\n\t\t\tif (*prescale_div > rqst_prescaler) {\n\t\t\t\t*tb_clk_div = (clkdiv << TBCTL_CLKDIV_SHIFT) |\n\t\t\t\t\t(hspclkdiv << TBCTL_HSPCLKDIV_SHIFT);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic void configure_polarity(struct ehrpwm_pwm_chip *pc, int chan)\n{\n\tu16 aqctl_val, aqctl_mask;\n\tunsigned int aqctl_reg;\n\n\t \n\tif (chan == 1) {\n\t\taqctl_reg = AQCTLB;\n\t\taqctl_mask = AQCTL_CBU_MASK;\n\n\t\tif (pc->polarity[chan] == PWM_POLARITY_INVERSED)\n\t\t\taqctl_val = AQCTL_CHANB_POLINVERSED;\n\t\telse\n\t\t\taqctl_val = AQCTL_CHANB_POLNORMAL;\n\t} else {\n\t\taqctl_reg = AQCTLA;\n\t\taqctl_mask = AQCTL_CAU_MASK;\n\n\t\tif (pc->polarity[chan] == PWM_POLARITY_INVERSED)\n\t\t\taqctl_val = AQCTL_CHANA_POLINVERSED;\n\t\telse\n\t\t\taqctl_val = AQCTL_CHANA_POLNORMAL;\n\t}\n\n\taqctl_mask |= AQCTL_PRD_MASK | AQCTL_ZRO_MASK;\n\tehrpwm_modify(pc->mmio_base, aqctl_reg, aqctl_mask, aqctl_val);\n}\n\n \nstatic int ehrpwm_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     u64 duty_ns, u64 period_ns)\n{\n\tstruct ehrpwm_pwm_chip *pc = to_ehrpwm_pwm_chip(chip);\n\tu32 period_cycles, duty_cycles;\n\tu16 ps_divval, tb_divval;\n\tunsigned int i, cmp_reg;\n\tunsigned long long c;\n\n\tif (period_ns > NSEC_PER_SEC)\n\t\treturn -ERANGE;\n\n\tc = pc->clk_rate;\n\tc = c * period_ns;\n\tdo_div(c, NSEC_PER_SEC);\n\tperiod_cycles = (unsigned long)c;\n\n\tif (period_cycles < 1) {\n\t\tperiod_cycles = 1;\n\t\tduty_cycles = 1;\n\t} else {\n\t\tc = pc->clk_rate;\n\t\tc = c * duty_ns;\n\t\tdo_div(c, NSEC_PER_SEC);\n\t\tduty_cycles = (unsigned long)c;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_PWM_CHANNEL; i++) {\n\t\tif (pc->period_cycles[i] &&\n\t\t\t\t(pc->period_cycles[i] != period_cycles)) {\n\t\t\t \n\t\t\tif (i == pwm->hwpwm)\n\t\t\t\tcontinue;\n\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"period value conflicts with channel %u\\n\",\n\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpc->period_cycles[pwm->hwpwm] = period_cycles;\n\n\t \n\tif (set_prescale_div(period_cycles/PERIOD_MAX, &ps_divval,\n\t\t\t     &tb_divval)) {\n\t\tdev_err(chip->dev, \"Unsupported values\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(chip->dev);\n\n\t \n\tehrpwm_modify(pc->mmio_base, TBCTL, TBCTL_CLKDIV_MASK, tb_divval);\n\n\t \n\tperiod_cycles = period_cycles / ps_divval;\n\tduty_cycles = duty_cycles / ps_divval;\n\n\t \n\tehrpwm_modify(pc->mmio_base, TBCTL, TBCTL_PRDLD_MASK, TBCTL_PRDLD_SHDW);\n\n\tehrpwm_write(pc->mmio_base, TBPRD, period_cycles);\n\n\t \n\tehrpwm_modify(pc->mmio_base, TBCTL, TBCTL_CTRMODE_MASK,\n\t\t      TBCTL_CTRMODE_UP);\n\n\tif (pwm->hwpwm == 1)\n\t\t \n\t\tcmp_reg = CMPB;\n\telse\n\t\t \n\t\tcmp_reg = CMPA;\n\n\tehrpwm_write(pc->mmio_base, cmp_reg, duty_cycles);\n\n\tpm_runtime_put_sync(chip->dev);\n\n\treturn 0;\n}\n\nstatic int ehrpwm_pwm_set_polarity(struct pwm_chip *chip,\n\t\t\t\t   struct pwm_device *pwm,\n\t\t\t\t   enum pwm_polarity polarity)\n{\n\tstruct ehrpwm_pwm_chip *pc = to_ehrpwm_pwm_chip(chip);\n\n\t \n\tpc->polarity[pwm->hwpwm] = polarity;\n\n\treturn 0;\n}\n\nstatic int ehrpwm_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct ehrpwm_pwm_chip *pc = to_ehrpwm_pwm_chip(chip);\n\tu16 aqcsfrc_val, aqcsfrc_mask;\n\tint ret;\n\n\t \n\tpm_runtime_get_sync(chip->dev);\n\n\t \n\tif (pwm->hwpwm) {\n\t\taqcsfrc_val = AQCSFRC_CSFB_FRCDIS;\n\t\taqcsfrc_mask = AQCSFRC_CSFB_MASK;\n\t} else {\n\t\taqcsfrc_val = AQCSFRC_CSFA_FRCDIS;\n\t\taqcsfrc_mask = AQCSFRC_CSFA_MASK;\n\t}\n\n\t \n\tehrpwm_modify(pc->mmio_base, AQSFRC, AQSFRC_RLDCSF_MASK,\n\t\t      AQSFRC_RLDCSF_ZRO);\n\n\tehrpwm_modify(pc->mmio_base, AQCSFRC, aqcsfrc_mask, aqcsfrc_val);\n\n\t \n\tconfigure_polarity(pc, pwm->hwpwm);\n\n\t \n\tret = clk_enable(pc->tbclk);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to enable TBCLK for %s: %d\\n\",\n\t\t\tdev_name(pc->chip.dev), ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ehrpwm_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct ehrpwm_pwm_chip *pc = to_ehrpwm_pwm_chip(chip);\n\tu16 aqcsfrc_val, aqcsfrc_mask;\n\n\t \n\tif (pwm->hwpwm) {\n\t\taqcsfrc_val = AQCSFRC_CSFB_FRCLOW;\n\t\taqcsfrc_mask = AQCSFRC_CSFB_MASK;\n\t} else {\n\t\taqcsfrc_val = AQCSFRC_CSFA_FRCLOW;\n\t\taqcsfrc_mask = AQCSFRC_CSFA_MASK;\n\t}\n\n\t \n\tehrpwm_modify(pc->mmio_base, AQSFRC, AQSFRC_RLDCSF_MASK,\n\t\t      AQSFRC_RLDCSF_ZRO);\n\tehrpwm_modify(pc->mmio_base, AQCSFRC, aqcsfrc_mask, aqcsfrc_val);\n\t \n\tehrpwm_modify(pc->mmio_base, AQSFRC, AQSFRC_RLDCSF_MASK,\n\t\t      AQSFRC_RLDCSF_IMDT);\n\n\tehrpwm_modify(pc->mmio_base, AQCSFRC, aqcsfrc_mask, aqcsfrc_val);\n\n\t \n\tclk_disable(pc->tbclk);\n\n\t \n\tpm_runtime_put_sync(chip->dev);\n}\n\nstatic void ehrpwm_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct ehrpwm_pwm_chip *pc = to_ehrpwm_pwm_chip(chip);\n\n\tif (pwm_is_enabled(pwm)) {\n\t\tdev_warn(chip->dev, \"Removing PWM device without disabling\\n\");\n\t\tpm_runtime_put_sync(chip->dev);\n\t}\n\n\t \n\tpc->period_cycles[pwm->hwpwm] = 0;\n}\n\nstatic int ehrpwm_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tint err;\n\tbool enabled = pwm->state.enabled;\n\n\tif (state->polarity != pwm->state.polarity) {\n\t\tif (enabled) {\n\t\t\tehrpwm_pwm_disable(chip, pwm);\n\t\t\tenabled = false;\n\t\t}\n\n\t\terr = ehrpwm_pwm_set_polarity(chip, pwm, state->polarity);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\tehrpwm_pwm_disable(chip, pwm);\n\t\treturn 0;\n\t}\n\n\terr = ehrpwm_pwm_config(chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!enabled)\n\t\terr = ehrpwm_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops ehrpwm_pwm_ops = {\n\t.free = ehrpwm_pwm_free,\n\t.apply = ehrpwm_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id ehrpwm_of_match[] = {\n\t{ .compatible = \"ti,am3352-ehrpwm\" },\n\t{ .compatible = \"ti,am33xx-ehrpwm\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ehrpwm_of_match);\n\nstatic int ehrpwm_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct ehrpwm_pwm_chip *pc;\n\tstruct clk *clk;\n\tint ret;\n\n\tpc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tclk = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(clk)) {\n\t\tif (of_device_is_compatible(np, \"ti,am33xx-ecap\")) {\n\t\t\tdev_warn(&pdev->dev, \"Binding is obsolete.\\n\");\n\t\t\tclk = devm_clk_get(pdev->dev.parent, \"fck\");\n\t\t}\n\t}\n\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(clk), \"Failed to get fck\\n\");\n\n\tpc->clk_rate = clk_get_rate(clk);\n\tif (!pc->clk_rate) {\n\t\tdev_err(&pdev->dev, \"failed to get clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpc->chip.dev = &pdev->dev;\n\tpc->chip.ops = &ehrpwm_pwm_ops;\n\tpc->chip.npwm = NUM_PWM_CHANNEL;\n\n\tpc->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->mmio_base))\n\t\treturn PTR_ERR(pc->mmio_base);\n\n\t \n\tpc->tbclk = devm_clk_get(&pdev->dev, \"tbclk\");\n\tif (IS_ERR(pc->tbclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(pc->tbclk), \"Failed to get tbclk\\n\");\n\n\tret = clk_prepare(pc->tbclk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"clk_prepare() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pwmchip_add(&pc->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pwmchip_add() failed: %d\\n\", ret);\n\t\tgoto err_clk_unprepare;\n\t}\n\n\tplatform_set_drvdata(pdev, pc);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n\nerr_clk_unprepare:\n\tclk_unprepare(pc->tbclk);\n\n\treturn ret;\n}\n\nstatic void ehrpwm_pwm_remove(struct platform_device *pdev)\n{\n\tstruct ehrpwm_pwm_chip *pc = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&pc->chip);\n\n\tclk_unprepare(pc->tbclk);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void ehrpwm_pwm_save_context(struct ehrpwm_pwm_chip *pc)\n{\n\tpm_runtime_get_sync(pc->chip.dev);\n\n\tpc->ctx.tbctl = ehrpwm_read(pc->mmio_base, TBCTL);\n\tpc->ctx.tbprd = ehrpwm_read(pc->mmio_base, TBPRD);\n\tpc->ctx.cmpa = ehrpwm_read(pc->mmio_base, CMPA);\n\tpc->ctx.cmpb = ehrpwm_read(pc->mmio_base, CMPB);\n\tpc->ctx.aqctla = ehrpwm_read(pc->mmio_base, AQCTLA);\n\tpc->ctx.aqctlb = ehrpwm_read(pc->mmio_base, AQCTLB);\n\tpc->ctx.aqsfrc = ehrpwm_read(pc->mmio_base, AQSFRC);\n\tpc->ctx.aqcsfrc = ehrpwm_read(pc->mmio_base, AQCSFRC);\n\n\tpm_runtime_put_sync(pc->chip.dev);\n}\n\nstatic void ehrpwm_pwm_restore_context(struct ehrpwm_pwm_chip *pc)\n{\n\tehrpwm_write(pc->mmio_base, TBPRD, pc->ctx.tbprd);\n\tehrpwm_write(pc->mmio_base, CMPA, pc->ctx.cmpa);\n\tehrpwm_write(pc->mmio_base, CMPB, pc->ctx.cmpb);\n\tehrpwm_write(pc->mmio_base, AQCTLA, pc->ctx.aqctla);\n\tehrpwm_write(pc->mmio_base, AQCTLB, pc->ctx.aqctlb);\n\tehrpwm_write(pc->mmio_base, AQSFRC, pc->ctx.aqsfrc);\n\tehrpwm_write(pc->mmio_base, AQCSFRC, pc->ctx.aqcsfrc);\n\tehrpwm_write(pc->mmio_base, TBCTL, pc->ctx.tbctl);\n}\n\nstatic int ehrpwm_pwm_suspend(struct device *dev)\n{\n\tstruct ehrpwm_pwm_chip *pc = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tehrpwm_pwm_save_context(pc);\n\n\tfor (i = 0; i < pc->chip.npwm; i++) {\n\t\tstruct pwm_device *pwm = &pc->chip.pwms[i];\n\n\t\tif (!pwm_is_enabled(pwm))\n\t\t\tcontinue;\n\n\t\t \n\t\tpm_runtime_put_sync(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int ehrpwm_pwm_resume(struct device *dev)\n{\n\tstruct ehrpwm_pwm_chip *pc = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < pc->chip.npwm; i++) {\n\t\tstruct pwm_device *pwm = &pc->chip.pwms[i];\n\n\t\tif (!pwm_is_enabled(pwm))\n\t\t\tcontinue;\n\n\t\t \n\t\tpm_runtime_get_sync(dev);\n\t}\n\n\tehrpwm_pwm_restore_context(pc);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ehrpwm_pwm_pm_ops, ehrpwm_pwm_suspend,\n\t\t\t ehrpwm_pwm_resume);\n\nstatic struct platform_driver ehrpwm_pwm_driver = {\n\t.driver = {\n\t\t.name = \"ehrpwm\",\n\t\t.of_match_table = ehrpwm_of_match,\n\t\t.pm = &ehrpwm_pwm_pm_ops,\n\t},\n\t.probe = ehrpwm_pwm_probe,\n\t.remove_new = ehrpwm_pwm_remove,\n};\nmodule_platform_driver(ehrpwm_pwm_driver);\n\nMODULE_DESCRIPTION(\"EHRPWM PWM driver\");\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}