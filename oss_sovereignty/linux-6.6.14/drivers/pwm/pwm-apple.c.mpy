{
  "module_name": "pwm-apple.c",
  "hash_id": "4e3d7882e6a77bc40d165af4cf1a25e204fdc9ec1ea2110dbb991a87303550cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-apple.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/math64.h>\n\n#define APPLE_PWM_CTRL        0x00\n#define APPLE_PWM_ON_CYCLES   0x1c\n#define APPLE_PWM_OFF_CYCLES  0x18\n\n#define APPLE_PWM_CTRL_ENABLE        BIT(0)\n#define APPLE_PWM_CTRL_MODE          BIT(2)\n#define APPLE_PWM_CTRL_UPDATE        BIT(5)\n#define APPLE_PWM_CTRL_TRIGGER       BIT(9)\n#define APPLE_PWM_CTRL_INVERT        BIT(10)\n#define APPLE_PWM_CTRL_OUTPUT_ENABLE BIT(14)\n\nstruct apple_pwm {\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n\tu64 clkrate;\n};\n\nstatic inline struct apple_pwm *to_apple_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct apple_pwm, chip);\n}\n\nstatic int apple_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tstruct apple_pwm *fpwm;\n\n\tif (state->polarity == PWM_POLARITY_INVERSED)\n\t\treturn -EINVAL;\n\n\tfpwm = to_apple_pwm(chip);\n\tif (state->enabled) {\n\t\tu64 on_cycles, off_cycles;\n\n\t\ton_cycles = mul_u64_u64_div_u64(fpwm->clkrate,\n\t\t\t\t\t\tstate->duty_cycle, NSEC_PER_SEC);\n\t\tif (on_cycles > 0xFFFFFFFF)\n\t\t\ton_cycles = 0xFFFFFFFF;\n\n\t\toff_cycles = mul_u64_u64_div_u64(fpwm->clkrate,\n\t\t\t\t\t\t state->period, NSEC_PER_SEC) - on_cycles;\n\t\tif (off_cycles > 0xFFFFFFFF)\n\t\t\toff_cycles = 0xFFFFFFFF;\n\n\t\twritel(on_cycles, fpwm->base + APPLE_PWM_ON_CYCLES);\n\t\twritel(off_cycles, fpwm->base + APPLE_PWM_OFF_CYCLES);\n\t\twritel(APPLE_PWM_CTRL_ENABLE | APPLE_PWM_CTRL_OUTPUT_ENABLE | APPLE_PWM_CTRL_UPDATE,\n\t\t       fpwm->base + APPLE_PWM_CTRL);\n\t} else {\n\t\twritel(0, fpwm->base + APPLE_PWM_CTRL);\n\t}\n\treturn 0;\n}\n\nstatic int apple_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   struct pwm_state *state)\n{\n\tstruct apple_pwm *fpwm;\n\tu32 on_cycles, off_cycles, ctrl;\n\n\tfpwm = to_apple_pwm(chip);\n\n\tctrl = readl(fpwm->base + APPLE_PWM_CTRL);\n\ton_cycles = readl(fpwm->base + APPLE_PWM_ON_CYCLES);\n\toff_cycles = readl(fpwm->base + APPLE_PWM_OFF_CYCLES);\n\n\tstate->enabled = (ctrl & APPLE_PWM_CTRL_ENABLE) && (ctrl & APPLE_PWM_CTRL_OUTPUT_ENABLE);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\t\n\tstate->duty_cycle = DIV64_U64_ROUND_UP((u64)on_cycles * NSEC_PER_SEC, fpwm->clkrate);\n\tstate->period = DIV64_U64_ROUND_UP(((u64)off_cycles + (u64)on_cycles) *\n\t\t\t\t\t    NSEC_PER_SEC, fpwm->clkrate);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops apple_pwm_ops = {\n\t.apply = apple_pwm_apply,\n\t.get_state = apple_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic int apple_pwm_probe(struct platform_device *pdev)\n{\n\tstruct apple_pwm *fpwm;\n\tstruct clk *clk;\n\tint ret;\n\n\tfpwm = devm_kzalloc(&pdev->dev, sizeof(*fpwm), GFP_KERNEL);\n\tif (!fpwm)\n\t\treturn -ENOMEM;\n\n\tfpwm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fpwm->base))\n\t\treturn PTR_ERR(fpwm->base);\n\n\tclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(clk), \"unable to get the clock\");\n\n\t \n\tfpwm->clkrate = clk_get_rate(clk);\n\tif (fpwm->clkrate > NSEC_PER_SEC)\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL, \"pwm clock out of range\");\n\n\tfpwm->chip.dev = &pdev->dev;\n\tfpwm->chip.npwm = 1;\n\tfpwm->chip.ops = &apple_pwm_ops;\n\n\tret = devm_pwmchip_add(&pdev->dev, &fpwm->chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"unable to add pwm chip\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id apple_pwm_of_match[] = {\n\t{ .compatible = \"apple,s5l-fpwm\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, apple_pwm_of_match);\n\nstatic struct platform_driver apple_pwm_driver = {\n\t.probe = apple_pwm_probe,\n\t.driver = {\n\t\t.name = \"apple-pwm\",\n\t\t.of_match_table = apple_pwm_of_match,\n\t},\n};\nmodule_platform_driver(apple_pwm_driver);\n\nMODULE_DESCRIPTION(\"Apple SoC PWM driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}