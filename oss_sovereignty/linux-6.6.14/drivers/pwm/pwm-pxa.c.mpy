{
  "module_name": "pwm-pxa.c",
  "hash_id": "e6246f1aa8d52f2128b66ad5d55c6eaebde19c30809a9a77cb67bf69bdcd35a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-pxa.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/pwm.h>\n#include <linux/of_device.h>\n\n#include <asm/div64.h>\n\n#define HAS_SECONDARY_PWM\t0x10\n\nstatic const struct platform_device_id pwm_id_table[] = {\n\t \n\t{ \"pxa25x-pwm\", 0 },\n\t{ \"pxa27x-pwm\", HAS_SECONDARY_PWM },\n\t{ \"pxa168-pwm\", 0 },\n\t{ \"pxa910-pwm\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, pwm_id_table);\n\n \n#define PWMCR\t\t(0x00)\n#define PWMDCR\t\t(0x04)\n#define PWMPCR\t\t(0x08)\n\n#define PWMCR_SD\t(1 << 6)\n#define PWMDCR_FD\t(1 << 10)\n\nstruct pxa_pwm_chip {\n\tstruct pwm_chip\tchip;\n\tstruct device\t*dev;\n\n\tstruct clk\t*clk;\n\tvoid __iomem\t*mmio_base;\n};\n\nstatic inline struct pxa_pwm_chip *to_pxa_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct pxa_pwm_chip, chip);\n}\n\n \nstatic int pxa_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  u64 duty_ns, u64 period_ns)\n{\n\tstruct pxa_pwm_chip *pc = to_pxa_pwm_chip(chip);\n\tunsigned long long c;\n\tunsigned long period_cycles, prescale, pv, dc;\n\tunsigned long offset;\n\n\toffset = pwm->hwpwm ? 0x10 : 0;\n\n\tc = clk_get_rate(pc->clk);\n\tc = c * period_ns;\n\tdo_div(c, 1000000000);\n\tperiod_cycles = c;\n\n\tif (period_cycles < 1)\n\t\tperiod_cycles = 1;\n\tprescale = (period_cycles - 1) / 1024;\n\tpv = period_cycles / (prescale + 1) - 1;\n\n\tif (prescale > 63)\n\t\treturn -EINVAL;\n\n\tif (duty_ns == period_ns)\n\t\tdc = PWMDCR_FD;\n\telse\n\t\tdc = mul_u64_u64_div_u64(pv + 1, duty_ns, period_ns);\n\n\twritel(prescale | PWMCR_SD, pc->mmio_base + offset + PWMCR);\n\twritel(dc, pc->mmio_base + offset + PWMDCR);\n\twritel(pv, pc->mmio_base + offset + PWMPCR);\n\n\treturn 0;\n}\n\nstatic int pxa_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tstruct pxa_pwm_chip *pc = to_pxa_pwm_chip(chip);\n\tu64 duty_cycle;\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\terr = clk_prepare_enable(pc->clk);\n\tif (err)\n\t\treturn err;\n\n\tduty_cycle = state->enabled ? state->duty_cycle : 0;\n\n\terr = pxa_pwm_config(chip, pwm, duty_cycle, state->period);\n\tif (err) {\n\t\tclk_disable_unprepare(pc->clk);\n\t\treturn err;\n\t}\n\n\tif (state->enabled && !pwm->state.enabled)\n\t\treturn 0;\n\n\tclk_disable_unprepare(pc->clk);\n\n\tif (!state->enabled && pwm->state.enabled)\n\t\tclk_disable_unprepare(pc->clk);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops pxa_pwm_ops = {\n\t.apply = pxa_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\n#ifdef CONFIG_OF\n \nstatic const struct of_device_id pwm_of_match[] = {\n\t{ .compatible = \"marvell,pxa250-pwm\", .data = &pwm_id_table[0]},\n\t{ .compatible = \"marvell,pxa270-pwm\", .data = &pwm_id_table[0]},\n\t{ .compatible = \"marvell,pxa168-pwm\", .data = &pwm_id_table[0]},\n\t{ .compatible = \"marvell,pxa910-pwm\", .data = &pwm_id_table[0]},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pwm_of_match);\n#else\n#define pwm_of_match NULL\n#endif\n\nstatic int pwm_probe(struct platform_device *pdev)\n{\n\tconst struct platform_device_id *id = platform_get_device_id(pdev);\n\tstruct pxa_pwm_chip *pc;\n\tint ret = 0;\n\n\tif (IS_ENABLED(CONFIG_OF) && id == NULL)\n\t\tid = of_device_get_match_data(&pdev->dev);\n\n\tif (id == NULL)\n\t\treturn -EINVAL;\n\n\tpc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\n\tif (pc == NULL)\n\t\treturn -ENOMEM;\n\n\tpc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pc->clk))\n\t\treturn PTR_ERR(pc->clk);\n\n\tpc->chip.dev = &pdev->dev;\n\tpc->chip.ops = &pxa_pwm_ops;\n\tpc->chip.npwm = (id->driver_data & HAS_SECONDARY_PWM) ? 2 : 1;\n\n\tif (IS_ENABLED(CONFIG_OF)) {\n\t\tpc->chip.of_xlate = of_pwm_single_xlate;\n\t\tpc->chip.of_pwm_n_cells = 1;\n\t}\n\n\tpc->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->mmio_base))\n\t\treturn PTR_ERR(pc->mmio_base);\n\n\tret = devm_pwmchip_add(&pdev->dev, &pc->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pwmchip_add() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver pwm_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"pxa25x-pwm\",\n\t\t.of_match_table = pwm_of_match,\n\t},\n\t.probe\t\t= pwm_probe,\n\t.id_table\t= pwm_id_table,\n};\n\nmodule_platform_driver(pwm_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}