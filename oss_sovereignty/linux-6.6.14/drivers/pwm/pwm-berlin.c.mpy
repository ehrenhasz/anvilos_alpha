{
  "module_name": "pwm-berlin.c",
  "hash_id": "bab561cf286c25095f190dffdd4333d52820bb81865f6da4686d03307230d115",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-berlin.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n#define BERLIN_PWM_EN\t\t\t0x0\n#define  BERLIN_PWM_ENABLE\t\tBIT(0)\n#define BERLIN_PWM_CONTROL\t\t0x4\n \n#define  BERLIN_PWM_PRESCALE_4096\t0x7\n#define  BERLIN_PWM_INVERT_POLARITY\tBIT(3)\n#define BERLIN_PWM_DUTY\t\t\t0x8\n#define BERLIN_PWM_TCNT\t\t\t0xc\n#define  BERLIN_PWM_MAX_TCNT\t\t65535\n\nstruct berlin_pwm_channel {\n\tu32 enable;\n\tu32 ctrl;\n\tu32 duty;\n\tu32 tcnt;\n};\n\nstruct berlin_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n};\n\nstatic inline struct berlin_pwm_chip *to_berlin_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct berlin_pwm_chip, chip);\n}\n\nstatic inline u32 berlin_pwm_readl(struct berlin_pwm_chip *bpc,\n\t\t\t\t   unsigned int channel, unsigned long offset)\n{\n\treturn readl_relaxed(bpc->base + channel * 0x10 + offset);\n}\n\nstatic inline void berlin_pwm_writel(struct berlin_pwm_chip *bpc,\n\t\t\t\t     unsigned int channel, u32 value,\n\t\t\t\t     unsigned long offset)\n{\n\twritel_relaxed(value, bpc->base + channel * 0x10 + offset);\n}\n\nstatic int berlin_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct berlin_pwm_channel *channel;\n\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn -ENOMEM;\n\n\treturn pwm_set_chip_data(pwm, channel);\n}\n\nstatic void berlin_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct berlin_pwm_channel *channel = pwm_get_chip_data(pwm);\n\n\tkfree(channel);\n}\n\nstatic int berlin_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     u64 duty_ns, u64 period_ns)\n{\n\tstruct berlin_pwm_chip *bpc = to_berlin_pwm_chip(chip);\n\tbool prescale_4096 = false;\n\tu32 value, duty, period;\n\tu64 cycles;\n\n\tcycles = clk_get_rate(bpc->clk);\n\tcycles *= period_ns;\n\tdo_div(cycles, NSEC_PER_SEC);\n\n\tif (cycles > BERLIN_PWM_MAX_TCNT) {\n\t\tprescale_4096 = true;\n\t\tcycles >>= 12; \n\n\t\tif (cycles > BERLIN_PWM_MAX_TCNT)\n\t\t\treturn -ERANGE;\n\t}\n\n\tperiod = cycles;\n\tcycles *= duty_ns;\n\tdo_div(cycles, period_ns);\n\tduty = cycles;\n\n\tvalue = berlin_pwm_readl(bpc, pwm->hwpwm, BERLIN_PWM_CONTROL);\n\tif (prescale_4096)\n\t\tvalue |= BERLIN_PWM_PRESCALE_4096;\n\telse\n\t\tvalue &= ~BERLIN_PWM_PRESCALE_4096;\n\tberlin_pwm_writel(bpc, pwm->hwpwm, value, BERLIN_PWM_CONTROL);\n\n\tberlin_pwm_writel(bpc, pwm->hwpwm, duty, BERLIN_PWM_DUTY);\n\tberlin_pwm_writel(bpc, pwm->hwpwm, period, BERLIN_PWM_TCNT);\n\n\treturn 0;\n}\n\nstatic int berlin_pwm_set_polarity(struct pwm_chip *chip,\n\t\t\t\t   struct pwm_device *pwm,\n\t\t\t\t   enum pwm_polarity polarity)\n{\n\tstruct berlin_pwm_chip *bpc = to_berlin_pwm_chip(chip);\n\tu32 value;\n\n\tvalue = berlin_pwm_readl(bpc, pwm->hwpwm, BERLIN_PWM_CONTROL);\n\n\tif (polarity == PWM_POLARITY_NORMAL)\n\t\tvalue &= ~BERLIN_PWM_INVERT_POLARITY;\n\telse\n\t\tvalue |= BERLIN_PWM_INVERT_POLARITY;\n\n\tberlin_pwm_writel(bpc, pwm->hwpwm, value, BERLIN_PWM_CONTROL);\n\n\treturn 0;\n}\n\nstatic int berlin_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct berlin_pwm_chip *bpc = to_berlin_pwm_chip(chip);\n\tu32 value;\n\n\tvalue = berlin_pwm_readl(bpc, pwm->hwpwm, BERLIN_PWM_EN);\n\tvalue |= BERLIN_PWM_ENABLE;\n\tberlin_pwm_writel(bpc, pwm->hwpwm, value, BERLIN_PWM_EN);\n\n\treturn 0;\n}\n\nstatic void berlin_pwm_disable(struct pwm_chip *chip,\n\t\t\t       struct pwm_device *pwm)\n{\n\tstruct berlin_pwm_chip *bpc = to_berlin_pwm_chip(chip);\n\tu32 value;\n\n\tvalue = berlin_pwm_readl(bpc, pwm->hwpwm, BERLIN_PWM_EN);\n\tvalue &= ~BERLIN_PWM_ENABLE;\n\tberlin_pwm_writel(bpc, pwm->hwpwm, value, BERLIN_PWM_EN);\n}\n\nstatic int berlin_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tint err;\n\tbool enabled = pwm->state.enabled;\n\n\tif (state->polarity != pwm->state.polarity) {\n\t\tif (enabled) {\n\t\t\tberlin_pwm_disable(chip, pwm);\n\t\t\tenabled = false;\n\t\t}\n\n\t\terr = berlin_pwm_set_polarity(chip, pwm, state->polarity);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\tberlin_pwm_disable(chip, pwm);\n\t\treturn 0;\n\t}\n\n\terr = berlin_pwm_config(chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!enabled)\n\t\treturn berlin_pwm_enable(chip, pwm);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops berlin_pwm_ops = {\n\t.request = berlin_pwm_request,\n\t.free = berlin_pwm_free,\n\t.apply = berlin_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id berlin_pwm_match[] = {\n\t{ .compatible = \"marvell,berlin-pwm\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, berlin_pwm_match);\n\nstatic int berlin_pwm_probe(struct platform_device *pdev)\n{\n\tstruct berlin_pwm_chip *bpc;\n\tint ret;\n\n\tbpc = devm_kzalloc(&pdev->dev, sizeof(*bpc), GFP_KERNEL);\n\tif (!bpc)\n\t\treturn -ENOMEM;\n\n\tbpc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bpc->base))\n\t\treturn PTR_ERR(bpc->base);\n\n\tbpc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(bpc->clk))\n\t\treturn PTR_ERR(bpc->clk);\n\n\tret = clk_prepare_enable(bpc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tbpc->chip.dev = &pdev->dev;\n\tbpc->chip.ops = &berlin_pwm_ops;\n\tbpc->chip.npwm = 4;\n\n\tret = pwmchip_add(&bpc->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip: %d\\n\", ret);\n\t\tclk_disable_unprepare(bpc->clk);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, bpc);\n\n\treturn 0;\n}\n\nstatic void berlin_pwm_remove(struct platform_device *pdev)\n{\n\tstruct berlin_pwm_chip *bpc = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&bpc->chip);\n\n\tclk_disable_unprepare(bpc->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int berlin_pwm_suspend(struct device *dev)\n{\n\tstruct berlin_pwm_chip *bpc = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < bpc->chip.npwm; i++) {\n\t\tstruct berlin_pwm_channel *channel;\n\n\t\tchannel = pwm_get_chip_data(&bpc->chip.pwms[i]);\n\t\tif (!channel)\n\t\t\tcontinue;\n\n\t\tchannel->enable = berlin_pwm_readl(bpc, i, BERLIN_PWM_ENABLE);\n\t\tchannel->ctrl = berlin_pwm_readl(bpc, i, BERLIN_PWM_CONTROL);\n\t\tchannel->duty = berlin_pwm_readl(bpc, i, BERLIN_PWM_DUTY);\n\t\tchannel->tcnt = berlin_pwm_readl(bpc, i, BERLIN_PWM_TCNT);\n\t}\n\n\tclk_disable_unprepare(bpc->clk);\n\n\treturn 0;\n}\n\nstatic int berlin_pwm_resume(struct device *dev)\n{\n\tstruct berlin_pwm_chip *bpc = dev_get_drvdata(dev);\n\tunsigned int i;\n\tint ret;\n\n\tret = clk_prepare_enable(bpc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < bpc->chip.npwm; i++) {\n\t\tstruct berlin_pwm_channel *channel;\n\n\t\tchannel = pwm_get_chip_data(&bpc->chip.pwms[i]);\n\t\tif (!channel)\n\t\t\tcontinue;\n\n\t\tberlin_pwm_writel(bpc, i, channel->ctrl, BERLIN_PWM_CONTROL);\n\t\tberlin_pwm_writel(bpc, i, channel->duty, BERLIN_PWM_DUTY);\n\t\tberlin_pwm_writel(bpc, i, channel->tcnt, BERLIN_PWM_TCNT);\n\t\tberlin_pwm_writel(bpc, i, channel->enable, BERLIN_PWM_ENABLE);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(berlin_pwm_pm_ops, berlin_pwm_suspend,\n\t\t\t berlin_pwm_resume);\n\nstatic struct platform_driver berlin_pwm_driver = {\n\t.probe = berlin_pwm_probe,\n\t.remove_new = berlin_pwm_remove,\n\t.driver = {\n\t\t.name = \"berlin-pwm\",\n\t\t.of_match_table = berlin_pwm_match,\n\t\t.pm = &berlin_pwm_pm_ops,\n\t},\n};\nmodule_platform_driver(berlin_pwm_driver);\n\nMODULE_AUTHOR(\"Antoine Tenart <antoine.tenart@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Marvell Berlin PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}