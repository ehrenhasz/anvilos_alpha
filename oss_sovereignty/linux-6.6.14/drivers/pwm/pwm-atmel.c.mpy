{
  "module_name": "pwm-atmel.c",
  "hash_id": "8dcd7ef2e9abce99725d41643493089e50a284e0d485512886fa518e9d7ffbde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-atmel.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n \n#define PWM_ENA\t\t\t0x04\n#define PWM_DIS\t\t\t0x08\n#define PWM_SR\t\t\t0x0C\n#define PWM_ISR\t\t\t0x1C\n \n#define PWM_SR_ALL_CH_MASK\t0x0F\n\n \n#define PWM_CH_REG_OFFSET\t0x200\n#define PWM_CH_REG_SIZE\t\t0x20\n\n#define PWM_CMR\t\t\t0x0\n \n#define PWM_CMR_CPOL\t\t(1 << 9)\n#define PWM_CMR_UPD_CDTY\t(1 << 10)\n#define PWM_CMR_CPRE_MSK\t0xF\n\n \n#define PWMV1_CDTY\t\t0x04\n#define PWMV1_CPRD\t\t0x08\n#define PWMV1_CUPD\t\t0x10\n\n \n#define PWMV2_CDTY\t\t0x04\n#define PWMV2_CDTYUPD\t\t0x08\n#define PWMV2_CPRD\t\t0x0C\n#define PWMV2_CPRDUPD\t\t0x10\n\n#define PWM_MAX_PRES\t\t10\n\nstruct atmel_pwm_registers {\n\tu8 period;\n\tu8 period_upd;\n\tu8 duty;\n\tu8 duty_upd;\n};\n\nstruct atmel_pwm_config {\n\tu32 period_bits;\n};\n\nstruct atmel_pwm_data {\n\tstruct atmel_pwm_registers regs;\n\tstruct atmel_pwm_config cfg;\n};\n\nstruct atmel_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tconst struct atmel_pwm_data *data;\n\n\t \n\tu32 update_pending;\n\n\t \n\tspinlock_t lock;\n};\n\nstatic inline struct atmel_pwm_chip *to_atmel_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct atmel_pwm_chip, chip);\n}\n\nstatic inline u32 atmel_pwm_readl(struct atmel_pwm_chip *chip,\n\t\t\t\t  unsigned long offset)\n{\n\treturn readl_relaxed(chip->base + offset);\n}\n\nstatic inline void atmel_pwm_writel(struct atmel_pwm_chip *chip,\n\t\t\t\t    unsigned long offset, unsigned long val)\n{\n\twritel_relaxed(val, chip->base + offset);\n}\n\nstatic inline u32 atmel_pwm_ch_readl(struct atmel_pwm_chip *chip,\n\t\t\t\t     unsigned int ch, unsigned long offset)\n{\n\tunsigned long base = PWM_CH_REG_OFFSET + ch * PWM_CH_REG_SIZE;\n\n\treturn atmel_pwm_readl(chip, base + offset);\n}\n\nstatic inline void atmel_pwm_ch_writel(struct atmel_pwm_chip *chip,\n\t\t\t\t       unsigned int ch, unsigned long offset,\n\t\t\t\t       unsigned long val)\n{\n\tunsigned long base = PWM_CH_REG_OFFSET + ch * PWM_CH_REG_SIZE;\n\n\tatmel_pwm_writel(chip, base + offset, val);\n}\n\nstatic void atmel_pwm_update_pending(struct atmel_pwm_chip *chip)\n{\n\t \n\tu32 isr = atmel_pwm_readl(chip, PWM_ISR);\n\n\tchip->update_pending &= ~isr;\n}\n\nstatic void atmel_pwm_set_pending(struct atmel_pwm_chip *chip, unsigned int ch)\n{\n\tspin_lock(&chip->lock);\n\n\t \n\tatmel_pwm_update_pending(chip);\n\n\tchip->update_pending |= (1 << ch);\n\n\tspin_unlock(&chip->lock);\n}\n\nstatic int atmel_pwm_test_pending(struct atmel_pwm_chip *chip, unsigned int ch)\n{\n\tint ret = 0;\n\n\tspin_lock(&chip->lock);\n\n\tif (chip->update_pending & (1 << ch)) {\n\t\tatmel_pwm_update_pending(chip);\n\n\t\tif (chip->update_pending & (1 << ch))\n\t\t\tret = 1;\n\t}\n\n\tspin_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int atmel_pwm_wait_nonpending(struct atmel_pwm_chip *chip, unsigned int ch)\n{\n\tunsigned long timeout = jiffies + 2 * HZ;\n\tint ret;\n\n\twhile ((ret = atmel_pwm_test_pending(chip, ch)) &&\n\t       time_before(jiffies, timeout))\n\t\tusleep_range(10, 100);\n\n\treturn ret ? -ETIMEDOUT : 0;\n}\n\nstatic int atmel_pwm_calculate_cprd_and_pres(struct pwm_chip *chip,\n\t\t\t\t\t     unsigned long clkrate,\n\t\t\t\t\t     const struct pwm_state *state,\n\t\t\t\t\t     unsigned long *cprd, u32 *pres)\n{\n\tstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\n\tunsigned long long cycles = state->period;\n\tint shift;\n\n\t \n\tcycles *= clkrate;\n\tdo_div(cycles, NSEC_PER_SEC);\n\n\t \n\tshift = fls(cycles) - atmel_pwm->data->cfg.period_bits;\n\n\tif (shift > PWM_MAX_PRES) {\n\t\tdev_err(chip->dev, \"pres exceeds the maximum value\\n\");\n\t\treturn -EINVAL;\n\t} else if (shift > 0) {\n\t\t*pres = shift;\n\t\tcycles >>= *pres;\n\t} else {\n\t\t*pres = 0;\n\t}\n\n\t*cprd = cycles;\n\n\treturn 0;\n}\n\nstatic void atmel_pwm_calculate_cdty(const struct pwm_state *state,\n\t\t\t\t     unsigned long clkrate, unsigned long cprd,\n\t\t\t\t     u32 pres, unsigned long *cdty)\n{\n\tunsigned long long cycles = state->duty_cycle;\n\n\tcycles *= clkrate;\n\tdo_div(cycles, NSEC_PER_SEC);\n\tcycles >>= pres;\n\t*cdty = cprd - cycles;\n}\n\nstatic void atmel_pwm_update_cdty(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t  unsigned long cdty)\n{\n\tstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\n\tu32 val;\n\n\tif (atmel_pwm->data->regs.duty_upd ==\n\t    atmel_pwm->data->regs.period_upd) {\n\t\tval = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\n\t\tval &= ~PWM_CMR_UPD_CDTY;\n\t\tatmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWM_CMR, val);\n\t}\n\n\tatmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm,\n\t\t\t    atmel_pwm->data->regs.duty_upd, cdty);\n\tatmel_pwm_set_pending(atmel_pwm, pwm->hwpwm);\n}\n\nstatic void atmel_pwm_set_cprd_cdty(struct pwm_chip *chip,\n\t\t\t\t    struct pwm_device *pwm,\n\t\t\t\t    unsigned long cprd, unsigned long cdty)\n{\n\tstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\n\n\tatmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm,\n\t\t\t    atmel_pwm->data->regs.duty, cdty);\n\tatmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm,\n\t\t\t    atmel_pwm->data->regs.period, cprd);\n}\n\nstatic void atmel_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      bool disable_clk)\n{\n\tstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\n\tunsigned long timeout;\n\n\tatmel_pwm_wait_nonpending(atmel_pwm, pwm->hwpwm);\n\n\tatmel_pwm_writel(atmel_pwm, PWM_DIS, 1 << pwm->hwpwm);\n\n\t \n\ttimeout = jiffies + 2 * HZ;\n\n\twhile ((atmel_pwm_readl(atmel_pwm, PWM_SR) & (1 << pwm->hwpwm)) &&\n\t       time_before(jiffies, timeout))\n\t\tusleep_range(10, 100);\n\n\tif (disable_clk)\n\t\tclk_disable(atmel_pwm->clk);\n}\n\nstatic int atmel_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\n\tstruct pwm_state cstate;\n\tunsigned long cprd, cdty;\n\tu32 pres, val;\n\tint ret;\n\n\tpwm_get_state(pwm, &cstate);\n\n\tif (state->enabled) {\n\t\tunsigned long clkrate = clk_get_rate(atmel_pwm->clk);\n\n\t\tif (cstate.enabled &&\n\t\t    cstate.polarity == state->polarity &&\n\t\t    cstate.period == state->period) {\n\t\t\tu32 cmr = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\n\n\t\t\tcprd = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm,\n\t\t\t\t\t\t  atmel_pwm->data->regs.period);\n\t\t\tpres = cmr & PWM_CMR_CPRE_MSK;\n\n\t\t\tatmel_pwm_calculate_cdty(state, clkrate, cprd, pres, &cdty);\n\t\t\tatmel_pwm_update_cdty(chip, pwm, cdty);\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = atmel_pwm_calculate_cprd_and_pres(chip, clkrate, state, &cprd,\n\t\t\t\t\t\t\t&pres);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"failed to calculate cprd and prescaler\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tatmel_pwm_calculate_cdty(state, clkrate, cprd, pres, &cdty);\n\n\t\tif (cstate.enabled) {\n\t\t\tatmel_pwm_disable(chip, pwm, false);\n\t\t} else {\n\t\t\tret = clk_enable(atmel_pwm->clk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(chip->dev, \"failed to enable clock\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tval = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\n\t\tval = (val & ~PWM_CMR_CPRE_MSK) | (pres & PWM_CMR_CPRE_MSK);\n\t\tif (state->polarity == PWM_POLARITY_NORMAL)\n\t\t\tval &= ~PWM_CMR_CPOL;\n\t\telse\n\t\t\tval |= PWM_CMR_CPOL;\n\t\tatmel_pwm_ch_writel(atmel_pwm, pwm->hwpwm, PWM_CMR, val);\n\t\tatmel_pwm_set_cprd_cdty(chip, pwm, cprd, cdty);\n\t\tatmel_pwm_writel(atmel_pwm, PWM_ENA, 1 << pwm->hwpwm);\n\t} else if (cstate.enabled) {\n\t\tatmel_pwm_disable(chip, pwm, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       struct pwm_state *state)\n{\n\tstruct atmel_pwm_chip *atmel_pwm = to_atmel_pwm_chip(chip);\n\tu32 sr, cmr;\n\n\tsr = atmel_pwm_readl(atmel_pwm, PWM_SR);\n\tcmr = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm, PWM_CMR);\n\n\tif (sr & (1 << pwm->hwpwm)) {\n\t\tunsigned long rate = clk_get_rate(atmel_pwm->clk);\n\t\tu32 cdty, cprd, pres;\n\t\tu64 tmp;\n\n\t\tpres = cmr & PWM_CMR_CPRE_MSK;\n\n\t\tcprd = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm,\n\t\t\t\t\t  atmel_pwm->data->regs.period);\n\t\ttmp = (u64)cprd * NSEC_PER_SEC;\n\t\ttmp <<= pres;\n\t\tstate->period = DIV64_U64_ROUND_UP(tmp, rate);\n\n\t\t \n\t\tatmel_pwm_wait_nonpending(atmel_pwm, pwm->hwpwm);\n\n\t\tcdty = atmel_pwm_ch_readl(atmel_pwm, pwm->hwpwm,\n\t\t\t\t\t  atmel_pwm->data->regs.duty);\n\t\ttmp = (u64)(cprd - cdty) * NSEC_PER_SEC;\n\t\ttmp <<= pres;\n\t\tstate->duty_cycle = DIV64_U64_ROUND_UP(tmp, rate);\n\n\t\tstate->enabled = true;\n\t} else {\n\t\tstate->enabled = false;\n\t}\n\n\tif (cmr & PWM_CMR_CPOL)\n\t\tstate->polarity = PWM_POLARITY_INVERSED;\n\telse\n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops atmel_pwm_ops = {\n\t.apply = atmel_pwm_apply,\n\t.get_state = atmel_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct atmel_pwm_data atmel_sam9rl_pwm_data = {\n\t.regs = {\n\t\t.period\t\t= PWMV1_CPRD,\n\t\t.period_upd\t= PWMV1_CUPD,\n\t\t.duty\t\t= PWMV1_CDTY,\n\t\t.duty_upd\t= PWMV1_CUPD,\n\t},\n\t.cfg = {\n\t\t \n\t\t.period_bits\t= 16,\n\t},\n};\n\nstatic const struct atmel_pwm_data atmel_sama5_pwm_data = {\n\t.regs = {\n\t\t.period\t\t= PWMV2_CPRD,\n\t\t.period_upd\t= PWMV2_CPRDUPD,\n\t\t.duty\t\t= PWMV2_CDTY,\n\t\t.duty_upd\t= PWMV2_CDTYUPD,\n\t},\n\t.cfg = {\n\t\t \n\t\t.period_bits\t= 16,\n\t},\n};\n\nstatic const struct atmel_pwm_data mchp_sam9x60_pwm_data = {\n\t.regs = {\n\t\t.period\t\t= PWMV1_CPRD,\n\t\t.period_upd\t= PWMV1_CUPD,\n\t\t.duty\t\t= PWMV1_CDTY,\n\t\t.duty_upd\t= PWMV1_CUPD,\n\t},\n\t.cfg = {\n\t\t \n\t\t.period_bits\t= 32,\n\t},\n};\n\nstatic const struct of_device_id atmel_pwm_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9rl-pwm\",\n\t\t.data = &atmel_sam9rl_pwm_data,\n\t}, {\n\t\t.compatible = \"atmel,sama5d3-pwm\",\n\t\t.data = &atmel_sama5_pwm_data,\n\t}, {\n\t\t.compatible = \"atmel,sama5d2-pwm\",\n\t\t.data = &atmel_sama5_pwm_data,\n\t}, {\n\t\t.compatible = \"microchip,sam9x60-pwm\",\n\t\t.data = &mchp_sam9x60_pwm_data,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, atmel_pwm_dt_ids);\n\nstatic int atmel_pwm_enable_clk_if_on(struct atmel_pwm_chip *atmel_pwm, bool on)\n{\n\tunsigned int i, cnt = 0;\n\tunsigned long sr;\n\tint ret = 0;\n\n\tsr = atmel_pwm_readl(atmel_pwm, PWM_SR) & PWM_SR_ALL_CH_MASK;\n\tif (!sr)\n\t\treturn 0;\n\n\tcnt = bitmap_weight(&sr, atmel_pwm->chip.npwm);\n\n\tif (!on)\n\t\tgoto disable_clk;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tret = clk_enable(atmel_pwm->clk);\n\t\tif (ret) {\n\t\t\tdev_err(atmel_pwm->chip.dev,\n\t\t\t\t\"failed to enable clock for pwm %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\n\t\t\tcnt = i;\n\t\t\tgoto disable_clk;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_clk:\n\twhile (cnt--)\n\t\tclk_disable(atmel_pwm->clk);\n\n\treturn ret;\n}\n\nstatic int atmel_pwm_probe(struct platform_device *pdev)\n{\n\tstruct atmel_pwm_chip *atmel_pwm;\n\tint ret;\n\n\tatmel_pwm = devm_kzalloc(&pdev->dev, sizeof(*atmel_pwm), GFP_KERNEL);\n\tif (!atmel_pwm)\n\t\treturn -ENOMEM;\n\n\tatmel_pwm->data = of_device_get_match_data(&pdev->dev);\n\n\tatmel_pwm->update_pending = 0;\n\tspin_lock_init(&atmel_pwm->lock);\n\n\tatmel_pwm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(atmel_pwm->base))\n\t\treturn PTR_ERR(atmel_pwm->base);\n\n\tatmel_pwm->clk = devm_clk_get_prepared(&pdev->dev, NULL);\n\tif (IS_ERR(atmel_pwm->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(atmel_pwm->clk),\n\t\t\t\t     \"failed to get prepared PWM clock\\n\");\n\n\tatmel_pwm->chip.dev = &pdev->dev;\n\tatmel_pwm->chip.ops = &atmel_pwm_ops;\n\tatmel_pwm->chip.npwm = 4;\n\n\tret = atmel_pwm_enable_clk_if_on(atmel_pwm, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_pwmchip_add(&pdev->dev, &atmel_pwm->chip);\n\tif (ret < 0) {\n\t\tdev_err_probe(&pdev->dev, ret, \"failed to add PWM chip\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\treturn 0;\n\ndisable_clk:\n\tatmel_pwm_enable_clk_if_on(atmel_pwm, false);\n\n\treturn ret;\n}\n\nstatic struct platform_driver atmel_pwm_driver = {\n\t.driver = {\n\t\t.name = \"atmel-pwm\",\n\t\t.of_match_table = of_match_ptr(atmel_pwm_dt_ids),\n\t},\n\t.probe = atmel_pwm_probe,\n};\nmodule_platform_driver(atmel_pwm_driver);\n\nMODULE_ALIAS(\"platform:atmel-pwm\");\nMODULE_AUTHOR(\"Bo Shen <voice.shen@atmel.com>\");\nMODULE_DESCRIPTION(\"Atmel PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}