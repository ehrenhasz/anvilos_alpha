{
  "module_name": "pwm-raspberrypi-poe.c",
  "hash_id": "e97eef58b0fd3d5ade251210b18722397f4aa6105a8eda39568e46762846dbfa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-raspberrypi-poe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n#include <soc/bcm2835/raspberrypi-firmware.h>\n#include <dt-bindings/pwm/raspberrypi,firmware-poe-pwm.h>\n\n#define RPI_PWM_MAX_DUTY\t\t255\n#define RPI_PWM_PERIOD_NS\t\t80000  \n\n#define RPI_PWM_CUR_DUTY_REG\t\t0x0\n\nstruct raspberrypi_pwm {\n\tstruct rpi_firmware *firmware;\n\tstruct pwm_chip chip;\n\tunsigned int duty_cycle;\n};\n\nstruct raspberrypi_pwm_prop {\n\t__le32 reg;\n\t__le32 val;\n\t__le32 ret;\n} __packed;\n\nstatic inline\nstruct raspberrypi_pwm *raspberrypi_pwm_from_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct raspberrypi_pwm, chip);\n}\n\nstatic int raspberrypi_pwm_set_property(struct rpi_firmware *firmware,\n\t\t\t\t\tu32 reg, u32 val)\n{\n\tstruct raspberrypi_pwm_prop msg = {\n\t\t.reg = cpu_to_le32(reg),\n\t\t.val = cpu_to_le32(val),\n\t};\n\tint ret;\n\n\tret = rpi_firmware_property(firmware, RPI_FIRMWARE_SET_POE_HAT_VAL,\n\t\t\t\t    &msg, sizeof(msg));\n\tif (ret)\n\t\treturn ret;\n\tif (msg.ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int raspberrypi_pwm_get_property(struct rpi_firmware *firmware,\n\t\t\t\t\tu32 reg, u32 *val)\n{\n\tstruct raspberrypi_pwm_prop msg = {\n\t\t.reg = cpu_to_le32(reg),\n\t};\n\tint ret;\n\n\tret = rpi_firmware_property(firmware, RPI_FIRMWARE_GET_POE_HAT_VAL,\n\t\t\t\t    &msg, sizeof(msg));\n\tif (ret)\n\t\treturn ret;\n\tif (msg.ret)\n\t\treturn -EIO;\n\n\t*val = le32_to_cpu(msg.val);\n\n\treturn 0;\n}\n\nstatic int raspberrypi_pwm_get_state(struct pwm_chip *chip,\n\t\t\t\t     struct pwm_device *pwm,\n\t\t\t\t     struct pwm_state *state)\n{\n\tstruct raspberrypi_pwm *rpipwm = raspberrypi_pwm_from_chip(chip);\n\n\tstate->period = RPI_PWM_PERIOD_NS;\n\tstate->duty_cycle = DIV_ROUND_UP(rpipwm->duty_cycle * RPI_PWM_PERIOD_NS,\n\t\t\t\t\t RPI_PWM_MAX_DUTY);\n\tstate->enabled = !!(rpipwm->duty_cycle);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\treturn 0;\n}\n\nstatic int raspberrypi_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t const struct pwm_state *state)\n{\n\tstruct raspberrypi_pwm *rpipwm = raspberrypi_pwm_from_chip(chip);\n\tunsigned int duty_cycle;\n\tint ret;\n\n\tif (state->period < RPI_PWM_PERIOD_NS ||\n\t    state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled)\n\t\tduty_cycle = 0;\n\telse if (state->duty_cycle < RPI_PWM_PERIOD_NS)\n\t\tduty_cycle = DIV_ROUND_DOWN_ULL(state->duty_cycle * RPI_PWM_MAX_DUTY,\n\t\t\t\t\t\tRPI_PWM_PERIOD_NS);\n\telse\n\t\tduty_cycle = RPI_PWM_MAX_DUTY;\n\n\tif (duty_cycle == rpipwm->duty_cycle)\n\t\treturn 0;\n\n\tret = raspberrypi_pwm_set_property(rpipwm->firmware, RPI_PWM_CUR_DUTY_REG,\n\t\t\t\t\t   duty_cycle);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to set duty cycle: %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\trpipwm->duty_cycle = duty_cycle;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops raspberrypi_pwm_ops = {\n\t.get_state = raspberrypi_pwm_get_state,\n\t.apply = raspberrypi_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int raspberrypi_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *firmware_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct rpi_firmware *firmware;\n\tstruct raspberrypi_pwm *rpipwm;\n\tint ret;\n\n\tfirmware_node = of_get_parent(dev->of_node);\n\tif (!firmware_node) {\n\t\tdev_err(dev, \"Missing firmware node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tfirmware = devm_rpi_firmware_get(&pdev->dev, firmware_node);\n\tof_node_put(firmware_node);\n\tif (!firmware)\n\t\treturn dev_err_probe(dev, -EPROBE_DEFER,\n\t\t\t\t     \"Failed to get firmware handle\\n\");\n\n\trpipwm = devm_kzalloc(&pdev->dev, sizeof(*rpipwm), GFP_KERNEL);\n\tif (!rpipwm)\n\t\treturn -ENOMEM;\n\n\trpipwm->firmware = firmware;\n\trpipwm->chip.dev = dev;\n\trpipwm->chip.ops = &raspberrypi_pwm_ops;\n\trpipwm->chip.npwm = RASPBERRYPI_FIRMWARE_PWM_NUM;\n\n\tret = raspberrypi_pwm_get_property(rpipwm->firmware, RPI_PWM_CUR_DUTY_REG,\n\t\t\t\t\t   &rpipwm->duty_cycle);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get duty cycle: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\treturn devm_pwmchip_add(dev, &rpipwm->chip);\n}\n\nstatic const struct of_device_id raspberrypi_pwm_of_match[] = {\n\t{ .compatible = \"raspberrypi,firmware-poe-pwm\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, raspberrypi_pwm_of_match);\n\nstatic struct platform_driver raspberrypi_pwm_driver = {\n\t.driver = {\n\t\t.name = \"raspberrypi-poe-pwm\",\n\t\t.of_match_table = raspberrypi_pwm_of_match,\n\t},\n\t.probe = raspberrypi_pwm_probe,\n};\nmodule_platform_driver(raspberrypi_pwm_driver);\n\nMODULE_AUTHOR(\"Nicolas Saenz Julienne <nsaenzjulienne@suse.de>\");\nMODULE_DESCRIPTION(\"Raspberry Pi Firmware Based PWM Bus Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}