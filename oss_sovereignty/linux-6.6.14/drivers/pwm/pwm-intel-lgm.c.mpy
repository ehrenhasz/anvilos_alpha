{
  "module_name": "pwm-intel-lgm.c",
  "hash_id": "110e88825f4f9810163ebff1f1be8232b68b0974fcdc4e729483d20a0452c7a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-intel-lgm.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#define LGM_PWM_FAN_CON0\t\t0x0\n#define LGM_PWM_FAN_EN_EN\t\tBIT(0)\n#define LGM_PWM_FAN_EN_DIS\t\t0x0\n#define LGM_PWM_FAN_EN_MSK\t\tBIT(0)\n#define LGM_PWM_FAN_MODE_2WIRE\t\t0x0\n#define LGM_PWM_FAN_MODE_MSK\t\tBIT(1)\n#define LGM_PWM_FAN_DC_MSK\t\tGENMASK(23, 16)\n\n#define LGM_PWM_FAN_CON1\t\t0x4\n#define LGM_PWM_FAN_MAX_RPM_MSK\t\tGENMASK(15, 0)\n\n#define LGM_PWM_MAX_RPM\t\t\t(BIT(16) - 1)\n#define LGM_PWM_DEFAULT_RPM\t\t4000\n#define LGM_PWM_MAX_DUTY_CYCLE\t\t(BIT(8) - 1)\n\n#define LGM_PWM_DC_BITS\t\t\t8\n\n#define LGM_PWM_PERIOD_2WIRE_NS\t\t(40 * NSEC_PER_MSEC)\n\nstruct lgm_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct regmap *regmap;\n\tu32 period;\n};\n\nstatic inline struct lgm_pwm_chip *to_lgm_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct lgm_pwm_chip, chip);\n}\n\nstatic int lgm_pwm_enable(struct pwm_chip *chip, bool enable)\n{\n\tstruct lgm_pwm_chip *pc = to_lgm_pwm_chip(chip);\n\tstruct regmap *regmap = pc->regmap;\n\n\treturn regmap_update_bits(regmap, LGM_PWM_FAN_CON0, LGM_PWM_FAN_EN_MSK,\n\t\t\t\t  enable ? LGM_PWM_FAN_EN_EN : LGM_PWM_FAN_EN_DIS);\n}\n\nstatic int lgm_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tstruct lgm_pwm_chip *pc = to_lgm_pwm_chip(chip);\n\tu32 duty_cycle, val;\n\tint ret;\n\n\t \n\tif (state->polarity != PWM_POLARITY_NORMAL || state->period < pc->period)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled)\n\t\treturn lgm_pwm_enable(chip, 0);\n\n\tduty_cycle = min_t(u64, state->duty_cycle, pc->period);\n\tval = duty_cycle * LGM_PWM_MAX_DUTY_CYCLE / pc->period;\n\n\tret = regmap_update_bits(pc->regmap, LGM_PWM_FAN_CON0, LGM_PWM_FAN_DC_MSK,\n\t\t\t\t FIELD_PREP(LGM_PWM_FAN_DC_MSK, val));\n\tif (ret)\n\t\treturn ret;\n\n\treturn lgm_pwm_enable(chip, 1);\n}\n\nstatic int lgm_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     struct pwm_state *state)\n{\n\tstruct lgm_pwm_chip *pc = to_lgm_pwm_chip(chip);\n\tu32 duty, val;\n\n\tstate->enabled = regmap_test_bits(pc->regmap, LGM_PWM_FAN_CON0,\n\t\t\t\t\t  LGM_PWM_FAN_EN_EN);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\tstate->period = pc->period;  \n\n\tregmap_read(pc->regmap, LGM_PWM_FAN_CON0, &val);\n\tduty = FIELD_GET(LGM_PWM_FAN_DC_MSK, val);\n\tstate->duty_cycle = DIV_ROUND_UP(duty * pc->period, LGM_PWM_MAX_DUTY_CYCLE);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops lgm_pwm_ops = {\n\t.get_state = lgm_pwm_get_state,\n\t.apply = lgm_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic void lgm_pwm_init(struct lgm_pwm_chip *pc)\n{\n\tstruct regmap *regmap = pc->regmap;\n\tu32 con0_val;\n\n\tcon0_val = FIELD_PREP(LGM_PWM_FAN_MODE_MSK, LGM_PWM_FAN_MODE_2WIRE);\n\tpc->period = LGM_PWM_PERIOD_2WIRE_NS;\n\tregmap_update_bits(regmap, LGM_PWM_FAN_CON1, LGM_PWM_FAN_MAX_RPM_MSK,\n\t\t\t   LGM_PWM_DEFAULT_RPM);\n\tregmap_update_bits(regmap, LGM_PWM_FAN_CON0, LGM_PWM_FAN_MODE_MSK,\n\t\t\t   con0_val);\n}\n\nstatic const struct regmap_config lgm_pwm_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n};\n\nstatic void lgm_clk_release(void *data)\n{\n\tstruct clk *clk = data;\n\n\tclk_disable_unprepare(clk);\n}\n\nstatic int lgm_clk_enable(struct device *dev, struct clk *clk)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, lgm_clk_release, clk);\n}\n\nstatic void lgm_reset_control_release(void *data)\n{\n\tstruct reset_control *rst = data;\n\n\treset_control_assert(rst);\n}\n\nstatic int lgm_reset_control_deassert(struct device *dev, struct reset_control *rst)\n{\n\tint ret;\n\n\tret = reset_control_deassert(rst);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, lgm_reset_control_release, rst);\n}\n\nstatic int lgm_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct reset_control *rst;\n\tstruct lgm_pwm_chip *pc;\n\tvoid __iomem *io_base;\n\tstruct clk *clk;\n\tint ret;\n\n\tpc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tpc->regmap = devm_regmap_init_mmio(dev, io_base, &lgm_pwm_regmap_config);\n\tif (IS_ERR(pc->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(pc->regmap),\n\t\t\t\t     \"failed to init register map\\n\");\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"failed to get clock\\n\");\n\n\tret = lgm_clk_enable(dev, clk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to enable clock\\n\");\n\n\trst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(rst),\n\t\t\t\t     \"failed to get reset control\\n\");\n\n\tret = lgm_reset_control_deassert(dev, rst);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"cannot deassert reset control\\n\");\n\n\tpc->chip.dev = dev;\n\tpc->chip.ops = &lgm_pwm_ops;\n\tpc->chip.npwm = 1;\n\n\tlgm_pwm_init(pc);\n\n\tret = devm_pwmchip_add(dev, &pc->chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"failed to add PWM chip\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lgm_pwm_of_match[] = {\n\t{ .compatible = \"intel,lgm-pwm\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lgm_pwm_of_match);\n\nstatic struct platform_driver lgm_pwm_driver = {\n\t.driver = {\n\t\t.name = \"intel-pwm\",\n\t\t.of_match_table = lgm_pwm_of_match,\n\t},\n\t.probe = lgm_pwm_probe,\n};\nmodule_platform_driver(lgm_pwm_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}