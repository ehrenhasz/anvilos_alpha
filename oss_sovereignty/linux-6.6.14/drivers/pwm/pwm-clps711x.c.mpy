{
  "module_name": "pwm-clps711x.c",
  "hash_id": "9df00991c745d86e4ba2e5c79508534eb8b9638ccfdf679b98dec8d03aa26e84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-clps711x.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\nstruct clps711x_chip {\n\tstruct pwm_chip chip;\n\tvoid __iomem *pmpcon;\n\tstruct clk *clk;\n\tspinlock_t lock;\n};\n\nstatic inline struct clps711x_chip *to_clps711x_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct clps711x_chip, chip);\n}\n\nstatic int clps711x_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct clps711x_chip *priv = to_clps711x_chip(chip);\n\tunsigned int freq = clk_get_rate(priv->clk);\n\n\tif (!freq)\n\t\treturn -EINVAL;\n\n\t \n\tpwm->args.period = DIV_ROUND_CLOSEST(NSEC_PER_SEC, freq);\n\n\treturn 0;\n}\n\nstatic int clps711x_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      const struct pwm_state *state)\n{\n\tstruct clps711x_chip *priv = to_clps711x_chip(chip);\n\t \n\tu32 shift = (pwm->hwpwm + 1) * 4;\n\tunsigned long flags;\n\tu32 pmpcon, val;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (state->period != pwm->args.period)\n\t\treturn -EINVAL;\n\n\tif (state->enabled)\n\t\tval = mul_u64_u64_div_u64(state->duty_cycle, 0xf, state->period);\n\telse\n\t\tval = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpmpcon = readl(priv->pmpcon);\n\tpmpcon &= ~(0xf << shift);\n\tpmpcon |= val << shift;\n\twritel(pmpcon, priv->pmpcon);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops clps711x_pwm_ops = {\n\t.request = clps711x_pwm_request,\n\t.apply = clps711x_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct pwm_device *clps711x_pwm_xlate(struct pwm_chip *chip,\n\t\t\t\t\t     const struct of_phandle_args *args)\n{\n\tif (args->args[0] >= chip->npwm)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn pwm_request_from_chip(chip, args->args[0], NULL);\n}\n\nstatic int clps711x_pwm_probe(struct platform_device *pdev)\n{\n\tstruct clps711x_chip *priv;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->pmpcon = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->pmpcon))\n\t\treturn PTR_ERR(priv->pmpcon);\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpriv->chip.ops = &clps711x_pwm_ops;\n\tpriv->chip.dev = &pdev->dev;\n\tpriv->chip.npwm = 2;\n\tpriv->chip.of_xlate = clps711x_pwm_xlate;\n\tpriv->chip.of_pwm_n_cells = 1;\n\n\tspin_lock_init(&priv->lock);\n\n\treturn devm_pwmchip_add(&pdev->dev, &priv->chip);\n}\n\nstatic const struct of_device_id __maybe_unused clps711x_pwm_dt_ids[] = {\n\t{ .compatible = \"cirrus,ep7209-pwm\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, clps711x_pwm_dt_ids);\n\nstatic struct platform_driver clps711x_pwm_driver = {\n\t.driver = {\n\t\t.name = \"clps711x-pwm\",\n\t\t.of_match_table = of_match_ptr(clps711x_pwm_dt_ids),\n\t},\n\t.probe = clps711x_pwm_probe,\n};\nmodule_platform_driver(clps711x_pwm_driver);\n\nMODULE_AUTHOR(\"Alexander Shiyan <shc_work@mail.ru>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CLPS711X PWM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}