{
  "module_name": "pwm-imx-tpm.c",
  "hash_id": "2dc161907d72a511b7d64b500feba57f2f50e622fa9c65f455ec37b44b35ca31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-imx-tpm.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n#define PWM_IMX_TPM_PARAM\t0x4\n#define PWM_IMX_TPM_GLOBAL\t0x8\n#define PWM_IMX_TPM_SC\t\t0x10\n#define PWM_IMX_TPM_CNT\t\t0x14\n#define PWM_IMX_TPM_MOD\t\t0x18\n#define PWM_IMX_TPM_CnSC(n)\t(0x20 + (n) * 0x8)\n#define PWM_IMX_TPM_CnV(n)\t(0x24 + (n) * 0x8)\n\n#define PWM_IMX_TPM_PARAM_CHAN\t\t\tGENMASK(7, 0)\n\n#define PWM_IMX_TPM_SC_PS\t\t\tGENMASK(2, 0)\n#define PWM_IMX_TPM_SC_CMOD\t\t\tGENMASK(4, 3)\n#define PWM_IMX_TPM_SC_CMOD_INC_EVERY_CLK\tFIELD_PREP(PWM_IMX_TPM_SC_CMOD, 1)\n#define PWM_IMX_TPM_SC_CPWMS\t\t\tBIT(5)\n\n#define PWM_IMX_TPM_CnSC_CHF\tBIT(7)\n#define PWM_IMX_TPM_CnSC_MSB\tBIT(5)\n#define PWM_IMX_TPM_CnSC_MSA\tBIT(4)\n\n \n#define PWM_IMX_TPM_CnSC_ELS\tGENMASK(3, 2)\n#define PWM_IMX_TPM_CnSC_ELS_INVERSED\tFIELD_PREP(PWM_IMX_TPM_CnSC_ELS, 1)\n#define PWM_IMX_TPM_CnSC_ELS_NORMAL\tFIELD_PREP(PWM_IMX_TPM_CnSC_ELS, 2)\n\n\n#define PWM_IMX_TPM_MOD_WIDTH\t16\n#define PWM_IMX_TPM_MOD_MOD\tGENMASK(PWM_IMX_TPM_MOD_WIDTH - 1, 0)\n\nstruct imx_tpm_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tstruct mutex lock;\n\tu32 user_count;\n\tu32 enable_count;\n\tu32 real_period;\n};\n\nstruct imx_tpm_pwm_param {\n\tu8 prescale;\n\tu32 mod;\n\tu32 val;\n};\n\nstatic inline struct imx_tpm_pwm_chip *\nto_imx_tpm_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct imx_tpm_pwm_chip, chip);\n}\n\n \nstatic int pwm_imx_tpm_round_state(struct pwm_chip *chip,\n\t\t\t\t   struct imx_tpm_pwm_param *p,\n\t\t\t\t   struct pwm_state *real_state,\n\t\t\t\t   const struct pwm_state *state)\n{\n\tstruct imx_tpm_pwm_chip *tpm = to_imx_tpm_pwm_chip(chip);\n\tu32 rate, prescale, period_count, clock_unit;\n\tu64 tmp;\n\n\trate = clk_get_rate(tpm->clk);\n\ttmp = (u64)state->period * rate;\n\tclock_unit = DIV_ROUND_CLOSEST_ULL(tmp, NSEC_PER_SEC);\n\tif (clock_unit <= PWM_IMX_TPM_MOD_MOD)\n\t\tprescale = 0;\n\telse\n\t\tprescale = ilog2(clock_unit) + 1 - PWM_IMX_TPM_MOD_WIDTH;\n\n\tif ((!FIELD_FIT(PWM_IMX_TPM_SC_PS, prescale)))\n\t\treturn -ERANGE;\n\tp->prescale = prescale;\n\n\tperiod_count = (clock_unit + ((1 << prescale) >> 1)) >> prescale;\n\tp->mod = period_count;\n\n\t \n\ttmp = (u64)period_count << prescale;\n\ttmp *= NSEC_PER_SEC;\n\treal_state->period = DIV_ROUND_CLOSEST_ULL(tmp, rate);\n\n\t \n\tif (!state->enabled)\n\t\treal_state->duty_cycle = 0;\n\telse\n\t\treal_state->duty_cycle = state->duty_cycle;\n\n\ttmp = (u64)p->mod * real_state->duty_cycle;\n\tp->val = DIV64_U64_ROUND_CLOSEST(tmp, real_state->period);\n\n\treal_state->polarity = state->polarity;\n\treal_state->enabled = state->enabled;\n\n\treturn 0;\n}\n\nstatic int pwm_imx_tpm_get_state(struct pwm_chip *chip,\n\t\t\t\t struct pwm_device *pwm,\n\t\t\t\t struct pwm_state *state)\n{\n\tstruct imx_tpm_pwm_chip *tpm = to_imx_tpm_pwm_chip(chip);\n\tu32 rate, val, prescale;\n\tu64 tmp;\n\n\t \n\tstate->period = tpm->real_period;\n\n\t \n\trate = clk_get_rate(tpm->clk);\n\tval = readl(tpm->base + PWM_IMX_TPM_SC);\n\tprescale = FIELD_GET(PWM_IMX_TPM_SC_PS, val);\n\ttmp = readl(tpm->base + PWM_IMX_TPM_CnV(pwm->hwpwm));\n\ttmp = (tmp << prescale) * NSEC_PER_SEC;\n\tstate->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, rate);\n\n\t \n\tval = readl(tpm->base + PWM_IMX_TPM_CnSC(pwm->hwpwm));\n\tif ((val & PWM_IMX_TPM_CnSC_ELS) == PWM_IMX_TPM_CnSC_ELS_INVERSED)\n\t\tstate->polarity = PWM_POLARITY_INVERSED;\n\telse\n\t\t \n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\t \n\tstate->enabled = FIELD_GET(PWM_IMX_TPM_CnSC_ELS, val) ? true : false;\n\n\treturn 0;\n}\n\n \nstatic int pwm_imx_tpm_apply_hw(struct pwm_chip *chip,\n\t\t\t\tstruct imx_tpm_pwm_param *p,\n\t\t\t\tstruct pwm_state *state,\n\t\t\t\tstruct pwm_device *pwm)\n{\n\tstruct imx_tpm_pwm_chip *tpm = to_imx_tpm_pwm_chip(chip);\n\tbool period_update = false;\n\tbool duty_update = false;\n\tu32 val, cmod, cur_prescale;\n\tunsigned long timeout;\n\tstruct pwm_state c;\n\n\tif (state->period != tpm->real_period) {\n\t\t \n\t\tif (tpm->user_count > 1)\n\t\t\treturn -EBUSY;\n\n\t\tval = readl(tpm->base + PWM_IMX_TPM_SC);\n\t\tcmod = FIELD_GET(PWM_IMX_TPM_SC_CMOD, val);\n\t\tcur_prescale = FIELD_GET(PWM_IMX_TPM_SC_PS, val);\n\t\tif (cmod && cur_prescale != p->prescale)\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tval &= ~PWM_IMX_TPM_SC_PS;\n\t\tval |= FIELD_PREP(PWM_IMX_TPM_SC_PS, p->prescale);\n\t\twritel(val, tpm->base + PWM_IMX_TPM_SC);\n\n\t\t \n\t\twritel(p->mod, tpm->base + PWM_IMX_TPM_MOD);\n\t\ttpm->real_period = state->period;\n\t\tperiod_update = true;\n\t}\n\n\tpwm_imx_tpm_get_state(chip, pwm, &c);\n\n\t \n\tif (c.enabled && c.polarity != state->polarity)\n\t\treturn -EBUSY;\n\n\tif (state->duty_cycle != c.duty_cycle) {\n\t\t \n\t\twritel(p->val, tpm->base + PWM_IMX_TPM_CnV(pwm->hwpwm));\n\t\tduty_update = true;\n\t}\n\n\t \n\tif (period_update || duty_update) {\n\t\ttimeout = jiffies + msecs_to_jiffies(tpm->real_period /\n\t\t\t\t\t\t     NSEC_PER_MSEC + 1);\n\t\twhile (readl(tpm->base + PWM_IMX_TPM_MOD) != p->mod\n\t\t       || readl(tpm->base + PWM_IMX_TPM_CnV(pwm->hwpwm))\n\t\t       != p->val) {\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\treturn -ETIME;\n\t\t\tcpu_relax();\n\t\t}\n\t}\n\n\t \n\tval = readl(tpm->base + PWM_IMX_TPM_CnSC(pwm->hwpwm));\n\tval &= ~(PWM_IMX_TPM_CnSC_ELS | PWM_IMX_TPM_CnSC_MSA |\n\t\t PWM_IMX_TPM_CnSC_MSB);\n\tif (state->enabled) {\n\t\t \n\t\tval |= PWM_IMX_TPM_CnSC_MSB;\n\t\tval |= (state->polarity == PWM_POLARITY_NORMAL) ?\n\t\t\tPWM_IMX_TPM_CnSC_ELS_NORMAL :\n\t\t\tPWM_IMX_TPM_CnSC_ELS_INVERSED;\n\t}\n\twritel(val, tpm->base + PWM_IMX_TPM_CnSC(pwm->hwpwm));\n\n\t \n\tif (state->enabled != c.enabled) {\n\t\tval = readl(tpm->base + PWM_IMX_TPM_SC);\n\t\tif (state->enabled) {\n\t\t\tif (++tpm->enable_count == 1)\n\t\t\t\tval |= PWM_IMX_TPM_SC_CMOD_INC_EVERY_CLK;\n\t\t} else {\n\t\t\tif (--tpm->enable_count == 0)\n\t\t\t\tval &= ~PWM_IMX_TPM_SC_CMOD;\n\t\t}\n\t\twritel(val, tpm->base + PWM_IMX_TPM_SC);\n\t}\n\n\treturn 0;\n}\n\nstatic int pwm_imx_tpm_apply(struct pwm_chip *chip,\n\t\t\t     struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tstruct imx_tpm_pwm_chip *tpm = to_imx_tpm_pwm_chip(chip);\n\tstruct imx_tpm_pwm_param param;\n\tstruct pwm_state real_state;\n\tint ret;\n\n\tret = pwm_imx_tpm_round_state(chip, &param, &real_state, state);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&tpm->lock);\n\tret = pwm_imx_tpm_apply_hw(chip, &param, &real_state, pwm);\n\tmutex_unlock(&tpm->lock);\n\n\treturn ret;\n}\n\nstatic int pwm_imx_tpm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct imx_tpm_pwm_chip *tpm = to_imx_tpm_pwm_chip(chip);\n\n\tmutex_lock(&tpm->lock);\n\ttpm->user_count++;\n\tmutex_unlock(&tpm->lock);\n\n\treturn 0;\n}\n\nstatic void pwm_imx_tpm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct imx_tpm_pwm_chip *tpm = to_imx_tpm_pwm_chip(chip);\n\n\tmutex_lock(&tpm->lock);\n\ttpm->user_count--;\n\tmutex_unlock(&tpm->lock);\n}\n\nstatic const struct pwm_ops imx_tpm_pwm_ops = {\n\t.request = pwm_imx_tpm_request,\n\t.free = pwm_imx_tpm_free,\n\t.get_state = pwm_imx_tpm_get_state,\n\t.apply = pwm_imx_tpm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pwm_imx_tpm_probe(struct platform_device *pdev)\n{\n\tstruct imx_tpm_pwm_chip *tpm;\n\tint ret;\n\tu32 val;\n\n\ttpm = devm_kzalloc(&pdev->dev, sizeof(*tpm), GFP_KERNEL);\n\tif (!tpm)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, tpm);\n\n\ttpm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tpm->base))\n\t\treturn PTR_ERR(tpm->base);\n\n\ttpm->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(tpm->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(tpm->clk),\n\t\t\t\t     \"failed to get PWM clock\\n\");\n\n\tret = clk_prepare_enable(tpm->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to prepare or enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttpm->chip.dev = &pdev->dev;\n\ttpm->chip.ops = &imx_tpm_pwm_ops;\n\n\t \n\tval = readl(tpm->base + PWM_IMX_TPM_PARAM);\n\ttpm->chip.npwm = FIELD_GET(PWM_IMX_TPM_PARAM_CHAN, val);\n\n\tmutex_init(&tpm->lock);\n\n\tret = pwmchip_add(&tpm->chip);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip: %d\\n\", ret);\n\t\tclk_disable_unprepare(tpm->clk);\n\t}\n\n\treturn ret;\n}\n\nstatic void pwm_imx_tpm_remove(struct platform_device *pdev)\n{\n\tstruct imx_tpm_pwm_chip *tpm = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&tpm->chip);\n\n\tclk_disable_unprepare(tpm->clk);\n}\n\nstatic int __maybe_unused pwm_imx_tpm_suspend(struct device *dev)\n{\n\tstruct imx_tpm_pwm_chip *tpm = dev_get_drvdata(dev);\n\n\tif (tpm->enable_count > 0)\n\t\treturn -EBUSY;\n\n\t \n\ttpm->real_period = 0;\n\n\tclk_disable_unprepare(tpm->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pwm_imx_tpm_resume(struct device *dev)\n{\n\tstruct imx_tpm_pwm_chip *tpm = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = clk_prepare_enable(tpm->clk);\n\tif (ret)\n\t\tdev_err(dev, \"failed to prepare or enable clock: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(imx_tpm_pwm_pm,\n\t\t\t pwm_imx_tpm_suspend, pwm_imx_tpm_resume);\n\nstatic const struct of_device_id imx_tpm_pwm_dt_ids[] = {\n\t{ .compatible = \"fsl,imx7ulp-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_tpm_pwm_dt_ids);\n\nstatic struct platform_driver imx_tpm_pwm_driver = {\n\t.driver = {\n\t\t.name = \"imx7ulp-tpm-pwm\",\n\t\t.of_match_table = imx_tpm_pwm_dt_ids,\n\t\t.pm = &imx_tpm_pwm_pm,\n\t},\n\t.probe\t= pwm_imx_tpm_probe,\n\t.remove_new = pwm_imx_tpm_remove,\n};\nmodule_platform_driver(imx_tpm_pwm_driver);\n\nMODULE_AUTHOR(\"Anson Huang <Anson.Huang@nxp.com>\");\nMODULE_DESCRIPTION(\"i.MX TPM PWM Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}