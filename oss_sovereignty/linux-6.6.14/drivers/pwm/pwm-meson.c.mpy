{
  "module_name": "pwm-meson.c",
  "hash_id": "fbabb4b3d6dbe45bd30e7324871a70bf5071a5736ecbf82ad53742f8eb6c896c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-meson.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define REG_PWM_A\t\t0x0\n#define REG_PWM_B\t\t0x4\n#define PWM_LOW_MASK\t\tGENMASK(15, 0)\n#define PWM_HIGH_MASK\t\tGENMASK(31, 16)\n\n#define REG_MISC_AB\t\t0x8\n#define MISC_B_CLK_EN_SHIFT\t23\n#define MISC_A_CLK_EN_SHIFT\t15\n#define MISC_CLK_DIV_WIDTH\t7\n#define MISC_B_CLK_DIV_SHIFT\t16\n#define MISC_A_CLK_DIV_SHIFT\t8\n#define MISC_B_CLK_SEL_SHIFT\t6\n#define MISC_A_CLK_SEL_SHIFT\t4\n#define MISC_CLK_SEL_MASK\t0x3\n#define MISC_B_EN\t\tBIT(1)\n#define MISC_A_EN\t\tBIT(0)\n\n#define MESON_NUM_PWMS\t\t2\n#define MESON_MAX_MUX_PARENTS\t4\n\nstatic struct meson_pwm_channel_data {\n\tu8\t\treg_offset;\n\tu8\t\tclk_sel_shift;\n\tu8\t\tclk_div_shift;\n\tu8\t\tclk_en_shift;\n\tu32\t\tpwm_en_mask;\n} meson_pwm_per_channel_data[MESON_NUM_PWMS] = {\n\t{\n\t\t.reg_offset\t= REG_PWM_A,\n\t\t.clk_sel_shift\t= MISC_A_CLK_SEL_SHIFT,\n\t\t.clk_div_shift\t= MISC_A_CLK_DIV_SHIFT,\n\t\t.clk_en_shift\t= MISC_A_CLK_EN_SHIFT,\n\t\t.pwm_en_mask\t= MISC_A_EN,\n\t},\n\t{\n\t\t.reg_offset\t= REG_PWM_B,\n\t\t.clk_sel_shift\t= MISC_B_CLK_SEL_SHIFT,\n\t\t.clk_div_shift\t= MISC_B_CLK_DIV_SHIFT,\n\t\t.clk_en_shift\t= MISC_B_CLK_EN_SHIFT,\n\t\t.pwm_en_mask\t= MISC_B_EN,\n\t}\n};\n\nstruct meson_pwm_channel {\n\tunsigned long rate;\n\tunsigned int hi;\n\tunsigned int lo;\n\n\tstruct clk_mux mux;\n\tstruct clk_divider div;\n\tstruct clk_gate gate;\n\tstruct clk *clk;\n};\n\nstruct meson_pwm_data {\n\tconst char * const *parent_names;\n\tunsigned int num_parents;\n};\n\nstruct meson_pwm {\n\tstruct pwm_chip chip;\n\tconst struct meson_pwm_data *data;\n\tstruct meson_pwm_channel channels[MESON_NUM_PWMS];\n\tvoid __iomem *base;\n\t \n\tspinlock_t lock;\n};\n\nstatic inline struct meson_pwm *to_meson_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct meson_pwm, chip);\n}\n\nstatic int meson_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct meson_pwm *meson = to_meson_pwm(chip);\n\tstruct meson_pwm_channel *channel = &meson->channels[pwm->hwpwm];\n\tstruct device *dev = chip->dev;\n\tint err;\n\n\terr = clk_prepare_enable(channel->clk);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable clock %s: %d\\n\",\n\t\t\t__clk_get_name(channel->clk), err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct meson_pwm *meson = to_meson_pwm(chip);\n\tstruct meson_pwm_channel *channel = &meson->channels[pwm->hwpwm];\n\n\tclk_disable_unprepare(channel->clk);\n}\n\nstatic int meson_pwm_calc(struct meson_pwm *meson, struct pwm_device *pwm,\n\t\t\t  const struct pwm_state *state)\n{\n\tstruct meson_pwm_channel *channel = &meson->channels[pwm->hwpwm];\n\tunsigned int cnt, duty_cnt;\n\tunsigned long fin_freq;\n\tu64 duty, period, freq;\n\n\tduty = state->duty_cycle;\n\tperiod = state->period;\n\n\t \n\tif (state->polarity == PWM_POLARITY_INVERSED)\n\t\tduty = period - duty;\n\n\tfreq = div64_u64(NSEC_PER_SEC * 0xffffULL, period);\n\tif (freq > ULONG_MAX)\n\t\tfreq = ULONG_MAX;\n\n\tfin_freq = clk_round_rate(channel->clk, freq);\n\tif (fin_freq == 0) {\n\t\tdev_err(meson->chip.dev, \"invalid source clock frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(meson->chip.dev, \"fin_freq: %lu Hz\\n\", fin_freq);\n\n\tcnt = div_u64(fin_freq * period, NSEC_PER_SEC);\n\tif (cnt > 0xffff) {\n\t\tdev_err(meson->chip.dev, \"unable to get period cnt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(meson->chip.dev, \"period=%llu cnt=%u\\n\", period, cnt);\n\n\tif (duty == period) {\n\t\tchannel->hi = cnt;\n\t\tchannel->lo = 0;\n\t} else if (duty == 0) {\n\t\tchannel->hi = 0;\n\t\tchannel->lo = cnt;\n\t} else {\n\t\tduty_cnt = div_u64(fin_freq * duty, NSEC_PER_SEC);\n\n\t\tdev_dbg(meson->chip.dev, \"duty=%llu duty_cnt=%u\\n\", duty, duty_cnt);\n\n\t\tchannel->hi = duty_cnt;\n\t\tchannel->lo = cnt - duty_cnt;\n\t}\n\n\tchannel->rate = fin_freq;\n\n\treturn 0;\n}\n\nstatic void meson_pwm_enable(struct meson_pwm *meson, struct pwm_device *pwm)\n{\n\tstruct meson_pwm_channel *channel = &meson->channels[pwm->hwpwm];\n\tstruct meson_pwm_channel_data *channel_data;\n\tunsigned long flags;\n\tu32 value;\n\tint err;\n\n\tchannel_data = &meson_pwm_per_channel_data[pwm->hwpwm];\n\n\terr = clk_set_rate(channel->clk, channel->rate);\n\tif (err)\n\t\tdev_err(meson->chip.dev, \"setting clock rate failed\\n\");\n\n\tspin_lock_irqsave(&meson->lock, flags);\n\n\tvalue = FIELD_PREP(PWM_HIGH_MASK, channel->hi) |\n\t\tFIELD_PREP(PWM_LOW_MASK, channel->lo);\n\twritel(value, meson->base + channel_data->reg_offset);\n\n\tvalue = readl(meson->base + REG_MISC_AB);\n\tvalue |= channel_data->pwm_en_mask;\n\twritel(value, meson->base + REG_MISC_AB);\n\n\tspin_unlock_irqrestore(&meson->lock, flags);\n}\n\nstatic void meson_pwm_disable(struct meson_pwm *meson, struct pwm_device *pwm)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&meson->lock, flags);\n\n\tvalue = readl(meson->base + REG_MISC_AB);\n\tvalue &= ~meson_pwm_per_channel_data[pwm->hwpwm].pwm_en_mask;\n\twritel(value, meson->base + REG_MISC_AB);\n\n\tspin_unlock_irqrestore(&meson->lock, flags);\n}\n\nstatic int meson_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tstruct meson_pwm *meson = to_meson_pwm(chip);\n\tstruct meson_pwm_channel *channel = &meson->channels[pwm->hwpwm];\n\tint err = 0;\n\n\tif (!state->enabled) {\n\t\tif (state->polarity == PWM_POLARITY_INVERSED) {\n\t\t\t \n\t\t\tchannel->rate = ULONG_MAX;\n\t\t\tchannel->hi = ~0;\n\t\t\tchannel->lo = 0;\n\n\t\t\tmeson_pwm_enable(meson, pwm);\n\t\t} else {\n\t\t\tmeson_pwm_disable(meson, pwm);\n\t\t}\n\t} else {\n\t\terr = meson_pwm_calc(meson, pwm, state);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmeson_pwm_enable(meson, pwm);\n\t}\n\n\treturn 0;\n}\n\nstatic u64 meson_pwm_cnt_to_ns(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       u32 cnt)\n{\n\tstruct meson_pwm *meson = to_meson_pwm(chip);\n\tstruct meson_pwm_channel *channel;\n\tunsigned long fin_freq;\n\n\t \n\tchannel = &meson->channels[pwm->hwpwm];\n\n\tfin_freq = clk_get_rate(channel->clk);\n\tif (fin_freq == 0)\n\t\treturn 0;\n\n\treturn div64_ul(NSEC_PER_SEC * (u64)cnt, fin_freq);\n}\n\nstatic int meson_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       struct pwm_state *state)\n{\n\tstruct meson_pwm *meson = to_meson_pwm(chip);\n\tstruct meson_pwm_channel_data *channel_data;\n\tstruct meson_pwm_channel *channel;\n\tu32 value;\n\n\tif (!state)\n\t\treturn 0;\n\n\tchannel = &meson->channels[pwm->hwpwm];\n\tchannel_data = &meson_pwm_per_channel_data[pwm->hwpwm];\n\n\tvalue = readl(meson->base + REG_MISC_AB);\n\tstate->enabled = value & channel_data->pwm_en_mask;\n\n\tvalue = readl(meson->base + channel_data->reg_offset);\n\tchannel->lo = FIELD_GET(PWM_LOW_MASK, value);\n\tchannel->hi = FIELD_GET(PWM_HIGH_MASK, value);\n\n\tstate->period = meson_pwm_cnt_to_ns(chip, pwm, channel->lo + channel->hi);\n\tstate->duty_cycle = meson_pwm_cnt_to_ns(chip, pwm, channel->hi);\n\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops meson_pwm_ops = {\n\t.request = meson_pwm_request,\n\t.free = meson_pwm_free,\n\t.apply = meson_pwm_apply,\n\t.get_state = meson_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic const char * const pwm_meson8b_parent_names[] = {\n\t\"xtal\", NULL, \"fclk_div4\", \"fclk_div3\"\n};\n\nstatic const struct meson_pwm_data pwm_meson8b_data = {\n\t.parent_names = pwm_meson8b_parent_names,\n\t.num_parents = ARRAY_SIZE(pwm_meson8b_parent_names),\n};\n\n \nstatic const char * const pwm_gxbb_ao_parent_names[] = {\n\t\"xtal\", \"clk81\"\n};\n\nstatic const struct meson_pwm_data pwm_gxbb_ao_data = {\n\t.parent_names = pwm_gxbb_ao_parent_names,\n\t.num_parents = ARRAY_SIZE(pwm_gxbb_ao_parent_names),\n};\n\nstatic const char * const pwm_axg_ee_parent_names[] = {\n\t\"xtal\", \"fclk_div5\", \"fclk_div4\", \"fclk_div3\"\n};\n\nstatic const struct meson_pwm_data pwm_axg_ee_data = {\n\t.parent_names = pwm_axg_ee_parent_names,\n\t.num_parents = ARRAY_SIZE(pwm_axg_ee_parent_names),\n};\n\nstatic const char * const pwm_axg_ao_parent_names[] = {\n\t\"xtal\", \"axg_ao_clk81\", \"fclk_div4\", \"fclk_div5\"\n};\n\nstatic const struct meson_pwm_data pwm_axg_ao_data = {\n\t.parent_names = pwm_axg_ao_parent_names,\n\t.num_parents = ARRAY_SIZE(pwm_axg_ao_parent_names),\n};\n\nstatic const char * const pwm_g12a_ao_ab_parent_names[] = {\n\t\"xtal\", \"g12a_ao_clk81\", \"fclk_div4\", \"fclk_div5\"\n};\n\nstatic const struct meson_pwm_data pwm_g12a_ao_ab_data = {\n\t.parent_names = pwm_g12a_ao_ab_parent_names,\n\t.num_parents = ARRAY_SIZE(pwm_g12a_ao_ab_parent_names),\n};\n\nstatic const char * const pwm_g12a_ao_cd_parent_names[] = {\n\t\"xtal\", \"g12a_ao_clk81\",\n};\n\nstatic const struct meson_pwm_data pwm_g12a_ao_cd_data = {\n\t.parent_names = pwm_g12a_ao_cd_parent_names,\n\t.num_parents = ARRAY_SIZE(pwm_g12a_ao_cd_parent_names),\n};\n\nstatic const struct of_device_id meson_pwm_matches[] = {\n\t{\n\t\t.compatible = \"amlogic,meson8b-pwm\",\n\t\t.data = &pwm_meson8b_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-gxbb-pwm\",\n\t\t.data = &pwm_meson8b_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-gxbb-ao-pwm\",\n\t\t.data = &pwm_gxbb_ao_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-axg-ee-pwm\",\n\t\t.data = &pwm_axg_ee_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-axg-ao-pwm\",\n\t\t.data = &pwm_axg_ao_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-ee-pwm\",\n\t\t.data = &pwm_meson8b_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-ao-pwm-ab\",\n\t\t.data = &pwm_g12a_ao_ab_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-ao-pwm-cd\",\n\t\t.data = &pwm_g12a_ao_cd_data\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, meson_pwm_matches);\n\nstatic int meson_pwm_init_channels(struct meson_pwm *meson)\n{\n\tstruct clk_parent_data mux_parent_data[MESON_MAX_MUX_PARENTS] = {};\n\tstruct device *dev = meson->chip.dev;\n\tunsigned int i;\n\tchar name[255];\n\tint err;\n\n\tfor (i = 0; i < meson->data->num_parents; i++) {\n\t\tmux_parent_data[i].index = -1;\n\t\tmux_parent_data[i].name = meson->data->parent_names[i];\n\t}\n\n\tfor (i = 0; i < meson->chip.npwm; i++) {\n\t\tstruct meson_pwm_channel *channel = &meson->channels[i];\n\t\tstruct clk_parent_data div_parent = {}, gate_parent = {};\n\t\tstruct clk_init_data init = {};\n\n\t\tsnprintf(name, sizeof(name), \"%s#mux%u\", dev_name(dev), i);\n\n\t\tinit.name = name;\n\t\tinit.ops = &clk_mux_ops;\n\t\tinit.flags = 0;\n\t\tinit.parent_data = mux_parent_data;\n\t\tinit.num_parents = meson->data->num_parents;\n\n\t\tchannel->mux.reg = meson->base + REG_MISC_AB;\n\t\tchannel->mux.shift =\n\t\t\t\tmeson_pwm_per_channel_data[i].clk_sel_shift;\n\t\tchannel->mux.mask = MISC_CLK_SEL_MASK;\n\t\tchannel->mux.flags = 0;\n\t\tchannel->mux.lock = &meson->lock;\n\t\tchannel->mux.table = NULL;\n\t\tchannel->mux.hw.init = &init;\n\n\t\terr = devm_clk_hw_register(dev, &channel->mux.hw);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to register %s: %d\\n\", name, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"%s#div%u\", dev_name(dev), i);\n\n\t\tinit.name = name;\n\t\tinit.ops = &clk_divider_ops;\n\t\tinit.flags = CLK_SET_RATE_PARENT;\n\t\tdiv_parent.index = -1;\n\t\tdiv_parent.hw = &channel->mux.hw;\n\t\tinit.parent_data = &div_parent;\n\t\tinit.num_parents = 1;\n\n\t\tchannel->div.reg = meson->base + REG_MISC_AB;\n\t\tchannel->div.shift = meson_pwm_per_channel_data[i].clk_div_shift;\n\t\tchannel->div.width = MISC_CLK_DIV_WIDTH;\n\t\tchannel->div.hw.init = &init;\n\t\tchannel->div.flags = 0;\n\t\tchannel->div.lock = &meson->lock;\n\n\t\terr = devm_clk_hw_register(dev, &channel->div.hw);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to register %s: %d\\n\", name, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"%s#gate%u\", dev_name(dev), i);\n\n\t\tinit.name = name;\n\t\tinit.ops = &clk_gate_ops;\n\t\tinit.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED;\n\t\tgate_parent.index = -1;\n\t\tgate_parent.hw = &channel->div.hw;\n\t\tinit.parent_data = &gate_parent;\n\t\tinit.num_parents = 1;\n\n\t\tchannel->gate.reg = meson->base + REG_MISC_AB;\n\t\tchannel->gate.bit_idx = meson_pwm_per_channel_data[i].clk_en_shift;\n\t\tchannel->gate.hw.init = &init;\n\t\tchannel->gate.flags = 0;\n\t\tchannel->gate.lock = &meson->lock;\n\n\t\terr = devm_clk_hw_register(dev, &channel->gate.hw);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to register %s: %d\\n\", name, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tchannel->clk = devm_clk_hw_get_clk(dev, &channel->gate.hw, NULL);\n\t\tif (IS_ERR(channel->clk)) {\n\t\t\terr = PTR_ERR(channel->clk);\n\t\t\tdev_err(dev, \"failed to register %s: %d\\n\", name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_pwm_probe(struct platform_device *pdev)\n{\n\tstruct meson_pwm *meson;\n\tint err;\n\n\tmeson = devm_kzalloc(&pdev->dev, sizeof(*meson), GFP_KERNEL);\n\tif (!meson)\n\t\treturn -ENOMEM;\n\n\tmeson->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(meson->base))\n\t\treturn PTR_ERR(meson->base);\n\n\tspin_lock_init(&meson->lock);\n\tmeson->chip.dev = &pdev->dev;\n\tmeson->chip.ops = &meson_pwm_ops;\n\tmeson->chip.npwm = MESON_NUM_PWMS;\n\n\tmeson->data = of_device_get_match_data(&pdev->dev);\n\n\terr = meson_pwm_init_channels(meson);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_pwmchip_add(&pdev->dev, &meson->chip);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register PWM chip: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver meson_pwm_driver = {\n\t.driver = {\n\t\t.name = \"meson-pwm\",\n\t\t.of_match_table = meson_pwm_matches,\n\t},\n\t.probe = meson_pwm_probe,\n};\nmodule_platform_driver(meson_pwm_driver);\n\nMODULE_DESCRIPTION(\"Amlogic Meson PWM Generator driver\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}