{
  "module_name": "pwm-sprd.c",
  "hash_id": "e18164e5c835d2e26bb189f32bf623cfc5f8ccb1e34defc1e59d81dd33289025",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-sprd.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/math64.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n#define SPRD_PWM_PRESCALE\t0x0\n#define SPRD_PWM_MOD\t\t0x4\n#define SPRD_PWM_DUTY\t\t0x8\n#define SPRD_PWM_ENABLE\t\t0x18\n\n#define SPRD_PWM_MOD_MAX\tGENMASK(7, 0)\n#define SPRD_PWM_DUTY_MSK\tGENMASK(15, 0)\n#define SPRD_PWM_PRESCALE_MSK\tGENMASK(7, 0)\n#define SPRD_PWM_ENABLE_BIT\tBIT(0)\n\n#define SPRD_PWM_CHN_NUM\t4\n#define SPRD_PWM_REGS_SHIFT\t5\n#define SPRD_PWM_CHN_CLKS_NUM\t2\n#define SPRD_PWM_CHN_OUTPUT_CLK\t1\n\nstruct sprd_pwm_chn {\n\tstruct clk_bulk_data clks[SPRD_PWM_CHN_CLKS_NUM];\n\tu32 clk_rate;\n};\n\nstruct sprd_pwm_chip {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct pwm_chip chip;\n\tint num_pwms;\n\tstruct sprd_pwm_chn chn[SPRD_PWM_CHN_NUM];\n};\n\n \nstatic const char * const sprd_pwm_clks[] = {\n\t\"enable0\", \"pwm0\",\n\t\"enable1\", \"pwm1\",\n\t\"enable2\", \"pwm2\",\n\t\"enable3\", \"pwm3\",\n};\n\nstatic u32 sprd_pwm_read(struct sprd_pwm_chip *spc, u32 hwid, u32 reg)\n{\n\tu32 offset = reg + (hwid << SPRD_PWM_REGS_SHIFT);\n\n\treturn readl_relaxed(spc->base + offset);\n}\n\nstatic void sprd_pwm_write(struct sprd_pwm_chip *spc, u32 hwid,\n\t\t\t   u32 reg, u32 val)\n{\n\tu32 offset = reg + (hwid << SPRD_PWM_REGS_SHIFT);\n\n\twritel_relaxed(val, spc->base + offset);\n}\n\nstatic int sprd_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      struct pwm_state *state)\n{\n\tstruct sprd_pwm_chip *spc =\n\t\tcontainer_of(chip, struct sprd_pwm_chip, chip);\n\tstruct sprd_pwm_chn *chn = &spc->chn[pwm->hwpwm];\n\tu32 val, duty, prescale;\n\tu64 tmp;\n\tint ret;\n\n\t \n\tret = clk_bulk_prepare_enable(SPRD_PWM_CHN_CLKS_NUM, chn->clks);\n\tif (ret) {\n\t\tdev_err(spc->dev, \"failed to enable pwm%u clocks\\n\",\n\t\t\tpwm->hwpwm);\n\t\treturn ret;\n\t}\n\n\tval = sprd_pwm_read(spc, pwm->hwpwm, SPRD_PWM_ENABLE);\n\tif (val & SPRD_PWM_ENABLE_BIT)\n\t\tstate->enabled = true;\n\telse\n\t\tstate->enabled = false;\n\n\t \n\tval = sprd_pwm_read(spc, pwm->hwpwm, SPRD_PWM_PRESCALE);\n\tprescale = val & SPRD_PWM_PRESCALE_MSK;\n\ttmp = (prescale + 1) * NSEC_PER_SEC * SPRD_PWM_MOD_MAX;\n\tstate->period = DIV_ROUND_CLOSEST_ULL(tmp, chn->clk_rate);\n\n\tval = sprd_pwm_read(spc, pwm->hwpwm, SPRD_PWM_DUTY);\n\tduty = val & SPRD_PWM_DUTY_MSK;\n\ttmp = (prescale + 1) * NSEC_PER_SEC * duty;\n\tstate->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, chn->clk_rate);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\t \n\tif (!state->enabled)\n\t\tclk_bulk_disable_unprepare(SPRD_PWM_CHN_CLKS_NUM, chn->clks);\n\n\treturn 0;\n}\n\nstatic int sprd_pwm_config(struct sprd_pwm_chip *spc, struct pwm_device *pwm,\n\t\t\t   int duty_ns, int period_ns)\n{\n\tstruct sprd_pwm_chn *chn = &spc->chn[pwm->hwpwm];\n\tu32 prescale, duty;\n\tu64 tmp;\n\n\t \n\tduty = duty_ns * SPRD_PWM_MOD_MAX / period_ns;\n\n\ttmp = (u64)chn->clk_rate * period_ns;\n\tdo_div(tmp, NSEC_PER_SEC);\n\tprescale = DIV_ROUND_CLOSEST_ULL(tmp, SPRD_PWM_MOD_MAX) - 1;\n\tif (prescale > SPRD_PWM_PRESCALE_MSK)\n\t\tprescale = SPRD_PWM_PRESCALE_MSK;\n\n\t \n\tsprd_pwm_write(spc, pwm->hwpwm, SPRD_PWM_PRESCALE, prescale);\n\tsprd_pwm_write(spc, pwm->hwpwm, SPRD_PWM_MOD, SPRD_PWM_MOD_MAX);\n\tsprd_pwm_write(spc, pwm->hwpwm, SPRD_PWM_DUTY, duty);\n\n\treturn 0;\n}\n\nstatic int sprd_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  const struct pwm_state *state)\n{\n\tstruct sprd_pwm_chip *spc =\n\t\tcontainer_of(chip, struct sprd_pwm_chip, chip);\n\tstruct sprd_pwm_chn *chn = &spc->chn[pwm->hwpwm];\n\tstruct pwm_state *cstate = &pwm->state;\n\tint ret;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (state->enabled) {\n\t\tif (!cstate->enabled) {\n\t\t\t \n\t\t\tret = clk_bulk_prepare_enable(SPRD_PWM_CHN_CLKS_NUM,\n\t\t\t\t\t\t      chn->clks);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(spc->dev,\n\t\t\t\t\t\"failed to enable pwm%u clocks\\n\",\n\t\t\t\t\tpwm->hwpwm);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = sprd_pwm_config(spc, pwm, state->duty_cycle,\n\t\t\t\t      state->period);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsprd_pwm_write(spc, pwm->hwpwm, SPRD_PWM_ENABLE, 1);\n\t} else if (cstate->enabled) {\n\t\t \n\t\tsprd_pwm_write(spc, pwm->hwpwm, SPRD_PWM_ENABLE, 0);\n\n\t\tclk_bulk_disable_unprepare(SPRD_PWM_CHN_CLKS_NUM, chn->clks);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops sprd_pwm_ops = {\n\t.apply = sprd_pwm_apply,\n\t.get_state = sprd_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic int sprd_pwm_clk_init(struct sprd_pwm_chip *spc)\n{\n\tstruct clk *clk_pwm;\n\tint ret, i;\n\n\tfor (i = 0; i < SPRD_PWM_CHN_NUM; i++) {\n\t\tstruct sprd_pwm_chn *chn = &spc->chn[i];\n\t\tint j;\n\n\t\tfor (j = 0; j < SPRD_PWM_CHN_CLKS_NUM; ++j)\n\t\t\tchn->clks[j].id =\n\t\t\t\tsprd_pwm_clks[i * SPRD_PWM_CHN_CLKS_NUM + j];\n\n\t\tret = devm_clk_bulk_get(spc->dev, SPRD_PWM_CHN_CLKS_NUM,\n\t\t\t\t\tchn->clks);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOENT)\n\t\t\t\tbreak;\n\n\t\t\treturn dev_err_probe(spc->dev, ret,\n\t\t\t\t\t     \"failed to get channel clocks\\n\");\n\t\t}\n\n\t\tclk_pwm = chn->clks[SPRD_PWM_CHN_OUTPUT_CLK].clk;\n\t\tchn->clk_rate = clk_get_rate(clk_pwm);\n\t}\n\n\tif (!i) {\n\t\tdev_err(spc->dev, \"no available PWM channels\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspc->num_pwms = i;\n\n\treturn 0;\n}\n\nstatic int sprd_pwm_probe(struct platform_device *pdev)\n{\n\tstruct sprd_pwm_chip *spc;\n\tint ret;\n\n\tspc = devm_kzalloc(&pdev->dev, sizeof(*spc), GFP_KERNEL);\n\tif (!spc)\n\t\treturn -ENOMEM;\n\n\tspc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(spc->base))\n\t\treturn PTR_ERR(spc->base);\n\n\tspc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, spc);\n\n\tret = sprd_pwm_clk_init(spc);\n\tif (ret)\n\t\treturn ret;\n\n\tspc->chip.dev = &pdev->dev;\n\tspc->chip.ops = &sprd_pwm_ops;\n\tspc->chip.npwm = spc->num_pwms;\n\n\tret = pwmchip_add(&spc->chip);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip\\n\");\n\n\treturn ret;\n}\n\nstatic void sprd_pwm_remove(struct platform_device *pdev)\n{\n\tstruct sprd_pwm_chip *spc = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&spc->chip);\n}\n\nstatic const struct of_device_id sprd_pwm_of_match[] = {\n\t{ .compatible = \"sprd,ums512-pwm\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sprd_pwm_of_match);\n\nstatic struct platform_driver sprd_pwm_driver = {\n\t.driver = {\n\t\t.name = \"sprd-pwm\",\n\t\t.of_match_table = sprd_pwm_of_match,\n\t},\n\t.probe = sprd_pwm_probe,\n\t.remove_new = sprd_pwm_remove,\n};\n\nmodule_platform_driver(sprd_pwm_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum PWM Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}