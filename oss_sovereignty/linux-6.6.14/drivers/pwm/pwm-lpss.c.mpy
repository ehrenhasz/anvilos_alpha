{
  "module_name": "pwm-lpss.c",
  "hash_id": "f770218c15e27e5fecad644b03a55ececa3103d33115ca895561067ecb65e265",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-lpss.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/time.h>\n\n#define DEFAULT_SYMBOL_NAMESPACE PWM_LPSS\n\n#include \"pwm-lpss.h\"\n\n#define PWM\t\t\t\t0x00000000\n#define PWM_ENABLE\t\t\tBIT(31)\n#define PWM_SW_UPDATE\t\t\tBIT(30)\n#define PWM_BASE_UNIT_SHIFT\t\t8\n#define PWM_ON_TIME_DIV_MASK\t\tGENMASK(7, 0)\n\n \n#define PWM_SIZE\t\t\t0x400\n\n \nconst struct pwm_lpss_boardinfo pwm_lpss_byt_info = {\n\t.clk_rate = 25000000,\n\t.npwm = 1,\n\t.base_unit_bits = 16,\n};\nEXPORT_SYMBOL_GPL(pwm_lpss_byt_info);\n\n \nconst struct pwm_lpss_boardinfo pwm_lpss_bsw_info = {\n\t.clk_rate = 19200000,\n\t.npwm = 1,\n\t.base_unit_bits = 16,\n\t.other_devices_aml_touches_pwm_regs = true,\n};\nEXPORT_SYMBOL_GPL(pwm_lpss_bsw_info);\n\n \nconst struct pwm_lpss_boardinfo pwm_lpss_bxt_info = {\n\t.clk_rate = 19200000,\n\t.npwm = 4,\n\t.base_unit_bits = 22,\n\t.bypass = true,\n};\nEXPORT_SYMBOL_GPL(pwm_lpss_bxt_info);\n\n \nconst struct pwm_lpss_boardinfo pwm_lpss_tng_info = {\n\t.clk_rate = 19200000,\n\t.npwm = 4,\n\t.base_unit_bits = 22,\n};\nEXPORT_SYMBOL_GPL(pwm_lpss_tng_info);\n\nstatic inline struct pwm_lpss_chip *to_lpwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct pwm_lpss_chip, chip);\n}\n\nstatic inline u32 pwm_lpss_read(const struct pwm_device *pwm)\n{\n\tstruct pwm_lpss_chip *lpwm = to_lpwm(pwm->chip);\n\n\treturn readl(lpwm->regs + pwm->hwpwm * PWM_SIZE + PWM);\n}\n\nstatic inline void pwm_lpss_write(const struct pwm_device *pwm, u32 value)\n{\n\tstruct pwm_lpss_chip *lpwm = to_lpwm(pwm->chip);\n\n\twritel(value, lpwm->regs + pwm->hwpwm * PWM_SIZE + PWM);\n}\n\nstatic int pwm_lpss_wait_for_update(struct pwm_device *pwm)\n{\n\tstruct pwm_lpss_chip *lpwm = to_lpwm(pwm->chip);\n\tconst void __iomem *addr = lpwm->regs + pwm->hwpwm * PWM_SIZE + PWM;\n\tconst unsigned int ms = 500 * USEC_PER_MSEC;\n\tu32 val;\n\tint err;\n\n\t \n\terr = readl_poll_timeout(addr, val, !(val & PWM_SW_UPDATE), 40, ms);\n\tif (err)\n\t\tdev_err(pwm->chip->dev, \"PWM_SW_UPDATE was not cleared\\n\");\n\n\treturn err;\n}\n\nstatic inline int pwm_lpss_is_updating(struct pwm_device *pwm)\n{\n\tif (pwm_lpss_read(pwm) & PWM_SW_UPDATE) {\n\t\tdev_err(pwm->chip->dev, \"PWM_SW_UPDATE is still set, skipping update\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void pwm_lpss_prepare(struct pwm_lpss_chip *lpwm, struct pwm_device *pwm,\n\t\t\t     int duty_ns, int period_ns)\n{\n\tunsigned long long on_time_div;\n\tunsigned long c = lpwm->info->clk_rate, base_unit_range;\n\tunsigned long long base_unit, freq = NSEC_PER_SEC;\n\tu32 ctrl;\n\n\tdo_div(freq, period_ns);\n\n\t \n\tbase_unit_range = BIT(lpwm->info->base_unit_bits);\n\tfreq *= base_unit_range;\n\n\tbase_unit = DIV_ROUND_CLOSEST_ULL(freq, c);\n\t \n\tbase_unit = clamp_val(base_unit, 1, base_unit_range - 1);\n\n\ton_time_div = 255ULL * duty_ns;\n\tdo_div(on_time_div, period_ns);\n\ton_time_div = 255ULL - on_time_div;\n\n\tctrl = pwm_lpss_read(pwm);\n\tctrl &= ~PWM_ON_TIME_DIV_MASK;\n\tctrl &= ~((base_unit_range - 1) << PWM_BASE_UNIT_SHIFT);\n\tctrl |= (u32) base_unit << PWM_BASE_UNIT_SHIFT;\n\tctrl |= on_time_div;\n\n\tpwm_lpss_write(pwm, ctrl);\n\tpwm_lpss_write(pwm, ctrl | PWM_SW_UPDATE);\n}\n\nstatic inline void pwm_lpss_cond_enable(struct pwm_device *pwm, bool cond)\n{\n\tif (cond)\n\t\tpwm_lpss_write(pwm, pwm_lpss_read(pwm) | PWM_ENABLE);\n}\n\nstatic int pwm_lpss_prepare_enable(struct pwm_lpss_chip *lpwm,\n\t\t\t\t   struct pwm_device *pwm,\n\t\t\t\t   const struct pwm_state *state)\n{\n\tint ret;\n\n\tret = pwm_lpss_is_updating(pwm);\n\tif (ret)\n\t\treturn ret;\n\n\tpwm_lpss_prepare(lpwm, pwm, state->duty_cycle, state->period);\n\tpwm_lpss_cond_enable(pwm, lpwm->info->bypass == false);\n\tret = pwm_lpss_wait_for_update(pwm);\n\tif (ret)\n\t\treturn ret;\n\n\tpwm_lpss_cond_enable(pwm, lpwm->info->bypass == true);\n\treturn 0;\n}\n\nstatic int pwm_lpss_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  const struct pwm_state *state)\n{\n\tstruct pwm_lpss_chip *lpwm = to_lpwm(chip);\n\tint ret = 0;\n\n\tif (state->enabled) {\n\t\tif (!pwm_is_enabled(pwm)) {\n\t\t\tpm_runtime_get_sync(chip->dev);\n\t\t\tret = pwm_lpss_prepare_enable(lpwm, pwm, state);\n\t\t\tif (ret)\n\t\t\t\tpm_runtime_put(chip->dev);\n\t\t} else {\n\t\t\tret = pwm_lpss_prepare_enable(lpwm, pwm, state);\n\t\t}\n\t} else if (pwm_is_enabled(pwm)) {\n\t\tpwm_lpss_write(pwm, pwm_lpss_read(pwm) & ~PWM_ENABLE);\n\t\tpm_runtime_put(chip->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int pwm_lpss_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      struct pwm_state *state)\n{\n\tstruct pwm_lpss_chip *lpwm = to_lpwm(chip);\n\tunsigned long base_unit_range;\n\tunsigned long long base_unit, freq, on_time_div;\n\tu32 ctrl;\n\n\tpm_runtime_get_sync(chip->dev);\n\n\tbase_unit_range = BIT(lpwm->info->base_unit_bits);\n\n\tctrl = pwm_lpss_read(pwm);\n\ton_time_div = 255 - (ctrl & PWM_ON_TIME_DIV_MASK);\n\tbase_unit = (ctrl >> PWM_BASE_UNIT_SHIFT) & (base_unit_range - 1);\n\n\tfreq = base_unit * lpwm->info->clk_rate;\n\tdo_div(freq, base_unit_range);\n\tif (freq == 0)\n\t\tstate->period = NSEC_PER_SEC;\n\telse\n\t\tstate->period = NSEC_PER_SEC / (unsigned long)freq;\n\n\ton_time_div *= state->period;\n\tdo_div(on_time_div, 255);\n\tstate->duty_cycle = on_time_div;\n\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\tstate->enabled = !!(ctrl & PWM_ENABLE);\n\n\tpm_runtime_put(chip->dev);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops pwm_lpss_ops = {\n\t.apply = pwm_lpss_apply,\n\t.get_state = pwm_lpss_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstruct pwm_lpss_chip *devm_pwm_lpss_probe(struct device *dev, void __iomem *base,\n\t\t\t\t\t  const struct pwm_lpss_boardinfo *info)\n{\n\tstruct pwm_lpss_chip *lpwm;\n\tunsigned long c;\n\tint i, ret;\n\tu32 ctrl;\n\n\tif (WARN_ON(info->npwm > LPSS_MAX_PWMS))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tlpwm = devm_kzalloc(dev, sizeof(*lpwm), GFP_KERNEL);\n\tif (!lpwm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlpwm->regs = base;\n\tlpwm->info = info;\n\n\tc = lpwm->info->clk_rate;\n\tif (!c)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlpwm->chip.dev = dev;\n\tlpwm->chip.ops = &pwm_lpss_ops;\n\tlpwm->chip.npwm = info->npwm;\n\n\tret = devm_pwmchip_add(dev, &lpwm->chip);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add PWM chip: %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tfor (i = 0; i < lpwm->info->npwm; i++) {\n\t\tctrl = pwm_lpss_read(&lpwm->chip.pwms[i]);\n\t\tif (ctrl & PWM_ENABLE)\n\t\t\tpm_runtime_get(dev);\n\t}\n\n\treturn lpwm;\n}\nEXPORT_SYMBOL_GPL(devm_pwm_lpss_probe);\n\nMODULE_DESCRIPTION(\"PWM driver for Intel LPSS\");\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}