{
  "module_name": "pwm-microchip-core.c",
  "hash_id": "d2b2ccf2999e4e60f838d810f3db9b300122c26a56a2916529f1c7c263330690",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-microchip-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/ktime.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n#define MCHPCOREPWM_PRESCALE_MAX\t0xff\n#define MCHPCOREPWM_PERIOD_STEPS_MAX\t0xfe\n#define MCHPCOREPWM_PERIOD_MAX\t\t0xff00\n\n#define MCHPCOREPWM_PRESCALE\t0x00\n#define MCHPCOREPWM_PERIOD\t0x04\n#define MCHPCOREPWM_EN(i)\t(0x08 + 0x04 * (i))  \n#define MCHPCOREPWM_POSEDGE(i)\t(0x10 + 0x08 * (i))  \n#define MCHPCOREPWM_NEGEDGE(i)\t(0x14 + 0x08 * (i))  \n#define MCHPCOREPWM_SYNC_UPD\t0xe4\n#define MCHPCOREPWM_TIMEOUT_MS\t100u\n\nstruct mchp_core_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tstruct mutex lock;  \n\tktime_t update_timestamp;\n\tu32 sync_update_mask;\n\tu16 channel_enabled;\n};\n\nstatic inline struct mchp_core_pwm_chip *to_mchp_core_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct mchp_core_pwm_chip, chip);\n}\n\nstatic void mchp_core_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t bool enable, u64 period)\n{\n\tstruct mchp_core_pwm_chip *mchp_core_pwm = to_mchp_core_pwm(chip);\n\tu8 channel_enable, reg_offset, shift;\n\n\t \n\treg_offset = MCHPCOREPWM_EN(pwm->hwpwm >> 3);\n\tshift = pwm->hwpwm & 7;\n\n\tchannel_enable = readb_relaxed(mchp_core_pwm->base + reg_offset);\n\tchannel_enable &= ~(1 << shift);\n\tchannel_enable |= (enable << shift);\n\n\twritel_relaxed(channel_enable, mchp_core_pwm->base + reg_offset);\n\tmchp_core_pwm->channel_enabled &= ~BIT(pwm->hwpwm);\n\tmchp_core_pwm->channel_enabled |= enable << pwm->hwpwm;\n\n\t \n\tif (mchp_core_pwm->sync_update_mask & (1 << pwm->hwpwm))\n\t\tmchp_core_pwm->update_timestamp = ktime_add_ns(ktime_get(), period);\n}\n\nstatic void mchp_core_pwm_wait_for_sync_update(struct mchp_core_pwm_chip *mchp_core_pwm,\n\t\t\t\t\t       unsigned int channel)\n{\n\t \n\n\tif (mchp_core_pwm->sync_update_mask & (1 << channel)) {\n\t\tktime_t current_time = ktime_get();\n\t\ts64 remaining_ns;\n\t\tu32 delay_us;\n\n\t\tremaining_ns = ktime_to_ns(ktime_sub(mchp_core_pwm->update_timestamp,\n\t\t\t\t\t\t     current_time));\n\n\t\t \n\t\tif (remaining_ns <= 0)\n\t\t\treturn;\n\n\t\tdelay_us = DIV_ROUND_UP_ULL(remaining_ns, NSEC_PER_USEC);\n\t\tfsleep(delay_us);\n\t}\n}\n\nstatic u64 mchp_core_pwm_calc_duty(const struct pwm_state *state, u64 clk_rate,\n\t\t\t\t   u8 prescale, u8 period_steps)\n{\n\tu64 duty_steps, tmp;\n\n\t \n\ttmp = (((u64)prescale) + 1) * NSEC_PER_SEC;\n\tduty_steps = mul_u64_u64_div_u64(state->duty_cycle, clk_rate, tmp);\n\n\treturn duty_steps;\n}\n\nstatic void mchp_core_pwm_apply_duty(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t     const struct pwm_state *state, u64 duty_steps,\n\t\t\t\t     u16 period_steps)\n{\n\tstruct mchp_core_pwm_chip *mchp_core_pwm = to_mchp_core_pwm(chip);\n\tu8 posedge, negedge;\n\tu8 first_edge = 0, second_edge = duty_steps;\n\n\t \n\tif (duty_steps == 0)\n\t\tfirst_edge = period_steps + 1;\n\n\tif (state->polarity == PWM_POLARITY_INVERSED) {\n\t\tnegedge = first_edge;\n\t\tposedge = second_edge;\n\t} else {\n\t\tposedge = first_edge;\n\t\tnegedge = second_edge;\n\t}\n\n\t \n\twritel_relaxed(posedge, mchp_core_pwm->base + MCHPCOREPWM_POSEDGE(pwm->hwpwm));\n\twritel_relaxed(negedge, mchp_core_pwm->base + MCHPCOREPWM_NEGEDGE(pwm->hwpwm));\n}\n\nstatic int mchp_core_pwm_calc_period(const struct pwm_state *state, unsigned long clk_rate,\n\t\t\t\t     u16 *prescale, u16 *period_steps)\n{\n\tu64 tmp;\n\n\t \n\ttmp = mul_u64_u64_div_u64(state->period, clk_rate, NSEC_PER_SEC);\n\tif (tmp >= MCHPCOREPWM_PERIOD_MAX) {\n\t\t*prescale = MCHPCOREPWM_PRESCALE_MAX;\n\t\t*period_steps = MCHPCOREPWM_PERIOD_STEPS_MAX;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (tmp < MCHPCOREPWM_PERIOD_STEPS_MAX + 1)\n\t\treturn -EINVAL;\n\n\t \n\t*prescale = ((u16)tmp) / (MCHPCOREPWM_PERIOD_STEPS_MAX + 1) - 1;\n\n\t \n\t*period_steps = MCHPCOREPWM_PERIOD_STEPS_MAX;\n\n\treturn 0;\n}\n\nstatic int mchp_core_pwm_apply_locked(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t      const struct pwm_state *state)\n{\n\tstruct mchp_core_pwm_chip *mchp_core_pwm = to_mchp_core_pwm(chip);\n\tbool period_locked;\n\tunsigned long clk_rate;\n\tu64 duty_steps;\n\tu16 prescale, period_steps;\n\tint ret;\n\n\tif (!state->enabled) {\n\t\tmchp_core_pwm_enable(chip, pwm, false, pwm->state.period);\n\t\treturn 0;\n\t}\n\n\t \n\tclk_rate = clk_get_rate(mchp_core_pwm->clk);\n\tif (clk_rate >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\tret = mchp_core_pwm_calc_period(state, clk_rate, &prescale, &period_steps);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tperiod_locked = mchp_core_pwm->channel_enabled & ~(1 << pwm->hwpwm);\n\n\tif (period_locked) {\n\t\tu16 hw_prescale;\n\t\tu16 hw_period_steps;\n\n\t\thw_prescale = readb_relaxed(mchp_core_pwm->base + MCHPCOREPWM_PRESCALE);\n\t\thw_period_steps = readb_relaxed(mchp_core_pwm->base + MCHPCOREPWM_PERIOD);\n\n\t\tif ((period_steps + 1) * (prescale + 1) <\n\t\t    (hw_period_steps + 1) * (hw_prescale + 1))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (hw_period_steps == MCHPCOREPWM_PERIOD_STEPS_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tprescale = hw_prescale;\n\t\tperiod_steps = hw_period_steps;\n\t}\n\n\tduty_steps = mchp_core_pwm_calc_duty(state, clk_rate, prescale, period_steps);\n\n\t \n\tif (duty_steps > period_steps)\n\t\tduty_steps = period_steps + 1;\n\n\tif (!period_locked) {\n\t\twritel_relaxed(prescale, mchp_core_pwm->base + MCHPCOREPWM_PRESCALE);\n\t\twritel_relaxed(period_steps, mchp_core_pwm->base + MCHPCOREPWM_PERIOD);\n\t}\n\n\tmchp_core_pwm_apply_duty(chip, pwm, state, duty_steps, period_steps);\n\n\tmchp_core_pwm_enable(chip, pwm, true, pwm->state.period);\n\n\treturn 0;\n}\n\nstatic int mchp_core_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       const struct pwm_state *state)\n{\n\tstruct mchp_core_pwm_chip *mchp_core_pwm = to_mchp_core_pwm(chip);\n\tint ret;\n\n\tmutex_lock(&mchp_core_pwm->lock);\n\n\tmchp_core_pwm_wait_for_sync_update(mchp_core_pwm, pwm->hwpwm);\n\n\tret = mchp_core_pwm_apply_locked(chip, pwm, state);\n\n\tmutex_unlock(&mchp_core_pwm->lock);\n\n\treturn ret;\n}\n\nstatic int mchp_core_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t   struct pwm_state *state)\n{\n\tstruct mchp_core_pwm_chip *mchp_core_pwm = to_mchp_core_pwm(chip);\n\tu64 rate;\n\tu16 prescale, period_steps;\n\tu8 duty_steps, posedge, negedge;\n\n\tmutex_lock(&mchp_core_pwm->lock);\n\n\tmchp_core_pwm_wait_for_sync_update(mchp_core_pwm, pwm->hwpwm);\n\n\tif (mchp_core_pwm->channel_enabled & (1 << pwm->hwpwm))\n\t\tstate->enabled = true;\n\telse\n\t\tstate->enabled = false;\n\n\trate = clk_get_rate(mchp_core_pwm->clk);\n\n\t \n\tprescale = readb_relaxed(mchp_core_pwm->base + MCHPCOREPWM_PRESCALE);\n\tperiod_steps = readb_relaxed(mchp_core_pwm->base + MCHPCOREPWM_PERIOD);\n\n\tstate->period = (period_steps + 1) * (prescale + 1);\n\tstate->period *= NSEC_PER_SEC;\n\tstate->period = DIV64_U64_ROUND_UP(state->period, rate);\n\n\tposedge = readb_relaxed(mchp_core_pwm->base + MCHPCOREPWM_POSEDGE(pwm->hwpwm));\n\tnegedge = readb_relaxed(mchp_core_pwm->base + MCHPCOREPWM_NEGEDGE(pwm->hwpwm));\n\n\tmutex_unlock(&mchp_core_pwm->lock);\n\n\tif (negedge == posedge) {\n\t\tstate->duty_cycle = state->period;\n\t\tstate->period *= 2;\n\t} else {\n\t\tduty_steps = abs((s16)posedge - (s16)negedge);\n\t\tstate->duty_cycle = duty_steps * (prescale + 1) * NSEC_PER_SEC;\n\t\tstate->duty_cycle = DIV64_U64_ROUND_UP(state->duty_cycle, rate);\n\t}\n\n\tstate->polarity = negedge < posedge ? PWM_POLARITY_INVERSED : PWM_POLARITY_NORMAL;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops mchp_core_pwm_ops = {\n\t.apply = mchp_core_pwm_apply,\n\t.get_state = mchp_core_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id mchp_core_of_match[] = {\n\t{\n\t\t.compatible = \"microchip,corepwm-rtl-v4\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mchp_core_of_match);\n\nstatic int mchp_core_pwm_probe(struct platform_device *pdev)\n{\n\tstruct mchp_core_pwm_chip *mchp_core_pwm;\n\tstruct resource *regs;\n\tint ret;\n\n\tmchp_core_pwm = devm_kzalloc(&pdev->dev, sizeof(*mchp_core_pwm), GFP_KERNEL);\n\tif (!mchp_core_pwm)\n\t\treturn -ENOMEM;\n\n\tmchp_core_pwm->base = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);\n\tif (IS_ERR(mchp_core_pwm->base))\n\t\treturn PTR_ERR(mchp_core_pwm->base);\n\n\tmchp_core_pwm->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(mchp_core_pwm->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(mchp_core_pwm->clk),\n\t\t\t\t     \"failed to get PWM clock\\n\");\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"microchip,sync-update-mask\",\n\t\t\t\t &mchp_core_pwm->sync_update_mask))\n\t\tmchp_core_pwm->sync_update_mask = 0;\n\n\tmutex_init(&mchp_core_pwm->lock);\n\n\tmchp_core_pwm->chip.dev = &pdev->dev;\n\tmchp_core_pwm->chip.ops = &mchp_core_pwm_ops;\n\tmchp_core_pwm->chip.npwm = 16;\n\n\tmchp_core_pwm->channel_enabled = readb_relaxed(mchp_core_pwm->base + MCHPCOREPWM_EN(0));\n\tmchp_core_pwm->channel_enabled |=\n\t\treadb_relaxed(mchp_core_pwm->base + MCHPCOREPWM_EN(1)) << 8;\n\n\t \n\twritel_relaxed(1U, mchp_core_pwm->base + MCHPCOREPWM_SYNC_UPD);\n\tmchp_core_pwm->update_timestamp = ktime_get();\n\n\tret = devm_pwmchip_add(&pdev->dev, &mchp_core_pwm->chip);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to add pwmchip\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver mchp_core_pwm_driver = {\n\t.driver = {\n\t\t.name = \"mchp-core-pwm\",\n\t\t.of_match_table = mchp_core_of_match,\n\t},\n\t.probe = mchp_core_pwm_probe,\n};\nmodule_platform_driver(mchp_core_pwm_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\nMODULE_DESCRIPTION(\"corePWM driver for Microchip FPGAs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}