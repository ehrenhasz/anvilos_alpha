{
  "module_name": "pwm-clk.c",
  "hash_id": "41581084747819c56e03a7dd08f09dd516245f958ff0089e8090fb5f4cf2c70e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-clk.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/pwm.h>\n\nstruct pwm_clk_chip {\n\tstruct pwm_chip chip;\n\tstruct clk *clk;\n\tbool clk_enabled;\n};\n\n#define to_pwm_clk_chip(_chip) container_of(_chip, struct pwm_clk_chip, chip)\n\nstatic int pwm_clk_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tstruct pwm_clk_chip *pcchip = to_pwm_clk_chip(chip);\n\tint ret;\n\tu32 rate;\n\tu64 period = state->period;\n\tu64 duty_cycle = state->duty_cycle;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled) {\n\t\t\tclk_disable(pcchip->clk);\n\t\t\tpcchip->clk_enabled = false;\n\t\t}\n\t\treturn 0;\n\t} else if (!pwm->state.enabled) {\n\t\tret = clk_enable(pcchip->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpcchip->clk_enabled = true;\n\t}\n\n\t \n\n\trate = DIV64_U64_ROUND_UP(NSEC_PER_SEC, period);\n\tret = clk_set_rate(pcchip->clk, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state->polarity == PWM_POLARITY_INVERSED)\n\t\tduty_cycle = period - duty_cycle;\n\n\treturn clk_set_duty_cycle(pcchip->clk, duty_cycle, period);\n}\n\nstatic const struct pwm_ops pwm_clk_ops = {\n\t.apply = pwm_clk_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pwm_clk_probe(struct platform_device *pdev)\n{\n\tstruct pwm_clk_chip *pcchip;\n\tint ret;\n\n\tpcchip = devm_kzalloc(&pdev->dev, sizeof(*pcchip), GFP_KERNEL);\n\tif (!pcchip)\n\t\treturn -ENOMEM;\n\n\tpcchip->clk = devm_clk_get_prepared(&pdev->dev, NULL);\n\tif (IS_ERR(pcchip->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(pcchip->clk),\n\t\t\t\t     \"Failed to get clock\\n\");\n\n\tpcchip->chip.dev = &pdev->dev;\n\tpcchip->chip.ops = &pwm_clk_ops;\n\tpcchip->chip.npwm = 1;\n\n\tret = pwmchip_add(&pcchip->chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to add pwm chip\\n\");\n\n\tplatform_set_drvdata(pdev, pcchip);\n\treturn 0;\n}\n\nstatic void pwm_clk_remove(struct platform_device *pdev)\n{\n\tstruct pwm_clk_chip *pcchip = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&pcchip->chip);\n\n\tif (pcchip->clk_enabled)\n\t\tclk_disable(pcchip->clk);\n}\n\nstatic const struct of_device_id pwm_clk_dt_ids[] = {\n\t{ .compatible = \"clk-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pwm_clk_dt_ids);\n\nstatic struct platform_driver pwm_clk_driver = {\n\t.driver = {\n\t\t.name = \"pwm-clk\",\n\t\t.of_match_table = pwm_clk_dt_ids,\n\t},\n\t.probe = pwm_clk_probe,\n\t.remove_new = pwm_clk_remove,\n};\nmodule_platform_driver(pwm_clk_driver);\n\nMODULE_ALIAS(\"platform:pwm-clk\");\nMODULE_AUTHOR(\"Nikita Travkin <nikita@trvn.ru>\");\nMODULE_DESCRIPTION(\"Clock based PWM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}