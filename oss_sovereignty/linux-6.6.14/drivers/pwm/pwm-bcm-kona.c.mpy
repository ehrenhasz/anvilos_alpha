{
  "module_name": "pwm-bcm-kona.c",
  "hash_id": "44ee5674a74b1a60cdb64ae7c4c5e1e3f64fffe00eef22c4cff1c0a0ca54722a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-bcm-kona.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n\n#define PWM_CONTROL_OFFSET\t\t\t0x00000000\n#define PWM_CONTROL_SMOOTH_SHIFT(chan)\t\t(24 + (chan))\n#define PWM_CONTROL_TYPE_SHIFT(chan)\t\t(16 + (chan))\n#define PWM_CONTROL_POLARITY_SHIFT(chan)\t(8 + (chan))\n#define PWM_CONTROL_TRIGGER_SHIFT(chan)\t\t(chan)\n\n#define PRESCALE_OFFSET\t\t\t\t0x00000004\n#define PRESCALE_SHIFT(chan)\t\t\t((chan) << 2)\n#define PRESCALE_MASK(chan)\t\t\t(0x7 << PRESCALE_SHIFT(chan))\n#define PRESCALE_MIN\t\t\t\t0x00000000\n#define PRESCALE_MAX\t\t\t\t0x00000007\n\n#define PERIOD_COUNT_OFFSET(chan)\t\t(0x00000008 + ((chan) << 3))\n#define PERIOD_COUNT_MIN\t\t\t0x00000002\n#define PERIOD_COUNT_MAX\t\t\t0x00ffffff\n\n#define DUTY_CYCLE_HIGH_OFFSET(chan)\t\t(0x0000000c + ((chan) << 3))\n#define DUTY_CYCLE_HIGH_MIN\t\t\t0x00000000\n#define DUTY_CYCLE_HIGH_MAX\t\t\t0x00ffffff\n\nstruct kona_pwmc {\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic inline struct kona_pwmc *to_kona_pwmc(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct kona_pwmc, chip);\n}\n\n \nstatic void kona_pwmc_prepare_for_settings(struct kona_pwmc *kp,\n\tunsigned int chan)\n{\n\tunsigned int value = readl(kp->base + PWM_CONTROL_OFFSET);\n\n\tvalue |= 1 << PWM_CONTROL_SMOOTH_SHIFT(chan);\n\tvalue &= ~(1 << PWM_CONTROL_TRIGGER_SHIFT(chan));\n\twritel(value, kp->base + PWM_CONTROL_OFFSET);\n\n\t \n\tndelay(400);\n}\n\nstatic void kona_pwmc_apply_settings(struct kona_pwmc *kp, unsigned int chan)\n{\n\tunsigned int value = readl(kp->base + PWM_CONTROL_OFFSET);\n\n\t \n\tvalue &= ~(1 << PWM_CONTROL_SMOOTH_SHIFT(chan));\n\tvalue |= 1 << PWM_CONTROL_TRIGGER_SHIFT(chan);\n\twritel(value, kp->base + PWM_CONTROL_OFFSET);\n\n\t \n\tndelay(400);\n}\n\nstatic int kona_pwmc_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    u64 duty_ns, u64 period_ns)\n{\n\tstruct kona_pwmc *kp = to_kona_pwmc(chip);\n\tu64 div, rate;\n\tunsigned long prescale = PRESCALE_MIN, pc, dc;\n\tunsigned int value, chan = pwm->hwpwm;\n\n\t \n\n\trate = clk_get_rate(kp->clk);\n\n\twhile (1) {\n\t\tdiv = 1000000000;\n\t\tdiv *= 1 + prescale;\n\t\tpc = mul_u64_u64_div_u64(rate, period_ns, div);\n\t\tdc = mul_u64_u64_div_u64(rate, duty_ns, div);\n\n\t\t \n\t\tif (pc < PERIOD_COUNT_MIN)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (pc <= PERIOD_COUNT_MAX && dc <= DUTY_CYCLE_HIGH_MAX)\n\t\t\tbreak;\n\n\t\t \n\t\tif (++prescale > PRESCALE_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tkona_pwmc_prepare_for_settings(kp, chan);\n\n\tvalue = readl(kp->base + PRESCALE_OFFSET);\n\tvalue &= ~PRESCALE_MASK(chan);\n\tvalue |= prescale << PRESCALE_SHIFT(chan);\n\twritel(value, kp->base + PRESCALE_OFFSET);\n\n\twritel(pc, kp->base + PERIOD_COUNT_OFFSET(chan));\n\n\twritel(dc, kp->base + DUTY_CYCLE_HIGH_OFFSET(chan));\n\n\tkona_pwmc_apply_settings(kp, chan);\n\n\treturn 0;\n}\n\nstatic int kona_pwmc_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t  enum pwm_polarity polarity)\n{\n\tstruct kona_pwmc *kp = to_kona_pwmc(chip);\n\tunsigned int chan = pwm->hwpwm;\n\tunsigned int value;\n\tint ret;\n\n\tret = clk_prepare_enable(kp->clk);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tkona_pwmc_prepare_for_settings(kp, chan);\n\n\tvalue = readl(kp->base + PWM_CONTROL_OFFSET);\n\n\tif (polarity == PWM_POLARITY_NORMAL)\n\t\tvalue |= 1 << PWM_CONTROL_POLARITY_SHIFT(chan);\n\telse\n\t\tvalue &= ~(1 << PWM_CONTROL_POLARITY_SHIFT(chan));\n\n\twritel(value, kp->base + PWM_CONTROL_OFFSET);\n\n\tkona_pwmc_apply_settings(kp, chan);\n\n\tclk_disable_unprepare(kp->clk);\n\n\treturn 0;\n}\n\nstatic int kona_pwmc_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct kona_pwmc *kp = to_kona_pwmc(chip);\n\tint ret;\n\n\tret = clk_prepare_enable(kp->clk);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void kona_pwmc_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct kona_pwmc *kp = to_kona_pwmc(chip);\n\tunsigned int chan = pwm->hwpwm;\n\tunsigned int value;\n\n\tkona_pwmc_prepare_for_settings(kp, chan);\n\n\t \n\twritel(0, kp->base + DUTY_CYCLE_HIGH_OFFSET(chan));\n\twritel(0, kp->base + PERIOD_COUNT_OFFSET(chan));\n\n\t \n\tvalue = readl(kp->base + PRESCALE_OFFSET);\n\tvalue &= ~PRESCALE_MASK(chan);\n\twritel(value, kp->base + PRESCALE_OFFSET);\n\n\tkona_pwmc_apply_settings(kp, chan);\n\n\tclk_disable_unprepare(kp->clk);\n}\n\nstatic int kona_pwmc_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tint err;\n\tstruct kona_pwmc *kp = to_kona_pwmc(chip);\n\tbool enabled = pwm->state.enabled;\n\n\tif (state->polarity != pwm->state.polarity) {\n\t\tif (enabled) {\n\t\t\tkona_pwmc_disable(chip, pwm);\n\t\t\tenabled = false;\n\t\t}\n\n\t\terr = kona_pwmc_set_polarity(chip, pwm, state->polarity);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tpwm->state.polarity = state->polarity;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\tkona_pwmc_disable(chip, pwm);\n\t\treturn 0;\n\t} else if (!enabled) {\n\t\t \n\t\terr = kona_pwmc_enable(chip, pwm);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = kona_pwmc_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err && !pwm->state.enabled)\n\t\tclk_disable_unprepare(kp->clk);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops kona_pwm_ops = {\n\t.apply = kona_pwmc_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int kona_pwmc_probe(struct platform_device *pdev)\n{\n\tstruct kona_pwmc *kp;\n\tunsigned int chan;\n\tunsigned int value = 0;\n\tint ret = 0;\n\n\tkp = devm_kzalloc(&pdev->dev, sizeof(*kp), GFP_KERNEL);\n\tif (kp == NULL)\n\t\treturn -ENOMEM;\n\n\tkp->chip.dev = &pdev->dev;\n\tkp->chip.ops = &kona_pwm_ops;\n\tkp->chip.npwm = 6;\n\n\tkp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(kp->base))\n\t\treturn PTR_ERR(kp->base);\n\n\tkp->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(kp->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock: %ld\\n\",\n\t\t\tPTR_ERR(kp->clk));\n\t\treturn PTR_ERR(kp->clk);\n\t}\n\n\tret = clk_prepare_enable(kp->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (chan = 0; chan < kp->chip.npwm; chan++)\n\t\tvalue |= (1 << PWM_CONTROL_TYPE_SHIFT(chan));\n\n\twritel(value, kp->base + PWM_CONTROL_OFFSET);\n\n\tclk_disable_unprepare(kp->clk);\n\n\tret = devm_pwmchip_add(&pdev->dev, &kp->chip);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id bcm_kona_pwmc_dt[] = {\n\t{ .compatible = \"brcm,kona-pwm\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm_kona_pwmc_dt);\n\nstatic struct platform_driver kona_pwmc_driver = {\n\t.driver = {\n\t\t.name = \"bcm-kona-pwm\",\n\t\t.of_match_table = bcm_kona_pwmc_dt,\n\t},\n\t.probe = kona_pwmc_probe,\n};\nmodule_platform_driver(kona_pwmc_driver);\n\nMODULE_AUTHOR(\"Broadcom Corporation <bcm-kernel-feedback-list@broadcom.com>\");\nMODULE_AUTHOR(\"Tim Kryger <tkryger@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom Kona PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}