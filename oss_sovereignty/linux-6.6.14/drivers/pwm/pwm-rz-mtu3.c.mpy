{
  "module_name": "pwm-rz-mtu3.c",
  "hash_id": "a5646143acfce6bae466377ba557a77ab23e3f14f5f88cd87d8cc56c7568e1b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-rz-mtu3.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/limits.h>\n#include <linux/mfd/rz-mtu3.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n#include <linux/time.h>\n\n#define RZ_MTU3_MAX_PWM_CHANNELS\t12\n#define RZ_MTU3_MAX_HW_CHANNELS\t\t7\n\n \nstruct rz_mtu3_channel_io_map {\n\tu8 base_pwm_number;\n\tu8 num_channel_ios;\n};\n\n \nstruct rz_mtu3_pwm_channel {\n\tstruct rz_mtu3_channel *mtu;\n\tconst struct rz_mtu3_channel_io_map *map;\n};\n\n \n\nstruct rz_mtu3_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct clk *clk;\n\tstruct mutex lock;\n\tunsigned long rate;\n\tu32 user_count[RZ_MTU3_MAX_HW_CHANNELS];\n\tu32 enable_count[RZ_MTU3_MAX_HW_CHANNELS];\n\tu8 prescale[RZ_MTU3_MAX_HW_CHANNELS];\n\tstruct rz_mtu3_pwm_channel channel_data[RZ_MTU3_MAX_HW_CHANNELS];\n};\n\n \nstatic const struct rz_mtu3_channel_io_map channel_map[] = {\n\t{ 0, 2 }, { 2, 1 }, { 3, 1 }, { 4, 2 }, { 6, 2 }, { 8, 2 }, { 10, 2 }\n};\n\nstatic inline struct rz_mtu3_pwm_chip *to_rz_mtu3_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct rz_mtu3_pwm_chip, chip);\n}\n\nstatic void rz_mtu3_pwm_read_tgr_registers(struct rz_mtu3_pwm_channel *priv,\n\t\t\t\t\t   u16 reg_pv_offset, u16 *pv_val,\n\t\t\t\t\t   u16 reg_dc_offset, u16 *dc_val)\n{\n\t*pv_val = rz_mtu3_16bit_ch_read(priv->mtu, reg_pv_offset);\n\t*dc_val = rz_mtu3_16bit_ch_read(priv->mtu, reg_dc_offset);\n}\n\nstatic void rz_mtu3_pwm_write_tgr_registers(struct rz_mtu3_pwm_channel *priv,\n\t\t\t\t\t    u16 reg_pv_offset, u16 pv_val,\n\t\t\t\t\t    u16 reg_dc_offset, u16 dc_val)\n{\n\trz_mtu3_16bit_ch_write(priv->mtu, reg_pv_offset, pv_val);\n\trz_mtu3_16bit_ch_write(priv->mtu, reg_dc_offset, dc_val);\n}\n\nstatic u8 rz_mtu3_pwm_calculate_prescale(struct rz_mtu3_pwm_chip *rz_mtu3,\n\t\t\t\t\t u64 period_cycles)\n{\n\tu32 prescaled_period_cycles;\n\tu8 prescale;\n\n\t \n\tprescaled_period_cycles = period_cycles >> 16;\n\tif (prescaled_period_cycles >= 16)\n\t\tprescale = 3;\n\telse\n\t\tprescale = (fls(prescaled_period_cycles) + 1) / 2;\n\n\treturn prescale;\n}\n\nstatic struct rz_mtu3_pwm_channel *\nrz_mtu3_get_channel(struct rz_mtu3_pwm_chip *rz_mtu3_pwm, u32 hwpwm)\n{\n\tstruct rz_mtu3_pwm_channel *priv = rz_mtu3_pwm->channel_data;\n\tunsigned int ch;\n\n\tfor (ch = 0; ch < RZ_MTU3_MAX_HW_CHANNELS; ch++, priv++) {\n\t\tif (priv->map->base_pwm_number + priv->map->num_channel_ios > hwpwm)\n\t\t\tbreak;\n\t}\n\n\treturn priv;\n}\n\nstatic bool rz_mtu3_pwm_is_ch_enabled(struct rz_mtu3_pwm_chip *rz_mtu3_pwm,\n\t\t\t\t      u32 hwpwm)\n{\n\tstruct rz_mtu3_pwm_channel *priv;\n\tbool is_channel_en;\n\tu8 val;\n\n\tpriv = rz_mtu3_get_channel(rz_mtu3_pwm, hwpwm);\n\tis_channel_en = rz_mtu3_is_enabled(priv->mtu);\n\tif (!is_channel_en)\n\t\treturn false;\n\n\tif (priv->map->base_pwm_number == hwpwm)\n\t\tval = rz_mtu3_8bit_ch_read(priv->mtu, RZ_MTU3_TIORH);\n\telse\n\t\tval = rz_mtu3_8bit_ch_read(priv->mtu, RZ_MTU3_TIORL);\n\n\treturn val & RZ_MTU3_TIOR_IOA;\n}\n\nstatic int rz_mtu3_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm = to_rz_mtu3_pwm_chip(chip);\n\tstruct rz_mtu3_pwm_channel *priv;\n\tbool is_mtu3_channel_available;\n\tu32 ch;\n\n\tpriv = rz_mtu3_get_channel(rz_mtu3_pwm, pwm->hwpwm);\n\tch = priv - rz_mtu3_pwm->channel_data;\n\n\tmutex_lock(&rz_mtu3_pwm->lock);\n\t \n\tif (!rz_mtu3_pwm->user_count[ch]) {\n\t\tis_mtu3_channel_available = rz_mtu3_request_channel(priv->mtu);\n\t\tif (!is_mtu3_channel_available) {\n\t\t\tmutex_unlock(&rz_mtu3_pwm->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\trz_mtu3_pwm->user_count[ch]++;\n\tmutex_unlock(&rz_mtu3_pwm->lock);\n\n\treturn 0;\n}\n\nstatic void rz_mtu3_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm = to_rz_mtu3_pwm_chip(chip);\n\tstruct rz_mtu3_pwm_channel *priv;\n\tu32 ch;\n\n\tpriv = rz_mtu3_get_channel(rz_mtu3_pwm, pwm->hwpwm);\n\tch = priv - rz_mtu3_pwm->channel_data;\n\n\tmutex_lock(&rz_mtu3_pwm->lock);\n\trz_mtu3_pwm->user_count[ch]--;\n\tif (!rz_mtu3_pwm->user_count[ch])\n\t\trz_mtu3_release_channel(priv->mtu);\n\n\tmutex_unlock(&rz_mtu3_pwm->lock);\n}\n\nstatic int rz_mtu3_pwm_enable(struct rz_mtu3_pwm_chip *rz_mtu3_pwm,\n\t\t\t      struct pwm_device *pwm)\n{\n\tstruct rz_mtu3_pwm_channel *priv;\n\tu32 ch;\n\tu8 val;\n\tint rc;\n\n\trc = pm_runtime_resume_and_get(rz_mtu3_pwm->chip.dev);\n\tif (rc)\n\t\treturn rc;\n\n\tpriv = rz_mtu3_get_channel(rz_mtu3_pwm, pwm->hwpwm);\n\tch = priv - rz_mtu3_pwm->channel_data;\n\tval = RZ_MTU3_TIOR_OC_IOB_TOGGLE | RZ_MTU3_TIOR_OC_IOA_H_COMP_MATCH;\n\n\trz_mtu3_8bit_ch_write(priv->mtu, RZ_MTU3_TMDR1, RZ_MTU3_TMDR1_MD_PWMMODE1);\n\tif (priv->map->base_pwm_number == pwm->hwpwm)\n\t\trz_mtu3_8bit_ch_write(priv->mtu, RZ_MTU3_TIORH, val);\n\telse\n\t\trz_mtu3_8bit_ch_write(priv->mtu, RZ_MTU3_TIORL, val);\n\n\tmutex_lock(&rz_mtu3_pwm->lock);\n\tif (!rz_mtu3_pwm->enable_count[ch])\n\t\trz_mtu3_enable(priv->mtu);\n\n\trz_mtu3_pwm->enable_count[ch]++;\n\tmutex_unlock(&rz_mtu3_pwm->lock);\n\n\treturn 0;\n}\n\nstatic void rz_mtu3_pwm_disable(struct rz_mtu3_pwm_chip *rz_mtu3_pwm,\n\t\t\t\tstruct pwm_device *pwm)\n{\n\tstruct rz_mtu3_pwm_channel *priv;\n\tu32 ch;\n\n\tpriv = rz_mtu3_get_channel(rz_mtu3_pwm, pwm->hwpwm);\n\tch = priv - rz_mtu3_pwm->channel_data;\n\n\t \n\tif (priv->map->base_pwm_number == pwm->hwpwm)\n\t\trz_mtu3_8bit_ch_write(priv->mtu, RZ_MTU3_TIORH, RZ_MTU3_TIOR_OC_RETAIN);\n\telse\n\t\trz_mtu3_8bit_ch_write(priv->mtu, RZ_MTU3_TIORL, RZ_MTU3_TIOR_OC_RETAIN);\n\n\tmutex_lock(&rz_mtu3_pwm->lock);\n\trz_mtu3_pwm->enable_count[ch]--;\n\tif (!rz_mtu3_pwm->enable_count[ch])\n\t\trz_mtu3_disable(priv->mtu);\n\n\tmutex_unlock(&rz_mtu3_pwm->lock);\n\n\tpm_runtime_put_sync(rz_mtu3_pwm->chip.dev);\n}\n\nstatic int rz_mtu3_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t struct pwm_state *state)\n{\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm = to_rz_mtu3_pwm_chip(chip);\n\tint rc;\n\n\trc = pm_runtime_resume_and_get(chip->dev);\n\tif (rc)\n\t\treturn rc;\n\n\tstate->enabled = rz_mtu3_pwm_is_ch_enabled(rz_mtu3_pwm, pwm->hwpwm);\n\tif (state->enabled) {\n\t\tstruct rz_mtu3_pwm_channel *priv;\n\t\tu8 prescale, val;\n\t\tu16 dc, pv;\n\t\tu64 tmp;\n\n\t\tpriv = rz_mtu3_get_channel(rz_mtu3_pwm, pwm->hwpwm);\n\t\tif (priv->map->base_pwm_number == pwm->hwpwm)\n\t\t\trz_mtu3_pwm_read_tgr_registers(priv, RZ_MTU3_TGRA, &pv,\n\t\t\t\t\t\t       RZ_MTU3_TGRB, &dc);\n\t\telse\n\t\t\trz_mtu3_pwm_read_tgr_registers(priv, RZ_MTU3_TGRC, &pv,\n\t\t\t\t\t\t       RZ_MTU3_TGRD, &dc);\n\n\t\tval = rz_mtu3_8bit_ch_read(priv->mtu, RZ_MTU3_TCR);\n\t\tprescale = FIELD_GET(RZ_MTU3_TCR_TPCS, val);\n\n\t\t \n\t\ttmp = NSEC_PER_SEC * (u64)pv << (2 * prescale);\n\t\tstate->period = DIV_ROUND_UP_ULL(tmp, rz_mtu3_pwm->rate);\n\t\ttmp = NSEC_PER_SEC * (u64)dc << (2 * prescale);\n\t\tstate->duty_cycle = DIV_ROUND_UP_ULL(tmp, rz_mtu3_pwm->rate);\n\n\t\tif (state->duty_cycle > state->period)\n\t\t\tstate->duty_cycle = state->period;\n\t}\n\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\tpm_runtime_put(chip->dev);\n\n\treturn 0;\n}\n\nstatic u16 rz_mtu3_pwm_calculate_pv_or_dc(u64 period_or_duty_cycle, u8 prescale)\n{\n\treturn min(period_or_duty_cycle >> (2 * prescale), (u64)U16_MAX);\n}\n\nstatic int rz_mtu3_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      const struct pwm_state *state)\n{\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm = to_rz_mtu3_pwm_chip(chip);\n\tstruct rz_mtu3_pwm_channel *priv;\n\tu64 period_cycles;\n\tu64 duty_cycles;\n\tu8 prescale;\n\tu16 pv, dc;\n\tu8 val;\n\tu32 ch;\n\n\tpriv = rz_mtu3_get_channel(rz_mtu3_pwm, pwm->hwpwm);\n\tch = priv - rz_mtu3_pwm->channel_data;\n\n\tperiod_cycles = mul_u64_u32_div(state->period, rz_mtu3_pwm->rate,\n\t\t\t\t\tNSEC_PER_SEC);\n\tprescale = rz_mtu3_pwm_calculate_prescale(rz_mtu3_pwm, period_cycles);\n\n\t \n\tif (rz_mtu3_pwm->enable_count[ch] > 1) {\n\t\tif (rz_mtu3_pwm->prescale[ch] > prescale)\n\t\t\treturn -EBUSY;\n\n\t\tprescale = rz_mtu3_pwm->prescale[ch];\n\t}\n\n\tpv = rz_mtu3_pwm_calculate_pv_or_dc(period_cycles, prescale);\n\n\tduty_cycles = mul_u64_u32_div(state->duty_cycle, rz_mtu3_pwm->rate,\n\t\t\t\t      NSEC_PER_SEC);\n\tdc = rz_mtu3_pwm_calculate_pv_or_dc(duty_cycles, prescale);\n\n\t \n\tif (!pwm->state.enabled) {\n\t\tint rc;\n\n\t\trc = pm_runtime_resume_and_get(chip->dev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tval = RZ_MTU3_TCR_CKEG_RISING | prescale;\n\n\t \n\tif (rz_mtu3_pwm->prescale[ch] != prescale && rz_mtu3_pwm->enable_count[ch])\n\t\trz_mtu3_disable(priv->mtu);\n\n\tif (priv->map->base_pwm_number == pwm->hwpwm) {\n\t\trz_mtu3_8bit_ch_write(priv->mtu, RZ_MTU3_TCR,\n\t\t\t\t      RZ_MTU3_TCR_CCLR_TGRA | val);\n\t\trz_mtu3_pwm_write_tgr_registers(priv, RZ_MTU3_TGRA, pv,\n\t\t\t\t\t\tRZ_MTU3_TGRB, dc);\n\t} else {\n\t\trz_mtu3_8bit_ch_write(priv->mtu, RZ_MTU3_TCR,\n\t\t\t\t      RZ_MTU3_TCR_CCLR_TGRC | val);\n\t\trz_mtu3_pwm_write_tgr_registers(priv, RZ_MTU3_TGRC, pv,\n\t\t\t\t\t\tRZ_MTU3_TGRD, dc);\n\t}\n\n\tif (rz_mtu3_pwm->prescale[ch] != prescale) {\n\t\t \n\t\trz_mtu3_pwm->prescale[ch] = prescale;\n\n\t\tif (rz_mtu3_pwm->enable_count[ch])\n\t\t\trz_mtu3_enable(priv->mtu);\n\t}\n\n\t \n\tif (!pwm->state.enabled)\n\t\tpm_runtime_put(chip->dev);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm = to_rz_mtu3_pwm_chip(chip);\n\tbool enabled = pwm->state.enabled;\n\tint ret;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\trz_mtu3_pwm_disable(rz_mtu3_pwm, pwm);\n\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&rz_mtu3_pwm->lock);\n\tret = rz_mtu3_pwm_config(chip, pwm, state);\n\tmutex_unlock(&rz_mtu3_pwm->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!enabled)\n\t\tret = rz_mtu3_pwm_enable(rz_mtu3_pwm, pwm);\n\n\treturn ret;\n}\n\nstatic const struct pwm_ops rz_mtu3_pwm_ops = {\n\t.request = rz_mtu3_pwm_request,\n\t.free = rz_mtu3_pwm_free,\n\t.get_state = rz_mtu3_pwm_get_state,\n\t.apply = rz_mtu3_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int rz_mtu3_pwm_pm_runtime_suspend(struct device *dev)\n{\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(rz_mtu3_pwm->clk);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_pwm_pm_runtime_resume(struct device *dev)\n{\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(rz_mtu3_pwm->clk);\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(rz_mtu3_pwm_pm_ops,\n\t\t\t\t rz_mtu3_pwm_pm_runtime_suspend,\n\t\t\t\t rz_mtu3_pwm_pm_runtime_resume, NULL);\n\nstatic void rz_mtu3_pwm_pm_disable(void *data)\n{\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm = data;\n\n\tclk_rate_exclusive_put(rz_mtu3_pwm->clk);\n\tpm_runtime_disable(rz_mtu3_pwm->chip.dev);\n\tpm_runtime_set_suspended(rz_mtu3_pwm->chip.dev);\n}\n\nstatic int rz_mtu3_pwm_probe(struct platform_device *pdev)\n{\n\tstruct rz_mtu3 *parent_ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct rz_mtu3_pwm_chip *rz_mtu3_pwm;\n\tstruct device *dev = &pdev->dev;\n\tunsigned int i, j = 0;\n\tint ret;\n\n\trz_mtu3_pwm = devm_kzalloc(&pdev->dev, sizeof(*rz_mtu3_pwm), GFP_KERNEL);\n\tif (!rz_mtu3_pwm)\n\t\treturn -ENOMEM;\n\n\trz_mtu3_pwm->clk = parent_ddata->clk;\n\n\tfor (i = 0; i < RZ_MTU_NUM_CHANNELS; i++) {\n\t\tif (i == RZ_MTU3_CHAN_5 || i == RZ_MTU3_CHAN_8)\n\t\t\tcontinue;\n\n\t\trz_mtu3_pwm->channel_data[j].mtu = &parent_ddata->channels[i];\n\t\trz_mtu3_pwm->channel_data[j].mtu->dev = dev;\n\t\trz_mtu3_pwm->channel_data[j].map = &channel_map[j];\n\t\tj++;\n\t}\n\n\tmutex_init(&rz_mtu3_pwm->lock);\n\tplatform_set_drvdata(pdev, rz_mtu3_pwm);\n\tret = clk_prepare_enable(rz_mtu3_pwm->clk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Clock enable failed\\n\");\n\n\tclk_rate_exclusive_get(rz_mtu3_pwm->clk);\n\n\trz_mtu3_pwm->rate = clk_get_rate(rz_mtu3_pwm->clk);\n\t \n\tif (rz_mtu3_pwm->rate > NSEC_PER_SEC) {\n\t\tret = -EINVAL;\n\t\tclk_rate_exclusive_put(rz_mtu3_pwm->clk);\n\t\tgoto disable_clock;\n\t}\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\trz_mtu3_pwm->chip.dev = &pdev->dev;\n\tret = devm_add_action_or_reset(&pdev->dev, rz_mtu3_pwm_pm_disable,\n\t\t\t\t       rz_mtu3_pwm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trz_mtu3_pwm->chip.ops = &rz_mtu3_pwm_ops;\n\trz_mtu3_pwm->chip.npwm = RZ_MTU3_MAX_PWM_CHANNELS;\n\tret = devm_pwmchip_add(&pdev->dev, &rz_mtu3_pwm->chip);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to add PWM chip\\n\");\n\n\tpm_runtime_idle(&pdev->dev);\n\n\treturn 0;\n\ndisable_clock:\n\tclk_disable_unprepare(rz_mtu3_pwm->clk);\n\treturn ret;\n}\n\nstatic struct platform_driver rz_mtu3_pwm_driver = {\n\t.driver = {\n\t\t.name = \"pwm-rz-mtu3\",\n\t\t.pm = pm_ptr(&rz_mtu3_pwm_pm_ops),\n\t},\n\t.probe = rz_mtu3_pwm_probe,\n};\nmodule_platform_driver(rz_mtu3_pwm_driver);\n\nMODULE_AUTHOR(\"Biju Das <biju.das.jz@bp.renesas.com>\");\nMODULE_ALIAS(\"platform:pwm-rz-mtu3\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L MTU3a PWM Timer Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}