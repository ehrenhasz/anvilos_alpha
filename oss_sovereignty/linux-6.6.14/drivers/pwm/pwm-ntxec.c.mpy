{
  "module_name": "pwm-ntxec.c",
  "hash_id": "df47b82d97db8cd2179dd73755d779350fc9b65392f64f8eb9f81f076e9a6eb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-ntxec.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/ntxec.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\nstruct ntxec_pwm {\n\tstruct ntxec *ec;\n\tstruct pwm_chip chip;\n};\n\nstatic struct ntxec_pwm *ntxec_pwm_from_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct ntxec_pwm, chip);\n}\n\n#define NTXEC_REG_AUTO_OFF_HI\t0xa1\n#define NTXEC_REG_AUTO_OFF_LO\t0xa2\n#define NTXEC_REG_ENABLE\t0xa3\n#define NTXEC_REG_PERIOD_LOW\t0xa4\n#define NTXEC_REG_PERIOD_HIGH\t0xa5\n#define NTXEC_REG_DUTY_LOW\t0xa6\n#define NTXEC_REG_DUTY_HIGH\t0xa7\n\n \n#define TIME_BASE_NS 125\n\n \n#define MAX_PERIOD_NS (TIME_BASE_NS * 0xffff)\n\nstatic int ntxec_pwm_set_raw_period_and_duty_cycle(struct pwm_chip *chip,\n\t\t\t\t\t\t   int period, int duty)\n{\n\tstruct ntxec_pwm *priv = ntxec_pwm_from_chip(chip);\n\n\t \n\n\tstruct reg_sequence regs[] = {\n\t\t{ NTXEC_REG_PERIOD_HIGH, ntxec_reg8(period >> 8) },\n\t\t{ NTXEC_REG_DUTY_HIGH, ntxec_reg8(duty >> 8) },\n\t\t{ NTXEC_REG_PERIOD_LOW, ntxec_reg8(period) },\n\t\t{ NTXEC_REG_DUTY_LOW, ntxec_reg8(duty) },\n\t};\n\n\treturn regmap_multi_reg_write(priv->ec->regmap, regs, ARRAY_SIZE(regs));\n}\n\nstatic int ntxec_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm_dev,\n\t\t\t   const struct pwm_state *state)\n{\n\tstruct ntxec_pwm *priv = ntxec_pwm_from_chip(chip);\n\tunsigned int period, duty;\n\tint res;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tperiod = min_t(u64, state->period, MAX_PERIOD_NS);\n\tduty   = min_t(u64, state->duty_cycle, period);\n\n\tperiod /= TIME_BASE_NS;\n\tduty   /= TIME_BASE_NS;\n\n\t \n\tif (state->enabled && duty != 0) {\n\t\tres = ntxec_pwm_set_raw_period_and_duty_cycle(chip, period, duty);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tres = regmap_write(priv->ec->regmap, NTXEC_REG_ENABLE, ntxec_reg8(1));\n\t\tif (res)\n\t\t\treturn res;\n\n\t\t \n\t\tres = regmap_write(priv->ec->regmap, NTXEC_REG_AUTO_OFF_HI, ntxec_reg8(0xff));\n\t\tif (res)\n\t\t\treturn res;\n\n\t\treturn regmap_write(priv->ec->regmap, NTXEC_REG_AUTO_OFF_LO, ntxec_reg8(0xff));\n\t} else {\n\t\treturn regmap_write(priv->ec->regmap, NTXEC_REG_ENABLE, ntxec_reg8(0));\n\t}\n}\n\nstatic const struct pwm_ops ntxec_pwm_ops = {\n\t.owner = THIS_MODULE,\n\t.apply = ntxec_pwm_apply,\n\t \n};\n\nstatic int ntxec_pwm_probe(struct platform_device *pdev)\n{\n\tstruct ntxec *ec = dev_get_drvdata(pdev->dev.parent);\n\tstruct ntxec_pwm *priv;\n\tstruct pwm_chip *chip;\n\n\tdevice_set_of_node_from_dev(&pdev->dev, pdev->dev.parent);\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->ec = ec;\n\n\tchip = &priv->chip;\n\tchip->dev = &pdev->dev;\n\tchip->ops = &ntxec_pwm_ops;\n\tchip->npwm = 1;\n\n\treturn devm_pwmchip_add(&pdev->dev, chip);\n}\n\nstatic struct platform_driver ntxec_pwm_driver = {\n\t.driver = {\n\t\t.name = \"ntxec-pwm\",\n\t},\n\t.probe = ntxec_pwm_probe,\n};\nmodule_platform_driver(ntxec_pwm_driver);\n\nMODULE_AUTHOR(\"Jonathan Neusch\u00e4fer <j.neuschaefer@gmx.net>\");\nMODULE_DESCRIPTION(\"PWM driver for Netronix EC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ntxec-pwm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}