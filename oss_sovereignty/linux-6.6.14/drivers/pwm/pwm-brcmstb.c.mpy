{
  "module_name": "pwm-brcmstb.c",
  "hash_id": "91a1eb89bee0296cce85ee342214f4d561f30943b899093a42a6f47929a6eea5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-brcmstb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/spinlock.h>\n\n#define PWM_CTRL\t\t0x00\n#define  CTRL_START\t\tBIT(0)\n#define  CTRL_OEB\t\tBIT(1)\n#define  CTRL_FORCE_HIGH\tBIT(2)\n#define  CTRL_OPENDRAIN\t\tBIT(3)\n#define  CTRL_CHAN_OFFS\t\t4\n\n#define PWM_CTRL2\t\t0x04\n#define  CTRL2_OUT_SELECT\tBIT(0)\n\n#define PWM_CH_SIZE\t\t0x8\n\n#define PWM_CWORD_MSB(ch)\t(0x08 + ((ch) * PWM_CH_SIZE))\n#define PWM_CWORD_LSB(ch)\t(0x0c + ((ch) * PWM_CH_SIZE))\n\n \n#define CWORD_BIT_SIZE\t\t16\n\n \n#define CONST_VAR_F_MAX\t\t32768\n#define CONST_VAR_F_MIN\t\t1\n\n#define PWM_ON(ch)\t\t(0x18 + ((ch) * PWM_CH_SIZE))\n#define  PWM_ON_MIN\t\t1\n#define PWM_PERIOD(ch)\t\t(0x1c + ((ch) * PWM_CH_SIZE))\n#define  PWM_PERIOD_MIN\t\t0\n\n#define PWM_ON_PERIOD_MAX\t0xff\n\nstruct brcmstb_pwm {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct pwm_chip chip;\n};\n\nstatic inline u32 brcmstb_pwm_readl(struct brcmstb_pwm *p,\n\t\t\t\t    unsigned int offset)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\treturn __raw_readl(p->base + offset);\n\telse\n\t\treturn readl_relaxed(p->base + offset);\n}\n\nstatic inline void brcmstb_pwm_writel(struct brcmstb_pwm *p, u32 value,\n\t\t\t\t      unsigned int offset)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\t__raw_writel(value, p->base + offset);\n\telse\n\t\twritel_relaxed(value, p->base + offset);\n}\n\nstatic inline struct brcmstb_pwm *to_brcmstb_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct brcmstb_pwm, chip);\n}\n\n \nstatic int brcmstb_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      u64 duty_ns, u64 period_ns)\n{\n\tstruct brcmstb_pwm *p = to_brcmstb_pwm(chip);\n\tunsigned long pc, dc, cword = CONST_VAR_F_MAX;\n\tunsigned int channel = pwm->hwpwm;\n\tu32 value;\n\n\t \n\tif (duty_ns == period_ns) {\n\t\tdc = PWM_ON_PERIOD_MAX;\n\t\tpc = PWM_ON_PERIOD_MAX - 1;\n\t\tgoto done;\n\t}\n\n\twhile (1) {\n\t\tu64 rate;\n\n\t\t \n\t\trate = (u64)clk_get_rate(p->clk) * (u64)cword;\n\t\trate >>= CWORD_BIT_SIZE;\n\n\t\tpc = mul_u64_u64_div_u64(period_ns, rate, NSEC_PER_SEC);\n\t\tdc = mul_u64_u64_div_u64(duty_ns + 1, rate, NSEC_PER_SEC);\n\n\t\t \n\t\tif (pc == PWM_PERIOD_MIN || (dc < PWM_ON_MIN && duty_ns))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (pc <= PWM_ON_PERIOD_MAX && dc <= PWM_ON_PERIOD_MAX)\n\t\t\tbreak;\n\n\t\t \n\t\tcword >>= 1;\n\n\t\t \n\t\tif (cword < CONST_VAR_F_MIN)\n\t\t\treturn -EINVAL;\n\t}\n\ndone:\n\t \n\tbrcmstb_pwm_writel(p, cword >> 8, PWM_CWORD_MSB(channel));\n\tbrcmstb_pwm_writel(p, cword & 0xff, PWM_CWORD_LSB(channel));\n\n\t \n\tvalue = brcmstb_pwm_readl(p, PWM_CTRL2);\n\tvalue |= CTRL2_OUT_SELECT << (channel * CTRL_CHAN_OFFS);\n\tbrcmstb_pwm_writel(p, value, PWM_CTRL2);\n\n\t \n\tbrcmstb_pwm_writel(p, pc, PWM_PERIOD(channel));\n\tbrcmstb_pwm_writel(p, dc, PWM_ON(channel));\n\n\treturn 0;\n}\n\nstatic inline void brcmstb_pwm_enable_set(struct brcmstb_pwm *p,\n\t\t\t\t\t  unsigned int channel, bool enable)\n{\n\tunsigned int shift = channel * CTRL_CHAN_OFFS;\n\tu32 value;\n\n\tvalue = brcmstb_pwm_readl(p, PWM_CTRL);\n\n\tif (enable) {\n\t\tvalue &= ~(CTRL_OEB << shift);\n\t\tvalue |= (CTRL_START | CTRL_OPENDRAIN) << shift;\n\t} else {\n\t\tvalue &= ~((CTRL_START | CTRL_OPENDRAIN) << shift);\n\t\tvalue |= CTRL_OEB << shift;\n\t}\n\n\tbrcmstb_pwm_writel(p, value, PWM_CTRL);\n}\n\nstatic int brcmstb_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tstruct brcmstb_pwm *p = to_brcmstb_pwm(chip);\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled)\n\t\t\tbrcmstb_pwm_enable_set(p, pwm->hwpwm, false);\n\n\t\treturn 0;\n\t}\n\n\terr = brcmstb_pwm_config(chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\tbrcmstb_pwm_enable_set(p, pwm->hwpwm, true);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops brcmstb_pwm_ops = {\n\t.apply = brcmstb_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id brcmstb_pwm_of_match[] = {\n\t{ .compatible = \"brcm,bcm7038-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, brcmstb_pwm_of_match);\n\nstatic int brcmstb_pwm_probe(struct platform_device *pdev)\n{\n\tstruct brcmstb_pwm *p;\n\tint ret;\n\n\tp = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(p->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to obtain clock\\n\");\n\t\treturn PTR_ERR(p->clk);\n\t}\n\n\tret = clk_prepare_enable(p->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, p);\n\n\tp->chip.dev = &pdev->dev;\n\tp->chip.ops = &brcmstb_pwm_ops;\n\tp->chip.npwm = 2;\n\n\tp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p->base)) {\n\t\tret = PTR_ERR(p->base);\n\t\tgoto out_clk;\n\t}\n\n\tret = pwmchip_add(&p->chip);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip: %d\\n\", ret);\n\t\tgoto out_clk;\n\t}\n\n\treturn 0;\n\nout_clk:\n\tclk_disable_unprepare(p->clk);\n\treturn ret;\n}\n\nstatic void brcmstb_pwm_remove(struct platform_device *pdev)\n{\n\tstruct brcmstb_pwm *p = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&p->chip);\n\tclk_disable_unprepare(p->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int brcmstb_pwm_suspend(struct device *dev)\n{\n\tstruct brcmstb_pwm *p = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(p->clk);\n\n\treturn 0;\n}\n\nstatic int brcmstb_pwm_resume(struct device *dev)\n{\n\tstruct brcmstb_pwm *p = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(p->clk);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(brcmstb_pwm_pm_ops, brcmstb_pwm_suspend,\n\t\t\t brcmstb_pwm_resume);\n\nstatic struct platform_driver brcmstb_pwm_driver = {\n\t.probe = brcmstb_pwm_probe,\n\t.remove_new = brcmstb_pwm_remove,\n\t.driver = {\n\t\t.name = \"pwm-brcmstb\",\n\t\t.of_match_table = brcmstb_pwm_of_match,\n\t\t.pm = &brcmstb_pwm_pm_ops,\n\t},\n};\nmodule_platform_driver(brcmstb_pwm_driver);\n\nMODULE_AUTHOR(\"Florian Fainelli <f.fainelli@gmail.com>\");\nMODULE_DESCRIPTION(\"Broadcom STB PWM driver\");\nMODULE_ALIAS(\"platform:pwm-brcmstb\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}