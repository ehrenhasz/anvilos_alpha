{
  "module_name": "pwm-crc.c",
  "hash_id": "169f7914242d7eaa7887cba70a54a25a373dab3e6e55d0b8bfad167bddaa0d90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-crc.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/pwm.h>\n\n#define PWM0_CLK_DIV\t\t0x4B\n#define  PWM_OUTPUT_ENABLE\tBIT(7)\n#define  PWM_DIV_CLK_0\t\t0x00  \n#define  PWM_DIV_CLK_100\t0x63  \n#define  PWM_DIV_CLK_128\t0x7F  \n\n#define PWM0_DUTY_CYCLE\t\t0x4E\n#define BACKLIGHT_EN\t\t0x51\n\n#define PWM_MAX_LEVEL\t\t0xFF\n\n#define PWM_BASE_CLK_MHZ\t6\t \n#define PWM_MAX_PERIOD_NS\t5461334\t \n\n \nstruct crystalcove_pwm {\n\tstruct pwm_chip chip;\n\tstruct regmap *regmap;\n};\n\nstatic inline struct crystalcove_pwm *to_crc_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct crystalcove_pwm, chip);\n}\n\nstatic int crc_pwm_calc_clk_div(int period_ns)\n{\n\tint clk_div;\n\n\tclk_div = PWM_BASE_CLK_MHZ * period_ns / (256 * NSEC_PER_USEC);\n\t \n\tif (clk_div > 0)\n\t\tclk_div--;\n\n\treturn clk_div;\n}\n\nstatic int crc_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t const struct pwm_state *state)\n{\n\tstruct crystalcove_pwm *crc_pwm = to_crc_pwm(chip);\n\tstruct device *dev = crc_pwm->chip.dev;\n\tint err;\n\n\tif (state->period > PWM_MAX_PERIOD_NS) {\n\t\tdev_err(dev, \"un-supported period_ns\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (pwm_is_enabled(pwm) && !state->enabled) {\n\t\terr = regmap_write(crc_pwm->regmap, BACKLIGHT_EN, 0);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Error writing BACKLIGHT_EN %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pwm_get_duty_cycle(pwm) != state->duty_cycle ||\n\t    pwm_get_period(pwm) != state->period) {\n\t\tu64 level = state->duty_cycle * PWM_MAX_LEVEL;\n\n\t\tdo_div(level, state->period);\n\n\t\terr = regmap_write(crc_pwm->regmap, PWM0_DUTY_CYCLE, level);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Error writing PWM0_DUTY_CYCLE %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pwm_is_enabled(pwm) && state->enabled &&\n\t    pwm_get_period(pwm) != state->period) {\n\t\t \n\t\terr = regmap_write(crc_pwm->regmap, PWM0_CLK_DIV, 0);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Error writing PWM0_CLK_DIV %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pwm_get_period(pwm) != state->period ||\n\t    pwm_is_enabled(pwm) != state->enabled) {\n\t\tint clk_div = crc_pwm_calc_clk_div(state->period);\n\t\tint pwm_output_enable = state->enabled ? PWM_OUTPUT_ENABLE : 0;\n\n\t\terr = regmap_write(crc_pwm->regmap, PWM0_CLK_DIV,\n\t\t\t\t   clk_div | pwm_output_enable);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Error writing PWM0_CLK_DIV %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!pwm_is_enabled(pwm) && state->enabled) {\n\t\terr = regmap_write(crc_pwm->regmap, BACKLIGHT_EN, 1);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Error writing BACKLIGHT_EN %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int crc_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     struct pwm_state *state)\n{\n\tstruct crystalcove_pwm *crc_pwm = to_crc_pwm(chip);\n\tstruct device *dev = crc_pwm->chip.dev;\n\tunsigned int clk_div, clk_div_reg, duty_cycle_reg;\n\tint error;\n\n\terror = regmap_read(crc_pwm->regmap, PWM0_CLK_DIV, &clk_div_reg);\n\tif (error) {\n\t\tdev_err(dev, \"Error reading PWM0_CLK_DIV %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = regmap_read(crc_pwm->regmap, PWM0_DUTY_CYCLE, &duty_cycle_reg);\n\tif (error) {\n\t\tdev_err(dev, \"Error reading PWM0_DUTY_CYCLE %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tclk_div = (clk_div_reg & ~PWM_OUTPUT_ENABLE) + 1;\n\n\tstate->period =\n\t\tDIV_ROUND_UP(clk_div * NSEC_PER_USEC * 256, PWM_BASE_CLK_MHZ);\n\tstate->duty_cycle =\n\t\tDIV_ROUND_UP_ULL(duty_cycle_reg * state->period, PWM_MAX_LEVEL);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\tstate->enabled = !!(clk_div_reg & PWM_OUTPUT_ENABLE);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops crc_pwm_ops = {\n\t.apply = crc_pwm_apply,\n\t.get_state = crc_pwm_get_state,\n};\n\nstatic int crystalcove_pwm_probe(struct platform_device *pdev)\n{\n\tstruct crystalcove_pwm *pwm;\n\tstruct device *dev = pdev->dev.parent;\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(dev);\n\n\tpwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);\n\tif (!pwm)\n\t\treturn -ENOMEM;\n\n\tpwm->chip.dev = &pdev->dev;\n\tpwm->chip.ops = &crc_pwm_ops;\n\tpwm->chip.npwm = 1;\n\n\t \n\tpwm->regmap = pmic->regmap;\n\n\treturn devm_pwmchip_add(&pdev->dev, &pwm->chip);\n}\n\nstatic struct platform_driver crystalcove_pwm_driver = {\n\t.probe = crystalcove_pwm_probe,\n\t.driver = {\n\t\t.name = \"crystal_cove_pwm\",\n\t},\n};\n\nbuiltin_platform_driver(crystalcove_pwm_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}