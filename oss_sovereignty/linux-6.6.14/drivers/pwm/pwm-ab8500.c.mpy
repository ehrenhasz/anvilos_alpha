{
  "module_name": "pwm-ab8500.c",
  "hash_id": "f496f8489c4381ff72932cfdd75defb3df6974c6590dbd7fbb09321694c1b2d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-ab8500.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/pwm.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/module.h>\n\n \n#define AB8500_PWM_OUT_CTRL1_REG\t0x60\n#define AB8500_PWM_OUT_CTRL2_REG\t0x61\n#define AB8500_PWM_OUT_CTRL7_REG\t0x66\n\n#define AB8500_PWM_CLKRATE 9600000\n\nstruct ab8500_pwm_chip {\n\tstruct pwm_chip chip;\n\tunsigned int hwid;\n};\n\nstatic struct ab8500_pwm_chip *ab8500_pwm_from_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct ab8500_pwm_chip, chip);\n}\n\nstatic int ab8500_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tint ret;\n\tu8 reg;\n\tu8 higher_val, lower_val;\n\tunsigned int duty_steps, div;\n\tstruct ab8500_pwm_chip *ab8500 = ab8500_pwm_from_chip(chip);\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (state->enabled) {\n\t\t \n\t\tdiv = min_t(u64, mul_u64_u64_div_u64(state->period,\n\t\t\t\t\t\t     AB8500_PWM_CLKRATE >> 10,\n\t\t\t\t\t\t     NSEC_PER_SEC), 32);  \n\t\tif (div <= 16)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\tduty_steps = max_t(u64, mul_u64_u64_div_u64(state->duty_cycle,\n\t\t\t\t\t\t\t    AB8500_PWM_CLKRATE,\n\t\t\t\t\t\t\t    (u64)NSEC_PER_SEC * div), 1024);\n\t}\n\n\t \n\tif (!state->enabled || duty_steps == 0) {\n\t\tret = abx500_mask_and_set_register_interruptible(chip->dev,\n\t\t\t\t\tAB8500_MISC, AB8500_PWM_OUT_CTRL7_REG,\n\t\t\t\t\t1 << ab8500->hwid, 0);\n\n\t\tif (ret < 0)\n\t\t\tdev_err(chip->dev, \"%s: Failed to disable PWM, Error %d\\n\",\n\t\t\t\t\t\t\t\tpwm->label, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tlower_val = (duty_steps - 1) & 0x00ff;\n\t \n\thigher_val = ((duty_steps - 1) & 0x0300) >> 8 | (32 - div) << 4;\n\n\treg = AB8500_PWM_OUT_CTRL1_REG + (ab8500->hwid * 2);\n\n\tret = abx500_set_register_interruptible(chip->dev, AB8500_MISC,\n\t\t\treg, lower_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = abx500_set_register_interruptible(chip->dev, AB8500_MISC,\n\t\t\t(reg + 1), higher_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = abx500_mask_and_set_register_interruptible(chip->dev,\n\t\t\t\tAB8500_MISC, AB8500_PWM_OUT_CTRL7_REG,\n\t\t\t\t1 << ab8500->hwid, 1 << ab8500->hwid);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"%s: Failed to enable PWM, Error %d\\n\",\n\t\t\t\t\t\t\tpwm->label, ret);\n\n\treturn ret;\n}\n\nstatic int ab8500_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\tstruct pwm_state *state)\n{\n\tu8 ctrl7, lower_val, higher_val;\n\tint ret;\n\tstruct ab8500_pwm_chip *ab8500 = ab8500_pwm_from_chip(chip);\n\tunsigned int div, duty_steps;\n\n\tret = abx500_get_register_interruptible(chip->dev, AB8500_MISC,\n\t\t\t\t\t\tAB8500_PWM_OUT_CTRL7_REG,\n\t\t\t\t\t\t&ctrl7);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\tif (!(ctrl7 & 1 << ab8500->hwid)) {\n\t\tstate->enabled = false;\n\t\treturn 0;\n\t}\n\n\tret = abx500_get_register_interruptible(chip->dev, AB8500_MISC,\n\t\t\t\t\t\tAB8500_PWM_OUT_CTRL1_REG + (ab8500->hwid * 2),\n\t\t\t\t\t\t&lower_val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = abx500_get_register_interruptible(chip->dev, AB8500_MISC,\n\t\t\t\t\t\tAB8500_PWM_OUT_CTRL2_REG + (ab8500->hwid * 2),\n\t\t\t\t\t\t&higher_val);\n\tif (ret)\n\t\treturn ret;\n\n\tdiv = 32 - ((higher_val & 0xf0) >> 4);\n\tduty_steps = ((higher_val & 3) << 8 | lower_val) + 1;\n\n\tstate->period = DIV64_U64_ROUND_UP((u64)div << 10, AB8500_PWM_CLKRATE);\n\tstate->duty_cycle = DIV64_U64_ROUND_UP((u64)div * duty_steps, AB8500_PWM_CLKRATE);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops ab8500_pwm_ops = {\n\t.apply = ab8500_pwm_apply,\n\t.get_state = ab8500_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic int ab8500_pwm_probe(struct platform_device *pdev)\n{\n\tstruct ab8500_pwm_chip *ab8500;\n\tint err;\n\n\tif (pdev->id < 1 || pdev->id > 31)\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL, \"Invalid device id %d\\n\", pdev->id);\n\n\t \n\tab8500 = devm_kzalloc(&pdev->dev, sizeof(*ab8500), GFP_KERNEL);\n\tif (ab8500 == NULL)\n\t\treturn -ENOMEM;\n\n\tab8500->chip.dev = &pdev->dev;\n\tab8500->chip.ops = &ab8500_pwm_ops;\n\tab8500->chip.npwm = 1;\n\tab8500->hwid = pdev->id - 1;\n\n\terr = devm_pwmchip_add(&pdev->dev, &ab8500->chip);\n\tif (err < 0)\n\t\treturn dev_err_probe(&pdev->dev, err, \"Failed to add pwm chip\\n\");\n\n\tdev_dbg(&pdev->dev, \"pwm probe successful\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver ab8500_pwm_driver = {\n\t.driver = {\n\t\t.name = \"ab8500-pwm\",\n\t},\n\t.probe = ab8500_pwm_probe,\n};\nmodule_platform_driver(ab8500_pwm_driver);\n\nMODULE_AUTHOR(\"Arun MURTHY <arun.murthy@stericsson.com>\");\nMODULE_DESCRIPTION(\"AB8500 Pulse Width Modulation Driver\");\nMODULE_ALIAS(\"platform:ab8500-pwm\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}