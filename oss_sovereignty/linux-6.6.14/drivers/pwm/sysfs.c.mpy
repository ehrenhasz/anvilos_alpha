{
  "module_name": "sysfs.c",
  "hash_id": "f8e9b911a798c1929e13f6b8f76df5742b25d8a01cfaa0604cabef8d11c0b003",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/pwm.h>\n\nstruct pwm_export {\n\tstruct device child;\n\tstruct pwm_device *pwm;\n\tstruct mutex lock;\n\tstruct pwm_state suspend;\n};\n\nstatic struct pwm_export *child_to_pwm_export(struct device *child)\n{\n\treturn container_of(child, struct pwm_export, child);\n}\n\nstatic struct pwm_device *child_to_pwm_device(struct device *child)\n{\n\tstruct pwm_export *export = child_to_pwm_export(child);\n\n\treturn export->pwm;\n}\n\nstatic ssize_t period_show(struct device *child,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tconst struct pwm_device *pwm = child_to_pwm_device(child);\n\tstruct pwm_state state;\n\n\tpwm_get_state(pwm, &state);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", state.period);\n}\n\nstatic ssize_t period_store(struct device *child,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t size)\n{\n\tstruct pwm_export *export = child_to_pwm_export(child);\n\tstruct pwm_device *pwm = export->pwm;\n\tstruct pwm_state state;\n\tu64 val;\n\tint ret;\n\n\tret = kstrtou64(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&export->lock);\n\tpwm_get_state(pwm, &state);\n\tstate.period = val;\n\tret = pwm_apply_state(pwm, &state);\n\tmutex_unlock(&export->lock);\n\n\treturn ret ? : size;\n}\n\nstatic ssize_t duty_cycle_show(struct device *child,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tconst struct pwm_device *pwm = child_to_pwm_device(child);\n\tstruct pwm_state state;\n\n\tpwm_get_state(pwm, &state);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", state.duty_cycle);\n}\n\nstatic ssize_t duty_cycle_store(struct device *child,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tstruct pwm_export *export = child_to_pwm_export(child);\n\tstruct pwm_device *pwm = export->pwm;\n\tstruct pwm_state state;\n\tu64 val;\n\tint ret;\n\n\tret = kstrtou64(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&export->lock);\n\tpwm_get_state(pwm, &state);\n\tstate.duty_cycle = val;\n\tret = pwm_apply_state(pwm, &state);\n\tmutex_unlock(&export->lock);\n\n\treturn ret ? : size;\n}\n\nstatic ssize_t enable_show(struct device *child,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tconst struct pwm_device *pwm = child_to_pwm_device(child);\n\tstruct pwm_state state;\n\n\tpwm_get_state(pwm, &state);\n\n\treturn sysfs_emit(buf, \"%d\\n\", state.enabled);\n}\n\nstatic ssize_t enable_store(struct device *child,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t size)\n{\n\tstruct pwm_export *export = child_to_pwm_export(child);\n\tstruct pwm_device *pwm = export->pwm;\n\tstruct pwm_state state;\n\tint val, ret;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&export->lock);\n\n\tpwm_get_state(pwm, &state);\n\n\tswitch (val) {\n\tcase 0:\n\t\tstate.enabled = false;\n\t\tbreak;\n\tcase 1:\n\t\tstate.enabled = true;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tret = pwm_apply_state(pwm, &state);\n\nunlock:\n\tmutex_unlock(&export->lock);\n\treturn ret ? : size;\n}\n\nstatic ssize_t polarity_show(struct device *child,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tconst struct pwm_device *pwm = child_to_pwm_device(child);\n\tconst char *polarity = \"unknown\";\n\tstruct pwm_state state;\n\n\tpwm_get_state(pwm, &state);\n\n\tswitch (state.polarity) {\n\tcase PWM_POLARITY_NORMAL:\n\t\tpolarity = \"normal\";\n\t\tbreak;\n\n\tcase PWM_POLARITY_INVERSED:\n\t\tpolarity = \"inversed\";\n\t\tbreak;\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", polarity);\n}\n\nstatic ssize_t polarity_store(struct device *child,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tstruct pwm_export *export = child_to_pwm_export(child);\n\tstruct pwm_device *pwm = export->pwm;\n\tenum pwm_polarity polarity;\n\tstruct pwm_state state;\n\tint ret;\n\n\tif (sysfs_streq(buf, \"normal\"))\n\t\tpolarity = PWM_POLARITY_NORMAL;\n\telse if (sysfs_streq(buf, \"inversed\"))\n\t\tpolarity = PWM_POLARITY_INVERSED;\n\telse\n\t\treturn -EINVAL;\n\n\tmutex_lock(&export->lock);\n\tpwm_get_state(pwm, &state);\n\tstate.polarity = polarity;\n\tret = pwm_apply_state(pwm, &state);\n\tmutex_unlock(&export->lock);\n\n\treturn ret ? : size;\n}\n\nstatic ssize_t capture_show(struct device *child,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct pwm_device *pwm = child_to_pwm_device(child);\n\tstruct pwm_capture result;\n\tint ret;\n\n\tret = pwm_capture(pwm, &result, jiffies_to_msecs(HZ));\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u %u\\n\", result.period, result.duty_cycle);\n}\n\nstatic DEVICE_ATTR_RW(period);\nstatic DEVICE_ATTR_RW(duty_cycle);\nstatic DEVICE_ATTR_RW(enable);\nstatic DEVICE_ATTR_RW(polarity);\nstatic DEVICE_ATTR_RO(capture);\n\nstatic struct attribute *pwm_attrs[] = {\n\t&dev_attr_period.attr,\n\t&dev_attr_duty_cycle.attr,\n\t&dev_attr_enable.attr,\n\t&dev_attr_polarity.attr,\n\t&dev_attr_capture.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(pwm);\n\nstatic void pwm_export_release(struct device *child)\n{\n\tstruct pwm_export *export = child_to_pwm_export(child);\n\n\tkfree(export);\n}\n\nstatic int pwm_export_child(struct device *parent, struct pwm_device *pwm)\n{\n\tstruct pwm_export *export;\n\tchar *pwm_prop[2];\n\tint ret;\n\n\tif (test_and_set_bit(PWMF_EXPORTED, &pwm->flags))\n\t\treturn -EBUSY;\n\n\texport = kzalloc(sizeof(*export), GFP_KERNEL);\n\tif (!export) {\n\t\tclear_bit(PWMF_EXPORTED, &pwm->flags);\n\t\treturn -ENOMEM;\n\t}\n\n\texport->pwm = pwm;\n\tmutex_init(&export->lock);\n\n\texport->child.release = pwm_export_release;\n\texport->child.parent = parent;\n\texport->child.devt = MKDEV(0, 0);\n\texport->child.groups = pwm_groups;\n\tdev_set_name(&export->child, \"pwm%u\", pwm->hwpwm);\n\n\tret = device_register(&export->child);\n\tif (ret) {\n\t\tclear_bit(PWMF_EXPORTED, &pwm->flags);\n\t\tput_device(&export->child);\n\t\texport = NULL;\n\t\treturn ret;\n\t}\n\tpwm_prop[0] = kasprintf(GFP_KERNEL, \"EXPORT=pwm%u\", pwm->hwpwm);\n\tpwm_prop[1] = NULL;\n\tkobject_uevent_env(&parent->kobj, KOBJ_CHANGE, pwm_prop);\n\tkfree(pwm_prop[0]);\n\n\treturn 0;\n}\n\nstatic int pwm_unexport_match(struct device *child, void *data)\n{\n\treturn child_to_pwm_device(child) == data;\n}\n\nstatic int pwm_unexport_child(struct device *parent, struct pwm_device *pwm)\n{\n\tstruct device *child;\n\tchar *pwm_prop[2];\n\n\tif (!test_and_clear_bit(PWMF_EXPORTED, &pwm->flags))\n\t\treturn -ENODEV;\n\n\tchild = device_find_child(parent, pwm, pwm_unexport_match);\n\tif (!child)\n\t\treturn -ENODEV;\n\n\tpwm_prop[0] = kasprintf(GFP_KERNEL, \"UNEXPORT=pwm%u\", pwm->hwpwm);\n\tpwm_prop[1] = NULL;\n\tkobject_uevent_env(&parent->kobj, KOBJ_CHANGE, pwm_prop);\n\tkfree(pwm_prop[0]);\n\n\t \n\tput_device(child);\n\tdevice_unregister(child);\n\tpwm_put(pwm);\n\n\treturn 0;\n}\n\nstatic ssize_t export_store(struct device *parent,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t len)\n{\n\tstruct pwm_chip *chip = dev_get_drvdata(parent);\n\tstruct pwm_device *pwm;\n\tunsigned int hwpwm;\n\tint ret;\n\n\tret = kstrtouint(buf, 0, &hwpwm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (hwpwm >= chip->npwm)\n\t\treturn -ENODEV;\n\n\tpwm = pwm_request_from_chip(chip, hwpwm, \"sysfs\");\n\tif (IS_ERR(pwm))\n\t\treturn PTR_ERR(pwm);\n\n\tret = pwm_export_child(parent, pwm);\n\tif (ret < 0)\n\t\tpwm_put(pwm);\n\n\treturn ret ? : len;\n}\nstatic DEVICE_ATTR_WO(export);\n\nstatic ssize_t unexport_store(struct device *parent,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t len)\n{\n\tstruct pwm_chip *chip = dev_get_drvdata(parent);\n\tunsigned int hwpwm;\n\tint ret;\n\n\tret = kstrtouint(buf, 0, &hwpwm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (hwpwm >= chip->npwm)\n\t\treturn -ENODEV;\n\n\tret = pwm_unexport_child(parent, &chip->pwms[hwpwm]);\n\n\treturn ret ? : len;\n}\nstatic DEVICE_ATTR_WO(unexport);\n\nstatic ssize_t npwm_show(struct device *parent, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tconst struct pwm_chip *chip = dev_get_drvdata(parent);\n\n\treturn sysfs_emit(buf, \"%u\\n\", chip->npwm);\n}\nstatic DEVICE_ATTR_RO(npwm);\n\nstatic struct attribute *pwm_chip_attrs[] = {\n\t&dev_attr_export.attr,\n\t&dev_attr_unexport.attr,\n\t&dev_attr_npwm.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(pwm_chip);\n\n \nstatic struct pwm_export *pwm_class_get_state(struct device *parent,\n\t\t\t\t\t      struct pwm_device *pwm,\n\t\t\t\t\t      struct pwm_state *state)\n{\n\tstruct device *child;\n\tstruct pwm_export *export;\n\n\tif (!test_bit(PWMF_EXPORTED, &pwm->flags))\n\t\treturn NULL;\n\n\tchild = device_find_child(parent, pwm, pwm_unexport_match);\n\tif (!child)\n\t\treturn NULL;\n\n\texport = child_to_pwm_export(child);\n\tput_device(child);\t \n\n\tmutex_lock(&export->lock);\n\tpwm_get_state(pwm, state);\n\n\treturn export;\n}\n\nstatic int pwm_class_apply_state(struct pwm_export *export,\n\t\t\t\t struct pwm_device *pwm,\n\t\t\t\t struct pwm_state *state)\n{\n\tint ret = pwm_apply_state(pwm, state);\n\n\t \n\tmutex_unlock(&export->lock);\n\n\treturn ret;\n}\n\nstatic int pwm_class_resume_npwm(struct device *parent, unsigned int npwm)\n{\n\tstruct pwm_chip *chip = dev_get_drvdata(parent);\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < npwm; i++) {\n\t\tstruct pwm_device *pwm = &chip->pwms[i];\n\t\tstruct pwm_state state;\n\t\tstruct pwm_export *export;\n\n\t\texport = pwm_class_get_state(parent, pwm, &state);\n\t\tif (!export)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!export->suspend.enabled) {\n\t\t\t \n\t\t\tmutex_unlock(&export->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstate.enabled = export->suspend.enabled;\n\t\tret = pwm_class_apply_state(export, pwm, &state);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int pwm_class_suspend(struct device *parent)\n{\n\tstruct pwm_chip *chip = dev_get_drvdata(parent);\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < chip->npwm; i++) {\n\t\tstruct pwm_device *pwm = &chip->pwms[i];\n\t\tstruct pwm_state state;\n\t\tstruct pwm_export *export;\n\n\t\texport = pwm_class_get_state(parent, pwm, &state);\n\t\tif (!export)\n\t\t\tcontinue;\n\n\t\t \n\t\texport->suspend = state;\n\t\tif (!state.enabled) {\n\t\t\t \n\t\t\tmutex_unlock(&export->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstate.enabled = false;\n\t\tret = pwm_class_apply_state(export, pwm, &state);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tpwm_class_resume_npwm(parent, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int pwm_class_resume(struct device *parent)\n{\n\tstruct pwm_chip *chip = dev_get_drvdata(parent);\n\n\treturn pwm_class_resume_npwm(parent, chip->npwm);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pwm_class_pm_ops, pwm_class_suspend, pwm_class_resume);\n\nstatic struct class pwm_class = {\n\t.name = \"pwm\",\n\t.dev_groups = pwm_chip_groups,\n\t.pm = pm_sleep_ptr(&pwm_class_pm_ops),\n};\n\nstatic int pwmchip_sysfs_match(struct device *parent, const void *data)\n{\n\treturn dev_get_drvdata(parent) == data;\n}\n\nvoid pwmchip_sysfs_export(struct pwm_chip *chip)\n{\n\tstruct device *parent;\n\n\t \n\tparent = device_create(&pwm_class, chip->dev, MKDEV(0, 0), chip,\n\t\t\t       \"pwmchip%d\", chip->base);\n\tif (IS_ERR(parent)) {\n\t\tdev_warn(chip->dev,\n\t\t\t \"device_create failed for pwm_chip sysfs export\\n\");\n\t}\n}\n\nvoid pwmchip_sysfs_unexport(struct pwm_chip *chip)\n{\n\tstruct device *parent;\n\tunsigned int i;\n\n\tparent = class_find_device(&pwm_class, NULL, chip,\n\t\t\t\t   pwmchip_sysfs_match);\n\tif (!parent)\n\t\treturn;\n\n\tfor (i = 0; i < chip->npwm; i++) {\n\t\tstruct pwm_device *pwm = &chip->pwms[i];\n\n\t\tif (test_bit(PWMF_EXPORTED, &pwm->flags))\n\t\t\tpwm_unexport_child(parent, pwm);\n\t}\n\n\tput_device(parent);\n\tdevice_unregister(parent);\n}\n\nstatic int __init pwm_sysfs_init(void)\n{\n\treturn class_register(&pwm_class);\n}\nsubsys_initcall(pwm_sysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}