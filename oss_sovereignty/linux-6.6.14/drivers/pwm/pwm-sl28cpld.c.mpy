{
  "module_name": "pwm-sl28cpld.c",
  "hash_id": "4fe9102c11a6a6681615f62b62ced3e36f0f688bc9e03b2b8931816bc6d9972a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-sl28cpld.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n\n \n#define SL28CPLD_PWM_CTRL\t\t\t0x00\n#define   SL28CPLD_PWM_CTRL_ENABLE\t\tBIT(7)\n#define   SL28CPLD_PWM_CTRL_PRESCALER_MASK\tGENMASK(1, 0)\n#define SL28CPLD_PWM_CYCLE\t\t\t0x01\n#define   SL28CPLD_PWM_CYCLE_MAX\t\tGENMASK(6, 0)\n\n#define SL28CPLD_PWM_CLK\t\t\t32000  \n#define SL28CPLD_PWM_MAX_DUTY_CYCLE(prescaler)\t(1 << (7 - (prescaler)))\n#define SL28CPLD_PWM_PERIOD(prescaler) \\\n\t(NSEC_PER_SEC / SL28CPLD_PWM_CLK * SL28CPLD_PWM_MAX_DUTY_CYCLE(prescaler))\n\n \n#define SL28CPLD_PWM_TO_DUTY_CYCLE(reg) \\\n\t(NSEC_PER_SEC / SL28CPLD_PWM_CLK * (reg))\n#define SL28CPLD_PWM_FROM_DUTY_CYCLE(duty_cycle) \\\n\t(DIV_ROUND_DOWN_ULL((duty_cycle), NSEC_PER_SEC / SL28CPLD_PWM_CLK))\n\n#define sl28cpld_pwm_read(priv, reg, val) \\\n\tregmap_read((priv)->regmap, (priv)->offset + (reg), (val))\n#define sl28cpld_pwm_write(priv, reg, val) \\\n\tregmap_write((priv)->regmap, (priv)->offset + (reg), (val))\n\nstruct sl28cpld_pwm {\n\tstruct pwm_chip chip;\n\tstruct regmap *regmap;\n\tu32 offset;\n};\n\nstatic inline struct sl28cpld_pwm *sl28cpld_pwm_from_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct sl28cpld_pwm, chip);\n}\n\nstatic int sl28cpld_pwm_get_state(struct pwm_chip *chip,\n\t\t\t\t  struct pwm_device *pwm,\n\t\t\t\t  struct pwm_state *state)\n{\n\tstruct sl28cpld_pwm *priv = sl28cpld_pwm_from_chip(chip);\n\tunsigned int reg;\n\tint prescaler;\n\n\tsl28cpld_pwm_read(priv, SL28CPLD_PWM_CTRL, &reg);\n\n\tstate->enabled = reg & SL28CPLD_PWM_CTRL_ENABLE;\n\n\tprescaler = FIELD_GET(SL28CPLD_PWM_CTRL_PRESCALER_MASK, reg);\n\tstate->period = SL28CPLD_PWM_PERIOD(prescaler);\n\n\tsl28cpld_pwm_read(priv, SL28CPLD_PWM_CYCLE, &reg);\n\tstate->duty_cycle = SL28CPLD_PWM_TO_DUTY_CYCLE(reg);\n\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\t \n\tstate->duty_cycle = min(state->duty_cycle, state->period);\n\n\treturn 0;\n}\n\nstatic int sl28cpld_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      const struct pwm_state *state)\n{\n\tstruct sl28cpld_pwm *priv = sl28cpld_pwm_from_chip(chip);\n\tunsigned int cycle, prescaler;\n\tbool write_duty_cycle_first;\n\tint ret;\n\tu8 ctrl;\n\n\t \n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\t \n\tprescaler = DIV_ROUND_UP_ULL(SL28CPLD_PWM_PERIOD(0), state->period);\n\tprescaler = order_base_2(prescaler);\n\n\tif (prescaler > field_max(SL28CPLD_PWM_CTRL_PRESCALER_MASK))\n\t\treturn -ERANGE;\n\n\tctrl = FIELD_PREP(SL28CPLD_PWM_CTRL_PRESCALER_MASK, prescaler);\n\tif (state->enabled)\n\t\tctrl |= SL28CPLD_PWM_CTRL_ENABLE;\n\n\tcycle = SL28CPLD_PWM_FROM_DUTY_CYCLE(state->duty_cycle);\n\tcycle = min_t(unsigned int, cycle, SL28CPLD_PWM_MAX_DUTY_CYCLE(prescaler));\n\n\t \n\tif (cycle == SL28CPLD_PWM_MAX_DUTY_CYCLE(0)) {\n\t\tctrl &= ~SL28CPLD_PWM_CTRL_PRESCALER_MASK;\n\t\tctrl |= FIELD_PREP(SL28CPLD_PWM_CTRL_PRESCALER_MASK, 1);\n\t\tcycle = SL28CPLD_PWM_MAX_DUTY_CYCLE(1);\n\t}\n\n\t \n\twrite_duty_cycle_first = pwm->state.period > state->period;\n\n\tif (write_duty_cycle_first) {\n\t\tret = sl28cpld_pwm_write(priv, SL28CPLD_PWM_CYCLE, cycle);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = sl28cpld_pwm_write(priv, SL28CPLD_PWM_CTRL, ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!write_duty_cycle_first) {\n\t\tret = sl28cpld_pwm_write(priv, SL28CPLD_PWM_CYCLE, cycle);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops sl28cpld_pwm_ops = {\n\t.apply = sl28cpld_pwm_apply,\n\t.get_state = sl28cpld_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic int sl28cpld_pwm_probe(struct platform_device *pdev)\n{\n\tstruct sl28cpld_pwm *priv;\n\tstruct pwm_chip *chip;\n\tint ret;\n\n\tif (!pdev->dev.parent) {\n\t\tdev_err(&pdev->dev, \"no parent device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!priv->regmap) {\n\t\tdev_err(&pdev->dev, \"could not get parent regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = device_property_read_u32(&pdev->dev, \"reg\", &priv->offset);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"no 'reg' property found (%pe)\\n\",\n\t\t\tERR_PTR(ret));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tchip = &priv->chip;\n\tchip->dev = &pdev->dev;\n\tchip->ops = &sl28cpld_pwm_ops;\n\tchip->npwm = 1;\n\n\tret = devm_pwmchip_add(&pdev->dev, chip);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip (%pe)\",\n\t\t\tERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sl28cpld_pwm_of_match[] = {\n\t{ .compatible = \"kontron,sl28cpld-pwm\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sl28cpld_pwm_of_match);\n\nstatic struct platform_driver sl28cpld_pwm_driver = {\n\t.probe = sl28cpld_pwm_probe,\n\t.driver = {\n\t\t.name = \"sl28cpld-pwm\",\n\t\t.of_match_table = sl28cpld_pwm_of_match,\n\t},\n};\nmodule_platform_driver(sl28cpld_pwm_driver);\n\nMODULE_DESCRIPTION(\"sl28cpld PWM Driver\");\nMODULE_AUTHOR(\"Michael Walle <michael@walle.cc>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}