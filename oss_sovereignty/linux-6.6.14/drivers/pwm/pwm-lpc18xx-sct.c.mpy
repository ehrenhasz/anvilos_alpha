{
  "module_name": "pwm-lpc18xx-sct.c",
  "hash_id": "ebae8343c7f7f6e87956b6dd672c626e786456cec28d2f43cbf1df6cf415f254",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-lpc18xx-sct.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\n \n#define LPC18XX_PWM_CONFIG\t\t0x000\n#define LPC18XX_PWM_CONFIG_UNIFY\tBIT(0)\n#define LPC18XX_PWM_CONFIG_NORELOAD\tBIT(7)\n\n#define LPC18XX_PWM_CTRL\t\t0x004\n#define LPC18XX_PWM_CTRL_HALT\t\tBIT(2)\n#define LPC18XX_PWM_BIDIR\t\tBIT(4)\n#define LPC18XX_PWM_PRE_SHIFT\t\t5\n#define LPC18XX_PWM_PRE_MASK\t\t(0xff << LPC18XX_PWM_PRE_SHIFT)\n#define LPC18XX_PWM_PRE(x)\t\t(x << LPC18XX_PWM_PRE_SHIFT)\n\n#define LPC18XX_PWM_LIMIT\t\t0x008\n\n#define LPC18XX_PWM_RES_BASE\t\t0x058\n#define LPC18XX_PWM_RES_SHIFT(_ch)\t(_ch * 2)\n#define LPC18XX_PWM_RES(_ch, _action)\t(_action << LPC18XX_PWM_RES_SHIFT(_ch))\n#define LPC18XX_PWM_RES_MASK(_ch)\t(0x3 << LPC18XX_PWM_RES_SHIFT(_ch))\n\n#define LPC18XX_PWM_MATCH_BASE\t\t0x100\n#define LPC18XX_PWM_MATCH(_ch)\t\t(LPC18XX_PWM_MATCH_BASE + _ch * 4)\n\n#define LPC18XX_PWM_MATCHREL_BASE\t0x200\n#define LPC18XX_PWM_MATCHREL(_ch)\t(LPC18XX_PWM_MATCHREL_BASE + _ch * 4)\n\n#define LPC18XX_PWM_EVSTATEMSK_BASE\t0x300\n#define LPC18XX_PWM_EVSTATEMSK(_ch)\t(LPC18XX_PWM_EVSTATEMSK_BASE + _ch * 8)\n#define LPC18XX_PWM_EVSTATEMSK_ALL\t0xffffffff\n\n#define LPC18XX_PWM_EVCTRL_BASE\t\t0x304\n#define LPC18XX_PWM_EVCTRL(_ev)\t\t(LPC18XX_PWM_EVCTRL_BASE + _ev * 8)\n\n#define LPC18XX_PWM_EVCTRL_MATCH(_ch)\t_ch\n\n#define LPC18XX_PWM_EVCTRL_COMB_SHIFT\t12\n#define LPC18XX_PWM_EVCTRL_COMB_MATCH\t(0x1 << LPC18XX_PWM_EVCTRL_COMB_SHIFT)\n\n#define LPC18XX_PWM_OUTPUTSET_BASE\t0x500\n#define LPC18XX_PWM_OUTPUTSET(_ch)\t(LPC18XX_PWM_OUTPUTSET_BASE + _ch * 8)\n\n#define LPC18XX_PWM_OUTPUTCL_BASE\t0x504\n#define LPC18XX_PWM_OUTPUTCL(_ch)\t(LPC18XX_PWM_OUTPUTCL_BASE + _ch * 8)\n\n \n#define LPC18XX_PWM_TIMER_MAX\t\t0xffffffff\n\n \n#define LPC18XX_PWM_EVENT_PERIOD\t0\n#define LPC18XX_PWM_EVENT_MAX\t\t16\n\n#define LPC18XX_NUM_PWMS\t\t16\n\n \nenum lpc18xx_pwm_res_action {\n\tLPC18XX_PWM_RES_NONE,\n\tLPC18XX_PWM_RES_SET,\n\tLPC18XX_PWM_RES_CLEAR,\n\tLPC18XX_PWM_RES_TOGGLE,\n};\n\nstruct lpc18xx_pwm_data {\n\tunsigned int duty_event;\n};\n\nstruct lpc18xx_pwm_chip {\n\tstruct device *dev;\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n\tstruct clk *pwm_clk;\n\tunsigned long clk_rate;\n\tunsigned int period_ns;\n\tunsigned int min_period_ns;\n\tu64 max_period_ns;\n\tunsigned int period_event;\n\tunsigned long event_map;\n\tstruct mutex res_lock;\n\tstruct mutex period_lock;\n\tstruct lpc18xx_pwm_data channeldata[LPC18XX_NUM_PWMS];\n};\n\nstatic inline struct lpc18xx_pwm_chip *\nto_lpc18xx_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct lpc18xx_pwm_chip, chip);\n}\n\nstatic inline void lpc18xx_pwm_writel(struct lpc18xx_pwm_chip *lpc18xx_pwm,\n\t\t\t\t      u32 reg, u32 val)\n{\n\twritel(val, lpc18xx_pwm->base + reg);\n}\n\nstatic inline u32 lpc18xx_pwm_readl(struct lpc18xx_pwm_chip *lpc18xx_pwm,\n\t\t\t\t    u32 reg)\n{\n\treturn readl(lpc18xx_pwm->base + reg);\n}\n\nstatic void lpc18xx_pwm_set_conflict_res(struct lpc18xx_pwm_chip *lpc18xx_pwm,\n\t\t\t\t\t struct pwm_device *pwm,\n\t\t\t\t\t enum lpc18xx_pwm_res_action action)\n{\n\tu32 val;\n\n\tmutex_lock(&lpc18xx_pwm->res_lock);\n\n\t \n\tval = lpc18xx_pwm_readl(lpc18xx_pwm, LPC18XX_PWM_RES_BASE);\n\tval &= ~LPC18XX_PWM_RES_MASK(pwm->hwpwm);\n\tval |= LPC18XX_PWM_RES(pwm->hwpwm, action);\n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_RES_BASE, val);\n\n\tmutex_unlock(&lpc18xx_pwm->res_lock);\n}\n\nstatic void lpc18xx_pwm_config_period(struct pwm_chip *chip, u64 period_ns)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\n\tu32 val;\n\n\t \n\tval = mul_u64_u64_div_u64(period_ns, lpc18xx_pwm->clk_rate, NSEC_PER_SEC);\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_MATCH(lpc18xx_pwm->period_event),\n\t\t\t   val - 1);\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_MATCHREL(lpc18xx_pwm->period_event),\n\t\t\t   val - 1);\n}\n\nstatic void lpc18xx_pwm_config_duty(struct pwm_chip *chip,\n\t\t\t\t    struct pwm_device *pwm, u64 duty_ns)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\n\tstruct lpc18xx_pwm_data *lpc18xx_data = &lpc18xx_pwm->channeldata[pwm->hwpwm];\n\tu32 val;\n\n\t \n\tval = mul_u64_u64_div_u64(duty_ns, lpc18xx_pwm->clk_rate, NSEC_PER_SEC);\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_MATCH(lpc18xx_data->duty_event),\n\t\t\t   val);\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_MATCHREL(lpc18xx_data->duty_event),\n\t\t\t   val);\n}\n\nstatic int lpc18xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      int duty_ns, int period_ns)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\n\tint requested_events, i;\n\n\tif (period_ns < lpc18xx_pwm->min_period_ns ||\n\t    period_ns > lpc18xx_pwm->max_period_ns) {\n\t\tdev_err(chip->dev, \"period %d not in range\\n\", period_ns);\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&lpc18xx_pwm->period_lock);\n\n\trequested_events = bitmap_weight(&lpc18xx_pwm->event_map,\n\t\t\t\t\t LPC18XX_PWM_EVENT_MAX);\n\n\t \n\tif (requested_events > 2 && lpc18xx_pwm->period_ns != period_ns &&\n\t    lpc18xx_pwm->period_ns) {\n\t\tdev_err(chip->dev, \"conflicting period requested for PWM %u\\n\",\n\t\t\tpwm->hwpwm);\n\t\tmutex_unlock(&lpc18xx_pwm->period_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif ((requested_events <= 2 && lpc18xx_pwm->period_ns != period_ns) ||\n\t    !lpc18xx_pwm->period_ns) {\n\t\tlpc18xx_pwm->period_ns = period_ns;\n\t\tfor (i = 0; i < chip->npwm; i++)\n\t\t\tpwm_set_period(&chip->pwms[i], period_ns);\n\t\tlpc18xx_pwm_config_period(chip, period_ns);\n\t}\n\n\tmutex_unlock(&lpc18xx_pwm->period_lock);\n\n\tlpc18xx_pwm_config_duty(chip, pwm, duty_ns);\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm, enum pwm_polarity polarity)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\n\tstruct lpc18xx_pwm_data *lpc18xx_data = &lpc18xx_pwm->channeldata[pwm->hwpwm];\n\tenum lpc18xx_pwm_res_action res_action;\n\tunsigned int set_event, clear_event;\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_EVCTRL(lpc18xx_data->duty_event),\n\t\t\t   LPC18XX_PWM_EVCTRL_MATCH(lpc18xx_data->duty_event) |\n\t\t\t   LPC18XX_PWM_EVCTRL_COMB_MATCH);\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_EVSTATEMSK(lpc18xx_data->duty_event),\n\t\t\t   LPC18XX_PWM_EVSTATEMSK_ALL);\n\n\tif (polarity == PWM_POLARITY_NORMAL) {\n\t\tset_event = lpc18xx_pwm->period_event;\n\t\tclear_event = lpc18xx_data->duty_event;\n\t\tres_action = LPC18XX_PWM_RES_SET;\n\t} else {\n\t\tset_event = lpc18xx_data->duty_event;\n\t\tclear_event = lpc18xx_pwm->period_event;\n\t\tres_action = LPC18XX_PWM_RES_CLEAR;\n\t}\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_OUTPUTSET(pwm->hwpwm),\n\t\t\t   BIT(set_event));\n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_OUTPUTCL(pwm->hwpwm),\n\t\t\t   BIT(clear_event));\n\tlpc18xx_pwm_set_conflict_res(lpc18xx_pwm, pwm, res_action);\n\n\treturn 0;\n}\n\nstatic void lpc18xx_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\n\tstruct lpc18xx_pwm_data *lpc18xx_data = &lpc18xx_pwm->channeldata[pwm->hwpwm];\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_EVCTRL(lpc18xx_data->duty_event), 0);\n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_OUTPUTSET(pwm->hwpwm), 0);\n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_OUTPUTCL(pwm->hwpwm), 0);\n}\n\nstatic int lpc18xx_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\n\tstruct lpc18xx_pwm_data *lpc18xx_data = &lpc18xx_pwm->channeldata[pwm->hwpwm];\n\tunsigned long event;\n\n\tevent = find_first_zero_bit(&lpc18xx_pwm->event_map,\n\t\t\t\t    LPC18XX_PWM_EVENT_MAX);\n\n\tif (event >= LPC18XX_PWM_EVENT_MAX) {\n\t\tdev_err(lpc18xx_pwm->dev,\n\t\t\t\"maximum number of simultaneous channels reached\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tset_bit(event, &lpc18xx_pwm->event_map);\n\tlpc18xx_data->duty_event = event;\n\n\treturn 0;\n}\n\nstatic void lpc18xx_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm = to_lpc18xx_pwm_chip(chip);\n\tstruct lpc18xx_pwm_data *lpc18xx_data = &lpc18xx_pwm->channeldata[pwm->hwpwm];\n\n\tclear_bit(lpc18xx_data->duty_event, &lpc18xx_pwm->event_map);\n}\n\nstatic int lpc18xx_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tint err;\n\tbool enabled = pwm->state.enabled;\n\n\tif (state->polarity != pwm->state.polarity && pwm->state.enabled) {\n\t\tlpc18xx_pwm_disable(chip, pwm);\n\t\tenabled = false;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\tlpc18xx_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\terr = lpc18xx_pwm_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!enabled)\n\t\terr = lpc18xx_pwm_enable(chip, pwm, state->polarity);\n\n\treturn err;\n}\nstatic const struct pwm_ops lpc18xx_pwm_ops = {\n\t.apply = lpc18xx_pwm_apply,\n\t.request = lpc18xx_pwm_request,\n\t.free = lpc18xx_pwm_free,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id lpc18xx_pwm_of_match[] = {\n\t{ .compatible = \"nxp,lpc1850-sct-pwm\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lpc18xx_pwm_of_match);\n\nstatic int lpc18xx_pwm_probe(struct platform_device *pdev)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm;\n\tint ret;\n\tu64 val;\n\n\tlpc18xx_pwm = devm_kzalloc(&pdev->dev, sizeof(*lpc18xx_pwm),\n\t\t\t\t   GFP_KERNEL);\n\tif (!lpc18xx_pwm)\n\t\treturn -ENOMEM;\n\n\tlpc18xx_pwm->dev = &pdev->dev;\n\n\tlpc18xx_pwm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lpc18xx_pwm->base))\n\t\treturn PTR_ERR(lpc18xx_pwm->base);\n\n\tlpc18xx_pwm->pwm_clk = devm_clk_get_enabled(&pdev->dev, \"pwm\");\n\tif (IS_ERR(lpc18xx_pwm->pwm_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(lpc18xx_pwm->pwm_clk),\n\t\t\t\t     \"failed to get pwm clock\\n\");\n\n\tlpc18xx_pwm->clk_rate = clk_get_rate(lpc18xx_pwm->pwm_clk);\n\tif (!lpc18xx_pwm->clk_rate)\n\t\treturn dev_err_probe(&pdev->dev,\n\t\t\t\t     -EINVAL, \"pwm clock has no frequency\\n\");\n\n\t \n\tif (lpc18xx_pwm->clk_rate > NSEC_PER_SEC)\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL, \"pwm clock to fast\\n\");\n\n\tmutex_init(&lpc18xx_pwm->res_lock);\n\tmutex_init(&lpc18xx_pwm->period_lock);\n\n\tlpc18xx_pwm->max_period_ns =\n\t\tmul_u64_u64_div_u64(NSEC_PER_SEC, LPC18XX_PWM_TIMER_MAX, lpc18xx_pwm->clk_rate);\n\n\tlpc18xx_pwm->min_period_ns = DIV_ROUND_UP(NSEC_PER_SEC,\n\t\t\t\t\t\t  lpc18xx_pwm->clk_rate);\n\n\tlpc18xx_pwm->chip.dev = &pdev->dev;\n\tlpc18xx_pwm->chip.ops = &lpc18xx_pwm_ops;\n\tlpc18xx_pwm->chip.npwm = LPC18XX_NUM_PWMS;\n\n\t \n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_CONFIG,\n\t\t\t   LPC18XX_PWM_CONFIG_UNIFY);\n\n\t \n\tset_bit(LPC18XX_PWM_EVENT_PERIOD, &lpc18xx_pwm->event_map);\n\tlpc18xx_pwm->period_event = LPC18XX_PWM_EVENT_PERIOD;\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_EVSTATEMSK(lpc18xx_pwm->period_event),\n\t\t\t   LPC18XX_PWM_EVSTATEMSK_ALL);\n\n\tval = LPC18XX_PWM_EVCTRL_MATCH(lpc18xx_pwm->period_event) |\n\t      LPC18XX_PWM_EVCTRL_COMB_MATCH;\n\tlpc18xx_pwm_writel(lpc18xx_pwm,\n\t\t\t   LPC18XX_PWM_EVCTRL(lpc18xx_pwm->period_event), val);\n\n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_LIMIT,\n\t\t\t   BIT(lpc18xx_pwm->period_event));\n\n\tval = lpc18xx_pwm_readl(lpc18xx_pwm, LPC18XX_PWM_CTRL);\n\tval &= ~LPC18XX_PWM_BIDIR;\n\tval &= ~LPC18XX_PWM_CTRL_HALT;\n\tval &= ~LPC18XX_PWM_PRE_MASK;\n\tval |= LPC18XX_PWM_PRE(0);\n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_CTRL, val);\n\n\tret = pwmchip_add(&lpc18xx_pwm->chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"pwmchip_add failed\\n\");\n\n\tplatform_set_drvdata(pdev, lpc18xx_pwm);\n\n\treturn 0;\n}\n\nstatic void lpc18xx_pwm_remove(struct platform_device *pdev)\n{\n\tstruct lpc18xx_pwm_chip *lpc18xx_pwm = platform_get_drvdata(pdev);\n\tu32 val;\n\n\tpwmchip_remove(&lpc18xx_pwm->chip);\n\n\tval = lpc18xx_pwm_readl(lpc18xx_pwm, LPC18XX_PWM_CTRL);\n\tlpc18xx_pwm_writel(lpc18xx_pwm, LPC18XX_PWM_CTRL,\n\t\t\t   val | LPC18XX_PWM_CTRL_HALT);\n}\n\nstatic struct platform_driver lpc18xx_pwm_driver = {\n\t.driver = {\n\t\t.name = \"lpc18xx-sct-pwm\",\n\t\t.of_match_table = lpc18xx_pwm_of_match,\n\t},\n\t.probe = lpc18xx_pwm_probe,\n\t.remove_new = lpc18xx_pwm_remove,\n};\nmodule_platform_driver(lpc18xx_pwm_driver);\n\nMODULE_AUTHOR(\"Ariel D'Alessandro <ariel@vanguardiasur.com.ar>\");\nMODULE_DESCRIPTION(\"NXP LPC18xx PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}