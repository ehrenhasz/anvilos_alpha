{
  "module_name": "pwm-vt8500.c",
  "hash_id": "1acc5adb2c0b8e3348341d095a1a6f48edf65fca8b69cdc2ae57b129a439b7d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-vt8500.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/pwm.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n\n#include <asm/div64.h>\n\n \n#define VT8500_NR_PWMS\t2\n\n#define REG_CTRL(pwm)\t\t(((pwm) << 4) + 0x00)\n#define REG_SCALAR(pwm)\t\t(((pwm) << 4) + 0x04)\n#define REG_PERIOD(pwm)\t\t(((pwm) << 4) + 0x08)\n#define REG_DUTY(pwm)\t\t(((pwm) << 4) + 0x0C)\n#define REG_STATUS\t\t0x40\n\n#define CTRL_ENABLE\t\tBIT(0)\n#define CTRL_INVERT\t\tBIT(1)\n#define CTRL_AUTOLOAD\t\tBIT(2)\n#define CTRL_STOP_IMM\t\tBIT(3)\n#define CTRL_LOAD_PRESCALE\tBIT(4)\n#define CTRL_LOAD_PERIOD\tBIT(5)\n\n#define STATUS_CTRL_UPDATE\tBIT(0)\n#define STATUS_SCALAR_UPDATE\tBIT(1)\n#define STATUS_PERIOD_UPDATE\tBIT(2)\n#define STATUS_DUTY_UPDATE\tBIT(3)\n#define STATUS_ALL_UPDATE\t0x0F\n\nstruct vt8500_chip {\n\tstruct pwm_chip chip;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\n#define to_vt8500_chip(chip)\tcontainer_of(chip, struct vt8500_chip, chip)\n\n#define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)\nstatic inline void vt8500_pwm_busy_wait(struct vt8500_chip *vt8500, int nr, u8 bitmask)\n{\n\tint loops = msecs_to_loops(10);\n\tu32 mask = bitmask << (nr << 8);\n\n\twhile ((readl(vt8500->base + REG_STATUS) & mask) && --loops)\n\t\tcpu_relax();\n\n\tif (unlikely(!loops))\n\t\tdev_warn(vt8500->chip.dev, \"Waiting for status bits 0x%x to clear timed out\\n\",\n\t\t\t mask);\n}\n\nstatic int vt8500_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\tu64 duty_ns, u64 period_ns)\n{\n\tstruct vt8500_chip *vt8500 = to_vt8500_chip(chip);\n\tunsigned long long c;\n\tunsigned long period_cycles, prescale, pv, dc;\n\tint err;\n\tu32 val;\n\n\terr = clk_enable(vt8500->clk);\n\tif (err < 0) {\n\t\tdev_err(chip->dev, \"failed to enable clock\\n\");\n\t\treturn err;\n\t}\n\n\tc = clk_get_rate(vt8500->clk);\n\tc = c * period_ns;\n\tdo_div(c, 1000000000);\n\tperiod_cycles = c;\n\n\tif (period_cycles < 1)\n\t\tperiod_cycles = 1;\n\tprescale = (period_cycles - 1) / 4096;\n\tpv = period_cycles / (prescale + 1) - 1;\n\tif (pv > 4095)\n\t\tpv = 4095;\n\n\tif (prescale > 1023) {\n\t\tclk_disable(vt8500->clk);\n\t\treturn -EINVAL;\n\t}\n\n\tc = (unsigned long long)pv * duty_ns;\n\n\tdc = div64_u64(c, period_ns);\n\n\twritel(prescale, vt8500->base + REG_SCALAR(pwm->hwpwm));\n\tvt8500_pwm_busy_wait(vt8500, pwm->hwpwm, STATUS_SCALAR_UPDATE);\n\n\twritel(pv, vt8500->base + REG_PERIOD(pwm->hwpwm));\n\tvt8500_pwm_busy_wait(vt8500, pwm->hwpwm, STATUS_PERIOD_UPDATE);\n\n\twritel(dc, vt8500->base + REG_DUTY(pwm->hwpwm));\n\tvt8500_pwm_busy_wait(vt8500, pwm->hwpwm, STATUS_DUTY_UPDATE);\n\n\tval = readl(vt8500->base + REG_CTRL(pwm->hwpwm));\n\tval |= CTRL_AUTOLOAD;\n\twritel(val, vt8500->base + REG_CTRL(pwm->hwpwm));\n\tvt8500_pwm_busy_wait(vt8500, pwm->hwpwm, STATUS_CTRL_UPDATE);\n\n\tclk_disable(vt8500->clk);\n\treturn 0;\n}\n\nstatic int vt8500_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct vt8500_chip *vt8500 = to_vt8500_chip(chip);\n\tint err;\n\tu32 val;\n\n\terr = clk_enable(vt8500->clk);\n\tif (err < 0) {\n\t\tdev_err(chip->dev, \"failed to enable clock\\n\");\n\t\treturn err;\n\t}\n\n\tval = readl(vt8500->base + REG_CTRL(pwm->hwpwm));\n\tval |= CTRL_ENABLE;\n\twritel(val, vt8500->base + REG_CTRL(pwm->hwpwm));\n\tvt8500_pwm_busy_wait(vt8500, pwm->hwpwm, STATUS_CTRL_UPDATE);\n\n\treturn 0;\n}\n\nstatic void vt8500_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct vt8500_chip *vt8500 = to_vt8500_chip(chip);\n\tu32 val;\n\n\tval = readl(vt8500->base + REG_CTRL(pwm->hwpwm));\n\tval &= ~CTRL_ENABLE;\n\twritel(val, vt8500->base + REG_CTRL(pwm->hwpwm));\n\tvt8500_pwm_busy_wait(vt8500, pwm->hwpwm, STATUS_CTRL_UPDATE);\n\n\tclk_disable(vt8500->clk);\n}\n\nstatic int vt8500_pwm_set_polarity(struct pwm_chip *chip,\n\t\t\t\t   struct pwm_device *pwm,\n\t\t\t\t   enum pwm_polarity polarity)\n{\n\tstruct vt8500_chip *vt8500 = to_vt8500_chip(chip);\n\tu32 val;\n\n\tval = readl(vt8500->base + REG_CTRL(pwm->hwpwm));\n\n\tif (polarity == PWM_POLARITY_INVERSED)\n\t\tval |= CTRL_INVERT;\n\telse\n\t\tval &= ~CTRL_INVERT;\n\n\twritel(val, vt8500->base + REG_CTRL(pwm->hwpwm));\n\tvt8500_pwm_busy_wait(vt8500, pwm->hwpwm, STATUS_CTRL_UPDATE);\n\n\treturn 0;\n}\n\nstatic int vt8500_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t    const struct pwm_state *state)\n{\n\tint err;\n\tbool enabled = pwm->state.enabled;\n\n\tif (state->polarity != pwm->state.polarity) {\n\t\t \n\t\tif (enabled) {\n\t\t\tvt8500_pwm_disable(chip, pwm);\n\n\t\t\tenabled = false;\n\t\t}\n\n\t\terr = vt8500_pwm_set_polarity(chip, pwm, state->polarity);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\tvt8500_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\t \n\terr = vt8500_pwm_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!enabled)\n\t\terr = vt8500_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops vt8500_pwm_ops = {\n\t.apply = vt8500_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id vt8500_pwm_dt_ids[] = {\n\t{ .compatible = \"via,vt8500-pwm\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, vt8500_pwm_dt_ids);\n\nstatic int vt8500_pwm_probe(struct platform_device *pdev)\n{\n\tstruct vt8500_chip *vt8500;\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"invalid devicetree node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvt8500 = devm_kzalloc(&pdev->dev, sizeof(*vt8500), GFP_KERNEL);\n\tif (vt8500 == NULL)\n\t\treturn -ENOMEM;\n\n\tvt8500->chip.dev = &pdev->dev;\n\tvt8500->chip.ops = &vt8500_pwm_ops;\n\tvt8500->chip.npwm = VT8500_NR_PWMS;\n\n\tvt8500->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(vt8500->clk)) {\n\t\tdev_err(&pdev->dev, \"clock source not specified\\n\");\n\t\treturn PTR_ERR(vt8500->clk);\n\t}\n\n\tvt8500->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(vt8500->base))\n\t\treturn PTR_ERR(vt8500->base);\n\n\tret = clk_prepare(vt8500->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to prepare clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pwmchip_add(&vt8500->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add PWM chip\\n\");\n\t\tclk_unprepare(vt8500->clk);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, vt8500);\n\treturn ret;\n}\n\nstatic void vt8500_pwm_remove(struct platform_device *pdev)\n{\n\tstruct vt8500_chip *vt8500 = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&vt8500->chip);\n\n\tclk_unprepare(vt8500->clk);\n}\n\nstatic struct platform_driver vt8500_pwm_driver = {\n\t.probe\t\t= vt8500_pwm_probe,\n\t.remove_new\t= vt8500_pwm_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"vt8500-pwm\",\n\t\t.of_match_table = vt8500_pwm_dt_ids,\n\t},\n};\nmodule_platform_driver(vt8500_pwm_driver);\n\nMODULE_DESCRIPTION(\"VT8500 PWM Driver\");\nMODULE_AUTHOR(\"Tony Prisk <linux@prisktech.co.nz>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}