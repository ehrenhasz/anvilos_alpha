{
  "module_name": "pwm-rockchip.c",
  "hash_id": "991f08c2efee6f0bbe3e33345cb1ee090033d28242172bfc1e32db55dd3b8d9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/time.h>\n\n#define PWM_CTRL_TIMER_EN\t(1 << 0)\n#define PWM_CTRL_OUTPUT_EN\t(1 << 3)\n\n#define PWM_ENABLE\t\t(1 << 0)\n#define PWM_CONTINUOUS\t\t(1 << 1)\n#define PWM_DUTY_POSITIVE\t(1 << 3)\n#define PWM_DUTY_NEGATIVE\t(0 << 3)\n#define PWM_INACTIVE_NEGATIVE\t(0 << 4)\n#define PWM_INACTIVE_POSITIVE\t(1 << 4)\n#define PWM_POLARITY_MASK\t(PWM_DUTY_POSITIVE | PWM_INACTIVE_POSITIVE)\n#define PWM_OUTPUT_LEFT\t\t(0 << 5)\n#define PWM_LOCK_EN\t\t(1 << 6)\n#define PWM_LP_DISABLE\t\t(0 << 8)\n\nstruct rockchip_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct clk *clk;\n\tstruct clk *pclk;\n\tconst struct rockchip_pwm_data *data;\n\tvoid __iomem *base;\n};\n\nstruct rockchip_pwm_regs {\n\tunsigned long duty;\n\tunsigned long period;\n\tunsigned long cntr;\n\tunsigned long ctrl;\n};\n\nstruct rockchip_pwm_data {\n\tstruct rockchip_pwm_regs regs;\n\tunsigned int prescaler;\n\tbool supports_polarity;\n\tbool supports_lock;\n\tu32 enable_conf;\n};\n\nstatic inline struct rockchip_pwm_chip *to_rockchip_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct rockchip_pwm_chip, chip);\n}\n\nstatic int rockchip_pwm_get_state(struct pwm_chip *chip,\n\t\t\t\t  struct pwm_device *pwm,\n\t\t\t\t  struct pwm_state *state)\n{\n\tstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\n\tu32 enable_conf = pc->data->enable_conf;\n\tunsigned long clk_rate;\n\tu64 tmp;\n\tu32 val;\n\tint ret;\n\n\tret = clk_enable(pc->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_enable(pc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_rate = clk_get_rate(pc->clk);\n\n\ttmp = readl_relaxed(pc->base + pc->data->regs.period);\n\ttmp *= pc->data->prescaler * NSEC_PER_SEC;\n\tstate->period = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);\n\n\ttmp = readl_relaxed(pc->base + pc->data->regs.duty);\n\ttmp *= pc->data->prescaler * NSEC_PER_SEC;\n\tstate->duty_cycle =  DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);\n\n\tval = readl_relaxed(pc->base + pc->data->regs.ctrl);\n\tstate->enabled = (val & enable_conf) == enable_conf;\n\n\tif (pc->data->supports_polarity && !(val & PWM_DUTY_POSITIVE))\n\t\tstate->polarity = PWM_POLARITY_INVERSED;\n\telse\n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\tclk_disable(pc->clk);\n\tclk_disable(pc->pclk);\n\n\treturn 0;\n}\n\nstatic void rockchip_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       const struct pwm_state *state)\n{\n\tstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\n\tunsigned long period, duty;\n\tu64 clk_rate, div;\n\tu32 ctrl;\n\n\tclk_rate = clk_get_rate(pc->clk);\n\n\t \n\tdiv = clk_rate * state->period;\n\tperiod = DIV_ROUND_CLOSEST_ULL(div,\n\t\t\t\t       pc->data->prescaler * NSEC_PER_SEC);\n\n\tdiv = clk_rate * state->duty_cycle;\n\tduty = DIV_ROUND_CLOSEST_ULL(div, pc->data->prescaler * NSEC_PER_SEC);\n\n\t \n\tctrl = readl_relaxed(pc->base + pc->data->regs.ctrl);\n\tif (pc->data->supports_lock) {\n\t\tctrl |= PWM_LOCK_EN;\n\t\twritel_relaxed(ctrl, pc->base + pc->data->regs.ctrl);\n\t}\n\n\twritel(period, pc->base + pc->data->regs.period);\n\twritel(duty, pc->base + pc->data->regs.duty);\n\n\tif (pc->data->supports_polarity) {\n\t\tctrl &= ~PWM_POLARITY_MASK;\n\t\tif (state->polarity == PWM_POLARITY_INVERSED)\n\t\t\tctrl |= PWM_DUTY_NEGATIVE | PWM_INACTIVE_POSITIVE;\n\t\telse\n\t\t\tctrl |= PWM_DUTY_POSITIVE | PWM_INACTIVE_NEGATIVE;\n\t}\n\n\t \n\tif (pc->data->supports_lock)\n\t\tctrl &= ~PWM_LOCK_EN;\n\n\twritel(ctrl, pc->base + pc->data->regs.ctrl);\n}\n\nstatic int rockchip_pwm_enable(struct pwm_chip *chip,\n\t\t\t       struct pwm_device *pwm,\n\t\t\t       bool enable)\n{\n\tstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\n\tu32 enable_conf = pc->data->enable_conf;\n\tint ret;\n\tu32 val;\n\n\tif (enable) {\n\t\tret = clk_enable(pc->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tval = readl_relaxed(pc->base + pc->data->regs.ctrl);\n\n\tif (enable)\n\t\tval |= enable_conf;\n\telse\n\t\tval &= ~enable_conf;\n\n\twritel_relaxed(val, pc->base + pc->data->regs.ctrl);\n\n\tif (!enable)\n\t\tclk_disable(pc->clk);\n\n\treturn 0;\n}\n\nstatic int rockchip_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      const struct pwm_state *state)\n{\n\tstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\n\tstruct pwm_state curstate;\n\tbool enabled;\n\tint ret = 0;\n\n\tret = clk_enable(pc->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_enable(pc->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tpwm_get_state(pwm, &curstate);\n\tenabled = curstate.enabled;\n\n\tif (state->polarity != curstate.polarity && enabled &&\n\t    !pc->data->supports_lock) {\n\t\tret = rockchip_pwm_enable(chip, pwm, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tenabled = false;\n\t}\n\n\trockchip_pwm_config(chip, pwm, state);\n\tif (state->enabled != enabled) {\n\t\tret = rockchip_pwm_enable(chip, pwm, state->enabled);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tclk_disable(pc->clk);\n\tclk_disable(pc->pclk);\n\n\treturn ret;\n}\n\nstatic const struct pwm_ops rockchip_pwm_ops = {\n\t.get_state = rockchip_pwm_get_state,\n\t.apply = rockchip_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct rockchip_pwm_data pwm_data_v1 = {\n\t.regs = {\n\t\t.duty = 0x04,\n\t\t.period = 0x08,\n\t\t.cntr = 0x00,\n\t\t.ctrl = 0x0c,\n\t},\n\t.prescaler = 2,\n\t.supports_polarity = false,\n\t.supports_lock = false,\n\t.enable_conf = PWM_CTRL_OUTPUT_EN | PWM_CTRL_TIMER_EN,\n};\n\nstatic const struct rockchip_pwm_data pwm_data_v2 = {\n\t.regs = {\n\t\t.duty = 0x08,\n\t\t.period = 0x04,\n\t\t.cntr = 0x00,\n\t\t.ctrl = 0x0c,\n\t},\n\t.prescaler = 1,\n\t.supports_polarity = true,\n\t.supports_lock = false,\n\t.enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | PWM_ENABLE |\n\t\t       PWM_CONTINUOUS,\n};\n\nstatic const struct rockchip_pwm_data pwm_data_vop = {\n\t.regs = {\n\t\t.duty = 0x08,\n\t\t.period = 0x04,\n\t\t.cntr = 0x0c,\n\t\t.ctrl = 0x00,\n\t},\n\t.prescaler = 1,\n\t.supports_polarity = true,\n\t.supports_lock = false,\n\t.enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | PWM_ENABLE |\n\t\t       PWM_CONTINUOUS,\n};\n\nstatic const struct rockchip_pwm_data pwm_data_v3 = {\n\t.regs = {\n\t\t.duty = 0x08,\n\t\t.period = 0x04,\n\t\t.cntr = 0x00,\n\t\t.ctrl = 0x0c,\n\t},\n\t.prescaler = 1,\n\t.supports_polarity = true,\n\t.supports_lock = true,\n\t.enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | PWM_ENABLE |\n\t\t       PWM_CONTINUOUS,\n};\n\nstatic const struct of_device_id rockchip_pwm_dt_ids[] = {\n\t{ .compatible = \"rockchip,rk2928-pwm\", .data = &pwm_data_v1},\n\t{ .compatible = \"rockchip,rk3288-pwm\", .data = &pwm_data_v2},\n\t{ .compatible = \"rockchip,vop-pwm\", .data = &pwm_data_vop},\n\t{ .compatible = \"rockchip,rk3328-pwm\", .data = &pwm_data_v3},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rockchip_pwm_dt_ids);\n\nstatic int rockchip_pwm_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *id;\n\tstruct rockchip_pwm_chip *pc;\n\tu32 enable_conf, ctrl;\n\tbool enabled;\n\tint ret, count;\n\n\tid = of_match_device(rockchip_pwm_dt_ids, &pdev->dev);\n\tif (!id)\n\t\treturn -EINVAL;\n\n\tpc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tpc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->base))\n\t\treturn PTR_ERR(pc->base);\n\n\tpc->clk = devm_clk_get(&pdev->dev, \"pwm\");\n\tif (IS_ERR(pc->clk)) {\n\t\tpc->clk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(pc->clk))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(pc->clk),\n\t\t\t\t\t     \"Can't get PWM clk\\n\");\n\t}\n\n\tcount = of_count_phandle_with_args(pdev->dev.of_node,\n\t\t\t\t\t   \"clocks\", \"#clock-cells\");\n\tif (count == 2)\n\t\tpc->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\telse\n\t\tpc->pclk = pc->clk;\n\n\tif (IS_ERR(pc->pclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(pc->pclk), \"Can't get APB clk\\n\");\n\n\tret = clk_prepare_enable(pc->clk);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Can't prepare enable PWM clk\\n\");\n\n\tret = clk_prepare_enable(pc->pclk);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"Can't prepare enable APB clk\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, pc);\n\n\tpc->data = id->data;\n\tpc->chip.dev = &pdev->dev;\n\tpc->chip.ops = &rockchip_pwm_ops;\n\tpc->chip.npwm = 1;\n\n\tenable_conf = pc->data->enable_conf;\n\tctrl = readl_relaxed(pc->base + pc->data->regs.ctrl);\n\tenabled = (ctrl & enable_conf) == enable_conf;\n\n\tret = pwmchip_add(&pc->chip);\n\tif (ret < 0) {\n\t\tdev_err_probe(&pdev->dev, ret, \"pwmchip_add() failed\\n\");\n\t\tgoto err_pclk;\n\t}\n\n\t \n\tif (!enabled)\n\t\tclk_disable(pc->clk);\n\n\tclk_disable(pc->pclk);\n\n\treturn 0;\n\nerr_pclk:\n\tclk_disable_unprepare(pc->pclk);\nerr_clk:\n\tclk_disable_unprepare(pc->clk);\n\n\treturn ret;\n}\n\nstatic void rockchip_pwm_remove(struct platform_device *pdev)\n{\n\tstruct rockchip_pwm_chip *pc = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&pc->chip);\n\n\tclk_unprepare(pc->pclk);\n\tclk_unprepare(pc->clk);\n}\n\nstatic struct platform_driver rockchip_pwm_driver = {\n\t.driver = {\n\t\t.name = \"rockchip-pwm\",\n\t\t.of_match_table = rockchip_pwm_dt_ids,\n\t},\n\t.probe = rockchip_pwm_probe,\n\t.remove_new = rockchip_pwm_remove,\n};\nmodule_platform_driver(rockchip_pwm_driver);\n\nMODULE_AUTHOR(\"Beniamino Galvani <b.galvani@gmail.com>\");\nMODULE_DESCRIPTION(\"Rockchip SoC PWM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}