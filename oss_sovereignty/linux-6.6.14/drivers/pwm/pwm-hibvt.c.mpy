{
  "module_name": "pwm-hibvt.c",
  "hash_id": "5174564ab4ecb8580b5bc8152fc50d341dc799899f55b6edfac71aa0fa3cd490",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-hibvt.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/reset.h>\n\n#define PWM_CFG0_ADDR(x)    (((x) * 0x20) + 0x0)\n#define PWM_CFG1_ADDR(x)    (((x) * 0x20) + 0x4)\n#define PWM_CFG2_ADDR(x)    (((x) * 0x20) + 0x8)\n#define PWM_CTRL_ADDR(x)    (((x) * 0x20) + 0xC)\n\n#define PWM_ENABLE_SHIFT    0\n#define PWM_ENABLE_MASK     BIT(0)\n\n#define PWM_POLARITY_SHIFT  1\n#define PWM_POLARITY_MASK   BIT(1)\n\n#define PWM_KEEP_SHIFT      2\n#define PWM_KEEP_MASK       BIT(2)\n\n#define PWM_PERIOD_MASK     GENMASK(31, 0)\n#define PWM_DUTY_MASK       GENMASK(31, 0)\n\nstruct hibvt_pwm_chip {\n\tstruct pwm_chip\tchip;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tstruct reset_control *rstc;\n\tconst struct hibvt_pwm_soc *soc;\n};\n\nstruct hibvt_pwm_soc {\n\tu32 num_pwms;\n\tbool quirk_force_enable;\n};\n\nstatic const struct hibvt_pwm_soc hi3516cv300_soc_info = {\n\t.num_pwms = 4,\n};\n\nstatic const struct hibvt_pwm_soc hi3519v100_soc_info = {\n\t.num_pwms = 8,\n};\n\nstatic const struct hibvt_pwm_soc hi3559v100_shub_soc_info = {\n\t.num_pwms = 8,\n\t.quirk_force_enable = true,\n};\n\nstatic const struct hibvt_pwm_soc hi3559v100_soc_info = {\n\t.num_pwms = 2,\n\t.quirk_force_enable = true,\n};\n\nstatic inline struct hibvt_pwm_chip *to_hibvt_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct hibvt_pwm_chip, chip);\n}\n\nstatic void hibvt_pwm_set_bits(void __iomem *base, u32 offset,\n\t\t\t\t\tu32 mask, u32 data)\n{\n\tvoid __iomem *address = base + offset;\n\tu32 value;\n\n\tvalue = readl(address);\n\tvalue &= ~mask;\n\tvalue |= (data & mask);\n\twritel(value, address);\n}\n\nstatic void hibvt_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\n\n\thibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CTRL_ADDR(pwm->hwpwm),\n\t\t\tPWM_ENABLE_MASK, 0x1);\n}\n\nstatic void hibvt_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\n\n\thibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CTRL_ADDR(pwm->hwpwm),\n\t\t\tPWM_ENABLE_MASK, 0x0);\n}\n\nstatic void hibvt_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t\tint duty_cycle_ns, int period_ns)\n{\n\tstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\n\tu32 freq, period, duty;\n\n\tfreq = div_u64(clk_get_rate(hi_pwm_chip->clk), 1000000);\n\n\tperiod = div_u64(freq * period_ns, 1000);\n\tduty = div_u64(period * duty_cycle_ns, period_ns);\n\n\thibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CFG0_ADDR(pwm->hwpwm),\n\t\t\tPWM_PERIOD_MASK, period);\n\n\thibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CFG1_ADDR(pwm->hwpwm),\n\t\t\tPWM_DUTY_MASK, duty);\n}\n\nstatic void hibvt_pwm_set_polarity(struct pwm_chip *chip,\n\t\t\t\t\tstruct pwm_device *pwm,\n\t\t\t\t\tenum pwm_polarity polarity)\n{\n\tstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\n\n\tif (polarity == PWM_POLARITY_INVERSED)\n\t\thibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CTRL_ADDR(pwm->hwpwm),\n\t\t\t\tPWM_POLARITY_MASK, (0x1 << PWM_POLARITY_SHIFT));\n\telse\n\t\thibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CTRL_ADDR(pwm->hwpwm),\n\t\t\t\tPWM_POLARITY_MASK, (0x0 << PWM_POLARITY_SHIFT));\n}\n\nstatic int hibvt_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       struct pwm_state *state)\n{\n\tstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\n\tvoid __iomem *base;\n\tu32 freq, value;\n\n\tfreq = div_u64(clk_get_rate(hi_pwm_chip->clk), 1000000);\n\tbase = hi_pwm_chip->base;\n\n\tvalue = readl(base + PWM_CFG0_ADDR(pwm->hwpwm));\n\tstate->period = div_u64(value * 1000, freq);\n\n\tvalue = readl(base + PWM_CFG1_ADDR(pwm->hwpwm));\n\tstate->duty_cycle = div_u64(value * 1000, freq);\n\n\tvalue = readl(base + PWM_CTRL_ADDR(pwm->hwpwm));\n\tstate->enabled = (PWM_ENABLE_MASK & value);\n\tstate->polarity = (PWM_POLARITY_MASK & value) ? PWM_POLARITY_INVERSED : PWM_POLARITY_NORMAL;\n\n\treturn 0;\n}\n\nstatic int hibvt_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\n\n\tif (state->polarity != pwm->state.polarity)\n\t\thibvt_pwm_set_polarity(chip, pwm, state->polarity);\n\n\tif (state->period != pwm->state.period ||\n\t    state->duty_cycle != pwm->state.duty_cycle) {\n\t\thibvt_pwm_config(chip, pwm, state->duty_cycle, state->period);\n\n\t\t \n\t\tif (hi_pwm_chip->soc->quirk_force_enable && state->enabled)\n\t\t\thibvt_pwm_enable(chip, pwm);\n\t}\n\n\tif (state->enabled != pwm->state.enabled) {\n\t\tif (state->enabled)\n\t\t\thibvt_pwm_enable(chip, pwm);\n\t\telse\n\t\t\thibvt_pwm_disable(chip, pwm);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops hibvt_pwm_ops = {\n\t.get_state = hibvt_pwm_get_state,\n\t.apply = hibvt_pwm_apply,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic int hibvt_pwm_probe(struct platform_device *pdev)\n{\n\tconst struct hibvt_pwm_soc *soc =\n\t\t\t\tof_device_get_match_data(&pdev->dev);\n\tstruct hibvt_pwm_chip *pwm_chip;\n\tint ret, i;\n\n\tpwm_chip = devm_kzalloc(&pdev->dev, sizeof(*pwm_chip), GFP_KERNEL);\n\tif (pwm_chip == NULL)\n\t\treturn -ENOMEM;\n\n\tpwm_chip->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pwm_chip->clk)) {\n\t\tdev_err(&pdev->dev, \"getting clock failed with %ld\\n\",\n\t\t\t\tPTR_ERR(pwm_chip->clk));\n\t\treturn PTR_ERR(pwm_chip->clk);\n\t}\n\n\tpwm_chip->chip.ops = &hibvt_pwm_ops;\n\tpwm_chip->chip.dev = &pdev->dev;\n\tpwm_chip->chip.npwm = soc->num_pwms;\n\tpwm_chip->soc = soc;\n\n\tpwm_chip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pwm_chip->base))\n\t\treturn PTR_ERR(pwm_chip->base);\n\n\tret = clk_prepare_enable(pwm_chip->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpwm_chip->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(pwm_chip->rstc)) {\n\t\tclk_disable_unprepare(pwm_chip->clk);\n\t\treturn PTR_ERR(pwm_chip->rstc);\n\t}\n\n\treset_control_assert(pwm_chip->rstc);\n\tmsleep(30);\n\treset_control_deassert(pwm_chip->rstc);\n\n\tret = pwmchip_add(&pwm_chip->chip);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(pwm_chip->clk);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < pwm_chip->chip.npwm; i++) {\n\t\thibvt_pwm_set_bits(pwm_chip->base, PWM_CTRL_ADDR(i),\n\t\t\t\tPWM_KEEP_MASK, (0x1 << PWM_KEEP_SHIFT));\n\t}\n\n\tplatform_set_drvdata(pdev, pwm_chip);\n\n\treturn 0;\n}\n\nstatic void hibvt_pwm_remove(struct platform_device *pdev)\n{\n\tstruct hibvt_pwm_chip *pwm_chip;\n\n\tpwm_chip = platform_get_drvdata(pdev);\n\n\tpwmchip_remove(&pwm_chip->chip);\n\n\treset_control_assert(pwm_chip->rstc);\n\tmsleep(30);\n\treset_control_deassert(pwm_chip->rstc);\n\n\tclk_disable_unprepare(pwm_chip->clk);\n}\n\nstatic const struct of_device_id hibvt_pwm_of_match[] = {\n\t{ .compatible = \"hisilicon,hi3516cv300-pwm\",\n\t  .data = &hi3516cv300_soc_info },\n\t{ .compatible = \"hisilicon,hi3519v100-pwm\",\n\t  .data = &hi3519v100_soc_info },\n\t{ .compatible = \"hisilicon,hi3559v100-shub-pwm\",\n\t  .data = &hi3559v100_shub_soc_info },\n\t{ .compatible = \"hisilicon,hi3559v100-pwm\",\n\t  .data = &hi3559v100_soc_info },\n\t{  }\n};\nMODULE_DEVICE_TABLE(of, hibvt_pwm_of_match);\n\nstatic struct platform_driver hibvt_pwm_driver = {\n\t.driver = {\n\t\t.name = \"hibvt-pwm\",\n\t\t.of_match_table = hibvt_pwm_of_match,\n\t},\n\t.probe = hibvt_pwm_probe,\n\t.remove_new = hibvt_pwm_remove,\n};\nmodule_platform_driver(hibvt_pwm_driver);\n\nMODULE_AUTHOR(\"Jian Yuan\");\nMODULE_DESCRIPTION(\"HiSilicon BVT SoCs PWM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}