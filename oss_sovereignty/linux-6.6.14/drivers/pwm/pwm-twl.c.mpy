{
  "module_name": "pwm-twl.c",
  "hash_id": "12fc2ff555c055058848685cf5de46ac37f06d79c703823658a20805611e90df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-twl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/mfd/twl.h>\n#include <linux/slab.h>\n\n \n\n#define TWL_PWM_MAX\t\t0x7f\n\n \n#define TWL4030_GPBR1_REG\t0x0c\n#define TWL4030_PMBR1_REG\t0x0d\n\n \n#define TWL4030_PWMXCLK_ENABLE\t(1 << 0)\n#define TWL4030_PWMX_ENABLE\t(1 << 2)\n#define TWL4030_PWMX_BITS\t(TWL4030_PWMX_ENABLE | TWL4030_PWMXCLK_ENABLE)\n#define TWL4030_PWM_TOGGLE(pwm, x)\t((x) << (pwm))\n\n \n#define TWL4030_GPIO6_PWM0_MUTE_MASK\t\t(0x03 << 2)\n#define TWL4030_GPIO6_PWM0_MUTE_PWM0\t\t(0x01 << 2)\n#define TWL4030_GPIO7_VIBRASYNC_PWM1_MASK\t(0x03 << 4)\n#define TWL4030_GPIO7_VIBRASYNC_PWM1_PWM1\t(0x03 << 4)\n\n \n#define TWL6030_TOGGLE3_REG\t0x92\n\n#define TWL6030_PWMXR\t\t(1 << 0)\n#define TWL6030_PWMXS\t\t(1 << 1)\n#define TWL6030_PWMXEN\t\t(1 << 2)\n#define TWL6030_PWM_TOGGLE(pwm, x)\t((x) << (pwm * 3))\n\nstruct twl_pwm_chip {\n\tstruct pwm_chip chip;\n\tstruct mutex mutex;\n\tu8 twl6030_toggle3;\n\tu8 twl4030_pwm_mux;\n};\n\nstatic inline struct twl_pwm_chip *to_twl(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct twl_pwm_chip, chip);\n}\n\nstatic int twl_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  u64 duty_ns, u64 period_ns)\n{\n\tint duty_cycle = DIV64_U64_ROUND_UP(duty_ns * TWL_PWM_MAX, period_ns) + 1;\n\tu8 pwm_config[2] = { 1, 0 };\n\tint base, ret;\n\n\t \n\tif (duty_cycle == 1)\n\t\tduty_cycle = 2;\n\telse if (duty_cycle > TWL_PWM_MAX)\n\t\tduty_cycle = 1;\n\n\tbase = pwm->hwpwm * 3;\n\n\tpwm_config[1] = duty_cycle;\n\n\tret = twl_i2c_write(TWL_MODULE_PWM, pwm_config, base, 2);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"%s: Failed to configure PWM\\n\", pwm->label);\n\n\treturn ret;\n}\n\nstatic int twl4030_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct twl_pwm_chip *twl = to_twl(chip);\n\tint ret;\n\tu8 val;\n\n\tmutex_lock(&twl->mutex);\n\tret = twl_i2c_read_u8(TWL4030_MODULE_INTBR, &val, TWL4030_GPBR1_REG);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s: Failed to read GPBR1\\n\", pwm->label);\n\t\tgoto out;\n\t}\n\n\tval |= TWL4030_PWM_TOGGLE(pwm->hwpwm, TWL4030_PWMXCLK_ENABLE);\n\n\tret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, val, TWL4030_GPBR1_REG);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"%s: Failed to enable PWM\\n\", pwm->label);\n\n\tval |= TWL4030_PWM_TOGGLE(pwm->hwpwm, TWL4030_PWMX_ENABLE);\n\n\tret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, val, TWL4030_GPBR1_REG);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"%s: Failed to enable PWM\\n\", pwm->label);\n\nout:\n\tmutex_unlock(&twl->mutex);\n\treturn ret;\n}\n\nstatic void twl4030_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct twl_pwm_chip *twl = to_twl(chip);\n\tint ret;\n\tu8 val;\n\n\tmutex_lock(&twl->mutex);\n\tret = twl_i2c_read_u8(TWL4030_MODULE_INTBR, &val, TWL4030_GPBR1_REG);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s: Failed to read GPBR1\\n\", pwm->label);\n\t\tgoto out;\n\t}\n\n\tval &= ~TWL4030_PWM_TOGGLE(pwm->hwpwm, TWL4030_PWMX_ENABLE);\n\n\tret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, val, TWL4030_GPBR1_REG);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"%s: Failed to disable PWM\\n\", pwm->label);\n\n\tval &= ~TWL4030_PWM_TOGGLE(pwm->hwpwm, TWL4030_PWMXCLK_ENABLE);\n\n\tret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, val, TWL4030_GPBR1_REG);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"%s: Failed to disable PWM\\n\", pwm->label);\n\nout:\n\tmutex_unlock(&twl->mutex);\n}\n\nstatic int twl4030_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct twl_pwm_chip *twl = to_twl(chip);\n\tint ret;\n\tu8 val, mask, bits;\n\n\tif (pwm->hwpwm == 1) {\n\t\tmask = TWL4030_GPIO7_VIBRASYNC_PWM1_MASK;\n\t\tbits = TWL4030_GPIO7_VIBRASYNC_PWM1_PWM1;\n\t} else {\n\t\tmask = TWL4030_GPIO6_PWM0_MUTE_MASK;\n\t\tbits = TWL4030_GPIO6_PWM0_MUTE_PWM0;\n\t}\n\n\tmutex_lock(&twl->mutex);\n\tret = twl_i2c_read_u8(TWL4030_MODULE_INTBR, &val, TWL4030_PMBR1_REG);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s: Failed to read PMBR1\\n\", pwm->label);\n\t\tgoto out;\n\t}\n\n\t \n\ttwl->twl4030_pwm_mux &= ~mask;\n\ttwl->twl4030_pwm_mux |= (val & mask);\n\n\t \n\tval &= ~mask;\n\tval |= bits;\n\n\tret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, val, TWL4030_PMBR1_REG);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"%s: Failed to request PWM\\n\", pwm->label);\n\nout:\n\tmutex_unlock(&twl->mutex);\n\treturn ret;\n}\n\nstatic void twl4030_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct twl_pwm_chip *twl = to_twl(chip);\n\tint ret;\n\tu8 val, mask;\n\n\tif (pwm->hwpwm == 1)\n\t\tmask = TWL4030_GPIO7_VIBRASYNC_PWM1_MASK;\n\telse\n\t\tmask = TWL4030_GPIO6_PWM0_MUTE_MASK;\n\n\tmutex_lock(&twl->mutex);\n\tret = twl_i2c_read_u8(TWL4030_MODULE_INTBR, &val, TWL4030_PMBR1_REG);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s: Failed to read PMBR1\\n\", pwm->label);\n\t\tgoto out;\n\t}\n\n\t \n\tval &= ~mask;\n\tval |= (twl->twl4030_pwm_mux & mask);\n\n\tret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, val, TWL4030_PMBR1_REG);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"%s: Failed to free PWM\\n\", pwm->label);\n\nout:\n\tmutex_unlock(&twl->mutex);\n}\n\nstatic int twl6030_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct twl_pwm_chip *twl = to_twl(chip);\n\tint ret;\n\tu8 val;\n\n\tmutex_lock(&twl->mutex);\n\tval = twl->twl6030_toggle3;\n\tval |= TWL6030_PWM_TOGGLE(pwm->hwpwm, TWL6030_PWMXS | TWL6030_PWMXEN);\n\tval &= ~TWL6030_PWM_TOGGLE(pwm->hwpwm, TWL6030_PWMXR);\n\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID1, val, TWL6030_TOGGLE3_REG);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s: Failed to enable PWM\\n\", pwm->label);\n\t\tgoto out;\n\t}\n\n\ttwl->twl6030_toggle3 = val;\nout:\n\tmutex_unlock(&twl->mutex);\n\treturn ret;\n}\n\nstatic void twl6030_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct twl_pwm_chip *twl = to_twl(chip);\n\tint ret;\n\tu8 val;\n\n\tmutex_lock(&twl->mutex);\n\tval = twl->twl6030_toggle3;\n\tval |= TWL6030_PWM_TOGGLE(pwm->hwpwm, TWL6030_PWMXR);\n\tval &= ~TWL6030_PWM_TOGGLE(pwm->hwpwm, TWL6030_PWMXS | TWL6030_PWMXEN);\n\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID1, val, TWL6030_TOGGLE3_REG);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s: Failed to disable PWM\\n\", pwm->label);\n\t\tgoto out;\n\t}\n\n\tval |= TWL6030_PWM_TOGGLE(pwm->hwpwm, TWL6030_PWMXEN);\n\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID1, val, TWL6030_TOGGLE3_REG);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s: Failed to disable PWM\\n\", pwm->label);\n\t\tgoto out;\n\t}\n\n\tval &= ~TWL6030_PWM_TOGGLE(pwm->hwpwm, TWL6030_PWMXEN);\n\n\tret = twl_i2c_write_u8(TWL6030_MODULE_ID1, val, TWL6030_TOGGLE3_REG);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"%s: Failed to disable PWM\\n\", pwm->label);\n\t\tgoto out;\n\t}\n\n\ttwl->twl6030_toggle3 = val;\nout:\n\tmutex_unlock(&twl->mutex);\n}\n\nstatic int twl4030_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled)\n\t\t\ttwl4030_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\terr = twl_pwm_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\terr = twl4030_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic int twl6030_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t     const struct pwm_state *state)\n{\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled)\n\t\t\ttwl6030_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\terr = twl_pwm_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\terr = twl6030_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops twl4030_pwm_ops = {\n\t.apply = twl4030_pwm_apply,\n\t.request = twl4030_pwm_request,\n\t.free = twl4030_pwm_free,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct pwm_ops twl6030_pwm_ops = {\n\t.apply = twl6030_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int twl_pwm_probe(struct platform_device *pdev)\n{\n\tstruct twl_pwm_chip *twl;\n\n\ttwl = devm_kzalloc(&pdev->dev, sizeof(*twl), GFP_KERNEL);\n\tif (!twl)\n\t\treturn -ENOMEM;\n\n\tif (twl_class_is_4030())\n\t\ttwl->chip.ops = &twl4030_pwm_ops;\n\telse\n\t\ttwl->chip.ops = &twl6030_pwm_ops;\n\n\ttwl->chip.dev = &pdev->dev;\n\ttwl->chip.npwm = 2;\n\n\tmutex_init(&twl->mutex);\n\n\treturn devm_pwmchip_add(&pdev->dev, &twl->chip);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id twl_pwm_of_match[] = {\n\t{ .compatible = \"ti,twl4030-pwm\" },\n\t{ .compatible = \"ti,twl6030-pwm\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, twl_pwm_of_match);\n#endif\n\nstatic struct platform_driver twl_pwm_driver = {\n\t.driver = {\n\t\t.name = \"twl-pwm\",\n\t\t.of_match_table = of_match_ptr(twl_pwm_of_match),\n\t},\n\t.probe = twl_pwm_probe,\n};\nmodule_platform_driver(twl_pwm_driver);\n\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_DESCRIPTION(\"PWM driver for TWL4030 and TWL6030\");\nMODULE_ALIAS(\"platform:twl-pwm\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}