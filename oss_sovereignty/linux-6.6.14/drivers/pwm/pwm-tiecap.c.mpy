{
  "module_name": "pwm-tiecap.c",
  "hash_id": "836c65c4c50a31776a019a7dfb04a94394a155a27d9f65a5c20945e08c68117d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-tiecap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n#include <linux/of.h>\n\n \n#define CAP1\t\t\t0x08\n#define CAP2\t\t\t0x0C\n#define CAP3\t\t\t0x10\n#define CAP4\t\t\t0x14\n#define ECCTL2\t\t\t0x2A\n#define ECCTL2_APWM_POL_LOW\tBIT(10)\n#define ECCTL2_APWM_MODE\tBIT(9)\n#define ECCTL2_SYNC_SEL_DISA\t(BIT(7) | BIT(6))\n#define ECCTL2_TSCTR_FREERUN\tBIT(4)\n\nstruct ecap_context {\n\tu32 cap3;\n\tu32 cap4;\n\tu16 ecctl2;\n};\n\nstruct ecap_pwm_chip {\n\tstruct pwm_chip chip;\n\tunsigned int clk_rate;\n\tvoid __iomem *mmio_base;\n\tstruct ecap_context ctx;\n};\n\nstatic inline struct ecap_pwm_chip *to_ecap_pwm_chip(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct ecap_pwm_chip, chip);\n}\n\n \nstatic int ecap_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   int duty_ns, int period_ns, int enabled)\n{\n\tstruct ecap_pwm_chip *pc = to_ecap_pwm_chip(chip);\n\tu32 period_cycles, duty_cycles;\n\tunsigned long long c;\n\tu16 value;\n\n\tc = pc->clk_rate;\n\tc = c * period_ns;\n\tdo_div(c, NSEC_PER_SEC);\n\tperiod_cycles = (u32)c;\n\n\tif (period_cycles < 1) {\n\t\tperiod_cycles = 1;\n\t\tduty_cycles = 1;\n\t} else {\n\t\tc = pc->clk_rate;\n\t\tc = c * duty_ns;\n\t\tdo_div(c, NSEC_PER_SEC);\n\t\tduty_cycles = (u32)c;\n\t}\n\n\tpm_runtime_get_sync(pc->chip.dev);\n\n\tvalue = readw(pc->mmio_base + ECCTL2);\n\n\t \n\tvalue |= ECCTL2_APWM_MODE | ECCTL2_SYNC_SEL_DISA;\n\n\twritew(value, pc->mmio_base + ECCTL2);\n\n\tif (!enabled) {\n\t\t \n\t\twritel(duty_cycles, pc->mmio_base + CAP2);\n\t\twritel(period_cycles, pc->mmio_base + CAP1);\n\t} else {\n\t\t \n\t\twritel(duty_cycles, pc->mmio_base + CAP4);\n\t\twritel(period_cycles, pc->mmio_base + CAP3);\n\t}\n\n\tif (!enabled) {\n\t\tvalue = readw(pc->mmio_base + ECCTL2);\n\t\t \n\t\tvalue &= ~ECCTL2_APWM_MODE;\n\t\twritew(value, pc->mmio_base + ECCTL2);\n\t}\n\n\tpm_runtime_put_sync(pc->chip.dev);\n\n\treturn 0;\n}\n\nstatic int ecap_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t enum pwm_polarity polarity)\n{\n\tstruct ecap_pwm_chip *pc = to_ecap_pwm_chip(chip);\n\tu16 value;\n\n\tpm_runtime_get_sync(pc->chip.dev);\n\n\tvalue = readw(pc->mmio_base + ECCTL2);\n\n\tif (polarity == PWM_POLARITY_INVERSED)\n\t\t \n\t\tvalue |= ECCTL2_APWM_POL_LOW;\n\telse\n\t\t \n\t\tvalue &= ~ECCTL2_APWM_POL_LOW;\n\n\twritew(value, pc->mmio_base + ECCTL2);\n\n\tpm_runtime_put_sync(pc->chip.dev);\n\n\treturn 0;\n}\n\nstatic int ecap_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct ecap_pwm_chip *pc = to_ecap_pwm_chip(chip);\n\tu16 value;\n\n\t \n\tpm_runtime_get_sync(pc->chip.dev);\n\n\t \n\tvalue = readw(pc->mmio_base + ECCTL2);\n\tvalue |= ECCTL2_TSCTR_FREERUN | ECCTL2_APWM_MODE;\n\twritew(value, pc->mmio_base + ECCTL2);\n\n\treturn 0;\n}\n\nstatic void ecap_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct ecap_pwm_chip *pc = to_ecap_pwm_chip(chip);\n\tu16 value;\n\n\t \n\tvalue = readw(pc->mmio_base + ECCTL2);\n\tvalue &= ~(ECCTL2_TSCTR_FREERUN | ECCTL2_APWM_MODE);\n\twritew(value, pc->mmio_base + ECCTL2);\n\n\t \n\tpm_runtime_put_sync(pc->chip.dev);\n}\n\nstatic int ecap_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t  const struct pwm_state *state)\n{\n\tint err;\n\tint enabled = pwm->state.enabled;\n\n\tif (state->polarity != pwm->state.polarity) {\n\n\t\tif (enabled) {\n\t\t\tecap_pwm_disable(chip, pwm);\n\t\t\tenabled = false;\n\t\t}\n\n\t\terr = ecap_pwm_set_polarity(chip, pwm, state->polarity);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!state->enabled) {\n\t\tif (enabled)\n\t\t\tecap_pwm_disable(chip, pwm);\n\t\treturn 0;\n\t}\n\n\tif (state->period > NSEC_PER_SEC)\n\t\treturn -ERANGE;\n\n\terr = ecap_pwm_config(chip, pwm, state->duty_cycle,\n\t\t\t      state->period, enabled);\n\tif (err)\n\t\treturn err;\n\n\tif (!enabled)\n\t\treturn ecap_pwm_enable(chip, pwm);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops ecap_pwm_ops = {\n\t.apply = ecap_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id ecap_of_match[] = {\n\t{ .compatible\t= \"ti,am3352-ecap\" },\n\t{ .compatible\t= \"ti,am33xx-ecap\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ecap_of_match);\n\nstatic int ecap_pwm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct ecap_pwm_chip *pc;\n\tstruct clk *clk;\n\tint ret;\n\n\tpc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tclk = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(clk)) {\n\t\tif (of_device_is_compatible(np, \"ti,am33xx-ecap\")) {\n\t\t\tdev_warn(&pdev->dev, \"Binding is obsolete.\\n\");\n\t\t\tclk = devm_clk_get(pdev->dev.parent, \"fck\");\n\t\t}\n\t}\n\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tpc->clk_rate = clk_get_rate(clk);\n\tif (!pc->clk_rate) {\n\t\tdev_err(&pdev->dev, \"failed to get clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpc->chip.dev = &pdev->dev;\n\tpc->chip.ops = &ecap_pwm_ops;\n\tpc->chip.npwm = 1;\n\n\tpc->mmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->mmio_base))\n\t\treturn PTR_ERR(pc->mmio_base);\n\n\tret = devm_pwmchip_add(&pdev->dev, &pc->chip);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pwmchip_add() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, pc);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void ecap_pwm_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void ecap_pwm_save_context(struct ecap_pwm_chip *pc)\n{\n\tpm_runtime_get_sync(pc->chip.dev);\n\tpc->ctx.ecctl2 = readw(pc->mmio_base + ECCTL2);\n\tpc->ctx.cap4 = readl(pc->mmio_base + CAP4);\n\tpc->ctx.cap3 = readl(pc->mmio_base + CAP3);\n\tpm_runtime_put_sync(pc->chip.dev);\n}\n\nstatic void ecap_pwm_restore_context(struct ecap_pwm_chip *pc)\n{\n\twritel(pc->ctx.cap3, pc->mmio_base + CAP3);\n\twritel(pc->ctx.cap4, pc->mmio_base + CAP4);\n\twritew(pc->ctx.ecctl2, pc->mmio_base + ECCTL2);\n}\n\nstatic int ecap_pwm_suspend(struct device *dev)\n{\n\tstruct ecap_pwm_chip *pc = dev_get_drvdata(dev);\n\tstruct pwm_device *pwm = pc->chip.pwms;\n\n\tecap_pwm_save_context(pc);\n\n\t \n\tif (pwm_is_enabled(pwm))\n\t\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int ecap_pwm_resume(struct device *dev)\n{\n\tstruct ecap_pwm_chip *pc = dev_get_drvdata(dev);\n\tstruct pwm_device *pwm = pc->chip.pwms;\n\n\t \n\tif (pwm_is_enabled(pwm))\n\t\tpm_runtime_get_sync(dev);\n\n\tecap_pwm_restore_context(pc);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ecap_pwm_pm_ops, ecap_pwm_suspend, ecap_pwm_resume);\n\nstatic struct platform_driver ecap_pwm_driver = {\n\t.driver = {\n\t\t.name = \"ecap\",\n\t\t.of_match_table = ecap_of_match,\n\t\t.pm = &ecap_pwm_pm_ops,\n\t},\n\t.probe = ecap_pwm_probe,\n\t.remove_new = ecap_pwm_remove,\n};\nmodule_platform_driver(ecap_pwm_driver);\n\nMODULE_DESCRIPTION(\"ECAP PWM driver\");\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}