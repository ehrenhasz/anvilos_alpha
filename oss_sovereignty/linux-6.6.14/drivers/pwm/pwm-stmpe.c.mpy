{
  "module_name": "pwm-stmpe.c",
  "hash_id": "680003e5f2218d77964d6a62ab79eafcbb047dca936b10d06adf331a27fc7eb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-stmpe.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/mfd/stmpe.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/slab.h>\n\n#define STMPE24XX_PWMCS\t\t0x30\n#define PWMCS_EN_PWM0\t\tBIT(0)\n#define PWMCS_EN_PWM1\t\tBIT(1)\n#define PWMCS_EN_PWM2\t\tBIT(2)\n#define STMPE24XX_PWMIC0\t0x38\n#define STMPE24XX_PWMIC1\t0x39\n#define STMPE24XX_PWMIC2\t0x3a\n\n#define STMPE_PWM_24XX_PINBASE\t21\n\nstruct stmpe_pwm {\n\tstruct stmpe *stmpe;\n\tstruct pwm_chip chip;\n\tu8 last_duty;\n};\n\nstatic inline struct stmpe_pwm *to_stmpe_pwm(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct stmpe_pwm, chip);\n}\n\nstatic int stmpe_24xx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct stmpe_pwm *stmpe_pwm = to_stmpe_pwm(chip);\n\tu8 value;\n\tint ret;\n\n\tret = stmpe_reg_read(stmpe_pwm->stmpe, STMPE24XX_PWMCS);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"error reading PWM#%u control\\n\",\n\t\t\tpwm->hwpwm);\n\t\treturn ret;\n\t}\n\n\tvalue = ret | BIT(pwm->hwpwm);\n\n\tret = stmpe_reg_write(stmpe_pwm->stmpe, STMPE24XX_PWMCS, value);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"error writing PWM#%u control\\n\",\n\t\t\tpwm->hwpwm);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmpe_24xx_pwm_disable(struct pwm_chip *chip,\n\t\t\t\t  struct pwm_device *pwm)\n{\n\tstruct stmpe_pwm *stmpe_pwm = to_stmpe_pwm(chip);\n\tu8 value;\n\tint ret;\n\n\tret = stmpe_reg_read(stmpe_pwm->stmpe, STMPE24XX_PWMCS);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"error reading PWM#%u control\\n\",\n\t\t\tpwm->hwpwm);\n\t\treturn ret;\n\t}\n\n\tvalue = ret & ~BIT(pwm->hwpwm);\n\n\tret = stmpe_reg_write(stmpe_pwm->stmpe, STMPE24XX_PWMCS, value);\n\tif (ret)\n\t\tdev_err(chip->dev, \"error writing PWM#%u control\\n\",\n\t\t\tpwm->hwpwm);\n\treturn ret;\n}\n\n \n#define SMAX\t\t0x007f\n#define SMIN\t\t0x00ff\n#define GTS\t\t0x0000\n#define LOAD\t\tBIT(14)  \n#define RAMPUP\t\t0x0000\n#define RAMPDOWN\tBIT(7)\n#define PRESCALE_512\tBIT(14)\n#define STEPTIME_1\tBIT(8)\n#define BRANCH\t\t(BIT(15) | BIT(13))\n\nstatic int stmpe_24xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\t int duty_ns, int period_ns)\n{\n\tstruct stmpe_pwm *stmpe_pwm = to_stmpe_pwm(chip);\n\tunsigned int i, pin;\n\tu16 program[3] = {\n\t\tSMAX,\n\t\tGTS,\n\t\tGTS,\n\t};\n\tu8 offset;\n\tint ret;\n\n\t \n\tif (pwm_is_enabled(pwm)) {\n\t\tret = stmpe_24xx_pwm_disable(chip, pwm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tpin = pwm->hwpwm;\n\n\t\t \n\t\tif (stmpe_pwm->stmpe->partnum == STMPE2401 ||\n\t\t    stmpe_pwm->stmpe->partnum == STMPE2403)\n\t\t\tpin += STMPE_PWM_24XX_PINBASE;\n\n\t\tret = stmpe_set_altfunc(stmpe_pwm->stmpe, BIT(pin),\n\t\t\t\t\tSTMPE_BLOCK_PWM);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev, \"unable to connect PWM#%u to pin\\n\",\n\t\t\t\tpwm->hwpwm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tswitch (pwm->hwpwm) {\n\tcase 0:\n\t\toffset = STMPE24XX_PWMIC0;\n\t\tbreak;\n\n\tcase 1:\n\t\toffset = STMPE24XX_PWMIC1;\n\t\tbreak;\n\n\tcase 2:\n\t\toffset = STMPE24XX_PWMIC2;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(chip->dev, \"PWM#%u: config duty %d ns, period %d ns\\n\",\n\t\tpwm->hwpwm, duty_ns, period_ns);\n\n\tif (duty_ns == 0) {\n\t\tif (stmpe_pwm->stmpe->partnum == STMPE2401)\n\t\t\tprogram[0] = SMAX;  \n\n\t\tif (stmpe_pwm->stmpe->partnum == STMPE2403)\n\t\t\tprogram[0] = LOAD | 0xff;  \n\n\t\tstmpe_pwm->last_duty = 0x00;\n\t} else if (duty_ns == period_ns) {\n\t\tif (stmpe_pwm->stmpe->partnum == STMPE2401)\n\t\t\tprogram[0] = SMIN;  \n\n\t\tif (stmpe_pwm->stmpe->partnum == STMPE2403)\n\t\t\tprogram[0] = LOAD | 0x00;  \n\n\t\tstmpe_pwm->last_duty = 0xff;\n\t} else {\n\t\tu8 value, last = stmpe_pwm->last_duty;\n\t\tunsigned long duty;\n\n\t\t \n\n\t\t \n\t\tduty = duty_ns * 256;\n\t\tduty = DIV_ROUND_CLOSEST(duty, period_ns);\n\t\tvalue = duty;\n\n\t\tif (value == last) {\n\t\t\t \n\t\t\tif (pwm_is_enabled(pwm))\n\t\t\t\tstmpe_24xx_pwm_enable(chip, pwm);\n\n\t\t\treturn 0;\n\t\t} else if (stmpe_pwm->stmpe->partnum == STMPE2403) {\n\t\t\t \n\t\t\tprogram[0] = LOAD | value;\n\t\t\tprogram[1] = 0x0000;\n\t\t} else if (stmpe_pwm->stmpe->partnum == STMPE2401) {\n\t\t\t \n\t\t\tu16 incdec = 0x0000;\n\n\t\t\tif (last < value)\n\t\t\t\t \n\t\t\t\tincdec = RAMPUP | (value - last);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tincdec = RAMPDOWN | (last - value);\n\n\t\t\t \n\t\t\tprogram[0] = PRESCALE_512 | STEPTIME_1 | incdec;\n\n\t\t\t \n\t\t\tprogram[1] = BRANCH;\n\t\t}\n\n\t\tdev_dbg(chip->dev,\n\t\t\t\"PWM#%u: value = %02x, last_duty = %02x, program=%04x,%04x,%04x\\n\",\n\t\t\tpwm->hwpwm, value, last, program[0], program[1],\n\t\t\tprogram[2]);\n\t\tstmpe_pwm->last_duty = value;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(program); i++) {\n\t\tu8 value;\n\n\t\tvalue = (program[i] >> 8) & 0xff;\n\n\t\tret = stmpe_reg_write(stmpe_pwm->stmpe, offset, value);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev, \"error writing register %02x: %d\\n\",\n\t\t\t\toffset, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tvalue = program[i] & 0xff;\n\n\t\tret = stmpe_reg_write(stmpe_pwm->stmpe, offset, value);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev, \"error writing register %02x: %d\\n\",\n\t\t\t\toffset, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (pwm_is_enabled(pwm))\n\t\tstmpe_24xx_pwm_enable(chip, pwm);\n\n\t \n\tmsleep(200);\n\n\tdev_dbg(chip->dev, \"programmed PWM#%u, %u bytes\\n\", pwm->hwpwm, i);\n\n\treturn 0;\n}\n\nstatic int stmpe_24xx_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t\tconst struct pwm_state *state)\n{\n\tint err;\n\n\tif (state->polarity != PWM_POLARITY_NORMAL)\n\t\treturn -EINVAL;\n\n\tif (!state->enabled) {\n\t\tif (pwm->state.enabled)\n\t\t\treturn stmpe_24xx_pwm_disable(chip, pwm);\n\n\t\treturn 0;\n\t}\n\n\terr = stmpe_24xx_pwm_config(pwm->chip, pwm, state->duty_cycle, state->period);\n\tif (err)\n\t\treturn err;\n\n\tif (!pwm->state.enabled)\n\t\terr = stmpe_24xx_pwm_enable(chip, pwm);\n\n\treturn err;\n}\n\nstatic const struct pwm_ops stmpe_24xx_pwm_ops = {\n\t.apply = stmpe_24xx_pwm_apply,\n\t.owner = THIS_MODULE,\n};\n\nstatic int __init stmpe_pwm_probe(struct platform_device *pdev)\n{\n\tstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\n\tstruct stmpe_pwm *stmpe_pwm;\n\tint ret;\n\n\tstmpe_pwm = devm_kzalloc(&pdev->dev, sizeof(*stmpe_pwm), GFP_KERNEL);\n\tif (!stmpe_pwm)\n\t\treturn -ENOMEM;\n\n\tstmpe_pwm->stmpe = stmpe;\n\tstmpe_pwm->chip.dev = &pdev->dev;\n\n\tif (stmpe->partnum == STMPE2401 || stmpe->partnum == STMPE2403) {\n\t\tstmpe_pwm->chip.ops = &stmpe_24xx_pwm_ops;\n\t\tstmpe_pwm->chip.npwm = 3;\n\t} else {\n\t\tif (stmpe->partnum == STMPE1601)\n\t\t\tdev_err(&pdev->dev, \"STMPE1601 not yet supported\\n\");\n\t\telse\n\t\t\tdev_err(&pdev->dev, \"Unknown STMPE PWM\\n\");\n\n\t\treturn -ENODEV;\n\t}\n\n\tret = stmpe_enable(stmpe, STMPE_BLOCK_PWM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pwmchip_add(&stmpe_pwm->chip);\n\tif (ret) {\n\t\tstmpe_disable(stmpe, STMPE_BLOCK_PWM);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver stmpe_pwm_driver = {\n\t.driver = {\n\t\t.name = \"stmpe-pwm\",\n\t},\n};\nbuiltin_platform_driver_probe(stmpe_pwm_driver, stmpe_pwm_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}