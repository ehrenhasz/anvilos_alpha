{
  "module_name": "pwm-stm32-lp.c",
  "hash_id": "863686e863757d57988aaac95e9c81c5e4ce740ad17163b14e5b451f8a1c8c00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pwm/pwm-stm32-lp.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/mfd/stm32-lptimer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n\nstruct stm32_pwm_lp {\n\tstruct pwm_chip chip;\n\tstruct clk *clk;\n\tstruct regmap *regmap;\n};\n\nstatic inline struct stm32_pwm_lp *to_stm32_pwm_lp(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct stm32_pwm_lp, chip);\n}\n\n \n#define STM32_LPTIM_MAX_PRESCALER\t128\n\nstatic int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t      const struct pwm_state *state)\n{\n\tstruct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);\n\tunsigned long long prd, div, dty;\n\tstruct pwm_state cstate;\n\tu32 val, mask, cfgr, presc = 0;\n\tbool reenable;\n\tint ret;\n\n\tpwm_get_state(pwm, &cstate);\n\treenable = !cstate.enabled;\n\n\tif (!state->enabled) {\n\t\tif (cstate.enabled) {\n\t\t\t \n\t\t\tret = regmap_write(priv->regmap, STM32_LPTIM_CR, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\tclk_disable(priv->clk);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tdiv = (unsigned long long)clk_get_rate(priv->clk) * state->period;\n\tdo_div(div, NSEC_PER_SEC);\n\tif (!div) {\n\t\t \n\t\tdev_dbg(priv->chip.dev, \"Can't reach %llu ns\\n\", state->period);\n\t\treturn -EINVAL;\n\t}\n\n\tprd = div;\n\twhile (div > STM32_LPTIM_MAX_ARR) {\n\t\tpresc++;\n\t\tif ((1 << presc) > STM32_LPTIM_MAX_PRESCALER) {\n\t\t\tdev_err(priv->chip.dev, \"max prescaler exceeded\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdiv = prd >> presc;\n\t}\n\tprd = div;\n\n\t \n\tdty = prd * state->duty_cycle;\n\tdo_div(dty, state->period);\n\n\tif (!cstate.enabled) {\n\t\t \n\t\tret = clk_enable(priv->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_read(priv->regmap, STM32_LPTIM_CFGR, &cfgr);\n\tif (ret)\n\t\tgoto err;\n\n\tif ((FIELD_GET(STM32_LPTIM_PRESC, cfgr) != presc) ||\n\t    (FIELD_GET(STM32_LPTIM_WAVPOL, cfgr) != state->polarity)) {\n\t\tval = FIELD_PREP(STM32_LPTIM_PRESC, presc);\n\t\tval |= FIELD_PREP(STM32_LPTIM_WAVPOL, state->polarity);\n\t\tmask = STM32_LPTIM_PRESC | STM32_LPTIM_WAVPOL;\n\n\t\t \n\t\treenable = true;\n\t\tret = regmap_write(priv->regmap, STM32_LPTIM_CR, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = regmap_update_bits(priv->regmap, STM32_LPTIM_CFGR, mask,\n\t\t\t\t\t val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (reenable) {\n\t\t \n\t\tret = regmap_write(priv->regmap, STM32_LPTIM_CR,\n\t\t\t\t   STM32_LPTIM_ENABLE);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = regmap_write(priv->regmap, STM32_LPTIM_ARR, prd - 1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(priv->regmap, STM32_LPTIM_CMP, prd - (1 + dty));\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = regmap_read_poll_timeout(priv->regmap, STM32_LPTIM_ISR, val,\n\t\t\t\t       (val & STM32_LPTIM_CMPOK_ARROK) == STM32_LPTIM_CMPOK_ARROK,\n\t\t\t\t       100, 1000);\n\tif (ret) {\n\t\tdev_err(priv->chip.dev, \"ARR/CMP registers write issue\\n\");\n\t\tgoto err;\n\t}\n\tret = regmap_write(priv->regmap, STM32_LPTIM_ICR,\n\t\t\t   STM32_LPTIM_CMPOKCF_ARROKCF);\n\tif (ret)\n\t\tgoto err;\n\n\tif (reenable) {\n\t\t \n\t\tret = regmap_set_bits(priv->regmap, STM32_LPTIM_CR,\n\t\t\t\t      STM32_LPTIM_CNTSTRT);\n\t\tif (ret) {\n\t\t\tregmap_write(priv->regmap, STM32_LPTIM_CR, 0);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tif (!cstate.enabled)\n\t\tclk_disable(priv->clk);\n\n\treturn ret;\n}\n\nstatic int stm32_pwm_lp_get_state(struct pwm_chip *chip,\n\t\t\t\t  struct pwm_device *pwm,\n\t\t\t\t  struct pwm_state *state)\n{\n\tstruct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);\n\tunsigned long rate = clk_get_rate(priv->clk);\n\tu32 val, presc, prd;\n\tu64 tmp;\n\n\tregmap_read(priv->regmap, STM32_LPTIM_CR, &val);\n\tstate->enabled = !!FIELD_GET(STM32_LPTIM_ENABLE, val);\n\t \n\tif (state->enabled)\n\t\tclk_enable(priv->clk);\n\n\tregmap_read(priv->regmap, STM32_LPTIM_CFGR, &val);\n\tpresc = FIELD_GET(STM32_LPTIM_PRESC, val);\n\tstate->polarity = FIELD_GET(STM32_LPTIM_WAVPOL, val);\n\n\tregmap_read(priv->regmap, STM32_LPTIM_ARR, &prd);\n\ttmp = prd + 1;\n\ttmp = (tmp << presc) * NSEC_PER_SEC;\n\tstate->period = DIV_ROUND_CLOSEST_ULL(tmp, rate);\n\n\tregmap_read(priv->regmap, STM32_LPTIM_CMP, &val);\n\ttmp = prd - val;\n\ttmp = (tmp << presc) * NSEC_PER_SEC;\n\tstate->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, rate);\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops stm32_pwm_lp_ops = {\n\t.owner = THIS_MODULE,\n\t.apply = stm32_pwm_lp_apply,\n\t.get_state = stm32_pwm_lp_get_state,\n};\n\nstatic int stm32_pwm_lp_probe(struct platform_device *pdev)\n{\n\tstruct stm32_lptimer *ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct stm32_pwm_lp *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = ddata->regmap;\n\tpriv->clk = ddata->clk;\n\tpriv->chip.dev = &pdev->dev;\n\tpriv->chip.ops = &stm32_pwm_lp_ops;\n\tpriv->chip.npwm = 1;\n\n\tret = devm_pwmchip_add(&pdev->dev, &priv->chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_pwm_lp_suspend(struct device *dev)\n{\n\tstruct stm32_pwm_lp *priv = dev_get_drvdata(dev);\n\tstruct pwm_state state;\n\n\tpwm_get_state(&priv->chip.pwms[0], &state);\n\tif (state.enabled) {\n\t\tdev_err(dev, \"The consumer didn't stop us (%s)\\n\",\n\t\t\tpriv->chip.pwms[0].label);\n\t\treturn -EBUSY;\n\t}\n\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int __maybe_unused stm32_pwm_lp_resume(struct device *dev)\n{\n\treturn pinctrl_pm_select_default_state(dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(stm32_pwm_lp_pm_ops, stm32_pwm_lp_suspend,\n\t\t\t stm32_pwm_lp_resume);\n\nstatic const struct of_device_id stm32_pwm_lp_of_match[] = {\n\t{ .compatible = \"st,stm32-pwm-lp\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_pwm_lp_of_match);\n\nstatic struct platform_driver stm32_pwm_lp_driver = {\n\t.probe\t= stm32_pwm_lp_probe,\n\t.driver\t= {\n\t\t.name = \"stm32-pwm-lp\",\n\t\t.of_match_table = stm32_pwm_lp_of_match,\n\t\t.pm = &stm32_pwm_lp_pm_ops,\n\t},\n};\nmodule_platform_driver(stm32_pwm_lp_driver);\n\nMODULE_ALIAS(\"platform:stm32-pwm-lp\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 PWM LP driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}