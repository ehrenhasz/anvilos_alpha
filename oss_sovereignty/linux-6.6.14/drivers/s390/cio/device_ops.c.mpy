{
  "module_name": "device_ops.c",
  "hash_id": "c43485f87c6f961f1fdcb87de6dc55387a7887d9169913024c06ed2fb637c745",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/device_ops.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n\n#include <asm/ccwdev.h>\n#include <asm/idals.h>\n#include <asm/chpid.h>\n#include <asm/fcx.h>\n\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"css.h\"\n#include \"chsc.h\"\n#include \"device.h\"\n#include \"chp.h\"\n\n \nint ccw_device_set_options_mask(struct ccw_device *cdev, unsigned long flags)\n{\n        \n\tif ((flags & CCWDEV_EARLY_NOTIFICATION) &&\n\t    (flags & CCWDEV_REPORT_ALL))\n\t\treturn -EINVAL;\n\tcdev->private->options.fast = (flags & CCWDEV_EARLY_NOTIFICATION) != 0;\n\tcdev->private->options.repall = (flags & CCWDEV_REPORT_ALL) != 0;\n\tcdev->private->options.pgroup = (flags & CCWDEV_DO_PATHGROUP) != 0;\n\tcdev->private->options.force = (flags & CCWDEV_ALLOW_FORCE) != 0;\n\tcdev->private->options.mpath = (flags & CCWDEV_DO_MULTIPATH) != 0;\n\treturn 0;\n}\n\n \nint ccw_device_set_options(struct ccw_device *cdev, unsigned long flags)\n{\n        \n\tif (((flags & CCWDEV_EARLY_NOTIFICATION) &&\n\t    (flags & CCWDEV_REPORT_ALL)) ||\n\t    ((flags & CCWDEV_EARLY_NOTIFICATION) &&\n\t     cdev->private->options.repall) ||\n\t    ((flags & CCWDEV_REPORT_ALL) &&\n\t     cdev->private->options.fast))\n\t\treturn -EINVAL;\n\tcdev->private->options.fast |= (flags & CCWDEV_EARLY_NOTIFICATION) != 0;\n\tcdev->private->options.repall |= (flags & CCWDEV_REPORT_ALL) != 0;\n\tcdev->private->options.pgroup |= (flags & CCWDEV_DO_PATHGROUP) != 0;\n\tcdev->private->options.force |= (flags & CCWDEV_ALLOW_FORCE) != 0;\n\tcdev->private->options.mpath |= (flags & CCWDEV_DO_MULTIPATH) != 0;\n\treturn 0;\n}\n\n \nvoid ccw_device_clear_options(struct ccw_device *cdev, unsigned long flags)\n{\n\tcdev->private->options.fast &= (flags & CCWDEV_EARLY_NOTIFICATION) == 0;\n\tcdev->private->options.repall &= (flags & CCWDEV_REPORT_ALL) == 0;\n\tcdev->private->options.pgroup &= (flags & CCWDEV_DO_PATHGROUP) == 0;\n\tcdev->private->options.force &= (flags & CCWDEV_ALLOW_FORCE) == 0;\n\tcdev->private->options.mpath &= (flags & CCWDEV_DO_MULTIPATH) == 0;\n}\n\n \nint ccw_device_is_pathgroup(struct ccw_device *cdev)\n{\n\treturn cdev->private->flags.pgroup;\n}\nEXPORT_SYMBOL(ccw_device_is_pathgroup);\n\n \nint ccw_device_is_multipath(struct ccw_device *cdev)\n{\n\treturn cdev->private->flags.mpath;\n}\nEXPORT_SYMBOL(ccw_device_is_multipath);\n\n \nint ccw_device_clear(struct ccw_device *cdev, unsigned long intparm)\n{\n\tstruct subchannel *sch;\n\tint ret;\n\n\tif (!cdev || !cdev->dev.parent)\n\t\treturn -ENODEV;\n\tsch = to_subchannel(cdev->dev.parent);\n\tif (!sch->schib.pmcw.ena)\n\t\treturn -EINVAL;\n\tif (cdev->private->state == DEV_STATE_NOT_OPER)\n\t\treturn -ENODEV;\n\tif (cdev->private->state != DEV_STATE_ONLINE &&\n\t    cdev->private->state != DEV_STATE_W4SENSE)\n\t\treturn -EINVAL;\n\n\tret = cio_clear(sch);\n\tif (ret == 0)\n\t\tcdev->private->intparm = intparm;\n\treturn ret;\n}\n\n \nint ccw_device_start_timeout_key(struct ccw_device *cdev, struct ccw1 *cpa,\n\t\t\t\t unsigned long intparm, __u8 lpm, __u8 key,\n\t\t\t\t unsigned long flags, int expires)\n{\n\tstruct subchannel *sch;\n\tint ret;\n\n\tif (!cdev || !cdev->dev.parent)\n\t\treturn -ENODEV;\n\tsch = to_subchannel(cdev->dev.parent);\n\tif (!sch->schib.pmcw.ena)\n\t\treturn -EINVAL;\n\tif (cdev->private->state == DEV_STATE_NOT_OPER)\n\t\treturn -ENODEV;\n\tif (cdev->private->state == DEV_STATE_VERIFY) {\n\t\t \n\t\tif (!cdev->private->flags.fake_irb) {\n\t\t\tcdev->private->flags.fake_irb = FAKE_CMD_IRB;\n\t\t\tcdev->private->intparm = intparm;\n\t\t\treturn 0;\n\t\t} else\n\t\t\t \n\t\t\treturn -EBUSY;\n\t}\n\tif (cdev->private->state != DEV_STATE_ONLINE ||\n\t    ((sch->schib.scsw.cmd.stctl & SCSW_STCTL_PRIM_STATUS) &&\n\t     !(sch->schib.scsw.cmd.stctl & SCSW_STCTL_SEC_STATUS)) ||\n\t    cdev->private->flags.doverify)\n\t\treturn -EBUSY;\n\tret = cio_set_options (sch, flags);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (lpm) {\n\t\tlpm &= sch->lpm;\n\t\tif (lpm == 0)\n\t\t\treturn -EACCES;\n\t}\n\tret = cio_start_key (sch, cpa, lpm, key);\n\tswitch (ret) {\n\tcase 0:\n\t\tcdev->private->intparm = intparm;\n\t\tif (expires)\n\t\t\tccw_device_set_timeout(cdev, expires);\n\t\tbreak;\n\tcase -EACCES:\n\tcase -ENODEV:\n\t\tdev_fsm_event(cdev, DEV_EVENT_VERIFY);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nint ccw_device_start_key(struct ccw_device *cdev, struct ccw1 *cpa,\n\t\t\t unsigned long intparm, __u8 lpm, __u8 key,\n\t\t\t unsigned long flags)\n{\n\treturn ccw_device_start_timeout_key(cdev, cpa, intparm, lpm, key,\n\t\t\t\t\t    flags, 0);\n}\n\n \nint ccw_device_start(struct ccw_device *cdev, struct ccw1 *cpa,\n\t\t     unsigned long intparm, __u8 lpm, unsigned long flags)\n{\n\treturn ccw_device_start_key(cdev, cpa, intparm, lpm,\n\t\t\t\t    PAGE_DEFAULT_KEY, flags);\n}\n\n \nint ccw_device_start_timeout(struct ccw_device *cdev, struct ccw1 *cpa,\n\t\t\t     unsigned long intparm, __u8 lpm,\n\t\t\t     unsigned long flags, int expires)\n{\n\treturn ccw_device_start_timeout_key(cdev, cpa, intparm, lpm,\n\t\t\t\t\t    PAGE_DEFAULT_KEY, flags,\n\t\t\t\t\t    expires);\n}\n\n\n \nint ccw_device_halt(struct ccw_device *cdev, unsigned long intparm)\n{\n\tstruct subchannel *sch;\n\tint ret;\n\n\tif (!cdev || !cdev->dev.parent)\n\t\treturn -ENODEV;\n\tsch = to_subchannel(cdev->dev.parent);\n\tif (!sch->schib.pmcw.ena)\n\t\treturn -EINVAL;\n\tif (cdev->private->state == DEV_STATE_NOT_OPER)\n\t\treturn -ENODEV;\n\tif (cdev->private->state != DEV_STATE_ONLINE &&\n\t    cdev->private->state != DEV_STATE_W4SENSE)\n\t\treturn -EINVAL;\n\n\tret = cio_halt(sch);\n\tif (ret == 0)\n\t\tcdev->private->intparm = intparm;\n\treturn ret;\n}\n\n \nint ccw_device_resume(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\n\tif (!cdev || !cdev->dev.parent)\n\t\treturn -ENODEV;\n\tsch = to_subchannel(cdev->dev.parent);\n\tif (!sch->schib.pmcw.ena)\n\t\treturn -EINVAL;\n\tif (cdev->private->state == DEV_STATE_NOT_OPER)\n\t\treturn -ENODEV;\n\tif (cdev->private->state != DEV_STATE_ONLINE ||\n\t    !(sch->schib.scsw.cmd.actl & SCSW_ACTL_SUSPENDED))\n\t\treturn -EINVAL;\n\treturn cio_resume(sch);\n}\n\n \nstruct ciw *ccw_device_get_ciw(struct ccw_device *cdev, __u32 ct)\n{\n\tint ciw_cnt;\n\n\tif (cdev->private->flags.esid == 0)\n\t\treturn NULL;\n\tfor (ciw_cnt = 0; ciw_cnt < MAX_CIWS; ciw_cnt++)\n\t\tif (cdev->private->dma_area->senseid.ciw[ciw_cnt].ct == ct)\n\t\t\treturn cdev->private->dma_area->senseid.ciw + ciw_cnt;\n\treturn NULL;\n}\n\n \n__u8 ccw_device_get_path_mask(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\n\tif (!cdev->dev.parent)\n\t\treturn 0;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\treturn sch->lpm;\n}\n\n \nstruct channel_path_desc_fmt0 *ccw_device_get_chp_desc(struct ccw_device *cdev,\n\t\t\t\t\t\t       int chp_idx)\n{\n\tstruct subchannel *sch;\n\tstruct chp_id chpid;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\tchp_id_init(&chpid);\n\tchpid.id = sch->schib.pmcw.chpid[chp_idx];\n\treturn chp_get_chp_desc(chpid);\n}\n\n \nu8 *ccw_device_get_util_str(struct ccw_device *cdev, int chp_idx)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct channel_path *chp;\n\tstruct chp_id chpid;\n\tu8 *util_str;\n\n\tchp_id_init(&chpid);\n\tchpid.id = sch->schib.pmcw.chpid[chp_idx];\n\tchp = chpid_to_chp(chpid);\n\n\tutil_str = kmalloc(sizeof(chp->desc_fmt3.util_str), GFP_KERNEL);\n\tif (!util_str)\n\t\treturn NULL;\n\n\tmutex_lock(&chp->lock);\n\tmemcpy(util_str, chp->desc_fmt3.util_str, sizeof(chp->desc_fmt3.util_str));\n\tmutex_unlock(&chp->lock);\n\n\treturn util_str;\n}\n\n \nvoid ccw_device_get_id(struct ccw_device *cdev, struct ccw_dev_id *dev_id)\n{\n\t*dev_id = cdev->private->dev_id;\n}\nEXPORT_SYMBOL(ccw_device_get_id);\n\n \nint ccw_device_tm_start_timeout_key(struct ccw_device *cdev, struct tcw *tcw,\n\t\t\t\t    unsigned long intparm, u8 lpm, u8 key,\n\t\t\t\t    int expires)\n{\n\tstruct subchannel *sch;\n\tint rc;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\tif (!sch->schib.pmcw.ena)\n\t\treturn -EINVAL;\n\tif (cdev->private->state == DEV_STATE_VERIFY) {\n\t\t \n\t\tif (!cdev->private->flags.fake_irb) {\n\t\t\tcdev->private->flags.fake_irb = FAKE_TM_IRB;\n\t\t\tcdev->private->intparm = intparm;\n\t\t\treturn 0;\n\t\t} else\n\t\t\t \n\t\t\treturn -EBUSY;\n\t}\n\tif (cdev->private->state != DEV_STATE_ONLINE)\n\t\treturn -EIO;\n\t \n\tif (lpm) {\n\t\tlpm &= sch->lpm;\n\t\tif (lpm == 0)\n\t\t\treturn -EACCES;\n\t}\n\trc = cio_tm_start_key(sch, tcw, lpm, key);\n\tif (rc == 0) {\n\t\tcdev->private->intparm = intparm;\n\t\tif (expires)\n\t\t\tccw_device_set_timeout(cdev, expires);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL(ccw_device_tm_start_timeout_key);\n\n \nint ccw_device_tm_start_key(struct ccw_device *cdev, struct tcw *tcw,\n\t\t\t    unsigned long intparm, u8 lpm, u8 key)\n{\n\treturn ccw_device_tm_start_timeout_key(cdev, tcw, intparm, lpm, key, 0);\n}\nEXPORT_SYMBOL(ccw_device_tm_start_key);\n\n \nint ccw_device_tm_start(struct ccw_device *cdev, struct tcw *tcw,\n\t\t\tunsigned long intparm, u8 lpm)\n{\n\treturn ccw_device_tm_start_key(cdev, tcw, intparm, lpm,\n\t\t\t\t       PAGE_DEFAULT_KEY);\n}\nEXPORT_SYMBOL(ccw_device_tm_start);\n\n \nint ccw_device_tm_start_timeout(struct ccw_device *cdev, struct tcw *tcw,\n\t\t\t       unsigned long intparm, u8 lpm, int expires)\n{\n\treturn ccw_device_tm_start_timeout_key(cdev, tcw, intparm, lpm,\n\t\t\t\t\t       PAGE_DEFAULT_KEY, expires);\n}\nEXPORT_SYMBOL(ccw_device_tm_start_timeout);\n\n \nint ccw_device_get_mdc(struct ccw_device *cdev, u8 mask)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct channel_path *chp;\n\tstruct chp_id chpid;\n\tint mdc = 0, i;\n\n\t \n\tif (mask)\n\t\tmask &= sch->lpm;\n\telse\n\t\tmask = sch->lpm;\n\n\tchp_id_init(&chpid);\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!(mask & (0x80 >> i)))\n\t\t\tcontinue;\n\t\tchpid.id = sch->schib.pmcw.chpid[i];\n\t\tchp = chpid_to_chp(chpid);\n\t\tif (!chp)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&chp->lock);\n\t\tif (!chp->desc_fmt1.f) {\n\t\t\tmutex_unlock(&chp->lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!chp->desc_fmt1.r)\n\t\t\tmdc = 1;\n\t\tmdc = mdc ? min_t(int, mdc, chp->desc_fmt1.mdc) :\n\t\t\t    chp->desc_fmt1.mdc;\n\t\tmutex_unlock(&chp->lock);\n\t}\n\n\treturn mdc;\n}\nEXPORT_SYMBOL(ccw_device_get_mdc);\n\n \nint ccw_device_tm_intrg(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\tif (!sch->schib.pmcw.ena)\n\t\treturn -EINVAL;\n\tif (cdev->private->state != DEV_STATE_ONLINE)\n\t\treturn -EIO;\n\tif (!scsw_is_tm(&sch->schib.scsw) ||\n\t    !(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_START_PEND))\n\t\treturn -EINVAL;\n\treturn cio_tm_intrg(sch);\n}\nEXPORT_SYMBOL(ccw_device_tm_intrg);\n\n \nvoid ccw_device_get_schid(struct ccw_device *cdev, struct subchannel_id *schid)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\t*schid = sch->schid;\n}\nEXPORT_SYMBOL_GPL(ccw_device_get_schid);\n\n \nint ccw_device_pnso(struct ccw_device *cdev,\n\t\t    struct chsc_pnso_area *pnso_area, u8 oc,\n\t\t    struct chsc_pnso_resume_token resume_token, int cnc)\n{\n\tstruct subchannel_id schid;\n\n\tccw_device_get_schid(cdev, &schid);\n\treturn chsc_pnso(schid, pnso_area, oc, resume_token, cnc);\n}\nEXPORT_SYMBOL_GPL(ccw_device_pnso);\n\n \nint ccw_device_get_cssid(struct ccw_device *cdev, u8 *cssid)\n{\n\tstruct device *sch_dev = cdev->dev.parent;\n\tstruct channel_subsystem *css = to_css(sch_dev->parent);\n\n\tif (css->id_valid)\n\t\t*cssid = css->cssid;\n\treturn css->id_valid ? 0 : -ENODEV;\n}\nEXPORT_SYMBOL_GPL(ccw_device_get_cssid);\n\n \nint ccw_device_get_iid(struct ccw_device *cdev, u8 *iid)\n{\n\tstruct device *sch_dev = cdev->dev.parent;\n\tstruct channel_subsystem *css = to_css(sch_dev->parent);\n\n\tif (css->id_valid)\n\t\t*iid = css->iid;\n\treturn css->id_valid ? 0 : -ENODEV;\n}\nEXPORT_SYMBOL_GPL(ccw_device_get_iid);\n\n \nint ccw_device_get_chpid(struct ccw_device *cdev, int chp_idx, u8 *chpid)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tint mask;\n\n\tif ((chp_idx < 0) || (chp_idx > 7))\n\t\treturn -EINVAL;\n\tmask = 0x80 >> chp_idx;\n\tif (!(sch->schib.pmcw.pim & mask))\n\t\treturn -ENODEV;\n\n\t*chpid = sch->schib.pmcw.chpid[chp_idx];\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ccw_device_get_chpid);\n\n \nint ccw_device_get_chid(struct ccw_device *cdev, int chp_idx, u16 *chid)\n{\n\tstruct chp_id cssid_chpid;\n\tstruct channel_path *chp;\n\tint rc;\n\n\tchp_id_init(&cssid_chpid);\n\trc = ccw_device_get_chpid(cdev, chp_idx, &cssid_chpid.id);\n\tif (rc)\n\t\treturn rc;\n\tchp = chpid_to_chp(cssid_chpid);\n\tif (!chp)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&chp->lock);\n\tif (chp->desc_fmt1.flags & 0x10)\n\t\t*chid = chp->desc_fmt1.chid;\n\telse\n\t\trc = -ENODEV;\n\tmutex_unlock(&chp->lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ccw_device_get_chid);\n\n \nvoid *ccw_device_dma_zalloc(struct ccw_device *cdev, size_t size)\n{\n\tvoid *addr;\n\n\tif (!get_device(&cdev->dev))\n\t\treturn NULL;\n\taddr = cio_gp_dma_zalloc(cdev->private->dma_pool, &cdev->dev, size);\n\tif (IS_ERR_OR_NULL(addr))\n\t\tput_device(&cdev->dev);\n\treturn addr;\n}\nEXPORT_SYMBOL(ccw_device_dma_zalloc);\n\nvoid ccw_device_dma_free(struct ccw_device *cdev, void *cpu_addr, size_t size)\n{\n\tif (!cpu_addr)\n\t\treturn;\n\tcio_gp_dma_free(cdev->private->dma_pool, cpu_addr, size);\n\tput_device(&cdev->dev);\n}\nEXPORT_SYMBOL(ccw_device_dma_free);\n\nEXPORT_SYMBOL(ccw_device_set_options_mask);\nEXPORT_SYMBOL(ccw_device_set_options);\nEXPORT_SYMBOL(ccw_device_clear_options);\nEXPORT_SYMBOL(ccw_device_clear);\nEXPORT_SYMBOL(ccw_device_halt);\nEXPORT_SYMBOL(ccw_device_resume);\nEXPORT_SYMBOL(ccw_device_start_timeout);\nEXPORT_SYMBOL(ccw_device_start);\nEXPORT_SYMBOL(ccw_device_start_timeout_key);\nEXPORT_SYMBOL(ccw_device_start_key);\nEXPORT_SYMBOL(ccw_device_get_ciw);\nEXPORT_SYMBOL(ccw_device_get_path_mask);\nEXPORT_SYMBOL_GPL(ccw_device_get_chp_desc);\nEXPORT_SYMBOL_GPL(ccw_device_get_util_str);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}