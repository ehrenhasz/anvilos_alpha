{
  "module_name": "device_status.c",
  "hash_id": "c84f02685f69eabb54c1b610b71046b2f65d16537895a0628c2ce8641cd4b206",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/device_status.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"css.h\"\n#include \"device.h\"\n#include \"ioasm.h\"\n#include \"io_sch.h\"\n\n \nstatic void\nccw_device_msg_control_check(struct ccw_device *cdev, struct irb *irb)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tchar dbf_text[15];\n\n\tif (!scsw_is_valid_cstat(&irb->scsw) ||\n\t    !(scsw_cstat(&irb->scsw) & (SCHN_STAT_CHN_DATA_CHK |\n\t      SCHN_STAT_CHN_CTRL_CHK | SCHN_STAT_INTF_CTRL_CHK)))\n\t\treturn;\n\tCIO_MSG_EVENT(0, \"Channel-Check or Interface-Control-Check \"\n\t\t      \"received\"\n\t\t      \" ... device %04x on subchannel 0.%x.%04x, dev_stat \"\n\t\t      \": %02X sch_stat : %02X\\n\",\n\t\t      cdev->private->dev_id.devno, sch->schid.ssid,\n\t\t      sch->schid.sch_no,\n\t\t      scsw_dstat(&irb->scsw), scsw_cstat(&irb->scsw));\n\tsprintf(dbf_text, \"chk%x\", sch->schid.sch_no);\n\tCIO_TRACE_EVENT(0, dbf_text);\n\tCIO_HEX_EVENT(0, irb, sizeof(struct irb));\n}\n\n \nstatic void\nccw_device_path_notoper(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\tif (cio_update_schib(sch))\n\t\tgoto doverify;\n\n\tCIO_MSG_EVENT(0, \"%s(0.%x.%04x) - path(s) %02x are \"\n\t\t      \"not operational \\n\", __func__,\n\t\t      sch->schid.ssid, sch->schid.sch_no,\n\t\t      sch->schib.pmcw.pnom);\n\n\tsch->lpm &= ~sch->schib.pmcw.pnom;\ndoverify:\n\tcdev->private->flags.doverify = 1;\n}\n\n \nstatic void\nccw_device_accumulate_ecw(struct ccw_device *cdev, struct irb *irb)\n{\n\t \n\tcdev->private->dma_area->irb.scsw.cmd.ectl = 0;\n\tif ((irb->scsw.cmd.stctl & SCSW_STCTL_ALERT_STATUS) &&\n\t    !(irb->scsw.cmd.stctl & SCSW_STCTL_INTER_STATUS))\n\t\tcdev->private->dma_area->irb.scsw.cmd.ectl = irb->scsw.cmd.ectl;\n\t \n\tif (!cdev->private->dma_area->irb.scsw.cmd.ectl)\n\t\treturn;\n\t \n\tmemcpy(&cdev->private->dma_area->irb.ecw, irb->ecw, sizeof(irb->ecw));\n}\n\n \nstatic int\nccw_device_accumulate_esw_valid(struct irb *irb)\n{\n\tif (!irb->scsw.cmd.eswf &&\n\t    (irb->scsw.cmd.stctl == SCSW_STCTL_STATUS_PEND))\n\t\treturn 0;\n\tif (irb->scsw.cmd.stctl ==\n\t\t\t(SCSW_STCTL_INTER_STATUS|SCSW_STCTL_STATUS_PEND) &&\n\t    !(irb->scsw.cmd.actl & SCSW_ACTL_SUSPENDED))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic void\nccw_device_accumulate_esw(struct ccw_device *cdev, struct irb *irb)\n{\n\tstruct irb *cdev_irb;\n\tstruct sublog *cdev_sublog, *sublog;\n\n\tif (!ccw_device_accumulate_esw_valid(irb))\n\t\treturn;\n\n\tcdev_irb = &cdev->private->dma_area->irb;\n\n\t \n\tcdev_irb->esw.esw1.lpum = irb->esw.esw1.lpum;\n\n\t \n\tif (irb->scsw.cmd.eswf) {\n\t\tcdev_sublog = &cdev_irb->esw.esw0.sublog;\n\t\tsublog = &irb->esw.esw0.sublog;\n\t\t \n\t\tcdev_sublog->esf = sublog->esf;\n\t\t \n\t\tif (irb->scsw.cmd.cstat & (SCHN_STAT_CHN_DATA_CHK |\n\t\t\t\t       SCHN_STAT_CHN_CTRL_CHK |\n\t\t\t\t       SCHN_STAT_INTF_CTRL_CHK)) {\n\t\t\t \n\t\t\tcdev_sublog->arep = sublog->arep;\n\t\t\t \n\t\t\tcdev_sublog->fvf = sublog->fvf;\n\t\t\t \n\t\t\tcdev_sublog->sacc = sublog->sacc;\n\t\t\t \n\t\t\tcdev_sublog->termc = sublog->termc;\n\t\t\t \n\t\t\tcdev_sublog->seqc = sublog->seqc;\n\t\t}\n\t\t \n\t\tcdev_sublog->devsc = sublog->devsc;\n\t\t \n\t\tcdev_sublog->serr = sublog->serr;\n\t\t \n\t\tcdev_sublog->ioerr = sublog->ioerr;\n\t\t \n\t\tif (irb->scsw.cmd.cstat & SCHN_STAT_INTF_CTRL_CHK)\n\t\t\tcdev_irb->esw.esw0.erw.cpt = irb->esw.esw0.erw.cpt;\n\t\t \n\t\tcdev_irb->esw.esw0.erw.fsavf = irb->esw.esw0.erw.fsavf;\n\t\tif (cdev_irb->esw.esw0.erw.fsavf) {\n\t\t\t \n\t\t\tmemcpy(cdev_irb->esw.esw0.faddr, irb->esw.esw0.faddr,\n\t\t\t       sizeof (irb->esw.esw0.faddr));\n\t\t\t \n\t\t\tcdev_irb->esw.esw0.erw.fsaf = irb->esw.esw0.erw.fsaf;\n\t\t}\n\t\t \n\t\tcdev_irb->esw.esw0.erw.scavf = irb->esw.esw0.erw.scavf;\n\t\tif (irb->esw.esw0.erw.scavf)\n\t\t\t \n\t\t\tcdev_irb->esw.esw0.saddr = irb->esw.esw0.saddr;\n\t\t\n\t}\n\t \n\n\t \n\tcdev_irb->esw.esw0.erw.auth = irb->esw.esw0.erw.auth;\n\t \n\tcdev_irb->esw.esw0.erw.pvrf = irb->esw.esw0.erw.pvrf;\n\tif (irb->esw.esw0.erw.pvrf)\n\t\tcdev->private->flags.doverify = 1;\n\t \n\tcdev_irb->esw.esw0.erw.cons = irb->esw.esw0.erw.cons;\n\tif (irb->esw.esw0.erw.cons)\n\t\tcdev_irb->esw.esw0.erw.scnt = irb->esw.esw0.erw.scnt;\n}\n\n \nvoid\nccw_device_accumulate_irb(struct ccw_device *cdev, struct irb *irb)\n{\n\tstruct irb *cdev_irb;\n\n\t \n\tif (!(scsw_stctl(&irb->scsw) & SCSW_STCTL_STATUS_PEND))\n\t\treturn;\n\n\t \n\tccw_device_msg_control_check(cdev, irb);\n\n\t \n\tif (scsw_is_valid_pno(&irb->scsw) && scsw_pno(&irb->scsw))\n\t\tccw_device_path_notoper(cdev);\n\t \n\tif (scsw_is_tm(&irb->scsw)) {\n\t\tmemcpy(&cdev->private->dma_area->irb, irb, sizeof(struct irb));\n\t\treturn;\n\t}\n\t \n\tif (!scsw_is_solicited(&irb->scsw))\n\t\treturn;\n\n\tcdev_irb = &cdev->private->dma_area->irb;\n\n\t \n\tif (irb->scsw.cmd.fctl & SCSW_FCTL_CLEAR_FUNC)\n\t\tmemset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));\n\n\t \n\tif (irb->scsw.cmd.fctl & SCSW_FCTL_START_FUNC) {\n\t\t \n\t\tcdev_irb->scsw.cmd.key = irb->scsw.cmd.key;\n\t\t \n\t\tcdev_irb->scsw.cmd.sctl = irb->scsw.cmd.sctl;\n\t\t \n\t\tcdev_irb->scsw.cmd.cc |= irb->scsw.cmd.cc;\n\t\t \n\t\tcdev_irb->scsw.cmd.fmt = irb->scsw.cmd.fmt;\n\t\t \n\t\tcdev_irb->scsw.cmd.pfch = irb->scsw.cmd.pfch;\n\t\t \n\t\tcdev_irb->scsw.cmd.isic = irb->scsw.cmd.isic;\n\t\t \n\t\tcdev_irb->scsw.cmd.alcc = irb->scsw.cmd.alcc;\n\t\t \n\t\tcdev_irb->scsw.cmd.ssi = irb->scsw.cmd.ssi;\n\t}\n\n\t \n\tccw_device_accumulate_ecw(cdev, irb);\n\t    \n\t \n\tcdev_irb->scsw.cmd.fctl |= irb->scsw.cmd.fctl;\n\t \n\tcdev_irb->scsw.cmd.actl = irb->scsw.cmd.actl;\n\t \n\tcdev_irb->scsw.cmd.stctl |= irb->scsw.cmd.stctl;\n\t \n\tif ((irb->scsw.cmd.stctl & SCSW_STCTL_PRIM_STATUS) ||\n\t    ((irb->scsw.cmd.stctl ==\n\t      (SCSW_STCTL_INTER_STATUS|SCSW_STCTL_STATUS_PEND)) &&\n\t     (irb->scsw.cmd.actl & SCSW_ACTL_DEVACT) &&\n\t     (irb->scsw.cmd.actl & SCSW_ACTL_SCHACT)) ||\n\t    (irb->scsw.cmd.actl & SCSW_ACTL_SUSPENDED))\n\t\tcdev_irb->scsw.cmd.cpa = irb->scsw.cmd.cpa;\n\t \n\tcdev_irb->scsw.cmd.dstat &= ~DEV_STAT_BUSY;\n\t \n\tif (irb->scsw.cmd.stctl &\n\t    (SCSW_STCTL_PRIM_STATUS | SCSW_STCTL_SEC_STATUS\n\t     | SCSW_STCTL_INTER_STATUS | SCSW_STCTL_ALERT_STATUS))\n\t\tcdev_irb->scsw.cmd.dstat |= irb->scsw.cmd.dstat;\n\t \n\tcdev_irb->scsw.cmd.cstat |= irb->scsw.cmd.cstat;\n\t \n\tif ((irb->scsw.cmd.stctl & SCSW_STCTL_PRIM_STATUS) &&\n\t    (irb->scsw.cmd.cstat & ~(SCHN_STAT_PCI | SCHN_STAT_INCORR_LEN))\n\t     == 0)\n\t\tcdev_irb->scsw.cmd.count = irb->scsw.cmd.count;\n\n\t \n\tccw_device_accumulate_esw(cdev, irb);\n\n\t \n\tif ((cdev_irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) &&\n\t    !(cdev_irb->esw.esw0.erw.cons))\n\t\tcdev->private->flags.dosense = 1;\n}\n\n \nint\nccw_device_do_sense(struct ccw_device *cdev, struct irb *irb)\n{\n\tstruct subchannel *sch;\n\tstruct ccw1 *sense_ccw;\n\tint rc;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\n\t \n\tif (scsw_actl(&irb->scsw) & (SCSW_ACTL_DEVACT | SCSW_ACTL_SCHACT))\n\t\t \n\t\treturn -EBUSY;\n\n\t \n\tsense_ccw = &to_io_private(sch)->dma_area->sense_ccw;\n\tsense_ccw->cmd_code = CCW_CMD_BASIC_SENSE;\n\tsense_ccw->cda = virt_to_phys(cdev->private->dma_area->irb.ecw);\n\tsense_ccw->count = SENSE_MAX_COUNT;\n\tsense_ccw->flags = CCW_FLAG_SLI;\n\n\trc = cio_start(sch, sense_ccw, 0xff);\n\tif (rc == -ENODEV || rc == -EACCES)\n\t\tdev_fsm_event(cdev, DEV_EVENT_VERIFY);\n\treturn rc;\n}\n\n \nvoid\nccw_device_accumulate_basic_sense(struct ccw_device *cdev, struct irb *irb)\n{\n\t \n\tif (!(scsw_stctl(&irb->scsw) & SCSW_STCTL_STATUS_PEND))\n\t\treturn;\n\n\t \n\tccw_device_msg_control_check(cdev, irb);\n\n\t \n\tif (scsw_is_valid_pno(&irb->scsw) && scsw_pno(&irb->scsw))\n\t\tccw_device_path_notoper(cdev);\n\n\tif (!(irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) &&\n\t    (irb->scsw.cmd.dstat & DEV_STAT_CHN_END)) {\n\t\tcdev->private->dma_area->irb.esw.esw0.erw.cons = 1;\n\t\tcdev->private->flags.dosense = 0;\n\t}\n\t \n\tif (ccw_device_accumulate_esw_valid(irb) &&\n\t    irb->esw.esw0.erw.pvrf)\n\t\tcdev->private->flags.doverify = 1;\n}\n\n \nint\nccw_device_accumulate_and_sense(struct ccw_device *cdev, struct irb *irb)\n{\n\tccw_device_accumulate_irb(cdev, irb);\n\tif ((irb->scsw.cmd.actl  & (SCSW_ACTL_DEVACT | SCSW_ACTL_SCHACT)) != 0)\n\t\treturn -EBUSY;\n\t \n\tif (cdev->private->flags.dosense &&\n\t    !(irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)) {\n\t\tcdev->private->dma_area->irb.esw.esw0.erw.cons = 1;\n\t\tcdev->private->flags.dosense = 0;\n\t\treturn 0;\n\t}\n\tif (cdev->private->flags.dosense) {\n\t\tccw_device_do_sense(cdev, irb);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}