{
  "module_name": "chsc_sch.c",
  "hash_id": "9536e594156bc6c16aed1ad03b32e24e21a394b679ad8c1a24a756c71060009f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/chsc_sch.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/miscdevice.h>\n#include <linux/kernel_stat.h>\n\n#include <asm/cio.h>\n#include <asm/chsc.h>\n#include <asm/isc.h>\n\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"css.h\"\n#include \"chsc_sch.h\"\n#include \"ioasm.h\"\n\nstatic debug_info_t *chsc_debug_msg_id;\nstatic debug_info_t *chsc_debug_log_id;\n\nstatic struct chsc_request *on_close_request;\nstatic struct chsc_async_area *on_close_chsc_area;\nstatic DEFINE_MUTEX(on_close_mutex);\n\n#define CHSC_MSG(imp, args...) do {\t\t\t\t\t\\\n\t\tdebug_sprintf_event(chsc_debug_msg_id, imp , ##args);\t\\\n\t} while (0)\n\n#define CHSC_LOG(imp, txt) do {\t\t\t\t\t\\\n\t\tdebug_text_event(chsc_debug_log_id, imp , txt);\t\\\n\t} while (0)\n\nstatic void CHSC_LOG_HEX(int level, void *data, int length)\n{\n\tdebug_event(chsc_debug_log_id, level, data, length);\n}\n\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"driver for s390 chsc subchannels\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void chsc_subchannel_irq(struct subchannel *sch)\n{\n\tstruct chsc_private *private = dev_get_drvdata(&sch->dev);\n\tstruct chsc_request *request = private->request;\n\tstruct irb *irb = this_cpu_ptr(&cio_irb);\n\n\tCHSC_LOG(4, \"irb\");\n\tCHSC_LOG_HEX(4, irb, sizeof(*irb));\n\tinc_irq_stat(IRQIO_CSC);\n\n\t \n\tif (!request) {\n\t\tCHSC_MSG(0, \"Interrupt on sch 0.%x.%04x with no request\\n\",\n\t\t\t sch->schid.ssid, sch->schid.sch_no);\n\t\treturn;\n\t}\n\tprivate->request = NULL;\n\tmemcpy(&request->irb, irb, sizeof(*irb));\n\tcio_update_schib(sch);\n\tcomplete(&request->completion);\n\tput_device(&sch->dev);\n}\n\nstatic int chsc_subchannel_probe(struct subchannel *sch)\n{\n\tstruct chsc_private *private;\n\tint ret;\n\n\tCHSC_MSG(6, \"Detected chsc subchannel 0.%x.%04x\\n\",\n\t\t sch->schid.ssid, sch->schid.sch_no);\n\tsch->isc = CHSC_SCH_ISC;\n\tprivate = kzalloc(sizeof(*private), GFP_KERNEL);\n\tif (!private)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(&sch->dev, private);\n\tret = cio_enable_subchannel(sch, (u32)virt_to_phys(sch));\n\tif (ret) {\n\t\tCHSC_MSG(0, \"Failed to enable 0.%x.%04x: %d\\n\",\n\t\t\t sch->schid.ssid, sch->schid.sch_no, ret);\n\t\tdev_set_drvdata(&sch->dev, NULL);\n\t\tkfree(private);\n\t}\n\treturn ret;\n}\n\nstatic void chsc_subchannel_remove(struct subchannel *sch)\n{\n\tstruct chsc_private *private;\n\n\tcio_disable_subchannel(sch);\n\tprivate = dev_get_drvdata(&sch->dev);\n\tdev_set_drvdata(&sch->dev, NULL);\n\tif (private->request) {\n\t\tcomplete(&private->request->completion);\n\t\tput_device(&sch->dev);\n\t}\n\tkfree(private);\n}\n\nstatic void chsc_subchannel_shutdown(struct subchannel *sch)\n{\n\tcio_disable_subchannel(sch);\n}\n\nstatic struct css_device_id chsc_subchannel_ids[] = {\n\t{ .match_flags = 0x1, .type =SUBCHANNEL_TYPE_CHSC, },\n\t{   },\n};\nMODULE_DEVICE_TABLE(css, chsc_subchannel_ids);\n\nstatic struct css_driver chsc_subchannel_driver = {\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"chsc_subchannel\",\n\t},\n\t.subchannel_type = chsc_subchannel_ids,\n\t.irq = chsc_subchannel_irq,\n\t.probe = chsc_subchannel_probe,\n\t.remove = chsc_subchannel_remove,\n\t.shutdown = chsc_subchannel_shutdown,\n};\n\nstatic int __init chsc_init_dbfs(void)\n{\n\tchsc_debug_msg_id = debug_register(\"chsc_msg\", 8, 1, 4 * sizeof(long));\n\tif (!chsc_debug_msg_id)\n\t\tgoto out;\n\tdebug_register_view(chsc_debug_msg_id, &debug_sprintf_view);\n\tdebug_set_level(chsc_debug_msg_id, 2);\n\tchsc_debug_log_id = debug_register(\"chsc_log\", 16, 1, 16);\n\tif (!chsc_debug_log_id)\n\t\tgoto out;\n\tdebug_register_view(chsc_debug_log_id, &debug_hex_ascii_view);\n\tdebug_set_level(chsc_debug_log_id, 2);\n\treturn 0;\nout:\n\tdebug_unregister(chsc_debug_msg_id);\n\treturn -ENOMEM;\n}\n\nstatic void chsc_remove_dbfs(void)\n{\n\tdebug_unregister(chsc_debug_log_id);\n\tdebug_unregister(chsc_debug_msg_id);\n}\n\nstatic int __init chsc_init_sch_driver(void)\n{\n\treturn css_driver_register(&chsc_subchannel_driver);\n}\n\nstatic void chsc_cleanup_sch_driver(void)\n{\n\tcss_driver_unregister(&chsc_subchannel_driver);\n}\n\nstatic DEFINE_SPINLOCK(chsc_lock);\n\nstatic int chsc_subchannel_match_next_free(struct device *dev, const void *data)\n{\n\tstruct subchannel *sch = to_subchannel(dev);\n\n\treturn sch->schib.pmcw.ena && !scsw_fctl(&sch->schib.scsw);\n}\n\nstatic struct subchannel *chsc_get_next_subchannel(struct subchannel *sch)\n{\n\tstruct device *dev;\n\n\tdev = driver_find_device(&chsc_subchannel_driver.drv,\n\t\t\t\t sch ? &sch->dev : NULL, NULL,\n\t\t\t\t chsc_subchannel_match_next_free);\n\treturn dev ? to_subchannel(dev) : NULL;\n}\n\n \nstatic int chsc_async(struct chsc_async_area *chsc_area,\n\t\t      struct chsc_request *request)\n{\n\tint cc;\n\tstruct chsc_private *private;\n\tstruct subchannel *sch = NULL;\n\tint ret = -ENODEV;\n\tchar dbf[10];\n\n\tchsc_area->header.key = PAGE_DEFAULT_KEY >> 4;\n\twhile ((sch = chsc_get_next_subchannel(sch))) {\n\t\tspin_lock(sch->lock);\n\t\tprivate = dev_get_drvdata(&sch->dev);\n\t\tif (private->request) {\n\t\t\tspin_unlock(sch->lock);\n\t\t\tret = -EBUSY;\n\t\t\tcontinue;\n\t\t}\n\t\tchsc_area->header.sid = sch->schid;\n\t\tCHSC_LOG(2, \"schid\");\n\t\tCHSC_LOG_HEX(2, &sch->schid, sizeof(sch->schid));\n\t\tcc = chsc(chsc_area);\n\t\tsnprintf(dbf, sizeof(dbf), \"cc:%d\", cc);\n\t\tCHSC_LOG(2, dbf);\n\t\tswitch (cc) {\n\t\tcase 0:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsch->schib.scsw.cmd.fctl |= SCSW_FCTL_START_FUNC;\n\t\t\tret = -EINPROGRESS;\n\t\t\tprivate->request = request;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENODEV;\n\t\t}\n\t\tspin_unlock(sch->lock);\n\t\tCHSC_MSG(2, \"chsc on 0.%x.%04x returned cc=%d\\n\",\n\t\t\t sch->schid.ssid, sch->schid.sch_no, cc);\n\t\tif (ret == -EINPROGRESS)\n\t\t\treturn -EINPROGRESS;\n\t\tput_device(&sch->dev);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\treturn ret;\n}\n\nstatic void chsc_log_command(void *chsc_area)\n{\n\tchar dbf[10];\n\n\tsnprintf(dbf, sizeof(dbf), \"CHSC:%x\", ((uint16_t *)chsc_area)[1]);\n\tCHSC_LOG(0, dbf);\n\tCHSC_LOG_HEX(0, chsc_area, 32);\n}\n\nstatic int chsc_examine_irb(struct chsc_request *request)\n{\n\tint backed_up;\n\n\tif (!(scsw_stctl(&request->irb.scsw) & SCSW_STCTL_STATUS_PEND))\n\t\treturn -EIO;\n\tbacked_up = scsw_cstat(&request->irb.scsw) & SCHN_STAT_CHAIN_CHECK;\n\trequest->irb.scsw.cmd.cstat &= ~SCHN_STAT_CHAIN_CHECK;\n\tif (scsw_cstat(&request->irb.scsw) == 0)\n\t\treturn 0;\n\tif (!backed_up)\n\t\treturn 0;\n\tif (scsw_cstat(&request->irb.scsw) & SCHN_STAT_PROG_CHECK)\n\t\treturn -EIO;\n\tif (scsw_cstat(&request->irb.scsw) & SCHN_STAT_PROT_CHECK)\n\t\treturn -EPERM;\n\tif (scsw_cstat(&request->irb.scsw) & SCHN_STAT_CHN_DATA_CHK)\n\t\treturn -EAGAIN;\n\tif (scsw_cstat(&request->irb.scsw) & SCHN_STAT_CHN_CTRL_CHK)\n\t\treturn -EAGAIN;\n\treturn -EIO;\n}\n\nstatic int chsc_ioctl_start(void __user *user_area)\n{\n\tstruct chsc_request *request;\n\tstruct chsc_async_area *chsc_area;\n\tint ret;\n\tchar dbf[10];\n\n\tif (!css_general_characteristics.dynio)\n\t\t \n\t\treturn -EOPNOTSUPP;\n\tchsc_area = (void *)get_zeroed_page(GFP_DMA | GFP_KERNEL);\n\tif (!chsc_area)\n\t\treturn -ENOMEM;\n\trequest = kzalloc(sizeof(*request), GFP_KERNEL);\n\tif (!request) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tinit_completion(&request->completion);\n\tif (copy_from_user(chsc_area, user_area, PAGE_SIZE)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tchsc_log_command(chsc_area);\n\tspin_lock_irq(&chsc_lock);\n\tret = chsc_async(chsc_area, request);\n\tspin_unlock_irq(&chsc_lock);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&request->completion);\n\t\tret = chsc_examine_irb(request);\n\t}\n\t \n\tif (!ret)\n\t\tif (copy_to_user(user_area, chsc_area, PAGE_SIZE))\n\t\t\tret = -EFAULT;\nout_free:\n\tsnprintf(dbf, sizeof(dbf), \"ret:%d\", ret);\n\tCHSC_LOG(0, dbf);\n\tkfree(request);\n\tfree_page((unsigned long)chsc_area);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_on_close_set(void __user *user_area)\n{\n\tchar dbf[13];\n\tint ret;\n\n\tmutex_lock(&on_close_mutex);\n\tif (on_close_chsc_area) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\ton_close_request = kzalloc(sizeof(*on_close_request), GFP_KERNEL);\n\tif (!on_close_request) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\ton_close_chsc_area = (void *)get_zeroed_page(GFP_DMA | GFP_KERNEL);\n\tif (!on_close_chsc_area) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_request;\n\t}\n\tif (copy_from_user(on_close_chsc_area, user_area, PAGE_SIZE)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free_chsc;\n\t}\n\tret = 0;\n\tgoto out_unlock;\n\nout_free_chsc:\n\tfree_page((unsigned long)on_close_chsc_area);\n\ton_close_chsc_area = NULL;\nout_free_request:\n\tkfree(on_close_request);\n\ton_close_request = NULL;\nout_unlock:\n\tmutex_unlock(&on_close_mutex);\n\tsnprintf(dbf, sizeof(dbf), \"ocsret:%d\", ret);\n\tCHSC_LOG(0, dbf);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_on_close_remove(void)\n{\n\tchar dbf[13];\n\tint ret;\n\n\tmutex_lock(&on_close_mutex);\n\tif (!on_close_chsc_area) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\tfree_page((unsigned long)on_close_chsc_area);\n\ton_close_chsc_area = NULL;\n\tkfree(on_close_request);\n\ton_close_request = NULL;\n\tret = 0;\nout_unlock:\n\tmutex_unlock(&on_close_mutex);\n\tsnprintf(dbf, sizeof(dbf), \"ocrret:%d\", ret);\n\tCHSC_LOG(0, dbf);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_start_sync(void __user *user_area)\n{\n\tstruct chsc_sync_area *chsc_area;\n\tint ret, ccode;\n\n\tchsc_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!chsc_area)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(chsc_area, user_area, PAGE_SIZE)) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (chsc_area->header.code & 0x4000) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tchsc_log_command(chsc_area);\n\tccode = chsc(chsc_area);\n\tif (ccode != 0) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tif (copy_to_user(user_area, chsc_area, PAGE_SIZE))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\nout_free:\n\tfree_page((unsigned long)chsc_area);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_info_channel_path(void __user *user_cd)\n{\n\tstruct chsc_chp_cd *cd;\n\tint ret, ccode;\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 : 2;\n\t\tu32 m : 1;\n\t\tu32 : 1;\n\t\tu32 fmt1 : 4;\n\t\tu32 cssid : 8;\n\t\tu32 : 8;\n\t\tu32 first_chpid : 8;\n\t\tu32 : 24;\n\t\tu32 last_chpid : 8;\n\t\tu32 : 32;\n\t\tstruct chsc_header response;\n\t\tu8 data[PAGE_SIZE - 20];\n\t} __attribute__ ((packed)) *scpcd_area;\n\n\tscpcd_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!scpcd_area)\n\t\treturn -ENOMEM;\n\tcd = kzalloc(sizeof(*cd), GFP_KERNEL);\n\tif (!cd) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tif (copy_from_user(cd, user_cd, sizeof(*cd))) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tscpcd_area->request.length = 0x0010;\n\tscpcd_area->request.code = 0x0028;\n\tscpcd_area->m = cd->m;\n\tscpcd_area->fmt1 = cd->fmt;\n\tscpcd_area->cssid = cd->chpid.cssid;\n\tscpcd_area->first_chpid = cd->chpid.id;\n\tscpcd_area->last_chpid = cd->chpid.id;\n\n\tccode = chsc(scpcd_area);\n\tif (ccode != 0) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tif (scpcd_area->response.code != 0x0001) {\n\t\tret = -EIO;\n\t\tCHSC_MSG(0, \"scpcd: response code=%x\\n\",\n\t\t\t scpcd_area->response.code);\n\t\tgoto out_free;\n\t}\n\tmemcpy(&cd->cpcb, &scpcd_area->response, scpcd_area->response.length);\n\tif (copy_to_user(user_cd, cd, sizeof(*cd)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\nout_free:\n\tkfree(cd);\n\tfree_page((unsigned long)scpcd_area);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_info_cu(void __user *user_cd)\n{\n\tstruct chsc_cu_cd *cd;\n\tint ret, ccode;\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 : 2;\n\t\tu32 m : 1;\n\t\tu32 : 1;\n\t\tu32 fmt1 : 4;\n\t\tu32 cssid : 8;\n\t\tu32 : 8;\n\t\tu32 first_cun : 8;\n\t\tu32 : 24;\n\t\tu32 last_cun : 8;\n\t\tu32 : 32;\n\t\tstruct chsc_header response;\n\t\tu8 data[PAGE_SIZE - 20];\n\t} __attribute__ ((packed)) *scucd_area;\n\n\tscucd_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!scucd_area)\n\t\treturn -ENOMEM;\n\tcd = kzalloc(sizeof(*cd), GFP_KERNEL);\n\tif (!cd) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tif (copy_from_user(cd, user_cd, sizeof(*cd))) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tscucd_area->request.length = 0x0010;\n\tscucd_area->request.code = 0x0026;\n\tscucd_area->m = cd->m;\n\tscucd_area->fmt1 = cd->fmt;\n\tscucd_area->cssid = cd->cssid;\n\tscucd_area->first_cun = cd->cun;\n\tscucd_area->last_cun = cd->cun;\n\n\tccode = chsc(scucd_area);\n\tif (ccode != 0) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tif (scucd_area->response.code != 0x0001) {\n\t\tret = -EIO;\n\t\tCHSC_MSG(0, \"scucd: response code=%x\\n\",\n\t\t\t scucd_area->response.code);\n\t\tgoto out_free;\n\t}\n\tmemcpy(&cd->cucb, &scucd_area->response, scucd_area->response.length);\n\tif (copy_to_user(user_cd, cd, sizeof(*cd)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\nout_free:\n\tkfree(cd);\n\tfree_page((unsigned long)scucd_area);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_info_sch_cu(void __user *user_cud)\n{\n\tstruct chsc_sch_cud *cud;\n\tint ret, ccode;\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 : 2;\n\t\tu32 m : 1;\n\t\tu32 : 5;\n\t\tu32 fmt1 : 4;\n\t\tu32 : 2;\n\t\tu32 ssid : 2;\n\t\tu32 first_sch : 16;\n\t\tu32 : 8;\n\t\tu32 cssid : 8;\n\t\tu32 last_sch : 16;\n\t\tu32 : 32;\n\t\tstruct chsc_header response;\n\t\tu8 data[PAGE_SIZE - 20];\n\t} __attribute__ ((packed)) *sscud_area;\n\n\tsscud_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sscud_area)\n\t\treturn -ENOMEM;\n\tcud = kzalloc(sizeof(*cud), GFP_KERNEL);\n\tif (!cud) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tif (copy_from_user(cud, user_cud, sizeof(*cud))) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tsscud_area->request.length = 0x0010;\n\tsscud_area->request.code = 0x0006;\n\tsscud_area->m = cud->schid.m;\n\tsscud_area->fmt1 = cud->fmt;\n\tsscud_area->ssid = cud->schid.ssid;\n\tsscud_area->first_sch = cud->schid.sch_no;\n\tsscud_area->cssid = cud->schid.cssid;\n\tsscud_area->last_sch = cud->schid.sch_no;\n\n\tccode = chsc(sscud_area);\n\tif (ccode != 0) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tif (sscud_area->response.code != 0x0001) {\n\t\tret = -EIO;\n\t\tCHSC_MSG(0, \"sscud: response code=%x\\n\",\n\t\t\t sscud_area->response.code);\n\t\tgoto out_free;\n\t}\n\tmemcpy(&cud->scub, &sscud_area->response, sscud_area->response.length);\n\tif (copy_to_user(user_cud, cud, sizeof(*cud)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\nout_free:\n\tkfree(cud);\n\tfree_page((unsigned long)sscud_area);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_conf_info(void __user *user_ci)\n{\n\tstruct chsc_conf_info *ci;\n\tint ret, ccode;\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 : 2;\n\t\tu32 m : 1;\n\t\tu32 : 1;\n\t\tu32 fmt1 : 4;\n\t\tu32 cssid : 8;\n\t\tu32 : 6;\n\t\tu32 ssid : 2;\n\t\tu32 : 8;\n\t\tu64 : 64;\n\t\tstruct chsc_header response;\n\t\tu8 data[PAGE_SIZE - 20];\n\t} __attribute__ ((packed)) *sci_area;\n\n\tsci_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sci_area)\n\t\treturn -ENOMEM;\n\tci = kzalloc(sizeof(*ci), GFP_KERNEL);\n\tif (!ci) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tif (copy_from_user(ci, user_ci, sizeof(*ci))) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tsci_area->request.length = 0x0010;\n\tsci_area->request.code = 0x0012;\n\tsci_area->m = ci->id.m;\n\tsci_area->fmt1 = ci->fmt;\n\tsci_area->cssid = ci->id.cssid;\n\tsci_area->ssid = ci->id.ssid;\n\n\tccode = chsc(sci_area);\n\tif (ccode != 0) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tif (sci_area->response.code != 0x0001) {\n\t\tret = -EIO;\n\t\tCHSC_MSG(0, \"sci: response code=%x\\n\",\n\t\t\t sci_area->response.code);\n\t\tgoto out_free;\n\t}\n\tmemcpy(&ci->scid, &sci_area->response, sci_area->response.length);\n\tif (copy_to_user(user_ci, ci, sizeof(*ci)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\nout_free:\n\tkfree(ci);\n\tfree_page((unsigned long)sci_area);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_conf_comp_list(void __user *user_ccl)\n{\n\tstruct chsc_comp_list *ccl;\n\tint ret, ccode;\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 ctype : 8;\n\t\tu32 : 4;\n\t\tu32 fmt : 4;\n\t\tu32 : 16;\n\t\tu64 : 64;\n\t\tu32 list_parm[2];\n\t\tu64 : 64;\n\t\tstruct chsc_header response;\n\t\tu8 data[PAGE_SIZE - 36];\n\t} __attribute__ ((packed)) *sccl_area;\n\tstruct {\n\t\tu32 m : 1;\n\t\tu32 : 31;\n\t\tu32 cssid : 8;\n\t\tu32 : 16;\n\t\tu32 chpid : 8;\n\t} __attribute__ ((packed)) *chpid_parm;\n\tstruct {\n\t\tu32 f_cssid : 8;\n\t\tu32 l_cssid : 8;\n\t\tu32 : 16;\n\t\tu32 res;\n\t} __attribute__ ((packed)) *cssids_parm;\n\n\tsccl_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccl_area)\n\t\treturn -ENOMEM;\n\tccl = kzalloc(sizeof(*ccl), GFP_KERNEL);\n\tif (!ccl) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tif (copy_from_user(ccl, user_ccl, sizeof(*ccl))) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tsccl_area->request.length = 0x0020;\n\tsccl_area->request.code = 0x0030;\n\tsccl_area->fmt = ccl->req.fmt;\n\tsccl_area->ctype = ccl->req.ctype;\n\tswitch (sccl_area->ctype) {\n\tcase CCL_CU_ON_CHP:\n\tcase CCL_IOP_CHP:\n\t\tchpid_parm = (void *)&sccl_area->list_parm;\n\t\tchpid_parm->m = ccl->req.chpid.m;\n\t\tchpid_parm->cssid = ccl->req.chpid.chp.cssid;\n\t\tchpid_parm->chpid = ccl->req.chpid.chp.id;\n\t\tbreak;\n\tcase CCL_CSS_IMG:\n\tcase CCL_CSS_IMG_CONF_CHAR:\n\t\tcssids_parm = (void *)&sccl_area->list_parm;\n\t\tcssids_parm->f_cssid = ccl->req.cssids.f_cssid;\n\t\tcssids_parm->l_cssid = ccl->req.cssids.l_cssid;\n\t\tbreak;\n\t}\n\tccode = chsc(sccl_area);\n\tif (ccode != 0) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tif (sccl_area->response.code != 0x0001) {\n\t\tret = -EIO;\n\t\tCHSC_MSG(0, \"sccl: response code=%x\\n\",\n\t\t\t sccl_area->response.code);\n\t\tgoto out_free;\n\t}\n\tmemcpy(&ccl->sccl, &sccl_area->response, sccl_area->response.length);\n\tif (copy_to_user(user_ccl, ccl, sizeof(*ccl)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\nout_free:\n\tkfree(ccl);\n\tfree_page((unsigned long)sccl_area);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_chpd(void __user *user_chpd)\n{\n\tstruct chsc_scpd *scpd_area;\n\tstruct chsc_cpd_info *chpd;\n\tint ret;\n\n\tchpd = kzalloc(sizeof(*chpd), GFP_KERNEL);\n\tscpd_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!scpd_area || !chpd) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tif (copy_from_user(chpd, user_chpd, sizeof(*chpd))) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tret = chsc_determine_channel_path_desc(chpd->chpid, chpd->fmt,\n\t\t\t\t\t       chpd->rfmt, chpd->c, chpd->m,\n\t\t\t\t\t       scpd_area);\n\tif (ret)\n\t\tgoto out_free;\n\tmemcpy(&chpd->chpdb, &scpd_area->response, scpd_area->response.length);\n\tif (copy_to_user(user_chpd, chpd, sizeof(*chpd)))\n\t\tret = -EFAULT;\nout_free:\n\tkfree(chpd);\n\tfree_page((unsigned long)scpd_area);\n\treturn ret;\n}\n\nstatic int chsc_ioctl_dcal(void __user *user_dcal)\n{\n\tstruct chsc_dcal *dcal;\n\tint ret, ccode;\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 atype : 8;\n\t\tu32 : 4;\n\t\tu32 fmt : 4;\n\t\tu32 : 16;\n\t\tu32 res0[2];\n\t\tu32 list_parm[2];\n\t\tu32 res1[2];\n\t\tstruct chsc_header response;\n\t\tu8 data[PAGE_SIZE - 36];\n\t} __attribute__ ((packed)) *sdcal_area;\n\n\tsdcal_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sdcal_area)\n\t\treturn -ENOMEM;\n\tdcal = kzalloc(sizeof(*dcal), GFP_KERNEL);\n\tif (!dcal) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tif (copy_from_user(dcal, user_dcal, sizeof(*dcal))) {\n\t\tret = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tsdcal_area->request.length = 0x0020;\n\tsdcal_area->request.code = 0x0034;\n\tsdcal_area->atype = dcal->req.atype;\n\tsdcal_area->fmt = dcal->req.fmt;\n\tmemcpy(&sdcal_area->list_parm, &dcal->req.list_parm,\n\t       sizeof(sdcal_area->list_parm));\n\n\tccode = chsc(sdcal_area);\n\tif (ccode != 0) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tif (sdcal_area->response.code != 0x0001) {\n\t\tret = -EIO;\n\t\tCHSC_MSG(0, \"sdcal: response code=%x\\n\",\n\t\t\t sdcal_area->response.code);\n\t\tgoto out_free;\n\t}\n\tmemcpy(&dcal->sdcal, &sdcal_area->response,\n\t       sdcal_area->response.length);\n\tif (copy_to_user(user_dcal, dcal, sizeof(*dcal)))\n\t\tret = -EFAULT;\n\telse\n\t\tret = 0;\nout_free:\n\tkfree(dcal);\n\tfree_page((unsigned long)sdcal_area);\n\treturn ret;\n}\n\nstatic long chsc_ioctl(struct file *filp, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tvoid __user *argp;\n\n\tCHSC_MSG(2, \"chsc_ioctl called, cmd=%x\\n\", cmd);\n\tif (is_compat_task())\n\t\targp = compat_ptr(arg);\n\telse\n\t\targp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase CHSC_START:\n\t\treturn chsc_ioctl_start(argp);\n\tcase CHSC_START_SYNC:\n\t\treturn chsc_ioctl_start_sync(argp);\n\tcase CHSC_INFO_CHANNEL_PATH:\n\t\treturn chsc_ioctl_info_channel_path(argp);\n\tcase CHSC_INFO_CU:\n\t\treturn chsc_ioctl_info_cu(argp);\n\tcase CHSC_INFO_SCH_CU:\n\t\treturn chsc_ioctl_info_sch_cu(argp);\n\tcase CHSC_INFO_CI:\n\t\treturn chsc_ioctl_conf_info(argp);\n\tcase CHSC_INFO_CCL:\n\t\treturn chsc_ioctl_conf_comp_list(argp);\n\tcase CHSC_INFO_CPD:\n\t\treturn chsc_ioctl_chpd(argp);\n\tcase CHSC_INFO_DCAL:\n\t\treturn chsc_ioctl_dcal(argp);\n\tcase CHSC_ON_CLOSE_SET:\n\t\treturn chsc_ioctl_on_close_set(argp);\n\tcase CHSC_ON_CLOSE_REMOVE:\n\t\treturn chsc_ioctl_on_close_remove();\n\tdefault:  \n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic atomic_t chsc_ready_for_use = ATOMIC_INIT(1);\n\nstatic int chsc_open(struct inode *inode, struct file *file)\n{\n\tif (!atomic_dec_and_test(&chsc_ready_for_use)) {\n\t\tatomic_inc(&chsc_ready_for_use);\n\t\treturn -EBUSY;\n\t}\n\treturn nonseekable_open(inode, file);\n}\n\nstatic int chsc_release(struct inode *inode, struct file *filp)\n{\n\tchar dbf[13];\n\tint ret;\n\n\tmutex_lock(&on_close_mutex);\n\tif (!on_close_chsc_area)\n\t\tgoto out_unlock;\n\tinit_completion(&on_close_request->completion);\n\tCHSC_LOG(0, \"on_close\");\n\tchsc_log_command(on_close_chsc_area);\n\tspin_lock_irq(&chsc_lock);\n\tret = chsc_async(on_close_chsc_area, on_close_request);\n\tspin_unlock_irq(&chsc_lock);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&on_close_request->completion);\n\t\tret = chsc_examine_irb(on_close_request);\n\t}\n\tsnprintf(dbf, sizeof(dbf), \"relret:%d\", ret);\n\tCHSC_LOG(0, dbf);\n\tfree_page((unsigned long)on_close_chsc_area);\n\ton_close_chsc_area = NULL;\n\tkfree(on_close_request);\n\ton_close_request = NULL;\nout_unlock:\n\tmutex_unlock(&on_close_mutex);\n\tatomic_inc(&chsc_ready_for_use);\n\treturn 0;\n}\n\nstatic const struct file_operations chsc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = chsc_open,\n\t.release = chsc_release,\n\t.unlocked_ioctl = chsc_ioctl,\n\t.compat_ioctl = chsc_ioctl,\n\t.llseek = no_llseek,\n};\n\nstatic struct miscdevice chsc_misc_device = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"chsc\",\n\t.fops = &chsc_fops,\n};\n\nstatic int __init chsc_misc_init(void)\n{\n\treturn misc_register(&chsc_misc_device);\n}\n\nstatic void chsc_misc_cleanup(void)\n{\n\tmisc_deregister(&chsc_misc_device);\n}\n\nstatic int __init chsc_sch_init(void)\n{\n\tint ret;\n\n\tret = chsc_init_dbfs();\n\tif (ret)\n\t\treturn ret;\n\tisc_register(CHSC_SCH_ISC);\n\tret = chsc_init_sch_driver();\n\tif (ret)\n\t\tgoto out_dbf;\n\tret = chsc_misc_init();\n\tif (ret)\n\t\tgoto out_driver;\n\treturn ret;\nout_driver:\n\tchsc_cleanup_sch_driver();\nout_dbf:\n\tisc_unregister(CHSC_SCH_ISC);\n\tchsc_remove_dbfs();\n\treturn ret;\n}\n\nstatic void __exit chsc_sch_exit(void)\n{\n\tchsc_misc_cleanup();\n\tchsc_cleanup_sch_driver();\n\tisc_unregister(CHSC_SCH_ISC);\n\tchsc_remove_dbfs();\n}\n\nmodule_init(chsc_sch_init);\nmodule_exit(chsc_sch_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}