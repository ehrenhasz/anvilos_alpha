{
  "module_name": "itcw.c",
  "hash_id": "4ca40c449a51f8f531160e3a46e32ea3a500af23982da80173092a8b543d35b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/itcw.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <asm/fcx.h>\n#include <asm/itcw.h>\n\n \nstruct itcw {\n\tstruct tcw *tcw;\n\tstruct tcw *intrg_tcw;\n\tint num_tidaws;\n\tint max_tidaws;\n\tint intrg_num_tidaws;\n\tint intrg_max_tidaws;\n};\n\n \nstruct tcw *itcw_get_tcw(struct itcw *itcw)\n{\n\treturn itcw->tcw;\n}\nEXPORT_SYMBOL(itcw_get_tcw);\n\n \nsize_t itcw_calc_size(int intrg, int max_tidaws, int intrg_max_tidaws)\n{\n\tsize_t len;\n\tint cross_count;\n\n\t \n\tlen = sizeof(struct itcw);\n\tlen +=   sizeof(struct tcw) +   TCCB_MAX_SIZE +\n\t         sizeof(struct tsb) +\n\t         max_tidaws * sizeof(struct tidaw);\n\t \n\tif (intrg) {\n\t\tlen +=   sizeof(struct tcw) +   TCCB_MAX_SIZE +\n\t\t         sizeof(struct tsb) +\n\t\t         intrg_max_tidaws * sizeof(struct tidaw);\n\t}\n\n\t \n\tlen +=   63 +   7;\n\n\t \n\tif (max_tidaws) {\n\t\tcross_count = 1 + ((max_tidaws * sizeof(struct tidaw) - 1)\n\t\t\t\t   >> PAGE_SHIFT);\n\t\tlen += cross_count * sizeof(struct tidaw);\n\t}\n\tif (intrg_max_tidaws) {\n\t\tcross_count = 1 + ((intrg_max_tidaws * sizeof(struct tidaw) - 1)\n\t\t\t\t   >> PAGE_SHIFT);\n\t\tlen += cross_count * sizeof(struct tidaw);\n\t}\n\treturn len;\n}\nEXPORT_SYMBOL(itcw_calc_size);\n\n#define CROSS4K(x, l)\t(((x) & ~4095) != ((x + l) & ~4095))\n\nstatic inline void *fit_chunk(addr_t *start, addr_t end, size_t len,\n\t\t\t      int align, int check_4k)\n{\n\taddr_t addr;\n\n\taddr = ALIGN(*start, align);\n\tif (check_4k && CROSS4K(addr, len)) {\n\t\taddr = ALIGN(addr, 4096);\n\t\taddr = ALIGN(addr, align);\n\t}\n\tif (addr + len > end)\n\t\treturn ERR_PTR(-ENOSPC);\n\t*start = addr + len;\n\treturn (void *) addr;\n}\n\n \nstruct itcw *itcw_init(void *buffer, size_t size, int op, int intrg,\n\t\t       int max_tidaws, int intrg_max_tidaws)\n{\n\tstruct itcw *itcw;\n\tvoid *chunk;\n\taddr_t start;\n\taddr_t end;\n\tint cross_count;\n\n\t \n\tstart = (addr_t) buffer;\n\tend = start + size;\n\tif ((virt_to_phys(buffer) + size) > (1 << 31))\n\t\treturn ERR_PTR(-EINVAL);\n\tmemset(buffer, 0, size);\n\t \n\tchunk = fit_chunk(&start, end, sizeof(struct itcw), 1, 0);\n\tif (IS_ERR(chunk))\n\t\treturn chunk;\n\titcw = chunk;\n\t \n\tcross_count = 0;\n\tif (max_tidaws)\n\t\tcross_count = 1 + ((max_tidaws * sizeof(struct tidaw) - 1)\n\t\t\t\t   >> PAGE_SHIFT);\n\titcw->max_tidaws = max_tidaws + cross_count;\n\tcross_count = 0;\n\tif (intrg_max_tidaws)\n\t\tcross_count = 1 + ((intrg_max_tidaws * sizeof(struct tidaw) - 1)\n\t\t\t\t   >> PAGE_SHIFT);\n\titcw->intrg_max_tidaws = intrg_max_tidaws + cross_count;\n\t \n\tchunk = fit_chunk(&start, end, sizeof(struct tcw), 64, 0);\n\tif (IS_ERR(chunk))\n\t\treturn chunk;\n\titcw->tcw = chunk;\n\ttcw_init(itcw->tcw, (op == ITCW_OP_READ) ? 1 : 0,\n\t\t (op == ITCW_OP_WRITE) ? 1 : 0);\n\t \n\tif (intrg) {\n\t\tchunk = fit_chunk(&start, end, sizeof(struct tcw), 64, 0);\n\t\tif (IS_ERR(chunk))\n\t\t\treturn chunk;\n\t\titcw->intrg_tcw = chunk;\n\t\ttcw_init(itcw->intrg_tcw, 1, 0);\n\t\ttcw_set_intrg(itcw->tcw, itcw->intrg_tcw);\n\t}\n\t \n\tif (max_tidaws > 0) {\n\t\tchunk = fit_chunk(&start, end, sizeof(struct tidaw) *\n\t\t\t\t  itcw->max_tidaws, 16, 0);\n\t\tif (IS_ERR(chunk))\n\t\t\treturn chunk;\n\t\ttcw_set_data(itcw->tcw, chunk, 1);\n\t}\n\t \n\tif (intrg && (intrg_max_tidaws > 0)) {\n\t\tchunk = fit_chunk(&start, end, sizeof(struct tidaw) *\n\t\t\t\t  itcw->intrg_max_tidaws, 16, 0);\n\t\tif (IS_ERR(chunk))\n\t\t\treturn chunk;\n\t\ttcw_set_data(itcw->intrg_tcw, chunk, 1);\n\t}\n\t \n\tchunk = fit_chunk(&start, end, sizeof(struct tsb), 8, 0);\n\tif (IS_ERR(chunk))\n\t\treturn chunk;\n\ttsb_init(chunk);\n\ttcw_set_tsb(itcw->tcw, chunk);\n\t \n\tif (intrg) {\n\t\tchunk = fit_chunk(&start, end, sizeof(struct tsb), 8, 0);\n\t\tif (IS_ERR(chunk))\n\t\t\treturn chunk;\n\t\ttsb_init(chunk);\n\t\ttcw_set_tsb(itcw->intrg_tcw, chunk);\n\t}\n\t \n\tchunk = fit_chunk(&start, end, TCCB_MAX_SIZE, 8, 0);\n\tif (IS_ERR(chunk))\n\t\treturn chunk;\n\ttccb_init(chunk, TCCB_MAX_SIZE, TCCB_SAC_DEFAULT);\n\ttcw_set_tccb(itcw->tcw, chunk);\n\t \n\tif (intrg) {\n\t\tchunk = fit_chunk(&start, end, TCCB_MAX_SIZE, 8, 0);\n\t\tif (IS_ERR(chunk))\n\t\t\treturn chunk;\n\t\ttccb_init(chunk, TCCB_MAX_SIZE, TCCB_SAC_INTRG);\n\t\ttcw_set_tccb(itcw->intrg_tcw, chunk);\n\t\ttccb_add_dcw(chunk, TCCB_MAX_SIZE, DCW_CMD_INTRG, 0, NULL,\n\t\t\t     sizeof(struct dcw_intrg_data), 0);\n\t\ttcw_finalize(itcw->intrg_tcw, 0);\n\t}\n\treturn itcw;\n}\nEXPORT_SYMBOL(itcw_init);\n\n \nstruct dcw *itcw_add_dcw(struct itcw *itcw, u8 cmd, u8 flags, void *cd,\n\t\t\t u8 cd_count, u32 count)\n{\n\treturn tccb_add_dcw(tcw_get_tccb(itcw->tcw), TCCB_MAX_SIZE, cmd,\n\t\t\t    flags, cd, cd_count, count);\n}\nEXPORT_SYMBOL(itcw_add_dcw);\n\n \nstruct tidaw *itcw_add_tidaw(struct itcw *itcw, u8 flags, void *addr, u32 count)\n{\n\tstruct tidaw *following;\n\n\tif (itcw->num_tidaws >= itcw->max_tidaws)\n\t\treturn ERR_PTR(-ENOSPC);\n\t \n\tfollowing = ((struct tidaw *) tcw_get_data(itcw->tcw))\n\t\t+ itcw->num_tidaws + 1;\n\tif (itcw->num_tidaws && !((unsigned long) following & ~PAGE_MASK)) {\n\t\ttcw_add_tidaw(itcw->tcw, itcw->num_tidaws++,\n\t\t\t      TIDAW_FLAGS_TTIC, following, 0);\n\t\tif (itcw->num_tidaws >= itcw->max_tidaws)\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\treturn tcw_add_tidaw(itcw->tcw, itcw->num_tidaws++, flags, addr, count);\n}\nEXPORT_SYMBOL(itcw_add_tidaw);\n\n \nvoid itcw_set_data(struct itcw *itcw, void *addr, int use_tidal)\n{\n\ttcw_set_data(itcw->tcw, addr, use_tidal);\n}\nEXPORT_SYMBOL(itcw_set_data);\n\n \nvoid itcw_finalize(struct itcw *itcw)\n{\n\ttcw_finalize(itcw->tcw, itcw->num_tidaws);\n}\nEXPORT_SYMBOL(itcw_finalize);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}