{
  "module_name": "cmf.c",
  "hash_id": "ac028cb9213a51e2594db56fa865f3b1f3c5e20632fd1c30c69e5fcefc2259b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/cmf.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"cio\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/memblock.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/timex.h>\t \n\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n#include <asm/cmb.h>\n#include <asm/div64.h>\n\n#include \"cio.h\"\n#include \"css.h\"\n#include \"device.h\"\n#include \"ioasm.h\"\n#include \"chsc.h\"\n\n \n#define ARGSTRING \"s390cmf\"\n\n \nenum cmb_index {\n\tavg_utilization = -1,\n  \n\tcmb_ssch_rsch_count = 0,\n\tcmb_sample_count,\n\tcmb_device_connect_time,\n\tcmb_function_pending_time,\n\tcmb_device_disconnect_time,\n\tcmb_control_unit_queuing_time,\n\tcmb_device_active_only_time,\n  \n\tcmb_device_busy_time,\n\tcmb_initial_command_response_time,\n};\n\n \nenum cmb_format {\n\tCMF_BASIC,\n\tCMF_EXTENDED,\n\tCMF_AUTODETECT = -1,\n};\n\n \nstatic int format = CMF_AUTODETECT;\nmodule_param(format, bint, 0444);\n\n \nstruct cmb_operations {\n\tint  (*alloc)  (struct ccw_device *);\n\tvoid (*free)   (struct ccw_device *);\n\tint  (*set)    (struct ccw_device *, u32);\n\tu64  (*read)   (struct ccw_device *, int);\n\tint  (*readall)(struct ccw_device *, struct cmbdata *);\n\tvoid (*reset)  (struct ccw_device *);\n \n\tstruct attribute_group *attr_group;\n};\nstatic struct cmb_operations *cmbops;\n\nstruct cmb_data {\n\tvoid *hw_block;    \n\tvoid *last_block;  \n\tint size;\t   \n\tunsigned long long last_update;   \n};\n\n \nstatic inline u64 time_to_nsec(u32 value)\n{\n\treturn ((u64)value) * 128000ull;\n}\n\n \nstatic inline u64 time_to_avg_nsec(u32 value, u32 count)\n{\n\tu64 ret;\n\n\t \n\tif (count == 0)\n\t\treturn 0;\n\n\t \n\tret = time_to_nsec(value);\n\tdo_div(ret, count);\n\n\treturn ret;\n}\n\n#define CMF_OFF 0\n#define CMF_ON\t2\n\n \nstatic inline void cmf_activate(void *area, unsigned int onoff)\n{\n\t \n\tasm volatile(\n\t\t\"\tlgr\t1,%[r1]\\n\"\n\t\t\"\tlgr\t2,%[mbo]\\n\"\n\t\t\"\tschm\\n\"\n\t\t:\n\t\t: [r1] \"d\" ((unsigned long)onoff), [mbo] \"d\" (area)\n\t\t: \"1\", \"2\");\n}\n\nstatic int set_schib(struct ccw_device *cdev, u32 mme, int mbfc,\n\t\t     unsigned long address)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tint ret;\n\n\tsch->config.mme = mme;\n\tsch->config.mbfc = mbfc;\n\t \n\tif (mbfc)\n\t\tsch->config.mba = address;\n\telse\n\t\tsch->config.mbi = address;\n\n\tret = cio_commit_config(sch);\n\tif (!mme && ret == -ENODEV) {\n\t\t \n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstruct set_schib_struct {\n\tu32 mme;\n\tint mbfc;\n\tunsigned long address;\n\twait_queue_head_t wait;\n\tint ret;\n};\n\n#define CMF_PENDING 1\n#define SET_SCHIB_TIMEOUT (10 * HZ)\n\nstatic int set_schib_wait(struct ccw_device *cdev, u32 mme,\n\t\t\t  int mbfc, unsigned long address)\n{\n\tstruct set_schib_struct set_data;\n\tint ret = -ENODEV;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tif (!cdev->private->cmb)\n\t\tgoto out;\n\n\tret = set_schib(cdev, mme, mbfc, address);\n\tif (ret != -EBUSY)\n\t\tgoto out;\n\n\t \n\tif (cdev->private->state != DEV_STATE_ONLINE)\n\t\tgoto out;\n\n\tinit_waitqueue_head(&set_data.wait);\n\tset_data.mme = mme;\n\tset_data.mbfc = mbfc;\n\tset_data.address = address;\n\tset_data.ret = CMF_PENDING;\n\n\tcdev->private->state = DEV_STATE_CMFCHANGE;\n\tcdev->private->cmb_wait = &set_data;\n\tspin_unlock_irq(cdev->ccwlock);\n\n\tret = wait_event_interruptible_timeout(set_data.wait,\n\t\t\t\t\t       set_data.ret != CMF_PENDING,\n\t\t\t\t\t       SET_SCHIB_TIMEOUT);\n\tspin_lock_irq(cdev->ccwlock);\n\tif (ret <= 0) {\n\t\tif (set_data.ret == CMF_PENDING) {\n\t\t\tset_data.ret = (ret == 0) ? -ETIME : ret;\n\t\t\tif (cdev->private->state == DEV_STATE_CMFCHANGE)\n\t\t\t\tcdev->private->state = DEV_STATE_ONLINE;\n\t\t}\n\t}\n\tcdev->private->cmb_wait = NULL;\n\tret = set_data.ret;\nout:\n\tspin_unlock_irq(cdev->ccwlock);\n\treturn ret;\n}\n\nvoid retry_set_schib(struct ccw_device *cdev)\n{\n\tstruct set_schib_struct *set_data = cdev->private->cmb_wait;\n\n\tif (!set_data)\n\t\treturn;\n\n\tset_data->ret = set_schib(cdev, set_data->mme, set_data->mbfc,\n\t\t\t\t  set_data->address);\n\twake_up(&set_data->wait);\n}\n\nstatic int cmf_copy_block(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct cmb_data *cmb_data;\n\tvoid *hw_block;\n\n\tif (cio_update_schib(sch))\n\t\treturn -ENODEV;\n\n\tif (scsw_fctl(&sch->schib.scsw) & SCSW_FCTL_START_FUNC) {\n\t\t \n\t\tif ((!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_SUSPENDED)) &&\n\t\t    (scsw_actl(&sch->schib.scsw) &\n\t\t     (SCSW_ACTL_DEVACT | SCSW_ACTL_SCHACT)) &&\n\t\t    (!(scsw_stctl(&sch->schib.scsw) & SCSW_STCTL_SEC_STATUS)))\n\t\t\treturn -EBUSY;\n\t}\n\tcmb_data = cdev->private->cmb;\n\thw_block = cmb_data->hw_block;\n\tmemcpy(cmb_data->last_block, hw_block, cmb_data->size);\n\tcmb_data->last_update = get_tod_clock();\n\treturn 0;\n}\n\nstruct copy_block_struct {\n\twait_queue_head_t wait;\n\tint ret;\n};\n\nstatic int cmf_cmb_copy_wait(struct ccw_device *cdev)\n{\n\tstruct copy_block_struct copy_block;\n\tint ret = -ENODEV;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tif (!cdev->private->cmb)\n\t\tgoto out;\n\n\tret = cmf_copy_block(cdev);\n\tif (ret != -EBUSY)\n\t\tgoto out;\n\n\tif (cdev->private->state != DEV_STATE_ONLINE)\n\t\tgoto out;\n\n\tinit_waitqueue_head(&copy_block.wait);\n\tcopy_block.ret = CMF_PENDING;\n\n\tcdev->private->state = DEV_STATE_CMFUPDATE;\n\tcdev->private->cmb_wait = &copy_block;\n\tspin_unlock_irq(cdev->ccwlock);\n\n\tret = wait_event_interruptible(copy_block.wait,\n\t\t\t\t       copy_block.ret != CMF_PENDING);\n\tspin_lock_irq(cdev->ccwlock);\n\tif (ret) {\n\t\tif (copy_block.ret == CMF_PENDING) {\n\t\t\tcopy_block.ret = -ERESTARTSYS;\n\t\t\tif (cdev->private->state == DEV_STATE_CMFUPDATE)\n\t\t\t\tcdev->private->state = DEV_STATE_ONLINE;\n\t\t}\n\t}\n\tcdev->private->cmb_wait = NULL;\n\tret = copy_block.ret;\nout:\n\tspin_unlock_irq(cdev->ccwlock);\n\treturn ret;\n}\n\nvoid cmf_retry_copy_block(struct ccw_device *cdev)\n{\n\tstruct copy_block_struct *copy_block = cdev->private->cmb_wait;\n\n\tif (!copy_block)\n\t\treturn;\n\n\tcopy_block->ret = cmf_copy_block(cdev);\n\twake_up(&copy_block->wait);\n}\n\nstatic void cmf_generic_reset(struct ccw_device *cdev)\n{\n\tstruct cmb_data *cmb_data;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tcmb_data = cdev->private->cmb;\n\tif (cmb_data) {\n\t\tmemset(cmb_data->last_block, 0, cmb_data->size);\n\t\t \n\t\tmemset(cmb_data->hw_block, 0, cmb_data->size);\n\t\tcmb_data->last_update = 0;\n\t}\n\tcdev->private->cmb_start_time = get_tod_clock();\n\tspin_unlock_irq(cdev->ccwlock);\n}\n\n \nstruct cmb_area {\n\tstruct cmb *mem;\n\tstruct list_head list;\n\tint num_channels;\n\tspinlock_t lock;\n};\n\nstatic struct cmb_area cmb_area = {\n\t.lock = __SPIN_LOCK_UNLOCKED(cmb_area.lock),\n\t.list = LIST_HEAD_INIT(cmb_area.list),\n\t.num_channels  = 1024,\n};\n\n \n\n \n\nmodule_param_named(maxchannels, cmb_area.num_channels, uint, 0444);\n\n \nstruct cmb {\n\tu16 ssch_rsch_count;\n\tu16 sample_count;\n\tu32 device_connect_time;\n\tu32 function_pending_time;\n\tu32 device_disconnect_time;\n\tu32 control_unit_queuing_time;\n\tu32 device_active_only_time;\n\tu32 reserved[2];\n};\n\n \nstatic int alloc_cmb_single(struct ccw_device *cdev,\n\t\t\t    struct cmb_data *cmb_data)\n{\n\tstruct cmb *cmb;\n\tstruct ccw_device_private *node;\n\tint ret;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tif (!list_empty(&cdev->private->cmb_list)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tcmb = cmb_area.mem;\n\tlist_for_each_entry(node, &cmb_area.list, cmb_list) {\n\t\tstruct cmb_data *data;\n\t\tdata = node->cmb;\n\t\tif ((struct cmb*)data->hw_block > cmb)\n\t\t\tbreak;\n\t\tcmb++;\n\t}\n\tif (cmb - cmb_area.mem >= cmb_area.num_channels) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tlist_add_tail(&cdev->private->cmb_list, &node->cmb_list);\n\tcmb_data->hw_block = cmb;\n\tcdev->private->cmb = cmb_data;\n\tret = 0;\nout:\n\tspin_unlock_irq(cdev->ccwlock);\n\treturn ret;\n}\n\nstatic int alloc_cmb(struct ccw_device *cdev)\n{\n\tint ret;\n\tstruct cmb *mem;\n\tssize_t size;\n\tstruct cmb_data *cmb_data;\n\n\t \n\tcmb_data = kzalloc(sizeof(struct cmb_data), GFP_KERNEL);\n\tif (!cmb_data)\n\t\treturn -ENOMEM;\n\n\tcmb_data->last_block = kzalloc(sizeof(struct cmb), GFP_KERNEL);\n\tif (!cmb_data->last_block) {\n\t\tkfree(cmb_data);\n\t\treturn -ENOMEM;\n\t}\n\tcmb_data->size = sizeof(struct cmb);\n\tspin_lock(&cmb_area.lock);\n\n\tif (!cmb_area.mem) {\n\t\t \n\t\tsize = sizeof(struct cmb) * cmb_area.num_channels;\n\t\tWARN_ON(!list_empty(&cmb_area.list));\n\n\t\tspin_unlock(&cmb_area.lock);\n\t\tmem = (void*)__get_free_pages(GFP_KERNEL | GFP_DMA,\n\t\t\t\t get_order(size));\n\t\tspin_lock(&cmb_area.lock);\n\n\t\tif (cmb_area.mem) {\n\t\t\t \n\t\t\tfree_pages((unsigned long)mem, get_order(size));\n\t\t} else if (!mem) {\n\t\t\t \n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\tmemset(mem, 0, size);\n\t\t\tcmb_area.mem = mem;\n\t\t\tcmf_activate(cmb_area.mem, CMF_ON);\n\t\t}\n\t}\n\n\t \n\tret = alloc_cmb_single(cdev, cmb_data);\nout:\n\tspin_unlock(&cmb_area.lock);\n\tif (ret) {\n\t\tkfree(cmb_data->last_block);\n\t\tkfree(cmb_data);\n\t}\n\treturn ret;\n}\n\nstatic void free_cmb(struct ccw_device *cdev)\n{\n\tstruct ccw_device_private *priv;\n\tstruct cmb_data *cmb_data;\n\n\tspin_lock(&cmb_area.lock);\n\tspin_lock_irq(cdev->ccwlock);\n\n\tpriv = cdev->private;\n\tcmb_data = priv->cmb;\n\tpriv->cmb = NULL;\n\tif (cmb_data)\n\t\tkfree(cmb_data->last_block);\n\tkfree(cmb_data);\n\tlist_del_init(&priv->cmb_list);\n\n\tif (list_empty(&cmb_area.list)) {\n\t\tssize_t size;\n\t\tsize = sizeof(struct cmb) * cmb_area.num_channels;\n\t\tcmf_activate(NULL, CMF_OFF);\n\t\tfree_pages((unsigned long)cmb_area.mem, get_order(size));\n\t\tcmb_area.mem = NULL;\n\t}\n\tspin_unlock_irq(cdev->ccwlock);\n\tspin_unlock(&cmb_area.lock);\n}\n\nstatic int set_cmb(struct ccw_device *cdev, u32 mme)\n{\n\tu16 offset;\n\tstruct cmb_data *cmb_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(cdev->ccwlock, flags);\n\tif (!cdev->private->cmb) {\n\t\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\t\treturn -EINVAL;\n\t}\n\tcmb_data = cdev->private->cmb;\n\toffset = mme ? (struct cmb *)cmb_data->hw_block - cmb_area.mem : 0;\n\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\n\treturn set_schib_wait(cdev, mme, 0, offset);\n}\n\n \nstatic u64 __cmb_utilization(u64 device_connect_time, u64 function_pending_time,\n\t\t\t     u64 device_disconnect_time, u64 start_time)\n{\n\tu64 utilization, elapsed_time;\n\n\tutilization = time_to_nsec(device_connect_time +\n\t\t\t\t   function_pending_time +\n\t\t\t\t   device_disconnect_time);\n\n\telapsed_time = get_tod_clock() - start_time;\n\telapsed_time = tod_to_ns(elapsed_time);\n\telapsed_time /= 1000;\n\n\treturn elapsed_time ? (utilization / elapsed_time) : 0;\n}\n\nstatic u64 read_cmb(struct ccw_device *cdev, int index)\n{\n\tstruct cmb_data *cmb_data;\n\tunsigned long flags;\n\tstruct cmb *cmb;\n\tu64 ret = 0;\n\tu32 val;\n\n\tspin_lock_irqsave(cdev->ccwlock, flags);\n\tcmb_data = cdev->private->cmb;\n\tif (!cmb_data)\n\t\tgoto out;\n\n\tcmb = cmb_data->hw_block;\n\tswitch (index) {\n\tcase avg_utilization:\n\t\tret = __cmb_utilization(cmb->device_connect_time,\n\t\t\t\t\tcmb->function_pending_time,\n\t\t\t\t\tcmb->device_disconnect_time,\n\t\t\t\t\tcdev->private->cmb_start_time);\n\t\tgoto out;\n\tcase cmb_ssch_rsch_count:\n\t\tret = cmb->ssch_rsch_count;\n\t\tgoto out;\n\tcase cmb_sample_count:\n\t\tret = cmb->sample_count;\n\t\tgoto out;\n\tcase cmb_device_connect_time:\n\t\tval = cmb->device_connect_time;\n\t\tbreak;\n\tcase cmb_function_pending_time:\n\t\tval = cmb->function_pending_time;\n\t\tbreak;\n\tcase cmb_device_disconnect_time:\n\t\tval = cmb->device_disconnect_time;\n\t\tbreak;\n\tcase cmb_control_unit_queuing_time:\n\t\tval = cmb->control_unit_queuing_time;\n\t\tbreak;\n\tcase cmb_device_active_only_time:\n\t\tval = cmb->device_active_only_time;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\tret = time_to_avg_nsec(val, cmb->sample_count);\nout:\n\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\treturn ret;\n}\n\nstatic int readall_cmb(struct ccw_device *cdev, struct cmbdata *data)\n{\n\tstruct cmb *cmb;\n\tstruct cmb_data *cmb_data;\n\tu64 time;\n\tunsigned long flags;\n\tint ret;\n\n\tret = cmf_cmb_copy_wait(cdev);\n\tif (ret < 0)\n\t\treturn ret;\n\tspin_lock_irqsave(cdev->ccwlock, flags);\n\tcmb_data = cdev->private->cmb;\n\tif (!cmb_data) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (cmb_data->last_update == 0) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tcmb = cmb_data->last_block;\n\ttime = cmb_data->last_update - cdev->private->cmb_start_time;\n\n\tmemset(data, 0, sizeof(struct cmbdata));\n\n\t \n\tdata->size = offsetof(struct cmbdata, device_busy_time);\n\n\tdata->elapsed_time = tod_to_ns(time);\n\n\t \n\tdata->ssch_rsch_count = cmb->ssch_rsch_count;\n\tdata->sample_count = cmb->sample_count;\n\n\t \n\tdata->device_connect_time = time_to_nsec(cmb->device_connect_time);\n\tdata->function_pending_time = time_to_nsec(cmb->function_pending_time);\n\tdata->device_disconnect_time =\n\t\ttime_to_nsec(cmb->device_disconnect_time);\n\tdata->control_unit_queuing_time\n\t\t= time_to_nsec(cmb->control_unit_queuing_time);\n\tdata->device_active_only_time\n\t\t= time_to_nsec(cmb->device_active_only_time);\n\tret = 0;\nout:\n\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\treturn ret;\n}\n\nstatic void reset_cmb(struct ccw_device *cdev)\n{\n\tcmf_generic_reset(cdev);\n}\n\nstatic int cmf_enabled(struct ccw_device *cdev)\n{\n\tint enabled;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tenabled = !!cdev->private->cmb;\n\tspin_unlock_irq(cdev->ccwlock);\n\n\treturn enabled;\n}\n\nstatic struct attribute_group cmf_attr_group;\n\nstatic struct cmb_operations cmbops_basic = {\n\t.alloc\t= alloc_cmb,\n\t.free\t= free_cmb,\n\t.set\t= set_cmb,\n\t.read\t= read_cmb,\n\t.readall    = readall_cmb,\n\t.reset\t    = reset_cmb,\n\t.attr_group = &cmf_attr_group,\n};\n\n \n\n \nstruct cmbe {\n\tu32 ssch_rsch_count;\n\tu32 sample_count;\n\tu32 device_connect_time;\n\tu32 function_pending_time;\n\tu32 device_disconnect_time;\n\tu32 control_unit_queuing_time;\n\tu32 device_active_only_time;\n\tu32 device_busy_time;\n\tu32 initial_command_response_time;\n\tu32 reserved[7];\n} __packed __aligned(64);\n\nstatic struct kmem_cache *cmbe_cache;\n\nstatic int alloc_cmbe(struct ccw_device *cdev)\n{\n\tstruct cmb_data *cmb_data;\n\tstruct cmbe *cmbe;\n\tint ret = -ENOMEM;\n\n\tcmbe = kmem_cache_zalloc(cmbe_cache, GFP_KERNEL);\n\tif (!cmbe)\n\t\treturn ret;\n\n\tcmb_data = kzalloc(sizeof(*cmb_data), GFP_KERNEL);\n\tif (!cmb_data)\n\t\tgoto out_free;\n\n\tcmb_data->last_block = kzalloc(sizeof(struct cmbe), GFP_KERNEL);\n\tif (!cmb_data->last_block)\n\t\tgoto out_free;\n\n\tcmb_data->size = sizeof(*cmbe);\n\tcmb_data->hw_block = cmbe;\n\n\tspin_lock(&cmb_area.lock);\n\tspin_lock_irq(cdev->ccwlock);\n\tif (cdev->private->cmb)\n\t\tgoto out_unlock;\n\n\tcdev->private->cmb = cmb_data;\n\n\t \n\tif (list_empty(&cmb_area.list))\n\t\tcmf_activate(NULL, CMF_ON);\n\tlist_add_tail(&cdev->private->cmb_list, &cmb_area.list);\n\n\tspin_unlock_irq(cdev->ccwlock);\n\tspin_unlock(&cmb_area.lock);\n\treturn 0;\n\nout_unlock:\n\tspin_unlock_irq(cdev->ccwlock);\n\tspin_unlock(&cmb_area.lock);\n\tret = -EBUSY;\nout_free:\n\tif (cmb_data)\n\t\tkfree(cmb_data->last_block);\n\tkfree(cmb_data);\n\tkmem_cache_free(cmbe_cache, cmbe);\n\n\treturn ret;\n}\n\nstatic void free_cmbe(struct ccw_device *cdev)\n{\n\tstruct cmb_data *cmb_data;\n\n\tspin_lock(&cmb_area.lock);\n\tspin_lock_irq(cdev->ccwlock);\n\tcmb_data = cdev->private->cmb;\n\tcdev->private->cmb = NULL;\n\tif (cmb_data) {\n\t\tkfree(cmb_data->last_block);\n\t\tkmem_cache_free(cmbe_cache, cmb_data->hw_block);\n\t}\n\tkfree(cmb_data);\n\n\t \n\tlist_del_init(&cdev->private->cmb_list);\n\tif (list_empty(&cmb_area.list))\n\t\tcmf_activate(NULL, CMF_OFF);\n\tspin_unlock_irq(cdev->ccwlock);\n\tspin_unlock(&cmb_area.lock);\n}\n\nstatic int set_cmbe(struct ccw_device *cdev, u32 mme)\n{\n\tunsigned long mba;\n\tstruct cmb_data *cmb_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(cdev->ccwlock, flags);\n\tif (!cdev->private->cmb) {\n\t\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\t\treturn -EINVAL;\n\t}\n\tcmb_data = cdev->private->cmb;\n\tmba = mme ? (unsigned long) cmb_data->hw_block : 0;\n\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\n\treturn set_schib_wait(cdev, mme, 1, mba);\n}\n\nstatic u64 read_cmbe(struct ccw_device *cdev, int index)\n{\n\tstruct cmb_data *cmb_data;\n\tunsigned long flags;\n\tstruct cmbe *cmb;\n\tu64 ret = 0;\n\tu32 val;\n\n\tspin_lock_irqsave(cdev->ccwlock, flags);\n\tcmb_data = cdev->private->cmb;\n\tif (!cmb_data)\n\t\tgoto out;\n\n\tcmb = cmb_data->hw_block;\n\tswitch (index) {\n\tcase avg_utilization:\n\t\tret = __cmb_utilization(cmb->device_connect_time,\n\t\t\t\t\tcmb->function_pending_time,\n\t\t\t\t\tcmb->device_disconnect_time,\n\t\t\t\t\tcdev->private->cmb_start_time);\n\t\tgoto out;\n\tcase cmb_ssch_rsch_count:\n\t\tret = cmb->ssch_rsch_count;\n\t\tgoto out;\n\tcase cmb_sample_count:\n\t\tret = cmb->sample_count;\n\t\tgoto out;\n\tcase cmb_device_connect_time:\n\t\tval = cmb->device_connect_time;\n\t\tbreak;\n\tcase cmb_function_pending_time:\n\t\tval = cmb->function_pending_time;\n\t\tbreak;\n\tcase cmb_device_disconnect_time:\n\t\tval = cmb->device_disconnect_time;\n\t\tbreak;\n\tcase cmb_control_unit_queuing_time:\n\t\tval = cmb->control_unit_queuing_time;\n\t\tbreak;\n\tcase cmb_device_active_only_time:\n\t\tval = cmb->device_active_only_time;\n\t\tbreak;\n\tcase cmb_device_busy_time:\n\t\tval = cmb->device_busy_time;\n\t\tbreak;\n\tcase cmb_initial_command_response_time:\n\t\tval = cmb->initial_command_response_time;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\tret = time_to_avg_nsec(val, cmb->sample_count);\nout:\n\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\treturn ret;\n}\n\nstatic int readall_cmbe(struct ccw_device *cdev, struct cmbdata *data)\n{\n\tstruct cmbe *cmb;\n\tstruct cmb_data *cmb_data;\n\tu64 time;\n\tunsigned long flags;\n\tint ret;\n\n\tret = cmf_cmb_copy_wait(cdev);\n\tif (ret < 0)\n\t\treturn ret;\n\tspin_lock_irqsave(cdev->ccwlock, flags);\n\tcmb_data = cdev->private->cmb;\n\tif (!cmb_data) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (cmb_data->last_update == 0) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\ttime = cmb_data->last_update - cdev->private->cmb_start_time;\n\n\tmemset (data, 0, sizeof(struct cmbdata));\n\n\t \n\tdata->size = offsetof(struct cmbdata, device_busy_time);\n\n\tdata->elapsed_time = tod_to_ns(time);\n\n\tcmb = cmb_data->last_block;\n\t \n\tdata->ssch_rsch_count = cmb->ssch_rsch_count;\n\tdata->sample_count = cmb->sample_count;\n\n\t \n\tdata->device_connect_time = time_to_nsec(cmb->device_connect_time);\n\tdata->function_pending_time = time_to_nsec(cmb->function_pending_time);\n\tdata->device_disconnect_time =\n\t\ttime_to_nsec(cmb->device_disconnect_time);\n\tdata->control_unit_queuing_time\n\t\t= time_to_nsec(cmb->control_unit_queuing_time);\n\tdata->device_active_only_time\n\t\t= time_to_nsec(cmb->device_active_only_time);\n\tdata->device_busy_time = time_to_nsec(cmb->device_busy_time);\n\tdata->initial_command_response_time\n\t\t= time_to_nsec(cmb->initial_command_response_time);\n\n\tret = 0;\nout:\n\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\treturn ret;\n}\n\nstatic void reset_cmbe(struct ccw_device *cdev)\n{\n\tcmf_generic_reset(cdev);\n}\n\nstatic struct attribute_group cmf_attr_group_ext;\n\nstatic struct cmb_operations cmbops_extended = {\n\t.alloc\t    = alloc_cmbe,\n\t.free\t    = free_cmbe,\n\t.set\t    = set_cmbe,\n\t.read\t    = read_cmbe,\n\t.readall    = readall_cmbe,\n\t.reset\t    = reset_cmbe,\n\t.attr_group = &cmf_attr_group_ext,\n};\n\nstatic ssize_t cmb_show_attr(struct device *dev, char *buf, enum cmb_index idx)\n{\n\treturn sprintf(buf, \"%lld\\n\",\n\t\t(unsigned long long) cmf_read(to_ccwdev(dev), idx));\n}\n\nstatic ssize_t cmb_show_avg_sample_interval(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tunsigned long count;\n\tlong interval;\n\n\tcount = cmf_read(cdev, cmb_sample_count);\n\tspin_lock_irq(cdev->ccwlock);\n\tif (count) {\n\t\tinterval = get_tod_clock() - cdev->private->cmb_start_time;\n\t\tinterval = tod_to_ns(interval);\n\t\tinterval /= count;\n\t} else\n\t\tinterval = -1;\n\tspin_unlock_irq(cdev->ccwlock);\n\treturn sprintf(buf, \"%ld\\n\", interval);\n}\n\nstatic ssize_t cmb_show_avg_utilization(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tunsigned long u = cmf_read(to_ccwdev(dev), avg_utilization);\n\n\treturn sprintf(buf, \"%02lu.%01lu%%\\n\", u / 10, u % 10);\n}\n\n#define cmf_attr(name) \\\nstatic ssize_t show_##name(struct device *dev, \\\n\t\t\t   struct device_attribute *attr, char *buf)\t\\\n{ return cmb_show_attr((dev), buf, cmb_##name); } \\\nstatic DEVICE_ATTR(name, 0444, show_##name, NULL);\n\n#define cmf_attr_avg(name) \\\nstatic ssize_t show_avg_##name(struct device *dev, \\\n\t\t\t       struct device_attribute *attr, char *buf) \\\n{ return cmb_show_attr((dev), buf, cmb_##name); } \\\nstatic DEVICE_ATTR(avg_##name, 0444, show_avg_##name, NULL);\n\ncmf_attr(ssch_rsch_count);\ncmf_attr(sample_count);\ncmf_attr_avg(device_connect_time);\ncmf_attr_avg(function_pending_time);\ncmf_attr_avg(device_disconnect_time);\ncmf_attr_avg(control_unit_queuing_time);\ncmf_attr_avg(device_active_only_time);\ncmf_attr_avg(device_busy_time);\ncmf_attr_avg(initial_command_response_time);\n\nstatic DEVICE_ATTR(avg_sample_interval, 0444, cmb_show_avg_sample_interval,\n\t\t   NULL);\nstatic DEVICE_ATTR(avg_utilization, 0444, cmb_show_avg_utilization, NULL);\n\nstatic struct attribute *cmf_attributes[] = {\n\t&dev_attr_avg_sample_interval.attr,\n\t&dev_attr_avg_utilization.attr,\n\t&dev_attr_ssch_rsch_count.attr,\n\t&dev_attr_sample_count.attr,\n\t&dev_attr_avg_device_connect_time.attr,\n\t&dev_attr_avg_function_pending_time.attr,\n\t&dev_attr_avg_device_disconnect_time.attr,\n\t&dev_attr_avg_control_unit_queuing_time.attr,\n\t&dev_attr_avg_device_active_only_time.attr,\n\tNULL,\n};\n\nstatic struct attribute_group cmf_attr_group = {\n\t.name  = \"cmf\",\n\t.attrs = cmf_attributes,\n};\n\nstatic struct attribute *cmf_attributes_ext[] = {\n\t&dev_attr_avg_sample_interval.attr,\n\t&dev_attr_avg_utilization.attr,\n\t&dev_attr_ssch_rsch_count.attr,\n\t&dev_attr_sample_count.attr,\n\t&dev_attr_avg_device_connect_time.attr,\n\t&dev_attr_avg_function_pending_time.attr,\n\t&dev_attr_avg_device_disconnect_time.attr,\n\t&dev_attr_avg_control_unit_queuing_time.attr,\n\t&dev_attr_avg_device_active_only_time.attr,\n\t&dev_attr_avg_device_busy_time.attr,\n\t&dev_attr_avg_initial_command_response_time.attr,\n\tNULL,\n};\n\nstatic struct attribute_group cmf_attr_group_ext = {\n\t.name  = \"cmf\",\n\t.attrs = cmf_attributes_ext,\n};\n\nstatic ssize_t cmb_enable_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\n\treturn sprintf(buf, \"%d\\n\", cmf_enabled(cdev));\n}\n\nstatic ssize_t cmb_enable_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t c)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 16, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase 0:\n\t\tret = disable_cmf(cdev);\n\t\tbreak;\n\tcase 1:\n\t\tret = enable_cmf(cdev);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ? ret : c;\n}\nDEVICE_ATTR_RW(cmb_enable);\n\n \nint enable_cmf(struct ccw_device *cdev)\n{\n\tint ret = 0;\n\n\tdevice_lock(&cdev->dev);\n\tif (cmf_enabled(cdev)) {\n\t\tcmbops->reset(cdev);\n\t\tgoto out_unlock;\n\t}\n\tget_device(&cdev->dev);\n\tret = cmbops->alloc(cdev);\n\tif (ret)\n\t\tgoto out;\n\tcmbops->reset(cdev);\n\tret = sysfs_create_group(&cdev->dev.kobj, cmbops->attr_group);\n\tif (ret) {\n\t\tcmbops->free(cdev);\n\t\tgoto out;\n\t}\n\tret = cmbops->set(cdev, 2);\n\tif (ret) {\n\t\tsysfs_remove_group(&cdev->dev.kobj, cmbops->attr_group);\n\t\tcmbops->free(cdev);\n\t}\nout:\n\tif (ret)\n\t\tput_device(&cdev->dev);\nout_unlock:\n\tdevice_unlock(&cdev->dev);\n\treturn ret;\n}\n\n \nint __disable_cmf(struct ccw_device *cdev)\n{\n\tint ret;\n\n\tret = cmbops->set(cdev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tsysfs_remove_group(&cdev->dev.kobj, cmbops->attr_group);\n\tcmbops->free(cdev);\n\tput_device(&cdev->dev);\n\n\treturn ret;\n}\n\n \nint disable_cmf(struct ccw_device *cdev)\n{\n\tint ret;\n\n\tdevice_lock(&cdev->dev);\n\tret = __disable_cmf(cdev);\n\tdevice_unlock(&cdev->dev);\n\n\treturn ret;\n}\n\n \nu64 cmf_read(struct ccw_device *cdev, int index)\n{\n\treturn cmbops->read(cdev, index);\n}\n\n \nint cmf_readall(struct ccw_device *cdev, struct cmbdata *data)\n{\n\treturn cmbops->readall(cdev, data);\n}\n\n \nint cmf_reenable(struct ccw_device *cdev)\n{\n\tcmbops->reset(cdev);\n\treturn cmbops->set(cdev, 2);\n}\n\n \nvoid cmf_reactivate(void)\n{\n\tspin_lock(&cmb_area.lock);\n\tif (!list_empty(&cmb_area.list))\n\t\tcmf_activate(cmb_area.mem, CMF_ON);\n\tspin_unlock(&cmb_area.lock);\n}\n\nstatic int __init init_cmbe(void)\n{\n\tcmbe_cache = kmem_cache_create(\"cmbe_cache\", sizeof(struct cmbe),\n\t\t\t\t       __alignof__(struct cmbe), 0, NULL);\n\n\treturn cmbe_cache ? 0 : -ENOMEM;\n}\n\nstatic int __init init_cmf(void)\n{\n\tchar *format_string;\n\tchar *detect_string;\n\tint ret;\n\n\t \n\tif (format == CMF_AUTODETECT) {\n\t\tif (!css_general_characteristics.ext_mb) {\n\t\t\tformat = CMF_BASIC;\n\t\t} else {\n\t\t\tformat = CMF_EXTENDED;\n\t\t}\n\t\tdetect_string = \"autodetected\";\n\t} else {\n\t\tdetect_string = \"parameter\";\n\t}\n\n\tswitch (format) {\n\tcase CMF_BASIC:\n\t\tformat_string = \"basic\";\n\t\tcmbops = &cmbops_basic;\n\t\tbreak;\n\tcase CMF_EXTENDED:\n\t\tformat_string = \"extended\";\n\t\tcmbops = &cmbops_extended;\n\n\t\tret = init_cmbe();\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tpr_info(\"Channel measurement facility initialized using format \"\n\t\t\"%s (mode %s)\\n\", format_string, detect_string);\n\treturn 0;\n}\ndevice_initcall(init_cmf);\n\nEXPORT_SYMBOL_GPL(enable_cmf);\nEXPORT_SYMBOL_GPL(disable_cmf);\nEXPORT_SYMBOL_GPL(cmf_read);\nEXPORT_SYMBOL_GPL(cmf_readall);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}