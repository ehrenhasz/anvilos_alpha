{
  "module_name": "scm.c",
  "hash_id": "f2820e9b8d74155038a0a822af99bc35b8df45430488f405c010a2c5f0fe5a18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/scm.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <asm/eadm.h>\n#include \"chsc.h\"\n\nstatic struct device *scm_root;\n\n#define to_scm_dev(n) container_of(n, struct scm_device, dev)\n#define\tto_scm_drv(d) container_of(d, struct scm_driver, drv)\n\nstatic int scmdev_probe(struct device *dev)\n{\n\tstruct scm_device *scmdev = to_scm_dev(dev);\n\tstruct scm_driver *scmdrv = to_scm_drv(dev->driver);\n\n\treturn scmdrv->probe ? scmdrv->probe(scmdev) : -ENODEV;\n}\n\nstatic void scmdev_remove(struct device *dev)\n{\n\tstruct scm_device *scmdev = to_scm_dev(dev);\n\tstruct scm_driver *scmdrv = to_scm_drv(dev->driver);\n\n\tif (scmdrv->remove)\n\t\tscmdrv->remove(scmdev);\n}\n\nstatic int scmdev_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\treturn add_uevent_var(env, \"MODALIAS=scm:scmdev\");\n}\n\nstatic struct bus_type scm_bus_type = {\n\t.name  = \"scm\",\n\t.probe = scmdev_probe,\n\t.remove = scmdev_remove,\n\t.uevent = scmdev_uevent,\n};\n\n \nint scm_driver_register(struct scm_driver *scmdrv)\n{\n\tstruct device_driver *drv = &scmdrv->drv;\n\n\tdrv->bus = &scm_bus_type;\n\n\treturn driver_register(drv);\n}\nEXPORT_SYMBOL_GPL(scm_driver_register);\n\n \nvoid scm_driver_unregister(struct scm_driver *scmdrv)\n{\n\tdriver_unregister(&scmdrv->drv);\n}\nEXPORT_SYMBOL_GPL(scm_driver_unregister);\n\nvoid scm_irq_handler(struct aob *aob, blk_status_t error)\n{\n\tstruct aob_rq_header *aobrq = (void *) aob->request.data;\n\tstruct scm_device *scmdev = aobrq->scmdev;\n\tstruct scm_driver *scmdrv = to_scm_drv(scmdev->dev.driver);\n\n\tscmdrv->handler(scmdev, aobrq->data, error);\n}\nEXPORT_SYMBOL_GPL(scm_irq_handler);\n\n#define scm_attr(name)\t\t\t\t\t\t\t\\\nstatic ssize_t show_##name(struct device *dev,\t\t\t\t\\\n\t       struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scm_device *scmdev = to_scm_dev(dev);\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdevice_lock(dev);\t\t\t\t\t\t\\\n\tret = sprintf(buf, \"%u\\n\", scmdev->attrs.name);\t\t\t\\\n\tdevice_unlock(dev);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, show_##name, NULL);\n\nscm_attr(persistence);\nscm_attr(oper_state);\nscm_attr(data_state);\nscm_attr(rank);\nscm_attr(release);\nscm_attr(res_id);\n\nstatic struct attribute *scmdev_attrs[] = {\n\t&dev_attr_persistence.attr,\n\t&dev_attr_oper_state.attr,\n\t&dev_attr_data_state.attr,\n\t&dev_attr_rank.attr,\n\t&dev_attr_release.attr,\n\t&dev_attr_res_id.attr,\n\tNULL,\n};\n\nstatic struct attribute_group scmdev_attr_group = {\n\t.attrs = scmdev_attrs,\n};\n\nstatic const struct attribute_group *scmdev_attr_groups[] = {\n\t&scmdev_attr_group,\n\tNULL,\n};\n\nstatic void scmdev_release(struct device *dev)\n{\n\tstruct scm_device *scmdev = to_scm_dev(dev);\n\n\tkfree(scmdev);\n}\n\nstatic void scmdev_setup(struct scm_device *scmdev, struct sale *sale,\n\t\t\t unsigned int size, unsigned int max_blk_count)\n{\n\tdev_set_name(&scmdev->dev, \"%016llx\", (unsigned long long) sale->sa);\n\tscmdev->nr_max_block = max_blk_count;\n\tscmdev->address = sale->sa;\n\tscmdev->size = 1UL << size;\n\tscmdev->attrs.rank = sale->rank;\n\tscmdev->attrs.persistence = sale->p;\n\tscmdev->attrs.oper_state = sale->op_state;\n\tscmdev->attrs.data_state = sale->data_state;\n\tscmdev->attrs.rank = sale->rank;\n\tscmdev->attrs.release = sale->r;\n\tscmdev->attrs.res_id = sale->rid;\n\tscmdev->dev.parent = scm_root;\n\tscmdev->dev.bus = &scm_bus_type;\n\tscmdev->dev.release = scmdev_release;\n\tscmdev->dev.groups = scmdev_attr_groups;\n}\n\n \nstatic void scmdev_update(struct scm_device *scmdev, struct sale *sale)\n{\n\tstruct scm_driver *scmdrv;\n\tbool changed;\n\n\tdevice_lock(&scmdev->dev);\n\tchanged = scmdev->attrs.rank != sale->rank ||\n\t\t  scmdev->attrs.oper_state != sale->op_state;\n\tscmdev->attrs.rank = sale->rank;\n\tscmdev->attrs.oper_state = sale->op_state;\n\tif (!scmdev->dev.driver)\n\t\tgoto out;\n\tscmdrv = to_scm_drv(scmdev->dev.driver);\n\tif (changed && scmdrv->notify)\n\t\tscmdrv->notify(scmdev, SCM_CHANGE);\nout:\n\tdevice_unlock(&scmdev->dev);\n\tif (changed)\n\t\tkobject_uevent(&scmdev->dev.kobj, KOBJ_CHANGE);\n}\n\nstatic int check_address(struct device *dev, const void *data)\n{\n\tstruct scm_device *scmdev = to_scm_dev(dev);\n\tconst struct sale *sale = data;\n\n\treturn scmdev->address == sale->sa;\n}\n\nstatic struct scm_device *scmdev_find(struct sale *sale)\n{\n\tstruct device *dev;\n\n\tdev = bus_find_device(&scm_bus_type, NULL, sale, check_address);\n\n\treturn dev ? to_scm_dev(dev) : NULL;\n}\n\nstatic int scm_add(struct chsc_scm_info *scm_info, size_t num)\n{\n\tstruct sale *sale, *scmal = scm_info->scmal;\n\tstruct scm_device *scmdev;\n\tint ret;\n\n\tfor (sale = scmal; sale < scmal + num; sale++) {\n\t\tscmdev = scmdev_find(sale);\n\t\tif (scmdev) {\n\t\t\tscmdev_update(scmdev, sale);\n\t\t\t \n\t\t\tput_device(&scmdev->dev);\n\t\t\tcontinue;\n\t\t}\n\t\tscmdev = kzalloc(sizeof(*scmdev), GFP_KERNEL);\n\t\tif (!scmdev)\n\t\t\treturn -ENODEV;\n\t\tscmdev_setup(scmdev, sale, scm_info->is, scm_info->mbc);\n\t\tret = device_register(&scmdev->dev);\n\t\tif (ret) {\n\t\t\t \n\t\t\tput_device(&scmdev->dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint scm_update_information(void)\n{\n\tstruct chsc_scm_info *scm_info;\n\tu64 token = 0;\n\tsize_t num;\n\tint ret;\n\n\tscm_info = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);\n\tif (!scm_info)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tret = chsc_scm_info(scm_info, token);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnum = (scm_info->response.length -\n\t\t       (offsetof(struct chsc_scm_info, scmal) -\n\t\t\toffsetof(struct chsc_scm_info, response))\n\t\t      ) / sizeof(struct sale);\n\n\t\tret = scm_add(scm_info, num);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\ttoken = scm_info->restok;\n\t} while (token);\n\n\tfree_page((unsigned long)scm_info);\n\n\treturn ret;\n}\n\nstatic int scm_dev_avail(struct device *dev, void *unused)\n{\n\tstruct scm_driver *scmdrv = to_scm_drv(dev->driver);\n\tstruct scm_device *scmdev = to_scm_dev(dev);\n\n\tif (dev->driver && scmdrv->notify)\n\t\tscmdrv->notify(scmdev, SCM_AVAIL);\n\n\treturn 0;\n}\n\nint scm_process_availability_information(void)\n{\n\treturn bus_for_each_dev(&scm_bus_type, NULL, NULL, scm_dev_avail);\n}\n\nstatic int __init scm_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&scm_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\tscm_root = root_device_register(\"scm\");\n\tif (IS_ERR(scm_root)) {\n\t\tbus_unregister(&scm_bus_type);\n\t\treturn PTR_ERR(scm_root);\n\t}\n\n\tscm_update_information();\n\treturn 0;\n}\nsubsys_initcall_sync(scm_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}