{
  "module_name": "css.h",
  "hash_id": "1932d32be5aa2720145d1bf6aaee7fe7d4f941c5db35a67f187919c5bd0e7e7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/css.h",
  "human_readable_source": " \n#ifndef _CSS_H\n#define _CSS_H\n\n#include <linux/mutex.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\n#include <asm/cio.h>\n#include <asm/chpid.h>\n#include <asm/schid.h>\n\n#include \"cio.h\"\n\n \n#define SPID_FUNC_SINGLE_PATH\t   0x00\n#define SPID_FUNC_MULTI_PATH\t   0x80\n#define SPID_FUNC_ESTABLISH\t   0x00\n#define SPID_FUNC_RESIGN\t   0x40\n#define SPID_FUNC_DISBAND\t   0x20\n\n#define SNID_STATE1_RESET\t   0\n#define SNID_STATE1_UNGROUPED\t   2\n#define SNID_STATE1_GROUPED\t   3\n\n#define SNID_STATE2_NOT_RESVD\t   0\n#define SNID_STATE2_RESVD_ELSE\t   2\n#define SNID_STATE2_RESVD_SELF\t   3\n\n#define SNID_STATE3_MULTI_PATH\t   1\n#define SNID_STATE3_SINGLE_PATH\t   0\n\n \nenum css_eval_cond {\n\tCSS_EVAL_NO_PATH,\t\t \n\tCSS_EVAL_NOT_ONLINE\t \n};\n\nstruct path_state {\n\t__u8  state1 : 2;\t \n\t__u8  state2 : 2;\t \n\t__u8  state3 : 1;\t \n\t__u8  resvd  : 3;\t \n} __attribute__ ((packed));\n\nstruct extended_cssid {\n\tu8 version;\n\tu8 cssid;\n} __attribute__ ((packed));\n\nstruct pgid {\n\tunion {\n\t\t__u8 fc;   \t \n\t\tstruct path_state ps;\t \n\t} __attribute__ ((packed)) inf;\n\tunion {\n\t\t__u32 cpu_addr\t: 16;\t \n\t\tstruct extended_cssid ext_cssid;\n\t} __attribute__ ((packed)) pgid_high;\n\t__u32 cpu_id\t: 24;\t \n\t__u32 cpu_model : 16;\t \n\t__u32 tod_high;\t\t \n} __attribute__ ((packed));\n\nstruct subchannel;\nstruct chp_link;\n \nstruct css_driver {\n\tstruct css_device_id *subchannel_type;\n\tstruct device_driver drv;\n\tvoid (*irq)(struct subchannel *);\n\tint (*chp_event)(struct subchannel *, struct chp_link *, int);\n\tint (*sch_event)(struct subchannel *, int);\n\tint (*probe)(struct subchannel *);\n\tvoid (*remove)(struct subchannel *);\n\tvoid (*shutdown)(struct subchannel *);\n\tint (*settle)(void);\n};\n\n#define to_cssdriver(n) container_of(n, struct css_driver, drv)\n\nextern int css_driver_register(struct css_driver *);\nextern void css_driver_unregister(struct css_driver *);\n\nextern void css_sch_device_unregister(struct subchannel *);\nextern int css_register_subchannel(struct subchannel *);\nextern struct subchannel *css_alloc_subchannel(struct subchannel_id,\n\t\t\t\t\t       struct schib *schib);\nextern struct subchannel *get_subchannel_by_schid(struct subchannel_id);\nextern int css_init_done;\nextern int max_ssid;\nint for_each_subchannel_staged(int (*fn_known)(struct subchannel *, void *),\n\t\t\t       int (*fn_unknown)(struct subchannel_id,\n\t\t\t       void *), void *data);\nextern int for_each_subchannel(int(*fn)(struct subchannel_id, void *), void *);\nvoid css_update_ssd_info(struct subchannel *sch);\n\nstruct channel_subsystem {\n\tu8 cssid;\n\tu8 iid;\n\tbool id_valid;  \n\tstruct channel_path *chps[__MAX_CHPID + 1];\n\tstruct device device;\n\tstruct pgid global_pgid;\n\tstruct mutex mutex;\n\t \n\tint cm_enabled;\n\tvoid *cub_addr1;\n\tvoid *cub_addr2;\n\t \n\tstruct subchannel *pseudo_subchannel;\n};\n#define to_css(dev) container_of(dev, struct channel_subsystem, device)\n\nextern struct channel_subsystem *channel_subsystems[];\n\n \nstatic inline struct channel_subsystem *css_by_id(u8 cssid)\n{\n\treturn channel_subsystems[0];\n}\n\n \n#define for_each_css(css)\t\t\t\t\t\t\\\n\tfor ((css) = channel_subsystems[0]; (css); (css) = NULL)\n\n \nvoid css_schedule_eval(struct subchannel_id schid);\nvoid css_schedule_eval_all(void);\nvoid css_schedule_eval_cond(enum css_eval_cond, unsigned long delay);\nint css_complete_work(void);\n\nint sch_is_pseudo_sch(struct subchannel *);\nstruct schib;\nint css_sch_is_valid(struct schib *);\n\nextern struct workqueue_struct *cio_work_q;\nvoid css_wait_for_slow_path(void);\nvoid css_sched_sch_todo(struct subchannel *sch, enum sch_todo todo);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}