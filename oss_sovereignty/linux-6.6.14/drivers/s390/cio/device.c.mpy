{
  "module_name": "device.c",
  "hash_id": "a15353558ef8b02f61f08a7cf16b56b44baf3909757533f516e00fdc9de52a92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/device.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"cio\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched/signal.h>\n#include <linux/dma-mapping.h>\n\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n#include <asm/param.h>\t\t \n#include <asm/cmb.h>\n#include <asm/isc.h>\n\n#include \"chp.h\"\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"css.h\"\n#include \"device.h\"\n#include \"ioasm.h\"\n#include \"io_sch.h\"\n#include \"blacklist.h\"\n#include \"chsc.h\"\n\nstatic struct timer_list recovery_timer;\nstatic DEFINE_SPINLOCK(recovery_lock);\nstatic int recovery_phase;\nstatic const unsigned long recovery_delay[] = { 3, 30, 300 };\n\nstatic atomic_t ccw_device_init_count = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(ccw_device_init_wq);\nstatic struct bus_type ccw_bus_type;\n\n \n\n \nstatic int\nccw_bus_match (struct device * dev, struct device_driver * drv)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct ccw_driver *cdrv = to_ccwdrv(drv);\n\tconst struct ccw_device_id *ids = cdrv->ids, *found;\n\n\tif (!ids)\n\t\treturn 0;\n\n\tfound = ccw_device_id_match(ids, &cdev->id);\n\tif (!found)\n\t\treturn 0;\n\n\tcdev->id.driver_info = found->driver_info;\n\n\treturn 1;\n}\n\n \nstatic int snprint_alias(char *buf, size_t size,\n\t\t\t const struct ccw_device_id *id, const char *suffix)\n{\n\tint len;\n\n\tlen = snprintf(buf, size, \"ccw:t%04Xm%02X\", id->cu_type, id->cu_model);\n\tif (len > size)\n\t\treturn len;\n\tbuf += len;\n\tsize -= len;\n\n\tif (id->dev_type != 0)\n\t\tlen += snprintf(buf, size, \"dt%04Xdm%02X%s\", id->dev_type,\n\t\t\t\tid->dev_model, suffix);\n\telse\n\t\tlen += snprintf(buf, size, \"dtdm%s\", suffix);\n\n\treturn len;\n}\n\n \nstatic int ccw_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct ccw_device *cdev = to_ccwdev(dev);\n\tconst struct ccw_device_id *id = &(cdev->id);\n\tint ret;\n\tchar modalias_buf[30];\n\n\t \n\tret = add_uevent_var(env, \"CU_TYPE=%04X\", id->cu_type);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = add_uevent_var(env, \"CU_MODEL=%02X\", id->cu_model);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t \n\tret = add_uevent_var(env, \"DEV_TYPE=%04X\", id->dev_type);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = add_uevent_var(env, \"DEV_MODEL=%02X\", id->dev_model);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsnprint_alias(modalias_buf, sizeof(modalias_buf), id, \"\");\n\tret = add_uevent_var(env, \"MODALIAS=%s\", modalias_buf);\n\treturn ret;\n}\n\nstatic void io_subchannel_irq(struct subchannel *);\nstatic int io_subchannel_probe(struct subchannel *);\nstatic void io_subchannel_remove(struct subchannel *);\nstatic void io_subchannel_shutdown(struct subchannel *);\nstatic int io_subchannel_sch_event(struct subchannel *, int);\nstatic int io_subchannel_chp_event(struct subchannel *, struct chp_link *,\n\t\t\t\t   int);\nstatic void recovery_func(struct timer_list *unused);\n\nstatic struct css_device_id io_subchannel_ids[] = {\n\t{ .match_flags = 0x1, .type = SUBCHANNEL_TYPE_IO, },\n\t{   },\n};\n\nstatic int io_subchannel_settle(void)\n{\n\tint ret;\n\n\tret = wait_event_interruptible(ccw_device_init_wq,\n\t\t\t\tatomic_read(&ccw_device_init_count) == 0);\n\tif (ret)\n\t\treturn -EINTR;\n\tflush_workqueue(cio_work_q);\n\treturn 0;\n}\n\nstatic struct css_driver io_subchannel_driver = {\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"io_subchannel\",\n\t},\n\t.subchannel_type = io_subchannel_ids,\n\t.irq = io_subchannel_irq,\n\t.sch_event = io_subchannel_sch_event,\n\t.chp_event = io_subchannel_chp_event,\n\t.probe = io_subchannel_probe,\n\t.remove = io_subchannel_remove,\n\t.shutdown = io_subchannel_shutdown,\n\t.settle = io_subchannel_settle,\n};\n\nint __init io_subchannel_init(void)\n{\n\tint ret;\n\n\ttimer_setup(&recovery_timer, recovery_func, 0);\n\tret = bus_register(&ccw_bus_type);\n\tif (ret)\n\t\treturn ret;\n\tret = css_driver_register(&io_subchannel_driver);\n\tif (ret)\n\t\tbus_unregister(&ccw_bus_type);\n\n\treturn ret;\n}\n\n\n \n\nstatic ssize_t\ndevtype_show (struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct ccw_device_id *id = &(cdev->id);\n\n\tif (id->dev_type != 0)\n\t\treturn sprintf(buf, \"%04x/%02x\\n\",\n\t\t\t\tid->dev_type, id->dev_model);\n\telse\n\t\treturn sprintf(buf, \"n/a\\n\");\n}\n\nstatic ssize_t\ncutype_show (struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct ccw_device_id *id = &(cdev->id);\n\n\treturn sprintf(buf, \"%04x/%02x\\n\",\n\t\t       id->cu_type, id->cu_model);\n}\n\nstatic ssize_t\nmodalias_show (struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct ccw_device_id *id = &(cdev->id);\n\tint len;\n\n\tlen = snprint_alias(buf, PAGE_SIZE, id, \"\\n\");\n\n\treturn len > PAGE_SIZE ? PAGE_SIZE : len;\n}\n\nstatic ssize_t\nonline_show (struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\n\treturn sprintf(buf, cdev->online ? \"1\\n\" : \"0\\n\");\n}\n\nint ccw_device_is_orphan(struct ccw_device *cdev)\n{\n\treturn sch_is_pseudo_sch(to_subchannel(cdev->dev.parent));\n}\n\nstatic void ccw_device_unregister(struct ccw_device *cdev)\n{\n\tmutex_lock(&cdev->reg_mutex);\n\tif (device_is_registered(&cdev->dev)) {\n\t\t \n\t\tdevice_del(&cdev->dev);\n\t}\n\tmutex_unlock(&cdev->reg_mutex);\n\n\tif (cdev->private->flags.initialized) {\n\t\tcdev->private->flags.initialized = 0;\n\t\t \n\t\tput_device(&cdev->dev);\n\t}\n}\n\nstatic void io_subchannel_quiesce(struct subchannel *);\n\n \nint ccw_device_set_offline(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\tint ret, state;\n\n\tif (!cdev)\n\t\treturn -ENODEV;\n\tif (!cdev->online || !cdev->drv)\n\t\treturn -EINVAL;\n\n\tif (cdev->drv->set_offline) {\n\t\tret = cdev->drv->set_offline(cdev);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock_irq(cdev->ccwlock);\n\tsch = to_subchannel(cdev->dev.parent);\n\tcdev->online = 0;\n\t \n\twhile (!dev_fsm_final_state(cdev) &&\n\t       cdev->private->state != DEV_STATE_DISCONNECTED) {\n\t\tspin_unlock_irq(cdev->ccwlock);\n\t\twait_event(cdev->private->wait_q, (dev_fsm_final_state(cdev) ||\n\t\t\t   cdev->private->state == DEV_STATE_DISCONNECTED));\n\t\tspin_lock_irq(cdev->ccwlock);\n\t}\n\tdo {\n\t\tret = ccw_device_offline(cdev);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tCIO_MSG_EVENT(0, \"ccw_device_offline returned %d, device \"\n\t\t\t      \"0.%x.%04x\\n\", ret, cdev->private->dev_id.ssid,\n\t\t\t      cdev->private->dev_id.devno);\n\t\tif (ret != -EBUSY)\n\t\t\tgoto error;\n\t\tstate = cdev->private->state;\n\t\tspin_unlock_irq(cdev->ccwlock);\n\t\tio_subchannel_quiesce(sch);\n\t\tspin_lock_irq(cdev->ccwlock);\n\t\tcdev->private->state = state;\n\t} while (ret == -EBUSY);\n\tspin_unlock_irq(cdev->ccwlock);\n\twait_event(cdev->private->wait_q, (dev_fsm_final_state(cdev) ||\n\t\t   cdev->private->state == DEV_STATE_DISCONNECTED));\n\t \n\tif (cdev->private->state == DEV_STATE_BOXED) {\n\t\tpr_warn(\"%s: The device entered boxed state while being set offline\\n\",\n\t\t\tdev_name(&cdev->dev));\n\t} else if (cdev->private->state == DEV_STATE_NOT_OPER) {\n\t\tpr_warn(\"%s: The device stopped operating while being set offline\\n\",\n\t\t\tdev_name(&cdev->dev));\n\t}\n\t \n\tput_device(&cdev->dev);\n\treturn 0;\n\nerror:\n\tcdev->private->state = DEV_STATE_OFFLINE;\n\tdev_fsm_event(cdev, DEV_EVENT_NOTOPER);\n\tspin_unlock_irq(cdev->ccwlock);\n\t \n\tput_device(&cdev->dev);\n\treturn -ENODEV;\n}\n\n \nint ccw_device_set_online(struct ccw_device *cdev)\n{\n\tint ret;\n\tint ret2;\n\n\tif (!cdev)\n\t\treturn -ENODEV;\n\tif (cdev->online || !cdev->drv)\n\t\treturn -EINVAL;\n\t \n\tif (!get_device(&cdev->dev))\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tret = ccw_device_online(cdev);\n\tspin_unlock_irq(cdev->ccwlock);\n\tif (ret == 0)\n\t\twait_event(cdev->private->wait_q, dev_fsm_final_state(cdev));\n\telse {\n\t\tCIO_MSG_EVENT(0, \"ccw_device_online returned %d, \"\n\t\t\t      \"device 0.%x.%04x\\n\",\n\t\t\t      ret, cdev->private->dev_id.ssid,\n\t\t\t      cdev->private->dev_id.devno);\n\t\t \n\t\tput_device(&cdev->dev);\n\t\treturn ret;\n\t}\n\tspin_lock_irq(cdev->ccwlock);\n\t \n\tif ((cdev->private->state != DEV_STATE_ONLINE) &&\n\t    (cdev->private->state != DEV_STATE_W4SENSE)) {\n\t\tspin_unlock_irq(cdev->ccwlock);\n\t\t \n\t\tif (cdev->private->state == DEV_STATE_BOXED) {\n\t\t\tpr_warn(\"%s: Setting the device online failed because it is boxed\\n\",\n\t\t\t\tdev_name(&cdev->dev));\n\t\t} else if (cdev->private->state == DEV_STATE_NOT_OPER) {\n\t\t\tpr_warn(\"%s: Setting the device online failed because it is not operational\\n\",\n\t\t\t\tdev_name(&cdev->dev));\n\t\t}\n\t\t \n\t\tput_device(&cdev->dev);\n\t\treturn -ENODEV;\n\t}\n\tspin_unlock_irq(cdev->ccwlock);\n\tif (cdev->drv->set_online)\n\t\tret = cdev->drv->set_online(cdev);\n\tif (ret)\n\t\tgoto rollback;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tcdev->online = 1;\n\tspin_unlock_irq(cdev->ccwlock);\n\treturn 0;\n\nrollback:\n\tspin_lock_irq(cdev->ccwlock);\n\t \n\twhile (!dev_fsm_final_state(cdev) &&\n\t       cdev->private->state != DEV_STATE_DISCONNECTED) {\n\t\tspin_unlock_irq(cdev->ccwlock);\n\t\twait_event(cdev->private->wait_q, (dev_fsm_final_state(cdev) ||\n\t\t\t   cdev->private->state == DEV_STATE_DISCONNECTED));\n\t\tspin_lock_irq(cdev->ccwlock);\n\t}\n\tret2 = ccw_device_offline(cdev);\n\tif (ret2)\n\t\tgoto error;\n\tspin_unlock_irq(cdev->ccwlock);\n\twait_event(cdev->private->wait_q, (dev_fsm_final_state(cdev) ||\n\t\t   cdev->private->state == DEV_STATE_DISCONNECTED));\n\t \n\tput_device(&cdev->dev);\n\treturn ret;\n\nerror:\n\tCIO_MSG_EVENT(0, \"rollback ccw_device_offline returned %d, \"\n\t\t      \"device 0.%x.%04x\\n\",\n\t\t      ret2, cdev->private->dev_id.ssid,\n\t\t      cdev->private->dev_id.devno);\n\tcdev->private->state = DEV_STATE_OFFLINE;\n\tspin_unlock_irq(cdev->ccwlock);\n\t \n\tput_device(&cdev->dev);\n\treturn ret;\n}\n\nstatic int online_store_handle_offline(struct ccw_device *cdev)\n{\n\tif (cdev->private->state == DEV_STATE_DISCONNECTED) {\n\t\tspin_lock_irq(cdev->ccwlock);\n\t\tccw_device_sched_todo(cdev, CDEV_TODO_UNREG_EVAL);\n\t\tspin_unlock_irq(cdev->ccwlock);\n\t\treturn 0;\n\t}\n\tif (cdev->drv && cdev->drv->set_offline)\n\t\treturn ccw_device_set_offline(cdev);\n\treturn -EINVAL;\n}\n\nstatic int online_store_recog_and_online(struct ccw_device *cdev)\n{\n\t \n\tif (cdev->private->state == DEV_STATE_BOXED) {\n\t\tspin_lock_irq(cdev->ccwlock);\n\t\tccw_device_recognition(cdev);\n\t\tspin_unlock_irq(cdev->ccwlock);\n\t\twait_event(cdev->private->wait_q,\n\t\t\t   cdev->private->flags.recog_done);\n\t\tif (cdev->private->state != DEV_STATE_OFFLINE)\n\t\t\t \n\t\t\treturn -EAGAIN;\n\t}\n\tif (cdev->drv && cdev->drv->set_online)\n\t\treturn ccw_device_set_online(cdev);\n\treturn -EINVAL;\n}\n\nstatic int online_store_handle_online(struct ccw_device *cdev, int force)\n{\n\tint ret;\n\n\tret = online_store_recog_and_online(cdev);\n\tif (ret && !force)\n\t\treturn ret;\n\tif (force && cdev->private->state == DEV_STATE_BOXED) {\n\t\tret = ccw_device_stlck(cdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (cdev->id.cu_type == 0)\n\t\t\tcdev->private->state = DEV_STATE_NOT_OPER;\n\t\tret = online_store_recog_and_online(cdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t online_store (struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tint force, ret;\n\tunsigned long i;\n\n\t \n\tif (atomic_cmpxchg(&cdev->private->onoff, 0, 1) != 0)\n\t\treturn -EAGAIN;\n\t \n\tif (!dev_fsm_final_state(cdev) &&\n\t    cdev->private->state != DEV_STATE_DISCONNECTED) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\t \n\tif (work_pending(&cdev->private->todo_work)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (!strncmp(buf, \"force\\n\", count)) {\n\t\tforce = 1;\n\t\ti = 1;\n\t\tret = 0;\n\t} else {\n\t\tforce = 0;\n\t\tret = kstrtoul(buf, 16, &i);\n\t}\n\tif (ret)\n\t\tgoto out;\n\n\tdevice_lock(dev);\n\tswitch (i) {\n\tcase 0:\n\t\tret = online_store_handle_offline(cdev);\n\t\tbreak;\n\tcase 1:\n\t\tret = online_store_handle_online(cdev, force);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tdevice_unlock(dev);\n\nout:\n\tatomic_set(&cdev->private->onoff, 0);\n\treturn (ret < 0) ? ret : count;\n}\n\nstatic ssize_t\navailable_show (struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct subchannel *sch;\n\n\tif (ccw_device_is_orphan(cdev))\n\t\treturn sprintf(buf, \"no device\\n\");\n\tswitch (cdev->private->state) {\n\tcase DEV_STATE_BOXED:\n\t\treturn sprintf(buf, \"boxed\\n\");\n\tcase DEV_STATE_DISCONNECTED:\n\tcase DEV_STATE_DISCONNECTED_SENSE_ID:\n\tcase DEV_STATE_NOT_OPER:\n\t\tsch = to_subchannel(dev->parent);\n\t\tif (!sch->lpm)\n\t\t\treturn sprintf(buf, \"no path\\n\");\n\t\telse\n\t\t\treturn sprintf(buf, \"no device\\n\");\n\tdefault:\n\t\t \n\t\treturn sprintf(buf, \"good\\n\");\n\t}\n}\n\nstatic ssize_t\ninitiate_logging(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tstruct subchannel *sch = to_subchannel(dev);\n\tint rc;\n\n\trc = chsc_siosl(sch->schid);\n\tif (rc < 0) {\n\t\tpr_warn(\"Logging for subchannel 0.%x.%04x failed with errno=%d\\n\",\n\t\t\tsch->schid.ssid, sch->schid.sch_no, rc);\n\t\treturn rc;\n\t}\n\tpr_notice(\"Logging for subchannel 0.%x.%04x was triggered\\n\",\n\t\t  sch->schid.ssid, sch->schid.sch_no);\n\treturn count;\n}\n\nstatic ssize_t vpm_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct subchannel *sch = to_subchannel(dev);\n\n\treturn sprintf(buf, \"%02x\\n\", sch->vpm);\n}\n\nstatic DEVICE_ATTR_RO(devtype);\nstatic DEVICE_ATTR_RO(cutype);\nstatic DEVICE_ATTR_RO(modalias);\nstatic DEVICE_ATTR_RW(online);\nstatic DEVICE_ATTR(availability, 0444, available_show, NULL);\nstatic DEVICE_ATTR(logging, 0200, NULL, initiate_logging);\nstatic DEVICE_ATTR_RO(vpm);\n\nstatic struct attribute *io_subchannel_attrs[] = {\n\t&dev_attr_logging.attr,\n\t&dev_attr_vpm.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group io_subchannel_attr_group = {\n\t.attrs = io_subchannel_attrs,\n};\n\nstatic struct attribute * ccwdev_attrs[] = {\n\t&dev_attr_devtype.attr,\n\t&dev_attr_cutype.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_online.attr,\n\t&dev_attr_cmb_enable.attr,\n\t&dev_attr_availability.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ccwdev_attr_group = {\n\t.attrs = ccwdev_attrs,\n};\n\nstatic const struct attribute_group *ccwdev_attr_groups[] = {\n\t&ccwdev_attr_group,\n\tNULL,\n};\n\nstatic int match_dev_id(struct device *dev, const void *data)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct ccw_dev_id *dev_id = (void *)data;\n\n\treturn ccw_dev_id_is_equal(&cdev->private->dev_id, dev_id);\n}\n\n \nstruct ccw_device *get_ccwdev_by_dev_id(struct ccw_dev_id *dev_id)\n{\n\tstruct device *dev;\n\n\tdev = bus_find_device(&ccw_bus_type, NULL, dev_id, match_dev_id);\n\n\treturn dev ? to_ccwdev(dev) : NULL;\n}\nEXPORT_SYMBOL_GPL(get_ccwdev_by_dev_id);\n\nstatic void ccw_device_do_unbind_bind(struct ccw_device *cdev)\n{\n\tint ret;\n\n\tmutex_lock(&cdev->reg_mutex);\n\tif (device_is_registered(&cdev->dev)) {\n\t\tdevice_release_driver(&cdev->dev);\n\t\tret = device_attach(&cdev->dev);\n\t\tWARN_ON(ret == -ENODEV);\n\t}\n\tmutex_unlock(&cdev->reg_mutex);\n}\n\nstatic void\nccw_device_release(struct device *dev)\n{\n\tstruct ccw_device *cdev;\n\n\tcdev = to_ccwdev(dev);\n\tcio_gp_dma_free(cdev->private->dma_pool, cdev->private->dma_area,\n\t\t\tsizeof(*cdev->private->dma_area));\n\tcio_gp_dma_destroy(cdev->private->dma_pool, &cdev->dev);\n\t \n\tput_device(cdev->dev.parent);\n\tkfree(cdev->private);\n\tkfree(cdev);\n}\n\nstatic struct ccw_device * io_subchannel_allocate_dev(struct subchannel *sch)\n{\n\tstruct ccw_device *cdev;\n\tstruct gen_pool *dma_pool;\n\tint ret;\n\n\tcdev  = kzalloc(sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_cdev;\n\t}\n\tcdev->private = kzalloc(sizeof(struct ccw_device_private),\n\t\t\t\tGFP_KERNEL | GFP_DMA);\n\tif (!cdev->private) {\n\t\tret = -ENOMEM;\n\t\tgoto err_priv;\n\t}\n\n\tcdev->dev.dma_mask = sch->dev.dma_mask;\n\tret = dma_set_coherent_mask(&cdev->dev, sch->dev.coherent_dma_mask);\n\tif (ret)\n\t\tgoto err_coherent_mask;\n\n\tdma_pool = cio_gp_dma_create(&cdev->dev, 1);\n\tif (!dma_pool) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dma_pool;\n\t}\n\tcdev->private->dma_pool = dma_pool;\n\tcdev->private->dma_area = cio_gp_dma_zalloc(dma_pool, &cdev->dev,\n\t\t\t\t\tsizeof(*cdev->private->dma_area));\n\tif (!cdev->private->dma_area) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dma_area;\n\t}\n\treturn cdev;\nerr_dma_area:\n\tcio_gp_dma_destroy(dma_pool, &cdev->dev);\nerr_dma_pool:\nerr_coherent_mask:\n\tkfree(cdev->private);\nerr_priv:\n\tkfree(cdev);\nerr_cdev:\n\treturn ERR_PTR(ret);\n}\n\nstatic void ccw_device_todo(struct work_struct *work);\n\nstatic int io_subchannel_initialize_dev(struct subchannel *sch,\n\t\t\t\t\tstruct ccw_device *cdev)\n{\n\tstruct ccw_device_private *priv = cdev->private;\n\tint ret;\n\n\tpriv->cdev = cdev;\n\tpriv->int_class = IRQIO_CIO;\n\tpriv->state = DEV_STATE_NOT_OPER;\n\tpriv->dev_id.devno = sch->schib.pmcw.dev;\n\tpriv->dev_id.ssid = sch->schid.ssid;\n\n\tINIT_WORK(&priv->todo_work, ccw_device_todo);\n\tINIT_LIST_HEAD(&priv->cmb_list);\n\tinit_waitqueue_head(&priv->wait_q);\n\ttimer_setup(&priv->timer, ccw_device_timeout, 0);\n\tmutex_init(&cdev->reg_mutex);\n\n\tatomic_set(&priv->onoff, 0);\n\tcdev->ccwlock = sch->lock;\n\tcdev->dev.parent = &sch->dev;\n\tcdev->dev.release = ccw_device_release;\n\tcdev->dev.bus = &ccw_bus_type;\n\tcdev->dev.groups = ccwdev_attr_groups;\n\t \n\tdevice_initialize(&cdev->dev);\n\tret = dev_set_name(&cdev->dev, \"0.%x.%04x\", cdev->private->dev_id.ssid,\n\t\t\t   cdev->private->dev_id.devno);\n\tif (ret)\n\t\tgoto out_put;\n\tif (!get_device(&sch->dev)) {\n\t\tret = -ENODEV;\n\t\tgoto out_put;\n\t}\n\tpriv->flags.initialized = 1;\n\tspin_lock_irq(sch->lock);\n\tsch_set_cdev(sch, cdev);\n\tspin_unlock_irq(sch->lock);\n\treturn 0;\n\nout_put:\n\t \n\tput_device(&cdev->dev);\n\treturn ret;\n}\n\nstatic struct ccw_device * io_subchannel_create_ccwdev(struct subchannel *sch)\n{\n\tstruct ccw_device *cdev;\n\tint ret;\n\n\tcdev = io_subchannel_allocate_dev(sch);\n\tif (!IS_ERR(cdev)) {\n\t\tret = io_subchannel_initialize_dev(sch, cdev);\n\t\tif (ret)\n\t\t\tcdev = ERR_PTR(ret);\n\t}\n\treturn cdev;\n}\n\nstatic void io_subchannel_recog(struct ccw_device *, struct subchannel *);\n\nstatic void sch_create_and_recog_new_device(struct subchannel *sch)\n{\n\tstruct ccw_device *cdev;\n\n\t \n\tcdev = io_subchannel_create_ccwdev(sch);\n\tif (IS_ERR(cdev)) {\n\t\t \n\t\tcss_sch_device_unregister(sch);\n\t\treturn;\n\t}\n\t \n\tio_subchannel_recog(cdev, sch);\n}\n\n \nstatic void io_subchannel_register(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\tint ret, adjust_init_count = 1;\n\tunsigned long flags;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\t \n\tif (!device_is_registered(&sch->dev))\n\t\tgoto out_err;\n\tcss_update_ssd_info(sch);\n\t \n\tmutex_lock(&cdev->reg_mutex);\n\tif (device_is_registered(&cdev->dev)) {\n\t\tif (!cdev->drv) {\n\t\t\tret = device_reprobe(&cdev->dev);\n\t\t\tif (ret)\n\t\t\t\t \n\t\t\t\tCIO_MSG_EVENT(0, \"device_reprobe() returned\"\n\t\t\t\t\t      \" %d for 0.%x.%04x\\n\", ret,\n\t\t\t\t\t      cdev->private->dev_id.ssid,\n\t\t\t\t\t      cdev->private->dev_id.devno);\n\t\t}\n\t\tadjust_init_count = 0;\n\t\tgoto out;\n\t}\n\t \n\tret = device_add(&cdev->dev);\n\tif (ret) {\n\t\tCIO_MSG_EVENT(0, \"Could not register ccw dev 0.%x.%04x: %d\\n\",\n\t\t\t      cdev->private->dev_id.ssid,\n\t\t\t      cdev->private->dev_id.devno, ret);\n\t\tspin_lock_irqsave(sch->lock, flags);\n\t\tsch_set_cdev(sch, NULL);\n\t\tspin_unlock_irqrestore(sch->lock, flags);\n\t\tmutex_unlock(&cdev->reg_mutex);\n\t\t \n\t\tput_device(&cdev->dev);\n\t\tgoto out_err;\n\t}\nout:\n\tcdev->private->flags.recog_done = 1;\n\tmutex_unlock(&cdev->reg_mutex);\n\twake_up(&cdev->private->wait_q);\nout_err:\n\tif (adjust_init_count && atomic_dec_and_test(&ccw_device_init_count))\n\t\twake_up(&ccw_device_init_wq);\n}\n\n \nvoid\nio_subchannel_recog_done(struct ccw_device *cdev)\n{\n\tif (css_init_done == 0) {\n\t\tcdev->private->flags.recog_done = 1;\n\t\treturn;\n\t}\n\tswitch (cdev->private->state) {\n\tcase DEV_STATE_BOXED:\n\t\t \n\tcase DEV_STATE_NOT_OPER:\n\t\tcdev->private->flags.recog_done = 1;\n\t\t \n\t\tccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\n\t\tif (atomic_dec_and_test(&ccw_device_init_count))\n\t\t\twake_up(&ccw_device_init_wq);\n\t\tbreak;\n\tcase DEV_STATE_OFFLINE:\n\t\t \n\t\tccw_device_sched_todo(cdev, CDEV_TODO_REGISTER);\n\t\tbreak;\n\t}\n}\n\nstatic void io_subchannel_recog(struct ccw_device *cdev, struct subchannel *sch)\n{\n\t \n\tatomic_inc(&ccw_device_init_count);\n\n\t \n\tspin_lock_irq(sch->lock);\n\tccw_device_recognition(cdev);\n\tspin_unlock_irq(sch->lock);\n}\n\nstatic int ccw_device_move_to_sch(struct ccw_device *cdev,\n\t\t\t\t  struct subchannel *sch)\n{\n\tstruct subchannel *old_sch;\n\tint rc, old_enabled = 0;\n\n\told_sch = to_subchannel(cdev->dev.parent);\n\t \n\tif (!get_device(&sch->dev))\n\t\treturn -ENODEV;\n\n\tif (!sch_is_pseudo_sch(old_sch)) {\n\t\tspin_lock_irq(old_sch->lock);\n\t\told_enabled = old_sch->schib.pmcw.ena;\n\t\trc = 0;\n\t\tif (old_enabled)\n\t\t\trc = cio_disable_subchannel(old_sch);\n\t\tspin_unlock_irq(old_sch->lock);\n\t\tif (rc == -EBUSY) {\n\t\t\t \n\t\t\tput_device(&sch->dev);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tmutex_lock(&sch->reg_mutex);\n\trc = device_move(&cdev->dev, &sch->dev, DPM_ORDER_PARENT_BEFORE_DEV);\n\tmutex_unlock(&sch->reg_mutex);\n\tif (rc) {\n\t\tCIO_MSG_EVENT(0, \"device_move(0.%x.%04x,0.%x.%04x)=%d\\n\",\n\t\t\t      cdev->private->dev_id.ssid,\n\t\t\t      cdev->private->dev_id.devno, sch->schid.ssid,\n\t\t\t      sch->schib.pmcw.dev, rc);\n\t\tif (old_enabled) {\n\t\t\t \n\t\t\tspin_lock_irq(old_sch->lock);\n\t\t\tcio_enable_subchannel(old_sch, (u32)virt_to_phys(old_sch));\n\t\t\tspin_unlock_irq(old_sch->lock);\n\t\t}\n\t\t \n\t\tput_device(&sch->dev);\n\t\treturn rc;\n\t}\n\t \n\tif (!sch_is_pseudo_sch(old_sch)) {\n\t\tspin_lock_irq(old_sch->lock);\n\t\tsch_set_cdev(old_sch, NULL);\n\t\tspin_unlock_irq(old_sch->lock);\n\t\tcss_schedule_eval(old_sch->schid);\n\t}\n\t \n\tput_device(&old_sch->dev);\n\t \n\tspin_lock_irq(sch->lock);\n\tcdev->ccwlock = sch->lock;\n\tif (!sch_is_pseudo_sch(sch))\n\t\tsch_set_cdev(sch, cdev);\n\tspin_unlock_irq(sch->lock);\n\tif (!sch_is_pseudo_sch(sch))\n\t\tcss_update_ssd_info(sch);\n\treturn 0;\n}\n\nstatic int ccw_device_move_to_orph(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct channel_subsystem *css = to_css(sch->dev.parent);\n\n\treturn ccw_device_move_to_sch(cdev, css->pseudo_subchannel);\n}\n\nstatic void io_subchannel_irq(struct subchannel *sch)\n{\n\tstruct ccw_device *cdev;\n\n\tcdev = sch_get_cdev(sch);\n\n\tCIO_TRACE_EVENT(6, \"IRQ\");\n\tCIO_TRACE_EVENT(6, dev_name(&sch->dev));\n\tif (cdev)\n\t\tdev_fsm_event(cdev, DEV_EVENT_INTERRUPT);\n\telse\n\t\tinc_irq_stat(IRQIO_CIO);\n}\n\nvoid io_subchannel_init_config(struct subchannel *sch)\n{\n\tmemset(&sch->config, 0, sizeof(sch->config));\n\tsch->config.csense = 1;\n}\n\nstatic void io_subchannel_init_fields(struct subchannel *sch)\n{\n\tif (cio_is_console(sch->schid))\n\t\tsch->opm = 0xff;\n\telse\n\t\tsch->opm = chp_get_sch_opm(sch);\n\tsch->lpm = sch->schib.pmcw.pam & sch->opm;\n\tsch->isc = cio_is_console(sch->schid) ? CONSOLE_ISC : IO_SCH_ISC;\n\n\tCIO_MSG_EVENT(6, \"Detected device %04x on subchannel 0.%x.%04X\"\n\t\t      \" - PIM = %02X, PAM = %02X, POM = %02X\\n\",\n\t\t      sch->schib.pmcw.dev, sch->schid.ssid,\n\t\t      sch->schid.sch_no, sch->schib.pmcw.pim,\n\t\t      sch->schib.pmcw.pam, sch->schib.pmcw.pom);\n\n\tio_subchannel_init_config(sch);\n}\n\n \nstatic int io_subchannel_probe(struct subchannel *sch)\n{\n\tstruct io_subchannel_private *io_priv;\n\tstruct ccw_device *cdev;\n\tint rc;\n\n\tif (cio_is_console(sch->schid)) {\n\t\trc = sysfs_create_group(&sch->dev.kobj,\n\t\t\t\t\t&io_subchannel_attr_group);\n\t\tif (rc)\n\t\t\tCIO_MSG_EVENT(0, \"Failed to create io subchannel \"\n\t\t\t\t      \"attributes for subchannel \"\n\t\t\t\t      \"0.%x.%04x (rc=%d)\\n\",\n\t\t\t\t      sch->schid.ssid, sch->schid.sch_no, rc);\n\t\t \n\t\tcdev = sch_get_cdev(sch);\n\t\trc = device_add(&cdev->dev);\n\t\tif (rc) {\n\t\t\t \n\t\t\tput_device(&cdev->dev);\n\t\t\tgoto out_schedule;\n\t\t}\n\t\tif (atomic_dec_and_test(&ccw_device_init_count))\n\t\t\twake_up(&ccw_device_init_wq);\n\t\treturn 0;\n\t}\n\tio_subchannel_init_fields(sch);\n\trc = cio_commit_config(sch);\n\tif (rc)\n\t\tgoto out_schedule;\n\trc = sysfs_create_group(&sch->dev.kobj,\n\t\t\t\t&io_subchannel_attr_group);\n\tif (rc)\n\t\tgoto out_schedule;\n\t \n\tio_priv = kzalloc(sizeof(*io_priv), GFP_KERNEL | GFP_DMA);\n\tif (!io_priv)\n\t\tgoto out_schedule;\n\n\tio_priv->dma_area = dma_alloc_coherent(&sch->dev,\n\t\t\t\tsizeof(*io_priv->dma_area),\n\t\t\t\t&io_priv->dma_area_dma, GFP_KERNEL);\n\tif (!io_priv->dma_area) {\n\t\tkfree(io_priv);\n\t\tgoto out_schedule;\n\t}\n\n\tset_io_private(sch, io_priv);\n\tcss_schedule_eval(sch->schid);\n\treturn 0;\n\nout_schedule:\n\tspin_lock_irq(sch->lock);\n\tcss_sched_sch_todo(sch, SCH_TODO_UNREG);\n\tspin_unlock_irq(sch->lock);\n\treturn 0;\n}\n\nstatic void io_subchannel_remove(struct subchannel *sch)\n{\n\tstruct io_subchannel_private *io_priv = to_io_private(sch);\n\tstruct ccw_device *cdev;\n\n\tcdev = sch_get_cdev(sch);\n\tif (!cdev)\n\t\tgoto out_free;\n\n\tccw_device_unregister(cdev);\n\tspin_lock_irq(sch->lock);\n\tsch_set_cdev(sch, NULL);\n\tset_io_private(sch, NULL);\n\tspin_unlock_irq(sch->lock);\nout_free:\n\tdma_free_coherent(&sch->dev, sizeof(*io_priv->dma_area),\n\t\t\t  io_priv->dma_area, io_priv->dma_area_dma);\n\tkfree(io_priv);\n\tsysfs_remove_group(&sch->dev.kobj, &io_subchannel_attr_group);\n}\n\nstatic void io_subchannel_verify(struct subchannel *sch)\n{\n\tstruct ccw_device *cdev;\n\n\tcdev = sch_get_cdev(sch);\n\tif (cdev)\n\t\tdev_fsm_event(cdev, DEV_EVENT_VERIFY);\n\telse\n\t\tcss_schedule_eval(sch->schid);\n}\n\nstatic void io_subchannel_terminate_path(struct subchannel *sch, u8 mask)\n{\n\tstruct ccw_device *cdev;\n\n\tcdev = sch_get_cdev(sch);\n\tif (!cdev)\n\t\treturn;\n\tif (cio_update_schib(sch))\n\t\tgoto err;\n\t \n\tif (scsw_actl(&sch->schib.scsw) == 0 || sch->schib.pmcw.lpum != mask)\n\t\tgoto out;\n\tif (cdev->private->state == DEV_STATE_ONLINE) {\n\t\tccw_device_kill_io(cdev);\n\t\tgoto out;\n\t}\n\tif (cio_clear(sch))\n\t\tgoto err;\nout:\n\t \n\tdev_fsm_event(cdev, DEV_EVENT_VERIFY);\n\treturn;\n\nerr:\n\tdev_fsm_event(cdev, DEV_EVENT_NOTOPER);\n}\n\nstatic int io_subchannel_chp_event(struct subchannel *sch,\n\t\t\t\t   struct chp_link *link, int event)\n{\n\tstruct ccw_device *cdev = sch_get_cdev(sch);\n\tint mask, chpid, valid_bit;\n\tint path_event[8];\n\n\tmask = chp_ssd_get_mask(&sch->ssd_info, link);\n\tif (!mask)\n\t\treturn 0;\n\tswitch (event) {\n\tcase CHP_VARY_OFF:\n\t\tsch->opm &= ~mask;\n\t\tsch->lpm &= ~mask;\n\t\tif (cdev)\n\t\t\tcdev->private->path_gone_mask |= mask;\n\t\tio_subchannel_terminate_path(sch, mask);\n\t\tbreak;\n\tcase CHP_VARY_ON:\n\t\tsch->opm |= mask;\n\t\tsch->lpm |= mask;\n\t\tif (cdev)\n\t\t\tcdev->private->path_new_mask |= mask;\n\t\tio_subchannel_verify(sch);\n\t\tbreak;\n\tcase CHP_OFFLINE:\n\t\tif (cio_update_schib(sch))\n\t\t\treturn -ENODEV;\n\t\tif (cdev)\n\t\t\tcdev->private->path_gone_mask |= mask;\n\t\tio_subchannel_terminate_path(sch, mask);\n\t\tbreak;\n\tcase CHP_ONLINE:\n\t\tif (cio_update_schib(sch))\n\t\t\treturn -ENODEV;\n\t\tsch->lpm |= mask & sch->opm;\n\t\tif (cdev)\n\t\t\tcdev->private->path_new_mask |= mask;\n\t\tio_subchannel_verify(sch);\n\t\tbreak;\n\tcase CHP_FCES_EVENT:\n\t\t \n\t\tfor (chpid = 0, valid_bit = 0x80; chpid < 8; chpid++,\n\t\t\t\tvalid_bit >>= 1) {\n\t\t\tif (mask & valid_bit)\n\t\t\t\tpath_event[chpid] = PE_PATH_FCES_EVENT;\n\t\t\telse\n\t\t\t\tpath_event[chpid] = PE_NONE;\n\t\t}\n\t\tif (cdev && cdev->drv && cdev->drv->path_event)\n\t\t\tcdev->drv->path_event(cdev, path_event);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void io_subchannel_quiesce(struct subchannel *sch)\n{\n\tstruct ccw_device *cdev;\n\tint ret;\n\n\tspin_lock_irq(sch->lock);\n\tcdev = sch_get_cdev(sch);\n\tif (cio_is_console(sch->schid))\n\t\tgoto out_unlock;\n\tif (!sch->schib.pmcw.ena)\n\t\tgoto out_unlock;\n\tret = cio_disable_subchannel(sch);\n\tif (ret != -EBUSY)\n\t\tgoto out_unlock;\n\tif (cdev->handler)\n\t\tcdev->handler(cdev, cdev->private->intparm, ERR_PTR(-EIO));\n\twhile (ret == -EBUSY) {\n\t\tcdev->private->state = DEV_STATE_QUIESCE;\n\t\tcdev->private->iretry = 255;\n\t\tret = ccw_device_cancel_halt_clear(cdev);\n\t\tif (ret == -EBUSY) {\n\t\t\tccw_device_set_timeout(cdev, HZ/10);\n\t\t\tspin_unlock_irq(sch->lock);\n\t\t\twait_event(cdev->private->wait_q,\n\t\t\t\t   cdev->private->state != DEV_STATE_QUIESCE);\n\t\t\tspin_lock_irq(sch->lock);\n\t\t}\n\t\tret = cio_disable_subchannel(sch);\n\t}\nout_unlock:\n\tspin_unlock_irq(sch->lock);\n}\n\nstatic void io_subchannel_shutdown(struct subchannel *sch)\n{\n\tio_subchannel_quiesce(sch);\n}\n\nstatic int device_is_disconnected(struct ccw_device *cdev)\n{\n\tif (!cdev)\n\t\treturn 0;\n\treturn (cdev->private->state == DEV_STATE_DISCONNECTED ||\n\t\tcdev->private->state == DEV_STATE_DISCONNECTED_SENSE_ID);\n}\n\nstatic int recovery_check(struct device *dev, void *data)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct subchannel *sch;\n\tint *redo = data;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tswitch (cdev->private->state) {\n\tcase DEV_STATE_ONLINE:\n\t\tsch = to_subchannel(cdev->dev.parent);\n\t\tif ((sch->schib.pmcw.pam & sch->opm) == sch->vpm)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase DEV_STATE_DISCONNECTED:\n\t\tCIO_MSG_EVENT(3, \"recovery: trigger 0.%x.%04x\\n\",\n\t\t\t      cdev->private->dev_id.ssid,\n\t\t\t      cdev->private->dev_id.devno);\n\t\tdev_fsm_event(cdev, DEV_EVENT_VERIFY);\n\t\t*redo = 1;\n\t\tbreak;\n\tcase DEV_STATE_DISCONNECTED_SENSE_ID:\n\t\t*redo = 1;\n\t\tbreak;\n\t}\n\tspin_unlock_irq(cdev->ccwlock);\n\n\treturn 0;\n}\n\nstatic void recovery_work_func(struct work_struct *unused)\n{\n\tint redo = 0;\n\n\tbus_for_each_dev(&ccw_bus_type, NULL, &redo, recovery_check);\n\tif (redo) {\n\t\tspin_lock_irq(&recovery_lock);\n\t\tif (!timer_pending(&recovery_timer)) {\n\t\t\tif (recovery_phase < ARRAY_SIZE(recovery_delay) - 1)\n\t\t\t\trecovery_phase++;\n\t\t\tmod_timer(&recovery_timer, jiffies +\n\t\t\t\t  recovery_delay[recovery_phase] * HZ);\n\t\t}\n\t\tspin_unlock_irq(&recovery_lock);\n\t} else\n\t\tCIO_MSG_EVENT(3, \"recovery: end\\n\");\n}\n\nstatic DECLARE_WORK(recovery_work, recovery_work_func);\n\nstatic void recovery_func(struct timer_list *unused)\n{\n\t \n\tschedule_work(&recovery_work);\n}\n\nvoid ccw_device_schedule_recovery(void)\n{\n\tunsigned long flags;\n\n\tCIO_MSG_EVENT(3, \"recovery: schedule\\n\");\n\tspin_lock_irqsave(&recovery_lock, flags);\n\tif (!timer_pending(&recovery_timer) || (recovery_phase != 0)) {\n\t\trecovery_phase = 0;\n\t\tmod_timer(&recovery_timer, jiffies + recovery_delay[0] * HZ);\n\t}\n\tspin_unlock_irqrestore(&recovery_lock, flags);\n}\n\nstatic int purge_fn(struct device *dev, void *data)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct ccw_dev_id *id = &cdev->private->dev_id;\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\tspin_lock_irq(cdev->ccwlock);\n\tif (is_blacklisted(id->ssid, id->devno) &&\n\t    (cdev->private->state == DEV_STATE_OFFLINE) &&\n\t    (atomic_cmpxchg(&cdev->private->onoff, 0, 1) == 0)) {\n\t\tCIO_MSG_EVENT(3, \"ccw: purging 0.%x.%04x\\n\", id->ssid,\n\t\t\t      id->devno);\n\t\tccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\n\t\tcss_sched_sch_todo(sch, SCH_TODO_UNREG);\n\t\tatomic_set(&cdev->private->onoff, 0);\n\t}\n\tspin_unlock_irq(cdev->ccwlock);\n\t \n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}\n\n \nint ccw_purge_blacklisted(void)\n{\n\tCIO_MSG_EVENT(2, \"ccw: purging blacklisted devices\\n\");\n\tbus_for_each_dev(&ccw_bus_type, NULL, NULL, purge_fn);\n\treturn 0;\n}\n\nvoid ccw_device_set_disconnected(struct ccw_device *cdev)\n{\n\tif (!cdev)\n\t\treturn;\n\tccw_device_set_timeout(cdev, 0);\n\tcdev->private->flags.fake_irb = 0;\n\tcdev->private->state = DEV_STATE_DISCONNECTED;\n\tif (cdev->online)\n\t\tccw_device_schedule_recovery();\n}\n\nvoid ccw_device_set_notoper(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\tCIO_TRACE_EVENT(2, \"notoper\");\n\tCIO_TRACE_EVENT(2, dev_name(&sch->dev));\n\tccw_device_set_timeout(cdev, 0);\n\tcio_disable_subchannel(sch);\n\tcdev->private->state = DEV_STATE_NOT_OPER;\n}\n\nenum io_sch_action {\n\tIO_SCH_UNREG,\n\tIO_SCH_ORPH_UNREG,\n\tIO_SCH_UNREG_CDEV,\n\tIO_SCH_ATTACH,\n\tIO_SCH_UNREG_ATTACH,\n\tIO_SCH_ORPH_ATTACH,\n\tIO_SCH_REPROBE,\n\tIO_SCH_VERIFY,\n\tIO_SCH_DISC,\n\tIO_SCH_NOP,\n};\n\nstatic enum io_sch_action sch_get_action(struct subchannel *sch)\n{\n\tstruct ccw_device *cdev;\n\n\tcdev = sch_get_cdev(sch);\n\tif (cio_update_schib(sch)) {\n\t\t \n\t\tif (!cdev)\n\t\t\treturn IO_SCH_UNREG;\n\t\tif (ccw_device_notify(cdev, CIO_GONE) != NOTIFY_OK)\n\t\t\treturn IO_SCH_UNREG;\n\t\treturn IO_SCH_ORPH_UNREG;\n\t}\n\t \n\tif (!cdev)\n\t\treturn IO_SCH_ATTACH;\n\tif (sch->schib.pmcw.dev != cdev->private->dev_id.devno) {\n\t\tif (ccw_device_notify(cdev, CIO_GONE) != NOTIFY_OK)\n\t\t\treturn IO_SCH_UNREG_ATTACH;\n\t\treturn IO_SCH_ORPH_ATTACH;\n\t}\n\tif ((sch->schib.pmcw.pam & sch->opm) == 0) {\n\t\tif (ccw_device_notify(cdev, CIO_NO_PATH) != NOTIFY_OK)\n\t\t\treturn IO_SCH_UNREG_CDEV;\n\t\treturn IO_SCH_DISC;\n\t}\n\tif (device_is_disconnected(cdev))\n\t\treturn IO_SCH_REPROBE;\n\tif (cdev->online)\n\t\treturn IO_SCH_VERIFY;\n\tif (cdev->private->state == DEV_STATE_NOT_OPER)\n\t\treturn IO_SCH_UNREG_ATTACH;\n\treturn IO_SCH_NOP;\n}\n\n \nstatic int io_subchannel_sch_event(struct subchannel *sch, int process)\n{\n\tunsigned long flags;\n\tstruct ccw_device *cdev;\n\tstruct ccw_dev_id dev_id;\n\tenum io_sch_action action;\n\tint rc = -EAGAIN;\n\n\tspin_lock_irqsave(sch->lock, flags);\n\tif (!device_is_registered(&sch->dev))\n\t\tgoto out_unlock;\n\tif (work_pending(&sch->todo_work))\n\t\tgoto out_unlock;\n\tcdev = sch_get_cdev(sch);\n\tif (cdev && work_pending(&cdev->private->todo_work))\n\t\tgoto out_unlock;\n\taction = sch_get_action(sch);\n\tCIO_MSG_EVENT(2, \"event: sch 0.%x.%04x, process=%d, action=%d\\n\",\n\t\t      sch->schid.ssid, sch->schid.sch_no, process,\n\t\t      action);\n\t \n\tswitch (action) {\n\tcase IO_SCH_REPROBE:\n\t\t \n\t\tccw_device_trigger_reprobe(cdev);\n\t\trc = 0;\n\t\tgoto out_unlock;\n\tcase IO_SCH_VERIFY:\n\t\t \n\t\tio_subchannel_verify(sch);\n\t\trc = 0;\n\t\tgoto out_unlock;\n\tcase IO_SCH_DISC:\n\t\tccw_device_set_disconnected(cdev);\n\t\trc = 0;\n\t\tgoto out_unlock;\n\tcase IO_SCH_ORPH_UNREG:\n\tcase IO_SCH_ORPH_ATTACH:\n\t\tccw_device_set_disconnected(cdev);\n\t\tbreak;\n\tcase IO_SCH_UNREG_CDEV:\n\tcase IO_SCH_UNREG_ATTACH:\n\tcase IO_SCH_UNREG:\n\t\tif (!cdev)\n\t\t\tbreak;\n\t\tif (cdev->private->state == DEV_STATE_SENSE_ID) {\n\t\t\t \n\t\t\tdev_fsm_event(cdev, DEV_EVENT_NOTOPER);\n\t\t} else\n\t\t\tccw_device_set_notoper(cdev);\n\t\tbreak;\n\tcase IO_SCH_NOP:\n\t\trc = 0;\n\t\tgoto out_unlock;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(sch->lock, flags);\n\t \n\tif (!process)\n\t\tgoto out;\n\t \n\tswitch (action) {\n\tcase IO_SCH_ORPH_UNREG:\n\tcase IO_SCH_ORPH_ATTACH:\n\t\t \n\t\trc = ccw_device_move_to_orph(cdev);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase IO_SCH_UNREG_CDEV:\n\tcase IO_SCH_UNREG_ATTACH:\n\t\tspin_lock_irqsave(sch->lock, flags);\n\t\tsch_set_cdev(sch, NULL);\n\t\tspin_unlock_irqrestore(sch->lock, flags);\n\t\t \n\t\tccw_device_unregister(cdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tswitch (action) {\n\tcase IO_SCH_ORPH_UNREG:\n\tcase IO_SCH_UNREG:\n\t\tcss_sch_device_unregister(sch);\n\t\tbreak;\n\tcase IO_SCH_ORPH_ATTACH:\n\tcase IO_SCH_UNREG_ATTACH:\n\tcase IO_SCH_ATTACH:\n\t\tdev_id.ssid = sch->schid.ssid;\n\t\tdev_id.devno = sch->schib.pmcw.dev;\n\t\tcdev = get_ccwdev_by_dev_id(&dev_id);\n\t\tif (!cdev) {\n\t\t\tsch_create_and_recog_new_device(sch);\n\t\t\tbreak;\n\t\t}\n\t\trc = ccw_device_move_to_sch(cdev, sch);\n\t\tif (rc) {\n\t\t\t \n\t\t\tput_device(&cdev->dev);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock_irqsave(sch->lock, flags);\n\t\tccw_device_trigger_reprobe(cdev);\n\t\tspin_unlock_irqrestore(sch->lock, flags);\n\t\t \n\t\tput_device(&cdev->dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n\nout_unlock:\n\tspin_unlock_irqrestore(sch->lock, flags);\nout:\n\treturn rc;\n}\n\nstatic void ccw_device_set_int_class(struct ccw_device *cdev)\n{\n\tstruct ccw_driver *cdrv = cdev->drv;\n\n\t \n\tif (cdrv->int_class != 0)\n\t\tcdev->private->int_class = cdrv->int_class;\n\telse\n\t\tcdev->private->int_class = IRQIO_CIO;\n}\n\n#ifdef CONFIG_CCW_CONSOLE\nint __init ccw_device_enable_console(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tint rc;\n\n\tif (!cdev->drv || !cdev->handler)\n\t\treturn -EINVAL;\n\n\tio_subchannel_init_fields(sch);\n\trc = cio_commit_config(sch);\n\tif (rc)\n\t\treturn rc;\n\tsch->driver = &io_subchannel_driver;\n\tio_subchannel_recog(cdev, sch);\n\t \n\tspin_lock_irq(cdev->ccwlock);\n\twhile (!dev_fsm_final_state(cdev))\n\t\tccw_device_wait_idle(cdev);\n\n\t \n\tget_device(&cdev->dev);\n\trc = ccw_device_online(cdev);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\twhile (!dev_fsm_final_state(cdev))\n\t\tccw_device_wait_idle(cdev);\n\n\tif (cdev->private->state == DEV_STATE_ONLINE)\n\t\tcdev->online = 1;\n\telse\n\t\trc = -EIO;\nout_unlock:\n\tspin_unlock_irq(cdev->ccwlock);\n\tif (rc)  \n\t\tput_device(&cdev->dev);\n\treturn rc;\n}\n\nstruct ccw_device * __init ccw_device_create_console(struct ccw_driver *drv)\n{\n\tstruct io_subchannel_private *io_priv;\n\tstruct ccw_device *cdev;\n\tstruct subchannel *sch;\n\n\tsch = cio_probe_console();\n\tif (IS_ERR(sch))\n\t\treturn ERR_CAST(sch);\n\n\tio_priv = kzalloc(sizeof(*io_priv), GFP_KERNEL | GFP_DMA);\n\tif (!io_priv)\n\t\tgoto err_priv;\n\tio_priv->dma_area = dma_alloc_coherent(&sch->dev,\n\t\t\t\tsizeof(*io_priv->dma_area),\n\t\t\t\t&io_priv->dma_area_dma, GFP_KERNEL);\n\tif (!io_priv->dma_area)\n\t\tgoto err_dma_area;\n\tset_io_private(sch, io_priv);\n\tcdev = io_subchannel_create_ccwdev(sch);\n\tif (IS_ERR(cdev)) {\n\t\tdma_free_coherent(&sch->dev, sizeof(*io_priv->dma_area),\n\t\t\t\t  io_priv->dma_area, io_priv->dma_area_dma);\n\t\tset_io_private(sch, NULL);\n\t\tput_device(&sch->dev);\n\t\tkfree(io_priv);\n\t\treturn cdev;\n\t}\n\tcdev->drv = drv;\n\tccw_device_set_int_class(cdev);\n\treturn cdev;\n\nerr_dma_area:\n\tkfree(io_priv);\nerr_priv:\n\tput_device(&sch->dev);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nvoid __init ccw_device_destroy_console(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct io_subchannel_private *io_priv = to_io_private(sch);\n\n\tset_io_private(sch, NULL);\n\tdma_free_coherent(&sch->dev, sizeof(*io_priv->dma_area),\n\t\t\t  io_priv->dma_area, io_priv->dma_area_dma);\n\tput_device(&sch->dev);\n\tput_device(&cdev->dev);\n\tkfree(io_priv);\n}\n\n \nvoid ccw_device_wait_idle(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\twhile (1) {\n\t\tcio_tsch(sch);\n\t\tif (sch->schib.scsw.cmd.actl == 0)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n}\n#endif\n\n \nstruct ccw_device *get_ccwdev_by_busid(struct ccw_driver *cdrv,\n\t\t\t\t       const char *bus_id)\n{\n\tstruct device *dev;\n\n\tdev = driver_find_device_by_name(&cdrv->driver, bus_id);\n\n\treturn dev ? to_ccwdev(dev) : NULL;\n}\n\n \n\n \nstatic int\nccw_device_probe (struct device *dev)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct ccw_driver *cdrv = to_ccwdrv(dev->driver);\n\tint ret;\n\n\tcdev->drv = cdrv;  \n\tccw_device_set_int_class(cdev);\n\tret = cdrv->probe ? cdrv->probe(cdev) : -ENODEV;\n\tif (ret) {\n\t\tcdev->drv = NULL;\n\t\tcdev->private->int_class = IRQIO_CIO;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ccw_device_remove(struct device *dev)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct ccw_driver *cdrv = cdev->drv;\n\tstruct subchannel *sch;\n\tint ret;\n\n\tif (cdrv->remove)\n\t\tcdrv->remove(cdev);\n\n\tspin_lock_irq(cdev->ccwlock);\n\tif (cdev->online) {\n\t\tcdev->online = 0;\n\t\tret = ccw_device_offline(cdev);\n\t\tspin_unlock_irq(cdev->ccwlock);\n\t\tif (ret == 0)\n\t\t\twait_event(cdev->private->wait_q,\n\t\t\t\t   dev_fsm_final_state(cdev));\n\t\telse\n\t\t\tCIO_MSG_EVENT(0, \"ccw_device_offline returned %d, \"\n\t\t\t\t      \"device 0.%x.%04x\\n\",\n\t\t\t\t      ret, cdev->private->dev_id.ssid,\n\t\t\t\t      cdev->private->dev_id.devno);\n\t\t \n\t\tput_device(&cdev->dev);\n\t\tspin_lock_irq(cdev->ccwlock);\n\t}\n\tccw_device_set_timeout(cdev, 0);\n\tcdev->drv = NULL;\n\tcdev->private->int_class = IRQIO_CIO;\n\tsch = to_subchannel(cdev->dev.parent);\n\tspin_unlock_irq(cdev->ccwlock);\n\tio_subchannel_quiesce(sch);\n\t__disable_cmf(cdev);\n}\n\nstatic void ccw_device_shutdown(struct device *dev)\n{\n\tstruct ccw_device *cdev;\n\n\tcdev = to_ccwdev(dev);\n\tif (cdev->drv && cdev->drv->shutdown)\n\t\tcdev->drv->shutdown(cdev);\n\t__disable_cmf(cdev);\n}\n\nstatic struct bus_type ccw_bus_type = {\n\t.name   = \"ccw\",\n\t.match  = ccw_bus_match,\n\t.uevent = ccw_uevent,\n\t.probe  = ccw_device_probe,\n\t.remove = ccw_device_remove,\n\t.shutdown = ccw_device_shutdown,\n};\n\n \nint ccw_driver_register(struct ccw_driver *cdriver)\n{\n\tstruct device_driver *drv = &cdriver->driver;\n\n\tdrv->bus = &ccw_bus_type;\n\n\treturn driver_register(drv);\n}\n\n \nvoid ccw_driver_unregister(struct ccw_driver *cdriver)\n{\n\tdriver_unregister(&cdriver->driver);\n}\n\nstatic void ccw_device_todo(struct work_struct *work)\n{\n\tstruct ccw_device_private *priv;\n\tstruct ccw_device *cdev;\n\tstruct subchannel *sch;\n\tenum cdev_todo todo;\n\n\tpriv = container_of(work, struct ccw_device_private, todo_work);\n\tcdev = priv->cdev;\n\tsch = to_subchannel(cdev->dev.parent);\n\t \n\tspin_lock_irq(cdev->ccwlock);\n\ttodo = priv->todo;\n\tpriv->todo = CDEV_TODO_NOTHING;\n\tCIO_MSG_EVENT(4, \"cdev_todo: cdev=0.%x.%04x todo=%d\\n\",\n\t\t      priv->dev_id.ssid, priv->dev_id.devno, todo);\n\tspin_unlock_irq(cdev->ccwlock);\n\t \n\tswitch (todo) {\n\tcase CDEV_TODO_ENABLE_CMF:\n\t\tcmf_reenable(cdev);\n\t\tbreak;\n\tcase CDEV_TODO_REBIND:\n\t\tccw_device_do_unbind_bind(cdev);\n\t\tbreak;\n\tcase CDEV_TODO_REGISTER:\n\t\tio_subchannel_register(cdev);\n\t\tbreak;\n\tcase CDEV_TODO_UNREG_EVAL:\n\t\tif (!sch_is_pseudo_sch(sch))\n\t\t\tcss_schedule_eval(sch->schid);\n\t\tfallthrough;\n\tcase CDEV_TODO_UNREG:\n\t\tspin_lock_irq(sch->lock);\n\t\tsch_set_cdev(sch, NULL);\n\t\tspin_unlock_irq(sch->lock);\n\t\tccw_device_unregister(cdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tput_device(&cdev->dev);\n}\n\n \nvoid ccw_device_sched_todo(struct ccw_device *cdev, enum cdev_todo todo)\n{\n\tCIO_MSG_EVENT(4, \"cdev_todo: sched cdev=0.%x.%04x todo=%d\\n\",\n\t\t      cdev->private->dev_id.ssid, cdev->private->dev_id.devno,\n\t\t      todo);\n\tif (cdev->private->todo >= todo)\n\t\treturn;\n\tcdev->private->todo = todo;\n\t \n\tif (!get_device(&cdev->dev))\n\t\treturn;\n\tif (!queue_work(cio_work_q, &cdev->private->todo_work)) {\n\t\t \n\t\tput_device(&cdev->dev);\n\t}\n}\n\n \nint ccw_device_siosl(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\treturn chsc_siosl(sch->schid);\n}\nEXPORT_SYMBOL_GPL(ccw_device_siosl);\n\nEXPORT_SYMBOL(ccw_device_set_online);\nEXPORT_SYMBOL(ccw_device_set_offline);\nEXPORT_SYMBOL(ccw_driver_register);\nEXPORT_SYMBOL(ccw_driver_unregister);\nEXPORT_SYMBOL(get_ccwdev_by_busid);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}