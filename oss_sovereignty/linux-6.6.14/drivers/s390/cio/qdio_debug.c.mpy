{
  "module_name": "qdio_debug.c",
  "hash_id": "e232aa7838038780a14a2e117fbbe04b64c10d8c37771bcbf5159250733eac7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/qdio_debug.c",
  "human_readable_source": "\n \n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <asm/debug.h>\n#include \"qdio_debug.h\"\n#include \"qdio.h\"\n\ndebug_info_t *qdio_dbf_setup;\ndebug_info_t *qdio_dbf_error;\n\nstatic struct dentry *debugfs_root;\n#define QDIO_DEBUGFS_NAME_LEN\t10\n#define QDIO_DBF_NAME_LEN\t20\n\nstruct qdio_dbf_entry {\n\tchar dbf_name[QDIO_DBF_NAME_LEN];\n\tdebug_info_t *dbf_info;\n\tstruct list_head dbf_list;\n};\n\nstatic LIST_HEAD(qdio_dbf_list);\nstatic DEFINE_MUTEX(qdio_dbf_list_mutex);\n\nstatic debug_info_t *qdio_get_dbf_entry(char *name)\n{\n\tstruct qdio_dbf_entry *entry;\n\tdebug_info_t *rc = NULL;\n\n\tmutex_lock(&qdio_dbf_list_mutex);\n\tlist_for_each_entry(entry, &qdio_dbf_list, dbf_list) {\n\t\tif (strcmp(entry->dbf_name, name) == 0) {\n\t\t\trc = entry->dbf_info;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&qdio_dbf_list_mutex);\n\treturn rc;\n}\n\nstatic void qdio_clear_dbf_list(void)\n{\n\tstruct qdio_dbf_entry *entry, *tmp;\n\n\tmutex_lock(&qdio_dbf_list_mutex);\n\tlist_for_each_entry_safe(entry, tmp, &qdio_dbf_list, dbf_list) {\n\t\tlist_del(&entry->dbf_list);\n\t\tdebug_unregister(entry->dbf_info);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&qdio_dbf_list_mutex);\n}\n\nint qdio_allocate_dbf(struct qdio_irq *irq_ptr)\n{\n\tchar text[QDIO_DBF_NAME_LEN];\n\tstruct qdio_dbf_entry *new_entry;\n\n\tDBF_EVENT(\"irq:%8lx\", (unsigned long)irq_ptr);\n\n\t \n\tsnprintf(text, QDIO_DBF_NAME_LEN, \"qdio_%s\",\n\t\t dev_name(&irq_ptr->cdev->dev));\n\tirq_ptr->debug_area = qdio_get_dbf_entry(text);\n\tif (irq_ptr->debug_area)\n\t\tDBF_DEV_EVENT(DBF_ERR, irq_ptr, \"dbf reused\");\n\telse {\n\t\tirq_ptr->debug_area = debug_register(text, 2, 1, 16);\n\t\tif (!irq_ptr->debug_area)\n\t\t\treturn -ENOMEM;\n\t\tif (debug_register_view(irq_ptr->debug_area,\n\t\t\t\t\t\t&debug_hex_ascii_view)) {\n\t\t\tdebug_unregister(irq_ptr->debug_area);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdebug_set_level(irq_ptr->debug_area, DBF_WARN);\n\t\tDBF_DEV_EVENT(DBF_ERR, irq_ptr, \"dbf created\");\n\t\tnew_entry = kzalloc(sizeof(struct qdio_dbf_entry), GFP_KERNEL);\n\t\tif (!new_entry) {\n\t\t\tdebug_unregister(irq_ptr->debug_area);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstrscpy(new_entry->dbf_name, text, QDIO_DBF_NAME_LEN);\n\t\tnew_entry->dbf_info = irq_ptr->debug_area;\n\t\tmutex_lock(&qdio_dbf_list_mutex);\n\t\tlist_add(&new_entry->dbf_list, &qdio_dbf_list);\n\t\tmutex_unlock(&qdio_dbf_list_mutex);\n\t}\n\treturn 0;\n}\n\nstatic int qstat_show(struct seq_file *m, void *v)\n{\n\tunsigned char state;\n\tstruct qdio_q *q = m->private;\n\tint i;\n\n\tif (!q)\n\t\treturn 0;\n\n\tseq_printf(m, \"Timestamp: %llx\\n\", q->timestamp);\n\tseq_printf(m, \"Last Data IRQ: %llx  Last AI: %llx\\n\",\n\t\t   q->irq_ptr->last_data_irq_time, last_ai_time);\n\tseq_printf(m, \"nr_used: %d  ftc: %d\\n\",\n\t\t   atomic_read(&q->nr_buf_used), q->first_to_check);\n\tif (q->is_input_q) {\n\t\tseq_printf(m, \"batch start: %u  batch count: %u\\n\",\n\t\t\t   q->u.in.batch_start, q->u.in.batch_count);\n\t\tseq_printf(m, \"DSCI: %x   IRQs disabled: %u\\n\",\n\t\t\t   *(u8 *)q->irq_ptr->dsci,\n\t\t\t   test_bit(QDIO_IRQ_DISABLED,\n\t\t\t\t    &q->irq_ptr->poll_state));\n\t}\n\tseq_printf(m, \"SBAL states:\\n\");\n\tseq_printf(m, \"|0      |8      |16     |24     |32     |40     |48     |56  63|\\n\");\n\n\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; i++) {\n\t\tdebug_get_buf_state(q, i, &state);\n\t\tswitch (state) {\n\t\tcase SLSB_P_INPUT_NOT_INIT:\n\t\tcase SLSB_P_OUTPUT_NOT_INIT:\n\t\t\tseq_printf(m, \"N\");\n\t\t\tbreak;\n\t\tcase SLSB_P_OUTPUT_PENDING:\n\t\t\tseq_printf(m, \"P\");\n\t\t\tbreak;\n\t\tcase SLSB_P_INPUT_PRIMED:\n\t\tcase SLSB_CU_OUTPUT_PRIMED:\n\t\t\tseq_printf(m, \"+\");\n\t\t\tbreak;\n\t\tcase SLSB_P_INPUT_ACK:\n\t\t\tseq_printf(m, \"A\");\n\t\t\tbreak;\n\t\tcase SLSB_P_INPUT_ERROR:\n\t\tcase SLSB_P_OUTPUT_ERROR:\n\t\t\tseq_printf(m, \"x\");\n\t\t\tbreak;\n\t\tcase SLSB_CU_INPUT_EMPTY:\n\t\tcase SLSB_P_OUTPUT_EMPTY:\n\t\t\tseq_printf(m, \"-\");\n\t\t\tbreak;\n\t\tcase SLSB_P_INPUT_HALTED:\n\t\tcase SLSB_P_OUTPUT_HALTED:\n\t\t\tseq_printf(m, \".\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m, \"?\");\n\t\t}\n\t\tif (i == 63)\n\t\t\tseq_printf(m, \"\\n\");\n\t}\n\tseq_printf(m, \"\\n\");\n\tseq_printf(m, \"|64     |72     |80     |88     |96     |104    |112    |   127|\\n\");\n\n\tseq_printf(m, \"\\nSBAL statistics:\");\n\tif (!q->irq_ptr->perf_stat_enabled) {\n\t\tseq_printf(m, \" disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"\\n1          2..        4..        8..        \"\n\t\t   \"16..       32..       64..       128\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(q->q_stats.nr_sbals); i++)\n\t\tseq_printf(m, \"%-10u \", q->q_stats.nr_sbals[i]);\n\tseq_printf(m, \"\\nError      NOP        Total\\n%-10u %-10u %-10u\\n\\n\",\n\t\t   q->q_stats.nr_sbal_error, q->q_stats.nr_sbal_nop,\n\t\t   q->q_stats.nr_sbal_total);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(qstat);\n\nstatic int ssqd_show(struct seq_file *m, void *v)\n{\n\tstruct ccw_device *cdev = m->private;\n\tstruct qdio_ssqd_desc ssqd;\n\tint rc;\n\n\trc = qdio_get_ssqd_desc(cdev, &ssqd);\n\tif (rc)\n\t\treturn rc;\n\n\tseq_hex_dump(m, \"\", DUMP_PREFIX_NONE, 16, 4, &ssqd, sizeof(ssqd),\n\t\t     false);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(ssqd);\n\nstatic char *qperf_names[] = {\n\t\"Assumed adapter interrupts\",\n\t\"QDIO interrupts\",\n\t\"SIGA read\",\n\t\"SIGA write\",\n\t\"SIGA sync\",\n\t\"Inbound calls\",\n\t\"Inbound stop_polling\",\n\t\"Inbound queue full\",\n\t\"Outbound calls\",\n\t\"Outbound queue full\",\n\t\"Outbound fast_requeue\",\n\t\"Outbound target_full\",\n\t\"QEBSM eqbs\",\n\t\"QEBSM eqbs partial\",\n\t\"QEBSM sqbs\",\n\t\"QEBSM sqbs partial\",\n\t\"Discarded interrupts\"\n};\n\nstatic int qperf_show(struct seq_file *m, void *v)\n{\n\tstruct qdio_irq *irq_ptr = m->private;\n\tunsigned int *stat;\n\tint i;\n\n\tif (!irq_ptr)\n\t\treturn 0;\n\tif (!irq_ptr->perf_stat_enabled) {\n\t\tseq_printf(m, \"disabled\\n\");\n\t\treturn 0;\n\t}\n\tstat = (unsigned int *)&irq_ptr->perf_stat;\n\n\tfor (i = 0; i < ARRAY_SIZE(qperf_names); i++)\n\t\tseq_printf(m, \"%26s:\\t%u\\n\",\n\t\t\t   qperf_names[i], *(stat + i));\n\treturn 0;\n}\n\nstatic ssize_t qperf_seq_write(struct file *file, const char __user *ubuf,\n\t\t\t       size_t count, loff_t *off)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct qdio_irq *irq_ptr = seq->private;\n\tstruct qdio_q *q;\n\tunsigned long val;\n\tint ret, i;\n\n\tif (!irq_ptr)\n\t\treturn 0;\n\n\tret = kstrtoul_from_user(ubuf, count, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase 0:\n\t\tirq_ptr->perf_stat_enabled = 0;\n\t\tmemset(&irq_ptr->perf_stat, 0, sizeof(irq_ptr->perf_stat));\n\t\tfor_each_input_queue(irq_ptr, q, i)\n\t\t\tmemset(&q->q_stats, 0, sizeof(q->q_stats));\n\t\tfor_each_output_queue(irq_ptr, q, i)\n\t\t\tmemset(&q->q_stats, 0, sizeof(q->q_stats));\n\t\tbreak;\n\tcase 1:\n\t\tirq_ptr->perf_stat_enabled = 1;\n\t\tbreak;\n\t}\n\treturn count;\n}\n\nstatic int qperf_seq_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, qperf_show,\n\t\t\t   file_inode(filp)->i_private);\n}\n\nstatic const struct file_operations debugfs_perf_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open\t = qperf_seq_open,\n\t.read\t = seq_read,\n\t.write\t = qperf_seq_write,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void setup_debugfs_entry(struct dentry *parent, struct qdio_q *q)\n{\n\tchar name[QDIO_DEBUGFS_NAME_LEN];\n\n\tsnprintf(name, QDIO_DEBUGFS_NAME_LEN, \"%s_%d\",\n\t\t q->is_input_q ? \"input\" : \"output\",\n\t\t q->nr);\n\tdebugfs_create_file(name, 0444, parent, q, &qstat_fops);\n}\n\nvoid qdio_setup_debug_entries(struct qdio_irq *irq_ptr)\n{\n\tstruct qdio_q *q;\n\tint i;\n\n\tirq_ptr->debugfs_dev = debugfs_create_dir(dev_name(&irq_ptr->cdev->dev),\n\t\t\t\t\t\t  debugfs_root);\n\tdebugfs_create_file(\"statistics\", S_IFREG | S_IRUGO | S_IWUSR,\n\t\t\t    irq_ptr->debugfs_dev, irq_ptr, &debugfs_perf_fops);\n\tdebugfs_create_file(\"ssqd\", 0444, irq_ptr->debugfs_dev, irq_ptr->cdev,\n\t\t\t    &ssqd_fops);\n\n\tfor_each_input_queue(irq_ptr, q, i)\n\t\tsetup_debugfs_entry(irq_ptr->debugfs_dev, q);\n\tfor_each_output_queue(irq_ptr, q, i)\n\t\tsetup_debugfs_entry(irq_ptr->debugfs_dev, q);\n}\n\nvoid qdio_shutdown_debug_entries(struct qdio_irq *irq_ptr)\n{\n\tdebugfs_remove_recursive(irq_ptr->debugfs_dev);\n}\n\nint __init qdio_debug_init(void)\n{\n\tdebugfs_root = debugfs_create_dir(\"qdio\", NULL);\n\n\tqdio_dbf_setup = debug_register(\"qdio_setup\", 16, 1, 16);\n\tdebug_register_view(qdio_dbf_setup, &debug_hex_ascii_view);\n\tdebug_set_level(qdio_dbf_setup, DBF_INFO);\n\tDBF_EVENT(\"dbf created\\n\");\n\n\tqdio_dbf_error = debug_register(\"qdio_error\", 4, 1, 16);\n\tdebug_register_view(qdio_dbf_error, &debug_hex_ascii_view);\n\tdebug_set_level(qdio_dbf_error, DBF_INFO);\n\tDBF_ERROR(\"dbf created\\n\");\n\treturn 0;\n}\n\nvoid qdio_debug_exit(void)\n{\n\tqdio_clear_dbf_list();\n\tdebugfs_remove_recursive(debugfs_root);\n\tdebug_unregister(qdio_dbf_setup);\n\tdebug_unregister(qdio_dbf_error);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}