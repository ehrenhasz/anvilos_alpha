{
  "module_name": "device_id.c",
  "hash_id": "49d3b4df503156fc4ab3b762a92b456c8d75b9cc4578a63897b7474da062c83a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/device_id.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <asm/ccwdev.h>\n#include <asm/setup.h>\n#include <asm/cio.h>\n#include <asm/diag.h>\n\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"device.h\"\n#include \"io_sch.h\"\n\n#define SENSE_ID_RETRIES\t256\n#define SENSE_ID_TIMEOUT\t(10 * HZ)\n#define SENSE_ID_MIN_LEN\t4\n#define SENSE_ID_BASIC_LEN\t7\n\n \nstatic int diag210_to_senseid(struct senseid *senseid, struct diag210 *diag)\n{\n\tstatic struct {\n\t\tint class, type, cu_type;\n\t} vm_devices[] = {\n\t\t{ 0x08, 0x01, 0x3480 },\n\t\t{ 0x08, 0x02, 0x3430 },\n\t\t{ 0x08, 0x10, 0x3420 },\n\t\t{ 0x08, 0x42, 0x3424 },\n\t\t{ 0x08, 0x44, 0x9348 },\n\t\t{ 0x08, 0x81, 0x3490 },\n\t\t{ 0x08, 0x82, 0x3422 },\n\t\t{ 0x10, 0x41, 0x1403 },\n\t\t{ 0x10, 0x42, 0x3211 },\n\t\t{ 0x10, 0x43, 0x3203 },\n\t\t{ 0x10, 0x45, 0x3800 },\n\t\t{ 0x10, 0x47, 0x3262 },\n\t\t{ 0x10, 0x48, 0x3820 },\n\t\t{ 0x10, 0x49, 0x3800 },\n\t\t{ 0x10, 0x4a, 0x4245 },\n\t\t{ 0x10, 0x4b, 0x4248 },\n\t\t{ 0x10, 0x4d, 0x3800 },\n\t\t{ 0x10, 0x4e, 0x3820 },\n\t\t{ 0x10, 0x4f, 0x3820 },\n\t\t{ 0x10, 0x82, 0x2540 },\n\t\t{ 0x10, 0x84, 0x3525 },\n\t\t{ 0x20, 0x81, 0x2501 },\n\t\t{ 0x20, 0x82, 0x2540 },\n\t\t{ 0x20, 0x84, 0x3505 },\n\t\t{ 0x40, 0x01, 0x3278 },\n\t\t{ 0x40, 0x04, 0x3277 },\n\t\t{ 0x40, 0x80, 0x2250 },\n\t\t{ 0x40, 0xc0, 0x5080 },\n\t\t{ 0x80, 0x00, 0x3215 },\n\t};\n\tint i;\n\n\t \n\tif (diag->vrdcvcla == 0x02 && diag->vrdcvtyp == 0x20) {\n\t\tsenseid->cu_type = 0x3088;\n\t\tsenseid->cu_model = 0x60;\n\t\tsenseid->reserved = 0xff;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(vm_devices); i++) {\n\t\tif (diag->vrdcvcla == vm_devices[i].class &&\n\t\t    diag->vrdcvtyp == vm_devices[i].type) {\n\t\t\tsenseid->cu_type = vm_devices[i].cu_type;\n\t\t\tsenseid->reserved = 0xff;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int diag210_get_dev_info(struct ccw_device *cdev)\n{\n\tstruct ccw_dev_id *dev_id = &cdev->private->dev_id;\n\tstruct senseid *senseid = &cdev->private->dma_area->senseid;\n\tstruct diag210 diag_data;\n\tint rc;\n\n\tif (dev_id->ssid != 0)\n\t\treturn -ENODEV;\n\tmemset(&diag_data, 0, sizeof(diag_data));\n\tdiag_data.vrdcdvno\t= dev_id->devno;\n\tdiag_data.vrdclen\t= sizeof(diag_data);\n\trc = diag210(&diag_data);\n\tCIO_TRACE_EVENT(4, \"diag210\");\n\tCIO_HEX_EVENT(4, &rc, sizeof(rc));\n\tCIO_HEX_EVENT(4, &diag_data, sizeof(diag_data));\n\tif (rc != 0 && rc != 2)\n\t\tgoto err_failed;\n\tif (diag210_to_senseid(senseid, &diag_data))\n\t\tgoto err_unknown;\n\treturn 0;\n\nerr_unknown:\n\tCIO_MSG_EVENT(0, \"snsid: device 0.%x.%04x: unknown diag210 data\\n\",\n\t\t      dev_id->ssid, dev_id->devno);\n\treturn -ENODEV;\nerr_failed:\n\tCIO_MSG_EVENT(0, \"snsid: device 0.%x.%04x: diag210 failed (rc=%d)\\n\",\n\t\t      dev_id->ssid, dev_id->devno, rc);\n\treturn -ENODEV;\n}\n\n \nstatic void snsid_init(struct ccw_device *cdev)\n{\n\tcdev->private->flags.esid = 0;\n\n\tmemset(&cdev->private->dma_area->senseid, 0,\n\t       sizeof(cdev->private->dma_area->senseid));\n\tcdev->private->dma_area->senseid.cu_type = 0xffff;\n}\n\n \nstatic int snsid_check(struct ccw_device *cdev, void *data)\n{\n\tstruct cmd_scsw *scsw = &cdev->private->dma_area->irb.scsw.cmd;\n\tint len = sizeof(struct senseid) - scsw->count;\n\n\t \n\tif (len < SENSE_ID_MIN_LEN)\n\t\tgoto out_restart;\n\tif (cdev->private->dma_area->senseid.cu_type == 0xffff)\n\t\tgoto out_restart;\n\t \n\tif (cdev->private->dma_area->senseid.reserved != 0xff)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (len > SENSE_ID_BASIC_LEN)\n\t\tcdev->private->flags.esid = 1;\n\treturn 0;\n\nout_restart:\n\tsnsid_init(cdev);\n\treturn -EAGAIN;\n}\n\n \nstatic void snsid_callback(struct ccw_device *cdev, void *data, int rc)\n{\n\tstruct ccw_dev_id *id = &cdev->private->dev_id;\n\tstruct senseid *senseid = &cdev->private->dma_area->senseid;\n\tint vm = 0;\n\n\tif (rc && MACHINE_IS_VM) {\n\t\t \n\t\tsnsid_init(cdev);\n\t\tif (diag210_get_dev_info(cdev) == 0) {\n\t\t\trc = 0;\n\t\t\tvm = 1;\n\t\t}\n\t}\n\tCIO_MSG_EVENT(2, \"snsid: device 0.%x.%04x: rc=%d %04x/%02x \"\n\t\t      \"%04x/%02x%s\\n\", id->ssid, id->devno, rc,\n\t\t      senseid->cu_type, senseid->cu_model, senseid->dev_type,\n\t\t      senseid->dev_model, vm ? \" (diag210)\" : \"\");\n\tccw_device_sense_id_done(cdev, rc);\n}\n\n \nvoid ccw_device_sense_id_start(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct ccw_request *req = &cdev->private->req;\n\tstruct ccw1 *cp = cdev->private->dma_area->iccws;\n\n\tCIO_TRACE_EVENT(4, \"snsid\");\n\tCIO_HEX_EVENT(4, &cdev->private->dev_id, sizeof(cdev->private->dev_id));\n\t \n\tsnsid_init(cdev);\n\t \n\tcp->cmd_code\t= CCW_CMD_SENSE_ID;\n\tcp->cda\t\t= (u32)virt_to_phys(&cdev->private->dma_area->senseid);\n\tcp->count\t= sizeof(struct senseid);\n\tcp->flags\t= CCW_FLAG_SLI;\n\t \n\tmemset(req, 0, sizeof(*req));\n\treq->cp\t\t= cp;\n\treq->timeout\t= SENSE_ID_TIMEOUT;\n\treq->maxretries\t= SENSE_ID_RETRIES;\n\treq->lpm\t= sch->schib.pmcw.pam & sch->opm;\n\treq->check\t= snsid_check;\n\treq->callback\t= snsid_callback;\n\tccw_request_start(cdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}