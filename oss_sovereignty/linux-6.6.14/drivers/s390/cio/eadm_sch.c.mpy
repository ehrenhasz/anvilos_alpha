{
  "module_name": "eadm_sch.c",
  "hash_id": "db9c020944351b8b60ade01d1de6dc0213d4826425710578826249f79835a2ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/eadm_sch.c",
  "human_readable_source": "\n \n\n#include <linux/kernel_stat.h>\n#include <linux/completion.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/io.h>\n\n#include <asm/css_chars.h>\n#include <asm/debug.h>\n#include <asm/isc.h>\n#include <asm/cio.h>\n#include <asm/scsw.h>\n#include <asm/eadm.h>\n\n#include \"eadm_sch.h\"\n#include \"ioasm.h\"\n#include \"cio.h\"\n#include \"css.h\"\n#include \"orb.h\"\n\nMODULE_DESCRIPTION(\"driver for s390 eadm subchannels\");\nMODULE_LICENSE(\"GPL\");\n\n#define EADM_TIMEOUT (7 * HZ)\nstatic DEFINE_SPINLOCK(list_lock);\nstatic LIST_HEAD(eadm_list);\n\nstatic debug_info_t *eadm_debug;\n\n#define EADM_LOG(imp, txt) do {\t\t\t\t\t\\\n\t\tdebug_text_event(eadm_debug, imp, txt);\t\t\\\n\t} while (0)\n\nstatic void EADM_LOG_HEX(int level, void *data, int length)\n{\n\tdebug_event(eadm_debug, level, data, length);\n}\n\nstatic void orb_init(union orb *orb)\n{\n\tmemset(orb, 0, sizeof(union orb));\n\torb->eadm.compat1 = 1;\n\torb->eadm.compat2 = 1;\n\torb->eadm.fmt = 1;\n\torb->eadm.x = 1;\n}\n\nstatic int eadm_subchannel_start(struct subchannel *sch, struct aob *aob)\n{\n\tunion orb *orb = &get_eadm_private(sch)->orb;\n\tint cc;\n\n\torb_init(orb);\n\torb->eadm.aob = (u32)virt_to_phys(aob);\n\torb->eadm.intparm = (u32)virt_to_phys(sch);\n\torb->eadm.key = PAGE_DEFAULT_KEY >> 4;\n\n\tEADM_LOG(6, \"start\");\n\tEADM_LOG_HEX(6, &sch->schid, sizeof(sch->schid));\n\n\tcc = ssch(sch->schid, orb);\n\tswitch (cc) {\n\tcase 0:\n\t\tsch->schib.scsw.eadm.actl |= SCSW_ACTL_START_PEND;\n\t\tbreak;\n\tcase 1:\t\t \n\tcase 2:\t\t \n\t\treturn -EBUSY;\n\tcase 3:\t\t \n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int eadm_subchannel_clear(struct subchannel *sch)\n{\n\tint cc;\n\n\tcc = csch(sch->schid);\n\tif (cc)\n\t\treturn -ENODEV;\n\n\tsch->schib.scsw.eadm.actl |= SCSW_ACTL_CLEAR_PEND;\n\treturn 0;\n}\n\nstatic void eadm_subchannel_timeout(struct timer_list *t)\n{\n\tstruct eadm_private *private = from_timer(private, t, timer);\n\tstruct subchannel *sch = private->sch;\n\n\tspin_lock_irq(sch->lock);\n\tEADM_LOG(1, \"timeout\");\n\tEADM_LOG_HEX(1, &sch->schid, sizeof(sch->schid));\n\tif (eadm_subchannel_clear(sch))\n\t\tEADM_LOG(0, \"clear failed\");\n\tspin_unlock_irq(sch->lock);\n}\n\nstatic void eadm_subchannel_set_timeout(struct subchannel *sch, int expires)\n{\n\tstruct eadm_private *private = get_eadm_private(sch);\n\n\tif (expires == 0)\n\t\tdel_timer(&private->timer);\n\telse\n\t\tmod_timer(&private->timer, jiffies + expires);\n}\n\nstatic void eadm_subchannel_irq(struct subchannel *sch)\n{\n\tstruct eadm_private *private = get_eadm_private(sch);\n\tstruct eadm_scsw *scsw = &sch->schib.scsw.eadm;\n\tstruct irb *irb = this_cpu_ptr(&cio_irb);\n\tblk_status_t error = BLK_STS_OK;\n\n\tEADM_LOG(6, \"irq\");\n\tEADM_LOG_HEX(6, irb, sizeof(*irb));\n\n\tinc_irq_stat(IRQIO_ADM);\n\n\tif ((scsw->stctl & (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND))\n\t    && scsw->eswf == 1 && irb->esw.eadm.erw.r)\n\t\terror = BLK_STS_IOERR;\n\n\tif (scsw->fctl & SCSW_FCTL_CLEAR_FUNC)\n\t\terror = BLK_STS_TIMEOUT;\n\n\teadm_subchannel_set_timeout(sch, 0);\n\n\tif (private->state != EADM_BUSY) {\n\t\tEADM_LOG(1, \"irq unsol\");\n\t\tEADM_LOG_HEX(1, irb, sizeof(*irb));\n\t\tprivate->state = EADM_NOT_OPER;\n\t\tcss_sched_sch_todo(sch, SCH_TODO_EVAL);\n\t\treturn;\n\t}\n\tscm_irq_handler(phys_to_virt(scsw->aob), error);\n\tprivate->state = EADM_IDLE;\n\n\tif (private->completion)\n\t\tcomplete(private->completion);\n}\n\nstatic struct subchannel *eadm_get_idle_sch(void)\n{\n\tstruct eadm_private *private;\n\tstruct subchannel *sch;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list_lock, flags);\n\tlist_for_each_entry(private, &eadm_list, head) {\n\t\tsch = private->sch;\n\t\tspin_lock(sch->lock);\n\t\tif (private->state == EADM_IDLE) {\n\t\t\tprivate->state = EADM_BUSY;\n\t\t\tlist_move_tail(&private->head, &eadm_list);\n\t\t\tspin_unlock(sch->lock);\n\t\t\tspin_unlock_irqrestore(&list_lock, flags);\n\n\t\t\treturn sch;\n\t\t}\n\t\tspin_unlock(sch->lock);\n\t}\n\tspin_unlock_irqrestore(&list_lock, flags);\n\n\treturn NULL;\n}\n\nint eadm_start_aob(struct aob *aob)\n{\n\tstruct eadm_private *private;\n\tstruct subchannel *sch;\n\tunsigned long flags;\n\tint ret;\n\n\tsch = eadm_get_idle_sch();\n\tif (!sch)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(sch->lock, flags);\n\teadm_subchannel_set_timeout(sch, EADM_TIMEOUT);\n\tret = eadm_subchannel_start(sch, aob);\n\tif (!ret)\n\t\tgoto out_unlock;\n\n\t \n\teadm_subchannel_set_timeout(sch, 0);\n\tprivate = get_eadm_private(sch);\n\tprivate->state = EADM_NOT_OPER;\n\tcss_sched_sch_todo(sch, SCH_TODO_EVAL);\n\nout_unlock:\n\tspin_unlock_irqrestore(sch->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(eadm_start_aob);\n\nstatic int eadm_subchannel_probe(struct subchannel *sch)\n{\n\tstruct eadm_private *private;\n\tint ret;\n\n\tprivate = kzalloc(sizeof(*private), GFP_KERNEL | GFP_DMA);\n\tif (!private)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&private->head);\n\ttimer_setup(&private->timer, eadm_subchannel_timeout, 0);\n\n\tspin_lock_irq(sch->lock);\n\tset_eadm_private(sch, private);\n\tprivate->state = EADM_IDLE;\n\tprivate->sch = sch;\n\tsch->isc = EADM_SCH_ISC;\n\tret = cio_enable_subchannel(sch, (u32)virt_to_phys(sch));\n\tif (ret) {\n\t\tset_eadm_private(sch, NULL);\n\t\tspin_unlock_irq(sch->lock);\n\t\tkfree(private);\n\t\tgoto out;\n\t}\n\tspin_unlock_irq(sch->lock);\n\n\tspin_lock_irq(&list_lock);\n\tlist_add(&private->head, &eadm_list);\n\tspin_unlock_irq(&list_lock);\nout:\n\treturn ret;\n}\n\nstatic void eadm_quiesce(struct subchannel *sch)\n{\n\tstruct eadm_private *private = get_eadm_private(sch);\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint ret;\n\n\tspin_lock_irq(sch->lock);\n\tif (private->state != EADM_BUSY)\n\t\tgoto disable;\n\n\tif (eadm_subchannel_clear(sch))\n\t\tgoto disable;\n\n\tprivate->completion = &completion;\n\tspin_unlock_irq(sch->lock);\n\n\twait_for_completion_io(&completion);\n\n\tspin_lock_irq(sch->lock);\n\tprivate->completion = NULL;\n\ndisable:\n\teadm_subchannel_set_timeout(sch, 0);\n\tdo {\n\t\tret = cio_disable_subchannel(sch);\n\t} while (ret == -EBUSY);\n\n\tspin_unlock_irq(sch->lock);\n}\n\nstatic void eadm_subchannel_remove(struct subchannel *sch)\n{\n\tstruct eadm_private *private = get_eadm_private(sch);\n\n\tspin_lock_irq(&list_lock);\n\tlist_del(&private->head);\n\tspin_unlock_irq(&list_lock);\n\n\teadm_quiesce(sch);\n\n\tspin_lock_irq(sch->lock);\n\tset_eadm_private(sch, NULL);\n\tspin_unlock_irq(sch->lock);\n\n\tkfree(private);\n}\n\nstatic void eadm_subchannel_shutdown(struct subchannel *sch)\n{\n\teadm_quiesce(sch);\n}\n\n \nstatic int eadm_subchannel_sch_event(struct subchannel *sch, int process)\n{\n\tstruct eadm_private *private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(sch->lock, flags);\n\tif (!device_is_registered(&sch->dev))\n\t\tgoto out_unlock;\n\n\tif (work_pending(&sch->todo_work))\n\t\tgoto out_unlock;\n\n\tif (cio_update_schib(sch)) {\n\t\tcss_sched_sch_todo(sch, SCH_TODO_UNREG);\n\t\tgoto out_unlock;\n\t}\n\tprivate = get_eadm_private(sch);\n\tif (private->state == EADM_NOT_OPER)\n\t\tprivate->state = EADM_IDLE;\n\nout_unlock:\n\tspin_unlock_irqrestore(sch->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct css_device_id eadm_subchannel_ids[] = {\n\t{ .match_flags = 0x1, .type = SUBCHANNEL_TYPE_ADM, },\n\t{   },\n};\nMODULE_DEVICE_TABLE(css, eadm_subchannel_ids);\n\nstatic struct css_driver eadm_subchannel_driver = {\n\t.drv = {\n\t\t.name = \"eadm_subchannel\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.subchannel_type = eadm_subchannel_ids,\n\t.irq = eadm_subchannel_irq,\n\t.probe = eadm_subchannel_probe,\n\t.remove = eadm_subchannel_remove,\n\t.shutdown = eadm_subchannel_shutdown,\n\t.sch_event = eadm_subchannel_sch_event,\n};\n\nstatic int __init eadm_sch_init(void)\n{\n\tint ret;\n\n\tif (!css_general_characteristics.eadm)\n\t\treturn -ENXIO;\n\n\teadm_debug = debug_register(\"eadm_log\", 16, 1, 16);\n\tif (!eadm_debug)\n\t\treturn -ENOMEM;\n\n\tdebug_register_view(eadm_debug, &debug_hex_ascii_view);\n\tdebug_set_level(eadm_debug, 2);\n\n\tisc_register(EADM_SCH_ISC);\n\tret = css_driver_register(&eadm_subchannel_driver);\n\tif (ret)\n\t\tgoto cleanup;\n\n\treturn ret;\n\ncleanup:\n\tisc_unregister(EADM_SCH_ISC);\n\tdebug_unregister(eadm_debug);\n\treturn ret;\n}\n\nstatic void __exit eadm_sch_exit(void)\n{\n\tcss_driver_unregister(&eadm_subchannel_driver);\n\tisc_unregister(EADM_SCH_ISC);\n\tdebug_unregister(eadm_debug);\n}\nmodule_init(eadm_sch_init);\nmodule_exit(eadm_sch_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}