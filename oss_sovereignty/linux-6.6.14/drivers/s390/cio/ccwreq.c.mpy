{
  "module_name": "ccwreq.c",
  "hash_id": "6ff05e55e5fb078d09b0ba9f8dd4653b5e55410584bff2998e52f06a8e1c1515",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/ccwreq.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"cio\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/types.h>\n#include <linux/err.h>\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n\n#include \"io_sch.h\"\n#include \"cio.h\"\n#include \"device.h\"\n#include \"cio_debug.h\"\n\n \nint lpm_adjust(int lpm, int mask)\n{\n\twhile (lpm && ((lpm & mask) == 0))\n\t\tlpm >>= 1;\n\treturn lpm;\n}\n\n \nstatic u16 ccwreq_next_path(struct ccw_device *cdev)\n{\n\tstruct ccw_request *req = &cdev->private->req;\n\n\tif (!req->singlepath) {\n\t\treq->mask = 0;\n\t\tgoto out;\n\t}\n\treq->retries\t= req->maxretries;\n\treq->mask\t= lpm_adjust(req->mask >> 1, req->lpm);\nout:\n\treturn req->mask;\n}\n\n \nstatic void ccwreq_stop(struct ccw_device *cdev, int rc)\n{\n\tstruct ccw_request *req = &cdev->private->req;\n\n\tif (req->done)\n\t\treturn;\n\treq->done = 1;\n\tccw_device_set_timeout(cdev, 0);\n\tmemset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));\n\tif (rc && rc != -ENODEV && req->drc)\n\t\trc = req->drc;\n\treq->callback(cdev, req->data, rc);\n}\n\n \nstatic void ccwreq_do(struct ccw_device *cdev)\n{\n\tstruct ccw_request *req = &cdev->private->req;\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct ccw1 *cp = req->cp;\n\tint rc = -EACCES;\n\n\twhile (req->mask) {\n\t\tif (req->retries-- == 0) {\n\t\t\t \n\t\t\tccwreq_next_path(cdev);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tmemset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));\n\t\trc = cio_start(sch, cp, (u8) req->mask);\n\t\tif (rc == 0) {\n\t\t\t \n\t\t\tccw_device_set_timeout(cdev, req->timeout);\n\t\t\treturn;\n\t\t}\n\t\tif (rc == -ENODEV) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tif (rc == -EACCES) {\n\t\t\t \n\t\t\tccwreq_next_path(cdev);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\trc = cio_clear(sch);\n\t\tif (rc)\n\t\t\tbreak;\n\t\treturn;\n\t}\n\tccwreq_stop(cdev, rc);\n}\n\n \nvoid ccw_request_start(struct ccw_device *cdev)\n{\n\tstruct ccw_request *req = &cdev->private->req;\n\n\tif (req->singlepath) {\n\t\t \n\t\treq->mask = 0x8080;\n\t} else\n\t\treq->mask = req->lpm;\n\n\treq->retries\t= req->maxretries;\n\treq->mask\t= lpm_adjust(req->mask, req->lpm);\n\treq->drc\t= 0;\n\treq->done\t= 0;\n\treq->cancel\t= 0;\n\tif (!req->mask)\n\t\tgoto out_nopath;\n\tccwreq_do(cdev);\n\treturn;\n\nout_nopath:\n\tccwreq_stop(cdev, -EACCES);\n}\n\n \nint ccw_request_cancel(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct ccw_request *req = &cdev->private->req;\n\tint rc;\n\n\tif (req->done)\n\t\treturn 1;\n\treq->cancel = 1;\n\trc = cio_clear(sch);\n\tif (rc)\n\t\tccwreq_stop(cdev, rc);\n\treturn 0;\n}\n\n \nstatic enum io_status ccwreq_status(struct ccw_device *cdev, struct irb *lcirb)\n{\n\tstruct irb *irb = &cdev->private->dma_area->irb;\n\tstruct cmd_scsw *scsw = &irb->scsw.cmd;\n\tenum uc_todo todo;\n\n\t \n\tif (ccw_device_accumulate_and_sense(cdev, lcirb))\n\t\treturn IO_RUNNING;\n\t \n\tif (scsw->fctl & (SCSW_FCTL_HALT_FUNC | SCSW_FCTL_CLEAR_FUNC))\n\t\treturn IO_KILLED;\n\t \n\tif (scsw->cc == 3 || scsw->pno)\n\t\treturn IO_PATH_ERROR;\n\t \n\tif (irb->esw.esw0.erw.cons) {\n\t\tCIO_TRACE_EVENT(2, \"sensedata\");\n\t\tCIO_HEX_EVENT(2, &cdev->private->dev_id,\n\t\t\t      sizeof(struct ccw_dev_id));\n\t\tCIO_HEX_EVENT(2, &cdev->private->dma_area->irb.ecw,\n\t\t\t      SENSE_MAX_COUNT);\n\t\t \n\t\tif (irb->ecw[0] & SNS0_CMD_REJECT)\n\t\t\treturn IO_REJECTED;\n\t\t \n\t\tif (cdev->drv && cdev->drv->uc_handler) {\n\t\t\ttodo = cdev->drv->uc_handler(cdev, lcirb);\n\t\t\tCIO_TRACE_EVENT(2, \"uc_response\");\n\t\t\tCIO_HEX_EVENT(2, &todo, sizeof(todo));\n\t\t\tswitch (todo) {\n\t\t\tcase UC_TODO_RETRY:\n\t\t\t\treturn IO_STATUS_ERROR;\n\t\t\tcase UC_TODO_RETRY_ON_NEW_PATH:\n\t\t\t\treturn IO_PATH_ERROR;\n\t\t\tcase UC_TODO_STOP:\n\t\t\t\treturn IO_REJECTED;\n\t\t\tdefault:\n\t\t\t\treturn IO_STATUS_ERROR;\n\t\t\t}\n\t\t}\n\t\t \n\t\treturn IO_STATUS_ERROR;\n\t}\n\t \n\tif (scsw->cstat != 0)\n\t\treturn IO_STATUS_ERROR;\n\t \n\tif (scsw->dstat & ~(DEV_STAT_CHN_END | DEV_STAT_DEV_END))\n\t\treturn IO_STATUS_ERROR;\n\t \n\tif (!(scsw->dstat & DEV_STAT_DEV_END))\n\t\treturn IO_RUNNING;\n\t \n\tif (scsw->cc == 1 && (scsw->stctl & SCSW_STCTL_ALERT_STATUS))\n\t\treturn IO_STATUS_ERROR;\n\treturn IO_DONE;\n}\n\n \nstatic void ccwreq_log_status(struct ccw_device *cdev, enum io_status status)\n{\n\tstruct ccw_request *req = &cdev->private->req;\n\tstruct {\n\t\tstruct ccw_dev_id dev_id;\n\t\tu16 retries;\n\t\tu8 lpm;\n\t\tu8 status;\n\t}  __attribute__ ((packed)) data;\n\tdata.dev_id\t= cdev->private->dev_id;\n\tdata.retries\t= req->retries;\n\tdata.lpm\t= (u8) req->mask;\n\tdata.status\t= (u8) status;\n\tCIO_TRACE_EVENT(2, \"reqstat\");\n\tCIO_HEX_EVENT(2, &data, sizeof(data));\n}\n\n \nvoid ccw_request_handler(struct ccw_device *cdev)\n{\n\tstruct irb *irb = this_cpu_ptr(&cio_irb);\n\tstruct ccw_request *req = &cdev->private->req;\n\tenum io_status status;\n\tint rc = -EOPNOTSUPP;\n\n\t \n\tstatus = ccwreq_status(cdev, irb);\n\tif (req->filter)\n\t\tstatus = req->filter(cdev, req->data, irb, status);\n\tif (status != IO_RUNNING)\n\t\tccw_device_set_timeout(cdev, 0);\n\tif (status != IO_DONE && status != IO_RUNNING)\n\t\tccwreq_log_status(cdev, status);\n\tswitch (status) {\n\tcase IO_DONE:\n\t\tbreak;\n\tcase IO_RUNNING:\n\t\treturn;\n\tcase IO_REJECTED:\n\t\tgoto err;\n\tcase IO_PATH_ERROR:\n\t\tgoto out_next_path;\n\tcase IO_STATUS_ERROR:\n\t\tgoto out_restart;\n\tcase IO_KILLED:\n\t\t \n\t\tif (req->cancel) {\n\t\t\trc = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tgoto out_restart;\n\t}\n\t \n\tif (!req->check)\n\t\tgoto out;\n\tswitch (req->check(cdev, req->data)) {\n\tcase 0:\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tgoto out_restart;\n\tcase -EACCES:\n\t\tgoto out_next_path;\n\tdefault:\n\t\tgoto err;\n\t}\nout:\n\tccwreq_stop(cdev, 0);\n\treturn;\n\nout_next_path:\n\t \n\tif (!ccwreq_next_path(cdev)) {\n\t\trc = -EACCES;\n\t\tgoto err;\n\t}\nout_restart:\n\t \n\tccwreq_do(cdev);\n\treturn;\nerr:\n\tccwreq_stop(cdev, rc);\n}\n\n\n \nvoid ccw_request_timeout(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tstruct ccw_request *req = &cdev->private->req;\n\tint rc = -ENODEV, chp;\n\n\tif (cio_update_schib(sch))\n\t\tgoto err;\n\n\tfor (chp = 0; chp < 8; chp++) {\n\t\tif ((0x80 >> chp) & sch->schib.pmcw.lpum)\n\t\t\tpr_warn(\"%s: No interrupt was received within %lus (CS=%02x, DS=%02x, CHPID=%x.%02x)\\n\",\n\t\t\t\tdev_name(&cdev->dev), req->timeout / HZ,\n\t\t\t\tscsw_cstat(&sch->schib.scsw),\n\t\t\t\tscsw_dstat(&sch->schib.scsw),\n\t\t\t\tsch->schid.cssid,\n\t\t\t\tsch->schib.pmcw.chpid[chp]);\n\t}\n\n\tif (!ccwreq_next_path(cdev)) {\n\t\t \n\t\treq->drc = -ETIME;\n\t}\n\trc = cio_clear(sch);\n\tif (rc)\n\t\tgoto err;\n\treturn;\n\nerr:\n\tccwreq_stop(cdev, rc);\n}\n\n \nvoid ccw_request_notoper(struct ccw_device *cdev)\n{\n\tccwreq_stop(cdev, -ENODEV);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}