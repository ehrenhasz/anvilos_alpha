{
  "module_name": "vfio_ccw_cp.c",
  "hash_id": "9996ffa65dbc5f581ccbc5b58a83189a2b22692b7509ae19dcc710f56d81abe4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/vfio_ccw_cp.c",
  "human_readable_source": "\n \n\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/iommu.h>\n#include <linux/vfio.h>\n#include <asm/idals.h>\n\n#include \"vfio_ccw_cp.h\"\n#include \"vfio_ccw_private.h\"\n\nstruct page_array {\n\t \n\tdma_addr_t\t\t*pa_iova;\n\t \n\tstruct page\t\t**pa_page;\n\t \n\tint\t\t\tpa_nr;\n};\n\nstruct ccwchain {\n\tstruct list_head\tnext;\n\tstruct ccw1\t\t*ch_ccw;\n\t \n\tu64\t\t\tch_iova;\n\t \n\tint\t\t\tch_len;\n\t \n\tstruct page_array\t*ch_pa;\n};\n\n \nstatic int page_array_alloc(struct page_array *pa, unsigned int len)\n{\n\tif (pa->pa_nr || pa->pa_iova)\n\t\treturn -EINVAL;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tpa->pa_nr = len;\n\n\tpa->pa_iova = kcalloc(len, sizeof(*pa->pa_iova), GFP_KERNEL);\n\tif (!pa->pa_iova)\n\t\treturn -ENOMEM;\n\n\tpa->pa_page = kcalloc(len, sizeof(*pa->pa_page), GFP_KERNEL);\n\tif (!pa->pa_page) {\n\t\tkfree(pa->pa_iova);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void page_array_unpin(struct page_array *pa,\n\t\t\t     struct vfio_device *vdev, int pa_nr, bool unaligned)\n{\n\tint unpinned = 0, npage = 1;\n\n\twhile (unpinned < pa_nr) {\n\t\tdma_addr_t *first = &pa->pa_iova[unpinned];\n\t\tdma_addr_t *last = &first[npage];\n\n\t\tif (unpinned + npage < pa_nr &&\n\t\t    *first + npage * PAGE_SIZE == *last &&\n\t\t    !unaligned) {\n\t\t\tnpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvfio_unpin_pages(vdev, *first, npage);\n\t\tunpinned += npage;\n\t\tnpage = 1;\n\t}\n\n\tpa->pa_nr = 0;\n}\n\n \nstatic int page_array_pin(struct page_array *pa, struct vfio_device *vdev, bool unaligned)\n{\n\tint pinned = 0, npage = 1;\n\tint ret = 0;\n\n\twhile (pinned < pa->pa_nr) {\n\t\tdma_addr_t *first = &pa->pa_iova[pinned];\n\t\tdma_addr_t *last = &first[npage];\n\n\t\tif (pinned + npage < pa->pa_nr &&\n\t\t    *first + npage * PAGE_SIZE == *last &&\n\t\t    !unaligned) {\n\t\t\tnpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = vfio_pin_pages(vdev, *first, npage,\n\t\t\t\t     IOMMU_READ | IOMMU_WRITE,\n\t\t\t\t     &pa->pa_page[pinned]);\n\t\tif (ret < 0) {\n\t\t\tgoto err_out;\n\t\t} else if (ret > 0 && ret != npage) {\n\t\t\tpinned += ret;\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tpinned += npage;\n\t\tnpage = 1;\n\t}\n\n\treturn ret;\n\nerr_out:\n\tpage_array_unpin(pa, vdev, pinned, unaligned);\n\treturn ret;\n}\n\n \nstatic void page_array_unpin_free(struct page_array *pa, struct vfio_device *vdev, bool unaligned)\n{\n\tpage_array_unpin(pa, vdev, pa->pa_nr, unaligned);\n\tkfree(pa->pa_page);\n\tkfree(pa->pa_iova);\n}\n\nstatic bool page_array_iova_pinned(struct page_array *pa, u64 iova, u64 length)\n{\n\tu64 iova_pfn_start = iova >> PAGE_SHIFT;\n\tu64 iova_pfn_end = (iova + length - 1) >> PAGE_SHIFT;\n\tu64 pfn;\n\tint i;\n\n\tfor (i = 0; i < pa->pa_nr; i++) {\n\t\tpfn = pa->pa_iova[i] >> PAGE_SHIFT;\n\t\tif (pfn >= iova_pfn_start && pfn <= iova_pfn_end)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n \nstatic inline void page_array_idal_create_words(struct page_array *pa,\n\t\t\t\t\t\tunsigned long *idaws)\n{\n\tint i;\n\n\t \n\n\tfor (i = 0; i < pa->pa_nr; i++) {\n\t\tidaws[i] = page_to_phys(pa->pa_page[i]);\n\n\t\t \n\t\tidaws[i] += pa->pa_iova[i] & (PAGE_SIZE - 1);\n\t}\n}\n\nstatic void convert_ccw0_to_ccw1(struct ccw1 *source, unsigned long len)\n{\n\tstruct ccw0 ccw0;\n\tstruct ccw1 *pccw1 = source;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tccw0 = *(struct ccw0 *)pccw1;\n\t\tif ((pccw1->cmd_code & 0x0f) == CCW_CMD_TIC) {\n\t\t\tpccw1->cmd_code = CCW_CMD_TIC;\n\t\t\tpccw1->flags = 0;\n\t\t\tpccw1->count = 0;\n\t\t} else {\n\t\t\tpccw1->cmd_code = ccw0.cmd_code;\n\t\t\tpccw1->flags = ccw0.flags;\n\t\t\tpccw1->count = ccw0.count;\n\t\t}\n\t\tpccw1->cda = ccw0.cda;\n\t\tpccw1++;\n\t}\n}\n\n#define idal_is_2k(_cp) (!(_cp)->orb.cmd.c64 || (_cp)->orb.cmd.i2k)\n\n \n#define ccw_is_read(_ccw) (((_ccw)->cmd_code & 0x03) == 0x02)\n#define ccw_is_read_backward(_ccw) (((_ccw)->cmd_code & 0x0F) == 0x0C)\n#define ccw_is_sense(_ccw) (((_ccw)->cmd_code & 0x0F) == CCW_CMD_BASIC_SENSE)\n\n#define ccw_is_noop(_ccw) ((_ccw)->cmd_code == CCW_CMD_NOOP)\n\n#define ccw_is_tic(_ccw) ((_ccw)->cmd_code == CCW_CMD_TIC)\n\n#define ccw_is_idal(_ccw) ((_ccw)->flags & CCW_FLAG_IDA)\n#define ccw_is_skip(_ccw) ((_ccw)->flags & CCW_FLAG_SKIP)\n\n#define ccw_is_chain(_ccw) ((_ccw)->flags & (CCW_FLAG_CC | CCW_FLAG_DC))\n\n \nstatic inline int ccw_does_data_transfer(struct ccw1 *ccw)\n{\n\t \n\tif (ccw->count == 0)\n\t\treturn 0;\n\n\t \n\tif (ccw_is_noop(ccw))\n\t\treturn 0;\n\n\t \n\tif (!ccw_is_skip(ccw))\n\t\treturn 1;\n\n\t \n\tif (ccw_is_read(ccw) || ccw_is_read_backward(ccw))\n\t\treturn 0;\n\n\tif (ccw_is_sense(ccw))\n\t\treturn 0;\n\n\t \n\treturn 1;\n}\n\n \nstatic inline int is_cpa_within_range(u32 cpa, u32 head, int len)\n{\n\tu32 tail = head + (len - 1) * sizeof(struct ccw1);\n\n\treturn (head <= cpa && cpa <= tail);\n}\n\nstatic inline int is_tic_within_range(struct ccw1 *ccw, u32 head, int len)\n{\n\tif (!ccw_is_tic(ccw))\n\t\treturn 0;\n\n\treturn is_cpa_within_range(ccw->cda, head, len);\n}\n\nstatic struct ccwchain *ccwchain_alloc(struct channel_program *cp, int len)\n{\n\tstruct ccwchain *chain;\n\n\tchain = kzalloc(sizeof(*chain), GFP_KERNEL);\n\tif (!chain)\n\t\treturn NULL;\n\n\tchain->ch_ccw = kcalloc(len, sizeof(*chain->ch_ccw), GFP_DMA | GFP_KERNEL);\n\tif (!chain->ch_ccw)\n\t\tgoto out_err;\n\n\tchain->ch_pa = kcalloc(len, sizeof(*chain->ch_pa), GFP_KERNEL);\n\tif (!chain->ch_pa)\n\t\tgoto out_err;\n\n\tlist_add_tail(&chain->next, &cp->ccwchain_list);\n\n\treturn chain;\n\nout_err:\n\tkfree(chain->ch_ccw);\n\tkfree(chain);\n\treturn NULL;\n}\n\nstatic void ccwchain_free(struct ccwchain *chain)\n{\n\tlist_del(&chain->next);\n\tkfree(chain->ch_pa);\n\tkfree(chain->ch_ccw);\n\tkfree(chain);\n}\n\n \nstatic void ccwchain_cda_free(struct ccwchain *chain, int idx)\n{\n\tstruct ccw1 *ccw = &chain->ch_ccw[idx];\n\n\tif (ccw_is_tic(ccw))\n\t\treturn;\n\n\tkfree(phys_to_virt(ccw->cda));\n}\n\n \nstatic int ccwchain_calc_length(u64 iova, struct channel_program *cp)\n{\n\tstruct ccw1 *ccw = cp->guest_cp;\n\tint cnt = 0;\n\n\tdo {\n\t\tcnt++;\n\n\t\t \n\t\tif (!ccw_is_chain(ccw) && !is_tic_within_range(ccw, iova, cnt))\n\t\t\tbreak;\n\n\t\tccw++;\n\t} while (cnt < CCWCHAIN_LEN_MAX + 1);\n\n\tif (cnt == CCWCHAIN_LEN_MAX + 1)\n\t\tcnt = -EINVAL;\n\n\treturn cnt;\n}\n\nstatic int tic_target_chain_exists(struct ccw1 *tic, struct channel_program *cp)\n{\n\tstruct ccwchain *chain;\n\tu32 ccw_head;\n\n\tlist_for_each_entry(chain, &cp->ccwchain_list, next) {\n\t\tccw_head = chain->ch_iova;\n\t\tif (is_cpa_within_range(tic->cda, ccw_head, chain->ch_len))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccwchain_loop_tic(struct ccwchain *chain,\n\t\t\t     struct channel_program *cp);\n\nstatic int ccwchain_handle_ccw(u32 cda, struct channel_program *cp)\n{\n\tstruct vfio_device *vdev =\n\t\t&container_of(cp, struct vfio_ccw_private, cp)->vdev;\n\tstruct ccwchain *chain;\n\tint len, ret;\n\n\t \n\tret = vfio_dma_rw(vdev, cda, cp->guest_cp, CCWCHAIN_LEN_MAX * sizeof(struct ccw1), false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!cp->orb.cmd.fmt)\n\t\tconvert_ccw0_to_ccw1(cp->guest_cp, CCWCHAIN_LEN_MAX);\n\n\t \n\tlen = ccwchain_calc_length(cda, cp);\n\tif (len < 0)\n\t\treturn len;\n\n\t \n\tchain = ccwchain_alloc(cp, len);\n\tif (!chain)\n\t\treturn -ENOMEM;\n\n\tchain->ch_len = len;\n\tchain->ch_iova = cda;\n\n\t \n\tmemcpy(chain->ch_ccw, cp->guest_cp, len * sizeof(struct ccw1));\n\n\t \n\tret = ccwchain_loop_tic(chain, cp);\n\n\tif (ret)\n\t\tccwchain_free(chain);\n\n\treturn ret;\n}\n\n \nstatic int ccwchain_loop_tic(struct ccwchain *chain, struct channel_program *cp)\n{\n\tstruct ccw1 *tic;\n\tint i, ret;\n\n\tfor (i = 0; i < chain->ch_len; i++) {\n\t\ttic = &chain->ch_ccw[i];\n\n\t\tif (!ccw_is_tic(tic))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tic_target_chain_exists(tic, cp))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = ccwchain_handle_ccw(tic->cda, cp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccwchain_fetch_tic(struct ccw1 *ccw,\n\t\t\t      struct channel_program *cp)\n{\n\tstruct ccwchain *iter;\n\tu32 ccw_head;\n\n\tlist_for_each_entry(iter, &cp->ccwchain_list, next) {\n\t\tccw_head = iter->ch_iova;\n\t\tif (is_cpa_within_range(ccw->cda, ccw_head, iter->ch_len)) {\n\t\t\tccw->cda = (__u32) (addr_t) (((char *)iter->ch_ccw) +\n\t\t\t\t\t\t     (ccw->cda - ccw_head));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EFAULT;\n}\n\nstatic unsigned long *get_guest_idal(struct ccw1 *ccw,\n\t\t\t\t     struct channel_program *cp,\n\t\t\t\t     int idaw_nr)\n{\n\tstruct vfio_device *vdev =\n\t\t&container_of(cp, struct vfio_ccw_private, cp)->vdev;\n\tunsigned long *idaws;\n\tunsigned int *idaws_f1;\n\tint idal_len = idaw_nr * sizeof(*idaws);\n\tint idaw_size = idal_is_2k(cp) ? PAGE_SIZE / 2 : PAGE_SIZE;\n\tint idaw_mask = ~(idaw_size - 1);\n\tint i, ret;\n\n\tidaws = kcalloc(idaw_nr, sizeof(*idaws), GFP_DMA | GFP_KERNEL);\n\tif (!idaws)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (ccw_is_idal(ccw)) {\n\t\t \n\t\tret = vfio_dma_rw(vdev, ccw->cda, idaws, idal_len, false);\n\t\tif (ret) {\n\t\t\tkfree(idaws);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t} else {\n\t\t \n\t\tif (cp->orb.cmd.c64) {\n\t\t\tidaws[0] = ccw->cda;\n\t\t\tfor (i = 1; i < idaw_nr; i++)\n\t\t\t\tidaws[i] = (idaws[i - 1] + idaw_size) & idaw_mask;\n\t\t} else {\n\t\t\tidaws_f1 = (unsigned int *)idaws;\n\t\t\tidaws_f1[0] = ccw->cda;\n\t\t\tfor (i = 1; i < idaw_nr; i++)\n\t\t\t\tidaws_f1[i] = (idaws_f1[i - 1] + idaw_size) & idaw_mask;\n\t\t}\n\t}\n\n\treturn idaws;\n}\n\n \nstatic int ccw_count_idaws(struct ccw1 *ccw,\n\t\t\t   struct channel_program *cp)\n{\n\tstruct vfio_device *vdev =\n\t\t&container_of(cp, struct vfio_ccw_private, cp)->vdev;\n\tu64 iova;\n\tint size = cp->orb.cmd.c64 ? sizeof(u64) : sizeof(u32);\n\tint ret;\n\tint bytes = 1;\n\n\tif (ccw->count)\n\t\tbytes = ccw->count;\n\n\tif (ccw_is_idal(ccw)) {\n\t\t \n\t\t \n\t\tret = vfio_dma_rw(vdev, ccw->cda, &iova, size, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!cp->orb.cmd.c64)\n\t\t\tiova = iova >> 32;\n\t} else {\n\t\tiova = ccw->cda;\n\t}\n\n\t \n\tif (!cp->orb.cmd.c64)\n\t\treturn idal_2k_nr_words((void *)iova, bytes);\n\n\t \n\tif (cp->orb.cmd.i2k)\n\t\treturn idal_2k_nr_words((void *)iova, bytes);\n\n\t \n\treturn idal_nr_words((void *)iova, bytes);\n}\n\nstatic int ccwchain_fetch_ccw(struct ccw1 *ccw,\n\t\t\t      struct page_array *pa,\n\t\t\t      struct channel_program *cp)\n{\n\tstruct vfio_device *vdev =\n\t\t&container_of(cp, struct vfio_ccw_private, cp)->vdev;\n\tunsigned long *idaws;\n\tunsigned int *idaws_f1;\n\tint ret;\n\tint idaw_nr;\n\tint i;\n\n\t \n\tidaw_nr = ccw_count_idaws(ccw, cp);\n\tif (idaw_nr < 0)\n\t\treturn idaw_nr;\n\n\t \n\tidaws = get_guest_idal(ccw, cp, idaw_nr);\n\tif (IS_ERR(idaws)) {\n\t\tret = PTR_ERR(idaws);\n\t\tgoto out_init;\n\t}\n\n\t \n\tret = page_array_alloc(pa, idaw_nr);\n\tif (ret < 0)\n\t\tgoto out_free_idaws;\n\n\t \n\tidaws_f1 = (unsigned int *)idaws;\n\tfor (i = 0; i < idaw_nr; i++) {\n\t\tif (cp->orb.cmd.c64)\n\t\t\tpa->pa_iova[i] = idaws[i];\n\t\telse\n\t\t\tpa->pa_iova[i] = idaws_f1[i];\n\t}\n\n\tif (ccw_does_data_transfer(ccw)) {\n\t\tret = page_array_pin(pa, vdev, idal_is_2k(cp));\n\t\tif (ret < 0)\n\t\t\tgoto out_unpin;\n\t} else {\n\t\tpa->pa_nr = 0;\n\t}\n\n\tccw->cda = (__u32) virt_to_phys(idaws);\n\tccw->flags |= CCW_FLAG_IDA;\n\n\t \n\tpage_array_idal_create_words(pa, idaws);\n\n\treturn 0;\n\nout_unpin:\n\tpage_array_unpin_free(pa, vdev, idal_is_2k(cp));\nout_free_idaws:\n\tkfree(idaws);\nout_init:\n\tccw->cda = 0;\n\treturn ret;\n}\n\n \nstatic int ccwchain_fetch_one(struct ccw1 *ccw,\n\t\t\t      struct page_array *pa,\n\t\t\t      struct channel_program *cp)\n\n{\n\tif (ccw_is_tic(ccw))\n\t\treturn ccwchain_fetch_tic(ccw, cp);\n\n\treturn ccwchain_fetch_ccw(ccw, pa, cp);\n}\n\n \nint cp_init(struct channel_program *cp, union orb *orb)\n{\n\tstruct vfio_device *vdev =\n\t\t&container_of(cp, struct vfio_ccw_private, cp)->vdev;\n\t \n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 1);\n\tint ret;\n\n\t \n\tif (cp->initialized)\n\t\treturn -EBUSY;\n\n\t \n\tif (!orb->cmd.pfch && __ratelimit(&ratelimit_state))\n\t\tdev_warn(\n\t\t\tvdev->dev,\n\t\t\t\"Prefetching channel program even though prefetch not specified in ORB\");\n\n\tINIT_LIST_HEAD(&cp->ccwchain_list);\n\tmemcpy(&cp->orb, orb, sizeof(*orb));\n\n\t \n\tret = ccwchain_handle_ccw(orb->cmd.cpa, cp);\n\n\tif (!ret)\n\t\tcp->initialized = true;\n\n\treturn ret;\n}\n\n\n \nvoid cp_free(struct channel_program *cp)\n{\n\tstruct vfio_device *vdev =\n\t\t&container_of(cp, struct vfio_ccw_private, cp)->vdev;\n\tstruct ccwchain *chain, *temp;\n\tint i;\n\n\tif (!cp->initialized)\n\t\treturn;\n\n\tcp->initialized = false;\n\tlist_for_each_entry_safe(chain, temp, &cp->ccwchain_list, next) {\n\t\tfor (i = 0; i < chain->ch_len; i++) {\n\t\t\tpage_array_unpin_free(&chain->ch_pa[i], vdev, idal_is_2k(cp));\n\t\t\tccwchain_cda_free(chain, i);\n\t\t}\n\t\tccwchain_free(chain);\n\t}\n}\n\n \nint cp_prefetch(struct channel_program *cp)\n{\n\tstruct ccwchain *chain;\n\tstruct ccw1 *ccw;\n\tstruct page_array *pa;\n\tint len, idx, ret;\n\n\t \n\tif (!cp->initialized)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(chain, &cp->ccwchain_list, next) {\n\t\tlen = chain->ch_len;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tccw = &chain->ch_ccw[idx];\n\t\t\tpa = &chain->ch_pa[idx];\n\n\t\t\tret = ccwchain_fetch_one(ccw, pa, cp);\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\treturn 0;\nout_err:\n\t \n\tchain->ch_len = idx;\n\tlist_for_each_entry_continue(chain, &cp->ccwchain_list, next) {\n\t\tchain->ch_len = 0;\n\t}\n\treturn ret;\n}\n\n \nunion orb *cp_get_orb(struct channel_program *cp, struct subchannel *sch)\n{\n\tunion orb *orb;\n\tstruct ccwchain *chain;\n\tstruct ccw1 *cpa;\n\n\t \n\tif (!cp->initialized)\n\t\treturn NULL;\n\n\torb = &cp->orb;\n\n\torb->cmd.intparm = (u32)virt_to_phys(sch);\n\torb->cmd.fmt = 1;\n\n\t \n\tif (!orb->cmd.c64)\n\t\torb->cmd.i2k = 1;\n\torb->cmd.c64 = 1;\n\n\tif (orb->cmd.lpm == 0)\n\t\torb->cmd.lpm = sch->lpm;\n\n\tchain = list_first_entry(&cp->ccwchain_list, struct ccwchain, next);\n\tcpa = chain->ch_ccw;\n\torb->cmd.cpa = (__u32)virt_to_phys(cpa);\n\n\treturn orb;\n}\n\n \nvoid cp_update_scsw(struct channel_program *cp, union scsw *scsw)\n{\n\tstruct ccwchain *chain;\n\tu32 cpa = scsw->cmd.cpa;\n\tu32 ccw_head;\n\n\tif (!cp->initialized)\n\t\treturn;\n\n\t \n\tlist_for_each_entry(chain, &cp->ccwchain_list, next) {\n\t\tccw_head = (u32)(u64)chain->ch_ccw;\n\t\t \n\t\tif (is_cpa_within_range(cpa, ccw_head, chain->ch_len + 1)) {\n\t\t\t \n\t\t\tcpa = chain->ch_iova + (cpa - ccw_head);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tscsw->cmd.cpa = cpa;\n}\n\n \nbool cp_iova_pinned(struct channel_program *cp, u64 iova, u64 length)\n{\n\tstruct ccwchain *chain;\n\tint i;\n\n\tif (!cp->initialized)\n\t\treturn false;\n\n\tlist_for_each_entry(chain, &cp->ccwchain_list, next) {\n\t\tfor (i = 0; i < chain->ch_len; i++)\n\t\t\tif (page_array_iova_pinned(&chain->ch_pa[i], iova, length))\n\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}