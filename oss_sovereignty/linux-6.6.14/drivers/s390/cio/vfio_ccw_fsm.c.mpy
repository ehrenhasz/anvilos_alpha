{
  "module_name": "vfio_ccw_fsm.c",
  "hash_id": "dc5e19d7bc4d69b4522a69b9aadb4b229d6d8a9b56ca6266cb82f3059c4587eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/vfio_ccw_fsm.c",
  "human_readable_source": "\n \n\n#include <linux/vfio.h>\n\n#include <asm/isc.h>\n\n#include \"ioasm.h\"\n#include \"vfio_ccw_private.h\"\n\nstatic int fsm_io_helper(struct vfio_ccw_private *private)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\tunion orb *orb;\n\tint ccode;\n\t__u8 lpm;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(sch->lock, flags);\n\n\torb = cp_get_orb(&private->cp, sch);\n\tif (!orb) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tVFIO_CCW_TRACE_EVENT(5, \"stIO\");\n\tVFIO_CCW_TRACE_EVENT(5, dev_name(&sch->dev));\n\n\t \n\tccode = ssch(sch->schid, orb);\n\n\tVFIO_CCW_HEX_EVENT(5, &ccode, sizeof(ccode));\n\n\tswitch (ccode) {\n\tcase 0:\n\t\t \n\t\tsch->schib.scsw.cmd.actl |= SCSW_ACTL_START_PEND;\n\t\tret = 0;\n\t\tprivate->state = VFIO_CCW_STATE_CP_PENDING;\n\t\tbreak;\n\tcase 1:\t\t \n\tcase 2:\t\t \n\t\tret = -EBUSY;\n\t\tbreak;\n\tcase 3:\t\t \n\t{\n\t\tlpm = orb->cmd.lpm;\n\t\tif (lpm != 0)\n\t\t\tsch->lpm &= ~lpm;\n\t\telse\n\t\t\tsch->lpm = 0;\n\n\t\tif (cio_update_schib(sch))\n\t\t\tret = -ENODEV;\n\t\telse\n\t\t\tret = sch->lpm ? -EACCES : -ENODEV;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = ccode;\n\t}\nout:\n\tspin_unlock_irqrestore(sch->lock, flags);\n\treturn ret;\n}\n\nstatic int fsm_do_halt(struct vfio_ccw_private *private)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\tunsigned long flags;\n\tint ccode;\n\tint ret;\n\n\tspin_lock_irqsave(sch->lock, flags);\n\n\tVFIO_CCW_TRACE_EVENT(2, \"haltIO\");\n\tVFIO_CCW_TRACE_EVENT(2, dev_name(&sch->dev));\n\n\t \n\tccode = hsch(sch->schid);\n\n\tVFIO_CCW_HEX_EVENT(2, &ccode, sizeof(ccode));\n\n\tswitch (ccode) {\n\tcase 0:\n\t\t \n\t\tsch->schib.scsw.cmd.actl |= SCSW_ACTL_HALT_PEND;\n\t\tret = 0;\n\t\tbreak;\n\tcase 1:\t\t \n\tcase 2:\t\t \n\t\tret = -EBUSY;\n\t\tbreak;\n\tcase 3:\t\t \n\t\tret = -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tret = ccode;\n\t}\n\tspin_unlock_irqrestore(sch->lock, flags);\n\treturn ret;\n}\n\nstatic int fsm_do_clear(struct vfio_ccw_private *private)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\tunsigned long flags;\n\tint ccode;\n\tint ret;\n\n\tspin_lock_irqsave(sch->lock, flags);\n\n\tVFIO_CCW_TRACE_EVENT(2, \"clearIO\");\n\tVFIO_CCW_TRACE_EVENT(2, dev_name(&sch->dev));\n\n\t \n\tccode = csch(sch->schid);\n\n\tVFIO_CCW_HEX_EVENT(2, &ccode, sizeof(ccode));\n\n\tswitch (ccode) {\n\tcase 0:\n\t\t \n\t\tsch->schib.scsw.cmd.actl = SCSW_ACTL_CLEAR_PEND;\n\t\t \n\t\tret = 0;\n\t\tbreak;\n\tcase 3:\t\t \n\t\tret = -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tret = ccode;\n\t}\n\tspin_unlock_irqrestore(sch->lock, flags);\n\treturn ret;\n}\n\nstatic void fsm_notoper(struct vfio_ccw_private *private,\n\t\t\tenum vfio_ccw_event event)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\n\tVFIO_CCW_MSG_EVENT(2, \"sch %x.%x.%04x: notoper event %x state %x\\n\",\n\t\t\t   sch->schid.cssid,\n\t\t\t   sch->schid.ssid,\n\t\t\t   sch->schid.sch_no,\n\t\t\t   event,\n\t\t\t   private->state);\n\n\t \n\tcss_sched_sch_todo(sch, SCH_TODO_UNREG);\n\tprivate->state = VFIO_CCW_STATE_NOT_OPER;\n\n\t \n\tcp_free(&private->cp);\n}\n\n \nstatic void fsm_nop(struct vfio_ccw_private *private,\n\t\t    enum vfio_ccw_event event)\n{\n}\n\nstatic void fsm_io_error(struct vfio_ccw_private *private,\n\t\t\t enum vfio_ccw_event event)\n{\n\tpr_err(\"vfio-ccw: FSM: I/O request from state:%d\\n\", private->state);\n\tprivate->io_region->ret_code = -EIO;\n}\n\nstatic void fsm_io_busy(struct vfio_ccw_private *private,\n\t\t\tenum vfio_ccw_event event)\n{\n\tprivate->io_region->ret_code = -EBUSY;\n}\n\nstatic void fsm_io_retry(struct vfio_ccw_private *private,\n\t\t\t enum vfio_ccw_event event)\n{\n\tprivate->io_region->ret_code = -EAGAIN;\n}\n\nstatic void fsm_async_error(struct vfio_ccw_private *private,\n\t\t\t    enum vfio_ccw_event event)\n{\n\tstruct ccw_cmd_region *cmd_region = private->cmd_region;\n\n\tpr_err(\"vfio-ccw: FSM: %s request from state:%d\\n\",\n\t       cmd_region->command == VFIO_CCW_ASYNC_CMD_HSCH ? \"halt\" :\n\t       cmd_region->command == VFIO_CCW_ASYNC_CMD_CSCH ? \"clear\" :\n\t       \"<unknown>\", private->state);\n\tcmd_region->ret_code = -EIO;\n}\n\nstatic void fsm_async_retry(struct vfio_ccw_private *private,\n\t\t\t    enum vfio_ccw_event event)\n{\n\tprivate->cmd_region->ret_code = -EAGAIN;\n}\n\nstatic void fsm_disabled_irq(struct vfio_ccw_private *private,\n\t\t\t     enum vfio_ccw_event event)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\n\t \n\tcio_disable_subchannel(sch);\n}\ninline struct subchannel_id get_schid(struct vfio_ccw_private *p)\n{\n\tstruct subchannel *sch = to_subchannel(p->vdev.dev->parent);\n\n\treturn sch->schid;\n}\n\n \nstatic void fsm_io_request(struct vfio_ccw_private *private,\n\t\t\t   enum vfio_ccw_event event)\n{\n\tunion orb *orb;\n\tunion scsw *scsw = &private->scsw;\n\tstruct ccw_io_region *io_region = private->io_region;\n\tchar *errstr = \"request\";\n\tstruct subchannel_id schid = get_schid(private);\n\n\tprivate->state = VFIO_CCW_STATE_CP_PROCESSING;\n\tmemcpy(scsw, io_region->scsw_area, sizeof(*scsw));\n\n\tif (scsw->cmd.fctl & SCSW_FCTL_START_FUNC) {\n\t\torb = (union orb *)io_region->orb_area;\n\n\t\t \n\t\tif (orb->tm.b) {\n\t\t\tio_region->ret_code = -EOPNOTSUPP;\n\t\t\tVFIO_CCW_MSG_EVENT(2,\n\t\t\t\t\t   \"sch %x.%x.%04x: transport mode\\n\",\n\t\t\t\t\t   schid.cssid,\n\t\t\t\t\t   schid.ssid, schid.sch_no);\n\t\t\terrstr = \"transport mode\";\n\t\t\tgoto err_out;\n\t\t}\n\t\tio_region->ret_code = cp_init(&private->cp, orb);\n\t\tif (io_region->ret_code) {\n\t\t\tVFIO_CCW_MSG_EVENT(2,\n\t\t\t\t\t   \"sch %x.%x.%04x: cp_init=%d\\n\",\n\t\t\t\t\t   schid.cssid,\n\t\t\t\t\t   schid.ssid, schid.sch_no,\n\t\t\t\t\t   io_region->ret_code);\n\t\t\terrstr = \"cp init\";\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tio_region->ret_code = cp_prefetch(&private->cp);\n\t\tif (io_region->ret_code) {\n\t\t\tVFIO_CCW_MSG_EVENT(2,\n\t\t\t\t\t   \"sch %x.%x.%04x: cp_prefetch=%d\\n\",\n\t\t\t\t\t   schid.cssid,\n\t\t\t\t\t   schid.ssid, schid.sch_no,\n\t\t\t\t\t   io_region->ret_code);\n\t\t\terrstr = \"cp prefetch\";\n\t\t\tcp_free(&private->cp);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\tio_region->ret_code = fsm_io_helper(private);\n\t\tif (io_region->ret_code) {\n\t\t\tVFIO_CCW_MSG_EVENT(2,\n\t\t\t\t\t   \"sch %x.%x.%04x: fsm_io_helper=%d\\n\",\n\t\t\t\t\t   schid.cssid,\n\t\t\t\t\t   schid.ssid, schid.sch_no,\n\t\t\t\t\t   io_region->ret_code);\n\t\t\terrstr = \"cp fsm_io_helper\";\n\t\t\tcp_free(&private->cp);\n\t\t\tgoto err_out;\n\t\t}\n\t\treturn;\n\t} else if (scsw->cmd.fctl & SCSW_FCTL_HALT_FUNC) {\n\t\tVFIO_CCW_MSG_EVENT(2,\n\t\t\t\t   \"sch %x.%x.%04x: halt on io_region\\n\",\n\t\t\t\t   schid.cssid,\n\t\t\t\t   schid.ssid, schid.sch_no);\n\t\t \n\t\tio_region->ret_code = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t} else if (scsw->cmd.fctl & SCSW_FCTL_CLEAR_FUNC) {\n\t\tVFIO_CCW_MSG_EVENT(2,\n\t\t\t\t   \"sch %x.%x.%04x: clear on io_region\\n\",\n\t\t\t\t   schid.cssid,\n\t\t\t\t   schid.ssid, schid.sch_no);\n\t\t \n\t\tio_region->ret_code = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\nerr_out:\n\tprivate->state = VFIO_CCW_STATE_IDLE;\n\ttrace_vfio_ccw_fsm_io_request(scsw->cmd.fctl, schid,\n\t\t\t\t      io_region->ret_code, errstr);\n}\n\n \nstatic void fsm_async_request(struct vfio_ccw_private *private,\n\t\t\t      enum vfio_ccw_event event)\n{\n\tstruct ccw_cmd_region *cmd_region = private->cmd_region;\n\n\tswitch (cmd_region->command) {\n\tcase VFIO_CCW_ASYNC_CMD_HSCH:\n\t\tcmd_region->ret_code = fsm_do_halt(private);\n\t\tbreak;\n\tcase VFIO_CCW_ASYNC_CMD_CSCH:\n\t\tcmd_region->ret_code = fsm_do_clear(private);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tcmd_region->ret_code = -EINVAL;\n\t}\n\n\ttrace_vfio_ccw_fsm_async_request(get_schid(private),\n\t\t\t\t\t cmd_region->command,\n\t\t\t\t\t cmd_region->ret_code);\n}\n\n \nstatic void fsm_irq(struct vfio_ccw_private *private,\n\t\t    enum vfio_ccw_event event)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\tstruct irb *irb = this_cpu_ptr(&cio_irb);\n\n\tVFIO_CCW_TRACE_EVENT(6, \"IRQ\");\n\tVFIO_CCW_TRACE_EVENT(6, dev_name(&sch->dev));\n\n\tmemcpy(&private->irb, irb, sizeof(*irb));\n\n\tqueue_work(vfio_ccw_work_q, &private->io_work);\n\n\tif (private->completion)\n\t\tcomplete(private->completion);\n}\n\nstatic void fsm_open(struct vfio_ccw_private *private,\n\t\t     enum vfio_ccw_event event)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\tint ret;\n\n\tspin_lock_irq(sch->lock);\n\tsch->isc = VFIO_CCW_ISC;\n\tret = cio_enable_subchannel(sch, (u32)(unsigned long)sch);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tprivate->state = VFIO_CCW_STATE_IDLE;\n\tspin_unlock_irq(sch->lock);\n\treturn;\n\nerr_unlock:\n\tspin_unlock_irq(sch->lock);\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_NOT_OPER);\n}\n\nstatic void fsm_close(struct vfio_ccw_private *private,\n\t\t      enum vfio_ccw_event event)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\tint ret;\n\n\tspin_lock_irq(sch->lock);\n\n\tif (!sch->schib.pmcw.ena)\n\t\tgoto err_unlock;\n\n\tret = cio_disable_subchannel(sch);\n\tif (ret == -EBUSY)\n\t\tret = vfio_ccw_sch_quiesce(sch);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tprivate->state = VFIO_CCW_STATE_STANDBY;\n\tspin_unlock_irq(sch->lock);\n\tcp_free(&private->cp);\n\treturn;\n\nerr_unlock:\n\tspin_unlock_irq(sch->lock);\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_NOT_OPER);\n}\n\n \nfsm_func_t *vfio_ccw_jumptable[NR_VFIO_CCW_STATES][NR_VFIO_CCW_EVENTS] = {\n\t[VFIO_CCW_STATE_NOT_OPER] = {\n\t\t[VFIO_CCW_EVENT_NOT_OPER]\t= fsm_nop,\n\t\t[VFIO_CCW_EVENT_IO_REQ]\t\t= fsm_io_error,\n\t\t[VFIO_CCW_EVENT_ASYNC_REQ]\t= fsm_async_error,\n\t\t[VFIO_CCW_EVENT_INTERRUPT]\t= fsm_disabled_irq,\n\t\t[VFIO_CCW_EVENT_OPEN]\t\t= fsm_nop,\n\t\t[VFIO_CCW_EVENT_CLOSE]\t\t= fsm_nop,\n\t},\n\t[VFIO_CCW_STATE_STANDBY] = {\n\t\t[VFIO_CCW_EVENT_NOT_OPER]\t= fsm_notoper,\n\t\t[VFIO_CCW_EVENT_IO_REQ]\t\t= fsm_io_error,\n\t\t[VFIO_CCW_EVENT_ASYNC_REQ]\t= fsm_async_error,\n\t\t[VFIO_CCW_EVENT_INTERRUPT]\t= fsm_disabled_irq,\n\t\t[VFIO_CCW_EVENT_OPEN]\t\t= fsm_open,\n\t\t[VFIO_CCW_EVENT_CLOSE]\t\t= fsm_notoper,\n\t},\n\t[VFIO_CCW_STATE_IDLE] = {\n\t\t[VFIO_CCW_EVENT_NOT_OPER]\t= fsm_notoper,\n\t\t[VFIO_CCW_EVENT_IO_REQ]\t\t= fsm_io_request,\n\t\t[VFIO_CCW_EVENT_ASYNC_REQ]\t= fsm_async_request,\n\t\t[VFIO_CCW_EVENT_INTERRUPT]\t= fsm_irq,\n\t\t[VFIO_CCW_EVENT_OPEN]\t\t= fsm_notoper,\n\t\t[VFIO_CCW_EVENT_CLOSE]\t\t= fsm_close,\n\t},\n\t[VFIO_CCW_STATE_CP_PROCESSING] = {\n\t\t[VFIO_CCW_EVENT_NOT_OPER]\t= fsm_notoper,\n\t\t[VFIO_CCW_EVENT_IO_REQ]\t\t= fsm_io_retry,\n\t\t[VFIO_CCW_EVENT_ASYNC_REQ]\t= fsm_async_retry,\n\t\t[VFIO_CCW_EVENT_INTERRUPT]\t= fsm_irq,\n\t\t[VFIO_CCW_EVENT_OPEN]\t\t= fsm_notoper,\n\t\t[VFIO_CCW_EVENT_CLOSE]\t\t= fsm_close,\n\t},\n\t[VFIO_CCW_STATE_CP_PENDING] = {\n\t\t[VFIO_CCW_EVENT_NOT_OPER]\t= fsm_notoper,\n\t\t[VFIO_CCW_EVENT_IO_REQ]\t\t= fsm_io_busy,\n\t\t[VFIO_CCW_EVENT_ASYNC_REQ]\t= fsm_async_request,\n\t\t[VFIO_CCW_EVENT_INTERRUPT]\t= fsm_irq,\n\t\t[VFIO_CCW_EVENT_OPEN]\t\t= fsm_notoper,\n\t\t[VFIO_CCW_EVENT_CLOSE]\t\t= fsm_close,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}