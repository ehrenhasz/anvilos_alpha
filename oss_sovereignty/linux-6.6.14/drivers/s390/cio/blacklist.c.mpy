{
  "module_name": "blacklist.c",
  "hash_id": "d42d545fd83d531f89d36089954ab57777f8bc99b44638c18601a147c4faff25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/blacklist.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"cio\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/ctype.h>\n#include <linux/device.h>\n\n#include <linux/uaccess.h>\n#include <asm/cio.h>\n#include <asm/ipl.h>\n\n#include \"blacklist.h\"\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"css.h\"\n#include \"device.h\"\n\n \n\n \n#define __BL_DEV_WORDS ((__MAX_SUBCHANNEL + (8*sizeof(long) - 1)) / \\\n\t\t\t (8*sizeof(long)))\nstatic unsigned long bl_dev[__MAX_SSID + 1][__BL_DEV_WORDS];\ntypedef enum {add, free} range_action;\n\n \nstatic int blacklist_range(range_action action, unsigned int from_ssid,\n\t\t\t   unsigned int to_ssid, unsigned int from,\n\t\t\t   unsigned int to, int msgtrigger)\n{\n\tif ((from_ssid > to_ssid) || ((from_ssid == to_ssid) && (from > to))) {\n\t\tif (msgtrigger)\n\t\t\tpr_warn(\"0.%x.%04x to 0.%x.%04x is not a valid range for cio_ignore\\n\",\n\t\t\t\tfrom_ssid, from, to_ssid, to);\n\n\t\treturn 1;\n\t}\n\n\twhile ((from_ssid < to_ssid) || ((from_ssid == to_ssid) &&\n\t       (from <= to))) {\n\t\tif (action == add)\n\t\t\tset_bit(from, bl_dev[from_ssid]);\n\t\telse\n\t\t\tclear_bit(from, bl_dev[from_ssid]);\n\t\tfrom++;\n\t\tif (from > __MAX_SUBCHANNEL) {\n\t\t\tfrom_ssid++;\n\t\t\tfrom = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pure_hex(char **cp, unsigned int *val, int min_digit,\n\t\t    int max_digit, int max_val)\n{\n\tint diff;\n\n\tdiff = 0;\n\t*val = 0;\n\n\twhile (diff <= max_digit) {\n\t\tint value = hex_to_bin(**cp);\n\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*val = *val * 16 + value;\n\t\t(*cp)++;\n\t\tdiff++;\n\t}\n\n\tif ((diff < min_digit) || (diff > max_digit) || (*val > max_val))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int parse_busid(char *str, unsigned int *cssid, unsigned int *ssid,\n\t\t       unsigned int *devno, int msgtrigger)\n{\n\tchar *str_work;\n\tint val, rc, ret;\n\n\trc = 1;\n\n\tif (*str == '\\0')\n\t\tgoto out;\n\n\t \n\tstr_work = str;\n\tval = simple_strtoul(str, &str_work, 16);\n\n\tif (*str_work == '\\0') {\n\t\tif (val <= __MAX_SUBCHANNEL) {\n\t\t\t*devno = val;\n\t\t\t*ssid = 0;\n\t\t\t*cssid = 0;\n\t\t\trc = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tstr_work = str;\n\tret = pure_hex(&str_work, cssid, 1, 2, __MAX_CSSID);\n\tif (ret || (str_work[0] != '.'))\n\t\tgoto out;\n\tstr_work++;\n\tret = pure_hex(&str_work, ssid, 1, 1, __MAX_SSID);\n\tif (ret || (str_work[0] != '.'))\n\t\tgoto out;\n\tstr_work++;\n\tret = pure_hex(&str_work, devno, 4, 4, __MAX_SUBCHANNEL);\n\tif (ret || (str_work[0] != '\\0'))\n\t\tgoto out;\n\n\trc = 0;\nout:\n\tif (rc && msgtrigger)\n\t\tpr_warn(\"%s is not a valid device for the cio_ignore kernel parameter\\n\",\n\t\t\tstr);\n\n\treturn rc;\n}\n\nstatic int blacklist_parse_parameters(char *str, range_action action,\n\t\t\t\t      int msgtrigger)\n{\n\tunsigned int from_cssid, to_cssid, from_ssid, to_ssid, from, to;\n\tint rc, totalrc;\n\tchar *parm;\n\trange_action ra;\n\n\ttotalrc = 0;\n\n\twhile ((parm = strsep(&str, \",\"))) {\n\t\trc = 0;\n\t\tra = action;\n\t\tif (*parm == '!') {\n\t\t\tif (ra == add)\n\t\t\t\tra = free;\n\t\t\telse\n\t\t\t\tra = add;\n\t\t\tparm++;\n\t\t}\n\t\tif (strcmp(parm, \"all\") == 0) {\n\t\t\tfrom_cssid = 0;\n\t\t\tfrom_ssid = 0;\n\t\t\tfrom = 0;\n\t\t\tto_cssid = __MAX_CSSID;\n\t\t\tto_ssid = __MAX_SSID;\n\t\t\tto = __MAX_SUBCHANNEL;\n\t\t} else if (strcmp(parm, \"ipldev\") == 0) {\n\t\t\tif (ipl_info.type == IPL_TYPE_CCW) {\n\t\t\t\tfrom_cssid = 0;\n\t\t\t\tfrom_ssid = ipl_info.data.ccw.dev_id.ssid;\n\t\t\t\tfrom = ipl_info.data.ccw.dev_id.devno;\n\t\t\t} else if (ipl_info.type == IPL_TYPE_FCP ||\n\t\t\t\t   ipl_info.type == IPL_TYPE_FCP_DUMP) {\n\t\t\t\tfrom_cssid = 0;\n\t\t\t\tfrom_ssid = ipl_info.data.fcp.dev_id.ssid;\n\t\t\t\tfrom = ipl_info.data.fcp.dev_id.devno;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tto_cssid = from_cssid;\n\t\t\tto_ssid = from_ssid;\n\t\t\tto = from;\n\t\t} else if (strcmp(parm, \"condev\") == 0) {\n\t\t\tif (console_devno == -1)\n\t\t\t\tcontinue;\n\n\t\t\tfrom_cssid = to_cssid = 0;\n\t\t\tfrom_ssid = to_ssid = 0;\n\t\t\tfrom = to = console_devno;\n\t\t} else {\n\t\t\trc = parse_busid(strsep(&parm, \"-\"), &from_cssid,\n\t\t\t\t\t &from_ssid, &from, msgtrigger);\n\t\t\tif (!rc) {\n\t\t\t\tif (parm != NULL)\n\t\t\t\t\trc = parse_busid(parm, &to_cssid,\n\t\t\t\t\t\t\t &to_ssid, &to,\n\t\t\t\t\t\t\t msgtrigger);\n\t\t\t\telse {\n\t\t\t\t\tto_cssid = from_cssid;\n\t\t\t\t\tto_ssid = from_ssid;\n\t\t\t\t\tto = from;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!rc) {\n\t\t\trc = blacklist_range(ra, from_ssid, to_ssid, from, to,\n\t\t\t\t\t     msgtrigger);\n\t\t\tif (rc)\n\t\t\t\ttotalrc = -EINVAL;\n\t\t} else\n\t\t\ttotalrc = -EINVAL;\n\t}\n\n\treturn totalrc;\n}\n\nstatic int __init\nblacklist_setup (char *str)\n{\n\tCIO_MSG_EVENT(6, \"Reading blacklist parameters\\n\");\n\tif (blacklist_parse_parameters(str, add, 1))\n\t\treturn 0;\n\treturn 1;\n}\n\n__setup (\"cio_ignore=\", blacklist_setup);\n\n \n\n \nint\nis_blacklisted (int ssid, int devno)\n{\n\treturn test_bit (devno, bl_dev[ssid]);\n}\n\n#ifdef CONFIG_PROC_FS\n \nstatic int blacklist_parse_proc_parameters(char *buf)\n{\n\tint rc;\n\tchar *parm;\n\n\tparm = strsep(&buf, \" \");\n\n\tif (strcmp(\"free\", parm) == 0) {\n\t\trc = blacklist_parse_parameters(buf, free, 0);\n\t\t \n\t\tcss_schedule_eval_cond(CSS_EVAL_NOT_ONLINE, 0);\n\t} else if (strcmp(\"add\", parm) == 0)\n\t\trc = blacklist_parse_parameters(buf, add, 0);\n\telse if (strcmp(\"purge\", parm) == 0)\n\t\treturn ccw_purge_blacklisted();\n\telse\n\t\treturn -EINVAL;\n\n\n\treturn rc;\n}\n\n \nstruct ccwdev_iter {\n\tint devno;\n\tint ssid;\n\tint in_range;\n};\n\nstatic void *\ncio_ignore_proc_seq_start(struct seq_file *s, loff_t *offset)\n{\n\tstruct ccwdev_iter *iter = s->private;\n\n\tif (*offset >= (__MAX_SUBCHANNEL + 1) * (__MAX_SSID + 1))\n\t\treturn NULL;\n\tmemset(iter, 0, sizeof(*iter));\n\titer->ssid = *offset / (__MAX_SUBCHANNEL + 1);\n\titer->devno = *offset % (__MAX_SUBCHANNEL + 1);\n\treturn iter;\n}\n\nstatic void\ncio_ignore_proc_seq_stop(struct seq_file *s, void *it)\n{\n}\n\nstatic void *\ncio_ignore_proc_seq_next(struct seq_file *s, void *it, loff_t *offset)\n{\n\tstruct ccwdev_iter *iter;\n\tloff_t p = *offset;\n\n\t(*offset)++;\n\tif (p >= (__MAX_SUBCHANNEL + 1) * (__MAX_SSID + 1))\n\t\treturn NULL;\n\titer = it;\n\tif (iter->devno == __MAX_SUBCHANNEL) {\n\t\titer->devno = 0;\n\t\titer->ssid++;\n\t\tif (iter->ssid > __MAX_SSID)\n\t\t\treturn NULL;\n\t} else\n\t\titer->devno++;\n\treturn iter;\n}\n\nstatic int\ncio_ignore_proc_seq_show(struct seq_file *s, void *it)\n{\n\tstruct ccwdev_iter *iter;\n\n\titer = it;\n\tif (!is_blacklisted(iter->ssid, iter->devno))\n\t\t \n\t\treturn 0;\n\tif (!iter->in_range) {\n\t\t \n\t\tif ((iter->devno == __MAX_SUBCHANNEL) ||\n\t\t    !is_blacklisted(iter->ssid, iter->devno + 1)) {\n\t\t\t \n\t\t\tseq_printf(s, \"0.%x.%04x\\n\", iter->ssid, iter->devno);\n\t\t\treturn 0;\n\t\t}\n\t\titer->in_range = 1;\n\t\tseq_printf(s, \"0.%x.%04x-\", iter->ssid, iter->devno);\n\t\treturn 0;\n\t}\n\tif ((iter->devno == __MAX_SUBCHANNEL) ||\n\t    !is_blacklisted(iter->ssid, iter->devno + 1)) {\n\t\t \n\t\titer->in_range = 0;\n\t\tseq_printf(s, \"0.%x.%04x\\n\", iter->ssid, iter->devno);\n\t}\n\treturn 0;\n}\n\nstatic ssize_t\ncio_ignore_write(struct file *file, const char __user *user_buf,\n\t\t size_t user_len, loff_t *offset)\n{\n\tchar *buf;\n\tssize_t rc, ret, i;\n\n\tif (*offset)\n\t\treturn -EINVAL;\n\tif (user_len > 65536)\n\t\tuser_len = 65536;\n\tbuf = vzalloc(user_len + 1);  \n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (strncpy_from_user (buf, user_buf, user_len) < 0) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\ti = user_len - 1;\n\twhile ((i >= 0) && (isspace(buf[i]) || (buf[i] == 0))) {\n\t\tbuf[i] = '\\0';\n\t\ti--;\n\t}\n\tret = blacklist_parse_proc_parameters(buf);\n\tif (ret)\n\t\trc = ret;\n\telse\n\t\trc = user_len;\n\nout_free:\n\tvfree (buf);\n\treturn rc;\n}\n\nstatic const struct seq_operations cio_ignore_proc_seq_ops = {\n\t.start = cio_ignore_proc_seq_start,\n\t.stop  = cio_ignore_proc_seq_stop,\n\t.next  = cio_ignore_proc_seq_next,\n\t.show  = cio_ignore_proc_seq_show,\n};\n\nstatic int\ncio_ignore_proc_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_private(file, &cio_ignore_proc_seq_ops,\n\t\t\t\tsizeof(struct ccwdev_iter));\n}\n\nstatic const struct proc_ops cio_ignore_proc_ops = {\n\t.proc_open\t= cio_ignore_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release_private,\n\t.proc_write\t= cio_ignore_write,\n};\n\nstatic int\ncio_ignore_proc_init (void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tentry = proc_create(\"cio_ignore\", S_IFREG | S_IRUGO | S_IWUSR, NULL,\n\t\t\t    &cio_ignore_proc_ops);\n\tif (!entry)\n\t\treturn -ENOENT;\n\treturn 0;\n}\n\n__initcall (cio_ignore_proc_init);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}