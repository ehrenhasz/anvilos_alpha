{
  "module_name": "qdio.h",
  "hash_id": "b173cd91e9d72ba001b00f3b96af838e80dd9734918e81ecf57b1fa3e3b2bbeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/qdio.h",
  "human_readable_source": " \n \n#ifndef _CIO_QDIO_H\n#define _CIO_QDIO_H\n\n#include <asm/page.h>\n#include <asm/schid.h>\n#include <asm/debug.h>\n#include \"chsc.h\"\n\n#define QDIO_BUSY_BIT_PATIENCE\t\t(100 << 12)\t \n#define QDIO_BUSY_BIT_RETRY_DELAY\t10\t\t \n#define QDIO_BUSY_BIT_RETRIES\t\t1000\t\t \n\nenum qdio_irq_states {\n\tQDIO_IRQ_STATE_INACTIVE,\n\tQDIO_IRQ_STATE_ESTABLISHED,\n\tQDIO_IRQ_STATE_ACTIVE,\n\tQDIO_IRQ_STATE_STOPPED,\n\tQDIO_IRQ_STATE_CLEANUP,\n\tQDIO_IRQ_STATE_ERR,\n\tNR_QDIO_IRQ_STATES,\n};\n\n \n#define QDIO_DOING_ESTABLISH\t1\n#define QDIO_DOING_ACTIVATE\t2\n#define QDIO_DOING_CLEANUP\t3\n\n#define SLSB_STATE_NOT_INIT\t0x0\n#define SLSB_STATE_EMPTY\t0x1\n#define SLSB_STATE_PRIMED\t0x2\n#define SLSB_STATE_PENDING\t0x3\n#define SLSB_STATE_HALTED\t0xe\n#define SLSB_STATE_ERROR\t0xf\n#define SLSB_TYPE_INPUT\t\t0x0\n#define SLSB_TYPE_OUTPUT\t0x20\n#define SLSB_OWNER_PROG\t\t0x80\n#define SLSB_OWNER_CU\t\t0x40\n\n#define SLSB_P_INPUT_NOT_INIT\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_NOT_INIT)   \n#define SLSB_P_INPUT_ACK\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_EMPTY)\t    \n#define SLSB_CU_INPUT_EMPTY\t\\\n\t(SLSB_OWNER_CU | SLSB_TYPE_INPUT | SLSB_STATE_EMPTY)\t    \n#define SLSB_P_INPUT_PRIMED\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_PRIMED)\t    \n#define SLSB_P_INPUT_HALTED\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_HALTED)\t    \n#define SLSB_P_INPUT_ERROR\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_INPUT | SLSB_STATE_ERROR)\t    \n#define SLSB_P_OUTPUT_NOT_INIT\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_NOT_INIT)  \n#define SLSB_P_OUTPUT_EMPTY\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_EMPTY)\t    \n#define SLSB_P_OUTPUT_PENDING \\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_PENDING)   \n#define SLSB_CU_OUTPUT_PRIMED\t\\\n\t(SLSB_OWNER_CU | SLSB_TYPE_OUTPUT | SLSB_STATE_PRIMED)\t    \n#define SLSB_P_OUTPUT_HALTED\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_HALTED)    \n#define SLSB_P_OUTPUT_ERROR\t\\\n\t(SLSB_OWNER_PROG | SLSB_TYPE_OUTPUT | SLSB_STATE_ERROR)\t    \n\n#define SLSB_ERROR_DURING_LOOKUP  0xff\n\n \n#define CIW_TYPE_EQUEUE\t\t\t0x3  \n#define CIW_TYPE_AQUEUE\t\t\t0x4  \n\n \n#define CHSC_FLAG_QDIO_CAPABILITY\t0x80\n#define CHSC_FLAG_VALIDITY\t\t0x40\n\n \n#define QDIO_SIGA_WRITE\t\t0x00\n#define QDIO_SIGA_READ\t\t0x01\n#define QDIO_SIGA_SYNC\t\t0x02\n#define QDIO_SIGA_WRITEM\t0x03\n#define QDIO_SIGA_WRITEQ\t0x04\n#define QDIO_SIGA_QEBSM_FLAG\t0x80\n\nstatic inline int do_sqbs(u64 token, unsigned char state, int queue,\n\t\t\t  int *start, int *count)\n{\n\tunsigned long _queuestart = ((unsigned long)queue << 32) | *start;\n\tunsigned long _ccq = *count;\n\n\tasm volatile(\n\t\t\"\tlgr\t1,%[token]\\n\"\n\t\t\"\t.insn\trsy,0xeb000000008a,%[qs],%[ccq],0(%[state])\"\n\t\t: [ccq] \"+&d\" (_ccq), [qs] \"+&d\" (_queuestart)\n\t\t: [state] \"a\" ((unsigned long)state), [token] \"d\" (token)\n\t\t: \"memory\", \"cc\", \"1\");\n\t*count = _ccq & 0xff;\n\t*start = _queuestart & 0xff;\n\n\treturn (_ccq >> 32) & 0xff;\n}\n\nstatic inline int do_eqbs(u64 token, unsigned char *state, int queue,\n\t\t\t  int *start, int *count, int ack)\n{\n\tunsigned long _queuestart = ((unsigned long)queue << 32) | *start;\n\tunsigned long _state = (unsigned long)ack << 63;\n\tunsigned long _ccq = *count;\n\n\tasm volatile(\n\t\t\"\tlgr\t1,%[token]\\n\"\n\t\t\"\t.insn\trrf,0xb99c0000,%[qs],%[state],%[ccq],0\"\n\t\t: [ccq] \"+&d\" (_ccq), [qs] \"+&d\" (_queuestart),\n\t\t  [state] \"+&d\" (_state)\n\t\t: [token] \"d\" (token)\n\t\t: \"memory\", \"cc\", \"1\");\n\t*count = _ccq & 0xff;\n\t*start = _queuestart & 0xff;\n\t*state = _state & 0xff;\n\n\treturn (_ccq >> 32) & 0xff;\n}\n\nstruct qdio_irq;\n\nstruct qdio_dev_perf_stat {\n\tunsigned int adapter_int;\n\tunsigned int qdio_int;\n\n\tunsigned int siga_read;\n\tunsigned int siga_write;\n\tunsigned int siga_sync;\n\n\tunsigned int inbound_call;\n\tunsigned int stop_polling;\n\tunsigned int inbound_queue_full;\n\tunsigned int outbound_call;\n\tunsigned int outbound_queue_full;\n\tunsigned int fast_requeue;\n\tunsigned int target_full;\n\tunsigned int eqbs;\n\tunsigned int eqbs_partial;\n\tunsigned int sqbs;\n\tunsigned int sqbs_partial;\n\tunsigned int int_discarded;\n} ____cacheline_aligned;\n\nstruct qdio_queue_perf_stat {\n\t \n\tunsigned int nr_sbals[8];\n\tunsigned int nr_sbal_error;\n\tunsigned int nr_sbal_nop;\n\tunsigned int nr_sbal_total;\n};\n\nenum qdio_irq_poll_states {\n\tQDIO_IRQ_DISABLED,\n};\n\nstruct qdio_input_q {\n\t \n\tunsigned int batch_start;\n\tunsigned int batch_count;\n};\n\nstruct qdio_output_q {\n};\n\n \nstruct qdio_q {\n\tstruct slsb slsb;\n\n\tunion {\n\t\tstruct qdio_input_q in;\n\t\tstruct qdio_output_q out;\n\t} u;\n\n\t \n\tint first_to_check;\n\n\t \n\tatomic_t nr_buf_used;\n\n\t \n\tu64 timestamp;\n\n\tstruct qdio_queue_perf_stat q_stats;\n\n\tstruct qdio_buffer *sbal[QDIO_MAX_BUFFERS_PER_Q] ____cacheline_aligned;\n\n\t \n\tint nr;\n\n\t \n\tint mask;\n\n\t \n\tint is_input_q;\n\n\t \n\tqdio_handler_t (*handler);\n\n\tstruct qdio_irq *irq_ptr;\n\tstruct sl *sl;\n\t \n\tstruct slib *slib;\n} __attribute__ ((aligned(256)));\n\nstruct qdio_irq {\n\tstruct qib qib;\n\tu32 *dsci;\t\t \n\tstruct ccw_device *cdev;\n\tstruct list_head entry;\t\t \n\tstruct dentry *debugfs_dev;\n\tu64 last_data_irq_time;\n\n\tunsigned long int_parm;\n\tstruct subchannel_id schid;\n\tunsigned long sch_token;\t \n\n\tenum qdio_irq_states state;\n\tu8 qdioac1;\n\n\tint nr_input_qs;\n\tint nr_output_qs;\n\n\tstruct ccw1 *ccw;\n\n\tstruct qdio_ssqd_desc ssqd_desc;\n\tvoid (*orig_handler) (struct ccw_device *, unsigned long, struct irb *);\n\tqdio_handler_t (*error_handler);\n\n\tint perf_stat_enabled;\n\n\tstruct qdr *qdr;\n\tunsigned long chsc_page;\n\n\tstruct qdio_q *input_qs[QDIO_MAX_QUEUES_PER_IRQ];\n\tstruct qdio_q *output_qs[QDIO_MAX_QUEUES_PER_IRQ];\n\tunsigned int max_input_qs;\n\tunsigned int max_output_qs;\n\n\tvoid (*irq_poll)(struct ccw_device *cdev, unsigned long data);\n\tunsigned long poll_state;\n\n\tdebug_info_t *debug_area;\n\tstruct mutex setup_mutex;\n\tstruct qdio_dev_perf_stat perf_stat;\n};\n\n \n#define queue_type(q)\tq->irq_ptr->qib.qfmt\n#define SCH_NO(q)\t(q->irq_ptr->schid.sch_no)\n\n#define is_thinint_irq(irq) \\\n\t(irq->qib.qfmt == QDIO_IQDIO_QFMT || \\\n\t css_general_characteristics.aif_osa)\n\n#define qperf(__qdev, __attr)\t((__qdev)->perf_stat.(__attr))\n\n#define QDIO_PERF_STAT_INC(__irq, __attr)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct qdio_irq *qdev = __irq;\t\t\t\t\t\\\n\tif (qdev->perf_stat_enabled)\t\t\t\t\t\\\n\t\t(qdev->perf_stat.__attr)++;\t\t\t\t\\\n})\n\n#define qperf_inc(__q, __attr)\tQDIO_PERF_STAT_INC((__q)->irq_ptr, __attr)\n\nstatic inline void account_sbals_error(struct qdio_q *q, int count)\n{\n\tq->q_stats.nr_sbal_error += count;\n\tq->q_stats.nr_sbal_total += count;\n}\n\n \nstatic inline int multicast_outbound(struct qdio_q *q)\n{\n\treturn (q->irq_ptr->nr_output_qs > 1) &&\n\t       (q->nr == q->irq_ptr->nr_output_qs - 1);\n}\n\nstatic inline void qdio_deliver_irq(struct qdio_irq *irq)\n{\n\tif (!test_and_set_bit(QDIO_IRQ_DISABLED, &irq->poll_state))\n\t\tirq->irq_poll(irq->cdev, irq->int_parm);\n\telse\n\t\tQDIO_PERF_STAT_INC(irq, int_discarded);\n}\n\n#define pci_out_supported(irq) ((irq)->qib.ac & QIB_AC_OUTBOUND_PCI_SUPPORTED)\n#define is_qebsm(q)\t\t\t(q->irq_ptr->sch_token != 0)\n\n#define qdio_need_siga_in(irq)\t\t((irq)->qdioac1 & AC1_SIGA_INPUT_NEEDED)\n#define qdio_need_siga_out(irq)\t\t((irq)->qdioac1 & AC1_SIGA_OUTPUT_NEEDED)\n#define qdio_need_siga_sync(irq)\t(unlikely((irq)->qdioac1 & AC1_SIGA_SYNC_NEEDED))\n\n#define for_each_input_queue(irq_ptr, q, i)\t\t\\\n\tfor (i = 0; i < irq_ptr->nr_input_qs &&\t\t\\\n\t\t({ q = irq_ptr->input_qs[i]; 1; }); i++)\n#define for_each_output_queue(irq_ptr, q, i)\t\t\\\n\tfor (i = 0; i < irq_ptr->nr_output_qs &&\t\\\n\t\t({ q = irq_ptr->output_qs[i]; 1; }); i++)\n\n#define add_buf(bufnr, inc)\tQDIO_BUFNR((bufnr) + (inc))\n#define next_buf(bufnr)\t\tadd_buf(bufnr, 1)\n#define sub_buf(bufnr, dec)\tQDIO_BUFNR((bufnr) - (dec))\n#define prev_buf(bufnr)\t\tsub_buf(bufnr, 1)\n\nextern u64 last_ai_time;\n\n \nint qdio_establish_thinint(struct qdio_irq *irq_ptr);\nvoid qdio_shutdown_thinint(struct qdio_irq *irq_ptr);\nint qdio_thinint_init(void);\nvoid qdio_thinint_exit(void);\nint test_nonshared_ind(struct qdio_irq *);\n\n \nvoid qdio_int_handler(struct ccw_device *cdev, unsigned long intparm,\n\t\t      struct irb *irb);\nint qdio_allocate_qs(struct qdio_irq *irq_ptr, int nr_input_qs,\n\t\t     int nr_output_qs);\nvoid qdio_setup_ssqd_info(struct qdio_irq *irq_ptr);\nint qdio_setup_get_ssqd(struct qdio_irq *irq_ptr,\n\t\t\tstruct subchannel_id *schid,\n\t\t\tstruct qdio_ssqd_desc *data);\nvoid qdio_setup_irq(struct qdio_irq *irq_ptr, struct qdio_initialize *init_data);\nvoid qdio_shutdown_irq(struct qdio_irq *irq);\nvoid qdio_print_subchannel_info(struct qdio_irq *irq_ptr);\nvoid qdio_free_queues(struct qdio_irq *irq_ptr);\nint qdio_setup_init(void);\nvoid qdio_setup_exit(void);\n\nint debug_get_buf_state(struct qdio_q *q, unsigned int bufnr,\n\t\t\tunsigned char *state);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}