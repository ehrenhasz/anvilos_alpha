{
  "module_name": "device_fsm.c",
  "hash_id": "edcec9d89b43ef879aadfb1a498ca8fd1d111b5b30cf555708e87bb5de0d4497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/device_fsm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n#include <asm/chpid.h>\n\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"css.h\"\n#include \"device.h\"\n#include \"chsc.h\"\n#include \"ioasm.h\"\n#include \"chp.h\"\n\nstatic int timeout_log_enabled;\n\nstatic int __init ccw_timeout_log_setup(char *unused)\n{\n\ttimeout_log_enabled = 1;\n\treturn 1;\n}\n\n__setup(\"ccw_timeout_log\", ccw_timeout_log_setup);\n\nstatic void ccw_timeout_log(struct ccw_device *cdev)\n{\n\tstruct schib schib;\n\tstruct subchannel *sch;\n\tstruct io_subchannel_private *private;\n\tunion orb *orb;\n\tint cc;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\tprivate = to_io_private(sch);\n\torb = &private->orb;\n\tcc = stsch(sch->schid, &schib);\n\n\tprintk(KERN_WARNING \"cio: ccw device timeout occurred at %lx, \"\n\t       \"device information:\\n\", get_tod_clock());\n\tprintk(KERN_WARNING \"cio: orb:\\n\");\n\tprint_hex_dump(KERN_WARNING, \"cio:  \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       orb, sizeof(*orb), 0);\n\tprintk(KERN_WARNING \"cio: ccw device bus id: %s\\n\",\n\t       dev_name(&cdev->dev));\n\tprintk(KERN_WARNING \"cio: subchannel bus id: %s\\n\",\n\t       dev_name(&sch->dev));\n\tprintk(KERN_WARNING \"cio: subchannel lpm: %02x, opm: %02x, \"\n\t       \"vpm: %02x\\n\", sch->lpm, sch->opm, sch->vpm);\n\n\tif (orb->tm.b) {\n\t\tprintk(KERN_WARNING \"cio: orb indicates transport mode\\n\");\n\t\tprintk(KERN_WARNING \"cio: last tcw:\\n\");\n\t\tprint_hex_dump(KERN_WARNING, \"cio:  \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t       phys_to_virt(orb->tm.tcw),\n\t\t\t       sizeof(struct tcw), 0);\n\t} else {\n\t\tprintk(KERN_WARNING \"cio: orb indicates command mode\\n\");\n\t\tif ((void *)(addr_t)orb->cmd.cpa ==\n\t\t    &private->dma_area->sense_ccw ||\n\t\t    (void *)(addr_t)orb->cmd.cpa ==\n\t\t    cdev->private->dma_area->iccws)\n\t\t\tprintk(KERN_WARNING \"cio: last channel program \"\n\t\t\t       \"(intern):\\n\");\n\t\telse\n\t\t\tprintk(KERN_WARNING \"cio: last channel program:\\n\");\n\n\t\tprint_hex_dump(KERN_WARNING, \"cio:  \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t       phys_to_virt(orb->cmd.cpa),\n\t\t\t       sizeof(struct ccw1), 0);\n\t}\n\tprintk(KERN_WARNING \"cio: ccw device state: %d\\n\",\n\t       cdev->private->state);\n\tprintk(KERN_WARNING \"cio: store subchannel returned: cc=%d\\n\", cc);\n\tprintk(KERN_WARNING \"cio: schib:\\n\");\n\tprint_hex_dump(KERN_WARNING, \"cio:  \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       &schib, sizeof(schib), 0);\n\tprintk(KERN_WARNING \"cio: ccw device flags:\\n\");\n\tprint_hex_dump(KERN_WARNING, \"cio:  \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       &cdev->private->flags, sizeof(cdev->private->flags), 0);\n}\n\n \nvoid\nccw_device_timeout(struct timer_list *t)\n{\n\tstruct ccw_device_private *priv = from_timer(priv, t, timer);\n\tstruct ccw_device *cdev = priv->cdev;\n\n\tspin_lock_irq(cdev->ccwlock);\n\tif (timeout_log_enabled)\n\t\tccw_timeout_log(cdev);\n\tdev_fsm_event(cdev, DEV_EVENT_TIMEOUT);\n\tspin_unlock_irq(cdev->ccwlock);\n}\n\n \nvoid\nccw_device_set_timeout(struct ccw_device *cdev, int expires)\n{\n\tif (expires == 0)\n\t\tdel_timer(&cdev->private->timer);\n\telse\n\t\tmod_timer(&cdev->private->timer, jiffies + expires);\n}\n\nint\nccw_device_cancel_halt_clear(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\tint ret;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\tret = cio_cancel_halt_clear(sch, &cdev->private->iretry);\n\n\tif (ret == -EIO)\n\t\tCIO_MSG_EVENT(0, \"0.%x.%04x: could not stop I/O\\n\",\n\t\t\t      cdev->private->dev_id.ssid,\n\t\t\t      cdev->private->dev_id.devno);\n\n\treturn ret;\n}\n\nvoid ccw_device_update_sense_data(struct ccw_device *cdev)\n{\n\tmemset(&cdev->id, 0, sizeof(cdev->id));\n\tcdev->id.cu_type = cdev->private->dma_area->senseid.cu_type;\n\tcdev->id.cu_model = cdev->private->dma_area->senseid.cu_model;\n\tcdev->id.dev_type = cdev->private->dma_area->senseid.dev_type;\n\tcdev->id.dev_model = cdev->private->dma_area->senseid.dev_model;\n}\n\nint ccw_device_test_sense_data(struct ccw_device *cdev)\n{\n\treturn cdev->id.cu_type ==\n\t\tcdev->private->dma_area->senseid.cu_type &&\n\t\tcdev->id.cu_model ==\n\t\tcdev->private->dma_area->senseid.cu_model &&\n\t\tcdev->id.dev_type ==\n\t\tcdev->private->dma_area->senseid.dev_type &&\n\t\tcdev->id.dev_model ==\n\t\tcdev->private->dma_area->senseid.dev_model;\n}\n\n \nstatic void\n__recover_lost_chpids(struct subchannel *sch, int old_lpm)\n{\n\tint mask, i;\n\tstruct chp_id chpid;\n\n\tchp_id_init(&chpid);\n\tfor (i = 0; i<8; i++) {\n\t\tmask = 0x80 >> i;\n\t\tif (!(sch->lpm & mask))\n\t\t\tcontinue;\n\t\tif (old_lpm & mask)\n\t\t\tcontinue;\n\t\tchpid.id = sch->schib.pmcw.chpid[i];\n\t\tif (!chp_is_registered(chpid))\n\t\t\tcss_schedule_eval_all();\n\t}\n}\n\n \nstatic void\nccw_device_recog_done(struct ccw_device *cdev, int state)\n{\n\tstruct subchannel *sch;\n\tint old_lpm;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\n\tif (cio_disable_subchannel(sch))\n\t\tstate = DEV_STATE_NOT_OPER;\n\t \n\told_lpm = sch->lpm;\n\n\t \n\tif (cio_update_schib(sch))\n\t\tstate = DEV_STATE_NOT_OPER;\n\telse\n\t\tsch->lpm = sch->schib.pmcw.pam & sch->opm;\n\n\tif (cdev->private->state == DEV_STATE_DISCONNECTED_SENSE_ID)\n\t\t \n\t\told_lpm = 0;\n\tif (sch->lpm != old_lpm)\n\t\t__recover_lost_chpids(sch, old_lpm);\n\tif (cdev->private->state == DEV_STATE_DISCONNECTED_SENSE_ID &&\n\t    (state == DEV_STATE_NOT_OPER || state == DEV_STATE_BOXED)) {\n\t\tcdev->private->flags.recog_done = 1;\n\t\tcdev->private->state = DEV_STATE_DISCONNECTED;\n\t\twake_up(&cdev->private->wait_q);\n\t\treturn;\n\t}\n\tswitch (state) {\n\tcase DEV_STATE_NOT_OPER:\n\t\tbreak;\n\tcase DEV_STATE_OFFLINE:\n\t\tif (!cdev->online) {\n\t\t\tccw_device_update_sense_data(cdev);\n\t\t\tbreak;\n\t\t}\n\t\tcdev->private->state = DEV_STATE_OFFLINE;\n\t\tcdev->private->flags.recog_done = 1;\n\t\tif (ccw_device_test_sense_data(cdev)) {\n\t\t\tcdev->private->flags.donotify = 1;\n\t\t\tccw_device_online(cdev);\n\t\t\twake_up(&cdev->private->wait_q);\n\t\t} else {\n\t\t\tccw_device_update_sense_data(cdev);\n\t\t\tccw_device_sched_todo(cdev, CDEV_TODO_REBIND);\n\t\t}\n\t\treturn;\n\tcase DEV_STATE_BOXED:\n\t\tif (cdev->id.cu_type != 0) {  \n\t\t\tcdev->private->flags.recog_done = 1;\n\t\t\tcdev->private->state = DEV_STATE_BOXED;\n\t\t\twake_up(&cdev->private->wait_q);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\tcdev->private->state = state;\n\tio_subchannel_recog_done(cdev);\n\twake_up(&cdev->private->wait_q);\n}\n\n \nvoid\nccw_device_sense_id_done(struct ccw_device *cdev, int err)\n{\n\tswitch (err) {\n\tcase 0:\n\t\tccw_device_recog_done(cdev, DEV_STATE_OFFLINE);\n\t\tbreak;\n\tcase -ETIME:\t\t \n\t\tccw_device_recog_done(cdev, DEV_STATE_BOXED);\n\t\tbreak;\n\tdefault:\n\t\tccw_device_recog_done(cdev, DEV_STATE_NOT_OPER);\n\t\tbreak;\n\t}\n}\n\n \nint ccw_device_notify(struct ccw_device *cdev, int event)\n{\n\tint ret = -EINVAL;\n\n\tif (!cdev->drv)\n\t\tgoto out;\n\tif (!cdev->online)\n\t\tgoto out;\n\tCIO_MSG_EVENT(2, \"notify called for 0.%x.%04x, event=%d\\n\",\n\t\t      cdev->private->dev_id.ssid, cdev->private->dev_id.devno,\n\t\t      event);\n\tif (!cdev->drv->notify) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (cdev->drv->notify(cdev, event))\n\t\tret = NOTIFY_OK;\n\telse\n\t\tret = NOTIFY_BAD;\nout:\n\treturn ret;\n}\n\nstatic void ccw_device_oper_notify(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\tif (ccw_device_notify(cdev, CIO_OPER) == NOTIFY_OK) {\n\t\t \n\t\tccw_device_sched_todo(cdev, CDEV_TODO_ENABLE_CMF);\n\t\t \n\t\tcdev->private->path_new_mask = sch->vpm;\n\t\treturn;\n\t}\n\t \n\tccw_device_set_notoper(cdev);\n\tccw_device_sched_todo(cdev, CDEV_TODO_REBIND);\n}\n\n \nstatic void\nccw_device_done(struct ccw_device *cdev, int state)\n{\n\tstruct subchannel *sch;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\n\tccw_device_set_timeout(cdev, 0);\n\n\tif (state != DEV_STATE_ONLINE)\n\t\tcio_disable_subchannel(sch);\n\n\t \n\tmemset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));\n\n\tcdev->private->state = state;\n\n\tswitch (state) {\n\tcase DEV_STATE_BOXED:\n\t\tCIO_MSG_EVENT(0, \"Boxed device %04x on subchannel %04x\\n\",\n\t\t\t      cdev->private->dev_id.devno, sch->schid.sch_no);\n\t\tif (cdev->online &&\n\t\t    ccw_device_notify(cdev, CIO_BOXED) != NOTIFY_OK)\n\t\t\tccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\n\t\tcdev->private->flags.donotify = 0;\n\t\tbreak;\n\tcase DEV_STATE_NOT_OPER:\n\t\tCIO_MSG_EVENT(0, \"Device %04x gone on subchannel %04x\\n\",\n\t\t\t      cdev->private->dev_id.devno, sch->schid.sch_no);\n\t\tif (ccw_device_notify(cdev, CIO_GONE) != NOTIFY_OK)\n\t\t\tccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\n\t\telse\n\t\t\tccw_device_set_disconnected(cdev);\n\t\tcdev->private->flags.donotify = 0;\n\t\tbreak;\n\tcase DEV_STATE_DISCONNECTED:\n\t\tCIO_MSG_EVENT(0, \"Disconnected device %04x on subchannel \"\n\t\t\t      \"%04x\\n\", cdev->private->dev_id.devno,\n\t\t\t      sch->schid.sch_no);\n\t\tif (ccw_device_notify(cdev, CIO_NO_PATH) != NOTIFY_OK) {\n\t\t\tcdev->private->state = DEV_STATE_NOT_OPER;\n\t\t\tccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\n\t\t} else\n\t\t\tccw_device_set_disconnected(cdev);\n\t\tcdev->private->flags.donotify = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cdev->private->flags.donotify) {\n\t\tcdev->private->flags.donotify = 0;\n\t\tccw_device_oper_notify(cdev);\n\t}\n\twake_up(&cdev->private->wait_q);\n}\n\n \nvoid ccw_device_recognition(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\t \n\tcdev->private->flags.recog_done = 0;\n\tcdev->private->state = DEV_STATE_SENSE_ID;\n\tif (cio_enable_subchannel(sch, (u32)virt_to_phys(sch))) {\n\t\tccw_device_recog_done(cdev, DEV_STATE_NOT_OPER);\n\t\treturn;\n\t}\n\tccw_device_sense_id_start(cdev);\n}\n\n \nstatic void ccw_device_request_event(struct ccw_device *cdev, enum dev_event e)\n{\n\tswitch (e) {\n\tcase DEV_EVENT_NOTOPER:\n\t\tccw_request_notoper(cdev);\n\t\tbreak;\n\tcase DEV_EVENT_INTERRUPT:\n\t\tccw_request_handler(cdev);\n\t\tbreak;\n\tcase DEV_EVENT_TIMEOUT:\n\t\tccw_request_timeout(cdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ccw_device_report_path_events(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tint path_event[8];\n\tint chp, mask;\n\n\tfor (chp = 0, mask = 0x80; chp < 8; chp++, mask >>= 1) {\n\t\tpath_event[chp] = PE_NONE;\n\t\tif (mask & cdev->private->path_gone_mask & ~(sch->vpm))\n\t\t\tpath_event[chp] |= PE_PATH_GONE;\n\t\tif (mask & cdev->private->path_new_mask & sch->vpm)\n\t\t\tpath_event[chp] |= PE_PATH_AVAILABLE;\n\t\tif (mask & cdev->private->pgid_reset_mask & sch->vpm)\n\t\t\tpath_event[chp] |= PE_PATHGROUP_ESTABLISHED;\n\t}\n\tif (cdev->online && cdev->drv->path_event)\n\t\tcdev->drv->path_event(cdev, path_event);\n}\n\nstatic void ccw_device_reset_path_events(struct ccw_device *cdev)\n{\n\tcdev->private->path_gone_mask = 0;\n\tcdev->private->path_new_mask = 0;\n\tcdev->private->pgid_reset_mask = 0;\n}\n\nstatic void create_fake_irb(struct irb *irb, int type)\n{\n\tmemset(irb, 0, sizeof(*irb));\n\tif (type == FAKE_CMD_IRB) {\n\t\tstruct cmd_scsw *scsw = &irb->scsw.cmd;\n\t\tscsw->cc = 1;\n\t\tscsw->fctl = SCSW_FCTL_START_FUNC;\n\t\tscsw->actl = SCSW_ACTL_START_PEND;\n\t\tscsw->stctl = SCSW_STCTL_STATUS_PEND;\n\t} else if (type == FAKE_TM_IRB) {\n\t\tstruct tm_scsw *scsw = &irb->scsw.tm;\n\t\tscsw->x = 1;\n\t\tscsw->cc = 1;\n\t\tscsw->fctl = SCSW_FCTL_START_FUNC;\n\t\tscsw->actl = SCSW_ACTL_START_PEND;\n\t\tscsw->stctl = SCSW_STCTL_STATUS_PEND;\n\t}\n}\n\nstatic void ccw_device_handle_broken_paths(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\tu8 broken_paths = (sch->schib.pmcw.pam & sch->opm) ^ sch->vpm;\n\n\tif (broken_paths && (cdev->private->path_broken_mask != broken_paths))\n\t\tccw_device_schedule_recovery();\n\n\tcdev->private->path_broken_mask = broken_paths;\n}\n\nvoid ccw_device_verify_done(struct ccw_device *cdev, int err)\n{\n\tstruct subchannel *sch;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\t \n\tif (cio_update_schib(sch)) {\n\t\terr = -ENODEV;\n\t\tgoto callback;\n\t}\n\t \n\tsch->lpm = sch->vpm;\n\t \n\tif (cdev->private->flags.doverify) {\n\t\tccw_device_verify_start(cdev);\n\t\treturn;\n\t}\ncallback:\n\tswitch (err) {\n\tcase 0:\n\t\tccw_device_done(cdev, DEV_STATE_ONLINE);\n\t\t \n\t\tif (cdev->private->flags.fake_irb) {\n\t\t\tcreate_fake_irb(&cdev->private->dma_area->irb,\n\t\t\t\t\tcdev->private->flags.fake_irb);\n\t\t\tcdev->private->flags.fake_irb = 0;\n\t\t\tif (cdev->handler)\n\t\t\t\tcdev->handler(cdev, cdev->private->intparm,\n\t\t\t\t\t      &cdev->private->dma_area->irb);\n\t\t\tmemset(&cdev->private->dma_area->irb, 0,\n\t\t\t       sizeof(struct irb));\n\t\t}\n\t\tccw_device_report_path_events(cdev);\n\t\tccw_device_handle_broken_paths(cdev);\n\t\tbreak;\n\tcase -ETIME:\n\tcase -EUSERS:\n\t\t \n\t\tcdev->private->flags.donotify = 0;\n\t\tccw_device_done(cdev, DEV_STATE_BOXED);\n\t\tbreak;\n\tcase -EACCES:\n\t\t \n\t\tcdev->private->flags.donotify = 0;\n\t\tccw_device_done(cdev, DEV_STATE_DISCONNECTED);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tcdev->private->flags.donotify = 0;\n\t\tccw_device_done(cdev, DEV_STATE_NOT_OPER);\n\t\tbreak;\n\t}\n\tccw_device_reset_path_events(cdev);\n}\n\n \nint\nccw_device_online(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\tint ret;\n\n\tif ((cdev->private->state != DEV_STATE_OFFLINE) &&\n\t    (cdev->private->state != DEV_STATE_BOXED))\n\t\treturn -EINVAL;\n\tsch = to_subchannel(cdev->dev.parent);\n\tret = cio_enable_subchannel(sch, (u32)virt_to_phys(sch));\n\tif (ret != 0) {\n\t\t \n\t\tif (ret == -ENODEV)\n\t\t\tdev_fsm_event(cdev, DEV_EVENT_NOTOPER);\n\t\treturn ret;\n\t}\n\t \n\tcdev->private->state = DEV_STATE_VERIFY;\n\tccw_device_verify_start(cdev);\n\treturn 0;\n}\n\nvoid\nccw_device_disband_done(struct ccw_device *cdev, int err)\n{\n\tswitch (err) {\n\tcase 0:\n\t\tccw_device_done(cdev, DEV_STATE_OFFLINE);\n\t\tbreak;\n\tcase -ETIME:\n\t\tccw_device_done(cdev, DEV_STATE_BOXED);\n\t\tbreak;\n\tdefault:\n\t\tcdev->private->flags.donotify = 0;\n\t\tccw_device_done(cdev, DEV_STATE_NOT_OPER);\n\t\tbreak;\n\t}\n}\n\n \nint\nccw_device_offline(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\n\t \n\tif (cdev->private->state == DEV_STATE_DISCONNECTED ||\n\t    cdev->private->state == DEV_STATE_NOT_OPER) {\n\t\tcdev->private->flags.donotify = 0;\n\t\tccw_device_done(cdev, DEV_STATE_NOT_OPER);\n\t\treturn 0;\n\t}\n\tif (cdev->private->state == DEV_STATE_BOXED) {\n\t\tccw_device_done(cdev, DEV_STATE_BOXED);\n\t\treturn 0;\n\t}\n\tif (ccw_device_is_orphan(cdev)) {\n\t\tccw_device_done(cdev, DEV_STATE_OFFLINE);\n\t\treturn 0;\n\t}\n\tsch = to_subchannel(cdev->dev.parent);\n\tif (cio_update_schib(sch))\n\t\treturn -ENODEV;\n\tif (scsw_actl(&sch->schib.scsw) != 0)\n\t\treturn -EBUSY;\n\tif (cdev->private->state != DEV_STATE_ONLINE)\n\t\treturn -EINVAL;\n\t \n\tif (!cdev->private->flags.pgroup) {\n\t\t \n\t\tccw_device_done(cdev, DEV_STATE_OFFLINE);\n\t\treturn 0;\n\t}\n\t \n\tcdev->private->state = DEV_STATE_DISBAND_PGID;\n\tccw_device_disband_start(cdev);\n\treturn 0;\n}\n\n \nstatic void ccw_device_generic_notoper(struct ccw_device *cdev,\n\t\t\t\t       enum dev_event dev_event)\n{\n\tif (ccw_device_notify(cdev, CIO_GONE) != NOTIFY_OK)\n\t\tccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\n\telse\n\t\tccw_device_set_disconnected(cdev);\n}\n\n \nstatic void ccw_device_offline_verify(struct ccw_device *cdev,\n\t\t\t\t      enum dev_event dev_event)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\tcss_schedule_eval(sch->schid);\n}\n\n \nstatic void\nccw_device_online_verify(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tstruct subchannel *sch;\n\n\tif (cdev->private->state == DEV_STATE_W4SENSE) {\n\t\tcdev->private->flags.doverify = 1;\n\t\treturn;\n\t}\n\tsch = to_subchannel(cdev->dev.parent);\n\t \n\tif (cio_update_schib(sch)) {\n\t\tccw_device_verify_done(cdev, -ENODEV);\n\t\treturn;\n\t}\n\n\tif (scsw_actl(&sch->schib.scsw) != 0 ||\n\t    (scsw_stctl(&sch->schib.scsw) & SCSW_STCTL_STATUS_PEND) ||\n\t    (scsw_stctl(&cdev->private->dma_area->irb.scsw) &\n\t     SCSW_STCTL_STATUS_PEND)) {\n\t\t \n\t\tcdev->private->flags.doverify = 1;\n\t\treturn;\n\t}\n\t \n\tcdev->private->state = DEV_STATE_VERIFY;\n\tccw_device_verify_start(cdev);\n}\n\n \nstatic void ccw_device_boxed_verify(struct ccw_device *cdev,\n\t\t\t\t    enum dev_event dev_event)\n{\n\tstruct subchannel *sch = to_subchannel(cdev->dev.parent);\n\n\tif (cdev->online) {\n\t\tif (cio_enable_subchannel(sch, (u32)virt_to_phys(sch)))\n\t\t\tccw_device_done(cdev, DEV_STATE_NOT_OPER);\n\t\telse\n\t\t\tccw_device_online_verify(cdev, dev_event);\n\t} else\n\t\tcss_schedule_eval(sch->schid);\n}\n\n \nstatic int ccw_device_call_handler(struct ccw_device *cdev)\n{\n\tunsigned int stctl;\n\tint ending_status;\n\n\t \n\tstctl = scsw_stctl(&cdev->private->dma_area->irb.scsw);\n\tending_status = (stctl & SCSW_STCTL_SEC_STATUS) ||\n\t\t(stctl == (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)) ||\n\t\t(stctl == SCSW_STCTL_STATUS_PEND);\n\tif (!ending_status &&\n\t    !cdev->private->options.repall &&\n\t    !(stctl & SCSW_STCTL_INTER_STATUS) &&\n\t    !(cdev->private->options.fast &&\n\t      (stctl & SCSW_STCTL_PRIM_STATUS)))\n\t\treturn 0;\n\n\tif (ending_status)\n\t\tccw_device_set_timeout(cdev, 0);\n\n\tif (cdev->handler)\n\t\tcdev->handler(cdev, cdev->private->intparm,\n\t\t\t      &cdev->private->dma_area->irb);\n\n\tmemset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));\n\treturn 1;\n}\n\n \nstatic void\nccw_device_irq(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tstruct irb *irb;\n\tint is_cmd;\n\n\tirb = this_cpu_ptr(&cio_irb);\n\tis_cmd = !scsw_is_tm(&irb->scsw);\n\t \n\tif (!scsw_is_solicited(&irb->scsw)) {\n\t\tif (is_cmd && (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) &&\n\t\t    !irb->esw.esw0.erw.cons) {\n\t\t\t \n\t\t\tif (ccw_device_do_sense(cdev, irb) != 0)\n\t\t\t\tgoto call_handler_unsol;\n\t\t\tmemcpy(&cdev->private->dma_area->irb, irb,\n\t\t\t       sizeof(struct irb));\n\t\t\tcdev->private->state = DEV_STATE_W4SENSE;\n\t\t\tcdev->private->intparm = 0;\n\t\t\treturn;\n\t\t}\ncall_handler_unsol:\n\t\tif (cdev->handler)\n\t\t\tcdev->handler (cdev, 0, irb);\n\t\tif (cdev->private->flags.doverify)\n\t\t\tccw_device_online_verify(cdev, 0);\n\t\treturn;\n\t}\n\t \n\tccw_device_accumulate_irb(cdev, irb);\n\tif (is_cmd && cdev->private->flags.dosense) {\n\t\tif (ccw_device_do_sense(cdev, irb) == 0) {\n\t\t\tcdev->private->state = DEV_STATE_W4SENSE;\n\t\t}\n\t\treturn;\n\t}\n\t \n\tif (ccw_device_call_handler(cdev) && cdev->private->flags.doverify)\n\t\t \n\t\tccw_device_online_verify(cdev, 0);\n}\n\n \nstatic void\nccw_device_online_timeout(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tint ret;\n\n\tccw_device_set_timeout(cdev, 0);\n\tcdev->private->iretry = 255;\n\tcdev->private->async_kill_io_rc = -ETIMEDOUT;\n\tret = ccw_device_cancel_halt_clear(cdev);\n\tif (ret == -EBUSY) {\n\t\tccw_device_set_timeout(cdev, 3*HZ);\n\t\tcdev->private->state = DEV_STATE_TIMEOUT_KILL;\n\t\treturn;\n\t}\n\tif (ret)\n\t\tdev_fsm_event(cdev, DEV_EVENT_NOTOPER);\n\telse if (cdev->handler)\n\t\tcdev->handler(cdev, cdev->private->intparm,\n\t\t\t      ERR_PTR(-ETIMEDOUT));\n}\n\n \nstatic void\nccw_device_w4sense(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tstruct irb *irb;\n\n\tirb = this_cpu_ptr(&cio_irb);\n\t \n\tif (scsw_stctl(&irb->scsw) ==\n\t    (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {\n\t\tif (scsw_cc(&irb->scsw) == 1)\n\t\t\t \n\t\t\tccw_device_do_sense(cdev, irb);\n\t\telse {\n\t\t\tCIO_MSG_EVENT(0, \"0.%x.%04x: unsolicited \"\n\t\t\t\t      \"interrupt during w4sense...\\n\",\n\t\t\t\t      cdev->private->dev_id.ssid,\n\t\t\t\t      cdev->private->dev_id.devno);\n\t\t\tif (cdev->handler)\n\t\t\t\tcdev->handler (cdev, 0, irb);\n\t\t}\n\t\treturn;\n\t}\n\t \n\tif (scsw_fctl(&irb->scsw) &\n\t    (SCSW_FCTL_CLEAR_FUNC | SCSW_FCTL_HALT_FUNC)) {\n\t\tcdev->private->flags.dosense = 0;\n\t\tmemset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));\n\t\tccw_device_accumulate_irb(cdev, irb);\n\t\tgoto call_handler;\n\t}\n\t \n\tccw_device_accumulate_basic_sense(cdev, irb);\n\tif (cdev->private->flags.dosense) {\n\t\t \n\t\tccw_device_do_sense(cdev, irb);\n\t\treturn;\n\t}\ncall_handler:\n\tcdev->private->state = DEV_STATE_ONLINE;\n\t \n\twake_up(&cdev->private->wait_q);\n\t \n\tif (ccw_device_call_handler(cdev) && cdev->private->flags.doverify)\n\t\t \n\t\tccw_device_online_verify(cdev, 0);\n}\n\nstatic void\nccw_device_killing_irq(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tccw_device_set_timeout(cdev, 0);\n\t \n\tccw_device_online_verify(cdev, 0);\n\t \n\tif (cdev->handler)\n\t\tcdev->handler(cdev, cdev->private->intparm,\n\t\t\t      ERR_PTR(cdev->private->async_kill_io_rc));\n}\n\nstatic void\nccw_device_killing_timeout(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tint ret;\n\n\tret = ccw_device_cancel_halt_clear(cdev);\n\tif (ret == -EBUSY) {\n\t\tccw_device_set_timeout(cdev, 3*HZ);\n\t\treturn;\n\t}\n\t \n\tccw_device_online_verify(cdev, 0);\n\tif (cdev->handler)\n\t\tcdev->handler(cdev, cdev->private->intparm,\n\t\t\t      ERR_PTR(cdev->private->async_kill_io_rc));\n}\n\nvoid ccw_device_kill_io(struct ccw_device *cdev)\n{\n\tint ret;\n\n\tccw_device_set_timeout(cdev, 0);\n\tcdev->private->iretry = 255;\n\tcdev->private->async_kill_io_rc = -EIO;\n\tret = ccw_device_cancel_halt_clear(cdev);\n\tif (ret == -EBUSY) {\n\t\tccw_device_set_timeout(cdev, 3*HZ);\n\t\tcdev->private->state = DEV_STATE_TIMEOUT_KILL;\n\t\treturn;\n\t}\n\t \n\tccw_device_online_verify(cdev, 0);\n\tif (cdev->handler)\n\t\tcdev->handler(cdev, cdev->private->intparm,\n\t\t\t      ERR_PTR(-EIO));\n}\n\nstatic void\nccw_device_delay_verify(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\t \n\tcdev->private->flags.doverify = 1;\n}\n\nstatic void\nccw_device_start_id(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tstruct subchannel *sch;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\tif (cio_enable_subchannel(sch, (u32)virt_to_phys(sch)) != 0)\n\t\t \n\t\treturn;\n\tcdev->private->state = DEV_STATE_DISCONNECTED_SENSE_ID;\n\tccw_device_sense_id_start(cdev);\n}\n\nvoid ccw_device_trigger_reprobe(struct ccw_device *cdev)\n{\n\tstruct subchannel *sch;\n\n\tif (cdev->private->state != DEV_STATE_DISCONNECTED)\n\t\treturn;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\t \n\tif (cio_update_schib(sch))\n\t\treturn;\n\t \n\tsch->lpm = sch->schib.pmcw.pam & sch->opm;\n\t \n\tio_subchannel_init_config(sch);\n\tif (cio_commit_config(sch))\n\t\treturn;\n\n\t \n\t \n\tif (sch->schib.pmcw.dev != cdev->private->dev_id.devno)\n\t\tcss_schedule_eval(sch->schid);\n\telse\n\t\tccw_device_start_id(cdev, 0);\n}\n\nstatic void ccw_device_disabled_irq(struct ccw_device *cdev,\n\t\t\t\t    enum dev_event dev_event)\n{\n\tstruct subchannel *sch;\n\n\tsch = to_subchannel(cdev->dev.parent);\n\t \n\tcio_disable_subchannel(sch);\n}\n\nstatic void\nccw_device_change_cmfstate(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tretry_set_schib(cdev);\n\tcdev->private->state = DEV_STATE_ONLINE;\n\tdev_fsm_event(cdev, dev_event);\n}\n\nstatic void ccw_device_update_cmfblock(struct ccw_device *cdev,\n\t\t\t\t       enum dev_event dev_event)\n{\n\tcmf_retry_copy_block(cdev);\n\tcdev->private->state = DEV_STATE_ONLINE;\n\tdev_fsm_event(cdev, dev_event);\n}\n\nstatic void\nccw_device_quiesce_done(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tccw_device_set_timeout(cdev, 0);\n\tcdev->private->state = DEV_STATE_NOT_OPER;\n\twake_up(&cdev->private->wait_q);\n}\n\nstatic void\nccw_device_quiesce_timeout(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tint ret;\n\n\tret = ccw_device_cancel_halt_clear(cdev);\n\tif (ret == -EBUSY) {\n\t\tccw_device_set_timeout(cdev, HZ/10);\n\t} else {\n\t\tcdev->private->state = DEV_STATE_NOT_OPER;\n\t\twake_up(&cdev->private->wait_q);\n\t}\n}\n\n \nstatic void\nccw_device_nop(struct ccw_device *cdev, enum dev_event dev_event)\n{\n}\n\n \nfsm_func_t *dev_jumptable[NR_DEV_STATES][NR_DEV_EVENTS] = {\n\t[DEV_STATE_NOT_OPER] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_nop,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_disabled_irq,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_nop,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_nop,\n\t},\n\t[DEV_STATE_SENSE_ID] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_nop,\n\t},\n\t[DEV_STATE_OFFLINE] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_generic_notoper,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_disabled_irq,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_nop,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_offline_verify,\n\t},\n\t[DEV_STATE_VERIFY] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_delay_verify,\n\t},\n\t[DEV_STATE_ONLINE] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_generic_notoper,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_irq,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_online_timeout,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_online_verify,\n\t},\n\t[DEV_STATE_W4SENSE] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_generic_notoper,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_w4sense,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_nop,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_online_verify,\n\t},\n\t[DEV_STATE_DISBAND_PGID] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_nop,\n\t},\n\t[DEV_STATE_BOXED] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_generic_notoper,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_nop,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_nop,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_boxed_verify,\n\t},\n\t \n\t[DEV_STATE_TIMEOUT_KILL] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_generic_notoper,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_killing_irq,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_killing_timeout,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_nop, \n\t},\n\t[DEV_STATE_QUIESCE] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_quiesce_done,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_quiesce_done,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_quiesce_timeout,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_nop,\n\t},\n\t \n\t[DEV_STATE_DISCONNECTED] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_nop,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_start_id,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_nop,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_start_id,\n\t},\n\t[DEV_STATE_DISCONNECTED_SENSE_ID] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_nop,\n\t},\n\t[DEV_STATE_CMFCHANGE] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_change_cmfstate,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_change_cmfstate,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_change_cmfstate,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_change_cmfstate,\n\t},\n\t[DEV_STATE_CMFUPDATE] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_update_cmfblock,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_update_cmfblock,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_update_cmfblock,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_update_cmfblock,\n\t},\n\t[DEV_STATE_STEAL_LOCK] = {\n\t\t[DEV_EVENT_NOTOPER]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_INTERRUPT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_TIMEOUT]\t= ccw_device_request_event,\n\t\t[DEV_EVENT_VERIFY]\t= ccw_device_nop,\n\t},\n};\n\nEXPORT_SYMBOL_GPL(ccw_device_set_timeout);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}