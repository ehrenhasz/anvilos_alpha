{
  "module_name": "ccwgroup.c",
  "hash_id": "293fa8f82daa9a46b5de53304a9a0f0fb42579d72be3f68c489ce66d4c640d3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/ccwgroup.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/dcache.h>\n\n#include <asm/cio.h>\n#include <asm/ccwdev.h>\n#include <asm/ccwgroup.h>\n\n#include \"device.h\"\n\n#define CCW_BUS_ID_SIZE\t\t10\n\n \n\nstatic struct bus_type ccwgroup_bus_type;\n\nstatic void __ccwgroup_remove_symlinks(struct ccwgroup_device *gdev)\n{\n\tint i;\n\tchar str[16];\n\n\tfor (i = 0; i < gdev->count; i++) {\n\t\tsprintf(str, \"cdev%d\", i);\n\t\tsysfs_remove_link(&gdev->dev.kobj, str);\n\t\tsysfs_remove_link(&gdev->cdev[i]->dev.kobj, \"group_device\");\n\t}\n}\n\n \nint ccwgroup_set_online(struct ccwgroup_device *gdev)\n{\n\tstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\n\tint ret = -EINVAL;\n\n\tif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\n\t\treturn -EAGAIN;\n\tif (gdev->state == CCWGROUP_ONLINE)\n\t\tgoto out;\n\tif (gdrv->set_online)\n\t\tret = gdrv->set_online(gdev);\n\tif (ret)\n\t\tgoto out;\n\n\tgdev->state = CCWGROUP_ONLINE;\nout:\n\tatomic_set(&gdev->onoff, 0);\n\treturn ret;\n}\nEXPORT_SYMBOL(ccwgroup_set_online);\n\n \nint ccwgroup_set_offline(struct ccwgroup_device *gdev, bool call_gdrv)\n{\n\tstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\n\tint ret = -EINVAL;\n\n\tif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\n\t\treturn -EAGAIN;\n\tif (gdev->state == CCWGROUP_OFFLINE)\n\t\tgoto out;\n\tif (!call_gdrv) {\n\t\tret = 0;\n\t\tgoto offline;\n\t}\n\tif (gdrv->set_offline)\n\t\tret = gdrv->set_offline(gdev);\n\tif (ret)\n\t\tgoto out;\n\noffline:\n\tgdev->state = CCWGROUP_OFFLINE;\nout:\n\tatomic_set(&gdev->onoff, 0);\n\treturn ret;\n}\nEXPORT_SYMBOL(ccwgroup_set_offline);\n\nstatic ssize_t ccwgroup_online_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\n\tunsigned long value;\n\tint ret;\n\n\tdevice_lock(dev);\n\tif (!dev->driver) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kstrtoul(buf, 0, &value);\n\tif (ret)\n\t\tgoto out;\n\n\tif (value == 1)\n\t\tret = ccwgroup_set_online(gdev);\n\telse if (value == 0)\n\t\tret = ccwgroup_set_offline(gdev, true);\n\telse\n\t\tret = -EINVAL;\nout:\n\tdevice_unlock(dev);\n\treturn (ret == 0) ? count : ret;\n}\n\nstatic ssize_t ccwgroup_online_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\n\tint online;\n\n\tonline = (gdev->state == CCWGROUP_ONLINE) ? 1 : 0;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", online);\n}\n\n \nstatic void ccwgroup_ungroup(struct ccwgroup_device *gdev)\n{\n\tmutex_lock(&gdev->reg_mutex);\n\tif (device_is_registered(&gdev->dev)) {\n\t\t__ccwgroup_remove_symlinks(gdev);\n\t\tdevice_unregister(&gdev->dev);\n\t}\n\tmutex_unlock(&gdev->reg_mutex);\n}\n\nstatic ssize_t ccwgroup_ungroup_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\n\tint rc = 0;\n\n\t \n\tif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\n\t\treturn -EAGAIN;\n\tif (gdev->state != CCWGROUP_OFFLINE) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (device_remove_file_self(dev, attr))\n\t\tccwgroup_ungroup(gdev);\n\telse\n\t\trc = -ENODEV;\nout:\n\tif (rc) {\n\t\t \n\t\tatomic_set(&gdev->onoff, 0);\n\t\treturn rc;\n\t}\n\treturn count;\n}\nstatic DEVICE_ATTR(ungroup, 0200, NULL, ccwgroup_ungroup_store);\nstatic DEVICE_ATTR(online, 0644, ccwgroup_online_show, ccwgroup_online_store);\n\nstatic struct attribute *ccwgroup_dev_attrs[] = {\n\t&dev_attr_online.attr,\n\t&dev_attr_ungroup.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ccwgroup_dev);\n\nstatic void ccwgroup_ungroup_workfn(struct work_struct *work)\n{\n\tstruct ccwgroup_device *gdev =\n\t\tcontainer_of(work, struct ccwgroup_device, ungroup_work);\n\n\tccwgroup_ungroup(gdev);\n\tput_device(&gdev->dev);\n}\n\nstatic void ccwgroup_release(struct device *dev)\n{\n\tstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\n\tunsigned int i;\n\n\tfor (i = 0; i < gdev->count; i++) {\n\t\tstruct ccw_device *cdev = gdev->cdev[i];\n\t\tunsigned long flags;\n\n\t\tif (cdev) {\n\t\t\tspin_lock_irqsave(cdev->ccwlock, flags);\n\t\t\tif (dev_get_drvdata(&cdev->dev) == gdev)\n\t\t\t\tdev_set_drvdata(&cdev->dev, NULL);\n\t\t\tspin_unlock_irqrestore(cdev->ccwlock, flags);\n\t\t\tput_device(&cdev->dev);\n\t\t}\n\t}\n\n\tkfree(gdev);\n}\n\nstatic int __ccwgroup_create_symlinks(struct ccwgroup_device *gdev)\n{\n\tchar str[16];\n\tint i, rc;\n\n\tfor (i = 0; i < gdev->count; i++) {\n\t\trc = sysfs_create_link(&gdev->cdev[i]->dev.kobj,\n\t\t\t\t       &gdev->dev.kobj, \"group_device\");\n\t\tif (rc) {\n\t\t\tfor (--i; i >= 0; i--)\n\t\t\t\tsysfs_remove_link(&gdev->cdev[i]->dev.kobj,\n\t\t\t\t\t\t  \"group_device\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\tfor (i = 0; i < gdev->count; i++) {\n\t\tsprintf(str, \"cdev%d\", i);\n\t\trc = sysfs_create_link(&gdev->dev.kobj,\n\t\t\t\t       &gdev->cdev[i]->dev.kobj, str);\n\t\tif (rc) {\n\t\t\tfor (--i; i >= 0; i--) {\n\t\t\t\tsprintf(str, \"cdev%d\", i);\n\t\t\t\tsysfs_remove_link(&gdev->dev.kobj, str);\n\t\t\t}\n\t\t\tfor (i = 0; i < gdev->count; i++)\n\t\t\t\tsysfs_remove_link(&gdev->cdev[i]->dev.kobj,\n\t\t\t\t\t\t  \"group_device\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __get_next_id(const char **buf, struct ccw_dev_id *id)\n{\n\tunsigned int cssid, ssid, devno;\n\tint ret = 0, len;\n\tchar *start, *end;\n\n\tstart = (char *)*buf;\n\tend = strchr(start, ',');\n\tif (!end) {\n\t\t \n\t\tend = strchr(start, '\\n');\n\t\tif (end)\n\t\t\t*end = '\\0';\n\t\tlen = strlen(start) + 1;\n\t} else {\n\t\tlen = end - start + 1;\n\t\tend++;\n\t}\n\tif (len <= CCW_BUS_ID_SIZE) {\n\t\tif (sscanf(start, \"%2x.%1x.%04x\", &cssid, &ssid, &devno) != 3)\n\t\t\tret = -EINVAL;\n\t} else\n\t\tret = -EINVAL;\n\n\tif (!ret) {\n\t\tid->ssid = ssid;\n\t\tid->devno = devno;\n\t}\n\t*buf = end;\n\treturn ret;\n}\n\n \nint ccwgroup_create_dev(struct device *parent, struct ccwgroup_driver *gdrv,\n\t\t\tint num_devices, const char *buf)\n{\n\tstruct ccwgroup_device *gdev;\n\tstruct ccw_dev_id dev_id;\n\tint rc, i;\n\n\tif (num_devices < 1)\n\t\treturn -EINVAL;\n\n\tgdev = kzalloc(struct_size(gdev, cdev, num_devices), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&gdev->onoff, 0);\n\tmutex_init(&gdev->reg_mutex);\n\tmutex_lock(&gdev->reg_mutex);\n\tINIT_WORK(&gdev->ungroup_work, ccwgroup_ungroup_workfn);\n\tgdev->count = num_devices;\n\tgdev->dev.bus = &ccwgroup_bus_type;\n\tgdev->dev.parent = parent;\n\tgdev->dev.release = ccwgroup_release;\n\tdevice_initialize(&gdev->dev);\n\n\tfor (i = 0; i < num_devices && buf; i++) {\n\t\trc = __get_next_id(&buf, &dev_id);\n\t\tif (rc != 0)\n\t\t\tgoto error;\n\t\tgdev->cdev[i] = get_ccwdev_by_dev_id(&dev_id);\n\t\t \n\t\tif (!gdev->cdev[i] || !gdev->cdev[i]->drv ||\n\t\t    gdev->cdev[i]->drv != gdev->cdev[0]->drv ||\n\t\t    gdev->cdev[i]->id.driver_info !=\n\t\t    gdev->cdev[0]->id.driver_info) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\t \n\t\tspin_lock_irq(gdev->cdev[i]->ccwlock);\n\t\tif (dev_get_drvdata(&gdev->cdev[i]->dev)) {\n\t\t\tspin_unlock_irq(gdev->cdev[i]->ccwlock);\n\t\t\trc = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tdev_set_drvdata(&gdev->cdev[i]->dev, gdev);\n\t\tspin_unlock_irq(gdev->cdev[i]->ccwlock);\n\t}\n\t \n\tif (i < num_devices) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\t \n\tif (i == num_devices && buf && strlen(buf) > 0) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\t \n\tif (gdrv && gdrv->ccw_driver &&\n\t    gdev->cdev[0]->drv != gdrv->ccw_driver) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdev_set_name(&gdev->dev, \"%s\", dev_name(&gdev->cdev[0]->dev));\n\n\tif (gdrv) {\n\t\tgdev->dev.driver = &gdrv->driver;\n\t\trc = gdrv->setup ? gdrv->setup(gdev) : 0;\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\trc = device_add(&gdev->dev);\n\tif (rc)\n\t\tgoto error;\n\trc = __ccwgroup_create_symlinks(gdev);\n\tif (rc) {\n\t\tdevice_del(&gdev->dev);\n\t\tgoto error;\n\t}\n\tmutex_unlock(&gdev->reg_mutex);\n\treturn 0;\nerror:\n\tmutex_unlock(&gdev->reg_mutex);\n\tput_device(&gdev->dev);\n\treturn rc;\n}\nEXPORT_SYMBOL(ccwgroup_create_dev);\n\nstatic int ccwgroup_notifier(struct notifier_block *nb, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct ccwgroup_device *gdev = to_ccwgroupdev(data);\n\n\tif (action == BUS_NOTIFY_UNBOUND_DRIVER) {\n\t\tget_device(&gdev->dev);\n\t\tschedule_work(&gdev->ungroup_work);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block ccwgroup_nb = {\n\t.notifier_call = ccwgroup_notifier\n};\n\nstatic int __init init_ccwgroup(void)\n{\n\tint ret;\n\n\tret = bus_register(&ccwgroup_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bus_register_notifier(&ccwgroup_bus_type, &ccwgroup_nb);\n\tif (ret)\n\t\tbus_unregister(&ccwgroup_bus_type);\n\n\treturn ret;\n}\n\nstatic void __exit cleanup_ccwgroup(void)\n{\n\tbus_unregister_notifier(&ccwgroup_bus_type, &ccwgroup_nb);\n\tbus_unregister(&ccwgroup_bus_type);\n}\n\nmodule_init(init_ccwgroup);\nmodule_exit(cleanup_ccwgroup);\n\n \n\nstatic void ccwgroup_remove(struct device *dev)\n{\n\tstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\n\tstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(dev->driver);\n\n\tif (gdrv->remove)\n\t\tgdrv->remove(gdev);\n}\n\nstatic void ccwgroup_shutdown(struct device *dev)\n{\n\tstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\n\tstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(dev->driver);\n\n\tif (!dev->driver)\n\t\treturn;\n\tif (gdrv->shutdown)\n\t\tgdrv->shutdown(gdev);\n}\n\nstatic struct bus_type ccwgroup_bus_type = {\n\t.name   = \"ccwgroup\",\n\t.dev_groups = ccwgroup_dev_groups,\n\t.remove = ccwgroup_remove,\n\t.shutdown = ccwgroup_shutdown,\n};\n\nbool dev_is_ccwgroup(struct device *dev)\n{\n\treturn dev->bus == &ccwgroup_bus_type;\n}\nEXPORT_SYMBOL(dev_is_ccwgroup);\n\n \nint ccwgroup_driver_register(struct ccwgroup_driver *cdriver)\n{\n\t \n\tcdriver->driver.bus = &ccwgroup_bus_type;\n\n\treturn driver_register(&cdriver->driver);\n}\nEXPORT_SYMBOL(ccwgroup_driver_register);\n\n \nvoid ccwgroup_driver_unregister(struct ccwgroup_driver *cdriver)\n{\n\tdriver_unregister(&cdriver->driver);\n}\nEXPORT_SYMBOL(ccwgroup_driver_unregister);\n\n \nint ccwgroup_probe_ccwdev(struct ccw_device *cdev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(ccwgroup_probe_ccwdev);\n\n \nvoid ccwgroup_remove_ccwdev(struct ccw_device *cdev)\n{\n\tstruct ccwgroup_device *gdev;\n\n\t \n\tccw_device_set_offline(cdev);\n\t \n\tspin_lock_irq(cdev->ccwlock);\n\tgdev = dev_get_drvdata(&cdev->dev);\n\tif (!gdev) {\n\t\tspin_unlock_irq(cdev->ccwlock);\n\t\treturn;\n\t}\n\t \n\tget_device(&gdev->dev);\n\tspin_unlock_irq(cdev->ccwlock);\n\t \n\tccwgroup_ungroup(gdev);\n\t \n\tput_device(&gdev->dev);\n}\nEXPORT_SYMBOL(ccwgroup_remove_ccwdev);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}