{
  "module_name": "device.h",
  "hash_id": "10805f6283287d86fc2182c1ac2a8a5a8a7e3b07a733bfe580a78cc78dad6e79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/device.h",
  "human_readable_source": " \n#ifndef S390_DEVICE_H\n#define S390_DEVICE_H\n\n#include <asm/ccwdev.h>\n#include <linux/atomic.h>\n#include <linux/timer.h>\n#include <linux/wait.h>\n#include <linux/notifier.h>\n#include <linux/kernel_stat.h>\n#include \"io_sch.h\"\n\n \nenum dev_state {\n\tDEV_STATE_NOT_OPER,\n\tDEV_STATE_SENSE_ID,\n\tDEV_STATE_OFFLINE,\n\tDEV_STATE_VERIFY,\n\tDEV_STATE_ONLINE,\n\tDEV_STATE_W4SENSE,\n\tDEV_STATE_DISBAND_PGID,\n\tDEV_STATE_BOXED,\n\t \n\tDEV_STATE_TIMEOUT_KILL,\n\tDEV_STATE_QUIESCE,\n\t \n\tDEV_STATE_DISCONNECTED,\n\tDEV_STATE_DISCONNECTED_SENSE_ID,\n\tDEV_STATE_CMFCHANGE,\n\tDEV_STATE_CMFUPDATE,\n\tDEV_STATE_STEAL_LOCK,\n\t \n\tNR_DEV_STATES\n};\n\n \nenum dev_event {\n\tDEV_EVENT_NOTOPER,\n\tDEV_EVENT_INTERRUPT,\n\tDEV_EVENT_TIMEOUT,\n\tDEV_EVENT_VERIFY,\n\t \n\tNR_DEV_EVENTS\n};\n\nstruct ccw_device;\n\n \ntypedef void (fsm_func_t)(struct ccw_device *, enum dev_event);\nextern fsm_func_t *dev_jumptable[NR_DEV_STATES][NR_DEV_EVENTS];\n\nstatic inline void\ndev_fsm_event(struct ccw_device *cdev, enum dev_event dev_event)\n{\n\tint state = cdev->private->state;\n\n\tif (dev_event == DEV_EVENT_INTERRUPT) {\n\t\tif (state == DEV_STATE_ONLINE)\n\t\t\tinc_irq_stat(cdev->private->int_class);\n\t\telse if (state != DEV_STATE_CMFCHANGE &&\n\t\t\t state != DEV_STATE_CMFUPDATE)\n\t\t\tinc_irq_stat(IRQIO_CIO);\n\t}\n\tdev_jumptable[state][dev_event](cdev, dev_event);\n}\n\n \nstatic inline int\ndev_fsm_final_state(struct ccw_device *cdev)\n{\n\treturn (cdev->private->state == DEV_STATE_NOT_OPER ||\n\t\tcdev->private->state == DEV_STATE_OFFLINE ||\n\t\tcdev->private->state == DEV_STATE_ONLINE ||\n\t\tcdev->private->state == DEV_STATE_BOXED);\n}\n\nint __init io_subchannel_init(void);\n\nvoid io_subchannel_recog_done(struct ccw_device *cdev);\nvoid io_subchannel_init_config(struct subchannel *sch);\n\nint ccw_device_cancel_halt_clear(struct ccw_device *);\n\nint ccw_device_is_orphan(struct ccw_device *);\n\nvoid ccw_device_recognition(struct ccw_device *);\nint ccw_device_online(struct ccw_device *);\nint ccw_device_offline(struct ccw_device *);\nvoid ccw_device_update_sense_data(struct ccw_device *);\nint ccw_device_test_sense_data(struct ccw_device *);\nint ccw_purge_blacklisted(void);\nvoid ccw_device_sched_todo(struct ccw_device *cdev, enum cdev_todo todo);\nstruct ccw_device *get_ccwdev_by_dev_id(struct ccw_dev_id *dev_id);\n\n \nvoid ccw_device_accumulate_irb(struct ccw_device *, struct irb *);\nvoid ccw_device_accumulate_basic_sense(struct ccw_device *, struct irb *);\nint ccw_device_accumulate_and_sense(struct ccw_device *, struct irb *);\nint ccw_device_do_sense(struct ccw_device *, struct irb *);\n\n \nint lpm_adjust(int lpm, int mask);\nvoid ccw_request_start(struct ccw_device *);\nint ccw_request_cancel(struct ccw_device *cdev);\nvoid ccw_request_handler(struct ccw_device *cdev);\nvoid ccw_request_timeout(struct ccw_device *cdev);\nvoid ccw_request_notoper(struct ccw_device *cdev);\n\n \nvoid ccw_device_sense_id_start(struct ccw_device *);\nvoid ccw_device_sense_id_done(struct ccw_device *, int);\n\n \nvoid ccw_device_verify_start(struct ccw_device *);\nvoid ccw_device_verify_done(struct ccw_device *, int);\n\nvoid ccw_device_disband_start(struct ccw_device *);\nvoid ccw_device_disband_done(struct ccw_device *, int);\n\nint ccw_device_stlck(struct ccw_device *);\n\n \nvoid ccw_device_trigger_reprobe(struct ccw_device *);\nvoid ccw_device_kill_io(struct ccw_device *);\nint ccw_device_notify(struct ccw_device *, int);\nvoid ccw_device_set_disconnected(struct ccw_device *cdev);\nvoid ccw_device_set_notoper(struct ccw_device *cdev);\n\nvoid ccw_device_timeout(struct timer_list *t);\nvoid ccw_device_set_timeout(struct ccw_device *, int);\nvoid ccw_device_schedule_recovery(void);\n\n \nvoid retry_set_schib(struct ccw_device *cdev);\nvoid cmf_retry_copy_block(struct ccw_device *);\nint cmf_reenable(struct ccw_device *);\nvoid cmf_reactivate(void);\nextern struct device_attribute dev_attr_cmb_enable;\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}