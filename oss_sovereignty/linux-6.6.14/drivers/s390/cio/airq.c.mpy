{
  "module_name": "airq.c",
  "hash_id": "60eb4db59881c61ac4e8fd6878b69eb8d69f36d49e923e77b9818f782e8be5bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/airq.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/kernel_stat.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/dmapool.h>\n\n#include <asm/airq.h>\n#include <asm/isc.h>\n#include <asm/cio.h>\n\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"ioasm.h\"\n\nstatic DEFINE_SPINLOCK(airq_lists_lock);\nstatic struct hlist_head airq_lists[MAX_ISC+1];\n\nstatic struct dma_pool *airq_iv_cache;\n\n \nint register_adapter_interrupt(struct airq_struct *airq)\n{\n\tchar dbf_txt[32];\n\n\tif (!airq->handler || airq->isc > MAX_ISC)\n\t\treturn -EINVAL;\n\tif (!airq->lsi_ptr) {\n\t\tairq->lsi_ptr = cio_dma_zalloc(1);\n\t\tif (!airq->lsi_ptr)\n\t\t\treturn -ENOMEM;\n\t\tairq->flags |= AIRQ_PTR_ALLOCATED;\n\t}\n\tsnprintf(dbf_txt, sizeof(dbf_txt), \"rairq:%p\", airq);\n\tCIO_TRACE_EVENT(4, dbf_txt);\n\tisc_register(airq->isc);\n\tspin_lock(&airq_lists_lock);\n\thlist_add_head_rcu(&airq->list, &airq_lists[airq->isc]);\n\tspin_unlock(&airq_lists_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(register_adapter_interrupt);\n\n \nvoid unregister_adapter_interrupt(struct airq_struct *airq)\n{\n\tchar dbf_txt[32];\n\n\tif (hlist_unhashed(&airq->list))\n\t\treturn;\n\tsnprintf(dbf_txt, sizeof(dbf_txt), \"urairq:%p\", airq);\n\tCIO_TRACE_EVENT(4, dbf_txt);\n\tspin_lock(&airq_lists_lock);\n\thlist_del_rcu(&airq->list);\n\tspin_unlock(&airq_lists_lock);\n\tsynchronize_rcu();\n\tisc_unregister(airq->isc);\n\tif (airq->flags & AIRQ_PTR_ALLOCATED) {\n\t\tcio_dma_free(airq->lsi_ptr, 1);\n\t\tairq->lsi_ptr = NULL;\n\t\tairq->flags &= ~AIRQ_PTR_ALLOCATED;\n\t}\n}\nEXPORT_SYMBOL(unregister_adapter_interrupt);\n\nstatic irqreturn_t do_airq_interrupt(int irq, void *dummy)\n{\n\tstruct tpi_info *tpi_info;\n\tstruct airq_struct *airq;\n\tstruct hlist_head *head;\n\n\tset_cpu_flag(CIF_NOHZ_DELAY);\n\ttpi_info = &get_irq_regs()->tpi_info;\n\ttrace_s390_cio_adapter_int(tpi_info);\n\thead = &airq_lists[tpi_info->isc];\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(airq, head, list)\n\t\tif (*airq->lsi_ptr != 0)\n\t\t\tairq->handler(airq, tpi_info);\n\trcu_read_unlock();\n\n\treturn IRQ_HANDLED;\n}\n\nvoid __init init_airq_interrupts(void)\n{\n\tirq_set_chip_and_handler(THIN_INTERRUPT,\n\t\t\t\t &dummy_irq_chip, handle_percpu_irq);\n\tif (request_irq(THIN_INTERRUPT, do_airq_interrupt, 0, \"AIO\", NULL))\n\t\tpanic(\"Failed to register AIO interrupt\\n\");\n}\n\nstatic inline unsigned long iv_size(unsigned long bits)\n{\n\treturn BITS_TO_LONGS(bits) * sizeof(unsigned long);\n}\n\n \nstruct airq_iv *airq_iv_create(unsigned long bits, unsigned long flags,\n\t\t\t       unsigned long *vec)\n{\n\tstruct airq_iv *iv;\n\tunsigned long size;\n\n\tiv = kzalloc(sizeof(*iv), GFP_KERNEL);\n\tif (!iv)\n\t\tgoto out;\n\tiv->bits = bits;\n\tiv->flags = flags;\n\tsize = iv_size(bits);\n\n\tif (flags & AIRQ_IV_CACHELINE) {\n\t\tif ((cache_line_size() * BITS_PER_BYTE) < bits\n\t\t\t\t|| !airq_iv_cache)\n\t\t\tgoto out_free;\n\n\t\tiv->vector = dma_pool_zalloc(airq_iv_cache, GFP_KERNEL,\n\t\t\t\t\t     &iv->vector_dma);\n\t\tif (!iv->vector)\n\t\t\tgoto out_free;\n\t} else if (flags & AIRQ_IV_GUESTVEC) {\n\t\tiv->vector = vec;\n\t} else {\n\t\tiv->vector = cio_dma_zalloc(size);\n\t\tif (!iv->vector)\n\t\t\tgoto out_free;\n\t}\n\tif (flags & AIRQ_IV_ALLOC) {\n\t\tiv->avail = kmalloc(size, GFP_KERNEL);\n\t\tif (!iv->avail)\n\t\t\tgoto out_free;\n\t\tmemset(iv->avail, 0xff, size);\n\t\tiv->end = 0;\n\t} else\n\t\tiv->end = bits;\n\tif (flags & AIRQ_IV_BITLOCK) {\n\t\tiv->bitlock = kzalloc(size, GFP_KERNEL);\n\t\tif (!iv->bitlock)\n\t\t\tgoto out_free;\n\t}\n\tif (flags & AIRQ_IV_PTR) {\n\t\tsize = bits * sizeof(unsigned long);\n\t\tiv->ptr = kzalloc(size, GFP_KERNEL);\n\t\tif (!iv->ptr)\n\t\t\tgoto out_free;\n\t}\n\tif (flags & AIRQ_IV_DATA) {\n\t\tsize = bits * sizeof(unsigned int);\n\t\tiv->data = kzalloc(size, GFP_KERNEL);\n\t\tif (!iv->data)\n\t\t\tgoto out_free;\n\t}\n\tspin_lock_init(&iv->lock);\n\treturn iv;\n\nout_free:\n\tkfree(iv->ptr);\n\tkfree(iv->bitlock);\n\tkfree(iv->avail);\n\tif (iv->flags & AIRQ_IV_CACHELINE && iv->vector)\n\t\tdma_pool_free(airq_iv_cache, iv->vector, iv->vector_dma);\n\telse if (!(iv->flags & AIRQ_IV_GUESTVEC))\n\t\tcio_dma_free(iv->vector, size);\n\tkfree(iv);\nout:\n\treturn NULL;\n}\nEXPORT_SYMBOL(airq_iv_create);\n\n \nvoid airq_iv_release(struct airq_iv *iv)\n{\n\tkfree(iv->data);\n\tkfree(iv->ptr);\n\tkfree(iv->bitlock);\n\tif (iv->flags & AIRQ_IV_CACHELINE)\n\t\tdma_pool_free(airq_iv_cache, iv->vector, iv->vector_dma);\n\telse if (!(iv->flags & AIRQ_IV_GUESTVEC))\n\t\tcio_dma_free(iv->vector, iv_size(iv->bits));\n\tkfree(iv->avail);\n\tkfree(iv);\n}\nEXPORT_SYMBOL(airq_iv_release);\n\n \nunsigned long airq_iv_alloc(struct airq_iv *iv, unsigned long num)\n{\n\tunsigned long bit, i, flags;\n\n\tif (!iv->avail || num == 0)\n\t\treturn -1UL;\n\tspin_lock_irqsave(&iv->lock, flags);\n\tbit = find_first_bit_inv(iv->avail, iv->bits);\n\twhile (bit + num <= iv->bits) {\n\t\tfor (i = 1; i < num; i++)\n\t\t\tif (!test_bit_inv(bit + i, iv->avail))\n\t\t\t\tbreak;\n\t\tif (i >= num) {\n\t\t\t \n\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\tclear_bit_inv(bit + i, iv->avail);\n\t\t\tif (bit + num >= iv->end)\n\t\t\t\tiv->end = bit + num + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbit = find_next_bit_inv(iv->avail, iv->bits, bit + i + 1);\n\t}\n\tif (bit + num > iv->bits)\n\t\tbit = -1UL;\n\tspin_unlock_irqrestore(&iv->lock, flags);\n\treturn bit;\n}\nEXPORT_SYMBOL(airq_iv_alloc);\n\n \nvoid airq_iv_free(struct airq_iv *iv, unsigned long bit, unsigned long num)\n{\n\tunsigned long i, flags;\n\n\tif (!iv->avail || num == 0)\n\t\treturn;\n\tspin_lock_irqsave(&iv->lock, flags);\n\tfor (i = 0; i < num; i++) {\n\t\t \n\t\tclear_bit_inv(bit + i, iv->vector);\n\t\t \n\t\tset_bit_inv(bit + i, iv->avail);\n\t}\n\tif (bit + num >= iv->end) {\n\t\t \n\t\twhile (iv->end > 0 && !test_bit_inv(iv->end - 1, iv->avail))\n\t\t\tiv->end--;\n\t}\n\tspin_unlock_irqrestore(&iv->lock, flags);\n}\nEXPORT_SYMBOL(airq_iv_free);\n\n \nunsigned long airq_iv_scan(struct airq_iv *iv, unsigned long start,\n\t\t\t   unsigned long end)\n{\n\tunsigned long bit;\n\n\t \n\tbit = find_next_bit_inv(iv->vector, end, start);\n\tif (bit >= end)\n\t\treturn -1UL;\n\tclear_bit_inv(bit, iv->vector);\n\treturn bit;\n}\nEXPORT_SYMBOL(airq_iv_scan);\n\nint __init airq_init(void)\n{\n\tairq_iv_cache = dma_pool_create(\"airq_iv_cache\", cio_get_dma_css_dev(),\n\t\t\t\t\tcache_line_size(),\n\t\t\t\t\tcache_line_size(), PAGE_SIZE);\n\tif (!airq_iv_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}