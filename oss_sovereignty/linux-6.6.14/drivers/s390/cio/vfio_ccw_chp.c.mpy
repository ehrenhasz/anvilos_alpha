{
  "module_name": "vfio_ccw_chp.c",
  "hash_id": "b3e212f20c86c43e93983c57ba764d4b966ee42d318d240a4456666c7e118fe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/vfio_ccw_chp.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/vfio.h>\n#include \"vfio_ccw_private.h\"\n\nstatic ssize_t vfio_ccw_schib_region_read(struct vfio_ccw_private *private,\n\t\t\t\t\t  char __user *buf, size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct subchannel *sch = to_subchannel(private->vdev.dev->parent);\n\tunsigned int i = VFIO_CCW_OFFSET_TO_INDEX(*ppos) - VFIO_CCW_NUM_REGIONS;\n\tloff_t pos = *ppos & VFIO_CCW_OFFSET_MASK;\n\tstruct ccw_schib_region *region;\n\tint ret;\n\n\tif (pos + count > sizeof(*region))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&private->io_mutex);\n\tregion = private->region[i].data;\n\n\tif (cio_update_schib(sch)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tmemcpy(region, &sch->schib, sizeof(*region));\n\n\tif (copy_to_user(buf, (void *)region + pos, count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tret = count;\n\nout:\n\tmutex_unlock(&private->io_mutex);\n\treturn ret;\n}\n\nstatic ssize_t vfio_ccw_schib_region_write(struct vfio_ccw_private *private,\n\t\t\t\t\t   const char __user *buf, size_t count,\n\t\t\t\t\t   loff_t *ppos)\n{\n\treturn -EINVAL;\n}\n\n\nstatic void vfio_ccw_schib_region_release(struct vfio_ccw_private *private,\n\t\t\t\t\t  struct vfio_ccw_region *region)\n{\n\n}\n\nstatic const struct vfio_ccw_regops vfio_ccw_schib_region_ops = {\n\t.read = vfio_ccw_schib_region_read,\n\t.write = vfio_ccw_schib_region_write,\n\t.release = vfio_ccw_schib_region_release,\n};\n\nint vfio_ccw_register_schib_dev_regions(struct vfio_ccw_private *private)\n{\n\treturn vfio_ccw_register_dev_region(private,\n\t\t\t\t\t    VFIO_REGION_SUBTYPE_CCW_SCHIB,\n\t\t\t\t\t    &vfio_ccw_schib_region_ops,\n\t\t\t\t\t    sizeof(struct ccw_schib_region),\n\t\t\t\t\t    VFIO_REGION_INFO_FLAG_READ,\n\t\t\t\t\t    private->schib_region);\n}\n\nstatic ssize_t vfio_ccw_crw_region_read(struct vfio_ccw_private *private,\n\t\t\t\t\tchar __user *buf, size_t count,\n\t\t\t\t\tloff_t *ppos)\n{\n\tunsigned int i = VFIO_CCW_OFFSET_TO_INDEX(*ppos) - VFIO_CCW_NUM_REGIONS;\n\tloff_t pos = *ppos & VFIO_CCW_OFFSET_MASK;\n\tstruct ccw_crw_region *region;\n\tstruct vfio_ccw_crw *crw;\n\tint ret;\n\n\tif (pos + count > sizeof(*region))\n\t\treturn -EINVAL;\n\n\tcrw = list_first_entry_or_null(&private->crw,\n\t\t\t\t       struct vfio_ccw_crw, next);\n\n\tif (crw)\n\t\tlist_del(&crw->next);\n\n\tmutex_lock(&private->io_mutex);\n\tregion = private->region[i].data;\n\n\tif (crw)\n\t\tmemcpy(&region->crw, &crw->crw, sizeof(region->crw));\n\n\tif (copy_to_user(buf, (void *)region + pos, count))\n\t\tret = -EFAULT;\n\telse\n\t\tret = count;\n\n\tregion->crw = 0;\n\n\tmutex_unlock(&private->io_mutex);\n\n\tkfree(crw);\n\n\t \n\tif (!list_empty(&private->crw) && private->crw_trigger)\n\t\teventfd_signal(private->crw_trigger, 1);\n\n\treturn ret;\n}\n\nstatic ssize_t vfio_ccw_crw_region_write(struct vfio_ccw_private *private,\n\t\t\t\t\t const char __user *buf, size_t count,\n\t\t\t\t\t loff_t *ppos)\n{\n\treturn -EINVAL;\n}\n\nstatic void vfio_ccw_crw_region_release(struct vfio_ccw_private *private,\n\t\t\t\t\tstruct vfio_ccw_region *region)\n{\n\n}\n\nstatic const struct vfio_ccw_regops vfio_ccw_crw_region_ops = {\n\t.read = vfio_ccw_crw_region_read,\n\t.write = vfio_ccw_crw_region_write,\n\t.release = vfio_ccw_crw_region_release,\n};\n\nint vfio_ccw_register_crw_dev_regions(struct vfio_ccw_private *private)\n{\n\treturn vfio_ccw_register_dev_region(private,\n\t\t\t\t\t    VFIO_REGION_SUBTYPE_CCW_CRW,\n\t\t\t\t\t    &vfio_ccw_crw_region_ops,\n\t\t\t\t\t    sizeof(struct ccw_crw_region),\n\t\t\t\t\t    VFIO_REGION_INFO_FLAG_READ,\n\t\t\t\t\t    private->crw_region);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}