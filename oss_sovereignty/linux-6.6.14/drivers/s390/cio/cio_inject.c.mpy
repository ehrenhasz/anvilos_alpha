{
  "module_name": "cio_inject.c",
  "hash_id": "a15cb5f9b43b9fc6751ec386ecae9885e76e066a790ad6887d88b4cebbcd6302",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/cio_inject.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"cio\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n#include <asm/chpid.h>\n\n#include \"cio_inject.h\"\n#include \"cio_debug.h\"\n\nstatic DEFINE_SPINLOCK(crw_inject_lock);\nDEFINE_STATIC_KEY_FALSE(cio_inject_enabled);\nstatic struct crw *crw_inject_data;\n\n \nstatic int crw_inject(struct crw *crw)\n{\n\tint rc = 0;\n\tstruct crw *copy;\n\tunsigned long flags;\n\n\tcopy = kmemdup(crw, sizeof(*crw), GFP_KERNEL);\n\tif (!copy)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&crw_inject_lock, flags);\n\tif (crw_inject_data) {\n\t\tkfree(copy);\n\t\trc = -EBUSY;\n\t} else {\n\t\tcrw_inject_data = copy;\n\t}\n\tspin_unlock_irqrestore(&crw_inject_lock, flags);\n\n\tif (!rc)\n\t\tcrw_handle_channel_report();\n\n\treturn rc;\n}\n\n \nint stcrw_get_injected(struct crw *crw)\n{\n\tint rc = 1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&crw_inject_lock, flags);\n\tif (crw_inject_data) {\n\t\tmemcpy(crw, crw_inject_data, sizeof(*crw));\n\t\tkfree(crw_inject_data);\n\t\tcrw_inject_data = NULL;\n\t\trc = 0;\n\t}\n\tspin_unlock_irqrestore(&crw_inject_lock, flags);\n\n\treturn rc;\n}\n\n \nstatic ssize_t crw_inject_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t lbuf, loff_t *ppos)\n{\n\tu32 slct, oflw, chn, rsc, anc, erc, rsid;\n\tstruct crw crw;\n\tchar *buffer;\n\tint rc;\n\n\tif (!static_branch_likely(&cio_inject_enabled)) {\n\t\tpr_warn(\"CIO inject is not enabled - ignoring CRW inject\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer = vmemdup_user(buf, lbuf);\n\tif (IS_ERR(buffer))\n\t\treturn -ENOMEM;\n\n\trc = sscanf(buffer, \"%x %x %x %x %x %x %x\", &slct, &oflw, &chn, &rsc, &anc,\n\t\t    &erc, &rsid);\n\n\tkvfree(buffer);\n\tif (rc != 7) {\n\t\tpr_warn(\"crw_inject: Invalid format (need <solicited> <overflow> <chaining> <rsc> <ancillary> <erc> <rsid>)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&crw, 0, sizeof(crw));\n\tcrw.slct = slct;\n\tcrw.oflw = oflw;\n\tcrw.chn = chn;\n\tcrw.rsc = rsc;\n\tcrw.anc = anc;\n\tcrw.erc = erc;\n\tcrw.rsid = rsid;\n\n\trc = crw_inject(&crw);\n\tif (rc)\n\t\treturn rc;\n\n\treturn lbuf;\n}\n\n \nstatic ssize_t enable_inject_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t lbuf, loff_t *ppos)\n{\n\tunsigned long en = 0;\n\tint rc;\n\n\trc = kstrtoul_from_user(buf, lbuf, 10, &en);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (en) {\n\tcase 0:\n\t\tstatic_branch_disable(&cio_inject_enabled);\n\t\tbreak;\n\tcase 1:\n\t\tstatic_branch_enable(&cio_inject_enabled);\n\t\tbreak;\n\t}\n\n\treturn lbuf;\n}\n\nstatic const struct file_operations crw_fops = {\n\t.owner = THIS_MODULE,\n\t.write = crw_inject_write,\n};\n\nstatic const struct file_operations cio_en_fops = {\n\t.owner = THIS_MODULE,\n\t.write = enable_inject_write,\n};\n\nstatic int __init cio_inject_init(void)\n{\n\t \n\tdebugfs_create_file(\"enable_inject\", 0200, cio_debugfs_dir,\n\t\t\t    NULL, &cio_en_fops);\n\n\tdebugfs_create_file(\"crw_inject\", 0200, cio_debugfs_dir,\n\t\t\t    NULL, &crw_fops);\n\treturn 0;\n}\n\ndevice_initcall(cio_inject_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}