{
  "module_name": "fcx.c",
  "hash_id": "9eab0ab7d490a907242d494242d7772fcdbe3f376ebbb46d76e7910b7f89f59c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/fcx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <asm/fcx.h>\n#include \"cio.h\"\n\n \nstruct tcw *tcw_get_intrg(struct tcw *tcw)\n{\n\treturn phys_to_virt(tcw->intrg);\n}\nEXPORT_SYMBOL(tcw_get_intrg);\n\n \nvoid *tcw_get_data(struct tcw *tcw)\n{\n\tif (tcw->r)\n\t\treturn phys_to_virt(tcw->input);\n\tif (tcw->w)\n\t\treturn phys_to_virt(tcw->output);\n\treturn NULL;\n}\nEXPORT_SYMBOL(tcw_get_data);\n\n \nstruct tccb *tcw_get_tccb(struct tcw *tcw)\n{\n\treturn phys_to_virt(tcw->tccb);\n}\nEXPORT_SYMBOL(tcw_get_tccb);\n\n \nstruct tsb *tcw_get_tsb(struct tcw *tcw)\n{\n\treturn phys_to_virt(tcw->tsb);\n}\nEXPORT_SYMBOL(tcw_get_tsb);\n\n \nvoid tcw_init(struct tcw *tcw, int r, int w)\n{\n\tmemset(tcw, 0, sizeof(struct tcw));\n\ttcw->format = TCW_FORMAT_DEFAULT;\n\ttcw->flags = TCW_FLAGS_TIDAW_FORMAT(TCW_TIDAW_FORMAT_DEFAULT);\n\tif (r)\n\t\ttcw->r = 1;\n\tif (w)\n\t\ttcw->w = 1;\n}\nEXPORT_SYMBOL(tcw_init);\n\nstatic inline size_t tca_size(struct tccb *tccb)\n{\n\treturn tccb->tcah.tcal - 12;\n}\n\nstatic u32 calc_dcw_count(struct tccb *tccb)\n{\n\tint offset;\n\tstruct dcw *dcw;\n\tu32 count = 0;\n\tsize_t size;\n\n\tsize = tca_size(tccb);\n\tfor (offset = 0; offset < size;) {\n\t\tdcw = (struct dcw *) &tccb->tca[offset];\n\t\tcount += dcw->count;\n\t\tif (!(dcw->flags & DCW_FLAGS_CC))\n\t\t\tbreak;\n\t\toffset += sizeof(struct dcw) + ALIGN((int) dcw->cd_count, 4);\n\t}\n\treturn count;\n}\n\nstatic u32 calc_cbc_size(struct tidaw *tidaw, int num)\n{\n\tint i;\n\tu32 cbc_data;\n\tu32 cbc_count = 0;\n\tu64 data_count = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (tidaw[i].flags & TIDAW_FLAGS_LAST)\n\t\t\tbreak;\n\t\t \n\t\tdata_count += tidaw[i].count;\n\t\tif (tidaw[i].flags & TIDAW_FLAGS_INSERT_CBC) {\n\t\t\tcbc_data = 4 + ALIGN(data_count, 4) - data_count;\n\t\t\tcbc_count += cbc_data;\n\t\t\tdata_count += cbc_data;\n\t\t}\n\t}\n\treturn cbc_count;\n}\n\n \nvoid tcw_finalize(struct tcw *tcw, int num_tidaws)\n{\n\tstruct tidaw *tidaw;\n\tstruct tccb *tccb;\n\tstruct tccb_tcat *tcat;\n\tu32 count;\n\n\t \n\ttidaw = tcw_get_data(tcw);\n\tif (num_tidaws > 0)\n\t\ttidaw[num_tidaws - 1].flags |= TIDAW_FLAGS_LAST;\n\t \n\ttccb = tcw_get_tccb(tcw);\n\ttcat = (struct tccb_tcat *) &tccb->tca[tca_size(tccb)];\n\tmemset(tcat, 0, sizeof(*tcat));\n\t \n\tcount = calc_dcw_count(tccb);\n\tif (tcw->w && (tcw->flags & TCW_FLAGS_OUTPUT_TIDA))\n\t\tcount += calc_cbc_size(tidaw, num_tidaws);\n\tif (tcw->r)\n\t\ttcw->input_count = count;\n\telse if (tcw->w)\n\t\ttcw->output_count = count;\n\ttcat->count = ALIGN(count, 4) + 4;\n\t \n\ttcw->tccbl = (sizeof(struct tccb) + tca_size(tccb) +\n\t\t      sizeof(struct tccb_tcat) - 20) >> 2;\n}\nEXPORT_SYMBOL(tcw_finalize);\n\n \nvoid tcw_set_intrg(struct tcw *tcw, struct tcw *intrg_tcw)\n{\n\ttcw->intrg = (u32)virt_to_phys(intrg_tcw);\n}\nEXPORT_SYMBOL(tcw_set_intrg);\n\n \nvoid tcw_set_data(struct tcw *tcw, void *data, int use_tidal)\n{\n\tif (tcw->r) {\n\t\ttcw->input = virt_to_phys(data);\n\t\tif (use_tidal)\n\t\t\ttcw->flags |= TCW_FLAGS_INPUT_TIDA;\n\t} else if (tcw->w) {\n\t\ttcw->output = virt_to_phys(data);\n\t\tif (use_tidal)\n\t\t\ttcw->flags |= TCW_FLAGS_OUTPUT_TIDA;\n\t}\n}\nEXPORT_SYMBOL(tcw_set_data);\n\n \nvoid tcw_set_tccb(struct tcw *tcw, struct tccb *tccb)\n{\n\ttcw->tccb = virt_to_phys(tccb);\n}\nEXPORT_SYMBOL(tcw_set_tccb);\n\n \nvoid tcw_set_tsb(struct tcw *tcw, struct tsb *tsb)\n{\n\ttcw->tsb = virt_to_phys(tsb);\n}\nEXPORT_SYMBOL(tcw_set_tsb);\n\n \nvoid tccb_init(struct tccb *tccb, size_t size, u32 sac)\n{\n\tmemset(tccb, 0, size);\n\ttccb->tcah.format = TCCB_FORMAT_DEFAULT;\n\ttccb->tcah.sac = sac;\n\ttccb->tcah.tcal = 12;\n}\nEXPORT_SYMBOL(tccb_init);\n\n \nvoid tsb_init(struct tsb *tsb)\n{\n\tmemset(tsb, 0, sizeof(*tsb));\n}\nEXPORT_SYMBOL(tsb_init);\n\n \nstruct dcw *tccb_add_dcw(struct tccb *tccb, size_t tccb_size, u8 cmd, u8 flags,\n\t\t\t void *cd, u8 cd_count, u32 count)\n{\n\tstruct dcw *dcw;\n\tint size;\n\tint tca_offset;\n\n\t \n\ttca_offset = tca_size(tccb);\n\tsize = ALIGN(sizeof(struct dcw) + cd_count, 4);\n\tif (sizeof(struct tccb_tcah) + tca_offset + size +\n\t    sizeof(struct tccb_tcat) > tccb_size)\n\t\treturn ERR_PTR(-ENOSPC);\n\t \n\tdcw = (struct dcw *) &tccb->tca[tca_offset];\n\tmemset(dcw, 0, size);\n\tdcw->cmd = cmd;\n\tdcw->flags = flags;\n\tdcw->count = count;\n\tdcw->cd_count = cd_count;\n\tif (cd)\n\t\tmemcpy(&dcw->cd[0], cd, cd_count);\n\ttccb->tcah.tcal += size;\n\treturn dcw;\n}\nEXPORT_SYMBOL(tccb_add_dcw);\n\n \nstruct tidaw *tcw_add_tidaw(struct tcw *tcw, int num_tidaws, u8 flags,\n\t\t\t    void *addr, u32 count)\n{\n\tstruct tidaw *tidaw;\n\n\t \n\ttidaw = ((struct tidaw *) tcw_get_data(tcw)) + num_tidaws;\n\tmemset(tidaw, 0, sizeof(struct tidaw));\n\ttidaw->flags = flags;\n\ttidaw->count = count;\n\ttidaw->addr = virt_to_phys(addr);\n\treturn tidaw;\n}\nEXPORT_SYMBOL(tcw_add_tidaw);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}