{
  "module_name": "crw.c",
  "hash_id": "8e3b02c8aa8a7e40677e7125902d1572848d4f7135a6befc819f0c3ad4eed9da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/crw.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/wait.h>\n#include <asm/crw.h>\n#include <asm/ctl_reg.h>\n#include \"ioasm.h\"\n\nstatic DEFINE_MUTEX(crw_handler_mutex);\nstatic crw_handler_t crw_handlers[NR_RSCS];\nstatic atomic_t crw_nr_req = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(crw_handler_wait_q);\n\n \nint crw_register_handler(int rsc, crw_handler_t handler)\n{\n\tint rc = 0;\n\n\tif ((rsc < 0) || (rsc >= NR_RSCS))\n\t\treturn -EINVAL;\n\tmutex_lock(&crw_handler_mutex);\n\tif (crw_handlers[rsc])\n\t\trc = -EBUSY;\n\telse\n\t\tcrw_handlers[rsc] = handler;\n\tmutex_unlock(&crw_handler_mutex);\n\treturn rc;\n}\n\n \nvoid crw_unregister_handler(int rsc)\n{\n\tif ((rsc < 0) || (rsc >= NR_RSCS))\n\t\treturn;\n\tmutex_lock(&crw_handler_mutex);\n\tcrw_handlers[rsc] = NULL;\n\tmutex_unlock(&crw_handler_mutex);\n}\n\n \nstatic int crw_collect_info(void *unused)\n{\n\tstruct crw crw[2];\n\tint ccode, signal;\n\tunsigned int chain;\n\nrepeat:\n\tsignal = wait_event_interruptible(crw_handler_wait_q,\n\t\t\t\t\t  atomic_read(&crw_nr_req) > 0);\n\tif (unlikely(signal))\n\t\tatomic_inc(&crw_nr_req);\n\tchain = 0;\n\twhile (1) {\n\t\tcrw_handler_t handler;\n\n\t\tif (unlikely(chain > 1)) {\n\t\t\tstruct crw tmp_crw;\n\n\t\t\tprintk(KERN_WARNING\"%s: Code does not support more \"\n\t\t\t       \"than two chained crws; please report to \"\n\t\t\t       \"linux390@de.ibm.com!\\n\", __func__);\n\t\t\tccode = stcrw(&tmp_crw);\n\t\t\tprintk(KERN_WARNING\"%s: crw reports slct=%d, oflw=%d, \"\n\t\t\t       \"chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\\n\",\n\t\t\t       __func__, tmp_crw.slct, tmp_crw.oflw,\n\t\t\t       tmp_crw.chn, tmp_crw.rsc, tmp_crw.anc,\n\t\t\t       tmp_crw.erc, tmp_crw.rsid);\n\t\t\tprintk(KERN_WARNING\"%s: This was crw number %x in the \"\n\t\t\t       \"chain\\n\", __func__, chain);\n\t\t\tif (ccode != 0)\n\t\t\t\tbreak;\n\t\t\tchain = tmp_crw.chn ? chain + 1 : 0;\n\t\t\tcontinue;\n\t\t}\n\t\tccode = stcrw(&crw[chain]);\n\t\tif (ccode != 0)\n\t\t\tbreak;\n\t\tprintk(KERN_DEBUG \"crw_info : CRW reports slct=%d, oflw=%d, \"\n\t\t       \"chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\\n\",\n\t\t       crw[chain].slct, crw[chain].oflw, crw[chain].chn,\n\t\t       crw[chain].rsc, crw[chain].anc, crw[chain].erc,\n\t\t       crw[chain].rsid);\n\t\t \n\t\tif (crw[chain].oflw) {\n\t\t\tint i;\n\n\t\t\tpr_debug(\"%s: crw overflow detected!\\n\", __func__);\n\t\t\tmutex_lock(&crw_handler_mutex);\n\t\t\tfor (i = 0; i < NR_RSCS; i++) {\n\t\t\t\tif (crw_handlers[i])\n\t\t\t\t\tcrw_handlers[i](NULL, NULL, 1);\n\t\t\t}\n\t\t\tmutex_unlock(&crw_handler_mutex);\n\t\t\tchain = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (crw[0].chn && !chain) {\n\t\t\tchain++;\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&crw_handler_mutex);\n\t\thandler = crw_handlers[crw[chain].rsc];\n\t\tif (handler)\n\t\t\thandler(&crw[0], chain ? &crw[1] : NULL, 0);\n\t\tmutex_unlock(&crw_handler_mutex);\n\t\t \n\t\tchain = crw[chain].chn ? chain + 1 : 0;\n\t}\n\tif (atomic_dec_and_test(&crw_nr_req))\n\t\twake_up(&crw_handler_wait_q);\n\tgoto repeat;\n\treturn 0;\n}\n\nvoid crw_handle_channel_report(void)\n{\n\tatomic_inc(&crw_nr_req);\n\twake_up(&crw_handler_wait_q);\n}\n\nvoid crw_wait_for_channel_report(void)\n{\n\tcrw_handle_channel_report();\n\twait_event(crw_handler_wait_q, atomic_read(&crw_nr_req) == 0);\n}\n\n \nstatic int __init crw_machine_check_init(void)\n{\n\tstruct task_struct *task;\n\n\ttask = kthread_run(crw_collect_info, NULL, \"kmcheck\");\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tctl_set_bit(14, 28);\t \n\treturn 0;\n}\ndevice_initcall(crw_machine_check_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}