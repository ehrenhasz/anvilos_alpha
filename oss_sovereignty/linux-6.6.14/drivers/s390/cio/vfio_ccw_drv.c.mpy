{
  "module_name": "vfio_ccw_drv.c",
  "hash_id": "9f828c653896e68939bd6f1a21c710446fe54ef167ec41dbbcea29c8d0e7aa86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/vfio_ccw_drv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mdev.h>\n\n#include <asm/isc.h>\n\n#include \"chp.h\"\n#include \"ioasm.h\"\n#include \"css.h\"\n#include \"vfio_ccw_private.h\"\n\nstruct workqueue_struct *vfio_ccw_work_q;\nstruct kmem_cache *vfio_ccw_io_region;\nstruct kmem_cache *vfio_ccw_cmd_region;\nstruct kmem_cache *vfio_ccw_schib_region;\nstruct kmem_cache *vfio_ccw_crw_region;\n\ndebug_info_t *vfio_ccw_debug_msg_id;\ndebug_info_t *vfio_ccw_debug_trace_id;\n\n \nint vfio_ccw_sch_quiesce(struct subchannel *sch)\n{\n\tstruct vfio_ccw_parent *parent = dev_get_drvdata(&sch->dev);\n\tstruct vfio_ccw_private *private = dev_get_drvdata(&parent->dev);\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint iretry, ret = 0;\n\n\t \n\tif (WARN_ON(!private))\n\t\treturn 0;\n\n\tiretry = 255;\n\tdo {\n\n\t\tret = cio_cancel_halt_clear(sch, &iretry);\n\n\t\tif (ret == -EIO) {\n\t\t\tpr_err(\"vfio_ccw: could not quiesce subchannel 0.%x.%04x!\\n\",\n\t\t\t       sch->schid.ssid, sch->schid.sch_no);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tprivate->completion = &completion;\n\t\tspin_unlock_irq(sch->lock);\n\n\t\tif (ret == -EBUSY)\n\t\t\twait_for_completion_timeout(&completion, 3*HZ);\n\n\t\tprivate->completion = NULL;\n\t\tflush_workqueue(vfio_ccw_work_q);\n\t\tspin_lock_irq(sch->lock);\n\t\tret = cio_disable_subchannel(sch);\n\t} while (ret == -EBUSY);\n\n\treturn ret;\n}\n\nvoid vfio_ccw_sch_io_todo(struct work_struct *work)\n{\n\tstruct vfio_ccw_private *private;\n\tstruct irb *irb;\n\tbool is_final;\n\tbool cp_is_finished = false;\n\n\tprivate = container_of(work, struct vfio_ccw_private, io_work);\n\tirb = &private->irb;\n\n\tis_final = !(scsw_actl(&irb->scsw) &\n\t\t     (SCSW_ACTL_DEVACT | SCSW_ACTL_SCHACT));\n\tif (scsw_is_solicited(&irb->scsw)) {\n\t\tcp_update_scsw(&private->cp, &irb->scsw);\n\t\tif (is_final && private->state == VFIO_CCW_STATE_CP_PENDING) {\n\t\t\tcp_free(&private->cp);\n\t\t\tcp_is_finished = true;\n\t\t}\n\t}\n\tmutex_lock(&private->io_mutex);\n\tmemcpy(private->io_region->irb_area, irb, sizeof(*irb));\n\tmutex_unlock(&private->io_mutex);\n\n\t \n\tif (cp_is_finished)\n\t\tprivate->state = VFIO_CCW_STATE_IDLE;\n\n\tif (private->io_trigger)\n\t\teventfd_signal(private->io_trigger, 1);\n}\n\nvoid vfio_ccw_crw_todo(struct work_struct *work)\n{\n\tstruct vfio_ccw_private *private;\n\n\tprivate = container_of(work, struct vfio_ccw_private, crw_work);\n\n\tif (!list_empty(&private->crw) && private->crw_trigger)\n\t\teventfd_signal(private->crw_trigger, 1);\n}\n\n \nstatic void vfio_ccw_sch_irq(struct subchannel *sch)\n{\n\tstruct vfio_ccw_parent *parent = dev_get_drvdata(&sch->dev);\n\tstruct vfio_ccw_private *private = dev_get_drvdata(&parent->dev);\n\n\t \n\tif (!private) {\n\t\tVFIO_CCW_MSG_EVENT(2, \"sch %x.%x.%04x: unexpected interrupt\\n\",\n\t\t\t\t   sch->schid.cssid, sch->schid.ssid,\n\t\t\t\t   sch->schid.sch_no);\n\n\t\tcio_disable_subchannel(sch);\n\t\treturn;\n\t}\n\n\tinc_irq_stat(IRQIO_CIO);\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_INTERRUPT);\n}\n\nstatic void vfio_ccw_free_parent(struct device *dev)\n{\n\tstruct vfio_ccw_parent *parent = container_of(dev, struct vfio_ccw_parent, dev);\n\n\tkfree(parent);\n}\n\nstatic int vfio_ccw_sch_probe(struct subchannel *sch)\n{\n\tstruct pmcw *pmcw = &sch->schib.pmcw;\n\tstruct vfio_ccw_parent *parent;\n\tint ret = -ENOMEM;\n\n\tif (pmcw->qf) {\n\t\tdev_warn(&sch->dev, \"vfio: ccw: does not support QDIO: %s\\n\",\n\t\t\t dev_name(&sch->dev));\n\t\treturn -ENODEV;\n\t}\n\n\tparent = kzalloc(struct_size(parent, mdev_types, 1), GFP_KERNEL);\n\tif (!parent)\n\t\treturn -ENOMEM;\n\n\tdev_set_name(&parent->dev, \"parent\");\n\tparent->dev.parent = &sch->dev;\n\tparent->dev.release = &vfio_ccw_free_parent;\n\tret = device_register(&parent->dev);\n\tif (ret)\n\t\tgoto out_free;\n\n\tdev_set_drvdata(&sch->dev, parent);\n\n\tparent->mdev_type.sysfs_name = \"io\";\n\tparent->mdev_type.pretty_name = \"I/O subchannel (Non-QDIO)\";\n\tparent->mdev_types[0] = &parent->mdev_type;\n\tret = mdev_register_parent(&parent->parent, &sch->dev,\n\t\t\t\t   &vfio_ccw_mdev_driver,\n\t\t\t\t   parent->mdev_types, 1);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tVFIO_CCW_MSG_EVENT(4, \"bound to subchannel %x.%x.%04x\\n\",\n\t\t\t   sch->schid.cssid, sch->schid.ssid,\n\t\t\t   sch->schid.sch_no);\n\treturn 0;\n\nout_unreg:\n\tdevice_del(&parent->dev);\nout_free:\n\tput_device(&parent->dev);\n\tdev_set_drvdata(&sch->dev, NULL);\n\treturn ret;\n}\n\nstatic void vfio_ccw_sch_remove(struct subchannel *sch)\n{\n\tstruct vfio_ccw_parent *parent = dev_get_drvdata(&sch->dev);\n\n\tmdev_unregister_parent(&parent->parent);\n\n\tdevice_unregister(&parent->dev);\n\tdev_set_drvdata(&sch->dev, NULL);\n\n\tVFIO_CCW_MSG_EVENT(4, \"unbound from subchannel %x.%x.%04x\\n\",\n\t\t\t   sch->schid.cssid, sch->schid.ssid,\n\t\t\t   sch->schid.sch_no);\n}\n\nstatic void vfio_ccw_sch_shutdown(struct subchannel *sch)\n{\n\tstruct vfio_ccw_parent *parent = dev_get_drvdata(&sch->dev);\n\tstruct vfio_ccw_private *private = dev_get_drvdata(&parent->dev);\n\n\tif (!private)\n\t\treturn;\n\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_CLOSE);\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_NOT_OPER);\n}\n\n \nstatic int vfio_ccw_sch_event(struct subchannel *sch, int process)\n{\n\tstruct vfio_ccw_parent *parent = dev_get_drvdata(&sch->dev);\n\tstruct vfio_ccw_private *private = dev_get_drvdata(&parent->dev);\n\tunsigned long flags;\n\tint rc = -EAGAIN;\n\n\tspin_lock_irqsave(sch->lock, flags);\n\tif (!device_is_registered(&sch->dev))\n\t\tgoto out_unlock;\n\n\tif (work_pending(&sch->todo_work))\n\t\tgoto out_unlock;\n\n\trc = 0;\n\n\tif (cio_update_schib(sch)) {\n\t\tif (private)\n\t\t\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_NOT_OPER);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(sch->lock, flags);\n\n\treturn rc;\n}\n\nstatic void vfio_ccw_queue_crw(struct vfio_ccw_private *private,\n\t\t\t       unsigned int rsc,\n\t\t\t       unsigned int erc,\n\t\t\t       unsigned int rsid)\n{\n\tstruct vfio_ccw_crw *crw;\n\n\t \n\tcrw = kzalloc(sizeof(*crw), GFP_ATOMIC);\n\tif (!crw)\n\t\treturn;\n\n\t \n\tcrw->crw.rsc = rsc;\n\tcrw->crw.erc = erc;\n\tcrw->crw.rsid = rsid;\n\n\tlist_add_tail(&crw->next, &private->crw);\n\tqueue_work(vfio_ccw_work_q, &private->crw_work);\n}\n\nstatic int vfio_ccw_chp_event(struct subchannel *sch,\n\t\t\t      struct chp_link *link, int event)\n{\n\tstruct vfio_ccw_parent *parent = dev_get_drvdata(&sch->dev);\n\tstruct vfio_ccw_private *private = dev_get_drvdata(&parent->dev);\n\tint mask = chp_ssd_get_mask(&sch->ssd_info, link);\n\tint retry = 255;\n\n\tif (!private || !mask)\n\t\treturn 0;\n\n\ttrace_vfio_ccw_chp_event(sch->schid, mask, event);\n\tVFIO_CCW_MSG_EVENT(2, \"sch %x.%x.%04x: mask=0x%x event=%d\\n\",\n\t\t\t   sch->schid.cssid,\n\t\t\t   sch->schid.ssid, sch->schid.sch_no,\n\t\t\t   mask, event);\n\n\tif (cio_update_schib(sch))\n\t\treturn -ENODEV;\n\n\tswitch (event) {\n\tcase CHP_VARY_OFF:\n\t\t \n\t\tsch->opm &= ~mask;\n\t\tsch->lpm &= ~mask;\n\t\tif (sch->schib.pmcw.lpum & mask)\n\t\t\tcio_cancel_halt_clear(sch, &retry);\n\t\tbreak;\n\tcase CHP_OFFLINE:\n\t\t \n\t\tif (sch->schib.pmcw.lpum & mask)\n\t\t\tcio_cancel_halt_clear(sch, &retry);\n\t\tvfio_ccw_queue_crw(private, CRW_RSC_CPATH, CRW_ERC_PERRN,\n\t\t\t\t   link->chpid.id);\n\t\tbreak;\n\tcase CHP_VARY_ON:\n\t\t \n\t\tsch->opm |= mask;\n\t\tsch->lpm |= mask;\n\t\tbreak;\n\tcase CHP_ONLINE:\n\t\t \n\t\tsch->lpm |= mask & sch->opm;\n\t\tvfio_ccw_queue_crw(private, CRW_RSC_CPATH, CRW_ERC_INIT,\n\t\t\t\t   link->chpid.id);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct css_device_id vfio_ccw_sch_ids[] = {\n\t{ .match_flags = 0x1, .type = SUBCHANNEL_TYPE_IO, },\n\t{   },\n};\nMODULE_DEVICE_TABLE(css, vfio_ccw_sch_ids);\n\nstatic struct css_driver vfio_ccw_sch_driver = {\n\t.drv = {\n\t\t.name = \"vfio_ccw\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.subchannel_type = vfio_ccw_sch_ids,\n\t.irq = vfio_ccw_sch_irq,\n\t.probe = vfio_ccw_sch_probe,\n\t.remove = vfio_ccw_sch_remove,\n\t.shutdown = vfio_ccw_sch_shutdown,\n\t.sch_event = vfio_ccw_sch_event,\n\t.chp_event = vfio_ccw_chp_event,\n};\n\nstatic int __init vfio_ccw_debug_init(void)\n{\n\tvfio_ccw_debug_msg_id = debug_register(\"vfio_ccw_msg\", 16, 1,\n\t\t\t\t\t       11 * sizeof(long));\n\tif (!vfio_ccw_debug_msg_id)\n\t\tgoto out_unregister;\n\tdebug_register_view(vfio_ccw_debug_msg_id, &debug_sprintf_view);\n\tdebug_set_level(vfio_ccw_debug_msg_id, 2);\n\tvfio_ccw_debug_trace_id = debug_register(\"vfio_ccw_trace\", 16, 1, 16);\n\tif (!vfio_ccw_debug_trace_id)\n\t\tgoto out_unregister;\n\tdebug_register_view(vfio_ccw_debug_trace_id, &debug_hex_ascii_view);\n\tdebug_set_level(vfio_ccw_debug_trace_id, 2);\n\treturn 0;\n\nout_unregister:\n\tdebug_unregister(vfio_ccw_debug_msg_id);\n\tdebug_unregister(vfio_ccw_debug_trace_id);\n\treturn -1;\n}\n\nstatic void vfio_ccw_debug_exit(void)\n{\n\tdebug_unregister(vfio_ccw_debug_msg_id);\n\tdebug_unregister(vfio_ccw_debug_trace_id);\n}\n\nstatic void vfio_ccw_destroy_regions(void)\n{\n\tkmem_cache_destroy(vfio_ccw_crw_region);\n\tkmem_cache_destroy(vfio_ccw_schib_region);\n\tkmem_cache_destroy(vfio_ccw_cmd_region);\n\tkmem_cache_destroy(vfio_ccw_io_region);\n}\n\nstatic int __init vfio_ccw_sch_init(void)\n{\n\tint ret;\n\n\tret = vfio_ccw_debug_init();\n\tif (ret)\n\t\treturn ret;\n\n\tvfio_ccw_work_q = create_singlethread_workqueue(\"vfio-ccw\");\n\tif (!vfio_ccw_work_q) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regions;\n\t}\n\n\tvfio_ccw_io_region = kmem_cache_create_usercopy(\"vfio_ccw_io_region\",\n\t\t\t\t\tsizeof(struct ccw_io_region), 0,\n\t\t\t\t\tSLAB_ACCOUNT, 0,\n\t\t\t\t\tsizeof(struct ccw_io_region), NULL);\n\tif (!vfio_ccw_io_region) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regions;\n\t}\n\n\tvfio_ccw_cmd_region = kmem_cache_create_usercopy(\"vfio_ccw_cmd_region\",\n\t\t\t\t\tsizeof(struct ccw_cmd_region), 0,\n\t\t\t\t\tSLAB_ACCOUNT, 0,\n\t\t\t\t\tsizeof(struct ccw_cmd_region), NULL);\n\tif (!vfio_ccw_cmd_region) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regions;\n\t}\n\n\tvfio_ccw_schib_region = kmem_cache_create_usercopy(\"vfio_ccw_schib_region\",\n\t\t\t\t\tsizeof(struct ccw_schib_region), 0,\n\t\t\t\t\tSLAB_ACCOUNT, 0,\n\t\t\t\t\tsizeof(struct ccw_schib_region), NULL);\n\n\tif (!vfio_ccw_schib_region) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regions;\n\t}\n\n\tvfio_ccw_crw_region = kmem_cache_create_usercopy(\"vfio_ccw_crw_region\",\n\t\t\t\t\tsizeof(struct ccw_crw_region), 0,\n\t\t\t\t\tSLAB_ACCOUNT, 0,\n\t\t\t\t\tsizeof(struct ccw_crw_region), NULL);\n\n\tif (!vfio_ccw_crw_region) {\n\t\tret = -ENOMEM;\n\t\tgoto out_regions;\n\t}\n\n\tret = mdev_register_driver(&vfio_ccw_mdev_driver);\n\tif (ret)\n\t\tgoto out_regions;\n\n\tisc_register(VFIO_CCW_ISC);\n\tret = css_driver_register(&vfio_ccw_sch_driver);\n\tif (ret) {\n\t\tisc_unregister(VFIO_CCW_ISC);\n\t\tgoto out_driver;\n\t}\n\n\treturn ret;\n\nout_driver:\n\tmdev_unregister_driver(&vfio_ccw_mdev_driver);\nout_regions:\n\tvfio_ccw_destroy_regions();\n\tdestroy_workqueue(vfio_ccw_work_q);\n\tvfio_ccw_debug_exit();\n\treturn ret;\n}\n\nstatic void __exit vfio_ccw_sch_exit(void)\n{\n\tcss_driver_unregister(&vfio_ccw_sch_driver);\n\tmdev_unregister_driver(&vfio_ccw_mdev_driver);\n\tisc_unregister(VFIO_CCW_ISC);\n\tvfio_ccw_destroy_regions();\n\tdestroy_workqueue(vfio_ccw_work_q);\n\tvfio_ccw_debug_exit();\n}\nmodule_init(vfio_ccw_sch_init);\nmodule_exit(vfio_ccw_sch_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}