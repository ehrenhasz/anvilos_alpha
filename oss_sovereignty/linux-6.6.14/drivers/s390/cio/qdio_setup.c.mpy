{
  "module_name": "qdio_setup.c",
  "hash_id": "1489a3a3f1ef1cbaeba4039213899788149a9032ad1a76ccc716fa56d1ada544",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/qdio_setup.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/io.h>\n\n#include <asm/ebcdic.h>\n#include <asm/qdio.h>\n\n#include \"cio.h\"\n#include \"css.h\"\n#include \"device.h\"\n#include \"ioasm.h\"\n#include \"chsc.h\"\n#include \"qdio.h\"\n#include \"qdio_debug.h\"\n\n#define QBUFF_PER_PAGE (PAGE_SIZE / sizeof(struct qdio_buffer))\n\nstatic struct kmem_cache *qdio_q_cache;\n\n \nvoid qdio_free_buffers(struct qdio_buffer **buf, unsigned int count)\n{\n\tint pos;\n\n\tfor (pos = 0; pos < count; pos += QBUFF_PER_PAGE)\n\t\tfree_page((unsigned long) buf[pos]);\n}\nEXPORT_SYMBOL_GPL(qdio_free_buffers);\n\n \nint qdio_alloc_buffers(struct qdio_buffer **buf, unsigned int count)\n{\n\tint pos;\n\n\tfor (pos = 0; pos < count; pos += QBUFF_PER_PAGE) {\n\t\tbuf[pos] = (void *) get_zeroed_page(GFP_KERNEL);\n\t\tif (!buf[pos]) {\n\t\t\tqdio_free_buffers(buf, count);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (pos = 0; pos < count; pos++)\n\t\tif (pos % QBUFF_PER_PAGE)\n\t\t\tbuf[pos] = buf[pos - 1] + 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qdio_alloc_buffers);\n\n \nvoid qdio_reset_buffers(struct qdio_buffer **buf, unsigned int count)\n{\n\tint pos;\n\n\tfor (pos = 0; pos < count; pos++)\n\t\tmemset(buf[pos], 0, sizeof(struct qdio_buffer));\n}\nEXPORT_SYMBOL_GPL(qdio_reset_buffers);\n\nstatic void __qdio_free_queues(struct qdio_q **queues, unsigned int count)\n{\n\tstruct qdio_q *q;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tq = queues[i];\n\t\tfree_page((unsigned long) q->slib);\n\t\tkmem_cache_free(qdio_q_cache, q);\n\t}\n}\n\nvoid qdio_free_queues(struct qdio_irq *irq_ptr)\n{\n\t__qdio_free_queues(irq_ptr->input_qs, irq_ptr->max_input_qs);\n\tirq_ptr->max_input_qs = 0;\n\n\t__qdio_free_queues(irq_ptr->output_qs, irq_ptr->max_output_qs);\n\tirq_ptr->max_output_qs = 0;\n}\n\nstatic int __qdio_allocate_qs(struct qdio_q **irq_ptr_qs, int nr_queues)\n{\n\tstruct qdio_q *q;\n\tint i;\n\n\tfor (i = 0; i < nr_queues; i++) {\n\t\tq = kmem_cache_zalloc(qdio_q_cache, GFP_KERNEL);\n\t\tif (!q) {\n\t\t\t__qdio_free_queues(irq_ptr_qs, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tq->slib = (struct slib *) __get_free_page(GFP_KERNEL);\n\t\tif (!q->slib) {\n\t\t\tkmem_cache_free(qdio_q_cache, q);\n\t\t\t__qdio_free_queues(irq_ptr_qs, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tirq_ptr_qs[i] = q;\n\t}\n\treturn 0;\n}\n\nint qdio_allocate_qs(struct qdio_irq *irq_ptr, int nr_input_qs, int nr_output_qs)\n{\n\tint rc;\n\n\trc = __qdio_allocate_qs(irq_ptr->input_qs, nr_input_qs);\n\tif (rc)\n\t\treturn rc;\n\n\trc = __qdio_allocate_qs(irq_ptr->output_qs, nr_output_qs);\n\tif (rc) {\n\t\t__qdio_free_queues(irq_ptr->input_qs, nr_input_qs);\n\t\treturn rc;\n\t}\n\n\tirq_ptr->max_input_qs = nr_input_qs;\n\tirq_ptr->max_output_qs = nr_output_qs;\n\treturn 0;\n}\n\nstatic void setup_queues_misc(struct qdio_q *q, struct qdio_irq *irq_ptr,\n\t\t\t      qdio_handler_t *handler, int i)\n{\n\tstruct slib *slib = q->slib;\n\n\t \n\tmemset(q, 0, sizeof(*q));\n\tmemset(slib, 0, PAGE_SIZE);\n\tq->slib = slib;\n\tq->irq_ptr = irq_ptr;\n\tq->mask = 1 << (31 - i);\n\tq->nr = i;\n\tq->handler = handler;\n}\n\nstatic void setup_storage_lists(struct qdio_q *q, struct qdio_irq *irq_ptr,\n\t\t\t\tstruct qdio_buffer **sbals_array, int i)\n{\n\tstruct qdio_q *prev;\n\tint j;\n\n\tDBF_HEX(&q, sizeof(void *));\n\tq->sl = (struct sl *)((char *)q->slib + PAGE_SIZE / 2);\n\n\t \n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; j++)\n\t\tq->sbal[j] = *sbals_array++;\n\n\t \n\tif (i > 0) {\n\t\tprev = (q->is_input_q) ? irq_ptr->input_qs[i - 1]\n\t\t\t: irq_ptr->output_qs[i - 1];\n\t\tprev->slib->nsliba = (unsigned long)q->slib;\n\t}\n\n\tq->slib->sla = (unsigned long)q->sl;\n\tq->slib->slsba = (unsigned long)&q->slsb.val[0];\n\n\t \n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; j++)\n\t\tq->sl->element[j].sbal = virt_to_phys(q->sbal[j]);\n}\n\nstatic void setup_queues(struct qdio_irq *irq_ptr,\n\t\t\t struct qdio_initialize *qdio_init)\n{\n\tstruct qdio_q *q;\n\tint i;\n\n\tfor_each_input_queue(irq_ptr, q, i) {\n\t\tDBF_EVENT(\"inq:%1d\", i);\n\t\tsetup_queues_misc(q, irq_ptr, qdio_init->input_handler, i);\n\n\t\tq->is_input_q = 1;\n\n\t\tsetup_storage_lists(q, irq_ptr,\n\t\t\t\t    qdio_init->input_sbal_addr_array[i], i);\n\t}\n\n\tfor_each_output_queue(irq_ptr, q, i) {\n\t\tDBF_EVENT(\"outq:%1d\", i);\n\t\tsetup_queues_misc(q, irq_ptr, qdio_init->output_handler, i);\n\n\t\tq->is_input_q = 0;\n\t\tsetup_storage_lists(q, irq_ptr,\n\t\t\t\t    qdio_init->output_sbal_addr_array[i], i);\n\t}\n}\n\nstatic void check_and_setup_qebsm(struct qdio_irq *irq_ptr,\n\t\t\t\t  unsigned char qdioac, unsigned long token)\n{\n\tif (!(irq_ptr->qib.rflags & QIB_RFLAGS_ENABLE_QEBSM))\n\t\tgoto no_qebsm;\n\tif (!(qdioac & AC1_SC_QEBSM_AVAILABLE) ||\n\t    (!(qdioac & AC1_SC_QEBSM_ENABLED)))\n\t\tgoto no_qebsm;\n\n\tirq_ptr->sch_token = token;\n\n\tDBF_EVENT(\"V=V:1\");\n\tDBF_EVENT(\"%8lx\", irq_ptr->sch_token);\n\treturn;\n\nno_qebsm:\n\tirq_ptr->sch_token = 0;\n\tirq_ptr->qib.rflags &= ~QIB_RFLAGS_ENABLE_QEBSM;\n\tDBF_EVENT(\"noV=V\");\n}\n\n \nint qdio_setup_get_ssqd(struct qdio_irq *irq_ptr,\n\t\t\tstruct subchannel_id *schid,\n\t\t\tstruct qdio_ssqd_desc *data)\n{\n\tstruct chsc_ssqd_area *ssqd;\n\tint rc;\n\n\tDBF_EVENT(\"getssqd:%4x\", schid->sch_no);\n\tif (!irq_ptr) {\n\t\tssqd = (struct chsc_ssqd_area *)__get_free_page(GFP_KERNEL);\n\t\tif (!ssqd)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tssqd = (struct chsc_ssqd_area *)irq_ptr->chsc_page;\n\t}\n\n\trc = chsc_ssqd(*schid, ssqd);\n\tif (rc)\n\t\tgoto out;\n\n\tif (!(ssqd->qdio_ssqd.flags & CHSC_FLAG_QDIO_CAPABILITY) ||\n\t    !(ssqd->qdio_ssqd.flags & CHSC_FLAG_VALIDITY) ||\n\t    (ssqd->qdio_ssqd.sch != schid->sch_no))\n\t\trc = -EINVAL;\n\n\tif (!rc)\n\t\tmemcpy(data, &ssqd->qdio_ssqd, sizeof(*data));\n\nout:\n\tif (!irq_ptr)\n\t\tfree_page((unsigned long)ssqd);\n\n\treturn rc;\n}\n\nvoid qdio_setup_ssqd_info(struct qdio_irq *irq_ptr)\n{\n\tunsigned char qdioac;\n\tint rc;\n\n\trc = qdio_setup_get_ssqd(irq_ptr, &irq_ptr->schid, &irq_ptr->ssqd_desc);\n\tif (rc) {\n\t\tDBF_ERROR(\"%4x ssqd ERR\", irq_ptr->schid.sch_no);\n\t\tDBF_ERROR(\"rc:%x\", rc);\n\t\t \n\t\tqdioac = AC1_SIGA_INPUT_NEEDED | AC1_SIGA_OUTPUT_NEEDED |\n\t\t\t AC1_SIGA_SYNC_NEEDED;\n\t} else\n\t\tqdioac = irq_ptr->ssqd_desc.qdioac1;\n\n\tcheck_and_setup_qebsm(irq_ptr, qdioac, irq_ptr->ssqd_desc.sch_token);\n\tirq_ptr->qdioac1 = qdioac;\n\tDBF_EVENT(\"ac 1:%2x 2:%4x\", qdioac, irq_ptr->ssqd_desc.qdioac2);\n\tDBF_EVENT(\"3:%4x qib:%4x\", irq_ptr->ssqd_desc.qdioac3, irq_ptr->qib.ac);\n}\n\nstatic void qdio_fill_qdr_desc(struct qdesfmt0 *desc, struct qdio_q *queue)\n{\n\tdesc->sliba = virt_to_phys(queue->slib);\n\tdesc->sla = virt_to_phys(queue->sl);\n\tdesc->slsba = virt_to_phys(&queue->slsb);\n\n\tdesc->akey = PAGE_DEFAULT_KEY >> 4;\n\tdesc->bkey = PAGE_DEFAULT_KEY >> 4;\n\tdesc->ckey = PAGE_DEFAULT_KEY >> 4;\n\tdesc->dkey = PAGE_DEFAULT_KEY >> 4;\n}\n\nstatic void setup_qdr(struct qdio_irq *irq_ptr,\n\t\t      struct qdio_initialize *qdio_init)\n{\n\tstruct qdesfmt0 *desc = &irq_ptr->qdr->qdf0[0];\n\tint i;\n\n\tmemset(irq_ptr->qdr, 0, sizeof(struct qdr));\n\n\tirq_ptr->qdr->qfmt = qdio_init->q_format;\n\tirq_ptr->qdr->ac = qdio_init->qdr_ac;\n\tirq_ptr->qdr->iqdcnt = qdio_init->no_input_qs;\n\tirq_ptr->qdr->oqdcnt = qdio_init->no_output_qs;\n\tirq_ptr->qdr->iqdsz = sizeof(struct qdesfmt0) / 4;  \n\tirq_ptr->qdr->oqdsz = sizeof(struct qdesfmt0) / 4;\n\tirq_ptr->qdr->qiba = virt_to_phys(&irq_ptr->qib);\n\tirq_ptr->qdr->qkey = PAGE_DEFAULT_KEY >> 4;\n\n\tfor (i = 0; i < qdio_init->no_input_qs; i++)\n\t\tqdio_fill_qdr_desc(desc++, irq_ptr->input_qs[i]);\n\n\tfor (i = 0; i < qdio_init->no_output_qs; i++)\n\t\tqdio_fill_qdr_desc(desc++, irq_ptr->output_qs[i]);\n}\n\nstatic void setup_qib(struct qdio_irq *irq_ptr,\n\t\t      struct qdio_initialize *init_data)\n{\n\tmemset(&irq_ptr->qib, 0, sizeof(irq_ptr->qib));\n\n\tirq_ptr->qib.qfmt = init_data->q_format;\n\tirq_ptr->qib.pfmt = init_data->qib_param_field_format;\n\n\tirq_ptr->qib.rflags = init_data->qib_rflags;\n\tif (css_general_characteristics.qebsm)\n\t\tirq_ptr->qib.rflags |= QIB_RFLAGS_ENABLE_QEBSM;\n\n\tif (init_data->no_input_qs)\n\t\tirq_ptr->qib.isliba =\n\t\t\t(unsigned long)(irq_ptr->input_qs[0]->slib);\n\tif (init_data->no_output_qs)\n\t\tirq_ptr->qib.osliba =\n\t\t\t(unsigned long)(irq_ptr->output_qs[0]->slib);\n\tmemcpy(irq_ptr->qib.ebcnam, dev_name(&irq_ptr->cdev->dev), 8);\n\tASCEBC(irq_ptr->qib.ebcnam, 8);\n\n\tif (init_data->qib_param_field)\n\t\tmemcpy(irq_ptr->qib.parm, init_data->qib_param_field,\n\t\t       sizeof(irq_ptr->qib.parm));\n}\n\nvoid qdio_setup_irq(struct qdio_irq *irq_ptr, struct qdio_initialize *init_data)\n{\n\tstruct ccw_device *cdev = irq_ptr->cdev;\n\n\tirq_ptr->qdioac1 = 0;\n\tmemset(&irq_ptr->ssqd_desc, 0, sizeof(irq_ptr->ssqd_desc));\n\tmemset(&irq_ptr->perf_stat, 0, sizeof(irq_ptr->perf_stat));\n\n\tirq_ptr->debugfs_dev = NULL;\n\tirq_ptr->sch_token = irq_ptr->perf_stat_enabled = 0;\n\tirq_ptr->state = QDIO_IRQ_STATE_INACTIVE;\n\tirq_ptr->error_handler = init_data->input_handler;\n\n\tirq_ptr->int_parm = init_data->int_parm;\n\tirq_ptr->nr_input_qs = init_data->no_input_qs;\n\tirq_ptr->nr_output_qs = init_data->no_output_qs;\n\tccw_device_get_schid(cdev, &irq_ptr->schid);\n\tsetup_queues(irq_ptr, init_data);\n\n\tirq_ptr->irq_poll = init_data->irq_poll;\n\tset_bit(QDIO_IRQ_DISABLED, &irq_ptr->poll_state);\n\n\tsetup_qib(irq_ptr, init_data);\n\n\t \n\tsetup_qdr(irq_ptr, init_data);\n\n\t \n\n\t \n\tspin_lock_irq(get_ccwdev_lock(cdev));\n\tirq_ptr->orig_handler = cdev->handler;\n\tcdev->handler = qdio_int_handler;\n\tspin_unlock_irq(get_ccwdev_lock(cdev));\n}\n\nvoid qdio_shutdown_irq(struct qdio_irq *irq)\n{\n\tstruct ccw_device *cdev = irq->cdev;\n\n\t \n\tspin_lock_irq(get_ccwdev_lock(cdev));\n\tcdev->handler = irq->orig_handler;\n\tcdev->private->intparm = 0;\n\tspin_unlock_irq(get_ccwdev_lock(cdev));\n}\n\nvoid qdio_print_subchannel_info(struct qdio_irq *irq_ptr)\n{\n\tdev_info(&irq_ptr->cdev->dev,\n\t\t \"qdio: %s on SC %x using AI:%d QEBSM:%d PRI:%d TDD:%d SIGA:%s%s%s\\n\",\n\t\t (irq_ptr->qib.qfmt == QDIO_QETH_QFMT) ? \"OSA\" :\n\t\t\t((irq_ptr->qib.qfmt == QDIO_ZFCP_QFMT) ? \"ZFCP\" : \"HS\"),\n\t\t irq_ptr->schid.sch_no,\n\t\t is_thinint_irq(irq_ptr),\n\t\t (irq_ptr->sch_token) ? 1 : 0,\n\t\t pci_out_supported(irq_ptr) ? 1 : 0,\n\t\t css_general_characteristics.aif_tdd,\n\t\t qdio_need_siga_in(irq_ptr) ? \"R\" : \" \",\n\t\t qdio_need_siga_out(irq_ptr) ? \"W\" : \" \",\n\t\t qdio_need_siga_sync(irq_ptr) ? \"S\" : \" \");\n}\n\nint __init qdio_setup_init(void)\n{\n\tqdio_q_cache = kmem_cache_create(\"qdio_q\", sizeof(struct qdio_q),\n\t\t\t\t\t 256, 0, NULL);\n\tif (!qdio_q_cache)\n\t\treturn -ENOMEM;\n\n\t \n\tDBF_EVENT(\"thinint:%1d\",\n\t\t  (css_general_characteristics.aif_osa) ? 1 : 0);\n\n\t \n\tDBF_EVENT(\"cssQEBSM:%1d\", css_general_characteristics.qebsm);\n\n\treturn 0;\n}\n\nvoid qdio_setup_exit(void)\n{\n\tkmem_cache_destroy(qdio_q_cache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}