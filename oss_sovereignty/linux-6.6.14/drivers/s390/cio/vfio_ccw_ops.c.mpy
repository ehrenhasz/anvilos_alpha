{
  "module_name": "vfio_ccw_ops.c",
  "hash_id": "760e97f7b1ff4ad65e7c7ff3971820ccf27a0184c6923bb244d940d66af4603d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/vfio_ccw_ops.c",
  "human_readable_source": "\n \n\n#include <linux/vfio.h>\n#include <linux/nospec.h>\n#include <linux/slab.h>\n\n#include \"vfio_ccw_private.h\"\n\nstatic const struct vfio_device_ops vfio_ccw_dev_ops;\n\nstatic int vfio_ccw_mdev_reset(struct vfio_ccw_private *private)\n{\n\t \n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_CLOSE);\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_OPEN);\n\tif (private->state == VFIO_CCW_STATE_NOT_OPER)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void vfio_ccw_dma_unmap(struct vfio_device *vdev, u64 iova, u64 length)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\n\t \n\tif (!cp_iova_pinned(&private->cp, iova, length))\n\t\treturn;\n\n\tvfio_ccw_mdev_reset(private);\n}\n\nstatic int vfio_ccw_mdev_init_dev(struct vfio_device *vdev)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\n\tmutex_init(&private->io_mutex);\n\tprivate->state = VFIO_CCW_STATE_STANDBY;\n\tINIT_LIST_HEAD(&private->crw);\n\tINIT_WORK(&private->io_work, vfio_ccw_sch_io_todo);\n\tINIT_WORK(&private->crw_work, vfio_ccw_crw_todo);\n\n\tprivate->cp.guest_cp = kcalloc(CCWCHAIN_LEN_MAX, sizeof(struct ccw1),\n\t\t\t\t       GFP_KERNEL);\n\tif (!private->cp.guest_cp)\n\t\tgoto out_free_private;\n\n\tprivate->io_region = kmem_cache_zalloc(vfio_ccw_io_region,\n\t\t\t\t\t       GFP_KERNEL | GFP_DMA);\n\tif (!private->io_region)\n\t\tgoto out_free_cp;\n\n\tprivate->cmd_region = kmem_cache_zalloc(vfio_ccw_cmd_region,\n\t\t\t\t\t\tGFP_KERNEL | GFP_DMA);\n\tif (!private->cmd_region)\n\t\tgoto out_free_io;\n\n\tprivate->schib_region = kmem_cache_zalloc(vfio_ccw_schib_region,\n\t\t\t\t\t\t  GFP_KERNEL | GFP_DMA);\n\tif (!private->schib_region)\n\t\tgoto out_free_cmd;\n\n\tprivate->crw_region = kmem_cache_zalloc(vfio_ccw_crw_region,\n\t\t\t\t\t\tGFP_KERNEL | GFP_DMA);\n\tif (!private->crw_region)\n\t\tgoto out_free_schib;\n\n\treturn 0;\n\nout_free_schib:\n\tkmem_cache_free(vfio_ccw_schib_region, private->schib_region);\nout_free_cmd:\n\tkmem_cache_free(vfio_ccw_cmd_region, private->cmd_region);\nout_free_io:\n\tkmem_cache_free(vfio_ccw_io_region, private->io_region);\nout_free_cp:\n\tkfree(private->cp.guest_cp);\nout_free_private:\n\tmutex_destroy(&private->io_mutex);\n\treturn -ENOMEM;\n}\n\nstatic int vfio_ccw_mdev_probe(struct mdev_device *mdev)\n{\n\tstruct subchannel *sch = to_subchannel(mdev->dev.parent);\n\tstruct vfio_ccw_parent *parent = dev_get_drvdata(&sch->dev);\n\tstruct vfio_ccw_private *private;\n\tint ret;\n\n\tprivate = vfio_alloc_device(vfio_ccw_private, vdev, &mdev->dev,\n\t\t\t\t    &vfio_ccw_dev_ops);\n\tif (IS_ERR(private))\n\t\treturn PTR_ERR(private);\n\n\tdev_set_drvdata(&parent->dev, private);\n\n\tVFIO_CCW_MSG_EVENT(2, \"sch %x.%x.%04x: create\\n\",\n\t\t\t   sch->schid.cssid,\n\t\t\t   sch->schid.ssid,\n\t\t\t   sch->schid.sch_no);\n\n\tret = vfio_register_emulated_iommu_dev(&private->vdev);\n\tif (ret)\n\t\tgoto err_put_vdev;\n\tdev_set_drvdata(&mdev->dev, private);\n\treturn 0;\n\nerr_put_vdev:\n\tdev_set_drvdata(&parent->dev, NULL);\n\tvfio_put_device(&private->vdev);\n\treturn ret;\n}\n\nstatic void vfio_ccw_mdev_release_dev(struct vfio_device *vdev)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\tstruct vfio_ccw_crw *crw, *temp;\n\n\tlist_for_each_entry_safe(crw, temp, &private->crw, next) {\n\t\tlist_del(&crw->next);\n\t\tkfree(crw);\n\t}\n\n\tkmem_cache_free(vfio_ccw_crw_region, private->crw_region);\n\tkmem_cache_free(vfio_ccw_schib_region, private->schib_region);\n\tkmem_cache_free(vfio_ccw_cmd_region, private->cmd_region);\n\tkmem_cache_free(vfio_ccw_io_region, private->io_region);\n\tkfree(private->cp.guest_cp);\n\tmutex_destroy(&private->io_mutex);\n}\n\nstatic void vfio_ccw_mdev_remove(struct mdev_device *mdev)\n{\n\tstruct subchannel *sch = to_subchannel(mdev->dev.parent);\n\tstruct vfio_ccw_parent *parent = dev_get_drvdata(&sch->dev);\n\tstruct vfio_ccw_private *private = dev_get_drvdata(&parent->dev);\n\n\tVFIO_CCW_MSG_EVENT(2, \"sch %x.%x.%04x: remove\\n\",\n\t\t\t   sch->schid.cssid,\n\t\t\t   sch->schid.ssid,\n\t\t\t   sch->schid.sch_no);\n\n\tvfio_unregister_group_dev(&private->vdev);\n\n\tdev_set_drvdata(&parent->dev, NULL);\n\tvfio_put_device(&private->vdev);\n}\n\nstatic int vfio_ccw_mdev_open_device(struct vfio_device *vdev)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\tint ret;\n\n\t \n\tif (private->state == VFIO_CCW_STATE_NOT_OPER)\n\t\treturn -EINVAL;\n\n\tret = vfio_ccw_register_async_dev_regions(private);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vfio_ccw_register_schib_dev_regions(private);\n\tif (ret)\n\t\tgoto out_unregister;\n\n\tret = vfio_ccw_register_crw_dev_regions(private);\n\tif (ret)\n\t\tgoto out_unregister;\n\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_OPEN);\n\tif (private->state == VFIO_CCW_STATE_NOT_OPER) {\n\t\tret = -EINVAL;\n\t\tgoto out_unregister;\n\t}\n\n\treturn ret;\n\nout_unregister:\n\tvfio_ccw_unregister_dev_regions(private);\n\treturn ret;\n}\n\nstatic void vfio_ccw_mdev_close_device(struct vfio_device *vdev)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_CLOSE);\n\tvfio_ccw_unregister_dev_regions(private);\n}\n\nstatic ssize_t vfio_ccw_mdev_read_io_region(struct vfio_ccw_private *private,\n\t\t\t\t\t    char __user *buf, size_t count,\n\t\t\t\t\t    loff_t *ppos)\n{\n\tloff_t pos = *ppos & VFIO_CCW_OFFSET_MASK;\n\tstruct ccw_io_region *region;\n\tint ret;\n\n\tif (pos + count > sizeof(*region))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&private->io_mutex);\n\tregion = private->io_region;\n\tif (copy_to_user(buf, (void *)region + pos, count))\n\t\tret = -EFAULT;\n\telse\n\t\tret = count;\n\tmutex_unlock(&private->io_mutex);\n\treturn ret;\n}\n\nstatic ssize_t vfio_ccw_mdev_read(struct vfio_device *vdev,\n\t\t\t\t  char __user *buf,\n\t\t\t\t  size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\tunsigned int index = VFIO_CCW_OFFSET_TO_INDEX(*ppos);\n\n\tif (index >= VFIO_CCW_NUM_REGIONS + private->num_regions)\n\t\treturn -EINVAL;\n\n\tswitch (index) {\n\tcase VFIO_CCW_CONFIG_REGION_INDEX:\n\t\treturn vfio_ccw_mdev_read_io_region(private, buf, count, ppos);\n\tdefault:\n\t\tindex -= VFIO_CCW_NUM_REGIONS;\n\t\treturn private->region[index].ops->read(private, buf, count,\n\t\t\t\t\t\t\tppos);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t vfio_ccw_mdev_write_io_region(struct vfio_ccw_private *private,\n\t\t\t\t\t     const char __user *buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tloff_t pos = *ppos & VFIO_CCW_OFFSET_MASK;\n\tstruct ccw_io_region *region;\n\tint ret;\n\n\tif (pos + count > sizeof(*region))\n\t\treturn -EINVAL;\n\n\tif (!mutex_trylock(&private->io_mutex))\n\t\treturn -EAGAIN;\n\n\tregion = private->io_region;\n\tif (copy_from_user((void *)region + pos, buf, count)) {\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\tvfio_ccw_fsm_event(private, VFIO_CCW_EVENT_IO_REQ);\n\tret = (region->ret_code != 0) ? region->ret_code : count;\n\nout_unlock:\n\tmutex_unlock(&private->io_mutex);\n\treturn ret;\n}\n\nstatic ssize_t vfio_ccw_mdev_write(struct vfio_device *vdev,\n\t\t\t\t   const char __user *buf,\n\t\t\t\t   size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\tunsigned int index = VFIO_CCW_OFFSET_TO_INDEX(*ppos);\n\n\tif (index >= VFIO_CCW_NUM_REGIONS + private->num_regions)\n\t\treturn -EINVAL;\n\n\tswitch (index) {\n\tcase VFIO_CCW_CONFIG_REGION_INDEX:\n\t\treturn vfio_ccw_mdev_write_io_region(private, buf, count, ppos);\n\tdefault:\n\t\tindex -= VFIO_CCW_NUM_REGIONS;\n\t\treturn private->region[index].ops->write(private, buf, count,\n\t\t\t\t\t\t\t ppos);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int vfio_ccw_mdev_get_device_info(struct vfio_ccw_private *private,\n\t\t\t\t\t struct vfio_device_info *info)\n{\n\tinfo->flags = VFIO_DEVICE_FLAGS_CCW | VFIO_DEVICE_FLAGS_RESET;\n\tinfo->num_regions = VFIO_CCW_NUM_REGIONS + private->num_regions;\n\tinfo->num_irqs = VFIO_CCW_NUM_IRQS;\n\n\treturn 0;\n}\n\nstatic int vfio_ccw_mdev_get_region_info(struct vfio_ccw_private *private,\n\t\t\t\t\t struct vfio_region_info *info,\n\t\t\t\t\t unsigned long arg)\n{\n\tint i;\n\n\tswitch (info->index) {\n\tcase VFIO_CCW_CONFIG_REGION_INDEX:\n\t\tinfo->offset = 0;\n\t\tinfo->size = sizeof(struct ccw_io_region);\n\t\tinfo->flags = VFIO_REGION_INFO_FLAG_READ\n\t\t\t      | VFIO_REGION_INFO_FLAG_WRITE;\n\t\treturn 0;\n\tdefault:  \n\t{\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tstruct vfio_region_info_cap_type cap_type = {\n\t\t\t.header.id = VFIO_REGION_INFO_CAP_TYPE,\n\t\t\t.header.version = 1 };\n\t\tint ret;\n\n\t\tif (info->index >=\n\t\t    VFIO_CCW_NUM_REGIONS + private->num_regions)\n\t\t\treturn -EINVAL;\n\n\t\tinfo->index = array_index_nospec(info->index,\n\t\t\t\t\t\t VFIO_CCW_NUM_REGIONS +\n\t\t\t\t\t\t private->num_regions);\n\n\t\ti = info->index - VFIO_CCW_NUM_REGIONS;\n\n\t\tinfo->offset = VFIO_CCW_INDEX_TO_OFFSET(info->index);\n\t\tinfo->size = private->region[i].size;\n\t\tinfo->flags = private->region[i].flags;\n\n\t\tcap_type.type = private->region[i].type;\n\t\tcap_type.subtype = private->region[i].subtype;\n\n\t\tret = vfio_info_add_capability(&caps, &cap_type.header,\n\t\t\t\t\t       sizeof(cap_type));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tinfo->flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\tif (info->argsz < sizeof(*info) + caps.size) {\n\t\t\tinfo->argsz = sizeof(*info) + caps.size;\n\t\t\tinfo->cap_offset = 0;\n\t\t} else {\n\t\t\tvfio_info_cap_shift(&caps, sizeof(*info));\n\t\t\tif (copy_to_user((void __user *)arg + sizeof(*info),\n\t\t\t\t\t caps.buf, caps.size)) {\n\t\t\t\tkfree(caps.buf);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tinfo->cap_offset = sizeof(*info);\n\t\t}\n\n\t\tkfree(caps.buf);\n\n\t}\n\t}\n\treturn 0;\n}\n\nstatic int vfio_ccw_mdev_get_irq_info(struct vfio_irq_info *info)\n{\n\tswitch (info->index) {\n\tcase VFIO_CCW_IO_IRQ_INDEX:\n\tcase VFIO_CCW_CRW_IRQ_INDEX:\n\tcase VFIO_CCW_REQ_IRQ_INDEX:\n\t\tinfo->count = 1;\n\t\tinfo->flags = VFIO_IRQ_INFO_EVENTFD;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vfio_ccw_mdev_set_irqs(struct vfio_ccw_private *private,\n\t\t\t\t  uint32_t flags,\n\t\t\t\t  uint32_t index,\n\t\t\t\t  void __user *data)\n{\n\tstruct eventfd_ctx **ctx;\n\n\tif (!(flags & VFIO_IRQ_SET_ACTION_TRIGGER))\n\t\treturn -EINVAL;\n\n\tswitch (index) {\n\tcase VFIO_CCW_IO_IRQ_INDEX:\n\t\tctx = &private->io_trigger;\n\t\tbreak;\n\tcase VFIO_CCW_CRW_IRQ_INDEX:\n\t\tctx = &private->crw_trigger;\n\t\tbreak;\n\tcase VFIO_CCW_REQ_IRQ_INDEX:\n\t\tctx = &private->req_trigger;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\tcase VFIO_IRQ_SET_DATA_NONE:\n\t{\n\t\tif (*ctx)\n\t\t\teventfd_signal(*ctx, 1);\n\t\treturn 0;\n\t}\n\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t{\n\t\tuint8_t trigger;\n\n\t\tif (get_user(trigger, (uint8_t __user *)data))\n\t\t\treturn -EFAULT;\n\n\t\tif (trigger && *ctx)\n\t\t\teventfd_signal(*ctx, 1);\n\t\treturn 0;\n\t}\n\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t{\n\t\tint32_t fd;\n\n\t\tif (get_user(fd, (int32_t __user *)data))\n\t\t\treturn -EFAULT;\n\n\t\tif (fd == -1) {\n\t\t\tif (*ctx)\n\t\t\t\teventfd_ctx_put(*ctx);\n\t\t\t*ctx = NULL;\n\t\t} else if (fd >= 0) {\n\t\t\tstruct eventfd_ctx *efdctx;\n\n\t\t\tefdctx = eventfd_ctx_fdget(fd);\n\t\t\tif (IS_ERR(efdctx))\n\t\t\t\treturn PTR_ERR(efdctx);\n\n\t\t\tif (*ctx)\n\t\t\t\teventfd_ctx_put(*ctx);\n\n\t\t\t*ctx = efdctx;\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint vfio_ccw_register_dev_region(struct vfio_ccw_private *private,\n\t\t\t\t unsigned int subtype,\n\t\t\t\t const struct vfio_ccw_regops *ops,\n\t\t\t\t size_t size, u32 flags, void *data)\n{\n\tstruct vfio_ccw_region *region;\n\n\tregion = krealloc(private->region,\n\t\t\t  (private->num_regions + 1) * sizeof(*region),\n\t\t\t  GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tprivate->region = region;\n\tprivate->region[private->num_regions].type = VFIO_REGION_TYPE_CCW;\n\tprivate->region[private->num_regions].subtype = subtype;\n\tprivate->region[private->num_regions].ops = ops;\n\tprivate->region[private->num_regions].size = size;\n\tprivate->region[private->num_regions].flags = flags;\n\tprivate->region[private->num_regions].data = data;\n\n\tprivate->num_regions++;\n\n\treturn 0;\n}\n\nvoid vfio_ccw_unregister_dev_regions(struct vfio_ccw_private *private)\n{\n\tint i;\n\n\tfor (i = 0; i < private->num_regions; i++)\n\t\tprivate->region[i].ops->release(private, &private->region[i]);\n\tprivate->num_regions = 0;\n\tkfree(private->region);\n\tprivate->region = NULL;\n}\n\nstatic ssize_t vfio_ccw_mdev_ioctl(struct vfio_device *vdev,\n\t\t\t\t   unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\tint ret = 0;\n\tunsigned long minsz;\n\n\tswitch (cmd) {\n\tcase VFIO_DEVICE_GET_INFO:\n\t{\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = vfio_ccw_mdev_get_device_info(private, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ? -EFAULT : 0;\n\t}\n\tcase VFIO_DEVICE_GET_REGION_INFO:\n\t{\n\t\tstruct vfio_region_info info;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = vfio_ccw_mdev_get_region_info(private, &info, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ? -EFAULT : 0;\n\t}\n\tcase VFIO_DEVICE_GET_IRQ_INFO:\n\t{\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_CCW_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tret = vfio_ccw_mdev_get_irq_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (info.count == -1)\n\t\t\treturn -EINVAL;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ? -EFAULT : 0;\n\t}\n\tcase VFIO_DEVICE_SET_IRQS:\n\t{\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t data_size;\n\t\tvoid __user *data;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tret = vfio_set_irqs_validate_and_prepare(&hdr, 1,\n\t\t\t\t\t\t\t VFIO_CCW_NUM_IRQS,\n\t\t\t\t\t\t\t &data_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = (void __user *)(arg + minsz);\n\t\treturn vfio_ccw_mdev_set_irqs(private, hdr.flags, hdr.index,\n\t\t\t\t\t      data);\n\t}\n\tcase VFIO_DEVICE_RESET:\n\t\treturn vfio_ccw_mdev_reset(private);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \nstatic void vfio_ccw_mdev_request(struct vfio_device *vdev, unsigned int count)\n{\n\tstruct vfio_ccw_private *private =\n\t\tcontainer_of(vdev, struct vfio_ccw_private, vdev);\n\tstruct device *dev = vdev->dev;\n\n\tif (private->req_trigger) {\n\t\tif (!(count % 10))\n\t\t\tdev_notice_ratelimited(dev,\n\t\t\t\t\t       \"Relaying device request to user (#%u)\\n\",\n\t\t\t\t\t       count);\n\n\t\teventfd_signal(private->req_trigger, 1);\n\t} else if (count == 0) {\n\t\tdev_notice(dev,\n\t\t\t   \"No device request channel registered, blocked until released by user\\n\");\n\t}\n}\n\nstatic const struct vfio_device_ops vfio_ccw_dev_ops = {\n\t.init = vfio_ccw_mdev_init_dev,\n\t.release = vfio_ccw_mdev_release_dev,\n\t.open_device = vfio_ccw_mdev_open_device,\n\t.close_device = vfio_ccw_mdev_close_device,\n\t.read = vfio_ccw_mdev_read,\n\t.write = vfio_ccw_mdev_write,\n\t.ioctl = vfio_ccw_mdev_ioctl,\n\t.request = vfio_ccw_mdev_request,\n\t.dma_unmap = vfio_ccw_dma_unmap,\n\t.bind_iommufd = vfio_iommufd_emulated_bind,\n\t.unbind_iommufd = vfio_iommufd_emulated_unbind,\n\t.attach_ioas = vfio_iommufd_emulated_attach_ioas,\n\t.detach_ioas = vfio_iommufd_emulated_detach_ioas,\n};\n\nstruct mdev_driver vfio_ccw_mdev_driver = {\n\t.device_api = VFIO_DEVICE_API_CCW_STRING,\n\t.max_instances = 1,\n\t.driver = {\n\t\t.name = \"vfio_ccw_mdev\",\n\t\t.owner = THIS_MODULE,\n\t\t.mod_name = KBUILD_MODNAME,\n\t},\n\t.probe = vfio_ccw_mdev_probe,\n\t.remove = vfio_ccw_mdev_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}