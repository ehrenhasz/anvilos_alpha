{
  "module_name": "cio.c",
  "hash_id": "24ca504e807fb602bf3395308e78150882f9ec665ada4c009bd84f9db2ef6c52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/cio.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"cio\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <asm/cio.h>\n#include <asm/delay.h>\n#include <asm/irq.h>\n#include <asm/irq_regs.h>\n#include <asm/setup.h>\n#include <asm/ipl.h>\n#include <asm/chpid.h>\n#include <asm/airq.h>\n#include <asm/isc.h>\n#include <linux/sched/cputime.h>\n#include <asm/fcx.h>\n#include <asm/nmi.h>\n#include <asm/crw.h>\n#include \"cio.h\"\n#include \"css.h\"\n#include \"chsc.h\"\n#include \"ioasm.h\"\n#include \"io_sch.h\"\n#include \"blacklist.h\"\n#include \"cio_debug.h\"\n#include \"chp.h\"\n#include \"trace.h\"\n\ndebug_info_t *cio_debug_msg_id;\ndebug_info_t *cio_debug_trace_id;\ndebug_info_t *cio_debug_crw_id;\n\nDEFINE_PER_CPU_ALIGNED(struct irb, cio_irb);\nEXPORT_PER_CPU_SYMBOL(cio_irb);\n\n \nstatic int __init cio_debug_init(void)\n{\n\tcio_debug_msg_id = debug_register(\"cio_msg\", 16, 1, 11 * sizeof(long));\n\tif (!cio_debug_msg_id)\n\t\tgoto out_unregister;\n\tdebug_register_view(cio_debug_msg_id, &debug_sprintf_view);\n\tdebug_set_level(cio_debug_msg_id, 2);\n\tcio_debug_trace_id = debug_register(\"cio_trace\", 16, 1, 16);\n\tif (!cio_debug_trace_id)\n\t\tgoto out_unregister;\n\tdebug_register_view(cio_debug_trace_id, &debug_hex_ascii_view);\n\tdebug_set_level(cio_debug_trace_id, 2);\n\tcio_debug_crw_id = debug_register(\"cio_crw\", 8, 1, 8 * sizeof(long));\n\tif (!cio_debug_crw_id)\n\t\tgoto out_unregister;\n\tdebug_register_view(cio_debug_crw_id, &debug_sprintf_view);\n\tdebug_set_level(cio_debug_crw_id, 4);\n\treturn 0;\n\nout_unregister:\n\tdebug_unregister(cio_debug_msg_id);\n\tdebug_unregister(cio_debug_trace_id);\n\tdebug_unregister(cio_debug_crw_id);\n\treturn -1;\n}\n\narch_initcall (cio_debug_init);\n\nint cio_set_options(struct subchannel *sch, int flags)\n{\n\tstruct io_subchannel_private *priv = to_io_private(sch);\n\n\tpriv->options.suspend = (flags & DOIO_ALLOW_SUSPEND) != 0;\n\tpriv->options.prefetch = (flags & DOIO_DENY_PREFETCH) != 0;\n\tpriv->options.inter = (flags & DOIO_SUPPRESS_INTER) != 0;\n\treturn 0;\n}\n\nstatic int\ncio_start_handle_notoper(struct subchannel *sch, __u8 lpm)\n{\n\tchar dbf_text[15];\n\n\tif (lpm != 0)\n\t\tsch->lpm &= ~lpm;\n\telse\n\t\tsch->lpm = 0;\n\n\tCIO_MSG_EVENT(2, \"cio_start: 'not oper' status for \"\n\t\t      \"subchannel 0.%x.%04x!\\n\", sch->schid.ssid,\n\t\t      sch->schid.sch_no);\n\n\tif (cio_update_schib(sch))\n\t\treturn -ENODEV;\n\n\tsprintf(dbf_text, \"no%s\", dev_name(&sch->dev));\n\tCIO_TRACE_EVENT(0, dbf_text);\n\tCIO_HEX_EVENT(0, &sch->schib, sizeof (struct schib));\n\n\treturn (sch->lpm ? -EACCES : -ENODEV);\n}\n\nint\ncio_start_key (struct subchannel *sch,\t \n\t       struct ccw1 * cpa,\t \n\t       __u8 lpm,\t\t \n\t       __u8 key)                 \n{\n\tstruct io_subchannel_private *priv = to_io_private(sch);\n\tunion orb *orb = &priv->orb;\n\tint ccode;\n\n\tCIO_TRACE_EVENT(5, \"stIO\");\n\tCIO_TRACE_EVENT(5, dev_name(&sch->dev));\n\n\tmemset(orb, 0, sizeof(union orb));\n\t \n\torb->cmd.intparm = (u32)virt_to_phys(sch);\n\torb->cmd.fmt = 1;\n\n\torb->cmd.pfch = priv->options.prefetch == 0;\n\torb->cmd.spnd = priv->options.suspend;\n\torb->cmd.ssic = priv->options.suspend && priv->options.inter;\n\torb->cmd.lpm = (lpm != 0) ? lpm : sch->lpm;\n\t \n\torb->cmd.c64 = 1;\n\torb->cmd.i2k = 0;\n\torb->cmd.key = key >> 4;\n\t \n\torb->cmd.cpa = (u32)virt_to_phys(cpa);\n\tccode = ssch(sch->schid, orb);\n\n\t \n\tCIO_HEX_EVENT(5, &ccode, sizeof(ccode));\n\n\tswitch (ccode) {\n\tcase 0:\n\t\t \n\t\tsch->schib.scsw.cmd.actl |= SCSW_ACTL_START_PEND;\n\t\treturn 0;\n\tcase 1:\t\t \n\tcase 2:\t\t \n\t\treturn -EBUSY;\n\tcase 3:\t\t \n\t\treturn cio_start_handle_notoper(sch, lpm);\n\tdefault:\n\t\treturn ccode;\n\t}\n}\nEXPORT_SYMBOL_GPL(cio_start_key);\n\nint\ncio_start (struct subchannel *sch, struct ccw1 *cpa, __u8 lpm)\n{\n\treturn cio_start_key(sch, cpa, lpm, PAGE_DEFAULT_KEY);\n}\nEXPORT_SYMBOL_GPL(cio_start);\n\n \nint\ncio_resume (struct subchannel *sch)\n{\n\tint ccode;\n\n\tCIO_TRACE_EVENT(4, \"resIO\");\n\tCIO_TRACE_EVENT(4, dev_name(&sch->dev));\n\n\tccode = rsch (sch->schid);\n\n\tCIO_HEX_EVENT(4, &ccode, sizeof(ccode));\n\n\tswitch (ccode) {\n\tcase 0:\n\t\tsch->schib.scsw.cmd.actl |= SCSW_ACTL_RESUME_PEND;\n\t\treturn 0;\n\tcase 1:\n\t\treturn -EBUSY;\n\tcase 2:\n\t\treturn -EINVAL;\n\tdefault:\n\t\t \n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL_GPL(cio_resume);\n\n \nint\ncio_halt(struct subchannel *sch)\n{\n\tint ccode;\n\n\tif (!sch)\n\t\treturn -ENODEV;\n\n\tCIO_TRACE_EVENT(2, \"haltIO\");\n\tCIO_TRACE_EVENT(2, dev_name(&sch->dev));\n\n\t \n\tccode = hsch (sch->schid);\n\n\tCIO_HEX_EVENT(2, &ccode, sizeof(ccode));\n\n\tswitch (ccode) {\n\tcase 0:\n\t\tsch->schib.scsw.cmd.actl |= SCSW_ACTL_HALT_PEND;\n\t\treturn 0;\n\tcase 1:\t\t \n\tcase 2:\t\t \n\t\treturn -EBUSY;\n\tdefault:\t\t \n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL_GPL(cio_halt);\n\n \nint\ncio_clear(struct subchannel *sch)\n{\n\tint ccode;\n\n\tif (!sch)\n\t\treturn -ENODEV;\n\n\tCIO_TRACE_EVENT(2, \"clearIO\");\n\tCIO_TRACE_EVENT(2, dev_name(&sch->dev));\n\n\t \n\tccode = csch (sch->schid);\n\n\tCIO_HEX_EVENT(2, &ccode, sizeof(ccode));\n\n\tswitch (ccode) {\n\tcase 0:\n\t\tsch->schib.scsw.cmd.actl |= SCSW_ACTL_CLEAR_PEND;\n\t\treturn 0;\n\tdefault:\t\t \n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL_GPL(cio_clear);\n\n \nint\ncio_cancel (struct subchannel *sch)\n{\n\tint ccode;\n\n\tif (!sch)\n\t\treturn -ENODEV;\n\n\tCIO_TRACE_EVENT(2, \"cancelIO\");\n\tCIO_TRACE_EVENT(2, dev_name(&sch->dev));\n\n\tccode = xsch (sch->schid);\n\n\tCIO_HEX_EVENT(2, &ccode, sizeof(ccode));\n\n\tswitch (ccode) {\n\tcase 0:\t\t \n\t\t \n\t\tif (cio_update_schib(sch))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\tcase 1:\t\t \n\t\treturn -EBUSY;\n\tcase 2:\t\t \n\t\treturn -EINVAL;\n\tdefault:\t \n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL_GPL(cio_cancel);\n\n \nint cio_cancel_halt_clear(struct subchannel *sch, int *iretry)\n{\n\tint ret;\n\n\tif (cio_update_schib(sch))\n\t\treturn -ENODEV;\n\tif (!sch->schib.pmcw.ena)\n\t\t \n\t\treturn 0;\n\t \n\tif (!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_HALT_PEND) &&\n\t    !(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_CLEAR_PEND)) {\n\t\tif (!scsw_is_tm(&sch->schib.scsw)) {\n\t\t\tret = cio_cancel(sch);\n\t\t\tif (ret != -EINVAL)\n\t\t\t\treturn ret;\n\t\t}\n\t\t \n\t\t*iretry = 3;\t \n\t}\n\t \n\tif (!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_CLEAR_PEND)) {\n\t\tif (*iretry) {\n\t\t\t*iretry -= 1;\n\t\t\tret = cio_halt(sch);\n\t\t\tif (ret != -EBUSY)\n\t\t\t\treturn (ret == 0) ? -EBUSY : ret;\n\t\t}\n\t\t \n\t\t*iretry = 255;\t \n\t}\n\t \n\tif (*iretry) {\n\t\t*iretry -= 1;\n\t\tret = cio_clear(sch);\n\t\treturn (ret == 0) ? -EBUSY : ret;\n\t}\n\t \n\treturn -EIO;\n}\nEXPORT_SYMBOL_GPL(cio_cancel_halt_clear);\n\nstatic void cio_apply_config(struct subchannel *sch, struct schib *schib)\n{\n\tschib->pmcw.intparm = sch->config.intparm;\n\tschib->pmcw.mbi = sch->config.mbi;\n\tschib->pmcw.isc = sch->config.isc;\n\tschib->pmcw.ena = sch->config.ena;\n\tschib->pmcw.mme = sch->config.mme;\n\tschib->pmcw.mp = sch->config.mp;\n\tschib->pmcw.csense = sch->config.csense;\n\tschib->pmcw.mbfc = sch->config.mbfc;\n\tif (sch->config.mbfc)\n\t\tschib->mba = sch->config.mba;\n}\n\nstatic int cio_check_config(struct subchannel *sch, struct schib *schib)\n{\n\treturn (schib->pmcw.intparm == sch->config.intparm) &&\n\t\t(schib->pmcw.mbi == sch->config.mbi) &&\n\t\t(schib->pmcw.isc == sch->config.isc) &&\n\t\t(schib->pmcw.ena == sch->config.ena) &&\n\t\t(schib->pmcw.mme == sch->config.mme) &&\n\t\t(schib->pmcw.mp == sch->config.mp) &&\n\t\t(schib->pmcw.csense == sch->config.csense) &&\n\t\t(schib->pmcw.mbfc == sch->config.mbfc) &&\n\t\t(!sch->config.mbfc || (schib->mba == sch->config.mba));\n}\n\n \nint cio_commit_config(struct subchannel *sch)\n{\n\tint ccode, retry, ret = 0;\n\tstruct schib schib;\n\tstruct irb irb;\n\n\tif (stsch(sch->schid, &schib) || !css_sch_is_valid(&schib))\n\t\treturn -ENODEV;\n\n\tfor (retry = 0; retry < 5; retry++) {\n\t\t \n\t\tcio_apply_config(sch, &schib);\n\t\tccode = msch(sch->schid, &schib);\n\t\tif (ccode < 0)  \n\t\t\treturn ccode;\n\t\tswitch (ccode) {\n\t\tcase 0:  \n\t\t\tif (stsch(sch->schid, &schib) ||\n\t\t\t    !css_sch_is_valid(&schib))\n\t\t\t\treturn -ENODEV;\n\t\t\tif (cio_check_config(sch, &schib)) {\n\t\t\t\t \n\t\t\t\tmemcpy(&sch->schib, &schib, sizeof(schib));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tret = -EBUSY;\n\t\t\tif (tsch(sch->schid, &irb))\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tudelay(100);  \n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cio_commit_config);\n\n \nint cio_update_schib(struct subchannel *sch)\n{\n\tstruct schib schib;\n\n\tif (stsch(sch->schid, &schib) || !css_sch_is_valid(&schib))\n\t\treturn -ENODEV;\n\n\tmemcpy(&sch->schib, &schib, sizeof(schib));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cio_update_schib);\n\n \nint cio_enable_subchannel(struct subchannel *sch, u32 intparm)\n{\n\tint ret;\n\n\tCIO_TRACE_EVENT(2, \"ensch\");\n\tCIO_TRACE_EVENT(2, dev_name(&sch->dev));\n\n\tif (sch_is_pseudo_sch(sch))\n\t\treturn -EINVAL;\n\tif (cio_update_schib(sch))\n\t\treturn -ENODEV;\n\n\tsch->config.ena = 1;\n\tsch->config.isc = sch->isc;\n\tsch->config.intparm = intparm;\n\n\tret = cio_commit_config(sch);\n\tif (ret == -EIO) {\n\t\t \n\t\tsch->config.csense = 0;\n\t\tret = cio_commit_config(sch);\n\t}\n\tCIO_HEX_EVENT(2, &ret, sizeof(ret));\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cio_enable_subchannel);\n\n \nint cio_disable_subchannel(struct subchannel *sch)\n{\n\tint ret;\n\n\tCIO_TRACE_EVENT(2, \"dissch\");\n\tCIO_TRACE_EVENT(2, dev_name(&sch->dev));\n\n\tif (sch_is_pseudo_sch(sch))\n\t\treturn 0;\n\tif (cio_update_schib(sch))\n\t\treturn -ENODEV;\n\n\tsch->config.ena = 0;\n\tret = cio_commit_config(sch);\n\n\tCIO_HEX_EVENT(2, &ret, sizeof(ret));\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cio_disable_subchannel);\n\n \nstatic irqreturn_t do_cio_interrupt(int irq, void *dummy)\n{\n\tstruct tpi_info *tpi_info;\n\tstruct subchannel *sch;\n\tstruct irb *irb;\n\n\tset_cpu_flag(CIF_NOHZ_DELAY);\n\ttpi_info = &get_irq_regs()->tpi_info;\n\ttrace_s390_cio_interrupt(tpi_info);\n\tirb = this_cpu_ptr(&cio_irb);\n\tif (!tpi_info->intparm) {\n\t\t \n\t\tinc_irq_stat(IRQIO_CIO);\n\t\ttsch(tpi_info->schid, irb);\n\t\treturn IRQ_HANDLED;\n\t}\n\tsch = phys_to_virt(tpi_info->intparm);\n\tspin_lock(sch->lock);\n\t \n\tif (tsch(tpi_info->schid, irb) == 0) {\n\t\t \n\t\tmemcpy (&sch->schib.scsw, &irb->scsw, sizeof (irb->scsw));\n\t\t \n\t\tif (sch->driver && sch->driver->irq)\n\t\t\tsch->driver->irq(sch);\n\t\telse\n\t\t\tinc_irq_stat(IRQIO_CIO);\n\t} else\n\t\tinc_irq_stat(IRQIO_CIO);\n\tspin_unlock(sch->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid __init init_cio_interrupts(void)\n{\n\tirq_set_chip_and_handler(IO_INTERRUPT,\n\t\t\t\t &dummy_irq_chip, handle_percpu_irq);\n\tif (request_irq(IO_INTERRUPT, do_cio_interrupt, 0, \"I/O\", NULL))\n\t\tpanic(\"Failed to register I/O interrupt\\n\");\n}\n\n#ifdef CONFIG_CCW_CONSOLE\nstatic struct subchannel *console_sch;\nstatic struct lock_class_key console_sch_key;\n\n \nvoid cio_tsch(struct subchannel *sch)\n{\n\tstruct irb *irb;\n\tint irq_context;\n\n\tirb = this_cpu_ptr(&cio_irb);\n\t \n\tif (tsch(sch->schid, irb) != 0)\n\t\t \n\t\treturn;\n\tmemcpy(&sch->schib.scsw, &irb->scsw, sizeof(union scsw));\n\t \n\tirq_context = in_interrupt();\n\tif (!irq_context) {\n\t\tlocal_bh_disable();\n\t\tirq_enter();\n\t}\n\tkstat_incr_irq_this_cpu(IO_INTERRUPT);\n\tif (sch->driver && sch->driver->irq)\n\t\tsch->driver->irq(sch);\n\telse\n\t\tinc_irq_stat(IRQIO_CIO);\n\tif (!irq_context) {\n\t\tirq_exit();\n\t\t_local_bh_enable();\n\t}\n}\n\nstatic int cio_test_for_console(struct subchannel_id schid, void *data)\n{\n\tstruct schib schib;\n\n\tif (stsch(schid, &schib) != 0)\n\t\treturn -ENXIO;\n\tif ((schib.pmcw.st == SUBCHANNEL_TYPE_IO) && schib.pmcw.dnv &&\n\t    (schib.pmcw.dev == console_devno)) {\n\t\tconsole_irq = schid.sch_no;\n\t\treturn 1;  \n\t}\n\treturn 0;\n}\n\nstatic int cio_get_console_sch_no(void)\n{\n\tstruct subchannel_id schid;\n\tstruct schib schib;\n\n\tinit_subchannel_id(&schid);\n\tif (console_irq != -1) {\n\t\t \n\t\tschid.sch_no = console_irq;\n\t\tif (stsch(schid, &schib) != 0 ||\n\t\t    (schib.pmcw.st != SUBCHANNEL_TYPE_IO) || !schib.pmcw.dnv)\n\t\t\treturn -1;\n\t\tconsole_devno = schib.pmcw.dev;\n\t} else if (console_devno != -1) {\n\t\t \n\t\tfor_each_subchannel(cio_test_for_console, NULL);\n\t}\n\treturn console_irq;\n}\n\nstruct subchannel *cio_probe_console(void)\n{\n\tstruct subchannel_id schid;\n\tstruct subchannel *sch;\n\tstruct schib schib;\n\tint sch_no, ret;\n\n\tsch_no = cio_get_console_sch_no();\n\tif (sch_no == -1) {\n\t\tpr_warn(\"No CCW console was found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tinit_subchannel_id(&schid);\n\tschid.sch_no = sch_no;\n\tret = stsch(schid, &schib);\n\tif (ret)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsch = css_alloc_subchannel(schid, &schib);\n\tif (IS_ERR(sch))\n\t\treturn sch;\n\n\tlockdep_set_class(sch->lock, &console_sch_key);\n\tisc_register(CONSOLE_ISC);\n\tsch->config.isc = CONSOLE_ISC;\n\tsch->config.intparm = (u32)virt_to_phys(sch);\n\tret = cio_commit_config(sch);\n\tif (ret) {\n\t\tisc_unregister(CONSOLE_ISC);\n\t\tput_device(&sch->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\tconsole_sch = sch;\n\treturn sch;\n}\n\nint cio_is_console(struct subchannel_id schid)\n{\n\tif (!console_sch)\n\t\treturn 0;\n\treturn schid_equal(&schid, &console_sch->schid);\n}\n\nvoid cio_register_early_subchannels(void)\n{\n\tint ret;\n\n\tif (!console_sch)\n\t\treturn;\n\n\tret = css_register_subchannel(console_sch);\n\tif (ret)\n\t\tput_device(&console_sch->dev);\n}\n#endif  \n\n \nint cio_tm_start_key(struct subchannel *sch, struct tcw *tcw, u8 lpm, u8 key)\n{\n\tint cc;\n\tunion orb *orb = &to_io_private(sch)->orb;\n\n\tmemset(orb, 0, sizeof(union orb));\n\torb->tm.intparm = (u32)virt_to_phys(sch);\n\torb->tm.key = key >> 4;\n\torb->tm.b = 1;\n\torb->tm.lpm = lpm ? lpm : sch->lpm;\n\torb->tm.tcw = (u32)virt_to_phys(tcw);\n\tcc = ssch(sch->schid, orb);\n\tswitch (cc) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\tcase 2:\n\t\treturn -EBUSY;\n\tdefault:\n\t\treturn cio_start_handle_notoper(sch, lpm);\n\t}\n}\nEXPORT_SYMBOL_GPL(cio_tm_start_key);\n\n \nint cio_tm_intrg(struct subchannel *sch)\n{\n\tint cc;\n\n\tif (!to_io_private(sch)->orb.tm.b)\n\t\treturn -EINVAL;\n\tcc = xsch(sch->schid);\n\tswitch (cc) {\n\tcase 0:\n\tcase 2:\n\t\treturn 0;\n\tcase 1:\n\t\treturn -EBUSY;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL_GPL(cio_tm_intrg);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}