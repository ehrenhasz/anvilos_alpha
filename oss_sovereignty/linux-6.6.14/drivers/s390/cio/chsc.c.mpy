{
  "module_name": "chsc.c",
  "hash_id": "7ed8cf2d856d433371cfe6a4dd4a4dd1e73a61f062101b74c1f19f8e283f3e68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/chsc.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"cio\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n\n#include <asm/cio.h>\n#include <asm/chpid.h>\n#include <asm/chsc.h>\n#include <asm/crw.h>\n#include <asm/isc.h>\n#include <asm/ebcdic.h>\n#include <asm/ap.h>\n\n#include \"css.h\"\n#include \"cio.h\"\n#include \"cio_debug.h\"\n#include \"ioasm.h\"\n#include \"chp.h\"\n#include \"chsc.h\"\n\nstatic void *sei_page;\nstatic void *chsc_page;\nstatic DEFINE_SPINLOCK(chsc_page_lock);\n\n#define SEI_VF_FLA\t0xc0  \n#define SEI_RS_CHPID\t0x4   \n\n \nint chsc_error_from_response(int response)\n{\n\tswitch (response) {\n\tcase 0x0001:\n\t\treturn 0;\n\tcase 0x0002:\n\tcase 0x0003:\n\tcase 0x0006:\n\tcase 0x0007:\n\tcase 0x0008:\n\tcase 0x000a:\n\tcase 0x0104:\n\t\treturn -EINVAL;\n\tcase 0x0004:\n\tcase 0x0106:\t\t \n\t\treturn -EOPNOTSUPP;\n\tcase 0x000b:\n\tcase 0x0107:\t\t \n\t\treturn -EBUSY;\n\tcase 0x0100:\n\tcase 0x0102:\n\t\treturn -ENOMEM;\n\tcase 0x0108:\t\t \n\t\treturn -EUSERS;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\nEXPORT_SYMBOL_GPL(chsc_error_from_response);\n\nstruct chsc_ssd_area {\n\tstruct chsc_header request;\n\tu16 :10;\n\tu16 ssid:2;\n\tu16 :4;\n\tu16 f_sch;\t   \n\tu16 :16;\n\tu16 l_sch;\t   \n\tu32 :32;\n\tstruct chsc_header response;\n\tu32 :32;\n\tu8 sch_valid : 1;\n\tu8 dev_valid : 1;\n\tu8 st\t     : 3;  \n\tu8 zeroes    : 3;\n\tu8  unit_addr;\t   \n\tu16 devno;\t   \n\tu8 path_mask;\n\tu8 fla_valid_mask;\n\tu16 sch;\t   \n\tu8 chpid[8];\t   \n\tu16 fla[8];\t   \n} __packed __aligned(PAGE_SIZE);\n\nint chsc_get_ssd_info(struct subchannel_id schid, struct chsc_ssd_info *ssd)\n{\n\tstruct chsc_ssd_area *ssd_area;\n\tunsigned long flags;\n\tint ccode;\n\tint ret;\n\tint i;\n\tint mask;\n\n\tspin_lock_irqsave(&chsc_page_lock, flags);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tssd_area = chsc_page;\n\tssd_area->request.length = 0x0010;\n\tssd_area->request.code = 0x0004;\n\tssd_area->ssid = schid.ssid;\n\tssd_area->f_sch = schid.sch_no;\n\tssd_area->l_sch = schid.sch_no;\n\n\tccode = chsc(ssd_area);\n\t \n\tif (ccode > 0) {\n\t\tret = (ccode == 3) ? -ENODEV : -EBUSY;\n\t\tgoto out;\n\t}\n\tret = chsc_error_from_response(ssd_area->response.code);\n\tif (ret != 0) {\n\t\tCIO_MSG_EVENT(2, \"chsc: ssd failed for 0.%x.%04x (rc=%04x)\\n\",\n\t\t\t      schid.ssid, schid.sch_no,\n\t\t\t      ssd_area->response.code);\n\t\tgoto out;\n\t}\n\tif (!ssd_area->sch_valid) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\t \n\tret = 0;\n\tmemset(ssd, 0, sizeof(struct chsc_ssd_info));\n\tif ((ssd_area->st != SUBCHANNEL_TYPE_IO) &&\n\t    (ssd_area->st != SUBCHANNEL_TYPE_MSG))\n\t\tgoto out;\n\tssd->path_mask = ssd_area->path_mask;\n\tssd->fla_valid_mask = ssd_area->fla_valid_mask;\n\tfor (i = 0; i < 8; i++) {\n\t\tmask = 0x80 >> i;\n\t\tif (ssd_area->path_mask & mask) {\n\t\t\tchp_id_init(&ssd->chpid[i]);\n\t\t\tssd->chpid[i].id = ssd_area->chpid[i];\n\t\t}\n\t\tif (ssd_area->fla_valid_mask & mask)\n\t\t\tssd->fla[i] = ssd_area->fla[i];\n\t}\nout:\n\tspin_unlock_irqrestore(&chsc_page_lock, flags);\n\treturn ret;\n}\n\n \nint chsc_ssqd(struct subchannel_id schid, struct chsc_ssqd_area *ssqd)\n{\n\tmemset(ssqd, 0, sizeof(*ssqd));\n\tssqd->request.length = 0x0010;\n\tssqd->request.code = 0x0024;\n\tssqd->first_sch = schid.sch_no;\n\tssqd->last_sch = schid.sch_no;\n\tssqd->ssid = schid.ssid;\n\n\tif (chsc(ssqd))\n\t\treturn -EIO;\n\n\treturn chsc_error_from_response(ssqd->response.code);\n}\nEXPORT_SYMBOL_GPL(chsc_ssqd);\n\n \nint chsc_sadc(struct subchannel_id schid, struct chsc_scssc_area *scssc,\n\t      u64 summary_indicator_addr, u64 subchannel_indicator_addr, u8 isc)\n{\n\tmemset(scssc, 0, sizeof(*scssc));\n\tscssc->request.length = 0x0fe0;\n\tscssc->request.code = 0x0021;\n\tscssc->operation_code = 0;\n\n\tscssc->summary_indicator_addr = summary_indicator_addr;\n\tscssc->subchannel_indicator_addr = subchannel_indicator_addr;\n\n\tscssc->ks = PAGE_DEFAULT_KEY >> 4;\n\tscssc->kc = PAGE_DEFAULT_KEY >> 4;\n\tscssc->isc = isc;\n\tscssc->schid = schid;\n\n\t \n\tif (css_general_characteristics.aif_tdd)\n\t\tscssc->word_with_d_bit = 0x10000000;\n\n\tif (chsc(scssc))\n\t\treturn -EIO;\n\n\treturn chsc_error_from_response(scssc->response.code);\n}\nEXPORT_SYMBOL_GPL(chsc_sadc);\n\nstatic int s390_subchannel_remove_chpid(struct subchannel *sch, void *data)\n{\n\tspin_lock_irq(sch->lock);\n\tif (sch->driver && sch->driver->chp_event)\n\t\tif (sch->driver->chp_event(sch, data, CHP_OFFLINE) != 0)\n\t\t\tgoto out_unreg;\n\tspin_unlock_irq(sch->lock);\n\treturn 0;\n\nout_unreg:\n\tsch->lpm = 0;\n\tspin_unlock_irq(sch->lock);\n\tcss_schedule_eval(sch->schid);\n\treturn 0;\n}\n\nvoid chsc_chp_offline(struct chp_id chpid)\n{\n\tstruct channel_path *chp = chpid_to_chp(chpid);\n\tstruct chp_link link;\n\tchar dbf_txt[15];\n\n\tsprintf(dbf_txt, \"chpr%x.%02x\", chpid.cssid, chpid.id);\n\tCIO_TRACE_EVENT(2, dbf_txt);\n\n\tif (chp_get_status(chpid) <= 0)\n\t\treturn;\n\tmemset(&link, 0, sizeof(struct chp_link));\n\tlink.chpid = chpid;\n\t \n\tcss_wait_for_slow_path();\n\n\tmutex_lock(&chp->lock);\n\tchp_update_desc(chp);\n\tmutex_unlock(&chp->lock);\n\n\tfor_each_subchannel_staged(s390_subchannel_remove_chpid, NULL, &link);\n}\n\nstatic int __s390_process_res_acc(struct subchannel *sch, void *data)\n{\n\tspin_lock_irq(sch->lock);\n\tif (sch->driver && sch->driver->chp_event)\n\t\tsch->driver->chp_event(sch, data, CHP_ONLINE);\n\tspin_unlock_irq(sch->lock);\n\n\treturn 0;\n}\n\nstatic void s390_process_res_acc(struct chp_link *link)\n{\n\tchar dbf_txt[15];\n\n\tsprintf(dbf_txt, \"accpr%x.%02x\", link->chpid.cssid,\n\t\tlink->chpid.id);\n\tCIO_TRACE_EVENT( 2, dbf_txt);\n\tif (link->fla != 0) {\n\t\tsprintf(dbf_txt, \"fla%x\", link->fla);\n\t\tCIO_TRACE_EVENT( 2, dbf_txt);\n\t}\n\t \n\tcss_wait_for_slow_path();\n\t \n\tfor_each_subchannel_staged(__s390_process_res_acc, NULL, link);\n\tcss_schedule_reprobe();\n}\n\nstatic int process_fces_event(struct subchannel *sch, void *data)\n{\n\tspin_lock_irq(sch->lock);\n\tif (sch->driver && sch->driver->chp_event)\n\t\tsch->driver->chp_event(sch, data, CHP_FCES_EVENT);\n\tspin_unlock_irq(sch->lock);\n\treturn 0;\n}\n\nstruct chsc_sei_nt0_area {\n\tu8  flags;\n\tu8  vf;\t\t\t\t \n\tu8  rs;\t\t\t\t \n\tu8  cc;\t\t\t\t \n\tu16 fla;\t\t\t \n\tu16 rsid;\t\t\t \n\tu32 reserved1;\n\tu32 reserved2;\n\t \n\tu8  ccdf[PAGE_SIZE - 24 - 16];\t \n} __packed;\n\nstruct chsc_sei_nt2_area {\n\tu8  flags;\t\t\t \n\tu8  reserved1;\n\tu8  reserved2;\n\tu8  cc;\t\t\t\t \n\tu32 reserved3[13];\n\tu8  ccdf[PAGE_SIZE - 24 - 56];\t \n} __packed;\n\n#define CHSC_SEI_NT0\t(1ULL << 63)\n#define CHSC_SEI_NT2\t(1ULL << 61)\n\nstruct chsc_sei {\n\tstruct chsc_header request;\n\tu32 reserved1;\n\tu64 ntsm;\t\t\t \n\tstruct chsc_header response;\n\tu32 :24;\n\tu8 nt;\n\tunion {\n\t\tstruct chsc_sei_nt0_area nt0_area;\n\t\tstruct chsc_sei_nt2_area nt2_area;\n\t\tu8 nt_area[PAGE_SIZE - 24];\n\t} u;\n} __packed __aligned(PAGE_SIZE);\n\n \n\n#define LIR_IQ_CLASS_INFO\t\t0\n#define LIR_IQ_CLASS_DEGRADED\t\t1\n#define LIR_IQ_CLASS_NOT_OPERATIONAL\t2\n\nstruct lir {\n\tstruct {\n\t\tu32 null:1;\n\t\tu32 reserved:3;\n\t\tu32 class:2;\n\t\tu32 reserved2:2;\n\t} __packed iq;\n\tu32 ic:8;\n\tu32 reserved:16;\n\tstruct node_descriptor incident_node;\n\tstruct node_descriptor attached_node;\n\tu8 reserved2[32];\n} __packed;\n\n#define PARAMS_LEN\t10\t \n#define NODEID_LEN\t35\t \n\n \nstatic char *store_ebcdic(char *dest, const char *src, unsigned long len,\n\t\t\t  char delim)\n{\n\tmemcpy(dest, src, len);\n\tEBCASC(dest, len);\n\n\tif (delim)\n\t\tdest[len++] = delim;\n\n\treturn dest + len;\n}\n\nstatic void chsc_link_from_sei(struct chp_link *link,\n\t\t\t\tstruct chsc_sei_nt0_area *sei_area)\n{\n\tif ((sei_area->vf & SEI_VF_FLA) != 0) {\n\t\tlink->fla\t= sei_area->fla;\n\t\tlink->fla_mask\t= ((sei_area->vf & SEI_VF_FLA) == SEI_VF_FLA) ?\n\t\t\t\t\t\t\t0xffff : 0xff00;\n\t}\n}\n\n \nstatic void format_node_data(char *params, char *id, struct node_descriptor *nd)\n{\n\tmemset(params, 0, PARAMS_LEN);\n\tmemset(id, 0, NODEID_LEN);\n\n\tif (nd->validity != ND_VALIDITY_VALID) {\n\t\tstrncpy(params, \"n/a\", PARAMS_LEN - 1);\n\t\tstrncpy(id, \"n/a\", NODEID_LEN - 1);\n\t\treturn;\n\t}\n\n\t \n\tsnprintf(params, PARAMS_LEN, \"%02x,%06x\", nd->byte0, nd->params);\n\t \n\tid = store_ebcdic(id, nd->type, sizeof(nd->type), '/');\n\tid = store_ebcdic(id, nd->model, sizeof(nd->model), ',');\n\tid = store_ebcdic(id, nd->manufacturer, sizeof(nd->manufacturer), '.');\n\tid = store_ebcdic(id, nd->plant, sizeof(nd->plant), 0);\n\tid = store_ebcdic(id, nd->seq, sizeof(nd->seq), ',');\n\tsprintf(id, \"%04X\", nd->tag);\n}\n\nstatic void chsc_process_sei_link_incident(struct chsc_sei_nt0_area *sei_area)\n{\n\tstruct lir *lir = (struct lir *) &sei_area->ccdf;\n\tchar iuparams[PARAMS_LEN], iunodeid[NODEID_LEN], auparams[PARAMS_LEN],\n\t     aunodeid[NODEID_LEN];\n\n\tCIO_CRW_EVENT(4, \"chsc: link incident (rs=%02x, rs_id=%04x, iq=%02x)\\n\",\n\t\t      sei_area->rs, sei_area->rsid, sei_area->ccdf[0]);\n\n\t \n\tif (lir->iq.null)\n\t\treturn;\n\n\t \n\n\tformat_node_data(iuparams, iunodeid, &lir->incident_node);\n\tformat_node_data(auparams, aunodeid, &lir->attached_node);\n\n\tswitch (lir->iq.class) {\n\tcase LIR_IQ_CLASS_DEGRADED:\n\t\tpr_warn(\"Link degraded: RS=%02x RSID=%04x IC=%02x \"\n\t\t\t\"IUPARAMS=%s IUNODEID=%s AUPARAMS=%s AUNODEID=%s\\n\",\n\t\t\tsei_area->rs, sei_area->rsid, lir->ic, iuparams,\n\t\t\tiunodeid, auparams, aunodeid);\n\t\tbreak;\n\tcase LIR_IQ_CLASS_NOT_OPERATIONAL:\n\t\tpr_err(\"Link stopped: RS=%02x RSID=%04x IC=%02x \"\n\t\t       \"IUPARAMS=%s IUNODEID=%s AUPARAMS=%s AUNODEID=%s\\n\",\n\t\t       sei_area->rs, sei_area->rsid, lir->ic, iuparams,\n\t\t       iunodeid, auparams, aunodeid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void chsc_process_sei_res_acc(struct chsc_sei_nt0_area *sei_area)\n{\n\tstruct channel_path *chp;\n\tstruct chp_link link;\n\tstruct chp_id chpid;\n\tint status;\n\n\tCIO_CRW_EVENT(4, \"chsc: resource accessibility event (rs=%02x, \"\n\t\t      \"rs_id=%04x)\\n\", sei_area->rs, sei_area->rsid);\n\tif (sei_area->rs != 4)\n\t\treturn;\n\tchp_id_init(&chpid);\n\tchpid.id = sei_area->rsid;\n\t \n\tstatus = chp_get_status(chpid);\n\tif (!status)\n\t\treturn;\n\n\tif (status < 0) {\n\t\tchp_new(chpid);\n\t} else {\n\t\tchp = chpid_to_chp(chpid);\n\t\tmutex_lock(&chp->lock);\n\t\tchp_update_desc(chp);\n\t\tmutex_unlock(&chp->lock);\n\t}\n\tmemset(&link, 0, sizeof(struct chp_link));\n\tlink.chpid = chpid;\n\tchsc_link_from_sei(&link, sei_area);\n\ts390_process_res_acc(&link);\n}\n\nstatic void chsc_process_sei_chp_avail(struct chsc_sei_nt0_area *sei_area)\n{\n\tstruct channel_path *chp;\n\tstruct chp_id chpid;\n\tu8 *data;\n\tint num;\n\n\tCIO_CRW_EVENT(4, \"chsc: channel path availability information\\n\");\n\tif (sei_area->rs != 0)\n\t\treturn;\n\tdata = sei_area->ccdf;\n\tchp_id_init(&chpid);\n\tfor (num = 0; num <= __MAX_CHPID; num++) {\n\t\tif (!chp_test_bit(data, num))\n\t\t\tcontinue;\n\t\tchpid.id = num;\n\n\t\tCIO_CRW_EVENT(4, \"Update information for channel path \"\n\t\t\t      \"%x.%02x\\n\", chpid.cssid, chpid.id);\n\t\tchp = chpid_to_chp(chpid);\n\t\tif (!chp) {\n\t\t\tchp_new(chpid);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&chp->lock);\n\t\tchp_update_desc(chp);\n\t\tmutex_unlock(&chp->lock);\n\t}\n}\n\nstruct chp_config_data {\n\tu8 map[32];\n\tu8 op;\n\tu8 pc;\n};\n\nstatic void chsc_process_sei_chp_config(struct chsc_sei_nt0_area *sei_area)\n{\n\tstruct chp_config_data *data;\n\tstruct chp_id chpid;\n\tint num;\n\tchar *events[3] = {\"configure\", \"deconfigure\", \"cancel deconfigure\"};\n\n\tCIO_CRW_EVENT(4, \"chsc: channel-path-configuration notification\\n\");\n\tif (sei_area->rs != 0)\n\t\treturn;\n\tdata = (struct chp_config_data *) &(sei_area->ccdf);\n\tchp_id_init(&chpid);\n\tfor (num = 0; num <= __MAX_CHPID; num++) {\n\t\tif (!chp_test_bit(data->map, num))\n\t\t\tcontinue;\n\t\tchpid.id = num;\n\t\tpr_notice(\"Processing %s for channel path %x.%02x\\n\",\n\t\t\t  events[data->op], chpid.cssid, chpid.id);\n\t\tswitch (data->op) {\n\t\tcase 0:\n\t\t\tchp_cfg_schedule(chpid, 1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tchp_cfg_schedule(chpid, 0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tchp_cfg_cancel_deconfigure(chpid);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void chsc_process_sei_scm_change(struct chsc_sei_nt0_area *sei_area)\n{\n\tint ret;\n\n\tCIO_CRW_EVENT(4, \"chsc: scm change notification\\n\");\n\tif (sei_area->rs != 7)\n\t\treturn;\n\n\tret = scm_update_information();\n\tif (ret)\n\t\tCIO_CRW_EVENT(0, \"chsc: updating change notification\"\n\t\t\t      \" failed (rc=%d).\\n\", ret);\n}\n\nstatic void chsc_process_sei_scm_avail(struct chsc_sei_nt0_area *sei_area)\n{\n\tint ret;\n\n\tCIO_CRW_EVENT(4, \"chsc: scm available information\\n\");\n\tif (sei_area->rs != 7)\n\t\treturn;\n\n\tret = scm_process_availability_information();\n\tif (ret)\n\t\tCIO_CRW_EVENT(0, \"chsc: process availability information\"\n\t\t\t      \" failed (rc=%d).\\n\", ret);\n}\n\nstatic void chsc_process_sei_ap_cfg_chg(struct chsc_sei_nt0_area *sei_area)\n{\n\tCIO_CRW_EVENT(3, \"chsc: ap config changed\\n\");\n\tif (sei_area->rs != 5)\n\t\treturn;\n\n\tap_bus_cfg_chg();\n}\n\nstatic void chsc_process_sei_fces_event(struct chsc_sei_nt0_area *sei_area)\n{\n\tstruct chp_link link;\n\tstruct chp_id chpid;\n\tstruct channel_path *chp;\n\n\tCIO_CRW_EVENT(4,\n\t\"chsc: FCES status notification (rs=%02x, rs_id=%04x, FCES-status=%x)\\n\",\n\t\tsei_area->rs, sei_area->rsid, sei_area->ccdf[0]);\n\n\tif (sei_area->rs != SEI_RS_CHPID)\n\t\treturn;\n\tchp_id_init(&chpid);\n\tchpid.id = sei_area->rsid;\n\n\t \n\tchp = chpid_to_chp(chpid);\n\tif (!chp)\n\t\treturn;\n\n\tmemset(&link, 0, sizeof(struct chp_link));\n\tlink.chpid = chpid;\n\tchsc_link_from_sei(&link, sei_area);\n\n\tfor_each_subchannel_staged(process_fces_event, NULL, &link);\n}\n\nstatic void chsc_process_sei_nt2(struct chsc_sei_nt2_area *sei_area)\n{\n\tswitch (sei_area->cc) {\n\tcase 1:\n\t\tzpci_event_error(sei_area->ccdf);\n\t\tbreak;\n\tcase 2:\n\t\tzpci_event_availability(sei_area->ccdf);\n\t\tbreak;\n\tdefault:\n\t\tCIO_CRW_EVENT(2, \"chsc: sei nt2 unhandled cc=%d\\n\",\n\t\t\t      sei_area->cc);\n\t\tbreak;\n\t}\n}\n\nstatic void chsc_process_sei_nt0(struct chsc_sei_nt0_area *sei_area)\n{\n\t \n\tswitch (sei_area->cc) {\n\tcase 1:  \n\t\tchsc_process_sei_link_incident(sei_area);\n\t\tbreak;\n\tcase 2:  \n\t\tchsc_process_sei_res_acc(sei_area);\n\t\tbreak;\n\tcase 3:  \n\t\tchsc_process_sei_ap_cfg_chg(sei_area);\n\t\tbreak;\n\tcase 7:  \n\t\tchsc_process_sei_chp_avail(sei_area);\n\t\tbreak;\n\tcase 8:  \n\t\tchsc_process_sei_chp_config(sei_area);\n\t\tbreak;\n\tcase 12:  \n\t\tchsc_process_sei_scm_change(sei_area);\n\t\tbreak;\n\tcase 14:  \n\t\tchsc_process_sei_scm_avail(sei_area);\n\t\tbreak;\n\tcase 15:  \n\t\tchsc_process_sei_fces_event(sei_area);\n\t\tbreak;\n\tdefault:  \n\t\tCIO_CRW_EVENT(2, \"chsc: sei nt0 unhandled cc=%d\\n\",\n\t\t\t      sei_area->cc);\n\t\tbreak;\n\t}\n\n\t \n\tif (sei_area->flags & 0x40) {\n\t\tCIO_CRW_EVENT(2, \"chsc: event overflow\\n\");\n\t\tcss_schedule_eval_all();\n\t}\n}\n\nstatic void chsc_process_event_information(struct chsc_sei *sei, u64 ntsm)\n{\n\tstatic int ntsm_unsupported;\n\n\twhile (true) {\n\t\tmemset(sei, 0, sizeof(*sei));\n\t\tsei->request.length = 0x0010;\n\t\tsei->request.code = 0x000e;\n\t\tif (!ntsm_unsupported)\n\t\t\tsei->ntsm = ntsm;\n\n\t\tif (chsc(sei))\n\t\t\tbreak;\n\n\t\tif (sei->response.code != 0x0001) {\n\t\t\tCIO_CRW_EVENT(2, \"chsc: sei failed (rc=%04x, ntsm=%llx)\\n\",\n\t\t\t\t      sei->response.code, sei->ntsm);\n\n\t\t\tif (sei->response.code == 3 && sei->ntsm) {\n\t\t\t\t \n\t\t\t\tntsm_unsupported = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tCIO_CRW_EVENT(2, \"chsc: sei successful (nt=%d)\\n\", sei->nt);\n\t\tswitch (sei->nt) {\n\t\tcase 0:\n\t\t\tchsc_process_sei_nt0(&sei->u.nt0_area);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tchsc_process_sei_nt2(&sei->u.nt2_area);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCIO_CRW_EVENT(2, \"chsc: unhandled nt: %d\\n\", sei->nt);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sei->u.nt0_area.flags & 0x80))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void chsc_process_crw(struct crw *crw0, struct crw *crw1, int overflow)\n{\n\tstruct chsc_sei *sei = sei_page;\n\n\tif (overflow) {\n\t\tcss_schedule_eval_all();\n\t\treturn;\n\t}\n\tCIO_CRW_EVENT(2, \"CRW reports slct=%d, oflw=%d, \"\n\t\t      \"chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\\n\",\n\t\t      crw0->slct, crw0->oflw, crw0->chn, crw0->rsc, crw0->anc,\n\t\t      crw0->erc, crw0->rsid);\n\n\tCIO_TRACE_EVENT(2, \"prcss\");\n\tchsc_process_event_information(sei, CHSC_SEI_NT0 | CHSC_SEI_NT2);\n}\n\nvoid chsc_chp_online(struct chp_id chpid)\n{\n\tstruct channel_path *chp = chpid_to_chp(chpid);\n\tstruct chp_link link;\n\tchar dbf_txt[15];\n\n\tsprintf(dbf_txt, \"cadd%x.%02x\", chpid.cssid, chpid.id);\n\tCIO_TRACE_EVENT(2, dbf_txt);\n\n\tif (chp_get_status(chpid) != 0) {\n\t\tmemset(&link, 0, sizeof(struct chp_link));\n\t\tlink.chpid = chpid;\n\t\t \n\t\tcss_wait_for_slow_path();\n\n\t\tmutex_lock(&chp->lock);\n\t\tchp_update_desc(chp);\n\t\tmutex_unlock(&chp->lock);\n\n\t\tfor_each_subchannel_staged(__s390_process_res_acc, NULL,\n\t\t\t\t\t   &link);\n\t\tcss_schedule_reprobe();\n\t}\n}\n\nstatic void __s390_subchannel_vary_chpid(struct subchannel *sch,\n\t\t\t\t\t struct chp_id chpid, int on)\n{\n\tunsigned long flags;\n\tstruct chp_link link;\n\n\tmemset(&link, 0, sizeof(struct chp_link));\n\tlink.chpid = chpid;\n\tspin_lock_irqsave(sch->lock, flags);\n\tif (sch->driver && sch->driver->chp_event)\n\t\tsch->driver->chp_event(sch, &link,\n\t\t\t\t       on ? CHP_VARY_ON : CHP_VARY_OFF);\n\tspin_unlock_irqrestore(sch->lock, flags);\n}\n\nstatic int s390_subchannel_vary_chpid_off(struct subchannel *sch, void *data)\n{\n\tstruct chp_id *chpid = data;\n\n\t__s390_subchannel_vary_chpid(sch, *chpid, 0);\n\treturn 0;\n}\n\nstatic int s390_subchannel_vary_chpid_on(struct subchannel *sch, void *data)\n{\n\tstruct chp_id *chpid = data;\n\n\t__s390_subchannel_vary_chpid(sch, *chpid, 1);\n\treturn 0;\n}\n\n \nint chsc_chp_vary(struct chp_id chpid, int on)\n{\n\tstruct channel_path *chp = chpid_to_chp(chpid);\n\n\t \n\tif (on) {\n\t\t \n\t\tchp_update_desc(chp);\n\t\tfor_each_subchannel_staged(s390_subchannel_vary_chpid_on,\n\t\t\t\t\t   NULL, &chpid);\n\t\tcss_schedule_reprobe();\n\t} else\n\t\tfor_each_subchannel_staged(s390_subchannel_vary_chpid_off,\n\t\t\t\t\t   NULL, &chpid);\n\n\treturn 0;\n}\n\nstatic void\nchsc_remove_cmg_attr(struct channel_subsystem *css)\n{\n\tint i;\n\n\tfor (i = 0; i <= __MAX_CHPID; i++) {\n\t\tif (!css->chps[i])\n\t\t\tcontinue;\n\t\tchp_remove_cmg_attr(css->chps[i]);\n\t}\n}\n\nstatic int\nchsc_add_cmg_attr(struct channel_subsystem *css)\n{\n\tint i, ret;\n\n\tret = 0;\n\tfor (i = 0; i <= __MAX_CHPID; i++) {\n\t\tif (!css->chps[i])\n\t\t\tcontinue;\n\t\tret = chp_add_cmg_attr(css->chps[i]);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\treturn ret;\ncleanup:\n\tfor (--i; i >= 0; i--) {\n\t\tif (!css->chps[i])\n\t\t\tcontinue;\n\t\tchp_remove_cmg_attr(css->chps[i]);\n\t}\n\treturn ret;\n}\n\nint __chsc_do_secm(struct channel_subsystem *css, int enable)\n{\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 operation_code : 2;\n\t\tu32 : 30;\n\t\tu32 key : 4;\n\t\tu32 : 28;\n\t\tu32 zeroes1;\n\t\tu32 cub_addr1;\n\t\tu32 zeroes2;\n\t\tu32 cub_addr2;\n\t\tu32 reserved[13];\n\t\tstruct chsc_header response;\n\t\tu32 status : 8;\n\t\tu32 : 4;\n\t\tu32 fmt : 4;\n\t\tu32 : 16;\n\t} *secm_area;\n\tunsigned long flags;\n\tint ret, ccode;\n\n\tspin_lock_irqsave(&chsc_page_lock, flags);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tsecm_area = chsc_page;\n\tsecm_area->request.length = 0x0050;\n\tsecm_area->request.code = 0x0016;\n\n\tsecm_area->key = PAGE_DEFAULT_KEY >> 4;\n\tsecm_area->cub_addr1 = (u64)(unsigned long)css->cub_addr1;\n\tsecm_area->cub_addr2 = (u64)(unsigned long)css->cub_addr2;\n\n\tsecm_area->operation_code = enable ? 0 : 1;\n\n\tccode = chsc(secm_area);\n\tif (ccode > 0) {\n\t\tret = (ccode == 3) ? -ENODEV : -EBUSY;\n\t\tgoto out;\n\t}\n\n\tswitch (secm_area->response.code) {\n\tcase 0x0102:\n\tcase 0x0103:\n\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tret = chsc_error_from_response(secm_area->response.code);\n\t}\n\tif (ret != 0)\n\t\tCIO_CRW_EVENT(2, \"chsc: secm failed (rc=%04x)\\n\",\n\t\t\t      secm_area->response.code);\nout:\n\tspin_unlock_irqrestore(&chsc_page_lock, flags);\n\treturn ret;\n}\n\nint\nchsc_secm(struct channel_subsystem *css, int enable)\n{\n\tint ret;\n\n\tif (enable && !css->cm_enabled) {\n\t\tcss->cub_addr1 = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\t\tcss->cub_addr2 = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\t\tif (!css->cub_addr1 || !css->cub_addr2) {\n\t\t\tfree_page((unsigned long)css->cub_addr1);\n\t\t\tfree_page((unsigned long)css->cub_addr2);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tret = __chsc_do_secm(css, enable);\n\tif (!ret) {\n\t\tcss->cm_enabled = enable;\n\t\tif (css->cm_enabled) {\n\t\t\tret = chsc_add_cmg_attr(css);\n\t\t\tif (ret) {\n\t\t\t\t__chsc_do_secm(css, 0);\n\t\t\t\tcss->cm_enabled = 0;\n\t\t\t}\n\t\t} else\n\t\t\tchsc_remove_cmg_attr(css);\n\t}\n\tif (!css->cm_enabled) {\n\t\tfree_page((unsigned long)css->cub_addr1);\n\t\tfree_page((unsigned long)css->cub_addr2);\n\t}\n\treturn ret;\n}\n\nint chsc_determine_channel_path_desc(struct chp_id chpid, int fmt, int rfmt,\n\t\t\t\t     int c, int m, void *page)\n{\n\tstruct chsc_scpd *scpd_area;\n\tint ccode, ret;\n\n\tif ((rfmt == 1 || rfmt == 0) && c == 1 &&\n\t    !css_general_characteristics.fcs)\n\t\treturn -EINVAL;\n\tif ((rfmt == 2) && !css_general_characteristics.cib)\n\t\treturn -EINVAL;\n\tif ((rfmt == 3) && !css_general_characteristics.util_str)\n\t\treturn -EINVAL;\n\n\tmemset(page, 0, PAGE_SIZE);\n\tscpd_area = page;\n\tscpd_area->request.length = 0x0010;\n\tscpd_area->request.code = 0x0002;\n\tscpd_area->cssid = chpid.cssid;\n\tscpd_area->first_chpid = chpid.id;\n\tscpd_area->last_chpid = chpid.id;\n\tscpd_area->m = m;\n\tscpd_area->c = c;\n\tscpd_area->fmt = fmt;\n\tscpd_area->rfmt = rfmt;\n\n\tccode = chsc(scpd_area);\n\tif (ccode > 0)\n\t\treturn (ccode == 3) ? -ENODEV : -EBUSY;\n\n\tret = chsc_error_from_response(scpd_area->response.code);\n\tif (ret)\n\t\tCIO_CRW_EVENT(2, \"chsc: scpd failed (rc=%04x)\\n\",\n\t\t\t      scpd_area->response.code);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(chsc_determine_channel_path_desc);\n\n#define chsc_det_chp_desc(FMT, c)\t\t\t\t\t\\\nint chsc_determine_fmt##FMT##_channel_path_desc(\t\t\t\\\n\tstruct chp_id chpid, struct channel_path_desc_fmt##FMT *desc)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct chsc_scpd *scpd_area;\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspin_lock_irqsave(&chsc_page_lock, flags);\t\t\t\\\n\tscpd_area = chsc_page;\t\t\t\t\t\t\\\n\tret = chsc_determine_channel_path_desc(chpid, 0, FMT, c, 0,\t\\\n\t\t\t\t\t       scpd_area);\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmemcpy(desc, scpd_area->data, sizeof(*desc));\t\t\t\\\nout:\t\t\t\t\t\t\t\t\t\\\n\tspin_unlock_irqrestore(&chsc_page_lock, flags);\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\nchsc_det_chp_desc(0, 0)\nchsc_det_chp_desc(1, 1)\nchsc_det_chp_desc(3, 0)\n\nstatic void\nchsc_initialize_cmg_chars(struct channel_path *chp, u8 cmcv,\n\t\t\t  struct cmg_chars *chars)\n{\n\tint i, mask;\n\n\tfor (i = 0; i < NR_MEASUREMENT_CHARS; i++) {\n\t\tmask = 0x80 >> (i + 3);\n\t\tif (cmcv & mask)\n\t\t\tchp->cmg_chars.values[i] = chars->values[i];\n\t\telse\n\t\t\tchp->cmg_chars.values[i] = 0;\n\t}\n}\n\nint chsc_get_channel_measurement_chars(struct channel_path *chp)\n{\n\tunsigned long flags;\n\tint ccode, ret;\n\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 : 24;\n\t\tu32 first_chpid : 8;\n\t\tu32 : 24;\n\t\tu32 last_chpid : 8;\n\t\tu32 zeroes1;\n\t\tstruct chsc_header response;\n\t\tu32 zeroes2;\n\t\tu32 not_valid : 1;\n\t\tu32 shared : 1;\n\t\tu32 : 22;\n\t\tu32 chpid : 8;\n\t\tu32 cmcv : 5;\n\t\tu32 : 11;\n\t\tu32 cmgq : 8;\n\t\tu32 cmg : 8;\n\t\tu32 zeroes3;\n\t\tu32 data[NR_MEASUREMENT_CHARS];\n\t} *scmc_area;\n\n\tchp->shared = -1;\n\tchp->cmg = -1;\n\n\tif (!css_chsc_characteristics.scmc || !css_chsc_characteristics.secm)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&chsc_page_lock, flags);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tscmc_area = chsc_page;\n\tscmc_area->request.length = 0x0010;\n\tscmc_area->request.code = 0x0022;\n\tscmc_area->first_chpid = chp->chpid.id;\n\tscmc_area->last_chpid = chp->chpid.id;\n\n\tccode = chsc(scmc_area);\n\tif (ccode > 0) {\n\t\tret = (ccode == 3) ? -ENODEV : -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = chsc_error_from_response(scmc_area->response.code);\n\tif (ret) {\n\t\tCIO_CRW_EVENT(2, \"chsc: scmc failed (rc=%04x)\\n\",\n\t\t\t      scmc_area->response.code);\n\t\tgoto out;\n\t}\n\tif (scmc_area->not_valid)\n\t\tgoto out;\n\n\tchp->cmg = scmc_area->cmg;\n\tchp->shared = scmc_area->shared;\n\tif (chp->cmg != 2 && chp->cmg != 3) {\n\t\t \n\t\tgoto out;\n\t}\n\tchsc_initialize_cmg_chars(chp, scmc_area->cmcv,\n\t\t\t\t  (struct cmg_chars *) &scmc_area->data);\nout:\n\tspin_unlock_irqrestore(&chsc_page_lock, flags);\n\treturn ret;\n}\n\nint __init chsc_init(void)\n{\n\tint ret;\n\n\tsei_page = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tchsc_page = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sei_page || !chsc_page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tret = crw_register_handler(CRW_RSC_CSS, chsc_process_crw);\n\tif (ret)\n\t\tgoto out_err;\n\treturn ret;\nout_err:\n\tfree_page((unsigned long)chsc_page);\n\tfree_page((unsigned long)sei_page);\n\treturn ret;\n}\n\nvoid __init chsc_init_cleanup(void)\n{\n\tcrw_unregister_handler(CRW_RSC_CSS);\n\tfree_page((unsigned long)chsc_page);\n\tfree_page((unsigned long)sei_page);\n}\n\nint __chsc_enable_facility(struct chsc_sda_area *sda_area, int operation_code)\n{\n\tint ret;\n\n\tsda_area->request.length = 0x0400;\n\tsda_area->request.code = 0x0031;\n\tsda_area->operation_code = operation_code;\n\n\tret = chsc(sda_area);\n\tif (ret > 0) {\n\t\tret = (ret == 3) ? -ENODEV : -EBUSY;\n\t\tgoto out;\n\t}\n\n\tswitch (sda_area->response.code) {\n\tcase 0x0101:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\tret = chsc_error_from_response(sda_area->response.code);\n\t}\nout:\n\treturn ret;\n}\n\nint chsc_enable_facility(int operation_code)\n{\n\tstruct chsc_sda_area *sda_area;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&chsc_page_lock, flags);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tsda_area = chsc_page;\n\n\tret = __chsc_enable_facility(sda_area, operation_code);\n\tif (ret != 0)\n\t\tCIO_CRW_EVENT(2, \"chsc: sda (oc=%x) failed (rc=%04x)\\n\",\n\t\t\t      operation_code, sda_area->response.code);\n\n\tspin_unlock_irqrestore(&chsc_page_lock, flags);\n\treturn ret;\n}\n\nint __init chsc_get_cssid_iid(int idx, u8 *cssid, u8 *iid)\n{\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu8 atype;\n\t\tu32 : 24;\n\t\tu32 reserved1[6];\n\t\tstruct chsc_header response;\n\t\tu32 reserved2[3];\n\t\tstruct {\n\t\t\tu8 cssid;\n\t\t\tu8 iid;\n\t\t\tu32 : 16;\n\t\t} list[];\n\t} *sdcal_area;\n\tint ret;\n\n\tspin_lock_irq(&chsc_page_lock);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tsdcal_area = chsc_page;\n\tsdcal_area->request.length = 0x0020;\n\tsdcal_area->request.code = 0x0034;\n\tsdcal_area->atype = 4;\n\n\tret = chsc(sdcal_area);\n\tif (ret) {\n\t\tret = (ret == 3) ? -ENODEV : -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tret = chsc_error_from_response(sdcal_area->response.code);\n\tif (ret) {\n\t\tCIO_CRW_EVENT(2, \"chsc: sdcal failed (rc=%04x)\\n\",\n\t\t\t      sdcal_area->response.code);\n\t\tgoto exit;\n\t}\n\n\tif ((addr_t) &sdcal_area->list[idx] <\n\t    (addr_t) &sdcal_area->response + sdcal_area->response.length) {\n\t\t*cssid = sdcal_area->list[idx].cssid;\n\t\t*iid = sdcal_area->list[idx].iid;\n\t}\n\telse\n\t\tret = -ENODEV;\nexit:\n\tspin_unlock_irq(&chsc_page_lock);\n\treturn ret;\n}\n\nstruct css_general_char css_general_characteristics;\nstruct css_chsc_char css_chsc_characteristics;\n\nint __init\nchsc_determine_css_characteristics(void)\n{\n\tunsigned long flags;\n\tint result;\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 reserved1;\n\t\tu32 reserved2;\n\t\tu32 reserved3;\n\t\tstruct chsc_header response;\n\t\tu32 reserved4;\n\t\tu32 general_char[510];\n\t\tu32 chsc_char[508];\n\t} *scsc_area;\n\n\tspin_lock_irqsave(&chsc_page_lock, flags);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tscsc_area = chsc_page;\n\tscsc_area->request.length = 0x0010;\n\tscsc_area->request.code = 0x0010;\n\n\tresult = chsc(scsc_area);\n\tif (result) {\n\t\tresult = (result == 3) ? -ENODEV : -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tresult = chsc_error_from_response(scsc_area->response.code);\n\tif (result == 0) {\n\t\tmemcpy(&css_general_characteristics, scsc_area->general_char,\n\t\t       sizeof(css_general_characteristics));\n\t\tmemcpy(&css_chsc_characteristics, scsc_area->chsc_char,\n\t\t       sizeof(css_chsc_characteristics));\n\t} else\n\t\tCIO_CRW_EVENT(2, \"chsc: scsc failed (rc=%04x)\\n\",\n\t\t\t      scsc_area->response.code);\nexit:\n\tspin_unlock_irqrestore(&chsc_page_lock, flags);\n\treturn result;\n}\n\nEXPORT_SYMBOL_GPL(css_general_characteristics);\nEXPORT_SYMBOL_GPL(css_chsc_characteristics);\n\nint chsc_sstpc(void *page, unsigned int op, u16 ctrl, long *clock_delta)\n{\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tunsigned int rsvd0;\n\t\tunsigned int op : 8;\n\t\tunsigned int rsvd1 : 8;\n\t\tunsigned int ctrl : 16;\n\t\tunsigned int rsvd2[5];\n\t\tstruct chsc_header response;\n\t\tunsigned int rsvd3[3];\n\t\ts64 clock_delta;\n\t\tunsigned int rsvd4[2];\n\t} *rr;\n\tint rc;\n\n\tmemset(page, 0, PAGE_SIZE);\n\trr = page;\n\trr->request.length = 0x0020;\n\trr->request.code = 0x0033;\n\trr->op = op;\n\trr->ctrl = ctrl;\n\trc = chsc(rr);\n\tif (rc)\n\t\treturn -EIO;\n\trc = (rr->response.code == 0x0001) ? 0 : -EIO;\n\tif (clock_delta)\n\t\t*clock_delta = rr->clock_delta;\n\treturn rc;\n}\n\nint chsc_sstpi(void *page, void *result, size_t size)\n{\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tunsigned int rsvd0[3];\n\t\tstruct chsc_header response;\n\t\tchar data[];\n\t} *rr;\n\tint rc;\n\n\tmemset(page, 0, PAGE_SIZE);\n\trr = page;\n\trr->request.length = 0x0010;\n\trr->request.code = 0x0038;\n\trc = chsc(rr);\n\tif (rc)\n\t\treturn -EIO;\n\tmemcpy(result, &rr->data, size);\n\treturn (rr->response.code == 0x0001) ? 0 : -EIO;\n}\n\nint chsc_stzi(void *page, void *result, size_t size)\n{\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tunsigned int rsvd0[3];\n\t\tstruct chsc_header response;\n\t\tchar data[];\n\t} *rr;\n\tint rc;\n\n\tmemset(page, 0, PAGE_SIZE);\n\trr = page;\n\trr->request.length = 0x0010;\n\trr->request.code = 0x003e;\n\trc = chsc(rr);\n\tif (rc)\n\t\treturn -EIO;\n\tmemcpy(result, &rr->data, size);\n\treturn (rr->response.code == 0x0001) ? 0 : -EIO;\n}\n\nint chsc_siosl(struct subchannel_id schid)\n{\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu32 word1;\n\t\tstruct subchannel_id sid;\n\t\tu32 word3;\n\t\tstruct chsc_header response;\n\t\tu32 word[11];\n\t} *siosl_area;\n\tunsigned long flags;\n\tint ccode;\n\tint rc;\n\n\tspin_lock_irqsave(&chsc_page_lock, flags);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tsiosl_area = chsc_page;\n\tsiosl_area->request.length = 0x0010;\n\tsiosl_area->request.code = 0x0046;\n\tsiosl_area->word1 = 0x80000000;\n\tsiosl_area->sid = schid;\n\n\tccode = chsc(siosl_area);\n\tif (ccode > 0) {\n\t\tif (ccode == 3)\n\t\t\trc = -ENODEV;\n\t\telse\n\t\t\trc = -EBUSY;\n\t\tCIO_MSG_EVENT(2, \"chsc: chsc failed for 0.%x.%04x (ccode=%d)\\n\",\n\t\t\t      schid.ssid, schid.sch_no, ccode);\n\t\tgoto out;\n\t}\n\trc = chsc_error_from_response(siosl_area->response.code);\n\tif (rc)\n\t\tCIO_MSG_EVENT(2, \"chsc: siosl failed for 0.%x.%04x (rc=%04x)\\n\",\n\t\t\t      schid.ssid, schid.sch_no,\n\t\t\t      siosl_area->response.code);\n\telse\n\t\tCIO_MSG_EVENT(4, \"chsc: siosl succeeded for 0.%x.%04x\\n\",\n\t\t\t      schid.ssid, schid.sch_no);\nout:\n\tspin_unlock_irqrestore(&chsc_page_lock, flags);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(chsc_siosl);\n\n \nint chsc_scm_info(struct chsc_scm_info *scm_area, u64 token)\n{\n\tint ccode, ret;\n\n\tmemset(scm_area, 0, sizeof(*scm_area));\n\tscm_area->request.length = 0x0020;\n\tscm_area->request.code = 0x004C;\n\tscm_area->reqtok = token;\n\n\tccode = chsc(scm_area);\n\tif (ccode > 0) {\n\t\tret = (ccode == 3) ? -ENODEV : -EBUSY;\n\t\tgoto out;\n\t}\n\tret = chsc_error_from_response(scm_area->response.code);\n\tif (ret != 0)\n\t\tCIO_MSG_EVENT(2, \"chsc: scm info failed (rc=%04x)\\n\",\n\t\t\t      scm_area->response.code);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(chsc_scm_info);\n\n \nint chsc_pnso(struct subchannel_id schid, struct chsc_pnso_area *pnso_area,\n\t      u8 oc, struct chsc_pnso_resume_token resume_token, int cnc)\n{\n\tmemset(pnso_area, 0, sizeof(*pnso_area));\n\tpnso_area->request.length = 0x0030;\n\tpnso_area->request.code = 0x003d;  \n\tpnso_area->m\t   = schid.m;\n\tpnso_area->ssid  = schid.ssid;\n\tpnso_area->sch\t = schid.sch_no;\n\tpnso_area->cssid = schid.cssid;\n\tpnso_area->oc\t = oc;\n\tpnso_area->resume_token = resume_token;\n\tpnso_area->n\t   = (cnc != 0);\n\tif (chsc(pnso_area))\n\t\treturn -EIO;\n\treturn chsc_error_from_response(pnso_area->response.code);\n}\n\nint chsc_sgib(u32 origin)\n{\n\tstruct {\n\t\tstruct chsc_header request;\n\t\tu16 op;\n\t\tu8  reserved01[2];\n\t\tu8  reserved02:4;\n\t\tu8  fmt:4;\n\t\tu8  reserved03[7];\n\t\t \n\t\tu8  reserved04[4];\n\t\tu32 gib_origin;\n\t\tu8  reserved05[10];\n\t\tu8  aix;\n\t\tu8  reserved06[4029];\n\t\tstruct chsc_header response;\n\t\tu8  reserved07[4];\n\t} *sgib_area;\n\tint ret;\n\n\tspin_lock_irq(&chsc_page_lock);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tsgib_area = chsc_page;\n\tsgib_area->request.length = 0x0fe0;\n\tsgib_area->request.code = 0x0021;\n\tsgib_area->op = 0x1;\n\tsgib_area->gib_origin = origin;\n\n\tret = chsc(sgib_area);\n\tif (ret == 0)\n\t\tret = chsc_error_from_response(sgib_area->response.code);\n\tspin_unlock_irq(&chsc_page_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(chsc_sgib);\n\n#define SCUD_REQ_LEN\t0x10  \n#define SCUD_REQ_CMD\t0x4b  \n\nstruct chse_cudb {\n\tu16 flags:8;\n\tu16 chp_valid:8;\n\tu16 cu;\n\tu32 esm_valid:8;\n\tu32:24;\n\tu8 chpid[8];\n\tu32:32;\n\tu32:32;\n\tu8 esm[8];\n\tu32 efla[8];\n} __packed;\n\nstruct chsc_scud {\n\tstruct chsc_header request;\n\tu16:4;\n\tu16 fmt:4;\n\tu16 cssid:8;\n\tu16 first_cu;\n\tu16:16;\n\tu16 last_cu;\n\tu32:32;\n\tstruct chsc_header response;\n\tu16:4;\n\tu16 fmt_resp:4;\n\tu32:24;\n\tstruct chse_cudb cudb[];\n} __packed;\n\n \nint chsc_scud(u16 cu, u64 *esm, u8 *esm_valid)\n{\n\tstruct chsc_scud *scud = chsc_page;\n\tint ret;\n\n\tspin_lock_irq(&chsc_page_lock);\n\tmemset(chsc_page, 0, PAGE_SIZE);\n\tscud->request.length = SCUD_REQ_LEN;\n\tscud->request.code = SCUD_REQ_CMD;\n\tscud->fmt = 0;\n\tscud->cssid = 0;\n\tscud->first_cu = cu;\n\tscud->last_cu = cu;\n\n\tret = chsc(scud);\n\tif (!ret)\n\t\tret = chsc_error_from_response(scud->response.code);\n\n\tif (!ret && (scud->response.length <= 8 || scud->fmt_resp != 0\n\t\t\t|| !(scud->cudb[0].flags & 0x80)\n\t\t\t|| scud->cudb[0].cu != cu)) {\n\n\t\tCIO_MSG_EVENT(2, \"chsc: scud failed rc=%04x, L2=%04x \"\n\t\t\t\"FMT=%04x, cudb.flags=%02x, cudb.cu=%04x\",\n\t\t\tscud->response.code, scud->response.length,\n\t\t\tscud->fmt_resp, scud->cudb[0].flags, scud->cudb[0].cu);\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(esm, scud->cudb[0].esm, sizeof(*esm));\n\t*esm_valid = scud->cudb[0].esm_valid;\nout:\n\tspin_unlock_irq(&chsc_page_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(chsc_scud);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}