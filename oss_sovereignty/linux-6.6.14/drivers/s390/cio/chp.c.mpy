{
  "module_name": "chp.c",
  "hash_id": "3fe079ba3f902aaea59b0ef8222a1ac236f5c2aa9830a37c97368b7a11609c7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/cio/chp.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/wait.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <asm/chpid.h>\n#include <asm/sclp.h>\n#include <asm/crw.h>\n\n#include \"cio.h\"\n#include \"css.h\"\n#include \"ioasm.h\"\n#include \"cio_debug.h\"\n#include \"chp.h\"\n\n#define to_channelpath(device) container_of(device, struct channel_path, dev)\n#define CHP_INFO_UPDATE_INTERVAL\t1*HZ\n\nenum cfg_task_t {\n\tcfg_none,\n\tcfg_configure,\n\tcfg_deconfigure\n};\n\n \nstatic enum cfg_task_t chp_cfg_task[__MAX_CSSID + 1][__MAX_CHPID + 1];\nstatic DEFINE_SPINLOCK(cfg_lock);\n\n \nstatic struct sclp_chp_info chp_info;\nstatic DEFINE_MUTEX(info_lock);\n\n \nstatic unsigned long chp_info_expires;\n\nstatic struct work_struct cfg_work;\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(cfg_wait_queue);\n\n \nstatic void set_chp_logically_online(struct chp_id chpid, int onoff)\n{\n\tchpid_to_chp(chpid)->state = onoff;\n}\n\n \nint chp_get_status(struct chp_id chpid)\n{\n\treturn (chpid_to_chp(chpid) ? chpid_to_chp(chpid)->state : -ENODEV);\n}\n\n \nu8 chp_get_sch_opm(struct subchannel *sch)\n{\n\tstruct chp_id chpid;\n\tint opm;\n\tint i;\n\n\topm = 0;\n\tchp_id_init(&chpid);\n\tfor (i = 0; i < 8; i++) {\n\t\topm <<= 1;\n\t\tchpid.id = sch->schib.pmcw.chpid[i];\n\t\tif (chp_get_status(chpid) != 0)\n\t\t\topm |= 1;\n\t}\n\treturn opm;\n}\nEXPORT_SYMBOL_GPL(chp_get_sch_opm);\n\n \nint chp_is_registered(struct chp_id chpid)\n{\n\treturn chpid_to_chp(chpid) != NULL;\n}\n\n \nstatic int s390_vary_chpid(struct chp_id chpid, int on)\n{\n\tchar dbf_text[15];\n\tint status;\n\n\tsprintf(dbf_text, on?\"varyon%x.%02x\":\"varyoff%x.%02x\", chpid.cssid,\n\t\tchpid.id);\n\tCIO_TRACE_EVENT(2, dbf_text);\n\n\tstatus = chp_get_status(chpid);\n\tif (!on && !status)\n\t\treturn 0;\n\n\tset_chp_logically_online(chpid, on);\n\tchsc_chp_vary(chpid, on);\n\treturn 0;\n}\n\n \nstatic ssize_t chp_measurement_chars_read(struct file *filp,\n\t\t\t\t\t  struct kobject *kobj,\n\t\t\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tstruct channel_path *chp;\n\tstruct device *device;\n\n\tdevice = kobj_to_dev(kobj);\n\tchp = to_channelpath(device);\n\tif (chp->cmg == -1)\n\t\treturn 0;\n\n\treturn memory_read_from_buffer(buf, count, &off, &chp->cmg_chars,\n\t\t\t\t       sizeof(chp->cmg_chars));\n}\n\nstatic const struct bin_attribute chp_measurement_chars_attr = {\n\t.attr = {\n\t\t.name = \"measurement_chars\",\n\t\t.mode = S_IRUSR,\n\t},\n\t.size = sizeof(struct cmg_chars),\n\t.read = chp_measurement_chars_read,\n};\n\nstatic void chp_measurement_copy_block(struct cmg_entry *buf,\n\t\t\t\t       struct channel_subsystem *css,\n\t\t\t\t       struct chp_id chpid)\n{\n\tvoid *area;\n\tstruct cmg_entry *entry, reference_buf;\n\tint idx;\n\n\tif (chpid.id < 128) {\n\t\tarea = css->cub_addr1;\n\t\tidx = chpid.id;\n\t} else {\n\t\tarea = css->cub_addr2;\n\t\tidx = chpid.id - 128;\n\t}\n\tentry = area + (idx * sizeof(struct cmg_entry));\n\tdo {\n\t\tmemcpy(buf, entry, sizeof(*entry));\n\t\tmemcpy(&reference_buf, entry, sizeof(*entry));\n\t} while (reference_buf.values[0] != buf->values[0]);\n}\n\nstatic ssize_t chp_measurement_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *bin_attr,\n\t\t\t\t    char *buf, loff_t off, size_t count)\n{\n\tstruct channel_path *chp;\n\tstruct channel_subsystem *css;\n\tstruct device *device;\n\tunsigned int size;\n\n\tdevice = kobj_to_dev(kobj);\n\tchp = to_channelpath(device);\n\tcss = to_css(chp->dev.parent);\n\n\tsize = sizeof(struct cmg_entry);\n\n\t \n\tif (off || count < size)\n\t\treturn 0;\n\tchp_measurement_copy_block((struct cmg_entry *)buf, css, chp->chpid);\n\tcount = size;\n\treturn count;\n}\n\nstatic const struct bin_attribute chp_measurement_attr = {\n\t.attr = {\n\t\t.name = \"measurement\",\n\t\t.mode = S_IRUSR,\n\t},\n\t.size = sizeof(struct cmg_entry),\n\t.read = chp_measurement_read,\n};\n\nvoid chp_remove_cmg_attr(struct channel_path *chp)\n{\n\tdevice_remove_bin_file(&chp->dev, &chp_measurement_chars_attr);\n\tdevice_remove_bin_file(&chp->dev, &chp_measurement_attr);\n}\n\nint chp_add_cmg_attr(struct channel_path *chp)\n{\n\tint ret;\n\n\tret = device_create_bin_file(&chp->dev, &chp_measurement_chars_attr);\n\tif (ret)\n\t\treturn ret;\n\tret = device_create_bin_file(&chp->dev, &chp_measurement_attr);\n\tif (ret)\n\t\tdevice_remove_bin_file(&chp->dev, &chp_measurement_chars_attr);\n\treturn ret;\n}\n\n \nstatic ssize_t chp_status_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct channel_path *chp = to_channelpath(dev);\n\tint status;\n\n\tmutex_lock(&chp->lock);\n\tstatus = chp->state;\n\tmutex_unlock(&chp->lock);\n\n\treturn status ? sprintf(buf, \"online\\n\") : sprintf(buf, \"offline\\n\");\n}\n\nstatic ssize_t chp_status_write(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct channel_path *cp = to_channelpath(dev);\n\tchar cmd[10];\n\tint num_args;\n\tint error;\n\n\tnum_args = sscanf(buf, \"%5s\", cmd);\n\tif (!num_args)\n\t\treturn count;\n\n\t \n\tcss_wait_for_slow_path();\n\n\tif (!strncasecmp(cmd, \"on\", 2) || !strcmp(cmd, \"1\")) {\n\t\tmutex_lock(&cp->lock);\n\t\terror = s390_vary_chpid(cp->chpid, 1);\n\t\tmutex_unlock(&cp->lock);\n\t} else if (!strncasecmp(cmd, \"off\", 3) || !strcmp(cmd, \"0\")) {\n\t\tmutex_lock(&cp->lock);\n\t\terror = s390_vary_chpid(cp->chpid, 0);\n\t\tmutex_unlock(&cp->lock);\n\t} else\n\t\terror = -EINVAL;\n\n\treturn error < 0 ? error : count;\n}\n\nstatic DEVICE_ATTR(status, 0644, chp_status_show, chp_status_write);\n\nstatic ssize_t chp_configure_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct channel_path *cp;\n\tint status;\n\n\tcp = to_channelpath(dev);\n\tstatus = chp_info_get_status(cp->chpid);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn sysfs_emit(buf, \"%d\\n\", status);\n}\n\nstatic int cfg_wait_idle(void);\n\nstatic ssize_t chp_configure_write(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct channel_path *cp;\n\tint val;\n\tchar delim;\n\n\tif (sscanf(buf, \"%d %c\", &val, &delim) != 1)\n\t\treturn -EINVAL;\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\tcp = to_channelpath(dev);\n\tchp_cfg_schedule(cp->chpid, val);\n\tcfg_wait_idle();\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(configure, 0644, chp_configure_show, chp_configure_write);\n\nstatic ssize_t chp_type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct channel_path *chp = to_channelpath(dev);\n\tu8 type;\n\n\tmutex_lock(&chp->lock);\n\ttype = chp->desc.desc;\n\tmutex_unlock(&chp->lock);\n\treturn sprintf(buf, \"%x\\n\", type);\n}\n\nstatic DEVICE_ATTR(type, 0444, chp_type_show, NULL);\n\nstatic ssize_t chp_cmg_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct channel_path *chp = to_channelpath(dev);\n\n\tif (!chp)\n\t\treturn 0;\n\tif (chp->cmg == -1)  \n\t\treturn sprintf(buf, \"unknown\\n\");\n\treturn sprintf(buf, \"%x\\n\", chp->cmg);\n}\n\nstatic DEVICE_ATTR(cmg, 0444, chp_cmg_show, NULL);\n\nstatic ssize_t chp_shared_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct channel_path *chp = to_channelpath(dev);\n\n\tif (!chp)\n\t\treturn 0;\n\tif (chp->shared == -1)  \n\t\treturn sprintf(buf, \"unknown\\n\");\n\treturn sprintf(buf, \"%x\\n\", chp->shared);\n}\n\nstatic DEVICE_ATTR(shared, 0444, chp_shared_show, NULL);\n\nstatic ssize_t chp_chid_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct channel_path *chp = to_channelpath(dev);\n\tssize_t rc;\n\n\tmutex_lock(&chp->lock);\n\tif (chp->desc_fmt1.flags & 0x10)\n\t\trc = sprintf(buf, \"%04x\\n\", chp->desc_fmt1.chid);\n\telse\n\t\trc = 0;\n\tmutex_unlock(&chp->lock);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR(chid, 0444, chp_chid_show, NULL);\n\nstatic ssize_t chp_chid_external_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct channel_path *chp = to_channelpath(dev);\n\tssize_t rc;\n\n\tmutex_lock(&chp->lock);\n\tif (chp->desc_fmt1.flags & 0x10)\n\t\trc = sprintf(buf, \"%x\\n\", chp->desc_fmt1.flags & 0x8 ? 1 : 0);\n\telse\n\t\trc = 0;\n\tmutex_unlock(&chp->lock);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR(chid_external, 0444, chp_chid_external_show, NULL);\n\nstatic ssize_t chp_esc_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct channel_path *chp = to_channelpath(dev);\n\tssize_t rc;\n\n\tmutex_lock(&chp->lock);\n\trc = sprintf(buf, \"%x\\n\", chp->desc_fmt1.esc);\n\tmutex_unlock(&chp->lock);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR(esc, 0444, chp_esc_show, NULL);\n\nstatic ssize_t util_string_read(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *attr, char *buf,\n\t\t\t\tloff_t off, size_t count)\n{\n\tstruct channel_path *chp = to_channelpath(kobj_to_dev(kobj));\n\tssize_t rc;\n\n\tmutex_lock(&chp->lock);\n\trc = memory_read_from_buffer(buf, count, &off, chp->desc_fmt3.util_str,\n\t\t\t\t     sizeof(chp->desc_fmt3.util_str));\n\tmutex_unlock(&chp->lock);\n\n\treturn rc;\n}\nstatic BIN_ATTR_RO(util_string,\n\t\t   sizeof(((struct channel_path_desc_fmt3 *)0)->util_str));\n\nstatic struct bin_attribute *chp_bin_attrs[] = {\n\t&bin_attr_util_string,\n\tNULL,\n};\n\nstatic struct attribute *chp_attrs[] = {\n\t&dev_attr_status.attr,\n\t&dev_attr_configure.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_cmg.attr,\n\t&dev_attr_shared.attr,\n\t&dev_attr_chid.attr,\n\t&dev_attr_chid_external.attr,\n\t&dev_attr_esc.attr,\n\tNULL,\n};\nstatic struct attribute_group chp_attr_group = {\n\t.attrs = chp_attrs,\n\t.bin_attrs = chp_bin_attrs,\n};\nstatic const struct attribute_group *chp_attr_groups[] = {\n\t&chp_attr_group,\n\tNULL,\n};\n\nstatic void chp_release(struct device *dev)\n{\n\tstruct channel_path *cp;\n\n\tcp = to_channelpath(dev);\n\tkfree(cp);\n}\n\n \nint chp_update_desc(struct channel_path *chp)\n{\n\tint rc;\n\n\trc = chsc_determine_fmt0_channel_path_desc(chp->chpid, &chp->desc);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tchsc_determine_fmt1_channel_path_desc(chp->chpid, &chp->desc_fmt1);\n\tchsc_determine_fmt3_channel_path_desc(chp->chpid, &chp->desc_fmt3);\n\tchsc_get_channel_measurement_chars(chp);\n\n\treturn 0;\n}\n\n \nint chp_new(struct chp_id chpid)\n{\n\tstruct channel_subsystem *css = css_by_id(chpid.cssid);\n\tstruct channel_path *chp;\n\tint ret = 0;\n\n\tmutex_lock(&css->mutex);\n\tif (chp_is_registered(chpid))\n\t\tgoto out;\n\n\tchp = kzalloc(sizeof(struct channel_path), GFP_KERNEL);\n\tif (!chp) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t \n\tchp->chpid = chpid;\n\tchp->state = 1;\n\tchp->dev.parent = &css->device;\n\tchp->dev.groups = chp_attr_groups;\n\tchp->dev.release = chp_release;\n\tmutex_init(&chp->lock);\n\n\t \n\tret = chp_update_desc(chp);\n\tif (ret)\n\t\tgoto out_free;\n\tif ((chp->desc.flags & 0x80) == 0) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\tdev_set_name(&chp->dev, \"chp%x.%02x\", chpid.cssid, chpid.id);\n\n\t \n\tret = device_register(&chp->dev);\n\tif (ret) {\n\t\tCIO_MSG_EVENT(0, \"Could not register chp%x.%02x: %d\\n\",\n\t\t\t      chpid.cssid, chpid.id, ret);\n\t\tput_device(&chp->dev);\n\t\tgoto out;\n\t}\n\n\tif (css->cm_enabled) {\n\t\tret = chp_add_cmg_attr(chp);\n\t\tif (ret) {\n\t\t\tdevice_unregister(&chp->dev);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcss->chps[chpid.id] = chp;\n\tgoto out;\nout_free:\n\tkfree(chp);\nout:\n\tmutex_unlock(&css->mutex);\n\treturn ret;\n}\n\n \nstruct channel_path_desc_fmt0 *chp_get_chp_desc(struct chp_id chpid)\n{\n\tstruct channel_path *chp;\n\tstruct channel_path_desc_fmt0 *desc;\n\n\tchp = chpid_to_chp(chpid);\n\tif (!chp)\n\t\treturn NULL;\n\tdesc = kmalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tmutex_lock(&chp->lock);\n\tmemcpy(desc, &chp->desc, sizeof(*desc));\n\tmutex_unlock(&chp->lock);\n\treturn desc;\n}\n\n \nstatic void chp_process_crw(struct crw *crw0, struct crw *crw1,\n\t\t\t    int overflow)\n{\n\tstruct chp_id chpid;\n\n\tif (overflow) {\n\t\tcss_schedule_eval_all();\n\t\treturn;\n\t}\n\tCIO_CRW_EVENT(2, \"CRW reports slct=%d, oflw=%d, \"\n\t\t      \"chn=%d, rsc=%X, anc=%d, erc=%X, rsid=%X\\n\",\n\t\t      crw0->slct, crw0->oflw, crw0->chn, crw0->rsc, crw0->anc,\n\t\t      crw0->erc, crw0->rsid);\n\t \n\tif (crw0->slct) {\n\t\tCIO_CRW_EVENT(2, \"solicited machine check for \"\n\t\t\t      \"channel path %02X\\n\", crw0->rsid);\n\t\treturn;\n\t}\n\tchp_id_init(&chpid);\n\tchpid.id = crw0->rsid;\n\tswitch (crw0->erc) {\n\tcase CRW_ERC_IPARM:  \n\tcase CRW_ERC_INIT:\n\t\tchp_new(chpid);\n\t\tchsc_chp_online(chpid);\n\t\tbreak;\n\tcase CRW_ERC_PERRI:  \n\tcase CRW_ERC_PERRN:\n\t\tchsc_chp_offline(chpid);\n\t\tbreak;\n\tdefault:\n\t\tCIO_CRW_EVENT(2, \"Don't know how to handle erc=%x\\n\",\n\t\t\t      crw0->erc);\n\t}\n}\n\nint chp_ssd_get_mask(struct chsc_ssd_info *ssd, struct chp_link *link)\n{\n\tint i;\n\tint mask;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tmask = 0x80 >> i;\n\t\tif (!(ssd->path_mask & mask))\n\t\t\tcontinue;\n\t\tif (!chp_id_is_equal(&ssd->chpid[i], &link->chpid))\n\t\t\tcontinue;\n\t\tif ((ssd->fla_valid_mask & mask) &&\n\t\t    ((ssd->fla[i] & link->fla_mask) != link->fla))\n\t\t\tcontinue;\n\t\treturn mask;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(chp_ssd_get_mask);\n\nstatic inline int info_bit_num(struct chp_id id)\n{\n\treturn id.id + id.cssid * (__MAX_CHPID + 1);\n}\n\n \nstatic void info_expire(void)\n{\n\tmutex_lock(&info_lock);\n\tchp_info_expires = jiffies - 1;\n\tmutex_unlock(&info_lock);\n}\n\n \nstatic int info_update(void)\n{\n\tint rc;\n\n\tmutex_lock(&info_lock);\n\trc = 0;\n\tif (time_after(jiffies, chp_info_expires)) {\n\t\t \n\t\trc = sclp_chp_read_info(&chp_info);\n\t\tchp_info_expires = jiffies + CHP_INFO_UPDATE_INTERVAL ;\n\t}\n\tmutex_unlock(&info_lock);\n\n\treturn rc;\n}\n\n \nint chp_info_get_status(struct chp_id chpid)\n{\n\tint rc;\n\tint bit;\n\n\trc = info_update();\n\tif (rc)\n\t\treturn rc;\n\n\tbit = info_bit_num(chpid);\n\tmutex_lock(&info_lock);\n\tif (!chp_test_bit(chp_info.recognized, bit))\n\t\trc = CHP_STATUS_NOT_RECOGNIZED;\n\telse if (chp_test_bit(chp_info.configured, bit))\n\t\trc = CHP_STATUS_CONFIGURED;\n\telse if (chp_test_bit(chp_info.standby, bit))\n\t\trc = CHP_STATUS_STANDBY;\n\telse\n\t\trc = CHP_STATUS_RESERVED;\n\tmutex_unlock(&info_lock);\n\n\treturn rc;\n}\n\n \nstatic enum cfg_task_t cfg_get_task(struct chp_id chpid)\n{\n\treturn chp_cfg_task[chpid.cssid][chpid.id];\n}\n\n \nstatic void cfg_set_task(struct chp_id chpid, enum cfg_task_t cfg)\n{\n\tchp_cfg_task[chpid.cssid][chpid.id] = cfg;\n}\n\n \nstatic enum cfg_task_t chp_cfg_fetch_task(struct chp_id *chpid)\n{\n\tenum cfg_task_t t = cfg_none;\n\n\tchp_id_for_each(chpid) {\n\t\tt = cfg_get_task(*chpid);\n\t\tif (t != cfg_none)\n\t\t\tbreak;\n\t}\n\n\treturn t;\n}\n\n \nstatic void cfg_func(struct work_struct *work)\n{\n\tstruct chp_id chpid;\n\tenum cfg_task_t t;\n\tint rc;\n\n\tspin_lock(&cfg_lock);\n\tt = chp_cfg_fetch_task(&chpid);\n\tspin_unlock(&cfg_lock);\n\n\tswitch (t) {\n\tcase cfg_configure:\n\t\trc = sclp_chp_configure(chpid);\n\t\tif (rc)\n\t\t\tCIO_MSG_EVENT(2, \"chp: sclp_chp_configure(%x.%02x)=\"\n\t\t\t\t      \"%d\\n\", chpid.cssid, chpid.id, rc);\n\t\telse {\n\t\t\tinfo_expire();\n\t\t\tchsc_chp_online(chpid);\n\t\t}\n\t\tbreak;\n\tcase cfg_deconfigure:\n\t\trc = sclp_chp_deconfigure(chpid);\n\t\tif (rc)\n\t\t\tCIO_MSG_EVENT(2, \"chp: sclp_chp_deconfigure(%x.%02x)=\"\n\t\t\t\t      \"%d\\n\", chpid.cssid, chpid.id, rc);\n\t\telse {\n\t\t\tinfo_expire();\n\t\t\tchsc_chp_offline(chpid);\n\t\t}\n\t\tbreak;\n\tcase cfg_none:\n\t\t \n\t\tinfo_update();\n\t\twake_up_interruptible(&cfg_wait_queue);\n\t\treturn;\n\t}\n\tspin_lock(&cfg_lock);\n\tif (t == cfg_get_task(chpid))\n\t\tcfg_set_task(chpid, cfg_none);\n\tspin_unlock(&cfg_lock);\n\tschedule_work(&cfg_work);\n}\n\n \nvoid chp_cfg_schedule(struct chp_id chpid, int configure)\n{\n\tCIO_MSG_EVENT(2, \"chp_cfg_sched%x.%02x=%d\\n\", chpid.cssid, chpid.id,\n\t\t      configure);\n\tspin_lock(&cfg_lock);\n\tcfg_set_task(chpid, configure ? cfg_configure : cfg_deconfigure);\n\tspin_unlock(&cfg_lock);\n\tschedule_work(&cfg_work);\n}\n\n \nvoid chp_cfg_cancel_deconfigure(struct chp_id chpid)\n{\n\tCIO_MSG_EVENT(2, \"chp_cfg_cancel:%x.%02x\\n\", chpid.cssid, chpid.id);\n\tspin_lock(&cfg_lock);\n\tif (cfg_get_task(chpid) == cfg_deconfigure)\n\t\tcfg_set_task(chpid, cfg_none);\n\tspin_unlock(&cfg_lock);\n}\n\nstatic bool cfg_idle(void)\n{\n\tstruct chp_id chpid;\n\tenum cfg_task_t t;\n\n\tspin_lock(&cfg_lock);\n\tt = chp_cfg_fetch_task(&chpid);\n\tspin_unlock(&cfg_lock);\n\n\treturn t == cfg_none;\n}\n\nstatic int cfg_wait_idle(void)\n{\n\tif (wait_event_interruptible(cfg_wait_queue, cfg_idle()))\n\t\treturn -ERESTARTSYS;\n\treturn 0;\n}\n\nstatic int __init chp_init(void)\n{\n\tstruct chp_id chpid;\n\tint state, ret;\n\n\tret = crw_register_handler(CRW_RSC_CPATH, chp_process_crw);\n\tif (ret)\n\t\treturn ret;\n\tINIT_WORK(&cfg_work, cfg_func);\n\tif (info_update())\n\t\treturn 0;\n\t \n\tchp_id_for_each(&chpid) {\n\t\tstate = chp_info_get_status(chpid);\n\t\tif (state == CHP_STATUS_CONFIGURED ||\n\t\t    state == CHP_STATUS_STANDBY)\n\t\t\tchp_new(chpid);\n\t}\n\n\treturn 0;\n}\n\nsubsys_initcall(chp_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}