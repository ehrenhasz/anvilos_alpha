{
  "module_name": "qeth_l3_sys.c",
  "hash_id": "cd444bdad4202863288f7f52acbdc08db879e4bcbebdaabac6ef0863f278868f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/qeth_l3_sys.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <asm/ebcdic.h>\n#include <linux/hashtable.h>\n#include <linux/inet.h>\n#include \"qeth_l3.h\"\n\n#define QETH_DEVICE_ATTR(_id, _name, _mode, _show, _store) \\\nstruct device_attribute dev_attr_##_id = __ATTR(_name, _mode, _show, _store)\n\nstatic int qeth_l3_string_to_ipaddr(const char *buf,\n\t\t\t\t    enum qeth_prot_versions proto, u8 *addr)\n{\n\tconst char *end;\n\n\tif ((proto == QETH_PROT_IPV4 && !in4_pton(buf, -1, addr, -1, &end)) ||\n\t    (proto == QETH_PROT_IPV6 && !in6_pton(buf, -1, addr, -1, &end)))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic ssize_t qeth_l3_dev_route_show(struct qeth_card *card,\n\t\t\tstruct qeth_routing_info *route, char *buf)\n{\n\tswitch (route->type) {\n\tcase PRIMARY_ROUTER:\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"primary router\");\n\tcase SECONDARY_ROUTER:\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"secondary router\");\n\tcase MULTICAST_ROUTER:\n\t\tif (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)\n\t\t\treturn sysfs_emit(buf, \"%s\\n\", \"multicast router+\");\n\t\telse\n\t\t\treturn sysfs_emit(buf, \"%s\\n\", \"multicast router\");\n\tcase PRIMARY_CONNECTOR:\n\t\tif (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)\n\t\t\treturn sysfs_emit(buf, \"%s\\n\", \"primary connector+\");\n\t\telse\n\t\t\treturn sysfs_emit(buf, \"%s\\n\", \"primary connector\");\n\tcase SECONDARY_CONNECTOR:\n\t\tif (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)\n\t\t\treturn sysfs_emit(buf, \"%s\\n\", \"secondary connector+\");\n\t\telse\n\t\t\treturn sysfs_emit(buf, \"%s\\n\", \"secondary connector\");\n\tdefault:\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"no\");\n\t}\n}\n\nstatic ssize_t qeth_l3_dev_route4_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_route_show(card, &card->options.route4, buf);\n}\n\nstatic ssize_t qeth_l3_dev_route_store(struct qeth_card *card,\n\t\tstruct qeth_routing_info *route, enum qeth_prot_versions prot,\n\t\tconst char *buf, size_t count)\n{\n\tenum qeth_routing_types old_route_type = route->type;\n\tint rc = 0;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (sysfs_streq(buf, \"no_router\")) {\n\t\troute->type = NO_ROUTER;\n\t} else if (sysfs_streq(buf, \"primary_connector\")) {\n\t\troute->type = PRIMARY_CONNECTOR;\n\t} else if (sysfs_streq(buf, \"secondary_connector\")) {\n\t\troute->type = SECONDARY_CONNECTOR;\n\t} else if (sysfs_streq(buf, \"primary_router\")) {\n\t\troute->type = PRIMARY_ROUTER;\n\t} else if (sysfs_streq(buf, \"secondary_router\")) {\n\t\troute->type = SECONDARY_ROUTER;\n\t} else if (sysfs_streq(buf, \"multicast_router\")) {\n\t\troute->type = MULTICAST_ROUTER;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (qeth_card_hw_is_reachable(card) &&\n\t    (old_route_type != route->type)) {\n\t\tif (prot == QETH_PROT_IPV4)\n\t\t\trc = qeth_l3_setrouting_v4(card);\n\t\telse if (prot == QETH_PROT_IPV6)\n\t\t\trc = qeth_l3_setrouting_v6(card);\n\t}\nout:\n\tif (rc)\n\t\troute->type = old_route_type;\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic ssize_t qeth_l3_dev_route4_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_route_store(card, &card->options.route4,\n\t\t\t\tQETH_PROT_IPV4, buf, count);\n}\n\nstatic DEVICE_ATTR(route4, 0644, qeth_l3_dev_route4_show,\n\t\t\tqeth_l3_dev_route4_store);\n\nstatic ssize_t qeth_l3_dev_route6_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_route_show(card, &card->options.route6, buf);\n}\n\nstatic ssize_t qeth_l3_dev_route6_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_route_store(card, &card->options.route6,\n\t\t\t\tQETH_PROT_IPV6, buf, count);\n}\n\nstatic DEVICE_ATTR(route6, 0644, qeth_l3_dev_route6_show,\n\t\t\tqeth_l3_dev_route6_store);\n\nstatic ssize_t qeth_l3_dev_sniffer_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", card->options.sniffer ? 1 : 0);\n}\n\nstatic ssize_t qeth_l3_dev_sniffer_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tint rc = 0;\n\tunsigned long i;\n\n\tif (!IS_IQD(card))\n\t\treturn -EPERM;\n\tif (card->options.cq == QETH_CQ_ENABLED)\n\t\treturn -EPERM;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (card->state != CARD_STATE_DOWN) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\trc = kstrtoul(buf, 16, &i);\n\tif (rc) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tswitch (i) {\n\tcase 0:\n\t\tcard->options.sniffer = i;\n\t\tbreak;\n\tcase 1:\n\t\tqdio_get_ssqd_desc(CARD_DDEV(card), &card->ssqd);\n\t\tif (card->ssqd.qdioac2 & CHSC_AC2_SNIFFER_AVAILABLE) {\n\t\t\tcard->options.sniffer = i;\n\t\t\tqeth_resize_buffer_pool(card, QETH_IN_BUF_COUNT_MAX);\n\t\t} else {\n\t\t\trc = -EPERM;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\nout:\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(sniffer, 0644, qeth_l3_dev_sniffer_show,\n\t\tqeth_l3_dev_sniffer_store);\n\nstatic ssize_t qeth_l3_dev_hsuid_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tchar tmp_hsuid[9];\n\n\tif (!IS_IQD(card))\n\t\treturn -EPERM;\n\n\tmemcpy(tmp_hsuid, card->options.hsuid, sizeof(tmp_hsuid));\n\tEBCASC(tmp_hsuid, 8);\n\treturn sysfs_emit(buf, \"%s\\n\", tmp_hsuid);\n}\n\nstatic ssize_t qeth_l3_dev_hsuid_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tint rc = 0;\n\tchar *tmp;\n\n\tif (!IS_IQD(card))\n\t\treturn -EPERM;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (card->state != CARD_STATE_DOWN) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (card->options.sniffer) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (card->options.cq == QETH_CQ_NOTAVAILABLE) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\ttmp = strsep((char **)&buf, \"\\n\");\n\tif (strlen(tmp) > 8) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (card->options.hsuid[0])\n\t\t \n\t\tqeth_l3_modify_hsuid(card, false);\n\n\tif (strlen(tmp) == 0) {\n\t\t \n\t\tcard->options.hsuid[0] = '\\0';\n\t\tmemcpy(card->dev->perm_addr, card->options.hsuid, 9);\n\t\tqeth_configure_cq(card, QETH_CQ_DISABLED);\n\t\tgoto out;\n\t}\n\n\tif (qeth_configure_cq(card, QETH_CQ_ENABLED)) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tscnprintf(card->options.hsuid, sizeof(card->options.hsuid),\n\t\t  \"%-8s\", tmp);\n\tASCEBC(card->options.hsuid, 8);\n\tmemcpy(card->dev->perm_addr, card->options.hsuid, 9);\n\n\trc = qeth_l3_modify_hsuid(card, true);\n\nout:\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(hsuid, 0644, qeth_l3_dev_hsuid_show,\n\t\t   qeth_l3_dev_hsuid_store);\n\n\nstatic struct attribute *qeth_l3_device_attrs[] = {\n\t&dev_attr_route4.attr,\n\t&dev_attr_route6.attr,\n\t&dev_attr_sniffer.attr,\n\t&dev_attr_hsuid.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qeth_l3_device_attr_group = {\n\t.attrs = qeth_l3_device_attrs,\n};\n\nstatic ssize_t qeth_l3_dev_ipato_enable_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", card->ipato.enabled ? 1 : 0);\n}\n\nstatic ssize_t qeth_l3_dev_ipato_enable_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tbool enable;\n\tint rc = 0;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (card->state != CARD_STATE_DOWN) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&card->ip_lock);\n\tif (sysfs_streq(buf, \"toggle\")) {\n\t\tenable = !card->ipato.enabled;\n\t} else if (kstrtobool(buf, &enable)) {\n\t\trc = -EINVAL;\n\t\tgoto unlock_ip;\n\t}\n\n\tif (card->ipato.enabled != enable) {\n\t\tcard->ipato.enabled = enable;\n\t\tqeth_l3_update_ipato(card);\n\t}\n\nunlock_ip:\n\tmutex_unlock(&card->ip_lock);\nout:\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic QETH_DEVICE_ATTR(ipato_enable, enable, 0644,\n\t\t\tqeth_l3_dev_ipato_enable_show,\n\t\t\tqeth_l3_dev_ipato_enable_store);\n\nstatic ssize_t qeth_l3_dev_ipato_invert4_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", card->ipato.invert4 ? 1 : 0);\n}\n\nstatic ssize_t qeth_l3_dev_ipato_invert4_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tbool invert;\n\tint rc = 0;\n\n\tmutex_lock(&card->ip_lock);\n\tif (sysfs_streq(buf, \"toggle\")) {\n\t\tinvert = !card->ipato.invert4;\n\t} else if (kstrtobool(buf, &invert)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (card->ipato.invert4 != invert) {\n\t\tcard->ipato.invert4 = invert;\n\t\tqeth_l3_update_ipato(card);\n\t}\n\nout:\n\tmutex_unlock(&card->ip_lock);\n\treturn rc ? rc : count;\n}\n\nstatic QETH_DEVICE_ATTR(ipato_invert4, invert4, 0644,\n\t\t\tqeth_l3_dev_ipato_invert4_show,\n\t\t\tqeth_l3_dev_ipato_invert4_store);\n\nstatic ssize_t qeth_l3_dev_ipato_add_show(char *buf, struct qeth_card *card,\n\t\t\tenum qeth_prot_versions proto)\n{\n\tstruct qeth_ipato_entry *ipatoe;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tint offset = 0;\n\n\tmutex_lock(&card->ip_lock);\n\tlist_for_each_entry(ipatoe, &card->ipato.entries, entry) {\n\t\tif (ipatoe->proto != proto)\n\t\t\tcontinue;\n\n\t\tqeth_l3_ipaddr_to_string(proto, ipatoe->addr, addr_str);\n\t\toffset += sysfs_emit_at(buf, offset, \"%s/%i\\n\",\n\t\t\t\t\taddr_str, ipatoe->mask_bits);\n\t}\n\tmutex_unlock(&card->ip_lock);\n\n\treturn offset ? offset : sysfs_emit(buf, \"\\n\");\n}\n\nstatic ssize_t qeth_l3_dev_ipato_add4_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_ipato_add_show(buf, card, QETH_PROT_IPV4);\n}\n\nstatic int qeth_l3_parse_ipatoe(const char *buf, enum qeth_prot_versions proto,\n\t\t\t\tu8 *addr, unsigned int *mask_bits)\n{\n\tchar *sep;\n\tint rc;\n\n\t \n\tsep = strnchr(buf, INET6_ADDRSTRLEN, '/');\n\tif (!sep)\n\t\treturn -EINVAL;\n\n\t \n\t*sep = '\\0';\n\trc = qeth_l3_string_to_ipaddr(buf, proto, addr);\n\tif (rc)\n\t\treturn rc;\n\n\trc = kstrtouint(sep + 1, 10, mask_bits);\n\tif (rc)\n\t\treturn rc;\n\n\tif (*mask_bits > ((proto == QETH_PROT_IPV4) ? 32 : 128))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic ssize_t qeth_l3_dev_ipato_add_store(const char *buf, size_t count,\n\t\t\t struct qeth_card *card, enum qeth_prot_versions proto)\n{\n\tstruct qeth_ipato_entry *ipatoe;\n\tunsigned int mask_bits;\n\tu8 addr[16];\n\tint rc = 0;\n\n\trc = qeth_l3_parse_ipatoe(buf, proto, addr, &mask_bits);\n\tif (rc)\n\t\treturn rc;\n\n\tipatoe = kzalloc(sizeof(struct qeth_ipato_entry), GFP_KERNEL);\n\tif (!ipatoe)\n\t\treturn -ENOMEM;\n\n\tipatoe->proto = proto;\n\tmemcpy(ipatoe->addr, addr, (proto == QETH_PROT_IPV4) ? 4 : 16);\n\tipatoe->mask_bits = mask_bits;\n\n\trc = qeth_l3_add_ipato_entry(card, ipatoe);\n\tif (rc)\n\t\tkfree(ipatoe);\n\n\treturn rc ? rc : count;\n}\n\nstatic ssize_t qeth_l3_dev_ipato_add4_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_ipato_add_store(buf, count, card, QETH_PROT_IPV4);\n}\n\nstatic QETH_DEVICE_ATTR(ipato_add4, add4, 0644,\n\t\t\tqeth_l3_dev_ipato_add4_show,\n\t\t\tqeth_l3_dev_ipato_add4_store);\n\nstatic ssize_t qeth_l3_dev_ipato_del_store(const char *buf, size_t count,\n\t\t\t struct qeth_card *card, enum qeth_prot_versions proto)\n{\n\tunsigned int mask_bits;\n\tu8 addr[16];\n\tint rc = 0;\n\n\trc = qeth_l3_parse_ipatoe(buf, proto, addr, &mask_bits);\n\tif (!rc)\n\t\trc = qeth_l3_del_ipato_entry(card, proto, addr, mask_bits);\n\treturn rc ? rc : count;\n}\n\nstatic ssize_t qeth_l3_dev_ipato_del4_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_ipato_del_store(buf, count, card, QETH_PROT_IPV4);\n}\n\nstatic QETH_DEVICE_ATTR(ipato_del4, del4, 0200, NULL,\n\t\t\tqeth_l3_dev_ipato_del4_store);\n\nstatic ssize_t qeth_l3_dev_ipato_invert6_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", card->ipato.invert6 ? 1 : 0);\n}\n\nstatic ssize_t qeth_l3_dev_ipato_invert6_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tbool invert;\n\tint rc = 0;\n\n\tmutex_lock(&card->ip_lock);\n\tif (sysfs_streq(buf, \"toggle\")) {\n\t\tinvert = !card->ipato.invert6;\n\t} else if (kstrtobool(buf, &invert)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (card->ipato.invert6 != invert) {\n\t\tcard->ipato.invert6 = invert;\n\t\tqeth_l3_update_ipato(card);\n\t}\n\nout:\n\tmutex_unlock(&card->ip_lock);\n\treturn rc ? rc : count;\n}\n\nstatic QETH_DEVICE_ATTR(ipato_invert6, invert6, 0644,\n\t\t\tqeth_l3_dev_ipato_invert6_show,\n\t\t\tqeth_l3_dev_ipato_invert6_store);\n\n\nstatic ssize_t qeth_l3_dev_ipato_add6_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_ipato_add_show(buf, card, QETH_PROT_IPV6);\n}\n\nstatic ssize_t qeth_l3_dev_ipato_add6_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_ipato_add_store(buf, count, card, QETH_PROT_IPV6);\n}\n\nstatic QETH_DEVICE_ATTR(ipato_add6, add6, 0644,\n\t\t\tqeth_l3_dev_ipato_add6_show,\n\t\t\tqeth_l3_dev_ipato_add6_store);\n\nstatic ssize_t qeth_l3_dev_ipato_del6_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_l3_dev_ipato_del_store(buf, count, card, QETH_PROT_IPV6);\n}\n\nstatic QETH_DEVICE_ATTR(ipato_del6, del6, 0200, NULL,\n\t\t\tqeth_l3_dev_ipato_del6_store);\n\nstatic struct attribute *qeth_ipato_device_attrs[] = {\n\t&dev_attr_ipato_enable.attr,\n\t&dev_attr_ipato_invert4.attr,\n\t&dev_attr_ipato_add4.attr,\n\t&dev_attr_ipato_del4.attr,\n\t&dev_attr_ipato_invert6.attr,\n\t&dev_attr_ipato_add6.attr,\n\t&dev_attr_ipato_del6.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qeth_device_ipato_group = {\n\t.name = \"ipa_takeover\",\n\t.attrs = qeth_ipato_device_attrs,\n};\n\nstatic ssize_t qeth_l3_dev_ip_add_show(struct device *dev, char *buf,\n\t\t\t\t       enum qeth_prot_versions proto,\n\t\t\t\t       enum qeth_ip_types type)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstruct qeth_ipaddr *ipaddr;\n\tint offset = 0;\n\tint i;\n\n\tmutex_lock(&card->ip_lock);\n\thash_for_each(card->ip_htable, i, ipaddr, hnode) {\n\t\tif (ipaddr->proto != proto || ipaddr->type != type)\n\t\t\tcontinue;\n\n\t\tqeth_l3_ipaddr_to_string(proto, (u8 *)&ipaddr->u, addr_str);\n\t\toffset += sysfs_emit_at(buf, offset, \"%s\\n\", addr_str);\n\t}\n\tmutex_unlock(&card->ip_lock);\n\n\treturn offset ? offset : sysfs_emit(buf, \"\\n\");\n}\n\nstatic ssize_t qeth_l3_dev_vipa_add4_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn qeth_l3_dev_ip_add_show(dev, buf, QETH_PROT_IPV4,\n\t\t\t\t       QETH_IP_TYPE_VIPA);\n}\n\nstatic ssize_t qeth_l3_vipa_store(struct device *dev, const char *buf, bool add,\n\t\t\t\t  size_t count, enum qeth_prot_versions proto)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tu8 addr[16] = {0, };\n\tint rc;\n\n\trc = qeth_l3_string_to_ipaddr(buf, proto, addr);\n\tif (!rc)\n\t\trc = qeth_l3_modify_rxip_vipa(card, add, addr,\n\t\t\t\t\t      QETH_IP_TYPE_VIPA, proto);\n\treturn rc ? rc : count;\n}\n\nstatic ssize_t qeth_l3_dev_vipa_add4_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn qeth_l3_vipa_store(dev, buf, true, count, QETH_PROT_IPV4);\n}\n\nstatic QETH_DEVICE_ATTR(vipa_add4, add4, 0644,\n\t\t\tqeth_l3_dev_vipa_add4_show,\n\t\t\tqeth_l3_dev_vipa_add4_store);\n\nstatic ssize_t qeth_l3_dev_vipa_del4_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn qeth_l3_vipa_store(dev, buf, false, count, QETH_PROT_IPV4);\n}\n\nstatic QETH_DEVICE_ATTR(vipa_del4, del4, 0200, NULL,\n\t\t\tqeth_l3_dev_vipa_del4_store);\n\nstatic ssize_t qeth_l3_dev_vipa_add6_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn qeth_l3_dev_ip_add_show(dev, buf, QETH_PROT_IPV6,\n\t\t\t\t       QETH_IP_TYPE_VIPA);\n}\n\nstatic ssize_t qeth_l3_dev_vipa_add6_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn qeth_l3_vipa_store(dev, buf, true, count, QETH_PROT_IPV6);\n}\n\nstatic QETH_DEVICE_ATTR(vipa_add6, add6, 0644,\n\t\t\tqeth_l3_dev_vipa_add6_show,\n\t\t\tqeth_l3_dev_vipa_add6_store);\n\nstatic ssize_t qeth_l3_dev_vipa_del6_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn qeth_l3_vipa_store(dev, buf, false, count, QETH_PROT_IPV6);\n}\n\nstatic QETH_DEVICE_ATTR(vipa_del6, del6, 0200, NULL,\n\t\t\tqeth_l3_dev_vipa_del6_store);\n\nstatic struct attribute *qeth_vipa_device_attrs[] = {\n\t&dev_attr_vipa_add4.attr,\n\t&dev_attr_vipa_del4.attr,\n\t&dev_attr_vipa_add6.attr,\n\t&dev_attr_vipa_del6.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qeth_device_vipa_group = {\n\t.name = \"vipa\",\n\t.attrs = qeth_vipa_device_attrs,\n};\n\nstatic ssize_t qeth_l3_dev_rxip_add4_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn qeth_l3_dev_ip_add_show(dev, buf, QETH_PROT_IPV4,\n\t\t\t\t       QETH_IP_TYPE_RXIP);\n}\n\nstatic int qeth_l3_parse_rxipe(const char *buf, enum qeth_prot_versions proto,\n\t\t u8 *addr)\n{\n\t__be32 ipv4_addr;\n\tstruct in6_addr ipv6_addr;\n\n\tif (qeth_l3_string_to_ipaddr(buf, proto, addr)) {\n\t\treturn -EINVAL;\n\t}\n\tif (proto == QETH_PROT_IPV4) {\n\t\tmemcpy(&ipv4_addr, addr, sizeof(ipv4_addr));\n\t\tif (ipv4_is_multicast(ipv4_addr)) {\n\t\t\tQETH_DBF_MESSAGE(2, \"multicast rxip not supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (proto == QETH_PROT_IPV6) {\n\t\tmemcpy(&ipv6_addr, addr, sizeof(ipv6_addr));\n\t\tif (ipv6_addr_is_multicast(&ipv6_addr)) {\n\t\t\tQETH_DBF_MESSAGE(2, \"multicast rxip not supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t qeth_l3_rxip_store(struct device *dev, const char *buf, bool add,\n\t\t\t\t  size_t count, enum qeth_prot_versions proto)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tu8 addr[16] = {0, };\n\tint rc;\n\n\trc = qeth_l3_parse_rxipe(buf, proto, addr);\n\tif (!rc)\n\t\trc = qeth_l3_modify_rxip_vipa(card, add, addr,\n\t\t\t\t\t      QETH_IP_TYPE_RXIP, proto);\n\treturn rc ? rc : count;\n}\n\nstatic ssize_t qeth_l3_dev_rxip_add4_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn qeth_l3_rxip_store(dev, buf, true, count, QETH_PROT_IPV4);\n}\n\nstatic QETH_DEVICE_ATTR(rxip_add4, add4, 0644,\n\t\t\tqeth_l3_dev_rxip_add4_show,\n\t\t\tqeth_l3_dev_rxip_add4_store);\n\nstatic ssize_t qeth_l3_dev_rxip_del4_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn qeth_l3_rxip_store(dev, buf, false, count, QETH_PROT_IPV4);\n}\n\nstatic QETH_DEVICE_ATTR(rxip_del4, del4, 0200, NULL,\n\t\t\tqeth_l3_dev_rxip_del4_store);\n\nstatic ssize_t qeth_l3_dev_rxip_add6_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn qeth_l3_dev_ip_add_show(dev, buf, QETH_PROT_IPV6,\n\t\t\t\t       QETH_IP_TYPE_RXIP);\n}\n\nstatic ssize_t qeth_l3_dev_rxip_add6_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn qeth_l3_rxip_store(dev, buf, true, count, QETH_PROT_IPV6);\n}\n\nstatic QETH_DEVICE_ATTR(rxip_add6, add6, 0644,\n\t\t\tqeth_l3_dev_rxip_add6_show,\n\t\t\tqeth_l3_dev_rxip_add6_store);\n\nstatic ssize_t qeth_l3_dev_rxip_del6_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn qeth_l3_rxip_store(dev, buf, false, count, QETH_PROT_IPV6);\n}\n\nstatic QETH_DEVICE_ATTR(rxip_del6, del6, 0200, NULL,\n\t\t\tqeth_l3_dev_rxip_del6_store);\n\nstatic struct attribute *qeth_rxip_device_attrs[] = {\n\t&dev_attr_rxip_add4.attr,\n\t&dev_attr_rxip_del4.attr,\n\t&dev_attr_rxip_add6.attr,\n\t&dev_attr_rxip_del6.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qeth_device_rxip_group = {\n\t.name = \"rxip\",\n\t.attrs = qeth_rxip_device_attrs,\n};\n\nconst struct attribute_group *qeth_l3_attr_groups[] = {\n\t&qeth_l3_device_attr_group,\n\t&qeth_device_ipato_group,\n\t&qeth_device_vipa_group,\n\t&qeth_device_rxip_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}