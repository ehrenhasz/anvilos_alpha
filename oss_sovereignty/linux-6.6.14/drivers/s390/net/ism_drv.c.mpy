{
  "module_name": "ism_drv.c",
  "hash_id": "df8989f02ec7df35e118790d8e1ccdb54ad44e77a29aff55d05f645cb78357ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/ism_drv.c",
  "human_readable_source": "\n \n#define KMSG_COMPONENT \"ism\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/ctype.h>\n#include <linux/processor.h>\n\n#include \"ism.h\"\n\nMODULE_DESCRIPTION(\"ISM driver for s390\");\nMODULE_LICENSE(\"GPL\");\n\n#define PCI_DEVICE_ID_IBM_ISM 0x04ED\n#define DRV_NAME \"ism\"\n\nstatic const struct pci_device_id ism_device_table[] = {\n\t{ PCI_VDEVICE(IBM, PCI_DEVICE_ID_IBM_ISM), 0 },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, ism_device_table);\n\nstatic debug_info_t *ism_debug_info;\n\n#define NO_CLIENT\t\t0xff\t\t \nstatic struct ism_client *clients[MAX_CLIENTS];\t \n\t\t\t\t\t\t \nstatic u8 max_client;\nstatic DEFINE_MUTEX(clients_lock);\nstruct ism_dev_list {\n\tstruct list_head list;\n\tstruct mutex mutex;  \n};\n\nstatic struct ism_dev_list ism_dev_list = {\n\t.list = LIST_HEAD_INIT(ism_dev_list.list),\n\t.mutex = __MUTEX_INITIALIZER(ism_dev_list.mutex),\n};\n\nstatic void ism_setup_forwarding(struct ism_client *client, struct ism_dev *ism)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ism->lock, flags);\n\tism->subs[client->id] = client;\n\tspin_unlock_irqrestore(&ism->lock, flags);\n}\n\nint ism_register_client(struct ism_client *client)\n{\n\tstruct ism_dev *ism;\n\tint i, rc = -ENOSPC;\n\n\tmutex_lock(&ism_dev_list.mutex);\n\tmutex_lock(&clients_lock);\n\tfor (i = 0; i < MAX_CLIENTS; ++i) {\n\t\tif (!clients[i]) {\n\t\t\tclients[i] = client;\n\t\t\tclient->id = i;\n\t\t\tif (i == max_client)\n\t\t\t\tmax_client++;\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&clients_lock);\n\n\tif (i < MAX_CLIENTS) {\n\t\t \n\t\tlist_for_each_entry(ism, &ism_dev_list.list, list) {\n\t\t\tism->priv[i] = NULL;\n\t\t\tclient->add(ism);\n\t\t\tism_setup_forwarding(client, ism);\n\t\t}\n\t}\n\tmutex_unlock(&ism_dev_list.mutex);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ism_register_client);\n\nint ism_unregister_client(struct ism_client *client)\n{\n\tstruct ism_dev *ism;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tmutex_lock(&ism_dev_list.mutex);\n\tlist_for_each_entry(ism, &ism_dev_list.list, list) {\n\t\tspin_lock_irqsave(&ism->lock, flags);\n\t\t \n\t\tism->subs[client->id] = NULL;\n\t\tfor (int i = 0; i < ISM_NR_DMBS; ++i) {\n\t\t\tif (ism->sba_client_arr[i] == client->id) {\n\t\t\t\tWARN(1, \"%s: attempt to unregister '%s' with registered dmb(s)\\n\",\n\t\t\t\t     __func__, client->name);\n\t\t\t\trc = -EBUSY;\n\t\t\t\tgoto err_reg_dmb;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ism->lock, flags);\n\t}\n\tmutex_unlock(&ism_dev_list.mutex);\n\n\tmutex_lock(&clients_lock);\n\tclients[client->id] = NULL;\n\tif (client->id + 1 == max_client)\n\t\tmax_client--;\n\tmutex_unlock(&clients_lock);\n\treturn rc;\n\nerr_reg_dmb:\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\tmutex_unlock(&ism_dev_list.mutex);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ism_unregister_client);\n\nstatic int ism_cmd(struct ism_dev *ism, void *cmd)\n{\n\tstruct ism_req_hdr *req = cmd;\n\tstruct ism_resp_hdr *resp = cmd;\n\n\t__ism_write_cmd(ism, req + 1, sizeof(*req), req->len - sizeof(*req));\n\t__ism_write_cmd(ism, req, 0, sizeof(*req));\n\n\tWRITE_ONCE(resp->ret, ISM_ERROR);\n\n\t__ism_read_cmd(ism, resp, 0, sizeof(*resp));\n\tif (resp->ret) {\n\t\tdebug_text_event(ism_debug_info, 0, \"cmd failure\");\n\t\tdebug_event(ism_debug_info, 0, resp, sizeof(*resp));\n\t\tgoto out;\n\t}\n\t__ism_read_cmd(ism, resp + 1, sizeof(*resp), resp->len - sizeof(*resp));\nout:\n\treturn resp->ret;\n}\n\nstatic int ism_cmd_simple(struct ism_dev *ism, u32 cmd_code)\n{\n\tunion ism_cmd_simple cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = cmd_code;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\treturn ism_cmd(ism, &cmd);\n}\n\nstatic int query_info(struct ism_dev *ism)\n{\n\tunion ism_qi cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_QUERY_INFO;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\tif (ism_cmd(ism, &cmd))\n\t\tgoto out;\n\n\tdebug_text_event(ism_debug_info, 3, \"query info\");\n\tdebug_event(ism_debug_info, 3, &cmd.response, sizeof(cmd.response));\nout:\n\treturn 0;\n}\n\nstatic int register_sba(struct ism_dev *ism)\n{\n\tunion ism_reg_sba cmd;\n\tdma_addr_t dma_handle;\n\tstruct ism_sba *sba;\n\n\tsba = dma_alloc_coherent(&ism->pdev->dev, PAGE_SIZE, &dma_handle,\n\t\t\t\t GFP_KERNEL);\n\tif (!sba)\n\t\treturn -ENOMEM;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_REG_SBA;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tcmd.request.sba = dma_handle;\n\n\tif (ism_cmd(ism, &cmd)) {\n\t\tdma_free_coherent(&ism->pdev->dev, PAGE_SIZE, sba, dma_handle);\n\t\treturn -EIO;\n\t}\n\n\tism->sba = sba;\n\tism->sba_dma_addr = dma_handle;\n\n\treturn 0;\n}\n\nstatic int register_ieq(struct ism_dev *ism)\n{\n\tunion ism_reg_ieq cmd;\n\tdma_addr_t dma_handle;\n\tstruct ism_eq *ieq;\n\n\tieq = dma_alloc_coherent(&ism->pdev->dev, PAGE_SIZE, &dma_handle,\n\t\t\t\t GFP_KERNEL);\n\tif (!ieq)\n\t\treturn -ENOMEM;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_REG_IEQ;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\tcmd.request.ieq = dma_handle;\n\tcmd.request.len = sizeof(*ieq);\n\n\tif (ism_cmd(ism, &cmd)) {\n\t\tdma_free_coherent(&ism->pdev->dev, PAGE_SIZE, ieq, dma_handle);\n\t\treturn -EIO;\n\t}\n\n\tism->ieq = ieq;\n\tism->ieq_idx = -1;\n\tism->ieq_dma_addr = dma_handle;\n\n\treturn 0;\n}\n\nstatic int unregister_sba(struct ism_dev *ism)\n{\n\tint ret;\n\n\tif (!ism->sba)\n\t\treturn 0;\n\n\tret = ism_cmd_simple(ism, ISM_UNREG_SBA);\n\tif (ret && ret != ISM_ERROR)\n\t\treturn -EIO;\n\n\tdma_free_coherent(&ism->pdev->dev, PAGE_SIZE,\n\t\t\t  ism->sba, ism->sba_dma_addr);\n\n\tism->sba = NULL;\n\tism->sba_dma_addr = 0;\n\n\treturn 0;\n}\n\nstatic int unregister_ieq(struct ism_dev *ism)\n{\n\tint ret;\n\n\tif (!ism->ieq)\n\t\treturn 0;\n\n\tret = ism_cmd_simple(ism, ISM_UNREG_IEQ);\n\tif (ret && ret != ISM_ERROR)\n\t\treturn -EIO;\n\n\tdma_free_coherent(&ism->pdev->dev, PAGE_SIZE,\n\t\t\t  ism->ieq, ism->ieq_dma_addr);\n\n\tism->ieq = NULL;\n\tism->ieq_dma_addr = 0;\n\n\treturn 0;\n}\n\nstatic int ism_read_local_gid(struct ism_dev *ism)\n{\n\tunion ism_read_gid cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_READ_GID;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\tret = ism_cmd(ism, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tism->local_gid = cmd.response.gid;\nout:\n\treturn ret;\n}\n\nstatic void ism_free_dmb(struct ism_dev *ism, struct ism_dmb *dmb)\n{\n\tclear_bit(dmb->sba_idx, ism->sba_bitmap);\n\tdma_free_coherent(&ism->pdev->dev, dmb->dmb_len,\n\t\t\t  dmb->cpu_addr, dmb->dma_addr);\n}\n\nstatic int ism_alloc_dmb(struct ism_dev *ism, struct ism_dmb *dmb)\n{\n\tunsigned long bit;\n\n\tif (PAGE_ALIGN(dmb->dmb_len) > dma_get_max_seg_size(&ism->pdev->dev))\n\t\treturn -EINVAL;\n\n\tif (!dmb->sba_idx) {\n\t\tbit = find_next_zero_bit(ism->sba_bitmap, ISM_NR_DMBS,\n\t\t\t\t\t ISM_DMB_BIT_OFFSET);\n\t\tif (bit == ISM_NR_DMBS)\n\t\t\treturn -ENOSPC;\n\n\t\tdmb->sba_idx = bit;\n\t}\n\tif (dmb->sba_idx < ISM_DMB_BIT_OFFSET ||\n\t    test_and_set_bit(dmb->sba_idx, ism->sba_bitmap))\n\t\treturn -EINVAL;\n\n\tdmb->cpu_addr = dma_alloc_coherent(&ism->pdev->dev, dmb->dmb_len,\n\t\t\t\t\t   &dmb->dma_addr,\n\t\t\t\t\t   GFP_KERNEL | __GFP_NOWARN |\n\t\t\t\t\t   __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!dmb->cpu_addr)\n\t\tclear_bit(dmb->sba_idx, ism->sba_bitmap);\n\n\treturn dmb->cpu_addr ? 0 : -ENOMEM;\n}\n\nint ism_register_dmb(struct ism_dev *ism, struct ism_dmb *dmb,\n\t\t     struct ism_client *client)\n{\n\tunion ism_reg_dmb cmd;\n\tunsigned long flags;\n\tint ret;\n\n\tret = ism_alloc_dmb(ism, dmb);\n\tif (ret)\n\t\tgoto out;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_REG_DMB;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\tcmd.request.dmb = dmb->dma_addr;\n\tcmd.request.dmb_len = dmb->dmb_len;\n\tcmd.request.sba_idx = dmb->sba_idx;\n\tcmd.request.vlan_valid = dmb->vlan_valid;\n\tcmd.request.vlan_id = dmb->vlan_id;\n\tcmd.request.rgid = dmb->rgid;\n\n\tret = ism_cmd(ism, &cmd);\n\tif (ret) {\n\t\tism_free_dmb(ism, dmb);\n\t\tgoto out;\n\t}\n\tdmb->dmb_tok = cmd.response.dmb_tok;\n\tspin_lock_irqsave(&ism->lock, flags);\n\tism->sba_client_arr[dmb->sba_idx - ISM_DMB_BIT_OFFSET] = client->id;\n\tspin_unlock_irqrestore(&ism->lock, flags);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ism_register_dmb);\n\nint ism_unregister_dmb(struct ism_dev *ism, struct ism_dmb *dmb)\n{\n\tunion ism_unreg_dmb cmd;\n\tunsigned long flags;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_UNREG_DMB;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\tcmd.request.dmb_tok = dmb->dmb_tok;\n\n\tspin_lock_irqsave(&ism->lock, flags);\n\tism->sba_client_arr[dmb->sba_idx - ISM_DMB_BIT_OFFSET] = NO_CLIENT;\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\n\tret = ism_cmd(ism, &cmd);\n\tif (ret && ret != ISM_ERROR)\n\t\tgoto out;\n\n\tism_free_dmb(ism, dmb);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ism_unregister_dmb);\n\nstatic int ism_add_vlan_id(struct ism_dev *ism, u64 vlan_id)\n{\n\tunion ism_set_vlan_id cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_ADD_VLAN_ID;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\tcmd.request.vlan_id = vlan_id;\n\n\treturn ism_cmd(ism, &cmd);\n}\n\nstatic int ism_del_vlan_id(struct ism_dev *ism, u64 vlan_id)\n{\n\tunion ism_set_vlan_id cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_DEL_VLAN_ID;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\tcmd.request.vlan_id = vlan_id;\n\n\treturn ism_cmd(ism, &cmd);\n}\n\nstatic unsigned int max_bytes(unsigned int start, unsigned int len,\n\t\t\t      unsigned int boundary)\n{\n\treturn min(boundary - (start & (boundary - 1)), len);\n}\n\nint ism_move(struct ism_dev *ism, u64 dmb_tok, unsigned int idx, bool sf,\n\t     unsigned int offset, void *data, unsigned int size)\n{\n\tunsigned int bytes;\n\tu64 dmb_req;\n\tint ret;\n\n\twhile (size) {\n\t\tbytes = max_bytes(offset, size, PAGE_SIZE);\n\t\tdmb_req = ISM_CREATE_REQ(dmb_tok, idx, size == bytes ? sf : 0,\n\t\t\t\t\t offset);\n\n\t\tret = __ism_move(ism, dmb_req, data, bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsize -= bytes;\n\t\tdata += bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ism_move);\n\nstatic struct ism_systemeid SYSTEM_EID = {\n\t.seid_string = \"IBM-SYSZ-ISMSEID00000000\",\n\t.serial_number = \"0000\",\n\t.type = \"0000\",\n};\n\nstatic void ism_create_system_eid(void)\n{\n\tstruct cpuid id;\n\tu16 ident_tail;\n\tchar tmp[5];\n\n\tget_cpu_id(&id);\n\tident_tail = (u16)(id.ident & ISM_IDENT_MASK);\n\tsnprintf(tmp, 5, \"%04X\", ident_tail);\n\tmemcpy(&SYSTEM_EID.serial_number, tmp, 4);\n\tsnprintf(tmp, 5, \"%04X\", id.machine);\n\tmemcpy(&SYSTEM_EID.type, tmp, 4);\n}\n\nu8 *ism_get_seid(void)\n{\n\treturn SYSTEM_EID.seid_string;\n}\nEXPORT_SYMBOL_GPL(ism_get_seid);\n\nstatic void ism_handle_event(struct ism_dev *ism)\n{\n\tstruct ism_event *entry;\n\tstruct ism_client *clt;\n\tint i;\n\n\twhile ((ism->ieq_idx + 1) != READ_ONCE(ism->ieq->header.idx)) {\n\t\tif (++(ism->ieq_idx) == ARRAY_SIZE(ism->ieq->entry))\n\t\t\tism->ieq_idx = 0;\n\n\t\tentry = &ism->ieq->entry[ism->ieq_idx];\n\t\tdebug_event(ism_debug_info, 2, entry, sizeof(*entry));\n\t\tfor (i = 0; i < max_client; ++i) {\n\t\t\tclt = ism->subs[i];\n\t\t\tif (clt)\n\t\t\t\tclt->handle_event(ism, entry);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t ism_handle_irq(int irq, void *data)\n{\n\tstruct ism_dev *ism = data;\n\tunsigned long bit, end;\n\tunsigned long *bv;\n\tu16 dmbemask;\n\tu8 client_id;\n\n\tbv = (void *) &ism->sba->dmb_bits[ISM_DMB_WORD_OFFSET];\n\tend = sizeof(ism->sba->dmb_bits) * BITS_PER_BYTE - ISM_DMB_BIT_OFFSET;\n\n\tspin_lock(&ism->lock);\n\tism->sba->s = 0;\n\tbarrier();\n\tfor (bit = 0;;) {\n\t\tbit = find_next_bit_inv(bv, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\n\t\tclear_bit_inv(bit, bv);\n\t\tdmbemask = ism->sba->dmbe_mask[bit + ISM_DMB_BIT_OFFSET];\n\t\tism->sba->dmbe_mask[bit + ISM_DMB_BIT_OFFSET] = 0;\n\t\tbarrier();\n\t\tclient_id = ism->sba_client_arr[bit];\n\t\tif (unlikely(client_id == NO_CLIENT || !ism->subs[client_id]))\n\t\t\tcontinue;\n\t\tism->subs[client_id]->handle_irq(ism, bit + ISM_DMB_BIT_OFFSET, dmbemask);\n\t}\n\n\tif (ism->sba->e) {\n\t\tism->sba->e = 0;\n\t\tbarrier();\n\t\tism_handle_event(ism);\n\t}\n\tspin_unlock(&ism->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ism_dev_init(struct ism_dev *ism)\n{\n\tstruct pci_dev *pdev = ism->pdev;\n\tint i, ret;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tism->sba_client_arr = kzalloc(ISM_NR_DMBS, GFP_KERNEL);\n\tif (!ism->sba_client_arr)\n\t\tgoto free_vectors;\n\tmemset(ism->sba_client_arr, NO_CLIENT, ISM_NR_DMBS);\n\n\tret = request_irq(pci_irq_vector(pdev, 0), ism_handle_irq, 0,\n\t\t\t  pci_name(pdev), ism);\n\tif (ret)\n\t\tgoto free_client_arr;\n\n\tret = register_sba(ism);\n\tif (ret)\n\t\tgoto free_irq;\n\n\tret = register_ieq(ism);\n\tif (ret)\n\t\tgoto unreg_sba;\n\n\tret = ism_read_local_gid(ism);\n\tif (ret)\n\t\tgoto unreg_ieq;\n\n\tif (!ism_add_vlan_id(ism, ISM_RESERVED_VLANID))\n\t\t \n\t\tism_create_system_eid();\n\n\tmutex_lock(&ism_dev_list.mutex);\n\tmutex_lock(&clients_lock);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i]) {\n\t\t\tclients[i]->add(ism);\n\t\t\tism_setup_forwarding(clients[i], ism);\n\t\t}\n\t}\n\tmutex_unlock(&clients_lock);\n\n\tlist_add(&ism->list, &ism_dev_list.list);\n\tmutex_unlock(&ism_dev_list.mutex);\n\n\tquery_info(ism);\n\treturn 0;\n\nunreg_ieq:\n\tunregister_ieq(ism);\nunreg_sba:\n\tunregister_sba(ism);\nfree_irq:\n\tfree_irq(pci_irq_vector(pdev, 0), ism);\nfree_client_arr:\n\tkfree(ism->sba_client_arr);\nfree_vectors:\n\tpci_free_irq_vectors(pdev);\nout:\n\treturn ret;\n}\n\nstatic int ism_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct ism_dev *ism;\n\tint ret;\n\n\tism = kzalloc(sizeof(*ism), GFP_KERNEL);\n\tif (!ism)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ism->lock);\n\tdev_set_drvdata(&pdev->dev, ism);\n\tism->pdev = pdev;\n\tism->dev.parent = &pdev->dev;\n\tdevice_initialize(&ism->dev);\n\tdev_set_name(&ism->dev, dev_name(&pdev->dev));\n\tret = device_add(&ism->dev);\n\tif (ret)\n\t\tgoto err_dev;\n\n\tret = pci_enable_device_mem(pdev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = pci_request_mem_regions(pdev, DRV_NAME);\n\tif (ret)\n\t\tgoto err_disable;\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\tgoto err_resource;\n\n\tdma_set_seg_boundary(&pdev->dev, SZ_1M - 1);\n\tdma_set_max_seg_size(&pdev->dev, SZ_1M);\n\tpci_set_master(pdev);\n\n\tret = ism_dev_init(ism);\n\tif (ret)\n\t\tgoto err_resource;\n\n\treturn 0;\n\nerr_resource:\n\tpci_release_mem_regions(pdev);\nerr_disable:\n\tpci_disable_device(pdev);\nerr:\n\tdevice_del(&ism->dev);\nerr_dev:\n\tdev_set_drvdata(&pdev->dev, NULL);\n\tkfree(ism);\n\n\treturn ret;\n}\n\nstatic void ism_dev_exit(struct ism_dev *ism)\n{\n\tstruct pci_dev *pdev = ism->pdev;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&ism->lock, flags);\n\tfor (i = 0; i < max_client; ++i)\n\t\tism->subs[i] = NULL;\n\tspin_unlock_irqrestore(&ism->lock, flags);\n\n\tmutex_lock(&ism_dev_list.mutex);\n\tmutex_lock(&clients_lock);\n\tfor (i = 0; i < max_client; ++i) {\n\t\tif (clients[i])\n\t\t\tclients[i]->remove(ism);\n\t}\n\tmutex_unlock(&clients_lock);\n\n\tif (SYSTEM_EID.serial_number[0] != '0' ||\n\t    SYSTEM_EID.type[0] != '0')\n\t\tism_del_vlan_id(ism, ISM_RESERVED_VLANID);\n\tunregister_ieq(ism);\n\tunregister_sba(ism);\n\tfree_irq(pci_irq_vector(pdev, 0), ism);\n\tkfree(ism->sba_client_arr);\n\tpci_free_irq_vectors(pdev);\n\tlist_del_init(&ism->list);\n\tmutex_unlock(&ism_dev_list.mutex);\n}\n\nstatic void ism_remove(struct pci_dev *pdev)\n{\n\tstruct ism_dev *ism = dev_get_drvdata(&pdev->dev);\n\n\tism_dev_exit(ism);\n\n\tpci_release_mem_regions(pdev);\n\tpci_disable_device(pdev);\n\tdevice_del(&ism->dev);\n\tdev_set_drvdata(&pdev->dev, NULL);\n\tkfree(ism);\n}\n\nstatic struct pci_driver ism_driver = {\n\t.name\t  = DRV_NAME,\n\t.id_table = ism_device_table,\n\t.probe\t  = ism_probe,\n\t.remove\t  = ism_remove,\n};\n\nstatic int __init ism_init(void)\n{\n\tint ret;\n\n\tism_debug_info = debug_register(\"ism\", 2, 1, 16);\n\tif (!ism_debug_info)\n\t\treturn -ENODEV;\n\n\tmemset(clients, 0, sizeof(clients));\n\tmax_client = 0;\n\tdebug_register_view(ism_debug_info, &debug_hex_ascii_view);\n\tret = pci_register_driver(&ism_driver);\n\tif (ret)\n\t\tdebug_unregister(ism_debug_info);\n\n\treturn ret;\n}\n\nstatic void __exit ism_exit(void)\n{\n\tpci_unregister_driver(&ism_driver);\n\tdebug_unregister(ism_debug_info);\n}\n\nmodule_init(ism_init);\nmodule_exit(ism_exit);\n\n \n\n#if IS_ENABLED(CONFIG_SMC)\nstatic int ism_query_rgid(struct ism_dev *ism, u64 rgid, u32 vid_valid,\n\t\t\t  u32 vid)\n{\n\tunion ism_query_rgid cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_QUERY_RGID;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\tcmd.request.rgid = rgid;\n\tcmd.request.vlan_valid = vid_valid;\n\tcmd.request.vlan_id = vid;\n\n\treturn ism_cmd(ism, &cmd);\n}\n\nstatic int smcd_query_rgid(struct smcd_dev *smcd, u64 rgid, u32 vid_valid,\n\t\t\t   u32 vid)\n{\n\treturn ism_query_rgid(smcd->priv, rgid, vid_valid, vid);\n}\n\nstatic int smcd_register_dmb(struct smcd_dev *smcd, struct smcd_dmb *dmb,\n\t\t\t     struct ism_client *client)\n{\n\treturn ism_register_dmb(smcd->priv, (struct ism_dmb *)dmb, client);\n}\n\nstatic int smcd_unregister_dmb(struct smcd_dev *smcd, struct smcd_dmb *dmb)\n{\n\treturn ism_unregister_dmb(smcd->priv, (struct ism_dmb *)dmb);\n}\n\nstatic int smcd_add_vlan_id(struct smcd_dev *smcd, u64 vlan_id)\n{\n\treturn ism_add_vlan_id(smcd->priv, vlan_id);\n}\n\nstatic int smcd_del_vlan_id(struct smcd_dev *smcd, u64 vlan_id)\n{\n\treturn ism_del_vlan_id(smcd->priv, vlan_id);\n}\n\nstatic int smcd_set_vlan_required(struct smcd_dev *smcd)\n{\n\treturn ism_cmd_simple(smcd->priv, ISM_SET_VLAN);\n}\n\nstatic int smcd_reset_vlan_required(struct smcd_dev *smcd)\n{\n\treturn ism_cmd_simple(smcd->priv, ISM_RESET_VLAN);\n}\n\nstatic int ism_signal_ieq(struct ism_dev *ism, u64 rgid, u32 trigger_irq,\n\t\t\t  u32 event_code, u64 info)\n{\n\tunion ism_sig_ieq cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.request.hdr.cmd = ISM_SIGNAL_IEQ;\n\tcmd.request.hdr.len = sizeof(cmd.request);\n\n\tcmd.request.rgid = rgid;\n\tcmd.request.trigger_irq = trigger_irq;\n\tcmd.request.event_code = event_code;\n\tcmd.request.info = info;\n\n\treturn ism_cmd(ism, &cmd);\n}\n\nstatic int smcd_signal_ieq(struct smcd_dev *smcd, u64 rgid, u32 trigger_irq,\n\t\t\t   u32 event_code, u64 info)\n{\n\treturn ism_signal_ieq(smcd->priv, rgid, trigger_irq, event_code, info);\n}\n\nstatic int smcd_move(struct smcd_dev *smcd, u64 dmb_tok, unsigned int idx,\n\t\t     bool sf, unsigned int offset, void *data,\n\t\t     unsigned int size)\n{\n\treturn ism_move(smcd->priv, dmb_tok, idx, sf, offset, data, size);\n}\n\nstatic int smcd_supports_v2(void)\n{\n\treturn SYSTEM_EID.serial_number[0] != '0' ||\n\t\tSYSTEM_EID.type[0] != '0';\n}\n\nstatic u64 ism_get_local_gid(struct ism_dev *ism)\n{\n\treturn ism->local_gid;\n}\n\nstatic u64 smcd_get_local_gid(struct smcd_dev *smcd)\n{\n\treturn ism_get_local_gid(smcd->priv);\n}\n\nstatic u16 ism_get_chid(struct ism_dev *ism)\n{\n\tif (!ism || !ism->pdev)\n\t\treturn 0;\n\n\treturn to_zpci(ism->pdev)->pchid;\n}\n\nstatic u16 smcd_get_chid(struct smcd_dev *smcd)\n{\n\treturn ism_get_chid(smcd->priv);\n}\n\nstatic inline struct device *smcd_get_dev(struct smcd_dev *dev)\n{\n\tstruct ism_dev *ism = dev->priv;\n\n\treturn &ism->dev;\n}\n\nstatic const struct smcd_ops ism_ops = {\n\t.query_remote_gid = smcd_query_rgid,\n\t.register_dmb = smcd_register_dmb,\n\t.unregister_dmb = smcd_unregister_dmb,\n\t.add_vlan_id = smcd_add_vlan_id,\n\t.del_vlan_id = smcd_del_vlan_id,\n\t.set_vlan_required = smcd_set_vlan_required,\n\t.reset_vlan_required = smcd_reset_vlan_required,\n\t.signal_event = smcd_signal_ieq,\n\t.move_data = smcd_move,\n\t.supports_v2 = smcd_supports_v2,\n\t.get_system_eid = ism_get_seid,\n\t.get_local_gid = smcd_get_local_gid,\n\t.get_chid = smcd_get_chid,\n\t.get_dev = smcd_get_dev,\n};\n\nconst struct smcd_ops *ism_get_smcd_ops(void)\n{\n\treturn &ism_ops;\n}\nEXPORT_SYMBOL_GPL(ism_get_smcd_ops);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}