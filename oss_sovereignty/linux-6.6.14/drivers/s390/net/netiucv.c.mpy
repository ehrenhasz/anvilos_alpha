{
  "module_name": "netiucv.c",
  "hash_id": "ec6f098da2d7c2fc30af52105ccba60fe9bc305844eec4373caa5f827621057c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/netiucv.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"netiucv\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#undef DEBUG\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/bitops.h>\n\n#include <linux/signal.h>\n#include <linux/string.h>\n#include <linux/device.h>\n\n#include <linux/ip.h>\n#include <linux/if_arp.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n#include <net/dst.h>\n\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <asm/ebcdic.h>\n\n#include <net/iucv/iucv.h>\n#include \"fsm.h\"\n\nMODULE_AUTHOR\n    (\"(C) 2001 IBM Corporation by Fritz Elfert (felfert@millenux.com)\");\nMODULE_DESCRIPTION (\"Linux for S/390 IUCV network driver\");\n\n \n#define IUCV_DBF_SETUP_NAME \"iucv_setup\"\n#define IUCV_DBF_SETUP_LEN 64\n#define IUCV_DBF_SETUP_PAGES 2\n#define IUCV_DBF_SETUP_NR_AREAS 1\n#define IUCV_DBF_SETUP_LEVEL 3\n\n#define IUCV_DBF_DATA_NAME \"iucv_data\"\n#define IUCV_DBF_DATA_LEN 128\n#define IUCV_DBF_DATA_PAGES 2\n#define IUCV_DBF_DATA_NR_AREAS 1\n#define IUCV_DBF_DATA_LEVEL 2\n\n#define IUCV_DBF_TRACE_NAME \"iucv_trace\"\n#define IUCV_DBF_TRACE_LEN 16\n#define IUCV_DBF_TRACE_PAGES 4\n#define IUCV_DBF_TRACE_NR_AREAS 1\n#define IUCV_DBF_TRACE_LEVEL 3\n\n#define IUCV_DBF_TEXT(name,level,text) \\\n\tdo { \\\n\t\tdebug_text_event(iucv_dbf_##name,level,text); \\\n\t} while (0)\n\n#define IUCV_DBF_HEX(name,level,addr,len) \\\n\tdo { \\\n\t\tdebug_event(iucv_dbf_##name,level,(void*)(addr),len); \\\n\t} while (0)\n\nDECLARE_PER_CPU(char[256], iucv_dbf_txt_buf);\n\n#define IUCV_DBF_TEXT_(name, level, text...) \\\n\tdo { \\\n\t\tif (debug_level_enabled(iucv_dbf_##name, level)) { \\\n\t\t\tchar* __buf = get_cpu_var(iucv_dbf_txt_buf); \\\n\t\t\tsprintf(__buf, text); \\\n\t\t\tdebug_text_event(iucv_dbf_##name, level, __buf); \\\n\t\t\tput_cpu_var(iucv_dbf_txt_buf); \\\n\t\t} \\\n\t} while (0)\n\n#define IUCV_DBF_SPRINTF(name,level,text...) \\\n\tdo { \\\n\t\tdebug_sprintf_event(iucv_dbf_trace, level, ##text ); \\\n\t\tdebug_sprintf_event(iucv_dbf_trace, level, text ); \\\n\t} while (0)\n\n \n#define PRINTK_HEADER \" iucv: \"        \n\nstatic struct device_driver netiucv_driver = {\n\t.owner = THIS_MODULE,\n\t.name = \"netiucv\",\n\t.bus  = &iucv_bus,\n};\n\n \nstruct connection_profile {\n\tunsigned long maxmulti;\n\tunsigned long maxcqueue;\n\tunsigned long doios_single;\n\tunsigned long doios_multi;\n\tunsigned long txlen;\n\tunsigned long tx_time;\n\tunsigned long send_stamp;\n\tunsigned long tx_pending;\n\tunsigned long tx_max_pending;\n};\n\n \nstruct iucv_connection {\n\tstruct list_head\t  list;\n\tstruct iucv_path\t  *path;\n\tstruct sk_buff            *rx_buff;\n\tstruct sk_buff            *tx_buff;\n\tstruct sk_buff_head       collect_queue;\n\tstruct sk_buff_head\t  commit_queue;\n\tspinlock_t                collect_lock;\n\tint                       collect_len;\n\tint                       max_buffsize;\n\tfsm_timer                 timer;\n\tfsm_instance              *fsm;\n\tstruct net_device         *netdev;\n\tstruct connection_profile prof;\n\tchar                      userid[9];\n\tchar\t\t\t  userdata[17];\n};\n\n \nstatic LIST_HEAD(iucv_connection_list);\nstatic DEFINE_RWLOCK(iucv_connection_rwlock);\n\n \nstruct iucv_event {\n\tstruct iucv_connection *conn;\n\tvoid                   *data;\n};\n\n \nstruct netiucv_priv {\n\tstruct net_device_stats stats;\n\tunsigned long           tbusy;\n\tfsm_instance            *fsm;\n        struct iucv_connection  *conn;\n\tstruct device           *dev;\n};\n\n \nstruct ll_header {\n\tu16 next;\n};\n\n#define NETIUCV_HDRLEN\t\t (sizeof(struct ll_header))\n#define NETIUCV_BUFSIZE_MAX\t 65537\n#define NETIUCV_BUFSIZE_DEFAULT  NETIUCV_BUFSIZE_MAX\n#define NETIUCV_MTU_MAX          (NETIUCV_BUFSIZE_MAX - NETIUCV_HDRLEN)\n#define NETIUCV_MTU_DEFAULT      9216\n#define NETIUCV_QUEUELEN_DEFAULT 50\n#define NETIUCV_TIMEOUT_5SEC     5000\n\n \nstatic void netiucv_clear_busy(struct net_device *dev)\n{\n\tstruct netiucv_priv *priv = netdev_priv(dev);\n\tclear_bit(0, &priv->tbusy);\n\tnetif_wake_queue(dev);\n}\n\nstatic int netiucv_test_and_set_busy(struct net_device *dev)\n{\n\tstruct netiucv_priv *priv = netdev_priv(dev);\n\tnetif_stop_queue(dev);\n\treturn test_and_set_bit(0, &priv->tbusy);\n}\n\nstatic u8 iucvMagic_ascii[16] = {\n\t0x30, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x30, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20\n};\n\nstatic u8 iucvMagic_ebcdic[16] = {\n\t0xF0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,\n\t0xF0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40\n};\n\n \nstatic char *netiucv_printname(char *name, int len)\n{\n\tstatic char tmp[17];\n\tchar *p = tmp;\n\tmemcpy(tmp, name, len);\n\ttmp[len] = '\\0';\n\twhile (*p && ((p - tmp) < len) && (!isspace(*p)))\n\t\tp++;\n\t*p = '\\0';\n\treturn tmp;\n}\n\nstatic char *netiucv_printuser(struct iucv_connection *conn)\n{\n\tstatic char tmp_uid[9];\n\tstatic char tmp_udat[17];\n\tstatic char buf[100];\n\n\tif (memcmp(conn->userdata, iucvMagic_ebcdic, 16)) {\n\t\ttmp_uid[8] = '\\0';\n\t\ttmp_udat[16] = '\\0';\n\t\tmemcpy(tmp_uid, netiucv_printname(conn->userid, 8), 8);\n\t\tmemcpy(tmp_udat, conn->userdata, 16);\n\t\tEBCASC(tmp_udat, 16);\n\t\tmemcpy(tmp_udat, netiucv_printname(tmp_udat, 16), 16);\n\t\tsprintf(buf, \"%s.%s\", tmp_uid, tmp_udat);\n\t\treturn buf;\n\t} else\n\t\treturn netiucv_printname(conn->userid, 8);\n}\n\n \nenum dev_states {\n\tDEV_STATE_STOPPED,\n\tDEV_STATE_STARTWAIT,\n\tDEV_STATE_STOPWAIT,\n\tDEV_STATE_RUNNING,\n\t \n\tNR_DEV_STATES\n};\n\nstatic const char *dev_state_names[] = {\n\t\"Stopped\",\n\t\"StartWait\",\n\t\"StopWait\",\n\t\"Running\",\n};\n\n \nenum dev_events {\n\tDEV_EVENT_START,\n\tDEV_EVENT_STOP,\n\tDEV_EVENT_CONUP,\n\tDEV_EVENT_CONDOWN,\n\t \n\tNR_DEV_EVENTS\n};\n\nstatic const char *dev_event_names[] = {\n\t\"Start\",\n\t\"Stop\",\n\t\"Connection up\",\n\t\"Connection down\",\n};\n\n \nenum conn_events {\n\t \n\tCONN_EVENT_CONN_REQ,\n\tCONN_EVENT_CONN_ACK,\n\tCONN_EVENT_CONN_REJ,\n\tCONN_EVENT_CONN_SUS,\n\tCONN_EVENT_CONN_RES,\n\tCONN_EVENT_RX,\n\tCONN_EVENT_TXDONE,\n\n\t \n\n\t \n\tCONN_EVENT_TIMER,\n\n\t \n\tCONN_EVENT_START,\n\tCONN_EVENT_STOP,\n\n\t \n\tNR_CONN_EVENTS,\n};\n\nstatic const char *conn_event_names[] = {\n\t\"Remote connection request\",\n\t\"Remote connection acknowledge\",\n\t\"Remote connection reject\",\n\t\"Connection suspended\",\n\t\"Connection resumed\",\n\t\"Data received\",\n\t\"Data sent\",\n\n\t\"Timer\",\n\n\t\"Start\",\n\t\"Stop\",\n};\n\n \nenum conn_states {\n\t \n\tCONN_STATE_INVALID,\n\n\t \n\tCONN_STATE_STOPPED,\n\n\t \n\tCONN_STATE_STARTWAIT,\n\n\t \n\tCONN_STATE_SETUPWAIT,\n\n\t \n\tCONN_STATE_IDLE,\n\n\t \n\tCONN_STATE_TX,\n\n\t \n\tCONN_STATE_REGERR,\n\n\t \n\tCONN_STATE_CONNERR,\n\n\t \n\tNR_CONN_STATES,\n};\n\nstatic const char *conn_state_names[] = {\n\t\"Invalid\",\n\t\"Stopped\",\n\t\"StartWait\",\n\t\"SetupWait\",\n\t\"Idle\",\n\t\"TX\",\n\t\"Terminating\",\n\t\"Registration error\",\n\t\"Connect error\",\n};\n\n\n \nstatic debug_info_t *iucv_dbf_setup = NULL;\nstatic debug_info_t *iucv_dbf_data = NULL;\nstatic debug_info_t *iucv_dbf_trace = NULL;\n\nDEFINE_PER_CPU(char[256], iucv_dbf_txt_buf);\n\nstatic void iucv_unregister_dbf_views(void)\n{\n\tdebug_unregister(iucv_dbf_setup);\n\tdebug_unregister(iucv_dbf_data);\n\tdebug_unregister(iucv_dbf_trace);\n}\nstatic int iucv_register_dbf_views(void)\n{\n\tiucv_dbf_setup = debug_register(IUCV_DBF_SETUP_NAME,\n\t\t\t\t\tIUCV_DBF_SETUP_PAGES,\n\t\t\t\t\tIUCV_DBF_SETUP_NR_AREAS,\n\t\t\t\t\tIUCV_DBF_SETUP_LEN);\n\tiucv_dbf_data = debug_register(IUCV_DBF_DATA_NAME,\n\t\t\t\t       IUCV_DBF_DATA_PAGES,\n\t\t\t\t       IUCV_DBF_DATA_NR_AREAS,\n\t\t\t\t       IUCV_DBF_DATA_LEN);\n\tiucv_dbf_trace = debug_register(IUCV_DBF_TRACE_NAME,\n\t\t\t\t\tIUCV_DBF_TRACE_PAGES,\n\t\t\t\t\tIUCV_DBF_TRACE_NR_AREAS,\n\t\t\t\t\tIUCV_DBF_TRACE_LEN);\n\n\tif ((iucv_dbf_setup == NULL) || (iucv_dbf_data == NULL) ||\n\t    (iucv_dbf_trace == NULL)) {\n\t\tiucv_unregister_dbf_views();\n\t\treturn -ENOMEM;\n\t}\n\tdebug_register_view(iucv_dbf_setup, &debug_hex_ascii_view);\n\tdebug_set_level(iucv_dbf_setup, IUCV_DBF_SETUP_LEVEL);\n\n\tdebug_register_view(iucv_dbf_data, &debug_hex_ascii_view);\n\tdebug_set_level(iucv_dbf_data, IUCV_DBF_DATA_LEVEL);\n\n\tdebug_register_view(iucv_dbf_trace, &debug_hex_ascii_view);\n\tdebug_set_level(iucv_dbf_trace, IUCV_DBF_TRACE_LEVEL);\n\n\treturn 0;\n}\n\n \n\nstatic void netiucv_callback_rx(struct iucv_path *path,\n\t\t\t\tstruct iucv_message *msg)\n{\n\tstruct iucv_connection *conn = path->private;\n\tstruct iucv_event ev;\n\n\tev.conn = conn;\n\tev.data = msg;\n\tfsm_event(conn->fsm, CONN_EVENT_RX, &ev);\n}\n\nstatic void netiucv_callback_txdone(struct iucv_path *path,\n\t\t\t\t    struct iucv_message *msg)\n{\n\tstruct iucv_connection *conn = path->private;\n\tstruct iucv_event ev;\n\n\tev.conn = conn;\n\tev.data = msg;\n\tfsm_event(conn->fsm, CONN_EVENT_TXDONE, &ev);\n}\n\nstatic void netiucv_callback_connack(struct iucv_path *path, u8 ipuser[16])\n{\n\tstruct iucv_connection *conn = path->private;\n\n\tfsm_event(conn->fsm, CONN_EVENT_CONN_ACK, conn);\n}\n\nstatic int netiucv_callback_connreq(struct iucv_path *path, u8 *ipvmid,\n\t\t\t\t    u8 *ipuser)\n{\n\tstruct iucv_connection *conn = path->private;\n\tstruct iucv_event ev;\n\tstatic char tmp_user[9];\n\tstatic char tmp_udat[17];\n\tint rc;\n\n\trc = -EINVAL;\n\tmemcpy(tmp_user, netiucv_printname(ipvmid, 8), 8);\n\tmemcpy(tmp_udat, ipuser, 16);\n\tEBCASC(tmp_udat, 16);\n\tread_lock_bh(&iucv_connection_rwlock);\n\tlist_for_each_entry(conn, &iucv_connection_list, list) {\n\t\tif (strncmp(ipvmid, conn->userid, 8) ||\n\t\t    strncmp(ipuser, conn->userdata, 16))\n\t\t\tcontinue;\n\t\t \n\t\tconn->path = path;\n\t\tev.conn = conn;\n\t\tev.data = path;\n\t\tfsm_event(conn->fsm, CONN_EVENT_CONN_REQ, &ev);\n\t\trc = 0;\n\t}\n\tIUCV_DBF_TEXT_(setup, 2, \"Connection requested for %s.%s\\n\",\n\t\t       tmp_user, netiucv_printname(tmp_udat, 16));\n\tread_unlock_bh(&iucv_connection_rwlock);\n\treturn rc;\n}\n\nstatic void netiucv_callback_connrej(struct iucv_path *path, u8 *ipuser)\n{\n\tstruct iucv_connection *conn = path->private;\n\n\tfsm_event(conn->fsm, CONN_EVENT_CONN_REJ, conn);\n}\n\nstatic void netiucv_callback_connsusp(struct iucv_path *path, u8 *ipuser)\n{\n\tstruct iucv_connection *conn = path->private;\n\n\tfsm_event(conn->fsm, CONN_EVENT_CONN_SUS, conn);\n}\n\nstatic void netiucv_callback_connres(struct iucv_path *path, u8 *ipuser)\n{\n\tstruct iucv_connection *conn = path->private;\n\n\tfsm_event(conn->fsm, CONN_EVENT_CONN_RES, conn);\n}\n\n \nstatic void netiucv_action_nop(fsm_instance *fi, int event, void *arg)\n{\n}\n\n \n\n \nstatic void netiucv_unpack_skb(struct iucv_connection *conn,\n\t\t\t       struct sk_buff *pskb)\n{\n\tstruct net_device     *dev = conn->netdev;\n\tstruct netiucv_priv   *privptr = netdev_priv(dev);\n\tu16 offset = 0;\n\n\tskb_put(pskb, NETIUCV_HDRLEN);\n\tpskb->dev = dev;\n\tpskb->ip_summed = CHECKSUM_NONE;\n\tpskb->protocol = cpu_to_be16(ETH_P_IP);\n\n\twhile (1) {\n\t\tstruct sk_buff *skb;\n\t\tstruct ll_header *header = (struct ll_header *) pskb->data;\n\n\t\tif (!header->next)\n\t\t\tbreak;\n\n\t\tskb_pull(pskb, NETIUCV_HDRLEN);\n\t\theader->next -= offset;\n\t\toffset += header->next;\n\t\theader->next -= NETIUCV_HDRLEN;\n\t\tif (skb_tailroom(pskb) < header->next) {\n\t\t\tIUCV_DBF_TEXT_(data, 2, \"Illegal next field: %d > %d\\n\",\n\t\t\t\theader->next, skb_tailroom(pskb));\n\t\t\treturn;\n\t\t}\n\t\tskb_put(pskb, header->next);\n\t\tskb_reset_mac_header(pskb);\n\t\tskb = dev_alloc_skb(pskb->len);\n\t\tif (!skb) {\n\t\t\tIUCV_DBF_TEXT(data, 2,\n\t\t\t\t\"Out of memory in netiucv_unpack_skb\\n\");\n\t\t\tprivptr->stats.rx_dropped++;\n\t\t\treturn;\n\t\t}\n\t\tskb_copy_from_linear_data(pskb, skb_put(skb, pskb->len),\n\t\t\t\t\t  pskb->len);\n\t\tskb_reset_mac_header(skb);\n\t\tskb->dev = pskb->dev;\n\t\tskb->protocol = pskb->protocol;\n\t\tpskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tprivptr->stats.rx_packets++;\n\t\tprivptr->stats.rx_bytes += skb->len;\n\t\tnetif_rx(skb);\n\t\tskb_pull(pskb, header->next);\n\t\tskb_put(pskb, NETIUCV_HDRLEN);\n\t}\n}\n\nstatic void conn_action_rx(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_event *ev = arg;\n\tstruct iucv_connection *conn = ev->conn;\n\tstruct iucv_message *msg = ev->data;\n\tstruct netiucv_priv *privptr = netdev_priv(conn->netdev);\n\tint rc;\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\n\tif (!conn->netdev) {\n\t\tiucv_message_reject(conn->path, msg);\n\t\tIUCV_DBF_TEXT(data, 2,\n\t\t\t      \"Received data for unlinked connection\\n\");\n\t\treturn;\n\t}\n\tif (msg->length > conn->max_buffsize) {\n\t\tiucv_message_reject(conn->path, msg);\n\t\tprivptr->stats.rx_dropped++;\n\t\tIUCV_DBF_TEXT_(data, 2, \"msglen %d > max_buffsize %d\\n\",\n\t\t\t       msg->length, conn->max_buffsize);\n\t\treturn;\n\t}\n\tconn->rx_buff->data = conn->rx_buff->head;\n\tskb_reset_tail_pointer(conn->rx_buff);\n\tconn->rx_buff->len = 0;\n\trc = iucv_message_receive(conn->path, msg, 0, conn->rx_buff->data,\n\t\t\t\t  msg->length, NULL);\n\tif (rc || msg->length < 5) {\n\t\tprivptr->stats.rx_errors++;\n\t\tIUCV_DBF_TEXT_(data, 2, \"rc %d from iucv_receive\\n\", rc);\n\t\treturn;\n\t}\n\tnetiucv_unpack_skb(conn, conn->rx_buff);\n}\n\nstatic void conn_action_txdone(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_event *ev = arg;\n\tstruct iucv_connection *conn = ev->conn;\n\tstruct iucv_message *msg = ev->data;\n\tstruct iucv_message txmsg;\n\tstruct netiucv_priv *privptr = NULL;\n\tu32 single_flag = msg->tag;\n\tu32 txbytes = 0;\n\tu32 txpackets = 0;\n\tu32 stat_maxcq = 0;\n\tstruct sk_buff *skb;\n\tunsigned long saveflags;\n\tstruct ll_header header;\n\tint rc;\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\n\tif (!conn || !conn->netdev) {\n\t\tIUCV_DBF_TEXT(data, 2,\n\t\t\t      \"Send confirmation for unlinked connection\\n\");\n\t\treturn;\n\t}\n\tprivptr = netdev_priv(conn->netdev);\n\tconn->prof.tx_pending--;\n\tif (single_flag) {\n\t\tif ((skb = skb_dequeue(&conn->commit_queue))) {\n\t\t\trefcount_dec(&skb->users);\n\t\t\tif (privptr) {\n\t\t\t\tprivptr->stats.tx_packets++;\n\t\t\t\tprivptr->stats.tx_bytes +=\n\t\t\t\t\t(skb->len - NETIUCV_HDRLEN\n\t\t\t\t\t\t  - NETIUCV_HDRLEN);\n\t\t\t}\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t}\n\tconn->tx_buff->data = conn->tx_buff->head;\n\tskb_reset_tail_pointer(conn->tx_buff);\n\tconn->tx_buff->len = 0;\n\tspin_lock_irqsave(&conn->collect_lock, saveflags);\n\twhile ((skb = skb_dequeue(&conn->collect_queue))) {\n\t\theader.next = conn->tx_buff->len + skb->len + NETIUCV_HDRLEN;\n\t\tskb_put_data(conn->tx_buff, &header, NETIUCV_HDRLEN);\n\t\tskb_copy_from_linear_data(skb,\n\t\t\t\t\t  skb_put(conn->tx_buff, skb->len),\n\t\t\t\t\t  skb->len);\n\t\ttxbytes += skb->len;\n\t\ttxpackets++;\n\t\tstat_maxcq++;\n\t\trefcount_dec(&skb->users);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\tif (conn->collect_len > conn->prof.maxmulti)\n\t\tconn->prof.maxmulti = conn->collect_len;\n\tconn->collect_len = 0;\n\tspin_unlock_irqrestore(&conn->collect_lock, saveflags);\n\tif (conn->tx_buff->len == 0) {\n\t\tfsm_newstate(fi, CONN_STATE_IDLE);\n\t\treturn;\n\t}\n\n\theader.next = 0;\n\tskb_put_data(conn->tx_buff, &header, NETIUCV_HDRLEN);\n\tconn->prof.send_stamp = jiffies;\n\ttxmsg.class = 0;\n\ttxmsg.tag = 0;\n\trc = iucv_message_send(conn->path, &txmsg, 0, 0,\n\t\t\t       conn->tx_buff->data, conn->tx_buff->len);\n\tconn->prof.doios_multi++;\n\tconn->prof.txlen += conn->tx_buff->len;\n\tconn->prof.tx_pending++;\n\tif (conn->prof.tx_pending > conn->prof.tx_max_pending)\n\t\tconn->prof.tx_max_pending = conn->prof.tx_pending;\n\tif (rc) {\n\t\tconn->prof.tx_pending--;\n\t\tfsm_newstate(fi, CONN_STATE_IDLE);\n\t\tif (privptr)\n\t\t\tprivptr->stats.tx_errors += txpackets;\n\t\tIUCV_DBF_TEXT_(data, 2, \"rc %d from iucv_send\\n\", rc);\n\t} else {\n\t\tif (privptr) {\n\t\t\tprivptr->stats.tx_packets += txpackets;\n\t\t\tprivptr->stats.tx_bytes += txbytes;\n\t\t}\n\t\tif (stat_maxcq > conn->prof.maxcqueue)\n\t\t\tconn->prof.maxcqueue = stat_maxcq;\n\t}\n}\n\nstatic struct iucv_handler netiucv_handler = {\n\t.path_pending\t  = netiucv_callback_connreq,\n\t.path_complete\t  = netiucv_callback_connack,\n\t.path_severed\t  = netiucv_callback_connrej,\n\t.path_quiesced\t  = netiucv_callback_connsusp,\n\t.path_resumed\t  = netiucv_callback_connres,\n\t.message_pending  = netiucv_callback_rx,\n\t.message_complete = netiucv_callback_txdone,\n};\n\nstatic void conn_action_connaccept(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_event *ev = arg;\n\tstruct iucv_connection *conn = ev->conn;\n\tstruct iucv_path *path = ev->data;\n\tstruct net_device *netdev = conn->netdev;\n\tstruct netiucv_priv *privptr = netdev_priv(netdev);\n\tint rc;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tconn->path = path;\n\tpath->msglim = NETIUCV_QUEUELEN_DEFAULT;\n\tpath->flags = 0;\n\trc = iucv_path_accept(path, &netiucv_handler, conn->userdata , conn);\n\tif (rc) {\n\t\tIUCV_DBF_TEXT_(setup, 2, \"rc %d from iucv_accept\", rc);\n\t\treturn;\n\t}\n\tfsm_newstate(fi, CONN_STATE_IDLE);\n\tnetdev->tx_queue_len = conn->path->msglim;\n\tfsm_event(privptr->fsm, DEV_EVENT_CONUP, netdev);\n}\n\nstatic void conn_action_connreject(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_event *ev = arg;\n\tstruct iucv_path *path = ev->data;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\tiucv_path_sever(path, NULL);\n}\n\nstatic void conn_action_connack(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_connection *conn = arg;\n\tstruct net_device *netdev = conn->netdev;\n\tstruct netiucv_priv *privptr = netdev_priv(netdev);\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\tfsm_deltimer(&conn->timer);\n\tfsm_newstate(fi, CONN_STATE_IDLE);\n\tnetdev->tx_queue_len = conn->path->msglim;\n\tfsm_event(privptr->fsm, DEV_EVENT_CONUP, netdev);\n}\n\nstatic void conn_action_conntimsev(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_connection *conn = arg;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\tfsm_deltimer(&conn->timer);\n\tiucv_path_sever(conn->path, conn->userdata);\n\tfsm_newstate(fi, CONN_STATE_STARTWAIT);\n}\n\nstatic void conn_action_connsever(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_connection *conn = arg;\n\tstruct net_device *netdev = conn->netdev;\n\tstruct netiucv_priv *privptr = netdev_priv(netdev);\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tfsm_deltimer(&conn->timer);\n\tiucv_path_sever(conn->path, conn->userdata);\n\tdev_info(privptr->dev, \"The peer z/VM guest %s has closed the \"\n\t\t\t       \"connection\\n\", netiucv_printuser(conn));\n\tIUCV_DBF_TEXT(data, 2,\n\t\t      \"conn_action_connsever: Remote dropped connection\\n\");\n\tfsm_newstate(fi, CONN_STATE_STARTWAIT);\n\tfsm_event(privptr->fsm, DEV_EVENT_CONDOWN, netdev);\n}\n\nstatic void conn_action_start(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_connection *conn = arg;\n\tstruct net_device *netdev = conn->netdev;\n\tstruct netiucv_priv *privptr = netdev_priv(netdev);\n\tint rc;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tfsm_newstate(fi, CONN_STATE_STARTWAIT);\n\n\t \n\n\tfsm_newstate(fi, CONN_STATE_SETUPWAIT);\n\tconn->path = iucv_path_alloc(NETIUCV_QUEUELEN_DEFAULT, 0, GFP_KERNEL);\n\tIUCV_DBF_TEXT_(setup, 2, \"%s: connecting to %s ...\\n\",\n\t\tnetdev->name, netiucv_printuser(conn));\n\n\trc = iucv_path_connect(conn->path, &netiucv_handler, conn->userid,\n\t\t\t       NULL, conn->userdata, conn);\n\tswitch (rc) {\n\tcase 0:\n\t\tnetdev->tx_queue_len = conn->path->msglim;\n\t\tfsm_addtimer(&conn->timer, NETIUCV_TIMEOUT_5SEC,\n\t\t\t     CONN_EVENT_TIMER, conn);\n\t\treturn;\n\tcase 11:\n\t\tdev_warn(privptr->dev,\n\t\t\t\"The IUCV device failed to connect to z/VM guest %s\\n\",\n\t\t\tnetiucv_printname(conn->userid, 8));\n\t\tfsm_newstate(fi, CONN_STATE_STARTWAIT);\n\t\tbreak;\n\tcase 12:\n\t\tdev_warn(privptr->dev,\n\t\t\t\"The IUCV device failed to connect to the peer on z/VM\"\n\t\t\t\" guest %s\\n\", netiucv_printname(conn->userid, 8));\n\t\tfsm_newstate(fi, CONN_STATE_STARTWAIT);\n\t\tbreak;\n\tcase 13:\n\t\tdev_err(privptr->dev,\n\t\t\t\"Connecting the IUCV device would exceed the maximum\"\n\t\t\t\" number of IUCV connections\\n\");\n\t\tfsm_newstate(fi, CONN_STATE_CONNERR);\n\t\tbreak;\n\tcase 14:\n\t\tdev_err(privptr->dev,\n\t\t\t\"z/VM guest %s has too many IUCV connections\"\n\t\t\t\" to connect with the IUCV device\\n\",\n\t\t\tnetiucv_printname(conn->userid, 8));\n\t\tfsm_newstate(fi, CONN_STATE_CONNERR);\n\t\tbreak;\n\tcase 15:\n\t\tdev_err(privptr->dev,\n\t\t\t\"The IUCV device cannot connect to a z/VM guest with no\"\n\t\t\t\" IUCV authorization\\n\");\n\t\tfsm_newstate(fi, CONN_STATE_CONNERR);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(privptr->dev,\n\t\t\t\"Connecting the IUCV device failed with error %d\\n\",\n\t\t\trc);\n\t\tfsm_newstate(fi, CONN_STATE_CONNERR);\n\t\tbreak;\n\t}\n\tIUCV_DBF_TEXT_(setup, 5, \"iucv_connect rc is %d\\n\", rc);\n\tkfree(conn->path);\n\tconn->path = NULL;\n}\n\nstatic void netiucv_purge_skb_queue(struct sk_buff_head *q)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(q))) {\n\t\trefcount_dec(&skb->users);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void conn_action_stop(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_event *ev = arg;\n\tstruct iucv_connection *conn = ev->conn;\n\tstruct net_device *netdev = conn->netdev;\n\tstruct netiucv_priv *privptr = netdev_priv(netdev);\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tfsm_deltimer(&conn->timer);\n\tfsm_newstate(fi, CONN_STATE_STOPPED);\n\tnetiucv_purge_skb_queue(&conn->collect_queue);\n\tif (conn->path) {\n\t\tIUCV_DBF_TEXT(trace, 5, \"calling iucv_path_sever\\n\");\n\t\tiucv_path_sever(conn->path, conn->userdata);\n\t\tkfree(conn->path);\n\t\tconn->path = NULL;\n\t}\n\tnetiucv_purge_skb_queue(&conn->commit_queue);\n\tfsm_event(privptr->fsm, DEV_EVENT_CONDOWN, netdev);\n}\n\nstatic void conn_action_inval(fsm_instance *fi, int event, void *arg)\n{\n\tstruct iucv_connection *conn = arg;\n\tstruct net_device *netdev = conn->netdev;\n\n\tIUCV_DBF_TEXT_(data, 2, \"%s('%s'): conn_action_inval called\\n\",\n\t\tnetdev->name, conn->userid);\n}\n\nstatic const fsm_node conn_fsm[] = {\n\t{ CONN_STATE_INVALID,   CONN_EVENT_START,    conn_action_inval      },\n\t{ CONN_STATE_STOPPED,   CONN_EVENT_START,    conn_action_start      },\n\n\t{ CONN_STATE_STOPPED,   CONN_EVENT_STOP,     conn_action_stop       },\n\t{ CONN_STATE_STARTWAIT, CONN_EVENT_STOP,     conn_action_stop       },\n\t{ CONN_STATE_SETUPWAIT, CONN_EVENT_STOP,     conn_action_stop       },\n\t{ CONN_STATE_IDLE,      CONN_EVENT_STOP,     conn_action_stop       },\n\t{ CONN_STATE_TX,        CONN_EVENT_STOP,     conn_action_stop       },\n\t{ CONN_STATE_REGERR,    CONN_EVENT_STOP,     conn_action_stop       },\n\t{ CONN_STATE_CONNERR,   CONN_EVENT_STOP,     conn_action_stop       },\n\n\t{ CONN_STATE_STOPPED,   CONN_EVENT_CONN_REQ, conn_action_connreject },\n        { CONN_STATE_STARTWAIT, CONN_EVENT_CONN_REQ, conn_action_connaccept },\n\t{ CONN_STATE_SETUPWAIT, CONN_EVENT_CONN_REQ, conn_action_connaccept },\n\t{ CONN_STATE_IDLE,      CONN_EVENT_CONN_REQ, conn_action_connreject },\n\t{ CONN_STATE_TX,        CONN_EVENT_CONN_REQ, conn_action_connreject },\n\n\t{ CONN_STATE_SETUPWAIT, CONN_EVENT_CONN_ACK, conn_action_connack    },\n\t{ CONN_STATE_SETUPWAIT, CONN_EVENT_TIMER,    conn_action_conntimsev },\n\n\t{ CONN_STATE_SETUPWAIT, CONN_EVENT_CONN_REJ, conn_action_connsever  },\n\t{ CONN_STATE_IDLE,      CONN_EVENT_CONN_REJ, conn_action_connsever  },\n\t{ CONN_STATE_TX,        CONN_EVENT_CONN_REJ, conn_action_connsever  },\n\n\t{ CONN_STATE_IDLE,      CONN_EVENT_RX,       conn_action_rx         },\n\t{ CONN_STATE_TX,        CONN_EVENT_RX,       conn_action_rx         },\n\n\t{ CONN_STATE_TX,        CONN_EVENT_TXDONE,   conn_action_txdone     },\n\t{ CONN_STATE_IDLE,      CONN_EVENT_TXDONE,   conn_action_txdone     },\n};\n\nstatic const int CONN_FSM_LEN = sizeof(conn_fsm) / sizeof(fsm_node);\n\n\n \n\n \nstatic void dev_action_start(fsm_instance *fi, int event, void *arg)\n{\n\tstruct net_device   *dev = arg;\n\tstruct netiucv_priv *privptr = netdev_priv(dev);\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tfsm_newstate(fi, DEV_STATE_STARTWAIT);\n\tfsm_event(privptr->conn->fsm, CONN_EVENT_START, privptr->conn);\n}\n\n \nstatic void\ndev_action_stop(fsm_instance *fi, int event, void *arg)\n{\n\tstruct net_device   *dev = arg;\n\tstruct netiucv_priv *privptr = netdev_priv(dev);\n\tstruct iucv_event   ev;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tev.conn = privptr->conn;\n\n\tfsm_newstate(fi, DEV_STATE_STOPWAIT);\n\tfsm_event(privptr->conn->fsm, CONN_EVENT_STOP, &ev);\n}\n\n \nstatic void\ndev_action_connup(fsm_instance *fi, int event, void *arg)\n{\n\tstruct net_device   *dev = arg;\n\tstruct netiucv_priv *privptr = netdev_priv(dev);\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tswitch (fsm_getstate(fi)) {\n\t\tcase DEV_STATE_STARTWAIT:\n\t\t\tfsm_newstate(fi, DEV_STATE_RUNNING);\n\t\t\tdev_info(privptr->dev,\n\t\t\t\t\"The IUCV device has been connected\"\n\t\t\t\t\" successfully to %s\\n\",\n\t\t\t\tnetiucv_printuser(privptr->conn));\n\t\t\tIUCV_DBF_TEXT(setup, 3,\n\t\t\t\t\"connection is up and running\\n\");\n\t\t\tbreak;\n\t\tcase DEV_STATE_STOPWAIT:\n\t\t\tIUCV_DBF_TEXT(data, 2,\n\t\t\t\t\"dev_action_connup: in DEV_STATE_STOPWAIT\\n\");\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void\ndev_action_conndown(fsm_instance *fi, int event, void *arg)\n{\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tswitch (fsm_getstate(fi)) {\n\t\tcase DEV_STATE_RUNNING:\n\t\t\tfsm_newstate(fi, DEV_STATE_STARTWAIT);\n\t\t\tbreak;\n\t\tcase DEV_STATE_STOPWAIT:\n\t\t\tfsm_newstate(fi, DEV_STATE_STOPPED);\n\t\t\tIUCV_DBF_TEXT(setup, 3, \"connection is down\\n\");\n\t\t\tbreak;\n\t}\n}\n\nstatic const fsm_node dev_fsm[] = {\n\t{ DEV_STATE_STOPPED,    DEV_EVENT_START,   dev_action_start    },\n\n\t{ DEV_STATE_STOPWAIT,   DEV_EVENT_START,   dev_action_start    },\n\t{ DEV_STATE_STOPWAIT,   DEV_EVENT_CONDOWN, dev_action_conndown },\n\n\t{ DEV_STATE_STARTWAIT,  DEV_EVENT_STOP,    dev_action_stop     },\n\t{ DEV_STATE_STARTWAIT,  DEV_EVENT_CONUP,   dev_action_connup   },\n\n\t{ DEV_STATE_RUNNING,    DEV_EVENT_STOP,    dev_action_stop     },\n\t{ DEV_STATE_RUNNING,    DEV_EVENT_CONDOWN, dev_action_conndown },\n\t{ DEV_STATE_RUNNING,    DEV_EVENT_CONUP,   netiucv_action_nop  },\n};\n\nstatic const int DEV_FSM_LEN = sizeof(dev_fsm) / sizeof(fsm_node);\n\n \nstatic int netiucv_transmit_skb(struct iucv_connection *conn,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct iucv_message msg;\n\tunsigned long saveflags;\n\tstruct ll_header header;\n\tint rc;\n\n\tif (fsm_getstate(conn->fsm) != CONN_STATE_IDLE) {\n\t\tint l = skb->len + NETIUCV_HDRLEN;\n\n\t\tspin_lock_irqsave(&conn->collect_lock, saveflags);\n\t\tif (conn->collect_len + l >\n\t\t    (conn->max_buffsize - NETIUCV_HDRLEN)) {\n\t\t\trc = -EBUSY;\n\t\t\tIUCV_DBF_TEXT(data, 2,\n\t\t\t\t      \"EBUSY from netiucv_transmit_skb\\n\");\n\t\t} else {\n\t\t\trefcount_inc(&skb->users);\n\t\t\tskb_queue_tail(&conn->collect_queue, skb);\n\t\t\tconn->collect_len += l;\n\t\t\trc = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&conn->collect_lock, saveflags);\n\t} else {\n\t\tstruct sk_buff *nskb = skb;\n\t\t \n\t\tunsigned long hi = ((unsigned long)(skb_tail_pointer(skb) +\n\t\t\t\t    NETIUCV_HDRLEN)) >> 31;\n\t\tint copied = 0;\n\t\tif (hi || (skb_tailroom(skb) < 2)) {\n\t\t\tnskb = alloc_skb(skb->len + NETIUCV_HDRLEN +\n\t\t\t\t\t NETIUCV_HDRLEN, GFP_ATOMIC | GFP_DMA);\n\t\t\tif (!nskb) {\n\t\t\t\tIUCV_DBF_TEXT(data, 2, \"alloc_skb failed\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\treturn rc;\n\t\t\t} else {\n\t\t\t\tskb_reserve(nskb, NETIUCV_HDRLEN);\n\t\t\t\tskb_put_data(nskb, skb->data, skb->len);\n\t\t\t}\n\t\t\tcopied = 1;\n\t\t}\n\t\t \n\t\theader.next = nskb->len + NETIUCV_HDRLEN;\n\t\tmemcpy(skb_push(nskb, NETIUCV_HDRLEN), &header, NETIUCV_HDRLEN);\n\t\theader.next = 0;\n\t\tskb_put_data(nskb, &header, NETIUCV_HDRLEN);\n\n\t\tfsm_newstate(conn->fsm, CONN_STATE_TX);\n\t\tconn->prof.send_stamp = jiffies;\n\n\t\tmsg.tag = 1;\n\t\tmsg.class = 0;\n\t\trc = iucv_message_send(conn->path, &msg, 0, 0,\n\t\t\t\t       nskb->data, nskb->len);\n\t\tconn->prof.doios_single++;\n\t\tconn->prof.txlen += skb->len;\n\t\tconn->prof.tx_pending++;\n\t\tif (conn->prof.tx_pending > conn->prof.tx_max_pending)\n\t\t\tconn->prof.tx_max_pending = conn->prof.tx_pending;\n\t\tif (rc) {\n\t\t\tstruct netiucv_priv *privptr;\n\t\t\tfsm_newstate(conn->fsm, CONN_STATE_IDLE);\n\t\t\tconn->prof.tx_pending--;\n\t\t\tprivptr = netdev_priv(conn->netdev);\n\t\t\tif (privptr)\n\t\t\t\tprivptr->stats.tx_errors++;\n\t\t\tif (copied)\n\t\t\t\tdev_kfree_skb(nskb);\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tskb_pull(skb, NETIUCV_HDRLEN);\n\t\t\t\tskb_trim(skb, skb->len - NETIUCV_HDRLEN);\n\t\t\t}\n\t\t\tIUCV_DBF_TEXT_(data, 2, \"rc %d from iucv_send\\n\", rc);\n\t\t} else {\n\t\t\tif (copied)\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\trefcount_inc(&nskb->users);\n\t\t\tskb_queue_tail(&conn->commit_queue, nskb);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \n\n \nstatic int netiucv_open(struct net_device *dev)\n{\n\tstruct netiucv_priv *priv = netdev_priv(dev);\n\n\tfsm_event(priv->fsm, DEV_EVENT_START, dev);\n\treturn 0;\n}\n\n \nstatic int netiucv_close(struct net_device *dev)\n{\n\tstruct netiucv_priv *priv = netdev_priv(dev);\n\n\tfsm_event(priv->fsm, DEV_EVENT_STOP, dev);\n\treturn 0;\n}\n\n \nstatic netdev_tx_t netiucv_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netiucv_priv *privptr = netdev_priv(dev);\n\tint rc;\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\t \n\tif (skb == NULL) {\n\t\tIUCV_DBF_TEXT(data, 2, \"netiucv_tx: skb is NULL\\n\");\n\t\tprivptr->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (skb_headroom(skb) < NETIUCV_HDRLEN) {\n\t\tIUCV_DBF_TEXT(data, 2,\n\t\t\t\"netiucv_tx: skb_headroom < NETIUCV_HDRLEN\\n\");\n\t\tdev_kfree_skb(skb);\n\t\tprivptr->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tif (fsm_getstate(privptr->fsm) != DEV_STATE_RUNNING) {\n\t\tdev_kfree_skb(skb);\n\t\tprivptr->stats.tx_dropped++;\n\t\tprivptr->stats.tx_errors++;\n\t\tprivptr->stats.tx_carrier_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (netiucv_test_and_set_busy(dev)) {\n\t\tIUCV_DBF_TEXT(data, 2, \"EBUSY from netiucv_tx\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\tnetif_trans_update(dev);\n\trc = netiucv_transmit_skb(privptr->conn, skb);\n\tnetiucv_clear_busy(dev);\n\treturn rc ? NETDEV_TX_BUSY : NETDEV_TX_OK;\n}\n\n \nstatic struct net_device_stats *netiucv_stats (struct net_device * dev)\n{\n\tstruct netiucv_priv *priv = netdev_priv(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn &priv->stats;\n}\n\n \n\nstatic ssize_t user_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%s\\n\", netiucv_printuser(priv->conn));\n}\n\nstatic int netiucv_check_user(const char *buf, size_t count, char *username,\n\t\t\t      char *userdata)\n{\n\tconst char *p;\n\tint i;\n\n\tp = strchr(buf, '.');\n\tif ((p && ((count > 26) ||\n\t\t   ((p - buf) > 8) ||\n\t\t   (buf + count - p > 18))) ||\n\t    (!p && (count > 9))) {\n\t\tIUCV_DBF_TEXT(setup, 2, \"conn_write: too long\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, p = buf; i < 8 && *p && *p != '.'; i++, p++) {\n\t\tif (isalnum(*p) || *p == '$') {\n\t\t\tusername[i] = toupper(*p);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '\\n')\n\t\t\t \n\t\t\tbreak;\n\t\tIUCV_DBF_TEXT_(setup, 2,\n\t\t\t       \"conn_write: invalid character %02x\\n\", *p);\n\t\treturn -EINVAL;\n\t}\n\twhile (i < 8)\n\t\tusername[i++] = ' ';\n\tusername[8] = '\\0';\n\n\tif (*p == '.') {\n\t\tp++;\n\t\tfor (i = 0; i < 16 && *p; i++, p++) {\n\t\t\tif (*p == '\\n')\n\t\t\t\tbreak;\n\t\t\tuserdata[i] = toupper(*p);\n\t\t}\n\t\twhile (i > 0 && i < 16)\n\t\t\tuserdata[i++] = ' ';\n\t} else\n\t\tmemcpy(userdata, iucvMagic_ascii, 16);\n\tuserdata[16] = '\\0';\n\tASCEBC(userdata, 16);\n\n\treturn 0;\n}\n\nstatic ssize_t user_write(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\tstruct net_device *ndev = priv->conn->netdev;\n\tchar\tusername[9];\n\tchar\tuserdata[17];\n\tint\trc;\n\tstruct iucv_connection *cp;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\trc = netiucv_check_user(buf, count, username, userdata);\n\tif (rc)\n\t\treturn rc;\n\n\tif (memcmp(username, priv->conn->userid, 9) &&\n\t    (ndev->flags & (IFF_UP | IFF_RUNNING))) {\n\t\t \n\t\tIUCV_DBF_TEXT(setup, 2, \"user_write: device active\\n\");\n\t\treturn -EPERM;\n\t}\n\tread_lock_bh(&iucv_connection_rwlock);\n\tlist_for_each_entry(cp, &iucv_connection_list, list) {\n\t\tif (!strncmp(username, cp->userid, 9) &&\n\t\t   !strncmp(userdata, cp->userdata, 17) && cp->netdev != ndev) {\n\t\t\tread_unlock_bh(&iucv_connection_rwlock);\n\t\t\tIUCV_DBF_TEXT_(setup, 2, \"user_write: Connection to %s \"\n\t\t\t\t\"already exists\\n\", netiucv_printuser(cp));\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tread_unlock_bh(&iucv_connection_rwlock);\n\tmemcpy(priv->conn->userid, username, 9);\n\tmemcpy(priv->conn->userdata, userdata, 17);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(user, 0644, user_show, user_write);\n\nstatic ssize_t buffer_show (struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%d\\n\", priv->conn->max_buffsize);\n}\n\nstatic ssize_t buffer_write (struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\tstruct net_device *ndev = priv->conn->netdev;\n\tunsigned int bs1;\n\tint rc;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\tif (count >= 39)\n\t\treturn -EINVAL;\n\n\trc = kstrtouint(buf, 0, &bs1);\n\n\tif (rc == -EINVAL) {\n\t\tIUCV_DBF_TEXT_(setup, 2, \"buffer_write: invalid char %s\\n\",\n\t\t\tbuf);\n\t\treturn -EINVAL;\n\t}\n\tif ((rc == -ERANGE) || (bs1 > NETIUCV_BUFSIZE_MAX)) {\n\t\tIUCV_DBF_TEXT_(setup, 2,\n\t\t\t\"buffer_write: buffer size %d too large\\n\",\n\t\t\tbs1);\n\t\treturn -EINVAL;\n\t}\n\tif ((ndev->flags & IFF_RUNNING) &&\n\t    (bs1 < (ndev->mtu + NETIUCV_HDRLEN + 2))) {\n\t\tIUCV_DBF_TEXT_(setup, 2,\n\t\t\t\"buffer_write: buffer size %d too small\\n\",\n\t\t\tbs1);\n\t\treturn -EINVAL;\n\t}\n\tif (bs1 < (576 + NETIUCV_HDRLEN + NETIUCV_HDRLEN)) {\n\t\tIUCV_DBF_TEXT_(setup, 2,\n\t\t\t\"buffer_write: buffer size %d too small\\n\",\n\t\t\tbs1);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->conn->max_buffsize = bs1;\n\tif (!(ndev->flags & IFF_RUNNING))\n\t\tndev->mtu = bs1 - NETIUCV_HDRLEN - NETIUCV_HDRLEN;\n\n\treturn count;\n\n}\n\nstatic DEVICE_ATTR(buffer, 0644, buffer_show, buffer_write);\n\nstatic ssize_t dev_fsm_show (struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%s\\n\", fsm_getstate_str(priv->fsm));\n}\n\nstatic DEVICE_ATTR(device_fsm_state, 0444, dev_fsm_show, NULL);\n\nstatic ssize_t conn_fsm_show (struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%s\\n\", fsm_getstate_str(priv->conn->fsm));\n}\n\nstatic DEVICE_ATTR(connection_fsm_state, 0444, conn_fsm_show, NULL);\n\nstatic ssize_t maxmulti_show (struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%ld\\n\", priv->conn->prof.maxmulti);\n}\n\nstatic ssize_t maxmulti_write (struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\tpriv->conn->prof.maxmulti = 0;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(max_tx_buffer_used, 0644, maxmulti_show, maxmulti_write);\n\nstatic ssize_t maxcq_show (struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%ld\\n\", priv->conn->prof.maxcqueue);\n}\n\nstatic ssize_t maxcq_write (struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\tpriv->conn->prof.maxcqueue = 0;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(max_chained_skbs, 0644, maxcq_show, maxcq_write);\n\nstatic ssize_t sdoio_show (struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%ld\\n\", priv->conn->prof.doios_single);\n}\n\nstatic ssize_t sdoio_write (struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\tpriv->conn->prof.doios_single = 0;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(tx_single_write_ops, 0644, sdoio_show, sdoio_write);\n\nstatic ssize_t mdoio_show (struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%ld\\n\", priv->conn->prof.doios_multi);\n}\n\nstatic ssize_t mdoio_write (struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\tpriv->conn->prof.doios_multi = 0;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(tx_multi_write_ops, 0644, mdoio_show, mdoio_write);\n\nstatic ssize_t txlen_show (struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%ld\\n\", priv->conn->prof.txlen);\n}\n\nstatic ssize_t txlen_write (struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\tpriv->conn->prof.txlen = 0;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(netto_bytes, 0644, txlen_show, txlen_write);\n\nstatic ssize_t txtime_show (struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%ld\\n\", priv->conn->prof.tx_time);\n}\n\nstatic ssize_t txtime_write (struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\tpriv->conn->prof.tx_time = 0;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(max_tx_io_time, 0644, txtime_show, txtime_write);\n\nstatic ssize_t txpend_show (struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%ld\\n\", priv->conn->prof.tx_pending);\n}\n\nstatic ssize_t txpend_write (struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\tpriv->conn->prof.tx_pending = 0;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(tx_pending, 0644, txpend_show, txpend_write);\n\nstatic ssize_t txmpnd_show (struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 5, __func__);\n\treturn sprintf(buf, \"%ld\\n\", priv->conn->prof.tx_max_pending);\n}\n\nstatic ssize_t txmpnd_write (struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct netiucv_priv *priv = dev_get_drvdata(dev);\n\n\tIUCV_DBF_TEXT(trace, 4, __func__);\n\tpriv->conn->prof.tx_max_pending = 0;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(tx_max_pending, 0644, txmpnd_show, txmpnd_write);\n\nstatic struct attribute *netiucv_attrs[] = {\n\t&dev_attr_buffer.attr,\n\t&dev_attr_user.attr,\n\tNULL,\n};\n\nstatic struct attribute_group netiucv_attr_group = {\n\t.attrs = netiucv_attrs,\n};\n\nstatic struct attribute *netiucv_stat_attrs[] = {\n\t&dev_attr_device_fsm_state.attr,\n\t&dev_attr_connection_fsm_state.attr,\n\t&dev_attr_max_tx_buffer_used.attr,\n\t&dev_attr_max_chained_skbs.attr,\n\t&dev_attr_tx_single_write_ops.attr,\n\t&dev_attr_tx_multi_write_ops.attr,\n\t&dev_attr_netto_bytes.attr,\n\t&dev_attr_max_tx_io_time.attr,\n\t&dev_attr_tx_pending.attr,\n\t&dev_attr_tx_max_pending.attr,\n\tNULL,\n};\n\nstatic struct attribute_group netiucv_stat_attr_group = {\n\t.name  = \"stats\",\n\t.attrs = netiucv_stat_attrs,\n};\n\nstatic const struct attribute_group *netiucv_attr_groups[] = {\n\t&netiucv_stat_attr_group,\n\t&netiucv_attr_group,\n\tNULL,\n};\n\nstatic int netiucv_register_device(struct net_device *ndev)\n{\n\tstruct netiucv_priv *priv = netdev_priv(ndev);\n\tstruct device *dev = kzalloc(sizeof(struct device), GFP_KERNEL);\n\tint ret;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tif (dev) {\n\t\tdev_set_name(dev, \"net%s\", ndev->name);\n\t\tdev->bus = &iucv_bus;\n\t\tdev->parent = iucv_root;\n\t\tdev->groups = netiucv_attr_groups;\n\t\t \n\t\tdev->release = (void (*)(struct device *))kfree;\n\t\tdev->driver = &netiucv_driver;\n\t} else\n\t\treturn -ENOMEM;\n\n\tret = device_register(dev);\n\tif (ret) {\n\t\tput_device(dev);\n\t\treturn ret;\n\t}\n\tpriv->dev = dev;\n\tdev_set_drvdata(dev, priv);\n\treturn 0;\n}\n\nstatic void netiucv_unregister_device(struct device *dev)\n{\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\tdevice_unregister(dev);\n}\n\n \nstatic struct iucv_connection *netiucv_new_connection(struct net_device *dev,\n\t\t\t\t\t\t      char *username,\n\t\t\t\t\t\t      char *userdata)\n{\n\tstruct iucv_connection *conn;\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn)\n\t\tgoto out;\n\tskb_queue_head_init(&conn->collect_queue);\n\tskb_queue_head_init(&conn->commit_queue);\n\tspin_lock_init(&conn->collect_lock);\n\tconn->max_buffsize = NETIUCV_BUFSIZE_DEFAULT;\n\tconn->netdev = dev;\n\n\tconn->rx_buff = alloc_skb(conn->max_buffsize, GFP_KERNEL | GFP_DMA);\n\tif (!conn->rx_buff)\n\t\tgoto out_conn;\n\tconn->tx_buff = alloc_skb(conn->max_buffsize, GFP_KERNEL | GFP_DMA);\n\tif (!conn->tx_buff)\n\t\tgoto out_rx;\n\tconn->fsm = init_fsm(\"netiucvconn\", conn_state_names,\n\t\t\t     conn_event_names, NR_CONN_STATES,\n\t\t\t     NR_CONN_EVENTS, conn_fsm, CONN_FSM_LEN,\n\t\t\t     GFP_KERNEL);\n\tif (!conn->fsm)\n\t\tgoto out_tx;\n\n\tfsm_settimer(conn->fsm, &conn->timer);\n\tfsm_newstate(conn->fsm, CONN_STATE_INVALID);\n\n\tif (userdata)\n\t\tmemcpy(conn->userdata, userdata, 17);\n\tif (username) {\n\t\tmemcpy(conn->userid, username, 9);\n\t\tfsm_newstate(conn->fsm, CONN_STATE_STOPPED);\n\t}\n\n\twrite_lock_bh(&iucv_connection_rwlock);\n\tlist_add_tail(&conn->list, &iucv_connection_list);\n\twrite_unlock_bh(&iucv_connection_rwlock);\n\treturn conn;\n\nout_tx:\n\tkfree_skb(conn->tx_buff);\nout_rx:\n\tkfree_skb(conn->rx_buff);\nout_conn:\n\tkfree(conn);\nout:\n\treturn NULL;\n}\n\n \nstatic void netiucv_remove_connection(struct iucv_connection *conn)\n{\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\twrite_lock_bh(&iucv_connection_rwlock);\n\tlist_del_init(&conn->list);\n\twrite_unlock_bh(&iucv_connection_rwlock);\n\tfsm_deltimer(&conn->timer);\n\tnetiucv_purge_skb_queue(&conn->collect_queue);\n\tif (conn->path) {\n\t\tiucv_path_sever(conn->path, conn->userdata);\n\t\tkfree(conn->path);\n\t\tconn->path = NULL;\n\t}\n\tnetiucv_purge_skb_queue(&conn->commit_queue);\n\tkfree_fsm(conn->fsm);\n\tkfree_skb(conn->rx_buff);\n\tkfree_skb(conn->tx_buff);\n}\n\n \nstatic void netiucv_free_netdevice(struct net_device *dev)\n{\n\tstruct netiucv_priv *privptr = netdev_priv(dev);\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n\tif (!dev)\n\t\treturn;\n\n\tif (privptr) {\n\t\tif (privptr->conn)\n\t\t\tnetiucv_remove_connection(privptr->conn);\n\t\tif (privptr->fsm)\n\t\t\tkfree_fsm(privptr->fsm);\n\t\tprivptr->conn = NULL; privptr->fsm = NULL;\n\t\t \n\t}\n}\n\n \nstatic const struct net_device_ops netiucv_netdev_ops = {\n\t.ndo_open\t\t= netiucv_open,\n\t.ndo_stop\t\t= netiucv_close,\n\t.ndo_get_stats\t\t= netiucv_stats,\n\t.ndo_start_xmit\t\t= netiucv_tx,\n};\n\nstatic void netiucv_setup_netdevice(struct net_device *dev)\n{\n\tdev->mtu\t         = NETIUCV_MTU_DEFAULT;\n\tdev->min_mtu\t\t = 576;\n\tdev->max_mtu\t\t = NETIUCV_MTU_MAX;\n\tdev->needs_free_netdev   = true;\n\tdev->priv_destructor     = netiucv_free_netdevice;\n\tdev->hard_header_len     = NETIUCV_HDRLEN;\n\tdev->addr_len            = 0;\n\tdev->type                = ARPHRD_SLIP;\n\tdev->tx_queue_len        = NETIUCV_QUEUELEN_DEFAULT;\n\tdev->flags\t         = IFF_POINTOPOINT | IFF_NOARP;\n\tdev->netdev_ops\t\t = &netiucv_netdev_ops;\n}\n\n \nstatic struct net_device *netiucv_init_netdevice(char *username, char *userdata)\n{\n\tstruct netiucv_priv *privptr;\n\tstruct net_device *dev;\n\n\tdev = alloc_netdev(sizeof(struct netiucv_priv), \"iucv%d\",\n\t\t\t   NET_NAME_UNKNOWN, netiucv_setup_netdevice);\n\tif (!dev)\n\t\treturn NULL;\n\trtnl_lock();\n\tif (dev_alloc_name(dev, dev->name) < 0)\n\t\tgoto out_netdev;\n\n\tprivptr = netdev_priv(dev);\n\tprivptr->fsm = init_fsm(\"netiucvdev\", dev_state_names,\n\t\t\t\tdev_event_names, NR_DEV_STATES, NR_DEV_EVENTS,\n\t\t\t\tdev_fsm, DEV_FSM_LEN, GFP_KERNEL);\n\tif (!privptr->fsm)\n\t\tgoto out_netdev;\n\n\tprivptr->conn = netiucv_new_connection(dev, username, userdata);\n\tif (!privptr->conn) {\n\t\tIUCV_DBF_TEXT(setup, 2, \"NULL from netiucv_new_connection\\n\");\n\t\tgoto out_fsm;\n\t}\n\tfsm_newstate(privptr->fsm, DEV_STATE_STOPPED);\n\treturn dev;\n\nout_fsm:\n\tkfree_fsm(privptr->fsm);\nout_netdev:\n\trtnl_unlock();\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstatic ssize_t connection_store(struct device_driver *drv, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tchar username[9];\n\tchar userdata[17];\n\tint rc;\n\tstruct net_device *dev;\n\tstruct netiucv_priv *priv;\n\tstruct iucv_connection *cp;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\trc = netiucv_check_user(buf, count, username, userdata);\n\tif (rc)\n\t\treturn rc;\n\n\tread_lock_bh(&iucv_connection_rwlock);\n\tlist_for_each_entry(cp, &iucv_connection_list, list) {\n\t\tif (!strncmp(username, cp->userid, 9) &&\n\t\t    !strncmp(userdata, cp->userdata, 17)) {\n\t\t\tread_unlock_bh(&iucv_connection_rwlock);\n\t\t\tIUCV_DBF_TEXT_(setup, 2, \"conn_write: Connection to %s \"\n\t\t\t\t\"already exists\\n\", netiucv_printuser(cp));\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tread_unlock_bh(&iucv_connection_rwlock);\n\n\tdev = netiucv_init_netdevice(username, userdata);\n\tif (!dev) {\n\t\tIUCV_DBF_TEXT(setup, 2, \"NULL from netiucv_init_netdevice\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = netiucv_register_device(dev);\n\tif (rc) {\n\t\trtnl_unlock();\n\t\tIUCV_DBF_TEXT_(setup, 2,\n\t\t\t\"ret %d from netiucv_register_device\\n\", rc);\n\t\tgoto out_free_ndev;\n\t}\n\n\t \n\tpriv = netdev_priv(dev);\n\tSET_NETDEV_DEV(dev, priv->dev);\n\n\trc = register_netdevice(dev);\n\trtnl_unlock();\n\tif (rc)\n\t\tgoto out_unreg;\n\n\tdev_info(priv->dev, \"The IUCV interface to %s has been established \"\n\t\t\t    \"successfully\\n\",\n\t\tnetiucv_printuser(priv->conn));\n\n\treturn count;\n\nout_unreg:\n\tnetiucv_unregister_device(priv->dev);\nout_free_ndev:\n\tnetiucv_free_netdevice(dev);\n\treturn rc;\n}\nstatic DRIVER_ATTR_WO(connection);\n\nstatic ssize_t remove_store(struct device_driver *drv, const char *buf,\n\t\t\t    size_t count)\n{\n\tstruct iucv_connection *cp;\n        struct net_device *ndev;\n        struct netiucv_priv *priv;\n        struct device *dev;\n        char name[IFNAMSIZ];\n\tconst char *p;\n        int i;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\n        if (count >= IFNAMSIZ)\n                count = IFNAMSIZ - 1;\n\n\tfor (i = 0, p = buf; i < count && *p; i++, p++) {\n\t\tif (*p == '\\n' || *p == ' ')\n                         \n                        break;\n\t\tname[i] = *p;\n        }\n        name[i] = '\\0';\n\n\tread_lock_bh(&iucv_connection_rwlock);\n\tlist_for_each_entry(cp, &iucv_connection_list, list) {\n\t\tndev = cp->netdev;\n\t\tpriv = netdev_priv(ndev);\n                dev = priv->dev;\n\t\tif (strncmp(name, ndev->name, count))\n\t\t\tcontinue;\n\t\tread_unlock_bh(&iucv_connection_rwlock);\n                if (ndev->flags & (IFF_UP | IFF_RUNNING)) {\n\t\t\tdev_warn(dev, \"The IUCV device is connected\"\n\t\t\t\t\" to %s and cannot be removed\\n\",\n\t\t\t\tpriv->conn->userid);\n\t\t\tIUCV_DBF_TEXT(data, 2, \"remove_write: still active\\n\");\n\t\t\treturn -EPERM;\n                }\n                unregister_netdev(ndev);\n                netiucv_unregister_device(dev);\n                return count;\n        }\n\tread_unlock_bh(&iucv_connection_rwlock);\n\tIUCV_DBF_TEXT(data, 2, \"remove_write: unknown device\\n\");\n        return -EINVAL;\n}\nstatic DRIVER_ATTR_WO(remove);\n\nstatic struct attribute * netiucv_drv_attrs[] = {\n\t&driver_attr_connection.attr,\n\t&driver_attr_remove.attr,\n\tNULL,\n};\n\nstatic struct attribute_group netiucv_drv_attr_group = {\n\t.attrs = netiucv_drv_attrs,\n};\n\nstatic const struct attribute_group *netiucv_drv_attr_groups[] = {\n\t&netiucv_drv_attr_group,\n\tNULL,\n};\n\nstatic void netiucv_banner(void)\n{\n\tpr_info(\"driver initialized\\n\");\n}\n\nstatic void __exit netiucv_exit(void)\n{\n\tstruct iucv_connection *cp;\n\tstruct net_device *ndev;\n\tstruct netiucv_priv *priv;\n\tstruct device *dev;\n\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\twhile (!list_empty(&iucv_connection_list)) {\n\t\tcp = list_entry(iucv_connection_list.next,\n\t\t\t\tstruct iucv_connection, list);\n\t\tndev = cp->netdev;\n\t\tpriv = netdev_priv(ndev);\n\t\tdev = priv->dev;\n\n\t\tunregister_netdev(ndev);\n\t\tnetiucv_unregister_device(dev);\n\t}\n\n\tdriver_unregister(&netiucv_driver);\n\tiucv_unregister(&netiucv_handler, 1);\n\tiucv_unregister_dbf_views();\n\n\tpr_info(\"driver unloaded\\n\");\n\treturn;\n}\n\nstatic int __init netiucv_init(void)\n{\n\tint rc;\n\n\trc = iucv_register_dbf_views();\n\tif (rc)\n\t\tgoto out;\n\trc = iucv_register(&netiucv_handler, 1);\n\tif (rc)\n\t\tgoto out_dbf;\n\tIUCV_DBF_TEXT(trace, 3, __func__);\n\tnetiucv_driver.groups = netiucv_drv_attr_groups;\n\trc = driver_register(&netiucv_driver);\n\tif (rc) {\n\t\tIUCV_DBF_TEXT_(setup, 2, \"ret %d from driver_register\\n\", rc);\n\t\tgoto out_iucv;\n\t}\n\n\tnetiucv_banner();\n\treturn rc;\n\nout_iucv:\n\tiucv_unregister(&netiucv_handler, 1);\nout_dbf:\n\tiucv_unregister_dbf_views();\nout:\n\treturn rc;\n}\n\nmodule_init(netiucv_init);\nmodule_exit(netiucv_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}