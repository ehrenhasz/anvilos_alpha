{
  "module_name": "qeth_core_main.c",
  "hash_id": "fd859602c700538080e8c94af0dd7dab3b8d06d10e3206c5781a231ec672a148",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/qeth_core_main.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"qeth\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/io.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/mii.h>\n#include <linux/mm.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/if_vlan.h>\n#include <linux/netdevice.h>\n#include <linux/netdev_features.h>\n#include <linux/rcutree.h>\n#include <linux/skbuff.h>\n#include <linux/vmalloc.h>\n\n#include <net/iucv/af_iucv.h>\n#include <net/dsfield.h>\n#include <net/sock.h>\n\n#include <asm/ebcdic.h>\n#include <asm/chpid.h>\n#include <asm/sysinfo.h>\n#include <asm/diag.h>\n#include <asm/cio.h>\n#include <asm/ccwdev.h>\n#include <asm/cpcmd.h>\n\n#include \"qeth_core.h\"\n\nstruct qeth_dbf_info qeth_dbf[QETH_DBF_INFOS] = {\n\t \n\t \n\t[QETH_DBF_SETUP] = {\"qeth_setup\",\n\t\t\t\t8, 1,   8, 5, &debug_hex_ascii_view, NULL},\n\t[QETH_DBF_MSG]\t = {\"qeth_msg\", 8, 1, 11 * sizeof(long), 3,\n\t\t\t    &debug_sprintf_view, NULL},\n\t[QETH_DBF_CTRL]  = {\"qeth_control\",\n\t\t8, 1, QETH_DBF_CTRL_LEN, 5, &debug_hex_ascii_view, NULL},\n};\nEXPORT_SYMBOL_GPL(qeth_dbf);\n\nstatic struct kmem_cache *qeth_core_header_cache;\nstatic struct kmem_cache *qeth_qdio_outbuf_cache;\nstatic struct kmem_cache *qeth_qaob_cache;\n\nstatic struct device *qeth_core_root_dev;\nstatic struct dentry *qeth_debugfs_root;\nstatic struct lock_class_key qdio_out_skb_queue_key;\n\nstatic void qeth_issue_next_read_cb(struct qeth_card *card,\n\t\t\t\t    struct qeth_cmd_buffer *iob,\n\t\t\t\t    unsigned int data_length);\nstatic int qeth_qdio_establish(struct qeth_card *);\nstatic void qeth_free_qdio_queues(struct qeth_card *card);\n\nstatic const char *qeth_get_cardname(struct qeth_card *card)\n{\n\tif (IS_VM_NIC(card)) {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \" Virtual NIC QDIO\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \" Virtual NIC Hiper\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \" Virtual NIC QDIO - OSM\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \" Virtual NIC QDIO - OSX\";\n\t\tdefault:\n\t\t\treturn \" unknown\";\n\t\t}\n\t} else {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \" OSD Express\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \" HiperSockets\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \" OSM QDIO\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \" OSX QDIO\";\n\t\tdefault:\n\t\t\treturn \" unknown\";\n\t\t}\n\t}\n\treturn \" n/a\";\n}\n\n \nconst char *qeth_get_cardname_short(struct qeth_card *card)\n{\n\tif (IS_VM_NIC(card)) {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\treturn \"Virt.NIC QDIO\";\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \"Virt.NIC Hiper\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \"Virt.NIC OSM\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \"Virt.NIC OSX\";\n\t\tdefault:\n\t\t\treturn \"unknown\";\n\t\t}\n\t} else {\n\t\tswitch (card->info.type) {\n\t\tcase QETH_CARD_TYPE_OSD:\n\t\t\tswitch (card->info.link_type) {\n\t\t\tcase QETH_LINK_TYPE_FAST_ETH:\n\t\t\t\treturn \"OSD_100\";\n\t\t\tcase QETH_LINK_TYPE_HSTR:\n\t\t\t\treturn \"HSTR\";\n\t\t\tcase QETH_LINK_TYPE_GBIT_ETH:\n\t\t\t\treturn \"OSD_1000\";\n\t\t\tcase QETH_LINK_TYPE_10GBIT_ETH:\n\t\t\t\treturn \"OSD_10GIG\";\n\t\t\tcase QETH_LINK_TYPE_25GBIT_ETH:\n\t\t\t\treturn \"OSD_25GIG\";\n\t\t\tcase QETH_LINK_TYPE_LANE_ETH100:\n\t\t\t\treturn \"OSD_FE_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE_TR:\n\t\t\t\treturn \"OSD_TR_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE_ETH1000:\n\t\t\t\treturn \"OSD_GbE_LANE\";\n\t\t\tcase QETH_LINK_TYPE_LANE:\n\t\t\t\treturn \"OSD_ATM_LANE\";\n\t\t\tdefault:\n\t\t\t\treturn \"OSD_Express\";\n\t\t\t}\n\t\tcase QETH_CARD_TYPE_IQD:\n\t\t\treturn \"HiperSockets\";\n\t\tcase QETH_CARD_TYPE_OSM:\n\t\t\treturn \"OSM_1000\";\n\t\tcase QETH_CARD_TYPE_OSX:\n\t\t\treturn \"OSX_10GIG\";\n\t\tdefault:\n\t\t\treturn \"unknown\";\n\t\t}\n\t}\n\treturn \"n/a\";\n}\n\nvoid qeth_set_allowed_threads(struct qeth_card *card, unsigned long threads,\n\t\t\t int clear_start_mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_allowed_mask = threads;\n\tif (clear_start_mask)\n\t\tcard->thread_start_mask &= threads;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\nEXPORT_SYMBOL_GPL(qeth_set_allowed_threads);\n\nint qeth_threads_running(struct qeth_card *card, unsigned long threads)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\trc = (card->thread_running_mask & threads);\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_threads_running);\n\nstatic void qeth_clear_working_pool_list(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry, *tmp;\n\tstruct qeth_qdio_q *queue = card->qdio.in_q;\n\tunsigned int i;\n\n\tQETH_CARD_TEXT(card, 5, \"clwrklst\");\n\tlist_for_each_entry_safe(pool_entry, tmp,\n\t\t\t\t &card->qdio.in_buf_pool.entry_list, list)\n\t\tlist_del(&pool_entry->list);\n\n\tfor (i = 0; i < ARRAY_SIZE(queue->bufs); i++)\n\t\tqueue->bufs[i].pool_entry = NULL;\n}\n\nstatic void qeth_free_pool_entry(struct qeth_buffer_pool_entry *entry)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(entry->elements); i++) {\n\t\tif (entry->elements[i])\n\t\t\t__free_page(entry->elements[i]);\n\t}\n\n\tkfree(entry);\n}\n\nstatic void qeth_free_buffer_pool(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &card->qdio.init_pool.entry_list,\n\t\t\t\t init_list) {\n\t\tlist_del(&entry->init_list);\n\t\tqeth_free_pool_entry(entry);\n\t}\n}\n\nstatic struct qeth_buffer_pool_entry *qeth_alloc_pool_entry(unsigned int pages)\n{\n\tstruct qeth_buffer_pool_entry *entry;\n\tunsigned int i;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++) {\n\t\tentry->elements[i] = __dev_alloc_page(GFP_KERNEL);\n\n\t\tif (!entry->elements[i]) {\n\t\t\tqeth_free_pool_entry(entry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn entry;\n}\n\nstatic int qeth_alloc_buffer_pool(struct qeth_card *card)\n{\n\tunsigned int buf_elements = QETH_MAX_BUFFER_ELEMENTS(card);\n\tunsigned int i;\n\n\tQETH_CARD_TEXT(card, 5, \"alocpool\");\n\tfor (i = 0; i < card->qdio.init_pool.buf_count; ++i) {\n\t\tstruct qeth_buffer_pool_entry *entry;\n\n\t\tentry = qeth_alloc_pool_entry(buf_elements);\n\t\tif (!entry) {\n\t\t\tqeth_free_buffer_pool(card);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tlist_add(&entry->init_list, &card->qdio.init_pool.entry_list);\n\t}\n\treturn 0;\n}\n\nint qeth_resize_buffer_pool(struct qeth_card *card, unsigned int count)\n{\n\tunsigned int buf_elements = QETH_MAX_BUFFER_ELEMENTS(card);\n\tstruct qeth_qdio_buffer_pool *pool = &card->qdio.init_pool;\n\tstruct qeth_buffer_pool_entry *entry, *tmp;\n\tint delta = count - pool->buf_count;\n\tLIST_HEAD(entries);\n\n\tQETH_CARD_TEXT(card, 2, \"realcbp\");\n\n\t \n\tif (list_empty(&pool->entry_list))\n\t\tgoto out;\n\n\t \n\twhile (delta < 0) {\n\t\tentry = list_first_entry(&pool->entry_list,\n\t\t\t\t\t struct qeth_buffer_pool_entry,\n\t\t\t\t\t init_list);\n\t\tlist_del(&entry->init_list);\n\t\tqeth_free_pool_entry(entry);\n\n\t\tdelta++;\n\t}\n\n\t \n\twhile (delta > 0) {\n\t\tentry = qeth_alloc_pool_entry(buf_elements);\n\t\tif (!entry) {\n\t\t\tlist_for_each_entry_safe(entry, tmp, &entries,\n\t\t\t\t\t\t init_list) {\n\t\t\t\tlist_del(&entry->init_list);\n\t\t\t\tqeth_free_pool_entry(entry);\n\t\t\t}\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tlist_add(&entry->init_list, &entries);\n\n\t\tdelta--;\n\t}\n\n\tlist_splice(&entries, &pool->entry_list);\n\nout:\n\tcard->qdio.in_buf_pool.buf_count = count;\n\tpool->buf_count = count;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_resize_buffer_pool);\n\nstatic void qeth_free_qdio_queue(struct qeth_qdio_q *q)\n{\n\tif (!q)\n\t\treturn;\n\n\tqdio_free_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q);\n\tkfree(q);\n}\n\nstatic struct qeth_qdio_q *qeth_alloc_qdio_queue(void)\n{\n\tstruct qeth_qdio_q *q = kzalloc(sizeof(*q), GFP_KERNEL);\n\tint i;\n\n\tif (!q)\n\t\treturn NULL;\n\n\tif (qdio_alloc_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q)) {\n\t\tkfree(q);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i)\n\t\tq->bufs[i].buffer = q->qdio_bufs[i];\n\n\tQETH_DBF_HEX(SETUP, 2, &q, sizeof(void *));\n\treturn q;\n}\n\nstatic int qeth_cq_init(struct qeth_card *card)\n{\n\tint rc;\n\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tQETH_CARD_TEXT(card, 2, \"cqinit\");\n\t\tqdio_reset_buffers(card->qdio.c_q->qdio_bufs,\n\t\t\t\t   QDIO_MAX_BUFFERS_PER_Q);\n\t\tcard->qdio.c_q->next_buf_to_init = 127;\n\n\t\trc = qdio_add_bufs_to_input_queue(CARD_DDEV(card), 1, 0, 127);\n\t\tif (rc) {\n\t\t\tQETH_CARD_TEXT_(card, 2, \"1err%d\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic int qeth_alloc_cq(struct qeth_card *card)\n{\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tQETH_CARD_TEXT(card, 2, \"cqon\");\n\t\tcard->qdio.c_q = qeth_alloc_qdio_queue();\n\t\tif (!card->qdio.c_q) {\n\t\t\tdev_err(&card->gdev->dev, \"Failed to create completion queue\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tQETH_CARD_TEXT(card, 2, \"nocq\");\n\t\tcard->qdio.c_q = NULL;\n\t}\n\treturn 0;\n}\n\nstatic void qeth_free_cq(struct qeth_card *card)\n{\n\tif (card->qdio.c_q) {\n\t\tqeth_free_qdio_queue(card->qdio.c_q);\n\t\tcard->qdio.c_q = NULL;\n\t}\n}\n\nstatic enum iucv_tx_notify qeth_compute_cq_notification(int sbalf15,\n\t\t\t\t\t\t\tint delayed)\n{\n\tenum iucv_tx_notify n;\n\n\tswitch (sbalf15) {\n\tcase 0:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_OK : TX_NOTIFY_OK;\n\t\tbreak;\n\tcase 4:\n\tcase 16:\n\tcase 17:\n\tcase 18:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_UNREACHABLE :\n\t\t\tTX_NOTIFY_UNREACHABLE;\n\t\tbreak;\n\tdefault:\n\t\tn = delayed ? TX_NOTIFY_DELAYED_GENERALERROR :\n\t\t\tTX_NOTIFY_GENERALERROR;\n\t\tbreak;\n\t}\n\n\treturn n;\n}\n\nstatic void qeth_put_cmd(struct qeth_cmd_buffer *iob)\n{\n\tif (refcount_dec_and_test(&iob->ref_count)) {\n\t\tkfree(iob->data);\n\t\tkfree(iob);\n\t}\n}\nstatic void qeth_setup_ccw(struct ccw1 *ccw, u8 cmd_code, u8 flags, u32 len,\n\t\t\t   void *data)\n{\n\tccw->cmd_code = cmd_code;\n\tccw->flags = flags | CCW_FLAG_SLI;\n\tccw->count = len;\n\tccw->cda = (__u32)virt_to_phys(data);\n}\n\nstatic int __qeth_issue_next_read(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob = card->read_cmd;\n\tstruct qeth_channel *channel = iob->channel;\n\tstruct ccw1 *ccw = __ccw_from_cmd(iob);\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 5, \"issnxrd\");\n\tif (channel->state != CH_STATE_UP)\n\t\treturn -EIO;\n\n\tmemset(iob->data, 0, iob->length);\n\tqeth_setup_ccw(ccw, CCW_CMD_READ, 0, iob->length, iob->data);\n\tiob->callback = qeth_issue_next_read_cb;\n\t \n\tqeth_get_cmd(iob);\n\n\tQETH_CARD_TEXT(card, 6, \"noirqpnd\");\n\trc = ccw_device_start(channel->ccwdev, ccw, (addr_t) iob, 0, 0);\n\tif (!rc) {\n\t\tchannel->active_cmd = iob;\n\t} else {\n\t\tQETH_DBF_MESSAGE(2, \"error %i on device %x when starting next read ccw!\\n\",\n\t\t\t\t rc, CARD_DEVID(card));\n\t\tqeth_unlock_channel(card, channel);\n\t\tqeth_put_cmd(iob);\n\t\tcard->read_or_write_problem = 1;\n\t\tqeth_schedule_recovery(card);\n\t}\n\treturn rc;\n}\n\nstatic int qeth_issue_next_read(struct qeth_card *card)\n{\n\tint ret;\n\n\tspin_lock_irq(get_ccwdev_lock(CARD_RDEV(card)));\n\tret = __qeth_issue_next_read(card);\n\tspin_unlock_irq(get_ccwdev_lock(CARD_RDEV(card)));\n\n\treturn ret;\n}\n\nstatic void qeth_enqueue_cmd(struct qeth_card *card,\n\t\t\t     struct qeth_cmd_buffer *iob)\n{\n\tspin_lock_irq(&card->lock);\n\tlist_add_tail(&iob->list_entry, &card->cmd_waiter_list);\n\tspin_unlock_irq(&card->lock);\n}\n\nstatic void qeth_dequeue_cmd(struct qeth_card *card,\n\t\t\t     struct qeth_cmd_buffer *iob)\n{\n\tspin_lock_irq(&card->lock);\n\tlist_del(&iob->list_entry);\n\tspin_unlock_irq(&card->lock);\n}\n\nstatic void qeth_notify_cmd(struct qeth_cmd_buffer *iob, int reason)\n{\n\tiob->rc = reason;\n\tcomplete(&iob->done);\n}\n\nstatic void qeth_flush_local_addrs4(struct qeth_card *card)\n{\n\tstruct qeth_local_addr *addr;\n\tstruct hlist_node *tmp;\n\tunsigned int i;\n\n\tspin_lock_irq(&card->local_addrs4_lock);\n\thash_for_each_safe(card->local_addrs4, i, tmp, addr, hnode) {\n\t\thash_del_rcu(&addr->hnode);\n\t\tkfree_rcu(addr, rcu);\n\t}\n\tspin_unlock_irq(&card->local_addrs4_lock);\n}\n\nstatic void qeth_flush_local_addrs6(struct qeth_card *card)\n{\n\tstruct qeth_local_addr *addr;\n\tstruct hlist_node *tmp;\n\tunsigned int i;\n\n\tspin_lock_irq(&card->local_addrs6_lock);\n\thash_for_each_safe(card->local_addrs6, i, tmp, addr, hnode) {\n\t\thash_del_rcu(&addr->hnode);\n\t\tkfree_rcu(addr, rcu);\n\t}\n\tspin_unlock_irq(&card->local_addrs6_lock);\n}\n\nstatic void qeth_flush_local_addrs(struct qeth_card *card)\n{\n\tqeth_flush_local_addrs4(card);\n\tqeth_flush_local_addrs6(card);\n}\n\nstatic void qeth_add_local_addrs4(struct qeth_card *card,\n\t\t\t\t  struct qeth_ipacmd_local_addrs4 *cmd)\n{\n\tunsigned int i;\n\n\tif (cmd->addr_length !=\n\t    sizeof_field(struct qeth_ipacmd_local_addr4, addr)) {\n\t\tdev_err_ratelimited(&card->gdev->dev,\n\t\t\t\t    \"Dropped IPv4 ADD LOCAL ADDR event with bad length %u\\n\",\n\t\t\t\t    cmd->addr_length);\n\t\treturn;\n\t}\n\n\tspin_lock(&card->local_addrs4_lock);\n\tfor (i = 0; i < cmd->count; i++) {\n\t\tunsigned int key = ipv4_addr_hash(cmd->addrs[i].addr);\n\t\tstruct qeth_local_addr *addr;\n\t\tbool duplicate = false;\n\n\t\thash_for_each_possible(card->local_addrs4, addr, hnode, key) {\n\t\t\tif (addr->addr.s6_addr32[3] == cmd->addrs[i].addr) {\n\t\t\t\tduplicate = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (duplicate)\n\t\t\tcontinue;\n\n\t\taddr = kmalloc(sizeof(*addr), GFP_ATOMIC);\n\t\tif (!addr) {\n\t\t\tdev_err(&card->gdev->dev,\n\t\t\t\t\"Failed to allocate local addr object. Traffic to %pI4 might suffer.\\n\",\n\t\t\t\t&cmd->addrs[i].addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tipv6_addr_set(&addr->addr, 0, 0, 0, cmd->addrs[i].addr);\n\t\thash_add_rcu(card->local_addrs4, &addr->hnode, key);\n\t}\n\tspin_unlock(&card->local_addrs4_lock);\n}\n\nstatic void qeth_add_local_addrs6(struct qeth_card *card,\n\t\t\t\t  struct qeth_ipacmd_local_addrs6 *cmd)\n{\n\tunsigned int i;\n\n\tif (cmd->addr_length !=\n\t    sizeof_field(struct qeth_ipacmd_local_addr6, addr)) {\n\t\tdev_err_ratelimited(&card->gdev->dev,\n\t\t\t\t    \"Dropped IPv6 ADD LOCAL ADDR event with bad length %u\\n\",\n\t\t\t\t    cmd->addr_length);\n\t\treturn;\n\t}\n\n\tspin_lock(&card->local_addrs6_lock);\n\tfor (i = 0; i < cmd->count; i++) {\n\t\tu32 key = ipv6_addr_hash(&cmd->addrs[i].addr);\n\t\tstruct qeth_local_addr *addr;\n\t\tbool duplicate = false;\n\n\t\thash_for_each_possible(card->local_addrs6, addr, hnode, key) {\n\t\t\tif (ipv6_addr_equal(&addr->addr, &cmd->addrs[i].addr)) {\n\t\t\t\tduplicate = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (duplicate)\n\t\t\tcontinue;\n\n\t\taddr = kmalloc(sizeof(*addr), GFP_ATOMIC);\n\t\tif (!addr) {\n\t\t\tdev_err(&card->gdev->dev,\n\t\t\t\t\"Failed to allocate local addr object. Traffic to %pI6c might suffer.\\n\",\n\t\t\t\t&cmd->addrs[i].addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\taddr->addr = cmd->addrs[i].addr;\n\t\thash_add_rcu(card->local_addrs6, &addr->hnode, key);\n\t}\n\tspin_unlock(&card->local_addrs6_lock);\n}\n\nstatic void qeth_del_local_addrs4(struct qeth_card *card,\n\t\t\t\t  struct qeth_ipacmd_local_addrs4 *cmd)\n{\n\tunsigned int i;\n\n\tif (cmd->addr_length !=\n\t    sizeof_field(struct qeth_ipacmd_local_addr4, addr)) {\n\t\tdev_err_ratelimited(&card->gdev->dev,\n\t\t\t\t    \"Dropped IPv4 DEL LOCAL ADDR event with bad length %u\\n\",\n\t\t\t\t    cmd->addr_length);\n\t\treturn;\n\t}\n\n\tspin_lock(&card->local_addrs4_lock);\n\tfor (i = 0; i < cmd->count; i++) {\n\t\tstruct qeth_ipacmd_local_addr4 *addr = &cmd->addrs[i];\n\t\tunsigned int key = ipv4_addr_hash(addr->addr);\n\t\tstruct qeth_local_addr *tmp;\n\n\t\thash_for_each_possible(card->local_addrs4, tmp, hnode, key) {\n\t\t\tif (tmp->addr.s6_addr32[3] == addr->addr) {\n\t\t\t\thash_del_rcu(&tmp->hnode);\n\t\t\t\tkfree_rcu(tmp, rcu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&card->local_addrs4_lock);\n}\n\nstatic void qeth_del_local_addrs6(struct qeth_card *card,\n\t\t\t\t  struct qeth_ipacmd_local_addrs6 *cmd)\n{\n\tunsigned int i;\n\n\tif (cmd->addr_length !=\n\t    sizeof_field(struct qeth_ipacmd_local_addr6, addr)) {\n\t\tdev_err_ratelimited(&card->gdev->dev,\n\t\t\t\t    \"Dropped IPv6 DEL LOCAL ADDR event with bad length %u\\n\",\n\t\t\t\t    cmd->addr_length);\n\t\treturn;\n\t}\n\n\tspin_lock(&card->local_addrs6_lock);\n\tfor (i = 0; i < cmd->count; i++) {\n\t\tstruct qeth_ipacmd_local_addr6 *addr = &cmd->addrs[i];\n\t\tu32 key = ipv6_addr_hash(&addr->addr);\n\t\tstruct qeth_local_addr *tmp;\n\n\t\thash_for_each_possible(card->local_addrs6, tmp, hnode, key) {\n\t\t\tif (ipv6_addr_equal(&tmp->addr, &addr->addr)) {\n\t\t\t\thash_del_rcu(&tmp->hnode);\n\t\t\t\tkfree_rcu(tmp, rcu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&card->local_addrs6_lock);\n}\n\nstatic bool qeth_next_hop_is_local_v4(struct qeth_card *card,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct qeth_local_addr *tmp;\n\tbool is_local = false;\n\tunsigned int key;\n\t__be32 next_hop;\n\n\tif (hash_empty(card->local_addrs4))\n\t\treturn false;\n\n\trcu_read_lock();\n\tnext_hop = qeth_next_hop_v4_rcu(skb,\n\t\t\t\t\tqeth_dst_check_rcu(skb, htons(ETH_P_IP)));\n\tkey = ipv4_addr_hash(next_hop);\n\n\thash_for_each_possible_rcu(card->local_addrs4, tmp, hnode, key) {\n\t\tif (tmp->addr.s6_addr32[3] == next_hop) {\n\t\t\tis_local = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn is_local;\n}\n\nstatic bool qeth_next_hop_is_local_v6(struct qeth_card *card,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct qeth_local_addr *tmp;\n\tstruct in6_addr *next_hop;\n\tbool is_local = false;\n\tu32 key;\n\n\tif (hash_empty(card->local_addrs6))\n\t\treturn false;\n\n\trcu_read_lock();\n\tnext_hop = qeth_next_hop_v6_rcu(skb,\n\t\t\t\t\tqeth_dst_check_rcu(skb, htons(ETH_P_IPV6)));\n\tkey = ipv6_addr_hash(next_hop);\n\n\thash_for_each_possible_rcu(card->local_addrs6, tmp, hnode, key) {\n\t\tif (ipv6_addr_equal(&tmp->addr, next_hop)) {\n\t\t\tis_local = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn is_local;\n}\n\nstatic int qeth_debugfs_local_addr_show(struct seq_file *m, void *v)\n{\n\tstruct qeth_card *card = m->private;\n\tstruct qeth_local_addr *tmp;\n\tunsigned int i;\n\n\trcu_read_lock();\n\thash_for_each_rcu(card->local_addrs4, i, tmp, hnode)\n\t\tseq_printf(m, \"%pI4\\n\", &tmp->addr.s6_addr32[3]);\n\thash_for_each_rcu(card->local_addrs6, i, tmp, hnode)\n\t\tseq_printf(m, \"%pI6c\\n\", &tmp->addr);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(qeth_debugfs_local_addr);\n\nstatic void qeth_issue_ipa_msg(struct qeth_ipa_cmd *cmd, int rc,\n\t\tstruct qeth_card *card)\n{\n\tconst char *ipa_name;\n\tint com = cmd->hdr.command;\n\n\tipa_name = qeth_get_ipa_cmd_name(com);\n\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"IPA: %s(%#x) for device %x returned %#x \\\"%s\\\"\\n\",\n\t\t\t\t ipa_name, com, CARD_DEVID(card), rc,\n\t\t\t\t qeth_get_ipa_msg(rc));\n\telse\n\t\tQETH_DBF_MESSAGE(5, \"IPA: %s(%#x) for device %x succeeded\\n\",\n\t\t\t\t ipa_name, com, CARD_DEVID(card));\n}\n\nstatic void qeth_default_link_info(struct qeth_card *card)\n{\n\tstruct qeth_link_info *link_info = &card->info.link_info;\n\n\tQETH_CARD_TEXT(card, 2, \"dftlinfo\");\n\tlink_info->duplex = DUPLEX_FULL;\n\n\tif (IS_IQD(card) || IS_VM_NIC(card)) {\n\t\tlink_info->speed = SPEED_10000;\n\t\tlink_info->port = PORT_FIBRE;\n\t\tlink_info->link_mode = QETH_LINK_MODE_FIBRE_SHORT;\n\t} else {\n\t\tswitch (card->info.link_type) {\n\t\tcase QETH_LINK_TYPE_FAST_ETH:\n\t\tcase QETH_LINK_TYPE_LANE_ETH100:\n\t\t\tlink_info->speed = SPEED_100;\n\t\t\tlink_info->port = PORT_TP;\n\t\t\tbreak;\n\t\tcase QETH_LINK_TYPE_GBIT_ETH:\n\t\tcase QETH_LINK_TYPE_LANE_ETH1000:\n\t\t\tlink_info->speed = SPEED_1000;\n\t\t\tlink_info->port = PORT_FIBRE;\n\t\t\tbreak;\n\t\tcase QETH_LINK_TYPE_10GBIT_ETH:\n\t\t\tlink_info->speed = SPEED_10000;\n\t\t\tlink_info->port = PORT_FIBRE;\n\t\t\tbreak;\n\t\tcase QETH_LINK_TYPE_25GBIT_ETH:\n\t\t\tlink_info->speed = SPEED_25000;\n\t\t\tlink_info->port = PORT_FIBRE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(&card->gdev->dev,\n\t\t\t\t \"Unknown link type %x\\n\",\n\t\t\t\t card->info.link_type);\n\t\t\tlink_info->speed = SPEED_UNKNOWN;\n\t\t\tlink_info->port = PORT_OTHER;\n\t\t}\n\n\t\tlink_info->link_mode = QETH_LINK_MODE_UNKNOWN;\n\t}\n}\n\nstatic struct qeth_ipa_cmd *qeth_check_ipa_data(struct qeth_card *card,\n\t\t\t\t\t\tstruct qeth_ipa_cmd *cmd)\n{\n\tQETH_CARD_TEXT(card, 5, \"chkipad\");\n\n\tif (IS_IPA_REPLY(cmd)) {\n\t\tif (cmd->hdr.command != IPA_CMD_SET_DIAG_ASS)\n\t\t\tqeth_issue_ipa_msg(cmd, cmd->hdr.return_code, card);\n\t\treturn cmd;\n\t}\n\n\t \n\tswitch (cmd->hdr.command) {\n\tcase IPA_CMD_STOPLAN:\n\t\tif (cmd->hdr.return_code == IPA_RC_VEPA_TO_VEB_TRANSITION) {\n\t\t\tdev_err(&card->gdev->dev,\n\t\t\t\t\"Adjacent port of interface %s is no longer in reflective relay mode, trigger recovery\\n\",\n\t\t\t\tnetdev_name(card->dev));\n\t\t\t \n\t\t\tqeth_schedule_recovery(card);\n\t\t} else {\n\t\t\t \n\t\t\tdev_warn(&card->gdev->dev,\n\t\t\t\t \"The link for interface %s on CHPID 0x%X failed\\n\",\n\t\t\t\t netdev_name(card->dev), card->info.chpid);\n\t\t\tqeth_issue_ipa_msg(cmd, cmd->hdr.return_code, card);\n\t\t\tnetif_carrier_off(card->dev);\n\t\t\tqeth_default_link_info(card);\n\t\t}\n\t\treturn NULL;\n\tcase IPA_CMD_STARTLAN:\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"The link for %s on CHPID 0x%X has been restored\\n\",\n\t\t\t netdev_name(card->dev), card->info.chpid);\n\t\tif (card->info.hwtrap)\n\t\t\tcard->info.hwtrap = 2;\n\t\tqeth_schedule_recovery(card);\n\t\treturn NULL;\n\tcase IPA_CMD_SETBRIDGEPORT_IQD:\n\tcase IPA_CMD_SETBRIDGEPORT_OSA:\n\tcase IPA_CMD_ADDRESS_CHANGE_NOTIF:\n\t\tif (card->discipline->control_event_handler(card, cmd))\n\t\t\treturn cmd;\n\t\treturn NULL;\n\tcase IPA_CMD_REGISTER_LOCAL_ADDR:\n\t\tif (cmd->hdr.prot_version == QETH_PROT_IPV4)\n\t\t\tqeth_add_local_addrs4(card, &cmd->data.local_addrs4);\n\t\telse if (cmd->hdr.prot_version == QETH_PROT_IPV6)\n\t\t\tqeth_add_local_addrs6(card, &cmd->data.local_addrs6);\n\n\t\tQETH_CARD_TEXT(card, 3, \"irla\");\n\t\treturn NULL;\n\tcase IPA_CMD_UNREGISTER_LOCAL_ADDR:\n\t\tif (cmd->hdr.prot_version == QETH_PROT_IPV4)\n\t\t\tqeth_del_local_addrs4(card, &cmd->data.local_addrs4);\n\t\telse if (cmd->hdr.prot_version == QETH_PROT_IPV6)\n\t\t\tqeth_del_local_addrs6(card, &cmd->data.local_addrs6);\n\n\t\tQETH_CARD_TEXT(card, 3, \"urla\");\n\t\treturn NULL;\n\tdefault:\n\t\tQETH_DBF_MESSAGE(2, \"Received data is IPA but not a reply!\\n\");\n\t\treturn cmd;\n\t}\n}\n\nstatic void qeth_clear_ipacmd_list(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tunsigned long flags;\n\n\tQETH_CARD_TEXT(card, 4, \"clipalst\");\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_for_each_entry(iob, &card->cmd_waiter_list, list_entry)\n\t\tqeth_notify_cmd(iob, -ECANCELED);\n\tspin_unlock_irqrestore(&card->lock, flags);\n}\n\nstatic int qeth_check_idx_response(struct qeth_card *card,\n\tunsigned char *buffer)\n{\n\tQETH_DBF_HEX(CTRL, 2, buffer, QETH_DBF_CTRL_LEN);\n\tif ((buffer[2] & QETH_IDX_TERMINATE_MASK) == QETH_IDX_TERMINATE) {\n\t\tQETH_DBF_MESSAGE(2, \"received an IDX TERMINATE with cause code %#04x\\n\",\n\t\t\t\t buffer[4]);\n\t\tQETH_CARD_TEXT(card, 2, \"ckidxres\");\n\t\tQETH_CARD_TEXT(card, 2, \" idxterm\");\n\t\tQETH_CARD_TEXT_(card, 2, \"rc%x\", buffer[4]);\n\t\tif (buffer[4] == QETH_IDX_TERM_BAD_TRANSPORT ||\n\t\t    buffer[4] == QETH_IDX_TERM_BAD_TRANSPORT_VM) {\n\t\t\tdev_err(&card->gdev->dev,\n\t\t\t\t\"The device does not support the configured transport mode\\n\");\n\t\t\treturn -EPROTONOSUPPORT;\n\t\t}\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void qeth_release_buffer_cb(struct qeth_card *card,\n\t\t\t\t   struct qeth_cmd_buffer *iob,\n\t\t\t\t   unsigned int data_length)\n{\n\tqeth_put_cmd(iob);\n}\n\nstatic void qeth_cancel_cmd(struct qeth_cmd_buffer *iob, int rc)\n{\n\tqeth_notify_cmd(iob, rc);\n\tqeth_put_cmd(iob);\n}\n\nstatic struct qeth_cmd_buffer *qeth_alloc_cmd(struct qeth_channel *channel,\n\t\t\t\t\t      unsigned int length,\n\t\t\t\t\t      unsigned int ccws, long timeout)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tif (length > QETH_BUFSIZE)\n\t\treturn NULL;\n\n\tiob = kzalloc(sizeof(*iob), GFP_KERNEL);\n\tif (!iob)\n\t\treturn NULL;\n\n\tiob->data = kzalloc(ALIGN(length, 8) + ccws * sizeof(struct ccw1),\n\t\t\t    GFP_KERNEL | GFP_DMA);\n\tif (!iob->data) {\n\t\tkfree(iob);\n\t\treturn NULL;\n\t}\n\n\tinit_completion(&iob->done);\n\tspin_lock_init(&iob->lock);\n\trefcount_set(&iob->ref_count, 1);\n\tiob->channel = channel;\n\tiob->timeout = timeout;\n\tiob->length = length;\n\treturn iob;\n}\n\nstatic void qeth_issue_next_read_cb(struct qeth_card *card,\n\t\t\t\t    struct qeth_cmd_buffer *iob,\n\t\t\t\t    unsigned int data_length)\n{\n\tstruct qeth_cmd_buffer *request = NULL;\n\tstruct qeth_ipa_cmd *cmd = NULL;\n\tstruct qeth_reply *reply = NULL;\n\tstruct qeth_cmd_buffer *tmp;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 4, \"sndctlcb\");\n\trc = qeth_check_idx_response(card, iob->data);\n\tswitch (rc) {\n\tcase 0:\n\t\tbreak;\n\tcase -EIO:\n\t\tqeth_schedule_recovery(card);\n\t\tfallthrough;\n\tdefault:\n\t\tqeth_clear_ipacmd_list(card);\n\t\tgoto err_idx;\n\t}\n\n\tcmd = __ipa_reply(iob);\n\tif (cmd) {\n\t\tcmd = qeth_check_ipa_data(card, cmd);\n\t\tif (!cmd)\n\t\t\tgoto out;\n\t}\n\n\t \n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_for_each_entry(tmp, &card->cmd_waiter_list, list_entry) {\n\t\tif (tmp->match && tmp->match(tmp, iob)) {\n\t\t\trequest = tmp;\n\t\t\t \n\t\t\tqeth_get_cmd(request);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tif (!request)\n\t\tgoto out;\n\n\treply = &request->reply;\n\tif (!reply->callback) {\n\t\trc = 0;\n\t\tgoto no_callback;\n\t}\n\n\tspin_lock_irqsave(&request->lock, flags);\n\tif (request->rc)\n\t\t \n\t\trc = request->rc;\n\telse\n\t\trc = reply->callback(card, reply, cmd ? (unsigned long)cmd :\n\t\t\t\t\t\t\t(unsigned long)iob);\n\tspin_unlock_irqrestore(&request->lock, flags);\n\nno_callback:\n\tif (rc <= 0)\n\t\tqeth_notify_cmd(request, rc);\n\tqeth_put_cmd(request);\nout:\n\tmemcpy(&card->seqno.pdu_hdr_ack,\n\t\tQETH_PDU_HEADER_SEQ_NO(iob->data),\n\t\tQETH_SEQ_NO_LENGTH);\n\t__qeth_issue_next_read(card);\nerr_idx:\n\tqeth_put_cmd(iob);\n}\n\nstatic int qeth_set_thread_start_bit(struct qeth_card *card,\n\t\tunsigned long thread)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tif (!(card->thread_allowed_mask & thread))\n\t\trc = -EPERM;\n\telse if (card->thread_start_mask & thread)\n\t\trc = -EBUSY;\n\telse\n\t\tcard->thread_start_mask |= thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\n\treturn rc;\n}\n\nstatic void qeth_clear_thread_start_bit(struct qeth_card *card,\n\t\t\t\t\tunsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_start_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\n\nstatic void qeth_clear_thread_running_bit(struct qeth_card *card,\n\t\t\t\t\t  unsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_running_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up_all(&card->wait_q);\n}\n\nstatic int __qeth_do_run_thread(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tif (card->thread_start_mask & thread) {\n\t\tif ((card->thread_allowed_mask & thread) &&\n\t\t    !(card->thread_running_mask & thread)) {\n\t\t\trc = 1;\n\t\t\tcard->thread_start_mask &= ~thread;\n\t\t\tcard->thread_running_mask |= thread;\n\t\t} else\n\t\t\trc = -EPERM;\n\t}\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\n\nstatic int qeth_do_run_thread(struct qeth_card *card, unsigned long thread)\n{\n\tint rc = 0;\n\n\twait_event(card->wait_q,\n\t\t   (rc = __qeth_do_run_thread(card, thread)) >= 0);\n\treturn rc;\n}\n\nint qeth_schedule_recovery(struct qeth_card *card)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"startrec\");\n\n\trc = qeth_set_thread_start_bit(card, QETH_RECOVER_THREAD);\n\tif (!rc)\n\t\tschedule_work(&card->kernel_thread_starter);\n\n\treturn rc;\n}\n\nstatic int qeth_get_problem(struct qeth_card *card, struct ccw_device *cdev,\n\t\t\t    struct irb *irb)\n{\n\tint dstat, cstat;\n\tchar *sense;\n\n\tsense = (char *) irb->ecw;\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\n\tif (cstat & (SCHN_STAT_CHN_CTRL_CHK | SCHN_STAT_INTF_CTRL_CHK |\n\t\t     SCHN_STAT_CHN_DATA_CHK | SCHN_STAT_CHAIN_CHECK |\n\t\t     SCHN_STAT_PROT_CHECK | SCHN_STAT_PROG_CHECK)) {\n\t\tQETH_CARD_TEXT(card, 2, \"CGENCHK\");\n\t\tdev_warn(&cdev->dev, \"The qeth device driver \"\n\t\t\t\"failed to recover an error on the device\\n\");\n\t\tQETH_DBF_MESSAGE(2, \"check on channel %x with dstat=%#x, cstat=%#x\\n\",\n\t\t\t\t CCW_DEVID(cdev), dstat, cstat);\n\t\tprint_hex_dump(KERN_WARNING, \"qeth: irb \", DUMP_PREFIX_OFFSET,\n\t\t\t\t16, 1, irb, 64, 1);\n\t\treturn -EIO;\n\t}\n\n\tif (dstat & DEV_STAT_UNIT_CHECK) {\n\t\tif (sense[SENSE_RESETTING_EVENT_BYTE] &\n\t\t    SENSE_RESETTING_EVENT_FLAG) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"REVIND\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (sense[SENSE_COMMAND_REJECT_BYTE] &\n\t\t    SENSE_COMMAND_REJECT_FLAG) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"CMDREJi\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((sense[2] == 0xaf) && (sense[3] == 0xfe)) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"AFFE\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((!sense[0]) && (!sense[1]) && (!sense[2]) && (!sense[3])) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"ZEROSEN\");\n\t\t\treturn 0;\n\t\t}\n\t\tQETH_CARD_TEXT(card, 2, \"DGENCHK\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int qeth_check_irb_error(struct qeth_card *card, struct ccw_device *cdev,\n\t\t\t\tstruct irb *irb)\n{\n\tif (!IS_ERR(irb))\n\t\treturn 0;\n\n\tswitch (PTR_ERR(irb)) {\n\tcase -EIO:\n\t\tQETH_DBF_MESSAGE(2, \"i/o-error on channel %x\\n\",\n\t\t\t\t CCW_DEVID(cdev));\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT_(card, 2, \"  rc%d\", -EIO);\n\t\treturn -EIO;\n\tcase -ETIMEDOUT:\n\t\tdev_warn(&cdev->dev, \"A hardware operation timed out\"\n\t\t\t\" on the device\\n\");\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT_(card, 2, \"  rc%d\", -ETIMEDOUT);\n\t\treturn -ETIMEDOUT;\n\tdefault:\n\t\tQETH_DBF_MESSAGE(2, \"unknown error %ld on channel %x\\n\",\n\t\t\t\t PTR_ERR(irb), CCW_DEVID(cdev));\n\t\tQETH_CARD_TEXT(card, 2, \"ckirberr\");\n\t\tQETH_CARD_TEXT(card, 2, \"  rc???\");\n\t\treturn PTR_ERR(irb);\n\t}\n}\n\nstatic void qeth_irq(struct ccw_device *cdev, unsigned long intparm,\n\t\tstruct irb *irb)\n{\n\tint rc;\n\tint cstat, dstat;\n\tstruct qeth_cmd_buffer *iob = NULL;\n\tstruct ccwgroup_device *gdev;\n\tstruct qeth_channel *channel;\n\tstruct qeth_card *card;\n\n\t \n\tgdev = dev_get_drvdata(&cdev->dev);\n\tcard = dev_get_drvdata(&gdev->dev);\n\n\tQETH_CARD_TEXT(card, 5, \"irq\");\n\n\tif (card->read.ccwdev == cdev) {\n\t\tchannel = &card->read;\n\t\tQETH_CARD_TEXT(card, 5, \"read\");\n\t} else if (card->write.ccwdev == cdev) {\n\t\tchannel = &card->write;\n\t\tQETH_CARD_TEXT(card, 5, \"write\");\n\t} else {\n\t\tchannel = &card->data;\n\t\tQETH_CARD_TEXT(card, 5, \"data\");\n\t}\n\n\tif (intparm == 0) {\n\t\tQETH_CARD_TEXT(card, 5, \"irqunsol\");\n\t} else if ((addr_t)intparm != (addr_t)channel->active_cmd) {\n\t\tQETH_CARD_TEXT(card, 5, \"irqunexp\");\n\n\t\tdev_err(&cdev->dev,\n\t\t\t\"Received IRQ with intparm %lx, expected %px\\n\",\n\t\t\tintparm, channel->active_cmd);\n\t\tif (channel->active_cmd)\n\t\t\tqeth_cancel_cmd(channel->active_cmd, -EIO);\n\t} else {\n\t\tiob = (struct qeth_cmd_buffer *) (addr_t)intparm;\n\t}\n\n\tqeth_unlock_channel(card, channel);\n\n\trc = qeth_check_irb_error(card, cdev, irb);\n\tif (rc) {\n\t\t \n\t\tif (iob)\n\t\t\tqeth_cancel_cmd(iob, rc);\n\t\treturn;\n\t}\n\n\tif (irb->scsw.cmd.fctl & SCSW_FCTL_CLEAR_FUNC) {\n\t\tchannel->state = CH_STATE_STOPPED;\n\t\twake_up(&card->wait_q);\n\t}\n\n\tif (irb->scsw.cmd.fctl & SCSW_FCTL_HALT_FUNC) {\n\t\tchannel->state = CH_STATE_HALTED;\n\t\twake_up(&card->wait_q);\n\t}\n\n\tif (iob && (irb->scsw.cmd.fctl & (SCSW_FCTL_CLEAR_FUNC |\n\t\t\t\t\t  SCSW_FCTL_HALT_FUNC))) {\n\t\tqeth_cancel_cmd(iob, -ECANCELED);\n\t\tiob = NULL;\n\t}\n\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\n\tif ((dstat & DEV_STAT_UNIT_EXCEP) ||\n\t    (dstat & DEV_STAT_UNIT_CHECK) ||\n\t    (cstat)) {\n\t\tif (irb->esw.esw0.erw.cons) {\n\t\t\tdev_warn(&channel->ccwdev->dev,\n\t\t\t\t\"The qeth device driver failed to recover \"\n\t\t\t\t\"an error on the device\\n\");\n\t\t\tQETH_DBF_MESSAGE(2, \"sense data available on channel %x: cstat %#X dstat %#X\\n\",\n\t\t\t\t\t CCW_DEVID(channel->ccwdev), cstat,\n\t\t\t\t\t dstat);\n\t\t\tprint_hex_dump(KERN_WARNING, \"qeth: irb \",\n\t\t\t\tDUMP_PREFIX_OFFSET, 16, 1, irb, 32, 1);\n\t\t\tprint_hex_dump(KERN_WARNING, \"qeth: sense data \",\n\t\t\t\tDUMP_PREFIX_OFFSET, 16, 1, irb->ecw, 32, 1);\n\t\t}\n\n\t\trc = qeth_get_problem(card, cdev, irb);\n\t\tif (rc) {\n\t\t\tcard->read_or_write_problem = 1;\n\t\t\tif (iob)\n\t\t\t\tqeth_cancel_cmd(iob, rc);\n\t\t\tqeth_clear_ipacmd_list(card);\n\t\t\tqeth_schedule_recovery(card);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (iob) {\n\t\t \n\t\tif (irb->scsw.cmd.count > iob->length) {\n\t\t\tqeth_cancel_cmd(iob, -EIO);\n\t\t\treturn;\n\t\t}\n\t\tif (iob->callback)\n\t\t\tiob->callback(card, iob,\n\t\t\t\t      iob->length - irb->scsw.cmd.count);\n\t}\n}\n\nstatic void qeth_notify_skbs(struct qeth_qdio_out_q *q,\n\t\tstruct qeth_qdio_out_buffer *buf,\n\t\tenum iucv_tx_notify notification)\n{\n\tstruct sk_buff *skb;\n\n\tskb_queue_walk(&buf->skb_list, skb) {\n\t\tstruct sock *sk = skb->sk;\n\n\t\tQETH_CARD_TEXT_(q->card, 5, \"skbn%d\", notification);\n\t\tQETH_CARD_TEXT_(q->card, 5, \"%lx\", (long) skb);\n\t\tif (sk && sk->sk_family == PF_IUCV)\n\t\t\tiucv_sk(sk)->sk_txnotify(sk, notification);\n\t}\n}\n\nstatic void qeth_tx_complete_buf(struct qeth_qdio_out_q *queue,\n\t\t\t\t struct qeth_qdio_out_buffer *buf, bool error,\n\t\t\t\t int budget)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tif (buf->next_element_to_fill == 0)\n\t\treturn;\n\n\tQETH_TXQ_STAT_INC(queue, bufs);\n\tQETH_TXQ_STAT_ADD(queue, buf_elements, buf->next_element_to_fill);\n\tif (error) {\n\t\tQETH_TXQ_STAT_ADD(queue, tx_errors, buf->frames);\n\t} else {\n\t\tQETH_TXQ_STAT_ADD(queue, tx_packets, buf->frames);\n\t\tQETH_TXQ_STAT_ADD(queue, tx_bytes, buf->bytes);\n\t}\n\n\twhile ((skb = __skb_dequeue(&buf->skb_list)) != NULL) {\n\t\tunsigned int bytes = qdisc_pkt_len(skb);\n\t\tbool is_tso = skb_is_gso(skb);\n\t\tunsigned int packets;\n\n\t\tpackets = is_tso ? skb_shinfo(skb)->gso_segs : 1;\n\t\tif (!error) {\n\t\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\t\tQETH_TXQ_STAT_ADD(queue, skbs_csum, packets);\n\t\t\tif (skb_is_nonlinear(skb))\n\t\t\t\tQETH_TXQ_STAT_INC(queue, skbs_sg);\n\t\t\tif (is_tso) {\n\t\t\t\tQETH_TXQ_STAT_INC(queue, skbs_tso);\n\t\t\t\tQETH_TXQ_STAT_ADD(queue, tso_bytes, bytes);\n\t\t\t}\n\t\t}\n\n\t\tnapi_consume_skb(skb, budget);\n\t}\n}\n\nstatic void qeth_clear_output_buffer(struct qeth_qdio_out_q *queue,\n\t\t\t\t     struct qeth_qdio_out_buffer *buf,\n\t\t\t\t     bool error, int budget)\n{\n\tint i;\n\n\t \n\tif (buf->buffer->element[0].sflags & SBAL_SFLAGS0_PCI_REQ) {\n\t\tatomic_dec(&queue->set_pci_flags_count);\n\t\tQETH_TXQ_STAT_INC(queue, completion_irq);\n\t}\n\n\tqeth_tx_complete_buf(queue, buf, error, budget);\n\n\tfor (i = 0; i < queue->max_elements; ++i) {\n\t\tvoid *data = phys_to_virt(buf->buffer->element[i].addr);\n\n\t\tif (__test_and_clear_bit(i, buf->from_kmem_cache) && data)\n\t\t\tkmem_cache_free(qeth_core_header_cache, data);\n\t}\n\n\tqeth_scrub_qdio_buffer(buf->buffer, queue->max_elements);\n\tbuf->next_element_to_fill = 0;\n\tbuf->frames = 0;\n\tbuf->bytes = 0;\n\tatomic_set(&buf->state, QETH_QDIO_BUF_EMPTY);\n}\n\nstatic void qeth_free_out_buf(struct qeth_qdio_out_buffer *buf)\n{\n\tif (buf->aob)\n\t\tkmem_cache_free(qeth_qaob_cache, buf->aob);\n\tkmem_cache_free(qeth_qdio_outbuf_cache, buf);\n}\n\nstatic void qeth_tx_complete_pending_bufs(struct qeth_card *card,\n\t\t\t\t\t  struct qeth_qdio_out_q *queue,\n\t\t\t\t\t  bool drain, int budget)\n{\n\tstruct qeth_qdio_out_buffer *buf, *tmp;\n\n\tlist_for_each_entry_safe(buf, tmp, &queue->pending_bufs, list_entry) {\n\t\tstruct qeth_qaob_priv1 *priv;\n\t\tstruct qaob *aob = buf->aob;\n\t\tenum iucv_tx_notify notify;\n\t\tunsigned int i;\n\n\t\tpriv = (struct qeth_qaob_priv1 *)&aob->user1;\n\t\tif (drain || READ_ONCE(priv->state) == QETH_QAOB_DONE) {\n\t\t\tQETH_CARD_TEXT(card, 5, \"fp\");\n\t\t\tQETH_CARD_TEXT_(card, 5, \"%lx\", (long) buf);\n\n\t\t\tnotify = drain ? TX_NOTIFY_GENERALERROR :\n\t\t\t\t\t qeth_compute_cq_notification(aob->aorc, 1);\n\t\t\tqeth_notify_skbs(queue, buf, notify);\n\t\t\tqeth_tx_complete_buf(queue, buf, drain, budget);\n\n\t\t\tfor (i = 0;\n\t\t\t     i < aob->sb_count && i < queue->max_elements;\n\t\t\t     i++) {\n\t\t\t\tvoid *data = phys_to_virt(aob->sba[i]);\n\n\t\t\t\tif (test_bit(i, buf->from_kmem_cache) && data)\n\t\t\t\t\tkmem_cache_free(qeth_core_header_cache,\n\t\t\t\t\t\t\tdata);\n\t\t\t}\n\n\t\t\tlist_del(&buf->list_entry);\n\t\t\tqeth_free_out_buf(buf);\n\t\t}\n\t}\n}\n\nstatic void qeth_drain_output_queue(struct qeth_qdio_out_q *q, bool free)\n{\n\tint j;\n\n\tqeth_tx_complete_pending_bufs(q->card, q, true, 0);\n\n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\tif (!q->bufs[j])\n\t\t\tcontinue;\n\n\t\tqeth_clear_output_buffer(q, q->bufs[j], true, 0);\n\t\tif (free) {\n\t\t\tqeth_free_out_buf(q->bufs[j]);\n\t\t\tq->bufs[j] = NULL;\n\t\t}\n\t}\n}\n\nstatic void qeth_drain_output_queues(struct qeth_card *card)\n{\n\tint i;\n\n\tQETH_CARD_TEXT(card, 2, \"clearqdbf\");\n\t \n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tif (card->qdio.out_qs[i])\n\t\t\tqeth_drain_output_queue(card->qdio.out_qs[i], false);\n\t}\n}\n\nstatic void qeth_osa_set_output_queues(struct qeth_card *card, bool single)\n{\n\tunsigned int max = single ? 1 : card->dev->num_tx_queues;\n\n\tif (card->qdio.no_out_queues == max)\n\t\treturn;\n\n\tif (atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED)\n\t\tqeth_free_qdio_queues(card);\n\n\tif (max == 1 && card->qdio.do_prio_queueing != QETH_PRIOQ_DEFAULT)\n\t\tdev_info(&card->gdev->dev, \"Priority Queueing not supported\\n\");\n\n\tcard->qdio.no_out_queues = max;\n}\n\nstatic int qeth_update_from_chp_desc(struct qeth_card *card)\n{\n\tstruct ccw_device *ccwdev;\n\tstruct channel_path_desc_fmt0 *chp_dsc;\n\n\tQETH_CARD_TEXT(card, 2, \"chp_desc\");\n\n\tccwdev = card->data.ccwdev;\n\tchp_dsc = ccw_device_get_chp_desc(ccwdev, 0);\n\tif (!chp_dsc)\n\t\treturn -ENOMEM;\n\n\tcard->info.func_level = 0x4100 + chp_dsc->desc;\n\n\tif (IS_OSD(card) || IS_OSX(card))\n\t\t \n\t\tqeth_osa_set_output_queues(card, chp_dsc->chpp & 0x02);\n\n\tkfree(chp_dsc);\n\tQETH_CARD_TEXT_(card, 2, \"nr:%x\", card->qdio.no_out_queues);\n\tQETH_CARD_TEXT_(card, 2, \"lvl:%02x\", card->info.func_level);\n\treturn 0;\n}\n\nstatic void qeth_init_qdio_info(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 4, \"intqdinf\");\n\tatomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);\n\tcard->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;\n\tcard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\n\n\t \n\tcard->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;\n\tif (IS_IQD(card))\n\t\tcard->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_HSDEFAULT;\n\telse\n\t\tcard->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_DEFAULT;\n\tcard->qdio.in_buf_pool.buf_count = card->qdio.init_pool.buf_count;\n\tINIT_LIST_HEAD(&card->qdio.in_buf_pool.entry_list);\n\tINIT_LIST_HEAD(&card->qdio.init_pool.entry_list);\n}\n\nstatic void qeth_set_initial_options(struct qeth_card *card)\n{\n\tcard->options.route4.type = NO_ROUTER;\n\tcard->options.route6.type = NO_ROUTER;\n\tcard->options.isolation = ISOLATION_MODE_NONE;\n\tcard->options.cq = QETH_CQ_DISABLED;\n\tcard->options.layer = QETH_DISCIPLINE_UNDETERMINED;\n}\n\nstatic int qeth_do_start_thread(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tQETH_CARD_TEXT_(card, 4, \"  %02x%02x%02x\",\n\t\t\t(u8) card->thread_start_mask,\n\t\t\t(u8) card->thread_allowed_mask,\n\t\t\t(u8) card->thread_running_mask);\n\trc = (card->thread_start_mask & thread);\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\treturn rc;\n}\n\nstatic int qeth_do_reset(void *data);\nstatic void qeth_start_kernel_thread(struct work_struct *work)\n{\n\tstruct task_struct *ts;\n\tstruct qeth_card *card = container_of(work, struct qeth_card,\n\t\t\t\t\tkernel_thread_starter);\n\tQETH_CARD_TEXT(card, 2, \"strthrd\");\n\n\tif (card->read.state != CH_STATE_UP &&\n\t    card->write.state != CH_STATE_UP)\n\t\treturn;\n\tif (qeth_do_start_thread(card, QETH_RECOVER_THREAD)) {\n\t\tts = kthread_run(qeth_do_reset, card, \"qeth_recover\");\n\t\tif (IS_ERR(ts)) {\n\t\t\tqeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);\n\t\t\tqeth_clear_thread_running_bit(card,\n\t\t\t\tQETH_RECOVER_THREAD);\n\t\t}\n\t}\n}\n\nstatic void qeth_buffer_reclaim_work(struct work_struct *);\nstatic void qeth_setup_card(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"setupcrd\");\n\n\tcard->info.type = CARD_RDEV(card)->id.driver_info;\n\tcard->state = CARD_STATE_DOWN;\n\tspin_lock_init(&card->lock);\n\tspin_lock_init(&card->thread_mask_lock);\n\tmutex_init(&card->conf_mutex);\n\tmutex_init(&card->discipline_mutex);\n\tINIT_WORK(&card->kernel_thread_starter, qeth_start_kernel_thread);\n\tINIT_LIST_HEAD(&card->cmd_waiter_list);\n\tinit_waitqueue_head(&card->wait_q);\n\tqeth_set_initial_options(card);\n\t \n\tINIT_LIST_HEAD(&card->ipato.entries);\n\tqeth_init_qdio_info(card);\n\tINIT_DELAYED_WORK(&card->buffer_reclaim_work, qeth_buffer_reclaim_work);\n\thash_init(card->rx_mode_addrs);\n\thash_init(card->local_addrs4);\n\thash_init(card->local_addrs6);\n\tspin_lock_init(&card->local_addrs4_lock);\n\tspin_lock_init(&card->local_addrs6_lock);\n}\n\nstatic void qeth_core_sl_print(struct seq_file *m, struct service_level *slr)\n{\n\tstruct qeth_card *card = container_of(slr, struct qeth_card,\n\t\t\t\t\tqeth_service_level);\n\tif (card->info.mcl_level[0])\n\t\tseq_printf(m, \"qeth: %s firmware level %s\\n\",\n\t\t\tCARD_BUS_ID(card), card->info.mcl_level);\n}\n\nstatic struct qeth_card *qeth_alloc_card(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"alloccrd\");\n\tcard = kzalloc(sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\tgoto out;\n\tQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\n\n\tcard->gdev = gdev;\n\tdev_set_drvdata(&gdev->dev, card);\n\tCARD_RDEV(card) = gdev->cdev[0];\n\tCARD_WDEV(card) = gdev->cdev[1];\n\tCARD_DDEV(card) = gdev->cdev[2];\n\n\tcard->event_wq = alloc_ordered_workqueue(\"%s_event\", 0,\n\t\t\t\t\t\t dev_name(&gdev->dev));\n\tif (!card->event_wq)\n\t\tgoto out_wq;\n\n\tcard->read_cmd = qeth_alloc_cmd(&card->read, QETH_BUFSIZE, 1, 0);\n\tif (!card->read_cmd)\n\t\tgoto out_read_cmd;\n\n\tcard->debugfs = debugfs_create_dir(dev_name(&gdev->dev),\n\t\t\t\t\t   qeth_debugfs_root);\n\tdebugfs_create_file(\"local_addrs\", 0400, card->debugfs, card,\n\t\t\t    &qeth_debugfs_local_addr_fops);\n\n\tcard->qeth_service_level.seq_print = qeth_core_sl_print;\n\tregister_service_level(&card->qeth_service_level);\n\treturn card;\n\nout_read_cmd:\n\tdestroy_workqueue(card->event_wq);\nout_wq:\n\tdev_set_drvdata(&gdev->dev, NULL);\n\tkfree(card);\nout:\n\treturn NULL;\n}\n\nstatic int qeth_clear_channel(struct qeth_card *card,\n\t\t\t      struct qeth_channel *channel)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"clearch\");\n\tspin_lock_irq(get_ccwdev_lock(channel->ccwdev));\n\trc = ccw_device_clear(channel->ccwdev, (addr_t)channel->active_cmd);\n\tspin_unlock_irq(get_ccwdev_lock(channel->ccwdev));\n\n\tif (rc)\n\t\treturn rc;\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\tchannel->state == CH_STATE_STOPPED, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_STOPPED)\n\t\treturn -ETIME;\n\tchannel->state = CH_STATE_DOWN;\n\treturn 0;\n}\n\nstatic int qeth_halt_channel(struct qeth_card *card,\n\t\t\t     struct qeth_channel *channel)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"haltch\");\n\tspin_lock_irq(get_ccwdev_lock(channel->ccwdev));\n\trc = ccw_device_halt(channel->ccwdev, (addr_t)channel->active_cmd);\n\tspin_unlock_irq(get_ccwdev_lock(channel->ccwdev));\n\n\tif (rc)\n\t\treturn rc;\n\trc = wait_event_interruptible_timeout(card->wait_q,\n\t\t\tchannel->state == CH_STATE_HALTED, QETH_TIMEOUT);\n\tif (rc == -ERESTARTSYS)\n\t\treturn rc;\n\tif (channel->state != CH_STATE_HALTED)\n\t\treturn -ETIME;\n\treturn 0;\n}\n\nstatic int qeth_stop_channel(struct qeth_channel *channel)\n{\n\tstruct ccw_device *cdev = channel->ccwdev;\n\tint rc;\n\n\trc = ccw_device_set_offline(cdev);\n\n\tspin_lock_irq(get_ccwdev_lock(cdev));\n\tif (channel->active_cmd)\n\t\tdev_err(&cdev->dev, \"Stopped channel while cmd %px was still active\\n\",\n\t\t\tchannel->active_cmd);\n\n\tcdev->handler = NULL;\n\tspin_unlock_irq(get_ccwdev_lock(cdev));\n\n\treturn rc;\n}\n\nstatic int qeth_start_channel(struct qeth_channel *channel)\n{\n\tstruct ccw_device *cdev = channel->ccwdev;\n\tint rc;\n\n\tchannel->state = CH_STATE_DOWN;\n\txchg(&channel->active_cmd, NULL);\n\n\tspin_lock_irq(get_ccwdev_lock(cdev));\n\tcdev->handler = qeth_irq;\n\tspin_unlock_irq(get_ccwdev_lock(cdev));\n\n\trc = ccw_device_set_online(cdev);\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tspin_lock_irq(get_ccwdev_lock(cdev));\n\tcdev->handler = NULL;\n\tspin_unlock_irq(get_ccwdev_lock(cdev));\n\treturn rc;\n}\n\nstatic int qeth_halt_channels(struct qeth_card *card)\n{\n\tint rc1 = 0, rc2 = 0, rc3 = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"haltchs\");\n\trc1 = qeth_halt_channel(card, &card->read);\n\trc2 = qeth_halt_channel(card, &card->write);\n\trc3 = qeth_halt_channel(card, &card->data);\n\tif (rc1)\n\t\treturn rc1;\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc3;\n}\n\nstatic int qeth_clear_channels(struct qeth_card *card)\n{\n\tint rc1 = 0, rc2 = 0, rc3 = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"clearchs\");\n\trc1 = qeth_clear_channel(card, &card->read);\n\trc2 = qeth_clear_channel(card, &card->write);\n\trc3 = qeth_clear_channel(card, &card->data);\n\tif (rc1)\n\t\treturn rc1;\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc3;\n}\n\nstatic int qeth_clear_halt_card(struct qeth_card *card, int halt)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"clhacrd\");\n\n\tif (halt)\n\t\trc = qeth_halt_channels(card);\n\tif (rc)\n\t\treturn rc;\n\treturn qeth_clear_channels(card);\n}\n\nstatic int qeth_qdio_clear_card(struct qeth_card *card, int use_halt)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"qdioclr\");\n\tswitch (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ESTABLISHED,\n\t\tQETH_QDIO_CLEANING)) {\n\tcase QETH_QDIO_ESTABLISHED:\n\t\tif (IS_IQD(card))\n\t\t\trc = qdio_shutdown(CARD_DDEV(card),\n\t\t\t\tQDIO_FLAG_CLEANUP_USING_HALT);\n\t\telse\n\t\t\trc = qdio_shutdown(CARD_DDEV(card),\n\t\t\t\tQDIO_FLAG_CLEANUP_USING_CLEAR);\n\t\tif (rc)\n\t\t\tQETH_CARD_TEXT_(card, 3, \"1err%d\", rc);\n\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\tbreak;\n\tcase QETH_QDIO_CLEANING:\n\t\treturn rc;\n\tdefault:\n\t\tbreak;\n\t}\n\trc = qeth_clear_halt_card(card, use_halt);\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 3, \"2err%d\", rc);\n\treturn rc;\n}\n\nstatic enum qeth_discipline_id qeth_vm_detect_layer(struct qeth_card *card)\n{\n\tenum qeth_discipline_id disc = QETH_DISCIPLINE_UNDETERMINED;\n\tstruct diag26c_vnic_resp *response = NULL;\n\tstruct diag26c_vnic_req *request = NULL;\n\tstruct ccw_dev_id id;\n\tchar userid[80];\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"vmlayer\");\n\n\tcpcmd(\"QUERY USERID\", userid, sizeof(userid), &rc);\n\tif (rc)\n\t\tgoto out;\n\n\trequest = kzalloc(sizeof(*request), GFP_KERNEL | GFP_DMA);\n\tresponse = kzalloc(sizeof(*response), GFP_KERNEL | GFP_DMA);\n\tif (!request || !response) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tccw_device_get_id(CARD_RDEV(card), &id);\n\trequest->resp_buf_len = sizeof(*response);\n\trequest->resp_version = DIAG26C_VERSION6_VM65918;\n\trequest->req_format = DIAG26C_VNIC_INFO;\n\tASCEBC(userid, 8);\n\tmemcpy(&request->sys_name, userid, 8);\n\trequest->devno = id.devno;\n\n\tQETH_DBF_HEX(CTRL, 2, request, sizeof(*request));\n\trc = diag26c(request, response, DIAG26C_PORT_VNIC);\n\tQETH_DBF_HEX(CTRL, 2, request, sizeof(*request));\n\tif (rc)\n\t\tgoto out;\n\tQETH_DBF_HEX(CTRL, 2, response, sizeof(*response));\n\n\tif (request->resp_buf_len < sizeof(*response) ||\n\t    response->version != request->resp_version) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (response->protocol == VNIC_INFO_PROT_L2)\n\t\tdisc = QETH_DISCIPLINE_LAYER2;\n\telse if (response->protocol == VNIC_INFO_PROT_L3)\n\t\tdisc = QETH_DISCIPLINE_LAYER3;\n\nout:\n\tkfree(response);\n\tkfree(request);\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"err%x\", rc);\n\treturn disc;\n}\n\n \nstatic enum qeth_discipline_id qeth_enforce_discipline(struct qeth_card *card)\n{\n\tenum qeth_discipline_id disc = QETH_DISCIPLINE_UNDETERMINED;\n\n\tif (IS_OSM(card))\n\t\tdisc = QETH_DISCIPLINE_LAYER2;\n\telse if (IS_VM_NIC(card))\n\t\tdisc = IS_IQD(card) ? QETH_DISCIPLINE_LAYER3 :\n\t\t\t\t      qeth_vm_detect_layer(card);\n\n\tswitch (disc) {\n\tcase QETH_DISCIPLINE_LAYER2:\n\t\tQETH_CARD_TEXT(card, 3, \"force l2\");\n\t\tbreak;\n\tcase QETH_DISCIPLINE_LAYER3:\n\t\tQETH_CARD_TEXT(card, 3, \"force l3\");\n\t\tbreak;\n\tdefault:\n\t\tQETH_CARD_TEXT(card, 3, \"force no\");\n\t}\n\n\treturn disc;\n}\n\nstatic void qeth_set_blkt_defaults(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"cfgblkt\");\n\n\tif (card->info.use_v1_blkt) {\n\t\tcard->info.blkt.time_total = 0;\n\t\tcard->info.blkt.inter_packet = 0;\n\t\tcard->info.blkt.inter_packet_jumbo = 0;\n\t} else {\n\t\tcard->info.blkt.time_total = 250;\n\t\tcard->info.blkt.inter_packet = 5;\n\t\tcard->info.blkt.inter_packet_jumbo = 15;\n\t}\n}\n\nstatic void qeth_idx_init(struct qeth_card *card)\n{\n\tmemset(&card->seqno, 0, sizeof(card->seqno));\n\n\tcard->token.issuer_rm_w = 0x00010103UL;\n\tcard->token.cm_filter_w = 0x00010108UL;\n\tcard->token.cm_connection_w = 0x0001010aUL;\n\tcard->token.ulp_filter_w = 0x0001010bUL;\n\tcard->token.ulp_connection_w = 0x0001010dUL;\n\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_IQD:\n\t\tcard->info.func_level =\tQETH_IDX_FUNC_LEVEL_IQD;\n\t\tbreak;\n\tcase QETH_CARD_TYPE_OSD:\n\t\tcard->info.func_level = QETH_IDX_FUNC_LEVEL_OSD;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void qeth_idx_finalize_cmd(struct qeth_card *card,\n\t\t\t\t  struct qeth_cmd_buffer *iob)\n{\n\tmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data), &card->seqno.trans_hdr,\n\t       QETH_SEQ_NO_LENGTH);\n\tif (iob->channel == &card->write)\n\t\tcard->seqno.trans_hdr++;\n}\n\nstatic int qeth_peer_func_level(int level)\n{\n\tif ((level & 0xff) == 8)\n\t\treturn (level & 0xff) + 0x400;\n\tif (((level >> 8) & 3) == 1)\n\t\treturn (level & 0xff) + 0x200;\n\treturn level;\n}\n\nstatic void qeth_mpc_finalize_cmd(struct qeth_card *card,\n\t\t\t\t  struct qeth_cmd_buffer *iob)\n{\n\tqeth_idx_finalize_cmd(card, iob);\n\n\tmemcpy(QETH_PDU_HEADER_SEQ_NO(iob->data),\n\t       &card->seqno.pdu_hdr, QETH_SEQ_NO_LENGTH);\n\tcard->seqno.pdu_hdr++;\n\tmemcpy(QETH_PDU_HEADER_ACK_SEQ_NO(iob->data),\n\t       &card->seqno.pdu_hdr_ack, QETH_SEQ_NO_LENGTH);\n\n\tiob->callback = qeth_release_buffer_cb;\n}\n\nstatic bool qeth_mpc_match_reply(struct qeth_cmd_buffer *iob,\n\t\t\t\t struct qeth_cmd_buffer *reply)\n{\n\t \n\treturn !IS_IPA(reply->data);\n}\n\nstatic struct qeth_cmd_buffer *qeth_mpc_alloc_cmd(struct qeth_card *card,\n\t\t\t\t\t\t  const void *data,\n\t\t\t\t\t\t  unsigned int data_length)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tiob = qeth_alloc_cmd(&card->write, data_length, 1, QETH_TIMEOUT);\n\tif (!iob)\n\t\treturn NULL;\n\n\tmemcpy(iob->data, data, data_length);\n\tqeth_setup_ccw(__ccw_from_cmd(iob), CCW_CMD_WRITE, 0, data_length,\n\t\t       iob->data);\n\tiob->finalize = qeth_mpc_finalize_cmd;\n\tiob->match = qeth_mpc_match_reply;\n\treturn iob;\n}\n\n \n\nstatic int qeth_send_control_data(struct qeth_card *card,\n\t\t\t\t  struct qeth_cmd_buffer *iob,\n\t\t\t\t  int (*reply_cb)(struct qeth_card *cb_card,\n\t\t\t\t\t\t  struct qeth_reply *cb_reply,\n\t\t\t\t\t\t  unsigned long cb_cmd),\n\t\t\t\t  void *reply_param)\n{\n\tstruct qeth_channel *channel = iob->channel;\n\tstruct qeth_reply *reply = &iob->reply;\n\tlong timeout = iob->timeout;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"sendctl\");\n\n\treply->callback = reply_cb;\n\treply->param = reply_param;\n\n\ttimeout = wait_event_interruptible_timeout(card->wait_q,\n\t\t\t\t\t\t   qeth_trylock_channel(channel, iob),\n\t\t\t\t\t\t   timeout);\n\tif (timeout <= 0) {\n\t\tqeth_put_cmd(iob);\n\t\treturn (timeout == -ERESTARTSYS) ? -EINTR : -ETIME;\n\t}\n\n\tif (iob->finalize)\n\t\tiob->finalize(card, iob);\n\tQETH_DBF_HEX(CTRL, 2, iob->data, min(iob->length, QETH_DBF_CTRL_LEN));\n\n\tqeth_enqueue_cmd(card, iob);\n\n\t \n\tqeth_get_cmd(iob);\n\n\tQETH_CARD_TEXT(card, 6, \"noirqpnd\");\n\tspin_lock_irq(get_ccwdev_lock(channel->ccwdev));\n\trc = ccw_device_start_timeout(channel->ccwdev, __ccw_from_cmd(iob),\n\t\t\t\t      (addr_t) iob, 0, 0, timeout);\n\tspin_unlock_irq(get_ccwdev_lock(channel->ccwdev));\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"qeth_send_control_data on device %x: ccw_device_start rc = %i\\n\",\n\t\t\t\t CARD_DEVID(card), rc);\n\t\tQETH_CARD_TEXT_(card, 2, \" err%d\", rc);\n\t\tqeth_dequeue_cmd(card, iob);\n\t\tqeth_put_cmd(iob);\n\t\tqeth_unlock_channel(card, channel);\n\t\tgoto out;\n\t}\n\n\ttimeout = wait_for_completion_interruptible_timeout(&iob->done,\n\t\t\t\t\t\t\t    timeout);\n\tif (timeout <= 0)\n\t\trc = (timeout == -ERESTARTSYS) ? -EINTR : -ETIME;\n\n\tqeth_dequeue_cmd(card, iob);\n\n\tif (reply_cb) {\n\t\t \n\t\tspin_lock_irq(&iob->lock);\n\t\tif (rc)\n\t\t\t \n\t\t\tiob->rc = rc;\n\t\tspin_unlock_irq(&iob->lock);\n\t}\n\n\tif (!rc)\n\t\trc = iob->rc;\n\nout:\n\tqeth_put_cmd(iob);\n\treturn rc;\n}\n\nstruct qeth_node_desc {\n\tstruct node_descriptor nd1;\n\tstruct node_descriptor nd2;\n\tstruct node_descriptor nd3;\n};\n\nstatic void qeth_read_conf_data_cb(struct qeth_card *card,\n\t\t\t\t   struct qeth_cmd_buffer *iob,\n\t\t\t\t   unsigned int data_length)\n{\n\tstruct qeth_node_desc *nd = (struct qeth_node_desc *) iob->data;\n\tint rc = 0;\n\tu8 *tag;\n\n\tQETH_CARD_TEXT(card, 2, \"cfgunit\");\n\n\tif (data_length < sizeof(*nd)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcard->info.is_vm_nic = nd->nd1.plant[0] == _ascebc['V'] &&\n\t\t\t       nd->nd1.plant[1] == _ascebc['M'];\n\ttag = (u8 *)&nd->nd1.tag;\n\tcard->info.chpid = tag[0];\n\tcard->info.unit_addr2 = tag[1];\n\n\ttag = (u8 *)&nd->nd2.tag;\n\tcard->info.cula = tag[1];\n\n\tcard->info.use_v1_blkt = nd->nd3.model[0] == 0xF0 &&\n\t\t\t\t nd->nd3.model[1] == 0xF0 &&\n\t\t\t\t nd->nd3.model[2] >= 0xF1 &&\n\t\t\t\t nd->nd3.model[2] <= 0xF4;\n\nout:\n\tqeth_notify_cmd(iob, rc);\n\tqeth_put_cmd(iob);\n}\n\nstatic int qeth_read_conf_data(struct qeth_card *card)\n{\n\tstruct qeth_channel *channel = &card->data;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct ciw *ciw;\n\n\t \n\tciw = ccw_device_get_ciw(channel->ccwdev, CIW_TYPE_RCD);\n\tif (!ciw || ciw->cmd == 0)\n\t\treturn -EOPNOTSUPP;\n\tif (ciw->count < sizeof(struct qeth_node_desc))\n\t\treturn -EINVAL;\n\n\tiob = qeth_alloc_cmd(channel, ciw->count, 1, QETH_RCD_TIMEOUT);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tiob->callback = qeth_read_conf_data_cb;\n\tqeth_setup_ccw(__ccw_from_cmd(iob), ciw->cmd, 0, iob->length,\n\t\t       iob->data);\n\n\treturn qeth_send_control_data(card, iob, NULL, NULL);\n}\n\nstatic int qeth_idx_check_activate_response(struct qeth_card *card,\n\t\t\t\t\t    struct qeth_channel *channel,\n\t\t\t\t\t    struct qeth_cmd_buffer *iob)\n{\n\tint rc;\n\n\trc = qeth_check_idx_response(card, iob->data);\n\tif (rc)\n\t\treturn rc;\n\n\tif (QETH_IS_IDX_ACT_POS_REPLY(iob->data))\n\t\treturn 0;\n\n\t \n\tQETH_CARD_TEXT_(card, 2, \"idxneg%c\",\n\t\t\tQETH_IDX_ACT_CAUSE_CODE(iob->data));\n\n\tswitch (QETH_IDX_ACT_CAUSE_CODE(iob->data)) {\n\tcase QETH_IDX_ACT_ERR_EXCL:\n\t\tdev_err(&channel->ccwdev->dev,\n\t\t\t\"The adapter is used exclusively by another host\\n\");\n\t\treturn -EBUSY;\n\tcase QETH_IDX_ACT_ERR_AUTH:\n\tcase QETH_IDX_ACT_ERR_AUTH_USER:\n\t\tdev_err(&channel->ccwdev->dev,\n\t\t\t\"Setting the device online failed because of insufficient authorization\\n\");\n\t\treturn -EPERM;\n\tdefault:\n\t\tQETH_DBF_MESSAGE(2, \"IDX_ACTIVATE on channel %x: negative reply\\n\",\n\t\t\t\t CCW_DEVID(channel->ccwdev));\n\t\treturn -EIO;\n\t}\n}\n\nstatic void qeth_idx_activate_read_channel_cb(struct qeth_card *card,\n\t\t\t\t\t      struct qeth_cmd_buffer *iob,\n\t\t\t\t\t      unsigned int data_length)\n{\n\tstruct qeth_channel *channel = iob->channel;\n\tu16 peer_level;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"idxrdcb\");\n\n\trc = qeth_idx_check_activate_response(card, channel, iob);\n\tif (rc)\n\t\tgoto out;\n\n\tmemcpy(&peer_level, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);\n\tif (peer_level != qeth_peer_func_level(card->info.func_level)) {\n\t\tQETH_DBF_MESSAGE(2, \"IDX_ACTIVATE on channel %x: function level mismatch (sent: %#x, received: %#x)\\n\",\n\t\t\t\t CCW_DEVID(channel->ccwdev),\n\t\t\t\t card->info.func_level, peer_level);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(&card->token.issuer_rm_r,\n\t       QETH_IDX_ACT_ISSUER_RM_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(&card->info.mcl_level[0],\n\t       QETH_IDX_REPLY_LEVEL(iob->data), QETH_MCL_LENGTH);\n\nout:\n\tqeth_notify_cmd(iob, rc);\n\tqeth_put_cmd(iob);\n}\n\nstatic void qeth_idx_activate_write_channel_cb(struct qeth_card *card,\n\t\t\t\t\t       struct qeth_cmd_buffer *iob,\n\t\t\t\t\t       unsigned int data_length)\n{\n\tstruct qeth_channel *channel = iob->channel;\n\tu16 peer_level;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"idxwrcb\");\n\n\trc = qeth_idx_check_activate_response(card, channel, iob);\n\tif (rc)\n\t\tgoto out;\n\n\tmemcpy(&peer_level, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);\n\tif ((peer_level & ~0x0100) !=\n\t    qeth_peer_func_level(card->info.func_level)) {\n\t\tQETH_DBF_MESSAGE(2, \"IDX_ACTIVATE on channel %x: function level mismatch (sent: %#x, received: %#x)\\n\",\n\t\t\t\t CCW_DEVID(channel->ccwdev),\n\t\t\t\t card->info.func_level, peer_level);\n\t\trc = -EINVAL;\n\t}\n\nout:\n\tqeth_notify_cmd(iob, rc);\n\tqeth_put_cmd(iob);\n}\n\nstatic void qeth_idx_setup_activate_cmd(struct qeth_card *card,\n\t\t\t\t\tstruct qeth_cmd_buffer *iob)\n{\n\tu16 addr = (card->info.cula << 8) + card->info.unit_addr2;\n\tu8 port = ((u8)card->dev->dev_port) | 0x80;\n\tstruct ccw1 *ccw = __ccw_from_cmd(iob);\n\n\tqeth_setup_ccw(&ccw[0], CCW_CMD_WRITE, CCW_FLAG_CC, IDX_ACTIVATE_SIZE,\n\t\t       iob->data);\n\tqeth_setup_ccw(&ccw[1], CCW_CMD_READ, 0, iob->length, iob->data);\n\tiob->finalize = qeth_idx_finalize_cmd;\n\n\tport |= QETH_IDX_ACT_INVAL_FRAME;\n\tmemcpy(QETH_IDX_ACT_PNO(iob->data), &port, 1);\n\tmemcpy(QETH_IDX_ACT_ISSUER_RM_TOKEN(iob->data),\n\t       &card->token.issuer_rm_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_IDX_ACT_FUNC_LEVEL(iob->data),\n\t       &card->info.func_level, 2);\n\tmemcpy(QETH_IDX_ACT_QDIO_DEV_CUA(iob->data), &card->info.ddev_devno, 2);\n\tmemcpy(QETH_IDX_ACT_QDIO_DEV_REALADDR(iob->data), &addr, 2);\n}\n\nstatic int qeth_idx_activate_read_channel(struct qeth_card *card)\n{\n\tstruct qeth_channel *channel = &card->read;\n\tstruct qeth_cmd_buffer *iob;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"idxread\");\n\n\tiob = qeth_alloc_cmd(channel, QETH_BUFSIZE, 2, QETH_TIMEOUT);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tmemcpy(iob->data, IDX_ACTIVATE_READ, IDX_ACTIVATE_SIZE);\n\tqeth_idx_setup_activate_cmd(card, iob);\n\tiob->callback = qeth_idx_activate_read_channel_cb;\n\n\trc = qeth_send_control_data(card, iob, NULL, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tchannel->state = CH_STATE_UP;\n\treturn 0;\n}\n\nstatic int qeth_idx_activate_write_channel(struct qeth_card *card)\n{\n\tstruct qeth_channel *channel = &card->write;\n\tstruct qeth_cmd_buffer *iob;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"idxwrite\");\n\n\tiob = qeth_alloc_cmd(channel, QETH_BUFSIZE, 2, QETH_TIMEOUT);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tmemcpy(iob->data, IDX_ACTIVATE_WRITE, IDX_ACTIVATE_SIZE);\n\tqeth_idx_setup_activate_cmd(card, iob);\n\tiob->callback = qeth_idx_activate_write_channel_cb;\n\n\trc = qeth_send_control_data(card, iob, NULL, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tchannel->state = CH_STATE_UP;\n\treturn 0;\n}\n\nstatic int qeth_cm_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"cmenblcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.cm_filter_r,\n\t       QETH_CM_ENABLE_RESP_FILTER_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\treturn 0;\n}\n\nstatic int qeth_cm_enable(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"cmenable\");\n\n\tiob = qeth_mpc_alloc_cmd(card, CM_ENABLE, CM_ENABLE_SIZE);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tmemcpy(QETH_CM_ENABLE_ISSUER_RM_TOKEN(iob->data),\n\t       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.cm_filter_w, QETH_MPC_TOKEN_LENGTH);\n\n\treturn qeth_send_control_data(card, iob, qeth_cm_enable_cb, NULL);\n}\n\nstatic int qeth_cm_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"cmsetpcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.cm_connection_r,\n\t       QETH_CM_SETUP_RESP_DEST_ADDR(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\treturn 0;\n}\n\nstatic int qeth_cm_setup(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"cmsetup\");\n\n\tiob = qeth_mpc_alloc_cmd(card, CM_SETUP, CM_SETUP_SIZE);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tmemcpy(QETH_CM_SETUP_DEST_ADDR(iob->data),\n\t       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_SETUP_CONNECTION_TOKEN(iob->data),\n\t       &card->token.cm_connection_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_SETUP_FILTER_TOKEN(iob->data),\n\t       &card->token.cm_filter_r, QETH_MPC_TOKEN_LENGTH);\n\treturn qeth_send_control_data(card, iob, qeth_cm_setup_cb, NULL);\n}\n\nstatic bool qeth_is_supported_link_type(struct qeth_card *card, u8 link_type)\n{\n\tif (link_type == QETH_LINK_TYPE_LANE_TR ||\n\t    link_type == QETH_LINK_TYPE_HSTR) {\n\t\tdev_err(&card->gdev->dev, \"Unsupported Token Ring device\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int qeth_update_max_mtu(struct qeth_card *card, unsigned int max_mtu)\n{\n\tstruct net_device *dev = card->dev;\n\tunsigned int new_mtu;\n\n\tif (!max_mtu) {\n\t\t \n\t\tif (IS_IQD(card))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tmax_mtu = ETH_MAX_MTU;\n\t}\n\n\trtnl_lock();\n\tif (IS_IQD(card)) {\n\t\t \n\t\tnew_mtu = (dev->mtu == dev->max_mtu) ? max_mtu : dev->mtu;\n\n\t\t \n\t\tcard->qdio.in_buf_size = max_mtu + 2 * PAGE_SIZE;\n\t\tif (dev->max_mtu && dev->max_mtu != max_mtu)\n\t\t\tqeth_free_qdio_queues(card);\n\t} else {\n\t\tif (dev->mtu)\n\t\t\tnew_mtu = dev->mtu;\n\t\t \n\t\telse if (IS_LAYER2(card))\n\t\t\tnew_mtu = ETH_DATA_LEN;\n\t\telse\n\t\t\tnew_mtu = ETH_DATA_LEN - 8;  \n\t}\n\n\tdev->max_mtu = max_mtu;\n\tdev->mtu = min(new_mtu, max_mtu);\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic int qeth_get_mtu_outof_framesize(int framesize)\n{\n\tswitch (framesize) {\n\tcase 0x4000:\n\t\treturn 8192;\n\tcase 0x6000:\n\t\treturn 16384;\n\tcase 0xa000:\n\t\treturn 32768;\n\tcase 0xffff:\n\t\treturn 57344;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int qeth_ulp_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\t__u16 mtu, framesize;\n\t__u16 len;\n\tstruct qeth_cmd_buffer *iob;\n\tu8 link_type = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"ulpenacb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.ulp_filter_r,\n\t       QETH_ULP_ENABLE_RESP_FILTER_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tif (IS_IQD(card)) {\n\t\tmemcpy(&framesize, QETH_ULP_ENABLE_RESP_MAX_MTU(iob->data), 2);\n\t\tmtu = qeth_get_mtu_outof_framesize(framesize);\n\t} else {\n\t\tmtu = *(__u16 *)QETH_ULP_ENABLE_RESP_MAX_MTU(iob->data);\n\t}\n\t*(u16 *)reply->param = mtu;\n\n\tmemcpy(&len, QETH_ULP_ENABLE_RESP_DIFINFO_LEN(iob->data), 2);\n\tif (len >= QETH_MPC_DIFINFO_LEN_INDICATES_LINK_TYPE) {\n\t\tmemcpy(&link_type,\n\t\t       QETH_ULP_ENABLE_RESP_LINK_TYPE(iob->data), 1);\n\t\tif (!qeth_is_supported_link_type(card, link_type))\n\t\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tcard->info.link_type = link_type;\n\tQETH_CARD_TEXT_(card, 2, \"link%d\", card->info.link_type);\n\treturn 0;\n}\n\nstatic u8 qeth_mpc_select_prot_type(struct qeth_card *card)\n{\n\treturn IS_LAYER2(card) ? QETH_MPC_PROT_L2 : QETH_MPC_PROT_L3;\n}\n\nstatic int qeth_ulp_enable(struct qeth_card *card)\n{\n\tu8 prot_type = qeth_mpc_select_prot_type(card);\n\tstruct qeth_cmd_buffer *iob;\n\tu16 max_mtu;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"ulpenabl\");\n\n\tiob = qeth_mpc_alloc_cmd(card, ULP_ENABLE, ULP_ENABLE_SIZE);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\t*(QETH_ULP_ENABLE_LINKNUM(iob->data)) = (u8) card->dev->dev_port;\n\tmemcpy(QETH_ULP_ENABLE_PROT_TYPE(iob->data), &prot_type, 1);\n\tmemcpy(QETH_ULP_ENABLE_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.ulp_filter_w, QETH_MPC_TOKEN_LENGTH);\n\trc = qeth_send_control_data(card, iob, qeth_ulp_enable_cb, &max_mtu);\n\tif (rc)\n\t\treturn rc;\n\treturn qeth_update_max_mtu(card, max_mtu);\n}\n\nstatic int qeth_ulp_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"ulpstpcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.ulp_connection_r,\n\t       QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tif (!strncmp(\"00S\", QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t\t     3)) {\n\t\tQETH_CARD_TEXT(card, 2, \"olmlimit\");\n\t\tdev_err(&card->gdev->dev, \"A connection could not be \"\n\t\t\t\"established because of an OLM limit\\n\");\n\t\treturn -EMLINK;\n\t}\n\treturn 0;\n}\n\nstatic int qeth_ulp_setup(struct qeth_card *card)\n{\n\t__u16 temp;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"ulpsetup\");\n\n\tiob = qeth_mpc_alloc_cmd(card, ULP_SETUP, ULP_SETUP_SIZE);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tmemcpy(QETH_ULP_SETUP_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_SETUP_CONNECTION_TOKEN(iob->data),\n\t       &card->token.ulp_connection_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_SETUP_FILTER_TOKEN(iob->data),\n\t       &card->token.ulp_filter_r, QETH_MPC_TOKEN_LENGTH);\n\n\tmemcpy(QETH_ULP_SETUP_CUA(iob->data), &card->info.ddev_devno, 2);\n\ttemp = (card->info.cula << 8) + card->info.unit_addr2;\n\tmemcpy(QETH_ULP_SETUP_REAL_DEVADDR(iob->data), &temp, 2);\n\treturn qeth_send_control_data(card, iob, qeth_ulp_setup_cb, NULL);\n}\n\nstatic int qeth_alloc_out_buf(struct qeth_qdio_out_q *q, unsigned int bidx,\n\t\t\t      gfp_t gfp)\n{\n\tstruct qeth_qdio_out_buffer *newbuf;\n\n\tnewbuf = kmem_cache_zalloc(qeth_qdio_outbuf_cache, gfp);\n\tif (!newbuf)\n\t\treturn -ENOMEM;\n\n\tnewbuf->buffer = q->qdio_bufs[bidx];\n\tskb_queue_head_init(&newbuf->skb_list);\n\tlockdep_set_class(&newbuf->skb_list.lock, &qdio_out_skb_queue_key);\n\tatomic_set(&newbuf->state, QETH_QDIO_BUF_EMPTY);\n\tq->bufs[bidx] = newbuf;\n\treturn 0;\n}\n\nstatic void qeth_free_output_queue(struct qeth_qdio_out_q *q)\n{\n\tif (!q)\n\t\treturn;\n\n\tqeth_drain_output_queue(q, true);\n\tqdio_free_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q);\n\tkfree(q);\n}\n\nstatic struct qeth_qdio_out_q *qeth_alloc_output_queue(void)\n{\n\tstruct qeth_qdio_out_q *q = kzalloc(sizeof(*q), GFP_KERNEL);\n\tunsigned int i;\n\n\tif (!q)\n\t\treturn NULL;\n\n\tif (qdio_alloc_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q))\n\t\tgoto err_qdio_bufs;\n\n\tfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; i++) {\n\t\tif (qeth_alloc_out_buf(q, i, GFP_KERNEL))\n\t\t\tgoto err_out_bufs;\n\t}\n\n\treturn q;\n\nerr_out_bufs:\n\twhile (i > 0)\n\t\tqeth_free_out_buf(q->bufs[--i]);\n\tqdio_free_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q);\nerr_qdio_bufs:\n\tkfree(q);\n\treturn NULL;\n}\n\nstatic void qeth_tx_completion_timer(struct timer_list *timer)\n{\n\tstruct qeth_qdio_out_q *queue = from_timer(queue, timer, timer);\n\n\tnapi_schedule(&queue->napi);\n\tQETH_TXQ_STAT_INC(queue, completion_timer);\n}\n\nstatic int qeth_alloc_qdio_queues(struct qeth_card *card)\n{\n\tunsigned int i;\n\n\tQETH_CARD_TEXT(card, 2, \"allcqdbf\");\n\n\tif (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED,\n\t\tQETH_QDIO_ALLOCATED) != QETH_QDIO_UNINITIALIZED)\n\t\treturn 0;\n\n\t \n\tif (qeth_alloc_buffer_pool(card))\n\t\tgoto out_buffer_pool;\n\n\t \n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tstruct qeth_qdio_out_q *queue;\n\n\t\tqueue = qeth_alloc_output_queue();\n\t\tif (!queue)\n\t\t\tgoto out_freeoutq;\n\t\tQETH_CARD_TEXT_(card, 2, \"outq %i\", i);\n\t\tQETH_CARD_HEX(card, 2, &queue, sizeof(void *));\n\t\tcard->qdio.out_qs[i] = queue;\n\t\tqueue->card = card;\n\t\tqueue->queue_no = i;\n\t\tINIT_LIST_HEAD(&queue->pending_bufs);\n\t\tspin_lock_init(&queue->lock);\n\t\ttimer_setup(&queue->timer, qeth_tx_completion_timer, 0);\n\t\tif (IS_IQD(card)) {\n\t\t\tqueue->coalesce_usecs = QETH_TX_COALESCE_USECS;\n\t\t\tqueue->max_coalesced_frames = QETH_TX_MAX_COALESCED_FRAMES;\n\t\t\tqueue->rescan_usecs = QETH_TX_TIMER_USECS;\n\t\t} else {\n\t\t\tqueue->coalesce_usecs = USEC_PER_SEC;\n\t\t\tqueue->max_coalesced_frames = 0;\n\t\t\tqueue->rescan_usecs = 10 * USEC_PER_SEC;\n\t\t}\n\t\tqueue->priority = QETH_QIB_PQUE_PRIO_DEFAULT;\n\t}\n\n\t \n\tif (qeth_alloc_cq(card))\n\t\tgoto out_freeoutq;\n\n\treturn 0;\n\nout_freeoutq:\n\twhile (i > 0) {\n\t\tqeth_free_output_queue(card->qdio.out_qs[--i]);\n\t\tcard->qdio.out_qs[i] = NULL;\n\t}\n\tqeth_free_buffer_pool(card);\nout_buffer_pool:\n\tatomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);\n\treturn -ENOMEM;\n}\n\nstatic void qeth_free_qdio_queues(struct qeth_card *card)\n{\n\tint i, j;\n\n\tif (atomic_xchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED) ==\n\t\tQETH_QDIO_UNINITIALIZED)\n\t\treturn;\n\n\tqeth_free_cq(card);\n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\tif (card->qdio.in_q->bufs[j].rx_skb) {\n\t\t\tconsume_skb(card->qdio.in_q->bufs[j].rx_skb);\n\t\t\tcard->qdio.in_q->bufs[j].rx_skb = NULL;\n\t\t}\n\t}\n\n\t \n\tqeth_free_buffer_pool(card);\n\t \n\tfor (i = 0; i < card->qdio.no_out_queues; i++) {\n\t\tqeth_free_output_queue(card->qdio.out_qs[i]);\n\t\tcard->qdio.out_qs[i] = NULL;\n\t}\n}\n\nstatic void qeth_fill_qib_parms(struct qeth_card *card,\n\t\t\t\tstruct qeth_qib_parms *parms)\n{\n\tstruct qeth_qdio_out_q *queue;\n\tunsigned int i;\n\n\tparms->pcit_magic[0] = 'P';\n\tparms->pcit_magic[1] = 'C';\n\tparms->pcit_magic[2] = 'I';\n\tparms->pcit_magic[3] = 'T';\n\tASCEBC(parms->pcit_magic, sizeof(parms->pcit_magic));\n\tparms->pcit_a = QETH_PCI_THRESHOLD_A(card);\n\tparms->pcit_b = QETH_PCI_THRESHOLD_B(card);\n\tparms->pcit_c = QETH_PCI_TIMER_VALUE(card);\n\n\tparms->blkt_magic[0] = 'B';\n\tparms->blkt_magic[1] = 'L';\n\tparms->blkt_magic[2] = 'K';\n\tparms->blkt_magic[3] = 'T';\n\tASCEBC(parms->blkt_magic, sizeof(parms->blkt_magic));\n\tparms->blkt_total = card->info.blkt.time_total;\n\tparms->blkt_inter_packet = card->info.blkt.inter_packet;\n\tparms->blkt_inter_packet_jumbo = card->info.blkt.inter_packet_jumbo;\n\n\t \n\tif (qeth_uses_tx_prio_queueing(card) || card->qdio.no_out_queues == 1)\n\t\treturn;\n\n\tparms->pque_magic[0] = 'P';\n\tparms->pque_magic[1] = 'Q';\n\tparms->pque_magic[2] = 'U';\n\tparms->pque_magic[3] = 'E';\n\tASCEBC(parms->pque_magic, sizeof(parms->pque_magic));\n\tparms->pque_order = QETH_QIB_PQUE_ORDER_RR;\n\tparms->pque_units = QETH_QIB_PQUE_UNITS_SBAL;\n\n\tqeth_for_each_output_queue(card, queue, i)\n\t\tparms->pque_priority[i] = queue->priority;\n}\n\nstatic int qeth_qdio_activate(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 3, \"qdioact\");\n\treturn qdio_activate(CARD_DDEV(card));\n}\n\nstatic int qeth_dm_act(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"dmact\");\n\n\tiob = qeth_mpc_alloc_cmd(card, DM_ACT, DM_ACT_SIZE);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tmemcpy(QETH_DM_ACT_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_DM_ACT_CONNECTION_TOKEN(iob->data),\n\t       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\n\treturn qeth_send_control_data(card, iob, NULL, NULL);\n}\n\nstatic int qeth_mpc_initialize(struct qeth_card *card)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"mpcinit\");\n\n\trc = qeth_issue_next_read(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"1err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_cm_enable(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"2err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_cm_setup(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"3err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_ulp_enable(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"4err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_ulp_setup(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"5err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_alloc_qdio_queues(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"5err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_qdio_establish(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"6err%d\", rc);\n\t\tqeth_free_qdio_queues(card);\n\t\treturn rc;\n\t}\n\trc = qeth_qdio_activate(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"7err%d\", rc);\n\t\treturn rc;\n\t}\n\trc = qeth_dm_act(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"8err%d\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void qeth_print_status_message(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\t\t \n\t\tif (!card->info.mcl_level[0]) {\n\t\t\tscnprintf(card->info.mcl_level,\n\t\t\t\t  sizeof(card->info.mcl_level),\n\t\t\t\t  \"%02x%02x\",\n\t\t\t\t  card->info.mcl_level[2],\n\t\t\t\t  card->info.mcl_level[3]);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase QETH_CARD_TYPE_IQD:\n\t\tif (IS_VM_NIC(card) || (card->info.mcl_level[0] & 0x80)) {\n\t\t\tcard->info.mcl_level[0] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[0]];\n\t\t\tcard->info.mcl_level[1] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[1]];\n\t\t\tcard->info.mcl_level[2] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[2]];\n\t\t\tcard->info.mcl_level[3] = (char) _ebcasc[(__u8)\n\t\t\t\tcard->info.mcl_level[3]];\n\t\t\tcard->info.mcl_level[QETH_MCL_LENGTH] = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmemset(&card->info.mcl_level[0], 0, QETH_MCL_LENGTH + 1);\n\t}\n\tdev_info(&card->gdev->dev,\n\t\t \"Device is a%s card%s%s%s\\nwith link type %s.\\n\",\n\t\t qeth_get_cardname(card),\n\t\t (card->info.mcl_level[0]) ? \" (level: \" : \"\",\n\t\t (card->info.mcl_level[0]) ? card->info.mcl_level : \"\",\n\t\t (card->info.mcl_level[0]) ? \")\" : \"\",\n\t\t qeth_get_cardname_short(card));\n}\n\nstatic void qeth_initialize_working_pool_list(struct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *entry;\n\n\tQETH_CARD_TEXT(card, 5, \"inwrklst\");\n\n\tlist_for_each_entry(entry,\n\t\t\t    &card->qdio.init_pool.entry_list, init_list) {\n\t\tqeth_put_buffer_pool_entry(card, entry);\n\t}\n}\n\nstatic struct qeth_buffer_pool_entry *qeth_find_free_buffer_pool_entry(\n\t\t\t\t\tstruct qeth_card *card)\n{\n\tstruct qeth_buffer_pool_entry *entry;\n\tint i, free;\n\n\tif (list_empty(&card->qdio.in_buf_pool.entry_list))\n\t\treturn NULL;\n\n\tlist_for_each_entry(entry, &card->qdio.in_buf_pool.entry_list, list) {\n\t\tfree = 1;\n\t\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\t\tif (page_count(entry->elements[i]) > 1) {\n\t\t\t\tfree = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (free) {\n\t\t\tlist_del_init(&entry->list);\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\t \n\tentry = list_first_entry(&card->qdio.in_buf_pool.entry_list,\n\t\t\t\t struct qeth_buffer_pool_entry, list);\n\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\tif (page_count(entry->elements[i]) > 1) {\n\t\t\tstruct page *page = dev_alloc_page();\n\n\t\t\tif (!page)\n\t\t\t\treturn NULL;\n\n\t\t\t__free_page(entry->elements[i]);\n\t\t\tentry->elements[i] = page;\n\t\t\tQETH_CARD_STAT_INC(card, rx_sg_alloc_page);\n\t\t}\n\t}\n\tlist_del_init(&entry->list);\n\treturn entry;\n}\n\nstatic int qeth_init_input_buffer(struct qeth_card *card,\n\t\tstruct qeth_qdio_buffer *buf)\n{\n\tstruct qeth_buffer_pool_entry *pool_entry = buf->pool_entry;\n\tint i;\n\n\tif ((card->options.cq == QETH_CQ_ENABLED) && (!buf->rx_skb)) {\n\t\tbuf->rx_skb = netdev_alloc_skb(card->dev,\n\t\t\t\t\t       ETH_HLEN +\n\t\t\t\t\t       sizeof(struct ipv6hdr));\n\t\tif (!buf->rx_skb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!pool_entry) {\n\t\tpool_entry = qeth_find_free_buffer_pool_entry(card);\n\t\tif (!pool_entry)\n\t\t\treturn -ENOBUFS;\n\n\t\tbuf->pool_entry = pool_entry;\n\t}\n\n\t \n\tfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\n\t\tbuf->buffer->element[i].length = PAGE_SIZE;\n\t\tbuf->buffer->element[i].addr =\n\t\t\tpage_to_phys(pool_entry->elements[i]);\n\t\tif (i == QETH_MAX_BUFFER_ELEMENTS(card) - 1)\n\t\t\tbuf->buffer->element[i].eflags = SBAL_EFLAGS_LAST_ENTRY;\n\t\telse\n\t\t\tbuf->buffer->element[i].eflags = 0;\n\t\tbuf->buffer->element[i].sflags = 0;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int qeth_tx_select_bulk_max(struct qeth_card *card,\n\t\t\t\t\t    struct qeth_qdio_out_q *queue)\n{\n\tif (!IS_IQD(card) ||\n\t    qeth_iqd_is_mcast_queue(card, queue) ||\n\t    card->options.cq == QETH_CQ_ENABLED ||\n\t    qdio_get_ssqd_desc(CARD_DDEV(card), &card->ssqd))\n\t\treturn 1;\n\n\treturn card->ssqd.mmwc ? card->ssqd.mmwc : 1;\n}\n\nstatic int qeth_init_qdio_queues(struct qeth_card *card)\n{\n\tunsigned int rx_bufs = card->qdio.in_buf_pool.buf_count;\n\tunsigned int i;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"initqdqs\");\n\n\t \n\tqdio_reset_buffers(card->qdio.in_q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q);\n\tmemset(&card->rx, 0, sizeof(struct qeth_rx));\n\n\tqeth_initialize_working_pool_list(card);\n\t \n\tfor (i = 0; i < rx_bufs; i++) {\n\t\trc = qeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tcard->qdio.in_q->next_buf_to_init = QDIO_BUFNR(rx_bufs);\n\trc = qdio_add_bufs_to_input_queue(CARD_DDEV(card), 0, 0, rx_bufs);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"1err%d\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\trc = qeth_cq_init(card);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t \n\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\tstruct qeth_qdio_out_q *queue = card->qdio.out_qs[i];\n\n\t\tqdio_reset_buffers(queue->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q);\n\t\tqueue->max_elements = QETH_MAX_BUFFER_ELEMENTS(card);\n\t\tqueue->next_buf_to_fill = 0;\n\t\tqueue->do_pack = 0;\n\t\tqueue->prev_hdr = NULL;\n\t\tqueue->coalesced_frames = 0;\n\t\tqueue->bulk_start = 0;\n\t\tqueue->bulk_count = 0;\n\t\tqueue->bulk_max = qeth_tx_select_bulk_max(card, queue);\n\t\tatomic_set(&queue->used_buffers, 0);\n\t\tatomic_set(&queue->set_pci_flags_count, 0);\n\t\tnetdev_tx_reset_queue(netdev_get_tx_queue(card->dev, i));\n\t}\n\treturn 0;\n}\n\nstatic void qeth_ipa_finalize_cmd(struct qeth_card *card,\n\t\t\t\t  struct qeth_cmd_buffer *iob)\n{\n\tqeth_mpc_finalize_cmd(card, iob);\n\n\t \n\t__ipa_cmd(iob)->hdr.seqno = card->seqno.ipa++;\n}\n\nstatic void qeth_prepare_ipa_cmd(struct qeth_card *card,\n\t\t\t\t struct qeth_cmd_buffer *iob, u16 cmd_length)\n{\n\tu8 prot_type = qeth_mpc_select_prot_type(card);\n\tu16 total_length = iob->length;\n\n\tqeth_setup_ccw(__ccw_from_cmd(iob), CCW_CMD_WRITE, 0, total_length,\n\t\t       iob->data);\n\tiob->finalize = qeth_ipa_finalize_cmd;\n\n\tmemcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);\n\tmemcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &total_length, 2);\n\tmemcpy(QETH_IPA_CMD_PROT_TYPE(iob->data), &prot_type, 1);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &cmd_length, 2);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &cmd_length, 2);\n\tmemcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),\n\t       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &cmd_length, 2);\n}\n\nstatic bool qeth_ipa_match_reply(struct qeth_cmd_buffer *iob,\n\t\t\t\t struct qeth_cmd_buffer *reply)\n{\n\tstruct qeth_ipa_cmd *ipa_reply = __ipa_reply(reply);\n\n\treturn ipa_reply && (__ipa_cmd(iob)->hdr.seqno == ipa_reply->hdr.seqno);\n}\n\nstruct qeth_cmd_buffer *qeth_ipa_alloc_cmd(struct qeth_card *card,\n\t\t\t\t\t   enum qeth_ipa_cmds cmd_code,\n\t\t\t\t\t   enum qeth_prot_versions prot,\n\t\t\t\t\t   unsigned int data_length)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipacmd_hdr *hdr;\n\n\tdata_length += offsetof(struct qeth_ipa_cmd, data);\n\tiob = qeth_alloc_cmd(&card->write, IPA_PDU_HEADER_SIZE + data_length, 1,\n\t\t\t     QETH_IPA_TIMEOUT);\n\tif (!iob)\n\t\treturn NULL;\n\n\tqeth_prepare_ipa_cmd(card, iob, data_length);\n\tiob->match = qeth_ipa_match_reply;\n\n\thdr = &__ipa_cmd(iob)->hdr;\n\thdr->command = cmd_code;\n\thdr->initiator = IPA_CMD_INITIATOR_HOST;\n\t \n\thdr->adapter_type = QETH_LINK_TYPE_FAST_ETH;\n\thdr->rel_adapter_no = (u8) card->dev->dev_port;\n\thdr->prim_version_no = IS_LAYER2(card) ? 2 : 1;\n\thdr->param_count = 1;\n\thdr->prot_version = prot;\n\treturn iob;\n}\nEXPORT_SYMBOL_GPL(qeth_ipa_alloc_cmd);\n\nstatic int qeth_send_ipa_cmd_cb(struct qeth_card *card,\n\t\t\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\n\treturn (cmd->hdr.return_code) ? -EIO : 0;\n}\n\n \n\nint qeth_send_ipa_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,\n\t\tint (*reply_cb)(struct qeth_card *, struct qeth_reply*,\n\t\t\tunsigned long),\n\t\tvoid *reply_param)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 4, \"sendipa\");\n\n\tif (card->read_or_write_problem) {\n\t\tqeth_put_cmd(iob);\n\t\treturn -EIO;\n\t}\n\n\tif (reply_cb == NULL)\n\t\treply_cb = qeth_send_ipa_cmd_cb;\n\trc = qeth_send_control_data(card, iob, reply_cb, reply_param);\n\tif (rc == -ETIME) {\n\t\tqeth_clear_ipacmd_list(card);\n\t\tqeth_schedule_recovery(card);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_send_ipa_cmd);\n\nstatic int qeth_send_startlan_cb(struct qeth_card *card,\n\t\t\t\t struct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\n\tif (cmd->hdr.return_code == IPA_RC_LAN_OFFLINE)\n\t\treturn -ENETDOWN;\n\n\treturn (cmd->hdr.return_code) ? -EIO : 0;\n}\n\nstatic int qeth_send_startlan(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"strtlan\");\n\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_STARTLAN, QETH_PROT_NONE, 0);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\treturn qeth_send_ipa_cmd(card, iob, qeth_send_startlan_cb, NULL);\n}\n\nstatic int qeth_setadpparms_inspect_rc(struct qeth_ipa_cmd *cmd)\n{\n\tif (!cmd->hdr.return_code)\n\t\tcmd->hdr.return_code =\n\t\t\tcmd->data.setadapterparms.hdr.return_code;\n\treturn cmd->hdr.return_code;\n}\n\nstatic int qeth_query_setadapterparms_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_query_cmds_supp *query_cmd;\n\n\tQETH_CARD_TEXT(card, 3, \"quyadpcb\");\n\tif (qeth_setadpparms_inspect_rc(cmd))\n\t\treturn -EIO;\n\n\tquery_cmd = &cmd->data.setadapterparms.data.query_cmds_supp;\n\tif (query_cmd->lan_type & 0x7f) {\n\t\tif (!qeth_is_supported_link_type(card, query_cmd->lan_type))\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\tcard->info.link_type = query_cmd->lan_type;\n\t\tQETH_CARD_TEXT_(card, 2, \"lnk %d\", card->info.link_type);\n\t}\n\n\tcard->options.adp.supported = query_cmd->supported_cmds;\n\treturn 0;\n}\n\nstatic struct qeth_cmd_buffer *qeth_get_adapter_cmd(struct qeth_card *card,\n\t\t\t\t\t\t    enum qeth_ipa_setadp_cmd adp_cmd,\n\t\t\t\t\t\t    unsigned int data_length)\n{\n\tstruct qeth_ipacmd_setadpparms_hdr *hdr;\n\tstruct qeth_cmd_buffer *iob;\n\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_SETADAPTERPARMS, QETH_PROT_IPV4,\n\t\t\t\t data_length +\n\t\t\t\t offsetof(struct qeth_ipacmd_setadpparms,\n\t\t\t\t\t  data));\n\tif (!iob)\n\t\treturn NULL;\n\n\thdr = &__ipa_cmd(iob)->data.setadapterparms.hdr;\n\thdr->cmdlength = sizeof(*hdr) + data_length;\n\thdr->command_code = adp_cmd;\n\thdr->used_total = 1;\n\thdr->seq_no = 1;\n\treturn iob;\n}\n\nstatic int qeth_query_setadapterparms(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 3, \"queryadp\");\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_COMMANDS_SUPPORTED,\n\t\t\t\t   SETADP_DATA_SIZEOF(query_cmds_supp));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\trc = qeth_send_ipa_cmd(card, iob, qeth_query_setadapterparms_cb, NULL);\n\treturn rc;\n}\n\nstatic int qeth_query_ipassists_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 2, \"qipasscb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\n\tswitch (cmd->hdr.return_code) {\n\tcase IPA_RC_SUCCESS:\n\t\tbreak;\n\tcase IPA_RC_NOTSUPP:\n\tcase IPA_RC_L2_UNSUPPORTED_CMD:\n\t\tQETH_CARD_TEXT(card, 2, \"ipaunsup\");\n\t\tcard->options.ipa4.supported |= IPA_SETADAPTERPARMS;\n\t\tcard->options.ipa6.supported |= IPA_SETADAPTERPARMS;\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tQETH_DBF_MESSAGE(1, \"IPA_CMD_QIPASSIST on device %x: Unhandled rc=%#x\\n\",\n\t\t\t\t CARD_DEVID(card), cmd->hdr.return_code);\n\t\treturn -EIO;\n\t}\n\n\tif (cmd->hdr.prot_version == QETH_PROT_IPV4)\n\t\tcard->options.ipa4 = cmd->hdr.assists;\n\telse if (cmd->hdr.prot_version == QETH_PROT_IPV6)\n\t\tcard->options.ipa6 = cmd->hdr.assists;\n\telse\n\t\tQETH_DBF_MESSAGE(1, \"IPA_CMD_QIPASSIST on device %x: Flawed LIC detected\\n\",\n\t\t\t\t CARD_DEVID(card));\n\treturn 0;\n}\n\nstatic int qeth_query_ipassists(struct qeth_card *card,\n\t\t\t\tenum qeth_prot_versions prot)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT_(card, 2, \"qipassi%i\", prot);\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_QIPASSIST, prot, 0);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\trc = qeth_send_ipa_cmd(card, iob, qeth_query_ipassists_cb, NULL);\n\treturn rc;\n}\n\nstatic int qeth_query_switch_attributes_cb(struct qeth_card *card,\n\t\t\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_query_switch_attributes *attrs;\n\tstruct qeth_switch_info *sw_info;\n\n\tQETH_CARD_TEXT(card, 2, \"qswiatcb\");\n\tif (qeth_setadpparms_inspect_rc(cmd))\n\t\treturn -EIO;\n\n\tsw_info = (struct qeth_switch_info *)reply->param;\n\tattrs = &cmd->data.setadapterparms.data.query_switch_attributes;\n\tsw_info->capabilities = attrs->capabilities;\n\tsw_info->settings = attrs->settings;\n\tQETH_CARD_TEXT_(card, 2, \"%04x%04x\", sw_info->capabilities,\n\t\t\tsw_info->settings);\n\treturn 0;\n}\n\nint qeth_query_switch_attributes(struct qeth_card *card,\n\t\t\t\t struct qeth_switch_info *sw_info)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"qswiattr\");\n\tif (!qeth_adp_supported(card, IPA_SETADP_QUERY_SWITCH_ATTRIBUTES))\n\t\treturn -EOPNOTSUPP;\n\tif (!netif_carrier_ok(card->dev))\n\t\treturn -ENOMEDIUM;\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_SWITCH_ATTRIBUTES, 0);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\treturn qeth_send_ipa_cmd(card, iob,\n\t\t\t\tqeth_query_switch_attributes_cb, sw_info);\n}\n\nstruct qeth_cmd_buffer *qeth_get_diag_cmd(struct qeth_card *card,\n\t\t\t\t\t  enum qeth_diags_cmds sub_cmd,\n\t\t\t\t\t  unsigned int data_length)\n{\n\tstruct qeth_ipacmd_diagass *cmd;\n\tstruct qeth_cmd_buffer *iob;\n\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_SET_DIAG_ASS, QETH_PROT_NONE,\n\t\t\t\t DIAG_HDR_LEN + data_length);\n\tif (!iob)\n\t\treturn NULL;\n\n\tcmd = &__ipa_cmd(iob)->data.diagass;\n\tcmd->subcmd_len = DIAG_SUB_HDR_LEN + data_length;\n\tcmd->subcmd = sub_cmd;\n\treturn iob;\n}\nEXPORT_SYMBOL_GPL(qeth_get_diag_cmd);\n\nstatic int qeth_query_setdiagass_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tu16 rc = cmd->hdr.return_code;\n\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"diagq:%x\", rc);\n\t\treturn -EIO;\n\t}\n\n\tcard->info.diagass_support = cmd->data.diagass.ext;\n\treturn 0;\n}\n\nstatic int qeth_query_setdiagass(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"qdiagass\");\n\tiob = qeth_get_diag_cmd(card, QETH_DIAGS_CMD_QUERY, 0);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\treturn qeth_send_ipa_cmd(card, iob, qeth_query_setdiagass_cb, NULL);\n}\n\nstatic void qeth_get_trap_id(struct qeth_card *card, struct qeth_trap_id *tid)\n{\n\tunsigned long info = get_zeroed_page(GFP_KERNEL);\n\tstruct sysinfo_2_2_2 *info222 = (struct sysinfo_2_2_2 *)info;\n\tstruct sysinfo_3_2_2 *info322 = (struct sysinfo_3_2_2 *)info;\n\tstruct ccw_dev_id ccwid;\n\tint level;\n\n\ttid->chpid = card->info.chpid;\n\tccw_device_get_id(CARD_RDEV(card), &ccwid);\n\ttid->ssid = ccwid.ssid;\n\ttid->devno = ccwid.devno;\n\tif (!info)\n\t\treturn;\n\tlevel = stsi(NULL, 0, 0, 0);\n\tif ((level >= 2) && (stsi(info222, 2, 2, 2) == 0))\n\t\ttid->lparnr = info222->lpar_number;\n\tif ((level >= 3) && (stsi(info322, 3, 2, 2) == 0)) {\n\t\tEBCASC(info322->vm[0].name, sizeof(info322->vm[0].name));\n\t\tmemcpy(tid->vmname, info322->vm[0].name, sizeof(tid->vmname));\n\t}\n\tfree_page(info);\n}\n\nstatic int qeth_hw_trap_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tu16 rc = cmd->hdr.return_code;\n\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"trapc:%x\", rc);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nint qeth_hw_trap(struct qeth_card *card, enum qeth_diags_trap_action action)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 2, \"diagtrap\");\n\tiob = qeth_get_diag_cmd(card, QETH_DIAGS_CMD_TRAP, 64);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\tcmd->data.diagass.type = 1;\n\tcmd->data.diagass.action = action;\n\tswitch (action) {\n\tcase QETH_DIAGS_TRAP_ARM:\n\t\tcmd->data.diagass.options = 0x0003;\n\t\tcmd->data.diagass.ext = 0x00010000 +\n\t\t\tsizeof(struct qeth_trap_id);\n\t\tqeth_get_trap_id(card,\n\t\t\t(struct qeth_trap_id *)cmd->data.diagass.cdata);\n\t\tbreak;\n\tcase QETH_DIAGS_TRAP_DISARM:\n\t\tcmd->data.diagass.options = 0x0001;\n\t\tbreak;\n\tcase QETH_DIAGS_TRAP_CAPTURE:\n\t\tbreak;\n\t}\n\treturn qeth_send_ipa_cmd(card, iob, qeth_hw_trap_cb, NULL);\n}\n\nstatic int qeth_check_qdio_errors(struct qeth_card *card,\n\t\t\t\t  struct qdio_buffer *buf,\n\t\t\t\t  unsigned int qdio_error,\n\t\t\t\t  const char *dbftext)\n{\n\tif (qdio_error) {\n\t\tQETH_CARD_TEXT(card, 2, dbftext);\n\t\tQETH_CARD_TEXT_(card, 2, \" F15=%02X\",\n\t\t\t       buf->element[15].sflags);\n\t\tQETH_CARD_TEXT_(card, 2, \" F14=%02X\",\n\t\t\t       buf->element[14].sflags);\n\t\tQETH_CARD_TEXT_(card, 2, \" qerr=%X\", qdio_error);\n\t\tif ((buf->element[15].sflags) == 0x12) {\n\t\t\tQETH_CARD_STAT_INC(card, rx_fifo_errors);\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int qeth_rx_refill_queue(struct qeth_card *card,\n\t\t\t\t\t unsigned int count)\n{\n\tstruct qeth_qdio_q *queue = card->qdio.in_q;\n\tstruct list_head *lh;\n\tint i;\n\tint rc;\n\tint newcount = 0;\n\n\t \n\tif (count >= QETH_IN_BUF_REQUEUE_THRESHOLD(card)) {\n\t\tfor (i = queue->next_buf_to_init;\n\t\t     i < queue->next_buf_to_init + count; ++i) {\n\t\t\tif (qeth_init_input_buffer(card,\n\t\t\t\t&queue->bufs[QDIO_BUFNR(i)])) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tnewcount++;\n\t\t\t}\n\t\t}\n\n\t\tif (newcount < count) {\n\t\t\t \n\t\t\tatomic_set(&card->force_alloc_skb, 3);\n\t\t\tcount = newcount;\n\t\t} else {\n\t\t\tatomic_add_unless(&card->force_alloc_skb, -1, 0);\n\t\t}\n\n\t\tif (!count) {\n\t\t\ti = 0;\n\t\t\tlist_for_each(lh, &card->qdio.in_buf_pool.entry_list)\n\t\t\t\ti++;\n\t\t\tif (i == card->qdio.in_buf_pool.buf_count) {\n\t\t\t\tQETH_CARD_TEXT(card, 2, \"qsarbw\");\n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t&card->buffer_reclaim_work,\n\t\t\t\t\tQETH_RECLAIM_WORK_TIME);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = qdio_add_bufs_to_input_queue(CARD_DDEV(card), 0,\n\t\t\t\t\t\t  queue->next_buf_to_init,\n\t\t\t\t\t\t  count);\n\t\tif (rc) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"qinberr\");\n\t\t}\n\t\tqueue->next_buf_to_init = QDIO_BUFNR(queue->next_buf_to_init +\n\t\t\t\t\t\t     count);\n\t\treturn count;\n\t}\n\n\treturn 0;\n}\n\nstatic void qeth_buffer_reclaim_work(struct work_struct *work)\n{\n\tstruct qeth_card *card = container_of(to_delayed_work(work),\n\t\t\t\t\t      struct qeth_card,\n\t\t\t\t\t      buffer_reclaim_work);\n\n\tlocal_bh_disable();\n\tnapi_schedule(&card->napi);\n\t \n\tlocal_bh_enable();\n}\n\nstatic void qeth_handle_send_error(struct qeth_card *card,\n\t\tstruct qeth_qdio_out_buffer *buffer, unsigned int qdio_err)\n{\n\tint sbalf15 = buffer->buffer->element[15].sflags;\n\n\tQETH_CARD_TEXT(card, 6, \"hdsnderr\");\n\tqeth_check_qdio_errors(card, buffer->buffer, qdio_err, \"qouterr\");\n\n\tif (!qdio_err)\n\t\treturn;\n\n\tif ((sbalf15 >= 15) && (sbalf15 <= 31))\n\t\treturn;\n\n\tQETH_CARD_TEXT(card, 1, \"lnkfail\");\n\tQETH_CARD_TEXT_(card, 1, \"%04x %02x\",\n\t\t       (u16)qdio_err, (u8)sbalf15);\n}\n\n \nstatic int qeth_prep_flush_pack_buffer(struct qeth_qdio_out_q *queue)\n{\n\tstruct qeth_qdio_out_buffer *buffer;\n\n\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\tif ((atomic_read(&buffer->state) == QETH_QDIO_BUF_EMPTY) &&\n\t    (buffer->next_element_to_fill > 0)) {\n\t\t \n\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\tqueue->next_buf_to_fill =\n\t\t\tQDIO_BUFNR(queue->next_buf_to_fill + 1);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void qeth_switch_to_packing_if_needed(struct qeth_qdio_out_q *queue)\n{\n\tif (!queue->do_pack) {\n\t\tif (atomic_read(&queue->used_buffers)\n\t\t    >= QETH_HIGH_WATERMARK_PACK){\n\t\t\t \n\t\t\tQETH_CARD_TEXT(queue->card, 6, \"np->pack\");\n\t\t\tQETH_TXQ_STAT_INC(queue, packing_mode_switch);\n\t\t\tqueue->do_pack = 1;\n\t\t}\n\t}\n}\n\n \nstatic int qeth_switch_to_nonpacking_if_needed(struct qeth_qdio_out_q *queue)\n{\n\tif (queue->do_pack) {\n\t\tif (atomic_read(&queue->used_buffers)\n\t\t    <= QETH_LOW_WATERMARK_PACK) {\n\t\t\t \n\t\t\tQETH_CARD_TEXT(queue->card, 6, \"pack->np\");\n\t\t\tQETH_TXQ_STAT_INC(queue, packing_mode_switch);\n\t\t\tqueue->do_pack = 0;\n\t\t\treturn qeth_prep_flush_pack_buffer(queue);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void qeth_flush_buffers(struct qeth_qdio_out_q *queue, int index,\n\t\t\t       int count)\n{\n\tstruct qeth_qdio_out_buffer *buf = queue->bufs[index];\n\tstruct qeth_card *card = queue->card;\n\tunsigned int frames, usecs;\n\tstruct qaob *aob = NULL;\n\tint rc;\n\tint i;\n\n\tfor (i = index; i < index + count; ++i) {\n\t\tunsigned int bidx = QDIO_BUFNR(i);\n\t\tstruct sk_buff *skb;\n\n\t\tbuf = queue->bufs[bidx];\n\t\tbuf->buffer->element[buf->next_element_to_fill - 1].eflags |=\n\t\t\t\tSBAL_EFLAGS_LAST_ENTRY;\n\t\tqueue->coalesced_frames += buf->frames;\n\n\t\tif (IS_IQD(card)) {\n\t\t\tskb_queue_walk(&buf->skb_list, skb)\n\t\t\t\tskb_tx_timestamp(skb);\n\t\t}\n\t}\n\n\tif (IS_IQD(card)) {\n\t\tif (card->options.cq == QETH_CQ_ENABLED &&\n\t\t    !qeth_iqd_is_mcast_queue(card, queue) &&\n\t\t    count == 1) {\n\t\t\tif (!buf->aob)\n\t\t\t\tbuf->aob = kmem_cache_zalloc(qeth_qaob_cache,\n\t\t\t\t\t\t\t     GFP_ATOMIC);\n\t\t\tif (buf->aob) {\n\t\t\t\tstruct qeth_qaob_priv1 *priv;\n\n\t\t\t\taob = buf->aob;\n\t\t\t\tpriv = (struct qeth_qaob_priv1 *)&aob->user1;\n\t\t\t\tpriv->state = QETH_QAOB_ISSUED;\n\t\t\t\tpriv->queue_no = queue->queue_no;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!queue->do_pack) {\n\t\t\tif ((atomic_read(&queue->used_buffers) >=\n\t\t\t\t(QETH_HIGH_WATERMARK_PACK -\n\t\t\t\t QETH_WATERMARK_PACK_FUZZ)) &&\n\t\t\t    !atomic_read(&queue->set_pci_flags_count)) {\n\t\t\t\t \n\t\t\t\tatomic_inc(&queue->set_pci_flags_count);\n\t\t\t\tbuf->buffer->element[0].sflags |= SBAL_SFLAGS0_PCI_REQ;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!atomic_read(&queue->set_pci_flags_count)) {\n\t\t\t\t \n\t\t\t\tatomic_inc(&queue->set_pci_flags_count);\n\t\t\t\tbuf->buffer->element[0].sflags |= SBAL_SFLAGS0_PCI_REQ;\n\t\t\t}\n\t\t}\n\t}\n\n\tQETH_TXQ_STAT_INC(queue, doorbell);\n\trc = qdio_add_bufs_to_output_queue(CARD_DDEV(card), queue->queue_no,\n\t\t\t\t\t   index, count, aob);\n\n\tswitch (rc) {\n\tcase 0:\n\tcase -ENOBUFS:\n\t\t \n\n\t\t \n\t\tframes = READ_ONCE(queue->max_coalesced_frames);\n\t\tusecs = READ_ONCE(queue->coalesce_usecs);\n\n\t\tif (frames && queue->coalesced_frames >= frames) {\n\t\t\tnapi_schedule(&queue->napi);\n\t\t\tqueue->coalesced_frames = 0;\n\t\t\tQETH_TXQ_STAT_INC(queue, coal_frames);\n\t\t} else if (qeth_use_tx_irqs(card) &&\n\t\t\t   atomic_read(&queue->used_buffers) >= 32) {\n\t\t\t \n\t\t\tnapi_schedule(&queue->napi);\n\t\t\tQETH_TXQ_STAT_INC(queue, coal_frames);\n\t\t} else if (usecs) {\n\t\t\tqeth_tx_arm_timer(queue, usecs);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tQETH_CARD_TEXT(queue->card, 2, \"flushbuf\");\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" q%d\", queue->queue_no);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" idx%d\", index);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" c%d\", count);\n\t\tQETH_CARD_TEXT_(queue->card, 2, \" err%d\", rc);\n\n\t\t \n\t\tqeth_schedule_recovery(queue->card);\n\t}\n}\n\nstatic void qeth_flush_queue(struct qeth_qdio_out_q *queue)\n{\n\tqeth_flush_buffers(queue, queue->bulk_start, queue->bulk_count);\n\n\tqueue->bulk_start = QDIO_BUFNR(queue->bulk_start + queue->bulk_count);\n\tqueue->prev_hdr = NULL;\n\tqueue->bulk_count = 0;\n}\n\nstatic void qeth_check_outbound_queue(struct qeth_qdio_out_q *queue)\n{\n\t \n\tif ((atomic_read(&queue->used_buffers) <= QETH_LOW_WATERMARK_PACK) ||\n\t    !atomic_read(&queue->set_pci_flags_count)) {\n\t\tunsigned int index, flush_cnt;\n\n\t\tspin_lock(&queue->lock);\n\n\t\tindex = queue->next_buf_to_fill;\n\n\t\tflush_cnt = qeth_switch_to_nonpacking_if_needed(queue);\n\t\tif (!flush_cnt && !atomic_read(&queue->set_pci_flags_count))\n\t\t\tflush_cnt = qeth_prep_flush_pack_buffer(queue);\n\n\t\tif (flush_cnt) {\n\t\t\tqeth_flush_buffers(queue, index, flush_cnt);\n\t\t\tQETH_TXQ_STAT_ADD(queue, bufs_pack, flush_cnt);\n\t\t}\n\n\t\tspin_unlock(&queue->lock);\n\t}\n}\n\nstatic void qeth_qdio_poll(struct ccw_device *cdev, unsigned long card_ptr)\n{\n\tstruct qeth_card *card = (struct qeth_card *)card_ptr;\n\n\tnapi_schedule_irqoff(&card->napi);\n}\n\nint qeth_configure_cq(struct qeth_card *card, enum qeth_cq cq)\n{\n\tint rc;\n\n\tif (card->options.cq ==  QETH_CQ_NOTAVAILABLE) {\n\t\trc = -1;\n\t\tgoto out;\n\t} else {\n\t\tif (card->options.cq == cq) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tqeth_free_qdio_queues(card);\n\t\tcard->options.cq = cq;\n\t\trc = 0;\n\t}\nout:\n\treturn rc;\n\n}\nEXPORT_SYMBOL_GPL(qeth_configure_cq);\n\nstatic void qeth_qdio_handle_aob(struct qeth_card *card, struct qaob *aob)\n{\n\tstruct qeth_qaob_priv1 *priv = (struct qeth_qaob_priv1 *)&aob->user1;\n\tunsigned int queue_no = priv->queue_no;\n\n\tBUILD_BUG_ON(sizeof(*priv) > ARRAY_SIZE(aob->user1));\n\n\tif (xchg(&priv->state, QETH_QAOB_DONE) == QETH_QAOB_PENDING &&\n\t    queue_no < card->qdio.no_out_queues)\n\t\tnapi_schedule(&card->qdio.out_qs[queue_no]->napi);\n}\n\nstatic void qeth_qdio_cq_handler(struct qeth_card *card, unsigned int qdio_err,\n\t\t\t\t unsigned int queue, int first_element,\n\t\t\t\t int count)\n{\n\tstruct qeth_qdio_q *cq = card->qdio.c_q;\n\tint i;\n\tint rc;\n\n\tQETH_CARD_TEXT_(card, 5, \"qcqhe%d\", first_element);\n\tQETH_CARD_TEXT_(card, 5, \"qcqhc%d\", count);\n\tQETH_CARD_TEXT_(card, 5, \"qcqherr%d\", qdio_err);\n\n\tif (qdio_err) {\n\t\tnetif_tx_stop_all_queues(card->dev);\n\t\tqeth_schedule_recovery(card);\n\t\treturn;\n\t}\n\n\tfor (i = first_element; i < first_element + count; ++i) {\n\t\tstruct qdio_buffer *buffer = cq->qdio_bufs[QDIO_BUFNR(i)];\n\t\tint e = 0;\n\n\t\twhile ((e < QDIO_MAX_ELEMENTS_PER_BUFFER) &&\n\t\t       buffer->element[e].addr) {\n\t\t\tunsigned long phys_aob_addr = buffer->element[e].addr;\n\n\t\t\tqeth_qdio_handle_aob(card, phys_to_virt(phys_aob_addr));\n\t\t\t++e;\n\t\t}\n\t\tqeth_scrub_qdio_buffer(buffer, QDIO_MAX_ELEMENTS_PER_BUFFER);\n\t}\n\trc = qdio_add_bufs_to_input_queue(CARD_DDEV(card), queue,\n\t\t\t\t\t  cq->next_buf_to_init, count);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t\"QDIO reported an error, rc=%i\\n\", rc);\n\t\tQETH_CARD_TEXT(card, 2, \"qcqherr\");\n\t}\n\n\tcq->next_buf_to_init = QDIO_BUFNR(cq->next_buf_to_init + count);\n}\n\nstatic void qeth_qdio_input_handler(struct ccw_device *ccwdev,\n\t\t\t\t    unsigned int qdio_err, int queue,\n\t\t\t\t    int first_elem, int count,\n\t\t\t\t    unsigned long card_ptr)\n{\n\tstruct qeth_card *card = (struct qeth_card *)card_ptr;\n\n\tQETH_CARD_TEXT_(card, 2, \"qihq%d\", queue);\n\tQETH_CARD_TEXT_(card, 2, \"qiec%d\", qdio_err);\n\n\tif (qdio_err)\n\t\tqeth_schedule_recovery(card);\n}\n\nstatic void qeth_qdio_output_handler(struct ccw_device *ccwdev,\n\t\t\t\t     unsigned int qdio_error, int __queue,\n\t\t\t\t     int first_element, int count,\n\t\t\t\t     unsigned long card_ptr)\n{\n\tstruct qeth_card *card        = (struct qeth_card *) card_ptr;\n\n\tQETH_CARD_TEXT(card, 2, \"achkcond\");\n\tnetif_tx_stop_all_queues(card->dev);\n\tqeth_schedule_recovery(card);\n}\n\n \nstatic int qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb)\n{\n\tstruct vlan_ethhdr *veth = vlan_eth_hdr(skb);\n\tu8 tos;\n\n\tswitch (card->qdio.do_prio_queueing) {\n\tcase QETH_PRIO_Q_ING_TOS:\n\tcase QETH_PRIO_Q_ING_PREC:\n\t\tswitch (vlan_get_protocol(skb)) {\n\t\tcase htons(ETH_P_IP):\n\t\t\ttos = ipv4_get_dsfield(ip_hdr(skb));\n\t\t\tbreak;\n\t\tcase htons(ETH_P_IPV6):\n\t\t\ttos = ipv6_get_dsfield(ipv6_hdr(skb));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn card->qdio.default_out_queue;\n\t\t}\n\t\tif (card->qdio.do_prio_queueing == QETH_PRIO_Q_ING_PREC)\n\t\t\treturn ~tos >> 6 & 3;\n\t\tif (tos & IPTOS_MINCOST)\n\t\t\treturn 3;\n\t\tif (tos & IPTOS_RELIABILITY)\n\t\t\treturn 2;\n\t\tif (tos & IPTOS_THROUGHPUT)\n\t\t\treturn 1;\n\t\tif (tos & IPTOS_LOWDELAY)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase QETH_PRIO_Q_ING_SKB:\n\t\tif (skb->priority > 5)\n\t\t\treturn 0;\n\t\treturn ~skb->priority >> 1 & 3;\n\tcase QETH_PRIO_Q_ING_VLAN:\n\t\tif (veth->h_vlan_proto == htons(ETH_P_8021Q))\n\t\t\treturn ~ntohs(veth->h_vlan_TCI) >>\n\t\t\t       (VLAN_PRIO_SHIFT + 1) & 3;\n\t\tbreak;\n\tcase QETH_PRIO_Q_ING_FIXED:\n\t\treturn card->qdio.default_out_queue;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn card->qdio.default_out_queue;\n}\n\n \nstatic int qeth_get_elements_for_frags(struct sk_buff *skb)\n{\n\tint cnt, elements = 0;\n\n\tfor (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[cnt];\n\n\t\telements += qeth_get_elements_for_range(\n\t\t\t(addr_t)skb_frag_address(frag),\n\t\t\t(addr_t)skb_frag_address(frag) + skb_frag_size(frag));\n\t}\n\treturn elements;\n}\n\n \nstatic unsigned int qeth_count_elements(struct sk_buff *skb,\n\t\t\t\t\tunsigned int data_offset)\n{\n\tunsigned int elements = qeth_get_elements_for_frags(skb);\n\taddr_t end = (addr_t)skb->data + skb_headlen(skb);\n\taddr_t start = (addr_t)skb->data + data_offset;\n\n\tif (start != end)\n\t\telements += qeth_get_elements_for_range(start, end);\n\treturn elements;\n}\n\n#define QETH_HDR_CACHE_OBJ_SIZE\t\t(sizeof(struct qeth_hdr_tso) + \\\n\t\t\t\t\t MAX_TCP_HEADER)\n\n \nstatic int qeth_add_hw_header(struct qeth_qdio_out_q *queue,\n\t\t\t      struct sk_buff *skb, struct qeth_hdr **hdr,\n\t\t\t      unsigned int hdr_len, unsigned int proto_len,\n\t\t\t      unsigned int *elements)\n{\n\tgfp_t gfp = GFP_ATOMIC | (skb_pfmemalloc(skb) ? __GFP_MEMALLOC : 0);\n\tconst unsigned int contiguous = proto_len ? proto_len : 1;\n\tconst unsigned int max_elements = queue->max_elements;\n\tunsigned int __elements;\n\taddr_t start, end;\n\tbool push_ok;\n\tint rc;\n\ncheck_layout:\n\tstart = (addr_t)skb->data - hdr_len;\n\tend = (addr_t)skb->data;\n\n\tif (qeth_get_elements_for_range(start, end + contiguous) == 1) {\n\t\t \n\t\tpush_ok = true;\n\t\t \n\t\tif (skb_is_gso(skb))\n\t\t\t__elements = 1 + qeth_count_elements(skb, proto_len);\n\t\telse\n\t\t\t__elements = qeth_count_elements(skb, 0);\n\t} else if (!proto_len && PAGE_ALIGNED(skb->data)) {\n\t\t \n\t\tpush_ok = true;\n\t\t__elements = 1 + qeth_count_elements(skb, 0);\n\t} else {\n\t\t \n\t\tpush_ok = false;\n\t\t__elements = 1 + qeth_count_elements(skb, proto_len);\n\t}\n\n\t \n\tif (__elements > max_elements) {\n\t\tif (!skb_is_nonlinear(skb)) {\n\t\t\t \n\t\t\tQETH_DBF_MESSAGE(2, \"Dropped an oversized skb (Max Elements=%u / Actual=%u / Length=%u).\\n\",\n\t\t\t\t\t max_elements, __elements, skb->len);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\trc = skb_linearize(skb);\n\t\tif (rc) {\n\t\t\tQETH_TXQ_STAT_INC(queue, skbs_linearized_fail);\n\t\t\treturn rc;\n\t\t}\n\n\t\tQETH_TXQ_STAT_INC(queue, skbs_linearized);\n\t\t \n\t\tgoto check_layout;\n\t}\n\n\t*elements = __elements;\n\t \n\tif (push_ok) {\n\t\t*hdr = skb_push(skb, hdr_len);\n\t\treturn hdr_len;\n\t}\n\n\t \n\tif (hdr_len + proto_len > QETH_HDR_CACHE_OBJ_SIZE)\n\t\treturn -E2BIG;\n\t*hdr = kmem_cache_alloc(qeth_core_header_cache, gfp);\n\tif (!*hdr)\n\t\treturn -ENOMEM;\n\t \n\tskb_copy_from_linear_data(skb, ((char *)*hdr) + hdr_len, proto_len);\n\treturn 0;\n}\n\nstatic bool qeth_iqd_may_bulk(struct qeth_qdio_out_q *queue,\n\t\t\t      struct sk_buff *curr_skb,\n\t\t\t      struct qeth_hdr *curr_hdr)\n{\n\tstruct qeth_qdio_out_buffer *buffer = queue->bufs[queue->bulk_start];\n\tstruct qeth_hdr *prev_hdr = queue->prev_hdr;\n\n\tif (!prev_hdr)\n\t\treturn true;\n\n\t \n\tif (curr_hdr->hdr.l2.id == QETH_HEADER_TYPE_LAYER2) {\n\t\tstruct sk_buff *prev_skb = skb_peek(&buffer->skb_list);\n\n\t\treturn ether_addr_equal(eth_hdr(prev_skb)->h_dest,\n\t\t\t\t\teth_hdr(curr_skb)->h_dest) &&\n\t\t       qeth_l2_same_vlan(&prev_hdr->hdr.l2, &curr_hdr->hdr.l2);\n\t}\n\n\treturn qeth_l3_same_next_hop(&prev_hdr->hdr.l3, &curr_hdr->hdr.l3) &&\n\t       qeth_l3_iqd_same_vlan(&prev_hdr->hdr.l3, &curr_hdr->hdr.l3);\n}\n\n \nstatic unsigned int qeth_fill_buffer(struct qeth_qdio_out_buffer *buf,\n\t\t\t\t     struct sk_buff *skb, struct qeth_hdr *hdr,\n\t\t\t\t     unsigned int offset, unsigned int hd_len)\n{\n\tstruct qdio_buffer *buffer = buf->buffer;\n\tint element = buf->next_element_to_fill;\n\tint length = skb_headlen(skb) - offset;\n\tchar *data = skb->data + offset;\n\tunsigned int elem_length, cnt;\n\tbool is_first_elem = true;\n\n\t__skb_queue_tail(&buf->skb_list, skb);\n\n\t \n\tif (hd_len) {\n\t\tis_first_elem = false;\n\n\t\tbuffer->element[element].addr = virt_to_phys(hdr);\n\t\tbuffer->element[element].length = hd_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\n\t\t \n\t\tif ((void *)hdr != skb->data)\n\t\t\t__set_bit(element, buf->from_kmem_cache);\n\t\t \n\t\telse if (length > 0 && !PAGE_ALIGNED(data) &&\n\t\t\t (data == (char *)hdr + hd_len))\n\t\t\tbuffer->element[element].eflags |=\n\t\t\t\tSBAL_EFLAGS_CONTIGUOUS;\n\n\t\telement++;\n\t}\n\n\t \n\twhile (length > 0) {\n\t\telem_length = min_t(unsigned int, length,\n\t\t\t\t    PAGE_SIZE - offset_in_page(data));\n\n\t\tbuffer->element[element].addr = virt_to_phys(data);\n\t\tbuffer->element[element].length = elem_length;\n\t\tlength -= elem_length;\n\t\tif (is_first_elem) {\n\t\t\tis_first_elem = false;\n\t\t\tif (length || skb_is_nonlinear(skb))\n\t\t\t\t \n\t\t\t\tbuffer->element[element].eflags =\n\t\t\t\t\tSBAL_EFLAGS_FIRST_FRAG;\n\t\t\telse\n\t\t\t\tbuffer->element[element].eflags = 0;\n\t\t} else {\n\t\t\tbuffer->element[element].eflags =\n\t\t\t\tSBAL_EFLAGS_MIDDLE_FRAG;\n\t\t}\n\n\t\tdata += elem_length;\n\t\telement++;\n\t}\n\n\t \n\tfor (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[cnt];\n\n\t\tdata = skb_frag_address(frag);\n\t\tlength = skb_frag_size(frag);\n\t\twhile (length > 0) {\n\t\t\telem_length = min_t(unsigned int, length,\n\t\t\t\t\t    PAGE_SIZE - offset_in_page(data));\n\n\t\t\tbuffer->element[element].addr = virt_to_phys(data);\n\t\t\tbuffer->element[element].length = elem_length;\n\t\t\tbuffer->element[element].eflags =\n\t\t\t\tSBAL_EFLAGS_MIDDLE_FRAG;\n\n\t\t\tlength -= elem_length;\n\t\t\tdata += elem_length;\n\t\t\telement++;\n\t\t}\n\t}\n\n\tif (buffer->element[element - 1].eflags)\n\t\tbuffer->element[element - 1].eflags = SBAL_EFLAGS_LAST_FRAG;\n\tbuf->next_element_to_fill = element;\n\treturn element;\n}\n\nstatic int __qeth_xmit(struct qeth_card *card, struct qeth_qdio_out_q *queue,\n\t\t       struct sk_buff *skb, unsigned int elements,\n\t\t       struct qeth_hdr *hdr, unsigned int offset,\n\t\t       unsigned int hd_len)\n{\n\tunsigned int bytes = qdisc_pkt_len(skb);\n\tstruct qeth_qdio_out_buffer *buffer;\n\tunsigned int next_element;\n\tstruct netdev_queue *txq;\n\tbool stopped = false;\n\tbool flush;\n\n\tbuffer = queue->bufs[QDIO_BUFNR(queue->bulk_start + queue->bulk_count)];\n\ttxq = netdev_get_tx_queue(card->dev, skb_get_queue_mapping(skb));\n\n\t \n\tif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY)\n\t\treturn -EBUSY;\n\n\tflush = !qeth_iqd_may_bulk(queue, skb, hdr);\n\n\tif (flush ||\n\t    (buffer->next_element_to_fill + elements > queue->max_elements)) {\n\t\tif (buffer->next_element_to_fill > 0) {\n\t\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\t\tqueue->bulk_count++;\n\t\t}\n\n\t\tif (queue->bulk_count >= queue->bulk_max)\n\t\t\tflush = true;\n\n\t\tif (flush)\n\t\t\tqeth_flush_queue(queue);\n\n\t\tbuffer = queue->bufs[QDIO_BUFNR(queue->bulk_start +\n\t\t\t\t\t\tqueue->bulk_count)];\n\n\t\t \n\t\tif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (buffer->next_element_to_fill == 0 &&\n\t    atomic_inc_return(&queue->used_buffers) >= QDIO_MAX_BUFFERS_PER_Q) {\n\t\t \n\t\tQETH_TXQ_STAT_INC(queue, stopped);\n\t\tnetif_tx_stop_queue(txq);\n\t\tstopped = true;\n\t}\n\n\tnext_element = qeth_fill_buffer(buffer, skb, hdr, offset, hd_len);\n\tbuffer->bytes += bytes;\n\tbuffer->frames += skb_is_gso(skb) ? skb_shinfo(skb)->gso_segs : 1;\n\tqueue->prev_hdr = hdr;\n\n\tflush = __netdev_tx_sent_queue(txq, bytes,\n\t\t\t\t       !stopped && netdev_xmit_more());\n\n\tif (flush || next_element >= queue->max_elements) {\n\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\tqueue->bulk_count++;\n\n\t\tif (queue->bulk_count >= queue->bulk_max)\n\t\t\tflush = true;\n\n\t\tif (flush)\n\t\t\tqeth_flush_queue(queue);\n\t}\n\n\tif (stopped && !qeth_out_queue_is_full(queue))\n\t\tnetif_tx_start_queue(txq);\n\treturn 0;\n}\n\nstatic int qeth_do_send_packet(struct qeth_card *card,\n\t\t\t       struct qeth_qdio_out_q *queue,\n\t\t\t       struct sk_buff *skb, struct qeth_hdr *hdr,\n\t\t\t       unsigned int offset, unsigned int hd_len,\n\t\t\t       unsigned int elements_needed)\n{\n\tunsigned int start_index = queue->next_buf_to_fill;\n\tstruct qeth_qdio_out_buffer *buffer;\n\tunsigned int next_element;\n\tstruct netdev_queue *txq;\n\tbool stopped = false;\n\tint flush_count = 0;\n\tint do_pack = 0;\n\tint rc = 0;\n\n\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\n\t \n\tif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY)\n\t\treturn -EBUSY;\n\n\ttxq = netdev_get_tx_queue(card->dev, skb_get_queue_mapping(skb));\n\n\t \n\tqeth_switch_to_packing_if_needed(queue);\n\tif (queue->do_pack) {\n\t\tdo_pack = 1;\n\t\t \n\t\tif (buffer->next_element_to_fill + elements_needed >\n\t\t    queue->max_elements) {\n\t\t\t \n\t\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\t\tflush_count++;\n\t\t\tqueue->next_buf_to_fill =\n\t\t\t\tQDIO_BUFNR(queue->next_buf_to_fill + 1);\n\t\t\tbuffer = queue->bufs[queue->next_buf_to_fill];\n\n\t\t\t \n\t\t\tif (atomic_read(&buffer->state) !=\n\t\t\t    QETH_QDIO_BUF_EMPTY) {\n\t\t\t\tqeth_flush_buffers(queue, start_index,\n\t\t\t\t\t\t\t   flush_count);\n\t\t\t\trc = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (buffer->next_element_to_fill == 0 &&\n\t    atomic_inc_return(&queue->used_buffers) >= QDIO_MAX_BUFFERS_PER_Q) {\n\t\t \n\t\tQETH_TXQ_STAT_INC(queue, stopped);\n\t\tnetif_tx_stop_queue(txq);\n\t\tstopped = true;\n\t}\n\n\tnext_element = qeth_fill_buffer(buffer, skb, hdr, offset, hd_len);\n\tbuffer->bytes += qdisc_pkt_len(skb);\n\tbuffer->frames += skb_is_gso(skb) ? skb_shinfo(skb)->gso_segs : 1;\n\n\tif (queue->do_pack)\n\t\tQETH_TXQ_STAT_INC(queue, skbs_pack);\n\tif (!queue->do_pack || stopped || next_element >= queue->max_elements) {\n\t\tflush_count++;\n\t\tatomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\n\t\tqueue->next_buf_to_fill =\n\t\t\t\tQDIO_BUFNR(queue->next_buf_to_fill + 1);\n\t}\n\n\tif (flush_count)\n\t\tqeth_flush_buffers(queue, start_index, flush_count);\n\nout:\n\tif (do_pack)\n\t\tQETH_TXQ_STAT_ADD(queue, bufs_pack, flush_count);\n\n\tif (stopped && !qeth_out_queue_is_full(queue))\n\t\tnetif_tx_start_queue(txq);\n\treturn rc;\n}\n\nstatic void qeth_fill_tso_ext(struct qeth_hdr_tso *hdr,\n\t\t\t      unsigned int payload_len, struct sk_buff *skb,\n\t\t\t      unsigned int proto_len)\n{\n\tstruct qeth_hdr_ext_tso *ext = &hdr->ext;\n\n\text->hdr_tot_len = sizeof(*ext);\n\text->imb_hdr_no = 1;\n\text->hdr_type = 1;\n\text->hdr_version = 1;\n\text->hdr_len = 28;\n\text->payload_len = payload_len;\n\text->mss = skb_shinfo(skb)->gso_size;\n\text->dg_hdr_len = proto_len;\n}\n\nint qeth_xmit(struct qeth_card *card, struct sk_buff *skb,\n\t      struct qeth_qdio_out_q *queue, __be16 proto,\n\t      void (*fill_header)(struct qeth_qdio_out_q *queue,\n\t\t\t\t  struct qeth_hdr *hdr, struct sk_buff *skb,\n\t\t\t\t  __be16 proto, unsigned int data_len))\n{\n\tunsigned int proto_len, hw_hdr_len;\n\tunsigned int frame_len = skb->len;\n\tbool is_tso = skb_is_gso(skb);\n\tunsigned int data_offset = 0;\n\tstruct qeth_hdr *hdr = NULL;\n\tunsigned int hd_len = 0;\n\tunsigned int elements;\n\tint push_len, rc;\n\n\tif (is_tso) {\n\t\thw_hdr_len = sizeof(struct qeth_hdr_tso);\n\t\tproto_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\n\t} else {\n\t\thw_hdr_len = sizeof(struct qeth_hdr);\n\t\tproto_len = (IS_IQD(card) && IS_LAYER2(card)) ? ETH_HLEN : 0;\n\t}\n\n\trc = skb_cow_head(skb, hw_hdr_len);\n\tif (rc)\n\t\treturn rc;\n\n\tpush_len = qeth_add_hw_header(queue, skb, &hdr, hw_hdr_len, proto_len,\n\t\t\t\t      &elements);\n\tif (push_len < 0)\n\t\treturn push_len;\n\tif (is_tso || !push_len) {\n\t\t \n\t\thd_len = hw_hdr_len + proto_len;\n\t\tdata_offset = push_len + proto_len;\n\t}\n\tmemset(hdr, 0, hw_hdr_len);\n\tfill_header(queue, hdr, skb, proto, frame_len);\n\tif (is_tso)\n\t\tqeth_fill_tso_ext((struct qeth_hdr_tso *) hdr,\n\t\t\t\t  frame_len - proto_len, skb, proto_len);\n\n\tif (IS_IQD(card)) {\n\t\trc = __qeth_xmit(card, queue, skb, elements, hdr, data_offset,\n\t\t\t\t hd_len);\n\t} else {\n\t\t \n\t\tskb_orphan(skb);\n\t\tspin_lock(&queue->lock);\n\t\trc = qeth_do_send_packet(card, queue, skb, hdr, data_offset,\n\t\t\t\t\t hd_len, elements);\n\t\tspin_unlock(&queue->lock);\n\t}\n\n\tif (rc && !push_len)\n\t\tkmem_cache_free(qeth_core_header_cache, hdr);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_xmit);\n\nstatic int qeth_setadp_promisc_mode_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_ipacmd_setadpparms *setparms;\n\n\tQETH_CARD_TEXT(card, 4, \"prmadpcb\");\n\n\tsetparms = &(cmd->data.setadapterparms);\n\tif (qeth_setadpparms_inspect_rc(cmd)) {\n\t\tQETH_CARD_TEXT_(card, 4, \"prmrc%x\", cmd->hdr.return_code);\n\t\tsetparms->data.mode = SET_PROMISC_MODE_OFF;\n\t}\n\tcard->info.promisc_mode = setparms->data.mode;\n\treturn (cmd->hdr.return_code) ? -EIO : 0;\n}\n\nvoid qeth_setadp_promisc_mode(struct qeth_card *card, bool enable)\n{\n\tenum qeth_ipa_promisc_modes mode = enable ? SET_PROMISC_MODE_ON :\n\t\t\t\t\t\t    SET_PROMISC_MODE_OFF;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"setprom\");\n\tQETH_CARD_TEXT_(card, 4, \"mode:%x\", mode);\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_PROMISC_MODE,\n\t\t\t\t   SETADP_DATA_SIZEOF(mode));\n\tif (!iob)\n\t\treturn;\n\tcmd = __ipa_cmd(iob);\n\tcmd->data.setadapterparms.data.mode = mode;\n\tqeth_send_ipa_cmd(card, iob, qeth_setadp_promisc_mode_cb, NULL);\n}\nEXPORT_SYMBOL_GPL(qeth_setadp_promisc_mode);\n\nstatic int qeth_setadpparms_change_macaddr_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_ipacmd_setadpparms *adp_cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmaccb\");\n\tif (qeth_setadpparms_inspect_rc(cmd))\n\t\treturn -EIO;\n\n\tadp_cmd = &cmd->data.setadapterparms;\n\tif (!is_valid_ether_addr(adp_cmd->data.change_addr.addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (IS_LAYER2(card) && IS_OSD(card) && !IS_VM_NIC(card) &&\n\t    !(adp_cmd->hdr.flags & QETH_SETADP_FLAGS_VIRTUAL_MAC))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(card->dev, adp_cmd->data.change_addr.addr);\n\treturn 0;\n}\n\nint qeth_setadpparms_change_macaddr(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmac\");\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_ALTER_MAC_ADDRESS,\n\t\t\t\t   SETADP_DATA_SIZEOF(change_addr));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\tcmd->data.setadapterparms.data.change_addr.cmd = CHANGE_ADDR_READ_MAC;\n\tcmd->data.setadapterparms.data.change_addr.addr_size = ETH_ALEN;\n\tether_addr_copy(cmd->data.setadapterparms.data.change_addr.addr,\n\t\t\tcard->dev->dev_addr);\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_change_macaddr_cb,\n\t\t\t       NULL);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_setadpparms_change_macaddr);\n\nstatic int qeth_setadpparms_set_access_ctrl_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_set_access_ctrl *access_ctrl_req;\n\n\tQETH_CARD_TEXT(card, 4, \"setaccb\");\n\n\taccess_ctrl_req = &cmd->data.setadapterparms.data.set_access_ctrl;\n\tQETH_CARD_TEXT_(card, 2, \"rc=%d\",\n\t\t\tcmd->data.setadapterparms.hdr.return_code);\n\tif (cmd->data.setadapterparms.hdr.return_code !=\n\t\t\t\t\t\tSET_ACCESS_CTRL_RC_SUCCESS)\n\t\tQETH_DBF_MESSAGE(3, \"ERR:SET_ACCESS_CTRL(%#x) on device %x: %#x\\n\",\n\t\t\t\t access_ctrl_req->subcmd_code, CARD_DEVID(card),\n\t\t\t\t cmd->data.setadapterparms.hdr.return_code);\n\tswitch (qeth_setadpparms_inspect_rc(cmd)) {\n\tcase SET_ACCESS_CTRL_RC_SUCCESS:\n\t\tif (access_ctrl_req->subcmd_code == ISOLATION_MODE_NONE)\n\t\t\tdev_info(&card->gdev->dev,\n\t\t\t    \"QDIO data connection isolation is deactivated\\n\");\n\t\telse\n\t\t\tdev_info(&card->gdev->dev,\n\t\t\t    \"QDIO data connection isolation is activated\\n\");\n\t\treturn 0;\n\tcase SET_ACCESS_CTRL_RC_ALREADY_NOT_ISOLATED:\n\t\tQETH_DBF_MESSAGE(2, \"QDIO data connection isolation on device %x already deactivated\\n\",\n\t\t\t\t CARD_DEVID(card));\n\t\treturn 0;\n\tcase SET_ACCESS_CTRL_RC_ALREADY_ISOLATED:\n\t\tQETH_DBF_MESSAGE(2, \"QDIO data connection isolation on device %x already activated\\n\",\n\t\t\t\t CARD_DEVID(card));\n\t\treturn 0;\n\tcase SET_ACCESS_CTRL_RC_NOT_SUPPORTED:\n\t\tdev_err(&card->gdev->dev, \"Adapter does not \"\n\t\t\t\"support QDIO data connection isolation\\n\");\n\t\treturn -EOPNOTSUPP;\n\tcase SET_ACCESS_CTRL_RC_NONE_SHARED_ADAPTER:\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"Adapter is dedicated. \"\n\t\t\t\"QDIO data connection isolation not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\tcase SET_ACCESS_CTRL_RC_ACTIVE_CHECKSUM_OFF:\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"TSO does not permit QDIO data connection isolation\\n\");\n\t\treturn -EPERM;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_UNSUPPORTED:\n\t\tdev_err(&card->gdev->dev, \"The adjacent switch port does not \"\n\t\t\t\"support reflective relay mode\\n\");\n\t\treturn -EOPNOTSUPP;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_FAILED:\n\t\tdev_err(&card->gdev->dev, \"The reflective relay mode cannot be \"\n\t\t\t\t\t\"enabled at the adjacent switch port\");\n\t\treturn -EREMOTEIO;\n\tcase SET_ACCESS_CTRL_RC_REFLREL_DEACT_FAILED:\n\t\tdev_warn(&card->gdev->dev, \"Turning off reflective relay mode \"\n\t\t\t\t\t\"at the adjacent switch failed\\n\");\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nint qeth_setadpparms_set_access_ctrl(struct qeth_card *card,\n\t\t\t\t     enum qeth_ipa_isolation_modes mode)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_set_access_ctrl *access_ctrl_req;\n\n\tQETH_CARD_TEXT(card, 4, \"setacctl\");\n\n\tif (!qeth_adp_supported(card, IPA_SETADP_SET_ACCESS_CONTROL)) {\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"Adapter does not support QDIO data connection isolation\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_ACCESS_CONTROL,\n\t\t\t\t   SETADP_DATA_SIZEOF(set_access_ctrl));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\taccess_ctrl_req = &cmd->data.setadapterparms.data.set_access_ctrl;\n\taccess_ctrl_req->subcmd_code = mode;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_set_access_ctrl_cb,\n\t\t\t       NULL);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"rc=%d\", rc);\n\t\tQETH_DBF_MESSAGE(3, \"IPA(SET_ACCESS_CTRL(%d) on device %x: sent failed\\n\",\n\t\t\t\t rc, CARD_DEVID(card));\n\t}\n\n\treturn rc;\n}\n\nvoid qeth_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct qeth_card *card;\n\n\tcard = dev->ml_priv;\n\tQETH_CARD_TEXT(card, 4, \"txtimeo\");\n\tqeth_schedule_recovery(card);\n}\nEXPORT_SYMBOL_GPL(qeth_tx_timeout);\n\nstatic int qeth_mdio_read(struct net_device *dev, int phy_id, int regnum)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tint rc = 0;\n\n\tswitch (regnum) {\n\tcase MII_BMCR:  \n\t\trc = BMCR_FULLDPLX;\n\t\tif ((card->info.link_type != QETH_LINK_TYPE_GBIT_ETH) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_10GBIT_ETH) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_25GBIT_ETH))\n\t\t\trc |= BMCR_SPEED100;\n\t\tbreak;\n\tcase MII_BMSR:  \n\t\trc = BMSR_ERCAP | BMSR_ANEGCOMPLETE | BMSR_LSTATUS |\n\t\t     BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | BMSR_100FULL |\n\t\t     BMSR_100BASE4;\n\t\tbreak;\n\tcase MII_PHYSID1:  \n\t\trc = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 8) |\n\t\t     dev->dev_addr[2];\n\t\trc = (rc >> 5) & 0xFFFF;\n\t\tbreak;\n\tcase MII_PHYSID2:  \n\t\trc = (dev->dev_addr[2] << 10) & 0xFFFF;\n\t\tbreak;\n\tcase MII_ADVERTISE:  \n\t\trc = ADVERTISE_ALL;\n\t\tbreak;\n\tcase MII_LPA:  \n\t\trc = LPA_10HALF | LPA_10FULL | LPA_100HALF | LPA_100FULL |\n\t\t     LPA_100BASE4 | LPA_LPACK;\n\t\tbreak;\n\tcase MII_EXPANSION:  \n\t\tbreak;\n\tcase MII_DCOUNTER:  \n\t\tbreak;\n\tcase MII_FCSCOUNTER:  \n\t\tbreak;\n\tcase MII_NWAYTEST:  \n\t\tbreak;\n\tcase MII_RERRCOUNTER:  \n\t\trc = card->stats.rx_length_errors +\n\t\t     card->stats.rx_frame_errors +\n\t\t     card->stats.rx_fifo_errors;\n\t\tbreak;\n\tcase MII_SREVISION:  \n\t\tbreak;\n\tcase MII_RESV1:  \n\t\tbreak;\n\tcase MII_LBRERROR:  \n\t\tbreak;\n\tcase MII_PHYADDR:  \n\t\tbreak;\n\tcase MII_RESV2:  \n\t\tbreak;\n\tcase MII_TPISTATUS:  \n\t\tbreak;\n\tcase MII_NCONFIG:  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int qeth_snmp_command_cb(struct qeth_card *card,\n\t\t\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_arp_query_info *qinfo = reply->param;\n\tstruct qeth_ipacmd_setadpparms *adp_cmd;\n\tunsigned int data_len;\n\tvoid *snmp_data;\n\n\tQETH_CARD_TEXT(card, 3, \"snpcmdcb\");\n\n\tif (cmd->hdr.return_code) {\n\t\tQETH_CARD_TEXT_(card, 4, \"scer1%x\", cmd->hdr.return_code);\n\t\treturn -EIO;\n\t}\n\tif (cmd->data.setadapterparms.hdr.return_code) {\n\t\tcmd->hdr.return_code =\n\t\t\tcmd->data.setadapterparms.hdr.return_code;\n\t\tQETH_CARD_TEXT_(card, 4, \"scer2%x\", cmd->hdr.return_code);\n\t\treturn -EIO;\n\t}\n\n\tadp_cmd = &cmd->data.setadapterparms;\n\tdata_len = adp_cmd->hdr.cmdlength - sizeof(adp_cmd->hdr);\n\tif (adp_cmd->hdr.seq_no == 1) {\n\t\tsnmp_data = &adp_cmd->data.snmp;\n\t} else {\n\t\tsnmp_data = &adp_cmd->data.snmp.request;\n\t\tdata_len -= offsetof(struct qeth_snmp_cmd, request);\n\t}\n\n\t \n\tif ((qinfo->udata_len - qinfo->udata_offset) < data_len) {\n\t\tQETH_CARD_TEXT_(card, 4, \"scer3%i\", -ENOSPC);\n\t\treturn -ENOSPC;\n\t}\n\tQETH_CARD_TEXT_(card, 4, \"snore%i\",\n\t\t\tcmd->data.setadapterparms.hdr.used_total);\n\tQETH_CARD_TEXT_(card, 4, \"sseqn%i\",\n\t\t\tcmd->data.setadapterparms.hdr.seq_no);\n\t \n\tmemcpy(qinfo->udata + qinfo->udata_offset, snmp_data, data_len);\n\tqinfo->udata_offset += data_len;\n\n\tif (cmd->data.setadapterparms.hdr.seq_no <\n\t    cmd->data.setadapterparms.hdr.used_total)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_snmp_ureq __user *ureq;\n\tstruct qeth_cmd_buffer *iob;\n\tunsigned int req_len;\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\n\tif (IS_VM_NIC(card))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    IS_LAYER3(card))\n\t\treturn -EOPNOTSUPP;\n\n\tureq = (struct qeth_snmp_ureq __user *) udata;\n\tif (get_user(qinfo.udata_len, &ureq->hdr.data_len) ||\n\t    get_user(req_len, &ureq->hdr.req_len))\n\t\treturn -EFAULT;\n\n\t \n\tif (req_len > QETH_BUFSIZE)\n\t\treturn -EINVAL;\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL, req_len);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(&__ipa_cmd(iob)->data.setadapterparms.data.snmp,\n\t\t\t   &ureq->cmd, req_len)) {\n\t\tqeth_put_cmd(iob);\n\t\treturn -EFAULT;\n\t}\n\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tqeth_put_cmd(iob);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_snmp_command_cb, &qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on device %x: (%#x)\\n\",\n\t\t\t\t CARD_DEVID(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\n\tkfree(qinfo.udata);\n\treturn rc;\n}\n\nstatic int qeth_setadpparms_query_oat_cb(struct qeth_card *card,\n\t\t\t\t\t struct qeth_reply *reply,\n\t\t\t\t\t unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *)data;\n\tstruct qeth_qoat_priv *priv = reply->param;\n\tint resdatalen;\n\n\tQETH_CARD_TEXT(card, 3, \"qoatcb\");\n\tif (qeth_setadpparms_inspect_rc(cmd))\n\t\treturn -EIO;\n\n\tresdatalen = cmd->data.setadapterparms.hdr.cmdlength;\n\n\tif (resdatalen > (priv->buffer_len - priv->response_len))\n\t\treturn -ENOSPC;\n\n\tmemcpy(priv->buffer + priv->response_len,\n\t       &cmd->data.setadapterparms.hdr, resdatalen);\n\tpriv->response_len += resdatalen;\n\n\tif (cmd->data.setadapterparms.hdr.seq_no <\n\t    cmd->data.setadapterparms.hdr.used_total)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int qeth_query_oat_command(struct qeth_card *card, char __user *udata)\n{\n\tint rc = 0;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_query_oat *oat_req;\n\tstruct qeth_query_oat_data oat_data;\n\tstruct qeth_qoat_priv priv;\n\tvoid __user *tmp;\n\n\tQETH_CARD_TEXT(card, 3, \"qoatcmd\");\n\n\tif (!qeth_adp_supported(card, IPA_SETADP_QUERY_OAT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&oat_data, udata, sizeof(oat_data)))\n\t\treturn -EFAULT;\n\n\tpriv.buffer_len = oat_data.buffer_len;\n\tpriv.response_len = 0;\n\tpriv.buffer = vzalloc(oat_data.buffer_len);\n\tif (!priv.buffer)\n\t\treturn -ENOMEM;\n\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_OAT,\n\t\t\t\t   SETADP_DATA_SIZEOF(query_oat));\n\tif (!iob) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tcmd = __ipa_cmd(iob);\n\toat_req = &cmd->data.setadapterparms.data.query_oat;\n\toat_req->subcmd_code = oat_data.command;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_query_oat_cb, &priv);\n\tif (!rc) {\n\t\ttmp = is_compat_task() ? compat_ptr(oat_data.ptr) :\n\t\t\t\t\t u64_to_user_ptr(oat_data.ptr);\n\t\toat_data.response_len = priv.response_len;\n\n\t\tif (copy_to_user(tmp, priv.buffer, priv.response_len) ||\n\t\t    copy_to_user(udata, &oat_data, sizeof(oat_data)))\n\t\t\trc = -EFAULT;\n\t}\n\nout_free:\n\tvfree(priv.buffer);\n\treturn rc;\n}\n\nstatic int qeth_init_link_info_oat_cb(struct qeth_card *card,\n\t\t\t\t      struct qeth_reply *reply_priv,\n\t\t\t\t      unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *)data;\n\tstruct qeth_link_info *link_info = reply_priv->param;\n\tstruct qeth_query_oat_physical_if *phys_if;\n\tstruct qeth_query_oat_reply *reply;\n\n\tQETH_CARD_TEXT(card, 2, \"qoatincb\");\n\tif (qeth_setadpparms_inspect_rc(cmd))\n\t\treturn -EIO;\n\n\t \n\tif (cmd->data.setadapterparms.hdr.used_total > 1)\n\t\treturn -EINVAL;\n\n\t \n\treply = &cmd->data.setadapterparms.data.query_oat.reply[0];\n\tif (reply->type != QETH_QOAT_REPLY_TYPE_PHYS_IF ||\n\t    reply->length < sizeof(*reply))\n\t\treturn -EINVAL;\n\n\tphys_if = &reply->phys_if;\n\n\tswitch (phys_if->speed_duplex) {\n\tcase QETH_QOAT_PHYS_SPEED_10M_HALF:\n\t\tlink_info->speed = SPEED_10;\n\t\tlink_info->duplex = DUPLEX_HALF;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_SPEED_10M_FULL:\n\t\tlink_info->speed = SPEED_10;\n\t\tlink_info->duplex = DUPLEX_FULL;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_SPEED_100M_HALF:\n\t\tlink_info->speed = SPEED_100;\n\t\tlink_info->duplex = DUPLEX_HALF;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_SPEED_100M_FULL:\n\t\tlink_info->speed = SPEED_100;\n\t\tlink_info->duplex = DUPLEX_FULL;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_SPEED_1000M_HALF:\n\t\tlink_info->speed = SPEED_1000;\n\t\tlink_info->duplex = DUPLEX_HALF;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_SPEED_1000M_FULL:\n\t\tlink_info->speed = SPEED_1000;\n\t\tlink_info->duplex = DUPLEX_FULL;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_SPEED_10G_FULL:\n\t\tlink_info->speed = SPEED_10000;\n\t\tlink_info->duplex = DUPLEX_FULL;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_SPEED_25G_FULL:\n\t\tlink_info->speed = SPEED_25000;\n\t\tlink_info->duplex = DUPLEX_FULL;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_SPEED_UNKNOWN:\n\tdefault:\n\t\tlink_info->speed = SPEED_UNKNOWN;\n\t\tlink_info->duplex = DUPLEX_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tswitch (phys_if->media_type) {\n\tcase QETH_QOAT_PHYS_MEDIA_COPPER:\n\t\tlink_info->port = PORT_TP;\n\t\tlink_info->link_mode = QETH_LINK_MODE_UNKNOWN;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_MEDIA_FIBRE_SHORT:\n\t\tlink_info->port = PORT_FIBRE;\n\t\tlink_info->link_mode = QETH_LINK_MODE_FIBRE_SHORT;\n\t\tbreak;\n\tcase QETH_QOAT_PHYS_MEDIA_FIBRE_LONG:\n\t\tlink_info->port = PORT_FIBRE;\n\t\tlink_info->link_mode = QETH_LINK_MODE_FIBRE_LONG;\n\t\tbreak;\n\tdefault:\n\t\tlink_info->port = PORT_OTHER;\n\t\tlink_info->link_mode = QETH_LINK_MODE_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void qeth_init_link_info(struct qeth_card *card)\n{\n\tqeth_default_link_info(card);\n\n\t \n\tif (qeth_adp_supported(card, IPA_SETADP_QUERY_OAT)) {\n\t\tstruct qeth_link_info link_info;\n\t\tstruct qeth_cmd_buffer *iob;\n\n\t\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_OAT,\n\t\t\t\t\t   SETADP_DATA_SIZEOF(query_oat));\n\t\tif (iob) {\n\t\t\tstruct qeth_ipa_cmd *cmd = __ipa_cmd(iob);\n\t\t\tstruct qeth_query_oat *oat_req;\n\n\t\t\toat_req = &cmd->data.setadapterparms.data.query_oat;\n\t\t\toat_req->subcmd_code = QETH_QOAT_SCOPE_INTERFACE;\n\n\t\t\tif (!qeth_send_ipa_cmd(card, iob,\n\t\t\t\t\t       qeth_init_link_info_oat_cb,\n\t\t\t\t\t       &link_info)) {\n\t\t\t\tif (link_info.speed != SPEED_UNKNOWN)\n\t\t\t\t\tcard->info.link_info.speed = link_info.speed;\n\t\t\t\tif (link_info.duplex != DUPLEX_UNKNOWN)\n\t\t\t\t\tcard->info.link_info.duplex = link_info.duplex;\n\t\t\t\tif (link_info.port != PORT_OTHER)\n\t\t\t\t\tcard->info.link_info.port = link_info.port;\n\t\t\t\tif (link_info.link_mode != QETH_LINK_MODE_UNKNOWN)\n\t\t\t\t\tcard->info.link_info.link_mode = link_info.link_mode;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint qeth_vm_request_mac(struct qeth_card *card)\n{\n\tstruct diag26c_mac_resp *response;\n\tstruct diag26c_mac_req *request;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"vmreqmac\");\n\n\trequest = kzalloc(sizeof(*request), GFP_KERNEL | GFP_DMA);\n\tresponse = kzalloc(sizeof(*response), GFP_KERNEL | GFP_DMA);\n\tif (!request || !response) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trequest->resp_buf_len = sizeof(*response);\n\trequest->resp_version = DIAG26C_VERSION2;\n\trequest->op_code = DIAG26C_GET_MAC;\n\trequest->devno = card->info.ddev_devno;\n\n\tQETH_DBF_HEX(CTRL, 2, request, sizeof(*request));\n\trc = diag26c(request, response, DIAG26C_MAC_SERVICES);\n\tQETH_DBF_HEX(CTRL, 2, request, sizeof(*request));\n\tif (rc)\n\t\tgoto out;\n\tQETH_DBF_HEX(CTRL, 2, response, sizeof(*response));\n\n\tif (request->resp_buf_len < sizeof(*response) ||\n\t    response->version != request->resp_version) {\n\t\trc = -EIO;\n\t\tQETH_CARD_TEXT(card, 2, \"badresp\");\n\t\tQETH_CARD_HEX(card, 2, &request->resp_buf_len,\n\t\t\t      sizeof(request->resp_buf_len));\n\t} else if (!is_valid_ether_addr(response->mac)) {\n\t\trc = -EINVAL;\n\t\tQETH_CARD_TEXT(card, 2, \"badmac\");\n\t\tQETH_CARD_HEX(card, 2, response->mac, ETH_ALEN);\n\t} else {\n\t\teth_hw_addr_set(card->dev, response->mac);\n\t}\n\nout:\n\tkfree(response);\n\tkfree(request);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_vm_request_mac);\n\nstatic void qeth_determine_capabilities(struct qeth_card *card)\n{\n\tstruct qeth_channel *channel = &card->data;\n\tstruct ccw_device *ddev = channel->ccwdev;\n\tint rc;\n\tint ddev_offline = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"detcapab\");\n\tif (!ddev->online) {\n\t\tddev_offline = 1;\n\t\trc = qeth_start_channel(channel);\n\t\tif (rc) {\n\t\t\tQETH_CARD_TEXT_(card, 2, \"3err%d\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = qeth_read_conf_data(card);\n\tif (rc) {\n\t\tQETH_DBF_MESSAGE(2, \"qeth_read_conf_data on device %x returned %i\\n\",\n\t\t\t\t CARD_DEVID(card), rc);\n\t\tQETH_CARD_TEXT_(card, 2, \"5err%d\", rc);\n\t\tgoto out_offline;\n\t}\n\n\trc = qdio_get_ssqd_desc(ddev, &card->ssqd);\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"6err%d\", rc);\n\n\tQETH_CARD_TEXT_(card, 2, \"qfmt%d\", card->ssqd.qfmt);\n\tQETH_CARD_TEXT_(card, 2, \"ac1:%02x\", card->ssqd.qdioac1);\n\tQETH_CARD_TEXT_(card, 2, \"ac2:%04x\", card->ssqd.qdioac2);\n\tQETH_CARD_TEXT_(card, 2, \"ac3:%04x\", card->ssqd.qdioac3);\n\tQETH_CARD_TEXT_(card, 2, \"icnt%d\", card->ssqd.icnt);\n\tif (!((card->ssqd.qfmt != QDIO_IQDIO_QFMT) ||\n\t    ((card->ssqd.qdioac1 & CHSC_AC1_INITIATE_INPUTQ) == 0) ||\n\t    ((card->ssqd.qdioac3 & CHSC_AC3_FORMAT2_CQ_AVAILABLE) == 0))) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t\"Completion Queueing supported\\n\");\n\t} else {\n\t\tcard->options.cq = QETH_CQ_NOTAVAILABLE;\n\t}\n\nout_offline:\n\tif (ddev_offline == 1)\n\t\tqeth_stop_channel(channel);\nout:\n\treturn;\n}\n\nstatic void qeth_read_ccw_conf_data(struct qeth_card *card)\n{\n\tstruct qeth_card_info *info = &card->info;\n\tstruct ccw_device *cdev = CARD_DDEV(card);\n\tstruct ccw_dev_id dev_id;\n\n\tQETH_CARD_TEXT(card, 2, \"ccwconfd\");\n\tccw_device_get_id(cdev, &dev_id);\n\n\tinfo->ddev_devno = dev_id.devno;\n\tinfo->ids_valid = !ccw_device_get_cssid(cdev, &info->cssid) &&\n\t\t\t  !ccw_device_get_iid(cdev, &info->iid) &&\n\t\t\t  !ccw_device_get_chid(cdev, 0, &info->chid);\n\tinfo->ssid = dev_id.ssid;\n\n\tdev_info(&card->gdev->dev, \"CHID: %x CHPID: %x\\n\",\n\t\t info->chid, info->chpid);\n\n\tQETH_CARD_TEXT_(card, 3, \"devn%x\", info->ddev_devno);\n\tQETH_CARD_TEXT_(card, 3, \"cssid:%x\", info->cssid);\n\tQETH_CARD_TEXT_(card, 3, \"iid:%x\", info->iid);\n\tQETH_CARD_TEXT_(card, 3, \"ssid:%x\", info->ssid);\n\tQETH_CARD_TEXT_(card, 3, \"chpid:%x\", info->chpid);\n\tQETH_CARD_TEXT_(card, 3, \"chid:%x\", info->chid);\n\tQETH_CARD_TEXT_(card, 3, \"idval%x\", info->ids_valid);\n}\n\nstatic int qeth_qdio_establish(struct qeth_card *card)\n{\n\tstruct qdio_buffer **out_sbal_ptrs[QETH_MAX_OUT_QUEUES];\n\tstruct qdio_buffer **in_sbal_ptrs[QETH_MAX_IN_QUEUES];\n\tstruct qeth_qib_parms *qib_parms = NULL;\n\tstruct qdio_initialize init_data;\n\tunsigned int no_input_qs = 1;\n\tunsigned int i;\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"qdioest\");\n\n\tif (!IS_IQD(card) && !IS_VM_NIC(card)) {\n\t\tqib_parms = kzalloc(sizeof_field(struct qib, parm), GFP_KERNEL);\n\t\tif (!qib_parms)\n\t\t\treturn -ENOMEM;\n\n\t\tqeth_fill_qib_parms(card, qib_parms);\n\t}\n\n\tin_sbal_ptrs[0] = card->qdio.in_q->qdio_bufs;\n\tif (card->options.cq == QETH_CQ_ENABLED) {\n\t\tin_sbal_ptrs[1] = card->qdio.c_q->qdio_bufs;\n\t\tno_input_qs++;\n\t}\n\n\tfor (i = 0; i < card->qdio.no_out_queues; i++)\n\t\tout_sbal_ptrs[i] = card->qdio.out_qs[i]->qdio_bufs;\n\n\tmemset(&init_data, 0, sizeof(struct qdio_initialize));\n\tinit_data.q_format\t\t = IS_IQD(card) ? QDIO_IQDIO_QFMT :\n\t\t\t\t\t\t\t  QDIO_QETH_QFMT;\n\tinit_data.qib_param_field_format = 0;\n\tinit_data.qib_param_field\t = (void *)qib_parms;\n\tinit_data.no_input_qs\t\t = no_input_qs;\n\tinit_data.no_output_qs           = card->qdio.no_out_queues;\n\tinit_data.input_handler\t\t = qeth_qdio_input_handler;\n\tinit_data.output_handler\t = qeth_qdio_output_handler;\n\tinit_data.irq_poll\t\t = qeth_qdio_poll;\n\tinit_data.int_parm               = (unsigned long) card;\n\tinit_data.input_sbal_addr_array  = in_sbal_ptrs;\n\tinit_data.output_sbal_addr_array = out_sbal_ptrs;\n\n\tif (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ALLOCATED,\n\t\tQETH_QDIO_ESTABLISHED) == QETH_QDIO_ALLOCATED) {\n\t\trc = qdio_allocate(CARD_DDEV(card), init_data.no_input_qs,\n\t\t\t\t   init_data.no_output_qs);\n\t\tif (rc) {\n\t\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\t\tgoto out;\n\t\t}\n\t\trc = qdio_establish(CARD_DDEV(card), &init_data);\n\t\tif (rc) {\n\t\t\tatomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\n\t\t\tqdio_free(CARD_DDEV(card));\n\t\t}\n\t}\n\n\tswitch (card->options.cq) {\n\tcase QETH_CQ_ENABLED:\n\t\tdev_info(&card->gdev->dev, \"Completion Queue support enabled\");\n\t\tbreak;\n\tcase QETH_CQ_DISABLED:\n\t\tdev_info(&card->gdev->dev, \"Completion Queue support disabled\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tkfree(qib_parms);\n\treturn rc;\n}\n\nstatic void qeth_core_free_card(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"freecrd\");\n\n\tunregister_service_level(&card->qeth_service_level);\n\tdebugfs_remove_recursive(card->debugfs);\n\tqeth_put_cmd(card->read_cmd);\n\tdestroy_workqueue(card->event_wq);\n\tdev_set_drvdata(&card->gdev->dev, NULL);\n\tkfree(card);\n}\n\nstatic void qeth_trace_features(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 2, \"features\");\n\tQETH_CARD_HEX(card, 2, &card->options.ipa4, sizeof(card->options.ipa4));\n\tQETH_CARD_HEX(card, 2, &card->options.ipa6, sizeof(card->options.ipa6));\n\tQETH_CARD_HEX(card, 2, &card->options.adp, sizeof(card->options.adp));\n\tQETH_CARD_HEX(card, 2, &card->info.diagass_support,\n\t\t      sizeof(card->info.diagass_support));\n}\n\nstatic struct ccw_device_id qeth_ids[] = {\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x01, 0x1732, 0x01),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSD},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x05, 0x1732, 0x05),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_IQD},\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x02, 0x1732, 0x03),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSM},\n#ifdef CONFIG_QETH_OSX\n\t{CCW_DEVICE_DEVTYPE(0x1731, 0x02, 0x1732, 0x02),\n\t\t\t\t\t.driver_info = QETH_CARD_TYPE_OSX},\n#endif\n\t{},\n};\nMODULE_DEVICE_TABLE(ccw, qeth_ids);\n\nstatic struct ccw_driver qeth_ccw_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"qeth\",\n\t},\n\t.ids = qeth_ids,\n\t.probe = ccwgroup_probe_ccwdev,\n\t.remove = ccwgroup_remove_ccwdev,\n};\n\nstatic int qeth_hardsetup_card(struct qeth_card *card, bool *carrier_ok)\n{\n\tint retries = 3;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"hrdsetup\");\n\tatomic_set(&card->force_alloc_skb, 0);\n\trc = qeth_update_from_chp_desc(card);\n\tif (rc)\n\t\treturn rc;\nretry:\n\tif (retries < 3)\n\t\tQETH_DBF_MESSAGE(2, \"Retrying to do IDX activates on device %x.\\n\",\n\t\t\t\t CARD_DEVID(card));\n\trc = qeth_qdio_clear_card(card, !IS_IQD(card));\n\tqeth_stop_channel(&card->data);\n\tqeth_stop_channel(&card->write);\n\tqeth_stop_channel(&card->read);\n\tqdio_free(CARD_DDEV(card));\n\n\trc = qeth_start_channel(&card->read);\n\tif (rc)\n\t\tgoto retriable;\n\trc = qeth_start_channel(&card->write);\n\tif (rc)\n\t\tgoto retriable;\n\trc = qeth_start_channel(&card->data);\n\tif (rc)\n\t\tgoto retriable;\nretriable:\n\tif (rc == -ERESTARTSYS) {\n\t\tQETH_CARD_TEXT(card, 2, \"break1\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"1err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\n\tqeth_determine_capabilities(card);\n\tqeth_read_ccw_conf_data(card);\n\tqeth_idx_init(card);\n\n\trc = qeth_idx_activate_read_channel(card);\n\tif (rc == -EINTR) {\n\t\tQETH_CARD_TEXT(card, 2, \"break2\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"3err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\n\trc = qeth_idx_activate_write_channel(card);\n\tif (rc == -EINTR) {\n\t\tQETH_CARD_TEXT(card, 2, \"break3\");\n\t\treturn rc;\n\t} else if (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"4err%d\", rc);\n\t\tif (--retries < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tgoto retry;\n\t}\n\tcard->read_or_write_problem = 0;\n\trc = qeth_mpc_initialize(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"5err%d\", rc);\n\t\tgoto out;\n\t}\n\n\trc = qeth_send_startlan(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"6err%d\", rc);\n\t\tif (rc == -ENETDOWN) {\n\t\t\tdev_warn(&card->gdev->dev, \"The LAN is offline\\n\");\n\t\t\t*carrier_ok = false;\n\t\t} else {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*carrier_ok = true;\n\t}\n\n\tcard->options.ipa4.supported = 0;\n\tcard->options.ipa6.supported = 0;\n\tcard->options.adp.supported = 0;\n\tcard->options.sbp.supported_funcs = 0;\n\tcard->info.diagass_support = 0;\n\trc = qeth_query_ipassists(card, QETH_PROT_IPV4);\n\tif (rc == -ENOMEM)\n\t\tgoto out;\n\tif (qeth_is_supported(card, IPA_IPV6)) {\n\t\trc = qeth_query_ipassists(card, QETH_PROT_IPV6);\n\t\tif (rc == -ENOMEM)\n\t\t\tgoto out;\n\t}\n\tif (qeth_is_supported(card, IPA_SETADAPTERPARMS)) {\n\t\trc = qeth_query_setadapterparms(card);\n\t\tif (rc < 0) {\n\t\t\tQETH_CARD_TEXT_(card, 2, \"7err%d\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (qeth_adp_supported(card, IPA_SETADP_SET_DIAG_ASSIST)) {\n\t\trc = qeth_query_setdiagass(card);\n\t\tif (rc)\n\t\t\tQETH_CARD_TEXT_(card, 2, \"8err%d\", rc);\n\t}\n\n\tqeth_trace_features(card);\n\n\tif (!qeth_is_diagass_supported(card, QETH_DIAGS_CMD_TRAP) ||\n\t    (card->info.hwtrap && qeth_hw_trap(card, QETH_DIAGS_TRAP_ARM)))\n\t\tcard->info.hwtrap = 0;\n\n\tif (card->options.isolation != ISOLATION_MODE_NONE) {\n\t\trc = qeth_setadpparms_set_access_ctrl(card,\n\t\t\t\t\t\t      card->options.isolation);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tqeth_init_link_info(card);\n\n\trc = qeth_init_qdio_queues(card);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"9err%d\", rc);\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tdev_warn(&card->gdev->dev, \"The qeth device driver failed to recover \"\n\t\t\"an error on the device\\n\");\n\tQETH_DBF_MESSAGE(2, \"Initialization for device %x failed in hardsetup! rc=%d\\n\",\n\t\t\t CARD_DEVID(card), rc);\n\treturn rc;\n}\n\nstatic int qeth_set_online(struct qeth_card *card,\n\t\t\t   const struct qeth_discipline *disc)\n{\n\tbool carrier_ok;\n\tint rc;\n\n\tmutex_lock(&card->conf_mutex);\n\tQETH_CARD_TEXT(card, 2, \"setonlin\");\n\n\trc = qeth_hardsetup_card(card, &carrier_ok);\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"2err%04x\", rc);\n\t\trc = -ENODEV;\n\t\tgoto err_hardsetup;\n\t}\n\n\tqeth_print_status_message(card);\n\n\tif (card->dev->reg_state != NETREG_REGISTERED)\n\t\t \n\t\tqeth_set_real_num_tx_queues(card, qeth_tx_actual_queues(card));\n\n\trc = disc->set_online(card, carrier_ok);\n\tif (rc)\n\t\tgoto err_online;\n\n\t \n\tkobject_uevent(&card->gdev->dev.kobj, KOBJ_CHANGE);\n\n\tmutex_unlock(&card->conf_mutex);\n\treturn 0;\n\nerr_online:\nerr_hardsetup:\n\tqeth_qdio_clear_card(card, 0);\n\tqeth_clear_working_pool_list(card);\n\tqeth_flush_local_addrs(card);\n\n\tqeth_stop_channel(&card->data);\n\tqeth_stop_channel(&card->write);\n\tqeth_stop_channel(&card->read);\n\tqdio_free(CARD_DDEV(card));\n\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc;\n}\n\nint qeth_set_offline(struct qeth_card *card, const struct qeth_discipline *disc,\n\t\t     bool resetting)\n{\n\tint rc, rc2, rc3;\n\n\tmutex_lock(&card->conf_mutex);\n\tQETH_CARD_TEXT(card, 3, \"setoffl\");\n\n\tif ((!resetting && card->info.hwtrap) || card->info.hwtrap == 2) {\n\t\tqeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\n\t\tcard->info.hwtrap = 1;\n\t}\n\n\t \n\tqeth_clear_ipacmd_list(card);\n\n\trtnl_lock();\n\tnetif_device_detach(card->dev);\n\tnetif_carrier_off(card->dev);\n\trtnl_unlock();\n\n\tcancel_work_sync(&card->rx_mode_work);\n\n\tdisc->set_offline(card);\n\n\tqeth_qdio_clear_card(card, 0);\n\tqeth_drain_output_queues(card);\n\tqeth_clear_working_pool_list(card);\n\tqeth_flush_local_addrs(card);\n\tcard->info.promisc_mode = 0;\n\tqeth_default_link_info(card);\n\n\trc  = qeth_stop_channel(&card->data);\n\trc2 = qeth_stop_channel(&card->write);\n\trc3 = qeth_stop_channel(&card->read);\n\tif (!rc)\n\t\trc = (rc2) ? rc2 : rc3;\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"1err%d\", rc);\n\tqdio_free(CARD_DDEV(card));\n\n\t \n\tkobject_uevent(&card->gdev->dev.kobj, KOBJ_CHANGE);\n\n\tmutex_unlock(&card->conf_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_set_offline);\n\nstatic int qeth_do_reset(void *data)\n{\n\tconst struct qeth_discipline *disc;\n\tstruct qeth_card *card = data;\n\tint rc;\n\n\t \n\tdisc = card->discipline;\n\n\tQETH_CARD_TEXT(card, 2, \"recover1\");\n\tif (!qeth_do_run_thread(card, QETH_RECOVER_THREAD))\n\t\treturn 0;\n\tQETH_CARD_TEXT(card, 2, \"recover2\");\n\tdev_warn(&card->gdev->dev,\n\t\t \"A recovery process has been started for the device\\n\");\n\n\tqeth_set_offline(card, disc, true);\n\trc = qeth_set_online(card, disc);\n\tif (!rc) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"Device successfully recovered!\\n\");\n\t} else {\n\t\tqeth_set_offline(card, disc, true);\n\t\tccwgroup_set_offline(card->gdev, false);\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"The qeth device driver failed to recover an error on the device\\n\");\n\t}\n\tqeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);\n\tqeth_clear_thread_running_bit(card, QETH_RECOVER_THREAD);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_QETH_L3)\nstatic void qeth_l3_rebuild_skb(struct qeth_card *card, struct sk_buff *skb,\n\t\t\t\tstruct qeth_hdr *hdr)\n{\n\tstruct af_iucv_trans_hdr *iucv = (struct af_iucv_trans_hdr *) skb->data;\n\tstruct qeth_hdr_layer3 *l3_hdr = &hdr->hdr.l3;\n\tstruct net_device *dev = skb->dev;\n\n\tif (IS_IQD(card) && iucv->magic == ETH_P_AF_IUCV) {\n\t\tdev_hard_header(skb, dev, ETH_P_AF_IUCV, dev->dev_addr,\n\t\t\t\t\"FAKELL\", skb->len);\n\t\treturn;\n\t}\n\n\tif (!(l3_hdr->flags & QETH_HDR_PASSTHRU)) {\n\t\tu16 prot = (l3_hdr->flags & QETH_HDR_IPV6) ? ETH_P_IPV6 :\n\t\t\t\t\t\t\t     ETH_P_IP;\n\t\tunsigned char tg_addr[ETH_ALEN];\n\n\t\tskb_reset_network_header(skb);\n\t\tswitch (l3_hdr->flags & QETH_HDR_CAST_MASK) {\n\t\tcase QETH_CAST_MULTICAST:\n\t\t\tif (prot == ETH_P_IP)\n\t\t\t\tip_eth_mc_map(ip_hdr(skb)->daddr, tg_addr);\n\t\t\telse\n\t\t\t\tipv6_eth_mc_map(&ipv6_hdr(skb)->daddr, tg_addr);\n\t\t\tQETH_CARD_STAT_INC(card, rx_multicast);\n\t\t\tbreak;\n\t\tcase QETH_CAST_BROADCAST:\n\t\t\tether_addr_copy(tg_addr, dev->broadcast);\n\t\t\tQETH_CARD_STAT_INC(card, rx_multicast);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (card->options.sniffer)\n\t\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\tether_addr_copy(tg_addr, dev->dev_addr);\n\t\t}\n\n\t\tif (l3_hdr->ext_flags & QETH_HDR_EXT_SRC_MAC_ADDR)\n\t\t\tdev_hard_header(skb, dev, prot, tg_addr,\n\t\t\t\t\t&l3_hdr->next_hop.rx.src_mac, skb->len);\n\t\telse\n\t\t\tdev_hard_header(skb, dev, prot, tg_addr, \"FAKELL\",\n\t\t\t\t\tskb->len);\n\t}\n\n\t \n\tif (!card->options.sniffer &&\n\t    (l3_hdr->ext_flags & (QETH_HDR_EXT_VLAN_FRAME |\n\t\t\t\t  QETH_HDR_EXT_INCLUDE_VLAN_TAG))) {\n\t\tu16 tag = (l3_hdr->ext_flags & QETH_HDR_EXT_VLAN_FRAME) ?\n\t\t\t\tl3_hdr->vlan_id :\n\t\t\t\tl3_hdr->next_hop.rx.vlan_id;\n\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), tag);\n\t}\n}\n#endif\n\nstatic void qeth_receive_skb(struct qeth_card *card, struct sk_buff *skb,\n\t\t\t     bool uses_frags, bool is_cso)\n{\n\tstruct napi_struct *napi = &card->napi;\n\n\tif (is_cso && (card->dev->features & NETIF_F_RXCSUM)) {\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tQETH_CARD_STAT_INC(card, rx_skb_csum);\n\t} else {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t}\n\n\tQETH_CARD_STAT_ADD(card, rx_bytes, skb->len);\n\tQETH_CARD_STAT_INC(card, rx_packets);\n\tif (skb_is_nonlinear(skb)) {\n\t\tQETH_CARD_STAT_INC(card, rx_sg_skbs);\n\t\tQETH_CARD_STAT_ADD(card, rx_sg_frags,\n\t\t\t\t   skb_shinfo(skb)->nr_frags);\n\t}\n\n\tif (uses_frags) {\n\t\tnapi_gro_frags(napi);\n\t} else {\n\t\tskb->protocol = eth_type_trans(skb, skb->dev);\n\t\tnapi_gro_receive(napi, skb);\n\t}\n}\n\nstatic void qeth_create_skb_frag(struct sk_buff *skb, char *data, int data_len)\n{\n\tstruct page *page = virt_to_page(data);\n\tunsigned int next_frag;\n\n\tnext_frag = skb_shinfo(skb)->nr_frags;\n\tget_page(page);\n\tskb_add_rx_frag(skb, next_frag, page, offset_in_page(data), data_len,\n\t\t\tdata_len);\n}\n\nstatic inline int qeth_is_last_sbale(struct qdio_buffer_element *sbale)\n{\n\treturn (sbale->eflags & SBAL_EFLAGS_LAST_ENTRY);\n}\n\nstatic int qeth_extract_skb(struct qeth_card *card,\n\t\t\t    struct qeth_qdio_buffer *qethbuffer, u8 *element_no,\n\t\t\t    int *__offset)\n{\n\tstruct qeth_priv *priv = netdev_priv(card->dev);\n\tstruct qdio_buffer *buffer = qethbuffer->buffer;\n\tstruct napi_struct *napi = &card->napi;\n\tstruct qdio_buffer_element *element;\n\tunsigned int linear_len = 0;\n\tbool uses_frags = false;\n\tint offset = *__offset;\n\tbool use_rx_sg = false;\n\tunsigned int headroom;\n\tstruct qeth_hdr *hdr;\n\tstruct sk_buff *skb;\n\tint skb_len = 0;\n\tbool is_cso;\n\n\telement = &buffer->element[*element_no];\n\nnext_packet:\n\t \n\twhile (element->length < offset + sizeof(struct qeth_hdr)) {\n\t\tif (qeth_is_last_sbale(element))\n\t\t\treturn -ENODATA;\n\t\telement++;\n\t\toffset = 0;\n\t}\n\n\thdr = phys_to_virt(element->addr) + offset;\n\toffset += sizeof(*hdr);\n\tskb = NULL;\n\n\tswitch (hdr->hdr.l2.id) {\n\tcase QETH_HEADER_TYPE_LAYER2:\n\t\tskb_len = hdr->hdr.l2.pkt_length;\n\t\tis_cso = hdr->hdr.l2.flags[1] & QETH_HDR_EXT_CSUM_TRANSP_REQ;\n\n\t\tlinear_len = ETH_HLEN;\n\t\theadroom = 0;\n\t\tbreak;\n\tcase QETH_HEADER_TYPE_LAYER3:\n\t\tskb_len = hdr->hdr.l3.length;\n\t\tis_cso = hdr->hdr.l3.ext_flags & QETH_HDR_EXT_CSUM_TRANSP_REQ;\n\n\t\tif (!IS_LAYER3(card)) {\n\t\t\tQETH_CARD_STAT_INC(card, rx_dropped_notsupp);\n\t\t\tgoto walk_packet;\n\t\t}\n\n\t\tif (hdr->hdr.l3.flags & QETH_HDR_PASSTHRU) {\n\t\t\tlinear_len = ETH_HLEN;\n\t\t\theadroom = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hdr->hdr.l3.flags & QETH_HDR_IPV6)\n\t\t\tlinear_len = sizeof(struct ipv6hdr);\n\t\telse\n\t\t\tlinear_len = sizeof(struct iphdr);\n\t\theadroom = ETH_HLEN;\n\t\tbreak;\n\tdefault:\n\t\tif (hdr->hdr.l2.id & QETH_HEADER_MASK_INVAL)\n\t\t\tQETH_CARD_STAT_INC(card, rx_frame_errors);\n\t\telse\n\t\t\tQETH_CARD_STAT_INC(card, rx_dropped_notsupp);\n\n\t\t \n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tif (skb_len < linear_len) {\n\t\tQETH_CARD_STAT_INC(card, rx_dropped_runt);\n\t\tgoto walk_packet;\n\t}\n\n\tuse_rx_sg = (card->options.cq == QETH_CQ_ENABLED) ||\n\t\t    (skb_len > READ_ONCE(priv->rx_copybreak) &&\n\t\t     !atomic_read(&card->force_alloc_skb));\n\n\tif (use_rx_sg) {\n\t\t \n\t\tif (qethbuffer->rx_skb &&\n\t\t    skb_tailroom(qethbuffer->rx_skb) >= linear_len + headroom) {\n\t\t\tskb = qethbuffer->rx_skb;\n\t\t\tqethbuffer->rx_skb = NULL;\n\t\t\tgoto use_skb;\n\t\t}\n\n\t\tskb = napi_get_frags(napi);\n\t\tif (!skb) {\n\t\t\t \n\t\t\tQETH_CARD_STAT_INC(card, rx_dropped_nomem);\n\t\t\tgoto walk_packet;\n\t\t}\n\n\t\tif (skb_tailroom(skb) >= linear_len + headroom) {\n\t\t\tuses_frags = true;\n\t\t\tgoto use_skb;\n\t\t}\n\n\t\tnetdev_info_once(card->dev,\n\t\t\t\t \"Insufficient linear space in NAPI frags skb, need %u but have %u\\n\",\n\t\t\t\t linear_len + headroom, skb_tailroom(skb));\n\t\t \n\t}\n\n\tlinear_len = skb_len;\n\tskb = napi_alloc_skb(napi, linear_len + headroom);\n\tif (!skb) {\n\t\tQETH_CARD_STAT_INC(card, rx_dropped_nomem);\n\t\tgoto walk_packet;\n\t}\n\nuse_skb:\n\tif (headroom)\n\t\tskb_reserve(skb, headroom);\nwalk_packet:\n\twhile (skb_len) {\n\t\tint data_len = min(skb_len, (int)(element->length - offset));\n\t\tchar *data = phys_to_virt(element->addr) + offset;\n\n\t\tskb_len -= data_len;\n\t\toffset += data_len;\n\n\t\t \n\t\tif (skb && data_len) {\n\t\t\tif (linear_len) {\n\t\t\t\tunsigned int copy_len;\n\n\t\t\t\tcopy_len = min_t(unsigned int, linear_len,\n\t\t\t\t\t\t data_len);\n\n\t\t\t\tskb_put_data(skb, data, copy_len);\n\t\t\t\tlinear_len -= copy_len;\n\t\t\t\tdata_len -= copy_len;\n\t\t\t\tdata += copy_len;\n\t\t\t}\n\n\t\t\tif (data_len)\n\t\t\t\tqeth_create_skb_frag(skb, data, data_len);\n\t\t}\n\n\t\t \n\t\tif (skb_len) {\n\t\t\tif (qeth_is_last_sbale(element)) {\n\t\t\t\tQETH_CARD_TEXT(card, 4, \"unexeob\");\n\t\t\t\tQETH_CARD_HEX(card, 2, buffer, sizeof(void *));\n\t\t\t\tif (skb) {\n\t\t\t\t\tif (uses_frags)\n\t\t\t\t\t\tnapi_free_frags(napi);\n\t\t\t\t\telse\n\t\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\tQETH_CARD_STAT_INC(card,\n\t\t\t\t\t\t\t   rx_length_errors);\n\t\t\t\t}\n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\t\t\telement++;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\n\t \n\tif (!skb)\n\t\tgoto next_packet;\n\n\t*element_no = element - &buffer->element[0];\n\t*__offset = offset;\n\n#if IS_ENABLED(CONFIG_QETH_L3)\n\tif (hdr->hdr.l2.id == QETH_HEADER_TYPE_LAYER3)\n\t\tqeth_l3_rebuild_skb(card, skb, hdr);\n#endif\n\n\tqeth_receive_skb(card, skb, uses_frags, is_cso);\n\treturn 0;\n}\n\nstatic unsigned int qeth_extract_skbs(struct qeth_card *card, int budget,\n\t\t\t\t      struct qeth_qdio_buffer *buf, bool *done)\n{\n\tunsigned int work_done = 0;\n\n\twhile (budget) {\n\t\tif (qeth_extract_skb(card, buf, &card->rx.buf_element,\n\t\t\t\t     &card->rx.e_offset)) {\n\t\t\t*done = true;\n\t\t\tbreak;\n\t\t}\n\n\t\twork_done++;\n\t\tbudget--;\n\t}\n\n\treturn work_done;\n}\n\nstatic unsigned int qeth_rx_poll(struct qeth_card *card, int budget)\n{\n\tstruct qeth_rx *ctx = &card->rx;\n\tunsigned int work_done = 0;\n\n\twhile (budget > 0) {\n\t\tstruct qeth_qdio_buffer *buffer;\n\t\tunsigned int skbs_done = 0;\n\t\tbool done = false;\n\n\t\t \n\t\tif (!card->rx.b_count) {\n\t\t\tcard->rx.qdio_err = 0;\n\t\t\tcard->rx.b_count =\n\t\t\t\tqdio_inspect_input_queue(CARD_DDEV(card), 0,\n\t\t\t\t\t\t\t &card->rx.b_index,\n\t\t\t\t\t\t\t &card->rx.qdio_err);\n\t\t\tif (card->rx.b_count <= 0) {\n\t\t\t\tcard->rx.b_count = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbuffer = &card->qdio.in_q->bufs[card->rx.b_index];\n\t\tif (!(card->rx.qdio_err &&\n\t\t      qeth_check_qdio_errors(card, buffer->buffer,\n\t\t\t\t\t     card->rx.qdio_err, \"qinerr\")))\n\t\t\tskbs_done = qeth_extract_skbs(card, budget, buffer,\n\t\t\t\t\t\t      &done);\n\t\telse\n\t\t\tdone = true;\n\n\t\twork_done += skbs_done;\n\t\tbudget -= skbs_done;\n\n\t\tif (done) {\n\t\t\tQETH_CARD_STAT_INC(card, rx_bufs);\n\t\t\tqeth_put_buffer_pool_entry(card, buffer->pool_entry);\n\t\t\tbuffer->pool_entry = NULL;\n\t\t\tcard->rx.b_count--;\n\t\t\tctx->bufs_refill++;\n\t\t\tctx->bufs_refill -= qeth_rx_refill_queue(card,\n\t\t\t\t\t\t\t\t ctx->bufs_refill);\n\n\t\t\t \n\t\t\tcard->rx.b_index = QDIO_BUFNR(card->rx.b_index + 1);\n\t\t\tcard->rx.buf_element = 0;\n\t\t\tcard->rx.e_offset = 0;\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\nstatic void qeth_cq_poll(struct qeth_card *card)\n{\n\tunsigned int work_done = 0;\n\n\twhile (work_done < QDIO_MAX_BUFFERS_PER_Q) {\n\t\tunsigned int start, error;\n\t\tint completed;\n\n\t\tcompleted = qdio_inspect_input_queue(CARD_DDEV(card), 1, &start,\n\t\t\t\t\t\t     &error);\n\t\tif (completed <= 0)\n\t\t\treturn;\n\n\t\tqeth_qdio_cq_handler(card, error, 1, start, completed);\n\t\twork_done += completed;\n\t}\n}\n\nint qeth_poll(struct napi_struct *napi, int budget)\n{\n\tstruct qeth_card *card = container_of(napi, struct qeth_card, napi);\n\tunsigned int work_done;\n\n\twork_done = qeth_rx_poll(card, budget);\n\n\tif (qeth_use_tx_irqs(card)) {\n\t\tstruct qeth_qdio_out_q *queue;\n\t\tunsigned int i;\n\n\t\tqeth_for_each_output_queue(card, queue, i) {\n\t\t\tif (!qeth_out_queue_is_empty(queue))\n\t\t\t\tnapi_schedule(&queue->napi);\n\t\t}\n\t}\n\n\tif (card->options.cq == QETH_CQ_ENABLED)\n\t\tqeth_cq_poll(card);\n\n\tif (budget) {\n\t\tstruct qeth_rx *ctx = &card->rx;\n\n\t\t \n\t\tctx->bufs_refill -= qeth_rx_refill_queue(card, ctx->bufs_refill);\n\n\t\t \n\t\tif (work_done >= budget)\n\t\t\treturn work_done;\n\t}\n\n\tif (napi_complete_done(napi, work_done) &&\n\t    qdio_start_irq(CARD_DDEV(card)))\n\t\tnapi_schedule(napi);\n\n\treturn work_done;\n}\nEXPORT_SYMBOL_GPL(qeth_poll);\n\nstatic void qeth_iqd_tx_complete(struct qeth_qdio_out_q *queue,\n\t\t\t\t unsigned int bidx, unsigned int qdio_error,\n\t\t\t\t int budget)\n{\n\tstruct qeth_qdio_out_buffer *buffer = queue->bufs[bidx];\n\tu8 sflags = buffer->buffer->element[15].sflags;\n\tstruct qeth_card *card = queue->card;\n\tbool error = !!qdio_error;\n\n\tif (qdio_error == QDIO_ERROR_SLSB_PENDING) {\n\t\tstruct qaob *aob = buffer->aob;\n\t\tstruct qeth_qaob_priv1 *priv;\n\t\tenum iucv_tx_notify notify;\n\n\t\tif (!aob) {\n\t\t\tnetdev_WARN_ONCE(card->dev,\n\t\t\t\t\t \"Pending TX buffer %#x without QAOB on TX queue %u\\n\",\n\t\t\t\t\t bidx, queue->queue_no);\n\t\t\tqeth_schedule_recovery(card);\n\t\t\treturn;\n\t\t}\n\n\t\tQETH_CARD_TEXT_(card, 5, \"pel%u\", bidx);\n\n\t\tpriv = (struct qeth_qaob_priv1 *)&aob->user1;\n\t\t \n\t\tif (xchg(&priv->state, QETH_QAOB_PENDING) != QETH_QAOB_DONE) {\n\t\t\tqeth_notify_skbs(queue, buffer, TX_NOTIFY_PENDING);\n\n\t\t\t \n\t\t\tqeth_scrub_qdio_buffer(buffer->buffer, queue->max_elements);\n\t\t\tif (qeth_alloc_out_buf(queue, bidx, GFP_ATOMIC)) {\n\t\t\t\tQETH_CARD_TEXT(card, 2, \"outofbuf\");\n\t\t\t\tqeth_schedule_recovery(card);\n\t\t\t}\n\n\t\t\tlist_add(&buffer->list_entry, &queue->pending_bufs);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tnotify = qeth_compute_cq_notification(aob->aorc, 0);\n\t\tqeth_notify_skbs(queue, buffer, notify);\n\t\terror = !!aob->aorc;\n\t\tmemset(aob, 0, sizeof(*aob));\n\t} else if (card->options.cq == QETH_CQ_ENABLED) {\n\t\tqeth_notify_skbs(queue, buffer,\n\t\t\t\t qeth_compute_cq_notification(sflags, 0));\n\t}\n\n\tqeth_clear_output_buffer(queue, buffer, error, budget);\n}\n\nstatic int qeth_tx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct qeth_qdio_out_q *queue = qeth_napi_to_out_queue(napi);\n\tunsigned int queue_no = queue->queue_no;\n\tstruct qeth_card *card = queue->card;\n\tstruct net_device *dev = card->dev;\n\tunsigned int work_done = 0;\n\tstruct netdev_queue *txq;\n\n\tif (IS_IQD(card))\n\t\ttxq = netdev_get_tx_queue(dev, qeth_iqd_translate_txq(dev, queue_no));\n\telse\n\t\ttxq = netdev_get_tx_queue(dev, queue_no);\n\n\twhile (1) {\n\t\tunsigned int start, error, i;\n\t\tunsigned int packets = 0;\n\t\tunsigned int bytes = 0;\n\t\tint completed;\n\n\t\tqeth_tx_complete_pending_bufs(card, queue, false, budget);\n\n\t\tif (qeth_out_queue_is_empty(queue)) {\n\t\t\tnapi_complete(napi);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (work_done >= QDIO_MAX_BUFFERS_PER_Q) {\n\t\t\tQETH_TXQ_STAT_INC(queue, completion_yield);\n\t\t\tif (napi_complete_done(napi, 0))\n\t\t\t\tnapi_schedule(napi);\n\t\t\treturn 0;\n\t\t}\n\n\t\tcompleted = qdio_inspect_output_queue(CARD_DDEV(card), queue_no,\n\t\t\t\t\t\t      &start, &error);\n\t\tif (completed <= 0) {\n\t\t\t \n\t\t\tif (napi_complete_done(napi, 0) &&\n\t\t\t    !atomic_read(&queue->set_pci_flags_count))\n\t\t\t\tqeth_tx_arm_timer(queue, queue->rescan_usecs);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i = start; i < start + completed; i++) {\n\t\t\tstruct qeth_qdio_out_buffer *buffer;\n\t\t\tunsigned int bidx = QDIO_BUFNR(i);\n\n\t\t\tbuffer = queue->bufs[bidx];\n\t\t\tpackets += buffer->frames;\n\t\t\tbytes += buffer->bytes;\n\n\t\t\tqeth_handle_send_error(card, buffer, error);\n\t\t\tif (IS_IQD(card))\n\t\t\t\tqeth_iqd_tx_complete(queue, bidx, error, budget);\n\t\t\telse\n\t\t\t\tqeth_clear_output_buffer(queue, buffer, error,\n\t\t\t\t\t\t\t budget);\n\t\t}\n\n\t\tatomic_sub(completed, &queue->used_buffers);\n\t\twork_done += completed;\n\t\tif (IS_IQD(card))\n\t\t\tnetdev_tx_completed_queue(txq, packets, bytes);\n\t\telse\n\t\t\tqeth_check_outbound_queue(queue);\n\n\t\t \n\t\tif (netif_tx_queue_stopped(txq) &&\n\t\t    !qeth_out_queue_is_full(queue))\n\t\t\tnetif_tx_wake_queue(txq);\n\t}\n}\n\nstatic int qeth_setassparms_inspect_rc(struct qeth_ipa_cmd *cmd)\n{\n\tif (!cmd->hdr.return_code)\n\t\tcmd->hdr.return_code = cmd->data.setassparms.hdr.return_code;\n\treturn cmd->hdr.return_code;\n}\n\nstatic int qeth_setassparms_get_caps_cb(struct qeth_card *card,\n\t\t\t\t\tstruct qeth_reply *reply,\n\t\t\t\t\tunsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_ipa_caps *caps = reply->param;\n\n\tif (qeth_setassparms_inspect_rc(cmd))\n\t\treturn -EIO;\n\n\tcaps->supported = cmd->data.setassparms.data.caps.supported;\n\tcaps->enabled = cmd->data.setassparms.data.caps.enabled;\n\treturn 0;\n}\n\nint qeth_setassparms_cb(struct qeth_card *card,\n\t\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\n\tQETH_CARD_TEXT(card, 4, \"defadpcb\");\n\n\tif (cmd->hdr.return_code)\n\t\treturn -EIO;\n\n\tcmd->hdr.return_code = cmd->data.setassparms.hdr.return_code;\n\tif (cmd->hdr.prot_version == QETH_PROT_IPV4)\n\t\tcard->options.ipa4.enabled = cmd->hdr.assists.enabled;\n\tif (cmd->hdr.prot_version == QETH_PROT_IPV6)\n\t\tcard->options.ipa6.enabled = cmd->hdr.assists.enabled;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_setassparms_cb);\n\nstruct qeth_cmd_buffer *qeth_get_setassparms_cmd(struct qeth_card *card,\n\t\t\t\t\t\t enum qeth_ipa_funcs ipa_func,\n\t\t\t\t\t\t u16 cmd_code,\n\t\t\t\t\t\t unsigned int data_length,\n\t\t\t\t\t\t enum qeth_prot_versions prot)\n{\n\tstruct qeth_ipacmd_setassparms *setassparms;\n\tstruct qeth_ipacmd_setassparms_hdr *hdr;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 4, \"getasscm\");\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_SETASSPARMS, prot,\n\t\t\t\t data_length +\n\t\t\t\t offsetof(struct qeth_ipacmd_setassparms,\n\t\t\t\t\t  data));\n\tif (!iob)\n\t\treturn NULL;\n\n\tsetassparms = &__ipa_cmd(iob)->data.setassparms;\n\tsetassparms->assist_no = ipa_func;\n\n\thdr = &setassparms->hdr;\n\thdr->length = sizeof(*hdr) + data_length;\n\thdr->command_code = cmd_code;\n\treturn iob;\n}\nEXPORT_SYMBOL_GPL(qeth_get_setassparms_cmd);\n\nint qeth_send_simple_setassparms_prot(struct qeth_card *card,\n\t\t\t\t      enum qeth_ipa_funcs ipa_func,\n\t\t\t\t      u16 cmd_code, u32 *data,\n\t\t\t\t      enum qeth_prot_versions prot)\n{\n\tunsigned int length = data ? SETASS_DATA_SIZEOF(flags_32bit) : 0;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT_(card, 4, \"simassp%i\", prot);\n\tiob = qeth_get_setassparms_cmd(card, ipa_func, cmd_code, length, prot);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tif (data)\n\t\t__ipa_cmd(iob)->data.setassparms.data.flags_32bit = *data;\n\treturn qeth_send_ipa_cmd(card, iob, qeth_setassparms_cb, NULL);\n}\nEXPORT_SYMBOL_GPL(qeth_send_simple_setassparms_prot);\n\nstatic void qeth_unregister_dbf_views(void)\n{\n\tint x;\n\n\tfor (x = 0; x < QETH_DBF_INFOS; x++) {\n\t\tdebug_unregister(qeth_dbf[x].id);\n\t\tqeth_dbf[x].id = NULL;\n\t}\n}\n\nvoid qeth_dbf_longtext(debug_info_t *id, int level, char *fmt, ...)\n{\n\tchar dbf_txt_buf[32];\n\tva_list args;\n\n\tif (!debug_level_enabled(id, level))\n\t\treturn;\n\tva_start(args, fmt);\n\tvscnprintf(dbf_txt_buf, sizeof(dbf_txt_buf), fmt, args);\n\tva_end(args);\n\tdebug_text_event(id, level, dbf_txt_buf);\n}\nEXPORT_SYMBOL_GPL(qeth_dbf_longtext);\n\nstatic int qeth_register_dbf_views(void)\n{\n\tint ret;\n\tint x;\n\n\tfor (x = 0; x < QETH_DBF_INFOS; x++) {\n\t\t \n\t\tqeth_dbf[x].id = debug_register(qeth_dbf[x].name,\n\t\t\t\t\t\tqeth_dbf[x].pages,\n\t\t\t\t\t\tqeth_dbf[x].areas,\n\t\t\t\t\t\tqeth_dbf[x].len);\n\t\tif (qeth_dbf[x].id == NULL) {\n\t\t\tqeth_unregister_dbf_views();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tret = debug_register_view(qeth_dbf[x].id, qeth_dbf[x].view);\n\t\tif (ret) {\n\t\t\tqeth_unregister_dbf_views();\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tdebug_set_level(qeth_dbf[x].id, qeth_dbf[x].level);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(qeth_mod_mutex);\t \n\nint qeth_setup_discipline(struct qeth_card *card,\n\t\t\t  enum qeth_discipline_id discipline)\n{\n\tint rc;\n\n\tmutex_lock(&qeth_mod_mutex);\n\tswitch (discipline) {\n\tcase QETH_DISCIPLINE_LAYER3:\n\t\tcard->discipline = try_then_request_module(\n\t\t\tsymbol_get(qeth_l3_discipline), \"qeth_l3\");\n\t\tbreak;\n\tcase QETH_DISCIPLINE_LAYER2:\n\t\tcard->discipline = try_then_request_module(\n\t\t\tsymbol_get(qeth_l2_discipline), \"qeth_l2\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&qeth_mod_mutex);\n\n\tif (!card->discipline) {\n\t\tdev_err(&card->gdev->dev, \"There is no kernel module to \"\n\t\t\t\"support discipline %d\\n\", discipline);\n\t\treturn -EINVAL;\n\t}\n\n\trc = card->discipline->setup(card->gdev);\n\tif (rc) {\n\t\tif (discipline == QETH_DISCIPLINE_LAYER2)\n\t\t\tsymbol_put(qeth_l2_discipline);\n\t\telse\n\t\t\tsymbol_put(qeth_l3_discipline);\n\t\tcard->discipline = NULL;\n\n\t\treturn rc;\n\t}\n\n\tcard->options.layer = discipline;\n\treturn 0;\n}\n\nvoid qeth_remove_discipline(struct qeth_card *card)\n{\n\tcard->discipline->remove(card->gdev);\n\n\tif (IS_LAYER2(card))\n\t\tsymbol_put(qeth_l2_discipline);\n\telse\n\t\tsymbol_put(qeth_l3_discipline);\n\tcard->options.layer = QETH_DISCIPLINE_UNDETERMINED;\n\tcard->discipline = NULL;\n}\n\nstatic const struct device_type qeth_generic_devtype = {\n\t.name = \"qeth_generic\",\n};\n\n#define DBF_NAME_LEN\t20\n\nstruct qeth_dbf_entry {\n\tchar dbf_name[DBF_NAME_LEN];\n\tdebug_info_t *dbf_info;\n\tstruct list_head dbf_list;\n};\n\nstatic LIST_HEAD(qeth_dbf_list);\nstatic DEFINE_MUTEX(qeth_dbf_list_mutex);\n\nstatic debug_info_t *qeth_get_dbf_entry(char *name)\n{\n\tstruct qeth_dbf_entry *entry;\n\tdebug_info_t *rc = NULL;\n\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_for_each_entry(entry, &qeth_dbf_list, dbf_list) {\n\t\tif (strcmp(entry->dbf_name, name) == 0) {\n\t\t\trc = entry->dbf_info;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&qeth_dbf_list_mutex);\n\treturn rc;\n}\n\nstatic int qeth_add_dbf_entry(struct qeth_card *card, char *name)\n{\n\tstruct qeth_dbf_entry *new_entry;\n\n\tcard->debug = debug_register(name, 2, 1, 8);\n\tif (!card->debug) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", \"qcdbf\");\n\t\tgoto err;\n\t}\n\tif (debug_register_view(card->debug, &debug_hex_ascii_view))\n\t\tgoto err_dbg;\n\tnew_entry = kzalloc(sizeof(struct qeth_dbf_entry), GFP_KERNEL);\n\tif (!new_entry)\n\t\tgoto err_dbg;\n\tstrncpy(new_entry->dbf_name, name, DBF_NAME_LEN);\n\tnew_entry->dbf_info = card->debug;\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_add(&new_entry->dbf_list, &qeth_dbf_list);\n\tmutex_unlock(&qeth_dbf_list_mutex);\n\n\treturn 0;\n\nerr_dbg:\n\tdebug_unregister(card->debug);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void qeth_clear_dbf_list(void)\n{\n\tstruct qeth_dbf_entry *entry, *tmp;\n\n\tmutex_lock(&qeth_dbf_list_mutex);\n\tlist_for_each_entry_safe(entry, tmp, &qeth_dbf_list, dbf_list) {\n\t\tlist_del(&entry->dbf_list);\n\t\tdebug_unregister(entry->dbf_info);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&qeth_dbf_list_mutex);\n}\n\nstatic struct net_device *qeth_alloc_netdev(struct qeth_card *card)\n{\n\tstruct net_device *dev;\n\tstruct qeth_priv *priv;\n\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_IQD:\n\t\tdev = alloc_netdev_mqs(sizeof(*priv), \"hsi%d\", NET_NAME_UNKNOWN,\n\t\t\t\t       ether_setup, QETH_MAX_OUT_QUEUES, 1);\n\t\tbreak;\n\tcase QETH_CARD_TYPE_OSM:\n\t\tdev = alloc_etherdev(sizeof(*priv));\n\t\tbreak;\n\tdefault:\n\t\tdev = alloc_etherdev_mqs(sizeof(*priv), QETH_MAX_OUT_QUEUES, 1);\n\t}\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tpriv = netdev_priv(dev);\n\tpriv->rx_copybreak = QETH_RX_COPYBREAK;\n\tpriv->tx_wanted_queues = IS_IQD(card) ? QETH_IQD_MIN_TXQ : 1;\n\n\tdev->ml_priv = card;\n\tdev->watchdog_timeo = QETH_TX_TIMEOUT;\n\tdev->min_mtu = 576;\n\t  \n\tdev->max_mtu = 0;\n\tdev->mtu = 0;\n\tSET_NETDEV_DEV(dev, &card->gdev->dev);\n\tnetif_carrier_off(dev);\n\n\tdev->ethtool_ops = &qeth_ethtool_ops;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->hw_features |= NETIF_F_SG;\n\tdev->vlan_features |= NETIF_F_SG;\n\tif (IS_IQD(card))\n\t\tdev->features |= NETIF_F_SG;\n\n\treturn dev;\n}\n\nstruct net_device *qeth_clone_netdev(struct net_device *orig)\n{\n\tstruct net_device *clone = qeth_alloc_netdev(orig->ml_priv);\n\n\tif (!clone)\n\t\treturn NULL;\n\n\tclone->dev_port = orig->dev_port;\n\treturn clone;\n}\n\nstatic int qeth_core_probe_device(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card;\n\tstruct device *dev;\n\tint rc;\n\tenum qeth_discipline_id enforced_disc;\n\tchar dbf_name[DBF_NAME_LEN];\n\n\tQETH_DBF_TEXT(SETUP, 2, \"probedev\");\n\n\tdev = &gdev->dev;\n\tif (!get_device(dev))\n\t\treturn -ENODEV;\n\n\tQETH_DBF_TEXT_(SETUP, 2, \"%s\", dev_name(&gdev->dev));\n\n\tcard = qeth_alloc_card(gdev);\n\tif (!card) {\n\t\tQETH_DBF_TEXT_(SETUP, 2, \"1err%d\", -ENOMEM);\n\t\trc = -ENOMEM;\n\t\tgoto err_dev;\n\t}\n\n\tscnprintf(dbf_name, sizeof(dbf_name), \"qeth_card_%s\",\n\t\t  dev_name(&gdev->dev));\n\tcard->debug = qeth_get_dbf_entry(dbf_name);\n\tif (!card->debug) {\n\t\trc = qeth_add_dbf_entry(card, dbf_name);\n\t\tif (rc)\n\t\t\tgoto err_card;\n\t}\n\n\tqeth_setup_card(card);\n\tcard->dev = qeth_alloc_netdev(card);\n\tif (!card->dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_card;\n\t}\n\n\tqeth_determine_capabilities(card);\n\tqeth_set_blkt_defaults(card);\n\n\tcard->qdio.in_q = qeth_alloc_qdio_queue();\n\tif (!card->qdio.in_q) {\n\t\trc = -ENOMEM;\n\t\tgoto err_rx_queue;\n\t}\n\n\tcard->qdio.no_out_queues = card->dev->num_tx_queues;\n\trc = qeth_update_from_chp_desc(card);\n\tif (rc)\n\t\tgoto err_chp_desc;\n\n\tgdev->dev.groups = qeth_dev_groups;\n\n\tenforced_disc = qeth_enforce_discipline(card);\n\tswitch (enforced_disc) {\n\tcase QETH_DISCIPLINE_UNDETERMINED:\n\t\tgdev->dev.type = &qeth_generic_devtype;\n\t\tbreak;\n\tdefault:\n\t\tcard->info.layer_enforced = true;\n\t\t \n\t\trc = qeth_setup_discipline(card, enforced_disc);\n\t\tif (rc)\n\t\t\tgoto err_setup_disc;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nerr_setup_disc:\nerr_chp_desc:\n\tqeth_free_qdio_queue(card->qdio.in_q);\nerr_rx_queue:\n\tfree_netdev(card->dev);\nerr_card:\n\tqeth_core_free_card(card);\nerr_dev:\n\tput_device(dev);\n\treturn rc;\n}\n\nstatic void qeth_core_remove_device(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\n\tQETH_CARD_TEXT(card, 2, \"removedv\");\n\n\tmutex_lock(&card->discipline_mutex);\n\tif (card->discipline)\n\t\tqeth_remove_discipline(card);\n\tmutex_unlock(&card->discipline_mutex);\n\n\tqeth_free_qdio_queues(card);\n\n\tqeth_free_qdio_queue(card->qdio.in_q);\n\tfree_netdev(card->dev);\n\tqeth_core_free_card(card);\n\tput_device(&gdev->dev);\n}\n\nstatic int qeth_core_set_online(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tint rc = 0;\n\tenum qeth_discipline_id def_discipline;\n\n\tmutex_lock(&card->discipline_mutex);\n\tif (!card->discipline) {\n\t\tdef_discipline = IS_IQD(card) ? QETH_DISCIPLINE_LAYER3 :\n\t\t\t\t\t\tQETH_DISCIPLINE_LAYER2;\n\t\trc = qeth_setup_discipline(card, def_discipline);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\trc = qeth_set_online(card, card->discipline);\n\nerr:\n\tmutex_unlock(&card->discipline_mutex);\n\treturn rc;\n}\n\nstatic int qeth_core_set_offline(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tint rc;\n\n\tmutex_lock(&card->discipline_mutex);\n\trc = qeth_set_offline(card, card->discipline, false);\n\tmutex_unlock(&card->discipline_mutex);\n\n\treturn rc;\n}\n\nstatic void qeth_core_shutdown(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\n\tqeth_set_allowed_threads(card, 0, 1);\n\tif ((gdev->state == CCWGROUP_ONLINE) && card->info.hwtrap)\n\t\tqeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\n\tqeth_qdio_clear_card(card, 0);\n\tqeth_drain_output_queues(card);\n\tqdio_free(CARD_DDEV(card));\n}\n\nstatic ssize_t group_store(struct device_driver *ddrv, const char *buf,\n\t\t\t   size_t count)\n{\n\tint err;\n\n\terr = ccwgroup_create_dev(qeth_core_root_dev, to_ccwgroupdrv(ddrv), 3,\n\t\t\t\t  buf);\n\n\treturn err ? err : count;\n}\nstatic DRIVER_ATTR_WO(group);\n\nstatic struct attribute *qeth_drv_attrs[] = {\n\t&driver_attr_group.attr,\n\tNULL,\n};\nstatic struct attribute_group qeth_drv_attr_group = {\n\t.attrs = qeth_drv_attrs,\n};\nstatic const struct attribute_group *qeth_drv_attr_groups[] = {\n\t&qeth_drv_attr_group,\n\tNULL,\n};\n\nstatic struct ccwgroup_driver qeth_core_ccwgroup_driver = {\n\t.driver = {\n\t\t.groups = qeth_drv_attr_groups,\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"qeth\",\n\t},\n\t.ccw_driver = &qeth_ccw_driver,\n\t.setup = qeth_core_probe_device,\n\t.remove = qeth_core_remove_device,\n\t.set_online = qeth_core_set_online,\n\t.set_offline = qeth_core_set_offline,\n\t.shutdown = qeth_core_shutdown,\n};\n\nint qeth_siocdevprivate(struct net_device *dev, struct ifreq *rq, void __user *data, int cmd)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tint rc = 0;\n\n\tswitch (cmd) {\n\tcase SIOC_QETH_ADP_SET_SNMP_CONTROL:\n\t\trc = qeth_snmp_command(card, data);\n\t\tbreak;\n\tcase SIOC_QETH_GET_CARD_TYPE:\n\t\tif ((IS_OSD(card) || IS_OSM(card) || IS_OSX(card)) &&\n\t\t    !IS_VM_NIC(card))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase SIOC_QETH_QUERY_OAT:\n\t\trc = qeth_query_oat_command(card, data);\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"ioce%x\", rc);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_siocdevprivate);\n\nint qeth_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tstruct mii_ioctl_data *mii_data;\n\tint rc = 0;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmii_data = if_mii(rq);\n\t\tmii_data->phy_id = 0;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tmii_data = if_mii(rq);\n\t\tif (mii_data->phy_id != 0)\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\tmii_data->val_out = qeth_mdio_read(dev,\n\t\t\t\tmii_data->phy_id, mii_data->reg_num);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"ioce%x\", rc);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_do_ioctl);\n\nstatic int qeth_start_csum_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\t\t      unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tu32 *features = reply->param;\n\n\tif (qeth_setassparms_inspect_rc(cmd))\n\t\treturn -EIO;\n\n\t*features = cmd->data.setassparms.data.flags_32bit;\n\treturn 0;\n}\n\nstatic int qeth_set_csum_off(struct qeth_card *card, enum qeth_ipa_funcs cstype,\n\t\t\t     enum qeth_prot_versions prot)\n{\n\treturn qeth_send_simple_setassparms_prot(card, cstype, IPA_CMD_ASS_STOP,\n\t\t\t\t\t\t NULL, prot);\n}\n\nstatic int qeth_set_csum_on(struct qeth_card *card, enum qeth_ipa_funcs cstype,\n\t\t\t    enum qeth_prot_versions prot, u8 *lp2lp)\n{\n\tu32 required_features = QETH_IPA_CHECKSUM_UDP | QETH_IPA_CHECKSUM_TCP;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_caps caps;\n\tu32 features;\n\tint rc;\n\n\t \n\tif (IS_LAYER3(card) && prot == QETH_PROT_IPV4 &&\n\t    cstype == IPA_OUTBOUND_CHECKSUM)\n\t\trequired_features |= QETH_IPA_CHECKSUM_IP_HDR;\n\n\tiob = qeth_get_setassparms_cmd(card, cstype, IPA_CMD_ASS_START, 0,\n\t\t\t\t       prot);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_start_csum_cb, &features);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((required_features & features) != required_features) {\n\t\tqeth_set_csum_off(card, cstype, prot);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tiob = qeth_get_setassparms_cmd(card, cstype, IPA_CMD_ASS_ENABLE,\n\t\t\t\t       SETASS_DATA_SIZEOF(flags_32bit),\n\t\t\t\t       prot);\n\tif (!iob) {\n\t\tqeth_set_csum_off(card, cstype, prot);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (features & QETH_IPA_CHECKSUM_LP2LP)\n\t\trequired_features |= QETH_IPA_CHECKSUM_LP2LP;\n\t__ipa_cmd(iob)->data.setassparms.data.flags_32bit = required_features;\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setassparms_get_caps_cb, &caps);\n\tif (rc) {\n\t\tqeth_set_csum_off(card, cstype, prot);\n\t\treturn rc;\n\t}\n\n\tif (!qeth_ipa_caps_supported(&caps, required_features) ||\n\t    !qeth_ipa_caps_enabled(&caps, required_features)) {\n\t\tqeth_set_csum_off(card, cstype, prot);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdev_info(&card->gdev->dev, \"HW Checksumming (%sbound IPv%d) enabled\\n\",\n\t\t cstype == IPA_INBOUND_CHECKSUM ? \"in\" : \"out\", prot);\n\n\tif (lp2lp)\n\t\t*lp2lp = qeth_ipa_caps_enabled(&caps, QETH_IPA_CHECKSUM_LP2LP);\n\n\treturn 0;\n}\n\nstatic int qeth_set_ipa_csum(struct qeth_card *card, bool on, int cstype,\n\t\t\t     enum qeth_prot_versions prot, u8 *lp2lp)\n{\n\treturn on ? qeth_set_csum_on(card, cstype, prot, lp2lp) :\n\t\t    qeth_set_csum_off(card, cstype, prot);\n}\n\nstatic int qeth_start_tso_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\t\t     unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_tso_start_data *tso_data = reply->param;\n\n\tif (qeth_setassparms_inspect_rc(cmd))\n\t\treturn -EIO;\n\n\ttso_data->mss = cmd->data.setassparms.data.tso.mss;\n\ttso_data->supported = cmd->data.setassparms.data.tso.supported;\n\treturn 0;\n}\n\nstatic int qeth_set_tso_off(struct qeth_card *card,\n\t\t\t    enum qeth_prot_versions prot)\n{\n\treturn qeth_send_simple_setassparms_prot(card, IPA_OUTBOUND_TSO,\n\t\t\t\t\t\t IPA_CMD_ASS_STOP, NULL, prot);\n}\n\nstatic int qeth_set_tso_on(struct qeth_card *card,\n\t\t\t   enum qeth_prot_versions prot)\n{\n\tstruct qeth_tso_start_data tso_data;\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_caps caps;\n\tint rc;\n\n\tiob = qeth_get_setassparms_cmd(card, IPA_OUTBOUND_TSO,\n\t\t\t\t       IPA_CMD_ASS_START, 0, prot);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_start_tso_cb, &tso_data);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!tso_data.mss || !(tso_data.supported & QETH_IPA_LARGE_SEND_TCP)) {\n\t\tqeth_set_tso_off(card, prot);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tiob = qeth_get_setassparms_cmd(card, IPA_OUTBOUND_TSO,\n\t\t\t\t       IPA_CMD_ASS_ENABLE,\n\t\t\t\t       SETASS_DATA_SIZEOF(caps), prot);\n\tif (!iob) {\n\t\tqeth_set_tso_off(card, prot);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\t__ipa_cmd(iob)->data.setassparms.data.caps.enabled =\n\t\tQETH_IPA_LARGE_SEND_TCP;\n\trc = qeth_send_ipa_cmd(card, iob, qeth_setassparms_get_caps_cb, &caps);\n\tif (rc) {\n\t\tqeth_set_tso_off(card, prot);\n\t\treturn rc;\n\t}\n\n\tif (!qeth_ipa_caps_supported(&caps, QETH_IPA_LARGE_SEND_TCP) ||\n\t    !qeth_ipa_caps_enabled(&caps, QETH_IPA_LARGE_SEND_TCP)) {\n\t\tqeth_set_tso_off(card, prot);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdev_info(&card->gdev->dev, \"TSOv%u enabled (MSS: %u)\\n\", prot,\n\t\t tso_data.mss);\n\treturn 0;\n}\n\nstatic int qeth_set_ipa_tso(struct qeth_card *card, bool on,\n\t\t\t    enum qeth_prot_versions prot)\n{\n\treturn on ? qeth_set_tso_on(card, prot) : qeth_set_tso_off(card, prot);\n}\n\nstatic int qeth_set_ipa_rx_csum(struct qeth_card *card, bool on)\n{\n\tint rc_ipv4 = (on) ? -EOPNOTSUPP : 0;\n\tint rc_ipv6;\n\n\tif (qeth_is_supported(card, IPA_INBOUND_CHECKSUM))\n\t\trc_ipv4 = qeth_set_ipa_csum(card, on, IPA_INBOUND_CHECKSUM,\n\t\t\t\t\t    QETH_PROT_IPV4, NULL);\n\tif (!qeth_is_supported6(card, IPA_INBOUND_CHECKSUM_V6))\n\t\t \n\t\treturn rc_ipv4;\n\n\trc_ipv6 = qeth_set_ipa_csum(card, on, IPA_INBOUND_CHECKSUM,\n\t\t\t\t    QETH_PROT_IPV6, NULL);\n\n\tif (on)\n\t\t \n\t\treturn (rc_ipv6) ? rc_ipv4 : 0;\n\n\t \n\treturn (rc_ipv6) ? rc_ipv6 : rc_ipv4;\n}\n\n \nvoid qeth_enable_hw_features(struct net_device *dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tnetdev_features_t features;\n\n\tfeatures = dev->features;\n\t \n\tdev->features &= ~dev->hw_features;\n\t \n\tif (IS_LAYER2(card) && IS_VM_NIC(card)) {\n\t\tdev->features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\tdev->wanted_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\t}\n\tnetdev_update_features(dev);\n\tif (features != dev->features)\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Device recovery failed to restore all offload features\\n\");\n}\nEXPORT_SYMBOL_GPL(qeth_enable_hw_features);\n\nstatic void qeth_check_restricted_features(struct qeth_card *card,\n\t\t\t\t\t   netdev_features_t changed,\n\t\t\t\t\t   netdev_features_t actual)\n{\n\tnetdev_features_t ipv6_features = NETIF_F_TSO6;\n\tnetdev_features_t ipv4_features = NETIF_F_TSO;\n\n\tif (!card->info.has_lp2lp_cso_v6)\n\t\tipv6_features |= NETIF_F_IPV6_CSUM;\n\tif (!card->info.has_lp2lp_cso_v4)\n\t\tipv4_features |= NETIF_F_IP_CSUM;\n\n\tif ((changed & ipv6_features) && !(actual & ipv6_features))\n\t\tqeth_flush_local_addrs6(card);\n\tif ((changed & ipv4_features) && !(actual & ipv4_features))\n\t\tqeth_flush_local_addrs4(card);\n}\n\nint qeth_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tnetdev_features_t changed = dev->features ^ features;\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"setfeat\");\n\tQETH_CARD_HEX(card, 2, &features, sizeof(features));\n\n\tif ((changed & NETIF_F_IP_CSUM)) {\n\t\trc = qeth_set_ipa_csum(card, features & NETIF_F_IP_CSUM,\n\t\t\t\t       IPA_OUTBOUND_CHECKSUM, QETH_PROT_IPV4,\n\t\t\t\t       &card->info.has_lp2lp_cso_v4);\n\t\tif (rc)\n\t\t\tchanged ^= NETIF_F_IP_CSUM;\n\t}\n\tif (changed & NETIF_F_IPV6_CSUM) {\n\t\trc = qeth_set_ipa_csum(card, features & NETIF_F_IPV6_CSUM,\n\t\t\t\t       IPA_OUTBOUND_CHECKSUM, QETH_PROT_IPV6,\n\t\t\t\t       &card->info.has_lp2lp_cso_v6);\n\t\tif (rc)\n\t\t\tchanged ^= NETIF_F_IPV6_CSUM;\n\t}\n\tif (changed & NETIF_F_RXCSUM) {\n\t\trc = qeth_set_ipa_rx_csum(card, features & NETIF_F_RXCSUM);\n\t\tif (rc)\n\t\t\tchanged ^= NETIF_F_RXCSUM;\n\t}\n\tif (changed & NETIF_F_TSO) {\n\t\trc = qeth_set_ipa_tso(card, features & NETIF_F_TSO,\n\t\t\t\t      QETH_PROT_IPV4);\n\t\tif (rc)\n\t\t\tchanged ^= NETIF_F_TSO;\n\t}\n\tif (changed & NETIF_F_TSO6) {\n\t\trc = qeth_set_ipa_tso(card, features & NETIF_F_TSO6,\n\t\t\t\t      QETH_PROT_IPV6);\n\t\tif (rc)\n\t\t\tchanged ^= NETIF_F_TSO6;\n\t}\n\n\tqeth_check_restricted_features(card, dev->features ^ features,\n\t\t\t\t       dev->features ^ changed);\n\n\t \n\tif ((dev->features ^ features) == changed)\n\t\treturn 0;\n\t \n\tdev->features ^= changed;\n\treturn -EIO;\n}\nEXPORT_SYMBOL_GPL(qeth_set_features);\n\nnetdev_features_t qeth_fix_features(struct net_device *dev,\n\t\t\t\t    netdev_features_t features)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tQETH_CARD_TEXT(card, 2, \"fixfeat\");\n\tif (!qeth_is_supported(card, IPA_OUTBOUND_CHECKSUM))\n\t\tfeatures &= ~NETIF_F_IP_CSUM;\n\tif (!qeth_is_supported6(card, IPA_OUTBOUND_CHECKSUM_V6))\n\t\tfeatures &= ~NETIF_F_IPV6_CSUM;\n\tif (!qeth_is_supported(card, IPA_INBOUND_CHECKSUM) &&\n\t    !qeth_is_supported6(card, IPA_INBOUND_CHECKSUM_V6))\n\t\tfeatures &= ~NETIF_F_RXCSUM;\n\tif (!qeth_is_supported(card, IPA_OUTBOUND_TSO))\n\t\tfeatures &= ~NETIF_F_TSO;\n\tif (!qeth_is_supported6(card, IPA_OUTBOUND_TSO))\n\t\tfeatures &= ~NETIF_F_TSO6;\n\n\tQETH_CARD_HEX(card, 2, &features, sizeof(features));\n\treturn features;\n}\nEXPORT_SYMBOL_GPL(qeth_fix_features);\n\nnetdev_features_t qeth_features_check(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      netdev_features_t features)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    READ_ONCE(card->options.isolation) != ISOLATION_MODE_FWD) {\n\t\tnetdev_features_t restricted = 0;\n\n\t\tif (skb_is_gso(skb) && !netif_needs_gso(skb, features))\n\t\t\trestricted |= NETIF_F_ALL_TSO;\n\n\t\tswitch (vlan_get_protocol(skb)) {\n\t\tcase htons(ETH_P_IP):\n\t\t\tif (!card->info.has_lp2lp_cso_v4)\n\t\t\t\trestricted |= NETIF_F_IP_CSUM;\n\n\t\t\tif (restricted && qeth_next_hop_is_local_v4(card, skb))\n\t\t\t\tfeatures &= ~restricted;\n\t\t\tbreak;\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tif (!card->info.has_lp2lp_cso_v6)\n\t\t\t\trestricted |= NETIF_F_IPV6_CSUM;\n\n\t\t\tif (restricted && qeth_next_hop_is_local_v6(card, skb))\n\t\t\t\tfeatures &= ~restricted;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (netif_needs_gso(skb, features)) {\n\t\t \n\t\tunsigned int doffset = skb->data - skb_mac_header(skb);\n\t\tunsigned int hsize = skb_shinfo(skb)->gso_size;\n\t\tunsigned int hroom = skb_headroom(skb);\n\n\t\t \n\t\tif (SKB_DATA_ALIGN(hroom + doffset + hsize) <= SKB_MAX_HEAD(0))\n\t\t\tfeatures &= ~NETIF_F_SG;\n\t}\n\n\treturn vlan_features_check(skb, features);\n}\nEXPORT_SYMBOL_GPL(qeth_features_check);\n\nvoid qeth_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tstruct qeth_qdio_out_q *queue;\n\tunsigned int i;\n\n\tQETH_CARD_TEXT(card, 5, \"getstat\");\n\n\tstats->rx_packets = card->stats.rx_packets;\n\tstats->rx_bytes = card->stats.rx_bytes;\n\tstats->rx_errors = card->stats.rx_length_errors +\n\t\t\t   card->stats.rx_frame_errors +\n\t\t\t   card->stats.rx_fifo_errors;\n\tstats->rx_dropped = card->stats.rx_dropped_nomem +\n\t\t\t    card->stats.rx_dropped_notsupp +\n\t\t\t    card->stats.rx_dropped_runt;\n\tstats->multicast = card->stats.rx_multicast;\n\tstats->rx_length_errors = card->stats.rx_length_errors;\n\tstats->rx_frame_errors = card->stats.rx_frame_errors;\n\tstats->rx_fifo_errors = card->stats.rx_fifo_errors;\n\n\tfor (i = 0; i < card->qdio.no_out_queues; i++) {\n\t\tqueue = card->qdio.out_qs[i];\n\n\t\tstats->tx_packets += queue->stats.tx_packets;\n\t\tstats->tx_bytes += queue->stats.tx_bytes;\n\t\tstats->tx_errors += queue->stats.tx_errors;\n\t\tstats->tx_dropped += queue->stats.tx_dropped;\n\t}\n}\nEXPORT_SYMBOL_GPL(qeth_get_stats64);\n\n#define TC_IQD_UCAST   0\nstatic void qeth_iqd_set_prio_tc_map(struct net_device *dev,\n\t\t\t\t     unsigned int ucast_txqs)\n{\n\tunsigned int prio;\n\n\t \n\n\t \n\tnetdev_set_num_tc(dev, 1);\n\tnetdev_set_tc_queue(dev, TC_IQD_UCAST, ucast_txqs,\n\t\t\t    QETH_IQD_MIN_UCAST_TXQ);\n\n\t \n\tfor (prio = 0; prio <= TC_BITMASK; prio++)\n\t\tnetdev_set_prio_tc_map(dev, prio, TC_IQD_UCAST);\n}\n\nint qeth_set_real_num_tx_queues(struct qeth_card *card, unsigned int count)\n{\n\tstruct net_device *dev = card->dev;\n\tint rc;\n\n\t \n\tif (IS_IQD(card))\n\t\tqeth_iqd_set_prio_tc_map(dev, count - 1);\n\n\trc = netif_set_real_num_tx_queues(dev, count);\n\n\tif (rc && IS_IQD(card))\n\t\tqeth_iqd_set_prio_tc_map(dev, dev->real_num_tx_queues - 1);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(qeth_set_real_num_tx_queues);\n\nu16 qeth_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t  u8 cast_type, struct net_device *sb_dev)\n{\n\tu16 txq;\n\n\tif (cast_type != RTN_UNICAST)\n\t\treturn QETH_IQD_MCAST_TXQ;\n\tif (dev->real_num_tx_queues == QETH_IQD_MIN_TXQ)\n\t\treturn QETH_IQD_MIN_UCAST_TXQ;\n\n\ttxq = netdev_pick_tx(dev, skb, sb_dev);\n\treturn (txq == QETH_IQD_MCAST_TXQ) ? QETH_IQD_MIN_UCAST_TXQ : txq;\n}\nEXPORT_SYMBOL_GPL(qeth_iqd_select_queue);\n\nu16 qeth_osa_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t  struct net_device *sb_dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tif (qeth_uses_tx_prio_queueing(card))\n\t\treturn qeth_get_priority_queue(card, skb);\n\n\treturn netdev_pick_tx(dev, skb, sb_dev);\n}\nEXPORT_SYMBOL_GPL(qeth_osa_select_queue);\n\nint qeth_open(struct net_device *dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tstruct qeth_qdio_out_q *queue;\n\tunsigned int i;\n\n\tQETH_CARD_TEXT(card, 4, \"qethopen\");\n\n\tcard->data.state = CH_STATE_UP;\n\tnetif_tx_start_all_queues(dev);\n\n\tlocal_bh_disable();\n\tqeth_for_each_output_queue(card, queue, i) {\n\t\tnetif_napi_add_tx(dev, &queue->napi, qeth_tx_poll);\n\t\tnapi_enable(&queue->napi);\n\t\tnapi_schedule(&queue->napi);\n\t}\n\n\tnapi_enable(&card->napi);\n\tnapi_schedule(&card->napi);\n\t \n\tlocal_bh_enable();\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_open);\n\nint qeth_stop(struct net_device *dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tstruct qeth_qdio_out_q *queue;\n\tunsigned int i;\n\n\tQETH_CARD_TEXT(card, 4, \"qethstop\");\n\n\tnapi_disable(&card->napi);\n\tcancel_delayed_work_sync(&card->buffer_reclaim_work);\n\tqdio_stop_irq(CARD_DDEV(card));\n\n\t \n\tqeth_for_each_output_queue(card, queue, i)\n\t\tnapi_disable(&queue->napi);\n\n\t \n\tnetif_tx_disable(dev);\n\n\tqeth_for_each_output_queue(card, queue, i) {\n\t\tdel_timer_sync(&queue->timer);\n\t\t \n\t\tnetif_napi_del(&queue->napi);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qeth_stop);\n\nstatic int __init qeth_core_init(void)\n{\n\tint rc;\n\n\tpr_info(\"loading core functions\\n\");\n\n\tqeth_debugfs_root = debugfs_create_dir(\"qeth\", NULL);\n\n\trc = qeth_register_dbf_views();\n\tif (rc)\n\t\tgoto dbf_err;\n\tqeth_core_root_dev = root_device_register(\"qeth\");\n\trc = PTR_ERR_OR_ZERO(qeth_core_root_dev);\n\tif (rc)\n\t\tgoto register_err;\n\tqeth_core_header_cache =\n\t\tkmem_cache_create(\"qeth_hdr\", QETH_HDR_CACHE_OBJ_SIZE,\n\t\t\t\t  roundup_pow_of_two(QETH_HDR_CACHE_OBJ_SIZE),\n\t\t\t\t  0, NULL);\n\tif (!qeth_core_header_cache) {\n\t\trc = -ENOMEM;\n\t\tgoto slab_err;\n\t}\n\tqeth_qdio_outbuf_cache = kmem_cache_create(\"qeth_buf\",\n\t\t\tsizeof(struct qeth_qdio_out_buffer), 0, 0, NULL);\n\tif (!qeth_qdio_outbuf_cache) {\n\t\trc = -ENOMEM;\n\t\tgoto cqslab_err;\n\t}\n\n\tqeth_qaob_cache = kmem_cache_create(\"qeth_qaob\",\n\t\t\t\t\t    sizeof(struct qaob),\n\t\t\t\t\t    sizeof(struct qaob),\n\t\t\t\t\t    0, NULL);\n\tif (!qeth_qaob_cache) {\n\t\trc = -ENOMEM;\n\t\tgoto qaob_err;\n\t}\n\n\trc = ccw_driver_register(&qeth_ccw_driver);\n\tif (rc)\n\t\tgoto ccw_err;\n\trc = ccwgroup_driver_register(&qeth_core_ccwgroup_driver);\n\tif (rc)\n\t\tgoto ccwgroup_err;\n\n\treturn 0;\n\nccwgroup_err:\n\tccw_driver_unregister(&qeth_ccw_driver);\nccw_err:\n\tkmem_cache_destroy(qeth_qaob_cache);\nqaob_err:\n\tkmem_cache_destroy(qeth_qdio_outbuf_cache);\ncqslab_err:\n\tkmem_cache_destroy(qeth_core_header_cache);\nslab_err:\n\troot_device_unregister(qeth_core_root_dev);\nregister_err:\n\tqeth_unregister_dbf_views();\ndbf_err:\n\tdebugfs_remove_recursive(qeth_debugfs_root);\n\tpr_err(\"Initializing the qeth device driver failed\\n\");\n\treturn rc;\n}\n\nstatic void __exit qeth_core_exit(void)\n{\n\tqeth_clear_dbf_list();\n\tccwgroup_driver_unregister(&qeth_core_ccwgroup_driver);\n\tccw_driver_unregister(&qeth_ccw_driver);\n\tkmem_cache_destroy(qeth_qaob_cache);\n\tkmem_cache_destroy(qeth_qdio_outbuf_cache);\n\tkmem_cache_destroy(qeth_core_header_cache);\n\troot_device_unregister(qeth_core_root_dev);\n\tqeth_unregister_dbf_views();\n\tdebugfs_remove_recursive(qeth_debugfs_root);\n\tpr_info(\"core functions removed\\n\");\n}\n\nmodule_init(qeth_core_init);\nmodule_exit(qeth_core_exit);\nMODULE_AUTHOR(\"Frank Blaschka <frank.blaschka@de.ibm.com>\");\nMODULE_DESCRIPTION(\"qeth core functions\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}