{
  "module_name": "qeth_core_sys.c",
  "hash_id": "1a74eca9a2bcaff798cd77dd54c9c2c082fc7e16894d99ed7c6ae3b1a18a9c0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/qeth_core_sys.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"qeth\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/list.h>\n#include <linux/rwsem.h>\n#include <asm/ebcdic.h>\n\n#include \"qeth_core.h\"\n\nstatic ssize_t qeth_dev_state_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\tswitch (card->state) {\n\tcase CARD_STATE_DOWN:\n\t\treturn sysfs_emit(buf, \"DOWN\\n\");\n\tcase CARD_STATE_SOFTSETUP:\n\t\tif (card->dev->flags & IFF_UP)\n\t\t\treturn sysfs_emit(buf, \"UP (LAN %s)\\n\",\n\t\t\t\t\t  netif_carrier_ok(card->dev) ?\n\t\t\t\t\t  \"ONLINE\" : \"OFFLINE\");\n\t\treturn sysfs_emit(buf, \"SOFTSETUP\\n\");\n\tdefault:\n\t\treturn sysfs_emit(buf, \"UNKNOWN\\n\");\n\t}\n}\n\nstatic DEVICE_ATTR(state, 0444, qeth_dev_state_show, NULL);\n\nstatic ssize_t qeth_dev_chpid_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%02X\\n\", card->info.chpid);\n}\n\nstatic DEVICE_ATTR(chpid, 0444, qeth_dev_chpid_show, NULL);\n\nstatic ssize_t qeth_dev_if_name_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", netdev_name(card->dev));\n}\n\nstatic DEVICE_ATTR(if_name, 0444, qeth_dev_if_name_show, NULL);\n\nstatic ssize_t qeth_dev_card_type_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", qeth_get_cardname_short(card));\n}\n\nstatic DEVICE_ATTR(card_type, 0444, qeth_dev_card_type_show, NULL);\n\nstatic const char *qeth_get_bufsize_str(struct qeth_card *card)\n{\n\tif (card->qdio.in_buf_size == 16384)\n\t\treturn \"16k\";\n\telse if (card->qdio.in_buf_size == 24576)\n\t\treturn \"24k\";\n\telse if (card->qdio.in_buf_size == 32768)\n\t\treturn \"32k\";\n\telse if (card->qdio.in_buf_size == 40960)\n\t\treturn \"40k\";\n\telse\n\t\treturn \"64k\";\n}\n\nstatic ssize_t qeth_dev_inbuf_size_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", qeth_get_bufsize_str(card));\n}\n\nstatic DEVICE_ATTR(inbuf_size, 0444, qeth_dev_inbuf_size_show, NULL);\n\nstatic ssize_t qeth_dev_portno_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", card->dev->dev_port);\n}\n\nstatic ssize_t qeth_dev_portno_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tunsigned int portno, limit;\n\tint rc = 0;\n\n\trc = kstrtouint(buf, 16, &portno);\n\tif (rc)\n\t\treturn rc;\n\tif (portno > QETH_MAX_PORTNO)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (card->state != CARD_STATE_DOWN) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tlimit = (card->ssqd.pcnt ? card->ssqd.pcnt - 1 : card->ssqd.pcnt);\n\tif (portno > limit) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tcard->dev->dev_port = portno;\nout:\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(portno, 0644, qeth_dev_portno_show, qeth_dev_portno_store);\n\nstatic ssize_t qeth_dev_portname_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"no portname required\\n\");\n}\n\nstatic ssize_t qeth_dev_portname_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\tdev_warn_once(&card->gdev->dev,\n\t\t      \"portname is deprecated and is ignored\\n\");\n\treturn count;\n}\n\nstatic DEVICE_ATTR(portname, 0644, qeth_dev_portname_show,\n\t\tqeth_dev_portname_store);\n\nstatic ssize_t qeth_dev_prioqing_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\tswitch (card->qdio.do_prio_queueing) {\n\tcase QETH_PRIO_Q_ING_PREC:\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"by precedence\");\n\tcase QETH_PRIO_Q_ING_TOS:\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"by type of service\");\n\tcase QETH_PRIO_Q_ING_SKB:\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"by skb-priority\");\n\tcase QETH_PRIO_Q_ING_VLAN:\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"by VLAN headers\");\n\tcase QETH_PRIO_Q_ING_FIXED:\n\t\treturn sysfs_emit(buf, \"always queue %i\\n\",\n\t\t\t       card->qdio.default_out_queue);\n\tdefault:\n\t\treturn sysfs_emit(buf, \"disabled\\n\");\n\t}\n}\n\nstatic ssize_t qeth_dev_prioqing_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tint rc = 0;\n\n\tif (IS_IQD(card) || IS_VM_NIC(card))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (card->state != CARD_STATE_DOWN) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (card->qdio.no_out_queues == 1) {\n\t\tcard->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (sysfs_streq(buf, \"prio_queueing_prec\")) {\n\t\tcard->qdio.do_prio_queueing = QETH_PRIO_Q_ING_PREC;\n\t\tcard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\n\t} else if (sysfs_streq(buf, \"prio_queueing_skb\")) {\n\t\tcard->qdio.do_prio_queueing = QETH_PRIO_Q_ING_SKB;\n\t\tcard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\n\t} else if (sysfs_streq(buf, \"prio_queueing_tos\")) {\n\t\tcard->qdio.do_prio_queueing = QETH_PRIO_Q_ING_TOS;\n\t\tcard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\n\t} else if (sysfs_streq(buf, \"prio_queueing_vlan\")) {\n\t\tif (IS_LAYER3(card)) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tcard->qdio.do_prio_queueing = QETH_PRIO_Q_ING_VLAN;\n\t\tcard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\n\t} else if (sysfs_streq(buf, \"no_prio_queueing:0\")) {\n\t\tcard->qdio.do_prio_queueing = QETH_PRIO_Q_ING_FIXED;\n\t\tcard->qdio.default_out_queue = 0;\n\t} else if (sysfs_streq(buf, \"no_prio_queueing:1\")) {\n\t\tcard->qdio.do_prio_queueing = QETH_PRIO_Q_ING_FIXED;\n\t\tcard->qdio.default_out_queue = 1;\n\t} else if (sysfs_streq(buf, \"no_prio_queueing:2\")) {\n\t\tcard->qdio.do_prio_queueing = QETH_PRIO_Q_ING_FIXED;\n\t\tcard->qdio.default_out_queue = 2;\n\t} else if (sysfs_streq(buf, \"no_prio_queueing:3\")) {\n\t\tcard->qdio.do_prio_queueing = QETH_PRIO_Q_ING_FIXED;\n\t\tcard->qdio.default_out_queue = 3;\n\t} else if (sysfs_streq(buf, \"no_prio_queueing\")) {\n\t\tcard->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;\n\t\tcard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\n\t} else\n\t\trc = -EINVAL;\nout:\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(priority_queueing, 0644, qeth_dev_prioqing_show,\n\t\tqeth_dev_prioqing_store);\n\nstatic ssize_t qeth_dev_bufcnt_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", card->qdio.in_buf_pool.buf_count);\n}\n\nstatic ssize_t qeth_dev_bufcnt_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tunsigned int cnt;\n\tint rc = 0;\n\n\trc = kstrtouint(buf, 10, &cnt);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (card->state != CARD_STATE_DOWN) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tcnt = clamp(cnt, QETH_IN_BUF_COUNT_MIN, QETH_IN_BUF_COUNT_MAX);\n\trc = qeth_resize_buffer_pool(card, cnt);\n\nout:\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(buffer_count, 0644, qeth_dev_bufcnt_show,\n\t\tqeth_dev_bufcnt_store);\n\nstatic ssize_t qeth_dev_recover_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tbool reset;\n\tint rc;\n\n\trc = kstrtobool(buf, &reset);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!qeth_card_hw_is_reachable(card))\n\t\treturn -EPERM;\n\n\tif (reset)\n\t\trc = qeth_schedule_recovery(card);\n\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(recover, 0200, NULL, qeth_dev_recover_store);\n\nstatic ssize_t qeth_dev_performance_stats_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"1\\n\");\n}\n\nstatic ssize_t qeth_dev_performance_stats_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tstruct qeth_qdio_out_q *queue;\n\tunsigned int i;\n\tbool reset;\n\tint rc;\n\n\trc = kstrtobool(buf, &reset);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reset) {\n\t\tmemset(&card->stats, 0, sizeof(card->stats));\n\t\tfor (i = 0; i < card->qdio.no_out_queues; i++) {\n\t\t\tqueue = card->qdio.out_qs[i];\n\t\t\tif (!queue)\n\t\t\t\tbreak;\n\t\t\tmemset(&queue->stats, 0, sizeof(queue->stats));\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(performance_stats, 0644, qeth_dev_performance_stats_show,\n\t\t   qeth_dev_performance_stats_store);\n\nstatic ssize_t qeth_dev_layer2_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", card->options.layer);\n}\n\nstatic ssize_t qeth_dev_layer2_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tstruct net_device *ndev;\n\tenum qeth_discipline_id newdis;\n\tunsigned int input;\n\tint rc;\n\n\trc = kstrtouint(buf, 16, &input);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (input) {\n\tcase 0:\n\t\tnewdis = QETH_DISCIPLINE_LAYER3;\n\t\tbreak;\n\tcase 1:\n\t\tnewdis = QETH_DISCIPLINE_LAYER2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&card->discipline_mutex);\n\tif (card->state != CARD_STATE_DOWN) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (card->options.layer == newdis)\n\t\tgoto out;\n\tif (card->info.layer_enforced) {\n\t\t \n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (card->discipline) {\n\t\t \n\t\tndev = qeth_clone_netdev(card->dev);\n\t\tif (!ndev) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tqeth_remove_discipline(card);\n\t\tfree_netdev(card->dev);\n\t\tcard->dev = ndev;\n\t}\n\n\trc = qeth_setup_discipline(card, newdis);\n\nout:\n\tmutex_unlock(&card->discipline_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(layer2, 0644, qeth_dev_layer2_show,\n\t\t   qeth_dev_layer2_store);\n\n#define ATTR_QETH_ISOLATION_NONE\t(\"none\")\n#define ATTR_QETH_ISOLATION_FWD\t\t(\"forward\")\n#define ATTR_QETH_ISOLATION_DROP\t(\"drop\")\n\nstatic ssize_t qeth_dev_isolation_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\tswitch (card->options.isolation) {\n\tcase ISOLATION_MODE_NONE:\n\t\treturn sysfs_emit(buf, \"%s\\n\", ATTR_QETH_ISOLATION_NONE);\n\tcase ISOLATION_MODE_FWD:\n\t\treturn sysfs_emit(buf, \"%s\\n\", ATTR_QETH_ISOLATION_FWD);\n\tcase ISOLATION_MODE_DROP:\n\t\treturn sysfs_emit(buf, \"%s\\n\", ATTR_QETH_ISOLATION_DROP);\n\tdefault:\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"N/A\");\n\t}\n}\n\nstatic ssize_t qeth_dev_isolation_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tenum qeth_ipa_isolation_modes isolation;\n\tint rc = 0;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (!IS_OSD(card) && !IS_OSX(card)) {\n\t\trc = -EOPNOTSUPP;\n\t\tdev_err(&card->gdev->dev, \"Adapter does not \"\n\t\t\t\"support QDIO data connection isolation\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (sysfs_streq(buf, ATTR_QETH_ISOLATION_NONE)) {\n\t\tisolation = ISOLATION_MODE_NONE;\n\t} else if (sysfs_streq(buf, ATTR_QETH_ISOLATION_FWD)) {\n\t\tisolation = ISOLATION_MODE_FWD;\n\t} else if (sysfs_streq(buf, ATTR_QETH_ISOLATION_DROP)) {\n\t\tisolation = ISOLATION_MODE_DROP;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (qeth_card_hw_is_reachable(card))\n\t\trc = qeth_setadpparms_set_access_ctrl(card, isolation);\n\n\tif (!rc)\n\t\tWRITE_ONCE(card->options.isolation, isolation);\n\nout:\n\tmutex_unlock(&card->conf_mutex);\n\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(isolation, 0644, qeth_dev_isolation_show,\n\t\t\tqeth_dev_isolation_store);\n\nstatic ssize_t qeth_dev_switch_attrs_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tstruct qeth_switch_info sw_info;\n\tint\trc = 0;\n\n\tif (!qeth_card_hw_is_reachable(card))\n\t\treturn sysfs_emit(buf, \"n/a\\n\");\n\n\trc = qeth_query_switch_attributes(card, &sw_info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!sw_info.capabilities)\n\t\trc = sysfs_emit(buf, \"unknown\");\n\n\tif (sw_info.capabilities & QETH_SWITCH_FORW_802_1)\n\t\trc = sysfs_emit(buf,\n\t\t\t\t(sw_info.settings & QETH_SWITCH_FORW_802_1 ?\n\t\t\t\t\"[802.1]\" : \"802.1\"));\n\tif (sw_info.capabilities & QETH_SWITCH_FORW_REFL_RELAY)\n\t\trc += sysfs_emit_at(buf, rc,\n\t\t\t\t    (sw_info.settings &\n\t\t\t\t    QETH_SWITCH_FORW_REFL_RELAY ?\n\t\t\t\t    \" [rr]\" : \" rr\"));\n\trc += sysfs_emit_at(buf, rc, \"\\n\");\n\n\treturn rc;\n}\n\nstatic DEVICE_ATTR(switch_attrs, 0444,\n\t\t   qeth_dev_switch_attrs_show, NULL);\n\nstatic ssize_t qeth_hw_trap_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\tif (card->info.hwtrap)\n\t\treturn sysfs_emit(buf, \"arm\\n\");\n\telse\n\t\treturn sysfs_emit(buf, \"disarm\\n\");\n}\n\nstatic ssize_t qeth_hw_trap_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tint rc = 0;\n\tint state = 0;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (qeth_card_hw_is_reachable(card))\n\t\tstate = 1;\n\n\tif (sysfs_streq(buf, \"arm\") && !card->info.hwtrap) {\n\t\tif (state) {\n\t\t\tif (qeth_is_diagass_supported(card,\n\t\t\t    QETH_DIAGS_CMD_TRAP)) {\n\t\t\t\trc = qeth_hw_trap(card, QETH_DIAGS_TRAP_ARM);\n\t\t\t\tif (!rc)\n\t\t\t\t\tcard->info.hwtrap = 1;\n\t\t\t} else\n\t\t\t\trc = -EINVAL;\n\t\t} else\n\t\t\tcard->info.hwtrap = 1;\n\t} else if (sysfs_streq(buf, \"disarm\") && card->info.hwtrap) {\n\t\tif (state) {\n\t\t\trc = qeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\n\t\t\tif (!rc)\n\t\t\t\tcard->info.hwtrap = 0;\n\t\t} else\n\t\t\tcard->info.hwtrap = 0;\n\t} else if (sysfs_streq(buf, \"trap\") && state && card->info.hwtrap)\n\t\trc = qeth_hw_trap(card, QETH_DIAGS_TRAP_CAPTURE);\n\telse\n\t\trc = -EINVAL;\n\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(hw_trap, 0644, qeth_hw_trap_show,\n\t\t   qeth_hw_trap_store);\n\nstatic ssize_t qeth_dev_blkt_store(struct qeth_card *card,\n\t\tconst char *buf, size_t count, int *value, int max_value)\n{\n\tunsigned int input;\n\tint rc;\n\n\trc = kstrtouint(buf, 10, &input);\n\tif (rc)\n\t\treturn rc;\n\n\tif (input > max_value)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&card->conf_mutex);\n\tif (card->state != CARD_STATE_DOWN)\n\t\trc = -EPERM;\n\telse\n\t\t*value = input;\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\nstatic ssize_t qeth_dev_blkt_total_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", card->info.blkt.time_total);\n}\n\nstatic ssize_t qeth_dev_blkt_total_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_dev_blkt_store(card, buf, count,\n\t\t\t\t   &card->info.blkt.time_total, 5000);\n}\n\nstatic DEVICE_ATTR(total, 0644, qeth_dev_blkt_total_show,\n\t\t   qeth_dev_blkt_total_store);\n\nstatic ssize_t qeth_dev_blkt_inter_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", card->info.blkt.inter_packet);\n}\n\nstatic ssize_t qeth_dev_blkt_inter_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_dev_blkt_store(card, buf, count,\n\t\t\t\t   &card->info.blkt.inter_packet, 1000);\n}\n\nstatic DEVICE_ATTR(inter, 0644, qeth_dev_blkt_inter_show,\n\t\t   qeth_dev_blkt_inter_store);\n\nstatic ssize_t qeth_dev_blkt_inter_jumbo_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%i\\n\", card->info.blkt.inter_packet_jumbo);\n}\n\nstatic ssize_t qeth_dev_blkt_inter_jumbo_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\treturn qeth_dev_blkt_store(card, buf, count,\n\t\t\t\t   &card->info.blkt.inter_packet_jumbo, 1000);\n}\n\nstatic DEVICE_ATTR(inter_jumbo, 0644, qeth_dev_blkt_inter_jumbo_show,\n\t\t   qeth_dev_blkt_inter_jumbo_store);\n\nstatic struct attribute *qeth_blkt_device_attrs[] = {\n\t&dev_attr_total.attr,\n\t&dev_attr_inter.attr,\n\t&dev_attr_inter_jumbo.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qeth_dev_blkt_group = {\n\t.name = \"blkt\",\n\t.attrs = qeth_blkt_device_attrs,\n};\n\nstatic struct attribute *qeth_dev_extended_attrs[] = {\n\t&dev_attr_inbuf_size.attr,\n\t&dev_attr_portno.attr,\n\t&dev_attr_portname.attr,\n\t&dev_attr_priority_queueing.attr,\n\t&dev_attr_performance_stats.attr,\n\t&dev_attr_layer2.attr,\n\t&dev_attr_isolation.attr,\n\t&dev_attr_hw_trap.attr,\n\t&dev_attr_switch_attrs.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qeth_dev_extended_group = {\n\t.attrs = qeth_dev_extended_attrs,\n};\n\nstatic struct attribute *qeth_dev_attrs[] = {\n\t&dev_attr_state.attr,\n\t&dev_attr_chpid.attr,\n\t&dev_attr_if_name.attr,\n\t&dev_attr_card_type.attr,\n\t&dev_attr_buffer_count.attr,\n\t&dev_attr_recover.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qeth_dev_group = {\n\t.attrs = qeth_dev_attrs,\n};\n\nconst struct attribute_group *qeth_dev_groups[] = {\n\t&qeth_dev_group,\n\t&qeth_dev_extended_group,\n\t&qeth_dev_blkt_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}