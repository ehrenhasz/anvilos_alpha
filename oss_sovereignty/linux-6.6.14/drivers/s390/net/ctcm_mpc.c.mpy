{
  "module_name": "ctcm_mpc.c",
  "hash_id": "c62c6182cdc22516edd1145d5c36514036f304f9fbbd6a84f0d924d17fab0dd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/ctcm_mpc.c",
  "human_readable_source": "\n \n\n \n\n#undef DEBUG\n#undef DEBUGDATA\n#undef DEBUGCCW\n\n#define KMSG_COMPONENT \"ctcm\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/sched.h>\n\n#include <linux/signal.h>\n#include <linux/string.h>\n#include <linux/proc_fs.h>\n\n#include <linux/ip.h>\n#include <linux/if_arp.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n#include <linux/netdevice.h>\n#include <net/dst.h>\n\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n#include <linux/moduleparam.h>\n#include <asm/ccwdev.h>\n#include <asm/ccwgroup.h>\n#include <asm/idals.h>\n\n#include \"ctcm_main.h\"\n#include \"ctcm_mpc.h\"\n#include \"ctcm_fsms.h\"\n\nstatic const struct xid2 init_xid = {\n\t.xid2_type_id\t=\tXID_FM2,\n\t.xid2_len\t=\t0x45,\n\t.xid2_adj_id\t=\t0,\n\t.xid2_rlen\t=\t0x31,\n\t.xid2_resv1\t=\t0,\n\t.xid2_flag1\t=\t0,\n\t.xid2_fmtt\t=\t0,\n\t.xid2_flag4\t=\t0x80,\n\t.xid2_resv2\t=\t0,\n\t.xid2_tgnum\t=\t0,\n\t.xid2_sender_id\t=\t0,\n\t.xid2_flag2\t=\t0,\n\t.xid2_option\t=\tXID2_0,\n\t.xid2_resv3\t=\t\"\\x00\",\n\t.xid2_resv4\t=\t0,\n\t.xid2_dlc_type\t=\tXID2_READ_SIDE,\n\t.xid2_resv5\t=\t0,\n\t.xid2_mpc_flag\t=\t0,\n\t.xid2_resv6\t=\t0,\n\t.xid2_buf_len\t=\t(MPC_BUFSIZE_DEFAULT - 35),\n};\n\nstatic const struct th_header thnorm = {\n\t.th_seg\t\t=\t0x00,\n\t.th_ch_flag\t=\tTH_IS_XID,\n\t.th_blk_flag\t=\tTH_DATA_IS_XID,\n\t.th_is_xid\t=\t0x01,\n\t.th_seq_num\t=\t0x00000000,\n};\n\nstatic const struct th_header thdummy = {\n\t.th_seg\t\t=\t0x00,\n\t.th_ch_flag\t=\t0x00,\n\t.th_blk_flag\t=\tTH_DATA_IS_XID,\n\t.th_is_xid\t=\t0x01,\n\t.th_seq_num\t=\t0x00000000,\n};\n\n \n\n \n\nstatic void ctcmpc_unpack_skb(struct channel *ch, struct sk_buff *pskb);\n\n \nstatic void mpc_action_nop(fsm_instance *fsm, int event, void *arg);\nstatic void mpc_action_go_ready(fsm_instance *fsm, int event, void *arg);\nstatic void mpc_action_go_inop(fsm_instance *fi, int event, void *arg);\nstatic void mpc_action_timeout(fsm_instance *fi, int event, void *arg);\nstatic int  mpc_validate_xid(struct mpcg_info *mpcginfo);\nstatic void mpc_action_yside_xid(fsm_instance *fsm, int event, void *arg);\nstatic void mpc_action_doxid0(fsm_instance *fsm, int event, void *arg);\nstatic void mpc_action_doxid7(fsm_instance *fsm, int event, void *arg);\nstatic void mpc_action_xside_xid(fsm_instance *fsm, int event, void *arg);\nstatic void mpc_action_rcvd_xid0(fsm_instance *fsm, int event, void *arg);\nstatic void mpc_action_rcvd_xid7(fsm_instance *fsm, int event, void *arg);\n\n#ifdef DEBUGDATA\n \nvoid ctcmpc_dumpit(char *buf, int len)\n{\n\t__u32\tct, sw, rm, dup;\n\tchar\t*ptr, *rptr;\n\tchar\ttbuf[82], tdup[82];\n\tchar\taddr[22];\n\tchar\tboff[12];\n\tchar\tbhex[82], duphex[82];\n\tchar\tbasc[40];\n\n\tsw  = 0;\n\trptr = ptr = buf;\n\trm  = 16;\n\tduphex[0] = 0x00;\n\tdup = 0;\n\n\tfor (ct = 0; ct < len; ct++, ptr++, rptr++) {\n\t\tif (sw == 0) {\n\t\t\tscnprintf(addr, sizeof(addr), \"%16.16llx\", (__u64)rptr);\n\n\t\t\tscnprintf(boff, sizeof(boff), \"%4.4X\", (__u32)ct);\n\t\t\tbhex[0] = '\\0';\n\t\t\tbasc[0] = '\\0';\n\t\t}\n\t\tif ((sw == 4) || (sw == 12))\n\t\t\tstrcat(bhex, \" \");\n\t\tif (sw == 8)\n\t\t\tstrcat(bhex, \"\t\");\n\n\t\tscnprintf(tbuf, sizeof(tbuf), \"%2.2llX\", (__u64)*ptr);\n\n\t\ttbuf[2] = '\\0';\n\t\tstrcat(bhex, tbuf);\n\t\tif ((0 != isprint(*ptr)) && (*ptr >= 0x20))\n\t\t\tbasc[sw] = *ptr;\n\t\telse\n\t\t\tbasc[sw] = '.';\n\n\t\tbasc[sw+1] = '\\0';\n\t\tsw++;\n\t\trm--;\n\t\tif (sw != 16)\n\t\t\tcontinue;\n\t\tif ((strcmp(duphex, bhex)) != 0) {\n\t\t\tif (dup != 0) {\n\t\t\t\tscnprintf(tdup, sizeof(tdup),\n\t\t\t\t\t  \"Duplicate as above to %s\", addr);\n\t\t\t\tctcm_pr_debug(\"\t\t       --- %s ---\\n\",\n\t\t\t\t\t\ttdup);\n\t\t\t}\n\t\t\tctcm_pr_debug(\"   %s (+%s) : %s  [%s]\\n\",\n\t\t\t\t\taddr, boff, bhex, basc);\n\t\t\tdup = 0;\n\t\t\tstrcpy(duphex, bhex);\n\t\t} else\n\t\t\tdup++;\n\n\t\tsw = 0;\n\t\trm = 16;\n\t}   \n\n\tif (sw != 0) {\n\t\tfor ( ; rm > 0; rm--, sw++) {\n\t\t\tif ((sw == 4) || (sw == 12))\n\t\t\t\tstrcat(bhex, \" \");\n\t\t\tif (sw == 8)\n\t\t\t\tstrcat(bhex, \"\t\");\n\t\t\tstrcat(bhex, \"\t\");\n\t\t\tstrcat(basc, \" \");\n\t\t}\n\t\tif (dup != 0) {\n\t\t\tscnprintf(tdup, sizeof(tdup),\n\t\t\t\t  \"Duplicate as above to %s\", addr);\n\t\t\tctcm_pr_debug(\"\t\t       --- %s ---\\n\", tdup);\n\t\t}\n\t\tctcm_pr_debug(\"   %s (+%s) : %s  [%s]\\n\",\n\t\t\t\t\taddr, boff, bhex, basc);\n\t} else {\n\t\tif (dup >= 1) {\n\t\t\tscnprintf(tdup, sizeof(tdup),\n\t\t\t\t  \"Duplicate as above to %s\", addr);\n\t\t\tctcm_pr_debug(\"\t\t       --- %s ---\\n\", tdup);\n\t\t}\n\t\tif (dup != 0) {\n\t\t\tctcm_pr_debug(\"   %s (+%s) : %s  [%s]\\n\",\n\t\t\t\taddr, boff, bhex, basc);\n\t\t}\n\t}\n\n\treturn;\n\n}    \n#endif\n\n#ifdef DEBUGDATA\n \nvoid ctcmpc_dump_skb(struct sk_buff *skb, int offset)\n{\n\t__u8 *p = skb->data;\n\tstruct th_header *header;\n\tstruct pdu *pheader;\n\tint bl = skb->len;\n\tint i;\n\n\tif (p == NULL)\n\t\treturn;\n\n\tp += offset;\n\theader = (struct th_header *)p;\n\n\tctcm_pr_debug(\"dump:\\n\");\n\tctcm_pr_debug(\"skb len=%d \\n\", skb->len);\n\tif (skb->len > 2) {\n\t\tswitch (header->th_ch_flag) {\n\t\tcase TH_HAS_PDU:\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\tcase TH_IS_XID:\n\t\t\tif ((header->th_blk_flag == TH_DATA_IS_XID) &&\n\t\t\t   (header->th_is_xid == 0x01))\n\t\t\t\tgoto dumpth;\n\t\tcase TH_SWEEP_REQ:\n\t\t\t\tgoto dumpth;\n\t\tcase TH_SWEEP_RESP:\n\t\t\t\tgoto dumpth;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tpheader = (struct pdu *)p;\n\t\tctcm_pr_debug(\"pdu->offset: %d hex: %04x\\n\",\n\t\t\t       pheader->pdu_offset, pheader->pdu_offset);\n\t\tctcm_pr_debug(\"pdu->flag  : %02x\\n\", pheader->pdu_flag);\n\t\tctcm_pr_debug(\"pdu->proto : %02x\\n\", pheader->pdu_proto);\n\t\tctcm_pr_debug(\"pdu->seq   : %02x\\n\", pheader->pdu_seq);\n\t\t\t\t\tgoto dumpdata;\n\ndumpth:\n\t\tctcm_pr_debug(\"th->seg     : %02x\\n\", header->th_seg);\n\t\tctcm_pr_debug(\"th->ch      : %02x\\n\", header->th_ch_flag);\n\t\tctcm_pr_debug(\"th->blk_flag: %02x\\n\", header->th_blk_flag);\n\t\tctcm_pr_debug(\"th->type    : %s\\n\",\n\t\t\t       (header->th_is_xid) ? \"DATA\" : \"XID\");\n\t\tctcm_pr_debug(\"th->seqnum  : %04x\\n\", header->th_seq_num);\n\n\t}\ndumpdata:\n\tif (bl > 32)\n\t\tbl = 32;\n\tctcm_pr_debug(\"data: \");\n\tfor (i = 0; i < bl; i++)\n\t\tctcm_pr_debug(\"%02x%s\", *p++, (i % 16) ? \" \" : \"\\n\");\n\tctcm_pr_debug(\"\\n\");\n}\n#endif\n\nstatic struct net_device *ctcmpc_get_dev(int port_num)\n{\n\tchar device[20];\n\tstruct net_device *dev;\n\tstruct ctcm_priv *priv;\n\n\tscnprintf(device, sizeof(device), \"%s%i\", MPC_DEVICE_NAME, port_num);\n\n\tdev = __dev_get_by_name(&init_net, device);\n\n\tif (dev == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s: Device not found by name: %s\",\n\t\t\t\t\tCTCM_FUNTAIL, device);\n\t\treturn NULL;\n\t}\n\tpriv = dev->ml_priv;\n\tif (priv == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): dev->ml_priv is NULL\",\n\t\t\t\t\tCTCM_FUNTAIL, device);\n\t\treturn NULL;\n\t}\n\tif (priv->mpcg == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): priv->mpcg is NULL\",\n\t\t\t\t\tCTCM_FUNTAIL, device);\n\t\treturn NULL;\n\t}\n\treturn dev;\n}\n\n \nint ctc_mpc_alloc_channel(int port_num, void (*callback)(int, int))\n{\n\tstruct net_device *dev;\n\tstruct mpc_group *grp;\n\tstruct ctcm_priv *priv;\n\n\tdev = ctcmpc_get_dev(port_num);\n\tif (dev == NULL)\n\t\treturn 1;\n\tpriv = dev->ml_priv;\n\tgrp = priv->mpcg;\n\n\tgrp->allochanfunc = callback;\n\tgrp->port_num = port_num;\n\tgrp->port_persist = 1;\n\n\tCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_INFO,\n\t\t\t\"%s(%s): state=%s\",\n\t\t\tCTCM_FUNTAIL, dev->name, fsm_getstate_str(grp->fsm));\n\n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_INOP:\n\t\t \n\t\tgrp->alloc_called = 1;\n\t\tbreak;\n\tcase MPCG_STATE_RESET:\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (callback)\n\t\t\tgrp->send_qllc_disc = 1;\n\t\tfallthrough;\n\tcase MPCG_STATE_XID0IOWAIT:\n\t\tfsm_deltimer(&grp->timer);\n\t\tgrp->outstanding_xid2 = 0;\n\t\tgrp->outstanding_xid7 = 0;\n\t\tgrp->outstanding_xid7_p2 = 0;\n\t\tgrp->saved_xid2 = NULL;\n\t\tif (callback)\n\t\t\tctcm_open(dev);\n\t\tfsm_event(priv->fsm, DEV_EVENT_START, dev);\n\t\tbreak;\n\tcase MPCG_STATE_READY:\n\t\t \n\t\t \n\t\t \n\t\tgrp->allocchan_callback_retries++;\n\t\tif (grp->allocchan_callback_retries < 4) {\n\t\t\tif (grp->allochanfunc)\n\t\t\t\tgrp->allochanfunc(grp->port_num,\n\t\t\t\t\t\t  grp->group_max_buflen);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\t\tgrp->allocchan_callback_retries = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ctc_mpc_alloc_channel);\n\n \nvoid ctc_mpc_establish_connectivity(int port_num,\n\t\t\t\tvoid (*callback)(int, int, int))\n{\n\tstruct net_device *dev;\n\tstruct mpc_group *grp;\n\tstruct ctcm_priv *priv;\n\tstruct channel *rch, *wch;\n\n\tdev = ctcmpc_get_dev(port_num);\n\tif (dev == NULL)\n\t\treturn;\n\tpriv = dev->ml_priv;\n\tgrp = priv->mpcg;\n\trch = priv->channel[CTCM_READ];\n\twch = priv->channel[CTCM_WRITE];\n\n\tCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_INFO,\n\t\t\t\"%s(%s): state=%s\",\n\t\t\tCTCM_FUNTAIL, dev->name, fsm_getstate_str(grp->fsm));\n\n\tgrp->estconnfunc = callback;\n\tgrp->port_num = port_num;\n\n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_READY:\n\t\t \n\t\t \n\t\t \n\t\tfsm_deltimer(&grp->timer);\n\t\tgrp->estconn_callback_retries++;\n\t\tif (grp->estconn_callback_retries < 4) {\n\t\t\tif (grp->estconnfunc) {\n\t\t\t\tgrp->estconnfunc(grp->port_num, 0,\n\t\t\t\t\t\tgrp->group_max_buflen);\n\t\t\t\tgrp->estconnfunc = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\t\tgrp->estconn_callback_retries = 0;\n\t\t}\n\t\tbreak;\n\tcase MPCG_STATE_INOP:\n\tcase MPCG_STATE_RESET:\n\t\t \n\t\t \n\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): REJECTED - inactive channels\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\tif (grp->estconnfunc) {\n\t\t\tgrp->estconnfunc(grp->port_num, -1, 0);\n\t\t\tgrp->estconnfunc = NULL;\n\t\t}\n\t\tbreak;\n\tcase MPCG_STATE_XID2INITW:\n\t\t \n\t\t \n\t\t \n\n\t\tif ((fsm_getstate(rch->fsm) > CH_XID0_PENDING) ||\n\t\t\t(fsm_getstate(wch->fsm) > CH_XID0_PENDING)) {\n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): ABORT - PASSIVE XID\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\t\tbreak;\n\t\t}\n\t\tgrp->send_qllc_disc = 1;\n\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID0IOWAIT);\n\t\tfsm_deltimer(&grp->timer);\n\t\tfsm_addtimer(&grp->timer, MPC_XID_TIMEOUT_VALUE,\n\t\t\t\t\t\tMPCG_EVENT_TIMER, dev);\n\t\tgrp->outstanding_xid7 = 0;\n\t\tgrp->outstanding_xid7_p2 = 0;\n\t\tgrp->saved_xid2 = NULL;\n\t\tif ((rch->in_mpcgroup) &&\n\t\t\t\t(fsm_getstate(rch->fsm) == CH_XID0_PENDING))\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_XID0DO, rch);\n\t\telse {\n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): RX-%s not ready for ACTIVE XID0\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name, rch->id);\n\t\t\tif (grp->estconnfunc) {\n\t\t\t\tgrp->estconnfunc(grp->port_num, -1, 0);\n\t\t\t\tgrp->estconnfunc = NULL;\n\t\t\t}\n\t\t\tfsm_deltimer(&grp->timer);\n\t\t\tgoto done;\n\t\t}\n\t\tif ((wch->in_mpcgroup) &&\n\t\t\t\t(fsm_getstate(wch->fsm) == CH_XID0_PENDING))\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_XID0DO, wch);\n\t\telse {\n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): WX-%s not ready for ACTIVE XID0\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name, wch->id);\n\t\t\tif (grp->estconnfunc) {\n\t\t\t\tgrp->estconnfunc(grp->port_num, -1, 0);\n\t\t\t\tgrp->estconnfunc = NULL;\n\t\t\t}\n\t\t\tfsm_deltimer(&grp->timer);\n\t\t\tgoto done;\n\t\t\t}\n\t\tbreak;\n\tcase MPCG_STATE_XID0IOWAIT:\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\ndone:\n\tCTCM_PR_DEBUG(\"Exit %s()\\n\", __func__);\n\treturn;\n}\nEXPORT_SYMBOL(ctc_mpc_establish_connectivity);\n\n \nvoid ctc_mpc_dealloc_ch(int port_num)\n{\n\tstruct net_device *dev;\n\tstruct ctcm_priv *priv;\n\tstruct mpc_group *grp;\n\n\tdev = ctcmpc_get_dev(port_num);\n\tif (dev == NULL)\n\t\treturn;\n\tpriv = dev->ml_priv;\n\tgrp = priv->mpcg;\n\n\tCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_DEBUG,\n\t\t\t\"%s: %s: refcount = %d\\n\",\n\t\t\tCTCM_FUNTAIL, dev->name, netdev_refcnt_read(dev));\n\n\tfsm_deltimer(&priv->restart_timer);\n\tgrp->channels_terminating = 0;\n\tfsm_deltimer(&grp->timer);\n\tgrp->allochanfunc = NULL;\n\tgrp->estconnfunc = NULL;\n\tgrp->port_persist = 0;\n\tgrp->send_qllc_disc = 0;\n\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\n\tctcm_close(dev);\n\treturn;\n}\nEXPORT_SYMBOL(ctc_mpc_dealloc_ch);\n\n \nvoid ctc_mpc_flow_control(int port_num, int flowc)\n{\n\tstruct ctcm_priv *priv;\n\tstruct mpc_group *grp;\n\tstruct net_device *dev;\n\tstruct channel *rch;\n\tint mpcg_state;\n\n\tdev = ctcmpc_get_dev(port_num);\n\tif (dev == NULL)\n\t\treturn;\n\tpriv = dev->ml_priv;\n\tgrp = priv->mpcg;\n\n\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\n\t\t\t\"%s: %s: flowc = %d\",\n\t\t\t\tCTCM_FUNTAIL, dev->name, flowc);\n\n\trch = priv->channel[CTCM_READ];\n\n\tmpcg_state = fsm_getstate(grp->fsm);\n\tswitch (flowc) {\n\tcase 1:\n\t\tif (mpcg_state == MPCG_STATE_FLOWC)\n\t\t\tbreak;\n\t\tif (mpcg_state == MPCG_STATE_READY) {\n\t\t\tif (grp->flow_off_called == 1)\n\t\t\t\tgrp->flow_off_called = 0;\n\t\t\telse\n\t\t\t\tfsm_newstate(grp->fsm, MPCG_STATE_FLOWC);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tif (mpcg_state == MPCG_STATE_FLOWC) {\n\t\t\tfsm_newstate(grp->fsm, MPCG_STATE_READY);\n\t\t\t \n\t\t\t \n\t\t\ttasklet_schedule(&rch->ch_tasklet);\n\t\t}\n\t\t \n\t\tif (mpcg_state == MPCG_STATE_READY) {\n\t\t\tgrp->flow_off_called = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n}\nEXPORT_SYMBOL(ctc_mpc_flow_control);\n\nstatic int mpc_send_qllc_discontact(struct net_device *);\n\n \nstatic void mpc_rcvd_sweep_resp(struct mpcg_info *mpcginfo)\n{\n\tstruct channel\t  *rch = mpcginfo->ch;\n\tstruct net_device *dev = rch->netdev;\n\tstruct ctcm_priv   *priv = dev->ml_priv;\n\tstruct mpc_group  *grp = priv->mpcg;\n\tstruct channel\t  *ch = priv->channel[CTCM_WRITE];\n\n\tCTCM_PR_DEBUG(\"%s: ch=0x%p id=%s\\n\", __func__, ch, ch->id);\n\tCTCM_D3_DUMP((char *)mpcginfo->sweep, TH_SWEEP_LENGTH);\n\n\tgrp->sweep_rsp_pend_num--;\n\n\tif ((grp->sweep_req_pend_num == 0) &&\n\t\t\t(grp->sweep_rsp_pend_num == 0)) {\n\t\tfsm_deltimer(&ch->sweep_timer);\n\t\tgrp->in_sweep = 0;\n\t\trch->th_seq_num = 0x00;\n\t\tch->th_seq_num = 0x00;\n\t\tctcm_clear_busy_do(dev);\n\t}\n\n\treturn;\n\n}\n\n \nstatic void ctcmpc_send_sweep_resp(struct channel *rch)\n{\n\tstruct net_device *dev = rch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct mpc_group *grp = priv->mpcg;\n\tstruct th_sweep *header;\n\tstruct sk_buff *sweep_skb;\n\tstruct channel *ch  = priv->channel[CTCM_WRITE];\n\n\tCTCM_PR_DEBUG(\"%s: ch=0x%p id=%s\\n\", __func__, rch, rch->id);\n\n\tsweep_skb = __dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC | GFP_DMA);\n\tif (sweep_skb == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): sweep_skb allocation ERROR\\n\",\n\t\t\tCTCM_FUNTAIL, rch->id);\n\t\tgoto done;\n\t}\n\n\theader = skb_put_zero(sweep_skb, TH_SWEEP_LENGTH);\n\theader->th.th_ch_flag\t= TH_SWEEP_RESP;\n\theader->sw.th_last_seq\t= ch->th_seq_num;\n\n\tnetif_trans_update(dev);\n\tskb_queue_tail(&ch->sweep_queue, sweep_skb);\n\n\tfsm_addtimer(&ch->sweep_timer, 100, CTC_EVENT_RSWEEP_TIMER, ch);\n\n\treturn;\n\ndone:\n\tgrp->in_sweep = 0;\n\tctcm_clear_busy_do(dev);\n\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\n\treturn;\n}\n\n \nstatic void mpc_rcvd_sweep_req(struct mpcg_info *mpcginfo)\n{\n\tstruct channel\t  *rch     = mpcginfo->ch;\n\tstruct net_device *dev     = rch->netdev;\n\tstruct ctcm_priv  *priv = dev->ml_priv;\n\tstruct mpc_group  *grp  = priv->mpcg;\n\tstruct channel\t  *ch\t   = priv->channel[CTCM_WRITE];\n\n\tif (do_debug)\n\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\n\t\t\t\" %s(): ch=0x%p id=%s\\n\", __func__, ch, ch->id);\n\n\tif (grp->in_sweep == 0) {\n\t\tgrp->in_sweep = 1;\n\t\tctcm_test_and_set_busy(dev);\n\t\tgrp->sweep_req_pend_num = grp->active_channels[CTCM_READ];\n\t\tgrp->sweep_rsp_pend_num = grp->active_channels[CTCM_READ];\n\t}\n\n\tCTCM_D3_DUMP((char *)mpcginfo->sweep, TH_SWEEP_LENGTH);\n\n\tgrp->sweep_req_pend_num--;\n\tctcmpc_send_sweep_resp(ch);\n\tkfree(mpcginfo);\n\treturn;\n}\n\n \nstatic const char *mpcg_event_names[] = {\n\t[MPCG_EVENT_INOP]\t= \"INOP Condition\",\n\t[MPCG_EVENT_DISCONC]\t= \"Discontact Received\",\n\t[MPCG_EVENT_XID0DO]\t= \"Channel Active - Start XID\",\n\t[MPCG_EVENT_XID2]\t= \"XID2 Received\",\n\t[MPCG_EVENT_XID2DONE]\t= \"XID0 Complete\",\n\t[MPCG_EVENT_XID7DONE]\t= \"XID7 Complete\",\n\t[MPCG_EVENT_TIMER]\t= \"XID Setup Timer\",\n\t[MPCG_EVENT_DOIO]\t= \"XID DoIO\",\n};\n\nstatic const char *mpcg_state_names[] = {\n\t[MPCG_STATE_RESET]\t= \"Reset\",\n\t[MPCG_STATE_INOP]\t= \"INOP\",\n\t[MPCG_STATE_XID2INITW]\t= \"Passive XID- XID0 Pending Start\",\n\t[MPCG_STATE_XID2INITX]\t= \"Passive XID- XID0 Pending Complete\",\n\t[MPCG_STATE_XID7INITW]\t= \"Passive XID- XID7 Pending P1 Start\",\n\t[MPCG_STATE_XID7INITX]\t= \"Passive XID- XID7 Pending P2 Complete\",\n\t[MPCG_STATE_XID0IOWAIT]\t= \"Active  XID- XID0 Pending Start\",\n\t[MPCG_STATE_XID0IOWAIX]\t= \"Active  XID- XID0 Pending Complete\",\n\t[MPCG_STATE_XID7INITI]\t= \"Active  XID- XID7 Pending Start\",\n\t[MPCG_STATE_XID7INITZ]\t= \"Active  XID- XID7 Pending Complete \",\n\t[MPCG_STATE_XID7INITF]\t= \"XID        - XID7 Complete \",\n\t[MPCG_STATE_FLOWC]\t= \"FLOW CONTROL ON\",\n\t[MPCG_STATE_READY]\t= \"READY\",\n};\n\n \nstatic const fsm_node mpcg_fsm[] = {\n\t{ MPCG_STATE_RESET,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_INOP,\tMPCG_EVENT_INOP,\tmpc_action_nop        },\n\t{ MPCG_STATE_FLOWC,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\n\t{ MPCG_STATE_READY,\tMPCG_EVENT_DISCONC,\tmpc_action_discontact },\n\t{ MPCG_STATE_READY,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\n\t{ MPCG_STATE_XID2INITW,\tMPCG_EVENT_XID0DO,\tmpc_action_doxid0     },\n\t{ MPCG_STATE_XID2INITW,\tMPCG_EVENT_XID2,\tmpc_action_rcvd_xid0  },\n\t{ MPCG_STATE_XID2INITW,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID2INITW,\tMPCG_EVENT_TIMER,\tmpc_action_timeout    },\n\t{ MPCG_STATE_XID2INITW,\tMPCG_EVENT_DOIO,\tmpc_action_yside_xid  },\n\n\t{ MPCG_STATE_XID2INITX,\tMPCG_EVENT_XID0DO,\tmpc_action_doxid0     },\n\t{ MPCG_STATE_XID2INITX,\tMPCG_EVENT_XID2,\tmpc_action_rcvd_xid0  },\n\t{ MPCG_STATE_XID2INITX,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID2INITX,\tMPCG_EVENT_TIMER,\tmpc_action_timeout    },\n\t{ MPCG_STATE_XID2INITX,\tMPCG_EVENT_DOIO,\tmpc_action_yside_xid  },\n\n\t{ MPCG_STATE_XID7INITW,\tMPCG_EVENT_XID2DONE,\tmpc_action_doxid7     },\n\t{ MPCG_STATE_XID7INITW,\tMPCG_EVENT_DISCONC,\tmpc_action_discontact },\n\t{ MPCG_STATE_XID7INITW,\tMPCG_EVENT_XID2,\tmpc_action_rcvd_xid7  },\n\t{ MPCG_STATE_XID7INITW,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID7INITW,\tMPCG_EVENT_TIMER,\tmpc_action_timeout    },\n\t{ MPCG_STATE_XID7INITW,\tMPCG_EVENT_XID7DONE,\tmpc_action_doxid7     },\n\t{ MPCG_STATE_XID7INITW,\tMPCG_EVENT_DOIO,\tmpc_action_yside_xid  },\n\n\t{ MPCG_STATE_XID7INITX,\tMPCG_EVENT_DISCONC,\tmpc_action_discontact },\n\t{ MPCG_STATE_XID7INITX,\tMPCG_EVENT_XID2,\tmpc_action_rcvd_xid7  },\n\t{ MPCG_STATE_XID7INITX,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID7INITX,\tMPCG_EVENT_XID7DONE,\tmpc_action_doxid7     },\n\t{ MPCG_STATE_XID7INITX,\tMPCG_EVENT_TIMER,\tmpc_action_timeout    },\n\t{ MPCG_STATE_XID7INITX,\tMPCG_EVENT_DOIO,\tmpc_action_yside_xid  },\n\n\t{ MPCG_STATE_XID0IOWAIT, MPCG_EVENT_XID0DO,\tmpc_action_doxid0     },\n\t{ MPCG_STATE_XID0IOWAIT, MPCG_EVENT_DISCONC,\tmpc_action_discontact },\n\t{ MPCG_STATE_XID0IOWAIT, MPCG_EVENT_XID2,\tmpc_action_rcvd_xid0  },\n\t{ MPCG_STATE_XID0IOWAIT, MPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID0IOWAIT, MPCG_EVENT_TIMER,\tmpc_action_timeout    },\n\t{ MPCG_STATE_XID0IOWAIT, MPCG_EVENT_DOIO,\tmpc_action_xside_xid  },\n\n\t{ MPCG_STATE_XID0IOWAIX, MPCG_EVENT_XID0DO,\tmpc_action_doxid0     },\n\t{ MPCG_STATE_XID0IOWAIX, MPCG_EVENT_DISCONC,\tmpc_action_discontact },\n\t{ MPCG_STATE_XID0IOWAIX, MPCG_EVENT_XID2,\tmpc_action_rcvd_xid0  },\n\t{ MPCG_STATE_XID0IOWAIX, MPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID0IOWAIX, MPCG_EVENT_TIMER,\tmpc_action_timeout    },\n\t{ MPCG_STATE_XID0IOWAIX, MPCG_EVENT_DOIO,\tmpc_action_xside_xid  },\n\n\t{ MPCG_STATE_XID7INITI,\tMPCG_EVENT_XID2DONE,\tmpc_action_doxid7     },\n\t{ MPCG_STATE_XID7INITI,\tMPCG_EVENT_XID2,\tmpc_action_rcvd_xid7  },\n\t{ MPCG_STATE_XID7INITI,\tMPCG_EVENT_DISCONC,\tmpc_action_discontact },\n\t{ MPCG_STATE_XID7INITI,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID7INITI,\tMPCG_EVENT_TIMER,\tmpc_action_timeout    },\n\t{ MPCG_STATE_XID7INITI,\tMPCG_EVENT_XID7DONE,\tmpc_action_doxid7     },\n\t{ MPCG_STATE_XID7INITI,\tMPCG_EVENT_DOIO,\tmpc_action_xside_xid  },\n\n\t{ MPCG_STATE_XID7INITZ,\tMPCG_EVENT_XID2,\tmpc_action_rcvd_xid7  },\n\t{ MPCG_STATE_XID7INITZ,\tMPCG_EVENT_XID7DONE,\tmpc_action_doxid7     },\n\t{ MPCG_STATE_XID7INITZ,\tMPCG_EVENT_DISCONC,\tmpc_action_discontact },\n\t{ MPCG_STATE_XID7INITZ,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID7INITZ,\tMPCG_EVENT_TIMER,\tmpc_action_timeout    },\n\t{ MPCG_STATE_XID7INITZ,\tMPCG_EVENT_DOIO,\tmpc_action_xside_xid  },\n\n\t{ MPCG_STATE_XID7INITF,\tMPCG_EVENT_INOP,\tmpc_action_go_inop    },\n\t{ MPCG_STATE_XID7INITF,\tMPCG_EVENT_XID7DONE,\tmpc_action_go_ready   },\n};\n\nstatic int mpcg_fsm_len = ARRAY_SIZE(mpcg_fsm);\n\n \nstatic void mpc_action_go_ready(fsm_instance *fsm, int event, void *arg)\n{\n\tstruct net_device *dev = arg;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct mpc_group *grp = priv->mpcg;\n\n\tif (grp == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): No MPC group\",\n\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\treturn;\n\t}\n\n\tfsm_deltimer(&grp->timer);\n\n\tif (grp->saved_xid2->xid2_flag2 == 0x40) {\n\t\tpriv->xid->xid2_flag2 = 0x00;\n\t\tif (grp->estconnfunc) {\n\t\t\tgrp->estconnfunc(grp->port_num, 1,\n\t\t\t\t\tgrp->group_max_buflen);\n\t\t\tgrp->estconnfunc = NULL;\n\t\t} else if (grp->allochanfunc)\n\t\t\tgrp->send_qllc_disc = 1;\n\n\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): fails\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\treturn;\n\t}\n\n\tgrp->port_persist = 1;\n\tgrp->out_of_sequence = 0;\n\tgrp->estconn_called = 0;\n\n\ttasklet_hi_schedule(&grp->mpc_tasklet2);\n\n\treturn;\n}\n\n \nvoid mpc_group_ready(unsigned long adev)\n{\n\tstruct net_device *dev = (struct net_device *)adev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct mpc_group *grp = priv->mpcg;\n\tstruct channel *ch = NULL;\n\n\tif (grp == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): No MPC group\",\n\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\treturn;\n\t}\n\n\tCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_NOTICE,\n\t\t\"%s: %s: GROUP TRANSITIONED TO READY, maxbuf = %d\\n\",\n\t\t\tCTCM_FUNTAIL, dev->name, grp->group_max_buflen);\n\n\tfsm_newstate(grp->fsm, MPCG_STATE_READY);\n\n\t \n\tch = priv->channel[CTCM_READ];\n\tch->pdu_seq = 0;\n\tCTCM_PR_DBGDATA(\"ctcmpc: %s() ToDCM_pdu_seq= %08x\\n\" ,\n\t\t\t__func__, ch->pdu_seq);\n\n\tctcmpc_chx_rxidle(ch->fsm, CTC_EVENT_START, ch);\n\t \n\tch = priv->channel[CTCM_WRITE];\n\tif (ch->collect_len > 0) {\n\t\tspin_lock(&ch->collect_lock);\n\t\tctcm_purge_skb_queue(&ch->collect_queue);\n\t\tch->collect_len = 0;\n\t\tspin_unlock(&ch->collect_lock);\n\t}\n\tctcm_chx_txidle(ch->fsm, CTC_EVENT_START, ch);\n\tctcm_clear_busy(dev);\n\n\tif (grp->estconnfunc) {\n\t\tgrp->estconnfunc(grp->port_num, 0,\n\t\t\t\t    grp->group_max_buflen);\n\t\tgrp->estconnfunc = NULL;\n\t} else if (grp->allochanfunc) {\n\t\tgrp->allochanfunc(grp->port_num, grp->group_max_buflen);\n\t}\n\n\tgrp->send_qllc_disc = 1;\n\tgrp->changed_side = 0;\n\n\treturn;\n\n}\n\n \nvoid mpc_channel_action(struct channel *ch, int direction, int action)\n{\n\tstruct net_device  *dev  = ch->netdev;\n\tstruct ctcm_priv   *priv = dev->ml_priv;\n\tstruct mpc_group   *grp  = priv->mpcg;\n\n\tif (grp == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): No MPC group\",\n\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\treturn;\n\t}\n\n\tCTCM_PR_DEBUG(\"enter %s: ch=0x%p id=%s\\n\", __func__, ch, ch->id);\n\n\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\n\t\t\"%s: %i / Grp:%s total_channels=%i, active_channels: \"\n\t\t\"read=%i, write=%i\\n\", __func__, action,\n\t\tfsm_getstate_str(grp->fsm), grp->num_channel_paths,\n\t\tgrp->active_channels[CTCM_READ],\n\t\tgrp->active_channels[CTCM_WRITE]);\n\n\tif ((action == MPC_CHANNEL_ADD) && (ch->in_mpcgroup == 0)) {\n\t\tgrp->num_channel_paths++;\n\t\tgrp->active_channels[direction]++;\n\t\tgrp->outstanding_xid2++;\n\t\tch->in_mpcgroup = 1;\n\n\t\tif (ch->xid_skb != NULL)\n\t\t\tdev_kfree_skb_any(ch->xid_skb);\n\n\t\tch->xid_skb = __dev_alloc_skb(MPC_BUFSIZE_DEFAULT,\n\t\t\t\t\tGFP_ATOMIC | GFP_DMA);\n\t\tif (ch->xid_skb == NULL) {\n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): Couldn't alloc ch xid_skb\\n\",\n\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\t\treturn;\n\t\t}\n\t\tch->xid_skb_data = ch->xid_skb->data;\n\t\tch->xid_th = (struct th_header *)ch->xid_skb->data;\n\t\tskb_put(ch->xid_skb, TH_HEADER_LENGTH);\n\t\tch->xid = (struct xid2 *)skb_tail_pointer(ch->xid_skb);\n\t\tskb_put(ch->xid_skb, XID2_LENGTH);\n\t\tch->xid_id = skb_tail_pointer(ch->xid_skb);\n\t\tch->xid_skb->data = ch->xid_skb_data;\n\t\tskb_reset_tail_pointer(ch->xid_skb);\n\t\tch->xid_skb->len = 0;\n\n\t\tskb_put_data(ch->xid_skb, grp->xid_skb->data,\n\t\t\t     grp->xid_skb->len);\n\n\t\tch->xid->xid2_dlc_type =\n\t\t\t((CHANNEL_DIRECTION(ch->flags) == CTCM_READ)\n\t\t\t\t? XID2_READ_SIDE : XID2_WRITE_SIDE);\n\n\t\tif (CHANNEL_DIRECTION(ch->flags) == CTCM_WRITE)\n\t\t\tch->xid->xid2_buf_len = 0x00;\n\n\t\tch->xid_skb->data = ch->xid_skb_data;\n\t\tskb_reset_tail_pointer(ch->xid_skb);\n\t\tch->xid_skb->len = 0;\n\n\t\tfsm_newstate(ch->fsm, CH_XID0_PENDING);\n\n\t\tif ((grp->active_channels[CTCM_READ] > 0) &&\n\t\t    (grp->active_channels[CTCM_WRITE] > 0) &&\n\t\t\t(fsm_getstate(grp->fsm) < MPCG_STATE_XID2INITW)) {\n\t\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID2INITW);\n\t\t\tCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_NOTICE,\n\t\t\t\t\"%s: %s: MPC GROUP CHANNELS ACTIVE\\n\",\n\t\t\t\t\t\t__func__, dev->name);\n\t\t}\n\t} else if ((action == MPC_CHANNEL_REMOVE) &&\n\t\t\t(ch->in_mpcgroup == 1)) {\n\t\tch->in_mpcgroup = 0;\n\t\tgrp->num_channel_paths--;\n\t\tgrp->active_channels[direction]--;\n\n\t\tif (ch->xid_skb != NULL)\n\t\t\tdev_kfree_skb_any(ch->xid_skb);\n\t\tch->xid_skb = NULL;\n\n\t\tif (grp->channels_terminating)\n\t\t\t\t\tgoto done;\n\n\t\tif (((grp->active_channels[CTCM_READ] == 0) &&\n\t\t\t\t\t(grp->active_channels[CTCM_WRITE] > 0))\n\t\t\t|| ((grp->active_channels[CTCM_WRITE] == 0) &&\n\t\t\t\t\t(grp->active_channels[CTCM_READ] > 0)))\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t}\ndone:\n\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\n\t\t\"exit %s: %i / Grp:%s total_channels=%i, active_channels: \"\n\t\t\"read=%i, write=%i\\n\", __func__, action,\n\t\tfsm_getstate_str(grp->fsm), grp->num_channel_paths,\n\t\tgrp->active_channels[CTCM_READ],\n\t\tgrp->active_channels[CTCM_WRITE]);\n\n\tCTCM_PR_DEBUG(\"exit %s: ch=0x%p id=%s\\n\", __func__, ch, ch->id);\n}\n\n \nstatic void ctcmpc_unpack_skb(struct channel *ch, struct sk_buff *pskb)\n{\n\tstruct net_device *dev\t= ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct mpc_group *grp = priv->mpcg;\n\tstruct pdu *curr_pdu;\n\tstruct mpcg_info *mpcginfo;\n\tstruct th_header *header = NULL;\n\tstruct th_sweep *sweep = NULL;\n\tint pdu_last_seen = 0;\n\t__u32 new_len;\n\tstruct sk_buff *skb;\n\tint skblen;\n\tint sendrc = 0;\n\n\tCTCM_PR_DEBUG(\"ctcmpc enter: %s() %s cp:%i ch:%s\\n\",\n\t\t\t__func__, dev->name, smp_processor_id(), ch->id);\n\n\theader = (struct th_header *)pskb->data;\n\tif ((header->th_seg == 0) &&\n\t\t(header->th_ch_flag == 0) &&\n\t\t(header->th_blk_flag == 0) &&\n\t\t(header->th_seq_num == 0))\n\t\t \tgoto done;\n\n\tCTCM_PR_DBGDATA(\"%s: th_header\\n\", __func__);\n\tCTCM_D3_DUMP((char *)header, TH_HEADER_LENGTH);\n\tCTCM_PR_DBGDATA(\"%s: pskb len: %04x \\n\", __func__, pskb->len);\n\n\tpskb->dev = dev;\n\tpskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb_pull(pskb, TH_HEADER_LENGTH);\n\n\tif (likely(header->th_ch_flag == TH_HAS_PDU)) {\n\t\tCTCM_PR_DBGDATA(\"%s: came into th_has_pdu\\n\", __func__);\n\t\tif ((fsm_getstate(grp->fsm) == MPCG_STATE_FLOWC) ||\n\t\t   ((fsm_getstate(grp->fsm) == MPCG_STATE_READY) &&\n\t\t    (header->th_seq_num != ch->th_seq_num + 1) &&\n\t\t    (ch->th_seq_num != 0))) {\n\t\t\t \n\t\t\tgrp->out_of_sequence += 1;\n\t\t\t__skb_push(pskb, TH_HEADER_LENGTH);\n\t\t\tskb_queue_tail(&ch->io_queue, pskb);\n\t\t\tCTCM_PR_DBGDATA(\"%s: th_seq_num expect:%08x \"\n\t\t\t\t\t\"got:%08x\\n\", __func__,\n\t\t\t\tch->th_seq_num + 1, header->th_seq_num);\n\n\t\t\treturn;\n\t\t}\n\t\tgrp->out_of_sequence = 0;\n\t\tch->th_seq_num = header->th_seq_num;\n\n\t\tCTCM_PR_DBGDATA(\"ctcmpc: %s() FromVTAM_th_seq=%08x\\n\",\n\t\t\t\t\t__func__, ch->th_seq_num);\n\n\t\tif (unlikely(fsm_getstate(grp->fsm) != MPCG_STATE_READY))\n\t\t\t\t\tgoto done;\n\t\twhile ((pskb->len > 0) && !pdu_last_seen) {\n\t\t\tcurr_pdu = (struct pdu *)pskb->data;\n\n\t\t\tCTCM_PR_DBGDATA(\"%s: pdu_header\\n\", __func__);\n\t\t\tCTCM_D3_DUMP((char *)pskb->data, PDU_HEADER_LENGTH);\n\t\t\tCTCM_PR_DBGDATA(\"%s: pskb len: %04x \\n\",\n\t\t\t\t\t\t__func__, pskb->len);\n\n\t\t\tskb_pull(pskb, PDU_HEADER_LENGTH);\n\n\t\t\tif (curr_pdu->pdu_flag & PDU_LAST)\n\t\t\t\tpdu_last_seen = 1;\n\t\t\tif (curr_pdu->pdu_flag & PDU_CNTL)\n\t\t\t\tpskb->protocol = htons(ETH_P_SNAP);\n\t\t\telse\n\t\t\t\tpskb->protocol = htons(ETH_P_SNA_DIX);\n\n\t\t\tif ((pskb->len <= 0) || (pskb->len > ch->max_bufsize)) {\n\t\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\t\"%s(%s): Dropping packet with \"\n\t\t\t\t\t\"illegal siize %d\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name, pskb->len);\n\n\t\t\t\tpriv->stats.rx_dropped++;\n\t\t\t\tpriv->stats.rx_length_errors++;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tskb_reset_mac_header(pskb);\n\t\t\tnew_len = curr_pdu->pdu_offset;\n\t\t\tCTCM_PR_DBGDATA(\"%s: new_len: %04x \\n\",\n\t\t\t\t\t\t__func__, new_len);\n\t\t\tif ((new_len == 0) || (new_len > pskb->len)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\t\"%s(%s): non valid pdu_offset: %04x\",\n\t\t\t\t\t \n\t\t\t\t\tCTCM_FUNTAIL, dev->name, new_len);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tskb = __dev_alloc_skb(new_len+4, GFP_ATOMIC);\n\n\t\t\tif (!skb) {\n\t\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\t\"%s(%s): MEMORY allocation error\",\n\t\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\t\t\tpriv->stats.rx_dropped++;\n\t\t\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tskb_put_data(skb, pskb->data, new_len);\n\n\t\t\tskb_reset_mac_header(skb);\n\t\t\tskb->dev = pskb->dev;\n\t\t\tskb->protocol = pskb->protocol;\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t*((__u32 *) skb_push(skb, 4)) = ch->pdu_seq;\n\t\t\tch->pdu_seq++;\n\n\t\t\tif (do_debug_data) {\n\t\t\t\tctcm_pr_debug(\"%s: ToDCM_pdu_seq= %08x\\n\",\n\t\t\t\t\t\t__func__, ch->pdu_seq);\n\t\t\t\tctcm_pr_debug(\"%s: skb:%0lx \"\n\t\t\t\t\t\"skb len: %d \\n\", __func__,\n\t\t\t\t\t(unsigned long)skb, skb->len);\n\t\t\t\tctcm_pr_debug(\"%s: up to 32 bytes \"\n\t\t\t\t\t\"of pdu_data sent\\n\", __func__);\n\t\t\t\tctcmpc_dump32((char *)skb->data, skb->len);\n\t\t\t}\n\n\t\t\tskblen = skb->len;\n\t\t\tsendrc = netif_rx(skb);\n\t\t\tpriv->stats.rx_packets++;\n\t\t\tpriv->stats.rx_bytes += skblen;\n\t\t\tskb_pull(pskb, new_len);  \n\t\t}\n\t} else {\n\t\tmpcginfo = kmalloc(sizeof(struct mpcg_info), GFP_ATOMIC);\n\t\tif (mpcginfo == NULL)\n\t\t\t\t\tgoto done;\n\n\t\tmpcginfo->ch = ch;\n\t\tmpcginfo->th = header;\n\t\tmpcginfo->skb = pskb;\n\t\tCTCM_PR_DEBUG(\"%s: Not PDU - may be control pkt\\n\",\n\t\t\t\t\t__func__);\n\t\t \n\t\tsweep = (struct th_sweep *)pskb->data;\n\t\tmpcginfo->sweep = sweep;\n\t\tif (header->th_ch_flag == TH_SWEEP_REQ)\n\t\t\tmpc_rcvd_sweep_req(mpcginfo);\n\t\telse if (header->th_ch_flag == TH_SWEEP_RESP)\n\t\t\tmpc_rcvd_sweep_resp(mpcginfo);\n\t\telse if (header->th_blk_flag == TH_DATA_IS_XID) {\n\t\t\tstruct xid2 *thisxid = (struct xid2 *)pskb->data;\n\t\t\tskb_pull(pskb, XID2_LENGTH);\n\t\t\tmpcginfo->xid = thisxid;\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_XID2, mpcginfo);\n\t\t} else if (header->th_blk_flag == TH_DISCONTACT)\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_DISCONC, mpcginfo);\n\t\telse if (header->th_seq_num != 0) {\n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): control pkt expected\\n\",\n\t\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\t\tpriv->stats.rx_dropped++;\n\t\t\t \n\t\t\tif (do_debug_data)\n\t\t\t\tctcmpc_dump_skb(pskb, -8);\n\t\t}\n\t\tkfree(mpcginfo);\n\t}\ndone:\n\n\tdev_kfree_skb_any(pskb);\n\tif (sendrc == NET_RX_DROP) {\n\t\tdev_warn(&dev->dev,\n\t\t\t\"The network backlog for %s is exceeded, \"\n\t\t\t\"package dropped\\n\", __func__);\n\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t}\n\n\tCTCM_PR_DEBUG(\"exit %s: %s: ch=0x%p id=%s\\n\",\n\t\t\t__func__, dev->name, ch, ch->id);\n}\n\n \nvoid ctcmpc_bh(unsigned long thischan)\n{\n\tstruct channel\t  *ch\t= (struct channel *)thischan;\n\tstruct sk_buff\t  *skb;\n\tstruct net_device *dev\t= ch->netdev;\n\tstruct ctcm_priv  *priv\t= dev->ml_priv;\n\tstruct mpc_group  *grp\t= priv->mpcg;\n\n\tCTCM_PR_DEBUG(\"%s cp:%i enter:  %s() %s\\n\",\n\t       dev->name, smp_processor_id(), __func__, ch->id);\n\t \n\twhile ((fsm_getstate(grp->fsm) != MPCG_STATE_FLOWC) &&\n\t\t\t(skb = skb_dequeue(&ch->io_queue))) {\n\t\tctcmpc_unpack_skb(ch, skb);\n\t\tif (grp->out_of_sequence > 20) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tgrp->out_of_sequence = 0;\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\t\tbreak;\n\t\t}\n\t\tif (skb == skb_peek(&ch->io_queue))\n\t\t\tbreak;\n\t}\n\tCTCM_PR_DEBUG(\"exit %s: %s: ch=0x%p id=%s\\n\",\n\t\t\t__func__, dev->name, ch, ch->id);\n\treturn;\n}\n\n \nstruct mpc_group *ctcmpc_init_mpc_group(struct ctcm_priv *priv)\n{\n\tstruct mpc_group *grp;\n\n\tCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_INFO,\n\t\t\t\"Enter %s(%p)\", CTCM_FUNTAIL, priv);\n\n\tgrp = kzalloc(sizeof(struct mpc_group), GFP_KERNEL);\n\tif (grp == NULL)\n\t\treturn NULL;\n\n\tgrp->fsm = init_fsm(\"mpcg\", mpcg_state_names, mpcg_event_names,\n\t\t\tMPCG_NR_STATES, MPCG_NR_EVENTS, mpcg_fsm,\n\t\t\tmpcg_fsm_len, GFP_KERNEL);\n\tif (grp->fsm == NULL) {\n\t\tkfree(grp);\n\t\treturn NULL;\n\t}\n\n\tfsm_newstate(grp->fsm, MPCG_STATE_RESET);\n\tfsm_settimer(grp->fsm, &grp->timer);\n\n\tgrp->xid_skb =\n\t\t __dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC | GFP_DMA);\n\tif (grp->xid_skb == NULL) {\n\t\tkfree_fsm(grp->fsm);\n\t\tkfree(grp);\n\t\treturn NULL;\n\t}\n\t \n\tgrp->xid_skb_data = grp->xid_skb->data;\n\tgrp->xid_th = (struct th_header *)grp->xid_skb->data;\n\tskb_put_data(grp->xid_skb, &thnorm, TH_HEADER_LENGTH);\n\n\tgrp->xid = (struct xid2 *)skb_tail_pointer(grp->xid_skb);\n\tskb_put_data(grp->xid_skb, &init_xid, XID2_LENGTH);\n\tgrp->xid->xid2_adj_id = jiffies | 0xfff00000;\n\tgrp->xid->xid2_sender_id = jiffies;\n\n\tgrp->xid_id = skb_tail_pointer(grp->xid_skb);\n\tskb_put_data(grp->xid_skb, \"VTAM\", 4);\n\n\tgrp->rcvd_xid_skb =\n\t\t__dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC|GFP_DMA);\n\tif (grp->rcvd_xid_skb == NULL) {\n\t\tkfree_fsm(grp->fsm);\n\t\tdev_kfree_skb(grp->xid_skb);\n\t\tkfree(grp);\n\t\treturn NULL;\n\t}\n\tgrp->rcvd_xid_data = grp->rcvd_xid_skb->data;\n\tgrp->rcvd_xid_th = (struct th_header *)grp->rcvd_xid_skb->data;\n\tskb_put_data(grp->rcvd_xid_skb, &thnorm, TH_HEADER_LENGTH);\n\tgrp->saved_xid2 = NULL;\n\tpriv->xid = grp->xid;\n\tpriv->mpcg = grp;\n\treturn grp;\n}\n\n \n\n \n\n \nstatic void mpc_action_nop(fsm_instance *fi, int event, void *arg)\n{\n}\n\n \nstatic void mpc_action_go_inop(fsm_instance *fi, int event, void *arg)\n{\n\tstruct net_device  *dev = arg;\n\tstruct ctcm_priv    *priv;\n\tstruct mpc_group *grp;\n\tstruct channel *wch;\n\n\tCTCM_PR_DEBUG(\"Enter %s: %s\\n\",\t__func__, dev->name);\n\n\tpriv  = dev->ml_priv;\n\tgrp =  priv->mpcg;\n\tgrp->flow_off_called = 0;\n\tfsm_deltimer(&grp->timer);\n\tif (grp->channels_terminating)\n\t\t\treturn;\n\n\tgrp->channels_terminating = 1;\n\tgrp->saved_state = fsm_getstate(grp->fsm);\n\tfsm_newstate(grp->fsm, MPCG_STATE_INOP);\n\tif (grp->saved_state > MPCG_STATE_XID7INITF)\n\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\n\t\t\t\"%s(%s): MPC GROUP INOPERATIVE\",\n\t\t\t\tCTCM_FUNTAIL, dev->name);\n\tif ((grp->saved_state != MPCG_STATE_RESET) ||\n\t\t \n\t\t(grp->port_persist == 0))\n\t\tfsm_deltimer(&priv->restart_timer);\n\n\twch = priv->channel[CTCM_WRITE];\n\n\tswitch (grp->saved_state) {\n\tcase MPCG_STATE_RESET:\n\tcase MPCG_STATE_INOP:\n\tcase MPCG_STATE_XID2INITW:\n\tcase MPCG_STATE_XID0IOWAIT:\n\tcase MPCG_STATE_XID2INITX:\n\tcase MPCG_STATE_XID7INITW:\n\tcase MPCG_STATE_XID7INITX:\n\tcase MPCG_STATE_XID0IOWAIX:\n\tcase MPCG_STATE_XID7INITI:\n\tcase MPCG_STATE_XID7INITZ:\n\tcase MPCG_STATE_XID7INITF:\n\t\tbreak;\n\tcase MPCG_STATE_FLOWC:\n\tcase MPCG_STATE_READY:\n\tdefault:\n\t\ttasklet_hi_schedule(&wch->ch_disc_tasklet);\n\t}\n\n\tgrp->xid2_tgnum = 0;\n\tgrp->group_max_buflen = 0;   \n\tgrp->outstanding_xid2 = 0;\n\tgrp->outstanding_xid7 = 0;\n\tgrp->outstanding_xid7_p2 = 0;\n\tgrp->saved_xid2 = NULL;\n\tgrp->xidnogood = 0;\n\tgrp->changed_side = 0;\n\n\tgrp->rcvd_xid_skb->data = grp->rcvd_xid_data;\n\tskb_reset_tail_pointer(grp->rcvd_xid_skb);\n\tgrp->rcvd_xid_skb->len = 0;\n\tgrp->rcvd_xid_th = (struct th_header *)grp->rcvd_xid_skb->data;\n\tskb_put_data(grp->rcvd_xid_skb, &thnorm, TH_HEADER_LENGTH);\n\n\tif (grp->send_qllc_disc == 1) {\n\t\tgrp->send_qllc_disc = 0;\n\t\tmpc_send_qllc_discontact(dev);\n\t}\n\n\t \n\t \n\t \n\t \n\t \n\tif ((grp->port_persist == 1) || (grp->alloc_called)) {\n\t\tgrp->alloc_called = 0;\n\t\tfsm_deltimer(&priv->restart_timer);\n\t\tfsm_addtimer(&priv->restart_timer, 500, DEV_EVENT_RESTART, dev);\n\t\tfsm_newstate(grp->fsm, MPCG_STATE_RESET);\n\t\tif (grp->saved_state > MPCG_STATE_XID7INITF)\n\t\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ALWAYS,\n\t\t\t\t\"%s(%s): MPC GROUP RECOVERY SCHEDULED\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t} else {\n\t\tfsm_deltimer(&priv->restart_timer);\n\t\tfsm_addtimer(&priv->restart_timer, 500, DEV_EVENT_STOP, dev);\n\t\tfsm_newstate(grp->fsm, MPCG_STATE_RESET);\n\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ALWAYS,\n\t\t\t\"%s(%s): NO MPC GROUP RECOVERY ATTEMPTED\",\n\t\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t}\n}\n\n \nstatic void mpc_action_timeout(fsm_instance *fi, int event, void *arg)\n{\n\tstruct net_device *dev = arg;\n\tstruct ctcm_priv *priv;\n\tstruct mpc_group *grp;\n\tstruct channel *wch;\n\tstruct channel *rch;\n\n\tpriv = dev->ml_priv;\n\tgrp = priv->mpcg;\n\twch = priv->channel[CTCM_WRITE];\n\trch = priv->channel[CTCM_READ];\n\n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_XID2INITW:\n\t\t \n\t\t \n\t\t \n\t\tif ((fsm_getstate(rch->fsm) == CH_XID0_PENDING) &&\n\t\t   (fsm_getstate(wch->fsm) == CH_XID0_PENDING))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t}\n\n\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\n\t\t\t\"%s: dev=%s exit\",\n\t\t\tCTCM_FUNTAIL, dev->name);\n\treturn;\n}\n\n \nvoid mpc_action_discontact(fsm_instance *fi, int event, void *arg)\n{\n\tstruct mpcg_info   *mpcginfo   = arg;\n\tstruct channel\t   *ch\t       = mpcginfo->ch;\n\tstruct net_device  *dev;\n\tstruct ctcm_priv   *priv;\n\tstruct mpc_group   *grp;\n\n\tif (ch) {\n\t\tdev = ch->netdev;\n\t\tif (dev) {\n\t\t\tpriv = dev->ml_priv;\n\t\t\tif (priv) {\n\t\t\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\n\t\t\t\t\t\"%s: %s: %s\\n\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name, ch->id);\n\t\t\t\tgrp = priv->mpcg;\n\t\t\t\tgrp->send_qllc_disc = 1;\n\t\t\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\n \nvoid mpc_action_send_discontact(unsigned long thischan)\n{\n\tint rc;\n\tstruct channel\t*ch = (struct channel *)thischan;\n\tunsigned long\tsaveflags = 0;\n\n\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\trc = ccw_device_start(ch->cdev, &ch->ccw[15], 0, 0xff, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\n\n\tif (rc != 0) {\n\t\tctcm_ccw_check_rc(ch, rc, (char *)__func__);\n\t}\n\n\treturn;\n}\n\n\n \nstatic int mpc_validate_xid(struct mpcg_info *mpcginfo)\n{\n\tstruct channel\t   *ch\t = mpcginfo->ch;\n\tstruct net_device  *dev  = ch->netdev;\n\tstruct ctcm_priv   *priv = dev->ml_priv;\n\tstruct mpc_group   *grp  = priv->mpcg;\n\tstruct xid2\t   *xid  = mpcginfo->xid;\n\tint\trc\t = 0;\n\t__u64\tour_id   = 0;\n\t__u64   their_id = 0;\n\tint\tlen = TH_HEADER_LENGTH + PDU_HEADER_LENGTH;\n\n\tCTCM_PR_DEBUG(\"Enter %s: xid=%p\\n\", __func__, xid);\n\n\tif (xid == NULL) {\n\t\trc = 1;\n\t\t \n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): xid = NULL\",\n\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\tgoto done;\n\t}\n\n\tCTCM_D3_DUMP((char *)xid, XID2_LENGTH);\n\n\t \n\tif (((CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ? XID2_WRITE_SIDE :\n\t\t\t\tXID2_READ_SIDE) != xid->xid2_dlc_type) {\n\t\trc = 2;\n\t\t \n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): r/w channel pairing mismatch\",\n\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\tgoto done;\n\t}\n\n\tif (xid->xid2_dlc_type == XID2_READ_SIDE) {\n\t\tCTCM_PR_DEBUG(\"%s: grpmaxbuf:%d xid2buflen:%d\\n\", __func__,\n\t\t\t\tgrp->group_max_buflen, xid->xid2_buf_len);\n\n\t\tif (grp->group_max_buflen == 0 || grp->group_max_buflen >\n\t\t\t\t\t\txid->xid2_buf_len - len)\n\t\t\tgrp->group_max_buflen = xid->xid2_buf_len - len;\n\t}\n\n\tif (grp->saved_xid2 == NULL) {\n\t\tgrp->saved_xid2 =\n\t\t\t(struct xid2 *)skb_tail_pointer(grp->rcvd_xid_skb);\n\n\t\tskb_put_data(grp->rcvd_xid_skb, xid, XID2_LENGTH);\n\t\tgrp->rcvd_xid_skb->data = grp->rcvd_xid_data;\n\n\t\tskb_reset_tail_pointer(grp->rcvd_xid_skb);\n\t\tgrp->rcvd_xid_skb->len = 0;\n\n\t\t \n\t\tour_id = (__u64)priv->xid->xid2_adj_id;\n\t\tour_id = our_id << 32;\n\t\tour_id = our_id + priv->xid->xid2_sender_id;\n\t\ttheir_id = (__u64)xid->xid2_adj_id;\n\t\ttheir_id = their_id << 32;\n\t\ttheir_id = their_id + xid->xid2_sender_id;\n\t\t \n\t\tif (our_id < their_id) {\n\t\t\tgrp->roll = XSIDE;\n\t\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\n\t\t\t\t\"%s(%s): WE HAVE LOW ID - TAKE XSIDE\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\t} else {\n\t\t\tgrp->roll = YSIDE;\n\t\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\n\t\t\t\t\"%s(%s): WE HAVE HIGH ID - TAKE YSIDE\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\t}\n\n\t} else {\n\t\tif (xid->xid2_flag4 != grp->saved_xid2->xid2_flag4) {\n\t\t\trc = 3;\n\t\t\t \n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): xid flag byte4 mismatch\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\t}\n\t\tif (xid->xid2_flag2 == 0x40) {\n\t\t\trc = 4;\n\t\t\t \n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): xid NOGOOD\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\t}\n\t\tif (xid->xid2_adj_id != grp->saved_xid2->xid2_adj_id) {\n\t\t\trc = 5;\n\t\t\t \n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): Adjacent Station ID Mismatch\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\t}\n\t\tif (xid->xid2_sender_id != grp->saved_xid2->xid2_sender_id) {\n\t\t\trc = 6;\n\t\t\t \n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): Sender Address Mismatch\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\t}\n\t}\ndone:\n\tif (rc) {\n\t\tdev_warn(&dev->dev,\n\t\t\t\"The XID used in the MPC protocol is not valid, \"\n\t\t\t\"rc = %d\\n\", rc);\n\t\tpriv->xid->xid2_flag2 = 0x40;\n\t\tgrp->saved_xid2->xid2_flag2 = 0x40;\n\t}\n\n\treturn rc;\n}\n\n \nstatic void mpc_action_side_xid(fsm_instance *fsm, void *arg, int side)\n{\n\tstruct channel *ch = arg;\n\tint rc = 0;\n\tint gotlock = 0;\n\tunsigned long saveflags = 0;\t \n\n\tCTCM_PR_DEBUG(\"Enter %s: cp=%i ch=0x%p id=%s\\n\",\n\t\t\t__func__, smp_processor_id(), ch, ch->id);\n\n\tif (ctcm_checkalloc_buffer(ch))\n\t\t\t\t\tgoto done;\n\n\t \n\tch->trans_skb->data = ch->trans_skb_data;\n\tskb_reset_tail_pointer(ch->trans_skb);\n\tch->trans_skb->len = 0;\n\t \n\tmemset(ch->trans_skb->data, 0, 16);\n\tch->rcvd_xid_th =  (struct th_header *)ch->trans_skb_data;\n\t \n\tskb_put(ch->trans_skb, TH_HEADER_LENGTH);\n\tch->rcvd_xid = (struct xid2 *)skb_tail_pointer(ch->trans_skb);\n\t \n\tskb_put(ch->trans_skb, XID2_LENGTH);\n\tch->rcvd_xid_id = skb_tail_pointer(ch->trans_skb);\n\t \n\tch->trans_skb->data = ch->trans_skb_data;\n\tskb_reset_tail_pointer(ch->trans_skb);\n\tch->trans_skb->len = 0;\n\n\t \n\t \n\n\tch->ccw[8].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\tch->ccw[8].count\t= 0;\n\tch->ccw[8].cda\t\t= 0x00;\n\n\tif (!(ch->xid_th && ch->xid && ch->xid_id))\n\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_INFO,\n\t\t\t\"%s(%s): xid_th=%p, xid=%p, xid_id=%p\",\n\t\t\tCTCM_FUNTAIL, ch->id, ch->xid_th, ch->xid, ch->xid_id);\n\n\tif (side == XSIDE) {\n\t\t \n\t\tif (ch->xid_th == NULL)\n\t\t\t\tgoto done;\n\t\tch->ccw[9].cmd_code\t= CCW_CMD_WRITE;\n\t\tch->ccw[9].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[9].count\t= TH_HEADER_LENGTH;\n\t\tch->ccw[9].cda\t\t= virt_to_phys(ch->xid_th);\n\n\t\tif (ch->xid == NULL)\n\t\t\t\tgoto done;\n\t\tch->ccw[10].cmd_code\t= CCW_CMD_WRITE;\n\t\tch->ccw[10].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[10].count\t= XID2_LENGTH;\n\t\tch->ccw[10].cda\t\t= virt_to_phys(ch->xid);\n\n\t\tch->ccw[11].cmd_code\t= CCW_CMD_READ;\n\t\tch->ccw[11].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[11].count\t= TH_HEADER_LENGTH;\n\t\tch->ccw[11].cda\t\t= virt_to_phys(ch->rcvd_xid_th);\n\n\t\tch->ccw[12].cmd_code\t= CCW_CMD_READ;\n\t\tch->ccw[12].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[12].count\t= XID2_LENGTH;\n\t\tch->ccw[12].cda\t\t= virt_to_phys(ch->rcvd_xid);\n\n\t\tch->ccw[13].cmd_code\t= CCW_CMD_READ;\n\t\tch->ccw[13].cda\t\t= virt_to_phys(ch->rcvd_xid_id);\n\n\t} else {  \n\t\tch->ccw[9].cmd_code\t= CCW_CMD_READ;\n\t\tch->ccw[9].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[9].count\t= TH_HEADER_LENGTH;\n\t\tch->ccw[9].cda\t\t= virt_to_phys(ch->rcvd_xid_th);\n\n\t\tch->ccw[10].cmd_code\t= CCW_CMD_READ;\n\t\tch->ccw[10].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[10].count\t= XID2_LENGTH;\n\t\tch->ccw[10].cda\t\t= virt_to_phys(ch->rcvd_xid);\n\n\t\tif (ch->xid_th == NULL)\n\t\t\t\tgoto done;\n\t\tch->ccw[11].cmd_code\t= CCW_CMD_WRITE;\n\t\tch->ccw[11].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[11].count\t= TH_HEADER_LENGTH;\n\t\tch->ccw[11].cda\t\t= virt_to_phys(ch->xid_th);\n\n\t\tif (ch->xid == NULL)\n\t\t\t\tgoto done;\n\t\tch->ccw[12].cmd_code\t= CCW_CMD_WRITE;\n\t\tch->ccw[12].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[12].count\t= XID2_LENGTH;\n\t\tch->ccw[12].cda\t\t= virt_to_phys(ch->xid);\n\n\t\tif (ch->xid_id == NULL)\n\t\t\t\tgoto done;\n\t\tch->ccw[13].cmd_code\t= CCW_CMD_WRITE;\n\t\tch->ccw[13].cda\t\t= virt_to_phys(ch->xid_id);\n\n\t}\n\tch->ccw[13].flags\t= CCW_FLAG_SLI | CCW_FLAG_CC;\n\tch->ccw[13].count\t= 4;\n\n\tch->ccw[14].cmd_code\t= CCW_CMD_NOOP;\n\tch->ccw[14].flags\t= CCW_FLAG_SLI;\n\tch->ccw[14].count\t= 0;\n\tch->ccw[14].cda\t\t= 0;\n\n\tCTCM_CCW_DUMP((char *)&ch->ccw[8], sizeof(struct ccw1) * 7);\n\tCTCM_D3_DUMP((char *)ch->xid_th, TH_HEADER_LENGTH);\n\tCTCM_D3_DUMP((char *)ch->xid, XID2_LENGTH);\n\tCTCM_D3_DUMP((char *)ch->xid_id, 4);\n\n\tif (!in_hardirq()) {\n\t\t\t  \n\t\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\t\tgotlock = 1;\n\t}\n\n\tfsm_addtimer(&ch->timer, 5000 , CTC_EVENT_TIMER, ch);\n\trc = ccw_device_start(ch->cdev, &ch->ccw[8], 0, 0xff, 0);\n\n\tif (gotlock)\t \n\t\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\n\n\tif (rc != 0) {\n\t\tctcm_ccw_check_rc(ch, rc,\n\t\t\t\t(side == XSIDE) ? \"x-side XID\" : \"y-side XID\");\n\t}\n\ndone:\n\tCTCM_PR_DEBUG(\"Exit %s: ch=0x%p id=%s\\n\",\n\t\t\t\t__func__, ch, ch->id);\n\treturn;\n\n}\n\n \nstatic void mpc_action_xside_xid(fsm_instance *fsm, int event, void *arg)\n{\n\tmpc_action_side_xid(fsm, arg, XSIDE);\n}\n\n \nstatic void mpc_action_yside_xid(fsm_instance *fsm, int event, void *arg)\n{\n\tmpc_action_side_xid(fsm, arg, YSIDE);\n}\n\n \nstatic void mpc_action_doxid0(fsm_instance *fsm, int event, void *arg)\n{\n\tstruct channel\t   *ch   = arg;\n\tstruct net_device  *dev  = ch->netdev;\n\tstruct ctcm_priv   *priv = dev->ml_priv;\n\tstruct mpc_group   *grp  = priv->mpcg;\n\n\tCTCM_PR_DEBUG(\"Enter %s: cp=%i ch=0x%p id=%s\\n\",\n\t\t\t__func__, smp_processor_id(), ch, ch->id);\n\n\tif (ch->xid == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): ch->xid == NULL\",\n\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\treturn;\n\t}\n\n\tfsm_newstate(ch->fsm, CH_XID0_INPROGRESS);\n\n\tch->xid->xid2_option =\tXID2_0;\n\n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_XID2INITW:\n\tcase MPCG_STATE_XID2INITX:\n\t\tch->ccw[8].cmd_code = CCW_CMD_SENSE_CMD;\n\t\tbreak;\n\tcase MPCG_STATE_XID0IOWAIT:\n\tcase MPCG_STATE_XID0IOWAIX:\n\t\tch->ccw[8].cmd_code = CCW_CMD_WRITE_CTL;\n\t\tbreak;\n\t}\n\n\tfsm_event(grp->fsm, MPCG_EVENT_DOIO, ch);\n\n\treturn;\n}\n\n \nstatic void mpc_action_doxid7(fsm_instance *fsm, int event, void *arg)\n{\n\tstruct net_device *dev = arg;\n\tstruct ctcm_priv  *priv = dev->ml_priv;\n\tstruct mpc_group  *grp  = NULL;\n\tint direction;\n\tint send = 0;\n\n\tif (priv)\n\t\tgrp = priv->mpcg;\n\tif (grp == NULL)\n\t\treturn;\n\n\tfor (direction = CTCM_READ; direction <= CTCM_WRITE; direction++) {\n\t\tstruct channel *ch = priv->channel[direction];\n\t\tstruct xid2 *thisxid = ch->xid;\n\t\tch->xid_skb->data = ch->xid_skb_data;\n\t\tskb_reset_tail_pointer(ch->xid_skb);\n\t\tch->xid_skb->len = 0;\n\t\tthisxid->xid2_option = XID2_7;\n\t\tsend = 0;\n\n\t\t \n\t\tif (grp->outstanding_xid7_p2 > 0) {\n\t\t\tif (grp->roll == YSIDE) {\n\t\t\t\tif (fsm_getstate(ch->fsm) == CH_XID7_PENDING1) {\n\t\t\t\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING2);\n\t\t\t\t\tch->ccw[8].cmd_code = CCW_CMD_SENSE_CMD;\n\t\t\t\t\tskb_put_data(ch->xid_skb, &thdummy,\n\t\t\t\t\t\t     TH_HEADER_LENGTH);\n\t\t\t\t\tsend = 1;\n\t\t\t\t}\n\t\t\t} else if (fsm_getstate(ch->fsm) < CH_XID7_PENDING2) {\n\t\t\t\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING2);\n\t\t\t\t\tch->ccw[8].cmd_code = CCW_CMD_WRITE_CTL;\n\t\t\t\t\tskb_put_data(ch->xid_skb, &thnorm,\n\t\t\t\t\t\t     TH_HEADER_LENGTH);\n\t\t\t\t\tsend = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (grp->roll == YSIDE) {\n\t\t\t\tif (fsm_getstate(ch->fsm) < CH_XID7_PENDING4) {\n\t\t\t\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING4);\n\t\t\t\t\tskb_put_data(ch->xid_skb, &thnorm,\n\t\t\t\t\t\t     TH_HEADER_LENGTH);\n\t\t\t\t\tch->ccw[8].cmd_code = CCW_CMD_WRITE_CTL;\n\t\t\t\t\tsend = 1;\n\t\t\t\t}\n\t\t\t} else if (fsm_getstate(ch->fsm) == CH_XID7_PENDING3) {\n\t\t\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING4);\n\t\t\t\tch->ccw[8].cmd_code = CCW_CMD_SENSE_CMD;\n\t\t\t\tskb_put_data(ch->xid_skb, &thdummy,\n\t\t\t\t\t     TH_HEADER_LENGTH);\n\t\t\t\tsend = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (send)\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_DOIO, ch);\n\t}\n\n\treturn;\n}\n\n \nstatic void mpc_action_rcvd_xid0(fsm_instance *fsm, int event, void *arg)\n{\n\n\tstruct mpcg_info   *mpcginfo  = arg;\n\tstruct channel\t   *ch   = mpcginfo->ch;\n\tstruct net_device  *dev  = ch->netdev;\n\tstruct ctcm_priv   *priv = dev->ml_priv;\n\tstruct mpc_group   *grp  = priv->mpcg;\n\n\tCTCM_PR_DEBUG(\"%s: ch-id:%s xid2:%i xid7:%i xidt_p2:%i \\n\",\n\t\t\t__func__, ch->id, grp->outstanding_xid2,\n\t\t\tgrp->outstanding_xid7, grp->outstanding_xid7_p2);\n\n\tif (fsm_getstate(ch->fsm) < CH_XID7_PENDING)\n\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING);\n\n\tgrp->outstanding_xid2--;\n\tgrp->outstanding_xid7++;\n\tgrp->outstanding_xid7_p2++;\n\n\t \n\t \n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_XID2INITW:\n\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID2INITX);\n\t\tmpc_validate_xid(mpcginfo);\n\t\tbreak;\n\tcase MPCG_STATE_XID0IOWAIT:\n\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID0IOWAIX);\n\t\tmpc_validate_xid(mpcginfo);\n\t\tbreak;\n\tcase MPCG_STATE_XID2INITX:\n\t\tif (grp->outstanding_xid2 == 0) {\n\t\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID7INITW);\n\t\t\tmpc_validate_xid(mpcginfo);\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_XID2DONE, dev);\n\t\t}\n\t\tbreak;\n\tcase MPCG_STATE_XID0IOWAIX:\n\t\tif (grp->outstanding_xid2 == 0) {\n\t\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID7INITI);\n\t\t\tmpc_validate_xid(mpcginfo);\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_XID2DONE, dev);\n\t\t}\n\t\tbreak;\n\t}\n\n\tCTCM_PR_DEBUG(\"ctcmpc:%s() %s xid2:%i xid7:%i xidt_p2:%i \\n\",\n\t\t__func__, ch->id, grp->outstanding_xid2,\n\t\tgrp->outstanding_xid7, grp->outstanding_xid7_p2);\n\tCTCM_PR_DEBUG(\"ctcmpc:%s() %s grpstate: %s chanstate: %s \\n\",\n\t\t__func__, ch->id,\n\t\tfsm_getstate_str(grp->fsm), fsm_getstate_str(ch->fsm));\n\treturn;\n\n}\n\n\n \nstatic void mpc_action_rcvd_xid7(fsm_instance *fsm, int event, void *arg)\n{\n\tstruct mpcg_info   *mpcginfo   = arg;\n\tstruct channel\t   *ch\t       = mpcginfo->ch;\n\tstruct net_device  *dev        = ch->netdev;\n\tstruct ctcm_priv   *priv    = dev->ml_priv;\n\tstruct mpc_group   *grp     = priv->mpcg;\n\n\tCTCM_PR_DEBUG(\"Enter %s: cp=%i ch=0x%p id=%s\\n\",\n\t\t__func__, smp_processor_id(), ch, ch->id);\n\tCTCM_PR_DEBUG(\"%s: outstanding_xid7: %i, outstanding_xid7_p2: %i\\n\",\n\t\t__func__, grp->outstanding_xid7, grp->outstanding_xid7_p2);\n\n\tgrp->outstanding_xid7--;\n\tch->xid_skb->data = ch->xid_skb_data;\n\tskb_reset_tail_pointer(ch->xid_skb);\n\tch->xid_skb->len = 0;\n\n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_XID7INITI:\n\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID7INITZ);\n\t\tmpc_validate_xid(mpcginfo);\n\t\tbreak;\n\tcase MPCG_STATE_XID7INITW:\n\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID7INITX);\n\t\tmpc_validate_xid(mpcginfo);\n\t\tbreak;\n\tcase MPCG_STATE_XID7INITZ:\n\tcase MPCG_STATE_XID7INITX:\n\t\tif (grp->outstanding_xid7 == 0) {\n\t\t\tif (grp->outstanding_xid7_p2 > 0) {\n\t\t\t\tgrp->outstanding_xid7 =\n\t\t\t\t\tgrp->outstanding_xid7_p2;\n\t\t\t\tgrp->outstanding_xid7_p2 = 0;\n\t\t\t} else\n\t\t\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID7INITF);\n\n\t\t\tmpc_validate_xid(mpcginfo);\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_XID7DONE, dev);\n\t\t\tbreak;\n\t\t}\n\t\tmpc_validate_xid(mpcginfo);\n\t\tbreak;\n\t}\n\treturn;\n}\n\n \nstatic int mpc_send_qllc_discontact(struct net_device *dev)\n{\n\tstruct sk_buff   *skb;\n\tstruct qllc      *qllcptr;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct mpc_group *grp = priv->mpcg;\n\n\tCTCM_PR_DEBUG(\"%s: GROUP STATE: %s\\n\",\n\t\t__func__, mpcg_state_names[grp->saved_state]);\n\n\tswitch (grp->saved_state) {\n\t \n\tcase MPCG_STATE_XID0IOWAIT:\n\tcase MPCG_STATE_XID0IOWAIX:\n\tcase MPCG_STATE_XID7INITI:\n\tcase MPCG_STATE_XID7INITZ:\n\tcase MPCG_STATE_XID2INITW:\n\tcase MPCG_STATE_XID2INITX:\n\tcase MPCG_STATE_XID7INITW:\n\tcase MPCG_STATE_XID7INITX:\n\t\tif (grp->estconnfunc) {\n\t\t\tgrp->estconnfunc(grp->port_num, -1, 0);\n\t\t\tgrp->estconnfunc = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase MPCG_STATE_FLOWC:\n\tcase MPCG_STATE_READY:\n\t\tgrp->send_qllc_disc = 2;\n\n\t\tskb = __dev_alloc_skb(sizeof(struct qllc), GFP_ATOMIC);\n\t\tif (skb == NULL) {\n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): skb allocation error\",\n\t\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\t\tpriv->stats.rx_dropped++;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tqllcptr = skb_put(skb, sizeof(struct qllc));\n\t\tqllcptr->qllc_address = 0xcc;\n\t\tqllcptr->qllc_commands = 0x03;\n\n\t\tif (skb_headroom(skb) < 4) {\n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): skb_headroom error\",\n\t\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t*((__u32 *)skb_push(skb, 4)) =\n\t\t\tpriv->channel[CTCM_READ]->pdu_seq;\n\t\tpriv->channel[CTCM_READ]->pdu_seq++;\n\t\tCTCM_PR_DBGDATA(\"ctcmpc: %s ToDCM_pdu_seq= %08x\\n\",\n\t\t\t\t__func__, priv->channel[CTCM_READ]->pdu_seq);\n\n\t\t \n\t\tpriv->channel[CTCM_READ]->pdu_seq = 0x00;\n\t\tskb_reset_mac_header(skb);\n\t\tskb->dev = dev;\n\t\tskb->protocol = htons(ETH_P_SNAP);\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\tCTCM_D3_DUMP(skb->data, (sizeof(struct qllc) + 4));\n\n\t\tnetif_rx(skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\treturn 0;\n}\n \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}