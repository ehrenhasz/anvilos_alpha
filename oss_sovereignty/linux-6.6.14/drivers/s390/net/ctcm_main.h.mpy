{
  "module_name": "ctcm_main.h",
  "hash_id": "3ea35667dd8f6614cde52876d44d3bb44cf6b7da2c03ebfbdfef0e826d2f4591",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/ctcm_main.h",
  "human_readable_source": " \n \n\n#ifndef _CTCM_MAIN_H_\n#define _CTCM_MAIN_H_\n\n#include <asm/ccwdev.h>\n#include <asm/ccwgroup.h>\n\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n\n#include \"fsm.h\"\n#include \"ctcm_dbug.h\"\n#include \"ctcm_mpc.h\"\n\n#define CTC_DRIVER_NAME\t\"ctcm\"\n#define CTC_DEVICE_NAME\t\"ctc\"\n#define MPC_DEVICE_NAME\t\"mpc\"\n#define CTC_DEVICE_GENE CTC_DEVICE_NAME \"%d\"\n#define MPC_DEVICE_GENE\tMPC_DEVICE_NAME \"%d\"\n\n#define CHANNEL_FLAGS_READ\t0\n#define CHANNEL_FLAGS_WRITE\t1\n#define CHANNEL_FLAGS_INUSE\t2\n#define CHANNEL_FLAGS_BUFSIZE_CHANGED\t4\n#define CHANNEL_FLAGS_FAILED\t8\n#define CHANNEL_FLAGS_WAITIRQ\t16\n#define CHANNEL_FLAGS_RWMASK\t1\n#define CHANNEL_DIRECTION(f) (f & CHANNEL_FLAGS_RWMASK)\n\n#define LOG_FLAG_ILLEGALPKT\t1\n#define LOG_FLAG_ILLEGALSIZE\t2\n#define LOG_FLAG_OVERRUN\t4\n#define LOG_FLAG_NOMEM\t\t8\n\n#define ctcm_pr_debug(fmt, arg...) printk(KERN_DEBUG fmt, ##arg)\n\n#define CTCM_PR_DEBUG(fmt, arg...) \\\n\tdo { \\\n\t\tif (do_debug) \\\n\t\t\tprintk(KERN_DEBUG fmt, ##arg); \\\n\t} while (0)\n\n#define\tCTCM_PR_DBGDATA(fmt, arg...) \\\n\tdo { \\\n\t\tif (do_debug_data) \\\n\t\t\tprintk(KERN_DEBUG fmt, ##arg); \\\n\t} while (0)\n\n#define\tCTCM_D3_DUMP(buf, len) \\\n\tdo { \\\n\t\tif (do_debug_data) \\\n\t\t\tctcmpc_dumpit(buf, len); \\\n\t} while (0)\n\n#define\tCTCM_CCW_DUMP(buf, len) \\\n\tdo { \\\n\t\tif (do_debug_ccw) \\\n\t\t\tctcmpc_dumpit(buf, len); \\\n\t} while (0)\n\n \nenum ctcm_channel_types {\n\t \n\tctcm_channel_type_none,\n\n\t \n\tctcm_channel_type_parallel,\n\n\t \n\tctcm_channel_type_ficon,\n\n\t \n\tctcm_channel_type_escon\n};\n\n \n#define CCW_CMD_WRITE\t\t0x01\n#define CCW_CMD_READ\t\t0x02\n#define CCW_CMD_NOOP\t\t0x03\n#define CCW_CMD_TIC             0x08\n#define CCW_CMD_SENSE_CMD\t0x14\n#define CCW_CMD_WRITE_CTL\t0x17\n#define CCW_CMD_SET_EXTENDED\t0xc3\n#define CCW_CMD_PREPARE\t\t0xe3\n\n#define CTCM_PROTO_S390\t\t0\n#define CTCM_PROTO_LINUX\t1\n#define CTCM_PROTO_LINUX_TTY\t2\n#define CTCM_PROTO_OS390\t3\n#define CTCM_PROTO_MPC\t\t4\n#define CTCM_PROTO_MAX\t\t4\n\n#define CTCM_STATSIZE_LIMIT\t64\n#define CTCM_BUFSIZE_LIMIT\t65535\n#define CTCM_BUFSIZE_DEFAULT\t32768\n#define MPC_BUFSIZE_DEFAULT\tCTCM_BUFSIZE_LIMIT\n\n#define CTCM_TIME_1_SEC\t\t1000\n#define CTCM_TIME_5_SEC\t\t5000\n#define CTCM_TIME_10_SEC\t10000\n\n#define CTCM_INITIAL_BLOCKLEN\t2\n\n#define CTCM_READ\t\t0\n#define CTCM_WRITE\t\t1\n\n#define CTCM_ID_SIZE\t\t20+3\n\nstruct ctcm_profile {\n\tunsigned long maxmulti;\n\tunsigned long maxcqueue;\n\tunsigned long doios_single;\n\tunsigned long doios_multi;\n\tunsigned long txlen;\n\tunsigned long tx_time;\n\tunsigned long send_stamp;\n};\n\n \nstruct channel {\n\tstruct channel *next;\n\tchar id[CTCM_ID_SIZE];\n\tstruct ccw_device *cdev;\n\t \n\tenum ctcm_channel_types type;\n\t \n\t__u32 flags;\n\t__u16 protocol;\t\t \n\t \n\tstruct ccw1 *ccw;\n\tstruct irb *irb;\n\t \n\tint max_bufsize;\n\tstruct sk_buff *trans_skb;\t \n\tstruct sk_buff_head io_queue;\t \n\tstruct tasklet_struct ch_tasklet;\t \n\t \n\tstruct sk_buff_head collect_queue;\n\t \n\tint collect_len;\n\t \n\tspinlock_t collect_lock;\n\t \n\tfsm_timer timer;\n\t \n\t__u32\tth_seq_num;\t \n\t__u8\tth_seg;\n\t__u32\tpdu_seq;\n\tstruct sk_buff\t\t*xid_skb;\n\tchar\t\t\t*xid_skb_data;\n\tstruct th_header\t*xid_th;\n\tstruct xid2\t\t*xid;\n\tchar\t\t\t*xid_id;\n\tstruct th_header\t*rcvd_xid_th;\n\tstruct xid2\t\t*rcvd_xid;\n\tchar\t\t\t*rcvd_xid_id;\n\t__u8\t\t\tin_mpcgroup;\n\tfsm_timer\t\tsweep_timer;\n\tstruct sk_buff_head\tsweep_queue;\n\tstruct th_header\t*discontact_th;\n\tstruct tasklet_struct\tch_disc_tasklet;\n\t \n\n\tint retry;\t\t \n\tfsm_instance *fsm;\t \n\tstruct net_device *netdev;\t \n\tstruct ctcm_profile prof;\n\t__u8 *trans_skb_data;\n\t__u16 logflags;\n\t__u8  sense_rc;  \n};\n\nstruct ctcm_priv {\n\tstruct net_device_stats\tstats;\n\tunsigned long\ttbusy;\n\n\t \n\tstruct\tmpc_group\t*mpcg;\t \n\tstruct\txid2\t\t*xid;\t \n\n\t \n\tfsm_instance *fsm;\n\n\t \n\t__u16 protocol;\n\n\t \n\tfsm_timer\trestart_timer;\n\n\tint buffer_size;\t \n\n\tstruct channel *channel[2];\n};\n\nint ctcm_open(struct net_device *dev);\nint ctcm_close(struct net_device *dev);\n\nextern const struct attribute_group *ctcm_attr_groups[];\n\n \nstatic inline void ctcm_clear_busy_do(struct net_device *dev)\n{\n\tclear_bit(0, &(((struct ctcm_priv *)dev->ml_priv)->tbusy));\n\tnetif_wake_queue(dev);\n}\n\nstatic inline void ctcm_clear_busy(struct net_device *dev)\n{\n\tstruct mpc_group *grp;\n\tgrp = ((struct ctcm_priv *)dev->ml_priv)->mpcg;\n\n\tif (!(grp && grp->in_sweep))\n\t\tctcm_clear_busy_do(dev);\n}\n\n\nstatic inline int ctcm_test_and_set_busy(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn test_and_set_bit(0,\n\t\t\t&(((struct ctcm_priv *)dev->ml_priv)->tbusy));\n}\n\nextern int loglevel;\nextern struct channel *channels;\n\nvoid ctcm_unpack_skb(struct channel *ch, struct sk_buff *pskb);\n\n \n\nstatic inline int ctcm_less_than(char *id1, char *id2)\n{\n\tunsigned long dev1, dev2;\n\n\tid1 = id1 + 5;\n\tid2 = id2 + 5;\n\n\tdev1 = simple_strtoul(id1, &id1, 16);\n\tdev2 = simple_strtoul(id2, &id2, 16);\n\n\treturn (dev1 < dev2);\n}\n\nint ctcm_ch_alloc_buffer(struct channel *ch);\n\nstatic inline int ctcm_checkalloc_buffer(struct channel *ch)\n{\n\tif (ch->trans_skb == NULL)\n\t\treturn ctcm_ch_alloc_buffer(ch);\n\tif (ch->flags & CHANNEL_FLAGS_BUFSIZE_CHANGED) {\n\t\tdev_kfree_skb(ch->trans_skb);\n\t\treturn ctcm_ch_alloc_buffer(ch);\n\t}\n\treturn 0;\n}\n\nstruct mpc_group *ctcmpc_init_mpc_group(struct ctcm_priv *priv);\n\n \n#define IS_MPC(p) ((p)->protocol == CTCM_PROTO_MPC)\n\n \n#define IS_MPCDEV(dev) IS_MPC((struct ctcm_priv *)dev->ml_priv)\n\n \nstruct ll_header {\n\t__u16 length;\n\t__u16 type;\n\t__u16 unused;\n};\n#define LL_HEADER_LENGTH (sizeof(struct ll_header))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}