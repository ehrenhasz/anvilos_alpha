{
  "module_name": "ctcm_fsms.c",
  "hash_id": "c793c26bcf127e981a301bdcf6da3dc4baa6ef922977fbe6016a83065daa8a3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/ctcm_fsms.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n#undef DEBUGDATA\n#undef DEBUGCCW\n\n#define KMSG_COMPONENT \"ctcm\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/bitops.h>\n\n#include <linux/signal.h>\n#include <linux/string.h>\n\n#include <linux/ip.h>\n#include <linux/if_arp.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n#include <net/dst.h>\n\n#include <linux/io.h>\n#include <asm/ccwdev.h>\n#include <asm/ccwgroup.h>\n#include <linux/uaccess.h>\n\n#include <asm/idals.h>\n\n#include \"fsm.h\"\n\n#include \"ctcm_dbug.h\"\n#include \"ctcm_main.h\"\n#include \"ctcm_fsms.h\"\n\nconst char *dev_state_names[] = {\n\t[DEV_STATE_STOPPED]\t\t= \"Stopped\",\n\t[DEV_STATE_STARTWAIT_RXTX]\t= \"StartWait RXTX\",\n\t[DEV_STATE_STARTWAIT_RX]\t= \"StartWait RX\",\n\t[DEV_STATE_STARTWAIT_TX]\t= \"StartWait TX\",\n\t[DEV_STATE_STOPWAIT_RXTX]\t= \"StopWait RXTX\",\n\t[DEV_STATE_STOPWAIT_RX]\t\t= \"StopWait RX\",\n\t[DEV_STATE_STOPWAIT_TX]\t\t= \"StopWait TX\",\n\t[DEV_STATE_RUNNING]\t\t= \"Running\",\n};\n\nconst char *dev_event_names[] = {\n\t[DEV_EVENT_START]\t= \"Start\",\n\t[DEV_EVENT_STOP]\t= \"Stop\",\n\t[DEV_EVENT_RXUP]\t= \"RX up\",\n\t[DEV_EVENT_TXUP]\t= \"TX up\",\n\t[DEV_EVENT_RXDOWN]\t= \"RX down\",\n\t[DEV_EVENT_TXDOWN]\t= \"TX down\",\n\t[DEV_EVENT_RESTART]\t= \"Restart\",\n};\n\nconst char *ctc_ch_event_names[] = {\n\t[CTC_EVENT_IO_SUCCESS]\t= \"ccw_device success\",\n\t[CTC_EVENT_IO_EBUSY]\t= \"ccw_device busy\",\n\t[CTC_EVENT_IO_ENODEV]\t= \"ccw_device enodev\",\n\t[CTC_EVENT_IO_UNKNOWN]\t= \"ccw_device unknown\",\n\t[CTC_EVENT_ATTNBUSY]\t= \"Status ATTN & BUSY\",\n\t[CTC_EVENT_ATTN]\t= \"Status ATTN\",\n\t[CTC_EVENT_BUSY]\t= \"Status BUSY\",\n\t[CTC_EVENT_UC_RCRESET]\t= \"Unit check remote reset\",\n\t[CTC_EVENT_UC_RSRESET]\t= \"Unit check remote system reset\",\n\t[CTC_EVENT_UC_TXTIMEOUT] = \"Unit check TX timeout\",\n\t[CTC_EVENT_UC_TXPARITY]\t= \"Unit check TX parity\",\n\t[CTC_EVENT_UC_HWFAIL]\t= \"Unit check Hardware failure\",\n\t[CTC_EVENT_UC_RXPARITY]\t= \"Unit check RX parity\",\n\t[CTC_EVENT_UC_ZERO]\t= \"Unit check ZERO\",\n\t[CTC_EVENT_UC_UNKNOWN]\t= \"Unit check Unknown\",\n\t[CTC_EVENT_SC_UNKNOWN]\t= \"SubChannel check Unknown\",\n\t[CTC_EVENT_MC_FAIL]\t= \"Machine check failure\",\n\t[CTC_EVENT_MC_GOOD]\t= \"Machine check operational\",\n\t[CTC_EVENT_IRQ]\t\t= \"IRQ normal\",\n\t[CTC_EVENT_FINSTAT]\t= \"IRQ final\",\n\t[CTC_EVENT_TIMER]\t= \"Timer\",\n\t[CTC_EVENT_START]\t= \"Start\",\n\t[CTC_EVENT_STOP]\t= \"Stop\",\n\t \n\t[CTC_EVENT_SEND_XID]\t= \"XID Exchange\",\n\t[CTC_EVENT_RSWEEP_TIMER] = \"MPC Group Sweep Timer\",\n};\n\nconst char *ctc_ch_state_names[] = {\n\t[CTC_STATE_IDLE]\t= \"Idle\",\n\t[CTC_STATE_STOPPED]\t= \"Stopped\",\n\t[CTC_STATE_STARTWAIT]\t= \"StartWait\",\n\t[CTC_STATE_STARTRETRY]\t= \"StartRetry\",\n\t[CTC_STATE_SETUPWAIT]\t= \"SetupWait\",\n\t[CTC_STATE_RXINIT]\t= \"RX init\",\n\t[CTC_STATE_TXINIT]\t= \"TX init\",\n\t[CTC_STATE_RX]\t\t= \"RX\",\n\t[CTC_STATE_TX]\t\t= \"TX\",\n\t[CTC_STATE_RXIDLE]\t= \"RX idle\",\n\t[CTC_STATE_TXIDLE]\t= \"TX idle\",\n\t[CTC_STATE_RXERR]\t= \"RX error\",\n\t[CTC_STATE_TXERR]\t= \"TX error\",\n\t[CTC_STATE_TERM]\t= \"Terminating\",\n\t[CTC_STATE_DTERM]\t= \"Restarting\",\n\t[CTC_STATE_NOTOP]\t= \"Not operational\",\n\t \n\t[CH_XID0_PENDING]\t= \"Pending XID0 Start\",\n\t[CH_XID0_INPROGRESS]\t= \"In XID0 Negotiations \",\n\t[CH_XID7_PENDING]\t= \"Pending XID7 P1 Start\",\n\t[CH_XID7_PENDING1]\t= \"Active XID7 P1 Exchange \",\n\t[CH_XID7_PENDING2]\t= \"Pending XID7 P2 Start \",\n\t[CH_XID7_PENDING3]\t= \"Active XID7 P2 Exchange \",\n\t[CH_XID7_PENDING4]\t= \"XID7 Complete - Pending READY \",\n};\n\nstatic void ctcm_action_nop(fsm_instance *fi, int event, void *arg);\n\n \nstatic void chx_txdone(fsm_instance *fi, int event, void *arg);\nstatic void chx_rx(fsm_instance *fi, int event, void *arg);\nstatic void chx_rxidle(fsm_instance *fi, int event, void *arg);\nstatic void chx_firstio(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_setmode(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_start(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_haltio(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_stopped(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_stop(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_fail(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_setuperr(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_restart(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_rxiniterr(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_rxinitfail(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_rxdisc(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_txiniterr(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_txretry(fsm_instance *fi, int event, void *arg);\nstatic void ctcm_chx_iofatal(fsm_instance *fi, int event, void *arg);\n\n \nstatic void ctcmpc_chx_txdone(fsm_instance *fi, int event, void *arg);\nstatic void ctcmpc_chx_rx(fsm_instance *fi, int event, void *arg);\nstatic void ctcmpc_chx_firstio(fsm_instance *fi, int event, void *arg);\n \nstatic void ctcmpc_chx_attn(fsm_instance *fsm, int event, void *arg);\nstatic void ctcmpc_chx_attnbusy(fsm_instance *, int, void *);\nstatic void ctcmpc_chx_resend(fsm_instance *, int, void *);\nstatic void ctcmpc_chx_send_sweep(fsm_instance *fsm, int event, void *arg);\n\n \nvoid ctcm_ccw_check_rc(struct channel *ch, int rc, char *msg)\n{\n\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\"%s(%s): %s: %04x\\n\",\n\t\tCTCM_FUNTAIL, ch->id, msg, rc);\n\tswitch (rc) {\n\tcase -EBUSY:\n\t\tpr_info(\"%s: The communication peer is busy\\n\",\n\t\t\tch->id);\n\t\tfsm_event(ch->fsm, CTC_EVENT_IO_EBUSY, ch);\n\t\tbreak;\n\tcase -ENODEV:\n\t\tpr_err(\"%s: The specified target device is not valid\\n\",\n\t\t       ch->id);\n\t\tfsm_event(ch->fsm, CTC_EVENT_IO_ENODEV, ch);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"An I/O operation resulted in error %04x\\n\",\n\t\t       rc);\n\t\tfsm_event(ch->fsm, CTC_EVENT_IO_UNKNOWN, ch);\n\t}\n}\n\nvoid ctcm_purge_skb_queue(struct sk_buff_head *q)\n{\n\tstruct sk_buff *skb;\n\n\tCTCM_DBF_TEXT(TRACE, CTC_DBF_DEBUG, __func__);\n\n\twhile ((skb = skb_dequeue(q))) {\n\t\trefcount_dec(&skb->users);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\n \nstatic void ctcm_action_nop(fsm_instance *fi, int event, void *arg)\n{\n}\n\n \n\n \nstatic void chx_txdone(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct sk_buff *skb;\n\tint first = 1;\n\tint i;\n\tunsigned long duration;\n\tunsigned long done_stamp = jiffies;\n\n\tCTCM_PR_DEBUG(\"%s(%s): %s\\n\", __func__, ch->id, dev->name);\n\n\tduration = done_stamp - ch->prof.send_stamp;\n\tif (duration > ch->prof.tx_time)\n\t\tch->prof.tx_time = duration;\n\n\tif (ch->irb->scsw.cmd.count != 0)\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\n\t\t\t\"%s(%s): TX not complete, remaining %d bytes\",\n\t\t\t     CTCM_FUNTAIL, dev->name, ch->irb->scsw.cmd.count);\n\tfsm_deltimer(&ch->timer);\n\twhile ((skb = skb_dequeue(&ch->io_queue))) {\n\t\tpriv->stats.tx_packets++;\n\t\tpriv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;\n\t\tif (first) {\n\t\t\tpriv->stats.tx_bytes += 2;\n\t\t\tfirst = 0;\n\t\t}\n\t\trefcount_dec(&skb->users);\n\t\tdev_kfree_skb_irq(skb);\n\t}\n\tspin_lock(&ch->collect_lock);\n\tclear_normalized_cda(&ch->ccw[4]);\n\tif (ch->collect_len > 0) {\n\t\tint rc;\n\n\t\tif (ctcm_checkalloc_buffer(ch)) {\n\t\t\tspin_unlock(&ch->collect_lock);\n\t\t\treturn;\n\t\t}\n\t\tch->trans_skb->data = ch->trans_skb_data;\n\t\tskb_reset_tail_pointer(ch->trans_skb);\n\t\tch->trans_skb->len = 0;\n\t\tif (ch->prof.maxmulti < (ch->collect_len + 2))\n\t\t\tch->prof.maxmulti = ch->collect_len + 2;\n\t\tif (ch->prof.maxcqueue < skb_queue_len(&ch->collect_queue))\n\t\t\tch->prof.maxcqueue = skb_queue_len(&ch->collect_queue);\n\t\t*((__u16 *)skb_put(ch->trans_skb, 2)) = ch->collect_len + 2;\n\t\ti = 0;\n\t\twhile ((skb = skb_dequeue(&ch->collect_queue))) {\n\t\t\tskb_copy_from_linear_data(skb,\n\t\t\t\tskb_put(ch->trans_skb, skb->len), skb->len);\n\t\t\tpriv->stats.tx_packets++;\n\t\t\tpriv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;\n\t\t\trefcount_dec(&skb->users);\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\ti++;\n\t\t}\n\t\tch->collect_len = 0;\n\t\tspin_unlock(&ch->collect_lock);\n\t\tch->ccw[1].count = ch->trans_skb->len;\n\t\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\n\t\tch->prof.send_stamp = jiffies;\n\t\trc = ccw_device_start(ch->cdev, &ch->ccw[0], 0, 0xff, 0);\n\t\tch->prof.doios_multi++;\n\t\tif (rc != 0) {\n\t\t\tpriv->stats.tx_dropped += i;\n\t\t\tpriv->stats.tx_errors += i;\n\t\t\tfsm_deltimer(&ch->timer);\n\t\t\tctcm_ccw_check_rc(ch, rc, \"chained TX\");\n\t\t}\n\t} else {\n\t\tspin_unlock(&ch->collect_lock);\n\t\tfsm_newstate(fi, CTC_STATE_TXIDLE);\n\t}\n\tctcm_clear_busy_do(dev);\n}\n\n \nvoid ctcm_chx_txidle(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCM_PR_DEBUG(\"%s(%s): %s\\n\", __func__, ch->id, dev->name);\n\n\tfsm_deltimer(&ch->timer);\n\tfsm_newstate(fi, CTC_STATE_TXIDLE);\n\tfsm_event(priv->fsm, DEV_EVENT_TXUP, ch->netdev);\n}\n\n \nstatic void chx_rx(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tint len = ch->max_bufsize - ch->irb->scsw.cmd.count;\n\tstruct sk_buff *skb = ch->trans_skb;\n\t__u16 block_len = *((__u16 *)skb->data);\n\tint check_len;\n\tint rc;\n\n\tfsm_deltimer(&ch->timer);\n\tif (len < 8) {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\n\t\t\t\"%s(%s): got packet with length %d < 8\\n\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name, len);\n\t\tpriv->stats.rx_dropped++;\n\t\tpriv->stats.rx_length_errors++;\n\t\tgoto again;\n\t}\n\tif (len > ch->max_bufsize) {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\n\t\t\t\"%s(%s): got packet with length %d > %d\\n\",\n\t\t\t\tCTCM_FUNTAIL, dev->name, len, ch->max_bufsize);\n\t\tpriv->stats.rx_dropped++;\n\t\tpriv->stats.rx_length_errors++;\n\t\tgoto again;\n\t}\n\n\t \n\tswitch (ch->protocol) {\n\tcase CTCM_PROTO_S390:\n\tcase CTCM_PROTO_OS390:\n\t\tcheck_len = block_len + 2;\n\t\tbreak;\n\tdefault:\n\t\tcheck_len = block_len;\n\t\tbreak;\n\t}\n\tif ((len < block_len) || (len > check_len)) {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\n\t\t\t\"%s(%s): got block length %d != rx length %d\\n\",\n\t\t\t\tCTCM_FUNTAIL, dev->name, block_len, len);\n\t\tif (do_debug)\n\t\t\tctcmpc_dump_skb(skb, 0);\n\n\t\t*((__u16 *)skb->data) = len;\n\t\tpriv->stats.rx_dropped++;\n\t\tpriv->stats.rx_length_errors++;\n\t\tgoto again;\n\t}\n\tif (block_len > 2) {\n\t\t*((__u16 *)skb->data) = block_len - 2;\n\t\tctcm_unpack_skb(ch, skb);\n\t}\n again:\n\tskb->data = ch->trans_skb_data;\n\tskb_reset_tail_pointer(skb);\n\tskb->len = 0;\n\tif (ctcm_checkalloc_buffer(ch))\n\t\treturn;\n\tch->ccw[1].count = ch->max_bufsize;\n\trc = ccw_device_start(ch->cdev, &ch->ccw[0], 0, 0xff, 0);\n\tif (rc != 0)\n\t\tctcm_ccw_check_rc(ch, rc, \"normal RX\");\n}\n\n \nstatic void chx_firstio(fsm_instance *fi, int event, void *arg)\n{\n\tint rc;\n\tstruct channel *ch = arg;\n\tint fsmstate = fsm_getstate(fi);\n\n\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\n\t\t\"%s(%s) : %02x\",\n\t\tCTCM_FUNTAIL, ch->id, fsmstate);\n\n\tch->sense_rc = 0;\t \n\tif (fsmstate == CTC_STATE_TXIDLE)\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\n\t\t\t\"%s(%s): remote side issued READ?, init.\\n\",\n\t\t\t\tCTCM_FUNTAIL, ch->id);\n\tfsm_deltimer(&ch->timer);\n\tif (ctcm_checkalloc_buffer(ch))\n\t\treturn;\n\tif ((fsmstate == CTC_STATE_SETUPWAIT) &&\n\t    (ch->protocol == CTCM_PROTO_OS390)) {\n\t\t \n\t\tif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\n\t\t\t*((__u16 *)ch->trans_skb->data) = CTCM_INITIAL_BLOCKLEN;\n\t\t\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC,\n\t\t\t\t     CTC_EVENT_TIMER, ch);\n\t\t\tchx_rxidle(fi, event, arg);\n\t\t} else {\n\t\t\tstruct net_device *dev = ch->netdev;\n\t\t\tstruct ctcm_priv *priv = dev->ml_priv;\n\t\t\tfsm_newstate(fi, CTC_STATE_TXIDLE);\n\t\t\tfsm_event(priv->fsm, DEV_EVENT_TXUP, dev);\n\t\t}\n\t\treturn;\n\t}\n\t \n\tif ((CHANNEL_DIRECTION(ch->flags) == CTCM_WRITE) ||\n\t    (ch->protocol != CTCM_PROTO_S390))\n\t\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\n\n\t*((__u16 *)ch->trans_skb->data) = CTCM_INITIAL_BLOCKLEN;\n\tch->ccw[1].count = 2;\t \n\n\tfsm_newstate(fi, (CHANNEL_DIRECTION(ch->flags) == CTCM_READ)\n\t\t     ? CTC_STATE_RXINIT : CTC_STATE_TXINIT);\n\trc = ccw_device_start(ch->cdev, &ch->ccw[0], 0, 0xff, 0);\n\tif (rc != 0) {\n\t\tfsm_deltimer(&ch->timer);\n\t\tfsm_newstate(fi, CTC_STATE_SETUPWAIT);\n\t\tctcm_ccw_check_rc(ch, rc, \"init IO\");\n\t}\n\t \n\tif ((CHANNEL_DIRECTION(ch->flags) == CTCM_READ) &&\n\t    (ch->protocol == CTCM_PROTO_S390)) {\n\t\tstruct net_device *dev = ch->netdev;\n\t\tstruct ctcm_priv *priv = dev->ml_priv;\n\t\tfsm_event(priv->fsm, DEV_EVENT_RXUP, dev);\n\t}\n}\n\n \nstatic void chx_rxidle(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\t__u16 buflen;\n\tint rc;\n\n\tfsm_deltimer(&ch->timer);\n\tbuflen = *((__u16 *)ch->trans_skb->data);\n\tCTCM_PR_DEBUG(\"%s: %s: Initial RX count = %d\\n\",\n\t\t\t__func__, dev->name, buflen);\n\n\tif (buflen >= CTCM_INITIAL_BLOCKLEN) {\n\t\tif (ctcm_checkalloc_buffer(ch))\n\t\t\treturn;\n\t\tch->ccw[1].count = ch->max_bufsize;\n\t\tfsm_newstate(fi, CTC_STATE_RXIDLE);\n\t\trc = ccw_device_start(ch->cdev, &ch->ccw[0], 0, 0xff, 0);\n\t\tif (rc != 0) {\n\t\t\tfsm_newstate(fi, CTC_STATE_RXINIT);\n\t\t\tctcm_ccw_check_rc(ch, rc, \"initial RX\");\n\t\t} else\n\t\t\tfsm_event(priv->fsm, DEV_EVENT_RXUP, dev);\n\t} else {\n\t\tCTCM_PR_DEBUG(\"%s: %s: Initial RX count %d not %d\\n\",\n\t\t\t\t__func__, dev->name,\n\t\t\t\t\tbuflen, CTCM_INITIAL_BLOCKLEN);\n\t\tchx_firstio(fi, event, arg);\n\t}\n}\n\n \nstatic void ctcm_chx_setmode(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tint rc;\n\tunsigned long saveflags = 0;\n\tint timeout = CTCM_TIME_5_SEC;\n\n\tfsm_deltimer(&ch->timer);\n\tif (IS_MPC(ch)) {\n\t\ttimeout = 1500;\n\t\tCTCM_PR_DEBUG(\"enter %s: cp=%i ch=0x%p id=%s\\n\",\n\t\t\t\t__func__, smp_processor_id(), ch, ch->id);\n\t}\n\tfsm_addtimer(&ch->timer, timeout, CTC_EVENT_TIMER, ch);\n\tfsm_newstate(fi, CTC_STATE_SETUPWAIT);\n\tCTCM_CCW_DUMP((char *)&ch->ccw[6], sizeof(struct ccw1) * 2);\n\n\tif (event == CTC_EVENT_TIMER)\t \n\t\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\t\t\t \n\n\trc = ccw_device_start(ch->cdev, &ch->ccw[6], 0, 0xff, 0);\n\tif (event == CTC_EVENT_TIMER)\t \n\t\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\n\tif (rc != 0) {\n\t\tfsm_deltimer(&ch->timer);\n\t\tfsm_newstate(fi, CTC_STATE_STARTWAIT);\n\t\tctcm_ccw_check_rc(ch, rc, \"set Mode\");\n\t} else\n\t\tch->retry = 0;\n}\n\n \nstatic void ctcm_chx_start(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch\t= arg;\n\tunsigned long saveflags;\n\tint rc;\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO, \"%s(%s): %s\",\n\t\tCTCM_FUNTAIL, ch->id,\n\t\t(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ? \"RX\" : \"TX\");\n\n\tif (ch->trans_skb != NULL) {\n\t\tclear_normalized_cda(&ch->ccw[1]);\n\t\tdev_kfree_skb(ch->trans_skb);\n\t\tch->trans_skb = NULL;\n\t}\n\tif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\n\t\tch->ccw[1].cmd_code = CCW_CMD_READ;\n\t\tch->ccw[1].flags = CCW_FLAG_SLI;\n\t\tch->ccw[1].count = 0;\n\t} else {\n\t\tch->ccw[1].cmd_code = CCW_CMD_WRITE;\n\t\tch->ccw[1].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[1].count = 0;\n\t}\n\tif (ctcm_checkalloc_buffer(ch)) {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\n\t\t\t\"%s(%s): %s trans_skb alloc delayed \"\n\t\t\t\"until first transfer\",\n\t\t\tCTCM_FUNTAIL, ch->id,\n\t\t\t(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ?\n\t\t\t\t\"RX\" : \"TX\");\n\t}\n\tch->ccw[0].cmd_code = CCW_CMD_PREPARE;\n\tch->ccw[0].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\n\tch->ccw[0].count = 0;\n\tch->ccw[0].cda = 0;\n\tch->ccw[2].cmd_code = CCW_CMD_NOOP;\t \n\tch->ccw[2].flags = CCW_FLAG_SLI;\n\tch->ccw[2].count = 0;\n\tch->ccw[2].cda = 0;\n\tmemcpy(&ch->ccw[3], &ch->ccw[0], sizeof(struct ccw1) * 3);\n\tch->ccw[4].cda = 0;\n\tch->ccw[4].flags &= ~CCW_FLAG_IDA;\n\n\tfsm_newstate(fi, CTC_STATE_STARTWAIT);\n\tfsm_addtimer(&ch->timer, 1000, CTC_EVENT_TIMER, ch);\n\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\trc = ccw_device_halt(ch->cdev, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\n\tif (rc != 0) {\n\t\tif (rc != -EBUSY)\n\t\t\tfsm_deltimer(&ch->timer);\n\t\tctcm_ccw_check_rc(ch, rc, \"initial HaltIO\");\n\t}\n}\n\n \nstatic void ctcm_chx_haltio(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tunsigned long saveflags = 0;\n\tint rc;\n\tint oldstate;\n\n\tfsm_deltimer(&ch->timer);\n\tif (IS_MPC(ch))\n\t\tfsm_deltimer(&ch->sweep_timer);\n\n\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\n\n\tif (event == CTC_EVENT_STOP)\t \n\t\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\t\t\t \n\toldstate = fsm_getstate(fi);\n\tfsm_newstate(fi, CTC_STATE_TERM);\n\trc = ccw_device_halt(ch->cdev, 0);\n\n\tif (event == CTC_EVENT_STOP)\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\n\t\t\t \n\n\tif (rc != 0 && rc != -EBUSY) {\n\t\tfsm_deltimer(&ch->timer);\n\t\tif (event != CTC_EVENT_STOP) {\n\t\t\tfsm_newstate(fi, oldstate);\n\t\t\tctcm_ccw_check_rc(ch, rc, (char *)__func__);\n\t\t}\n\t}\n}\n\n \nstatic void ctcm_chx_cleanup(fsm_instance *fi, int state,\n\t\tstruct channel *ch)\n{\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_NOTICE,\n\t\t\t\"%s(%s): %s[%d]\\n\",\n\t\t\tCTCM_FUNTAIL, dev->name, ch->id, state);\n\n\tfsm_deltimer(&ch->timer);\n\tif (IS_MPC(ch))\n\t\tfsm_deltimer(&ch->sweep_timer);\n\n\tfsm_newstate(fi, state);\n\tif (state == CTC_STATE_STOPPED && ch->trans_skb != NULL) {\n\t\tclear_normalized_cda(&ch->ccw[1]);\n\t\tdev_kfree_skb_any(ch->trans_skb);\n\t\tch->trans_skb = NULL;\n\t}\n\n\tch->th_seg = 0x00;\n\tch->th_seq_num = 0x00;\n\tif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\n\t\tskb_queue_purge(&ch->io_queue);\n\t\tfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\n\t} else {\n\t\tctcm_purge_skb_queue(&ch->io_queue);\n\t\tif (IS_MPC(ch))\n\t\t\tctcm_purge_skb_queue(&ch->sweep_queue);\n\t\tspin_lock(&ch->collect_lock);\n\t\tctcm_purge_skb_queue(&ch->collect_queue);\n\t\tch->collect_len = 0;\n\t\tspin_unlock(&ch->collect_lock);\n\t\tfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\n\t}\n}\n\n \nstatic void ctcm_chx_stopped(fsm_instance *fi, int event, void *arg)\n{\n\tctcm_chx_cleanup(fi, CTC_STATE_STOPPED, arg);\n}\n\n \nstatic void ctcm_chx_stop(fsm_instance *fi, int event, void *arg)\n{\n\tfsm_newstate(fi, CTC_STATE_STOPPED);\n}\n\n \nstatic void ctcm_chx_fail(fsm_instance *fi, int event, void *arg)\n{\n\tctcm_chx_cleanup(fi, CTC_STATE_NOTOP, arg);\n}\n\n \nstatic void ctcm_chx_setuperr(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\t \n\tif ((fsm_getstate(fi) == CTC_STATE_SETUPWAIT) &&\n\t    ((event == CTC_EVENT_UC_RCRESET) ||\n\t     (event == CTC_EVENT_UC_RSRESET))) {\n\t\tfsm_newstate(fi, CTC_STATE_STARTRETRY);\n\t\tfsm_deltimer(&ch->timer);\n\t\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\n\t\tif (!IS_MPC(ch) &&\n\t\t    (CHANNEL_DIRECTION(ch->flags) == CTCM_READ)) {\n\t\t\tint rc = ccw_device_halt(ch->cdev, 0);\n\t\t\tif (rc != 0)\n\t\t\t\tctcm_ccw_check_rc(ch, rc,\n\t\t\t\t\t\"HaltIO in chx_setuperr\");\n\t\t}\n\t\treturn;\n\t}\n\n\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_CRIT,\n\t\t\"%s(%s) : %s error during %s channel setup state=%s\\n\",\n\t\tCTCM_FUNTAIL, dev->name, ctc_ch_event_names[event],\n\t\t(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ? \"RX\" : \"TX\",\n\t\tfsm_getstate_str(fi));\n\n\tif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\n\t\tfsm_newstate(fi, CTC_STATE_RXERR);\n\t\tfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\n\t} else {\n\t\tfsm_newstate(fi, CTC_STATE_TXERR);\n\t\tfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\n\t}\n}\n\n \nstatic void ctcm_chx_restart(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tunsigned long saveflags = 0;\n\tint oldstate;\n\tint rc;\n\n\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\n\t\t\"%s: %s[%d] of %s\\n\",\n\t\t\tCTCM_FUNTAIL, ch->id, event, dev->name);\n\n\tfsm_deltimer(&ch->timer);\n\n\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\n\toldstate = fsm_getstate(fi);\n\tfsm_newstate(fi, CTC_STATE_STARTWAIT);\n\tif (event == CTC_EVENT_TIMER)\t \n\t\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\t\t\t \n\trc = ccw_device_halt(ch->cdev, 0);\n\tif (event == CTC_EVENT_TIMER)\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\n\tif (rc != 0) {\n\t\tif (rc != -EBUSY) {\n\t\t    fsm_deltimer(&ch->timer);\n\t\t    fsm_newstate(fi, oldstate);\n\t\t}\n\t\tctcm_ccw_check_rc(ch, rc, \"HaltIO in ctcm_chx_restart\");\n\t}\n}\n\n \nstatic void ctcm_chx_rxiniterr(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tif (event == CTC_EVENT_TIMER) {\n\t\tif (!IS_MPCDEV(dev))\n\t\t\t \n\t\t\tfsm_deltimer(&ch->timer);\n\t\tif (ch->retry++ < 3)\n\t\t\tctcm_chx_restart(fi, event, arg);\n\t\telse {\n\t\t\tfsm_newstate(fi, CTC_STATE_RXERR);\n\t\t\tfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\n\t\t}\n\t} else {\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): %s in %s\", CTCM_FUNTAIL, ch->id,\n\t\t\tctc_ch_event_names[event], fsm_getstate_str(fi));\n\n\t\tdev_warn(&dev->dev,\n\t\t\t\"Initialization failed with RX/TX init handshake \"\n\t\t\t\"error %s\\n\", ctc_ch_event_names[event]);\n\t}\n}\n\n \nstatic void ctcm_chx_rxinitfail(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): RX %s busy, init. fail\",\n\t\t\t\tCTCM_FUNTAIL, dev->name, ch->id);\n\tfsm_newstate(fi, CTC_STATE_RXERR);\n\tfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\n}\n\n \nstatic void ctcm_chx_rxdisc(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct channel *ch2;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\n\t\t\t\"%s: %s: remote disconnect - re-init ...\",\n\t\t\t\tCTCM_FUNTAIL, dev->name);\n\tfsm_deltimer(&ch->timer);\n\t \n\tfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\n\tfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\n\n\tfsm_newstate(fi, CTC_STATE_DTERM);\n\tch2 = priv->channel[CTCM_WRITE];\n\tfsm_newstate(ch2->fsm, CTC_STATE_DTERM);\n\n\tccw_device_halt(ch->cdev, 0);\n\tccw_device_halt(ch2->cdev, 0);\n}\n\n \nstatic void ctcm_chx_txiniterr(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tif (event == CTC_EVENT_TIMER) {\n\t\tfsm_deltimer(&ch->timer);\n\t\tif (ch->retry++ < 3)\n\t\t\tctcm_chx_restart(fi, event, arg);\n\t\telse {\n\t\t\tfsm_newstate(fi, CTC_STATE_TXERR);\n\t\t\tfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\n\t\t}\n\t} else {\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): %s in %s\", CTCM_FUNTAIL, ch->id,\n\t\t\tctc_ch_event_names[event], fsm_getstate_str(fi));\n\n\t\tdev_warn(&dev->dev,\n\t\t\t\"Initialization failed with RX/TX init handshake \"\n\t\t\t\"error %s\\n\", ctc_ch_event_names[event]);\n\t}\n}\n\n \nstatic void ctcm_chx_txretry(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct sk_buff *skb;\n\n\tCTCM_PR_DEBUG(\"Enter: %s: cp=%i ch=0x%p id=%s\\n\",\n\t\t\t__func__, smp_processor_id(), ch, ch->id);\n\n\tfsm_deltimer(&ch->timer);\n\tif (ch->retry++ > 3) {\n\t\tstruct mpc_group *gptr = priv->mpcg;\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_INFO,\n\t\t\t\t\"%s: %s: retries exceeded\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\tfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\n\t\t \n\t\tif (!(gptr && (fsm_getstate(gptr->fsm) != MPCG_STATE_READY)))\n\t\t\tctcm_chx_restart(fi, event, arg);\n\t\tgoto done;\n\t}\n\n\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\n\t\t\t\"%s : %s: retry %d\",\n\t\t\t\tCTCM_FUNTAIL, ch->id, ch->retry);\n\tskb = skb_peek(&ch->io_queue);\n\tif (skb) {\n\t\tint rc = 0;\n\t\tunsigned long saveflags = 0;\n\t\tclear_normalized_cda(&ch->ccw[4]);\n\t\tch->ccw[4].count = skb->len;\n\t\tif (set_normalized_cda(&ch->ccw[4], skb->data)) {\n\t\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_INFO,\n\t\t\t\t\"%s: %s: IDAL alloc failed\",\n\t\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\t\tfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\n\t\t\tctcm_chx_restart(fi, event, arg);\n\t\t\tgoto done;\n\t\t}\n\t\tfsm_addtimer(&ch->timer, 1000, CTC_EVENT_TIMER, ch);\n\t\tif (event == CTC_EVENT_TIMER)  \n\t\t\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\t\t\t \n\t\tif (do_debug_ccw)\n\t\t\tctcmpc_dumpit((char *)&ch->ccw[3],\n\t\t\t\t\tsizeof(struct ccw1) * 3);\n\n\t\trc = ccw_device_start(ch->cdev, &ch->ccw[3], 0, 0xff, 0);\n\t\tif (event == CTC_EVENT_TIMER)\n\t\t\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev),\n\t\t\t\t\tsaveflags);\n\t\tif (rc != 0) {\n\t\t\tfsm_deltimer(&ch->timer);\n\t\t\tctcm_ccw_check_rc(ch, rc, \"TX in chx_txretry\");\n\t\t\tctcm_purge_skb_queue(&ch->io_queue);\n\t\t}\n\t}\ndone:\n\treturn;\n}\n\n \nstatic void ctcm_chx_iofatal(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tint rd = CHANNEL_DIRECTION(ch->flags);\n\n\tfsm_deltimer(&ch->timer);\n\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\"%s: %s: %s unrecoverable channel error\",\n\t\t\tCTCM_FUNTAIL, ch->id, rd == CTCM_READ ? \"RX\" : \"TX\");\n\n\tif (IS_MPC(ch)) {\n\t\tpriv->stats.tx_dropped++;\n\t\tpriv->stats.tx_errors++;\n\t}\n\tif (rd == CTCM_READ) {\n\t\tfsm_newstate(fi, CTC_STATE_RXERR);\n\t\tfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\n\t} else {\n\t\tfsm_newstate(fi, CTC_STATE_TXERR);\n\t\tfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\n\t}\n}\n\n \nconst fsm_node ch_fsm[] = {\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_STOP,\t\tctcm_action_nop  },\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_START,\tctcm_chx_start  },\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_FINSTAT,\tctcm_action_nop  },\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_MC_FAIL,\tctcm_action_nop  },\n\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_STOP,\t\tctcm_chx_stop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_FINSTAT,\tctcm_action_nop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_MC_FAIL,\tctcm_action_nop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_MC_GOOD,\tctcm_chx_start  },\n\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_FINSTAT,\tctcm_chx_setmode  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_TIMER,\tctcm_chx_setuperr  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_TIMER,\tctcm_chx_setmode  },\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_FINSTAT,\tctcm_action_nop  },\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_FINSTAT,\tchx_firstio  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_TIMER,\tctcm_chx_setmode  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_FINSTAT,\tchx_rxidle  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_rxiniterr  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_rxiniterr  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_TIMER,\tctcm_chx_rxiniterr  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_ATTNBUSY,\tctcm_chx_rxinitfail  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_UC_ZERO,\tchx_firstio  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_FINSTAT,\tchx_rx  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_rxdisc  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_UC_ZERO,\tchx_rx  },\n\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_FINSTAT,\tctcm_chx_txidle  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_txiniterr  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_txiniterr  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_TIMER,\tctcm_chx_txiniterr  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_FINSTAT,\tchx_firstio  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_UC_RCRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_UC_RSRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_TERM,\tCTC_EVENT_STOP,\t\tctcm_action_nop  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_START,\tctcm_chx_restart  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_FINSTAT,\tctcm_chx_stopped  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_UC_RCRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_UC_RSRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_START,\tctcm_chx_restart  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_FINSTAT,\tctcm_chx_setmode  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_UC_RCRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_UC_RSRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_FINSTAT,\tchx_txdone  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_UC_RCRESET,\tctcm_chx_txretry  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_UC_RSRESET,\tctcm_chx_txretry  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_TIMER,\tctcm_chx_txretry  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_RXERR,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TXERR,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TXERR,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_RXERR,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n};\n\nint ch_fsm_len = ARRAY_SIZE(ch_fsm);\n\n \n\n \n\n \nstatic void ctcmpc_chx_txdone(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel\t\t*ch = arg;\n\tstruct net_device\t*dev = ch->netdev;\n\tstruct ctcm_priv\t*priv = dev->ml_priv;\n\tstruct mpc_group\t*grp = priv->mpcg;\n\tstruct sk_buff\t\t*skb;\n\tint\t\tfirst = 1;\n\tint\t\ti;\n\t__u32\t\tdata_space;\n\tunsigned long\tduration;\n\tstruct sk_buff\t*peekskb;\n\tint\t\trc;\n\tstruct th_header *header;\n\tstruct pdu\t*p_header;\n\tunsigned long done_stamp = jiffies;\n\n\tCTCM_PR_DEBUG(\"Enter %s: %s cp:%i\\n\",\n\t\t\t__func__, dev->name, smp_processor_id());\n\n\tduration = done_stamp - ch->prof.send_stamp;\n\tif (duration > ch->prof.tx_time)\n\t\tch->prof.tx_time = duration;\n\n\tif (ch->irb->scsw.cmd.count != 0)\n\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\n\t\t\t\"%s(%s): TX not complete, remaining %d bytes\",\n\t\t\t     CTCM_FUNTAIL, dev->name, ch->irb->scsw.cmd.count);\n\tfsm_deltimer(&ch->timer);\n\twhile ((skb = skb_dequeue(&ch->io_queue))) {\n\t\tpriv->stats.tx_packets++;\n\t\tpriv->stats.tx_bytes += skb->len - TH_HEADER_LENGTH;\n\t\tif (first) {\n\t\t\tpriv->stats.tx_bytes += 2;\n\t\t\tfirst = 0;\n\t\t}\n\t\trefcount_dec(&skb->users);\n\t\tdev_kfree_skb_irq(skb);\n\t}\n\tspin_lock(&ch->collect_lock);\n\tclear_normalized_cda(&ch->ccw[4]);\n\tif ((ch->collect_len <= 0) || (grp->in_sweep != 0)) {\n\t\tspin_unlock(&ch->collect_lock);\n\t\tfsm_newstate(fi, CTC_STATE_TXIDLE);\n\t\tgoto done;\n\t}\n\n\tif (ctcm_checkalloc_buffer(ch)) {\n\t\tspin_unlock(&ch->collect_lock);\n\t\tgoto done;\n\t}\n\tch->trans_skb->data = ch->trans_skb_data;\n\tskb_reset_tail_pointer(ch->trans_skb);\n\tch->trans_skb->len = 0;\n\tif (ch->prof.maxmulti < (ch->collect_len + TH_HEADER_LENGTH))\n\t\tch->prof.maxmulti = ch->collect_len + TH_HEADER_LENGTH;\n\tif (ch->prof.maxcqueue < skb_queue_len(&ch->collect_queue))\n\t\tch->prof.maxcqueue = skb_queue_len(&ch->collect_queue);\n\ti = 0;\n\tp_header = NULL;\n\tdata_space = grp->group_max_buflen - TH_HEADER_LENGTH;\n\n\tCTCM_PR_DBGDATA(\"%s: building trans_skb from collect_q\"\n\t\t       \" data_space:%04x\\n\",\n\t\t       __func__, data_space);\n\n\twhile ((skb = skb_dequeue(&ch->collect_queue))) {\n\t\tskb_put_data(ch->trans_skb, skb->data, skb->len);\n\t\tp_header = (struct pdu *)\n\t\t\t(skb_tail_pointer(ch->trans_skb) - skb->len);\n\t\tp_header->pdu_flag = 0x00;\n\t\tif (be16_to_cpu(skb->protocol) == ETH_P_SNAP)\n\t\t\tp_header->pdu_flag |= 0x60;\n\t\telse\n\t\t\tp_header->pdu_flag |= 0x20;\n\n\t\tCTCM_PR_DBGDATA(\"%s: trans_skb len:%04x \\n\",\n\t\t\t\t__func__, ch->trans_skb->len);\n\t\tCTCM_PR_DBGDATA(\"%s: pdu header and data for up\"\n\t\t\t\t\" to 32 bytes sent to vtam\\n\", __func__);\n\t\tCTCM_D3_DUMP((char *)p_header, min_t(int, skb->len, 32));\n\n\t\tch->collect_len -= skb->len;\n\t\tdata_space -= skb->len;\n\t\tpriv->stats.tx_packets++;\n\t\tpriv->stats.tx_bytes += skb->len;\n\t\trefcount_dec(&skb->users);\n\t\tdev_kfree_skb_any(skb);\n\t\tpeekskb = skb_peek(&ch->collect_queue);\n\t\tif (peekskb->len > data_space)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\t \n\tif (p_header)\n\t\tp_header->pdu_flag |= PDU_LAST;\t \n\n\theader = skb_push(ch->trans_skb, TH_HEADER_LENGTH);\n\tmemset(header, 0, TH_HEADER_LENGTH);\n\n\theader->th_ch_flag = TH_HAS_PDU;   \n\tch->th_seq_num++;\n\theader->th_seq_num = ch->th_seq_num;\n\n\tCTCM_PR_DBGDATA(\"%s: ToVTAM_th_seq= %08x\\n\" ,\n\t\t\t\t\t__func__, ch->th_seq_num);\n\n\tCTCM_PR_DBGDATA(\"%s: trans_skb len:%04x \\n\",\n\t\t       __func__, ch->trans_skb->len);\n\tCTCM_PR_DBGDATA(\"%s: up-to-50 bytes of trans_skb \"\n\t\t\t\"data to vtam from collect_q\\n\", __func__);\n\tCTCM_D3_DUMP((char *)ch->trans_skb->data,\n\t\t\t\tmin_t(int, ch->trans_skb->len, 50));\n\n\tspin_unlock(&ch->collect_lock);\n\tclear_normalized_cda(&ch->ccw[1]);\n\n\tCTCM_PR_DBGDATA(\"ccwcda=0x%p data=0x%p\\n\",\n\t\t\t(void *)(unsigned long)ch->ccw[1].cda,\n\t\t\tch->trans_skb->data);\n\tch->ccw[1].count = ch->max_bufsize;\n\n\tif (set_normalized_cda(&ch->ccw[1], ch->trans_skb->data)) {\n\t\tdev_kfree_skb_any(ch->trans_skb);\n\t\tch->trans_skb = NULL;\n\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ERROR,\n\t\t\t\"%s: %s: IDAL alloc failed\",\n\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\tfsm_event(priv->mpcg->fsm, MPCG_EVENT_INOP, dev);\n\t\treturn;\n\t}\n\n\tCTCM_PR_DBGDATA(\"ccwcda=0x%p data=0x%p\\n\",\n\t\t\t(void *)(unsigned long)ch->ccw[1].cda,\n\t\t\tch->trans_skb->data);\n\n\tch->ccw[1].count = ch->trans_skb->len;\n\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\n\tch->prof.send_stamp = jiffies;\n\tif (do_debug_ccw)\n\t\tctcmpc_dumpit((char *)&ch->ccw[0], sizeof(struct ccw1) * 3);\n\trc = ccw_device_start(ch->cdev, &ch->ccw[0], 0, 0xff, 0);\n\tch->prof.doios_multi++;\n\tif (rc != 0) {\n\t\tpriv->stats.tx_dropped += i;\n\t\tpriv->stats.tx_errors += i;\n\t\tfsm_deltimer(&ch->timer);\n\t\tctcm_ccw_check_rc(ch, rc, \"chained TX\");\n\t}\ndone:\n\tctcm_clear_busy(dev);\n\treturn;\n}\n\n \nstatic void ctcmpc_chx_rx(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel\t\t*ch = arg;\n\tstruct net_device\t*dev = ch->netdev;\n\tstruct ctcm_priv\t*priv = dev->ml_priv;\n\tstruct mpc_group\t*grp = priv->mpcg;\n\tstruct sk_buff\t\t*skb = ch->trans_skb;\n\tstruct sk_buff\t\t*new_skb;\n\tunsigned long\t\tsaveflags = 0;\t \n\tint len\t= ch->max_bufsize - ch->irb->scsw.cmd.count;\n\n\tCTCM_PR_DEBUG(\"%s: %s: cp:%i %s maxbuf : %04x, len: %04x\\n\",\n\t\t\tCTCM_FUNTAIL, dev->name, smp_processor_id(),\n\t\t\t\tch->id, ch->max_bufsize, len);\n\tfsm_deltimer(&ch->timer);\n\n\tif (skb == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): TRANS_SKB = NULL\",\n\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\tgoto again;\n\t}\n\n\tif (len < TH_HEADER_LENGTH) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): packet length %d too short\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name, len);\n\t\tpriv->stats.rx_dropped++;\n\t\tpriv->stats.rx_length_errors++;\n\t} else {\n\t\t \n\t\t__u32\tblock_len = len;\n\t\tlen = TH_HEADER_LENGTH + XID2_LENGTH + 4;\n\t\tnew_skb = __dev_alloc_skb(ch->max_bufsize, GFP_ATOMIC);\n\n\t\tif (new_skb == NULL) {\n\t\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): skb allocation failed\",\n\t\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\t\tfsm_event(priv->mpcg->fsm, MPCG_EVENT_INOP, dev);\n\t\t\tgoto again;\n\t\t}\n\t\tswitch (fsm_getstate(grp->fsm)) {\n\t\tcase MPCG_STATE_RESET:\n\t\tcase MPCG_STATE_INOP:\n\t\t\tdev_kfree_skb_any(new_skb);\n\t\t\tbreak;\n\t\tcase MPCG_STATE_FLOWC:\n\t\tcase MPCG_STATE_READY:\n\t\t\tskb_put_data(new_skb, skb->data, block_len);\n\t\t\tskb_queue_tail(&ch->io_queue, new_skb);\n\t\t\ttasklet_schedule(&ch->ch_tasklet);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tskb_put_data(new_skb, skb->data, len);\n\t\t\tskb_queue_tail(&ch->io_queue, new_skb);\n\t\t\ttasklet_hi_schedule(&ch->ch_tasklet);\n\t\t\tbreak;\n\t\t}\n\t}\n\nagain:\n\tswitch (fsm_getstate(grp->fsm)) {\n\tint rc, dolock;\n\tcase MPCG_STATE_FLOWC:\n\tcase MPCG_STATE_READY:\n\t\tif (ctcm_checkalloc_buffer(ch))\n\t\t\tbreak;\n\t\tch->trans_skb->data = ch->trans_skb_data;\n\t\tskb_reset_tail_pointer(ch->trans_skb);\n\t\tch->trans_skb->len = 0;\n\t\tch->ccw[1].count = ch->max_bufsize;\n\t\tif (do_debug_ccw)\n\t\t\tctcmpc_dumpit((char *)&ch->ccw[0],\n\t\t\t\t      sizeof(struct ccw1) * 3);\n\t\tdolock = !in_hardirq();\n\t\tif (dolock)\n\t\t\tspin_lock_irqsave(\n\t\t\t\tget_ccwdev_lock(ch->cdev), saveflags);\n\t\trc = ccw_device_start(ch->cdev, &ch->ccw[0], 0, 0xff, 0);\n\t\tif (dolock)  \n\t\t\tspin_unlock_irqrestore(\n\t\t\t\tget_ccwdev_lock(ch->cdev), saveflags);\n\t\tif (rc != 0)\n\t\t\tctcm_ccw_check_rc(ch, rc, \"normal RX\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tCTCM_PR_DEBUG(\"Exit %s: %s, ch=0x%p, id=%s\\n\",\n\t\t\t__func__, dev->name, ch, ch->id);\n\n}\n\n \nstatic void ctcmpc_chx_firstio(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel\t\t*ch = arg;\n\tstruct net_device\t*dev = ch->netdev;\n\tstruct ctcm_priv\t*priv = dev->ml_priv;\n\tstruct mpc_group\t*gptr = priv->mpcg;\n\n\tCTCM_PR_DEBUG(\"Enter %s: id=%s, ch=0x%p\\n\",\n\t\t\t\t__func__, ch->id, ch);\n\n\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_INFO,\n\t\t\t\"%s: %s: chstate:%i, grpstate:%i, prot:%i\\n\",\n\t\t\tCTCM_FUNTAIL, ch->id, fsm_getstate(fi),\n\t\t\tfsm_getstate(gptr->fsm), ch->protocol);\n\n\tif (fsm_getstate(fi) == CTC_STATE_TXIDLE)\n\t\tMPC_DBF_DEV_NAME(TRACE, dev, \"remote side issued READ? \");\n\n\tfsm_deltimer(&ch->timer);\n\tif (ctcm_checkalloc_buffer(ch))\n\t\t\t\tgoto done;\n\n\tswitch (fsm_getstate(fi)) {\n\tcase CTC_STATE_STARTRETRY:\n\tcase CTC_STATE_SETUPWAIT:\n\t\tif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\n\t\t\tctcmpc_chx_rxidle(fi, event, arg);\n\t\t} else {\n\t\t\tfsm_newstate(fi, CTC_STATE_TXIDLE);\n\t\t\tfsm_event(priv->fsm, DEV_EVENT_TXUP, dev);\n\t\t}\n\t\t\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfsm_newstate(fi, (CHANNEL_DIRECTION(ch->flags) == CTCM_READ)\n\t\t     ? CTC_STATE_RXINIT : CTC_STATE_TXINIT);\n\ndone:\n\tCTCM_PR_DEBUG(\"Exit %s: id=%s, ch=0x%p\\n\",\n\t\t\t\t__func__, ch->id, ch);\n\treturn;\n}\n\n \nvoid ctcmpc_chx_rxidle(fsm_instance *fi, int event, void *arg)\n{\n\tstruct channel *ch = arg;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv  *priv = dev->ml_priv;\n\tstruct mpc_group  *grp = priv->mpcg;\n\tint rc;\n\tunsigned long saveflags = 0;\t \n\n\tfsm_deltimer(&ch->timer);\n\tCTCM_PR_DEBUG(\"%s: %s: %s: cp:%i, chstate:%i grpstate:%i\\n\",\n\t\t\t__func__, ch->id, dev->name, smp_processor_id(),\n\t\t\t\tfsm_getstate(fi), fsm_getstate(grp->fsm));\n\n\tfsm_newstate(fi, CTC_STATE_RXIDLE);\n\t \n\n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_FLOWC:\n\tcase MPCG_STATE_READY:\n\t\tif (ctcm_checkalloc_buffer(ch))\n\t\t\t\tgoto done;\n\t\tch->trans_skb->data = ch->trans_skb_data;\n\t\tskb_reset_tail_pointer(ch->trans_skb);\n\t\tch->trans_skb->len = 0;\n\t\tch->ccw[1].count = ch->max_bufsize;\n\t\tCTCM_CCW_DUMP((char *)&ch->ccw[0], sizeof(struct ccw1) * 3);\n\t\tif (event == CTC_EVENT_START)\n\t\t\t \n\t\t\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\t\trc = ccw_device_start(ch->cdev, &ch->ccw[0], 0, 0xff, 0);\n\t\tif (event == CTC_EVENT_START)\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\tget_ccwdev_lock(ch->cdev), saveflags);\n\t\tif (rc != 0) {\n\t\t\tfsm_newstate(fi, CTC_STATE_RXINIT);\n\t\t\tctcm_ccw_check_rc(ch, rc, \"initial RX\");\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfsm_event(priv->fsm, DEV_EVENT_RXUP, dev);\ndone:\n\treturn;\n}\n\n \nstatic void ctcmpc_chx_attn(fsm_instance *fsm, int event, void *arg)\n{\n\tstruct channel\t  *ch     = arg;\n\tstruct net_device *dev    = ch->netdev;\n\tstruct ctcm_priv  *priv   = dev->ml_priv;\n\tstruct mpc_group  *grp = priv->mpcg;\n\n\tCTCM_PR_DEBUG(\"%s(%s): %s(ch=0x%p), cp=%i, ChStat:%s, GrpStat:%s\\n\",\n\t\t__func__, dev->name, ch->id, ch, smp_processor_id(),\n\t\t\tfsm_getstate_str(ch->fsm), fsm_getstate_str(grp->fsm));\n\n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_XID2INITW:\n\t\t \n\t\tif (!ch->in_mpcgroup)\n\t\t\tbreak;\n\t\tif (fsm_getstate(ch->fsm) ==  CH_XID0_PENDING) {\n\t\t\tfsm_deltimer(&grp->timer);\n\t\t\tfsm_addtimer(&grp->timer,\n\t\t\t\tMPC_XID_TIMEOUT_VALUE,\n\t\t\t\tMPCG_EVENT_TIMER, dev);\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_XID0DO, ch);\n\n\t\t} else if (fsm_getstate(ch->fsm) < CH_XID7_PENDING1)\n\t\t\t \n\t\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING1);\n\t\tbreak;\n\tcase MPCG_STATE_XID2INITX:\n\tcase MPCG_STATE_XID0IOWAIT:\n\tcase MPCG_STATE_XID0IOWAIX:\n\t\t \n\t\tif (fsm_getstate(ch->fsm) < CH_XID7_PENDING1)\n\t\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING1);\n\t\tbreak;\n\tcase MPCG_STATE_XID7INITW:\n\tcase MPCG_STATE_XID7INITX:\n\tcase MPCG_STATE_XID7INITI:\n\tcase MPCG_STATE_XID7INITZ:\n\t\tswitch (fsm_getstate(ch->fsm)) {\n\t\tcase CH_XID7_PENDING:\n\t\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING1);\n\t\t\tbreak;\n\t\tcase CH_XID7_PENDING2:\n\t\t\tfsm_newstate(ch->fsm, CH_XID7_PENDING3);\n\t\t\tbreak;\n\t\t}\n\t\tfsm_event(grp->fsm, MPCG_EVENT_XID7DONE, dev);\n\t\tbreak;\n\t}\n\n\treturn;\n}\n\n \nstatic void ctcmpc_chx_attnbusy(fsm_instance *fsm, int event, void *arg)\n{\n\tstruct channel\t  *ch     = arg;\n\tstruct net_device *dev    = ch->netdev;\n\tstruct ctcm_priv  *priv   = dev->ml_priv;\n\tstruct mpc_group  *grp    = priv->mpcg;\n\n\tCTCM_PR_DEBUG(\"%s(%s): %s\\n  ChState:%s GrpState:%s\\n\",\n\t\t\t__func__, dev->name, ch->id,\n\t\t\tfsm_getstate_str(ch->fsm), fsm_getstate_str(grp->fsm));\n\n\tfsm_deltimer(&ch->timer);\n\n\tswitch (fsm_getstate(grp->fsm)) {\n\tcase MPCG_STATE_XID0IOWAIT:\n\t\t \n\t\t \n\t\t \n\t\tgrp->changed_side = 1;\n\t\tfsm_newstate(grp->fsm, MPCG_STATE_XID2INITW);\n\t\tbreak;\n\tcase MPCG_STATE_XID2INITW:\n\t\tif (grp->changed_side == 1) {\n\t\t\tgrp->changed_side = 2;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\t \n\t\t \n\t\tif (grp->estconnfunc)\n\t\t\t\tgoto done;\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (fsm_getstate(ch->fsm) == CH_XID0_INPROGRESS) {\n\t\t\tfsm_newstate(ch->fsm, CH_XID0_PENDING) ;\n\t\t\tfsm_deltimer(&grp->timer);\n\t\t\tgoto done;\n\t\t}\n\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\tgoto done;\n\tcase MPCG_STATE_XID2INITX:\n\t\t \n\t\tif (grp->changed_side == 1) {\n\t\t\tgrp->changed_side = 2;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase MPCG_STATE_XID0IOWAIX:\n\tcase MPCG_STATE_XID7INITW:\n\tcase MPCG_STATE_XID7INITX:\n\tcase MPCG_STATE_XID7INITI:\n\tcase MPCG_STATE_XID7INITZ:\n\tdefault:\n\t\t \n\t\t \n\t\t \n\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\t\t\tgoto done;\n\t}\n\n\tif (grp->changed_side == 1) {\n\t\tfsm_deltimer(&grp->timer);\n\t\tfsm_addtimer(&grp->timer, MPC_XID_TIMEOUT_VALUE,\n\t\t\t     MPCG_EVENT_TIMER, dev);\n\t}\n\tif (ch->in_mpcgroup)\n\t\tfsm_event(grp->fsm, MPCG_EVENT_XID0DO, ch);\n\telse\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): channel %s not added to group\",\n\t\t\t\tCTCM_FUNTAIL, dev->name, ch->id);\n\ndone:\n\treturn;\n}\n\n \nstatic void ctcmpc_chx_resend(fsm_instance *fsm, int event, void *arg)\n{\n\tstruct channel\t   *ch\t   = arg;\n\tstruct net_device  *dev    = ch->netdev;\n\tstruct ctcm_priv   *priv   = dev->ml_priv;\n\tstruct mpc_group   *grp    = priv->mpcg;\n\n\tfsm_event(grp->fsm, MPCG_EVENT_XID0DO, ch);\n\treturn;\n}\n\n \nstatic void ctcmpc_chx_send_sweep(fsm_instance *fsm, int event, void *arg)\n{\n\tstruct channel *ach = arg;\n\tstruct net_device *dev = ach->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct mpc_group *grp = priv->mpcg;\n\tstruct channel *wch = priv->channel[CTCM_WRITE];\n\tstruct channel *rch = priv->channel[CTCM_READ];\n\tstruct sk_buff *skb;\n\tstruct th_sweep *header;\n\tint rc = 0;\n\tunsigned long saveflags = 0;\n\n\tCTCM_PR_DEBUG(\"ctcmpc enter: %s(): cp=%i ch=0x%p id=%s\\n\",\n\t\t\t__func__, smp_processor_id(), ach, ach->id);\n\n\tif (grp->in_sweep == 0)\n\t\t\t\tgoto done;\n\n\tCTCM_PR_DBGDATA(\"%s: 1: ToVTAM_th_seq= %08x\\n\" ,\n\t\t\t\t__func__, wch->th_seq_num);\n\tCTCM_PR_DBGDATA(\"%s: 1: FromVTAM_th_seq= %08x\\n\" ,\n\t\t\t\t__func__, rch->th_seq_num);\n\n\tif (fsm_getstate(wch->fsm) != CTC_STATE_TXIDLE) {\n\t\t \n\t\tfsm_addtimer(&wch->sweep_timer,\n\t\t\t200, CTC_EVENT_RSWEEP_TIMER, wch);\n\t\tgoto done;\n\t}\n\n\tskb = skb_dequeue(&wch->sweep_queue);\n\tif (!skb)\n\t\t\t\tgoto done;\n\n\tif (set_normalized_cda(&wch->ccw[4], skb->data)) {\n\t\tgrp->in_sweep = 0;\n\t\tctcm_clear_busy_do(dev);\n\t\tdev_kfree_skb_any(skb);\n\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\tgoto done;\n\t} else {\n\t\trefcount_inc(&skb->users);\n\t\tskb_queue_tail(&wch->io_queue, skb);\n\t}\n\n\t \n\twch->ccw[4].count = skb->len;\n\n\theader = (struct th_sweep *)skb->data;\n\tswitch (header->th.th_ch_flag) {\n\tcase TH_SWEEP_REQ:\n\t\tgrp->sweep_req_pend_num--;\n\t\tbreak;\n\tcase TH_SWEEP_RESP:\n\t\tgrp->sweep_rsp_pend_num--;\n\t\tbreak;\n\t}\n\n\theader->sw.th_last_seq = wch->th_seq_num;\n\n\tCTCM_CCW_DUMP((char *)&wch->ccw[3], sizeof(struct ccw1) * 3);\n\tCTCM_PR_DBGDATA(\"%s: sweep packet\\n\", __func__);\n\tCTCM_D3_DUMP((char *)header, TH_SWEEP_LENGTH);\n\n\tfsm_addtimer(&wch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, wch);\n\tfsm_newstate(wch->fsm, CTC_STATE_TX);\n\n\tspin_lock_irqsave(get_ccwdev_lock(wch->cdev), saveflags);\n\twch->prof.send_stamp = jiffies;\n\trc = ccw_device_start(wch->cdev, &wch->ccw[3], 0, 0xff, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(wch->cdev), saveflags);\n\n\tif ((grp->sweep_req_pend_num == 0) &&\n\t   (grp->sweep_rsp_pend_num == 0)) {\n\t\tgrp->in_sweep = 0;\n\t\trch->th_seq_num = 0x00;\n\t\twch->th_seq_num = 0x00;\n\t\tctcm_clear_busy_do(dev);\n\t}\n\n\tCTCM_PR_DBGDATA(\"%s: To-/From-VTAM_th_seq = %08x/%08x\\n\" ,\n\t\t\t__func__, wch->th_seq_num, rch->th_seq_num);\n\n\tif (rc != 0)\n\t\tctcm_ccw_check_rc(wch, rc, \"send sweep\");\n\ndone:\n\treturn;\n}\n\n\n \n\nconst fsm_node ctcmpc_ch_fsm[] = {\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_STOP,\t\tctcm_action_nop  },\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_START,\tctcm_chx_start  },\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_FINSTAT,\tctcm_action_nop  },\n\t{ CTC_STATE_STOPPED,\tCTC_EVENT_MC_FAIL,\tctcm_action_nop  },\n\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_STOP,\t\tctcm_chx_stop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_FINSTAT,\tctcm_action_nop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_MC_FAIL,\tctcm_action_nop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_MC_GOOD,\tctcm_chx_start  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_stop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_stop  },\n\t{ CTC_STATE_NOTOP,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_FINSTAT,\tctcm_chx_setmode  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_TIMER,\tctcm_chx_setuperr  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_STARTWAIT,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_TIMER,\tctcm_chx_setmode  },\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_FINSTAT,\tctcm_chx_setmode  },\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_STARTRETRY,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_firstio  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_TIMER,\tctcm_chx_setmode  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_SETUPWAIT,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_rxidle  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_rxiniterr  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_rxiniterr  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_TIMER,\tctcm_chx_rxiniterr  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_ATTNBUSY,\tctcm_chx_rxinitfail  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_UC_ZERO,\tctcmpc_chx_firstio  },\n\t{ CTC_STATE_RXINIT,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\n\t{ CH_XID0_PENDING,\tCTC_EVENT_FINSTAT,\tctcm_action_nop  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_ATTN,\t\tctcmpc_chx_attn  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID0_PENDING,\tCTC_EVENT_ATTNBUSY,\tctcm_chx_iofatal  },\n\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_rx  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_ATTN,\t\tctcmpc_chx_attn  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_UC_ZERO,\tctcmpc_chx_rx  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_ATTNBUSY,\tctcmpc_chx_attnbusy  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_TIMER,\tctcmpc_chx_resend  },\n\t{ CH_XID0_INPROGRESS,\tCTC_EVENT_IO_EBUSY,\tctcm_chx_fail  },\n\n\t{ CH_XID7_PENDING,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_ATTN,\t\tctcmpc_chx_attn  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_UC_ZERO,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_ATTNBUSY,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_TIMER,\tctcmpc_chx_resend  },\n\t{ CH_XID7_PENDING,\tCTC_EVENT_IO_EBUSY,\tctcm_chx_fail  },\n\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_ATTN,\t\tctcmpc_chx_attn  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_UC_ZERO,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_ATTNBUSY,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_TIMER,\tctcmpc_chx_resend  },\n\t{ CH_XID7_PENDING1,\tCTC_EVENT_IO_EBUSY,\tctcm_chx_fail  },\n\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_ATTN,\t\tctcmpc_chx_attn  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_UC_ZERO,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_ATTNBUSY,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_TIMER,\tctcmpc_chx_resend  },\n\t{ CH_XID7_PENDING2,\tCTC_EVENT_IO_EBUSY,\tctcm_chx_fail  },\n\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_ATTN,\t\tctcmpc_chx_attn  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_UC_ZERO,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_ATTNBUSY,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_TIMER,\tctcmpc_chx_resend  },\n\t{ CH_XID7_PENDING3,\tCTC_EVENT_IO_EBUSY,\tctcm_chx_fail  },\n\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_ATTN,\t\tctcmpc_chx_attn  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_UC_ZERO,\tctcmpc_chx_rx  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_setuperr  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_ATTNBUSY,\tctcm_chx_iofatal  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_TIMER,\tctcmpc_chx_resend  },\n\t{ CH_XID7_PENDING4,\tCTC_EVENT_IO_EBUSY,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_rx  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_rxdisc  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_fail  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_RXIDLE,\tCTC_EVENT_UC_ZERO,\tctcmpc_chx_rx  },\n\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_FINSTAT,\tctcm_chx_txidle  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_txiniterr  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_txiniterr  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_TIMER,\tctcm_chx_txiniterr  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_TXINIT,\tCTC_EVENT_RSWEEP_TIMER,\tctcmpc_chx_send_sweep },\n\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_FINSTAT,\tctcmpc_chx_firstio  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_UC_RCRESET,\tctcm_chx_fail  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_UC_RSRESET,\tctcm_chx_fail  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_TXIDLE,\tCTC_EVENT_RSWEEP_TIMER,\tctcmpc_chx_send_sweep },\n\n\t{ CTC_STATE_TERM,\tCTC_EVENT_STOP,\t\tctcm_action_nop  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_START,\tctcm_chx_restart  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_FINSTAT,\tctcm_chx_stopped  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_UC_RCRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_UC_RSRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_IO_EBUSY,\tctcm_chx_fail  },\n\t{ CTC_STATE_TERM,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_START,\tctcm_chx_restart  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_FINSTAT,\tctcm_chx_setmode  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_UC_RCRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_UC_RSRESET,\tctcm_action_nop  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_DTERM,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_START,\tctcm_action_nop  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_FINSTAT,\tctcmpc_chx_txdone  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_UC_RCRESET,\tctcm_chx_fail  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_UC_RSRESET,\tctcm_chx_fail  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_TIMER,\tctcm_chx_txretry  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_RSWEEP_TIMER,\tctcmpc_chx_send_sweep },\n\t{ CTC_STATE_TX,\t\tCTC_EVENT_IO_EBUSY,\tctcm_chx_fail  },\n\n\t{ CTC_STATE_RXERR,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TXERR,\tCTC_EVENT_STOP,\t\tctcm_chx_haltio  },\n\t{ CTC_STATE_TXERR,\tCTC_EVENT_IO_ENODEV,\tctcm_chx_iofatal  },\n\t{ CTC_STATE_TXERR,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n\t{ CTC_STATE_RXERR,\tCTC_EVENT_MC_FAIL,\tctcm_chx_fail  },\n};\n\nint mpc_ch_fsm_len = ARRAY_SIZE(ctcmpc_ch_fsm);\n\n \n\n \nstatic void dev_action_start(fsm_instance *fi, int event, void *arg)\n{\n\tstruct net_device *dev = arg;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tint direction;\n\n\tCTCMY_DBF_DEV_NAME(SETUP, dev, \"\");\n\n\tfsm_deltimer(&priv->restart_timer);\n\tfsm_newstate(fi, DEV_STATE_STARTWAIT_RXTX);\n\tif (IS_MPC(priv))\n\t\tpriv->mpcg->channels_terminating = 0;\n\tfor (direction = CTCM_READ; direction <= CTCM_WRITE; direction++) {\n\t\tstruct channel *ch = priv->channel[direction];\n\t\tfsm_event(ch->fsm, CTC_EVENT_START, ch);\n\t}\n}\n\n \nstatic void dev_action_stop(fsm_instance *fi, int event, void *arg)\n{\n\tint direction;\n\tstruct net_device *dev = arg;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCMY_DBF_DEV_NAME(SETUP, dev, \"\");\n\n\tfsm_newstate(fi, DEV_STATE_STOPWAIT_RXTX);\n\tfor (direction = CTCM_READ; direction <= CTCM_WRITE; direction++) {\n\t\tstruct channel *ch = priv->channel[direction];\n\t\tfsm_event(ch->fsm, CTC_EVENT_STOP, ch);\n\t\tch->th_seq_num = 0x00;\n\t\tCTCM_PR_DEBUG(\"%s: CH_th_seq= %08x\\n\",\n\t\t\t\t__func__, ch->th_seq_num);\n\t}\n\tif (IS_MPC(priv))\n\t\tfsm_newstate(priv->mpcg->fsm, MPCG_STATE_RESET);\n}\n\nstatic void dev_action_restart(fsm_instance *fi, int event, void *arg)\n{\n\tint restart_timer;\n\tstruct net_device *dev = arg;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCMY_DBF_DEV_NAME(TRACE, dev, \"\");\n\n\tif (IS_MPC(priv)) {\n\t\trestart_timer = CTCM_TIME_1_SEC;\n\t} else {\n\t\trestart_timer = CTCM_TIME_5_SEC;\n\t}\n\tdev_info(&dev->dev, \"Restarting device\\n\");\n\n\tdev_action_stop(fi, event, arg);\n\tfsm_event(priv->fsm, DEV_EVENT_STOP, dev);\n\tif (IS_MPC(priv))\n\t\tfsm_newstate(priv->mpcg->fsm, MPCG_STATE_RESET);\n\n\t \n\t \n\t \n\tfsm_addtimer(&priv->restart_timer, restart_timer,\n\t\t\tDEV_EVENT_START, dev);\n}\n\n \nstatic void dev_action_chup(fsm_instance *fi, int event, void *arg)\n{\n\tstruct net_device *dev = arg;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tint dev_stat = fsm_getstate(fi);\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_NOTICE,\n\t\t\t\"%s(%s): priv = %p [%d,%d]\\n \",\tCTCM_FUNTAIL,\n\t\t\t\tdev->name, dev->ml_priv, dev_stat, event);\n\n\tswitch (fsm_getstate(fi)) {\n\tcase DEV_STATE_STARTWAIT_RXTX:\n\t\tif (event == DEV_EVENT_RXUP)\n\t\t\tfsm_newstate(fi, DEV_STATE_STARTWAIT_TX);\n\t\telse\n\t\t\tfsm_newstate(fi, DEV_STATE_STARTWAIT_RX);\n\t\tbreak;\n\tcase DEV_STATE_STARTWAIT_RX:\n\t\tif (event == DEV_EVENT_RXUP) {\n\t\t\tfsm_newstate(fi, DEV_STATE_RUNNING);\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t\"Connected with remote side\\n\");\n\t\t\tctcm_clear_busy(dev);\n\t\t}\n\t\tbreak;\n\tcase DEV_STATE_STARTWAIT_TX:\n\t\tif (event == DEV_EVENT_TXUP) {\n\t\t\tfsm_newstate(fi, DEV_STATE_RUNNING);\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t\"Connected with remote side\\n\");\n\t\t\tctcm_clear_busy(dev);\n\t\t}\n\t\tbreak;\n\tcase DEV_STATE_STOPWAIT_TX:\n\t\tif (event == DEV_EVENT_RXUP)\n\t\t\tfsm_newstate(fi, DEV_STATE_STOPWAIT_RXTX);\n\t\tbreak;\n\tcase DEV_STATE_STOPWAIT_RX:\n\t\tif (event == DEV_EVENT_TXUP)\n\t\t\tfsm_newstate(fi, DEV_STATE_STOPWAIT_RXTX);\n\t\tbreak;\n\t}\n\n\tif (IS_MPC(priv)) {\n\t\tif (event == DEV_EVENT_RXUP)\n\t\t\tmpc_channel_action(priv->channel[CTCM_READ],\n\t\t\t\tCTCM_READ, MPC_CHANNEL_ADD);\n\t\telse\n\t\t\tmpc_channel_action(priv->channel[CTCM_WRITE],\n\t\t\t\tCTCM_WRITE, MPC_CHANNEL_ADD);\n\t}\n}\n\n \nstatic void dev_action_chdown(fsm_instance *fi, int event, void *arg)\n{\n\n\tstruct net_device *dev = arg;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCMY_DBF_DEV_NAME(SETUP, dev, \"\");\n\n\tswitch (fsm_getstate(fi)) {\n\tcase DEV_STATE_RUNNING:\n\t\tif (event == DEV_EVENT_TXDOWN)\n\t\t\tfsm_newstate(fi, DEV_STATE_STARTWAIT_TX);\n\t\telse\n\t\t\tfsm_newstate(fi, DEV_STATE_STARTWAIT_RX);\n\t\tbreak;\n\tcase DEV_STATE_STARTWAIT_RX:\n\t\tif (event == DEV_EVENT_TXDOWN)\n\t\t\tfsm_newstate(fi, DEV_STATE_STARTWAIT_RXTX);\n\t\tbreak;\n\tcase DEV_STATE_STARTWAIT_TX:\n\t\tif (event == DEV_EVENT_RXDOWN)\n\t\t\tfsm_newstate(fi, DEV_STATE_STARTWAIT_RXTX);\n\t\tbreak;\n\tcase DEV_STATE_STOPWAIT_RXTX:\n\t\tif (event == DEV_EVENT_TXDOWN)\n\t\t\tfsm_newstate(fi, DEV_STATE_STOPWAIT_RX);\n\t\telse\n\t\t\tfsm_newstate(fi, DEV_STATE_STOPWAIT_TX);\n\t\tbreak;\n\tcase DEV_STATE_STOPWAIT_RX:\n\t\tif (event == DEV_EVENT_RXDOWN)\n\t\t\tfsm_newstate(fi, DEV_STATE_STOPPED);\n\t\tbreak;\n\tcase DEV_STATE_STOPWAIT_TX:\n\t\tif (event == DEV_EVENT_TXDOWN)\n\t\t\tfsm_newstate(fi, DEV_STATE_STOPPED);\n\t\tbreak;\n\t}\n\tif (IS_MPC(priv)) {\n\t\tif (event == DEV_EVENT_RXDOWN)\n\t\t\tmpc_channel_action(priv->channel[CTCM_READ],\n\t\t\t\tCTCM_READ, MPC_CHANNEL_REMOVE);\n\t\telse\n\t\t\tmpc_channel_action(priv->channel[CTCM_WRITE],\n\t\t\t\tCTCM_WRITE, MPC_CHANNEL_REMOVE);\n\t}\n}\n\nconst fsm_node dev_fsm[] = {\n\t{ DEV_STATE_STOPPED,        DEV_EVENT_START,   dev_action_start   },\n\t{ DEV_STATE_STOPWAIT_RXTX,  DEV_EVENT_START,   dev_action_start   },\n\t{ DEV_STATE_STOPWAIT_RXTX,  DEV_EVENT_RXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_STOPWAIT_RXTX,  DEV_EVENT_TXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_STOPWAIT_RXTX,  DEV_EVENT_RESTART, dev_action_restart },\n\t{ DEV_STATE_STOPWAIT_RX,    DEV_EVENT_START,   dev_action_start   },\n\t{ DEV_STATE_STOPWAIT_RX,    DEV_EVENT_RXUP,    dev_action_chup    },\n\t{ DEV_STATE_STOPWAIT_RX,    DEV_EVENT_TXUP,    dev_action_chup    },\n\t{ DEV_STATE_STOPWAIT_RX,    DEV_EVENT_RXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_STOPWAIT_RX,    DEV_EVENT_RESTART, dev_action_restart },\n\t{ DEV_STATE_STOPWAIT_TX,    DEV_EVENT_START,   dev_action_start   },\n\t{ DEV_STATE_STOPWAIT_TX,    DEV_EVENT_RXUP,    dev_action_chup    },\n\t{ DEV_STATE_STOPWAIT_TX,    DEV_EVENT_TXUP,    dev_action_chup    },\n\t{ DEV_STATE_STOPWAIT_TX,    DEV_EVENT_TXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_STOPWAIT_TX,    DEV_EVENT_RESTART, dev_action_restart },\n\t{ DEV_STATE_STARTWAIT_RXTX, DEV_EVENT_STOP,    dev_action_stop    },\n\t{ DEV_STATE_STARTWAIT_RXTX, DEV_EVENT_RXUP,    dev_action_chup    },\n\t{ DEV_STATE_STARTWAIT_RXTX, DEV_EVENT_TXUP,    dev_action_chup    },\n\t{ DEV_STATE_STARTWAIT_RXTX, DEV_EVENT_RXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_STARTWAIT_RXTX, DEV_EVENT_TXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_STARTWAIT_RXTX, DEV_EVENT_RESTART, dev_action_restart },\n\t{ DEV_STATE_STARTWAIT_TX,   DEV_EVENT_STOP,    dev_action_stop    },\n\t{ DEV_STATE_STARTWAIT_TX,   DEV_EVENT_RXUP,    dev_action_chup    },\n\t{ DEV_STATE_STARTWAIT_TX,   DEV_EVENT_TXUP,    dev_action_chup    },\n\t{ DEV_STATE_STARTWAIT_TX,   DEV_EVENT_RXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_STARTWAIT_TX,   DEV_EVENT_RESTART, dev_action_restart },\n\t{ DEV_STATE_STARTWAIT_RX,   DEV_EVENT_STOP,    dev_action_stop    },\n\t{ DEV_STATE_STARTWAIT_RX,   DEV_EVENT_RXUP,    dev_action_chup    },\n\t{ DEV_STATE_STARTWAIT_RX,   DEV_EVENT_TXUP,    dev_action_chup    },\n\t{ DEV_STATE_STARTWAIT_RX,   DEV_EVENT_TXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_STARTWAIT_RX,   DEV_EVENT_RESTART, dev_action_restart },\n\t{ DEV_STATE_RUNNING,        DEV_EVENT_STOP,    dev_action_stop    },\n\t{ DEV_STATE_RUNNING,        DEV_EVENT_RXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_RUNNING,        DEV_EVENT_TXDOWN,  dev_action_chdown  },\n\t{ DEV_STATE_RUNNING,        DEV_EVENT_TXUP,    ctcm_action_nop    },\n\t{ DEV_STATE_RUNNING,        DEV_EVENT_RXUP,    ctcm_action_nop    },\n\t{ DEV_STATE_RUNNING,        DEV_EVENT_RESTART, dev_action_restart },\n};\n\nint dev_fsm_len = ARRAY_SIZE(dev_fsm);\n\n \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}