{
  "module_name": "qeth_l3_main.c",
  "hash_id": "869fc462639ba987f5b01451093a504d76ad33bfb6bbe740b2ea750aa83c40b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/qeth_l3_main.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"qeth\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/ipv6.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/slab.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/skbuff.h>\n\n#include <net/ip.h>\n#include <net/arp.h>\n#include <net/route.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/iucv/af_iucv.h>\n#include <linux/hashtable.h>\n\n#include \"qeth_l3.h\"\n\nstatic int qeth_l3_register_addr_entry(struct qeth_card *,\n\t\tstruct qeth_ipaddr *);\nstatic int qeth_l3_deregister_addr_entry(struct qeth_card *,\n\t\tstruct qeth_ipaddr *);\n\nint qeth_l3_ipaddr_to_string(enum qeth_prot_versions proto, const u8 *addr,\n\t\t\t     char *buf)\n{\n\tif (proto == QETH_PROT_IPV4)\n\t\treturn scnprintf(buf, INET_ADDRSTRLEN, \"%pI4\", addr);\n\telse\n\t\treturn scnprintf(buf, INET6_ADDRSTRLEN, \"%pI6\", addr);\n}\n\nstatic struct qeth_ipaddr *qeth_l3_find_addr_by_ip(struct qeth_card *card,\n\t\t\t\t\t\t   struct qeth_ipaddr *query)\n{\n\tu32 key = qeth_l3_ipaddr_hash(query);\n\tstruct qeth_ipaddr *addr;\n\n\tif (query->is_multicast) {\n\t\thash_for_each_possible(card->rx_mode_addrs, addr, hnode, key)\n\t\t\tif (qeth_l3_addr_match_ip(addr, query))\n\t\t\t\treturn addr;\n\t} else {\n\t\thash_for_each_possible(card->ip_htable,  addr, hnode, key)\n\t\t\tif (qeth_l3_addr_match_ip(addr, query))\n\t\t\t\treturn addr;\n\t}\n\treturn NULL;\n}\n\nstatic void qeth_l3_convert_addr_to_bits(u8 *addr, u8 *bits, int len)\n{\n\tint i, j;\n\tu8 octet;\n\n\tfor (i = 0; i < len; ++i) {\n\t\toctet = addr[i];\n\t\tfor (j = 7; j >= 0; --j) {\n\t\t\tbits[i*8 + j] = octet & 1;\n\t\t\toctet >>= 1;\n\t\t}\n\t}\n}\n\nstatic bool qeth_l3_is_addr_covered_by_ipato(struct qeth_card *card,\n\t\t\t\t\t     struct qeth_ipaddr *addr)\n{\n\tstruct qeth_ipato_entry *ipatoe;\n\tu8 addr_bits[128] = {0, };\n\tu8 ipatoe_bits[128] = {0, };\n\tint rc = 0;\n\n\tif (!card->ipato.enabled)\n\t\treturn false;\n\tif (addr->type != QETH_IP_TYPE_NORMAL)\n\t\treturn false;\n\n\tqeth_l3_convert_addr_to_bits((u8 *) &addr->u, addr_bits,\n\t\t\t\t     (addr->proto == QETH_PROT_IPV4) ? 4 : 16);\n\tlist_for_each_entry(ipatoe, &card->ipato.entries, entry) {\n\t\tif (addr->proto != ipatoe->proto)\n\t\t\tcontinue;\n\t\tqeth_l3_convert_addr_to_bits(ipatoe->addr, ipatoe_bits,\n\t\t\t\t\t  (ipatoe->proto == QETH_PROT_IPV4) ?\n\t\t\t\t\t  4 : 16);\n\t\trc = !memcmp(addr_bits, ipatoe_bits, ipatoe->mask_bits);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\t \n\tif ((addr->proto == QETH_PROT_IPV4) && card->ipato.invert4)\n\t\trc = !rc;\n\telse if ((addr->proto == QETH_PROT_IPV6) && card->ipato.invert6)\n\t\trc = !rc;\n\n\treturn rc;\n}\n\nstatic int qeth_l3_delete_ip(struct qeth_card *card,\n\t\t\t     struct qeth_ipaddr *tmp_addr)\n{\n\tint rc = 0;\n\tstruct qeth_ipaddr *addr;\n\n\tif (tmp_addr->type == QETH_IP_TYPE_RXIP)\n\t\tQETH_CARD_TEXT(card, 2, \"delrxip\");\n\telse if (tmp_addr->type == QETH_IP_TYPE_VIPA)\n\t\tQETH_CARD_TEXT(card, 2, \"delvipa\");\n\telse\n\t\tQETH_CARD_TEXT(card, 2, \"delip\");\n\n\tif (tmp_addr->proto == QETH_PROT_IPV4)\n\t\tQETH_CARD_HEX(card, 4, &tmp_addr->u.a4.addr, 4);\n\telse {\n\t\tQETH_CARD_HEX(card, 4, &tmp_addr->u.a6.addr, 8);\n\t\tQETH_CARD_HEX(card, 4, ((char *)&tmp_addr->u.a6.addr) + 8, 8);\n\t}\n\n\taddr = qeth_l3_find_addr_by_ip(card, tmp_addr);\n\tif (!addr || !qeth_l3_addr_match_all(addr, tmp_addr))\n\t\treturn -ENOENT;\n\n\taddr->ref_counter--;\n\tif (addr->type == QETH_IP_TYPE_NORMAL && addr->ref_counter > 0)\n\t\treturn rc;\n\n\tif (qeth_card_hw_is_reachable(card))\n\t\trc = qeth_l3_deregister_addr_entry(card, addr);\n\n\thash_del(&addr->hnode);\n\tkfree(addr);\n\n\treturn rc;\n}\n\nstatic int qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)\n{\n\tint rc = 0;\n\tstruct qeth_ipaddr *addr;\n\tchar buf[INET6_ADDRSTRLEN];\n\n\tif (tmp_addr->type == QETH_IP_TYPE_RXIP)\n\t\tQETH_CARD_TEXT(card, 2, \"addrxip\");\n\telse if (tmp_addr->type == QETH_IP_TYPE_VIPA)\n\t\tQETH_CARD_TEXT(card, 2, \"addvipa\");\n\telse\n\t\tQETH_CARD_TEXT(card, 2, \"addip\");\n\n\tif (tmp_addr->proto == QETH_PROT_IPV4)\n\t\tQETH_CARD_HEX(card, 4, &tmp_addr->u.a4.addr, 4);\n\telse {\n\t\tQETH_CARD_HEX(card, 4, &tmp_addr->u.a6.addr, 8);\n\t\tQETH_CARD_HEX(card, 4, ((char *)&tmp_addr->u.a6.addr) + 8, 8);\n\t}\n\n\taddr = qeth_l3_find_addr_by_ip(card, tmp_addr);\n\tif (addr) {\n\t\tif (tmp_addr->type != QETH_IP_TYPE_NORMAL)\n\t\t\treturn -EADDRINUSE;\n\t\tif (qeth_l3_addr_match_all(addr, tmp_addr)) {\n\t\t\taddr->ref_counter++;\n\t\t\treturn 0;\n\t\t}\n\t\tqeth_l3_ipaddr_to_string(tmp_addr->proto, (u8 *)&tmp_addr->u,\n\t\t\t\t\t buf);\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Registering IP address %s failed\\n\", buf);\n\t\treturn -EADDRINUSE;\n\t} else {\n\t\taddr = kmemdup(tmp_addr, sizeof(*tmp_addr), GFP_KERNEL);\n\t\tif (!addr)\n\t\t\treturn -ENOMEM;\n\n\t\tif (qeth_l3_is_addr_covered_by_ipato(card, addr)) {\n\t\t\tQETH_CARD_TEXT(card, 2, \"tkovaddr\");\n\t\t\taddr->ipato = 1;\n\t\t}\n\t\thash_add(card->ip_htable, &addr->hnode,\n\t\t\t\tqeth_l3_ipaddr_hash(addr));\n\n\t\tif (!qeth_card_hw_is_reachable(card)) {\n\t\t\taddr->disp_flag = QETH_DISP_ADDR_ADD;\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = qeth_l3_register_addr_entry(card, addr);\n\n\t\tif (!rc || rc == -EADDRINUSE || rc == -ENETDOWN) {\n\t\t\taddr->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\n\t\t} else {\n\t\t\thash_del(&addr->hnode);\n\t\t\tkfree(addr);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int qeth_l3_modify_ip(struct qeth_card *card, struct qeth_ipaddr *addr,\n\t\t\t     bool add)\n{\n\tint rc;\n\n\tmutex_lock(&card->ip_lock);\n\trc = add ? qeth_l3_add_ip(card, addr) : qeth_l3_delete_ip(card, addr);\n\tmutex_unlock(&card->ip_lock);\n\n\treturn rc;\n}\n\nstatic void qeth_l3_drain_rx_mode_cache(struct qeth_card *card)\n{\n\tstruct qeth_ipaddr *addr;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\thash_for_each_safe(card->rx_mode_addrs, i, tmp, addr, hnode) {\n\t\thash_del(&addr->hnode);\n\t\tkfree(addr);\n\t}\n}\n\nstatic void qeth_l3_clear_ip_htable(struct qeth_card *card, int recover)\n{\n\tstruct qeth_ipaddr *addr;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\tQETH_CARD_TEXT(card, 4, \"clearip\");\n\n\tmutex_lock(&card->ip_lock);\n\n\thash_for_each_safe(card->ip_htable, i, tmp, addr, hnode) {\n\t\tif (!recover) {\n\t\t\thash_del(&addr->hnode);\n\t\t\tkfree(addr);\n\t\t\tcontinue;\n\t\t}\n\t\taddr->disp_flag = QETH_DISP_ADDR_ADD;\n\t}\n\n\tmutex_unlock(&card->ip_lock);\n}\n\nstatic void qeth_l3_recover_ip(struct qeth_card *card)\n{\n\tstruct qeth_ipaddr *addr;\n\tstruct hlist_node *tmp;\n\tint i;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 4, \"recovrip\");\n\n\tmutex_lock(&card->ip_lock);\n\n\thash_for_each_safe(card->ip_htable, i, tmp, addr, hnode) {\n\t\tif (addr->disp_flag == QETH_DISP_ADDR_ADD) {\n\t\t\trc = qeth_l3_register_addr_entry(card, addr);\n\n\t\t\tif (!rc) {\n\t\t\t\taddr->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\n\t\t\t} else {\n\t\t\t\thash_del(&addr->hnode);\n\t\t\t\tkfree(addr);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&card->ip_lock);\n}\n\nstatic int qeth_l3_setdelip_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\t\t       unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\n\tswitch (cmd->hdr.return_code) {\n\tcase IPA_RC_SUCCESS:\n\t\treturn 0;\n\tcase IPA_RC_DUPLICATE_IP_ADDRESS:\n\t\treturn -EADDRINUSE;\n\tcase IPA_RC_MC_ADDR_NOT_FOUND:\n\t\treturn -ENOENT;\n\tcase IPA_RC_LAN_OFFLINE:\n\t\treturn -ENETDOWN;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int qeth_l3_send_setdelmc(struct qeth_card *card,\n\t\t\t\t struct qeth_ipaddr *addr,\n\t\t\t\t enum qeth_ipa_cmds ipacmd)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"setdelmc\");\n\n\tiob = qeth_ipa_alloc_cmd(card, ipacmd, addr->proto,\n\t\t\t\t IPA_DATA_SIZEOF(setdelipm));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\tif (addr->proto == QETH_PROT_IPV6) {\n\t\tcmd->data.setdelipm.ip = addr->u.a6.addr;\n\t\tipv6_eth_mc_map(&addr->u.a6.addr, cmd->data.setdelipm.mac);\n\t} else {\n\t\tcmd->data.setdelipm.ip.s6_addr32[3] = addr->u.a4.addr;\n\t\tip_eth_mc_map(addr->u.a4.addr, cmd->data.setdelipm.mac);\n\t}\n\n\treturn qeth_send_ipa_cmd(card, iob, qeth_l3_setdelip_cb, NULL);\n}\n\nstatic void qeth_l3_set_ipv6_prefix(struct in6_addr *prefix, unsigned int len)\n{\n\tunsigned int i = 0;\n\n\twhile (len && i < 4) {\n\t\tint mask_len = min_t(int, len, 32);\n\n\t\tprefix->s6_addr32[i] = inet_make_mask(mask_len);\n\t\tlen -= mask_len;\n\t\ti++;\n\t}\n}\n\nstatic u32 qeth_l3_get_setdelip_flags(struct qeth_ipaddr *addr, bool set)\n{\n\tswitch (addr->type) {\n\tcase QETH_IP_TYPE_RXIP:\n\t\treturn (set) ? QETH_IPA_SETIP_TAKEOVER_FLAG : 0;\n\tcase QETH_IP_TYPE_VIPA:\n\t\treturn (set) ? QETH_IPA_SETIP_VIPA_FLAG :\n\t\t\t       QETH_IPA_DELIP_VIPA_FLAG;\n\tdefault:\n\t\treturn (set && addr->ipato) ? QETH_IPA_SETIP_TAKEOVER_FLAG : 0;\n\t}\n}\n\nstatic int qeth_l3_send_setdelip(struct qeth_card *card,\n\t\t\t\t struct qeth_ipaddr *addr,\n\t\t\t\t enum qeth_ipa_cmds ipacmd)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tu32 flags;\n\n\tQETH_CARD_TEXT(card, 4, \"setdelip\");\n\n\tiob = qeth_ipa_alloc_cmd(card, ipacmd, addr->proto,\n\t\t\t\t IPA_DATA_SIZEOF(setdelip6));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\n\tflags = qeth_l3_get_setdelip_flags(addr, ipacmd == IPA_CMD_SETIP);\n\tQETH_CARD_TEXT_(card, 4, \"flags%02X\", flags);\n\n\tif (addr->proto == QETH_PROT_IPV6) {\n\t\tcmd->data.setdelip6.addr = addr->u.a6.addr;\n\t\tqeth_l3_set_ipv6_prefix(&cmd->data.setdelip6.prefix,\n\t\t\t\t\taddr->u.a6.pfxlen);\n\t\tcmd->data.setdelip6.flags = flags;\n\t} else {\n\t\tcmd->data.setdelip4.addr = addr->u.a4.addr;\n\t\tcmd->data.setdelip4.mask = addr->u.a4.mask;\n\t\tcmd->data.setdelip4.flags = flags;\n\t}\n\n\treturn qeth_send_ipa_cmd(card, iob, qeth_l3_setdelip_cb, NULL);\n}\n\nstatic int qeth_l3_send_setrouting(struct qeth_card *card,\n\tenum qeth_routing_types type, enum qeth_prot_versions prot)\n{\n\tint rc;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 4, \"setroutg\");\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_SETRTG, prot,\n\t\t\t\t IPA_DATA_SIZEOF(setrtg));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\tcmd->data.setrtg.type = (type);\n\trc = qeth_send_ipa_cmd(card, iob, NULL, NULL);\n\n\treturn rc;\n}\n\nstatic int qeth_l3_correct_routing_type(struct qeth_card *card,\n\t\tenum qeth_routing_types *type, enum qeth_prot_versions prot)\n{\n\tif (IS_IQD(card)) {\n\t\tswitch (*type) {\n\t\tcase NO_ROUTER:\n\t\tcase PRIMARY_CONNECTOR:\n\t\tcase SECONDARY_CONNECTOR:\n\t\tcase MULTICAST_ROUTER:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tgoto out_inval;\n\t\t}\n\t} else {\n\t\tswitch (*type) {\n\t\tcase NO_ROUTER:\n\t\tcase PRIMARY_ROUTER:\n\t\tcase SECONDARY_ROUTER:\n\t\t\treturn 0;\n\t\tcase MULTICAST_ROUTER:\n\t\t\tif (qeth_is_ipafunc_supported(card, prot,\n\t\t\t\t\t\t      IPA_OSA_MC_ROUTER))\n\t\t\t\treturn 0;\n\t\t\tgoto out_inval;\n\t\tdefault:\n\t\t\tgoto out_inval;\n\t\t}\n\t}\nout_inval:\n\t*type = NO_ROUTER;\n\treturn -EINVAL;\n}\n\nint qeth_l3_setrouting_v4(struct qeth_card *card)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"setrtg4\");\n\n\trc = qeth_l3_correct_routing_type(card, &card->options.route4.type,\n\t\t\t\t  QETH_PROT_IPV4);\n\tif (rc)\n\t\treturn rc;\n\n\trc = qeth_l3_send_setrouting(card, card->options.route4.type,\n\t\t\t\t  QETH_PROT_IPV4);\n\tif (rc) {\n\t\tcard->options.route4.type = NO_ROUTER;\n\t\tQETH_DBF_MESSAGE(2, \"Error (%#06x) while setting routing type on device %x. Type set to 'no router'.\\n\",\n\t\t\t\t rc, CARD_DEVID(card));\n\t}\n\treturn rc;\n}\n\nint qeth_l3_setrouting_v6(struct qeth_card *card)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"setrtg6\");\n\n\tif (!qeth_is_supported(card, IPA_IPV6))\n\t\treturn 0;\n\trc = qeth_l3_correct_routing_type(card, &card->options.route6.type,\n\t\t\t\t  QETH_PROT_IPV6);\n\tif (rc)\n\t\treturn rc;\n\n\trc = qeth_l3_send_setrouting(card, card->options.route6.type,\n\t\t\t\t  QETH_PROT_IPV6);\n\tif (rc) {\n\t\tcard->options.route6.type = NO_ROUTER;\n\t\tQETH_DBF_MESSAGE(2, \"Error (%#06x) while setting routing type on device %x. Type set to 'no router'.\\n\",\n\t\t\t\t rc, CARD_DEVID(card));\n\t}\n\treturn rc;\n}\n\n \n\n \nvoid qeth_l3_update_ipato(struct qeth_card *card)\n{\n\tstruct qeth_ipaddr *addr;\n\tunsigned int i;\n\n\thash_for_each(card->ip_htable, i, addr, hnode) {\n\t\tif (addr->type != QETH_IP_TYPE_NORMAL)\n\t\t\tcontinue;\n\t\taddr->ipato = qeth_l3_is_addr_covered_by_ipato(card, addr);\n\t}\n}\n\nstatic void qeth_l3_clear_ipato_list(struct qeth_card *card)\n{\n\tstruct qeth_ipato_entry *ipatoe, *tmp;\n\n\tmutex_lock(&card->ip_lock);\n\n\tlist_for_each_entry_safe(ipatoe, tmp, &card->ipato.entries, entry) {\n\t\tlist_del(&ipatoe->entry);\n\t\tkfree(ipatoe);\n\t}\n\n\tqeth_l3_update_ipato(card);\n\tmutex_unlock(&card->ip_lock);\n}\n\nint qeth_l3_add_ipato_entry(struct qeth_card *card,\n\t\t\t\tstruct qeth_ipato_entry *new)\n{\n\tstruct qeth_ipato_entry *ipatoe;\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"addipato\");\n\n\tmutex_lock(&card->ip_lock);\n\n\tlist_for_each_entry(ipatoe, &card->ipato.entries, entry) {\n\t\tif (ipatoe->proto != new->proto)\n\t\t\tcontinue;\n\t\tif (!memcmp(ipatoe->addr, new->addr,\n\t\t\t    (ipatoe->proto == QETH_PROT_IPV4) ? 4 : 16) &&\n\t\t    (ipatoe->mask_bits == new->mask_bits)) {\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rc) {\n\t\tlist_add_tail(&new->entry, &card->ipato.entries);\n\t\tqeth_l3_update_ipato(card);\n\t}\n\n\tmutex_unlock(&card->ip_lock);\n\n\treturn rc;\n}\n\nint qeth_l3_del_ipato_entry(struct qeth_card *card,\n\t\t\t    enum qeth_prot_versions proto, u8 *addr,\n\t\t\t    unsigned int mask_bits)\n{\n\tstruct qeth_ipato_entry *ipatoe, *tmp;\n\tint rc = -ENOENT;\n\n\tQETH_CARD_TEXT(card, 2, \"delipato\");\n\n\tmutex_lock(&card->ip_lock);\n\n\tlist_for_each_entry_safe(ipatoe, tmp, &card->ipato.entries, entry) {\n\t\tif (ipatoe->proto != proto)\n\t\t\tcontinue;\n\t\tif (!memcmp(ipatoe->addr, addr,\n\t\t\t    (proto == QETH_PROT_IPV4) ? 4 : 16) &&\n\t\t    (ipatoe->mask_bits == mask_bits)) {\n\t\t\tlist_del(&ipatoe->entry);\n\t\t\tqeth_l3_update_ipato(card);\n\t\t\tkfree(ipatoe);\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&card->ip_lock);\n\n\treturn rc;\n}\n\nint qeth_l3_modify_rxip_vipa(struct qeth_card *card, bool add, const u8 *ip,\n\t\t\t     enum qeth_ip_types type,\n\t\t\t     enum qeth_prot_versions proto)\n{\n\tstruct qeth_ipaddr addr;\n\n\tqeth_l3_init_ipaddr(&addr, type, proto);\n\tif (proto == QETH_PROT_IPV4)\n\t\tmemcpy(&addr.u.a4.addr, ip, 4);\n\telse\n\t\tmemcpy(&addr.u.a6.addr, ip, 16);\n\n\treturn qeth_l3_modify_ip(card, &addr, add);\n}\n\nint qeth_l3_modify_hsuid(struct qeth_card *card, bool add)\n{\n\tstruct qeth_ipaddr addr;\n\tunsigned int i;\n\n\tqeth_l3_init_ipaddr(&addr, QETH_IP_TYPE_NORMAL, QETH_PROT_IPV6);\n\taddr.u.a6.addr.s6_addr[0] = 0xfe;\n\taddr.u.a6.addr.s6_addr[1] = 0x80;\n\tfor (i = 0; i < 8; i++)\n\t\taddr.u.a6.addr.s6_addr[8+i] = card->options.hsuid[i];\n\n\treturn qeth_l3_modify_ip(card, &addr, add);\n}\n\nstatic int qeth_l3_register_addr_entry(struct qeth_card *card,\n\t\t\t\tstruct qeth_ipaddr *addr)\n{\n\tchar buf[50];\n\tint rc = 0;\n\tint cnt = 3;\n\n\tif (card->options.sniffer)\n\t\treturn 0;\n\n\tif (addr->proto == QETH_PROT_IPV4) {\n\t\tQETH_CARD_TEXT(card, 2, \"setaddr4\");\n\t\tQETH_CARD_HEX(card, 3, &addr->u.a4.addr, sizeof(int));\n\t} else if (addr->proto == QETH_PROT_IPV6) {\n\t\tQETH_CARD_TEXT(card, 2, \"setaddr6\");\n\t\tQETH_CARD_HEX(card, 3, &addr->u.a6.addr, 8);\n\t\tQETH_CARD_HEX(card, 3, ((char *)&addr->u.a6.addr) + 8, 8);\n\t} else {\n\t\tQETH_CARD_TEXT(card, 2, \"setaddr?\");\n\t\tQETH_CARD_HEX(card, 3, addr, sizeof(struct qeth_ipaddr));\n\t}\n\tdo {\n\t\tif (addr->is_multicast)\n\t\t\trc =  qeth_l3_send_setdelmc(card, addr, IPA_CMD_SETIPM);\n\t\telse\n\t\t\trc = qeth_l3_send_setdelip(card, addr, IPA_CMD_SETIP);\n\t\tif (rc)\n\t\t\tQETH_CARD_TEXT(card, 2, \"failed\");\n\t} while ((--cnt > 0) && rc);\n\tif (rc) {\n\t\tQETH_CARD_TEXT(card, 2, \"FAILED\");\n\t\tqeth_l3_ipaddr_to_string(addr->proto, (u8 *)&addr->u, buf);\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t\"Registering IP address %s failed\\n\", buf);\n\t}\n\treturn rc;\n}\n\nstatic int qeth_l3_deregister_addr_entry(struct qeth_card *card,\n\t\t\t\t\t\tstruct qeth_ipaddr *addr)\n{\n\tint rc = 0;\n\n\tif (card->options.sniffer)\n\t\treturn 0;\n\n\tif (addr->proto == QETH_PROT_IPV4) {\n\t\tQETH_CARD_TEXT(card, 2, \"deladdr4\");\n\t\tQETH_CARD_HEX(card, 3, &addr->u.a4.addr, sizeof(int));\n\t} else if (addr->proto == QETH_PROT_IPV6) {\n\t\tQETH_CARD_TEXT(card, 2, \"deladdr6\");\n\t\tQETH_CARD_HEX(card, 3, &addr->u.a6.addr, 8);\n\t\tQETH_CARD_HEX(card, 3, ((char *)&addr->u.a6.addr) + 8, 8);\n\t} else {\n\t\tQETH_CARD_TEXT(card, 2, \"deladdr?\");\n\t\tQETH_CARD_HEX(card, 3, addr, sizeof(struct qeth_ipaddr));\n\t}\n\tif (addr->is_multicast)\n\t\trc = qeth_l3_send_setdelmc(card, addr, IPA_CMD_DELIPM);\n\telse\n\t\trc = qeth_l3_send_setdelip(card, addr, IPA_CMD_DELIP);\n\tif (rc)\n\t\tQETH_CARD_TEXT(card, 2, \"failed\");\n\n\treturn rc;\n}\n\nstatic int qeth_l3_setadapter_parms(struct qeth_card *card)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"setadprm\");\n\n\tif (qeth_adp_supported(card, IPA_SETADP_ALTER_MAC_ADDRESS)) {\n\t\trc = qeth_setadpparms_change_macaddr(card);\n\t\tif (rc)\n\t\t\tdev_warn(&card->gdev->dev, \"Reading the adapter MAC\"\n\t\t\t\t\" address failed\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic int qeth_l3_start_ipa_arp_processing(struct qeth_card *card)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"ipaarp\");\n\n\tif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"ARP processing not supported on %s!\\n\",\n\t\t\t netdev_name(card->dev));\n\t\treturn 0;\n\t}\n\trc = qeth_send_simple_setassparms(card, IPA_ARP_PROCESSING,\n\t\t\t\t\t  IPA_CMD_ASS_START, NULL);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Starting ARP processing support for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\t}\n\treturn rc;\n}\n\nstatic int qeth_l3_start_ipa_source_mac(struct qeth_card *card)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"stsrcmac\");\n\n\tif (!qeth_is_supported(card, IPA_SOURCE_MAC)) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"Inbound source MAC-address not supported on %s\\n\",\n\t\t\t netdev_name(card->dev));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = qeth_send_simple_setassparms(card, IPA_SOURCE_MAC,\n\t\t\t\t\t  IPA_CMD_ASS_START, NULL);\n\tif (rc)\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Starting source MAC-address support for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\treturn rc;\n}\n\nstatic int qeth_l3_start_ipa_vlan(struct qeth_card *card)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"strtvlan\");\n\n\tif (!qeth_is_supported(card, IPA_FULL_VLAN)) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"VLAN not supported on %s\\n\", netdev_name(card->dev));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = qeth_send_simple_setassparms(card, IPA_VLAN_PRIO,\n\t\t\t\t\t  IPA_CMD_ASS_START, NULL);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Starting VLAN support for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\t} else {\n\t\tdev_info(&card->gdev->dev, \"VLAN enabled\\n\");\n\t}\n\treturn rc;\n}\n\nstatic int qeth_l3_start_ipa_multicast(struct qeth_card *card)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"stmcast\");\n\n\tif (!qeth_is_supported(card, IPA_MULTICASTING)) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"Multicast not supported on %s\\n\",\n\t\t\t netdev_name(card->dev));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = qeth_send_simple_setassparms(card, IPA_MULTICASTING,\n\t\t\t\t\t  IPA_CMD_ASS_START, NULL);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Starting multicast support for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\t} else {\n\t\tdev_info(&card->gdev->dev, \"Multicast enabled\\n\");\n\t\tcard->dev->flags |= IFF_MULTICAST;\n\t}\n\treturn rc;\n}\n\nstatic int qeth_l3_softsetup_ipv6(struct qeth_card *card)\n{\n\tu32 ipv6_data = 3;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"softipv6\");\n\n\tif (IS_IQD(card))\n\t\tgoto out;\n\n\trc = qeth_send_simple_setassparms(card, IPA_IPV6, IPA_CMD_ASS_START,\n\t\t\t\t\t  &ipv6_data);\n\tif (rc) {\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"Activating IPv6 support for %s failed\\n\",\n\t\t\tnetdev_name(card->dev));\n\t\treturn rc;\n\t}\n\trc = qeth_send_simple_setassparms_v6(card, IPA_IPV6, IPA_CMD_ASS_START,\n\t\t\t\t\t     NULL);\n\tif (rc) {\n\t\tdev_err(&card->gdev->dev,\n\t\t\t\"Activating IPv6 support for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\t\treturn rc;\n\t}\n\trc = qeth_send_simple_setassparms_v6(card, IPA_PASSTHRU,\n\t\t\t\t\t     IPA_CMD_ASS_START, NULL);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Enabling the passthrough mode for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\t\treturn rc;\n\t}\nout:\n\tdev_info(&card->gdev->dev, \"IPV6 enabled\\n\");\n\treturn 0;\n}\n\nstatic int qeth_l3_start_ipa_ipv6(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 3, \"strtipv6\");\n\n\tif (!qeth_is_supported(card, IPA_IPV6)) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"IPv6 not supported on %s\\n\", netdev_name(card->dev));\n\t\treturn 0;\n\t}\n\treturn qeth_l3_softsetup_ipv6(card);\n}\n\nstatic int qeth_l3_start_ipa_broadcast(struct qeth_card *card)\n{\n\tu32 filter_data = 1;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"stbrdcst\");\n\tcard->info.broadcast_capable = 0;\n\tif (!qeth_is_supported(card, IPA_FILTERING)) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"Broadcast not supported on %s\\n\",\n\t\t\t netdev_name(card->dev));\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\trc = qeth_send_simple_setassparms(card, IPA_FILTERING,\n\t\t\t\t\t  IPA_CMD_ASS_START, NULL);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Enabling broadcast filtering for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\t\tgoto out;\n\t}\n\n\trc = qeth_send_simple_setassparms(card, IPA_FILTERING,\n\t\t\t\t\t  IPA_CMD_ASS_CONFIGURE, &filter_data);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Setting up broadcast filtering for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\t\tgoto out;\n\t}\n\tcard->info.broadcast_capable = QETH_BROADCAST_WITH_ECHO;\n\tdev_info(&card->gdev->dev, \"Broadcast enabled\\n\");\n\trc = qeth_send_simple_setassparms(card, IPA_FILTERING,\n\t\t\t\t\t  IPA_CMD_ASS_ENABLE, &filter_data);\n\tif (rc) {\n\t\tdev_warn(&card->gdev->dev,\n\t\t\t \"Setting up broadcast echo filtering for %s failed\\n\",\n\t\t\t netdev_name(card->dev));\n\t\tgoto out;\n\t}\n\tcard->info.broadcast_capable = QETH_BROADCAST_WITHOUT_ECHO;\nout:\n\tif (card->info.broadcast_capable)\n\t\tcard->dev->flags |= IFF_BROADCAST;\n\telse\n\t\tcard->dev->flags &= ~IFF_BROADCAST;\n\treturn rc;\n}\n\nstatic void qeth_l3_start_ipassists(struct qeth_card *card)\n{\n\tQETH_CARD_TEXT(card, 3, \"strtipas\");\n\n\tqeth_l3_start_ipa_arp_processing(card);\t \n\tqeth_l3_start_ipa_source_mac(card);\t \n\tqeth_l3_start_ipa_vlan(card);\t\t \n\tqeth_l3_start_ipa_multicast(card);\t\t \n\tqeth_l3_start_ipa_ipv6(card);\t\t \n\tqeth_l3_start_ipa_broadcast(card);\t\t \n}\n\nstatic int qeth_l3_iqd_read_initial_mac_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\n\tif (cmd->hdr.return_code)\n\t\treturn -EIO;\n\tif (!is_valid_ether_addr(cmd->data.create_destroy_addr.mac_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(card->dev, cmd->data.create_destroy_addr.mac_addr);\n\treturn 0;\n}\n\nstatic int qeth_l3_iqd_read_initial_mac(struct qeth_card *card)\n{\n\tint rc = 0;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"hsrmac\");\n\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_CREATE_ADDR, QETH_PROT_IPV6,\n\t\t\t\t IPA_DATA_SIZEOF(create_destroy_addr));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_l3_iqd_read_initial_mac_cb,\n\t\t\t\tNULL);\n\treturn rc;\n}\n\nstatic int qeth_l3_get_unique_id_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tu16 *uid = reply->param;\n\n\tif (cmd->hdr.return_code == 0) {\n\t\t*uid = cmd->data.create_destroy_addr.uid;\n\t\treturn 0;\n\t}\n\n\tdev_warn(&card->gdev->dev, \"The network adapter failed to generate a unique ID\\n\");\n\treturn -EIO;\n}\n\nstatic u16 qeth_l3_get_unique_id(struct qeth_card *card, u16 uid)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"guniqeid\");\n\n\tif (!qeth_is_supported(card, IPA_IPV6))\n\t\tgoto out;\n\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_CREATE_ADDR, QETH_PROT_IPV6,\n\t\t\t\t IPA_DATA_SIZEOF(create_destroy_addr));\n\tif (!iob)\n\t\tgoto out;\n\n\t__ipa_cmd(iob)->data.create_destroy_addr.uid = uid;\n\tqeth_send_ipa_cmd(card, iob, qeth_l3_get_unique_id_cb, &uid);\n\nout:\n\treturn uid;\n}\n\nstatic int\nqeth_diags_trace_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\t\t    unsigned long data)\n{\n\tstruct qeth_ipa_cmd\t   *cmd;\n\t__u16 rc;\n\n\tQETH_CARD_TEXT(card, 2, \"diastrcb\");\n\n\tcmd = (struct qeth_ipa_cmd *)data;\n\trc = cmd->hdr.return_code;\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"dxter%x\", rc);\n\tswitch (cmd->data.diagass.action) {\n\tcase QETH_DIAGS_CMD_TRACE_QUERY:\n\t\tbreak;\n\tcase QETH_DIAGS_CMD_TRACE_DISABLE:\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\tcase IPA_RC_INVALID_SUBCMD:\n\t\t\tcard->info.promisc_mode = SET_PROMISC_MODE_OFF;\n\t\t\tdev_info(&card->gdev->dev, \"The HiperSockets network \"\n\t\t\t\t\"traffic analyzer is deactivated\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase QETH_DIAGS_CMD_TRACE_ENABLE:\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tcard->info.promisc_mode = SET_PROMISC_MODE_ON;\n\t\t\tdev_info(&card->gdev->dev, \"The HiperSockets network \"\n\t\t\t\t\"traffic analyzer is activated\\n\");\n\t\t\tbreak;\n\t\tcase IPA_RC_HARDWARE_AUTH_ERROR:\n\t\t\tdev_warn(&card->gdev->dev, \"The device is not \"\n\t\t\t\t\"authorized to run as a HiperSockets network \"\n\t\t\t\t\"traffic analyzer\\n\");\n\t\t\tbreak;\n\t\tcase IPA_RC_TRACE_ALREADY_ACTIVE:\n\t\t\tdev_warn(&card->gdev->dev, \"A HiperSockets \"\n\t\t\t\t\"network traffic analyzer is already \"\n\t\t\t\t\"active in the HiperSockets LAN\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tQETH_DBF_MESSAGE(2, \"Unknown sniffer action (%#06x) on device %x\\n\",\n\t\t\t\t cmd->data.diagass.action, CARD_DEVID(card));\n\t}\n\n\treturn rc ? -EIO : 0;\n}\n\nstatic int\nqeth_diags_trace(struct qeth_card *card, enum qeth_diags_trace_cmds diags_cmd)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd    *cmd;\n\n\tQETH_CARD_TEXT(card, 2, \"diagtrac\");\n\n\tiob = qeth_get_diag_cmd(card, QETH_DIAGS_CMD_TRACE, 0);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\tcmd->data.diagass.type = QETH_DIAGS_TYPE_HIPERSOCKET;\n\tcmd->data.diagass.action = diags_cmd;\n\treturn qeth_send_ipa_cmd(card, iob, qeth_diags_trace_cb, NULL);\n}\n\nstatic int qeth_l3_add_mcast_rtnl(struct net_device *dev, int vid, void *arg)\n{\n\tstruct qeth_card *card = arg;\n\tstruct inet6_dev *in6_dev;\n\tstruct in_device *in4_dev;\n\tstruct qeth_ipaddr *ipm;\n\tstruct qeth_ipaddr tmp;\n\tstruct ip_mc_list *im4;\n\tstruct ifmcaddr6 *im6;\n\n\tQETH_CARD_TEXT(card, 4, \"addmc\");\n\n\tif (!dev || !(dev->flags & IFF_UP))\n\t\tgoto out;\n\n\tin4_dev = __in_dev_get_rtnl(dev);\n\tif (!in4_dev)\n\t\tgoto walk_ipv6;\n\n\tqeth_l3_init_ipaddr(&tmp, QETH_IP_TYPE_NORMAL, QETH_PROT_IPV4);\n\ttmp.disp_flag = QETH_DISP_ADDR_ADD;\n\ttmp.is_multicast = 1;\n\n\tfor (im4 = rtnl_dereference(in4_dev->mc_list); im4 != NULL;\n\t     im4 = rtnl_dereference(im4->next_rcu)) {\n\t\ttmp.u.a4.addr = im4->multiaddr;\n\n\t\tipm = qeth_l3_find_addr_by_ip(card, &tmp);\n\t\tif (ipm) {\n\t\t\t \n\t\t\tipm->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\n\t\t\tcontinue;\n\t\t}\n\n\t\tipm = kmemdup(&tmp, sizeof(tmp), GFP_KERNEL);\n\t\tif (!ipm)\n\t\t\tcontinue;\n\n\t\thash_add(card->rx_mode_addrs, &ipm->hnode,\n\t\t\t qeth_l3_ipaddr_hash(ipm));\n\t}\n\nwalk_ipv6:\n\tif (!qeth_is_supported(card, IPA_IPV6))\n\t\tgoto out;\n\n\tin6_dev = __in6_dev_get(dev);\n\tif (!in6_dev)\n\t\tgoto out;\n\n\tqeth_l3_init_ipaddr(&tmp, QETH_IP_TYPE_NORMAL, QETH_PROT_IPV6);\n\ttmp.disp_flag = QETH_DISP_ADDR_ADD;\n\ttmp.is_multicast = 1;\n\n\tfor (im6 = rtnl_dereference(in6_dev->mc_list);\n\t     im6;\n\t     im6 = rtnl_dereference(im6->next)) {\n\t\ttmp.u.a6.addr = im6->mca_addr;\n\n\t\tipm = qeth_l3_find_addr_by_ip(card, &tmp);\n\t\tif (ipm) {\n\t\t\t \n\t\t\tipm->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\n\t\t\tcontinue;\n\t\t}\n\n\t\tipm = kmemdup(&tmp, sizeof(tmp), GFP_ATOMIC);\n\t\tif (!ipm)\n\t\t\tcontinue;\n\n\t\thash_add(card->rx_mode_addrs, &ipm->hnode,\n\t\t\t qeth_l3_ipaddr_hash(ipm));\n\n\t}\n\nout:\n\treturn 0;\n}\n\nstatic void qeth_l3_set_promisc_mode(struct qeth_card *card)\n{\n\tbool enable = card->dev->flags & IFF_PROMISC;\n\n\tif (card->info.promisc_mode == enable)\n\t\treturn;\n\n\tif (IS_VM_NIC(card)) {\t\t \n\t\tif (qeth_adp_supported(card, IPA_SETADP_SET_PROMISC_MODE))\n\t\t\tqeth_setadp_promisc_mode(card, enable);\n\t} else if (card->options.sniffer &&\t \n\t\t   qeth_adp_supported(card, IPA_SETADP_SET_DIAG_ASSIST)) {\n\t\tif (enable) {\n\t\t\tQETH_CARD_TEXT(card, 3, \"+promisc\");\n\t\t\tqeth_diags_trace(card, QETH_DIAGS_CMD_TRACE_ENABLE);\n\t\t} else {\n\t\t\tQETH_CARD_TEXT(card, 3, \"-promisc\");\n\t\t\tqeth_diags_trace(card, QETH_DIAGS_CMD_TRACE_DISABLE);\n\t\t}\n\t}\n}\n\nstatic void qeth_l3_rx_mode_work(struct work_struct *work)\n{\n\tstruct qeth_card *card = container_of(work, struct qeth_card,\n\t\t\t\t\t      rx_mode_work);\n\tstruct qeth_ipaddr *addr;\n\tstruct hlist_node *tmp;\n\tint i, rc;\n\n\tQETH_CARD_TEXT(card, 3, \"setmulti\");\n\n\tif (!card->options.sniffer) {\n\t\trtnl_lock();\n\t\tqeth_l3_add_mcast_rtnl(card->dev, 0, card);\n\t\tif (qeth_is_supported(card, IPA_FULL_VLAN))\n\t\t\tvlan_for_each(card->dev, qeth_l3_add_mcast_rtnl, card);\n\t\trtnl_unlock();\n\n\t\thash_for_each_safe(card->rx_mode_addrs, i, tmp, addr, hnode) {\n\t\t\tswitch (addr->disp_flag) {\n\t\t\tcase QETH_DISP_ADDR_DELETE:\n\t\t\t\trc = qeth_l3_deregister_addr_entry(card, addr);\n\t\t\t\tif (!rc || rc == -ENOENT) {\n\t\t\t\t\thash_del(&addr->hnode);\n\t\t\t\t\tkfree(addr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase QETH_DISP_ADDR_ADD:\n\t\t\t\trc = qeth_l3_register_addr_entry(card, addr);\n\t\t\t\tif (rc && rc != -ENETDOWN) {\n\t\t\t\t\thash_del(&addr->hnode);\n\t\t\t\t\tkfree(addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\taddr->disp_flag = QETH_DISP_ADDR_DELETE;\n\t\t\t}\n\t\t}\n\t}\n\n\tqeth_l3_set_promisc_mode(card);\n}\n\nstatic int qeth_l3_arp_makerc(u16 rc)\n{\n\tswitch (rc) {\n\tcase IPA_RC_SUCCESS:\n\t\treturn 0;\n\tcase QETH_IPA_ARP_RC_NOTSUPP:\n\tcase QETH_IPA_ARP_RC_Q_NOTSUPP:\n\t\treturn -EOPNOTSUPP;\n\tcase QETH_IPA_ARP_RC_OUT_OF_RANGE:\n\t\treturn -EINVAL;\n\tcase QETH_IPA_ARP_RC_Q_NO_DATA:\n\t\treturn -ENOENT;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int qeth_l3_arp_cmd_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\t\t      unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\n\tqeth_setassparms_cb(card, reply, data);\n\treturn qeth_l3_arp_makerc(cmd->hdr.return_code);\n}\n\nstatic int qeth_l3_arp_set_no_entries(struct qeth_card *card, int no_entries)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"arpstnoe\");\n\n\t \n\tif (IS_VM_NIC(card))\n\t\treturn -EOPNOTSUPP;\n\tif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tiob = qeth_get_setassparms_cmd(card, IPA_ARP_PROCESSING,\n\t\t\t\t       IPA_CMD_ASS_ARP_SET_NO_ENTRIES,\n\t\t\t\t       SETASS_DATA_SIZEOF(flags_32bit),\n\t\t\t\t       QETH_PROT_IPV4);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\t__ipa_cmd(iob)->data.setassparms.data.flags_32bit = (u32) no_entries;\n\trc = qeth_send_ipa_cmd(card, iob, qeth_l3_arp_cmd_cb, NULL);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"Could not set number of ARP entries on device %x: %#x\\n\",\n\t\t\t\t CARD_DEVID(card), rc);\n\treturn rc;\n}\n\nstatic __u32 get_arp_entry_size(struct qeth_card *card,\n\t\t\tstruct qeth_arp_query_data *qdata,\n\t\t\tstruct qeth_arp_entrytype *type, __u8 strip_entries)\n{\n\t__u32 rc;\n\t__u8 is_hsi;\n\n\tis_hsi = qdata->reply_bits == 5;\n\tif (type->ip == QETHARP_IP_ADDR_V4) {\n\t\tQETH_CARD_TEXT(card, 4, \"arpev4\");\n\t\tif (strip_entries) {\n\t\t\trc = is_hsi ? sizeof(struct qeth_arp_qi_entry5_short) :\n\t\t\t\tsizeof(struct qeth_arp_qi_entry7_short);\n\t\t} else {\n\t\t\trc = is_hsi ? sizeof(struct qeth_arp_qi_entry5) :\n\t\t\t\tsizeof(struct qeth_arp_qi_entry7);\n\t\t}\n\t} else if (type->ip == QETHARP_IP_ADDR_V6) {\n\t\tQETH_CARD_TEXT(card, 4, \"arpev6\");\n\t\tif (strip_entries) {\n\t\t\trc = is_hsi ?\n\t\t\t\tsizeof(struct qeth_arp_qi_entry5_short_ipv6) :\n\t\t\t\tsizeof(struct qeth_arp_qi_entry7_short_ipv6);\n\t\t} else {\n\t\t\trc = is_hsi ?\n\t\t\t\tsizeof(struct qeth_arp_qi_entry5_ipv6) :\n\t\t\t\tsizeof(struct qeth_arp_qi_entry7_ipv6);\n\t\t}\n\t} else {\n\t\tQETH_CARD_TEXT(card, 4, \"arpinv\");\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nstatic int arpentry_matches_prot(struct qeth_arp_entrytype *type, __u16 prot)\n{\n\treturn (type->ip == QETHARP_IP_ADDR_V4 && prot == QETH_PROT_IPV4) ||\n\t\t(type->ip == QETHARP_IP_ADDR_V6 && prot == QETH_PROT_IPV6);\n}\n\nstatic int qeth_l3_arp_query_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_arp_query_data *qdata;\n\tstruct qeth_arp_query_info *qinfo;\n\tint e;\n\tint entrybytes_done;\n\tint stripped_bytes;\n\t__u8 do_strip_entries;\n\n\tQETH_CARD_TEXT(card, 3, \"arpquecb\");\n\n\tqinfo = (struct qeth_arp_query_info *) reply->param;\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tQETH_CARD_TEXT_(card, 4, \"%i\", cmd->hdr.prot_version);\n\tif (cmd->hdr.return_code) {\n\t\tQETH_CARD_TEXT(card, 4, \"arpcberr\");\n\t\tQETH_CARD_TEXT_(card, 4, \"%i\", cmd->hdr.return_code);\n\t\treturn qeth_l3_arp_makerc(cmd->hdr.return_code);\n\t}\n\tif (cmd->data.setassparms.hdr.return_code) {\n\t\tcmd->hdr.return_code = cmd->data.setassparms.hdr.return_code;\n\t\tQETH_CARD_TEXT(card, 4, \"setaperr\");\n\t\tQETH_CARD_TEXT_(card, 4, \"%i\", cmd->hdr.return_code);\n\t\treturn qeth_l3_arp_makerc(cmd->hdr.return_code);\n\t}\n\tqdata = &cmd->data.setassparms.data.query_arp;\n\tQETH_CARD_TEXT_(card, 4, \"anoen%i\", qdata->no_entries);\n\n\tdo_strip_entries = (qinfo->mask_bits & QETH_QARP_STRIP_ENTRIES) > 0;\n\tstripped_bytes = do_strip_entries ? QETH_QARP_MEDIASPECIFIC_BYTES : 0;\n\tentrybytes_done = 0;\n\tfor (e = 0; e < qdata->no_entries; ++e) {\n\t\tchar *cur_entry;\n\t\t__u32 esize;\n\t\tstruct qeth_arp_entrytype *etype;\n\n\t\tcur_entry = &qdata->data + entrybytes_done;\n\t\tetype = &((struct qeth_arp_qi_entry5 *) cur_entry)->type;\n\t\tif (!arpentry_matches_prot(etype, cmd->hdr.prot_version)) {\n\t\t\tQETH_CARD_TEXT(card, 4, \"pmis\");\n\t\t\tQETH_CARD_TEXT_(card, 4, \"%i\", etype->ip);\n\t\t\tbreak;\n\t\t}\n\t\tesize = get_arp_entry_size(card, qdata, etype,\n\t\t\tdo_strip_entries);\n\t\tQETH_CARD_TEXT_(card, 5, \"esz%i\", esize);\n\t\tif (!esize)\n\t\t\tbreak;\n\n\t\tif ((qinfo->udata_len - qinfo->udata_offset) < esize) {\n\t\t\tQETH_CARD_TEXT_(card, 4, \"qaer3%i\", -ENOSPC);\n\t\t\tmemset(qinfo->udata, 0, 4);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tmemcpy(qinfo->udata + qinfo->udata_offset,\n\t\t\t&qdata->data + entrybytes_done + stripped_bytes,\n\t\t\tesize);\n\t\tentrybytes_done += esize + stripped_bytes;\n\t\tqinfo->udata_offset += esize;\n\t\t++qinfo->no_entries;\n\t}\n\t \n\tif (cmd->data.setassparms.hdr.seq_no <\n\t    cmd->data.setassparms.hdr.number_of_replies)\n\t\treturn 1;\n\tQETH_CARD_TEXT_(card, 4, \"nove%i\", qinfo->no_entries);\n\tmemcpy(qinfo->udata, &qinfo->no_entries, 4);\n\t \n\tif (qinfo->mask_bits & QETH_QARP_STRIP_ENTRIES)\n\t\tqdata->reply_bits |= QETH_QARP_STRIP_ENTRIES;\n\tmemcpy(qinfo->udata + QETH_QARP_MASK_OFFSET, &qdata->reply_bits, 2);\n\tQETH_CARD_TEXT_(card, 4, \"rc%i\", 0);\n\treturn 0;\n}\n\nstatic int qeth_l3_query_arp_cache_info(struct qeth_card *card,\n\tenum qeth_prot_versions prot,\n\tstruct qeth_arp_query_info *qinfo)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tint rc;\n\n\tQETH_CARD_TEXT_(card, 3, \"qarpipv%i\", prot);\n\n\tiob = qeth_get_setassparms_cmd(card, IPA_ARP_PROCESSING,\n\t\t\t\t       IPA_CMD_ASS_ARP_QUERY_INFO,\n\t\t\t\t       SETASS_DATA_SIZEOF(query_arp), prot);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\tcmd->data.setassparms.data.query_arp.request_bits = 0x000F;\n\trc = qeth_send_ipa_cmd(card, iob, qeth_l3_arp_query_cb, qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"Error while querying ARP cache on device %x: %#x\\n\",\n\t\t\t\t CARD_DEVID(card), rc);\n\treturn rc;\n}\n\nstatic int qeth_l3_arp_query(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"arpquery\");\n\n\tif (!qeth_is_supported(card, \n\t\t\t       IPA_ARP_PROCESSING)) {\n\t\tQETH_CARD_TEXT(card, 3, \"arpqnsup\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\t \n\tif (copy_from_user(&qinfo, udata, 6)) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tqinfo.udata_offset = QETH_QARP_ENTRIES_OFFSET;\n\trc = qeth_l3_query_arp_cache_info(card, QETH_PROT_IPV4, &qinfo);\n\tif (rc) {\n\t\tif (copy_to_user(udata, qinfo.udata, 4))\n\t\t\trc = -EFAULT;\n\t\tgoto free_and_out;\n\t}\n\tif (qinfo.mask_bits & QETH_QARP_WITH_IPV6) {\n\t\t \n\t\tqeth_l3_query_arp_cache_info(card, QETH_PROT_IPV6, &qinfo);\n\t}\n\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len)) {\n\t\tQETH_CARD_TEXT(card, 4, \"qactf\");\n\t\trc = -EFAULT;\n\t\tgoto free_and_out;\n\t}\n\tQETH_CARD_TEXT(card, 4, \"qacts\");\n\nfree_and_out:\n\tkfree(qinfo.udata);\nout:\n\treturn rc;\n}\n\nstatic int qeth_l3_arp_modify_entry(struct qeth_card *card,\n\t\t\t\t    struct qeth_arp_cache_entry *entry,\n\t\t\t\t    enum qeth_arp_process_subcmds arp_cmd)\n{\n\tstruct qeth_arp_cache_entry *cmd_entry;\n\tstruct qeth_cmd_buffer *iob;\n\tint rc;\n\n\tif (arp_cmd == IPA_CMD_ASS_ARP_ADD_ENTRY)\n\t\tQETH_CARD_TEXT(card, 3, \"arpadd\");\n\telse\n\t\tQETH_CARD_TEXT(card, 3, \"arpdel\");\n\n\t \n\tif (IS_VM_NIC(card))\n\t\treturn -EOPNOTSUPP;\n\tif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tiob = qeth_get_setassparms_cmd(card, IPA_ARP_PROCESSING, arp_cmd,\n\t\t\t\t       SETASS_DATA_SIZEOF(arp_entry),\n\t\t\t\t       QETH_PROT_IPV4);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tcmd_entry = &__ipa_cmd(iob)->data.setassparms.data.arp_entry;\n\tether_addr_copy(cmd_entry->macaddr, entry->macaddr);\n\tmemcpy(cmd_entry->ipaddr, entry->ipaddr, 4);\n\trc = qeth_send_ipa_cmd(card, iob, qeth_l3_arp_cmd_cb, NULL);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"Could not modify (cmd: %#x) ARP entry on device %x: %#x\\n\",\n\t\t\t\t arp_cmd, CARD_DEVID(card), rc);\n\treturn rc;\n}\n\nstatic int qeth_l3_arp_flush_cache(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"arpflush\");\n\n\t \n\tif (IS_VM_NIC(card) || IS_IQD(card))\n\t\treturn -EOPNOTSUPP;\n\tif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tiob = qeth_get_setassparms_cmd(card, IPA_ARP_PROCESSING,\n\t\t\t\t       IPA_CMD_ASS_ARP_FLUSH_CACHE, 0,\n\t\t\t\t       QETH_PROT_IPV4);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\trc = qeth_send_ipa_cmd(card, iob, qeth_l3_arp_cmd_cb, NULL);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"Could not flush ARP cache on device %x: %#x\\n\",\n\t\t\t\t CARD_DEVID(card), rc);\n\treturn rc;\n}\n\nstatic int qeth_l3_ndo_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t\t      void __user *data, int cmd)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tstruct qeth_arp_cache_entry arp_entry;\n\tenum qeth_arp_process_subcmds arp_cmd;\n\tint rc = 0;\n\n\tswitch (cmd) {\n\tcase SIOC_QETH_ARP_SET_NO_ENTRIES:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\trc = qeth_l3_arp_set_no_entries(card, rq->ifr_ifru.ifru_ivalue);\n\t\tbreak;\n\tcase SIOC_QETH_ARP_QUERY_INFO:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\trc = qeth_l3_arp_query(card, data);\n\t\tbreak;\n\tcase SIOC_QETH_ARP_ADD_ENTRY:\n\tcase SIOC_QETH_ARP_REMOVE_ENTRY:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&arp_entry, data, sizeof(arp_entry)))\n\t\t\treturn -EFAULT;\n\n\t\tarp_cmd = (cmd == SIOC_QETH_ARP_ADD_ENTRY) ?\n\t\t\t\tIPA_CMD_ASS_ARP_ADD_ENTRY :\n\t\t\t\tIPA_CMD_ASS_ARP_REMOVE_ENTRY;\n\t\treturn qeth_l3_arp_modify_entry(card, &arp_entry, arp_cmd);\n\tcase SIOC_QETH_ARP_FLUSH_CACHE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\trc = qeth_l3_arp_flush_cache(card);\n\t\tbreak;\n\tdefault:\n\t\trc = qeth_siocdevprivate(dev, rq, data, cmd);\n\t}\n\treturn rc;\n}\n\nstatic int qeth_l3_get_cast_type_rcu(struct sk_buff *skb, struct dst_entry *dst,\n\t\t\t\t     __be16 proto)\n{\n\tstruct neighbour *n = NULL;\n\n\tif (dst)\n\t\tn = dst_neigh_lookup_skb(dst, skb);\n\n\tif (n) {\n\t\tint cast_type = n->type;\n\n\t\tneigh_release(n);\n\t\tif ((cast_type == RTN_BROADCAST) ||\n\t\t    (cast_type == RTN_MULTICAST) ||\n\t\t    (cast_type == RTN_ANYCAST))\n\t\t\treturn cast_type;\n\t\treturn RTN_UNICAST;\n\t}\n\n\t \n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\tif (ipv4_is_lbcast(ip_hdr(skb)->daddr))\n\t\t\treturn RTN_BROADCAST;\n\t\treturn ipv4_is_multicast(ip_hdr(skb)->daddr) ?\n\t\t\t\tRTN_MULTICAST : RTN_UNICAST;\n\tcase htons(ETH_P_IPV6):\n\t\treturn ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) ?\n\t\t\t\tRTN_MULTICAST : RTN_UNICAST;\n\tcase htons(ETH_P_AF_IUCV):\n\t\treturn RTN_UNICAST;\n\tdefault:\n\t\t \n\t\treturn qeth_get_ether_cast_type(skb);\n\t}\n}\n\nstatic int qeth_l3_get_cast_type(struct sk_buff *skb, __be16 proto)\n{\n\tstruct dst_entry *dst;\n\tint cast_type;\n\n\trcu_read_lock();\n\tdst = qeth_dst_check_rcu(skb, proto);\n\tcast_type = qeth_l3_get_cast_type_rcu(skb, dst, proto);\n\trcu_read_unlock();\n\n\treturn cast_type;\n}\n\nstatic u8 qeth_l3_cast_type_to_flag(int cast_type)\n{\n\tif (cast_type == RTN_MULTICAST)\n\t\treturn QETH_CAST_MULTICAST;\n\tif (cast_type == RTN_ANYCAST)\n\t\treturn QETH_CAST_ANYCAST;\n\tif (cast_type == RTN_BROADCAST)\n\t\treturn QETH_CAST_BROADCAST;\n\treturn QETH_CAST_UNICAST;\n}\n\nstatic void qeth_l3_fill_header(struct qeth_qdio_out_q *queue,\n\t\t\t\tstruct qeth_hdr *hdr, struct sk_buff *skb,\n\t\t\t\t__be16 proto, unsigned int data_len)\n{\n\tstruct qeth_hdr_layer3 *l3_hdr = &hdr->hdr.l3;\n\tstruct vlan_ethhdr *veth = vlan_eth_hdr(skb);\n\tstruct qeth_card *card = queue->card;\n\tstruct dst_entry *dst;\n\tint cast_type;\n\n\thdr->hdr.l3.length = data_len;\n\n\tif (skb_is_gso(skb)) {\n\t\thdr->hdr.l3.id = QETH_HEADER_TYPE_L3_TSO;\n\t} else {\n\t\thdr->hdr.l3.id = QETH_HEADER_TYPE_LAYER3;\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tqeth_tx_csum(skb, &hdr->hdr.l3.ext_flags, proto);\n\t\t\t \n\t\t\tif (proto == htons(ETH_P_IP))\n\t\t\t\thdr->hdr.l3.ext_flags |= QETH_HDR_EXT_CSUM_HDR_REQ;\n\t\t}\n\t}\n\n\tif (proto == htons(ETH_P_IP) || IS_IQD(card)) {\n\t\t \n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\thdr->hdr.l3.ext_flags |= QETH_HDR_EXT_VLAN_FRAME;\n\t\t\thdr->hdr.l3.vlan_id = skb_vlan_tag_get(skb);\n\t\t}\n\t} else if (veth->h_vlan_proto == htons(ETH_P_8021Q)) {\n\t\thdr->hdr.l3.ext_flags |= QETH_HDR_EXT_INCLUDE_VLAN_TAG;\n\t\thdr->hdr.l3.vlan_id = ntohs(veth->h_vlan_TCI);\n\t}\n\n\trcu_read_lock();\n\tdst = qeth_dst_check_rcu(skb, proto);\n\n\tif (IS_IQD(card) && skb_get_queue_mapping(skb) != QETH_IQD_MCAST_TXQ)\n\t\tcast_type = RTN_UNICAST;\n\telse\n\t\tcast_type = qeth_l3_get_cast_type_rcu(skb, dst, proto);\n\tl3_hdr->flags |= qeth_l3_cast_type_to_flag(cast_type);\n\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\tl3_hdr->next_hop.addr.s6_addr32[3] =\n\t\t\t\t\tqeth_next_hop_v4_rcu(skb, dst);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl3_hdr->next_hop.addr = *qeth_next_hop_v6_rcu(skb, dst);\n\n\t\thdr->hdr.l3.flags |= QETH_HDR_IPV6;\n\t\tif (!IS_IQD(card))\n\t\t\thdr->hdr.l3.flags |= QETH_HDR_PASSTHRU;\n\t\tbreak;\n\tcase htons(ETH_P_AF_IUCV):\n\t\tl3_hdr->next_hop.addr.s6_addr16[0] = htons(0xfe80);\n\t\tmemcpy(&l3_hdr->next_hop.addr.s6_addr32[2],\n\t\t       iucv_trans_hdr(skb)->destUserID, 8);\n\t\tl3_hdr->flags |= QETH_HDR_IPV6;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tl3_hdr->flags |= QETH_HDR_PASSTHRU;\n\t}\n\trcu_read_unlock();\n}\n\nstatic void qeth_l3_fixup_headers(struct sk_buff *skb)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tiph->check = 0;\n\tif (skb_is_gso(skb)) {\n\t\tiph->tot_len = 0;\n\t\ttcp_hdr(skb)->check = ~tcp_v4_check(0, iph->saddr,\n\t\t\t\t\t\t    iph->daddr, 0);\n\t}\n}\n\nstatic int qeth_l3_xmit(struct qeth_card *card, struct sk_buff *skb,\n\t\t\tstruct qeth_qdio_out_q *queue, __be16 proto)\n{\n\tunsigned int hw_hdr_len;\n\tint rc;\n\n\t \n\thw_hdr_len = skb_is_gso(skb) ? sizeof(struct qeth_hdr_tso) :\n\t\t\t\t       sizeof(struct qeth_hdr);\n\trc = skb_cow_head(skb, hw_hdr_len - ETH_HLEN);\n\tif (rc)\n\t\treturn rc;\n\tskb_pull(skb, ETH_HLEN);\n\n\tqeth_l3_fixup_headers(skb);\n\treturn qeth_xmit(card, skb, queue, proto, qeth_l3_fill_header);\n}\n\nstatic netdev_tx_t qeth_l3_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\t__be16 proto = vlan_get_protocol(skb);\n\tu16 txq = skb_get_queue_mapping(skb);\n\tstruct qeth_qdio_out_q *queue;\n\tint rc;\n\n\tif (!skb_is_gso(skb))\n\t\tqdisc_skb_cb(skb)->pkt_len = skb->len;\n\tif (IS_IQD(card)) {\n\t\tqueue = card->qdio.out_qs[qeth_iqd_translate_txq(dev, txq)];\n\n\t\tif (card->options.sniffer)\n\t\t\tgoto tx_drop;\n\n\t\tswitch (proto) {\n\t\tcase htons(ETH_P_AF_IUCV):\n\t\t\tif (card->options.cq != QETH_CQ_ENABLED)\n\t\t\t\tgoto tx_drop;\n\t\t\tbreak;\n\t\tcase htons(ETH_P_IP):\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tif (card->options.cq == QETH_CQ_ENABLED)\n\t\t\t\tgoto tx_drop;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto tx_drop;\n\t\t}\n\t} else {\n\t\tqueue = card->qdio.out_qs[txq];\n\t}\n\n\tif (!(dev->flags & IFF_BROADCAST) &&\n\t    qeth_l3_get_cast_type(skb, proto) == RTN_BROADCAST)\n\t\tgoto tx_drop;\n\n\tif (proto == htons(ETH_P_IP) || IS_IQD(card))\n\t\trc = qeth_l3_xmit(card, skb, queue, proto);\n\telse\n\t\trc = qeth_xmit(card, skb, queue, proto, qeth_l3_fill_header);\n\n\tif (!rc)\n\t\treturn NETDEV_TX_OK;\n\ntx_drop:\n\tQETH_TXQ_STAT_INC(queue, tx_dropped);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void qeth_l3_set_rx_mode(struct net_device *dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tschedule_work(&card->rx_mode_work);\n}\n\n \nstatic int qeth_l3_neigh_setup_noarp(struct neighbour *n)\n{\n\tn->nud_state = NUD_NOARP;\n\tmemcpy(n->ha, \"FAKELL\", 6);\n\tn->output = n->ops->connected_output;\n\treturn 0;\n}\n\nstatic int\nqeth_l3_neigh_setup(struct net_device *dev, struct neigh_parms *np)\n{\n\tif (np->tbl->family == AF_INET)\n\t\tnp->neigh_setup = qeth_l3_neigh_setup_noarp;\n\n\treturn 0;\n}\n\nstatic netdev_features_t qeth_l3_osa_features_check(struct sk_buff *skb,\n\t\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t\t    netdev_features_t features)\n{\n\tif (vlan_get_protocol(skb) != htons(ETH_P_IP))\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\treturn qeth_features_check(skb, dev, features);\n}\n\nstatic u16 qeth_l3_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t\t    struct net_device *sb_dev)\n{\n\t__be16 proto = vlan_get_protocol(skb);\n\n\treturn qeth_iqd_select_queue(dev, skb,\n\t\t\t\t     qeth_l3_get_cast_type(skb, proto), sb_dev);\n}\n\nstatic const struct net_device_ops qeth_l3_netdev_ops = {\n\t.ndo_open\t\t= qeth_open,\n\t.ndo_stop\t\t= qeth_stop,\n\t.ndo_get_stats64\t= qeth_get_stats64,\n\t.ndo_start_xmit\t\t= qeth_l3_hard_start_xmit,\n\t.ndo_select_queue\t= qeth_l3_iqd_select_queue,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= qeth_l3_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= qeth_do_ioctl,\n\t.ndo_siocdevprivate\t= qeth_l3_ndo_siocdevprivate,\n\t.ndo_fix_features\t= qeth_fix_features,\n\t.ndo_set_features\t= qeth_set_features,\n\t.ndo_tx_timeout\t\t= qeth_tx_timeout,\n};\n\nstatic const struct net_device_ops qeth_l3_osa_netdev_ops = {\n\t.ndo_open\t\t= qeth_open,\n\t.ndo_stop\t\t= qeth_stop,\n\t.ndo_get_stats64\t= qeth_get_stats64,\n\t.ndo_start_xmit\t\t= qeth_l3_hard_start_xmit,\n\t.ndo_features_check\t= qeth_l3_osa_features_check,\n\t.ndo_select_queue\t= qeth_osa_select_queue,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= qeth_l3_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= qeth_do_ioctl,\n\t.ndo_siocdevprivate\t= qeth_l3_ndo_siocdevprivate,\n\t.ndo_fix_features\t= qeth_fix_features,\n\t.ndo_set_features\t= qeth_set_features,\n\t.ndo_tx_timeout\t\t= qeth_tx_timeout,\n\t.ndo_neigh_setup\t= qeth_l3_neigh_setup,\n};\n\nstatic int qeth_l3_setup_netdev(struct qeth_card *card)\n{\n\tstruct net_device *dev = card->dev;\n\tunsigned int headroom;\n\tint rc;\n\n\tif (IS_OSD(card) || IS_OSX(card)) {\n\t\tcard->dev->netdev_ops = &qeth_l3_osa_netdev_ops;\n\n\t\t \n\t\tdev->dev_id = qeth_l3_get_unique_id(card, dev->dev_id);\n\n\t\tif (!IS_VM_NIC(card)) {\n\t\t\tcard->dev->features |= NETIF_F_SG;\n\t\t\tcard->dev->hw_features |= NETIF_F_TSO |\n\t\t\t\tNETIF_F_RXCSUM | NETIF_F_IP_CSUM;\n\t\t\tcard->dev->vlan_features |= NETIF_F_TSO |\n\t\t\t\tNETIF_F_RXCSUM | NETIF_F_IP_CSUM;\n\t\t}\n\n\t\tif (qeth_is_supported6(card, IPA_OUTBOUND_CHECKSUM_V6)) {\n\t\t\tcard->dev->hw_features |= NETIF_F_IPV6_CSUM;\n\t\t\tcard->dev->vlan_features |= NETIF_F_IPV6_CSUM;\n\t\t}\n\t\tif (qeth_is_supported6(card, IPA_OUTBOUND_TSO)) {\n\t\t\tcard->dev->hw_features |= NETIF_F_TSO6;\n\t\t\tcard->dev->vlan_features |= NETIF_F_TSO6;\n\t\t}\n\n\t\t \n\t\tif (card->dev->hw_features & NETIF_F_TSO6)\n\t\t\theadroom = sizeof(struct qeth_hdr_tso) + VLAN_HLEN;\n\t\telse if (card->dev->hw_features & NETIF_F_TSO)\n\t\t\theadroom = sizeof(struct qeth_hdr_tso);\n\t\telse\n\t\t\theadroom = sizeof(struct qeth_hdr) + VLAN_HLEN;\n\t} else if (IS_IQD(card)) {\n\t\tcard->dev->flags |= IFF_NOARP;\n\t\tcard->dev->netdev_ops = &qeth_l3_netdev_ops;\n\t\theadroom = sizeof(struct qeth_hdr) - ETH_HLEN;\n\n\t\trc = qeth_l3_iqd_read_initial_mac(card);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else\n\t\treturn -ENODEV;\n\n\tcard->dev->needed_headroom = headroom;\n\tcard->dev->features |=\tNETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\tNETIF_F_HW_VLAN_CTAG_RX;\n\n\tnetif_keep_dst(card->dev);\n\tif (card->dev->hw_features & (NETIF_F_TSO | NETIF_F_TSO6))\n\t\tnetif_set_tso_max_size(card->dev,\n\t\t\t\t       PAGE_SIZE * (QETH_MAX_BUFFER_ELEMENTS(card) - 1));\n\n\tnetif_napi_add(card->dev, &card->napi, qeth_poll);\n\treturn register_netdev(card->dev);\n}\n\nstatic const struct device_type qeth_l3_devtype = {\n\t.name = \"qeth_layer3\",\n\t.groups = qeth_l3_attr_groups,\n};\n\nstatic int qeth_l3_probe_device(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tint rc;\n\n\thash_init(card->ip_htable);\n\tmutex_init(&card->ip_lock);\n\tcard->cmd_wq = alloc_ordered_workqueue(\"%s_cmd\", 0,\n\t\t\t\t\t       dev_name(&gdev->dev));\n\tif (!card->cmd_wq)\n\t\treturn -ENOMEM;\n\n\tif (gdev->dev.type) {\n\t\trc = device_add_groups(&gdev->dev, qeth_l3_attr_groups);\n\t\tif (rc) {\n\t\t\tdestroy_workqueue(card->cmd_wq);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tgdev->dev.type = &qeth_l3_devtype;\n\t}\n\n\tINIT_WORK(&card->rx_mode_work, qeth_l3_rx_mode_work);\n\treturn 0;\n}\n\nstatic void qeth_l3_remove_device(struct ccwgroup_device *cgdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&cgdev->dev);\n\n\tif (cgdev->dev.type != &qeth_l3_devtype)\n\t\tdevice_remove_groups(&cgdev->dev, qeth_l3_attr_groups);\n\n\tqeth_set_allowed_threads(card, 0, 1);\n\twait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);\n\n\tif (cgdev->state == CCWGROUP_ONLINE)\n\t\tqeth_set_offline(card, card->discipline, false);\n\n\tif (card->dev->reg_state == NETREG_REGISTERED)\n\t\tunregister_netdev(card->dev);\n\n\tdestroy_workqueue(card->cmd_wq);\n\tqeth_l3_clear_ip_htable(card, 0);\n\tqeth_l3_clear_ipato_list(card);\n}\n\nstatic int qeth_l3_set_online(struct qeth_card *card, bool carrier_ok)\n{\n\tstruct net_device *dev = card->dev;\n\tint rc = 0;\n\n\t \n\tQETH_CARD_TEXT(card, 2, \"softsetp\");\n\n\trc = qeth_l3_setadapter_parms(card);\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"2err%04x\", rc);\n\tif (!card->options.sniffer) {\n\t\tqeth_l3_start_ipassists(card);\n\n\t\trc = qeth_l3_setrouting_v4(card);\n\t\tif (rc)\n\t\t\tQETH_CARD_TEXT_(card, 2, \"4err%04x\", rc);\n\t\trc = qeth_l3_setrouting_v6(card);\n\t\tif (rc)\n\t\t\tQETH_CARD_TEXT_(card, 2, \"5err%04x\", rc);\n\t}\n\n\tcard->state = CARD_STATE_SOFTSETUP;\n\n\tqeth_set_allowed_threads(card, 0xffffffff, 0);\n\tqeth_l3_recover_ip(card);\n\n\tif (dev->reg_state != NETREG_REGISTERED) {\n\t\trc = qeth_l3_setup_netdev(card);\n\t\tif (rc)\n\t\t\tgoto err_setup;\n\n\t\tif (carrier_ok)\n\t\t\tnetif_carrier_on(dev);\n\t} else {\n\t\trtnl_lock();\n\t\trc = qeth_set_real_num_tx_queues(card,\n\t\t\t\t\t\t qeth_tx_actual_queues(card));\n\t\tif (rc) {\n\t\t\trtnl_unlock();\n\t\t\tgoto err_set_queues;\n\t\t}\n\n\t\tif (carrier_ok)\n\t\t\tnetif_carrier_on(dev);\n\t\telse\n\t\t\tnetif_carrier_off(dev);\n\n\t\tnetif_device_attach(dev);\n\t\tqeth_enable_hw_features(dev);\n\n\t\tif (netif_running(dev)) {\n\t\t\tlocal_bh_disable();\n\t\t\tnapi_schedule(&card->napi);\n\t\t\t \n\t\t\tlocal_bh_enable();\n\t\t}\n\t\trtnl_unlock();\n\t}\n\treturn 0;\n\nerr_set_queues:\nerr_setup:\n\tqeth_set_allowed_threads(card, 0, 1);\n\tcard->state = CARD_STATE_DOWN;\n\tqeth_l3_clear_ip_htable(card, 1);\n\treturn rc;\n}\n\nstatic void qeth_l3_set_offline(struct qeth_card *card)\n{\n\tqeth_set_allowed_threads(card, 0, 1);\n\tqeth_l3_drain_rx_mode_cache(card);\n\n\tif (card->options.sniffer &&\n\t    (card->info.promisc_mode == SET_PROMISC_MODE_ON))\n\t\tqeth_diags_trace(card, QETH_DIAGS_CMD_TRACE_DISABLE);\n\n\tif (card->state == CARD_STATE_SOFTSETUP) {\n\t\tcard->state = CARD_STATE_DOWN;\n\t\tqeth_l3_clear_ip_htable(card, 1);\n\t}\n}\n\n \nstatic int qeth_l3_control_event(struct qeth_card *card,\n\t\t\t\t\tstruct qeth_ipa_cmd *cmd)\n{\n\treturn 1;\n}\n\nconst struct qeth_discipline qeth_l3_discipline = {\n\t.setup = qeth_l3_probe_device,\n\t.remove = qeth_l3_remove_device,\n\t.set_online = qeth_l3_set_online,\n\t.set_offline = qeth_l3_set_offline,\n\t.control_event_handler = qeth_l3_control_event,\n};\nEXPORT_SYMBOL_GPL(qeth_l3_discipline);\n\nstatic int qeth_l3_handle_ip_event(struct qeth_card *card,\n\t\t\t\t   struct qeth_ipaddr *addr,\n\t\t\t\t   unsigned long event)\n{\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tqeth_l3_modify_ip(card, addr, true);\n\t\treturn NOTIFY_OK;\n\tcase NETDEV_DOWN:\n\t\tqeth_l3_modify_ip(card, addr, false);\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstruct qeth_l3_ip_event_work {\n\tstruct work_struct work;\n\tstruct qeth_card *card;\n\tstruct qeth_ipaddr addr;\n};\n\n#define to_ip_work(w) container_of((w), struct qeth_l3_ip_event_work, work)\n\nstatic void qeth_l3_add_ip_worker(struct work_struct *work)\n{\n\tstruct qeth_l3_ip_event_work *ip_work = to_ip_work(work);\n\n\tqeth_l3_modify_ip(ip_work->card, &ip_work->addr, true);\n\tkfree(work);\n}\n\nstatic void qeth_l3_delete_ip_worker(struct work_struct *work)\n{\n\tstruct qeth_l3_ip_event_work *ip_work = to_ip_work(work);\n\n\tqeth_l3_modify_ip(ip_work->card, &ip_work->addr, false);\n\tkfree(work);\n}\n\nstatic struct qeth_card *qeth_l3_get_card_from_dev(struct net_device *dev)\n{\n\tif (is_vlan_dev(dev))\n\t\tdev = vlan_dev_real_dev(dev);\n\tif (dev->netdev_ops == &qeth_l3_osa_netdev_ops ||\n\t    dev->netdev_ops == &qeth_l3_netdev_ops)\n\t\treturn (struct qeth_card *) dev->ml_priv;\n\treturn NULL;\n}\n\nstatic int qeth_l3_ip_event(struct notifier_block *this,\n\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct qeth_ipaddr addr;\n\tstruct qeth_card *card;\n\n\tcard = qeth_l3_get_card_from_dev(dev);\n\tif (!card)\n\t\treturn NOTIFY_DONE;\n\tQETH_CARD_TEXT(card, 3, \"ipevent\");\n\n\tqeth_l3_init_ipaddr(&addr, QETH_IP_TYPE_NORMAL, QETH_PROT_IPV4);\n\taddr.u.a4.addr = ifa->ifa_address;\n\taddr.u.a4.mask = ifa->ifa_mask;\n\n\treturn qeth_l3_handle_ip_event(card, &addr, event);\n}\n\nstatic struct notifier_block qeth_l3_ip_notifier = {\n\tqeth_l3_ip_event,\n\tNULL,\n};\n\nstatic int qeth_l3_ip6_event(struct notifier_block *this,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->idev->dev;\n\tstruct qeth_l3_ip_event_work *ip_work;\n\tstruct qeth_card *card;\n\n\tif (event != NETDEV_UP && event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tcard = qeth_l3_get_card_from_dev(dev);\n\tif (!card)\n\t\treturn NOTIFY_DONE;\n\tQETH_CARD_TEXT(card, 3, \"ip6event\");\n\tif (!qeth_is_supported(card, IPA_IPV6))\n\t\treturn NOTIFY_DONE;\n\n\tip_work = kmalloc(sizeof(*ip_work), GFP_ATOMIC);\n\tif (!ip_work)\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_UP)\n\t\tINIT_WORK(&ip_work->work, qeth_l3_add_ip_worker);\n\telse\n\t\tINIT_WORK(&ip_work->work, qeth_l3_delete_ip_worker);\n\n\tip_work->card = card;\n\tqeth_l3_init_ipaddr(&ip_work->addr, QETH_IP_TYPE_NORMAL,\n\t\t\t    QETH_PROT_IPV6);\n\tip_work->addr.u.a6.addr = ifa->addr;\n\tip_work->addr.u.a6.pfxlen = ifa->prefix_len;\n\n\tqueue_work(card->cmd_wq, &ip_work->work);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block qeth_l3_ip6_notifier = {\n\tqeth_l3_ip6_event,\n\tNULL,\n};\n\nstatic int qeth_l3_register_notifiers(void)\n{\n\tint rc;\n\n\tQETH_DBF_TEXT(SETUP, 5, \"regnotif\");\n\trc = register_inetaddr_notifier(&qeth_l3_ip_notifier);\n\tif (rc)\n\t\treturn rc;\n\trc = register_inet6addr_notifier(&qeth_l3_ip6_notifier);\n\tif (rc) {\n\t\tunregister_inetaddr_notifier(&qeth_l3_ip_notifier);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void qeth_l3_unregister_notifiers(void)\n{\n\tQETH_DBF_TEXT(SETUP, 5, \"unregnot\");\n\tWARN_ON(unregister_inetaddr_notifier(&qeth_l3_ip_notifier));\n\tWARN_ON(unregister_inet6addr_notifier(&qeth_l3_ip6_notifier));\n}\n\nstatic int __init qeth_l3_init(void)\n{\n\tpr_info(\"register layer 3 discipline\\n\");\n\treturn qeth_l3_register_notifiers();\n}\n\nstatic void __exit qeth_l3_exit(void)\n{\n\tqeth_l3_unregister_notifiers();\n\tpr_info(\"unregister layer 3 discipline\\n\");\n}\n\nmodule_init(qeth_l3_init);\nmodule_exit(qeth_l3_exit);\nMODULE_AUTHOR(\"Frank Blaschka <frank.blaschka@de.ibm.com>\");\nMODULE_DESCRIPTION(\"qeth layer 3 discipline\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}