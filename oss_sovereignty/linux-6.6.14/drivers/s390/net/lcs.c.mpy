{
  "module_name": "lcs.c",
  "hash_id": "147eb6958625e77d5b65057f62c0cfd58cafc8664cdb4bae73ba7d7328acb4a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/lcs.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT\t\t\"lcs\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/if.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/in.h>\n#include <linux/igmp.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <net/arp.h>\n#include <net/ip.h>\n\n#include <asm/debug.h>\n#include <asm/idals.h>\n#include <asm/timex.h>\n#include <linux/device.h>\n#include <asm/ccwgroup.h>\n\n#include \"lcs.h\"\n\n\n \n\nstatic char version[] __initdata = \"LCS driver\";\n\n \nstatic struct device *lcs_root_dev;\n\n \nstatic void lcs_tasklet(unsigned long);\nstatic void lcs_start_kernel_thread(struct work_struct *);\nstatic void lcs_get_frames_cb(struct lcs_channel *, struct lcs_buffer *);\n#ifdef CONFIG_IP_MULTICAST\nstatic int lcs_send_delipm(struct lcs_card *, struct lcs_ipm_list *);\n#endif  \nstatic int lcs_recovery(void *ptr);\n\n \nstatic char debug_buffer[255];\nstatic debug_info_t *lcs_dbf_setup;\nstatic debug_info_t *lcs_dbf_trace;\n\n \nstatic void\nlcs_unregister_debug_facility(void)\n{\n\tdebug_unregister(lcs_dbf_setup);\n\tdebug_unregister(lcs_dbf_trace);\n}\n\nstatic int\nlcs_register_debug_facility(void)\n{\n\tlcs_dbf_setup = debug_register(\"lcs_setup\", 2, 1, 8);\n\tlcs_dbf_trace = debug_register(\"lcs_trace\", 4, 1, 8);\n\tif (lcs_dbf_setup == NULL || lcs_dbf_trace == NULL) {\n\t\tpr_err(\"Not enough memory for debug facility.\\n\");\n\t\tlcs_unregister_debug_facility();\n\t\treturn -ENOMEM;\n\t}\n\tdebug_register_view(lcs_dbf_setup, &debug_hex_ascii_view);\n\tdebug_set_level(lcs_dbf_setup, 2);\n\tdebug_register_view(lcs_dbf_trace, &debug_hex_ascii_view);\n\tdebug_set_level(lcs_dbf_trace, 2);\n\treturn 0;\n}\n\n \nstatic int\nlcs_alloc_channel(struct lcs_channel *channel)\n{\n\tint cnt;\n\n\tLCS_DBF_TEXT(2, setup, \"ichalloc\");\n\tfor (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {\n\t\t \n\t\tchannel->iob[cnt].data =\n\t\t\tkzalloc(LCS_IOBUFFERSIZE, GFP_DMA | GFP_KERNEL);\n\t\tif (channel->iob[cnt].data == NULL)\n\t\t\tbreak;\n\t\tchannel->iob[cnt].state = LCS_BUF_STATE_EMPTY;\n\t}\n\tif (cnt < LCS_NUM_BUFFS) {\n\t\t \n\t\tLCS_DBF_TEXT(2, setup, \"echalloc\");\n\t\twhile (cnt-- > 0)\n\t\t\tkfree(channel->iob[cnt].data);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic void\nlcs_free_channel(struct lcs_channel *channel)\n{\n\tint cnt;\n\n\tLCS_DBF_TEXT(2, setup, \"ichfree\");\n\tfor (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {\n\t\tkfree(channel->iob[cnt].data);\n\t\tchannel->iob[cnt].data = NULL;\n\t}\n}\n\n \nstatic void\nlcs_cleanup_channel(struct lcs_channel *channel)\n{\n\tLCS_DBF_TEXT(3, setup, \"cleanch\");\n\t \n\ttasklet_kill(&channel->irq_tasklet);\n\t \n\tlcs_free_channel(channel);\n}\n\n \nstatic void\nlcs_free_card(struct lcs_card *card)\n{\n\tLCS_DBF_TEXT(2, setup, \"remcard\");\n\tLCS_DBF_HEX(2, setup, &card, sizeof(void*));\n\tkfree(card);\n}\n\n \nstatic struct lcs_card *\nlcs_alloc_card(void)\n{\n\tstruct lcs_card *card;\n\tint rc;\n\n\tLCS_DBF_TEXT(2, setup, \"alloclcs\");\n\n\tcard = kzalloc(sizeof(struct lcs_card), GFP_KERNEL | GFP_DMA);\n\tif (card == NULL)\n\t\treturn NULL;\n\tcard->lan_type = LCS_FRAME_TYPE_AUTO;\n\tcard->pkt_seq = 0;\n\tcard->lancmd_timeout = LCS_LANCMD_TIMEOUT_DEFAULT;\n\t \n\trc = lcs_alloc_channel(&card->read);\n\tif (rc){\n\t\tLCS_DBF_TEXT(2, setup, \"iccwerr\");\n\t\tlcs_free_card(card);\n\t\treturn NULL;\n\t}\n\t \n\trc = lcs_alloc_channel(&card->write);\n\tif (rc) {\n\t\tLCS_DBF_TEXT(2, setup, \"iccwerr\");\n\t\tlcs_cleanup_channel(&card->read);\n\t\tlcs_free_card(card);\n\t\treturn NULL;\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tINIT_LIST_HEAD(&card->ipm_list);\n#endif\n\tLCS_DBF_HEX(2, setup, &card, sizeof(void*));\n\treturn card;\n}\n\n \nstatic void\nlcs_setup_read_ccws(struct lcs_card *card)\n{\n\tint cnt;\n\n\tLCS_DBF_TEXT(2, setup, \"ireadccw\");\n\t \n\tmemset(card->read.ccws, 0, sizeof (struct ccw1) * (LCS_NUM_BUFFS + 1));\n\tfor (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {\n\t\tcard->read.ccws[cnt].cmd_code = LCS_CCW_READ;\n\t\tcard->read.ccws[cnt].count = LCS_IOBUFFERSIZE;\n\t\tcard->read.ccws[cnt].flags =\n\t\t\tCCW_FLAG_CC | CCW_FLAG_SLI | CCW_FLAG_PCI;\n\t\t \n\t\tcard->read.ccws[cnt].cda =\n\t\t\t(__u32)virt_to_phys(card->read.iob[cnt].data);\n\t\t((struct lcs_header *)\n\t\t card->read.iob[cnt].data)->offset = LCS_ILLEGAL_OFFSET;\n\t\tcard->read.iob[cnt].callback = lcs_get_frames_cb;\n\t\tcard->read.iob[cnt].state = LCS_BUF_STATE_READY;\n\t\tcard->read.iob[cnt].count = LCS_IOBUFFERSIZE;\n\t}\n\tcard->read.ccws[0].flags &= ~CCW_FLAG_PCI;\n\tcard->read.ccws[LCS_NUM_BUFFS - 1].flags &= ~CCW_FLAG_PCI;\n\tcard->read.ccws[LCS_NUM_BUFFS - 1].flags |= CCW_FLAG_SUSPEND;\n\t \n\tcard->read.ccws[LCS_NUM_BUFFS].cmd_code = LCS_CCW_TRANSFER;\n\tcard->read.ccws[LCS_NUM_BUFFS].cda =\n\t\t(__u32)virt_to_phys(card->read.ccws);\n\t \n\tcard->read.state = LCS_CH_STATE_INIT;\n\n\tcard->read.io_idx = 0;\n\tcard->read.buf_idx = 0;\n}\n\nstatic void\nlcs_setup_read(struct lcs_card *card)\n{\n\tLCS_DBF_TEXT(3, setup, \"initread\");\n\n\tlcs_setup_read_ccws(card);\n\t \n\tcard->read.irq_tasklet.data = (unsigned long) &card->read;\n\tcard->read.irq_tasklet.func = lcs_tasklet;\n\t \n\tinit_waitqueue_head(&card->read.wait_q);\n}\n\n \nstatic void\nlcs_setup_write_ccws(struct lcs_card *card)\n{\n\tint cnt;\n\n\tLCS_DBF_TEXT(3, setup, \"iwritccw\");\n\t \n\tmemset(card->write.ccws, 0, sizeof(struct ccw1) * (LCS_NUM_BUFFS + 1));\n\tfor (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {\n\t\tcard->write.ccws[cnt].cmd_code = LCS_CCW_WRITE;\n\t\tcard->write.ccws[cnt].count = 0;\n\t\tcard->write.ccws[cnt].flags =\n\t\t\tCCW_FLAG_SUSPEND | CCW_FLAG_CC | CCW_FLAG_SLI;\n\t\t \n\t\tcard->write.ccws[cnt].cda =\n\t\t\t(__u32)virt_to_phys(card->write.iob[cnt].data);\n\t}\n\t \n\tcard->write.ccws[LCS_NUM_BUFFS].cmd_code = LCS_CCW_TRANSFER;\n\tcard->write.ccws[LCS_NUM_BUFFS].cda =\n\t\t(__u32)virt_to_phys(card->write.ccws);\n\t \n\tcard->read.state = LCS_CH_STATE_INIT;\n\n\tcard->write.io_idx = 0;\n\tcard->write.buf_idx = 0;\n}\n\nstatic void\nlcs_setup_write(struct lcs_card *card)\n{\n\tLCS_DBF_TEXT(3, setup, \"initwrit\");\n\n\tlcs_setup_write_ccws(card);\n\t \n\tcard->write.irq_tasklet.data = (unsigned long) &card->write;\n\tcard->write.irq_tasklet.func = lcs_tasklet;\n\t \n\tinit_waitqueue_head(&card->write.wait_q);\n}\n\nstatic void\nlcs_set_allowed_threads(struct lcs_card *card, unsigned long threads)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->mask_lock, flags);\n\tcard->thread_allowed_mask = threads;\n\tspin_unlock_irqrestore(&card->mask_lock, flags);\n\twake_up(&card->wait_q);\n}\nstatic int lcs_threads_running(struct lcs_card *card, unsigned long threads)\n{\n        unsigned long flags;\n        int rc = 0;\n\n\tspin_lock_irqsave(&card->mask_lock, flags);\n        rc = (card->thread_running_mask & threads);\n\tspin_unlock_irqrestore(&card->mask_lock, flags);\n        return rc;\n}\n\nstatic int\nlcs_wait_for_threads(struct lcs_card *card, unsigned long threads)\n{\n        return wait_event_interruptible(card->wait_q,\n                        lcs_threads_running(card, threads) == 0);\n}\n\nstatic int lcs_set_thread_start_bit(struct lcs_card *card, unsigned long thread)\n{\n        unsigned long flags;\n\n\tspin_lock_irqsave(&card->mask_lock, flags);\n        if ( !(card->thread_allowed_mask & thread) ||\n              (card->thread_start_mask & thread) ) {\n                spin_unlock_irqrestore(&card->mask_lock, flags);\n                return -EPERM;\n        }\n        card->thread_start_mask |= thread;\n\tspin_unlock_irqrestore(&card->mask_lock, flags);\n        return 0;\n}\n\nstatic void\nlcs_clear_thread_running_bit(struct lcs_card *card, unsigned long thread)\n{\n        unsigned long flags;\n\n\tspin_lock_irqsave(&card->mask_lock, flags);\n        card->thread_running_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->mask_lock, flags);\n        wake_up(&card->wait_q);\n}\n\nstatic int __lcs_do_run_thread(struct lcs_card *card, unsigned long thread)\n{\n        unsigned long flags;\n        int rc = 0;\n\n\tspin_lock_irqsave(&card->mask_lock, flags);\n        if (card->thread_start_mask & thread){\n                if ((card->thread_allowed_mask & thread) &&\n                    !(card->thread_running_mask & thread)){\n                        rc = 1;\n                        card->thread_start_mask &= ~thread;\n                        card->thread_running_mask |= thread;\n                } else\n                        rc = -EPERM;\n        }\n\tspin_unlock_irqrestore(&card->mask_lock, flags);\n        return rc;\n}\n\nstatic int\nlcs_do_run_thread(struct lcs_card *card, unsigned long thread)\n{\n        int rc = 0;\n        wait_event(card->wait_q,\n                   (rc = __lcs_do_run_thread(card, thread)) >= 0);\n        return rc;\n}\n\nstatic int\nlcs_do_start_thread(struct lcs_card *card, unsigned long thread)\n{\n        unsigned long flags;\n        int rc = 0;\n\n\tspin_lock_irqsave(&card->mask_lock, flags);\n        LCS_DBF_TEXT_(4, trace, \"  %02x%02x%02x\",\n                        (u8) card->thread_start_mask,\n                        (u8) card->thread_allowed_mask,\n                        (u8) card->thread_running_mask);\n        rc = (card->thread_start_mask & thread);\n\tspin_unlock_irqrestore(&card->mask_lock, flags);\n        return rc;\n}\n\n \nstatic void\nlcs_setup_card(struct lcs_card *card)\n{\n\tLCS_DBF_TEXT(2, setup, \"initcard\");\n\tLCS_DBF_HEX(2, setup, &card, sizeof(void*));\n\n\tlcs_setup_read(card);\n\tlcs_setup_write(card);\n\t \n\tcard->state = DEV_STATE_DOWN;\n\tcard->tx_buffer = NULL;\n\tcard->tx_emitted = 0;\n\n\tinit_waitqueue_head(&card->wait_q);\n\tspin_lock_init(&card->lock);\n\tspin_lock_init(&card->ipm_lock);\n\tspin_lock_init(&card->mask_lock);\n#ifdef CONFIG_IP_MULTICAST\n\tINIT_LIST_HEAD(&card->ipm_list);\n#endif\n\tINIT_LIST_HEAD(&card->lancmd_waiters);\n}\n\nstatic void lcs_clear_multicast_list(struct lcs_card *card)\n{\n#ifdef\tCONFIG_IP_MULTICAST\n\tstruct lcs_ipm_list *ipm;\n\tunsigned long flags;\n\n\t \n\tLCS_DBF_TEXT(3, setup, \"clmclist\");\n\tspin_lock_irqsave(&card->ipm_lock, flags);\n\twhile (!list_empty(&card->ipm_list)){\n\t\tipm = list_entry(card->ipm_list.next,\n\t\t\t\t struct lcs_ipm_list, list);\n\t\tlist_del(&ipm->list);\n\t\tif (ipm->ipm_state != LCS_IPM_STATE_SET_REQUIRED){\n\t\t\tspin_unlock_irqrestore(&card->ipm_lock, flags);\n\t\t\tlcs_send_delipm(card, ipm);\n\t\t\tspin_lock_irqsave(&card->ipm_lock, flags);\n\t\t}\n\t\tkfree(ipm);\n\t}\n\tspin_unlock_irqrestore(&card->ipm_lock, flags);\n#endif\n}\n\n \nstatic void\nlcs_cleanup_card(struct lcs_card *card)\n{\n\n\tLCS_DBF_TEXT(3, setup, \"cleancrd\");\n\tLCS_DBF_HEX(2,setup,&card,sizeof(void*));\n\n\tif (card->dev != NULL)\n\t\tfree_netdev(card->dev);\n\t \n\tlcs_cleanup_channel(&card->write);\n\tlcs_cleanup_channel(&card->read);\n}\n\n \nstatic int\nlcs_start_channel(struct lcs_channel *channel)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tLCS_DBF_TEXT_(4, trace,\"ssch%s\", dev_name(&channel->ccwdev->dev));\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_start(channel->ccwdev,\n\t\t\t      channel->ccws + channel->io_idx, 0, 0,\n\t\t\t      DOIO_DENY_PREFETCH | DOIO_ALLOW_SUSPEND);\n\tif (rc == 0)\n\t\tchannel->state = LCS_CH_STATE_RUNNING;\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\tif (rc) {\n\t\tLCS_DBF_TEXT_(4,trace,\"essh%s\",\n\t\t\t      dev_name(&channel->ccwdev->dev));\n\t\tdev_err(&channel->ccwdev->dev,\n\t\t\t\"Starting an LCS device resulted in an error,\"\n\t\t\t\" rc=%d!\\n\", rc);\n\t}\n\treturn rc;\n}\n\nstatic int\nlcs_clear_channel(struct lcs_channel *channel)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tLCS_DBF_TEXT(4,trace,\"clearch\");\n\tLCS_DBF_TEXT_(4, trace, \"%s\", dev_name(&channel->ccwdev->dev));\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_clear(channel->ccwdev, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\tif (rc) {\n\t\tLCS_DBF_TEXT_(4, trace, \"ecsc%s\",\n\t\t\t      dev_name(&channel->ccwdev->dev));\n\t\treturn rc;\n\t}\n\twait_event(channel->wait_q, (channel->state == LCS_CH_STATE_CLEARED));\n\tchannel->state = LCS_CH_STATE_STOPPED;\n\treturn rc;\n}\n\n\n \nstatic int\nlcs_stop_channel(struct lcs_channel *channel)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tif (channel->state == LCS_CH_STATE_STOPPED)\n\t\treturn 0;\n\tLCS_DBF_TEXT(4,trace,\"haltsch\");\n\tLCS_DBF_TEXT_(4, trace, \"%s\", dev_name(&channel->ccwdev->dev));\n\tchannel->state = LCS_CH_STATE_INIT;\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\trc = ccw_device_halt(channel->ccwdev, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\tif (rc) {\n\t\tLCS_DBF_TEXT_(4, trace, \"ehsc%s\",\n\t\t\t      dev_name(&channel->ccwdev->dev));\n\t\treturn rc;\n\t}\n\t \n\twait_event(channel->wait_q, (channel->state == LCS_CH_STATE_HALTED));\n\tlcs_clear_channel(channel);\n\treturn 0;\n}\n\n \nstatic int\nlcs_start_channels(struct lcs_card *card)\n{\n\tint rc;\n\n\tLCS_DBF_TEXT(2, trace, \"chstart\");\n\t \n\trc = lcs_start_channel(&card->read);\n\tif (rc)\n\t\treturn rc;\n\t \n\trc = lcs_start_channel(&card->write);\n\tif (rc)\n\t\tlcs_stop_channel(&card->read);\n\treturn rc;\n}\n\n \nstatic int\nlcs_stop_channels(struct lcs_card *card)\n{\n\tLCS_DBF_TEXT(2, trace, \"chhalt\");\n\tlcs_stop_channel(&card->read);\n\tlcs_stop_channel(&card->write);\n\treturn 0;\n}\n\n \nstatic struct lcs_buffer *\n__lcs_get_buffer(struct lcs_channel *channel)\n{\n\tint index;\n\n\tLCS_DBF_TEXT(5, trace, \"_getbuff\");\n\tindex = channel->io_idx;\n\tdo {\n\t\tif (channel->iob[index].state == LCS_BUF_STATE_EMPTY) {\n\t\t\tchannel->iob[index].state = LCS_BUF_STATE_LOCKED;\n\t\t\treturn channel->iob + index;\n\t\t}\n\t\tindex = (index + 1) & (LCS_NUM_BUFFS - 1);\n\t} while (index != channel->io_idx);\n\treturn NULL;\n}\n\nstatic struct lcs_buffer *\nlcs_get_buffer(struct lcs_channel *channel)\n{\n\tstruct lcs_buffer *buffer;\n\tunsigned long flags;\n\n\tLCS_DBF_TEXT(5, trace, \"getbuff\");\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\tbuffer = __lcs_get_buffer(channel);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\treturn buffer;\n}\n\n \nstatic int\n__lcs_resume_channel(struct lcs_channel *channel)\n{\n\tint rc;\n\n\tif (channel->state != LCS_CH_STATE_SUSPENDED)\n\t\treturn 0;\n\tif (channel->ccws[channel->io_idx].flags & CCW_FLAG_SUSPEND)\n\t\treturn 0;\n\tLCS_DBF_TEXT_(5, trace, \"rsch%s\", dev_name(&channel->ccwdev->dev));\n\trc = ccw_device_resume(channel->ccwdev);\n\tif (rc) {\n\t\tLCS_DBF_TEXT_(4, trace, \"ersc%s\",\n\t\t\t      dev_name(&channel->ccwdev->dev));\n\t\tdev_err(&channel->ccwdev->dev,\n\t\t\t\"Sending data from the LCS device to the LAN failed\"\n\t\t\t\" with rc=%d\\n\",rc);\n\t} else\n\t\tchannel->state = LCS_CH_STATE_RUNNING;\n\treturn rc;\n\n}\n\n \nstatic void __lcs_ready_buffer_bits(struct lcs_channel *channel, int index)\n{\n\tint prev, next;\n\n\tLCS_DBF_TEXT(5, trace, \"rdybits\");\n\tprev = (index - 1) & (LCS_NUM_BUFFS - 1);\n\tnext = (index + 1) & (LCS_NUM_BUFFS - 1);\n\t \n\tif (channel->ccws[next].flags & CCW_FLAG_SUSPEND) {\n\t\t \n\t\tif (!(channel->ccws[prev].flags & CCW_FLAG_SUSPEND))\n\t\t\t \n\t\t\tchannel->ccws[index].flags |= CCW_FLAG_PCI;\n\t\t \n\t\tchannel->ccws[index].flags &= ~CCW_FLAG_SUSPEND;\n\t}\n}\n\nstatic int\nlcs_ready_buffer(struct lcs_channel *channel, struct lcs_buffer *buffer)\n{\n\tunsigned long flags;\n\tint index, rc;\n\n\tLCS_DBF_TEXT(5, trace, \"rdybuff\");\n\tBUG_ON(buffer->state != LCS_BUF_STATE_LOCKED &&\n\t       buffer->state != LCS_BUF_STATE_PROCESSED);\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\tbuffer->state = LCS_BUF_STATE_READY;\n\tindex = buffer - channel->iob;\n\t \n\tchannel->ccws[index].count = buffer->count;\n\t \n\t__lcs_ready_buffer_bits(channel, index);\n\trc = __lcs_resume_channel(channel);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\treturn rc;\n}\n\n \nstatic int\n__lcs_processed_buffer(struct lcs_channel *channel, struct lcs_buffer *buffer)\n{\n\tint index, prev, next;\n\n\tLCS_DBF_TEXT(5, trace, \"prcsbuff\");\n\tBUG_ON(buffer->state != LCS_BUF_STATE_READY);\n\tbuffer->state = LCS_BUF_STATE_PROCESSED;\n\tindex = buffer - channel->iob;\n\tprev = (index - 1) & (LCS_NUM_BUFFS - 1);\n\tnext = (index + 1) & (LCS_NUM_BUFFS - 1);\n\t \n\tchannel->ccws[index].flags |= CCW_FLAG_SUSPEND;\n\tchannel->ccws[index].flags &= ~CCW_FLAG_PCI;\n\t \n\tif (channel->iob[prev].state == LCS_BUF_STATE_READY) {\n\t\t \n\t\t__lcs_ready_buffer_bits(channel, prev);\n\t}\n\t \n\tchannel->ccws[next].flags &= ~CCW_FLAG_PCI;\n\treturn __lcs_resume_channel(channel);\n}\n\n \nstatic void\nlcs_release_buffer(struct lcs_channel *channel, struct lcs_buffer *buffer)\n{\n\tunsigned long flags;\n\n\tLCS_DBF_TEXT(5, trace, \"relbuff\");\n\tBUG_ON(buffer->state != LCS_BUF_STATE_LOCKED &&\n\t       buffer->state != LCS_BUF_STATE_PROCESSED);\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\tbuffer->state = LCS_BUF_STATE_EMPTY;\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n}\n\n \nstatic struct lcs_buffer *\nlcs_get_lancmd(struct lcs_card *card, int count)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\n\tLCS_DBF_TEXT(4, trace, \"getlncmd\");\n\t \n\twait_event(card->write.wait_q,\n\t\t   ((buffer = lcs_get_buffer(&card->write)) != NULL));\n\tcount += sizeof(struct lcs_header);\n\t*(__u16 *)(buffer->data + count) = 0;\n\tbuffer->count = count + sizeof(__u16);\n\tbuffer->callback = lcs_release_buffer;\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->offset = count;\n\tcmd->type = LCS_FRAME_TYPE_CONTROL;\n\tcmd->slot = 0;\n\treturn buffer;\n}\n\n\nstatic void\nlcs_get_reply(struct lcs_reply *reply)\n{\n\trefcount_inc(&reply->refcnt);\n}\n\nstatic void\nlcs_put_reply(struct lcs_reply *reply)\n{\n\tif (refcount_dec_and_test(&reply->refcnt))\n\t\tkfree(reply);\n}\n\nstatic struct lcs_reply *\nlcs_alloc_reply(struct lcs_cmd *cmd)\n{\n\tstruct lcs_reply *reply;\n\n\tLCS_DBF_TEXT(4, trace, \"getreply\");\n\n\treply = kzalloc(sizeof(struct lcs_reply), GFP_ATOMIC);\n\tif (!reply)\n\t\treturn NULL;\n\trefcount_set(&reply->refcnt, 1);\n\treply->sequence_no = cmd->sequence_no;\n\treply->received = 0;\n\treply->rc = 0;\n\tinit_waitqueue_head(&reply->wait_q);\n\n\treturn reply;\n}\n\n \nstatic void\nlcs_notify_lancmd_waiters(struct lcs_card *card, struct lcs_cmd *cmd)\n{\n\tstruct list_head *l, *n;\n\tstruct lcs_reply *reply;\n\n\tLCS_DBF_TEXT(4, trace, \"notiwait\");\n\tspin_lock(&card->lock);\n\tlist_for_each_safe(l, n, &card->lancmd_waiters) {\n\t\treply = list_entry(l, struct lcs_reply, list);\n\t\tif (reply->sequence_no == cmd->sequence_no) {\n\t\t\tlcs_get_reply(reply);\n\t\t\tlist_del_init(&reply->list);\n\t\t\tif (reply->callback != NULL)\n\t\t\t\treply->callback(card, cmd);\n\t\t\treply->received = 1;\n\t\t\treply->rc = cmd->return_code;\n\t\t\twake_up(&reply->wait_q);\n\t\t\tlcs_put_reply(reply);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&card->lock);\n}\n\n \nstatic void\nlcs_lancmd_timeout(struct timer_list *t)\n{\n\tstruct lcs_reply *reply = from_timer(reply, t, timer);\n\tstruct lcs_reply *list_reply, *r;\n\tunsigned long flags;\n\n\tLCS_DBF_TEXT(4, trace, \"timeout\");\n\tspin_lock_irqsave(&reply->card->lock, flags);\n\tlist_for_each_entry_safe(list_reply, r,\n\t\t\t\t &reply->card->lancmd_waiters,list) {\n\t\tif (reply == list_reply) {\n\t\t\tlcs_get_reply(reply);\n\t\t\tlist_del_init(&reply->list);\n\t\t\tspin_unlock_irqrestore(&reply->card->lock, flags);\n\t\t\treply->received = 1;\n\t\t\treply->rc = -ETIME;\n\t\t\twake_up(&reply->wait_q);\n\t\t\tlcs_put_reply(reply);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&reply->card->lock, flags);\n}\n\nstatic int\nlcs_send_lancmd(struct lcs_card *card, struct lcs_buffer *buffer,\n\t\tvoid (*reply_callback)(struct lcs_card *, struct lcs_cmd *))\n{\n\tstruct lcs_reply *reply;\n\tstruct lcs_cmd *cmd;\n\tunsigned long flags;\n\tint rc;\n\n\tLCS_DBF_TEXT(4, trace, \"sendcmd\");\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->return_code = 0;\n\tcmd->sequence_no = card->sequence_no++;\n\treply = lcs_alloc_reply(cmd);\n\tif (!reply)\n\t\treturn -ENOMEM;\n\treply->callback = reply_callback;\n\treply->card = card;\n\tspin_lock_irqsave(&card->lock, flags);\n\tlist_add_tail(&reply->list, &card->lancmd_waiters);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tbuffer->callback = lcs_release_buffer;\n\trc = lcs_ready_buffer(&card->write, buffer);\n\tif (rc)\n\t\treturn rc;\n\ttimer_setup(&reply->timer, lcs_lancmd_timeout, 0);\n\tmod_timer(&reply->timer, jiffies + HZ * card->lancmd_timeout);\n\twait_event(reply->wait_q, reply->received);\n\tdel_timer_sync(&reply->timer);\n\tLCS_DBF_TEXT_(4, trace, \"rc:%d\",reply->rc);\n\trc = reply->rc;\n\tlcs_put_reply(reply);\n\treturn rc ? -EIO : 0;\n}\n\n \nstatic int\nlcs_send_startup(struct lcs_card *card, __u8 initiator)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\n\tLCS_DBF_TEXT(2, trace, \"startup\");\n\tbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->cmd_code = LCS_CMD_STARTUP;\n\tcmd->initiator = initiator;\n\tcmd->cmd.lcs_startup.buff_size = LCS_IOBUFFERSIZE;\n\treturn lcs_send_lancmd(card, buffer, NULL);\n}\n\n \nstatic int\nlcs_send_shutdown(struct lcs_card *card)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\n\tLCS_DBF_TEXT(2, trace, \"shutdown\");\n\tbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->cmd_code = LCS_CMD_SHUTDOWN;\n\tcmd->initiator = LCS_INITIATOR_TCPIP;\n\treturn lcs_send_lancmd(card, buffer, NULL);\n}\n\n \nstatic void\n__lcs_lanstat_cb(struct lcs_card *card, struct lcs_cmd *cmd)\n{\n\tLCS_DBF_TEXT(2, trace, \"statcb\");\n\tmemcpy(card->mac, cmd->cmd.lcs_lanstat_cmd.mac_addr, LCS_MAC_LENGTH);\n}\n\nstatic int\nlcs_send_lanstat(struct lcs_card *card)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\n\tLCS_DBF_TEXT(2,trace, \"cmdstat\");\n\tbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\n\tcmd = (struct lcs_cmd *) buffer->data;\n\t \n\tcmd->cmd_code = LCS_CMD_LANSTAT;\n\tcmd->initiator = LCS_INITIATOR_TCPIP;\n\tcmd->cmd.lcs_std_cmd.lan_type = card->lan_type;\n\tcmd->cmd.lcs_std_cmd.portno = card->portno;\n\treturn lcs_send_lancmd(card, buffer, __lcs_lanstat_cb);\n}\n\n \nstatic int\nlcs_send_stoplan(struct lcs_card *card, __u8 initiator)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\n\tLCS_DBF_TEXT(2, trace, \"cmdstpln\");\n\tbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->cmd_code = LCS_CMD_STOPLAN;\n\tcmd->initiator = initiator;\n\tcmd->cmd.lcs_std_cmd.lan_type = card->lan_type;\n\tcmd->cmd.lcs_std_cmd.portno = card->portno;\n\treturn lcs_send_lancmd(card, buffer, NULL);\n}\n\n \nstatic void\n__lcs_send_startlan_cb(struct lcs_card *card, struct lcs_cmd *cmd)\n{\n\tLCS_DBF_TEXT(2, trace, \"srtlancb\");\n\tcard->lan_type = cmd->cmd.lcs_std_cmd.lan_type;\n\tcard->portno = cmd->cmd.lcs_std_cmd.portno;\n}\n\nstatic int\nlcs_send_startlan(struct lcs_card *card, __u8 initiator)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\n\tLCS_DBF_TEXT(2, trace, \"cmdstaln\");\n\tbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->cmd_code = LCS_CMD_STARTLAN;\n\tcmd->initiator = initiator;\n\tcmd->cmd.lcs_std_cmd.lan_type = card->lan_type;\n\tcmd->cmd.lcs_std_cmd.portno = card->portno;\n\treturn lcs_send_lancmd(card, buffer, __lcs_send_startlan_cb);\n}\n\n#ifdef CONFIG_IP_MULTICAST\n \nstatic int\nlcs_send_setipm(struct lcs_card *card,struct lcs_ipm_list *ipm_list)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\n\tLCS_DBF_TEXT(2, trace, \"cmdsetim\");\n\tbuffer = lcs_get_lancmd(card, LCS_MULTICAST_CMD_SIZE);\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->cmd_code = LCS_CMD_SETIPM;\n\tcmd->initiator = LCS_INITIATOR_TCPIP;\n\tcmd->cmd.lcs_qipassist.lan_type = card->lan_type;\n\tcmd->cmd.lcs_qipassist.portno = card->portno;\n\tcmd->cmd.lcs_qipassist.version = 4;\n\tcmd->cmd.lcs_qipassist.num_ip_pairs = 1;\n\tmemcpy(cmd->cmd.lcs_qipassist.lcs_ipass_ctlmsg.ip_mac_pair,\n\t       &ipm_list->ipm, sizeof (struct lcs_ip_mac_pair));\n\tLCS_DBF_TEXT_(2, trace, \"%x\",ipm_list->ipm.ip_addr);\n\treturn lcs_send_lancmd(card, buffer, NULL);\n}\n\n \nstatic int\nlcs_send_delipm(struct lcs_card *card,struct lcs_ipm_list *ipm_list)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\n\tLCS_DBF_TEXT(2, trace, \"cmddelim\");\n\tbuffer = lcs_get_lancmd(card, LCS_MULTICAST_CMD_SIZE);\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->cmd_code = LCS_CMD_DELIPM;\n\tcmd->initiator = LCS_INITIATOR_TCPIP;\n\tcmd->cmd.lcs_qipassist.lan_type = card->lan_type;\n\tcmd->cmd.lcs_qipassist.portno = card->portno;\n\tcmd->cmd.lcs_qipassist.version = 4;\n\tcmd->cmd.lcs_qipassist.num_ip_pairs = 1;\n\tmemcpy(cmd->cmd.lcs_qipassist.lcs_ipass_ctlmsg.ip_mac_pair,\n\t       &ipm_list->ipm, sizeof (struct lcs_ip_mac_pair));\n\tLCS_DBF_TEXT_(2, trace, \"%x\",ipm_list->ipm.ip_addr);\n\treturn lcs_send_lancmd(card, buffer, NULL);\n}\n\n \nstatic void\n__lcs_check_multicast_cb(struct lcs_card *card, struct lcs_cmd *cmd)\n{\n\tLCS_DBF_TEXT(2, trace, \"chkmccb\");\n\tcard->ip_assists_supported =\n\t\tcmd->cmd.lcs_qipassist.ip_assists_supported;\n\tcard->ip_assists_enabled =\n\t\tcmd->cmd.lcs_qipassist.ip_assists_enabled;\n}\n\nstatic int\nlcs_check_multicast_support(struct lcs_card *card)\n{\n\tstruct lcs_buffer *buffer;\n\tstruct lcs_cmd *cmd;\n\tint rc;\n\n\tLCS_DBF_TEXT(2, trace, \"cmdqipa\");\n\t \n\tbuffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);\n\tcmd = (struct lcs_cmd *) buffer->data;\n\tcmd->cmd_code = LCS_CMD_QIPASSIST;\n\tcmd->initiator = LCS_INITIATOR_TCPIP;\n\tcmd->cmd.lcs_qipassist.lan_type = card->lan_type;\n\tcmd->cmd.lcs_qipassist.portno = card->portno;\n\tcmd->cmd.lcs_qipassist.version = 4;\n\tcmd->cmd.lcs_qipassist.num_ip_pairs = 1;\n\trc = lcs_send_lancmd(card, buffer, __lcs_check_multicast_cb);\n\tif (rc != 0) {\n\t\tpr_err(\"Query IPAssist failed. Assuming unsupported!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT)\n\t\treturn 0;\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic void\nlcs_fix_multicast_list(struct lcs_card *card)\n{\n\tstruct list_head failed_list;\n\tstruct lcs_ipm_list *ipm, *tmp;\n\tunsigned long flags;\n\tint rc;\n\n\tLCS_DBF_TEXT(4,trace, \"fixipm\");\n\tINIT_LIST_HEAD(&failed_list);\n\tspin_lock_irqsave(&card->ipm_lock, flags);\nlist_modified:\n\tlist_for_each_entry_safe(ipm, tmp, &card->ipm_list, list){\n\t\tswitch (ipm->ipm_state) {\n\t\tcase LCS_IPM_STATE_SET_REQUIRED:\n\t\t\t \n\t\t\tlist_del_init(&ipm->list);\n\t\t\tspin_unlock_irqrestore(&card->ipm_lock, flags);\n\t\t\trc = lcs_send_setipm(card, ipm);\n\t\t\tspin_lock_irqsave(&card->ipm_lock, flags);\n\t\t\tif (rc) {\n\t\t\t\tpr_info(\"Adding multicast address failed.\"\n\t\t\t\t\t\" Table possibly full!\\n\");\n\t\t\t\t \n\t\t\t\tlist_add_tail(&ipm->list, &failed_list);\n\t\t\t} else {\n\t\t\t\tipm->ipm_state = LCS_IPM_STATE_ON_CARD;\n\t\t\t\t \n\t\t\t\tlist_add_tail(&ipm->list, &card->ipm_list);\n\t\t\t}\n\t\t\tgoto list_modified;\n\t\tcase LCS_IPM_STATE_DEL_REQUIRED:\n\t\t\tlist_del(&ipm->list);\n\t\t\tspin_unlock_irqrestore(&card->ipm_lock, flags);\n\t\t\tlcs_send_delipm(card, ipm);\n\t\t\tspin_lock_irqsave(&card->ipm_lock, flags);\n\t\t\tkfree(ipm);\n\t\t\tgoto list_modified;\n\t\tcase LCS_IPM_STATE_ON_CARD:\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tlist_for_each_entry_safe(ipm, tmp, &failed_list, list)\n\t\tlist_move_tail(&ipm->list, &card->ipm_list);\n\n\tspin_unlock_irqrestore(&card->ipm_lock, flags);\n}\n\n \nstatic void\nlcs_get_mac_for_ipm(__be32 ipm, char *mac, struct net_device *dev)\n{\n\tLCS_DBF_TEXT(4,trace, \"getmac\");\n\tip_eth_mc_map(ipm, mac);\n}\n\n \nstatic void lcs_remove_mc_addresses(struct lcs_card *card,\n\t\t\t\t    struct in_device *in4_dev)\n{\n\tstruct ip_mc_list *im4;\n\tstruct list_head *l;\n\tstruct lcs_ipm_list *ipm;\n\tunsigned long flags;\n\tchar buf[MAX_ADDR_LEN];\n\n\tLCS_DBF_TEXT(4, trace, \"remmclst\");\n\tspin_lock_irqsave(&card->ipm_lock, flags);\n\tlist_for_each(l, &card->ipm_list) {\n\t\tipm = list_entry(l, struct lcs_ipm_list, list);\n\t\tfor (im4 = rcu_dereference(in4_dev->mc_list);\n\t\t     im4 != NULL; im4 = rcu_dereference(im4->next_rcu)) {\n\t\t\tlcs_get_mac_for_ipm(im4->multiaddr, buf, card->dev);\n\t\t\tif ( (ipm->ipm.ip_addr == im4->multiaddr) &&\n\t\t\t     (memcmp(buf, &ipm->ipm.mac_addr,\n\t\t\t\t     LCS_MAC_LENGTH) == 0) )\n\t\t\t\tbreak;\n\t\t}\n\t\tif (im4 == NULL)\n\t\t\tipm->ipm_state = LCS_IPM_STATE_DEL_REQUIRED;\n\t}\n\tspin_unlock_irqrestore(&card->ipm_lock, flags);\n}\n\nstatic struct lcs_ipm_list *lcs_check_addr_entry(struct lcs_card *card,\n\t\t\t\t\t\t struct ip_mc_list *im4,\n\t\t\t\t\t\t char *buf)\n{\n\tstruct lcs_ipm_list *tmp, *ipm = NULL;\n\tstruct list_head *l;\n\tunsigned long flags;\n\n\tLCS_DBF_TEXT(4, trace, \"chkmcent\");\n\tspin_lock_irqsave(&card->ipm_lock, flags);\n\tlist_for_each(l, &card->ipm_list) {\n\t\ttmp = list_entry(l, struct lcs_ipm_list, list);\n\t\tif ( (tmp->ipm.ip_addr == im4->multiaddr) &&\n\t\t     (memcmp(buf, &tmp->ipm.mac_addr,\n\t\t\t     LCS_MAC_LENGTH) == 0) ) {\n\t\t\tipm = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&card->ipm_lock, flags);\n\treturn ipm;\n}\n\nstatic void lcs_set_mc_addresses(struct lcs_card *card,\n\t\t\t\t struct in_device *in4_dev)\n{\n\n\tstruct ip_mc_list *im4;\n\tstruct lcs_ipm_list *ipm;\n\tchar buf[MAX_ADDR_LEN];\n\tunsigned long flags;\n\n\tLCS_DBF_TEXT(4, trace, \"setmclst\");\n\tfor (im4 = rcu_dereference(in4_dev->mc_list); im4 != NULL;\n\t     im4 = rcu_dereference(im4->next_rcu)) {\n\t\tlcs_get_mac_for_ipm(im4->multiaddr, buf, card->dev);\n\t\tipm = lcs_check_addr_entry(card, im4, buf);\n\t\tif (ipm != NULL)\n\t\t\tcontinue;\t \n\t\tipm = kzalloc(sizeof(struct lcs_ipm_list), GFP_ATOMIC);\n\t\tif (ipm == NULL) {\n\t\t\tpr_info(\"Not enough memory to add\"\n\t\t\t\t\" new multicast entry!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(&ipm->ipm.mac_addr, buf, LCS_MAC_LENGTH);\n\t\tipm->ipm.ip_addr = im4->multiaddr;\n\t\tipm->ipm_state = LCS_IPM_STATE_SET_REQUIRED;\n\t\tspin_lock_irqsave(&card->ipm_lock, flags);\n\t\tLCS_DBF_HEX(2,trace,&ipm->ipm.ip_addr,4);\n\t\tlist_add(&ipm->list, &card->ipm_list);\n\t\tspin_unlock_irqrestore(&card->ipm_lock, flags);\n\t}\n}\n\nstatic int\nlcs_register_mc_addresses(void *data)\n{\n\tstruct lcs_card *card;\n\tstruct in_device *in4_dev;\n\n\tcard = (struct lcs_card *) data;\n\n\tif (!lcs_do_run_thread(card, LCS_SET_MC_THREAD))\n\t\treturn 0;\n\tLCS_DBF_TEXT(4, trace, \"regmulti\");\n\n\tin4_dev = in_dev_get(card->dev);\n\tif (in4_dev == NULL)\n\t\tgoto out;\n\trcu_read_lock();\n\tlcs_remove_mc_addresses(card,in4_dev);\n\tlcs_set_mc_addresses(card, in4_dev);\n\trcu_read_unlock();\n\tin_dev_put(in4_dev);\n\n\tnetif_carrier_off(card->dev);\n\tnetif_tx_disable(card->dev);\n\twait_event(card->write.wait_q,\n\t\t\t(card->write.state != LCS_CH_STATE_RUNNING));\n\tlcs_fix_multicast_list(card);\n\tif (card->state == DEV_STATE_UP) {\n\t\tnetif_carrier_on(card->dev);\n\t\tnetif_wake_queue(card->dev);\n\t}\nout:\n\tlcs_clear_thread_running_bit(card, LCS_SET_MC_THREAD);\n\treturn 0;\n}\n#endif  \n\n \nstatic void\nlcs_set_multicast_list(struct net_device *dev)\n{\n#ifdef CONFIG_IP_MULTICAST\n        struct lcs_card *card;\n\n        LCS_DBF_TEXT(4, trace, \"setmulti\");\n        card = (struct lcs_card *) dev->ml_priv;\n\n        if (!lcs_set_thread_start_bit(card, LCS_SET_MC_THREAD))\n\t\tschedule_work(&card->kernel_thread_starter);\n#endif  \n}\n\nstatic long\nlcs_check_irb_error(struct ccw_device *cdev, struct irb *irb)\n{\n\tif (!IS_ERR(irb))\n\t\treturn 0;\n\n\tswitch (PTR_ERR(irb)) {\n\tcase -EIO:\n\t\tdev_warn(&cdev->dev,\n\t\t\t\"An I/O-error occurred on the LCS device\\n\");\n\t\tLCS_DBF_TEXT(2, trace, \"ckirberr\");\n\t\tLCS_DBF_TEXT_(2, trace, \"  rc%d\", -EIO);\n\t\tbreak;\n\tcase -ETIMEDOUT:\n\t\tdev_warn(&cdev->dev,\n\t\t\t\"A command timed out on the LCS device\\n\");\n\t\tLCS_DBF_TEXT(2, trace, \"ckirberr\");\n\t\tLCS_DBF_TEXT_(2, trace, \"  rc%d\", -ETIMEDOUT);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&cdev->dev,\n\t\t\t\"An error occurred on the LCS device, rc=%ld\\n\",\n\t\t\tPTR_ERR(irb));\n\t\tLCS_DBF_TEXT(2, trace, \"ckirberr\");\n\t\tLCS_DBF_TEXT(2, trace, \"  rc???\");\n\t}\n\treturn PTR_ERR(irb);\n}\n\nstatic int\nlcs_get_problem(struct ccw_device *cdev, struct irb *irb)\n{\n\tint dstat, cstat;\n\tchar *sense;\n\n\tsense = (char *) irb->ecw;\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\n\tif (cstat & (SCHN_STAT_CHN_CTRL_CHK | SCHN_STAT_INTF_CTRL_CHK |\n\t\t     SCHN_STAT_CHN_DATA_CHK | SCHN_STAT_CHAIN_CHECK |\n\t\t     SCHN_STAT_PROT_CHECK   | SCHN_STAT_PROG_CHECK)) {\n\t\tLCS_DBF_TEXT(2, trace, \"CGENCHK\");\n\t\treturn 1;\n\t}\n\tif (dstat & DEV_STAT_UNIT_CHECK) {\n\t\tif (sense[LCS_SENSE_BYTE_1] &\n\t\t    LCS_SENSE_RESETTING_EVENT) {\n\t\t\tLCS_DBF_TEXT(2, trace, \"REVIND\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (sense[LCS_SENSE_BYTE_0] &\n\t\t    LCS_SENSE_CMD_REJECT) {\n\t\t\tLCS_DBF_TEXT(2, trace, \"CMDREJ\");\n\t\t\treturn 0;\n\t\t}\n\t\tif ((!sense[LCS_SENSE_BYTE_0]) &&\n\t\t    (!sense[LCS_SENSE_BYTE_1]) &&\n\t\t    (!sense[LCS_SENSE_BYTE_2]) &&\n\t\t    (!sense[LCS_SENSE_BYTE_3])) {\n\t\t\tLCS_DBF_TEXT(2, trace, \"ZEROSEN\");\n\t\t\treturn 0;\n\t\t}\n\t\tLCS_DBF_TEXT(2, trace, \"DGENCHK\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void\nlcs_schedule_recovery(struct lcs_card *card)\n{\n\tLCS_DBF_TEXT(2, trace, \"startrec\");\n\tif (!lcs_set_thread_start_bit(card, LCS_RECOVERY_THREAD))\n\t\tschedule_work(&card->kernel_thread_starter);\n}\n\n \nstatic void\nlcs_irq(struct ccw_device *cdev, unsigned long intparm, struct irb *irb)\n{\n\tstruct lcs_card *card;\n\tstruct lcs_channel *channel;\n\tint rc, index;\n\tint cstat, dstat;\n\n\tif (lcs_check_irb_error(cdev, irb))\n\t\treturn;\n\n\tcard = CARD_FROM_DEV(cdev);\n\tif (card->read.ccwdev == cdev)\n\t\tchannel = &card->read;\n\telse\n\t\tchannel = &card->write;\n\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\tLCS_DBF_TEXT_(5, trace, \"Rint%s\", dev_name(&cdev->dev));\n\tLCS_DBF_TEXT_(5, trace, \"%4x%4x\", irb->scsw.cmd.cstat,\n\t\t      irb->scsw.cmd.dstat);\n\tLCS_DBF_TEXT_(5, trace, \"%4x%4x\", irb->scsw.cmd.fctl,\n\t\t      irb->scsw.cmd.actl);\n\n\t \n\trc = lcs_get_problem(cdev, irb);\n\tif (rc || (dstat & DEV_STAT_UNIT_EXCEP)) {\n\t\tdev_warn(&cdev->dev,\n\t\t\t\"The LCS device stopped because of an error,\"\n\t\t\t\" dstat=0x%X, cstat=0x%X \\n\",\n\t\t\t    dstat, cstat);\n\t\tif (rc) {\n\t\t\tchannel->state = LCS_CH_STATE_ERROR;\n\t\t}\n\t}\n\tif (channel->state == LCS_CH_STATE_ERROR) {\n\t\tlcs_schedule_recovery(card);\n\t\twake_up(&card->wait_q);\n\t\treturn;\n\t}\n\t \n\tif ((channel->state != LCS_CH_STATE_INIT) &&\n\t    (irb->scsw.cmd.fctl & SCSW_FCTL_START_FUNC) &&\n\t    (irb->scsw.cmd.cpa != 0)) {\n\t\tindex = (struct ccw1 *) __va((addr_t) irb->scsw.cmd.cpa)\n\t\t\t- channel->ccws;\n\t\tif ((irb->scsw.cmd.actl & SCSW_ACTL_SUSPENDED) ||\n\t\t    (irb->scsw.cmd.cstat & SCHN_STAT_PCI))\n\t\t\t \n\t\t\tindex = (index - 1) & (LCS_NUM_BUFFS - 1);\n\t\twhile (channel->io_idx != index) {\n\t\t\t__lcs_processed_buffer(channel,\n\t\t\t\t\t       channel->iob + channel->io_idx);\n\t\t\tchannel->io_idx =\n\t\t\t\t(channel->io_idx + 1) & (LCS_NUM_BUFFS - 1);\n\t\t}\n\t}\n\n\tif ((irb->scsw.cmd.dstat & DEV_STAT_DEV_END) ||\n\t    (irb->scsw.cmd.dstat & DEV_STAT_CHN_END) ||\n\t    (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK))\n\t\t \n\t\tchannel->state = LCS_CH_STATE_STOPPED;\n\telse if (irb->scsw.cmd.actl & SCSW_ACTL_SUSPENDED)\n\t\t \n\t\tchannel->state = LCS_CH_STATE_SUSPENDED;\n\tif (irb->scsw.cmd.fctl & SCSW_FCTL_HALT_FUNC) {\n\t\tif (irb->scsw.cmd.cc != 0) {\n\t\t\tccw_device_halt(channel->ccwdev, 0);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tchannel->state = LCS_CH_STATE_HALTED;\n\t}\n\tif (irb->scsw.cmd.fctl & SCSW_FCTL_CLEAR_FUNC)\n\t\tchannel->state = LCS_CH_STATE_CLEARED;\n\t \n\ttasklet_schedule(&channel->irq_tasklet);\n}\n\n \nstatic void\nlcs_tasklet(unsigned long data)\n{\n\tunsigned long flags;\n\tstruct lcs_channel *channel;\n\tstruct lcs_buffer *iob;\n\tint buf_idx;\n\n\tchannel = (struct lcs_channel *) data;\n\tLCS_DBF_TEXT_(5, trace, \"tlet%s\", dev_name(&channel->ccwdev->dev));\n\n\t \n\tiob = channel->iob;\n\tbuf_idx = channel->buf_idx;\n\twhile (iob[buf_idx].state == LCS_BUF_STATE_PROCESSED) {\n\t\t \n\t\tif (iob[buf_idx].callback != NULL)\n\t\t\tiob[buf_idx].callback(channel, iob + buf_idx);\n\t\tbuf_idx = (buf_idx + 1) & (LCS_NUM_BUFFS - 1);\n\t}\n\tchannel->buf_idx = buf_idx;\n\n\tif (channel->state == LCS_CH_STATE_STOPPED)\n\t\tlcs_start_channel(channel);\n\tspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\n\tif (channel->state == LCS_CH_STATE_SUSPENDED &&\n\t    channel->iob[channel->io_idx].state == LCS_BUF_STATE_READY)\n\t\t__lcs_resume_channel(channel);\n\tspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\n\n\t \n\twake_up(&channel->wait_q);\n}\n\n \nstatic void\n__lcs_emit_txbuffer(struct lcs_card *card)\n{\n\tLCS_DBF_TEXT(5, trace, \"emittx\");\n\t*(__u16 *)(card->tx_buffer->data + card->tx_buffer->count) = 0;\n\tcard->tx_buffer->count += 2;\n\tlcs_ready_buffer(&card->write, card->tx_buffer);\n\tcard->tx_buffer = NULL;\n\tcard->tx_emitted++;\n}\n\n \nstatic void\nlcs_txbuffer_cb(struct lcs_channel *channel, struct lcs_buffer *buffer)\n{\n\tstruct lcs_card *card;\n\n\tLCS_DBF_TEXT(5, trace, \"txbuffcb\");\n\t \n\tlcs_release_buffer(channel, buffer);\n\tcard = container_of(channel, struct lcs_card, write);\n\tif (netif_queue_stopped(card->dev) && netif_carrier_ok(card->dev))\n\t\tnetif_wake_queue(card->dev);\n\tspin_lock(&card->lock);\n\tcard->tx_emitted--;\n\tif (card->tx_emitted <= 0 && card->tx_buffer != NULL)\n\t\t \n\t\t__lcs_emit_txbuffer(card);\n\tspin_unlock(&card->lock);\n}\n\n \nstatic netdev_tx_t __lcs_start_xmit(struct lcs_card *card, struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct lcs_header *header;\n\tint rc = NETDEV_TX_OK;\n\n\tLCS_DBF_TEXT(5, trace, \"hardxmit\");\n\tif (skb == NULL) {\n\t\tcard->stats.tx_dropped++;\n\t\tcard->stats.tx_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (card->state != DEV_STATE_UP) {\n\t\tdev_kfree_skb(skb);\n\t\tcard->stats.tx_dropped++;\n\t\tcard->stats.tx_errors++;\n\t\tcard->stats.tx_carrier_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tnetif_stop_queue(card->dev);\n\tspin_lock(&card->lock);\n\tif (card->tx_buffer != NULL &&\n\t    card->tx_buffer->count + sizeof(struct lcs_header) +\n\t    skb->len + sizeof(u16) > LCS_IOBUFFERSIZE)\n\t\t \n\t\t__lcs_emit_txbuffer(card);\n\tif (card->tx_buffer == NULL) {\n\t\t \n\t\tcard->tx_buffer = lcs_get_buffer(&card->write);\n\t\tif (card->tx_buffer == NULL) {\n\t\t\tcard->stats.tx_dropped++;\n\t\t\trc = NETDEV_TX_BUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tcard->tx_buffer->callback = lcs_txbuffer_cb;\n\t\tcard->tx_buffer->count = 0;\n\t}\n\theader = (struct lcs_header *)\n\t\t(card->tx_buffer->data + card->tx_buffer->count);\n\tcard->tx_buffer->count += skb->len + sizeof(struct lcs_header);\n\theader->offset = card->tx_buffer->count;\n\theader->type = card->lan_type;\n\theader->slot = card->portno;\n\tskb_copy_from_linear_data(skb, header + 1, skb->len);\n\tspin_unlock(&card->lock);\n\tcard->stats.tx_bytes += skb->len;\n\tcard->stats.tx_packets++;\n\tdev_kfree_skb(skb);\n\tnetif_wake_queue(card->dev);\n\tspin_lock(&card->lock);\n\tif (card->tx_emitted <= 0 && card->tx_buffer != NULL)\n\t\t \n\t\t__lcs_emit_txbuffer(card);\nout:\n\tspin_unlock(&card->lock);\n\treturn rc;\n}\n\nstatic netdev_tx_t lcs_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct lcs_card *card;\n\tint rc;\n\n\tLCS_DBF_TEXT(5, trace, \"pktxmit\");\n\tcard = (struct lcs_card *) dev->ml_priv;\n\trc = __lcs_start_xmit(card, skb, dev);\n\treturn rc;\n}\n\n \nstatic int\nlcs_startlan_auto(struct lcs_card *card)\n{\n\tint rc;\n\n\tLCS_DBF_TEXT(2, trace, \"strtauto\");\n\tcard->lan_type = LCS_FRAME_TYPE_ENET;\n\trc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);\n\tif (rc == 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int\nlcs_startlan(struct lcs_card *card)\n{\n\tint rc, i;\n\n\tLCS_DBF_TEXT(2, trace, \"startlan\");\n\trc = 0;\n\tif (card->portno != LCS_INVALID_PORT_NO) {\n\t\tif (card->lan_type == LCS_FRAME_TYPE_AUTO)\n\t\t\trc = lcs_startlan_auto(card);\n\t\telse\n\t\t\trc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);\n\t} else {\n                for (i = 0; i <= 16; i++) {\n                        card->portno = i;\n                        if (card->lan_type != LCS_FRAME_TYPE_AUTO)\n                                rc = lcs_send_startlan(card,\n                                                       LCS_INITIATOR_TCPIP);\n                        else\n                                 \n                                rc = lcs_startlan_auto(card);\n                        if (rc == 0)\n                                break;\n                }\n        }\n\tif (rc == 0)\n\t\treturn lcs_send_lanstat(card);\n\treturn rc;\n}\n\n \nstatic int\nlcs_detect(struct lcs_card *card)\n{\n\tint rc = 0;\n\n\tLCS_DBF_TEXT(2, setup, \"lcsdetct\");\n\t \n\tif (card->dev)\n\t\tnetif_stop_queue(card->dev);\n\trc = lcs_stop_channels(card);\n\tif (rc == 0) {\n\t\trc = lcs_start_channels(card);\n\t\tif (rc == 0) {\n\t\t\trc = lcs_send_startup(card, LCS_INITIATOR_TCPIP);\n\t\t\tif (rc == 0)\n\t\t\t\trc = lcs_startlan(card);\n\t\t}\n\t}\n\tif (rc == 0) {\n\t\tcard->state = DEV_STATE_UP;\n\t} else {\n\t\tcard->state = DEV_STATE_DOWN;\n\t\tcard->write.state = LCS_CH_STATE_INIT;\n\t\tcard->read.state =  LCS_CH_STATE_INIT;\n\t}\n\treturn rc;\n}\n\n \nstatic int\nlcs_stopcard(struct lcs_card *card)\n{\n\tint rc;\n\n\tLCS_DBF_TEXT(3, setup, \"stopcard\");\n\n\tif (card->read.state != LCS_CH_STATE_STOPPED &&\n\t    card->write.state != LCS_CH_STATE_STOPPED &&\n\t    card->read.state != LCS_CH_STATE_ERROR &&\n\t    card->write.state != LCS_CH_STATE_ERROR &&\n\t    card->state == DEV_STATE_UP) {\n\t\tlcs_clear_multicast_list(card);\n\t\trc = lcs_send_stoplan(card,LCS_INITIATOR_TCPIP);\n\t\trc = lcs_send_shutdown(card);\n\t}\n\trc = lcs_stop_channels(card);\n\tcard->state = DEV_STATE_DOWN;\n\n\treturn rc;\n}\n\n \nstatic void\nlcs_start_kernel_thread(struct work_struct *work)\n{\n\tstruct lcs_card *card = container_of(work, struct lcs_card, kernel_thread_starter);\n\tLCS_DBF_TEXT(5, trace, \"krnthrd\");\n\tif (lcs_do_start_thread(card, LCS_RECOVERY_THREAD))\n\t\tkthread_run(lcs_recovery, card, \"lcs_recover\");\n#ifdef CONFIG_IP_MULTICAST\n\tif (lcs_do_start_thread(card, LCS_SET_MC_THREAD))\n\t\tkthread_run(lcs_register_mc_addresses, card, \"regipm\");\n#endif\n}\n\n \nstatic void\nlcs_get_control(struct lcs_card *card, struct lcs_cmd *cmd)\n{\n\tLCS_DBF_TEXT(5, trace, \"getctrl\");\n\tif (cmd->initiator == LCS_INITIATOR_LGW) {\n\t\tswitch(cmd->cmd_code) {\n\t\tcase LCS_CMD_STARTUP:\n\t\tcase LCS_CMD_STARTLAN:\n\t\t\tlcs_schedule_recovery(card);\n\t\t\tbreak;\n\t\tcase LCS_CMD_STOPLAN:\n\t\t\tif (card->dev) {\n\t\t\t\tpr_warn(\"Stoplan for %s initiated by LGW\\n\",\n\t\t\t\t\tcard->dev->name);\n\t\t\t\tnetif_carrier_off(card->dev);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLCS_DBF_TEXT(5, trace, \"noLGWcmd\");\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tlcs_notify_lancmd_waiters(card, cmd);\n}\n\n \nstatic void\nlcs_get_skb(struct lcs_card *card, char *skb_data, unsigned int skb_len)\n{\n\tstruct sk_buff *skb;\n\n\tLCS_DBF_TEXT(5, trace, \"getskb\");\n\tif (card->dev == NULL ||\n\t    card->state != DEV_STATE_UP)\n\t\t \n\t\treturn;\n\n\tskb = dev_alloc_skb(skb_len);\n\tif (skb == NULL) {\n\t\tdev_err(&card->dev->dev,\n\t\t\t\" Allocating a socket buffer to interface %s failed\\n\",\n\t\t\t  card->dev->name);\n\t\tcard->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tskb_put_data(skb, skb_data, skb_len);\n\tskb->protocol =\tcard->lan_type_trans(skb, card->dev);\n\tcard->stats.rx_bytes += skb_len;\n\tcard->stats.rx_packets++;\n\tif (skb->protocol == htons(ETH_P_802_2))\n\t\t*((__u32 *)skb->cb) = ++card->pkt_seq;\n\tnetif_rx(skb);\n}\n\n \nstatic void\nlcs_get_frames_cb(struct lcs_channel *channel, struct lcs_buffer *buffer)\n{\n\tstruct lcs_card *card;\n\tstruct lcs_header *lcs_hdr;\n\t__u16 offset;\n\n\tLCS_DBF_TEXT(5, trace, \"lcsgtpkt\");\n\tlcs_hdr = (struct lcs_header *) buffer->data;\n\tif (lcs_hdr->offset == LCS_ILLEGAL_OFFSET) {\n\t\tLCS_DBF_TEXT(4, trace, \"-eiogpkt\");\n\t\treturn;\n\t}\n\tcard = container_of(channel, struct lcs_card, read);\n\toffset = 0;\n\twhile (lcs_hdr->offset != 0) {\n\t\tif (lcs_hdr->offset <= 0 ||\n\t\t    lcs_hdr->offset > LCS_IOBUFFERSIZE ||\n\t\t    lcs_hdr->offset < offset) {\n\t\t\t \n\t\t\tcard->stats.rx_length_errors++;\n\t\t\tcard->stats.rx_errors++;\n\t\t\treturn;\n\t\t}\n\t\tif (lcs_hdr->type == LCS_FRAME_TYPE_CONTROL)\n\t\t\tlcs_get_control(card, (struct lcs_cmd *) lcs_hdr);\n\t\telse if (lcs_hdr->type == LCS_FRAME_TYPE_ENET)\n\t\t\tlcs_get_skb(card, (char *)(lcs_hdr + 1),\n\t\t\t\t    lcs_hdr->offset - offset -\n\t\t\t\t    sizeof(struct lcs_header));\n\t\telse\n\t\t\tdev_info_once(&card->dev->dev,\n\t\t\t\t      \"Unknown frame type %d\\n\",\n\t\t\t\t      lcs_hdr->type);\n\t\toffset = lcs_hdr->offset;\n\t\tlcs_hdr->offset = LCS_ILLEGAL_OFFSET;\n\t\tlcs_hdr = (struct lcs_header *) (buffer->data + offset);\n\t}\n\t \n\tlcs_ready_buffer(&card->read, buffer);\n}\n\n \nstatic struct net_device_stats *\nlcs_getstats(struct net_device *dev)\n{\n\tstruct lcs_card *card;\n\n\tLCS_DBF_TEXT(4, trace, \"netstats\");\n\tcard = (struct lcs_card *) dev->ml_priv;\n\treturn &card->stats;\n}\n\n \nstatic int\nlcs_stop_device(struct net_device *dev)\n{\n\tstruct lcs_card *card;\n\tint rc;\n\n\tLCS_DBF_TEXT(2, trace, \"stopdev\");\n\tcard   = (struct lcs_card *) dev->ml_priv;\n\tnetif_carrier_off(dev);\n\tnetif_tx_disable(dev);\n\tdev->flags &= ~IFF_UP;\n\twait_event(card->write.wait_q,\n\t\t(card->write.state != LCS_CH_STATE_RUNNING));\n\trc = lcs_stopcard(card);\n\tif (rc)\n\t\tdev_err(&card->dev->dev,\n\t\t\t\" Shutting down the LCS device failed\\n\");\n\treturn rc;\n}\n\n \nstatic int\nlcs_open_device(struct net_device *dev)\n{\n\tstruct lcs_card *card;\n\tint rc;\n\n\tLCS_DBF_TEXT(2, trace, \"opendev\");\n\tcard = (struct lcs_card *) dev->ml_priv;\n\t \n\trc = lcs_detect(card);\n\tif (rc) {\n\t\tpr_err(\"Error in opening device!\\n\");\n\n\t} else {\n\t\tdev->flags |= IFF_UP;\n\t\tnetif_carrier_on(dev);\n\t\tnetif_wake_queue(dev);\n\t\tcard->state = DEV_STATE_UP;\n\t}\n\treturn rc;\n}\n\n \nstatic ssize_t\nlcs_portno_show (struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct lcs_card *card;\n\n\tcard = dev_get_drvdata(dev);\n\n\tif (!card)\n\t\treturn 0;\n\n\treturn sysfs_emit(buf, \"%d\\n\", card->portno);\n}\n\n \nstatic ssize_t\nlcs_portno_store (struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n        struct lcs_card *card;\n\tint rc;\n\ts16 value;\n\n\tcard = dev_get_drvdata(dev);\n\n        if (!card)\n                return 0;\n\n\trc = kstrtos16(buf, 0, &value);\n\tif (rc)\n\t\treturn -EINVAL;\n         \n        card->portno = value;\n\tif (card->dev)\n\t\tcard->dev->dev_port = card->portno;\n\n        return count;\n\n}\n\nstatic DEVICE_ATTR(portno, 0644, lcs_portno_show, lcs_portno_store);\n\nstatic const char *lcs_type[] = {\n\t\"not a channel\",\n\t\"2216 parallel\",\n\t\"2216 channel\",\n\t\"OSA LCS card\",\n\t\"unknown channel type\",\n\t\"unsupported channel type\",\n};\n\nstatic ssize_t\nlcs_type_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ccwgroup_device *cgdev;\n\n\tcgdev = to_ccwgroupdev(dev);\n\tif (!cgdev)\n\t\treturn -ENODEV;\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  lcs_type[cgdev->cdev[0]->id.driver_info]);\n}\n\nstatic DEVICE_ATTR(type, 0444, lcs_type_show, NULL);\n\nstatic ssize_t\nlcs_timeout_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct lcs_card *card;\n\n\tcard = dev_get_drvdata(dev);\n\n\treturn card ? sysfs_emit(buf, \"%u\\n\", card->lancmd_timeout) : 0;\n}\n\nstatic ssize_t\nlcs_timeout_store (struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n        struct lcs_card *card;\n\tunsigned int value;\n\tint rc;\n\n\tcard = dev_get_drvdata(dev);\n\n        if (!card)\n                return 0;\n\n\trc = kstrtouint(buf, 0, &value);\n\tif (rc)\n\t\treturn -EINVAL;\n         \n        card->lancmd_timeout = value;\n\n        return count;\n\n}\n\nstatic DEVICE_ATTR(lancmd_timeout, 0644, lcs_timeout_show, lcs_timeout_store);\n\nstatic ssize_t\nlcs_dev_recover_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct lcs_card *card = dev_get_drvdata(dev);\n\tchar *tmp;\n\tint i;\n\n\tif (!card)\n\t\treturn -EINVAL;\n\tif (card->state != DEV_STATE_UP)\n\t\treturn -EPERM;\n\ti = simple_strtoul(buf, &tmp, 16);\n\tif (i == 1)\n\t\tlcs_schedule_recovery(card);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(recover, 0200, NULL, lcs_dev_recover_store);\n\nstatic struct attribute * lcs_attrs[] = {\n\t&dev_attr_portno.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_lancmd_timeout.attr,\n\t&dev_attr_recover.attr,\n\tNULL,\n};\nstatic struct attribute_group lcs_attr_group = {\n\t.attrs = lcs_attrs,\n};\nstatic const struct attribute_group *lcs_attr_groups[] = {\n\t&lcs_attr_group,\n\tNULL,\n};\nstatic const struct device_type lcs_devtype = {\n\t.name = \"lcs\",\n\t.groups = lcs_attr_groups,\n};\n\n \nstatic int\nlcs_probe_device(struct ccwgroup_device *ccwgdev)\n{\n\tstruct lcs_card *card;\n\n\tif (!get_device(&ccwgdev->dev))\n\t\treturn -ENODEV;\n\n\tLCS_DBF_TEXT(2, setup, \"add_dev\");\n        card = lcs_alloc_card();\n        if (!card) {\n\t\tLCS_DBF_TEXT_(2, setup, \"  rc%d\", -ENOMEM);\n\t\tput_device(&ccwgdev->dev);\n                return -ENOMEM;\n        }\n\tdev_set_drvdata(&ccwgdev->dev, card);\n\tccwgdev->cdev[0]->handler = lcs_irq;\n\tccwgdev->cdev[1]->handler = lcs_irq;\n\tcard->gdev = ccwgdev;\n\tINIT_WORK(&card->kernel_thread_starter, lcs_start_kernel_thread);\n\tcard->thread_start_mask = 0;\n\tcard->thread_allowed_mask = 0;\n\tcard->thread_running_mask = 0;\n\tccwgdev->dev.type = &lcs_devtype;\n\n\treturn 0;\n}\n\nstatic int\nlcs_register_netdev(struct ccwgroup_device *ccwgdev)\n{\n\tstruct lcs_card *card;\n\n\tLCS_DBF_TEXT(2, setup, \"regnetdv\");\n\tcard = dev_get_drvdata(&ccwgdev->dev);\n\tif (card->dev->reg_state != NETREG_UNINITIALIZED)\n\t\treturn 0;\n\tSET_NETDEV_DEV(card->dev, &ccwgdev->dev);\n\treturn register_netdev(card->dev);\n}\n\n \nstatic const struct net_device_ops lcs_netdev_ops = {\n\t.ndo_open\t\t= lcs_open_device,\n\t.ndo_stop\t\t= lcs_stop_device,\n\t.ndo_get_stats\t\t= lcs_getstats,\n\t.ndo_start_xmit\t\t= lcs_start_xmit,\n};\n\nstatic const struct net_device_ops lcs_mc_netdev_ops = {\n\t.ndo_open\t\t= lcs_open_device,\n\t.ndo_stop\t\t= lcs_stop_device,\n\t.ndo_get_stats\t\t= lcs_getstats,\n\t.ndo_start_xmit\t\t= lcs_start_xmit,\n\t.ndo_set_rx_mode\t= lcs_set_multicast_list,\n};\n\nstatic int\nlcs_new_device(struct ccwgroup_device *ccwgdev)\n{\n\tstruct  lcs_card *card;\n\tstruct net_device *dev=NULL;\n\tenum lcs_dev_states recover_state;\n\tint rc;\n\n\tcard = dev_get_drvdata(&ccwgdev->dev);\n\tif (!card)\n\t\treturn -ENODEV;\n\n\tLCS_DBF_TEXT(2, setup, \"newdev\");\n\tLCS_DBF_HEX(3, setup, &card, sizeof(void*));\n\tcard->read.ccwdev  = ccwgdev->cdev[0];\n\tcard->write.ccwdev = ccwgdev->cdev[1];\n\n\trecover_state = card->state;\n\trc = ccw_device_set_online(card->read.ccwdev);\n\tif (rc)\n\t\tgoto out_err;\n\trc = ccw_device_set_online(card->write.ccwdev);\n\tif (rc)\n\t\tgoto out_werr;\n\n\tLCS_DBF_TEXT(3, setup, \"lcsnewdv\");\n\n\tlcs_setup_card(card);\n\trc = lcs_detect(card);\n\tif (rc) {\n\t\tLCS_DBF_TEXT(2, setup, \"dtctfail\");\n\t\tdev_err(&ccwgdev->dev,\n\t\t\t\"Detecting a network adapter for LCS devices\"\n\t\t\t\" failed with rc=%d (0x%x)\\n\", rc, rc);\n\t\tlcs_stopcard(card);\n\t\tgoto out;\n\t}\n\tif (card->dev) {\n\t\tLCS_DBF_TEXT(2, setup, \"samedev\");\n\t\tLCS_DBF_HEX(3, setup, &card, sizeof(void*));\n\t\tgoto netdev_out;\n\t}\n\tswitch (card->lan_type) {\n\tcase LCS_FRAME_TYPE_ENET:\n\t\tcard->lan_type_trans = eth_type_trans;\n\t\tdev = alloc_etherdev(0);\n\t\tbreak;\n\tdefault:\n\t\tLCS_DBF_TEXT(3, setup, \"errinit\");\n\t\tpr_err(\" Initialization failed\\n\");\n\t\tgoto out;\n\t}\n\tif (!dev)\n\t\tgoto out;\n\tcard->dev = dev;\n\tcard->dev->ml_priv = card;\n\tcard->dev->netdev_ops = &lcs_netdev_ops;\n\tcard->dev->dev_port = card->portno;\n\teth_hw_addr_set(card->dev, card->mac);\n#ifdef CONFIG_IP_MULTICAST\n\tif (!lcs_check_multicast_support(card))\n\t\tcard->dev->netdev_ops = &lcs_mc_netdev_ops;\n#endif\nnetdev_out:\n\tlcs_set_allowed_threads(card,0xffffffff);\n\tif (recover_state == DEV_STATE_RECOVER) {\n\t\tlcs_set_multicast_list(card->dev);\n\t\tcard->dev->flags |= IFF_UP;\n\t\tnetif_carrier_on(card->dev);\n\t\tnetif_wake_queue(card->dev);\n\t\tcard->state = DEV_STATE_UP;\n\t} else {\n\t\tlcs_stopcard(card);\n\t}\n\n\tif (lcs_register_netdev(ccwgdev) != 0)\n\t\tgoto out;\n\n\t \n\tpr_info(\"LCS device %s %s IPv6 support\\n\", card->dev->name,\n\t\t(card->ip_assists_supported & LCS_IPASS_IPV6_SUPPORT) ?\n\t\t\"with\" : \"without\");\n\t \n\tpr_info(\"LCS device %s %s Multicast support\\n\", card->dev->name,\n\t\t(card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT) ?\n\t\t\"with\" : \"without\");\n\treturn 0;\nout:\n\n\tccw_device_set_offline(card->write.ccwdev);\nout_werr:\n\tccw_device_set_offline(card->read.ccwdev);\nout_err:\n\treturn -ENODEV;\n}\n\n \nstatic int\n__lcs_shutdown_device(struct ccwgroup_device *ccwgdev, int recovery_mode)\n{\n\tstruct lcs_card *card;\n\tenum lcs_dev_states recover_state;\n\tint ret = 0, ret2 = 0, ret3 = 0;\n\n\tLCS_DBF_TEXT(3, setup, \"shtdndev\");\n\tcard = dev_get_drvdata(&ccwgdev->dev);\n\tif (!card)\n\t\treturn -ENODEV;\n\tif (recovery_mode == 0) {\n\t\tlcs_set_allowed_threads(card, 0);\n\t\tif (lcs_wait_for_threads(card, LCS_SET_MC_THREAD))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\tLCS_DBF_HEX(3, setup, &card, sizeof(void*));\n\trecover_state = card->state;\n\n\tret = lcs_stop_device(card->dev);\n\tret2 = ccw_device_set_offline(card->read.ccwdev);\n\tret3 = ccw_device_set_offline(card->write.ccwdev);\n\tif (!ret)\n\t\tret = (ret2) ? ret2 : ret3;\n\tif (ret)\n\t\tLCS_DBF_TEXT_(3, setup, \"1err:%d\", ret);\n\tif (recover_state == DEV_STATE_UP) {\n\t\tcard->state = DEV_STATE_RECOVER;\n\t}\n\treturn 0;\n}\n\nstatic int\nlcs_shutdown_device(struct ccwgroup_device *ccwgdev)\n{\n\treturn __lcs_shutdown_device(ccwgdev, 0);\n}\n\n \nstatic int\nlcs_recovery(void *ptr)\n{\n\tstruct lcs_card *card;\n\tstruct ccwgroup_device *gdev;\n        int rc;\n\n\tcard = (struct lcs_card *) ptr;\n\n\tLCS_DBF_TEXT(4, trace, \"recover1\");\n\tif (!lcs_do_run_thread(card, LCS_RECOVERY_THREAD))\n\t\treturn 0;\n\tLCS_DBF_TEXT(4, trace, \"recover2\");\n\tgdev = card->gdev;\n\tdev_warn(&gdev->dev,\n\t\t\"A recovery process has been started for the LCS device\\n\");\n\trc = __lcs_shutdown_device(gdev, 1);\n\trc = lcs_new_device(gdev);\n\tif (!rc)\n\t\tpr_info(\"Device %s successfully recovered!\\n\",\n\t\t\tcard->dev->name);\n\telse\n\t\tpr_info(\"Device %s could not be recovered!\\n\",\n\t\t\tcard->dev->name);\n\tlcs_clear_thread_running_bit(card, LCS_RECOVERY_THREAD);\n\treturn 0;\n}\n\n \nstatic void\nlcs_remove_device(struct ccwgroup_device *ccwgdev)\n{\n\tstruct lcs_card *card;\n\n\tcard = dev_get_drvdata(&ccwgdev->dev);\n\tif (!card)\n\t\treturn;\n\n\tLCS_DBF_TEXT(3, setup, \"remdev\");\n\tLCS_DBF_HEX(3, setup, &card, sizeof(void*));\n\tif (ccwgdev->state == CCWGROUP_ONLINE) {\n\t\tlcs_shutdown_device(ccwgdev);\n\t}\n\tif (card->dev)\n\t\tunregister_netdev(card->dev);\n\tlcs_cleanup_card(card);\n\tlcs_free_card(card);\n\tdev_set_drvdata(&ccwgdev->dev, NULL);\n\tput_device(&ccwgdev->dev);\n}\n\nstatic struct ccw_device_id lcs_ids[] = {\n\t{CCW_DEVICE(0x3088, 0x08), .driver_info = lcs_channel_type_parallel},\n\t{CCW_DEVICE(0x3088, 0x1f), .driver_info = lcs_channel_type_2216},\n\t{CCW_DEVICE(0x3088, 0x60), .driver_info = lcs_channel_type_osa2},\n\t{},\n};\nMODULE_DEVICE_TABLE(ccw, lcs_ids);\n\nstatic struct ccw_driver lcs_ccw_driver = {\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"lcs\",\n\t},\n\t.ids\t= lcs_ids,\n\t.probe\t= ccwgroup_probe_ccwdev,\n\t.remove\t= ccwgroup_remove_ccwdev,\n\t.int_class = IRQIO_LCS,\n};\n\n \nstatic struct ccwgroup_driver lcs_group_driver = {\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"lcs\",\n\t},\n\t.ccw_driver  = &lcs_ccw_driver,\n\t.setup\t     = lcs_probe_device,\n\t.remove      = lcs_remove_device,\n\t.set_online  = lcs_new_device,\n\t.set_offline = lcs_shutdown_device,\n};\n\nstatic ssize_t group_store(struct device_driver *ddrv, const char *buf,\n\t\t\t   size_t count)\n{\n\tint err;\n\terr = ccwgroup_create_dev(lcs_root_dev, &lcs_group_driver, 2, buf);\n\treturn err ? err : count;\n}\nstatic DRIVER_ATTR_WO(group);\n\nstatic struct attribute *lcs_drv_attrs[] = {\n\t&driver_attr_group.attr,\n\tNULL,\n};\nstatic struct attribute_group lcs_drv_attr_group = {\n\t.attrs = lcs_drv_attrs,\n};\nstatic const struct attribute_group *lcs_drv_attr_groups[] = {\n\t&lcs_drv_attr_group,\n\tNULL,\n};\n\n \nstatic int\n__init lcs_init_module(void)\n{\n\tint rc;\n\n\tpr_info(\"Loading %s\\n\", version);\n\trc = lcs_register_debug_facility();\n\tLCS_DBF_TEXT(0, setup, \"lcsinit\");\n\tif (rc)\n\t\tgoto out_err;\n\tlcs_root_dev = root_device_register(\"lcs\");\n\trc = PTR_ERR_OR_ZERO(lcs_root_dev);\n\tif (rc)\n\t\tgoto register_err;\n\trc = ccw_driver_register(&lcs_ccw_driver);\n\tif (rc)\n\t\tgoto ccw_err;\n\tlcs_group_driver.driver.groups = lcs_drv_attr_groups;\n\trc = ccwgroup_driver_register(&lcs_group_driver);\n\tif (rc)\n\t\tgoto ccwgroup_err;\n\treturn 0;\n\nccwgroup_err:\n\tccw_driver_unregister(&lcs_ccw_driver);\nccw_err:\n\troot_device_unregister(lcs_root_dev);\nregister_err:\n\tlcs_unregister_debug_facility();\nout_err:\n\tpr_err(\"Initializing the lcs device driver failed\\n\");\n\treturn rc;\n}\n\n\n \nstatic void\n__exit lcs_cleanup_module(void)\n{\n\tpr_info(\"Terminating lcs module.\\n\");\n\tLCS_DBF_TEXT(0, trace, \"cleanup\");\n\tccwgroup_driver_unregister(&lcs_group_driver);\n\tccw_driver_unregister(&lcs_ccw_driver);\n\troot_device_unregister(lcs_root_dev);\n\tlcs_unregister_debug_facility();\n}\n\nmodule_init(lcs_init_module);\nmodule_exit(lcs_cleanup_module);\n\nMODULE_AUTHOR(\"Frank Pavlic <fpavlic@de.ibm.com>\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}