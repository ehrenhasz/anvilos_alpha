{
  "module_name": "qeth_ethtool.c",
  "hash_id": "3ce35adc8e6bda807fd9e2ac20b65f1f44bb647363bed6321fc5455fce7cd7b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/qeth_ethtool.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"qeth\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/ethtool.h>\n#include \"qeth_core.h\"\n\n\n#define QETH_TXQ_STAT(_name, _stat) { \\\n\t.name = _name, \\\n\t.offset = offsetof(struct qeth_out_q_stats, _stat) \\\n}\n\n#define QETH_CARD_STAT(_name, _stat) { \\\n\t.name = _name, \\\n\t.offset = offsetof(struct qeth_card_stats, _stat) \\\n}\n\nstruct qeth_stats {\n\tchar name[ETH_GSTRING_LEN];\n\tunsigned int offset;\n};\n\nstatic const struct qeth_stats txq_stats[] = {\n\tQETH_TXQ_STAT(\"IO buffers\", bufs),\n\tQETH_TXQ_STAT(\"IO buffer elements\", buf_elements),\n\tQETH_TXQ_STAT(\"packed IO buffers\", bufs_pack),\n\tQETH_TXQ_STAT(\"skbs\", tx_packets),\n\tQETH_TXQ_STAT(\"packed skbs\", skbs_pack),\n\tQETH_TXQ_STAT(\"SG skbs\", skbs_sg),\n\tQETH_TXQ_STAT(\"HW csum skbs\", skbs_csum),\n\tQETH_TXQ_STAT(\"TSO skbs\", skbs_tso),\n\tQETH_TXQ_STAT(\"linearized skbs\", skbs_linearized),\n\tQETH_TXQ_STAT(\"linearized+error skbs\", skbs_linearized_fail),\n\tQETH_TXQ_STAT(\"TSO bytes\", tso_bytes),\n\tQETH_TXQ_STAT(\"Packing mode switches\", packing_mode_switch),\n\tQETH_TXQ_STAT(\"Queue stopped\", stopped),\n\tQETH_TXQ_STAT(\"Doorbell\", doorbell),\n\tQETH_TXQ_STAT(\"IRQ for frames\", coal_frames),\n\tQETH_TXQ_STAT(\"Completion IRQ\", completion_irq),\n\tQETH_TXQ_STAT(\"Completion yield\", completion_yield),\n\tQETH_TXQ_STAT(\"Completion timer\", completion_timer),\n};\n\nstatic const struct qeth_stats card_stats[] = {\n\tQETH_CARD_STAT(\"rx0 IO buffers\", rx_bufs),\n\tQETH_CARD_STAT(\"rx0 HW csum skbs\", rx_skb_csum),\n\tQETH_CARD_STAT(\"rx0 SG skbs\", rx_sg_skbs),\n\tQETH_CARD_STAT(\"rx0 SG page frags\", rx_sg_frags),\n\tQETH_CARD_STAT(\"rx0 SG page allocs\", rx_sg_alloc_page),\n\tQETH_CARD_STAT(\"rx0 dropped, no memory\", rx_dropped_nomem),\n\tQETH_CARD_STAT(\"rx0 dropped, bad format\", rx_dropped_notsupp),\n\tQETH_CARD_STAT(\"rx0 dropped, runt\", rx_dropped_runt),\n};\n\n#define TXQ_STATS_LEN\tARRAY_SIZE(txq_stats)\n#define CARD_STATS_LEN\tARRAY_SIZE(card_stats)\n\nstatic void qeth_add_stat_data(u64 **dst, void *src,\n\t\t\t       const struct qeth_stats stats[],\n\t\t\t       unsigned int size)\n{\n\tunsigned int i;\n\tchar *stat;\n\n\tfor (i = 0; i < size; i++) {\n\t\tstat = (char *)src + stats[i].offset;\n\t\t**dst = *(u64 *)stat;\n\t\t(*dst)++;\n\t}\n}\n\nstatic void qeth_add_stat_strings(u8 **data, const char *prefix,\n\t\t\t\t  const struct qeth_stats stats[],\n\t\t\t\t  unsigned int size)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < size; i++)\n\t\tethtool_sprintf(data, \"%s%s\", prefix, stats[i].name);\n}\n\nstatic int qeth_get_sset_count(struct net_device *dev, int stringset)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\treturn CARD_STATS_LEN +\n\t\t       card->qdio.no_out_queues * TXQ_STATS_LEN;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void qeth_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tunsigned int i;\n\n\tqeth_add_stat_data(&data, &card->stats, card_stats, CARD_STATS_LEN);\n\tfor (i = 0; i < card->qdio.no_out_queues; i++)\n\t\tqeth_add_stat_data(&data, &card->qdio.out_qs[i]->stats,\n\t\t\t\t   txq_stats, TXQ_STATS_LEN);\n}\n\nstatic void __qeth_set_coalesce(struct net_device *dev,\n\t\t\t\tstruct qeth_qdio_out_q *queue,\n\t\t\t\tstruct ethtool_coalesce *coal)\n{\n\tWRITE_ONCE(queue->coalesce_usecs, coal->tx_coalesce_usecs);\n\tWRITE_ONCE(queue->max_coalesced_frames, coal->tx_max_coalesced_frames);\n\n\tif (coal->tx_coalesce_usecs &&\n\t    netif_running(dev) &&\n\t    !qeth_out_queue_is_empty(queue))\n\t\tqeth_tx_arm_timer(queue, coal->tx_coalesce_usecs);\n}\n\nstatic int qeth_set_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *coal,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tstruct qeth_qdio_out_q *queue;\n\tunsigned int i;\n\n\tif (!IS_IQD(card))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!coal->tx_coalesce_usecs && !coal->tx_max_coalesced_frames)\n\t\treturn -EINVAL;\n\n\tqeth_for_each_output_queue(card, queue, i)\n\t\t__qeth_set_coalesce(dev, queue, coal);\n\n\treturn 0;\n}\n\nstatic void qeth_get_ringparam(struct net_device *dev,\n\t\t\t       struct ethtool_ringparam *param,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tparam->rx_max_pending = QDIO_MAX_BUFFERS_PER_Q;\n\tparam->rx_mini_max_pending = 0;\n\tparam->rx_jumbo_max_pending = 0;\n\tparam->tx_max_pending = QDIO_MAX_BUFFERS_PER_Q;\n\n\tparam->rx_pending = card->qdio.in_buf_pool.buf_count;\n\tparam->rx_mini_pending = 0;\n\tparam->rx_jumbo_pending = 0;\n\tparam->tx_pending = QDIO_MAX_BUFFERS_PER_Q;\n}\n\nstatic void qeth_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tchar prefix[ETH_GSTRING_LEN] = \"\";\n\tunsigned int i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tqeth_add_stat_strings(&data, prefix, card_stats,\n\t\t\t\t      CARD_STATS_LEN);\n\t\tfor (i = 0; i < card->qdio.no_out_queues; i++) {\n\t\t\tscnprintf(prefix, ETH_GSTRING_LEN, \"tx%u \", i);\n\t\t\tqeth_add_stat_strings(&data, prefix, txq_stats,\n\t\t\t\t\t      TXQ_STATS_LEN);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic void qeth_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tstrscpy(info->driver, IS_LAYER2(card) ? \"qeth_l2\" : \"qeth_l3\",\n\t\tsizeof(info->driver));\n\tstrscpy(info->fw_version, card->info.mcl_level,\n\t\tsizeof(info->fw_version));\n\tscnprintf(info->bus_info, sizeof(info->bus_info), \"%s/%s/%s\",\n\t\t  CARD_RDEV_ID(card), CARD_WDEV_ID(card), CARD_DDEV_ID(card));\n}\n\nstatic void qeth_get_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *channels)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tchannels->max_rx = dev->num_rx_queues;\n\tchannels->max_tx = card->qdio.no_out_queues;\n\tchannels->max_other = 0;\n\tchannels->max_combined = 0;\n\tchannels->rx_count = dev->real_num_rx_queues;\n\tchannels->tx_count = dev->real_num_tx_queues;\n\tchannels->other_count = 0;\n\tchannels->combined_count = 0;\n}\n\nstatic int qeth_set_channels(struct net_device *dev,\n\t\t\t     struct ethtool_channels *channels)\n{\n\tstruct qeth_priv *priv = netdev_priv(dev);\n\tstruct qeth_card *card = dev->ml_priv;\n\tint rc;\n\n\tif (channels->rx_count == 0 || channels->tx_count == 0)\n\t\treturn -EINVAL;\n\tif (channels->tx_count > card->qdio.no_out_queues)\n\t\treturn -EINVAL;\n\n\t \n\tif (qeth_uses_tx_prio_queueing(card))\n\t\treturn -EPERM;\n\n\tif (IS_IQD(card)) {\n\t\tif (channels->tx_count < QETH_IQD_MIN_TXQ)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (netif_running(dev) &&\n\t\t    channels->tx_count < dev->real_num_tx_queues)\n\t\t\treturn -EPERM;\n\t}\n\n\trc = qeth_set_real_num_tx_queues(card, channels->tx_count);\n\tif (!rc)\n\t\tpriv->tx_wanted_queues = channels->tx_count;\n\n\treturn rc;\n}\n\nstatic int qeth_get_ts_info(struct net_device *dev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tif (!IS_IQD(card))\n\t\treturn -EOPNOTSUPP;\n\n\treturn ethtool_op_get_ts_info(dev, info);\n}\n\nstatic int qeth_get_tunable(struct net_device *dev,\n\t\t\t    const struct ethtool_tunable *tuna, void *data)\n{\n\tstruct qeth_priv *priv = netdev_priv(dev);\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = priv->rx_copybreak;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int qeth_set_tunable(struct net_device *dev,\n\t\t\t    const struct ethtool_tunable *tuna,\n\t\t\t    const void *data)\n{\n\tstruct qeth_priv *priv = netdev_priv(dev);\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tWRITE_ONCE(priv->rx_copybreak, *(u32 *)data);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int qeth_get_per_queue_coalesce(struct net_device *dev, u32 __queue,\n\t\t\t\t       struct ethtool_coalesce *coal)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tstruct qeth_qdio_out_q *queue;\n\n\tif (!IS_IQD(card))\n\t\treturn -EOPNOTSUPP;\n\n\tif (__queue >= card->qdio.no_out_queues)\n\t\treturn -EINVAL;\n\n\tqueue = card->qdio.out_qs[__queue];\n\n\tcoal->tx_coalesce_usecs = queue->coalesce_usecs;\n\tcoal->tx_max_coalesced_frames = queue->max_coalesced_frames;\n\treturn 0;\n}\n\nstatic int qeth_set_per_queue_coalesce(struct net_device *dev, u32 queue,\n\t\t\t\t       struct ethtool_coalesce *coal)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tif (!IS_IQD(card))\n\t\treturn -EOPNOTSUPP;\n\n\tif (queue >= card->qdio.no_out_queues)\n\t\treturn -EINVAL;\n\n\tif (!coal->tx_coalesce_usecs && !coal->tx_max_coalesced_frames)\n\t\treturn -EINVAL;\n\n\t__qeth_set_coalesce(dev, card->qdio.out_qs[queue], coal);\n\treturn 0;\n}\n\n \n \n \n \nstatic void qeth_set_ethtool_link_modes(struct ethtool_link_ksettings *cmd,\n\t\t\t\t\tenum qeth_link_mode link_mode)\n{\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\tethtool_link_ksettings_zero_link_mode(cmd, lp_advertising);\n\n\tethtool_link_ksettings_add_link_mode(cmd, supported, Autoneg);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, Autoneg);\n\n\tswitch (cmd->base.port) {\n\tcase PORT_TP:\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, TP);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, TP);\n\n\t\tswitch (cmd->base.speed) {\n\t\tcase SPEED_10000:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     10000baseT_Full);\n\t\t\tfallthrough;\n\t\tcase SPEED_1000:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     1000baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     1000baseT_Half);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     1000baseT_Half);\n\t\t\tfallthrough;\n\t\tcase SPEED_100:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     100baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     100baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     100baseT_Half);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     100baseT_Half);\n\t\t\tfallthrough;\n\t\tcase SPEED_10:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     10baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     10baseT_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     10baseT_Half);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     10baseT_Half);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase PORT_FIBRE:\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);\n\n\t\tswitch (cmd->base.speed) {\n\t\tcase SPEED_25000:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     25000baseSR_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     25000baseSR_Full);\n\t\t\tbreak;\n\t\tcase SPEED_10000:\n\t\t\tif (link_mode == QETH_LINK_MODE_FIBRE_LONG) {\n\t\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t\t     10000baseLR_Full);\n\t\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t\t     10000baseLR_Full);\n\t\t\t} else if (link_mode == QETH_LINK_MODE_FIBRE_SHORT) {\n\t\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t\t     10000baseSR_Full);\n\t\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t\t     10000baseSR_Full);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t\t     1000baseX_Full);\n\t\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t\t     1000baseX_Full);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int qeth_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct qeth_card *card = netdev->ml_priv;\n\n\tQETH_CARD_TEXT(card, 4, \"ethtglks\");\n\tcmd->base.speed = card->info.link_info.speed;\n\tcmd->base.duplex = card->info.link_info.duplex;\n\tcmd->base.port = card->info.link_info.port;\n\tcmd->base.autoneg = AUTONEG_ENABLE;\n\tcmd->base.phy_address = 0;\n\tcmd->base.mdio_support = 0;\n\tcmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\tcmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_INVALID;\n\n\tqeth_set_ethtool_link_modes(cmd, card->info.link_info.link_mode);\n\n\treturn 0;\n}\n\nconst struct ethtool_ops qeth_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_TX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_TX_MAX_FRAMES,\n\t.get_link = ethtool_op_get_link,\n\t.set_coalesce = qeth_set_coalesce,\n\t.get_ringparam = qeth_get_ringparam,\n\t.get_strings = qeth_get_strings,\n\t.get_ethtool_stats = qeth_get_ethtool_stats,\n\t.get_sset_count = qeth_get_sset_count,\n\t.get_drvinfo = qeth_get_drvinfo,\n\t.get_channels = qeth_get_channels,\n\t.set_channels = qeth_set_channels,\n\t.get_ts_info = qeth_get_ts_info,\n\t.get_tunable = qeth_get_tunable,\n\t.set_tunable = qeth_set_tunable,\n\t.get_per_queue_coalesce = qeth_get_per_queue_coalesce,\n\t.set_per_queue_coalesce = qeth_set_per_queue_coalesce,\n\t.get_link_ksettings = qeth_get_link_ksettings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}