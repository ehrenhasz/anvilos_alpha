{
  "module_name": "fsm.c",
  "hash_id": "3816eb18138c3dadbcf545fea6b14780f84f3d6dbcda16ad0431197f8f2e40cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/fsm.c",
  "human_readable_source": "\n \n\n#include \"fsm.h\"\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\nMODULE_AUTHOR(\"(C) 2000 IBM Corp. by Fritz Elfert (felfert@millenux.com)\");\nMODULE_DESCRIPTION(\"Finite state machine helper functions\");\nMODULE_LICENSE(\"GPL\");\n\nfsm_instance *\ninit_fsm(char *name, const char **state_names, const char **event_names, int nr_states,\n\t\tint nr_events, const fsm_node *tmpl, int tmpl_len, gfp_t order)\n{\n\tint i;\n\tfsm_instance *this;\n\tfsm_function_t *m;\n\tfsm *f;\n\n\tthis = kzalloc(sizeof(fsm_instance), order);\n\tif (this == NULL) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"fsm(%s): init_fsm: Couldn't alloc instance\\n\", name);\n\t\treturn NULL;\n\t}\n\tstrscpy(this->name, name, sizeof(this->name));\n\tinit_waitqueue_head(&this->wait_q);\n\n\tf = kzalloc(sizeof(fsm), order);\n\tif (f == NULL) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"fsm(%s): init_fsm: Couldn't alloc fsm\\n\", name);\n\t\tkfree_fsm(this);\n\t\treturn NULL;\n\t}\n\tf->nr_events = nr_events;\n\tf->nr_states = nr_states;\n\tf->event_names = event_names;\n\tf->state_names = state_names;\n\tthis->f = f;\n\n\tm = kcalloc(nr_states*nr_events, sizeof(fsm_function_t), order);\n\tif (m == NULL) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"fsm(%s): init_fsm: Couldn't alloc jumptable\\n\", name);\n\t\tkfree_fsm(this);\n\t\treturn NULL;\n\t}\n\tf->jumpmatrix = m;\n\n\tfor (i = 0; i < tmpl_len; i++) {\n\t\tif ((tmpl[i].cond_state >= nr_states) ||\n\t\t    (tmpl[i].cond_event >= nr_events)   ) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"fsm(%s): init_fsm: Bad template l=%d st(%ld/%ld) ev(%ld/%ld)\\n\",\n\t\t\t\tname, i, (long)tmpl[i].cond_state, (long)f->nr_states,\n\t\t\t\t(long)tmpl[i].cond_event, (long)f->nr_events);\n\t\t\tkfree_fsm(this);\n\t\t\treturn NULL;\n\t\t} else\n\t\t\tm[nr_states * tmpl[i].cond_event + tmpl[i].cond_state] =\n\t\t\t\ttmpl[i].function;\n\t}\n\treturn this;\n}\n\nvoid\nkfree_fsm(fsm_instance *this)\n{\n\tif (this) {\n\t\tif (this->f) {\n\t\t\tkfree(this->f->jumpmatrix);\n\t\t\tkfree(this->f);\n\t\t}\n\t\tkfree(this);\n\t} else\n\t\tprintk(KERN_WARNING\n\t\t\t\"fsm: kfree_fsm called with NULL argument\\n\");\n}\n\n#if FSM_DEBUG_HISTORY\nvoid\nfsm_print_history(fsm_instance *fi)\n{\n\tint idx = 0;\n\tint i;\n\n\tif (fi->history_size >= FSM_HISTORY_SIZE)\n\t\tidx = fi->history_index;\n\n\tprintk(KERN_DEBUG \"fsm(%s): History:\\n\", fi->name);\n\tfor (i = 0; i < fi->history_size; i++) {\n\t\tint e = fi->history[idx].event;\n\t\tint s = fi->history[idx++].state;\n\t\tidx %= FSM_HISTORY_SIZE;\n\t\tif (e == -1)\n\t\t\tprintk(KERN_DEBUG \"  S=%s\\n\",\n\t\t\t       fi->f->state_names[s]);\n\t\telse\n\t\t\tprintk(KERN_DEBUG \"  S=%s E=%s\\n\",\n\t\t\t       fi->f->state_names[s],\n\t\t\t       fi->f->event_names[e]);\n\t}\n\tfi->history_size = fi->history_index = 0;\n}\n\nvoid\nfsm_record_history(fsm_instance *fi, int state, int event)\n{\n\tfi->history[fi->history_index].state = state;\n\tfi->history[fi->history_index++].event = event;\n\tfi->history_index %= FSM_HISTORY_SIZE;\n\tif (fi->history_size < FSM_HISTORY_SIZE)\n\t\tfi->history_size++;\n}\n#endif\n\nconst char *\nfsm_getstate_str(fsm_instance *fi)\n{\n\tint st = atomic_read(&fi->state);\n\tif (st >= fi->f->nr_states)\n\t\treturn \"Invalid\";\n\treturn fi->f->state_names[st];\n}\n\nstatic void\nfsm_expire_timer(struct timer_list *t)\n{\n\tfsm_timer *this = from_timer(this, t, tl);\n#if FSM_TIMER_DEBUG\n\tprintk(KERN_DEBUG \"fsm(%s): Timer %p expired\\n\",\n\t       this->fi->name, this);\n#endif\n\tfsm_event(this->fi, this->expire_event, this->event_arg);\n}\n\nvoid\nfsm_settimer(fsm_instance *fi, fsm_timer *this)\n{\n\tthis->fi = fi;\n#if FSM_TIMER_DEBUG\n\tprintk(KERN_DEBUG \"fsm(%s): Create timer %p\\n\", fi->name,\n\t       this);\n#endif\n\ttimer_setup(&this->tl, fsm_expire_timer, 0);\n}\n\nvoid\nfsm_deltimer(fsm_timer *this)\n{\n#if FSM_TIMER_DEBUG\n\tprintk(KERN_DEBUG \"fsm(%s): Delete timer %p\\n\", this->fi->name,\n\t\tthis);\n#endif\n\tdel_timer(&this->tl);\n}\n\nint\nfsm_addtimer(fsm_timer *this, int millisec, int event, void *arg)\n{\n\n#if FSM_TIMER_DEBUG\n\tprintk(KERN_DEBUG \"fsm(%s): Add timer %p %dms\\n\",\n\t       this->fi->name, this, millisec);\n#endif\n\n\ttimer_setup(&this->tl, fsm_expire_timer, 0);\n\tthis->expire_event = event;\n\tthis->event_arg = arg;\n\tthis->tl.expires = jiffies + (millisec * HZ) / 1000;\n\tadd_timer(&this->tl);\n\treturn 0;\n}\n\n \nvoid\nfsm_modtimer(fsm_timer *this, int millisec, int event, void *arg)\n{\n\n#if FSM_TIMER_DEBUG\n\tprintk(KERN_DEBUG \"fsm(%s): Restart timer %p %dms\\n\",\n\t\tthis->fi->name, this, millisec);\n#endif\n\n\tdel_timer(&this->tl);\n\ttimer_setup(&this->tl, fsm_expire_timer, 0);\n\tthis->expire_event = event;\n\tthis->event_arg = arg;\n\tthis->tl.expires = jiffies + (millisec * HZ) / 1000;\n\tadd_timer(&this->tl);\n}\n\nEXPORT_SYMBOL(init_fsm);\nEXPORT_SYMBOL(kfree_fsm);\nEXPORT_SYMBOL(fsm_settimer);\nEXPORT_SYMBOL(fsm_deltimer);\nEXPORT_SYMBOL(fsm_addtimer);\nEXPORT_SYMBOL(fsm_modtimer);\nEXPORT_SYMBOL(fsm_getstate_str);\n\n#if FSM_DEBUG_HISTORY\nEXPORT_SYMBOL(fsm_print_history);\nEXPORT_SYMBOL(fsm_record_history);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}