{
  "module_name": "qeth_l2_main.c",
  "hash_id": "df68548100d119c729b59c882444a690ecb44d29df48979f5f22edc1e16ea1b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/qeth_l2_main.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"qeth\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/hashtable.h>\n#include <net/switchdev.h>\n#include <asm/chsc.h>\n#include <asm/css_chars.h>\n#include <asm/setup.h>\n#include \"qeth_core.h\"\n#include \"qeth_l2.h\"\n\nstatic int qeth_l2_setdelmac_makerc(struct qeth_card *card, u16 retcode)\n{\n\tint rc;\n\n\tif (retcode)\n\t\tQETH_CARD_TEXT_(card, 2, \"err%04x\", retcode);\n\tswitch (retcode) {\n\tcase IPA_RC_SUCCESS:\n\t\trc = 0;\n\t\tbreak;\n\tcase IPA_RC_L2_UNSUPPORTED_CMD:\n\t\trc = -EOPNOTSUPP;\n\t\tbreak;\n\tcase IPA_RC_L2_ADDR_TABLE_FULL:\n\t\trc = -ENOSPC;\n\t\tbreak;\n\tcase IPA_RC_L2_DUP_MAC:\n\tcase IPA_RC_L2_DUP_LAYER3_MAC:\n\t\trc = -EADDRINUSE;\n\t\tbreak;\n\tcase IPA_RC_L2_MAC_NOT_AUTH_BY_HYP:\n\tcase IPA_RC_L2_MAC_NOT_AUTH_BY_ADP:\n\t\trc = -EADDRNOTAVAIL;\n\t\tbreak;\n\tcase IPA_RC_L2_MAC_NOT_FOUND:\n\t\trc = -ENOENT;\n\t\tbreak;\n\tdefault:\n\t\trc = -EIO;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int qeth_l2_send_setdelmac_cb(struct qeth_card *card,\n\t\t\t\t     struct qeth_reply *reply,\n\t\t\t\t     unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\n\treturn qeth_l2_setdelmac_makerc(card, cmd->hdr.return_code);\n}\n\nstatic int qeth_l2_send_setdelmac(struct qeth_card *card, const __u8 *mac,\n\t\t\t   enum qeth_ipa_cmds ipacmd)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"L2sdmac\");\n\tiob = qeth_ipa_alloc_cmd(card, ipacmd, QETH_PROT_IPV4,\n\t\t\t\t IPA_DATA_SIZEOF(setdelmac));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\tcmd->data.setdelmac.mac_length = ETH_ALEN;\n\tether_addr_copy(cmd->data.setdelmac.mac, mac);\n\treturn qeth_send_ipa_cmd(card, iob, qeth_l2_send_setdelmac_cb, NULL);\n}\n\nstatic int qeth_l2_send_setmac(struct qeth_card *card, const __u8 *mac)\n{\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"L2Setmac\");\n\trc = qeth_l2_send_setdelmac(card, mac, IPA_CMD_SETVMAC);\n\tif (rc == 0) {\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"MAC address %pM successfully registered\\n\", mac);\n\t} else {\n\t\tswitch (rc) {\n\t\tcase -EADDRINUSE:\n\t\t\tdev_warn(&card->gdev->dev,\n\t\t\t\t\"MAC address %pM already exists\\n\", mac);\n\t\t\tbreak;\n\t\tcase -EADDRNOTAVAIL:\n\t\t\tdev_warn(&card->gdev->dev,\n\t\t\t\t\"MAC address %pM is not authorized\\n\", mac);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int qeth_l2_write_mac(struct qeth_card *card, u8 *mac)\n{\n\tenum qeth_ipa_cmds cmd = is_multicast_ether_addr(mac) ?\n\t\t\t\t\tIPA_CMD_SETGMAC : IPA_CMD_SETVMAC;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"L2Wmac\");\n\trc = qeth_l2_send_setdelmac(card, mac, cmd);\n\tif (rc == -EADDRINUSE)\n\t\tQETH_DBF_MESSAGE(2, \"MAC address %012llx is already registered on device %x\\n\",\n\t\t\t\t ether_addr_to_u64(mac), CARD_DEVID(card));\n\telse if (rc)\n\t\tQETH_DBF_MESSAGE(2, \"Failed to register MAC address %012llx on device %x: %d\\n\",\n\t\t\t\t ether_addr_to_u64(mac), CARD_DEVID(card), rc);\n\treturn rc;\n}\n\nstatic int qeth_l2_remove_mac(struct qeth_card *card, u8 *mac)\n{\n\tenum qeth_ipa_cmds cmd = is_multicast_ether_addr(mac) ?\n\t\t\t\t\tIPA_CMD_DELGMAC : IPA_CMD_DELVMAC;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"L2Rmac\");\n\trc = qeth_l2_send_setdelmac(card, mac, cmd);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"Failed to delete MAC address %012llx on device %x: %d\\n\",\n\t\t\t\t ether_addr_to_u64(mac), CARD_DEVID(card), rc);\n\treturn rc;\n}\n\nstatic void qeth_l2_drain_rx_mode_cache(struct qeth_card *card)\n{\n\tstruct qeth_mac *mac;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\thash_for_each_safe(card->rx_mode_addrs, i, tmp, mac, hnode) {\n\t\thash_del(&mac->hnode);\n\t\tkfree(mac);\n\t}\n}\n\nstatic void qeth_l2_fill_header(struct qeth_qdio_out_q *queue,\n\t\t\t\tstruct qeth_hdr *hdr, struct sk_buff *skb,\n\t\t\t\t__be16 proto, unsigned int data_len)\n{\n\tint cast_type = qeth_get_ether_cast_type(skb);\n\tstruct vlan_ethhdr *veth = vlan_eth_hdr(skb);\n\n\thdr->hdr.l2.pkt_length = data_len;\n\n\tif (skb_is_gso(skb)) {\n\t\thdr->hdr.l2.id = QETH_HEADER_TYPE_L2_TSO;\n\t} else {\n\t\thdr->hdr.l2.id = QETH_HEADER_TYPE_LAYER2;\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tqeth_tx_csum(skb, &hdr->hdr.l2.flags[1], proto);\n\t}\n\n\t \n\tif (cast_type == RTN_MULTICAST)\n\t\thdr->hdr.l2.flags[2] |= QETH_LAYER2_FLAG_MULTICAST;\n\telse if (cast_type == RTN_BROADCAST)\n\t\thdr->hdr.l2.flags[2] |= QETH_LAYER2_FLAG_BROADCAST;\n\telse\n\t\thdr->hdr.l2.flags[2] |= QETH_LAYER2_FLAG_UNICAST;\n\n\t \n\tif (veth->h_vlan_proto == htons(ETH_P_8021Q)) {\n\t\thdr->hdr.l2.flags[2] |= QETH_LAYER2_FLAG_VLAN;\n\t\thdr->hdr.l2.vlan_id = ntohs(veth->h_vlan_TCI);\n\t}\n}\n\nstatic int qeth_l2_setdelvlan_makerc(struct qeth_card *card, u16 retcode)\n{\n\tif (retcode)\n\t\tQETH_CARD_TEXT_(card, 2, \"err%04x\", retcode);\n\n\tswitch (retcode) {\n\tcase IPA_RC_SUCCESS:\n\t\treturn 0;\n\tcase IPA_RC_L2_INVALID_VLAN_ID:\n\t\treturn -EINVAL;\n\tcase IPA_RC_L2_DUP_VLAN_ID:\n\t\treturn -EEXIST;\n\tcase IPA_RC_L2_VLAN_ID_NOT_FOUND:\n\t\treturn -ENOENT;\n\tcase IPA_RC_L2_VLAN_ID_NOT_ALLOWED:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int qeth_l2_send_setdelvlan_cb(struct qeth_card *card,\n\t\t\t\t      struct qeth_reply *reply,\n\t\t\t\t      unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\n\tQETH_CARD_TEXT(card, 2, \"L2sdvcb\");\n\tif (cmd->hdr.return_code) {\n\t\tQETH_DBF_MESSAGE(2, \"Error in processing VLAN %u on device %x: %#x.\\n\",\n\t\t\t\t cmd->data.setdelvlan.vlan_id,\n\t\t\t\t CARD_DEVID(card), cmd->hdr.return_code);\n\t\tQETH_CARD_TEXT_(card, 2, \"L2VL%4x\", cmd->hdr.command);\n\t}\n\treturn qeth_l2_setdelvlan_makerc(card, cmd->hdr.return_code);\n}\n\nstatic int qeth_l2_send_setdelvlan(struct qeth_card *card, __u16 i,\n\t\t\t\t   enum qeth_ipa_cmds ipacmd)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT_(card, 4, \"L2sdv%x\", ipacmd);\n\tiob = qeth_ipa_alloc_cmd(card, ipacmd, QETH_PROT_IPV4,\n\t\t\t\t IPA_DATA_SIZEOF(setdelvlan));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\tcmd = __ipa_cmd(iob);\n\tcmd->data.setdelvlan.vlan_id = i;\n\treturn qeth_send_ipa_cmd(card, iob, qeth_l2_send_setdelvlan_cb, NULL);\n}\n\nstatic int qeth_l2_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t   __be16 proto, u16 vid)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tQETH_CARD_TEXT_(card, 4, \"aid:%d\", vid);\n\tif (!vid)\n\t\treturn 0;\n\n\treturn qeth_l2_send_setdelvlan(card, vid, IPA_CMD_SETVLAN);\n}\n\nstatic int qeth_l2_vlan_rx_kill_vid(struct net_device *dev,\n\t\t\t\t    __be16 proto, u16 vid)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tQETH_CARD_TEXT_(card, 4, \"kid:%d\", vid);\n\tif (!vid)\n\t\treturn 0;\n\n\treturn qeth_l2_send_setdelvlan(card, vid, IPA_CMD_DELVLAN);\n}\n\nstatic void qeth_l2_set_pnso_mode(struct qeth_card *card,\n\t\t\t\t  enum qeth_pnso_mode mode)\n{\n\tspin_lock_irq(get_ccwdev_lock(CARD_RDEV(card)));\n\tWRITE_ONCE(card->info.pnso_mode, mode);\n\tspin_unlock_irq(get_ccwdev_lock(CARD_RDEV(card)));\n\n\tif (mode == QETH_PNSO_NONE)\n\t\tdrain_workqueue(card->event_wq);\n}\n\nstatic void qeth_l2_dev2br_fdb_flush(struct qeth_card *card)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\n\tQETH_CARD_TEXT(card, 2, \"fdbflush\");\n\n\tinfo.addr = NULL;\n\t \n\tinfo.vid = 0;\n\tinfo.added_by_user = false;\n\tinfo.offloaded = true;\n\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_FLUSH_TO_BRIDGE,\n\t\t\t\t card->dev, &info.info, NULL);\n}\n\nstatic int qeth_l2_request_initial_mac(struct qeth_card *card)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"l2reqmac\");\n\n\tif (MACHINE_IS_VM) {\n\t\trc = qeth_vm_request_mac(card);\n\t\tif (!rc)\n\t\t\tgoto out;\n\t\tQETH_DBF_MESSAGE(2, \"z/VM MAC Service failed on device %x: %#x\\n\",\n\t\t\t\t CARD_DEVID(card), rc);\n\t\tQETH_CARD_TEXT_(card, 2, \"err%04x\", rc);\n\t\t \n\t}\n\n\trc = qeth_setadpparms_change_macaddr(card);\n\tif (!rc)\n\t\tgoto out;\n\tQETH_DBF_MESSAGE(2, \"READ_MAC Assist failed on device %x: %#x\\n\",\n\t\t\t CARD_DEVID(card), rc);\n\tQETH_CARD_TEXT_(card, 2, \"1err%04x\", rc);\n\n\t \n\tif (IS_OSM(card) || IS_OSX(card))\n\t\treturn (rc) ? rc : -EADDRNOTAVAIL;\n\teth_hw_addr_random(card->dev);\n\nout:\n\tQETH_CARD_HEX(card, 2, card->dev->dev_addr, card->dev->addr_len);\n\treturn 0;\n}\n\nstatic void qeth_l2_register_dev_addr(struct qeth_card *card)\n{\n\tif (!is_valid_ether_addr(card->dev->dev_addr))\n\t\tqeth_l2_request_initial_mac(card);\n\n\tif (!qeth_l2_send_setmac(card, card->dev->dev_addr))\n\t\tcard->info.dev_addr_is_registered = 1;\n\telse\n\t\tcard->info.dev_addr_is_registered = 0;\n}\n\nstatic int qeth_l2_validate_addr(struct net_device *dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tif (card->info.dev_addr_is_registered)\n\t\treturn eth_validate_addr(dev);\n\n\tQETH_CARD_TEXT(card, 4, \"nomacadr\");\n\treturn -EPERM;\n}\n\nstatic int qeth_l2_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct qeth_card *card = dev->ml_priv;\n\tu8 old_addr[ETH_ALEN];\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 3, \"setmac\");\n\n\tif (IS_OSM(card) || IS_OSX(card)) {\n\t\tQETH_CARD_TEXT(card, 3, \"setmcTYP\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tQETH_CARD_HEX(card, 3, addr->sa_data, ETH_ALEN);\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tif (ether_addr_equal_64bits(dev->dev_addr, addr->sa_data) &&\n\t    card->info.dev_addr_is_registered)\n\t\treturn 0;\n\n\t \n\trc = qeth_l2_send_setmac(card, addr->sa_data);\n\tif (rc)\n\t\treturn rc;\n\tether_addr_copy(old_addr, dev->dev_addr);\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tif (card->info.dev_addr_is_registered)\n\t\tqeth_l2_remove_mac(card, old_addr);\n\tcard->info.dev_addr_is_registered = 1;\n\treturn 0;\n}\n\nstatic void qeth_l2_promisc_to_bridge(struct qeth_card *card, bool enable)\n{\n\tint role;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"pmisc2br\");\n\n\tif (enable) {\n\t\tif (card->options.sbp.reflect_promisc_primary)\n\t\t\trole = QETH_SBP_ROLE_PRIMARY;\n\t\telse\n\t\t\trole = QETH_SBP_ROLE_SECONDARY;\n\t} else\n\t\trole = QETH_SBP_ROLE_NONE;\n\n\trc = qeth_bridgeport_setrole(card, role);\n\tQETH_CARD_TEXT_(card, 2, \"bpm%c%04x\", enable ? '+' : '-', rc);\n\tif (!rc) {\n\t\tcard->options.sbp.role = role;\n\t\tcard->info.promisc_mode = enable;\n\t}\n}\n\nstatic void qeth_l2_set_promisc_mode(struct qeth_card *card)\n{\n\tbool enable = card->dev->flags & IFF_PROMISC;\n\n\tif (card->info.promisc_mode == enable)\n\t\treturn;\n\n\tif (qeth_adp_supported(card, IPA_SETADP_SET_PROMISC_MODE)) {\n\t\tqeth_setadp_promisc_mode(card, enable);\n\t} else {\n\t\tmutex_lock(&card->sbp_lock);\n\t\tif (card->options.sbp.reflect_promisc)\n\t\t\tqeth_l2_promisc_to_bridge(card, enable);\n\t\tmutex_unlock(&card->sbp_lock);\n\t}\n}\n\n \nstatic void qeth_l2_add_mac(struct qeth_card *card, struct netdev_hw_addr *ha)\n{\n\tu32 mac_hash = get_unaligned((u32 *)(&ha->addr[2]));\n\tstruct qeth_mac *mac;\n\n\thash_for_each_possible(card->rx_mode_addrs, mac, hnode, mac_hash) {\n\t\tif (ether_addr_equal_64bits(ha->addr, mac->mac_addr)) {\n\t\t\tmac->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmac = kzalloc(sizeof(struct qeth_mac), GFP_ATOMIC);\n\tif (!mac)\n\t\treturn;\n\n\tether_addr_copy(mac->mac_addr, ha->addr);\n\tmac->disp_flag = QETH_DISP_ADDR_ADD;\n\n\thash_add(card->rx_mode_addrs, &mac->hnode, mac_hash);\n}\n\nstatic void qeth_l2_rx_mode_work(struct work_struct *work)\n{\n\tstruct qeth_card *card = container_of(work, struct qeth_card,\n\t\t\t\t\t      rx_mode_work);\n\tstruct net_device *dev = card->dev;\n\tstruct netdev_hw_addr *ha;\n\tstruct qeth_mac *mac;\n\tstruct hlist_node *tmp;\n\tint i;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 3, \"setmulti\");\n\n\tnetif_addr_lock_bh(dev);\n\tnetdev_for_each_mc_addr(ha, dev)\n\t\tqeth_l2_add_mac(card, ha);\n\tnetdev_for_each_uc_addr(ha, dev)\n\t\tqeth_l2_add_mac(card, ha);\n\tnetif_addr_unlock_bh(dev);\n\n\thash_for_each_safe(card->rx_mode_addrs, i, tmp, mac, hnode) {\n\t\tswitch (mac->disp_flag) {\n\t\tcase QETH_DISP_ADDR_DELETE:\n\t\t\tqeth_l2_remove_mac(card, mac->mac_addr);\n\t\t\thash_del(&mac->hnode);\n\t\t\tkfree(mac);\n\t\t\tbreak;\n\t\tcase QETH_DISP_ADDR_ADD:\n\t\t\trc = qeth_l2_write_mac(card, mac->mac_addr);\n\t\t\tif (rc) {\n\t\t\t\thash_del(&mac->hnode);\n\t\t\t\tkfree(mac);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\t \n\t\t\tmac->disp_flag = QETH_DISP_ADDR_DELETE;\n\t\t}\n\t}\n\n\tqeth_l2_set_promisc_mode(card);\n}\n\nstatic netdev_tx_t qeth_l2_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tu16 txq = skb_get_queue_mapping(skb);\n\tstruct qeth_qdio_out_q *queue;\n\tint rc;\n\n\tif (!skb_is_gso(skb))\n\t\tqdisc_skb_cb(skb)->pkt_len = skb->len;\n\tif (IS_IQD(card))\n\t\ttxq = qeth_iqd_translate_txq(dev, txq);\n\tqueue = card->qdio.out_qs[txq];\n\n\trc = qeth_xmit(card, skb, queue, vlan_get_protocol(skb),\n\t\t       qeth_l2_fill_header);\n\tif (!rc)\n\t\treturn NETDEV_TX_OK;\n\n\tQETH_TXQ_STAT_INC(queue, tx_dropped);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic u16 qeth_l2_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t\t    struct net_device *sb_dev)\n{\n\treturn qeth_iqd_select_queue(dev, skb, qeth_get_ether_cast_type(skb),\n\t\t\t\t     sb_dev);\n}\n\nstatic void qeth_l2_set_rx_mode(struct net_device *dev)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\n\tschedule_work(&card->rx_mode_work);\n}\n\n \nstatic int qeth_l2_pnso(struct qeth_card *card, u8 oc, int cnc,\n\t\t\tvoid (*cb)(void *priv, struct chsc_pnso_naid_l2 *entry),\n\t\t\tvoid *priv)\n{\n\tstruct ccw_device *ddev = CARD_DDEV(card);\n\tstruct chsc_pnso_area *rr;\n\tu32 prev_instance = 0;\n\tint isfirstblock = 1;\n\tint i, size, elems;\n\tint rc;\n\n\trr = (struct chsc_pnso_area *)get_zeroed_page(GFP_KERNEL);\n\tif (rr == NULL)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tQETH_CARD_TEXT(card, 2, \"PNSO\");\n\t\t \n\t\trc = ccw_device_pnso(ddev, rr, oc, rr->naihdr.resume_token,\n\t\t\t\t     cnc);\n\t\tif (rc)\n\t\t\tcontinue;\n\t\tif (cb == NULL)\n\t\t\tcontinue;\n\n\t\tsize = rr->naihdr.naids;\n\t\tif (size != sizeof(struct chsc_pnso_naid_l2)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\telems = (rr->response.length - sizeof(struct chsc_header) -\n\t\t\t sizeof(struct chsc_pnso_naihdr)) / size;\n\n\t\tif (!isfirstblock && (rr->naihdr.instance != prev_instance)) {\n\t\t\t \n\t\t\t \n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tisfirstblock = 0;\n\t\tprev_instance = rr->naihdr.instance;\n\t\tfor (i = 0; i < elems; i++)\n\t\t\t(*cb)(priv, &rr->entries[i]);\n\t} while ((rc == -EBUSY) || (!rc &&  \n\t\t    \n\t\t   (rr->naihdr.resume_token.t1 || rr->naihdr.resume_token.t2)));\n\n\tif (rc)\n\t\tQETH_CARD_TEXT_(card, 2, \"PNrp%04x\", rr->response.code);\n\n\tfree_page((unsigned long)rr);\n\treturn rc;\n}\n\nstatic bool qeth_is_my_net_if_token(struct qeth_card *card,\n\t\t\t\t    struct net_if_token *token)\n{\n\treturn ((card->info.ddev_devno == token->devnum) &&\n\t\t(card->info.cssid == token->cssid) &&\n\t\t(card->info.iid == token->iid) &&\n\t\t(card->info.ssid == token->ssid) &&\n\t\t(card->info.chpid == token->chpid) &&\n\t\t(card->info.chid == token->chid));\n}\n\n \nstatic void qeth_l2_dev2br_fdb_notify(struct qeth_card *card, u8 code,\n\t\t\t\t      struct net_if_token *token,\n\t\t\t\t      struct mac_addr_lnid *addr_lnid)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\tu8 ntfy_mac[ETH_ALEN];\n\n\tether_addr_copy(ntfy_mac, addr_lnid->mac);\n\t \n\tif (!(code & IPA_ADDR_CHANGE_CODE_MACADDR))\n\t\treturn;\n\t \n\tif (is_multicast_ether_addr(ntfy_mac))\n\t\treturn;\n\t \n\tif (qeth_is_my_net_if_token(card, token))\n\t\treturn;\n\n\tinfo.addr = ntfy_mac;\n\t \n\tinfo.vid = 0;\n\tinfo.added_by_user = false;\n\tinfo.offloaded = true;\n\n\tif (code & IPA_ADDR_CHANGE_CODE_REMOVAL) {\n\t\tcall_switchdev_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE,\n\t\t\t\t\t card->dev, &info.info, NULL);\n\t\tQETH_CARD_TEXT(card, 4, \"andelmac\");\n\t\tQETH_CARD_TEXT_(card, 4,\n\t\t\t\t\"mc%012llx\", ether_addr_to_u64(ntfy_mac));\n\t} else {\n\t\tcall_switchdev_notifiers(SWITCHDEV_FDB_ADD_TO_BRIDGE,\n\t\t\t\t\t card->dev, &info.info, NULL);\n\t\tQETH_CARD_TEXT(card, 4, \"anaddmac\");\n\t\tQETH_CARD_TEXT_(card, 4,\n\t\t\t\t\"mc%012llx\", ether_addr_to_u64(ntfy_mac));\n\t}\n}\n\nstatic void qeth_l2_dev2br_an_set_cb(void *priv,\n\t\t\t\t     struct chsc_pnso_naid_l2 *entry)\n{\n\tu8 code = IPA_ADDR_CHANGE_CODE_MACADDR;\n\tstruct qeth_card *card = priv;\n\n\tif (entry->addr_lnid.lnid < VLAN_N_VID)\n\t\tcode |= IPA_ADDR_CHANGE_CODE_VLANID;\n\tqeth_l2_dev2br_fdb_notify(card, code,\n\t\t\t\t  (struct net_if_token *)&entry->nit,\n\t\t\t\t  (struct mac_addr_lnid *)&entry->addr_lnid);\n}\n\n \nstatic int qeth_l2_dev2br_an_set(struct qeth_card *card, bool enable)\n{\n\tint rc;\n\n\tif (enable) {\n\t\tQETH_CARD_TEXT(card, 2, \"anseton\");\n\t\trc = qeth_l2_pnso(card, PNSO_OC_NET_ADDR_INFO, 1,\n\t\t\t\t  qeth_l2_dev2br_an_set_cb, card);\n\t\tif (rc == -EAGAIN)\n\t\t\t \n\t\t\tqeth_l2_pnso(card, PNSO_OC_NET_ADDR_INFO, 0,\n\t\t\t\t     NULL, NULL);\n\t} else {\n\t\tQETH_CARD_TEXT(card, 2, \"ansetoff\");\n\t\trc = qeth_l2_pnso(card, PNSO_OC_NET_ADDR_INFO, 0, NULL, NULL);\n\t}\n\n\treturn rc;\n}\n\nstruct qeth_l2_br2dev_event_work {\n\tstruct work_struct work;\n\tstruct net_device *br_dev;\n\tstruct net_device *lsync_dev;\n\tstruct net_device *dst_dev;\n\tunsigned long event;\n\tunsigned char addr[ETH_ALEN];\n};\n\nstatic const struct net_device_ops qeth_l2_iqd_netdev_ops;\nstatic const struct net_device_ops qeth_l2_osa_netdev_ops;\n\nstatic bool qeth_l2_must_learn(struct net_device *netdev,\n\t\t\t       struct net_device *dstdev)\n{\n\tstruct qeth_priv *priv;\n\n\tpriv = netdev_priv(netdev);\n\treturn (netdev != dstdev &&\n\t\t(priv->brport_features & BR_LEARNING_SYNC) &&\n\t\t!(br_port_flag_is_set(netdev, BR_ISOLATED) &&\n\t\t  br_port_flag_is_set(dstdev, BR_ISOLATED)) &&\n\t\t(netdev->netdev_ops == &qeth_l2_iqd_netdev_ops ||\n\t\t netdev->netdev_ops == &qeth_l2_osa_netdev_ops));\n}\n\n \nstatic void qeth_l2_br2dev_worker(struct work_struct *work)\n{\n\tstruct qeth_l2_br2dev_event_work *br2dev_event_work =\n\t\tcontainer_of(work, struct qeth_l2_br2dev_event_work, work);\n\tstruct net_device *lsyncdev = br2dev_event_work->lsync_dev;\n\tstruct net_device *dstdev = br2dev_event_work->dst_dev;\n\tstruct net_device *brdev = br2dev_event_work->br_dev;\n\tunsigned long event = br2dev_event_work->event;\n\tunsigned char *addr = br2dev_event_work->addr;\n\tstruct qeth_card *card = lsyncdev->ml_priv;\n\tstruct net_device *lowerdev;\n\tstruct list_head *iter;\n\tint err = 0;\n\n\tQETH_CARD_TEXT_(card, 4, \"b2dw%04lx\", event);\n\tQETH_CARD_TEXT_(card, 4, \"ma%012llx\", ether_addr_to_u64(addr));\n\n\trcu_read_lock();\n\t \n\tif (!netif_is_bridge_port(lsyncdev) ||\n\t    brdev != netdev_master_upper_dev_get_rcu(lsyncdev))\n\t\tgoto unlock;\n\tif (!qeth_l2_must_learn(lsyncdev, dstdev))\n\t\tgoto unlock;\n\n\tif (br_port_flag_is_set(lsyncdev, BR_ISOLATED)) {\n\t\t \n\t\titer = &brdev->adj_list.lower;\n\t\tlowerdev = netdev_next_lower_dev_rcu(brdev, &iter);\n\t\twhile (lowerdev) {\n\t\t\tif (br_port_flag_is_set(lowerdev, BR_ISOLATED)) {\n\t\t\t\tswitch (event) {\n\t\t\t\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\t\t\t\terr = dev_uc_add(lowerdev, addr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\t\t\t\terr = dev_uc_del(lowerdev, addr);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (err) {\n\t\t\t\t\tQETH_CARD_TEXT(card, 2, \"b2derris\");\n\t\t\t\t\tQETH_CARD_TEXT_(card, 2,\n\t\t\t\t\t\t\t\"err%02lx%03d\", event,\n\t\t\t\t\t\t\tlowerdev->ifindex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlowerdev = netdev_next_lower_dev_rcu(brdev, &iter);\n\t\t}\n\t} else {\n\t\tswitch (event) {\n\t\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\t\terr = dev_uc_add(lsyncdev, addr);\n\t\t\tbreak;\n\t\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\t\terr = dev_uc_del(lsyncdev, addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (err)\n\t\t\tQETH_CARD_TEXT_(card, 2, \"b2derr%02lx\", event);\n\t}\n\nunlock:\n\trcu_read_unlock();\n\tdev_put(brdev);\n\tdev_put(lsyncdev);\n\tdev_put(dstdev);\n\tkfree(br2dev_event_work);\n}\n\nstatic int qeth_l2_br2dev_queue_work(struct net_device *brdev,\n\t\t\t\t     struct net_device *lsyncdev,\n\t\t\t\t     struct net_device *dstdev,\n\t\t\t\t     unsigned long event,\n\t\t\t\t     const unsigned char *addr)\n{\n\tstruct qeth_l2_br2dev_event_work *worker_data;\n\tstruct qeth_card *card;\n\n\tworker_data = kzalloc(sizeof(*worker_data), GFP_ATOMIC);\n\tif (!worker_data)\n\t\treturn -ENOMEM;\n\tINIT_WORK(&worker_data->work, qeth_l2_br2dev_worker);\n\tworker_data->br_dev = brdev;\n\tworker_data->lsync_dev = lsyncdev;\n\tworker_data->dst_dev = dstdev;\n\tworker_data->event = event;\n\tether_addr_copy(worker_data->addr, addr);\n\n\tcard = lsyncdev->ml_priv;\n\t \n\tdev_hold(brdev);\n\tdev_hold(lsyncdev);\n\tdev_hold(dstdev);\n\tqueue_work(card->event_wq, &worker_data->work);\n\treturn 0;\n}\n\n \nstatic int qeth_l2_switchdev_event(struct notifier_block *unused,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dstdev, *brdev, *lowerdev;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct switchdev_notifier_info *info = ptr;\n\tstruct list_head *iter;\n\tstruct qeth_card *card;\n\tint rc;\n\n\tif (!(event == SWITCHDEV_FDB_ADD_TO_DEVICE ||\n\t      event == SWITCHDEV_FDB_DEL_TO_DEVICE))\n\t\treturn NOTIFY_DONE;\n\n\tdstdev = switchdev_notifier_info_to_dev(info);\n\tbrdev = netdev_master_upper_dev_get_rcu(dstdev);\n\tif (!brdev || !netif_is_bridge_master(brdev))\n\t\treturn NOTIFY_DONE;\n\tfdb_info = container_of(info,\n\t\t\t\tstruct switchdev_notifier_fdb_info,\n\t\t\t\tinfo);\n\titer = &brdev->adj_list.lower;\n\tlowerdev = netdev_next_lower_dev_rcu(brdev, &iter);\n\twhile (lowerdev) {\n\t\tif (qeth_l2_must_learn(lowerdev, dstdev)) {\n\t\t\tcard = lowerdev->ml_priv;\n\t\t\tQETH_CARD_TEXT_(card, 4, \"b2dqw%03lx\", event);\n\t\t\trc = qeth_l2_br2dev_queue_work(brdev, lowerdev,\n\t\t\t\t\t\t       dstdev, event,\n\t\t\t\t\t\t       fdb_info->addr);\n\t\t\tif (rc) {\n\t\t\t\tQETH_CARD_TEXT(card, 2, \"b2dqwerr\");\n\t\t\t\treturn NOTIFY_BAD;\n\t\t\t}\n\t\t}\n\t\tlowerdev = netdev_next_lower_dev_rcu(brdev, &iter);\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block qeth_l2_sw_notifier = {\n\t\t.notifier_call = qeth_l2_switchdev_event,\n};\n\nstatic refcount_t qeth_l2_switchdev_notify_refcnt;\n\n \nstatic void qeth_l2_br2dev_get(void)\n{\n\tint rc;\n\n\tif (!refcount_inc_not_zero(&qeth_l2_switchdev_notify_refcnt)) {\n\t\trc = register_switchdev_notifier(&qeth_l2_sw_notifier);\n\t\tif (rc) {\n\t\t\tQETH_DBF_MESSAGE(2,\n\t\t\t\t\t \"failed to register qeth_l2_sw_notifier: %d\\n\",\n\t\t\t\t\t rc);\n\t\t} else {\n\t\t\trefcount_set(&qeth_l2_switchdev_notify_refcnt, 1);\n\t\t\tQETH_DBF_MESSAGE(2, \"qeth_l2_sw_notifier registered\\n\");\n\t\t}\n\t}\n\tQETH_DBF_TEXT_(SETUP, 2, \"b2d+%04d\",\n\t\t       qeth_l2_switchdev_notify_refcnt.refs.counter);\n}\n\n \nstatic void qeth_l2_br2dev_put(void)\n{\n\tint rc;\n\n\tif (refcount_dec_and_test(&qeth_l2_switchdev_notify_refcnt)) {\n\t\trc = unregister_switchdev_notifier(&qeth_l2_sw_notifier);\n\t\tif (rc) {\n\t\t\tQETH_DBF_MESSAGE(2,\n\t\t\t\t\t \"failed to unregister qeth_l2_sw_notifier: %d\\n\",\n\t\t\t\t\t rc);\n\t\t} else {\n\t\t\tQETH_DBF_MESSAGE(2,\n\t\t\t\t\t \"qeth_l2_sw_notifier unregistered\\n\");\n\t\t}\n\t}\n\tQETH_DBF_TEXT_(SETUP, 2, \"b2d-%04d\",\n\t\t       qeth_l2_switchdev_notify_refcnt.refs.counter);\n}\n\nstatic int qeth_l2_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t\t  struct net_device *dev, u32 filter_mask,\n\t\t\t\t  int nlflags)\n{\n\tstruct qeth_priv *priv = netdev_priv(dev);\n\tstruct qeth_card *card = dev->ml_priv;\n\tu16 mode = BRIDGE_MODE_UNDEF;\n\n\t \n\tif (!priv->brport_hw_features || !netif_device_present(dev) ||\n\t    qeth_bridgeport_is_in_use(card))\n\t\treturn -EOPNOTSUPP;\n\n\treturn ndo_dflt_bridge_getlink(skb, pid, seq, dev,\n\t\t\t\t       mode, priv->brport_features,\n\t\t\t\t       priv->brport_hw_features,\n\t\t\t\t       nlflags, filter_mask, NULL);\n}\n\nstatic const struct nla_policy qeth_brport_policy[IFLA_BRPORT_MAX + 1] = {\n\t[IFLA_BRPORT_LEARNING_SYNC]\t= { .type = NLA_U8 },\n};\n\n \nstatic int qeth_l2_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,\n\t\t\t\t  u16 flags, struct netlink_ext_ack *extack)\n{\n\tstruct qeth_priv *priv = netdev_priv(dev);\n\tstruct nlattr *bp_tb[IFLA_BRPORT_MAX + 1];\n\tstruct qeth_card *card = dev->ml_priv;\n\tstruct nlattr *attr, *nested_attr;\n\tbool enable, has_protinfo = false;\n\tint rem1, rem2;\n\tint rc;\n\n\tif (!netif_device_present(dev))\n\t\treturn -ENODEV;\n\n\tnlmsg_for_each_attr(attr, nlh, sizeof(struct ifinfomsg), rem1) {\n\t\tif (nla_type(attr) == IFLA_PROTINFO) {\n\t\t\trc = nla_parse_nested(bp_tb, IFLA_BRPORT_MAX, attr,\n\t\t\t\t\t      qeth_brport_policy, extack);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\thas_protinfo = true;\n\t\t} else if (nla_type(attr) == IFLA_AF_SPEC) {\n\t\t\tnla_for_each_nested(nested_attr, attr, rem2) {\n\t\t\t\tif (nla_type(nested_attr) == IFLA_BRIDGE_FLAGS)\n\t\t\t\t\tcontinue;\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nested_attr,\n\t\t\t\t\t\t    \"Unsupported attribute\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr, \"Unsupported attribute\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!has_protinfo)\n\t\treturn 0;\n\tif (!bp_tb[IFLA_BRPORT_LEARNING_SYNC])\n\t\treturn -EINVAL;\n\tif (!(priv->brport_hw_features & BR_LEARNING_SYNC)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, bp_tb[IFLA_BRPORT_LEARNING_SYNC],\n\t\t\t\t    \"Operation not supported by HW\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!IS_ENABLED(CONFIG_NET_SWITCHDEV)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, bp_tb[IFLA_BRPORT_LEARNING_SYNC],\n\t\t\t\t    \"Requires NET_SWITCHDEV\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tenable = !!nla_get_u8(bp_tb[IFLA_BRPORT_LEARNING_SYNC]);\n\n\tif (enable == !!(priv->brport_features & BR_LEARNING_SYNC))\n\t\treturn 0;\n\n\tmutex_lock(&card->sbp_lock);\n\t \n\tif (qeth_bridgeport_is_in_use(card)) {\n\t\tNL_SET_ERR_MSG(extack, \"n/a (BridgePort)\");\n\t\trc = -EBUSY;\n\t} else if (enable) {\n\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_ADDR_INFO);\n\t\trc = qeth_l2_dev2br_an_set(card, true);\n\t\tif (rc) {\n\t\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);\n\t\t} else {\n\t\t\tpriv->brport_features |= BR_LEARNING_SYNC;\n\t\t\tqeth_l2_br2dev_get();\n\t\t}\n\t} else {\n\t\trc = qeth_l2_dev2br_an_set(card, false);\n\t\tif (!rc) {\n\t\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);\n\t\t\tpriv->brport_features ^= BR_LEARNING_SYNC;\n\t\t\tqeth_l2_dev2br_fdb_flush(card);\n\t\t\tqeth_l2_br2dev_put();\n\t\t}\n\t}\n\tmutex_unlock(&card->sbp_lock);\n\n\treturn rc;\n}\n\nstatic const struct net_device_ops qeth_l2_iqd_netdev_ops = {\n\t.ndo_open\t\t= qeth_open,\n\t.ndo_stop\t\t= qeth_stop,\n\t.ndo_get_stats64\t= qeth_get_stats64,\n\t.ndo_start_xmit\t\t= qeth_l2_hard_start_xmit,\n\t.ndo_features_check\t= qeth_features_check,\n\t.ndo_select_queue\t= qeth_l2_iqd_select_queue,\n\t.ndo_validate_addr\t= qeth_l2_validate_addr,\n\t.ndo_set_rx_mode\t= qeth_l2_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= qeth_do_ioctl,\n\t.ndo_siocdevprivate\t= qeth_siocdevprivate,\n\t.ndo_set_mac_address\t= qeth_l2_set_mac_address,\n\t.ndo_vlan_rx_add_vid\t= qeth_l2_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= qeth_l2_vlan_rx_kill_vid,\n\t.ndo_tx_timeout\t\t= qeth_tx_timeout,\n\t.ndo_fix_features\t= qeth_fix_features,\n\t.ndo_set_features\t= qeth_set_features,\n\t.ndo_bridge_getlink\t= qeth_l2_bridge_getlink,\n\t.ndo_bridge_setlink\t= qeth_l2_bridge_setlink,\n};\n\nstatic const struct net_device_ops qeth_l2_osa_netdev_ops = {\n\t.ndo_open\t\t= qeth_open,\n\t.ndo_stop\t\t= qeth_stop,\n\t.ndo_get_stats64\t= qeth_get_stats64,\n\t.ndo_start_xmit\t\t= qeth_l2_hard_start_xmit,\n\t.ndo_features_check\t= qeth_features_check,\n\t.ndo_select_queue\t= qeth_osa_select_queue,\n\t.ndo_validate_addr\t= qeth_l2_validate_addr,\n\t.ndo_set_rx_mode\t= qeth_l2_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= qeth_do_ioctl,\n\t.ndo_siocdevprivate\t= qeth_siocdevprivate,\n\t.ndo_set_mac_address    = qeth_l2_set_mac_address,\n\t.ndo_vlan_rx_add_vid\t= qeth_l2_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid   = qeth_l2_vlan_rx_kill_vid,\n\t.ndo_tx_timeout\t\t= qeth_tx_timeout,\n\t.ndo_fix_features\t= qeth_fix_features,\n\t.ndo_set_features\t= qeth_set_features,\n};\n\nstatic int qeth_l2_setup_netdev(struct qeth_card *card)\n{\n\tcard->dev->netdev_ops = IS_IQD(card) ? &qeth_l2_iqd_netdev_ops :\n\t\t\t\t\t       &qeth_l2_osa_netdev_ops;\n\tcard->dev->needed_headroom = sizeof(struct qeth_hdr);\n\tcard->dev->priv_flags |= IFF_UNICAST_FLT;\n\n\tif (IS_OSM(card)) {\n\t\tcard->dev->features |= NETIF_F_VLAN_CHALLENGED;\n\t} else {\n\t\tif (!IS_VM_NIC(card))\n\t\t\tcard->dev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\tcard->dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\t}\n\n\tif (IS_OSD(card) && !IS_VM_NIC(card)) {\n\t\tcard->dev->features |= NETIF_F_SG;\n\t\t \n\t\tif (qeth_is_supported(card, IPA_OUTBOUND_CHECKSUM)) {\n\t\t\tcard->dev->hw_features |= NETIF_F_IP_CSUM;\n\t\t\tcard->dev->vlan_features |= NETIF_F_IP_CSUM;\n\t\t}\n\t}\n\tif (qeth_is_supported6(card, IPA_OUTBOUND_CHECKSUM_V6)) {\n\t\tcard->dev->hw_features |= NETIF_F_IPV6_CSUM;\n\t\tcard->dev->vlan_features |= NETIF_F_IPV6_CSUM;\n\t}\n\tif (qeth_is_supported(card, IPA_INBOUND_CHECKSUM) ||\n\t    qeth_is_supported6(card, IPA_INBOUND_CHECKSUM_V6)) {\n\t\tcard->dev->hw_features |= NETIF_F_RXCSUM;\n\t\tcard->dev->vlan_features |= NETIF_F_RXCSUM;\n\t}\n\tif (qeth_is_supported(card, IPA_OUTBOUND_TSO)) {\n\t\tcard->dev->hw_features |= NETIF_F_TSO;\n\t\tcard->dev->vlan_features |= NETIF_F_TSO;\n\t}\n\tif (qeth_is_supported6(card, IPA_OUTBOUND_TSO)) {\n\t\tcard->dev->hw_features |= NETIF_F_TSO6;\n\t\tcard->dev->vlan_features |= NETIF_F_TSO6;\n\t}\n\n\tif (card->dev->hw_features & (NETIF_F_TSO | NETIF_F_TSO6)) {\n\t\tcard->dev->needed_headroom = sizeof(struct qeth_hdr_tso);\n\t\tnetif_keep_dst(card->dev);\n\t\tnetif_set_tso_max_size(card->dev,\n\t\t\t\t       PAGE_SIZE * (QDIO_MAX_ELEMENTS_PER_BUFFER - 1));\n\t}\n\n\tnetif_napi_add(card->dev, &card->napi, qeth_poll);\n\treturn register_netdev(card->dev);\n}\n\nstatic void qeth_l2_trace_features(struct qeth_card *card)\n{\n\t \n\tQETH_CARD_TEXT(card, 2, \"featuSBP\");\n\tQETH_CARD_HEX(card, 2, &card->options.sbp.supported_funcs,\n\t\t      sizeof(card->options.sbp.supported_funcs));\n\t \n\tQETH_CARD_TEXT(card, 2, \"feaVNICC\");\n\tQETH_CARD_HEX(card, 2, &card->options.vnicc.sup_chars,\n\t\t      sizeof(card->options.vnicc.sup_chars));\n}\n\nstatic void qeth_l2_setup_bridgeport_attrs(struct qeth_card *card)\n{\n\tif (!card->options.sbp.reflect_promisc &&\n\t    card->options.sbp.role != QETH_SBP_ROLE_NONE) {\n\t\t \n\t\tqeth_bridgeport_setrole(card, card->options.sbp.role);\n\t\t \n\t\tqeth_bridgeport_query_ports(card, &card->options.sbp.role,\n\t\t\t\t\t    NULL);\n\t}\n\tif (card->options.sbp.hostnotification) {\n\t\tif (qeth_bridgeport_an_set(card, 1))\n\t\t\tcard->options.sbp.hostnotification = 0;\n\t}\n}\n\n \nstatic void qeth_l2_detect_dev2br_support(struct qeth_card *card)\n{\n\tstruct qeth_priv *priv = netdev_priv(card->dev);\n\tbool dev2br_supported;\n\n\tQETH_CARD_TEXT(card, 2, \"d2brsup\");\n\tif (!IS_IQD(card))\n\t\treturn;\n\n\t \n\tdev2br_supported = card->info.ids_valid &&\n\t\t\t   css_general_characteristics.enarf;\n\tQETH_CARD_TEXT_(card, 2, \"D2Bsup%02x\", dev2br_supported);\n\n\tif (dev2br_supported)\n\t\tpriv->brport_hw_features |= BR_LEARNING_SYNC;\n\telse\n\t\tpriv->brport_hw_features &= ~BR_LEARNING_SYNC;\n}\n\nstatic void qeth_l2_enable_brport_features(struct qeth_card *card)\n{\n\tstruct qeth_priv *priv = netdev_priv(card->dev);\n\tint rc;\n\n\tif (priv->brport_features & BR_LEARNING_SYNC) {\n\t\tif (priv->brport_hw_features & BR_LEARNING_SYNC) {\n\t\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_ADDR_INFO);\n\t\t\trc = qeth_l2_dev2br_an_set(card, true);\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\t \n\t\t\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);\n\t\t\t\tqeth_l2_dev2br_fdb_flush(card);\n\t\t\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_ADDR_INFO);\n\t\t\t\trc = qeth_l2_dev2br_an_set(card, true);\n\t\t\t}\n\t\t\tif (rc) {\n\t\t\t\tnetdev_err(card->dev,\n\t\t\t\t\t   \"failed to enable bridge learning_sync: %d\\n\",\n\t\t\t\t\t   rc);\n\t\t\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);\n\t\t\t\tqeth_l2_dev2br_fdb_flush(card);\n\t\t\t\tpriv->brport_features ^= BR_LEARNING_SYNC;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(&card->gdev->dev,\n\t\t\t\t\"bridge learning_sync not supported\\n\");\n\t\t\tpriv->brport_features ^= BR_LEARNING_SYNC;\n\t\t}\n\t}\n}\n\n \n\nenum qeth_an_event_type {anev_reg_unreg, anev_abort, anev_reset};\n\n \nstatic void qeth_bridge_emit_host_event(struct qeth_card *card,\n\t\t\t\t\tenum qeth_an_event_type evtype,\n\t\t\t\t\tu8 code,\n\t\t\t\t\tstruct net_if_token *token,\n\t\t\t\t\tstruct mac_addr_lnid *addr_lnid)\n{\n\tchar str[7][32];\n\tchar *env[8];\n\tint i = 0;\n\n\tswitch (evtype) {\n\tcase anev_reg_unreg:\n\t\tscnprintf(str[i], sizeof(str[i]), \"BRIDGEDHOST=%s\",\n\t\t\t  (code & IPA_ADDR_CHANGE_CODE_REMOVAL)\n\t\t\t  ? \"deregister\" : \"register\");\n\t\tenv[i] = str[i]; i++;\n\t\tif (code & IPA_ADDR_CHANGE_CODE_VLANID) {\n\t\t\tscnprintf(str[i], sizeof(str[i]), \"VLAN=%d\",\n\t\t\t\t  addr_lnid->lnid);\n\t\t\tenv[i] = str[i]; i++;\n\t\t}\n\t\tif (code & IPA_ADDR_CHANGE_CODE_MACADDR) {\n\t\t\tscnprintf(str[i], sizeof(str[i]), \"MAC=%pM\",\n\t\t\t\t  addr_lnid->mac);\n\t\t\tenv[i] = str[i]; i++;\n\t\t}\n\t\tscnprintf(str[i], sizeof(str[i]), \"NTOK_BUSID=%x.%x.%04x\",\n\t\t\t  token->cssid, token->ssid, token->devnum);\n\t\tenv[i] = str[i]; i++;\n\t\tscnprintf(str[i], sizeof(str[i]), \"NTOK_IID=%02x\", token->iid);\n\t\tenv[i] = str[i]; i++;\n\t\tscnprintf(str[i], sizeof(str[i]), \"NTOK_CHPID=%02x\",\n\t\t\t  token->chpid);\n\t\tenv[i] = str[i]; i++;\n\t\tscnprintf(str[i], sizeof(str[i]), \"NTOK_CHID=%04x\",\n\t\t\t  token->chid);\n\t\tenv[i] = str[i]; i++;\n\t\tbreak;\n\tcase anev_abort:\n\t\tscnprintf(str[i], sizeof(str[i]), \"BRIDGEDHOST=abort\");\n\t\tenv[i] = str[i]; i++;\n\t\tbreak;\n\tcase anev_reset:\n\t\tscnprintf(str[i], sizeof(str[i]), \"BRIDGEDHOST=reset\");\n\t\tenv[i] = str[i]; i++;\n\t\tbreak;\n\t}\n\tenv[i] = NULL;\n\tkobject_uevent_env(&card->gdev->dev.kobj, KOBJ_CHANGE, env);\n}\n\nstruct qeth_bridge_state_data {\n\tstruct work_struct worker;\n\tstruct qeth_card *card;\n\tu8 role;\n\tu8 state;\n};\n\nstatic void qeth_bridge_state_change_worker(struct work_struct *work)\n{\n\tstruct qeth_bridge_state_data *data =\n\t\tcontainer_of(work, struct qeth_bridge_state_data, worker);\n\tchar env_locrem[32];\n\tchar env_role[32];\n\tchar env_state[32];\n\tchar *env[] = {\n\t\tenv_locrem,\n\t\tenv_role,\n\t\tenv_state,\n\t\tNULL\n\t};\n\n\tscnprintf(env_locrem, sizeof(env_locrem), \"BRIDGEPORT=statechange\");\n\tscnprintf(env_role, sizeof(env_role), \"ROLE=%s\",\n\t\t  (data->role == QETH_SBP_ROLE_NONE) ? \"none\" :\n\t\t  (data->role == QETH_SBP_ROLE_PRIMARY) ? \"primary\" :\n\t\t  (data->role == QETH_SBP_ROLE_SECONDARY) ? \"secondary\" :\n\t\t  \"<INVALID>\");\n\tscnprintf(env_state, sizeof(env_state), \"STATE=%s\",\n\t\t  (data->state == QETH_SBP_STATE_INACTIVE) ? \"inactive\" :\n\t\t  (data->state == QETH_SBP_STATE_STANDBY) ? \"standby\" :\n\t\t  (data->state == QETH_SBP_STATE_ACTIVE) ? \"active\" :\n\t\t  \"<INVALID>\");\n\tkobject_uevent_env(&data->card->gdev->dev.kobj,\n\t\t\t\tKOBJ_CHANGE, env);\n\tkfree(data);\n}\n\nstatic void qeth_bridge_state_change(struct qeth_card *card,\n\t\t\t\t\tstruct qeth_ipa_cmd *cmd)\n{\n\tstruct qeth_sbp_port_data *qports = &cmd->data.sbp.data.port_data;\n\tstruct qeth_bridge_state_data *data;\n\n\tQETH_CARD_TEXT(card, 2, \"brstchng\");\n\tif (qports->num_entries == 0) {\n\t\tQETH_CARD_TEXT(card, 2, \"BPempty\");\n\t\treturn;\n\t}\n\tif (qports->entry_length != sizeof(struct qeth_sbp_port_entry)) {\n\t\tQETH_CARD_TEXT_(card, 2, \"BPsz%04x\", qports->entry_length);\n\t\treturn;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_ATOMIC);\n\tif (!data) {\n\t\tQETH_CARD_TEXT(card, 2, \"BPSalloc\");\n\t\treturn;\n\t}\n\tINIT_WORK(&data->worker, qeth_bridge_state_change_worker);\n\tdata->card = card;\n\t \n\tdata->role = qports->entry[0].role;\n\tdata->state = qports->entry[0].state;\n\n\tqueue_work(card->event_wq, &data->worker);\n}\n\nstruct qeth_addr_change_data {\n\tstruct delayed_work dwork;\n\tstruct qeth_card *card;\n\tstruct qeth_ipacmd_addr_change ac_event;\n};\n\nstatic void qeth_l2_dev2br_worker(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct qeth_addr_change_data *data;\n\tstruct qeth_card *card;\n\tstruct qeth_priv *priv;\n\tunsigned int i;\n\tint rc;\n\n\tdata = container_of(dwork, struct qeth_addr_change_data, dwork);\n\tcard = data->card;\n\tpriv = netdev_priv(card->dev);\n\n\tQETH_CARD_TEXT(card, 4, \"dev2brew\");\n\n\tif (READ_ONCE(card->info.pnso_mode) == QETH_PNSO_NONE)\n\t\tgoto free;\n\n\tif (data->ac_event.lost_event_mask) {\n\t\t \n\t\tif (!rtnl_trylock()) {\n\t\t\tqueue_delayed_work(card->event_wq, dwork,\n\t\t\t\t\t   msecs_to_jiffies(100));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!netif_device_present(card->dev)) {\n\t\t\trtnl_unlock();\n\t\t\tgoto free;\n\t\t}\n\n\t\tQETH_DBF_MESSAGE(3,\n\t\t\t\t \"Address change notification overflow on device %x\\n\",\n\t\t\t\t CARD_DEVID(card));\n\t\t \n\t\tqeth_l2_dev2br_fdb_flush(card);\n\t\trc = qeth_l2_dev2br_an_set(card, true);\n\t\tif (rc) {\n\t\t\t \n\t\t\tnetdev_err(card->dev,\n\t\t\t\t   \"bridge learning_sync failed to recover: %d\\n\",\n\t\t\t\t   rc);\n\t\t\tWRITE_ONCE(card->info.pnso_mode,\n\t\t\t\t   QETH_PNSO_NONE);\n\t\t\t \n\t\t\tqeth_l2_dev2br_fdb_flush(card);\n\t\t\tpriv->brport_features ^= BR_LEARNING_SYNC;\n\t\t} else {\n\t\t\tQETH_DBF_MESSAGE(3,\n\t\t\t\t\t \"Address Notification resynced on device %x\\n\",\n\t\t\t\t\t CARD_DEVID(card));\n\t\t}\n\n\t\trtnl_unlock();\n\t} else {\n\t\tfor (i = 0; i < data->ac_event.num_entries; i++) {\n\t\t\tstruct qeth_ipacmd_addr_change_entry *entry =\n\t\t\t\t\t&data->ac_event.entry[i];\n\t\t\tqeth_l2_dev2br_fdb_notify(card,\n\t\t\t\t\t\t  entry->change_code,\n\t\t\t\t\t\t  &entry->token,\n\t\t\t\t\t\t  &entry->addr_lnid);\n\t\t}\n\t}\n\nfree:\n\tkfree(data);\n}\n\nstatic void qeth_addr_change_event_worker(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct qeth_addr_change_data *data;\n\tstruct qeth_card *card;\n\tint i;\n\n\tdata = container_of(dwork, struct qeth_addr_change_data, dwork);\n\tcard = data->card;\n\n\tQETH_CARD_TEXT(data->card, 4, \"adrchgew\");\n\n\tif (READ_ONCE(card->info.pnso_mode) == QETH_PNSO_NONE)\n\t\tgoto free;\n\n\tif (data->ac_event.lost_event_mask) {\n\t\t \n\t\tif (!mutex_trylock(&card->sbp_lock)) {\n\t\t\tqueue_delayed_work(card->event_wq, dwork,\n\t\t\t\t\t   msecs_to_jiffies(100));\n\t\t\treturn;\n\t\t}\n\n\t\tdev_info(&data->card->gdev->dev,\n\t\t\t \"Address change notification stopped on %s (%s)\\n\",\n\t\t\t netdev_name(card->dev),\n\t\t\t(data->ac_event.lost_event_mask == 0x01)\n\t\t\t? \"Overflow\"\n\t\t\t: (data->ac_event.lost_event_mask == 0x02)\n\t\t\t? \"Bridge port state change\"\n\t\t\t: \"Unknown reason\");\n\n\t\tdata->card->options.sbp.hostnotification = 0;\n\t\tcard->info.pnso_mode = QETH_PNSO_NONE;\n\t\tmutex_unlock(&data->card->sbp_lock);\n\t\tqeth_bridge_emit_host_event(data->card, anev_abort,\n\t\t\t\t\t    0, NULL, NULL);\n\t} else\n\t\tfor (i = 0; i < data->ac_event.num_entries; i++) {\n\t\t\tstruct qeth_ipacmd_addr_change_entry *entry =\n\t\t\t\t\t&data->ac_event.entry[i];\n\t\t\tqeth_bridge_emit_host_event(data->card,\n\t\t\t\t\t\t    anev_reg_unreg,\n\t\t\t\t\t\t    entry->change_code,\n\t\t\t\t\t\t    &entry->token,\n\t\t\t\t\t\t    &entry->addr_lnid);\n\t\t}\n\nfree:\n\tkfree(data);\n}\n\nstatic void qeth_addr_change_event(struct qeth_card *card,\n\t\t\t\t   struct qeth_ipa_cmd *cmd)\n{\n\tstruct qeth_ipacmd_addr_change *hostevs =\n\t\t &cmd->data.addrchange;\n\tstruct qeth_addr_change_data *data;\n\tint extrasize;\n\n\tif (card->info.pnso_mode == QETH_PNSO_NONE)\n\t\treturn;\n\n\tQETH_CARD_TEXT(card, 4, \"adrchgev\");\n\tif (cmd->hdr.return_code != 0x0000) {\n\t\tif (cmd->hdr.return_code == 0x0010) {\n\t\t\tif (hostevs->lost_event_mask == 0x00)\n\t\t\t\thostevs->lost_event_mask = 0xff;\n\t\t} else {\n\t\t\tQETH_CARD_TEXT_(card, 2, \"ACHN%04x\",\n\t\t\t\tcmd->hdr.return_code);\n\t\t\treturn;\n\t\t}\n\t}\n\textrasize = sizeof(struct qeth_ipacmd_addr_change_entry) *\n\t\t\t\t\t\thostevs->num_entries;\n\tdata = kzalloc(sizeof(struct qeth_addr_change_data) + extrasize,\n\t\t       GFP_ATOMIC);\n\tif (!data) {\n\t\tQETH_CARD_TEXT(card, 2, \"ACNalloc\");\n\t\treturn;\n\t}\n\tif (card->info.pnso_mode == QETH_PNSO_BRIDGEPORT)\n\t\tINIT_DELAYED_WORK(&data->dwork, qeth_addr_change_event_worker);\n\telse\n\t\tINIT_DELAYED_WORK(&data->dwork, qeth_l2_dev2br_worker);\n\tdata->card = card;\n\tdata->ac_event = *hostevs;\n\tmemcpy(data->ac_event.entry, hostevs->entry, extrasize);\n\tqueue_delayed_work(card->event_wq, &data->dwork, 0);\n}\n\n \n\nstruct _qeth_sbp_cbctl {\n\tunion {\n\t\tu32 supported;\n\t\tstruct {\n\t\t\tenum qeth_sbp_roles *role;\n\t\t\tenum qeth_sbp_states *state;\n\t\t} qports;\n\t} data;\n};\n\nstatic int qeth_bridgeport_makerc(struct qeth_card *card,\n\t\t\t\t  struct qeth_ipa_cmd *cmd)\n{\n\tstruct qeth_ipacmd_setbridgeport *sbp = &cmd->data.sbp;\n\tenum qeth_ipa_sbp_cmd setcmd = sbp->hdr.command_code;\n\tu16 ipa_rc = cmd->hdr.return_code;\n\tu16 sbp_rc = sbp->hdr.return_code;\n\tint rc;\n\n\tif (ipa_rc == IPA_RC_SUCCESS && sbp_rc == IPA_RC_SUCCESS)\n\t\treturn 0;\n\n\tif ((IS_IQD(card) && ipa_rc == IPA_RC_SUCCESS) ||\n\t    (!IS_IQD(card) && ipa_rc == sbp_rc)) {\n\t\tswitch (sbp_rc) {\n\t\tcase IPA_RC_SUCCESS:\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\tcase IPA_RC_L2_UNSUPPORTED_CMD:\n\t\tcase IPA_RC_UNSUPPORTED_COMMAND:\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase IPA_RC_SBP_OSA_NOT_CONFIGURED:\n\t\tcase IPA_RC_SBP_IQD_NOT_CONFIGURED:\n\t\t\trc = -ENODEV;  \n\t\t\tdev_err(&card->gdev->dev,\n\t\"The device is not configured as a Bridge Port\\n\");\n\t\t\tbreak;\n\t\tcase IPA_RC_SBP_OSA_OS_MISMATCH:\n\t\tcase IPA_RC_SBP_IQD_OS_MISMATCH:\n\t\t\trc = -EPERM;\n\t\t\tdev_err(&card->gdev->dev,\n\t\"A Bridge Port is already configured by a different operating system\\n\");\n\t\t\tbreak;\n\t\tcase IPA_RC_SBP_OSA_ANO_DEV_PRIMARY:\n\t\tcase IPA_RC_SBP_IQD_ANO_DEV_PRIMARY:\n\t\t\tswitch (setcmd) {\n\t\t\tcase IPA_SBP_SET_PRIMARY_BRIDGE_PORT:\n\t\t\t\trc = -EEXIST;\n\t\t\t\tdev_err(&card->gdev->dev,\n\t\"The LAN already has a primary Bridge Port\\n\");\n\t\t\t\tbreak;\n\t\t\tcase IPA_SBP_SET_SECONDARY_BRIDGE_PORT:\n\t\t\t\trc = -EBUSY;\n\t\t\t\tdev_err(&card->gdev->dev,\n\t\"The device is already a primary Bridge Port\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trc = -EIO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPA_RC_SBP_OSA_CURRENT_SECOND:\n\t\tcase IPA_RC_SBP_IQD_CURRENT_SECOND:\n\t\t\trc = -EBUSY;\n\t\t\tdev_err(&card->gdev->dev,\n\t\"The device is already a secondary Bridge Port\\n\");\n\t\t\tbreak;\n\t\tcase IPA_RC_SBP_OSA_LIMIT_SECOND:\n\t\tcase IPA_RC_SBP_IQD_LIMIT_SECOND:\n\t\t\trc = -EEXIST;\n\t\t\tdev_err(&card->gdev->dev,\n\t\"The LAN cannot have more secondary Bridge Ports\\n\");\n\t\t\tbreak;\n\t\tcase IPA_RC_SBP_OSA_CURRENT_PRIMARY:\n\t\tcase IPA_RC_SBP_IQD_CURRENT_PRIMARY:\n\t\t\trc = -EBUSY;\n\t\t\tdev_err(&card->gdev->dev,\n\t\"The device is already a primary Bridge Port\\n\");\n\t\t\tbreak;\n\t\tcase IPA_RC_SBP_OSA_NOT_AUTHD_BY_ZMAN:\n\t\tcase IPA_RC_SBP_IQD_NOT_AUTHD_BY_ZMAN:\n\t\t\trc = -EACCES;\n\t\t\tdev_err(&card->gdev->dev,\n\t\"The device is not authorized to be a Bridge Port\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EIO;\n\t\t}\n\t} else {\n\t\tswitch (ipa_rc) {\n\t\tcase IPA_RC_NOTSUPP:\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\tcase IPA_RC_UNSUPPORTED_COMMAND:\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EIO;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tQETH_CARD_TEXT_(card, 2, \"SBPi%04x\", ipa_rc);\n\t\tQETH_CARD_TEXT_(card, 2, \"SBPc%04x\", sbp_rc);\n\t}\n\treturn rc;\n}\n\nstatic struct qeth_cmd_buffer *qeth_sbp_build_cmd(struct qeth_card *card,\n\t\t\t\t\t\t  enum qeth_ipa_sbp_cmd sbp_cmd,\n\t\t\t\t\t\t  unsigned int data_length)\n{\n\tenum qeth_ipa_cmds ipa_cmd = IS_IQD(card) ? IPA_CMD_SETBRIDGEPORT_IQD :\n\t\t\t\t\t\t    IPA_CMD_SETBRIDGEPORT_OSA;\n\tstruct qeth_ipacmd_sbp_hdr *hdr;\n\tstruct qeth_cmd_buffer *iob;\n\n\tiob = qeth_ipa_alloc_cmd(card, ipa_cmd, QETH_PROT_NONE,\n\t\t\t\t data_length +\n\t\t\t\t offsetof(struct qeth_ipacmd_setbridgeport,\n\t\t\t\t\t  data));\n\tif (!iob)\n\t\treturn iob;\n\n\thdr = &__ipa_cmd(iob)->data.sbp.hdr;\n\thdr->cmdlength = sizeof(*hdr) + data_length;\n\thdr->command_code = sbp_cmd;\n\thdr->used_total = 1;\n\thdr->seq_no = 1;\n\treturn iob;\n}\n\nstatic int qeth_bridgeport_query_support_cb(struct qeth_card *card,\n\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct _qeth_sbp_cbctl *cbctl = (struct _qeth_sbp_cbctl *)reply->param;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"brqsupcb\");\n\trc = qeth_bridgeport_makerc(card, cmd);\n\tif (rc)\n\t\treturn rc;\n\n\tcbctl->data.supported =\n\t\tcmd->data.sbp.data.query_cmds_supp.supported_cmds;\n\treturn 0;\n}\n\n \nstatic void qeth_bridgeport_query_support(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct _qeth_sbp_cbctl cbctl;\n\n\tQETH_CARD_TEXT(card, 2, \"brqsuppo\");\n\tiob = qeth_sbp_build_cmd(card, IPA_SBP_QUERY_COMMANDS_SUPPORTED,\n\t\t\t\t SBP_DATA_SIZEOF(query_cmds_supp));\n\tif (!iob)\n\t\treturn;\n\n\tif (qeth_send_ipa_cmd(card, iob, qeth_bridgeport_query_support_cb,\n\t\t\t      &cbctl)) {\n\t\tcard->options.sbp.role = QETH_SBP_ROLE_NONE;\n\t\tcard->options.sbp.supported_funcs = 0;\n\t\treturn;\n\t}\n\tcard->options.sbp.supported_funcs = cbctl.data.supported;\n}\n\nstatic int qeth_bridgeport_query_ports_cb(struct qeth_card *card,\n\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct _qeth_sbp_cbctl *cbctl = (struct _qeth_sbp_cbctl *)reply->param;\n\tstruct qeth_sbp_port_data *qports;\n\tint rc;\n\n\tQETH_CARD_TEXT(card, 2, \"brqprtcb\");\n\trc = qeth_bridgeport_makerc(card, cmd);\n\tif (rc)\n\t\treturn rc;\n\n\tqports = &cmd->data.sbp.data.port_data;\n\tif (qports->entry_length != sizeof(struct qeth_sbp_port_entry)) {\n\t\tQETH_CARD_TEXT_(card, 2, \"SBPs%04x\", qports->entry_length);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (qports->num_entries > 0) {\n\t\tif (cbctl->data.qports.role)\n\t\t\t*cbctl->data.qports.role = qports->entry[0].role;\n\t\tif (cbctl->data.qports.state)\n\t\t\t*cbctl->data.qports.state = qports->entry[0].state;\n\t}\n\treturn 0;\n}\n\n \nint qeth_bridgeport_query_ports(struct qeth_card *card,\n\tenum qeth_sbp_roles *role, enum qeth_sbp_states *state)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct _qeth_sbp_cbctl cbctl = {\n\t\t.data = {\n\t\t\t.qports = {\n\t\t\t\t.role = role,\n\t\t\t\t.state = state,\n\t\t\t},\n\t\t},\n\t};\n\n\tQETH_CARD_TEXT(card, 2, \"brqports\");\n\tif (!(card->options.sbp.supported_funcs & IPA_SBP_QUERY_BRIDGE_PORTS))\n\t\treturn -EOPNOTSUPP;\n\tiob = qeth_sbp_build_cmd(card, IPA_SBP_QUERY_BRIDGE_PORTS, 0);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\treturn qeth_send_ipa_cmd(card, iob, qeth_bridgeport_query_ports_cb,\n\t\t\t\t &cbctl);\n}\n\nstatic int qeth_bridgeport_set_cb(struct qeth_card *card,\n\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *)data;\n\n\tQETH_CARD_TEXT(card, 2, \"brsetrcb\");\n\treturn qeth_bridgeport_makerc(card, cmd);\n}\n\n \nint qeth_bridgeport_setrole(struct qeth_card *card, enum qeth_sbp_roles role)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tenum qeth_ipa_sbp_cmd setcmd;\n\tunsigned int cmdlength = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"brsetrol\");\n\tswitch (role) {\n\tcase QETH_SBP_ROLE_NONE:\n\t\tsetcmd = IPA_SBP_RESET_BRIDGE_PORT_ROLE;\n\t\tbreak;\n\tcase QETH_SBP_ROLE_PRIMARY:\n\t\tsetcmd = IPA_SBP_SET_PRIMARY_BRIDGE_PORT;\n\t\tcmdlength = SBP_DATA_SIZEOF(set_primary);\n\t\tbreak;\n\tcase QETH_SBP_ROLE_SECONDARY:\n\t\tsetcmd = IPA_SBP_SET_SECONDARY_BRIDGE_PORT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!(card->options.sbp.supported_funcs & setcmd))\n\t\treturn -EOPNOTSUPP;\n\tiob = qeth_sbp_build_cmd(card, setcmd, cmdlength);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\treturn qeth_send_ipa_cmd(card, iob, qeth_bridgeport_set_cb, NULL);\n}\n\nstatic void qeth_bridgeport_an_set_cb(void *priv,\n\t\t\t\t      struct chsc_pnso_naid_l2 *entry)\n{\n\tstruct qeth_card *card = (struct qeth_card *)priv;\n\tu8 code;\n\n\tcode = IPA_ADDR_CHANGE_CODE_MACADDR;\n\tif (entry->addr_lnid.lnid < VLAN_N_VID)\n\t\tcode |= IPA_ADDR_CHANGE_CODE_VLANID;\n\tqeth_bridge_emit_host_event(card, anev_reg_unreg, code,\n\t\t\t\t    (struct net_if_token *)&entry->nit,\n\t\t\t\t    (struct mac_addr_lnid *)&entry->addr_lnid);\n}\n\n \nint qeth_bridgeport_an_set(struct qeth_card *card, int enable)\n{\n\tint rc;\n\n\tif (!card->options.sbp.supported_funcs)\n\t\treturn -EOPNOTSUPP;\n\n\tif (enable) {\n\t\tqeth_bridge_emit_host_event(card, anev_reset, 0, NULL, NULL);\n\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_BRIDGEPORT);\n\t\trc = qeth_l2_pnso(card, PNSO_OC_NET_BRIDGE_INFO, 1,\n\t\t\t\t  qeth_bridgeport_an_set_cb, card);\n\t\tif (rc)\n\t\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);\n\t} else {\n\t\trc = qeth_l2_pnso(card, PNSO_OC_NET_BRIDGE_INFO, 0, NULL, NULL);\n\t\tqeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);\n\t}\n\treturn rc;\n}\n\n \n\n \nstatic int qeth_l2_vnicc_makerc(struct qeth_card *card, u16 ipa_rc)\n{\n\tint rc;\n\n\tswitch (ipa_rc) {\n\tcase IPA_RC_SUCCESS:\n\t\treturn ipa_rc;\n\tcase IPA_RC_L2_UNSUPPORTED_CMD:\n\tcase IPA_RC_NOTSUPP:\n\t\trc = -EOPNOTSUPP;\n\t\tbreak;\n\tcase IPA_RC_VNICC_OOSEQ:\n\t\trc = -EALREADY;\n\t\tbreak;\n\tcase IPA_RC_VNICC_VNICBP:\n\t\trc = -EBUSY;\n\t\tbreak;\n\tcase IPA_RC_L2_ADDR_TABLE_FULL:\n\t\trc = -ENOSPC;\n\t\tbreak;\n\tcase IPA_RC_L2_MAC_NOT_AUTH_BY_ADP:\n\t\trc = -EACCES;\n\t\tbreak;\n\tdefault:\n\t\trc = -EIO;\n\t}\n\n\tQETH_CARD_TEXT_(card, 2, \"err%04x\", ipa_rc);\n\treturn rc;\n}\n\n \nstatic int qeth_l2_vnicc_request_cb(struct qeth_card *card,\n\t\t\t\t    struct qeth_reply *reply,\n\t\t\t\t    unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\n\tstruct qeth_ipacmd_vnicc *rep = &cmd->data.vnicc;\n\tu32 sub_cmd = cmd->data.vnicc.hdr.sub_command;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccrcb\");\n\tif (cmd->hdr.return_code)\n\t\treturn qeth_l2_vnicc_makerc(card, cmd->hdr.return_code);\n\t \n\tcard->options.vnicc.sup_chars = rep->vnicc_cmds.supported;\n\tcard->options.vnicc.cur_chars = rep->vnicc_cmds.enabled;\n\n\tif (sub_cmd == IPA_VNICC_QUERY_CMDS)\n\t\t*(u32 *)reply->param = rep->data.query_cmds.sup_cmds;\n\telse if (sub_cmd == IPA_VNICC_GET_TIMEOUT)\n\t\t*(u32 *)reply->param = rep->data.getset_timeout.timeout;\n\n\treturn 0;\n}\n\nstatic struct qeth_cmd_buffer *qeth_l2_vnicc_build_cmd(struct qeth_card *card,\n\t\t\t\t\t\t       u32 vnicc_cmd,\n\t\t\t\t\t\t       unsigned int data_length)\n{\n\tstruct qeth_ipacmd_vnicc_hdr *hdr;\n\tstruct qeth_cmd_buffer *iob;\n\n\tiob = qeth_ipa_alloc_cmd(card, IPA_CMD_VNICC, QETH_PROT_NONE,\n\t\t\t\t data_length +\n\t\t\t\t offsetof(struct qeth_ipacmd_vnicc, data));\n\tif (!iob)\n\t\treturn NULL;\n\n\thdr = &__ipa_cmd(iob)->data.vnicc.hdr;\n\thdr->data_length = sizeof(*hdr) + data_length;\n\thdr->sub_command = vnicc_cmd;\n\treturn iob;\n}\n\n \nstatic int qeth_l2_vnicc_query_chars(struct qeth_card *card)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccqch\");\n\tiob = qeth_l2_vnicc_build_cmd(card, IPA_VNICC_QUERY_CHARS, 0);\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\treturn qeth_send_ipa_cmd(card, iob, qeth_l2_vnicc_request_cb, NULL);\n}\n\n \nstatic int qeth_l2_vnicc_query_cmds(struct qeth_card *card, u32 vnic_char,\n\t\t\t\t    u32 *sup_cmds)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccqcm\");\n\tiob = qeth_l2_vnicc_build_cmd(card, IPA_VNICC_QUERY_CMDS,\n\t\t\t\t      VNICC_DATA_SIZEOF(query_cmds));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\t__ipa_cmd(iob)->data.vnicc.data.query_cmds.vnic_char = vnic_char;\n\n\treturn qeth_send_ipa_cmd(card, iob, qeth_l2_vnicc_request_cb, sup_cmds);\n}\n\n \nstatic int qeth_l2_vnicc_set_char(struct qeth_card *card, u32 vnic_char,\n\t\t\t\t      u32 cmd)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccedc\");\n\tiob = qeth_l2_vnicc_build_cmd(card, cmd, VNICC_DATA_SIZEOF(set_char));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\t__ipa_cmd(iob)->data.vnicc.data.set_char.vnic_char = vnic_char;\n\n\treturn qeth_send_ipa_cmd(card, iob, qeth_l2_vnicc_request_cb, NULL);\n}\n\n \nstatic int qeth_l2_vnicc_getset_timeout(struct qeth_card *card, u32 vnicc,\n\t\t\t\t\tu32 cmd, u32 *timeout)\n{\n\tstruct qeth_vnicc_getset_timeout *getset_timeout;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccgst\");\n\tiob = qeth_l2_vnicc_build_cmd(card, cmd,\n\t\t\t\t      VNICC_DATA_SIZEOF(getset_timeout));\n\tif (!iob)\n\t\treturn -ENOMEM;\n\n\tgetset_timeout = &__ipa_cmd(iob)->data.vnicc.data.getset_timeout;\n\tgetset_timeout->vnic_char = vnicc;\n\n\tif (cmd == IPA_VNICC_SET_TIMEOUT)\n\t\tgetset_timeout->timeout = *timeout;\n\n\treturn qeth_send_ipa_cmd(card, iob, qeth_l2_vnicc_request_cb, timeout);\n}\n\n \nstatic bool qeth_l2_vnicc_recover_timeout(struct qeth_card *card, u32 vnicc,\n\t\t\t\t\t  u32 *timeout)\n{\n\tif (card->options.vnicc.sup_chars & vnicc &&\n\t    card->options.vnicc.getset_timeout_sup & vnicc &&\n\t    !qeth_l2_vnicc_getset_timeout(card, vnicc, IPA_VNICC_SET_TIMEOUT,\n\t\t\t\t\t  timeout))\n\t\treturn false;\n\t*timeout = QETH_VNICC_DEFAULT_TIMEOUT;\n\treturn true;\n}\n\n \nint qeth_l2_vnicc_set_state(struct qeth_card *card, u32 vnicc, bool state)\n{\n\tint rc = 0;\n\tu32 cmd;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccsch\");\n\n\t \n\tif (!(card->options.vnicc.sup_chars & vnicc) ||\n\t    !(card->options.vnicc.set_char_sup & vnicc))\n\t\treturn -EOPNOTSUPP;\n\n\tif (qeth_bridgeport_is_in_use(card))\n\t\treturn -EBUSY;\n\n\t \n\tif (state) {\n\t\tcmd = IPA_VNICC_ENABLE;\n\t\tcard->options.vnicc.wanted_chars |= vnicc;\n\t} else {\n\t\tcmd = IPA_VNICC_DISABLE;\n\t\tcard->options.vnicc.wanted_chars &= ~vnicc;\n\t}\n\n\t \n\tif (card->options.vnicc.cur_chars == card->options.vnicc.wanted_chars)\n\t\treturn rc;\n\n\t \n\tif (!qeth_card_hw_is_reachable(card)) {\n\t\tif (state)\n\t\t\tcard->options.vnicc.cur_chars |= vnicc;\n\t\telse\n\t\t\tcard->options.vnicc.cur_chars &= ~vnicc;\n\t\treturn rc;\n\t}\n\n\trc = qeth_l2_vnicc_set_char(card, vnicc, cmd);\n\tif (rc)\n\t\tcard->options.vnicc.wanted_chars =\n\t\t\tcard->options.vnicc.cur_chars;\n\telse {\n\t\t \n\t\tif (state && vnicc == QETH_VNICC_RX_BCAST)\n\t\t\tcard->options.vnicc.rx_bcast_enabled = true;\n\t\tif (!state && vnicc == QETH_VNICC_LEARNING)\n\t\t\tqeth_l2_vnicc_recover_timeout(card, vnicc,\n\t\t\t\t\t&card->options.vnicc.learning_timeout);\n\t}\n\n\treturn rc;\n}\n\n \nint qeth_l2_vnicc_get_state(struct qeth_card *card, u32 vnicc, bool *state)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccgch\");\n\n\t \n\tif (!(card->options.vnicc.sup_chars & vnicc))\n\t\treturn -EOPNOTSUPP;\n\n\tif (qeth_bridgeport_is_in_use(card))\n\t\treturn -EBUSY;\n\n\t \n\tif (qeth_card_hw_is_reachable(card))\n\t\trc = qeth_l2_vnicc_query_chars(card);\n\n\t*state = (card->options.vnicc.cur_chars & vnicc) ? true : false;\n\treturn rc;\n}\n\n \nint qeth_l2_vnicc_set_timeout(struct qeth_card *card, u32 timeout)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccsto\");\n\n\t \n\tif (!(card->options.vnicc.sup_chars & QETH_VNICC_LEARNING) ||\n\t    !(card->options.vnicc.getset_timeout_sup & QETH_VNICC_LEARNING))\n\t\treturn -EOPNOTSUPP;\n\n\tif (qeth_bridgeport_is_in_use(card))\n\t\treturn -EBUSY;\n\n\t \n\tif (card->options.vnicc.learning_timeout == timeout)\n\t\treturn rc;\n\n\t \n\tif (!qeth_card_hw_is_reachable(card)) {\n\t\tcard->options.vnicc.learning_timeout = timeout;\n\t\treturn rc;\n\t}\n\n\t \n\trc = qeth_l2_vnicc_getset_timeout(card, QETH_VNICC_LEARNING,\n\t\t\t\t\t  IPA_VNICC_SET_TIMEOUT, &timeout);\n\tif (!rc)\n\t\tcard->options.vnicc.learning_timeout = timeout;\n\n\treturn rc;\n}\n\n \nint qeth_l2_vnicc_get_timeout(struct qeth_card *card, u32 *timeout)\n{\n\tint rc = 0;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccgto\");\n\n\t \n\tif (!(card->options.vnicc.sup_chars & QETH_VNICC_LEARNING) ||\n\t    !(card->options.vnicc.getset_timeout_sup & QETH_VNICC_LEARNING))\n\t\treturn -EOPNOTSUPP;\n\n\tif (qeth_bridgeport_is_in_use(card))\n\t\treturn -EBUSY;\n\n\t \n\t*timeout = card->options.vnicc.learning_timeout;\n\tif (qeth_card_hw_is_reachable(card))\n\t\trc = qeth_l2_vnicc_getset_timeout(card, QETH_VNICC_LEARNING,\n\t\t\t\t\t\t  IPA_VNICC_GET_TIMEOUT,\n\t\t\t\t\t\t  timeout);\n\n\treturn rc;\n}\n\n \nstatic bool _qeth_l2_vnicc_is_in_use(struct qeth_card *card)\n{\n\tif (!card->options.vnicc.sup_chars)\n\t\treturn false;\n\t \n\tif (card->options.vnicc.cur_chars == QETH_VNICC_DEFAULT) {\n\t\tif (!card->options.vnicc.rx_bcast_enabled ||\n\t\t    !qeth_card_hw_is_reachable(card))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nbool qeth_bridgeport_allowed(struct qeth_card *card)\n{\n\tstruct qeth_priv *priv = netdev_priv(card->dev);\n\n\treturn (!_qeth_l2_vnicc_is_in_use(card) &&\n\t\t!(priv->brport_features & BR_LEARNING_SYNC));\n}\n\n \nstatic bool qeth_l2_vnicc_recover_char(struct qeth_card *card, u32 vnicc,\n\t\t\t\t       bool enable)\n{\n\tu32 cmd = enable ? IPA_VNICC_ENABLE : IPA_VNICC_DISABLE;\n\n\tif (card->options.vnicc.sup_chars & vnicc &&\n\t    card->options.vnicc.set_char_sup & vnicc &&\n\t    !qeth_l2_vnicc_set_char(card, vnicc, cmd))\n\t\treturn false;\n\tcard->options.vnicc.wanted_chars &= ~vnicc;\n\tcard->options.vnicc.wanted_chars |= QETH_VNICC_DEFAULT & vnicc;\n\treturn true;\n}\n\n \nstatic void qeth_l2_vnicc_init(struct qeth_card *card)\n{\n\tu32 *timeout = &card->options.vnicc.learning_timeout;\n\tbool enable, error = false;\n\tunsigned int chars_len, i;\n\tunsigned long chars_tmp;\n\tu32 sup_cmds, vnicc;\n\n\tQETH_CARD_TEXT(card, 2, \"vniccini\");\n\t \n\tcard->options.vnicc.rx_bcast_enabled = 0;\n\t \n\tif (qeth_l2_vnicc_query_chars(card)) {\n\t\tif (card->options.vnicc.wanted_chars != QETH_VNICC_DEFAULT ||\n\t\t    *timeout != QETH_VNICC_DEFAULT_TIMEOUT)\n\t\t\tdev_err(&card->gdev->dev, \"Configuring the VNIC characteristics failed\\n\");\n\t\t \n\t\tcard->options.vnicc.sup_chars = 0;\n\t\tcard->options.vnicc.cur_chars = 0;\n\t\tcard->options.vnicc.wanted_chars = QETH_VNICC_DEFAULT;\n\t\treturn;\n\t}\n\t \n\tchars_tmp = card->options.vnicc.sup_chars;\n\tchars_len = sizeof(card->options.vnicc.sup_chars) * BITS_PER_BYTE;\n\tfor_each_set_bit(i, &chars_tmp, chars_len) {\n\t\tvnicc = BIT(i);\n\t\tif (qeth_l2_vnicc_query_cmds(card, vnicc, &sup_cmds)) {\n\t\t\tsup_cmds = 0;\n\t\t\terror = true;\n\t\t}\n\t\tif ((sup_cmds & IPA_VNICC_SET_TIMEOUT) &&\n\t\t    (sup_cmds & IPA_VNICC_GET_TIMEOUT))\n\t\t\tcard->options.vnicc.getset_timeout_sup |= vnicc;\n\t\telse\n\t\t\tcard->options.vnicc.getset_timeout_sup &= ~vnicc;\n\t\tif ((sup_cmds & IPA_VNICC_ENABLE) &&\n\t\t    (sup_cmds & IPA_VNICC_DISABLE))\n\t\t\tcard->options.vnicc.set_char_sup |= vnicc;\n\t\telse\n\t\t\tcard->options.vnicc.set_char_sup &= ~vnicc;\n\t}\n\t \n\terror |= qeth_l2_vnicc_recover_timeout(card, QETH_VNICC_LEARNING,\n\t\t\t\t\t       timeout);\n\t \n\tchars_tmp = card->options.vnicc.wanted_chars ^\n\t\t    card->options.vnicc.cur_chars;\n\tchars_len = sizeof(card->options.vnicc.wanted_chars) * BITS_PER_BYTE;\n\tfor_each_set_bit(i, &chars_tmp, chars_len) {\n\t\tvnicc = BIT(i);\n\t\tenable = card->options.vnicc.wanted_chars & vnicc;\n\t\terror |= qeth_l2_vnicc_recover_char(card, vnicc, enable);\n\t}\n\tif (error)\n\t\tdev_err(&card->gdev->dev, \"Configuring the VNIC characteristics failed\\n\");\n}\n\n \nstatic void qeth_l2_vnicc_set_defaults(struct qeth_card *card)\n{\n\t \n\tcard->options.vnicc.sup_chars = QETH_VNICC_ALL;\n\tcard->options.vnicc.cur_chars = QETH_VNICC_DEFAULT;\n\tcard->options.vnicc.learning_timeout = QETH_VNICC_DEFAULT_TIMEOUT;\n\t \n\tcard->options.vnicc.set_char_sup = QETH_VNICC_ALL;\n\tcard->options.vnicc.getset_timeout_sup = QETH_VNICC_LEARNING;\n\t \n\tcard->options.vnicc.wanted_chars = QETH_VNICC_DEFAULT;\n}\n\nstatic const struct device_type qeth_l2_devtype = {\n\t.name = \"qeth_layer2\",\n\t.groups = qeth_l2_attr_groups,\n};\n\nstatic int qeth_l2_probe_device(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tint rc;\n\n\tqeth_l2_vnicc_set_defaults(card);\n\tmutex_init(&card->sbp_lock);\n\n\tif (gdev->dev.type) {\n\t\trc = device_add_groups(&gdev->dev, qeth_l2_attr_groups);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tgdev->dev.type = &qeth_l2_devtype;\n\t}\n\n\tINIT_WORK(&card->rx_mode_work, qeth_l2_rx_mode_work);\n\treturn 0;\n}\n\nstatic void qeth_l2_remove_device(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tstruct qeth_priv *priv;\n\n\tif (gdev->dev.type != &qeth_l2_devtype)\n\t\tdevice_remove_groups(&gdev->dev, qeth_l2_attr_groups);\n\n\tqeth_set_allowed_threads(card, 0, 1);\n\twait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);\n\n\tif (gdev->state == CCWGROUP_ONLINE)\n\t\tqeth_set_offline(card, card->discipline, false);\n\n\tif (card->dev->reg_state == NETREG_REGISTERED) {\n\t\tpriv = netdev_priv(card->dev);\n\t\tif (priv->brport_features & BR_LEARNING_SYNC) {\n\t\t\trtnl_lock();\n\t\t\tqeth_l2_br2dev_put();\n\t\t\trtnl_unlock();\n\t\t}\n\t\tunregister_netdev(card->dev);\n\t}\n}\n\nstatic int qeth_l2_set_online(struct qeth_card *card, bool carrier_ok)\n{\n\tstruct net_device *dev = card->dev;\n\tint rc = 0;\n\n\tqeth_l2_detect_dev2br_support(card);\n\n\tmutex_lock(&card->sbp_lock);\n\tqeth_bridgeport_query_support(card);\n\tif (card->options.sbp.supported_funcs) {\n\t\tqeth_l2_setup_bridgeport_attrs(card);\n\t\tdev_info(&card->gdev->dev,\n\t\t\t \"The device represents a Bridge Capable Port\\n\");\n\t}\n\tmutex_unlock(&card->sbp_lock);\n\n\tqeth_l2_register_dev_addr(card);\n\n\t \n\tqeth_l2_vnicc_init(card);\n\n\tqeth_l2_trace_features(card);\n\n\t \n\tQETH_CARD_TEXT(card, 2, \"softsetp\");\n\n\tcard->state = CARD_STATE_SOFTSETUP;\n\n\tqeth_set_allowed_threads(card, 0xffffffff, 0);\n\n\tif (dev->reg_state != NETREG_REGISTERED) {\n\t\trc = qeth_l2_setup_netdev(card);\n\t\tif (rc)\n\t\t\tgoto err_setup;\n\n\t\tif (carrier_ok)\n\t\t\tnetif_carrier_on(dev);\n\t} else {\n\t\trtnl_lock();\n\t\trc = qeth_set_real_num_tx_queues(card,\n\t\t\t\t\t\t qeth_tx_actual_queues(card));\n\t\tif (rc) {\n\t\t\trtnl_unlock();\n\t\t\tgoto err_set_queues;\n\t\t}\n\n\t\tif (carrier_ok)\n\t\t\tnetif_carrier_on(dev);\n\t\telse\n\t\t\tnetif_carrier_off(dev);\n\n\t\tnetif_device_attach(dev);\n\t\tqeth_enable_hw_features(dev);\n\t\tqeth_l2_enable_brport_features(card);\n\n\t\tif (netif_running(dev)) {\n\t\t\tlocal_bh_disable();\n\t\t\tnapi_schedule(&card->napi);\n\t\t\t \n\t\t\tlocal_bh_enable();\n\t\t\tqeth_l2_set_rx_mode(dev);\n\t\t}\n\t\trtnl_unlock();\n\t}\n\treturn 0;\n\nerr_set_queues:\nerr_setup:\n\tqeth_set_allowed_threads(card, 0, 1);\n\tcard->state = CARD_STATE_DOWN;\n\treturn rc;\n}\n\nstatic void qeth_l2_set_offline(struct qeth_card *card)\n{\n\tstruct qeth_priv *priv = netdev_priv(card->dev);\n\n\tqeth_set_allowed_threads(card, 0, 1);\n\tqeth_l2_drain_rx_mode_cache(card);\n\n\tif (card->state == CARD_STATE_SOFTSETUP)\n\t\tcard->state = CARD_STATE_DOWN;\n\n\tqeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);\n\tif (priv->brport_features & BR_LEARNING_SYNC)\n\t\tqeth_l2_dev2br_fdb_flush(card);\n}\n\n \nstatic int qeth_l2_control_event(struct qeth_card *card,\n\t\t\t\t struct qeth_ipa_cmd *cmd)\n{\n\tswitch (cmd->hdr.command) {\n\tcase IPA_CMD_SETBRIDGEPORT_OSA:\n\tcase IPA_CMD_SETBRIDGEPORT_IQD:\n\t\tif (cmd->data.sbp.hdr.command_code ==\n\t\t    IPA_SBP_BRIDGE_PORT_STATE_CHANGE) {\n\t\t\tqeth_bridge_state_change(card, cmd);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\tcase IPA_CMD_ADDRESS_CHANGE_NOTIF:\n\t\tqeth_addr_change_event(card, cmd);\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nconst struct qeth_discipline qeth_l2_discipline = {\n\t.setup = qeth_l2_probe_device,\n\t.remove = qeth_l2_remove_device,\n\t.set_online = qeth_l2_set_online,\n\t.set_offline = qeth_l2_set_offline,\n\t.control_event_handler = qeth_l2_control_event,\n};\nEXPORT_SYMBOL_GPL(qeth_l2_discipline);\n\nstatic int __init qeth_l2_init(void)\n{\n\tpr_info(\"register layer 2 discipline\\n\");\n\trefcount_set(&qeth_l2_switchdev_notify_refcnt, 0);\n\treturn 0;\n}\n\nstatic void __exit qeth_l2_exit(void)\n{\n\tpr_info(\"unregister layer 2 discipline\\n\");\n}\n\nmodule_init(qeth_l2_init);\nmodule_exit(qeth_l2_exit);\nMODULE_AUTHOR(\"Frank Blaschka <frank.blaschka@de.ibm.com>\");\nMODULE_DESCRIPTION(\"qeth layer 2 discipline\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}