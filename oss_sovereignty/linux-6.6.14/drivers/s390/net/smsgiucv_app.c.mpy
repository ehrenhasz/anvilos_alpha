{
  "module_name": "smsgiucv_app.c",
  "hash_id": "6a1c10b2c74a01f1f6a45e68c6e970ab86698888b2aef3f453418ab6e96a8508",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/smsgiucv_app.c",
  "human_readable_source": "\n \n#define KMSG_COMPONENT\t\t\"smsgiucv_app\"\n#define pr_fmt(fmt)\t\tKMSG_COMPONENT \": \" fmt\n\n#include <linux/ctype.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <net/iucv/iucv.h>\n#include \"smsgiucv.h\"\n\n \n#define SMSG_PREFIX\t\t\"APP\"\n\n \n#define ENV_SENDER_STR\t\t\"SMSG_SENDER=\"\n#define ENV_SENDER_LEN\t\t(strlen(ENV_SENDER_STR) + 8 + 1)\n#define ENV_PREFIX_STR\t\t\"SMSG_ID=\"\n#define ENV_PREFIX_LEN\t\t(strlen(ENV_PREFIX_STR) + \\\n\t\t\t\t strlen(SMSG_PREFIX) + 1)\n#define ENV_TEXT_STR\t\t\"SMSG_TEXT=\"\n#define ENV_TEXT_LEN(msg)\t(strlen(ENV_TEXT_STR) + strlen((msg)) + 1)\n\n \nstatic char *sender;\nmodule_param(sender, charp, 0400);\nMODULE_PARM_DESC(sender, \"z/VM user ID from which CP SMSGs are accepted\");\n\n \nstatic struct device *smsg_app_dev;\n\n \nstruct smsg_app_event {\n\tstruct list_head list;\n\tchar *buf;\n\tchar *envp[4];\n};\n\n \nstatic LIST_HEAD(smsg_event_queue);\nstatic DEFINE_SPINLOCK(smsg_event_queue_lock);\n\nstatic void smsg_app_event_free(struct smsg_app_event *ev)\n{\n\tkfree(ev->buf);\n\tkfree(ev);\n}\n\nstatic struct smsg_app_event *smsg_app_event_alloc(const char *from,\n\t\t\t\t\t\t   const char *msg)\n{\n\tstruct smsg_app_event *ev;\n\n\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\tif (!ev)\n\t\treturn NULL;\n\n\tev->buf = kzalloc(ENV_SENDER_LEN + ENV_PREFIX_LEN +\n\t\t\t  ENV_TEXT_LEN(msg), GFP_ATOMIC);\n\tif (!ev->buf) {\n\t\tkfree(ev);\n\t\treturn NULL;\n\t}\n\n\t \n\tev->envp[0] = ev->buf;\n\tev->envp[1] = ev->envp[0] + ENV_SENDER_LEN;\n\tev->envp[2] = ev->envp[1] + ENV_PREFIX_LEN;\n\tev->envp[3] = NULL;\n\n\t \n\tsnprintf(ev->envp[0], ENV_SENDER_LEN, ENV_SENDER_STR \"%s\", from);\n\tsnprintf(ev->envp[1], ENV_PREFIX_LEN, ENV_PREFIX_STR \"%s\", SMSG_PREFIX);\n\tsnprintf(ev->envp[2], ENV_TEXT_LEN(msg), ENV_TEXT_STR \"%s\", msg);\n\n\treturn ev;\n}\n\nstatic void smsg_event_work_fn(struct work_struct *work)\n{\n\tLIST_HEAD(event_queue);\n\tstruct smsg_app_event *p, *n;\n\tstruct device *dev;\n\n\tdev = get_device(smsg_app_dev);\n\tif (!dev)\n\t\treturn;\n\n\tspin_lock_bh(&smsg_event_queue_lock);\n\tlist_splice_init(&smsg_event_queue, &event_queue);\n\tspin_unlock_bh(&smsg_event_queue_lock);\n\n\tlist_for_each_entry_safe(p, n, &event_queue, list) {\n\t\tlist_del(&p->list);\n\t\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, p->envp);\n\t\tsmsg_app_event_free(p);\n\t}\n\n\tput_device(dev);\n}\nstatic DECLARE_WORK(smsg_event_work, smsg_event_work_fn);\n\nstatic void smsg_app_callback(const char *from, char *msg)\n{\n\tstruct smsg_app_event *se;\n\n\t \n\tif (sender && strlen(sender) > 0 && strcmp(from, sender) != 0)\n\t\treturn;\n\n\t \n\tmsg += strlen(SMSG_PREFIX);\n\twhile (*msg && isspace(*msg))\n\t\tmsg++;\n\tif (*msg == '\\0')\n\t\treturn;\n\n\t \n\tse = smsg_app_event_alloc(from, msg);\n\tif (!se)\n\t\treturn;\n\n\t \n\tspin_lock(&smsg_event_queue_lock);\n\tlist_add_tail(&se->list, &smsg_event_queue);\n\tspin_unlock(&smsg_event_queue_lock);\n\n\tschedule_work(&smsg_event_work);\n\treturn;\n}\n\nstatic int __init smsgiucv_app_init(void)\n{\n\tstruct device_driver *smsgiucv_drv;\n\tint rc;\n\n\tif (!MACHINE_IS_VM)\n\t\treturn -ENODEV;\n\n\tsmsg_app_dev = kzalloc(sizeof(*smsg_app_dev), GFP_KERNEL);\n\tif (!smsg_app_dev)\n\t\treturn -ENOMEM;\n\n\tsmsgiucv_drv = driver_find(SMSGIUCV_DRV_NAME, &iucv_bus);\n\tif (!smsgiucv_drv) {\n\t\tkfree(smsg_app_dev);\n\t\treturn -ENODEV;\n\t}\n\n\trc = dev_set_name(smsg_app_dev, KMSG_COMPONENT);\n\tif (rc) {\n\t\tkfree(smsg_app_dev);\n\t\tgoto fail;\n\t}\n\tsmsg_app_dev->bus = &iucv_bus;\n\tsmsg_app_dev->parent = iucv_root;\n\tsmsg_app_dev->release = (void (*)(struct device *)) kfree;\n\tsmsg_app_dev->driver = smsgiucv_drv;\n\trc = device_register(smsg_app_dev);\n\tif (rc) {\n\t\tput_device(smsg_app_dev);\n\t\tgoto fail;\n\t}\n\n\t \n\tif (sender) {\n\t\tint len = strlen(sender);\n\t\twhile (len--)\n\t\t\tsender[len] = toupper(sender[len]);\n\t}\n\n\t \n\trc = smsg_register_callback(SMSG_PREFIX, smsg_app_callback);\n\tif (rc) {\n\t\tdevice_unregister(smsg_app_dev);\n\t\tgoto fail;\n\t}\n\n\trc = 0;\nfail:\n\treturn rc;\n}\nmodule_init(smsgiucv_app_init);\n\nstatic void __exit smsgiucv_app_exit(void)\n{\n\t \n\tsmsg_unregister_callback(SMSG_PREFIX, smsg_app_callback);\n\n\t \n\tcancel_work_sync(&smsg_event_work);\n\tsmsg_event_work_fn(&smsg_event_work);\n\n\tdevice_unregister(smsg_app_dev);\n}\nmodule_exit(smsgiucv_app_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Deliver z/VM CP SMSG as uevents\");\nMODULE_AUTHOR(\"Hendrik Brueckner <brueckner@linux.vnet.ibm.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}