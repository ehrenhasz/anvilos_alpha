{
  "module_name": "smsgiucv.c",
  "hash_id": "d66fe6c188434ec81f18b66b8cb0a6771e6c17fc73dcc358d343778492ea8962",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/smsgiucv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <net/iucv/iucv.h>\n#include <asm/cpcmd.h>\n#include <asm/ebcdic.h>\n#include \"smsgiucv.h\"\n\nstruct smsg_callback {\n\tstruct list_head list;\n\tconst char *prefix;\n\tint len;\n\tvoid (*callback)(const char *from, char *str);\n};\n\nMODULE_AUTHOR\n   (\"(C) 2003 IBM Corporation by Martin Schwidefsky (schwidefsky@de.ibm.com)\");\nMODULE_DESCRIPTION (\"Linux for S/390 IUCV special message driver\");\n\nstatic struct iucv_path *smsg_path;\n\nstatic DEFINE_SPINLOCK(smsg_list_lock);\nstatic LIST_HEAD(smsg_list);\n\nstatic int smsg_path_pending(struct iucv_path *, u8 *, u8 *);\nstatic void smsg_message_pending(struct iucv_path *, struct iucv_message *);\n\nstatic struct iucv_handler smsg_handler = {\n\t.path_pending\t = smsg_path_pending,\n\t.message_pending = smsg_message_pending,\n};\n\nstatic int smsg_path_pending(struct iucv_path *path, u8 *ipvmid, u8 *ipuser)\n{\n\tif (strncmp(ipvmid, \"*MSG    \", 8) != 0)\n\t\treturn -EINVAL;\n\t \n\treturn iucv_path_accept(path, &smsg_handler, \"SMSGIUCV        \", NULL);\n}\n\nstatic void smsg_message_pending(struct iucv_path *path,\n\t\t\t\t struct iucv_message *msg)\n{\n\tstruct smsg_callback *cb;\n\tunsigned char *buffer;\n\tunsigned char sender[9];\n\tint rc, i;\n\n\tbuffer = kmalloc(msg->length + 1, GFP_ATOMIC | GFP_DMA);\n\tif (!buffer) {\n\t\tiucv_message_reject(path, msg);\n\t\treturn;\n\t}\n\trc = iucv_message_receive(path, msg, 0, buffer, msg->length, NULL);\n\tif (rc == 0) {\n\t\tbuffer[msg->length] = 0;\n\t\tEBCASC(buffer, msg->length);\n\t\tmemcpy(sender, buffer, 8);\n\t\tsender[8] = 0;\n\t\t \n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif (sender[i] != ' ' && sender[i] != '\\t')\n\t\t\t\tbreak;\n\t\t\tsender[i] = 0;\n\t\t}\n\t\tspin_lock(&smsg_list_lock);\n\t\tlist_for_each_entry(cb, &smsg_list, list)\n\t\t\tif (strncmp(buffer + 8, cb->prefix, cb->len) == 0) {\n\t\t\t\tcb->callback(sender, buffer + 8);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tspin_unlock(&smsg_list_lock);\n\t}\n\tkfree(buffer);\n}\n\nint smsg_register_callback(const char *prefix,\n\t\t\t   void (*callback)(const char *from, char *str))\n{\n\tstruct smsg_callback *cb;\n\n\tcb = kmalloc(sizeof(struct smsg_callback), GFP_KERNEL);\n\tif (!cb)\n\t\treturn -ENOMEM;\n\tcb->prefix = prefix;\n\tcb->len = strlen(prefix);\n\tcb->callback = callback;\n\tspin_lock_bh(&smsg_list_lock);\n\tlist_add_tail(&cb->list, &smsg_list);\n\tspin_unlock_bh(&smsg_list_lock);\n\treturn 0;\n}\n\nvoid smsg_unregister_callback(const char *prefix,\n\t\t\t      void (*callback)(const char *from,\n\t\t\t\t\t       char *str))\n{\n\tstruct smsg_callback *cb, *tmp;\n\n\tspin_lock_bh(&smsg_list_lock);\n\tcb = NULL;\n\tlist_for_each_entry(tmp, &smsg_list, list)\n\t\tif (tmp->callback == callback &&\n\t\t    strcmp(tmp->prefix, prefix) == 0) {\n\t\t\tcb = tmp;\n\t\t\tlist_del(&cb->list);\n\t\t\tbreak;\n\t\t}\n\tspin_unlock_bh(&smsg_list_lock);\n\tkfree(cb);\n}\n\nstatic struct device_driver smsg_driver = {\n\t.owner = THIS_MODULE,\n\t.name = SMSGIUCV_DRV_NAME,\n\t.bus  = &iucv_bus,\n};\n\nstatic void __exit smsg_exit(void)\n{\n\tcpcmd(\"SET SMSG OFF\", NULL, 0, NULL);\n\tiucv_unregister(&smsg_handler, 1);\n\tdriver_unregister(&smsg_driver);\n}\n\nstatic int __init smsg_init(void)\n{\n\tint rc;\n\n\tif (!MACHINE_IS_VM) {\n\t\trc = -EPROTONOSUPPORT;\n\t\tgoto out;\n\t}\n\trc = driver_register(&smsg_driver);\n\tif (rc != 0)\n\t\tgoto out;\n\trc = iucv_register(&smsg_handler, 1);\n\tif (rc)\n\t\tgoto out_driver;\n\tsmsg_path = iucv_path_alloc(255, 0, GFP_KERNEL);\n\tif (!smsg_path) {\n\t\trc = -ENOMEM;\n\t\tgoto out_register;\n\t}\n\trc = iucv_path_connect(smsg_path, &smsg_handler, \"*MSG    \",\n\t\t\t       NULL, NULL, NULL);\n\tif (rc)\n\t\tgoto out_free_path;\n\n\tcpcmd(\"SET SMSG IUCV\", NULL, 0, NULL);\n\treturn 0;\n\nout_free_path:\n\tiucv_path_free(smsg_path);\n\tsmsg_path = NULL;\nout_register:\n\tiucv_unregister(&smsg_handler, 1);\nout_driver:\n\tdriver_unregister(&smsg_driver);\nout:\n\treturn rc;\n}\n\nmodule_init(smsg_init);\nmodule_exit(smsg_exit);\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL(smsg_register_callback);\nEXPORT_SYMBOL(smsg_unregister_callback);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}