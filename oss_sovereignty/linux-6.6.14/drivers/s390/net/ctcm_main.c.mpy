{
  "module_name": "ctcm_main.c",
  "hash_id": "f2c4986022b9d37c20e6807c1f6fe8bb3416b3db812b3b40a25d37e750bffbeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/ctcm_main.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n#undef DEBUGDATA\n#undef DEBUGCCW\n\n#define KMSG_COMPONENT \"ctcm\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/bitops.h>\n\n#include <linux/signal.h>\n#include <linux/string.h>\n\n#include <linux/ip.h>\n#include <linux/if_arp.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n#include <net/dst.h>\n\n#include <linux/io.h>\n#include <asm/ccwdev.h>\n#include <asm/ccwgroup.h>\n#include <linux/uaccess.h>\n\n#include <asm/idals.h>\n\n#include \"ctcm_fsms.h\"\n#include \"ctcm_main.h\"\n\n \n\n \nstatic struct device *ctcm_root_dev;\n\n \nstruct channel *channels;\n\n \nvoid ctcm_unpack_skb(struct channel *ch, struct sk_buff *pskb)\n{\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\t__u16 len = *((__u16 *) pskb->data);\n\n\tskb_put(pskb, 2 + LL_HEADER_LENGTH);\n\tskb_pull(pskb, 2);\n\tpskb->dev = dev;\n\tpskb->ip_summed = CHECKSUM_UNNECESSARY;\n\twhile (len > 0) {\n\t\tstruct sk_buff *skb;\n\t\tint skblen;\n\t\tstruct ll_header *header = (struct ll_header *)pskb->data;\n\n\t\tskb_pull(pskb, LL_HEADER_LENGTH);\n\t\tif ((ch->protocol == CTCM_PROTO_S390) &&\n\t\t    (header->type != ETH_P_IP)) {\n\t\t\tif (!(ch->logflags & LOG_FLAG_ILLEGALPKT)) {\n\t\t\t\tch->logflags |= LOG_FLAG_ILLEGALPKT;\n\t\t\t\t \n\t\t\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\t\t\"%s(%s): Illegal packet type 0x%04x\"\n\t\t\t\t\t\" - dropping\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name, header->type);\n\t\t\t}\n\t\t\tpriv->stats.rx_dropped++;\n\t\t\tpriv->stats.rx_frame_errors++;\n\t\t\treturn;\n\t\t}\n\t\tpskb->protocol = cpu_to_be16(header->type);\n\t\tif ((header->length <= LL_HEADER_LENGTH) ||\n\t\t    (len <= LL_HEADER_LENGTH)) {\n\t\t\tif (!(ch->logflags & LOG_FLAG_ILLEGALSIZE)) {\n\t\t\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\t\t\"%s(%s): Illegal packet size %d(%d,%d)\"\n\t\t\t\t\t\"- dropping\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name,\n\t\t\t\t\theader->length, dev->mtu, len);\n\t\t\t\tch->logflags |= LOG_FLAG_ILLEGALSIZE;\n\t\t\t}\n\n\t\t\tpriv->stats.rx_dropped++;\n\t\t\tpriv->stats.rx_length_errors++;\n\t\t\treturn;\n\t\t}\n\t\theader->length -= LL_HEADER_LENGTH;\n\t\tlen -= LL_HEADER_LENGTH;\n\t\tif ((header->length > skb_tailroom(pskb)) ||\n\t\t    (header->length > len)) {\n\t\t\tif (!(ch->logflags & LOG_FLAG_OVERRUN)) {\n\t\t\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\t\t\"%s(%s): Packet size %d (overrun)\"\n\t\t\t\t\t\" - dropping\", CTCM_FUNTAIL,\n\t\t\t\t\t\tdev->name, header->length);\n\t\t\t\tch->logflags |= LOG_FLAG_OVERRUN;\n\t\t\t}\n\n\t\t\tpriv->stats.rx_dropped++;\n\t\t\tpriv->stats.rx_length_errors++;\n\t\t\treturn;\n\t\t}\n\t\tskb_put(pskb, header->length);\n\t\tskb_reset_mac_header(pskb);\n\t\tlen -= header->length;\n\t\tskb = dev_alloc_skb(pskb->len);\n\t\tif (!skb) {\n\t\t\tif (!(ch->logflags & LOG_FLAG_NOMEM)) {\n\t\t\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\t\t\"%s(%s): MEMORY allocation error\",\n\t\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\t\t\tch->logflags |= LOG_FLAG_NOMEM;\n\t\t\t}\n\t\t\tpriv->stats.rx_dropped++;\n\t\t\treturn;\n\t\t}\n\t\tskb_copy_from_linear_data(pskb, skb_put(skb, pskb->len),\n\t\t\t\t\t  pskb->len);\n\t\tskb_reset_mac_header(skb);\n\t\tskb->dev = pskb->dev;\n\t\tskb->protocol = pskb->protocol;\n\t\tpskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tskblen = skb->len;\n\t\t \n\t\tch->logflags = 0;\n\t\tpriv->stats.rx_packets++;\n\t\tpriv->stats.rx_bytes += skblen;\n\t\tnetif_rx(skb);\n\t\tif (len > 0) {\n\t\t\tskb_pull(pskb, header->length);\n\t\t\tif (skb_tailroom(pskb) < LL_HEADER_LENGTH) {\n\t\t\t\tCTCM_DBF_DEV_NAME(TRACE, dev,\n\t\t\t\t\t\"Overrun in ctcm_unpack_skb\");\n\t\t\t\tch->logflags |= LOG_FLAG_OVERRUN;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tskb_put(pskb, LL_HEADER_LENGTH);\n\t\t}\n\t}\n}\n\n \nstatic void channel_free(struct channel *ch)\n{\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO, \"%s(%s)\", CTCM_FUNTAIL, ch->id);\n\tch->flags &= ~CHANNEL_FLAGS_INUSE;\n\tfsm_newstate(ch->fsm, CTC_STATE_IDLE);\n}\n\n \nstatic void channel_remove(struct channel *ch)\n{\n\tstruct channel **c = &channels;\n\tchar chid[CTCM_ID_SIZE+1];\n\tint ok = 0;\n\n\tif (ch == NULL)\n\t\treturn;\n\telse\n\t\tstrncpy(chid, ch->id, CTCM_ID_SIZE);\n\n\tchannel_free(ch);\n\twhile (*c) {\n\t\tif (*c == ch) {\n\t\t\t*c = ch->next;\n\t\t\tfsm_deltimer(&ch->timer);\n\t\t\tif (IS_MPC(ch))\n\t\t\t\tfsm_deltimer(&ch->sweep_timer);\n\n\t\t\tkfree_fsm(ch->fsm);\n\t\t\tclear_normalized_cda(&ch->ccw[4]);\n\t\t\tif (ch->trans_skb != NULL) {\n\t\t\t\tclear_normalized_cda(&ch->ccw[1]);\n\t\t\t\tdev_kfree_skb_any(ch->trans_skb);\n\t\t\t}\n\t\t\tif (IS_MPC(ch)) {\n\t\t\t\ttasklet_kill(&ch->ch_tasklet);\n\t\t\t\ttasklet_kill(&ch->ch_disc_tasklet);\n\t\t\t\tkfree(ch->discontact_th);\n\t\t\t}\n\t\t\tkfree(ch->ccw);\n\t\t\tkfree(ch->irb);\n\t\t\tkfree(ch);\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tc = &((*c)->next);\n\t}\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO, \"%s(%s) %s\", CTCM_FUNTAIL,\n\t\t\tchid, ok ? \"OK\" : \"failed\");\n}\n\n \nstatic struct channel *channel_get(enum ctcm_channel_types type,\n\t\t\t\t\tchar *id, int direction)\n{\n\tstruct channel *ch = channels;\n\n\twhile (ch && (strncmp(ch->id, id, CTCM_ID_SIZE) || (ch->type != type)))\n\t\tch = ch->next;\n\tif (!ch) {\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%d, %s, %d) not found in channel list\\n\",\n\t\t\t\tCTCM_FUNTAIL, type, id, direction);\n\t} else {\n\t\tif (ch->flags & CHANNEL_FLAGS_INUSE)\n\t\t\tch = NULL;\n\t\telse {\n\t\t\tch->flags |= CHANNEL_FLAGS_INUSE;\n\t\t\tch->flags &= ~CHANNEL_FLAGS_RWMASK;\n\t\t\tch->flags |= (direction == CTCM_WRITE)\n\t\t\t    ? CHANNEL_FLAGS_WRITE : CHANNEL_FLAGS_READ;\n\t\t\tfsm_newstate(ch->fsm, CTC_STATE_STOPPED);\n\t\t}\n\t}\n\treturn ch;\n}\n\nstatic long ctcm_check_irb_error(struct ccw_device *cdev, struct irb *irb)\n{\n\tif (!IS_ERR(irb))\n\t\treturn 0;\n\n\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_WARN,\n\t\t\t\"irb error %ld on device %s\\n\",\n\t\t\t\tPTR_ERR(irb), dev_name(&cdev->dev));\n\n\tswitch (PTR_ERR(irb)) {\n\tcase -EIO:\n\t\tdev_err(&cdev->dev,\n\t\t\t\"An I/O-error occurred on the CTCM device\\n\");\n\t\tbreak;\n\tcase -ETIMEDOUT:\n\t\tdev_err(&cdev->dev,\n\t\t\t\"An adapter hardware operation timed out\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&cdev->dev,\n\t\t\t\"An error occurred on the adapter hardware\\n\");\n\t}\n\treturn PTR_ERR(irb);\n}\n\n\n \nstatic void ccw_unit_check(struct channel *ch, __u8 sense)\n{\n\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\n\t\t\t\"%s(%s): %02x\",\n\t\t\t\tCTCM_FUNTAIL, ch->id, sense);\n\n\tif (sense & SNS0_INTERVENTION_REQ) {\n\t\tif (sense & 0x01) {\n\t\t\tif (ch->sense_rc != 0x01) {\n\t\t\t\tpr_notice(\n\t\t\t\t\t\"%s: The communication peer has \"\n\t\t\t\t\t\"disconnected\\n\", ch->id);\n\t\t\t\tch->sense_rc = 0x01;\n\t\t\t}\n\t\t\tfsm_event(ch->fsm, CTC_EVENT_UC_RCRESET, ch);\n\t\t} else {\n\t\t\tif (ch->sense_rc != SNS0_INTERVENTION_REQ) {\n\t\t\t\tpr_notice(\n\t\t\t\t\t\"%s: The remote operating system is \"\n\t\t\t\t\t\"not available\\n\", ch->id);\n\t\t\t\tch->sense_rc = SNS0_INTERVENTION_REQ;\n\t\t\t}\n\t\t\tfsm_event(ch->fsm, CTC_EVENT_UC_RSRESET, ch);\n\t\t}\n\t} else if (sense & SNS0_EQUIPMENT_CHECK) {\n\t\tif (sense & SNS0_BUS_OUT_CHECK) {\n\t\t\tif (ch->sense_rc != SNS0_BUS_OUT_CHECK) {\n\t\t\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\n\t\t\t\t\t\"%s(%s): remote HW error %02x\",\n\t\t\t\t\t\tCTCM_FUNTAIL, ch->id, sense);\n\t\t\t\tch->sense_rc = SNS0_BUS_OUT_CHECK;\n\t\t\t}\n\t\t\tfsm_event(ch->fsm, CTC_EVENT_UC_HWFAIL, ch);\n\t\t} else {\n\t\t\tif (ch->sense_rc != SNS0_EQUIPMENT_CHECK) {\n\t\t\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\n\t\t\t\t\t\"%s(%s): remote read parity error %02x\",\n\t\t\t\t\t\tCTCM_FUNTAIL, ch->id, sense);\n\t\t\t\tch->sense_rc = SNS0_EQUIPMENT_CHECK;\n\t\t\t}\n\t\t\tfsm_event(ch->fsm, CTC_EVENT_UC_RXPARITY, ch);\n\t\t}\n\t} else if (sense & SNS0_BUS_OUT_CHECK) {\n\t\tif (ch->sense_rc != SNS0_BUS_OUT_CHECK) {\n\t\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\n\t\t\t\t\"%s(%s): BUS OUT error %02x\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id, sense);\n\t\t\tch->sense_rc = SNS0_BUS_OUT_CHECK;\n\t\t}\n\t\tif (sense & 0x04)\t \n\t\t\tfsm_event(ch->fsm, CTC_EVENT_UC_TXTIMEOUT, ch);\n\t\telse\t\t\t \n\t\t\tfsm_event(ch->fsm, CTC_EVENT_UC_TXPARITY, ch);\n\t} else if (sense & SNS0_CMD_REJECT) {\n\t\tif (ch->sense_rc != SNS0_CMD_REJECT) {\n\t\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\n\t\t\t\t\"%s(%s): Command rejected\",\n\t\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\t\tch->sense_rc = SNS0_CMD_REJECT;\n\t\t}\n\t} else if (sense == 0) {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\n\t\t\t\"%s(%s): Unit check ZERO\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id);\n\t\tfsm_event(ch->fsm, CTC_EVENT_UC_ZERO, ch);\n\t} else {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\n\t\t\t\"%s(%s): Unit check code %02x unknown\",\n\t\t\t\t\tCTCM_FUNTAIL, ch->id, sense);\n\t\tfsm_event(ch->fsm, CTC_EVENT_UC_UNKNOWN, ch);\n\t}\n}\n\nint ctcm_ch_alloc_buffer(struct channel *ch)\n{\n\tclear_normalized_cda(&ch->ccw[1]);\n\tch->trans_skb = __dev_alloc_skb(ch->max_bufsize, GFP_ATOMIC | GFP_DMA);\n\tif (ch->trans_skb == NULL) {\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): %s trans_skb allocation error\",\n\t\t\tCTCM_FUNTAIL, ch->id,\n\t\t\t(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ?\n\t\t\t\t\"RX\" : \"TX\");\n\t\treturn -ENOMEM;\n\t}\n\n\tch->ccw[1].count = ch->max_bufsize;\n\tif (set_normalized_cda(&ch->ccw[1], ch->trans_skb->data)) {\n\t\tdev_kfree_skb(ch->trans_skb);\n\t\tch->trans_skb = NULL;\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): %s set norm_cda failed\",\n\t\t\tCTCM_FUNTAIL, ch->id,\n\t\t\t(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ?\n\t\t\t\t\"RX\" : \"TX\");\n\t\treturn -ENOMEM;\n\t}\n\n\tch->ccw[1].count = 0;\n\tch->trans_skb_data = ch->trans_skb->data;\n\tch->flags &= ~CHANNEL_FLAGS_BUFSIZE_CHANGED;\n\treturn 0;\n}\n\n \n\n \nint ctcm_open(struct net_device *dev)\n{\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCMY_DBF_DEV_NAME(SETUP, dev, \"\");\n\tif (!IS_MPC(priv))\n\t\tfsm_event(priv->fsm,\tDEV_EVENT_START, dev);\n\treturn 0;\n}\n\n \nint ctcm_close(struct net_device *dev)\n{\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tCTCMY_DBF_DEV_NAME(SETUP, dev, \"\");\n\tif (!IS_MPC(priv))\n\t\tfsm_event(priv->fsm, DEV_EVENT_STOP, dev);\n\treturn 0;\n}\n\n\n \nstatic int ctcm_transmit_skb(struct channel *ch, struct sk_buff *skb)\n{\n\tunsigned long saveflags;\n\tstruct ll_header header;\n\tint rc = 0;\n\t__u16 block_len;\n\tint ccw_idx;\n\tstruct sk_buff *nskb;\n\tunsigned long hi;\n\n\t \n\tspin_lock_irqsave(&ch->collect_lock, saveflags);\n\tif (fsm_getstate(ch->fsm) != CTC_STATE_TXIDLE) {\n\t\tint l = skb->len + LL_HEADER_LENGTH;\n\n\t\tif (ch->collect_len + l > ch->max_bufsize - 2) {\n\t\t\tspin_unlock_irqrestore(&ch->collect_lock, saveflags);\n\t\t\treturn -EBUSY;\n\t\t} else {\n\t\t\trefcount_inc(&skb->users);\n\t\t\theader.length = l;\n\t\t\theader.type = be16_to_cpu(skb->protocol);\n\t\t\theader.unused = 0;\n\t\t\tmemcpy(skb_push(skb, LL_HEADER_LENGTH), &header,\n\t\t\t       LL_HEADER_LENGTH);\n\t\t\tskb_queue_tail(&ch->collect_queue, skb);\n\t\t\tch->collect_len += l;\n\t\t}\n\t\tspin_unlock_irqrestore(&ch->collect_lock, saveflags);\n\t\tgoto done;\n\t}\n\tspin_unlock_irqrestore(&ch->collect_lock, saveflags);\n\t \n\trefcount_inc(&skb->users);\n\tch->prof.txlen += skb->len;\n\theader.length = skb->len + LL_HEADER_LENGTH;\n\theader.type = be16_to_cpu(skb->protocol);\n\theader.unused = 0;\n\tmemcpy(skb_push(skb, LL_HEADER_LENGTH), &header, LL_HEADER_LENGTH);\n\tblock_len = skb->len + 2;\n\t*((__u16 *)skb_push(skb, 2)) = block_len;\n\n\t \n\thi = ((unsigned long)skb_tail_pointer(skb) + LL_HEADER_LENGTH) >> 31;\n\tif (hi) {\n\t\tnskb = alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);\n\t\tif (!nskb) {\n\t\t\trefcount_dec(&skb->users);\n\t\t\tskb_pull(skb, LL_HEADER_LENGTH + 2);\n\t\t\tctcm_clear_busy(ch->netdev);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tskb_put_data(nskb, skb->data, skb->len);\n\t\t\trefcount_inc(&nskb->users);\n\t\t\trefcount_dec(&skb->users);\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tskb = nskb;\n\t\t}\n\t}\n\n\tch->ccw[4].count = block_len;\n\tif (set_normalized_cda(&ch->ccw[4], skb->data)) {\n\t\t \n\t\tif (ctcm_checkalloc_buffer(ch)) {\n\t\t\t \n\t\t\trefcount_dec(&skb->users);\n\t\t\tskb_pull(skb, LL_HEADER_LENGTH + 2);\n\t\t\tctcm_clear_busy(ch->netdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_reset_tail_pointer(ch->trans_skb);\n\t\tch->trans_skb->len = 0;\n\t\tch->ccw[1].count = skb->len;\n\t\tskb_copy_from_linear_data(skb,\n\t\t\t\tskb_put(ch->trans_skb, skb->len), skb->len);\n\t\trefcount_dec(&skb->users);\n\t\tdev_kfree_skb_irq(skb);\n\t\tccw_idx = 0;\n\t} else {\n\t\tskb_queue_tail(&ch->io_queue, skb);\n\t\tccw_idx = 3;\n\t}\n\tif (do_debug_ccw)\n\t\tctcmpc_dumpit((char *)&ch->ccw[ccw_idx],\n\t\t\t\t\tsizeof(struct ccw1) * 3);\n\tch->retry = 0;\n\tfsm_newstate(ch->fsm, CTC_STATE_TX);\n\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\n\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\tch->prof.send_stamp = jiffies;\n\trc = ccw_device_start(ch->cdev, &ch->ccw[ccw_idx], 0, 0xff, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\n\tif (ccw_idx == 3)\n\t\tch->prof.doios_single++;\n\tif (rc != 0) {\n\t\tfsm_deltimer(&ch->timer);\n\t\tctcm_ccw_check_rc(ch, rc, \"single skb TX\");\n\t\tif (ccw_idx == 3)\n\t\t\tskb_dequeue_tail(&ch->io_queue);\n\t\t \n\t\tskb_pull(skb, LL_HEADER_LENGTH + 2);\n\t} else if (ccw_idx == 0) {\n\t\tstruct net_device *dev = ch->netdev;\n\t\tstruct ctcm_priv *priv = dev->ml_priv;\n\t\tpriv->stats.tx_packets++;\n\t\tpriv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;\n\t}\ndone:\n\tctcm_clear_busy(ch->netdev);\n\treturn rc;\n}\n\nstatic void ctcmpc_send_sweep_req(struct channel *rch)\n{\n\tstruct net_device *dev = rch->netdev;\n\tstruct ctcm_priv *priv;\n\tstruct mpc_group *grp;\n\tstruct th_sweep *header;\n\tstruct sk_buff *sweep_skb;\n\tstruct channel *ch;\n\t \n\n\tpriv = dev->ml_priv;\n\tgrp = priv->mpcg;\n\tch = priv->channel[CTCM_WRITE];\n\n\t \n\t \n\tif (grp->in_sweep == 0) {\n\t\tgrp->in_sweep = 1;\n\t\tgrp->sweep_rsp_pend_num = grp->active_channels[CTCM_READ];\n\t\tgrp->sweep_req_pend_num = grp->active_channels[CTCM_READ];\n\t}\n\n\tsweep_skb = __dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC|GFP_DMA);\n\n\tif (sweep_skb == NULL)\t{\n\t\t \n\t\t\t\tgoto nomem;\n\t}\n\n\theader = skb_put_zero(sweep_skb, TH_SWEEP_LENGTH);\n\theader->th.th_ch_flag\t= TH_SWEEP_REQ;   \n\theader->sw.th_last_seq\t= ch->th_seq_num;\n\n\tnetif_trans_update(dev);\n\tskb_queue_tail(&ch->sweep_queue, sweep_skb);\n\n\tfsm_addtimer(&ch->sweep_timer, 100, CTC_EVENT_RSWEEP_TIMER, ch);\n\n\treturn;\n\nnomem:\n\tgrp->in_sweep = 0;\n\tctcm_clear_busy(dev);\n\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\n\treturn;\n}\n\n \nstatic int ctcmpc_transmit_skb(struct channel *ch, struct sk_buff *skb)\n{\n\tstruct pdu *p_header;\n\tstruct net_device *dev = ch->netdev;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct mpc_group *grp = priv->mpcg;\n\tstruct th_header *header;\n\tstruct sk_buff *nskb;\n\tint rc = 0;\n\tint ccw_idx;\n\tunsigned long hi;\n\tunsigned long saveflags = 0;\t \n\n\tCTCM_PR_DEBUG(\"Enter %s: %s, cp=%i ch=0x%p id=%s state=%s\\n\",\n\t\t\t__func__, dev->name, smp_processor_id(), ch,\n\t\t\t\t\tch->id, fsm_getstate_str(ch->fsm));\n\n\tif ((fsm_getstate(ch->fsm) != CTC_STATE_TXIDLE) || grp->in_sweep) {\n\t\tspin_lock_irqsave(&ch->collect_lock, saveflags);\n\t\trefcount_inc(&skb->users);\n\n\t\tp_header = skb_push(skb, PDU_HEADER_LENGTH);\n\t\tp_header->pdu_offset = skb->len - PDU_HEADER_LENGTH;\n\t\tp_header->pdu_proto = 0x01;\n\t\tif (be16_to_cpu(skb->protocol) == ETH_P_SNAP) {\n\t\t\tp_header->pdu_flag = PDU_FIRST | PDU_CNTL;\n\t\t} else {\n\t\t\tp_header->pdu_flag = PDU_FIRST;\n\t\t}\n\t\tp_header->pdu_seq = 0;\n\n\t\tCTCM_PR_DEBUG(\"%s(%s): Put on collect_q - skb len: %04x \\n\"\n\t\t\t\t\"pdu header and data for up to 32 bytes:\\n\",\n\t\t\t\t__func__, dev->name, skb->len);\n\t\tCTCM_D3_DUMP((char *)skb->data, min_t(int, 32, skb->len));\n\n\t\tskb_queue_tail(&ch->collect_queue, skb);\n\t\tch->collect_len += skb->len;\n\n\t\tspin_unlock_irqrestore(&ch->collect_lock, saveflags);\n\t\tgoto done;\n\t}\n\n\t \n\trefcount_inc(&skb->users);\n\n\t \n\thi = ((unsigned long)skb->tail + TH_HEADER_LENGTH) >> 31;\n\tif (hi) {\n\t\tnskb = __dev_alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);\n\t\tif (!nskb) {\n\t\t\tgoto nomem_exit;\n\t\t} else {\n\t\t\tskb_put_data(nskb, skb->data, skb->len);\n\t\t\trefcount_inc(&nskb->users);\n\t\t\trefcount_dec(&skb->users);\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tskb = nskb;\n\t\t}\n\t}\n\n\tp_header = skb_push(skb, PDU_HEADER_LENGTH);\n\tp_header->pdu_offset = skb->len - PDU_HEADER_LENGTH;\n\tp_header->pdu_proto = 0x01;\n\tp_header->pdu_seq = 0;\n\tif (be16_to_cpu(skb->protocol) == ETH_P_SNAP) {\n\t\tp_header->pdu_flag = PDU_FIRST | PDU_CNTL;\n\t} else {\n\t\tp_header->pdu_flag = PDU_FIRST;\n\t}\n\n\tif (ch->collect_len > 0) {\n\t\tspin_lock_irqsave(&ch->collect_lock, saveflags);\n\t\tskb_queue_tail(&ch->collect_queue, skb);\n\t\tch->collect_len += skb->len;\n\t\tskb = skb_dequeue(&ch->collect_queue);\n\t\tch->collect_len -= skb->len;\n\t\tspin_unlock_irqrestore(&ch->collect_lock, saveflags);\n\t}\n\n\tp_header = (struct pdu *)skb->data;\n\tp_header->pdu_flag |= PDU_LAST;\n\n\tch->prof.txlen += skb->len - PDU_HEADER_LENGTH;\n\n\t \n\theader = skb_push(skb, TH_HEADER_LENGTH);\n\tmemset(header, 0, TH_HEADER_LENGTH);\n\n\theader->th_ch_flag = TH_HAS_PDU;   \n\tch->th_seq_num++;\n\theader->th_seq_num = ch->th_seq_num;\n\n\tCTCM_PR_DBGDATA(\"%s(%s) ToVTAM_th_seq= %08x\\n\" ,\n\t\t       __func__, dev->name, ch->th_seq_num);\n\n\tCTCM_PR_DBGDATA(\"%s(%s): skb len: %04x\\n - pdu header and data for \"\n\t\t\t\"up to 32 bytes sent to vtam:\\n\",\n\t\t\t\t__func__, dev->name, skb->len);\n\tCTCM_D3_DUMP((char *)skb->data, min_t(int, 32, skb->len));\n\n\tch->ccw[4].count = skb->len;\n\tif (set_normalized_cda(&ch->ccw[4], skb->data)) {\n\t\t \n\t\tif (ctcm_checkalloc_buffer(ch)) {\n\t\t\t \n\t\t\t\tgoto nomem_exit;\n\t\t}\n\n\t\tskb_reset_tail_pointer(ch->trans_skb);\n\t\tch->trans_skb->len = 0;\n\t\tch->ccw[1].count = skb->len;\n\t\tskb_put_data(ch->trans_skb, skb->data, skb->len);\n\t\trefcount_dec(&skb->users);\n\t\tdev_kfree_skb_irq(skb);\n\t\tccw_idx = 0;\n\t\tCTCM_PR_DBGDATA(\"%s(%s): trans_skb len: %04x\\n\"\n\t\t\t\t\"up to 32 bytes sent to vtam:\\n\",\n\t\t\t\t__func__, dev->name, ch->trans_skb->len);\n\t\tCTCM_D3_DUMP((char *)ch->trans_skb->data,\n\t\t\t\tmin_t(int, 32, ch->trans_skb->len));\n\t} else {\n\t\tskb_queue_tail(&ch->io_queue, skb);\n\t\tccw_idx = 3;\n\t}\n\tch->retry = 0;\n\tfsm_newstate(ch->fsm, CTC_STATE_TX);\n\tfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\n\n\tif (do_debug_ccw)\n\t\tctcmpc_dumpit((char *)&ch->ccw[ccw_idx],\n\t\t\t\t\tsizeof(struct ccw1) * 3);\n\n\tspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\n\tch->prof.send_stamp = jiffies;\n\trc = ccw_device_start(ch->cdev, &ch->ccw[ccw_idx], 0, 0xff, 0);\n\tspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\n\tif (ccw_idx == 3)\n\t\tch->prof.doios_single++;\n\tif (rc != 0) {\n\t\tfsm_deltimer(&ch->timer);\n\t\tctcm_ccw_check_rc(ch, rc, \"single skb TX\");\n\t\tif (ccw_idx == 3)\n\t\t\tskb_dequeue_tail(&ch->io_queue);\n\t} else if (ccw_idx == 0) {\n\t\tpriv->stats.tx_packets++;\n\t\tpriv->stats.tx_bytes += skb->len - TH_HEADER_LENGTH;\n\t}\n\tif (ch->th_seq_num > 0xf0000000)\t \n\t\tctcmpc_send_sweep_req(ch);\n\n\tgoto done;\nnomem_exit:\n\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_CRIT,\n\t\t\t\"%s(%s): MEMORY allocation ERROR\\n\",\n\t\t\tCTCM_FUNTAIL, ch->id);\n\trc = -ENOMEM;\n\trefcount_dec(&skb->users);\n\tdev_kfree_skb_any(skb);\n\tfsm_event(priv->mpcg->fsm, MPCG_EVENT_INOP, dev);\ndone:\n\tCTCM_PR_DEBUG(\"Exit %s(%s)\\n\", __func__, dev->name);\n\treturn rc;\n}\n\n \n \nstatic netdev_tx_t ctcm_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\n\tif (skb == NULL) {\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\t\"%s(%s): NULL sk_buff passed\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\tpriv->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (skb_headroom(skb) < (LL_HEADER_LENGTH + 2)) {\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): Got sk_buff with head room < %ld bytes\",\n\t\t\tCTCM_FUNTAIL, dev->name, LL_HEADER_LENGTH + 2);\n\t\tdev_kfree_skb(skb);\n\t\tpriv->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tif (fsm_getstate(priv->fsm) != DEV_STATE_RUNNING) {\n\t\tfsm_event(priv->fsm, DEV_EVENT_START, dev);\n\t\tdev_kfree_skb(skb);\n\t\tpriv->stats.tx_dropped++;\n\t\tpriv->stats.tx_errors++;\n\t\tpriv->stats.tx_carrier_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (ctcm_test_and_set_busy(dev))\n\t\treturn NETDEV_TX_BUSY;\n\n\tnetif_trans_update(dev);\n\tif (ctcm_transmit_skb(priv->channel[CTCM_WRITE], skb) != 0)\n\t\treturn NETDEV_TX_BUSY;\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic netdev_tx_t ctcmpc_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tint len = 0;\n\tstruct ctcm_priv *priv = dev->ml_priv;\n\tstruct mpc_group *grp  = priv->mpcg;\n\tstruct sk_buff *newskb = NULL;\n\n\t \n\tif (skb == NULL) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): NULL sk_buff passed\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\tpriv->stats.tx_dropped++;\n\t\tgoto done;\n\t}\n\tif (skb_headroom(skb) < (TH_HEADER_LENGTH + PDU_HEADER_LENGTH)) {\n\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): Got sk_buff with head room < %ld bytes\",\n\t\t\tCTCM_FUNTAIL, dev->name,\n\t\t\t\tTH_HEADER_LENGTH + PDU_HEADER_LENGTH);\n\n\t\tCTCM_D3_DUMP((char *)skb->data, min_t(int, 32, skb->len));\n\n\t\tlen =  skb->len + TH_HEADER_LENGTH + PDU_HEADER_LENGTH;\n\t\tnewskb = __dev_alloc_skb(len, GFP_ATOMIC | GFP_DMA);\n\n\t\tif (!newskb) {\n\t\t\tCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ERROR,\n\t\t\t\t\"%s: %s: __dev_alloc_skb failed\",\n\t\t\t\t\t\t__func__, dev->name);\n\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tpriv->stats.tx_dropped++;\n\t\t\tpriv->stats.tx_errors++;\n\t\t\tpriv->stats.tx_carrier_errors++;\n\t\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\t\tgoto done;\n\t\t}\n\t\tnewskb->protocol = skb->protocol;\n\t\tskb_reserve(newskb, TH_HEADER_LENGTH + PDU_HEADER_LENGTH);\n\t\tskb_put_data(newskb, skb->data, skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = newskb;\n\t}\n\n\t \n\tif ((fsm_getstate(priv->fsm) != DEV_STATE_RUNNING) ||\n\t   (fsm_getstate(grp->fsm) <  MPCG_STATE_XID2INITW)) {\n\t\tdev_kfree_skb_any(skb);\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): inactive MPCGROUP - dropped\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\tpriv->stats.tx_dropped++;\n\t\tpriv->stats.tx_errors++;\n\t\tpriv->stats.tx_carrier_errors++;\n\t\tgoto done;\n\t}\n\n\tif (ctcm_test_and_set_busy(dev)) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): device busy - dropped\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\tpriv->stats.tx_dropped++;\n\t\tpriv->stats.tx_errors++;\n\t\tpriv->stats.tx_carrier_errors++;\n\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\tgoto done;\n\t}\n\n\tnetif_trans_update(dev);\n\tif (ctcmpc_transmit_skb(priv->channel[CTCM_WRITE], skb) != 0) {\n\t\tCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s(%s): device error - dropped\",\n\t\t\t\t\tCTCM_FUNTAIL, dev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\tpriv->stats.tx_dropped++;\n\t\tpriv->stats.tx_errors++;\n\t\tpriv->stats.tx_carrier_errors++;\n\t\tctcm_clear_busy(dev);\n\t\tfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\n\t\tgoto done;\n\t}\n\tctcm_clear_busy(dev);\ndone:\n\tif (do_debug)\n\t\tMPC_DBF_DEV_NAME(TRACE, dev, \"exit\");\n\n\treturn NETDEV_TX_OK;\t \n}\n\n\n \nstatic int ctcm_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ctcm_priv *priv;\n\tint max_bufsize;\n\n\tpriv = dev->ml_priv;\n\tmax_bufsize = priv->channel[CTCM_READ]->max_bufsize;\n\n\tif (IS_MPC(priv)) {\n\t\tif (new_mtu > max_bufsize - TH_HEADER_LENGTH)\n\t\t\treturn -EINVAL;\n\t\tdev->hard_header_len = TH_HEADER_LENGTH + PDU_HEADER_LENGTH;\n\t} else {\n\t\tif (new_mtu > max_bufsize - LL_HEADER_LENGTH - 2)\n\t\t\treturn -EINVAL;\n\t\tdev->hard_header_len = LL_HEADER_LENGTH + 2;\n\t}\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n \nstatic struct net_device_stats *ctcm_stats(struct net_device *dev)\n{\n\treturn &((struct ctcm_priv *)dev->ml_priv)->stats;\n}\n\nstatic void ctcm_free_netdevice(struct net_device *dev)\n{\n\tstruct ctcm_priv *priv;\n\tstruct mpc_group *grp;\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\n\t\t\t\"%s(%s)\", CTCM_FUNTAIL, dev->name);\n\tpriv = dev->ml_priv;\n\tif (priv) {\n\t\tgrp = priv->mpcg;\n\t\tif (grp) {\n\t\t\tif (grp->fsm)\n\t\t\t\tkfree_fsm(grp->fsm);\n\t\t\tdev_kfree_skb(grp->xid_skb);\n\t\t\tdev_kfree_skb(grp->rcvd_xid_skb);\n\t\t\ttasklet_kill(&grp->mpc_tasklet2);\n\t\t\tkfree(grp);\n\t\t\tpriv->mpcg = NULL;\n\t\t}\n\t\tif (priv->fsm) {\n\t\t\tkfree_fsm(priv->fsm);\n\t\t\tpriv->fsm = NULL;\n\t\t}\n\t\tkfree(priv->xid);\n\t\tpriv->xid = NULL;\n\t \n\t}\n#ifdef MODULE\n\tfree_netdev(dev);\n#endif\n}\n\nstruct mpc_group *ctcmpc_init_mpc_group(struct ctcm_priv *priv);\n\nstatic const struct net_device_ops ctcm_netdev_ops = {\n\t.ndo_open\t\t= ctcm_open,\n\t.ndo_stop\t\t= ctcm_close,\n\t.ndo_get_stats\t\t= ctcm_stats,\n\t.ndo_change_mtu\t   \t= ctcm_change_mtu,\n\t.ndo_start_xmit\t\t= ctcm_tx,\n};\n\nstatic const struct net_device_ops ctcm_mpc_netdev_ops = {\n\t.ndo_open\t\t= ctcm_open,\n\t.ndo_stop\t\t= ctcm_close,\n\t.ndo_get_stats\t\t= ctcm_stats,\n\t.ndo_change_mtu\t   \t= ctcm_change_mtu,\n\t.ndo_start_xmit\t\t= ctcmpc_tx,\n};\n\nstatic void ctcm_dev_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_SLIP;\n\tdev->tx_queue_len = 100;\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP;\n\tdev->min_mtu = 576;\n\tdev->max_mtu = 65527;\n}\n\n \nstatic struct net_device *ctcm_init_netdevice(struct ctcm_priv *priv)\n{\n\tstruct net_device *dev;\n\tstruct mpc_group *grp;\n\tif (!priv)\n\t\treturn NULL;\n\n\tif (IS_MPC(priv))\n\t\tdev = alloc_netdev(0, MPC_DEVICE_GENE, NET_NAME_UNKNOWN,\n\t\t\t\t   ctcm_dev_setup);\n\telse\n\t\tdev = alloc_netdev(0, CTC_DEVICE_GENE, NET_NAME_UNKNOWN,\n\t\t\t\t   ctcm_dev_setup);\n\n\tif (!dev) {\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_CRIT,\n\t\t\t\"%s: MEMORY allocation ERROR\",\n\t\t\tCTCM_FUNTAIL);\n\t\treturn NULL;\n\t}\n\tdev->ml_priv = priv;\n\tpriv->fsm = init_fsm(\"ctcmdev\", dev_state_names, dev_event_names,\n\t\t\t\tCTCM_NR_DEV_STATES, CTCM_NR_DEV_EVENTS,\n\t\t\t\tdev_fsm, dev_fsm_len, GFP_KERNEL);\n\tif (priv->fsm == NULL) {\n\t\tCTCMY_DBF_DEV(SETUP, dev, \"init_fsm error\");\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\tfsm_newstate(priv->fsm, DEV_STATE_STOPPED);\n\tfsm_settimer(priv->fsm, &priv->restart_timer);\n\n\tif (IS_MPC(priv)) {\n\t\t \n\t\tgrp = ctcmpc_init_mpc_group(priv);\n\t\tif (grp == NULL) {\n\t\t\tMPC_DBF_DEV(SETUP, dev, \"init_mpc_group error\");\n\t\t\tfree_netdev(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\ttasklet_init(&grp->mpc_tasklet2,\n\t\t\t\tmpc_group_ready, (unsigned long)dev);\n\t\tdev->mtu = MPC_BUFSIZE_DEFAULT -\n\t\t\t\tTH_HEADER_LENGTH - PDU_HEADER_LENGTH;\n\n\t\tdev->netdev_ops = &ctcm_mpc_netdev_ops;\n\t\tdev->hard_header_len = TH_HEADER_LENGTH + PDU_HEADER_LENGTH;\n\t\tpriv->buffer_size = MPC_BUFSIZE_DEFAULT;\n\t} else {\n\t\tdev->mtu = CTCM_BUFSIZE_DEFAULT - LL_HEADER_LENGTH - 2;\n\t\tdev->netdev_ops = &ctcm_netdev_ops;\n\t\tdev->hard_header_len = LL_HEADER_LENGTH + 2;\n\t}\n\n\tCTCMY_DBF_DEV(SETUP, dev, \"finished\");\n\n\treturn dev;\n}\n\n \nstatic void ctcm_irq_handler(struct ccw_device *cdev,\n\t\t\t\tunsigned long intparm, struct irb *irb)\n{\n\tstruct channel\t\t*ch;\n\tstruct net_device\t*dev;\n\tstruct ctcm_priv\t*priv;\n\tstruct ccwgroup_device\t*cgdev;\n\tint cstat;\n\tint dstat;\n\n\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\n\t\t\"Enter %s(%s)\", CTCM_FUNTAIL, dev_name(&cdev->dev));\n\n\tif (ctcm_check_irb_error(cdev, irb))\n\t\treturn;\n\n\tcgdev = dev_get_drvdata(&cdev->dev);\n\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\n\t \n\tif (cgdev == NULL) {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_ERROR,\n\t\t\t\"%s(%s) unsolicited irq: c-%02x d-%02x\\n\",\n\t\t\tCTCM_FUNTAIL, dev_name(&cdev->dev), cstat, dstat);\n\t\tdev_warn(&cdev->dev,\n\t\t\t\"The adapter received a non-specific IRQ\\n\");\n\t\treturn;\n\t}\n\n\tpriv = dev_get_drvdata(&cgdev->dev);\n\n\t \n\tif (priv->channel[CTCM_READ]->cdev == cdev)\n\t\tch = priv->channel[CTCM_READ];\n\telse if (priv->channel[CTCM_WRITE]->cdev == cdev)\n\t\tch = priv->channel[CTCM_WRITE];\n\telse {\n\t\tdev_err(&cdev->dev,\n\t\t\t\"%s: Internal error: Can't determine channel for \"\n\t\t\t\"interrupt device %s\\n\",\n\t\t\t__func__, dev_name(&cdev->dev));\n\t\t\t \n\t\treturn;\n\t}\n\n\tdev = ch->netdev;\n\tif (dev == NULL) {\n\t\tdev_err(&cdev->dev,\n\t\t\t\"%s Internal error: net_device is NULL, ch = 0x%p\\n\",\n\t\t\t__func__, ch);\n\t\t\t \n\t\treturn;\n\t}\n\n\t \n\tmemcpy(ch->irb, irb, sizeof(struct irb));\n\n\t \n\tif (irb->scsw.cmd.cstat) {\n\t\tfsm_event(ch->fsm, CTC_EVENT_SC_UNKNOWN, ch);\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\n\t\t\t\"%s(%s): sub-ch check %s: cs=%02x ds=%02x\",\n\t\t\t\tCTCM_FUNTAIL, dev->name, ch->id, cstat, dstat);\n\t\tdev_warn(&cdev->dev,\n\t\t\t\t\"A check occurred on the subchannel\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {\n\t\tif ((irb->ecw[0] & ch->sense_rc) == 0)\n\t\t\t \n\t\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\n\t\t\t\t\"%s(%s): sense=%02x, ds=%02x\",\n\t\t\t\tCTCM_FUNTAIL, ch->id, irb->ecw[0], dstat);\n\t\tccw_unit_check(ch, irb->ecw[0]);\n\t\treturn;\n\t}\n\tif (irb->scsw.cmd.dstat & DEV_STAT_BUSY) {\n\t\tif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION)\n\t\t\tfsm_event(ch->fsm, CTC_EVENT_ATTNBUSY, ch);\n\t\telse\n\t\t\tfsm_event(ch->fsm, CTC_EVENT_BUSY, ch);\n\t\treturn;\n\t}\n\tif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\n\t\tfsm_event(ch->fsm, CTC_EVENT_ATTN, ch);\n\t\treturn;\n\t}\n\tif ((irb->scsw.cmd.stctl & SCSW_STCTL_SEC_STATUS) ||\n\t    (irb->scsw.cmd.stctl == SCSW_STCTL_STATUS_PEND) ||\n\t    (irb->scsw.cmd.stctl ==\n\t     (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))\n\t\tfsm_event(ch->fsm, CTC_EVENT_FINSTAT, ch);\n\telse\n\t\tfsm_event(ch->fsm, CTC_EVENT_IRQ, ch);\n\n}\n\nstatic const struct device_type ctcm_devtype = {\n\t.name = \"ctcm\",\n\t.groups = ctcm_attr_groups,\n};\n\n \nstatic int ctcm_probe_device(struct ccwgroup_device *cgdev)\n{\n\tstruct ctcm_priv *priv;\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\n\t\t\t\"%s %p\",\n\t\t\t__func__, cgdev);\n\n\tif (!get_device(&cgdev->dev))\n\t\treturn -ENODEV;\n\n\tpriv = kzalloc(sizeof(struct ctcm_priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\n\t\t\t\"%s: memory allocation failure\",\n\t\t\tCTCM_FUNTAIL);\n\t\tput_device(&cgdev->dev);\n\t\treturn -ENOMEM;\n\t}\n\tpriv->buffer_size = CTCM_BUFSIZE_DEFAULT;\n\tcgdev->cdev[0]->handler = ctcm_irq_handler;\n\tcgdev->cdev[1]->handler = ctcm_irq_handler;\n\tdev_set_drvdata(&cgdev->dev, priv);\n\tcgdev->dev.type = &ctcm_devtype;\n\n\treturn 0;\n}\n\n \nstatic int add_channel(struct ccw_device *cdev, enum ctcm_channel_types type,\n\t\t\t\tstruct ctcm_priv *priv)\n{\n\tstruct channel **c = &channels;\n\tstruct channel *ch;\n\tint ccw_num;\n\tint rc = 0;\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\n\t\t\"%s(%s), type %d, proto %d\",\n\t\t\t__func__, dev_name(&cdev->dev),\ttype, priv->protocol);\n\n\tch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (ch == NULL)\n\t\treturn -ENOMEM;\n\n\tch->protocol = priv->protocol;\n\tif (IS_MPC(priv)) {\n\t\tch->discontact_th = kzalloc(TH_HEADER_LENGTH, GFP_KERNEL);\n\t\tif (ch->discontact_th == NULL)\n\t\t\t\t\tgoto nomem_return;\n\n\t\tch->discontact_th->th_blk_flag = TH_DISCONTACT;\n\t\ttasklet_init(&ch->ch_disc_tasklet,\n\t\t\tmpc_action_send_discontact, (unsigned long)ch);\n\n\t\ttasklet_init(&ch->ch_tasklet, ctcmpc_bh, (unsigned long)ch);\n\t\tch->max_bufsize = (MPC_BUFSIZE_DEFAULT - 35);\n\t\tccw_num = 17;\n\t} else\n\t\tccw_num = 8;\n\n\tch->ccw = kcalloc(ccw_num, sizeof(struct ccw1), GFP_KERNEL | GFP_DMA);\n\tif (ch->ccw == NULL)\n\t\t\t\t\tgoto nomem_return;\n\n\tch->cdev = cdev;\n\tscnprintf(ch->id, CTCM_ID_SIZE, \"ch-%s\", dev_name(&cdev->dev));\n\tch->type = type;\n\n\t \n\tch->ccw[6].cmd_code\t= CCW_CMD_SET_EXTENDED;\n\tch->ccw[6].flags\t= CCW_FLAG_SLI;\n\n\tch->ccw[7].cmd_code\t= CCW_CMD_NOOP;\n\tch->ccw[7].flags\t= CCW_FLAG_SLI;\n\n\tif (IS_MPC(priv)) {\n\t\tch->ccw[15].cmd_code = CCW_CMD_WRITE;\n\t\tch->ccw[15].flags    = CCW_FLAG_SLI | CCW_FLAG_CC;\n\t\tch->ccw[15].count    = TH_HEADER_LENGTH;\n\t\tch->ccw[15].cda      = virt_to_phys(ch->discontact_th);\n\n\t\tch->ccw[16].cmd_code = CCW_CMD_NOOP;\n\t\tch->ccw[16].flags    = CCW_FLAG_SLI;\n\n\t\tch->fsm = init_fsm(ch->id, ctc_ch_state_names,\n\t\t\t\tctc_ch_event_names, CTC_MPC_NR_STATES,\n\t\t\t\tCTC_MPC_NR_EVENTS, ctcmpc_ch_fsm,\n\t\t\t\tmpc_ch_fsm_len, GFP_KERNEL);\n\t} else {\n\t\tch->fsm = init_fsm(ch->id, ctc_ch_state_names,\n\t\t\t\tctc_ch_event_names, CTC_NR_STATES,\n\t\t\t\tCTC_NR_EVENTS, ch_fsm,\n\t\t\t\tch_fsm_len, GFP_KERNEL);\n\t}\n\tif (ch->fsm == NULL)\n\t\t\t\tgoto nomem_return;\n\n\tfsm_newstate(ch->fsm, CTC_STATE_IDLE);\n\n\tch->irb = kzalloc(sizeof(struct irb), GFP_KERNEL);\n\tif (ch->irb == NULL)\n\t\t\t\tgoto nomem_return;\n\n\twhile (*c && ctcm_less_than((*c)->id, ch->id))\n\t\tc = &(*c)->next;\n\n\tif (*c && (!strncmp((*c)->id, ch->id, CTCM_ID_SIZE))) {\n\t\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\n\t\t\t\t\"%s (%s) already in list, using old entry\",\n\t\t\t\t__func__, (*c)->id);\n\n\t\tgoto free_return;\n\t}\n\n\tspin_lock_init(&ch->collect_lock);\n\n\tfsm_settimer(ch->fsm, &ch->timer);\n\tskb_queue_head_init(&ch->io_queue);\n\tskb_queue_head_init(&ch->collect_queue);\n\n\tif (IS_MPC(priv)) {\n\t\tfsm_settimer(ch->fsm, &ch->sweep_timer);\n\t\tskb_queue_head_init(&ch->sweep_queue);\n\t}\n\tch->next = *c;\n\t*c = ch;\n\treturn 0;\n\nnomem_return:\n\trc = -ENOMEM;\n\nfree_return:\t \n\tkfree(ch->ccw);\n\tkfree(ch->discontact_th);\n\tkfree_fsm(ch->fsm);\n\tkfree(ch->irb);\n\tkfree(ch);\n\treturn rc;\n}\n\n \nstatic enum ctcm_channel_types get_channel_type(struct ccw_device_id *id)\n{\n\tenum ctcm_channel_types type;\n\ttype = (enum ctcm_channel_types)id->driver_info;\n\n\tif (type == ctcm_channel_type_ficon)\n\t\ttype = ctcm_channel_type_escon;\n\n\treturn type;\n}\n\n \nstatic int ctcm_new_device(struct ccwgroup_device *cgdev)\n{\n\tchar read_id[CTCM_ID_SIZE];\n\tchar write_id[CTCM_ID_SIZE];\n\tint direction;\n\tenum ctcm_channel_types type;\n\tstruct ctcm_priv *priv;\n\tstruct net_device *dev;\n\tstruct ccw_device *cdev0;\n\tstruct ccw_device *cdev1;\n\tstruct channel *readc;\n\tstruct channel *writec;\n\tint ret;\n\tint result;\n\n\tpriv = dev_get_drvdata(&cgdev->dev);\n\tif (!priv) {\n\t\tresult = -ENODEV;\n\t\tgoto out_err_result;\n\t}\n\n\tcdev0 = cgdev->cdev[0];\n\tcdev1 = cgdev->cdev[1];\n\n\ttype = get_channel_type(&cdev0->id);\n\n\tscnprintf(read_id, CTCM_ID_SIZE, \"ch-%s\", dev_name(&cdev0->dev));\n\tscnprintf(write_id, CTCM_ID_SIZE, \"ch-%s\", dev_name(&cdev1->dev));\n\n\tret = add_channel(cdev0, type, priv);\n\tif (ret) {\n\t\tresult = ret;\n\t\tgoto out_err_result;\n\t}\n\tret = add_channel(cdev1, type, priv);\n\tif (ret) {\n\t\tresult = ret;\n\t\tgoto out_remove_channel1;\n\t}\n\n\tret = ccw_device_set_online(cdev0);\n\tif (ret != 0) {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\n\t\t\t\"%s(%s) set_online rc=%d\",\n\t\t\t\tCTCM_FUNTAIL, read_id, ret);\n\t\tresult = -EIO;\n\t\tgoto out_remove_channel2;\n\t}\n\n\tret = ccw_device_set_online(cdev1);\n\tif (ret != 0) {\n\t\tCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\n\t\t\t\"%s(%s) set_online rc=%d\",\n\t\t\t\tCTCM_FUNTAIL, write_id, ret);\n\n\t\tresult = -EIO;\n\t\tgoto out_ccw1;\n\t}\n\n\tdev = ctcm_init_netdevice(priv);\n\tif (dev == NULL) {\n\t\tresult = -ENODEV;\n\t\tgoto out_ccw2;\n\t}\n\n\tfor (direction = CTCM_READ; direction <= CTCM_WRITE; direction++) {\n\t\tpriv->channel[direction] =\n\t\t\tchannel_get(type, direction == CTCM_READ ?\n\t\t\t\tread_id : write_id, direction);\n\t\tif (priv->channel[direction] == NULL) {\n\t\t\tif (direction == CTCM_WRITE)\n\t\t\t\tchannel_free(priv->channel[CTCM_READ]);\n\t\t\tresult = -ENODEV;\n\t\t\tgoto out_dev;\n\t\t}\n\t\tpriv->channel[direction]->netdev = dev;\n\t\tpriv->channel[direction]->protocol = priv->protocol;\n\t\tpriv->channel[direction]->max_bufsize = priv->buffer_size;\n\t}\n\t \n\tSET_NETDEV_DEV(dev, &cgdev->dev);\n\n\tif (register_netdev(dev)) {\n\t\tresult = -ENODEV;\n\t\tgoto out_dev;\n\t}\n\n\tstrscpy(priv->fsm->name, dev->name, sizeof(priv->fsm->name));\n\n\tdev_info(&dev->dev,\n\t\t\"setup OK : r/w = %s/%s, protocol : %d\\n\",\n\t\t\tpriv->channel[CTCM_READ]->id,\n\t\t\tpriv->channel[CTCM_WRITE]->id, priv->protocol);\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\n\t\t\"setup(%s) OK : r/w = %s/%s, protocol : %d\", dev->name,\n\t\t\tpriv->channel[CTCM_READ]->id,\n\t\t\tpriv->channel[CTCM_WRITE]->id, priv->protocol);\n\n\treturn 0;\nout_dev:\n\tctcm_free_netdevice(dev);\nout_ccw2:\n\tccw_device_set_offline(cgdev->cdev[1]);\nout_ccw1:\n\tccw_device_set_offline(cgdev->cdev[0]);\nout_remove_channel2:\n\treadc = channel_get(type, read_id, CTCM_READ);\n\tchannel_remove(readc);\nout_remove_channel1:\n\twritec = channel_get(type, write_id, CTCM_WRITE);\n\tchannel_remove(writec);\nout_err_result:\n\treturn result;\n}\n\n \nstatic int ctcm_shutdown_device(struct ccwgroup_device *cgdev)\n{\n\tstruct ctcm_priv *priv;\n\tstruct net_device *dev;\n\n\tpriv = dev_get_drvdata(&cgdev->dev);\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tif (priv->channel[CTCM_READ]) {\n\t\tdev = priv->channel[CTCM_READ]->netdev;\n\t\tCTCM_DBF_DEV(SETUP, dev, \"\");\n\t\t \n\t\tctcm_close(dev);\n\t\tdev->flags &= ~IFF_RUNNING;\n\t\tchannel_free(priv->channel[CTCM_READ]);\n\t} else\n\t\tdev = NULL;\n\n\tif (priv->channel[CTCM_WRITE])\n\t\tchannel_free(priv->channel[CTCM_WRITE]);\n\n\tif (dev) {\n\t\tunregister_netdev(dev);\n\t\tctcm_free_netdevice(dev);\n\t}\n\n\tif (priv->fsm)\n\t\tkfree_fsm(priv->fsm);\n\n\tccw_device_set_offline(cgdev->cdev[1]);\n\tccw_device_set_offline(cgdev->cdev[0]);\n\tchannel_remove(priv->channel[CTCM_READ]);\n\tchannel_remove(priv->channel[CTCM_WRITE]);\n\tpriv->channel[CTCM_READ] = priv->channel[CTCM_WRITE] = NULL;\n\n\treturn 0;\n\n}\n\n\nstatic void ctcm_remove_device(struct ccwgroup_device *cgdev)\n{\n\tstruct ctcm_priv *priv = dev_get_drvdata(&cgdev->dev);\n\n\tCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\n\t\t\t\"removing device %p, proto : %d\",\n\t\t\tcgdev, priv->protocol);\n\n\tif (cgdev->state == CCWGROUP_ONLINE)\n\t\tctcm_shutdown_device(cgdev);\n\tdev_set_drvdata(&cgdev->dev, NULL);\n\tkfree(priv);\n\tput_device(&cgdev->dev);\n}\n\nstatic struct ccw_device_id ctcm_ids[] = {\n\t{CCW_DEVICE(0x3088, 0x08), .driver_info = ctcm_channel_type_parallel},\n\t{CCW_DEVICE(0x3088, 0x1e), .driver_info = ctcm_channel_type_ficon},\n\t{CCW_DEVICE(0x3088, 0x1f), .driver_info = ctcm_channel_type_escon},\n\t{},\n};\nMODULE_DEVICE_TABLE(ccw, ctcm_ids);\n\nstatic struct ccw_driver ctcm_ccw_driver = {\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"ctcm\",\n\t},\n\t.ids\t= ctcm_ids,\n\t.probe\t= ccwgroup_probe_ccwdev,\n\t.remove\t= ccwgroup_remove_ccwdev,\n\t.int_class = IRQIO_CTC,\n};\n\nstatic struct ccwgroup_driver ctcm_group_driver = {\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= CTC_DRIVER_NAME,\n\t},\n\t.ccw_driver  = &ctcm_ccw_driver,\n\t.setup\t     = ctcm_probe_device,\n\t.remove      = ctcm_remove_device,\n\t.set_online  = ctcm_new_device,\n\t.set_offline = ctcm_shutdown_device,\n};\n\nstatic ssize_t group_store(struct device_driver *ddrv, const char *buf,\n\t\t\t   size_t count)\n{\n\tint err;\n\n\terr = ccwgroup_create_dev(ctcm_root_dev, &ctcm_group_driver, 2, buf);\n\treturn err ? err : count;\n}\nstatic DRIVER_ATTR_WO(group);\n\nstatic struct attribute *ctcm_drv_attrs[] = {\n\t&driver_attr_group.attr,\n\tNULL,\n};\nstatic struct attribute_group ctcm_drv_attr_group = {\n\t.attrs = ctcm_drv_attrs,\n};\nstatic const struct attribute_group *ctcm_drv_attr_groups[] = {\n\t&ctcm_drv_attr_group,\n\tNULL,\n};\n\n \n\n \nstatic void __exit ctcm_exit(void)\n{\n\tccwgroup_driver_unregister(&ctcm_group_driver);\n\tccw_driver_unregister(&ctcm_ccw_driver);\n\troot_device_unregister(ctcm_root_dev);\n\tctcm_unregister_dbf_views();\n\tpr_info(\"CTCM driver unloaded\\n\");\n}\n\n \nstatic void print_banner(void)\n{\n\tpr_info(\"CTCM driver initialized\\n\");\n}\n\n \nstatic int __init ctcm_init(void)\n{\n\tint ret;\n\n\tchannels = NULL;\n\n\tret = ctcm_register_dbf_views();\n\tif (ret)\n\t\tgoto out_err;\n\tctcm_root_dev = root_device_register(\"ctcm\");\n\tret = PTR_ERR_OR_ZERO(ctcm_root_dev);\n\tif (ret)\n\t\tgoto register_err;\n\tret = ccw_driver_register(&ctcm_ccw_driver);\n\tif (ret)\n\t\tgoto ccw_err;\n\tctcm_group_driver.driver.groups = ctcm_drv_attr_groups;\n\tret = ccwgroup_driver_register(&ctcm_group_driver);\n\tif (ret)\n\t\tgoto ccwgroup_err;\n\tprint_banner();\n\treturn 0;\n\nccwgroup_err:\n\tccw_driver_unregister(&ctcm_ccw_driver);\nccw_err:\n\troot_device_unregister(ctcm_root_dev);\nregister_err:\n\tctcm_unregister_dbf_views();\nout_err:\n\tpr_err(\"%s / Initializing the ctcm device driver failed, ret = %d\\n\",\n\t\t__func__, ret);\n\treturn ret;\n}\n\nmodule_init(ctcm_init);\nmodule_exit(ctcm_exit);\n\nMODULE_AUTHOR(\"Peter Tiedemann <ptiedem@de.ibm.com>\");\nMODULE_DESCRIPTION(\"Network driver for S/390 CTC + CTCMPC (SNA)\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}