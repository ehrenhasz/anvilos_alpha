{
  "module_name": "fsm.h",
  "hash_id": "518adeeb7536ca5a1348f26b3ca3240aaea01219dca6454fba6e89a0c661e8ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/fsm.h",
  "human_readable_source": " \n#ifndef _FSM_H_\n#define _FSM_H_\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/atomic.h>\n\n \n#define FSM_DEBUG         0\n\n \n#define FSM_TIMER_DEBUG   0\n\n \n#define FSM_DEBUG_HISTORY 0\n#define FSM_HISTORY_SIZE  40\n\nstruct fsm_instance_t;\n\n \ntypedef void (*fsm_function_t)(struct fsm_instance_t *, int, void *);\n\n \ntypedef struct {\n\tfsm_function_t *jumpmatrix;\n\tint nr_events;\n\tint nr_states;\n\tconst char **event_names;\n\tconst char **state_names;\n} fsm;\n\n#if FSM_DEBUG_HISTORY\n \ntypedef struct {\n\tint state;\n\tint event;\n} fsm_history;\n#endif\n\n \ntypedef struct fsm_instance_t {\n\tfsm *f;\n\tatomic_t state;\n\tchar name[16];\n\tvoid *userdata;\n\tint userint;\n\twait_queue_head_t wait_q;\n#if FSM_DEBUG_HISTORY\n\tint         history_index;\n\tint         history_size;\n\tfsm_history history[FSM_HISTORY_SIZE];\n#endif\n} fsm_instance;\n\n \ntypedef struct {\n\tint cond_state;\n\tint cond_event;\n\tfsm_function_t function;\n} fsm_node;\n\n \ntypedef struct {\n\tfsm_instance *fi;\n\tstruct timer_list tl;\n\tint expire_event;\n\tvoid *event_arg;\n} fsm_timer;\n\n \nextern fsm_instance *\ninit_fsm(char *name, const char **state_names,\n\t const char **event_names,\n\t int nr_states, int nr_events, const fsm_node *tmpl,\n\t int tmpl_len, gfp_t order);\n\n \nextern void kfree_fsm(fsm_instance *fi);\n\n#if FSM_DEBUG_HISTORY\nextern void\nfsm_print_history(fsm_instance *fi);\n\nextern void\nfsm_record_history(fsm_instance *fi, int state, int event);\n#endif\n\n \nstatic inline int\nfsm_event(fsm_instance *fi, int event, void *arg)\n{\n\tfsm_function_t r;\n\tint state = atomic_read(&fi->state);\n\n\tif ((state >= fi->f->nr_states) ||\n\t    (event >= fi->f->nr_events)       ) {\n\t\tprintk(KERN_ERR \"fsm(%s): Invalid state st(%ld/%ld) ev(%d/%ld)\\n\",\n\t\t\tfi->name, (long)state,(long)fi->f->nr_states, event,\n\t\t\t(long)fi->f->nr_events);\n#if FSM_DEBUG_HISTORY\n\t\tfsm_print_history(fi);\n#endif\n\t\treturn 1;\n\t}\n\tr = fi->f->jumpmatrix[fi->f->nr_states * event + state];\n\tif (r) {\n#if FSM_DEBUG\n\t\tprintk(KERN_DEBUG \"fsm(%s): state %s event %s\\n\",\n\t\t       fi->name, fi->f->state_names[state],\n\t\t       fi->f->event_names[event]);\n#endif\n#if FSM_DEBUG_HISTORY\n\t\tfsm_record_history(fi, state, event);\n#endif\n\t\tr(fi, event, arg);\n\t\treturn 0;\n\t} else {\n#if FSM_DEBUG || FSM_DEBUG_HISTORY\n\t\tprintk(KERN_DEBUG \"fsm(%s): no function for event %s in state %s\\n\",\n\t\t       fi->name, fi->f->event_names[event],\n\t\t       fi->f->state_names[state]);\n#endif\n#if FSM_DEBUG_HISTORY\n\t\tfsm_print_history(fi);\n#endif\n\t\treturn !0;\n\t}\n}\n\n \nstatic inline void\nfsm_newstate(fsm_instance *fi, int newstate)\n{\n\tatomic_set(&fi->state,newstate);\n#if FSM_DEBUG_HISTORY\n\tfsm_record_history(fi, newstate, -1);\n#endif\n#if FSM_DEBUG\n\tprintk(KERN_DEBUG \"fsm(%s): New state %s\\n\", fi->name,\n\t\tfi->f->state_names[newstate]);\n#endif\n\twake_up(&fi->wait_q);\n}\n\n \nstatic inline int\nfsm_getstate(fsm_instance *fi)\n{\n\treturn atomic_read(&fi->state);\n}\n\n \nextern const char *fsm_getstate_str(fsm_instance *fi);\n\n \nextern void fsm_settimer(fsm_instance *fi, fsm_timer *);\n\n \nextern void fsm_deltimer(fsm_timer *timer);\n\n \nextern int fsm_addtimer(fsm_timer *timer, int millisec, int event, void *arg);\n\n \nextern void fsm_modtimer(fsm_timer *timer, int millisec, int event, void *arg);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}