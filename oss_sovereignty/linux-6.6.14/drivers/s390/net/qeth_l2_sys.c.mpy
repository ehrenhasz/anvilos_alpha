{
  "module_name": "qeth_l2_sys.c",
  "hash_id": "f7198b76d9e6e013477eb26c6a031ac7727e04a6530d90eb7cc062604d6d1dd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/qeth_l2_sys.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <asm/ebcdic.h>\n#include \"qeth_core.h\"\n#include \"qeth_l2.h\"\n\nstatic ssize_t qeth_bridge_port_role_state_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf,\n\t\t\t\tint show_state)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tenum qeth_sbp_states state = QETH_SBP_STATE_INACTIVE;\n\tint rc = 0;\n\tchar *word;\n\n\tif (!qeth_bridgeport_allowed(card))\n\t\treturn sysfs_emit(buf, \"n/a (VNIC characteristics)\\n\");\n\n\tmutex_lock(&card->sbp_lock);\n\tif (qeth_card_hw_is_reachable(card) &&\n\t\t\t\t\tcard->options.sbp.supported_funcs)\n\t\trc = qeth_bridgeport_query_ports(card,\n\t\t\t&card->options.sbp.role, &state);\n\tif (!rc) {\n\t\tif (show_state)\n\t\t\tswitch (state) {\n\t\t\tcase QETH_SBP_STATE_INACTIVE:\n\t\t\t\tword = \"inactive\"; break;\n\t\t\tcase QETH_SBP_STATE_STANDBY:\n\t\t\t\tword = \"standby\"; break;\n\t\t\tcase QETH_SBP_STATE_ACTIVE:\n\t\t\t\tword = \"active\"; break;\n\t\t\tdefault:\n\t\t\t\trc = -EIO;\n\t\t\t}\n\t\telse\n\t\t\tswitch (card->options.sbp.role) {\n\t\t\tcase QETH_SBP_ROLE_NONE:\n\t\t\t\tword = \"none\"; break;\n\t\t\tcase QETH_SBP_ROLE_PRIMARY:\n\t\t\t\tword = \"primary\"; break;\n\t\t\tcase QETH_SBP_ROLE_SECONDARY:\n\t\t\t\tword = \"secondary\"; break;\n\t\t\tdefault:\n\t\t\t\trc = -EIO;\n\t\t\t}\n\t\tif (rc)\n\t\t\tQETH_CARD_TEXT_(card, 2, \"SBP%02x:%02x\",\n\t\t\t\tcard->options.sbp.role, state);\n\t\telse\n\t\t\trc = sysfs_emit(buf, \"%s\\n\", word);\n\t}\n\tmutex_unlock(&card->sbp_lock);\n\n\treturn rc;\n}\n\nstatic ssize_t qeth_bridge_port_role_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\tif (!qeth_bridgeport_allowed(card))\n\t\treturn sysfs_emit(buf, \"n/a (VNIC characteristics)\\n\");\n\n\treturn qeth_bridge_port_role_state_show(dev, attr, buf, 0);\n}\n\nstatic ssize_t qeth_bridge_port_role_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tint rc = 0;\n\tenum qeth_sbp_roles role;\n\n\tif (sysfs_streq(buf, \"primary\"))\n\t\trole = QETH_SBP_ROLE_PRIMARY;\n\telse if (sysfs_streq(buf, \"secondary\"))\n\t\trole = QETH_SBP_ROLE_SECONDARY;\n\telse if (sysfs_streq(buf, \"none\"))\n\t\trole = QETH_SBP_ROLE_NONE;\n\telse\n\t\treturn -EINVAL;\n\n\tmutex_lock(&card->conf_mutex);\n\tmutex_lock(&card->sbp_lock);\n\n\tif (!qeth_bridgeport_allowed(card))\n\t\trc = -EBUSY;\n\telse if (card->options.sbp.reflect_promisc)\n\t\t \n\t\trc = -EPERM;\n\telse if (qeth_card_hw_is_reachable(card)) {\n\t\trc = qeth_bridgeport_setrole(card, role);\n\t\tif (!rc)\n\t\t\tcard->options.sbp.role = role;\n\t} else\n\t\tcard->options.sbp.role = role;\n\n\tmutex_unlock(&card->sbp_lock);\n\tmutex_unlock(&card->conf_mutex);\n\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(bridge_role, 0644, qeth_bridge_port_role_show,\n\t\t   qeth_bridge_port_role_store);\n\nstatic ssize_t qeth_bridge_port_state_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\n\tif (!qeth_bridgeport_allowed(card))\n\t\treturn sysfs_emit(buf, \"n/a (VNIC characteristics)\\n\");\n\n\treturn qeth_bridge_port_role_state_show(dev, attr, buf, 1);\n}\n\nstatic DEVICE_ATTR(bridge_state, 0444, qeth_bridge_port_state_show,\n\t\t   NULL);\n\nstatic ssize_t qeth_bridgeport_hostnotification_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tint enabled;\n\n\tif (!qeth_bridgeport_allowed(card))\n\t\treturn sysfs_emit(buf, \"n/a (VNIC characteristics)\\n\");\n\n\tenabled = card->options.sbp.hostnotification;\n\n\treturn sysfs_emit(buf, \"%d\\n\", enabled);\n}\n\nstatic ssize_t qeth_bridgeport_hostnotification_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tbool enable;\n\tint rc;\n\n\trc = kstrtobool(buf, &enable);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&card->conf_mutex);\n\tmutex_lock(&card->sbp_lock);\n\n\tif (!qeth_bridgeport_allowed(card))\n\t\trc = -EBUSY;\n\telse if (qeth_card_hw_is_reachable(card)) {\n\t\trc = qeth_bridgeport_an_set(card, enable);\n\t\t \n\t\tif (!rc)\n\t\t\tcard->options.sbp.hostnotification = enable;\n\t} else\n\t\tcard->options.sbp.hostnotification = enable;\n\n\tmutex_unlock(&card->sbp_lock);\n\tmutex_unlock(&card->conf_mutex);\n\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(bridge_hostnotify, 0644,\n\t\t\tqeth_bridgeport_hostnotification_show,\n\t\t\tqeth_bridgeport_hostnotification_store);\n\nstatic ssize_t qeth_bridgeport_reflect_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tchar *state;\n\n\tif (!qeth_bridgeport_allowed(card))\n\t\treturn sysfs_emit(buf, \"n/a (VNIC characteristics)\\n\");\n\n\tif (card->options.sbp.reflect_promisc) {\n\t\tif (card->options.sbp.reflect_promisc_primary)\n\t\t\tstate = \"primary\";\n\t\telse\n\t\t\tstate = \"secondary\";\n\t} else\n\t\tstate = \"none\";\n\n\treturn sysfs_emit(buf, \"%s\\n\", state);\n}\n\nstatic ssize_t qeth_bridgeport_reflect_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tint enable, primary;\n\tint rc = 0;\n\n\tif (sysfs_streq(buf, \"none\")) {\n\t\tenable = 0;\n\t\tprimary = 0;\n\t} else if (sysfs_streq(buf, \"primary\")) {\n\t\tenable = 1;\n\t\tprimary = 1;\n\t} else if (sysfs_streq(buf, \"secondary\")) {\n\t\tenable = 1;\n\t\tprimary = 0;\n\t} else\n\t\treturn -EINVAL;\n\n\tmutex_lock(&card->conf_mutex);\n\tmutex_lock(&card->sbp_lock);\n\n\tif (!qeth_bridgeport_allowed(card))\n\t\trc = -EBUSY;\n\telse if (card->options.sbp.role != QETH_SBP_ROLE_NONE)\n\t\trc = -EPERM;\n\telse {\n\t\tcard->options.sbp.reflect_promisc = enable;\n\t\tcard->options.sbp.reflect_promisc_primary = primary;\n\t\trc = 0;\n\t}\n\n\tmutex_unlock(&card->sbp_lock);\n\tmutex_unlock(&card->conf_mutex);\n\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(bridge_reflect_promisc, 0644,\n\t\t\tqeth_bridgeport_reflect_show,\n\t\t\tqeth_bridgeport_reflect_store);\n\nstatic struct attribute *qeth_l2_bridgeport_attrs[] = {\n\t&dev_attr_bridge_role.attr,\n\t&dev_attr_bridge_state.attr,\n\t&dev_attr_bridge_hostnotify.attr,\n\t&dev_attr_bridge_reflect_promisc.attr,\n\tNULL,\n};\n\nstatic struct attribute_group qeth_l2_bridgeport_attr_group = {\n\t.attrs = qeth_l2_bridgeport_attrs,\n};\n\n \n\n \nstatic u32 qeth_l2_vnicc_sysfs_attr_to_char(const char *attr_name)\n{\n\tif (sysfs_streq(attr_name, \"flooding\"))\n\t\treturn QETH_VNICC_FLOODING;\n\telse if (sysfs_streq(attr_name, \"mcast_flooding\"))\n\t\treturn QETH_VNICC_MCAST_FLOODING;\n\telse if (sysfs_streq(attr_name, \"learning\"))\n\t\treturn QETH_VNICC_LEARNING;\n\telse if (sysfs_streq(attr_name, \"takeover_setvmac\"))\n\t\treturn QETH_VNICC_TAKEOVER_SETVMAC;\n\telse if (sysfs_streq(attr_name, \"takeover_learning\"))\n\t\treturn QETH_VNICC_TAKEOVER_LEARNING;\n\telse if (sysfs_streq(attr_name, \"bridge_invisible\"))\n\t\treturn QETH_VNICC_BRIDGE_INVISIBLE;\n\telse if (sysfs_streq(attr_name, \"rx_bcast\"))\n\t\treturn QETH_VNICC_RX_BCAST;\n\n\treturn 0;\n}\n\n \nstatic ssize_t qeth_vnicc_timeout_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tu32 timeout;\n\tint rc;\n\n\trc = qeth_l2_vnicc_get_timeout(card, &timeout);\n\tif (rc == -EBUSY)\n\t\treturn sysfs_emit(buf, \"n/a (BridgePort)\\n\");\n\tif (rc == -EOPNOTSUPP)\n\t\treturn sysfs_emit(buf, \"n/a\\n\");\n\treturn rc ? rc : sysfs_emit(buf, \"%d\\n\", timeout);\n}\n\n \nstatic ssize_t qeth_vnicc_timeout_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tu32 timeout;\n\tint rc;\n\n\trc = kstrtou32(buf, 10, &timeout);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&card->conf_mutex);\n\trc = qeth_l2_vnicc_set_timeout(card, timeout);\n\tmutex_unlock(&card->conf_mutex);\n\treturn rc ? rc : count;\n}\n\n \nstatic ssize_t qeth_vnicc_char_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tbool state;\n\tu32 vnicc;\n\tint rc;\n\n\tvnicc = qeth_l2_vnicc_sysfs_attr_to_char(attr->attr.name);\n\trc = qeth_l2_vnicc_get_state(card, vnicc, &state);\n\n\tif (rc == -EBUSY)\n\t\treturn sysfs_emit(buf, \"n/a (BridgePort)\\n\");\n\tif (rc == -EOPNOTSUPP)\n\t\treturn sysfs_emit(buf, \"n/a\\n\");\n\treturn rc ? rc : sysfs_emit(buf, \"%d\\n\", state);\n}\n\n \nstatic ssize_t qeth_vnicc_char_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct qeth_card *card = dev_get_drvdata(dev);\n\tbool state;\n\tu32 vnicc;\n\tint rc;\n\n\tif (kstrtobool(buf, &state))\n\t\treturn -EINVAL;\n\n\tvnicc = qeth_l2_vnicc_sysfs_attr_to_char(attr->attr.name);\n\tmutex_lock(&card->conf_mutex);\n\trc = qeth_l2_vnicc_set_state(card, vnicc, state);\n\tmutex_unlock(&card->conf_mutex);\n\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(flooding, 0644, qeth_vnicc_char_show, qeth_vnicc_char_store);\nstatic DEVICE_ATTR(mcast_flooding, 0644, qeth_vnicc_char_show,\n\t\t   qeth_vnicc_char_store);\nstatic DEVICE_ATTR(learning, 0644, qeth_vnicc_char_show, qeth_vnicc_char_store);\nstatic DEVICE_ATTR(learning_timeout, 0644, qeth_vnicc_timeout_show,\n\t\t   qeth_vnicc_timeout_store);\nstatic DEVICE_ATTR(takeover_setvmac, 0644, qeth_vnicc_char_show,\n\t\t   qeth_vnicc_char_store);\nstatic DEVICE_ATTR(takeover_learning, 0644, qeth_vnicc_char_show,\n\t\t   qeth_vnicc_char_store);\nstatic DEVICE_ATTR(bridge_invisible, 0644, qeth_vnicc_char_show,\n\t\t   qeth_vnicc_char_store);\nstatic DEVICE_ATTR(rx_bcast, 0644, qeth_vnicc_char_show, qeth_vnicc_char_store);\n\nstatic struct attribute *qeth_l2_vnicc_attrs[] = {\n\t&dev_attr_flooding.attr,\n\t&dev_attr_mcast_flooding.attr,\n\t&dev_attr_learning.attr,\n\t&dev_attr_learning_timeout.attr,\n\t&dev_attr_takeover_setvmac.attr,\n\t&dev_attr_takeover_learning.attr,\n\t&dev_attr_bridge_invisible.attr,\n\t&dev_attr_rx_bcast.attr,\n\tNULL,\n};\n\nstatic struct attribute_group qeth_l2_vnicc_attr_group = {\n\t.attrs = qeth_l2_vnicc_attrs,\n\t.name = \"vnicc\",\n};\n\nconst struct attribute_group *qeth_l2_attr_groups[] = {\n\t&qeth_l2_bridgeport_attr_group,\n\t&qeth_l2_vnicc_attr_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}