{
  "module_name": "qeth_core.h",
  "hash_id": "6ffa003f223cdc9571170da36cf345daa1a1442b2be147351afc272c1645ef3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/qeth_core.h",
  "human_readable_source": " \n \n\n#ifndef __QETH_CORE_H__\n#define __QETH_CORE_H__\n\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/if.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/ctype.h>\n#include <linux/in6.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/hashtable.h>\n#include <linux/ip.h>\n#include <linux/rcupdate.h>\n#include <linux/refcount.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n#include <net/dst.h>\n#include <net/ip6_fib.h>\n#include <net/ipv6.h>\n#include <net/if_inet6.h>\n#include <net/addrconf.h>\n#include <net/route.h>\n#include <net/sch_generic.h>\n#include <net/tcp.h>\n\n#include <asm/debug.h>\n#include <asm/qdio.h>\n#include <asm/ccwdev.h>\n#include <asm/ccwgroup.h>\n#include <asm/sysinfo.h>\n\n#include <uapi/linux/if_link.h>\n\n#include \"qeth_core_mpc.h\"\n\n \nenum qeth_dbf_names {\n\tQETH_DBF_SETUP,\n\tQETH_DBF_MSG,\n\tQETH_DBF_CTRL,\n\tQETH_DBF_INFOS\t \n};\n\nstruct qeth_dbf_info {\n\tchar name[DEBUG_MAX_NAME_LEN];\n\tint pages;\n\tint areas;\n\tint len;\n\tint level;\n\tstruct debug_view *view;\n\tdebug_info_t *id;\n};\n\n#define QETH_DBF_CTRL_LEN 256U\n\n#define QETH_DBF_TEXT(name, level, text) \\\n\tdebug_text_event(qeth_dbf[QETH_DBF_##name].id, level, text)\n\n#define QETH_DBF_HEX(name, level, addr, len) \\\n\tdebug_event(qeth_dbf[QETH_DBF_##name].id, level, (void *)(addr), len)\n\n#define QETH_DBF_MESSAGE(level, text...) \\\n\tdebug_sprintf_event(qeth_dbf[QETH_DBF_MSG].id, level, text)\n\n#define QETH_DBF_TEXT_(name, level, text...) \\\n\tqeth_dbf_longtext(qeth_dbf[QETH_DBF_##name].id, level, text)\n\n#define QETH_CARD_TEXT(card, level, text) \\\n\tdebug_text_event(card->debug, level, text)\n\n#define QETH_CARD_HEX(card, level, addr, len) \\\n\tdebug_event(card->debug, level, (void *)(addr), len)\n\n#define QETH_CARD_MESSAGE(card, text...) \\\n\tdebug_sprintf_event(card->debug, level, text)\n\n#define QETH_CARD_TEXT_(card, level, text...) \\\n\tqeth_dbf_longtext(card->debug, level, text)\n\n#define SENSE_COMMAND_REJECT_BYTE 0\n#define SENSE_COMMAND_REJECT_FLAG 0x80\n#define SENSE_RESETTING_EVENT_BYTE 1\n#define SENSE_RESETTING_EVENT_FLAG 0x80\n\nstatic inline u32 qeth_get_device_id(struct ccw_device *cdev)\n{\n\tstruct ccw_dev_id dev_id;\n\tu32 id;\n\n\tccw_device_get_id(cdev, &dev_id);\n\tid = dev_id.devno;\n\tid |= (u32) (dev_id.ssid << 16);\n\n\treturn id;\n}\n\n \n#define CARD_RDEV(card) card->read.ccwdev\n#define CARD_WDEV(card) card->write.ccwdev\n#define CARD_DDEV(card) card->data.ccwdev\n#define CARD_BUS_ID(card) dev_name(&card->gdev->dev)\n#define CARD_RDEV_ID(card) dev_name(&card->read.ccwdev->dev)\n#define CARD_WDEV_ID(card) dev_name(&card->write.ccwdev->dev)\n#define CARD_DDEV_ID(card) dev_name(&card->data.ccwdev->dev)\n#define CCW_DEVID(cdev)\t\t(qeth_get_device_id(cdev))\n#define CARD_DEVID(card)\t(CCW_DEVID(CARD_RDEV(card)))\n\n \nstruct qeth_routing_info {\n\tenum qeth_routing_types type;\n};\n\n \nenum qeth_sbp_roles {\n\tQETH_SBP_ROLE_NONE\t= 0,\n\tQETH_SBP_ROLE_PRIMARY\t= 1,\n\tQETH_SBP_ROLE_SECONDARY\t= 2,\n};\n\nenum qeth_sbp_states {\n\tQETH_SBP_STATE_INACTIVE\t= 0,\n\tQETH_SBP_STATE_STANDBY\t= 1,\n\tQETH_SBP_STATE_ACTIVE\t= 2,\n};\n\n#define QETH_SBP_HOST_NOTIFICATION 1\n\nstruct qeth_sbp_info {\n\t__u32 supported_funcs;\n\tenum qeth_sbp_roles role;\n\t__u32 hostnotification:1;\n\t__u32 reflect_promisc:1;\n\t__u32 reflect_promisc_primary:1;\n};\n\nstruct qeth_vnicc_info {\n\t \n\tu32 sup_chars;\n\tu32 cur_chars;\n\t \n\tu32 set_char_sup;\n\tu32 getset_timeout_sup;\n\t \n\tu32 learning_timeout;\n\t \n\tu32 wanted_chars;\n\t \n\tbool rx_bcast_enabled;\n};\n\n#define QETH_IDX_FUNC_LEVEL_OSD\t\t 0x0101\n#define QETH_IDX_FUNC_LEVEL_IQD\t\t 0x4108\n\n#define QETH_BUFSIZE\t\t4096\n#define CCW_CMD_WRITE\t\t0x01\n#define CCW_CMD_READ\t\t0x02\n\n \n#define QETH_TX_TIMEOUT\t\t(100 * HZ)\n#define QETH_RCD_TIMEOUT\t(60 * HZ)\n#define QETH_RECLAIM_WORK_TIME\tHZ\n#define QETH_MAX_PORTNO\t\t15\n\n \n \n \n#define QETH_MAX_OUT_QUEUES\t4\n#define QETH_IQD_MIN_TXQ\t2\t \n#define QETH_IQD_MCAST_TXQ\t0\n#define QETH_IQD_MIN_UCAST_TXQ\t1\n\n#define QETH_MAX_IN_QUEUES\t2\n#define QETH_RX_COPYBREAK      (PAGE_SIZE >> 1)\n#define QETH_IN_BUF_SIZE_DEFAULT 65536\n#define QETH_IN_BUF_COUNT_DEFAULT 64\n#define QETH_IN_BUF_COUNT_HSDEFAULT 128\n#define QETH_IN_BUF_COUNT_MIN\t8U\n#define QETH_IN_BUF_COUNT_MAX\t128U\n#define QETH_MAX_BUFFER_ELEMENTS(card) ((card)->qdio.in_buf_size >> 12)\n#define QETH_IN_BUF_REQUEUE_THRESHOLD(card) \\\n\t\t ((card)->qdio.in_buf_pool.buf_count / 2)\n\n \n#define QETH_PCI_THRESHOLD_A(card) ((card)->qdio.in_buf_pool.buf_count+1)\n \n#define QETH_PCI_THRESHOLD_B(card) 0\n \n#define QETH_PCI_TIMER_VALUE(card) 3\n\n \n#define QETH_PRIOQ_DEFAULT QETH_NO_PRIO_QUEUEING\n#define QETH_DEFAULT_QUEUE    2\n#define QETH_NO_PRIO_QUEUEING 0\n#define QETH_PRIO_Q_ING_PREC  1\n#define QETH_PRIO_Q_ING_TOS   2\n#define QETH_PRIO_Q_ING_SKB   3\n#define QETH_PRIO_Q_ING_VLAN  4\n#define QETH_PRIO_Q_ING_FIXED 5\n\n \n#define QETH_LOW_WATERMARK_PACK  2\n#define QETH_HIGH_WATERMARK_PACK 5\n#define QETH_WATERMARK_PACK_FUZZ 1\n\nstruct qeth_hdr_layer3 {\n\t__u8  id;\n\t__u8  flags;\n\t__u16 inbound_checksum;  \n\t__u32 token;\t\t \n\t__u16 length;\n\t__u8  vlan_prio;\n\t__u8  ext_flags;\n\t__u16 vlan_id;\n\t__u16 frame_offset;\n\tunion {\n\t\t \n\t\tstruct in6_addr addr;\n\t\t \n\t\tstruct rx {\n\t\t\tu8 res1[2];\n\t\t\tu8 src_mac[6];\n\t\t\tu8 res2[4];\n\t\t\tu16 vlan_id;\n\t\t\tu8 res3[2];\n\t\t} rx;\n\t} next_hop;\n};\n\nstruct qeth_hdr_layer2 {\n\t__u8 id;\n\t__u8 flags[3];\n\t__u8 port_no;\n\t__u8 hdr_length;\n\t__u16 pkt_length;\n\t__u16 seq_no;\n\t__u16 vlan_id;\n\t__u32 reserved;\n\t__u8 reserved2[16];\n} __attribute__ ((packed));\n\nstruct qeth_hdr {\n\tunion {\n\t\tstruct qeth_hdr_layer2 l2;\n\t\tstruct qeth_hdr_layer3 l3;\n\t} hdr;\n} __attribute__ ((packed));\n\n#define QETH_QIB_PQUE_ORDER_RR\t\t0\n#define QETH_QIB_PQUE_UNITS_SBAL\t2\n#define QETH_QIB_PQUE_PRIO_DEFAULT\t4\n\nstruct qeth_qib_parms {\n\tchar pcit_magic[4];\n\tu32 pcit_a;\n\tu32 pcit_b;\n\tu32 pcit_c;\n\tchar blkt_magic[4];\n\tu32 blkt_total;\n\tu32 blkt_inter_packet;\n\tu32 blkt_inter_packet_jumbo;\n\tchar pque_magic[4];\n\tu8 pque_order;\n\tu8 pque_units;\n\tu16 reserved;\n\tu32 pque_priority[4];\n};\n\n \nstruct qeth_hdr_ext_tso {\n\t__u16 hdr_tot_len;\n\t__u8  imb_hdr_no;\n\t__u8  reserved;\n\t__u8  hdr_type;\n\t__u8  hdr_version;\n\t__u16 hdr_len;\n\t__u32 payload_len;\n\t__u16 mss;\n\t__u16 dg_hdr_len;\n\t__u8  padding[16];\n} __attribute__ ((packed));\n\nstruct qeth_hdr_tso {\n\tstruct qeth_hdr hdr;\t \n\tstruct qeth_hdr_ext_tso ext;\n} __attribute__ ((packed));\n\n\n \n#define QETH_HDR_PASSTHRU 0x10\n#define QETH_HDR_IPV6     0x80\n#define QETH_HDR_CAST_MASK 0x07\nenum qeth_cast_flags {\n\tQETH_CAST_UNICAST   = 0x06,\n\tQETH_CAST_MULTICAST = 0x04,\n\tQETH_CAST_BROADCAST = 0x05,\n\tQETH_CAST_ANYCAST   = 0x07,\n\tQETH_CAST_NOCAST    = 0x00,\n};\n\nenum qeth_layer2_frame_flags {\n\tQETH_LAYER2_FLAG_MULTICAST = 0x01,\n\tQETH_LAYER2_FLAG_BROADCAST = 0x02,\n\tQETH_LAYER2_FLAG_UNICAST   = 0x04,\n\tQETH_LAYER2_FLAG_VLAN      = 0x10,\n};\n\nenum qeth_header_ids {\n\tQETH_HEADER_TYPE_LAYER3 = 0x01,\n\tQETH_HEADER_TYPE_LAYER2 = 0x02,\n\tQETH_HEADER_TYPE_L3_TSO\t= 0x03,\n\tQETH_HEADER_TYPE_L2_TSO\t= 0x06,\n\tQETH_HEADER_MASK_INVAL\t= 0x80,\n};\n \n#define QETH_HDR_EXT_VLAN_FRAME       0x01\n#define QETH_HDR_EXT_TOKEN_ID         0x02\n#define QETH_HDR_EXT_INCLUDE_VLAN_TAG 0x04\n#define QETH_HDR_EXT_SRC_MAC_ADDR     0x08\n#define QETH_HDR_EXT_CSUM_HDR_REQ     0x10\n#define QETH_HDR_EXT_CSUM_TRANSP_REQ  0x20\n#define QETH_HDR_EXT_UDP\t      0x40  \n\nstatic inline bool qeth_l2_same_vlan(struct qeth_hdr_layer2 *h1,\n\t\t\t\t     struct qeth_hdr_layer2 *h2)\n{\n\treturn !((h1->flags[2] ^ h2->flags[2]) & QETH_LAYER2_FLAG_VLAN) &&\n\t       h1->vlan_id == h2->vlan_id;\n}\n\nstatic inline bool qeth_l3_iqd_same_vlan(struct qeth_hdr_layer3 *h1,\n\t\t\t\t\t struct qeth_hdr_layer3 *h2)\n{\n\treturn !((h1->ext_flags ^ h2->ext_flags) & QETH_HDR_EXT_VLAN_FRAME) &&\n\t       h1->vlan_id == h2->vlan_id;\n}\n\nstatic inline bool qeth_l3_same_next_hop(struct qeth_hdr_layer3 *h1,\n\t\t\t\t\t struct qeth_hdr_layer3 *h2)\n{\n\treturn !((h1->flags ^ h2->flags) & QETH_HDR_IPV6) &&\n\t       ipv6_addr_equal(&h1->next_hop.addr, &h2->next_hop.addr);\n}\n\nstruct qeth_local_addr {\n\tstruct hlist_node hnode;\n\tstruct rcu_head rcu;\n\tstruct in6_addr addr;\n};\n\nenum qeth_qdio_info_states {\n\tQETH_QDIO_UNINITIALIZED,\n\tQETH_QDIO_ALLOCATED,\n\tQETH_QDIO_ESTABLISHED,\n\tQETH_QDIO_CLEANING\n};\n\nstruct qeth_buffer_pool_entry {\n\tstruct list_head list;\n\tstruct list_head init_list;\n\tstruct page *elements[QDIO_MAX_ELEMENTS_PER_BUFFER];\n};\n\nstruct qeth_qdio_buffer_pool {\n\tstruct list_head entry_list;\n\tint buf_count;\n};\n\nstruct qeth_qdio_buffer {\n\tstruct qdio_buffer *buffer;\n\t \n\tstruct qeth_buffer_pool_entry *pool_entry;\n\tstruct sk_buff *rx_skb;\n};\n\nstruct qeth_qdio_q {\n\tstruct qdio_buffer *qdio_bufs[QDIO_MAX_BUFFERS_PER_Q];\n\tstruct qeth_qdio_buffer bufs[QDIO_MAX_BUFFERS_PER_Q];\n\tint next_buf_to_init;\n};\n\nenum qeth_qdio_out_buffer_state {\n\t \n\tQETH_QDIO_BUF_EMPTY,\n\t \n\tQETH_QDIO_BUF_PRIMED,\n};\n\nenum qeth_qaob_state {\n\tQETH_QAOB_ISSUED,\n\tQETH_QAOB_PENDING,\n\tQETH_QAOB_DONE,\n};\n\nstruct qeth_qaob_priv1 {\n\tunsigned int state;\n\tu8 queue_no;\n};\n\nstruct qeth_qdio_out_buffer {\n\tstruct qdio_buffer *buffer;\n\tatomic_t state;\n\tint next_element_to_fill;\n\tunsigned int frames;\n\tunsigned int bytes;\n\tstruct sk_buff_head skb_list;\n\tDECLARE_BITMAP(from_kmem_cache, QDIO_MAX_ELEMENTS_PER_BUFFER);\n\n\tstruct list_head list_entry;\n\tstruct qaob *aob;\n};\n\nstruct qeth_card;\n\n#define QETH_CARD_STAT_ADD(_c, _stat, _val)\t((_c)->stats._stat += (_val))\n#define QETH_CARD_STAT_INC(_c, _stat)\t\tQETH_CARD_STAT_ADD(_c, _stat, 1)\n\n#define QETH_TXQ_STAT_ADD(_q, _stat, _val)\t((_q)->stats._stat += (_val))\n#define QETH_TXQ_STAT_INC(_q, _stat)\t\tQETH_TXQ_STAT_ADD(_q, _stat, 1)\n\nstruct qeth_card_stats {\n\tu64 rx_bufs;\n\tu64 rx_skb_csum;\n\tu64 rx_sg_skbs;\n\tu64 rx_sg_frags;\n\tu64 rx_sg_alloc_page;\n\n\tu64 rx_dropped_nomem;\n\tu64 rx_dropped_notsupp;\n\tu64 rx_dropped_runt;\n\n\t \n\tu64 rx_packets;\n\tu64 rx_bytes;\n\tu64 rx_multicast;\n\tu64 rx_length_errors;\n\tu64 rx_frame_errors;\n\tu64 rx_fifo_errors;\n};\n\nstruct qeth_out_q_stats {\n\tu64 bufs;\n\tu64 bufs_pack;\n\tu64 buf_elements;\n\tu64 skbs_pack;\n\tu64 skbs_sg;\n\tu64 skbs_csum;\n\tu64 skbs_tso;\n\tu64 skbs_linearized;\n\tu64 skbs_linearized_fail;\n\tu64 tso_bytes;\n\tu64 packing_mode_switch;\n\tu64 stopped;\n\tu64 doorbell;\n\tu64 coal_frames;\n\tu64 completion_irq;\n\tu64 completion_yield;\n\tu64 completion_timer;\n\n\t \n\tu64 tx_packets;\n\tu64 tx_bytes;\n\tu64 tx_errors;\n\tu64 tx_dropped;\n};\n\n#define QETH_TX_MAX_COALESCED_FRAMES\t1\n#define QETH_TX_COALESCE_USECS\t\t25\n#define QETH_TX_TIMER_USECS\t\t500\n\nstruct qeth_qdio_out_q {\n\tstruct qdio_buffer *qdio_bufs[QDIO_MAX_BUFFERS_PER_Q];\n\tstruct qeth_qdio_out_buffer *bufs[QDIO_MAX_BUFFERS_PER_Q];\n\tstruct list_head pending_bufs;\n\tstruct qeth_out_q_stats stats;\n\tspinlock_t lock;\n\tunsigned int priority;\n\tu8 next_buf_to_fill;\n\tu8 max_elements;\n\tu8 queue_no;\n\tu8 do_pack;\n\tstruct qeth_card *card;\n\t \n\tatomic_t used_buffers;\n\t \n\tatomic_t set_pci_flags_count;\n\tstruct napi_struct napi;\n\tstruct timer_list timer;\n\tstruct qeth_hdr *prev_hdr;\n\tunsigned int coalesced_frames;\n\tu8 bulk_start;\n\tu8 bulk_count;\n\tu8 bulk_max;\n\n\tunsigned int coalesce_usecs;\n\tunsigned int max_coalesced_frames;\n\tunsigned int rescan_usecs;\n};\n\n#define qeth_for_each_output_queue(card, q, i)\t\t\\\n\tfor (i = 0; i < card->qdio.no_out_queues &&\t\\\n\t\t    (q = card->qdio.out_qs[i]); i++)\n\n#define\tqeth_napi_to_out_queue(n) container_of(n, struct qeth_qdio_out_q, napi)\n\nstatic inline void qeth_tx_arm_timer(struct qeth_qdio_out_q *queue,\n\t\t\t\t     unsigned long usecs)\n{\n\ttimer_reduce(&queue->timer, usecs_to_jiffies(usecs) + jiffies);\n}\n\nstatic inline bool qeth_out_queue_is_full(struct qeth_qdio_out_q *queue)\n{\n\treturn atomic_read(&queue->used_buffers) >= QDIO_MAX_BUFFERS_PER_Q;\n}\n\nstatic inline bool qeth_out_queue_is_empty(struct qeth_qdio_out_q *queue)\n{\n\treturn atomic_read(&queue->used_buffers) == 0;\n}\n\nstruct qeth_qdio_info {\n\tatomic_t state;\n\t \n\tstruct qeth_qdio_q *in_q;\n\tstruct qeth_qdio_q *c_q;\n\tstruct qeth_qdio_buffer_pool in_buf_pool;\n\tstruct qeth_qdio_buffer_pool init_pool;\n\tint in_buf_size;\n\n\t \n\tunsigned int no_out_queues;\n\tstruct qeth_qdio_out_q *out_qs[QETH_MAX_OUT_QUEUES];\n\n\t \n\tint do_prio_queueing;\n\tint default_out_queue;\n};\n\n \nenum qeth_channel_states {\n\tCH_STATE_UP,\n\tCH_STATE_DOWN,\n\tCH_STATE_HALTED,\n\tCH_STATE_STOPPED,\n};\n \nenum qeth_card_states {\n\tCARD_STATE_DOWN,\n\tCARD_STATE_SOFTSETUP,\n};\n\n \nenum qeth_prot_versions {\n\tQETH_PROT_NONE = 0x0000,\n\tQETH_PROT_IPV4 = 0x0004,\n\tQETH_PROT_IPV6 = 0x0006,\n};\n\nenum qeth_cq {\n\tQETH_CQ_DISABLED = 0,\n\tQETH_CQ_ENABLED = 1,\n\tQETH_CQ_NOTAVAILABLE = 2,\n};\n\nstruct qeth_ipato {\n\tbool enabled;\n\tbool invert4;\n\tbool invert6;\n\tstruct list_head entries;\n};\n\nstruct qeth_channel {\n\tstruct ccw_device *ccwdev;\n\tstruct qeth_cmd_buffer *active_cmd;\n\tenum qeth_channel_states state;\n};\n\nstruct qeth_reply {\n\tint (*callback)(struct qeth_card *card, struct qeth_reply *reply,\n\t\t\tunsigned long data);\n\tvoid *param;\n};\n\nstruct qeth_cmd_buffer {\n\tstruct list_head list_entry;\n\tstruct completion done;\n\tspinlock_t lock;\n\tunsigned int length;\n\trefcount_t ref_count;\n\tstruct qeth_channel *channel;\n\tstruct qeth_reply reply;\n\tlong timeout;\n\tunsigned char *data;\n\tvoid (*finalize)(struct qeth_card *card, struct qeth_cmd_buffer *iob);\n\tbool (*match)(struct qeth_cmd_buffer *iob,\n\t\t      struct qeth_cmd_buffer *reply);\n\tvoid (*callback)(struct qeth_card *card, struct qeth_cmd_buffer *iob,\n\t\t\t unsigned int data_length);\n\tint rc;\n};\n\nstatic inline void qeth_get_cmd(struct qeth_cmd_buffer *iob)\n{\n\trefcount_inc(&iob->ref_count);\n}\n\nstatic inline struct qeth_ipa_cmd *__ipa_reply(struct qeth_cmd_buffer *iob)\n{\n\tif (!IS_IPA(iob->data))\n\t\treturn NULL;\n\n\treturn (struct qeth_ipa_cmd *) PDU_ENCAPSULATION(iob->data);\n}\n\nstatic inline struct qeth_ipa_cmd *__ipa_cmd(struct qeth_cmd_buffer *iob)\n{\n\treturn (struct qeth_ipa_cmd *)(iob->data + IPA_PDU_HEADER_SIZE);\n}\n\nstatic inline struct ccw1 *__ccw_from_cmd(struct qeth_cmd_buffer *iob)\n{\n\treturn (struct ccw1 *)(iob->data + ALIGN(iob->length, 8));\n}\n\n \nstruct qeth_token {\n\t__u32 issuer_rm_w;\n\t__u32 issuer_rm_r;\n\t__u32 cm_filter_w;\n\t__u32 cm_filter_r;\n\t__u32 cm_connection_w;\n\t__u32 cm_connection_r;\n\t__u32 ulp_filter_w;\n\t__u32 ulp_filter_r;\n\t__u32 ulp_connection_w;\n\t__u32 ulp_connection_r;\n};\n\nstruct qeth_seqno {\n\t__u32 trans_hdr;\n\t__u32 pdu_hdr;\n\t__u32 pdu_hdr_ack;\n\t__u16 ipa;\n};\n\nstruct qeth_card_blkt {\n\tint time_total;\n\tint inter_packet;\n\tint inter_packet_jumbo;\n};\n\nenum qeth_pnso_mode {\n\tQETH_PNSO_NONE,\n\tQETH_PNSO_BRIDGEPORT,\n\tQETH_PNSO_ADDR_INFO,\n};\n\nenum qeth_link_mode {\n\tQETH_LINK_MODE_UNKNOWN,\n\tQETH_LINK_MODE_FIBRE_SHORT,\n\tQETH_LINK_MODE_FIBRE_LONG,\n};\n\nstruct qeth_link_info {\n\tu32 speed;\n\tu8 duplex;\n\tu8 port;\n\tenum qeth_link_mode link_mode;\n};\n\n#define QETH_BROADCAST_WITH_ECHO    0x01\n#define QETH_BROADCAST_WITHOUT_ECHO 0x02\nstruct qeth_card_info {\n\tunsigned short unit_addr2;\n\tunsigned short cula;\n\t__u16 func_level;\n\tchar mcl_level[QETH_MCL_LENGTH + 1];\n\t \n\tu16 ddev_devno;\n\tu8 cssid;\n\tu8 iid;\n\tu8 ssid;\n\tu8 chpid;\n\tu16 chid;\n\tu8 ids_valid:1;  \n\tu8 dev_addr_is_registered:1;\n\tu8 promisc_mode:1;\n\tu8 use_v1_blkt:1;\n\tu8 is_vm_nic:1;\n\t \n\tu8 has_lp2lp_cso_v6;\n\tu8 has_lp2lp_cso_v4;\n\tenum qeth_pnso_mode pnso_mode;\n\tenum qeth_card_types type;\n\tenum qeth_link_types link_type;\n\tint broadcast_capable;\n\tbool layer_enforced;\n\tstruct qeth_card_blkt blkt;\n\t__u32 diagass_support;\n\t__u32 hwtrap;\n\tstruct qeth_link_info link_info;\n};\n\nenum qeth_discipline_id {\n\tQETH_DISCIPLINE_UNDETERMINED = -1,\n\tQETH_DISCIPLINE_LAYER3 = 0,\n\tQETH_DISCIPLINE_LAYER2 = 1,\n};\n\nstruct qeth_card_options {\n\tstruct qeth_ipa_caps ipa4;\n\tstruct qeth_ipa_caps ipa6;\n\tstruct qeth_routing_info route4;\n\tstruct qeth_routing_info route6;\n\tstruct qeth_ipa_caps adp;  \n\tstruct qeth_sbp_info sbp;  \n\tstruct qeth_vnicc_info vnicc;  \n\tenum qeth_discipline_id layer;\n\tenum qeth_ipa_isolation_modes isolation;\n\tint sniffer;\n\tenum qeth_cq cq;\n\tchar hsuid[9];\n};\n\n#define\tIS_LAYER2(card)\t((card)->options.layer == QETH_DISCIPLINE_LAYER2)\n#define\tIS_LAYER3(card)\t((card)->options.layer == QETH_DISCIPLINE_LAYER3)\n\n \nenum qeth_threads {\n\tQETH_RECOVER_THREAD = 1,\n};\n\nstruct qeth_discipline {\n\tint (*setup) (struct ccwgroup_device *);\n\tvoid (*remove) (struct ccwgroup_device *);\n\tint (*set_online)(struct qeth_card *card, bool carrier_ok);\n\tvoid (*set_offline)(struct qeth_card *card);\n\tint (*control_event_handler)(struct qeth_card *card,\n\t\t\t\t\tstruct qeth_ipa_cmd *cmd);\n};\n\nenum qeth_addr_disposition {\n\tQETH_DISP_ADDR_DELETE = 0,\n\tQETH_DISP_ADDR_DO_NOTHING = 1,\n\tQETH_DISP_ADDR_ADD = 2,\n};\n\nstruct qeth_rx {\n\tint b_count;\n\tint b_index;\n\tu8 buf_element;\n\tint e_offset;\n\tint qdio_err;\n\tu8 bufs_refill;\n};\n\nstruct qeth_switch_info {\n\t__u32 capabilities;\n\t__u32 settings;\n};\n\nstruct qeth_priv {\n\tunsigned int rx_copybreak;\n\tunsigned int tx_wanted_queues;\n\tu32 brport_hw_features;\n\tu32 brport_features;\n};\n\nstruct qeth_card {\n\tenum qeth_card_states state;\n\tspinlock_t lock;\n\tstruct ccwgroup_device *gdev;\n\tstruct qeth_cmd_buffer *read_cmd;\n\tstruct qeth_channel read;\n\tstruct qeth_channel write;\n\tstruct qeth_channel data;\n\n\tstruct net_device *dev;\n\tstruct dentry *debugfs;\n\tstruct qeth_card_stats stats;\n\tstruct qeth_card_info info;\n\tstruct qeth_token token;\n\tstruct qeth_seqno seqno;\n\tstruct qeth_card_options options;\n\n\tstruct workqueue_struct *event_wq;\n\tstruct workqueue_struct *cmd_wq;\n\twait_queue_head_t wait_q;\n\n\tstruct mutex ip_lock;\n\t \n\tDECLARE_HASHTABLE(ip_htable, 4);\n\tstruct qeth_ipato ipato;\n\n\tDECLARE_HASHTABLE(local_addrs4, 4);\n\tDECLARE_HASHTABLE(local_addrs6, 4);\n\tspinlock_t local_addrs4_lock;\n\tspinlock_t local_addrs6_lock;\n\tDECLARE_HASHTABLE(rx_mode_addrs, 4);\n\tstruct work_struct rx_mode_work;\n\tstruct work_struct kernel_thread_starter;\n\tspinlock_t thread_mask_lock;\n\tunsigned long thread_start_mask;\n\tunsigned long thread_allowed_mask;\n\tunsigned long thread_running_mask;\n\tstruct list_head cmd_waiter_list;\n\t \n\tstruct qeth_qdio_info qdio;\n\tint read_or_write_problem;\n\tconst struct qeth_discipline *discipline;\n\tatomic_t force_alloc_skb;\n\tstruct service_level qeth_service_level;\n\tstruct qdio_ssqd_desc ssqd;\n\tdebug_info_t *debug;\n\tstruct mutex sbp_lock;\n\tstruct mutex conf_mutex;\n\tstruct mutex discipline_mutex;\n\tstruct napi_struct napi;\n\tstruct qeth_rx rx;\n\tstruct delayed_work buffer_reclaim_work;\n};\n\nstatic inline bool qeth_card_hw_is_reachable(struct qeth_card *card)\n{\n\treturn card->state == CARD_STATE_SOFTSETUP;\n}\n\nstatic inline bool qeth_use_tx_irqs(struct qeth_card *card)\n{\n\treturn !IS_IQD(card);\n}\n\nstatic inline void qeth_unlock_channel(struct qeth_card *card,\n\t\t\t\t       struct qeth_channel *channel)\n{\n\txchg(&channel->active_cmd, NULL);\n\twake_up(&card->wait_q);\n}\n\nstatic inline bool qeth_trylock_channel(struct qeth_channel *channel,\n\t\t\t\t\tstruct qeth_cmd_buffer *cmd)\n{\n\treturn cmpxchg(&channel->active_cmd, NULL, cmd) == NULL;\n}\n\nstruct qeth_trap_id {\n\t__u16 lparnr;\n\tchar vmname[8];\n\t__u8 chpid;\n\t__u8 ssid;\n\t__u16 devno;\n} __packed;\n\nstatic inline bool qeth_uses_tx_prio_queueing(struct qeth_card *card)\n{\n\treturn card->qdio.do_prio_queueing != QETH_NO_PRIO_QUEUEING;\n}\n\nstatic inline unsigned int qeth_tx_actual_queues(struct qeth_card *card)\n{\n\tstruct qeth_priv *priv = netdev_priv(card->dev);\n\n\tif (qeth_uses_tx_prio_queueing(card))\n\t\treturn min(card->dev->num_tx_queues, card->qdio.no_out_queues);\n\n\treturn min(priv->tx_wanted_queues, card->qdio.no_out_queues);\n}\n\nstatic inline u16 qeth_iqd_translate_txq(struct net_device *dev, u16 txq)\n{\n\tif (txq == QETH_IQD_MCAST_TXQ)\n\t\treturn dev->num_tx_queues - 1;\n\tif (txq == dev->num_tx_queues - 1)\n\t\treturn QETH_IQD_MCAST_TXQ;\n\treturn txq;\n}\n\nstatic inline bool qeth_iqd_is_mcast_queue(struct qeth_card *card,\n\t\t\t\t\t   struct qeth_qdio_out_q *queue)\n{\n\treturn qeth_iqd_translate_txq(card->dev, queue->queue_no) ==\n\t       QETH_IQD_MCAST_TXQ;\n}\n\nstatic inline void qeth_scrub_qdio_buffer(struct qdio_buffer *buf,\n\t\t\t\t\t  unsigned int elements)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < elements; i++)\n\t\tmemset(&buf->element[i], 0, sizeof(struct qdio_buffer_element));\n\tbuf->element[14].sflags = 0;\n\tbuf->element[15].sflags = 0;\n}\n\n \nstatic inline int qeth_get_elements_for_range(addr_t start, addr_t end)\n{\n\treturn PFN_UP(end) - PFN_DOWN(start);\n}\n\nstatic inline int qeth_get_ether_cast_type(struct sk_buff *skb)\n{\n\tu8 *addr = eth_hdr(skb)->h_dest;\n\n\tif (is_multicast_ether_addr(addr))\n\t\treturn is_broadcast_ether_addr(addr) ? RTN_BROADCAST :\n\t\t\t\t\t\t       RTN_MULTICAST;\n\treturn RTN_UNICAST;\n}\n\nstatic inline struct dst_entry *qeth_dst_check_rcu(struct sk_buff *skb,\n\t\t\t\t\t\t   __be16 proto)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct rt6_info *rt;\n\n\trt = (struct rt6_info *) dst;\n\tif (dst) {\n\t\tif (proto == htons(ETH_P_IPV6))\n\t\t\tdst = dst_check(dst, rt6_get_cookie(rt));\n\t\telse\n\t\t\tdst = dst_check(dst, 0);\n\t}\n\n\treturn dst;\n}\n\nstatic inline __be32 qeth_next_hop_v4_rcu(struct sk_buff *skb,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct rtable *rt = (struct rtable *) dst;\n\n\treturn (rt) ? rt_nexthop(rt, ip_hdr(skb)->daddr) : ip_hdr(skb)->daddr;\n}\n\nstatic inline struct in6_addr *qeth_next_hop_v6_rcu(struct sk_buff *skb,\n\t\t\t\t\t\t    struct dst_entry *dst)\n{\n\tstruct rt6_info *rt = (struct rt6_info *) dst;\n\n\tif (rt && !ipv6_addr_any(&rt->rt6i_gateway))\n\t\treturn &rt->rt6i_gateway;\n\telse\n\t\treturn &ipv6_hdr(skb)->daddr;\n}\n\nstatic inline void qeth_tx_csum(struct sk_buff *skb, u8 *flags, __be16 proto)\n{\n\t*flags |= QETH_HDR_EXT_CSUM_TRANSP_REQ;\n\tif ((proto == htons(ETH_P_IP) && ip_hdr(skb)->protocol == IPPROTO_UDP) ||\n\t    (proto == htons(ETH_P_IPV6) && ipv6_hdr(skb)->nexthdr == IPPROTO_UDP))\n\t\t*flags |= QETH_HDR_EXT_UDP;\n}\n\nstatic inline void qeth_put_buffer_pool_entry(struct qeth_card *card,\n\t\tstruct qeth_buffer_pool_entry *entry)\n{\n\tlist_add_tail(&entry->list, &card->qdio.in_buf_pool.entry_list);\n}\n\nstatic inline int qeth_is_diagass_supported(struct qeth_card *card,\n\t\tenum qeth_diags_cmds cmd)\n{\n\treturn card->info.diagass_support & (__u32)cmd;\n}\n\nint qeth_send_simple_setassparms_prot(struct qeth_card *card,\n\t\t\t\t      enum qeth_ipa_funcs ipa_func,\n\t\t\t\t      u16 cmd_code, u32 *data,\n\t\t\t\t      enum qeth_prot_versions prot);\n \nstatic inline int qeth_send_simple_setassparms(struct qeth_card *card,\n\t\t\t\t\t       enum qeth_ipa_funcs ipa_func,\n\t\t\t\t\t       u16 cmd_code, u32 *data)\n{\n\treturn qeth_send_simple_setassparms_prot(card, ipa_func, cmd_code,\n\t\t\t\t\t\t data, QETH_PROT_IPV4);\n}\n\nstatic inline int qeth_send_simple_setassparms_v6(struct qeth_card *card,\n\t\t\t\t\t\t  enum qeth_ipa_funcs ipa_func,\n\t\t\t\t\t\t  u16 cmd_code, u32 *data)\n{\n\treturn qeth_send_simple_setassparms_prot(card, ipa_func, cmd_code,\n\t\t\t\t\t\t data, QETH_PROT_IPV6);\n}\n\nextern const struct qeth_discipline qeth_l2_discipline;\nextern const struct qeth_discipline qeth_l3_discipline;\nextern const struct ethtool_ops qeth_ethtool_ops;\nextern const struct attribute_group *qeth_dev_groups[];\n\nconst char *qeth_get_cardname_short(struct qeth_card *);\nint qeth_resize_buffer_pool(struct qeth_card *card, unsigned int count);\nint qeth_setup_discipline(struct qeth_card *card, enum qeth_discipline_id disc);\nvoid qeth_remove_discipline(struct qeth_card *card);\n\n \nextern struct qeth_dbf_info qeth_dbf[QETH_DBF_INFOS];\n\nstruct net_device *qeth_clone_netdev(struct net_device *orig);\nvoid qeth_set_allowed_threads(struct qeth_card *card, unsigned long threads,\n\t\t\t      int clear_start_mask);\nint qeth_threads_running(struct qeth_card *, unsigned long);\nint qeth_set_offline(struct qeth_card *card, const struct qeth_discipline *disc,\n\t\t     bool resetting);\n\nint qeth_send_ipa_cmd(struct qeth_card *, struct qeth_cmd_buffer *,\n\t\t  int (*reply_cb)\n\t\t  (struct qeth_card *, struct qeth_reply *, unsigned long),\n\t\t  void *);\nstruct qeth_cmd_buffer *qeth_ipa_alloc_cmd(struct qeth_card *card,\n\t\t\t\t\t   enum qeth_ipa_cmds cmd_code,\n\t\t\t\t\t   enum qeth_prot_versions prot,\n\t\t\t\t\t   unsigned int data_length);\nstruct qeth_cmd_buffer *qeth_get_setassparms_cmd(struct qeth_card *card,\n\t\t\t\t\t\t enum qeth_ipa_funcs ipa_func,\n\t\t\t\t\t\t u16 cmd_code,\n\t\t\t\t\t\t unsigned int data_length,\n\t\t\t\t\t\t enum qeth_prot_versions prot);\nstruct qeth_cmd_buffer *qeth_get_diag_cmd(struct qeth_card *card,\n\t\t\t\t\t  enum qeth_diags_cmds sub_cmd,\n\t\t\t\t\t  unsigned int data_length);\n\nint qeth_schedule_recovery(struct qeth_card *card);\nint qeth_poll(struct napi_struct *napi, int budget);\nvoid qeth_setadp_promisc_mode(struct qeth_card *card, bool enable);\nint qeth_setadpparms_change_macaddr(struct qeth_card *);\nvoid qeth_tx_timeout(struct net_device *, unsigned int txqueue);\nint qeth_query_switch_attributes(struct qeth_card *card,\n\t\t\t\t  struct qeth_switch_info *sw_info);\nint qeth_query_card_info(struct qeth_card *card,\n\t\t\t struct qeth_link_info *link_info);\nint qeth_setadpparms_set_access_ctrl(struct qeth_card *card,\n\t\t\t\t     enum qeth_ipa_isolation_modes mode);\n\nint qeth_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nint qeth_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\tvoid __user *data, int cmd);\n__printf(3, 4)\nvoid qeth_dbf_longtext(debug_info_t *id, int level, char *text, ...);\nint qeth_configure_cq(struct qeth_card *, enum qeth_cq);\nint qeth_hw_trap(struct qeth_card *, enum qeth_diags_trap_action);\nint qeth_setassparms_cb(struct qeth_card *, struct qeth_reply *, unsigned long);\nint qeth_set_features(struct net_device *, netdev_features_t);\nvoid qeth_enable_hw_features(struct net_device *dev);\nnetdev_features_t qeth_fix_features(struct net_device *, netdev_features_t);\nnetdev_features_t qeth_features_check(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      netdev_features_t features);\nvoid qeth_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats);\nint qeth_set_real_num_tx_queues(struct qeth_card *card, unsigned int count);\nu16 qeth_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t  u8 cast_type, struct net_device *sb_dev);\nu16 qeth_osa_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t  struct net_device *sb_dev);\nint qeth_open(struct net_device *dev);\nint qeth_stop(struct net_device *dev);\n\nint qeth_vm_request_mac(struct qeth_card *card);\nint qeth_xmit(struct qeth_card *card, struct sk_buff *skb,\n\t      struct qeth_qdio_out_q *queue, __be16 proto,\n\t      void (*fill_header)(struct qeth_qdio_out_q *queue,\n\t\t\t\t  struct qeth_hdr *hdr, struct sk_buff *skb,\n\t\t\t\t  __be16 proto, unsigned int data_len));\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}