{
  "module_name": "ctcm_sysfs.c",
  "hash_id": "0b48d7cf2525fd4f16aded9aaa7c5c098f0da0a61fd6fed5397d444eac7feece",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/net/ctcm_sysfs.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n#undef DEBUGDATA\n#undef DEBUGCCW\n\n#define KMSG_COMPONENT \"ctcm\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include \"ctcm_main.h\"\n\n \n\nstatic ssize_t ctcm_buffer_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ctcm_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\treturn sysfs_emit(buf, \"%d\\n\", priv->buffer_size);\n}\n\nstatic ssize_t ctcm_buffer_write(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct net_device *ndev;\n\tunsigned int bs1;\n\tstruct ctcm_priv *priv = dev_get_drvdata(dev);\n\tint rc;\n\n\tif (!(priv && priv->channel[CTCM_READ] &&\n\t      priv->channel[CTCM_READ]->netdev)) {\n\t\tCTCM_DBF_TEXT(SETUP, CTC_DBF_ERROR, \"bfnondev\");\n\t\treturn -ENODEV;\n\t}\n\tndev = priv->channel[CTCM_READ]->netdev;\n\n\trc = kstrtouint(buf, 0, &bs1);\n\tif (rc)\n\t\tgoto einval;\n\tif (bs1 > CTCM_BUFSIZE_LIMIT)\n\t\t\t\t\tgoto einval;\n\tif (bs1 < (576 + LL_HEADER_LENGTH + 2))\n\t\t\t\t\tgoto einval;\n\tpriv->buffer_size = bs1;\t \n\n\tif ((ndev->flags & IFF_RUNNING) &&\n\t    (bs1 < (ndev->mtu + LL_HEADER_LENGTH + 2)))\n\t\t\t\t\tgoto einval;\n\n\tpriv->channel[CTCM_READ]->max_bufsize = bs1;\n\tpriv->channel[CTCM_WRITE]->max_bufsize = bs1;\n\tif (!(ndev->flags & IFF_RUNNING))\n\t\tndev->mtu = bs1 - LL_HEADER_LENGTH - 2;\n\tpriv->channel[CTCM_READ]->flags |= CHANNEL_FLAGS_BUFSIZE_CHANGED;\n\tpriv->channel[CTCM_WRITE]->flags |= CHANNEL_FLAGS_BUFSIZE_CHANGED;\n\n\tCTCM_DBF_DEV(SETUP, ndev, buf);\n\treturn count;\n\neinval:\n\tCTCM_DBF_DEV(SETUP, ndev, \"buff_err\");\n\treturn -EINVAL;\n}\n\nstatic void ctcm_print_statistics(struct ctcm_priv *priv)\n{\n\tchar *sbuf;\n\tchar *p;\n\n\tif (!priv)\n\t\treturn;\n\tsbuf = kmalloc(2048, GFP_KERNEL);\n\tif (sbuf == NULL)\n\t\treturn;\n\tp = sbuf;\n\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  Device FSM state: %s\\n\",\n\t\t       fsm_getstate_str(priv->fsm));\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  RX channel FSM state: %s\\n\",\n\t\t       fsm_getstate_str(priv->channel[CTCM_READ]->fsm));\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  TX channel FSM state: %s\\n\",\n\t\t       fsm_getstate_str(priv->channel[CTCM_WRITE]->fsm));\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  Max. TX buffer used: %ld\\n\",\n\t\t       priv->channel[WRITE]->prof.maxmulti);\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  Max. chained SKBs: %ld\\n\",\n\t\t       priv->channel[WRITE]->prof.maxcqueue);\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  TX single write ops: %ld\\n\",\n\t\t       priv->channel[WRITE]->prof.doios_single);\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  TX multi write ops: %ld\\n\",\n\t\t       priv->channel[WRITE]->prof.doios_multi);\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  Netto bytes written: %ld\\n\",\n\t\t       priv->channel[WRITE]->prof.txlen);\n\tp += scnprintf(p, CTCM_STATSIZE_LIMIT, \"  Max. TX IO-time: %u\\n\",\n\t\t       jiffies_to_usecs(priv->channel[WRITE]->prof.tx_time));\n\n\tprintk(KERN_INFO \"Statistics for %s:\\n%s\",\n\t\t\t\tpriv->channel[CTCM_WRITE]->netdev->name, sbuf);\n\tkfree(sbuf);\n\treturn;\n}\n\nstatic ssize_t stats_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\n\tstruct ctcm_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv || gdev->state != CCWGROUP_ONLINE)\n\t\treturn -ENODEV;\n\tctcm_print_statistics(priv);\n\treturn sysfs_emit(buf, \"0\\n\");\n}\n\nstatic ssize_t stats_write(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ctcm_priv *priv = dev_get_drvdata(dev);\n\tif (!priv)\n\t\treturn -ENODEV;\n\t \n\tmemset(&priv->channel[WRITE]->prof, 0,\n\t\t\t\tsizeof(priv->channel[CTCM_WRITE]->prof));\n\treturn count;\n}\n\nstatic ssize_t ctcm_proto_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ctcm_priv *priv = dev_get_drvdata(dev);\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\treturn sysfs_emit(buf, \"%d\\n\", priv->protocol);\n}\n\nstatic ssize_t ctcm_proto_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tint value, rc;\n\tstruct ctcm_priv *priv = dev_get_drvdata(dev);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\trc = kstrtoint(buf, 0, &value);\n\tif (rc ||\n\t    !((value == CTCM_PROTO_S390)  ||\n\t      (value == CTCM_PROTO_LINUX) ||\n\t      (value == CTCM_PROTO_MPC) ||\n\t      (value == CTCM_PROTO_OS390)))\n\t\treturn -EINVAL;\n\tpriv->protocol = value;\n\tCTCM_DBF_DEV(SETUP, dev, buf);\n\n\treturn count;\n}\n\nstatic const char *ctcm_type[] = {\n\t\"not a channel\",\n\t\"CTC/A\",\n\t\"FICON channel\",\n\t\"ESCON channel\",\n\t\"unknown channel type\",\n\t\"unsupported channel type\",\n};\n\nstatic ssize_t ctcm_type_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ccwgroup_device *cgdev;\n\n\tcgdev = to_ccwgroupdev(dev);\n\tif (!cgdev)\n\t\treturn -ENODEV;\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  ctcm_type[cgdev->cdev[0]->id.driver_info]);\n}\n\nstatic DEVICE_ATTR(buffer, 0644, ctcm_buffer_show, ctcm_buffer_write);\nstatic DEVICE_ATTR(protocol, 0644, ctcm_proto_show, ctcm_proto_store);\nstatic DEVICE_ATTR(type, 0444, ctcm_type_show, NULL);\nstatic DEVICE_ATTR(stats, 0644, stats_show, stats_write);\n\nstatic struct attribute *ctcm_attr[] = {\n\t&dev_attr_protocol.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_buffer.attr,\n\t&dev_attr_stats.attr,\n\tNULL,\n};\n\nstatic struct attribute_group ctcm_attr_group = {\n\t.attrs = ctcm_attr,\n};\nconst struct attribute_group *ctcm_attr_groups[] = {\n\t&ctcm_attr_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}