{
  "module_name": "tape.h",
  "hash_id": "aa206838f33a287b9848c09f3b7ad999e81c96764edbf2bad5bdb89180bcffd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/tape.h",
  "human_readable_source": " \n \n\n#ifndef _TAPE_H\n#define _TAPE_H\n\n#include <asm/ccwdev.h>\n#include <asm/debug.h>\n#include <asm/idals.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtio.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n\nstruct gendisk;\n\n \n#define DBF_LIKE_HELL\n#ifdef  DBF_LIKE_HELL\n#define DBF_LH(level, str, ...) \\\ndo { \\\n\tdebug_sprintf_event(TAPE_DBF_AREA, level, str, ## __VA_ARGS__); \\\n} while (0)\n#else\n#define DBF_LH(level, str, ...) do {} while(0)\n#endif\n\n \n#define DBF_EVENT(d_level, d_str...) \\\ndo { \\\n\tdebug_sprintf_event(TAPE_DBF_AREA, d_level, d_str); \\\n} while (0)\n\n#define DBF_EXCEPTION(d_level, d_str...) \\\ndo { \\\n\tdebug_sprintf_exception(TAPE_DBF_AREA, d_level, d_str); \\\n} while (0)\n\n#define TAPE_VERSION_MAJOR 2\n#define TAPE_VERSION_MINOR 0\n#define TAPE_MAGIC \"tape\"\n\n#define TAPE_MINORS_PER_DEV 2\t     \n#define TAPEBLOCK_HSEC_SIZE\t2048\n#define TAPEBLOCK_HSEC_S2B\t2\n#define TAPEBLOCK_RETRIES\t5\n\nenum tape_medium_state {\n\tMS_UNKNOWN,\n\tMS_LOADED,\n\tMS_UNLOADED,\n\tMS_SIZE\n};\n\nenum tape_state {\n\tTS_UNUSED=0,\n\tTS_IN_USE,\n\tTS_BLKUSE,\n\tTS_INIT,\n\tTS_NOT_OPER,\n\tTS_SIZE\n};\n\nenum tape_op {\n\tTO_BLOCK,\t \n\tTO_BSB,\t\t \n\tTO_BSF,\t\t \n\tTO_DSE,\t\t \n\tTO_FSB,\t\t \n\tTO_FSF,\t\t \n\tTO_LBL,\t\t \n\tTO_NOP,\t\t \n\tTO_RBA,\t\t \n\tTO_RBI,\t\t \n\tTO_RFO,\t\t \n\tTO_REW,\t\t \n\tTO_RUN,\t\t \n\tTO_WRI,\t\t \n\tTO_WTM,\t\t \n\tTO_MSEN,\t \n\tTO_LOAD,\t \n\tTO_READ_CONFIG,  \n\tTO_READ_ATTMSG,  \n\tTO_DIS,\t\t \n\tTO_ASSIGN,\t \n\tTO_UNASSIGN,\t \n\tTO_CRYPT_ON,\t \n\tTO_CRYPT_OFF,\t \n\tTO_KEKL_SET,\t \n\tTO_KEKL_QUERY,\t \n\tTO_RDC,\t\t \n\tTO_SIZE,\t \n};\n\n \nstruct tape_device;\n\n \nenum tape_request_status {\n\tTAPE_REQUEST_INIT,\t \n\tTAPE_REQUEST_QUEUED,\t \n\tTAPE_REQUEST_IN_IO,\t \n\tTAPE_REQUEST_DONE,\t \n\tTAPE_REQUEST_CANCEL,\t \n\tTAPE_REQUEST_LONG_BUSY,  \n};\n\n \nstruct tape_request {\n\tstruct list_head list;\t\t \n\tstruct tape_device *device;\t \n\tstruct ccw1 *cpaddr;\t\t \n\tvoid *cpdata;\t\t\t \n\tenum tape_request_status status; \n\tint options;\t\t\t \n\tint retries;\t\t\t \n\tint rescnt;\t\t\t \n\tstruct timer_list timer;\t \n\n\t \n\tvoid (*callback)(struct tape_request *, void *);\n\tvoid *callback_data;\n\n\tenum tape_op op;\n\tint rc;\n};\n\n \ntypedef int (*tape_mtop_fn)(struct tape_device *, int);\n\n \n#define TAPE_NR_MTOPS (MTMKPART+1)\n\n \nstruct tape_discipline {\n\tstruct module *owner;\n\tint  (*setup_device)(struct tape_device *);\n\tvoid (*cleanup_device)(struct tape_device *);\n\tint (*irq)(struct tape_device *, struct tape_request *, struct irb *);\n\tstruct tape_request *(*read_block)(struct tape_device *, size_t);\n\tstruct tape_request *(*write_block)(struct tape_device *, size_t);\n\tvoid (*process_eov)(struct tape_device*);\n\t \n\tint (*ioctl_fn)(struct tape_device *, unsigned int, unsigned long);\n\t \n\ttape_mtop_fn *mtop_array;\n};\n\n \n#define TAPE_IO_SUCCESS\t\t0\t \n#define TAPE_IO_PENDING\t\t1\t \n#define TAPE_IO_RETRY\t\t2\t \n#define TAPE_IO_STOP\t\t3\t \n#define TAPE_IO_LONG_BUSY\t4\t \n\n \nstruct tape_char_data {\n\tstruct idal_buffer *idal_buf;\t \n\tint block_size;\t\t\t \n};\n\n \nstruct tape_device {\n\t \n\tstruct list_head\t\tnode;\n\n\tint\t\t\t\tcdev_id;\n\tstruct ccw_device *\t\tcdev;\n\tstruct tape_class_device *\tnt;\n\tstruct tape_class_device *\trt;\n\n\t \n\tstruct mutex\t\t\tmutex;\n\n\t \n\tstruct tape_discipline *\tdiscipline;\n\tvoid *\t\t\t\tdiscdata;\n\n\t \n\tlong\t\t\t\ttape_generic_status;\n\n\t \n\twait_queue_head_t\t\tstate_change_wq;\n\tenum tape_state\t\t\ttape_state;\n\tenum tape_medium_state\t\tmedium_state;\n\tunsigned char *\t\t\tmodeset_byte;\n\n\t \n\tatomic_t\t\t\tref_count;\n\n\t \n\tstruct list_head\t\treq_queue;\n\n\t \n\twait_queue_head_t\t\twait_queue;\n\n\t \n\tint\t\t\t\tfirst_minor;\n\n\t \n\tint\t\t\t\trequired_tapemarks;\n\n\t \n\tunsigned int\t\t\tbof;\n\n\t \n\tstruct tape_char_data\t\tchar_data;\n\n\t \n\tstruct delayed_work\t\ttape_dnr;\n\n\t \n\tstruct timer_list\t\tlb_timeout;\n\n};\n\n \nextern struct tape_request *tape_alloc_request(int cplength, int datasize);\nextern void tape_free_request(struct tape_request *);\nextern int tape_do_io(struct tape_device *, struct tape_request *);\nextern int tape_do_io_async(struct tape_device *, struct tape_request *);\nextern int tape_do_io_interruptible(struct tape_device *, struct tape_request *);\nextern int tape_cancel_io(struct tape_device *, struct tape_request *);\n\nstatic inline int\ntape_do_io_free(struct tape_device *device, struct tape_request *request)\n{\n\tint rc;\n\n\trc = tape_do_io(device, request);\n\ttape_free_request(request);\n\treturn rc;\n}\n\nstatic inline void\ntape_do_io_async_free(struct tape_device *device, struct tape_request *request)\n{\n\trequest->callback = (void *) tape_free_request;\n\trequest->callback_data = NULL;\n\ttape_do_io_async(device, request);\n}\n\nextern int tape_open(struct tape_device *);\nextern int tape_release(struct tape_device *);\nextern int tape_mtop(struct tape_device *, int, int);\nextern void tape_state_set(struct tape_device *, enum tape_state);\n\nextern int tape_generic_online(struct tape_device *, struct tape_discipline *);\nextern int tape_generic_offline(struct ccw_device *);\n\n \nextern int tape_generic_probe(struct ccw_device *);\nextern void tape_generic_remove(struct ccw_device *);\n\nextern struct tape_device *tape_find_device(int devindex);\nextern struct tape_device *tape_get_device(struct tape_device *);\nextern void tape_put_device(struct tape_device *);\n\n \nextern int tapechar_init(void);\nextern void tapechar_exit(void);\nextern int  tapechar_setup_device(struct tape_device *);\nextern void tapechar_cleanup_device(struct tape_device *);\n\n \n#ifdef CONFIG_PROC_FS\nextern void tape_proc_init (void);\nextern void tape_proc_cleanup (void);\n#else\nstatic inline void tape_proc_init (void) {;}\nstatic inline void tape_proc_cleanup (void) {;}\n#endif\n\n \nextern void tape_dump_sense_dbf(struct tape_device *, struct tape_request *,\n\t\t\t\tstruct irb *);\n\n \nextern void tape_med_state_set(struct tape_device *, enum tape_medium_state);\n\n \nextern debug_info_t *TAPE_DBF_AREA;\n\n \nstatic inline struct ccw1 *\ntape_ccw_cc(struct ccw1 *ccw, __u8 cmd_code, __u16 memsize, void *cda)\n{\n\tccw->cmd_code = cmd_code;\n\tccw->flags = CCW_FLAG_CC;\n\tccw->count = memsize;\n\tccw->cda = (__u32)(addr_t) cda;\n\treturn ccw + 1;\n}\n\nstatic inline struct ccw1 *\ntape_ccw_end(struct ccw1 *ccw, __u8 cmd_code, __u16 memsize, void *cda)\n{\n\tccw->cmd_code = cmd_code;\n\tccw->flags = 0;\n\tccw->count = memsize;\n\tccw->cda = (__u32)(addr_t) cda;\n\treturn ccw + 1;\n}\n\nstatic inline struct ccw1 *\ntape_ccw_cmd(struct ccw1 *ccw, __u8 cmd_code)\n{\n\tccw->cmd_code = cmd_code;\n\tccw->flags = 0;\n\tccw->count = 0;\n\tccw->cda = (__u32)(addr_t) &ccw->cmd_code;\n\treturn ccw + 1;\n}\n\nstatic inline struct ccw1 *\ntape_ccw_repeat(struct ccw1 *ccw, __u8 cmd_code, int count)\n{\n\twhile (count-- > 0) {\n\t\tccw->cmd_code = cmd_code;\n\t\tccw->flags = CCW_FLAG_CC;\n\t\tccw->count = 0;\n\t\tccw->cda = (__u32)(addr_t) &ccw->cmd_code;\n\t\tccw++;\n\t}\n\treturn ccw;\n}\n\nstatic inline struct ccw1 *\ntape_ccw_cc_idal(struct ccw1 *ccw, __u8 cmd_code, struct idal_buffer *idal)\n{\n\tccw->cmd_code = cmd_code;\n\tccw->flags    = CCW_FLAG_CC;\n\tidal_buffer_set_cda(idal, ccw);\n\treturn ccw++;\n}\n\nstatic inline struct ccw1 *\ntape_ccw_end_idal(struct ccw1 *ccw, __u8 cmd_code, struct idal_buffer *idal)\n{\n\tccw->cmd_code = cmd_code;\n\tccw->flags    = 0;\n\tidal_buffer_set_cda(idal, ccw);\n\treturn ccw++;\n}\n\n \nextern const char *tape_state_verbose[];\nextern const char *tape_op_verbose[];\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}