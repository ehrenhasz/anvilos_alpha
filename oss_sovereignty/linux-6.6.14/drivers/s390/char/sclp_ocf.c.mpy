{
  "module_name": "sclp_ocf.c",
  "hash_id": "9a4a63f8ebe751729986ecac9efc4e0e0dd786c88d31033fd6ca701ffdee842e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_ocf.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"sclp_ocf\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/kmod.h>\n#include <linux/timer.h>\n#include <linux/err.h>\n#include <asm/ebcdic.h>\n#include <asm/sclp.h>\n\n#include \"sclp.h\"\n\n#define OCF_LENGTH_HMC_NETWORK 8UL\n#define OCF_LENGTH_CPC_NAME 8UL\n\nstatic char hmc_network[OCF_LENGTH_HMC_NETWORK + 1];\nstatic char cpc_name[OCF_LENGTH_CPC_NAME];  \n\nstatic DEFINE_SPINLOCK(sclp_ocf_lock);\nstatic struct work_struct sclp_ocf_change_work;\n\nstatic struct kset *ocf_kset;\n\nstatic void sclp_ocf_change_notify(struct work_struct *work)\n{\n\tkobject_uevent(&ocf_kset->kobj, KOBJ_CHANGE);\n}\n\n \nstatic void sclp_ocf_handler(struct evbuf_header *evbuf)\n{\n\tstruct gds_vector *v;\n\tstruct gds_subvector *sv, *netid, *cpc;\n\tsize_t size;\n\n\t \n\tv = sclp_find_gds_vector(evbuf + 1, (void *) evbuf + evbuf->length,\n\t\t\t\t 0x9f00);\n\tif (!v)\n\t\treturn;\n\t \n\tv = sclp_find_gds_vector(v + 1, (void *) v + v->length, 0x9f22);\n\tif (!v)\n\t\treturn;\n\t \n\tsv = sclp_find_gds_subvector(v + 1, (void *) v + v->length, 0x81);\n\tif (!sv)\n\t\treturn;\n\t \n\tnetid = sclp_find_gds_subvector(sv + 1, (void *) sv + sv->length, 1);\n\t \n\tcpc = sclp_find_gds_subvector(sv + 1, (void *) sv + sv->length, 2);\n\t \n\tspin_lock(&sclp_ocf_lock);\n\tif (netid) {\n\t\tsize = min(OCF_LENGTH_HMC_NETWORK, (size_t) netid->length);\n\t\tmemcpy(hmc_network, netid + 1, size);\n\t\tEBCASC(hmc_network, size);\n\t\thmc_network[size] = 0;\n\t}\n\tif (cpc) {\n\t\tsize = min(OCF_LENGTH_CPC_NAME, (size_t) cpc->length);\n\t\tmemset(cpc_name, 0, OCF_LENGTH_CPC_NAME);\n\t\tmemcpy(cpc_name, cpc + 1, size);\n\t}\n\tspin_unlock(&sclp_ocf_lock);\n\tschedule_work(&sclp_ocf_change_work);\n}\n\nstatic struct sclp_register sclp_ocf_event = {\n\t.receive_mask = EVTYP_OCF_MASK,\n\t.receiver_fn = sclp_ocf_handler,\n};\n\nvoid sclp_ocf_cpc_name_copy(char *dst)\n{\n\tspin_lock_irq(&sclp_ocf_lock);\n\tmemcpy(dst, cpc_name, OCF_LENGTH_CPC_NAME);\n\tspin_unlock_irq(&sclp_ocf_lock);\n}\nEXPORT_SYMBOL(sclp_ocf_cpc_name_copy);\n\nstatic ssize_t cpc_name_show(struct kobject *kobj,\n\t\t\t     struct kobj_attribute *attr, char *page)\n{\n\tchar name[OCF_LENGTH_CPC_NAME + 1];\n\n\tsclp_ocf_cpc_name_copy(name);\n\tname[OCF_LENGTH_CPC_NAME] = 0;\n\tEBCASC(name, OCF_LENGTH_CPC_NAME);\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", name);\n}\n\nstatic struct kobj_attribute cpc_name_attr =\n\t__ATTR(cpc_name, 0444, cpc_name_show, NULL);\n\nstatic ssize_t hmc_network_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *page)\n{\n\tint rc;\n\n\tspin_lock_irq(&sclp_ocf_lock);\n\trc = snprintf(page, PAGE_SIZE, \"%s\\n\", hmc_network);\n\tspin_unlock_irq(&sclp_ocf_lock);\n\treturn rc;\n}\n\nstatic struct kobj_attribute hmc_network_attr =\n\t__ATTR(hmc_network, 0444, hmc_network_show, NULL);\n\nstatic struct attribute *ocf_attrs[] = {\n\t&cpc_name_attr.attr,\n\t&hmc_network_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ocf_attr_group = {\n\t.attrs = ocf_attrs,\n};\n\nstatic int __init ocf_init(void)\n{\n\tint rc;\n\n\tINIT_WORK(&sclp_ocf_change_work, sclp_ocf_change_notify);\n\tocf_kset = kset_create_and_add(\"ocf\", NULL, firmware_kobj);\n\tif (!ocf_kset)\n\t\treturn -ENOMEM;\n\n\trc = sysfs_create_group(&ocf_kset->kobj, &ocf_attr_group);\n\tif (rc) {\n\t\tkset_unregister(ocf_kset);\n\t\treturn rc;\n\t}\n\n\treturn sclp_register(&sclp_ocf_event);\n}\n\ndevice_initcall(ocf_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}