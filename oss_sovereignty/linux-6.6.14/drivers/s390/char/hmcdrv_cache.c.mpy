{
  "module_name": "hmcdrv_cache.c",
  "hash_id": "5dca2985d63f969667c7d666c1d6cd12ecaf43cc779d885e30bfb17c586d15e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/hmcdrv_cache.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"hmcdrv\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/jiffies.h>\n\n#include \"hmcdrv_ftp.h\"\n#include \"hmcdrv_cache.h\"\n\n#define HMCDRV_CACHE_TIMEOUT\t\t30  \n\n \nstruct hmcdrv_cache_entry {\n\tenum hmcdrv_ftp_cmdid id;\n\tchar fname[HMCDRV_FTP_FIDENT_MAX];\n\tsize_t fsize;\n\tloff_t ofs;\n\tunsigned long timeout;\n\tvoid *content;\n\tsize_t len;\n};\n\nstatic int hmcdrv_cache_order;  \n\nstatic struct hmcdrv_cache_entry hmcdrv_cache_file = {\n\t.fsize = SIZE_MAX,\n\t.ofs = -1,\n\t.len = 0,\n\t.fname = {'\\0'}\n};\n\n \nstatic ssize_t hmcdrv_cache_get(const struct hmcdrv_ftp_cmdspec *ftp)\n{\n\tloff_t pos;  \n\tssize_t len;\n\n\tif ((ftp->id != hmcdrv_cache_file.id) ||\n\t    strcmp(hmcdrv_cache_file.fname, ftp->fname))\n\t\treturn -1;\n\n\tif (ftp->ofs >= hmcdrv_cache_file.fsize)  \n\t\treturn 0;\n\n\tif ((hmcdrv_cache_file.ofs < 0) ||  \n\t    time_after(jiffies, hmcdrv_cache_file.timeout))\n\t\treturn -1;\n\n\t \n\tlen = hmcdrv_cache_file.fsize - ftp->ofs;\n\n\tif (len > ftp->len)\n\t\tlen = ftp->len;\n\n\t \n\tpos = ftp->ofs - hmcdrv_cache_file.ofs;\n\n\tif ((pos >= 0) &&\n\t    ((pos + len) <= hmcdrv_cache_file.len)) {\n\n\t\tmemcpy(ftp->buf,\n\t\t       hmcdrv_cache_file.content + pos,\n\t\t       len);\n\t\tpr_debug(\"using cached content of '%s', returning %zd/%zd bytes\\n\",\n\t\t\t hmcdrv_cache_file.fname, len,\n\t\t\t hmcdrv_cache_file.fsize);\n\n\t\treturn len;\n\t}\n\n\treturn -1;\n}\n\n \nstatic ssize_t hmcdrv_cache_do(const struct hmcdrv_ftp_cmdspec *ftp,\n\t\t\t       hmcdrv_cache_ftpfunc func)\n{\n\tssize_t len;\n\n\t \n\tif ((ftp->len > 0) && (hmcdrv_cache_file.len >= ftp->len)) {\n\n\t\t \n\t\tstruct hmcdrv_ftp_cmdspec cftp = *ftp;  \n\t\tcftp.buf = hmcdrv_cache_file.content;   \n\t\tcftp.len = hmcdrv_cache_file.len;       \n\n\t\tlen = func(&cftp, &hmcdrv_cache_file.fsize);  \n\n\t\tif (len > 0) {\n\t\t\tpr_debug(\"caching %zd bytes content for '%s'\\n\",\n\t\t\t\t len, ftp->fname);\n\n\t\t\tif (len > ftp->len)\n\t\t\t\tlen = ftp->len;\n\n\t\t\thmcdrv_cache_file.ofs = ftp->ofs;\n\t\t\thmcdrv_cache_file.timeout = jiffies +\n\t\t\t\tHMCDRV_CACHE_TIMEOUT * HZ;\n\t\t\tmemcpy(ftp->buf, hmcdrv_cache_file.content, len);\n\t\t}\n\t} else {\n\t\tlen = func(ftp, &hmcdrv_cache_file.fsize);\n\t\thmcdrv_cache_file.ofs = -1;  \n\t}\n\n\tif (len > 0) {\n\t\t \n\t\tstrscpy(hmcdrv_cache_file.fname, ftp->fname,\n\t\t\tHMCDRV_FTP_FIDENT_MAX);\n\t\thmcdrv_cache_file.id = ftp->id;\n\t\tpr_debug(\"caching cmd %d, file size %zu for '%s'\\n\",\n\t\t\t ftp->id, hmcdrv_cache_file.fsize, ftp->fname);\n\t}\n\n\treturn len;\n}\n\n \nssize_t hmcdrv_cache_cmd(const struct hmcdrv_ftp_cmdspec *ftp,\n\t\t\t hmcdrv_cache_ftpfunc func)\n{\n\tssize_t len;\n\n\tif ((ftp->id == HMCDRV_FTP_DIR) ||  \n\t    (ftp->id == HMCDRV_FTP_NLIST) ||\n\t    (ftp->id == HMCDRV_FTP_GET)) {\n\n\t\tlen = hmcdrv_cache_get(ftp);\n\n\t\tif (len >= 0)  \n\t\t\treturn len;  \n\n\t\tlen = hmcdrv_cache_do(ftp, func);\n\n\t\tif (len >= 0)\n\t\t\treturn len;\n\n\t} else {\n\t\tlen = func(ftp, NULL);  \n\t}\n\n\t \n\thmcdrv_cache_file.id = HMCDRV_FTP_NOOP;\n\thmcdrv_cache_file.fsize = LLONG_MAX;\n\thmcdrv_cache_file.ofs = -1;\n\n\treturn len;\n}\n\n \nint hmcdrv_cache_startup(size_t cachesize)\n{\n\tif (cachesize > 0) {  \n\t\thmcdrv_cache_order = get_order(cachesize);\n\t\thmcdrv_cache_file.content =\n\t\t\t(void *) __get_free_pages(GFP_KERNEL | GFP_DMA,\n\t\t\t\t\t\t  hmcdrv_cache_order);\n\n\t\tif (!hmcdrv_cache_file.content) {\n\t\t\tpr_err(\"Allocating the requested cache size of %zu bytes failed\\n\",\n\t\t\t       cachesize);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpr_debug(\"content cache enabled, size is %zu bytes\\n\",\n\t\t\t cachesize);\n\t}\n\n\thmcdrv_cache_file.len = cachesize;\n\treturn 0;\n}\n\n \nvoid hmcdrv_cache_shutdown(void)\n{\n\tif (hmcdrv_cache_file.content) {\n\t\tfree_pages((unsigned long) hmcdrv_cache_file.content,\n\t\t\t   hmcdrv_cache_order);\n\t\thmcdrv_cache_file.content = NULL;\n\t}\n\n\thmcdrv_cache_file.id = HMCDRV_FTP_NOOP;\n\thmcdrv_cache_file.fsize = LLONG_MAX;\n\thmcdrv_cache_file.ofs = -1;\n\thmcdrv_cache_file.len = 0;  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}