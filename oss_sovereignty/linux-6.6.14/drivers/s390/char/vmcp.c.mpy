{
  "module_name": "vmcp.c",
  "hash_id": "6a7caf02230b261d36920748e866eca65cee41f6f2525a293f709c9e4a197ab7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/vmcp.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/compat.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cma.h>\n#include <linux/mm.h>\n#include <asm/cpcmd.h>\n#include <asm/debug.h>\n#include <asm/vmcp.h>\n\nstruct vmcp_session {\n\tchar *response;\n\tunsigned int bufsize;\n\tunsigned int cma_alloc : 1;\n\tint resp_size;\n\tint resp_code;\n\tstruct mutex mutex;\n};\n\nstatic debug_info_t *vmcp_debug;\n\nstatic unsigned long vmcp_cma_size __initdata = CONFIG_VMCP_CMA_SIZE * 1024 * 1024;\nstatic struct cma *vmcp_cma;\n\nstatic int __init early_parse_vmcp_cma(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\tvmcp_cma_size = ALIGN(memparse(p, NULL), PAGE_SIZE);\n\treturn 0;\n}\nearly_param(\"vmcp_cma\", early_parse_vmcp_cma);\n\nvoid __init vmcp_cma_reserve(void)\n{\n\tif (!MACHINE_IS_VM)\n\t\treturn;\n\tcma_declare_contiguous(0, vmcp_cma_size, 0, 0, 0, false, \"vmcp\", &vmcp_cma);\n}\n\nstatic void vmcp_response_alloc(struct vmcp_session *session)\n{\n\tstruct page *page = NULL;\n\tint nr_pages, order;\n\n\torder = get_order(session->bufsize);\n\tnr_pages = ALIGN(session->bufsize, PAGE_SIZE) >> PAGE_SHIFT;\n\t \n\tif (order > 2)\n\t\tpage = cma_alloc(vmcp_cma, nr_pages, 0, false);\n\tif (page) {\n\t\tsession->response = (char *)page_to_virt(page);\n\t\tsession->cma_alloc = 1;\n\t\treturn;\n\t}\n\tsession->response = (char *)__get_free_pages(GFP_KERNEL | __GFP_RETRY_MAYFAIL, order);\n}\n\nstatic void vmcp_response_free(struct vmcp_session *session)\n{\n\tint nr_pages, order;\n\tstruct page *page;\n\n\tif (!session->response)\n\t\treturn;\n\torder = get_order(session->bufsize);\n\tnr_pages = ALIGN(session->bufsize, PAGE_SIZE) >> PAGE_SHIFT;\n\tif (session->cma_alloc) {\n\t\tpage = virt_to_page(session->response);\n\t\tcma_release(vmcp_cma, page, nr_pages);\n\t\tsession->cma_alloc = 0;\n\t} else {\n\t\tfree_pages((unsigned long)session->response, order);\n\t}\n\tsession->response = NULL;\n}\n\nstatic int vmcp_open(struct inode *inode, struct file *file)\n{\n\tstruct vmcp_session *session;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsession = kmalloc(sizeof(*session), GFP_KERNEL);\n\tif (!session)\n\t\treturn -ENOMEM;\n\n\tsession->bufsize = PAGE_SIZE;\n\tsession->response = NULL;\n\tsession->resp_size = 0;\n\tmutex_init(&session->mutex);\n\tfile->private_data = session;\n\treturn nonseekable_open(inode, file);\n}\n\nstatic int vmcp_release(struct inode *inode, struct file *file)\n{\n\tstruct vmcp_session *session;\n\n\tsession = file->private_data;\n\tfile->private_data = NULL;\n\tvmcp_response_free(session);\n\tkfree(session);\n\treturn 0;\n}\n\nstatic ssize_t\nvmcp_read(struct file *file, char __user *buff, size_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tsize_t size;\n\tstruct vmcp_session *session;\n\n\tsession = file->private_data;\n\tif (mutex_lock_interruptible(&session->mutex))\n\t\treturn -ERESTARTSYS;\n\tif (!session->response) {\n\t\tmutex_unlock(&session->mutex);\n\t\treturn 0;\n\t}\n\tsize = min_t(size_t, session->resp_size, session->bufsize);\n\tret = simple_read_from_buffer(buff, count, ppos,\n\t\t\t\t\tsession->response, size);\n\n\tmutex_unlock(&session->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t\nvmcp_write(struct file *file, const char __user *buff, size_t count,\n\t   loff_t *ppos)\n{\n\tchar *cmd;\n\tstruct vmcp_session *session;\n\n\tif (count > 240)\n\t\treturn -EINVAL;\n\tcmd = memdup_user_nul(buff, count);\n\tif (IS_ERR(cmd))\n\t\treturn PTR_ERR(cmd);\n\tsession = file->private_data;\n\tif (mutex_lock_interruptible(&session->mutex)) {\n\t\tkfree(cmd);\n\t\treturn -ERESTARTSYS;\n\t}\n\tif (!session->response)\n\t\tvmcp_response_alloc(session);\n\tif (!session->response) {\n\t\tmutex_unlock(&session->mutex);\n\t\tkfree(cmd);\n\t\treturn -ENOMEM;\n\t}\n\tdebug_text_event(vmcp_debug, 1, cmd);\n\tsession->resp_size = cpcmd(cmd, session->response, session->bufsize,\n\t\t\t\t   &session->resp_code);\n\tmutex_unlock(&session->mutex);\n\tkfree(cmd);\n\t*ppos = 0;\t\t \n\treturn count;\n}\n\n\n \nstatic long vmcp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct vmcp_session *session;\n\tint ret = -ENOTTY;\n\tint __user *argp;\n\n\tsession = file->private_data;\n\tif (is_compat_task())\n\t\targp = compat_ptr(arg);\n\telse\n\t\targp = (int __user *)arg;\n\tif (mutex_lock_interruptible(&session->mutex))\n\t\treturn -ERESTARTSYS;\n\tswitch (cmd) {\n\tcase VMCP_GETCODE:\n\t\tret = put_user(session->resp_code, argp);\n\t\tbreak;\n\tcase VMCP_SETBUF:\n\t\tvmcp_response_free(session);\n\t\tret = get_user(session->bufsize, argp);\n\t\tif (ret)\n\t\t\tsession->bufsize = PAGE_SIZE;\n\t\tif (!session->bufsize || get_order(session->bufsize) > 8) {\n\t\t\tsession->bufsize = PAGE_SIZE;\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase VMCP_GETSIZE:\n\t\tret = put_user(session->resp_size, argp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&session->mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations vmcp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= vmcp_open,\n\t.release\t= vmcp_release,\n\t.read\t\t= vmcp_read,\n\t.write\t\t= vmcp_write,\n\t.unlocked_ioctl\t= vmcp_ioctl,\n\t.compat_ioctl\t= vmcp_ioctl,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice vmcp_dev = {\n\t.name\t= \"vmcp\",\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.fops\t= &vmcp_fops,\n};\n\nstatic int __init vmcp_init(void)\n{\n\tint ret;\n\n\tif (!MACHINE_IS_VM)\n\t\treturn 0;\n\n\tvmcp_debug = debug_register(\"vmcp\", 1, 1, 240);\n\tif (!vmcp_debug)\n\t\treturn -ENOMEM;\n\n\tret = debug_register_view(vmcp_debug, &debug_hex_ascii_view);\n\tif (ret) {\n\t\tdebug_unregister(vmcp_debug);\n\t\treturn ret;\n\t}\n\n\tret = misc_register(&vmcp_dev);\n\tif (ret)\n\t\tdebug_unregister(vmcp_debug);\n\treturn ret;\n}\ndevice_initcall(vmcp_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}