{
  "module_name": "con3215.c",
  "hash_id": "c3caf6ee749b339484602a48140a5f786c79fb2d3fed46109820d18b4ff65057",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/con3215.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kdev_t.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/vt_kern.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/panic_notifier.h>\n#include <linux/reboot.h>\n#include <linux/serial.h>  \n#include <linux/slab.h>\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n#include <linux/io.h>\n#include <asm/ebcdic.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/cpcmd.h>\n#include <asm/setup.h>\n\n#include \"ctrlchar.h\"\n\n#define NR_3215\t\t    1\n#define NR_3215_REQ\t    (4*NR_3215)\n#define RAW3215_BUFFER_SIZE 65536      \n#define RAW3215_INBUF_SIZE  256\t       \n#define RAW3215_MIN_SPACE   128\t       \n#define RAW3215_MIN_WRITE   1024       \n#define RAW3215_MAX_BYTES   3968       \n#define RAW3215_MAX_NEWLINE 50\t       \n#define RAW3215_NR_CCWS\t    3\n#define RAW3215_TIMEOUT\t    HZ/10      \n\n#define RAW3215_FIXED\t    1\t       \n#define RAW3215_WORKING\t    4\t       \n#define RAW3215_THROTTLED   8\t       \n#define RAW3215_STOPPED\t    16\t       \n#define RAW3215_TIMER_RUNS  64\t       \n#define RAW3215_FLUSHING    128\t       \n\n#define TAB_STOP_SIZE\t    8\t       \n\n \nenum raw3215_type {\n\tRAW3215_FREE, RAW3215_READ, RAW3215_WRITE\n};\n\n \nstruct raw3215_req {\n\tenum raw3215_type type;\t       \n\tint start, len;\t\t       \n\tint delayable;\t\t       \n\tint residual;\t\t       \n\tstruct ccw1 ccws[RAW3215_NR_CCWS];  \n\tstruct raw3215_info *info;     \n\tstruct raw3215_req *next;      \n} __attribute__ ((aligned(8)));\n\nstruct raw3215_info {\n\tstruct tty_port port;\n\tstruct ccw_device *cdev;       \n\tspinlock_t *lock;\t       \n\tint flags;\t\t       \n\tchar *buffer;\t\t       \n\tchar *inbuf;\t\t       \n\tint head;\t\t       \n\tint count;\t\t       \n\tint written;\t\t       \n\tstruct raw3215_req *queued_read;  \n\tstruct raw3215_req *queued_write; \n\twait_queue_head_t empty_wait;  \n\tstruct timer_list timer;       \n\tint line_pos;\t\t       \n\tchar ubuffer[80];\t       \n};\n\n \nstatic struct raw3215_info *raw3215[NR_3215];\n \nstatic DEFINE_SPINLOCK(raw3215_device_lock);\n \nstatic struct raw3215_req *raw3215_freelist;\n \nstatic DEFINE_SPINLOCK(raw3215_freelist_lock);\n\nstatic struct tty_driver *tty3215_driver;\nstatic bool con3215_drop = true;\n\n \nstatic inline struct raw3215_req *raw3215_alloc_req(void)\n{\n\tstruct raw3215_req *req;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&raw3215_freelist_lock, flags);\n\treq = raw3215_freelist;\n\traw3215_freelist = req->next;\n\tspin_unlock_irqrestore(&raw3215_freelist_lock, flags);\n\treturn req;\n}\n\n \nstatic inline void raw3215_free_req(struct raw3215_req *req)\n{\n\tunsigned long flags;\n\n\tif (req->type == RAW3215_FREE)\n\t\treturn;\t\t \n\treq->type = RAW3215_FREE;\n\tspin_lock_irqsave(&raw3215_freelist_lock, flags);\n\treq->next = raw3215_freelist;\n\traw3215_freelist = req;\n\tspin_unlock_irqrestore(&raw3215_freelist_lock, flags);\n}\n\n \nstatic void raw3215_mk_read_req(struct raw3215_info *raw)\n{\n\tstruct raw3215_req *req;\n\tstruct ccw1 *ccw;\n\n\t \n\treq = raw->queued_read;\n\tif (req == NULL) {\n\t\t \n\t\treq = raw3215_alloc_req();\n\t\treq->type = RAW3215_READ;\n\t\treq->info = raw;\n\t\traw->queued_read = req;\n\t}\n\n\tccw = req->ccws;\n\tccw->cmd_code = 0x0A;  \n\tccw->flags = 0x20;     \n\tccw->count = 160;\n\tccw->cda = (__u32)__pa(raw->inbuf);\n}\n\n \nstatic void raw3215_mk_write_req(struct raw3215_info *raw)\n{\n\tstruct raw3215_req *req;\n\tstruct ccw1 *ccw;\n\tint len, count, ix, lines;\n\n\tif (raw->count <= raw->written)\n\t\treturn;\n\t \n\treq = raw->queued_write;\n\tif (req == NULL) {\n\t\t \n\t\treq = raw3215_alloc_req();\n\t\treq->type = RAW3215_WRITE;\n\t\treq->info = raw;\n\t\traw->queued_write = req;\n\t} else {\n\t\traw->written -= req->len;\n\t}\n\n\tccw = req->ccws;\n\treq->start = (raw->head - raw->count + raw->written) &\n\t\t     (RAW3215_BUFFER_SIZE - 1);\n\t \n\tlines = 0;\n\tix = req->start;\n\twhile (lines < RAW3215_MAX_NEWLINE && ix != raw->head) {\n\t\tif (raw->buffer[ix] == 0x15)\n\t\t\tlines++;\n\t\tix = (ix + 1) & (RAW3215_BUFFER_SIZE - 1);\n\t}\n\tlen = ((ix - 1 - req->start) & (RAW3215_BUFFER_SIZE - 1)) + 1;\n\tif (len > RAW3215_MAX_BYTES)\n\t\tlen = RAW3215_MAX_BYTES;\n\treq->len = len;\n\traw->written += len;\n\n\t \n\treq->delayable = (ix == raw->head) && (len < RAW3215_MIN_WRITE);\n\n\tix = req->start;\n\twhile (len > 0) {\n\t\tif (ccw > req->ccws)\n\t\t\tccw[-1].flags |= 0x40;  \n\t\tccw->cmd_code = 0x01;  \n\t\tccw->flags = 0x20;     \n\t\tccw->cda = (__u32)__pa(raw->buffer + ix);\n\t\tcount = len;\n\t\tif (ix + count > RAW3215_BUFFER_SIZE)\n\t\t\tcount = RAW3215_BUFFER_SIZE - ix;\n\t\tccw->count = count;\n\t\tlen -= count;\n\t\tix = (ix + count) & (RAW3215_BUFFER_SIZE - 1);\n\t\tccw++;\n\t}\n\t \n\tif (ccw > req->ccws)\n\t\tccw[-1].flags |= 0x40;  \n\tccw->cmd_code = 0x03;  \n\tccw->flags = 0;\n\tccw->cda = 0;\n\tccw->count = 1;\n}\n\n \nstatic void raw3215_start_io(struct raw3215_info *raw)\n{\n\tstruct raw3215_req *req;\n\tint res;\n\n\treq = raw->queued_read;\n\tif (req != NULL &&\n\t    !(raw->flags & (RAW3215_WORKING | RAW3215_THROTTLED))) {\n\t\t \n\t\traw->queued_read = NULL;\n\t\tres = ccw_device_start(raw->cdev, req->ccws,\n\t\t\t\t       (unsigned long) req, 0, 0);\n\t\tif (res != 0) {\n\t\t\t \n\t\t\traw->queued_read = req;\n\t\t} else {\n\t\t\traw->flags |= RAW3215_WORKING;\n\t\t}\n\t}\n\treq = raw->queued_write;\n\tif (req != NULL &&\n\t    !(raw->flags & (RAW3215_WORKING | RAW3215_STOPPED))) {\n\t\t \n\t\traw->queued_write = NULL;\n\t\tres = ccw_device_start(raw->cdev, req->ccws,\n\t\t\t\t       (unsigned long) req, 0, 0);\n\t\tif (res != 0) {\n\t\t\t \n\t\t\traw->queued_write = req;\n\t\t} else {\n\t\t\traw->flags |= RAW3215_WORKING;\n\t\t}\n\t}\n}\n\n \nstatic void raw3215_timeout(struct timer_list *t)\n{\n\tstruct raw3215_info *raw = from_timer(raw, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\n\traw->flags &= ~RAW3215_TIMER_RUNS;\n\traw3215_mk_write_req(raw);\n\traw3215_start_io(raw);\n\tif ((raw->queued_read || raw->queued_write) &&\n\t    !(raw->flags & RAW3215_WORKING) &&\n\t    !(raw->flags & RAW3215_TIMER_RUNS)) {\n\t\traw->timer.expires = RAW3215_TIMEOUT + jiffies;\n\t\tadd_timer(&raw->timer);\n\t\traw->flags |= RAW3215_TIMER_RUNS;\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n}\n\n \nstatic inline void raw3215_try_io(struct raw3215_info *raw)\n{\n\tif (!tty_port_initialized(&raw->port))\n\t\treturn;\n\tif (raw->queued_read != NULL)\n\t\traw3215_start_io(raw);\n\telse if (raw->queued_write != NULL) {\n\t\tif ((raw->queued_write->delayable == 0) ||\n\t\t    (raw->flags & RAW3215_FLUSHING)) {\n\t\t\t \n\t\t\traw3215_start_io(raw);\n\t\t}\n\t}\n\tif ((raw->queued_read || raw->queued_write) &&\n\t    !(raw->flags & RAW3215_WORKING) &&\n\t    !(raw->flags & RAW3215_TIMER_RUNS)) {\n\t\traw->timer.expires = RAW3215_TIMEOUT + jiffies;\n\t\tadd_timer(&raw->timer);\n\t\traw->flags |= RAW3215_TIMER_RUNS;\n\t}\n}\n\n \nstatic void raw3215_next_io(struct raw3215_info *raw, struct tty_struct *tty)\n{\n\traw3215_mk_write_req(raw);\n\traw3215_try_io(raw);\n\tif (tty && RAW3215_BUFFER_SIZE - raw->count >= RAW3215_MIN_SPACE)\n\t\ttty_wakeup(tty);\n}\n\n \nstatic void raw3215_irq(struct ccw_device *cdev, unsigned long intparm,\n\t\t\tstruct irb *irb)\n{\n\tstruct raw3215_info *raw;\n\tstruct raw3215_req *req;\n\tstruct tty_struct *tty;\n\tint cstat, dstat;\n\tint count;\n\n\traw = dev_get_drvdata(&cdev->dev);\n\treq = (struct raw3215_req *) intparm;\n\ttty = tty_port_tty_get(&raw->port);\n\tcstat = irb->scsw.cmd.cstat;\n\tdstat = irb->scsw.cmd.dstat;\n\tif (cstat != 0)\n\t\traw3215_next_io(raw, tty);\n\tif (dstat & 0x01) {  \n\t\tdstat &= ~0x01;\t  \n\t}\n\tswitch (dstat) {\n\tcase 0x80:\n\t\tif (cstat != 0)\n\t\t\tbreak;\n\t\t \n\t\traw3215_mk_read_req(raw);\n\t\traw3215_next_io(raw, tty);\n\t\tbreak;\n\tcase 0x08:\n\tcase 0x0C:\n\t\t \n\t\tif ((raw = req->info) == NULL)\n\t\t\tgoto put_tty;\t      \n\t\tif (req->type == RAW3215_READ) {\n\t\t\t \n\t\t\treq->residual = irb->scsw.cmd.count;\n\t\t}\n\t\tif (dstat == 0x08)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 0x04:\n\t\t \n\t\tif ((raw = req->info) == NULL)\n\t\t\tgoto put_tty;\t      \n\t\tif (req->type == RAW3215_READ && tty != NULL) {\n\t\t\tunsigned int cchar;\n\n\t\t\tcount = 160 - req->residual;\n\t\t\tEBCASC(raw->inbuf, count);\n\t\t\tcchar = ctrlchar_handle(raw->inbuf, count, tty);\n\t\t\tswitch (cchar & CTRLCHAR_MASK) {\n\t\t\tcase CTRLCHAR_SYSRQ:\n\t\t\t\tbreak;\n\n\t\t\tcase CTRLCHAR_CTRL:\n\t\t\t\ttty_insert_flip_char(&raw->port, cchar,\n\t\t\t\t\t\tTTY_NORMAL);\n\t\t\t\ttty_flip_buffer_push(&raw->port);\n\t\t\t\tbreak;\n\n\t\t\tcase CTRLCHAR_NONE:\n\t\t\t\tif (count < 2 ||\n\t\t\t\t    (strncmp(raw->inbuf+count-2, \"\\252n\", 2) &&\n\t\t\t\t     strncmp(raw->inbuf+count-2, \"^n\", 2)) ) {\n\t\t\t\t\t \n\t\t\t\t\traw->inbuf[count] = '\\n';\n\t\t\t\t\tcount++;\n\t\t\t\t} else\n\t\t\t\t\tcount -= 2;\n\t\t\t\ttty_insert_flip_string(&raw->port, raw->inbuf,\n\t\t\t\t\t\tcount);\n\t\t\t\ttty_flip_buffer_push(&raw->port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (req->type == RAW3215_WRITE) {\n\t\t\traw->count -= req->len;\n\t\t\traw->written -= req->len;\n\t\t}\n\t\traw->flags &= ~RAW3215_WORKING;\n\t\traw3215_free_req(req);\n\t\t \n\t\tif (waitqueue_active(&raw->empty_wait) &&\n\t\t    raw->queued_write == NULL &&\n\t\t    raw->queued_read == NULL) {\n\t\t\twake_up_interruptible(&raw->empty_wait);\n\t\t}\n\t\traw3215_next_io(raw, tty);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (req != NULL && req->type != RAW3215_FREE) {\n\t\t\tif (req->type == RAW3215_WRITE) {\n\t\t\t\traw->count -= req->len;\n\t\t\t\traw->written -= req->len;\n\t\t\t}\n\t\t\traw->flags &= ~RAW3215_WORKING;\n\t\t\traw3215_free_req(req);\n\t\t}\n\t\traw3215_next_io(raw, tty);\n\t}\nput_tty:\n\ttty_kref_put(tty);\n}\n\n \nstatic unsigned int raw3215_drop(struct raw3215_info *raw)\n{\n\tstruct raw3215_req *req;\n\n\treq = raw->queued_write;\n\tif (req) {\n\t\t \n\t\traw->written -= req->len;\n\t\traw3215_free_req(req);\n\t\traw->queued_write = NULL;\n\t}\n\traw->head = (raw->head - raw->count + raw->written) &\n\t\t    (RAW3215_BUFFER_SIZE - 1);\n\traw->count = raw->written;\n\n\treturn RAW3215_BUFFER_SIZE - raw->count;\n}\n\n \nstatic unsigned int raw3215_make_room(struct raw3215_info *raw,\n\t\t\t\t      unsigned int length, bool drop)\n{\n\twhile (RAW3215_BUFFER_SIZE - raw->count < length) {\n\t\tif (drop)\n\t\t\treturn raw3215_drop(raw);\n\n\t\t \n\t\traw->flags |= RAW3215_FLUSHING;\n\t\traw3215_mk_write_req(raw);\n\t\traw3215_try_io(raw);\n\t\traw->flags &= ~RAW3215_FLUSHING;\n#ifdef CONFIG_TN3215_CONSOLE\n\t\tccw_device_wait_idle(raw->cdev);\n#endif\n\t\t \n\t\tif (RAW3215_BUFFER_SIZE - raw->count >= length)\n\t\t\tbreak;\n\t\t \n\t\tspin_unlock(get_ccwdev_lock(raw->cdev));\n\t\tudelay(100);\n\t\tspin_lock(get_ccwdev_lock(raw->cdev));\n\t}\n\treturn length;\n}\n\n#define\tRAW3215_COUNT\t1\n#define\tRAW3215_STORE\t2\n\n \nstatic unsigned int raw3215_addtext(const char *str, unsigned int length,\n\t\t\t\t    struct raw3215_info *raw, int opmode,\n\t\t\t\t    unsigned int todrop)\n{\n\tunsigned int c, ch, i, blanks, expanded_size = 0;\n\tunsigned int column = raw->line_pos;\n\n\tif (opmode == RAW3215_COUNT)\n\t\ttodrop = 0;\n\n\tfor (c = 0; c < length; ++c) {\n\t\tblanks = 1;\n\t\tch = str[c];\n\n\t\tswitch (ch) {\n\t\tcase '\\n':\n\t\t\texpanded_size++;\n\t\t\tcolumn = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tblanks = TAB_STOP_SIZE - (column % TAB_STOP_SIZE);\n\t\t\tcolumn += blanks;\n\t\t\texpanded_size += blanks;\n\t\t\tch = ' ';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texpanded_size++;\n\t\t\tcolumn++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opmode == RAW3215_COUNT)\n\t\t\tcontinue;\n\t\tif (todrop && expanded_size < todrop)\t \n\t\t\tcontinue;\n\t\tfor (i = 0; i < blanks; i++) {\n\t\t\traw->buffer[raw->head] = (char)_ascebc[(int)ch];\n\t\t\traw->head = (raw->head + 1) & (RAW3215_BUFFER_SIZE - 1);\n\t\t\traw->count++;\n\t\t}\n\t\traw->line_pos = column;\n\t}\n\treturn expanded_size - todrop;\n}\n\n \nstatic void raw3215_write(struct raw3215_info *raw, const char *str,\n\t\t\t  unsigned int length)\n{\n\tunsigned int count, avail;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\n\n\tcount = raw3215_addtext(str, length, raw, RAW3215_COUNT, 0);\n\n\tavail = raw3215_make_room(raw, count, con3215_drop);\n\tif (avail) {\n\t\traw3215_addtext(str, length, raw, RAW3215_STORE,\n\t\t\t\tcount - avail);\n\t}\n\tif (!(raw->flags & RAW3215_WORKING)) {\n\t\traw3215_mk_write_req(raw);\n\t\t \n\t\traw3215_try_io(raw);\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n}\n\n \nstatic void raw3215_putchar(struct raw3215_info *raw, unsigned char ch)\n{\n\traw3215_write(raw, &ch, 1);\n}\n\n \nstatic void raw3215_flush_buffer(struct raw3215_info *raw)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\n\tif (raw->count > 0) {\n\t\traw->flags |= RAW3215_FLUSHING;\n\t\traw3215_try_io(raw);\n\t\traw->flags &= ~RAW3215_FLUSHING;\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n}\n\n \nstatic int raw3215_startup(struct raw3215_info *raw)\n{\n\tunsigned long flags;\n\n\tif (tty_port_initialized(&raw->port))\n\t\treturn 0;\n\traw->line_pos = 0;\n\ttty_port_set_initialized(&raw->port, true);\n\tspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\n\traw3215_try_io(raw);\n\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n\n\treturn 0;\n}\n\n \nstatic void raw3215_shutdown(struct raw3215_info *raw)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long flags;\n\n\tif (!tty_port_initialized(&raw->port) || (raw->flags & RAW3215_FIXED))\n\t\treturn;\n\t \n\tspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\n\tif ((raw->flags & RAW3215_WORKING) ||\n\t    raw->queued_write != NULL ||\n\t    raw->queued_read != NULL) {\n\t\tadd_wait_queue(&raw->empty_wait, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\n\t\tremove_wait_queue(&raw->empty_wait, &wait);\n\t\tset_current_state(TASK_RUNNING);\n\t\ttty_port_set_initialized(&raw->port, true);\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n}\n\nstatic struct raw3215_info *raw3215_alloc_info(void)\n{\n\tstruct raw3215_info *info;\n\n\tinfo = kzalloc(sizeof(struct raw3215_info), GFP_KERNEL | GFP_DMA);\n\tif (!info)\n\t\treturn NULL;\n\n\tinfo->buffer = kzalloc(RAW3215_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);\n\tinfo->inbuf = kzalloc(RAW3215_INBUF_SIZE, GFP_KERNEL | GFP_DMA);\n\tif (!info->buffer || !info->inbuf) {\n\t\tkfree(info->inbuf);\n\t\tkfree(info->buffer);\n\t\tkfree(info);\n\t\treturn NULL;\n\t}\n\n\ttimer_setup(&info->timer, raw3215_timeout, 0);\n\tinit_waitqueue_head(&info->empty_wait);\n\ttty_port_init(&info->port);\n\n\treturn info;\n}\n\nstatic void raw3215_free_info(struct raw3215_info *raw)\n{\n\tkfree(raw->inbuf);\n\tkfree(raw->buffer);\n\ttty_port_destroy(&raw->port);\n\tkfree(raw);\n}\n\nstatic int raw3215_probe(struct ccw_device *cdev)\n{\n\tstruct raw3215_info *raw;\n\tint line;\n\n\t \n\tif (raw3215[0] && (raw3215[0] == dev_get_drvdata(&cdev->dev)))\n\t\treturn 0;\n\n\traw = raw3215_alloc_info();\n\tif (raw == NULL)\n\t\treturn -ENOMEM;\n\n\traw->cdev = cdev;\n\tdev_set_drvdata(&cdev->dev, raw);\n\tcdev->handler = raw3215_irq;\n\n\tspin_lock(&raw3215_device_lock);\n\tfor (line = 0; line < NR_3215; line++) {\n\t\tif (!raw3215[line]) {\n\t\t\traw3215[line] = raw;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&raw3215_device_lock);\n\tif (line == NR_3215) {\n\t\traw3215_free_info(raw);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void raw3215_remove(struct ccw_device *cdev)\n{\n\tstruct raw3215_info *raw;\n\tunsigned int line;\n\n\tccw_device_set_offline(cdev);\n\traw = dev_get_drvdata(&cdev->dev);\n\tif (raw) {\n\t\tspin_lock(&raw3215_device_lock);\n\t\tfor (line = 0; line < NR_3215; line++)\n\t\t\tif (raw3215[line] == raw)\n\t\t\t\tbreak;\n\t\traw3215[line] = NULL;\n\t\tspin_unlock(&raw3215_device_lock);\n\t\tdev_set_drvdata(&cdev->dev, NULL);\n\t\traw3215_free_info(raw);\n\t}\n}\n\nstatic int raw3215_set_online(struct ccw_device *cdev)\n{\n\tstruct raw3215_info *raw;\n\n\traw = dev_get_drvdata(&cdev->dev);\n\tif (!raw)\n\t\treturn -ENODEV;\n\n\treturn raw3215_startup(raw);\n}\n\nstatic int raw3215_set_offline(struct ccw_device *cdev)\n{\n\tstruct raw3215_info *raw;\n\n\traw = dev_get_drvdata(&cdev->dev);\n\tif (!raw)\n\t\treturn -ENODEV;\n\n\traw3215_shutdown(raw);\n\n\treturn 0;\n}\n\nstatic struct ccw_device_id raw3215_id[] = {\n\t{ CCW_DEVICE(0x3215, 0) },\n\t{   },\n};\n\nstatic ssize_t con_drop_store(struct device_driver *dev, const char *buf, size_t count)\n{\n\tbool drop;\n\tint rc;\n\n\trc = kstrtobool(buf, &drop);\n\tif (!rc)\n\t\tcon3215_drop = drop;\n\treturn rc ?: count;\n}\n\nstatic ssize_t con_drop_show(struct device_driver *dev, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", con3215_drop ? 1 : 0);\n}\n\nstatic DRIVER_ATTR_RW(con_drop);\n\nstatic struct attribute *con3215_drv_attrs[] = {\n\t&driver_attr_con_drop.attr,\n\tNULL,\n};\n\nstatic struct attribute_group con3215_drv_attr_group = {\n\t.attrs = con3215_drv_attrs,\n\tNULL,\n};\n\nstatic const struct attribute_group *con3215_drv_attr_groups[] = {\n\t&con3215_drv_attr_group,\n\tNULL,\n};\n\nstatic struct ccw_driver raw3215_ccw_driver = {\n\t.driver = {\n\t\t.name\t= \"3215\",\n\t\t.groups = con3215_drv_attr_groups,\n\t\t.owner\t= THIS_MODULE,\n\t},\n\t.ids\t\t= raw3215_id,\n\t.probe\t\t= &raw3215_probe,\n\t.remove\t\t= &raw3215_remove,\n\t.set_online\t= &raw3215_set_online,\n\t.set_offline\t= &raw3215_set_offline,\n\t.int_class\t= IRQIO_C15,\n};\n\nstatic void handle_write(struct raw3215_info *raw, const char *str, int count)\n{\n\tint i;\n\n\twhile (count > 0) {\n\t\ti = min_t(int, count, RAW3215_BUFFER_SIZE - 1);\n\t\traw3215_write(raw, str, i);\n\t\tcount -= i;\n\t\tstr += i;\n\t}\n}\n\n#ifdef CONFIG_TN3215_CONSOLE\n \nstatic void con3215_write(struct console *co, const char *str, unsigned int count)\n{\n\thandle_write(raw3215[0], str, count);\n}\n\nstatic struct tty_driver *con3215_device(struct console *c, int *index)\n{\n\t*index = c->index;\n\treturn tty3215_driver;\n}\n\n \nstatic int con3215_notify(struct notifier_block *self,\n\t\t\t  unsigned long event, void *data)\n{\n\tstruct raw3215_info *raw;\n\tunsigned long flags;\n\n\traw = raw3215[0];   \n\tif (!spin_trylock_irqsave(get_ccwdev_lock(raw->cdev), flags))\n\t\treturn NOTIFY_DONE;\n\traw3215_make_room(raw, RAW3215_BUFFER_SIZE, false);\n\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block on_panic_nb = {\n\t.notifier_call = con3215_notify,\n\t.priority = INT_MIN + 1,  \n};\n\nstatic struct notifier_block on_reboot_nb = {\n\t.notifier_call = con3215_notify,\n\t.priority = INT_MIN + 1,  \n};\n\n \nstatic struct console con3215 = {\n\t.name\t = \"ttyS\",\n\t.write\t = con3215_write,\n\t.device\t = con3215_device,\n\t.flags\t = CON_PRINTBUFFER,\n};\n\n \nstatic int __init con3215_init(void)\n{\n\tstruct ccw_device *cdev;\n\tstruct raw3215_info *raw;\n\tstruct raw3215_req *req;\n\tint i;\n\n\t \n\tif (!CONSOLE_IS_3215)\n\t\treturn -ENODEV;\n\n\t \n\tif (MACHINE_IS_VM) {\n\t\tcpcmd(\"TERM CONMODE 3215\", NULL, 0, NULL);\n\t\tcpcmd(\"TERM AUTOCR OFF\", NULL, 0, NULL);\n\t}\n\n\t \n\traw3215_freelist = NULL;\n\tfor (i = 0; i < NR_3215_REQ; i++) {\n\t\treq = kzalloc(sizeof(struct raw3215_req), GFP_KERNEL | GFP_DMA);\n\t\tif (!req)\n\t\t\treturn -ENOMEM;\n\t\treq->next = raw3215_freelist;\n\t\traw3215_freelist = req;\n\t}\n\n\tcdev = ccw_device_create_console(&raw3215_ccw_driver);\n\tif (IS_ERR(cdev))\n\t\treturn -ENODEV;\n\n\traw3215[0] = raw = raw3215_alloc_info();\n\traw->cdev = cdev;\n\tdev_set_drvdata(&cdev->dev, raw);\n\tcdev->handler = raw3215_irq;\n\n\traw->flags |= RAW3215_FIXED;\n\tif (ccw_device_enable_console(cdev)) {\n\t\tccw_device_destroy_console(cdev);\n\t\traw3215_free_info(raw);\n\t\traw3215[0] = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (raw3215_startup(raw) != 0) {\n\t\traw3215_free_info(raw);\n\t\traw3215[0] = NULL;\n\t\treturn -ENODEV;\n\t}\n\tatomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\n\tregister_reboot_notifier(&on_reboot_nb);\n\tregister_console(&con3215);\n\treturn 0;\n}\nconsole_initcall(con3215_init);\n#endif\n\nstatic int tty3215_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct raw3215_info *raw;\n\n\traw = raw3215[tty->index];\n\tif (raw == NULL)\n\t\treturn -ENODEV;\n\n\ttty->driver_data = raw;\n\n\treturn tty_port_install(&raw->port, driver, tty);\n}\n\n \nstatic int tty3215_open(struct tty_struct *tty, struct file * filp)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\n\ttty_port_tty_set(&raw->port, tty);\n\n\t \n\treturn raw3215_startup(raw);\n}\n\n \nstatic void tty3215_close(struct tty_struct *tty, struct file * filp)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\n\tif (raw == NULL || tty->count > 1)\n\t\treturn;\n\ttty->closing = 1;\n\t \n\traw3215_shutdown(raw);\n\ttty->closing = 0;\n\ttty_port_tty_set(&raw->port, NULL);\n}\n\n \nstatic unsigned int tty3215_write_room(struct tty_struct *tty)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\n\t \n\tif ((RAW3215_BUFFER_SIZE - raw->count - TAB_STOP_SIZE) >= 0)\n\t\treturn RAW3215_BUFFER_SIZE - raw->count - TAB_STOP_SIZE;\n\telse\n\t\treturn 0;\n}\n\n \nstatic ssize_t tty3215_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t     size_t count)\n{\n\thandle_write(tty->driver_data, buf, count);\n\treturn count;\n}\n\n \nstatic int tty3215_put_char(struct tty_struct *tty, u8 ch)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\n\traw3215_putchar(raw, ch);\n\n\treturn 1;\n}\n\nstatic void tty3215_flush_chars(struct tty_struct *tty)\n{\n}\n\n \nstatic unsigned int tty3215_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\n\treturn raw->count;\n}\n\nstatic void tty3215_flush_buffer(struct tty_struct *tty)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\n\traw3215_flush_buffer(raw);\n\ttty_wakeup(tty);\n}\n\n \nstatic void tty3215_throttle(struct tty_struct *tty)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\n\traw->flags |= RAW3215_THROTTLED;\n}\n\n \nstatic void tty3215_unthrottle(struct tty_struct *tty)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\tunsigned long flags;\n\n\tif (raw->flags & RAW3215_THROTTLED) {\n\t\tspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\n\t\traw->flags &= ~RAW3215_THROTTLED;\n\t\traw3215_try_io(raw);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n\t}\n}\n\n \nstatic void tty3215_stop(struct tty_struct *tty)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\n\traw->flags |= RAW3215_STOPPED;\n}\n\n \nstatic void tty3215_start(struct tty_struct *tty)\n{\n\tstruct raw3215_info *raw = tty->driver_data;\n\tunsigned long flags;\n\n\tif (raw->flags & RAW3215_STOPPED) {\n\t\tspin_lock_irqsave(get_ccwdev_lock(raw->cdev), flags);\n\t\traw->flags &= ~RAW3215_STOPPED;\n\t\traw3215_try_io(raw);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(raw->cdev), flags);\n\t}\n}\n\nstatic const struct tty_operations tty3215_ops = {\n\t.install = tty3215_install,\n\t.open = tty3215_open,\n\t.close = tty3215_close,\n\t.write = tty3215_write,\n\t.put_char = tty3215_put_char,\n\t.flush_chars = tty3215_flush_chars,\n\t.write_room = tty3215_write_room,\n\t.chars_in_buffer = tty3215_chars_in_buffer,\n\t.flush_buffer = tty3215_flush_buffer,\n\t.throttle = tty3215_throttle,\n\t.unthrottle = tty3215_unthrottle,\n\t.stop = tty3215_stop,\n\t.start = tty3215_start,\n};\n\nstatic int __init con3215_setup_drop(char *str)\n{\n\tbool drop;\n\tint rc;\n\n\trc = kstrtobool(str, &drop);\n\tif (!rc)\n\t\tcon3215_drop = drop;\n\treturn rc;\n}\nearly_param(\"con3215_drop\", con3215_setup_drop);\n\n \nstatic int __init tty3215_init(void)\n{\n\tstruct tty_driver *driver;\n\tint ret;\n\n\tif (!CONSOLE_IS_3215)\n\t\treturn 0;\n\n\tdriver = tty_alloc_driver(NR_3215, TTY_DRIVER_REAL_RAW);\n\tif (IS_ERR(driver))\n\t\treturn PTR_ERR(driver);\n\n\tret = ccw_driver_register(&raw3215_ccw_driver);\n\tif (ret) {\n\t\ttty_driver_kref_put(driver);\n\t\treturn ret;\n\t}\n\t \n\n\tdriver->driver_name = \"tty3215\";\n\tdriver->name = \"ttyS\";\n\tdriver->major = TTY_MAJOR;\n\tdriver->minor_start = 64;\n\tdriver->type = TTY_DRIVER_TYPE_SYSTEM;\n\tdriver->subtype = SYSTEM_TYPE_TTY;\n\tdriver->init_termios = tty_std_termios;\n\tdriver->init_termios.c_iflag = IGNBRK | IGNPAR;\n\tdriver->init_termios.c_oflag = ONLCR;\n\tdriver->init_termios.c_lflag = ISIG;\n\ttty_set_operations(driver, &tty3215_ops);\n\tret = tty_register_driver(driver);\n\tif (ret) {\n\t\ttty_driver_kref_put(driver);\n\t\treturn ret;\n\t}\n\ttty3215_driver = driver;\n\treturn 0;\n}\ndevice_initcall(tty3215_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}