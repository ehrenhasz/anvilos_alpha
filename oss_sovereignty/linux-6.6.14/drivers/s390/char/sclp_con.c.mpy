{
  "module_name": "sclp_con.c",
  "hash_id": "d09bdc46f1478c9a308f988f726b11768845117d87c9ac49204ec466bab72196",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_con.c",
  "human_readable_source": "\n \n\n#include <linux/kmod.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/panic_notifier.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/termios.h>\n#include <linux/err.h>\n#include <linux/reboot.h>\n#include <linux/gfp.h>\n\n#include \"sclp.h\"\n#include \"sclp_rw.h\"\n#include \"sclp_tty.h\"\n\n#define sclp_console_major 4\t\t \n#define sclp_console_minor 64\n#define sclp_console_name  \"ttyS\"\n\n \nstatic DEFINE_SPINLOCK(sclp_con_lock);\n \nstatic LIST_HEAD(sclp_con_pages);\n \nstatic LIST_HEAD(sclp_con_outqueue);\n \nstatic struct sclp_buffer *sclp_conbuf;\n \nstatic struct timer_list sclp_con_timer;\n \nstatic int sclp_con_queue_running;\n\n \n#define SCLP_CON_COLUMNS\t320\n#define SPACES_PER_TAB\t\t8\n\nstatic void\nsclp_conbuf_callback(struct sclp_buffer *buffer, int rc)\n{\n\tunsigned long flags;\n\tvoid *page;\n\n\tdo {\n\t\tpage = sclp_unmake_buffer(buffer);\n\t\tspin_lock_irqsave(&sclp_con_lock, flags);\n\n\t\t \n\t\tlist_del(&buffer->list);\n\t\tlist_add_tail((struct list_head *) page, &sclp_con_pages);\n\n\t\t \n\t\tbuffer = NULL;\n\t\tif (!list_empty(&sclp_con_outqueue))\n\t\t\tbuffer = list_first_entry(&sclp_con_outqueue,\n\t\t\t\t\t\t  struct sclp_buffer, list);\n\t\tif (!buffer) {\n\t\t\tsclp_con_queue_running = 0;\n\t\t\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n\t} while (sclp_emit_buffer(buffer, sclp_conbuf_callback));\n}\n\n \nstatic void sclp_conbuf_emit(void)\n{\n\tstruct sclp_buffer* buffer;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&sclp_con_lock, flags);\n\tif (sclp_conbuf)\n\t\tlist_add_tail(&sclp_conbuf->list, &sclp_con_outqueue);\n\tsclp_conbuf = NULL;\n\tif (sclp_con_queue_running)\n\t\tgoto out_unlock;\n\tif (list_empty(&sclp_con_outqueue))\n\t\tgoto out_unlock;\n\tbuffer = list_first_entry(&sclp_con_outqueue, struct sclp_buffer,\n\t\t\t\t  list);\n\tsclp_con_queue_running = 1;\n\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n\n\trc = sclp_emit_buffer(buffer, sclp_conbuf_callback);\n\tif (rc)\n\t\tsclp_conbuf_callback(buffer, rc);\n\treturn;\nout_unlock:\n\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n}\n\n \nstatic void sclp_console_sync_queue(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sclp_con_lock, flags);\n\tdel_timer(&sclp_con_timer);\n\twhile (sclp_con_queue_running) {\n\t\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n\t\tsclp_sync_wait();\n\t\tspin_lock_irqsave(&sclp_con_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n}\n\n \nstatic void\nsclp_console_timeout(struct timer_list *unused)\n{\n\tsclp_conbuf_emit();\n}\n\n \nstatic int\nsclp_console_drop_buffer(void)\n{\n\tstruct list_head *list;\n\tstruct sclp_buffer *buffer;\n\tvoid *page;\n\n\tif (!sclp_console_drop)\n\t\treturn 0;\n\tlist = sclp_con_outqueue.next;\n\tif (sclp_con_queue_running)\n\t\t \n\t\tlist = list->next;\n\tif (list == &sclp_con_outqueue)\n\t\treturn 0;\n\tlist_del(list);\n\tbuffer = list_entry(list, struct sclp_buffer, list);\n\tpage = sclp_unmake_buffer(buffer);\n\tlist_add_tail((struct list_head *) page, &sclp_con_pages);\n\treturn 1;\n}\n\n \nstatic void\nsclp_console_write(struct console *console, const char *message,\n\t\t   unsigned int count)\n{\n\tunsigned long flags;\n\tvoid *page;\n\tint written;\n\n\tif (count == 0)\n\t\treturn;\n\tspin_lock_irqsave(&sclp_con_lock, flags);\n\t \n\tdo {\n\t\t \n\t\tif (sclp_conbuf == NULL) {\n\t\t\tif (list_empty(&sclp_con_pages))\n\t\t\t\tsclp_console_full++;\n\t\t\twhile (list_empty(&sclp_con_pages)) {\n\t\t\t\tif (sclp_console_drop_buffer())\n\t\t\t\t\tbreak;\n\t\t\t\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n\t\t\t\tsclp_sync_wait();\n\t\t\t\tspin_lock_irqsave(&sclp_con_lock, flags);\n\t\t\t}\n\t\t\tpage = sclp_con_pages.next;\n\t\t\tlist_del((struct list_head *) page);\n\t\t\tsclp_conbuf = sclp_make_buffer(page, SCLP_CON_COLUMNS,\n\t\t\t\t\t\t       SPACES_PER_TAB);\n\t\t}\n\t\t \n\t\twritten = sclp_write(sclp_conbuf, (const unsigned char *)\n\t\t\t\t     message, count);\n\t\tif (written == count)\n\t\t\tbreak;\n\t\t \n\t\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n\t\tsclp_conbuf_emit();\n\t\tspin_lock_irqsave(&sclp_con_lock, flags);\n\t\tmessage += written;\n\t\tcount -= written;\n\t} while (count > 0);\n\t \n\tif (sclp_conbuf != NULL && sclp_chars_in_buffer(sclp_conbuf) != 0 &&\n\t    !timer_pending(&sclp_con_timer)) {\n\t\tmod_timer(&sclp_con_timer, jiffies + HZ / 10);\n\t}\n\tspin_unlock_irqrestore(&sclp_con_lock, flags);\n}\n\nstatic struct tty_driver *\nsclp_console_device(struct console *c, int *index)\n{\n\t*index = c->index;\n\treturn sclp_tty_driver;\n}\n\n \nstatic int sclp_console_notify(struct notifier_block *self,\n\t\t\t       unsigned long event, void *data)\n{\n\t \n\tif (spin_is_locked(&sclp_con_lock))\n\t\treturn NOTIFY_DONE;\n\n\tsclp_conbuf_emit();\n\tsclp_console_sync_queue();\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block on_panic_nb = {\n\t.notifier_call = sclp_console_notify,\n\t.priority = INT_MIN + 1,  \n};\n\nstatic struct notifier_block on_reboot_nb = {\n\t.notifier_call = sclp_console_notify,\n\t.priority = INT_MIN + 1,  \n};\n\n \nstatic struct console sclp_console =\n{\n\t.name = sclp_console_name,\n\t.write = sclp_console_write,\n\t.device = sclp_console_device,\n\t.flags = CON_PRINTBUFFER,\n\t.index = 0  \n};\n\n \nstatic int __init\nsclp_console_init(void)\n{\n\tvoid *page;\n\tint i;\n\tint rc;\n\n\t \n\tif (!(CONSOLE_IS_SCLP || CONSOLE_IS_VT220))\n\t\treturn 0;\n\trc = sclp_rw_init();\n\tif (rc)\n\t\treturn rc;\n\t \n\tfor (i = 0; i < sclp_console_pages; i++) {\n\t\tpage = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\t\tlist_add_tail(page, &sclp_con_pages);\n\t}\n\tsclp_conbuf = NULL;\n\ttimer_setup(&sclp_con_timer, sclp_console_timeout, 0);\n\n\t \n\tatomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\n\tregister_reboot_notifier(&on_reboot_nb);\n\tregister_console(&sclp_console);\n\treturn 0;\n}\n\nconsole_initcall(sclp_console_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}