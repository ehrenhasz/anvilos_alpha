{
  "module_name": "uvdevice.c",
  "hash_id": "147dd5f49fe2f9e2c45926ccddc60d61aee56f2a497277c8a2bb730616ccb826",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/uvdevice.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/cpufeature.h>\n\n#include <asm/uvdevice.h>\n#include <asm/uv.h>\n\n#define BIT_UVIO_INTERNAL U32_MAX\n \nstatic const u32 ioctl_nr_to_uvc_bit[] __initconst = {\n\t[UVIO_IOCTL_UVDEV_INFO_NR] = BIT_UVIO_INTERNAL,\n\t[UVIO_IOCTL_ATT_NR] = BIT_UVC_CMD_RETR_ATTEST,\n\t[UVIO_IOCTL_ADD_SECRET_NR] = BIT_UVC_CMD_ADD_SECRET,\n\t[UVIO_IOCTL_LIST_SECRETS_NR] = BIT_UVC_CMD_LIST_SECRETS,\n\t[UVIO_IOCTL_LOCK_SECRETS_NR] = BIT_UVC_CMD_LOCK_SECRETS,\n};\n\nstatic_assert(ARRAY_SIZE(ioctl_nr_to_uvc_bit) == UVIO_IOCTL_NUM_IOCTLS);\n\nstatic struct uvio_uvdev_info uvdev_info = {\n\t.supp_uvio_cmds = GENMASK_ULL(UVIO_IOCTL_NUM_IOCTLS - 1, 0),\n};\n\nstatic void __init set_supp_uv_cmds(unsigned long *supp_uv_cmds)\n{\n\tint i;\n\n\tfor (i = 0; i < UVIO_IOCTL_NUM_IOCTLS; i++) {\n\t\tif (ioctl_nr_to_uvc_bit[i] == BIT_UVIO_INTERNAL)\n\t\t\tcontinue;\n\t\tif (!test_bit_inv(ioctl_nr_to_uvc_bit[i], uv_info.inst_calls_list))\n\t\t\tcontinue;\n\t\t__set_bit(i, supp_uv_cmds);\n\t}\n}\n\n \nstatic int uvio_uvdev_info(struct uvio_ioctl_cb *uv_ioctl)\n{\n\tvoid __user *user_buf_arg = (void __user *)uv_ioctl->argument_addr;\n\n\tif (uv_ioctl->argument_len < sizeof(uvdev_info))\n\t\treturn -EINVAL;\n\tif (copy_to_user(user_buf_arg, &uvdev_info, sizeof(uvdev_info)))\n\t\treturn -EFAULT;\n\n\tuv_ioctl->uv_rc = UVC_RC_EXECUTED;\n\treturn 0;\n}\n\nstatic int uvio_build_uvcb_attest(struct uv_cb_attest *uvcb_attest, u8 *arcb,\n\t\t\t\t  u8 *meas, u8 *add_data, struct uvio_attest *uvio_attest)\n{\n\tvoid __user *user_buf_arcb = (void __user *)uvio_attest->arcb_addr;\n\n\tif (copy_from_user(arcb, user_buf_arcb, uvio_attest->arcb_len))\n\t\treturn -EFAULT;\n\n\tuvcb_attest->header.len = sizeof(*uvcb_attest);\n\tuvcb_attest->header.cmd = UVC_CMD_RETR_ATTEST;\n\tuvcb_attest->arcb_addr = (u64)arcb;\n\tuvcb_attest->cont_token = 0;\n\tuvcb_attest->user_data_len = uvio_attest->user_data_len;\n\tmemcpy(uvcb_attest->user_data, uvio_attest->user_data, sizeof(uvcb_attest->user_data));\n\tuvcb_attest->meas_len = uvio_attest->meas_len;\n\tuvcb_attest->meas_addr = (u64)meas;\n\tuvcb_attest->add_data_len = uvio_attest->add_data_len;\n\tuvcb_attest->add_data_addr = (u64)add_data;\n\n\treturn 0;\n}\n\nstatic int uvio_copy_attest_result_to_user(struct uv_cb_attest *uvcb_attest,\n\t\t\t\t\t   struct uvio_ioctl_cb *uv_ioctl,\n\t\t\t\t\t   u8 *measurement, u8 *add_data,\n\t\t\t\t\t   struct uvio_attest *uvio_attest)\n{\n\tstruct uvio_attest __user *user_uvio_attest = (void __user *)uv_ioctl->argument_addr;\n\tvoid __user *user_buf_add = (void __user *)uvio_attest->add_data_addr;\n\tvoid __user *user_buf_meas = (void __user *)uvio_attest->meas_addr;\n\tvoid __user *user_buf_uid = &user_uvio_attest->config_uid;\n\n\tif (copy_to_user(user_buf_meas, measurement, uvio_attest->meas_len))\n\t\treturn -EFAULT;\n\tif (add_data && copy_to_user(user_buf_add, add_data, uvio_attest->add_data_len))\n\t\treturn -EFAULT;\n\tif (copy_to_user(user_buf_uid, uvcb_attest->config_uid, sizeof(uvcb_attest->config_uid)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int get_uvio_attest(struct uvio_ioctl_cb *uv_ioctl, struct uvio_attest *uvio_attest)\n{\n\tu8 __user *user_arg_buf = (u8 __user *)uv_ioctl->argument_addr;\n\n\tif (copy_from_user(uvio_attest, user_arg_buf, sizeof(*uvio_attest)))\n\t\treturn -EFAULT;\n\n\tif (uvio_attest->arcb_len > UVIO_ATT_ARCB_MAX_LEN)\n\t\treturn -EINVAL;\n\tif (uvio_attest->arcb_len == 0)\n\t\treturn -EINVAL;\n\tif (uvio_attest->meas_len > UVIO_ATT_MEASUREMENT_MAX_LEN)\n\t\treturn -EINVAL;\n\tif (uvio_attest->meas_len == 0)\n\t\treturn -EINVAL;\n\tif (uvio_attest->add_data_len > UVIO_ATT_ADDITIONAL_MAX_LEN)\n\t\treturn -EINVAL;\n\tif (uvio_attest->reserved136)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int uvio_attestation(struct uvio_ioctl_cb *uv_ioctl)\n{\n\tstruct uv_cb_attest *uvcb_attest = NULL;\n\tstruct uvio_attest *uvio_attest = NULL;\n\tu8 *measurement = NULL;\n\tu8 *add_data = NULL;\n\tu8 *arcb = NULL;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (uv_ioctl->argument_len != sizeof(*uvio_attest))\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tuvio_attest = kzalloc(sizeof(*uvio_attest), GFP_KERNEL);\n\tif (!uvio_attest)\n\t\tgoto out;\n\n\tret = get_uvio_attest(uv_ioctl, uvio_attest);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tarcb = kvzalloc(uvio_attest->arcb_len, GFP_KERNEL);\n\tmeasurement = kvzalloc(uvio_attest->meas_len, GFP_KERNEL);\n\tif (!arcb || !measurement)\n\t\tgoto out;\n\n\tif (uvio_attest->add_data_len) {\n\t\tadd_data = kvzalloc(uvio_attest->add_data_len, GFP_KERNEL);\n\t\tif (!add_data)\n\t\t\tgoto out;\n\t}\n\n\tuvcb_attest = kzalloc(sizeof(*uvcb_attest), GFP_KERNEL);\n\tif (!uvcb_attest)\n\t\tgoto out;\n\n\tret = uvio_build_uvcb_attest(uvcb_attest, arcb,  measurement, add_data, uvio_attest);\n\tif (ret)\n\t\tgoto out;\n\n\tuv_call_sched(0, (u64)uvcb_attest);\n\n\tuv_ioctl->uv_rc = uvcb_attest->header.rc;\n\tuv_ioctl->uv_rrc = uvcb_attest->header.rrc;\n\n\tret = uvio_copy_attest_result_to_user(uvcb_attest, uv_ioctl, measurement, add_data,\n\t\t\t\t\t      uvio_attest);\nout:\n\tkvfree(arcb);\n\tkvfree(measurement);\n\tkvfree(add_data);\n\tkfree(uvio_attest);\n\tkfree(uvcb_attest);\n\treturn ret;\n}\n\n \nstatic int uvio_add_secret(struct uvio_ioctl_cb *uv_ioctl)\n{\n\tvoid __user *user_buf_arg = (void __user *)uv_ioctl->argument_addr;\n\tstruct uv_cb_guest_addr uvcb = {\n\t\t.header.len = sizeof(uvcb),\n\t\t.header.cmd = UVC_CMD_ADD_SECRET,\n\t};\n\tvoid *asrcb = NULL;\n\tint ret;\n\n\tif (uv_ioctl->argument_len > UVIO_ADD_SECRET_MAX_LEN)\n\t\treturn -EINVAL;\n\tif (uv_ioctl->argument_len == 0)\n\t\treturn -EINVAL;\n\n\tasrcb = kvzalloc(uv_ioctl->argument_len, GFP_KERNEL);\n\tif (!asrcb)\n\t\treturn -ENOMEM;\n\n\tret = -EFAULT;\n\tif (copy_from_user(asrcb, user_buf_arg, uv_ioctl->argument_len))\n\t\tgoto out;\n\n\tret = 0;\n\tuvcb.addr = (u64)asrcb;\n\tuv_call_sched(0, (u64)&uvcb);\n\tuv_ioctl->uv_rc = uvcb.header.rc;\n\tuv_ioctl->uv_rrc = uvcb.header.rrc;\n\nout:\n\tkvfree(asrcb);\n\treturn ret;\n}\n\n \nstatic int uvio_list_secrets(struct uvio_ioctl_cb *uv_ioctl)\n{\n\tvoid __user *user_buf_arg = (void __user *)uv_ioctl->argument_addr;\n\tstruct uv_cb_guest_addr uvcb = {\n\t\t.header.len = sizeof(uvcb),\n\t\t.header.cmd = UVC_CMD_LIST_SECRETS,\n\t};\n\tvoid *secrets = NULL;\n\tint ret = 0;\n\n\tif (uv_ioctl->argument_len != UVIO_LIST_SECRETS_LEN)\n\t\treturn -EINVAL;\n\n\tsecrets = kvzalloc(UVIO_LIST_SECRETS_LEN, GFP_KERNEL);\n\tif (!secrets)\n\t\treturn -ENOMEM;\n\n\tuvcb.addr = (u64)secrets;\n\tuv_call_sched(0, (u64)&uvcb);\n\tuv_ioctl->uv_rc = uvcb.header.rc;\n\tuv_ioctl->uv_rrc = uvcb.header.rrc;\n\n\tif (copy_to_user(user_buf_arg, secrets, UVIO_LIST_SECRETS_LEN))\n\t\tret = -EFAULT;\n\n\tkvfree(secrets);\n\treturn ret;\n}\n\n \nstatic int uvio_lock_secrets(struct uvio_ioctl_cb *ioctl)\n{\n\tstruct uv_cb_nodata uvcb = {\n\t\t.header.len = sizeof(uvcb),\n\t\t.header.cmd = UVC_CMD_LOCK_SECRETS,\n\t};\n\n\tif (ioctl->argument_addr || ioctl->argument_len)\n\t\treturn -EINVAL;\n\n\tuv_call(0, (u64)&uvcb);\n\tioctl->uv_rc = uvcb.header.rc;\n\tioctl->uv_rrc = uvcb.header.rrc;\n\n\treturn 0;\n}\n\nstatic int uvio_copy_and_check_ioctl(struct uvio_ioctl_cb *ioctl, void __user *argp,\n\t\t\t\t     unsigned long cmd)\n{\n\tu8 nr = _IOC_NR(cmd);\n\n\tif (_IOC_DIR(cmd) != (_IOC_READ | _IOC_WRITE))\n\t\treturn -ENOIOCTLCMD;\n\tif (_IOC_TYPE(cmd) != UVIO_TYPE_UVC)\n\t\treturn -ENOIOCTLCMD;\n\tif (nr >= UVIO_IOCTL_NUM_IOCTLS)\n\t\treturn -ENOIOCTLCMD;\n\tif (_IOC_SIZE(cmd) != sizeof(*ioctl))\n\t\treturn -ENOIOCTLCMD;\n\tif (copy_from_user(ioctl, argp, sizeof(*ioctl)))\n\t\treturn -EFAULT;\n\tif (ioctl->flags != 0)\n\t\treturn -EINVAL;\n\tif (memchr_inv(ioctl->reserved14, 0, sizeof(ioctl->reserved14)))\n\t\treturn -EINVAL;\n\n\treturn nr;\n}\n\n \nstatic long uvio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct uvio_ioctl_cb uv_ioctl = { };\n\tlong ret;\n\tint nr;\n\n\tnr = uvio_copy_and_check_ioctl(&uv_ioctl, argp, cmd);\n\tif (nr < 0)\n\t\treturn nr;\n\n\tswitch (nr) {\n\tcase UVIO_IOCTL_UVDEV_INFO_NR:\n\t\tret = uvio_uvdev_info(&uv_ioctl);\n\t\tbreak;\n\tcase UVIO_IOCTL_ATT_NR:\n\t\tret = uvio_attestation(&uv_ioctl);\n\t\tbreak;\n\tcase UVIO_IOCTL_ADD_SECRET_NR:\n\t\tret = uvio_add_secret(&uv_ioctl);\n\t\tbreak;\n\tcase UVIO_IOCTL_LIST_SECRETS_NR:\n\t\tret = uvio_list_secrets(&uv_ioctl);\n\t\tbreak;\n\tcase UVIO_IOCTL_LOCK_SECRETS_NR:\n\t\tret = uvio_lock_secrets(&uv_ioctl);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user(argp, &uv_ioctl, sizeof(uv_ioctl)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic const struct file_operations uvio_dev_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = uvio_ioctl,\n\t.llseek = no_llseek,\n};\n\nstatic struct miscdevice uvio_dev_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = UVIO_DEVICE_NAME,\n\t.fops = &uvio_dev_fops,\n};\n\nstatic void __exit uvio_dev_exit(void)\n{\n\tmisc_deregister(&uvio_dev_miscdev);\n}\n\nstatic int __init uvio_dev_init(void)\n{\n\tset_supp_uv_cmds((unsigned long *)&uvdev_info.supp_uv_cmds);\n\treturn misc_register(&uvio_dev_miscdev);\n}\n\nmodule_cpu_feature_match(S390_CPU_FEATURE_UV, uvio_dev_init);\nmodule_exit(uvio_dev_exit);\n\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Ultravisor UAPI driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}