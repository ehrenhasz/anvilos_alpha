{
  "module_name": "sclp.c",
  "hash_id": "2136fff0d20ea0611f0c609d3313ab430758e56ba696a36d416690460a2d487b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel_stat.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/panic_notifier.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/reboot.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <asm/types.h>\n#include <asm/irq.h>\n#include <asm/debug.h>\n\n#include \"sclp.h\"\n\n#define SCLP_HEADER\t\t\"sclp: \"\n\nstruct sclp_trace_entry {\n\tchar id[4] __nonstring;\n\tu32 a;\n\tu64 b;\n};\n\n#define SCLP_TRACE_ENTRY_SIZE\t\tsizeof(struct sclp_trace_entry)\n#define SCLP_TRACE_MAX_SIZE\t\t128\n#define SCLP_TRACE_EVENT_MAX_SIZE\t64\n\n \nDEFINE_STATIC_DEBUG_INFO(sclp_debug, \"sclp\", 8, 1, SCLP_TRACE_ENTRY_SIZE,\n\t\t\t &debug_hex_ascii_view);\n\n \nDEFINE_STATIC_DEBUG_INFO(sclp_debug_err, \"sclp_err\", 4, 1,\n\t\t\t SCLP_TRACE_ENTRY_SIZE, &debug_hex_ascii_view);\n\n \nstatic DEFINE_SPINLOCK(sclp_lock);\n\n \nstatic sccb_mask_t sclp_receive_mask;\n\n \nstatic sccb_mask_t sclp_send_mask;\n\n \nstatic LIST_HEAD(sclp_reg_list);\n\n \nstatic LIST_HEAD(sclp_req_queue);\n\n \nstatic struct sclp_req sclp_read_req;\nstatic struct sclp_req sclp_init_req;\nstatic void *sclp_read_sccb;\nstatic struct init_sccb *sclp_init_sccb;\n\n \nint sclp_console_pages = SCLP_CONSOLE_PAGES;\n \nbool sclp_console_drop = true;\n \nunsigned long sclp_console_full;\n\n \nstatic sclp_cmdw_t active_cmd;\n\nstatic inline void sclp_trace(int prio, char *id, u32 a, u64 b, bool err)\n{\n\tstruct sclp_trace_entry e;\n\n\tmemset(&e, 0, sizeof(e));\n\tstrncpy(e.id, id, sizeof(e.id));\n\te.a = a;\n\te.b = b;\n\tdebug_event(&sclp_debug, prio, &e, sizeof(e));\n\tif (err)\n\t\tdebug_event(&sclp_debug_err, 0, &e, sizeof(e));\n}\n\nstatic inline int no_zeroes_len(void *data, int len)\n{\n\tchar *d = data;\n\n\t \n\twhile (len > SCLP_TRACE_ENTRY_SIZE && d[len - 1] == 0)\n\t\tlen--;\n\n\treturn len;\n}\n\nstatic inline void sclp_trace_bin(int prio, void *d, int len, int errlen)\n{\n\tdebug_event(&sclp_debug, prio, d, no_zeroes_len(d, len));\n\tif (errlen)\n\t\tdebug_event(&sclp_debug_err, 0, d, no_zeroes_len(d, errlen));\n}\n\nstatic inline int abbrev_len(sclp_cmdw_t cmd, struct sccb_header *sccb)\n{\n\tstruct evbuf_header *evbuf = (struct evbuf_header *)(sccb + 1);\n\tint len = sccb->length, limit = SCLP_TRACE_MAX_SIZE;\n\n\t \n\tif (sclp_debug.level == DEBUG_MAX_LEVEL)\n\t\treturn len;\n\n\t \n\tif (cmd == SCLP_CMDW_WRITE_EVENT_DATA &&\n\t    (evbuf->type == EVTYP_MSG  || evbuf->type == EVTYP_VT220MSG))\n\t\tlimit = SCLP_TRACE_ENTRY_SIZE;\n\n\treturn min(len, limit);\n}\n\nstatic inline void sclp_trace_sccb(int prio, char *id, u32 a, u64 b,\n\t\t\t\t   sclp_cmdw_t cmd, struct sccb_header *sccb,\n\t\t\t\t   bool err)\n{\n\tsclp_trace(prio, id, a, b, err);\n\tif (sccb) {\n\t\tsclp_trace_bin(prio + 1, sccb, abbrev_len(cmd, sccb),\n\t\t\t       err ? sccb->length : 0);\n\t}\n}\n\nstatic inline void sclp_trace_evbuf(int prio, char *id, u32 a, u64 b,\n\t\t\t\t    struct evbuf_header *evbuf, bool err)\n{\n\tsclp_trace(prio, id, a, b, err);\n\tsclp_trace_bin(prio + 1, evbuf,\n\t\t       min((int)evbuf->length, (int)SCLP_TRACE_EVENT_MAX_SIZE),\n\t\t       err ? evbuf->length : 0);\n}\n\nstatic inline void sclp_trace_req(int prio, char *id, struct sclp_req *req,\n\t\t\t\t  bool err)\n{\n\tstruct sccb_header *sccb = req->sccb;\n\tunion {\n\t\tstruct {\n\t\t\tu16 status;\n\t\t\tu16 response;\n\t\t\tu16 timeout;\n\t\t\tu16 start_count;\n\t\t};\n\t\tu64 b;\n\t} summary;\n\n\tsummary.status = req->status;\n\tsummary.response = sccb ? sccb->response_code : 0;\n\tsummary.timeout = (u16)req->queue_timeout;\n\tsummary.start_count = (u16)req->start_count;\n\n\tsclp_trace(prio, id, __pa(sccb), summary.b, err);\n}\n\nstatic inline void sclp_trace_register(int prio, char *id, u32 a, u64 b,\n\t\t\t\t       struct sclp_register *reg)\n{\n\tstruct {\n\t\tu64 receive;\n\t\tu64 send;\n\t} d;\n\n\td.receive = reg->receive_mask;\n\td.send = reg->send_mask;\n\n\tsclp_trace(prio, id, a, b, false);\n\tsclp_trace_bin(prio, &d, sizeof(d), 0);\n}\n\nstatic int __init sclp_setup_console_pages(char *str)\n{\n\tint pages, rc;\n\n\trc = kstrtoint(str, 0, &pages);\n\tif (!rc && pages >= SCLP_CONSOLE_PAGES)\n\t\tsclp_console_pages = pages;\n\treturn 1;\n}\n\n__setup(\"sclp_con_pages=\", sclp_setup_console_pages);\n\nstatic int __init sclp_setup_console_drop(char *str)\n{\n\treturn kstrtobool(str, &sclp_console_drop) == 0;\n}\n\n__setup(\"sclp_con_drop=\", sclp_setup_console_drop);\n\n \nstatic struct timer_list sclp_request_timer;\n\n \nstatic struct timer_list sclp_queue_timer;\n\n \nstatic volatile enum sclp_running_state_t {\n\tsclp_running_state_idle,\n\tsclp_running_state_running,\n\tsclp_running_state_reset_pending\n} sclp_running_state = sclp_running_state_idle;\n\n \nstatic volatile enum sclp_reading_state_t {\n\tsclp_reading_state_idle,\n\tsclp_reading_state_reading\n} sclp_reading_state = sclp_reading_state_idle;\n\n \nstatic volatile enum sclp_activation_state_t {\n\tsclp_activation_state_active,\n\tsclp_activation_state_deactivating,\n\tsclp_activation_state_inactive,\n\tsclp_activation_state_activating\n} sclp_activation_state = sclp_activation_state_active;\n\n \nstatic volatile enum sclp_mask_state_t {\n\tsclp_mask_state_idle,\n\tsclp_mask_state_initializing\n} sclp_mask_state = sclp_mask_state_idle;\n\n \n#define SCLP_INIT_RETRY\t\t3\n#define SCLP_MASK_RETRY\t\t3\n\n \n#define SCLP_BUSY_INTERVAL\t10\n#define SCLP_RETRY_INTERVAL\t30\n\nstatic void sclp_request_timeout(bool force_restart);\nstatic void sclp_process_queue(void);\nstatic void __sclp_make_read_req(void);\nstatic int sclp_init_mask(int calculate);\nstatic int sclp_init(void);\n\nstatic void\n__sclp_queue_read_req(void)\n{\n\tif (sclp_reading_state == sclp_reading_state_idle) {\n\t\tsclp_reading_state = sclp_reading_state_reading;\n\t\t__sclp_make_read_req();\n\t\t \n\t\tlist_add(&sclp_read_req.list, &sclp_req_queue);\n\t}\n}\n\n \nstatic inline void\n__sclp_set_request_timer(unsigned long time, void (*cb)(struct timer_list *))\n{\n\tdel_timer(&sclp_request_timer);\n\tsclp_request_timer.function = cb;\n\tsclp_request_timer.expires = jiffies + time;\n\tadd_timer(&sclp_request_timer);\n}\n\nstatic void sclp_request_timeout_restart(struct timer_list *unused)\n{\n\tsclp_request_timeout(true);\n}\n\nstatic void sclp_request_timeout_normal(struct timer_list *unused)\n{\n\tsclp_request_timeout(false);\n}\n\n \nstatic void sclp_request_timeout(bool force_restart)\n{\n\tunsigned long flags;\n\n\t \n\tsclp_trace(2, \"TMO\", force_restart, 0, true);\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tif (force_restart) {\n\t\tif (sclp_running_state == sclp_running_state_running) {\n\t\t\t \n\t\t\t__sclp_queue_read_req();\n\t\t\tsclp_running_state = sclp_running_state_idle;\n\t\t}\n\t} else {\n\t\t__sclp_set_request_timer(SCLP_BUSY_INTERVAL * HZ,\n\t\t\t\t\t sclp_request_timeout_normal);\n\t}\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\tsclp_process_queue();\n}\n\n \nstatic unsigned long __sclp_req_queue_find_next_timeout(void)\n{\n\tunsigned long expires_next = 0;\n\tstruct sclp_req *req;\n\n\tlist_for_each_entry(req, &sclp_req_queue, list) {\n\t\tif (!req->queue_expires)\n\t\t\tcontinue;\n\t\tif (!expires_next ||\n\t\t   (time_before(req->queue_expires, expires_next)))\n\t\t\t\texpires_next = req->queue_expires;\n\t}\n\treturn expires_next;\n}\n\n \nstatic struct sclp_req *__sclp_req_queue_remove_expired_req(void)\n{\n\tunsigned long flags, now;\n\tstruct sclp_req *req;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tnow = jiffies;\n\t \n\tlist_for_each_entry(req, &sclp_req_queue, list) {\n\t\tif (!req->queue_expires)\n\t\t\tcontinue;\n\t\tif (time_before_eq(req->queue_expires, now)) {\n\t\t\tif (req->status == SCLP_REQ_QUEUED) {\n\t\t\t\treq->status = SCLP_REQ_QUEUED_TIMEOUT;\n\t\t\t\tlist_del(&req->list);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\treq = NULL;\nout:\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\treturn req;\n}\n\n \nstatic void sclp_req_queue_timeout(struct timer_list *unused)\n{\n\tunsigned long flags, expires_next;\n\tstruct sclp_req *req;\n\n\tdo {\n\t\treq = __sclp_req_queue_remove_expired_req();\n\n\t\tif (req) {\n\t\t\t \n\t\t\tsclp_trace_req(2, \"RQTM\", req, true);\n\t\t}\n\n\t\tif (req && req->callback)\n\t\t\treq->callback(req, req->callback_data);\n\t} while (req);\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\texpires_next = __sclp_req_queue_find_next_timeout();\n\tif (expires_next)\n\t\tmod_timer(&sclp_queue_timer, expires_next);\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n}\n\nstatic int sclp_service_call_trace(sclp_cmdw_t command, void *sccb)\n{\n\tstatic u64 srvc_count;\n\tint rc;\n\n\t \n\tsclp_trace_sccb(0, \"SRV1\", command, (u64)sccb, command, sccb, false);\n\n\trc = sclp_service_call(command, sccb);\n\n\t \n\tsclp_trace(0, \"SRV2\", -rc, ++srvc_count, rc != 0);\n\n\tif (rc == 0)\n\t\tactive_cmd = command;\n\n\treturn rc;\n}\n\n \nstatic int\n__sclp_start_request(struct sclp_req *req)\n{\n\tint rc;\n\n\tif (sclp_running_state != sclp_running_state_idle)\n\t\treturn 0;\n\tdel_timer(&sclp_request_timer);\n\trc = sclp_service_call_trace(req->command, req->sccb);\n\treq->start_count++;\n\n\tif (rc == 0) {\n\t\t \n\t\treq->status = SCLP_REQ_RUNNING;\n\t\tsclp_running_state = sclp_running_state_running;\n\t\t__sclp_set_request_timer(SCLP_RETRY_INTERVAL * HZ,\n\t\t\t\t\t sclp_request_timeout_restart);\n\t\treturn 0;\n\t} else if (rc == -EBUSY) {\n\t\t \n\t\t__sclp_set_request_timer(SCLP_BUSY_INTERVAL * HZ,\n\t\t\t\t\t sclp_request_timeout_normal);\n\t\treturn 0;\n\t}\n\t \n\treq->status = SCLP_REQ_FAILED;\n\treturn rc;\n}\n\n \nstatic void\nsclp_process_queue(void)\n{\n\tstruct sclp_req *req;\n\tint rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tif (sclp_running_state != sclp_running_state_idle) {\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\treturn;\n\t}\n\tdel_timer(&sclp_request_timer);\n\twhile (!list_empty(&sclp_req_queue)) {\n\t\treq = list_entry(sclp_req_queue.next, struct sclp_req, list);\n\t\trc = __sclp_start_request(req);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t\t \n\t\tif (req->start_count > 1) {\n\t\t\t \n\t\t\t__sclp_set_request_timer(SCLP_BUSY_INTERVAL * HZ,\n\t\t\t\t\t\t sclp_request_timeout_normal);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tlist_del(&req->list);\n\n\t\t \n\t\tsclp_trace_req(2, \"RQAB\", req, true);\n\n\t\tif (req->callback) {\n\t\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\t\treq->callback(req, req->callback_data);\n\t\t\tspin_lock_irqsave(&sclp_lock, flags);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n}\n\nstatic int __sclp_can_add_request(struct sclp_req *req)\n{\n\tif (req == &sclp_init_req)\n\t\treturn 1;\n\tif (sclp_init_state != sclp_init_state_initialized)\n\t\treturn 0;\n\tif (sclp_activation_state != sclp_activation_state_active)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint\nsclp_add_request(struct sclp_req *req)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tif (!__sclp_can_add_request(req)) {\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\treturn -EIO;\n\t}\n\n\t \n\tsclp_trace(2, \"RQAD\", __pa(req->sccb), _RET_IP_, false);\n\n\treq->status = SCLP_REQ_QUEUED;\n\treq->start_count = 0;\n\tlist_add_tail(&req->list, &sclp_req_queue);\n\trc = 0;\n\tif (req->queue_timeout) {\n\t\treq->queue_expires = jiffies + req->queue_timeout * HZ;\n\t\tif (!timer_pending(&sclp_queue_timer) ||\n\t\t    time_after(sclp_queue_timer.expires, req->queue_expires))\n\t\t\tmod_timer(&sclp_queue_timer, req->queue_expires);\n\t} else\n\t\treq->queue_expires = 0;\n\t \n\tif (sclp_running_state == sclp_running_state_idle &&\n\t    req->list.prev == &sclp_req_queue) {\n\t\trc = __sclp_start_request(req);\n\t\tif (rc)\n\t\t\tlist_del(&req->list);\n\t}\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\treturn rc;\n}\n\nEXPORT_SYMBOL(sclp_add_request);\n\n \nstatic int\nsclp_dispatch_evbufs(struct sccb_header *sccb)\n{\n\tunsigned long flags;\n\tstruct evbuf_header *evbuf;\n\tstruct list_head *l;\n\tstruct sclp_register *reg;\n\tint offset;\n\tint rc;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\trc = 0;\n\tfor (offset = sizeof(struct sccb_header); offset < sccb->length;\n\t     offset += evbuf->length) {\n\t\tevbuf = (struct evbuf_header *) ((addr_t) sccb + offset);\n\t\t \n\t\tif (evbuf->length == 0)\n\t\t\tbreak;\n\t\t \n\t\treg = NULL;\n\t\tlist_for_each(l, &sclp_reg_list) {\n\t\t\treg = list_entry(l, struct sclp_register, list);\n\t\t\tif (reg->receive_mask & SCLP_EVTYP_MASK(evbuf->type))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\treg = NULL;\n\t\t}\n\n\t\t \n\t\tsclp_trace_evbuf(2, \"EVNT\", 0, reg ? (u64)reg->receiver_fn : 0,\n\t\t\t\t evbuf, !reg);\n\n\t\tif (reg && reg->receiver_fn) {\n\t\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\t\treg->receiver_fn(evbuf);\n\t\t\tspin_lock_irqsave(&sclp_lock, flags);\n\t\t} else if (reg == NULL)\n\t\t\trc = -EOPNOTSUPP;\n\t}\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\treturn rc;\n}\n\n \nstatic void\nsclp_read_cb(struct sclp_req *req, void *data)\n{\n\tunsigned long flags;\n\tstruct sccb_header *sccb;\n\n\tsccb = (struct sccb_header *) req->sccb;\n\tif (req->status == SCLP_REQ_DONE && (sccb->response_code == 0x20 ||\n\t    sccb->response_code == 0x220))\n\t\tsclp_dispatch_evbufs(sccb);\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tsclp_reading_state = sclp_reading_state_idle;\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n}\n\n \nstatic void __sclp_make_read_req(void)\n{\n\tstruct sccb_header *sccb;\n\n\tsccb = (struct sccb_header *) sclp_read_sccb;\n\tclear_page(sccb);\n\tmemset(&sclp_read_req, 0, sizeof(struct sclp_req));\n\tsclp_read_req.command = SCLP_CMDW_READ_EVENT_DATA;\n\tsclp_read_req.status = SCLP_REQ_QUEUED;\n\tsclp_read_req.start_count = 0;\n\tsclp_read_req.callback = sclp_read_cb;\n\tsclp_read_req.sccb = sccb;\n\tsccb->length = PAGE_SIZE;\n\tsccb->function_code = 0;\n\tsccb->control_mask[2] = 0x80;\n}\n\n \nstatic inline struct sclp_req *\n__sclp_find_req(u32 sccb)\n{\n\tstruct list_head *l;\n\tstruct sclp_req *req;\n\n\tlist_for_each(l, &sclp_req_queue) {\n\t\treq = list_entry(l, struct sclp_req, list);\n\t\tif (sccb == __pa(req->sccb))\n\t\t\treturn req;\n\t}\n\treturn NULL;\n}\n\nstatic bool ok_response(u32 sccb_int, sclp_cmdw_t cmd)\n{\n\tstruct sccb_header *sccb = (struct sccb_header *)__va(sccb_int);\n\tstruct evbuf_header *evbuf;\n\tu16 response;\n\n\tif (!sccb)\n\t\treturn true;\n\n\t \n\tresponse = sccb->response_code & 0xff;\n\tif (response != 0x10 && response != 0x20)\n\t\treturn false;\n\n\t \n\tif (cmd == SCLP_CMDW_WRITE_EVENT_DATA) {\n\t\tevbuf = (struct evbuf_header *)(sccb + 1);\n\t\tif (!(evbuf->flags & 0x80))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void sclp_interrupt_handler(struct ext_code ext_code,\n\t\t\t\t   unsigned int param32, unsigned long param64)\n{\n\tstruct sclp_req *req;\n\tu32 finished_sccb;\n\tu32 evbuf_pending;\n\n\tinc_irq_stat(IRQEXT_SCP);\n\tspin_lock(&sclp_lock);\n\tfinished_sccb = param32 & 0xfffffff8;\n\tevbuf_pending = param32 & 0x3;\n\n\t \n\tsclp_trace_sccb(0, \"INT\", param32, active_cmd, active_cmd,\n\t\t\t(struct sccb_header *)__va(finished_sccb),\n\t\t\t!ok_response(finished_sccb, active_cmd));\n\n\tif (finished_sccb) {\n\t\tdel_timer(&sclp_request_timer);\n\t\tsclp_running_state = sclp_running_state_reset_pending;\n\t\treq = __sclp_find_req(finished_sccb);\n\t\tif (req) {\n\t\t\t \n\t\t\tlist_del(&req->list);\n\t\t\treq->status = SCLP_REQ_DONE;\n\n\t\t\t \n\t\t\tsclp_trace_req(2, \"RQOK\", req, false);\n\n\t\t\tif (req->callback) {\n\t\t\t\tspin_unlock(&sclp_lock);\n\t\t\t\treq->callback(req, req->callback_data);\n\t\t\t\tspin_lock(&sclp_lock);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tsclp_trace(0, \"UNEX\", finished_sccb, 0, true);\n\t\t}\n\t\tsclp_running_state = sclp_running_state_idle;\n\t\tactive_cmd = 0;\n\t}\n\tif (evbuf_pending &&\n\t    sclp_activation_state == sclp_activation_state_active)\n\t\t__sclp_queue_read_req();\n\tspin_unlock(&sclp_lock);\n\tsclp_process_queue();\n}\n\n \nstatic inline u64\nsclp_tod_from_jiffies(unsigned long jiffies)\n{\n\treturn (u64) (jiffies / HZ) << 32;\n}\n\n \nvoid\nsclp_sync_wait(void)\n{\n\tunsigned long long old_tick;\n\tunsigned long flags;\n\tunsigned long cr0, cr0_sync;\n\tstatic u64 sync_count;\n\tu64 timeout;\n\tint irq_context;\n\n\t \n\tsclp_trace(4, \"SYN1\", sclp_running_state, ++sync_count, false);\n\n\t \n\ttimeout = 0;\n\tif (timer_pending(&sclp_request_timer)) {\n\t\t \n\t\ttimeout = get_tod_clock_fast() +\n\t\t\t  sclp_tod_from_jiffies(sclp_request_timer.expires -\n\t\t\t\t\t\tjiffies);\n\t}\n\tlocal_irq_save(flags);\n\t \n\tirq_context = in_interrupt();\n\tif (!irq_context)\n\t\tlocal_bh_disable();\n\t \n\told_tick = local_tick_disable();\n\ttrace_hardirqs_on();\n\t__ctl_store(cr0, 0, 0);\n\tcr0_sync = cr0 & ~CR0_IRQ_SUBCLASS_MASK;\n\tcr0_sync |= 1UL << (63 - 54);\n\t__ctl_load(cr0_sync, 0, 0);\n\t__arch_local_irq_stosm(0x01);\n\t \n\twhile (sclp_running_state != sclp_running_state_idle) {\n\t\t \n\t\tif (get_tod_clock_fast() > timeout && del_timer(&sclp_request_timer))\n\t\t\tsclp_request_timer.function(&sclp_request_timer);\n\t\tcpu_relax();\n\t}\n\tlocal_irq_disable();\n\t__ctl_load(cr0, 0, 0);\n\tif (!irq_context)\n\t\t_local_bh_enable();\n\tlocal_tick_enable(old_tick);\n\tlocal_irq_restore(flags);\n\n\t \n\tsclp_trace(4, \"SYN2\", sclp_running_state, sync_count, false);\n}\nEXPORT_SYMBOL(sclp_sync_wait);\n\n \nstatic void\nsclp_dispatch_state_change(void)\n{\n\tstruct list_head *l;\n\tstruct sclp_register *reg;\n\tunsigned long flags;\n\tsccb_mask_t receive_mask;\n\tsccb_mask_t send_mask;\n\n\tdo {\n\t\tspin_lock_irqsave(&sclp_lock, flags);\n\t\treg = NULL;\n\t\tlist_for_each(l, &sclp_reg_list) {\n\t\t\treg = list_entry(l, struct sclp_register, list);\n\t\t\treceive_mask = reg->send_mask & sclp_receive_mask;\n\t\t\tsend_mask = reg->receive_mask & sclp_send_mask;\n\t\t\tif (reg->sclp_receive_mask != receive_mask ||\n\t\t\t    reg->sclp_send_mask != send_mask) {\n\t\t\t\treg->sclp_receive_mask = receive_mask;\n\t\t\t\treg->sclp_send_mask = send_mask;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treg = NULL;\n\t\t}\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\tif (reg && reg->state_change_fn) {\n\t\t\t \n\t\t\tsclp_trace(2, \"STCG\", 0, (u64)reg->state_change_fn,\n\t\t\t\t   false);\n\n\t\t\treg->state_change_fn(reg);\n\t\t}\n\t} while (reg);\n}\n\nstruct sclp_statechangebuf {\n\tstruct evbuf_header\theader;\n\tu8\t\tvalidity_sclp_active_facility_mask : 1;\n\tu8\t\tvalidity_sclp_receive_mask : 1;\n\tu8\t\tvalidity_sclp_send_mask : 1;\n\tu8\t\tvalidity_read_data_function_mask : 1;\n\tu16\t\t_zeros : 12;\n\tu16\t\tmask_length;\n\tu64\t\tsclp_active_facility_mask;\n\tu8\t\tmasks[2 * 1021 + 4];\t \n\t \n} __attribute__((packed));\n\n\n \nstatic void\nsclp_state_change_cb(struct evbuf_header *evbuf)\n{\n\tunsigned long flags;\n\tstruct sclp_statechangebuf *scbuf;\n\n\tBUILD_BUG_ON(sizeof(struct sclp_statechangebuf) > PAGE_SIZE);\n\n\tscbuf = (struct sclp_statechangebuf *) evbuf;\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tif (scbuf->validity_sclp_receive_mask)\n\t\tsclp_receive_mask = sccb_get_recv_mask(scbuf);\n\tif (scbuf->validity_sclp_send_mask)\n\t\tsclp_send_mask = sccb_get_send_mask(scbuf);\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\tif (scbuf->validity_sclp_active_facility_mask)\n\t\tsclp.facilities = scbuf->sclp_active_facility_mask;\n\tsclp_dispatch_state_change();\n}\n\nstatic struct sclp_register sclp_state_change_event = {\n\t.receive_mask = EVTYP_STATECHANGE_MASK,\n\t.receiver_fn = sclp_state_change_cb\n};\n\n \nstatic inline void\n__sclp_get_mask(sccb_mask_t *receive_mask, sccb_mask_t *send_mask)\n{\n\tstruct list_head *l;\n\tstruct sclp_register *t;\n\n\t*receive_mask = 0;\n\t*send_mask = 0;\n\tlist_for_each(l, &sclp_reg_list) {\n\t\tt = list_entry(l, struct sclp_register, list);\n\t\t*receive_mask |= t->receive_mask;\n\t\t*send_mask |= t->send_mask;\n\t}\n}\n\n \nint\nsclp_register(struct sclp_register *reg)\n{\n\tunsigned long flags;\n\tsccb_mask_t receive_mask;\n\tsccb_mask_t send_mask;\n\tint rc;\n\n\t \n\tsclp_trace_register(2, \"REG\", 0, _RET_IP_, reg);\n\n\trc = sclp_init();\n\tif (rc)\n\t\treturn rc;\n\tspin_lock_irqsave(&sclp_lock, flags);\n\t \n\t__sclp_get_mask(&receive_mask, &send_mask);\n\tif (reg->receive_mask & receive_mask || reg->send_mask & send_mask) {\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\t \n\treg->sclp_receive_mask = 0;\n\treg->sclp_send_mask = 0;\n\tlist_add(&reg->list, &sclp_reg_list);\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\trc = sclp_init_mask(1);\n\tif (rc) {\n\t\tspin_lock_irqsave(&sclp_lock, flags);\n\t\tlist_del(&reg->list);\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t}\n\treturn rc;\n}\n\nEXPORT_SYMBOL(sclp_register);\n\n \nvoid\nsclp_unregister(struct sclp_register *reg)\n{\n\tunsigned long flags;\n\n\t \n\tsclp_trace_register(2, \"UREG\", 0, _RET_IP_, reg);\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tlist_del(&reg->list);\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\tsclp_init_mask(1);\n}\n\nEXPORT_SYMBOL(sclp_unregister);\n\n \nint\nsclp_remove_processed(struct sccb_header *sccb)\n{\n\tstruct evbuf_header *evbuf;\n\tint unprocessed;\n\tu16 remaining;\n\n\tevbuf = (struct evbuf_header *) (sccb + 1);\n\tunprocessed = 0;\n\tremaining = sccb->length - sizeof(struct sccb_header);\n\twhile (remaining > 0) {\n\t\tremaining -= evbuf->length;\n\t\tif (evbuf->flags & 0x80) {\n\t\t\tsccb->length -= evbuf->length;\n\t\t\tmemcpy(evbuf, (void *) ((addr_t) evbuf + evbuf->length),\n\t\t\t       remaining);\n\t\t} else {\n\t\t\tunprocessed++;\n\t\t\tevbuf = (struct evbuf_header *)\n\t\t\t\t\t((addr_t) evbuf + evbuf->length);\n\t\t}\n\t}\n\treturn unprocessed;\n}\n\nEXPORT_SYMBOL(sclp_remove_processed);\n\n \nstatic inline void\n__sclp_make_init_req(sccb_mask_t receive_mask, sccb_mask_t send_mask)\n{\n\tstruct init_sccb *sccb = sclp_init_sccb;\n\n\tclear_page(sccb);\n\tmemset(&sclp_init_req, 0, sizeof(struct sclp_req));\n\tsclp_init_req.command = SCLP_CMDW_WRITE_EVENT_MASK;\n\tsclp_init_req.status = SCLP_REQ_FILLED;\n\tsclp_init_req.start_count = 0;\n\tsclp_init_req.callback = NULL;\n\tsclp_init_req.callback_data = NULL;\n\tsclp_init_req.sccb = sccb;\n\tsccb->header.length = sizeof(*sccb);\n\tif (sclp_mask_compat_mode)\n\t\tsccb->mask_length = SCLP_MASK_SIZE_COMPAT;\n\telse\n\t\tsccb->mask_length = sizeof(sccb_mask_t);\n\tsccb_set_recv_mask(sccb, receive_mask);\n\tsccb_set_send_mask(sccb, send_mask);\n\tsccb_set_sclp_recv_mask(sccb, 0);\n\tsccb_set_sclp_send_mask(sccb, 0);\n}\n\n \nstatic int\nsclp_init_mask(int calculate)\n{\n\tunsigned long flags;\n\tstruct init_sccb *sccb = sclp_init_sccb;\n\tsccb_mask_t receive_mask;\n\tsccb_mask_t send_mask;\n\tint retry;\n\tint rc;\n\tunsigned long wait;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\t \n\tif (sclp_mask_state != sclp_mask_state_idle) {\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tif (sclp_activation_state == sclp_activation_state_inactive) {\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tsclp_mask_state = sclp_mask_state_initializing;\n\t \n\tif (calculate)\n\t\t__sclp_get_mask(&receive_mask, &send_mask);\n\telse {\n\t\treceive_mask = 0;\n\t\tsend_mask = 0;\n\t}\n\trc = -EIO;\n\tfor (retry = 0; retry <= SCLP_MASK_RETRY; retry++) {\n\t\t \n\t\t__sclp_make_init_req(receive_mask, send_mask);\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\tif (sclp_add_request(&sclp_init_req)) {\n\t\t\t \n\t\t\twait = jiffies + SCLP_BUSY_INTERVAL * HZ;\n\t\t\twhile (time_before(jiffies, wait))\n\t\t\t\tsclp_sync_wait();\n\t\t\tspin_lock_irqsave(&sclp_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sclp_init_req.status != SCLP_REQ_DONE &&\n\t\t       sclp_init_req.status != SCLP_REQ_FAILED)\n\t\t\tsclp_sync_wait();\n\t\tspin_lock_irqsave(&sclp_lock, flags);\n\t\tif (sclp_init_req.status == SCLP_REQ_DONE &&\n\t\t    sccb->header.response_code == 0x20) {\n\t\t\t \n\t\t\tif (calculate) {\n\t\t\t\tsclp_receive_mask = sccb_get_sclp_recv_mask(sccb);\n\t\t\t\tsclp_send_mask = sccb_get_sclp_send_mask(sccb);\n\t\t\t} else {\n\t\t\t\tsclp_receive_mask = 0;\n\t\t\t\tsclp_send_mask = 0;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\t\tsclp_dispatch_state_change();\n\t\t\tspin_lock_irqsave(&sclp_lock, flags);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsclp_mask_state = sclp_mask_state_idle;\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\treturn rc;\n}\n\n \nint\nsclp_deactivate(void)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\t \n\tif (sclp_activation_state != sclp_activation_state_active) {\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tsclp_activation_state = sclp_activation_state_deactivating;\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\trc = sclp_init_mask(0);\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tif (rc == 0)\n\t\tsclp_activation_state = sclp_activation_state_inactive;\n\telse\n\t\tsclp_activation_state = sclp_activation_state_active;\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\treturn rc;\n}\n\nEXPORT_SYMBOL(sclp_deactivate);\n\n \nint\nsclp_reactivate(void)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\t \n\tif (sclp_activation_state != sclp_activation_state_inactive) {\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tsclp_activation_state = sclp_activation_state_activating;\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\trc = sclp_init_mask(1);\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tif (rc == 0)\n\t\tsclp_activation_state = sclp_activation_state_active;\n\telse\n\t\tsclp_activation_state = sclp_activation_state_inactive;\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\treturn rc;\n}\n\nEXPORT_SYMBOL(sclp_reactivate);\n\n \nstatic void sclp_check_handler(struct ext_code ext_code,\n\t\t\t       unsigned int param32, unsigned long param64)\n{\n\tu32 finished_sccb;\n\n\tinc_irq_stat(IRQEXT_SCP);\n\tfinished_sccb = param32 & 0xfffffff8;\n\t \n\tif (finished_sccb == 0)\n\t\treturn;\n\tif (finished_sccb != __pa(sclp_init_sccb))\n\t\tpanic(\"sclp: unsolicited interrupt for buffer at 0x%x\\n\",\n\t\t      finished_sccb);\n\tspin_lock(&sclp_lock);\n\tif (sclp_running_state == sclp_running_state_running) {\n\t\tsclp_init_req.status = SCLP_REQ_DONE;\n\t\tsclp_running_state = sclp_running_state_idle;\n\t}\n\tspin_unlock(&sclp_lock);\n}\n\n \nstatic void\nsclp_check_timeout(struct timer_list *unused)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tif (sclp_running_state == sclp_running_state_running) {\n\t\tsclp_init_req.status = SCLP_REQ_FAILED;\n\t\tsclp_running_state = sclp_running_state_idle;\n\t}\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n}\n\n \nstatic int\nsclp_check_interface(void)\n{\n\tstruct init_sccb *sccb;\n\tunsigned long flags;\n\tint retry;\n\tint rc;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\t \n\trc = register_external_irq(EXT_IRQ_SERVICE_SIG, sclp_check_handler);\n\tif (rc) {\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\treturn rc;\n\t}\n\tfor (retry = 0; retry <= SCLP_INIT_RETRY; retry++) {\n\t\t__sclp_make_init_req(0, 0);\n\t\tsccb = (struct init_sccb *) sclp_init_req.sccb;\n\t\trc = sclp_service_call_trace(sclp_init_req.command, sccb);\n\t\tif (rc == -EIO)\n\t\t\tbreak;\n\t\tsclp_init_req.status = SCLP_REQ_RUNNING;\n\t\tsclp_running_state = sclp_running_state_running;\n\t\t__sclp_set_request_timer(SCLP_RETRY_INTERVAL * HZ,\n\t\t\t\t\t sclp_check_timeout);\n\t\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t\t \n\t\tirq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);\n\t\t \n\t\tsclp_sync_wait();\n\t\t \n\t\tirq_subclass_unregister(IRQ_SUBCLASS_SERVICE_SIGNAL);\n\t\tspin_lock_irqsave(&sclp_lock, flags);\n\t\tdel_timer(&sclp_request_timer);\n\t\trc = -EBUSY;\n\t\tif (sclp_init_req.status == SCLP_REQ_DONE) {\n\t\t\tif (sccb->header.response_code == 0x20) {\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t} else if (sccb->header.response_code == 0x74f0) {\n\t\t\t\tif (!sclp_mask_compat_mode) {\n\t\t\t\t\tsclp_mask_compat_mode = true;\n\t\t\t\t\tretry = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tunregister_external_irq(EXT_IRQ_SERVICE_SIG, sclp_check_handler);\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\treturn rc;\n}\n\n \nstatic int\nsclp_reboot_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tsclp_deactivate();\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block sclp_reboot_notifier = {\n\t.notifier_call = sclp_reboot_event\n};\n\nstatic ssize_t con_pages_show(struct device_driver *dev, char *buf)\n{\n\treturn sysfs_emit(buf, \"%i\\n\", sclp_console_pages);\n}\n\nstatic DRIVER_ATTR_RO(con_pages);\n\nstatic ssize_t con_drop_store(struct device_driver *dev, const char *buf, size_t count)\n{\n\tint rc;\n\n\trc = kstrtobool(buf, &sclp_console_drop);\n\treturn rc ?: count;\n}\n\nstatic ssize_t con_drop_show(struct device_driver *dev, char *buf)\n{\n\treturn sysfs_emit(buf, \"%i\\n\", sclp_console_drop);\n}\n\nstatic DRIVER_ATTR_RW(con_drop);\n\nstatic ssize_t con_full_show(struct device_driver *dev, char *buf)\n{\n\treturn sysfs_emit(buf, \"%lu\\n\", sclp_console_full);\n}\n\nstatic DRIVER_ATTR_RO(con_full);\n\nstatic struct attribute *sclp_drv_attrs[] = {\n\t&driver_attr_con_pages.attr,\n\t&driver_attr_con_drop.attr,\n\t&driver_attr_con_full.attr,\n\tNULL,\n};\nstatic struct attribute_group sclp_drv_attr_group = {\n\t.attrs = sclp_drv_attrs,\n};\nstatic const struct attribute_group *sclp_drv_attr_groups[] = {\n\t&sclp_drv_attr_group,\n\tNULL,\n};\n\nstatic struct platform_driver sclp_pdrv = {\n\t.driver = {\n\t\t.name\t= \"sclp\",\n\t\t.groups = sclp_drv_attr_groups,\n\t},\n};\n\n \nstatic int\nsclp_init(void)\n{\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&sclp_lock, flags);\n\t \n\tif (sclp_init_state != sclp_init_state_uninitialized)\n\t\tgoto fail_unlock;\n\tsclp_init_state = sclp_init_state_initializing;\n\tsclp_read_sccb = (void *) __get_free_page(GFP_ATOMIC | GFP_DMA);\n\tsclp_init_sccb = (void *) __get_free_page(GFP_ATOMIC | GFP_DMA);\n\tBUG_ON(!sclp_read_sccb || !sclp_init_sccb);\n\t \n\tlist_add(&sclp_state_change_event.list, &sclp_reg_list);\n\ttimer_setup(&sclp_request_timer, NULL, 0);\n\ttimer_setup(&sclp_queue_timer, sclp_req_queue_timeout, 0);\n\t \n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\trc = sclp_check_interface();\n\tspin_lock_irqsave(&sclp_lock, flags);\n\tif (rc)\n\t\tgoto fail_init_state_uninitialized;\n\t \n\trc = register_reboot_notifier(&sclp_reboot_notifier);\n\tif (rc)\n\t\tgoto fail_init_state_uninitialized;\n\t \n\trc = register_external_irq(EXT_IRQ_SERVICE_SIG, sclp_interrupt_handler);\n\tif (rc)\n\t\tgoto fail_unregister_reboot_notifier;\n\tsclp_init_state = sclp_init_state_initialized;\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\t \n\tirq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);\n\tsclp_init_mask(1);\n\treturn 0;\n\nfail_unregister_reboot_notifier:\n\tunregister_reboot_notifier(&sclp_reboot_notifier);\nfail_init_state_uninitialized:\n\tsclp_init_state = sclp_init_state_uninitialized;\n\tfree_page((unsigned long) sclp_read_sccb);\n\tfree_page((unsigned long) sclp_init_sccb);\nfail_unlock:\n\tspin_unlock_irqrestore(&sclp_lock, flags);\n\treturn rc;\n}\n\nstatic __init int sclp_initcall(void)\n{\n\tint rc;\n\n\trc = platform_driver_register(&sclp_pdrv);\n\tif (rc)\n\t\treturn rc;\n\n\treturn sclp_init();\n}\n\narch_initcall(sclp_initcall);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}