{
  "module_name": "sclp.h",
  "hash_id": "8314fd5bb5c582a8e2036abab94d8e9d2fd13ff62a4e5ad1bbf20b780decccef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp.h",
  "human_readable_source": " \n \n\n#ifndef __SCLP_H__\n#define __SCLP_H__\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <asm/asm-extable.h>\n#include <asm/sclp.h>\n#include <asm/ebcdic.h>\n\n \n#define MAX_KMEM_PAGES (sizeof(unsigned long) << 3)\n#define SCLP_CONSOLE_PAGES\t6\n\n#define SCLP_EVTYP_MASK(T) (1UL << (sizeof(sccb_mask_t) * BITS_PER_BYTE - (T)))\n\n#define EVTYP_OPCMD\t\t0x01\n#define EVTYP_MSG\t\t0x02\n#define EVTYP_CONFMGMDATA\t0x04\n#define EVTYP_DIAG_TEST\t\t0x07\n#define EVTYP_STATECHANGE\t0x08\n#define EVTYP_PMSGCMD\t\t0x09\n#define EVTYP_ASYNC\t\t0x0A\n#define EVTYP_CTLPROGIDENT\t0x0B\n#define EVTYP_STORE_DATA\t0x0C\n#define EVTYP_ERRNOTIFY\t\t0x18\n#define EVTYP_VT220MSG\t\t0x1A\n#define EVTYP_SDIAS\t\t0x1C\n#define EVTYP_SIGQUIESCE\t0x1D\n#define EVTYP_OCF\t\t0x1E\n\n#define EVTYP_OPCMD_MASK\tSCLP_EVTYP_MASK(EVTYP_OPCMD)\n#define EVTYP_MSG_MASK\t\tSCLP_EVTYP_MASK(EVTYP_MSG)\n#define EVTYP_CONFMGMDATA_MASK\tSCLP_EVTYP_MASK(EVTYP_CONFMGMDATA)\n#define EVTYP_DIAG_TEST_MASK\tSCLP_EVTYP_MASK(EVTYP_DIAG_TEST)\n#define EVTYP_STATECHANGE_MASK\tSCLP_EVTYP_MASK(EVTYP_STATECHANGE)\n#define EVTYP_PMSGCMD_MASK\tSCLP_EVTYP_MASK(EVTYP_PMSGCMD)\n#define EVTYP_ASYNC_MASK\tSCLP_EVTYP_MASK(EVTYP_ASYNC)\n#define EVTYP_CTLPROGIDENT_MASK\tSCLP_EVTYP_MASK(EVTYP_CTLPROGIDENT)\n#define EVTYP_STORE_DATA_MASK\tSCLP_EVTYP_MASK(EVTYP_STORE_DATA)\n#define EVTYP_ERRNOTIFY_MASK\tSCLP_EVTYP_MASK(EVTYP_ERRNOTIFY)\n#define EVTYP_VT220MSG_MASK\tSCLP_EVTYP_MASK(EVTYP_VT220MSG)\n#define EVTYP_SDIAS_MASK\tSCLP_EVTYP_MASK(EVTYP_SDIAS)\n#define EVTYP_SIGQUIESCE_MASK\tSCLP_EVTYP_MASK(EVTYP_SIGQUIESCE)\n#define EVTYP_OCF_MASK\t\tSCLP_EVTYP_MASK(EVTYP_OCF)\n\n#define GNRLMSGFLGS_DOM\t\t0x8000\n#define GNRLMSGFLGS_SNDALRM\t0x4000\n#define GNRLMSGFLGS_HOLDMSG\t0x2000\n\n#define LNTPFLGS_CNTLTEXT\t0x8000\n#define LNTPFLGS_LABELTEXT\t0x4000\n#define LNTPFLGS_DATATEXT\t0x2000\n#define LNTPFLGS_ENDTEXT\t0x1000\n#define LNTPFLGS_PROMPTTEXT\t0x0800\n\ntypedef unsigned int sclp_cmdw_t;\n\n#define SCLP_CMDW_READ_CPU_INFO\t\t0x00010001\n#define SCLP_CMDW_READ_SCP_INFO\t\t0x00020001\n#define SCLP_CMDW_READ_STORAGE_INFO\t0x00040001\n#define SCLP_CMDW_READ_SCP_INFO_FORCED\t0x00120001\n#define SCLP_CMDW_READ_EVENT_DATA\t0x00770005\n#define SCLP_CMDW_WRITE_EVENT_DATA\t0x00760005\n#define SCLP_CMDW_WRITE_EVENT_MASK\t0x00780005\n\n#define GDS_ID_MDSMU\t\t0x1310\n#define GDS_ID_MDSROUTEINFO\t0x1311\n#define GDS_ID_AGUNWRKCORR\t0x1549\n#define GDS_ID_SNACONDREPORT\t0x1532\n#define GDS_ID_CPMSU\t\t0x1212\n#define GDS_ID_ROUTTARGINSTR\t0x154D\n#define GDS_ID_OPREQ\t\t0x8070\n#define GDS_ID_TEXTCMD\t\t0x1320\n\n#define GDS_KEY_SELFDEFTEXTMSG\t0x31\n\ntypedef u64 sccb_mask_t;\n\nstruct sccb_header {\n\tu16\tlength;\n\tu8\tfunction_code;\n\tu8\tcontrol_mask[3];\n\tu16\tresponse_code;\n} __attribute__((packed));\n\nstruct init_sccb {\n\tstruct sccb_header header;\n\tu16 _reserved;\n\tu16 mask_length;\n\tu8 masks[4 * 1021];\t \n\t \n} __attribute__((packed));\n\n#define SCLP_MASK_SIZE_COMPAT 4\n\nstatic inline sccb_mask_t sccb_get_mask(u8 *masks, size_t len, int i)\n{\n\tsccb_mask_t res = 0;\n\n\tmemcpy(&res, masks + i * len, min(sizeof(res), len));\n\treturn res;\n}\n\nstatic inline void sccb_set_mask(u8 *masks, size_t len, int i, sccb_mask_t val)\n{\n\tmemset(masks + i * len, 0, len);\n\tmemcpy(masks + i * len, &val, min(sizeof(val), len));\n}\n\n#define sccb_get_generic_mask(sccb, i)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__typeof__(sccb) __sccb = sccb;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tsccb_get_mask(__sccb->masks, __sccb->mask_length, i);\t\t\\\n})\n#define sccb_get_recv_mask(sccb)\tsccb_get_generic_mask(sccb, 0)\n#define sccb_get_send_mask(sccb)\tsccb_get_generic_mask(sccb, 1)\n#define sccb_get_sclp_recv_mask(sccb)\tsccb_get_generic_mask(sccb, 2)\n#define sccb_get_sclp_send_mask(sccb)\tsccb_get_generic_mask(sccb, 3)\n\n#define sccb_set_generic_mask(sccb, i, val)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__typeof__(sccb) __sccb = sccb;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tsccb_set_mask(__sccb->masks, __sccb->mask_length, i, val);\t\\\n})\n#define sccb_set_recv_mask(sccb, val)\t    sccb_set_generic_mask(sccb, 0, val)\n#define sccb_set_send_mask(sccb, val)\t    sccb_set_generic_mask(sccb, 1, val)\n#define sccb_set_sclp_recv_mask(sccb, val)  sccb_set_generic_mask(sccb, 2, val)\n#define sccb_set_sclp_send_mask(sccb, val)  sccb_set_generic_mask(sccb, 3, val)\n\nstruct read_cpu_info_sccb {\n\tstruct\tsccb_header header;\n\tu16\tnr_configured;\n\tu16\toffset_configured;\n\tu16\tnr_standby;\n\tu16\toffset_standby;\n\t \n\tu8\treserved[];\n} __attribute__((packed, aligned(PAGE_SIZE)));\n\nstruct read_info_sccb {\n\tstruct\tsccb_header header;\t \n\tu16\trnmax;\t\t\t \n\tu8\trnsize;\t\t\t \n\tu8\t_pad_11[16 - 11];\t \n\tu16\tncpurl;\t\t\t \n\tu16\tcpuoff;\t\t\t \n\tu8\t_pad_20[24 - 20];\t \n\tu8\tloadparm[8];\t\t \n\tu8\t_pad_32[42 - 32];\t \n\tu8\tfac42;\t\t\t \n\tu8\tfac43;\t\t\t \n\tu8\t_pad_44[48 - 44];\t \n\tu64\tfacilities;\t\t \n\tu8\t_pad_56[66 - 56];\t \n\tu8\tfac66;\t\t\t \n\tu8\t_pad_67[76 - 67];\t \n\tu32\tibc;\t\t\t \n\tu8\t_pad80[84 - 80];\t \n\tu8\tfac84;\t\t\t \n\tu8\tfac85;\t\t\t \n\tu8\t_pad_86[91 - 86];\t \n\tu8\tfac91;\t\t\t \n\tu8\t_pad_92[98 - 92];\t \n\tu8\tfac98;\t\t\t \n\tu8\thamaxpow;\t\t \n\tu32\trnsize2;\t\t \n\tu64\trnmax2;\t\t\t \n\tu32\thsa_size;\t\t \n\tu8\tfac116;\t\t\t \n\tu8\tfac117;\t\t\t \n\tu8\tfac118;\t\t\t \n\tu8\tfac119;\t\t\t \n\tu16\thcpua;\t\t\t \n\tu8\t_pad_122[124 - 122];\t \n\tu32\thmfai;\t\t\t \n\tu8\t_pad_128[134 - 128];\t \n\tu8\tbyte_134;\t\t\t \n\tu8\tcpudirq;\t\t \n\tu16\tcbl;\t\t\t \n\tu8\t_pad_138[EXT_SCCB_READ_SCP - 138];\n} __packed __aligned(PAGE_SIZE);\n\nstruct read_storage_sccb {\n\tstruct sccb_header header;\n\tu16 max_id;\n\tu16 assigned;\n\tu16 standby;\n\tu16 :16;\n\tu32 entries[];\n} __packed;\n\nstatic inline void sclp_fill_core_info(struct sclp_core_info *info,\n\t\t\t\t       struct read_cpu_info_sccb *sccb)\n{\n\tchar *page = (char *) sccb;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->configured = sccb->nr_configured;\n\tinfo->standby = sccb->nr_standby;\n\tinfo->combined = sccb->nr_configured + sccb->nr_standby;\n\tmemcpy(&info->core, page + sccb->offset_configured,\n\t       info->combined * sizeof(struct sclp_core_entry));\n}\n\n#define SCLP_HAS_CHP_INFO\t(sclp.facilities & 0x8000000000000000ULL)\n#define SCLP_HAS_CHP_RECONFIG\t(sclp.facilities & 0x2000000000000000ULL)\n#define SCLP_HAS_CPU_INFO\t(sclp.facilities & 0x0800000000000000ULL)\n#define SCLP_HAS_CPU_RECONFIG\t(sclp.facilities & 0x0400000000000000ULL)\n#define SCLP_HAS_PCI_RECONFIG\t(sclp.facilities & 0x0000000040000000ULL)\n#define SCLP_HAS_AP_RECONFIG\t(sclp.facilities & 0x0000000100000000ULL)\n\nstruct gds_subvector {\n\tu8\tlength;\n\tu8\tkey;\n} __attribute__((packed));\n\nstruct gds_vector {\n\tu16\tlength;\n\tu16\tgds_id;\n} __attribute__((packed));\n\nstruct evbuf_header {\n\tu16\tlength;\n\tu8\ttype;\n\tu8\tflags;\n\tu16\t_reserved;\n} __attribute__((packed));\n\nstruct sclp_req {\n\tstruct list_head list;\t\t \n\tsclp_cmdw_t command;\t\t \n\tvoid\t*sccb;\t\t\t \n\tchar\tstatus;\t\t\t \n\tint     start_count;\t\t \n\t \n\tvoid (*callback)(struct sclp_req *, void *data);\n\tvoid *callback_data;\n\tint queue_timeout;\t\t \n\t \n\tunsigned long queue_expires;\t \n};\n\n#define SCLP_REQ_FILLED\t  0x00\t \n#define SCLP_REQ_QUEUED\t  0x01\t \n#define SCLP_REQ_RUNNING  0x02\t \n#define SCLP_REQ_DONE\t  0x03\t \n#define SCLP_REQ_FAILED\t  0x05\t \n#define SCLP_REQ_QUEUED_TIMEOUT 0x06\t \n\n#define SCLP_QUEUE_INTERVAL 5\t \n\n \n \nstruct sclp_register {\n\tstruct list_head list;\n\t \n\tsccb_mask_t receive_mask;\n\t \n\tsccb_mask_t send_mask;\n\t \n\tsccb_mask_t sclp_receive_mask;\n\t \n\tsccb_mask_t sclp_send_mask;\n\t \n\tvoid (*state_change_fn)(struct sclp_register *);\n\t \n\tvoid (*receiver_fn)(struct evbuf_header *);\n};\n\n \nint sclp_add_request(struct sclp_req *req);\nvoid sclp_sync_wait(void);\nint sclp_register(struct sclp_register *reg);\nvoid sclp_unregister(struct sclp_register *reg);\nint sclp_remove_processed(struct sccb_header *sccb);\nint sclp_deactivate(void);\nint sclp_reactivate(void);\nint sclp_sync_request(sclp_cmdw_t command, void *sccb);\nint sclp_sync_request_timeout(sclp_cmdw_t command, void *sccb, int timeout);\nint sclp_sdias_init(void);\n\nenum {\n\tsclp_init_state_uninitialized,\n\tsclp_init_state_initializing,\n\tsclp_init_state_initialized\n};\n\nextern int sclp_init_state;\nextern int sclp_console_pages;\nextern bool sclp_console_drop;\nextern unsigned long sclp_console_full;\nextern bool sclp_mask_compat_mode;\n\nvoid sclp_early_wait_irq(void);\nint sclp_early_cmd(sclp_cmdw_t cmd, void *sccb);\nunsigned int sclp_early_con_check_linemode(struct init_sccb *sccb);\nunsigned int sclp_early_con_check_vt220(struct init_sccb *sccb);\nint sclp_early_set_event_mask(struct init_sccb *sccb,\n\t\t\t      sccb_mask_t receive_mask,\n\t\t\t      sccb_mask_t send_mask);\nstruct read_info_sccb * __init sclp_early_get_info(void);\n\n \n\n \nstatic inline int sclp_service_call(sclp_cmdw_t command, void *sccb)\n{\n\tint cc = 4;  \n\n\tasm volatile(\n\t\t\"0:\t.insn\trre,0xb2200000,%1,%2\\n\"\t  \n\t\t\"1:\tipm\t%0\\n\"\n\t\t\"\tsrl\t%0,28\\n\"\n\t\t\"2:\\n\"\n\t\tEX_TABLE(0b, 2b)\n\t\tEX_TABLE(1b, 2b)\n\t\t: \"+&d\" (cc) : \"d\" (command), \"a\" (__pa(sccb))\n\t\t: \"cc\", \"memory\");\n\tif (cc == 4)\n\t\treturn -EINVAL;\n\tif (cc == 3)\n\t\treturn -EIO;\n\tif (cc == 2)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n \n \nstatic inline unsigned char\nsclp_ascebc(unsigned char ch)\n{\n\treturn (MACHINE_IS_VM) ? _ascebc[ch] : _ascebc_500[ch];\n}\n\n \nstatic inline void\nsclp_ebcasc_str(char *str, int nr)\n{\n\t(MACHINE_IS_VM) ? EBCASC(str, nr) : EBCASC_500(str, nr);\n}\n\n \nstatic inline void\nsclp_ascebc_str(char *str, int nr)\n{\n\t(MACHINE_IS_VM) ? ASCEBC(str, nr) : ASCEBC_500(str, nr);\n}\n\nstatic inline struct gds_vector *\nsclp_find_gds_vector(void *start, void *end, u16 id)\n{\n\tstruct gds_vector *v;\n\n\tfor (v = start; (void *) v < end; v = (void *) v + v->length)\n\t\tif (v->gds_id == id)\n\t\t\treturn v;\n\treturn NULL;\n}\n\nstatic inline struct gds_subvector *\nsclp_find_gds_subvector(void *start, void *end, u8 key)\n{\n\tstruct gds_subvector *sv;\n\n\tfor (sv = start; (void *) sv < end; sv = (void *) sv + sv->length)\n\t\tif (sv->key == key)\n\t\t\treturn sv;\n\treturn NULL;\n}\n\n#endif\t  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}