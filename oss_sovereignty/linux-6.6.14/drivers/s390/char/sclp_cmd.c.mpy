{
  "module_name": "sclp_cmd.c",
  "hash_id": "44005052bf7de34dc0fa093ce2b12170f12d9da8b31c63403370b8cbe432b5f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_cmd.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"sclp_cmd\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/mmzone.h>\n#include <linux/memory.h>\n#include <linux/module.h>\n#include <asm/ctl_reg.h>\n#include <asm/chpid.h>\n#include <asm/setup.h>\n#include <asm/page.h>\n#include <asm/sclp.h>\n#include <asm/numa.h>\n#include <asm/facility.h>\n\n#include \"sclp.h\"\n\nstatic void sclp_sync_callback(struct sclp_req *req, void *data)\n{\n\tstruct completion *completion = data;\n\n\tcomplete(completion);\n}\n\nint sclp_sync_request(sclp_cmdw_t cmd, void *sccb)\n{\n\treturn sclp_sync_request_timeout(cmd, sccb, 0);\n}\n\nint sclp_sync_request_timeout(sclp_cmdw_t cmd, void *sccb, int timeout)\n{\n\tstruct completion completion;\n\tstruct sclp_req *request;\n\tint rc;\n\n\trequest = kzalloc(sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\tif (timeout)\n\t\trequest->queue_timeout = timeout;\n\trequest->command = cmd;\n\trequest->sccb = sccb;\n\trequest->status = SCLP_REQ_FILLED;\n\trequest->callback = sclp_sync_callback;\n\trequest->callback_data = &completion;\n\tinit_completion(&completion);\n\n\t \n\trc = sclp_add_request(request);\n\tif (rc)\n\t\tgoto out;\n\twait_for_completion(&completion);\n\n\t \n\tif (request->status != SCLP_REQ_DONE) {\n\t\tpr_warn(\"sync request failed (cmd=0x%08x, status=0x%02x)\\n\",\n\t\t\tcmd, request->status);\n\t\trc = -EIO;\n\t}\nout:\n\tkfree(request);\n\treturn rc;\n}\n\n \n\n#define SCLP_CMDW_CONFIGURE_CPU\t\t0x00110001\n#define SCLP_CMDW_DECONFIGURE_CPU\t0x00100001\n\nint _sclp_get_core_info(struct sclp_core_info *info)\n{\n\tint rc;\n\tint length = test_facility(140) ? EXT_SCCB_READ_CPU : PAGE_SIZE;\n\tstruct read_cpu_info_sccb *sccb;\n\n\tif (!SCLP_HAS_CPU_INFO)\n\t\treturn -EOPNOTSUPP;\n\n\tsccb = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA | __GFP_ZERO, get_order(length));\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tsccb->header.length = length;\n\tsccb->header.control_mask[2] = 0x80;\n\trc = sclp_sync_request_timeout(SCLP_CMDW_READ_CPU_INFO, sccb,\n\t\t\t\t       SCLP_QUEUE_INTERVAL);\n\tif (rc)\n\t\tgoto out;\n\tif (sccb->header.response_code != 0x0010) {\n\t\tpr_warn(\"readcpuinfo failed (response=0x%04x)\\n\",\n\t\t\tsccb->header.response_code);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tsclp_fill_core_info(info, sccb);\nout:\n\tfree_pages((unsigned long) sccb, get_order(length));\n\treturn rc;\n}\n\nstruct cpu_configure_sccb {\n\tstruct sccb_header header;\n} __attribute__((packed, aligned(8)));\n\nstatic int do_core_configure(sclp_cmdw_t cmd)\n{\n\tstruct cpu_configure_sccb *sccb;\n\tint rc;\n\n\tif (!SCLP_HAS_CPU_RECONFIG)\n\t\treturn -EOPNOTSUPP;\n\t \n\tsccb = kzalloc(sizeof(*sccb), GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tsccb->header.length = sizeof(*sccb);\n\trc = sclp_sync_request_timeout(cmd, sccb, SCLP_QUEUE_INTERVAL);\n\tif (rc)\n\t\tgoto out;\n\tswitch (sccb->header.response_code) {\n\tcase 0x0020:\n\tcase 0x0120:\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"configure cpu failed (cmd=0x%08x, response=0x%04x)\\n\",\n\t\t\tcmd, sccb->header.response_code);\n\t\trc = -EIO;\n\t\tbreak;\n\t}\nout:\n\tkfree(sccb);\n\treturn rc;\n}\n\nint sclp_core_configure(u8 core)\n{\n\treturn do_core_configure(SCLP_CMDW_CONFIGURE_CPU | core << 8);\n}\n\nint sclp_core_deconfigure(u8 core)\n{\n\treturn do_core_configure(SCLP_CMDW_DECONFIGURE_CPU | core << 8);\n}\n\n#ifdef CONFIG_MEMORY_HOTPLUG\n\nstatic DEFINE_MUTEX(sclp_mem_mutex);\nstatic LIST_HEAD(sclp_mem_list);\nstatic u8 sclp_max_storage_id;\nstatic DECLARE_BITMAP(sclp_storage_ids, 256);\n\nstruct memory_increment {\n\tstruct list_head list;\n\tu16 rn;\n\tint standby;\n};\n\nstruct assign_storage_sccb {\n\tstruct sccb_header header;\n\tu16 rn;\n} __packed;\n\nint arch_get_memory_phys_device(unsigned long start_pfn)\n{\n\tif (!sclp.rzm)\n\t\treturn 0;\n\treturn PFN_PHYS(start_pfn) >> ilog2(sclp.rzm);\n}\n\nstatic unsigned long long rn2addr(u16 rn)\n{\n\treturn (unsigned long long) (rn - 1) * sclp.rzm;\n}\n\nstatic int do_assign_storage(sclp_cmdw_t cmd, u16 rn)\n{\n\tstruct assign_storage_sccb *sccb;\n\tint rc;\n\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tsccb->header.length = PAGE_SIZE;\n\tsccb->rn = rn;\n\trc = sclp_sync_request_timeout(cmd, sccb, SCLP_QUEUE_INTERVAL);\n\tif (rc)\n\t\tgoto out;\n\tswitch (sccb->header.response_code) {\n\tcase 0x0020:\n\tcase 0x0120:\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"assign storage failed (cmd=0x%08x, response=0x%04x, rn=0x%04x)\\n\",\n\t\t\tcmd, sccb->header.response_code, rn);\n\t\trc = -EIO;\n\t\tbreak;\n\t}\nout:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n\nstatic int sclp_assign_storage(u16 rn)\n{\n\tunsigned long long start;\n\tint rc;\n\n\trc = do_assign_storage(0x000d0001, rn);\n\tif (rc)\n\t\treturn rc;\n\tstart = rn2addr(rn);\n\tstorage_key_init_range(start, start + sclp.rzm);\n\treturn 0;\n}\n\nstatic int sclp_unassign_storage(u16 rn)\n{\n\treturn do_assign_storage(0x000c0001, rn);\n}\n\nstruct attach_storage_sccb {\n\tstruct sccb_header header;\n\tu16 :16;\n\tu16 assigned;\n\tu32 :32;\n\tu32 entries[];\n} __packed;\n\nstatic int sclp_attach_storage(u8 id)\n{\n\tstruct attach_storage_sccb *sccb;\n\tint rc;\n\tint i;\n\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tsccb->header.length = PAGE_SIZE;\n\tsccb->header.function_code = 0x40;\n\trc = sclp_sync_request_timeout(0x00080001 | id << 8, sccb,\n\t\t\t\t       SCLP_QUEUE_INTERVAL);\n\tif (rc)\n\t\tgoto out;\n\tswitch (sccb->header.response_code) {\n\tcase 0x0020:\n\t\tset_bit(id, sclp_storage_ids);\n\t\tfor (i = 0; i < sccb->assigned; i++) {\n\t\t\tif (sccb->entries[i])\n\t\t\t\tsclp_unassign_storage(sccb->entries[i] >> 16);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EIO;\n\t\tbreak;\n\t}\nout:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n\nstatic int sclp_mem_change_state(unsigned long start, unsigned long size,\n\t\t\t\t int online)\n{\n\tstruct memory_increment *incr;\n\tunsigned long long istart;\n\tint rc = 0;\n\n\tlist_for_each_entry(incr, &sclp_mem_list, list) {\n\t\tistart = rn2addr(incr->rn);\n\t\tif (start + size - 1 < istart)\n\t\t\tbreak;\n\t\tif (start > istart + sclp.rzm - 1)\n\t\t\tcontinue;\n\t\tif (online)\n\t\t\trc |= sclp_assign_storage(incr->rn);\n\t\telse\n\t\t\tsclp_unassign_storage(incr->rn);\n\t\tif (rc == 0)\n\t\t\tincr->standby = online ? 0 : 1;\n\t}\n\treturn rc ? -EIO : 0;\n}\n\nstatic bool contains_standby_increment(unsigned long start, unsigned long end)\n{\n\tstruct memory_increment *incr;\n\tunsigned long istart;\n\n\tlist_for_each_entry(incr, &sclp_mem_list, list) {\n\t\tistart = rn2addr(incr->rn);\n\t\tif (end - 1 < istart)\n\t\t\tcontinue;\n\t\tif (start > istart + sclp.rzm - 1)\n\t\t\tcontinue;\n\t\tif (incr->standby)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int sclp_mem_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long action, void *data)\n{\n\tunsigned long start, size;\n\tstruct memory_notify *arg;\n\tunsigned char id;\n\tint rc = 0;\n\n\targ = data;\n\tstart = arg->start_pfn << PAGE_SHIFT;\n\tsize = arg->nr_pages << PAGE_SHIFT;\n\tmutex_lock(&sclp_mem_mutex);\n\tfor_each_clear_bit(id, sclp_storage_ids, sclp_max_storage_id + 1)\n\t\tsclp_attach_storage(id);\n\tswitch (action) {\n\tcase MEM_GOING_OFFLINE:\n\t\t \n\t\tif (contains_standby_increment(start, start + size))\n\t\t\trc = -EPERM;\n\t\tbreak;\n\tcase MEM_ONLINE:\n\tcase MEM_CANCEL_OFFLINE:\n\t\tbreak;\n\tcase MEM_GOING_ONLINE:\n\t\trc = sclp_mem_change_state(start, size, 1);\n\t\tbreak;\n\tcase MEM_CANCEL_ONLINE:\n\t\tsclp_mem_change_state(start, size, 0);\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\t\tsclp_mem_change_state(start, size, 0);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&sclp_mem_mutex);\n\treturn rc ? NOTIFY_BAD : NOTIFY_OK;\n}\n\nstatic struct notifier_block sclp_mem_nb = {\n\t.notifier_call = sclp_mem_notifier,\n};\n\nstatic void __init align_to_block_size(unsigned long long *start,\n\t\t\t\t       unsigned long long *size,\n\t\t\t\t       unsigned long long alignment)\n{\n\tunsigned long long start_align, size_align;\n\n\tstart_align = roundup(*start, alignment);\n\tsize_align = rounddown(*start + *size, alignment) - start_align;\n\n\tpr_info(\"Standby memory at 0x%llx (%lluM of %lluM usable)\\n\",\n\t\t*start, size_align >> 20, *size >> 20);\n\t*start = start_align;\n\t*size = size_align;\n}\n\nstatic void __init add_memory_merged(u16 rn)\n{\n\tunsigned long long start, size, addr, block_size;\n\tstatic u16 first_rn, num;\n\n\tif (rn && first_rn && (first_rn + num == rn)) {\n\t\tnum++;\n\t\treturn;\n\t}\n\tif (!first_rn)\n\t\tgoto skip_add;\n\tstart = rn2addr(first_rn);\n\tsize = (unsigned long long) num * sclp.rzm;\n\tif (start >= ident_map_size)\n\t\tgoto skip_add;\n\tif (start + size > ident_map_size)\n\t\tsize = ident_map_size - start;\n\tblock_size = memory_block_size_bytes();\n\talign_to_block_size(&start, &size, block_size);\n\tif (!size)\n\t\tgoto skip_add;\n\tfor (addr = start; addr < start + size; addr += block_size)\n\t\tadd_memory(0, addr, block_size, MHP_NONE);\nskip_add:\n\tfirst_rn = rn;\n\tnum = 1;\n}\n\nstatic void __init sclp_add_standby_memory(void)\n{\n\tstruct memory_increment *incr;\n\n\tlist_for_each_entry(incr, &sclp_mem_list, list)\n\t\tif (incr->standby)\n\t\t\tadd_memory_merged(incr->rn);\n\tadd_memory_merged(0);\n}\n\nstatic void __init insert_increment(u16 rn, int standby, int assigned)\n{\n\tstruct memory_increment *incr, *new_incr;\n\tstruct list_head *prev;\n\tu16 last_rn;\n\n\tnew_incr = kzalloc(sizeof(*new_incr), GFP_KERNEL);\n\tif (!new_incr)\n\t\treturn;\n\tnew_incr->rn = rn;\n\tnew_incr->standby = standby;\n\tlast_rn = 0;\n\tprev = &sclp_mem_list;\n\tlist_for_each_entry(incr, &sclp_mem_list, list) {\n\t\tif (assigned && incr->rn > rn)\n\t\t\tbreak;\n\t\tif (!assigned && incr->rn - last_rn > 1)\n\t\t\tbreak;\n\t\tlast_rn = incr->rn;\n\t\tprev = &incr->list;\n\t}\n\tif (!assigned)\n\t\tnew_incr->rn = last_rn + 1;\n\tif (new_incr->rn > sclp.rnmax) {\n\t\tkfree(new_incr);\n\t\treturn;\n\t}\n\tlist_add(&new_incr->list, prev);\n}\n\nstatic int __init sclp_detect_standby_memory(void)\n{\n\tstruct read_storage_sccb *sccb;\n\tint i, id, assigned, rc;\n\n\tif (oldmem_data.start)  \n\t\treturn 0;\n\tif ((sclp.facilities & 0xe00000000000ULL) != 0xe00000000000ULL)\n\t\treturn 0;\n\trc = -ENOMEM;\n\tsccb = (void *) __get_free_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\tgoto out;\n\tassigned = 0;\n\tfor (id = 0; id <= sclp_max_storage_id; id++) {\n\t\tmemset(sccb, 0, PAGE_SIZE);\n\t\tsccb->header.length = PAGE_SIZE;\n\t\trc = sclp_sync_request(SCLP_CMDW_READ_STORAGE_INFO | id << 8, sccb);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tswitch (sccb->header.response_code) {\n\t\tcase 0x0010:\n\t\t\tset_bit(id, sclp_storage_ids);\n\t\t\tfor (i = 0; i < sccb->assigned; i++) {\n\t\t\t\tif (!sccb->entries[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tassigned++;\n\t\t\t\tinsert_increment(sccb->entries[i] >> 16, 0, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0310:\n\t\t\tbreak;\n\t\tcase 0x0410:\n\t\t\tfor (i = 0; i < sccb->assigned; i++) {\n\t\t\t\tif (!sccb->entries[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tassigned++;\n\t\t\t\tinsert_increment(sccb->entries[i] >> 16, 1, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (!rc)\n\t\t\tsclp_max_storage_id = sccb->max_id;\n\t}\n\tif (rc || list_empty(&sclp_mem_list))\n\t\tgoto out;\n\tfor (i = 1; i <= sclp.rnmax - assigned; i++)\n\t\tinsert_increment(0, 1, 0);\n\trc = register_memory_notifier(&sclp_mem_nb);\n\tif (rc)\n\t\tgoto out;\n\tsclp_add_standby_memory();\nout:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n__initcall(sclp_detect_standby_memory);\n\n#endif  \n\n \n\n#define SCLP_CMDW_CONFIGURE_CHPATH\t\t0x000f0001\n#define SCLP_CMDW_DECONFIGURE_CHPATH\t\t0x000e0001\n#define SCLP_CMDW_READ_CHPATH_INFORMATION\t0x00030001\n\nstruct chp_cfg_sccb {\n\tstruct sccb_header header;\n\tu8 ccm;\n\tu8 reserved[6];\n\tu8 cssid;\n} __attribute__((packed));\n\nstatic int do_chp_configure(sclp_cmdw_t cmd)\n{\n\tstruct chp_cfg_sccb *sccb;\n\tint rc;\n\n\tif (!SCLP_HAS_CHP_RECONFIG)\n\t\treturn -EOPNOTSUPP;\n\t \n\tsccb = (struct chp_cfg_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tsccb->header.length = sizeof(*sccb);\n\trc = sclp_sync_request(cmd, sccb);\n\tif (rc)\n\t\tgoto out;\n\tswitch (sccb->header.response_code) {\n\tcase 0x0020:\n\tcase 0x0120:\n\tcase 0x0440:\n\tcase 0x0450:\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"configure channel-path failed (cmd=0x%08x, response=0x%04x)\\n\",\n\t\t\tcmd, sccb->header.response_code);\n\t\trc = -EIO;\n\t\tbreak;\n\t}\nout:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n\n \nint sclp_chp_configure(struct chp_id chpid)\n{\n\treturn do_chp_configure(SCLP_CMDW_CONFIGURE_CHPATH | chpid.id << 8);\n}\n\n \nint sclp_chp_deconfigure(struct chp_id chpid)\n{\n\treturn do_chp_configure(SCLP_CMDW_DECONFIGURE_CHPATH | chpid.id << 8);\n}\n\nstruct chp_info_sccb {\n\tstruct sccb_header header;\n\tu8 recognized[SCLP_CHP_INFO_MASK_SIZE];\n\tu8 standby[SCLP_CHP_INFO_MASK_SIZE];\n\tu8 configured[SCLP_CHP_INFO_MASK_SIZE];\n\tu8 ccm;\n\tu8 reserved[6];\n\tu8 cssid;\n} __attribute__((packed));\n\n \nint sclp_chp_read_info(struct sclp_chp_info *info)\n{\n\tstruct chp_info_sccb *sccb;\n\tint rc;\n\n\tif (!SCLP_HAS_CHP_INFO)\n\t\treturn -EOPNOTSUPP;\n\t \n\tsccb = (struct chp_info_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tsccb->header.length = sizeof(*sccb);\n\trc = sclp_sync_request(SCLP_CMDW_READ_CHPATH_INFORMATION, sccb);\n\tif (rc)\n\t\tgoto out;\n\tif (sccb->header.response_code != 0x0010) {\n\t\tpr_warn(\"read channel-path info failed (response=0x%04x)\\n\",\n\t\t\tsccb->header.response_code);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(info->recognized, sccb->recognized, SCLP_CHP_INFO_MASK_SIZE);\n\tmemcpy(info->standby, sccb->standby, SCLP_CHP_INFO_MASK_SIZE);\n\tmemcpy(info->configured, sccb->configured, SCLP_CHP_INFO_MASK_SIZE);\nout:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}