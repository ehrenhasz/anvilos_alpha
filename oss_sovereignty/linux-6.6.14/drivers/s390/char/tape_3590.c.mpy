{
  "module_name": "tape_3590.c",
  "hash_id": "22e03e03244d7121ca69b459f36ae69a8ee06a9e68d75da62a814f226a1d79aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/tape_3590.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"tape_3590\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/bio.h>\n#include <asm/ebcdic.h>\n\n#define TAPE_DBF_AREA\ttape_3590_dbf\n#define BUFSIZE 512\t \n\n#include \"tape.h\"\n#include \"tape_std.h\"\n#include \"tape_3590.h\"\n\nstatic struct workqueue_struct *tape_3590_wq;\n\n \ndebug_info_t *TAPE_DBF_AREA = NULL;\nEXPORT_SYMBOL(TAPE_DBF_AREA);\n\n \n\nstatic const char *tape_3590_msg[TAPE_3590_MAX_MSG] = {\n\t[0x00] = \"\",\n\t[0x10] = \"Lost Sense\",\n\t[0x11] = \"Assigned Elsewhere\",\n\t[0x12] = \"Allegiance Reset\",\n\t[0x13] = \"Shared Access Violation\",\n\t[0x20] = \"Command Reject\",\n\t[0x21] = \"Configuration Error\",\n\t[0x22] = \"Protection Exception\",\n\t[0x23] = \"Write Protect\",\n\t[0x24] = \"Write Length\",\n\t[0x25] = \"Read-Only Format\",\n\t[0x31] = \"Beginning of Partition\",\n\t[0x33] = \"End of Partition\",\n\t[0x34] = \"End of Data\",\n\t[0x35] = \"Block not found\",\n\t[0x40] = \"Device Intervention\",\n\t[0x41] = \"Loader Intervention\",\n\t[0x42] = \"Library Intervention\",\n\t[0x50] = \"Write Error\",\n\t[0x51] = \"Erase Error\",\n\t[0x52] = \"Formatting Error\",\n\t[0x53] = \"Read Error\",\n\t[0x54] = \"Unsupported Format\",\n\t[0x55] = \"No Formatting\",\n\t[0x56] = \"Positioning lost\",\n\t[0x57] = \"Read Length\",\n\t[0x60] = \"Unsupported Medium\",\n\t[0x61] = \"Medium Length Error\",\n\t[0x62] = \"Medium removed\",\n\t[0x64] = \"Load Check\",\n\t[0x65] = \"Unload Check\",\n\t[0x70] = \"Equipment Check\",\n\t[0x71] = \"Bus out Check\",\n\t[0x72] = \"Protocol Error\",\n\t[0x73] = \"Interface Error\",\n\t[0x74] = \"Overrun\",\n\t[0x75] = \"Halt Signal\",\n\t[0x90] = \"Device fenced\",\n\t[0x91] = \"Device Path fenced\",\n\t[0xa0] = \"Volume misplaced\",\n\t[0xa1] = \"Volume inaccessible\",\n\t[0xa2] = \"Volume in input\",\n\t[0xa3] = \"Volume ejected\",\n\t[0xa4] = \"All categories reserved\",\n\t[0xa5] = \"Duplicate Volume\",\n\t[0xa6] = \"Library Manager Offline\",\n\t[0xa7] = \"Library Output Station full\",\n\t[0xa8] = \"Vision System non-operational\",\n\t[0xa9] = \"Library Manager Equipment Check\",\n\t[0xaa] = \"Library Equipment Check\",\n\t[0xab] = \"All Library Cells full\",\n\t[0xac] = \"No Cleaner Volumes in Library\",\n\t[0xad] = \"I/O Station door open\",\n\t[0xae] = \"Subsystem environmental alert\",\n};\n\nstatic int crypt_supported(struct tape_device *device)\n{\n\treturn TAPE390_CRYPT_SUPPORTED(TAPE_3590_CRYPT_INFO(device));\n}\n\nstatic int crypt_enabled(struct tape_device *device)\n{\n\treturn TAPE390_CRYPT_ON(TAPE_3590_CRYPT_INFO(device));\n}\n\nstatic void ext_to_int_kekl(struct tape390_kekl *in,\n\t\t\t    struct tape3592_kekl *out)\n{\n\tint len;\n\n\tmemset(out, 0, sizeof(*out));\n\tif (in->type == TAPE390_KEKL_TYPE_HASH)\n\t\tout->flags |= 0x40;\n\tif (in->type_on_tape == TAPE390_KEKL_TYPE_HASH)\n\t\tout->flags |= 0x80;\n\tlen = min(sizeof(out->label), strlen(in->label));\n\tmemcpy(out->label, in->label, len);\n\tmemset(out->label + len, ' ', sizeof(out->label) - len);\n\tASCEBC(out->label, sizeof(out->label));\n}\n\nstatic void int_to_ext_kekl(struct tape3592_kekl *in,\n\t\t\t    struct tape390_kekl *out)\n{\n\tmemset(out, 0, sizeof(*out));\n\tif(in->flags & 0x40)\n\t\tout->type = TAPE390_KEKL_TYPE_HASH;\n\telse\n\t\tout->type = TAPE390_KEKL_TYPE_LABEL;\n\tif(in->flags & 0x80)\n\t\tout->type_on_tape = TAPE390_KEKL_TYPE_HASH;\n\telse\n\t\tout->type_on_tape = TAPE390_KEKL_TYPE_LABEL;\n\tmemcpy(out->label, in->label, sizeof(in->label));\n\tEBCASC(out->label, sizeof(in->label));\n\tstrim(out->label);\n}\n\nstatic void int_to_ext_kekl_pair(struct tape3592_kekl_pair *in,\n\t\t\t\t struct tape390_kekl_pair *out)\n{\n\tif (in->count == 0) {\n\t\tout->kekl[0].type = TAPE390_KEKL_TYPE_NONE;\n\t\tout->kekl[0].type_on_tape = TAPE390_KEKL_TYPE_NONE;\n\t\tout->kekl[1].type = TAPE390_KEKL_TYPE_NONE;\n\t\tout->kekl[1].type_on_tape = TAPE390_KEKL_TYPE_NONE;\n\t} else if (in->count == 1) {\n\t\tint_to_ext_kekl(&in->kekl[0], &out->kekl[0]);\n\t\tout->kekl[1].type = TAPE390_KEKL_TYPE_NONE;\n\t\tout->kekl[1].type_on_tape = TAPE390_KEKL_TYPE_NONE;\n\t} else if (in->count == 2) {\n\t\tint_to_ext_kekl(&in->kekl[0], &out->kekl[0]);\n\t\tint_to_ext_kekl(&in->kekl[1], &out->kekl[1]);\n\t} else {\n\t\tprintk(\"Invalid KEKL number: %d\\n\", in->count);\n\t\tBUG();\n\t}\n}\n\nstatic int check_ext_kekl(struct tape390_kekl *kekl)\n{\n\tif (kekl->type == TAPE390_KEKL_TYPE_NONE)\n\t\tgoto invalid;\n\tif (kekl->type > TAPE390_KEKL_TYPE_HASH)\n\t\tgoto invalid;\n\tif (kekl->type_on_tape == TAPE390_KEKL_TYPE_NONE)\n\t\tgoto invalid;\n\tif (kekl->type_on_tape > TAPE390_KEKL_TYPE_HASH)\n\t\tgoto invalid;\n\tif ((kekl->type == TAPE390_KEKL_TYPE_HASH) &&\n\t    (kekl->type_on_tape == TAPE390_KEKL_TYPE_LABEL))\n\t\tgoto invalid;\n\n\treturn 0;\ninvalid:\n\treturn -EINVAL;\n}\n\nstatic int check_ext_kekl_pair(struct tape390_kekl_pair *kekls)\n{\n\tif (check_ext_kekl(&kekls->kekl[0]))\n\t\tgoto invalid;\n\tif (check_ext_kekl(&kekls->kekl[1]))\n\t\tgoto invalid;\n\n\treturn 0;\ninvalid:\n\treturn -EINVAL;\n}\n\n \nstatic int tape_3592_kekl_query(struct tape_device *device,\n\t\t\t\tstruct tape390_kekl_pair *ext_kekls)\n{\n\tstruct tape_request *request;\n\tstruct tape3592_kekl_query_order *order;\n\tstruct tape3592_kekl_query_data *int_kekls;\n\tint rc;\n\n\tDBF_EVENT(6, \"tape3592_kekl_query\\n\");\n\tint_kekls = kmalloc(sizeof(*int_kekls), GFP_KERNEL|GFP_DMA);\n\tif (!int_kekls)\n\t\treturn -ENOMEM;\n\trequest = tape_alloc_request(2, sizeof(*order));\n\tif (IS_ERR(request)) {\n\t\trc = PTR_ERR(request);\n\t\tgoto fail_malloc;\n\t}\n\torder = request->cpdata;\n\tmemset(order,0,sizeof(*order));\n\torder->code = 0xe2;\n\torder->max_count = 2;\n\trequest->op = TO_KEKL_QUERY;\n\ttape_ccw_cc(request->cpaddr, PERF_SUBSYS_FUNC, sizeof(*order), order);\n\ttape_ccw_end(request->cpaddr + 1, READ_SS_DATA, sizeof(*int_kekls),\n\t\t     int_kekls);\n\trc = tape_do_io(device, request);\n\tif (rc)\n\t\tgoto fail_request;\n\tint_to_ext_kekl_pair(&int_kekls->kekls, ext_kekls);\n\n\trc = 0;\nfail_request:\n\ttape_free_request(request);\nfail_malloc:\n\tkfree(int_kekls);\n\treturn rc;\n}\n\n \nstatic int tape_3592_ioctl_kekl_query(struct tape_device *device,\n\t\t\t\t      unsigned long arg)\n{\n\tint rc;\n\tstruct tape390_kekl_pair *ext_kekls;\n\n\tDBF_EVENT(6, \"tape_3592_ioctl_kekl_query\\n\");\n\tif (!crypt_supported(device))\n\t\treturn -ENOSYS;\n\tif (!crypt_enabled(device))\n\t\treturn -EUNATCH;\n\text_kekls = kmalloc(sizeof(*ext_kekls), GFP_KERNEL);\n\tif (!ext_kekls)\n\t\treturn -ENOMEM;\n\trc = tape_3592_kekl_query(device, ext_kekls);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (copy_to_user((char __user *) arg, ext_kekls, sizeof(*ext_kekls))) {\n\t\trc = -EFAULT;\n\t\tgoto fail;\n\t}\n\trc = 0;\nfail:\n\tkfree(ext_kekls);\n\treturn rc;\n}\n\nstatic int tape_3590_mttell(struct tape_device *device, int mt_count);\n\n \nstatic int tape_3592_kekl_set(struct tape_device *device,\n\t\t\t      struct tape390_kekl_pair *ext_kekls)\n{\n\tstruct tape_request *request;\n\tstruct tape3592_kekl_set_order *order;\n\n\tDBF_EVENT(6, \"tape3592_kekl_set\\n\");\n\tif (check_ext_kekl_pair(ext_kekls)) {\n\t\tDBF_EVENT(6, \"invalid kekls\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tape_3590_mttell(device, 0) != 0)\n\t\treturn -EBADSLT;\n\trequest = tape_alloc_request(1, sizeof(*order));\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\torder = request->cpdata;\n\tmemset(order, 0, sizeof(*order));\n\torder->code = 0xe3;\n\torder->kekls.count = 2;\n\text_to_int_kekl(&ext_kekls->kekl[0], &order->kekls.kekl[0]);\n\text_to_int_kekl(&ext_kekls->kekl[1], &order->kekls.kekl[1]);\n\trequest->op = TO_KEKL_SET;\n\ttape_ccw_end(request->cpaddr, PERF_SUBSYS_FUNC, sizeof(*order), order);\n\n\treturn tape_do_io_free(device, request);\n}\n\n \nstatic int tape_3592_ioctl_kekl_set(struct tape_device *device,\n\t\t\t\t    unsigned long arg)\n{\n\tint rc;\n\tstruct tape390_kekl_pair *ext_kekls;\n\n\tDBF_EVENT(6, \"tape_3592_ioctl_kekl_set\\n\");\n\tif (!crypt_supported(device))\n\t\treturn -ENOSYS;\n\tif (!crypt_enabled(device))\n\t\treturn -EUNATCH;\n\text_kekls = memdup_user((char __user *)arg, sizeof(*ext_kekls));\n\tif (IS_ERR(ext_kekls))\n\t\treturn PTR_ERR(ext_kekls);\n\trc = tape_3592_kekl_set(device, ext_kekls);\n\tkfree(ext_kekls);\n\treturn rc;\n}\n\n \nstatic struct tape_request *__tape_3592_enable_crypt(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\tchar *data;\n\n\tDBF_EVENT(6, \"tape_3592_enable_crypt\\n\");\n\tif (!crypt_supported(device))\n\t\treturn ERR_PTR(-ENOSYS);\n\trequest = tape_alloc_request(2, 72);\n\tif (IS_ERR(request))\n\t\treturn request;\n\tdata = request->cpdata;\n\tmemset(data,0,72);\n\n\tdata[0]       = 0x05;\n\tdata[36 + 0]  = 0x03;\n\tdata[36 + 1]  = 0x03;\n\tdata[36 + 4]  = 0x40;\n\tdata[36 + 6]  = 0x01;\n\tdata[36 + 14] = 0x2f;\n\tdata[36 + 18] = 0xc3;\n\tdata[36 + 35] = 0x72;\n\trequest->op = TO_CRYPT_ON;\n\ttape_ccw_cc(request->cpaddr, MODE_SET_CB, 36, data);\n\ttape_ccw_end(request->cpaddr + 1, MODE_SET_CB, 36, data + 36);\n\treturn request;\n}\n\nstatic int tape_3592_enable_crypt(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\n\trequest = __tape_3592_enable_crypt(device);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\treturn tape_do_io_free(device, request);\n}\n\nstatic void tape_3592_enable_crypt_async(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\n\trequest = __tape_3592_enable_crypt(device);\n\tif (!IS_ERR(request))\n\t\ttape_do_io_async_free(device, request);\n}\n\n \nstatic struct tape_request *__tape_3592_disable_crypt(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\tchar *data;\n\n\tDBF_EVENT(6, \"tape_3592_disable_crypt\\n\");\n\tif (!crypt_supported(device))\n\t\treturn ERR_PTR(-ENOSYS);\n\trequest = tape_alloc_request(2, 72);\n\tif (IS_ERR(request))\n\t\treturn request;\n\tdata = request->cpdata;\n\tmemset(data,0,72);\n\n\tdata[0]       = 0x05;\n\tdata[36 + 0]  = 0x03;\n\tdata[36 + 1]  = 0x03;\n\tdata[36 + 35] = 0x32;\n\n\trequest->op = TO_CRYPT_OFF;\n\ttape_ccw_cc(request->cpaddr, MODE_SET_CB, 36, data);\n\ttape_ccw_end(request->cpaddr + 1, MODE_SET_CB, 36, data + 36);\n\n\treturn request;\n}\n\nstatic int tape_3592_disable_crypt(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\n\trequest = __tape_3592_disable_crypt(device);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\treturn tape_do_io_free(device, request);\n}\n\nstatic void tape_3592_disable_crypt_async(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\n\trequest = __tape_3592_disable_crypt(device);\n\tif (!IS_ERR(request))\n\t\ttape_do_io_async_free(device, request);\n}\n\n \nstatic int tape_3592_ioctl_crypt_set(struct tape_device *device,\n\t\t\t\t     unsigned long arg)\n{\n\tstruct tape390_crypt_info info;\n\n\tDBF_EVENT(6, \"tape_3592_ioctl_crypt_set\\n\");\n\tif (!crypt_supported(device))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&info, (char __user *)arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.status & ~TAPE390_CRYPT_ON_MASK)\n\t\treturn -EINVAL;\n\tif (info.status & TAPE390_CRYPT_ON_MASK)\n\t\treturn tape_3592_enable_crypt(device);\n\telse\n\t\treturn tape_3592_disable_crypt(device);\n}\n\nstatic int tape_3590_sense_medium(struct tape_device *device);\n\n \nstatic int tape_3592_ioctl_crypt_query(struct tape_device *device,\n\t\t\t\t       unsigned long arg)\n{\n\tDBF_EVENT(6, \"tape_3592_ioctl_crypt_query\\n\");\n\tif (!crypt_supported(device))\n\t\treturn -ENOSYS;\n\ttape_3590_sense_medium(device);\n\tif (copy_to_user((char __user *) arg, &TAPE_3590_CRYPT_INFO(device),\n\t\tsizeof(TAPE_3590_CRYPT_INFO(device))))\n\t\treturn -EFAULT;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int\ntape_3590_ioctl(struct tape_device *device, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase TAPE390_DISPLAY: {\n\t\tstruct display_struct disp;\n\n\t\tif (copy_from_user(&disp, (char __user *) arg, sizeof(disp)))\n\t\t\treturn -EFAULT;\n\n\t\treturn tape_std_display(device, &disp);\n\t}\n\tcase TAPE390_KEKL_SET:\n\t\treturn tape_3592_ioctl_kekl_set(device, arg);\n\tcase TAPE390_KEKL_QUERY:\n\t\treturn tape_3592_ioctl_kekl_query(device, arg);\n\tcase TAPE390_CRYPT_SET:\n\t\treturn tape_3592_ioctl_crypt_set(device, arg);\n\tcase TAPE390_CRYPT_QUERY:\n\t\treturn tape_3592_ioctl_crypt_query(device, arg);\n\tdefault:\n\t\treturn -EINVAL;\t \n\t}\n}\n\n \nstatic int tape_3590_sense_medium(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(1, 128);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_MSEN;\n\ttape_ccw_end(request->cpaddr, MEDIUM_SENSE, 128, request->cpdata);\n\treturn tape_do_io_free(device, request);\n}\n\nstatic void tape_3590_sense_medium_async(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(1, 128);\n\tif (IS_ERR(request))\n\t\treturn;\n\trequest->op = TO_MSEN;\n\ttape_ccw_end(request->cpaddr, MEDIUM_SENSE, 128, request->cpdata);\n\ttape_do_io_async_free(device, request);\n}\n\n \nstatic int\ntape_3590_mttell(struct tape_device *device, int mt_count)\n{\n\t__u64 block_id;\n\tint rc;\n\n\trc = tape_std_read_block_id(device, &block_id);\n\tif (rc)\n\t\treturn rc;\n\treturn block_id >> 32;\n}\n\n \nstatic int\ntape_3590_mtseek(struct tape_device *device, int count)\n{\n\tstruct tape_request *request;\n\n\tDBF_EVENT(6, \"xsee id: %x\\n\", count);\n\trequest = tape_alloc_request(3, 4);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_LBL;\n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\t*(__u32 *) request->cpdata = count;\n\ttape_ccw_cc(request->cpaddr + 1, LOCATE, 4, request->cpdata);\n\ttape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\n\treturn tape_do_io_free(device, request);\n}\n\n \nstatic void\ntape_3590_read_opposite(struct tape_device *device,\n\t\t\tstruct tape_request *request)\n{\n\tstruct tape_3590_disc_data *data;\n\n\t \n\trequest->op = TO_RBA;\n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\tdata = device->discdata;\n\ttape_ccw_cc_idal(request->cpaddr + 1, data->read_back_op,\n\t\t\t device->char_data.idal_buf);\n\ttape_ccw_cc(request->cpaddr + 2, FORSPACEBLOCK, 0, NULL);\n\ttape_ccw_end(request->cpaddr + 3, NOP, 0, NULL);\n\tDBF_EVENT(6, \"xrop ccwg\\n\");\n}\n\n \nstatic void tape_3590_read_attmsg_async(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\tchar *buf;\n\n\trequest = tape_alloc_request(3, 4096);\n\tif (IS_ERR(request))\n\t\treturn;\n\trequest->op = TO_READ_ATTMSG;\n\tbuf = request->cpdata;\n\tbuf[0] = PREP_RD_SS_DATA;\n\tbuf[6] = RD_ATTMSG;\t \n\ttape_ccw_cc(request->cpaddr, PERFORM_SS_FUNC, 12, buf);\n\ttape_ccw_cc(request->cpaddr + 1, READ_SS_DATA, 4096 - 12, buf + 12);\n\ttape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\n\ttape_do_io_async_free(device, request);\n}\n\n \nstruct work_handler_data {\n\tstruct tape_device *device;\n\tenum tape_op        op;\n\tstruct work_struct  work;\n};\n\nstatic void\ntape_3590_work_handler(struct work_struct *work)\n{\n\tstruct work_handler_data *p =\n\t\tcontainer_of(work, struct work_handler_data, work);\n\n\tswitch (p->op) {\n\tcase TO_MSEN:\n\t\ttape_3590_sense_medium_async(p->device);\n\t\tbreak;\n\tcase TO_READ_ATTMSG:\n\t\ttape_3590_read_attmsg_async(p->device);\n\t\tbreak;\n\tcase TO_CRYPT_ON:\n\t\ttape_3592_enable_crypt_async(p->device);\n\t\tbreak;\n\tcase TO_CRYPT_OFF:\n\t\ttape_3592_disable_crypt_async(p->device);\n\t\tbreak;\n\tdefault:\n\t\tDBF_EVENT(3, \"T3590: work handler undefined for \"\n\t\t\t  \"operation 0x%02x\\n\", p->op);\n\t}\n\ttape_put_device(p->device);\n\tkfree(p);\n}\n\nstatic int\ntape_3590_schedule_work(struct tape_device *device, enum tape_op op)\n{\n\tstruct work_handler_data *p;\n\n\tif ((p = kzalloc(sizeof(*p), GFP_ATOMIC)) == NULL)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&p->work, tape_3590_work_handler);\n\n\tp->device = tape_get_device(device);\n\tp->op = op;\n\n\tqueue_work(tape_3590_wq, &p->work);\n\treturn 0;\n}\n\nstatic void tape_3590_med_state_set(struct tape_device *device,\n\t\t\t\t    struct tape_3590_med_sense *sense)\n{\n\tstruct tape390_crypt_info *c_info;\n\n\tc_info = &TAPE_3590_CRYPT_INFO(device);\n\n\tDBF_EVENT(6, \"medium state: %x:%x\\n\", sense->macst, sense->masst);\n\tswitch (sense->macst) {\n\tcase 0x04:\n\tcase 0x05:\n\tcase 0x06:\n\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\tTAPE_3590_CRYPT_INFO(device).medium_status = 0;\n\t\treturn;\n\tcase 0x08:\n\tcase 0x09:\n\t\ttape_med_state_set(device, MS_LOADED);\n\t\tbreak;\n\tdefault:\n\t\ttape_med_state_set(device, MS_UNKNOWN);\n\t\treturn;\n\t}\n\tc_info->medium_status |= TAPE390_MEDIUM_LOADED_MASK;\n\tif (sense->flags & MSENSE_CRYPT_MASK) {\n\t\tDBF_EVENT(6, \"Medium is encrypted (%04x)\\n\", sense->flags);\n\t\tc_info->medium_status |= TAPE390_MEDIUM_ENCRYPTED_MASK;\n\t} else\t{\n\t\tDBF_EVENT(6, \"Medium is not encrypted %04x\\n\", sense->flags);\n\t\tc_info->medium_status &= ~TAPE390_MEDIUM_ENCRYPTED_MASK;\n\t}\n}\n\n \nstatic int\ntape_3590_done(struct tape_device *device, struct tape_request *request)\n{\n\n\tDBF_EVENT(6, \"%s done\\n\", tape_op_verbose[request->op]);\n\n\tswitch (request->op) {\n\tcase TO_BSB:\n\tcase TO_BSF:\n\tcase TO_DSE:\n\tcase TO_FSB:\n\tcase TO_FSF:\n\tcase TO_LBL:\n\tcase TO_RFO:\n\tcase TO_RBA:\n\tcase TO_REW:\n\tcase TO_WRI:\n\tcase TO_WTM:\n\tcase TO_BLOCK:\n\tcase TO_LOAD:\n\t\ttape_med_state_set(device, MS_LOADED);\n\t\tbreak;\n\tcase TO_RUN:\n\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\ttape_3590_schedule_work(device, TO_CRYPT_OFF);\n\t\tbreak;\n\tcase TO_MSEN:\n\t\ttape_3590_med_state_set(device, request->cpdata);\n\t\tbreak;\n\tcase TO_CRYPT_ON:\n\t\tTAPE_3590_CRYPT_INFO(device).status\n\t\t\t|= TAPE390_CRYPT_ON_MASK;\n\t\t*(device->modeset_byte) |= 0x03;\n\t\tbreak;\n\tcase TO_CRYPT_OFF:\n\t\tTAPE_3590_CRYPT_INFO(device).status\n\t\t\t&= ~TAPE390_CRYPT_ON_MASK;\n\t\t*(device->modeset_byte) &= ~0x03;\n\t\tbreak;\n\tcase TO_RBI:\t \n\tcase TO_NOP:\t \n\tcase TO_READ_CONFIG:\n\tcase TO_READ_ATTMSG:\n\tcase TO_DIS:\n\tcase TO_ASSIGN:\n\tcase TO_UNASSIGN:\n\tcase TO_SIZE:\n\tcase TO_KEKL_SET:\n\tcase TO_KEKL_QUERY:\n\tcase TO_RDC:\n\t\tbreak;\n\t}\n\treturn TAPE_IO_SUCCESS;\n}\n\n \nstatic inline int\ntape_3590_erp_succeeded(struct tape_device *device, struct tape_request *request)\n{\n\tDBF_EVENT(3, \"Error Recovery successful for %s\\n\",\n\t\t  tape_op_verbose[request->op]);\n\treturn tape_3590_done(device, request);\n}\n\n \nstatic inline int\ntape_3590_erp_failed(struct tape_device *device, struct tape_request *request,\n\t\t     struct irb *irb, int rc)\n{\n\tDBF_EVENT(3, \"Error Recovery failed for %s\\n\",\n\t\t  tape_op_verbose[request->op]);\n\ttape_dump_sense_dbf(device, request, irb);\n\treturn rc;\n}\n\n \nstatic inline int\ntape_3590_erp_retry(struct tape_device *device, struct tape_request *request,\n\t\t    struct irb *irb)\n{\n\tDBF_EVENT(2, \"Retry: %s\\n\", tape_op_verbose[request->op]);\n\ttape_dump_sense_dbf(device, request, irb);\n\treturn TAPE_IO_RETRY;\n}\n\n \nstatic int\ntape_3590_unsolicited_irq(struct tape_device *device, struct irb *irb)\n{\n\tif (irb->scsw.cmd.dstat == DEV_STAT_CHN_END)\n\t\t \n\t\treturn TAPE_IO_PENDING;\n\telse if (irb->scsw.cmd.dstat == 0x85)\n\t\t \n\t\tDBF_EVENT(3, \"unsol.irq! tape ready: %08x\\n\", device->cdev_id);\n\telse if (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\n\t\ttape_3590_schedule_work(device, TO_READ_ATTMSG);\n\t} else {\n\t\tDBF_EVENT(3, \"unsol.irq! dev end: %08x\\n\", device->cdev_id);\n\t\ttape_dump_sense_dbf(device, NULL, irb);\n\t}\n\t \n\ttape_3590_schedule_work(device, TO_MSEN);\n\treturn TAPE_IO_SUCCESS;\n}\n\n \nstatic int\ntape_3590_erp_basic(struct tape_device *device, struct tape_request *request,\n\t\t    struct irb *irb, int rc)\n{\n\tstruct tape_3590_sense *sense;\n\n\tsense = (struct tape_3590_sense *) irb->ecw;\n\n\tswitch (sense->bra) {\n\tcase SENSE_BRA_PER:\n\t\treturn tape_3590_erp_failed(device, request, irb, rc);\n\tcase SENSE_BRA_CONT:\n\t\treturn tape_3590_erp_succeeded(device, request);\n\tcase SENSE_BRA_RE:\n\t\treturn tape_3590_erp_retry(device, request, irb);\n\tcase SENSE_BRA_DRE:\n\t\treturn tape_3590_erp_failed(device, request, irb, rc);\n\tdefault:\n\t\tBUG();\n\t\treturn TAPE_IO_STOP;\n\t}\n}\n\n \nstatic int\ntape_3590_erp_read_buf_log(struct tape_device *device,\n\t\t\t   struct tape_request *request, struct irb *irb)\n{\n\t \n\treturn tape_3590_erp_basic(device, request, irb, -EIO);\n}\n\n \nstatic int\ntape_3590_erp_swap(struct tape_device *device, struct tape_request *request,\n\t\t   struct irb *irb)\n{\n\t \n\tdev_warn (&device->cdev->dev, \"The tape medium must be loaded into a \"\n\t\t\"different tape unit\\n\");\n\treturn tape_3590_erp_basic(device, request, irb, -EIO);\n}\n\n \nstatic int\ntape_3590_erp_long_busy(struct tape_device *device,\n\t\t\tstruct tape_request *request, struct irb *irb)\n{\n\tDBF_EVENT(6, \"Device is busy\\n\");\n\treturn TAPE_IO_LONG_BUSY;\n}\n\n \nstatic int\ntape_3590_erp_special_interrupt(struct tape_device *device,\n\t\t\t\tstruct tape_request *request, struct irb *irb)\n{\n\treturn tape_3590_erp_basic(device, request, irb, -EIO);\n}\n\n \nstatic int\ntape_3590_erp_read_alternate(struct tape_device *device,\n\t\t\t     struct tape_request *request, struct irb *irb)\n{\n\tstruct tape_3590_disc_data *data;\n\n\t \n\tdata = device->discdata;\n\tif (data->read_back_op == READ_PREVIOUS) {\n\t\tDBF_EVENT(2, \"(%08x): No support for READ_PREVIOUS command\\n\",\n\t\t\t  device->cdev_id);\n\t\tdata->read_back_op = READ_BACKWARD;\n\t} else {\n\t\tDBF_EVENT(2, \"(%08x): No support for READ_BACKWARD command\\n\",\n\t\t\t  device->cdev_id);\n\t\tdata->read_back_op = READ_PREVIOUS;\n\t}\n\ttape_3590_read_opposite(device, request);\n\treturn tape_3590_erp_retry(device, request, irb);\n}\n\n \nstatic int\ntape_3590_erp_read_opposite(struct tape_device *device,\n\t\t\t    struct tape_request *request, struct irb *irb)\n{\n\tswitch (request->op) {\n\tcase TO_RFO:\n\t\t \n\t\ttape_3590_read_opposite(device, request);\n\t\treturn tape_3590_erp_retry(device, request, irb);\n\tcase TO_RBA:\n\t\t \n\t\treturn tape_3590_erp_failed(device, request, irb, -EIO);\n\t\tbreak;\n\tdefault:\n\t\treturn tape_3590_erp_failed(device, request, irb, -EIO);\n\t}\n}\n\n \nstatic void\ntape_3590_print_mim_msg_f0(struct tape_device *device, struct irb *irb)\n{\n\tstruct tape_3590_sense *sense;\n\tchar *exception, *service;\n\n\texception = kmalloc(BUFSIZE, GFP_ATOMIC);\n\tservice = kmalloc(BUFSIZE, GFP_ATOMIC);\n\n\tif (!exception || !service)\n\t\tgoto out_nomem;\n\n\tsense = (struct tape_3590_sense *) irb->ecw;\n\t \n\tswitch (sense->fmt.f70.emc) {\n\tcase 0x02:\n\t\tsnprintf(exception, BUFSIZE, \"Data degraded\");\n\t\tbreak;\n\tcase 0x03:\n\t\tsnprintf(exception, BUFSIZE, \"Data degraded in partition %i\",\n\t\t\tsense->fmt.f70.mp);\n\t\tbreak;\n\tcase 0x04:\n\t\tsnprintf(exception, BUFSIZE, \"Medium degraded\");\n\t\tbreak;\n\tcase 0x05:\n\t\tsnprintf(exception, BUFSIZE, \"Medium degraded in partition %i\",\n\t\t\tsense->fmt.f70.mp);\n\t\tbreak;\n\tcase 0x06:\n\t\tsnprintf(exception, BUFSIZE, \"Block 0 Error\");\n\t\tbreak;\n\tcase 0x07:\n\t\tsnprintf(exception, BUFSIZE, \"Medium Exception 0x%02x\",\n\t\t\tsense->fmt.f70.md);\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(exception, BUFSIZE, \"0x%02x\",\n\t\t\tsense->fmt.f70.emc);\n\t\tbreak;\n\t}\n\t \n\tswitch (sense->fmt.f70.smc) {\n\tcase 0x02:\n\t\tsnprintf(service, BUFSIZE, \"Reference Media maintenance \"\n\t\t\t\"procedure %i\", sense->fmt.f70.md);\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(service, BUFSIZE, \"0x%02x\",\n\t\t\tsense->fmt.f70.smc);\n\t\tbreak;\n\t}\n\n\tdev_warn (&device->cdev->dev, \"Tape media information: exception %s, \"\n\t\t\"service %s\\n\", exception, service);\n\nout_nomem:\n\tkfree(exception);\n\tkfree(service);\n}\n\n \nstatic void\ntape_3590_print_io_sim_msg_f1(struct tape_device *device, struct irb *irb)\n{\n\tstruct tape_3590_sense *sense;\n\tchar *exception, *service;\n\n\texception = kmalloc(BUFSIZE, GFP_ATOMIC);\n\tservice = kmalloc(BUFSIZE, GFP_ATOMIC);\n\n\tif (!exception || !service)\n\t\tgoto out_nomem;\n\n\tsense = (struct tape_3590_sense *) irb->ecw;\n\t \n\tswitch (sense->fmt.f71.emc) {\n\tcase 0x01:\n\t\tsnprintf(exception, BUFSIZE, \"Effect of failure is unknown\");\n\t\tbreak;\n\tcase 0x02:\n\t\tsnprintf(exception, BUFSIZE, \"CU Exception - no performance \"\n\t\t\t\"impact\");\n\t\tbreak;\n\tcase 0x03:\n\t\tsnprintf(exception, BUFSIZE, \"CU Exception on channel \"\n\t\t\t\"interface 0x%02x\", sense->fmt.f71.md[0]);\n\t\tbreak;\n\tcase 0x04:\n\t\tsnprintf(exception, BUFSIZE, \"CU Exception on device path \"\n\t\t\t\"0x%02x\", sense->fmt.f71.md[0]);\n\t\tbreak;\n\tcase 0x05:\n\t\tsnprintf(exception, BUFSIZE, \"CU Exception on library path \"\n\t\t\t\"0x%02x\", sense->fmt.f71.md[0]);\n\t\tbreak;\n\tcase 0x06:\n\t\tsnprintf(exception, BUFSIZE, \"CU Exception on node 0x%02x\",\n\t\t\tsense->fmt.f71.md[0]);\n\t\tbreak;\n\tcase 0x07:\n\t\tsnprintf(exception, BUFSIZE, \"CU Exception on partition \"\n\t\t\t\"0x%02x\", sense->fmt.f71.md[0]);\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(exception, BUFSIZE, \"0x%02x\",\n\t\t\tsense->fmt.f71.emc);\n\t}\n\t \n\tswitch (sense->fmt.f71.smc) {\n\tcase 0x01:\n\t\tsnprintf(service, BUFSIZE, \"Repair impact is unknown\");\n\t\tbreak;\n\tcase 0x02:\n\t\tsnprintf(service, BUFSIZE, \"Repair will not impact cu \"\n\t\t\t\"performance\");\n\t\tbreak;\n\tcase 0x03:\n\t\tif (sense->fmt.f71.mdf == 0)\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable node \"\n\t\t\t\t\"0x%x on CU\", sense->fmt.f71.md[1]);\n\t\telse\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"nodes (0x%x-0x%x) on CU\", sense->fmt.f71.md[1],\n\t\t\t\tsense->fmt.f71.md[2]);\n\t\tbreak;\n\tcase 0x04:\n\t\tif (sense->fmt.f71.mdf == 0)\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"channel path 0x%x on CU\",\n\t\t\t\tsense->fmt.f71.md[1]);\n\t\telse\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable channel\"\n\t\t\t\t\" paths (0x%x-0x%x) on CU\",\n\t\t\t\tsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\n\t\tbreak;\n\tcase 0x05:\n\t\tif (sense->fmt.f71.mdf == 0)\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable device\"\n\t\t\t\t\" path 0x%x on CU\", sense->fmt.f71.md[1]);\n\t\telse\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable device\"\n\t\t\t\t\" paths (0x%x-0x%x) on CU\",\n\t\t\t\tsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\n\t\tbreak;\n\tcase 0x06:\n\t\tif (sense->fmt.f71.mdf == 0)\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"library path 0x%x on CU\",\n\t\t\t\tsense->fmt.f71.md[1]);\n\t\telse\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"library paths (0x%x-0x%x) on CU\",\n\t\t\t\tsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\n\t\tbreak;\n\tcase 0x07:\n\t\tsnprintf(service, BUFSIZE, \"Repair will disable access to CU\");\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(service, BUFSIZE, \"0x%02x\",\n\t\t\tsense->fmt.f71.smc);\n\t}\n\n\tdev_warn (&device->cdev->dev, \"I/O subsystem information: exception\"\n\t\t\" %s, service %s\\n\", exception, service);\nout_nomem:\n\tkfree(exception);\n\tkfree(service);\n}\n\n \nstatic void\ntape_3590_print_dev_sim_msg_f2(struct tape_device *device, struct irb *irb)\n{\n\tstruct tape_3590_sense *sense;\n\tchar *exception, *service;\n\n\texception = kmalloc(BUFSIZE, GFP_ATOMIC);\n\tservice = kmalloc(BUFSIZE, GFP_ATOMIC);\n\n\tif (!exception || !service)\n\t\tgoto out_nomem;\n\n\tsense = (struct tape_3590_sense *) irb->ecw;\n\t \n\tswitch (sense->fmt.f71.emc) {\n\tcase 0x01:\n\t\tsnprintf(exception, BUFSIZE, \"Effect of failure is unknown\");\n\t\tbreak;\n\tcase 0x02:\n\t\tsnprintf(exception, BUFSIZE, \"DV Exception - no performance\"\n\t\t\t\" impact\");\n\t\tbreak;\n\tcase 0x03:\n\t\tsnprintf(exception, BUFSIZE, \"DV Exception on channel \"\n\t\t\t\"interface 0x%02x\", sense->fmt.f71.md[0]);\n\t\tbreak;\n\tcase 0x04:\n\t\tsnprintf(exception, BUFSIZE, \"DV Exception on loader 0x%02x\",\n\t\t\tsense->fmt.f71.md[0]);\n\t\tbreak;\n\tcase 0x05:\n\t\tsnprintf(exception, BUFSIZE, \"DV Exception on message display\"\n\t\t\t\" 0x%02x\", sense->fmt.f71.md[0]);\n\t\tbreak;\n\tcase 0x06:\n\t\tsnprintf(exception, BUFSIZE, \"DV Exception in tape path\");\n\t\tbreak;\n\tcase 0x07:\n\t\tsnprintf(exception, BUFSIZE, \"DV Exception in drive\");\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(exception, BUFSIZE, \"0x%02x\",\n\t\t\tsense->fmt.f71.emc);\n\t}\n\t \n\tswitch (sense->fmt.f71.smc) {\n\tcase 0x01:\n\t\tsnprintf(service, BUFSIZE, \"Repair impact is unknown\");\n\t\tbreak;\n\tcase 0x02:\n\t\tsnprintf(service, BUFSIZE, \"Repair will not impact device \"\n\t\t\t\"performance\");\n\t\tbreak;\n\tcase 0x03:\n\t\tif (sense->fmt.f71.mdf == 0)\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"channel path 0x%x on DV\",\n\t\t\t\tsense->fmt.f71.md[1]);\n\t\telse\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"channel path (0x%x-0x%x) on DV\",\n\t\t\t\tsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\n\t\tbreak;\n\tcase 0x04:\n\t\tif (sense->fmt.f71.mdf == 0)\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"interface 0x%x on DV\", sense->fmt.f71.md[1]);\n\t\telse\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"interfaces (0x%x-0x%x) on DV\",\n\t\t\t\tsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\n\t\tbreak;\n\tcase 0x05:\n\t\tif (sense->fmt.f71.mdf == 0)\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable loader\"\n\t\t\t\t\" 0x%x on DV\", sense->fmt.f71.md[1]);\n\t\telse\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable loader\"\n\t\t\t\t\" (0x%x-0x%x) on DV\",\n\t\t\t\tsense->fmt.f71.md[1], sense->fmt.f71.md[2]);\n\t\tbreak;\n\tcase 0x07:\n\t\tsnprintf(service, BUFSIZE, \"Repair will disable access to DV\");\n\t\tbreak;\n\tcase 0x08:\n\t\tif (sense->fmt.f71.mdf == 0)\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"message display 0x%x on DV\",\n\t\t\t\tsense->fmt.f71.md[1]);\n\t\telse\n\t\t\tsnprintf(service, BUFSIZE, \"Repair will disable \"\n\t\t\t\t\"message displays (0x%x-0x%x) on DV\",\n\t\t\t\t sense->fmt.f71.md[1], sense->fmt.f71.md[2]);\n\t\tbreak;\n\tcase 0x09:\n\t\tsnprintf(service, BUFSIZE, \"Clean DV\");\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(service, BUFSIZE, \"0x%02x\",\n\t\t\tsense->fmt.f71.smc);\n\t}\n\n\tdev_warn (&device->cdev->dev, \"Device subsystem information: exception\"\n\t\t\" %s, service %s\\n\", exception, service);\nout_nomem:\n\tkfree(exception);\n\tkfree(service);\n}\n\n \nstatic void\ntape_3590_print_era_msg(struct tape_device *device, struct irb *irb)\n{\n\tstruct tape_3590_sense *sense;\n\n\tsense = (struct tape_3590_sense *) irb->ecw;\n\tif (sense->mc == 0)\n\t\treturn;\n\tif ((sense->mc > 0) && (sense->mc < TAPE_3590_MAX_MSG)) {\n\t\tif (tape_3590_msg[sense->mc] != NULL)\n\t\t\tdev_warn (&device->cdev->dev, \"The tape unit has \"\n\t\t\t\t\"issued sense message %s\\n\",\n\t\t\t\ttape_3590_msg[sense->mc]);\n\t\telse\n\t\t\tdev_warn (&device->cdev->dev, \"The tape unit has \"\n\t\t\t\t\"issued an unknown sense message code 0x%x\\n\",\n\t\t\t\tsense->mc);\n\t\treturn;\n\t}\n\tif (sense->mc == 0xf0) {\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"MIM SEV=%i, MC=%02x, ES=%x/%x, \"\n\t\t\t\"RC=%02x-%04x-%02x\\n\", sense->fmt.f70.sev, sense->mc,\n\t\t\tsense->fmt.f70.emc, sense->fmt.f70.smc,\n\t\t\tsense->fmt.f70.refcode, sense->fmt.f70.mid,\n\t\t\tsense->fmt.f70.fid);\n\t\ttape_3590_print_mim_msg_f0(device, irb);\n\t\treturn;\n\t}\n\tif (sense->mc == 0xf1) {\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"IOSIM SEV=%i, DEVTYPE=3590/%02x,\"\n\t\t\t\" MC=%02x, ES=%x/%x, REF=0x%04x-0x%04x-0x%04x\\n\",\n\t\t\tsense->fmt.f71.sev, device->cdev->id.dev_model,\n\t\t\tsense->mc, sense->fmt.f71.emc, sense->fmt.f71.smc,\n\t\t\tsense->fmt.f71.refcode1, sense->fmt.f71.refcode2,\n\t\t\tsense->fmt.f71.refcode3);\n\t\ttape_3590_print_io_sim_msg_f1(device, irb);\n\t\treturn;\n\t}\n\tif (sense->mc == 0xf2) {\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"DEVSIM SEV=%i, DEVTYPE=3590/%02x\"\n\t\t\t\", MC=%02x, ES=%x/%x, REF=0x%04x-0x%04x-0x%04x\\n\",\n\t\t\tsense->fmt.f71.sev, device->cdev->id.dev_model,\n\t\t\tsense->mc, sense->fmt.f71.emc, sense->fmt.f71.smc,\n\t\t\tsense->fmt.f71.refcode1, sense->fmt.f71.refcode2,\n\t\t\tsense->fmt.f71.refcode3);\n\t\ttape_3590_print_dev_sim_msg_f2(device, irb);\n\t\treturn;\n\t}\n\tif (sense->mc == 0xf3) {\n\t\t \n\t\treturn;\n\t}\n\tdev_warn (&device->cdev->dev, \"The tape unit has issued an unknown \"\n\t\t\"sense message code %x\\n\", sense->mc);\n}\n\nstatic int tape_3590_crypt_error(struct tape_device *device,\n\t\t\t\t struct tape_request *request, struct irb *irb)\n{\n\tu8 cu_rc;\n\tu16 ekm_rc2;\n\tchar *sense;\n\n\tsense = ((struct tape_3590_sense *) irb->ecw)->fmt.data;\n\tcu_rc = sense[0];\n\tekm_rc2 = *((u16*) &sense[10]);\n\tif ((cu_rc == 0) && (ekm_rc2 == 0xee31))\n\t\t \n\t\treturn tape_3590_erp_basic(device, request, irb, -EKEYREJECTED);\n\tif ((cu_rc == 1) || (cu_rc == 2))\n\t\t \n\t\treturn tape_3590_erp_basic(device, request, irb, -ENOTCONN);\n\n\tdev_err (&device->cdev->dev, \"The tape unit failed to obtain the \"\n\t\t\"encryption key from EKM\\n\");\n\n\treturn tape_3590_erp_basic(device, request, irb, -ENOKEY);\n}\n\n \nstatic int\ntape_3590_unit_check(struct tape_device *device, struct tape_request *request,\n\t\t     struct irb *irb)\n{\n\tstruct tape_3590_sense *sense;\n\n\tsense = (struct tape_3590_sense *) irb->ecw;\n\n\tDBF_EVENT(6, \"Unit Check: RQC = %x\\n\", sense->rc_rqc);\n\n\t \n\tswitch (sense->rc_rqc) {\n\n\tcase 0x1110:\n\t\ttape_3590_print_era_msg(device, irb);\n\t\treturn tape_3590_erp_read_buf_log(device, request, irb);\n\n\tcase 0x2011:\n\t\ttape_3590_print_era_msg(device, irb);\n\t\treturn tape_3590_erp_read_alternate(device, request, irb);\n\n\tcase 0x2230:\n\tcase 0x2231:\n\t\ttape_3590_print_era_msg(device, irb);\n\t\treturn tape_3590_erp_special_interrupt(device, request, irb);\n\tcase 0x2240:\n\t\treturn tape_3590_crypt_error(device, request, irb);\n\n\tcase 0x3010:\n\t\tDBF_EVENT(2, \"(%08x): Backward at Beginning of Partition\\n\",\n\t\t\t  device->cdev_id);\n\t\treturn tape_3590_erp_basic(device, request, irb, -ENOSPC);\n\tcase 0x3012:\n\t\tDBF_EVENT(2, \"(%08x): Forward at End of Partition\\n\",\n\t\t\t  device->cdev_id);\n\t\treturn tape_3590_erp_basic(device, request, irb, -ENOSPC);\n\tcase 0x3020:\n\t\tDBF_EVENT(2, \"(%08x): End of Data Mark\\n\", device->cdev_id);\n\t\treturn tape_3590_erp_basic(device, request, irb, -ENOSPC);\n\n\tcase 0x3122:\n\t\tDBF_EVENT(2, \"(%08x): Rewind Unload initiated\\n\",\n\t\t\t  device->cdev_id);\n\t\treturn tape_3590_erp_basic(device, request, irb, -EIO);\n\tcase 0x3123:\n\t\tDBF_EVENT(2, \"(%08x): Rewind Unload complete\\n\",\n\t\t\t  device->cdev_id);\n\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\ttape_3590_schedule_work(device, TO_CRYPT_OFF);\n\t\treturn tape_3590_erp_basic(device, request, irb, 0);\n\n\tcase 0x4010:\n\t\t \n\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\ttape_3590_schedule_work(device, TO_CRYPT_OFF);\n\t\treturn tape_3590_erp_basic(device, request, irb, -ENOMEDIUM);\n\tcase 0x4012:\t\t \n\t\t \n\t\tDBF_EVENT(6, \"(%08x): LONG BUSY\\n\", device->cdev_id);\n\t\ttape_3590_print_era_msg(device, irb);\n\t\treturn tape_3590_erp_basic(device, request, irb, -EBUSY);\n\tcase 0x4014:\n\t\tDBF_EVENT(6, \"(%08x): Crypto LONG BUSY\\n\", device->cdev_id);\n\t\treturn tape_3590_erp_long_busy(device, request, irb);\n\n\tcase 0x5010:\n\t\tif (sense->rac == 0xd0) {\n\t\t\t \n\t\t\ttape_3590_print_era_msg(device, irb);\n\t\t\treturn tape_3590_erp_swap(device, request, irb);\n\t\t}\n\t\tif (sense->rac == 0x26) {\n\t\t\t \n\t\t\ttape_3590_print_era_msg(device, irb);\n\t\t\treturn tape_3590_erp_read_opposite(device, request,\n\t\t\t\t\t\t\t   irb);\n\t\t}\n\t\treturn tape_3590_erp_basic(device, request, irb, -EIO);\n\tcase 0x5020:\n\tcase 0x5021:\n\tcase 0x5022:\n\tcase 0x5040:\n\tcase 0x5041:\n\tcase 0x5042:\n\t\ttape_3590_print_era_msg(device, irb);\n\t\treturn tape_3590_erp_swap(device, request, irb);\n\n\tcase 0x5110:\n\tcase 0x5111:\n\t\treturn tape_3590_erp_basic(device, request, irb, -EMEDIUMTYPE);\n\n\tcase 0x5120:\n\tcase 0x1120:\n\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\ttape_3590_schedule_work(device, TO_CRYPT_OFF);\n\t\treturn tape_3590_erp_basic(device, request, irb, -ENOMEDIUM);\n\n\tcase 0x6020:\n\t\treturn tape_3590_erp_basic(device, request, irb, -EMEDIUMTYPE);\n\n\tcase 0x8011:\n\t\treturn tape_3590_erp_basic(device, request, irb, -EPERM);\n\tcase 0x8013:\n\t\tdev_warn (&device->cdev->dev, \"A different host has privileged\"\n\t\t\t\" access to the tape unit\\n\");\n\t\treturn tape_3590_erp_basic(device, request, irb, -EPERM);\n\tdefault:\n\t\treturn tape_3590_erp_basic(device, request, irb, -EIO);\n\t}\n}\n\n \nstatic int\ntape_3590_irq(struct tape_device *device, struct tape_request *request,\n\t      struct irb *irb)\n{\n\tif (request == NULL)\n\t\treturn tape_3590_unsolicited_irq(device, irb);\n\n\tif ((irb->scsw.cmd.dstat & DEV_STAT_UNIT_EXCEP) &&\n\t    (irb->scsw.cmd.dstat & DEV_STAT_DEV_END) &&\n\t    (request->op == TO_WRI)) {\n\t\t \n\t\tDBF_EVENT(2, \"End of volume\\n\");\n\t\treturn tape_3590_erp_failed(device, request, irb, -ENOSPC);\n\t}\n\n\tif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\n\t\treturn tape_3590_unit_check(device, request, irb);\n\n\tif (irb->scsw.cmd.dstat & DEV_STAT_DEV_END) {\n\t\tif (irb->scsw.cmd.dstat == DEV_STAT_UNIT_EXCEP) {\n\t\t\tif (request->op == TO_FSB || request->op == TO_BSB)\n\t\t\t\trequest->rescnt++;\n\t\t\telse\n\t\t\t\tDBF_EVENT(5, \"Unit Exception!\\n\");\n\t\t}\n\n\t\treturn tape_3590_done(device, request);\n\t}\n\n\tif (irb->scsw.cmd.dstat & DEV_STAT_CHN_END) {\n\t\tDBF_EVENT(2, \"channel end\\n\");\n\t\treturn TAPE_IO_PENDING;\n\t}\n\n\tif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\n\t\tDBF_EVENT(2, \"Unit Attention when busy..\\n\");\n\t\treturn TAPE_IO_PENDING;\n\t}\n\n\tDBF_EVENT(6, \"xunknownirq\\n\");\n\ttape_dump_sense_dbf(device, request, irb);\n\treturn TAPE_IO_STOP;\n}\n\n\nstatic int tape_3590_read_dev_chars(struct tape_device *device,\n\t\t\t\t    struct tape_3590_rdc_data *rdc_data)\n{\n\tint rc;\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(1, sizeof(*rdc_data));\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_RDC;\n\ttape_ccw_end(request->cpaddr, CCW_CMD_RDC, sizeof(*rdc_data),\n\t\t     request->cpdata);\n\trc = tape_do_io(device, request);\n\tif (rc == 0)\n\t\tmemcpy(rdc_data, request->cpdata, sizeof(*rdc_data));\n\ttape_free_request(request);\n\treturn rc;\n}\n\n \nstatic int\ntape_3590_setup_device(struct tape_device *device)\n{\n\tint rc;\n\tstruct tape_3590_disc_data *data;\n\tstruct tape_3590_rdc_data *rdc_data;\n\n\tDBF_EVENT(6, \"3590 device setup\\n\");\n\tdata = kzalloc(sizeof(struct tape_3590_disc_data), GFP_KERNEL | GFP_DMA);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->read_back_op = READ_PREVIOUS;\n\tdevice->discdata = data;\n\n\trdc_data = kmalloc(sizeof(*rdc_data), GFP_KERNEL | GFP_DMA);\n\tif (!rdc_data) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_kmalloc;\n\t}\n\trc = tape_3590_read_dev_chars(device, rdc_data);\n\tif (rc) {\n\t\tDBF_LH(3, \"Read device characteristics failed!\\n\");\n\t\tgoto fail_rdc_data;\n\t}\n\trc = tape_std_assign(device);\n\tif (rc)\n\t\tgoto fail_rdc_data;\n\tif (rdc_data->data[31] == 0x13) {\n\t\tdata->crypt_info.capability |= TAPE390_CRYPT_SUPPORTED_MASK;\n\t\ttape_3592_disable_crypt(device);\n\t} else {\n\t\tDBF_EVENT(6, \"Device has NO crypto support\\n\");\n\t}\n\t \n\trc = tape_3590_sense_medium(device);\n\tif (rc) {\n\t\tDBF_LH(3, \"3590 medium sense returned %d\\n\", rc);\n\t\tgoto fail_rdc_data;\n\t}\n\treturn 0;\n\nfail_rdc_data:\n\tkfree(rdc_data);\nfail_kmalloc:\n\tkfree(data);\n\treturn rc;\n}\n\n \nstatic void\ntape_3590_cleanup_device(struct tape_device *device)\n{\n\tflush_workqueue(tape_3590_wq);\n\ttape_std_unassign(device);\n\n\tkfree(device->discdata);\n\tdevice->discdata = NULL;\n}\n\n \nstatic tape_mtop_fn tape_3590_mtop[TAPE_NR_MTOPS] = {\n\t[MTRESET]\t = tape_std_mtreset,\n\t[MTFSF]\t\t = tape_std_mtfsf,\n\t[MTBSF]\t\t = tape_std_mtbsf,\n\t[MTFSR]\t\t = tape_std_mtfsr,\n\t[MTBSR]\t\t = tape_std_mtbsr,\n\t[MTWEOF]\t = tape_std_mtweof,\n\t[MTREW]\t\t = tape_std_mtrew,\n\t[MTOFFL]\t = tape_std_mtoffl,\n\t[MTNOP]\t\t = tape_std_mtnop,\n\t[MTRETEN]\t = tape_std_mtreten,\n\t[MTBSFM]\t = tape_std_mtbsfm,\n\t[MTFSFM]\t = tape_std_mtfsfm,\n\t[MTEOM]\t\t = tape_std_mteom,\n\t[MTERASE]\t = tape_std_mterase,\n\t[MTRAS1]\t = NULL,\n\t[MTRAS2]\t = NULL,\n\t[MTRAS3]\t = NULL,\n\t[MTSETBLK]\t = tape_std_mtsetblk,\n\t[MTSETDENSITY]\t = NULL,\n\t[MTSEEK]\t = tape_3590_mtseek,\n\t[MTTELL]\t = tape_3590_mttell,\n\t[MTSETDRVBUFFER] = NULL,\n\t[MTFSS]\t\t = NULL,\n\t[MTBSS]\t\t = NULL,\n\t[MTWSM]\t\t = NULL,\n\t[MTLOCK]\t = NULL,\n\t[MTUNLOCK]\t = NULL,\n\t[MTLOAD]\t = tape_std_mtload,\n\t[MTUNLOAD]\t = tape_std_mtunload,\n\t[MTCOMPRESSION]\t = tape_std_mtcompression,\n\t[MTSETPART]\t = NULL,\n\t[MTMKPART]\t = NULL\n};\n\n \nstatic struct tape_discipline tape_discipline_3590 = {\n\t.owner = THIS_MODULE,\n\t.setup_device = tape_3590_setup_device,\n\t.cleanup_device = tape_3590_cleanup_device,\n\t.process_eov = tape_std_process_eov,\n\t.irq = tape_3590_irq,\n\t.read_block = tape_std_read_block,\n\t.write_block = tape_std_write_block,\n\t.ioctl_fn = tape_3590_ioctl,\n\t.mtop_array = tape_3590_mtop\n};\n\nstatic struct ccw_device_id tape_3590_ids[] = {\n\t{CCW_DEVICE_DEVTYPE(0x3590, 0, 0x3590, 0), .driver_info = tape_3590},\n\t{CCW_DEVICE_DEVTYPE(0x3592, 0, 0x3592, 0), .driver_info = tape_3592},\n\t{   }\n};\n\nstatic int\ntape_3590_online(struct ccw_device *cdev)\n{\n\treturn tape_generic_online(dev_get_drvdata(&cdev->dev),\n\t\t\t\t   &tape_discipline_3590);\n}\n\nstatic struct ccw_driver tape_3590_driver = {\n\t.driver = {\n\t\t.name = \"tape_3590\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.ids = tape_3590_ids,\n\t.probe = tape_generic_probe,\n\t.remove = tape_generic_remove,\n\t.set_offline = tape_generic_offline,\n\t.set_online = tape_3590_online,\n\t.int_class = IRQIO_TAP,\n};\n\n \nstatic int\ntape_3590_init(void)\n{\n\tint rc;\n\n\tTAPE_DBF_AREA = debug_register(\"tape_3590\", 2, 2, 4 * sizeof(long));\n\tdebug_register_view(TAPE_DBF_AREA, &debug_sprintf_view);\n#ifdef DBF_LIKE_HELL\n\tdebug_set_level(TAPE_DBF_AREA, 6);\n#endif\n\n\tDBF_EVENT(3, \"3590 init\\n\");\n\n\ttape_3590_wq = alloc_workqueue(\"tape_3590\", 0, 0);\n\tif (!tape_3590_wq)\n\t\treturn -ENOMEM;\n\n\t \n\trc = ccw_driver_register(&tape_3590_driver);\n\tif (rc) {\n\t\tdestroy_workqueue(tape_3590_wq);\n\t\tDBF_EVENT(3, \"3590 init failed\\n\");\n\t} else\n\t\tDBF_EVENT(3, \"3590 registered\\n\");\n\treturn rc;\n}\n\nstatic void\ntape_3590_exit(void)\n{\n\tccw_driver_unregister(&tape_3590_driver);\n\tdestroy_workqueue(tape_3590_wq);\n\tdebug_unregister(TAPE_DBF_AREA);\n}\n\nMODULE_DEVICE_TABLE(ccw, tape_3590_ids);\nMODULE_AUTHOR(\"(C) 2001,2006 IBM Corporation\");\nMODULE_DESCRIPTION(\"Linux on zSeries channel attached 3590 tape device driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(tape_3590_init);\nmodule_exit(tape_3590_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}