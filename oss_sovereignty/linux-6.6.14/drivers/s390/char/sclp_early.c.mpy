{
  "module_name": "sclp_early.c",
  "hash_id": "1d45e15b4ec426e2c5e5f4b10171e4ec76759d15f155537b762261a3aa3222eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_early.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"sclp_early\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/memblock.h>\n#include <asm/ctl_reg.h>\n#include <asm/sclp.h>\n#include <asm/ipl.h>\n#include <asm/setup.h>\n#include <asm/facility.h>\n#include \"sclp_sdias.h\"\n#include \"sclp.h\"\n\nstatic struct sclp_ipl_info sclp_ipl_info;\n\nstruct sclp_info sclp;\nEXPORT_SYMBOL(sclp);\n\nstatic void __init sclp_early_facilities_detect(void)\n{\n\tstruct sclp_core_entry *cpue;\n\tstruct read_info_sccb *sccb;\n\tu16 boot_cpu_address, cpu;\n\n\tsccb = sclp_early_get_info();\n\tif (!sccb)\n\t\treturn;\n\n\tsclp.facilities = sccb->facilities;\n\tsclp.has_sprp = !!(sccb->fac84 & 0x02);\n\tsclp.has_core_type = !!(sccb->fac84 & 0x01);\n\tsclp.has_gsls = !!(sccb->fac85 & 0x80);\n\tsclp.has_64bscao = !!(sccb->fac116 & 0x80);\n\tsclp.has_cmma = !!(sccb->fac116 & 0x40);\n\tsclp.has_esca = !!(sccb->fac116 & 0x08);\n\tsclp.has_pfmfi = !!(sccb->fac117 & 0x40);\n\tsclp.has_ibs = !!(sccb->fac117 & 0x20);\n\tsclp.has_gisaf = !!(sccb->fac118 & 0x08);\n\tsclp.has_hvs = !!(sccb->fac119 & 0x80);\n\tsclp.has_kss = !!(sccb->fac98 & 0x01);\n\tsclp.has_aisii = !!(sccb->fac118 & 0x40);\n\tsclp.has_aeni = !!(sccb->fac118 & 0x20);\n\tsclp.has_aisi = !!(sccb->fac118 & 0x10);\n\tsclp.has_zpci_lsi = !!(sccb->fac118 & 0x01);\n\tif (sccb->fac85 & 0x02)\n\t\tS390_lowcore.machine_flags |= MACHINE_FLAG_ESOP;\n\tif (sccb->fac91 & 0x40)\n\t\tS390_lowcore.machine_flags |= MACHINE_FLAG_TLB_GUEST;\n\tif (sccb->cpuoff > 134) {\n\t\tsclp.has_diag318 = !!(sccb->byte_134 & 0x80);\n\t\tsclp.has_diag320 = !!(sccb->byte_134 & 0x04);\n\t\tsclp.has_iplcc = !!(sccb->byte_134 & 0x02);\n\t}\n\tif (sccb->cpuoff > 137) {\n\t\tsclp.has_sipl = !!(sccb->cbl & 0x4000);\n\t\tsclp.has_sipl_eckd = !!(sccb->cbl & 0x2000);\n\t}\n\tsclp.rnmax = sccb->rnmax ? sccb->rnmax : sccb->rnmax2;\n\tsclp.rzm = sccb->rnsize ? sccb->rnsize : sccb->rnsize2;\n\tsclp.rzm <<= 20;\n\tsclp.ibc = sccb->ibc;\n\n\tif (sccb->hamaxpow && sccb->hamaxpow < 64)\n\t\tsclp.hamax = (1UL << sccb->hamaxpow) - 1;\n\telse\n\t\tsclp.hamax = U64_MAX;\n\n\tif (!sccb->hcpua) {\n\t\tif (MACHINE_IS_VM)\n\t\t\tsclp.max_cores = 64;\n\t\telse\n\t\t\tsclp.max_cores = sccb->ncpurl;\n\t} else {\n\t\tsclp.max_cores = sccb->hcpua + 1;\n\t}\n\n\tboot_cpu_address = stap();\n\tcpue = (void *)sccb + sccb->cpuoff;\n\tfor (cpu = 0; cpu < sccb->ncpurl; cpue++, cpu++) {\n\t\tif (boot_cpu_address != cpue->core_id)\n\t\t\tcontinue;\n\t\tsclp.has_siif = cpue->siif;\n\t\tsclp.has_sigpif = cpue->sigpif;\n\t\tsclp.has_sief2 = cpue->sief2;\n\t\tsclp.has_gpere = cpue->gpere;\n\t\tsclp.has_ib = cpue->ib;\n\t\tsclp.has_cei = cpue->cei;\n\t\tsclp.has_skey = cpue->skey;\n\t\tbreak;\n\t}\n\n\t \n\tsclp_ipl_info.is_valid = 1;\n\tif (sccb->fac91 & 0x2)\n\t\tsclp_ipl_info.has_dump = 1;\n\tmemcpy(&sclp_ipl_info.loadparm, &sccb->loadparm, LOADPARM_LEN);\n\n\tif (sccb->hsa_size)\n\t\tsclp.hsa_size = (sccb->hsa_size - 1) * PAGE_SIZE;\n\tsclp.mtid = (sccb->fac42 & 0x80) ? (sccb->fac42 & 31) : 0;\n\tsclp.mtid_cp = (sccb->fac42 & 0x80) ? (sccb->fac43 & 31) : 0;\n\tsclp.mtid_prev = (sccb->fac42 & 0x80) ? (sccb->fac66 & 31) : 0;\n\n\tsclp.hmfai = sccb->hmfai;\n\tsclp.has_dirq = !!(sccb->cpudirq & 0x80);\n}\n\n \nvoid __init sclp_early_get_ipl_info(struct sclp_ipl_info *info)\n{\n\t*info = sclp_ipl_info;\n}\n\nint __init sclp_early_get_core_info(struct sclp_core_info *info)\n{\n\tstruct read_cpu_info_sccb *sccb;\n\tint length = test_facility(140) ? EXT_SCCB_READ_CPU : PAGE_SIZE;\n\tint rc = 0;\n\n\tif (!SCLP_HAS_CPU_INFO)\n\t\treturn -EOPNOTSUPP;\n\n\tsccb = memblock_alloc_low(length, PAGE_SIZE);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\n\tmemset(sccb, 0, length);\n\tsccb->header.length = length;\n\tsccb->header.control_mask[2] = 0x80;\n\tif (sclp_early_cmd(SCLP_CMDW_READ_CPU_INFO, sccb)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (sccb->header.response_code != 0x0010) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tsclp_fill_core_info(info, sccb);\nout:\n\tmemblock_free(sccb, length);\n\treturn rc;\n}\n\nstatic void __init sclp_early_console_detect(struct init_sccb *sccb)\n{\n\tif (sccb->header.response_code != 0x20)\n\t\treturn;\n\n\tif (sclp_early_con_check_vt220(sccb))\n\t\tsclp.has_vt220 = 1;\n\n\tif (sclp_early_con_check_linemode(sccb))\n\t\tsclp.has_linemode = 1;\n}\n\nvoid __init __no_sanitize_address sclp_early_adjust_va(void)\n{\n\tsclp_early_sccb = __va((unsigned long)sclp_early_sccb);\n}\n\nvoid __init sclp_early_detect(void)\n{\n\tvoid *sccb = sclp_early_sccb;\n\n\tsclp_early_facilities_detect();\n\n\t \n\tsclp_early_set_event_mask(sccb, 0, 0);\n\tsclp_early_console_detect(sccb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}