{
  "module_name": "tape_proc.c",
  "hash_id": "671b614d3b30d0d27ce3f488b0d259482a400773b6bd6ca9c3d06dc5955a4197",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/tape_proc.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"tape\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n\n#define TAPE_DBF_AREA\ttape_core_dbf\n\n#include \"tape.h\"\n\nstatic const char *tape_med_st_verbose[MS_SIZE] =\n{\n\t[MS_UNKNOWN] = \"UNKNOWN \",\n\t[MS_LOADED] = \"LOADED  \",\n\t[MS_UNLOADED] = \"UNLOADED\"\n};\n\n \nstatic struct proc_dir_entry *tape_proc_devices;\n\n \nstatic int tape_proc_show(struct seq_file *m, void *v)\n{\n\tstruct tape_device *device;\n\tstruct tape_request *request;\n\tconst char *str;\n\tunsigned long n;\n\n\tn = (unsigned long) v - 1;\n\tif (!n) {\n\t\tseq_printf(m, \"TapeNo\\tBusID      CuType/Model\\t\"\n\t\t\t\"DevType/Model\\tBlkSize\\tState\\tOp\\tMedState\\n\");\n\t}\n\tdevice = tape_find_device(n);\n\tif (IS_ERR(device))\n\t\treturn 0;\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\tseq_printf(m, \"%d\\t\", (int) n);\n\tseq_printf(m, \"%-10.10s \", dev_name(&device->cdev->dev));\n\tseq_printf(m, \"%04X/\", device->cdev->id.cu_type);\n\tseq_printf(m, \"%02X\\t\", device->cdev->id.cu_model);\n\tseq_printf(m, \"%04X/\", device->cdev->id.dev_type);\n\tseq_printf(m, \"%02X\\t\\t\", device->cdev->id.dev_model);\n\tif (device->char_data.block_size == 0)\n\t\tseq_printf(m, \"auto\\t\");\n\telse\n\t\tseq_printf(m, \"%i\\t\", device->char_data.block_size);\n\tif (device->tape_state >= 0 &&\n\t    device->tape_state < TS_SIZE)\n\t\tstr = tape_state_verbose[device->tape_state];\n\telse\n\t\tstr = \"UNKNOWN\";\n\tseq_printf(m, \"%s\\t\", str);\n\tif (!list_empty(&device->req_queue)) {\n\t\trequest = list_entry(device->req_queue.next,\n\t\t\t\t     struct tape_request, list);\n\t\tstr = tape_op_verbose[request->op];\n\t} else\n\t\tstr = \"---\";\n\tseq_printf(m, \"%s\\t\", str);\n\tseq_printf(m, \"%s\\n\", tape_med_st_verbose[device->medium_state]);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\ttape_put_device(device);\n        return 0;\n}\n\nstatic void *tape_proc_start(struct seq_file *m, loff_t *pos)\n{\n\tif (*pos >= 256 / TAPE_MINORS_PER_DEV)\n\t\treturn NULL;\n\treturn (void *)((unsigned long) *pos + 1);\n}\n\nstatic void *tape_proc_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn tape_proc_start(m, pos);\n}\n\nstatic void tape_proc_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic const struct seq_operations tape_proc_seq = {\n\t.start\t\t= tape_proc_start,\n\t.next\t\t= tape_proc_next,\n\t.stop\t\t= tape_proc_stop,\n\t.show\t\t= tape_proc_show,\n};\n\n \nvoid\ntape_proc_init(void)\n{\n\ttape_proc_devices = proc_create_seq(\"tapedevices\", 0444, NULL,\n\t\t\t\t\t    &tape_proc_seq);\n}\n\n \nvoid\ntape_proc_cleanup(void)\n{\n\tif (tape_proc_devices != NULL)\n\t\tremove_proc_entry (\"tapedevices\", NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}