{
  "module_name": "tape_34xx.c",
  "hash_id": "c5f3757a061b0939008084e0505826cac52c6112dc61fde9fe8e2f265163beb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/tape_34xx.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"tape_34xx\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bio.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n\n#define TAPE_DBF_AREA\ttape_34xx_dbf\n\n#include \"tape.h\"\n#include \"tape_std.h\"\n\n \ndebug_info_t *TAPE_DBF_AREA = NULL;\nEXPORT_SYMBOL(TAPE_DBF_AREA);\n\n#define TAPE34XX_FMT_3480\t0\n#define TAPE34XX_FMT_3480_2_XF\t1\n#define TAPE34XX_FMT_3480_XF\t2\n\nstruct tape_34xx_block_id {\n\tunsigned int\twrap\t\t: 1;\n\tunsigned int\tsegment\t\t: 7;\n\tunsigned int\tformat\t\t: 2;\n\tunsigned int\tblock\t\t: 22;\n};\n\n \nstruct tape_34xx_sbid {\n\tstruct list_head\t\tlist;\n\tstruct tape_34xx_block_id\tbid;\n};\n\nstatic void tape_34xx_delete_sbid_from(struct tape_device *, int);\n\n \nstatic void __tape_34xx_medium_sense(struct tape_request *request)\n{\n\tstruct tape_device *device = request->device;\n\tunsigned char *sense;\n\n\tif (request->rc == 0) {\n\t\tsense = request->cpdata;\n\n\t\t \n\t\tif (sense[0] & SENSE_INTERVENTION_REQUIRED)\n\t\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\telse\n\t\t\ttape_med_state_set(device, MS_LOADED);\n\n\t\tif (sense[1] & SENSE_WRITE_PROTECT)\n\t\t\tdevice->tape_generic_status |= GMT_WR_PROT(~0);\n\t\telse\n\t\t\tdevice->tape_generic_status &= ~GMT_WR_PROT(~0);\n\t} else\n\t\tDBF_EVENT(4, \"tape_34xx: medium sense failed with rc=%d\\n\",\n\t\t\trequest->rc);\n\ttape_free_request(request);\n}\n\nstatic int tape_34xx_medium_sense(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\tint rc;\n\n\trequest = tape_alloc_request(1, 32);\n\tif (IS_ERR(request)) {\n\t\tDBF_EXCEPTION(6, \"MSEN fail\\n\");\n\t\treturn PTR_ERR(request);\n\t}\n\n\trequest->op = TO_MSEN;\n\ttape_ccw_end(request->cpaddr, SENSE, 32, request->cpdata);\n\trc = tape_do_io_interruptible(device, request);\n\t__tape_34xx_medium_sense(request);\n\treturn rc;\n}\n\nstatic void tape_34xx_medium_sense_async(struct tape_device *device)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(1, 32);\n\tif (IS_ERR(request)) {\n\t\tDBF_EXCEPTION(6, \"MSEN fail\\n\");\n\t\treturn;\n\t}\n\n\trequest->op = TO_MSEN;\n\ttape_ccw_end(request->cpaddr, SENSE, 32, request->cpdata);\n\trequest->callback = (void *) __tape_34xx_medium_sense;\n\trequest->callback_data = NULL;\n\ttape_do_io_async(device, request);\n}\n\nstruct tape_34xx_work {\n\tstruct tape_device\t*device;\n\tenum tape_op\t\t op;\n\tstruct work_struct\t work;\n};\n\n \nstatic void\ntape_34xx_work_handler(struct work_struct *work)\n{\n\tstruct tape_34xx_work *p =\n\t\tcontainer_of(work, struct tape_34xx_work, work);\n\tstruct tape_device *device = p->device;\n\n\tswitch(p->op) {\n\t\tcase TO_MSEN:\n\t\t\ttape_34xx_medium_sense_async(device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBF_EVENT(3, \"T34XX: internal error: unknown work\\n\");\n\t}\n\ttape_put_device(device);\n\tkfree(p);\n}\n\nstatic int\ntape_34xx_schedule_work(struct tape_device *device, enum tape_op op)\n{\n\tstruct tape_34xx_work *p;\n\n\tif ((p = kzalloc(sizeof(*p), GFP_ATOMIC)) == NULL)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&p->work, tape_34xx_work_handler);\n\n\tp->device = tape_get_device(device);\n\tp->op     = op;\n\n\tschedule_work(&p->work);\n\treturn 0;\n}\n\n \nstatic inline int\ntape_34xx_done(struct tape_request *request)\n{\n\tDBF_EVENT(6, \"%s done\\n\", tape_op_verbose[request->op]);\n\n\tswitch (request->op) {\n\t\tcase TO_DSE:\n\t\tcase TO_RUN:\n\t\tcase TO_WRI:\n\t\tcase TO_WTM:\n\t\tcase TO_ASSIGN:\n\t\tcase TO_UNASSIGN:\n\t\t\ttape_34xx_delete_sbid_from(request->device, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\treturn TAPE_IO_SUCCESS;\n}\n\nstatic inline int\ntape_34xx_erp_failed(struct tape_request *request, int rc)\n{\n\tDBF_EVENT(3, \"Error recovery failed for %s (RC=%d)\\n\",\n\t\t  tape_op_verbose[request->op], rc);\n\treturn rc;\n}\n\nstatic inline int\ntape_34xx_erp_succeeded(struct tape_request *request)\n{\n\tDBF_EVENT(3, \"Error Recovery successful for %s\\n\",\n\t\t  tape_op_verbose[request->op]);\n\treturn tape_34xx_done(request);\n}\n\nstatic inline int\ntape_34xx_erp_retry(struct tape_request *request)\n{\n\tDBF_EVENT(3, \"xerp retr %s\\n\", tape_op_verbose[request->op]);\n\treturn TAPE_IO_RETRY;\n}\n\n \nstatic int\ntape_34xx_unsolicited_irq(struct tape_device *device, struct irb *irb)\n{\n\tif (irb->scsw.cmd.dstat == 0x85) {  \n\t\t \n\t\tDBF_EVENT(6, \"xuud med\\n\");\n\t\ttape_34xx_delete_sbid_from(device, 0);\n\t\ttape_34xx_schedule_work(device, TO_MSEN);\n\t} else {\n\t\tDBF_EVENT(3, \"unsol.irq! dev end: %08x\\n\", device->cdev_id);\n\t\ttape_dump_sense_dbf(device, NULL, irb);\n\t}\n\treturn TAPE_IO_SUCCESS;\n}\n\n \nstatic int\ntape_34xx_erp_read_opposite(struct tape_device *device,\n\t\t\t    struct tape_request *request)\n{\n\tif (request->op == TO_RFO) {\n\t\t \n\t\ttape_std_read_backward(device, request);\n\t\treturn tape_34xx_erp_retry(request);\n\t}\n\n\t \n\treturn tape_34xx_erp_failed(request, -EIO);\n}\n\nstatic int\ntape_34xx_erp_bug(struct tape_device *device, struct tape_request *request,\n\t\t  struct irb *irb, int no)\n{\n\tif (request->op != TO_ASSIGN) {\n\t\tdev_err(&device->cdev->dev, \"An unexpected condition %d \"\n\t\t\t\"occurred in tape error recovery\\n\", no);\n\t\ttape_dump_sense_dbf(device, request, irb);\n\t}\n\treturn tape_34xx_erp_failed(request, -EIO);\n}\n\n \nstatic int\ntape_34xx_erp_overrun(struct tape_device *device, struct tape_request *request,\n\t\t      struct irb *irb)\n{\n\tif (irb->ecw[3] == 0x40) {\n\t\tdev_warn (&device->cdev->dev, \"A data overrun occurred between\"\n\t\t\t\" the control unit and tape unit\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t}\n\treturn tape_34xx_erp_bug(device, request, irb, -1);\n}\n\n \nstatic int\ntape_34xx_erp_sequence(struct tape_device *device,\n\t\t       struct tape_request *request, struct irb *irb)\n{\n\tif (irb->ecw[3] == 0x41) {\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The block ID sequence on the \"\n\t\t\t\"tape is incorrect\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t}\n\t \n\treturn tape_34xx_erp_bug(device, request, irb, -2);\n}\n\n \nstatic int\ntape_34xx_unit_check(struct tape_device *device, struct tape_request *request,\n\t\t     struct irb *irb)\n{\n\tint inhibit_cu_recovery;\n\t__u8* sense;\n\n\tinhibit_cu_recovery = (*device->modeset_byte & 0x80) ? 1 : 0;\n\tsense = irb->ecw;\n\n\tif (\n\t\tsense[0] & SENSE_COMMAND_REJECT &&\n\t\tsense[1] & SENSE_WRITE_PROTECT\n\t) {\n\t\tif (\n\t\t\trequest->op == TO_DSE ||\n\t\t\trequest->op == TO_WRI ||\n\t\t\trequest->op == TO_WTM\n\t\t) {\n\t\t\t \n\t\t\treturn tape_34xx_erp_failed(request, -EACCES);\n\t\t} else {\n\t\t\treturn tape_34xx_erp_bug(device, request, irb, -3);\n\t\t}\n\t}\n\n\t \n\tif ((\n\t\tsense[0] == SENSE_DATA_CHECK      ||\n\t\tsense[0] == SENSE_EQUIPMENT_CHECK ||\n\t\tsense[0] == (SENSE_EQUIPMENT_CHECK | SENSE_DEFERRED_UNIT_CHECK)\n\t) && (\n\t\tsense[1] == SENSE_DRIVE_ONLINE ||\n\t\tsense[1] == (SENSE_BEGINNING_OF_TAPE | SENSE_WRITE_MODE)\n\t)) {\n\t\tswitch (request->op) {\n\t\t \n\t\tcase TO_FSF:\n\t\tcase TO_FSB:\n\t\t\t \n\t\t\treturn tape_34xx_erp_failed(request, -ENOSPC);\n\t\tcase TO_BSB:\n\t\t\treturn tape_34xx_erp_retry(request);\n\n\t\t \n\t\tcase TO_LBL:\n\t\t\t \n\t\t\ttape_34xx_delete_sbid_from(device, 0);\n\t\t\treturn tape_34xx_erp_failed(request, -EIO);\n\n\t\tcase TO_RFO:\n\t\t\t \n\t\t\treturn tape_34xx_erp_failed(request, 0);\n\n\t\t \n\t\tcase TO_WRI:\n\t\t\t \n\t\t\treturn tape_34xx_erp_failed(request, -ENOSPC);\n\t\tdefault:\n\t\t\treturn tape_34xx_erp_failed(request, 0);\n\t\t}\n\t}\n\n\t \n\tif (sense[0] & SENSE_BUS_OUT_CHECK)\n\t\treturn tape_34xx_erp_retry(request);\n\n\tif (sense[0] & SENSE_DATA_CHECK) {\n\t\t \n\t\tswitch (sense[3]) {\n\t\tcase 0x23:\n\t\t\t \n\t\t\tif ((sense[2] & SENSE_TAPE_SYNC_MODE) ||\n\t\t\t    inhibit_cu_recovery)\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\treturn tape_34xx_erp_bug(device, request,\n\t\t\t\t\t\t\t irb, -4);\n\n\t\t\t \n\t\t\tdev_warn (&device->cdev->dev, \"A read error occurred \"\n\t\t\t\t\"that cannot be recovered\\n\");\n\t\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t\tcase 0x25:\n\t\t\t \n\t\t\tif ((sense[2] & SENSE_TAPE_SYNC_MODE) ||\n\t\t\t    inhibit_cu_recovery)\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\treturn tape_34xx_erp_bug(device, request,\n\t\t\t\t\t\t\t irb, -5);\n\n\t\t\t \n\t\t\tdev_warn (&device->cdev->dev, \"A write error on the \"\n\t\t\t\t\"tape cannot be recovered\\n\");\n\t\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t\tcase 0x26:\n\t\t\t \n\t\t\treturn tape_34xx_erp_read_opposite(device, request);\n\t\tcase 0x28:\n\t\t\t \n\t\t\tdev_warn (&device->cdev->dev, \"Writing the ID-mark \"\n\t\t\t\t\"failed\\n\");\n\t\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t\tcase 0x31:\n\t\t\t \n\t\t\tdev_warn (&device->cdev->dev, \"Reading the tape beyond\"\n\t\t\t\t\" the end of the recorded area failed\\n\");\n\t\t\treturn tape_34xx_erp_failed(request, -ENOSPC);\n\t\tcase 0x41:\n\t\t\t \n\t\t\tdev_warn (&device->cdev->dev, \"The tape contains an \"\n\t\t\t\t\"incorrect block ID sequence\\n\");\n\t\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t\tdefault:\n\t\t\t \n\t\t\tif (device->cdev->id.driver_info == tape_3480)\n\t\t\t\treturn tape_34xx_erp_bug(device, request,\n\t\t\t\t\t\t\t irb, -6);\n\t\t}\n\t}\n\n\tif (sense[0] & SENSE_OVERRUN)\n\t\treturn tape_34xx_erp_overrun(device, request, irb);\n\n\tif (sense[1] & SENSE_RECORD_SEQUENCE_ERR)\n\t\treturn tape_34xx_erp_sequence(device, request, irb);\n\n\t \n\tswitch (sense[3]) {\n\tcase 0x00:\n\t\t \n\t\treturn TAPE_IO_SUCCESS;\n\tcase 0x21:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x22:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"A path equipment check occurred\"\n\t\t\t\" for the tape device\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x24:\n\t\t \n\t\treturn tape_34xx_erp_succeeded(request);\n\tcase 0x27:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x29:\n\t\t \n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x2a:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x2b:\n\t\t \n\t\tif (request->op == TO_RUN) {\n\t\t\t \n\t\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\t\treturn tape_34xx_erp_succeeded(request);\n\t\t}\n\t\t \n\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);\n\tcase 0x2c:\n\t\t \n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x2d:\n\t\t \n\t\tif (request->op == TO_DSE)\n\t\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t\t \n\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);\n\tcase 0x2e:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit cannot process \"\n\t\t\t\"the tape format\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EMEDIUMTYPE);\n\tcase 0x30:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape medium is write-\"\n\t\t\t\"protected\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EACCES);\n\tcase 0x32:\n\t\t\n\t\tdev_warn (&device->cdev->dev, \"The tape does not have the \"\n\t\t\t\"required tape tension\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x33:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit failed to load\"\n\t\t\t\" the cartridge\\n\");\n\t\ttape_34xx_delete_sbid_from(device, 0);\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x34:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"Automatic unloading of the tape\"\n\t\t\t\" cartridge failed\\n\");\n\t\tif (request->op == TO_RUN)\n\t\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);\n\tcase 0x35:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"An equipment check has occurred\"\n\t\t\t\" on the tape unit\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x36:\n\t\tif (device->cdev->id.driver_info == tape_3490)\n\t\t\t \n\t\t\treturn tape_34xx_erp_failed(request, -EIO);\n\t\t \n\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);\n\tcase 0x37:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape information states an\"\n\t\t\t\" incorrect length\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x38:\n\t\t \n\t\tif (request->op==TO_WRI ||\n\t\t    request->op==TO_DSE ||\n\t\t    request->op==TO_WTM)\n\t\t\treturn tape_34xx_erp_failed(request, -ENOSPC);\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x39:\n\t\t \n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x3a:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit is not ready\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x3b:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape medium has been \"\n\t\t\t\"rewound or unloaded manually\\n\");\n\t\ttape_34xx_delete_sbid_from(device, 0);\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x42:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape subsystem is running \"\n\t\t\t\"in degraded mode\\n\");\n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x43:\n\t\t \n\t\ttape_34xx_delete_sbid_from(device, 0);\n\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\t \n\t\tif (sense[1] & SENSE_DRIVE_ONLINE) {\n\t\t\tswitch(request->op) {\n\t\t\t\tcase TO_ASSIGN:\n\t\t\t\tcase TO_UNASSIGN:\n\t\t\t\tcase TO_DIS:\n\t\t\t\tcase TO_NOP:\n\t\t\t\t\treturn tape_34xx_done(request);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn tape_34xx_erp_failed(request, -ENOMEDIUM);\n\tcase 0x44:\n\t\t \n\t\tif (request->op != TO_BLOCK && request->op != TO_LBL)\n\t\t\t \n\t\t\treturn tape_34xx_erp_bug(device, request,\n\t\t\t\t\t\t irb, sense[3]);\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x45:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit is already \"\n\t\t\t\"assigned\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x46:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit is not online\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x47:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The control unit has fenced \"\n\t\t\t\"access to the tape volume\\n\");\n\t\ttape_34xx_delete_sbid_from(device, 0);\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x48:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x49:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"A parity error occurred on the \"\n\t\t\t\"tape bus\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x4a:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"I/O error recovery failed on \"\n\t\t\t\"the tape control unit\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x4b:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit requires a \"\n\t\t\t\"firmware update\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x4c:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x4d:\n\t\tif (device->cdev->id.driver_info == tape_3490)\n\t\t\t \n\t\t\treturn tape_34xx_erp_retry(request);\n\t\t \n\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);\n\tcase 0x4e:\n\t\tif (device->cdev->id.driver_info == tape_3490) {\n\t\t\t \n\t\t\tdev_warn (&device->cdev->dev, \"The maximum block size\"\n\t\t\t\t\" for buffered mode is exceeded\\n\");\n\t\t\treturn tape_34xx_erp_failed(request, -ENOBUFS);\n\t\t}\n\t\t \n\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);\n\tcase 0x50:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x51:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x52:\n\t\t \n\t\tif (request->op == TO_RUN) {\n\t\t\ttape_med_state_set(device, MS_UNLOADED);\n\t\t\ttape_34xx_delete_sbid_from(device, 0);\n\t\t\treturn tape_34xx_erp_succeeded(request);\n\t\t}\n\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);\n\tcase 0x53:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x54:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x55:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"A channel interface error cannot be\"\n\t\t\t\" recovered\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x56:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"A channel protocol error \"\n\t\t\t\"occurred\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x57:\n\t\t \n\t\treturn tape_34xx_erp_retry(request);\n\tcase 0x5a:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit does not support \"\n\t\t\t\"the tape length\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x5b:\n\t\t \n\t\tif (sense[1] & SENSE_BEGINNING_OF_TAPE)\n\t\t\t \n\t\t\treturn tape_34xx_erp_retry(request);\n\t\tdev_warn (&device->cdev->dev, \"The tape unit does not support\"\n\t\t\t\" format 3480 XF\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x5c:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit does not support tape \"\n\t\t\t\"format 3480-2 XF\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EIO);\n\tcase 0x5d:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit does not support\"\n\t\t\t\" the current tape length\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EMEDIUMTYPE);\n\tcase 0x5e:\n\t\t \n\t\tdev_warn (&device->cdev->dev, \"The tape unit does not support\"\n\t\t\t\" the compaction algorithm\\n\");\n\t\treturn tape_34xx_erp_failed(request, -EMEDIUMTYPE);\n\n\t\t \n\tcase 0x23:  \n\tcase 0x25:  \n\tcase 0x26:  \n\tcase 0x28:  \n\tcase 0x31:  \n\tcase 0x40:  \n\tcase 0x41:  \n\t\t \n\tdefault:\n\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);\n\t}\n}\n\n \nstatic int\ntape_34xx_irq(struct tape_device *device, struct tape_request *request,\n\t      struct irb *irb)\n{\n\tif (request == NULL)\n\t\treturn tape_34xx_unsolicited_irq(device, irb);\n\n\tif ((irb->scsw.cmd.dstat & DEV_STAT_UNIT_EXCEP) &&\n\t    (irb->scsw.cmd.dstat & DEV_STAT_DEV_END) &&\n\t    (request->op == TO_WRI)) {\n\t\t \n\t\treturn tape_34xx_erp_failed(request, -ENOSPC);\n\t}\n\n\tif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\n\t\treturn tape_34xx_unit_check(device, request, irb);\n\n\tif (irb->scsw.cmd.dstat & DEV_STAT_DEV_END) {\n\t\t \n\t\tif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_EXCEP) {\n\t\t\tif (request->op == TO_BSB || request->op == TO_FSB)\n\t\t\t\trequest->rescnt++;\n\t\t\telse\n\t\t\t\tDBF_EVENT(5, \"Unit Exception!\\n\");\n\t\t}\n\t\treturn tape_34xx_done(request);\n\t}\n\n\tDBF_EVENT(6, \"xunknownirq\\n\");\n\ttape_dump_sense_dbf(device, request, irb);\n\treturn TAPE_IO_STOP;\n}\n\n \nstatic int\ntape_34xx_ioctl(struct tape_device *device, unsigned int cmd, unsigned long arg)\n{\n\tif (cmd == TAPE390_DISPLAY) {\n\t\tstruct display_struct disp;\n\n\t\tif (copy_from_user(&disp, (char __user *) arg, sizeof(disp)) != 0)\n\t\t\treturn -EFAULT;\n\n\t\treturn tape_std_display(device, &disp);\n\t} else\n\t\treturn -EINVAL;\n}\n\nstatic inline void\ntape_34xx_append_new_sbid(struct tape_34xx_block_id bid, struct list_head *l)\n{\n\tstruct tape_34xx_sbid *\tnew_sbid;\n\n\tnew_sbid = kmalloc(sizeof(*new_sbid), GFP_ATOMIC);\n\tif (!new_sbid)\n\t\treturn;\n\n\tnew_sbid->bid = bid;\n\tlist_add(&new_sbid->list, l);\n}\n\n \nstatic void\ntape_34xx_add_sbid(struct tape_device *device, struct tape_34xx_block_id bid)\n{\n\tstruct list_head *\tsbid_list;\n\tstruct tape_34xx_sbid *\tsbid;\n\tstruct list_head *\tl;\n\n\t \n\tsbid_list = (struct list_head *) device->discdata;\n\tif (!sbid_list || (bid.segment < 2 && bid.wrap == 0))\n\t\treturn;\n\n\t \n\tlist_for_each(l, sbid_list) {\n\t\tsbid = list_entry(l, struct tape_34xx_sbid, list);\n\n\t\tif (\n\t\t\t(sbid->bid.segment == bid.segment) &&\n\t\t\t(sbid->bid.wrap    == bid.wrap)\n\t\t) {\n\t\t\tif (bid.block < sbid->bid.block)\n\t\t\t\tsbid->bid = bid;\n\t\t\telse return;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (bid.block < sbid->bid.block) {\n\t\t\ttape_34xx_append_new_sbid(bid, l->prev);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (l == sbid_list)\n\t\ttape_34xx_append_new_sbid(bid, l->prev);\n\n\tDBF_LH(4, \"Current list is:\\n\");\n\tlist_for_each(l, sbid_list) {\n\t\tsbid = list_entry(l, struct tape_34xx_sbid, list);\n\t\tDBF_LH(4, \"%d:%03d@%05d\\n\",\n\t\t\tsbid->bid.wrap,\n\t\t\tsbid->bid.segment,\n\t\t\tsbid->bid.block\n\t\t);\n\t}\n}\n\n \nstatic void\ntape_34xx_delete_sbid_from(struct tape_device *device, int from)\n{\n\tstruct list_head *\tsbid_list;\n\tstruct tape_34xx_sbid *\tsbid;\n\tstruct list_head *\tl;\n\tstruct list_head *\tn;\n\n\tsbid_list = (struct list_head *) device->discdata;\n\tif (!sbid_list)\n\t\treturn;\n\n\tlist_for_each_safe(l, n, sbid_list) {\n\t\tsbid = list_entry(l, struct tape_34xx_sbid, list);\n\t\tif (sbid->bid.block >= from) {\n\t\t\tDBF_LH(4, \"Delete sbid %d:%03d@%05d\\n\",\n\t\t\t\tsbid->bid.wrap,\n\t\t\t\tsbid->bid.segment,\n\t\t\t\tsbid->bid.block\n\t\t\t);\n\t\t\tlist_del(l);\n\t\t\tkfree(sbid);\n\t\t}\n\t}\n}\n\n \nstatic void\ntape_34xx_merge_sbid(\n\tstruct tape_device *\t\tdevice,\n\tstruct tape_34xx_block_id *\tbid\n) {\n\tstruct tape_34xx_sbid *\tsbid;\n\tstruct tape_34xx_sbid *\tsbid_to_use;\n\tstruct list_head *\tsbid_list;\n\tstruct list_head *\tl;\n\n\tsbid_list = (struct list_head *) device->discdata;\n\tbid->wrap    = 0;\n\tbid->segment = 1;\n\n\tif (!sbid_list || list_empty(sbid_list))\n\t\treturn;\n\n\tsbid_to_use = NULL;\n\tlist_for_each(l, sbid_list) {\n\t\tsbid = list_entry(l, struct tape_34xx_sbid, list);\n\n\t\tif (sbid->bid.block >= bid->block)\n\t\t\tbreak;\n\t\tsbid_to_use = sbid;\n\t}\n\tif (sbid_to_use) {\n\t\tbid->wrap    = sbid_to_use->bid.wrap;\n\t\tbid->segment = sbid_to_use->bid.segment;\n\t\tDBF_LH(4, \"Use %d:%03d@%05d for %05d\\n\",\n\t\t\tsbid_to_use->bid.wrap,\n\t\t\tsbid_to_use->bid.segment,\n\t\t\tsbid_to_use->bid.block,\n\t\t\tbid->block\n\t\t);\n\t}\n}\n\nstatic int\ntape_34xx_setup_device(struct tape_device * device)\n{\n\tint\t\t\trc;\n\tstruct list_head *\tdiscdata;\n\n\tDBF_EVENT(6, \"34xx device setup\\n\");\n\tif ((rc = tape_std_assign(device)) == 0) {\n\t\tif ((rc = tape_34xx_medium_sense(device)) != 0) {\n\t\t\tDBF_LH(3, \"34xx medium sense returned %d\\n\", rc);\n\t\t}\n\t}\n\tdiscdata = kmalloc(sizeof(struct list_head), GFP_KERNEL);\n\tif (discdata) {\n\t\t\tINIT_LIST_HEAD(discdata);\n\t\t\tdevice->discdata = discdata;\n\t}\n\n\treturn rc;\n}\n\nstatic void\ntape_34xx_cleanup_device(struct tape_device *device)\n{\n\ttape_std_unassign(device);\n\t\n\tif (device->discdata) {\n\t\ttape_34xx_delete_sbid_from(device, 0);\n\t\tkfree(device->discdata);\n\t\tdevice->discdata = NULL;\n\t}\n}\n\n\n \nstatic int\ntape_34xx_mttell(struct tape_device *device, int mt_count)\n{\n\tstruct {\n\t\tstruct tape_34xx_block_id\tcbid;\n\t\tstruct tape_34xx_block_id\tdbid;\n\t} __attribute__ ((packed)) block_id;\n\tint rc;\n\n\trc = tape_std_read_block_id(device, (__u64 *) &block_id);\n\tif (rc)\n\t\treturn rc;\n\n\ttape_34xx_add_sbid(device, block_id.cbid);\n\treturn block_id.cbid.block;\n}\n\n \nstatic int\ntape_34xx_mtseek(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\tstruct tape_34xx_block_id *\tbid;\n\n\tif (mt_count > 0x3fffff) {\n\t\tDBF_EXCEPTION(6, \"xsee parm\\n\");\n\t\treturn -EINVAL;\n\t}\n\trequest = tape_alloc_request(3, 4);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\n\t \n\trequest->op = TO_LBL;\n\tbid         = (struct tape_34xx_block_id *) request->cpdata;\n\tbid->format = (*device->modeset_byte & 0x08) ?\n\t\t\tTAPE34XX_FMT_3480_XF : TAPE34XX_FMT_3480;\n\tbid->block  = mt_count;\n\ttape_34xx_merge_sbid(device, bid);\n\n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_cc(request->cpaddr + 1, LOCATE, 4, request->cpdata);\n\ttape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\n\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nstatic tape_mtop_fn tape_34xx_mtop[TAPE_NR_MTOPS] = {\n\t[MTRESET]\t = tape_std_mtreset,\n\t[MTFSF]\t\t = tape_std_mtfsf,\n\t[MTBSF]\t\t = tape_std_mtbsf,\n\t[MTFSR]\t\t = tape_std_mtfsr,\n\t[MTBSR]\t\t = tape_std_mtbsr,\n\t[MTWEOF]\t = tape_std_mtweof,\n\t[MTREW]\t\t = tape_std_mtrew,\n\t[MTOFFL]\t = tape_std_mtoffl,\n\t[MTNOP]\t\t = tape_std_mtnop,\n\t[MTRETEN]\t = tape_std_mtreten,\n\t[MTBSFM]\t = tape_std_mtbsfm,\n\t[MTFSFM]\t = tape_std_mtfsfm,\n\t[MTEOM]\t\t = tape_std_mteom,\n\t[MTERASE]\t = tape_std_mterase,\n\t[MTRAS1]\t = NULL,\n\t[MTRAS2]\t = NULL,\n\t[MTRAS3]\t = NULL,\n\t[MTSETBLK]\t = tape_std_mtsetblk,\n\t[MTSETDENSITY]\t = NULL,\n\t[MTSEEK]\t = tape_34xx_mtseek,\n\t[MTTELL]\t = tape_34xx_mttell,\n\t[MTSETDRVBUFFER] = NULL,\n\t[MTFSS]\t\t = NULL,\n\t[MTBSS]\t\t = NULL,\n\t[MTWSM]\t\t = NULL,\n\t[MTLOCK]\t = NULL,\n\t[MTUNLOCK]\t = NULL,\n\t[MTLOAD]\t = tape_std_mtload,\n\t[MTUNLOAD]\t = tape_std_mtunload,\n\t[MTCOMPRESSION]\t = tape_std_mtcompression,\n\t[MTSETPART]\t = NULL,\n\t[MTMKPART]\t = NULL\n};\n\n \nstatic struct tape_discipline tape_discipline_34xx = {\n\t.owner = THIS_MODULE,\n\t.setup_device = tape_34xx_setup_device,\n\t.cleanup_device = tape_34xx_cleanup_device,\n\t.process_eov = tape_std_process_eov,\n\t.irq = tape_34xx_irq,\n\t.read_block = tape_std_read_block,\n\t.write_block = tape_std_write_block,\n\t.ioctl_fn = tape_34xx_ioctl,\n\t.mtop_array = tape_34xx_mtop\n};\n\nstatic struct ccw_device_id tape_34xx_ids[] = {\n\t{ CCW_DEVICE_DEVTYPE(0x3480, 0, 0x3480, 0), .driver_info = tape_3480},\n\t{ CCW_DEVICE_DEVTYPE(0x3490, 0, 0x3490, 0), .driver_info = tape_3490},\n\t{   },\n};\n\nstatic int\ntape_34xx_online(struct ccw_device *cdev)\n{\n\treturn tape_generic_online(\n\t\tdev_get_drvdata(&cdev->dev),\n\t\t&tape_discipline_34xx\n\t);\n}\n\nstatic struct ccw_driver tape_34xx_driver = {\n\t.driver = {\n\t\t.name = \"tape_34xx\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.ids = tape_34xx_ids,\n\t.probe = tape_generic_probe,\n\t.remove = tape_generic_remove,\n\t.set_online = tape_34xx_online,\n\t.set_offline = tape_generic_offline,\n\t.int_class = IRQIO_TAP,\n};\n\nstatic int\ntape_34xx_init (void)\n{\n\tint rc;\n\n\tTAPE_DBF_AREA = debug_register ( \"tape_34xx\", 2, 2, 4*sizeof(long));\n\tdebug_register_view(TAPE_DBF_AREA, &debug_sprintf_view);\n#ifdef DBF_LIKE_HELL\n\tdebug_set_level(TAPE_DBF_AREA, 6);\n#endif\n\n\tDBF_EVENT(3, \"34xx init\\n\");\n\t \n\trc = ccw_driver_register(&tape_34xx_driver);\n\tif (rc)\n\t\tDBF_EVENT(3, \"34xx init failed\\n\");\n\telse\n\t\tDBF_EVENT(3, \"34xx registered\\n\");\n\treturn rc;\n}\n\nstatic void\ntape_34xx_exit(void)\n{\n\tccw_driver_unregister(&tape_34xx_driver);\n\n\tdebug_unregister(TAPE_DBF_AREA);\n}\n\nMODULE_DEVICE_TABLE(ccw, tape_34xx_ids);\nMODULE_AUTHOR(\"(C) 2001-2002 IBM Deutschland Entwicklung GmbH\");\nMODULE_DESCRIPTION(\"Linux on zSeries channel attached 3480 tape device driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(tape_34xx_init);\nmodule_exit(tape_34xx_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}