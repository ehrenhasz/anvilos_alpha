{
  "module_name": "vmlogrdr.c",
  "hash_id": "a1f69611f603e5e305021bd21ef5f09c64c13e184463e62a150da6e92cb14841",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/vmlogrdr.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"vmlogrdr\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <asm/cpcmd.h>\n#include <asm/debug.h>\n#include <asm/ebcdic.h>\n#include <net/iucv/iucv.h>\n#include <linux/kmod.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/string.h>\n\nMODULE_AUTHOR\n\t(\"(C) 2004 IBM Corporation by Xenia Tkatschow (xenia@us.ibm.com)\\n\"\n\t \"                            Stefan Weinhuber (wein@de.ibm.com)\");\nMODULE_DESCRIPTION (\"Character device driver for reading z/VM \"\n\t\t    \"system service records.\");\nMODULE_LICENSE(\"GPL\");\n\n\n \n#define NET_BUFFER_SIZE\t(PAGE_SIZE - sizeof(int) - sizeof(FENCE))\n\n \nstruct vmlogrdr_priv_t {\n\tchar system_service[8];\n\tchar internal_name[8];\n\tchar recording_name[8];\n\tstruct iucv_path *path;\n\tint connection_established;\n\tint iucv_path_severed;\n\tstruct iucv_message local_interrupt_buffer;\n\tatomic_t receive_ready;\n\tint minor_num;\n\tchar * buffer;\n\tchar * current_position;\n\tint remaining;\n\tulong residual_length;\n\tint buffer_free;\n\tint dev_in_use;  \n\tspinlock_t priv_lock;\n\tstruct device  *device;\n\tstruct device  *class_device;\n\tint autorecording;\n\tint autopurge;\n};\n\n\n \nstatic int vmlogrdr_open(struct inode *, struct file *);\nstatic int vmlogrdr_release(struct inode *, struct file *);\nstatic ssize_t vmlogrdr_read (struct file *filp, char __user *data,\n\t\t\t      size_t count, loff_t * ppos);\n\nstatic const struct file_operations vmlogrdr_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = vmlogrdr_open,\n\t.release = vmlogrdr_release,\n\t.read    = vmlogrdr_read,\n\t.llseek  = no_llseek,\n};\n\n\nstatic void vmlogrdr_iucv_path_complete(struct iucv_path *, u8 *ipuser);\nstatic void vmlogrdr_iucv_path_severed(struct iucv_path *, u8 *ipuser);\nstatic void vmlogrdr_iucv_message_pending(struct iucv_path *,\n\t\t\t\t\t  struct iucv_message *);\n\n\nstatic struct iucv_handler vmlogrdr_iucv_handler = {\n\t.path_complete\t = vmlogrdr_iucv_path_complete,\n\t.path_severed\t = vmlogrdr_iucv_path_severed,\n\t.message_pending = vmlogrdr_iucv_message_pending,\n};\n\n\nstatic DECLARE_WAIT_QUEUE_HEAD(conn_wait_queue);\nstatic DECLARE_WAIT_QUEUE_HEAD(read_wait_queue);\n\n \n\nstatic struct vmlogrdr_priv_t sys_ser[] = {\n\t{ .system_service = \"*LOGREC \",\n\t  .internal_name  = \"logrec\",\n\t  .recording_name = \"EREP\",\n\t  .minor_num      = 0,\n\t  .buffer_free    = 1,\n\t  .priv_lock\t  = __SPIN_LOCK_UNLOCKED(sys_ser[0].priv_lock),\n\t  .autorecording  = 1,\n\t  .autopurge      = 1,\n\t},\n\t{ .system_service = \"*ACCOUNT\",\n\t  .internal_name  = \"account\",\n\t  .recording_name = \"ACCOUNT\",\n\t  .minor_num      = 1,\n\t  .buffer_free    = 1,\n\t  .priv_lock\t  = __SPIN_LOCK_UNLOCKED(sys_ser[1].priv_lock),\n\t  .autorecording  = 1,\n\t  .autopurge      = 1,\n\t},\n\t{ .system_service = \"*SYMPTOM\",\n\t  .internal_name  = \"symptom\",\n\t  .recording_name = \"SYMPTOM\",\n\t  .minor_num      = 2,\n\t  .buffer_free    = 1,\n\t  .priv_lock\t  = __SPIN_LOCK_UNLOCKED(sys_ser[2].priv_lock),\n\t  .autorecording  = 1,\n\t  .autopurge      = 1,\n\t}\n};\n\n#define MAXMINOR  ARRAY_SIZE(sys_ser)\n\nstatic char FENCE[] = {\"EOR\"};\nstatic int vmlogrdr_major = 0;\nstatic struct cdev  *vmlogrdr_cdev = NULL;\nstatic int recording_class_AB;\n\n\nstatic void vmlogrdr_iucv_path_complete(struct iucv_path *path, u8 *ipuser)\n{\n\tstruct vmlogrdr_priv_t * logptr = path->private;\n\n\tspin_lock(&logptr->priv_lock);\n\tlogptr->connection_established = 1;\n\tspin_unlock(&logptr->priv_lock);\n\twake_up(&conn_wait_queue);\n}\n\n\nstatic void vmlogrdr_iucv_path_severed(struct iucv_path *path, u8 *ipuser)\n{\n\tstruct vmlogrdr_priv_t * logptr = path->private;\n\tu8 reason = (u8) ipuser[8];\n\n\tpr_err(\"vmlogrdr: connection severed with reason %i\\n\", reason);\n\n\tiucv_path_sever(path, NULL);\n\tkfree(path);\n\tlogptr->path = NULL;\n\n\tspin_lock(&logptr->priv_lock);\n\tlogptr->connection_established = 0;\n\tlogptr->iucv_path_severed = 1;\n\tspin_unlock(&logptr->priv_lock);\n\n\twake_up(&conn_wait_queue);\n\t \n\twake_up_interruptible(&read_wait_queue);\n}\n\n\nstatic void vmlogrdr_iucv_message_pending(struct iucv_path *path,\n\t\t\t\t\t  struct iucv_message *msg)\n{\n\tstruct vmlogrdr_priv_t * logptr = path->private;\n\n\t \n\tspin_lock(&logptr->priv_lock);\n\tmemcpy(&logptr->local_interrupt_buffer, msg, sizeof(*msg));\n\tatomic_inc(&logptr->receive_ready);\n\tspin_unlock(&logptr->priv_lock);\n\twake_up_interruptible(&read_wait_queue);\n}\n\n\nstatic int vmlogrdr_get_recording_class_AB(void)\n{\n\tstatic const char cp_command[] = \"QUERY COMMAND RECORDING \";\n\tchar cp_response[80];\n\tchar *tail;\n\tint len,i;\n\n\tcpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\n\tlen = strnlen(cp_response,sizeof(cp_response));\n\t\n\ttail=strnchr(cp_response,len,'=');\n\tif (!tail)\n\t\treturn 0;\n\ttail++;\n\tif (!strncmp(\"ANY\",tail,3))\n\t\treturn 1;\n\tif (!strncmp(\"NONE\",tail,4))\n\t\treturn 0;\n\t \n        for (i=tail-cp_response; i<len; i++)\n\t\tif ( cp_response[i]=='A' || cp_response[i]=='B' )\n\t\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic int vmlogrdr_recording(struct vmlogrdr_priv_t * logptr,\n\t\t\t      int action, int purge)\n{\n\n\tchar cp_command[80];\n\tchar cp_response[160];\n\tchar *onoff, *qid_string;\n\tint rc;\n\n\tonoff = ((action == 1) ? \"ON\" : \"OFF\");\n\tqid_string = ((recording_class_AB == 1) ? \" QID * \" : \"\");\n\n\t \n\tif (purge && (action == 1)) {\n\t\tmemset(cp_command, 0x00, sizeof(cp_command));\n\t\tmemset(cp_response, 0x00, sizeof(cp_response));\n\t\tsnprintf(cp_command, sizeof(cp_command),\n\t\t\t \"RECORDING %s PURGE %s\",\n\t\t\t logptr->recording_name,\n\t\t\t qid_string);\n\t\tcpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\n\t}\n\n\tmemset(cp_command, 0x00, sizeof(cp_command));\n\tmemset(cp_response, 0x00, sizeof(cp_response));\n\tsnprintf(cp_command, sizeof(cp_command), \"RECORDING %s %s %s\",\n\t\tlogptr->recording_name,\n\t\tonoff,\n\t\tqid_string);\n\tcpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\n\t \n\tif (strstr(cp_response,\"Command complete\"))\n\t\trc = 0;\n\telse\n\t\trc = -EIO;\n\t \n\tif (purge && (action == 0)) {\n\t\tmemset(cp_command, 0x00, sizeof(cp_command));\n\t\tmemset(cp_response, 0x00, sizeof(cp_response));\n\t\tsnprintf(cp_command, sizeof(cp_command),\n\t\t\t \"RECORDING %s PURGE %s\",\n\t\t\t logptr->recording_name,\n\t\t\t qid_string);\n\t\tcpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\n\t}\n\n\treturn rc;\n}\n\n\nstatic int vmlogrdr_open (struct inode *inode, struct file *filp)\n{\n\tint dev_num = 0;\n\tstruct vmlogrdr_priv_t * logptr = NULL;\n\tint connect_rc = 0;\n\tint ret;\n\n\tdev_num = iminor(inode);\n\tif (dev_num >= MAXMINOR)\n\t\treturn -ENODEV;\n\tlogptr = &sys_ser[dev_num];\n\n\t \n\tif (filp->f_flags & O_NONBLOCK)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tspin_lock_bh(&logptr->priv_lock);\n\tif (logptr->dev_in_use)\t{\n\t\tspin_unlock_bh(&logptr->priv_lock);\n\t\treturn -EBUSY;\n\t}\n\tlogptr->dev_in_use = 1;\n\tlogptr->connection_established = 0;\n\tlogptr->iucv_path_severed = 0;\n\tatomic_set(&logptr->receive_ready, 0);\n\tlogptr->buffer_free = 1;\n\tspin_unlock_bh(&logptr->priv_lock);\n\n\t \n\tfilp->private_data = logptr;\n\n\t \n\tif (logptr->autorecording) {\n\t\tret = vmlogrdr_recording(logptr,1,logptr->autopurge);\n\t\tif (ret)\n\t\t\tpr_warn(\"vmlogrdr: failed to start recording automatically\\n\");\n\t}\n\n\t \n\tlogptr->path = iucv_path_alloc(10, 0, GFP_KERNEL);\n\tif (!logptr->path)\n\t\tgoto out_dev;\n\tconnect_rc = iucv_path_connect(logptr->path, &vmlogrdr_iucv_handler,\n\t\t\t\t       logptr->system_service, NULL, NULL,\n\t\t\t\t       logptr);\n\tif (connect_rc) {\n\t\tpr_err(\"vmlogrdr: iucv connection to %s \"\n\t\t       \"failed with rc %i \\n\",\n\t\t       logptr->system_service, connect_rc);\n\t\tgoto out_path;\n\t}\n\n\t \n\twait_event(conn_wait_queue, (logptr->connection_established)\n\t\t   || (logptr->iucv_path_severed));\n\tif (logptr->iucv_path_severed)\n\t\tgoto out_record;\n\tnonseekable_open(inode, filp);\n\treturn 0;\n\nout_record:\n\tif (logptr->autorecording)\n\t\tvmlogrdr_recording(logptr,0,logptr->autopurge);\nout_path:\n\tkfree(logptr->path);\t \n\tlogptr->path = NULL;\nout_dev:\n\tlogptr->dev_in_use = 0;\n\treturn -EIO;\n}\n\n\nstatic int vmlogrdr_release (struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tstruct vmlogrdr_priv_t * logptr = filp->private_data;\n\n\tiucv_path_sever(logptr->path, NULL);\n\tkfree(logptr->path);\n\tlogptr->path = NULL;\n\tif (logptr->autorecording) {\n\t\tret = vmlogrdr_recording(logptr,0,logptr->autopurge);\n\t\tif (ret)\n\t\t\tpr_warn(\"vmlogrdr: failed to stop recording automatically\\n\");\n\t}\n\tlogptr->dev_in_use = 0;\n\n\treturn 0;\n}\n\n\nstatic int vmlogrdr_receive_data(struct vmlogrdr_priv_t *priv)\n{\n\tint rc, *temp;\n\t \n\tint user_data_count, iucv_data_count;\n\tchar * buffer;\n\n\tif (atomic_read(&priv->receive_ready)) {\n\t\tspin_lock_bh(&priv->priv_lock);\n\t\tif (priv->residual_length){\n\t\t\t \n\t\t\tiucv_data_count = priv->residual_length;\n\t\t\tuser_data_count = 0;\n\t\t\tbuffer = priv->buffer;\n\t\t} else {\n\t\t\t \n\t\t\tiucv_data_count = priv->local_interrupt_buffer.length;\n\t\t\tuser_data_count = sizeof(int);\n\t\t\ttemp = (int*)priv->buffer;\n\t\t\t*temp= iucv_data_count + sizeof(FENCE);\n\t\t\tbuffer = priv->buffer + sizeof(int);\n\t\t}\n\t\t \n\t\tif (iucv_data_count > NET_BUFFER_SIZE)\n\t\t\tiucv_data_count = NET_BUFFER_SIZE;\n\t\trc = iucv_message_receive(priv->path,\n\t\t\t\t\t  &priv->local_interrupt_buffer,\n\t\t\t\t\t  0, buffer, iucv_data_count,\n\t\t\t\t\t  &priv->residual_length);\n\t\tspin_unlock_bh(&priv->priv_lock);\n\t\t \n\t\tif (rc == 5)\n\t\t\trc = 0;\n\t\tif (rc == 9)\n\t\t\tatomic_set(&priv->receive_ready, 0);\n\t} else {\n\t\trc = 1;\n\t}\n\tif (!rc) {\n\t\tpriv->buffer_free = 0;\n \t\tuser_data_count += iucv_data_count;\n\t\tpriv->current_position = priv->buffer;\n\t\tif (priv->residual_length == 0){\n\t\t\t \n\t\t\tatomic_dec(&priv->receive_ready);\n\t\t\tbuffer = priv->buffer + user_data_count;\n\t\t\tmemcpy(buffer, FENCE, sizeof(FENCE));\n\t\t\tuser_data_count += sizeof(FENCE);\n\t\t}\n\t\tpriv->remaining = user_data_count;\n\t}\n\n\treturn rc;\n}\n\n\nstatic ssize_t vmlogrdr_read(struct file *filp, char __user *data,\n\t\t\t     size_t count, loff_t * ppos)\n{\n\tint rc;\n\tstruct vmlogrdr_priv_t * priv = filp->private_data;\n\n\twhile (priv->buffer_free) {\n\t\trc = vmlogrdr_receive_data(priv);\n\t\tif (rc) {\n\t\t\trc = wait_event_interruptible(read_wait_queue,\n\t\t\t\t\tatomic_read(&priv->receive_ready));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\t \n\tif (count > priv->remaining)\n\t\tcount = priv->remaining;\n\n\tif (copy_to_user(data, priv->current_position, count))\n\t\treturn -EFAULT;\n\n\t*ppos += count;\n\tpriv->current_position += count;\n\tpriv->remaining -= count;\n\n\t \n\tif (priv->remaining == 0)\n\t\tpriv->buffer_free = 1;\n\n\treturn count;\n}\n\nstatic ssize_t vmlogrdr_autopurge_store(struct device * dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char * buf, size_t count)\n{\n\tstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\n\tssize_t ret = count;\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tpriv->autopurge=0;\n\t\tbreak;\n\tcase '1':\n\t\tpriv->autopurge=1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\n\nstatic ssize_t vmlogrdr_autopurge_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", priv->autopurge);\n}\n\n\nstatic DEVICE_ATTR(autopurge, 0644, vmlogrdr_autopurge_show,\n\t\t   vmlogrdr_autopurge_store);\n\n\nstatic ssize_t vmlogrdr_purge_store(struct device * dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char * buf, size_t count)\n{\n\n\tchar cp_command[80];\n\tchar cp_response[80];\n\tstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\n\n\tif (buf[0] != '1')\n\t\treturn -EINVAL;\n\n\tmemset(cp_command, 0x00, sizeof(cp_command));\n\tmemset(cp_response, 0x00, sizeof(cp_response));\n\n         \n\n\tif (recording_class_AB)\n\t\tsnprintf(cp_command, sizeof(cp_command),\n\t\t\t \"RECORDING %s PURGE QID * \",\n\t\t\t priv->recording_name);\n\telse\n\t\tsnprintf(cp_command, sizeof(cp_command),\n\t\t\t \"RECORDING %s PURGE \",\n\t\t\t priv->recording_name);\n\n\tcpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\n\n\treturn count;\n}\n\n\nstatic DEVICE_ATTR(purge, 0200, NULL, vmlogrdr_purge_store);\n\n\nstatic ssize_t vmlogrdr_autorecording_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\n\tssize_t ret = count;\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tpriv->autorecording=0;\n\t\tbreak;\n\tcase '1':\n\t\tpriv->autorecording=1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\n\nstatic ssize_t vmlogrdr_autorecording_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", priv->autorecording);\n}\n\n\nstatic DEVICE_ATTR(autorecording, 0644, vmlogrdr_autorecording_show,\n\t\t   vmlogrdr_autorecording_store);\n\n\nstatic ssize_t vmlogrdr_recording_store(struct device * dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char * buf, size_t count)\n{\n\tstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tret = vmlogrdr_recording(priv,0,0);\n\t\tbreak;\n\tcase '1':\n\t\tret = vmlogrdr_recording(priv,1,0);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\treturn ret;\n\telse\n\t\treturn count;\n\n}\n\n\nstatic DEVICE_ATTR(recording, 0200, NULL, vmlogrdr_recording_store);\n\n\nstatic ssize_t recording_status_show(struct device_driver *driver, char *buf)\n{\n\tstatic const char cp_command[] = \"QUERY RECORDING \";\n\tint len;\n\n\tcpcmd(cp_command, buf, 4096, NULL);\n\tlen = strlen(buf);\n\treturn len;\n}\nstatic DRIVER_ATTR_RO(recording_status);\nstatic struct attribute *vmlogrdr_drv_attrs[] = {\n\t&driver_attr_recording_status.attr,\n\tNULL,\n};\nstatic struct attribute_group vmlogrdr_drv_attr_group = {\n\t.attrs = vmlogrdr_drv_attrs,\n};\nstatic const struct attribute_group *vmlogrdr_drv_attr_groups[] = {\n\t&vmlogrdr_drv_attr_group,\n\tNULL,\n};\n\nstatic struct attribute *vmlogrdr_attrs[] = {\n\t&dev_attr_autopurge.attr,\n\t&dev_attr_purge.attr,\n\t&dev_attr_autorecording.attr,\n\t&dev_attr_recording.attr,\n\tNULL,\n};\nstatic struct attribute_group vmlogrdr_attr_group = {\n\t.attrs = vmlogrdr_attrs,\n};\nstatic const struct attribute_group *vmlogrdr_attr_groups[] = {\n\t&vmlogrdr_attr_group,\n\tNULL,\n};\n\nstatic struct class *vmlogrdr_class;\nstatic struct device_driver vmlogrdr_driver = {\n\t.name = \"vmlogrdr\",\n\t.bus  = &iucv_bus,\n\t.groups = vmlogrdr_drv_attr_groups,\n};\n\nstatic int vmlogrdr_register_driver(void)\n{\n\tint ret;\n\n\t \n\tret = iucv_register(&vmlogrdr_iucv_handler, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = driver_register(&vmlogrdr_driver);\n\tif (ret)\n\t\tgoto out_iucv;\n\n\tvmlogrdr_class = class_create(\"vmlogrdr\");\n\tif (IS_ERR(vmlogrdr_class)) {\n\t\tret = PTR_ERR(vmlogrdr_class);\n\t\tvmlogrdr_class = NULL;\n\t\tgoto out_driver;\n\t}\n\treturn 0;\n\nout_driver:\n\tdriver_unregister(&vmlogrdr_driver);\nout_iucv:\n\tiucv_unregister(&vmlogrdr_iucv_handler, 1);\nout:\n\treturn ret;\n}\n\n\nstatic void vmlogrdr_unregister_driver(void)\n{\n\tclass_destroy(vmlogrdr_class);\n\tvmlogrdr_class = NULL;\n\tdriver_unregister(&vmlogrdr_driver);\n\tiucv_unregister(&vmlogrdr_iucv_handler, 1);\n}\n\n\nstatic int vmlogrdr_register_device(struct vmlogrdr_priv_t *priv)\n{\n\tstruct device *dev;\n\tint ret;\n\n\tdev = kzalloc(sizeof(struct device), GFP_KERNEL);\n\tif (dev) {\n\t\tdev_set_name(dev, \"%s\", priv->internal_name);\n\t\tdev->bus = &iucv_bus;\n\t\tdev->parent = iucv_root;\n\t\tdev->driver = &vmlogrdr_driver;\n\t\tdev->groups = vmlogrdr_attr_groups;\n\t\tdev_set_drvdata(dev, priv);\n\t\t \n\t\tdev->release = (void (*)(struct device *))kfree;\n\t} else\n\t\treturn -ENOMEM;\n\tret = device_register(dev);\n\tif (ret) {\n\t\tput_device(dev);\n\t\treturn ret;\n\t}\n\n\tpriv->class_device = device_create(vmlogrdr_class, dev,\n\t\t\t\t\t   MKDEV(vmlogrdr_major,\n\t\t\t\t\t\t priv->minor_num),\n\t\t\t\t\t   priv, \"%s\", dev_name(dev));\n\tif (IS_ERR(priv->class_device)) {\n\t\tret = PTR_ERR(priv->class_device);\n\t\tpriv->class_device=NULL;\n\t\tdevice_unregister(dev);\n\t\treturn ret;\n\t}\n\tpriv->device = dev;\n\treturn 0;\n}\n\n\nstatic int vmlogrdr_unregister_device(struct vmlogrdr_priv_t *priv)\n{\n\tdevice_destroy(vmlogrdr_class, MKDEV(vmlogrdr_major, priv->minor_num));\n\tif (priv->device != NULL) {\n\t\tdevice_unregister(priv->device);\n\t\tpriv->device=NULL;\n\t}\n\treturn 0;\n}\n\n\nstatic int vmlogrdr_register_cdev(dev_t dev)\n{\n\tint rc = 0;\n\tvmlogrdr_cdev = cdev_alloc();\n\tif (!vmlogrdr_cdev) {\n\t\treturn -ENOMEM;\n\t}\n\tvmlogrdr_cdev->owner = THIS_MODULE;\n\tvmlogrdr_cdev->ops = &vmlogrdr_fops;\n\trc = cdev_add(vmlogrdr_cdev, dev, MAXMINOR);\n\tif (!rc)\n\t\treturn 0;\n\n\t\n\tkobject_put(&vmlogrdr_cdev->kobj);\n\tvmlogrdr_cdev=NULL;\n\treturn rc;\n}\n\n\nstatic void vmlogrdr_cleanup(void)\n{\n        int i;\n\n\tif (vmlogrdr_cdev) {\n\t\tcdev_del(vmlogrdr_cdev);\n\t\tvmlogrdr_cdev=NULL;\n\t}\n\tfor (i=0; i < MAXMINOR; ++i ) {\n\t\tvmlogrdr_unregister_device(&sys_ser[i]);\n\t\tfree_page((unsigned long)sys_ser[i].buffer);\n\t}\n\tvmlogrdr_unregister_driver();\n\tif (vmlogrdr_major) {\n\t\tunregister_chrdev_region(MKDEV(vmlogrdr_major, 0), MAXMINOR);\n\t\tvmlogrdr_major=0;\n\t}\n}\n\n\nstatic int __init vmlogrdr_init(void)\n{\n\tint rc;\n\tint i;\n\tdev_t dev;\n\n\tif (! MACHINE_IS_VM) {\n\t\tpr_err(\"not running under VM, driver not loaded.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n        recording_class_AB = vmlogrdr_get_recording_class_AB();\n\n\trc = alloc_chrdev_region(&dev, 0, MAXMINOR, \"vmlogrdr\");\n\tif (rc)\n\t\treturn rc;\n\tvmlogrdr_major = MAJOR(dev);\n\n\trc=vmlogrdr_register_driver();\n\tif (rc)\n\t\tgoto cleanup;\n\n\tfor (i=0; i < MAXMINOR; ++i ) {\n\t\tsys_ser[i].buffer = (char *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\t\tif (!sys_ser[i].buffer) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tsys_ser[i].current_position = sys_ser[i].buffer;\n\t\trc=vmlogrdr_register_device(&sys_ser[i]);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tif (rc)\n\t\tgoto cleanup;\n\n\trc = vmlogrdr_register_cdev(dev);\n\tif (rc)\n\t\tgoto cleanup;\n\treturn 0;\n\ncleanup:\n\tvmlogrdr_cleanup();\n\treturn rc;\n}\n\n\nstatic void __exit vmlogrdr_exit(void)\n{\n\tvmlogrdr_cleanup();\n\treturn;\n}\n\n\nmodule_init(vmlogrdr_init);\nmodule_exit(vmlogrdr_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}