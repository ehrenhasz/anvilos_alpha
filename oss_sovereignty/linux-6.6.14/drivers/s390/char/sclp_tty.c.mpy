{
  "module_name": "sclp_tty.c",
  "hash_id": "6be89f206ac7aab975e29e81757ede06aa65b8943d98f0fb9de5d1bf351d5f63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_tty.c",
  "human_readable_source": "\n \n\n#include <linux/kmod.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n\n#include \"ctrlchar.h\"\n#include \"sclp.h\"\n#include \"sclp_rw.h\"\n#include \"sclp_tty.h\"\n\n \n#define SCLP_TTY_BUF_SIZE 512\n\n \n\n \nstatic DEFINE_SPINLOCK(sclp_tty_lock);\n \nstatic LIST_HEAD(sclp_tty_pages);\n \nstatic LIST_HEAD(sclp_tty_outqueue);\n \nstatic int sclp_tty_buffer_count;\n \nstatic struct sclp_buffer *sclp_ttybuf;\n \nstatic struct timer_list sclp_tty_timer;\n\nstatic struct tty_port sclp_port;\nstatic u8 sclp_tty_chars[SCLP_TTY_BUF_SIZE];\nstatic unsigned short int sclp_tty_chars_count;\n\nstruct tty_driver *sclp_tty_driver;\n\nstatic int sclp_tty_tolower;\n\n#define SCLP_TTY_COLUMNS 320\n#define SPACES_PER_TAB 8\n#define CASE_DELIMITER 0x6c  \n\n \nstatic int\nsclp_tty_open(struct tty_struct *tty, struct file *filp)\n{\n\ttty_port_tty_set(&sclp_port, tty);\n\ttty->driver_data = NULL;\n\treturn 0;\n}\n\n \nstatic void\nsclp_tty_close(struct tty_struct *tty, struct file *filp)\n{\n\tif (tty->count > 1)\n\t\treturn;\n\ttty_port_tty_set(&sclp_port, NULL);\n}\n\n \nstatic unsigned int\nsclp_tty_write_room (struct tty_struct *tty)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\tunsigned int count;\n\n\tspin_lock_irqsave(&sclp_tty_lock, flags);\n\tcount = 0;\n\tif (sclp_ttybuf != NULL)\n\t\tcount = sclp_buffer_space(sclp_ttybuf) / sizeof(struct msg_buf);\n\tlist_for_each(l, &sclp_tty_pages)\n\t\tcount += NR_EMPTY_MSG_PER_SCCB;\n\tspin_unlock_irqrestore(&sclp_tty_lock, flags);\n\treturn count;\n}\n\nstatic void\nsclp_ttybuf_callback(struct sclp_buffer *buffer, int rc)\n{\n\tunsigned long flags;\n\tvoid *page;\n\n\tdo {\n\t\tpage = sclp_unmake_buffer(buffer);\n\t\tspin_lock_irqsave(&sclp_tty_lock, flags);\n\t\t \n\t\tlist_del(&buffer->list);\n\t\tsclp_tty_buffer_count--;\n\t\tlist_add_tail((struct list_head *) page, &sclp_tty_pages);\n\t\t \n\t\tbuffer = NULL;\n\t\tif (!list_empty(&sclp_tty_outqueue))\n\t\t\tbuffer = list_entry(sclp_tty_outqueue.next,\n\t\t\t\t\t    struct sclp_buffer, list);\n\t\tspin_unlock_irqrestore(&sclp_tty_lock, flags);\n\t} while (buffer && sclp_emit_buffer(buffer, sclp_ttybuf_callback));\n\n\ttty_port_tty_wakeup(&sclp_port);\n}\n\nstatic inline void\n__sclp_ttybuf_emit(struct sclp_buffer *buffer)\n{\n\tunsigned long flags;\n\tint count;\n\tint rc;\n\n\tspin_lock_irqsave(&sclp_tty_lock, flags);\n\tlist_add_tail(&buffer->list, &sclp_tty_outqueue);\n\tcount = sclp_tty_buffer_count++;\n\tspin_unlock_irqrestore(&sclp_tty_lock, flags);\n\tif (count)\n\t\treturn;\n\trc = sclp_emit_buffer(buffer, sclp_ttybuf_callback);\n\tif (rc)\n\t\tsclp_ttybuf_callback(buffer, rc);\n}\n\n \nstatic void\nsclp_tty_timeout(struct timer_list *unused)\n{\n\tunsigned long flags;\n\tstruct sclp_buffer *buf;\n\n\tspin_lock_irqsave(&sclp_tty_lock, flags);\n\tbuf = sclp_ttybuf;\n\tsclp_ttybuf = NULL;\n\tspin_unlock_irqrestore(&sclp_tty_lock, flags);\n\n\tif (buf != NULL) {\n\t\t__sclp_ttybuf_emit(buf);\n\t}\n}\n\n \nstatic int sclp_tty_write_string(const u8 *str, int count, int may_fail)\n{\n\tunsigned long flags;\n\tvoid *page;\n\tint written;\n\tint overall_written;\n\tstruct sclp_buffer *buf;\n\n\tif (count <= 0)\n\t\treturn 0;\n\toverall_written = 0;\n\tspin_lock_irqsave(&sclp_tty_lock, flags);\n\tdo {\n\t\t \n\t\tif (sclp_ttybuf == NULL) {\n\t\t\twhile (list_empty(&sclp_tty_pages)) {\n\t\t\t\tspin_unlock_irqrestore(&sclp_tty_lock, flags);\n\t\t\t\tif (may_fail)\n\t\t\t\t\tgoto out;\n\t\t\t\telse\n\t\t\t\t\tsclp_sync_wait();\n\t\t\t\tspin_lock_irqsave(&sclp_tty_lock, flags);\n\t\t\t}\n\t\t\tpage = sclp_tty_pages.next;\n\t\t\tlist_del((struct list_head *) page);\n\t\t\tsclp_ttybuf = sclp_make_buffer(page, SCLP_TTY_COLUMNS,\n\t\t\t\t\t\t       SPACES_PER_TAB);\n\t\t}\n\t\t \n\t\twritten = sclp_write(sclp_ttybuf, str, count);\n\t\toverall_written += written;\n\t\tif (written == count)\n\t\t\tbreak;\n\t\t \n\t\tbuf = sclp_ttybuf;\n\t\tsclp_ttybuf = NULL;\n\t\tspin_unlock_irqrestore(&sclp_tty_lock, flags);\n\t\t__sclp_ttybuf_emit(buf);\n\t\tspin_lock_irqsave(&sclp_tty_lock, flags);\n\t\tstr += written;\n\t\tcount -= written;\n\t} while (count > 0);\n\t \n\tif (sclp_ttybuf && sclp_chars_in_buffer(sclp_ttybuf) &&\n\t    !timer_pending(&sclp_tty_timer)) {\n\t\tmod_timer(&sclp_tty_timer, jiffies + HZ / 10);\n\t}\n\tspin_unlock_irqrestore(&sclp_tty_lock, flags);\nout:\n\treturn overall_written;\n}\n\n \nstatic ssize_t\nsclp_tty_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tif (sclp_tty_chars_count > 0) {\n\t\tsclp_tty_write_string(sclp_tty_chars, sclp_tty_chars_count, 0);\n\t\tsclp_tty_chars_count = 0;\n\t}\n\treturn sclp_tty_write_string(buf, count, 1);\n}\n\n \nstatic int\nsclp_tty_put_char(struct tty_struct *tty, u8 ch)\n{\n\tsclp_tty_chars[sclp_tty_chars_count++] = ch;\n\tif (ch == '\\n' || sclp_tty_chars_count >= SCLP_TTY_BUF_SIZE) {\n\t\tsclp_tty_write_string(sclp_tty_chars, sclp_tty_chars_count, 0);\n\t\tsclp_tty_chars_count = 0;\n\t}\n\treturn 1;\n}\n\n \nstatic void\nsclp_tty_flush_chars(struct tty_struct *tty)\n{\n\tif (sclp_tty_chars_count > 0) {\n\t\tsclp_tty_write_string(sclp_tty_chars, sclp_tty_chars_count, 0);\n\t\tsclp_tty_chars_count = 0;\n\t}\n}\n\n \nstatic unsigned int\nsclp_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\tstruct sclp_buffer *t;\n\tunsigned int count = 0;\n\n\tspin_lock_irqsave(&sclp_tty_lock, flags);\n\tif (sclp_ttybuf != NULL)\n\t\tcount = sclp_chars_in_buffer(sclp_ttybuf);\n\tlist_for_each_entry(t, &sclp_tty_outqueue, list) {\n\t\tcount += sclp_chars_in_buffer(t);\n\t}\n\tspin_unlock_irqrestore(&sclp_tty_lock, flags);\n\treturn count;\n}\n\n \nstatic void\nsclp_tty_flush_buffer(struct tty_struct *tty)\n{\n\tif (sclp_tty_chars_count > 0) {\n\t\tsclp_tty_write_string(sclp_tty_chars, sclp_tty_chars_count, 0);\n\t\tsclp_tty_chars_count = 0;\n\t}\n}\n\n \nstatic void\nsclp_tty_input(unsigned char* buf, unsigned int count)\n{\n\tstruct tty_struct *tty = tty_port_tty_get(&sclp_port);\n\tunsigned int cchar;\n\n\t \n\tif (tty == NULL)\n\t\treturn;\n\tcchar = ctrlchar_handle(buf, count, tty);\n\tswitch (cchar & CTRLCHAR_MASK) {\n\tcase CTRLCHAR_SYSRQ:\n\t\tbreak;\n\tcase CTRLCHAR_CTRL:\n\t\ttty_insert_flip_char(&sclp_port, cchar, TTY_NORMAL);\n\t\ttty_flip_buffer_push(&sclp_port);\n\t\tbreak;\n\tcase CTRLCHAR_NONE:\n\t\t \n\t\tif (count < 2 ||\n\t\t    (strncmp((const char *) buf + count - 2, \"^n\", 2) &&\n\t\t     strncmp((const char *) buf + count - 2, \"\\252n\", 2))) {\n\t\t\t \n\t\t\ttty_insert_flip_string(&sclp_port, buf, count);\n\t\t\ttty_insert_flip_char(&sclp_port, '\\n', TTY_NORMAL);\n\t\t} else\n\t\t\ttty_insert_flip_string(&sclp_port, buf, count - 2);\n\t\ttty_flip_buffer_push(&sclp_port);\n\t\tbreak;\n\t}\n\ttty_kref_put(tty);\n}\n\n \nstatic int sclp_switch_cases(unsigned char *buf, int count)\n{\n\tunsigned char *ip, *op;\n\tint toggle;\n\n\t \n\ttoggle = 0;\n\tip = op = buf;\n\twhile (count-- > 0) {\n\t\t \n\t\tif (*ip == CASE_DELIMITER) {\n\t\t\t \n\t\t\tif (count && ip[1] == CASE_DELIMITER) {\n\t\t\t\t \n\t\t\t\t*op++ = *ip++;\n\t\t\t\tcount--;\n\t\t\t} else\n\t\t\t\t \n\t\t\t\ttoggle = ~toggle;\n\t\t\t \n\t\t\tip++;\n\t\t} else\n\t\t\t \n\t\t\tif (toggle)\n\t\t\t\t \n\t\t\t\tif (sclp_tty_tolower)\n\t\t\t\t\t \n\t\t\t\t\t*op++ = _ebc_toupper[(int) *ip++];\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\t*op++ = _ebc_tolower[(int) *ip++];\n\t\t\telse\n\t\t\t\t \n\t\t\t\t*op++ = *ip++;\n\t}\n\t \n\treturn op - buf;\n}\n\nstatic void sclp_get_input(struct gds_subvector *sv)\n{\n\tunsigned char *str;\n\tint count;\n\n\tstr = (unsigned char *) (sv + 1);\n\tcount = sv->length - sizeof(*sv);\n\tif (sclp_tty_tolower)\n\t\tEBC_TOLOWER(str, count);\n\tcount = sclp_switch_cases(str, count);\n\t \n\tsclp_ebcasc_str(str, count);\n\n\t \n\tsclp_tty_input(str, count);\n}\n\nstatic inline void sclp_eval_selfdeftextmsg(struct gds_subvector *sv)\n{\n\tvoid *end;\n\n\tend = (void *) sv + sv->length;\n\tfor (sv = sv + 1; (void *) sv < end; sv = (void *) sv + sv->length)\n\t\tif (sv->key == 0x30)\n\t\t\tsclp_get_input(sv);\n}\n\nstatic inline void sclp_eval_textcmd(struct gds_vector *v)\n{\n\tstruct gds_subvector *sv;\n\tvoid *end;\n\n\tend = (void *) v + v->length;\n\tfor (sv = (struct gds_subvector *) (v + 1);\n\t     (void *) sv < end; sv = (void *) sv + sv->length)\n\t\tif (sv->key == GDS_KEY_SELFDEFTEXTMSG)\n\t\t\tsclp_eval_selfdeftextmsg(sv);\n\n}\n\nstatic inline void sclp_eval_cpmsu(struct gds_vector *v)\n{\n\tvoid *end;\n\n\tend = (void *) v + v->length;\n\tfor (v = v + 1; (void *) v < end; v = (void *) v + v->length)\n\t\tif (v->gds_id == GDS_ID_TEXTCMD)\n\t\t\tsclp_eval_textcmd(v);\n}\n\n\nstatic inline void sclp_eval_mdsmu(struct gds_vector *v)\n{\n\tv = sclp_find_gds_vector(v + 1, (void *) v + v->length, GDS_ID_CPMSU);\n\tif (v)\n\t\tsclp_eval_cpmsu(v);\n}\n\nstatic void sclp_tty_receiver(struct evbuf_header *evbuf)\n{\n\tstruct gds_vector *v;\n\n\tv = sclp_find_gds_vector(evbuf + 1, (void *) evbuf + evbuf->length,\n\t\t\t\t GDS_ID_MDSMU);\n\tif (v)\n\t\tsclp_eval_mdsmu(v);\n}\n\nstatic void\nsclp_tty_state_change(struct sclp_register *reg)\n{\n}\n\nstatic struct sclp_register sclp_input_event =\n{\n\t.receive_mask = EVTYP_OPCMD_MASK | EVTYP_PMSGCMD_MASK,\n\t.state_change_fn = sclp_tty_state_change,\n\t.receiver_fn = sclp_tty_receiver\n};\n\nstatic const struct tty_operations sclp_ops = {\n\t.open = sclp_tty_open,\n\t.close = sclp_tty_close,\n\t.write = sclp_tty_write,\n\t.put_char = sclp_tty_put_char,\n\t.flush_chars = sclp_tty_flush_chars,\n\t.write_room = sclp_tty_write_room,\n\t.chars_in_buffer = sclp_tty_chars_in_buffer,\n\t.flush_buffer = sclp_tty_flush_buffer,\n};\n\nstatic int __init\nsclp_tty_init(void)\n{\n\tstruct tty_driver *driver;\n\tvoid *page;\n\tint i;\n\tint rc;\n\n\t \n\tif (MACHINE_IS_VM && !CONSOLE_IS_SCLP)\n\t\treturn 0;\n\tif (!sclp.has_linemode)\n\t\treturn 0;\n\tdriver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);\n\tif (IS_ERR(driver))\n\t\treturn PTR_ERR(driver);\n\n\trc = sclp_rw_init();\n\tif (rc) {\n\t\ttty_driver_kref_put(driver);\n\t\treturn rc;\n\t}\n\t \n\tfor (i = 0; i < MAX_KMEM_PAGES; i++) {\n\t\tpage = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\t\tif (page == NULL) {\n\t\t\ttty_driver_kref_put(driver);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add_tail((struct list_head *) page, &sclp_tty_pages);\n\t}\n\ttimer_setup(&sclp_tty_timer, sclp_tty_timeout, 0);\n\tsclp_ttybuf = NULL;\n\tsclp_tty_buffer_count = 0;\n\tif (MACHINE_IS_VM) {\n\t\t \n\t\tsclp_tty_tolower = 1;\n\t}\n\tsclp_tty_chars_count = 0;\n\n\trc = sclp_register(&sclp_input_event);\n\tif (rc) {\n\t\ttty_driver_kref_put(driver);\n\t\treturn rc;\n\t}\n\n\ttty_port_init(&sclp_port);\n\n\tdriver->driver_name = \"sclp_line\";\n\tdriver->name = \"sclp_line\";\n\tdriver->major = TTY_MAJOR;\n\tdriver->minor_start = 64;\n\tdriver->type = TTY_DRIVER_TYPE_SYSTEM;\n\tdriver->subtype = SYSTEM_TYPE_TTY;\n\tdriver->init_termios = tty_std_termios;\n\tdriver->init_termios.c_iflag = IGNBRK | IGNPAR;\n\tdriver->init_termios.c_oflag = ONLCR;\n\tdriver->init_termios.c_lflag = ISIG | ECHO;\n\ttty_set_operations(driver, &sclp_ops);\n\ttty_port_link_device(&sclp_port, driver, 0);\n\trc = tty_register_driver(driver);\n\tif (rc) {\n\t\ttty_driver_kref_put(driver);\n\t\ttty_port_destroy(&sclp_port);\n\t\treturn rc;\n\t}\n\tsclp_tty_driver = driver;\n\treturn 0;\n}\ndevice_initcall(sclp_tty_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}