{
  "module_name": "sclp_early_core.c",
  "hash_id": "377276d786f57ca24548e0605f0d7742ae6961a6d178ac4dfb434b77ebbdb276",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_early_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <asm/processor.h>\n#include <asm/lowcore.h>\n#include <asm/ebcdic.h>\n#include <asm/irq.h>\n#include <asm/sections.h>\n#include <asm/physmem_info.h>\n#include <asm/facility.h>\n#include \"sclp.h\"\n#include \"sclp_rw.h\"\n\nstatic struct read_info_sccb __bootdata(sclp_info_sccb);\nstatic int __bootdata(sclp_info_sccb_valid);\nchar *__bootdata_preserved(sclp_early_sccb);\nint sclp_init_state = sclp_init_state_uninitialized;\n \nbool sclp_mask_compat_mode;\n\nvoid sclp_early_wait_irq(void)\n{\n\tunsigned long psw_mask, addr;\n\tpsw_t psw_ext_save, psw_wait;\n\tunion ctlreg0 cr0, cr0_new;\n\n\t__ctl_store(cr0.val, 0, 0);\n\tcr0_new.val = cr0.val & ~CR0_IRQ_SUBCLASS_MASK;\n\tcr0_new.lap = 0;\n\tcr0_new.sssm = 1;\n\t__ctl_load(cr0_new.val, 0, 0);\n\n\tpsw_ext_save = S390_lowcore.external_new_psw;\n\tpsw_mask = __extract_psw();\n\tS390_lowcore.external_new_psw.mask = psw_mask;\n\tpsw_wait.mask = psw_mask | PSW_MASK_EXT | PSW_MASK_WAIT;\n\tS390_lowcore.ext_int_code = 0;\n\n\tdo {\n\t\tasm volatile(\n\t\t\t\"\tlarl\t%[addr],0f\\n\"\n\t\t\t\"\tstg\t%[addr],%[psw_wait_addr]\\n\"\n\t\t\t\"\tstg\t%[addr],%[psw_ext_addr]\\n\"\n\t\t\t\"\tlpswe\t%[psw_wait]\\n\"\n\t\t\t\"0:\\n\"\n\t\t\t: [addr] \"=&d\" (addr),\n\t\t\t  [psw_wait_addr] \"=Q\" (psw_wait.addr),\n\t\t\t  [psw_ext_addr] \"=Q\" (S390_lowcore.external_new_psw.addr)\n\t\t\t: [psw_wait] \"Q\" (psw_wait)\n\t\t\t: \"cc\", \"memory\");\n\t} while (S390_lowcore.ext_int_code != EXT_IRQ_SERVICE_SIG);\n\n\tS390_lowcore.external_new_psw = psw_ext_save;\n\t__ctl_load(cr0.val, 0, 0);\n}\n\nint sclp_early_cmd(sclp_cmdw_t cmd, void *sccb)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tflags = arch_local_irq_save();\n\trc = sclp_service_call(cmd, sccb);\n\tif (rc)\n\t\tgoto out;\n\tsclp_early_wait_irq();\nout:\n\tarch_local_irq_restore(flags);\n\treturn rc;\n}\n\nstruct write_sccb {\n\tstruct sccb_header header;\n\tstruct msg_buf msg;\n} __packed;\n\n \nstatic void sclp_early_print_lm(const char *str, unsigned int len)\n{\n\tunsigned char *ptr, *end, ch;\n\tunsigned int count, offset;\n\tstruct write_sccb *sccb;\n\tstruct msg_buf *msg;\n\tstruct mdb *mdb;\n\tstruct mto *mto;\n\tstruct go *go;\n\n\tsccb = (struct write_sccb *) sclp_early_sccb;\n\tend = (unsigned char *) sccb + EARLY_SCCB_SIZE - 1;\n\tmemset(sccb, 0, sizeof(*sccb));\n\tptr = (unsigned char *) &sccb->msg.mdb.mto;\n\toffset = 0;\n\tdo {\n\t\tfor (count = sizeof(*mto); offset < len; count++) {\n\t\t\tch = str[offset++];\n\t\t\tif ((ch == 0x0a) || (ptr + count > end))\n\t\t\t\tbreak;\n\t\t\tptr[count] = _ascebc[ch];\n\t\t}\n\t\tmto = (struct mto *) ptr;\n\t\tmemset(mto, 0, sizeof(*mto));\n\t\tmto->length = count;\n\t\tmto->type = 4;\n\t\tmto->line_type_flags = LNTPFLGS_ENDTEXT;\n\t\tptr += count;\n\t} while ((offset < len) && (ptr + sizeof(*mto) <= end));\n\tlen = ptr - (unsigned char *) sccb;\n\tsccb->header.length = len - offsetof(struct write_sccb, header);\n\tmsg = &sccb->msg;\n\tmsg->header.type = EVTYP_MSG;\n\tmsg->header.length = len - offsetof(struct write_sccb, msg.header);\n\tmdb = &msg->mdb;\n\tmdb->header.type = 1;\n\tmdb->header.tag = 0xD4C4C240;\n\tmdb->header.revision_code = 1;\n\tmdb->header.length = len - offsetof(struct write_sccb, msg.mdb.header);\n\tgo = &mdb->go;\n\tgo->length = sizeof(*go);\n\tgo->type = 1;\n\tsclp_early_cmd(SCLP_CMDW_WRITE_EVENT_DATA, sccb);\n}\n\nstruct vt220_sccb {\n\tstruct sccb_header header;\n\tstruct {\n\t\tstruct evbuf_header header;\n\t\tchar data[];\n\t} msg;\n} __packed;\n\n \nstatic void sclp_early_print_vt220(const char *str, unsigned int len)\n{\n\tstruct vt220_sccb *sccb;\n\n\tsccb = (struct vt220_sccb *) sclp_early_sccb;\n\tif (sizeof(*sccb) + len >= EARLY_SCCB_SIZE)\n\t\tlen = EARLY_SCCB_SIZE - sizeof(*sccb);\n\tmemset(sccb, 0, sizeof(*sccb));\n\tmemcpy(&sccb->msg.data, str, len);\n\tsccb->header.length = sizeof(*sccb) + len;\n\tsccb->msg.header.length = sizeof(sccb->msg) + len;\n\tsccb->msg.header.type = EVTYP_VT220MSG;\n\tsclp_early_cmd(SCLP_CMDW_WRITE_EVENT_DATA, sccb);\n}\n\nint sclp_early_set_event_mask(struct init_sccb *sccb,\n\t\t\t      sccb_mask_t receive_mask,\n\t\t\t      sccb_mask_t send_mask)\n{\nretry:\n\tmemset(sccb, 0, sizeof(*sccb));\n\tsccb->header.length = sizeof(*sccb);\n\tif (sclp_mask_compat_mode)\n\t\tsccb->mask_length = SCLP_MASK_SIZE_COMPAT;\n\telse\n\t\tsccb->mask_length = sizeof(sccb_mask_t);\n\tsccb_set_recv_mask(sccb, receive_mask);\n\tsccb_set_send_mask(sccb, send_mask);\n\tif (sclp_early_cmd(SCLP_CMDW_WRITE_EVENT_MASK, sccb))\n\t\treturn -EIO;\n\tif ((sccb->header.response_code == 0x74f0) && !sclp_mask_compat_mode) {\n\t\tsclp_mask_compat_mode = true;\n\t\tgoto retry;\n\t}\n\tif (sccb->header.response_code != 0x20)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nunsigned int sclp_early_con_check_linemode(struct init_sccb *sccb)\n{\n\tif (!(sccb_get_sclp_send_mask(sccb) & EVTYP_OPCMD_MASK))\n\t\treturn 0;\n\tif (!(sccb_get_sclp_recv_mask(sccb) & (EVTYP_MSG_MASK | EVTYP_PMSGCMD_MASK)))\n\t\treturn 0;\n\treturn 1;\n}\n\nunsigned int sclp_early_con_check_vt220(struct init_sccb *sccb)\n{\n\tif (sccb_get_sclp_send_mask(sccb) & EVTYP_VT220MSG_MASK)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int sclp_early_setup(int disable, int *have_linemode, int *have_vt220)\n{\n\tunsigned long receive_mask, send_mask;\n\tstruct init_sccb *sccb;\n\tint rc;\n\n\tBUILD_BUG_ON(sizeof(struct init_sccb) > PAGE_SIZE);\n\n\t*have_linemode = *have_vt220 = 0;\n\tsccb = (struct init_sccb *) sclp_early_sccb;\n\treceive_mask = disable ? 0 : EVTYP_OPCMD_MASK;\n\tsend_mask = disable ? 0 : EVTYP_VT220MSG_MASK | EVTYP_MSG_MASK;\n\trc = sclp_early_set_event_mask(sccb, receive_mask, send_mask);\n\tif (rc)\n\t\treturn rc;\n\t*have_linemode = sclp_early_con_check_linemode(sccb);\n\t*have_vt220 = !!(sccb_get_send_mask(sccb) & EVTYP_VT220MSG_MASK);\n\treturn rc;\n}\n\nvoid sclp_early_set_buffer(void *sccb)\n{\n\tsclp_early_sccb = sccb;\n}\n\n \nvoid __sclp_early_printk(const char *str, unsigned int len)\n{\n\tint have_linemode, have_vt220;\n\n\tif (sclp_init_state != sclp_init_state_uninitialized)\n\t\treturn;\n\tif (sclp_early_setup(0, &have_linemode, &have_vt220) != 0)\n\t\treturn;\n\tif (have_linemode)\n\t\tsclp_early_print_lm(str, len);\n\tif (have_vt220)\n\t\tsclp_early_print_vt220(str, len);\n\tsclp_early_setup(1, &have_linemode, &have_vt220);\n}\n\nvoid sclp_early_printk(const char *str)\n{\n\t__sclp_early_printk(str, strlen(str));\n}\n\n \nvoid sclp_emergency_printk(const char *str)\n{\n\tint have_linemode, have_vt220;\n\tunsigned int len;\n\n\tlen = strlen(str);\n\t \n\tsclp_early_setup(0, &have_linemode, &have_vt220);\n\tsclp_early_print_lm(str, len);\n\tsclp_early_print_vt220(str, len);\n\tsclp_early_setup(1, &have_linemode, &have_vt220);\n}\n\n \nint __init sclp_early_read_info(void)\n{\n\tint i;\n\tint length = test_facility(140) ? EXT_SCCB_READ_SCP : PAGE_SIZE;\n\tstruct read_info_sccb *sccb = (struct read_info_sccb *)sclp_early_sccb;\n\tsclp_cmdw_t commands[] = {SCLP_CMDW_READ_SCP_INFO_FORCED,\n\t\t\t\t  SCLP_CMDW_READ_SCP_INFO};\n\n\tfor (i = 0; i < ARRAY_SIZE(commands); i++) {\n\t\tmemset(sccb, 0, length);\n\t\tsccb->header.length = length;\n\t\tsccb->header.function_code = 0x80;\n\t\tsccb->header.control_mask[2] = 0x80;\n\t\tif (sclp_early_cmd(commands[i], sccb))\n\t\t\tbreak;\n\t\tif (sccb->header.response_code == 0x10) {\n\t\t\tmemcpy(&sclp_info_sccb, sccb, length);\n\t\t\tsclp_info_sccb_valid = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (sccb->header.response_code != 0x1f0)\n\t\t\tbreak;\n\t}\n\treturn -EIO;\n}\n\nstruct read_info_sccb * __init sclp_early_get_info(void)\n{\n\tif (!sclp_info_sccb_valid)\n\t\treturn NULL;\n\n\treturn &sclp_info_sccb;\n}\n\nint __init sclp_early_get_memsize(unsigned long *mem)\n{\n\tunsigned long rnmax;\n\tunsigned long rnsize;\n\tstruct read_info_sccb *sccb = &sclp_info_sccb;\n\n\tif (!sclp_info_sccb_valid)\n\t\treturn -EIO;\n\n\trnmax = sccb->rnmax ? sccb->rnmax : sccb->rnmax2;\n\trnsize = sccb->rnsize ? sccb->rnsize : sccb->rnsize2;\n\trnsize <<= 20;\n\t*mem = rnsize * rnmax;\n\treturn 0;\n}\n\nint __init sclp_early_get_hsa_size(unsigned long *hsa_size)\n{\n\tif (!sclp_info_sccb_valid)\n\t\treturn -EIO;\n\n\t*hsa_size = 0;\n\tif (sclp_info_sccb.hsa_size)\n\t\t*hsa_size = (sclp_info_sccb.hsa_size - 1) * PAGE_SIZE;\n\treturn 0;\n}\n\n#define SCLP_STORAGE_INFO_FACILITY     0x0000400000000000UL\n\nvoid __weak __init add_physmem_online_range(u64 start, u64 end) {}\nint __init sclp_early_read_storage_info(void)\n{\n\tstruct read_storage_sccb *sccb = (struct read_storage_sccb *)sclp_early_sccb;\n\tint rc, id, max_id = 0;\n\tunsigned long rn, rzm;\n\tsclp_cmdw_t command;\n\tu16 sn;\n\n\tif (!sclp_info_sccb_valid)\n\t\treturn -EIO;\n\n\tif (!(sclp_info_sccb.facilities & SCLP_STORAGE_INFO_FACILITY))\n\t\treturn -EOPNOTSUPP;\n\n\trzm = sclp_info_sccb.rnsize ?: sclp_info_sccb.rnsize2;\n\trzm <<= 20;\n\n\tfor (id = 0; id <= max_id; id++) {\n\t\tmemset(sclp_early_sccb, 0, EARLY_SCCB_SIZE);\n\t\tsccb->header.length = EARLY_SCCB_SIZE;\n\t\tcommand = SCLP_CMDW_READ_STORAGE_INFO | (id << 8);\n\t\trc = sclp_early_cmd(command, sccb);\n\t\tif (rc)\n\t\t\tgoto fail;\n\n\t\tmax_id = sccb->max_id;\n\t\tswitch (sccb->header.response_code) {\n\t\tcase 0x0010:\n\t\t\tfor (sn = 0; sn < sccb->assigned; sn++) {\n\t\t\t\tif (!sccb->entries[sn])\n\t\t\t\t\tcontinue;\n\t\t\t\trn = sccb->entries[sn] >> 16;\n\t\t\t\tadd_physmem_online_range((rn - 1) * rzm, rn * rzm);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0310:\n\t\tcase 0x0410:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\nfail:\n\tphysmem_info.range_count = 0;\n\treturn -EIO;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}