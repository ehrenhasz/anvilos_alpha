{
  "module_name": "hmcdrv_dev.c",
  "hash_id": "20b77823d0e1c3d9abd5eff6ef7e371f8fc18a3fa5eee115cbdb4831bfae4273",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/hmcdrv_dev.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"hmcdrv\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/capability.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n\n#include \"hmcdrv_dev.h\"\n#include \"hmcdrv_ftp.h\"\n\n \n\n#define HMCDRV_DEV_NAME  \"hmcdrv\"\n#define HMCDRV_DEV_BUSY_DELAY\t 500  \n#define HMCDRV_DEV_BUSY_RETRIES  3    \n\nstruct hmcdrv_dev_node {\n\n#ifdef HMCDRV_DEV_CLASS\n\tstruct cdev dev;  \n\tumode_t mode;\t  \n#else\n\tstruct miscdevice dev;  \n#endif\n\n};\n\nstatic int hmcdrv_dev_open(struct inode *inode, struct file *fp);\nstatic int hmcdrv_dev_release(struct inode *inode, struct file *fp);\nstatic loff_t hmcdrv_dev_seek(struct file *fp, loff_t pos, int whence);\nstatic ssize_t hmcdrv_dev_read(struct file *fp, char __user *ubuf,\n\t\t\t       size_t len, loff_t *pos);\nstatic ssize_t hmcdrv_dev_write(struct file *fp, const char __user *ubuf,\n\t\t\t\tsize_t len, loff_t *pos);\nstatic ssize_t hmcdrv_dev_transfer(char __kernel *cmd, loff_t offset,\n\t\t\t\t   char __user *buf, size_t len);\n\n \nstatic const struct file_operations hmcdrv_dev_fops = {\n\t.open = hmcdrv_dev_open,\n\t.llseek = hmcdrv_dev_seek,\n\t.release = hmcdrv_dev_release,\n\t.read = hmcdrv_dev_read,\n\t.write = hmcdrv_dev_write,\n};\n\nstatic struct hmcdrv_dev_node hmcdrv_dev;  \n\n#ifdef HMCDRV_DEV_CLASS\n\nstatic struct class *hmcdrv_dev_class;  \nstatic dev_t hmcdrv_dev_no;  \n\n \nstatic char *hmcdrv_dev_name(const struct device *dev, umode_t *mode)\n{\n\tchar *nodename = NULL;\n\tconst char *devname = dev_name(dev);  \n\n\tif (devname)\n\t\tnodename = kasprintf(GFP_KERNEL, \"%s\", devname);\n\n\t \n\tif (mode)\n\t\t*mode = hmcdrv_dev.mode;\n\n\treturn nodename;\n}\n\n#endif\t \n\n \nstatic int hmcdrv_dev_open(struct inode *inode, struct file *fp)\n{\n\tint rc;\n\n\t \n\tif (fp->f_flags & O_NONBLOCK)\n\t\treturn -EINVAL;\n\n\t \n\tif ((fp->f_flags & O_ACCMODE) == O_RDONLY)\n\t\treturn -EINVAL;\n\n\t \n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -ENODEV;\n\n\tfp->private_data = NULL;  \n\trc = hmcdrv_ftp_startup();\n\tif (rc)\n\t\tmodule_put(THIS_MODULE);\n\n\tpr_debug(\"open file '/dev/%pD' with return code %d\\n\", fp, rc);\n\treturn rc;\n}\n\n \nstatic int hmcdrv_dev_release(struct inode *inode, struct file *fp)\n{\n\tpr_debug(\"closing file '/dev/%pD'\\n\", fp);\n\tkfree(fp->private_data);\n\tfp->private_data = NULL;\n\thmcdrv_ftp_shutdown();\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}\n\n \nstatic loff_t hmcdrv_dev_seek(struct file *fp, loff_t pos, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_CUR:  \n\t\tpos += fp->f_pos;  \n\t\tbreak;\n\n\tcase SEEK_SET:  \n\t\tbreak;  \n\n\t\t \n\tcase SEEK_END:\n\t\tif (fp->private_data) {\n\t\t\tkfree(fp->private_data);\n\t\t\tfp->private_data = NULL;\n\t\t}\n\n\t\tbreak;  \n\n\tdefault:  \n\t\treturn -EINVAL;\n\t}\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tif (fp->f_pos != pos)\n\t\t++fp->f_version;\n\n\tfp->f_pos = pos;\n\treturn pos;\n}\n\n \nstatic ssize_t hmcdrv_dev_transfer(char __kernel *cmd, loff_t offset,\n\t\t\t\t   char __user *buf, size_t len)\n{\n\tssize_t retlen;\n\tunsigned trials = HMCDRV_DEV_BUSY_RETRIES;\n\n\tdo {\n\t\tretlen = hmcdrv_ftp_cmd(cmd, offset, buf, len);\n\n\t\tif (retlen != -EBUSY)\n\t\t\tbreak;\n\n\t\tmsleep(HMCDRV_DEV_BUSY_DELAY);\n\n\t} while (--trials > 0);\n\n\treturn retlen;\n}\n\n \nstatic ssize_t hmcdrv_dev_read(struct file *fp, char __user *ubuf,\n\t\t\t       size_t len, loff_t *pos)\n{\n\tssize_t retlen;\n\n\tif (((fp->f_flags & O_ACCMODE) == O_WRONLY) ||\n\t    (fp->private_data == NULL)) {  \n\t\treturn -EBADF;\n\t}\n\n\tretlen = hmcdrv_dev_transfer((char *) fp->private_data,\n\t\t\t\t     *pos, ubuf, len);\n\n\tpr_debug(\"read from file '/dev/%pD' at %lld returns %zd/%zu\\n\",\n\t\t fp, (long long) *pos, retlen, len);\n\n\tif (retlen > 0)\n\t\t*pos += retlen;\n\n\treturn retlen;\n}\n\n \nstatic ssize_t hmcdrv_dev_write(struct file *fp, const char __user *ubuf,\n\t\t\t\tsize_t len, loff_t *pos)\n{\n\tssize_t retlen;\n\n\tpr_debug(\"writing file '/dev/%pD' at pos. %lld with length %zd\\n\",\n\t\t fp, (long long) *pos, len);\n\n\tif (!fp->private_data) {  \n\t\tfp->private_data = kmalloc(len + 1, GFP_KERNEL);\n\n\t\tif (!fp->private_data)\n\t\t\treturn -ENOMEM;\n\n\t\tif (!copy_from_user(fp->private_data, ubuf, len)) {\n\t\t\t((char *)fp->private_data)[len] = '\\0';\n\t\t\treturn len;\n\t\t}\n\n\t\tkfree(fp->private_data);\n\t\tfp->private_data = NULL;\n\t\treturn -EFAULT;\n\t}\n\n\tretlen = hmcdrv_dev_transfer((char *) fp->private_data,\n\t\t\t\t     *pos, (char __user *) ubuf, len);\n\tif (retlen > 0)\n\t\t*pos += retlen;\n\n\tpr_debug(\"write to file '/dev/%pD' returned %zd\\n\", fp, retlen);\n\n\treturn retlen;\n}\n\n \nint hmcdrv_dev_init(void)\n{\n\tint rc;\n\n#ifdef HMCDRV_DEV_CLASS\n\tstruct device *dev;\n\n\trc = alloc_chrdev_region(&hmcdrv_dev_no, 0, 1, HMCDRV_DEV_NAME);\n\n\tif (rc)\n\t\tgoto out_err;\n\n\tcdev_init(&hmcdrv_dev.dev, &hmcdrv_dev_fops);\n\thmcdrv_dev.dev.owner = THIS_MODULE;\n\trc = cdev_add(&hmcdrv_dev.dev, hmcdrv_dev_no, 1);\n\n\tif (rc)\n\t\tgoto out_unreg;\n\n\t \n\thmcdrv_dev_class = class_create(HMCDRV_DEV_CLASS);\n\n\tif (IS_ERR(hmcdrv_dev_class)) {\n\t\trc = PTR_ERR(hmcdrv_dev_class);\n\t\tgoto out_devdel;\n\t}\n\n\t \n\thmcdrv_dev.mode = 0;  \n\thmcdrv_dev_class->devnode = hmcdrv_dev_name;\n\n\tdev = device_create(hmcdrv_dev_class, NULL, hmcdrv_dev_no, NULL,\n\t\t\t    \"%s\", HMCDRV_DEV_NAME);\n\tif (!IS_ERR(dev))\n\t\treturn 0;\n\n\trc = PTR_ERR(dev);\n\tclass_destroy(hmcdrv_dev_class);\n\thmcdrv_dev_class = NULL;\n\nout_devdel:\n\tcdev_del(&hmcdrv_dev.dev);\n\nout_unreg:\n\tunregister_chrdev_region(hmcdrv_dev_no, 1);\n\nout_err:\n\n#else   \n\thmcdrv_dev.dev.minor = MISC_DYNAMIC_MINOR;\n\thmcdrv_dev.dev.name = HMCDRV_DEV_NAME;\n\thmcdrv_dev.dev.fops = &hmcdrv_dev_fops;\n\thmcdrv_dev.dev.mode = 0;  \n\trc = misc_register(&hmcdrv_dev.dev);\n#endif\t \n\n\treturn rc;\n}\n\n \nvoid hmcdrv_dev_exit(void)\n{\n#ifdef HMCDRV_DEV_CLASS\n\tif (!IS_ERR_OR_NULL(hmcdrv_dev_class)) {\n\t\tdevice_destroy(hmcdrv_dev_class, hmcdrv_dev_no);\n\t\tclass_destroy(hmcdrv_dev_class);\n\t}\n\n\tcdev_del(&hmcdrv_dev.dev);\n\tunregister_chrdev_region(hmcdrv_dev_no, 1);\n#else   \n\tmisc_deregister(&hmcdrv_dev.dev);\n#endif\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}