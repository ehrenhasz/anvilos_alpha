{
  "module_name": "con3270.c",
  "hash_id": "0ecc89efedd2fd73f8aa892af0a797501b7b0106971e8bdc946af5ccf4281475",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/con3270.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kdev_t.h>\n#include <linux/tty.h>\n#include <linux/vt_kern.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/panic_notifier.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/compat.h>\n\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n#include <asm/ebcdic.h>\n#include <asm/cpcmd.h>\n#include <linux/uaccess.h>\n\n#include \"raw3270.h\"\n#include \"keyboard.h\"\n\n#define TTY3270_CHAR_BUF_SIZE 256\n#define TTY3270_OUTPUT_BUFFER_SIZE 4096\n#define TTY3270_SCREEN_PAGES 8  \n#define TTY3270_RECALL_SIZE 16  \n#define TTY3270_STATUS_AREA_SIZE 40\n\nstatic struct tty_driver *tty3270_driver;\nstatic int tty3270_max_index;\nstatic struct raw3270_fn tty3270_fn;\n\n#define TTY3270_HIGHLIGHT_BLINK\t\t1\n#define TTY3270_HIGHLIGHT_REVERSE\t2\n#define TTY3270_HIGHLIGHT_UNDERSCORE\t4\n\nstruct tty3270_attribute {\n\tunsigned char alternate_charset:1;\t \n\tunsigned char highlight:3;\t\t \n\tunsigned char f_color:4;\t\t \n\tunsigned char b_color:4;\t\t \n};\n\nstruct tty3270_cell {\n\tunsigned char character;\n\tstruct tty3270_attribute attributes;\n};\n\nstruct tty3270_line {\n\tstruct tty3270_cell *cells;\n\tint len;\n\tint dirty;\n};\n\nstatic const unsigned char sfq_read_partition[] = {\n\t0x00, 0x07, 0x01, 0xff, 0x03, 0x00, 0x81\n};\n\n#define ESCAPE_NPAR 8\n\n \nstruct tty3270 {\n\tstruct raw3270_view view;\n\tstruct tty_port port;\n\n\t \n\tunsigned char wcc;\t\t \n\tint nr_up;\t\t\t \n\tunsigned long update_flags;\t \n\tstruct raw3270_request *write;\t \n\tstruct timer_list timer;\t \n\tchar *converted_line;\t\t \n\tunsigned int line_view_start;\t \n\tunsigned int line_write_start;\t \n\tunsigned int oops_line;\t\t \n\n\t \n\tunsigned int cx, cy;\t\t \n\tstruct tty3270_attribute attributes;\n\tstruct tty3270_attribute saved_attributes;\n\tint allocated_lines;\n\tstruct tty3270_line *screen;\n\n\t \n\tchar *prompt;\t\t\t \n\tchar *input;\t\t\t \n\tstruct raw3270_request *read;\t \n\tstruct raw3270_request *kreset;\t \n\tstruct raw3270_request *readpartreq;\n\tunsigned char inattr;\t\t \n\tint throttle, attn;\t\t \n\tstruct tasklet_struct readlet;\t \n\tstruct tasklet_struct hanglet;\t \n\tstruct kbd_data *kbd;\t\t \n\n\t \n\tint esc_state, esc_ques, esc_npar;\n\tint esc_par[ESCAPE_NPAR];\n\tunsigned int saved_cx, saved_cy;\n\n\t \n\tchar **rcl_lines;\t\t \n\tint rcl_write_index;\t\t \n\tint rcl_read_index;\t\t \n\n\t \n\tunsigned int char_count;\n\tchar char_buf[TTY3270_CHAR_BUF_SIZE];\n};\n\n \n#define TTY_UPDATE_INPUT\t0x1\t \n#define TTY_UPDATE_STATUS\t0x2\t \n#define TTY_UPDATE_LINES\t0x4\t \n#define TTY_UPDATE_ALL\t\t0x7\t \n\n#define TTY3270_INPUT_AREA_ROWS 2\n\n \nstatic void tty3270_set_timer(struct tty3270 *tp, int expires)\n{\n\tmod_timer(&tp->timer, jiffies + expires);\n}\n\nstatic int tty3270_tty_rows(struct tty3270 *tp)\n{\n\treturn tp->view.rows - TTY3270_INPUT_AREA_ROWS;\n}\n\nstatic char *tty3270_add_ba(struct tty3270 *tp, char *cp, char order, int x, int y)\n{\n\t*cp++ = order;\n\traw3270_buffer_address(tp->view.dev, cp, x, y);\n\treturn cp + 2;\n}\n\nstatic char *tty3270_add_ra(struct tty3270 *tp, char *cp, int x, int y, char c)\n{\n\tcp = tty3270_add_ba(tp, cp, TO_RA, x, y);\n\t*cp++ = c;\n\treturn cp;\n}\n\nstatic char *tty3270_add_sa(struct tty3270 *tp, char *cp, char attr, char value)\n{\n\t*cp++ = TO_SA;\n\t*cp++ = attr;\n\t*cp++ = value;\n\treturn cp;\n}\n\nstatic char *tty3270_add_ge(struct tty3270 *tp, char *cp, char c)\n{\n\t*cp++ = TO_GE;\n\t*cp++ = c;\n\treturn cp;\n}\n\nstatic char *tty3270_add_sf(struct tty3270 *tp, char *cp, char type)\n{\n\t*cp++ = TO_SF;\n\t*cp++ = type;\n\treturn cp;\n}\n\nstatic int tty3270_line_increment(struct tty3270 *tp, unsigned int line, unsigned int incr)\n{\n\treturn (line + incr) & (tp->allocated_lines - 1);\n}\n\nstatic struct tty3270_line *tty3270_get_write_line(struct tty3270 *tp, unsigned int num)\n{\n\treturn tp->screen + tty3270_line_increment(tp, tp->line_write_start, num);\n}\n\nstatic struct tty3270_line *tty3270_get_view_line(struct tty3270 *tp, unsigned int num)\n{\n\treturn tp->screen + tty3270_line_increment(tp, tp->line_view_start, num - tp->nr_up);\n}\n\nstatic int tty3270_input_size(int cols)\n{\n\treturn cols * 2 - 11;\n}\n\nstatic void tty3270_update_prompt(struct tty3270 *tp, char *input)\n{\n\tstrcpy(tp->prompt, input);\n\ttp->update_flags |= TTY_UPDATE_INPUT;\n\ttty3270_set_timer(tp, 1);\n}\n\n \nstatic int tty3270_add_prompt(struct tty3270 *tp)\n{\n\tint count = 0;\n\tchar *cp;\n\n\tcp = tp->converted_line;\n\tcp = tty3270_add_ba(tp, cp, TO_SBA, 0, -2);\n\t*cp++ = tp->view.ascebc['>'];\n\n\tif (*tp->prompt) {\n\t\tcp = tty3270_add_sf(tp, cp, TF_INMDT);\n\t\tcount = min_t(int, strlen(tp->prompt),\n\t\t\t      tp->view.cols * 2 - TTY3270_STATUS_AREA_SIZE - 2);\n\t\tmemcpy(cp, tp->prompt, count);\n\t\tcp += count;\n\t} else {\n\t\tcp = tty3270_add_sf(tp, cp, tp->inattr);\n\t}\n\t*cp++ = TO_IC;\n\t \n\tif (count < tp->view.cols * 2 - 11)\n\t\tcp = tty3270_add_ra(tp, cp, -TTY3270_STATUS_AREA_SIZE, -1, 0);\n\treturn cp - tp->converted_line;\n}\n\nstatic char *tty3270_ebcdic_convert(struct tty3270 *tp, char *d, char *s)\n{\n\twhile (*s)\n\t\t*d++ = tp->view.ascebc[(int)*s++];\n\treturn d;\n}\n\n \nstatic int tty3270_add_status(struct tty3270 *tp)\n{\n\tchar *cp = tp->converted_line;\n\tint len;\n\n\tcp = tty3270_add_ba(tp, cp, TO_SBA, -TTY3270_STATUS_AREA_SIZE, -1);\n\tcp = tty3270_add_sf(tp, cp, TF_LOG);\n\tcp = tty3270_add_sa(tp, cp, TAT_FGCOLOR, TAC_GREEN);\n\tcp = tty3270_ebcdic_convert(tp, cp, \" 7\");\n\tcp = tty3270_add_sa(tp, cp, TAT_EXTHI, TAX_REVER);\n\tcp = tty3270_ebcdic_convert(tp, cp, \"PrevPg\");\n\tcp = tty3270_add_sa(tp, cp, TAT_EXTHI, TAX_RESET);\n\tcp = tty3270_ebcdic_convert(tp, cp, \" 8\");\n\tcp = tty3270_add_sa(tp, cp, TAT_EXTHI, TAX_REVER);\n\tcp = tty3270_ebcdic_convert(tp, cp, \"NextPg\");\n\tcp = tty3270_add_sa(tp, cp, TAT_EXTHI, TAX_RESET);\n\tcp = tty3270_ebcdic_convert(tp, cp, \" 12\");\n\tcp = tty3270_add_sa(tp, cp, TAT_EXTHI, TAX_REVER);\n\tcp = tty3270_ebcdic_convert(tp, cp, \"Recall\");\n\tcp = tty3270_add_sa(tp, cp, TAT_EXTHI, TAX_RESET);\n\tcp = tty3270_ebcdic_convert(tp, cp, \"  \");\n\tif (tp->nr_up) {\n\t\tlen = sprintf(cp, \"History %d\", -tp->nr_up);\n\t\tcodepage_convert(tp->view.ascebc, cp, len);\n\t\tcp += len;\n\t} else {\n\t\tcp = tty3270_ebcdic_convert(tp, cp, oops_in_progress ? \"Crashed\" : \"Running\");\n\t}\n\tcp = tty3270_add_sf(tp, cp, TF_LOG);\n\tcp = tty3270_add_sa(tp, cp, TAT_FGCOLOR, TAC_RESET);\n\treturn cp - (char *)tp->converted_line;\n}\n\nstatic void tty3270_blank_screen(struct tty3270 *tp)\n{\n\tstruct tty3270_line *line;\n\tint i;\n\n\tfor (i = 0; i < tty3270_tty_rows(tp); i++) {\n\t\tline = tty3270_get_write_line(tp, i);\n\t\tline->len = 0;\n\t\tline->dirty = 1;\n\t}\n\ttp->nr_up = 0;\n}\n\n \nstatic void tty3270_write_callback(struct raw3270_request *rq, void *data)\n{\n\tstruct tty3270 *tp = container_of(rq->view, struct tty3270, view);\n\n\tif (rq->rc != 0) {\n\t\t \n\t\ttp->update_flags = TTY_UPDATE_ALL;\n\t\ttty3270_set_timer(tp, 1);\n\t}\n\traw3270_request_reset(rq);\n\txchg(&tp->write, rq);\n}\n\nstatic int tty3270_required_length(struct tty3270 *tp, struct tty3270_line *line)\n{\n\tunsigned char f_color, b_color, highlight;\n\tstruct tty3270_cell *cell;\n\tint i, flen = 3;\t\t \n\n\tflen += line->len;\n\thighlight = 0;\n\tf_color = TAC_RESET;\n\tb_color = TAC_RESET;\n\n\tfor (i = 0, cell = line->cells; i < line->len; i++, cell++) {\n\t\tif (cell->attributes.highlight != highlight) {\n\t\t\tflen += 3;\t \n\t\t\thighlight = cell->attributes.highlight;\n\t\t}\n\t\tif (cell->attributes.f_color != f_color) {\n\t\t\tflen += 3;\t \n\t\t\tf_color = cell->attributes.f_color;\n\t\t}\n\t\tif (cell->attributes.b_color != b_color) {\n\t\t\tflen += 3;\t \n\t\t\tb_color = cell->attributes.b_color;\n\t\t}\n\t\tif (cell->attributes.alternate_charset)\n\t\t\tflen += 1;\t \n\t}\n\tif (highlight)\n\t\tflen += 3;\t \n\tif (f_color != TAC_RESET)\n\t\tflen += 3;\t \n\tif (b_color != TAC_RESET)\n\t\tflen += 3;\t \n\tif (line->len < tp->view.cols)\n\t\tflen += 4;\t \n\n\treturn flen;\n}\n\nstatic char *tty3270_add_reset_attributes(struct tty3270 *tp, struct tty3270_line *line,\n\t\t\t\t\t  char *cp, struct tty3270_attribute *attr, int lineno)\n{\n\tif (attr->highlight)\n\t\tcp = tty3270_add_sa(tp, cp, TAT_EXTHI, TAX_RESET);\n\tif (attr->f_color != TAC_RESET)\n\t\tcp = tty3270_add_sa(tp, cp, TAT_FGCOLOR, TAX_RESET);\n\tif (attr->b_color != TAC_RESET)\n\t\tcp = tty3270_add_sa(tp, cp, TAT_BGCOLOR, TAX_RESET);\n\tif (line->len < tp->view.cols)\n\t\tcp = tty3270_add_ra(tp, cp, 0, lineno + 1, 0);\n\treturn cp;\n}\n\nstatic char tty3270_graphics_translate(struct tty3270 *tp, char ch)\n{\n\tswitch (ch) {\n\tcase 'q':  \n\t\treturn 0xa2;\n\tcase 'x':  \n\t\treturn 0x85;\n\tcase 'l':  \n\t\treturn 0xc5;\n\tcase 't':  \n\t\treturn 0xc6;\n\tcase 'u':  \n\t\treturn 0xd6;\n\tcase 'k':  \n\t\treturn 0xd5;\n\tcase 'j':\n\t\treturn 0xd4;\n\tcase 'm':\n\t\treturn 0xc4;\n\tcase 'n':  \n\t\treturn 0xd3;\n\tcase 'v':\n\t\treturn 0xc7;\n\tcase 'w':\n\t\treturn 0xd7;\n\tdefault:\n\t\treturn ch;\n\t}\n}\n\nstatic char *tty3270_add_attributes(struct tty3270 *tp, struct tty3270_line *line,\n\t\t\t\t    struct tty3270_attribute *attr, char *cp, int lineno)\n{\n\tconst unsigned char colors[16] = {\n\t\t[0] = TAC_DEFAULT,\n\t\t[1] = TAC_RED,\n\t\t[2] = TAC_GREEN,\n\t\t[3] = TAC_YELLOW,\n\t\t[4] = TAC_BLUE,\n\t\t[5] = TAC_PINK,\n\t\t[6] = TAC_TURQ,\n\t\t[7] = TAC_WHITE,\n\t\t[9] = TAC_DEFAULT\n\t};\n\n\tconst unsigned char highlights[8] = {\n\t\t[TTY3270_HIGHLIGHT_BLINK] = TAX_BLINK,\n\t\t[TTY3270_HIGHLIGHT_REVERSE] = TAX_REVER,\n\t\t[TTY3270_HIGHLIGHT_UNDERSCORE] = TAX_UNDER,\n\t};\n\n\tstruct tty3270_cell *cell;\n\tint c, i;\n\n\tcp = tty3270_add_ba(tp, cp, TO_SBA, 0, lineno);\n\n\tfor (i = 0, cell = line->cells; i < line->len; i++, cell++) {\n\t\tif (cell->attributes.highlight != attr->highlight) {\n\t\t\tattr->highlight = cell->attributes.highlight;\n\t\t\tcp = tty3270_add_sa(tp, cp, TAT_EXTHI, highlights[attr->highlight]);\n\t\t}\n\t\tif (cell->attributes.f_color != attr->f_color) {\n\t\t\tattr->f_color = cell->attributes.f_color;\n\t\t\tcp = tty3270_add_sa(tp, cp, TAT_FGCOLOR, colors[attr->f_color]);\n\t\t}\n\t\tif (cell->attributes.b_color != attr->b_color) {\n\t\t\tattr->b_color = cell->attributes.b_color;\n\t\t\tcp = tty3270_add_sa(tp, cp, TAT_BGCOLOR, colors[attr->b_color]);\n\t\t}\n\t\tc = cell->character;\n\t\tif (cell->attributes.alternate_charset)\n\t\t\tcp = tty3270_add_ge(tp, cp, tty3270_graphics_translate(tp, c));\n\t\telse\n\t\t\t*cp++ = tp->view.ascebc[c];\n\t}\n\treturn cp;\n}\n\nstatic void tty3270_reset_attributes(struct tty3270_attribute *attr)\n{\n\tattr->highlight = TAX_RESET;\n\tattr->f_color = TAC_RESET;\n\tattr->b_color = TAC_RESET;\n}\n\n \nstatic unsigned int tty3270_convert_line(struct tty3270 *tp, struct tty3270_line *line, int lineno)\n{\n\tstruct tty3270_attribute attr;\n\tint flen;\n\tchar *cp;\n\n\t \n\tflen = tty3270_required_length(tp, line);\n\tif (flen > PAGE_SIZE)\n\t\treturn 0;\n\t \n\ttty3270_reset_attributes(&attr);\n\tcp = tty3270_add_attributes(tp, line, &attr, tp->converted_line, lineno);\n\tcp = tty3270_add_reset_attributes(tp, line, cp, &attr, lineno);\n\treturn cp - (char *)tp->converted_line;\n}\n\nstatic void tty3270_update_lines_visible(struct tty3270 *tp, struct raw3270_request *rq)\n{\n\tstruct tty3270_line *line;\n\tint len, i;\n\n\tfor (i = 0; i < tty3270_tty_rows(tp); i++) {\n\t\tline = tty3270_get_view_line(tp, i);\n\t\tif (!line->dirty)\n\t\t\tcontinue;\n\t\tlen = tty3270_convert_line(tp, line, i);\n\t\tif (raw3270_request_add_data(rq, tp->converted_line, len))\n\t\t\tbreak;\n\t\tline->dirty = 0;\n\t}\n\tif (i == tty3270_tty_rows(tp)) {\n\t\tfor (i = 0; i < tp->allocated_lines; i++)\n\t\t\ttp->screen[i].dirty = 0;\n\t\ttp->update_flags &= ~TTY_UPDATE_LINES;\n\t}\n}\n\nstatic void tty3270_update_lines_all(struct tty3270 *tp, struct raw3270_request *rq)\n{\n\tstruct tty3270_line *line;\n\tchar buf[4];\n\tint len, i;\n\n\tfor (i = 0; i < tp->allocated_lines; i++) {\n\t\tline = tty3270_get_write_line(tp, i + tp->cy + 1);\n\t\tif (!line->dirty)\n\t\t\tcontinue;\n\t\tlen = tty3270_convert_line(tp, line, tp->oops_line);\n\t\tif (raw3270_request_add_data(rq, tp->converted_line, len))\n\t\t\tbreak;\n\t\tline->dirty = 0;\n\t\tif (++tp->oops_line >= tty3270_tty_rows(tp))\n\t\t\ttp->oops_line = 0;\n\t}\n\n\tif (i == tp->allocated_lines) {\n\t\tif (tp->oops_line < tty3270_tty_rows(tp)) {\n\t\t\ttty3270_add_ra(tp, buf, 0, tty3270_tty_rows(tp), 0);\n\t\t\tif (raw3270_request_add_data(rq, buf, sizeof(buf)))\n\t\t\t\treturn;\n\t\t}\n\t\ttp->update_flags &= ~TTY_UPDATE_LINES;\n\t}\n}\n\n \nstatic void tty3270_update(struct timer_list *t)\n{\n\tstruct tty3270 *tp = from_timer(tp, t, timer);\n\tstruct raw3270_request *wrq;\n\tu8 cmd = TC_WRITE;\n\tint rc, len;\n\n\twrq = xchg(&tp->write, 0);\n\tif (!wrq) {\n\t\ttty3270_set_timer(tp, 1);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tp->view.lock);\n\tif (tp->update_flags == TTY_UPDATE_ALL)\n\t\tcmd = TC_EWRITEA;\n\n\traw3270_request_set_cmd(wrq, cmd);\n\traw3270_request_add_data(wrq, &tp->wcc, 1);\n\ttp->wcc = TW_NONE;\n\n\t \n\tif (tp->update_flags & TTY_UPDATE_STATUS) {\n\t\tlen = tty3270_add_status(tp);\n\t\tif (raw3270_request_add_data(wrq, tp->converted_line, len) == 0)\n\t\t\ttp->update_flags &= ~TTY_UPDATE_STATUS;\n\t}\n\n\t \n\tif (tp->update_flags & TTY_UPDATE_INPUT) {\n\t\tlen = tty3270_add_prompt(tp);\n\t\tif (raw3270_request_add_data(wrq, tp->converted_line, len) == 0)\n\t\t\ttp->update_flags &= ~TTY_UPDATE_INPUT;\n\t}\n\n\tif (tp->update_flags & TTY_UPDATE_LINES) {\n\t\tif (oops_in_progress)\n\t\t\ttty3270_update_lines_all(tp, wrq);\n\t\telse\n\t\t\ttty3270_update_lines_visible(tp, wrq);\n\t}\n\n\twrq->callback = tty3270_write_callback;\n\trc = raw3270_start(&tp->view, wrq);\n\tif (rc == 0) {\n\t\tif (tp->update_flags)\n\t\t\ttty3270_set_timer(tp, 1);\n\t} else {\n\t\traw3270_request_reset(wrq);\n\t\txchg(&tp->write, wrq);\n\t}\n\tspin_unlock_irq(&tp->view.lock);\n}\n\n \nstatic void tty3270_rcl_add(struct tty3270 *tp, char *input, int len)\n{\n\tchar *p;\n\n\tif (len <= 0)\n\t\treturn;\n\tp = tp->rcl_lines[tp->rcl_write_index++];\n\ttp->rcl_write_index &= TTY3270_RECALL_SIZE - 1;\n\tmemcpy(p, input, len);\n\tp[len] = '\\0';\n\ttp->rcl_read_index = tp->rcl_write_index;\n}\n\nstatic void tty3270_rcl_backward(struct kbd_data *kbd)\n{\n\tstruct tty3270 *tp = container_of(kbd->port, struct tty3270, port);\n\tint i = 0;\n\n\tspin_lock_irq(&tp->view.lock);\n\tif (tp->inattr == TF_INPUT) {\n\t\tdo {\n\t\t\ttp->rcl_read_index--;\n\t\t\ttp->rcl_read_index &= TTY3270_RECALL_SIZE - 1;\n\t\t} while (!*tp->rcl_lines[tp->rcl_read_index] &&\n\t\t\t i++ < TTY3270_RECALL_SIZE - 1);\n\t\ttty3270_update_prompt(tp, tp->rcl_lines[tp->rcl_read_index]);\n\t}\n\tspin_unlock_irq(&tp->view.lock);\n}\n\n \nstatic void tty3270_exit_tty(struct kbd_data *kbd)\n{\n\tstruct tty3270 *tp = container_of(kbd->port, struct tty3270, port);\n\n\traw3270_deactivate_view(&tp->view);\n}\n\nstatic void tty3270_redraw(struct tty3270 *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tty3270_tty_rows(tp); i++)\n\t\ttty3270_get_view_line(tp, i)->dirty = 1;\n\ttp->update_flags = TTY_UPDATE_ALL;\n\ttty3270_set_timer(tp, 1);\n}\n\n \nstatic void tty3270_scroll_forward(struct kbd_data *kbd)\n{\n\tstruct tty3270 *tp = container_of(kbd->port, struct tty3270, port);\n\n\tspin_lock_irq(&tp->view.lock);\n\n\tif (tp->nr_up >= tty3270_tty_rows(tp))\n\t\ttp->nr_up -= tty3270_tty_rows(tp) / 2;\n\telse\n\t\ttp->nr_up = 0;\n\ttty3270_redraw(tp);\n\tspin_unlock_irq(&tp->view.lock);\n}\n\n \nstatic void tty3270_scroll_backward(struct kbd_data *kbd)\n{\n\tstruct tty3270 *tp = container_of(kbd->port, struct tty3270, port);\n\n\tspin_lock_irq(&tp->view.lock);\n\ttp->nr_up += tty3270_tty_rows(tp) / 2;\n\tif (tp->nr_up > tp->allocated_lines - tty3270_tty_rows(tp))\n\t\ttp->nr_up = tp->allocated_lines - tty3270_tty_rows(tp);\n\ttty3270_redraw(tp);\n\tspin_unlock_irq(&tp->view.lock);\n}\n\n \nstatic void tty3270_read_tasklet(unsigned long data)\n{\n\tstruct raw3270_request *rrq = (struct raw3270_request *)data;\n\tstatic char kreset_data = TW_KR;\n\tstruct tty3270 *tp = container_of(rrq->view, struct tty3270, view);\n\tchar *input;\n\tint len;\n\n\tspin_lock_irq(&tp->view.lock);\n\t \n\tinput = NULL;\n\tlen = 0;\n\tswitch (tp->input[0]) {\n\tcase AID_ENTER:\n\t\t \n\t\tinput = tp->input + 6;\n\t\tlen = tty3270_input_size(tp->view.cols) - 6 - rrq->rescnt;\n\t\tif (tp->inattr != TF_INPUTN)\n\t\t\ttty3270_rcl_add(tp, input, len);\n\t\tif (tp->nr_up > 0)\n\t\t\ttp->nr_up = 0;\n\t\t \n\t\ttty3270_update_prompt(tp, \"\");\n\t\ttty3270_set_timer(tp, 1);\n\t\tbreak;\n\tcase AID_CLEAR:\n\t\t \n\t\ttp->update_flags = TTY_UPDATE_ALL;\n\t\ttty3270_set_timer(tp, 1);\n\t\tif (!list_empty(&tp->readpartreq->list))\n\t\t\tbreak;\n\t\traw3270_start_request(&tp->view, tp->readpartreq, TC_WRITESF,\n\t\t\t\t      (char *)sfq_read_partition, sizeof(sfq_read_partition));\n\t\tbreak;\n\tcase AID_READ_PARTITION:\n\t\traw3270_read_modified_cb(tp->readpartreq, tp->input);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_irq(&tp->view.lock);\n\n\t \n\traw3270_start_request(&tp->view, tp->kreset, TC_WRITE, &kreset_data, 1);\n\n\twhile (len-- > 0)\n\t\tkbd_keycode(tp->kbd, *input++);\n\t \n\tkbd_keycode(tp->kbd, 256 + tp->input[0]);\n\n\traw3270_request_reset(rrq);\n\txchg(&tp->read, rrq);\n\traw3270_put_view(&tp->view);\n}\n\n \nstatic void tty3270_read_callback(struct raw3270_request *rq, void *data)\n{\n\tstruct tty3270 *tp = container_of(rq->view, struct tty3270, view);\n\n\traw3270_get_view(rq->view);\n\t \n\ttasklet_schedule(&tp->readlet);\n}\n\n \nstatic void tty3270_issue_read(struct tty3270 *tp, int lock)\n{\n\tstruct raw3270_request *rrq;\n\tint rc;\n\n\trrq = xchg(&tp->read, 0);\n\tif (!rrq)\n\t\t \n\t\treturn;\n\trrq->callback = tty3270_read_callback;\n\trrq->callback_data = tp;\n\traw3270_request_set_cmd(rrq, TC_READMOD);\n\traw3270_request_set_data(rrq, tp->input, tty3270_input_size(tp->view.cols));\n\t \n\tif (lock)\n\t\trc = raw3270_start(&tp->view, rrq);\n\telse\n\t\trc = raw3270_start_irq(&tp->view, rrq);\n\tif (rc) {\n\t\traw3270_request_reset(rrq);\n\t\txchg(&tp->read, rrq);\n\t}\n}\n\n \nstatic void tty3270_hangup_tasklet(unsigned long data)\n{\n\tstruct tty3270 *tp = (struct tty3270 *)data;\n\n\ttty_port_tty_hangup(&tp->port, true);\n\traw3270_put_view(&tp->view);\n}\n\n \nstatic int tty3270_activate(struct raw3270_view *view)\n{\n\tstruct tty3270 *tp = container_of(view, struct tty3270, view);\n\n\ttp->update_flags = TTY_UPDATE_ALL;\n\ttty3270_set_timer(tp, 1);\n\treturn 0;\n}\n\nstatic void tty3270_deactivate(struct raw3270_view *view)\n{\n\tstruct tty3270 *tp = container_of(view, struct tty3270, view);\n\n\tdel_timer(&tp->timer);\n}\n\nstatic void tty3270_irq(struct tty3270 *tp, struct raw3270_request *rq, struct irb *irb)\n{\n\t \n\tif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\n\t\tif (!tp->throttle)\n\t\t\ttty3270_issue_read(tp, 0);\n\t\telse\n\t\t\ttp->attn = 1;\n\t}\n\n\tif (rq) {\n\t\tif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {\n\t\t\trq->rc = -EIO;\n\t\t\traw3270_get_view(&tp->view);\n\t\t\ttasklet_schedule(&tp->hanglet);\n\t\t} else {\n\t\t\t \n\t\t\trq->rescnt = irb->scsw.cmd.count;\n\t\t}\n\t} else if (irb->scsw.cmd.dstat & DEV_STAT_DEV_END) {\n\t\t \n\t\ttp->update_flags = TTY_UPDATE_ALL;\n\t\ttty3270_set_timer(tp, 1);\n\t}\n}\n\n \nstatic struct tty3270 *tty3270_alloc_view(void)\n{\n\tstruct tty3270 *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\tgoto out_err;\n\n\ttp->write = raw3270_request_alloc(TTY3270_OUTPUT_BUFFER_SIZE);\n\tif (IS_ERR(tp->write))\n\t\tgoto out_tp;\n\ttp->read = raw3270_request_alloc(0);\n\tif (IS_ERR(tp->read))\n\t\tgoto out_write;\n\ttp->kreset = raw3270_request_alloc(1);\n\tif (IS_ERR(tp->kreset))\n\t\tgoto out_read;\n\ttp->readpartreq = raw3270_request_alloc(sizeof(sfq_read_partition));\n\tif (IS_ERR(tp->readpartreq))\n\t\tgoto out_reset;\n\ttp->kbd = kbd_alloc();\n\tif (!tp->kbd)\n\t\tgoto out_readpartreq;\n\n\ttty_port_init(&tp->port);\n\ttimer_setup(&tp->timer, tty3270_update, 0);\n\ttasklet_init(&tp->readlet, tty3270_read_tasklet,\n\t\t     (unsigned long)tp->read);\n\ttasklet_init(&tp->hanglet, tty3270_hangup_tasklet,\n\t\t     (unsigned long)tp);\n\treturn tp;\n\nout_readpartreq:\n\traw3270_request_free(tp->readpartreq);\nout_reset:\n\traw3270_request_free(tp->kreset);\nout_read:\n\traw3270_request_free(tp->read);\nout_write:\n\traw3270_request_free(tp->write);\nout_tp:\n\tkfree(tp);\nout_err:\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nstatic void tty3270_free_view(struct tty3270 *tp)\n{\n\tkbd_free(tp->kbd);\n\traw3270_request_free(tp->kreset);\n\traw3270_request_free(tp->read);\n\traw3270_request_free(tp->write);\n\tfree_page((unsigned long)tp->converted_line);\n\ttty_port_destroy(&tp->port);\n\tkfree(tp);\n}\n\n \nstatic struct tty3270_line *tty3270_alloc_screen(struct tty3270 *tp, unsigned int rows,\n\t\t\t\t\t\t unsigned int cols, int *allocated_out)\n{\n\tstruct tty3270_line *screen;\n\tint allocated, lines;\n\n\tallocated = __roundup_pow_of_two(rows) * TTY3270_SCREEN_PAGES;\n\tscreen = kcalloc(allocated, sizeof(struct tty3270_line), GFP_KERNEL);\n\tif (!screen)\n\t\tgoto out_err;\n\tfor (lines = 0; lines < allocated; lines++) {\n\t\tscreen[lines].cells = kcalloc(cols, sizeof(struct tty3270_cell), GFP_KERNEL);\n\t\tif (!screen[lines].cells)\n\t\t\tgoto out_screen;\n\t}\n\t*allocated_out = allocated;\n\treturn screen;\nout_screen:\n\twhile (lines--)\n\t\tkfree(screen[lines].cells);\n\tkfree(screen);\nout_err:\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic char **tty3270_alloc_recall(int cols)\n{\n\tchar **lines;\n\tint i;\n\n\tlines = kmalloc_array(TTY3270_RECALL_SIZE, sizeof(char *), GFP_KERNEL);\n\tif (!lines)\n\t\treturn NULL;\n\tfor (i = 0; i < TTY3270_RECALL_SIZE; i++) {\n\t\tlines[i] = kcalloc(1, tty3270_input_size(cols) + 1, GFP_KERNEL);\n\t\tif (!lines[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == TTY3270_RECALL_SIZE)\n\t\treturn lines;\n\n\twhile (i--)\n\t\tkfree(lines[i]);\n\tkfree(lines);\n\treturn NULL;\n}\n\nstatic void tty3270_free_recall(char **lines)\n{\n\tint i;\n\n\tfor (i = 0; i < TTY3270_RECALL_SIZE; i++)\n\t\tkfree(lines[i]);\n\tkfree(lines);\n}\n\n \nstatic void tty3270_free_screen(struct tty3270_line *screen, int old_lines)\n{\n\tint lines;\n\n\tfor (lines = 0; lines < old_lines; lines++)\n\t\tkfree(screen[lines].cells);\n\tkfree(screen);\n}\n\n \nstatic void tty3270_resize(struct raw3270_view *view,\n\t\t\t   int new_model, int new_rows, int new_cols,\n\t\t\t   int old_model, int old_rows, int old_cols)\n{\n\tstruct tty3270 *tp = container_of(view, struct tty3270, view);\n\tstruct tty3270_line *screen, *oscreen;\n\tchar **old_rcl_lines, **new_rcl_lines;\n\tchar *old_prompt, *new_prompt;\n\tchar *old_input, *new_input;\n\tstruct tty_struct *tty;\n\tstruct winsize ws;\n\tint new_allocated, old_allocated = tp->allocated_lines;\n\n\tif (old_model == new_model &&\n\t    old_cols == new_cols &&\n\t    old_rows == new_rows) {\n\t\tspin_lock_irq(&tp->view.lock);\n\t\ttty3270_redraw(tp);\n\t\tspin_unlock_irq(&tp->view.lock);\n\t\treturn;\n\t}\n\n\tnew_input = kzalloc(tty3270_input_size(new_cols), GFP_KERNEL | GFP_DMA);\n\tif (!new_input)\n\t\treturn;\n\tnew_prompt = kzalloc(tty3270_input_size(new_cols), GFP_KERNEL);\n\tif (!new_prompt)\n\t\tgoto out_input;\n\tscreen = tty3270_alloc_screen(tp, new_rows, new_cols, &new_allocated);\n\tif (IS_ERR(screen))\n\t\tgoto out_prompt;\n\tnew_rcl_lines = tty3270_alloc_recall(new_cols);\n\tif (!new_rcl_lines)\n\t\tgoto out_screen;\n\n\t \n\tspin_lock_irq(&tp->view.lock);\n\ttty3270_blank_screen(tp);\n\toscreen = tp->screen;\n\ttp->screen = screen;\n\ttp->allocated_lines = new_allocated;\n\ttp->view.rows = new_rows;\n\ttp->view.cols = new_cols;\n\ttp->view.model = new_model;\n\ttp->update_flags = TTY_UPDATE_ALL;\n\told_input = tp->input;\n\told_prompt = tp->prompt;\n\told_rcl_lines = tp->rcl_lines;\n\ttp->input = new_input;\n\ttp->prompt = new_prompt;\n\ttp->rcl_lines = new_rcl_lines;\n\ttp->rcl_read_index = 0;\n\ttp->rcl_write_index = 0;\n\tspin_unlock_irq(&tp->view.lock);\n\ttty3270_free_screen(oscreen, old_allocated);\n\tkfree(old_input);\n\tkfree(old_prompt);\n\ttty3270_free_recall(old_rcl_lines);\n\ttty3270_set_timer(tp, 1);\n\t \n\ttty = tty_port_tty_get(&tp->port);\n\tif (!tty)\n\t\treturn;\n\tws.ws_row = tty3270_tty_rows(tp);\n\tws.ws_col = tp->view.cols;\n\ttty_do_resize(tty, &ws);\n\ttty_kref_put(tty);\n\treturn;\nout_screen:\n\ttty3270_free_screen(screen, new_rows);\nout_prompt:\n\tkfree(new_prompt);\nout_input:\n\tkfree(new_input);\n}\n\n \nstatic void tty3270_release(struct raw3270_view *view)\n{\n\tstruct tty3270 *tp = container_of(view, struct tty3270, view);\n\tstruct tty_struct *tty = tty_port_tty_get(&tp->port);\n\n\tif (tty) {\n\t\ttty->driver_data = NULL;\n\t\ttty_port_tty_set(&tp->port, NULL);\n\t\ttty_hangup(tty);\n\t\traw3270_put_view(&tp->view);\n\t\ttty_kref_put(tty);\n\t}\n}\n\n \nstatic void tty3270_free(struct raw3270_view *view)\n{\n\tstruct tty3270 *tp = container_of(view, struct tty3270, view);\n\n\tdel_timer_sync(&tp->timer);\n\ttty3270_free_screen(tp->screen, tp->allocated_lines);\n\tfree_page((unsigned long)tp->converted_line);\n\tkfree(tp->input);\n\tkfree(tp->prompt);\n\ttty3270_free_view(tp);\n}\n\n \nstatic void tty3270_del_views(void)\n{\n\tint i;\n\n\tfor (i = RAW3270_FIRSTMINOR; i <= tty3270_max_index; i++) {\n\t\tstruct raw3270_view *view = raw3270_find_view(&tty3270_fn, i);\n\n\t\tif (!IS_ERR(view))\n\t\t\traw3270_del_view(view);\n\t}\n}\n\nstatic struct raw3270_fn tty3270_fn = {\n\t.activate = tty3270_activate,\n\t.deactivate = tty3270_deactivate,\n\t.intv = (void *)tty3270_irq,\n\t.release = tty3270_release,\n\t.free = tty3270_free,\n\t.resize = tty3270_resize\n};\n\nstatic int\ntty3270_create_view(int index, struct tty3270 **newtp)\n{\n\tstruct tty3270 *tp;\n\tint rc;\n\n\tif (tty3270_max_index < index + 1)\n\t\ttty3270_max_index = index + 1;\n\n\t \n\ttp = tty3270_alloc_view();\n\tif (IS_ERR(tp))\n\t\treturn PTR_ERR(tp);\n\n\trc = raw3270_add_view(&tp->view, &tty3270_fn,\n\t\t\t      index + RAW3270_FIRSTMINOR,\n\t\t\t      RAW3270_VIEW_LOCK_IRQ);\n\tif (rc)\n\t\tgoto out_free_view;\n\n\ttp->screen = tty3270_alloc_screen(tp, tp->view.rows, tp->view.cols,\n\t\t\t\t\t  &tp->allocated_lines);\n\tif (IS_ERR(tp->screen)) {\n\t\trc = PTR_ERR(tp->screen);\n\t\tgoto out_put_view;\n\t}\n\n\ttp->converted_line = (void *)__get_free_page(GFP_KERNEL);\n\tif (!tp->converted_line) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_screen;\n\t}\n\n\ttp->input = kzalloc(tty3270_input_size(tp->view.cols), GFP_KERNEL | GFP_DMA);\n\tif (!tp->input) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_converted_line;\n\t}\n\n\ttp->prompt = kzalloc(tty3270_input_size(tp->view.cols), GFP_KERNEL);\n\tif (!tp->prompt) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_input;\n\t}\n\n\ttp->rcl_lines = tty3270_alloc_recall(tp->view.cols);\n\tif (!tp->rcl_lines) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_prompt;\n\t}\n\n\t \n\ttty3270_blank_screen(tp);\n\n\ttp->kbd->port = &tp->port;\n\ttp->kbd->fn_handler[KVAL(K_INCRCONSOLE)] = tty3270_exit_tty;\n\ttp->kbd->fn_handler[KVAL(K_SCROLLBACK)] = tty3270_scroll_backward;\n\ttp->kbd->fn_handler[KVAL(K_SCROLLFORW)] = tty3270_scroll_forward;\n\ttp->kbd->fn_handler[KVAL(K_CONS)] = tty3270_rcl_backward;\n\tkbd_ascebc(tp->kbd, tp->view.ascebc);\n\n\traw3270_activate_view(&tp->view);\n\traw3270_put_view(&tp->view);\n\t*newtp = tp;\n\treturn 0;\n\nout_free_prompt:\n\tkfree(tp->prompt);\nout_free_input:\n\tkfree(tp->input);\nout_free_converted_line:\n\tfree_page((unsigned long)tp->converted_line);\nout_free_screen:\n\ttty3270_free_screen(tp->screen, tp->view.rows);\nout_put_view:\n\traw3270_put_view(&tp->view);\n\traw3270_del_view(&tp->view);\nout_free_view:\n\ttty3270_free_view(tp);\n\treturn rc;\n}\n\n \nstatic int\ntty3270_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct raw3270_view *view;\n\tstruct tty3270 *tp;\n\tint rc;\n\n\t \n\tview = raw3270_find_view(&tty3270_fn, tty->index + RAW3270_FIRSTMINOR);\n\tif (IS_ERR(view)) {\n\t\trc = tty3270_create_view(tty->index, &tp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\ttp = container_of(view, struct tty3270, view);\n\t\ttty->driver_data = tp;\n\t\ttp->inattr = TF_INPUT;\n\t}\n\n\ttty->winsize.ws_row = tty3270_tty_rows(tp);\n\ttty->winsize.ws_col = tp->view.cols;\n\trc = tty_port_install(&tp->port, driver, tty);\n\tif (rc) {\n\t\traw3270_put_view(&tp->view);\n\t\treturn rc;\n\t}\n\ttty->driver_data = tp;\n\treturn 0;\n}\n\n \nstatic int tty3270_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct tty3270 *tp = tty->driver_data;\n\tstruct tty_port *port = &tp->port;\n\n\tport->count++;\n\ttty_port_tty_set(port, tty);\n\treturn 0;\n}\n\n \nstatic void tty3270_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct tty3270 *tp = tty->driver_data;\n\n\tif (tty->count > 1)\n\t\treturn;\n\tif (tp)\n\t\ttty_port_tty_set(&tp->port, NULL);\n}\n\nstatic void tty3270_cleanup(struct tty_struct *tty)\n{\n\tstruct tty3270 *tp = tty->driver_data;\n\n\tif (tp) {\n\t\ttty->driver_data = NULL;\n\t\traw3270_put_view(&tp->view);\n\t}\n}\n\n \nstatic unsigned int tty3270_write_room(struct tty_struct *tty)\n{\n\treturn INT_MAX;\n}\n\n \nstatic void tty3270_put_character(struct tty3270 *tp, char ch)\n{\n\tstruct tty3270_line *line;\n\tstruct tty3270_cell *cell;\n\n\tline = tty3270_get_write_line(tp, tp->cy);\n\tif (line->len <= tp->cx) {\n\t\twhile (line->len < tp->cx) {\n\t\t\tcell = line->cells + line->len;\n\t\t\tcell->character = ' ';\n\t\t\tcell->attributes = tp->attributes;\n\t\t\tline->len++;\n\t\t}\n\t\tline->len++;\n\t}\n\tcell = line->cells + tp->cx;\n\tcell->character = ch;\n\tcell->attributes = tp->attributes;\n\tline->dirty = 1;\n}\n\n \nstatic void tty3270_cr(struct tty3270 *tp)\n{\n\ttp->cx = 0;\n}\n\n \nstatic void tty3270_lf(struct tty3270 *tp)\n{\n\tstruct tty3270_line *line;\n\tint i;\n\n\tif (tp->cy < tty3270_tty_rows(tp) - 1) {\n\t\ttp->cy++;\n\t} else {\n\t\ttp->line_view_start = tty3270_line_increment(tp, tp->line_view_start, 1);\n\t\ttp->line_write_start = tty3270_line_increment(tp, tp->line_write_start, 1);\n\t\tfor (i = 0; i < tty3270_tty_rows(tp); i++)\n\t\t\ttty3270_get_view_line(tp, i)->dirty = 1;\n\t}\n\n\tline = tty3270_get_write_line(tp, tp->cy);\n\tline->len = 0;\n\tline->dirty = 1;\n}\n\nstatic void tty3270_ri(struct tty3270 *tp)\n{\n\tif (tp->cy > 0)\n\t\ttp->cy--;\n}\n\nstatic void tty3270_reset_cell(struct tty3270 *tp, struct tty3270_cell *cell)\n{\n\tcell->character = ' ';\n\ttty3270_reset_attributes(&cell->attributes);\n}\n\n \nstatic void tty3270_insert_characters(struct tty3270 *tp, int n)\n{\n\tstruct tty3270_line *line;\n\tint k;\n\n\tline = tty3270_get_write_line(tp, tp->cy);\n\twhile (line->len < tp->cx)\n\t\ttty3270_reset_cell(tp, &line->cells[line->len++]);\n\tif (n > tp->view.cols - tp->cx)\n\t\tn = tp->view.cols - tp->cx;\n\tk = min_t(int, line->len - tp->cx, tp->view.cols - tp->cx - n);\n\twhile (k--)\n\t\tline->cells[tp->cx + n + k] = line->cells[tp->cx + k];\n\tline->len += n;\n\tif (line->len > tp->view.cols)\n\t\tline->len = tp->view.cols;\n\twhile (n-- > 0) {\n\t\tline->cells[tp->cx + n].character = ' ';\n\t\tline->cells[tp->cx + n].attributes = tp->attributes;\n\t}\n}\n\n \nstatic void tty3270_delete_characters(struct tty3270 *tp, int n)\n{\n\tstruct tty3270_line *line;\n\tint i;\n\n\tline = tty3270_get_write_line(tp, tp->cy);\n\tif (line->len <= tp->cx)\n\t\treturn;\n\tif (line->len - tp->cx <= n) {\n\t\tline->len = tp->cx;\n\t\treturn;\n\t}\n\tfor (i = tp->cx; i + n < line->len; i++)\n\t\tline->cells[i] = line->cells[i + n];\n\tline->len -= n;\n}\n\n \nstatic void tty3270_erase_characters(struct tty3270 *tp, int n)\n{\n\tstruct tty3270_line *line;\n\tstruct tty3270_cell *cell;\n\n\tline = tty3270_get_write_line(tp, tp->cy);\n\twhile (line->len > tp->cx && n-- > 0) {\n\t\tcell = line->cells + tp->cx++;\n\t\ttty3270_reset_cell(tp, cell);\n\t}\n\ttp->cx += n;\n\ttp->cx = min_t(int, tp->cx, tp->view.cols - 1);\n}\n\n \nstatic void tty3270_erase_line(struct tty3270 *tp, int mode)\n{\n\tstruct tty3270_line *line;\n\tstruct tty3270_cell *cell;\n\tint i, start, end;\n\n\tline = tty3270_get_write_line(tp, tp->cy);\n\n\tswitch (mode) {\n\tcase 0:\n\t\tstart = tp->cx;\n\t\tend = tp->view.cols;\n\t\tbreak;\n\tcase 1:\n\t\tstart = 0;\n\t\tend = tp->cx;\n\t\tbreak;\n\tcase 2:\n\t\tstart = 0;\n\t\tend = tp->view.cols;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = start; i < end; i++) {\n\t\tcell = line->cells + i;\n\t\ttty3270_reset_cell(tp, cell);\n\t\tcell->attributes.b_color = tp->attributes.b_color;\n\t}\n\n\tif (line->len <= end)\n\t\tline->len = end;\n}\n\n \nstatic void tty3270_erase_display(struct tty3270 *tp, int mode)\n{\n\tstruct tty3270_line *line;\n\tint i, start, end;\n\n\tswitch (mode) {\n\tcase 0:\n\t\ttty3270_erase_line(tp, 0);\n\t\tstart = tp->cy + 1;\n\t\tend = tty3270_tty_rows(tp);\n\t\tbreak;\n\tcase 1:\n\t\tstart = 0;\n\t\tend = tp->cy;\n\t\ttty3270_erase_line(tp, 1);\n\t\tbreak;\n\tcase 2:\n\t\tstart = 0;\n\t\tend = tty3270_tty_rows(tp);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tfor (i = start; i < end; i++) {\n\t\tline = tty3270_get_write_line(tp, i);\n\t\tline->len = 0;\n\t\tline->dirty = 1;\n\t}\n}\n\n \nstatic void tty3270_set_attributes(struct tty3270 *tp)\n{\n\tint i, attr;\n\n\tfor (i = 0; i <= tp->esc_npar; i++) {\n\t\tattr = tp->esc_par[i];\n\t\tswitch (attr) {\n\t\tcase 0:\t\t \n\t\t\ttty3270_reset_attributes(&tp->attributes);\n\t\t\tbreak;\n\t\t \n\t\tcase 4:\t\t \n\t\t\ttp->attributes.highlight = TTY3270_HIGHLIGHT_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 5:\t\t \n\t\t\ttp->attributes.highlight = TTY3270_HIGHLIGHT_BLINK;\n\t\t\tbreak;\n\t\tcase 7:\t\t \n\t\t\ttp->attributes.highlight = TTY3270_HIGHLIGHT_REVERSE;\n\t\t\tbreak;\n\t\tcase 24:\t \n\t\t\ttp->attributes.highlight &= ~TTY3270_HIGHLIGHT_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 25:\t \n\t\t\ttp->attributes.highlight &= ~TTY3270_HIGHLIGHT_BLINK;\n\t\t\tbreak;\n\t\tcase 27:\t \n\t\t\ttp->attributes.highlight &= ~TTY3270_HIGHLIGHT_REVERSE;\n\t\t\tbreak;\n\t\t \n\t\tcase 30:\t \n\t\tcase 31:\t \n\t\tcase 32:\t \n\t\tcase 33:\t \n\t\tcase 34:\t \n\t\tcase 35:\t \n\t\tcase 36:\t \n\t\tcase 37:\t \n\t\tcase 39:\t \n\t\t\ttp->attributes.f_color = attr - 30;\n\t\t\tbreak;\n\t\t \n\t\tcase 40:\t \n\t\tcase 41:\t \n\t\tcase 42:\t \n\t\tcase 43:\t \n\t\tcase 44:\t \n\t\tcase 45:\t \n\t\tcase 46:\t \n\t\tcase 47:\t \n\t\tcase 49:\t \n\t\t\ttp->attributes.b_color = attr - 40;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline int tty3270_getpar(struct tty3270 *tp, int ix)\n{\n\treturn (tp->esc_par[ix] > 0) ? tp->esc_par[ix] : 1;\n}\n\nstatic void tty3270_goto_xy(struct tty3270 *tp, int cx, int cy)\n{\n\tstruct tty3270_line *line;\n\tstruct tty3270_cell *cell;\n\tint max_cx = max(0, cx);\n\tint max_cy = max(0, cy);\n\n\ttp->cx = min_t(int, tp->view.cols - 1, max_cx);\n\tline = tty3270_get_write_line(tp, tp->cy);\n\twhile (line->len < tp->cx) {\n\t\tcell = line->cells + line->len;\n\t\tcell->character = ' ';\n\t\tcell->attributes = tp->attributes;\n\t\tline->len++;\n\t}\n\ttp->cy = min_t(int, tty3270_tty_rows(tp) - 1, max_cy);\n}\n\n \nstatic void tty3270_escape_sequence(struct tty3270 *tp, char ch)\n{\n\tenum { ES_NORMAL, ES_ESC, ES_SQUARE, ES_PAREN, ES_GETPARS };\n\n\tif (tp->esc_state == ES_NORMAL) {\n\t\tif (ch == 0x1b)\n\t\t\t \n\t\t\ttp->esc_state = ES_ESC;\n\t\treturn;\n\t}\n\tif (tp->esc_state == ES_ESC) {\n\t\ttp->esc_state = ES_NORMAL;\n\t\tswitch (ch) {\n\t\tcase '[':\n\t\t\ttp->esc_state = ES_SQUARE;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\ttp->esc_state = ES_PAREN;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\ttty3270_cr(tp);\n\t\t\ttty3270_lf(tp);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\ttty3270_ri(tp);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\ttty3270_lf(tp);\n\t\t\tbreak;\n\t\tcase 'Z':\t\t \n\t\t\tkbd_puts_queue(&tp->port, \"\\033[?6c\");\n\t\t\tbreak;\n\t\tcase '7':\t\t \n\t\t\ttp->saved_cx = tp->cx;\n\t\t\ttp->saved_cy = tp->cy;\n\t\t\ttp->saved_attributes = tp->attributes;\n\t\t\tbreak;\n\t\tcase '8':\t\t \n\t\t\ttty3270_goto_xy(tp, tp->saved_cx, tp->saved_cy);\n\t\t\ttp->attributes = tp->saved_attributes;\n\t\t\tbreak;\n\t\tcase 'c':\t\t \n\t\t\ttp->cx = 0;\n\t\t\ttp->cy = 0;\n\t\t\ttp->saved_cx = 0;\n\t\t\ttp->saved_cy = 0;\n\t\t\ttty3270_reset_attributes(&tp->attributes);\n\t\t\ttty3270_reset_attributes(&tp->saved_attributes);\n\t\t\ttty3270_erase_display(tp, 2);\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tswitch (tp->esc_state) {\n\tcase ES_PAREN:\n\t\ttp->esc_state = ES_NORMAL;\n\t\tswitch (ch) {\n\t\tcase 'B':\n\t\t\ttp->attributes.alternate_charset = 0;\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\ttp->attributes.alternate_charset = 1;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\tcase ES_SQUARE:\n\t\ttp->esc_state = ES_GETPARS;\n\t\tmemset(tp->esc_par, 0, sizeof(tp->esc_par));\n\t\ttp->esc_npar = 0;\n\t\ttp->esc_ques = (ch == '?');\n\t\tif (tp->esc_ques)\n\t\t\treturn;\n\t\tfallthrough;\n\tcase ES_GETPARS:\n\t\tif (ch == ';' && tp->esc_npar < ESCAPE_NPAR - 1) {\n\t\t\ttp->esc_npar++;\n\t\t\treturn;\n\t\t}\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\ttp->esc_par[tp->esc_npar] *= 10;\n\t\t\ttp->esc_par[tp->esc_npar] += ch - '0';\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ttp->esc_state = ES_NORMAL;\n\tif (ch == 'n' && !tp->esc_ques) {\n\t\tif (tp->esc_par[0] == 5)\t\t \n\t\t\tkbd_puts_queue(&tp->port, \"\\033[0n\");\n\t\telse if (tp->esc_par[0] == 6) {\t \n\t\t\tchar buf[40];\n\n\t\t\tsprintf(buf, \"\\033[%d;%dR\", tp->cy + 1, tp->cx + 1);\n\t\t\tkbd_puts_queue(&tp->port, buf);\n\t\t}\n\t\treturn;\n\t}\n\tif (tp->esc_ques)\n\t\treturn;\n\tswitch (ch) {\n\tcase 'm':\n\t\ttty3270_set_attributes(tp);\n\t\tbreak;\n\tcase 'H':\t \n\tcase 'f':\n\t\ttty3270_goto_xy(tp, tty3270_getpar(tp, 1) - 1,\n\t\t\t\ttty3270_getpar(tp, 0) - 1);\n\t\tbreak;\n\tcase 'd':\t \n\t\ttty3270_goto_xy(tp, tp->cx, tty3270_getpar(tp, 0) - 1);\n\t\tbreak;\n\tcase 'A':\t \n\tcase 'F':\n\t\ttty3270_goto_xy(tp, tp->cx, tp->cy - tty3270_getpar(tp, 0));\n\t\tbreak;\n\tcase 'B':\t \n\tcase 'e':\n\tcase 'E':\n\t\ttty3270_goto_xy(tp, tp->cx, tp->cy + tty3270_getpar(tp, 0));\n\t\tbreak;\n\tcase 'C':\t \n\tcase 'a':\n\t\ttty3270_goto_xy(tp, tp->cx + tty3270_getpar(tp, 0), tp->cy);\n\t\tbreak;\n\tcase 'D':\t \n\t\ttty3270_goto_xy(tp, tp->cx - tty3270_getpar(tp, 0), tp->cy);\n\t\tbreak;\n\tcase 'G':\t \n\tcase '`':\n\t\ttty3270_goto_xy(tp, tty3270_getpar(tp, 0), tp->cy);\n\t\tbreak;\n\tcase 'X':\t \n\t\ttty3270_erase_characters(tp, tty3270_getpar(tp, 0));\n\t\tbreak;\n\tcase 'J':\t \n\t\ttty3270_erase_display(tp, tp->esc_par[0]);\n\t\tbreak;\n\tcase 'K':\t \n\t\ttty3270_erase_line(tp, tp->esc_par[0]);\n\t\tbreak;\n\tcase 'P':\t \n\t\ttty3270_delete_characters(tp, tty3270_getpar(tp, 0));\n\t\tbreak;\n\tcase '@':\t \n\t\ttty3270_insert_characters(tp, tty3270_getpar(tp, 0));\n\t\tbreak;\n\tcase 's':\t \n\t\ttp->saved_cx = tp->cx;\n\t\ttp->saved_cy = tp->cy;\n\t\ttp->saved_attributes = tp->attributes;\n\t\tbreak;\n\tcase 'u':\t \n\t\ttty3270_goto_xy(tp, tp->saved_cx, tp->saved_cy);\n\t\ttp->attributes = tp->saved_attributes;\n\t\tbreak;\n\t}\n}\n\n \nstatic void tty3270_do_write(struct tty3270 *tp, struct tty_struct *tty,\n\t\t\t     const unsigned char *buf, int count)\n{\n\tint i_msg, i;\n\n\tspin_lock_irq(&tp->view.lock);\n\tfor (i_msg = 0; !tty->flow.stopped && i_msg < count; i_msg++) {\n\t\tif (tp->esc_state != 0) {\n\t\t\t \n\t\t\ttty3270_escape_sequence(tp, buf[i_msg]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (buf[i_msg]) {\n\t\tcase 0x00:\n\t\t\tbreak;\n\t\tcase 0x07:\t\t \n\t\t\ttp->wcc |= TW_PLUSALARM;\n\t\t\tbreak;\n\t\tcase 0x08:\t\t \n\t\t\tif (tp->cx > 0) {\n\t\t\t\ttp->cx--;\n\t\t\t\ttty3270_put_character(tp, ' ');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x09:\t\t \n\t\t\tfor (i = tp->cx % 8; i < 8; i++) {\n\t\t\t\tif (tp->cx >= tp->view.cols) {\n\t\t\t\t\ttty3270_cr(tp);\n\t\t\t\t\ttty3270_lf(tp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty3270_put_character(tp, ' ');\n\t\t\t\ttp->cx++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0a:\t\t \n\t\t\ttty3270_cr(tp);\n\t\t\ttty3270_lf(tp);\n\t\t\tbreak;\n\t\tcase 0x0c:\t\t \n\t\t\ttty3270_erase_display(tp, 2);\n\t\t\ttp->cx = 0;\n\t\t\ttp->cy = 0;\n\t\t\tbreak;\n\t\tcase 0x0d:\t\t \n\t\t\ttp->cx = 0;\n\t\t\tbreak;\n\t\tcase 0x0e:\n\t\t\ttp->attributes.alternate_charset = 1;\n\t\t\tbreak;\n\t\tcase 0x0f:\t\t \n\t\t\ttp->attributes.alternate_charset = 0;\n\t\t\tbreak;\n\t\tcase 0x1b:\t\t \n\t\t\ttty3270_escape_sequence(tp, buf[i_msg]);\n\t\t\tbreak;\n\t\tdefault:\t\t \n\t\t\tif (tp->cx >= tp->view.cols) {\n\t\t\t\ttty3270_cr(tp);\n\t\t\t\ttty3270_lf(tp);\n\t\t\t}\n\t\t\ttty3270_put_character(tp, buf[i_msg]);\n\t\t\ttp->cx++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\ttp->update_flags |= TTY_UPDATE_LINES;\n\tif (!timer_pending(&tp->timer))\n\t\ttty3270_set_timer(tp, msecs_to_jiffies(100));\n\n\tspin_unlock_irq(&tp->view.lock);\n}\n\n \nstatic ssize_t tty3270_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t     size_t count)\n{\n\tstruct tty3270 *tp;\n\n\ttp = tty->driver_data;\n\tif (!tp)\n\t\treturn 0;\n\tif (tp->char_count > 0) {\n\t\ttty3270_do_write(tp, tty, tp->char_buf, tp->char_count);\n\t\ttp->char_count = 0;\n\t}\n\ttty3270_do_write(tp, tty, buf, count);\n\treturn count;\n}\n\n \nstatic int tty3270_put_char(struct tty_struct *tty, u8 ch)\n{\n\tstruct tty3270 *tp;\n\n\ttp = tty->driver_data;\n\tif (!tp || tp->char_count >= TTY3270_CHAR_BUF_SIZE)\n\t\treturn 0;\n\ttp->char_buf[tp->char_count++] = ch;\n\treturn 1;\n}\n\n \nstatic void tty3270_flush_chars(struct tty_struct *tty)\n{\n\tstruct tty3270 *tp;\n\n\ttp = tty->driver_data;\n\tif (!tp)\n\t\treturn;\n\tif (tp->char_count > 0) {\n\t\ttty3270_do_write(tp, tty, tp->char_buf, tp->char_count);\n\t\ttp->char_count = 0;\n\t}\n}\n\n \nstatic void tty3270_set_termios(struct tty_struct *tty, const struct ktermios *old)\n{\n\tstruct tty3270 *tp;\n\tint new;\n\n\ttp = tty->driver_data;\n\tif (!tp)\n\t\treturn;\n\tspin_lock_irq(&tp->view.lock);\n\tif (L_ICANON(tty)) {\n\t\tnew = L_ECHO(tty) ? TF_INPUT : TF_INPUTN;\n\t\tif (new != tp->inattr) {\n\t\t\ttp->inattr = new;\n\t\t\ttty3270_update_prompt(tp, \"\");\n\t\t\ttty3270_set_timer(tp, 1);\n\t\t}\n\t}\n\tspin_unlock_irq(&tp->view.lock);\n}\n\n \nstatic void tty3270_throttle(struct tty_struct *tty)\n{\n\tstruct tty3270 *tp;\n\n\ttp = tty->driver_data;\n\tif (!tp)\n\t\treturn;\n\ttp->throttle = 1;\n}\n\n \nstatic void tty3270_unthrottle(struct tty_struct *tty)\n{\n\tstruct tty3270 *tp;\n\n\ttp = tty->driver_data;\n\tif (!tp)\n\t\treturn;\n\ttp->throttle = 0;\n\tif (tp->attn)\n\t\ttty3270_issue_read(tp, 1);\n}\n\n \nstatic void tty3270_hangup(struct tty_struct *tty)\n{\n\tstruct tty3270 *tp;\n\n\ttp = tty->driver_data;\n\tif (!tp)\n\t\treturn;\n\tspin_lock_irq(&tp->view.lock);\n\ttp->cx = 0;\n\ttp->cy = 0;\n\ttp->saved_cx = 0;\n\ttp->saved_cy = 0;\n\ttty3270_reset_attributes(&tp->attributes);\n\ttty3270_reset_attributes(&tp->saved_attributes);\n\ttty3270_blank_screen(tp);\n\ttp->update_flags = TTY_UPDATE_ALL;\n\tspin_unlock_irq(&tp->view.lock);\n\ttty3270_set_timer(tp, 1);\n}\n\nstatic void tty3270_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n}\n\nstatic int tty3270_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tstruct tty3270 *tp;\n\n\ttp = tty->driver_data;\n\tif (!tp)\n\t\treturn -ENODEV;\n\tif (tty_io_error(tty))\n\t\treturn -EIO;\n\treturn kbd_ioctl(tp->kbd, cmd, arg);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long tty3270_compat_ioctl(struct tty_struct *tty,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct tty3270 *tp;\n\n\ttp = tty->driver_data;\n\tif (!tp)\n\t\treturn -ENODEV;\n\tif (tty_io_error(tty))\n\t\treturn -EIO;\n\treturn kbd_ioctl(tp->kbd, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic const struct tty_operations tty3270_ops = {\n\t.install = tty3270_install,\n\t.cleanup = tty3270_cleanup,\n\t.open = tty3270_open,\n\t.close = tty3270_close,\n\t.write = tty3270_write,\n\t.put_char = tty3270_put_char,\n\t.flush_chars = tty3270_flush_chars,\n\t.write_room = tty3270_write_room,\n\t.throttle = tty3270_throttle,\n\t.unthrottle = tty3270_unthrottle,\n\t.hangup = tty3270_hangup,\n\t.wait_until_sent = tty3270_wait_until_sent,\n\t.ioctl = tty3270_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = tty3270_compat_ioctl,\n#endif\n\t.set_termios = tty3270_set_termios\n};\n\nstatic void tty3270_create_cb(int minor)\n{\n\ttty_register_device(tty3270_driver, minor - RAW3270_FIRSTMINOR, NULL);\n}\n\nstatic void tty3270_destroy_cb(int minor)\n{\n\ttty_unregister_device(tty3270_driver, minor - RAW3270_FIRSTMINOR);\n}\n\nstatic struct raw3270_notifier tty3270_notifier = {\n\t.create = tty3270_create_cb,\n\t.destroy = tty3270_destroy_cb,\n};\n\n \nstatic int __init tty3270_init(void)\n{\n\tstruct tty_driver *driver;\n\tint ret;\n\n\tdriver = tty_alloc_driver(RAW3270_MAXDEVS,\n\t\t\t\t  TTY_DRIVER_REAL_RAW |\n\t\t\t\t  TTY_DRIVER_DYNAMIC_DEV |\n\t\t\t\t  TTY_DRIVER_RESET_TERMIOS);\n\tif (IS_ERR(driver))\n\t\treturn PTR_ERR(driver);\n\n\t \n\tdriver->driver_name = \"tty3270\";\n\tdriver->name = \"3270/tty\";\n\tdriver->major = IBM_TTY3270_MAJOR;\n\tdriver->minor_start = RAW3270_FIRSTMINOR;\n\tdriver->name_base = RAW3270_FIRSTMINOR;\n\tdriver->type = TTY_DRIVER_TYPE_SYSTEM;\n\tdriver->subtype = SYSTEM_TYPE_TTY;\n\tdriver->init_termios = tty_std_termios;\n\ttty_set_operations(driver, &tty3270_ops);\n\tret = tty_register_driver(driver);\n\tif (ret) {\n\t\ttty_driver_kref_put(driver);\n\t\treturn ret;\n\t}\n\ttty3270_driver = driver;\n\traw3270_register_notifier(&tty3270_notifier);\n\treturn 0;\n}\n\nstatic void __exit tty3270_exit(void)\n{\n\tstruct tty_driver *driver;\n\n\traw3270_unregister_notifier(&tty3270_notifier);\n\tdriver = tty3270_driver;\n\ttty3270_driver = NULL;\n\ttty_unregister_driver(driver);\n\ttty_driver_kref_put(driver);\n\ttty3270_del_views();\n}\n\n#if IS_ENABLED(CONFIG_TN3270_CONSOLE)\n\nstatic struct tty3270 *condev;\n\nstatic void\ncon3270_write(struct console *co, const char *str, unsigned int count)\n{\n\tstruct tty3270 *tp = co->data;\n\tunsigned long flags;\n\tchar c;\n\n\tspin_lock_irqsave(&tp->view.lock, flags);\n\twhile (count--) {\n\t\tc = *str++;\n\t\tif (c == 0x0a) {\n\t\t\ttty3270_cr(tp);\n\t\t\ttty3270_lf(tp);\n\t\t} else {\n\t\t\tif (tp->cx >= tp->view.cols) {\n\t\t\t\ttty3270_cr(tp);\n\t\t\t\ttty3270_lf(tp);\n\t\t\t}\n\t\t\ttty3270_put_character(tp, c);\n\t\t\ttp->cx++;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tp->view.lock, flags);\n}\n\nstatic struct tty_driver *\ncon3270_device(struct console *c, int *index)\n{\n\t*index = c->index;\n\treturn tty3270_driver;\n}\n\nstatic void\ncon3270_wait_write(struct tty3270 *tp)\n{\n\twhile (!tp->write) {\n\t\traw3270_wait_cons_dev(tp->view.dev);\n\t\tbarrier();\n\t}\n}\n\n \nstatic int con3270_notify(struct notifier_block *self,\n\t\t\t  unsigned long event, void *data)\n{\n\tstruct tty3270 *tp;\n\tunsigned long flags;\n\tint rc;\n\n\ttp = condev;\n\tif (!tp->view.dev)\n\t\treturn NOTIFY_DONE;\n\tif (!raw3270_view_lock_unavailable(&tp->view)) {\n\t\trc = raw3270_activate_view(&tp->view);\n\t\tif (rc)\n\t\t\treturn NOTIFY_DONE;\n\t}\n\tif (!spin_trylock_irqsave(&tp->view.lock, flags))\n\t\treturn NOTIFY_DONE;\n\tcon3270_wait_write(tp);\n\ttp->nr_up = 0;\n\ttp->update_flags = TTY_UPDATE_ALL;\n\twhile (tp->update_flags != 0) {\n\t\tspin_unlock_irqrestore(&tp->view.lock, flags);\n\t\ttty3270_update(&tp->timer);\n\t\tspin_lock_irqsave(&tp->view.lock, flags);\n\t\tcon3270_wait_write(tp);\n\t}\n\tspin_unlock_irqrestore(&tp->view.lock, flags);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block on_panic_nb = {\n\t.notifier_call = con3270_notify,\n\t.priority = INT_MIN + 1,  \n};\n\nstatic struct notifier_block on_reboot_nb = {\n\t.notifier_call = con3270_notify,\n\t.priority = INT_MIN + 1,  \n};\n\nstatic struct console con3270 = {\n\t.name\t = \"tty3270\",\n\t.write\t = con3270_write,\n\t.device\t = con3270_device,\n\t.flags\t = CON_PRINTBUFFER,\n};\n\nstatic int __init\ncon3270_init(void)\n{\n\tstruct raw3270_view *view;\n\tstruct raw3270 *rp;\n\tstruct tty3270 *tp;\n\tint rc;\n\n\t \n\tif (!CONSOLE_IS_3270)\n\t\treturn -ENODEV;\n\n\t \n\tif (MACHINE_IS_VM) {\n\t\tcpcmd(\"TERM CONMODE 3270\", NULL, 0, NULL);\n\t\tcpcmd(\"TERM AUTOCR OFF\", NULL, 0, NULL);\n\t}\n\n\trp = raw3270_setup_console();\n\tif (IS_ERR(rp))\n\t\treturn PTR_ERR(rp);\n\n\t \n\tview = raw3270_find_view(&tty3270_fn, RAW3270_FIRSTMINOR);\n\tif (IS_ERR(view)) {\n\t\trc = tty3270_create_view(0, &tp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\ttp = container_of(view, struct tty3270, view);\n\t\ttp->inattr = TF_INPUT;\n\t}\n\tcon3270.data = tp;\n\tcondev = tp;\n\tatomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\n\tregister_reboot_notifier(&on_reboot_nb);\n\tregister_console(&con3270);\n\treturn 0;\n}\nconsole_initcall(con3270_init);\n#endif\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(IBM_TTY3270_MAJOR);\n\nmodule_init(tty3270_init);\nmodule_exit(tty3270_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}