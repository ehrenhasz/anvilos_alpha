{
  "module_name": "keyboard.c",
  "hash_id": "c1c842aea240152c81f4d97104b08acee0bb5cdf93bf55f7d75edeb713b04604",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/keyboard.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/sysrq.h>\n\n#include <linux/consolemap.h>\n#include <linux/kbd_kern.h>\n#include <linux/kbd_diacr.h>\n#include <linux/uaccess.h>\n\n#include \"keyboard.h\"\n\n \n#define K_HANDLERS\\\n\tk_self,\t\tk_fn,\t\tk_spec,\t\tk_ignore,\\\n\tk_dead,\t\tk_ignore,\tk_ignore,\tk_ignore,\\\n\tk_ignore,\tk_ignore,\tk_ignore,\tk_ignore,\\\n\tk_ignore,\tk_ignore,\tk_ignore,\tk_ignore\n\ntypedef void (k_handler_fn)(struct kbd_data *, unsigned char);\nstatic k_handler_fn K_HANDLERS;\nstatic k_handler_fn *k_handler[16] = { K_HANDLERS };\n\n \nstatic const int kbd_max_vals[] = {\n\t255, ARRAY_SIZE(func_table) - 1, NR_FN_HANDLER - 1, 0,\n\tNR_DEAD - 1, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\nstatic const int KBD_NR_TYPES = ARRAY_SIZE(kbd_max_vals);\n\nstatic const unsigned char ret_diacr[NR_DEAD] = {\n\t'`',\t \n\t'\\'',\t \n\t'^',\t \n\t'~',\t \n\t'\"',\t \n\t',',\t \n\t'_',\t \n\t'U',\t \n\t'.',\t \n\t'*',\t \n\t'=',\t \n\t'c',\t \n\t'k',\t \n\t'i',\t \n\t'#',\t \n\t'o',\t \n\t'!',\t \n\t'?',\t \n\t'+',\t \n\t'-',\t \n\t')',\t \n\t'(',\t \n\t':',\t \n\t'n',\t \n\t';',\t \n\t'$',\t \n\t'@',\t \n};\n\n \nstruct kbd_data *\nkbd_alloc(void) {\n\tstruct kbd_data *kbd;\n\tint i;\n\n\tkbd = kzalloc(sizeof(struct kbd_data), GFP_KERNEL);\n\tif (!kbd)\n\t\tgoto out;\n\tkbd->key_maps = kzalloc(sizeof(ebc_key_maps), GFP_KERNEL);\n\tif (!kbd->key_maps)\n\t\tgoto out_kbd;\n\tfor (i = 0; i < ARRAY_SIZE(ebc_key_maps); i++) {\n\t\tif (ebc_key_maps[i]) {\n\t\t\tkbd->key_maps[i] = kmemdup(ebc_key_maps[i],\n\t\t\t\t\t\t   sizeof(u_short) * NR_KEYS,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!kbd->key_maps[i])\n\t\t\t\tgoto out_maps;\n\t\t}\n\t}\n\tkbd->func_table = kzalloc(sizeof(ebc_func_table), GFP_KERNEL);\n\tif (!kbd->func_table)\n\t\tgoto out_maps;\n\tfor (i = 0; i < ARRAY_SIZE(ebc_func_table); i++) {\n\t\tif (ebc_func_table[i]) {\n\t\t\tkbd->func_table[i] = kstrdup(ebc_func_table[i],\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!kbd->func_table[i])\n\t\t\t\tgoto out_func;\n\t\t}\n\t}\n\tkbd->fn_handler =\n\t\tkcalloc(NR_FN_HANDLER, sizeof(fn_handler_fn *), GFP_KERNEL);\n\tif (!kbd->fn_handler)\n\t\tgoto out_func;\n\tkbd->accent_table = kmemdup(ebc_accent_table,\n\t\t\t\t    sizeof(struct kbdiacruc) * MAX_DIACR,\n\t\t\t\t    GFP_KERNEL);\n\tif (!kbd->accent_table)\n\t\tgoto out_fn_handler;\n\tkbd->accent_table_size = ebc_accent_table_size;\n\treturn kbd;\n\nout_fn_handler:\n\tkfree(kbd->fn_handler);\nout_func:\n\tfor (i = 0; i < ARRAY_SIZE(ebc_func_table); i++)\n\t\tkfree(kbd->func_table[i]);\n\tkfree(kbd->func_table);\nout_maps:\n\tfor (i = 0; i < ARRAY_SIZE(ebc_key_maps); i++)\n\t\tkfree(kbd->key_maps[i]);\n\tkfree(kbd->key_maps);\nout_kbd:\n\tkfree(kbd);\nout:\n\treturn NULL;\n}\n\nvoid\nkbd_free(struct kbd_data *kbd)\n{\n\tint i;\n\n\tkfree(kbd->accent_table);\n\tkfree(kbd->fn_handler);\n\tfor (i = 0; i < ARRAY_SIZE(ebc_func_table); i++)\n\t\tkfree(kbd->func_table[i]);\n\tkfree(kbd->func_table);\n\tfor (i = 0; i < ARRAY_SIZE(ebc_key_maps); i++)\n\t\tkfree(kbd->key_maps[i]);\n\tkfree(kbd->key_maps);\n\tkfree(kbd);\n}\n\n \nvoid\nkbd_ascebc(struct kbd_data *kbd, unsigned char *ascebc)\n{\n\tunsigned short *keymap, keysym;\n\tint i, j, k;\n\n\tmemset(ascebc, 0x40, 256);\n\tfor (i = 0; i < ARRAY_SIZE(ebc_key_maps); i++) {\n\t\tkeymap = kbd->key_maps[i];\n\t\tif (!keymap)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < NR_KEYS; j++) {\n\t\t\tk = ((i & 1) << 7) + j;\n\t\t\tkeysym = keymap[j];\n\t\t\tif (KTYP(keysym) == (KT_LATIN | 0xf0) ||\n\t\t\t    KTYP(keysym) == (KT_LETTER | 0xf0))\n\t\t\t\tascebc[KVAL(keysym)] = k;\n\t\t\telse if (KTYP(keysym) == (KT_DEAD | 0xf0))\n\t\t\t\tascebc[ret_diacr[KVAL(keysym)]] = k;\n\t\t}\n\t}\n}\n\n#if 0\n \nvoid\nkbd_ebcasc(struct kbd_data *kbd, unsigned char *ebcasc)\n{\n\tunsigned short *keymap, keysym;\n\tint i, j, k;\n\n\tmemset(ebcasc, ' ', 256);\n\tfor (i = 0; i < ARRAY_SIZE(ebc_key_maps); i++) {\n\t\tkeymap = kbd->key_maps[i];\n\t\tif (!keymap)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < NR_KEYS; j++) {\n\t\t\tkeysym = keymap[j];\n\t\t\tk = ((i & 1) << 7) + j;\n\t\t\tif (KTYP(keysym) == (KT_LATIN | 0xf0) ||\n\t\t\t    KTYP(keysym) == (KT_LETTER | 0xf0))\n\t\t\t\tebcasc[k] = KVAL(keysym);\n\t\t\telse if (KTYP(keysym) == (KT_DEAD | 0xf0))\n\t\t\t\tebcasc[k] = ret_diacr[KVAL(keysym)];\n\t\t}\n\t}\n}\n#endif\n\n \nstatic unsigned int\nhandle_diacr(struct kbd_data *kbd, unsigned int ch)\n{\n\tint i, d;\n\n\td = kbd->diacr;\n\tkbd->diacr = 0;\n\n\tfor (i = 0; i < kbd->accent_table_size; i++) {\n\t\tif (kbd->accent_table[i].diacr == d &&\n\t\t    kbd->accent_table[i].base == ch)\n\t\t\treturn kbd->accent_table[i].result;\n\t}\n\n\tif (ch == ' ' || ch == d)\n\t\treturn d;\n\n\tkbd_put_queue(kbd->port, d);\n\treturn ch;\n}\n\n \nstatic void\nk_dead(struct kbd_data *kbd, unsigned char value)\n{\n\tvalue = ret_diacr[value];\n\tkbd->diacr = (kbd->diacr ? handle_diacr(kbd, value) : value);\n}\n\n \nstatic void\nk_self(struct kbd_data *kbd, unsigned char value)\n{\n\tif (kbd->diacr)\n\t\tvalue = handle_diacr(kbd, value);\n\tkbd_put_queue(kbd->port, value);\n}\n\n \nstatic void\nk_ignore(struct kbd_data *kbd, unsigned char value)\n{\n}\n\n \nstatic void\nk_fn(struct kbd_data *kbd, unsigned char value)\n{\n\tif (kbd->func_table[value])\n\t\tkbd_puts_queue(kbd->port, kbd->func_table[value]);\n}\n\nstatic void\nk_spec(struct kbd_data *kbd, unsigned char value)\n{\n\tif (value >= NR_FN_HANDLER)\n\t\treturn;\n\tif (kbd->fn_handler[value])\n\t\tkbd->fn_handler[value](kbd);\n}\n\n \nstatic void\nto_utf8(struct tty_port *port, ushort c)\n{\n\tif (c < 0x80)\n\t\t \n\t\tkbd_put_queue(port, c);\n\telse if (c < 0x800) {\n\t\t \n\t\tkbd_put_queue(port, 0xc0 | (c >> 6));\n\t\tkbd_put_queue(port, 0x80 | (c & 0x3f));\n\t} else {\n\t\t \n\t\tkbd_put_queue(port, 0xe0 | (c >> 12));\n\t\tkbd_put_queue(port, 0x80 | ((c >> 6) & 0x3f));\n\t\tkbd_put_queue(port, 0x80 | (c & 0x3f));\n\t}\n}\n\n \nvoid\nkbd_keycode(struct kbd_data *kbd, unsigned int keycode)\n{\n\tunsigned short keysym;\n\tunsigned char type, value;\n\n\tif (!kbd)\n\t\treturn;\n\n\tif (keycode >= 384)\n\t\tkeysym = kbd->key_maps[5][keycode - 384];\n\telse if (keycode >= 256)\n\t\tkeysym = kbd->key_maps[4][keycode - 256];\n\telse if (keycode >= 128)\n\t\tkeysym = kbd->key_maps[1][keycode - 128];\n\telse\n\t\tkeysym = kbd->key_maps[0][keycode];\n\n\ttype = KTYP(keysym);\n\tif (type >= 0xf0) {\n\t\ttype -= 0xf0;\n\t\tif (type == KT_LETTER)\n\t\t\ttype = KT_LATIN;\n\t\tvalue = KVAL(keysym);\n#ifdef CONFIG_MAGIC_SYSRQ\t        \n\t\tif (kbd->sysrq) {\n\t\t\tif (kbd->sysrq == K(KT_LATIN, '-')) {\n\t\t\t\tkbd->sysrq = 0;\n\t\t\t\thandle_sysrq(value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (value == '-') {\n\t\t\t\tkbd->sysrq = K(KT_LATIN, '-');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\t(*k_handler[KTYP(kbd->sysrq)])(kbd, KVAL(kbd->sysrq));\n\t\t\tkbd->sysrq = 0;\n\t\t} else if ((type == KT_LATIN && value == '^') ||\n\t\t\t   (type == KT_DEAD && ret_diacr[value] == '^')) {\n\t\t\tkbd->sysrq = K(type, value);\n\t\t\treturn;\n\t\t}\n#endif\n\t\t(*k_handler[type])(kbd, value);\n\t} else\n\t\tto_utf8(kbd->port, keysym);\n}\n\n \nstatic int\ndo_kdsk_ioctl(struct kbd_data *kbd, struct kbentry __user *user_kbe,\n\t      int cmd, int perm)\n{\n\tstruct kbentry tmp;\n\tunsigned long kb_index, kb_table;\n\tushort *key_map, val, ov;\n\n\tif (copy_from_user(&tmp, user_kbe, sizeof(struct kbentry)))\n\t\treturn -EFAULT;\n\tkb_index = (unsigned long) tmp.kb_index;\n#if NR_KEYS < 256\n\tif (kb_index >= NR_KEYS)\n\t\treturn -EINVAL;\n#endif\n\tkb_table = (unsigned long) tmp.kb_table;\n#if MAX_NR_KEYMAPS < 256\n\tif (kb_table >= MAX_NR_KEYMAPS)\n\t\treturn -EINVAL;\t\n\tkb_table = array_index_nospec(kb_table , MAX_NR_KEYMAPS);\n#endif\n\n\tswitch (cmd) {\n\tcase KDGKBENT:\n\t\tkey_map = kbd->key_maps[kb_table];\n\t\tif (key_map) {\n\t\t    val = U(key_map[kb_index]);\n\t\t    if (KTYP(val) >= KBD_NR_TYPES)\n\t\t\tval = K_HOLE;\n\t\t} else\n\t\t    val = (kb_index ? K_HOLE : K_NOSUCHMAP);\n\t\treturn put_user(val, &user_kbe->kb_value);\n\tcase KDSKBENT:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (!kb_index && tmp.kb_value == K_NOSUCHMAP) {\n\t\t\t \n\t\t\tkey_map = kbd->key_maps[kb_table];\n\t\t\tif (key_map) {\n\t\t\t    kbd->key_maps[kb_table] = NULL;\n\t\t\t    kfree(key_map);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (KTYP(tmp.kb_value) >= KBD_NR_TYPES)\n\t\t\treturn -EINVAL;\n\t\tif (KVAL(tmp.kb_value) > kbd_max_vals[KTYP(tmp.kb_value)])\n\t\t\treturn -EINVAL;\n\n\t\tif (!(key_map = kbd->key_maps[kb_table])) {\n\t\t\tint j;\n\n\t\t\tkey_map = kmalloc(sizeof(plain_map),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!key_map)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkbd->key_maps[kb_table] = key_map;\n\t\t\tfor (j = 0; j < NR_KEYS; j++)\n\t\t\t\tkey_map[j] = U(K_HOLE);\n\t\t}\n\t\tov = U(key_map[kb_index]);\n\t\tif (tmp.kb_value == ov)\n\t\t\tbreak;\t \n\t\t \n\t\tif (((ov == K_SAK) || (tmp.kb_value == K_SAK)) &&\n\t\t    !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tkey_map[kb_index] = U(tmp.kb_value);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\ndo_kdgkb_ioctl(struct kbd_data *kbd, struct kbsentry __user *u_kbs,\n\t       int cmd, int perm)\n{\n\tunsigned char kb_func;\n\tchar *p;\n\tint len;\n\n\t \n\tif (get_user(kb_func, &u_kbs->kb_func))\n\t\treturn -EFAULT;\n#if MAX_NR_FUNC < 256\n\tif (kb_func >= MAX_NR_FUNC)\n\t\treturn -EINVAL;\n#endif\n\n\tswitch (cmd) {\n\tcase KDGKBSENT:\n\t\tp = kbd->func_table[kb_func];\n\t\tif (p) {\n\t\t\tlen = strlen(p);\n\t\t\tif (len >= sizeof(u_kbs->kb_string))\n\t\t\t\tlen = sizeof(u_kbs->kb_string) - 1;\n\t\t\tif (copy_to_user(u_kbs->kb_string, p, len))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\tlen = 0;\n\t\tif (put_user('\\0', u_kbs->kb_string + len))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase KDSKBSENT:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tp = strndup_user(u_kbs->kb_string, sizeof(u_kbs->kb_string));\n\t\tif (IS_ERR(p))\n\t\t\treturn PTR_ERR(p);\n\t\tkfree(kbd->func_table[kb_func]);\n\t\tkbd->func_table[kb_func] = p;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint kbd_ioctl(struct kbd_data *kbd, unsigned int cmd, unsigned long arg)\n{\n\tstruct tty_struct *tty;\n\tvoid __user *argp;\n\tunsigned int ct;\n\tint perm;\n\n\targp = (void __user *)arg;\n\n\t \n\ttty = tty_port_tty_get(kbd->port);\n\t \n\tperm = current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG);\n\ttty_kref_put(tty);\n\tswitch (cmd) {\n\tcase KDGKBTYPE:\n\t\treturn put_user(KB_101, (char __user *)argp);\n\tcase KDGKBENT:\n\tcase KDSKBENT:\n\t\treturn do_kdsk_ioctl(kbd, argp, cmd, perm);\n\tcase KDGKBSENT:\n\tcase KDSKBSENT:\n\t\treturn do_kdgkb_ioctl(kbd, argp, cmd, perm);\n\tcase KDGKBDIACR:\n\t{\n\t\tstruct kbdiacrs __user *a = argp;\n\t\tstruct kbdiacr diacr;\n\t\tint i;\n\n\t\tif (put_user(kbd->accent_table_size, &a->kb_cnt))\n\t\t\treturn -EFAULT;\n\t\tfor (i = 0; i < kbd->accent_table_size; i++) {\n\t\t\tdiacr.diacr = kbd->accent_table[i].diacr;\n\t\t\tdiacr.base = kbd->accent_table[i].base;\n\t\t\tdiacr.result = kbd->accent_table[i].result;\n\t\t\tif (copy_to_user(a->kbdiacr + i, &diacr, sizeof(struct kbdiacr)))\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase KDGKBDIACRUC:\n\t{\n\t\tstruct kbdiacrsuc __user *a = argp;\n\n\t\tct = kbd->accent_table_size;\n\t\tif (put_user(ct, &a->kb_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(a->kbdiacruc, kbd->accent_table,\n\t\t\t\t ct * sizeof(struct kbdiacruc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase KDSKBDIACR:\n\t{\n\t\tstruct kbdiacrs __user *a = argp;\n\t\tstruct kbdiacr diacr;\n\t\tint i;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ct, &a->kb_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (ct >= MAX_DIACR)\n\t\t\treturn -EINVAL;\n\t\tkbd->accent_table_size = ct;\n\t\tfor (i = 0; i < ct; i++) {\n\t\t\tif (copy_from_user(&diacr, a->kbdiacr + i, sizeof(struct kbdiacr)))\n\t\t\t\treturn -EFAULT;\n\t\t\tkbd->accent_table[i].diacr = diacr.diacr;\n\t\t\tkbd->accent_table[i].base = diacr.base;\n\t\t\tkbd->accent_table[i].result = diacr.result;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase KDSKBDIACRUC:\n\t{\n\t\tstruct kbdiacrsuc __user *a = argp;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ct, &a->kb_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (ct >= MAX_DIACR)\n\t\t\treturn -EINVAL;\n\t\tkbd->accent_table_size = ct;\n\t\tif (copy_from_user(kbd->accent_table, a->kbdiacruc,\n\t\t\t\t   ct * sizeof(struct kbdiacruc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nEXPORT_SYMBOL(kbd_ioctl);\nEXPORT_SYMBOL(kbd_ascebc);\nEXPORT_SYMBOL(kbd_free);\nEXPORT_SYMBOL(kbd_alloc);\nEXPORT_SYMBOL(kbd_keycode);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}