{
  "module_name": "tape_std.c",
  "hash_id": "f482bdf36252d8fdbede4fd78856e3ff3c5cd50e38db0ac106fefa9e5704e752",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/tape_std.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"tape\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/bio.h>\n#include <linux/timer.h>\n\n#include <asm/types.h>\n#include <asm/idals.h>\n#include <asm/ebcdic.h>\n#include <asm/tape390.h>\n\n#define TAPE_DBF_AREA\ttape_core_dbf\n\n#include \"tape.h\"\n#include \"tape_std.h\"\n\n \nstatic void\ntape_std_assign_timeout(struct timer_list *t)\n{\n\tstruct tape_request *\trequest = from_timer(request, t, timer);\n\tstruct tape_device *\tdevice = request->device;\n\tint rc;\n\n\tBUG_ON(!device);\n\n\tDBF_EVENT(3, \"%08x: Assignment timeout. Device busy.\\n\",\n\t\t\tdevice->cdev_id);\n\trc = tape_cancel_io(device, request);\n\tif(rc)\n\t\tDBF_EVENT(3, \"(%08x): Assign timeout: Cancel failed with rc = \"\n\t\t\t  \"%i\\n\", device->cdev_id, rc);\n}\n\nint\ntape_std_assign(struct tape_device *device)\n{\n\tint                  rc;\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(2, 11);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\n\trequest->op = TO_ASSIGN;\n\ttape_ccw_cc(request->cpaddr, ASSIGN, 11, request->cpdata);\n\ttape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\n\n\t \n\ttimer_setup(&request->timer, tape_std_assign_timeout, 0);\n\tmod_timer(&request->timer, jiffies + msecs_to_jiffies(2000));\n\n\trc = tape_do_io_interruptible(device, request);\n\n\tdel_timer_sync(&request->timer);\n\n\tif (rc != 0) {\n\t\tDBF_EVENT(3, \"%08x: assign failed - device might be busy\\n\",\n\t\t\tdevice->cdev_id);\n\t} else {\n\t\tDBF_EVENT(3, \"%08x: Tape assigned\\n\", device->cdev_id);\n\t}\n\ttape_free_request(request);\n\treturn rc;\n}\n\n \nint\ntape_std_unassign (struct tape_device *device)\n{\n\tint                  rc;\n\tstruct tape_request *request;\n\n\tif (device->tape_state == TS_NOT_OPER) {\n\t\tDBF_EVENT(3, \"(%08x): Can't unassign device\\n\",\n\t\t\tdevice->cdev_id);\n\t\treturn -EIO;\n\t}\n\n\trequest = tape_alloc_request(2, 11);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\n\trequest->op = TO_UNASSIGN;\n\ttape_ccw_cc(request->cpaddr, UNASSIGN, 11, request->cpdata);\n\ttape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\n\n\tif ((rc = tape_do_io(device, request)) != 0) {\n\t\tDBF_EVENT(3, \"%08x: Unassign failed\\n\", device->cdev_id);\n\t} else {\n\t\tDBF_EVENT(3, \"%08x: Tape unassigned\\n\", device->cdev_id);\n\t}\n\ttape_free_request(request);\n\treturn rc;\n}\n\n \nint\ntape_std_display(struct tape_device *device, struct display_struct *disp)\n{\n\tstruct tape_request *request;\n\tint rc;\n\n\trequest = tape_alloc_request(2, 17);\n\tif (IS_ERR(request)) {\n\t\tDBF_EVENT(3, \"TAPE: load display failed\\n\");\n\t\treturn PTR_ERR(request);\n\t}\n\trequest->op = TO_DIS;\n\n\t*(unsigned char *) request->cpdata = disp->cntrl;\n\tDBF_EVENT(5, \"TAPE: display cntrl=%04x\\n\", disp->cntrl);\n\tmemcpy(((unsigned char *) request->cpdata) + 1, disp->message1, 8);\n\tmemcpy(((unsigned char *) request->cpdata) + 9, disp->message2, 8);\n\tASCEBC(((unsigned char*) request->cpdata) + 1, 16);\n\n\ttape_ccw_cc(request->cpaddr, LOAD_DISPLAY, 17, request->cpdata);\n\ttape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\n\n\trc = tape_do_io_interruptible(device, request);\n\ttape_free_request(request);\n\treturn rc;\n}\n\n \nint\ntape_std_read_block_id(struct tape_device *device, __u64 *id)\n{\n\tstruct tape_request *request;\n\tint rc;\n\n\trequest = tape_alloc_request(3, 8);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_RBI;\n\t \n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_cc(request->cpaddr + 1, READ_BLOCK_ID, 8, request->cpdata);\n\ttape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\n\t \n\trc = tape_do_io(device, request);\n\tif (rc == 0)\n\t\t \n\t\t*id = *(__u64 *) request->cpdata;\n\ttape_free_request(request);\n\treturn rc;\n}\n\nint\ntape_std_terminate_write(struct tape_device *device)\n{\n\tint rc;\n\n\tif(device->required_tapemarks == 0)\n\t\treturn 0;\n\n\tDBF_LH(5, \"tape%d: terminate write %dxEOF\\n\", device->first_minor,\n\t\tdevice->required_tapemarks);\n\n\trc = tape_mtop(device, MTWEOF, device->required_tapemarks);\n\tif (rc)\n\t\treturn rc;\n\n\tdevice->required_tapemarks = 0;\n\treturn tape_mtop(device, MTBSR, 1);\n}\n\n \nint\ntape_std_mtload(struct tape_device *device, int count)\n{\n\treturn wait_event_interruptible(device->state_change_wq,\n\t\t(device->medium_state == MS_LOADED));\n}\n\n \nint\ntape_std_mtsetblk(struct tape_device *device, int count)\n{\n\tstruct idal_buffer *new;\n\n\tDBF_LH(6, \"tape_std_mtsetblk(%d)\\n\", count);\n\tif (count <= 0) {\n\t\t \n\t\tdevice->char_data.block_size = 0;\n\t\treturn 0;\n\t}\n\tif (device->char_data.idal_buf != NULL &&\n\t    device->char_data.idal_buf->size == count)\n\t\t \n\t\treturn 0;\n\n\tif (count > MAX_BLOCKSIZE) {\n\t\tDBF_EVENT(3, \"Invalid block size (%d > %d) given.\\n\",\n\t\t\tcount, MAX_BLOCKSIZE);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnew = idal_buffer_alloc(count, 0);\n\tif (IS_ERR(new))\n\t\treturn -ENOMEM;\n\tif (device->char_data.idal_buf != NULL)\n\t\tidal_buffer_free(device->char_data.idal_buf);\n\tdevice->char_data.idal_buf = new;\n\tdevice->char_data.block_size = count;\n\n\tDBF_LH(6, \"new blocksize is %d\\n\", device->char_data.block_size);\n\n\treturn 0;\n}\n\n \nint\ntape_std_mtreset(struct tape_device *device, int count)\n{\n\tDBF_EVENT(6, \"TCHAR:devreset:\\n\");\n\tdevice->char_data.block_size = 0;\n\treturn 0;\n}\n\n \nint\ntape_std_mtfsf(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\tstruct ccw1 *ccw;\n\n\trequest = tape_alloc_request(mt_count + 2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_FSF;\n\t \n\tccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\n\t\t\t  device->modeset_byte);\n\tccw = tape_ccw_repeat(ccw, FORSPACEFILE, mt_count);\n\tccw = tape_ccw_end(ccw, NOP, 0, NULL);\n\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nint\ntape_std_mtfsr(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\trequest = tape_alloc_request(mt_count + 2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_FSB;\n\t \n\tccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\n\t\t\t  device->modeset_byte);\n\tccw = tape_ccw_repeat(ccw, FORSPACEBLOCK, mt_count);\n\tccw = tape_ccw_end(ccw, NOP, 0, NULL);\n\n\t \n\trc = tape_do_io(device, request);\n\tif (rc == 0 && request->rescnt > 0) {\n\t\tDBF_LH(3, \"FSR over tapemark\\n\");\n\t\trc = 1;\n\t}\n\ttape_free_request(request);\n\n\treturn rc;\n}\n\n \nint\ntape_std_mtbsr(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\trequest = tape_alloc_request(mt_count + 2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_BSB;\n\t \n\tccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\n\t\t\t  device->modeset_byte);\n\tccw = tape_ccw_repeat(ccw, BACKSPACEBLOCK, mt_count);\n\tccw = tape_ccw_end(ccw, NOP, 0, NULL);\n\n\t \n\trc = tape_do_io(device, request);\n\tif (rc == 0 && request->rescnt > 0) {\n\t\tDBF_LH(3, \"BSR over tapemark\\n\");\n\t\trc = 1;\n\t}\n\ttape_free_request(request);\n\n\treturn rc;\n}\n\n \nint\ntape_std_mtweof(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\tstruct ccw1 *ccw;\n\n\trequest = tape_alloc_request(mt_count + 2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_WTM;\n\t \n\tccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\n\t\t\t  device->modeset_byte);\n\tccw = tape_ccw_repeat(ccw, WRITETAPEMARK, mt_count);\n\tccw = tape_ccw_end(ccw, NOP, 0, NULL);\n\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nint\ntape_std_mtbsfm(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\tstruct ccw1 *ccw;\n\n\trequest = tape_alloc_request(mt_count + 2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_BSF;\n\t \n\tccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\n\t\t\t  device->modeset_byte);\n\tccw = tape_ccw_repeat(ccw, BACKSPACEFILE, mt_count);\n\tccw = tape_ccw_end(ccw, NOP, 0, NULL);\n\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nint\ntape_std_mtbsf(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\trequest = tape_alloc_request(mt_count + 2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_BSF;\n\t \n\tccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\n\t\t\t  device->modeset_byte);\n\tccw = tape_ccw_repeat(ccw, BACKSPACEFILE, mt_count);\n\tccw = tape_ccw_end(ccw, NOP, 0, NULL);\n\t \n\trc = tape_do_io_free(device, request);\n\tif (rc == 0) {\n\t\trc = tape_mtop(device, MTFSR, 1);\n\t\tif (rc > 0)\n\t\t\trc = 0;\n\t}\n\treturn rc;\n}\n\n \nint\ntape_std_mtfsfm(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\trequest = tape_alloc_request(mt_count + 2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_FSF;\n\t \n\tccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\n\t\t\t  device->modeset_byte);\n\tccw = tape_ccw_repeat(ccw, FORSPACEFILE, mt_count);\n\tccw = tape_ccw_end(ccw, NOP, 0, NULL);\n\t \n\trc = tape_do_io_free(device, request);\n\tif (rc == 0) {\n\t\trc = tape_mtop(device, MTBSR, 1);\n\t\tif (rc > 0)\n\t\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\n \nint\ntape_std_mtrew(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(3, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_REW;\n\t \n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\n\t\t    device->modeset_byte);\n\ttape_ccw_cc(request->cpaddr + 1, REWIND, 0, NULL);\n\ttape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\n\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nint\ntape_std_mtoffl(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(3, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_RUN;\n\t \n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_cc(request->cpaddr + 1, REWIND_UNLOAD, 0, NULL);\n\ttape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\n\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nint\ntape_std_mtnop(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_NOP;\n\t \n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nint\ntape_std_mteom(struct tape_device *device, int mt_count)\n{\n\tint rc;\n\n\t \n\tif ((rc = tape_mtop(device, MTREW, 1)) < 0)\n\t\treturn rc;\n\n\t \n\tdo {\n\t\tif ((rc = tape_mtop(device, MTFSF, 1)) < 0)\n\t\t\treturn rc;\n\t\tif ((rc = tape_mtop(device, MTFSR, 1)) < 0)\n\t\t\treturn rc;\n\t} while (rc == 0);\n\n\treturn tape_mtop(device, MTBSR, 1);\n}\n\n \nint\ntape_std_mtreten(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(4, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_FSF;\n\t \n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_cc(request->cpaddr + 1,FORSPACEFILE, 0, NULL);\n\ttape_ccw_cc(request->cpaddr + 2, NOP, 0, NULL);\n\ttape_ccw_end(request->cpaddr + 3, CCW_CMD_TIC, 0, request->cpaddr);\n\t \n\ttape_do_io_interruptible(device, request);\n\ttape_free_request(request);\n\treturn tape_mtop(device, MTREW, 1);\n}\n\n \nint\ntape_std_mterase(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(6, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_DSE;\n\t \n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_cc(request->cpaddr + 1, REWIND, 0, NULL);\n\ttape_ccw_cc(request->cpaddr + 2, ERASE_GAP, 0, NULL);\n\ttape_ccw_cc(request->cpaddr + 3, DATA_SEC_ERASE, 0, NULL);\n\ttape_ccw_cc(request->cpaddr + 4, REWIND, 0, NULL);\n\ttape_ccw_end(request->cpaddr + 5, NOP, 0, NULL);\n\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nint\ntape_std_mtunload(struct tape_device *device, int mt_count)\n{\n\treturn tape_mtop(device, MTOFFL, mt_count);\n}\n\n \nint\ntape_std_mtcompression(struct tape_device *device, int mt_count)\n{\n\tstruct tape_request *request;\n\n\tif (mt_count < 0 || mt_count > 1) {\n\t\tDBF_EXCEPTION(6, \"xcom parm\\n\");\n\t\treturn -EINVAL;\n\t}\n\trequest = tape_alloc_request(2, 0);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trequest->op = TO_NOP;\n\t \n\tif (mt_count == 0)\n\t\t*device->modeset_byte &= ~0x08;\n\telse\n\t\t*device->modeset_byte |= 0x08;\n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\n\t \n\treturn tape_do_io_free(device, request);\n}\n\n \nstruct tape_request *\ntape_std_read_block(struct tape_device *device, size_t count)\n{\n\tstruct tape_request *request;\n\n\t \n\trequest = tape_alloc_request(4, 0);\n\tif (IS_ERR(request)) {\n\t\tDBF_EXCEPTION(6, \"xrbl fail\");\n\t\treturn request;\n\t}\n\trequest->op = TO_RFO;\n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_end_idal(request->cpaddr + 1, READ_FORWARD,\n\t\t\t  device->char_data.idal_buf);\n\tDBF_EVENT(6, \"xrbl ccwg\\n\");\n\treturn request;\n}\n\n \nvoid\ntape_std_read_backward(struct tape_device *device, struct tape_request *request)\n{\n\t \n\trequest->op = TO_RBA;\n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_cc_idal(request->cpaddr + 1, READ_BACKWARD,\n\t\t\t device->char_data.idal_buf);\n\ttape_ccw_cc(request->cpaddr + 2, FORSPACEBLOCK, 0, NULL);\n\ttape_ccw_end(request->cpaddr + 3, NOP, 0, NULL);\n\tDBF_EVENT(6, \"xrop ccwg\");}\n\n \nstruct tape_request *\ntape_std_write_block(struct tape_device *device, size_t count)\n{\n\tstruct tape_request *request;\n\n\trequest = tape_alloc_request(2, 0);\n\tif (IS_ERR(request)) {\n\t\tDBF_EXCEPTION(6, \"xwbl fail\\n\");\n\t\treturn request;\n\t}\n\trequest->op = TO_WRI;\n\ttape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\n\ttape_ccw_end_idal(request->cpaddr + 1, WRITE_CMD,\n\t\t\t  device->char_data.idal_buf);\n\tDBF_EVENT(6, \"xwbl ccwg\\n\");\n\treturn request;\n}\n\n \nvoid\ntape_std_process_eov(struct tape_device *device)\n{\n\t \n\tif (tape_mtop(device, MTBSR, 1) == 0 &&\n\t    tape_mtop(device, MTWEOF, 1) == 0) {\n\t\ttape_mtop(device, MTBSR, 1);\n\t}\n}\n\nEXPORT_SYMBOL(tape_std_assign);\nEXPORT_SYMBOL(tape_std_unassign);\nEXPORT_SYMBOL(tape_std_display);\nEXPORT_SYMBOL(tape_std_read_block_id);\nEXPORT_SYMBOL(tape_std_mtload);\nEXPORT_SYMBOL(tape_std_mtsetblk);\nEXPORT_SYMBOL(tape_std_mtreset);\nEXPORT_SYMBOL(tape_std_mtfsf);\nEXPORT_SYMBOL(tape_std_mtfsr);\nEXPORT_SYMBOL(tape_std_mtbsr);\nEXPORT_SYMBOL(tape_std_mtweof);\nEXPORT_SYMBOL(tape_std_mtbsfm);\nEXPORT_SYMBOL(tape_std_mtbsf);\nEXPORT_SYMBOL(tape_std_mtfsfm);\nEXPORT_SYMBOL(tape_std_mtrew);\nEXPORT_SYMBOL(tape_std_mtoffl);\nEXPORT_SYMBOL(tape_std_mtnop);\nEXPORT_SYMBOL(tape_std_mteom);\nEXPORT_SYMBOL(tape_std_mtreten);\nEXPORT_SYMBOL(tape_std_mterase);\nEXPORT_SYMBOL(tape_std_mtunload);\nEXPORT_SYMBOL(tape_std_mtcompression);\nEXPORT_SYMBOL(tape_std_read_block);\nEXPORT_SYMBOL(tape_std_read_backward);\nEXPORT_SYMBOL(tape_std_write_block);\nEXPORT_SYMBOL(tape_std_process_eov);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}