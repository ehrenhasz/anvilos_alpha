{
  "module_name": "raw3270.c",
  "hash_id": "ac3ab359ce3b862d86d0b6608fdcd5c3c57b5d217b383b8b44d10f31daaf0cdf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/raw3270.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n#include <asm/ebcdic.h>\n#include <asm/diag.h>\n\n#include \"raw3270.h\"\n\n#include <linux/major.h>\n#include <linux/kdev_t.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n\nstruct class *class3270;\nEXPORT_SYMBOL(class3270);\n\n \nstruct raw3270 {\n\tstruct list_head list;\n\tstruct ccw_device *cdev;\n\tint minor;\n\n\tint model, rows, cols;\n\tint old_model, old_rows, old_cols;\n\tunsigned int state;\n\tunsigned long flags;\n\n\tstruct list_head req_queue;\t \n\tstruct list_head view_list;\t \n\tstruct raw3270_view *view;\t \n\n\tstruct timer_list timer;\t \n\n\tunsigned char *ascebc;\t\t \n\n\tstruct raw3270_view init_view;\n\tstruct raw3270_request init_reset;\n\tstruct raw3270_request init_readpart;\n\tstruct raw3270_request init_readmod;\n\tunsigned char init_data[256];\n\tstruct work_struct resize_work;\n};\n\n \n#define RAW3270_STATE_INIT\t0\t \n#define RAW3270_STATE_RESET\t1\t \n#define RAW3270_STATE_W4ATTN\t2\t \n#define RAW3270_STATE_READMOD\t3\t \n#define RAW3270_STATE_READY\t4\t \n\n \n#define RAW3270_FLAGS_14BITADDR\t0\t \n#define RAW3270_FLAGS_BUSY\t1\t \n#define RAW3270_FLAGS_CONSOLE\t2\t \n\n \nstatic DEFINE_MUTEX(raw3270_mutex);\n\n \nstatic LIST_HEAD(raw3270_devices);\n\n \nstatic int raw3270_registered;\n\n \nstatic bool tubxcorrect;\nmodule_param(tubxcorrect, bool, 0);\n\n \nDECLARE_WAIT_QUEUE_HEAD(raw3270_wait_queue);\nEXPORT_SYMBOL(raw3270_wait_queue);\n\nstatic void __raw3270_disconnect(struct raw3270 *rp);\n\n \nstatic unsigned char raw3270_ebcgraf[64] =\t{\n\t0x40, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n\t0xc8, 0xc9, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n\t0x50, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n\t0xd8, 0xd9, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n\t0x60, 0x61, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n\t0xe8, 0xe9, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n\t0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n\t0xf8, 0xf9, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f\n};\n\nstatic inline int raw3270_state_ready(struct raw3270 *rp)\n{\n\treturn rp->state == RAW3270_STATE_READY;\n}\n\nvoid raw3270_buffer_address(struct raw3270 *rp, char *cp, int x, int y)\n{\n\tint addr;\n\n\tif (x < 0)\n\t\tx = max_t(int, 0, rp->view->cols + x);\n\tif (y < 0)\n\t\ty = max_t(int, 0, rp->view->rows + y);\n\taddr = (y * rp->view->cols) + x;\n\tif (test_bit(RAW3270_FLAGS_14BITADDR, &rp->flags)) {\n\t\tcp[0] = (addr >> 8) & 0x3f;\n\t\tcp[1] = addr & 0xff;\n\t} else {\n\t\tcp[0] = raw3270_ebcgraf[(addr >> 6) & 0x3f];\n\t\tcp[1] = raw3270_ebcgraf[addr & 0x3f];\n\t}\n}\nEXPORT_SYMBOL(raw3270_buffer_address);\n\n \nstruct raw3270_request *raw3270_request_alloc(size_t size)\n{\n\tstruct raw3270_request *rq;\n\n\t \n\trq = kzalloc(sizeof(*rq), GFP_KERNEL | GFP_DMA);\n\tif (!rq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (size > 0) {\n\t\trq->buffer = kmalloc(size, GFP_KERNEL | GFP_DMA);\n\t\tif (!rq->buffer) {\n\t\t\tkfree(rq);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\trq->size = size;\n\tINIT_LIST_HEAD(&rq->list);\n\n\t \n\trq->ccw.cda = __pa(rq->buffer);\n\trq->ccw.flags = CCW_FLAG_SLI;\n\n\treturn rq;\n}\nEXPORT_SYMBOL(raw3270_request_alloc);\n\n \nvoid raw3270_request_free(struct raw3270_request *rq)\n{\n\tkfree(rq->buffer);\n\tkfree(rq);\n}\nEXPORT_SYMBOL(raw3270_request_free);\n\n \nint raw3270_request_reset(struct raw3270_request *rq)\n{\n\tif (WARN_ON_ONCE(!list_empty(&rq->list)))\n\t\treturn -EBUSY;\n\trq->ccw.cmd_code = 0;\n\trq->ccw.count = 0;\n\trq->ccw.cda = __pa(rq->buffer);\n\trq->ccw.flags = CCW_FLAG_SLI;\n\trq->rescnt = 0;\n\trq->rc = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL(raw3270_request_reset);\n\n \nvoid raw3270_request_set_cmd(struct raw3270_request *rq, u8 cmd)\n{\n\trq->ccw.cmd_code = cmd;\n}\nEXPORT_SYMBOL(raw3270_request_set_cmd);\n\n \nint raw3270_request_add_data(struct raw3270_request *rq, void *data, size_t size)\n{\n\tif (size + rq->ccw.count > rq->size)\n\t\treturn -E2BIG;\n\tmemcpy(rq->buffer + rq->ccw.count, data, size);\n\trq->ccw.count += size;\n\treturn 0;\n}\nEXPORT_SYMBOL(raw3270_request_add_data);\n\n \nvoid raw3270_request_set_data(struct raw3270_request *rq, void *data, size_t size)\n{\n\trq->ccw.cda = __pa(data);\n\trq->ccw.count = size;\n}\nEXPORT_SYMBOL(raw3270_request_set_data);\n\n \nvoid raw3270_request_set_idal(struct raw3270_request *rq, struct idal_buffer *ib)\n{\n\trq->ccw.cda = __pa(ib->data);\n\trq->ccw.count = ib->size;\n\trq->ccw.flags |= CCW_FLAG_IDA;\n}\nEXPORT_SYMBOL(raw3270_request_set_idal);\n\n \nstatic int __raw3270_start(struct raw3270 *rp, struct raw3270_view *view,\n\t\t\t   struct raw3270_request *rq)\n{\n\trq->view = view;\n\traw3270_get_view(view);\n\tif (list_empty(&rp->req_queue) &&\n\t    !test_bit(RAW3270_FLAGS_BUSY, &rp->flags)) {\n\t\t \n\t\trq->rc = ccw_device_start(rp->cdev, &rq->ccw,\n\t\t\t\t\t  (unsigned long)rq, 0, 0);\n\t\tif (rq->rc) {\n\t\t\traw3270_put_view(view);\n\t\t\treturn rq->rc;\n\t\t}\n\t}\n\tlist_add_tail(&rq->list, &rp->req_queue);\n\treturn 0;\n}\n\nint raw3270_view_active(struct raw3270_view *view)\n{\n\tstruct raw3270 *rp = view->dev;\n\n\treturn rp && rp->view == view;\n}\n\nint raw3270_start(struct raw3270_view *view, struct raw3270_request *rq)\n{\n\tunsigned long flags;\n\tstruct raw3270 *rp;\n\tint rc;\n\n\tspin_lock_irqsave(get_ccwdev_lock(view->dev->cdev), flags);\n\trp = view->dev;\n\tif (!rp || rp->view != view)\n\t\trc = -EACCES;\n\telse if (!raw3270_state_ready(rp))\n\t\trc = -EBUSY;\n\telse\n\t\trc =  __raw3270_start(rp, view, rq);\n\tspin_unlock_irqrestore(get_ccwdev_lock(view->dev->cdev), flags);\n\treturn rc;\n}\nEXPORT_SYMBOL(raw3270_start);\n\nint raw3270_start_request(struct raw3270_view *view, struct raw3270_request *rq,\n\t\t\t  int cmd, void *data, size_t len)\n{\n\tint rc;\n\n\trc = raw3270_request_reset(rq);\n\tif (rc)\n\t\treturn rc;\n\traw3270_request_set_cmd(rq, cmd);\n\trc = raw3270_request_add_data(rq, data, len);\n\tif (rc)\n\t\treturn rc;\n\treturn raw3270_start(view, rq);\n}\nEXPORT_SYMBOL(raw3270_start_request);\n\nint raw3270_start_locked(struct raw3270_view *view, struct raw3270_request *rq)\n{\n\tstruct raw3270 *rp;\n\tint rc;\n\n\trp = view->dev;\n\tif (!rp || rp->view != view)\n\t\trc = -EACCES;\n\telse if (!raw3270_state_ready(rp))\n\t\trc = -EBUSY;\n\telse\n\t\trc =  __raw3270_start(rp, view, rq);\n\treturn rc;\n}\nEXPORT_SYMBOL(raw3270_start_locked);\n\nint raw3270_start_irq(struct raw3270_view *view, struct raw3270_request *rq)\n{\n\tstruct raw3270 *rp;\n\n\trp = view->dev;\n\trq->view = view;\n\traw3270_get_view(view);\n\tlist_add_tail(&rq->list, &rp->req_queue);\n\treturn 0;\n}\nEXPORT_SYMBOL(raw3270_start_irq);\n\n \nstatic void raw3270_irq(struct ccw_device *cdev, unsigned long intparm, struct irb *irb)\n{\n\tstruct raw3270 *rp;\n\tstruct raw3270_view *view;\n\tstruct raw3270_request *rq;\n\n\trp = dev_get_drvdata(&cdev->dev);\n\tif (!rp)\n\t\treturn;\n\trq = (struct raw3270_request *)intparm;\n\tview = rq ? rq->view : rp->view;\n\n\tif (!IS_ERR(irb)) {\n\t\t \n\t\tif (irb->scsw.cmd.dstat & DEV_STAT_DEV_END)\n\t\t\tclear_bit(RAW3270_FLAGS_BUSY, &rp->flags);\n\t\tif (irb->scsw.cmd.dstat == (DEV_STAT_CHN_END |\n\t\t\t\t\t    DEV_STAT_DEV_END |\n\t\t\t\t\t    DEV_STAT_UNIT_EXCEP))\n\t\t\tset_bit(RAW3270_FLAGS_BUSY, &rp->flags);\n\t\t \n\t\tif ((irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) &&\n\t\t    (irb->ecw[0] & SNS0_INTERVENTION_REQ)) {\n\t\t\tset_bit(RAW3270_FLAGS_BUSY, &rp->flags);\n\t\t\tif (rp->state > RAW3270_STATE_RESET)\n\t\t\t\t__raw3270_disconnect(rp);\n\t\t}\n\t\t \n\t\tif (view)\n\t\t\tview->fn->intv(view, rq, irb);\n\t}\n\n\tif (test_bit(RAW3270_FLAGS_BUSY, &rp->flags))\n\t\t \n\t\treturn;\n\n\tif (rq && !list_empty(&rq->list)) {\n\t\t \n\t\tlist_del_init(&rq->list);\n\t\tif (rq->callback)\n\t\t\trq->callback(rq, rq->callback_data);\n\t\t \n\t\traw3270_put_view(view);\n\t}\n\n\t \n\twhile (!list_empty(&rp->req_queue)) {\n\t\trq = list_entry(rp->req_queue.next, struct raw3270_request, list);\n\t\trq->rc = ccw_device_start(rp->cdev, &rq->ccw,\n\t\t\t\t\t  (unsigned long)rq, 0, 0);\n\t\tif (rq->rc == 0)\n\t\t\tbreak;\n\t\t \n\t\tlist_del_init(&rq->list);\n\t\tif (rq->callback)\n\t\t\trq->callback(rq, rq->callback_data);\n\t\t \n\t\traw3270_put_view(view);\n\t}\n}\n\n \nstruct raw3270_ua {\t \n\tstruct {\t \n\t\tshort l;\t \n\t\tchar  sfid;\t \n\t\tchar  qcode;\t \n\t\tchar  flags0;\n\t\tchar  flags1;\n\t\tshort w;\t \n\t\tshort h;\t \n\t\tchar  units;\t \n\t\tint   xr;\n\t\tint   yr;\n\t\tchar  aw;\n\t\tchar  ah;\n\t\tshort buffsz;\t \n\t\tchar  xmin;\n\t\tchar  ymin;\n\t\tchar  xmax;\n\t\tchar  ymax;\n\t} __packed uab;\n\tstruct {\t \n\t\tchar  l;\t \n\t\tchar  sdpid;\t \n\t\tchar  res;\n\t\tchar  auaid;\t \n\t\tshort wauai;\t \n\t\tshort hauai;\t \n\t\tchar  auaunits;\t \n\t\tint   auaxr;\n\t\tint   auayr;\n\t\tchar  awauai;\n\t\tchar  ahauai;\n\t} __packed aua;\n} __packed;\n\nstatic void raw3270_size_device_vm(struct raw3270 *rp)\n{\n\tint rc, model;\n\tstruct ccw_dev_id dev_id;\n\tstruct diag210 diag_data;\n\tstruct diag8c diag8c_data;\n\n\tccw_device_get_id(rp->cdev, &dev_id);\n\trc = diag8c(&diag8c_data, &dev_id);\n\tif (!rc) {\n\t\trp->model = 2;\n\t\trp->rows = diag8c_data.height;\n\t\trp->cols = diag8c_data.width;\n\t\tif (diag8c_data.flags & 1)\n\t\t\tset_bit(RAW3270_FLAGS_14BITADDR, &rp->flags);\n\t\treturn;\n\t}\n\n\tdiag_data.vrdcdvno = dev_id.devno;\n\tdiag_data.vrdclen = sizeof(struct diag210);\n\trc = diag210(&diag_data);\n\tmodel = diag_data.vrdccrmd;\n\t \n\tif (rc || model < 2 || model > 5)\n\t\tmodel = 2;\n\tswitch (model) {\n\tcase 2:\n\t\trp->model = model;\n\t\trp->rows = 24;\n\t\trp->cols = 80;\n\t\tbreak;\n\tcase 3:\n\t\trp->model = model;\n\t\trp->rows = 32;\n\t\trp->cols = 80;\n\t\tbreak;\n\tcase 4:\n\t\trp->model = model;\n\t\trp->rows = 43;\n\t\trp->cols = 80;\n\t\tbreak;\n\tcase 5:\n\t\trp->model = model;\n\t\trp->rows = 27;\n\t\trp->cols = 132;\n\t\tbreak;\n\t}\n}\n\nstatic void raw3270_size_device(struct raw3270 *rp, char *init_data)\n{\n\tstruct raw3270_ua *uap;\n\n\t \n\tuap = (struct raw3270_ua *)(init_data + 1);\n\t \n\tif (init_data[0] != 0x88 || uap->uab.qcode != 0x81) {\n\t\t \n\t\trp->model = 2;\n\t\trp->rows = 24;\n\t\trp->cols = 80;\n\t\treturn;\n\t}\n\t \n\trp->rows = uap->uab.h;\n\trp->cols = uap->uab.w;\n\t \n\tif ((uap->uab.flags0 & 0x0d) == 0x01)\n\t\tset_bit(RAW3270_FLAGS_14BITADDR, &rp->flags);\n\t \n\tif (uap->uab.l == sizeof(struct raw3270_ua) &&\n\t    uap->aua.sdpid == 0x02) {\n\t\trp->rows = uap->aua.hauai;\n\t\trp->cols = uap->aua.wauai;\n\t}\n\t \n\trp->model = 0;\n\tif (rp->rows == 24 && rp->cols == 80)\n\t\trp->model = 2;\n\tif (rp->rows == 32 && rp->cols == 80)\n\t\trp->model = 3;\n\tif (rp->rows == 43 && rp->cols == 80)\n\t\trp->model = 4;\n\tif (rp->rows == 27 && rp->cols == 132)\n\t\trp->model = 5;\n}\n\nstatic void raw3270_resize_work(struct work_struct *work)\n{\n\tstruct raw3270 *rp = container_of(work, struct raw3270, resize_work);\n\tstruct raw3270_view *view;\n\n\t \n\tlist_for_each_entry(view, &rp->view_list, list) {\n\t\tif (view->fn->resize)\n\t\t\tview->fn->resize(view, rp->model, rp->rows, rp->cols,\n\t\t\t\t\t rp->old_model, rp->old_rows, rp->old_cols);\n\t}\n\trp->old_cols = rp->cols;\n\trp->old_rows = rp->rows;\n\trp->old_model = rp->model;\n\t \n\tlist_for_each_entry(view, &rp->view_list, list) {\n\t\trp->view = view;\n\t\tif (view->fn->activate(view) == 0)\n\t\t\tbreak;\n\t\trp->view = NULL;\n\t}\n}\n\nstatic void raw3270_size_device_done(struct raw3270 *rp)\n{\n\trp->view = NULL;\n\trp->state = RAW3270_STATE_READY;\n\tschedule_work(&rp->resize_work);\n}\n\nvoid raw3270_read_modified_cb(struct raw3270_request *rq, void *data)\n{\n\tstruct raw3270 *rp = rq->view->dev;\n\n\traw3270_size_device(rp, data);\n\traw3270_size_device_done(rp);\n}\nEXPORT_SYMBOL(raw3270_read_modified_cb);\n\nstatic void raw3270_read_modified(struct raw3270 *rp)\n{\n\tif (rp->state != RAW3270_STATE_W4ATTN)\n\t\treturn;\n\t \n\tmemset(&rp->init_readmod, 0, sizeof(rp->init_readmod));\n\tmemset(&rp->init_data, 0, sizeof(rp->init_data));\n\trp->init_readmod.ccw.cmd_code = TC_READMOD;\n\trp->init_readmod.ccw.flags = CCW_FLAG_SLI;\n\trp->init_readmod.ccw.count = sizeof(rp->init_data);\n\trp->init_readmod.ccw.cda = (__u32)__pa(rp->init_data);\n\trp->init_readmod.callback = raw3270_read_modified_cb;\n\trp->init_readmod.callback_data = rp->init_data;\n\trp->state = RAW3270_STATE_READMOD;\n\traw3270_start_irq(&rp->init_view, &rp->init_readmod);\n}\n\nstatic void raw3270_writesf_readpart(struct raw3270 *rp)\n{\n\tstatic const unsigned char wbuf[] = {\n\t\t0x00, 0x07, 0x01, 0xff, 0x03, 0x00, 0x81\n\t};\n\n\t \n\tmemset(&rp->init_readpart, 0, sizeof(rp->init_readpart));\n\tmemset(&rp->init_data, 0, sizeof(rp->init_data));\n\tmemcpy(&rp->init_data, wbuf, sizeof(wbuf));\n\trp->init_readpart.ccw.cmd_code = TC_WRITESF;\n\trp->init_readpart.ccw.flags = CCW_FLAG_SLI;\n\trp->init_readpart.ccw.count = sizeof(wbuf);\n\trp->init_readpart.ccw.cda = (__u32)__pa(&rp->init_data);\n\trp->state = RAW3270_STATE_W4ATTN;\n\traw3270_start_irq(&rp->init_view, &rp->init_readpart);\n}\n\n \nstatic void raw3270_reset_device_cb(struct raw3270_request *rq, void *data)\n{\n\tstruct raw3270 *rp = rq->view->dev;\n\n\tif (rp->state != RAW3270_STATE_RESET)\n\t\treturn;\n\tif (rq->rc) {\n\t\t \n\t\trp->state = RAW3270_STATE_INIT;\n\t} else if (MACHINE_IS_VM) {\n\t\traw3270_size_device_vm(rp);\n\t\traw3270_size_device_done(rp);\n\t} else {\n\t\traw3270_writesf_readpart(rp);\n\t}\n\tmemset(&rp->init_reset, 0, sizeof(rp->init_reset));\n}\n\nstatic int __raw3270_reset_device(struct raw3270 *rp)\n{\n\tint rc;\n\n\t \n\tif (rp->init_reset.view)\n\t\treturn -EBUSY;\n\t \n\trp->init_data[0] = TW_KR;\n\trp->init_reset.ccw.cmd_code = TC_EWRITEA;\n\trp->init_reset.ccw.flags = CCW_FLAG_SLI;\n\trp->init_reset.ccw.count = 1;\n\trp->init_reset.ccw.cda = (__u32)__pa(rp->init_data);\n\trp->init_reset.callback = raw3270_reset_device_cb;\n\trc = __raw3270_start(rp, &rp->init_view, &rp->init_reset);\n\tif (rc == 0 && rp->state == RAW3270_STATE_INIT)\n\t\trp->state = RAW3270_STATE_RESET;\n\treturn rc;\n}\n\nstatic int raw3270_reset_device(struct raw3270 *rp)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\n\trc = __raw3270_reset_device(rp);\n\tspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\n\treturn rc;\n}\n\nint raw3270_reset(struct raw3270_view *view)\n{\n\tstruct raw3270 *rp;\n\tint rc;\n\n\trp = view->dev;\n\tif (!rp || rp->view != view)\n\t\trc = -EACCES;\n\telse if (!raw3270_state_ready(rp))\n\t\trc = -EBUSY;\n\telse\n\t\trc = raw3270_reset_device(view->dev);\n\treturn rc;\n}\nEXPORT_SYMBOL(raw3270_reset);\n\nstatic void __raw3270_disconnect(struct raw3270 *rp)\n{\n\tstruct raw3270_request *rq;\n\tstruct raw3270_view *view;\n\n\trp->state = RAW3270_STATE_INIT;\n\trp->view = &rp->init_view;\n\t \n\twhile (!list_empty(&rp->req_queue)) {\n\t\trq = list_entry(rp->req_queue.next, struct raw3270_request, list);\n\t\tview = rq->view;\n\t\trq->rc = -EACCES;\n\t\tlist_del_init(&rq->list);\n\t\tif (rq->callback)\n\t\t\trq->callback(rq, rq->callback_data);\n\t\traw3270_put_view(view);\n\t}\n\t \n\t__raw3270_reset_device(rp);\n}\n\nstatic void raw3270_init_irq(struct raw3270_view *view, struct raw3270_request *rq,\n\t\t\t     struct irb *irb)\n{\n\tstruct raw3270 *rp;\n\n\tif (rq) {\n\t\tif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {\n\t\t\tif (irb->ecw[0] & SNS0_CMD_REJECT)\n\t\t\t\trq->rc = -EOPNOTSUPP;\n\t\t\telse\n\t\t\t\trq->rc = -EIO;\n\t\t}\n\t}\n\tif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\n\t\t \n\t\trp = view->dev;\n\t\traw3270_read_modified(rp);\n\t}\n}\n\nstatic struct raw3270_fn raw3270_init_fn = {\n\t.intv = raw3270_init_irq\n};\n\n \nstatic int raw3270_setup_device(struct ccw_device *cdev, struct raw3270 *rp,\n\t\t\t\tchar *ascebc)\n{\n\tstruct list_head *l;\n\tstruct raw3270 *tmp;\n\tint minor;\n\n\tmemset(rp, 0, sizeof(struct raw3270));\n\t \n\tmemcpy(ascebc, _ascebc, 256);\n\tif (tubxcorrect) {\n\t\t \n\t\tascebc['['] = 0xad;\n\t\tascebc[']'] = 0xbd;\n\t\tascebc['^'] = 0xb0;\n\t}\n\trp->ascebc = ascebc;\n\n\t \n\trp->rows = 24;\n\trp->cols = 80;\n\trp->old_rows = rp->rows;\n\trp->old_cols = rp->cols;\n\n\tINIT_LIST_HEAD(&rp->req_queue);\n\tINIT_LIST_HEAD(&rp->view_list);\n\n\trp->init_view.dev = rp;\n\trp->init_view.fn = &raw3270_init_fn;\n\trp->view = &rp->init_view;\n\tINIT_WORK(&rp->resize_work, raw3270_resize_work);\n\n\t \n\tmutex_lock(&raw3270_mutex);\n\t \n\tminor = RAW3270_FIRSTMINOR;\n\trp->minor = -1;\n\tlist_for_each(l, &raw3270_devices) {\n\t\ttmp = list_entry(l, struct raw3270, list);\n\t\tif (tmp->minor > minor) {\n\t\t\trp->minor = minor;\n\t\t\t__list_add(&rp->list, l->prev, l);\n\t\t\tbreak;\n\t\t}\n\t\tminor++;\n\t}\n\tif (rp->minor == -1 && minor < RAW3270_MAXDEVS + RAW3270_FIRSTMINOR) {\n\t\trp->minor = minor;\n\t\tlist_add_tail(&rp->list, &raw3270_devices);\n\t}\n\tmutex_unlock(&raw3270_mutex);\n\t \n\tif (rp->minor == -1)\n\t\treturn -EUSERS;\n\trp->cdev = cdev;\n\tdev_set_drvdata(&cdev->dev, rp);\n\tcdev->handler = raw3270_irq;\n\treturn 0;\n}\n\n#ifdef CONFIG_TN3270_CONSOLE\n \nstatic struct ccw_driver raw3270_ccw_driver;\n\nstatic inline int raw3270_state_final(struct raw3270 *rp)\n{\n\treturn rp->state == RAW3270_STATE_INIT ||\n\t\trp->state == RAW3270_STATE_READY;\n}\n\n \nstruct raw3270 __init *raw3270_setup_console(void)\n{\n\tstruct ccw_device *cdev;\n\tunsigned long flags;\n\tstruct raw3270 *rp;\n\tchar *ascebc;\n\tint rc;\n\n\tcdev = ccw_device_create_console(&raw3270_ccw_driver);\n\tif (IS_ERR(cdev))\n\t\treturn ERR_CAST(cdev);\n\n\trp = kzalloc(sizeof(*rp), GFP_KERNEL | GFP_DMA);\n\tascebc = kzalloc(256, GFP_KERNEL);\n\trc = raw3270_setup_device(cdev, rp, ascebc);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\tset_bit(RAW3270_FLAGS_CONSOLE, &rp->flags);\n\n\trc = ccw_device_enable_console(cdev);\n\tif (rc) {\n\t\tccw_device_destroy_console(cdev);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\n\tdo {\n\t\t__raw3270_reset_device(rp);\n\t\twhile (!raw3270_state_final(rp)) {\n\t\t\tccw_device_wait_idle(rp->cdev);\n\t\t\tbarrier();\n\t\t}\n\t} while (rp->state != RAW3270_STATE_READY);\n\tspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\n\treturn rp;\n}\n\nvoid raw3270_wait_cons_dev(struct raw3270 *rp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\n\tccw_device_wait_idle(rp->cdev);\n\tspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\n}\n\n#endif\n\n \nstatic struct raw3270 *raw3270_create_device(struct ccw_device *cdev)\n{\n\tstruct raw3270 *rp;\n\tchar *ascebc;\n\tint rc;\n\n\trp = kzalloc(sizeof(*rp), GFP_KERNEL | GFP_DMA);\n\tif (!rp)\n\t\treturn ERR_PTR(-ENOMEM);\n\tascebc = kmalloc(256, GFP_KERNEL);\n\tif (!ascebc) {\n\t\tkfree(rp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\trc = raw3270_setup_device(cdev, rp, ascebc);\n\tif (rc) {\n\t\tkfree(rp->ascebc);\n\t\tkfree(rp);\n\t\trp = ERR_PTR(rc);\n\t}\n\t \n\tget_device(&cdev->dev);\n\treturn rp;\n}\n\n \nint raw3270_view_lock_unavailable(struct raw3270_view *view)\n{\n\tstruct raw3270 *rp = view->dev;\n\n\tif (!rp)\n\t\treturn -ENODEV;\n\tif (spin_is_locked(get_ccwdev_lock(rp->cdev)))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int raw3270_assign_activate_view(struct raw3270 *rp, struct raw3270_view *view)\n{\n\trp->view = view;\n\treturn view->fn->activate(view);\n}\n\nstatic int __raw3270_activate_view(struct raw3270 *rp, struct raw3270_view *view)\n{\n\tstruct raw3270_view *oldview = NULL, *nv;\n\tint rc;\n\n\tif (rp->view == view)\n\t\treturn 0;\n\n\tif (!raw3270_state_ready(rp))\n\t\treturn -EBUSY;\n\n\tif (rp->view && rp->view->fn->deactivate) {\n\t\toldview = rp->view;\n\t\toldview->fn->deactivate(oldview);\n\t}\n\n\trc = raw3270_assign_activate_view(rp, view);\n\tif (!rc)\n\t\treturn 0;\n\n\t \n\tif (oldview) {\n\t\trc = raw3270_assign_activate_view(rp, oldview);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\t \n\tlist_for_each_entry(nv, &rp->view_list, list) {\n\t\tif (nv == view || nv == oldview)\n\t\t\tcontinue;\n\t\trc = raw3270_assign_activate_view(rp, nv);\n\t\tif (!rc)\n\t\t\tbreak;\n\t\trp->view = NULL;\n\t}\n\treturn rc;\n}\n\n \nint raw3270_activate_view(struct raw3270_view *view)\n{\n\tstruct raw3270 *rp;\n\tunsigned long flags;\n\tint rc;\n\n\trp = view->dev;\n\tif (!rp)\n\t\treturn -ENODEV;\n\tspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\n\trc = __raw3270_activate_view(rp, view);\n\tspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\n\treturn rc;\n}\nEXPORT_SYMBOL(raw3270_activate_view);\n\n \nvoid raw3270_deactivate_view(struct raw3270_view *view)\n{\n\tunsigned long flags;\n\tstruct raw3270 *rp;\n\n\trp = view->dev;\n\tif (!rp)\n\t\treturn;\n\tspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\n\tif (rp->view == view) {\n\t\tview->fn->deactivate(view);\n\t\trp->view = NULL;\n\t\t \n\t\tlist_del_init(&view->list);\n\t\tlist_add_tail(&view->list, &rp->view_list);\n\t\t \n\t\tif (raw3270_state_ready(rp)) {\n\t\t\tlist_for_each_entry(view, &rp->view_list, list) {\n\t\t\t\trp->view = view;\n\t\t\t\tif (view->fn->activate(view) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\trp->view = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\n}\nEXPORT_SYMBOL(raw3270_deactivate_view);\n\n \nint raw3270_add_view(struct raw3270_view *view, struct raw3270_fn *fn,\n\t\t     int minor, int subclass)\n{\n\tunsigned long flags;\n\tstruct raw3270 *rp;\n\tint rc;\n\n\tif (minor <= 0)\n\t\treturn -ENODEV;\n\tmutex_lock(&raw3270_mutex);\n\trc = -ENODEV;\n\tlist_for_each_entry(rp, &raw3270_devices, list) {\n\t\tif (rp->minor != minor)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\n\t\tatomic_set(&view->ref_count, 2);\n\t\tview->dev = rp;\n\t\tview->fn = fn;\n\t\tview->model = rp->model;\n\t\tview->rows = rp->rows;\n\t\tview->cols = rp->cols;\n\t\tview->ascebc = rp->ascebc;\n\t\tspin_lock_init(&view->lock);\n\t\tlockdep_set_subclass(&view->lock, subclass);\n\t\tlist_add(&view->list, &rp->view_list);\n\t\trc = 0;\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\n\t\tbreak;\n\t}\n\tmutex_unlock(&raw3270_mutex);\n\treturn rc;\n}\nEXPORT_SYMBOL(raw3270_add_view);\n\n \nstruct raw3270_view *raw3270_find_view(struct raw3270_fn *fn, int minor)\n{\n\tstruct raw3270 *rp;\n\tstruct raw3270_view *view, *tmp;\n\tunsigned long flags;\n\n\tmutex_lock(&raw3270_mutex);\n\tview = ERR_PTR(-ENODEV);\n\tlist_for_each_entry(rp, &raw3270_devices, list) {\n\t\tif (rp->minor != minor)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\n\t\tlist_for_each_entry(tmp, &rp->view_list, list) {\n\t\t\tif (tmp->fn == fn) {\n\t\t\t\traw3270_get_view(tmp);\n\t\t\t\tview = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\n\t\tbreak;\n\t}\n\tmutex_unlock(&raw3270_mutex);\n\treturn view;\n}\nEXPORT_SYMBOL(raw3270_find_view);\n\n \nvoid raw3270_del_view(struct raw3270_view *view)\n{\n\tunsigned long flags;\n\tstruct raw3270 *rp;\n\tstruct raw3270_view *nv;\n\n\trp = view->dev;\n\tspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\n\tif (rp->view == view) {\n\t\tview->fn->deactivate(view);\n\t\trp->view = NULL;\n\t}\n\tlist_del_init(&view->list);\n\tif (!rp->view && raw3270_state_ready(rp)) {\n\t\t \n\t\tlist_for_each_entry(nv, &rp->view_list, list) {\n\t\t\tif (nv->fn->activate(nv) == 0) {\n\t\t\t\trp->view = nv;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\n\t \n\tatomic_dec(&view->ref_count);\n\twait_event(raw3270_wait_queue, atomic_read(&view->ref_count) == 0);\n\tif (view->fn->free)\n\t\tview->fn->free(view);\n}\nEXPORT_SYMBOL(raw3270_del_view);\n\n \nstatic void raw3270_delete_device(struct raw3270 *rp)\n{\n\tstruct ccw_device *cdev;\n\n\t \n\tmutex_lock(&raw3270_mutex);\n\tlist_del_init(&rp->list);\n\tmutex_unlock(&raw3270_mutex);\n\n\t \n\tcdev = rp->cdev;\n\trp->cdev = NULL;\n\tdev_set_drvdata(&cdev->dev, NULL);\n\tcdev->handler = NULL;\n\n\t \n\tput_device(&cdev->dev);\n\n\t \n\tkfree(rp->ascebc);\n\tkfree(rp);\n}\n\nstatic int raw3270_probe(struct ccw_device *cdev)\n{\n\treturn 0;\n}\n\n \nstatic ssize_t model_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\treturn sysfs_emit(buf, \"%i\\n\",\n\t\t\t  ((struct raw3270 *)dev_get_drvdata(dev))->model);\n}\nstatic DEVICE_ATTR_RO(model);\n\nstatic ssize_t rows_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%i\\n\",\n\t\t\t  ((struct raw3270 *)dev_get_drvdata(dev))->rows);\n}\nstatic DEVICE_ATTR_RO(rows);\n\nstatic ssize_t\ncolumns_show(struct device *dev, struct device_attribute *attr,\n\t     char *buf)\n{\n\treturn sysfs_emit(buf, \"%i\\n\",\n\t\t\t  ((struct raw3270 *)dev_get_drvdata(dev))->cols);\n}\nstatic DEVICE_ATTR_RO(columns);\n\nstatic struct attribute *raw3270_attrs[] = {\n\t&dev_attr_model.attr,\n\t&dev_attr_rows.attr,\n\t&dev_attr_columns.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group raw3270_attr_group = {\n\t.attrs = raw3270_attrs,\n};\n\nstatic int raw3270_create_attributes(struct raw3270 *rp)\n{\n\treturn sysfs_create_group(&rp->cdev->dev.kobj, &raw3270_attr_group);\n}\n\n \nstatic LIST_HEAD(raw3270_notifier);\n\nint raw3270_register_notifier(struct raw3270_notifier *notifier)\n{\n\tstruct raw3270 *rp;\n\n\tmutex_lock(&raw3270_mutex);\n\tlist_add_tail(&notifier->list, &raw3270_notifier);\n\tlist_for_each_entry(rp, &raw3270_devices, list)\n\t\tnotifier->create(rp->minor);\n\tmutex_unlock(&raw3270_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(raw3270_register_notifier);\n\nvoid raw3270_unregister_notifier(struct raw3270_notifier *notifier)\n{\n\tstruct raw3270 *rp;\n\n\tmutex_lock(&raw3270_mutex);\n\tlist_for_each_entry(rp, &raw3270_devices, list)\n\t\tnotifier->destroy(rp->minor);\n\tlist_del(&notifier->list);\n\tmutex_unlock(&raw3270_mutex);\n}\nEXPORT_SYMBOL(raw3270_unregister_notifier);\n\n \nstatic int raw3270_set_online(struct ccw_device *cdev)\n{\n\tstruct raw3270_notifier *np;\n\tstruct raw3270 *rp;\n\tint rc;\n\n\trp = raw3270_create_device(cdev);\n\tif (IS_ERR(rp))\n\t\treturn PTR_ERR(rp);\n\trc = raw3270_create_attributes(rp);\n\tif (rc)\n\t\tgoto failure;\n\traw3270_reset_device(rp);\n\tmutex_lock(&raw3270_mutex);\n\tlist_for_each_entry(np, &raw3270_notifier, list)\n\t\tnp->create(rp->minor);\n\tmutex_unlock(&raw3270_mutex);\n\treturn 0;\n\nfailure:\n\traw3270_delete_device(rp);\n\treturn rc;\n}\n\n \nstatic void raw3270_remove(struct ccw_device *cdev)\n{\n\tunsigned long flags;\n\tstruct raw3270 *rp;\n\tstruct raw3270_view *v;\n\tstruct raw3270_notifier *np;\n\n\trp = dev_get_drvdata(&cdev->dev);\n\t \n\tif (!rp)\n\t\treturn;\n\n\tsysfs_remove_group(&cdev->dev.kobj, &raw3270_attr_group);\n\n\t \n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tif (rp->view) {\n\t\tif (rp->view->fn->deactivate)\n\t\t\trp->view->fn->deactivate(rp->view);\n\t\trp->view = NULL;\n\t}\n\twhile (!list_empty(&rp->view_list)) {\n\t\tv = list_entry(rp->view_list.next, struct raw3270_view, list);\n\t\tif (v->fn->release)\n\t\t\tv->fn->release(v);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\t\traw3270_del_view(v);\n\t\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\n\tmutex_lock(&raw3270_mutex);\n\tlist_for_each_entry(np, &raw3270_notifier, list)\n\t\tnp->destroy(rp->minor);\n\tmutex_unlock(&raw3270_mutex);\n\n\t \n\traw3270_reset_device(rp);\n\t \n\traw3270_delete_device(rp);\n}\n\n \nstatic int raw3270_set_offline(struct ccw_device *cdev)\n{\n\tstruct raw3270 *rp;\n\n\trp = dev_get_drvdata(&cdev->dev);\n\tif (test_bit(RAW3270_FLAGS_CONSOLE, &rp->flags))\n\t\treturn -EBUSY;\n\traw3270_remove(cdev);\n\treturn 0;\n}\n\nstatic struct ccw_device_id raw3270_id[] = {\n\t{ CCW_DEVICE(0x3270, 0) },\n\t{ CCW_DEVICE(0x3271, 0) },\n\t{ CCW_DEVICE(0x3272, 0) },\n\t{ CCW_DEVICE(0x3273, 0) },\n\t{ CCW_DEVICE(0x3274, 0) },\n\t{ CCW_DEVICE(0x3275, 0) },\n\t{ CCW_DEVICE(0x3276, 0) },\n\t{ CCW_DEVICE(0x3277, 0) },\n\t{ CCW_DEVICE(0x3278, 0) },\n\t{ CCW_DEVICE(0x3279, 0) },\n\t{ CCW_DEVICE(0x3174, 0) },\n\t{   },\n};\n\nstatic struct ccw_driver raw3270_ccw_driver = {\n\t.driver = {\n\t\t.name\t= \"3270\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n\t.ids\t\t= raw3270_id,\n\t.probe\t\t= &raw3270_probe,\n\t.remove\t\t= &raw3270_remove,\n\t.set_online\t= &raw3270_set_online,\n\t.set_offline\t= &raw3270_set_offline,\n\t.int_class\t= IRQIO_C70,\n};\n\nstatic int raw3270_init(void)\n{\n\tstruct raw3270 *rp;\n\tint rc;\n\n\tif (raw3270_registered)\n\t\treturn 0;\n\traw3270_registered = 1;\n\trc = ccw_driver_register(&raw3270_ccw_driver);\n\tif (rc == 0) {\n\t\t \n\t\tmutex_lock(&raw3270_mutex);\n\t\tclass3270 = class_create(\"3270\");\n\t\tlist_for_each_entry(rp, &raw3270_devices, list) {\n\t\t\tget_device(&rp->cdev->dev);\n\t\t\traw3270_create_attributes(rp);\n\t\t}\n\t\tmutex_unlock(&raw3270_mutex);\n\t}\n\treturn rc;\n}\n\nstatic void raw3270_exit(void)\n{\n\tccw_driver_unregister(&raw3270_ccw_driver);\n\tclass_destroy(class3270);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(raw3270_init);\nmodule_exit(raw3270_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}