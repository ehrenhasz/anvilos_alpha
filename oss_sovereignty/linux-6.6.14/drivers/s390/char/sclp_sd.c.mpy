{
  "module_name": "sclp_sd.c",
  "hash_id": "620b0a7cef756c336c79eb85a6c2ea5d583f4da47f6be6d195a428a81593adc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_sd.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"sclp_sd\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/completion.h>\n#include <linux/kobject.h>\n#include <linux/list.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/async.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n\n#include <asm/pgalloc.h>\n\n#include \"sclp.h\"\n\n#define SD_EQ_STORE_DATA\t0\n#define SD_EQ_HALT\t\t1\n#define SD_EQ_SIZE\t\t2\n\n#define SD_DI_CONFIG\t\t3\n\nstruct sclp_sd_evbuf {\n\tstruct evbuf_header hdr;\n\tu8 eq;\n\tu8 di;\n\tu8 rflags;\n\tu64 :56;\n\tu32 id;\n\tu16 :16;\n\tu8 fmt;\n\tu8 status;\n\tu64 sat;\n\tu64 sa;\n\tu32 esize;\n\tu32 dsize;\n} __packed;\n\nstruct sclp_sd_sccb {\n\tstruct sccb_header hdr;\n\tstruct sclp_sd_evbuf evbuf;\n} __packed __aligned(PAGE_SIZE);\n\n \nstruct sclp_sd_data {\n\tsize_t esize_bytes;\n\tsize_t dsize_bytes;\n\tvoid *data;\n};\n\n \nstruct sclp_sd_listener {\n\tstruct list_head list;\n\tu32 id;\n\tstruct completion completion;\n\tstruct sclp_sd_evbuf evbuf;\n};\n\n \nstruct sclp_sd_file {\n\tstruct kobject kobj;\n\tstruct bin_attribute data_attr;\n\tstruct mutex data_mutex;\n\tstruct sclp_sd_data data;\n\tu8 di;\n};\n#define to_sd_file(x) container_of(x, struct sclp_sd_file, kobj)\n\nstatic struct kset *sclp_sd_kset;\nstatic struct sclp_sd_file *config_file;\n\nstatic LIST_HEAD(sclp_sd_queue);\nstatic DEFINE_SPINLOCK(sclp_sd_queue_lock);\n\n \nstatic void sclp_sd_listener_add(struct sclp_sd_listener *listener)\n{\n\tspin_lock_irq(&sclp_sd_queue_lock);\n\tlist_add_tail(&listener->list, &sclp_sd_queue);\n\tspin_unlock_irq(&sclp_sd_queue_lock);\n}\n\n \nstatic void sclp_sd_listener_remove(struct sclp_sd_listener *listener)\n{\n\tspin_lock_irq(&sclp_sd_queue_lock);\n\tlist_del(&listener->list);\n\tspin_unlock_irq(&sclp_sd_queue_lock);\n}\n\n \nstatic void sclp_sd_listener_init(struct sclp_sd_listener *listener, u32 id)\n{\n\tmemset(listener, 0, sizeof(*listener));\n\tlistener->id = id;\n\tinit_completion(&listener->completion);\n}\n\n \nstatic void sclp_sd_receiver(struct evbuf_header *evbuf_hdr)\n{\n\tstruct sclp_sd_evbuf *evbuf = (struct sclp_sd_evbuf *) evbuf_hdr;\n\tstruct sclp_sd_listener *listener;\n\tint found = 0;\n\n\tpr_debug(\"received event (id=0x%08x)\\n\", evbuf->id);\n\tspin_lock(&sclp_sd_queue_lock);\n\tlist_for_each_entry(listener, &sclp_sd_queue, list) {\n\t\tif (listener->id != evbuf->id)\n\t\t\tcontinue;\n\n\t\tlistener->evbuf = *evbuf;\n\t\tcomplete(&listener->completion);\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tspin_unlock(&sclp_sd_queue_lock);\n\n\tif (!found)\n\t\tpr_debug(\"unsolicited event (id=0x%08x)\\n\", evbuf->id);\n}\n\nstatic struct sclp_register sclp_sd_register = {\n\t.send_mask = EVTYP_STORE_DATA_MASK,\n\t.receive_mask = EVTYP_STORE_DATA_MASK,\n\t.receiver_fn = sclp_sd_receiver,\n};\n\n \nstatic int sclp_sd_sync(unsigned long page, u8 eq, u8 di, u64 sat, u64 sa,\n\t\t\tu32 *dsize_ptr, u32 *esize_ptr)\n{\n\tstruct sclp_sd_sccb *sccb = (void *) page;\n\tstruct sclp_sd_listener listener;\n\tstruct sclp_sd_evbuf *evbuf;\n\tint rc;\n\n\tsclp_sd_listener_init(&listener, __pa(sccb));\n\tsclp_sd_listener_add(&listener);\n\n\t \n\tmemset(sccb, 0, PAGE_SIZE);\n\tsccb->hdr.length = sizeof(sccb->hdr) + sizeof(sccb->evbuf);\n\tevbuf = &sccb->evbuf;\n\tevbuf->hdr.length = sizeof(*evbuf);\n\tevbuf->hdr.type = EVTYP_STORE_DATA;\n\tevbuf->eq = eq;\n\tevbuf->di = di;\n\tevbuf->id = listener.id;\n\tevbuf->fmt = 1;\n\tevbuf->sat = sat;\n\tevbuf->sa = sa;\n\tif (dsize_ptr)\n\t\tevbuf->dsize = *dsize_ptr;\n\n\t \n\tpr_debug(\"request (eq=%d, di=%d, id=0x%08x)\\n\", eq, di, listener.id);\n\trc = sclp_sync_request(SCLP_CMDW_WRITE_EVENT_DATA, sccb);\n\tpr_debug(\"request done (rc=%d)\\n\", rc);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tif (sccb->hdr.response_code == 0x73f0) {\n\t\tpr_debug(\"event not supported\\n\");\n\t\trc = -EIO;\n\t\tgoto out_remove;\n\t}\n\tif (sccb->hdr.response_code != 0x0020 || !(evbuf->hdr.flags & 0x80)) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (!(evbuf->rflags & 0x80)) {\n\t\trc = wait_for_completion_interruptible(&listener.completion);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tevbuf = &listener.evbuf;\n\t}\n\tswitch (evbuf->status) {\n\tcase 0:\n\t\tif (dsize_ptr)\n\t\t\t*dsize_ptr = evbuf->dsize;\n\t\tif (esize_ptr)\n\t\t\t*esize_ptr = evbuf->esize;\n\t\tpr_debug(\"success (dsize=%u, esize=%u)\\n\", evbuf->dsize,\n\t\t\t evbuf->esize);\n\t\tbreak;\n\tcase 3:\n\t\trc = -ENOENT;\n\t\tbreak;\n\tdefault:\n\t\trc = -EIO;\n\t\tbreak;\n\n\t}\n\nout:\n\tif (rc && rc != -ENOENT) {\n\t\t \n\t\tpr_warn(\"Store Data request failed (eq=%d, di=%d, \"\n\t\t\t\"response=0x%04x, flags=0x%02x, status=%d, rc=%d)\\n\",\n\t\t\teq, di, sccb->hdr.response_code, evbuf->hdr.flags,\n\t\t\tevbuf->status, rc);\n\t}\n\nout_remove:\n\tsclp_sd_listener_remove(&listener);\n\n\treturn rc;\n}\n\n \nstatic int sclp_sd_store_data(struct sclp_sd_data *result, u8 di)\n{\n\tu32 dsize = 0, esize = 0;\n\tunsigned long page, asce = 0;\n\tvoid *data = NULL;\n\tint rc;\n\n\tpage = __get_free_page(GFP_KERNEL | GFP_DMA);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\t \n\trc = sclp_sd_sync(page, SD_EQ_SIZE, di, 0, 0, &dsize, &esize);\n\tif (rc)\n\t\tgoto out;\n\tif (dsize == 0)\n\t\tgoto out_result;\n\n\t \n\tdata = vzalloc(array_size((size_t)dsize, PAGE_SIZE));\n\tif (!data) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tasce = base_asce_alloc((unsigned long) data, dsize);\n\tif (!asce) {\n\t\tvfree(data);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\trc = sclp_sd_sync(page, SD_EQ_STORE_DATA, di, asce, (u64) data, &dsize,\n\t\t\t  &esize);\n\tif (rc) {\n\t\t \n\t\tif (rc == -ERESTARTSYS)\n\t\t\tsclp_sd_sync(page, SD_EQ_HALT, di, 0, 0, NULL, NULL);\n\t\tvfree(data);\n\t\tgoto out;\n\t}\n\nout_result:\n\tresult->esize_bytes = (size_t) esize * PAGE_SIZE;\n\tresult->dsize_bytes = (size_t) dsize * PAGE_SIZE;\n\tresult->data = data;\n\nout:\n\tbase_asce_free(asce);\n\tfree_page(page);\n\n\treturn rc;\n}\n\n \nstatic void sclp_sd_data_reset(struct sclp_sd_data *data)\n{\n\tvfree(data->data);\n\tdata->data = NULL;\n\tdata->dsize_bytes = 0;\n\tdata->esize_bytes = 0;\n}\n\n \nstatic void sclp_sd_file_release(struct kobject *kobj)\n{\n\tstruct sclp_sd_file *sd_file = to_sd_file(kobj);\n\n\tsclp_sd_data_reset(&sd_file->data);\n\tkfree(sd_file);\n}\n\n \nstatic int sclp_sd_file_update(struct sclp_sd_file *sd_file)\n{\n\tconst char *name = kobject_name(&sd_file->kobj);\n\tstruct sclp_sd_data data;\n\tint rc;\n\n\trc = sclp_sd_store_data(&data, sd_file->di);\n\tif (rc) {\n\t\tif (rc == -ENOENT) {\n\t\t\tpr_info(\"No data is available for the %s data entity\\n\",\n\t\t\t\t name);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tmutex_lock(&sd_file->data_mutex);\n\tsclp_sd_data_reset(&sd_file->data);\n\tsd_file->data = data;\n\tmutex_unlock(&sd_file->data_mutex);\n\n\tpr_info(\"A %zu-byte %s data entity was retrieved\\n\", data.dsize_bytes,\n\t\tname);\n\tkobject_uevent(&sd_file->kobj, KOBJ_CHANGE);\n\n\treturn 0;\n}\n\n \nstatic void sclp_sd_file_update_async(void *data, async_cookie_t cookie)\n{\n\tstruct sclp_sd_file *sd_file = data;\n\n\tsclp_sd_file_update(sd_file);\n}\n\n \nstatic ssize_t reload_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct sclp_sd_file *sd_file = to_sd_file(kobj);\n\n\tsclp_sd_file_update(sd_file);\n\n\treturn count;\n}\n\nstatic struct kobj_attribute reload_attr = __ATTR_WO(reload);\n\nstatic struct attribute *sclp_sd_file_default_attrs[] = {\n\t&reload_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(sclp_sd_file_default);\n\nstatic struct kobj_type sclp_sd_file_ktype = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.release = sclp_sd_file_release,\n\t.default_groups = sclp_sd_file_default_groups,\n};\n\n \nstatic ssize_t data_read(struct file *file, struct kobject *kobj,\n\t\t\t struct bin_attribute *attr, char *buffer,\n\t\t\t loff_t off, size_t size)\n{\n\tstruct sclp_sd_file *sd_file = to_sd_file(kobj);\n\tsize_t data_size;\n\tchar *data;\n\n\tmutex_lock(&sd_file->data_mutex);\n\n\tdata = sd_file->data.data;\n\tdata_size = sd_file->data.dsize_bytes;\n\tif (!data || off >= data_size) {\n\t\tsize = 0;\n\t} else {\n\t\tif (off + size > data_size)\n\t\t\tsize = data_size - off;\n\t\tmemcpy(buffer, data + off, size);\n\t}\n\n\tmutex_unlock(&sd_file->data_mutex);\n\n\treturn size;\n}\n\n \nstatic __init struct sclp_sd_file *sclp_sd_file_create(const char *name, u8 di)\n{\n\tstruct sclp_sd_file *sd_file;\n\tint rc;\n\n\tsd_file = kzalloc(sizeof(*sd_file), GFP_KERNEL);\n\tif (!sd_file)\n\t\treturn NULL;\n\tsd_file->di = di;\n\tmutex_init(&sd_file->data_mutex);\n\n\t \n\tsd_file->kobj.kset = sclp_sd_kset;\n\trc = kobject_init_and_add(&sd_file->kobj, &sclp_sd_file_ktype, NULL,\n\t\t\t\t  \"%s\", name);\n\tif (rc) {\n\t\tkobject_put(&sd_file->kobj);\n\t\treturn NULL;\n\t}\n\n\tsysfs_bin_attr_init(&sd_file->data_attr);\n\tsd_file->data_attr.attr.name = \"data\";\n\tsd_file->data_attr.attr.mode = 0444;\n\tsd_file->data_attr.read = data_read;\n\n\trc = sysfs_create_bin_file(&sd_file->kobj, &sd_file->data_attr);\n\tif (rc) {\n\t\tkobject_put(&sd_file->kobj);\n\t\treturn NULL;\n\t}\n\n\t \n\tkobject_uevent(&sd_file->kobj, KOBJ_ADD);\n\n\t \n\tasync_schedule(sclp_sd_file_update_async, sd_file);\n\n\treturn sd_file;\n}\n\n \nstatic __init int sclp_sd_init(void)\n{\n\tint rc;\n\n\trc = sclp_register(&sclp_sd_register);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = -ENOMEM;\n\tsclp_sd_kset = kset_create_and_add(\"sclp_sd\", NULL, firmware_kobj);\n\tif (!sclp_sd_kset)\n\t\tgoto err_kset;\n\n\trc = -EINVAL;\n\tconfig_file = sclp_sd_file_create(\"config\", SD_DI_CONFIG);\n\tif (!config_file)\n\t\tgoto err_config;\n\n\treturn 0;\n\nerr_config:\n\tkset_unregister(sclp_sd_kset);\nerr_kset:\n\tsclp_unregister(&sclp_sd_register);\n\n\treturn rc;\n}\ndevice_initcall(sclp_sd_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}