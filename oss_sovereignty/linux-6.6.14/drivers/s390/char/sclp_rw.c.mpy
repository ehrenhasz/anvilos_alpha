{
  "module_name": "sclp_rw.c",
  "hash_id": "a8237491ac25c0435fdb5c19bc33baa9294d5de45c138ae86f63f63ddd80eb10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_rw.c",
  "human_readable_source": "\n \n\n#include <linux/kmod.h>\n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n\n#include \"sclp.h\"\n#include \"sclp_rw.h\"\n\n \n#define MAX_SCCB_ROOM (PAGE_SIZE - sizeof(struct sclp_buffer))\n\n \nstatic struct sclp_register sclp_rw_event = {\n\t.send_mask = EVTYP_MSG_MASK,\n};\n\n \nstruct sclp_buffer *\nsclp_make_buffer(void *page, unsigned short columns, unsigned short htab)\n{\n\tstruct sclp_buffer *buffer;\n\tstruct sccb_header *sccb;\n\n\tsccb = (struct sccb_header *) page;\n\t \n\tbuffer = ((struct sclp_buffer *) ((addr_t) sccb + PAGE_SIZE)) - 1;\n\tbuffer->sccb = sccb;\n\tbuffer->retry_count = 0;\n\tbuffer->messages = 0;\n\tbuffer->char_sum = 0;\n\tbuffer->current_line = NULL;\n\tbuffer->current_length = 0;\n\tbuffer->columns = columns;\n\tbuffer->htab = htab;\n\n\t \n\tmemset(sccb, 0, sizeof(struct sccb_header));\n\tsccb->length = sizeof(struct sccb_header);\n\n\treturn buffer;\n}\n\n \nvoid *\nsclp_unmake_buffer(struct sclp_buffer *buffer)\n{\n\treturn buffer->sccb;\n}\n\n \nstatic int\nsclp_initialize_mto(struct sclp_buffer *buffer, int max_len)\n{\n\tstruct sccb_header *sccb;\n\tstruct msg_buf *msg;\n\tstruct mdb *mdb;\n\tstruct go *go;\n\tstruct mto *mto;\n\tint msg_size;\n\n\t \n\tmsg_size = sizeof(struct msg_buf) + max_len;\n\n\t \n\tsccb = buffer->sccb;\n\tif ((MAX_SCCB_ROOM - sccb->length) < msg_size)\n\t\treturn -ENOMEM;\n\n\tmsg = (struct msg_buf *)((addr_t) sccb + sccb->length);\n\tmemset(msg, 0, sizeof(struct msg_buf));\n\tmsg->header.length = sizeof(struct msg_buf);\n\tmsg->header.type = EVTYP_MSG;\n\n\tmdb = &msg->mdb;\n\tmdb->header.length = sizeof(struct mdb);\n\tmdb->header.type = 1;\n\tmdb->header.tag = 0xD4C4C240;\t \n\tmdb->header.revision_code = 1;\n\n\tgo = &mdb->go;\n\tgo->length = sizeof(struct go);\n\tgo->type = 1;\n\n\tmto = &mdb->mto;\n\tmto->length = sizeof(struct mto);\n\tmto->type = 4;\t \n\tmto->line_type_flags = LNTPFLGS_ENDTEXT;  \n\n\t \n\tbuffer->current_msg = msg;\n\tbuffer->current_line = (char *) (mto + 1);\n\tbuffer->current_length = 0;\n\n\treturn 0;\n}\n\n \nstatic void\nsclp_finalize_mto(struct sclp_buffer *buffer)\n{\n\tstruct sccb_header *sccb;\n\tstruct msg_buf *msg;\n\n\t \n\tsccb = buffer->sccb;\n\tmsg = buffer->current_msg;\n\tmsg->header.length += buffer->current_length;\n\tmsg->mdb.header.length += buffer->current_length;\n\tmsg->mdb.mto.length += buffer->current_length;\n\tsccb->length += msg->header.length;\n\n\t \n\tbuffer->messages++;\n\tbuffer->char_sum += buffer->current_length;\n\n\tbuffer->current_line = NULL;\n\tbuffer->current_length = 0;\n\tbuffer->current_msg = NULL;\n}\n\n \nint\nsclp_write(struct sclp_buffer *buffer, const unsigned char *msg, int count)\n{\n\tint spaces, i_msg;\n\tint rc;\n\n\t \n\tfor (i_msg = 0; i_msg < count; i_msg++) {\n\t\tswitch (msg[i_msg]) {\n\t\tcase '\\n':\t \n\t\t\t \n\t\t\tif (buffer->current_line == NULL) {\n\t\t\t\trc = sclp_initialize_mto(buffer, 0);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn i_msg;\n\t\t\t}\n\t\t\tsclp_finalize_mto(buffer);\n\t\t\tbreak;\n\t\tcase '\\a':\t \n\t\t\t \n\t\t\tif (buffer->current_line == NULL) {\n\t\t\t\trc = sclp_initialize_mto(buffer,\n\t\t\t\t\t\t\t buffer->columns);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn i_msg;\n\t\t\t}\n\t\t\tbuffer->current_msg->mdb.go.general_msg_flags |=\n\t\t\t\tGNRLMSGFLGS_SNDALRM;\n\t\t\tbreak;\n\t\tcase '\\t':\t \n\t\t\t \n\t\t\tif (buffer->current_line == NULL) {\n\t\t\t\trc = sclp_initialize_mto(buffer,\n\t\t\t\t\t\t\t buffer->columns);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn i_msg;\n\t\t\t}\n\t\t\t \n\t\t\tdo {\n\t\t\t\tif (buffer->current_length >= buffer->columns)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\t*buffer->current_line++ = 0x40;\n\t\t\t\tbuffer->current_length++;\n\t\t\t} while (buffer->current_length % buffer->htab);\n\t\t\tbreak;\n\t\tcase '\\f':\t \n\t\tcase '\\v':\t \n\t\t\t \n\t\t\t \n\t\t\tif (buffer->current_line != NULL) {\n\t\t\t\tspaces = buffer->current_length;\n\t\t\t\tsclp_finalize_mto(buffer);\n\t\t\t\trc = sclp_initialize_mto(buffer,\n\t\t\t\t\t\t\t buffer->columns);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn i_msg;\n\t\t\t\tmemset(buffer->current_line, 0x40, spaces);\n\t\t\t\tbuffer->current_line += spaces;\n\t\t\t\tbuffer->current_length = spaces;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trc = sclp_initialize_mto(buffer,\n\t\t\t\t\t\t\t buffer->columns);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn i_msg;\n\t\t\t\tsclp_finalize_mto(buffer);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\b':\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tif (buffer->current_line != NULL &&\n\t\t\t    buffer->current_length > 0) {\n\t\t\t\tbuffer->current_length--;\n\t\t\t\tbuffer->current_line--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x00:\t \n\t\t\t \n\t\t\tif (buffer->current_line != NULL)\n\t\t\t\tsclp_finalize_mto(buffer);\n\t\t\t \n\t\t\ti_msg = count - 1;\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\t \n\t\t\tif (!isprint(msg[i_msg]))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (buffer->current_line == NULL) {\n\t\t\t\trc = sclp_initialize_mto(buffer,\n\t\t\t\t\t\t\t buffer->columns);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn i_msg;\n\t\t\t}\n\t\t\t*buffer->current_line++ = sclp_ascebc(msg[i_msg]);\n\t\t\tbuffer->current_length++;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (buffer->current_line != NULL &&\n\t\t    buffer->current_length >= buffer->columns)\n\t\t\tsclp_finalize_mto(buffer);\n\t}\n\n\t \n\treturn i_msg;\n}\n\n \nint\nsclp_buffer_space(struct sclp_buffer *buffer)\n{\n\tstruct sccb_header *sccb;\n\tint count;\n\n\tsccb = buffer->sccb;\n\tcount = MAX_SCCB_ROOM - sccb->length;\n\tif (buffer->current_line != NULL)\n\t\tcount -= sizeof(struct msg_buf) + buffer->current_length;\n\treturn count;\n}\n\n \nunsigned int\nsclp_chars_in_buffer(struct sclp_buffer *buffer)\n{\n\tunsigned int count;\n\n\tcount = buffer->char_sum;\n\tif (buffer->current_line != NULL)\n\t\tcount += buffer->current_length;\n\treturn count;\n}\n\n \nint\nsclp_rw_init(void)\n{\n\tstatic int init_done = 0;\n\tint rc;\n\n\tif (init_done)\n\t\treturn 0;\n\n\trc = sclp_register(&sclp_rw_event);\n\tif (rc == 0)\n\t\tinit_done = 1;\n\treturn rc;\n}\n\n#define SCLP_BUFFER_MAX_RETRY\t\t1\n\n \nstatic void\nsclp_writedata_callback(struct sclp_req *request, void *data)\n{\n\tint rc;\n\tstruct sclp_buffer *buffer;\n\tstruct sccb_header *sccb;\n\n\tbuffer = (struct sclp_buffer *) data;\n\tsccb = buffer->sccb;\n\n\tif (request->status == SCLP_REQ_FAILED) {\n\t\tif (buffer->callback != NULL)\n\t\t\tbuffer->callback(buffer, -EIO);\n\t\treturn;\n\t}\n\t \n\tswitch (sccb->response_code) {\n\tcase 0x0020 :\n\t\t \n\t\trc = 0;\n\t\tbreak;\n\n\tcase 0x0340:  \n\t\tif (++buffer->retry_count > SCLP_BUFFER_MAX_RETRY) {\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (sclp_remove_processed((struct sccb_header *) sccb) > 0) {\n\t\t\t \n\t\t\tsccb->response_code = 0x0000;\n\t\t\tbuffer->request.status = SCLP_REQ_FILLED;\n\t\t\trc = sclp_add_request(request);\n\t\t\tif (rc == 0)\n\t\t\t\treturn;\n\t\t} else\n\t\t\trc = 0;\n\t\tbreak;\n\n\tcase 0x0040:  \n\tcase 0x05f0:  \n\t\tif (++buffer->retry_count > SCLP_BUFFER_MAX_RETRY) {\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tsccb->response_code = 0x0000;\n\t\tbuffer->request.status = SCLP_REQ_FILLED;\n\t\trc = sclp_add_request(request);\n\t\tif (rc == 0)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tif (sccb->response_code == 0x71f0)\n\t\t\trc = -ENOMEM;\n\t\telse\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\tif (buffer->callback != NULL)\n\t\tbuffer->callback(buffer, rc);\n}\n\n \nint\nsclp_emit_buffer(struct sclp_buffer *buffer,\n\t\t void (*callback)(struct sclp_buffer *, int))\n{\n\t \n\tif (buffer->current_line != NULL)\n\t\tsclp_finalize_mto(buffer);\n\n\t \n\tif (buffer->messages == 0)\n\t\treturn -EIO;\n\n\tbuffer->request.command = SCLP_CMDW_WRITE_EVENT_DATA;\n\tbuffer->request.status = SCLP_REQ_FILLED;\n\tbuffer->request.callback = sclp_writedata_callback;\n\tbuffer->request.callback_data = buffer;\n\tbuffer->request.sccb = buffer->sccb;\n\tbuffer->callback = callback;\n\treturn sclp_add_request(&buffer->request);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}