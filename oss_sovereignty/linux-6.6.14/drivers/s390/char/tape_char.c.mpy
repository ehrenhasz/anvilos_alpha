{
  "module_name": "tape_char.c",
  "hash_id": "ecd1701929c9a53329e5a3fd7f92dbf255d98cb68c9a671cd8c650a7b610b6e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/tape_char.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"tape\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/proc_fs.h>\n#include <linux/mtio.h>\n#include <linux/compat.h>\n\n#include <linux/uaccess.h>\n\n#define TAPE_DBF_AREA\ttape_core_dbf\n\n#include \"tape.h\"\n#include \"tape_std.h\"\n#include \"tape_class.h\"\n\n#define TAPECHAR_MAJOR\t\t0\t \n\n \nstatic ssize_t tapechar_read(struct file *, char __user *, size_t, loff_t *);\nstatic ssize_t tapechar_write(struct file *, const char __user *, size_t, loff_t *);\nstatic int tapechar_open(struct inode *,struct file *);\nstatic int tapechar_release(struct inode *,struct file *);\nstatic long tapechar_ioctl(struct file *, unsigned int, unsigned long);\n#ifdef CONFIG_COMPAT\nstatic long tapechar_compat_ioctl(struct file *, unsigned int, unsigned long);\n#endif\n\nstatic const struct file_operations tape_fops =\n{\n\t.owner = THIS_MODULE,\n\t.read = tapechar_read,\n\t.write = tapechar_write,\n\t.unlocked_ioctl = tapechar_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = tapechar_compat_ioctl,\n#endif\n\t.open = tapechar_open,\n\t.release = tapechar_release,\n\t.llseek = no_llseek,\n};\n\nstatic int tapechar_major = TAPECHAR_MAJOR;\n\n \nint\ntapechar_setup_device(struct tape_device * device)\n{\n\tchar\tdevice_name[20];\n\n\tsprintf(device_name, \"ntibm%i\", device->first_minor / 2);\n\tdevice->nt = register_tape_dev(\n\t\t&device->cdev->dev,\n\t\tMKDEV(tapechar_major, device->first_minor),\n\t\t&tape_fops,\n\t\tdevice_name,\n\t\t\"non-rewinding\"\n\t);\n\tdevice_name[0] = 'r';\n\tdevice->rt = register_tape_dev(\n\t\t&device->cdev->dev,\n\t\tMKDEV(tapechar_major, device->first_minor + 1),\n\t\t&tape_fops,\n\t\tdevice_name,\n\t\t\"rewinding\"\n\t);\n\n\treturn 0;\n}\n\nvoid\ntapechar_cleanup_device(struct tape_device *device)\n{\n\tunregister_tape_dev(&device->cdev->dev, device->rt);\n\tdevice->rt = NULL;\n\tunregister_tape_dev(&device->cdev->dev, device->nt);\n\tdevice->nt = NULL;\n}\n\nstatic int\ntapechar_check_idalbuffer(struct tape_device *device, size_t block_size)\n{\n\tstruct idal_buffer *new;\n\n\tif (device->char_data.idal_buf != NULL &&\n\t    device->char_data.idal_buf->size == block_size)\n\t\treturn 0;\n\n\tif (block_size > MAX_BLOCKSIZE) {\n\t\tDBF_EVENT(3, \"Invalid blocksize (%zd > %d)\\n\",\n\t\t\tblock_size, MAX_BLOCKSIZE);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnew = idal_buffer_alloc(block_size, 0);\n\tif (IS_ERR(new))\n\t\treturn -ENOMEM;\n\n\tif (device->char_data.idal_buf != NULL)\n\t\tidal_buffer_free(device->char_data.idal_buf);\n\n\tdevice->char_data.idal_buf = new;\n\n\treturn 0;\n}\n\n \nstatic ssize_t\ntapechar_read(struct file *filp, char __user *data, size_t count, loff_t *ppos)\n{\n\tstruct tape_device *device;\n\tstruct tape_request *request;\n\tsize_t block_size;\n\tint rc;\n\n\tDBF_EVENT(6, \"TCHAR:read\\n\");\n\tdevice = (struct tape_device *) filp->private_data;\n\n\t \n\tif(device->required_tapemarks) {\n\t\treturn tape_std_terminate_write(device);\n\t}\n\n\t \n\tif (device->char_data.block_size != 0) {\n\t\tif (count < device->char_data.block_size) {\n\t\t\tDBF_EVENT(3, \"TCHAR:read smaller than block \"\n\t\t\t\t  \"size was requested\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tblock_size = device->char_data.block_size;\n\t} else {\n\t\tblock_size = count;\n\t}\n\n\trc = tapechar_check_idalbuffer(device, block_size);\n\tif (rc)\n\t\treturn rc;\n\n\tDBF_EVENT(6, \"TCHAR:nbytes: %lx\\n\", block_size);\n\t \n\trequest = device->discipline->read_block(device, block_size);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\t \n\trc = tape_do_io(device, request);\n\tif (rc == 0) {\n\t\trc = block_size - request->rescnt;\n\t\tDBF_EVENT(6, \"TCHAR:rbytes:  %x\\n\", rc);\n\t\t \n\t\tif (idal_buffer_to_user(device->char_data.idal_buf,\n\t\t\t\t\tdata, rc) != 0)\n\t\t\trc = -EFAULT;\n\t}\n\ttape_free_request(request);\n\treturn rc;\n}\n\n \nstatic ssize_t\ntapechar_write(struct file *filp, const char __user *data, size_t count, loff_t *ppos)\n{\n\tstruct tape_device *device;\n\tstruct tape_request *request;\n\tsize_t block_size;\n\tsize_t written;\n\tint nblocks;\n\tint i, rc;\n\n\tDBF_EVENT(6, \"TCHAR:write\\n\");\n\tdevice = (struct tape_device *) filp->private_data;\n\t \n\tif (device->char_data.block_size != 0) {\n\t\tif (count < device->char_data.block_size) {\n\t\t\tDBF_EVENT(3, \"TCHAR:write smaller than block \"\n\t\t\t\t  \"size was requested\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tblock_size = device->char_data.block_size;\n\t\tnblocks = count / block_size;\n\t} else {\n\t\tblock_size = count;\n\t\tnblocks = 1;\n\t}\n\n\trc = tapechar_check_idalbuffer(device, block_size);\n\tif (rc)\n\t\treturn rc;\n\n\tDBF_EVENT(6,\"TCHAR:nbytes: %lx\\n\", block_size);\n\tDBF_EVENT(6, \"TCHAR:nblocks: %x\\n\", nblocks);\n\t \n\trequest = device->discipline->write_block(device, block_size);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\trc = 0;\n\twritten = 0;\n\tfor (i = 0; i < nblocks; i++) {\n\t\t \n\t\tif (idal_buffer_from_user(device->char_data.idal_buf,\n\t\t\t\t\t  data, block_size)) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\trc = tape_do_io(device, request);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tDBF_EVENT(6, \"TCHAR:wbytes: %lx\\n\",\n\t\t\t  block_size - request->rescnt);\n\t\twritten += block_size - request->rescnt;\n\t\tif (request->rescnt != 0)\n\t\t\tbreak;\n\t\tdata += block_size;\n\t}\n\ttape_free_request(request);\n\tif (rc == -ENOSPC) {\n\t\t \n\t\tif (device->discipline->process_eov)\n\t\t\tdevice->discipline->process_eov(device);\n\t\tif (written > 0)\n\t\t\trc = 0;\n\n\t}\n\n\t \n\tif (!rc)\n\t\tdevice->required_tapemarks = 2;\n\n\treturn rc ? rc : written;\n}\n\n \nstatic int\ntapechar_open (struct inode *inode, struct file *filp)\n{\n\tstruct tape_device *device;\n\tint minor, rc;\n\n\tDBF_EVENT(6, \"TCHAR:open: %i:%i\\n\",\n\t\timajor(file_inode(filp)),\n\t\timinor(file_inode(filp)));\n\n\tif (imajor(file_inode(filp)) != tapechar_major)\n\t\treturn -ENODEV;\n\n\tminor = iminor(file_inode(filp));\n\tdevice = tape_find_device(minor / TAPE_MINORS_PER_DEV);\n\tif (IS_ERR(device)) {\n\t\tDBF_EVENT(3, \"TCHAR:open: tape_find_device() failed\\n\");\n\t\treturn PTR_ERR(device);\n\t}\n\n\trc = tape_open(device);\n\tif (rc == 0) {\n\t\tfilp->private_data = device;\n\t\tstream_open(inode, filp);\n\t} else\n\t\ttape_put_device(device);\n\n\treturn rc;\n}\n\n \n\nstatic int\ntapechar_release(struct inode *inode, struct file *filp)\n{\n\tstruct tape_device *device;\n\n\tDBF_EVENT(6, \"TCHAR:release: %x\\n\", iminor(inode));\n\tdevice = (struct tape_device *) filp->private_data;\n\n\t \n\tif ((iminor(inode) & 1) != 0) {\n\t\tif (device->required_tapemarks)\n\t\t\ttape_std_terminate_write(device);\n\t\ttape_mtop(device, MTREW, 1);\n\t} else {\n\t\tif (device->required_tapemarks > 1) {\n\t\t\tif (tape_mtop(device, MTWEOF, 1) == 0)\n\t\t\t\tdevice->required_tapemarks--;\n\t\t}\n\t}\n\n\tif (device->char_data.idal_buf != NULL) {\n\t\tidal_buffer_free(device->char_data.idal_buf);\n\t\tdevice->char_data.idal_buf = NULL;\n\t}\n\ttape_release(device);\n\tfilp->private_data = NULL;\n\ttape_put_device(device);\n\n\treturn 0;\n}\n\n \nstatic int\n__tapechar_ioctl(struct tape_device *device,\n\t\t unsigned int no, void __user *data)\n{\n\tint rc;\n\n\tif (no == MTIOCTOP) {\n\t\tstruct mtop op;\n\n\t\tif (copy_from_user(&op, data, sizeof(op)) != 0)\n\t\t\treturn -EFAULT;\n\t\tif (op.mt_count < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tswitch (op.mt_op) {\n\t\t\tcase MTFSF:\n\t\t\tcase MTBSF:\n\t\t\tcase MTFSR:\n\t\t\tcase MTBSR:\n\t\t\tcase MTREW:\n\t\t\tcase MTOFFL:\n\t\t\tcase MTEOM:\n\t\t\tcase MTRETEN:\n\t\t\tcase MTBSFM:\n\t\t\tcase MTFSFM:\n\t\t\tcase MTSEEK:\n\t\t\t\tif (device->required_tapemarks)\n\t\t\t\t\ttape_std_terminate_write(device);\n\t\t}\n\t\trc = tape_mtop(device, op.mt_op, op.mt_count);\n\n\t\tif (op.mt_op == MTWEOF && rc == 0) {\n\t\t\tif (op.mt_count > device->required_tapemarks)\n\t\t\t\tdevice->required_tapemarks = 0;\n\t\t\telse\n\t\t\t\tdevice->required_tapemarks -= op.mt_count;\n\t\t}\n\t\treturn rc;\n\t}\n\tif (no == MTIOCPOS) {\n\t\t \n\t\tstruct mtpos pos;\n\n\t\trc = tape_mtop(device, MTTELL, 1);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tpos.mt_blkno = rc;\n\t\treturn put_user_mtpos(data, &pos);\n\t}\n\tif (no == MTIOCGET) {\n\t\t \n\t\tstruct mtget get;\n\n\t\tmemset(&get, 0, sizeof(get));\n\t\tget.mt_type = MT_ISUNKNOWN;\n\t\tget.mt_resid = 0  ;\n\t\tget.mt_dsreg =\n\t\t\t((device->char_data.block_size << MT_ST_BLKSIZE_SHIFT)\n\t\t\t & MT_ST_BLKSIZE_MASK);\n\t\t \n\t\tget.mt_gstat = 0;\n\t\tget.mt_erreg = 0;\n\t\tget.mt_fileno = 0;\n\t\tget.mt_gstat  = device->tape_generic_status;\n\n\t\tif (device->medium_state == MS_LOADED) {\n\t\t\trc = tape_mtop(device, MTTELL, 1);\n\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\tif (rc == 0)\n\t\t\t\tget.mt_gstat |= GMT_BOT(~0);\n\n\t\t\tget.mt_blkno = rc;\n\t\t}\n\n\t\treturn put_user_mtget(data, &get);\n\t}\n\t \n\tif (device->discipline->ioctl_fn == NULL)\n\t\treturn -EINVAL;\n\treturn device->discipline->ioctl_fn(device, no, (unsigned long)data);\n}\n\nstatic long\ntapechar_ioctl(struct file *filp, unsigned int no, unsigned long data)\n{\n\tstruct tape_device *device;\n\tlong rc;\n\n\tDBF_EVENT(6, \"TCHAR:ioct\\n\");\n\n\tdevice = (struct tape_device *) filp->private_data;\n\tmutex_lock(&device->mutex);\n\trc = __tapechar_ioctl(device, no, (void __user *)data);\n\tmutex_unlock(&device->mutex);\n\treturn rc;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\ntapechar_compat_ioctl(struct file *filp, unsigned int no, unsigned long data)\n{\n\tstruct tape_device *device = filp->private_data;\n\tlong rc;\n\n\tif (no == MTIOCPOS32)\n\t\tno = MTIOCPOS;\n\telse if (no == MTIOCGET32)\n\t\tno = MTIOCGET;\n\n\tmutex_lock(&device->mutex);\n\trc = __tapechar_ioctl(device, no, compat_ptr(data));\n\tmutex_unlock(&device->mutex);\n\treturn rc;\n}\n#endif  \n\n \nint\ntapechar_init (void)\n{\n\tdev_t\tdev;\n\n\tif (alloc_chrdev_region(&dev, 0, 256, \"tape\") != 0)\n\t\treturn -1;\n\n\ttapechar_major = MAJOR(dev);\n\n\treturn 0;\n}\n\n \nvoid\ntapechar_exit(void)\n{\n\tunregister_chrdev_region(MKDEV(tapechar_major, 0), 256);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}