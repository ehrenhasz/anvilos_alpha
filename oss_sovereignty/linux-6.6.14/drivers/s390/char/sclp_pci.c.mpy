{
  "module_name": "sclp_pci.c",
  "hash_id": "4ef4a42529cadeaf7b764a26854a2b7ce188b7a2d3dbadf174f7f7c6520c873e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_pci.c",
  "human_readable_source": "\n \n#define KMSG_COMPONENT \"sclp_cmd\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/err.h>\n\n#include <asm/sclp.h>\n\n#include \"sclp.h\"\n\n#define SCLP_CMDW_CONFIGURE_PCI\t\t\t0x001a0001\n#define SCLP_CMDW_DECONFIGURE_PCI\t\t0x001b0001\n\n#define SCLP_ATYPE_PCI\t\t\t\t2\n\n#define SCLP_ERRNOTIFY_AQ_RESET\t\t\t0\n#define SCLP_ERRNOTIFY_AQ_REPAIR\t\t1\n#define SCLP_ERRNOTIFY_AQ_INFO_LOG\t\t2\n\nstatic DEFINE_MUTEX(sclp_pci_mutex);\nstatic struct sclp_register sclp_pci_event = {\n\t.send_mask = EVTYP_ERRNOTIFY_MASK,\n};\n\nstruct err_notify_evbuf {\n\tstruct evbuf_header header;\n\tu8 action;\n\tu8 atype;\n\tu32 fh;\n\tu32 fid;\n\tu8 data[];\n} __packed;\n\nstruct err_notify_sccb {\n\tstruct sccb_header header;\n\tstruct err_notify_evbuf evbuf;\n} __packed;\n\nstruct pci_cfg_sccb {\n\tstruct sccb_header header;\n\tu8 atype;\t\t \n\tu8 reserved1;\n\tu16 reserved2;\n\tu32 aid;\t\t \n} __packed;\n\nstatic int do_pci_configure(sclp_cmdw_t cmd, u32 fid)\n{\n\tstruct pci_cfg_sccb *sccb;\n\tint rc;\n\n\tif (!SCLP_HAS_PCI_RECONFIG)\n\t\treturn -EOPNOTSUPP;\n\n\tsccb = (struct pci_cfg_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\n\tsccb->header.length = PAGE_SIZE;\n\tsccb->atype = SCLP_ATYPE_PCI;\n\tsccb->aid = fid;\n\trc = sclp_sync_request(cmd, sccb);\n\tif (rc)\n\t\tgoto out;\n\tswitch (sccb->header.response_code) {\n\tcase 0x0020:\n\tcase 0x0120:\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"configure PCI I/O adapter failed: cmd=0x%08x  response=0x%04x\\n\",\n\t\t\tcmd, sccb->header.response_code);\n\t\trc = -EIO;\n\t\tbreak;\n\t}\nout:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n\nint sclp_pci_configure(u32 fid)\n{\n\treturn do_pci_configure(SCLP_CMDW_CONFIGURE_PCI, fid);\n}\nEXPORT_SYMBOL(sclp_pci_configure);\n\nint sclp_pci_deconfigure(u32 fid)\n{\n\treturn do_pci_configure(SCLP_CMDW_DECONFIGURE_PCI, fid);\n}\nEXPORT_SYMBOL(sclp_pci_deconfigure);\n\nstatic void sclp_pci_callback(struct sclp_req *req, void *data)\n{\n\tstruct completion *completion = data;\n\n\tcomplete(completion);\n}\n\nstatic int sclp_pci_check_report(struct zpci_report_error_header *report)\n{\n\tif (report->version != 1)\n\t\treturn -EINVAL;\n\n\tswitch (report->action) {\n\tcase SCLP_ERRNOTIFY_AQ_RESET:\n\tcase SCLP_ERRNOTIFY_AQ_REPAIR:\n\tcase SCLP_ERRNOTIFY_AQ_INFO_LOG:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (report->length > (PAGE_SIZE - sizeof(struct err_notify_sccb)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint sclp_pci_report(struct zpci_report_error_header *report, u32 fh, u32 fid)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct err_notify_sccb *sccb;\n\tstruct sclp_req req;\n\tint ret;\n\n\tret = sclp_pci_check_report(report);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&sclp_pci_mutex);\n\tret = sclp_register(&sclp_pci_event);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (!(sclp_pci_event.sclp_receive_mask & EVTYP_ERRNOTIFY_MASK)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_unregister;\n\t}\n\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.callback_data = &completion;\n\treq.callback = sclp_pci_callback;\n\treq.command = SCLP_CMDW_WRITE_EVENT_DATA;\n\treq.status = SCLP_REQ_FILLED;\n\treq.sccb = sccb;\n\n\tsccb->evbuf.header.length = sizeof(sccb->evbuf) + report->length;\n\tsccb->evbuf.header.type = EVTYP_ERRNOTIFY;\n\tsccb->header.length = sizeof(sccb->header) + sccb->evbuf.header.length;\n\n\tsccb->evbuf.action = report->action;\n\tsccb->evbuf.atype = SCLP_ATYPE_PCI;\n\tsccb->evbuf.fh = fh;\n\tsccb->evbuf.fid = fid;\n\n\tmemcpy(sccb->evbuf.data, report->data, report->length);\n\n\tret = sclp_add_request(&req);\n\tif (ret)\n\t\tgoto out_free_req;\n\n\twait_for_completion(&completion);\n\tif (req.status != SCLP_REQ_DONE) {\n\t\tpr_warn(\"request failed (status=0x%02x)\\n\",\n\t\t\treq.status);\n\t\tret = -EIO;\n\t\tgoto out_free_req;\n\t}\n\n\tif (sccb->header.response_code != 0x0020) {\n\t\tpr_warn(\"request failed with response code 0x%x\\n\",\n\t\t\tsccb->header.response_code);\n\t\tret = -EIO;\n\t}\n\nout_free_req:\n\tfree_page((unsigned long) sccb);\nout_unregister:\n\tsclp_unregister(&sclp_pci_event);\nout_unlock:\n\tmutex_unlock(&sclp_pci_mutex);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}