{
  "module_name": "fs3270.c",
  "hash_id": "ece6562bfbc6df4418b195d4b4df388ecc46d96c4d666d3eadd8ab6e57e5b7c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/fs3270.c",
  "human_readable_source": "\n \n\n#include <linux/memblock.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/compat.h>\n#include <linux/sched/signal.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <uapi/asm/fs3270.h>\n#include <asm/ccwdev.h>\n#include <asm/cio.h>\n#include <asm/ebcdic.h>\n#include <asm/idals.h>\n\n#include \"raw3270.h\"\n#include \"ctrlchar.h\"\n\nstatic struct raw3270_fn fs3270_fn;\n\nstruct fs3270 {\n\tstruct raw3270_view view;\n\tstruct pid *fs_pid;\t\t \n\tint read_command;\t\t \n\tint write_command;\t\t \n\tint attention;\t\t\t \n\tint active;\t\t\t \n\tstruct raw3270_request *init;\t \n\twait_queue_head_t wait;\t\t \n\tstruct idal_buffer *rdbuf;\t \n\tsize_t rdbuf_size;\t\t \n};\n\nstatic DEFINE_MUTEX(fs3270_mutex);\n\nstatic void fs3270_wake_up(struct raw3270_request *rq, void *data)\n{\n\twake_up((wait_queue_head_t *)data);\n}\n\nstatic inline int fs3270_working(struct fs3270 *fp)\n{\n\t \n\treturn fp->active && raw3270_request_final(fp->init);\n}\n\nstatic int fs3270_do_io(struct raw3270_view *view, struct raw3270_request *rq)\n{\n\tstruct fs3270 *fp;\n\tint rc;\n\n\tfp = (struct fs3270 *)view;\n\trq->callback = fs3270_wake_up;\n\trq->callback_data = &fp->wait;\n\n\tdo {\n\t\tif (!fs3270_working(fp)) {\n\t\t\t \n\t\t\trc = wait_event_interruptible(fp->wait,\n\t\t\t\t\t\t      fs3270_working(fp));\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = raw3270_start(view, rq);\n\t\tif (rc == 0) {\n\t\t\t \n\t\t\twait_event(fp->wait, raw3270_request_final(rq));\n\t\t}\n\t} while (rc == -EACCES);\n\treturn rc;\n}\n\n \nstatic void fs3270_reset_callback(struct raw3270_request *rq, void *data)\n{\n\tstruct fs3270 *fp;\n\n\tfp = (struct fs3270 *)rq->view;\n\traw3270_request_reset(rq);\n\twake_up(&fp->wait);\n}\n\nstatic void fs3270_restore_callback(struct raw3270_request *rq, void *data)\n{\n\tstruct fs3270 *fp;\n\n\tfp = (struct fs3270 *)rq->view;\n\tif (rq->rc != 0 || rq->rescnt != 0) {\n\t\tif (fp->fs_pid)\n\t\t\tkill_pid(fp->fs_pid, SIGHUP, 1);\n\t}\n\tfp->rdbuf_size = 0;\n\traw3270_request_reset(rq);\n\twake_up(&fp->wait);\n}\n\nstatic int fs3270_activate(struct raw3270_view *view)\n{\n\tstruct fs3270 *fp;\n\tchar *cp;\n\tint rc;\n\n\tfp = (struct fs3270 *)view;\n\n\t \n\tif (!raw3270_request_final(fp->init))\n\t\treturn 0;\n\n\traw3270_request_set_cmd(fp->init, TC_EWRITEA);\n\traw3270_request_set_idal(fp->init, fp->rdbuf);\n\tfp->init->rescnt = 0;\n\tcp = fp->rdbuf->data[0];\n\tif (fp->rdbuf_size == 0) {\n\t\t \n\t\tfp->init->ccw.count = 1;\n\t\tfp->init->callback = fs3270_reset_callback;\n\t\tcp[0] = 0;\n\t} else {\n\t\t \n\t\tfp->init->ccw.count = fp->rdbuf_size;\n\t\tfp->init->callback = fs3270_restore_callback;\n\t\tcp[0] = TW_KR;\n\t\tcp[1] = TO_SBA;\n\t\tcp[2] = cp[6];\n\t\tcp[3] = cp[7];\n\t\tcp[4] = TO_IC;\n\t\tcp[5] = TO_SBA;\n\t\tcp[6] = 0x40;\n\t\tcp[7] = 0x40;\n\t}\n\trc = raw3270_start_locked(view, fp->init);\n\tfp->init->rc = rc;\n\tif (rc)\n\t\tfp->init->callback(fp->init, NULL);\n\telse\n\t\tfp->active = 1;\n\treturn rc;\n}\n\n \nstatic void fs3270_save_callback(struct raw3270_request *rq, void *data)\n{\n\tstruct fs3270 *fp;\n\n\tfp = (struct fs3270 *)rq->view;\n\n\t \n\tfp->rdbuf->data[0] -= 5;\n\tfp->rdbuf->size += 5;\n\n\t \n\tif (rq->rc != 0 || rq->rescnt == 0) {\n\t\tif (fp->fs_pid)\n\t\t\tkill_pid(fp->fs_pid, SIGHUP, 1);\n\t\tfp->rdbuf_size = 0;\n\t} else {\n\t\tfp->rdbuf_size = fp->rdbuf->size - rq->rescnt;\n\t}\n\traw3270_request_reset(rq);\n\twake_up(&fp->wait);\n}\n\nstatic void fs3270_deactivate(struct raw3270_view *view)\n{\n\tstruct fs3270 *fp;\n\n\tfp = (struct fs3270 *)view;\n\tfp->active = 0;\n\n\t \n\tif (!raw3270_request_final(fp->init))\n\t\treturn;\n\n\t \n\traw3270_request_set_cmd(fp->init, TC_RDBUF);\n\t \n\tfp->rdbuf->data[0] += 5;\n\tfp->rdbuf->size -= 5;\n\traw3270_request_set_idal(fp->init, fp->rdbuf);\n\tfp->init->rescnt = 0;\n\tfp->init->callback = fs3270_save_callback;\n\n\t \n\tfp->init->rc = raw3270_start_locked(view, fp->init);\n\tif (fp->init->rc)\n\t\tfp->init->callback(fp->init, NULL);\n}\n\nstatic void fs3270_irq(struct fs3270 *fp, struct raw3270_request *rq,\n\t\t       struct irb *irb)\n{\n\t \n\tif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\n\t\tfp->attention = 1;\n\t\twake_up(&fp->wait);\n\t}\n\n\tif (rq) {\n\t\tif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\n\t\t\trq->rc = -EIO;\n\t\telse\n\t\t\t \n\t\t\trq->rescnt = irb->scsw.cmd.count;\n\t}\n}\n\n \nstatic ssize_t fs3270_read(struct file *filp, char __user *data,\n\t\t\t   size_t count, loff_t *off)\n{\n\tstruct fs3270 *fp;\n\tstruct raw3270_request *rq;\n\tstruct idal_buffer *ib;\n\tssize_t rc;\n\n\tif (count == 0 || count > 65535)\n\t\treturn -EINVAL;\n\tfp = filp->private_data;\n\tif (!fp)\n\t\treturn -ENODEV;\n\tib = idal_buffer_alloc(count, 0);\n\tif (IS_ERR(ib))\n\t\treturn -ENOMEM;\n\trq = raw3270_request_alloc(0);\n\tif (!IS_ERR(rq)) {\n\t\tif (fp->read_command == 0 && fp->write_command != 0)\n\t\t\tfp->read_command = 6;\n\t\traw3270_request_set_cmd(rq, fp->read_command ? : 2);\n\t\traw3270_request_set_idal(rq, ib);\n\t\trc = wait_event_interruptible(fp->wait, fp->attention);\n\t\tfp->attention = 0;\n\t\tif (rc == 0) {\n\t\t\trc = fs3270_do_io(&fp->view, rq);\n\t\t\tif (rc == 0) {\n\t\t\t\tcount -= rq->rescnt;\n\t\t\t\tif (idal_buffer_to_user(ib, data, count) != 0)\n\t\t\t\t\trc = -EFAULT;\n\t\t\t\telse\n\t\t\t\t\trc = count;\n\t\t\t}\n\t\t}\n\t\traw3270_request_free(rq);\n\t} else {\n\t\trc = PTR_ERR(rq);\n\t}\n\tidal_buffer_free(ib);\n\treturn rc;\n}\n\n \nstatic ssize_t fs3270_write(struct file *filp, const char __user *data,\n\t\t\t    size_t count, loff_t *off)\n{\n\tstruct fs3270 *fp;\n\tstruct raw3270_request *rq;\n\tstruct idal_buffer *ib;\n\tint write_command;\n\tssize_t rc;\n\n\tfp = filp->private_data;\n\tif (!fp)\n\t\treturn -ENODEV;\n\tib = idal_buffer_alloc(count, 0);\n\tif (IS_ERR(ib))\n\t\treturn -ENOMEM;\n\trq = raw3270_request_alloc(0);\n\tif (!IS_ERR(rq)) {\n\t\tif (idal_buffer_from_user(ib, data, count) == 0) {\n\t\t\twrite_command = fp->write_command ? : 1;\n\t\t\tif (write_command == 5)\n\t\t\t\twrite_command = 13;\n\t\t\traw3270_request_set_cmd(rq, write_command);\n\t\t\traw3270_request_set_idal(rq, ib);\n\t\t\trc = fs3270_do_io(&fp->view, rq);\n\t\t\tif (rc == 0)\n\t\t\t\trc = count - rq->rescnt;\n\t\t} else {\n\t\t\trc = -EFAULT;\n\t\t}\n\t\traw3270_request_free(rq);\n\t} else {\n\t\trc = PTR_ERR(rq);\n\t}\n\tidal_buffer_free(ib);\n\treturn rc;\n}\n\n \nstatic long fs3270_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tchar __user *argp;\n\tstruct fs3270 *fp;\n\tstruct raw3270_iocb iocb;\n\tint rc;\n\n\tfp = filp->private_data;\n\tif (!fp)\n\t\treturn -ENODEV;\n\tif (is_compat_task())\n\t\targp = compat_ptr(arg);\n\telse\n\t\targp = (char __user *)arg;\n\trc = 0;\n\tmutex_lock(&fs3270_mutex);\n\tswitch (cmd) {\n\tcase TUBICMD:\n\t\tfp->read_command = arg;\n\t\tbreak;\n\tcase TUBOCMD:\n\t\tfp->write_command = arg;\n\t\tbreak;\n\tcase TUBGETI:\n\t\trc = put_user(fp->read_command, argp);\n\t\tbreak;\n\tcase TUBGETO:\n\t\trc = put_user(fp->write_command, argp);\n\t\tbreak;\n\tcase TUBGETMOD:\n\t\tiocb.model = fp->view.model;\n\t\tiocb.line_cnt = fp->view.rows;\n\t\tiocb.col_cnt = fp->view.cols;\n\t\tiocb.pf_cnt = 24;\n\t\tiocb.re_cnt = 20;\n\t\tiocb.map = 0;\n\t\tif (copy_to_user(argp, &iocb, sizeof(struct raw3270_iocb)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&fs3270_mutex);\n\treturn rc;\n}\n\n \nstatic struct fs3270 *fs3270_alloc_view(void)\n{\n\tstruct fs3270 *fp;\n\n\tfp = kzalloc(sizeof(*fp), GFP_KERNEL);\n\tif (!fp)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfp->init = raw3270_request_alloc(0);\n\tif (IS_ERR(fp->init)) {\n\t\tkfree(fp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\treturn fp;\n}\n\n \nstatic void fs3270_free_view(struct raw3270_view *view)\n{\n\tstruct fs3270 *fp;\n\n\tfp = (struct fs3270 *)view;\n\tif (fp->rdbuf)\n\t\tidal_buffer_free(fp->rdbuf);\n\traw3270_request_free(((struct fs3270 *)view)->init);\n\tkfree(view);\n}\n\n \nstatic void fs3270_release(struct raw3270_view *view)\n{\n\tstruct fs3270 *fp;\n\n\tfp = (struct fs3270 *)view;\n\tif (fp->fs_pid)\n\t\tkill_pid(fp->fs_pid, SIGHUP, 1);\n}\n\n \nstatic struct raw3270_fn fs3270_fn = {\n\t.activate = fs3270_activate,\n\t.deactivate = fs3270_deactivate,\n\t.intv = (void *)fs3270_irq,\n\t.release = fs3270_release,\n\t.free = fs3270_free_view\n};\n\n \nstatic int fs3270_open(struct inode *inode, struct file *filp)\n{\n\tstruct fs3270 *fp;\n\tstruct idal_buffer *ib;\n\tint minor, rc = 0;\n\n\tif (imajor(file_inode(filp)) != IBM_FS3270_MAJOR)\n\t\treturn -ENODEV;\n\tminor = iminor(file_inode(filp));\n\t \n\tif (minor == 0) {\n\t\tstruct tty_struct *tty = get_current_tty();\n\n\t\tif (!tty || tty->driver->major != IBM_TTY3270_MAJOR) {\n\t\t\ttty_kref_put(tty);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tminor = tty->index;\n\t\ttty_kref_put(tty);\n\t}\n\tmutex_lock(&fs3270_mutex);\n\t \n\tfp = (struct fs3270 *)raw3270_find_view(&fs3270_fn, minor);\n\tif (!IS_ERR(fp)) {\n\t\traw3270_put_view(&fp->view);\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\t \n\tfp = fs3270_alloc_view();\n\tif (IS_ERR(fp)) {\n\t\trc = PTR_ERR(fp);\n\t\tgoto out;\n\t}\n\n\tinit_waitqueue_head(&fp->wait);\n\tfp->fs_pid = get_pid(task_pid(current));\n\trc = raw3270_add_view(&fp->view, &fs3270_fn, minor,\n\t\t\t      RAW3270_VIEW_LOCK_BH);\n\tif (rc) {\n\t\tfs3270_free_view(&fp->view);\n\t\tgoto out;\n\t}\n\n\t \n\tib = idal_buffer_alloc(2 * fp->view.rows * fp->view.cols + 5, 0);\n\tif (IS_ERR(ib)) {\n\t\traw3270_put_view(&fp->view);\n\t\traw3270_del_view(&fp->view);\n\t\trc = PTR_ERR(ib);\n\t\tgoto out;\n\t}\n\tfp->rdbuf = ib;\n\n\trc = raw3270_activate_view(&fp->view);\n\tif (rc) {\n\t\traw3270_put_view(&fp->view);\n\t\traw3270_del_view(&fp->view);\n\t\tgoto out;\n\t}\n\tstream_open(inode, filp);\n\tfilp->private_data = fp;\nout:\n\tmutex_unlock(&fs3270_mutex);\n\treturn rc;\n}\n\n \nstatic int fs3270_close(struct inode *inode, struct file *filp)\n{\n\tstruct fs3270 *fp;\n\n\tfp = filp->private_data;\n\tfilp->private_data = NULL;\n\tif (fp) {\n\t\tput_pid(fp->fs_pid);\n\t\tfp->fs_pid = NULL;\n\t\traw3270_reset(&fp->view);\n\t\traw3270_put_view(&fp->view);\n\t\traw3270_del_view(&fp->view);\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations fs3270_fops = {\n\t.owner\t\t = THIS_MODULE,\t\t \n\t.read\t\t = fs3270_read,\t\t \n\t.write\t\t = fs3270_write,\t \n\t.unlocked_ioctl\t = fs3270_ioctl,\t \n\t.compat_ioctl\t = fs3270_ioctl,\t \n\t.open\t\t = fs3270_open,\t\t \n\t.release\t = fs3270_close,\t \n\t.llseek\t\t= no_llseek,\n};\n\nstatic void fs3270_create_cb(int minor)\n{\n\t__register_chrdev(IBM_FS3270_MAJOR, minor, 1, \"tub\", &fs3270_fops);\n\tdevice_create(class3270, NULL, MKDEV(IBM_FS3270_MAJOR, minor),\n\t\t      NULL, \"3270/tub%d\", minor);\n}\n\nstatic void fs3270_destroy_cb(int minor)\n{\n\tdevice_destroy(class3270, MKDEV(IBM_FS3270_MAJOR, minor));\n\t__unregister_chrdev(IBM_FS3270_MAJOR, minor, 1, \"tub\");\n}\n\nstatic struct raw3270_notifier fs3270_notifier = {\n\t.create = fs3270_create_cb,\n\t.destroy = fs3270_destroy_cb,\n};\n\n \nstatic int __init fs3270_init(void)\n{\n\tint rc;\n\n\trc = __register_chrdev(IBM_FS3270_MAJOR, 0, 1, \"fs3270\", &fs3270_fops);\n\tif (rc)\n\t\treturn rc;\n\tdevice_create(class3270, NULL, MKDEV(IBM_FS3270_MAJOR, 0),\n\t\t      NULL, \"3270/tub\");\n\traw3270_register_notifier(&fs3270_notifier);\n\treturn 0;\n}\n\nstatic void __exit fs3270_exit(void)\n{\n\traw3270_unregister_notifier(&fs3270_notifier);\n\tdevice_destroy(class3270, MKDEV(IBM_FS3270_MAJOR, 0));\n\t__unregister_chrdev(IBM_FS3270_MAJOR, 0, 1, \"fs3270\");\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(IBM_FS3270_MAJOR);\n\nmodule_init(fs3270_init);\nmodule_exit(fs3270_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}