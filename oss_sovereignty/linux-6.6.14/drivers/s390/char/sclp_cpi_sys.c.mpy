{
  "module_name": "sclp_cpi_sys.c",
  "hash_id": "e41ce56bb25a98b526790d394332cf27895908b4da07441f44cd869bba4931ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_cpi_sys.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"sclp_cpi\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/kmod.h>\n#include <linux/timer.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <asm/ebcdic.h>\n#include <asm/sclp.h>\n\n#include \"sclp.h\"\n#include \"sclp_rw.h\"\n#include \"sclp_cpi_sys.h\"\n\n#define CPI_LENGTH_NAME 8\n#define CPI_LENGTH_LEVEL 16\n\nstatic DEFINE_MUTEX(sclp_cpi_mutex);\n\nstruct cpi_evbuf {\n\tstruct evbuf_header header;\n\tu8\tid_format;\n\tu8\treserved0;\n\tu8\tsystem_type[CPI_LENGTH_NAME];\n\tu64\treserved1;\n\tu8\tsystem_name[CPI_LENGTH_NAME];\n\tu64\treserved2;\n\tu64\tsystem_level;\n\tu64\treserved3;\n\tu8\tsysplex_name[CPI_LENGTH_NAME];\n\tu8\treserved4[16];\n} __attribute__((packed));\n\nstruct cpi_sccb {\n\tstruct sccb_header header;\n\tstruct cpi_evbuf cpi_evbuf;\n} __attribute__((packed));\n\nstatic struct sclp_register sclp_cpi_event = {\n\t.send_mask = EVTYP_CTLPROGIDENT_MASK,\n};\n\nstatic char system_name[CPI_LENGTH_NAME + 1];\nstatic char sysplex_name[CPI_LENGTH_NAME + 1];\nstatic char system_type[CPI_LENGTH_NAME + 1];\nstatic u64 system_level;\n\nstatic void set_data(char *field, char *data)\n{\n\tmemset(field, ' ', CPI_LENGTH_NAME);\n\tmemcpy(field, data, strlen(data));\n\tsclp_ascebc_str(field, CPI_LENGTH_NAME);\n}\n\nstatic void cpi_callback(struct sclp_req *req, void *data)\n{\n\tstruct completion *completion = data;\n\n\tcomplete(completion);\n}\n\nstatic struct sclp_req *cpi_prepare_req(void)\n{\n\tstruct sclp_req *req;\n\tstruct cpi_sccb *sccb;\n\tstruct cpi_evbuf *evb;\n\n\treq = kzalloc(sizeof(struct sclp_req), GFP_KERNEL);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsccb = (struct cpi_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb) {\n\t\tkfree(req);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tsccb->header.length = sizeof(struct cpi_sccb);\n\tsccb->cpi_evbuf.header.length = sizeof(struct cpi_evbuf);\n\tsccb->cpi_evbuf.header.type = EVTYP_CTLPROGIDENT;\n\tevb = &sccb->cpi_evbuf;\n\n\t \n\tset_data(evb->system_type, system_type);\n\n\t \n\tset_data(evb->system_name, system_name);\n\n\t \n\tevb->system_level = system_level;\n\n\t \n\tset_data(evb->sysplex_name, sysplex_name);\n\n\t \n\treq->command = SCLP_CMDW_WRITE_EVENT_DATA;\n\treq->sccb = sccb;\n\treq->status = SCLP_REQ_FILLED;\n\treq->callback = cpi_callback;\n\treturn req;\n}\n\nstatic void cpi_free_req(struct sclp_req *req)\n{\n\tfree_page((unsigned long) req->sccb);\n\tkfree(req);\n}\n\nstatic int cpi_req(void)\n{\n\tstruct completion completion;\n\tstruct sclp_req *req;\n\tint rc;\n\tint response;\n\n\trc = sclp_register(&sclp_cpi_event);\n\tif (rc)\n\t\tgoto out;\n\tif (!(sclp_cpi_event.sclp_receive_mask & EVTYP_CTLPROGIDENT_MASK)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out_unregister;\n\t}\n\n\treq = cpi_prepare_req();\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\tgoto out_unregister;\n\t}\n\n\tinit_completion(&completion);\n\treq->callback_data = &completion;\n\n\t \n\trc = sclp_add_request(req);\n\tif (rc)\n\t\tgoto out_free_req;\n\n\twait_for_completion(&completion);\n\n\tif (req->status != SCLP_REQ_DONE) {\n\t\tpr_warn(\"request failed (status=0x%02x)\\n\", req->status);\n\t\trc = -EIO;\n\t\tgoto out_free_req;\n\t}\n\n\tresponse = ((struct cpi_sccb *) req->sccb)->header.response_code;\n\tif (response != 0x0020) {\n\t\tpr_warn(\"request failed with response code 0x%x\\n\", response);\n\t\trc = -EIO;\n\t}\n\nout_free_req:\n\tcpi_free_req(req);\n\nout_unregister:\n\tsclp_unregister(&sclp_cpi_event);\n\nout:\n\treturn rc;\n}\n\nstatic int check_string(const char *attr, const char *str)\n{\n\tsize_t len;\n\tsize_t i;\n\n\tlen = strlen(str);\n\n\tif ((len > 0) && (str[len - 1] == '\\n'))\n\t\tlen--;\n\n\tif (len > CPI_LENGTH_NAME)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < len ; i++) {\n\t\tif (isalpha(str[i]) || isdigit(str[i]) ||\n\t\t    strchr(\"$@# \", str[i]))\n\t\t\tcontinue;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void set_string(char *attr, const char *value)\n{\n\tsize_t len;\n\tsize_t i;\n\n\tlen = strlen(value);\n\n\tif ((len > 0) && (value[len - 1] == '\\n'))\n\t\tlen--;\n\n\tfor (i = 0; i < CPI_LENGTH_NAME; i++) {\n\t\tif (i < len)\n\t\t\tattr[i] = toupper(value[i]);\n\t\telse\n\t\t\tattr[i] = ' ';\n\t}\n}\n\nstatic ssize_t system_name_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *page)\n{\n\tint rc;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\trc = snprintf(page, PAGE_SIZE, \"%s\\n\", system_name);\n\tmutex_unlock(&sclp_cpi_mutex);\n\treturn rc;\n}\n\nstatic ssize_t system_name_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf,\n\tsize_t len)\n{\n\tint rc;\n\n\trc = check_string(\"system_name\", buf);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\tset_string(system_name, buf);\n\tmutex_unlock(&sclp_cpi_mutex);\n\n\treturn len;\n}\n\nstatic struct kobj_attribute system_name_attr =\n\t__ATTR(system_name, 0644, system_name_show, system_name_store);\n\nstatic ssize_t sysplex_name_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *page)\n{\n\tint rc;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\trc = snprintf(page, PAGE_SIZE, \"%s\\n\", sysplex_name);\n\tmutex_unlock(&sclp_cpi_mutex);\n\treturn rc;\n}\n\nstatic ssize_t sysplex_name_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf,\n\tsize_t len)\n{\n\tint rc;\n\n\trc = check_string(\"sysplex_name\", buf);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\tset_string(sysplex_name, buf);\n\tmutex_unlock(&sclp_cpi_mutex);\n\n\treturn len;\n}\n\nstatic struct kobj_attribute sysplex_name_attr =\n\t__ATTR(sysplex_name, 0644, sysplex_name_show, sysplex_name_store);\n\nstatic ssize_t system_type_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *page)\n{\n\tint rc;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\trc = snprintf(page, PAGE_SIZE, \"%s\\n\", system_type);\n\tmutex_unlock(&sclp_cpi_mutex);\n\treturn rc;\n}\n\nstatic ssize_t system_type_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf,\n\tsize_t len)\n{\n\tint rc;\n\n\trc = check_string(\"system_type\", buf);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\tset_string(system_type, buf);\n\tmutex_unlock(&sclp_cpi_mutex);\n\n\treturn len;\n}\n\nstatic struct kobj_attribute system_type_attr =\n\t__ATTR(system_type, 0644, system_type_show, system_type_store);\n\nstatic ssize_t system_level_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *page)\n{\n\tunsigned long long level;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\tlevel = system_level;\n\tmutex_unlock(&sclp_cpi_mutex);\n\treturn snprintf(page, PAGE_SIZE, \"%#018llx\\n\", level);\n}\n\nstatic ssize_t system_level_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf,\n\tsize_t len)\n{\n\tunsigned long long level;\n\tchar *endp;\n\n\tlevel = simple_strtoull(buf, &endp, 16);\n\n\tif (endp == buf)\n\t\treturn -EINVAL;\n\tif (*endp == '\\n')\n\t\tendp++;\n\tif (*endp)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\tsystem_level = level;\n\tmutex_unlock(&sclp_cpi_mutex);\n\treturn len;\n}\n\nstatic struct kobj_attribute system_level_attr =\n\t__ATTR(system_level, 0644, system_level_show, system_level_store);\n\nstatic ssize_t set_store(struct kobject *kobj,\n\t\t\t struct kobj_attribute *attr,\n\t\t\t const char *buf, size_t len)\n{\n\tint rc;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\trc = cpi_req();\n\tmutex_unlock(&sclp_cpi_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\treturn len;\n}\n\nstatic struct kobj_attribute set_attr = __ATTR(set, 0200, NULL, set_store);\n\nstatic struct attribute *cpi_attrs[] = {\n\t&system_name_attr.attr,\n\t&sysplex_name_attr.attr,\n\t&system_type_attr.attr,\n\t&system_level_attr.attr,\n\t&set_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group cpi_attr_group = {\n\t.attrs = cpi_attrs,\n};\n\nstatic struct kset *cpi_kset;\n\nint sclp_cpi_set_data(const char *system, const char *sysplex, const char *type,\n\t\t      const u64 level)\n{\n\tint rc;\n\n\trc = check_string(\"system_name\", system);\n\tif (rc)\n\t\treturn rc;\n\trc = check_string(\"sysplex_name\", sysplex);\n\tif (rc)\n\t\treturn rc;\n\trc = check_string(\"system_type\", type);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&sclp_cpi_mutex);\n\tset_string(system_name, system);\n\tset_string(sysplex_name, sysplex);\n\tset_string(system_type, type);\n\tsystem_level = level;\n\n\trc = cpi_req();\n\tmutex_unlock(&sclp_cpi_mutex);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(sclp_cpi_set_data);\n\nstatic int __init cpi_init(void)\n{\n\tint rc;\n\n\tcpi_kset = kset_create_and_add(\"cpi\", NULL, firmware_kobj);\n\tif (!cpi_kset)\n\t\treturn -ENOMEM;\n\n\trc = sysfs_create_group(&cpi_kset->kobj, &cpi_attr_group);\n\tif (rc)\n\t\tkset_unregister(cpi_kset);\n\n\treturn rc;\n}\n\n__initcall(cpi_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}