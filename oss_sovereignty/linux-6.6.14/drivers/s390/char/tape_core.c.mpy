{
  "module_name": "tape_core.c",
  "hash_id": "c86521e593a6384381a182e63bda13ffb3d1216aefb5d5a2d2561634ca3d1578",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/tape_core.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"tape\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\t     \n#include <linux/kmod.h>\t     \n#include <linux/spinlock.h>  \n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <asm/types.h>\t     \n\n#define TAPE_DBF_AREA\ttape_core_dbf\n\n#include \"tape.h\"\n#include \"tape_std.h\"\n\n#define LONG_BUSY_TIMEOUT 180  \n\nstatic void __tape_do_irq (struct ccw_device *, unsigned long, struct irb *);\nstatic void tape_delayed_next_request(struct work_struct *);\nstatic void tape_long_busy_timeout(struct timer_list *t);\n\n \nstatic LIST_HEAD(tape_device_list);\nstatic DEFINE_RWLOCK(tape_device_lock);\n\n \ndebug_info_t *TAPE_DBF_AREA = NULL;\nEXPORT_SYMBOL(TAPE_DBF_AREA);\n\n \nconst char *tape_state_verbose[TS_SIZE] =\n{\n\t[TS_UNUSED]   = \"UNUSED\",\n\t[TS_IN_USE]   = \"IN_USE\",\n\t[TS_BLKUSE]   = \"BLKUSE\",\n\t[TS_INIT]     = \"INIT  \",\n\t[TS_NOT_OPER] = \"NOT_OP\"\n};\n\nconst char *tape_op_verbose[TO_SIZE] =\n{\n\t[TO_BLOCK] = \"BLK\",\t[TO_BSB] = \"BSB\",\n\t[TO_BSF] = \"BSF\",\t[TO_DSE] = \"DSE\",\n\t[TO_FSB] = \"FSB\",\t[TO_FSF] = \"FSF\",\n\t[TO_LBL] = \"LBL\",\t[TO_NOP] = \"NOP\",\n\t[TO_RBA] = \"RBA\",\t[TO_RBI] = \"RBI\",\n\t[TO_RFO] = \"RFO\",\t[TO_REW] = \"REW\",\n\t[TO_RUN] = \"RUN\",\t[TO_WRI] = \"WRI\",\n\t[TO_WTM] = \"WTM\",\t[TO_MSEN] = \"MSN\",\n\t[TO_LOAD] = \"LOA\",\t[TO_READ_CONFIG] = \"RCF\",\n\t[TO_READ_ATTMSG] = \"RAT\",\n\t[TO_DIS] = \"DIS\",\t[TO_ASSIGN] = \"ASS\",\n\t[TO_UNASSIGN] = \"UAS\",  [TO_CRYPT_ON] = \"CON\",\n\t[TO_CRYPT_OFF] = \"COF\",\t[TO_KEKL_SET] = \"KLS\",\n\t[TO_KEKL_QUERY] = \"KLQ\",[TO_RDC] = \"RDC\",\n};\n\nstatic int devid_to_int(struct ccw_dev_id *dev_id)\n{\n\treturn dev_id->devno + (dev_id->ssid << 16);\n}\n\n \nstatic ssize_t\ntape_medium_state_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct tape_device *tdev;\n\n\ttdev = dev_get_drvdata(dev);\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", tdev->medium_state);\n}\n\nstatic\nDEVICE_ATTR(medium_state, 0444, tape_medium_state_show, NULL);\n\nstatic ssize_t\ntape_first_minor_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct tape_device *tdev;\n\n\ttdev = dev_get_drvdata(dev);\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", tdev->first_minor);\n}\n\nstatic\nDEVICE_ATTR(first_minor, 0444, tape_first_minor_show, NULL);\n\nstatic ssize_t\ntape_state_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct tape_device *tdev;\n\n\ttdev = dev_get_drvdata(dev);\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", (tdev->first_minor < 0) ?\n\t\t\"OFFLINE\" : tape_state_verbose[tdev->tape_state]);\n}\n\nstatic\nDEVICE_ATTR(state, 0444, tape_state_show, NULL);\n\nstatic ssize_t\ntape_operation_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct tape_device *tdev;\n\tssize_t rc;\n\n\ttdev = dev_get_drvdata(dev);\n\tif (tdev->first_minor < 0)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"N/A\\n\");\n\n\tspin_lock_irq(get_ccwdev_lock(tdev->cdev));\n\tif (list_empty(&tdev->req_queue))\n\t\trc = scnprintf(buf, PAGE_SIZE, \"---\\n\");\n\telse {\n\t\tstruct tape_request *req;\n\n\t\treq = list_entry(tdev->req_queue.next, struct tape_request,\n\t\t\tlist);\n\t\trc = scnprintf(buf,PAGE_SIZE, \"%s\\n\", tape_op_verbose[req->op]);\n\t}\n\tspin_unlock_irq(get_ccwdev_lock(tdev->cdev));\n\treturn rc;\n}\n\nstatic\nDEVICE_ATTR(operation, 0444, tape_operation_show, NULL);\n\nstatic ssize_t\ntape_blocksize_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct tape_device *tdev;\n\n\ttdev = dev_get_drvdata(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%i\\n\", tdev->char_data.block_size);\n}\n\nstatic\nDEVICE_ATTR(blocksize, 0444, tape_blocksize_show, NULL);\n\nstatic struct attribute *tape_attrs[] = {\n\t&dev_attr_medium_state.attr,\n\t&dev_attr_first_minor.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_operation.attr,\n\t&dev_attr_blocksize.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tape_attr_group = {\n\t.attrs = tape_attrs,\n};\n\n \nvoid\ntape_state_set(struct tape_device *device, enum tape_state newstate)\n{\n\tconst char *str;\n\n\tif (device->tape_state == TS_NOT_OPER) {\n\t\tDBF_EVENT(3, \"ts_set err: not oper\\n\");\n\t\treturn;\n\t}\n\tDBF_EVENT(4, \"ts. dev:\t%x\\n\", device->first_minor);\n\tDBF_EVENT(4, \"old ts:\\t\\n\");\n\tif (device->tape_state < TS_SIZE && device->tape_state >=0 )\n\t\tstr = tape_state_verbose[device->tape_state];\n\telse\n\t\tstr = \"UNKNOWN TS\";\n\tDBF_EVENT(4, \"%s\\n\", str);\n\tDBF_EVENT(4, \"new ts:\\t\\n\");\n\tif (newstate < TS_SIZE && newstate >= 0)\n\t\tstr = tape_state_verbose[newstate];\n\telse\n\t\tstr = \"UNKNOWN TS\";\n\tDBF_EVENT(4, \"%s\\n\", str);\n\tdevice->tape_state = newstate;\n\twake_up(&device->state_change_wq);\n}\n\nstruct tape_med_state_work_data {\n\tstruct tape_device *device;\n\tenum tape_medium_state state;\n\tstruct work_struct  work;\n};\n\nstatic void\ntape_med_state_work_handler(struct work_struct *work)\n{\n\tstatic char env_state_loaded[] = \"MEDIUM_STATE=LOADED\";\n\tstatic char env_state_unloaded[] = \"MEDIUM_STATE=UNLOADED\";\n\tstruct tape_med_state_work_data *p =\n\t\tcontainer_of(work, struct tape_med_state_work_data, work);\n\tstruct tape_device *device = p->device;\n\tchar *envp[] = { NULL, NULL };\n\n\tswitch (p->state) {\n\tcase MS_UNLOADED:\n\t\tpr_info(\"%s: The tape cartridge has been successfully \"\n\t\t\t\"unloaded\\n\", dev_name(&device->cdev->dev));\n\t\tenvp[0] = env_state_unloaded;\n\t\tkobject_uevent_env(&device->cdev->dev.kobj, KOBJ_CHANGE, envp);\n\t\tbreak;\n\tcase MS_LOADED:\n\t\tpr_info(\"%s: A tape cartridge has been mounted\\n\",\n\t\t\tdev_name(&device->cdev->dev));\n\t\tenvp[0] = env_state_loaded;\n\t\tkobject_uevent_env(&device->cdev->dev.kobj, KOBJ_CHANGE, envp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ttape_put_device(device);\n\tkfree(p);\n}\n\nstatic void\ntape_med_state_work(struct tape_device *device, enum tape_medium_state state)\n{\n\tstruct tape_med_state_work_data *p;\n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\tif (p) {\n\t\tINIT_WORK(&p->work, tape_med_state_work_handler);\n\t\tp->device = tape_get_device(device);\n\t\tp->state = state;\n\t\tschedule_work(&p->work);\n\t}\n}\n\nvoid\ntape_med_state_set(struct tape_device *device, enum tape_medium_state newstate)\n{\n\tenum tape_medium_state oldstate;\n\n\toldstate = device->medium_state;\n\tif (oldstate == newstate)\n\t\treturn;\n\tdevice->medium_state = newstate;\n\tswitch(newstate){\n\tcase MS_UNLOADED:\n\t\tdevice->tape_generic_status |= GMT_DR_OPEN(~0);\n\t\tif (oldstate == MS_LOADED)\n\t\t\ttape_med_state_work(device, MS_UNLOADED);\n\t\tbreak;\n\tcase MS_LOADED:\n\t\tdevice->tape_generic_status &= ~GMT_DR_OPEN(~0);\n\t\tif (oldstate == MS_UNLOADED)\n\t\t\ttape_med_state_work(device, MS_LOADED);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\twake_up(&device->state_change_wq);\n}\n\n \nstatic int\n__tape_cancel_io(struct tape_device *device, struct tape_request *request)\n{\n\tint retries;\n\tint rc;\n\n\t \n\tif (request->callback == NULL)\n\t\treturn 0;\n\n\trc = 0;\n\tfor (retries = 0; retries < 5; retries++) {\n\t\trc = ccw_device_clear(device->cdev, (long) request);\n\n\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\trequest->status\t= TAPE_REQUEST_DONE;\n\t\t\t\treturn 0;\n\t\t\tcase -EBUSY:\n\t\t\t\trequest->status\t= TAPE_REQUEST_CANCEL;\n\t\t\t\tschedule_delayed_work(&device->tape_dnr, 0);\n\t\t\t\treturn 0;\n\t\t\tcase -ENODEV:\n\t\t\t\tDBF_EXCEPTION(2, \"device gone, retry\\n\");\n\t\t\t\tbreak;\n\t\t\tcase -EIO:\n\t\t\t\tDBF_EXCEPTION(2, \"I/O error, retry\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic int\ntape_assign_minor(struct tape_device *device)\n{\n\tstruct tape_device *tmp;\n\tint minor;\n\n\tminor = 0;\n\twrite_lock(&tape_device_lock);\n\tlist_for_each_entry(tmp, &tape_device_list, node) {\n\t\tif (minor < tmp->first_minor)\n\t\t\tbreak;\n\t\tminor += TAPE_MINORS_PER_DEV;\n\t}\n\tif (minor >= 256) {\n\t\twrite_unlock(&tape_device_lock);\n\t\treturn -ENODEV;\n\t}\n\tdevice->first_minor = minor;\n\tlist_add_tail(&device->node, &tmp->node);\n\twrite_unlock(&tape_device_lock);\n\treturn 0;\n}\n\n \nstatic void\ntape_remove_minor(struct tape_device *device)\n{\n\twrite_lock(&tape_device_lock);\n\tlist_del_init(&device->node);\n\tdevice->first_minor = -1;\n\twrite_unlock(&tape_device_lock);\n}\n\n \nint\ntape_generic_online(struct tape_device *device,\n\t\t   struct tape_discipline *discipline)\n{\n\tint rc;\n\n\tDBF_LH(6, \"tape_enable_device(%p, %p)\\n\", device, discipline);\n\n\tif (device->tape_state != TS_INIT) {\n\t\tDBF_LH(3, \"Tapestate not INIT (%d)\\n\", device->tape_state);\n\t\treturn -EINVAL;\n\t}\n\n\ttimer_setup(&device->lb_timeout, tape_long_busy_timeout, 0);\n\n\t \n\tdevice->discipline = discipline;\n\tif (!try_module_get(discipline->owner)) {\n\t\treturn -EINVAL;\n\t}\n\n\trc = discipline->setup_device(device);\n\tif (rc)\n\t\tgoto out;\n\trc = tape_assign_minor(device);\n\tif (rc)\n\t\tgoto out_discipline;\n\n\trc = tapechar_setup_device(device);\n\tif (rc)\n\t\tgoto out_minor;\n\n\ttape_state_set(device, TS_UNUSED);\n\n\tDBF_LH(3, \"(%08x): Drive set online\\n\", device->cdev_id);\n\n\treturn 0;\n\nout_minor:\n\ttape_remove_minor(device);\nout_discipline:\n\tdevice->discipline->cleanup_device(device);\n\tdevice->discipline = NULL;\nout:\n\tmodule_put(discipline->owner);\n\treturn rc;\n}\n\nstatic void\ntape_cleanup_device(struct tape_device *device)\n{\n\ttapechar_cleanup_device(device);\n\tdevice->discipline->cleanup_device(device);\n\tmodule_put(device->discipline->owner);\n\ttape_remove_minor(device);\n\ttape_med_state_set(device, MS_UNKNOWN);\n}\n\n \nint\ntape_generic_offline(struct ccw_device *cdev)\n{\n\tstruct tape_device *device;\n\n\tdevice = dev_get_drvdata(&cdev->dev);\n\tif (!device) {\n\t\treturn -ENODEV;\n\t}\n\n\tDBF_LH(3, \"(%08x): tape_generic_offline(%p)\\n\",\n\t\tdevice->cdev_id, device);\n\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\tswitch (device->tape_state) {\n\t\tcase TS_INIT:\n\t\tcase TS_NOT_OPER:\n\t\t\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t\t\tbreak;\n\t\tcase TS_UNUSED:\n\t\t\ttape_state_set(device, TS_INIT);\n\t\t\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t\t\ttape_cleanup_device(device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBF_EVENT(3, \"(%08x): Set offline failed \"\n\t\t\t\t\"- drive in use.\\n\",\n\t\t\t\tdevice->cdev_id);\n\t\t\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t\t\treturn -EBUSY;\n\t}\n\n\tDBF_LH(3, \"(%08x): Drive set offline.\\n\", device->cdev_id);\n\treturn 0;\n}\n\n \nstatic struct tape_device *\ntape_alloc_device(void)\n{\n\tstruct tape_device *device;\n\n\tdevice = kzalloc(sizeof(struct tape_device), GFP_KERNEL);\n\tif (device == NULL) {\n\t\tDBF_EXCEPTION(2, \"ti:no mem\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdevice->modeset_byte = kmalloc(1, GFP_KERNEL | GFP_DMA);\n\tif (device->modeset_byte == NULL) {\n\t\tDBF_EXCEPTION(2, \"ti:no mem\\n\");\n\t\tkfree(device);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&device->mutex);\n\tINIT_LIST_HEAD(&device->req_queue);\n\tINIT_LIST_HEAD(&device->node);\n\tinit_waitqueue_head(&device->state_change_wq);\n\tinit_waitqueue_head(&device->wait_queue);\n\tdevice->tape_state = TS_INIT;\n\tdevice->medium_state = MS_UNKNOWN;\n\t*device->modeset_byte = 0;\n\tdevice->first_minor = -1;\n\tatomic_set(&device->ref_count, 1);\n\tINIT_DELAYED_WORK(&device->tape_dnr, tape_delayed_next_request);\n\n\treturn device;\n}\n\n \nstruct tape_device *\ntape_get_device(struct tape_device *device)\n{\n\tint count;\n\n\tcount = atomic_inc_return(&device->ref_count);\n\tDBF_EVENT(4, \"tape_get_device(%p) = %i\\n\", device, count);\n\treturn device;\n}\n\n \nvoid\ntape_put_device(struct tape_device *device)\n{\n\tint count;\n\n\tcount = atomic_dec_return(&device->ref_count);\n\tDBF_EVENT(4, \"tape_put_device(%p) -> %i\\n\", device, count);\n\tBUG_ON(count < 0);\n\tif (count == 0) {\n\t\tkfree(device->modeset_byte);\n\t\tkfree(device);\n\t}\n}\n\n \nstruct tape_device *\ntape_find_device(int devindex)\n{\n\tstruct tape_device *device, *tmp;\n\n\tdevice = ERR_PTR(-ENODEV);\n\tread_lock(&tape_device_lock);\n\tlist_for_each_entry(tmp, &tape_device_list, node) {\n\t\tif (tmp->first_minor / TAPE_MINORS_PER_DEV == devindex) {\n\t\t\tdevice = tape_get_device(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tape_device_lock);\n\treturn device;\n}\n\n \nint\ntape_generic_probe(struct ccw_device *cdev)\n{\n\tstruct tape_device *device;\n\tint ret;\n\tstruct ccw_dev_id dev_id;\n\n\tdevice = tape_alloc_device();\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tccw_device_set_options(cdev, CCWDEV_DO_PATHGROUP |\n\t\t\t\t     CCWDEV_DO_MULTIPATH);\n\tret = sysfs_create_group(&cdev->dev.kobj, &tape_attr_group);\n\tif (ret) {\n\t\ttape_put_device(device);\n\t\treturn ret;\n\t}\n\tdev_set_drvdata(&cdev->dev, device);\n\tcdev->handler = __tape_do_irq;\n\tdevice->cdev = cdev;\n\tccw_device_get_id(cdev, &dev_id);\n\tdevice->cdev_id = devid_to_int(&dev_id);\n\treturn ret;\n}\n\nstatic void\n__tape_discard_requests(struct tape_device *device)\n{\n\tstruct tape_request *\trequest;\n\tstruct list_head *\tl, *n;\n\n\tlist_for_each_safe(l, n, &device->req_queue) {\n\t\trequest = list_entry(l, struct tape_request, list);\n\t\tif (request->status == TAPE_REQUEST_IN_IO)\n\t\t\trequest->status = TAPE_REQUEST_DONE;\n\t\tlist_del(&request->list);\n\n\t\t \n\t\trequest->device = NULL;\n\t\ttape_put_device(device);\n\t\trequest->rc = -EIO;\n\t\tif (request->callback != NULL)\n\t\t\trequest->callback(request, request->callback_data);\n\t}\n}\n\n \nvoid\ntape_generic_remove(struct ccw_device *cdev)\n{\n\tstruct tape_device *\tdevice;\n\n\tdevice = dev_get_drvdata(&cdev->dev);\n\tif (!device) {\n\t\treturn;\n\t}\n\tDBF_LH(3, \"(%08x): tape_generic_remove(%p)\\n\", device->cdev_id, cdev);\n\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\tswitch (device->tape_state) {\n\t\tcase TS_INIT:\n\t\t\ttape_state_set(device, TS_NOT_OPER);\n\t\t\tfallthrough;\n\t\tcase TS_NOT_OPER:\n\t\t\t \n\t\t\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t\t\tbreak;\n\t\tcase TS_UNUSED:\n\t\t\t \n\t\t\ttape_state_set(device, TS_NOT_OPER);\n\t\t\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t\t\ttape_cleanup_device(device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tDBF_EVENT(3, \"(%08x): Drive in use vanished!\\n\",\n\t\t\t\tdevice->cdev_id);\n\t\t\tpr_warn(\"%s: A tape unit was detached while in use\\n\",\n\t\t\t\tdev_name(&device->cdev->dev));\n\t\t\ttape_state_set(device, TS_NOT_OPER);\n\t\t\t__tape_discard_requests(device);\n\t\t\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t\t\ttape_cleanup_device(device);\n\t}\n\n\tdevice = dev_get_drvdata(&cdev->dev);\n\tif (device) {\n\t\tsysfs_remove_group(&cdev->dev.kobj, &tape_attr_group);\n\t\tdev_set_drvdata(&cdev->dev, NULL);\n\t\ttape_put_device(device);\n\t}\n}\n\n \nstruct tape_request *\ntape_alloc_request(int cplength, int datasize)\n{\n\tstruct tape_request *request;\n\n\tBUG_ON(datasize > PAGE_SIZE || (cplength*sizeof(struct ccw1)) > PAGE_SIZE);\n\n\tDBF_LH(6, \"tape_alloc_request(%d, %d)\\n\", cplength, datasize);\n\n\trequest = kzalloc(sizeof(struct tape_request), GFP_KERNEL);\n\tif (request == NULL) {\n\t\tDBF_EXCEPTION(1, \"cqra nomem\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t \n\tif (cplength > 0) {\n\t\trequest->cpaddr = kcalloc(cplength, sizeof(struct ccw1),\n\t\t\t\t\t  GFP_ATOMIC | GFP_DMA);\n\t\tif (request->cpaddr == NULL) {\n\t\t\tDBF_EXCEPTION(1, \"cqra nomem\\n\");\n\t\t\tkfree(request);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\t \n\tif (datasize > 0) {\n\t\trequest->cpdata = kzalloc(datasize, GFP_KERNEL | GFP_DMA);\n\t\tif (request->cpdata == NULL) {\n\t\t\tDBF_EXCEPTION(1, \"cqra nomem\\n\");\n\t\t\tkfree(request->cpaddr);\n\t\t\tkfree(request);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\tDBF_LH(6, \"New request %p(%p/%p)\\n\", request, request->cpaddr,\n\t\trequest->cpdata);\n\n\treturn request;\n}\n\n \nvoid\ntape_free_request (struct tape_request * request)\n{\n\tDBF_LH(6, \"Free request %p\\n\", request);\n\n\tif (request->device)\n\t\ttape_put_device(request->device);\n\tkfree(request->cpdata);\n\tkfree(request->cpaddr);\n\tkfree(request);\n}\n\nstatic int\n__tape_start_io(struct tape_device *device, struct tape_request *request)\n{\n\tint rc;\n\n\trc = ccw_device_start(\n\t\tdevice->cdev,\n\t\trequest->cpaddr,\n\t\t(unsigned long) request,\n\t\t0x00,\n\t\trequest->options\n\t);\n\tif (rc == 0) {\n\t\trequest->status = TAPE_REQUEST_IN_IO;\n\t} else if (rc == -EBUSY) {\n\t\t \n\t\trequest->status = TAPE_REQUEST_QUEUED;\n\t\tschedule_delayed_work(&device->tape_dnr, 0);\n\t\trc = 0;\n\t} else {\n\t\t \n\t\tDBF_EVENT(1, \"tape: start request failed with RC = %i\\n\", rc);\n\t}\n\treturn rc;\n}\n\nstatic void\n__tape_start_next_request(struct tape_device *device)\n{\n\tstruct list_head *l, *n;\n\tstruct tape_request *request;\n\tint rc;\n\n\tDBF_LH(6, \"__tape_start_next_request(%p)\\n\", device);\n\t \n\tlist_for_each_safe(l, n, &device->req_queue) {\n\t\trequest = list_entry(l, struct tape_request, list);\n\n\t\t \n\t\tif (request->status == TAPE_REQUEST_IN_IO)\n\t\t\treturn;\n\t\t \n\t\tif (request->status == TAPE_REQUEST_DONE)\n\t\t\treturn;\n\n\t\t \n\t\tif (request->status == TAPE_REQUEST_CANCEL) {\n\t\t\trc = __tape_cancel_io(device, request);\n\t\t} else {\n\t\t\trc = __tape_start_io(device, request);\n\t\t}\n\t\tif (rc == 0)\n\t\t\treturn;\n\n\t\t \n\t\trequest->rc = rc;\n\t\trequest->status = TAPE_REQUEST_DONE;\n\n\t\t \n\t\tlist_del(&request->list);\n\n\t\t \n\t\tif (request->callback != NULL)\n\t\t\trequest->callback(request, request->callback_data);\n\t}\n}\n\nstatic void\ntape_delayed_next_request(struct work_struct *work)\n{\n\tstruct tape_device *device =\n\t\tcontainer_of(work, struct tape_device, tape_dnr.work);\n\n\tDBF_LH(6, \"tape_delayed_next_request(%p)\\n\", device);\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\t__tape_start_next_request(device);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n}\n\nstatic void tape_long_busy_timeout(struct timer_list *t)\n{\n\tstruct tape_device *device = from_timer(device, t, lb_timeout);\n\tstruct tape_request *request;\n\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\trequest = list_entry(device->req_queue.next, struct tape_request, list);\n\tBUG_ON(request->status != TAPE_REQUEST_LONG_BUSY);\n\tDBF_LH(6, \"%08x: Long busy timeout.\\n\", device->cdev_id);\n\t__tape_start_next_request(device);\n\ttape_put_device(device);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n}\n\nstatic void\n__tape_end_request(\n\tstruct tape_device *\tdevice,\n\tstruct tape_request *\trequest,\n\tint\t\t\trc)\n{\n\tDBF_LH(6, \"__tape_end_request(%p, %p, %i)\\n\", device, request, rc);\n\tif (request) {\n\t\trequest->rc = rc;\n\t\trequest->status = TAPE_REQUEST_DONE;\n\n\t\t \n\t\tlist_del(&request->list);\n\n\t\t \n\t\tif (request->callback != NULL)\n\t\t\trequest->callback(request, request->callback_data);\n\t}\n\n\t \n\tif (!list_empty(&device->req_queue))\n\t\t__tape_start_next_request(device);\n}\n\n \nvoid\ntape_dump_sense_dbf(struct tape_device *device, struct tape_request *request,\n\t\t    struct irb *irb)\n{\n\tunsigned int *sptr;\n\tconst char* op;\n\n\tif (request != NULL)\n\t\top = tape_op_verbose[request->op];\n\telse\n\t\top = \"---\";\n\tDBF_EVENT(3, \"DSTAT : %02x   CSTAT: %02x\\n\",\n\t\t  irb->scsw.cmd.dstat, irb->scsw.cmd.cstat);\n\tDBF_EVENT(3, \"DEVICE: %08x OP\\t: %s\\n\", device->cdev_id, op);\n\tsptr = (unsigned int *) irb->ecw;\n\tDBF_EVENT(3, \"%08x %08x\\n\", sptr[0], sptr[1]);\n\tDBF_EVENT(3, \"%08x %08x\\n\", sptr[2], sptr[3]);\n\tDBF_EVENT(3, \"%08x %08x\\n\", sptr[4], sptr[5]);\n\tDBF_EVENT(3, \"%08x %08x\\n\", sptr[6], sptr[7]);\n}\n\n \nstatic int\n__tape_start_request(struct tape_device *device, struct tape_request *request)\n{\n\tint rc;\n\n\tswitch (request->op) {\n\t\tcase TO_MSEN:\n\t\tcase TO_ASSIGN:\n\t\tcase TO_UNASSIGN:\n\t\tcase TO_READ_ATTMSG:\n\t\tcase TO_RDC:\n\t\t\tif (device->tape_state == TS_INIT)\n\t\t\t\tbreak;\n\t\t\tif (device->tape_state == TS_UNUSED)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (device->tape_state == TS_BLKUSE)\n\t\t\t\tbreak;\n\t\t\tif (device->tape_state != TS_IN_USE)\n\t\t\t\treturn -ENODEV;\n\t}\n\n\t \n\trequest->device = tape_get_device(device);\n\n\tif (list_empty(&device->req_queue)) {\n\t\t \n\t\trc = __tape_start_io(device, request);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tDBF_LH(5, \"Request %p added for execution.\\n\", request);\n\t\tlist_add(&request->list, &device->req_queue);\n\t} else {\n\t\tDBF_LH(5, \"Request %p add to queue.\\n\", request);\n\t\trequest->status = TAPE_REQUEST_QUEUED;\n\t\tlist_add_tail(&request->list, &device->req_queue);\n\t}\n\treturn 0;\n}\n\n \nint\ntape_do_io_async(struct tape_device *device, struct tape_request *request)\n{\n\tint rc;\n\n\tDBF_LH(6, \"tape_do_io_async(%p, %p)\\n\", device, request);\n\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\t \n\trc = __tape_start_request(device, request);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\treturn rc;\n}\n\n \nstatic void\n__tape_wake_up(struct tape_request *request, void *data)\n{\n\trequest->callback = NULL;\n\twake_up((wait_queue_head_t *) data);\n}\n\nint\ntape_do_io(struct tape_device *device, struct tape_request *request)\n{\n\tint rc;\n\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\t \n\trequest->callback = __tape_wake_up;\n\trequest->callback_data = &device->wait_queue;\n\t \n\trc = __tape_start_request(device, request);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\tif (rc)\n\t\treturn rc;\n\t \n\twait_event(device->wait_queue, (request->callback == NULL));\n\t \n\treturn request->rc;\n}\n\n \nstatic void\n__tape_wake_up_interruptible(struct tape_request *request, void *data)\n{\n\trequest->callback = NULL;\n\twake_up_interruptible((wait_queue_head_t *) data);\n}\n\nint\ntape_do_io_interruptible(struct tape_device *device,\n\t\t\t struct tape_request *request)\n{\n\tint rc;\n\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\t \n\trequest->callback = __tape_wake_up_interruptible;\n\trequest->callback_data = &device->wait_queue;\n\trc = __tape_start_request(device, request);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\tif (rc)\n\t\treturn rc;\n\t \n\trc = wait_event_interruptible(device->wait_queue,\n\t\t\t\t      (request->callback == NULL));\n\tif (rc != -ERESTARTSYS)\n\t\t \n\t\treturn request->rc;\n\n\t \n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\trc = __tape_cancel_io(device, request);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\tif (rc == 0) {\n\t\t \n\t\tdo {\n\t\t\trc = wait_event_interruptible(\n\t\t\t\tdevice->wait_queue,\n\t\t\t\t(request->callback == NULL)\n\t\t\t);\n\t\t} while (rc == -ERESTARTSYS);\n\n\t\tDBF_EVENT(3, \"IO stopped on %08x\\n\", device->cdev_id);\n\t\trc = -ERESTARTSYS;\n\t}\n\treturn rc;\n}\n\n \nint\ntape_cancel_io(struct tape_device *device, struct tape_request *request)\n{\n\tint rc;\n\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\trc = __tape_cancel_io(device, request);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\treturn rc;\n}\n\n \nstatic void\n__tape_do_irq (struct ccw_device *cdev, unsigned long intparm, struct irb *irb)\n{\n\tstruct tape_device *device;\n\tstruct tape_request *request;\n\tint rc;\n\n\tdevice = dev_get_drvdata(&cdev->dev);\n\tif (device == NULL) {\n\t\treturn;\n\t}\n\trequest = (struct tape_request *) intparm;\n\n\tDBF_LH(6, \"__tape_do_irq(device=%p, request=%p)\\n\", device, request);\n\n\t \n\tif (IS_ERR(irb)) {\n\t\t \n\t\tswitch (PTR_ERR(irb)) {\n\t\t\tcase -ETIMEDOUT:\n\t\t\t\tDBF_LH(1, \"(%08x): Request timed out\\n\",\n\t\t\t\t       device->cdev_id);\n\t\t\t\tfallthrough;\n\t\t\tcase -EIO:\n\t\t\t\t__tape_end_request(device, request, -EIO);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDBF_LH(1, \"(%08x): Unexpected i/o error %li\\n\",\n\t\t\t\t       device->cdev_id,\tPTR_ERR(irb));\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (irb->scsw.cmd.cc != 0 &&\n\t    (irb->scsw.cmd.fctl & SCSW_FCTL_START_FUNC) &&\n\t    (request->status == TAPE_REQUEST_IN_IO)) {\n\t\tDBF_EVENT(3,\"(%08x): deferred cc=%i, fctl=%i. restarting\\n\",\n\t\t\tdevice->cdev_id, irb->scsw.cmd.cc, irb->scsw.cmd.fctl);\n\t\trequest->status = TAPE_REQUEST_QUEUED;\n\t\tschedule_delayed_work(&device->tape_dnr, HZ);\n\t\treturn;\n\t}\n\n\t \n\tif(request != NULL)\n\t\trequest->rescnt = irb->scsw.cmd.count;\n\telse if ((irb->scsw.cmd.dstat == 0x85 || irb->scsw.cmd.dstat == 0x80) &&\n\t\t !list_empty(&device->req_queue)) {\n\t\t \n\t\tstruct tape_request *req;\n\t\treq = list_entry(device->req_queue.next,\n\t\t\t\t struct tape_request, list);\n\t\tif (req->status == TAPE_REQUEST_LONG_BUSY) {\n\t\t\tDBF_EVENT(3, \"(%08x): del timer\\n\", device->cdev_id);\n\t\t\tif (del_timer(&device->lb_timeout)) {\n\t\t\t\ttape_put_device(device);\n\t\t\t\t__tape_start_next_request(device);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (irb->scsw.cmd.dstat != 0x0c) {\n\t\t \n\t\tif(*(((__u8 *) irb->ecw) + 1) & SENSE_DRIVE_ONLINE)\n\t\t\tdevice->tape_generic_status |= GMT_ONLINE(~0);\n\t\telse\n\t\t\tdevice->tape_generic_status &= ~GMT_ONLINE(~0);\n\n\t\t \n\t\tDBF_EVENT(3,\"-- Tape Interrupthandler --\\n\");\n\t\ttape_dump_sense_dbf(device, request, irb);\n\t} else {\n\t\t \n\t\tdevice->tape_generic_status |= GMT_ONLINE(~0);\n\t}\n\tif (device->tape_state == TS_NOT_OPER) {\n\t\tDBF_EVENT(6, \"tape:device is not operational\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif(request != NULL && request->status == TAPE_REQUEST_DONE) {\n\t\t__tape_end_request(device, request, -EIO);\n\t\treturn;\n\t}\n\n\trc = device->discipline->irq(device, request, irb);\n\t \n\tswitch (rc) {\n\t\tcase TAPE_IO_SUCCESS:\n\t\t\t \n\t\t\tdevice->tape_generic_status |= GMT_ONLINE(~0);\n\t\t\t__tape_end_request(device, request, rc);\n\t\t\tbreak;\n\t\tcase TAPE_IO_PENDING:\n\t\t\tbreak;\n\t\tcase TAPE_IO_LONG_BUSY:\n\t\t\tdevice->lb_timeout.expires = jiffies +\n\t\t\t\tLONG_BUSY_TIMEOUT * HZ;\n\t\t\tDBF_EVENT(3, \"(%08x): add timer\\n\", device->cdev_id);\n\t\t\tadd_timer(&device->lb_timeout);\n\t\t\trequest->status = TAPE_REQUEST_LONG_BUSY;\n\t\t\tbreak;\n\t\tcase TAPE_IO_RETRY:\n\t\t\trc = __tape_start_io(device, request);\n\t\t\tif (rc)\n\t\t\t\t__tape_end_request(device, request, rc);\n\t\t\tbreak;\n\t\tcase TAPE_IO_STOP:\n\t\t\trc = __tape_cancel_io(device, request);\n\t\t\tif (rc)\n\t\t\t\t__tape_end_request(device, request, rc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (rc > 0) {\n\t\t\t\tDBF_EVENT(6, \"xunknownrc\\n\");\n\t\t\t\t__tape_end_request(device, request, -EIO);\n\t\t\t} else {\n\t\t\t\t__tape_end_request(device, request, rc);\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\n \nint\ntape_open(struct tape_device *device)\n{\n\tint rc;\n\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\tif (device->tape_state == TS_NOT_OPER) {\n\t\tDBF_EVENT(6, \"TAPE:nodev\\n\");\n\t\trc = -ENODEV;\n\t} else if (device->tape_state == TS_IN_USE) {\n\t\tDBF_EVENT(6, \"TAPE:dbusy\\n\");\n\t\trc = -EBUSY;\n\t} else if (device->tape_state == TS_BLKUSE) {\n\t\tDBF_EVENT(6, \"TAPE:dbusy\\n\");\n\t\trc = -EBUSY;\n\t} else if (device->discipline != NULL &&\n\t\t   !try_module_get(device->discipline->owner)) {\n\t\tDBF_EVENT(6, \"TAPE:nodisc\\n\");\n\t\trc = -ENODEV;\n\t} else {\n\t\ttape_state_set(device, TS_IN_USE);\n\t\trc = 0;\n\t}\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\treturn rc;\n}\n\n \nint\ntape_release(struct tape_device *device)\n{\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\tif (device->tape_state == TS_IN_USE)\n\t\ttape_state_set(device, TS_UNUSED);\n\tmodule_put(device->discipline->owner);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\treturn 0;\n}\n\n \nint\ntape_mtop(struct tape_device *device, int mt_op, int mt_count)\n{\n\ttape_mtop_fn fn;\n\tint rc;\n\n\tDBF_EVENT(6, \"TAPE:mtio\\n\");\n\tDBF_EVENT(6, \"TAPE:ioop: %x\\n\", mt_op);\n\tDBF_EVENT(6, \"TAPE:arg:\t %x\\n\", mt_count);\n\n\tif (mt_op < 0 || mt_op >= TAPE_NR_MTOPS)\n\t\treturn -EINVAL;\n\tfn = device->discipline->mtop_array[mt_op];\n\tif (fn == NULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (mt_op == MTBSR  || mt_op == MTFSR  || mt_op == MTFSF  ||\n\t    mt_op == MTBSF  || mt_op == MTFSFM || mt_op == MTBSFM) {\n\t\trc = 0;\n\t\tfor (; mt_count > 500; mt_count -= 500)\n\t\t\tif ((rc = fn(device, 500)) != 0)\n\t\t\t\tbreak;\n\t\tif (rc == 0)\n\t\t\trc = fn(device, mt_count);\n\t} else\n\t\trc = fn(device, mt_count);\n\treturn rc;\n\n}\n\n \nstatic int\ntape_init (void)\n{\n\tTAPE_DBF_AREA = debug_register ( \"tape\", 2, 2, 4*sizeof(long));\n\tdebug_register_view(TAPE_DBF_AREA, &debug_sprintf_view);\n#ifdef DBF_LIKE_HELL\n\tdebug_set_level(TAPE_DBF_AREA, 6);\n#endif\n\tDBF_EVENT(3, \"tape init\\n\");\n\ttape_proc_init();\n\ttapechar_init ();\n\treturn 0;\n}\n\n \nstatic void\ntape_exit(void)\n{\n\tDBF_EVENT(6, \"tape exit\\n\");\n\n\t \n\ttapechar_exit();\n\ttape_proc_cleanup();\n\tdebug_unregister (TAPE_DBF_AREA);\n}\n\nMODULE_AUTHOR(\"(C) 2001 IBM Deutschland Entwicklung GmbH by Carsten Otte and \"\n\t      \"Michael Holzheu (cotte@de.ibm.com,holzheu@de.ibm.com)\");\nMODULE_DESCRIPTION(\"Linux on zSeries channel attached tape device driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(tape_init);\nmodule_exit(tape_exit);\n\nEXPORT_SYMBOL(tape_generic_remove);\nEXPORT_SYMBOL(tape_generic_probe);\nEXPORT_SYMBOL(tape_generic_online);\nEXPORT_SYMBOL(tape_generic_offline);\nEXPORT_SYMBOL(tape_put_device);\nEXPORT_SYMBOL(tape_get_device);\nEXPORT_SYMBOL(tape_state_verbose);\nEXPORT_SYMBOL(tape_op_verbose);\nEXPORT_SYMBOL(tape_state_set);\nEXPORT_SYMBOL(tape_med_state_set);\nEXPORT_SYMBOL(tape_alloc_request);\nEXPORT_SYMBOL(tape_free_request);\nEXPORT_SYMBOL(tape_dump_sense_dbf);\nEXPORT_SYMBOL(tape_do_io);\nEXPORT_SYMBOL(tape_do_io_async);\nEXPORT_SYMBOL(tape_do_io_interruptible);\nEXPORT_SYMBOL(tape_cancel_io);\nEXPORT_SYMBOL(tape_mtop);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}