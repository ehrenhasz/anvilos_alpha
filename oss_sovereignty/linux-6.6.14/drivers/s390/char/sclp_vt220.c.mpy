{
  "module_name": "sclp_vt220.c",
  "hash_id": "ef13b1d10849882217020192d51c5a56f9b5f24a16cc051f0b04856544210798",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/sclp_vt220.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/panic_notifier.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/kernel.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/major.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n\n#include <linux/uaccess.h>\n#include \"sclp.h\"\n#include \"ctrlchar.h\"\n\n#define SCLP_VT220_MAJOR\t\tTTY_MAJOR\n#define SCLP_VT220_MINOR\t\t65\n#define SCLP_VT220_DRIVER_NAME\t\t\"sclp_vt220\"\n#define SCLP_VT220_DEVICE_NAME\t\t\"ttysclp\"\n#define SCLP_VT220_CONSOLE_NAME\t\t\"ttysclp\"\n#define SCLP_VT220_CONSOLE_INDEX\t0\t \n\n \nstruct sclp_vt220_request {\n\tstruct list_head list;\n\tstruct sclp_req sclp_req;\n\tint retry_count;\n};\n\n \nstruct sclp_vt220_sccb {\n\tstruct sccb_header header;\n\tstruct evbuf_header evbuf;\n};\n\n#define SCLP_VT220_MAX_CHARS_PER_BUFFER\t(PAGE_SIZE - \\\n\t\t\t\t\t sizeof(struct sclp_vt220_request) - \\\n\t\t\t\t\t sizeof(struct sclp_vt220_sccb))\n\n \nstatic struct tty_driver *sclp_vt220_driver;\n\nstatic struct tty_port sclp_vt220_port;\n\n \nstatic DEFINE_SPINLOCK(sclp_vt220_lock);\n\n \nstatic LIST_HEAD(sclp_vt220_empty);\n\n \nstatic LIST_HEAD(sclp_vt220_outqueue);\n\n \nstatic int sclp_vt220_queue_running;\n\n \nstatic struct timer_list sclp_vt220_timer;\n\n \nstatic struct sclp_vt220_request *sclp_vt220_current_request;\n\n \nstatic int sclp_vt220_buffered_chars;\n\n \nstatic int __initdata sclp_vt220_init_count;\n\n \nstatic int sclp_vt220_flush_later;\n\nstatic void sclp_vt220_receiver_fn(struct evbuf_header *evbuf);\nstatic int __sclp_vt220_emit(struct sclp_vt220_request *request);\nstatic void sclp_vt220_emit_current(void);\n\n \nstatic struct sclp_register sclp_vt220_register = {\n\t.send_mask\t\t= EVTYP_VT220MSG_MASK,\n};\n\n \nstatic struct sclp_register sclp_vt220_register_input = {\n\t.receive_mask\t\t= EVTYP_VT220MSG_MASK,\n\t.receiver_fn\t\t= sclp_vt220_receiver_fn,\n};\n\n\n \nstatic void\nsclp_vt220_process_queue(struct sclp_vt220_request *request)\n{\n\tunsigned long flags;\n\tvoid *page;\n\n\tdo {\n\t\t \n\t\tpage = request->sclp_req.sccb;\n\t\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\t\t \n\t\tlist_del(&request->list);\n\t\tlist_add_tail((struct list_head *) page, &sclp_vt220_empty);\n\t\t \n\t\trequest = NULL;\n\t\tif (!list_empty(&sclp_vt220_outqueue))\n\t\t\trequest = list_entry(sclp_vt220_outqueue.next,\n\t\t\t\t\t     struct sclp_vt220_request, list);\n\t\tif (!request) {\n\t\t\tsclp_vt220_queue_running = 0;\n\t\t\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\t} while (__sclp_vt220_emit(request));\n\tif (request == NULL && sclp_vt220_flush_later)\n\t\tsclp_vt220_emit_current();\n\ttty_port_tty_wakeup(&sclp_vt220_port);\n}\n\n#define SCLP_BUFFER_MAX_RETRY\t\t1\n\n \nstatic void\nsclp_vt220_callback(struct sclp_req *request, void *data)\n{\n\tstruct sclp_vt220_request *vt220_request;\n\tstruct sclp_vt220_sccb *sccb;\n\n\tvt220_request = (struct sclp_vt220_request *) data;\n\tif (request->status == SCLP_REQ_FAILED) {\n\t\tsclp_vt220_process_queue(vt220_request);\n\t\treturn;\n\t}\n\tsccb = (struct sclp_vt220_sccb *) vt220_request->sclp_req.sccb;\n\n\t \n\tswitch (sccb->header.response_code) {\n\tcase 0x0020 :\n\t\tbreak;\n\n\tcase 0x05f0:  \n\t\tbreak;\n\n\tcase 0x0340:  \n\t\tif (++vt220_request->retry_count > SCLP_BUFFER_MAX_RETRY)\n\t\t\tbreak;\n\t\t \n\t\tif (sclp_remove_processed((struct sccb_header *) sccb) > 0) {\n\t\t\t \n\t\t\tsccb->header.response_code = 0x0000;\n\t\t\tvt220_request->sclp_req.status = SCLP_REQ_FILLED;\n\t\t\tif (sclp_add_request(request) == 0)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase 0x0040:  \n\t\tif (++vt220_request->retry_count > SCLP_BUFFER_MAX_RETRY)\n\t\t\tbreak;\n\t\tsccb->header.response_code = 0x0000;\n\t\tvt220_request->sclp_req.status = SCLP_REQ_FILLED;\n\t\tif (sclp_add_request(request) == 0)\n\t\t\treturn;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tsclp_vt220_process_queue(vt220_request);\n}\n\n \nstatic int\n__sclp_vt220_emit(struct sclp_vt220_request *request)\n{\n\trequest->sclp_req.command = SCLP_CMDW_WRITE_EVENT_DATA;\n\trequest->sclp_req.status = SCLP_REQ_FILLED;\n\trequest->sclp_req.callback = sclp_vt220_callback;\n\trequest->sclp_req.callback_data = (void *) request;\n\n\treturn sclp_add_request(&request->sclp_req);\n}\n\n \nstatic void\nsclp_vt220_emit_current(void)\n{\n\tunsigned long flags;\n\tstruct sclp_vt220_request *request;\n\tstruct sclp_vt220_sccb *sccb;\n\n\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\tif (sclp_vt220_current_request) {\n\t\tsccb = (struct sclp_vt220_sccb *) \n\t\t\t\tsclp_vt220_current_request->sclp_req.sccb;\n\t\t \n\t\tif (sccb->header.length != sizeof(struct sclp_vt220_sccb)) {\n\t\t\tlist_add_tail(&sclp_vt220_current_request->list,\n\t\t\t\t      &sclp_vt220_outqueue);\n\t\t\tsclp_vt220_current_request = NULL;\n\t\t\tdel_timer(&sclp_vt220_timer);\n\t\t}\n\t\tsclp_vt220_flush_later = 0;\n\t}\n\tif (sclp_vt220_queue_running)\n\t\tgoto out_unlock;\n\tif (list_empty(&sclp_vt220_outqueue))\n\t\tgoto out_unlock;\n\trequest = list_first_entry(&sclp_vt220_outqueue,\n\t\t\t\t   struct sclp_vt220_request, list);\n\tsclp_vt220_queue_running = 1;\n\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\n\tif (__sclp_vt220_emit(request))\n\t\tsclp_vt220_process_queue(request);\n\treturn;\nout_unlock:\n\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n}\n\n#define SCLP_NORMAL_WRITE\t0x00\n\n \nstatic struct sclp_vt220_request *\nsclp_vt220_initialize_page(void *page)\n{\n\tstruct sclp_vt220_request *request;\n\tstruct sclp_vt220_sccb *sccb;\n\n\t \n\trequest = ((struct sclp_vt220_request *)\n\t\t\t((addr_t) page + PAGE_SIZE)) - 1;\n\trequest->retry_count = 0;\n\trequest->sclp_req.sccb = page;\n\t \n\tsccb = (struct sclp_vt220_sccb *) page;\n\tmemset((void *) sccb, 0, sizeof(struct sclp_vt220_sccb));\n\tsccb->header.length = sizeof(struct sclp_vt220_sccb);\n\tsccb->header.function_code = SCLP_NORMAL_WRITE;\n\tsccb->header.response_code = 0x0000;\n\tsccb->evbuf.type = EVTYP_VT220MSG;\n\tsccb->evbuf.length = sizeof(struct evbuf_header);\n\n\treturn request;\n}\n\nstatic inline unsigned int\nsclp_vt220_space_left(struct sclp_vt220_request *request)\n{\n\tstruct sclp_vt220_sccb *sccb;\n\tsccb = (struct sclp_vt220_sccb *) request->sclp_req.sccb;\n\treturn PAGE_SIZE - sizeof(struct sclp_vt220_request) -\n\t       sccb->header.length;\n}\n\nstatic inline unsigned int\nsclp_vt220_chars_stored(struct sclp_vt220_request *request)\n{\n\tstruct sclp_vt220_sccb *sccb;\n\tsccb = (struct sclp_vt220_sccb *) request->sclp_req.sccb;\n\treturn sccb->evbuf.length - sizeof(struct evbuf_header);\n}\n\n \nstatic int\nsclp_vt220_add_msg(struct sclp_vt220_request *request,\n\t\t   const unsigned char *msg, int count, int convertlf)\n{\n\tstruct sclp_vt220_sccb *sccb;\n\tvoid *buffer;\n\tunsigned char c;\n\tint from;\n\tint to;\n\n\tif (count > sclp_vt220_space_left(request))\n\t\tcount = sclp_vt220_space_left(request);\n\tif (count <= 0)\n\t\treturn 0;\n\n\tsccb = (struct sclp_vt220_sccb *) request->sclp_req.sccb;\n\tbuffer = (void *) ((addr_t) sccb + sccb->header.length);\n\n\tif (convertlf) {\n\t\t \n\t\tfor (from=0, to=0;\n\t\t     (from < count) && (to < sclp_vt220_space_left(request));\n\t\t     from++) {\n\t\t\t \n\t\t\tc = msg[from];\n\t\t\t \n\t\t\tif (c == 0x0a) {\n\t\t\t\tif (to + 1 < sclp_vt220_space_left(request)) {\n\t\t\t\t\t((unsigned char *) buffer)[to++] = c;\n\t\t\t\t\t((unsigned char *) buffer)[to++] = 0x0d;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\n\t\t\t} else\n\t\t\t\t((unsigned char *) buffer)[to++] = c;\n\t\t}\n\t\tsccb->header.length += to;\n\t\tsccb->evbuf.length += to;\n\t\treturn from;\n\t} else {\n\t\tmemcpy(buffer, (const void *) msg, count);\n\t\tsccb->header.length += count;\n\t\tsccb->evbuf.length += count;\n\t\treturn count;\n\t}\n}\n\n \nstatic void\nsclp_vt220_timeout(struct timer_list *unused)\n{\n\tsclp_vt220_emit_current();\n}\n\n#define BUFFER_MAX_DELAY\tHZ/20\n\n \nstatic int\nsclp_vt220_drop_buffer(void)\n{\n\tstruct list_head *list;\n\tstruct sclp_vt220_request *request;\n\tvoid *page;\n\n\tif (!sclp_console_drop)\n\t\treturn 0;\n\tlist = sclp_vt220_outqueue.next;\n\tif (sclp_vt220_queue_running)\n\t\t \n\t\tlist = list->next;\n\tif (list == &sclp_vt220_outqueue)\n\t\treturn 0;\n\tlist_del(list);\n\trequest = list_entry(list, struct sclp_vt220_request, list);\n\tpage = request->sclp_req.sccb;\n\tlist_add_tail((struct list_head *) page, &sclp_vt220_empty);\n\treturn 1;\n}\n\n \nstatic int\n__sclp_vt220_write(const unsigned char *buf, int count, int do_schedule,\n\t\t   int convertlf, int may_fail)\n{\n\tunsigned long flags;\n\tvoid *page;\n\tint written;\n\tint overall_written;\n\n\tif (count <= 0)\n\t\treturn 0;\n\toverall_written = 0;\n\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\tdo {\n\t\t \n\t\tif (sclp_vt220_current_request == NULL) {\n\t\t\tif (list_empty(&sclp_vt220_empty))\n\t\t\t\tsclp_console_full++;\n\t\t\twhile (list_empty(&sclp_vt220_empty)) {\n\t\t\t\tif (may_fail)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (sclp_vt220_drop_buffer())\n\t\t\t\t\tbreak;\n\t\t\t\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\n\t\t\t\tsclp_sync_wait();\n\t\t\t\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\t\t\t}\n\t\t\tpage = (void *) sclp_vt220_empty.next;\n\t\t\tlist_del((struct list_head *) page);\n\t\t\tsclp_vt220_current_request =\n\t\t\t\tsclp_vt220_initialize_page(page);\n\t\t}\n\t\t \n\t\twritten = sclp_vt220_add_msg(sclp_vt220_current_request,\n\t\t\t\t\t     buf, count, convertlf);\n\t\toverall_written += written;\n\t\tif (written == count)\n\t\t\tbreak;\n\t\t \n\t\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\t\tsclp_vt220_emit_current();\n\t\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\t\tbuf += written;\n\t\tcount -= written;\n\t} while (count > 0);\n\t \n\tif (sclp_vt220_current_request != NULL &&\n\t    !timer_pending(&sclp_vt220_timer) && do_schedule) {\n\t\tsclp_vt220_timer.expires = jiffies + BUFFER_MAX_DELAY;\n\t\tadd_timer(&sclp_vt220_timer);\n\t}\nout:\n\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\treturn overall_written;\n}\n\n \nstatic ssize_t\nsclp_vt220_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\treturn __sclp_vt220_write(buf, count, 1, 0, 1);\n}\n\n#define SCLP_VT220_SESSION_ENDED\t0x01\n#define\tSCLP_VT220_SESSION_STARTED\t0x80\n#define SCLP_VT220_SESSION_DATA\t\t0x00\n\n#ifdef CONFIG_MAGIC_SYSRQ\n\nstatic int sysrq_pressed;\nstatic struct sysrq_work sysrq;\n\nstatic void sclp_vt220_reset_session(void)\n{\n\tsysrq_pressed = 0;\n}\n\nstatic void sclp_vt220_handle_input(const char *buffer, unsigned int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (buffer[i] == ('O' ^ 0100)) {  \n\t\t\t \n\t\t\tsysrq_pressed = !sysrq_pressed;\n\t\t\tif (sysrq_pressed)\n\t\t\t\tcontinue;\n\t\t} else if (sysrq_pressed) {\n\t\t\tsysrq.key = buffer[i];\n\t\t\tschedule_sysrq_work(&sysrq);\n\t\t\tsysrq_pressed = 0;\n\t\t\tcontinue;\n\t\t}\n\t\ttty_insert_flip_char(&sclp_vt220_port, buffer[i], 0);\n\t}\n}\n\n#else\n\nstatic void sclp_vt220_reset_session(void)\n{\n}\n\nstatic void sclp_vt220_handle_input(const char *buffer, unsigned int count)\n{\n\ttty_insert_flip_string(&sclp_vt220_port, buffer, count);\n}\n\n#endif\n\n \nstatic void\nsclp_vt220_receiver_fn(struct evbuf_header *evbuf)\n{\n\tchar *buffer;\n\tunsigned int count;\n\n\tbuffer = (char *) ((addr_t) evbuf + sizeof(struct evbuf_header));\n\tcount = evbuf->length - sizeof(struct evbuf_header);\n\n\tswitch (*buffer) {\n\tcase SCLP_VT220_SESSION_ENDED:\n\tcase SCLP_VT220_SESSION_STARTED:\n\t\tsclp_vt220_reset_session();\n\t\tbreak;\n\tcase SCLP_VT220_SESSION_DATA:\n\t\t \n\t\tbuffer++;\n\t\tcount--;\n\t\tsclp_vt220_handle_input(buffer, count);\n\t\ttty_flip_buffer_push(&sclp_vt220_port);\n\t\tbreak;\n\t}\n}\n\n \nstatic int\nsclp_vt220_open(struct tty_struct *tty, struct file *filp)\n{\n\tif (tty->count == 1) {\n\t\ttty_port_tty_set(&sclp_vt220_port, tty);\n\t\tif (!tty->winsize.ws_row && !tty->winsize.ws_col) {\n\t\t\ttty->winsize.ws_row = 24;\n\t\t\ttty->winsize.ws_col = 80;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void\nsclp_vt220_close(struct tty_struct *tty, struct file *filp)\n{\n\tif (tty->count == 1)\n\t\ttty_port_tty_set(&sclp_vt220_port, NULL);\n}\n\n \nstatic int\nsclp_vt220_put_char(struct tty_struct *tty, u8 ch)\n{\n\treturn __sclp_vt220_write(&ch, 1, 0, 0, 1);\n}\n\n \nstatic void\nsclp_vt220_flush_chars(struct tty_struct *tty)\n{\n\tif (!sclp_vt220_queue_running)\n\t\tsclp_vt220_emit_current();\n\telse\n\t\tsclp_vt220_flush_later = 1;\n}\n\n \nstatic unsigned int\nsclp_vt220_write_room(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\tunsigned int count;\n\n\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\tcount = 0;\n\tif (sclp_vt220_current_request != NULL)\n\t\tcount = sclp_vt220_space_left(sclp_vt220_current_request);\n\tlist_for_each(l, &sclp_vt220_empty)\n\t\tcount += SCLP_VT220_MAX_CHARS_PER_BUFFER;\n\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\treturn count;\n}\n\n \nstatic unsigned int\nsclp_vt220_chars_in_buffer(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\tstruct list_head *l;\n\tstruct sclp_vt220_request *r;\n\tunsigned int count = 0;\n\n\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\tif (sclp_vt220_current_request != NULL)\n\t\tcount = sclp_vt220_chars_stored(sclp_vt220_current_request);\n\tlist_for_each(l, &sclp_vt220_outqueue) {\n\t\tr = list_entry(l, struct sclp_vt220_request, list);\n\t\tcount += sclp_vt220_chars_stored(r);\n\t}\n\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\treturn count;\n}\n\n \nstatic void\nsclp_vt220_flush_buffer(struct tty_struct *tty)\n{\n\tsclp_vt220_emit_current();\n}\n\n \nstatic void __init __sclp_vt220_free_pages(void)\n{\n\tstruct list_head *page, *p;\n\n\tlist_for_each_safe(page, p, &sclp_vt220_empty) {\n\t\tlist_del(page);\n\t\tfree_page((unsigned long) page);\n\t}\n}\n\n \nstatic void __init __sclp_vt220_cleanup(void)\n{\n\tsclp_vt220_init_count--;\n\tif (sclp_vt220_init_count != 0)\n\t\treturn;\n\tsclp_unregister(&sclp_vt220_register);\n\t__sclp_vt220_free_pages();\n\ttty_port_destroy(&sclp_vt220_port);\n}\n\n \nstatic int __init __sclp_vt220_init(int num_pages)\n{\n\tvoid *page;\n\tint i;\n\tint rc;\n\n\tsclp_vt220_init_count++;\n\tif (sclp_vt220_init_count != 1)\n\t\treturn 0;\n\ttimer_setup(&sclp_vt220_timer, sclp_vt220_timeout, 0);\n\ttty_port_init(&sclp_vt220_port);\n\tsclp_vt220_current_request = NULL;\n\tsclp_vt220_buffered_chars = 0;\n\tsclp_vt220_flush_later = 0;\n\n\t \n\trc = -ENOMEM;\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\t\tif (!page)\n\t\t\tgoto out;\n\t\tlist_add_tail(page, &sclp_vt220_empty);\n\t}\n\trc = sclp_register(&sclp_vt220_register);\nout:\n\tif (rc) {\n\t\t__sclp_vt220_free_pages();\n\t\tsclp_vt220_init_count--;\n\t\ttty_port_destroy(&sclp_vt220_port);\n\t}\n\treturn rc;\n}\n\nstatic const struct tty_operations sclp_vt220_ops = {\n\t.open = sclp_vt220_open,\n\t.close = sclp_vt220_close,\n\t.write = sclp_vt220_write,\n\t.put_char = sclp_vt220_put_char,\n\t.flush_chars = sclp_vt220_flush_chars,\n\t.write_room = sclp_vt220_write_room,\n\t.chars_in_buffer = sclp_vt220_chars_in_buffer,\n\t.flush_buffer = sclp_vt220_flush_buffer,\n};\n\n \nstatic int __init sclp_vt220_tty_init(void)\n{\n\tstruct tty_driver *driver;\n\tint rc;\n\n\t \n\tdriver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);\n\tif (IS_ERR(driver))\n\t\treturn PTR_ERR(driver);\n\trc = __sclp_vt220_init(MAX_KMEM_PAGES);\n\tif (rc)\n\t\tgoto out_driver;\n\n\tdriver->driver_name = SCLP_VT220_DRIVER_NAME;\n\tdriver->name = SCLP_VT220_DEVICE_NAME;\n\tdriver->major = SCLP_VT220_MAJOR;\n\tdriver->minor_start = SCLP_VT220_MINOR;\n\tdriver->type = TTY_DRIVER_TYPE_SYSTEM;\n\tdriver->subtype = SYSTEM_TYPE_TTY;\n\tdriver->init_termios = tty_std_termios;\n\ttty_set_operations(driver, &sclp_vt220_ops);\n\ttty_port_link_device(&sclp_vt220_port, driver, 0);\n\n\trc = tty_register_driver(driver);\n\tif (rc)\n\t\tgoto out_init;\n\trc = sclp_register(&sclp_vt220_register_input);\n\tif (rc)\n\t\tgoto out_reg;\n\tsclp_vt220_driver = driver;\n\treturn 0;\n\nout_reg:\n\ttty_unregister_driver(driver);\nout_init:\n\t__sclp_vt220_cleanup();\nout_driver:\n\ttty_driver_kref_put(driver);\n\treturn rc;\n}\n__initcall(sclp_vt220_tty_init);\n\n#ifdef CONFIG_SCLP_VT220_CONSOLE\n\nstatic void\nsclp_vt220_con_write(struct console *con, const char *buf, unsigned int count)\n{\n\t__sclp_vt220_write((const unsigned char *) buf, count, 1, 1, 0);\n}\n\nstatic struct tty_driver *\nsclp_vt220_con_device(struct console *c, int *index)\n{\n\t*index = 0;\n\treturn sclp_vt220_driver;\n}\n\n \nstatic int\nsclp_vt220_notify(struct notifier_block *self,\n\t\t\t  unsigned long event, void *data)\n{\n\tunsigned long flags;\n\n\tif (spin_is_locked(&sclp_vt220_lock))\n\t\treturn NOTIFY_DONE;\n\n\tsclp_vt220_emit_current();\n\n\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\tdel_timer(&sclp_vt220_timer);\n\twhile (sclp_vt220_queue_running) {\n\t\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\t\tsclp_sync_wait();\n\t\tspin_lock_irqsave(&sclp_vt220_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&sclp_vt220_lock, flags);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block on_panic_nb = {\n\t.notifier_call = sclp_vt220_notify,\n\t.priority = INT_MIN + 1,  \n};\n\nstatic struct notifier_block on_reboot_nb = {\n\t.notifier_call = sclp_vt220_notify,\n\t.priority = INT_MIN + 1,  \n};\n\n \nstatic struct console sclp_vt220_console =\n{\n\t.name = SCLP_VT220_CONSOLE_NAME,\n\t.write = sclp_vt220_con_write,\n\t.device = sclp_vt220_con_device,\n\t.flags = CON_PRINTBUFFER,\n\t.index = SCLP_VT220_CONSOLE_INDEX\n};\n\nstatic int __init\nsclp_vt220_con_init(void)\n{\n\tint rc;\n\n\trc = __sclp_vt220_init(sclp_console_pages);\n\tif (rc)\n\t\treturn rc;\n\t \n\tatomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\n\tregister_reboot_notifier(&on_reboot_nb);\n\tregister_console(&sclp_vt220_console);\n\treturn 0;\n}\n\nconsole_initcall(sclp_vt220_con_init);\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}