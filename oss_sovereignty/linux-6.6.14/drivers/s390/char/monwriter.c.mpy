{
  "module_name": "monwriter.c",
  "hash_id": "94740688126c091c8f338f73fbe25ff459be0e6ed42059a3c3ebda3f81fdefd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/monwriter.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"monwriter\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/ctype.h>\n#include <linux/poll.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <asm/ebcdic.h>\n#include <asm/appldata.h>\n#include <asm/monwriter.h>\n\n#define MONWRITE_MAX_DATALEN\t4010\n\nstatic int mon_max_bufs = 255;\nstatic int mon_buf_count;\n\nstruct mon_buf {\n\tstruct list_head list;\n\tstruct monwrite_hdr hdr;\n\tint diag_done;\n\tchar *data;\n};\n\nstruct mon_private {\n\tstruct list_head list;\n\tstruct monwrite_hdr hdr;\n\tsize_t hdr_to_read;\n\tsize_t data_to_read;\n\tstruct mon_buf *current_buf;\n\tstruct mutex thread_mutex;\n};\n\n \n\nstatic int monwrite_diag(struct monwrite_hdr *myhdr, char *buffer, int fcn)\n{\n\tstruct appldata_parameter_list *parm_list;\n\tstruct appldata_product_id *id;\n\tint rc;\n\n\tid = kmalloc(sizeof(*id), GFP_KERNEL);\n\tparm_list = kmalloc(sizeof(*parm_list), GFP_KERNEL);\n\trc = -ENOMEM;\n\tif (!id || !parm_list)\n\t\tgoto out;\n\tmemcpy(id->prod_nr, \"LNXAPPL\", 7);\n\tid->prod_fn = myhdr->applid;\n\tid->record_nr = myhdr->record_num;\n\tid->version_nr = myhdr->version;\n\tid->release_nr = myhdr->release;\n\tid->mod_lvl = myhdr->mod_level;\n\trc = appldata_asm(parm_list, id, fcn,\n\t\t\t  (void *) buffer, myhdr->datalen);\n\tif (rc <= 0)\n\t\tgoto out;\n\tpr_err(\"Writing monitor data failed with rc=%i\\n\", rc);\n\trc = (rc == 5) ? -EPERM : -EINVAL;\nout:\n\tkfree(id);\n\tkfree(parm_list);\n\treturn rc;\n}\n\nstatic struct mon_buf *monwrite_find_hdr(struct mon_private *monpriv,\n\t\t\t\t\t struct monwrite_hdr *monhdr)\n{\n\tstruct mon_buf *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, &monpriv->list, list)\n\t\tif ((entry->hdr.mon_function == monhdr->mon_function ||\n\t\t     monhdr->mon_function == MONWRITE_STOP_INTERVAL) &&\n\t\t    entry->hdr.applid == monhdr->applid &&\n\t\t    entry->hdr.record_num == monhdr->record_num &&\n\t\t    entry->hdr.version == monhdr->version &&\n\t\t    entry->hdr.release == monhdr->release &&\n\t\t    entry->hdr.mod_level == monhdr->mod_level)\n\t\t\treturn entry;\n\n\treturn NULL;\n}\n\nstatic int monwrite_new_hdr(struct mon_private *monpriv)\n{\n\tstruct monwrite_hdr *monhdr = &monpriv->hdr;\n\tstruct mon_buf *monbuf;\n\tint rc = 0;\n\n\tif (monhdr->datalen > MONWRITE_MAX_DATALEN ||\n\t    monhdr->mon_function > MONWRITE_START_CONFIG ||\n\t    monhdr->hdrlen != sizeof(struct monwrite_hdr))\n\t\treturn -EINVAL;\n\tmonbuf = NULL;\n\tif (monhdr->mon_function != MONWRITE_GEN_EVENT)\n\t\tmonbuf = monwrite_find_hdr(monpriv, monhdr);\n\tif (monbuf) {\n\t\tif (monhdr->mon_function == MONWRITE_STOP_INTERVAL) {\n\t\t\tmonhdr->datalen = monbuf->hdr.datalen;\n\t\t\trc = monwrite_diag(monhdr, monbuf->data,\n\t\t\t\t\t   APPLDATA_STOP_REC);\n\t\t\tlist_del(&monbuf->list);\n\t\t\tmon_buf_count--;\n\t\t\tkfree(monbuf->data);\n\t\t\tkfree(monbuf);\n\t\t\tmonbuf = NULL;\n\t\t}\n\t} else if (monhdr->mon_function != MONWRITE_STOP_INTERVAL) {\n\t\tif (mon_buf_count >= mon_max_bufs)\n\t\t\treturn -ENOSPC;\n\t\tmonbuf = kzalloc(sizeof(struct mon_buf), GFP_KERNEL);\n\t\tif (!monbuf)\n\t\t\treturn -ENOMEM;\n\t\tmonbuf->data = kzalloc(monhdr->datalen,\n\t\t\t\t       GFP_KERNEL | GFP_DMA);\n\t\tif (!monbuf->data) {\n\t\t\tkfree(monbuf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmonbuf->hdr = *monhdr;\n\t\tlist_add_tail(&monbuf->list, &monpriv->list);\n\t\tif (monhdr->mon_function != MONWRITE_GEN_EVENT)\n\t\t\tmon_buf_count++;\n\t}\n\tmonpriv->current_buf = monbuf;\n\treturn rc;\n}\n\nstatic int monwrite_new_data(struct mon_private *monpriv)\n{\n\tstruct monwrite_hdr *monhdr = &monpriv->hdr;\n\tstruct mon_buf *monbuf = monpriv->current_buf;\n\tint rc = 0;\n\n\tswitch (monhdr->mon_function) {\n\tcase MONWRITE_START_INTERVAL:\n\t\tif (!monbuf->diag_done) {\n\t\t\trc = monwrite_diag(monhdr, monbuf->data,\n\t\t\t\t\t   APPLDATA_START_INTERVAL_REC);\n\t\t\tmonbuf->diag_done = 1;\n\t\t}\n\t\tbreak;\n\tcase MONWRITE_START_CONFIG:\n\t\tif (!monbuf->diag_done) {\n\t\t\trc = monwrite_diag(monhdr, monbuf->data,\n\t\t\t\t\t   APPLDATA_START_CONFIG_REC);\n\t\t\tmonbuf->diag_done = 1;\n\t\t}\n\t\tbreak;\n\tcase MONWRITE_GEN_EVENT:\n\t\trc = monwrite_diag(monhdr, monbuf->data,\n\t\t\t\t   APPLDATA_GEN_EVENT_REC);\n\t\tlist_del(&monpriv->current_buf->list);\n\t\tkfree(monpriv->current_buf->data);\n\t\tkfree(monpriv->current_buf);\n\t\tmonpriv->current_buf = NULL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tBUG();\n\t}\n\treturn rc;\n}\n\n \n\nstatic int monwrite_open(struct inode *inode, struct file *filp)\n{\n\tstruct mon_private *monpriv;\n\n\tmonpriv = kzalloc(sizeof(struct mon_private), GFP_KERNEL);\n\tif (!monpriv)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&monpriv->list);\n\tmonpriv->hdr_to_read = sizeof(monpriv->hdr);\n\tmutex_init(&monpriv->thread_mutex);\n\tfilp->private_data = monpriv;\n\treturn nonseekable_open(inode, filp);\n}\n\nstatic int monwrite_close(struct inode *inode, struct file *filp)\n{\n\tstruct mon_private *monpriv = filp->private_data;\n\tstruct mon_buf *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, &monpriv->list, list) {\n\t\tif (entry->hdr.mon_function != MONWRITE_GEN_EVENT)\n\t\t\tmonwrite_diag(&entry->hdr, entry->data,\n\t\t\t\t      APPLDATA_STOP_REC);\n\t\tmon_buf_count--;\n\t\tlist_del(&entry->list);\n\t\tkfree(entry->data);\n\t\tkfree(entry);\n\t}\n\tkfree(monpriv);\n\treturn 0;\n}\n\nstatic ssize_t monwrite_write(struct file *filp, const char __user *data,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct mon_private *monpriv = filp->private_data;\n\tsize_t len, written;\n\tvoid *to;\n\tint rc;\n\n\tmutex_lock(&monpriv->thread_mutex);\n\tfor (written = 0; written < count; ) {\n\t\tif (monpriv->hdr_to_read) {\n\t\t\tlen = min(count - written, monpriv->hdr_to_read);\n\t\t\tto = (char *) &monpriv->hdr +\n\t\t\t\tsizeof(monpriv->hdr) - monpriv->hdr_to_read;\n\t\t\tif (copy_from_user(to, data + written, len)) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tmonpriv->hdr_to_read -= len;\n\t\t\twritten += len;\n\t\t\tif (monpriv->hdr_to_read > 0)\n\t\t\t\tcontinue;\n\t\t\trc = monwrite_new_hdr(monpriv);\n\t\t\tif (rc)\n\t\t\t\tgoto out_error;\n\t\t\tmonpriv->data_to_read = monpriv->current_buf ?\n\t\t\t\tmonpriv->current_buf->hdr.datalen : 0;\n\t\t}\n\n\t\tif (monpriv->data_to_read) {\n\t\t\tlen = min(count - written, monpriv->data_to_read);\n\t\t\tto = monpriv->current_buf->data +\n\t\t\t\tmonpriv->hdr.datalen - monpriv->data_to_read;\n\t\t\tif (copy_from_user(to, data + written, len)) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tmonpriv->data_to_read -= len;\n\t\t\twritten += len;\n\t\t\tif (monpriv->data_to_read > 0)\n\t\t\t\tcontinue;\n\t\t\trc = monwrite_new_data(monpriv);\n\t\t\tif (rc)\n\t\t\t\tgoto out_error;\n\t\t}\n\t\tmonpriv->hdr_to_read = sizeof(monpriv->hdr);\n\t}\n\tmutex_unlock(&monpriv->thread_mutex);\n\treturn written;\n\nout_error:\n\tmonpriv->data_to_read = 0;\n\tmonpriv->hdr_to_read = sizeof(struct monwrite_hdr);\n\tmutex_unlock(&monpriv->thread_mutex);\n\treturn rc;\n}\n\nstatic const struct file_operations monwrite_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open\t = &monwrite_open,\n\t.release = &monwrite_close,\n\t.write\t = &monwrite_write,\n\t.llseek  = noop_llseek,\n};\n\nstatic struct miscdevice mon_dev = {\n\t.name\t= \"monwriter\",\n\t.fops\t= &monwrite_fops,\n\t.minor\t= MISC_DYNAMIC_MINOR,\n};\n\n \n\nstatic int __init mon_init(void)\n{\n\tif (!MACHINE_IS_VM)\n\t\treturn -ENODEV;\n\t \n\treturn misc_register(&mon_dev);\n}\n\nstatic void __exit mon_exit(void)\n{\n\tmisc_deregister(&mon_dev);\n}\n\nmodule_init(mon_init);\nmodule_exit(mon_exit);\n\nmodule_param_named(max_bufs, mon_max_bufs, int, 0644);\nMODULE_PARM_DESC(max_bufs, \"Maximum number of sample monitor data buffers \"\n\t\t \"that can be active at one time\");\n\nMODULE_AUTHOR(\"Melissa Howland <Melissa.Howland@us.ibm.com>\");\nMODULE_DESCRIPTION(\"Character device driver for writing z/VM \"\n\t\t   \"APPLDATA monitor records.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}