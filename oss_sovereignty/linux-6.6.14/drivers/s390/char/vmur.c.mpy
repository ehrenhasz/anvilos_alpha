{
  "module_name": "vmur.c",
  "hash_id": "4151c89bbc0d0e4d793b3118e49e2a0d3c09538e4c73a9c2104c8e28d91f43ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/vmur.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"vmur\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/cdev.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\n#include <linux/uaccess.h>\n#include <asm/cio.h>\n#include <asm/ccwdev.h>\n#include <asm/debug.h>\n#include <asm/diag.h>\n#include <asm/scsw.h>\n\n#include \"vmur.h\"\n\n \n\nstatic char ur_banner[] = \"z/VM virtual unit record device driver\";\n\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"s390 z/VM virtual unit record device driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic dev_t ur_first_dev_maj_min;\nstatic struct class *vmur_class;\nstatic struct debug_info *vmur_dbf;\n\n \nstatic struct ccw_device_id ur_ids[] = {\n\t{ CCWDEV_CU_DI(READER_PUNCH_DEVTYPE, 80) },\n\t{ CCWDEV_CU_DI(PRINTER_DEVTYPE, 132) },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(ccw, ur_ids);\n\nstatic int ur_probe(struct ccw_device *cdev);\nstatic void ur_remove(struct ccw_device *cdev);\nstatic int ur_set_online(struct ccw_device *cdev);\nstatic int ur_set_offline(struct ccw_device *cdev);\n\nstatic struct ccw_driver ur_driver = {\n\t.driver = {\n\t\t.name\t= \"vmur\",\n\t\t.owner\t= THIS_MODULE,\n\t},\n\t.ids\t\t= ur_ids,\n\t.probe\t\t= ur_probe,\n\t.remove\t\t= ur_remove,\n\t.set_online\t= ur_set_online,\n\t.set_offline\t= ur_set_offline,\n\t.int_class\t= IRQIO_VMR,\n};\n\nstatic DEFINE_MUTEX(vmur_mutex);\n\nstatic void ur_uevent(struct work_struct *ws);\n\n \nstatic struct urdev *urdev_alloc(struct ccw_device *cdev)\n{\n\tstruct urdev *urd;\n\n\turd = kzalloc(sizeof(struct urdev), GFP_KERNEL);\n\tif (!urd)\n\t\treturn NULL;\n\turd->reclen = cdev->id.driver_info;\n\tccw_device_get_id(cdev, &urd->dev_id);\n\tmutex_init(&urd->io_mutex);\n\tinit_waitqueue_head(&urd->wait);\n\tINIT_WORK(&urd->uevent_work, ur_uevent);\n\tspin_lock_init(&urd->open_lock);\n\trefcount_set(&urd->ref_count,  1);\n\turd->cdev = cdev;\n\tget_device(&cdev->dev);\n\treturn urd;\n}\n\nstatic void urdev_free(struct urdev *urd)\n{\n\tTRACE(\"urdev_free: %p\\n\", urd);\n\tif (urd->cdev)\n\t\tput_device(&urd->cdev->dev);\n\tkfree(urd);\n}\n\nstatic void urdev_get(struct urdev *urd)\n{\n\trefcount_inc(&urd->ref_count);\n}\n\nstatic struct urdev *urdev_get_from_cdev(struct ccw_device *cdev)\n{\n\tstruct urdev *urd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\turd = dev_get_drvdata(&cdev->dev);\n\tif (urd)\n\t\turdev_get(urd);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\treturn urd;\n}\n\nstatic struct urdev *urdev_get_from_devno(u16 devno)\n{\n\tchar bus_id[16];\n\tstruct ccw_device *cdev;\n\tstruct urdev *urd;\n\n\tsprintf(bus_id, \"0.0.%04x\", devno);\n\tcdev = get_ccwdev_by_busid(&ur_driver, bus_id);\n\tif (!cdev)\n\t\treturn NULL;\n\turd = urdev_get_from_cdev(cdev);\n\tput_device(&cdev->dev);\n\treturn urd;\n}\n\nstatic void urdev_put(struct urdev *urd)\n{\n\tif (refcount_dec_and_test(&urd->ref_count))\n\t\turdev_free(urd);\n}\n\n \n\nstatic void free_chan_prog(struct ccw1 *cpa)\n{\n\tstruct ccw1 *ptr = cpa;\n\n\twhile (ptr->cda) {\n\t\tkfree((void *)(addr_t) ptr->cda);\n\t\tptr++;\n\t}\n\tkfree(cpa);\n}\n\n \nstatic struct ccw1 *alloc_chan_prog(const char __user *ubuf, int rec_count,\n\t\t\t\t    int reclen)\n{\n\tstruct ccw1 *cpa;\n\tvoid *kbuf;\n\tint i;\n\n\tTRACE(\"alloc_chan_prog(%p, %i, %i)\\n\", ubuf, rec_count, reclen);\n\n\t \n\tcpa = kcalloc(rec_count + 1, sizeof(struct ccw1),\n\t\t      GFP_KERNEL | GFP_DMA);\n\tif (!cpa)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < rec_count; i++) {\n\t\tcpa[i].cmd_code = WRITE_CCW_CMD;\n\t\tcpa[i].flags = CCW_FLAG_CC | CCW_FLAG_SLI;\n\t\tcpa[i].count = reclen;\n\t\tkbuf = kmalloc(reclen, GFP_KERNEL | GFP_DMA);\n\t\tif (!kbuf) {\n\t\t\tfree_chan_prog(cpa);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tcpa[i].cda = (u32)(addr_t) kbuf;\n\t\tif (copy_from_user(kbuf, ubuf, reclen)) {\n\t\t\tfree_chan_prog(cpa);\n\t\t\treturn ERR_PTR(-EFAULT);\n\t\t}\n\t\tubuf += reclen;\n\t}\n\t \n\tcpa[i].cmd_code = CCW_CMD_NOOP;\n\treturn cpa;\n}\n\nstatic int do_ur_io(struct urdev *urd, struct ccw1 *cpa)\n{\n\tint rc;\n\tstruct ccw_device *cdev = urd->cdev;\n\tDECLARE_COMPLETION_ONSTACK(event);\n\n\tTRACE(\"do_ur_io: cpa=%p\\n\", cpa);\n\n\trc = mutex_lock_interruptible(&urd->io_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\turd->io_done = &event;\n\n\tspin_lock_irq(get_ccwdev_lock(cdev));\n\trc = ccw_device_start(cdev, cpa, 1, 0, 0);\n\tspin_unlock_irq(get_ccwdev_lock(cdev));\n\n\tTRACE(\"do_ur_io: ccw_device_start returned %d\\n\", rc);\n\tif (rc)\n\t\tgoto out;\n\n\twait_for_completion(&event);\n\tTRACE(\"do_ur_io: I/O complete\\n\");\n\trc = 0;\n\nout:\n\tmutex_unlock(&urd->io_mutex);\n\treturn rc;\n}\n\nstatic void ur_uevent(struct work_struct *ws)\n{\n\tstruct urdev *urd = container_of(ws, struct urdev, uevent_work);\n\tchar *envp[] = {\n\t\t\"EVENT=unsol_de\",\t \n\t\tNULL\n\t};\n\n\tkobject_uevent_env(&urd->cdev->dev.kobj, KOBJ_CHANGE, envp);\n\turdev_put(urd);\n}\n\n \nstatic void ur_int_handler(struct ccw_device *cdev, unsigned long intparm,\n\t\t\t   struct irb *irb)\n{\n\tstruct urdev *urd;\n\n\tif (!IS_ERR(irb)) {\n\t\tTRACE(\"ur_int_handler: intparm=0x%lx cstat=%02x dstat=%02x res=%u\\n\",\n\t\t      intparm, irb->scsw.cmd.cstat, irb->scsw.cmd.dstat,\n\t\t      irb->scsw.cmd.count);\n\t}\n\turd = dev_get_drvdata(&cdev->dev);\n\tif (!intparm) {\n\t\tTRACE(\"ur_int_handler: unsolicited interrupt\\n\");\n\n\t\tif (scsw_dstat(&irb->scsw) & DEV_STAT_DEV_END) {\n\t\t\t \n\t\t\turdev_get(urd);\n\t\t\tschedule_work(&urd->uevent_work);\n\t\t}\n\n\t\treturn;\n\t}\n\t \n\tif (IS_ERR(irb))\n\t\turd->io_request_rc = PTR_ERR(irb);\n\telse if (irb->scsw.cmd.dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))\n\t\turd->io_request_rc = 0;\n\telse\n\t\turd->io_request_rc = -EIO;\n\n\tcomplete(urd->io_done);\n}\n\n \nstatic ssize_t ur_attr_reclen_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct urdev *urd;\n\tint rc;\n\n\turd = urdev_get_from_cdev(to_ccwdev(dev));\n\tif (!urd)\n\t\treturn -ENODEV;\n\trc = sprintf(buf, \"%zu\\n\", urd->reclen);\n\turdev_put(urd);\n\treturn rc;\n}\n\nstatic DEVICE_ATTR(reclen, 0444, ur_attr_reclen_show, NULL);\n\nstatic int ur_create_attributes(struct device *dev)\n{\n\treturn device_create_file(dev, &dev_attr_reclen);\n}\n\nstatic void ur_remove_attributes(struct device *dev)\n{\n\tdevice_remove_file(dev, &dev_attr_reclen);\n}\n\n \nstatic int get_urd_class(struct urdev *urd)\n{\n\tstatic struct diag210 ur_diag210;\n\tint cc;\n\n\tur_diag210.vrdcdvno = urd->dev_id.devno;\n\tur_diag210.vrdclen = sizeof(struct diag210);\n\n\tcc = diag210(&ur_diag210);\n\tswitch (cc) {\n\tcase 0:\n\t\treturn -EOPNOTSUPP;\n\tcase 2:\n\t\treturn ur_diag210.vrdcvcla;  \n\tcase 3:\n\t\treturn -ENODEV;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n \nstatic struct urfile *urfile_alloc(struct urdev *urd)\n{\n\tstruct urfile *urf;\n\n\turf = kzalloc(sizeof(struct urfile), GFP_KERNEL);\n\tif (!urf)\n\t\treturn NULL;\n\turf->urd = urd;\n\n\tTRACE(\"urfile_alloc: urd=%p urf=%p rl=%zu\\n\", urd, urf,\n\t      urf->dev_reclen);\n\n\treturn urf;\n}\n\nstatic void urfile_free(struct urfile *urf)\n{\n\tTRACE(\"urfile_free: urf=%p urd=%p\\n\", urf, urf->urd);\n\tkfree(urf);\n}\n\n \nstatic ssize_t do_write(struct urdev *urd, const char __user *udata,\n\t\t\tsize_t count, size_t reclen, loff_t *ppos)\n{\n\tstruct ccw1 *cpa;\n\tint rc;\n\n\tcpa = alloc_chan_prog(udata, count / reclen, reclen);\n\tif (IS_ERR(cpa))\n\t\treturn PTR_ERR(cpa);\n\n\trc = do_ur_io(urd, cpa);\n\tif (rc)\n\t\tgoto fail_kfree_cpa;\n\n\tif (urd->io_request_rc) {\n\t\trc = urd->io_request_rc;\n\t\tgoto fail_kfree_cpa;\n\t}\n\t*ppos += count;\n\trc = count;\n\nfail_kfree_cpa:\n\tfree_chan_prog(cpa);\n\treturn rc;\n}\n\nstatic ssize_t ur_write(struct file *file, const char __user *udata,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct urfile *urf = file->private_data;\n\n\tTRACE(\"ur_write: count=%zu\\n\", count);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tif (count % urf->dev_reclen)\n\t\treturn -EINVAL;\t \n\n\tif (count > urf->dev_reclen * MAX_RECS_PER_IO)\n\t\tcount = urf->dev_reclen * MAX_RECS_PER_IO;\n\n\treturn do_write(urf->urd, udata, count, urf->dev_reclen, ppos);\n}\n\n \nstatic int diag_position_to_record(int devno, int record)\n{\n\tint cc;\n\n\tcc = diag14(record, devno, 0x28);\n\tswitch (cc) {\n\tcase 0:\n\t\treturn 0;\n\tcase 2:\n\t\treturn -ENOMEDIUM;\n\tcase 3:\n\t\treturn -ENODATA;  \n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n \nstatic int diag_read_file(int devno, char *buf)\n{\n\tint cc;\n\n\tcc = diag14((unsigned long) buf, devno, 0x00);\n\tswitch (cc) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn -ENODATA;\n\tcase 2:\n\t\treturn -ENOMEDIUM;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic ssize_t diag14_read(struct file *file, char __user *ubuf, size_t count,\n\t\t\t   loff_t *offs)\n{\n\tsize_t len, copied, res;\n\tchar *buf;\n\tint rc;\n\tu16 reclen;\n\tstruct urdev *urd;\n\n\turd = ((struct urfile *) file->private_data)->urd;\n\treclen = ((struct urfile *) file->private_data)->file_reclen;\n\n\trc = diag_position_to_record(urd->dev_id.devno, *offs / PAGE_SIZE + 1);\n\tif (rc == -ENODATA)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tlen = min((size_t) PAGE_SIZE, count);\n\tbuf = (char *) __get_free_page(GFP_KERNEL | GFP_DMA);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tres = (size_t) (*offs % PAGE_SIZE);\n\tdo {\n\t\trc = diag_read_file(urd->dev_id.devno, buf);\n\t\tif (rc == -ENODATA) {\n\t\t\tbreak;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\tif (reclen && (copied == 0) && (*offs < PAGE_SIZE))\n\t\t\t*((u16 *) &buf[FILE_RECLEN_OFFSET]) = reclen;\n\t\tlen = min(count - copied, PAGE_SIZE - res);\n\t\tif (copy_to_user(ubuf + copied, buf + res, len)) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto fail;\n\t\t}\n\t\tres = 0;\n\t\tcopied += len;\n\t} while (copied != count);\n\n\t*offs += copied;\n\trc = copied;\nfail:\n\tfree_page((unsigned long) buf);\n\treturn rc;\n}\n\nstatic ssize_t ur_read(struct file *file, char __user *ubuf, size_t count,\n\t\t       loff_t *offs)\n{\n\tstruct urdev *urd;\n\tint rc;\n\n\tTRACE(\"ur_read: count=%zu ppos=%li\\n\", count, (unsigned long) *offs);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\turd = ((struct urfile *) file->private_data)->urd;\n\trc = mutex_lock_interruptible(&urd->io_mutex);\n\tif (rc)\n\t\treturn rc;\n\trc = diag14_read(file, ubuf, count, offs);\n\tmutex_unlock(&urd->io_mutex);\n\treturn rc;\n}\n\n \nstatic int diag_read_next_file_info(struct file_control_block *buf, int spid)\n{\n\tint cc;\n\n\tcc = diag14((unsigned long) buf, spid, 0xfff);\n\tswitch (cc) {\n\tcase 0:\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n}\n\nstatic int verify_uri_device(struct urdev *urd)\n{\n\tstruct file_control_block *fcb;\n\tchar *buf;\n\tint rc;\n\n\tfcb = kmalloc(sizeof(*fcb), GFP_KERNEL | GFP_DMA);\n\tif (!fcb)\n\t\treturn -ENOMEM;\n\n\t \n\trc = diag_read_next_file_info(fcb, 0);\n\tif (rc)\n\t\tgoto fail_free_fcb;\n\n\t \n\tif (fcb->file_stat & (FLG_SYSTEM_HOLD | FLG_USER_HOLD)) {\n\t\trc = -EPERM;\n\t\tgoto fail_free_fcb;\n\t}\n\n\t \n\tbuf = (char *) __get_free_page(GFP_KERNEL | GFP_DMA);\n\tif (!buf) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_free_fcb;\n\t}\n\trc = diag_read_file(urd->dev_id.devno, buf);\n\tif ((rc != 0) && (rc != -ENODATA))  \n\t\tgoto fail_free_buf;\n\n\t \n\trc = diag_read_next_file_info(fcb, 0);\n\tif (rc)\n\t\tgoto fail_free_buf;\n\tif (!(fcb->file_stat & FLG_IN_USE)) {\n\t\trc = -EMFILE;\n\t\tgoto fail_free_buf;\n\t}\n\trc = 0;\n\nfail_free_buf:\n\tfree_page((unsigned long) buf);\nfail_free_fcb:\n\tkfree(fcb);\n\treturn rc;\n}\n\nstatic int verify_device(struct urdev *urd)\n{\n\tswitch (urd->class) {\n\tcase DEV_CLASS_UR_O:\n\t\treturn 0;  \n\tcase DEV_CLASS_UR_I:\n\t\treturn verify_uri_device(urd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int get_uri_file_reclen(struct urdev *urd)\n{\n\tstruct file_control_block *fcb;\n\tint rc;\n\n\tfcb = kmalloc(sizeof(*fcb), GFP_KERNEL | GFP_DMA);\n\tif (!fcb)\n\t\treturn -ENOMEM;\n\trc = diag_read_next_file_info(fcb, 0);\n\tif (rc)\n\t\tgoto fail_free;\n\tif (fcb->file_stat & FLG_CP_DUMP)\n\t\trc = 0;\n\telse\n\t\trc = fcb->rec_len;\n\nfail_free:\n\tkfree(fcb);\n\treturn rc;\n}\n\nstatic int get_file_reclen(struct urdev *urd)\n{\n\tswitch (urd->class) {\n\tcase DEV_CLASS_UR_O:\n\t\treturn 0;\n\tcase DEV_CLASS_UR_I:\n\t\treturn get_uri_file_reclen(urd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ur_open(struct inode *inode, struct file *file)\n{\n\tu16 devno;\n\tstruct urdev *urd;\n\tstruct urfile *urf;\n\tunsigned short accmode;\n\tint rc;\n\n\taccmode = file->f_flags & O_ACCMODE;\n\n\tif (accmode == O_RDWR)\n\t\treturn -EACCES;\n\t \n\tdevno = iminor(file_inode(file));\n\n\turd = urdev_get_from_devno(devno);\n\tif (!urd) {\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&urd->open_lock);\n\twhile (urd->open_flag) {\n\t\tspin_unlock(&urd->open_lock);\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\trc = -EBUSY;\n\t\t\tgoto fail_put;\n\t\t}\n\t\tif (wait_event_interruptible(urd->wait, urd->open_flag == 0)) {\n\t\t\trc = -ERESTARTSYS;\n\t\t\tgoto fail_put;\n\t\t}\n\t\tspin_lock(&urd->open_lock);\n\t}\n\turd->open_flag++;\n\tspin_unlock(&urd->open_lock);\n\n\tTRACE(\"ur_open\\n\");\n\n\tif (((accmode == O_RDONLY) && (urd->class != DEV_CLASS_UR_I)) ||\n\t    ((accmode == O_WRONLY) && (urd->class != DEV_CLASS_UR_O))) {\n\t\tTRACE(\"ur_open: unsupported dev class (%d)\\n\", urd->class);\n\t\trc = -EACCES;\n\t\tgoto fail_unlock;\n\t}\n\n\trc = verify_device(urd);\n\tif (rc)\n\t\tgoto fail_unlock;\n\n\turf = urfile_alloc(urd);\n\tif (!urf) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_unlock;\n\t}\n\n\turf->dev_reclen = urd->reclen;\n\trc = get_file_reclen(urd);\n\tif (rc < 0)\n\t\tgoto fail_urfile_free;\n\turf->file_reclen = rc;\n\tfile->private_data = urf;\n\treturn 0;\n\nfail_urfile_free:\n\turfile_free(urf);\nfail_unlock:\n\tspin_lock(&urd->open_lock);\n\turd->open_flag--;\n\tspin_unlock(&urd->open_lock);\nfail_put:\n\turdev_put(urd);\nout:\n\treturn rc;\n}\n\nstatic int ur_release(struct inode *inode, struct file *file)\n{\n\tstruct urfile *urf = file->private_data;\n\n\tTRACE(\"ur_release\\n\");\n\tspin_lock(&urf->urd->open_lock);\n\turf->urd->open_flag--;\n\tspin_unlock(&urf->urd->open_lock);\n\twake_up_interruptible(&urf->urd->wait);\n\turdev_put(urf->urd);\n\turfile_free(urf);\n\treturn 0;\n}\n\nstatic loff_t ur_llseek(struct file *file, loff_t offset, int whence)\n{\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY)\n\t\treturn -ESPIPE;  \n\tif (offset % PAGE_SIZE)\n\t\treturn -ESPIPE;  \n\treturn no_seek_end_llseek(file, offset, whence);\n}\n\nstatic const struct file_operations ur_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open\t = ur_open,\n\t.release = ur_release,\n\t.read\t = ur_read,\n\t.write\t = ur_write,\n\t.llseek  = ur_llseek,\n};\n\n \nstatic int ur_probe(struct ccw_device *cdev)\n{\n\tstruct urdev *urd;\n\tint rc;\n\n\tTRACE(\"ur_probe: cdev=%p\\n\", cdev);\n\n\tmutex_lock(&vmur_mutex);\n\turd = urdev_alloc(cdev);\n\tif (!urd) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_unlock;\n\t}\n\n\trc = ur_create_attributes(&cdev->dev);\n\tif (rc) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_urdev_put;\n\t}\n\n\t \n\turd->class = get_urd_class(urd);\n\tif (urd->class < 0) {\n\t\trc = urd->class;\n\t\tgoto fail_remove_attr;\n\t}\n\tif ((urd->class != DEV_CLASS_UR_I) && (urd->class != DEV_CLASS_UR_O)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto fail_remove_attr;\n\t}\n\tspin_lock_irq(get_ccwdev_lock(cdev));\n\tdev_set_drvdata(&cdev->dev, urd);\n\tcdev->handler = ur_int_handler;\n\tspin_unlock_irq(get_ccwdev_lock(cdev));\n\n\tmutex_unlock(&vmur_mutex);\n\treturn 0;\n\nfail_remove_attr:\n\tur_remove_attributes(&cdev->dev);\nfail_urdev_put:\n\turdev_put(urd);\nfail_unlock:\n\tmutex_unlock(&vmur_mutex);\n\treturn rc;\n}\n\nstatic int ur_set_online(struct ccw_device *cdev)\n{\n\tstruct urdev *urd;\n\tint minor, major, rc;\n\tchar node_id[16];\n\n\tTRACE(\"ur_set_online: cdev=%p\\n\", cdev);\n\n\tmutex_lock(&vmur_mutex);\n\turd = urdev_get_from_cdev(cdev);\n\tif (!urd) {\n\t\t \n\t\trc = -ENODEV;\n\t\tgoto fail_unlock;\n\t}\n\n\tif (urd->char_device) {\n\t\t \n\t\trc = -EBUSY;\n\t\tgoto fail_urdev_put;\n\t}\n\n\tminor = urd->dev_id.devno;\n\tmajor = MAJOR(ur_first_dev_maj_min);\n\n\turd->char_device = cdev_alloc();\n\tif (!urd->char_device) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_urdev_put;\n\t}\n\n\turd->char_device->ops = &ur_fops;\n\turd->char_device->owner = ur_fops.owner;\n\n\trc = cdev_add(urd->char_device, MKDEV(major, minor), 1);\n\tif (rc)\n\t\tgoto fail_free_cdev;\n\tif (urd->cdev->id.cu_type == READER_PUNCH_DEVTYPE) {\n\t\tif (urd->class == DEV_CLASS_UR_I)\n\t\t\tsprintf(node_id, \"vmrdr-%s\", dev_name(&cdev->dev));\n\t\tif (urd->class == DEV_CLASS_UR_O)\n\t\t\tsprintf(node_id, \"vmpun-%s\", dev_name(&cdev->dev));\n\t} else if (urd->cdev->id.cu_type == PRINTER_DEVTYPE) {\n\t\tsprintf(node_id, \"vmprt-%s\", dev_name(&cdev->dev));\n\t} else {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto fail_free_cdev;\n\t}\n\n\turd->device = device_create(vmur_class, &cdev->dev,\n\t\t\t\t    urd->char_device->dev, NULL, \"%s\", node_id);\n\tif (IS_ERR(urd->device)) {\n\t\trc = PTR_ERR(urd->device);\n\t\tTRACE(\"ur_set_online: device_create rc=%d\\n\", rc);\n\t\tgoto fail_free_cdev;\n\t}\n\turdev_put(urd);\n\tmutex_unlock(&vmur_mutex);\n\treturn 0;\n\nfail_free_cdev:\n\tcdev_del(urd->char_device);\n\turd->char_device = NULL;\nfail_urdev_put:\n\turdev_put(urd);\nfail_unlock:\n\tmutex_unlock(&vmur_mutex);\n\treturn rc;\n}\n\nstatic int ur_set_offline_force(struct ccw_device *cdev, int force)\n{\n\tstruct urdev *urd;\n\tint rc;\n\n\tTRACE(\"ur_set_offline: cdev=%p\\n\", cdev);\n\turd = urdev_get_from_cdev(cdev);\n\tif (!urd)\n\t\t \n\t\treturn -ENODEV;\n\tif (!urd->char_device) {\n\t\t \n\t\trc = -EBUSY;\n\t\tgoto fail_urdev_put;\n\t}\n\tif (!force && (refcount_read(&urd->ref_count) > 2)) {\n\t\t \n\t\tTRACE(\"ur_set_offline: BUSY\\n\");\n\t\trc = -EBUSY;\n\t\tgoto fail_urdev_put;\n\t}\n\tif (cancel_work_sync(&urd->uevent_work)) {\n\t\t \n\t\turdev_put(urd);\n\t}\n\tdevice_destroy(vmur_class, urd->char_device->dev);\n\tcdev_del(urd->char_device);\n\turd->char_device = NULL;\n\trc = 0;\n\nfail_urdev_put:\n\turdev_put(urd);\n\treturn rc;\n}\n\nstatic int ur_set_offline(struct ccw_device *cdev)\n{\n\tint rc;\n\n\tmutex_lock(&vmur_mutex);\n\trc = ur_set_offline_force(cdev, 0);\n\tmutex_unlock(&vmur_mutex);\n\treturn rc;\n}\n\nstatic void ur_remove(struct ccw_device *cdev)\n{\n\tunsigned long flags;\n\n\tTRACE(\"ur_remove\\n\");\n\n\tmutex_lock(&vmur_mutex);\n\n\tif (cdev->online)\n\t\tur_set_offline_force(cdev, 1);\n\tur_remove_attributes(&cdev->dev);\n\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\turdev_put(dev_get_drvdata(&cdev->dev));\n\tdev_set_drvdata(&cdev->dev, NULL);\n\tcdev->handler = NULL;\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\n\tmutex_unlock(&vmur_mutex);\n}\n\n \nstatic int __init ur_init(void)\n{\n\tint rc;\n\tdev_t dev;\n\n\tif (!MACHINE_IS_VM) {\n\t\tpr_err(\"The %s cannot be loaded without z/VM\\n\",\n\t\t       ur_banner);\n\t\treturn -ENODEV;\n\t}\n\n\tvmur_dbf = debug_register(\"vmur\", 4, 1, 4 * sizeof(long));\n\tif (!vmur_dbf)\n\t\treturn -ENOMEM;\n\trc = debug_register_view(vmur_dbf, &debug_sprintf_view);\n\tif (rc)\n\t\tgoto fail_free_dbf;\n\n\tdebug_set_level(vmur_dbf, 6);\n\n\tvmur_class = class_create(\"vmur\");\n\tif (IS_ERR(vmur_class)) {\n\t\trc = PTR_ERR(vmur_class);\n\t\tgoto fail_free_dbf;\n\t}\n\n\trc = ccw_driver_register(&ur_driver);\n\tif (rc)\n\t\tgoto fail_class_destroy;\n\n\trc = alloc_chrdev_region(&dev, 0, NUM_MINORS, \"vmur\");\n\tif (rc) {\n\t\tpr_err(\"Kernel function alloc_chrdev_region failed with \"\n\t\t       \"error code %d\\n\", rc);\n\t\tgoto fail_unregister_driver;\n\t}\n\tur_first_dev_maj_min = MKDEV(MAJOR(dev), 0);\n\n\tpr_info(\"%s loaded.\\n\", ur_banner);\n\treturn 0;\n\nfail_unregister_driver:\n\tccw_driver_unregister(&ur_driver);\nfail_class_destroy:\n\tclass_destroy(vmur_class);\nfail_free_dbf:\n\tdebug_unregister(vmur_dbf);\n\treturn rc;\n}\n\nstatic void __exit ur_exit(void)\n{\n\tunregister_chrdev_region(ur_first_dev_maj_min, NUM_MINORS);\n\tccw_driver_unregister(&ur_driver);\n\tclass_destroy(vmur_class);\n\tdebug_unregister(vmur_dbf);\n\tpr_info(\"%s unloaded.\\n\", ur_banner);\n}\n\nmodule_init(ur_init);\nmodule_exit(ur_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}