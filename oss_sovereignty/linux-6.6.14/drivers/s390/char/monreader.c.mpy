{
  "module_name": "monreader.c",
  "hash_id": "06df2f2f75d4b8e0f8780a92ae1cc6c3e5609643b287bd4b3e230219e3ce3347",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/monreader.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"monreader\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/ctype.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <net/iucv/iucv.h>\n#include <linux/uaccess.h>\n#include <asm/ebcdic.h>\n#include <asm/extmem.h>\n\n\n#define MON_COLLECT_SAMPLE 0x80\n#define MON_COLLECT_EVENT  0x40\n#define MON_SERVICE\t   \"*MONITOR\"\n#define MON_IN_USE\t   0x01\n#define MON_MSGLIM\t   255\n\nstatic char mon_dcss_name[9] = \"MONDCSS\\0\";\n\nstruct mon_msg {\n\tu32 pos;\n\tu32 mca_offset;\n\tstruct iucv_message msg;\n\tchar msglim_reached;\n\tchar replied_msglim;\n};\n\nstruct mon_private {\n\tstruct iucv_path *path;\n\tstruct mon_msg *msg_array[MON_MSGLIM];\n\tunsigned int   write_index;\n\tunsigned int   read_index;\n\tatomic_t msglim_count;\n\tatomic_t read_ready;\n\tatomic_t iucv_connected;\n\tatomic_t iucv_severed;\n};\n\nstatic unsigned long mon_in_use = 0;\n\nstatic unsigned long mon_dcss_start;\nstatic unsigned long mon_dcss_end;\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mon_read_wait_queue);\nstatic DECLARE_WAIT_QUEUE_HEAD(mon_conn_wait_queue);\n\nstatic u8 user_data_connect[16] = {\n\t \n\t0x01,\n\t \n\tMON_COLLECT_SAMPLE | MON_COLLECT_EVENT,\n\t \n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n};\n\nstatic u8 user_data_sever[16] = {\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n};\n\n \n \nstatic void dcss_mkname(char *ascii_name, char *ebcdic_name)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (ascii_name[i] == '\\0')\n\t\t\tbreak;\n\t\tebcdic_name[i] = toupper(ascii_name[i]);\n\t}\n\tfor (; i < 8; i++)\n\t\tebcdic_name[i] = ' ';\n\tASCEBC(ebcdic_name, 8);\n}\n\nstatic inline unsigned long mon_mca_start(struct mon_msg *monmsg)\n{\n\treturn *(u32 *) &monmsg->msg.rmmsg;\n}\n\nstatic inline unsigned long mon_mca_end(struct mon_msg *monmsg)\n{\n\treturn *(u32 *) &monmsg->msg.rmmsg[4];\n}\n\nstatic inline u8 mon_mca_type(struct mon_msg *monmsg, u8 index)\n{\n\treturn *((u8 *)__va(mon_mca_start(monmsg)) + monmsg->mca_offset + index);\n}\n\nstatic inline u32 mon_mca_size(struct mon_msg *monmsg)\n{\n\treturn mon_mca_end(monmsg) - mon_mca_start(monmsg) + 1;\n}\n\nstatic inline u32 mon_rec_start(struct mon_msg *monmsg)\n{\n\treturn *((u32 *)(__va(mon_mca_start(monmsg)) + monmsg->mca_offset + 4));\n}\n\nstatic inline u32 mon_rec_end(struct mon_msg *monmsg)\n{\n\treturn *((u32 *)(__va(mon_mca_start(monmsg)) + monmsg->mca_offset + 8));\n}\n\nstatic int mon_check_mca(struct mon_msg *monmsg)\n{\n\tif ((mon_rec_end(monmsg) <= mon_rec_start(monmsg)) ||\n\t    (mon_rec_start(monmsg) < mon_dcss_start) ||\n\t    (mon_rec_end(monmsg) > mon_dcss_end) ||\n\t    (mon_mca_type(monmsg, 0) == 0) ||\n\t    (mon_mca_size(monmsg) % 12 != 0) ||\n\t    (mon_mca_end(monmsg) <= mon_mca_start(monmsg)) ||\n\t    (mon_mca_end(monmsg) > mon_dcss_end) ||\n\t    (mon_mca_start(monmsg) < mon_dcss_start) ||\n\t    ((mon_mca_type(monmsg, 1) == 0) && (mon_mca_type(monmsg, 2) == 0)))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int mon_send_reply(struct mon_msg *monmsg,\n\t\t\t  struct mon_private *monpriv)\n{\n\tint rc;\n\n\trc = iucv_message_reply(monpriv->path, &monmsg->msg,\n\t\t\t\tIUCV_IPRMDATA, NULL, 0);\n\tatomic_dec(&monpriv->msglim_count);\n\tif (likely(!monmsg->msglim_reached)) {\n\t\tmonmsg->pos = 0;\n\t\tmonmsg->mca_offset = 0;\n\t\tmonpriv->read_index = (monpriv->read_index + 1) %\n\t\t\t\t      MON_MSGLIM;\n\t\tatomic_dec(&monpriv->read_ready);\n\t} else\n\t\tmonmsg->replied_msglim = 1;\n\tif (rc) {\n\t\tpr_err(\"Reading monitor data failed with rc=%i\\n\", rc);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void mon_free_mem(struct mon_private *monpriv)\n{\n\tint i;\n\n\tfor (i = 0; i < MON_MSGLIM; i++)\n\t\tkfree(monpriv->msg_array[i]);\n\tkfree(monpriv);\n}\n\nstatic struct mon_private *mon_alloc_mem(void)\n{\n\tint i;\n\tstruct mon_private *monpriv;\n\n\tmonpriv = kzalloc(sizeof(struct mon_private), GFP_KERNEL);\n\tif (!monpriv)\n\t\treturn NULL;\n\tfor (i = 0; i < MON_MSGLIM; i++) {\n\t\tmonpriv->msg_array[i] = kzalloc(sizeof(struct mon_msg),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!monpriv->msg_array[i]) {\n\t\t\tmon_free_mem(monpriv);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn monpriv;\n}\n\nstatic inline void mon_next_mca(struct mon_msg *monmsg)\n{\n\tif (likely((mon_mca_size(monmsg) - monmsg->mca_offset) == 12))\n\t\treturn;\n\tmonmsg->mca_offset += 12;\n\tmonmsg->pos = 0;\n}\n\nstatic struct mon_msg *mon_next_message(struct mon_private *monpriv)\n{\n\tstruct mon_msg *monmsg;\n\n\tif (!atomic_read(&monpriv->read_ready))\n\t\treturn NULL;\n\tmonmsg = monpriv->msg_array[monpriv->read_index];\n\tif (unlikely(monmsg->replied_msglim)) {\n\t\tmonmsg->replied_msglim = 0;\n\t\tmonmsg->msglim_reached = 0;\n\t\tmonmsg->pos = 0;\n\t\tmonmsg->mca_offset = 0;\n\t\tmonpriv->read_index = (monpriv->read_index + 1) %\n\t\t\t\t      MON_MSGLIM;\n\t\tatomic_dec(&monpriv->read_ready);\n\t\treturn ERR_PTR(-EOVERFLOW);\n\t}\n\treturn monmsg;\n}\n\n\n \nstatic void mon_iucv_path_complete(struct iucv_path *path, u8 *ipuser)\n{\n\tstruct mon_private *monpriv = path->private;\n\n\tatomic_set(&monpriv->iucv_connected, 1);\n\twake_up(&mon_conn_wait_queue);\n}\n\nstatic void mon_iucv_path_severed(struct iucv_path *path, u8 *ipuser)\n{\n\tstruct mon_private *monpriv = path->private;\n\n\tpr_err(\"z/VM *MONITOR system service disconnected with rc=%i\\n\",\n\t       ipuser[0]);\n\tiucv_path_sever(path, NULL);\n\tatomic_set(&monpriv->iucv_severed, 1);\n\twake_up(&mon_conn_wait_queue);\n\twake_up_interruptible(&mon_read_wait_queue);\n}\n\nstatic void mon_iucv_message_pending(struct iucv_path *path,\n\t\t\t\t     struct iucv_message *msg)\n{\n\tstruct mon_private *monpriv = path->private;\n\n\tmemcpy(&monpriv->msg_array[monpriv->write_index]->msg,\n\t       msg, sizeof(*msg));\n\tif (atomic_inc_return(&monpriv->msglim_count) == MON_MSGLIM) {\n\t\tpr_warn(\"The read queue for monitor data is full\\n\");\n\t\tmonpriv->msg_array[monpriv->write_index]->msglim_reached = 1;\n\t}\n\tmonpriv->write_index = (monpriv->write_index + 1) % MON_MSGLIM;\n\tatomic_inc(&monpriv->read_ready);\n\twake_up_interruptible(&mon_read_wait_queue);\n}\n\nstatic struct iucv_handler monreader_iucv_handler = {\n\t.path_complete\t = mon_iucv_path_complete,\n\t.path_severed\t = mon_iucv_path_severed,\n\t.message_pending = mon_iucv_message_pending,\n};\n\n \nstatic int mon_open(struct inode *inode, struct file *filp)\n{\n\tstruct mon_private *monpriv;\n\tint rc;\n\n\t \n\trc = -EBUSY;\n\tif (test_and_set_bit(MON_IN_USE, &mon_in_use))\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tmonpriv = mon_alloc_mem();\n\tif (!monpriv)\n\t\tgoto out_use;\n\n\t \n\tmonpriv->path = iucv_path_alloc(MON_MSGLIM, IUCV_IPRMDATA, GFP_KERNEL);\n\tif (!monpriv->path)\n\t\tgoto out_priv;\n\trc = iucv_path_connect(monpriv->path, &monreader_iucv_handler,\n\t\t\t       MON_SERVICE, NULL, user_data_connect, monpriv);\n\tif (rc) {\n\t\tpr_err(\"Connecting to the z/VM *MONITOR system service \"\n\t\t       \"failed with rc=%i\\n\", rc);\n\t\trc = -EIO;\n\t\tgoto out_path;\n\t}\n\t \n\twait_event(mon_conn_wait_queue,\n\t\t   atomic_read(&monpriv->iucv_connected) ||\n\t\t   atomic_read(&monpriv->iucv_severed));\n\tif (atomic_read(&monpriv->iucv_severed)) {\n\t\tatomic_set(&monpriv->iucv_severed, 0);\n\t\tatomic_set(&monpriv->iucv_connected, 0);\n\t\trc = -EIO;\n\t\tgoto out_path;\n\t}\n\tfilp->private_data = monpriv;\n\treturn nonseekable_open(inode, filp);\n\nout_path:\n\tiucv_path_free(monpriv->path);\nout_priv:\n\tmon_free_mem(monpriv);\nout_use:\n\tclear_bit(MON_IN_USE, &mon_in_use);\nout:\n\treturn rc;\n}\n\nstatic int mon_close(struct inode *inode, struct file *filp)\n{\n\tint rc, i;\n\tstruct mon_private *monpriv = filp->private_data;\n\n\t \n\tif (monpriv->path) {\n\t\trc = iucv_path_sever(monpriv->path, user_data_sever);\n\t\tif (rc)\n\t\t\tpr_warn(\"Disconnecting the z/VM *MONITOR system service failed with rc=%i\\n\",\n\t\t\t\trc);\n\t\tiucv_path_free(monpriv->path);\n\t}\n\n\tatomic_set(&monpriv->iucv_severed, 0);\n\tatomic_set(&monpriv->iucv_connected, 0);\n\tatomic_set(&monpriv->read_ready, 0);\n\tatomic_set(&monpriv->msglim_count, 0);\n\tmonpriv->write_index  = 0;\n\tmonpriv->read_index   = 0;\n\n\tfor (i = 0; i < MON_MSGLIM; i++)\n\t\tkfree(monpriv->msg_array[i]);\n\tkfree(monpriv);\n\tclear_bit(MON_IN_USE, &mon_in_use);\n\treturn 0;\n}\n\nstatic ssize_t mon_read(struct file *filp, char __user *data,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mon_private *monpriv = filp->private_data;\n\tstruct mon_msg *monmsg;\n\tint ret;\n\tu32 mce_start;\n\n\tmonmsg = mon_next_message(monpriv);\n\tif (IS_ERR(monmsg))\n\t\treturn PTR_ERR(monmsg);\n\n\tif (!monmsg) {\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tret = wait_event_interruptible(mon_read_wait_queue,\n\t\t\t\t\tatomic_read(&monpriv->read_ready) ||\n\t\t\t\t\tatomic_read(&monpriv->iucv_severed));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (unlikely(atomic_read(&monpriv->iucv_severed)))\n\t\t\treturn -EIO;\n\t\tmonmsg = monpriv->msg_array[monpriv->read_index];\n\t}\n\n\tif (!monmsg->pos)\n\t\tmonmsg->pos = mon_mca_start(monmsg) + monmsg->mca_offset;\n\tif (mon_check_mca(monmsg))\n\t\tgoto reply;\n\n\t \n\tmce_start = mon_mca_start(monmsg) + monmsg->mca_offset;\n\tif ((monmsg->pos >= mce_start) && (monmsg->pos < mce_start + 12)) {\n\t\tcount = min(count, (size_t) mce_start + 12 - monmsg->pos);\n\t\tret = copy_to_user(data, __va(monmsg->pos), count);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tmonmsg->pos += count;\n\t\tif (monmsg->pos == mce_start + 12)\n\t\t\tmonmsg->pos = mon_rec_start(monmsg);\n\t\tgoto out_copy;\n\t}\n\n\t \n\tif (monmsg->pos <= mon_rec_end(monmsg)) {\n\t\tcount = min(count, (size_t) mon_rec_end(monmsg) - monmsg->pos\n\t\t\t\t\t    + 1);\n\t\tret = copy_to_user(data, __va(monmsg->pos), count);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tmonmsg->pos += count;\n\t\tif (monmsg->pos > mon_rec_end(monmsg))\n\t\t\tmon_next_mca(monmsg);\n\t\tgoto out_copy;\n\t}\nreply:\n\tret = mon_send_reply(monmsg, monpriv);\n\treturn ret;\n\nout_copy:\n\t*ppos += count;\n\treturn count;\n}\n\nstatic __poll_t mon_poll(struct file *filp, struct poll_table_struct *p)\n{\n\tstruct mon_private *monpriv = filp->private_data;\n\n\tpoll_wait(filp, &mon_read_wait_queue, p);\n\tif (unlikely(atomic_read(&monpriv->iucv_severed)))\n\t\treturn EPOLLERR;\n\tif (atomic_read(&monpriv->read_ready))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic const struct file_operations mon_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = &mon_open,\n\t.release = &mon_close,\n\t.read    = &mon_read,\n\t.poll    = &mon_poll,\n\t.llseek  = noop_llseek,\n};\n\nstatic struct miscdevice mon_dev = {\n\t.name       = \"monreader\",\n\t.fops       = &mon_fops,\n\t.minor      = MISC_DYNAMIC_MINOR,\n};\n\n \nstatic int __init mon_init(void)\n{\n\tint rc;\n\n\tif (!MACHINE_IS_VM) {\n\t\tpr_err(\"The z/VM *MONITOR record device driver cannot be \"\n\t\t       \"loaded without z/VM\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\trc = iucv_register(&monreader_iucv_handler, 1);\n\tif (rc) {\n\t\tpr_err(\"The z/VM *MONITOR record device driver failed to \"\n\t\t       \"register with IUCV\\n\");\n\t\treturn rc;\n\t}\n\n\trc = segment_type(mon_dcss_name);\n\tif (rc < 0) {\n\t\tsegment_warning(rc, mon_dcss_name);\n\t\tgoto out_iucv;\n\t}\n\tif (rc != SEG_TYPE_SC) {\n\t\tpr_err(\"The specified *MONITOR DCSS %s does not have the \"\n\t\t       \"required type SC\\n\", mon_dcss_name);\n\t\trc = -EINVAL;\n\t\tgoto out_iucv;\n\t}\n\n\trc = segment_load(mon_dcss_name, SEGMENT_SHARED,\n\t\t\t  &mon_dcss_start, &mon_dcss_end);\n\tif (rc < 0) {\n\t\tsegment_warning(rc, mon_dcss_name);\n\t\trc = -EINVAL;\n\t\tgoto out_iucv;\n\t}\n\tdcss_mkname(mon_dcss_name, &user_data_connect[8]);\n\n\t \n\trc = misc_register(&mon_dev);\n\tif (rc < 0 )\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tsegment_unload(mon_dcss_name);\nout_iucv:\n\tiucv_unregister(&monreader_iucv_handler, 1);\n\treturn rc;\n}\n\nstatic void __exit mon_exit(void)\n{\n\tsegment_unload(mon_dcss_name);\n\tmisc_deregister(&mon_dev);\n\tiucv_unregister(&monreader_iucv_handler, 1);\n\treturn;\n}\n\n\nmodule_init(mon_init);\nmodule_exit(mon_exit);\n\nmodule_param_string(mondcss, mon_dcss_name, 9, 0444);\nMODULE_PARM_DESC(mondcss, \"Name of DCSS segment to be used for *MONITOR \"\n\t\t \"service, max. 8 chars. Default is MONDCSS\");\n\nMODULE_AUTHOR(\"Gerald Schaefer <geraldsc@de.ibm.com>\");\nMODULE_DESCRIPTION(\"Character device driver for reading z/VM \"\n\t\t   \"monitor service records.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}