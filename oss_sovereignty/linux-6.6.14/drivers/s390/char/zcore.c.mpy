{
  "module_name": "zcore.c",
  "hash_id": "dafecef6e534d4045719a6dfe7f46365d48b74c5470cd767faa3d19204049674",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/char/zcore.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zdump\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/panic_notifier.h>\n#include <linux/reboot.h>\n#include <linux/uio.h>\n\n#include <asm/asm-offsets.h>\n#include <asm/ipl.h>\n#include <asm/sclp.h>\n#include <asm/setup.h>\n#include <linux/uaccess.h>\n#include <asm/debug.h>\n#include <asm/processor.h>\n#include <asm/irqflags.h>\n#include <asm/checksum.h>\n#include <asm/os_info.h>\n#include <asm/switch_to.h>\n#include <asm/maccess.h>\n#include \"sclp.h\"\n\n#define TRACE(x...) debug_sprintf_event(zcore_dbf, 1, x)\n\nenum arch_id {\n\tARCH_S390\t= 0,\n\tARCH_S390X\t= 1,\n};\n\nstruct ipib_info {\n\tunsigned long\tipib;\n\tu32\t\tchecksum;\n}  __attribute__((packed));\n\nstatic struct debug_info *zcore_dbf;\nstatic int hsa_available;\nstatic struct dentry *zcore_dir;\nstatic struct dentry *zcore_reipl_file;\nstatic struct dentry *zcore_hsa_file;\nstatic struct ipl_parameter_block *zcore_ipl_block;\nstatic unsigned long os_info_flags;\n\nstatic DEFINE_MUTEX(hsa_buf_mutex);\nstatic char hsa_buf[PAGE_SIZE] __aligned(PAGE_SIZE);\n\n \nsize_t memcpy_hsa_iter(struct iov_iter *iter, unsigned long src, size_t count)\n{\n\tsize_t bytes, copied, res = 0;\n\tunsigned long offset;\n\n\tif (!hsa_available)\n\t\treturn 0;\n\n\tmutex_lock(&hsa_buf_mutex);\n\twhile (count) {\n\t\tif (sclp_sdias_copy(hsa_buf, src / PAGE_SIZE + 2, 1)) {\n\t\t\tTRACE(\"sclp_sdias_copy() failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\toffset = src % PAGE_SIZE;\n\t\tbytes = min(PAGE_SIZE - offset, count);\n\t\tcopied = copy_to_iter(hsa_buf + offset, bytes, iter);\n\t\tcount -= copied;\n\t\tsrc += copied;\n\t\tres += copied;\n\t\tif (copied < bytes)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&hsa_buf_mutex);\n\treturn res;\n}\n\n \nstatic inline int memcpy_hsa_kernel(void *dst, unsigned long src, size_t count)\n{\n\tstruct iov_iter iter;\n\tstruct kvec kvec;\n\n\tkvec.iov_base = dst;\n\tkvec.iov_len = count;\n\tiov_iter_kvec(&iter, ITER_DEST, &kvec, 1, count);\n\tif (memcpy_hsa_iter(&iter, src, count) < count)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int __init init_cpu_info(void)\n{\n\tstruct save_area *sa;\n\n\t \n\tsa = save_area_boot_cpu();\n\tif (!sa)\n\t\treturn -ENOMEM;\n\tif (memcpy_hsa_kernel(hsa_buf, __LC_FPREGS_SAVE_AREA, 512) < 0) {\n\t\tTRACE(\"could not copy from HSA\\n\");\n\t\treturn -EIO;\n\t}\n\tsave_area_add_regs(sa, hsa_buf);  \n\treturn 0;\n}\n\n \nstatic void release_hsa(void)\n{\n\tdiag308(DIAG308_REL_HSA, NULL);\n\thsa_available = 0;\n}\n\nstatic ssize_t zcore_reipl_write(struct file *filp, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tif (zcore_ipl_block) {\n\t\tdiag308(DIAG308_SET, zcore_ipl_block);\n\t\tif (os_info_flags & OS_INFO_FLAG_REIPL_CLEAR)\n\t\t\tdiag308(DIAG308_LOAD_CLEAR, NULL);\n\t\t \n\t\tif (zcore_ipl_block->pb0_hdr.pbt == IPL_PBT_CCW)\n\t\t\tdiag308(DIAG308_LOAD_NORMAL_DUMP, NULL);\n\t\telse\n\t\t\tdiag308(DIAG308_LOAD_NORMAL, NULL);\n\t}\n\treturn count;\n}\n\nstatic int zcore_reipl_open(struct inode *inode, struct file *filp)\n{\n\treturn stream_open(inode, filp);\n}\n\nstatic int zcore_reipl_release(struct inode *inode, struct file *filp)\n{\n\treturn 0;\n}\n\nstatic const struct file_operations zcore_reipl_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= zcore_reipl_write,\n\t.open\t\t= zcore_reipl_open,\n\t.release\t= zcore_reipl_release,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic ssize_t zcore_hsa_read(struct file *filp, char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstatic char str[18];\n\n\tif (hsa_available)\n\t\tsnprintf(str, sizeof(str), \"%lx\\n\", sclp.hsa_size);\n\telse\n\t\tsnprintf(str, sizeof(str), \"0\\n\");\n\treturn simple_read_from_buffer(buf, count, ppos, str, strlen(str));\n}\n\nstatic ssize_t zcore_hsa_write(struct file *filp, const char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar value;\n\n\tif (*ppos != 0)\n\t\treturn -EPIPE;\n\tif (copy_from_user(&value, buf, 1))\n\t\treturn -EFAULT;\n\tif (value != '0')\n\t\treturn -EINVAL;\n\trelease_hsa();\n\treturn count;\n}\n\nstatic const struct file_operations zcore_hsa_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= zcore_hsa_write,\n\t.read\t\t= zcore_hsa_read,\n\t.open\t\t= nonseekable_open,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic int __init check_sdias(void)\n{\n\tif (!sclp.hsa_size) {\n\t\tTRACE(\"Could not determine HSA size\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \nstatic int __init zcore_reipl_init(void)\n{\n\tstruct os_info_entry *entry;\n\tstruct ipib_info ipib_info;\n\tunsigned long os_info_addr;\n\tstruct os_info *os_info;\n\tint rc;\n\n\trc = memcpy_hsa_kernel(&ipib_info, __LC_DUMP_REIPL, sizeof(ipib_info));\n\tif (rc)\n\t\treturn rc;\n\tif (ipib_info.ipib == 0)\n\t\treturn 0;\n\tzcore_ipl_block = (void *) __get_free_page(GFP_KERNEL);\n\tif (!zcore_ipl_block)\n\t\treturn -ENOMEM;\n\tif (ipib_info.ipib < sclp.hsa_size)\n\t\trc = memcpy_hsa_kernel(zcore_ipl_block, ipib_info.ipib,\n\t\t\t\t       PAGE_SIZE);\n\telse\n\t\trc = memcpy_real(zcore_ipl_block, ipib_info.ipib, PAGE_SIZE);\n\tif (rc || (__force u32)csum_partial(zcore_ipl_block, zcore_ipl_block->hdr.len, 0) !=\n\t    ipib_info.checksum) {\n\t\tTRACE(\"Checksum does not match\\n\");\n\t\tfree_page((unsigned long) zcore_ipl_block);\n\t\tzcore_ipl_block = NULL;\n\t}\n\t \n\tos_info = (void *)__get_free_page(GFP_KERNEL);\n\tif (!os_info)\n\t\treturn -ENOMEM;\n\trc = memcpy_hsa_kernel(&os_info_addr, __LC_OS_INFO, sizeof(os_info_addr));\n\tif (rc)\n\t\tgoto out;\n\tif (os_info_addr < sclp.hsa_size)\n\t\trc = memcpy_hsa_kernel(os_info, os_info_addr, PAGE_SIZE);\n\telse\n\t\trc = memcpy_real(os_info, os_info_addr, PAGE_SIZE);\n\tif (rc || os_info_csum(os_info) != os_info->csum)\n\t\tgoto out;\n\tentry = &os_info->entry[OS_INFO_FLAGS_ENTRY];\n\tif (entry->addr && entry->size) {\n\t\tif (entry->addr < sclp.hsa_size)\n\t\t\trc = memcpy_hsa_kernel(&os_info_flags, entry->addr, sizeof(os_info_flags));\n\t\telse\n\t\t\trc = memcpy_real(&os_info_flags, entry->addr, sizeof(os_info_flags));\n\t\tif (rc || (__force u32)csum_partial(&os_info_flags, entry->size, 0) != entry->csum)\n\t\t\tos_info_flags = 0;\n\t}\nout:\n\tfree_page((unsigned long)os_info);\n\treturn 0;\n}\n\nstatic int zcore_reboot_and_on_panic_handler(struct notifier_block *self,\n\t\t\t\t\t     unsigned long\t   event,\n\t\t\t\t\t     void\t\t   *data)\n{\n\tif (hsa_available)\n\t\trelease_hsa();\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block zcore_reboot_notifier = {\n\t.notifier_call\t= zcore_reboot_and_on_panic_handler,\n\t \n\t.priority\t= INT_MAX,\n};\n\nstatic struct notifier_block zcore_on_panic_notifier = {\n\t.notifier_call\t= zcore_reboot_and_on_panic_handler,\n\t \n\t.priority\t= INT_MAX,\n};\n\nstatic int __init zcore_init(void)\n{\n\tunsigned char arch;\n\tint rc;\n\n\tif (!is_ipl_type_dump())\n\t\treturn -ENODATA;\n\tif (oldmem_data.start)\n\t\treturn -ENODATA;\n\n\tzcore_dbf = debug_register(\"zcore\", 4, 1, 4 * sizeof(long));\n\tdebug_register_view(zcore_dbf, &debug_sprintf_view);\n\tdebug_set_level(zcore_dbf, 6);\n\n\tif (ipl_info.type == IPL_TYPE_FCP_DUMP) {\n\t\tTRACE(\"type:   fcp\\n\");\n\t\tTRACE(\"devno:  %x\\n\", ipl_info.data.fcp.dev_id.devno);\n\t\tTRACE(\"wwpn:   %llx\\n\", (unsigned long long) ipl_info.data.fcp.wwpn);\n\t\tTRACE(\"lun:    %llx\\n\", (unsigned long long) ipl_info.data.fcp.lun);\n\t} else if (ipl_info.type == IPL_TYPE_NVME_DUMP) {\n\t\tTRACE(\"type:   nvme\\n\");\n\t\tTRACE(\"fid:    %x\\n\", ipl_info.data.nvme.fid);\n\t\tTRACE(\"nsid:   %x\\n\", ipl_info.data.nvme.nsid);\n\t} else if (ipl_info.type == IPL_TYPE_ECKD_DUMP) {\n\t\tTRACE(\"type:   eckd\\n\");\n\t\tTRACE(\"devno:  %x\\n\", ipl_info.data.eckd.dev_id.devno);\n\t\tTRACE(\"ssid:   %x\\n\", ipl_info.data.eckd.dev_id.ssid);\n\t}\n\n\trc = sclp_sdias_init();\n\tif (rc)\n\t\tgoto fail;\n\n\trc = check_sdias();\n\tif (rc)\n\t\tgoto fail;\n\thsa_available = 1;\n\n\trc = memcpy_hsa_kernel(&arch, __LC_AR_MODE_ID, 1);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (arch == ARCH_S390) {\n\t\tpr_alert(\"The 64-bit dump tool cannot be used for a \"\n\t\t\t \"32-bit system\\n\");\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tpr_alert(\"The dump process started for a 64-bit operating system\\n\");\n\trc = init_cpu_info();\n\tif (rc)\n\t\tgoto fail;\n\n\trc = zcore_reipl_init();\n\tif (rc)\n\t\tgoto fail;\n\n\tzcore_dir = debugfs_create_dir(\"zcore\" , NULL);\n\tzcore_reipl_file = debugfs_create_file(\"reipl\", S_IRUSR, zcore_dir,\n\t\t\t\t\t\tNULL, &zcore_reipl_fops);\n\tzcore_hsa_file = debugfs_create_file(\"hsa\", S_IRUSR|S_IWUSR, zcore_dir,\n\t\t\t\t\t     NULL, &zcore_hsa_fops);\n\n\tregister_reboot_notifier(&zcore_reboot_notifier);\n\tatomic_notifier_chain_register(&panic_notifier_list, &zcore_on_panic_notifier);\n\n\treturn 0;\nfail:\n\tdiag308(DIAG308_REL_HSA, NULL);\n\treturn rc;\n}\nsubsys_initcall(zcore_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}