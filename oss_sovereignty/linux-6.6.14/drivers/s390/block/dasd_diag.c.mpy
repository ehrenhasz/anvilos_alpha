{
  "module_name": "dasd_diag.c",
  "hash_id": "1f391cbfcd81da59452ca6543f33f98787de9a4c3c42f465c40b710877ecb91e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_diag.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd\"\n\n#include <linux/kernel_stat.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/hdreg.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <asm/asm-extable.h>\n#include <asm/dasd.h>\n#include <asm/debug.h>\n#include <asm/diag.h>\n#include <asm/ebcdic.h>\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <asm/vtoc.h>\n\n#include \"dasd_int.h\"\n#include \"dasd_diag.h\"\n\n#define PRINTK_HEADER \"dasd(diag):\"\n\nMODULE_LICENSE(\"GPL\");\n\n \n#define DIAG_MAX_BLOCKS\t(((2 * PAGE_SIZE - sizeof(struct dasd_ccw_req) - \\\n\t\t\t   sizeof(struct dasd_diag_req)) / \\\n\t\t           sizeof(struct dasd_diag_bio)) / 2)\n#define DIAG_MAX_RETRIES\t32\n#define DIAG_TIMEOUT\t\t50\n\nstatic struct dasd_discipline dasd_diag_discipline;\n\nstruct dasd_diag_private {\n\tstruct dasd_diag_characteristics rdc_data;\n\tstruct dasd_diag_rw_io iob;\n\tstruct dasd_diag_init_io iib;\n\tblocknum_t pt_block;\n\tstruct ccw_dev_id dev_id;\n};\n\nstruct dasd_diag_req {\n\tunsigned int block_count;\n\tstruct dasd_diag_bio bio[];\n};\n\nstatic const u8 DASD_DIAG_CMS1[] = { 0xc3, 0xd4, 0xe2, 0xf1 }; \n\n \nstatic inline int __dia250(void *iob, int cmd)\n{\n\tunion register_pair rx = { .even = (unsigned long)iob, };\n\ttypedef union {\n\t\tstruct dasd_diag_init_io init_io;\n\t\tstruct dasd_diag_rw_io rw_io;\n\t} addr_type;\n\tint cc;\n\n\tcc = 3;\n\tasm volatile(\n\t\t\"\tdiag\t%[rx],%[cmd],0x250\\n\"\n\t\t\"0:\tipm\t%[cc]\\n\"\n\t\t\"\tsrl\t%[cc],28\\n\"\n\t\t\"1:\\n\"\n\t\tEX_TABLE(0b,1b)\n\t\t: [cc] \"+&d\" (cc), [rx] \"+&d\" (rx.pair), \"+m\" (*(addr_type *)iob)\n\t\t: [cmd] \"d\" (cmd)\n\t\t: \"cc\");\n\treturn cc | rx.odd;\n}\n\nstatic inline int dia250(void *iob, int cmd)\n{\n\tdiag_stat_inc(DIAG_STAT_X250);\n\treturn __dia250(iob, cmd);\n}\n\n \nstatic inline int\nmdsk_init_io(struct dasd_device *device, unsigned int blocksize,\n\t     blocknum_t offset, blocknum_t *end_block)\n{\n\tstruct dasd_diag_private *private = device->private;\n\tstruct dasd_diag_init_io *iib = &private->iib;\n\tint rc;\n\n\tmemset(iib, 0, sizeof (struct dasd_diag_init_io));\n\n\tiib->dev_nr = private->dev_id.devno;\n\tiib->block_size = blocksize;\n\tiib->offset = offset;\n\tiib->flaga = DASD_DIAG_FLAGA_DEFAULT;\n\n\trc = dia250(iib, INIT_BIO);\n\n\tif ((rc & 3) == 0 && end_block)\n\t\t*end_block = iib->end_block;\n\n\treturn rc;\n}\n\n \nstatic inline int\nmdsk_term_io(struct dasd_device * device)\n{\n\tstruct dasd_diag_private *private = device->private;\n\tstruct dasd_diag_init_io *iib = &private->iib;\n\tint rc;\n\n\tmemset(iib, 0, sizeof (struct dasd_diag_init_io));\n\tiib->dev_nr = private->dev_id.devno;\n\trc = dia250(iib, TERM_BIO);\n\treturn rc;\n}\n\n \nstatic void\ndasd_diag_erp(struct dasd_device *device)\n{\n\tint rc;\n\n\tmdsk_term_io(device);\n\trc = mdsk_init_io(device, device->block->bp_block, 0, NULL);\n\tif (rc == 4) {\n\t\tif (!(test_and_set_bit(DASD_FLAG_DEVICE_RO, &device->flags)))\n\t\t\tpr_warn(\"%s: The access mode of a DIAG device changed to read-only\\n\",\n\t\t\t\tdev_name(&device->cdev->dev));\n\t\trc = 0;\n\t}\n\tif (rc)\n\t\tpr_warn(\"%s: DIAG ERP failed with rc=%d\\n\",\n\t\t\tdev_name(&device->cdev->dev), rc);\n}\n\n \nstatic int\ndasd_start_diag(struct dasd_ccw_req * cqr)\n{\n\tstruct dasd_device *device;\n\tstruct dasd_diag_private *private;\n\tstruct dasd_diag_req *dreq;\n\tint rc;\n\n\tdevice = cqr->startdev;\n\tif (cqr->retries < 0) {\n\t\tDBF_DEV_EVENT(DBF_ERR, device, \"DIAG start_IO: request %p \"\n\t\t\t    \"- no retry left)\", cqr);\n\t\tcqr->status = DASD_CQR_ERROR;\n\t\treturn -EIO;\n\t}\n\tprivate = device->private;\n\tdreq = cqr->data;\n\n\tprivate->iob.dev_nr = private->dev_id.devno;\n\tprivate->iob.key = 0;\n\tprivate->iob.flags = DASD_DIAG_RWFLAG_ASYNC;\n\tprivate->iob.block_count = dreq->block_count;\n\tprivate->iob.interrupt_params = (addr_t) cqr;\n\tprivate->iob.bio_list = dreq->bio;\n\tprivate->iob.flaga = DASD_DIAG_FLAGA_DEFAULT;\n\n\tcqr->startclk = get_tod_clock();\n\tcqr->starttime = jiffies;\n\tcqr->retries--;\n\n\trc = dia250(&private->iob, RW_BIO);\n\tswitch (rc) {\n\tcase 0:  \n\t\tcqr->stopclk = get_tod_clock();\n\t\tcqr->status = DASD_CQR_SUCCESS;\n\t\t \n                rc = -EACCES;\n\t\tbreak;\n\tcase 8:  \n\t\tcqr->status = DASD_CQR_IN_IO;\n\t\trc = 0;\n\t\tbreak;\n\tdefault:  \n\t\tcqr->status = DASD_CQR_QUEUED;\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"dia250 returned rc=%d\", rc);\n\t\tdasd_diag_erp(device);\n\t\trc = -EIO;\n\t\tbreak;\n\t}\n\tcqr->intrc = rc;\n\treturn rc;\n}\n\n \nstatic int\ndasd_diag_term_IO(struct dasd_ccw_req * cqr)\n{\n\tstruct dasd_device *device;\n\n\tdevice = cqr->startdev;\n\tmdsk_term_io(device);\n\tmdsk_init_io(device, device->block->bp_block, 0, NULL);\n\tcqr->status = DASD_CQR_CLEAR_PENDING;\n\tcqr->stopclk = get_tod_clock();\n\tdasd_schedule_device_bh(device);\n\treturn 0;\n}\n\n \nstatic void dasd_ext_handler(struct ext_code ext_code,\n\t\t\t     unsigned int param32, unsigned long param64)\n{\n\tstruct dasd_ccw_req *cqr, *next;\n\tstruct dasd_device *device;\n\tunsigned long expires;\n\tunsigned long flags;\n\taddr_t ip;\n\tint rc;\n\n\tswitch (ext_code.subcode >> 8) {\n\tcase DASD_DIAG_CODE_31BIT:\n\t\tip = (addr_t) param32;\n\t\tbreak;\n\tcase DASD_DIAG_CODE_64BIT:\n\t\tip = (addr_t) param64;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tinc_irq_stat(IRQEXT_DSD);\n\tif (!ip) {\t\t \n\t\tDBF_EVENT(DBF_NOTICE, \"%s\", \"caught unsolicited \"\n\t\t\t      \"interrupt\");\n\t\treturn;\n\t}\n\tcqr = (struct dasd_ccw_req *) ip;\n\tdevice = (struct dasd_device *) cqr->startdev;\n\tif (strncmp(device->discipline->ebcname, (char *) &cqr->magic, 4)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t\t    \" magic number of dasd_ccw_req 0x%08X doesn't\"\n\t\t\t    \" match discipline 0x%08X\",\n\t\t\t    cqr->magic, *(int *) (&device->discipline->name));\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\n\t \n\tif (cqr->status == DASD_CQR_CLEAR_PENDING) {\n\t\tcqr->status = DASD_CQR_CLEARED;\n\t\tdasd_device_clear_timer(device);\n\t\tdasd_schedule_device_bh(device);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\t\treturn;\n\t}\n\n\tcqr->stopclk = get_tod_clock();\n\n\texpires = 0;\n\tif ((ext_code.subcode & 0xff) == 0) {\n\t\tcqr->status = DASD_CQR_SUCCESS;\n\t\t \n\t\tif (!list_empty(&device->ccw_queue)) {\n\t\t\tnext = list_entry(device->ccw_queue.next,\n\t\t\t\t\t  struct dasd_ccw_req, devlist);\n\t\t\tif (next->status == DASD_CQR_QUEUED) {\n\t\t\t\trc = dasd_start_diag(next);\n\t\t\t\tif (rc == 0)\n\t\t\t\t\texpires = next->expires;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcqr->status = DASD_CQR_QUEUED;\n\t\tDBF_DEV_EVENT(DBF_DEBUG, device, \"interrupt status for \"\n\t\t\t      \"request %p was %d (%d retries left)\", cqr,\n\t\t\t      ext_code.subcode & 0xff, cqr->retries);\n\t\tdasd_diag_erp(device);\n\t}\n\n\tif (expires != 0)\n\t\tdasd_device_set_timer(device, expires);\n\telse\n\t\tdasd_device_clear_timer(device);\n\tdasd_schedule_device_bh(device);\n\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n}\n\n \nstatic int\ndasd_diag_check_device(struct dasd_device *device)\n{\n\tstruct dasd_diag_private *private = device->private;\n\tstruct dasd_diag_characteristics *rdc_data;\n\tstruct vtoc_cms_label *label;\n\tstruct dasd_block *block;\n\tstruct dasd_diag_bio *bio;\n\tunsigned int sb, bsize;\n\tblocknum_t end_block;\n\tint rc;\n\n\tif (private == NULL) {\n\t\tprivate = kzalloc(sizeof(*private), GFP_KERNEL);\n\t\tif (private == NULL) {\n\t\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t\t\"Allocating memory for private DASD data \"\n\t\t\t\t      \"failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tccw_device_get_id(device->cdev, &private->dev_id);\n\t\tdevice->private = private;\n\t}\n\tblock = dasd_alloc_block();\n\tif (IS_ERR(block)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"could not allocate dasd block structure\");\n\t\tdevice->private = NULL;\n\t\tkfree(private);\n\t\treturn PTR_ERR(block);\n\t}\n\tdevice->block = block;\n\tblock->base = device;\n\n\t \n\trdc_data = &private->rdc_data;\n\trdc_data->dev_nr = private->dev_id.devno;\n\trdc_data->rdc_len = sizeof (struct dasd_diag_characteristics);\n\n\trc = diag210((struct diag210 *) rdc_data);\n\tif (rc) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"failed to retrieve device \"\n\t\t\t    \"information (rc=%d)\", rc);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tdevice->default_expires = DIAG_TIMEOUT;\n\tdevice->default_retries = DIAG_MAX_RETRIES;\n\n\t \n\tswitch (private->rdc_data.vdev_class) {\n\tcase DEV_CLASS_FBA:\n\t\tprivate->pt_block = 1;\n\t\tbreak;\n\tcase DEV_CLASS_ECKD:\n\t\tprivate->pt_block = 2;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Device type %d is not supported in DIAG mode\\n\",\n\t\t\tdev_name(&device->cdev->dev),\n\t\t\tprivate->rdc_data.vdev_class);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tDBF_DEV_EVENT(DBF_INFO, device,\n\t\t      \"%04X: %04X on real %04X/%02X\",\n\t\t      rdc_data->dev_nr,\n\t\t      rdc_data->vdev_type,\n\t\t      rdc_data->rdev_type, rdc_data->rdev_model);\n\n\t \n\tmdsk_term_io(device);\n\n\t \n\tlabel = (struct vtoc_cms_label *) get_zeroed_page(GFP_KERNEL);\n\tif (label == NULL)  {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"No memory to allocate initialization request\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbio = kzalloc(sizeof(*bio), GFP_KERNEL);\n\tif (bio == NULL)  {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"No memory to allocate initialization bio\");\n\t\trc = -ENOMEM;\n\t\tgoto out_label;\n\t}\n\trc = 0;\n\tend_block = 0;\n\t \n\tfor (bsize = 512; bsize <= PAGE_SIZE; bsize <<= 1) {\n\t\tmdsk_init_io(device, bsize, 0, &end_block);\n\t\tmemset(bio, 0, sizeof(*bio));\n\t\tbio->type = MDSK_READ_REQ;\n\t\tbio->block_number = private->pt_block + 1;\n\t\tbio->buffer = label;\n\t\tmemset(&private->iob, 0, sizeof (struct dasd_diag_rw_io));\n\t\tprivate->iob.dev_nr = rdc_data->dev_nr;\n\t\tprivate->iob.key = 0;\n\t\tprivate->iob.flags = 0;\t \n\t\tprivate->iob.block_count = 1;\n\t\tprivate->iob.interrupt_params = 0;\n\t\tprivate->iob.bio_list = bio;\n\t\tprivate->iob.flaga = DASD_DIAG_FLAGA_DEFAULT;\n\t\trc = dia250(&private->iob, RW_BIO);\n\t\tif (rc == 3) {\n\t\t\tpr_warn(\"%s: A 64-bit DIAG call failed\\n\",\n\t\t\t\tdev_name(&device->cdev->dev));\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_bio;\n\t\t}\n\t\tmdsk_term_io(device);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\tif (bsize > PAGE_SIZE) {\n\t\tpr_warn(\"%s: Accessing the DASD failed because of an incorrect format (rc=%d)\\n\",\n\t\t\tdev_name(&device->cdev->dev), rc);\n\t\trc = -EIO;\n\t\tgoto out_bio;\n\t}\n\t \n\tif (memcmp(label->label_id, DASD_DIAG_CMS1,\n\t\t  sizeof(DASD_DIAG_CMS1)) == 0) {\n\t\t \n\t\tbsize = (unsigned int) label->block_size;\n\t\tblock->blocks = (unsigned long) label->block_count;\n\t} else\n\t\tblock->blocks = end_block;\n\tblock->bp_block = bsize;\n\tblock->s2b_shift = 0;\t \n\tfor (sb = 512; sb < bsize; sb = sb << 1)\n\t\tblock->s2b_shift++;\n\trc = mdsk_init_io(device, block->bp_block, 0, NULL);\n\tif (rc && (rc != 4)) {\n\t\tpr_warn(\"%s: DIAG initialization failed with rc=%d\\n\",\n\t\t\tdev_name(&device->cdev->dev), rc);\n\t\trc = -EIO;\n\t} else {\n\t\tif (rc == 4)\n\t\t\tset_bit(DASD_FLAG_DEVICE_RO, &device->flags);\n\t\tpr_info(\"%s: New DASD with %ld byte/block, total size %ld \"\n\t\t\t\"KB%s\\n\", dev_name(&device->cdev->dev),\n\t\t\t(unsigned long) block->bp_block,\n\t\t\t(unsigned long) (block->blocks <<\n\t\t\t\t\t block->s2b_shift) >> 1,\n\t\t\t(rc == 4) ? \", read-only device\" : \"\");\n\t\trc = 0;\n\t}\nout_bio:\n\tkfree(bio);\nout_label:\n\tfree_page((long) label);\nout:\n\tif (rc) {\n\t\tdevice->block = NULL;\n\t\tdasd_free_block(block);\n\t\tdevice->private = NULL;\n\t\tkfree(private);\n\t}\n\treturn rc;\n}\n\n \nstatic int\ndasd_diag_fill_geometry(struct dasd_block *block, struct hd_geometry *geo)\n{\n\tif (dasd_check_blocksize(block->bp_block) != 0)\n\t\treturn -EINVAL;\n\tgeo->cylinders = (block->blocks << block->s2b_shift) >> 10;\n\tgeo->heads = 16;\n\tgeo->sectors = 128 >> block->s2b_shift;\n\treturn 0;\n}\n\nstatic dasd_erp_fn_t\ndasd_diag_erp_action(struct dasd_ccw_req * cqr)\n{\n\treturn dasd_default_erp_action;\n}\n\nstatic dasd_erp_fn_t\ndasd_diag_erp_postaction(struct dasd_ccw_req * cqr)\n{\n\treturn dasd_default_erp_postaction;\n}\n\n \nstatic struct dasd_ccw_req *dasd_diag_build_cp(struct dasd_device *memdev,\n\t\t\t\t\t       struct dasd_block *block,\n\t\t\t\t\t       struct request *req)\n{\n\tstruct dasd_ccw_req *cqr;\n\tstruct dasd_diag_req *dreq;\n\tstruct dasd_diag_bio *dbio;\n\tstruct req_iterator iter;\n\tstruct bio_vec bv;\n\tchar *dst;\n\tunsigned int count;\n\tsector_t recid, first_rec, last_rec;\n\tunsigned int blksize, off;\n\tunsigned char rw_cmd;\n\n\tif (rq_data_dir(req) == READ)\n\t\trw_cmd = MDSK_READ_REQ;\n\telse if (rq_data_dir(req) == WRITE)\n\t\trw_cmd = MDSK_WRITE_REQ;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\tblksize = block->bp_block;\n\t \n\tfirst_rec = blk_rq_pos(req) >> block->s2b_shift;\n\tlast_rec =\n\t\t(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\n\t \n\tcount = 0;\n\trq_for_each_segment(bv, req, iter) {\n\t\tif (bv.bv_len & (blksize - 1))\n\t\t\t \n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcount += bv.bv_len >> (block->s2b_shift + 9);\n\t}\n\t \n\tif (count != last_rec - first_rec + 1)\n\t\treturn ERR_PTR(-EINVAL);\n\t \n\tcqr = dasd_smalloc_request(DASD_DIAG_MAGIC, 0, struct_size(dreq, bio, count),\n\t\t\t\t   memdev, blk_mq_rq_to_pdu(req));\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\n\tdreq = (struct dasd_diag_req *) cqr->data;\n\tdreq->block_count = count;\n\tdbio = dreq->bio;\n\trecid = first_rec;\n\trq_for_each_segment(bv, req, iter) {\n\t\tdst = bvec_virt(&bv);\n\t\tfor (off = 0; off < bv.bv_len; off += blksize) {\n\t\t\tmemset(dbio, 0, sizeof (struct dasd_diag_bio));\n\t\t\tdbio->type = rw_cmd;\n\t\t\tdbio->block_number = recid + 1;\n\t\t\tdbio->buffer = dst;\n\t\t\tdbio++;\n\t\t\tdst += blksize;\n\t\t\trecid++;\n\t\t}\n\t}\n\tcqr->retries = memdev->default_retries;\n\tcqr->buildclk = get_tod_clock();\n\tif (blk_noretry_request(req) ||\n\t    block->base->features & DASD_FEATURE_FAILFAST)\n\t\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->startdev = memdev;\n\tcqr->memdev = memdev;\n\tcqr->block = block;\n\tcqr->expires = memdev->default_expires * HZ;\n\tcqr->status = DASD_CQR_FILLED;\n\treturn cqr;\n}\n\n \nstatic int\ndasd_diag_free_cp(struct dasd_ccw_req *cqr, struct request *req)\n{\n\tint status;\n\n\tstatus = cqr->status == DASD_CQR_DONE;\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn status;\n}\n\nstatic void dasd_diag_handle_terminated_request(struct dasd_ccw_req *cqr)\n{\n\tif (cqr->retries < 0)\n\t\tcqr->status = DASD_CQR_FAILED;\n\telse\n\t\tcqr->status = DASD_CQR_FILLED;\n};\n\n \nstatic int\ndasd_diag_fill_info(struct dasd_device * device,\n\t\t    struct dasd_information2_t * info)\n{\n\tstruct dasd_diag_private *private = device->private;\n\n\tinfo->label_block = (unsigned int) private->pt_block;\n\tinfo->FBA_layout = 1;\n\tinfo->format = DASD_FORMAT_LDL;\n\tinfo->characteristics_size = sizeof(private->rdc_data);\n\tmemcpy(info->characteristics, &private->rdc_data,\n\t       sizeof(private->rdc_data));\n\tinfo->confdata_size = 0;\n\treturn 0;\n}\n\nstatic void\ndasd_diag_dump_sense(struct dasd_device *device, struct dasd_ccw_req * req,\n\t\t     struct irb *stat)\n{\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t    \"dump sense not available for DIAG data\");\n}\n\n \nstatic void dasd_diag_setup_blk_queue(struct dasd_block *block)\n{\n\tunsigned int logical_block_size = block->bp_block;\n\tstruct request_queue *q = block->gdp->queue;\n\tint max;\n\n\tmax = DIAG_MAX_BLOCKS << block->s2b_shift;\n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, q);\n\tq->limits.max_dev_sectors = max;\n\tblk_queue_logical_block_size(q, logical_block_size);\n\tblk_queue_max_hw_sectors(q, max);\n\tblk_queue_max_segments(q, USHRT_MAX);\n\t \n\tblk_queue_max_segment_size(q, PAGE_SIZE);\n\tblk_queue_segment_boundary(q, PAGE_SIZE - 1);\n\tblk_queue_dma_alignment(q, PAGE_SIZE - 1);\n}\n\nstatic int dasd_diag_pe_handler(struct dasd_device *device,\n\t\t\t\t__u8 tbvpm, __u8 fcsecpm)\n{\n\treturn dasd_generic_verify_path(device, tbvpm);\n}\n\nstatic struct dasd_discipline dasd_diag_discipline = {\n\t.owner = THIS_MODULE,\n\t.name = \"DIAG\",\n\t.ebcname = \"DIAG\",\n\t.check_device = dasd_diag_check_device,\n\t.pe_handler = dasd_diag_pe_handler,\n\t.fill_geometry = dasd_diag_fill_geometry,\n\t.setup_blk_queue = dasd_diag_setup_blk_queue,\n\t.start_IO = dasd_start_diag,\n\t.term_IO = dasd_diag_term_IO,\n\t.handle_terminated_request = dasd_diag_handle_terminated_request,\n\t.erp_action = dasd_diag_erp_action,\n\t.erp_postaction = dasd_diag_erp_postaction,\n\t.build_cp = dasd_diag_build_cp,\n\t.free_cp = dasd_diag_free_cp,\n\t.dump_sense = dasd_diag_dump_sense,\n\t.fill_info = dasd_diag_fill_info,\n};\n\nstatic int __init\ndasd_diag_init(void)\n{\n\tif (!MACHINE_IS_VM) {\n\t\tpr_info(\"Discipline %s cannot be used without z/VM\\n\",\n\t\t\tdasd_diag_discipline.name);\n\t\treturn -ENODEV;\n\t}\n\tASCEBC(dasd_diag_discipline.ebcname, 4);\n\n\tirq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);\n\tregister_external_irq(EXT_IRQ_CP_SERVICE, dasd_ext_handler);\n\tdasd_diag_discipline_pointer = &dasd_diag_discipline;\n\treturn 0;\n}\n\nstatic void __exit\ndasd_diag_cleanup(void)\n{\n\tunregister_external_irq(EXT_IRQ_CP_SERVICE, dasd_ext_handler);\n\tirq_subclass_unregister(IRQ_SUBCLASS_SERVICE_SIGNAL);\n\tdasd_diag_discipline_pointer = NULL;\n}\n\nmodule_init(dasd_diag_init);\nmodule_exit(dasd_diag_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}