{
  "module_name": "dasd_int.h",
  "hash_id": "c01830d03183dbc94342c71feaeaaf30666d09cc6183b83b9046322c2328a8e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_int.h",
  "human_readable_source": " \n \n\n#ifndef DASD_INT_H\n#define DASD_INT_H\n\n \n#define DASD_PER_MAJOR (1U << (MINORBITS - DASD_PARTN_BITS))\n#define DASD_PARTN_MASK ((1 << DASD_PARTN_BITS) - 1)\n\n \n\n#define DASD_STATE_NEW\t  0\n#define DASD_STATE_KNOWN  1\n#define DASD_STATE_BASIC  2\n#define DASD_STATE_UNFMT  3\n#define DASD_STATE_READY  4\n#define DASD_STATE_ONLINE 5\n\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/blkdev.h>\n#include <linux/hdreg.h>\n#include <linux/interrupt.h>\n#include <linux/log2.h>\n#include <asm/ccwdev.h>\n#include <linux/workqueue.h>\n#include <asm/debug.h>\n#include <asm/dasd.h>\n#include <asm/idals.h>\n#include <linux/bitops.h>\n#include <linux/blk-mq.h>\n\n \n#define DASD_ECKD_MAGIC 0xC5C3D2C4\n#define DASD_DIAG_MAGIC 0xC4C9C1C7\n#define DASD_FBA_MAGIC 0xC6C2C140\n\n \nstruct dasd_device;\nstruct dasd_block;\n\n \n#define DASD_SENSE_BIT_0 0x80\n#define DASD_SENSE_BIT_1 0x40\n#define DASD_SENSE_BIT_2 0x20\n#define DASD_SENSE_BIT_3 0x10\n\n \n#define DASD_SIM_SENSE 0x0F\n#define DASD_SIM_MSG_TO_OP 0x03\n#define DASD_SIM_LOG 0x0C\n\n \n#define CDEV_NESTED_FIRST 1\n#define CDEV_NESTED_SECOND 2\n\n \n#define DBF_DEV_EVENT(d_level, d_device, d_str, d_data...) \\\ndo { \\\n\tdebug_sprintf_event(d_device->debug_area, \\\n\t\t\t    d_level, \\\n\t\t\t    d_str \"\\n\", \\\n\t\t\t    d_data); \\\n} while(0)\n\n#define DBF_EVENT(d_level, d_str, d_data...)\\\ndo { \\\n\tdebug_sprintf_event(dasd_debug_area, \\\n\t\t\t    d_level,\\\n\t\t\t    d_str \"\\n\", \\\n\t\t\t    d_data); \\\n} while(0)\n\n#define DBF_EVENT_DEVID(d_level, d_cdev, d_str, d_data...)\t\\\ndo { \\\n\tstruct ccw_dev_id __dev_id;\t\t\t\\\n\tccw_device_get_id(d_cdev, &__dev_id);\t\t\\\n\tdebug_sprintf_event(dasd_debug_area,\t\t\\\n\t\t\t    d_level,\t\t\t\t\t\\\n\t\t\t    \"0.%x.%04x \" d_str \"\\n\",\t\t\t\\\n\t\t\t    __dev_id.ssid, __dev_id.devno, d_data);\t\\\n} while (0)\n\n \n#define ERRORLENGTH 30\n\n \n#define\tDBF_EMERG\t0\t \n#define\tDBF_ALERT\t1\t \n#define\tDBF_CRIT\t2\t \n#define\tDBF_ERR\t\t3\t \n#define\tDBF_WARNING\t4\t \n#define\tDBF_NOTICE\t5\t \n#define\tDBF_INFO\t6\t \n#define\tDBF_DEBUG\t6\t \n\n \n#define DEV_MESSAGE(d_loglevel,d_device,d_string,d_args...)\\\ndo { \\\n\tprintk(d_loglevel PRINTK_HEADER \" %s: \" d_string \"\\n\", \\\n\t       dev_name(&d_device->cdev->dev), d_args); \\\n\tDBF_DEV_EVENT(DBF_ALERT, d_device, d_string, d_args); \\\n} while(0)\n\n#define MESSAGE(d_loglevel,d_string,d_args...)\\\ndo { \\\n\tprintk(d_loglevel PRINTK_HEADER \" \" d_string \"\\n\", d_args); \\\n\tDBF_EVENT(DBF_ALERT, d_string, d_args); \\\n} while(0)\n\n \n#define DEV_MESSAGE_LOG(d_loglevel,d_device,d_string,d_args...)\\\ndo { \\\n\tprintk(d_loglevel PRINTK_HEADER \" %s: \" d_string \"\\n\", \\\n\t       dev_name(&d_device->cdev->dev), d_args); \\\n} while(0)\n\n#define MESSAGE_LOG(d_loglevel,d_string,d_args...)\\\ndo { \\\n\tprintk(d_loglevel PRINTK_HEADER \" \" d_string \"\\n\", d_args); \\\n} while(0)\n\n \n#define BLOCKS_PER_PAGE(blksize) (PAGE_SIZE / blksize)\n\nstruct dasd_ccw_req {\n\tunsigned int magic;\t\t \n\tint intrc;\t\t\t \n\tstruct list_head devlist;\t \n\tstruct list_head blocklist;\t \n\tstruct dasd_block *block;\t \n\tstruct dasd_device *memdev;\t \n\tstruct dasd_device *startdev;\t \n\tstruct dasd_device *basedev;\t \n\tvoid *cpaddr;\t\t\t \n\tshort retries;\t\t\t \n\tunsigned char cpmode;\t\t \n\tchar status;\t\t\t \n\tchar lpm;\t\t\t \n\tunsigned long flags;        \t \n\tstruct dasd_queue *dq;\n\tunsigned long starttime;\t \n\tunsigned long expires;\t\t \n\tvoid *data;\t\t\t \n\tstruct irb irb;\t\t\t \n\tstruct dasd_ccw_req *refers;\t \n\tvoid *function; \t\t \n\tvoid *mem_chunk;\n\n\tunsigned long buildclk;\t\t \n\tunsigned long startclk;\t\t \n\tunsigned long stopclk;\t\t \n\tunsigned long endclk;\t\t \n\n\tvoid (*callback)(struct dasd_ccw_req *, void *data);\n\tvoid *callback_data;\n\tunsigned int proc_bytes;\t \n\tunsigned int trkcount;\t\t \n};\n\n \n#define DASD_CQR_FILLED \t0x00\t \n#define DASD_CQR_DONE\t\t0x01\t \n#define DASD_CQR_NEED_ERP\t0x02\t \n#define DASD_CQR_IN_ERP \t0x03\t \n#define DASD_CQR_FAILED \t0x04\t \n#define DASD_CQR_TERMINATED\t0x05\t \n\n#define DASD_CQR_QUEUED \t0x80\t \n#define DASD_CQR_IN_IO\t\t0x81\t \n#define DASD_CQR_ERROR\t\t0x82\t \n#define DASD_CQR_CLEAR_PENDING\t0x83\t \n#define DASD_CQR_CLEARED\t0x84\t \n#define DASD_CQR_SUCCESS\t0x85\t \n\n \n#define DASD_EXPIRES\t  300\n#define DASD_EXPIRES_MAX  40000000\n#define DASD_RETRIES\t  256\n#define DASD_RETRIES_MAX  32768\n\n \n#define DASD_CQR_FLAGS_USE_ERP   0\t \n#define DASD_CQR_FLAGS_FAILFAST  1\t \n#define DASD_CQR_VERIFY_PATH\t 2\t \n#define DASD_CQR_ALLOW_SLOCK\t 3\t \n \n#define DASD_CQR_SUPPRESS_NRF\t4\t \n#define DASD_CQR_SUPPRESS_FP\t5\t \n#define DASD_CQR_SUPPRESS_IL\t6\t \n#define DASD_CQR_SUPPRESS_CR\t7\t \n\n#define DASD_REQ_PER_DEV 4\n\n \ntypedef struct dasd_ccw_req *(*dasd_erp_fn_t) (struct dasd_ccw_req *);\n\n \n#define DASD_CQR_MAX_CCW 255\n\n \n#define UA_NOT_CONFIGURED  0x00\n#define UA_BASE_DEVICE\t   0x01\n#define UA_BASE_PAV_ALIAS  0x02\n#define UA_HYPER_PAV_ALIAS 0x03\n\nstruct dasd_uid {\n\t__u8 type;\n\tchar vendor[4];\n\tchar serial[15];\n\t__u16 ssid;\n\t__u8 real_unit_addr;\n\t__u8 base_unit_addr;\n\tchar vduit[33];\n};\n\n#define DASD_UID_STRLEN (   3 + 1 +   14 + 1 +\t\\\n\t\t\t    4 + 1 +   2 + 1 +\t\\\n\t\t\t    32 + 1)\n\n \nstruct dasd_pprc_header {\n\t__u8 entries;\t\t \n\t__u8 unused;\t\t \n\t__u16 entry_length;\t \n\t__u32 unused2;\t\t \n} __packed;\n\nstruct dasd_pprc_dev_info {\n\t__u8 state;\t\t \n\t__u8 flags;\t\t \n\t__u8 reserved1[2];\t \n\t__u8 prim_lss;\t\t \n\t__u8 primary;\t\t \n\t__u8 sec_lss;\t\t \n\t__u8 secondary;\t\t \n\t__u16 pprc_id;\t\t \n\t__u8 reserved2[12];\t \n\t__u16 prim_cu_ssid;\t \n\t__u8 reserved3[12];\t \n\t__u16 sec_cu_ssid;\t \n\t__u8 reserved4[90];\t \n} __packed;\n\nstruct dasd_pprc_data_sc4 {\n\tstruct dasd_pprc_header header;\n\tstruct dasd_pprc_dev_info dev_info[5];\n} __packed;\n\n#define DASD_BUS_ID_SIZE 20\n#define DASD_CP_ENTRIES 5\n\nstruct dasd_copy_entry {\n\tchar busid[DASD_BUS_ID_SIZE];\n\tstruct dasd_device *device;\n\tbool primary;\n\tbool configured;\n};\n\nstruct dasd_copy_relation {\n\tstruct dasd_copy_entry entry[DASD_CP_ENTRIES];\n\tstruct dasd_copy_entry *active;\n};\n\nint dasd_devmap_set_device_copy_relation(struct ccw_device *,\n\t\t\t\t\t bool pprc_enabled);\n\n \nstruct dasd_discipline {\n\tstruct module *owner;\n\tchar ebcname[8];\t \n\tchar name[8];\t\t \n\n\tstruct list_head list;\t \n\n\t \n\tint (*check_device) (struct dasd_device *);\n\tvoid (*uncheck_device) (struct dasd_device *);\n\n\t \n\tint (*do_analysis) (struct dasd_block *);\n\n\t \n\tint (*pe_handler)(struct dasd_device *, __u8, __u8);\n\n\t \n\tint (*basic_to_ready) (struct dasd_device *);\n\tint (*online_to_ready) (struct dasd_device *);\n\tint (*basic_to_known)(struct dasd_device *);\n\n\t \n\tvoid (*setup_blk_queue)(struct dasd_block *);\n\t \n\tstruct dasd_ccw_req *(*build_cp) (struct dasd_device *,\n\t\t\t\t\t  struct dasd_block *,\n\t\t\t\t\t  struct request *);\n\tint (*start_IO) (struct dasd_ccw_req *);\n\tint (*term_IO) (struct dasd_ccw_req *);\n\tvoid (*handle_terminated_request) (struct dasd_ccw_req *);\n\tint (*format_device) (struct dasd_device *,\n\t\t\t      struct format_data_t *, int);\n\tint (*check_device_format)(struct dasd_device *,\n\t\t\t\t   struct format_check_t *, int);\n\tint (*free_cp) (struct dasd_ccw_req *, struct request *);\n\n\t \n\tdasd_erp_fn_t(*erp_action) (struct dasd_ccw_req *);\n\tdasd_erp_fn_t(*erp_postaction) (struct dasd_ccw_req *);\n\tvoid (*dump_sense) (struct dasd_device *, struct dasd_ccw_req *,\n\t\t\t    struct irb *);\n\tvoid (*dump_sense_dbf) (struct dasd_device *, struct irb *, char *);\n\tvoid (*check_for_device_change) (struct dasd_device *,\n\t\t\t\t\t struct dasd_ccw_req *,\n\t\t\t\t\t struct irb *);\n\n         \n\tint (*fill_geometry) (struct dasd_block *, struct hd_geometry *);\n\tint (*fill_info) (struct dasd_device *, struct dasd_information2_t *);\n\tint (*ioctl) (struct dasd_block *, unsigned int, void __user *);\n\n\t \n\tint (*reload) (struct dasd_device *);\n\n\tint (*get_uid) (struct dasd_device *, struct dasd_uid *);\n\tvoid (*kick_validate) (struct dasd_device *);\n\tint (*check_attention)(struct dasd_device *, __u8);\n\tint (*host_access_count)(struct dasd_device *);\n\tint (*hosts_print)(struct dasd_device *, struct seq_file *);\n\tvoid (*handle_hpf_error)(struct dasd_device *, struct irb *);\n\tvoid (*disable_hpf)(struct dasd_device *);\n\tint (*hpf_enabled)(struct dasd_device *);\n\tvoid (*reset_path)(struct dasd_device *, __u8);\n\n\t \n\tint (*is_ese)(struct dasd_device *);\n\t \n\tint (*space_allocated)(struct dasd_device *);\n\tint (*space_configured)(struct dasd_device *);\n\tint (*logical_capacity)(struct dasd_device *);\n\tint (*release_space)(struct dasd_device *, struct format_data_t *);\n\t \n\tint (*ext_pool_id)(struct dasd_device *);\n\tint (*ext_size)(struct dasd_device *);\n\tint (*ext_pool_cap_at_warnlevel)(struct dasd_device *);\n\tint (*ext_pool_warn_thrshld)(struct dasd_device *);\n\tint (*ext_pool_oos)(struct dasd_device *);\n\tint (*ext_pool_exhaust)(struct dasd_device *, struct dasd_ccw_req *);\n\tstruct dasd_ccw_req *(*ese_format)(struct dasd_device *,\n\t\t\t\t\t   struct dasd_ccw_req *, struct irb *);\n\tint (*ese_read)(struct dasd_ccw_req *, struct irb *);\n\tint (*pprc_status)(struct dasd_device *, struct\tdasd_pprc_data_sc4 *);\n\tbool (*pprc_enabled)(struct dasd_device *);\n\tint (*copy_pair_swap)(struct dasd_device *, char *, char *);\n\tint (*device_ping)(struct dasd_device *);\n};\n\nextern struct dasd_discipline *dasd_diag_discipline_pointer;\n\n \nenum eer_trigger {\n\tDASD_EER_FATALERROR = 1,\n\tDASD_EER_NOPATH,\n\tDASD_EER_STATECHANGE,\n\tDASD_EER_PPRCSUSPEND,\n\tDASD_EER_NOSPC,\n\tDASD_EER_TIMEOUTS,\n\tDASD_EER_STARTIO,\n\n\t \n\tDASD_EER_MAX,\n\tDASD_EER_AUTOQUIESCE = 31,  \n};\n\n#define DASD_EER_VALID ((1U << DASD_EER_MAX) - 1)\n\n \n\n#define DASD_PATH_OPERATIONAL  1\n#define DASD_PATH_TBV\t       2\n#define DASD_PATH_PP\t       3\n#define DASD_PATH_NPP\t       4\n#define DASD_PATH_MISCABLED    5\n#define DASD_PATH_NOHPF        6\n#define DASD_PATH_CUIR\t       7\n#define DASD_PATH_IFCC\t       8\n#define DASD_PATH_FCSEC\t       9\n\n#define DASD_THRHLD_MAX\t\t4294967295U\n#define DASD_INTERVAL_MAX\t4294967295U\n\n \n#define DASD_FC_SECURITY_UNSUP\t\t0\n#define DASD_FC_SECURITY_AUTH\t\t1\n#define DASD_FC_SECURITY_ENC_FCSP2\t2\n#define DASD_FC_SECURITY_ENC_ERAS\t3\n\n#define DASD_FC_SECURITY_ENC_STR\t\"Encryption\"\nstatic const struct {\n\tu8 value;\n\tchar *name;\n} dasd_path_fcs_mnemonics[] = {\n\t{ DASD_FC_SECURITY_UNSUP,\t\"Unsupported\" },\n\t{ DASD_FC_SECURITY_AUTH,\t\"Authentication\" },\n\t{ DASD_FC_SECURITY_ENC_FCSP2,\tDASD_FC_SECURITY_ENC_STR },\n\t{ DASD_FC_SECURITY_ENC_ERAS,\tDASD_FC_SECURITY_ENC_STR },\n};\n\nstatic inline char *dasd_path_get_fcs_str(int val)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dasd_path_fcs_mnemonics); i++) {\n\t\tif (dasd_path_fcs_mnemonics[i].value == val)\n\t\t\treturn dasd_path_fcs_mnemonics[i].name;\n\t}\n\n\treturn dasd_path_fcs_mnemonics[0].name;\n}\n\nstruct dasd_path {\n\tunsigned long flags;\n\tu8 cssid;\n\tu8 ssid;\n\tu8 chpid;\n\tstruct dasd_conf_data *conf_data;\n\tatomic_t error_count;\n\tunsigned long errorclk;\n\tu8 fc_security;\n\tstruct kobject kobj;\n\tbool in_sysfs;\n};\n\n#define to_dasd_path(path) container_of(path, struct dasd_path, kobj)\n\nstatic inline void dasd_path_release(struct kobject *kobj)\n{\n \n}\n\n\nstruct dasd_profile_info {\n\t \n\tunsigned int dasd_io_reqs;\t  \n\tunsigned int dasd_io_sects;\t  \n\tunsigned int dasd_io_secs[32];\t  \n\tunsigned int dasd_io_times[32];\t  \n\tunsigned int dasd_io_timps[32];\t  \n\tunsigned int dasd_io_time1[32];\t  \n\tunsigned int dasd_io_time2[32];\t  \n\tunsigned int dasd_io_time2ps[32];  \n\tunsigned int dasd_io_time3[32];\t  \n\tunsigned int dasd_io_nr_req[32];  \n\n\t \n\tstruct timespec64 starttod;\t    \n\tunsigned int dasd_io_alias;\t    \n\tunsigned int dasd_io_tpm;\t    \n\tunsigned int dasd_read_reqs;\t    \n\tunsigned int dasd_read_sects;\t    \n\tunsigned int dasd_read_alias;\t    \n\tunsigned int dasd_read_tpm;\t    \n\tunsigned int dasd_read_secs[32];    \n\tunsigned int dasd_read_times[32];   \n\tunsigned int dasd_read_time1[32];   \n\tunsigned int dasd_read_time2[32];   \n\tunsigned int dasd_read_time3[32];   \n\tunsigned int dasd_read_nr_req[32];  \n\tunsigned long dasd_sum_times;\t    \n\tunsigned long dasd_sum_time_str;    \n\tunsigned long dasd_sum_time_irq;    \n\tunsigned long dasd_sum_time_end;    \n};\n\nstruct dasd_profile {\n\tstruct dentry *dentry;\n\tstruct dasd_profile_info *data;\n\tspinlock_t lock;\n};\n\nstruct dasd_format_entry {\n\tstruct list_head list;\n\tsector_t track;\n};\n\nstruct dasd_device {\n\t \n\tstruct dasd_block *block;\n\n        unsigned int devindex;\n\tunsigned long flags;\t    \n\tunsigned short features;    \n\n\t \n\tstruct dasd_ccw_req *eer_cqr;\n\n\t \n\tstruct dasd_discipline *discipline;\n\tstruct dasd_discipline *base_discipline;\n\tvoid *private;\n\tstruct dasd_path path[8];\n\t__u8 opm;\n\n\t \n\tint state, target;\n\tstruct mutex state_mutex;\n\tint stopped;\t\t \n\n\t \n        atomic_t ref_count;\n\n\t \n\tstruct list_head ccw_queue;\n\tspinlock_t mem_lock;\n\tvoid *ccw_mem;\n\tvoid *erp_mem;\n\tvoid *ese_mem;\n\tstruct list_head ccw_chunks;\n\tstruct list_head erp_chunks;\n\tstruct list_head ese_chunks;\n\n\tatomic_t tasklet_scheduled;\n        struct tasklet_struct tasklet;\n\tstruct work_struct kick_work;\n\tstruct work_struct reload_device;\n\tstruct work_struct kick_validate;\n\tstruct work_struct suc_work;\n\tstruct work_struct requeue_requests;\n\tstruct timer_list timer;\n\n\tdebug_info_t *debug_area;\n\n\tstruct ccw_device *cdev;\n\n\t \n\tstruct list_head alias_list;\n\n\t \n\tunsigned long default_expires;\n\tunsigned long default_retries;\n\n\tunsigned long blk_timeout;\n\n\tunsigned long path_thrhld;\n\tunsigned long path_interval;\n\n\tstruct dentry *debugfs_dentry;\n\tstruct dentry *hosts_dentry;\n\tstruct dasd_profile profile;\n\tstruct dasd_format_entry format_entry;\n\tstruct kset *paths_info;\n\tstruct dasd_copy_relation *copy;\n\tunsigned long aq_mask;\n\tunsigned int aq_timeouts;\n};\n\nstruct dasd_block {\n\t \n\tstruct gendisk *gdp;\n\tspinlock_t request_queue_lock;\n\tstruct blk_mq_tag_set tag_set;\n\tstruct block_device *bdev;\n\tatomic_t open_count;\n\n\tunsigned long blocks;\t    \n\tunsigned int bp_block;\t    \n\tunsigned int s2b_shift;\t    \n\n\tstruct dasd_device *base;\n\tstruct list_head ccw_queue;\n\tspinlock_t queue_lock;\n\n\tatomic_t tasklet_scheduled;\n\tstruct tasklet_struct tasklet;\n\tstruct timer_list timer;\n\n\tstruct dentry *debugfs_dentry;\n\tstruct dasd_profile profile;\n\n\tstruct list_head format_list;\n\tspinlock_t format_lock;\n\tatomic_t trkcount;\n};\n\nstruct dasd_attention_data {\n\tstruct dasd_device *device;\n\t__u8 lpum;\n};\n\nstruct dasd_queue {\n\tspinlock_t lock;\n};\n\n \n#define DASD_STOPPED_NOT_ACC 1          \n#define DASD_STOPPED_QUIESCE 2          \n#define DASD_STOPPED_PENDING 4          \n#define DASD_STOPPED_DC_WAIT 8          \n#define DASD_STOPPED_SU      16         \n#define DASD_STOPPED_PPRC    32         \n#define DASD_STOPPED_NOSPC   128        \n\n \n#define DASD_FLAG_OFFLINE\t3\t \n#define DASD_FLAG_EER_SNSS\t4\t \n#define DASD_FLAG_EER_IN_USE\t5\t \n#define DASD_FLAG_DEVICE_RO\t6\t \n#define DASD_FLAG_IS_RESERVED\t7\t \n#define DASD_FLAG_LOCK_STOLEN\t8\t \n#define DASD_FLAG_SUSPENDED\t9\t \n#define DASD_FLAG_SAFE_OFFLINE\t10\t \n#define DASD_FLAG_SAFE_OFFLINE_RUNNING\t11\t \n#define DASD_FLAG_ABORTALL\t12\t \n#define DASD_FLAG_PATH_VERIFY\t13\t \n#define DASD_FLAG_SUC\t\t14\t \n\n#define DASD_SLEEPON_START_TAG\t((void *) 1)\n#define DASD_SLEEPON_END_TAG\t((void *) 2)\n\nvoid dasd_put_device_wake(struct dasd_device *);\n\n \n#define DASD_COPYPAIRSWAP_SUCCESS\t0\n#define DASD_COPYPAIRSWAP_INVALID\t1\n#define DASD_COPYPAIRSWAP_NOACTIVE\t2\n#define DASD_COPYPAIRSWAP_PRIMARY\t3\n#define DASD_COPYPAIRSWAP_SECONDARY\t4\n#define DASD_COPYPAIRSWAP_MULTIPLE\t5\n\n \nstatic inline void\ndasd_get_device(struct dasd_device *device)\n{\n\tatomic_inc(&device->ref_count);\n}\n\nstatic inline void\ndasd_put_device(struct dasd_device *device)\n{\n\tif (atomic_dec_return(&device->ref_count) == 0)\n\t\tdasd_put_device_wake(device);\n}\n\n \nstruct dasd_mchunk\n{\n\tstruct list_head list;\n\tunsigned long size;\n} __attribute__ ((aligned(8)));\n\nstatic inline void\ndasd_init_chunklist(struct list_head *chunk_list, void *mem,\n\t\t    unsigned long size)\n{\n\tstruct dasd_mchunk *chunk;\n\n\tINIT_LIST_HEAD(chunk_list);\n\tchunk = (struct dasd_mchunk *) mem;\n\tchunk->size = size - sizeof(struct dasd_mchunk);\n\tlist_add(&chunk->list, chunk_list);\n}\n\nstatic inline void *\ndasd_alloc_chunk(struct list_head *chunk_list, unsigned long size)\n{\n\tstruct dasd_mchunk *chunk, *tmp;\n\n\tsize = (size + 7L) & -8L;\n\tlist_for_each_entry(chunk, chunk_list, list) {\n\t\tif (chunk->size < size)\n\t\t\tcontinue;\n\t\tif (chunk->size > size + sizeof(struct dasd_mchunk)) {\n\t\t\tchar *endaddr = (char *) (chunk + 1) + chunk->size;\n\t\t\ttmp = (struct dasd_mchunk *) (endaddr - size) - 1;\n\t\t\ttmp->size = size;\n\t\t\tchunk->size -= size + sizeof(struct dasd_mchunk);\n\t\t\tchunk = tmp;\n\t\t} else\n\t\t\tlist_del(&chunk->list);\n\t\treturn (void *) (chunk + 1);\n\t}\n\treturn NULL;\n}\n\nstatic inline void\ndasd_free_chunk(struct list_head *chunk_list, void *mem)\n{\n\tstruct dasd_mchunk *chunk, *tmp;\n\tstruct list_head *p, *left;\n\n\tchunk = (struct dasd_mchunk *)\n\t\t((char *) mem - sizeof(struct dasd_mchunk));\n\t \n\tleft = chunk_list;\n\tlist_for_each(p, chunk_list) {\n\t\tif (list_entry(p, struct dasd_mchunk, list) > chunk)\n\t\t\tbreak;\n\t\tleft = p;\n\t}\n\t \n\tif (left->next != chunk_list) {\n\t\ttmp = list_entry(left->next, struct dasd_mchunk, list);\n\t\tif ((char *) (chunk + 1) + chunk->size == (char *) tmp) {\n\t\t\tlist_del(&tmp->list);\n\t\t\tchunk->size += tmp->size + sizeof(struct dasd_mchunk);\n\t\t}\n\t}\n\t \n\tif (left != chunk_list) {\n\t\ttmp = list_entry(left, struct dasd_mchunk, list);\n\t\tif ((char *) (tmp + 1) + tmp->size == (char *) chunk) {\n\t\t\ttmp->size += chunk->size + sizeof(struct dasd_mchunk);\n\t\t\treturn;\n\t\t}\n\t}\n\t__list_add(&chunk->list, left, left->next);\n}\n\n \nstatic inline int\ndasd_check_blocksize(int bsize)\n{\n\tif (bsize < 512 || bsize > 4096 || !is_power_of_2(bsize))\n\t\treturn -EMEDIUMTYPE;\n\treturn 0;\n}\n\n \nstatic inline void *dasd_get_callback_data(struct dasd_ccw_req *cqr)\n{\n\twhile (cqr->refers)\n\t\tcqr = cqr->refers;\n\n\treturn cqr->callback_data;\n}\n\n \n#define DASD_PROFILE_OFF\t 0\n#define DASD_PROFILE_ON \t 1\n#define DASD_PROFILE_GLOBAL_ONLY 2\n\nextern debug_info_t *dasd_debug_area;\nextern struct dasd_profile dasd_global_profile;\nextern unsigned int dasd_global_profile_level;\nextern const struct block_device_operations dasd_device_operations;\nextern struct blk_mq_ops dasd_mq_ops;\n\nextern struct kmem_cache *dasd_page_cache;\n\nstruct dasd_ccw_req *\ndasd_smalloc_request(int, int, int, struct dasd_device *, struct dasd_ccw_req *);\nstruct dasd_ccw_req *dasd_fmalloc_request(int, int, int, struct dasd_device *);\nvoid dasd_sfree_request(struct dasd_ccw_req *, struct dasd_device *);\nvoid dasd_ffree_request(struct dasd_ccw_req *, struct dasd_device *);\nvoid dasd_wakeup_cb(struct dasd_ccw_req *, void *);\n\nstruct dasd_device *dasd_alloc_device(void);\nvoid dasd_free_device(struct dasd_device *);\n\nstruct dasd_block *dasd_alloc_block(void);\nvoid dasd_free_block(struct dasd_block *);\n\nenum blk_eh_timer_return dasd_times_out(struct request *req);\n\nvoid dasd_enable_device(struct dasd_device *);\nvoid dasd_set_target_state(struct dasd_device *, int);\nvoid dasd_kick_device(struct dasd_device *);\nvoid dasd_reload_device(struct dasd_device *);\nvoid dasd_schedule_requeue(struct dasd_device *);\n\nvoid dasd_add_request_head(struct dasd_ccw_req *);\nvoid dasd_add_request_tail(struct dasd_ccw_req *);\nint  dasd_start_IO(struct dasd_ccw_req *);\nint  dasd_term_IO(struct dasd_ccw_req *);\nvoid dasd_schedule_device_bh(struct dasd_device *);\nvoid dasd_schedule_block_bh(struct dasd_block *);\nint  dasd_sleep_on(struct dasd_ccw_req *);\nint  dasd_sleep_on_queue(struct list_head *);\nint  dasd_sleep_on_immediatly(struct dasd_ccw_req *);\nint  dasd_sleep_on_queue_interruptible(struct list_head *);\nint  dasd_sleep_on_interruptible(struct dasd_ccw_req *);\nvoid dasd_device_set_timer(struct dasd_device *, int);\nvoid dasd_device_clear_timer(struct dasd_device *);\nvoid dasd_block_set_timer(struct dasd_block *, int);\nvoid dasd_block_clear_timer(struct dasd_block *);\nint  dasd_cancel_req(struct dasd_ccw_req *);\nint dasd_flush_device_queue(struct dasd_device *);\nint dasd_generic_probe(struct ccw_device *);\nvoid dasd_generic_free_discipline(struct dasd_device *);\nvoid dasd_generic_remove (struct ccw_device *cdev);\nint dasd_generic_set_online(struct ccw_device *, struct dasd_discipline *);\nint dasd_generic_set_offline (struct ccw_device *cdev);\nint dasd_generic_notify(struct ccw_device *, int);\nint dasd_generic_last_path_gone(struct dasd_device *);\nint dasd_generic_path_operational(struct dasd_device *);\nvoid dasd_generic_shutdown(struct ccw_device *);\n\nvoid dasd_generic_handle_state_change(struct dasd_device *);\nenum uc_todo dasd_generic_uc_handler(struct ccw_device *, struct irb *);\nvoid dasd_generic_path_event(struct ccw_device *, int *);\nint dasd_generic_verify_path(struct dasd_device *, __u8);\nvoid dasd_generic_space_exhaust(struct dasd_device *, struct dasd_ccw_req *);\nvoid dasd_generic_space_avail(struct dasd_device *);\n\nint dasd_generic_requeue_all_requests(struct dasd_device *);\n\nint dasd_generic_read_dev_chars(struct dasd_device *, int, void *, int);\nchar *dasd_get_sense(struct irb *);\n\nvoid dasd_device_set_stop_bits(struct dasd_device *, int);\nvoid dasd_device_remove_stop_bits(struct dasd_device *, int);\n\nint dasd_device_is_ro(struct dasd_device *);\n\nvoid dasd_profile_reset(struct dasd_profile *);\nint dasd_profile_on(struct dasd_profile *);\nvoid dasd_profile_off(struct dasd_profile *);\nchar *dasd_get_user_string(const char __user *, size_t);\n\n \nextern int dasd_max_devindex;\nextern int dasd_probeonly;\nextern int dasd_autodetect;\nextern int dasd_nopav;\nextern int dasd_nofcx;\n\nint dasd_devmap_init(void);\nvoid dasd_devmap_exit(void);\n\nstruct dasd_device *dasd_create_device(struct ccw_device *);\nvoid dasd_delete_device(struct dasd_device *);\n\nint dasd_get_feature(struct ccw_device *, int);\nint dasd_set_feature(struct ccw_device *, int, int);\n\nextern const struct attribute_group *dasd_dev_groups[];\nvoid dasd_path_create_kobj(struct dasd_device *, int);\nvoid dasd_path_create_kobjects(struct dasd_device *);\nvoid dasd_path_remove_kobjects(struct dasd_device *);\n\nstruct dasd_device *dasd_device_from_cdev(struct ccw_device *);\nstruct dasd_device *dasd_device_from_cdev_locked(struct ccw_device *);\nstruct dasd_device *dasd_device_from_devindex(int);\n\nvoid dasd_add_link_to_gendisk(struct gendisk *, struct dasd_device *);\nstruct dasd_device *dasd_device_from_gendisk(struct gendisk *);\n\nint dasd_parse(void) __init;\nint dasd_busid_known(const char *);\n\n \nint  dasd_gendisk_init(void);\nvoid dasd_gendisk_exit(void);\nint dasd_gendisk_alloc(struct dasd_block *);\nvoid dasd_gendisk_free(struct dasd_block *);\nint dasd_scan_partitions(struct dasd_block *);\nvoid dasd_destroy_partitions(struct dasd_block *);\n\n \nint dasd_ioctl(struct block_device *bdev, blk_mode_t mode, unsigned int cmd,\n\t\tunsigned long arg);\nint dasd_set_read_only(struct block_device *bdev, bool ro);\n\n \nint dasd_proc_init(void);\nvoid dasd_proc_exit(void);\n\n \nstruct dasd_ccw_req *dasd_default_erp_action(struct dasd_ccw_req *);\nstruct dasd_ccw_req *dasd_default_erp_postaction(struct dasd_ccw_req *);\nstruct dasd_ccw_req *dasd_alloc_erp_request(unsigned int, int, int,\n\t\t\t\t\t    struct dasd_device *);\nvoid dasd_free_erp_request(struct dasd_ccw_req *, struct dasd_device *);\nvoid dasd_log_sense(struct dasd_ccw_req *, struct irb *);\nvoid dasd_log_sense_dbf(struct dasd_ccw_req *cqr, struct irb *irb);\n\n \nstruct dasd_ccw_req *dasd_3990_erp_action(struct dasd_ccw_req *);\nvoid dasd_3990_erp_handle_sim(struct dasd_device *, char *);\n\n \n#ifdef CONFIG_DASD_EER\nint dasd_eer_init(void);\nvoid dasd_eer_exit(void);\nint dasd_eer_enable(struct dasd_device *);\nvoid dasd_eer_disable(struct dasd_device *);\nvoid dasd_eer_write(struct dasd_device *, struct dasd_ccw_req *cqr,\n\t\t    unsigned int id);\nvoid dasd_eer_snss(struct dasd_device *);\n\nstatic inline int dasd_eer_enabled(struct dasd_device *device)\n{\n\treturn device->eer_cqr != NULL;\n}\n#else\n#define dasd_eer_init()\t\t(0)\n#define dasd_eer_exit()\t\tdo { } while (0)\n#define dasd_eer_enable(d)\t(0)\n#define dasd_eer_disable(d)\tdo { } while (0)\n#define dasd_eer_write(d,c,i)\tdo { } while (0)\n#define dasd_eer_snss(d)\tdo { } while (0)\n#define dasd_eer_enabled(d)\t(0)\n#endif\t \n\n\n \n\n \nstatic inline int dasd_path_is_operational(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_OPERATIONAL, &device->path[chp].flags);\n}\n\nstatic inline int dasd_path_need_verify(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_TBV, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_verify(struct dasd_device *device, int chp)\n{\n\t__set_bit(DASD_PATH_TBV, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_verify(struct dasd_device *device, int chp)\n{\n\t__clear_bit(DASD_PATH_TBV, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_all_verify(struct dasd_device *device)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tdasd_path_clear_verify(device, chp);\n}\n\nstatic inline void dasd_path_fcsec(struct dasd_device *device, int chp)\n{\n\t__set_bit(DASD_PATH_FCSEC, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_fcsec(struct dasd_device *device, int chp)\n{\n\t__clear_bit(DASD_PATH_FCSEC, &device->path[chp].flags);\n}\n\nstatic inline int dasd_path_need_fcsec(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_FCSEC, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_all_fcsec(struct dasd_device *device)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tdasd_path_clear_fcsec(device, chp);\n}\n\nstatic inline void dasd_path_operational(struct dasd_device *device, int chp)\n{\n\t__set_bit(DASD_PATH_OPERATIONAL, &device->path[chp].flags);\n\tdevice->opm |= (0x80 >> chp);\n}\n\nstatic inline void dasd_path_nonpreferred(struct dasd_device *device, int chp)\n{\n\t__set_bit(DASD_PATH_NPP, &device->path[chp].flags);\n}\n\nstatic inline int dasd_path_is_nonpreferred(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_NPP, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_nonpreferred(struct dasd_device *device,\n\t\t\t\t\t\tint chp)\n{\n\t__clear_bit(DASD_PATH_NPP, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_preferred(struct dasd_device *device, int chp)\n{\n\t__set_bit(DASD_PATH_PP, &device->path[chp].flags);\n}\n\nstatic inline int dasd_path_is_preferred(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_PP, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_preferred(struct dasd_device *device,\n\t\t\t\t\t     int chp)\n{\n\t__clear_bit(DASD_PATH_PP, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_oper(struct dasd_device *device, int chp)\n{\n\t__clear_bit(DASD_PATH_OPERATIONAL, &device->path[chp].flags);\n\tdevice->opm &= ~(0x80 >> chp);\n}\n\nstatic inline void dasd_path_clear_cable(struct dasd_device *device, int chp)\n{\n\t__clear_bit(DASD_PATH_MISCABLED, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_cuir(struct dasd_device *device, int chp)\n{\n\t__set_bit(DASD_PATH_CUIR, &device->path[chp].flags);\n}\n\nstatic inline int dasd_path_is_cuir(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_CUIR, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_cuir(struct dasd_device *device, int chp)\n{\n\t__clear_bit(DASD_PATH_CUIR, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_ifcc(struct dasd_device *device, int chp)\n{\n\tset_bit(DASD_PATH_IFCC, &device->path[chp].flags);\n}\n\nstatic inline int dasd_path_is_ifcc(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_IFCC, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_ifcc(struct dasd_device *device, int chp)\n{\n\tclear_bit(DASD_PATH_IFCC, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_clear_nohpf(struct dasd_device *device, int chp)\n{\n\t__clear_bit(DASD_PATH_NOHPF, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_miscabled(struct dasd_device *device, int chp)\n{\n\t__set_bit(DASD_PATH_MISCABLED, &device->path[chp].flags);\n}\n\nstatic inline int dasd_path_is_miscabled(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_MISCABLED, &device->path[chp].flags);\n}\n\nstatic inline void dasd_path_nohpf(struct dasd_device *device, int chp)\n{\n\t__set_bit(DASD_PATH_NOHPF, &device->path[chp].flags);\n}\n\nstatic inline int dasd_path_is_nohpf(struct dasd_device *device, int chp)\n{\n\treturn test_bit(DASD_PATH_NOHPF, &device->path[chp].flags);\n}\n\n \n\nstatic inline __u8 dasd_path_get_opm(struct dasd_device *device)\n{\n\treturn device->opm;\n}\n\nstatic inline __u8 dasd_path_get_tbvpm(struct dasd_device *device)\n{\n\tint chp;\n\t__u8 tbvpm = 0x00;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (dasd_path_need_verify(device, chp))\n\t\t\ttbvpm |= 0x80 >> chp;\n\treturn tbvpm;\n}\n\nstatic inline int dasd_path_get_fcsecpm(struct dasd_device *device)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (dasd_path_need_fcsec(device, chp))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline __u8 dasd_path_get_nppm(struct dasd_device *device)\n{\n\tint chp;\n\t__u8 npm = 0x00;\n\n\tfor (chp = 0; chp < 8; chp++) {\n\t\tif (dasd_path_is_nonpreferred(device, chp))\n\t\t\tnpm |= 0x80 >> chp;\n\t}\n\treturn npm;\n}\n\nstatic inline __u8 dasd_path_get_ppm(struct dasd_device *device)\n{\n\tint chp;\n\t__u8 ppm = 0x00;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (dasd_path_is_preferred(device, chp))\n\t\t\tppm |= 0x80 >> chp;\n\treturn ppm;\n}\n\nstatic inline __u8 dasd_path_get_cablepm(struct dasd_device *device)\n{\n\tint chp;\n\t__u8 cablepm = 0x00;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (dasd_path_is_miscabled(device, chp))\n\t\t\tcablepm |= 0x80 >> chp;\n\treturn cablepm;\n}\n\nstatic inline __u8 dasd_path_get_cuirpm(struct dasd_device *device)\n{\n\tint chp;\n\t__u8 cuirpm = 0x00;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (dasd_path_is_cuir(device, chp))\n\t\t\tcuirpm |= 0x80 >> chp;\n\treturn cuirpm;\n}\n\nstatic inline __u8 dasd_path_get_ifccpm(struct dasd_device *device)\n{\n\tint chp;\n\t__u8 ifccpm = 0x00;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (dasd_path_is_ifcc(device, chp))\n\t\t\tifccpm |= 0x80 >> chp;\n\treturn ifccpm;\n}\n\nstatic inline __u8 dasd_path_get_hpfpm(struct dasd_device *device)\n{\n\tint chp;\n\t__u8 hpfpm = 0x00;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (dasd_path_is_nohpf(device, chp))\n\t\t\thpfpm |= 0x80 >> chp;\n\treturn hpfpm;\n}\n\nstatic inline u8 dasd_path_get_fcs_path(struct dasd_device *device, int chp)\n{\n\treturn device->path[chp].fc_security;\n}\n\nstatic inline int dasd_path_get_fcs_device(struct dasd_device *device)\n{\n\tu8 fc_sec = 0;\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++) {\n\t\tif (device->opm & (0x80 >> chp)) {\n\t\t\tfc_sec = device->path[chp].fc_security;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (; chp < 8; chp++) {\n\t\tif (device->opm & (0x80 >> chp))\n\t\t\tif (device->path[chp].fc_security != fc_sec)\n\t\t\t\treturn -EINVAL;\n\t}\n\n\treturn fc_sec;\n}\n\n \nstatic inline void dasd_path_add_tbvpm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_verify(device, chp);\n}\n\nstatic inline __u8 dasd_path_get_notoperpm(struct dasd_device *device)\n{\n\tint chp;\n\t__u8 nopm = 0x00;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (dasd_path_is_nohpf(device, chp) ||\n\t\t    dasd_path_is_ifcc(device, chp) ||\n\t\t    dasd_path_is_cuir(device, chp) ||\n\t\t    dasd_path_is_miscabled(device, chp))\n\t\t\tnopm |= 0x80 >> chp;\n\treturn nopm;\n}\n\nstatic inline void dasd_path_add_opm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp)) {\n\t\t\tdasd_path_operational(device, chp);\n\t\t\t \n\t\t\tdasd_path_clear_nohpf(device, chp);\n\t\t\tdasd_path_clear_cuir(device, chp);\n\t\t\tdasd_path_clear_cable(device, chp);\n\t\t\tdasd_path_clear_ifcc(device, chp);\n\t\t}\n}\n\nstatic inline void dasd_path_add_cablepm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_miscabled(device, chp);\n}\n\nstatic inline void dasd_path_add_cuirpm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_cuir(device, chp);\n}\n\nstatic inline void dasd_path_add_ifccpm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_ifcc(device, chp);\n}\n\nstatic inline void dasd_path_add_nppm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_nonpreferred(device, chp);\n}\n\nstatic inline void dasd_path_add_nohpfpm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_nohpf(device, chp);\n}\n\nstatic inline void dasd_path_add_ppm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_preferred(device, chp);\n}\n\nstatic inline void dasd_path_add_fcsecpm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_fcsec(device, chp);\n}\n\n \nstatic inline void dasd_path_set_tbvpm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_verify(device, chp);\n\t\telse\n\t\t\tdasd_path_clear_verify(device, chp);\n}\n\nstatic inline void dasd_path_set_opm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++) {\n\t\tdasd_path_clear_oper(device, chp);\n\t\tif (pm & (0x80 >> chp)) {\n\t\t\tdasd_path_operational(device, chp);\n\t\t\t \n\t\t\tdasd_path_clear_nohpf(device, chp);\n\t\t\tdasd_path_clear_cuir(device, chp);\n\t\t\tdasd_path_clear_cable(device, chp);\n\t\t\tdasd_path_clear_ifcc(device, chp);\n\t\t}\n\t}\n}\n\n \nstatic inline void dasd_path_remove_opm(struct dasd_device *device, __u8 pm)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++) {\n\t\tif (pm & (0x80 >> chp))\n\t\t\tdasd_path_clear_oper(device, chp);\n\t}\n}\n\n \nstatic inline void dasd_path_available(struct dasd_device *device, int chp)\n{\n\tdasd_path_clear_oper(device, chp);\n\tdasd_path_verify(device, chp);\n}\n\nstatic inline void dasd_path_notoper(struct dasd_device *device, int chp)\n{\n\tdasd_path_clear_oper(device, chp);\n\tdasd_path_clear_preferred(device, chp);\n\tdasd_path_clear_nonpreferred(device, chp);\n}\n\nstatic inline void dasd_path_fcsec_update(struct dasd_device *device, int chp)\n{\n\tdasd_path_fcsec(device, chp);\n}\n\n \nstatic inline void dasd_path_no_path(struct dasd_device *device)\n{\n\tint chp;\n\n\tfor (chp = 0; chp < 8; chp++)\n\t\tdasd_path_notoper(device, chp);\n\n\tdasd_path_clear_all_verify(device);\n}\n\n \n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}