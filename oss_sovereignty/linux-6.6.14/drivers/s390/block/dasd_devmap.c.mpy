{
  "module_name": "dasd_devmap.c",
  "hash_id": "b59864a73f762ddc66347e215aa8495ff4289733014f977c326ad7f0cee2d413",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_devmap.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd\"\n\n#include <linux/ctype.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <asm/debug.h>\n#include <linux/uaccess.h>\n#include <asm/ipl.h>\n\n \n#define PRINTK_HEADER \"dasd_devmap:\"\n#define DASD_MAX_PARAMS 256\n\n#include \"dasd_int.h\"\n\nstruct kmem_cache *dasd_page_cache;\nEXPORT_SYMBOL_GPL(dasd_page_cache);\n\n \nstruct dasd_devmap {\n\tstruct list_head list;\n\tchar bus_id[DASD_BUS_ID_SIZE];\n        unsigned int devindex;\n        unsigned short features;\n\tstruct dasd_device *device;\n\tstruct dasd_copy_relation *copy;\n\tunsigned int aq_mask;\n};\n\n \n\nint dasd_probeonly =  0;\t \nint dasd_autodetect = 0;\t \nint dasd_nopav = 0;\t\t \nEXPORT_SYMBOL_GPL(dasd_nopav);\nint dasd_nofcx;\t\t\t \nEXPORT_SYMBOL_GPL(dasd_nofcx);\n\n \nstatic char *dasd[DASD_MAX_PARAMS];\nmodule_param_array(dasd, charp, NULL, S_IRUGO);\n\n \nstatic DEFINE_SPINLOCK(dasd_devmap_lock);\n\n \nstatic struct list_head dasd_hashlists[256];\nint dasd_max_devindex;\n\nstatic struct dasd_devmap *dasd_add_busid(const char *, int);\n\nstatic inline int\ndasd_hash_busid(const char *bus_id)\n{\n\tint hash, i;\n\n\thash = 0;\n\tfor (i = 0; (i < DASD_BUS_ID_SIZE) && *bus_id; i++, bus_id++)\n\t\thash += *bus_id;\n\treturn hash & 0xff;\n}\n\n#ifndef MODULE\nstatic int __init dasd_call_setup(char *opt)\n{\n\tstatic int i __initdata;\n\tchar *tmp;\n\n\twhile (i < DASD_MAX_PARAMS) {\n\t\ttmp = strsep(&opt, \",\");\n\t\tif (!tmp)\n\t\t\tbreak;\n\n\t\tdasd[i++] = tmp;\n\t}\n\n\treturn 1;\n}\n\n__setup (\"dasd=\", dasd_call_setup);\n#endif\t \n\n#define\tDASD_IPLDEV\t\"ipldev\"\n\n \nstatic int dasd_busid(char *str, int *id0, int *id1, int *devno)\n{\n\tunsigned int val;\n\tchar *tok;\n\n\t \n\tif (strncmp(DASD_IPLDEV, str, strlen(DASD_IPLDEV)) == 0) {\n\t\tif (ipl_info.type != IPL_TYPE_CCW) {\n\t\t\tpr_err(\"The IPL device is not a CCW device\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*id0 = 0;\n\t\t*id1 = ipl_info.data.ccw.dev_id.ssid;\n\t\t*devno = ipl_info.data.ccw.dev_id.devno;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (!kstrtouint(str, 16, &val)) {\n\t\t*id0 = *id1 = 0;\n\t\tif (val > 0xffff)\n\t\t\treturn -EINVAL;\n\t\t*devno = val;\n\t\treturn 0;\n\t}\n\n\t \n\ttok = strsep(&str, \".\");\n\tif (kstrtouint(tok, 16, &val) || val > 0xff)\n\t\treturn -EINVAL;\n\t*id0 = val;\n\n\ttok = strsep(&str, \".\");\n\tif (kstrtouint(tok, 16, &val) || val > 0xff)\n\t\treturn -EINVAL;\n\t*id1 = val;\n\n\ttok = strsep(&str, \".\");\n\tif (kstrtouint(tok, 16, &val) || val > 0xffff)\n\t\treturn -EINVAL;\n\t*devno = val;\n\n\treturn 0;\n}\n\n \nstatic int __init dasd_feature_list(char *str)\n{\n\tint features, len, rc;\n\n\tfeatures = 0;\n\trc = 0;\n\n\tif (!str)\n\t\treturn DASD_FEATURE_DEFAULT;\n\n\twhile (1) {\n\t\tfor (len = 0;\n\t\t     str[len] && str[len] != ':' && str[len] != ')'; len++);\n\t\tif (len == 2 && !strncmp(str, \"ro\", 2))\n\t\t\tfeatures |= DASD_FEATURE_READONLY;\n\t\telse if (len == 4 && !strncmp(str, \"diag\", 4))\n\t\t\tfeatures |= DASD_FEATURE_USEDIAG;\n\t\telse if (len == 3 && !strncmp(str, \"raw\", 3))\n\t\t\tfeatures |= DASD_FEATURE_USERAW;\n\t\telse if (len == 6 && !strncmp(str, \"erplog\", 6))\n\t\t\tfeatures |= DASD_FEATURE_ERPLOG;\n\t\telse if (len == 8 && !strncmp(str, \"failfast\", 8))\n\t\t\tfeatures |= DASD_FEATURE_FAILFAST;\n\t\telse {\n\t\t\tpr_warn(\"%.*s is not a supported device option\\n\",\n\t\t\t\tlen, str);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tstr += len;\n\t\tif (*str != ':')\n\t\t\tbreak;\n\t\tstr++;\n\t}\n\n\treturn rc ? : features;\n}\n\n \nstatic int __init dasd_parse_keyword(char *keyword)\n{\n\tint length = strlen(keyword);\n\n\tif (strncmp(\"autodetect\", keyword, length) == 0) {\n\t\tdasd_autodetect = 1;\n\t\tpr_info(\"The autodetection mode has been activated\\n\");\n\t\treturn 0;\n        }\n\tif (strncmp(\"probeonly\", keyword, length) == 0) {\n\t\tdasd_probeonly = 1;\n\t\tpr_info(\"The probeonly mode has been activated\\n\");\n\t\treturn 0;\n        }\n\tif (strncmp(\"nopav\", keyword, length) == 0) {\n\t\tif (MACHINE_IS_VM)\n\t\t\tpr_info(\"'nopav' is not supported on z/VM\\n\");\n\t\telse {\n\t\t\tdasd_nopav = 1;\n\t\t\tpr_info(\"PAV support has be deactivated\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\tif (strncmp(\"nofcx\", keyword, length) == 0) {\n\t\tdasd_nofcx = 1;\n\t\tpr_info(\"High Performance FICON support has been \"\n\t\t\t\"deactivated\\n\");\n\t\treturn 0;\n\t}\n\tif (strncmp(\"fixedbuffers\", keyword, length) == 0) {\n\t\tif (dasd_page_cache)\n\t\t\treturn 0;\n\t\tdasd_page_cache =\n\t\t\tkmem_cache_create(\"dasd_page_cache\", PAGE_SIZE,\n\t\t\t\t\t  PAGE_SIZE, SLAB_CACHE_DMA,\n\t\t\t\t\t  NULL);\n\t\tif (!dasd_page_cache)\n\t\t\tDBF_EVENT(DBF_WARNING, \"%s\", \"Failed to create slab, \"\n\t\t\t\t\"fixed buffer mode disabled.\");\n\t\telse\n\t\t\tDBF_EVENT(DBF_INFO, \"%s\",\n\t\t\t\t \"turning on fixed buffer mode\");\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int __init dasd_evaluate_range_param(char *range, char **from_str,\n\t\t\t\t\t    char **to_str, char **features_str)\n{\n\tint rc = 0;\n\n\t \n\tif (strchr(range, '-')) {\n\t\t*from_str = strsep(&range, \"-\");\n\t\t*to_str = strsep(&range, \"(\");\n\t\t*features_str = strsep(&range, \")\");\n\t} else {\n\t\t*from_str = strsep(&range, \"(\");\n\t\t*features_str = strsep(&range, \")\");\n\t}\n\n\tif (*features_str && !range) {\n\t\tpr_warn(\"A closing parenthesis ')' is missing in the dasd= parameter\\n\");\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int __init dasd_parse_range(const char *range)\n{\n\tstruct dasd_devmap *devmap;\n\tint from, from_id0, from_id1;\n\tint to, to_id0, to_id1;\n\tint features;\n\tchar bus_id[DASD_BUS_ID_SIZE + 1];\n\tchar *features_str = NULL;\n\tchar *from_str = NULL;\n\tchar *to_str = NULL;\n\tint rc = 0;\n\tchar *tmp;\n\n\ttmp = kstrdup(range, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tif (dasd_evaluate_range_param(tmp, &from_str, &to_str, &features_str)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (dasd_busid(from_str, &from_id0, &from_id1, &from)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tto = from;\n\tto_id0 = from_id0;\n\tto_id1 = from_id1;\n\tif (to_str) {\n\t\tif (dasd_busid(to_str, &to_id0, &to_id1, &to)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (from_id0 != to_id0 || from_id1 != to_id1 || from > to) {\n\t\t\tpr_err(\"%s is not a valid device range\\n\", range);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfeatures = dasd_feature_list(features_str);\n\tif (features < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tfeatures |= DASD_FEATURE_INITIAL_ONLINE;\n\twhile (from <= to) {\n\t\tsprintf(bus_id, \"%01x.%01x.%04x\", from_id0, from_id1, from++);\n\t\tdevmap = dasd_add_busid(bus_id, features);\n\t\tif (IS_ERR(devmap)) {\n\t\t\trc = PTR_ERR(devmap);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tkfree(tmp);\n\n\treturn rc;\n}\n\n \nint __init dasd_parse(void)\n{\n\tint rc, i;\n\tchar *cur;\n\n\trc = 0;\n\tfor (i = 0; i < DASD_MAX_PARAMS; i++) {\n\t\tcur = dasd[i];\n\t\tif (!cur)\n\t\t\tbreak;\n\t\tif (*cur == '\\0')\n\t\t\tcontinue;\n\n\t\trc = dasd_parse_keyword(cur);\n\t\tif (rc)\n\t\t\trc = dasd_parse_range(cur);\n\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic struct dasd_devmap *\ndasd_add_busid(const char *bus_id, int features)\n{\n\tstruct dasd_devmap *devmap, *new, *tmp;\n\tint hash;\n\n\tnew = kzalloc(sizeof(struct dasd_devmap), GFP_KERNEL);\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\tspin_lock(&dasd_devmap_lock);\n\tdevmap = NULL;\n\thash = dasd_hash_busid(bus_id);\n\tlist_for_each_entry(tmp, &dasd_hashlists[hash], list)\n\t\tif (strncmp(tmp->bus_id, bus_id, DASD_BUS_ID_SIZE) == 0) {\n\t\t\tdevmap = tmp;\n\t\t\tbreak;\n\t\t}\n\tif (!devmap) {\n\t\t \n\t\tnew->devindex = dasd_max_devindex++;\n\t\tstrscpy(new->bus_id, bus_id, DASD_BUS_ID_SIZE);\n\t\tnew->features = features;\n\t\tnew->device = NULL;\n\t\tlist_add(&new->list, &dasd_hashlists[hash]);\n\t\tdevmap = new;\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&dasd_devmap_lock);\n\tkfree(new);\n\treturn devmap;\n}\n\nstatic struct dasd_devmap *\ndasd_find_busid_locked(const char *bus_id)\n{\n\tstruct dasd_devmap *devmap, *tmp;\n\tint hash;\n\n\tdevmap = ERR_PTR(-ENODEV);\n\thash = dasd_hash_busid(bus_id);\n\tlist_for_each_entry(tmp, &dasd_hashlists[hash], list) {\n\t\tif (strncmp(tmp->bus_id, bus_id, DASD_BUS_ID_SIZE) == 0) {\n\t\t\tdevmap = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn devmap;\n}\n\n \nstatic struct dasd_devmap *\ndasd_find_busid(const char *bus_id)\n{\n\tstruct dasd_devmap *devmap;\n\n\tspin_lock(&dasd_devmap_lock);\n\tdevmap = dasd_find_busid_locked(bus_id);\n\tspin_unlock(&dasd_devmap_lock);\n\treturn devmap;\n}\n\n \nint\ndasd_busid_known(const char *bus_id)\n{\n\treturn IS_ERR(dasd_find_busid(bus_id)) ? -ENOENT : 0;\n}\n\n \nstatic void\ndasd_forget_ranges(void)\n{\n\tstruct dasd_devmap *devmap, *n;\n\tint i;\n\n\tspin_lock(&dasd_devmap_lock);\n\tfor (i = 0; i < 256; i++) {\n\t\tlist_for_each_entry_safe(devmap, n, &dasd_hashlists[i], list) {\n\t\t\tBUG_ON(devmap->device != NULL);\n\t\t\tlist_del(&devmap->list);\n\t\t\tkfree(devmap);\n\t\t}\n\t}\n\tspin_unlock(&dasd_devmap_lock);\n}\n\n \nstruct dasd_device *\ndasd_device_from_devindex(int devindex)\n{\n\tstruct dasd_devmap *devmap, *tmp;\n\tstruct dasd_device *device;\n\tint i;\n\n\tspin_lock(&dasd_devmap_lock);\n\tdevmap = NULL;\n\tfor (i = 0; (i < 256) && !devmap; i++)\n\t\tlist_for_each_entry(tmp, &dasd_hashlists[i], list)\n\t\t\tif (tmp->devindex == devindex) {\n\t\t\t\t \n\t\t\t\tdevmap = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\tif (devmap && devmap->device) {\n\t\tdevice = devmap->device;\n\t\tdasd_get_device(device);\n\t} else\n\t\tdevice = ERR_PTR(-ENODEV);\n\tspin_unlock(&dasd_devmap_lock);\n\treturn device;\n}\n\n \nstatic struct dasd_devmap *\ndasd_devmap_from_cdev(struct ccw_device *cdev)\n{\n\tstruct dasd_devmap *devmap;\n\n\tdevmap = dasd_find_busid(dev_name(&cdev->dev));\n\tif (IS_ERR(devmap))\n\t\tdevmap = dasd_add_busid(dev_name(&cdev->dev),\n\t\t\t\t\tDASD_FEATURE_DEFAULT);\n\treturn devmap;\n}\n\n \nstruct dasd_device *\ndasd_create_device(struct ccw_device *cdev)\n{\n\tstruct dasd_devmap *devmap;\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\tint rc;\n\n\tdevmap = dasd_devmap_from_cdev(cdev);\n\tif (IS_ERR(devmap))\n\t\treturn (void *) devmap;\n\n\tdevice = dasd_alloc_device();\n\tif (IS_ERR(device))\n\t\treturn device;\n\tatomic_set(&device->ref_count, 3);\n\n\tspin_lock(&dasd_devmap_lock);\n\tif (!devmap->device) {\n\t\tdevmap->device = device;\n\t\tdevice->devindex = devmap->devindex;\n\t\tdevice->features = devmap->features;\n\t\tget_device(&cdev->dev);\n\t\tdevice->cdev = cdev;\n\t\trc = 0;\n\t} else\n\t\t \n\t\trc = -EBUSY;\n\tspin_unlock(&dasd_devmap_lock);\n\n\tif (rc) {\n\t\tdasd_free_device(device);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tdev_set_drvdata(&cdev->dev, device);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\n\tdevice->paths_info = kset_create_and_add(\"paths_info\", NULL,\n\t\t\t\t\t\t &device->cdev->dev.kobj);\n\tif (!device->paths_info)\n\t\tdev_warn(&cdev->dev, \"Could not create paths_info kset\\n\");\n\n\treturn device;\n}\n\n \nstatic int dasd_devmap_get_pprc_status(struct dasd_device *device,\n\t\t\t\t       struct dasd_pprc_data_sc4 **data)\n{\n\tstruct dasd_pprc_data_sc4 *temp;\n\n\tif (!device->discipline || !device->discipline->pprc_status) {\n\t\tdev_warn(&device->cdev->dev, \"Unable to query copy relation status\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\ttemp = kzalloc(sizeof(*temp), GFP_KERNEL);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\t \n\tif (device->discipline->pprc_status(device, temp)) {\n\t\tdev_warn(&device->cdev->dev, \"Error during copy relation status query\\n\");\n\t\tkfree(temp);\n\t\treturn -EINVAL;\n\t}\n\t*data = temp;\n\n\treturn 0;\n}\n\n \nstatic int dasd_devmap_entry_from_pprc_data(struct dasd_pprc_data_sc4 *data,\n\t\t\t\t\t    struct dasd_uid uid,\n\t\t\t\t\t    bool primary)\n{\n\tint i;\n\n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (primary) {\n\t\t\tif (data->dev_info[i].prim_cu_ssid == uid.ssid &&\n\t\t\t    data->dev_info[i].primary == uid.real_unit_addr)\n\t\t\t\treturn i;\n\t\t} else {\n\t\t\tif (data->dev_info[i].sec_cu_ssid == uid.ssid &&\n\t\t\t    data->dev_info[i].secondary == uid.real_unit_addr)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n \nstatic int dasd_devmap_check_copy_relation(struct dasd_device *device,\n\t\t\t\t\t   struct dasd_copy_entry *entry,\n\t\t\t\t\t   struct dasd_pprc_data_sc4 *data,\n\t\t\t\t\t   struct dasd_copy_relation *copy)\n{\n\tstruct dasd_pprc_data_sc4 *tmp_dat;\n\tstruct dasd_device *tmp_dev;\n\tstruct dasd_uid uid;\n\tint i, j;\n\n\tif (!device->discipline || !device->discipline->get_uid ||\n\t    device->discipline->get_uid(device, &uid))\n\t\treturn 1;\n\n\ti = dasd_devmap_entry_from_pprc_data(data, uid, entry->primary);\n\tif (i < 0) {\n\t\tdev_warn(&device->cdev->dev, \"Device not part of a copy relation\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (entry->primary) {\n\t\tif (data->dev_info[i].flags & 0x80) {\n\t\t\tdev_warn(&device->cdev->dev, \"Copy pair secondary is setup as primary\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (data->dev_info[i].prim_cu_ssid != uid.ssid ||\n\t\t    data->dev_info[i].primary != uid.real_unit_addr) {\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"Primary device %s does not match copy pair status primary device %04x\\n\",\n\t\t\t\t dev_name(&device->cdev->dev),\n\t\t\t\t data->dev_info[i].prim_cu_ssid |\n\t\t\t\t data->dev_info[i].primary);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (!(data->dev_info[i].flags & 0x80)) {\n\t\t\tdev_warn(&device->cdev->dev, \"Copy pair primary is setup as secondary\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (data->dev_info[i].sec_cu_ssid != uid.ssid ||\n\t\t    data->dev_info[i].secondary != uid.real_unit_addr) {\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"Secondary device %s does not match copy pair status secondary device %04x\\n\",\n\t\t\t\t dev_name(&device->cdev->dev),\n\t\t\t\t data->dev_info[i].sec_cu_ssid |\n\t\t\t\t data->dev_info[i].secondary);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tfor (j = 0; j < DASD_CP_ENTRIES; j++) {\n\t\tif (entry == &copy->entry[j])\n\t\t\ttmp_dev = device;\n\t\telse\n\t\t\ttmp_dev = copy->entry[j].device;\n\n\t\tif (!tmp_dev)\n\t\t\tcontinue;\n\n\t\tif (dasd_devmap_get_pprc_status(tmp_dev, &tmp_dat))\n\t\t\treturn 1;\n\n\t\tif (dasd_devmap_entry_from_pprc_data(tmp_dat, uid, entry->primary) < 0) {\n\t\t\tdev_warn(&tmp_dev->cdev->dev,\n\t\t\t\t \"Copy pair relation does not contain device: %s\\n\",\n\t\t\t\t dev_name(&device->cdev->dev));\n\t\t\tkfree(tmp_dat);\n\t\t\treturn 1;\n\t\t}\n\t\tkfree(tmp_dat);\n\t}\n\treturn 0;\n}\n\n \nstatic void dasd_devmap_delete_copy_relation_device(struct dasd_device *device)\n{\n\tstruct dasd_copy_relation *copy;\n\tint i;\n\n\tif (!device->copy)\n\t\treturn;\n\n\tcopy = device->copy;\n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (copy->entry[i].device == device)\n\t\t\tcopy->entry[i].device = NULL;\n\t}\n\tdasd_put_device(device);\n\tdevice->copy = NULL;\n}\n\n \nint dasd_devmap_set_device_copy_relation(struct ccw_device *cdev,\n\t\t\t\t\t bool pprc_enabled)\n{\n\tstruct dasd_pprc_data_sc4 *data = NULL;\n\tstruct dasd_copy_entry *entry = NULL;\n\tstruct dasd_copy_relation *copy;\n\tstruct dasd_devmap *devmap;\n\tstruct dasd_device *device;\n\tint i, rc = 0;\n\n\tdevmap = dasd_devmap_from_cdev(cdev);\n\tif (IS_ERR(devmap))\n\t\treturn PTR_ERR(devmap);\n\n\tdevice = devmap->device;\n\tif (!device)\n\t\treturn -ENODEV;\n\n\tcopy = devmap->copy;\n\t \n\tif (!copy)\n\t\tgoto out;\n\n\trc = dasd_devmap_get_pprc_status(device, &data);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (!pprc_enabled) {\n\t\tdev_err(&cdev->dev, \"Copy relation not enabled on storage server\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!data->dev_info[0].state) {\n\t\tdev_warn(&device->cdev->dev, \"Copy pair setup requested for device not in copy relation\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (copy->entry[i].configured &&\n\t\t    strncmp(dev_name(&cdev->dev),\n\t\t\t    copy->entry[i].busid, DASD_BUS_ID_SIZE) == 0) {\n\t\t\tentry = &copy->entry[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!entry) {\n\t\tdev_warn(&device->cdev->dev, \"Copy relation entry not found\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tif (dasd_devmap_check_copy_relation(device, entry, data, copy)) {\n\t\tdev_warn(&device->cdev->dev, \"Copy relation faulty\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdasd_get_device(device);\n\tcopy->entry[i].device = device;\n\tdevice->copy = copy;\nout:\n\tkfree(data);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(dasd_devmap_set_device_copy_relation);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(dasd_delete_wq);\n\n \nvoid\ndasd_delete_device(struct dasd_device *device)\n{\n\tstruct ccw_device *cdev;\n\tstruct dasd_devmap *devmap;\n\tunsigned long flags;\n\n\t \n\tdevmap = dasd_find_busid(dev_name(&device->cdev->dev));\n\tBUG_ON(IS_ERR(devmap));\n\tspin_lock(&dasd_devmap_lock);\n\tif (devmap->device != device) {\n\t\tspin_unlock(&dasd_devmap_lock);\n\t\tdasd_put_device(device);\n\t\treturn;\n\t}\n\tdevmap->device = NULL;\n\tspin_unlock(&dasd_devmap_lock);\n\n\t \n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tdev_set_drvdata(&device->cdev->dev, NULL);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\n\t \n\tdasd_devmap_delete_copy_relation_device(device);\n\t \n\tatomic_sub(3, &device->ref_count);\n\n\t \n\twait_event(dasd_delete_wq, atomic_read(&device->ref_count) == 0);\n\n\tdasd_generic_free_discipline(device);\n\n\tkset_unregister(device->paths_info);\n\n\t \n\tcdev = device->cdev;\n\tdevice->cdev = NULL;\n\n\t \n\tput_device(&cdev->dev);\n\n\t \n\tdasd_free_device(device);\n}\n\n \nvoid\ndasd_put_device_wake(struct dasd_device *device)\n{\n\twake_up(&dasd_delete_wq);\n}\nEXPORT_SYMBOL_GPL(dasd_put_device_wake);\n\n \nstruct dasd_device *\ndasd_device_from_cdev_locked(struct ccw_device *cdev)\n{\n\tstruct dasd_device *device = dev_get_drvdata(&cdev->dev);\n\n\tif (!device)\n\t\treturn ERR_PTR(-ENODEV);\n\tdasd_get_device(device);\n\treturn device;\n}\n\n \nstruct dasd_device *\ndasd_device_from_cdev(struct ccw_device *cdev)\n{\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tdevice = dasd_device_from_cdev_locked(cdev);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\treturn device;\n}\n\nvoid dasd_add_link_to_gendisk(struct gendisk *gdp, struct dasd_device *device)\n{\n\tstruct dasd_devmap *devmap;\n\n\tdevmap = dasd_find_busid(dev_name(&device->cdev->dev));\n\tif (IS_ERR(devmap))\n\t\treturn;\n\tspin_lock(&dasd_devmap_lock);\n\tgdp->private_data = devmap;\n\tspin_unlock(&dasd_devmap_lock);\n}\nEXPORT_SYMBOL(dasd_add_link_to_gendisk);\n\nstruct dasd_device *dasd_device_from_gendisk(struct gendisk *gdp)\n{\n\tstruct dasd_device *device;\n\tstruct dasd_devmap *devmap;\n\n\tif (!gdp->private_data)\n\t\treturn NULL;\n\tdevice = NULL;\n\tspin_lock(&dasd_devmap_lock);\n\tdevmap = gdp->private_data;\n\tif (devmap && devmap->device) {\n\t\tdevice = devmap->device;\n\t\tdasd_get_device(device);\n\t}\n\tspin_unlock(&dasd_devmap_lock);\n\treturn device;\n}\n\n \n\n \nstatic ssize_t dasd_ff_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tint ff_flag;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (!IS_ERR(devmap))\n\t\tff_flag = (devmap->features & DASD_FEATURE_FAILFAST) != 0;\n\telse\n\t\tff_flag = (DASD_FEATURE_DEFAULT & DASD_FEATURE_FAILFAST) != 0;\n\treturn sysfs_emit(buf, ff_flag ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t dasd_ff_store(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tunsigned int val;\n\tint rc;\n\n\tif (kstrtouint(buf, 0, &val) || val > 1)\n\t\treturn -EINVAL;\n\n\trc = dasd_set_feature(to_ccwdev(dev), DASD_FEATURE_FAILFAST, val);\n\n\treturn rc ? : count;\n}\n\nstatic DEVICE_ATTR(failfast, 0644, dasd_ff_show, dasd_ff_store);\n\n \nstatic ssize_t\ndasd_ro_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tstruct dasd_device *device;\n\tint ro_flag = 0;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (IS_ERR(devmap))\n\t\tgoto out;\n\n\tro_flag = !!(devmap->features & DASD_FEATURE_READONLY);\n\n\tspin_lock(&dasd_devmap_lock);\n\tdevice = devmap->device;\n\tif (device)\n\t\tro_flag |= test_bit(DASD_FLAG_DEVICE_RO, &device->flags);\n\tspin_unlock(&dasd_devmap_lock);\n\nout:\n\treturn sysfs_emit(buf, ro_flag ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t\ndasd_ro_store(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\tunsigned int val;\n\tint rc;\n\n\tif (kstrtouint(buf, 0, &val) || val > 1)\n\t\treturn -EINVAL;\n\n\trc = dasd_set_feature(cdev, DASD_FEATURE_READONLY, val);\n\tif (rc)\n\t\treturn rc;\n\n\tdevice = dasd_device_from_cdev(cdev);\n\tif (IS_ERR(device))\n\t\treturn count;\n\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tval = val || test_bit(DASD_FLAG_DEVICE_RO, &device->flags);\n\n\tif (!device->block || !device->block->gdp ||\n\t    test_bit(DASD_FLAG_OFFLINE, &device->flags)) {\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\t\tgoto out;\n\t}\n\t \n\tatomic_inc(&device->block->open_count);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\n\tset_disk_ro(device->block->gdp, val);\n\tatomic_dec(&device->block->open_count);\n\nout:\n\tdasd_put_device(device);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(readonly, 0644, dasd_ro_show, dasd_ro_store);\n \nstatic ssize_t\ndasd_erplog_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tint erplog;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (!IS_ERR(devmap))\n\t\terplog = (devmap->features & DASD_FEATURE_ERPLOG) != 0;\n\telse\n\t\terplog = (DASD_FEATURE_DEFAULT & DASD_FEATURE_ERPLOG) != 0;\n\treturn sysfs_emit(buf, erplog ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t\ndasd_erplog_store(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tunsigned int val;\n\tint rc;\n\n\tif (kstrtouint(buf, 0, &val) || val > 1)\n\t\treturn -EINVAL;\n\n\trc = dasd_set_feature(to_ccwdev(dev), DASD_FEATURE_ERPLOG, val);\n\n\treturn rc ? : count;\n}\n\nstatic DEVICE_ATTR(erplog, 0644, dasd_erplog_show, dasd_erplog_store);\n\n \nstatic ssize_t\ndasd_use_diag_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tint use_diag;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (!IS_ERR(devmap))\n\t\tuse_diag = (devmap->features & DASD_FEATURE_USEDIAG) != 0;\n\telse\n\t\tuse_diag = (DASD_FEATURE_DEFAULT & DASD_FEATURE_USEDIAG) != 0;\n\treturn sprintf(buf, use_diag ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t\ndasd_use_diag_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct dasd_devmap *devmap;\n\tunsigned int val;\n\tssize_t rc;\n\n\tdevmap = dasd_devmap_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(devmap))\n\t\treturn PTR_ERR(devmap);\n\n\tif (kstrtouint(buf, 0, &val) || val > 1)\n\t\treturn -EINVAL;\n\n\tspin_lock(&dasd_devmap_lock);\n\t \n\trc = count;\n\tif (!devmap->device && !(devmap->features & DASD_FEATURE_USERAW)) {\n\t\tif (val)\n\t\t\tdevmap->features |= DASD_FEATURE_USEDIAG;\n\t\telse\n\t\t\tdevmap->features &= ~DASD_FEATURE_USEDIAG;\n\t} else\n\t\trc = -EPERM;\n\tspin_unlock(&dasd_devmap_lock);\n\treturn rc;\n}\n\nstatic DEVICE_ATTR(use_diag, 0644, dasd_use_diag_show, dasd_use_diag_store);\n\n \nstatic ssize_t\ndasd_use_raw_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tint use_raw;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (!IS_ERR(devmap))\n\t\tuse_raw = (devmap->features & DASD_FEATURE_USERAW) != 0;\n\telse\n\t\tuse_raw = (DASD_FEATURE_DEFAULT & DASD_FEATURE_USERAW) != 0;\n\treturn sprintf(buf, use_raw ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t\ndasd_use_raw_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct dasd_devmap *devmap;\n\tssize_t rc;\n\tunsigned long val;\n\n\tdevmap = dasd_devmap_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(devmap))\n\t\treturn PTR_ERR(devmap);\n\n\tif ((kstrtoul(buf, 10, &val) != 0) || val > 1)\n\t\treturn -EINVAL;\n\n\tspin_lock(&dasd_devmap_lock);\n\t \n\trc = count;\n\tif (!devmap->device && !(devmap->features & DASD_FEATURE_USEDIAG)) {\n\t\tif (val)\n\t\t\tdevmap->features |= DASD_FEATURE_USERAW;\n\t\telse\n\t\t\tdevmap->features &= ~DASD_FEATURE_USERAW;\n\t} else\n\t\trc = -EPERM;\n\tspin_unlock(&dasd_devmap_lock);\n\treturn rc;\n}\n\nstatic DEVICE_ATTR(raw_track_access, 0644, dasd_use_raw_show,\n\t\t   dasd_use_raw_store);\n\nstatic ssize_t\ndasd_safe_offline_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tdevice = dasd_device_from_cdev_locked(cdev);\n\tif (IS_ERR(device)) {\n\t\trc = PTR_ERR(device);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\t\tgoto out;\n\t}\n\n\tif (test_bit(DASD_FLAG_OFFLINE, &device->flags) ||\n\t    test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\n\t\t \n\t\tdasd_put_device(device);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tset_bit(DASD_FLAG_SAFE_OFFLINE, &device->flags);\n\tdasd_put_device(device);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\n\trc = ccw_device_set_offline(cdev);\n\nout:\n\treturn rc ? rc : count;\n}\n\nstatic DEVICE_ATTR(safe_offline, 0200, NULL, dasd_safe_offline_store);\n\nstatic ssize_t\ndasd_access_show(struct device *dev, struct device_attribute *attr,\n\t\t char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct dasd_device *device;\n\tint count;\n\n\tdevice = dasd_device_from_cdev(cdev);\n\tif (IS_ERR(device))\n\t\treturn PTR_ERR(device);\n\n\tif (!device->discipline)\n\t\tcount = -ENODEV;\n\telse if (!device->discipline->host_access_count)\n\t\tcount = -EOPNOTSUPP;\n\telse\n\t\tcount = device->discipline->host_access_count(device);\n\n\tdasd_put_device(device);\n\tif (count < 0)\n\t\treturn count;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}\n\nstatic DEVICE_ATTR(host_access_count, 0444, dasd_access_show, NULL);\n\nstatic ssize_t\ndasd_discipline_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct dasd_device *device;\n\tssize_t len;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\tgoto out;\n\telse if (!device->discipline) {\n\t\tdasd_put_device(device);\n\t\tgoto out;\n\t} else {\n\t\tlen = sysfs_emit(buf, \"%s\\n\",\n\t\t\t\t device->discipline->name);\n\t\tdasd_put_device(device);\n\t\treturn len;\n\t}\nout:\n\tlen = sysfs_emit(buf, \"none\\n\");\n\treturn len;\n}\n\nstatic DEVICE_ATTR(discipline, 0444, dasd_discipline_show, NULL);\n\nstatic ssize_t\ndasd_device_status_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct dasd_device *device;\n\tssize_t len;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (!IS_ERR(device)) {\n\t\tswitch (device->state) {\n\t\tcase DASD_STATE_NEW:\n\t\t\tlen = sysfs_emit(buf, \"new\\n\");\n\t\t\tbreak;\n\t\tcase DASD_STATE_KNOWN:\n\t\t\tlen = sysfs_emit(buf, \"detected\\n\");\n\t\t\tbreak;\n\t\tcase DASD_STATE_BASIC:\n\t\t\tlen = sysfs_emit(buf, \"basic\\n\");\n\t\t\tbreak;\n\t\tcase DASD_STATE_UNFMT:\n\t\t\tlen = sysfs_emit(buf, \"unformatted\\n\");\n\t\t\tbreak;\n\t\tcase DASD_STATE_READY:\n\t\t\tlen = sysfs_emit(buf, \"ready\\n\");\n\t\t\tbreak;\n\t\tcase DASD_STATE_ONLINE:\n\t\t\tlen = sysfs_emit(buf, \"online\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen = sysfs_emit(buf, \"no stat\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tdasd_put_device(device);\n\t} else\n\t\tlen = sysfs_emit(buf, \"unknown\\n\");\n\treturn len;\n}\n\nstatic DEVICE_ATTR(status, 0444, dasd_device_status_show, NULL);\n\nstatic ssize_t dasd_alias_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_device *device;\n\tstruct dasd_uid uid;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn sprintf(buf, \"0\\n\");\n\n\tif (device->discipline && device->discipline->get_uid &&\n\t    !device->discipline->get_uid(device, &uid)) {\n\t\tif (uid.type == UA_BASE_PAV_ALIAS ||\n\t\t    uid.type == UA_HYPER_PAV_ALIAS) {\n\t\t\tdasd_put_device(device);\n\t\t\treturn sprintf(buf, \"1\\n\");\n\t\t}\n\t}\n\tdasd_put_device(device);\n\n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic DEVICE_ATTR(alias, 0444, dasd_alias_show, NULL);\n\nstatic ssize_t dasd_vendor_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dasd_device *device;\n\tstruct dasd_uid uid;\n\tchar *vendor;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tvendor = \"\";\n\tif (IS_ERR(device))\n\t\treturn sysfs_emit(buf, \"%s\\n\", vendor);\n\n\tif (device->discipline && device->discipline->get_uid &&\n\t    !device->discipline->get_uid(device, &uid))\n\t\t\tvendor = uid.vendor;\n\n\tdasd_put_device(device);\n\n\treturn sysfs_emit(buf, \"%s\\n\", vendor);\n}\n\nstatic DEVICE_ATTR(vendor, 0444, dasd_vendor_show, NULL);\n\nstatic ssize_t\ndasd_uid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tchar uid_string[DASD_UID_STRLEN];\n\tstruct dasd_device *device;\n\tstruct dasd_uid uid;\n\tchar ua_string[3];\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tuid_string[0] = 0;\n\tif (IS_ERR(device))\n\t\treturn sysfs_emit(buf, \"%s\\n\", uid_string);\n\n\tif (device->discipline && device->discipline->get_uid &&\n\t    !device->discipline->get_uid(device, &uid)) {\n\t\tswitch (uid.type) {\n\t\tcase UA_BASE_DEVICE:\n\t\t\tsnprintf(ua_string, sizeof(ua_string), \"%02x\",\n\t\t\t\t uid.real_unit_addr);\n\t\t\tbreak;\n\t\tcase UA_BASE_PAV_ALIAS:\n\t\t\tsnprintf(ua_string, sizeof(ua_string), \"%02x\",\n\t\t\t\t uid.base_unit_addr);\n\t\t\tbreak;\n\t\tcase UA_HYPER_PAV_ALIAS:\n\t\t\tsnprintf(ua_string, sizeof(ua_string), \"xx\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tsnprintf(ua_string, sizeof(ua_string), \"%02x\",\n\t\t\t\t uid.real_unit_addr);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strlen(uid.vduit) > 0)\n\t\t\tsnprintf(uid_string, sizeof(uid_string),\n\t\t\t\t \"%s.%s.%04x.%s.%s\",\n\t\t\t\t uid.vendor, uid.serial, uid.ssid, ua_string,\n\t\t\t\t uid.vduit);\n\t\telse\n\t\t\tsnprintf(uid_string, sizeof(uid_string),\n\t\t\t\t \"%s.%s.%04x.%s\",\n\t\t\t\t uid.vendor, uid.serial, uid.ssid, ua_string);\n\t}\n\tdasd_put_device(device);\n\n\treturn sysfs_emit(buf, \"%s\\n\", uid_string);\n}\nstatic DEVICE_ATTR(uid, 0444, dasd_uid_show, NULL);\n\n \nstatic ssize_t\ndasd_eer_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tint eer_flag;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (!IS_ERR(devmap) && devmap->device)\n\t\teer_flag = dasd_eer_enabled(devmap->device);\n\telse\n\t\teer_flag = 0;\n\treturn sysfs_emit(buf, eer_flag ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t\ndasd_eer_store(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tunsigned int val;\n\tint rc = 0;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn PTR_ERR(device);\n\n\tif (kstrtouint(buf, 0, &val) || val > 1)\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\trc = dasd_eer_enable(device);\n\telse\n\t\tdasd_eer_disable(device);\n\n\tdasd_put_device(device);\n\n\treturn rc ? : count;\n}\n\nstatic DEVICE_ATTR(eer_enabled, 0644, dasd_eer_show, dasd_eer_store);\n\n \nstatic ssize_t dasd_aq_mask_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tunsigned int aq_mask = 0;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (!IS_ERR(devmap))\n\t\taq_mask = devmap->aq_mask;\n\n\treturn sysfs_emit(buf, \"%d\\n\", aq_mask);\n}\n\nstatic ssize_t dasd_aq_mask_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct dasd_devmap *devmap;\n\tunsigned int val;\n\n\tif (kstrtouint(buf, 0, &val) || val > DASD_EER_VALID)\n\t\treturn -EINVAL;\n\n\tdevmap = dasd_devmap_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(devmap))\n\t\treturn PTR_ERR(devmap);\n\n\tspin_lock(&dasd_devmap_lock);\n\tdevmap->aq_mask = val;\n\tif (devmap->device)\n\t\tdevmap->device->aq_mask = devmap->aq_mask;\n\tspin_unlock(&dasd_devmap_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(aq_mask, 0644, dasd_aq_mask_show, dasd_aq_mask_store);\n\n \nstatic ssize_t dasd_aqr_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tint flag;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (!IS_ERR(devmap))\n\t\tflag = (devmap->features & DASD_FEATURE_REQUEUEQUIESCE) != 0;\n\telse\n\t\tflag = (DASD_FEATURE_DEFAULT &\n\t\t\tDASD_FEATURE_REQUEUEQUIESCE) != 0;\n\treturn sysfs_emit(buf, \"%d\\n\", flag);\n}\n\nstatic ssize_t dasd_aqr_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tbool val;\n\tint rc;\n\n\tif (kstrtobool(buf, &val))\n\t\treturn -EINVAL;\n\n\trc = dasd_set_feature(to_ccwdev(dev), DASD_FEATURE_REQUEUEQUIESCE, val);\n\n\treturn rc ? : count;\n}\n\nstatic DEVICE_ATTR(aq_requeue, 0644, dasd_aqr_show, dasd_aqr_store);\n\n \nstatic ssize_t\ndasd_aq_timeouts_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct dasd_device *device;\n\tint len;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tlen = sysfs_emit(buf, \"%u\\n\", device->aq_timeouts);\n\tdasd_put_device(device);\n\treturn len;\n}\n\nstatic ssize_t\ndasd_aq_timeouts_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tunsigned int val;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\n\tif ((kstrtouint(buf, 10, &val) != 0) ||\n\t    val > DASD_RETRIES_MAX || val == 0) {\n\t\tdasd_put_device(device);\n\t\treturn -EINVAL;\n\t}\n\n\tif (val)\n\t\tdevice->aq_timeouts = val;\n\n\tdasd_put_device(device);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(aq_timeouts, 0644, dasd_aq_timeouts_show,\n\t\t   dasd_aq_timeouts_store);\n\n \nstatic ssize_t\ndasd_expires_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_device *device;\n\tint len;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tlen = sysfs_emit(buf, \"%lu\\n\", device->default_expires);\n\tdasd_put_device(device);\n\treturn len;\n}\n\nstatic ssize_t\ndasd_expires_store(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tunsigned long val;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\n\tif ((kstrtoul(buf, 10, &val) != 0) ||\n\t    (val > DASD_EXPIRES_MAX) || val == 0) {\n\t\tdasd_put_device(device);\n\t\treturn -EINVAL;\n\t}\n\n\tif (val)\n\t\tdevice->default_expires = val;\n\n\tdasd_put_device(device);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(expires, 0644, dasd_expires_show, dasd_expires_store);\n\nstatic ssize_t\ndasd_retries_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_device *device;\n\tint len;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tlen = sysfs_emit(buf, \"%lu\\n\", device->default_retries);\n\tdasd_put_device(device);\n\treturn len;\n}\n\nstatic ssize_t\ndasd_retries_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tunsigned long val;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\n\tif ((kstrtoul(buf, 10, &val) != 0) ||\n\t    (val > DASD_RETRIES_MAX)) {\n\t\tdasd_put_device(device);\n\t\treturn -EINVAL;\n\t}\n\n\tif (val)\n\t\tdevice->default_retries = val;\n\n\tdasd_put_device(device);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(retries, 0644, dasd_retries_show, dasd_retries_store);\n\nstatic ssize_t\ndasd_timeout_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct dasd_device *device;\n\tint len;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tlen = sysfs_emit(buf, \"%lu\\n\", device->blk_timeout);\n\tdasd_put_device(device);\n\treturn len;\n}\n\nstatic ssize_t\ndasd_timeout_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tunsigned long val;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device) || !device->block)\n\t\treturn -ENODEV;\n\n\tif ((kstrtoul(buf, 10, &val) != 0) ||\n\t    val > UINT_MAX / HZ) {\n\t\tdasd_put_device(device);\n\t\treturn -EINVAL;\n\t}\n\tif (!device->block->gdp) {\n\t\tdasd_put_device(device);\n\t\treturn -ENODEV;\n\t}\n\n\tdevice->blk_timeout = val;\n\tblk_queue_rq_timeout(device->block->gdp->queue, val * HZ);\n\n\tdasd_put_device(device);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(timeout, 0644,\n\t\t   dasd_timeout_show, dasd_timeout_store);\n\n\nstatic ssize_t\ndasd_path_reset_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tunsigned int val;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\n\tif ((kstrtouint(buf, 16, &val) != 0) || val > 0xff)\n\t\tval = 0;\n\n\tif (device->discipline && device->discipline->reset_path)\n\t\tdevice->discipline->reset_path(device, (__u8) val);\n\n\tdasd_put_device(device);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(path_reset, 0200, NULL, dasd_path_reset_store);\n\nstatic ssize_t dasd_hpf_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct dasd_device *device;\n\tint hpf;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tif (!device->discipline || !device->discipline->hpf_enabled) {\n\t\tdasd_put_device(device);\n\t\treturn sysfs_emit(buf, \"%d\\n\", dasd_nofcx);\n\t}\n\thpf = device->discipline->hpf_enabled(device);\n\tdasd_put_device(device);\n\treturn sysfs_emit(buf, \"%d\\n\", hpf);\n}\n\nstatic DEVICE_ATTR(hpf, 0444, dasd_hpf_show, NULL);\n\nstatic ssize_t dasd_reservation_policy_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tint rc = 0;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (IS_ERR(devmap)) {\n\t\trc = sysfs_emit(buf, \"ignore\\n\");\n\t} else {\n\t\tspin_lock(&dasd_devmap_lock);\n\t\tif (devmap->features & DASD_FEATURE_FAILONSLCK)\n\t\t\trc = sysfs_emit(buf, \"fail\\n\");\n\t\telse\n\t\t\trc = sysfs_emit(buf, \"ignore\\n\");\n\t\tspin_unlock(&dasd_devmap_lock);\n\t}\n\treturn rc;\n}\n\nstatic ssize_t dasd_reservation_policy_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tint rc;\n\n\tif (sysfs_streq(\"ignore\", buf))\n\t\trc = dasd_set_feature(cdev, DASD_FEATURE_FAILONSLCK, 0);\n\telse if (sysfs_streq(\"fail\", buf))\n\t\trc = dasd_set_feature(cdev, DASD_FEATURE_FAILONSLCK, 1);\n\telse\n\t\trc = -EINVAL;\n\n\treturn rc ? : count;\n}\n\nstatic DEVICE_ATTR(reservation_policy, 0644,\n\t\t   dasd_reservation_policy_show, dasd_reservation_policy_store);\n\nstatic ssize_t dasd_reservation_state_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct dasd_device *device;\n\tint rc = 0;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn sysfs_emit(buf, \"none\\n\");\n\n\tif (test_bit(DASD_FLAG_IS_RESERVED, &device->flags))\n\t\trc = sysfs_emit(buf, \"reserved\\n\");\n\telse if (test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags))\n\t\trc = sysfs_emit(buf, \"lost\\n\");\n\telse\n\t\trc = sysfs_emit(buf, \"none\\n\");\n\tdasd_put_device(device);\n\treturn rc;\n}\n\nstatic ssize_t dasd_reservation_state_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tint rc = 0;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tif (sysfs_streq(\"reset\", buf))\n\t\tclear_bit(DASD_FLAG_LOCK_STOLEN, &device->flags);\n\telse\n\t\trc = -EINVAL;\n\tdasd_put_device(device);\n\n\tif (rc)\n\t\treturn rc;\n\telse\n\t\treturn count;\n}\n\nstatic DEVICE_ATTR(last_known_reservation_state, 0644,\n\t\t   dasd_reservation_state_show, dasd_reservation_state_store);\n\nstatic ssize_t dasd_pm_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_device *device;\n\tu8 opm, nppm, cablepm, cuirpm, hpfpm, ifccpm;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn sprintf(buf, \"0\\n\");\n\n\topm = dasd_path_get_opm(device);\n\tnppm = dasd_path_get_nppm(device);\n\tcablepm = dasd_path_get_cablepm(device);\n\tcuirpm = dasd_path_get_cuirpm(device);\n\thpfpm = dasd_path_get_hpfpm(device);\n\tifccpm = dasd_path_get_ifccpm(device);\n\tdasd_put_device(device);\n\n\treturn sprintf(buf, \"%02x %02x %02x %02x %02x %02x\\n\", opm, nppm,\n\t\t       cablepm, cuirpm, hpfpm, ifccpm);\n}\n\nstatic DEVICE_ATTR(path_masks, 0444, dasd_pm_show, NULL);\n\n \nstatic ssize_t\ndasd_path_threshold_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_device *device;\n\tint len;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tlen = sysfs_emit(buf, \"%lu\\n\", device->path_thrhld);\n\tdasd_put_device(device);\n\treturn len;\n}\n\nstatic ssize_t\ndasd_path_threshold_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\tunsigned long val;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\n\tif (kstrtoul(buf, 10, &val) != 0 || val > DASD_THRHLD_MAX) {\n\t\tdasd_put_device(device);\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_irqsave(get_ccwdev_lock(to_ccwdev(dev)), flags);\n\tdevice->path_thrhld = val;\n\tspin_unlock_irqrestore(get_ccwdev_lock(to_ccwdev(dev)), flags);\n\tdasd_put_device(device);\n\treturn count;\n}\nstatic DEVICE_ATTR(path_threshold, 0644, dasd_path_threshold_show,\n\t\t   dasd_path_threshold_store);\n\n \nstatic ssize_t\ndasd_path_autodisable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_devmap *devmap;\n\tint flag;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (!IS_ERR(devmap))\n\t\tflag = (devmap->features & DASD_FEATURE_PATH_AUTODISABLE) != 0;\n\telse\n\t\tflag = (DASD_FEATURE_DEFAULT &\n\t\t\tDASD_FEATURE_PATH_AUTODISABLE) != 0;\n\treturn sysfs_emit(buf, flag ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t\ndasd_path_autodisable_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tunsigned int val;\n\tint rc;\n\n\tif (kstrtouint(buf, 0, &val) || val > 1)\n\t\treturn -EINVAL;\n\n\trc = dasd_set_feature(to_ccwdev(dev),\n\t\t\t      DASD_FEATURE_PATH_AUTODISABLE, val);\n\n\treturn rc ? : count;\n}\n\nstatic DEVICE_ATTR(path_autodisable, 0644,\n\t\t   dasd_path_autodisable_show,\n\t\t   dasd_path_autodisable_store);\n \nstatic ssize_t\ndasd_path_interval_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct dasd_device *device;\n\tint len;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tlen = sysfs_emit(buf, \"%lu\\n\", device->path_interval);\n\tdasd_put_device(device);\n\treturn len;\n}\n\nstatic ssize_t\ndasd_path_interval_store(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\tunsigned long val;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\n\tif ((kstrtoul(buf, 10, &val) != 0) ||\n\t    (val > DASD_INTERVAL_MAX) || val == 0) {\n\t\tdasd_put_device(device);\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_irqsave(get_ccwdev_lock(to_ccwdev(dev)), flags);\n\tif (val)\n\t\tdevice->path_interval = val;\n\tspin_unlock_irqrestore(get_ccwdev_lock(to_ccwdev(dev)), flags);\n\tdasd_put_device(device);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(path_interval, 0644, dasd_path_interval_show,\n\t\t   dasd_path_interval_store);\n\nstatic ssize_t\ndasd_device_fcs_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct dasd_device *device;\n\tint fc_sec;\n\tint rc;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\tfc_sec = dasd_path_get_fcs_device(device);\n\tif (fc_sec == -EINVAL)\n\t\trc = sysfs_emit(buf, \"Inconsistent\\n\");\n\telse\n\t\trc = sysfs_emit(buf, \"%s\\n\", dasd_path_get_fcs_str(fc_sec));\n\tdasd_put_device(device);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR(fc_security, 0444, dasd_device_fcs_show, NULL);\n\nstatic ssize_t\ndasd_path_fcs_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct dasd_path *path = to_dasd_path(kobj);\n\tunsigned int fc_sec = path->fc_security;\n\n\treturn sysfs_emit(buf, \"%s\\n\", dasd_path_get_fcs_str(fc_sec));\n}\n\nstatic struct kobj_attribute path_fcs_attribute =\n\t__ATTR(fc_security, 0444, dasd_path_fcs_show, NULL);\n\n \nstatic ssize_t\ndasd_copy_pair_show(struct device *dev,\n\t\t    struct device_attribute *attr, char *buf)\n{\n\tchar prim_busid[DASD_BUS_ID_SIZE];\n\tstruct dasd_copy_relation *copy;\n\tstruct dasd_devmap *devmap;\n\tint len = 0;\n\tint i;\n\n\tdevmap = dasd_find_busid(dev_name(dev));\n\tif (IS_ERR(devmap))\n\t\treturn -ENODEV;\n\n\tif (!devmap->copy)\n\t\treturn -ENODEV;\n\n\tcopy = devmap->copy;\n\t \n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (copy->entry[i].configured && copy->entry[i].primary) {\n\t\t\tstrscpy(prim_busid, copy->entry[i].busid,\n\t\t\t\tDASD_BUS_ID_SIZE);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == DASD_CP_ENTRIES)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (copy->entry[i].configured && !copy->entry[i].primary)\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s,%s \", prim_busid,\n\t\t\t\t\t     copy->entry[i].busid);\n\t}\n\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\nout:\n\treturn len;\n}\n\nstatic int dasd_devmap_set_copy_relation(struct dasd_devmap *devmap,\n\t\t\t\t\t struct dasd_copy_relation *copy,\n\t\t\t\t\t char *busid, bool primary)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\t \n\t\tif (copy->entry[i].configured &&\n\t\t    strncmp(copy->entry[i].busid, busid, DASD_BUS_ID_SIZE) == 0)\n\t\t\treturn 0;\n\n\t\tif (!copy->entry[i].configured)\n\t\t\tbreak;\n\t}\n\tif (i == DASD_CP_ENTRIES)\n\t\treturn -EINVAL;\n\n\tcopy->entry[i].configured = true;\n\tstrscpy(copy->entry[i].busid, busid, DASD_BUS_ID_SIZE);\n\tif (primary) {\n\t\tcopy->active = &copy->entry[i];\n\t\tcopy->entry[i].primary = true;\n\t}\n\tif (!devmap->copy)\n\t\tdevmap->copy = copy;\n\n\treturn 0;\n}\n\nstatic void dasd_devmap_del_copy_relation(struct dasd_copy_relation *copy,\n\t\t\t\t\t  char *busid)\n{\n\tint i;\n\n\tspin_lock(&dasd_devmap_lock);\n\t \n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (copy->entry[i].configured &&\n\t\t    strncmp(copy->entry[i].busid, busid, DASD_BUS_ID_SIZE) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == DASD_CP_ENTRIES || !copy->entry[i].configured) {\n\t\tspin_unlock(&dasd_devmap_lock);\n\t\treturn;\n\t}\n\n\tcopy->entry[i].configured = false;\n\tmemset(copy->entry[i].busid, 0, DASD_BUS_ID_SIZE);\n\tif (copy->active == &copy->entry[i]) {\n\t\tcopy->active = NULL;\n\t\tcopy->entry[i].primary = false;\n\t}\n\tspin_unlock(&dasd_devmap_lock);\n}\n\nstatic int dasd_devmap_clear_copy_relation(struct device *dev)\n{\n\tstruct dasd_copy_relation *copy;\n\tstruct dasd_devmap *devmap;\n\tint i, rc = 1;\n\n\tdevmap = dasd_devmap_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(devmap))\n\t\treturn 1;\n\n\tspin_lock(&dasd_devmap_lock);\n\tif (!devmap->copy)\n\t\tgoto out;\n\n\tcopy = devmap->copy;\n\t \n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (!copy->entry[i].configured)\n\t\t\tcontinue;\n\n\t\tif (copy->entry[i].device == copy->active->device)\n\t\t\tcontinue;\n\n\t\tif (copy->entry[i].device)\n\t\t\tgoto out;\n\t}\n\t \n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (strlen(copy->entry[i].busid) == 0)\n\t\t\tcontinue;\n\t\tif (copy->entry[i].device) {\n\t\t\tdasd_put_device(copy->entry[i].device);\n\t\t\tcopy->entry[i].device->copy = NULL;\n\t\t\tcopy->entry[i].device = NULL;\n\t\t}\n\t\tdevmap = dasd_find_busid_locked(copy->entry[i].busid);\n\t\tdevmap->copy = NULL;\n\t\tmemset(copy->entry[i].busid, 0, DASD_BUS_ID_SIZE);\n\t}\n\tkfree(copy);\n\trc = 0;\nout:\n\tspin_unlock(&dasd_devmap_lock);\n\treturn rc;\n}\n\n \nstatic int dasd_devmap_parse_busid(const char *buf, char *prim_busid,\n\t\t\t\t   char *sec_busid)\n{\n\tchar *primary, *secondary, *tmp, *pt;\n\tint id0, id1, id2;\n\n\tpt =  kstrdup(buf, GFP_KERNEL);\n\ttmp = pt;\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tprimary = strsep(&tmp, \",\");\n\tif (!primary) {\n\t\tkfree(pt);\n\t\treturn -EINVAL;\n\t}\n\tsecondary = strsep(&tmp, \",\");\n\tif (!secondary) {\n\t\tkfree(pt);\n\t\treturn -EINVAL;\n\t}\n\tif (dasd_busid(primary, &id0, &id1, &id2)) {\n\t\tkfree(pt);\n\t\treturn -EINVAL;\n\t}\n\tsprintf(prim_busid, \"%01x.%01x.%04x\", id0, id1, id2);\n\tif (dasd_busid(secondary, &id0, &id1, &id2)) {\n\t\tkfree(pt);\n\t\treturn -EINVAL;\n\t}\n\tsprintf(sec_busid, \"%01x.%01x.%04x\", id0, id1, id2);\n\tkfree(pt);\n\n\treturn 0;\n}\n\nstatic ssize_t dasd_copy_pair_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct dasd_devmap *prim_devmap, *sec_devmap;\n\tchar prim_busid[DASD_BUS_ID_SIZE];\n\tchar sec_busid[DASD_BUS_ID_SIZE];\n\tstruct dasd_copy_relation *copy;\n\tstruct dasd_device *device;\n\tbool pprc_enabled;\n\tint rc;\n\n\tif (strncmp(buf, \"clear\", strlen(\"clear\")) == 0) {\n\t\tif (dasd_devmap_clear_copy_relation(dev))\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\t}\n\n\trc = dasd_devmap_parse_busid(buf, prim_busid, sec_busid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (strncmp(dev_name(dev), prim_busid, DASD_BUS_ID_SIZE) != 0 &&\n\t    strncmp(dev_name(dev), sec_busid, DASD_BUS_ID_SIZE) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tprim_devmap = dasd_find_busid(prim_busid);\n\tif (IS_ERR(prim_devmap))\n\t\tprim_devmap = dasd_add_busid(prim_busid, DASD_FEATURE_DEFAULT);\n\n\t \n\tsec_devmap = dasd_find_busid(sec_busid);\n\tif (IS_ERR(sec_devmap))\n\t\tsec_devmap = dasd_add_busid(sec_busid, DASD_FEATURE_DEFAULT);\n\n\t \n\tif (sec_devmap->device)\n\t\treturn -EINVAL;\n\n\tif (prim_devmap->copy) {\n\t\tcopy = prim_devmap->copy;\n\t} else if (sec_devmap->copy) {\n\t\tcopy = sec_devmap->copy;\n\t} else {\n\t\tcopy = kzalloc(sizeof(*copy), GFP_KERNEL);\n\t\tif (!copy)\n\t\t\treturn -ENOMEM;\n\t}\n\tspin_lock(&dasd_devmap_lock);\n\trc = dasd_devmap_set_copy_relation(prim_devmap, copy, prim_busid, true);\n\tif (rc) {\n\t\tspin_unlock(&dasd_devmap_lock);\n\t\treturn rc;\n\t}\n\trc = dasd_devmap_set_copy_relation(sec_devmap, copy, sec_busid, false);\n\tif (rc) {\n\t\tspin_unlock(&dasd_devmap_lock);\n\t\treturn rc;\n\t}\n\tspin_unlock(&dasd_devmap_lock);\n\n\t \n\tif (prim_devmap->device && !prim_devmap->device->copy) {\n\t\tdevice = prim_devmap->device;\n\t\tif (device->discipline->pprc_enabled) {\n\t\t\tpprc_enabled = device->discipline->pprc_enabled(device);\n\t\t\trc = dasd_devmap_set_device_copy_relation(device->cdev,\n\t\t\t\t\t\t\t\t  pprc_enabled);\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (rc) {\n\t\tdasd_devmap_del_copy_relation(copy, prim_busid);\n\t\tdasd_devmap_del_copy_relation(copy, sec_busid);\n\t\tcount = rc;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR(copy_pair, 0644, dasd_copy_pair_show,\n\t\t   dasd_copy_pair_store);\n\nstatic ssize_t\ndasd_copy_role_show(struct device *dev,\n\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct dasd_copy_relation *copy;\n\tstruct dasd_device *device;\n\tint len, i;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\n\tif (!device->copy) {\n\t\tlen = sysfs_emit(buf, \"none\\n\");\n\t\tgoto out;\n\t}\n\tcopy = device->copy;\n\t \n\tif (copy->active->device == device) {\n\t\tlen = sysfs_emit(buf, \"primary\\n\");\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (copy->entry[i].device == device) {\n\t\t\tlen = sysfs_emit(buf, \"secondary\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tlen = sysfs_emit(buf, \"none\\n\");\nout:\n\tdasd_put_device(device);\n\treturn len;\n}\nstatic DEVICE_ATTR(copy_role, 0444, dasd_copy_role_show, NULL);\n\nstatic ssize_t dasd_device_ping(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct dasd_device *device;\n\tsize_t rc;\n\n\tdevice = dasd_device_from_cdev(to_ccwdev(dev));\n\tif (IS_ERR(device))\n\t\treturn -ENODEV;\n\n\t \n\tif (test_bit(DASD_FLAG_OFFLINE, &device->flags)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (!device->discipline || !device->discipline->device_ping) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\trc = device->discipline->device_ping(device);\n\tif (!rc)\n\t\trc = count;\nout:\n\tdasd_put_device(device);\n\treturn rc;\n}\nstatic DEVICE_ATTR(ping, 0200, NULL, dasd_device_ping);\n\n#define DASD_DEFINE_ATTR(_name, _func)\t\t\t\t\t\\\nstatic ssize_t dasd_##_name##_show(struct device *dev,\t\t\t\\\n\t\t\t\t   struct device_attribute *attr,\t\\\n\t\t\t\t   char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ccw_device *cdev = to_ccwdev(dev);\t\t\t\\\n\tstruct dasd_device *device = dasd_device_from_cdev(cdev);\t\\\n\tint val = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (IS_ERR(device))\t\t\t\t\t\t\\\n\t\treturn -ENODEV;\t\t\t\t\t\t\\\n\tif (device->discipline && _func)\t\t\t\t\\\n\t\tval = _func(device);\t\t\t\t\t\\\n\tdasd_put_device(device);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%d\\n\", val);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(_name, 0444, dasd_##_name##_show, NULL);\t\t\\\n\nDASD_DEFINE_ATTR(ese, device->discipline->is_ese);\nDASD_DEFINE_ATTR(extent_size, device->discipline->ext_size);\nDASD_DEFINE_ATTR(pool_id, device->discipline->ext_pool_id);\nDASD_DEFINE_ATTR(space_configured, device->discipline->space_configured);\nDASD_DEFINE_ATTR(space_allocated, device->discipline->space_allocated);\nDASD_DEFINE_ATTR(logical_capacity, device->discipline->logical_capacity);\nDASD_DEFINE_ATTR(warn_threshold, device->discipline->ext_pool_warn_thrshld);\nDASD_DEFINE_ATTR(cap_at_warnlevel, device->discipline->ext_pool_cap_at_warnlevel);\nDASD_DEFINE_ATTR(pool_oos, device->discipline->ext_pool_oos);\n\nstatic struct attribute * dasd_attrs[] = {\n\t&dev_attr_readonly.attr,\n\t&dev_attr_discipline.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_alias.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_uid.attr,\n\t&dev_attr_use_diag.attr,\n\t&dev_attr_raw_track_access.attr,\n\t&dev_attr_eer_enabled.attr,\n\t&dev_attr_erplog.attr,\n\t&dev_attr_failfast.attr,\n\t&dev_attr_expires.attr,\n\t&dev_attr_retries.attr,\n\t&dev_attr_timeout.attr,\n\t&dev_attr_reservation_policy.attr,\n\t&dev_attr_last_known_reservation_state.attr,\n\t&dev_attr_safe_offline.attr,\n\t&dev_attr_host_access_count.attr,\n\t&dev_attr_path_masks.attr,\n\t&dev_attr_path_threshold.attr,\n\t&dev_attr_path_autodisable.attr,\n\t&dev_attr_path_interval.attr,\n\t&dev_attr_path_reset.attr,\n\t&dev_attr_hpf.attr,\n\t&dev_attr_ese.attr,\n\t&dev_attr_fc_security.attr,\n\t&dev_attr_copy_pair.attr,\n\t&dev_attr_copy_role.attr,\n\t&dev_attr_ping.attr,\n\t&dev_attr_aq_mask.attr,\n\t&dev_attr_aq_requeue.attr,\n\t&dev_attr_aq_timeouts.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group dasd_attr_group = {\n\t.attrs = dasd_attrs,\n};\n\nstatic struct attribute *capacity_attrs[] = {\n\t&dev_attr_space_configured.attr,\n\t&dev_attr_space_allocated.attr,\n\t&dev_attr_logical_capacity.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group capacity_attr_group = {\n\t.name = \"capacity\",\n\t.attrs = capacity_attrs,\n};\n\nstatic struct attribute *ext_pool_attrs[] = {\n\t&dev_attr_pool_id.attr,\n\t&dev_attr_extent_size.attr,\n\t&dev_attr_warn_threshold.attr,\n\t&dev_attr_cap_at_warnlevel.attr,\n\t&dev_attr_pool_oos.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ext_pool_attr_group = {\n\t.name = \"extent_pool\",\n\t.attrs = ext_pool_attrs,\n};\n\nconst struct attribute_group *dasd_dev_groups[] = {\n\t&dasd_attr_group,\n\t&capacity_attr_group,\n\t&ext_pool_attr_group,\n\tNULL,\n};\nEXPORT_SYMBOL_GPL(dasd_dev_groups);\n\n \nint\ndasd_get_feature(struct ccw_device *cdev, int feature)\n{\n\tstruct dasd_devmap *devmap;\n\n\tdevmap = dasd_find_busid(dev_name(&cdev->dev));\n\tif (IS_ERR(devmap))\n\t\treturn PTR_ERR(devmap);\n\n\treturn ((devmap->features & feature) != 0);\n}\n\n \nint\ndasd_set_feature(struct ccw_device *cdev, int feature, int flag)\n{\n\tstruct dasd_devmap *devmap;\n\n\tdevmap = dasd_devmap_from_cdev(cdev);\n\tif (IS_ERR(devmap))\n\t\treturn PTR_ERR(devmap);\n\n\tspin_lock(&dasd_devmap_lock);\n\tif (flag)\n\t\tdevmap->features |= feature;\n\telse\n\t\tdevmap->features &= ~feature;\n\tif (devmap->device)\n\t\tdevmap->device->features = devmap->features;\n\tspin_unlock(&dasd_devmap_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(dasd_set_feature);\n\nstatic struct attribute *paths_info_attrs[] = {\n\t&path_fcs_attribute.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(paths_info);\n\nstatic struct kobj_type path_attr_type = {\n\t.release\t= dasd_path_release,\n\t.default_groups\t= paths_info_groups,\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n};\n\nstatic void dasd_path_init_kobj(struct dasd_device *device, int chp)\n{\n\tdevice->path[chp].kobj.kset = device->paths_info;\n\tkobject_init(&device->path[chp].kobj, &path_attr_type);\n}\n\nvoid dasd_path_create_kobj(struct dasd_device *device, int chp)\n{\n\tint rc;\n\n\tif (test_bit(DASD_FLAG_OFFLINE, &device->flags))\n\t\treturn;\n\tif (!device->paths_info) {\n\t\tdev_warn(&device->cdev->dev, \"Unable to create paths objects\\n\");\n\t\treturn;\n\t}\n\tif (device->path[chp].in_sysfs)\n\t\treturn;\n\tif (!device->path[chp].conf_data)\n\t\treturn;\n\n\tdasd_path_init_kobj(device, chp);\n\n\trc = kobject_add(&device->path[chp].kobj, NULL, \"%x.%02x\",\n\t\t\t device->path[chp].cssid, device->path[chp].chpid);\n\tif (rc)\n\t\tkobject_put(&device->path[chp].kobj);\n\tdevice->path[chp].in_sysfs = true;\n}\nEXPORT_SYMBOL(dasd_path_create_kobj);\n\nvoid dasd_path_create_kobjects(struct dasd_device *device)\n{\n\tu8 lpm, opm;\n\n\topm = dasd_path_get_opm(device);\n\tfor (lpm = 0x80; lpm; lpm >>= 1) {\n\t\tif (!(lpm & opm))\n\t\t\tcontinue;\n\t\tdasd_path_create_kobj(device, pathmask_to_pos(lpm));\n\t}\n}\nEXPORT_SYMBOL(dasd_path_create_kobjects);\n\nstatic void dasd_path_remove_kobj(struct dasd_device *device, int chp)\n{\n\tif (device->path[chp].in_sysfs) {\n\t\tkobject_put(&device->path[chp].kobj);\n\t\tdevice->path[chp].in_sysfs = false;\n\t}\n}\n\n \nvoid dasd_path_remove_kobjects(struct dasd_device *device)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tdasd_path_remove_kobj(device, i);\n}\nEXPORT_SYMBOL(dasd_path_remove_kobjects);\n\nint\ndasd_devmap_init(void)\n{\n\tint i;\n\n\t \n\tdasd_max_devindex = 0;\n\tfor (i = 0; i < 256; i++)\n\t\tINIT_LIST_HEAD(&dasd_hashlists[i]);\n\treturn 0;\n}\n\nvoid\ndasd_devmap_exit(void)\n{\n\tdasd_forget_ranges();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}