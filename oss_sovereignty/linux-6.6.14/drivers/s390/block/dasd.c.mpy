{
  "module_name": "dasd.c",
  "hash_id": "d97d894b7c3b0eab819d91d545281533ad6dfb3d08220bea2e7d4b4bcc1cb71e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/major.h>\n#include <linux/slab.h>\n#include <linux/hdreg.h>\n#include <linux/async.h>\n#include <linux/mutex.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n\n#include <asm/ccwdev.h>\n#include <asm/ebcdic.h>\n#include <asm/idals.h>\n#include <asm/itcw.h>\n#include <asm/diag.h>\n\n \n#define PRINTK_HEADER \"dasd:\"\n\n#include \"dasd_int.h\"\n \n#define DASD_CHANQ_MAX_SIZE 4\n\n#define DASD_DIAG_MOD\t\t\"dasd_diag_mod\"\n\n \ndebug_info_t *dasd_debug_area;\nEXPORT_SYMBOL(dasd_debug_area);\nstatic struct dentry *dasd_debugfs_root_entry;\nstruct dasd_discipline *dasd_diag_discipline_pointer;\nEXPORT_SYMBOL(dasd_diag_discipline_pointer);\nvoid dasd_int_handler(struct ccw_device *, unsigned long, struct irb *);\n\nMODULE_AUTHOR(\"Holger Smolinski <Holger.Smolinski@de.ibm.com>\");\nMODULE_DESCRIPTION(\"Linux on S/390 DASD device driver,\"\n\t\t   \" Copyright IBM Corp. 2000\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int dasd_flush_block_queue(struct dasd_block *);\nstatic void dasd_device_tasklet(unsigned long);\nstatic void dasd_block_tasklet(unsigned long);\nstatic void do_kick_device(struct work_struct *);\nstatic void do_reload_device(struct work_struct *);\nstatic void do_requeue_requests(struct work_struct *);\nstatic void dasd_return_cqr_cb(struct dasd_ccw_req *, void *);\nstatic void dasd_device_timeout(struct timer_list *);\nstatic void dasd_block_timeout(struct timer_list *);\nstatic void __dasd_process_erp(struct dasd_device *, struct dasd_ccw_req *);\nstatic void dasd_profile_init(struct dasd_profile *, struct dentry *);\nstatic void dasd_profile_exit(struct dasd_profile *);\nstatic void dasd_hosts_init(struct dentry *, struct dasd_device *);\nstatic void dasd_hosts_exit(struct dasd_device *);\nstatic int dasd_handle_autoquiesce(struct dasd_device *, struct dasd_ccw_req *,\n\t\t\t\t   unsigned int);\n \nstatic wait_queue_head_t dasd_init_waitq;\nstatic wait_queue_head_t dasd_flush_wq;\nstatic wait_queue_head_t generic_waitq;\nstatic wait_queue_head_t shutdown_waitq;\n\n \nstruct dasd_device *dasd_alloc_device(void)\n{\n\tstruct dasd_device *device;\n\n\tdevice = kzalloc(sizeof(struct dasd_device), GFP_ATOMIC);\n\tif (!device)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tdevice->ccw_mem = (void *) __get_free_pages(GFP_ATOMIC | GFP_DMA, 1);\n\tif (!device->ccw_mem) {\n\t\tkfree(device);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t \n\tdevice->erp_mem = (void *) get_zeroed_page(GFP_ATOMIC | GFP_DMA);\n\tif (!device->erp_mem) {\n\t\tfree_pages((unsigned long) device->ccw_mem, 1);\n\t\tkfree(device);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\t \n\tdevice->ese_mem = (void *)__get_free_pages(GFP_ATOMIC | GFP_DMA, 1);\n\tif (!device->ese_mem) {\n\t\tfree_page((unsigned long) device->erp_mem);\n\t\tfree_pages((unsigned long) device->ccw_mem, 1);\n\t\tkfree(device);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdasd_init_chunklist(&device->ccw_chunks, device->ccw_mem, PAGE_SIZE*2);\n\tdasd_init_chunklist(&device->erp_chunks, device->erp_mem, PAGE_SIZE);\n\tdasd_init_chunklist(&device->ese_chunks, device->ese_mem, PAGE_SIZE * 2);\n\tspin_lock_init(&device->mem_lock);\n\tatomic_set(&device->tasklet_scheduled, 0);\n\ttasklet_init(&device->tasklet, dasd_device_tasklet,\n\t\t     (unsigned long) device);\n\tINIT_LIST_HEAD(&device->ccw_queue);\n\ttimer_setup(&device->timer, dasd_device_timeout, 0);\n\tINIT_WORK(&device->kick_work, do_kick_device);\n\tINIT_WORK(&device->reload_device, do_reload_device);\n\tINIT_WORK(&device->requeue_requests, do_requeue_requests);\n\tdevice->state = DASD_STATE_NEW;\n\tdevice->target = DASD_STATE_NEW;\n\tmutex_init(&device->state_mutex);\n\tspin_lock_init(&device->profile.lock);\n\treturn device;\n}\n\n \nvoid dasd_free_device(struct dasd_device *device)\n{\n\tkfree(device->private);\n\tfree_pages((unsigned long) device->ese_mem, 1);\n\tfree_page((unsigned long) device->erp_mem);\n\tfree_pages((unsigned long) device->ccw_mem, 1);\n\tkfree(device);\n}\n\n \nstruct dasd_block *dasd_alloc_block(void)\n{\n\tstruct dasd_block *block;\n\n\tblock = kzalloc(sizeof(*block), GFP_ATOMIC);\n\tif (!block)\n\t\treturn ERR_PTR(-ENOMEM);\n\t \n\tatomic_set(&block->open_count, -1);\n\n\tatomic_set(&block->tasklet_scheduled, 0);\n\ttasklet_init(&block->tasklet, dasd_block_tasklet,\n\t\t     (unsigned long) block);\n\tINIT_LIST_HEAD(&block->ccw_queue);\n\tspin_lock_init(&block->queue_lock);\n\tINIT_LIST_HEAD(&block->format_list);\n\tspin_lock_init(&block->format_lock);\n\ttimer_setup(&block->timer, dasd_block_timeout, 0);\n\tspin_lock_init(&block->profile.lock);\n\n\treturn block;\n}\nEXPORT_SYMBOL_GPL(dasd_alloc_block);\n\n \nvoid dasd_free_block(struct dasd_block *block)\n{\n\tkfree(block);\n}\nEXPORT_SYMBOL_GPL(dasd_free_block);\n\n \nstatic int dasd_state_new_to_known(struct dasd_device *device)\n{\n\t \n\tdasd_get_device(device);\n\tdevice->state = DASD_STATE_KNOWN;\n\treturn 0;\n}\n\n \nstatic int dasd_state_known_to_new(struct dasd_device *device)\n{\n\t \n\tdasd_eer_disable(device);\n\tdevice->state = DASD_STATE_NEW;\n\n\t \n\tdasd_put_device(device);\n\treturn 0;\n}\n\nstatic struct dentry *dasd_debugfs_setup(const char *name,\n\t\t\t\t\t struct dentry *base_dentry)\n{\n\tstruct dentry *pde;\n\n\tif (!base_dentry)\n\t\treturn NULL;\n\tpde = debugfs_create_dir(name, base_dentry);\n\tif (!pde || IS_ERR(pde))\n\t\treturn NULL;\n\treturn pde;\n}\n\n \nstatic int dasd_state_known_to_basic(struct dasd_device *device)\n{\n\tstruct dasd_block *block = device->block;\n\tint rc = 0;\n\n\t \n\tif (block) {\n\t\trc = dasd_gendisk_alloc(block);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tblock->debugfs_dentry =\n\t\t\tdasd_debugfs_setup(block->gdp->disk_name,\n\t\t\t\t\t   dasd_debugfs_root_entry);\n\t\tdasd_profile_init(&block->profile, block->debugfs_dentry);\n\t\tif (dasd_global_profile_level == DASD_PROFILE_ON)\n\t\t\tdasd_profile_on(&device->block->profile);\n\t}\n\tdevice->debugfs_dentry =\n\t\tdasd_debugfs_setup(dev_name(&device->cdev->dev),\n\t\t\t\t   dasd_debugfs_root_entry);\n\tdasd_profile_init(&device->profile, device->debugfs_dentry);\n\tdasd_hosts_init(device->debugfs_dentry, device);\n\n\t \n\tdevice->debug_area = debug_register(dev_name(&device->cdev->dev), 4, 1,\n\t\t\t\t\t    8 * sizeof(long));\n\tdebug_register_view(device->debug_area, &debug_sprintf_view);\n\tdebug_set_level(device->debug_area, DBF_WARNING);\n\tDBF_DEV_EVENT(DBF_EMERG, device, \"%s\", \"debug area created\");\n\n\tdevice->state = DASD_STATE_BASIC;\n\n\treturn rc;\n}\n\n \nstatic int dasd_state_basic_to_known(struct dasd_device *device)\n{\n\tint rc;\n\n\tif (device->discipline->basic_to_known) {\n\t\trc = device->discipline->basic_to_known(device);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (device->block) {\n\t\tdasd_profile_exit(&device->block->profile);\n\t\tdebugfs_remove(device->block->debugfs_dentry);\n\t\tdasd_gendisk_free(device->block);\n\t\tdasd_block_clear_timer(device->block);\n\t}\n\trc = dasd_flush_device_queue(device);\n\tif (rc)\n\t\treturn rc;\n\tdasd_device_clear_timer(device);\n\tdasd_profile_exit(&device->profile);\n\tdasd_hosts_exit(device);\n\tdebugfs_remove(device->debugfs_dentry);\n\tDBF_DEV_EVENT(DBF_EMERG, device, \"%p debug area deleted\", device);\n\tif (device->debug_area != NULL) {\n\t\tdebug_unregister(device->debug_area);\n\t\tdevice->debug_area = NULL;\n\t}\n\tdevice->state = DASD_STATE_KNOWN;\n\treturn 0;\n}\n\n \nstatic int dasd_state_basic_to_ready(struct dasd_device *device)\n{\n\tint rc;\n\tstruct dasd_block *block;\n\tstruct gendisk *disk;\n\n\trc = 0;\n\tblock = device->block;\n\t \n\tif (block) {\n\t\tif (block->base->discipline->do_analysis != NULL)\n\t\t\trc = block->base->discipline->do_analysis(block);\n\t\tif (rc) {\n\t\t\tif (rc != -EAGAIN) {\n\t\t\t\tdevice->state = DASD_STATE_UNFMT;\n\t\t\t\tdisk = device->block->gdp;\n\t\t\t\tkobject_uevent(&disk_to_dev(disk)->kobj,\n\t\t\t\t\t       KOBJ_CHANGE);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\t\tif (device->discipline->setup_blk_queue)\n\t\t\tdevice->discipline->setup_blk_queue(block);\n\t\tset_capacity(block->gdp,\n\t\t\t     block->blocks << block->s2b_shift);\n\t\tdevice->state = DASD_STATE_READY;\n\t\trc = dasd_scan_partitions(block);\n\t\tif (rc) {\n\t\t\tdevice->state = DASD_STATE_BASIC;\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tdevice->state = DASD_STATE_READY;\n\t}\nout:\n\tif (device->discipline->basic_to_ready)\n\t\trc = device->discipline->basic_to_ready(device);\n\treturn rc;\n}\n\nstatic inline\nint _wait_for_empty_queues(struct dasd_device *device)\n{\n\tif (device->block)\n\t\treturn list_empty(&device->ccw_queue) &&\n\t\t\tlist_empty(&device->block->ccw_queue);\n\telse\n\t\treturn list_empty(&device->ccw_queue);\n}\n\n \nstatic int dasd_state_ready_to_basic(struct dasd_device *device)\n{\n\tint rc;\n\n\tdevice->state = DASD_STATE_BASIC;\n\tif (device->block) {\n\t\tstruct dasd_block *block = device->block;\n\t\trc = dasd_flush_block_queue(block);\n\t\tif (rc) {\n\t\t\tdevice->state = DASD_STATE_READY;\n\t\t\treturn rc;\n\t\t}\n\t\tdasd_destroy_partitions(block);\n\t\tblock->blocks = 0;\n\t\tblock->bp_block = 0;\n\t\tblock->s2b_shift = 0;\n\t}\n\treturn 0;\n}\n\n \nstatic int dasd_state_unfmt_to_basic(struct dasd_device *device)\n{\n\tdevice->state = DASD_STATE_BASIC;\n\treturn 0;\n}\n\n \nstatic int\ndasd_state_ready_to_online(struct dasd_device * device)\n{\n\tdevice->state = DASD_STATE_ONLINE;\n\tif (device->block) {\n\t\tdasd_schedule_block_bh(device->block);\n\t\tif ((device->features & DASD_FEATURE_USERAW)) {\n\t\t\tkobject_uevent(&disk_to_dev(device->block->gdp)->kobj,\n\t\t\t\t\tKOBJ_CHANGE);\n\t\t\treturn 0;\n\t\t}\n\t\tdisk_uevent(device->block->bdev->bd_disk, KOBJ_CHANGE);\n\t}\n\treturn 0;\n}\n\n \nstatic int dasd_state_online_to_ready(struct dasd_device *device)\n{\n\tint rc;\n\n\tif (device->discipline->online_to_ready) {\n\t\trc = device->discipline->online_to_ready(device);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tdevice->state = DASD_STATE_READY;\n\tif (device->block && !(device->features & DASD_FEATURE_USERAW))\n\t\tdisk_uevent(device->block->bdev->bd_disk, KOBJ_CHANGE);\n\treturn 0;\n}\n\n \nstatic int dasd_increase_state(struct dasd_device *device)\n{\n\tint rc;\n\n\trc = 0;\n\tif (device->state == DASD_STATE_NEW &&\n\t    device->target >= DASD_STATE_KNOWN)\n\t\trc = dasd_state_new_to_known(device);\n\n\tif (!rc &&\n\t    device->state == DASD_STATE_KNOWN &&\n\t    device->target >= DASD_STATE_BASIC)\n\t\trc = dasd_state_known_to_basic(device);\n\n\tif (!rc &&\n\t    device->state == DASD_STATE_BASIC &&\n\t    device->target >= DASD_STATE_READY)\n\t\trc = dasd_state_basic_to_ready(device);\n\n\tif (!rc &&\n\t    device->state == DASD_STATE_UNFMT &&\n\t    device->target > DASD_STATE_UNFMT)\n\t\trc = -EPERM;\n\n\tif (!rc &&\n\t    device->state == DASD_STATE_READY &&\n\t    device->target >= DASD_STATE_ONLINE)\n\t\trc = dasd_state_ready_to_online(device);\n\n\treturn rc;\n}\n\n \nstatic int dasd_decrease_state(struct dasd_device *device)\n{\n\tint rc;\n\n\trc = 0;\n\tif (device->state == DASD_STATE_ONLINE &&\n\t    device->target <= DASD_STATE_READY)\n\t\trc = dasd_state_online_to_ready(device);\n\n\tif (!rc &&\n\t    device->state == DASD_STATE_READY &&\n\t    device->target <= DASD_STATE_BASIC)\n\t\trc = dasd_state_ready_to_basic(device);\n\n\tif (!rc &&\n\t    device->state == DASD_STATE_UNFMT &&\n\t    device->target <= DASD_STATE_BASIC)\n\t\trc = dasd_state_unfmt_to_basic(device);\n\n\tif (!rc &&\n\t    device->state == DASD_STATE_BASIC &&\n\t    device->target <= DASD_STATE_KNOWN)\n\t\trc = dasd_state_basic_to_known(device);\n\n\tif (!rc &&\n\t    device->state == DASD_STATE_KNOWN &&\n\t    device->target <= DASD_STATE_NEW)\n\t\trc = dasd_state_known_to_new(device);\n\n\treturn rc;\n}\n\n \nstatic void dasd_change_state(struct dasd_device *device)\n{\n\tint rc;\n\n\tif (device->state == device->target)\n\t\t \n\t\treturn;\n\tif (device->state < device->target)\n\t\trc = dasd_increase_state(device);\n\telse\n\t\trc = dasd_decrease_state(device);\n\tif (rc == -EAGAIN)\n\t\treturn;\n\tif (rc)\n\t\tdevice->target = device->state;\n\n\t \n\tkobject_uevent(&device->cdev->dev.kobj, KOBJ_CHANGE);\n\n\tif (device->state == device->target)\n\t\twake_up(&dasd_init_waitq);\n}\n\n \nstatic void do_kick_device(struct work_struct *work)\n{\n\tstruct dasd_device *device = container_of(work, struct dasd_device, kick_work);\n\tmutex_lock(&device->state_mutex);\n\tdasd_change_state(device);\n\tmutex_unlock(&device->state_mutex);\n\tdasd_schedule_device_bh(device);\n\tdasd_put_device(device);\n}\n\nvoid dasd_kick_device(struct dasd_device *device)\n{\n\tdasd_get_device(device);\n\t \n\tif (!schedule_work(&device->kick_work))\n\t\tdasd_put_device(device);\n}\nEXPORT_SYMBOL(dasd_kick_device);\n\n \nstatic void do_reload_device(struct work_struct *work)\n{\n\tstruct dasd_device *device = container_of(work, struct dasd_device,\n\t\t\t\t\t\t  reload_device);\n\tdevice->discipline->reload(device);\n\tdasd_put_device(device);\n}\n\nvoid dasd_reload_device(struct dasd_device *device)\n{\n\tdasd_get_device(device);\n\t \n\tif (!schedule_work(&device->reload_device))\n\t\tdasd_put_device(device);\n}\nEXPORT_SYMBOL(dasd_reload_device);\n\n \nvoid dasd_set_target_state(struct dasd_device *device, int target)\n{\n\tdasd_get_device(device);\n\tmutex_lock(&device->state_mutex);\n\t \n\tif (dasd_probeonly && target > DASD_STATE_READY)\n\t\ttarget = DASD_STATE_READY;\n\tif (device->target != target) {\n\t\tif (device->state == target)\n\t\t\twake_up(&dasd_init_waitq);\n\t\tdevice->target = target;\n\t}\n\tif (device->state != device->target)\n\t\tdasd_change_state(device);\n\tmutex_unlock(&device->state_mutex);\n\tdasd_put_device(device);\n}\n\n \nstatic inline int _wait_for_device(struct dasd_device *device)\n{\n\treturn (device->state == device->target);\n}\n\nvoid dasd_enable_device(struct dasd_device *device)\n{\n\tdasd_set_target_state(device, DASD_STATE_ONLINE);\n\tif (device->state <= DASD_STATE_KNOWN)\n\t\t \n\t\tdasd_set_target_state(device, DASD_STATE_NEW);\n\t \n\twait_event(dasd_init_waitq, _wait_for_device(device));\n\n\tdasd_reload_device(device);\n\tif (device->discipline->kick_validate)\n\t\tdevice->discipline->kick_validate(device);\n}\nEXPORT_SYMBOL(dasd_enable_device);\n\n \n\nunsigned int dasd_global_profile_level = DASD_PROFILE_OFF;\n\n#ifdef CONFIG_DASD_PROFILE\nstruct dasd_profile dasd_global_profile = {\n\t.lock = __SPIN_LOCK_UNLOCKED(dasd_global_profile.lock),\n};\nstatic struct dentry *dasd_debugfs_global_entry;\n\n \nstatic void dasd_profile_start(struct dasd_block *block,\n\t\t\t       struct dasd_ccw_req *cqr,\n\t\t\t       struct request *req)\n{\n\tstruct list_head *l;\n\tunsigned int counter;\n\tstruct dasd_device *device;\n\n\t \n\tcounter = 0;\n\tif (dasd_global_profile_level || block->profile.data)\n\t\tlist_for_each(l, &block->ccw_queue)\n\t\t\tif (++counter >= 31)\n\t\t\t\tbreak;\n\n\tspin_lock(&dasd_global_profile.lock);\n\tif (dasd_global_profile.data) {\n\t\tdasd_global_profile.data->dasd_io_nr_req[counter]++;\n\t\tif (rq_data_dir(req) == READ)\n\t\t\tdasd_global_profile.data->dasd_read_nr_req[counter]++;\n\t}\n\tspin_unlock(&dasd_global_profile.lock);\n\n\tspin_lock(&block->profile.lock);\n\tif (block->profile.data) {\n\t\tblock->profile.data->dasd_io_nr_req[counter]++;\n\t\tif (rq_data_dir(req) == READ)\n\t\t\tblock->profile.data->dasd_read_nr_req[counter]++;\n\t}\n\tspin_unlock(&block->profile.lock);\n\n\t \n\tdevice = cqr->startdev;\n\tif (!device->profile.data)\n\t\treturn;\n\n\tspin_lock(get_ccwdev_lock(device->cdev));\n\tcounter = 1;  \n\tlist_for_each(l, &device->ccw_queue)\n\t\tif (++counter >= 31)\n\t\t\tbreak;\n\tspin_unlock(get_ccwdev_lock(device->cdev));\n\n\tspin_lock(&device->profile.lock);\n\tdevice->profile.data->dasd_io_nr_req[counter]++;\n\tif (rq_data_dir(req) == READ)\n\t\tdevice->profile.data->dasd_read_nr_req[counter]++;\n\tspin_unlock(&device->profile.lock);\n}\n\n \n\n#define dasd_profile_counter(value, index)\t\t\t   \\\n{\t\t\t\t\t\t\t\t   \\\n\tfor (index = 0; index < 31 && value >> (2+index); index++) \\\n\t\t;\t\t\t\t\t\t   \\\n}\n\nstatic void dasd_profile_end_add_data(struct dasd_profile_info *data,\n\t\t\t\t      int is_alias,\n\t\t\t\t      int is_tpm,\n\t\t\t\t      int is_read,\n\t\t\t\t      long sectors,\n\t\t\t\t      int sectors_ind,\n\t\t\t\t      int tottime_ind,\n\t\t\t\t      int tottimeps_ind,\n\t\t\t\t      int strtime_ind,\n\t\t\t\t      int irqtime_ind,\n\t\t\t\t      int irqtimeps_ind,\n\t\t\t\t      int endtime_ind)\n{\n\t \n\tif (data->dasd_io_reqs == UINT_MAX) {\n\t\t\tmemset(data, 0, sizeof(*data));\n\t\t\tktime_get_real_ts64(&data->starttod);\n\t}\n\tdata->dasd_io_reqs++;\n\tdata->dasd_io_sects += sectors;\n\tif (is_alias)\n\t\tdata->dasd_io_alias++;\n\tif (is_tpm)\n\t\tdata->dasd_io_tpm++;\n\n\tdata->dasd_io_secs[sectors_ind]++;\n\tdata->dasd_io_times[tottime_ind]++;\n\tdata->dasd_io_timps[tottimeps_ind]++;\n\tdata->dasd_io_time1[strtime_ind]++;\n\tdata->dasd_io_time2[irqtime_ind]++;\n\tdata->dasd_io_time2ps[irqtimeps_ind]++;\n\tdata->dasd_io_time3[endtime_ind]++;\n\n\tif (is_read) {\n\t\tdata->dasd_read_reqs++;\n\t\tdata->dasd_read_sects += sectors;\n\t\tif (is_alias)\n\t\t\tdata->dasd_read_alias++;\n\t\tif (is_tpm)\n\t\t\tdata->dasd_read_tpm++;\n\t\tdata->dasd_read_secs[sectors_ind]++;\n\t\tdata->dasd_read_times[tottime_ind]++;\n\t\tdata->dasd_read_time1[strtime_ind]++;\n\t\tdata->dasd_read_time2[irqtime_ind]++;\n\t\tdata->dasd_read_time3[endtime_ind]++;\n\t}\n}\n\nstatic void dasd_profile_end(struct dasd_block *block,\n\t\t\t     struct dasd_ccw_req *cqr,\n\t\t\t     struct request *req)\n{\n\tunsigned long strtime, irqtime, endtime, tottime;\n\tunsigned long tottimeps, sectors;\n\tstruct dasd_device *device;\n\tint sectors_ind, tottime_ind, tottimeps_ind, strtime_ind;\n\tint irqtime_ind, irqtimeps_ind, endtime_ind;\n\tstruct dasd_profile_info *data;\n\n\tdevice = cqr->startdev;\n\tif (!(dasd_global_profile_level ||\n\t      block->profile.data ||\n\t      device->profile.data))\n\t\treturn;\n\n\tsectors = blk_rq_sectors(req);\n\tif (!cqr->buildclk || !cqr->startclk ||\n\t    !cqr->stopclk || !cqr->endclk ||\n\t    !sectors)\n\t\treturn;\n\n\tstrtime = ((cqr->startclk - cqr->buildclk) >> 12);\n\tirqtime = ((cqr->stopclk - cqr->startclk) >> 12);\n\tendtime = ((cqr->endclk - cqr->stopclk) >> 12);\n\ttottime = ((cqr->endclk - cqr->buildclk) >> 12);\n\ttottimeps = tottime / sectors;\n\n\tdasd_profile_counter(sectors, sectors_ind);\n\tdasd_profile_counter(tottime, tottime_ind);\n\tdasd_profile_counter(tottimeps, tottimeps_ind);\n\tdasd_profile_counter(strtime, strtime_ind);\n\tdasd_profile_counter(irqtime, irqtime_ind);\n\tdasd_profile_counter(irqtime / sectors, irqtimeps_ind);\n\tdasd_profile_counter(endtime, endtime_ind);\n\n\tspin_lock(&dasd_global_profile.lock);\n\tif (dasd_global_profile.data) {\n\t\tdata = dasd_global_profile.data;\n\t\tdata->dasd_sum_times += tottime;\n\t\tdata->dasd_sum_time_str += strtime;\n\t\tdata->dasd_sum_time_irq += irqtime;\n\t\tdata->dasd_sum_time_end += endtime;\n\t\tdasd_profile_end_add_data(dasd_global_profile.data,\n\t\t\t\t\t  cqr->startdev != block->base,\n\t\t\t\t\t  cqr->cpmode == 1,\n\t\t\t\t\t  rq_data_dir(req) == READ,\n\t\t\t\t\t  sectors, sectors_ind, tottime_ind,\n\t\t\t\t\t  tottimeps_ind, strtime_ind,\n\t\t\t\t\t  irqtime_ind, irqtimeps_ind,\n\t\t\t\t\t  endtime_ind);\n\t}\n\tspin_unlock(&dasd_global_profile.lock);\n\n\tspin_lock(&block->profile.lock);\n\tif (block->profile.data) {\n\t\tdata = block->profile.data;\n\t\tdata->dasd_sum_times += tottime;\n\t\tdata->dasd_sum_time_str += strtime;\n\t\tdata->dasd_sum_time_irq += irqtime;\n\t\tdata->dasd_sum_time_end += endtime;\n\t\tdasd_profile_end_add_data(block->profile.data,\n\t\t\t\t\t  cqr->startdev != block->base,\n\t\t\t\t\t  cqr->cpmode == 1,\n\t\t\t\t\t  rq_data_dir(req) == READ,\n\t\t\t\t\t  sectors, sectors_ind, tottime_ind,\n\t\t\t\t\t  tottimeps_ind, strtime_ind,\n\t\t\t\t\t  irqtime_ind, irqtimeps_ind,\n\t\t\t\t\t  endtime_ind);\n\t}\n\tspin_unlock(&block->profile.lock);\n\n\tspin_lock(&device->profile.lock);\n\tif (device->profile.data) {\n\t\tdata = device->profile.data;\n\t\tdata->dasd_sum_times += tottime;\n\t\tdata->dasd_sum_time_str += strtime;\n\t\tdata->dasd_sum_time_irq += irqtime;\n\t\tdata->dasd_sum_time_end += endtime;\n\t\tdasd_profile_end_add_data(device->profile.data,\n\t\t\t\t\t  cqr->startdev != block->base,\n\t\t\t\t\t  cqr->cpmode == 1,\n\t\t\t\t\t  rq_data_dir(req) == READ,\n\t\t\t\t\t  sectors, sectors_ind, tottime_ind,\n\t\t\t\t\t  tottimeps_ind, strtime_ind,\n\t\t\t\t\t  irqtime_ind, irqtimeps_ind,\n\t\t\t\t\t  endtime_ind);\n\t}\n\tspin_unlock(&device->profile.lock);\n}\n\nvoid dasd_profile_reset(struct dasd_profile *profile)\n{\n\tstruct dasd_profile_info *data;\n\n\tspin_lock_bh(&profile->lock);\n\tdata = profile->data;\n\tif (!data) {\n\t\tspin_unlock_bh(&profile->lock);\n\t\treturn;\n\t}\n\tmemset(data, 0, sizeof(*data));\n\tktime_get_real_ts64(&data->starttod);\n\tspin_unlock_bh(&profile->lock);\n}\n\nint dasd_profile_on(struct dasd_profile *profile)\n{\n\tstruct dasd_profile_info *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tspin_lock_bh(&profile->lock);\n\tif (profile->data) {\n\t\tspin_unlock_bh(&profile->lock);\n\t\tkfree(data);\n\t\treturn 0;\n\t}\n\tktime_get_real_ts64(&data->starttod);\n\tprofile->data = data;\n\tspin_unlock_bh(&profile->lock);\n\treturn 0;\n}\n\nvoid dasd_profile_off(struct dasd_profile *profile)\n{\n\tspin_lock_bh(&profile->lock);\n\tkfree(profile->data);\n\tprofile->data = NULL;\n\tspin_unlock_bh(&profile->lock);\n}\n\nchar *dasd_get_user_string(const char __user *user_buf, size_t user_len)\n{\n\tchar *buffer;\n\n\tbuffer = vmalloc(user_len + 1);\n\tif (buffer == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (copy_from_user(buffer, user_buf, user_len) != 0) {\n\t\tvfree(buffer);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\t \n\tif (buffer[user_len - 1] == '\\n')\n\t\tbuffer[user_len - 1] = 0;\n\telse\n\t\tbuffer[user_len] = 0;\n\treturn buffer;\n}\n\nstatic ssize_t dasd_stats_write(struct file *file,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t user_len, loff_t *pos)\n{\n\tchar *buffer, *str;\n\tint rc;\n\tstruct seq_file *m = (struct seq_file *)file->private_data;\n\tstruct dasd_profile *prof = m->private;\n\n\tif (user_len > 65536)\n\t\tuser_len = 65536;\n\tbuffer = dasd_get_user_string(user_buf, user_len);\n\tif (IS_ERR(buffer))\n\t\treturn PTR_ERR(buffer);\n\n\tstr = skip_spaces(buffer);\n\trc = user_len;\n\tif (strncmp(str, \"reset\", 5) == 0) {\n\t\tdasd_profile_reset(prof);\n\t} else if (strncmp(str, \"on\", 2) == 0) {\n\t\trc = dasd_profile_on(prof);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\trc = user_len;\n\t\tif (prof == &dasd_global_profile) {\n\t\t\tdasd_profile_reset(prof);\n\t\t\tdasd_global_profile_level = DASD_PROFILE_GLOBAL_ONLY;\n\t\t}\n\t} else if (strncmp(str, \"off\", 3) == 0) {\n\t\tif (prof == &dasd_global_profile)\n\t\t\tdasd_global_profile_level = DASD_PROFILE_OFF;\n\t\tdasd_profile_off(prof);\n\t} else\n\t\trc = -EINVAL;\nout:\n\tvfree(buffer);\n\treturn rc;\n}\n\nstatic void dasd_stats_array(struct seq_file *m, unsigned int *array)\n{\n\tint i;\n\n\tfor (i = 0; i < 32; i++)\n\t\tseq_printf(m, \"%u \", array[i]);\n\tseq_putc(m, '\\n');\n}\n\nstatic void dasd_stats_seq_print(struct seq_file *m,\n\t\t\t\t struct dasd_profile_info *data)\n{\n\tseq_printf(m, \"start_time %lld.%09ld\\n\",\n\t\t   (s64)data->starttod.tv_sec, data->starttod.tv_nsec);\n\tseq_printf(m, \"total_requests %u\\n\", data->dasd_io_reqs);\n\tseq_printf(m, \"total_sectors %u\\n\", data->dasd_io_sects);\n\tseq_printf(m, \"total_pav %u\\n\", data->dasd_io_alias);\n\tseq_printf(m, \"total_hpf %u\\n\", data->dasd_io_tpm);\n\tseq_printf(m, \"avg_total %lu\\n\", data->dasd_io_reqs ?\n\t\t   data->dasd_sum_times / data->dasd_io_reqs : 0UL);\n\tseq_printf(m, \"avg_build_to_ssch %lu\\n\", data->dasd_io_reqs ?\n\t\t   data->dasd_sum_time_str / data->dasd_io_reqs : 0UL);\n\tseq_printf(m, \"avg_ssch_to_irq %lu\\n\", data->dasd_io_reqs ?\n\t\t   data->dasd_sum_time_irq / data->dasd_io_reqs : 0UL);\n\tseq_printf(m, \"avg_irq_to_end %lu\\n\", data->dasd_io_reqs ?\n\t\t   data->dasd_sum_time_end / data->dasd_io_reqs : 0UL);\n\tseq_puts(m, \"histogram_sectors \");\n\tdasd_stats_array(m, data->dasd_io_secs);\n\tseq_puts(m, \"histogram_io_times \");\n\tdasd_stats_array(m, data->dasd_io_times);\n\tseq_puts(m, \"histogram_io_times_weighted \");\n\tdasd_stats_array(m, data->dasd_io_timps);\n\tseq_puts(m, \"histogram_time_build_to_ssch \");\n\tdasd_stats_array(m, data->dasd_io_time1);\n\tseq_puts(m, \"histogram_time_ssch_to_irq \");\n\tdasd_stats_array(m, data->dasd_io_time2);\n\tseq_puts(m, \"histogram_time_ssch_to_irq_weighted \");\n\tdasd_stats_array(m, data->dasd_io_time2ps);\n\tseq_puts(m, \"histogram_time_irq_to_end \");\n\tdasd_stats_array(m, data->dasd_io_time3);\n\tseq_puts(m, \"histogram_ccw_queue_length \");\n\tdasd_stats_array(m, data->dasd_io_nr_req);\n\tseq_printf(m, \"total_read_requests %u\\n\", data->dasd_read_reqs);\n\tseq_printf(m, \"total_read_sectors %u\\n\", data->dasd_read_sects);\n\tseq_printf(m, \"total_read_pav %u\\n\", data->dasd_read_alias);\n\tseq_printf(m, \"total_read_hpf %u\\n\", data->dasd_read_tpm);\n\tseq_puts(m, \"histogram_read_sectors \");\n\tdasd_stats_array(m, data->dasd_read_secs);\n\tseq_puts(m, \"histogram_read_times \");\n\tdasd_stats_array(m, data->dasd_read_times);\n\tseq_puts(m, \"histogram_read_time_build_to_ssch \");\n\tdasd_stats_array(m, data->dasd_read_time1);\n\tseq_puts(m, \"histogram_read_time_ssch_to_irq \");\n\tdasd_stats_array(m, data->dasd_read_time2);\n\tseq_puts(m, \"histogram_read_time_irq_to_end \");\n\tdasd_stats_array(m, data->dasd_read_time3);\n\tseq_puts(m, \"histogram_read_ccw_queue_length \");\n\tdasd_stats_array(m, data->dasd_read_nr_req);\n}\n\nstatic int dasd_stats_show(struct seq_file *m, void *v)\n{\n\tstruct dasd_profile *profile;\n\tstruct dasd_profile_info *data;\n\n\tprofile = m->private;\n\tspin_lock_bh(&profile->lock);\n\tdata = profile->data;\n\tif (!data) {\n\t\tspin_unlock_bh(&profile->lock);\n\t\tseq_puts(m, \"disabled\\n\");\n\t\treturn 0;\n\t}\n\tdasd_stats_seq_print(m, data);\n\tspin_unlock_bh(&profile->lock);\n\treturn 0;\n}\n\nstatic int dasd_stats_open(struct inode *inode, struct file *file)\n{\n\tstruct dasd_profile *profile = inode->i_private;\n\treturn single_open(file, dasd_stats_show, profile);\n}\n\nstatic const struct file_operations dasd_stats_raw_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= dasd_stats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n\t.write\t\t= dasd_stats_write,\n};\n\nstatic void dasd_profile_init(struct dasd_profile *profile,\n\t\t\t      struct dentry *base_dentry)\n{\n\tumode_t mode;\n\tstruct dentry *pde;\n\n\tif (!base_dentry)\n\t\treturn;\n\tprofile->dentry = NULL;\n\tprofile->data = NULL;\n\tmode = (S_IRUSR | S_IWUSR | S_IFREG);\n\tpde = debugfs_create_file(\"statistics\", mode, base_dentry,\n\t\t\t\t  profile, &dasd_stats_raw_fops);\n\tif (pde && !IS_ERR(pde))\n\t\tprofile->dentry = pde;\n\treturn;\n}\n\nstatic void dasd_profile_exit(struct dasd_profile *profile)\n{\n\tdasd_profile_off(profile);\n\tdebugfs_remove(profile->dentry);\n\tprofile->dentry = NULL;\n}\n\nstatic void dasd_statistics_removeroot(void)\n{\n\tdasd_global_profile_level = DASD_PROFILE_OFF;\n\tdasd_profile_exit(&dasd_global_profile);\n\tdebugfs_remove(dasd_debugfs_global_entry);\n\tdebugfs_remove(dasd_debugfs_root_entry);\n}\n\nstatic void dasd_statistics_createroot(void)\n{\n\tstruct dentry *pde;\n\n\tdasd_debugfs_root_entry = NULL;\n\tpde = debugfs_create_dir(\"dasd\", NULL);\n\tif (!pde || IS_ERR(pde))\n\t\tgoto error;\n\tdasd_debugfs_root_entry = pde;\n\tpde = debugfs_create_dir(\"global\", dasd_debugfs_root_entry);\n\tif (!pde || IS_ERR(pde))\n\t\tgoto error;\n\tdasd_debugfs_global_entry = pde;\n\tdasd_profile_init(&dasd_global_profile, dasd_debugfs_global_entry);\n\treturn;\n\nerror:\n\tDBF_EVENT(DBF_ERR, \"%s\",\n\t\t  \"Creation of the dasd debugfs interface failed\");\n\tdasd_statistics_removeroot();\n\treturn;\n}\n\n#else\n#define dasd_profile_start(block, cqr, req) do {} while (0)\n#define dasd_profile_end(block, cqr, req) do {} while (0)\n\nstatic void dasd_statistics_createroot(void)\n{\n\treturn;\n}\n\nstatic void dasd_statistics_removeroot(void)\n{\n\treturn;\n}\n\nint dasd_stats_generic_show(struct seq_file *m, void *v)\n{\n\tseq_puts(m, \"Statistics are not activated in this kernel\\n\");\n\treturn 0;\n}\n\nstatic void dasd_profile_init(struct dasd_profile *profile,\n\t\t\t      struct dentry *base_dentry)\n{\n\treturn;\n}\n\nstatic void dasd_profile_exit(struct dasd_profile *profile)\n{\n\treturn;\n}\n\nint dasd_profile_on(struct dasd_profile *profile)\n{\n\treturn 0;\n}\n\n#endif\t\t\t\t \n\nstatic int dasd_hosts_show(struct seq_file *m, void *v)\n{\n\tstruct dasd_device *device;\n\tint rc = -EOPNOTSUPP;\n\n\tdevice = m->private;\n\tdasd_get_device(device);\n\n\tif (device->discipline->hosts_print)\n\t\trc = device->discipline->hosts_print(device, m);\n\n\tdasd_put_device(device);\n\treturn rc;\n}\n\nDEFINE_SHOW_ATTRIBUTE(dasd_hosts);\n\nstatic void dasd_hosts_exit(struct dasd_device *device)\n{\n\tdebugfs_remove(device->hosts_dentry);\n\tdevice->hosts_dentry = NULL;\n}\n\nstatic void dasd_hosts_init(struct dentry *base_dentry,\n\t\t\t    struct dasd_device *device)\n{\n\tstruct dentry *pde;\n\tumode_t mode;\n\n\tif (!base_dentry)\n\t\treturn;\n\n\tmode = S_IRUSR | S_IFREG;\n\tpde = debugfs_create_file(\"host_access_list\", mode, base_dentry,\n\t\t\t\t  device, &dasd_hosts_fops);\n\tif (pde && !IS_ERR(pde))\n\t\tdevice->hosts_dentry = pde;\n}\n\nstruct dasd_ccw_req *dasd_smalloc_request(int magic, int cplength, int datasize,\n\t\t\t\t\t  struct dasd_device *device,\n\t\t\t\t\t  struct dasd_ccw_req *cqr)\n{\n\tunsigned long flags;\n\tchar *data, *chunk;\n\tint size = 0;\n\n\tif (cplength > 0)\n\t\tsize += cplength * sizeof(struct ccw1);\n\tif (datasize > 0)\n\t\tsize += datasize;\n\tif (!cqr)\n\t\tsize += (sizeof(*cqr) + 7L) & -8L;\n\n\tspin_lock_irqsave(&device->mem_lock, flags);\n\tdata = chunk = dasd_alloc_chunk(&device->ccw_chunks, size);\n\tspin_unlock_irqrestore(&device->mem_lock, flags);\n\tif (!chunk)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!cqr) {\n\t\tcqr = (void *) data;\n\t\tdata += (sizeof(*cqr) + 7L) & -8L;\n\t}\n\tmemset(cqr, 0, sizeof(*cqr));\n\tcqr->mem_chunk = chunk;\n\tif (cplength > 0) {\n\t\tcqr->cpaddr = data;\n\t\tdata += cplength * sizeof(struct ccw1);\n\t\tmemset(cqr->cpaddr, 0, cplength * sizeof(struct ccw1));\n\t}\n\tif (datasize > 0) {\n\t\tcqr->data = data;\n \t\tmemset(cqr->data, 0, datasize);\n\t}\n\tcqr->magic = magic;\n\tset_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tdasd_get_device(device);\n\treturn cqr;\n}\nEXPORT_SYMBOL(dasd_smalloc_request);\n\nstruct dasd_ccw_req *dasd_fmalloc_request(int magic, int cplength,\n\t\t\t\t\t  int datasize,\n\t\t\t\t\t  struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tunsigned long flags;\n\tint size, cqr_size;\n\tchar *data;\n\n\tcqr_size = (sizeof(*cqr) + 7L) & -8L;\n\tsize = cqr_size;\n\tif (cplength > 0)\n\t\tsize += cplength * sizeof(struct ccw1);\n\tif (datasize > 0)\n\t\tsize += datasize;\n\n\tspin_lock_irqsave(&device->mem_lock, flags);\n\tcqr = dasd_alloc_chunk(&device->ese_chunks, size);\n\tspin_unlock_irqrestore(&device->mem_lock, flags);\n\tif (!cqr)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmemset(cqr, 0, sizeof(*cqr));\n\tdata = (char *)cqr + cqr_size;\n\tcqr->cpaddr = NULL;\n\tif (cplength > 0) {\n\t\tcqr->cpaddr = data;\n\t\tdata += cplength * sizeof(struct ccw1);\n\t\tmemset(cqr->cpaddr, 0, cplength * sizeof(struct ccw1));\n\t}\n\tcqr->data = NULL;\n\tif (datasize > 0) {\n\t\tcqr->data = data;\n\t\tmemset(cqr->data, 0, datasize);\n\t}\n\n\tcqr->magic = magic;\n\tset_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tdasd_get_device(device);\n\n\treturn cqr;\n}\nEXPORT_SYMBOL(dasd_fmalloc_request);\n\nvoid dasd_sfree_request(struct dasd_ccw_req *cqr, struct dasd_device *device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&device->mem_lock, flags);\n\tdasd_free_chunk(&device->ccw_chunks, cqr->mem_chunk);\n\tspin_unlock_irqrestore(&device->mem_lock, flags);\n\tdasd_put_device(device);\n}\nEXPORT_SYMBOL(dasd_sfree_request);\n\nvoid dasd_ffree_request(struct dasd_ccw_req *cqr, struct dasd_device *device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&device->mem_lock, flags);\n\tdasd_free_chunk(&device->ese_chunks, cqr);\n\tspin_unlock_irqrestore(&device->mem_lock, flags);\n\tdasd_put_device(device);\n}\nEXPORT_SYMBOL(dasd_ffree_request);\n\n \nstatic inline int dasd_check_cqr(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\n\tif (cqr == NULL)\n\t\treturn -EINVAL;\n\tdevice = cqr->startdev;\n\tif (strncmp((char *) &cqr->magic, device->discipline->ebcname, 4)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t\t    \" dasd_ccw_req 0x%08x magic doesn't match\"\n\t\t\t    \" discipline 0x%08x\",\n\t\t\t    cqr->magic,\n\t\t\t    *(unsigned int *) device->discipline->name);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nint dasd_term_IO(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\tint retries, rc;\n\tchar errorstring[ERRORLENGTH];\n\n\t \n\trc = dasd_check_cqr(cqr);\n\tif (rc)\n\t\treturn rc;\n\tretries = 0;\n\tdevice = (struct dasd_device *) cqr->startdev;\n\twhile ((retries < 5) && (cqr->status == DASD_CQR_IN_IO)) {\n\t\trc = ccw_device_clear(device->cdev, (long) cqr);\n\t\tswitch (rc) {\n\t\tcase 0:\t \n\t\t\tcqr->status = DASD_CQR_CLEAR_PENDING;\n\t\t\tcqr->stopclk = get_tod_clock();\n\t\t\tcqr->starttime = 0;\n\t\t\tDBF_DEV_EVENT(DBF_DEBUG, device,\n\t\t\t\t      \"terminate cqr %p successful\",\n\t\t\t\t      cqr);\n\t\t\tbreak;\n\t\tcase -ENODEV:\n\t\t\tDBF_DEV_EVENT(DBF_ERR, device, \"%s\",\n\t\t\t\t      \"device gone, retry\");\n\t\t\tbreak;\n\t\tcase -EINVAL:\n\t\t\t \n\t\t\tcqr->status = DASD_CQR_CLEARED;\n\t\t\tcqr->stopclk = get_tod_clock();\n\t\t\tcqr->starttime = 0;\n\t\t\t \n\t\t\tcqr->retries = -1;\n\t\t\tDBF_DEV_EVENT(DBF_ERR, device, \"%s\",\n\t\t\t\t      \"EINVAL, handle as terminated\");\n\t\t\t \n\t\t\trc = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tsnprintf(errorstring, ERRORLENGTH, \"10 %d\", rc);\n\t\t\tdev_err(&device->cdev->dev, \"An error occurred in the \"\n\t\t\t\t\"DASD device driver, reason=%s\\n\", errorstring);\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t\tretries++;\n\t}\n\tdasd_schedule_device_bh(device);\n\treturn rc;\n}\nEXPORT_SYMBOL(dasd_term_IO);\n\n \nint dasd_start_IO(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\tint rc;\n\tchar errorstring[ERRORLENGTH];\n\n\t \n\trc = dasd_check_cqr(cqr);\n\tif (rc) {\n\t\tcqr->intrc = rc;\n\t\treturn rc;\n\t}\n\tdevice = (struct dasd_device *) cqr->startdev;\n\tif (((cqr->block &&\n\t      test_bit(DASD_FLAG_LOCK_STOLEN, &cqr->block->base->flags)) ||\n\t     test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags)) &&\n\t    !test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\n\t\tDBF_DEV_EVENT(DBF_DEBUG, device, \"start_IO: return request %p \"\n\t\t\t      \"because of stolen lock\", cqr);\n\t\tcqr->status = DASD_CQR_ERROR;\n\t\tcqr->intrc = -EPERM;\n\t\treturn -EPERM;\n\t}\n\tif (cqr->retries < 0) {\n\t\t \n\t\tsprintf(errorstring, \"14 %p\", cqr);\n\t\tdev_err(&device->cdev->dev, \"An error occurred in the DASD \"\n\t\t\t\"device driver, reason=%s\\n\", errorstring);\n\t\tcqr->status = DASD_CQR_ERROR;\n\t\treturn -EIO;\n\t}\n\tcqr->startclk = get_tod_clock();\n\tcqr->starttime = jiffies;\n\tcqr->retries--;\n\tif (!test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags)) {\n\t\tcqr->lpm &= dasd_path_get_opm(device);\n\t\tif (!cqr->lpm)\n\t\t\tcqr->lpm = dasd_path_get_opm(device);\n\t}\n\t \n\tif (cqr->block)\n\t\tcqr->trkcount = atomic_read(&cqr->block->trkcount);\n\n\tif (cqr->cpmode == 1) {\n\t\trc = ccw_device_tm_start(device->cdev, cqr->cpaddr,\n\t\t\t\t\t (long) cqr, cqr->lpm);\n\t} else {\n\t\trc = ccw_device_start(device->cdev, cqr->cpaddr,\n\t\t\t\t      (long) cqr, cqr->lpm, 0);\n\t}\n\tswitch (rc) {\n\tcase 0:\n\t\tcqr->status = DASD_CQR_IN_IO;\n\t\tbreak;\n\tcase -EBUSY:\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"start_IO: device busy, retry later\");\n\t\tbreak;\n\tcase -EACCES:\n\t\t \n\t\tif (test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags)) {\n\t\t\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t\t\t      \"start_IO: selected paths gone (%x)\",\n\t\t\t\t      cqr->lpm);\n\t\t} else if (cqr->lpm != dasd_path_get_opm(device)) {\n\t\t\tcqr->lpm = dasd_path_get_opm(device);\n\t\t\tDBF_DEV_EVENT(DBF_DEBUG, device, \"%s\",\n\t\t\t\t      \"start_IO: selected paths gone,\"\n\t\t\t\t      \" retry on all paths\");\n\t\t} else {\n\t\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t\t      \"start_IO: all paths in opm gone,\"\n\t\t\t\t      \" do path verification\");\n\t\t\tdasd_generic_last_path_gone(device);\n\t\t\tdasd_path_no_path(device);\n\t\t\tdasd_path_set_tbvpm(device,\n\t\t\t\t\t  ccw_device_get_path_mask(\n\t\t\t\t\t\t  device->cdev));\n\t\t}\n\t\tbreak;\n\tcase -ENODEV:\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"start_IO: -ENODEV device gone, retry\");\n\t\t \n\t\tdasd_handle_autoquiesce(device, cqr, DASD_EER_STARTIO);\n\t\tbreak;\n\tcase -EIO:\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"start_IO: -EIO device gone, retry\");\n\t\tbreak;\n\tcase -EINVAL:\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"start_IO: -EINVAL device currently \"\n\t\t\t      \"not accessible\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tsnprintf(errorstring, ERRORLENGTH, \"11 %d\", rc);\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"An error occurred in the DASD device driver, \"\n\t\t\t\"reason=%s\\n\", errorstring);\n\t\tBUG();\n\t\tbreak;\n\t}\n\tcqr->intrc = rc;\n\treturn rc;\n}\nEXPORT_SYMBOL(dasd_start_IO);\n\n \nstatic void dasd_device_timeout(struct timer_list *t)\n{\n\tunsigned long flags;\n\tstruct dasd_device *device;\n\n\tdevice = from_timer(device, t, timer);\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\t \n\tdasd_device_remove_stop_bits(device, DASD_STOPPED_PENDING);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\tdasd_schedule_device_bh(device);\n}\n\n \nvoid dasd_device_set_timer(struct dasd_device *device, int expires)\n{\n\tif (expires == 0)\n\t\tdel_timer(&device->timer);\n\telse\n\t\tmod_timer(&device->timer, jiffies + expires);\n}\nEXPORT_SYMBOL(dasd_device_set_timer);\n\n \nvoid dasd_device_clear_timer(struct dasd_device *device)\n{\n\tdel_timer(&device->timer);\n}\nEXPORT_SYMBOL(dasd_device_clear_timer);\n\nstatic void dasd_handle_killed_request(struct ccw_device *cdev,\n\t\t\t\t       unsigned long intparm)\n{\n\tstruct dasd_ccw_req *cqr;\n\tstruct dasd_device *device;\n\n\tif (!intparm)\n\t\treturn;\n\tcqr = (struct dasd_ccw_req *) intparm;\n\tif (cqr->status != DASD_CQR_IN_IO) {\n\t\tDBF_EVENT_DEVID(DBF_DEBUG, cdev,\n\t\t\t\t\"invalid status in handle_killed_request: \"\n\t\t\t\t\"%02x\", cqr->status);\n\t\treturn;\n\t}\n\n\tdevice = dasd_device_from_cdev_locked(cdev);\n\tif (IS_ERR(device)) {\n\t\tDBF_EVENT_DEVID(DBF_DEBUG, cdev, \"%s\",\n\t\t\t\t\"unable to get device from cdev\");\n\t\treturn;\n\t}\n\n\tif (!cqr->startdev ||\n\t    device != cqr->startdev ||\n\t    strncmp(cqr->startdev->discipline->ebcname,\n\t\t    (char *) &cqr->magic, 4)) {\n\t\tDBF_EVENT_DEVID(DBF_DEBUG, cdev, \"%s\",\n\t\t\t\t\"invalid device in request\");\n\t\tdasd_put_device(device);\n\t\treturn;\n\t}\n\n\t \n\tcqr->status = DASD_CQR_QUEUED;\n\n\tdasd_device_clear_timer(device);\n\tdasd_schedule_device_bh(device);\n\tdasd_put_device(device);\n}\n\nvoid dasd_generic_handle_state_change(struct dasd_device *device)\n{\n\t \n\tdasd_eer_snss(device);\n\n\tdasd_device_remove_stop_bits(device, DASD_STOPPED_PENDING);\n\tdasd_schedule_device_bh(device);\n\tif (device->block) {\n\t\tdasd_schedule_block_bh(device->block);\n\t\tif (device->block->gdp)\n\t\t\tblk_mq_run_hw_queues(device->block->gdp->queue, true);\n\t}\n}\nEXPORT_SYMBOL_GPL(dasd_generic_handle_state_change);\n\nstatic int dasd_check_hpf_error(struct irb *irb)\n{\n\treturn (scsw_tm_is_valid_schxs(&irb->scsw) &&\n\t    (irb->scsw.tm.sesq == SCSW_SESQ_DEV_NOFCX ||\n\t     irb->scsw.tm.sesq == SCSW_SESQ_PATH_NOFCX));\n}\n\nstatic int dasd_ese_needs_format(struct dasd_block *block, struct irb *irb)\n{\n\tstruct dasd_device *device = NULL;\n\tu8 *sense = NULL;\n\n\tif (!block)\n\t\treturn 0;\n\tdevice = block->base;\n\tif (!device || !device->discipline->is_ese)\n\t\treturn 0;\n\tif (!device->discipline->is_ese(device))\n\t\treturn 0;\n\n\tsense = dasd_get_sense(irb);\n\tif (!sense)\n\t\treturn 0;\n\n\treturn !!(sense[1] & SNS1_NO_REC_FOUND) ||\n\t\t!!(sense[1] & SNS1_FILE_PROTECTED) ||\n\t\tscsw_cstat(&irb->scsw) == SCHN_STAT_INCORR_LEN;\n}\n\nstatic int dasd_ese_oos_cond(u8 *sense)\n{\n\treturn sense[0] & SNS0_EQUIPMENT_CHECK &&\n\t\tsense[1] & SNS1_PERM_ERR &&\n\t\tsense[1] & SNS1_WRITE_INHIBITED &&\n\t\tsense[25] == 0x01;\n}\n\n \nvoid dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,\n\t\t      struct irb *irb)\n{\n\tstruct dasd_ccw_req *cqr, *next, *fcqr;\n\tstruct dasd_device *device;\n\tunsigned long now;\n\tint nrf_suppressed = 0;\n\tint fp_suppressed = 0;\n\tstruct request *req;\n\tu8 *sense = NULL;\n\tint expires;\n\n\tcqr = (struct dasd_ccw_req *) intparm;\n\tif (IS_ERR(irb)) {\n\t\tswitch (PTR_ERR(irb)) {\n\t\tcase -EIO:\n\t\t\tif (cqr && cqr->status == DASD_CQR_CLEAR_PENDING) {\n\t\t\t\tdevice = cqr->startdev;\n\t\t\t\tcqr->status = DASD_CQR_CLEARED;\n\t\t\t\tdasd_device_clear_timer(device);\n\t\t\t\twake_up(&dasd_flush_wq);\n\t\t\t\tdasd_schedule_device_bh(device);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase -ETIMEDOUT:\n\t\t\tDBF_EVENT_DEVID(DBF_WARNING, cdev, \"%s: \"\n\t\t\t\t\t\"request timed out\\n\", __func__);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBF_EVENT_DEVID(DBF_WARNING, cdev, \"%s: \"\n\t\t\t\t\t\"unknown error %ld\\n\", __func__,\n\t\t\t\t\tPTR_ERR(irb));\n\t\t}\n\t\tdasd_handle_killed_request(cdev, intparm);\n\t\treturn;\n\t}\n\n\tnow = get_tod_clock();\n\t \n\tif (!cqr ||\n\t    !(scsw_dstat(&irb->scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &&\n\t      scsw_cstat(&irb->scsw) == 0)) {\n\t\tif (cqr)\n\t\t\tmemcpy(&cqr->irb, irb, sizeof(*irb));\n\t\tdevice = dasd_device_from_cdev_locked(cdev);\n\t\tif (IS_ERR(device))\n\t\t\treturn;\n\t\t \n\t\tif (device->discipline == dasd_diag_discipline_pointer) {\n\t\t\tdasd_put_device(device);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tsense = dasd_get_sense(irb);\n\t\tif (sense) {\n\t\t\tfp_suppressed = (sense[1] & SNS1_FILE_PROTECTED) &&\n\t\t\t\ttest_bit(DASD_CQR_SUPPRESS_FP, &cqr->flags);\n\t\t\tnrf_suppressed = (sense[1] & SNS1_NO_REC_FOUND) &&\n\t\t\t\ttest_bit(DASD_CQR_SUPPRESS_NRF, &cqr->flags);\n\n\t\t\t \n\t\t\tif (dasd_ese_oos_cond(sense)) {\n\t\t\t\tdasd_generic_space_exhaust(device, cqr);\n\t\t\t\tdevice->discipline->ext_pool_exhaust(device, cqr);\n\t\t\t\tdasd_put_device(device);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!(fp_suppressed || nrf_suppressed))\n\t\t\tdevice->discipline->dump_sense_dbf(device, irb, \"int\");\n\n\t\tif (device->features & DASD_FEATURE_ERPLOG)\n\t\t\tdevice->discipline->dump_sense(device, cqr, irb);\n\t\tdevice->discipline->check_for_device_change(device, cqr, irb);\n\t\tdasd_put_device(device);\n\t}\n\n\t \n\tif (scsw_dstat(&irb->scsw) & DEV_STAT_ATTENTION) {\n\t\tdevice = dasd_device_from_cdev_locked(cdev);\n\t\tif (!IS_ERR(device)) {\n\t\t\tdevice->discipline->check_attention(device,\n\t\t\t\t\t\t\t    irb->esw.esw1.lpum);\n\t\t\tdasd_put_device(device);\n\t\t}\n\t}\n\n\tif (!cqr)\n\t\treturn;\n\n\tdevice = (struct dasd_device *) cqr->startdev;\n\tif (!device ||\n\t    strncmp(device->discipline->ebcname, (char *) &cqr->magic, 4)) {\n\t\tDBF_EVENT_DEVID(DBF_DEBUG, cdev, \"%s\",\n\t\t\t\t\"invalid device in request\");\n\t\treturn;\n\t}\n\n\tif (dasd_ese_needs_format(cqr->block, irb)) {\n\t\treq = dasd_get_callback_data(cqr);\n\t\tif (!req) {\n\t\t\tcqr->status = DASD_CQR_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif (rq_data_dir(req) == READ) {\n\t\t\tdevice->discipline->ese_read(cqr, irb);\n\t\t\tcqr->status = DASD_CQR_SUCCESS;\n\t\t\tcqr->stopclk = now;\n\t\t\tdasd_device_clear_timer(device);\n\t\t\tdasd_schedule_device_bh(device);\n\t\t\treturn;\n\t\t}\n\t\tfcqr = device->discipline->ese_format(device, cqr, irb);\n\t\tif (IS_ERR(fcqr)) {\n\t\t\tif (PTR_ERR(fcqr) == -EINVAL) {\n\t\t\t\tcqr->status = DASD_CQR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tcqr->status = DASD_CQR_QUEUED;\n\t\t\tdasd_schedule_device_bh(device);\n\t\t\treturn;\n\t\t} else {\n\t\t\tfcqr->status = DASD_CQR_QUEUED;\n\t\t\tcqr->status = DASD_CQR_QUEUED;\n\t\t\tlist_add(&fcqr->devlist, &device->ccw_queue);\n\t\t\tdasd_schedule_device_bh(device);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (cqr->status == DASD_CQR_CLEAR_PENDING &&\n\t    scsw_fctl(&irb->scsw) & SCSW_FCTL_CLEAR_FUNC) {\n\t\tcqr->status = DASD_CQR_CLEARED;\n\t\tdasd_device_clear_timer(device);\n\t\twake_up(&dasd_flush_wq);\n\t\tdasd_schedule_device_bh(device);\n\t\treturn;\n\t}\n\n\t \n\tif (cqr->status != DASD_CQR_IN_IO) {\n\t\tDBF_DEV_EVENT(DBF_DEBUG, device, \"invalid status: bus_id %s, \"\n\t\t\t      \"status %02x\", dev_name(&cdev->dev), cqr->status);\n\t\treturn;\n\t}\n\n\tnext = NULL;\n\texpires = 0;\n\tif (scsw_dstat(&irb->scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &&\n\t    scsw_cstat(&irb->scsw) == 0) {\n\t\t \n\t\tcqr->status = DASD_CQR_SUCCESS;\n\t\tcqr->stopclk = now;\n\t\t \n\t\tif (cqr->devlist.next != &device->ccw_queue) {\n\t\t\tnext = list_entry(cqr->devlist.next,\n\t\t\t\t\t  struct dasd_ccw_req, devlist);\n\t\t}\n\t} else {   \n\t\t \n\t\tif (cqr->cpmode && dasd_check_hpf_error(irb) &&\n\t\t    device->discipline->handle_hpf_error)\n\t\t\tdevice->discipline->handle_hpf_error(device, irb);\n\t\t \n\t\tif (!test_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags) &&\n\t\t    cqr->retries > 0) {\n\t\t\tif (cqr->lpm == dasd_path_get_opm(device))\n\t\t\t\tDBF_DEV_EVENT(DBF_DEBUG, device,\n\t\t\t\t\t      \"default ERP in fastpath \"\n\t\t\t\t\t      \"(%i retries left)\",\n\t\t\t\t\t      cqr->retries);\n\t\t\tif (!test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags))\n\t\t\t\tcqr->lpm = dasd_path_get_opm(device);\n\t\t\tcqr->status = DASD_CQR_QUEUED;\n\t\t\tnext = cqr;\n\t\t} else\n\t\t\tcqr->status = DASD_CQR_ERROR;\n\t}\n\tif (next && (next->status == DASD_CQR_QUEUED) &&\n\t    (!device->stopped)) {\n\t\tif (device->discipline->start_IO(next) == 0)\n\t\t\texpires = next->expires;\n\t}\n\tif (expires != 0)\n\t\tdasd_device_set_timer(device, expires);\n\telse\n\t\tdasd_device_clear_timer(device);\n\tdasd_schedule_device_bh(device);\n}\nEXPORT_SYMBOL(dasd_int_handler);\n\nenum uc_todo dasd_generic_uc_handler(struct ccw_device *cdev, struct irb *irb)\n{\n\tstruct dasd_device *device;\n\n\tdevice = dasd_device_from_cdev_locked(cdev);\n\n\tif (IS_ERR(device))\n\t\tgoto out;\n\tif (test_bit(DASD_FLAG_OFFLINE, &device->flags) ||\n\t   device->state != device->target ||\n\t   !device->discipline->check_for_device_change){\n\t\tdasd_put_device(device);\n\t\tgoto out;\n\t}\n\tif (device->discipline->dump_sense_dbf)\n\t\tdevice->discipline->dump_sense_dbf(device, irb, \"uc\");\n\tdevice->discipline->check_for_device_change(device, NULL, irb);\n\tdasd_put_device(device);\nout:\n\treturn UC_TODO_RETRY;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_uc_handler);\n\n \nstatic void __dasd_device_recovery(struct dasd_device *device,\n\t\t\t\t   struct dasd_ccw_req *ref_cqr)\n{\n\tstruct list_head *l, *n;\n\tstruct dasd_ccw_req *cqr;\n\n\t \n\tif (!ref_cqr->block)\n\t\treturn;\n\n\tlist_for_each_safe(l, n, &device->ccw_queue) {\n\t\tcqr = list_entry(l, struct dasd_ccw_req, devlist);\n\t\tif (cqr->status == DASD_CQR_QUEUED &&\n\t\t    ref_cqr->block == cqr->block) {\n\t\t\tcqr->status = DASD_CQR_CLEARED;\n\t\t}\n\t}\n};\n\n \nstatic void __dasd_device_process_ccw_queue(struct dasd_device *device,\n\t\t\t\t\t    struct list_head *final_queue)\n{\n\tstruct list_head *l, *n;\n\tstruct dasd_ccw_req *cqr;\n\n\t \n\tlist_for_each_safe(l, n, &device->ccw_queue) {\n\t\tcqr = list_entry(l, struct dasd_ccw_req, devlist);\n\n\t\t \n\t\tif (cqr->status == DASD_CQR_QUEUED ||\n\t\t    cqr->status == DASD_CQR_IN_IO ||\n\t\t    cqr->status == DASD_CQR_CLEAR_PENDING)\n\t\t\tcontinue;\n\t\tif (cqr->status == DASD_CQR_ERROR) {\n\t\t\t__dasd_device_recovery(device, cqr);\n\t\t}\n\t\t \n\t\tlist_move_tail(&cqr->devlist, final_queue);\n\t}\n}\n\nstatic void __dasd_process_cqr(struct dasd_device *device,\n\t\t\t       struct dasd_ccw_req *cqr)\n{\n\tchar errorstring[ERRORLENGTH];\n\n\tswitch (cqr->status) {\n\tcase DASD_CQR_SUCCESS:\n\t\tcqr->status = DASD_CQR_DONE;\n\t\tbreak;\n\tcase DASD_CQR_ERROR:\n\t\tcqr->status = DASD_CQR_NEED_ERP;\n\t\tbreak;\n\tcase DASD_CQR_CLEARED:\n\t\tcqr->status = DASD_CQR_TERMINATED;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tsnprintf(errorstring, ERRORLENGTH, \"12 %p %x02\", cqr, cqr->status);\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"An error occurred in the DASD device driver, \"\n\t\t\t\"reason=%s\\n\", errorstring);\n\t\tBUG();\n\t}\n\tif (cqr->callback)\n\t\tcqr->callback(cqr, cqr->callback_data);\n}\n\n \nstatic void __dasd_device_process_final_queue(struct dasd_device *device,\n\t\t\t\t\t      struct list_head *final_queue)\n{\n\tstruct list_head *l, *n;\n\tstruct dasd_ccw_req *cqr;\n\tstruct dasd_block *block;\n\n\tlist_for_each_safe(l, n, final_queue) {\n\t\tcqr = list_entry(l, struct dasd_ccw_req, devlist);\n\t\tlist_del_init(&cqr->devlist);\n\t\tblock = cqr->block;\n\t\tif (!block) {\n\t\t\t__dasd_process_cqr(device, cqr);\n\t\t} else {\n\t\t\tspin_lock_bh(&block->queue_lock);\n\t\t\t__dasd_process_cqr(device, cqr);\n\t\t\tspin_unlock_bh(&block->queue_lock);\n\t\t}\n\t}\n}\n\n \nstatic void __dasd_device_check_autoquiesce_timeout(struct dasd_device *device,\n\t\t\t\t\t\t    struct dasd_ccw_req *cqr)\n{\n\tif ((device->default_retries - cqr->retries) >= device->aq_timeouts)\n\t\tdasd_handle_autoquiesce(device, cqr, DASD_EER_TIMEOUTS);\n}\n\n \nstatic void __dasd_device_check_expire(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\n\tif (list_empty(&device->ccw_queue))\n\t\treturn;\n\tcqr = list_entry(device->ccw_queue.next, struct dasd_ccw_req, devlist);\n\tif ((cqr->status == DASD_CQR_IN_IO && cqr->expires != 0) &&\n\t    (time_after_eq(jiffies, cqr->expires + cqr->starttime))) {\n\t\tif (test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\n\t\t\t \n\t\t\tcqr->retries++;\n\t\t}\n\t\tif (device->discipline->term_IO(cqr) != 0) {\n\t\t\t \n\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t\"cqr %p timed out (%lus) but cannot be \"\n\t\t\t\t\"ended, retrying in 5 s\\n\",\n\t\t\t\tcqr, (cqr->expires/HZ));\n\t\t\tcqr->expires += 5*HZ;\n\t\t\tdasd_device_set_timer(device, 5*HZ);\n\t\t} else {\n\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t\"cqr %p timed out (%lus), %i retries \"\n\t\t\t\t\"remaining\\n\", cqr, (cqr->expires/HZ),\n\t\t\t\tcqr->retries);\n\t\t}\n\t\t__dasd_device_check_autoquiesce_timeout(device, cqr);\n\t}\n}\n\n \nstatic int __dasd_device_is_unusable(struct dasd_device *device,\n\t\t\t\t     struct dasd_ccw_req *cqr)\n{\n\tint mask = ~(DASD_STOPPED_DC_WAIT | DASD_STOPPED_NOSPC);\n\n\tif (test_bit(DASD_FLAG_OFFLINE, &device->flags) &&\n\t    !test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\n\t\t \n\t\treturn 1;\n\t}\n\tif (device->stopped) {\n\t\tif (device->stopped & mask) {\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t\tif (!test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags)) {\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t\t \n\t}\n\treturn 0;\n}\n\n \nstatic void __dasd_device_start_head(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc;\n\n\tif (list_empty(&device->ccw_queue))\n\t\treturn;\n\tcqr = list_entry(device->ccw_queue.next, struct dasd_ccw_req, devlist);\n\tif (cqr->status != DASD_CQR_QUEUED)\n\t\treturn;\n\t \n\tif (__dasd_device_is_unusable(device, cqr)) {\n\t\tcqr->intrc = -EAGAIN;\n\t\tcqr->status = DASD_CQR_CLEARED;\n\t\tdasd_schedule_device_bh(device);\n\t\treturn;\n\t}\n\n\trc = device->discipline->start_IO(cqr);\n\tif (rc == 0)\n\t\tdasd_device_set_timer(device, cqr->expires);\n\telse if (rc == -EACCES) {\n\t\tdasd_schedule_device_bh(device);\n\t} else\n\t\t \n\t\tdasd_device_set_timer(device, 50);\n}\n\nstatic void __dasd_device_check_path_events(struct dasd_device *device)\n{\n\t__u8 tbvpm, fcsecpm;\n\tint rc;\n\n\ttbvpm = dasd_path_get_tbvpm(device);\n\tfcsecpm = dasd_path_get_fcsecpm(device);\n\n\tif (!tbvpm && !fcsecpm)\n\t\treturn;\n\n\tif (device->stopped & ~(DASD_STOPPED_DC_WAIT))\n\t\treturn;\n\n\tdasd_path_clear_all_verify(device);\n\tdasd_path_clear_all_fcsec(device);\n\n\trc = device->discipline->pe_handler(device, tbvpm, fcsecpm);\n\tif (rc) {\n\t\tdasd_path_add_tbvpm(device, tbvpm);\n\t\tdasd_path_add_fcsecpm(device, fcsecpm);\n\t\tdasd_device_set_timer(device, 50);\n\t}\n};\n\n \nint dasd_flush_device_queue(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr, *n;\n\tint rc;\n\tstruct list_head flush_queue;\n\n\tINIT_LIST_HEAD(&flush_queue);\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\trc = 0;\n\tlist_for_each_entry_safe(cqr, n, &device->ccw_queue, devlist) {\n\t\t \n\t\tswitch (cqr->status) {\n\t\tcase DASD_CQR_IN_IO:\n\t\t\trc = device->discipline->term_IO(cqr);\n\t\t\tif (rc) {\n\t\t\t\t \n\t\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t\t\"Flushing the DASD request queue \"\n\t\t\t\t\t\"failed for request %p\\n\", cqr);\n\t\t\t\t \n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DASD_CQR_QUEUED:\n\t\t\tcqr->stopclk = get_tod_clock();\n\t\t\tcqr->status = DASD_CQR_CLEARED;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tbreak;\n\t\t}\n\t\tlist_move_tail(&cqr->devlist, &flush_queue);\n\t}\nfinished:\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t \n\tlist_for_each_entry_safe(cqr, n, &flush_queue, devlist)\n\t\twait_event(dasd_flush_wq,\n\t\t\t   (cqr->status != DASD_CQR_CLEAR_PENDING));\n\t \n\t__dasd_device_process_final_queue(device, &flush_queue);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(dasd_flush_device_queue);\n\n \nstatic void dasd_device_tasklet(unsigned long data)\n{\n\tstruct dasd_device *device = (struct dasd_device *) data;\n\tstruct list_head final_queue;\n\n\tatomic_set (&device->tasklet_scheduled, 0);\n\tINIT_LIST_HEAD(&final_queue);\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\t \n\t__dasd_device_check_expire(device);\n\t \n\t__dasd_device_process_ccw_queue(device, &final_queue);\n\t__dasd_device_check_path_events(device);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t \n\t__dasd_device_process_final_queue(device, &final_queue);\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\t \n\t__dasd_device_start_head(device);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\tif (waitqueue_active(&shutdown_waitq))\n\t\twake_up(&shutdown_waitq);\n\tdasd_put_device(device);\n}\n\n \nvoid dasd_schedule_device_bh(struct dasd_device *device)\n{\n\t \n\tif (atomic_cmpxchg (&device->tasklet_scheduled, 0, 1) != 0)\n\t\treturn;\n\tdasd_get_device(device);\n\ttasklet_hi_schedule(&device->tasklet);\n}\nEXPORT_SYMBOL(dasd_schedule_device_bh);\n\nvoid dasd_device_set_stop_bits(struct dasd_device *device, int bits)\n{\n\tdevice->stopped |= bits;\n}\nEXPORT_SYMBOL_GPL(dasd_device_set_stop_bits);\n\nvoid dasd_device_remove_stop_bits(struct dasd_device *device, int bits)\n{\n\tdevice->stopped &= ~bits;\n\tif (!device->stopped)\n\t\twake_up(&generic_waitq);\n}\nEXPORT_SYMBOL_GPL(dasd_device_remove_stop_bits);\n\n \nvoid dasd_add_request_head(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\n\tdevice = cqr->startdev;\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tcqr->status = DASD_CQR_QUEUED;\n\tlist_add(&cqr->devlist, &device->ccw_queue);\n\t \n\tdasd_schedule_device_bh(device);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n}\nEXPORT_SYMBOL(dasd_add_request_head);\n\n \nvoid dasd_add_request_tail(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\n\tdevice = cqr->startdev;\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tcqr->status = DASD_CQR_QUEUED;\n\tlist_add_tail(&cqr->devlist, &device->ccw_queue);\n\t \n\tdasd_schedule_device_bh(device);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n}\nEXPORT_SYMBOL(dasd_add_request_tail);\n\n \nvoid dasd_wakeup_cb(struct dasd_ccw_req *cqr, void *data)\n{\n\tspin_lock_irq(get_ccwdev_lock(cqr->startdev->cdev));\n\tcqr->callback_data = DASD_SLEEPON_END_TAG;\n\tspin_unlock_irq(get_ccwdev_lock(cqr->startdev->cdev));\n\twake_up(&generic_waitq);\n}\nEXPORT_SYMBOL_GPL(dasd_wakeup_cb);\n\nstatic inline int _wait_for_wakeup(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\tint rc;\n\n\tdevice = cqr->startdev;\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\trc = (cqr->callback_data == DASD_SLEEPON_END_TAG);\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\treturn rc;\n}\n\n \nstatic int __dasd_sleep_on_erp(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\tdasd_erp_fn_t erp_fn;\n\n\tif (cqr->status == DASD_CQR_FILLED)\n\t\treturn 0;\n\tdevice = cqr->startdev;\n\tif (test_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags)) {\n\t\tif (cqr->status == DASD_CQR_TERMINATED) {\n\t\t\tdevice->discipline->handle_terminated_request(cqr);\n\t\t\treturn 1;\n\t\t}\n\t\tif (cqr->status == DASD_CQR_NEED_ERP) {\n\t\t\terp_fn = device->discipline->erp_action(cqr);\n\t\t\terp_fn(cqr);\n\t\t\treturn 1;\n\t\t}\n\t\tif (cqr->status == DASD_CQR_FAILED)\n\t\t\tdasd_log_sense(cqr, &cqr->irb);\n\t\tif (cqr->refers) {\n\t\t\t__dasd_process_erp(device, cqr);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __dasd_sleep_on_loop_condition(struct dasd_ccw_req *cqr)\n{\n\tif (test_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags)) {\n\t\tif (cqr->refers)  \n\t\t\treturn 1;\n\t\treturn ((cqr->status != DASD_CQR_DONE) &&\n\t\t\t(cqr->status != DASD_CQR_FAILED));\n\t} else\n\t\treturn (cqr->status == DASD_CQR_FILLED);\n}\n\nstatic int _dasd_sleep_on(struct dasd_ccw_req *maincqr, int interruptible)\n{\n\tstruct dasd_device *device;\n\tint rc;\n\tstruct list_head ccw_queue;\n\tstruct dasd_ccw_req *cqr;\n\n\tINIT_LIST_HEAD(&ccw_queue);\n\tmaincqr->status = DASD_CQR_FILLED;\n\tdevice = maincqr->startdev;\n\tlist_add(&maincqr->blocklist, &ccw_queue);\n\tfor (cqr = maincqr;  __dasd_sleep_on_loop_condition(cqr);\n\t     cqr = list_first_entry(&ccw_queue,\n\t\t\t\t    struct dasd_ccw_req, blocklist)) {\n\n\t\tif (__dasd_sleep_on_erp(cqr))\n\t\t\tcontinue;\n\t\tif (cqr->status != DASD_CQR_FILLED)  \n\t\t\tcontinue;\n\t\tif (test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags) &&\n\t\t    !test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\n\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\tcqr->intrc = -EPERM;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (device->stopped & ~DASD_STOPPED_PENDING &&\n\t\t    test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&\n\t\t    !dasd_eer_enabled(device) && device->aq_mask == 0) {\n\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\tcqr->intrc = -ENOLINK;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (test_bit(DASD_FLAG_OFFLINE, &device->flags)) {\n\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\tcqr->intrc = -ENODEV;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags)) {\n\t\t\tif (interruptible) {\n\t\t\t\trc = wait_event_interruptible(\n\t\t\t\t\tgeneric_waitq, !(device->stopped));\n\t\t\t\tif (rc == -ERESTARTSYS) {\n\t\t\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\t\t\tmaincqr->intrc = rc;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\twait_event(generic_waitq, !(device->stopped));\n\t\t}\n\t\tif (!cqr->callback)\n\t\t\tcqr->callback = dasd_wakeup_cb;\n\n\t\tcqr->callback_data = DASD_SLEEPON_START_TAG;\n\t\tdasd_add_request_tail(cqr);\n\t\tif (interruptible) {\n\t\t\trc = wait_event_interruptible(\n\t\t\t\tgeneric_waitq, _wait_for_wakeup(cqr));\n\t\t\tif (rc == -ERESTARTSYS) {\n\t\t\t\tdasd_cancel_req(cqr);\n\t\t\t\t \n\t\t\t\twait_event(generic_waitq,\n\t\t\t\t\t   _wait_for_wakeup(cqr));\n\t\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\t\tmaincqr->intrc = rc;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else\n\t\t\twait_event(generic_waitq, _wait_for_wakeup(cqr));\n\t}\n\n\tmaincqr->endclk = get_tod_clock();\n\tif ((maincqr->status != DASD_CQR_DONE) &&\n\t    (maincqr->intrc != -ERESTARTSYS))\n\t\tdasd_log_sense(maincqr, &maincqr->irb);\n\tif (maincqr->status == DASD_CQR_DONE)\n\t\trc = 0;\n\telse if (maincqr->intrc)\n\t\trc = maincqr->intrc;\n\telse\n\t\trc = -EIO;\n\treturn rc;\n}\n\nstatic inline int _wait_for_wakeup_queue(struct list_head *ccw_queue)\n{\n\tstruct dasd_ccw_req *cqr;\n\n\tlist_for_each_entry(cqr, ccw_queue, blocklist) {\n\t\tif (cqr->callback_data != DASD_SLEEPON_END_TAG)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int _dasd_sleep_on_queue(struct list_head *ccw_queue, int interruptible)\n{\n\tstruct dasd_device *device;\n\tstruct dasd_ccw_req *cqr, *n;\n\tu8 *sense = NULL;\n\tint rc;\n\nretry:\n\tlist_for_each_entry_safe(cqr, n, ccw_queue, blocklist) {\n\t\tdevice = cqr->startdev;\n\t\tif (cqr->status != DASD_CQR_FILLED)  \n\t\t\tcontinue;\n\n\t\tif (test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags) &&\n\t\t    !test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\n\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\tcqr->intrc = -EPERM;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (device->stopped & ~DASD_STOPPED_PENDING &&\n\t\t    test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&\n\t\t    !dasd_eer_enabled(device)) {\n\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\tcqr->intrc = -EAGAIN;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (interruptible) {\n\t\t\trc = wait_event_interruptible(\n\t\t\t\tgeneric_waitq, !device->stopped);\n\t\t\tif (rc == -ERESTARTSYS) {\n\t\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\t\tcqr->intrc = rc;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else\n\t\t\twait_event(generic_waitq, !(device->stopped));\n\n\t\tif (!cqr->callback)\n\t\t\tcqr->callback = dasd_wakeup_cb;\n\t\tcqr->callback_data = DASD_SLEEPON_START_TAG;\n\t\tdasd_add_request_tail(cqr);\n\t}\n\n\twait_event(generic_waitq, _wait_for_wakeup_queue(ccw_queue));\n\n\trc = 0;\n\tlist_for_each_entry_safe(cqr, n, ccw_queue, blocklist) {\n\t\t \n\t\tsense = dasd_get_sense(&cqr->irb);\n\t\tif (sense && sense[1] & SNS1_FILE_PROTECTED &&\n\t\t    test_bit(DASD_CQR_SUPPRESS_FP, &cqr->flags))\n\t\t\tcontinue;\n\t\tif (scsw_cstat(&cqr->irb.scsw) == 0x40 &&\n\t\t    test_bit(DASD_CQR_SUPPRESS_IL, &cqr->flags))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (cqr->startdev != cqr->basedev && !cqr->refers &&\n\t\t    (cqr->status == DASD_CQR_TERMINATED ||\n\t\t     cqr->status == DASD_CQR_NEED_ERP))\n\t\t\treturn -EAGAIN;\n\n\t\t \n\t\tif (__dasd_sleep_on_erp(cqr))\n\t\t\t \n\t\t\tgoto retry;\n\t}\n\n\treturn 0;\n}\n\n \nint dasd_sleep_on(struct dasd_ccw_req *cqr)\n{\n\treturn _dasd_sleep_on(cqr, 0);\n}\nEXPORT_SYMBOL(dasd_sleep_on);\n\n \nint dasd_sleep_on_queue(struct list_head *ccw_queue)\n{\n\treturn _dasd_sleep_on_queue(ccw_queue, 0);\n}\nEXPORT_SYMBOL(dasd_sleep_on_queue);\n\n \nint dasd_sleep_on_queue_interruptible(struct list_head *ccw_queue)\n{\n\treturn _dasd_sleep_on_queue(ccw_queue, 1);\n}\nEXPORT_SYMBOL(dasd_sleep_on_queue_interruptible);\n\n \nint dasd_sleep_on_interruptible(struct dasd_ccw_req *cqr)\n{\n\treturn _dasd_sleep_on(cqr, 1);\n}\nEXPORT_SYMBOL(dasd_sleep_on_interruptible);\n\n \nstatic inline int _dasd_term_running_cqr(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc;\n\n\tif (list_empty(&device->ccw_queue))\n\t\treturn 0;\n\tcqr = list_entry(device->ccw_queue.next, struct dasd_ccw_req, devlist);\n\trc = device->discipline->term_IO(cqr);\n\tif (!rc)\n\t\t \n\t\tcqr->retries++;\n\treturn rc;\n}\n\nint dasd_sleep_on_immediatly(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\tint rc;\n\n\tdevice = cqr->startdev;\n\tif (test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags) &&\n\t    !test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\n\t\tcqr->status = DASD_CQR_FAILED;\n\t\tcqr->intrc = -EPERM;\n\t\treturn -EIO;\n\t}\n\tspin_lock_irq(get_ccwdev_lock(device->cdev));\n\trc = _dasd_term_running_cqr(device);\n\tif (rc) {\n\t\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\t\treturn rc;\n\t}\n\tcqr->callback = dasd_wakeup_cb;\n\tcqr->callback_data = DASD_SLEEPON_START_TAG;\n\tcqr->status = DASD_CQR_QUEUED;\n\t \n\tlist_add(&cqr->devlist, device->ccw_queue.next);\n\n\t \n\tdasd_schedule_device_bh(device);\n\n\tspin_unlock_irq(get_ccwdev_lock(device->cdev));\n\n\twait_event(generic_waitq, _wait_for_wakeup(cqr));\n\n\tif (cqr->status == DASD_CQR_DONE)\n\t\trc = 0;\n\telse if (cqr->intrc)\n\t\trc = cqr->intrc;\n\telse\n\t\trc = -EIO;\n\n\t \n\tdasd_schedule_device_bh(device);\n\tif (device->block)\n\t\tdasd_schedule_block_bh(device->block);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(dasd_sleep_on_immediatly);\n\n \nstatic int __dasd_cancel_req(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device = cqr->startdev;\n\tint rc = 0;\n\n\tswitch (cqr->status) {\n\tcase DASD_CQR_QUEUED:\n\t\t \n\t\tcqr->status = DASD_CQR_CLEARED;\n\t\tbreak;\n\tcase DASD_CQR_IN_IO:\n\t\t \n\t\trc = device->discipline->term_IO(cqr);\n\t\tif (rc) {\n\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t\"Cancelling request %p failed with rc=%d\\n\",\n\t\t\t\tcqr, rc);\n\t\t} else {\n\t\t\tcqr->stopclk = get_tod_clock();\n\t\t}\n\t\tbreak;\n\tdefault:  \n\t\tbreak;\n\t}\n\tdasd_schedule_device_bh(device);\n\treturn rc;\n}\n\nint dasd_cancel_req(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device = cqr->startdev;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\trc = __dasd_cancel_req(cqr);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\treturn rc;\n}\n\n \n\n \nstatic void dasd_block_timeout(struct timer_list *t)\n{\n\tunsigned long flags;\n\tstruct dasd_block *block;\n\n\tblock = from_timer(block, t, timer);\n\tspin_lock_irqsave(get_ccwdev_lock(block->base->cdev), flags);\n\t \n\tdasd_device_remove_stop_bits(block->base, DASD_STOPPED_PENDING);\n\tspin_unlock_irqrestore(get_ccwdev_lock(block->base->cdev), flags);\n\tdasd_schedule_block_bh(block);\n\tblk_mq_run_hw_queues(block->gdp->queue, true);\n}\n\n \nvoid dasd_block_set_timer(struct dasd_block *block, int expires)\n{\n\tif (expires == 0)\n\t\tdel_timer(&block->timer);\n\telse\n\t\tmod_timer(&block->timer, jiffies + expires);\n}\nEXPORT_SYMBOL(dasd_block_set_timer);\n\n \nvoid dasd_block_clear_timer(struct dasd_block *block)\n{\n\tdel_timer(&block->timer);\n}\nEXPORT_SYMBOL(dasd_block_clear_timer);\n\n \nstatic void __dasd_process_erp(struct dasd_device *device,\n\t\t\t       struct dasd_ccw_req *cqr)\n{\n\tdasd_erp_fn_t erp_fn;\n\n\tif (cqr->status == DASD_CQR_DONE)\n\t\tDBF_DEV_EVENT(DBF_NOTICE, device, \"%s\", \"ERP successful\");\n\telse\n\t\tdev_err(&device->cdev->dev, \"ERP failed for the DASD\\n\");\n\terp_fn = device->discipline->erp_postaction(cqr);\n\terp_fn(cqr);\n}\n\nstatic void __dasd_cleanup_cqr(struct dasd_ccw_req *cqr)\n{\n\tstruct request *req;\n\tblk_status_t error = BLK_STS_OK;\n\tunsigned int proc_bytes;\n\tint status;\n\n\treq = (struct request *) cqr->callback_data;\n\tdasd_profile_end(cqr->block, cqr, req);\n\n\tproc_bytes = cqr->proc_bytes;\n\tstatus = cqr->block->base->discipline->free_cp(cqr, req);\n\tif (status < 0)\n\t\terror = errno_to_blk_status(status);\n\telse if (status == 0) {\n\t\tswitch (cqr->intrc) {\n\t\tcase -EPERM:\n\t\t\t \n\t\t\terror = BLK_STS_RESV_CONFLICT;\n\t\t\tbreak;\n\t\tcase -ENOLINK:\n\t\t\terror = BLK_STS_TRANSPORT;\n\t\t\tbreak;\n\t\tcase -ETIMEDOUT:\n\t\t\terror = BLK_STS_TIMEOUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = BLK_STS_IOERR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (error) {\n\t\tblk_mq_end_request(req, error);\n\t\tblk_mq_run_hw_queues(req->q, true);\n\t} else {\n\t\t \n\t\tif (proc_bytes) {\n\t\t\tblk_update_request(req, BLK_STS_OK, proc_bytes);\n\t\t\tblk_mq_requeue_request(req, true);\n\t\t} else if (likely(!blk_should_fake_timeout(req->q))) {\n\t\t\tblk_mq_complete_request(req);\n\t\t}\n\t}\n}\n\n \nstatic void __dasd_process_block_ccw_queue(struct dasd_block *block,\n\t\t\t\t\t   struct list_head *final_queue)\n{\n\tstruct list_head *l, *n;\n\tstruct dasd_ccw_req *cqr;\n\tdasd_erp_fn_t erp_fn;\n\tunsigned long flags;\n\tstruct dasd_device *base = block->base;\n\nrestart:\n\t \n\tlist_for_each_safe(l, n, &block->ccw_queue) {\n\t\tcqr = list_entry(l, struct dasd_ccw_req, blocklist);\n\t\tif (cqr->status != DASD_CQR_DONE &&\n\t\t    cqr->status != DASD_CQR_FAILED &&\n\t\t    cqr->status != DASD_CQR_NEED_ERP &&\n\t\t    cqr->status != DASD_CQR_TERMINATED)\n\t\t\tcontinue;\n\n\t\tif (cqr->status == DASD_CQR_TERMINATED) {\n\t\t\tbase->discipline->handle_terminated_request(cqr);\n\t\t\tgoto restart;\n\t\t}\n\n\t\t \n\t\tif (cqr->status == DASD_CQR_NEED_ERP) {\n\t\t\terp_fn = base->discipline->erp_action(cqr);\n\t\t\tif (IS_ERR(erp_fn(cqr)))\n\t\t\t\tcontinue;\n\t\t\tgoto restart;\n\t\t}\n\n\t\t \n\t\tif (cqr->status == DASD_CQR_FAILED) {\n\t\t\tdasd_log_sense(cqr, &cqr->irb);\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);\n\t\tif (cqr->status == DASD_CQR_FAILED &&\n\t\t    dasd_handle_autoquiesce(base, cqr, DASD_EER_FATALERROR)) {\n\t\t\tcqr->status = DASD_CQR_FILLED;\n\t\t\tcqr->retries = 255;\n\t\t\tspin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);\n\t\t\tgoto restart;\n\t\t}\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);\n\n\t\t \n\t\tif (cqr->refers) {\n\t\t\t__dasd_process_erp(base, cqr);\n\t\t\tgoto restart;\n\t\t}\n\n\t\t \n\t\tcqr->endclk = get_tod_clock();\n\t\tlist_move_tail(&cqr->blocklist, final_queue);\n\t}\n}\n\nstatic void dasd_return_cqr_cb(struct dasd_ccw_req *cqr, void *data)\n{\n\tdasd_schedule_block_bh(cqr->block);\n}\n\nstatic void __dasd_block_start_head(struct dasd_block *block)\n{\n\tstruct dasd_ccw_req *cqr;\n\n\tif (list_empty(&block->ccw_queue))\n\t\treturn;\n\t \n\tlist_for_each_entry(cqr, &block->ccw_queue, blocklist) {\n\t\tif (cqr->status != DASD_CQR_FILLED)\n\t\t\tcontinue;\n\t\tif (test_bit(DASD_FLAG_LOCK_STOLEN, &block->base->flags) &&\n\t\t    !test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)) {\n\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\tcqr->intrc = -EPERM;\n\t\t\tdasd_schedule_block_bh(block);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (block->base->stopped & ~DASD_STOPPED_PENDING &&\n\t\t    test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&\n\t\t    !dasd_eer_enabled(block->base) && block->base->aq_mask == 0) {\n\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\tcqr->intrc = -ENOLINK;\n\t\t\tdasd_schedule_block_bh(block);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (block->base->stopped)\n\t\t\treturn;\n\n\t\t \n\t\tif (!cqr->startdev)\n\t\t\tcqr->startdev = block->base;\n\n\t\t \n\t\tcqr->callback = dasd_return_cqr_cb;\n\n\t\tdasd_add_request_tail(cqr);\n\t}\n}\n\n \nstatic void dasd_block_tasklet(unsigned long data)\n{\n\tstruct dasd_block *block = (struct dasd_block *) data;\n\tstruct list_head final_queue;\n\tstruct list_head *l, *n;\n\tstruct dasd_ccw_req *cqr;\n\tstruct dasd_queue *dq;\n\n\tatomic_set(&block->tasklet_scheduled, 0);\n\tINIT_LIST_HEAD(&final_queue);\n\tspin_lock_irq(&block->queue_lock);\n\t \n\t__dasd_process_block_ccw_queue(block, &final_queue);\n\tspin_unlock_irq(&block->queue_lock);\n\n\t \n\tlist_for_each_safe(l, n, &final_queue) {\n\t\tcqr = list_entry(l, struct dasd_ccw_req, blocklist);\n\t\tdq = cqr->dq;\n\t\tspin_lock_irq(&dq->lock);\n\t\tlist_del_init(&cqr->blocklist);\n\t\t__dasd_cleanup_cqr(cqr);\n\t\tspin_unlock_irq(&dq->lock);\n\t}\n\n\tspin_lock_irq(&block->queue_lock);\n\t \n\t__dasd_block_start_head(block);\n\tspin_unlock_irq(&block->queue_lock);\n\n\tif (waitqueue_active(&shutdown_waitq))\n\t\twake_up(&shutdown_waitq);\n\tdasd_put_device(block->base);\n}\n\nstatic void _dasd_wake_block_flush_cb(struct dasd_ccw_req *cqr, void *data)\n{\n\twake_up(&dasd_flush_wq);\n}\n\n \nstatic void _dasd_requeue_request(struct dasd_ccw_req *cqr)\n{\n\tstruct request *req;\n\n\t \n\tif (cqr->refers)\n\t\treturn;\n\tspin_lock_irq(&cqr->dq->lock);\n\treq = (struct request *) cqr->callback_data;\n\tblk_mq_requeue_request(req, true);\n\tspin_unlock_irq(&cqr->dq->lock);\n\n\treturn;\n}\n\nstatic int _dasd_requests_to_flushqueue(struct dasd_block *block,\n\t\t\t\t\tstruct list_head *flush_queue)\n{\n\tstruct dasd_ccw_req *cqr, *n;\n\tunsigned long flags;\n\tint rc, i;\n\n\tspin_lock_irqsave(&block->queue_lock, flags);\n\trc = 0;\nrestart:\n\tlist_for_each_entry_safe(cqr, n, &block->ccw_queue, blocklist) {\n\t\t \n\t\tif (cqr->status >= DASD_CQR_QUEUED)\n\t\t\trc = dasd_cancel_req(cqr);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\t \n\t\tcqr->callback = _dasd_wake_block_flush_cb;\n\t\tfor (i = 0; cqr; cqr = cqr->refers, i++)\n\t\t\tlist_move_tail(&cqr->blocklist, flush_queue);\n\t\tif (i > 1)\n\t\t\t \n\t\t\tgoto restart;\n\t}\n\tspin_unlock_irqrestore(&block->queue_lock, flags);\n\n\treturn rc;\n}\n\n \nstatic int dasd_flush_block_queue(struct dasd_block *block)\n{\n\tstruct dasd_ccw_req *cqr, *n;\n\tstruct list_head flush_queue;\n\tunsigned long flags;\n\tint rc;\n\n\tINIT_LIST_HEAD(&flush_queue);\n\trc = _dasd_requests_to_flushqueue(block, &flush_queue);\n\n\t \nrestart_cb:\n\tlist_for_each_entry_safe(cqr, n, &flush_queue, blocklist) {\n\t\twait_event(dasd_flush_wq, (cqr->status < DASD_CQR_QUEUED));\n\t\t \n\t\tif (cqr->refers) {\n\t\t\tspin_lock_bh(&block->queue_lock);\n\t\t\t__dasd_process_erp(block->base, cqr);\n\t\t\tspin_unlock_bh(&block->queue_lock);\n\t\t\t \n\t\t\tgoto restart_cb;\n\t\t}\n\t\t \n\t\tspin_lock_irqsave(&cqr->dq->lock, flags);\n\t\tcqr->endclk = get_tod_clock();\n\t\tlist_del_init(&cqr->blocklist);\n\t\t__dasd_cleanup_cqr(cqr);\n\t\tspin_unlock_irqrestore(&cqr->dq->lock, flags);\n\t}\n\treturn rc;\n}\n\n \nvoid dasd_schedule_block_bh(struct dasd_block *block)\n{\n\t \n\tif (atomic_cmpxchg(&block->tasklet_scheduled, 0, 1) != 0)\n\t\treturn;\n\t \n\tdasd_get_device(block->base);\n\ttasklet_hi_schedule(&block->tasklet);\n}\nEXPORT_SYMBOL(dasd_schedule_block_bh);\n\n\n \n\n \nstatic blk_status_t do_dasd_request(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t    const struct blk_mq_queue_data *qd)\n{\n\tstruct dasd_block *block = hctx->queue->queuedata;\n\tstruct dasd_queue *dq = hctx->driver_data;\n\tstruct request *req = qd->rq;\n\tstruct dasd_device *basedev;\n\tstruct dasd_ccw_req *cqr;\n\tblk_status_t rc = BLK_STS_OK;\n\n\tbasedev = block->base;\n\tspin_lock_irq(&dq->lock);\n\tif (basedev->state < DASD_STATE_READY ||\n\t    test_bit(DASD_FLAG_OFFLINE, &basedev->flags)) {\n\t\tDBF_DEV_EVENT(DBF_ERR, basedev,\n\t\t\t      \"device not ready for request %p\", req);\n\t\trc = BLK_STS_IOERR;\n\t\tgoto out;\n\t}\n\n\t \n\tif (basedev->stopped && !(basedev->features & DASD_FEATURE_FAILFAST)) {\n\t\tDBF_DEV_EVENT(DBF_ERR, basedev,\n\t\t\t      \"device stopped request %p\", req);\n\t\trc = BLK_STS_RESOURCE;\n\t\tgoto out;\n\t}\n\n\tif (basedev->features & DASD_FEATURE_READONLY &&\n\t    rq_data_dir(req) == WRITE) {\n\t\tDBF_DEV_EVENT(DBF_ERR, basedev,\n\t\t\t      \"Rejecting write request %p\", req);\n\t\trc = BLK_STS_IOERR;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(DASD_FLAG_ABORTALL, &basedev->flags) &&\n\t    (basedev->features & DASD_FEATURE_FAILFAST ||\n\t     blk_noretry_request(req))) {\n\t\tDBF_DEV_EVENT(DBF_ERR, basedev,\n\t\t\t      \"Rejecting failfast request %p\", req);\n\t\trc = BLK_STS_IOERR;\n\t\tgoto out;\n\t}\n\n\tcqr = basedev->discipline->build_cp(basedev, block, req);\n\tif (IS_ERR(cqr)) {\n\t\tif (PTR_ERR(cqr) == -EBUSY ||\n\t\t    PTR_ERR(cqr) == -ENOMEM ||\n\t\t    PTR_ERR(cqr) == -EAGAIN) {\n\t\t\trc = BLK_STS_RESOURCE;\n\t\t\tgoto out;\n\t\t}\n\t\tDBF_DEV_EVENT(DBF_ERR, basedev,\n\t\t\t      \"CCW creation failed (rc=%ld) on request %p\",\n\t\t\t      PTR_ERR(cqr), req);\n\t\trc = BLK_STS_IOERR;\n\t\tgoto out;\n\t}\n\t \n\tcqr->callback_data = req;\n\tcqr->status = DASD_CQR_FILLED;\n\tcqr->dq = dq;\n\n\tblk_mq_start_request(req);\n\tspin_lock(&block->queue_lock);\n\tlist_add_tail(&cqr->blocklist, &block->ccw_queue);\n\tINIT_LIST_HEAD(&cqr->devlist);\n\tdasd_profile_start(block, cqr, req);\n\tdasd_schedule_block_bh(block);\n\tspin_unlock(&block->queue_lock);\n\nout:\n\tspin_unlock_irq(&dq->lock);\n\treturn rc;\n}\n\n \nenum blk_eh_timer_return dasd_times_out(struct request *req)\n{\n\tstruct dasd_block *block = req->q->queuedata;\n\tstruct dasd_device *device;\n\tstruct dasd_ccw_req *cqr;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tcqr = blk_mq_rq_to_pdu(req);\n\tif (!cqr)\n\t\treturn BLK_EH_DONE;\n\n\tspin_lock_irqsave(&cqr->dq->lock, flags);\n\tdevice = cqr->startdev ? cqr->startdev : block->base;\n\tif (!device->blk_timeout) {\n\t\tspin_unlock_irqrestore(&cqr->dq->lock, flags);\n\t\treturn BLK_EH_RESET_TIMER;\n\t}\n\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t      \" dasd_times_out cqr %p status %x\",\n\t\t      cqr, cqr->status);\n\n\tspin_lock(&block->queue_lock);\n\tspin_lock(get_ccwdev_lock(device->cdev));\n\tcqr->retries = -1;\n\tcqr->intrc = -ETIMEDOUT;\n\tif (cqr->status >= DASD_CQR_QUEUED) {\n\t\trc = __dasd_cancel_req(cqr);\n\t} else if (cqr->status == DASD_CQR_FILLED ||\n\t\t   cqr->status == DASD_CQR_NEED_ERP) {\n\t\tcqr->status = DASD_CQR_TERMINATED;\n\t} else if (cqr->status == DASD_CQR_IN_ERP) {\n\t\tstruct dasd_ccw_req *searchcqr, *nextcqr, *tmpcqr;\n\n\t\tlist_for_each_entry_safe(searchcqr, nextcqr,\n\t\t\t\t\t &block->ccw_queue, blocklist) {\n\t\t\ttmpcqr = searchcqr;\n\t\t\twhile (tmpcqr->refers)\n\t\t\t\ttmpcqr = tmpcqr->refers;\n\t\t\tif (tmpcqr != cqr)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tsearchcqr->retries = -1;\n\t\t\tsearchcqr->intrc = -ETIMEDOUT;\n\t\t\tif (searchcqr->status >= DASD_CQR_QUEUED) {\n\t\t\t\trc = __dasd_cancel_req(searchcqr);\n\t\t\t} else if ((searchcqr->status == DASD_CQR_FILLED) ||\n\t\t\t\t   (searchcqr->status == DASD_CQR_NEED_ERP)) {\n\t\t\t\tsearchcqr->status = DASD_CQR_TERMINATED;\n\t\t\t\trc = 0;\n\t\t\t} else if (searchcqr->status == DASD_CQR_IN_ERP) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(get_ccwdev_lock(device->cdev));\n\tdasd_schedule_block_bh(block);\n\tspin_unlock(&block->queue_lock);\n\tspin_unlock_irqrestore(&cqr->dq->lock, flags);\n\n\treturn rc ? BLK_EH_RESET_TIMER : BLK_EH_DONE;\n}\n\nstatic int dasd_init_hctx(struct blk_mq_hw_ctx *hctx, void *data,\n\t\t\t  unsigned int idx)\n{\n\tstruct dasd_queue *dq = kzalloc(sizeof(*dq), GFP_KERNEL);\n\n\tif (!dq)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dq->lock);\n\thctx->driver_data = dq;\n\n\treturn 0;\n}\n\nstatic void dasd_exit_hctx(struct blk_mq_hw_ctx *hctx, unsigned int idx)\n{\n\tkfree(hctx->driver_data);\n\thctx->driver_data = NULL;\n}\n\nstatic void dasd_request_done(struct request *req)\n{\n\tblk_mq_end_request(req, 0);\n\tblk_mq_run_hw_queues(req->q, true);\n}\n\nstruct blk_mq_ops dasd_mq_ops = {\n\t.queue_rq = do_dasd_request,\n\t.complete = dasd_request_done,\n\t.timeout = dasd_times_out,\n\t.init_hctx = dasd_init_hctx,\n\t.exit_hctx = dasd_exit_hctx,\n};\n\nstatic int dasd_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct dasd_device *base;\n\tint rc;\n\n\tbase = dasd_device_from_gendisk(disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\n\tatomic_inc(&base->block->open_count);\n\tif (test_bit(DASD_FLAG_OFFLINE, &base->flags)) {\n\t\trc = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tif (!try_module_get(base->discipline->owner)) {\n\t\trc = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (dasd_probeonly) {\n\t\tdev_info(&base->cdev->dev,\n\t\t\t \"Accessing the DASD failed because it is in \"\n\t\t\t \"probeonly mode\\n\");\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (base->state <= DASD_STATE_BASIC) {\n\t\tDBF_DEV_EVENT(DBF_ERR, base, \" %s\",\n\t\t\t      \" Cannot open unrecognized device\");\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\tif ((mode & BLK_OPEN_WRITE) &&\n\t    (test_bit(DASD_FLAG_DEVICE_RO, &base->flags) ||\n\t     (base->features & DASD_FEATURE_READONLY))) {\n\t\trc = -EROFS;\n\t\tgoto out;\n\t}\n\tdasd_put_device(base);\n\treturn 0;\n\nout:\n\tmodule_put(base->discipline->owner);\nunlock:\n\tatomic_dec(&base->block->open_count);\n\tdasd_put_device(base);\n\treturn rc;\n}\n\nstatic void dasd_release(struct gendisk *disk)\n{\n\tstruct dasd_device *base = dasd_device_from_gendisk(disk);\n\tif (base) {\n\t\tatomic_dec(&base->block->open_count);\n\t\tmodule_put(base->discipline->owner);\n\t\tdasd_put_device(base);\n\t}\n}\n\n \nstatic int dasd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tstruct dasd_device *base;\n\n\tbase = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\n\tif (!base->discipline ||\n\t    !base->discipline->fill_geometry) {\n\t\tdasd_put_device(base);\n\t\treturn -EINVAL;\n\t}\n\tbase->discipline->fill_geometry(base->block, geo);\n\tgeo->start = get_start_sect(bdev) >> base->block->s2b_shift;\n\tdasd_put_device(base);\n\treturn 0;\n}\n\nconst struct block_device_operations\ndasd_device_operations = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= dasd_open,\n\t.release\t= dasd_release,\n\t.ioctl\t\t= dasd_ioctl,\n\t.compat_ioctl\t= dasd_ioctl,\n\t.getgeo\t\t= dasd_getgeo,\n\t.set_read_only\t= dasd_set_read_only,\n};\n\n \n\nstatic void\ndasd_exit(void)\n{\n#ifdef CONFIG_PROC_FS\n\tdasd_proc_exit();\n#endif\n\tdasd_eer_exit();\n\tkmem_cache_destroy(dasd_page_cache);\n\tdasd_page_cache = NULL;\n\tdasd_gendisk_exit();\n\tdasd_devmap_exit();\n\tif (dasd_debug_area != NULL) {\n\t\tdebug_unregister(dasd_debug_area);\n\t\tdasd_debug_area = NULL;\n\t}\n\tdasd_statistics_removeroot();\n}\n\n \n\n \nint dasd_device_is_ro(struct dasd_device *device)\n{\n\tstruct ccw_dev_id dev_id;\n\tstruct diag210 diag_data;\n\tint rc;\n\n\tif (!MACHINE_IS_VM)\n\t\treturn 0;\n\tccw_device_get_id(device->cdev, &dev_id);\n\tmemset(&diag_data, 0, sizeof(diag_data));\n\tdiag_data.vrdcdvno = dev_id.devno;\n\tdiag_data.vrdclen = sizeof(diag_data);\n\trc = diag210(&diag_data);\n\tif (rc == 0 || rc == 2) {\n\t\treturn diag_data.vrdcvfla & 0x80;\n\t} else {\n\t\tDBF_EVENT(DBF_WARNING, \"diag210 failed for dev=%04x with rc=%d\",\n\t\t\t  dev_id.devno, rc);\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(dasd_device_is_ro);\n\nstatic void dasd_generic_auto_online(void *data, async_cookie_t cookie)\n{\n\tstruct ccw_device *cdev = data;\n\tint ret;\n\n\tret = ccw_device_set_online(cdev);\n\tif (ret)\n\t\tpr_warn(\"%s: Setting the DASD online failed with rc=%d\\n\",\n\t\t\tdev_name(&cdev->dev), ret);\n}\n\n \nint dasd_generic_probe(struct ccw_device *cdev)\n{\n\tcdev->handler = &dasd_int_handler;\n\n\t \n\tif ((dasd_get_feature(cdev, DASD_FEATURE_INITIAL_ONLINE) > 0 ) ||\n\t    (dasd_autodetect && dasd_busid_known(dev_name(&cdev->dev)) != 0))\n\t\tasync_schedule(dasd_generic_auto_online, cdev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_probe);\n\nvoid dasd_generic_free_discipline(struct dasd_device *device)\n{\n\t \n\tif (device->discipline) {\n\t\tif (device->discipline->uncheck_device)\n\t\t\tdevice->discipline->uncheck_device(device);\n\t\tmodule_put(device->discipline->owner);\n\t\tdevice->discipline = NULL;\n\t}\n\tif (device->base_discipline) {\n\t\tmodule_put(device->base_discipline->owner);\n\t\tdevice->base_discipline = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(dasd_generic_free_discipline);\n\n \nvoid dasd_generic_remove(struct ccw_device *cdev)\n{\n\tstruct dasd_device *device;\n\tstruct dasd_block *block;\n\n\tdevice = dasd_device_from_cdev(cdev);\n\tif (IS_ERR(device))\n\t\treturn;\n\n\tif (test_and_set_bit(DASD_FLAG_OFFLINE, &device->flags) &&\n\t    !test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\n\t\t \n\t\tdasd_put_device(device);\n\t\treturn;\n\t}\n\t \n\tdasd_set_target_state(device, DASD_STATE_NEW);\n\tcdev->handler = NULL;\n\t \n\tblock = device->block;\n\tdasd_delete_device(device);\n\t \n\tif (block)\n\t\tdasd_free_block(block);\n}\nEXPORT_SYMBOL_GPL(dasd_generic_remove);\n\n \nint dasd_generic_set_online(struct ccw_device *cdev,\n\t\t\t    struct dasd_discipline *base_discipline)\n{\n\tstruct dasd_discipline *discipline;\n\tstruct dasd_device *device;\n\tint rc;\n\n\t \n\tdasd_set_feature(cdev, DASD_FEATURE_INITIAL_ONLINE, 0);\n\tdevice = dasd_create_device(cdev);\n\tif (IS_ERR(device))\n\t\treturn PTR_ERR(device);\n\n\tdiscipline = base_discipline;\n\tif (device->features & DASD_FEATURE_USEDIAG) {\n\t  \tif (!dasd_diag_discipline_pointer) {\n\t\t\t \n\t\t\trc = request_module(DASD_DIAG_MOD);\n\t\t\tif (rc) {\n\t\t\t\tpr_warn(\"%s Setting the DASD online failed \"\n\t\t\t\t\t\"because the required module %s \"\n\t\t\t\t\t\"could not be loaded (rc=%d)\\n\",\n\t\t\t\t\tdev_name(&cdev->dev), DASD_DIAG_MOD,\n\t\t\t\t\trc);\n\t\t\t\tdasd_delete_device(device);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!dasd_diag_discipline_pointer) {\n\t\t\tpr_warn(\"%s Setting the DASD online failed because of missing DIAG discipline\\n\",\n\t\t\t\tdev_name(&cdev->dev));\n\t\t\tdasd_delete_device(device);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tdiscipline = dasd_diag_discipline_pointer;\n\t}\n\tif (!try_module_get(base_discipline->owner)) {\n\t\tdasd_delete_device(device);\n\t\treturn -EINVAL;\n\t}\n\tif (!try_module_get(discipline->owner)) {\n\t\tmodule_put(base_discipline->owner);\n\t\tdasd_delete_device(device);\n\t\treturn -EINVAL;\n\t}\n\tdevice->base_discipline = base_discipline;\n\tdevice->discipline = discipline;\n\n\t \n\trc = discipline->check_device(device);\n\tif (rc) {\n\t\tpr_warn(\"%s Setting the DASD online with discipline %s failed with rc=%i\\n\",\n\t\t\tdev_name(&cdev->dev), discipline->name, rc);\n\t\tmodule_put(discipline->owner);\n\t\tmodule_put(base_discipline->owner);\n\t\tdasd_delete_device(device);\n\t\treturn rc;\n\t}\n\n\tdasd_set_target_state(device, DASD_STATE_ONLINE);\n\tif (device->state <= DASD_STATE_KNOWN) {\n\t\tpr_warn(\"%s Setting the DASD online failed because of a missing discipline\\n\",\n\t\t\tdev_name(&cdev->dev));\n\t\trc = -ENODEV;\n\t\tdasd_set_target_state(device, DASD_STATE_NEW);\n\t\tif (device->block)\n\t\t\tdasd_free_block(device->block);\n\t\tdasd_delete_device(device);\n\t} else\n\t\tpr_debug(\"dasd_generic device %s found\\n\",\n\t\t\t\tdev_name(&cdev->dev));\n\n\twait_event(dasd_init_waitq, _wait_for_device(device));\n\n\tdasd_put_device(device);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_set_online);\n\nint dasd_generic_set_offline(struct ccw_device *cdev)\n{\n\tstruct dasd_device *device;\n\tstruct dasd_block *block;\n\tint max_count, open_count, rc;\n\tunsigned long flags;\n\n\trc = 0;\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tdevice = dasd_device_from_cdev_locked(cdev);\n\tif (IS_ERR(device)) {\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\t\treturn PTR_ERR(device);\n\t}\n\n\t \n\tif (device->block) {\n\t\tmax_count = device->block->bdev ? 0 : -1;\n\t\topen_count = atomic_read(&device->block->open_count);\n\t\tif (open_count > max_count) {\n\t\t\tif (open_count > 0)\n\t\t\t\tpr_warn(\"%s: The DASD cannot be set offline with open count %i\\n\",\n\t\t\t\t\tdev_name(&cdev->dev), open_count);\n\t\t\telse\n\t\t\t\tpr_warn(\"%s: The DASD cannot be set offline while it is in use\\n\",\n\t\t\t\t\tdev_name(&cdev->dev));\n\t\t\trc = -EBUSY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\tif (test_bit(DASD_FLAG_OFFLINE, &device->flags)) {\n\t\tif (test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\n\t\t\tclear_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING,\n\t\t\t\t  &device->flags);\n\t\t} else {\n\t\t\trc = -EBUSY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tset_bit(DASD_FLAG_OFFLINE, &device->flags);\n\n\t \n\tif (test_and_clear_bit(DASD_FLAG_SAFE_OFFLINE, &device->flags) &&\n\t    !test_and_set_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\n\t\t \n\t\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\t\t \n\t\tif (device->block)\n\t\t\tbdev_mark_dead(device->block->bdev, false);\n\t\tdasd_schedule_device_bh(device);\n\t\trc = wait_event_interruptible(shutdown_waitq,\n\t\t\t\t\t      _wait_for_empty_queues(device));\n\t\tif (rc != 0)\n\t\t\tgoto interrupted;\n\n\t\t \n\t\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\t\tif (!test_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\n\t\t\trc = -ERESTARTSYS;\n\t\t\tgoto out_err;\n\t\t}\n\t\tclear_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags);\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\n\tdasd_set_target_state(device, DASD_STATE_NEW);\n\t \n\tblock = device->block;\n\tdasd_delete_device(device);\n\t \n\tif (block)\n\t\tdasd_free_block(block);\n\n\treturn 0;\n\ninterrupted:\n\t \n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tclear_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags);\n\tclear_bit(DASD_FLAG_OFFLINE, &device->flags);\nout_err:\n\tdasd_put_device(device);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_set_offline);\n\nint dasd_generic_last_path_gone(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\n\tdev_warn(&device->cdev->dev, \"No operational channel path is left \"\n\t\t \"for the device\\n\");\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\", \"last path gone\");\n\t \n\tdasd_handle_autoquiesce(device, NULL, DASD_EER_NOPATH);\n\n\tif (device->state < DASD_STATE_BASIC)\n\t\treturn 0;\n\t \n\tlist_for_each_entry(cqr, &device->ccw_queue, devlist)\n\t\tif ((cqr->status == DASD_CQR_IN_IO) ||\n\t\t    (cqr->status == DASD_CQR_CLEAR_PENDING)) {\n\t\t\tcqr->status = DASD_CQR_QUEUED;\n\t\t\tcqr->retries++;\n\t\t}\n\tdasd_device_set_stop_bits(device, DASD_STOPPED_DC_WAIT);\n\tdasd_device_clear_timer(device);\n\tdasd_schedule_device_bh(device);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_last_path_gone);\n\nint dasd_generic_path_operational(struct dasd_device *device)\n{\n\tdev_info(&device->cdev->dev, \"A channel path to the device has become \"\n\t\t \"operational\\n\");\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\", \"path operational\");\n\tdasd_device_remove_stop_bits(device, DASD_STOPPED_DC_WAIT);\n\tdasd_schedule_device_bh(device);\n\tif (device->block) {\n\t\tdasd_schedule_block_bh(device->block);\n\t\tif (device->block->gdp)\n\t\t\tblk_mq_run_hw_queues(device->block->gdp->queue, true);\n\t}\n\n\tif (!device->stopped)\n\t\twake_up(&generic_waitq);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_path_operational);\n\nint dasd_generic_notify(struct ccw_device *cdev, int event)\n{\n\tstruct dasd_device *device;\n\tint ret;\n\n\tdevice = dasd_device_from_cdev_locked(cdev);\n\tif (IS_ERR(device))\n\t\treturn 0;\n\tret = 0;\n\tswitch (event) {\n\tcase CIO_GONE:\n\tcase CIO_BOXED:\n\tcase CIO_NO_PATH:\n\t\tdasd_path_no_path(device);\n\t\tret = dasd_generic_last_path_gone(device);\n\t\tbreak;\n\tcase CIO_OPER:\n\t\tret = 1;\n\t\tif (dasd_path_get_opm(device))\n\t\t\tret = dasd_generic_path_operational(device);\n\t\tbreak;\n\t}\n\tdasd_put_device(device);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_notify);\n\nvoid dasd_generic_path_event(struct ccw_device *cdev, int *path_event)\n{\n\tstruct dasd_device *device;\n\tint chp, oldopm, hpfpm, ifccpm;\n\n\tdevice = dasd_device_from_cdev_locked(cdev);\n\tif (IS_ERR(device))\n\t\treturn;\n\n\toldopm = dasd_path_get_opm(device);\n\tfor (chp = 0; chp < 8; chp++) {\n\t\tif (path_event[chp] & PE_PATH_GONE) {\n\t\t\tdasd_path_notoper(device, chp);\n\t\t}\n\t\tif (path_event[chp] & PE_PATH_AVAILABLE) {\n\t\t\tdasd_path_available(device, chp);\n\t\t\tdasd_schedule_device_bh(device);\n\t\t}\n\t\tif (path_event[chp] & PE_PATHGROUP_ESTABLISHED) {\n\t\t\tif (!dasd_path_is_operational(device, chp) &&\n\t\t\t    !dasd_path_need_verify(device, chp)) {\n\t\t\t\t \n\t\t\tdasd_path_available(device, chp);\n\t\t\tdasd_schedule_device_bh(device);\n\t\t\t}\n\t\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t\t      \"Pathgroup re-established\\n\");\n\t\t\tif (device->discipline->kick_validate)\n\t\t\t\tdevice->discipline->kick_validate(device);\n\t\t}\n\t\tif (path_event[chp] & PE_PATH_FCES_EVENT) {\n\t\t\tdasd_path_fcsec_update(device, chp);\n\t\t\tdasd_schedule_device_bh(device);\n\t\t}\n\t}\n\thpfpm = dasd_path_get_hpfpm(device);\n\tifccpm = dasd_path_get_ifccpm(device);\n\tif (!dasd_path_get_opm(device) && hpfpm) {\n\t\t \n\t\tif (device->discipline->disable_hpf)\n\t\t\tdevice->discipline->disable_hpf(device);\n\t\tdasd_device_set_stop_bits(device, DASD_STOPPED_NOT_ACC);\n\t\tdasd_path_set_tbvpm(device, hpfpm);\n\t\tdasd_schedule_device_bh(device);\n\t\tdasd_schedule_requeue(device);\n\t} else if (!dasd_path_get_opm(device) && ifccpm) {\n\t\t \n\t\tdasd_path_set_tbvpm(device, ifccpm);\n\t\tdasd_schedule_device_bh(device);\n\t}\n\tif (oldopm && !dasd_path_get_opm(device) && !hpfpm && !ifccpm) {\n\t\tdev_warn(&device->cdev->dev,\n\t\t\t \"No verified channel paths remain for the device\\n\");\n\t\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t\t      \"%s\", \"last verified path gone\");\n\t\t \n\t\tdasd_handle_autoquiesce(device, NULL, DASD_EER_NOPATH);\n\t\tdasd_device_set_stop_bits(device,\n\t\t\t\t\t  DASD_STOPPED_DC_WAIT);\n\t}\n\tdasd_put_device(device);\n}\nEXPORT_SYMBOL_GPL(dasd_generic_path_event);\n\nint dasd_generic_verify_path(struct dasd_device *device, __u8 lpm)\n{\n\tif (!dasd_path_get_opm(device) && lpm) {\n\t\tdasd_path_set_opm(device, lpm);\n\t\tdasd_generic_path_operational(device);\n\t} else\n\t\tdasd_path_add_opm(device, lpm);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_verify_path);\n\nvoid dasd_generic_space_exhaust(struct dasd_device *device,\n\t\t\t\tstruct dasd_ccw_req *cqr)\n{\n\t \n\tdasd_handle_autoquiesce(device, NULL, DASD_EER_NOSPC);\n\n\tif (device->state < DASD_STATE_BASIC)\n\t\treturn;\n\n\tif (cqr->status == DASD_CQR_IN_IO ||\n\t    cqr->status == DASD_CQR_CLEAR_PENDING) {\n\t\tcqr->status = DASD_CQR_QUEUED;\n\t\tcqr->retries++;\n\t}\n\tdasd_device_set_stop_bits(device, DASD_STOPPED_NOSPC);\n\tdasd_device_clear_timer(device);\n\tdasd_schedule_device_bh(device);\n}\nEXPORT_SYMBOL_GPL(dasd_generic_space_exhaust);\n\nvoid dasd_generic_space_avail(struct dasd_device *device)\n{\n\tdev_info(&device->cdev->dev, \"Extent pool space is available\\n\");\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\", \"space available\");\n\n\tdasd_device_remove_stop_bits(device, DASD_STOPPED_NOSPC);\n\tdasd_schedule_device_bh(device);\n\n\tif (device->block) {\n\t\tdasd_schedule_block_bh(device->block);\n\t\tif (device->block->gdp)\n\t\t\tblk_mq_run_hw_queues(device->block->gdp->queue, true);\n\t}\n\tif (!device->stopped)\n\t\twake_up(&generic_waitq);\n}\nEXPORT_SYMBOL_GPL(dasd_generic_space_avail);\n\n \nint dasd_generic_requeue_all_requests(struct dasd_device *device)\n{\n\tstruct dasd_block *block = device->block;\n\tstruct list_head requeue_queue;\n\tstruct dasd_ccw_req *cqr, *n;\n\tint rc;\n\n\tif (!block)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&requeue_queue);\n\trc = _dasd_requests_to_flushqueue(block, &requeue_queue);\n\n\t \nrestart_cb:\n\tlist_for_each_entry_safe(cqr, n, &requeue_queue, blocklist) {\n\t\twait_event(dasd_flush_wq, (cqr->status < DASD_CQR_QUEUED));\n\t\t \n\t\tif (cqr->refers) {\n\t\t\tspin_lock_bh(&block->queue_lock);\n\t\t\t__dasd_process_erp(block->base, cqr);\n\t\t\tspin_unlock_bh(&block->queue_lock);\n\t\t\t \n\t\t\tgoto restart_cb;\n\t\t}\n\t\t_dasd_requeue_request(cqr);\n\t\tlist_del_init(&cqr->blocklist);\n\t\tcqr->block->base->discipline->free_cp(\n\t\t\tcqr, (struct request *) cqr->callback_data);\n\t}\n\tdasd_schedule_device_bh(device);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_requeue_all_requests);\n\nstatic void do_requeue_requests(struct work_struct *work)\n{\n\tstruct dasd_device *device = container_of(work, struct dasd_device,\n\t\t\t\t\t\t  requeue_requests);\n\tdasd_generic_requeue_all_requests(device);\n\tdasd_device_remove_stop_bits(device, DASD_STOPPED_NOT_ACC);\n\tif (device->block)\n\t\tdasd_schedule_block_bh(device->block);\n\tdasd_put_device(device);\n}\n\nvoid dasd_schedule_requeue(struct dasd_device *device)\n{\n\tdasd_get_device(device);\n\t \n\tif (!schedule_work(&device->requeue_requests))\n\t\tdasd_put_device(device);\n}\nEXPORT_SYMBOL(dasd_schedule_requeue);\n\nstatic int dasd_handle_autoquiesce(struct dasd_device *device,\n\t\t\t\t   struct dasd_ccw_req *cqr,\n\t\t\t\t   unsigned int reason)\n{\n\t \n\tif (dasd_eer_enabled(device))\n\t\tdasd_eer_write(device, cqr, reason);\n\n\tif (!test_bit(reason, &device->aq_mask))\n\t\treturn 0;\n\n\t \n\tif (dasd_eer_enabled(device))\n\t\tdasd_eer_write(device, NULL, DASD_EER_AUTOQUIESCE);\n\n\tpr_info(\"%s: The DASD has been put in the quiesce state\\n\",\n\t\tdev_name(&device->cdev->dev));\n\tdasd_device_set_stop_bits(device, DASD_STOPPED_QUIESCE);\n\n\tif (device->features & DASD_FEATURE_REQUEUEQUIESCE)\n\t\tdasd_schedule_requeue(device);\n\n\treturn 1;\n}\n\nstatic struct dasd_ccw_req *dasd_generic_build_rdc(struct dasd_device *device,\n\t\t\t\t\t\t   int rdc_buffer_size,\n\t\t\t\t\t\t   int magic)\n{\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\n\tcqr = dasd_smalloc_request(magic, 1  , rdc_buffer_size, device,\n\t\t\t\t   NULL);\n\n\tif (IS_ERR(cqr)) {\n\t\t \n\t\tdev_err(&device->cdev->dev,\n\t\t\t \"An error occurred in the DASD device driver, \"\n\t\t\t \"reason=%s\\n\", \"13\");\n\t\treturn cqr;\n\t}\n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = CCW_CMD_RDC;\n\tccw->cda = (__u32)virt_to_phys(cqr->data);\n\tccw->flags = 0;\n\tccw->count = rdc_buffer_size;\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->expires = 10*HZ;\n\tcqr->retries = 256;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\treturn cqr;\n}\n\n\nint dasd_generic_read_dev_chars(struct dasd_device *device, int magic,\n\t\t\t\tvoid *rdc_buffer, int rdc_buffer_size)\n{\n\tint ret;\n\tstruct dasd_ccw_req *cqr;\n\n\tcqr = dasd_generic_build_rdc(device, rdc_buffer_size, magic);\n\tif (IS_ERR(cqr))\n\t\treturn PTR_ERR(cqr);\n\n\tret = dasd_sleep_on(cqr);\n\tif (ret == 0)\n\t\tmemcpy(rdc_buffer, cqr->data, rdc_buffer_size);\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dasd_generic_read_dev_chars);\n\n \nchar *dasd_get_sense(struct irb *irb)\n{\n\tstruct tsb *tsb = NULL;\n\tchar *sense = NULL;\n\n\tif (scsw_is_tm(&irb->scsw) && (irb->scsw.tm.fcxs == 0x01)) {\n\t\tif (irb->scsw.tm.tcw)\n\t\t\ttsb = tcw_get_tsb(phys_to_virt(irb->scsw.tm.tcw));\n\t\tif (tsb && tsb->length == 64 && tsb->flags)\n\t\t\tswitch (tsb->flags & 0x07) {\n\t\t\tcase 1:\t \n\t\t\t\tsense = tsb->tsa.iostat.sense;\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\tsense = tsb->tsa.ddpc.sense;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t} else if (irb->esw.esw0.erw.cons) {\n\t\tsense = irb->ecw;\n\t}\n\treturn sense;\n}\nEXPORT_SYMBOL_GPL(dasd_get_sense);\n\nvoid dasd_generic_shutdown(struct ccw_device *cdev)\n{\n\tstruct dasd_device *device;\n\n\tdevice = dasd_device_from_cdev(cdev);\n\tif (IS_ERR(device))\n\t\treturn;\n\n\tif (device->block)\n\t\tdasd_schedule_block_bh(device->block);\n\n\tdasd_schedule_device_bh(device);\n\n\twait_event(shutdown_waitq, _wait_for_empty_queues(device));\n}\nEXPORT_SYMBOL_GPL(dasd_generic_shutdown);\n\nstatic int __init dasd_init(void)\n{\n\tint rc;\n\n\tinit_waitqueue_head(&dasd_init_waitq);\n\tinit_waitqueue_head(&dasd_flush_wq);\n\tinit_waitqueue_head(&generic_waitq);\n\tinit_waitqueue_head(&shutdown_waitq);\n\n\t \n\tdasd_debug_area = debug_register(\"dasd\", 1, 1, 8 * sizeof(long));\n\tif (dasd_debug_area == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto failed;\n\t}\n\tdebug_register_view(dasd_debug_area, &debug_sprintf_view);\n\tdebug_set_level(dasd_debug_area, DBF_WARNING);\n\n\tDBF_EVENT(DBF_EMERG, \"%s\", \"debug area created\");\n\n\tdasd_diag_discipline_pointer = NULL;\n\n\tdasd_statistics_createroot();\n\n\trc = dasd_devmap_init();\n\tif (rc)\n\t\tgoto failed;\n\trc = dasd_gendisk_init();\n\tif (rc)\n\t\tgoto failed;\n\trc = dasd_parse();\n\tif (rc)\n\t\tgoto failed;\n\trc = dasd_eer_init();\n\tif (rc)\n\t\tgoto failed;\n#ifdef CONFIG_PROC_FS\n\trc = dasd_proc_init();\n\tif (rc)\n\t\tgoto failed;\n#endif\n\n\treturn 0;\nfailed:\n\tpr_info(\"The DASD device driver could not be initialized\\n\");\n\tdasd_exit();\n\treturn rc;\n}\n\nmodule_init(dasd_init);\nmodule_exit(dasd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}