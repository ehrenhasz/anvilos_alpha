{
  "module_name": "dasd_eckd.c",
  "hash_id": "ca09c58874d04c963fd101e8402e628a232960769dfe5aa3025a9ebe93f4a829",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_eckd.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd-eckd\"\n\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/hdreg.h>\t \n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#include <asm/css_chars.h>\n#include <asm/debug.h>\n#include <asm/idals.h>\n#include <asm/ebcdic.h>\n#include <asm/cio.h>\n#include <asm/ccwdev.h>\n#include <asm/itcw.h>\n#include <asm/schid.h>\n#include <asm/chpid.h>\n\n#include \"dasd_int.h\"\n#include \"dasd_eckd.h\"\n\n#ifdef PRINTK_HEADER\n#undef PRINTK_HEADER\n#endif\t\t\t\t \n#define PRINTK_HEADER \"dasd(eckd):\"\n\n \n#define DASD_RAW_BLOCK_PER_TRACK 16\n#define DASD_RAW_BLOCKSIZE 4096\n \n#define DASD_RAW_SECTORS_PER_TRACK 128\n\nMODULE_LICENSE(\"GPL\");\n\nstatic struct dasd_discipline dasd_eckd_discipline;\n\n \nstatic struct ccw_device_id dasd_eckd_ids[] = {\n\t{ CCW_DEVICE_DEVTYPE (0x3990, 0, 0x3390, 0), .driver_info = 0x1},\n\t{ CCW_DEVICE_DEVTYPE (0x2105, 0, 0x3390, 0), .driver_info = 0x2},\n\t{ CCW_DEVICE_DEVTYPE (0x3880, 0, 0x3380, 0), .driver_info = 0x3},\n\t{ CCW_DEVICE_DEVTYPE (0x3990, 0, 0x3380, 0), .driver_info = 0x4},\n\t{ CCW_DEVICE_DEVTYPE (0x2105, 0, 0x3380, 0), .driver_info = 0x5},\n\t{ CCW_DEVICE_DEVTYPE (0x9343, 0, 0x9345, 0), .driver_info = 0x6},\n\t{ CCW_DEVICE_DEVTYPE (0x2107, 0, 0x3390, 0), .driver_info = 0x7},\n\t{ CCW_DEVICE_DEVTYPE (0x2107, 0, 0x3380, 0), .driver_info = 0x8},\n\t{ CCW_DEVICE_DEVTYPE (0x1750, 0, 0x3390, 0), .driver_info = 0x9},\n\t{ CCW_DEVICE_DEVTYPE (0x1750, 0, 0x3380, 0), .driver_info = 0xa},\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(ccw, dasd_eckd_ids);\n\nstatic struct ccw_driver dasd_eckd_driver;  \n\nstatic void *rawpadpage;\n\n#define INIT_CQR_OK 0\n#define INIT_CQR_UNFORMATTED 1\n#define INIT_CQR_ERROR 2\n\n \nstatic struct {\n\tstruct dasd_ccw_req cqr;\n\tstruct ccw1 ccw;\n\tchar data[32];\n} *dasd_reserve_req;\nstatic DEFINE_MUTEX(dasd_reserve_mutex);\n\nstatic struct {\n\tstruct dasd_ccw_req cqr;\n\tstruct ccw1 ccw[2];\n\tchar data[40];\n} *dasd_vol_info_req;\nstatic DEFINE_MUTEX(dasd_vol_info_mutex);\n\nstruct ext_pool_exhaust_work_data {\n\tstruct work_struct worker;\n\tstruct dasd_device *device;\n\tstruct dasd_device *base;\n};\n\n \nstruct pe_handler_work_data {\n\tstruct work_struct worker;\n\tstruct dasd_device *device;\n\tstruct dasd_ccw_req cqr;\n\tstruct ccw1 ccw;\n\t__u8 rcd_buffer[DASD_ECKD_RCD_DATA_SIZE];\n\tint isglobal;\n\t__u8 tbvpm;\n\t__u8 fcsecpm;\n};\nstatic struct pe_handler_work_data *pe_handler_worker;\nstatic DEFINE_MUTEX(dasd_pe_handler_mutex);\n\nstruct check_attention_work_data {\n\tstruct work_struct worker;\n\tstruct dasd_device *device;\n\t__u8 lpum;\n};\n\nstatic int dasd_eckd_ext_pool_id(struct dasd_device *);\nstatic int prepare_itcw(struct itcw *, unsigned int, unsigned int, int,\n\t\t\tstruct dasd_device *, struct dasd_device *,\n\t\t\tunsigned int, int, unsigned int, unsigned int,\n\t\t\tunsigned int, unsigned int);\nstatic int dasd_eckd_query_pprc_status(struct dasd_device *,\n\t\t\t\t       struct dasd_pprc_data_sc4 *);\n\n \nstatic int\ndasd_eckd_probe (struct ccw_device *cdev)\n{\n\tint ret;\n\n\t \n\tret = ccw_device_set_options(cdev, CCWDEV_ALLOW_FORCE |\n\t\t\t\t     CCWDEV_DO_PATHGROUP | CCWDEV_DO_MULTIPATH);\n\tif (ret) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, cdev, \"%s\",\n\t\t\t\t\"dasd_eckd_probe: could not set \"\n\t\t\t\t\"ccw-device options\");\n\t\treturn ret;\n\t}\n\tret = dasd_generic_probe(cdev);\n\treturn ret;\n}\n\nstatic int\ndasd_eckd_set_online(struct ccw_device *cdev)\n{\n\treturn dasd_generic_set_online(cdev, &dasd_eckd_discipline);\n}\n\nstatic const int sizes_trk0[] = { 28, 148, 84 };\n#define LABEL_SIZE 140\n\n \nstatic const int count_area_head[] = { 0, 0, 0, 0, 1 };\nstatic const int count_area_rec[] = { 1, 2, 3, 4, 1 };\n\nstatic inline unsigned int\nceil_quot(unsigned int d1, unsigned int d2)\n{\n\treturn (d1 + (d2 - 1)) / d2;\n}\n\nstatic unsigned int\nrecs_per_track(struct dasd_eckd_characteristics * rdc,\n\t       unsigned int kl, unsigned int dl)\n{\n\tint dn, kn;\n\n\tswitch (rdc->dev_type) {\n\tcase 0x3380:\n\t\tif (kl)\n\t\t\treturn 1499 / (15 + 7 + ceil_quot(kl + 12, 32) +\n\t\t\t\t       ceil_quot(dl + 12, 32));\n\t\telse\n\t\t\treturn 1499 / (15 + ceil_quot(dl + 12, 32));\n\tcase 0x3390:\n\t\tdn = ceil_quot(dl + 6, 232) + 1;\n\t\tif (kl) {\n\t\t\tkn = ceil_quot(kl + 6, 232) + 1;\n\t\t\treturn 1729 / (10 + 9 + ceil_quot(kl + 6 * kn, 34) +\n\t\t\t\t       9 + ceil_quot(dl + 6 * dn, 34));\n\t\t} else\n\t\t\treturn 1729 / (10 + 9 + ceil_quot(dl + 6 * dn, 34));\n\tcase 0x9345:\n\t\tdn = ceil_quot(dl + 6, 232) + 1;\n\t\tif (kl) {\n\t\t\tkn = ceil_quot(kl + 6, 232) + 1;\n\t\t\treturn 1420 / (18 + 7 + ceil_quot(kl + 6 * kn, 34) +\n\t\t\t\t       ceil_quot(dl + 6 * dn, 34));\n\t\t} else\n\t\t\treturn 1420 / (18 + 7 + ceil_quot(dl + 6 * dn, 34));\n\t}\n\treturn 0;\n}\n\nstatic void set_ch_t(struct ch_t *geo, __u32 cyl, __u8 head)\n{\n\tgeo->cyl = (__u16) cyl;\n\tgeo->head = cyl >> 16;\n\tgeo->head <<= 4;\n\tgeo->head |= head;\n}\n\n \nstatic int dasd_eckd_track_from_irb(struct irb *irb, struct dasd_device *device,\n\t\t\t\t    sector_t *track)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tu8 *sense = NULL;\n\tu32 cyl;\n\tu8 head;\n\n\tsense = dasd_get_sense(irb);\n\tif (!sense) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"ESE error no sense data\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!(sense[27] & DASD_SENSE_BIT_2)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"ESE error no valid track data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sense[27] & DASD_SENSE_BIT_3) {\n\t\t \n\t\tcyl = sense[30] << 20;\n\t\tcyl |= (sense[31] & 0xF0) << 12;\n\t\tcyl |= sense[28] << 8;\n\t\tcyl |= sense[29];\n\t} else {\n\t\tcyl = sense[29] << 8;\n\t\tcyl |= sense[30];\n\t}\n\thead = sense[31] & 0x0F;\n\t*track = cyl * private->rdc_data.trk_per_cyl + head;\n\treturn 0;\n}\n\nstatic int set_timestamp(struct ccw1 *ccw, struct DE_eckd_data *data,\n\t\t     struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint rc;\n\n\trc = get_phys_clock(&data->ep_sys_time);\n\t \n\tif ((rc && !private->rdc_data.facilities.XRC_supported) ||\n\t    rc == -EOPNOTSUPP || rc == -EACCES)\n\t\treturn 0;\n\n\t \n\tdata->ga_extended |= 0x08;  \n\tdata->ga_extended |= 0x02;  \n\n\tif (ccw) {\n\t\tccw->count = sizeof(struct DE_eckd_data);\n\t\tccw->flags |= CCW_FLAG_SLI;\n\t}\n\n\treturn rc;\n}\n\nstatic int\ndefine_extent(struct ccw1 *ccw, struct DE_eckd_data *data, unsigned int trk,\n\t      unsigned int totrk, int cmd, struct dasd_device *device,\n\t      int blksize)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tu16 heads, beghead, endhead;\n\tu32 begcyl, endcyl;\n\tint rc = 0;\n\n\tif (ccw) {\n\t\tccw->cmd_code = DASD_ECKD_CCW_DEFINE_EXTENT;\n\t\tccw->flags = 0;\n\t\tccw->count = 16;\n\t\tccw->cda = (__u32)virt_to_phys(data);\n\t}\n\n\tmemset(data, 0, sizeof(struct DE_eckd_data));\n\tswitch (cmd) {\n\tcase DASD_ECKD_CCW_READ_HOME_ADDRESS:\n\tcase DASD_ECKD_CCW_READ_RECORD_ZERO:\n\tcase DASD_ECKD_CCW_READ:\n\tcase DASD_ECKD_CCW_READ_MT:\n\tcase DASD_ECKD_CCW_READ_CKD:\n\tcase DASD_ECKD_CCW_READ_CKD_MT:\n\tcase DASD_ECKD_CCW_READ_KD:\n\tcase DASD_ECKD_CCW_READ_KD_MT:\n\t\tdata->mask.perm = 0x1;\n\t\tdata->attributes.operation = private->attrib.operation;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_COUNT:\n\t\tdata->mask.perm = 0x1;\n\t\tdata->attributes.operation = DASD_BYPASS_CACHE;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_TRACK:\n\tcase DASD_ECKD_CCW_READ_TRACK_DATA:\n\t\tdata->mask.perm = 0x1;\n\t\tdata->attributes.operation = private->attrib.operation;\n\t\tdata->blk_size = 0;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE:\n\tcase DASD_ECKD_CCW_WRITE_MT:\n\tcase DASD_ECKD_CCW_WRITE_KD:\n\tcase DASD_ECKD_CCW_WRITE_KD_MT:\n\t\tdata->mask.perm = 0x02;\n\t\tdata->attributes.operation = private->attrib.operation;\n\t\trc = set_timestamp(ccw, data, device);\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_CKD:\n\tcase DASD_ECKD_CCW_WRITE_CKD_MT:\n\t\tdata->attributes.operation = DASD_BYPASS_CACHE;\n\t\trc = set_timestamp(ccw, data, device);\n\t\tbreak;\n\tcase DASD_ECKD_CCW_ERASE:\n\tcase DASD_ECKD_CCW_WRITE_HOME_ADDRESS:\n\tcase DASD_ECKD_CCW_WRITE_RECORD_ZERO:\n\t\tdata->mask.perm = 0x3;\n\t\tdata->mask.auth = 0x1;\n\t\tdata->attributes.operation = DASD_BYPASS_CACHE;\n\t\trc = set_timestamp(ccw, data, device);\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_FULL_TRACK:\n\t\tdata->mask.perm = 0x03;\n\t\tdata->attributes.operation = private->attrib.operation;\n\t\tdata->blk_size = 0;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_TRACK_DATA:\n\t\tdata->mask.perm = 0x02;\n\t\tdata->attributes.operation = private->attrib.operation;\n\t\tdata->blk_size = blksize;\n\t\trc = set_timestamp(ccw, data, device);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"0x%x is not a known command\\n\", cmd);\n\t\tbreak;\n\t}\n\n\tdata->attributes.mode = 0x3;\t \n\n\tif ((private->rdc_data.cu_type == 0x2105 ||\n\t     private->rdc_data.cu_type == 0x2107 ||\n\t     private->rdc_data.cu_type == 0x1750)\n\t    && !(private->uses_cdl && trk < 2))\n\t\tdata->ga_extended |= 0x40;  \n\n\theads = private->rdc_data.trk_per_cyl;\n\tbegcyl = trk / heads;\n\tbeghead = trk % heads;\n\tendcyl = totrk / heads;\n\tendhead = totrk % heads;\n\n\t \n\tif (data->attributes.operation == DASD_SEQ_PRESTAGE ||\n\t    data->attributes.operation == DASD_SEQ_ACCESS) {\n\n\t\tif (endcyl + private->attrib.nr_cyl < private->real_cyl)\n\t\t\tendcyl += private->attrib.nr_cyl;\n\t\telse\n\t\t\tendcyl = (private->real_cyl - 1);\n\t}\n\n\tset_ch_t(&data->beg_ext, begcyl, beghead);\n\tset_ch_t(&data->end_ext, endcyl, endhead);\n\treturn rc;\n}\n\n\nstatic void locate_record_ext(struct ccw1 *ccw, struct LRE_eckd_data *data,\n\t\t\t      unsigned int trk, unsigned int rec_on_trk,\n\t\t\t      int count, int cmd, struct dasd_device *device,\n\t\t\t      unsigned int reclen, unsigned int tlf)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint sector;\n\tint dn, d;\n\n\tif (ccw) {\n\t\tccw->cmd_code = DASD_ECKD_CCW_LOCATE_RECORD_EXT;\n\t\tccw->flags = 0;\n\t\tif (cmd == DASD_ECKD_CCW_WRITE_FULL_TRACK)\n\t\t\tccw->count = 22;\n\t\telse\n\t\t\tccw->count = 20;\n\t\tccw->cda = (__u32)virt_to_phys(data);\n\t}\n\n\tmemset(data, 0, sizeof(*data));\n\tsector = 0;\n\tif (rec_on_trk) {\n\t\tswitch (private->rdc_data.dev_type) {\n\t\tcase 0x3390:\n\t\t\tdn = ceil_quot(reclen + 6, 232);\n\t\t\td = 9 + ceil_quot(reclen + 6 * (dn + 1), 34);\n\t\t\tsector = (49 + (rec_on_trk - 1) * (10 + d)) / 8;\n\t\t\tbreak;\n\t\tcase 0x3380:\n\t\t\td = 7 + ceil_quot(reclen + 12, 32);\n\t\t\tsector = (39 + (rec_on_trk - 1) * (8 + d)) / 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdata->sector = sector;\n\t \n\tdata->count = count;\n\tswitch (cmd) {\n\tcase DASD_ECKD_CCW_WRITE_HOME_ADDRESS:\n\t\tdata->operation.orientation = 0x3;\n\t\tdata->operation.operation = 0x03;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_HOME_ADDRESS:\n\t\tdata->operation.orientation = 0x3;\n\t\tdata->operation.operation = 0x16;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_RECORD_ZERO:\n\t\tdata->operation.orientation = 0x1;\n\t\tdata->operation.operation = 0x03;\n\t\tdata->count++;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_RECORD_ZERO:\n\t\tdata->operation.orientation = 0x3;\n\t\tdata->operation.operation = 0x16;\n\t\tdata->count++;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE:\n\tcase DASD_ECKD_CCW_WRITE_MT:\n\tcase DASD_ECKD_CCW_WRITE_KD:\n\tcase DASD_ECKD_CCW_WRITE_KD_MT:\n\t\tdata->auxiliary.length_valid = 0x1;\n\t\tdata->length = reclen;\n\t\tdata->operation.operation = 0x01;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_CKD:\n\tcase DASD_ECKD_CCW_WRITE_CKD_MT:\n\t\tdata->auxiliary.length_valid = 0x1;\n\t\tdata->length = reclen;\n\t\tdata->operation.operation = 0x03;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_FULL_TRACK:\n\t\tdata->operation.orientation = 0x0;\n\t\tdata->operation.operation = 0x3F;\n\t\tdata->extended_operation = 0x11;\n\t\tdata->length = 0;\n\t\tdata->extended_parameter_length = 0x02;\n\t\tif (data->count > 8) {\n\t\t\tdata->extended_parameter[0] = 0xFF;\n\t\t\tdata->extended_parameter[1] = 0xFF;\n\t\t\tdata->extended_parameter[1] <<= (16 - count);\n\t\t} else {\n\t\t\tdata->extended_parameter[0] = 0xFF;\n\t\t\tdata->extended_parameter[0] <<= (8 - count);\n\t\t\tdata->extended_parameter[1] = 0x00;\n\t\t}\n\t\tdata->sector = 0xFF;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_TRACK_DATA:\n\t\tdata->auxiliary.length_valid = 0x1;\n\t\tdata->length = reclen;\t \n\t\tdata->operation.operation = 0x3F;\n\t\tdata->extended_operation = 0x23;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ:\n\tcase DASD_ECKD_CCW_READ_MT:\n\tcase DASD_ECKD_CCW_READ_KD:\n\tcase DASD_ECKD_CCW_READ_KD_MT:\n\t\tdata->auxiliary.length_valid = 0x1;\n\t\tdata->length = reclen;\n\t\tdata->operation.operation = 0x06;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_CKD:\n\tcase DASD_ECKD_CCW_READ_CKD_MT:\n\t\tdata->auxiliary.length_valid = 0x1;\n\t\tdata->length = reclen;\n\t\tdata->operation.operation = 0x16;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_COUNT:\n\t\tdata->operation.operation = 0x06;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_TRACK:\n\t\tdata->operation.orientation = 0x1;\n\t\tdata->operation.operation = 0x0C;\n\t\tdata->extended_parameter_length = 0;\n\t\tdata->sector = 0xFF;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_TRACK_DATA:\n\t\tdata->auxiliary.length_valid = 0x1;\n\t\tdata->length = tlf;\n\t\tdata->operation.operation = 0x0C;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_ERASE:\n\t\tdata->length = reclen;\n\t\tdata->auxiliary.length_valid = 0x1;\n\t\tdata->operation.operation = 0x0b;\n\t\tbreak;\n\tdefault:\n\t\tDBF_DEV_EVENT(DBF_ERR, device,\n\t\t\t    \"fill LRE unknown opcode 0x%x\", cmd);\n\t\tBUG();\n\t}\n\tset_ch_t(&data->seek_addr,\n\t\t trk / private->rdc_data.trk_per_cyl,\n\t\t trk % private->rdc_data.trk_per_cyl);\n\tdata->search_arg.cyl = data->seek_addr.cyl;\n\tdata->search_arg.head = data->seek_addr.head;\n\tdata->search_arg.record = rec_on_trk;\n}\n\nstatic int prefix_LRE(struct ccw1 *ccw, struct PFX_eckd_data *pfxdata,\n\t\t      unsigned int trk, unsigned int totrk, int cmd,\n\t\t      struct dasd_device *basedev, struct dasd_device *startdev,\n\t\t      unsigned int format, unsigned int rec_on_trk, int count,\n\t\t      unsigned int blksize, unsigned int tlf)\n{\n\tstruct dasd_eckd_private *basepriv, *startpriv;\n\tstruct LRE_eckd_data *lredata;\n\tstruct DE_eckd_data *dedata;\n\tint rc = 0;\n\n\tbasepriv = basedev->private;\n\tstartpriv = startdev->private;\n\tdedata = &pfxdata->define_extent;\n\tlredata = &pfxdata->locate_record;\n\n\tccw->cmd_code = DASD_ECKD_CCW_PFX;\n\tccw->flags = 0;\n\tif (cmd == DASD_ECKD_CCW_WRITE_FULL_TRACK) {\n\t\tccw->count = sizeof(*pfxdata) + 2;\n\t\tccw->cda = (__u32)virt_to_phys(pfxdata);\n\t\tmemset(pfxdata, 0, sizeof(*pfxdata) + 2);\n\t} else {\n\t\tccw->count = sizeof(*pfxdata);\n\t\tccw->cda = (__u32)virt_to_phys(pfxdata);\n\t\tmemset(pfxdata, 0, sizeof(*pfxdata));\n\t}\n\n\t \n\tif (format > 1) {\n\t\tDBF_DEV_EVENT(DBF_ERR, basedev,\n\t\t\t      \"PFX LRE unknown format 0x%x\", format);\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\tpfxdata->format = format;\n\tpfxdata->base_address = basepriv->conf.ned->unit_addr;\n\tpfxdata->base_lss = basepriv->conf.ned->ID;\n\tpfxdata->validity.define_extent = 1;\n\n\t \n\tif (startpriv->uid.type == UA_BASE_PAV_ALIAS)\n\t\tpfxdata->validity.verify_base = 1;\n\n\tif (startpriv->uid.type == UA_HYPER_PAV_ALIAS) {\n\t\tpfxdata->validity.verify_base = 1;\n\t\tpfxdata->validity.hyper_pav = 1;\n\t}\n\n\trc = define_extent(NULL, dedata, trk, totrk, cmd, basedev, blksize);\n\n\t \n\tif (dedata->ga_extended & 0x08 && dedata->ga_extended & 0x02)\n\t\tpfxdata->validity.time_stamp = 1;  \n\n\tif (format == 1) {\n\t\tlocate_record_ext(NULL, lredata, trk, rec_on_trk, count, cmd,\n\t\t\t\t  basedev, blksize, tlf);\n\t}\n\n\treturn rc;\n}\n\nstatic int prefix(struct ccw1 *ccw, struct PFX_eckd_data *pfxdata,\n\t\t  unsigned int trk, unsigned int totrk, int cmd,\n\t\t  struct dasd_device *basedev, struct dasd_device *startdev)\n{\n\treturn prefix_LRE(ccw, pfxdata, trk, totrk, cmd, basedev, startdev,\n\t\t\t  0, 0, 0, 0, 0);\n}\n\nstatic void\nlocate_record(struct ccw1 *ccw, struct LO_eckd_data *data, unsigned int trk,\n\t      unsigned int rec_on_trk, int no_rec, int cmd,\n\t      struct dasd_device * device, int reclen)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint sector;\n\tint dn, d;\n\n\tDBF_DEV_EVENT(DBF_INFO, device,\n\t\t  \"Locate: trk %d, rec %d, no_rec %d, cmd %d, reclen %d\",\n\t\t  trk, rec_on_trk, no_rec, cmd, reclen);\n\n\tccw->cmd_code = DASD_ECKD_CCW_LOCATE_RECORD;\n\tccw->flags = 0;\n\tccw->count = 16;\n\tccw->cda = (__u32)virt_to_phys(data);\n\n\tmemset(data, 0, sizeof(struct LO_eckd_data));\n\tsector = 0;\n\tif (rec_on_trk) {\n\t\tswitch (private->rdc_data.dev_type) {\n\t\tcase 0x3390:\n\t\t\tdn = ceil_quot(reclen + 6, 232);\n\t\t\td = 9 + ceil_quot(reclen + 6 * (dn + 1), 34);\n\t\t\tsector = (49 + (rec_on_trk - 1) * (10 + d)) / 8;\n\t\t\tbreak;\n\t\tcase 0x3380:\n\t\t\td = 7 + ceil_quot(reclen + 12, 32);\n\t\t\tsector = (39 + (rec_on_trk - 1) * (8 + d)) / 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdata->sector = sector;\n\tdata->count = no_rec;\n\tswitch (cmd) {\n\tcase DASD_ECKD_CCW_WRITE_HOME_ADDRESS:\n\t\tdata->operation.orientation = 0x3;\n\t\tdata->operation.operation = 0x03;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_HOME_ADDRESS:\n\t\tdata->operation.orientation = 0x3;\n\t\tdata->operation.operation = 0x16;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_RECORD_ZERO:\n\t\tdata->operation.orientation = 0x1;\n\t\tdata->operation.operation = 0x03;\n\t\tdata->count++;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_RECORD_ZERO:\n\t\tdata->operation.orientation = 0x3;\n\t\tdata->operation.operation = 0x16;\n\t\tdata->count++;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE:\n\tcase DASD_ECKD_CCW_WRITE_MT:\n\tcase DASD_ECKD_CCW_WRITE_KD:\n\tcase DASD_ECKD_CCW_WRITE_KD_MT:\n\t\tdata->auxiliary.last_bytes_used = 0x1;\n\t\tdata->length = reclen;\n\t\tdata->operation.operation = 0x01;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_CKD:\n\tcase DASD_ECKD_CCW_WRITE_CKD_MT:\n\t\tdata->auxiliary.last_bytes_used = 0x1;\n\t\tdata->length = reclen;\n\t\tdata->operation.operation = 0x03;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ:\n\tcase DASD_ECKD_CCW_READ_MT:\n\tcase DASD_ECKD_CCW_READ_KD:\n\tcase DASD_ECKD_CCW_READ_KD_MT:\n\t\tdata->auxiliary.last_bytes_used = 0x1;\n\t\tdata->length = reclen;\n\t\tdata->operation.operation = 0x06;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_CKD:\n\tcase DASD_ECKD_CCW_READ_CKD_MT:\n\t\tdata->auxiliary.last_bytes_used = 0x1;\n\t\tdata->length = reclen;\n\t\tdata->operation.operation = 0x16;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_COUNT:\n\t\tdata->operation.operation = 0x06;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_ERASE:\n\t\tdata->length = reclen;\n\t\tdata->auxiliary.last_bytes_used = 0x1;\n\t\tdata->operation.operation = 0x0b;\n\t\tbreak;\n\tdefault:\n\t\tDBF_DEV_EVENT(DBF_ERR, device, \"unknown locate record \"\n\t\t\t      \"opcode 0x%x\", cmd);\n\t}\n\tset_ch_t(&data->seek_addr,\n\t\t trk / private->rdc_data.trk_per_cyl,\n\t\t trk % private->rdc_data.trk_per_cyl);\n\tdata->search_arg.cyl = data->seek_addr.cyl;\n\tdata->search_arg.head = data->seek_addr.head;\n\tdata->search_arg.record = rec_on_trk;\n}\n\n \nstatic inline int\ndasd_eckd_cdl_special(int blk_per_trk, int recid)\n{\n\tif (recid < 3)\n\t\treturn 1;\n\tif (recid < blk_per_trk)\n\t\treturn 0;\n\tif (recid < 2 * blk_per_trk)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline int\ndasd_eckd_cdl_reclen(int recid)\n{\n\tif (recid < 3)\n\t\treturn sizes_trk0[recid];\n\treturn LABEL_SIZE;\n}\n \nstatic void create_uid(struct dasd_conf *conf, struct dasd_uid *uid)\n{\n\tint count;\n\n\tmemset(uid, 0, sizeof(struct dasd_uid));\n\tmemcpy(uid->vendor, conf->ned->HDA_manufacturer,\n\t       sizeof(uid->vendor) - 1);\n\tEBCASC(uid->vendor, sizeof(uid->vendor) - 1);\n\tmemcpy(uid->serial, &conf->ned->serial,\n\t       sizeof(uid->serial) - 1);\n\tEBCASC(uid->serial, sizeof(uid->serial) - 1);\n\tuid->ssid = conf->gneq->subsystemID;\n\tuid->real_unit_addr = conf->ned->unit_addr;\n\tif (conf->sneq) {\n\t\tuid->type = conf->sneq->sua_flags;\n\t\tif (uid->type == UA_BASE_PAV_ALIAS)\n\t\t\tuid->base_unit_addr = conf->sneq->base_unit_addr;\n\t} else {\n\t\tuid->type = UA_BASE_DEVICE;\n\t}\n\tif (conf->vdsneq) {\n\t\tfor (count = 0; count < 16; count++) {\n\t\t\tsprintf(uid->vduit+2*count, \"%02x\",\n\t\t\t\tconf->vdsneq->uit[count]);\n\t\t}\n\t}\n}\n\n \nstatic int dasd_eckd_generate_uid(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tunsigned long flags;\n\n\tif (!private)\n\t\treturn -ENODEV;\n\tif (!private->conf.ned || !private->conf.gneq)\n\t\treturn -ENODEV;\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tcreate_uid(&private->conf, &private->uid);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\treturn 0;\n}\n\nstatic int dasd_eckd_get_uid(struct dasd_device *device, struct dasd_uid *uid)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tunsigned long flags;\n\n\tif (private) {\n\t\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\t\t*uid = private->uid;\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int dasd_eckd_compare_path_uid(struct dasd_device *device,\n\t\t\t\t      struct dasd_conf *path_conf)\n{\n\tstruct dasd_uid device_uid;\n\tstruct dasd_uid path_uid;\n\n\tcreate_uid(path_conf, &path_uid);\n\tdasd_eckd_get_uid(device, &device_uid);\n\n\treturn memcmp(&device_uid, &path_uid, sizeof(struct dasd_uid));\n}\n\nstatic void dasd_eckd_fill_rcd_cqr(struct dasd_device *device,\n\t\t\t\t   struct dasd_ccw_req *cqr,\n\t\t\t\t   __u8 *rcd_buffer,\n\t\t\t\t   __u8 lpm)\n{\n\tstruct ccw1 *ccw;\n\t \n\trcd_buffer[0] = 0xE5;\n\trcd_buffer[1] = 0xF1;\n\trcd_buffer[2] = 0x4B;\n\trcd_buffer[3] = 0xF0;\n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_RCD;\n\tccw->flags = 0;\n\tccw->cda = (__u32)virt_to_phys(rcd_buffer);\n\tccw->count = DASD_ECKD_RCD_DATA_SIZE;\n\tcqr->magic = DASD_ECKD_MAGIC;\n\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->expires = 10*HZ;\n\tcqr->lpm = lpm;\n\tcqr->retries = 256;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\tset_bit(DASD_CQR_VERIFY_PATH, &cqr->flags);\n}\n\n \nstatic void read_conf_cb(struct dasd_ccw_req *cqr, void *data)\n{\n\tstruct ccw1 *ccw;\n\t__u8 *rcd_buffer;\n\n\tif (cqr->status !=  DASD_CQR_DONE) {\n\t\tccw = cqr->cpaddr;\n\t\trcd_buffer = phys_to_virt(ccw->cda);\n\t\tmemset(rcd_buffer, 0, sizeof(*rcd_buffer));\n\n\t\trcd_buffer[0] = 0xE5;\n\t\trcd_buffer[1] = 0xF1;\n\t\trcd_buffer[2] = 0x4B;\n\t\trcd_buffer[3] = 0xF0;\n\t}\n\tdasd_wakeup_cb(cqr, data);\n}\n\nstatic int dasd_eckd_read_conf_immediately(struct dasd_device *device,\n\t\t\t\t\t   struct dasd_ccw_req *cqr,\n\t\t\t\t\t   __u8 *rcd_buffer,\n\t\t\t\t\t   __u8 lpm)\n{\n\tstruct ciw *ciw;\n\tint rc;\n\t \n\tciw = ccw_device_get_ciw(device->cdev, CIW_TYPE_RCD);\n\tif (!ciw || ciw->cmd != DASD_ECKD_CCW_RCD)\n\t\treturn -EOPNOTSUPP;\n\n\tdasd_eckd_fill_rcd_cqr(device, cqr, rcd_buffer, lpm);\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tset_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags);\n\tcqr->retries = 5;\n\tcqr->callback = read_conf_cb;\n\trc = dasd_sleep_on_immediatly(cqr);\n\treturn rc;\n}\n\nstatic int dasd_eckd_read_conf_lpm(struct dasd_device *device,\n\t\t\t\t   void **rcd_buffer,\n\t\t\t\t   int *rcd_buffer_size, __u8 lpm)\n{\n\tstruct ciw *ciw;\n\tchar *rcd_buf = NULL;\n\tint ret;\n\tstruct dasd_ccw_req *cqr;\n\n\t \n\tciw = ccw_device_get_ciw(device->cdev, CIW_TYPE_RCD);\n\tif (!ciw || ciw->cmd != DASD_ECKD_CCW_RCD) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_error;\n\t}\n\trcd_buf = kzalloc(DASD_ECKD_RCD_DATA_SIZE, GFP_KERNEL | GFP_DMA);\n\tif (!rcd_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_error;\n\t}\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1  ,\n\t\t\t\t   0,  \n\t\t\t\t   device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"Could not allocate RCD request\");\n\t\tret = -ENOMEM;\n\t\tgoto out_error;\n\t}\n\tdasd_eckd_fill_rcd_cqr(device, cqr, rcd_buf, lpm);\n\tcqr->callback = read_conf_cb;\n\tret = dasd_sleep_on(cqr);\n\t \n\tdasd_sfree_request(cqr, cqr->memdev);\n\tif (ret)\n\t\tgoto out_error;\n\n\t*rcd_buffer_size = DASD_ECKD_RCD_DATA_SIZE;\n\t*rcd_buffer = rcd_buf;\n\treturn 0;\nout_error:\n\tkfree(rcd_buf);\n\t*rcd_buffer = NULL;\n\t*rcd_buffer_size = 0;\n\treturn ret;\n}\n\nstatic int dasd_eckd_identify_conf_parts(struct dasd_conf *conf)\n{\n\n\tstruct dasd_sneq *sneq;\n\tint i, count;\n\n\tconf->ned = NULL;\n\tconf->sneq = NULL;\n\tconf->vdsneq = NULL;\n\tconf->gneq = NULL;\n\tcount = conf->len / sizeof(struct dasd_sneq);\n\tsneq = (struct dasd_sneq *)conf->data;\n\tfor (i = 0; i < count; ++i) {\n\t\tif (sneq->flags.identifier == 1 && sneq->format == 1)\n\t\t\tconf->sneq = sneq;\n\t\telse if (sneq->flags.identifier == 1 && sneq->format == 4)\n\t\t\tconf->vdsneq = (struct vd_sneq *)sneq;\n\t\telse if (sneq->flags.identifier == 2)\n\t\t\tconf->gneq = (struct dasd_gneq *)sneq;\n\t\telse if (sneq->flags.identifier == 3 && sneq->res1 == 1)\n\t\t\tconf->ned = (struct dasd_ned *)sneq;\n\t\tsneq++;\n\t}\n\tif (!conf->ned || !conf->gneq) {\n\t\tconf->ned = NULL;\n\t\tconf->sneq = NULL;\n\t\tconf->vdsneq = NULL;\n\t\tconf->gneq = NULL;\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\n};\n\nstatic unsigned char dasd_eckd_path_access(void *conf_data, int conf_len)\n{\n\tstruct dasd_gneq *gneq;\n\tint i, count, found;\n\n\tcount = conf_len / sizeof(*gneq);\n\tgneq = (struct dasd_gneq *)conf_data;\n\tfound = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tif (gneq->flags.identifier == 2) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tgneq++;\n\t}\n\tif (found)\n\t\treturn ((char *)gneq)[18] & 0x07;\n\telse\n\t\treturn 0;\n}\n\nstatic void dasd_eckd_store_conf_data(struct dasd_device *device,\n\t\t\t\t      struct dasd_conf_data *conf_data, int chp)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct channel_path_desc_fmt0 *chp_desc;\n\tstruct subchannel_id sch_id;\n\tvoid *cdp;\n\n\t \n\tcdp = device->path[chp].conf_data;\n\tif (private->conf.data == cdp) {\n\t\tprivate->conf.data = (void *)conf_data;\n\t\tdasd_eckd_identify_conf_parts(&private->conf);\n\t}\n\tccw_device_get_schid(device->cdev, &sch_id);\n\tdevice->path[chp].conf_data = conf_data;\n\tdevice->path[chp].cssid = sch_id.cssid;\n\tdevice->path[chp].ssid = sch_id.ssid;\n\tchp_desc = ccw_device_get_chp_desc(device->cdev, chp);\n\tif (chp_desc)\n\t\tdevice->path[chp].chpid = chp_desc->chpid;\n\tkfree(chp_desc);\n\tkfree(cdp);\n}\n\nstatic void dasd_eckd_clear_conf_data(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint i;\n\n\tprivate->conf.data = NULL;\n\tprivate->conf.len = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tkfree(device->path[i].conf_data);\n\t\tdevice->path[i].conf_data = NULL;\n\t\tdevice->path[i].cssid = 0;\n\t\tdevice->path[i].ssid = 0;\n\t\tdevice->path[i].chpid = 0;\n\t\tdasd_path_notoper(device, i);\n\t}\n}\n\nstatic void dasd_eckd_read_fc_security(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tu8 esm_valid;\n\tu8 esm[8];\n\tint chp;\n\tint rc;\n\n\trc = chsc_scud(private->uid.ssid, (u64 *)esm, &esm_valid);\n\tif (rc) {\n\t\tfor (chp = 0; chp < 8; chp++)\n\t\t\tdevice->path[chp].fc_security = 0;\n\t\treturn;\n\t}\n\n\tfor (chp = 0; chp < 8; chp++) {\n\t\tif (esm_valid & (0x80 >> chp))\n\t\t\tdevice->path[chp].fc_security = esm[chp];\n\t\telse\n\t\t\tdevice->path[chp].fc_security = 0;\n\t}\n}\n\nstatic void dasd_eckd_get_uid_string(struct dasd_conf *conf,\n\t\t\t\t     char *print_uid)\n{\n\tstruct dasd_uid uid;\n\n\tcreate_uid(conf, &uid);\n\tif (strlen(uid.vduit) > 0)\n\t\tsnprintf(print_uid, DASD_UID_STRLEN,\n\t\t\t \"%s.%s.%04x.%02x.%s\",\n\t\t\t uid.vendor, uid.serial, uid.ssid,\n\t\t\t uid.real_unit_addr, uid.vduit);\n\telse\n\t\tsnprintf(print_uid, DASD_UID_STRLEN,\n\t\t\t \"%s.%s.%04x.%02x\",\n\t\t\t uid.vendor, uid.serial, uid.ssid,\n\t\t\t uid.real_unit_addr);\n}\n\nstatic int dasd_eckd_check_cabling(struct dasd_device *device,\n\t\t\t\t   void *conf_data, __u8 lpm)\n{\n\tchar print_path_uid[DASD_UID_STRLEN], print_device_uid[DASD_UID_STRLEN];\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_conf path_conf;\n\n\tpath_conf.data = conf_data;\n\tpath_conf.len = DASD_ECKD_RCD_DATA_SIZE;\n\tif (dasd_eckd_identify_conf_parts(&path_conf))\n\t\treturn 1;\n\n\tif (dasd_eckd_compare_path_uid(device, &path_conf)) {\n\t\tdasd_eckd_get_uid_string(&path_conf, print_path_uid);\n\t\tdasd_eckd_get_uid_string(&private->conf, print_device_uid);\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"Not all channel paths lead to the same device, path %02X leads to device %s instead of %s\\n\",\n\t\t\tlpm, print_path_uid, print_device_uid);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int dasd_eckd_read_conf(struct dasd_device *device)\n{\n\tvoid *conf_data;\n\tint conf_len, conf_data_saved;\n\tint rc, path_err, pos;\n\t__u8 lpm, opm;\n\tstruct dasd_eckd_private *private;\n\n\tprivate = device->private;\n\topm = ccw_device_get_path_mask(device->cdev);\n\tconf_data_saved = 0;\n\tpath_err = 0;\n\t \n\tfor (lpm = 0x80; lpm; lpm>>= 1) {\n\t\tif (!(lpm & opm))\n\t\t\tcontinue;\n\t\trc = dasd_eckd_read_conf_lpm(device, &conf_data,\n\t\t\t\t\t     &conf_len, lpm);\n\t\tif (rc && rc != -EOPNOTSUPP) {\t \n\t\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\t\"Read configuration data returned \"\n\t\t\t\t\t\"error %d\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tif (conf_data == NULL) {\n\t\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\t\"No configuration data \"\n\t\t\t\t\t\"retrieved\");\n\t\t\t \n\t\t\tdasd_path_add_opm(device, opm);\n\t\t\tcontinue;\t \n\t\t}\n\t\t \n\t\tif (!conf_data_saved) {\n\t\t\t \n\t\t\tdasd_eckd_clear_conf_data(device);\n\t\t\tprivate->conf.data = conf_data;\n\t\t\tprivate->conf.len = conf_len;\n\t\t\tif (dasd_eckd_identify_conf_parts(&private->conf)) {\n\t\t\t\tprivate->conf.data = NULL;\n\t\t\t\tprivate->conf.len = 0;\n\t\t\t\tkfree(conf_data);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tdasd_eckd_generate_uid(device);\n\t\t\tconf_data_saved++;\n\t\t} else if (dasd_eckd_check_cabling(device, conf_data, lpm)) {\n\t\t\tdasd_path_add_cablepm(device, lpm);\n\t\t\tpath_err = -EINVAL;\n\t\t\tkfree(conf_data);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpos = pathmask_to_pos(lpm);\n\t\tdasd_eckd_store_conf_data(device, conf_data, pos);\n\n\t\tswitch (dasd_eckd_path_access(conf_data, conf_len)) {\n\t\tcase 0x02:\n\t\t\tdasd_path_add_nppm(device, lpm);\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tdasd_path_add_ppm(device, lpm);\n\t\t\tbreak;\n\t\t}\n\t\tif (!dasd_path_get_opm(device)) {\n\t\t\tdasd_path_set_opm(device, lpm);\n\t\t\tdasd_generic_path_operational(device);\n\t\t} else {\n\t\t\tdasd_path_add_opm(device, lpm);\n\t\t}\n\t}\n\n\treturn path_err;\n}\n\nstatic u32 get_fcx_max_data(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint fcx_in_css, fcx_in_gneq, fcx_in_features;\n\tunsigned int mdc;\n\tint tpm;\n\n\tif (dasd_nofcx)\n\t\treturn 0;\n\t \n\tfcx_in_css = css_general_characteristics.fcx;\n\tfcx_in_gneq = private->conf.gneq->reserved2[7] & 0x04;\n\tfcx_in_features = private->features.feature[40] & 0x80;\n\ttpm = fcx_in_css && fcx_in_gneq && fcx_in_features;\n\n\tif (!tpm)\n\t\treturn 0;\n\n\tmdc = ccw_device_get_mdc(device->cdev, 0);\n\tif (mdc == 0) {\n\t\tdev_warn(&device->cdev->dev, \"Detecting the maximum supported data size for zHPF requests failed\\n\");\n\t\treturn 0;\n\t} else {\n\t\treturn (u32)mdc * FCX_MAX_DATA_FACTOR;\n\t}\n}\n\nstatic int verify_fcx_max_data(struct dasd_device *device, __u8 lpm)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tunsigned int mdc;\n\tu32 fcx_max_data;\n\n\tif (private->fcx_max_data) {\n\t\tmdc = ccw_device_get_mdc(device->cdev, lpm);\n\t\tif (mdc == 0) {\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"Detecting the maximum data size for zHPF \"\n\t\t\t\t \"requests failed (rc=%d) for a new path %x\\n\",\n\t\t\t\t mdc, lpm);\n\t\t\treturn mdc;\n\t\t}\n\t\tfcx_max_data = (u32)mdc * FCX_MAX_DATA_FACTOR;\n\t\tif (fcx_max_data < private->fcx_max_data) {\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"The maximum data size for zHPF requests %u \"\n\t\t\t\t \"on a new path %x is below the active maximum \"\n\t\t\t\t \"%u\\n\", fcx_max_data, lpm,\n\t\t\t\t private->fcx_max_data);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int rebuild_device_uid(struct dasd_device *device,\n\t\t\t      struct pe_handler_work_data *data)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\t__u8 lpm, opm = dasd_path_get_opm(device);\n\tint rc = -ENODEV;\n\n\tfor (lpm = 0x80; lpm; lpm >>= 1) {\n\t\tif (!(lpm & opm))\n\t\t\tcontinue;\n\t\tmemset(&data->rcd_buffer, 0, sizeof(data->rcd_buffer));\n\t\tmemset(&data->cqr, 0, sizeof(data->cqr));\n\t\tdata->cqr.cpaddr = &data->ccw;\n\t\trc = dasd_eckd_read_conf_immediately(device, &data->cqr,\n\t\t\t\t\t\t     data->rcd_buffer,\n\t\t\t\t\t\t     lpm);\n\n\t\tif (rc) {\n\t\t\tif (rc == -EOPNOTSUPP)  \n\t\t\t\tcontinue;\n\t\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\t\"Read configuration data \"\n\t\t\t\t\t\"returned error %d\", rc);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(private->conf.data, data->rcd_buffer,\n\t\t       DASD_ECKD_RCD_DATA_SIZE);\n\t\tif (dasd_eckd_identify_conf_parts(&private->conf)) {\n\t\t\trc = -ENODEV;\n\t\t} else  \n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\trc = dasd_eckd_generate_uid(device);\n\n\treturn rc;\n}\n\nstatic void dasd_eckd_path_available_action(struct dasd_device *device,\n\t\t\t\t\t    struct pe_handler_work_data *data)\n{\n\t__u8 path_rcd_buf[DASD_ECKD_RCD_DATA_SIZE];\n\t__u8 lpm, opm, npm, ppm, epm, hpfpm, cablepm;\n\tstruct dasd_conf_data *conf_data;\n\tchar print_uid[DASD_UID_STRLEN];\n\tstruct dasd_conf path_conf;\n\tunsigned long flags;\n\tint rc, pos;\n\n\topm = 0;\n\tnpm = 0;\n\tppm = 0;\n\tepm = 0;\n\thpfpm = 0;\n\tcablepm = 0;\n\n\tfor (lpm = 0x80; lpm; lpm >>= 1) {\n\t\tif (!(lpm & data->tbvpm))\n\t\t\tcontinue;\n\t\tmemset(&data->rcd_buffer, 0, sizeof(data->rcd_buffer));\n\t\tmemset(&data->cqr, 0, sizeof(data->cqr));\n\t\tdata->cqr.cpaddr = &data->ccw;\n\t\trc = dasd_eckd_read_conf_immediately(device, &data->cqr,\n\t\t\t\t\t\t     data->rcd_buffer,\n\t\t\t\t\t\t     lpm);\n\t\tif (!rc) {\n\t\t\tswitch (dasd_eckd_path_access(data->rcd_buffer,\n\t\t\t\t\t\t      DASD_ECKD_RCD_DATA_SIZE)\n\t\t\t\t) {\n\t\t\tcase 0x02:\n\t\t\t\tnpm |= lpm;\n\t\t\t\tbreak;\n\t\t\tcase 0x03:\n\t\t\t\tppm |= lpm;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topm |= lpm;\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\t\"path verification: No configuration \"\n\t\t\t\t\t\"data retrieved\");\n\t\t\topm |= lpm;\n\t\t} else if (rc == -EAGAIN) {\n\t\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\t\"path verification: device is stopped,\"\n\t\t\t\t\t\" try again later\");\n\t\t\tepm |= lpm;\n\t\t} else {\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"Reading device feature codes failed \"\n\t\t\t\t \"(rc=%d) for new path %x\\n\", rc, lpm);\n\t\t\tcontinue;\n\t\t}\n\t\tif (verify_fcx_max_data(device, lpm)) {\n\t\t\topm &= ~lpm;\n\t\t\tnpm &= ~lpm;\n\t\t\tppm &= ~lpm;\n\t\t\thpfpm |= lpm;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmemcpy(&path_rcd_buf, data->rcd_buffer,\n\t\t       DASD_ECKD_RCD_DATA_SIZE);\n\t\tpath_conf.data = (void *)&path_rcd_buf;\n\t\tpath_conf.len = DASD_ECKD_RCD_DATA_SIZE;\n\t\tif (dasd_eckd_identify_conf_parts(&path_conf)) {\n\t\t\tpath_conf.data = NULL;\n\t\t\tpath_conf.len = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (dasd_path_get_opm(device) &&\n\t\t    dasd_eckd_compare_path_uid(device, &path_conf)) {\n\t\t\t \n\t\t\tif (rebuild_device_uid(device, data) ||\n\t\t\t    dasd_eckd_compare_path_uid(\n\t\t\t\t    device, &path_conf)) {\n\t\t\t\tdasd_eckd_get_uid_string(&path_conf, print_uid);\n\t\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t\t\"The newly added channel path %02X \"\n\t\t\t\t\t\"will not be used because it leads \"\n\t\t\t\t\t\"to a different device %s\\n\",\n\t\t\t\t\tlpm, print_uid);\n\t\t\t\topm &= ~lpm;\n\t\t\t\tnpm &= ~lpm;\n\t\t\t\tppm &= ~lpm;\n\t\t\t\tcablepm |= lpm;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconf_data = kzalloc(DASD_ECKD_RCD_DATA_SIZE, GFP_KERNEL);\n\t\tif (conf_data) {\n\t\t\tmemcpy(conf_data, data->rcd_buffer,\n\t\t\t       DASD_ECKD_RCD_DATA_SIZE);\n\t\t} else {\n\t\t\t \n\t\t\tepm |= lpm;\n\t\t}\n\t\tpos = pathmask_to_pos(lpm);\n\t\tdasd_eckd_store_conf_data(device, conf_data, pos);\n\n\t\t \n\t\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\t\tif (!dasd_path_get_opm(device) && opm) {\n\t\t\tdasd_path_set_opm(device, opm);\n\t\t\tdasd_generic_path_operational(device);\n\t\t} else {\n\t\t\tdasd_path_add_opm(device, opm);\n\t\t}\n\t\tdasd_path_add_nppm(device, npm);\n\t\tdasd_path_add_ppm(device, ppm);\n\t\tif (epm) {\n\t\t\tdasd_path_add_tbvpm(device, epm);\n\t\t\tdasd_device_set_timer(device, 50);\n\t\t}\n\t\tdasd_path_add_cablepm(device, cablepm);\n\t\tdasd_path_add_nohpfpm(device, hpfpm);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\n\t\tdasd_path_create_kobj(device, pos);\n\t}\n}\n\nstatic void do_pe_handler_work(struct work_struct *work)\n{\n\tstruct pe_handler_work_data *data;\n\tstruct dasd_device *device;\n\n\tdata = container_of(work, struct pe_handler_work_data, worker);\n\tdevice = data->device;\n\n\t \n\tif (test_bit(DASD_FLAG_SUSPENDED, &device->flags)) {\n\t\tschedule_work(work);\n\t\treturn;\n\t}\n\t \n\tif (test_and_set_bit(DASD_FLAG_PATH_VERIFY, &device->flags)) {\n\t\tschedule_work(work);\n\t\treturn;\n\t}\n\n\tif (data->tbvpm)\n\t\tdasd_eckd_path_available_action(device, data);\n\tif (data->fcsecpm)\n\t\tdasd_eckd_read_fc_security(device);\n\n\tclear_bit(DASD_FLAG_PATH_VERIFY, &device->flags);\n\tdasd_put_device(device);\n\tif (data->isglobal)\n\t\tmutex_unlock(&dasd_pe_handler_mutex);\n\telse\n\t\tkfree(data);\n}\n\nstatic int dasd_eckd_pe_handler(struct dasd_device *device,\n\t\t\t\t__u8 tbvpm, __u8 fcsecpm)\n{\n\tstruct pe_handler_work_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_ATOMIC | GFP_DMA);\n\tif (!data) {\n\t\tif (mutex_trylock(&dasd_pe_handler_mutex)) {\n\t\t\tdata = pe_handler_worker;\n\t\t\tdata->isglobal = 1;\n\t\t} else {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tINIT_WORK(&data->worker, do_pe_handler_work);\n\tdasd_get_device(device);\n\tdata->device = device;\n\tdata->tbvpm = tbvpm;\n\tdata->fcsecpm = fcsecpm;\n\tschedule_work(&data->worker);\n\treturn 0;\n}\n\nstatic void dasd_eckd_reset_path(struct dasd_device *device, __u8 pm)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tunsigned long flags;\n\n\tif (!private->fcx_max_data)\n\t\tprivate->fcx_max_data = get_fcx_max_data(device);\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tdasd_path_set_tbvpm(device, pm ? : dasd_path_get_notoperpm(device));\n\tdasd_schedule_device_bh(device);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n}\n\nstatic int dasd_eckd_read_features(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_psf_prssd_data *prssdp;\n\tstruct dasd_rssd_features *features;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\tmemset(&private->features, 0, sizeof(struct dasd_rssd_features));\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1  \t+ 1  ,\n\t\t\t\t   (sizeof(struct dasd_psf_prssd_data) +\n\t\t\t\t    sizeof(struct dasd_rssd_features)),\n\t\t\t\t   device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\", \"Could not \"\n\t\t\t\t\"allocate initialization request\");\n\t\treturn PTR_ERR(cqr);\n\t}\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->retries = 256;\n\tcqr->expires = 10 * HZ;\n\n\t \n\tprssdp = (struct dasd_psf_prssd_data *) cqr->data;\n\tmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\n\tprssdp->order = PSF_ORDER_PRSSD;\n\tprssdp->suborder = 0x41;\t \n\t \n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = sizeof(struct dasd_psf_prssd_data);\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->cda = (__u32)virt_to_phys(prssdp);\n\n\t \n\tfeatures = (struct dasd_rssd_features *) (prssdp + 1);\n\tmemset(features, 0, sizeof(struct dasd_rssd_features));\n\n\tccw++;\n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = sizeof(struct dasd_rssd_features);\n\tccw->cda = (__u32)virt_to_phys(features);\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\trc = dasd_sleep_on(cqr);\n\tif (rc == 0) {\n\t\tprssdp = (struct dasd_psf_prssd_data *) cqr->data;\n\t\tfeatures = (struct dasd_rssd_features *) (prssdp + 1);\n\t\tmemcpy(&private->features, features,\n\t\t       sizeof(struct dasd_rssd_features));\n\t} else\n\t\tdev_warn(&device->cdev->dev, \"Reading device feature codes\"\n\t\t\t \" failed with rc=%d\\n\", rc);\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic int dasd_eckd_read_vol_info(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_psf_prssd_data *prssdp;\n\tstruct dasd_rssd_vsq *vsq;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint useglobal;\n\tint rc;\n\n\t \n\tif (private->uid.type == UA_BASE_PAV_ALIAS ||\n\t    private->uid.type == UA_HYPER_PAV_ALIAS)\n\t\treturn 0;\n\n\tuseglobal = 0;\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 2  ,\n\t\t\t\t   sizeof(*prssdp) + sizeof(*vsq), device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate initialization request\");\n\t\tmutex_lock(&dasd_vol_info_mutex);\n\t\tuseglobal = 1;\n\t\tcqr = &dasd_vol_info_req->cqr;\n\t\tmemset(cqr, 0, sizeof(*cqr));\n\t\tmemset(dasd_vol_info_req, 0, sizeof(*dasd_vol_info_req));\n\t\tcqr->cpaddr = &dasd_vol_info_req->ccw;\n\t\tcqr->data = &dasd_vol_info_req->data;\n\t\tcqr->magic = DASD_ECKD_MAGIC;\n\t}\n\n\t \n\tprssdp = cqr->data;\n\tprssdp->order = PSF_ORDER_PRSSD;\n\tprssdp->suborder = PSF_SUBORDER_VSQ;\t \n\tprssdp->lss = private->conf.ned->ID;\n\tprssdp->volume = private->conf.ned->unit_addr;\n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = sizeof(*prssdp);\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->cda = (__u32)virt_to_phys(prssdp);\n\n\t \n\tvsq = (struct dasd_rssd_vsq *)(prssdp + 1);\n\tmemset(vsq, 0, sizeof(*vsq));\n\n\tccw++;\n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = sizeof(*vsq);\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->cda = (__u32)virt_to_phys(vsq);\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->retries = 256;\n\tcqr->expires = device->default_expires * HZ;\n\t \n\t__set_bit(DASD_CQR_SUPPRESS_CR, &cqr->flags);\n\n\trc = dasd_sleep_on_interruptible(cqr);\n\tif (rc == 0) {\n\t\tmemcpy(&private->vsq, vsq, sizeof(*vsq));\n\t} else {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\"Reading the volume storage information failed with rc=%d\", rc);\n\t}\n\n\tif (useglobal)\n\t\tmutex_unlock(&dasd_vol_info_mutex);\n\telse\n\t\tdasd_sfree_request(cqr, cqr->memdev);\n\n\treturn rc;\n}\n\nstatic int dasd_eckd_is_ese(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\treturn private->vsq.vol_info.ese;\n}\n\nstatic int dasd_eckd_ext_pool_id(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\treturn private->vsq.extent_pool_id;\n}\n\n \nstatic int dasd_eckd_space_configured(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint rc;\n\n\trc = dasd_eckd_read_vol_info(device);\n\n\treturn rc ? : private->vsq.space_configured;\n}\n\n \nstatic int dasd_eckd_space_allocated(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint rc;\n\n\trc = dasd_eckd_read_vol_info(device);\n\n\treturn rc ? : private->vsq.space_allocated;\n}\n\nstatic int dasd_eckd_logical_capacity(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\treturn private->vsq.logical_capacity;\n}\n\nstatic void dasd_eckd_ext_pool_exhaust_work(struct work_struct *work)\n{\n\tstruct ext_pool_exhaust_work_data *data;\n\tstruct dasd_device *device;\n\tstruct dasd_device *base;\n\n\tdata = container_of(work, struct ext_pool_exhaust_work_data, worker);\n\tdevice = data->device;\n\tbase = data->base;\n\n\tif (!base)\n\t\tbase = device;\n\tif (dasd_eckd_space_configured(base) != 0) {\n\t\tdasd_generic_space_avail(device);\n\t} else {\n\t\tdev_warn(&device->cdev->dev, \"No space left in the extent pool\\n\");\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\", \"out of space\");\n\t}\n\n\tdasd_put_device(device);\n\tkfree(data);\n}\n\nstatic int dasd_eckd_ext_pool_exhaust(struct dasd_device *device,\n\t\t\t\t      struct dasd_ccw_req *cqr)\n{\n\tstruct ext_pool_exhaust_work_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_ATOMIC);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tINIT_WORK(&data->worker, dasd_eckd_ext_pool_exhaust_work);\n\tdasd_get_device(device);\n\tdata->device = device;\n\n\tif (cqr->block)\n\t\tdata->base = cqr->block->base;\n\telse if (cqr->basedev)\n\t\tdata->base = cqr->basedev;\n\telse\n\t\tdata->base = NULL;\n\n\tschedule_work(&data->worker);\n\n\treturn 0;\n}\n\nstatic void dasd_eckd_cpy_ext_pool_data(struct dasd_device *device,\n\t\t\t\t\tstruct dasd_rssd_lcq *lcq)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint pool_id = dasd_eckd_ext_pool_id(device);\n\tstruct dasd_ext_pool_sum eps;\n\tint i;\n\n\tfor (i = 0; i < lcq->pool_count; i++) {\n\t\teps = lcq->ext_pool_sum[i];\n\t\tif (eps.pool_id == pool_id) {\n\t\t\tmemcpy(&private->eps, &eps,\n\t\t\t       sizeof(struct dasd_ext_pool_sum));\n\t\t}\n\t}\n}\n\n \nstatic int dasd_eckd_read_ext_pool_info(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_psf_prssd_data *prssdp;\n\tstruct dasd_rssd_lcq *lcq;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\t \n\tif (private->uid.type == UA_BASE_PAV_ALIAS ||\n\t    private->uid.type == UA_HYPER_PAV_ALIAS)\n\t\treturn 0;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 2  ,\n\t\t\t\t   sizeof(*prssdp) + sizeof(*lcq), device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate initialization request\");\n\t\treturn PTR_ERR(cqr);\n\t}\n\n\t \n\tprssdp = cqr->data;\n\tmemset(prssdp, 0, sizeof(*prssdp));\n\tprssdp->order = PSF_ORDER_PRSSD;\n\tprssdp->suborder = PSF_SUBORDER_LCQ;\t \n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = sizeof(*prssdp);\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->cda = (__u32)virt_to_phys(prssdp);\n\n\tlcq = (struct dasd_rssd_lcq *)(prssdp + 1);\n\tmemset(lcq, 0, sizeof(*lcq));\n\n\tccw++;\n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = sizeof(*lcq);\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->cda = (__u32)virt_to_phys(lcq);\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->retries = 256;\n\tcqr->expires = device->default_expires * HZ;\n\t \n\t__set_bit(DASD_CQR_SUPPRESS_CR, &cqr->flags);\n\n\trc = dasd_sleep_on_interruptible(cqr);\n\tif (rc == 0) {\n\t\tdasd_eckd_cpy_ext_pool_data(device, lcq);\n\t} else {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\"Reading the logical configuration failed with rc=%d\", rc);\n\t}\n\n\tdasd_sfree_request(cqr, cqr->memdev);\n\n\treturn rc;\n}\n\n \nstatic int dasd_eckd_ext_size(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_ext_pool_sum eps = private->eps;\n\n\tif (!eps.flags.extent_size_valid)\n\t\treturn 0;\n\tif (eps.extent_size.size_1G)\n\t\treturn 1113;\n\tif (eps.extent_size.size_16M)\n\t\treturn 21;\n\n\treturn 0;\n}\n\nstatic int dasd_eckd_ext_pool_warn_thrshld(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\treturn private->eps.warn_thrshld;\n}\n\nstatic int dasd_eckd_ext_pool_cap_at_warnlevel(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\treturn private->eps.flags.capacity_at_warnlevel;\n}\n\n \nstatic int dasd_eckd_ext_pool_oos(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\treturn private->eps.flags.pool_oos;\n}\n\n \nstatic struct dasd_ccw_req *dasd_eckd_build_psf_ssc(struct dasd_device *device,\n\t\t\t\t\t\t    int enable_pav)\n{\n\tstruct dasd_ccw_req *cqr;\n\tstruct dasd_psf_ssc_data *psf_ssc_data;\n\tstruct ccw1 *ccw;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1   ,\n\t\t\t\t  sizeof(struct dasd_psf_ssc_data),\n\t\t\t\t   device, NULL);\n\n\tif (IS_ERR(cqr)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t   \"Could not allocate PSF-SSC request\");\n\t\treturn cqr;\n\t}\n\tpsf_ssc_data = (struct dasd_psf_ssc_data *)cqr->data;\n\tpsf_ssc_data->order = PSF_ORDER_SSC;\n\tpsf_ssc_data->suborder = 0xc0;\n\tif (enable_pav) {\n\t\tpsf_ssc_data->suborder |= 0x08;\n\t\tpsf_ssc_data->reserved[0] = 0x88;\n\t}\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->cda = (__u32)virt_to_phys(psf_ssc_data);\n\tccw->count = 66;\n\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->retries = 256;\n\tcqr->expires = 10*HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\treturn cqr;\n}\n\n \nstatic int\ndasd_eckd_psf_ssc(struct dasd_device *device, int enable_pav,\n\t\t  unsigned long flags)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc;\n\n\tcqr = dasd_eckd_build_psf_ssc(device, enable_pav);\n\tif (IS_ERR(cqr))\n\t\treturn PTR_ERR(cqr);\n\n\t \n\tcqr->flags |= flags;\n\n\trc = dasd_sleep_on(cqr);\n\tif (!rc)\n\t\t \n\t\tcss_schedule_reprobe();\n\telse if (cqr->intrc == -EAGAIN)\n\t\trc = -EAGAIN;\n\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic int dasd_eckd_validate_server(struct dasd_device *device,\n\t\t\t\t     unsigned long flags)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint enable_pav, rc;\n\n\tif (private->uid.type == UA_BASE_PAV_ALIAS ||\n\t    private->uid.type == UA_HYPER_PAV_ALIAS)\n\t\treturn 0;\n\tif (dasd_nopav || MACHINE_IS_VM)\n\t\tenable_pav = 0;\n\telse\n\t\tenable_pav = 1;\n\trc = dasd_eckd_psf_ssc(device, enable_pav, flags);\n\n\t \n\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"PSF-SSC for SSID %04x \"\n\t\t\t\"returned rc=%d\", private->uid.ssid, rc);\n\treturn rc;\n}\n\n \nstatic void dasd_eckd_do_validate_server(struct work_struct *work)\n{\n\tstruct dasd_device *device = container_of(work, struct dasd_device,\n\t\t\t\t\t\t  kick_validate);\n\tunsigned long flags = 0;\n\n\tset_bit(DASD_CQR_FLAGS_FAILFAST, &flags);\n\tif (dasd_eckd_validate_server(device, flags)\n\t    == -EAGAIN) {\n\t\t \n\t\tschedule_work(&device->kick_validate);\n\t\treturn;\n\t}\n\n\tdasd_put_device(device);\n}\n\nstatic void dasd_eckd_kick_validate_server(struct dasd_device *device)\n{\n\tdasd_get_device(device);\n\t \n\tif (test_bit(DASD_FLAG_OFFLINE, &device->flags) ||\n\t   device->state < DASD_STATE_ONLINE) {\n\t\tdasd_put_device(device);\n\t\treturn;\n\t}\n\t \n\tif (!schedule_work(&device->kick_validate))\n\t\tdasd_put_device(device);\n}\n\n \nstatic int dasd_device_is_primary(struct dasd_device *device)\n{\n\tif (!device->copy)\n\t\treturn 1;\n\n\tif (device->copy->active->device == device)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int dasd_eckd_alloc_block(struct dasd_device *device)\n{\n\tstruct dasd_block *block;\n\tstruct dasd_uid temp_uid;\n\n\tif (!dasd_device_is_primary(device))\n\t\treturn 0;\n\n\tdasd_eckd_get_uid(device, &temp_uid);\n\tif (temp_uid.type == UA_BASE_DEVICE) {\n\t\tblock = dasd_alloc_block();\n\t\tif (IS_ERR(block)) {\n\t\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\t\"could not allocate dasd block structure\");\n\t\t\treturn PTR_ERR(block);\n\t\t}\n\t\tdevice->block = block;\n\t\tblock->base = device;\n\t}\n\treturn 0;\n}\n\nstatic bool dasd_eckd_pprc_enabled(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\treturn private->rdc_data.facilities.PPRC_enabled;\n}\n\n \nstatic int\ndasd_eckd_check_characteristics(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tint rc, i;\n\tint readonly;\n\tunsigned long value;\n\n\t \n\tINIT_WORK(&device->kick_validate, dasd_eckd_do_validate_server);\n\t \n\tINIT_WORK(&device->suc_work, dasd_alias_handle_summary_unit_check);\n\n\tif (!ccw_device_is_pathgroup(device->cdev)) {\n\t\tdev_warn(&device->cdev->dev,\n\t\t\t \"A channel path group could not be established\\n\");\n\t\treturn -EIO;\n\t}\n\tif (!ccw_device_is_multipath(device->cdev)) {\n\t\tdev_info(&device->cdev->dev,\n\t\t\t \"The DASD is not operating in multipath mode\\n\");\n\t}\n\tif (!private) {\n\t\tprivate = kzalloc(sizeof(*private), GFP_KERNEL | GFP_DMA);\n\t\tif (!private) {\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"Allocating memory for private DASD data \"\n\t\t\t\t \"failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdevice->private = private;\n\t} else {\n\t\tmemset(private, 0, sizeof(*private));\n\t}\n\t \n\tprivate->init_cqr_status = -1;\n\t \n\tprivate->attrib.operation = DASD_NORMAL_CACHE;\n\tprivate->attrib.nr_cyl = 0;\n\n\t \n\trc = dasd_eckd_read_conf(device);\n\tif (rc)\n\t\tgoto out_err1;\n\n\t \n\tdevice->default_expires = DASD_EXPIRES;\n\tdevice->default_retries = DASD_RETRIES;\n\tdevice->path_thrhld = DASD_ECKD_PATH_THRHLD;\n\tdevice->path_interval = DASD_ECKD_PATH_INTERVAL;\n\tdevice->aq_timeouts = DASD_RETRIES_MAX;\n\n\tif (private->conf.gneq) {\n\t\tvalue = 1;\n\t\tfor (i = 0; i < private->conf.gneq->timeout.value; i++)\n\t\t\tvalue = 10 * value;\n\t\tvalue = value * private->conf.gneq->timeout.number;\n\t\t \n\t\tif (value != 0 && value <= DASD_EXPIRES_MAX)\n\t\t\tdevice->default_expires = value;\n\t}\n\n\t \n\trc = dasd_generic_read_dev_chars(device, DASD_ECKD_MAGIC,\n\t\t\t\t\t &private->rdc_data, 64);\n\tif (rc) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\"Read device characteristic failed, rc=%d\", rc);\n\t\tgoto out_err1;\n\t}\n\n\t \n\trc = dasd_devmap_set_device_copy_relation(device->cdev,\n\t\t\t\t\t\t  dasd_eckd_pprc_enabled(device));\n\tif (rc) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\"copy relation setup failed, rc=%d\", rc);\n\t\tgoto out_err1;\n\t}\n\n\t \n\trc = dasd_eckd_alloc_block(device);\n\tif (rc)\n\t\tgoto out_err1;\n\n\t \n\trc = dasd_alias_make_device_known_to_lcu(device);\n\tif (rc)\n\t\tgoto out_err2;\n\n\tdasd_eckd_validate_server(device, 0);\n\n\t \n\trc = dasd_eckd_read_conf(device);\n\tif (rc)\n\t\tgoto out_err3;\n\n\tdasd_eckd_read_fc_security(device);\n\tdasd_path_create_kobjects(device);\n\n\t \n\tdasd_eckd_read_features(device);\n\n\t \n\tdasd_eckd_read_vol_info(device);\n\n\t \n\tdasd_eckd_read_ext_pool_info(device);\n\n\tif ((device->features & DASD_FEATURE_USERAW) &&\n\t    !(private->rdc_data.facilities.RT_in_LR)) {\n\t\tdev_err(&device->cdev->dev, \"The storage server does not \"\n\t\t\t\"support raw-track access\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_err3;\n\t}\n\n\t \n\tif (private->rdc_data.no_cyl == LV_COMPAT_CYL &&\n\t    private->rdc_data.long_no_cyl)\n\t\tprivate->real_cyl = private->rdc_data.long_no_cyl;\n\telse\n\t\tprivate->real_cyl = private->rdc_data.no_cyl;\n\n\tprivate->fcx_max_data = get_fcx_max_data(device);\n\n\treadonly = dasd_device_is_ro(device);\n\tif (readonly)\n\t\tset_bit(DASD_FLAG_DEVICE_RO, &device->flags);\n\n\tdev_info(&device->cdev->dev, \"New DASD %04X/%02X (CU %04X/%02X) \"\n\t\t \"with %d cylinders, %d heads, %d sectors%s\\n\",\n\t\t private->rdc_data.dev_type,\n\t\t private->rdc_data.dev_model,\n\t\t private->rdc_data.cu_type,\n\t\t private->rdc_data.cu_model.model,\n\t\t private->real_cyl,\n\t\t private->rdc_data.trk_per_cyl,\n\t\t private->rdc_data.sec_per_trk,\n\t\t readonly ? \", read-only device\" : \"\");\n\treturn 0;\n\nout_err3:\n\tdasd_alias_disconnect_device_from_lcu(device);\nout_err2:\n\tdasd_free_block(device->block);\n\tdevice->block = NULL;\nout_err1:\n\tdasd_eckd_clear_conf_data(device);\n\tdasd_path_remove_kobjects(device);\n\tkfree(device->private);\n\tdevice->private = NULL;\n\treturn rc;\n}\n\nstatic void dasd_eckd_uncheck_device(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\tif (!private)\n\t\treturn;\n\n\tdasd_alias_disconnect_device_from_lcu(device);\n\tprivate->conf.ned = NULL;\n\tprivate->conf.sneq = NULL;\n\tprivate->conf.vdsneq = NULL;\n\tprivate->conf.gneq = NULL;\n\tdasd_eckd_clear_conf_data(device);\n\tdasd_path_remove_kobjects(device);\n}\n\nstatic struct dasd_ccw_req *\ndasd_eckd_analysis_ccw(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct eckd_count *count_data;\n\tstruct LO_eckd_data *LO_data;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint cplength, datasize;\n\tint i;\n\n\tcplength = 8;\n\tdatasize = sizeof(struct DE_eckd_data) + 2*sizeof(struct LO_eckd_data);\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize, device,\n\t\t\t\t   NULL);\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\tccw = cqr->cpaddr;\n\t \n\tdefine_extent(ccw++, cqr->data, 0, 1,\n\t\t      DASD_ECKD_CCW_READ_COUNT, device, 0);\n\tLO_data = cqr->data + sizeof(struct DE_eckd_data);\n\t \n\tccw[-1].flags |= CCW_FLAG_CC;\n\tlocate_record(ccw++, LO_data++, 0, 0, 4,\n\t\t      DASD_ECKD_CCW_READ_COUNT, device, 0);\n\n\tcount_data = private->count_area;\n\tfor (i = 0; i < 4; i++) {\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;\n\t\tccw->flags = 0;\n\t\tccw->count = 8;\n\t\tccw->cda = (__u32)virt_to_phys(count_data);\n\t\tccw++;\n\t\tcount_data++;\n\t}\n\n\t \n\tccw[-1].flags |= CCW_FLAG_CC;\n\tlocate_record(ccw++, LO_data++, 1, 0, 1,\n\t\t      DASD_ECKD_CCW_READ_COUNT, device, 0);\n\t \n\tccw[-1].flags |= CCW_FLAG_CC;\n\tccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;\n\tccw->flags = 0;\n\tccw->count = 8;\n\tccw->cda = (__u32)virt_to_phys(count_data);\n\n\tcqr->block = NULL;\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->retries = 255;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\t \n\tset_bit(DASD_CQR_SUPPRESS_NRF, &cqr->flags);\n\n\treturn cqr;\n}\n\n \nstatic int dasd_eckd_analysis_evaluation(struct dasd_ccw_req *init_cqr)\n{\n\tchar *sense;\n\tif (init_cqr->status == DASD_CQR_DONE)\n\t\treturn INIT_CQR_OK;\n\telse if (init_cqr->status == DASD_CQR_NEED_ERP ||\n\t\t init_cqr->status == DASD_CQR_FAILED) {\n\t\tsense = dasd_get_sense(&init_cqr->irb);\n\t\tif (sense && (sense[1] & SNS1_NO_REC_FOUND))\n\t\t\treturn INIT_CQR_UNFORMATTED;\n\t\telse\n\t\t\treturn INIT_CQR_ERROR;\n\t} else\n\t\treturn INIT_CQR_ERROR;\n}\n\n \nstatic void dasd_eckd_analysis_callback(struct dasd_ccw_req *init_cqr,\n\t\t\t\t\tvoid *data)\n{\n\tstruct dasd_device *device = init_cqr->startdev;\n\tstruct dasd_eckd_private *private = device->private;\n\n\tprivate->init_cqr_status = dasd_eckd_analysis_evaluation(init_cqr);\n\tdasd_sfree_request(init_cqr, device);\n\tdasd_kick_device(device);\n}\n\nstatic int dasd_eckd_start_analysis(struct dasd_block *block)\n{\n\tstruct dasd_ccw_req *init_cqr;\n\n\tinit_cqr = dasd_eckd_analysis_ccw(block->base);\n\tif (IS_ERR(init_cqr))\n\t\treturn PTR_ERR(init_cqr);\n\tinit_cqr->callback = dasd_eckd_analysis_callback;\n\tinit_cqr->callback_data = NULL;\n\tinit_cqr->expires = 5*HZ;\n\t \n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &init_cqr->flags);\n\tinit_cqr->retries = 0;\n\tdasd_add_request_head(init_cqr);\n\treturn -EAGAIN;\n}\n\nstatic int dasd_eckd_end_analysis(struct dasd_block *block)\n{\n\tstruct dasd_device *device = block->base;\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct eckd_count *count_area;\n\tunsigned int sb, blk_per_trk;\n\tint status, i;\n\tstruct dasd_ccw_req *init_cqr;\n\n\tstatus = private->init_cqr_status;\n\tprivate->init_cqr_status = -1;\n\tif (status == INIT_CQR_ERROR) {\n\t\t \n\t\tinit_cqr = dasd_eckd_analysis_ccw(device);\n\t\tdasd_sleep_on(init_cqr);\n\t\tstatus = dasd_eckd_analysis_evaluation(init_cqr);\n\t\tdasd_sfree_request(init_cqr, device);\n\t}\n\n\tif (device->features & DASD_FEATURE_USERAW) {\n\t\tblock->bp_block = DASD_RAW_BLOCKSIZE;\n\t\tblk_per_trk = DASD_RAW_BLOCK_PER_TRACK;\n\t\tblock->s2b_shift = 3;\n\t\tgoto raw;\n\t}\n\n\tif (status == INIT_CQR_UNFORMATTED) {\n\t\tdev_warn(&device->cdev->dev, \"The DASD is not formatted\\n\");\n\t\treturn -EMEDIUMTYPE;\n\t} else if (status == INIT_CQR_ERROR) {\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"Detecting the DASD disk layout failed because \"\n\t\t\t\"of an I/O error\\n\");\n\t\treturn -EIO;\n\t}\n\n\tprivate->uses_cdl = 1;\n\t \n\tcount_area = NULL;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (private->count_area[i].kl != 4 ||\n\t\t    private->count_area[i].dl != dasd_eckd_cdl_reclen(i) - 4 ||\n\t\t    private->count_area[i].cyl != 0 ||\n\t\t    private->count_area[i].head != count_area_head[i] ||\n\t\t    private->count_area[i].record != count_area_rec[i]) {\n\t\t\tprivate->uses_cdl = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == 3)\n\t\tcount_area = &private->count_area[3];\n\n\tif (private->uses_cdl == 0) {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tif ((private->count_area[i].kl != 0) ||\n\t\t\t    (private->count_area[i].dl !=\n\t\t\t     private->count_area[0].dl) ||\n\t\t\t    private->count_area[i].cyl !=  0 ||\n\t\t\t    private->count_area[i].head != count_area_head[i] ||\n\t\t\t    private->count_area[i].record != count_area_rec[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == 5)\n\t\t\tcount_area = &private->count_area[0];\n\t} else {\n\t\tif (private->count_area[3].record == 1)\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"Track 0 has no records following the VTOC\\n\");\n\t}\n\n\tif (count_area != NULL && count_area->kl == 0) {\n\t\t \n\t\tif (dasd_check_blocksize(count_area->dl) == 0)\n\t\t\tblock->bp_block = count_area->dl;\n\t}\n\tif (block->bp_block == 0) {\n\t\tdev_warn(&device->cdev->dev,\n\t\t\t \"The disk layout of the DASD is not supported\\n\");\n\t\treturn -EMEDIUMTYPE;\n\t}\n\tblock->s2b_shift = 0;\t \n\tfor (sb = 512; sb < block->bp_block; sb = sb << 1)\n\t\tblock->s2b_shift++;\n\n\tblk_per_trk = recs_per_track(&private->rdc_data, 0, block->bp_block);\n\nraw:\n\tblock->blocks = ((unsigned long) private->real_cyl *\n\t\t\t  private->rdc_data.trk_per_cyl *\n\t\t\t  blk_per_trk);\n\n\tdev_info(&device->cdev->dev,\n\t\t \"DASD with %u KB/block, %lu KB total size, %u KB/track, \"\n\t\t \"%s\\n\", (block->bp_block >> 10),\n\t\t (((unsigned long) private->real_cyl *\n\t\t   private->rdc_data.trk_per_cyl *\n\t\t   blk_per_trk * (block->bp_block >> 9)) >> 1),\n\t\t ((blk_per_trk * block->bp_block) >> 10),\n\t\t private->uses_cdl ?\n\t\t \"compatible disk layout\" : \"linux disk layout\");\n\n\treturn 0;\n}\n\nstatic int dasd_eckd_do_analysis(struct dasd_block *block)\n{\n\tstruct dasd_eckd_private *private = block->base->private;\n\n\tif (private->init_cqr_status < 0)\n\t\treturn dasd_eckd_start_analysis(block);\n\telse\n\t\treturn dasd_eckd_end_analysis(block);\n}\n\nstatic int dasd_eckd_basic_to_ready(struct dasd_device *device)\n{\n\treturn dasd_alias_add_device(device);\n};\n\nstatic int dasd_eckd_online_to_ready(struct dasd_device *device)\n{\n\tif (cancel_work_sync(&device->reload_device))\n\t\tdasd_put_device(device);\n\tif (cancel_work_sync(&device->kick_validate))\n\t\tdasd_put_device(device);\n\n\treturn 0;\n};\n\nstatic int dasd_eckd_basic_to_known(struct dasd_device *device)\n{\n\treturn dasd_alias_remove_device(device);\n};\n\nstatic int\ndasd_eckd_fill_geometry(struct dasd_block *block, struct hd_geometry *geo)\n{\n\tstruct dasd_eckd_private *private = block->base->private;\n\n\tif (dasd_check_blocksize(block->bp_block) == 0) {\n\t\tgeo->sectors = recs_per_track(&private->rdc_data,\n\t\t\t\t\t      0, block->bp_block);\n\t}\n\tgeo->cylinders = private->rdc_data.no_cyl;\n\tgeo->heads = private->rdc_data.trk_per_cyl;\n\treturn 0;\n}\n\n \nstatic struct dasd_ccw_req *\ndasd_eckd_build_check_tcw(struct dasd_device *base, struct format_data_t *fdata,\n\t\t\t  int enable_pav, struct eckd_count *fmt_buffer,\n\t\t\t  int rpt)\n{\n\tstruct dasd_eckd_private *start_priv;\n\tstruct dasd_device *startdev = NULL;\n\tstruct tidaw *last_tidaw = NULL;\n\tstruct dasd_ccw_req *cqr;\n\tstruct itcw *itcw;\n\tint itcw_size;\n\tint count;\n\tint rc;\n\tint i;\n\n\tif (enable_pav)\n\t\tstartdev = dasd_alias_get_start_dev(base);\n\n\tif (!startdev)\n\t\tstartdev = base;\n\n\tstart_priv = startdev->private;\n\n\tcount = rpt * (fdata->stop_unit - fdata->start_unit + 1);\n\n\t \n\titcw_size = itcw_calc_size(0, count, 0);\n\n\tcqr = dasd_fmalloc_request(DASD_ECKD_MAGIC, 0, itcw_size, startdev);\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\n\tstart_priv->count++;\n\n\titcw = itcw_init(cqr->data, itcw_size, ITCW_OP_READ, 0, count, 0);\n\tif (IS_ERR(itcw)) {\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tcqr->cpaddr = itcw_get_tcw(itcw);\n\trc = prepare_itcw(itcw, fdata->start_unit, fdata->stop_unit,\n\t\t\t  DASD_ECKD_CCW_READ_COUNT_MT, base, startdev, 0, count,\n\t\t\t  sizeof(struct eckd_count),\n\t\t\t  count * sizeof(struct eckd_count), 0, rpt);\n\tif (rc)\n\t\tgoto out_err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tlast_tidaw = itcw_add_tidaw(itcw, 0, fmt_buffer++,\n\t\t\t\t\t    sizeof(struct eckd_count));\n\t\tif (IS_ERR(last_tidaw)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tlast_tidaw->flags |= TIDAW_FLAGS_LAST;\n\titcw_finalize(itcw);\n\n\tcqr->cpmode = 1;\n\tcqr->startdev = startdev;\n\tcqr->memdev = startdev;\n\tcqr->basedev = base;\n\tcqr->retries = startdev->default_retries;\n\tcqr->expires = startdev->default_expires * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\t \n\tset_bit(DASD_CQR_SUPPRESS_FP, &cqr->flags);\n\tset_bit(DASD_CQR_SUPPRESS_IL, &cqr->flags);\n\n\treturn cqr;\n\nout_err:\n\tdasd_sfree_request(cqr, startdev);\n\n\treturn ERR_PTR(rc);\n}\n\n \nstatic struct dasd_ccw_req *\ndasd_eckd_build_check(struct dasd_device *base, struct format_data_t *fdata,\n\t\t      int enable_pav, struct eckd_count *fmt_buffer, int rpt)\n{\n\tstruct dasd_eckd_private *start_priv;\n\tstruct dasd_eckd_private *base_priv;\n\tstruct dasd_device *startdev = NULL;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tvoid *data;\n\tint cplength, datasize;\n\tint use_prefix;\n\tint count;\n\tint i;\n\n\tif (enable_pav)\n\t\tstartdev = dasd_alias_get_start_dev(base);\n\n\tif (!startdev)\n\t\tstartdev = base;\n\n\tstart_priv = startdev->private;\n\tbase_priv = base->private;\n\n\tcount = rpt * (fdata->stop_unit - fdata->start_unit + 1);\n\n\tuse_prefix = base_priv->features.feature[8] & 0x01;\n\n\tif (use_prefix) {\n\t\tcplength = 1;\n\t\tdatasize = sizeof(struct PFX_eckd_data);\n\t} else {\n\t\tcplength = 2;\n\t\tdatasize = sizeof(struct DE_eckd_data) +\n\t\t\tsizeof(struct LO_eckd_data);\n\t}\n\tcplength += count;\n\n\tcqr = dasd_fmalloc_request(DASD_ECKD_MAGIC, cplength, datasize, startdev);\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\n\tstart_priv->count++;\n\tdata = cqr->data;\n\tccw = cqr->cpaddr;\n\n\tif (use_prefix) {\n\t\tprefix_LRE(ccw++, data, fdata->start_unit, fdata->stop_unit,\n\t\t\t   DASD_ECKD_CCW_READ_COUNT, base, startdev, 1, 0,\n\t\t\t   count, 0, 0);\n\t} else {\n\t\tdefine_extent(ccw++, data, fdata->start_unit, fdata->stop_unit,\n\t\t\t      DASD_ECKD_CCW_READ_COUNT, startdev, 0);\n\n\t\tdata += sizeof(struct DE_eckd_data);\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\n\t\tlocate_record(ccw++, data, fdata->start_unit, 0, count,\n\t\t\t      DASD_ECKD_CCW_READ_COUNT, base, 0);\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;\n\t\tccw->flags = CCW_FLAG_SLI;\n\t\tccw->count = 8;\n\t\tccw->cda = (__u32)virt_to_phys(fmt_buffer);\n\t\tccw++;\n\t\tfmt_buffer++;\n\t}\n\n\tcqr->startdev = startdev;\n\tcqr->memdev = startdev;\n\tcqr->basedev = base;\n\tcqr->retries = DASD_RETRIES;\n\tcqr->expires = startdev->default_expires * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\t \n\tset_bit(DASD_CQR_SUPPRESS_NRF, &cqr->flags);\n\n\treturn cqr;\n}\n\nstatic struct dasd_ccw_req *\ndasd_eckd_build_format(struct dasd_device *base, struct dasd_device *startdev,\n\t\t       struct format_data_t *fdata, int enable_pav)\n{\n\tstruct dasd_eckd_private *base_priv;\n\tstruct dasd_eckd_private *start_priv;\n\tstruct dasd_ccw_req *fcp;\n\tstruct eckd_count *ect;\n\tstruct ch_t address;\n\tstruct ccw1 *ccw;\n\tvoid *data;\n\tint rpt;\n\tint cplength, datasize;\n\tint i, j;\n\tint intensity = 0;\n\tint r0_perm;\n\tint nr_tracks;\n\tint use_prefix;\n\n\tif (enable_pav)\n\t\tstartdev = dasd_alias_get_start_dev(base);\n\n\tif (!startdev)\n\t\tstartdev = base;\n\n\tstart_priv = startdev->private;\n\tbase_priv = base->private;\n\n\trpt = recs_per_track(&base_priv->rdc_data, 0, fdata->blksize);\n\n\tnr_tracks = fdata->stop_unit - fdata->start_unit + 1;\n\n\t \n\tif (fdata->intensity & 0x10) {\n\t\tr0_perm = 0;\n\t\tintensity = fdata->intensity & ~0x10;\n\t} else {\n\t\tr0_perm = 1;\n\t\tintensity = fdata->intensity;\n\t}\n\n\tuse_prefix = base_priv->features.feature[8] & 0x01;\n\n\tswitch (intensity) {\n\tcase 0x00:\t \n\tcase 0x08:\t \n\t\tcplength = 2 + (rpt*nr_tracks);\n\t\tif (use_prefix)\n\t\t\tdatasize = sizeof(struct PFX_eckd_data) +\n\t\t\t\tsizeof(struct LO_eckd_data) +\n\t\t\t\trpt * nr_tracks * sizeof(struct eckd_count);\n\t\telse\n\t\t\tdatasize = sizeof(struct DE_eckd_data) +\n\t\t\t\tsizeof(struct LO_eckd_data) +\n\t\t\t\trpt * nr_tracks * sizeof(struct eckd_count);\n\t\tbreak;\n\tcase 0x01:\t \n\tcase 0x09:\t \n\t\tcplength = 2 + rpt * nr_tracks;\n\t\tif (use_prefix)\n\t\t\tdatasize = sizeof(struct PFX_eckd_data) +\n\t\t\t\tsizeof(struct LO_eckd_data) +\n\t\t\t\tsizeof(struct eckd_count) +\n\t\t\t\trpt * nr_tracks * sizeof(struct eckd_count);\n\t\telse\n\t\t\tdatasize = sizeof(struct DE_eckd_data) +\n\t\t\t\tsizeof(struct LO_eckd_data) +\n\t\t\t\tsizeof(struct eckd_count) +\n\t\t\t\trpt * nr_tracks * sizeof(struct eckd_count);\n\t\tbreak;\n\tcase 0x04:\t \n\tcase 0x0c:\t \n\t\tcplength = 3;\n\t\tif (use_prefix)\n\t\t\tdatasize = sizeof(struct PFX_eckd_data) +\n\t\t\t\tsizeof(struct LO_eckd_data) +\n\t\t\t\tsizeof(struct eckd_count);\n\t\telse\n\t\t\tdatasize = sizeof(struct DE_eckd_data) +\n\t\t\t\tsizeof(struct LO_eckd_data) +\n\t\t\t\tsizeof(struct eckd_count);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&startdev->cdev->dev,\n\t\t\t \"An I/O control call used incorrect flags 0x%x\\n\",\n\t\t\t fdata->intensity);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfcp = dasd_fmalloc_request(DASD_ECKD_MAGIC, cplength, datasize, startdev);\n\tif (IS_ERR(fcp))\n\t\treturn fcp;\n\n\tstart_priv->count++;\n\tdata = fcp->data;\n\tccw = fcp->cpaddr;\n\n\tswitch (intensity & ~0x08) {\n\tcase 0x00:  \n\t\tif (use_prefix) {\n\t\t\tprefix(ccw++, (struct PFX_eckd_data *) data,\n\t\t\t       fdata->start_unit, fdata->stop_unit,\n\t\t\t       DASD_ECKD_CCW_WRITE_CKD, base, startdev);\n\t\t\t \n\t\t\tif (r0_perm)\n\t\t\t\t((struct PFX_eckd_data *)data)\n\t\t\t\t\t->define_extent.ga_extended |= 0x04;\n\t\t\tdata += sizeof(struct PFX_eckd_data);\n\t\t} else {\n\t\t\tdefine_extent(ccw++, (struct DE_eckd_data *) data,\n\t\t\t\t      fdata->start_unit, fdata->stop_unit,\n\t\t\t\t      DASD_ECKD_CCW_WRITE_CKD, startdev, 0);\n\t\t\t \n\t\t\tif (r0_perm)\n\t\t\t\t((struct DE_eckd_data *) data)\n\t\t\t\t\t->ga_extended |= 0x04;\n\t\t\tdata += sizeof(struct DE_eckd_data);\n\t\t}\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tlocate_record(ccw++, (struct LO_eckd_data *) data,\n\t\t\t      fdata->start_unit, 0, rpt*nr_tracks,\n\t\t\t      DASD_ECKD_CCW_WRITE_CKD, base,\n\t\t\t      fdata->blksize);\n\t\tdata += sizeof(struct LO_eckd_data);\n\t\tbreak;\n\tcase 0x01:  \n\t\tif (use_prefix) {\n\t\t\tprefix(ccw++, (struct PFX_eckd_data *) data,\n\t\t\t       fdata->start_unit, fdata->stop_unit,\n\t\t\t       DASD_ECKD_CCW_WRITE_RECORD_ZERO,\n\t\t\t       base, startdev);\n\t\t\tdata += sizeof(struct PFX_eckd_data);\n\t\t} else {\n\t\t\tdefine_extent(ccw++, (struct DE_eckd_data *) data,\n\t\t\t       fdata->start_unit, fdata->stop_unit,\n\t\t\t       DASD_ECKD_CCW_WRITE_RECORD_ZERO, startdev, 0);\n\t\t\tdata += sizeof(struct DE_eckd_data);\n\t\t}\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tlocate_record(ccw++, (struct LO_eckd_data *) data,\n\t\t\t      fdata->start_unit, 0, rpt * nr_tracks + 1,\n\t\t\t      DASD_ECKD_CCW_WRITE_RECORD_ZERO, base,\n\t\t\t      base->block->bp_block);\n\t\tdata += sizeof(struct LO_eckd_data);\n\t\tbreak;\n\tcase 0x04:  \n\t\tif (use_prefix) {\n\t\t\tprefix(ccw++, (struct PFX_eckd_data *) data,\n\t\t\t       fdata->start_unit, fdata->stop_unit,\n\t\t\t       DASD_ECKD_CCW_WRITE_CKD, base, startdev);\n\t\t\tdata += sizeof(struct PFX_eckd_data);\n\t\t} else {\n\t\t\tdefine_extent(ccw++, (struct DE_eckd_data *) data,\n\t\t\t       fdata->start_unit, fdata->stop_unit,\n\t\t\t       DASD_ECKD_CCW_WRITE_CKD, startdev, 0);\n\t\t\tdata += sizeof(struct DE_eckd_data);\n\t\t}\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tlocate_record(ccw++, (struct LO_eckd_data *) data,\n\t\t\t      fdata->start_unit, 0, 1,\n\t\t\t      DASD_ECKD_CCW_WRITE_CKD, base, 8);\n\t\tdata += sizeof(struct LO_eckd_data);\n\t\tbreak;\n\t}\n\n\tfor (j = 0; j < nr_tracks; j++) {\n\t\t \n\t\tset_ch_t(&address,\n\t\t\t (fdata->start_unit + j) /\n\t\t\t base_priv->rdc_data.trk_per_cyl,\n\t\t\t (fdata->start_unit + j) %\n\t\t\t base_priv->rdc_data.trk_per_cyl);\n\t\tif (intensity & 0x01) {\t \n\t\t\tect = (struct eckd_count *) data;\n\t\t\tdata += sizeof(struct eckd_count);\n\t\t\tect->cyl = address.cyl;\n\t\t\tect->head = address.head;\n\t\t\tect->record = 0;\n\t\t\tect->kl = 0;\n\t\t\tect->dl = 8;\n\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\tccw->cmd_code = DASD_ECKD_CCW_WRITE_RECORD_ZERO;\n\t\t\tccw->flags = CCW_FLAG_SLI;\n\t\t\tccw->count = 8;\n\t\t\tccw->cda = (__u32)virt_to_phys(ect);\n\t\t\tccw++;\n\t\t}\n\t\tif ((intensity & ~0x08) & 0x04) {\t \n\t\t\tect = (struct eckd_count *) data;\n\t\t\tdata += sizeof(struct eckd_count);\n\t\t\tect->cyl = address.cyl;\n\t\t\tect->head = address.head;\n\t\t\tect->record = 1;\n\t\t\tect->kl = 0;\n\t\t\tect->dl = 0;\n\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\tccw->cmd_code = DASD_ECKD_CCW_WRITE_CKD;\n\t\t\tccw->flags = CCW_FLAG_SLI;\n\t\t\tccw->count = 8;\n\t\t\tccw->cda = (__u32)virt_to_phys(ect);\n\t\t} else {\t\t \n\t\t\tfor (i = 0; i < rpt; i++) {\n\t\t\t\tect = (struct eckd_count *) data;\n\t\t\t\tdata += sizeof(struct eckd_count);\n\t\t\t\tect->cyl = address.cyl;\n\t\t\t\tect->head = address.head;\n\t\t\t\tect->record = i + 1;\n\t\t\t\tect->kl = 0;\n\t\t\t\tect->dl = fdata->blksize;\n\t\t\t\t \n\t\t\t\tif ((intensity & 0x08) &&\n\t\t\t\t    address.cyl == 0 && address.head == 0) {\n\t\t\t\t\tif (i < 3) {\n\t\t\t\t\t\tect->kl = 4;\n\t\t\t\t\t\tect->dl = sizes_trk0[i] - 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((intensity & 0x08) &&\n\t\t\t\t    address.cyl == 0 && address.head == 1) {\n\t\t\t\t\tect->kl = 44;\n\t\t\t\t\tect->dl = LABEL_SIZE - 44;\n\t\t\t\t}\n\t\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\t\tif (i != 0 || j == 0)\n\t\t\t\t\tccw->cmd_code =\n\t\t\t\t\t\tDASD_ECKD_CCW_WRITE_CKD;\n\t\t\t\telse\n\t\t\t\t\tccw->cmd_code =\n\t\t\t\t\t\tDASD_ECKD_CCW_WRITE_CKD_MT;\n\t\t\t\tccw->flags = CCW_FLAG_SLI;\n\t\t\t\tccw->count = 8;\n\t\t\t\tccw->cda = (__u32)virt_to_phys(ect);\n\t\t\t\tccw++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfcp->startdev = startdev;\n\tfcp->memdev = startdev;\n\tfcp->basedev = base;\n\tfcp->retries = 256;\n\tfcp->expires = startdev->default_expires * HZ;\n\tfcp->buildclk = get_tod_clock();\n\tfcp->status = DASD_CQR_FILLED;\n\n\treturn fcp;\n}\n\n \nstatic struct dasd_ccw_req *\ndasd_eckd_format_build_ccw_req(struct dasd_device *base,\n\t\t\t       struct format_data_t *fdata, int enable_pav,\n\t\t\t       int tpm, struct eckd_count *fmt_buffer, int rpt)\n{\n\tstruct dasd_ccw_req *ccw_req;\n\n\tif (!fmt_buffer) {\n\t\tccw_req = dasd_eckd_build_format(base, NULL, fdata, enable_pav);\n\t} else {\n\t\tif (tpm)\n\t\t\tccw_req = dasd_eckd_build_check_tcw(base, fdata,\n\t\t\t\t\t\t\t    enable_pav,\n\t\t\t\t\t\t\t    fmt_buffer, rpt);\n\t\telse\n\t\t\tccw_req = dasd_eckd_build_check(base, fdata, enable_pav,\n\t\t\t\t\t\t\tfmt_buffer, rpt);\n\t}\n\n\treturn ccw_req;\n}\n\n \nstatic int dasd_eckd_format_sanity_checks(struct dasd_device *base,\n\t\t\t\t\t  struct format_data_t *fdata)\n{\n\tstruct dasd_eckd_private *private = base->private;\n\n\tif (fdata->start_unit >=\n\t    (private->real_cyl * private->rdc_data.trk_per_cyl)) {\n\t\tdev_warn(&base->cdev->dev,\n\t\t\t \"Start track number %u used in formatting is too big\\n\",\n\t\t\t fdata->start_unit);\n\t\treturn -EINVAL;\n\t}\n\tif (fdata->stop_unit >=\n\t    (private->real_cyl * private->rdc_data.trk_per_cyl)) {\n\t\tdev_warn(&base->cdev->dev,\n\t\t\t \"Stop track number %u used in formatting is too big\\n\",\n\t\t\t fdata->stop_unit);\n\t\treturn -EINVAL;\n\t}\n\tif (fdata->start_unit > fdata->stop_unit) {\n\t\tdev_warn(&base->cdev->dev,\n\t\t\t \"Start track %u used in formatting exceeds end track\\n\",\n\t\t\t fdata->start_unit);\n\t\treturn -EINVAL;\n\t}\n\tif (dasd_check_blocksize(fdata->blksize) != 0) {\n\t\tdev_warn(&base->cdev->dev,\n\t\t\t \"The DASD cannot be formatted with block size %u\\n\",\n\t\t\t fdata->blksize);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int dasd_eckd_format_process_data(struct dasd_device *base,\n\t\t\t\t\t struct format_data_t *fdata,\n\t\t\t\t\t int enable_pav, int tpm,\n\t\t\t\t\t struct eckd_count *fmt_buffer, int rpt,\n\t\t\t\t\t struct irb *irb)\n{\n\tstruct dasd_eckd_private *private = base->private;\n\tstruct dasd_ccw_req *cqr, *n;\n\tstruct list_head format_queue;\n\tstruct dasd_device *device;\n\tchar *sense = NULL;\n\tint old_start, old_stop, format_step;\n\tint step, retry;\n\tint rc;\n\n\trc = dasd_eckd_format_sanity_checks(base, fdata);\n\tif (rc)\n\t\treturn rc;\n\n\tINIT_LIST_HEAD(&format_queue);\n\n\told_start = fdata->start_unit;\n\told_stop = fdata->stop_unit;\n\n\tif (!tpm && fmt_buffer != NULL) {\n\t\t \n\t\tformat_step = 1;\n\t} else if (tpm && fmt_buffer != NULL) {\n\t\t \n\t\tformat_step = DASD_CQR_MAX_CCW / rpt;\n\t} else {\n\t\t \n\t\tformat_step = DASD_CQR_MAX_CCW /\n\t\t\trecs_per_track(&private->rdc_data, 0, fdata->blksize);\n\t}\n\n\tdo {\n\t\tretry = 0;\n\t\twhile (fdata->start_unit <= old_stop) {\n\t\t\tstep = fdata->stop_unit - fdata->start_unit + 1;\n\t\t\tif (step > format_step) {\n\t\t\t\tfdata->stop_unit =\n\t\t\t\t\tfdata->start_unit + format_step - 1;\n\t\t\t}\n\n\t\t\tcqr = dasd_eckd_format_build_ccw_req(base, fdata,\n\t\t\t\t\t\t\t     enable_pav, tpm,\n\t\t\t\t\t\t\t     fmt_buffer, rpt);\n\t\t\tif (IS_ERR(cqr)) {\n\t\t\t\trc = PTR_ERR(cqr);\n\t\t\t\tif (rc == -ENOMEM) {\n\t\t\t\t\tif (list_empty(&format_queue))\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t \n\t\t\t\t\tretry = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tlist_add_tail(&cqr->blocklist, &format_queue);\n\n\t\t\tif (fmt_buffer) {\n\t\t\t\tstep = fdata->stop_unit - fdata->start_unit + 1;\n\t\t\t\tfmt_buffer += rpt * step;\n\t\t\t}\n\t\t\tfdata->start_unit = fdata->stop_unit + 1;\n\t\t\tfdata->stop_unit = old_stop;\n\t\t}\n\n\t\trc = dasd_sleep_on_queue(&format_queue);\n\nout_err:\n\t\tlist_for_each_entry_safe(cqr, n, &format_queue, blocklist) {\n\t\t\tdevice = cqr->startdev;\n\t\t\tprivate = device->private;\n\n\t\t\tif (cqr->status == DASD_CQR_FAILED) {\n\t\t\t\t \n\t\t\t\tif (fmt_buffer && irb) {\n\t\t\t\t\tsense = dasd_get_sense(&cqr->irb);\n\t\t\t\t\tmemcpy(irb, &cqr->irb, sizeof(*irb));\n\t\t\t\t}\n\t\t\t\trc = -EIO;\n\t\t\t}\n\t\t\tlist_del_init(&cqr->blocklist);\n\t\t\tdasd_ffree_request(cqr, device);\n\t\t\tprivate->count--;\n\t\t}\n\n\t\tif (rc && rc != -EIO)\n\t\t\tgoto out;\n\t\tif (rc == -EIO) {\n\t\t\t \n\t\t\tif (sense &&\n\t\t\t    (sense[1] & SNS1_NO_REC_FOUND ||\n\t\t\t     sense[1] & SNS1_FILE_PROTECTED))\n\t\t\t\tretry = 1;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\n\t} while (retry);\n\nout:\n\tfdata->start_unit = old_start;\n\tfdata->stop_unit = old_stop;\n\n\treturn rc;\n}\n\nstatic int dasd_eckd_format_device(struct dasd_device *base,\n\t\t\t\t   struct format_data_t *fdata, int enable_pav)\n{\n\treturn dasd_eckd_format_process_data(base, fdata, enable_pav, 0, NULL,\n\t\t\t\t\t     0, NULL);\n}\n\nstatic bool test_and_set_format_track(struct dasd_format_entry *to_format,\n\t\t\t\t      struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_block *block = cqr->block;\n\tstruct dasd_format_entry *format;\n\tunsigned long flags;\n\tbool rc = false;\n\n\tspin_lock_irqsave(&block->format_lock, flags);\n\tif (cqr->trkcount != atomic_read(&block->trkcount)) {\n\t\t \n\t\trc = true;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(format, &block->format_list, list) {\n\t\tif (format->track == to_format->track) {\n\t\t\trc = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlist_add_tail(&to_format->list, &block->format_list);\n\nout:\n\tspin_unlock_irqrestore(&block->format_lock, flags);\n\treturn rc;\n}\n\nstatic void clear_format_track(struct dasd_format_entry *format,\n\t\t\t      struct dasd_block *block)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&block->format_lock, flags);\n\tatomic_inc(&block->trkcount);\n\tlist_del_init(&format->list);\n\tspin_unlock_irqrestore(&block->format_lock, flags);\n}\n\n \nstatic void dasd_eckd_ese_format_cb(struct dasd_ccw_req *cqr, void *data)\n{\n\tstruct dasd_device *device = cqr->startdev;\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_format_entry *format = data;\n\n\tclear_format_track(format, cqr->basedev->block);\n\tprivate->count--;\n\tdasd_ffree_request(cqr, device);\n}\n\nstatic struct dasd_ccw_req *\ndasd_eckd_ese_format(struct dasd_device *startdev, struct dasd_ccw_req *cqr,\n\t\t     struct irb *irb)\n{\n\tstruct dasd_eckd_private *private;\n\tstruct dasd_format_entry *format;\n\tstruct format_data_t fdata;\n\tunsigned int recs_per_trk;\n\tstruct dasd_ccw_req *fcqr;\n\tstruct dasd_device *base;\n\tstruct dasd_block *block;\n\tunsigned int blksize;\n\tstruct request *req;\n\tsector_t first_trk;\n\tsector_t last_trk;\n\tsector_t curr_trk;\n\tint rc;\n\n\treq = dasd_get_callback_data(cqr);\n\tblock = cqr->block;\n\tbase = block->base;\n\tprivate = base->private;\n\tblksize = block->bp_block;\n\trecs_per_trk = recs_per_track(&private->rdc_data, 0, blksize);\n\tformat = &startdev->format_entry;\n\n\tfirst_trk = blk_rq_pos(req) >> block->s2b_shift;\n\tsector_div(first_trk, recs_per_trk);\n\tlast_trk =\n\t\t(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\n\tsector_div(last_trk, recs_per_trk);\n\trc = dasd_eckd_track_from_irb(irb, base, &curr_trk);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\tif (curr_trk < first_trk || curr_trk > last_trk) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, startdev,\n\t\t\t      \"ESE error track %llu not within range %llu - %llu\\n\",\n\t\t\t      curr_trk, first_trk, last_trk);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tformat->track = curr_trk;\n\t \n\tif (test_and_set_format_track(format, cqr)) {\n\t\t \n\t\tcqr->retries++;\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\n\tfdata.start_unit = curr_trk;\n\tfdata.stop_unit = curr_trk;\n\tfdata.blksize = blksize;\n\tfdata.intensity = private->uses_cdl ? DASD_FMT_INT_COMPAT : 0;\n\n\trc = dasd_eckd_format_sanity_checks(base, &fdata);\n\tif (rc)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tfcqr = dasd_eckd_build_format(base, startdev, &fdata, 0);\n\tif (IS_ERR(fcqr))\n\t\treturn fcqr;\n\n\tfcqr->callback = dasd_eckd_ese_format_cb;\n\tfcqr->callback_data = (void *) format;\n\n\treturn fcqr;\n}\n\n \nstatic int dasd_eckd_ese_read(struct dasd_ccw_req *cqr, struct irb *irb)\n{\n\tstruct dasd_eckd_private *private;\n\tsector_t first_trk, last_trk;\n\tsector_t first_blk, last_blk;\n\tunsigned int blksize, off;\n\tunsigned int recs_per_trk;\n\tstruct dasd_device *base;\n\tstruct req_iterator iter;\n\tstruct dasd_block *block;\n\tunsigned int skip_block;\n\tunsigned int blk_count;\n\tstruct request *req;\n\tstruct bio_vec bv;\n\tsector_t curr_trk;\n\tsector_t end_blk;\n\tchar *dst;\n\tint rc;\n\n\treq = (struct request *) cqr->callback_data;\n\tbase = cqr->block->base;\n\tblksize = base->block->bp_block;\n\tblock =  cqr->block;\n\tprivate = base->private;\n\tskip_block = 0;\n\tblk_count = 0;\n\n\trecs_per_trk = recs_per_track(&private->rdc_data, 0, blksize);\n\tfirst_trk = first_blk = blk_rq_pos(req) >> block->s2b_shift;\n\tsector_div(first_trk, recs_per_trk);\n\tlast_trk = last_blk =\n\t\t(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\n\tsector_div(last_trk, recs_per_trk);\n\trc = dasd_eckd_track_from_irb(irb, base, &curr_trk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (curr_trk < first_trk || curr_trk > last_trk) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, base,\n\t\t\t      \"ESE error track %llu not within range %llu - %llu\\n\",\n\t\t\t      curr_trk, first_trk, last_trk);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (curr_trk != first_trk)\n\t\tskip_block = curr_trk * recs_per_trk - first_blk;\n\n\t \n\tend_blk = (curr_trk + 1) * recs_per_trk;\n\n\trq_for_each_segment(bv, req, iter) {\n\t\tdst = bvec_virt(&bv);\n\t\tfor (off = 0; off < bv.bv_len; off += blksize) {\n\t\t\tif (first_blk + blk_count >= end_blk) {\n\t\t\t\tcqr->proc_bytes = blk_count * blksize;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (dst && !skip_block)\n\t\t\t\tmemset(dst, 0, blksize);\n\t\t\telse\n\t\t\t\tskip_block--;\n\t\t\tdst += blksize;\n\t\t\tblk_count++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int dasd_eckd_count_records(struct eckd_count *fmt_buffer, int start,\n\t\t\t\t   int max)\n{\n\tint head;\n\tint i;\n\n\thead = fmt_buffer[start].head;\n\n\t \n\tfor (i = start; i < max; i++) {\n\t\tif (i > start) {\n\t\t\tif ((fmt_buffer[i].head == head &&\n\t\t\t    fmt_buffer[i].record == 1) ||\n\t\t\t    fmt_buffer[i].head != head ||\n\t\t\t    fmt_buffer[i].record == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn i - start;\n}\n\n \nstatic void dasd_eckd_format_evaluate_tracks(struct eckd_count *fmt_buffer,\n\t\t\t\t\t     struct format_check_t *cdata,\n\t\t\t\t\t     int rpt_max, int rpt_exp,\n\t\t\t\t\t     int trk_per_cyl, int tpm)\n{\n\tstruct ch_t geo;\n\tint max_entries;\n\tint count = 0;\n\tint trkcount;\n\tint blksize;\n\tint pos = 0;\n\tint i, j;\n\tint kl;\n\n\ttrkcount = cdata->expect.stop_unit - cdata->expect.start_unit + 1;\n\tmax_entries = trkcount * rpt_max;\n\n\tfor (i = cdata->expect.start_unit; i <= cdata->expect.stop_unit; i++) {\n\t\t \n\t\tif (tpm) {\n\t\t\twhile (fmt_buffer[pos].record == 0 &&\n\t\t\t       fmt_buffer[pos].dl == 0) {\n\t\t\t\tif (pos++ > max_entries)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i != cdata->expect.start_unit)\n\t\t\t\tpos += rpt_max - count;\n\t\t}\n\n\t\t \n\t\tset_ch_t(&geo, i / trk_per_cyl, i % trk_per_cyl);\n\n\t\t \n\t\tcount = dasd_eckd_count_records(fmt_buffer, pos, pos + rpt_max);\n\n\t\tif (count < rpt_exp) {\n\t\t\tcdata->result = DASD_FMT_ERR_TOO_FEW_RECORDS;\n\t\t\tbreak;\n\t\t}\n\t\tif (count > rpt_exp) {\n\t\t\tcdata->result = DASD_FMT_ERR_TOO_MANY_RECORDS;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < count; j++, pos++) {\n\t\t\tblksize = cdata->expect.blksize;\n\t\t\tkl = 0;\n\n\t\t\t \n\t\t\tif ((cdata->expect.intensity & 0x08) &&\n\t\t\t    geo.cyl == 0 && geo.head == 0) {\n\t\t\t\tif (j < 3) {\n\t\t\t\t\tblksize = sizes_trk0[j] - 4;\n\t\t\t\t\tkl = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((cdata->expect.intensity & 0x08) &&\n\t\t\t    geo.cyl == 0 && geo.head == 1) {\n\t\t\t\tblksize = LABEL_SIZE - 44;\n\t\t\t\tkl = 44;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (fmt_buffer[pos].dl != blksize) {\n\t\t\t\tcdata->result = DASD_FMT_ERR_BLKSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (fmt_buffer[pos].kl != kl) {\n\t\t\t\tcdata->result = DASD_FMT_ERR_KEY_LENGTH;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (fmt_buffer[pos].cyl != geo.cyl ||\n\t\t\t    fmt_buffer[pos].head != geo.head ||\n\t\t\t    fmt_buffer[pos].record != (j + 1)) {\n\t\t\t\tcdata->result = DASD_FMT_ERR_RECORD_ID;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t \n\tif (!cdata->result) {\n\t\ti--;\n\t\tpos--;\n\t}\n\n\tcdata->unit = i;\n\tcdata->num_records = count;\n\tcdata->rec = fmt_buffer[pos].record;\n\tcdata->blksize = fmt_buffer[pos].dl;\n\tcdata->key_length = fmt_buffer[pos].kl;\n}\n\n \nstatic int dasd_eckd_check_device_format(struct dasd_device *base,\n\t\t\t\t\t struct format_check_t *cdata,\n\t\t\t\t\t int enable_pav)\n{\n\tstruct dasd_eckd_private *private = base->private;\n\tstruct eckd_count *fmt_buffer;\n\tstruct irb irb;\n\tint rpt_max, rpt_exp;\n\tint fmt_buffer_size;\n\tint trk_per_cyl;\n\tint trkcount;\n\tint tpm = 0;\n\tint rc;\n\n\ttrk_per_cyl = private->rdc_data.trk_per_cyl;\n\n\t \n\trpt_max = recs_per_track(&private->rdc_data, 0, 512) + 1;\n\trpt_exp = recs_per_track(&private->rdc_data, 0, cdata->expect.blksize);\n\n\ttrkcount = cdata->expect.stop_unit - cdata->expect.start_unit + 1;\n\tfmt_buffer_size = trkcount * rpt_max * sizeof(struct eckd_count);\n\n\tfmt_buffer = kzalloc(fmt_buffer_size, GFP_KERNEL | GFP_DMA);\n\tif (!fmt_buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tif ((private->features.feature[40] & 0x04) &&\n\t    fmt_buffer_size <= private->fcx_max_data)\n\t\ttpm = 1;\n\n\trc = dasd_eckd_format_process_data(base, &cdata->expect, enable_pav,\n\t\t\t\t\t   tpm, fmt_buffer, rpt_max, &irb);\n\tif (rc && rc != -EIO)\n\t\tgoto out;\n\tif (rc == -EIO) {\n\t\t \n\t\tif (tpm && scsw_cstat(&irb.scsw) == 0x40) {\n\t\t\ttpm = 0;\n\t\t\trc = dasd_eckd_format_process_data(base, &cdata->expect,\n\t\t\t\t\t\t\t   enable_pav, tpm,\n\t\t\t\t\t\t\t   fmt_buffer, rpt_max,\n\t\t\t\t\t\t\t   &irb);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdasd_eckd_format_evaluate_tracks(fmt_buffer, cdata, rpt_max, rpt_exp,\n\t\t\t\t\t trk_per_cyl, tpm);\n\nout:\n\tkfree(fmt_buffer);\n\n\treturn rc;\n}\n\nstatic void dasd_eckd_handle_terminated_request(struct dasd_ccw_req *cqr)\n{\n\tif (cqr->retries < 0) {\n\t\tcqr->status = DASD_CQR_FAILED;\n\t\treturn;\n\t}\n\tcqr->status = DASD_CQR_FILLED;\n\tif (cqr->block && (cqr->startdev != cqr->block->base)) {\n\t\tdasd_eckd_reset_ccw_to_base_io(cqr);\n\t\tcqr->startdev = cqr->block->base;\n\t\tcqr->lpm = dasd_path_get_opm(cqr->block->base);\n\t}\n};\n\nstatic dasd_erp_fn_t\ndasd_eckd_erp_action(struct dasd_ccw_req * cqr)\n{\n\tstruct dasd_device *device = (struct dasd_device *) cqr->startdev;\n\tstruct ccw_device *cdev = device->cdev;\n\n\tswitch (cdev->id.cu_type) {\n\tcase 0x3990:\n\tcase 0x2105:\n\tcase 0x2107:\n\tcase 0x1750:\n\t\treturn dasd_3990_erp_action;\n\tcase 0x9343:\n\tcase 0x3880:\n\tdefault:\n\t\treturn dasd_default_erp_action;\n\t}\n}\n\nstatic dasd_erp_fn_t\ndasd_eckd_erp_postaction(struct dasd_ccw_req * cqr)\n{\n\treturn dasd_default_erp_postaction;\n}\n\nstatic void dasd_eckd_check_for_device_change(struct dasd_device *device,\n\t\t\t\t\t      struct dasd_ccw_req *cqr,\n\t\t\t\t\t      struct irb *irb)\n{\n\tchar mask;\n\tchar *sense = NULL;\n\tstruct dasd_eckd_private *private = device->private;\n\n\t \n\tmask = DEV_STAT_ATTENTION | DEV_STAT_DEV_END | DEV_STAT_UNIT_EXCEP;\n\tif ((scsw_dstat(&irb->scsw) & mask) == mask) {\n\t\t \n\t\tif (!device->block && private->lcu &&\n\t\t    device->state == DASD_STATE_ONLINE &&\n\t\t    !test_bit(DASD_FLAG_OFFLINE, &device->flags) &&\n\t\t    !test_bit(DASD_FLAG_SUSPENDED, &device->flags)) {\n\t\t\t \n\t\t\tdasd_reload_device(device);\n\t\t}\n\t\tdasd_generic_handle_state_change(device);\n\t\treturn;\n\t}\n\n\tsense = dasd_get_sense(irb);\n\tif (!sense)\n\t\treturn;\n\n\t \n\tif ((sense[27] & DASD_SENSE_BIT_0) && (sense[7] == 0x0D) &&\n\t    (scsw_dstat(&irb->scsw) & DEV_STAT_UNIT_CHECK)) {\n\t\tif (test_and_set_bit(DASD_FLAG_SUC, &device->flags)) {\n\t\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t\t      \"eckd suc: device already notified\");\n\t\t\treturn;\n\t\t}\n\t\tsense = dasd_get_sense(irb);\n\t\tif (!sense) {\n\t\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t\t      \"eckd suc: no reason code available\");\n\t\t\tclear_bit(DASD_FLAG_SUC, &device->flags);\n\t\t\treturn;\n\n\t\t}\n\t\tprivate->suc_reason = sense[8];\n\t\tDBF_DEV_EVENT(DBF_NOTICE, device, \"%s %x\",\n\t\t\t      \"eckd handle summary unit check: reason\",\n\t\t\t      private->suc_reason);\n\t\tdasd_get_device(device);\n\t\tif (!schedule_work(&device->suc_work))\n\t\t\tdasd_put_device(device);\n\n\t\treturn;\n\t}\n\n\t \n\tif (!cqr && !(sense[27] & DASD_SENSE_BIT_0) &&\n\t    ((sense[6] & DASD_SIM_SENSE) == DASD_SIM_SENSE)) {\n\t\tdasd_3990_erp_handle_sim(device, sense);\n\t\treturn;\n\t}\n\n\t \n\tif (device->block && (sense[27] & DASD_SENSE_BIT_0) &&\n\t    (sense[7] == 0x3F) &&\n\t    (scsw_dstat(&irb->scsw) & DEV_STAT_UNIT_CHECK) &&\n\t    test_bit(DASD_FLAG_IS_RESERVED, &device->flags)) {\n\t\tif (device->features & DASD_FEATURE_FAILONSLCK)\n\t\t\tset_bit(DASD_FLAG_LOCK_STOLEN, &device->flags);\n\t\tclear_bit(DASD_FLAG_IS_RESERVED, &device->flags);\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"The device reservation was lost\\n\");\n\t}\n}\n\nstatic int dasd_eckd_ras_sanity_checks(struct dasd_device *device,\n\t\t\t\t       unsigned int first_trk,\n\t\t\t\t       unsigned int last_trk)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tunsigned int trks_per_vol;\n\tint rc = 0;\n\n\ttrks_per_vol = private->real_cyl * private->rdc_data.trk_per_cyl;\n\n\tif (first_trk >= trks_per_vol) {\n\t\tdev_warn(&device->cdev->dev,\n\t\t\t \"Start track number %u used in the space release command is too big\\n\",\n\t\t\t first_trk);\n\t\trc = -EINVAL;\n\t} else if (last_trk >= trks_per_vol) {\n\t\tdev_warn(&device->cdev->dev,\n\t\t\t \"Stop track number %u used in the space release command is too big\\n\",\n\t\t\t last_trk);\n\t\trc = -EINVAL;\n\t} else if (first_trk > last_trk) {\n\t\tdev_warn(&device->cdev->dev,\n\t\t\t \"Start track %u used in the space release command exceeds the end track\\n\",\n\t\t\t first_trk);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}\n\n \nstatic int count_exts(unsigned int from, unsigned int to, int trks_per_ext)\n{\n\tint cur_pos = 0;\n\tint count = 0;\n\tint tmp;\n\n\tif (from == to)\n\t\treturn 1;\n\n\t \n\tif (from % trks_per_ext != 0) {\n\t\ttmp = from + trks_per_ext - (from % trks_per_ext) - 1;\n\t\tif (tmp > to)\n\t\t\ttmp = to;\n\t\tcur_pos = tmp - from + 1;\n\t\tcount++;\n\t}\n\t \n\tif (to - (from + cur_pos) + 1 >= trks_per_ext) {\n\t\ttmp = to - ((to - trks_per_ext + 1) % trks_per_ext);\n\t\tcount += (tmp - (from + cur_pos) + 1) / trks_per_ext;\n\t\tcur_pos = tmp;\n\t}\n\t \n\tif (cur_pos < to)\n\t\tcount++;\n\n\treturn count;\n}\n\nstatic int dasd_in_copy_relation(struct dasd_device *device)\n{\n\tstruct dasd_pprc_data_sc4 *temp;\n\tint rc;\n\n\tif (!dasd_eckd_pprc_enabled(device))\n\t\treturn 0;\n\n\ttemp = kzalloc(sizeof(*temp), GFP_KERNEL);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\trc = dasd_eckd_query_pprc_status(device, temp);\n\tif (!rc)\n\t\trc = temp->dev_info[0].state;\n\n\tkfree(temp);\n\treturn rc;\n}\n\n \nstatic struct dasd_ccw_req *\ndasd_eckd_dso_ras(struct dasd_device *device, struct dasd_block *block,\n\t\t  struct request *req, unsigned int first_trk,\n\t\t  unsigned int last_trk, int by_extent)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_dso_ras_ext_range *ras_range;\n\tstruct dasd_rssd_features *features;\n\tstruct dasd_dso_ras_data *ras_data;\n\tu16 heads, beg_head, end_head;\n\tint cur_to_trk, cur_from_trk;\n\tstruct dasd_ccw_req *cqr;\n\tu32 beg_cyl, end_cyl;\n\tint copy_relation;\n\tstruct ccw1 *ccw;\n\tint trks_per_ext;\n\tsize_t ras_size;\n\tsize_t size;\n\tint nr_exts;\n\tvoid *rq;\n\tint i;\n\n\tif (dasd_eckd_ras_sanity_checks(device, first_trk, last_trk))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcopy_relation = dasd_in_copy_relation(device);\n\tif (copy_relation < 0)\n\t\treturn ERR_PTR(copy_relation);\n\n\trq = req ? blk_mq_rq_to_pdu(req) : NULL;\n\n\tfeatures = &private->features;\n\n\ttrks_per_ext = dasd_eckd_ext_size(device) * private->rdc_data.trk_per_cyl;\n\tnr_exts = 0;\n\tif (by_extent)\n\t\tnr_exts = count_exts(first_trk, last_trk, trks_per_ext);\n\tras_size = sizeof(*ras_data);\n\tsize = ras_size + (nr_exts * sizeof(*ras_range));\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, size, device, rq);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate RAS request\");\n\t\treturn cqr;\n\t}\n\n\tras_data = cqr->data;\n\tmemset(ras_data, 0, size);\n\n\tras_data->order = DSO_ORDER_RAS;\n\tras_data->flags.vol_type = 0;  \n\t \n\tras_data->op_flags.by_extent = by_extent;\n\t \n\tif (features->feature[56] & 0x01 && !copy_relation)\n\t\tras_data->op_flags.guarantee_init = 1;\n\n\tras_data->lss = private->conf.ned->ID;\n\tras_data->dev_addr = private->conf.ned->unit_addr;\n\tras_data->nr_exts = nr_exts;\n\n\tif (by_extent) {\n\t\theads = private->rdc_data.trk_per_cyl;\n\t\tcur_from_trk = first_trk;\n\t\tcur_to_trk = first_trk + trks_per_ext -\n\t\t\t(first_trk % trks_per_ext) - 1;\n\t\tif (cur_to_trk > last_trk)\n\t\t\tcur_to_trk = last_trk;\n\t\tras_range = (struct dasd_dso_ras_ext_range *)(cqr->data + ras_size);\n\n\t\tfor (i = 0; i < nr_exts; i++) {\n\t\t\tbeg_cyl = cur_from_trk / heads;\n\t\t\tbeg_head = cur_from_trk % heads;\n\t\t\tend_cyl = cur_to_trk / heads;\n\t\t\tend_head = cur_to_trk % heads;\n\n\t\t\tset_ch_t(&ras_range->beg_ext, beg_cyl, beg_head);\n\t\t\tset_ch_t(&ras_range->end_ext, end_cyl, end_head);\n\n\t\t\tcur_from_trk = cur_to_trk + 1;\n\t\t\tcur_to_trk = cur_from_trk + trks_per_ext - 1;\n\t\t\tif (cur_to_trk > last_trk)\n\t\t\t\tcur_to_trk = last_trk;\n\t\t\tras_range++;\n\t\t}\n\t}\n\n\tccw = cqr->cpaddr;\n\tccw->cda = (__u32)virt_to_phys(cqr->data);\n\tccw->cmd_code = DASD_ECKD_CCW_DSO;\n\tccw->count = size;\n\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = block;\n\tcqr->retries = 256;\n\tcqr->expires = device->default_expires * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\treturn cqr;\n}\n\nstatic int dasd_eckd_release_space_full(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc;\n\n\tcqr = dasd_eckd_dso_ras(device, NULL, NULL, 0, 0, 0);\n\tif (IS_ERR(cqr))\n\t\treturn PTR_ERR(cqr);\n\n\trc = dasd_sleep_on_interruptible(cqr);\n\n\tdasd_sfree_request(cqr, cqr->memdev);\n\n\treturn rc;\n}\n\nstatic int dasd_eckd_release_space_trks(struct dasd_device *device,\n\t\t\t\t\tunsigned int from, unsigned int to)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_block *block = device->block;\n\tstruct dasd_ccw_req *cqr, *n;\n\tstruct list_head ras_queue;\n\tunsigned int device_exts;\n\tint trks_per_ext;\n\tint stop, step;\n\tint cur_pos;\n\tint rc = 0;\n\tint retry;\n\n\tINIT_LIST_HEAD(&ras_queue);\n\n\tdevice_exts = private->real_cyl / dasd_eckd_ext_size(device);\n\ttrks_per_ext = dasd_eckd_ext_size(device) * private->rdc_data.trk_per_cyl;\n\n\t \n\tstep = trks_per_ext * min(device_exts, DASD_ECKD_RAS_EXTS_MAX);\n\tcur_pos = from;\n\n\tdo {\n\t\tretry = 0;\n\t\twhile (cur_pos < to) {\n\t\t\tstop = cur_pos + step -\n\t\t\t\t((cur_pos + step) % trks_per_ext) - 1;\n\t\t\tif (stop > to)\n\t\t\t\tstop = to;\n\n\t\t\tcqr = dasd_eckd_dso_ras(device, NULL, NULL, cur_pos, stop, 1);\n\t\t\tif (IS_ERR(cqr)) {\n\t\t\t\trc = PTR_ERR(cqr);\n\t\t\t\tif (rc == -ENOMEM) {\n\t\t\t\t\tif (list_empty(&ras_queue))\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tretry = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tspin_lock_irq(&block->queue_lock);\n\t\t\tlist_add_tail(&cqr->blocklist, &ras_queue);\n\t\t\tspin_unlock_irq(&block->queue_lock);\n\t\t\tcur_pos = stop + 1;\n\t\t}\n\n\t\trc = dasd_sleep_on_queue_interruptible(&ras_queue);\n\nerr_out:\n\t\tlist_for_each_entry_safe(cqr, n, &ras_queue, blocklist) {\n\t\t\tdevice = cqr->startdev;\n\t\t\tprivate = device->private;\n\n\t\t\tspin_lock_irq(&block->queue_lock);\n\t\t\tlist_del_init(&cqr->blocklist);\n\t\t\tspin_unlock_irq(&block->queue_lock);\n\t\t\tdasd_sfree_request(cqr, device);\n\t\t\tprivate->count--;\n\t\t}\n\t} while (retry);\n\nout:\n\treturn rc;\n}\n\nstatic int dasd_eckd_release_space(struct dasd_device *device,\n\t\t\t\t   struct format_data_t *rdata)\n{\n\tif (rdata->intensity & DASD_FMT_INT_ESE_FULL)\n\t\treturn dasd_eckd_release_space_full(device);\n\telse if (rdata->intensity == 0)\n\t\treturn dasd_eckd_release_space_trks(device, rdata->start_unit,\n\t\t\t\t\t\t    rdata->stop_unit);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic struct dasd_ccw_req *dasd_eckd_build_cp_cmd_single(\n\t\t\t\t\t       struct dasd_device *startdev,\n\t\t\t\t\t       struct dasd_block *block,\n\t\t\t\t\t       struct request *req,\n\t\t\t\t\t       sector_t first_rec,\n\t\t\t\t\t       sector_t last_rec,\n\t\t\t\t\t       sector_t first_trk,\n\t\t\t\t\t       sector_t last_trk,\n\t\t\t\t\t       unsigned int first_offs,\n\t\t\t\t\t       unsigned int last_offs,\n\t\t\t\t\t       unsigned int blk_per_trk,\n\t\t\t\t\t       unsigned int blksize)\n{\n\tstruct dasd_eckd_private *private;\n\tunsigned long *idaws;\n\tstruct LO_eckd_data *LO_data;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tstruct req_iterator iter;\n\tstruct bio_vec bv;\n\tchar *dst;\n\tunsigned int off;\n\tint count, cidaw, cplength, datasize;\n\tsector_t recid;\n\tunsigned char cmd, rcmd;\n\tint use_prefix;\n\tstruct dasd_device *basedev;\n\n\tbasedev = block->base;\n\tprivate = basedev->private;\n\tif (rq_data_dir(req) == READ)\n\t\tcmd = DASD_ECKD_CCW_READ_MT;\n\telse if (rq_data_dir(req) == WRITE)\n\t\tcmd = DASD_ECKD_CCW_WRITE_MT;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tcount = 0;\n\tcidaw = 0;\n\trq_for_each_segment(bv, req, iter) {\n\t\tif (bv.bv_len & (blksize - 1))\n\t\t\t \n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcount += bv.bv_len >> (block->s2b_shift + 9);\n\t\tif (idal_is_needed (page_address(bv.bv_page), bv.bv_len))\n\t\t\tcidaw += bv.bv_len >> (block->s2b_shift + 9);\n\t}\n\t \n\tif (count != last_rec - first_rec + 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tuse_prefix = private->features.feature[8] & 0x01;\n\tif (use_prefix) {\n\t\t \n\t\tcplength = 2 + count;\n\t\t \n\t\tdatasize = sizeof(struct PFX_eckd_data) +\n\t\t\tsizeof(struct LO_eckd_data) +\n\t\t\tcidaw * sizeof(unsigned long);\n\t} else {\n\t\t \n\t\tcplength = 2 + count;\n\t\t \n\t\tdatasize = sizeof(struct DE_eckd_data) +\n\t\t\tsizeof(struct LO_eckd_data) +\n\t\t\tcidaw * sizeof(unsigned long);\n\t}\n\t \n\tif (private->uses_cdl && first_rec < 2*blk_per_trk) {\n\t\tif (last_rec >= 2*blk_per_trk)\n\t\t\tcount = 2*blk_per_trk - first_rec;\n\t\tcplength += count;\n\t\tdatasize += count*sizeof(struct LO_eckd_data);\n\t}\n\t \n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize,\n\t\t\t\t   startdev, blk_mq_rq_to_pdu(req));\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\tccw = cqr->cpaddr;\n\t \n\tif (use_prefix) {\n\t\tif (prefix(ccw++, cqr->data, first_trk,\n\t\t\t   last_trk, cmd, basedev, startdev) == -EAGAIN) {\n\t\t\t \n\t\t\tdasd_sfree_request(cqr, startdev);\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n\t\tidaws = (unsigned long *) (cqr->data +\n\t\t\t\t\t   sizeof(struct PFX_eckd_data));\n\t} else {\n\t\tif (define_extent(ccw++, cqr->data, first_trk,\n\t\t\t\t  last_trk, cmd, basedev, 0) == -EAGAIN) {\n\t\t\t \n\t\t\tdasd_sfree_request(cqr, startdev);\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n\t\tidaws = (unsigned long *) (cqr->data +\n\t\t\t\t\t   sizeof(struct DE_eckd_data));\n\t}\n\t \n\tLO_data = (struct LO_eckd_data *) (idaws + cidaw);\n\trecid = first_rec;\n\tif (private->uses_cdl == 0 || recid > 2*blk_per_trk) {\n\t\t \n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tlocate_record(ccw++, LO_data++, first_trk, first_offs + 1,\n\t\t\t      last_rec - recid + 1, cmd, basedev, blksize);\n\t}\n\trq_for_each_segment(bv, req, iter) {\n\t\tdst = bvec_virt(&bv);\n\t\tif (dasd_page_cache) {\n\t\t\tchar *copy = kmem_cache_alloc(dasd_page_cache,\n\t\t\t\t\t\t      GFP_DMA | __GFP_NOWARN);\n\t\t\tif (copy && rq_data_dir(req) == WRITE)\n\t\t\t\tmemcpy(copy + bv.bv_offset, dst, bv.bv_len);\n\t\t\tif (copy)\n\t\t\t\tdst = copy + bv.bv_offset;\n\t\t}\n\t\tfor (off = 0; off < bv.bv_len; off += blksize) {\n\t\t\tsector_t trkid = recid;\n\t\t\tunsigned int recoffs = sector_div(trkid, blk_per_trk);\n\t\t\trcmd = cmd;\n\t\t\tcount = blksize;\n\t\t\t \n\t\t\tif (private->uses_cdl && recid < 2*blk_per_trk) {\n\t\t\t\tif (dasd_eckd_cdl_special(blk_per_trk, recid)){\n\t\t\t\t\trcmd |= 0x8;\n\t\t\t\t\tcount = dasd_eckd_cdl_reclen(recid);\n\t\t\t\t\tif (count < blksize &&\n\t\t\t\t\t    rq_data_dir(req) == READ)\n\t\t\t\t\t\tmemset(dst + count, 0xe5,\n\t\t\t\t\t\t       blksize - count);\n\t\t\t\t}\n\t\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\t\tlocate_record(ccw++, LO_data++,\n\t\t\t\t\t      trkid, recoffs + 1,\n\t\t\t\t\t      1, rcmd, basedev, count);\n\t\t\t}\n\t\t\t \n\t\t\tif (private->uses_cdl && recid == 2*blk_per_trk) {\n\t\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\t\tlocate_record(ccw++, LO_data++,\n\t\t\t\t\t      trkid, recoffs + 1,\n\t\t\t\t\t      last_rec - recid + 1,\n\t\t\t\t\t      cmd, basedev, count);\n\t\t\t}\n\t\t\t \n\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\tccw->cmd_code = rcmd;\n\t\t\tccw->count = count;\n\t\t\tif (idal_is_needed(dst, blksize)) {\n\t\t\t\tccw->cda = (__u32)virt_to_phys(idaws);\n\t\t\t\tccw->flags = CCW_FLAG_IDA;\n\t\t\t\tidaws = idal_create_words(idaws, dst, blksize);\n\t\t\t} else {\n\t\t\t\tccw->cda = (__u32)virt_to_phys(dst);\n\t\t\t\tccw->flags = 0;\n\t\t\t}\n\t\t\tccw++;\n\t\t\tdst += blksize;\n\t\t\trecid++;\n\t\t}\n\t}\n\tif (blk_noretry_request(req) ||\n\t    block->base->features & DASD_FEATURE_FAILFAST)\n\t\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->startdev = startdev;\n\tcqr->memdev = startdev;\n\tcqr->block = block;\n\tcqr->expires = startdev->default_expires * HZ;\t \n\tcqr->lpm = dasd_path_get_ppm(startdev);\n\tcqr->retries = startdev->default_retries;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\t \n\tif (dasd_eckd_is_ese(basedev)) {\n\t\tset_bit(DASD_CQR_SUPPRESS_FP, &cqr->flags);\n\t\tset_bit(DASD_CQR_SUPPRESS_IL, &cqr->flags);\n\t\tset_bit(DASD_CQR_SUPPRESS_NRF, &cqr->flags);\n\t}\n\n\treturn cqr;\n}\n\nstatic struct dasd_ccw_req *dasd_eckd_build_cp_cmd_track(\n\t\t\t\t\t       struct dasd_device *startdev,\n\t\t\t\t\t       struct dasd_block *block,\n\t\t\t\t\t       struct request *req,\n\t\t\t\t\t       sector_t first_rec,\n\t\t\t\t\t       sector_t last_rec,\n\t\t\t\t\t       sector_t first_trk,\n\t\t\t\t\t       sector_t last_trk,\n\t\t\t\t\t       unsigned int first_offs,\n\t\t\t\t\t       unsigned int last_offs,\n\t\t\t\t\t       unsigned int blk_per_trk,\n\t\t\t\t\t       unsigned int blksize)\n{\n\tunsigned long *idaws;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tstruct req_iterator iter;\n\tstruct bio_vec bv;\n\tchar *dst, *idaw_dst;\n\tunsigned int cidaw, cplength, datasize;\n\tunsigned int tlf;\n\tsector_t recid;\n\tunsigned char cmd;\n\tstruct dasd_device *basedev;\n\tunsigned int trkcount, count, count_to_trk_end;\n\tunsigned int idaw_len, seg_len, part_len, len_to_track_end;\n\tunsigned char new_track, end_idaw;\n\tsector_t trkid;\n\tunsigned int recoffs;\n\n\tbasedev = block->base;\n\tif (rq_data_dir(req) == READ)\n\t\tcmd = DASD_ECKD_CCW_READ_TRACK_DATA;\n\telse if (rq_data_dir(req) == WRITE)\n\t\tcmd = DASD_ECKD_CCW_WRITE_TRACK_DATA;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tcidaw = last_rec - first_rec + 1;\n\ttrkcount = last_trk - first_trk + 1;\n\n\t \n\tcplength = 1 + trkcount;\n\n\tdatasize = sizeof(struct PFX_eckd_data) + cidaw * sizeof(unsigned long);\n\n\t \n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize,\n\t\t\t\t   startdev, blk_mq_rq_to_pdu(req));\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\tccw = cqr->cpaddr;\n\t \n\tif (first_trk == last_trk)\n\t\ttlf = last_offs - first_offs + 1;\n\telse\n\t\ttlf = last_offs + 1;\n\ttlf *= blksize;\n\n\tif (prefix_LRE(ccw++, cqr->data, first_trk,\n\t\t       last_trk, cmd, basedev, startdev,\n\t\t       1  , first_offs + 1,\n\t\t       trkcount, blksize,\n\t\t       tlf) == -EAGAIN) {\n\t\t \n\t\tdasd_sfree_request(cqr, startdev);\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\n\t \n\tidaws = (unsigned long *) (cqr->data + sizeof(struct PFX_eckd_data));\n\trecid = first_rec;\n\tnew_track = 1;\n\tend_idaw = 0;\n\tlen_to_track_end = 0;\n\tidaw_dst = NULL;\n\tidaw_len = 0;\n\trq_for_each_segment(bv, req, iter) {\n\t\tdst = bvec_virt(&bv);\n\t\tseg_len = bv.bv_len;\n\t\twhile (seg_len) {\n\t\t\tif (new_track) {\n\t\t\t\ttrkid = recid;\n\t\t\t\trecoffs = sector_div(trkid, blk_per_trk);\n\t\t\t\tcount_to_trk_end = blk_per_trk - recoffs;\n\t\t\t\tcount = min((last_rec - recid + 1),\n\t\t\t\t\t    (sector_t)count_to_trk_end);\n\t\t\t\tlen_to_track_end = count * blksize;\n\t\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\t\tccw->cmd_code = cmd;\n\t\t\t\tccw->count = len_to_track_end;\n\t\t\t\tccw->cda = (__u32)virt_to_phys(idaws);\n\t\t\t\tccw->flags = CCW_FLAG_IDA;\n\t\t\t\tccw++;\n\t\t\t\trecid += count;\n\t\t\t\tnew_track = 0;\n\t\t\t\t \n\t\t\t\tif (!idaw_dst)\n\t\t\t\t\tidaw_dst = dst;\n\t\t\t}\n\t\t\t \n\t\t\tif (!idaw_dst) {\n\t\t\t\tif ((__u32)virt_to_phys(dst) & (IDA_BLOCK_SIZE - 1)) {\n\t\t\t\t\tdasd_sfree_request(cqr, startdev);\n\t\t\t\t\treturn ERR_PTR(-ERANGE);\n\t\t\t\t} else\n\t\t\t\t\tidaw_dst = dst;\n\t\t\t}\n\t\t\tif ((idaw_dst + idaw_len) != dst) {\n\t\t\t\tdasd_sfree_request(cqr, startdev);\n\t\t\t\treturn ERR_PTR(-ERANGE);\n\t\t\t}\n\t\t\tpart_len = min(seg_len, len_to_track_end);\n\t\t\tseg_len -= part_len;\n\t\t\tdst += part_len;\n\t\t\tidaw_len += part_len;\n\t\t\tlen_to_track_end -= part_len;\n\t\t\t \n\t\t\tif (!((__u32)virt_to_phys(idaw_dst + idaw_len) & (IDA_BLOCK_SIZE - 1)))\n\t\t\t\tend_idaw = 1;\n\t\t\t \n\t\t\tif (!len_to_track_end) {\n\t\t\t\tnew_track = 1;\n\t\t\t\tend_idaw = 1;\n\t\t\t}\n\t\t\tif (end_idaw) {\n\t\t\t\tidaws = idal_create_words(idaws, idaw_dst,\n\t\t\t\t\t\t\t  idaw_len);\n\t\t\t\tidaw_dst = NULL;\n\t\t\t\tidaw_len = 0;\n\t\t\t\tend_idaw = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (blk_noretry_request(req) ||\n\t    block->base->features & DASD_FEATURE_FAILFAST)\n\t\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->startdev = startdev;\n\tcqr->memdev = startdev;\n\tcqr->block = block;\n\tcqr->expires = startdev->default_expires * HZ;\t \n\tcqr->lpm = dasd_path_get_ppm(startdev);\n\tcqr->retries = startdev->default_retries;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\t \n\tif (dasd_eckd_is_ese(basedev))\n\t\tset_bit(DASD_CQR_SUPPRESS_NRF, &cqr->flags);\n\n\treturn cqr;\n}\n\nstatic int prepare_itcw(struct itcw *itcw,\n\t\t\tunsigned int trk, unsigned int totrk, int cmd,\n\t\t\tstruct dasd_device *basedev,\n\t\t\tstruct dasd_device *startdev,\n\t\t\tunsigned int rec_on_trk, int count,\n\t\t\tunsigned int blksize,\n\t\t\tunsigned int total_data_size,\n\t\t\tunsigned int tlf,\n\t\t\tunsigned int blk_per_trk)\n{\n\tstruct PFX_eckd_data pfxdata;\n\tstruct dasd_eckd_private *basepriv, *startpriv;\n\tstruct DE_eckd_data *dedata;\n\tstruct LRE_eckd_data *lredata;\n\tstruct dcw *dcw;\n\n\tu32 begcyl, endcyl;\n\tu16 heads, beghead, endhead;\n\tu8 pfx_cmd;\n\n\tint rc = 0;\n\tint sector = 0;\n\tint dn, d;\n\n\n\t \n\tbasepriv = basedev->private;\n\tstartpriv = startdev->private;\n\tdedata = &pfxdata.define_extent;\n\tlredata = &pfxdata.locate_record;\n\n\tmemset(&pfxdata, 0, sizeof(pfxdata));\n\tpfxdata.format = 1;  \n\tpfxdata.base_address = basepriv->conf.ned->unit_addr;\n\tpfxdata.base_lss = basepriv->conf.ned->ID;\n\tpfxdata.validity.define_extent = 1;\n\n\t \n\tif (startpriv->uid.type == UA_BASE_PAV_ALIAS)\n\t\tpfxdata.validity.verify_base = 1;\n\n\tif (startpriv->uid.type == UA_HYPER_PAV_ALIAS) {\n\t\tpfxdata.validity.verify_base = 1;\n\t\tpfxdata.validity.hyper_pav = 1;\n\t}\n\n\tswitch (cmd) {\n\tcase DASD_ECKD_CCW_READ_TRACK_DATA:\n\t\tdedata->mask.perm = 0x1;\n\t\tdedata->attributes.operation = basepriv->attrib.operation;\n\t\tdedata->blk_size = blksize;\n\t\tdedata->ga_extended |= 0x42;\n\t\tlredata->operation.orientation = 0x0;\n\t\tlredata->operation.operation = 0x0C;\n\t\tlredata->auxiliary.check_bytes = 0x01;\n\t\tpfx_cmd = DASD_ECKD_CCW_PFX_READ;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_WRITE_TRACK_DATA:\n\t\tdedata->mask.perm = 0x02;\n\t\tdedata->attributes.operation = basepriv->attrib.operation;\n\t\tdedata->blk_size = blksize;\n\t\trc = set_timestamp(NULL, dedata, basedev);\n\t\tdedata->ga_extended |= 0x42;\n\t\tlredata->operation.orientation = 0x0;\n\t\tlredata->operation.operation = 0x3F;\n\t\tlredata->extended_operation = 0x23;\n\t\tlredata->auxiliary.check_bytes = 0x2;\n\t\t \n\t\tif (dedata->ga_extended & 0x08 && dedata->ga_extended & 0x02)\n\t\t\tpfxdata.validity.time_stamp = 1;  \n\t\tpfx_cmd = DASD_ECKD_CCW_PFX;\n\t\tbreak;\n\tcase DASD_ECKD_CCW_READ_COUNT_MT:\n\t\tdedata->mask.perm = 0x1;\n\t\tdedata->attributes.operation = DASD_BYPASS_CACHE;\n\t\tdedata->ga_extended |= 0x42;\n\t\tdedata->blk_size = blksize;\n\t\tlredata->operation.orientation = 0x2;\n\t\tlredata->operation.operation = 0x16;\n\t\tlredata->auxiliary.check_bytes = 0x01;\n\t\tpfx_cmd = DASD_ECKD_CCW_PFX_READ;\n\t\tbreak;\n\tdefault:\n\t\tDBF_DEV_EVENT(DBF_ERR, basedev,\n\t\t\t      \"prepare itcw, unknown opcode 0x%x\", cmd);\n\t\tBUG();\n\t\tbreak;\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\tdedata->attributes.mode = 0x3;\t \n\n\theads = basepriv->rdc_data.trk_per_cyl;\n\tbegcyl = trk / heads;\n\tbeghead = trk % heads;\n\tendcyl = totrk / heads;\n\tendhead = totrk % heads;\n\n\t \n\tif (dedata->attributes.operation == DASD_SEQ_PRESTAGE ||\n\t    dedata->attributes.operation == DASD_SEQ_ACCESS) {\n\n\t\tif (endcyl + basepriv->attrib.nr_cyl < basepriv->real_cyl)\n\t\t\tendcyl += basepriv->attrib.nr_cyl;\n\t\telse\n\t\t\tendcyl = (basepriv->real_cyl - 1);\n\t}\n\n\tset_ch_t(&dedata->beg_ext, begcyl, beghead);\n\tset_ch_t(&dedata->end_ext, endcyl, endhead);\n\n\tdedata->ep_format = 0x20;  \n\tdedata->ep_rec_per_track = blk_per_trk;\n\n\tif (rec_on_trk) {\n\t\tswitch (basepriv->rdc_data.dev_type) {\n\t\tcase 0x3390:\n\t\t\tdn = ceil_quot(blksize + 6, 232);\n\t\t\td = 9 + ceil_quot(blksize + 6 * (dn + 1), 34);\n\t\t\tsector = (49 + (rec_on_trk - 1) * (10 + d)) / 8;\n\t\t\tbreak;\n\t\tcase 0x3380:\n\t\t\td = 7 + ceil_quot(blksize + 12, 32);\n\t\t\tsector = (39 + (rec_on_trk - 1) * (8 + d)) / 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cmd == DASD_ECKD_CCW_READ_COUNT_MT) {\n\t\tlredata->auxiliary.length_valid = 0;\n\t\tlredata->auxiliary.length_scope = 0;\n\t\tlredata->sector = 0xff;\n\t} else {\n\t\tlredata->auxiliary.length_valid = 1;\n\t\tlredata->auxiliary.length_scope = 1;\n\t\tlredata->sector = sector;\n\t}\n\tlredata->auxiliary.imbedded_ccw_valid = 1;\n\tlredata->length = tlf;\n\tlredata->imbedded_ccw = cmd;\n\tlredata->count = count;\n\tset_ch_t(&lredata->seek_addr, begcyl, beghead);\n\tlredata->search_arg.cyl = lredata->seek_addr.cyl;\n\tlredata->search_arg.head = lredata->seek_addr.head;\n\tlredata->search_arg.record = rec_on_trk;\n\n\tdcw = itcw_add_dcw(itcw, pfx_cmd, 0,\n\t\t     &pfxdata, sizeof(pfxdata), total_data_size);\n\treturn PTR_ERR_OR_ZERO(dcw);\n}\n\nstatic struct dasd_ccw_req *dasd_eckd_build_cp_tpm_track(\n\t\t\t\t\t       struct dasd_device *startdev,\n\t\t\t\t\t       struct dasd_block *block,\n\t\t\t\t\t       struct request *req,\n\t\t\t\t\t       sector_t first_rec,\n\t\t\t\t\t       sector_t last_rec,\n\t\t\t\t\t       sector_t first_trk,\n\t\t\t\t\t       sector_t last_trk,\n\t\t\t\t\t       unsigned int first_offs,\n\t\t\t\t\t       unsigned int last_offs,\n\t\t\t\t\t       unsigned int blk_per_trk,\n\t\t\t\t\t       unsigned int blksize)\n{\n\tstruct dasd_ccw_req *cqr;\n\tstruct req_iterator iter;\n\tstruct bio_vec bv;\n\tchar *dst;\n\tunsigned int trkcount, ctidaw;\n\tunsigned char cmd;\n\tstruct dasd_device *basedev;\n\tunsigned int tlf;\n\tstruct itcw *itcw;\n\tstruct tidaw *last_tidaw = NULL;\n\tint itcw_op;\n\tsize_t itcw_size;\n\tu8 tidaw_flags;\n\tunsigned int seg_len, part_len, len_to_track_end;\n\tunsigned char new_track;\n\tsector_t recid, trkid;\n\tunsigned int offs;\n\tunsigned int count, count_to_trk_end;\n\tint ret;\n\n\tbasedev = block->base;\n\tif (rq_data_dir(req) == READ) {\n\t\tcmd = DASD_ECKD_CCW_READ_TRACK_DATA;\n\t\titcw_op = ITCW_OP_READ;\n\t} else if (rq_data_dir(req) == WRITE) {\n\t\tcmd = DASD_ECKD_CCW_WRITE_TRACK_DATA;\n\t\titcw_op = ITCW_OP_WRITE;\n\t} else\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\ttrkcount = last_trk - first_trk + 1;\n\tctidaw = 0;\n\trq_for_each_segment(bv, req, iter) {\n\t\t++ctidaw;\n\t}\n\tif (rq_data_dir(req) == WRITE)\n\t\tctidaw += (last_trk - first_trk);\n\n\t \n\titcw_size = itcw_calc_size(0, ctidaw, 0);\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 0, itcw_size, startdev,\n\t\t\t\t   blk_mq_rq_to_pdu(req));\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\n\t \n\tif (first_trk == last_trk)\n\t\ttlf = last_offs - first_offs + 1;\n\telse\n\t\ttlf = last_offs + 1;\n\ttlf *= blksize;\n\n\titcw = itcw_init(cqr->data, itcw_size, itcw_op, 0, ctidaw, 0);\n\tif (IS_ERR(itcw)) {\n\t\tret = -EINVAL;\n\t\tgoto out_error;\n\t}\n\tcqr->cpaddr = itcw_get_tcw(itcw);\n\tif (prepare_itcw(itcw, first_trk, last_trk,\n\t\t\t cmd, basedev, startdev,\n\t\t\t first_offs + 1,\n\t\t\t trkcount, blksize,\n\t\t\t (last_rec - first_rec + 1) * blksize,\n\t\t\t tlf, blk_per_trk) == -EAGAIN) {\n\t\t \n\t\tret = -EAGAIN;\n\t\tgoto out_error;\n\t}\n\tlen_to_track_end = 0;\n\t \n\tif (rq_data_dir(req) == WRITE) {\n\t\tnew_track = 1;\n\t\trecid = first_rec;\n\t\trq_for_each_segment(bv, req, iter) {\n\t\t\tdst = bvec_virt(&bv);\n\t\t\tseg_len = bv.bv_len;\n\t\t\twhile (seg_len) {\n\t\t\t\tif (new_track) {\n\t\t\t\t\ttrkid = recid;\n\t\t\t\t\toffs = sector_div(trkid, blk_per_trk);\n\t\t\t\t\tcount_to_trk_end = blk_per_trk - offs;\n\t\t\t\t\tcount = min((last_rec - recid + 1),\n\t\t\t\t\t\t    (sector_t)count_to_trk_end);\n\t\t\t\t\tlen_to_track_end = count * blksize;\n\t\t\t\t\trecid += count;\n\t\t\t\t\tnew_track = 0;\n\t\t\t\t}\n\t\t\t\tpart_len = min(seg_len, len_to_track_end);\n\t\t\t\tseg_len -= part_len;\n\t\t\t\tlen_to_track_end -= part_len;\n\t\t\t\t \n\t\t\t\tif (!len_to_track_end) {\n\t\t\t\t\tnew_track = 1;\n\t\t\t\t\ttidaw_flags = TIDAW_FLAGS_INSERT_CBC;\n\t\t\t\t} else\n\t\t\t\t\ttidaw_flags = 0;\n\t\t\t\tlast_tidaw = itcw_add_tidaw(itcw, tidaw_flags,\n\t\t\t\t\t\t\t    dst, part_len);\n\t\t\t\tif (IS_ERR(last_tidaw)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tdst += part_len;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trq_for_each_segment(bv, req, iter) {\n\t\t\tdst = bvec_virt(&bv);\n\t\t\tlast_tidaw = itcw_add_tidaw(itcw, 0x00,\n\t\t\t\t\t\t    dst, bv.bv_len);\n\t\t\tif (IS_ERR(last_tidaw)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\tlast_tidaw->flags |= TIDAW_FLAGS_LAST;\n\tlast_tidaw->flags &= ~TIDAW_FLAGS_INSERT_CBC;\n\titcw_finalize(itcw);\n\n\tif (blk_noretry_request(req) ||\n\t    block->base->features & DASD_FEATURE_FAILFAST)\n\t\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->cpmode = 1;\n\tcqr->startdev = startdev;\n\tcqr->memdev = startdev;\n\tcqr->block = block;\n\tcqr->expires = startdev->default_expires * HZ;\t \n\tcqr->lpm = dasd_path_get_ppm(startdev);\n\tcqr->retries = startdev->default_retries;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\t \n\tif (dasd_eckd_is_ese(basedev)) {\n\t\tset_bit(DASD_CQR_SUPPRESS_FP, &cqr->flags);\n\t\tset_bit(DASD_CQR_SUPPRESS_IL, &cqr->flags);\n\t\tset_bit(DASD_CQR_SUPPRESS_NRF, &cqr->flags);\n\t}\n\n\treturn cqr;\nout_error:\n\tdasd_sfree_request(cqr, startdev);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct dasd_ccw_req *dasd_eckd_build_cp(struct dasd_device *startdev,\n\t\t\t\t\t       struct dasd_block *block,\n\t\t\t\t\t       struct request *req)\n{\n\tint cmdrtd, cmdwtd;\n\tint use_prefix;\n\tint fcx_multitrack;\n\tstruct dasd_eckd_private *private;\n\tstruct dasd_device *basedev;\n\tsector_t first_rec, last_rec;\n\tsector_t first_trk, last_trk;\n\tunsigned int first_offs, last_offs;\n\tunsigned int blk_per_trk, blksize;\n\tint cdlspecial;\n\tunsigned int data_size;\n\tstruct dasd_ccw_req *cqr;\n\n\tbasedev = block->base;\n\tprivate = basedev->private;\n\n\t \n\tblksize = block->bp_block;\n\tblk_per_trk = recs_per_track(&private->rdc_data, 0, blksize);\n\tif (blk_per_trk == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\t \n\tfirst_rec = first_trk = blk_rq_pos(req) >> block->s2b_shift;\n\tfirst_offs = sector_div(first_trk, blk_per_trk);\n\tlast_rec = last_trk =\n\t\t(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\n\tlast_offs = sector_div(last_trk, blk_per_trk);\n\tcdlspecial = (private->uses_cdl && first_rec < 2*blk_per_trk);\n\n\tfcx_multitrack = private->features.feature[40] & 0x20;\n\tdata_size = blk_rq_bytes(req);\n\tif (data_size % blksize)\n\t\treturn ERR_PTR(-EINVAL);\n\t \n\tif (rq_data_dir(req) == WRITE)\n\t\tdata_size += (last_trk - first_trk) * 4;\n\n\t \n\tcmdrtd = private->features.feature[9] & 0x20;\n\tcmdwtd = private->features.feature[12] & 0x40;\n\tuse_prefix = private->features.feature[8] & 0x01;\n\n\tcqr = NULL;\n\tif (cdlspecial || dasd_page_cache) {\n\t\t \n\t} else if ((data_size <= private->fcx_max_data)\n\t\t   && (fcx_multitrack || (first_trk == last_trk))) {\n\t\tcqr = dasd_eckd_build_cp_tpm_track(startdev, block, req,\n\t\t\t\t\t\t    first_rec, last_rec,\n\t\t\t\t\t\t    first_trk, last_trk,\n\t\t\t\t\t\t    first_offs, last_offs,\n\t\t\t\t\t\t    blk_per_trk, blksize);\n\t\tif (IS_ERR(cqr) && (PTR_ERR(cqr) != -EAGAIN) &&\n\t\t    (PTR_ERR(cqr) != -ENOMEM))\n\t\t\tcqr = NULL;\n\t} else if (use_prefix &&\n\t\t   (((rq_data_dir(req) == READ) && cmdrtd) ||\n\t\t    ((rq_data_dir(req) == WRITE) && cmdwtd))) {\n\t\tcqr = dasd_eckd_build_cp_cmd_track(startdev, block, req,\n\t\t\t\t\t\t   first_rec, last_rec,\n\t\t\t\t\t\t   first_trk, last_trk,\n\t\t\t\t\t\t   first_offs, last_offs,\n\t\t\t\t\t\t   blk_per_trk, blksize);\n\t\tif (IS_ERR(cqr) && (PTR_ERR(cqr) != -EAGAIN) &&\n\t\t    (PTR_ERR(cqr) != -ENOMEM))\n\t\t\tcqr = NULL;\n\t}\n\tif (!cqr)\n\t\tcqr = dasd_eckd_build_cp_cmd_single(startdev, block, req,\n\t\t\t\t\t\t    first_rec, last_rec,\n\t\t\t\t\t\t    first_trk, last_trk,\n\t\t\t\t\t\t    first_offs, last_offs,\n\t\t\t\t\t\t    blk_per_trk, blksize);\n\treturn cqr;\n}\n\nstatic struct dasd_ccw_req *dasd_eckd_build_cp_raw(struct dasd_device *startdev,\n\t\t\t\t\t\t   struct dasd_block *block,\n\t\t\t\t\t\t   struct request *req)\n{\n\tsector_t start_padding_sectors, end_sector_offset, end_padding_sectors;\n\tunsigned int seg_len, len_to_track_end;\n\tunsigned int cidaw, cplength, datasize;\n\tsector_t first_trk, last_trk, sectors;\n\tstruct dasd_eckd_private *base_priv;\n\tstruct dasd_device *basedev;\n\tstruct req_iterator iter;\n\tstruct dasd_ccw_req *cqr;\n\tunsigned int trkcount;\n\tunsigned long *idaws;\n\tunsigned int size;\n\tunsigned char cmd;\n\tstruct bio_vec bv;\n\tstruct ccw1 *ccw;\n\tint use_prefix;\n\tvoid *data;\n\tchar *dst;\n\n\t \n\tstart_padding_sectors = blk_rq_pos(req) % DASD_RAW_SECTORS_PER_TRACK;\n\tend_sector_offset = (blk_rq_pos(req) + blk_rq_sectors(req)) %\n\t\tDASD_RAW_SECTORS_PER_TRACK;\n\tend_padding_sectors = (DASD_RAW_SECTORS_PER_TRACK - end_sector_offset) %\n\t\tDASD_RAW_SECTORS_PER_TRACK;\n\tbasedev = block->base;\n\tif ((start_padding_sectors || end_padding_sectors) &&\n\t    (rq_data_dir(req) == WRITE)) {\n\t\tDBF_DEV_EVENT(DBF_ERR, basedev,\n\t\t\t      \"raw write not track aligned (%llu,%llu) req %p\",\n\t\t\t      start_padding_sectors, end_padding_sectors, req);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfirst_trk = blk_rq_pos(req) / DASD_RAW_SECTORS_PER_TRACK;\n\tlast_trk = (blk_rq_pos(req) + blk_rq_sectors(req) - 1) /\n\t\tDASD_RAW_SECTORS_PER_TRACK;\n\ttrkcount = last_trk - first_trk + 1;\n\n\tif (rq_data_dir(req) == READ)\n\t\tcmd = DASD_ECKD_CCW_READ_TRACK;\n\telse if (rq_data_dir(req) == WRITE)\n\t\tcmd = DASD_ECKD_CCW_WRITE_FULL_TRACK;\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tcidaw = trkcount * DASD_RAW_BLOCK_PER_TRACK;\n\n\t \n\tbase_priv = basedev->private;\n\tuse_prefix = base_priv->features.feature[8] & 0x01;\n\tif (use_prefix) {\n\t\tcplength = 1 + trkcount;\n\t\tsize = sizeof(struct PFX_eckd_data) + 2;\n\t} else {\n\t\tcplength = 2 + trkcount;\n\t\tsize = sizeof(struct DE_eckd_data) +\n\t\t\tsizeof(struct LRE_eckd_data) + 2;\n\t}\n\tsize = ALIGN(size, 8);\n\n\tdatasize = size + cidaw * sizeof(unsigned long);\n\n\t \n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength,\n\t\t\t\t   datasize, startdev, blk_mq_rq_to_pdu(req));\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\n\tccw = cqr->cpaddr;\n\tdata = cqr->data;\n\n\tif (use_prefix) {\n\t\tprefix_LRE(ccw++, data, first_trk, last_trk, cmd, basedev,\n\t\t\t   startdev, 1, 0, trkcount, 0, 0);\n\t} else {\n\t\tdefine_extent(ccw++, data, first_trk, last_trk, cmd, basedev, 0);\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\n\t\tdata += sizeof(struct DE_eckd_data);\n\t\tlocate_record_ext(ccw++, data, first_trk, 0,\n\t\t\t\t  trkcount, cmd, basedev, 0, 0);\n\t}\n\n\tidaws = (unsigned long *)(cqr->data + size);\n\tlen_to_track_end = 0;\n\tif (start_padding_sectors) {\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tccw->cmd_code = cmd;\n\t\t \n\t\tccw->count = 57326;\n\t\t \n\t\tlen_to_track_end = 65536 - start_padding_sectors * 512;\n\t\tccw->cda = (__u32)virt_to_phys(idaws);\n\t\tccw->flags |= CCW_FLAG_IDA;\n\t\tccw->flags |= CCW_FLAG_SLI;\n\t\tccw++;\n\t\tfor (sectors = 0; sectors < start_padding_sectors; sectors += 8)\n\t\t\tidaws = idal_create_words(idaws, rawpadpage, PAGE_SIZE);\n\t}\n\trq_for_each_segment(bv, req, iter) {\n\t\tdst = bvec_virt(&bv);\n\t\tseg_len = bv.bv_len;\n\t\tif (cmd == DASD_ECKD_CCW_READ_TRACK)\n\t\t\tmemset(dst, 0, seg_len);\n\t\tif (!len_to_track_end) {\n\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\tccw->cmd_code = cmd;\n\t\t\t \n\t\t\tccw->count = 57326;\n\t\t\t \n\t\t\tlen_to_track_end = 65536;\n\t\t\tccw->cda = (__u32)virt_to_phys(idaws);\n\t\t\tccw->flags |= CCW_FLAG_IDA;\n\t\t\tccw->flags |= CCW_FLAG_SLI;\n\t\t\tccw++;\n\t\t}\n\t\tlen_to_track_end -= seg_len;\n\t\tidaws = idal_create_words(idaws, dst, seg_len);\n\t}\n\tfor (sectors = 0; sectors < end_padding_sectors; sectors += 8)\n\t\tidaws = idal_create_words(idaws, rawpadpage, PAGE_SIZE);\n\tif (blk_noretry_request(req) ||\n\t    block->base->features & DASD_FEATURE_FAILFAST)\n\t\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->startdev = startdev;\n\tcqr->memdev = startdev;\n\tcqr->block = block;\n\tcqr->expires = startdev->default_expires * HZ;\n\tcqr->lpm = dasd_path_get_ppm(startdev);\n\tcqr->retries = startdev->default_retries;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\treturn cqr;\n}\n\n\nstatic int\ndasd_eckd_free_cp(struct dasd_ccw_req *cqr, struct request *req)\n{\n\tstruct dasd_eckd_private *private;\n\tstruct ccw1 *ccw;\n\tstruct req_iterator iter;\n\tstruct bio_vec bv;\n\tchar *dst, *cda;\n\tunsigned int blksize, blk_per_trk, off;\n\tsector_t recid;\n\tint status;\n\n\tif (!dasd_page_cache)\n\t\tgoto out;\n\tprivate = cqr->block->base->private;\n\tblksize = cqr->block->bp_block;\n\tblk_per_trk = recs_per_track(&private->rdc_data, 0, blksize);\n\trecid = blk_rq_pos(req) >> cqr->block->s2b_shift;\n\tccw = cqr->cpaddr;\n\t \n\tccw++;\n\tif (private->uses_cdl == 0 || recid > 2*blk_per_trk)\n\t\tccw++;\n\trq_for_each_segment(bv, req, iter) {\n\t\tdst = bvec_virt(&bv);\n\t\tfor (off = 0; off < bv.bv_len; off += blksize) {\n\t\t\t \n\t\t\tif (private->uses_cdl && recid <= 2*blk_per_trk)\n\t\t\t\tccw++;\n\t\t\tif (dst) {\n\t\t\t\tif (ccw->flags & CCW_FLAG_IDA)\n\t\t\t\t\tcda = *((char **)phys_to_virt(ccw->cda));\n\t\t\t\telse\n\t\t\t\t\tcda = phys_to_virt(ccw->cda);\n\t\t\t\tif (dst != cda) {\n\t\t\t\t\tif (rq_data_dir(req) == READ)\n\t\t\t\t\t\tmemcpy(dst, cda, bv.bv_len);\n\t\t\t\t\tkmem_cache_free(dasd_page_cache,\n\t\t\t\t\t    (void *)((addr_t)cda & PAGE_MASK));\n\t\t\t\t}\n\t\t\t\tdst = NULL;\n\t\t\t}\n\t\t\tccw++;\n\t\t\trecid++;\n\t\t}\n\t}\nout:\n\tstatus = cqr->status == DASD_CQR_DONE;\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn status;\n}\n\n \nvoid dasd_eckd_reset_ccw_to_base_io(struct dasd_ccw_req *cqr)\n{\n\tstruct ccw1 *ccw;\n\tstruct PFX_eckd_data *pfxdata;\n\tstruct tcw *tcw;\n\tstruct tccb *tccb;\n\tstruct dcw *dcw;\n\n\tif (cqr->cpmode == 1) {\n\t\ttcw = cqr->cpaddr;\n\t\ttccb = tcw_get_tccb(tcw);\n\t\tdcw = (struct dcw *)&tccb->tca[0];\n\t\tpfxdata = (struct PFX_eckd_data *)&dcw->cd[0];\n\t\tpfxdata->validity.verify_base = 0;\n\t\tpfxdata->validity.hyper_pav = 0;\n\t} else {\n\t\tccw = cqr->cpaddr;\n\t\tpfxdata = cqr->data;\n\t\tif (ccw->cmd_code == DASD_ECKD_CCW_PFX) {\n\t\t\tpfxdata->validity.verify_base = 0;\n\t\t\tpfxdata->validity.hyper_pav = 0;\n\t\t}\n\t}\n}\n\n#define DASD_ECKD_CHANQ_MAX_SIZE 4\n\nstatic struct dasd_ccw_req *dasd_eckd_build_alias_cp(struct dasd_device *base,\n\t\t\t\t\t\t     struct dasd_block *block,\n\t\t\t\t\t\t     struct request *req)\n{\n\tstruct dasd_eckd_private *private;\n\tstruct dasd_device *startdev;\n\tunsigned long flags;\n\tstruct dasd_ccw_req *cqr;\n\n\tstartdev = dasd_alias_get_start_dev(base);\n\tif (!startdev)\n\t\tstartdev = base;\n\tprivate = startdev->private;\n\tif (private->count >= DASD_ECKD_CHANQ_MAX_SIZE)\n\t\treturn ERR_PTR(-EBUSY);\n\n\tspin_lock_irqsave(get_ccwdev_lock(startdev->cdev), flags);\n\tprivate->count++;\n\tif ((base->features & DASD_FEATURE_USERAW))\n\t\tcqr = dasd_eckd_build_cp_raw(startdev, block, req);\n\telse\n\t\tcqr = dasd_eckd_build_cp(startdev, block, req);\n\tif (IS_ERR(cqr))\n\t\tprivate->count--;\n\tspin_unlock_irqrestore(get_ccwdev_lock(startdev->cdev), flags);\n\treturn cqr;\n}\n\nstatic int dasd_eckd_free_alias_cp(struct dasd_ccw_req *cqr,\n\t\t\t\t   struct request *req)\n{\n\tstruct dasd_eckd_private *private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(get_ccwdev_lock(cqr->memdev->cdev), flags);\n\tprivate = cqr->memdev->private;\n\tprivate->count--;\n\tspin_unlock_irqrestore(get_ccwdev_lock(cqr->memdev->cdev), flags);\n\treturn dasd_eckd_free_cp(cqr, req);\n}\n\nstatic int\ndasd_eckd_fill_info(struct dasd_device * device,\n\t\t    struct dasd_information2_t * info)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\tinfo->label_block = 2;\n\tinfo->FBA_layout = private->uses_cdl ? 0 : 1;\n\tinfo->format = private->uses_cdl ? DASD_FORMAT_CDL : DASD_FORMAT_LDL;\n\tinfo->characteristics_size = sizeof(private->rdc_data);\n\tmemcpy(info->characteristics, &private->rdc_data,\n\t       sizeof(private->rdc_data));\n\tinfo->confdata_size = min_t(unsigned long, private->conf.len,\n\t\t\t\t    sizeof(info->configuration_data));\n\tmemcpy(info->configuration_data, private->conf.data,\n\t       info->confdata_size);\n\treturn 0;\n}\n\n \n\n \nstatic int\ndasd_eckd_release(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc;\n\tstruct ccw1 *ccw;\n\tint useglobal;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tuseglobal = 0;\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tmutex_lock(&dasd_reserve_mutex);\n\t\tuseglobal = 1;\n\t\tcqr = &dasd_reserve_req->cqr;\n\t\tmemset(cqr, 0, sizeof(*cqr));\n\t\tmemset(&dasd_reserve_req->ccw, 0,\n\t\t       sizeof(dasd_reserve_req->ccw));\n\t\tcqr->cpaddr = &dasd_reserve_req->ccw;\n\t\tcqr->data = &dasd_reserve_req->data;\n\t\tcqr->magic = DASD_ECKD_MAGIC;\n\t}\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_RELEASE;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->count = 32;\n\tccw->cda = (__u32)virt_to_phys(cqr->data);\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->retries = 2;\t \n\tcqr->expires = 2 * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\trc = dasd_sleep_on_immediatly(cqr);\n\tif (!rc)\n\t\tclear_bit(DASD_FLAG_IS_RESERVED, &device->flags);\n\n\tif (useglobal)\n\t\tmutex_unlock(&dasd_reserve_mutex);\n\telse\n\t\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic int\ndasd_eckd_reserve(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc;\n\tstruct ccw1 *ccw;\n\tint useglobal;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tuseglobal = 0;\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tmutex_lock(&dasd_reserve_mutex);\n\t\tuseglobal = 1;\n\t\tcqr = &dasd_reserve_req->cqr;\n\t\tmemset(cqr, 0, sizeof(*cqr));\n\t\tmemset(&dasd_reserve_req->ccw, 0,\n\t\t       sizeof(dasd_reserve_req->ccw));\n\t\tcqr->cpaddr = &dasd_reserve_req->ccw;\n\t\tcqr->data = &dasd_reserve_req->data;\n\t\tcqr->magic = DASD_ECKD_MAGIC;\n\t}\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_RESERVE;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->count = 32;\n\tccw->cda = (__u32)virt_to_phys(cqr->data);\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->retries = 2;\t \n\tcqr->expires = 2 * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\trc = dasd_sleep_on_immediatly(cqr);\n\tif (!rc)\n\t\tset_bit(DASD_FLAG_IS_RESERVED, &device->flags);\n\n\tif (useglobal)\n\t\tmutex_unlock(&dasd_reserve_mutex);\n\telse\n\t\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic int\ndasd_eckd_steal_lock(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc;\n\tstruct ccw1 *ccw;\n\tint useglobal;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tuseglobal = 0;\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tmutex_lock(&dasd_reserve_mutex);\n\t\tuseglobal = 1;\n\t\tcqr = &dasd_reserve_req->cqr;\n\t\tmemset(cqr, 0, sizeof(*cqr));\n\t\tmemset(&dasd_reserve_req->ccw, 0,\n\t\t       sizeof(dasd_reserve_req->ccw));\n\t\tcqr->cpaddr = &dasd_reserve_req->ccw;\n\t\tcqr->data = &dasd_reserve_req->data;\n\t\tcqr->magic = DASD_ECKD_MAGIC;\n\t}\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_SLCK;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->count = 32;\n\tccw->cda = (__u32)virt_to_phys(cqr->data);\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->retries = 2;\t \n\tcqr->expires = 2 * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\trc = dasd_sleep_on_immediatly(cqr);\n\tif (!rc)\n\t\tset_bit(DASD_FLAG_IS_RESERVED, &device->flags);\n\n\tif (useglobal)\n\t\tmutex_unlock(&dasd_reserve_mutex);\n\telse\n\t\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic int dasd_eckd_snid(struct dasd_device *device,\n\t\t\t  void __user *argp)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc;\n\tstruct ccw1 *ccw;\n\tint useglobal;\n\tstruct dasd_snid_ioctl_data usrparm;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (copy_from_user(&usrparm, argp, sizeof(usrparm)))\n\t\treturn -EFAULT;\n\n\tuseglobal = 0;\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1,\n\t\t\t\t   sizeof(struct dasd_snid_data), device,\n\t\t\t\t   NULL);\n\tif (IS_ERR(cqr)) {\n\t\tmutex_lock(&dasd_reserve_mutex);\n\t\tuseglobal = 1;\n\t\tcqr = &dasd_reserve_req->cqr;\n\t\tmemset(cqr, 0, sizeof(*cqr));\n\t\tmemset(&dasd_reserve_req->ccw, 0,\n\t\t       sizeof(dasd_reserve_req->ccw));\n\t\tcqr->cpaddr = &dasd_reserve_req->ccw;\n\t\tcqr->data = &dasd_reserve_req->data;\n\t\tcqr->magic = DASD_ECKD_MAGIC;\n\t}\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_SNID;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->count = 12;\n\tccw->cda = (__u32)virt_to_phys(cqr->data);\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tset_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags);\n\tcqr->retries = 5;\n\tcqr->expires = 10 * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\tcqr->lpm = usrparm.path_mask;\n\n\trc = dasd_sleep_on_immediatly(cqr);\n\t \n\tif (!rc && usrparm.path_mask && (cqr->lpm != usrparm.path_mask))\n\t\trc = -EIO;\n\tif (!rc) {\n\t\tusrparm.data = *((struct dasd_snid_data *)cqr->data);\n\t\tif (copy_to_user(argp, &usrparm, sizeof(usrparm)))\n\t\t\trc = -EFAULT;\n\t}\n\n\tif (useglobal)\n\t\tmutex_unlock(&dasd_reserve_mutex);\n\telse\n\t\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic int\ndasd_eckd_performance(struct dasd_device *device, void __user *argp)\n{\n\tstruct dasd_psf_prssd_data *prssdp;\n\tstruct dasd_rssd_perf_stats_t *stats;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1    + 1  ,\n\t\t\t\t   (sizeof(struct dasd_psf_prssd_data) +\n\t\t\t\t    sizeof(struct dasd_rssd_perf_stats_t)),\n\t\t\t\t   device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Could not allocate initialization request\");\n\t\treturn PTR_ERR(cqr);\n\t}\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->retries = 0;\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tcqr->expires = 10 * HZ;\n\n\t \n\tprssdp = (struct dasd_psf_prssd_data *) cqr->data;\n\tmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\n\tprssdp->order = PSF_ORDER_PRSSD;\n\tprssdp->suborder = 0x01;\t \n\tprssdp->varies[1] = 0x01;\t \n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = sizeof(struct dasd_psf_prssd_data);\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->cda = (__u32)virt_to_phys(prssdp);\n\n\t \n\tstats = (struct dasd_rssd_perf_stats_t *) (prssdp + 1);\n\tmemset(stats, 0, sizeof(struct dasd_rssd_perf_stats_t));\n\n\tccw++;\n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = sizeof(struct dasd_rssd_perf_stats_t);\n\tccw->cda = (__u32)virt_to_phys(stats);\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\trc = dasd_sleep_on(cqr);\n\tif (rc == 0) {\n\t\tprssdp = (struct dasd_psf_prssd_data *) cqr->data;\n\t\tstats = (struct dasd_rssd_perf_stats_t *) (prssdp + 1);\n\t\tif (copy_to_user(argp, stats,\n\t\t\t\t sizeof(struct dasd_rssd_perf_stats_t)))\n\t\t\trc = -EFAULT;\n\t}\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic int\ndasd_eckd_get_attrib(struct dasd_device *device, void __user *argp)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct attrib_data_t attrib = private->attrib;\n\tint rc;\n\n        if (!capable(CAP_SYS_ADMIN))\n                return -EACCES;\n\tif (!argp)\n                return -EINVAL;\n\n\trc = 0;\n\tif (copy_to_user(argp, (long *) &attrib,\n\t\t\t sizeof(struct attrib_data_t)))\n\t\trc = -EFAULT;\n\n\treturn rc;\n}\n\n \nstatic int\ndasd_eckd_set_attrib(struct dasd_device *device, void __user *argp)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct attrib_data_t attrib;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&attrib, argp, sizeof(struct attrib_data_t)))\n\t\treturn -EFAULT;\n\tprivate->attrib = attrib;\n\n\tdev_info(&device->cdev->dev,\n\t\t \"The DASD cache mode was set to %x (%i cylinder prestage)\\n\",\n\t\t private->attrib.operation, private->attrib.nr_cyl);\n\treturn 0;\n}\n\n \nstatic int dasd_symm_io(struct dasd_device *device, void __user *argp)\n{\n\tstruct dasd_symmio_parms usrparm;\n\tchar *psf_data, *rssd_result;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tchar psf0, psf1;\n\tint rc;\n\n\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RAWIO))\n\t\treturn -EACCES;\n\tpsf0 = psf1 = 0;\n\n\t \n\trc = -EFAULT;\n\tif (copy_from_user(&usrparm, argp, sizeof(usrparm)))\n\t\tgoto out;\n\tif (is_compat_task()) {\n\t\t \n\t\trc = -EINVAL;\n\t\tif ((usrparm.psf_data >> 32) != 0)\n\t\t\tgoto out;\n\t\tif ((usrparm.rssd_result >> 32) != 0)\n\t\t\tgoto out;\n\t\tusrparm.psf_data &= 0x7fffffffULL;\n\t\tusrparm.rssd_result &= 0x7fffffffULL;\n\t}\n\t \n\tif (usrparm.psf_data_len < 2) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t\t      \"Symmetrix ioctl invalid data length %d\",\n\t\t\t      usrparm.psf_data_len);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tpsf_data = kzalloc(usrparm.psf_data_len, GFP_KERNEL | GFP_DMA);\n\trssd_result = kzalloc(usrparm.rssd_result_len, GFP_KERNEL | GFP_DMA);\n\tif (!psf_data || !rssd_result) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t \n\trc = -EFAULT;\n\tif (copy_from_user(psf_data,\n\t\t\t   (void __user *)(unsigned long) usrparm.psf_data,\n\t\t\t   usrparm.psf_data_len))\n\t\tgoto out_free;\n\tpsf0 = psf_data[0];\n\tpsf1 = psf_data[1];\n\n\t \n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 2, 0, device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t\"Could not allocate initialization request\");\n\t\trc = PTR_ERR(cqr);\n\t\tgoto out_free;\n\t}\n\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->retries = 3;\n\tcqr->expires = 10 * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\t \n\tccw = cqr->cpaddr;\n\n\t \n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = usrparm.psf_data_len;\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->cda = (__u32)virt_to_phys(psf_data);\n\n\tccw++;\n\n\t \n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = usrparm.rssd_result_len;\n\tccw->flags = CCW_FLAG_SLI ;\n\tccw->cda = (__u32)virt_to_phys(rssd_result);\n\n\trc = dasd_sleep_on(cqr);\n\tif (rc)\n\t\tgoto out_sfree;\n\n\trc = -EFAULT;\n\tif (copy_to_user((void __user *)(unsigned long) usrparm.rssd_result,\n\t\t\t   rssd_result, usrparm.rssd_result_len))\n\t\tgoto out_sfree;\n\trc = 0;\n\nout_sfree:\n\tdasd_sfree_request(cqr, cqr->memdev);\nout_free:\n\tkfree(rssd_result);\n\tkfree(psf_data);\nout:\n\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t      \"Symmetrix ioctl (0x%02x 0x%02x): rc=%d\",\n\t\t      (int) psf0, (int) psf1, rc);\n\treturn rc;\n}\n\nstatic int\ndasd_eckd_ioctl(struct dasd_block *block, unsigned int cmd, void __user *argp)\n{\n\tstruct dasd_device *device = block->base;\n\n\tswitch (cmd) {\n\tcase BIODASDGATTR:\n\t\treturn dasd_eckd_get_attrib(device, argp);\n\tcase BIODASDSATTR:\n\t\treturn dasd_eckd_set_attrib(device, argp);\n\tcase BIODASDPSRD:\n\t\treturn dasd_eckd_performance(device, argp);\n\tcase BIODASDRLSE:\n\t\treturn dasd_eckd_release(device);\n\tcase BIODASDRSRV:\n\t\treturn dasd_eckd_reserve(device);\n\tcase BIODASDSLCK:\n\t\treturn dasd_eckd_steal_lock(device);\n\tcase BIODASDSNID:\n\t\treturn dasd_eckd_snid(device, argp);\n\tcase BIODASDSYMMIO:\n\t\treturn dasd_symm_io(device, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \nstatic void\ndasd_eckd_dump_ccw_range(struct ccw1 *from, struct ccw1 *to, char *page)\n{\n\tint len, count;\n\tchar *datap;\n\n\tlen = 0;\n\twhile (from <= to) {\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" CCW %p: %08X %08X DAT:\",\n\t\t\t       from, ((int *) from)[0], ((int *) from)[1]);\n\n\t\t \n\t\tif (from->flags & CCW_FLAG_IDA)\n\t\t\tdatap = (char *)*((addr_t *)phys_to_virt(from->cda));\n\t\telse\n\t\t\tdatap = phys_to_virt(from->cda);\n\n\t\t \n\t\tfor (count = 0; count < from->count && count < 128; count++) {\n\t\t\tif (count % 32 == 0)\n\t\t\t\tlen += sprintf(page + len, \"\\n\");\n\t\t\tif (count % 8 == 0)\n\t\t\t\tlen += sprintf(page + len, \" \");\n\t\t\tif (count % 4 == 0)\n\t\t\t\tlen += sprintf(page + len, \" \");\n\t\t\tlen += sprintf(page + len, \"%02x\", datap[count]);\n\t\t}\n\t\tlen += sprintf(page + len, \"\\n\");\n\t\tfrom++;\n\t}\n\tif (len > 0)\n\t\tprintk(KERN_ERR \"%s\", page);\n}\n\nstatic void\ndasd_eckd_dump_sense_dbf(struct dasd_device *device, struct irb *irb,\n\t\t\t char *reason)\n{\n\tu64 *sense;\n\tu64 *stat;\n\n\tsense = (u64 *) dasd_get_sense(irb);\n\tstat = (u64 *) &irb->scsw;\n\tif (sense) {\n\t\tDBF_DEV_EVENT(DBF_EMERG, device, \"%s: %016llx %08x : \"\n\t\t\t      \"%016llx %016llx %016llx %016llx\",\n\t\t\t      reason, *stat, *((u32 *) (stat + 1)),\n\t\t\t      sense[0], sense[1], sense[2], sense[3]);\n\t} else {\n\t\tDBF_DEV_EVENT(DBF_EMERG, device, \"%s: %016llx %08x : %s\",\n\t\t\t      reason, *stat, *((u32 *) (stat + 1)),\n\t\t\t      \"NO VALID SENSE\");\n\t}\n}\n\n \nstatic void dasd_eckd_dump_sense_ccw(struct dasd_device *device,\n\t\t\t\t struct dasd_ccw_req *req, struct irb *irb)\n{\n\tchar *page;\n\tstruct ccw1 *first, *last, *fail, *from, *to;\n\tint len, sl, sct;\n\n\tpage = (char *) get_zeroed_page(GFP_ATOMIC);\n\tif (page == NULL) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"No memory to dump sense data\\n\");\n\t\treturn;\n\t}\n\t \n\tlen = sprintf(page, PRINTK_HEADER\n\t\t      \" I/O status report for device %s:\\n\",\n\t\t      dev_name(&device->cdev->dev));\n\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t       \" in req: %p CC:%02X FC:%02X AC:%02X SC:%02X DS:%02X \"\n\t\t       \"CS:%02X RC:%d\\n\",\n\t\t       req, scsw_cc(&irb->scsw), scsw_fctl(&irb->scsw),\n\t\t       scsw_actl(&irb->scsw), scsw_stctl(&irb->scsw),\n\t\t       scsw_dstat(&irb->scsw), scsw_cstat(&irb->scsw),\n\t\t       req ? req->intrc : 0);\n\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t       \" device %s: Failing CCW: %p\\n\",\n\t\t       dev_name(&device->cdev->dev),\n\t\t       phys_to_virt(irb->scsw.cmd.cpa));\n\tif (irb->esw.esw0.erw.cons) {\n\t\tfor (sl = 0; sl < 4; sl++) {\n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t\t       \" Sense(hex) %2d-%2d:\",\n\t\t\t\t       (8 * sl), ((8 * sl) + 7));\n\n\t\t\tfor (sct = 0; sct < 8; sct++) {\n\t\t\t\tlen += sprintf(page + len, \" %02x\",\n\t\t\t\t\t       irb->ecw[8 * sl + sct]);\n\t\t\t}\n\t\t\tlen += sprintf(page + len, \"\\n\");\n\t\t}\n\n\t\tif (irb->ecw[27] & DASD_SENSE_BIT_0) {\n\t\t\t \n\t\t\tsprintf(page + len, PRINTK_HEADER\n\t\t\t\t\" 24 Byte: %x MSG %x, \"\n\t\t\t\t\"%s MSGb to SYSOP\\n\",\n\t\t\t\tirb->ecw[7] >> 4, irb->ecw[7] & 0x0f,\n\t\t\t\tirb->ecw[1] & 0x10 ? \"\" : \"no\");\n\t\t} else {\n\t\t\t \n\t\t\tsprintf(page + len, PRINTK_HEADER\n\t\t\t\t\" 32 Byte: Format: %x \"\n\t\t\t\t\"Exception class %x\\n\",\n\t\t\t\tirb->ecw[6] & 0x0f, irb->ecw[22] >> 4);\n\t\t}\n\t} else {\n\t\tsprintf(page + len, PRINTK_HEADER\n\t\t\t\" SORRY - NO VALID SENSE AVAILABLE\\n\");\n\t}\n\tprintk(KERN_ERR \"%s\", page);\n\n\tif (req) {\n\t\t \n\t\t \n\t\t \n\t\tfirst = req->cpaddr;\n\t\tfor (last = first; last->flags & (CCW_FLAG_CC | CCW_FLAG_DC); last++);\n\t\tto = min(first + 6, last);\n\t\tprintk(KERN_ERR PRINTK_HEADER \" Related CP in req: %p\\n\", req);\n\t\tdasd_eckd_dump_ccw_range(first, to, page);\n\n\t\t \n\t\t \n\t\tfrom = ++to;\n\t\tfail = phys_to_virt(irb->scsw.cmd.cpa);  \n\t\tif (from <  fail - 2) {\n\t\t\tfrom = fail - 2;      \n\t\t\tprintk(KERN_ERR PRINTK_HEADER \"......\\n\");\n\t\t}\n\t\tto = min(fail + 1, last);\n\t\tdasd_eckd_dump_ccw_range(from, to, page + len);\n\n\t\t \n\t\tlen = 0;\n\t\tfrom = max(from, ++to);\n\t\tif (from < last - 1) {\n\t\t\tfrom = last - 1;      \n\t\t\tprintk(KERN_ERR PRINTK_HEADER \"......\\n\");\n\t\t}\n\t\tdasd_eckd_dump_ccw_range(from, last, page + len);\n\t}\n\tfree_page((unsigned long) page);\n}\n\n\n \nstatic void dasd_eckd_dump_sense_tcw(struct dasd_device *device,\n\t\t\t\t struct dasd_ccw_req *req, struct irb *irb)\n{\n\tchar *page;\n\tint len, sl, sct, residual;\n\tstruct tsb *tsb;\n\tu8 *sense, *rcq;\n\n\tpage = (char *) get_zeroed_page(GFP_ATOMIC);\n\tif (page == NULL) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \" %s\",\n\t\t\t    \"No memory to dump sense data\");\n\t\treturn;\n\t}\n\t \n\tlen = sprintf(page, PRINTK_HEADER\n\t\t      \" I/O status report for device %s:\\n\",\n\t\t      dev_name(&device->cdev->dev));\n\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t       \" in req: %p CC:%02X FC:%02X AC:%02X SC:%02X DS:%02X \"\n\t\t       \"CS:%02X fcxs:%02X schxs:%02X RC:%d\\n\",\n\t\t       req, scsw_cc(&irb->scsw), scsw_fctl(&irb->scsw),\n\t\t       scsw_actl(&irb->scsw), scsw_stctl(&irb->scsw),\n\t\t       scsw_dstat(&irb->scsw), scsw_cstat(&irb->scsw),\n\t\t       irb->scsw.tm.fcxs,\n\t\t       (irb->scsw.tm.ifob << 7) | irb->scsw.tm.sesq,\n\t\t       req ? req->intrc : 0);\n\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t       \" device %s: Failing TCW: %p\\n\",\n\t\t       dev_name(&device->cdev->dev),\n\t\t       phys_to_virt(irb->scsw.tm.tcw));\n\n\ttsb = NULL;\n\tsense = NULL;\n\tif (irb->scsw.tm.tcw && (irb->scsw.tm.fcxs & 0x01))\n\t\ttsb = tcw_get_tsb(phys_to_virt(irb->scsw.tm.tcw));\n\n\tif (tsb) {\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->length %d\\n\", tsb->length);\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->flags %x\\n\", tsb->flags);\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->dcw_offset %d\\n\", tsb->dcw_offset);\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->count %d\\n\", tsb->count);\n\t\tresidual = tsb->count - 28;\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" residual %d\\n\", residual);\n\n\t\tswitch (tsb->flags & 0x07) {\n\t\tcase 1:\t \n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->tsa.iostat.dev_time %d\\n\",\n\t\t\t\t       tsb->tsa.iostat.dev_time);\n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->tsa.iostat.def_time %d\\n\",\n\t\t\t\t       tsb->tsa.iostat.def_time);\n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->tsa.iostat.queue_time %d\\n\",\n\t\t\t\t       tsb->tsa.iostat.queue_time);\n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->tsa.iostat.dev_busy_time %d\\n\",\n\t\t\t\t       tsb->tsa.iostat.dev_busy_time);\n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->tsa.iostat.dev_act_time %d\\n\",\n\t\t\t\t       tsb->tsa.iostat.dev_act_time);\n\t\t\tsense = tsb->tsa.iostat.sense;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" tsb->tsa.ddpc.rc %d\\n\", tsb->tsa.ddpc.rc);\n\t\t\tfor (sl = 0; sl < 2; sl++) {\n\t\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t\t\t       \" tsb->tsa.ddpc.rcq %2d-%2d: \",\n\t\t\t\t\t       (8 * sl), ((8 * sl) + 7));\n\t\t\t\trcq = tsb->tsa.ddpc.rcq;\n\t\t\t\tfor (sct = 0; sct < 8; sct++) {\n\t\t\t\t\tlen += sprintf(page + len, \" %02x\",\n\t\t\t\t\t\t       rcq[8 * sl + sct]);\n\t\t\t\t}\n\t\t\t\tlen += sprintf(page + len, \"\\n\");\n\t\t\t}\n\t\t\tsense = tsb->tsa.ddpc.sense;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t\t      \" tsb->tsa.intrg.: not supported yet\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sense) {\n\t\t\tfor (sl = 0; sl < 4; sl++) {\n\t\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t\t\t       \" Sense(hex) %2d-%2d:\",\n\t\t\t\t\t       (8 * sl), ((8 * sl) + 7));\n\t\t\t\tfor (sct = 0; sct < 8; sct++) {\n\t\t\t\t\tlen += sprintf(page + len, \" %02x\",\n\t\t\t\t\t\t       sense[8 * sl + sct]);\n\t\t\t\t}\n\t\t\t\tlen += sprintf(page + len, \"\\n\");\n\t\t\t}\n\n\t\t\tif (sense[27] & DASD_SENSE_BIT_0) {\n\t\t\t\t \n\t\t\t\tsprintf(page + len, PRINTK_HEADER\n\t\t\t\t\t\" 24 Byte: %x MSG %x, \"\n\t\t\t\t\t\"%s MSGb to SYSOP\\n\",\n\t\t\t\t\tsense[7] >> 4, sense[7] & 0x0f,\n\t\t\t\t\tsense[1] & 0x10 ? \"\" : \"no\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsprintf(page + len, PRINTK_HEADER\n\t\t\t\t\t\" 32 Byte: Format: %x \"\n\t\t\t\t\t\"Exception class %x\\n\",\n\t\t\t\t\tsense[6] & 0x0f, sense[22] >> 4);\n\t\t\t}\n\t\t} else {\n\t\t\tsprintf(page + len, PRINTK_HEADER\n\t\t\t\t\" SORRY - NO VALID SENSE AVAILABLE\\n\");\n\t\t}\n\t} else {\n\t\tsprintf(page + len, PRINTK_HEADER\n\t\t\t\" SORRY - NO TSB DATA AVAILABLE\\n\");\n\t}\n\tprintk(KERN_ERR \"%s\", page);\n\tfree_page((unsigned long) page);\n}\n\nstatic void dasd_eckd_dump_sense(struct dasd_device *device,\n\t\t\t\t struct dasd_ccw_req *req, struct irb *irb)\n{\n\tu8 *sense = dasd_get_sense(irb);\n\n\tif (scsw_is_tm(&irb->scsw)) {\n\t\t \n\t\tif (sense && (sense[1] & SNS1_FILE_PROTECTED) &&\n\t\t    test_bit(DASD_CQR_SUPPRESS_FP, &req->flags))\n\t\t\treturn;\n\t\tif (scsw_cstat(&irb->scsw) == 0x40 &&\n\t\t    test_bit(DASD_CQR_SUPPRESS_IL, &req->flags))\n\t\t\treturn;\n\n\t\tdasd_eckd_dump_sense_tcw(device, req, irb);\n\t} else {\n\t\t \n\t\tif (sense && sense[0] & SNS0_CMD_REJECT &&\n\t\t    test_bit(DASD_CQR_SUPPRESS_CR, &req->flags))\n\t\t\treturn;\n\n\t\tif (sense && sense[1] & SNS1_NO_REC_FOUND &&\n\t\t    test_bit(DASD_CQR_SUPPRESS_NRF, &req->flags))\n\t\t\treturn;\n\n\t\tdasd_eckd_dump_sense_ccw(device, req, irb);\n\t}\n}\n\nstatic int dasd_eckd_reload_device(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tchar print_uid[DASD_UID_STRLEN];\n\tint rc, old_base;\n\tstruct dasd_uid uid;\n\tunsigned long flags;\n\n\t \n\tdasd_alias_remove_device(device);\n\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\told_base = private->uid.base_unit_addr;\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\n\t \n\trc = dasd_eckd_read_conf(device);\n\tif (rc)\n\t\tgoto out_err;\n\n\tdasd_eckd_read_fc_security(device);\n\n\trc = dasd_eckd_generate_uid(device);\n\tif (rc)\n\t\tgoto out_err;\n\t \n\tdasd_alias_update_add_device(device);\n\n\tdasd_eckd_get_uid(device, &uid);\n\n\tif (old_base != uid.base_unit_addr) {\n\t\tdasd_eckd_get_uid_string(&private->conf, print_uid);\n\t\tdev_info(&device->cdev->dev,\n\t\t\t \"An Alias device was reassigned to a new base device \"\n\t\t\t \"with UID: %s\\n\", print_uid);\n\t}\n\treturn 0;\n\nout_err:\n\treturn -1;\n}\n\nstatic int dasd_eckd_read_message_buffer(struct dasd_device *device,\n\t\t\t\t\t struct dasd_rssd_messages *messages,\n\t\t\t\t\t __u8 lpum)\n{\n\tstruct dasd_rssd_messages *message_buf;\n\tstruct dasd_psf_prssd_data *prssdp;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1  \t+ 1  ,\n\t\t\t\t   (sizeof(struct dasd_psf_prssd_data) +\n\t\t\t\t    sizeof(struct dasd_rssd_messages)),\n\t\t\t\t   device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate read message buffer request\");\n\t\treturn PTR_ERR(cqr);\n\t}\n\n\tcqr->lpm = lpum;\nretry:\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->expires = 10 * HZ;\n\tset_bit(DASD_CQR_VERIFY_PATH, &cqr->flags);\n\t \n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tcqr->retries = 256;\n\n\t \n\tprssdp = (struct dasd_psf_prssd_data *) cqr->data;\n\tmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\n\tprssdp->order = PSF_ORDER_PRSSD;\n\tprssdp->suborder = 0x03;\t \n\t \n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = sizeof(struct dasd_psf_prssd_data);\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->cda = (__u32)virt_to_phys(prssdp);\n\n\t \n\tmessage_buf = (struct dasd_rssd_messages *) (prssdp + 1);\n\tmemset(message_buf, 0, sizeof(struct dasd_rssd_messages));\n\n\tccw++;\n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = sizeof(struct dasd_rssd_messages);\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->cda = (__u32)virt_to_phys(message_buf);\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\trc = dasd_sleep_on_immediatly(cqr);\n\tif (rc == 0) {\n\t\tprssdp = (struct dasd_psf_prssd_data *) cqr->data;\n\t\tmessage_buf = (struct dasd_rssd_messages *)\n\t\t\t(prssdp + 1);\n\t\tmemcpy(messages, message_buf,\n\t\t       sizeof(struct dasd_rssd_messages));\n\t} else if (cqr->lpm) {\n\t\t \n\t\tcqr->lpm = 0;\n\t\tgoto retry;\n\t} else\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\"Reading messages failed with rc=%d\\n\"\n\t\t\t\t, rc);\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\nstatic int dasd_eckd_query_host_access(struct dasd_device *device,\n\t\t\t\t       struct dasd_psf_query_host_access *data)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct dasd_psf_query_host_access *host_access;\n\tstruct dasd_psf_prssd_data *prssdp;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\t \n\tif (!device->block && private->lcu->pav == HYPER_PAV)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!(private->features.feature[14] & 0x80))\n\t\treturn -EOPNOTSUPP;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1  \t+ 1  ,\n\t\t\t\t   sizeof(struct dasd_psf_prssd_data) + 1,\n\t\t\t\t   device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate read message buffer request\");\n\t\treturn PTR_ERR(cqr);\n\t}\n\thost_access = kzalloc(sizeof(*host_access), GFP_KERNEL | GFP_DMA);\n\tif (!host_access) {\n\t\tdasd_sfree_request(cqr, device);\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate host_access buffer\");\n\t\treturn -ENOMEM;\n\t}\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->retries = 256;\n\tcqr->expires = 10 * HZ;\n\n\t \n\tprssdp = (struct dasd_psf_prssd_data *) cqr->data;\n\tmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\n\tprssdp->order = PSF_ORDER_PRSSD;\n\tprssdp->suborder = PSF_SUBORDER_QHA;\t \n\t \n\tprssdp->lss = private->conf.ned->ID;\n\tprssdp->volume = private->conf.ned->unit_addr;\n\t \n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = sizeof(struct dasd_psf_prssd_data);\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->cda = (__u32)virt_to_phys(prssdp);\n\n\t \n\tccw++;\n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = sizeof(struct dasd_psf_query_host_access);\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->cda = (__u32)virt_to_phys(host_access);\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\t \n\t__set_bit(DASD_CQR_SUPPRESS_CR, &cqr->flags);\n\trc = dasd_sleep_on_interruptible(cqr);\n\tif (rc == 0) {\n\t\t*data = *host_access;\n\t} else {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\"Reading host access data failed with rc=%d\\n\",\n\t\t\t\trc);\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tdasd_sfree_request(cqr, cqr->memdev);\n\tkfree(host_access);\n\treturn rc;\n}\n \nstatic int dasd_eckd_host_access_count(struct dasd_device *device)\n{\n\tstruct dasd_psf_query_host_access *access;\n\tstruct dasd_ckd_path_group_entry *entry;\n\tstruct dasd_ckd_host_information *info;\n\tint count = 0;\n\tint rc, i;\n\n\taccess = kzalloc(sizeof(*access), GFP_NOIO);\n\tif (!access) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate access buffer\");\n\t\treturn -ENOMEM;\n\t}\n\trc = dasd_eckd_query_host_access(device, access);\n\tif (rc) {\n\t\tkfree(access);\n\t\treturn rc;\n\t}\n\n\tinfo = (struct dasd_ckd_host_information *)\n\t\taccess->host_access_information;\n\tfor (i = 0; i < info->entry_count; i++) {\n\t\tentry = (struct dasd_ckd_path_group_entry *)\n\t\t\t(info->entry + i * info->entry_size);\n\t\tif (entry->status_flags & DASD_ECKD_PG_GROUPED)\n\t\t\tcount++;\n\t}\n\n\tkfree(access);\n\treturn count;\n}\n\n \nstatic int dasd_hosts_print(struct dasd_device *device, struct seq_file *m)\n{\n\tstruct dasd_psf_query_host_access *access;\n\tstruct dasd_ckd_path_group_entry *entry;\n\tstruct dasd_ckd_host_information *info;\n\tchar sysplex[9] = \"\";\n\tint rc, i;\n\n\taccess = kzalloc(sizeof(*access), GFP_NOIO);\n\tif (!access) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate access buffer\");\n\t\treturn -ENOMEM;\n\t}\n\trc = dasd_eckd_query_host_access(device, access);\n\tif (rc) {\n\t\tkfree(access);\n\t\treturn rc;\n\t}\n\n\tinfo = (struct dasd_ckd_host_information *)\n\t\taccess->host_access_information;\n\tfor (i = 0; i < info->entry_count; i++) {\n\t\tentry = (struct dasd_ckd_path_group_entry *)\n\t\t\t(info->entry + i * info->entry_size);\n\t\t \n\t\tseq_printf(m, \"pgid %*phN\\n\", 11, entry->pgid);\n\t\t \n\t\tseq_printf(m, \"status_flags %02x\\n\", entry->status_flags);\n\t\t \n\t\tmemcpy(&sysplex, &entry->sysplex_name, sizeof(sysplex) - 1);\n\t\tEBCASC(sysplex, sizeof(sysplex));\n\t\tseq_printf(m, \"sysplex_name %8s\\n\", sysplex);\n\t\t \n\t\tseq_printf(m, \"supported_cylinder %d\\n\", entry->cylinder);\n\t\t \n\t\tseq_printf(m, \"timestamp %lu\\n\", (unsigned long)\n\t\t\t   entry->timestamp);\n\t}\n\tkfree(access);\n\n\treturn 0;\n}\n\nstatic struct dasd_device\n*copy_relation_find_device(struct dasd_copy_relation *copy,\n\t\t\t   char *busid)\n{\n\tint i;\n\n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (copy->entry[i].configured &&\n\t\t    strncmp(copy->entry[i].busid, busid, DASD_BUS_ID_SIZE) == 0)\n\t\t\treturn copy->entry[i].device;\n\t}\n\treturn NULL;\n}\n\n \nstatic void copy_pair_set_active(struct dasd_copy_relation *copy, char *new_busid,\n\t\t\t\t char *old_busid)\n{\n\tint i;\n\n\tfor (i = 0; i < DASD_CP_ENTRIES; i++) {\n\t\tif (copy->entry[i].configured &&\n\t\t    strncmp(copy->entry[i].busid, new_busid,\n\t\t\t    DASD_BUS_ID_SIZE) == 0) {\n\t\t\tcopy->active = &copy->entry[i];\n\t\t\tcopy->entry[i].primary = true;\n\t\t} else if (copy->entry[i].configured &&\n\t\t\t   strncmp(copy->entry[i].busid, old_busid,\n\t\t\t\t   DASD_BUS_ID_SIZE) == 0) {\n\t\t\tcopy->entry[i].primary = false;\n\t\t}\n\t}\n}\n\n \nstatic int dasd_eckd_copy_pair_swap(struct dasd_device *device, char *prim_busid,\n\t\t\t\t    char *sec_busid)\n{\n\tstruct dasd_device *primary, *secondary;\n\tstruct dasd_copy_relation *copy;\n\tstruct dasd_block *block;\n\tstruct gendisk *gdp;\n\n\tcopy = device->copy;\n\tif (!copy)\n\t\treturn DASD_COPYPAIRSWAP_INVALID;\n\tprimary = copy->active->device;\n\tif (!primary)\n\t\treturn DASD_COPYPAIRSWAP_INVALID;\n\t \n\tif (strncmp(dev_name(&primary->cdev->dev), prim_busid, DASD_BUS_ID_SIZE) != 0)\n\t\treturn DASD_COPYPAIRSWAP_PRIMARY;\n\n\tsecondary = copy_relation_find_device(copy, sec_busid);\n\tif (!secondary)\n\t\treturn DASD_COPYPAIRSWAP_SECONDARY;\n\n\t \n\tdasd_device_set_stop_bits(primary, DASD_STOPPED_PPRC);\n\tdasd_device_set_stop_bits(secondary, DASD_STOPPED_PPRC);\n\tdasd_generic_requeue_all_requests(primary);\n\n\t \n\tblock = primary->block;\n\tprimary->block = NULL;\n\tsecondary->block = block;\n\tblock->base = secondary;\n\t \n\tcopy_pair_set_active(copy, sec_busid, prim_busid);\n\n\t \n\tgdp = block->gdp;\n\tdasd_add_link_to_gendisk(gdp, secondary);\n\n\t \n\tdasd_device_remove_stop_bits(primary, DASD_STOPPED_PPRC);\n\tdasd_device_remove_stop_bits(secondary, DASD_STOPPED_PPRC);\n\tdasd_schedule_device_bh(secondary);\n\n\treturn DASD_COPYPAIRSWAP_SUCCESS;\n}\n\n \nstatic int dasd_eckd_query_pprc_status(struct dasd_device *device,\n\t\t\t\t       struct dasd_pprc_data_sc4 *data)\n{\n\tstruct dasd_pprc_data_sc4 *pprc_data;\n\tstruct dasd_psf_prssd_data *prssdp;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1  \t+ 1  ,\n\t\t\t\t   sizeof(*prssdp) + sizeof(*pprc_data) + 1,\n\t\t\t\t   device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate query PPRC status request\");\n\t\treturn PTR_ERR(cqr);\n\t}\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->retries = 256;\n\tcqr->expires = 10 * HZ;\n\n\t \n\tprssdp = (struct dasd_psf_prssd_data *)cqr->data;\n\tmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\n\tprssdp->order = PSF_ORDER_PRSSD;\n\tprssdp->suborder = PSF_SUBORDER_PPRCEQ;\n\tprssdp->varies[0] = PPRCEQ_SCOPE_4;\n\tpprc_data = (struct dasd_pprc_data_sc4 *)(prssdp + 1);\n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = sizeof(struct dasd_psf_prssd_data);\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->cda = (__u32)(addr_t)prssdp;\n\n\t \n\tccw++;\n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = sizeof(*pprc_data);\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->cda = (__u32)(addr_t)pprc_data;\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\trc = dasd_sleep_on_interruptible(cqr);\n\tif (rc == 0) {\n\t\t*data = *pprc_data;\n\t} else {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\"PPRC Extended Query failed with rc=%d\\n\",\n\t\t\t\trc);\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic int dasd_eckd_nop(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 1, device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev, \"%s\",\n\t\t\t\t\"Could not allocate NOP request\");\n\t\treturn PTR_ERR(cqr);\n\t}\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->retries = 1;\n\tcqr->expires = 10 * HZ;\n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_NOP;\n\tccw->flags |= CCW_FLAG_SLI;\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\trc = dasd_sleep_on_interruptible(cqr);\n\tif (rc != 0) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\n\t\t\t\t\"NOP failed with rc=%d\\n\", rc);\n\t\trc = -EOPNOTSUPP;\n\t}\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\nstatic int dasd_eckd_device_ping(struct dasd_device *device)\n{\n\treturn dasd_eckd_nop(device);\n}\n\n \nstatic int\ndasd_eckd_psf_cuir_response(struct dasd_device *device, int response,\n\t\t\t    __u32 message_id, __u8 lpum)\n{\n\tstruct dasd_psf_cuir_response *psf_cuir;\n\tint pos = pathmask_to_pos(lpum);\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1   ,\n\t\t\t\t   sizeof(struct dasd_psf_cuir_response),\n\t\t\t\t   device, NULL);\n\n\tif (IS_ERR(cqr)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t   \"Could not allocate PSF-CUIR request\");\n\t\treturn PTR_ERR(cqr);\n\t}\n\n\tpsf_cuir = (struct dasd_psf_cuir_response *)cqr->data;\n\tpsf_cuir->order = PSF_ORDER_CUIR_RESPONSE;\n\tpsf_cuir->cc = response;\n\tpsf_cuir->chpid = device->path[pos].chpid;\n\tpsf_cuir->message_id = message_id;\n\tpsf_cuir->cssid = device->path[pos].cssid;\n\tpsf_cuir->ssid = device->path[pos].ssid;\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->cda = (__u32)virt_to_phys(psf_cuir);\n\tccw->flags = CCW_FLAG_SLI;\n\tccw->count = sizeof(struct dasd_psf_cuir_response);\n\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->retries = 256;\n\tcqr->expires = 10*HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\tset_bit(DASD_CQR_VERIFY_PATH, &cqr->flags);\n\n\trc = dasd_sleep_on(cqr);\n\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\n \nstatic struct dasd_conf_data *dasd_eckd_get_ref_conf(struct dasd_device *device,\n\t\t\t\t\t\t     __u8 lpum,\n\t\t\t\t\t\t     struct dasd_cuir_message *cuir)\n{\n\tstruct dasd_conf_data *conf_data;\n\tint path, pos;\n\n\tif (cuir->record_selector == 0)\n\t\tgoto out;\n\tfor (path = 0x80, pos = 0; path; path >>= 1, pos++) {\n\t\tconf_data = device->path[pos].conf_data;\n\t\tif (conf_data->gneq.record_selector ==\n\t\t    cuir->record_selector)\n\t\t\treturn conf_data;\n\t}\nout:\n\treturn device->path[pathmask_to_pos(lpum)].conf_data;\n}\n\n \nstatic int dasd_eckd_cuir_scope(struct dasd_device *device, __u8 lpum,\n\t\t\t\tstruct dasd_cuir_message *cuir)\n{\n\tstruct dasd_conf_data *ref_conf_data;\n\tunsigned long bitmask = 0, mask = 0;\n\tstruct dasd_conf_data *conf_data;\n\tunsigned int pos, path;\n\tchar *ref_gneq, *gneq;\n\tchar *ref_ned, *ned;\n\tint tbcpm = 0;\n\n\t \n\tif (!cuir->ned_map ||\n\t    !(cuir->neq_map[0] | cuir->neq_map[1] | cuir->neq_map[2]))\n\t\treturn lpum;\n\n\t \n\tref_conf_data = dasd_eckd_get_ref_conf(device, lpum, cuir);\n\t \n\tpos = 8 - ffs(cuir->ned_map);\n\tref_ned = (char *)&ref_conf_data->neds[pos];\n\tref_gneq = (char *)&ref_conf_data->gneq;\n\t \n\tmask = cuir->neq_map[2];\n\tmask |= cuir->neq_map[1] << 8;\n\tmask |= cuir->neq_map[0] << 16;\n\n\tfor (path = 0; path < 8; path++) {\n\t\t \n\t\tbitmask = mask;\n\t\tconf_data = device->path[path].conf_data;\n\t\tpos = 8 - ffs(cuir->ned_map);\n\t\tned = (char *) &conf_data->neds[pos];\n\t\t \n\t\tif (memcmp(ref_ned, ned, sizeof(*ned)) != 0)\n\t\t\tcontinue;\n\t\tgneq = (char *)&conf_data->gneq;\n\t\t \n\t\twhile (bitmask) {\n\t\t\tpos = ffs(bitmask) - 1;\n\t\t\tif (memcmp(&ref_gneq[31 - pos], &gneq[31 - pos], 1)\n\t\t\t    != 0)\n\t\t\t\tbreak;\n\t\t\tclear_bit(pos, &bitmask);\n\t\t}\n\t\tif (bitmask)\n\t\t\tcontinue;\n\t\t \n\t\ttbcpm |= 0x80 >> path;\n\t}\n\treturn tbcpm;\n}\n\nstatic void dasd_eckd_cuir_notify_user(struct dasd_device *device,\n\t\t\t\t       unsigned long paths, int action)\n{\n\tint pos;\n\n\twhile (paths) {\n\t\t \n\t\tpos = 8 - ffs(paths);\n\t\t \n\t\tif (action == CUIR_QUIESCE)\n\t\t\tpr_warn(\"Service on the storage server caused path %x.%02x to go offline\",\n\t\t\t\tdevice->path[pos].cssid,\n\t\t\t\tdevice->path[pos].chpid);\n\t\telse if (action == CUIR_RESUME)\n\t\t\tpr_info(\"Path %x.%02x is back online after service on the storage server\",\n\t\t\t\tdevice->path[pos].cssid,\n\t\t\t\tdevice->path[pos].chpid);\n\t\tclear_bit(7 - pos, &paths);\n\t}\n}\n\nstatic int dasd_eckd_cuir_remove_path(struct dasd_device *device, __u8 lpum,\n\t\t\t\t      struct dasd_cuir_message *cuir)\n{\n\tunsigned long tbcpm;\n\n\ttbcpm = dasd_eckd_cuir_scope(device, lpum, cuir);\n\t \n\tif (!(dasd_path_get_opm(device) & tbcpm))\n\t\treturn 0;\n\tif (!(dasd_path_get_opm(device) & ~tbcpm)) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\t \n\tdasd_path_remove_opm(device, tbcpm);\n\tdasd_path_add_cuirpm(device, tbcpm);\n\treturn tbcpm;\n}\n\n \nstatic int dasd_eckd_cuir_quiesce(struct dasd_device *device, __u8 lpum,\n\t\t\t\t  struct dasd_cuir_message *cuir)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct alias_pav_group *pavgroup, *tempgroup;\n\tstruct dasd_device *dev, *n;\n\tunsigned long paths = 0;\n\tunsigned long flags;\n\tint tbcpm;\n\n\t \n\tlist_for_each_entry_safe(dev, n, &private->lcu->active_devices,\n\t\t\t\t alias_list) {\n\t\tspin_lock_irqsave(get_ccwdev_lock(dev->cdev), flags);\n\t\ttbcpm = dasd_eckd_cuir_remove_path(dev, lpum, cuir);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(dev->cdev), flags);\n\t\tif (tbcpm < 0)\n\t\t\tgoto out_err;\n\t\tpaths |= tbcpm;\n\t}\n\t \n\tlist_for_each_entry_safe(dev, n, &private->lcu->inactive_devices,\n\t\t\t\t alias_list) {\n\t\tspin_lock_irqsave(get_ccwdev_lock(dev->cdev), flags);\n\t\ttbcpm = dasd_eckd_cuir_remove_path(dev, lpum, cuir);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(dev->cdev), flags);\n\t\tif (tbcpm < 0)\n\t\t\tgoto out_err;\n\t\tpaths |= tbcpm;\n\t}\n\t \n\tlist_for_each_entry_safe(pavgroup, tempgroup,\n\t\t\t\t &private->lcu->grouplist, group) {\n\t\tlist_for_each_entry_safe(dev, n, &pavgroup->baselist,\n\t\t\t\t\t alias_list) {\n\t\t\tspin_lock_irqsave(get_ccwdev_lock(dev->cdev), flags);\n\t\t\ttbcpm = dasd_eckd_cuir_remove_path(dev, lpum, cuir);\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\tget_ccwdev_lock(dev->cdev), flags);\n\t\t\tif (tbcpm < 0)\n\t\t\t\tgoto out_err;\n\t\t\tpaths |= tbcpm;\n\t\t}\n\t\tlist_for_each_entry_safe(dev, n, &pavgroup->aliaslist,\n\t\t\t\t\t alias_list) {\n\t\t\tspin_lock_irqsave(get_ccwdev_lock(dev->cdev), flags);\n\t\t\ttbcpm = dasd_eckd_cuir_remove_path(dev, lpum, cuir);\n\t\t\tspin_unlock_irqrestore(\n\t\t\t\tget_ccwdev_lock(dev->cdev), flags);\n\t\t\tif (tbcpm < 0)\n\t\t\t\tgoto out_err;\n\t\t\tpaths |= tbcpm;\n\t\t}\n\t}\n\t \n\tdasd_eckd_cuir_notify_user(device, paths, CUIR_QUIESCE);\n\treturn 0;\nout_err:\n\treturn tbcpm;\n}\n\nstatic int dasd_eckd_cuir_resume(struct dasd_device *device, __u8 lpum,\n\t\t\t\t struct dasd_cuir_message *cuir)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct alias_pav_group *pavgroup, *tempgroup;\n\tstruct dasd_device *dev, *n;\n\tunsigned long paths = 0;\n\tint tbcpm;\n\n\t \n\tlist_for_each_entry_safe(dev, n,\n\t\t\t\t &private->lcu->active_devices,\n\t\t\t\t alias_list) {\n\t\ttbcpm = dasd_eckd_cuir_scope(dev, lpum, cuir);\n\t\tpaths |= tbcpm;\n\t\tif (!(dasd_path_get_opm(dev) & tbcpm)) {\n\t\t\tdasd_path_add_tbvpm(dev, tbcpm);\n\t\t\tdasd_schedule_device_bh(dev);\n\t\t}\n\t}\n\tlist_for_each_entry_safe(dev, n,\n\t\t\t\t &private->lcu->inactive_devices,\n\t\t\t\t alias_list) {\n\t\ttbcpm = dasd_eckd_cuir_scope(dev, lpum, cuir);\n\t\tpaths |= tbcpm;\n\t\tif (!(dasd_path_get_opm(dev) & tbcpm)) {\n\t\t\tdasd_path_add_tbvpm(dev, tbcpm);\n\t\t\tdasd_schedule_device_bh(dev);\n\t\t}\n\t}\n\t \n\tlist_for_each_entry_safe(pavgroup, tempgroup,\n\t\t\t\t &private->lcu->grouplist,\n\t\t\t\t group) {\n\t\tlist_for_each_entry_safe(dev, n,\n\t\t\t\t\t &pavgroup->baselist,\n\t\t\t\t\t alias_list) {\n\t\t\ttbcpm = dasd_eckd_cuir_scope(dev, lpum, cuir);\n\t\t\tpaths |= tbcpm;\n\t\t\tif (!(dasd_path_get_opm(dev) & tbcpm)) {\n\t\t\t\tdasd_path_add_tbvpm(dev, tbcpm);\n\t\t\t\tdasd_schedule_device_bh(dev);\n\t\t\t}\n\t\t}\n\t\tlist_for_each_entry_safe(dev, n,\n\t\t\t\t\t &pavgroup->aliaslist,\n\t\t\t\t\t alias_list) {\n\t\t\ttbcpm = dasd_eckd_cuir_scope(dev, lpum, cuir);\n\t\t\tpaths |= tbcpm;\n\t\t\tif (!(dasd_path_get_opm(dev) & tbcpm)) {\n\t\t\t\tdasd_path_add_tbvpm(dev, tbcpm);\n\t\t\t\tdasd_schedule_device_bh(dev);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tdasd_eckd_cuir_notify_user(device, paths, CUIR_RESUME);\n\treturn 0;\n}\n\nstatic void dasd_eckd_handle_cuir(struct dasd_device *device, void *messages,\n\t\t\t\t __u8 lpum)\n{\n\tstruct dasd_cuir_message *cuir = messages;\n\tint response;\n\n\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t      \"CUIR request: %016llx %016llx %016llx %08x\",\n\t\t      ((u64 *)cuir)[0], ((u64 *)cuir)[1], ((u64 *)cuir)[2],\n\t\t      ((u32 *)cuir)[3]);\n\n\tif (cuir->code == CUIR_QUIESCE) {\n\t\t \n\t\tif (dasd_eckd_cuir_quiesce(device, lpum, cuir))\n\t\t\tresponse = PSF_CUIR_LAST_PATH;\n\t\telse\n\t\t\tresponse = PSF_CUIR_COMPLETED;\n\t} else if (cuir->code == CUIR_RESUME) {\n\t\t \n\t\tdasd_eckd_cuir_resume(device, lpum, cuir);\n\t\tresponse = PSF_CUIR_COMPLETED;\n\t} else\n\t\tresponse = PSF_CUIR_NOT_SUPPORTED;\n\n\tdasd_eckd_psf_cuir_response(device, response,\n\t\t\t\t    cuir->message_id, lpum);\n\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t      \"CUIR response: %d on message ID %08x\", response,\n\t\t      cuir->message_id);\n\t \n\tdevice->discipline->check_attention(device, lpum);\n}\n\nstatic void dasd_eckd_oos_resume(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct alias_pav_group *pavgroup, *tempgroup;\n\tstruct dasd_device *dev, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&private->lcu->lock, flags);\n\tlist_for_each_entry_safe(dev, n, &private->lcu->active_devices,\n\t\t\t\t alias_list) {\n\t\tif (dev->stopped & DASD_STOPPED_NOSPC)\n\t\t\tdasd_generic_space_avail(dev);\n\t}\n\tlist_for_each_entry_safe(dev, n, &private->lcu->inactive_devices,\n\t\t\t\t alias_list) {\n\t\tif (dev->stopped & DASD_STOPPED_NOSPC)\n\t\t\tdasd_generic_space_avail(dev);\n\t}\n\t \n\tlist_for_each_entry_safe(pavgroup, tempgroup,\n\t\t\t\t &private->lcu->grouplist,\n\t\t\t\t group) {\n\t\tlist_for_each_entry_safe(dev, n, &pavgroup->baselist,\n\t\t\t\t\t alias_list) {\n\t\t\tif (dev->stopped & DASD_STOPPED_NOSPC)\n\t\t\t\tdasd_generic_space_avail(dev);\n\t\t}\n\t\tlist_for_each_entry_safe(dev, n, &pavgroup->aliaslist,\n\t\t\t\t\t alias_list) {\n\t\t\tif (dev->stopped & DASD_STOPPED_NOSPC)\n\t\t\t\tdasd_generic_space_avail(dev);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&private->lcu->lock, flags);\n}\n\nstatic void dasd_eckd_handle_oos(struct dasd_device *device, void *messages,\n\t\t\t\t __u8 lpum)\n{\n\tstruct dasd_oos_message *oos = messages;\n\n\tswitch (oos->code) {\n\tcase REPO_WARN:\n\tcase POOL_WARN:\n\t\tdev_warn(&device->cdev->dev,\n\t\t\t \"Extent pool usage has reached a critical value\\n\");\n\t\tdasd_eckd_oos_resume(device);\n\t\tbreak;\n\tcase REPO_EXHAUST:\n\tcase POOL_EXHAUST:\n\t\tdev_warn(&device->cdev->dev,\n\t\t\t \"Extent pool is exhausted\\n\");\n\t\tbreak;\n\tcase REPO_RELIEVE:\n\tcase POOL_RELIEVE:\n\t\tdev_info(&device->cdev->dev,\n\t\t\t \"Extent pool physical space constraint has been relieved\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tdasd_eckd_read_ext_pool_info(device);\n\n\t \n\tdevice->discipline->check_attention(device, lpum);\n}\n\nstatic void dasd_eckd_check_attention_work(struct work_struct *work)\n{\n\tstruct check_attention_work_data *data;\n\tstruct dasd_rssd_messages *messages;\n\tstruct dasd_device *device;\n\tint rc;\n\n\tdata = container_of(work, struct check_attention_work_data, worker);\n\tdevice = data->device;\n\tmessages = kzalloc(sizeof(*messages), GFP_KERNEL);\n\tif (!messages) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"Could not allocate attention message buffer\");\n\t\tgoto out;\n\t}\n\trc = dasd_eckd_read_message_buffer(device, messages, data->lpum);\n\tif (rc)\n\t\tgoto out;\n\n\tif (messages->length == ATTENTION_LENGTH_CUIR &&\n\t    messages->format == ATTENTION_FORMAT_CUIR)\n\t\tdasd_eckd_handle_cuir(device, messages, data->lpum);\n\tif (messages->length == ATTENTION_LENGTH_OOS &&\n\t    messages->format == ATTENTION_FORMAT_OOS)\n\t\tdasd_eckd_handle_oos(device, messages, data->lpum);\n\nout:\n\tdasd_put_device(device);\n\tkfree(messages);\n\tkfree(data);\n}\n\nstatic int dasd_eckd_check_attention(struct dasd_device *device, __u8 lpum)\n{\n\tstruct check_attention_work_data *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_ATOMIC);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tINIT_WORK(&data->worker, dasd_eckd_check_attention_work);\n\tdasd_get_device(device);\n\tdata->device = device;\n\tdata->lpum = lpum;\n\tschedule_work(&data->worker);\n\treturn 0;\n}\n\nstatic int dasd_eckd_disable_hpf_path(struct dasd_device *device, __u8 lpum)\n{\n\tif (~lpum & dasd_path_get_opm(device)) {\n\t\tdasd_path_add_nohpfpm(device, lpum);\n\t\tdasd_path_remove_opm(device, lpum);\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"Channel path %02X lost HPF functionality and is disabled\\n\",\n\t\t\tlpum);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void dasd_eckd_disable_hpf_device(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\tdev_err(&device->cdev->dev,\n\t\t\"High Performance FICON disabled\\n\");\n\tprivate->fcx_max_data = 0;\n}\n\nstatic int dasd_eckd_hpf_enabled(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\treturn private->fcx_max_data ? 1 : 0;\n}\n\nstatic void dasd_eckd_handle_hpf_error(struct dasd_device *device,\n\t\t\t\t       struct irb *irb)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\tif (!private->fcx_max_data) {\n\t\t \n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"Trying to disable HPF for a non HPF device\");\n\t\treturn;\n\t}\n\tif (irb->scsw.tm.sesq == SCSW_SESQ_DEV_NOFCX) {\n\t\tdasd_eckd_disable_hpf_device(device);\n\t} else if (irb->scsw.tm.sesq == SCSW_SESQ_PATH_NOFCX) {\n\t\tif (dasd_eckd_disable_hpf_path(device, irb->esw.esw1.lpum))\n\t\t\treturn;\n\t\tdasd_eckd_disable_hpf_device(device);\n\t\tdasd_path_set_tbvpm(device,\n\t\t\t\t  dasd_path_get_hpfpm(device));\n\t}\n\t \n\tdasd_device_set_stop_bits(device, DASD_STOPPED_NOT_ACC);\n\tdasd_schedule_requeue(device);\n}\n\n \nstatic void dasd_eckd_setup_blk_queue(struct dasd_block *block)\n{\n\tunsigned int logical_block_size = block->bp_block;\n\tstruct request_queue *q = block->gdp->queue;\n\tstruct dasd_device *device = block->base;\n\tint max;\n\n\tif (device->features & DASD_FEATURE_USERAW) {\n\t\t \n\t\tmax = DASD_ECKD_MAX_BLOCKS_RAW << block->s2b_shift;\n\t} else {\n\t\tmax = DASD_ECKD_MAX_BLOCKS << block->s2b_shift;\n\t}\n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, q);\n\tq->limits.max_dev_sectors = max;\n\tblk_queue_logical_block_size(q, logical_block_size);\n\tblk_queue_max_hw_sectors(q, max);\n\tblk_queue_max_segments(q, USHRT_MAX);\n\t \n\tblk_queue_max_segment_size(q, PAGE_SIZE);\n\tblk_queue_segment_boundary(q, PAGE_SIZE - 1);\n\tblk_queue_dma_alignment(q, PAGE_SIZE - 1);\n}\n\nstatic struct ccw_driver dasd_eckd_driver = {\n\t.driver = {\n\t\t.name\t= \"dasd-eckd\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.dev_groups = dasd_dev_groups,\n\t},\n\t.ids\t     = dasd_eckd_ids,\n\t.probe\t     = dasd_eckd_probe,\n\t.remove      = dasd_generic_remove,\n\t.set_offline = dasd_generic_set_offline,\n\t.set_online  = dasd_eckd_set_online,\n\t.notify      = dasd_generic_notify,\n\t.path_event  = dasd_generic_path_event,\n\t.shutdown    = dasd_generic_shutdown,\n\t.uc_handler  = dasd_generic_uc_handler,\n\t.int_class   = IRQIO_DAS,\n};\n\nstatic struct dasd_discipline dasd_eckd_discipline = {\n\t.owner = THIS_MODULE,\n\t.name = \"ECKD\",\n\t.ebcname = \"ECKD\",\n\t.check_device = dasd_eckd_check_characteristics,\n\t.uncheck_device = dasd_eckd_uncheck_device,\n\t.do_analysis = dasd_eckd_do_analysis,\n\t.pe_handler = dasd_eckd_pe_handler,\n\t.basic_to_ready = dasd_eckd_basic_to_ready,\n\t.online_to_ready = dasd_eckd_online_to_ready,\n\t.basic_to_known = dasd_eckd_basic_to_known,\n\t.setup_blk_queue = dasd_eckd_setup_blk_queue,\n\t.fill_geometry = dasd_eckd_fill_geometry,\n\t.start_IO = dasd_start_IO,\n\t.term_IO = dasd_term_IO,\n\t.handle_terminated_request = dasd_eckd_handle_terminated_request,\n\t.format_device = dasd_eckd_format_device,\n\t.check_device_format = dasd_eckd_check_device_format,\n\t.erp_action = dasd_eckd_erp_action,\n\t.erp_postaction = dasd_eckd_erp_postaction,\n\t.check_for_device_change = dasd_eckd_check_for_device_change,\n\t.build_cp = dasd_eckd_build_alias_cp,\n\t.free_cp = dasd_eckd_free_alias_cp,\n\t.dump_sense = dasd_eckd_dump_sense,\n\t.dump_sense_dbf = dasd_eckd_dump_sense_dbf,\n\t.fill_info = dasd_eckd_fill_info,\n\t.ioctl = dasd_eckd_ioctl,\n\t.reload = dasd_eckd_reload_device,\n\t.get_uid = dasd_eckd_get_uid,\n\t.kick_validate = dasd_eckd_kick_validate_server,\n\t.check_attention = dasd_eckd_check_attention,\n\t.host_access_count = dasd_eckd_host_access_count,\n\t.hosts_print = dasd_hosts_print,\n\t.handle_hpf_error = dasd_eckd_handle_hpf_error,\n\t.disable_hpf = dasd_eckd_disable_hpf_device,\n\t.hpf_enabled = dasd_eckd_hpf_enabled,\n\t.reset_path = dasd_eckd_reset_path,\n\t.is_ese = dasd_eckd_is_ese,\n\t.space_allocated = dasd_eckd_space_allocated,\n\t.space_configured = dasd_eckd_space_configured,\n\t.logical_capacity = dasd_eckd_logical_capacity,\n\t.release_space = dasd_eckd_release_space,\n\t.ext_pool_id = dasd_eckd_ext_pool_id,\n\t.ext_size = dasd_eckd_ext_size,\n\t.ext_pool_cap_at_warnlevel = dasd_eckd_ext_pool_cap_at_warnlevel,\n\t.ext_pool_warn_thrshld = dasd_eckd_ext_pool_warn_thrshld,\n\t.ext_pool_oos = dasd_eckd_ext_pool_oos,\n\t.ext_pool_exhaust = dasd_eckd_ext_pool_exhaust,\n\t.ese_format = dasd_eckd_ese_format,\n\t.ese_read = dasd_eckd_ese_read,\n\t.pprc_status = dasd_eckd_query_pprc_status,\n\t.pprc_enabled = dasd_eckd_pprc_enabled,\n\t.copy_pair_swap = dasd_eckd_copy_pair_swap,\n\t.device_ping = dasd_eckd_device_ping,\n};\n\nstatic int __init\ndasd_eckd_init(void)\n{\n\tint ret;\n\n\tASCEBC(dasd_eckd_discipline.ebcname, 4);\n\tdasd_reserve_req = kmalloc(sizeof(*dasd_reserve_req),\n\t\t\t\t   GFP_KERNEL | GFP_DMA);\n\tif (!dasd_reserve_req)\n\t\treturn -ENOMEM;\n\tdasd_vol_info_req = kmalloc(sizeof(*dasd_vol_info_req),\n\t\t\t\t    GFP_KERNEL | GFP_DMA);\n\tif (!dasd_vol_info_req) {\n\t\tkfree(dasd_reserve_req);\n\t\treturn -ENOMEM;\n\t}\n\tpe_handler_worker = kmalloc(sizeof(*pe_handler_worker),\n\t\t\t\t    GFP_KERNEL | GFP_DMA);\n\tif (!pe_handler_worker) {\n\t\tkfree(dasd_reserve_req);\n\t\tkfree(dasd_vol_info_req);\n\t\treturn -ENOMEM;\n\t}\n\trawpadpage = (void *)__get_free_page(GFP_KERNEL);\n\tif (!rawpadpage) {\n\t\tkfree(pe_handler_worker);\n\t\tkfree(dasd_reserve_req);\n\t\tkfree(dasd_vol_info_req);\n\t\treturn -ENOMEM;\n\t}\n\tret = ccw_driver_register(&dasd_eckd_driver);\n\tif (!ret)\n\t\twait_for_device_probe();\n\telse {\n\t\tkfree(pe_handler_worker);\n\t\tkfree(dasd_reserve_req);\n\t\tkfree(dasd_vol_info_req);\n\t\tfree_page((unsigned long)rawpadpage);\n\t}\n\treturn ret;\n}\n\nstatic void __exit\ndasd_eckd_cleanup(void)\n{\n\tccw_driver_unregister(&dasd_eckd_driver);\n\tkfree(pe_handler_worker);\n\tkfree(dasd_reserve_req);\n\tfree_page((unsigned long)rawpadpage);\n}\n\nmodule_init(dasd_eckd_init);\nmodule_exit(dasd_eckd_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}