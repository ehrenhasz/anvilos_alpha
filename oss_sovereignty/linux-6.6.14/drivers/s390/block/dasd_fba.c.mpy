{
  "module_name": "dasd_fba.c",
  "hash_id": "fa44d2209552acf742a91ea07abe3b02ed18e61971ab3f531eb9b4c300471cb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_fba.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd-fba\"\n\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <asm/debug.h>\n\n#include <linux/slab.h>\n#include <linux/hdreg.h>\t \n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n\n#include <asm/idals.h>\n#include <asm/ebcdic.h>\n#include <asm/ccwdev.h>\n\n#include \"dasd_int.h\"\n#include \"dasd_fba.h\"\n\n#ifdef PRINTK_HEADER\n#undef PRINTK_HEADER\n#endif\t\t\t\t \n#define PRINTK_HEADER \"dasd(fba):\"\n\n#define FBA_DEFAULT_RETRIES 32\n\n#define DASD_FBA_CCW_WRITE 0x41\n#define DASD_FBA_CCW_READ 0x42\n#define DASD_FBA_CCW_LOCATE 0x43\n#define DASD_FBA_CCW_DEFINE_EXTENT 0x63\n\nMODULE_LICENSE(\"GPL\");\n\nstatic struct dasd_discipline dasd_fba_discipline;\nstatic void *dasd_fba_zero_page;\n\nstruct dasd_fba_private {\n\tstruct dasd_fba_characteristics rdc_data;\n};\n\nstatic struct ccw_device_id dasd_fba_ids[] = {\n\t{ CCW_DEVICE_DEVTYPE (0x6310, 0, 0x9336, 0), .driver_info = 0x1},\n\t{ CCW_DEVICE_DEVTYPE (0x3880, 0, 0x3370, 0), .driver_info = 0x2},\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(ccw, dasd_fba_ids);\n\nstatic int\ndasd_fba_set_online(struct ccw_device *cdev)\n{\n\treturn dasd_generic_set_online(cdev, &dasd_fba_discipline);\n}\n\nstatic struct ccw_driver dasd_fba_driver = {\n\t.driver = {\n\t\t.name\t= \"dasd-fba\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.dev_groups = dasd_dev_groups,\n\t},\n\t.ids         = dasd_fba_ids,\n\t.probe       = dasd_generic_probe,\n\t.remove      = dasd_generic_remove,\n\t.set_offline = dasd_generic_set_offline,\n\t.set_online  = dasd_fba_set_online,\n\t.notify      = dasd_generic_notify,\n\t.path_event  = dasd_generic_path_event,\n\t.int_class   = IRQIO_DAS,\n};\n\nstatic void\ndefine_extent(struct ccw1 * ccw, struct DE_fba_data *data, int rw,\n\t      int blksize, int beg, int nr)\n{\n\tccw->cmd_code = DASD_FBA_CCW_DEFINE_EXTENT;\n\tccw->flags = 0;\n\tccw->count = 16;\n\tccw->cda = (__u32)virt_to_phys(data);\n\tmemset(data, 0, sizeof (struct DE_fba_data));\n\tif (rw == WRITE)\n\t\t(data->mask).perm = 0x0;\n\telse if (rw == READ)\n\t\t(data->mask).perm = 0x1;\n\telse\n\t\tdata->mask.perm = 0x2;\n\tdata->blk_size = blksize;\n\tdata->ext_loc = beg;\n\tdata->ext_end = nr - 1;\n}\n\nstatic void\nlocate_record(struct ccw1 * ccw, struct LO_fba_data *data, int rw,\n\t      int block_nr, int block_ct)\n{\n\tccw->cmd_code = DASD_FBA_CCW_LOCATE;\n\tccw->flags = 0;\n\tccw->count = 8;\n\tccw->cda = (__u32)virt_to_phys(data);\n\tmemset(data, 0, sizeof (struct LO_fba_data));\n\tif (rw == WRITE)\n\t\tdata->operation.cmd = 0x5;\n\telse if (rw == READ)\n\t\tdata->operation.cmd = 0x6;\n\telse\n\t\tdata->operation.cmd = 0x8;\n\tdata->blk_nr = block_nr;\n\tdata->blk_ct = block_ct;\n}\n\nstatic int\ndasd_fba_check_characteristics(struct dasd_device *device)\n{\n\tstruct dasd_fba_private *private = device->private;\n\tstruct ccw_device *cdev = device->cdev;\n\tstruct dasd_block *block;\n\tint readonly, rc;\n\n\tif (!private) {\n\t\tprivate = kzalloc(sizeof(*private), GFP_KERNEL | GFP_DMA);\n\t\tif (!private) {\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"Allocating memory for private DASD \"\n\t\t\t\t \"data failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdevice->private = private;\n\t} else {\n\t\tmemset(private, 0, sizeof(*private));\n\t}\n\tblock = dasd_alloc_block();\n\tif (IS_ERR(block)) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, cdev, \"%s\", \"could not allocate \"\n\t\t\t\t\"dasd block structure\");\n\t\tdevice->private = NULL;\n\t\tkfree(private);\n\t\treturn PTR_ERR(block);\n\t}\n\tdevice->block = block;\n\tblock->base = device;\n\n\t \n\trc = dasd_generic_read_dev_chars(device, DASD_FBA_MAGIC,\n\t\t\t\t\t &private->rdc_data, 32);\n\tif (rc) {\n\t\tDBF_EVENT_DEVID(DBF_WARNING, cdev, \"Read device \"\n\t\t\t\t\"characteristics returned error %d\", rc);\n\t\tdevice->block = NULL;\n\t\tdasd_free_block(block);\n\t\tdevice->private = NULL;\n\t\tkfree(private);\n\t\treturn rc;\n\t}\n\n\tdevice->default_expires = DASD_EXPIRES;\n\tdevice->default_retries = FBA_DEFAULT_RETRIES;\n\tdasd_path_set_opm(device, LPM_ANYPATH);\n\n\treadonly = dasd_device_is_ro(device);\n\tif (readonly)\n\t\tset_bit(DASD_FLAG_DEVICE_RO, &device->flags);\n\n\t \n\tdasd_set_feature(cdev, DASD_FEATURE_DISCARD, 1);\n\n\tdev_info(&device->cdev->dev,\n\t\t \"New FBA DASD %04X/%02X (CU %04X/%02X) with %d MB \"\n\t\t \"and %d B/blk%s\\n\",\n\t\t cdev->id.dev_type,\n\t\t cdev->id.dev_model,\n\t\t cdev->id.cu_type,\n\t\t cdev->id.cu_model,\n\t\t ((private->rdc_data.blk_bdsa *\n\t\t   (private->rdc_data.blk_size >> 9)) >> 11),\n\t\t private->rdc_data.blk_size,\n\t\t readonly ? \", read-only device\" : \"\");\n\treturn 0;\n}\n\nstatic int dasd_fba_do_analysis(struct dasd_block *block)\n{\n\tstruct dasd_fba_private *private = block->base->private;\n\tint sb, rc;\n\n\trc = dasd_check_blocksize(private->rdc_data.blk_size);\n\tif (rc) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, block->base, \"unknown blocksize %d\",\n\t\t\t    private->rdc_data.blk_size);\n\t\treturn rc;\n\t}\n\tblock->blocks = private->rdc_data.blk_bdsa;\n\tblock->bp_block = private->rdc_data.blk_size;\n\tblock->s2b_shift = 0;\t \n\tfor (sb = 512; sb < private->rdc_data.blk_size; sb = sb << 1)\n\t\tblock->s2b_shift++;\n\treturn 0;\n}\n\nstatic int dasd_fba_fill_geometry(struct dasd_block *block,\n\t\t\t\t  struct hd_geometry *geo)\n{\n\tif (dasd_check_blocksize(block->bp_block) != 0)\n\t\treturn -EINVAL;\n\tgeo->cylinders = (block->blocks << block->s2b_shift) >> 10;\n\tgeo->heads = 16;\n\tgeo->sectors = 128 >> block->s2b_shift;\n\treturn 0;\n}\n\nstatic dasd_erp_fn_t\ndasd_fba_erp_action(struct dasd_ccw_req * cqr)\n{\n\treturn dasd_default_erp_action;\n}\n\nstatic dasd_erp_fn_t\ndasd_fba_erp_postaction(struct dasd_ccw_req * cqr)\n{\n\tif (cqr->function == dasd_default_erp_action)\n\t\treturn dasd_default_erp_postaction;\n\n\tDBF_DEV_EVENT(DBF_WARNING, cqr->startdev, \"unknown ERP action %p\",\n\t\t    cqr->function);\n\treturn NULL;\n}\n\nstatic void dasd_fba_check_for_device_change(struct dasd_device *device,\n\t\t\t\t\t     struct dasd_ccw_req *cqr,\n\t\t\t\t\t     struct irb *irb)\n{\n\tchar mask;\n\n\t \n\tmask = DEV_STAT_ATTENTION | DEV_STAT_DEV_END | DEV_STAT_UNIT_EXCEP;\n\tif ((irb->scsw.cmd.dstat & mask) == mask)\n\t\tdasd_generic_handle_state_change(device);\n};\n\n\n \nstatic void ccw_write_no_data(struct ccw1 *ccw)\n{\n\tccw->cmd_code = DASD_FBA_CCW_WRITE;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->count = 0;\n}\n\n \nstatic void ccw_write_zero(struct ccw1 *ccw, int count)\n{\n\tccw->cmd_code = DASD_FBA_CCW_WRITE;\n\tccw->flags |= CCW_FLAG_SLI;\n\tccw->count = count;\n\tccw->cda = (__u32)virt_to_phys(dasd_fba_zero_page);\n}\n\n \nstatic int count_ccws(sector_t first_rec, sector_t last_rec,\n\t\t      unsigned int blocks_per_page)\n{\n\tsector_t wz_stop = 0, d_stop = 0;\n\tint cur_pos = 0;\n\tint count = 0;\n\n\tif (first_rec % blocks_per_page != 0) {\n\t\twz_stop = first_rec + blocks_per_page -\n\t\t\t(first_rec % blocks_per_page) - 1;\n\t\tif (wz_stop > last_rec)\n\t\t\twz_stop = last_rec;\n\t\tcur_pos = wz_stop - first_rec + 1;\n\t\tcount++;\n\t}\n\n\tif (last_rec - (first_rec + cur_pos) + 1 >= blocks_per_page) {\n\t\tif ((last_rec - blocks_per_page + 1) % blocks_per_page != 0)\n\t\t\td_stop = last_rec - ((last_rec - blocks_per_page + 1) %\n\t\t\t\t\t     blocks_per_page);\n\t\telse\n\t\t\td_stop = last_rec;\n\n\t\tcur_pos += d_stop - (first_rec + cur_pos) + 1;\n\t\tcount++;\n\t}\n\n\tif (cur_pos == 0 || first_rec + cur_pos - 1 < last_rec)\n\t\tcount++;\n\n\treturn count;\n}\n\n \nstatic struct dasd_ccw_req *dasd_fba_build_cp_discard(\n\t\t\t\t\t\tstruct dasd_device *memdev,\n\t\t\t\t\t\tstruct dasd_block *block,\n\t\t\t\t\t\tstruct request *req)\n{\n\tstruct LO_fba_data *LO_data;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\n\tsector_t wz_stop = 0, d_stop = 0;\n\tsector_t first_rec, last_rec;\n\n\tunsigned int blksize = block->bp_block;\n\tunsigned int blocks_per_page;\n\tint wz_count = 0;\n\tint d_count = 0;\n\tint cur_pos = 0;  \n\tint count = 0;\n\tint cplength;\n\tint datasize;\n\tint nr_ccws;\n\n\tfirst_rec = blk_rq_pos(req) >> block->s2b_shift;\n\tlast_rec =\n\t\t(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\n\tcount = last_rec - first_rec + 1;\n\n\tblocks_per_page = BLOCKS_PER_PAGE(blksize);\n\tnr_ccws = count_ccws(first_rec, last_rec, blocks_per_page);\n\n\t \n\tcplength = 1 + 2 * nr_ccws;\n\tdatasize = sizeof(struct DE_fba_data) +\n\t\tnr_ccws * (sizeof(struct LO_fba_data) + sizeof(struct ccw1));\n\n\tcqr = dasd_smalloc_request(DASD_FBA_MAGIC, cplength, datasize, memdev,\n\t\t\t\t   blk_mq_rq_to_pdu(req));\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\n\tccw = cqr->cpaddr;\n\n\tdefine_extent(ccw++, cqr->data, WRITE, blksize, first_rec, count);\n\tLO_data = cqr->data + sizeof(struct DE_fba_data);\n\n\t \n\tif (first_rec % blocks_per_page != 0) {\n\t\twz_stop = first_rec + blocks_per_page -\n\t\t\t(first_rec % blocks_per_page) - 1;\n\t\tif (wz_stop > last_rec)\n\t\t\twz_stop = last_rec;\n\t\twz_count = wz_stop - first_rec + 1;\n\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tlocate_record(ccw++, LO_data++, WRITE, cur_pos, wz_count);\n\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tccw_write_zero(ccw++, wz_count * blksize);\n\n\t\tcur_pos = wz_count;\n\t}\n\n\t \n\tif (last_rec - (first_rec + cur_pos) + 1 >= blocks_per_page) {\n\t\t \n\t\tif ((last_rec - blocks_per_page + 1) % blocks_per_page != 0)\n\t\t\td_stop = last_rec - ((last_rec - blocks_per_page + 1) %\n\t\t\t\t\t     blocks_per_page);\n\t\telse\n\t\t\td_stop = last_rec;\n\n\t\td_count = d_stop - (first_rec + cur_pos) + 1;\n\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tlocate_record(ccw++, LO_data++, WRITE, cur_pos, d_count);\n\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tccw_write_no_data(ccw++);\n\n\t\tcur_pos += d_count;\n\t}\n\n\t \n\tif (cur_pos == 0 || first_rec + cur_pos - 1 < last_rec) {\n\t\tif (d_stop != 0)\n\t\t\twz_count = last_rec - d_stop;\n\t\telse if (wz_stop != 0)\n\t\t\twz_count = last_rec - wz_stop;\n\t\telse\n\t\t\twz_count = count;\n\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tlocate_record(ccw++, LO_data++, WRITE, cur_pos, wz_count);\n\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tccw_write_zero(ccw++, wz_count * blksize);\n\t}\n\n\tif (blk_noretry_request(req) ||\n\t    block->base->features & DASD_FEATURE_FAILFAST)\n\t\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\n\tcqr->startdev = memdev;\n\tcqr->memdev = memdev;\n\tcqr->block = block;\n\tcqr->expires = memdev->default_expires * HZ;\t \n\tcqr->retries = memdev->default_retries;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\treturn cqr;\n}\n\nstatic struct dasd_ccw_req *dasd_fba_build_cp_regular(\n\t\t\t\t\t\tstruct dasd_device *memdev,\n\t\t\t\t\t\tstruct dasd_block *block,\n\t\t\t\t\t\tstruct request *req)\n{\n\tstruct dasd_fba_private *private = block->base->private;\n\tunsigned long *idaws;\n\tstruct LO_fba_data *LO_data;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tstruct req_iterator iter;\n\tstruct bio_vec bv;\n\tchar *dst;\n\tint count, cidaw, cplength, datasize;\n\tsector_t recid, first_rec, last_rec;\n\tunsigned int blksize, off;\n\tunsigned char cmd;\n\n\tif (rq_data_dir(req) == READ) {\n\t\tcmd = DASD_FBA_CCW_READ;\n\t} else if (rq_data_dir(req) == WRITE) {\n\t\tcmd = DASD_FBA_CCW_WRITE;\n\t} else\n\t\treturn ERR_PTR(-EINVAL);\n\tblksize = block->bp_block;\n\t \n\tfirst_rec = blk_rq_pos(req) >> block->s2b_shift;\n\tlast_rec =\n\t\t(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\n\t \n\tcount = 0;\n\tcidaw = 0;\n\trq_for_each_segment(bv, req, iter) {\n\t\tif (bv.bv_len & (blksize - 1))\n\t\t\t \n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcount += bv.bv_len >> (block->s2b_shift + 9);\n\t\tif (idal_is_needed (page_address(bv.bv_page), bv.bv_len))\n\t\t\tcidaw += bv.bv_len / blksize;\n\t}\n\t \n\tif (count != last_rec - first_rec + 1)\n\t\treturn ERR_PTR(-EINVAL);\n\t \n\tcplength = 2 + count;\n\t \n\tdatasize = sizeof(struct DE_fba_data) + sizeof(struct LO_fba_data) +\n\t\tcidaw * sizeof(unsigned long);\n\t \n\tif (private->rdc_data.mode.bits.data_chain == 0) {\n\t\tcplength += count - 1;\n\t\tdatasize += (count - 1)*sizeof(struct LO_fba_data);\n\t}\n\t \n\tcqr = dasd_smalloc_request(DASD_FBA_MAGIC, cplength, datasize, memdev,\n\t\t\t\t   blk_mq_rq_to_pdu(req));\n\tif (IS_ERR(cqr))\n\t\treturn cqr;\n\tccw = cqr->cpaddr;\n\t \n\tdefine_extent(ccw++, cqr->data, rq_data_dir(req),\n\t\t      block->bp_block, blk_rq_pos(req), blk_rq_sectors(req));\n\t \n\tidaws = (unsigned long *) (cqr->data + sizeof(struct DE_fba_data));\n\tLO_data = (struct LO_fba_data *) (idaws + cidaw);\n\t \n\tif (private->rdc_data.mode.bits.data_chain != 0) {\n\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\tlocate_record(ccw++, LO_data++, rq_data_dir(req), 0, count);\n\t}\n\trecid = first_rec;\n\trq_for_each_segment(bv, req, iter) {\n\t\tdst = bvec_virt(&bv);\n\t\tif (dasd_page_cache) {\n\t\t\tchar *copy = kmem_cache_alloc(dasd_page_cache,\n\t\t\t\t\t\t      GFP_DMA | __GFP_NOWARN);\n\t\t\tif (copy && rq_data_dir(req) == WRITE)\n\t\t\t\tmemcpy(copy + bv.bv_offset, dst, bv.bv_len);\n\t\t\tif (copy)\n\t\t\t\tdst = copy + bv.bv_offset;\n\t\t}\n\t\tfor (off = 0; off < bv.bv_len; off += blksize) {\n\t\t\t \n\t\t\tif (private->rdc_data.mode.bits.data_chain == 0) {\n\t\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\t\tlocate_record(ccw, LO_data++,\n\t\t\t\t\t      rq_data_dir(req),\n\t\t\t\t\t      recid - first_rec, 1);\n\t\t\t\tccw->flags = CCW_FLAG_CC;\n\t\t\t\tccw++;\n\t\t\t} else {\n\t\t\t\tif (recid > first_rec)\n\t\t\t\t\tccw[-1].flags |= CCW_FLAG_DC;\n\t\t\t\telse\n\t\t\t\t\tccw[-1].flags |= CCW_FLAG_CC;\n\t\t\t}\n\t\t\tccw->cmd_code = cmd;\n\t\t\tccw->count = block->bp_block;\n\t\t\tif (idal_is_needed(dst, blksize)) {\n\t\t\t\tccw->cda = (__u32)virt_to_phys(idaws);\n\t\t\t\tccw->flags = CCW_FLAG_IDA;\n\t\t\t\tidaws = idal_create_words(idaws, dst, blksize);\n\t\t\t} else {\n\t\t\t\tccw->cda = (__u32)virt_to_phys(dst);\n\t\t\t\tccw->flags = 0;\n\t\t\t}\n\t\t\tccw++;\n\t\t\tdst += blksize;\n\t\t\trecid++;\n\t\t}\n\t}\n\tif (blk_noretry_request(req) ||\n\t    block->base->features & DASD_FEATURE_FAILFAST)\n\t\tset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\n\tcqr->startdev = memdev;\n\tcqr->memdev = memdev;\n\tcqr->block = block;\n\tcqr->expires = memdev->default_expires * HZ;\t \n\tcqr->retries = memdev->default_retries;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\treturn cqr;\n}\n\nstatic struct dasd_ccw_req *dasd_fba_build_cp(struct dasd_device *memdev,\n\t\t\t\t\t      struct dasd_block *block,\n\t\t\t\t\t      struct request *req)\n{\n\tif (req_op(req) == REQ_OP_DISCARD || req_op(req) == REQ_OP_WRITE_ZEROES)\n\t\treturn dasd_fba_build_cp_discard(memdev, block, req);\n\telse\n\t\treturn dasd_fba_build_cp_regular(memdev, block, req);\n}\n\nstatic int\ndasd_fba_free_cp(struct dasd_ccw_req *cqr, struct request *req)\n{\n\tstruct dasd_fba_private *private = cqr->block->base->private;\n\tstruct ccw1 *ccw;\n\tstruct req_iterator iter;\n\tstruct bio_vec bv;\n\tchar *dst, *cda;\n\tunsigned int blksize, off;\n\tint status;\n\n\tif (!dasd_page_cache)\n\t\tgoto out;\n\tblksize = cqr->block->bp_block;\n\tccw = cqr->cpaddr;\n\t \n\tccw++;\n\tif (private->rdc_data.mode.bits.data_chain != 0)\n\t\tccw++;\n\trq_for_each_segment(bv, req, iter) {\n\t\tdst = bvec_virt(&bv);\n\t\tfor (off = 0; off < bv.bv_len; off += blksize) {\n\t\t\t \n\t\t\tif (private->rdc_data.mode.bits.data_chain == 0)\n\t\t\t\tccw++;\n\t\t\tif (dst) {\n\t\t\t\tif (ccw->flags & CCW_FLAG_IDA)\n\t\t\t\t\tcda = *((char **)phys_to_virt(ccw->cda));\n\t\t\t\telse\n\t\t\t\t\tcda = phys_to_virt(ccw->cda);\n\t\t\t\tif (dst != cda) {\n\t\t\t\t\tif (rq_data_dir(req) == READ)\n\t\t\t\t\t\tmemcpy(dst, cda, bv.bv_len);\n\t\t\t\t\tkmem_cache_free(dasd_page_cache,\n\t\t\t\t\t    (void *)((addr_t)cda & PAGE_MASK));\n\t\t\t\t}\n\t\t\t\tdst = NULL;\n\t\t\t}\n\t\t\tccw++;\n\t\t}\n\t}\nout:\n\tstatus = cqr->status == DASD_CQR_DONE;\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn status;\n}\n\nstatic void dasd_fba_handle_terminated_request(struct dasd_ccw_req *cqr)\n{\n\tif (cqr->retries < 0)\n\t\tcqr->status = DASD_CQR_FAILED;\n\telse\n\t\tcqr->status = DASD_CQR_FILLED;\n};\n\nstatic int\ndasd_fba_fill_info(struct dasd_device * device,\n\t\t   struct dasd_information2_t * info)\n{\n\tstruct dasd_fba_private *private = device->private;\n\n\tinfo->label_block = 1;\n\tinfo->FBA_layout = 1;\n\tinfo->format = DASD_FORMAT_LDL;\n\tinfo->characteristics_size = sizeof(private->rdc_data);\n\tmemcpy(info->characteristics, &private->rdc_data,\n\t       sizeof(private->rdc_data));\n\tinfo->confdata_size = 0;\n\treturn 0;\n}\n\nstatic void\ndasd_fba_dump_sense_dbf(struct dasd_device *device, struct irb *irb,\n\t\t\tchar *reason)\n{\n\tu64 *sense;\n\n\tsense = (u64 *) dasd_get_sense(irb);\n\tif (sense) {\n\t\tDBF_DEV_EVENT(DBF_EMERG, device,\n\t\t\t      \"%s: %s %02x%02x%02x %016llx %016llx %016llx \"\n\t\t\t      \"%016llx\", reason,\n\t\t\t      scsw_is_tm(&irb->scsw) ? \"t\" : \"c\",\n\t\t\t      scsw_cc(&irb->scsw), scsw_cstat(&irb->scsw),\n\t\t\t      scsw_dstat(&irb->scsw), sense[0], sense[1],\n\t\t\t      sense[2], sense[3]);\n\t} else {\n\t\tDBF_DEV_EVENT(DBF_EMERG, device, \"%s\",\n\t\t\t      \"SORRY - NO VALID SENSE AVAILABLE\\n\");\n\t}\n}\n\n\nstatic void\ndasd_fba_dump_sense(struct dasd_device *device, struct dasd_ccw_req * req,\n\t\t    struct irb *irb)\n{\n\tchar *page;\n\tstruct ccw1 *act, *end, *last;\n\tint len, sl, sct, count;\n\n\tpage = (char *) get_zeroed_page(GFP_ATOMIC);\n\tif (page == NULL) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"No memory to dump sense data\");\n\t\treturn;\n\t}\n\tlen = sprintf(page, PRINTK_HEADER\n\t\t      \" I/O status report for device %s:\\n\",\n\t\t      dev_name(&device->cdev->dev));\n\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t       \" in req: %p CS: 0x%02X DS: 0x%02X\\n\", req,\n\t\t       irb->scsw.cmd.cstat, irb->scsw.cmd.dstat);\n\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t       \" device %s: Failing CCW: %p\\n\",\n\t\t       dev_name(&device->cdev->dev),\n\t\t       (void *) (addr_t) irb->scsw.cmd.cpa);\n\tif (irb->esw.esw0.erw.cons) {\n\t\tfor (sl = 0; sl < 4; sl++) {\n\t\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t\t       \" Sense(hex) %2d-%2d:\",\n\t\t\t\t       (8 * sl), ((8 * sl) + 7));\n\n\t\t\tfor (sct = 0; sct < 8; sct++) {\n\t\t\t\tlen += sprintf(page + len, \" %02x\",\n\t\t\t\t\t       irb->ecw[8 * sl + sct]);\n\t\t\t}\n\t\t\tlen += sprintf(page + len, \"\\n\");\n\t\t}\n\t} else {\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" SORRY - NO VALID SENSE AVAILABLE\\n\");\n\t}\n\tprintk(KERN_ERR \"%s\", page);\n\n\t \n\t \n\tact = req->cpaddr;\n        for (last = act; last->flags & (CCW_FLAG_CC | CCW_FLAG_DC); last++);\n\tend = min(act + 8, last);\n\tlen = sprintf(page, PRINTK_HEADER \" Related CP in req: %p\\n\", req);\n\twhile (act <= end) {\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" CCW %p: %08X %08X DAT:\",\n\t\t\t       act, ((int *) act)[0], ((int *) act)[1]);\n\t\tfor (count = 0; count < 32 && count < act->count;\n\t\t     count += sizeof(int))\n\t\t\tlen += sprintf(page + len, \" %08X\",\n\t\t\t\t       ((int *) (addr_t) act->cda)\n\t\t\t\t       [(count>>2)]);\n\t\tlen += sprintf(page + len, \"\\n\");\n\t\tact++;\n\t}\n\tprintk(KERN_ERR \"%s\", page);\n\n\n\t \n\tlen = 0;\n\tif (act <  ((struct ccw1 *)(addr_t) irb->scsw.cmd.cpa) - 2) {\n\t\tact = ((struct ccw1 *)(addr_t) irb->scsw.cmd.cpa) - 2;\n\t\tlen += sprintf(page + len, PRINTK_HEADER \"......\\n\");\n\t}\n\tend = min((struct ccw1 *)(addr_t) irb->scsw.cmd.cpa + 2, last);\n\twhile (act <= end) {\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" CCW %p: %08X %08X DAT:\",\n\t\t\t       act, ((int *) act)[0], ((int *) act)[1]);\n\t\tfor (count = 0; count < 32 && count < act->count;\n\t\t     count += sizeof(int))\n\t\t\tlen += sprintf(page + len, \" %08X\",\n\t\t\t\t       ((int *) (addr_t) act->cda)\n\t\t\t\t       [(count>>2)]);\n\t\tlen += sprintf(page + len, \"\\n\");\n\t\tact++;\n\t}\n\n\t \n\tif (act <  last - 2) {\n\t\tact = last - 2;\n\t\tlen += sprintf(page + len, PRINTK_HEADER \"......\\n\");\n\t}\n\twhile (act <= last) {\n\t\tlen += sprintf(page + len, PRINTK_HEADER\n\t\t\t       \" CCW %p: %08X %08X DAT:\",\n\t\t\t       act, ((int *) act)[0], ((int *) act)[1]);\n\t\tfor (count = 0; count < 32 && count < act->count;\n\t\t     count += sizeof(int))\n\t\t\tlen += sprintf(page + len, \" %08X\",\n\t\t\t\t       ((int *) (addr_t) act->cda)\n\t\t\t\t       [(count>>2)]);\n\t\tlen += sprintf(page + len, \"\\n\");\n\t\tact++;\n\t}\n\tif (len > 0)\n\t\tprintk(KERN_ERR \"%s\", page);\n\tfree_page((unsigned long) page);\n}\n\n \nstatic void dasd_fba_setup_blk_queue(struct dasd_block *block)\n{\n\tunsigned int logical_block_size = block->bp_block;\n\tstruct request_queue *q = block->gdp->queue;\n\tunsigned int max_bytes, max_discard_sectors;\n\tint max;\n\n\tmax = DASD_FBA_MAX_BLOCKS << block->s2b_shift;\n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, q);\n\tq->limits.max_dev_sectors = max;\n\tblk_queue_logical_block_size(q, logical_block_size);\n\tblk_queue_max_hw_sectors(q, max);\n\tblk_queue_max_segments(q, USHRT_MAX);\n\t \n\tblk_queue_max_segment_size(q, PAGE_SIZE);\n\tblk_queue_segment_boundary(q, PAGE_SIZE - 1);\n\n\tq->limits.discard_granularity = logical_block_size;\n\n\t \n\tmax_bytes = USHRT_MAX * logical_block_size;\n\tmax_bytes = ALIGN_DOWN(max_bytes, PAGE_SIZE);\n\tmax_discard_sectors = max_bytes / logical_block_size;\n\n\tblk_queue_max_discard_sectors(q, max_discard_sectors);\n\tblk_queue_max_write_zeroes_sectors(q, max_discard_sectors);\n}\n\nstatic int dasd_fba_pe_handler(struct dasd_device *device,\n\t\t\t       __u8 tbvpm, __u8 fcsecpm)\n{\n\treturn dasd_generic_verify_path(device, tbvpm);\n}\n\nstatic struct dasd_discipline dasd_fba_discipline = {\n\t.owner = THIS_MODULE,\n\t.name = \"FBA \",\n\t.ebcname = \"FBA \",\n\t.check_device = dasd_fba_check_characteristics,\n\t.do_analysis = dasd_fba_do_analysis,\n\t.pe_handler = dasd_fba_pe_handler,\n\t.setup_blk_queue = dasd_fba_setup_blk_queue,\n\t.fill_geometry = dasd_fba_fill_geometry,\n\t.start_IO = dasd_start_IO,\n\t.term_IO = dasd_term_IO,\n\t.handle_terminated_request = dasd_fba_handle_terminated_request,\n\t.erp_action = dasd_fba_erp_action,\n\t.erp_postaction = dasd_fba_erp_postaction,\n\t.check_for_device_change = dasd_fba_check_for_device_change,\n\t.build_cp = dasd_fba_build_cp,\n\t.free_cp = dasd_fba_free_cp,\n\t.dump_sense = dasd_fba_dump_sense,\n\t.dump_sense_dbf = dasd_fba_dump_sense_dbf,\n\t.fill_info = dasd_fba_fill_info,\n};\n\nstatic int __init\ndasd_fba_init(void)\n{\n\tint ret;\n\n\tASCEBC(dasd_fba_discipline.ebcname, 4);\n\n\tdasd_fba_zero_page = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!dasd_fba_zero_page)\n\t\treturn -ENOMEM;\n\n\tret = ccw_driver_register(&dasd_fba_driver);\n\tif (!ret)\n\t\twait_for_device_probe();\n\n\treturn ret;\n}\n\nstatic void __exit\ndasd_fba_cleanup(void)\n{\n\tccw_driver_unregister(&dasd_fba_driver);\n\tfree_page((unsigned long)dasd_fba_zero_page);\n}\n\nmodule_init(dasd_fba_init);\nmodule_exit(dasd_fba_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}