{
  "module_name": "dasd_ioctl.c",
  "hash_id": "8d62d159df74d966aad64553759bfedf20ac8d0fd7cfdcc61c065b42d2fb2a6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_ioctl.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd\"\n\n#include <linux/interrupt.h>\n#include <linux/compat.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/blkpg.h>\n#include <linux/slab.h>\n#include <asm/ccwdev.h>\n#include <asm/schid.h>\n#include <asm/cmb.h>\n#include <linux/uaccess.h>\n#include <linux/dasd_mod.h>\n\n \n#define PRINTK_HEADER \"dasd_ioctl:\"\n\n#include \"dasd_int.h\"\n\n\nstatic int\ndasd_ioctl_api_version(void __user *argp)\n{\n\tint ver = DASD_API_VERSION;\n\treturn put_user(ver, (int __user *)argp);\n}\n\n \nstatic int\ndasd_ioctl_enable(struct block_device *bdev)\n{\n\tstruct dasd_device *base;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tbase = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\n\tdasd_enable_device(base);\n\tdasd_put_device(base);\n\treturn 0;\n}\n\n \nstatic int\ndasd_ioctl_disable(struct block_device *bdev)\n{\n\tstruct dasd_device *base;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tbase = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\t \n\tdasd_set_target_state(base, DASD_STATE_BASIC);\n\t \n\tset_capacity(bdev->bd_disk, 0);\n\tdasd_put_device(base);\n\treturn 0;\n}\n\n \nstatic int dasd_ioctl_quiesce(struct dasd_block *block)\n{\n\tunsigned long flags;\n\tstruct dasd_device *base;\n\n\tbase = block->base;\n\tif (!capable (CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tpr_info(\"%s: The DASD has been put in the quiesce \"\n\t\t\"state\\n\", dev_name(&base->cdev->dev));\n\tspin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);\n\tdasd_device_set_stop_bits(base, DASD_STOPPED_QUIESCE);\n\tspin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);\n\treturn 0;\n}\n\n\n \nstatic int dasd_ioctl_resume(struct dasd_block *block)\n{\n\tunsigned long flags;\n\tstruct dasd_device *base;\n\n\tbase = block->base;\n\tif (!capable (CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tpr_info(\"%s: I/O operations have been resumed \"\n\t\t\"on the DASD\\n\", dev_name(&base->cdev->dev));\n\tspin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);\n\tdasd_device_remove_stop_bits(base, DASD_STOPPED_QUIESCE);\n\tspin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);\n\n\tdasd_schedule_block_bh(block);\n\tdasd_schedule_device_bh(base);\n\treturn 0;\n}\n\n \nstatic int dasd_ioctl_abortio(struct dasd_block *block)\n{\n\tunsigned long flags;\n\tstruct dasd_device *base;\n\tstruct dasd_ccw_req *cqr, *n;\n\n\tbase = block->base;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (test_and_set_bit(DASD_FLAG_ABORTALL, &base->flags))\n\t\treturn 0;\n\tDBF_DEV_EVENT(DBF_NOTICE, base, \"%s\", \"abortall flag set\");\n\n\tspin_lock_irqsave(&block->request_queue_lock, flags);\n\tspin_lock(&block->queue_lock);\n\tlist_for_each_entry_safe(cqr, n, &block->ccw_queue, blocklist) {\n\t\tif (test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&\n\t\t    cqr->callback_data &&\n\t\t    cqr->callback_data != DASD_SLEEPON_START_TAG &&\n\t\t    cqr->callback_data != DASD_SLEEPON_END_TAG) {\n\t\t\tspin_unlock(&block->queue_lock);\n\t\t\tblk_abort_request(cqr->callback_data);\n\t\t\tspin_lock(&block->queue_lock);\n\t\t}\n\t}\n\tspin_unlock(&block->queue_lock);\n\tspin_unlock_irqrestore(&block->request_queue_lock, flags);\n\n\tdasd_schedule_block_bh(block);\n\treturn 0;\n}\n\n \nstatic int dasd_ioctl_allowio(struct dasd_block *block)\n{\n\tstruct dasd_device *base;\n\n\tbase = block->base;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (test_and_clear_bit(DASD_FLAG_ABORTALL, &base->flags))\n\t\tDBF_DEV_EVENT(DBF_NOTICE, base, \"%s\", \"abortall flag unset\");\n\n\treturn 0;\n}\n\n \nstatic int\ndasd_format(struct dasd_block *block, struct format_data_t *fdata)\n{\n\tstruct dasd_device *base;\n\tint rc;\n\n\tbase = block->base;\n\tif (base->discipline->format_device == NULL)\n\t\treturn -EPERM;\n\n\tif (base->state != DASD_STATE_BASIC) {\n\t\tpr_warn(\"%s: The DASD cannot be formatted while it is enabled\\n\",\n\t\t\tdev_name(&base->cdev->dev));\n\t\treturn -EBUSY;\n\t}\n\n\tDBF_DEV_EVENT(DBF_NOTICE, base,\n\t\t      \"formatting units %u to %u (%u B blocks) flags %u\",\n\t\t      fdata->start_unit,\n\t\t      fdata->stop_unit, fdata->blksize, fdata->intensity);\n\n\t \n\tif (fdata->start_unit == 0) {\n\t\tblock->gdp->part0->bd_inode->i_blkbits =\n\t\t\tblksize_bits(fdata->blksize);\n\t}\n\n\trc = base->discipline->format_device(base, fdata, 1);\n\tif (rc == -EAGAIN)\n\t\trc = base->discipline->format_device(base, fdata, 0);\n\n\treturn rc;\n}\n\nstatic int dasd_check_format(struct dasd_block *block,\n\t\t\t     struct format_check_t *cdata)\n{\n\tstruct dasd_device *base;\n\tint rc;\n\n\tbase = block->base;\n\tif (!base->discipline->check_device_format)\n\t\treturn -ENOTTY;\n\n\trc = base->discipline->check_device_format(base, cdata, 1);\n\tif (rc == -EAGAIN)\n\t\trc = base->discipline->check_device_format(base, cdata, 0);\n\n\treturn rc;\n}\n\n \nstatic int\ndasd_ioctl_format(struct block_device *bdev, void __user *argp)\n{\n\tstruct dasd_device *base;\n\tstruct format_data_t fdata;\n\tint rc;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (!argp)\n\t\treturn -EINVAL;\n\tbase = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\tif (base->features & DASD_FEATURE_READONLY ||\n\t    test_bit(DASD_FLAG_DEVICE_RO, &base->flags)) {\n\t\tdasd_put_device(base);\n\t\treturn -EROFS;\n\t}\n\tif (copy_from_user(&fdata, argp, sizeof(struct format_data_t))) {\n\t\tdasd_put_device(base);\n\t\treturn -EFAULT;\n\t}\n\tif (bdev_is_partition(bdev)) {\n\t\tpr_warn(\"%s: The specified DASD is a partition and cannot be formatted\\n\",\n\t\t\tdev_name(&base->cdev->dev));\n\t\tdasd_put_device(base);\n\t\treturn -EINVAL;\n\t}\n\trc = dasd_format(base->block, &fdata);\n\tdasd_put_device(base);\n\n\treturn rc;\n}\n\n \nstatic int dasd_ioctl_check_format(struct block_device *bdev, void __user *argp)\n{\n\tstruct format_check_t cdata;\n\tstruct dasd_device *base;\n\tint rc = 0;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tbase = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\tif (bdev_is_partition(bdev)) {\n\t\tpr_warn(\"%s: The specified DASD is a partition and cannot be checked\\n\",\n\t\t\tdev_name(&base->cdev->dev));\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (copy_from_user(&cdata, argp, sizeof(cdata))) {\n\t\trc = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\trc = dasd_check_format(base->block, &cdata);\n\tif (rc)\n\t\tgoto out_err;\n\n\tif (copy_to_user(argp, &cdata, sizeof(cdata)))\n\t\trc = -EFAULT;\n\nout_err:\n\tdasd_put_device(base);\n\n\treturn rc;\n}\n\nstatic int dasd_release_space(struct dasd_device *device,\n\t\t\t      struct format_data_t *rdata)\n{\n\tif (!device->discipline->is_ese && !device->discipline->is_ese(device))\n\t\treturn -ENOTSUPP;\n\tif (!device->discipline->release_space)\n\t\treturn -ENOTSUPP;\n\n\treturn device->discipline->release_space(device, rdata);\n}\n\n \nstatic int dasd_ioctl_release_space(struct block_device *bdev, void __user *argp)\n{\n\tstruct format_data_t rdata;\n\tstruct dasd_device *base;\n\tint rc = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tbase = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\tif (base->features & DASD_FEATURE_READONLY ||\n\t    test_bit(DASD_FLAG_DEVICE_RO, &base->flags)) {\n\t\trc = -EROFS;\n\t\tgoto out_err;\n\t}\n\tif (bdev_is_partition(bdev)) {\n\t\tpr_warn(\"%s: The specified DASD is a partition and tracks cannot be released\\n\",\n\t\t\tdev_name(&base->cdev->dev));\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (copy_from_user(&rdata, argp, sizeof(rdata))) {\n\t\trc = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\trc = dasd_release_space(base, &rdata);\n\nout_err:\n\tdasd_put_device(base);\n\n\treturn rc;\n}\n\n \nstatic int\ndasd_ioctl_copy_pair_swap(struct block_device *bdev, void __user *argp)\n{\n\tstruct dasd_copypair_swap_data_t data;\n\tstruct dasd_device *device;\n\tint rc;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tdevice = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!device)\n\t\treturn -ENODEV;\n\n\tif (copy_from_user(&data, argp, sizeof(struct dasd_copypair_swap_data_t))) {\n\t\tdasd_put_device(device);\n\t\treturn -EFAULT;\n\t}\n\tif (memchr_inv(data.reserved, 0, sizeof(data.reserved))) {\n\t\tpr_warn(\"%s: Invalid swap data specified\\n\",\n\t\t\tdev_name(&device->cdev->dev));\n\t\tdasd_put_device(device);\n\t\treturn DASD_COPYPAIRSWAP_INVALID;\n\t}\n\tif (bdev_is_partition(bdev)) {\n\t\tpr_warn(\"%s: The specified DASD is a partition and cannot be swapped\\n\",\n\t\t\tdev_name(&device->cdev->dev));\n\t\tdasd_put_device(device);\n\t\treturn DASD_COPYPAIRSWAP_INVALID;\n\t}\n\tif (!device->copy) {\n\t\tpr_warn(\"%s: The specified DASD has no copy pair set up\\n\",\n\t\t\tdev_name(&device->cdev->dev));\n\t\tdasd_put_device(device);\n\t\treturn -ENODEV;\n\t}\n\tif (!device->discipline->copy_pair_swap) {\n\t\tdasd_put_device(device);\n\t\treturn -EOPNOTSUPP;\n\t}\n\trc = device->discipline->copy_pair_swap(device, data.primary,\n\t\t\t\t\t\tdata.secondary);\n\tdasd_put_device(device);\n\n\treturn rc;\n}\n\n#ifdef CONFIG_DASD_PROFILE\n \nstatic int dasd_ioctl_reset_profile(struct dasd_block *block)\n{\n\tdasd_profile_reset(&block->profile);\n\treturn 0;\n}\n\n \nstatic int dasd_ioctl_read_profile(struct dasd_block *block, void __user *argp)\n{\n\tstruct dasd_profile_info_t *data;\n\tint rc = 0;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&block->profile.lock);\n\tif (block->profile.data) {\n\t\tdata->dasd_io_reqs = block->profile.data->dasd_io_reqs;\n\t\tdata->dasd_io_sects = block->profile.data->dasd_io_sects;\n\t\tmemcpy(data->dasd_io_secs, block->profile.data->dasd_io_secs,\n\t\t       sizeof(data->dasd_io_secs));\n\t\tmemcpy(data->dasd_io_times, block->profile.data->dasd_io_times,\n\t\t       sizeof(data->dasd_io_times));\n\t\tmemcpy(data->dasd_io_timps, block->profile.data->dasd_io_timps,\n\t\t       sizeof(data->dasd_io_timps));\n\t\tmemcpy(data->dasd_io_time1, block->profile.data->dasd_io_time1,\n\t\t       sizeof(data->dasd_io_time1));\n\t\tmemcpy(data->dasd_io_time2, block->profile.data->dasd_io_time2,\n\t\t       sizeof(data->dasd_io_time2));\n\t\tmemcpy(data->dasd_io_time2ps,\n\t\t       block->profile.data->dasd_io_time2ps,\n\t\t       sizeof(data->dasd_io_time2ps));\n\t\tmemcpy(data->dasd_io_time3, block->profile.data->dasd_io_time3,\n\t\t       sizeof(data->dasd_io_time3));\n\t\tmemcpy(data->dasd_io_nr_req,\n\t\t       block->profile.data->dasd_io_nr_req,\n\t\t       sizeof(data->dasd_io_nr_req));\n\t\tspin_unlock_bh(&block->profile.lock);\n\t} else {\n\t\tspin_unlock_bh(&block->profile.lock);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (copy_to_user(argp, data, sizeof(*data)))\n\t\trc = -EFAULT;\nout:\n\tkfree(data);\n\treturn rc;\n}\n#else\nstatic int dasd_ioctl_reset_profile(struct dasd_block *block)\n{\n\treturn -ENOTTY;\n}\n\nstatic int dasd_ioctl_read_profile(struct dasd_block *block, void __user *argp)\n{\n\treturn -ENOTTY;\n}\n#endif\n\n \nstatic int __dasd_ioctl_information(struct dasd_block *block,\n\t\tstruct dasd_information2_t *dasd_info)\n{\n\tstruct subchannel_id sch_id;\n\tstruct ccw_dev_id dev_id;\n\tstruct dasd_device *base;\n\tstruct ccw_device *cdev;\n\tstruct list_head *l;\n\tunsigned long flags;\n\tint rc;\n\n\tbase = block->base;\n\tif (!base->discipline || !base->discipline->fill_info)\n\t\treturn -EINVAL;\n\n\trc = base->discipline->fill_info(base, dasd_info);\n\tif (rc)\n\t\treturn rc;\n\n\tcdev = base->cdev;\n\tccw_device_get_id(cdev, &dev_id);\n\tccw_device_get_schid(cdev, &sch_id);\n\n\tdasd_info->devno = dev_id.devno;\n\tdasd_info->schid = sch_id.sch_no;\n\tdasd_info->cu_type = cdev->id.cu_type;\n\tdasd_info->cu_model = cdev->id.cu_model;\n\tdasd_info->dev_type = cdev->id.dev_type;\n\tdasd_info->dev_model = cdev->id.dev_model;\n\tdasd_info->status = base->state;\n\t \n\tdasd_info->open_count = atomic_read(&block->open_count);\n\tif (!block->bdev)\n\t\tdasd_info->open_count++;\n\n\t \n\tif ((base->state < DASD_STATE_READY) ||\n\t    (dasd_check_blocksize(block->bp_block)))\n\t\tdasd_info->format = DASD_FORMAT_NONE;\n\n\tdasd_info->features |=\n\t\t((base->features & DASD_FEATURE_READONLY) != 0);\n\n\tmemcpy(dasd_info->type, base->discipline->name, 4);\n\n\tspin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);\n\tlist_for_each(l, &base->ccw_queue)\n\t\tdasd_info->chanq_len++;\n\tspin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);\n\treturn 0;\n}\n\nstatic int dasd_ioctl_information(struct dasd_block *block, void __user *argp,\n\t\tsize_t copy_size)\n{\n\tstruct dasd_information2_t *dasd_info;\n\tint error;\n\n\tdasd_info = kzalloc(sizeof(*dasd_info), GFP_KERNEL);\n\tif (!dasd_info)\n\t\treturn -ENOMEM;\n\n\terror = __dasd_ioctl_information(block, dasd_info);\n\tif (!error && copy_to_user(argp, dasd_info, copy_size))\n\t\terror = -EFAULT;\n\tkfree(dasd_info);\n\treturn error;\n}\n\n \nint dasd_set_read_only(struct block_device *bdev, bool ro)\n{\n\tstruct dasd_device *base;\n\tint rc;\n\n\t \n\tif (bdev_is_partition(bdev))\n\t\treturn 0;\n\n\tbase = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\tif (!ro && test_bit(DASD_FLAG_DEVICE_RO, &base->flags))\n\t\trc = -EROFS;\n\telse\n\t\trc = dasd_set_feature(base->cdev, DASD_FEATURE_READONLY, ro);\n\tdasd_put_device(base);\n\treturn rc;\n}\n\nstatic int dasd_ioctl_readall_cmb(struct dasd_block *block, unsigned int cmd,\n\t\t\t\t  struct cmbdata __user *argp)\n{\n\tsize_t size = _IOC_SIZE(cmd);\n\tstruct cmbdata data;\n\tint ret;\n\n\tret = cmf_readall(block->base->cdev, &data);\n\tif (!ret && copy_to_user(argp, &data, min(size, sizeof(*argp))))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\nint dasd_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct dasd_block *block;\n\tstruct dasd_device *base;\n\tvoid __user *argp;\n\tint rc;\n\n\tif (is_compat_task())\n\t\targp = compat_ptr(arg);\n\telse\n\t\targp = (void __user *)arg;\n\n\tif ((_IOC_DIR(cmd) != _IOC_NONE) && !arg)\n\t\treturn -EINVAL;\n\n\tbase = dasd_device_from_gendisk(bdev->bd_disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\tblock = base->block;\n\trc = 0;\n\tswitch (cmd) {\n\tcase BIODASDDISABLE:\n\t\trc = dasd_ioctl_disable(bdev);\n\t\tbreak;\n\tcase BIODASDENABLE:\n\t\trc = dasd_ioctl_enable(bdev);\n\t\tbreak;\n\tcase BIODASDQUIESCE:\n\t\trc = dasd_ioctl_quiesce(block);\n\t\tbreak;\n\tcase BIODASDRESUME:\n\t\trc = dasd_ioctl_resume(block);\n\t\tbreak;\n\tcase BIODASDABORTIO:\n\t\trc = dasd_ioctl_abortio(block);\n\t\tbreak;\n\tcase BIODASDALLOWIO:\n\t\trc = dasd_ioctl_allowio(block);\n\t\tbreak;\n\tcase BIODASDFMT:\n\t\trc = dasd_ioctl_format(bdev, argp);\n\t\tbreak;\n\tcase BIODASDCHECKFMT:\n\t\trc = dasd_ioctl_check_format(bdev, argp);\n\t\tbreak;\n\tcase BIODASDINFO:\n\t\trc = dasd_ioctl_information(block, argp,\n\t\t\t\tsizeof(struct dasd_information_t));\n\t\tbreak;\n\tcase BIODASDINFO2:\n\t\trc = dasd_ioctl_information(block, argp,\n\t\t\t\tsizeof(struct dasd_information2_t));\n\t\tbreak;\n\tcase BIODASDPRRD:\n\t\trc = dasd_ioctl_read_profile(block, argp);\n\t\tbreak;\n\tcase BIODASDPRRST:\n\t\trc = dasd_ioctl_reset_profile(block);\n\t\tbreak;\n\tcase DASDAPIVER:\n\t\trc = dasd_ioctl_api_version(argp);\n\t\tbreak;\n\tcase BIODASDCMFENABLE:\n\t\trc = enable_cmf(base->cdev);\n\t\tbreak;\n\tcase BIODASDCMFDISABLE:\n\t\trc = disable_cmf(base->cdev);\n\t\tbreak;\n\tcase BIODASDREADALLCMB:\n\t\trc = dasd_ioctl_readall_cmb(block, cmd, argp);\n\t\tbreak;\n\tcase BIODASDRAS:\n\t\trc = dasd_ioctl_release_space(bdev, argp);\n\t\tbreak;\n\tcase BIODASDCOPYPAIRSWAP:\n\t\trc = dasd_ioctl_copy_pair_swap(bdev, argp);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\trc = -ENOTTY;\n\t\tif (base->discipline->ioctl)\n\t\t\trc = base->discipline->ioctl(block, cmd, argp);\n\t}\n\tdasd_put_device(base);\n\treturn rc;\n}\n\n\n \nint dasd_biodasdinfo(struct gendisk *disk, struct dasd_information2_t *info)\n{\n\tstruct dasd_device *base;\n\tint error;\n\n\tif (disk->fops != &dasd_device_operations)\n\t\treturn -EINVAL;\n\n\tbase = dasd_device_from_gendisk(disk);\n\tif (!base)\n\t\treturn -ENODEV;\n\terror = __dasd_ioctl_information(base->block, info);\n\tdasd_put_device(base);\n\treturn error;\n}\n \nEXPORT_SYMBOL_GPL(dasd_biodasdinfo);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}