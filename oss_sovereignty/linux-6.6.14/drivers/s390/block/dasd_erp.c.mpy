{
  "module_name": "dasd_erp.c",
  "hash_id": "23f3f498504cf6ee4675b245e25283acfcf3b509541e52949c1a8198dc9897f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_erp.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd\"\n\n#include <linux/ctype.h>\n#include <linux/init.h>\n\n#include <asm/debug.h>\n#include <asm/ebcdic.h>\n#include <linux/uaccess.h>\n\n \n#define PRINTK_HEADER \"dasd_erp:\"\n\n#include \"dasd_int.h\"\n\nstruct dasd_ccw_req *\ndasd_alloc_erp_request(unsigned int magic, int cplength, int datasize,\n\t\t       struct dasd_device * device)\n{\n\tunsigned long flags;\n\tstruct dasd_ccw_req *cqr;\n\tchar *data;\n\tint size;\n\n\t \n\tBUG_ON(datasize > PAGE_SIZE ||\n\t       (cplength*sizeof(struct ccw1)) > PAGE_SIZE);\n\n\tsize = (sizeof(struct dasd_ccw_req) + 7L) & -8L;\n\tif (cplength > 0)\n\t\tsize += cplength * sizeof(struct ccw1);\n\tif (datasize > 0)\n\t\tsize += datasize;\n\tspin_lock_irqsave(&device->mem_lock, flags);\n\tcqr = (struct dasd_ccw_req *)\n\t\tdasd_alloc_chunk(&device->erp_chunks, size);\n\tspin_unlock_irqrestore(&device->mem_lock, flags);\n\tif (cqr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmemset(cqr, 0, sizeof(struct dasd_ccw_req));\n\tINIT_LIST_HEAD(&cqr->devlist);\n\tINIT_LIST_HEAD(&cqr->blocklist);\n\tdata = (char *) cqr + ((sizeof(struct dasd_ccw_req) + 7L) & -8L);\n\tcqr->cpaddr = NULL;\n\tif (cplength > 0) {\n\t\tcqr->cpaddr = (struct ccw1 *) data;\n\t\tdata += cplength*sizeof(struct ccw1);\n\t\tmemset(cqr->cpaddr, 0, cplength*sizeof(struct ccw1));\n\t}\n\tcqr->data = NULL;\n\tif (datasize > 0) {\n\t\tcqr->data = data;\n \t\tmemset(cqr->data, 0, datasize);\n\t}\n\tcqr->magic = magic;\n\tASCEBC((char *) &cqr->magic, 4);\n\tset_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tdasd_get_device(device);\n\treturn cqr;\n}\n\nvoid\ndasd_free_erp_request(struct dasd_ccw_req *cqr, struct dasd_device * device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&device->mem_lock, flags);\n\tdasd_free_chunk(&device->erp_chunks, cqr);\n\tspin_unlock_irqrestore(&device->mem_lock, flags);\n\tatomic_dec(&device->ref_count);\n}\n\n\n \nstruct dasd_ccw_req *\ndasd_default_erp_action(struct dasd_ccw_req *cqr)\n{\n\tstruct dasd_device *device;\n\n\tdevice = cqr->startdev;\n\n         \n        if (cqr->retries > 0) {\n\t\tDBF_DEV_EVENT(DBF_DEBUG, device,\n                             \"default ERP called (%i retries left)\",\n                             cqr->retries);\n\t\tif (!test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags))\n\t\t\tcqr->lpm = dasd_path_get_opm(device);\n\t\tcqr->status = DASD_CQR_FILLED;\n        } else {\n\t\tpr_err(\"%s: default ERP has run out of retries and failed\\n\",\n\t\t       dev_name(&device->cdev->dev));\n\t\tcqr->status = DASD_CQR_FAILED;\n\t\tcqr->stopclk = get_tod_clock();\n        }\n        return cqr;\n}\t\t\t\t \n\n \nstruct dasd_ccw_req *dasd_default_erp_postaction(struct dasd_ccw_req *cqr)\n{\n\tint success;\n\tunsigned long startclk, stopclk;\n\tstruct dasd_device *startdev;\n\n\tBUG_ON(cqr->refers == NULL || cqr->function == NULL);\n\n\tsuccess = cqr->status == DASD_CQR_DONE;\n\tstartclk = cqr->startclk;\n\tstopclk = cqr->stopclk;\n\tstartdev = cqr->startdev;\n\n\t \n\twhile (cqr->refers != NULL) {\n\t\tstruct dasd_ccw_req *refers;\n\n\t\trefers = cqr->refers;\n\t\t \n\t\tlist_del(&cqr->blocklist);\n\t\t \n\t\tdasd_free_erp_request(cqr, cqr->memdev);\n\t\tcqr = refers;\n\t}\n\n\t \n\tcqr->startclk = startclk;\n\tcqr->stopclk = stopclk;\n\tcqr->startdev = startdev;\n\tif (success)\n\t\tcqr->status = DASD_CQR_DONE;\n\telse {\n\t\tcqr->status = DASD_CQR_FAILED;\n\t\tcqr->stopclk = get_tod_clock();\n\t}\n\n\treturn cqr;\n\n}\t\t\t\t \n\nvoid\ndasd_log_sense(struct dasd_ccw_req *cqr, struct irb *irb)\n{\n\tstruct dasd_device *device;\n\n\tdevice = cqr->startdev;\n\tif (cqr->intrc == -ETIMEDOUT) {\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"A timeout error occurred for cqr %p\\n\", cqr);\n\t\treturn;\n\t}\n\tif (cqr->intrc == -ENOLINK) {\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"A transport error occurred for cqr %p\\n\", cqr);\n\t\treturn;\n\t}\n\t \n\tif (device->discipline && device->discipline->dump_sense)\n\t\tdevice->discipline->dump_sense(device, cqr, irb);\n}\n\nvoid\ndasd_log_sense_dbf(struct dasd_ccw_req *cqr, struct irb *irb)\n{\n\tstruct dasd_device *device;\n\n\tdevice = cqr->startdev;\n\t \n\tif (device->discipline && device->discipline->dump_sense_dbf)\n\t\tdevice->discipline->dump_sense_dbf(device, irb, \"log\");\n}\nEXPORT_SYMBOL(dasd_log_sense_dbf);\n\nEXPORT_SYMBOL(dasd_default_erp_action);\nEXPORT_SYMBOL(dasd_default_erp_postaction);\nEXPORT_SYMBOL(dasd_alloc_erp_request);\nEXPORT_SYMBOL(dasd_free_erp_request);\nEXPORT_SYMBOL(dasd_log_sense);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}