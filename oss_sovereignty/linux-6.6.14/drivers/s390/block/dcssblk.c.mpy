{
  "module_name": "dcssblk.c",
  "hash_id": "b84d46164f01cc28b97a238b6fc367d005352f47fc506f2ef0839e90a41b4dae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dcssblk.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dcssblk\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/pfn_t.h>\n#include <linux/uio.h>\n#include <linux/dax.h>\n#include <linux/io.h>\n#include <asm/extmem.h>\n\n#define DCSSBLK_NAME \"dcssblk\"\n#define DCSSBLK_MINORS_PER_DISK 1\n#define DCSSBLK_PARM_LEN 400\n#define DCSS_BUS_ID_SIZE 20\n\nstatic int dcssblk_open(struct gendisk *disk, blk_mode_t mode);\nstatic void dcssblk_release(struct gendisk *disk);\nstatic void dcssblk_submit_bio(struct bio *bio);\nstatic long dcssblk_dax_direct_access(struct dax_device *dax_dev, pgoff_t pgoff,\n\t\tlong nr_pages, enum dax_access_mode mode, void **kaddr,\n\t\tpfn_t *pfn);\n\nstatic char dcssblk_segments[DCSSBLK_PARM_LEN] = \"\\0\";\n\nstatic int dcssblk_major;\nstatic const struct block_device_operations dcssblk_devops = {\n\t.owner   \t= THIS_MODULE,\n\t.submit_bio\t= dcssblk_submit_bio,\n\t.open    \t= dcssblk_open,\n\t.release \t= dcssblk_release,\n};\n\nstatic int dcssblk_dax_zero_page_range(struct dax_device *dax_dev,\n\t\t\t\t       pgoff_t pgoff, size_t nr_pages)\n{\n\tlong rc;\n\tvoid *kaddr;\n\n\trc = dax_direct_access(dax_dev, pgoff, nr_pages, DAX_ACCESS,\n\t\t\t&kaddr, NULL);\n\tif (rc < 0)\n\t\treturn dax_mem2blk_err(rc);\n\n\tmemset(kaddr, 0, nr_pages << PAGE_SHIFT);\n\tdax_flush(dax_dev, kaddr, nr_pages << PAGE_SHIFT);\n\treturn 0;\n}\n\nstatic const struct dax_operations dcssblk_dax_ops = {\n\t.direct_access = dcssblk_dax_direct_access,\n\t.zero_page_range = dcssblk_dax_zero_page_range,\n};\n\nstruct dcssblk_dev_info {\n\tstruct list_head lh;\n\tstruct device dev;\n\tchar segment_name[DCSS_BUS_ID_SIZE];\n\tatomic_t use_count;\n\tstruct gendisk *gd;\n\tunsigned long start;\n\tunsigned long end;\n\tint segment_type;\n\tunsigned char save_pending;\n\tunsigned char is_shared;\n\tint num_of_segments;\n\tstruct list_head seg_list;\n\tstruct dax_device *dax_dev;\n};\n\nstruct segment_info {\n\tstruct list_head lh;\n\tchar segment_name[DCSS_BUS_ID_SIZE];\n\tunsigned long start;\n\tunsigned long end;\n\tint segment_type;\n};\n\nstatic ssize_t dcssblk_add_store(struct device * dev, struct device_attribute *attr, const char * buf,\n\t\t\t\t  size_t count);\nstatic ssize_t dcssblk_remove_store(struct device * dev, struct device_attribute *attr, const char * buf,\n\t\t\t\t  size_t count);\n\nstatic DEVICE_ATTR(add, S_IWUSR, NULL, dcssblk_add_store);\nstatic DEVICE_ATTR(remove, S_IWUSR, NULL, dcssblk_remove_store);\n\nstatic struct device *dcssblk_root_dev;\n\nstatic LIST_HEAD(dcssblk_devices);\nstatic struct rw_semaphore dcssblk_devices_sem;\n\n \nstatic void\ndcssblk_release_segment(struct device *dev)\n{\n\tstruct dcssblk_dev_info *dev_info;\n\tstruct segment_info *entry, *temp;\n\n\tdev_info = container_of(dev, struct dcssblk_dev_info, dev);\n\tlist_for_each_entry_safe(entry, temp, &dev_info->seg_list, lh) {\n\t\tlist_del(&entry->lh);\n\t\tkfree(entry);\n\t}\n\tkfree(dev_info);\n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic int\ndcssblk_assign_free_minor(struct dcssblk_dev_info *dev_info)\n{\n\tint minor, found;\n\tstruct dcssblk_dev_info *entry;\n\n\tif (dev_info == NULL)\n\t\treturn -EINVAL;\n\tfor (minor = 0; minor < (1<<MINORBITS); minor++) {\n\t\tfound = 0;\n\t\t\n\t\tlist_for_each_entry(entry, &dcssblk_devices, lh)\n\t\t\tif (minor == entry->gd->first_minor)\n\t\t\t\tfound++;\n\t\tif (!found) break; \n\t}\n\tif (found)\n\t\treturn -EBUSY;\n\tdev_info->gd->first_minor = minor;\n\treturn 0;\n}\n\n \nstatic struct dcssblk_dev_info *\ndcssblk_get_device_by_name(char *name)\n{\n\tstruct dcssblk_dev_info *entry;\n\n\tlist_for_each_entry(entry, &dcssblk_devices, lh) {\n\t\tif (!strcmp(name, entry->segment_name)) {\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic struct segment_info *\ndcssblk_get_segment_by_name(char *name)\n{\n\tstruct dcssblk_dev_info *dev_info;\n\tstruct segment_info *entry;\n\n\tlist_for_each_entry(dev_info, &dcssblk_devices, lh) {\n\t\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\t\tif (!strcmp(name, entry->segment_name))\n\t\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic unsigned long\ndcssblk_find_highest_addr(struct dcssblk_dev_info *dev_info)\n{\n\tunsigned long highest_addr;\n\tstruct segment_info *entry;\n\n\thighest_addr = 0;\n\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\tif (highest_addr < entry->end)\n\t\t\thighest_addr = entry->end;\n\t}\n\treturn highest_addr;\n}\n\n \nstatic unsigned long\ndcssblk_find_lowest_addr(struct dcssblk_dev_info *dev_info)\n{\n\tint set_first;\n\tunsigned long lowest_addr;\n\tstruct segment_info *entry;\n\n\tset_first = 0;\n\tlowest_addr = 0;\n\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\tif (set_first == 0) {\n\t\t\tlowest_addr = entry->start;\n\t\t\tset_first = 1;\n\t\t} else {\n\t\t\tif (lowest_addr > entry->start)\n\t\t\t\tlowest_addr = entry->start;\n\t\t}\n\t}\n\treturn lowest_addr;\n}\n\n \nstatic int\ndcssblk_is_continuous(struct dcssblk_dev_info *dev_info)\n{\n\tint i, j, rc;\n\tstruct segment_info *sort_list, *entry, temp;\n\n\tif (dev_info->num_of_segments <= 1)\n\t\treturn 0;\n\n\tsort_list = kcalloc(dev_info->num_of_segments,\n\t\t\t    sizeof(struct segment_info),\n\t\t\t    GFP_KERNEL);\n\tif (sort_list == NULL)\n\t\treturn -ENOMEM;\n\ti = 0;\n\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\tmemcpy(&sort_list[i], entry, sizeof(struct segment_info));\n\t\ti++;\n\t}\n\n\t \n\tfor (i = 0; i < dev_info->num_of_segments; i++)\n\t\tfor (j = 0; j < dev_info->num_of_segments; j++)\n\t\t\tif (sort_list[j].start > sort_list[i].start) {\n\t\t\t\tmemcpy(&temp, &sort_list[i],\n\t\t\t\t\tsizeof(struct segment_info));\n\t\t\t\tmemcpy(&sort_list[i], &sort_list[j],\n\t\t\t\t\tsizeof(struct segment_info));\n\t\t\t\tmemcpy(&sort_list[j], &temp,\n\t\t\t\t\tsizeof(struct segment_info));\n\t\t\t}\n\n\t \n\tfor (i = 0; i < dev_info->num_of_segments - 1; i++) {\n\t\tif ((sort_list[i].end + 1) != sort_list[i+1].start) {\n\t\t\tpr_err(\"Adjacent DCSSs %s and %s are not \"\n\t\t\t       \"contiguous\\n\", sort_list[i].segment_name,\n\t\t\t       sort_list[i+1].segment_name);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (sort_list[i].segment_type != sort_list[i+1].segment_type) {\n\t\t\tif (!(sort_list[i].segment_type & SEGMENT_EXCLUSIVE) ||\n\t\t\t\t(sort_list[i].segment_type == SEG_TYPE_ER) ||\n\t\t\t\t!(sort_list[i+1].segment_type &\n\t\t\t\tSEGMENT_EXCLUSIVE) ||\n\t\t\t\t(sort_list[i+1].segment_type == SEG_TYPE_ER)) {\n\t\t\t\tpr_err(\"DCSS %s and DCSS %s have \"\n\t\t\t\t       \"incompatible types\\n\",\n\t\t\t\t       sort_list[i].segment_name,\n\t\t\t\t       sort_list[i+1].segment_name);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout:\n\tkfree(sort_list);\n\treturn rc;\n}\n\n \nstatic int\ndcssblk_load_segment(char *name, struct segment_info **seg_info)\n{\n\tint rc;\n\n\t \n\tdown_read(&dcssblk_devices_sem);\n\t*seg_info = dcssblk_get_segment_by_name(name);\n\tup_read(&dcssblk_devices_sem);\n\tif (*seg_info != NULL)\n\t\treturn -EEXIST;\n\n\t \n\t*seg_info = kzalloc(sizeof(struct segment_info), GFP_KERNEL);\n\tif (*seg_info == NULL)\n\t\treturn -ENOMEM;\n\n\tstrcpy((*seg_info)->segment_name, name);\n\n\t \n\trc = segment_load(name, SEGMENT_SHARED,\n\t\t\t&(*seg_info)->start, &(*seg_info)->end);\n\tif (rc < 0) {\n\t\tsegment_warning(rc, (*seg_info)->segment_name);\n\t\tkfree(*seg_info);\n\t} else {\n\t\tINIT_LIST_HEAD(&(*seg_info)->lh);\n\t\t(*seg_info)->segment_type = rc;\n\t}\n\treturn rc;\n}\n\n \nstatic ssize_t\ndcssblk_shared_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dcssblk_dev_info *dev_info;\n\n\tdev_info = container_of(dev, struct dcssblk_dev_info, dev);\n\treturn sprintf(buf, dev_info->is_shared ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t\ndcssblk_shared_store(struct device *dev, struct device_attribute *attr, const char *inbuf, size_t count)\n{\n\tstruct dcssblk_dev_info *dev_info;\n\tstruct segment_info *entry, *temp;\n\tint rc;\n\n\tif ((count > 1) && (inbuf[1] != '\\n') && (inbuf[1] != '\\0'))\n\t\treturn -EINVAL;\n\tdown_write(&dcssblk_devices_sem);\n\tdev_info = container_of(dev, struct dcssblk_dev_info, dev);\n\tif (atomic_read(&dev_info->use_count)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (inbuf[0] == '1') {\n\t\t \n\t\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\t\trc = segment_modify_shared(entry->segment_name,\n\t\t\t\t\t\tSEGMENT_SHARED);\n\t\t\tif (rc < 0) {\n\t\t\t\tBUG_ON(rc == -EINVAL);\n\t\t\t\tif (rc != -EAGAIN)\n\t\t\t\t\tgoto removeseg;\n\t\t\t}\n\t\t}\n\t\tdev_info->is_shared = 1;\n\t\tswitch (dev_info->segment_type) {\n\t\tcase SEG_TYPE_SR:\n\t\tcase SEG_TYPE_ER:\n\t\tcase SEG_TYPE_SC:\n\t\t\tset_disk_ro(dev_info->gd, 1);\n\t\t}\n\t} else if (inbuf[0] == '0') {\n\t\t \n\t\tif (dev_info->segment_type == SEG_TYPE_SC) {\n\t\t\tpr_err(\"DCSS %s is of type SC and cannot be \"\n\t\t\t       \"loaded as exclusive-writable\\n\",\n\t\t\t       dev_info->segment_name);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\t\trc = segment_modify_shared(entry->segment_name,\n\t\t\t\t\t\t   SEGMENT_EXCLUSIVE);\n\t\t\tif (rc < 0) {\n\t\t\t\tBUG_ON(rc == -EINVAL);\n\t\t\t\tif (rc != -EAGAIN)\n\t\t\t\t\tgoto removeseg;\n\t\t\t}\n\t\t}\n\t\tdev_info->is_shared = 0;\n\t\tset_disk_ro(dev_info->gd, 0);\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = count;\n\tgoto out;\n\nremoveseg:\n\tpr_err(\"DCSS device %s is removed after a failed access mode \"\n\t       \"change\\n\", dev_info->segment_name);\n\ttemp = entry;\n\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\tif (entry != temp)\n\t\t\tsegment_unload(entry->segment_name);\n\t}\n\tlist_del(&dev_info->lh);\n\tup_write(&dcssblk_devices_sem);\n\n\tdax_remove_host(dev_info->gd);\n\tkill_dax(dev_info->dax_dev);\n\tput_dax(dev_info->dax_dev);\n\tdel_gendisk(dev_info->gd);\n\tput_disk(dev_info->gd);\n\n\tif (device_remove_file_self(dev, attr)) {\n\t\tdevice_unregister(dev);\n\t\tput_device(dev);\n\t}\n\treturn rc;\nout:\n\tup_write(&dcssblk_devices_sem);\n\treturn rc;\n}\nstatic DEVICE_ATTR(shared, S_IWUSR | S_IRUSR, dcssblk_shared_show,\n\t\t   dcssblk_shared_store);\n\n \nstatic ssize_t\ndcssblk_save_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dcssblk_dev_info *dev_info;\n\n\tdev_info = container_of(dev, struct dcssblk_dev_info, dev);\n\treturn sprintf(buf, dev_info->save_pending ? \"1\\n\" : \"0\\n\");\n}\n\nstatic ssize_t\ndcssblk_save_store(struct device *dev, struct device_attribute *attr, const char *inbuf, size_t count)\n{\n\tstruct dcssblk_dev_info *dev_info;\n\tstruct segment_info *entry;\n\n\tif ((count > 1) && (inbuf[1] != '\\n') && (inbuf[1] != '\\0'))\n\t\treturn -EINVAL;\n\tdev_info = container_of(dev, struct dcssblk_dev_info, dev);\n\n\tdown_write(&dcssblk_devices_sem);\n\tif (inbuf[0] == '1') {\n\t\tif (atomic_read(&dev_info->use_count) == 0) {\n\t\t\t\n\t\t\tpr_info(\"All DCSSs that map to device %s are \"\n\t\t\t\t\"saved\\n\", dev_info->segment_name);\n\t\t\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\t\t\tif (entry->segment_type == SEG_TYPE_EN ||\n\t\t\t\t    entry->segment_type == SEG_TYPE_SN)\n\t\t\t\t\tpr_warn(\"DCSS %s is of type SN or EN\"\n\t\t\t\t\t\t\" and cannot be saved\\n\",\n\t\t\t\t\t\tentry->segment_name);\n\t\t\t\telse\n\t\t\t\t\tsegment_save(entry->segment_name);\n\t\t\t}\n\t\t}  else {\n\t\t\t\n\t\t\t\n\t\t\tpr_info(\"Device %s is in use, its DCSSs will be \"\n\t\t\t\t\"saved when it becomes idle\\n\",\n\t\t\t\tdev_info->segment_name);\n\t\t\tdev_info->save_pending = 1;\n\t\t}\n\t} else if (inbuf[0] == '0') {\n\t\tif (dev_info->save_pending) {\n\t\t\t\n\t\t\t\n\t\t\tdev_info->save_pending = 0;\n\t\t\tpr_info(\"A pending save request for device %s \"\n\t\t\t\t\"has been canceled\\n\",\n\t\t\t\tdev_info->segment_name);\n\t\t}\n\t} else {\n\t\tup_write(&dcssblk_devices_sem);\n\t\treturn -EINVAL;\n\t}\n\tup_write(&dcssblk_devices_sem);\n\treturn count;\n}\nstatic DEVICE_ATTR(save, S_IWUSR | S_IRUSR, dcssblk_save_show,\n\t\t   dcssblk_save_store);\n\n \nstatic ssize_t\ndcssblk_seglist_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint i;\n\n\tstruct dcssblk_dev_info *dev_info;\n\tstruct segment_info *entry;\n\n\tdown_read(&dcssblk_devices_sem);\n\tdev_info = container_of(dev, struct dcssblk_dev_info, dev);\n\ti = 0;\n\tbuf[0] = '\\0';\n\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\tstrcpy(&buf[i], entry->segment_name);\n\t\ti += strlen(entry->segment_name);\n\t\tbuf[i] = '\\n';\n\t\ti++;\n\t}\n\tup_read(&dcssblk_devices_sem);\n\treturn i;\n}\nstatic DEVICE_ATTR(seglist, S_IRUSR, dcssblk_seglist_show, NULL);\n\nstatic struct attribute *dcssblk_dev_attrs[] = {\n\t&dev_attr_shared.attr,\n\t&dev_attr_save.attr,\n\t&dev_attr_seglist.attr,\n\tNULL,\n};\nstatic struct attribute_group dcssblk_dev_attr_group = {\n\t.attrs = dcssblk_dev_attrs,\n};\nstatic const struct attribute_group *dcssblk_dev_attr_groups[] = {\n\t&dcssblk_dev_attr_group,\n\tNULL,\n};\n\n \nstatic ssize_t\ndcssblk_add_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tint rc, i, j, num_of_segments;\n\tstruct dcssblk_dev_info *dev_info;\n\tstruct segment_info *seg_info, *temp;\n\tchar *local_buf;\n\tunsigned long seg_byte_size;\n\n\tdev_info = NULL;\n\tseg_info = NULL;\n\tif (dev != dcssblk_root_dev) {\n\t\trc = -EINVAL;\n\t\tgoto out_nobuf;\n\t}\n\tif ((count < 1) || (buf[0] == '\\0') || (buf[0] == '\\n')) {\n\t\trc = -ENAMETOOLONG;\n\t\tgoto out_nobuf;\n\t}\n\n\tlocal_buf = kmalloc(count + 1, GFP_KERNEL);\n\tif (local_buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_nobuf;\n\t}\n\n\t \n\tnum_of_segments = 0;\n\tfor (i = 0; (i < count && (buf[i] != '\\0') && (buf[i] != '\\n')); i++) {\n\t\tfor (j = i; j < count &&\n\t\t\t(buf[j] != ':') &&\n\t\t\t(buf[j] != '\\0') &&\n\t\t\t(buf[j] != '\\n'); j++) {\n\t\t\tlocal_buf[j-i] = toupper(buf[j]);\n\t\t}\n\t\tlocal_buf[j-i] = '\\0';\n\t\tif (((j - i) == 0) || ((j - i) > 8)) {\n\t\t\trc = -ENAMETOOLONG;\n\t\t\tgoto seg_list_del;\n\t\t}\n\n\t\trc = dcssblk_load_segment(local_buf, &seg_info);\n\t\tif (rc < 0)\n\t\t\tgoto seg_list_del;\n\t\t \n\t\tif (num_of_segments == 0) {\n\t\t\tdev_info = kzalloc(sizeof(struct dcssblk_dev_info),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (dev_info == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrcpy(dev_info->segment_name, local_buf);\n\t\t\tdev_info->segment_type = seg_info->segment_type;\n\t\t\tINIT_LIST_HEAD(&dev_info->seg_list);\n\t\t}\n\t\tlist_add_tail(&seg_info->lh, &dev_info->seg_list);\n\t\tnum_of_segments++;\n\t\ti = j;\n\n\t\tif ((buf[j] == '\\0') || (buf[j] == '\\n'))\n\t\t\tbreak;\n\t}\n\n\t \n\tif ((i > 0) && (buf[i-1] == ':')) {\n\t\trc = -ENAMETOOLONG;\n\t\tgoto seg_list_del;\n\t}\n\tstrscpy(local_buf, buf, i + 1);\n\tdev_info->num_of_segments = num_of_segments;\n\trc = dcssblk_is_continuous(dev_info);\n\tif (rc < 0)\n\t\tgoto seg_list_del;\n\n\tdev_info->start = dcssblk_find_lowest_addr(dev_info);\n\tdev_info->end = dcssblk_find_highest_addr(dev_info);\n\n\tdev_set_name(&dev_info->dev, \"%s\", dev_info->segment_name);\n\tdev_info->dev.release = dcssblk_release_segment;\n\tdev_info->dev.groups = dcssblk_dev_attr_groups;\n\tINIT_LIST_HEAD(&dev_info->lh);\n\tdev_info->gd = blk_alloc_disk(NUMA_NO_NODE);\n\tif (dev_info->gd == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto seg_list_del;\n\t}\n\tdev_info->gd->major = dcssblk_major;\n\tdev_info->gd->minors = DCSSBLK_MINORS_PER_DISK;\n\tdev_info->gd->fops = &dcssblk_devops;\n\tdev_info->gd->private_data = dev_info;\n\tdev_info->gd->flags |= GENHD_FL_NO_PART;\n\tblk_queue_logical_block_size(dev_info->gd->queue, 4096);\n\tblk_queue_flag_set(QUEUE_FLAG_DAX, dev_info->gd->queue);\n\n\tseg_byte_size = (dev_info->end - dev_info->start + 1);\n\tset_capacity(dev_info->gd, seg_byte_size >> 9); \n\tpr_info(\"Loaded %s with total size %lu bytes and capacity %lu \"\n\t\t\"sectors\\n\", local_buf, seg_byte_size, seg_byte_size >> 9);\n\n\tdev_info->save_pending = 0;\n\tdev_info->is_shared = 1;\n\tdev_info->dev.parent = dcssblk_root_dev;\n\n\t \n\tdown_write(&dcssblk_devices_sem);\n\tif (dcssblk_get_segment_by_name(local_buf)) {\n\t\trc = -EEXIST;\n\t\tgoto release_gd;\n\t}\n\trc = dcssblk_assign_free_minor(dev_info);\n\tif (rc)\n\t\tgoto release_gd;\n\tsprintf(dev_info->gd->disk_name, \"dcssblk%d\",\n\t\tdev_info->gd->first_minor);\n\tlist_add_tail(&dev_info->lh, &dcssblk_devices);\n\n\tif (!try_module_get(THIS_MODULE)) {\n\t\trc = -ENODEV;\n\t\tgoto dev_list_del;\n\t}\n\t \n\trc = device_register(&dev_info->dev);\n\tif (rc)\n\t\tgoto put_dev;\n\n\tdev_info->dax_dev = alloc_dax(dev_info, &dcssblk_dax_ops);\n\tif (IS_ERR(dev_info->dax_dev)) {\n\t\trc = PTR_ERR(dev_info->dax_dev);\n\t\tdev_info->dax_dev = NULL;\n\t\tgoto put_dev;\n\t}\n\tset_dax_synchronous(dev_info->dax_dev);\n\trc = dax_add_host(dev_info->dax_dev, dev_info->gd);\n\tif (rc)\n\t\tgoto out_dax;\n\n\tget_device(&dev_info->dev);\n\trc = device_add_disk(&dev_info->dev, dev_info->gd, NULL);\n\tif (rc)\n\t\tgoto out_dax_host;\n\n\tswitch (dev_info->segment_type) {\n\t\tcase SEG_TYPE_SR:\n\t\tcase SEG_TYPE_ER:\n\t\tcase SEG_TYPE_SC:\n\t\t\tset_disk_ro(dev_info->gd,1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tset_disk_ro(dev_info->gd,0);\n\t\t\tbreak;\n\t}\n\tup_write(&dcssblk_devices_sem);\n\trc = count;\n\tgoto out;\n\nout_dax_host:\n\tput_device(&dev_info->dev);\n\tdax_remove_host(dev_info->gd);\nout_dax:\n\tkill_dax(dev_info->dax_dev);\n\tput_dax(dev_info->dax_dev);\nput_dev:\n\tlist_del(&dev_info->lh);\n\tput_disk(dev_info->gd);\n\tlist_for_each_entry(seg_info, &dev_info->seg_list, lh) {\n\t\tsegment_unload(seg_info->segment_name);\n\t}\n\tput_device(&dev_info->dev);\n\tup_write(&dcssblk_devices_sem);\n\tgoto out;\ndev_list_del:\n\tlist_del(&dev_info->lh);\nrelease_gd:\n\tput_disk(dev_info->gd);\n\tup_write(&dcssblk_devices_sem);\nseg_list_del:\n\tif (dev_info == NULL)\n\t\tgoto out;\n\tlist_for_each_entry_safe(seg_info, temp, &dev_info->seg_list, lh) {\n\t\tlist_del(&seg_info->lh);\n\t\tsegment_unload(seg_info->segment_name);\n\t\tkfree(seg_info);\n\t}\n\tkfree(dev_info);\nout:\n\tkfree(local_buf);\nout_nobuf:\n\treturn rc;\n}\n\n \nstatic ssize_t\ndcssblk_remove_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct dcssblk_dev_info *dev_info;\n\tstruct segment_info *entry;\n\tint rc, i;\n\tchar *local_buf;\n\n\tif (dev != dcssblk_root_dev) {\n\t\treturn -EINVAL;\n\t}\n\tlocal_buf = kmalloc(count + 1, GFP_KERNEL);\n\tif (local_buf == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\t \n\tfor (i = 0; (i < count && (*(buf+i)!='\\0') && (*(buf+i)!='\\n')); i++) {\n\t\tlocal_buf[i] = toupper(buf[i]);\n\t}\n\tlocal_buf[i] = '\\0';\n\tif ((i == 0) || (i > 8)) {\n\t\trc = -ENAMETOOLONG;\n\t\tgoto out_buf;\n\t}\n\n\tdown_write(&dcssblk_devices_sem);\n\tdev_info = dcssblk_get_device_by_name(local_buf);\n\tif (dev_info == NULL) {\n\t\tup_write(&dcssblk_devices_sem);\n\t\tpr_warn(\"Device %s cannot be removed because it is not a known device\\n\",\n\t\t\tlocal_buf);\n\t\trc = -ENODEV;\n\t\tgoto out_buf;\n\t}\n\tif (atomic_read(&dev_info->use_count) != 0) {\n\t\tup_write(&dcssblk_devices_sem);\n\t\tpr_warn(\"Device %s cannot be removed while it is in use\\n\",\n\t\t\tlocal_buf);\n\t\trc = -EBUSY;\n\t\tgoto out_buf;\n\t}\n\n\tlist_del(&dev_info->lh);\n\t \n\tlist_for_each_entry(entry, &dev_info->seg_list, lh)\n\t\tsegment_unload(entry->segment_name);\n\tup_write(&dcssblk_devices_sem);\n\n\tdax_remove_host(dev_info->gd);\n\tkill_dax(dev_info->dax_dev);\n\tput_dax(dev_info->dax_dev);\n\tdel_gendisk(dev_info->gd);\n\tput_disk(dev_info->gd);\n\n\tdevice_unregister(&dev_info->dev);\n\tput_device(&dev_info->dev);\n\n\trc = count;\nout_buf:\n\tkfree(local_buf);\n\treturn rc;\n}\n\nstatic int\ndcssblk_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct dcssblk_dev_info *dev_info = disk->private_data;\n\tint rc;\n\n\tif (NULL == dev_info) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\tatomic_inc(&dev_info->use_count);\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic void\ndcssblk_release(struct gendisk *disk)\n{\n\tstruct dcssblk_dev_info *dev_info = disk->private_data;\n\tstruct segment_info *entry;\n\n\tif (!dev_info) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tdown_write(&dcssblk_devices_sem);\n\tif (atomic_dec_and_test(&dev_info->use_count)\n\t    && (dev_info->save_pending)) {\n\t\tpr_info(\"Device %s has become idle and is being saved \"\n\t\t\t\"now\\n\", dev_info->segment_name);\n\t\tlist_for_each_entry(entry, &dev_info->seg_list, lh) {\n\t\t\tif (entry->segment_type == SEG_TYPE_EN ||\n\t\t\t    entry->segment_type == SEG_TYPE_SN)\n\t\t\t\tpr_warn(\"DCSS %s is of type SN or EN and cannot\"\n\t\t\t\t\t\" be saved\\n\", entry->segment_name);\n\t\t\telse\n\t\t\t\tsegment_save(entry->segment_name);\n\t\t}\n\t\tdev_info->save_pending = 0;\n\t}\n\tup_write(&dcssblk_devices_sem);\n}\n\nstatic void\ndcssblk_submit_bio(struct bio *bio)\n{\n\tstruct dcssblk_dev_info *dev_info;\n\tstruct bio_vec bvec;\n\tstruct bvec_iter iter;\n\tunsigned long index;\n\tvoid *page_addr;\n\tunsigned long source_addr;\n\tunsigned long bytes_done;\n\n\tbytes_done = 0;\n\tdev_info = bio->bi_bdev->bd_disk->private_data;\n\tif (dev_info == NULL)\n\t\tgoto fail;\n\tif (!IS_ALIGNED(bio->bi_iter.bi_sector, 8) ||\n\t    !IS_ALIGNED(bio->bi_iter.bi_size, PAGE_SIZE))\n\t\t \n\t\tgoto fail;\n\t \n\tif (dev_info->is_shared) {\n\t\tswitch (dev_info->segment_type) {\n\t\tcase SEG_TYPE_SR:\n\t\tcase SEG_TYPE_ER:\n\t\tcase SEG_TYPE_SC:\n\t\t\t \n\t\t\tif (bio_data_dir(bio) == WRITE) {\n\t\t\t\tpr_warn(\"Writing to %s failed because it is a read-only device\\n\",\n\t\t\t\t\tdev_name(&dev_info->dev));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tindex = (bio->bi_iter.bi_sector >> 3);\n\tbio_for_each_segment(bvec, bio, iter) {\n\t\tpage_addr = bvec_virt(&bvec);\n\t\tsource_addr = dev_info->start + (index<<12) + bytes_done;\n\t\tif (unlikely(!IS_ALIGNED((unsigned long)page_addr, PAGE_SIZE) ||\n\t\t\t     !IS_ALIGNED(bvec.bv_len, PAGE_SIZE)))\n\t\t\t\n\t\t\tgoto fail;\n\t\tif (bio_data_dir(bio) == READ)\n\t\t\tmemcpy(page_addr, __va(source_addr), bvec.bv_len);\n\t\telse\n\t\t\tmemcpy(__va(source_addr), page_addr, bvec.bv_len);\n\t\tbytes_done += bvec.bv_len;\n\t}\n\tbio_endio(bio);\n\treturn;\nfail:\n\tbio_io_error(bio);\n}\n\nstatic long\n__dcssblk_direct_access(struct dcssblk_dev_info *dev_info, pgoff_t pgoff,\n\t\tlong nr_pages, void **kaddr, pfn_t *pfn)\n{\n\tresource_size_t offset = pgoff * PAGE_SIZE;\n\tunsigned long dev_sz;\n\n\tdev_sz = dev_info->end - dev_info->start + 1;\n\tif (kaddr)\n\t\t*kaddr = (void *) dev_info->start + offset;\n\tif (pfn)\n\t\t*pfn = __pfn_to_pfn_t(PFN_DOWN(dev_info->start + offset),\n\t\t\t\tPFN_DEV|PFN_SPECIAL);\n\n\treturn (dev_sz - offset) / PAGE_SIZE;\n}\n\nstatic long\ndcssblk_dax_direct_access(struct dax_device *dax_dev, pgoff_t pgoff,\n\t\tlong nr_pages, enum dax_access_mode mode, void **kaddr,\n\t\tpfn_t *pfn)\n{\n\tstruct dcssblk_dev_info *dev_info = dax_get_private(dax_dev);\n\n\treturn __dcssblk_direct_access(dev_info, pgoff, nr_pages, kaddr, pfn);\n}\n\nstatic void\ndcssblk_check_params(void)\n{\n\tint rc, i, j, k;\n\tchar buf[DCSSBLK_PARM_LEN + 1];\n\tstruct dcssblk_dev_info *dev_info;\n\n\tfor (i = 0; (i < DCSSBLK_PARM_LEN) && (dcssblk_segments[i] != '\\0');\n\t     i++) {\n\t\tfor (j = i; (j < DCSSBLK_PARM_LEN) &&\n\t\t\t    (dcssblk_segments[j] != ',')  &&\n\t\t\t    (dcssblk_segments[j] != '\\0') &&\n\t\t\t    (dcssblk_segments[j] != '('); j++)\n\t\t{\n\t\t\tbuf[j-i] = dcssblk_segments[j];\n\t\t}\n\t\tbuf[j-i] = '\\0';\n\t\trc = dcssblk_add_store(dcssblk_root_dev, NULL, buf, j-i);\n\t\tif ((rc >= 0) && (dcssblk_segments[j] == '(')) {\n\t\t\tfor (k = 0; (buf[k] != ':') && (buf[k] != '\\0'); k++)\n\t\t\t\tbuf[k] = toupper(buf[k]);\n\t\t\tbuf[k] = '\\0';\n\t\t\tif (!strncmp(&dcssblk_segments[j], \"(local)\", 7)) {\n\t\t\t\tdown_read(&dcssblk_devices_sem);\n\t\t\t\tdev_info = dcssblk_get_device_by_name(buf);\n\t\t\t\tup_read(&dcssblk_devices_sem);\n\t\t\t\tif (dev_info)\n\t\t\t\t\tdcssblk_shared_store(&dev_info->dev,\n\t\t\t\t\t\t\t     NULL, \"0\\n\", 2);\n\t\t\t}\n\t\t}\n\t\twhile ((dcssblk_segments[j] != ',') &&\n\t\t       (dcssblk_segments[j] != '\\0'))\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tif (dcssblk_segments[j] == '\\0')\n\t\t\tbreak;\n\t\ti = j;\n\t}\n}\n\n \nstatic void __exit\ndcssblk_exit(void)\n{\n\troot_device_unregister(dcssblk_root_dev);\n\tunregister_blkdev(dcssblk_major, DCSSBLK_NAME);\n}\n\nstatic int __init\ndcssblk_init(void)\n{\n\tint rc;\n\n\tdcssblk_root_dev = root_device_register(\"dcssblk\");\n\tif (IS_ERR(dcssblk_root_dev))\n\t\treturn PTR_ERR(dcssblk_root_dev);\n\trc = device_create_file(dcssblk_root_dev, &dev_attr_add);\n\tif (rc)\n\t\tgoto out_root;\n\trc = device_create_file(dcssblk_root_dev, &dev_attr_remove);\n\tif (rc)\n\t\tgoto out_root;\n\trc = register_blkdev(0, DCSSBLK_NAME);\n\tif (rc < 0)\n\t\tgoto out_root;\n\tdcssblk_major = rc;\n\tinit_rwsem(&dcssblk_devices_sem);\n\n\tdcssblk_check_params();\n\treturn 0;\n\nout_root:\n\troot_device_unregister(dcssblk_root_dev);\n\n\treturn rc;\n}\n\nmodule_init(dcssblk_init);\nmodule_exit(dcssblk_exit);\n\nmodule_param_string(segments, dcssblk_segments, DCSSBLK_PARM_LEN, 0444);\nMODULE_PARM_DESC(segments, \"Name of DCSS segment(s) to be loaded, \"\n\t\t \"comma-separated list, names in each set separated \"\n\t\t \"by commas are separated by colons, each set contains \"\n\t\t \"names of contiguous segments and each name max. 8 chars.\\n\"\n\t\t \"Adding \\\"(local)\\\" to the end of each set equals echoing 0 \"\n\t\t \"to /sys/devices/dcssblk/<device name>/shared after loading \"\n\t\t \"the contiguous segments - \\n\"\n\t\t \"e.g. segments=\\\"mydcss1,mydcss2:mydcss3,mydcss4(local)\\\"\");\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}