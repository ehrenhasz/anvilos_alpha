{
  "module_name": "dasd_alias.c",
  "hash_id": "6c397f1da0d0fc0f612b3db63bdf4665ff06cf25252105a8d38d592ff6d1b847",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_alias.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd-eckd\"\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <asm/ebcdic.h>\n#include \"dasd_int.h\"\n#include \"dasd_eckd.h\"\n\n#ifdef PRINTK_HEADER\n#undef PRINTK_HEADER\n#endif\t\t\t\t \n#define PRINTK_HEADER \"dasd(eckd):\"\n\n\n \n\n\nstatic void summary_unit_check_handling_work(struct work_struct *);\nstatic void lcu_update_work(struct work_struct *);\nstatic int _schedule_lcu_update(struct alias_lcu *, struct dasd_device *);\n\nstatic struct alias_root aliastree = {\n\t.serverlist = LIST_HEAD_INIT(aliastree.serverlist),\n\t.lock = __SPIN_LOCK_UNLOCKED(aliastree.lock),\n};\n\nstatic struct alias_server *_find_server(struct dasd_uid *uid)\n{\n\tstruct alias_server *pos;\n\tlist_for_each_entry(pos, &aliastree.serverlist, server) {\n\t\tif (!strncmp(pos->uid.vendor, uid->vendor,\n\t\t\t     sizeof(uid->vendor))\n\t\t    && !strncmp(pos->uid.serial, uid->serial,\n\t\t\t\tsizeof(uid->serial)))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic struct alias_lcu *_find_lcu(struct alias_server *server,\n\t\t\t\t   struct dasd_uid *uid)\n{\n\tstruct alias_lcu *pos;\n\tlist_for_each_entry(pos, &server->lculist, lcu) {\n\t\tif (pos->uid.ssid == uid->ssid)\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic struct alias_pav_group *_find_group(struct alias_lcu *lcu,\n\t\t\t\t\t   struct dasd_uid *uid)\n{\n\tstruct alias_pav_group *pos;\n\t__u8 search_unit_addr;\n\n\t \n\tif (lcu->pav == HYPER_PAV) {\n\t\tif (list_empty(&lcu->grouplist))\n\t\t\treturn NULL;\n\t\telse\n\t\t\treturn list_first_entry(&lcu->grouplist,\n\t\t\t\t\t\tstruct alias_pav_group, group);\n\t}\n\n\t \n\tif (uid->type == UA_BASE_DEVICE)\n\t\tsearch_unit_addr = uid->real_unit_addr;\n\telse\n\t\tsearch_unit_addr = uid->base_unit_addr;\n\tlist_for_each_entry(pos, &lcu->grouplist, group) {\n\t\tif (pos->uid.base_unit_addr == search_unit_addr &&\n\t\t    !strncmp(pos->uid.vduit, uid->vduit, sizeof(uid->vduit)))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic struct alias_server *_allocate_server(struct dasd_uid *uid)\n{\n\tstruct alias_server *server;\n\n\tserver = kzalloc(sizeof(*server), GFP_KERNEL);\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmemcpy(server->uid.vendor, uid->vendor, sizeof(uid->vendor));\n\tmemcpy(server->uid.serial, uid->serial, sizeof(uid->serial));\n\tINIT_LIST_HEAD(&server->server);\n\tINIT_LIST_HEAD(&server->lculist);\n\treturn server;\n}\n\nstatic void _free_server(struct alias_server *server)\n{\n\tkfree(server);\n}\n\nstatic struct alias_lcu *_allocate_lcu(struct dasd_uid *uid)\n{\n\tstruct alias_lcu *lcu;\n\n\tlcu = kzalloc(sizeof(*lcu), GFP_KERNEL);\n\tif (!lcu)\n\t\treturn ERR_PTR(-ENOMEM);\n\tlcu->uac = kzalloc(sizeof(*(lcu->uac)), GFP_KERNEL | GFP_DMA);\n\tif (!lcu->uac)\n\t\tgoto out_err1;\n\tlcu->rsu_cqr = kzalloc(sizeof(*lcu->rsu_cqr), GFP_KERNEL | GFP_DMA);\n\tif (!lcu->rsu_cqr)\n\t\tgoto out_err2;\n\tlcu->rsu_cqr->cpaddr = kzalloc(sizeof(struct ccw1),\n\t\t\t\t       GFP_KERNEL | GFP_DMA);\n\tif (!lcu->rsu_cqr->cpaddr)\n\t\tgoto out_err3;\n\tlcu->rsu_cqr->data = kzalloc(16, GFP_KERNEL | GFP_DMA);\n\tif (!lcu->rsu_cqr->data)\n\t\tgoto out_err4;\n\n\tmemcpy(lcu->uid.vendor, uid->vendor, sizeof(uid->vendor));\n\tmemcpy(lcu->uid.serial, uid->serial, sizeof(uid->serial));\n\tlcu->uid.ssid = uid->ssid;\n\tlcu->pav = NO_PAV;\n\tlcu->flags = NEED_UAC_UPDATE | UPDATE_PENDING;\n\tINIT_LIST_HEAD(&lcu->lcu);\n\tINIT_LIST_HEAD(&lcu->inactive_devices);\n\tINIT_LIST_HEAD(&lcu->active_devices);\n\tINIT_LIST_HEAD(&lcu->grouplist);\n\tINIT_WORK(&lcu->suc_data.worker, summary_unit_check_handling_work);\n\tINIT_DELAYED_WORK(&lcu->ruac_data.dwork, lcu_update_work);\n\tspin_lock_init(&lcu->lock);\n\tinit_completion(&lcu->lcu_setup);\n\treturn lcu;\n\nout_err4:\n\tkfree(lcu->rsu_cqr->cpaddr);\nout_err3:\n\tkfree(lcu->rsu_cqr);\nout_err2:\n\tkfree(lcu->uac);\nout_err1:\n\tkfree(lcu);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void _free_lcu(struct alias_lcu *lcu)\n{\n\tkfree(lcu->rsu_cqr->data);\n\tkfree(lcu->rsu_cqr->cpaddr);\n\tkfree(lcu->rsu_cqr);\n\tkfree(lcu->uac);\n\tkfree(lcu);\n}\n\n \nint dasd_alias_make_device_known_to_lcu(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tunsigned long flags;\n\tstruct alias_server *server, *newserver;\n\tstruct alias_lcu *lcu, *newlcu;\n\tstruct dasd_uid uid;\n\n\tdevice->discipline->get_uid(device, &uid);\n\tspin_lock_irqsave(&aliastree.lock, flags);\n\tserver = _find_server(&uid);\n\tif (!server) {\n\t\tspin_unlock_irqrestore(&aliastree.lock, flags);\n\t\tnewserver = _allocate_server(&uid);\n\t\tif (IS_ERR(newserver))\n\t\t\treturn PTR_ERR(newserver);\n\t\tspin_lock_irqsave(&aliastree.lock, flags);\n\t\tserver = _find_server(&uid);\n\t\tif (!server) {\n\t\t\tlist_add(&newserver->server, &aliastree.serverlist);\n\t\t\tserver = newserver;\n\t\t} else {\n\t\t\t \n\t\t\t_free_server(newserver);\n\t\t}\n\t}\n\n\tlcu = _find_lcu(server, &uid);\n\tif (!lcu) {\n\t\tspin_unlock_irqrestore(&aliastree.lock, flags);\n\t\tnewlcu = _allocate_lcu(&uid);\n\t\tif (IS_ERR(newlcu))\n\t\t\treturn PTR_ERR(newlcu);\n\t\tspin_lock_irqsave(&aliastree.lock, flags);\n\t\tlcu = _find_lcu(server, &uid);\n\t\tif (!lcu) {\n\t\t\tlist_add(&newlcu->lcu, &server->lculist);\n\t\t\tlcu = newlcu;\n\t\t} else {\n\t\t\t \n\t\t\t_free_lcu(newlcu);\n\t\t}\n\t}\n\tspin_lock(&lcu->lock);\n\tlist_add(&device->alias_list, &lcu->inactive_devices);\n\tprivate->lcu = lcu;\n\tspin_unlock(&lcu->lock);\n\tspin_unlock_irqrestore(&aliastree.lock, flags);\n\n\treturn 0;\n}\n\n \nvoid dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tunsigned long flags;\n\tstruct alias_lcu *lcu;\n\tstruct alias_server *server;\n\tint was_pending;\n\tstruct dasd_uid uid;\n\n\tlcu = private->lcu;\n\t \n\tif (!lcu)\n\t\treturn;\n\tdevice->discipline->get_uid(device, &uid);\n\tspin_lock_irqsave(&lcu->lock, flags);\n\t \n\tif (device == lcu->suc_data.device) {\n\t\tspin_unlock_irqrestore(&lcu->lock, flags);\n\t\tcancel_work_sync(&lcu->suc_data.worker);\n\t\tspin_lock_irqsave(&lcu->lock, flags);\n\t\tif (device == lcu->suc_data.device) {\n\t\t\tdasd_put_device(device);\n\t\t\tlcu->suc_data.device = NULL;\n\t\t}\n\t}\n\twas_pending = 0;\n\tif (device == lcu->ruac_data.device) {\n\t\tspin_unlock_irqrestore(&lcu->lock, flags);\n\t\twas_pending = 1;\n\t\tcancel_delayed_work_sync(&lcu->ruac_data.dwork);\n\t\tspin_lock_irqsave(&lcu->lock, flags);\n\t\tif (device == lcu->ruac_data.device) {\n\t\t\tdasd_put_device(device);\n\t\t\tlcu->ruac_data.device = NULL;\n\t\t}\n\t}\n\tprivate->lcu = NULL;\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n\n\tspin_lock_irqsave(&aliastree.lock, flags);\n\tspin_lock(&lcu->lock);\n\tlist_del_init(&device->alias_list);\n\tif (list_empty(&lcu->grouplist) &&\n\t    list_empty(&lcu->active_devices) &&\n\t    list_empty(&lcu->inactive_devices)) {\n\t\tlist_del(&lcu->lcu);\n\t\tspin_unlock(&lcu->lock);\n\t\t_free_lcu(lcu);\n\t\tlcu = NULL;\n\t} else {\n\t\tif (was_pending)\n\t\t\t_schedule_lcu_update(lcu, NULL);\n\t\tspin_unlock(&lcu->lock);\n\t}\n\tserver = _find_server(&uid);\n\tif (server && list_empty(&server->lculist)) {\n\t\tlist_del(&server->server);\n\t\t_free_server(server);\n\t}\n\tspin_unlock_irqrestore(&aliastree.lock, flags);\n}\n\n \n\nstatic int _add_device_to_lcu(struct alias_lcu *lcu,\n\t\t\t      struct dasd_device *device,\n\t\t\t      struct dasd_device *pos)\n{\n\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct alias_pav_group *group;\n\tstruct dasd_uid uid;\n\n\tspin_lock(get_ccwdev_lock(device->cdev));\n\tprivate->uid.type = lcu->uac->unit[private->uid.real_unit_addr].ua_type;\n\tprivate->uid.base_unit_addr =\n\t\tlcu->uac->unit[private->uid.real_unit_addr].base_ua;\n\tuid = private->uid;\n\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t \n\tif (lcu->pav == NO_PAV) {\n\t\tlist_move(&device->alias_list, &lcu->active_devices);\n\t\treturn 0;\n\t}\n\tgroup = _find_group(lcu, &uid);\n\tif (!group) {\n\t\tgroup = kzalloc(sizeof(*group), GFP_ATOMIC);\n\t\tif (!group)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(group->uid.vendor, uid.vendor, sizeof(uid.vendor));\n\t\tmemcpy(group->uid.serial, uid.serial, sizeof(uid.serial));\n\t\tgroup->uid.ssid = uid.ssid;\n\t\tif (uid.type == UA_BASE_DEVICE)\n\t\t\tgroup->uid.base_unit_addr = uid.real_unit_addr;\n\t\telse\n\t\t\tgroup->uid.base_unit_addr = uid.base_unit_addr;\n\t\tmemcpy(group->uid.vduit, uid.vduit, sizeof(uid.vduit));\n\t\tINIT_LIST_HEAD(&group->group);\n\t\tINIT_LIST_HEAD(&group->baselist);\n\t\tINIT_LIST_HEAD(&group->aliaslist);\n\t\tlist_add(&group->group, &lcu->grouplist);\n\t}\n\tif (uid.type == UA_BASE_DEVICE)\n\t\tlist_move(&device->alias_list, &group->baselist);\n\telse\n\t\tlist_move(&device->alias_list, &group->aliaslist);\n\tprivate->pavgroup = group;\n\treturn 0;\n};\n\nstatic void _remove_device_from_lcu(struct alias_lcu *lcu,\n\t\t\t\t    struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct alias_pav_group *group;\n\n\tlist_move(&device->alias_list, &lcu->inactive_devices);\n\tgroup = private->pavgroup;\n\tif (!group)\n\t\treturn;\n\tprivate->pavgroup = NULL;\n\tif (list_empty(&group->baselist) && list_empty(&group->aliaslist)) {\n\t\tlist_del(&group->group);\n\t\tkfree(group);\n\t\treturn;\n\t}\n\tif (group->next == device)\n\t\tgroup->next = NULL;\n};\n\nstatic int\nsuborder_not_supported(struct dasd_ccw_req *cqr)\n{\n\tchar *sense;\n\tchar reason;\n\tchar msg_format;\n\tchar msg_no;\n\n\t \n\tif (cqr->intrc == -ENODEV)\n\t\treturn 1;\n\n\tif (cqr->intrc == -ENOLINK)\n\t\treturn 1;\n\n\tif (cqr->intrc == -EPERM)\n\t\treturn 1;\n\n\tsense = dasd_get_sense(&cqr->irb);\n\tif (!sense)\n\t\treturn 0;\n\n\treason = sense[0];\n\tmsg_format = (sense[7] & 0xF0);\n\tmsg_no = (sense[7] & 0x0F);\n\n\t \n\tif ((reason == 0x80) && (msg_format == 0x00) && (msg_no == 0x04))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int read_unit_address_configuration(struct dasd_device *device,\n\t\t\t\t\t   struct alias_lcu *lcu)\n{\n\tstruct dasd_psf_prssd_data *prssdp;\n\tstruct dasd_ccw_req *cqr;\n\tstruct ccw1 *ccw;\n\tint rc;\n\tunsigned long flags;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1  \t+ 1  ,\n\t\t\t\t   (sizeof(struct dasd_psf_prssd_data)),\n\t\t\t\t   device, NULL);\n\tif (IS_ERR(cqr))\n\t\treturn PTR_ERR(cqr);\n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tcqr->retries = 10;\n\tcqr->expires = 20 * HZ;\n\n\t \n\tprssdp = (struct dasd_psf_prssd_data *) cqr->data;\n\tmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\n\tprssdp->order = PSF_ORDER_PRSSD;\n\tprssdp->suborder = 0x0e;\t \n\t \n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_PSF;\n\tccw->count = sizeof(struct dasd_psf_prssd_data);\n\tccw->flags |= CCW_FLAG_CC;\n\tccw->cda = (__u32)virt_to_phys(prssdp);\n\n\t \n\tmemset(lcu->uac, 0, sizeof(*(lcu->uac)));\n\n\tccw++;\n\tccw->cmd_code = DASD_ECKD_CCW_RSSD;\n\tccw->count = sizeof(*(lcu->uac));\n\tccw->cda = (__u32)virt_to_phys(lcu->uac);\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\t \n\tspin_lock_irqsave(&lcu->lock, flags);\n\tlcu->flags &= ~NEED_UAC_UPDATE;\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n\n\trc = dasd_sleep_on(cqr);\n\tif (!rc)\n\t\tgoto out;\n\n\tif (suborder_not_supported(cqr)) {\n\t\t \n\t\trc = -EOPNOTSUPP;\n\t} else {\n\t\t \n\t\tspin_lock_irqsave(&lcu->lock, flags);\n\t\tlcu->flags |= NEED_UAC_UPDATE;\n\t\tspin_unlock_irqrestore(&lcu->lock, flags);\n\t}\nout:\n\tdasd_sfree_request(cqr, cqr->memdev);\n\treturn rc;\n}\n\nstatic int _lcu_update(struct dasd_device *refdev, struct alias_lcu *lcu)\n{\n\tunsigned long flags;\n\tstruct alias_pav_group *pavgroup, *tempgroup;\n\tstruct dasd_device *device, *tempdev;\n\tint i, rc;\n\tstruct dasd_eckd_private *private;\n\n\tspin_lock_irqsave(&lcu->lock, flags);\n\tlist_for_each_entry_safe(pavgroup, tempgroup, &lcu->grouplist, group) {\n\t\tlist_for_each_entry_safe(device, tempdev, &pavgroup->baselist,\n\t\t\t\t\t alias_list) {\n\t\t\tlist_move(&device->alias_list, &lcu->active_devices);\n\t\t\tprivate = device->private;\n\t\t\tprivate->pavgroup = NULL;\n\t\t}\n\t\tlist_for_each_entry_safe(device, tempdev, &pavgroup->aliaslist,\n\t\t\t\t\t alias_list) {\n\t\t\tlist_move(&device->alias_list, &lcu->active_devices);\n\t\t\tprivate = device->private;\n\t\t\tprivate->pavgroup = NULL;\n\t\t}\n\t\tlist_del(&pavgroup->group);\n\t\tkfree(pavgroup);\n\t}\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n\n\trc = read_unit_address_configuration(refdev, lcu);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock_irqsave(&lcu->lock, flags);\n\t \n\tif (lcu->flags & NEED_UAC_UPDATE)\n\t\tgoto out;\n\tlcu->pav = NO_PAV;\n\tfor (i = 0; i < MAX_DEVICES_PER_LCU; ++i) {\n\t\tswitch (lcu->uac->unit[i].ua_type) {\n\t\tcase UA_BASE_PAV_ALIAS:\n\t\t\tlcu->pav = BASE_PAV;\n\t\t\tbreak;\n\t\tcase UA_HYPER_PAV_ALIAS:\n\t\t\tlcu->pav = HYPER_PAV;\n\t\t\tbreak;\n\t\t}\n\t\tif (lcu->pav != NO_PAV)\n\t\t\tbreak;\n\t}\n\n\tlist_for_each_entry_safe(device, tempdev, &lcu->active_devices,\n\t\t\t\t alias_list) {\n\t\t_add_device_to_lcu(lcu, device, refdev);\n\t}\nout:\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n\treturn 0;\n}\n\nstatic void lcu_update_work(struct work_struct *work)\n{\n\tstruct alias_lcu *lcu;\n\tstruct read_uac_work_data *ruac_data;\n\tstruct dasd_device *device;\n\tunsigned long flags;\n\tint rc;\n\n\truac_data = container_of(work, struct read_uac_work_data, dwork.work);\n\tlcu = container_of(ruac_data, struct alias_lcu, ruac_data);\n\tdevice = ruac_data->device;\n\trc = _lcu_update(device, lcu);\n\t \n\tspin_lock_irqsave(&lcu->lock, flags);\n\tif ((rc && (rc != -EOPNOTSUPP)) || (lcu->flags & NEED_UAC_UPDATE)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"could not update\"\n\t\t\t    \" alias data in lcu (rc = %d), retry later\", rc);\n\t\tif (!schedule_delayed_work(&lcu->ruac_data.dwork, 30*HZ))\n\t\t\tdasd_put_device(device);\n\t} else {\n\t\tdasd_put_device(device);\n\t\tlcu->ruac_data.device = NULL;\n\t\tlcu->flags &= ~UPDATE_PENDING;\n\t}\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n}\n\nstatic int _schedule_lcu_update(struct alias_lcu *lcu,\n\t\t\t\tstruct dasd_device *device)\n{\n\tstruct dasd_device *usedev = NULL;\n\tstruct alias_pav_group *group;\n\n\tlcu->flags |= NEED_UAC_UPDATE;\n\tif (lcu->ruac_data.device) {\n\t\t \n\t\treturn 0;\n\t}\n\tif (device && !list_empty(&device->alias_list))\n\t\tusedev = device;\n\n\tif (!usedev && !list_empty(&lcu->grouplist)) {\n\t\tgroup = list_first_entry(&lcu->grouplist,\n\t\t\t\t\t struct alias_pav_group, group);\n\t\tif (!list_empty(&group->baselist))\n\t\t\tusedev = list_first_entry(&group->baselist,\n\t\t\t\t\t\t  struct dasd_device,\n\t\t\t\t\t\t  alias_list);\n\t\telse if (!list_empty(&group->aliaslist))\n\t\t\tusedev = list_first_entry(&group->aliaslist,\n\t\t\t\t\t\t  struct dasd_device,\n\t\t\t\t\t\t  alias_list);\n\t}\n\tif (!usedev && !list_empty(&lcu->active_devices)) {\n\t\tusedev = list_first_entry(&lcu->active_devices,\n\t\t\t\t\t  struct dasd_device, alias_list);\n\t}\n\t \n\tif (!usedev)\n\t\treturn -EINVAL;\n\tdasd_get_device(usedev);\n\tlcu->ruac_data.device = usedev;\n\tif (!schedule_delayed_work(&lcu->ruac_data.dwork, 0))\n\t\tdasd_put_device(usedev);\n\treturn 0;\n}\n\nint dasd_alias_add_device(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\t__u8 uaddr = private->uid.real_unit_addr;\n\tstruct alias_lcu *lcu = private->lcu;\n\tunsigned long flags;\n\tint rc;\n\n\trc = 0;\n\tspin_lock_irqsave(&lcu->lock, flags);\n\t \n\tif (private->uid.type !=  lcu->uac->unit[uaddr].ua_type) {\n\t\tlcu->flags |= UPDATE_PENDING;\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"uid type mismatch - trigger rescan\");\n\t}\n\tif (!(lcu->flags & UPDATE_PENDING)) {\n\t\trc = _add_device_to_lcu(lcu, device, device);\n\t\tif (rc)\n\t\t\tlcu->flags |= UPDATE_PENDING;\n\t}\n\tif (lcu->flags & UPDATE_PENDING) {\n\t\tlist_move(&device->alias_list, &lcu->active_devices);\n\t\tprivate->pavgroup = NULL;\n\t\t_schedule_lcu_update(lcu, device);\n\t}\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n\treturn rc;\n}\n\nint dasd_alias_update_add_device(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\n\tprivate->lcu->flags |= UPDATE_PENDING;\n\treturn dasd_alias_add_device(device);\n}\n\nint dasd_alias_remove_device(struct dasd_device *device)\n{\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct alias_lcu *lcu = private->lcu;\n\tunsigned long flags;\n\n\t \n\tif (!lcu)\n\t\treturn 0;\n\tspin_lock_irqsave(&lcu->lock, flags);\n\t_remove_device_from_lcu(lcu, device);\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n\treturn 0;\n}\n\nstruct dasd_device *dasd_alias_get_start_dev(struct dasd_device *base_device)\n{\n\tstruct dasd_eckd_private *alias_priv, *private = base_device->private;\n\tstruct alias_lcu *lcu = private->lcu;\n\tstruct dasd_device *alias_device;\n\tstruct alias_pav_group *group;\n\tunsigned long flags;\n\n\tif (!lcu)\n\t\treturn NULL;\n\tif (lcu->pav == NO_PAV ||\n\t    lcu->flags & (NEED_UAC_UPDATE | UPDATE_PENDING))\n\t\treturn NULL;\n\tif (unlikely(!(private->features.feature[8] & 0x01))) {\n\t\t \n\t\tDBF_DEV_EVENT(DBF_ERR, base_device, \"%s\",\n\t\t\t      \"Prefix not enabled with PAV enabled\\n\");\n\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&lcu->lock, flags);\n\tgroup = private->pavgroup;\n\tif (!group) {\n\t\tspin_unlock_irqrestore(&lcu->lock, flags);\n\t\treturn NULL;\n\t}\n\talias_device = group->next;\n\tif (!alias_device) {\n\t\tif (list_empty(&group->aliaslist)) {\n\t\t\tspin_unlock_irqrestore(&lcu->lock, flags);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\talias_device = list_first_entry(&group->aliaslist,\n\t\t\t\t\t\t\tstruct dasd_device,\n\t\t\t\t\t\t\talias_list);\n\t\t}\n\t}\n\tif (list_is_last(&alias_device->alias_list, &group->aliaslist))\n\t\tgroup->next = list_first_entry(&group->aliaslist,\n\t\t\t\t\t       struct dasd_device, alias_list);\n\telse\n\t\tgroup->next = list_first_entry(&alias_device->alias_list,\n\t\t\t\t\t       struct dasd_device, alias_list);\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n\talias_priv = alias_device->private;\n\tif ((alias_priv->count < private->count) && !alias_device->stopped &&\n\t    !test_bit(DASD_FLAG_OFFLINE, &alias_device->flags))\n\t\treturn alias_device;\n\telse\n\t\treturn NULL;\n}\n\n \nstatic int reset_summary_unit_check(struct alias_lcu *lcu,\n\t\t\t\t    struct dasd_device *device,\n\t\t\t\t    char reason)\n{\n\tstruct dasd_ccw_req *cqr;\n\tint rc = 0;\n\tstruct ccw1 *ccw;\n\n\tcqr = lcu->rsu_cqr;\n\tmemcpy((char *) &cqr->magic, \"ECKD\", 4);\n\tASCEBC((char *) &cqr->magic, 4);\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_RSCK;\n\tccw->flags = CCW_FLAG_SLI;\n\tccw->count = 16;\n\tccw->cda = (__u32)virt_to_phys(cqr->data);\n\t((char *)cqr->data)[0] = reason;\n\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tcqr->retries = 255;\t \n\tcqr->startdev = device;\n\tcqr->memdev = device;\n\tcqr->block = NULL;\n\tcqr->expires = 5 * HZ;\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\n\trc = dasd_sleep_on_immediatly(cqr);\n\treturn rc;\n}\n\nstatic void _restart_all_base_devices_on_lcu(struct alias_lcu *lcu)\n{\n\tstruct alias_pav_group *pavgroup;\n\tstruct dasd_device *device;\n\tstruct dasd_eckd_private *private;\n\n\t \n\tlist_for_each_entry(device, &lcu->active_devices, alias_list) {\n\t\tprivate = device->private;\n\t\tif (private->uid.type != UA_BASE_DEVICE)\n\t\t\tcontinue;\n\t\tdasd_schedule_block_bh(device->block);\n\t\tdasd_schedule_device_bh(device);\n\t}\n\tlist_for_each_entry(device, &lcu->inactive_devices, alias_list) {\n\t\tprivate = device->private;\n\t\tif (private->uid.type != UA_BASE_DEVICE)\n\t\t\tcontinue;\n\t\tdasd_schedule_block_bh(device->block);\n\t\tdasd_schedule_device_bh(device);\n\t}\n\tlist_for_each_entry(pavgroup, &lcu->grouplist, group) {\n\t\tlist_for_each_entry(device, &pavgroup->baselist, alias_list) {\n\t\t\tdasd_schedule_block_bh(device->block);\n\t\t\tdasd_schedule_device_bh(device);\n\t\t}\n\t}\n}\n\nstatic void flush_all_alias_devices_on_lcu(struct alias_lcu *lcu)\n{\n\tstruct alias_pav_group *pavgroup;\n\tstruct dasd_device *device, *temp;\n\tstruct dasd_eckd_private *private;\n\tunsigned long flags;\n\tLIST_HEAD(active);\n\n\t \n\n\tspin_lock_irqsave(&lcu->lock, flags);\n\tlist_for_each_entry_safe(device, temp, &lcu->active_devices,\n\t\t\t\t alias_list) {\n\t\tprivate = device->private;\n\t\tif (private->uid.type == UA_BASE_DEVICE)\n\t\t\tcontinue;\n\t\tlist_move(&device->alias_list, &active);\n\t}\n\n\tlist_for_each_entry(pavgroup, &lcu->grouplist, group) {\n\t\tlist_splice_init(&pavgroup->aliaslist, &active);\n\t}\n\twhile (!list_empty(&active)) {\n\t\tdevice = list_first_entry(&active, struct dasd_device,\n\t\t\t\t\t  alias_list);\n\t\tspin_unlock_irqrestore(&lcu->lock, flags);\n\t\tdasd_flush_device_queue(device);\n\t\tspin_lock_irqsave(&lcu->lock, flags);\n\t\t \n\t\tif (device == list_first_entry(&active,\n\t\t\t\t\t       struct dasd_device, alias_list)) {\n\t\t\tlist_move(&device->alias_list, &lcu->active_devices);\n\t\t\tprivate = device->private;\n\t\t\tprivate->pavgroup = NULL;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n}\n\nstatic void _stop_all_devices_on_lcu(struct alias_lcu *lcu)\n{\n\tstruct alias_pav_group *pavgroup;\n\tstruct dasd_device *device;\n\n\tlist_for_each_entry(device, &lcu->active_devices, alias_list) {\n\t\tspin_lock(get_ccwdev_lock(device->cdev));\n\t\tdasd_device_set_stop_bits(device, DASD_STOPPED_SU);\n\t\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t}\n\tlist_for_each_entry(device, &lcu->inactive_devices, alias_list) {\n\t\tspin_lock(get_ccwdev_lock(device->cdev));\n\t\tdasd_device_set_stop_bits(device, DASD_STOPPED_SU);\n\t\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t}\n\tlist_for_each_entry(pavgroup, &lcu->grouplist, group) {\n\t\tlist_for_each_entry(device, &pavgroup->baselist, alias_list) {\n\t\t\tspin_lock(get_ccwdev_lock(device->cdev));\n\t\t\tdasd_device_set_stop_bits(device, DASD_STOPPED_SU);\n\t\t\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t\t}\n\t\tlist_for_each_entry(device, &pavgroup->aliaslist, alias_list) {\n\t\t\tspin_lock(get_ccwdev_lock(device->cdev));\n\t\t\tdasd_device_set_stop_bits(device, DASD_STOPPED_SU);\n\t\t\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t\t}\n\t}\n}\n\nstatic void _unstop_all_devices_on_lcu(struct alias_lcu *lcu)\n{\n\tstruct alias_pav_group *pavgroup;\n\tstruct dasd_device *device;\n\n\tlist_for_each_entry(device, &lcu->active_devices, alias_list) {\n\t\tspin_lock(get_ccwdev_lock(device->cdev));\n\t\tdasd_device_remove_stop_bits(device, DASD_STOPPED_SU);\n\t\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t}\n\tlist_for_each_entry(device, &lcu->inactive_devices, alias_list) {\n\t\tspin_lock(get_ccwdev_lock(device->cdev));\n\t\tdasd_device_remove_stop_bits(device, DASD_STOPPED_SU);\n\t\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t}\n\tlist_for_each_entry(pavgroup, &lcu->grouplist, group) {\n\t\tlist_for_each_entry(device, &pavgroup->baselist, alias_list) {\n\t\t\tspin_lock(get_ccwdev_lock(device->cdev));\n\t\t\tdasd_device_remove_stop_bits(device, DASD_STOPPED_SU);\n\t\t\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t\t}\n\t\tlist_for_each_entry(device, &pavgroup->aliaslist, alias_list) {\n\t\t\tspin_lock(get_ccwdev_lock(device->cdev));\n\t\t\tdasd_device_remove_stop_bits(device, DASD_STOPPED_SU);\n\t\t\tspin_unlock(get_ccwdev_lock(device->cdev));\n\t\t}\n\t}\n}\n\nstatic void summary_unit_check_handling_work(struct work_struct *work)\n{\n\tstruct alias_lcu *lcu;\n\tstruct summary_unit_check_work_data *suc_data;\n\tunsigned long flags;\n\tstruct dasd_device *device;\n\n\tsuc_data = container_of(work, struct summary_unit_check_work_data,\n\t\t\t\tworker);\n\tlcu = container_of(suc_data, struct alias_lcu, suc_data);\n\tdevice = suc_data->device;\n\n\t \n\tflush_all_alias_devices_on_lcu(lcu);\n\n\t \n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tdasd_device_remove_stop_bits(device,\n\t\t\t\t     (DASD_STOPPED_SU | DASD_STOPPED_PENDING));\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\treset_summary_unit_check(lcu, device, suc_data->reason);\n\n\tspin_lock_irqsave(&lcu->lock, flags);\n\t_unstop_all_devices_on_lcu(lcu);\n\t_restart_all_base_devices_on_lcu(lcu);\n\t \n\t_schedule_lcu_update(lcu, device);\n\tlcu->suc_data.device = NULL;\n\tdasd_put_device(device);\n\tspin_unlock_irqrestore(&lcu->lock, flags);\n}\n\nvoid dasd_alias_handle_summary_unit_check(struct work_struct *work)\n{\n\tstruct dasd_device *device = container_of(work, struct dasd_device,\n\t\t\t\t\t\t  suc_work);\n\tstruct dasd_eckd_private *private = device->private;\n\tstruct alias_lcu *lcu;\n\tunsigned long flags;\n\n\tlcu = private->lcu;\n\tif (!lcu) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"device not ready to handle summary\"\n\t\t\t    \" unit check (no lcu structure)\");\n\t\tgoto out;\n\t}\n\tspin_lock_irqsave(&lcu->lock, flags);\n\t \n\tif (list_empty(&device->alias_list)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"device is in offline processing,\"\n\t\t\t    \" don't do summary unit check handling\");\n\t\tgoto out_unlock;\n\t}\n\tif (lcu->suc_data.device) {\n\t\t \n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"previous instance of summary unit check worker\"\n\t\t\t    \" still pending\");\n\t\tgoto out_unlock;\n\t}\n\t_stop_all_devices_on_lcu(lcu);\n\t \n\tlcu->flags |= NEED_UAC_UPDATE | UPDATE_PENDING;\n\tlcu->suc_data.reason = private->suc_reason;\n\tlcu->suc_data.device = device;\n\tdasd_get_device(device);\n\tif (!schedule_work(&lcu->suc_data.worker))\n\t\tdasd_put_device(device);\nout_unlock:\n\tspin_unlock_irqrestore(&lcu->lock, flags);\nout:\n\tclear_bit(DASD_FLAG_SUC, &device->flags);\n\tdasd_put_device(device);\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}