{
  "module_name": "dasd_proc.c",
  "hash_id": "398b37c1afc36fd61ed2c46543e78280c84c1b566e322dc5053b9724b94effde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_proc.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd\"\n\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n\n#include <asm/debug.h>\n#include <linux/uaccess.h>\n\n \n#define PRINTK_HEADER \"dasd_proc:\"\n\n#include \"dasd_int.h\"\n\nstatic struct proc_dir_entry *dasd_proc_root_entry = NULL;\nstatic struct proc_dir_entry *dasd_devices_entry = NULL;\nstatic struct proc_dir_entry *dasd_statistics_entry = NULL;\n\nstatic int\ndasd_devices_show(struct seq_file *m, void *v)\n{\n\tstruct dasd_device *device;\n\tstruct dasd_block *block;\n\tchar *substr;\n\n\tdevice = dasd_device_from_devindex((unsigned long) v - 1);\n\tif (IS_ERR(device))\n\t\treturn 0;\n\tif (device->block)\n\t\tblock = device->block;\n\telse {\n\t\tdasd_put_device(device);\n\t\treturn 0;\n\t}\n\t \n\tseq_printf(m, \"%s\", dev_name(&device->cdev->dev));\n\t \n\tif (device->discipline != NULL)\n\t\tseq_printf(m, \"(%s)\", device->discipline->name);\n\telse\n\t\tseq_printf(m, \"(none)\");\n\t \n\tif (block->gdp)\n\t\tseq_printf(m, \" at (%3d:%6d)\",\n\t\t\t   MAJOR(disk_devt(block->gdp)),\n\t\t\t   MINOR(disk_devt(block->gdp)));\n\telse\n\t\tseq_printf(m, \"  at (???:??????)\");\n\t \n\tif (block->gdp)\n\t\tseq_printf(m, \" is %-8s\", block->gdp->disk_name);\n\telse\n\t\tseq_printf(m, \" is ????????\");\n\t \n\tsubstr = (device->features & DASD_FEATURE_READONLY) ? \"(ro)\" : \" \";\n\tseq_printf(m, \"%4s: \", substr);\n\t \n\tswitch (device->state) {\n\tcase DASD_STATE_NEW:\n\t\tseq_printf(m, \"new\");\n\t\tbreak;\n\tcase DASD_STATE_KNOWN:\n\t\tseq_printf(m, \"detected\");\n\t\tbreak;\n\tcase DASD_STATE_BASIC:\n\t\tseq_printf(m, \"basic\");\n\t\tbreak;\n\tcase DASD_STATE_UNFMT:\n\t\tseq_printf(m, \"unformatted\");\n\t\tbreak;\n\tcase DASD_STATE_READY:\n\tcase DASD_STATE_ONLINE:\n\t\tseq_printf(m, \"active \");\n\t\tif (dasd_check_blocksize(block->bp_block))\n\t\t\tseq_printf(m, \"n/f\t \");\n\t\telse\n\t\t\tseq_printf(m,\n\t\t\t\t   \"at blocksize: %u, %lu blocks, %lu MB\",\n\t\t\t\t   block->bp_block, block->blocks,\n\t\t\t\t   ((block->bp_block >> 9) *\n\t\t\t\t    block->blocks) >> 11);\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(m, \"no stat\");\n\t\tbreak;\n\t}\n\tdasd_put_device(device);\n\tif (dasd_probeonly)\n\t\tseq_printf(m, \"(probeonly)\");\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}\n\nstatic void *dasd_devices_start(struct seq_file *m, loff_t *pos)\n{\n\tif (*pos >= dasd_max_devindex)\n\t\treturn NULL;\n\treturn (void *)((unsigned long) *pos + 1);\n}\n\nstatic void *dasd_devices_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn dasd_devices_start(m, pos);\n}\n\nstatic void dasd_devices_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic const struct seq_operations dasd_devices_seq_ops = {\n\t.start\t\t= dasd_devices_start,\n\t.next\t\t= dasd_devices_next,\n\t.stop\t\t= dasd_devices_stop,\n\t.show\t\t= dasd_devices_show,\n};\n\n#ifdef CONFIG_DASD_PROFILE\nstatic int dasd_stats_all_block_on(void)\n{\n\tint i, rc;\n\tstruct dasd_device *device;\n\n\trc = 0;\n\tfor (i = 0; i < dasd_max_devindex; ++i) {\n\t\tdevice = dasd_device_from_devindex(i);\n\t\tif (IS_ERR(device))\n\t\t\tcontinue;\n\t\tif (device->block)\n\t\t\trc = dasd_profile_on(&device->block->profile);\n\t\tdasd_put_device(device);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void dasd_stats_all_block_off(void)\n{\n\tint i;\n\tstruct dasd_device *device;\n\n\tfor (i = 0; i < dasd_max_devindex; ++i) {\n\t\tdevice = dasd_device_from_devindex(i);\n\t\tif (IS_ERR(device))\n\t\t\tcontinue;\n\t\tif (device->block)\n\t\t\tdasd_profile_off(&device->block->profile);\n\t\tdasd_put_device(device);\n\t}\n}\n\nstatic void dasd_stats_all_block_reset(void)\n{\n\tint i;\n\tstruct dasd_device *device;\n\n\tfor (i = 0; i < dasd_max_devindex; ++i) {\n\t\tdevice = dasd_device_from_devindex(i);\n\t\tif (IS_ERR(device))\n\t\t\tcontinue;\n\t\tif (device->block)\n\t\t\tdasd_profile_reset(&device->block->profile);\n\t\tdasd_put_device(device);\n\t}\n}\n\nstatic void dasd_statistics_array(struct seq_file *m, unsigned int *array, int factor)\n{\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tseq_printf(m, \"%7d \", array[i] / factor);\n\t\tif (i == 15)\n\t\t\tseq_putc(m, '\\n');\n\t}\n\tseq_putc(m, '\\n');\n}\n#endif  \n\nstatic int dasd_stats_proc_show(struct seq_file *m, void *v)\n{\n#ifdef CONFIG_DASD_PROFILE\n\tstruct dasd_profile_info *prof;\n\tint factor;\n\n\tspin_lock_bh(&dasd_global_profile.lock);\n\tprof = dasd_global_profile.data;\n\tif (!prof) {\n\t\tspin_unlock_bh(&dasd_global_profile.lock);\n\t\tseq_printf(m, \"Statistics are off - they might be \"\n\t\t\t\t    \"switched on using 'echo set on > \"\n\t\t\t\t    \"/proc/dasd/statistics'\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (factor = 1; (prof->dasd_io_reqs / factor) > 9999999;\n\t     factor *= 10);\n\n\tseq_printf(m, \"%d dasd I/O requests\\n\", prof->dasd_io_reqs);\n\tseq_printf(m, \"with %u sectors(512B each)\\n\",\n\t\t       prof->dasd_io_sects);\n\tseq_printf(m, \"Scale Factor is  %d\\n\", factor);\n\tseq_printf(m,\n\t\t       \"   __<4\t   ___8\t   __16\t   __32\t   __64\t   _128\t\"\n\t\t       \"   _256\t   _512\t   __1k\t   __2k\t   __4k\t   __8k\t\"\n\t\t       \"   _16k\t   _32k\t   _64k\t   128k\\n\");\n\tseq_printf(m,\n\t\t       \"   _256\t   _512\t   __1M\t   __2M\t   __4M\t   __8M\t\"\n\t\t       \"   _16M\t   _32M\t   _64M\t   128M\t   256M\t   512M\t\"\n\t\t       \"   __1G\t   __2G\t   __4G \" \"   _>4G\\n\");\n\n\tseq_printf(m, \"Histogram of sizes (512B secs)\\n\");\n\tdasd_statistics_array(m, prof->dasd_io_secs, factor);\n\tseq_printf(m, \"Histogram of I/O times (microseconds)\\n\");\n\tdasd_statistics_array(m, prof->dasd_io_times, factor);\n\tseq_printf(m, \"Histogram of I/O times per sector\\n\");\n\tdasd_statistics_array(m, prof->dasd_io_timps, factor);\n\tseq_printf(m, \"Histogram of I/O time till ssch\\n\");\n\tdasd_statistics_array(m, prof->dasd_io_time1, factor);\n\tseq_printf(m, \"Histogram of I/O time between ssch and irq\\n\");\n\tdasd_statistics_array(m, prof->dasd_io_time2, factor);\n\tseq_printf(m, \"Histogram of I/O time between ssch \"\n\t\t\t    \"and irq per sector\\n\");\n\tdasd_statistics_array(m, prof->dasd_io_time2ps, factor);\n\tseq_printf(m, \"Histogram of I/O time between irq and end\\n\");\n\tdasd_statistics_array(m, prof->dasd_io_time3, factor);\n\tseq_printf(m, \"# of req in chanq at enqueuing (1..32) \\n\");\n\tdasd_statistics_array(m, prof->dasd_io_nr_req, factor);\n\tspin_unlock_bh(&dasd_global_profile.lock);\n#else\n\tseq_printf(m, \"Statistics are not activated in this kernel\\n\");\n#endif\n\treturn 0;\n}\n\nstatic int dasd_stats_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, dasd_stats_proc_show, NULL);\n}\n\nstatic ssize_t dasd_stats_proc_write(struct file *file,\n\t\tconst char __user *user_buf, size_t user_len, loff_t *pos)\n{\n#ifdef CONFIG_DASD_PROFILE\n\tchar *buffer, *str;\n\tint rc;\n\n\tif (user_len > 65536)\n\t\tuser_len = 65536;\n\tbuffer = dasd_get_user_string(user_buf, user_len);\n\tif (IS_ERR(buffer))\n\t\treturn PTR_ERR(buffer);\n\n\t \n\tstr = skip_spaces(buffer);\n\tif (strncmp(str, \"set\", 3) == 0 && isspace(str[3])) {\n\t\t \n\t\tstr = skip_spaces(str + 4);\n\t\tif (strcmp(str, \"on\") == 0) {\n\t\t\t \n\t\t\trc = dasd_stats_all_block_on();\n\t\t\tif (rc) {\n\t\t\t\tdasd_stats_all_block_off();\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\trc = dasd_profile_on(&dasd_global_profile);\n\t\t\tif (rc) {\n\t\t\t\tdasd_stats_all_block_off();\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tdasd_profile_reset(&dasd_global_profile);\n\t\t\tdasd_global_profile_level = DASD_PROFILE_ON;\n\t\t\tpr_info(\"The statistics feature has been switched \"\n\t\t\t\t\"on\\n\");\n\t\t} else if (strcmp(str, \"off\") == 0) {\n\t\t\t \n\t\t\tdasd_global_profile_level = DASD_PROFILE_OFF;\n\t\t\tdasd_profile_off(&dasd_global_profile);\n\t\t\tdasd_stats_all_block_off();\n\t\t\tpr_info(\"The statistics feature has been switched \"\n\t\t\t\t\"off\\n\");\n\t\t} else\n\t\t\tgoto out_parse_error;\n\t} else if (strncmp(str, \"reset\", 5) == 0) {\n\t\t \n\t\tdasd_profile_reset(&dasd_global_profile);\n\t\tdasd_stats_all_block_reset();\n\t\tpr_info(\"The statistics have been reset\\n\");\n\t} else\n\t\tgoto out_parse_error;\n\tvfree(buffer);\n\treturn user_len;\nout_parse_error:\n\trc = -EINVAL;\n\tpr_warn(\"%s is not a supported value for /proc/dasd/statistics\\n\", str);\nout_error:\n\tvfree(buffer);\n\treturn rc;\n#else\n\tpr_warn(\"/proc/dasd/statistics: is not activated in this kernel\\n\");\n\treturn user_len;\n#endif\t\t\t\t \n}\n\nstatic const struct proc_ops dasd_stats_proc_ops = {\n\t.proc_open\t= dasd_stats_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= dasd_stats_proc_write,\n};\n\n \nint\ndasd_proc_init(void)\n{\n\tdasd_proc_root_entry = proc_mkdir(\"dasd\", NULL);\n\tif (!dasd_proc_root_entry)\n\t\tgoto out_nodasd;\n\tdasd_devices_entry = proc_create_seq(\"devices\", 0444,\n\t\t\t\t\t dasd_proc_root_entry,\n\t\t\t\t\t &dasd_devices_seq_ops);\n\tif (!dasd_devices_entry)\n\t\tgoto out_nodevices;\n\tdasd_statistics_entry = proc_create(\"statistics\",\n\t\t\t\t\t    S_IFREG | S_IRUGO | S_IWUSR,\n\t\t\t\t\t    dasd_proc_root_entry,\n\t\t\t\t\t    &dasd_stats_proc_ops);\n\tif (!dasd_statistics_entry)\n\t\tgoto out_nostatistics;\n\treturn 0;\n\n out_nostatistics:\n\tremove_proc_entry(\"devices\", dasd_proc_root_entry);\n out_nodevices:\n\tremove_proc_entry(\"dasd\", NULL);\n out_nodasd:\n\treturn -ENOENT;\n}\n\nvoid\ndasd_proc_exit(void)\n{\n\tremove_proc_entry(\"devices\", dasd_proc_root_entry);\n\tremove_proc_entry(\"statistics\", dasd_proc_root_entry);\n\tremove_proc_entry(\"dasd\", NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}