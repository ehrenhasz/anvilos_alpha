{
  "module_name": "dasd_genhd.c",
  "hash_id": "83a48c1f1e0dcc5702b5a65b43ce15467eaf148dbd0c00db03e74b23859bf1ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_genhd.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd\"\n\n#include <linux/interrupt.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/blkpg.h>\n\n#include <linux/uaccess.h>\n\n \n#define PRINTK_HEADER \"dasd_gendisk:\"\n\n#include \"dasd_int.h\"\n\nstatic unsigned int queue_depth = 32;\nstatic unsigned int nr_hw_queues = 4;\n\nmodule_param(queue_depth, uint, 0444);\nMODULE_PARM_DESC(queue_depth, \"Default queue depth for new DASD devices\");\n\nmodule_param(nr_hw_queues, uint, 0444);\nMODULE_PARM_DESC(nr_hw_queues, \"Default number of hardware queues for new DASD devices\");\n\n \nint dasd_gendisk_alloc(struct dasd_block *block)\n{\n\tstruct gendisk *gdp;\n\tstruct dasd_device *base;\n\tint len, rc;\n\n\t \n\tbase = block->base;\n\tif (base->devindex >= DASD_PER_MAJOR)\n\t\treturn -EBUSY;\n\n\tblock->tag_set.ops = &dasd_mq_ops;\n\tblock->tag_set.cmd_size = sizeof(struct dasd_ccw_req);\n\tblock->tag_set.nr_hw_queues = nr_hw_queues;\n\tblock->tag_set.queue_depth = queue_depth;\n\tblock->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;\n\tblock->tag_set.numa_node = NUMA_NO_NODE;\n\trc = blk_mq_alloc_tag_set(&block->tag_set);\n\tif (rc)\n\t\treturn rc;\n\n\tgdp = blk_mq_alloc_disk(&block->tag_set, block);\n\tif (IS_ERR(gdp)) {\n\t\tblk_mq_free_tag_set(&block->tag_set);\n\t\treturn PTR_ERR(gdp);\n\t}\n\n\t \n\tgdp->major = DASD_MAJOR;\n\tgdp->first_minor = base->devindex << DASD_PARTN_BITS;\n\tgdp->minors = 1 << DASD_PARTN_BITS;\n\tgdp->fops = &dasd_device_operations;\n\n\t \n\tlen = sprintf(gdp->disk_name, \"dasd\");\n\tif (base->devindex > 25) {\n\t\tif (base->devindex > 701) {\n\t\t\tif (base->devindex > 18277)\n\t\t\t        len += sprintf(gdp->disk_name + len, \"%c\",\n\t\t\t\t\t       'a'+(((base->devindex-18278)\n\t\t\t\t\t\t     /17576)%26));\n\t\t\tlen += sprintf(gdp->disk_name + len, \"%c\",\n\t\t\t\t       'a'+(((base->devindex-702)/676)%26));\n\t\t}\n\t\tlen += sprintf(gdp->disk_name + len, \"%c\",\n\t\t\t       'a'+(((base->devindex-26)/26)%26));\n\t}\n\tlen += sprintf(gdp->disk_name + len, \"%c\", 'a'+(base->devindex%26));\n\n\tif (base->features & DASD_FEATURE_READONLY ||\n\t    test_bit(DASD_FLAG_DEVICE_RO, &base->flags))\n\t\tset_disk_ro(gdp, 1);\n\tdasd_add_link_to_gendisk(gdp, base);\n\tblock->gdp = gdp;\n\tset_capacity(block->gdp, 0);\n\n\trc = device_add_disk(&base->cdev->dev, block->gdp, NULL);\n\tif (rc) {\n\t\tdasd_gendisk_free(block);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nvoid dasd_gendisk_free(struct dasd_block *block)\n{\n\tif (block->gdp) {\n\t\tdel_gendisk(block->gdp);\n\t\tblock->gdp->private_data = NULL;\n\t\tput_disk(block->gdp);\n\t\tblock->gdp = NULL;\n\t\tblk_mq_free_tag_set(&block->tag_set);\n\t}\n}\n\n \nint dasd_scan_partitions(struct dasd_block *block)\n{\n\tstruct block_device *bdev;\n\tint rc;\n\n\tbdev = blkdev_get_by_dev(disk_devt(block->gdp), BLK_OPEN_READ, NULL,\n\t\t\t\t NULL);\n\tif (IS_ERR(bdev)) {\n\t\tDBF_DEV_EVENT(DBF_ERR, block->base,\n\t\t\t      \"scan partitions error, blkdev_get returned %ld\",\n\t\t\t      PTR_ERR(bdev));\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&block->gdp->open_mutex);\n\trc = bdev_disk_changed(block->gdp, false);\n\tmutex_unlock(&block->gdp->open_mutex);\n\tif (rc)\n\t\tDBF_DEV_EVENT(DBF_ERR, block->base,\n\t\t\t\t\"scan partitions error, rc %d\", rc);\n\n\t \n\tblock->bdev = bdev;\n\treturn 0;\n}\n\n \nvoid dasd_destroy_partitions(struct dasd_block *block)\n{\n\tstruct block_device *bdev;\n\n\t \n\tbdev = block->bdev;\n\tblock->bdev = NULL;\n\n\tmutex_lock(&bdev->bd_disk->open_mutex);\n\tbdev_disk_changed(bdev->bd_disk, true);\n\tmutex_unlock(&bdev->bd_disk->open_mutex);\n\n\t \n\tblkdev_put(bdev, NULL);\n}\n\nint dasd_gendisk_init(void)\n{\n\tint rc;\n\n\t \n\trc = register_blkdev(DASD_MAJOR, \"dasd\");\n\tif (rc != 0) {\n\t\tpr_warn(\"Registering the device driver with major number %d failed\\n\",\n\t\t\tDASD_MAJOR);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nvoid dasd_gendisk_exit(void)\n{\n\tunregister_blkdev(DASD_MAJOR, \"dasd\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}