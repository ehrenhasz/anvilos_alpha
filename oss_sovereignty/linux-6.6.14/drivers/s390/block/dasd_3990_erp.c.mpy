{
  "module_name": "dasd_3990_erp.c",
  "hash_id": "0b2314f91a03a60ac9a501d42570f7cc896f1a86b9b92f9f07db0c52e929a242",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_3990_erp.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd-eckd\"\n\n#include <linux/timer.h>\n#include <asm/idals.h>\n\n#define PRINTK_HEADER \"dasd_erp(3990): \"\n\n#include \"dasd_int.h\"\n#include \"dasd_eckd.h\"\n\n\nstruct DCTL_data {\n\tunsigned char subcommand;   \n\tunsigned char modifier;\t    \n\tunsigned short res;\t    \n} __attribute__ ((packed));\n\n \n \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_cleanup(struct dasd_ccw_req * erp, char final_status)\n{\n\tstruct dasd_ccw_req *cqr = erp->refers;\n\n\tdasd_free_erp_request(erp, erp->memdev);\n\tcqr->status = final_status;\n\treturn cqr;\n\n}\t\t\t\t \n\n \nstatic void dasd_3990_erp_block_queue(struct dasd_ccw_req *erp, int expires)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\tunsigned long flags;\n\n\tDBF_DEV_EVENT(DBF_INFO, device,\n\t\t    \"blocking request queue for %is\", expires/HZ);\n\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tdasd_device_set_stop_bits(device, DASD_STOPPED_PENDING);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\terp->status = DASD_CQR_FILLED;\n\tif (erp->block)\n\t\tdasd_block_set_timer(erp->block, expires);\n\telse\n\t\tdasd_device_set_timer(device, expires);\n}\n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_int_req(struct dasd_ccw_req * erp)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\t \n\t \n\t \n\tif (erp->function != dasd_3990_erp_int_req) {\n\n\t\terp->retries = 256;\n\t\terp->function = dasd_3990_erp_int_req;\n\n\t} else {\n\n\t\t \n\t\tdev_err(&device->cdev->dev,\n\t\t\t    \"is offline or not installed - \"\n\t\t\t    \"INTERVENTION REQUIRED!!\\n\");\n\n\t\tdasd_3990_erp_block_queue(erp, 60*HZ);\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic void\ndasd_3990_erp_alternate_path(struct dasd_ccw_req * erp)\n{\n\tstruct dasd_device *device = erp->startdev;\n\t__u8 opm;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\topm = ccw_device_get_path_mask(device->cdev);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\tif (erp->lpm == 0)\n\t\terp->lpm = dasd_path_get_opm(device) &\n\t\t\t~(erp->irb.esw.esw0.sublog.lpum);\n\telse\n\t\terp->lpm &= ~(erp->irb.esw.esw0.sublog.lpum);\n\n\tif ((erp->lpm & opm) != 0x00) {\n\n\t\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t\t    \"try alternate lpm=%x (lpum=%x / opm=%x)\",\n\t\t\t    erp->lpm, erp->irb.esw.esw0.sublog.lpum, opm);\n\n\t\t \n\t\terp->status = DASD_CQR_FILLED;\n\t\terp->retries = 10;\n\t} else {\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"The DASD cannot be reached on any path (lpum=%x\"\n\t\t\t\"/opm=%x)\\n\", erp->irb.esw.esw0.sublog.lpum, opm);\n\n\t\t \n\t\terp->status = DASD_CQR_FAILED;\n\t}\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_DCTL(struct dasd_ccw_req * erp, char modifier)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\tstruct DCTL_data *DCTL_data;\n\tstruct ccw1 *ccw;\n\tstruct dasd_ccw_req *dctl_cqr;\n\n\tdctl_cqr = dasd_alloc_erp_request(erp->magic, 1,\n\t\t\t\t\t  sizeof(struct DCTL_data),\n\t\t\t\t\t  device);\n\tif (IS_ERR(dctl_cqr)) {\n\t\tdev_err(&device->cdev->dev,\n\t\t\t    \"Unable to allocate DCTL-CQR\\n\");\n\t\terp->status = DASD_CQR_FAILED;\n\t\treturn erp;\n\t}\n\n\tDCTL_data = dctl_cqr->data;\n\n\tDCTL_data->subcommand = 0x02;\t \n\tDCTL_data->modifier = modifier;\n\n\tccw = dctl_cqr->cpaddr;\n\tmemset(ccw, 0, sizeof(struct ccw1));\n\tccw->cmd_code = CCW_CMD_DCTL;\n\tccw->count = 4;\n\tccw->cda = (__u32)virt_to_phys(DCTL_data);\n\tdctl_cqr->flags = erp->flags;\n\tdctl_cqr->function = dasd_3990_erp_DCTL;\n\tdctl_cqr->refers = erp;\n\tdctl_cqr->startdev = device;\n\tdctl_cqr->memdev = device;\n\tdctl_cqr->magic = erp->magic;\n\tdctl_cqr->expires = 5 * 60 * HZ;\n\tdctl_cqr->retries = 2;\n\n\tdctl_cqr->buildclk = get_tod_clock();\n\n\tdctl_cqr->status = DASD_CQR_FILLED;\n\n\treturn dctl_cqr;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *dasd_3990_erp_action_1_sec(struct dasd_ccw_req *erp)\n{\n\terp->function = dasd_3990_erp_action_1_sec;\n\tdasd_3990_erp_alternate_path(erp);\n\treturn erp;\n}\n\nstatic struct dasd_ccw_req *dasd_3990_erp_action_1(struct dasd_ccw_req *erp)\n{\n\terp->function = dasd_3990_erp_action_1;\n\tdasd_3990_erp_alternate_path(erp);\n\tif (erp->status == DASD_CQR_FAILED &&\n\t    !test_bit(DASD_CQR_VERIFY_PATH, &erp->flags)) {\n\t\terp->status = DASD_CQR_FILLED;\n\t\terp->retries = 10;\n\t\terp->lpm = dasd_path_get_opm(erp->startdev);\n\t\terp->function = dasd_3990_erp_action_1_sec;\n\t}\n\treturn erp;\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_action_4(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\t \n\t \n\t \n\tif (erp->function != dasd_3990_erp_action_4) {\n\n\t\tDBF_DEV_EVENT(DBF_INFO, device, \"%s\",\n\t\t\t    \"dasd_3990_erp_action_4: first time retry\");\n\n\t\terp->retries = 256;\n\t\terp->function = dasd_3990_erp_action_4;\n\n\t} else {\n\t\tif (sense && (sense[25] == 0x1D)) {  \n\n\t\t\tDBF_DEV_EVENT(DBF_INFO, device,\n\t\t\t\t    \"waiting for state change pending \"\n\t\t\t\t    \"interrupt, %d retries left\",\n\t\t\t\t    erp->retries);\n\n\t\t\tdasd_3990_erp_block_queue(erp, 30*HZ);\n\n\t\t} else if (sense && (sense[25] == 0x1E)) {\t \n\t\t\tDBF_DEV_EVENT(DBF_INFO, device,\n\t\t\t\t    \"busy - redriving request later, \"\n\t\t\t\t    \"%d retries left\",\n\t\t\t\t    erp->retries);\n                        dasd_3990_erp_block_queue(erp, HZ);\n\t\t} else {\n\t\t\t \n\t\t\tDBF_DEV_EVENT(DBF_INFO, device,\n\t\t\t\t     \"redriving request immediately, \"\n\t\t\t\t     \"%d retries left\",\n\t\t\t\t     erp->retries);\n\t\t\terp->status = DASD_CQR_FILLED;\n\t\t}\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_action_5(struct dasd_ccw_req * erp)\n{\n\n\t \n\terp->retries = 10;\n\terp->function = dasd_3990_erp_action_5;\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic void\ndasd_3990_handle_env_data(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\tchar msg_format = (sense[7] & 0xF0);\n\tchar msg_no = (sense[7] & 0x0F);\n\tchar errorstring[ERRORLENGTH];\n\n\tswitch (msg_format) {\n\tcase 0x00:\t\t \n\n\t\tif (sense[1] & 0x10) {\t \n\n\t\t\tswitch (msg_no) {\n\t\t\tcase 0x00:\t \n\t\t\t\tbreak;\n\t\t\tcase 0x01:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Invalid Command\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x02:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Invalid Command \"\n\t\t\t\t\t    \"Sequence\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x03:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - CCW Count less than \"\n\t\t\t\t\t    \"required\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x04:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Invalid Parameter\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Diagnostic of Special\"\n\t\t\t\t\t    \" Command Violates File Mask\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x07:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Channel Returned with \"\n\t\t\t\t\t    \"Incorrect retry CCW\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x08:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Reset Notification\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x09:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t \"FORMAT 0 - Storage Path Restart\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x0A:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Channel requested \"\n\t\t\t\t\t    \"... %02x\\n\", sense[8]);\n\t\t\t\tbreak;\n\t\t\tcase 0x0B:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Invalid Defective/\"\n\t\t\t\t\t    \"Alternate Track Pointer\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x0C:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - DPS Installation \"\n\t\t\t\t\t    \"Check\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x0E:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Command Invalid on \"\n\t\t\t\t\t    \"Secondary Address\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x0F:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Status Not As \"\n\t\t\t\t\t    \"Required: reason %02x\\n\",\n\t\t\t\t\t sense[8]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Reserved\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (msg_no) {\n\t\t\tcase 0x00:\t \n\t\t\t\tbreak;\n\t\t\tcase 0x01:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t \"FORMAT 0 - Device Error \"\n\t\t\t\t\t \"Source\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x02:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Reserved\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 0x03:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Device Fenced - \"\n\t\t\t\t\t    \"device = %02x\\n\", sense[4]);\n\t\t\t\tbreak;\n\t\t\tcase 0x04:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Data Pinned for \"\n\t\t\t\t\t    \"Device\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t\t    \"FORMAT 0 - Reserved\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 0x10:\t\t \n\t\tswitch (msg_no) {\n\t\tcase 0x00:\t \n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Device Status 1 not as \"\n\t\t\t\t    \"expected\\n\");\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Index missing\\n\");\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"FORMAT 1 - Interruption cannot be \"\n\t\t\t\t \"reset\\n\");\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Device did not respond to \"\n\t\t\t\t    \"selection\\n\");\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Device check-2 error or Set \"\n\t\t\t\t    \"Sector is not complete\\n\");\n\t\t\tbreak;\n\t\tcase 0x07:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Head address does not \"\n\t\t\t\t    \"compare\\n\");\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Device status 1 not valid\\n\");\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Device not ready\\n\");\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Track physical address did \"\n\t\t\t\t    \"not compare\\n\");\n\t\t\tbreak;\n\t\tcase 0x0B:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Missing device address bit\\n\");\n\t\t\tbreak;\n\t\tcase 0x0C:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Drive motor switch is off\\n\");\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Seek incomplete\\n\");\n\t\t\tbreak;\n\t\tcase 0x0E:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Cylinder address did not \"\n\t\t\t\t    \"compare\\n\");\n\t\t\tbreak;\n\t\tcase 0x0F:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Offset active cannot be \"\n\t\t\t\t    \"reset\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 1 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x20:\t\t \n\t\tswitch (msg_no) {\n\t\tcase 0x08:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 2 - 3990 check-2 error\\n\");\n\t\t\tbreak;\n\t\tcase 0x0E:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 2 - Support facility errors\\n\");\n\t\t\tbreak;\n\t\tcase 0x0F:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"FORMAT 2 - Microcode detected error \"\n\t\t\t\t \"%02x\\n\",\n\t\t\t\t sense[8]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 2 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x30:\t\t \n\t\tswitch (msg_no) {\n\t\tcase 0x0F:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 3 - Allegiance terminated\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 3 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x40:\t\t \n\t\tswitch (msg_no) {\n\t\tcase 0x00:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Home address area error\\n\");\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Count area error\\n\");\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Key area error\\n\");\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Data area error\\n\");\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - No sync byte in home address \"\n\t\t\t\t    \"area\\n\");\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - No sync byte in count address \"\n\t\t\t\t    \"area\\n\");\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - No sync byte in key area\\n\");\n\t\t\tbreak;\n\t\tcase 0x07:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - No sync byte in data area\\n\");\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Home address area error; \"\n\t\t\t\t    \"offset active\\n\");\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Count area error; offset \"\n\t\t\t\t    \"active\\n\");\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Key area error; offset \"\n\t\t\t\t    \"active\\n\");\n\t\t\tbreak;\n\t\tcase 0x0B:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Data area error; \"\n\t\t\t\t    \"offset active\\n\");\n\t\t\tbreak;\n\t\tcase 0x0C:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - No sync byte in home \"\n\t\t\t\t    \"address area; offset active\\n\");\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - No sync byte in count \"\n\t\t\t\t    \"address area; offset active\\n\");\n\t\t\tbreak;\n\t\tcase 0x0E:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - No sync byte in key area; \"\n\t\t\t\t    \"offset active\\n\");\n\t\t\tbreak;\n\t\tcase 0x0F:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - No sync byte in data area; \"\n\t\t\t\t    \"offset active\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 4 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x50:   \n\t\tswitch (msg_no) {\n\t\tcase 0x00:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 5 - Data Check in the \"\n\t\t\t\t    \"home address area\\n\");\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"FORMAT 5 - Data Check in the count \"\n\t\t\t\t \"area\\n\");\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 5 - Data Check in the key area\\n\");\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"FORMAT 5 - Data Check in the data \"\n\t\t\t\t \"area\\n\");\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 5 - Data Check in the \"\n\t\t\t\t    \"home address area; offset active\\n\");\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 5 - Data Check in the count area; \"\n\t\t\t\t    \"offset active\\n\");\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 5 - Data Check in the key area; \"\n\t\t\t\t    \"offset active\\n\");\n\t\t\tbreak;\n\t\tcase 0x0B:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 5 - Data Check in the data area; \"\n\t\t\t\t    \"offset active\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 5 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x60:   \n\t\tswitch (msg_no) {\n\t\tcase 0x00:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Overrun on channel A\\n\");\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Overrun on channel B\\n\");\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Overrun on channel C\\n\");\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Overrun on channel D\\n\");\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Overrun on channel E\\n\");\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Overrun on channel F\\n\");\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Overrun on channel G\\n\");\n\t\t\tbreak;\n\t\tcase 0x07:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Overrun on channel H\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 6 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x70:   \n\t\tswitch (msg_no) {\n\t\tcase 0x00:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - RCC initiated by a connection \"\n\t\t\t\t    \"check alert\\n\");\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - RCC 1 sequence not \"\n\t\t\t\t    \"successful\\n\");\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - RCC 1 and RCC 2 sequences not \"\n\t\t\t\t    \"successful\\n\");\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - Invalid tag-in during \"\n\t\t\t\t    \"selection sequence\\n\");\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - extra RCC required\\n\");\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - Invalid DCC selection \"\n\t\t\t\t    \"response or timeout\\n\");\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - Missing end operation; device \"\n\t\t\t\t    \"transfer complete\\n\");\n\t\t\tbreak;\n\t\tcase 0x07:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - Missing end operation; device \"\n\t\t\t\t    \"transfer incomplete\\n\");\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - Invalid tag-in for an \"\n\t\t\t\t    \"immediate command sequence\\n\");\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - Invalid tag-in for an \"\n\t\t\t\t    \"extended command sequence\\n\");\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - 3990 microcode time out when \"\n\t\t\t\t    \"stopping selection\\n\");\n\t\t\tbreak;\n\t\tcase 0x0B:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - No response to selection \"\n\t\t\t\t    \"after a poll interruption\\n\");\n\t\t\tbreak;\n\t\tcase 0x0C:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - Permanent path error (DASD \"\n\t\t\t\t    \"controller not available)\\n\");\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - DASD controller not available\"\n\t\t\t\t    \" on disconnected command chain\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 7 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x80:   \n\t\tswitch (msg_no) {\n\t\tcase 0x00:\t \n\t\tcase 0x01:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - Error correction code \"\n\t\t\t\t    \"hardware fault\\n\");\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - Unexpected end operation \"\n\t\t\t\t    \"response code\\n\");\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - End operation with transfer \"\n\t\t\t\t    \"count not zero\\n\");\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - End operation with transfer \"\n\t\t\t\t    \"count zero\\n\");\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - DPS checks after a system \"\n\t\t\t\t    \"reset or selective reset\\n\");\n\t\t\tbreak;\n\t\tcase 0x07:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - DPS cannot be filled\\n\");\n\t\t\tbreak;\n\t\tcase 0x08:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - Short busy time-out during \"\n\t\t\t\t    \"device selection\\n\");\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - DASD controller failed to \"\n\t\t\t\t    \"set or reset the long busy latch\\n\");\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - No interruption from device \"\n\t\t\t\t    \"during a command chain\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 8 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0x90:   \n\t\tswitch (msg_no) {\n\t\tcase 0x00:\n\t\t\tbreak;\t \n\t\tcase 0x06:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 9 - Device check-2 error\\n\");\n\t\t\tbreak;\n\t\tcase 0x07:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t \"FORMAT 9 - Head address did not \"\n\t\t\t\t \"compare\\n\");\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 9 - Track physical address did \"\n\t\t\t\t    \"not compare while oriented\\n\");\n\t\t\tbreak;\n\t\tcase 0x0E:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 9 - Cylinder address did not \"\n\t\t\t\t    \"compare\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT 9 - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tcase 0xF0:\t\t \n\t\tswitch (msg_no) {\n\t\tcase 0x00:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Operation Terminated\\n\");\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Subsystem Processing Error\\n\");\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Cache or nonvolatile storage \"\n\t\t\t\t    \"equipment failure\\n\");\n\t\t\tbreak;\n\t\tcase 0x04:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Caching terminated\\n\");\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Cache fast write access not \"\n\t\t\t\t    \"authorized\\n\");\n\t\t\tbreak;\n\t\tcase 0x07:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Track format incorrect\\n\");\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Caching reinitiated\\n\");\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Nonvolatile storage \"\n\t\t\t\t    \"terminated\\n\");\n\t\t\tbreak;\n\t\tcase 0x0B:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Volume is suspended duplex\\n\");\n\t\t\t \n\t\t\tdasd_eer_write(device, erp->refers,\n\t\t\t\t       DASD_EER_PPRCSUSPEND);\n\t\t\tbreak;\n\t\tcase 0x0C:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Subsystem status cannot be \"\n\t\t\t\t    \"determined\\n\");\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Caching status reset to \"\n\t\t\t\t    \"default\\n\");\n\t\t\tbreak;\n\t\tcase 0x0E:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - DASD Fast Write inhibited\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&device->cdev->dev,\n\t\t\t\t    \"FORMAT F - Reserved\\n\");\n\t\t}\n\t\tbreak;\n\n\tdefault:\t \n\t\tsnprintf(errorstring, ERRORLENGTH, \"03 %x02\", msg_format);\n\t\tdev_err(&device->cdev->dev,\n\t\t\t \"An error occurred in the DASD device driver, \"\n\t\t\t \"reason=%s\\n\", errorstring);\n\t\tbreak;\n\t}\t\t\t \n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_com_rej(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\terp->function = dasd_3990_erp_com_rej;\n\n\t \n\tif (sense[2] & SNS2_ENV_DATA_PRESENT) {\n\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Command Reject - environmental data present\");\n\n\t\tdasd_3990_handle_env_data(erp, sense);\n\n\t\terp->retries = 5;\n\n\t} else if (sense[1] & SNS1_WRITE_INHIBITED) {\n\t\tdev_err(&device->cdev->dev, \"An I/O request was rejected\"\n\t\t\t\" because writing is inhibited\\n\");\n\t\terp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\t} else if (sense[7] == SNS7_INVALID_ON_SEC) {\n\t\tdev_err(&device->cdev->dev, \"An I/O request was rejected on a copy pair secondary device\\n\");\n\t\t \n\t\tset_bit(DASD_CQR_SUPPRESS_CR, &erp->refers->flags);\n\t\terp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\t} else {\n\t\t \n\t\tif (!test_bit(DASD_CQR_SUPPRESS_CR, &erp->flags))\n\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t\"An error occurred in the DASD device driver, reason=09\\n\");\n\n\t\terp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_bus_out(struct dasd_ccw_req * erp)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\t \n\t \n\t \n\tif (erp->function != dasd_3990_erp_bus_out) {\n\t\terp->retries = 256;\n\t\terp->function = dasd_3990_erp_bus_out;\n\n\t} else {\n\n\t\t \n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"bus out parity error or BOPC requested by \"\n\t\t\t    \"channel\");\n\n\t\tdasd_3990_erp_block_queue(erp, 60*HZ);\n\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_equip_check(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\terp->function = dasd_3990_erp_equip_check;\n\n\tif (sense[1] & SNS1_WRITE_INHIBITED) {\n\t\tdev_info(&device->cdev->dev,\n\t\t\t    \"Write inhibited path encountered\\n\");\n\n\t\t \n\t\tdev_err(&device->cdev->dev, \"An error occurred in the DASD \"\n\t\t\t\"device driver, reason=%s\\n\", \"04\");\n\n\t\terp = dasd_3990_erp_action_1(erp);\n\n\t} else if (sense[2] & SNS2_ENV_DATA_PRESENT) {\n\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Equipment Check - \" \"environmental data present\");\n\n\t\tdasd_3990_handle_env_data(erp, sense);\n\n\t\terp = dasd_3990_erp_action_4(erp, sense);\n\n\t} else if (sense[1] & SNS1_PERM_ERR) {\n\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Equipment Check - retry exhausted or \"\n\t\t\t    \"undesirable\");\n\n\t\terp = dasd_3990_erp_action_1(erp);\n\n\t} else {\n\t\t \n\t\t \n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Equipment check or processing error\");\n\n\t\terp = dasd_3990_erp_action_5(erp);\n\t}\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_data_check(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\terp->function = dasd_3990_erp_data_check;\n\n\tif (sense[2] & SNS2_CORRECTABLE) {\t \n\n\t\t \n\t\tdev_emerg(&device->cdev->dev,\n\t\t\t    \"Data recovered during retry with PCI \"\n\t\t\t    \"fetch mode active\\n\");\n\n\t\t \n\t\tpanic(\"No way to inform application about the possibly \"\n\t\t      \"incorrect data\");\n\n\t} else if (sense[2] & SNS2_ENV_DATA_PRESENT) {\n\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Uncorrectable data check recovered secondary \"\n\t\t\t    \"addr of duplex pair\");\n\n\t\terp = dasd_3990_erp_action_4(erp, sense);\n\n\t} else if (sense[1] & SNS1_PERM_ERR) {\n\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Uncorrectable data check with internal \"\n\t\t\t    \"retry exhausted\");\n\n\t\terp = dasd_3990_erp_action_1(erp);\n\n\t} else {\n\t\t \n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Uncorrectable data check with retry count \"\n\t\t\t    \"exhausted...\");\n\n\t\terp = dasd_3990_erp_action_5(erp);\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_overrun(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\terp->function = dasd_3990_erp_overrun;\n\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t    \"Overrun - service overrun or overrun\"\n\t\t    \" error requested by channel\");\n\n\terp = dasd_3990_erp_action_5(erp);\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_inv_format(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\terp->function = dasd_3990_erp_inv_format;\n\n\tif (sense[2] & SNS2_ENV_DATA_PRESENT) {\n\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Track format error when destaging or \"\n\t\t\t    \"staging data\");\n\n\t\tdasd_3990_handle_env_data(erp, sense);\n\n\t\terp = dasd_3990_erp_action_4(erp, sense);\n\n\t} else {\n\t\t \n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"An error occurred in the DASD device driver, \"\n\t\t\t\"reason=%s\\n\", \"06\");\n\n\t\terp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_EOC(struct dasd_ccw_req * default_erp, char *sense)\n{\n\n\tstruct dasd_device *device = default_erp->startdev;\n\n\tdev_err(&device->cdev->dev,\n\t\t\"The cylinder data for accessing the DASD is inconsistent\\n\");\n\n\t \n\treturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_env_data(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\terp->function = dasd_3990_erp_env_data;\n\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\", \"Environmental data present\");\n\n\tdasd_3990_handle_env_data(erp, sense);\n\n\t \n\tif (sense[7] != 0x0F) {\n\t\terp = dasd_3990_erp_action_4(erp, sense);\n\t} else {\n\t\terp->status = DASD_CQR_FILLED;\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_no_rec(struct dasd_ccw_req * default_erp, char *sense)\n{\n\n\tstruct dasd_device *device = default_erp->startdev;\n\n\t \n\tif (!test_bit(DASD_CQR_SUPPRESS_NRF, &default_erp->flags))\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"The specified record was not found\\n\");\n\n\treturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_file_prot(struct dasd_ccw_req * erp)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\t \n\tif (!test_bit(DASD_CQR_SUPPRESS_FP, &erp->flags))\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"Accessing the DASD failed because of a hardware error\\n\");\n\n\treturn dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\n}\t\t\t\t \n\n \n\nstatic struct dasd_ccw_req *dasd_3990_erp_inspect_alias(\n\t\t\t\t\t\tstruct dasd_ccw_req *erp)\n{\n\tstruct dasd_ccw_req *cqr = erp->refers;\n\tchar *sense;\n\n\tif (cqr->block &&\n\t    (cqr->block->base != cqr->startdev)) {\n\n\t\tsense = dasd_get_sense(&erp->refers->irb);\n\t\t \n\t\tif (!test_bit(DASD_FLAG_OFFLINE, &cqr->startdev->flags) && sense\n\t\t    && (sense[0] == 0x10) && (sense[7] == 0x0F)\n\t\t    && (sense[8] == 0x67)) {\n\t\t\t \n\t\t\tdasd_alias_remove_device(cqr->startdev);\n\n\t\t\t \n\t\t\tdasd_reload_device(cqr->startdev);\n\t\t}\n\n\t\tif (cqr->startdev->features & DASD_FEATURE_ERPLOG) {\n\t\t\tDBF_DEV_EVENT(DBF_ERR, cqr->startdev,\n\t\t\t\t    \"ERP on alias device for request %p,\"\n\t\t\t\t    \" recover on base device %s\", cqr,\n\t\t\t\t    dev_name(&cqr->block->base->cdev->dev));\n\t\t}\n\t\tdasd_eckd_reset_ccw_to_base_io(cqr);\n\t\terp->startdev = cqr->block->base;\n\t\terp->function = dasd_3990_erp_inspect_alias;\n\t\treturn erp;\n\t} else\n\t\treturn NULL;\n}\n\n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_inspect_24(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_ccw_req *erp_filled = NULL;\n\n\t \n\t \n\tif ((erp_filled == NULL) && (sense[0] & SNS0_CMD_REJECT)) {\n\t\terp_filled = dasd_3990_erp_com_rej(erp, sense);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[0] & SNS0_INTERVENTION_REQ)) {\n\t\terp_filled = dasd_3990_erp_int_req(erp);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[0] & SNS0_BUS_OUT_CHECK)) {\n\t\terp_filled = dasd_3990_erp_bus_out(erp);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[0] & SNS0_EQUIPMENT_CHECK)) {\n\t\terp_filled = dasd_3990_erp_equip_check(erp, sense);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[0] & SNS0_DATA_CHECK)) {\n\t\terp_filled = dasd_3990_erp_data_check(erp, sense);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[0] & SNS0_OVERRUN)) {\n\t\terp_filled = dasd_3990_erp_overrun(erp, sense);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[1] & SNS1_INV_TRACK_FORMAT)) {\n\t\terp_filled = dasd_3990_erp_inv_format(erp, sense);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[1] & SNS1_EOC)) {\n\t\terp_filled = dasd_3990_erp_EOC(erp, sense);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[2] & SNS2_ENV_DATA_PRESENT)) {\n\t\terp_filled = dasd_3990_erp_env_data(erp, sense);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[1] & SNS1_NO_REC_FOUND)) {\n\t\terp_filled = dasd_3990_erp_no_rec(erp, sense);\n\t}\n\t \n\tif ((erp_filled == NULL) && (sense[1] & SNS1_FILE_PROTECTED)) {\n\t\terp_filled = dasd_3990_erp_file_prot(erp);\n\t}\n\t \n\tif (erp_filled == NULL) {\n\n\t\terp_filled = erp;\n\t}\n\n\treturn erp_filled;\n\n}\t\t\t\t \n\n \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_action_10_32(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\terp->retries = 256;\n\terp->function = dasd_3990_erp_action_10_32;\n\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\", \"Perform logging requested\");\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_action_1B_32(struct dasd_ccw_req * default_erp, char *sense)\n{\n\n\tstruct dasd_device *device = default_erp->startdev;\n\t__u32 cpa = 0;\n\tstruct dasd_ccw_req *cqr;\n\tstruct dasd_ccw_req *erp;\n\tstruct DE_eckd_data *DE_data;\n\tstruct PFX_eckd_data *PFX_data;\n\tchar *LO_data;\t\t \n\tstruct ccw1 *ccw, *oldccw;\n\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t    \"Write not finished because of unexpected condition\");\n\n\tdefault_erp->function = dasd_3990_erp_action_1B_32;\n\n\t \n\tcqr = default_erp;\n\n\twhile (cqr->refers != NULL) {\n\t\tcqr = cqr->refers;\n\t}\n\n\tif (scsw_is_tm(&cqr->irb.scsw)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"32 bit sense, action 1B is not defined\"\n\t\t\t      \" in transport mode - just retry\");\n\t\treturn default_erp;\n\t}\n\n\t \n\tif (sense[1] & 0x01) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Imprecise ending is set - just retry\");\n\n\t\treturn default_erp;\n\t}\n\n\t \n\t \n\tcpa = default_erp->refers->irb.scsw.cmd.cpa;\n\n\tif (cpa == 0) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Unable to determine address of the CCW \"\n\t\t\t    \"to be restarted\");\n\n\t\treturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\n\t}\n\n\t \n\terp = dasd_alloc_erp_request(cqr->magic,\n\t\t\t\t     2 + 1, \n\t\t\t\t     sizeof(struct DE_eckd_data) +\n\t\t\t\t     sizeof(struct LO_eckd_data), device);\n\n\tif (IS_ERR(erp)) {\n\t\t \n\t\tdev_err(&device->cdev->dev, \"An error occurred in the DASD \"\n\t\t\t\"device driver, reason=%s\\n\", \"01\");\n\t\treturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\n\t}\n\n\t \n\tDE_data = erp->data;\n\toldccw = cqr->cpaddr;\n\tif (oldccw->cmd_code == DASD_ECKD_CCW_PFX) {\n\t\tPFX_data = cqr->data;\n\t\tmemcpy(DE_data, &PFX_data->define_extent,\n\t\t       sizeof(struct DE_eckd_data));\n\t} else\n\t\tmemcpy(DE_data, cqr->data, sizeof(struct DE_eckd_data));\n\n\t \n\tLO_data = erp->data + sizeof(struct DE_eckd_data);\n\n\tif ((sense[3] == 0x01) && (LO_data[1] & 0x01)) {\n\t\t \n\t\treturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\n\t}\n\n\tif ((sense[7] & 0x3F) == 0x01) {\n\t\t \n\t\tLO_data[0] = 0x81;\n\n\t} else if ((sense[7] & 0x3F) == 0x03) {\n\t\t \n\t\tLO_data[0] = 0xC3;\n\n\t} else {\n\t\tLO_data[0] = sense[7];\t \n\t}\n\n\tLO_data[1] = sense[8];\t \n\tLO_data[2] = sense[9];\n\tLO_data[3] = sense[3];\t \n\tLO_data[4] = sense[29];\t \n\tLO_data[5] = sense[30];\t \n\tLO_data[7] = sense[31];\t \n\n\tmemcpy(&(LO_data[8]), &(sense[11]), 8);\n\n\t \n\tccw = erp->cpaddr;\n\tmemset(ccw, 0, sizeof(struct ccw1));\n\tccw->cmd_code = DASD_ECKD_CCW_DEFINE_EXTENT;\n\tccw->flags = CCW_FLAG_CC;\n\tccw->count = 16;\n\tccw->cda = (__u32)virt_to_phys(DE_data);\n\n\t \n\tccw++;\n\tmemset(ccw, 0, sizeof(struct ccw1));\n\tccw->cmd_code = DASD_ECKD_CCW_LOCATE_RECORD;\n\tccw->flags = CCW_FLAG_CC;\n\tccw->count = 16;\n\tccw->cda = (__u32)virt_to_phys(LO_data);\n\n\t \n\tccw++;\n\tccw->cmd_code = CCW_CMD_TIC;\n\tccw->cda = cpa;\n\n\t \n\terp->flags = default_erp->flags;\n\terp->function = dasd_3990_erp_action_1B_32;\n\terp->refers = default_erp->refers;\n\terp->startdev = device;\n\terp->memdev = device;\n\terp->magic = default_erp->magic;\n\terp->expires = default_erp->expires;\n\terp->retries = 256;\n\terp->buildclk = get_tod_clock();\n\terp->status = DASD_CQR_FILLED;\n\n\t \n\tdasd_free_erp_request(default_erp, device);\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_update_1B(struct dasd_ccw_req * previous_erp, char *sense)\n{\n\n\tstruct dasd_device *device = previous_erp->startdev;\n\t__u32 cpa = 0;\n\tstruct dasd_ccw_req *cqr;\n\tstruct dasd_ccw_req *erp;\n\tchar *LO_data;\t\t \n\tstruct ccw1 *ccw;\n\n\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t    \"Write not finished because of unexpected condition\"\n\t\t    \" - follow on\");\n\n\t \n\tcqr = previous_erp;\n\n\twhile (cqr->refers != NULL) {\n\t\tcqr = cqr->refers;\n\t}\n\n\tif (scsw_is_tm(&cqr->irb.scsw)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t      \"32 bit sense, action 1B, update,\"\n\t\t\t      \" in transport mode - just retry\");\n\t\treturn previous_erp;\n\t}\n\n\t \n\tif (sense[1] & 0x01) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"Imprecise ending is set - just retry\");\n\n\t\tprevious_erp->status = DASD_CQR_FILLED;\n\n\t\treturn previous_erp;\n\t}\n\n\t \n\t \n\tcpa = previous_erp->irb.scsw.cmd.cpa;\n\n\tif (cpa == 0) {\n\t\t \n\t\tdev_err(&device->cdev->dev, \"An error occurred in the DASD \"\n\t\t\t\"device driver, reason=%s\\n\", \"02\");\n\n\t\tprevious_erp->status = DASD_CQR_FAILED;\n\n\t\treturn previous_erp;\n\t}\n\n\terp = previous_erp;\n\n\t \n\tLO_data = erp->data + sizeof(struct DE_eckd_data);\n\n\tif ((sense[3] == 0x01) && (LO_data[1] & 0x01)) {\n\t\t \n\t\tprevious_erp->status = DASD_CQR_FAILED;\n\n\t\treturn previous_erp;\n\t}\n\n\tif ((sense[7] & 0x3F) == 0x01) {\n\t\t \n\t\tLO_data[0] = 0x81;\n\n\t} else if ((sense[7] & 0x3F) == 0x03) {\n\t\t \n\t\tLO_data[0] = 0xC3;\n\n\t} else {\n\t\tLO_data[0] = sense[7];\t \n\t}\n\n\tLO_data[1] = sense[8];\t \n\tLO_data[2] = sense[9];\n\tLO_data[3] = sense[3];\t \n\tLO_data[4] = sense[29];\t \n\tLO_data[5] = sense[30];\t \n\tLO_data[7] = sense[31];\t \n\n\tmemcpy(&(LO_data[8]), &(sense[11]), 8);\n\n\t \n\tccw = erp->cpaddr;\t \n\tccw++;\t\t\t \n\tccw++;\t\t\t \n\tccw->cda = cpa;\n\n\terp->status = DASD_CQR_FILLED;\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic void\ndasd_3990_erp_compound_retry(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tswitch (sense[25] & 0x03) {\n\tcase 0x00:\t\t \n\t\terp->retries = 1;\n\t\tbreak;\n\n\tcase 0x01:\t\t \n\t\terp->retries = 2;\n\t\tbreak;\n\n\tcase 0x02:\t\t \n\t\terp->retries = 10;\n\t\tbreak;\n\n\tcase 0x03:\t\t \n\t\terp->retries = 256;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\terp->function = dasd_3990_erp_compound_retry;\n\n}\t\t\t\t \n\n \nstatic void\ndasd_3990_erp_compound_path(struct dasd_ccw_req * erp, char *sense)\n{\n\tif (sense[25] & DASD_SENSE_BIT_3) {\n\t\tdasd_3990_erp_alternate_path(erp);\n\n\t\tif (erp->status == DASD_CQR_FAILED &&\n\t\t    !test_bit(DASD_CQR_VERIFY_PATH, &erp->flags)) {\n\t\t\t \n\t\t\terp->lpm = dasd_path_get_opm(erp->startdev);\n\t\t\terp->status = DASD_CQR_NEED_ERP;\n\t\t}\n\t}\n\n\terp->function = dasd_3990_erp_compound_path;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_compound_code(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tif (sense[25] & DASD_SENSE_BIT_2) {\n\n\t\tswitch (sense[28]) {\n\t\tcase 0x17:\n\t\t\t \n\t\t\terp = dasd_3990_erp_DCTL(erp, 0x20);\n\t\t\tbreak;\n\n\t\tcase 0x25:\n\t\t\t \n\t\t\terp->retries = 1;\n\n\t\t\tdasd_3990_erp_block_queue (erp, 5*HZ);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\terp->function = dasd_3990_erp_compound_code;\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic void\ndasd_3990_erp_compound_config(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tif ((sense[25] & DASD_SENSE_BIT_1) && (sense[26] & DASD_SENSE_BIT_2)) {\n\n\t\t \n\t\tstruct dasd_device *device = erp->startdev;\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"An error occurred in the DASD device driver, \"\n\t\t\t\"reason=%s\\n\", \"05\");\n\n\t}\n\n\terp->function = dasd_3990_erp_compound_config;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_compound(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tif ((erp->function == dasd_3990_erp_compound_retry) &&\n\t    (erp->status == DASD_CQR_NEED_ERP)) {\n\n\t\tdasd_3990_erp_compound_path(erp, sense);\n\t}\n\n\tif ((erp->function == dasd_3990_erp_compound_path) &&\n\t    (erp->status == DASD_CQR_NEED_ERP)) {\n\n\t\terp = dasd_3990_erp_compound_code(erp, sense);\n\t}\n\n\tif ((erp->function == dasd_3990_erp_compound_code) &&\n\t    (erp->status == DASD_CQR_NEED_ERP)) {\n\n\t\tdasd_3990_erp_compound_config(erp, sense);\n\t}\n\n\t \n\tif (erp->status == DASD_CQR_NEED_ERP)\n\t\terp->status = DASD_CQR_FAILED;\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nvoid\ndasd_3990_erp_handle_sim(struct dasd_device *device, char *sense)\n{\n\t \n\tif ((sense[24] & DASD_SIM_MSG_TO_OP) || (sense[1] & 0x10)) {\n\t\t \n\t\tdev_err(&device->cdev->dev, \"SIM - SRC: \"\n\t\t\t    \"%02x%02x%02x%02x\\n\", sense[22],\n\t\t\t    sense[23], sense[11], sense[12]);\n\t} else if (sense[24] & DASD_SIM_LOG) {\n\t\t \n\t\tdev_warn(&device->cdev->dev, \"log SIM - SRC: \"\n\t\t\t    \"%02x%02x%02x%02x\\n\", sense[22],\n\t\t\t    sense[23], sense[11], sense[12]);\n\t}\n}\n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_inspect_32(struct dasd_ccw_req * erp, char *sense)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\terp->function = dasd_3990_erp_inspect_32;\n\n\t \n\tif ((sense[6] & DASD_SIM_SENSE) == DASD_SIM_SENSE)\n\t\tdasd_3990_erp_handle_sim(device, sense);\n\n\tif (sense[25] & DASD_SENSE_BIT_0) {\n\n\t\t \n\t\tdasd_3990_erp_compound_retry(erp, sense);\n\n\t} else {\n\n\t\t \n\t\tswitch (sense[25]) {\n\n\t\tcase 0x00:\t \n\t\t\tDBF_DEV_EVENT(DBF_DEBUG, device, \"%s\",\n\t\t\t\t    \"ERP called for successful request\"\n\t\t\t\t    \" - just retry\");\n\t\t\tbreak;\n\n\t\tcase 0x01:\t \n\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t    \"ERP failed for the DASD\\n\");\n\n\t\t\terp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\t\t\tbreak;\n\n\t\tcase 0x02:\t \n\t\tcase 0x03:\t \n\t\t\terp = dasd_3990_erp_int_req(erp);\n\t\t\tbreak;\n\n\t\tcase 0x0F:   \n\t\t\tdev_err(&device->cdev->dev, \"An error occurred in the \"\n\t\t\t\t\"DASD device driver, reason=%s\\n\", \"08\");\n\n\t\t\terp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\t\t\tbreak;\n\n\t\tcase 0x10:   \n\t\t\terp = dasd_3990_erp_action_10_32(erp, sense);\n\t\t\tbreak;\n\n\t\tcase 0x15:\t \n\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t\"An error occurred in the DASD device driver, \"\n\t\t\t\t\"reason=%s\\n\", \"07\");\n\n\t\t\terp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\t\t\tbreak;\n\n\t\tcase 0x1B:\t \n\n\t\t\terp = dasd_3990_erp_action_1B_32(erp, sense);\n\t\t\tbreak;\n\n\t\tcase 0x1C:\t \n\t\t\tdev_emerg(&device->cdev->dev,\n\t\t\t\t    \"Data recovered during retry with PCI \"\n\t\t\t\t    \"fetch mode active\\n\");\n\n\t\t\t \n\t\t\tpanic\n\t\t\t    (\"Invalid data - No way to inform application \"\n\t\t\t     \"about the possibly incorrect data\");\n\t\t\tbreak;\n\n\t\tcase 0x1D:\t \n\t\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t\t    \"A State change pending condition exists \"\n\t\t\t\t    \"for the subsystem or device\");\n\n\t\t\terp = dasd_3990_erp_action_4(erp, sense);\n\t\t\tbreak;\n\n\t\tcase 0x1E:\t \n\t\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t\t    \"Busy condition exists \"\n\t\t\t\t    \"for the subsystem or device\");\n                        erp = dasd_3990_erp_action_4(erp, sense);\n\t\t\tbreak;\n\n\t\tdefault:\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\nstatic void dasd_3990_erp_disable_path(struct dasd_device *device, __u8 lpum)\n{\n\tint pos = pathmask_to_pos(lpum);\n\n\tif (!(device->features & DASD_FEATURE_PATH_AUTODISABLE)) {\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"Path %x.%02x (pathmask %02x) is operational despite excessive IFCCs\\n\",\n\t\t\tdevice->path[pos].cssid, device->path[pos].chpid, lpum);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(dasd_path_get_opm(device) & ~lpum)) {\n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"Last path %x.%02x (pathmask %02x) is operational despite excessive IFCCs\\n\",\n\t\t\tdevice->path[pos].cssid, device->path[pos].chpid, lpum);\n\t\tgoto out;\n\t}\n\n\tdev_err(&device->cdev->dev,\n\t\t\"Path %x.%02x (pathmask %02x) is disabled - IFCC threshold exceeded\\n\",\n\t\tdevice->path[pos].cssid, device->path[pos].chpid, lpum);\n\tdasd_path_remove_opm(device, lpum);\n\tdasd_path_add_ifccpm(device, lpum);\n\nout:\n\tdevice->path[pos].errorclk = 0;\n\tatomic_set(&device->path[pos].error_count, 0);\n}\n\nstatic void dasd_3990_erp_account_error(struct dasd_ccw_req *erp)\n{\n\tstruct dasd_device *device = erp->startdev;\n\t__u8 lpum = erp->refers->irb.esw.esw1.lpum;\n\tint pos = pathmask_to_pos(lpum);\n\tunsigned long clk;\n\n\tif (!device->path_thrhld)\n\t\treturn;\n\n\tclk = get_tod_clock();\n\t \n\tif ((tod_to_ns(clk - device->path[pos].errorclk) / NSEC_PER_SEC)\n\t    >= device->path_interval) {\n\t\tatomic_set(&device->path[pos].error_count, 0);\n\t\tdevice->path[pos].errorclk = 0;\n\t}\n\tatomic_inc(&device->path[pos].error_count);\n\tdevice->path[pos].errorclk = clk;\n\t \n\tif (atomic_read(&device->path[pos].error_count) >=\n\t    device->path_thrhld)\n\t\tdasd_3990_erp_disable_path(device, lpum);\n}\n\n \n\n \n\nstatic struct dasd_ccw_req *\ndasd_3990_erp_control_check(struct dasd_ccw_req *erp)\n{\n\tstruct dasd_device *device = erp->startdev;\n\n\tif (scsw_cstat(&erp->refers->irb.scsw) & (SCHN_STAT_INTF_CTRL_CHK\n\t\t\t\t\t   | SCHN_STAT_CHN_CTRL_CHK)) {\n\t\tDBF_DEV_EVENT(DBF_WARNING, device, \"%s\",\n\t\t\t    \"channel or interface control check\");\n\t\tdasd_3990_erp_account_error(erp);\n\t\terp = dasd_3990_erp_action_4(erp, NULL);\n\t}\n\treturn erp;\n}\n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_inspect(struct dasd_ccw_req *erp)\n{\n\n\tstruct dasd_ccw_req *erp_new = NULL;\n\tchar *sense;\n\n\t \n\terp_new = dasd_3990_erp_inspect_alias(erp);\n\tif (erp_new)\n\t\treturn erp_new;\n\n\t \n\tsense = dasd_get_sense(&erp->refers->irb);\n\tif (!sense)\n\t\terp_new = dasd_3990_erp_control_check(erp);\n\t \n\telse if (sense[27] & DASD_SENSE_BIT_0) {\n\n\t\t \n\t\terp_new = dasd_3990_erp_inspect_24(erp, sense);\n\n\t} else {\n\n\t\t \n\t\terp_new = dasd_3990_erp_inspect_32(erp, sense);\n\n\t}\t \n\n\treturn erp_new;\n}\n\n \nstatic struct dasd_ccw_req *dasd_3990_erp_add_erp(struct dasd_ccw_req *cqr)\n{\n\n\tstruct dasd_device *device = cqr->startdev;\n\tstruct ccw1 *ccw;\n\tstruct dasd_ccw_req *erp;\n\tint cplength, datasize;\n\tstruct tcw *tcw;\n\tstruct tsb *tsb;\n\n\tif (cqr->cpmode == 1) {\n\t\tcplength = 0;\n\t\t \n\t\tdatasize = 64 + sizeof(struct tcw) + sizeof(struct tsb);\n\t} else {\n\t\tcplength = 2;\n\t\tdatasize = 0;\n\t}\n\n\t \n\terp = dasd_alloc_erp_request(cqr->magic,\n\t\t\t\t     cplength, datasize, device);\n\tif (IS_ERR(erp)) {\n                if (cqr->retries <= 0) {\n\t\t\tDBF_DEV_EVENT(DBF_ERR, device, \"%s\",\n\t\t\t\t    \"Unable to allocate ERP request\");\n\t\t\tcqr->status = DASD_CQR_FAILED;\n\t\t\tcqr->stopclk = get_tod_clock();\n\t\t} else {\n\t\t\tDBF_DEV_EVENT(DBF_ERR, device,\n                                     \"Unable to allocate ERP request \"\n\t\t\t\t     \"(%i retries left)\",\n                                     cqr->retries);\n\t\t\tdasd_block_set_timer(device->block, (HZ << 3));\n                }\n\t\treturn erp;\n\t}\n\n\tccw = cqr->cpaddr;\n\tif (cqr->cpmode == 1) {\n\t\t \n\t\terp->cpmode = 1;\n\t\terp->cpaddr = PTR_ALIGN(erp->data, 64);\n\t\ttcw = erp->cpaddr;\n\t\ttsb = (struct tsb *) &tcw[1];\n\t\t*tcw = *((struct tcw *)cqr->cpaddr);\n\t\ttcw->tsb = virt_to_phys(tsb);\n\t} else if (ccw->cmd_code == DASD_ECKD_CCW_PSF) {\n\t\t \n\t\terp->cpaddr = cqr->cpaddr;\n\t} else {\n\t\t \n\t\tccw = erp->cpaddr;\n\t\tccw->cmd_code = CCW_CMD_NOOP;\n\t\tccw->flags = CCW_FLAG_CC;\n\t\tccw++;\n\t\tccw->cmd_code = CCW_CMD_TIC;\n\t\tccw->cda      = (__u32)virt_to_phys(cqr->cpaddr);\n\t}\n\n\terp->flags = cqr->flags;\n\terp->function = dasd_3990_erp_add_erp;\n\terp->refers   = cqr;\n\terp->startdev = device;\n\terp->memdev   = device;\n\terp->block    = cqr->block;\n\terp->magic    = cqr->magic;\n\terp->expires  = cqr->expires;\n\terp->retries  = device->default_retries;\n\terp->buildclk = get_tod_clock();\n\terp->status = DASD_CQR_FILLED;\n\n\treturn erp;\n}\n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_additional_erp(struct dasd_ccw_req * cqr)\n{\n\n\tstruct dasd_ccw_req *erp = NULL;\n\n\t \n\terp = dasd_3990_erp_add_erp(cqr);\n\n\tif (IS_ERR(erp))\n\t\treturn erp;\n\n\t \n\tif (erp != cqr) {\n\n\t\terp = dasd_3990_erp_inspect(erp);\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic int dasd_3990_erp_error_match(struct dasd_ccw_req *cqr1,\n\t\t\t\t     struct dasd_ccw_req *cqr2)\n{\n\tchar *sense1, *sense2;\n\n\tif (cqr1->startdev != cqr2->startdev)\n\t\treturn 0;\n\n\tsense1 = dasd_get_sense(&cqr1->irb);\n\tsense2 = dasd_get_sense(&cqr2->irb);\n\n\t \n\tif (!sense1 != !sense2)\n\t\treturn 0;\n\t \n\tif (!sense1 && !sense2)\t{\n\t\tif ((scsw_cstat(&cqr1->irb.scsw) & (SCHN_STAT_INTF_CTRL_CHK |\n\t\t\t\t\t\t    SCHN_STAT_CHN_CTRL_CHK)) ==\n\t\t    (scsw_cstat(&cqr2->irb.scsw) & (SCHN_STAT_INTF_CTRL_CHK |\n\t\t\t\t\t\t    SCHN_STAT_CHN_CTRL_CHK)))\n\t\t\treturn 1;  \n\t}\n\t \n\tif (!(sense1 && sense2 &&\n\t      (memcmp(sense1, sense2, 3) == 0) &&\n\t      (sense1[27] == sense2[27]) &&\n\t      (sense1[25] == sense2[25]))) {\n\n\t\treturn 0;\t \n\t}\n\n\treturn 1;\t\t \n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_in_erp(struct dasd_ccw_req *cqr)\n{\n\n\tstruct dasd_ccw_req *erp_head = cqr,\t \n\t*erp_match = NULL;\t \n\tint match = 0;\t\t \n\n\tif (cqr->refers == NULL) {\t \n\t\treturn NULL;\n\t}\n\n\t \n\tdo {\n\t\tmatch = dasd_3990_erp_error_match(erp_head, cqr->refers);\n\t\terp_match = cqr;\t \n\t\tcqr = cqr->refers;\t \n\n\t} while ((cqr->refers != NULL) && (!match));\n\n\tif (!match) {\n\t\treturn NULL;\t \n\t}\n\n\treturn erp_match;\t \n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_further_erp(struct dasd_ccw_req *erp)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\tchar *sense = dasd_get_sense(&erp->irb);\n\n\t \n\tif ((erp->function == dasd_3990_erp_bus_out) ||\n\t    (erp->function == dasd_3990_erp_action_1) ||\n\t    (erp->function == dasd_3990_erp_action_4)) {\n\n\t\terp = dasd_3990_erp_action_1(erp);\n\n\t} else if (erp->function == dasd_3990_erp_action_1_sec) {\n\t\terp = dasd_3990_erp_action_1_sec(erp);\n\t} else if (erp->function == dasd_3990_erp_action_5) {\n\n\t\t \n\t\t \n\t\terp = dasd_3990_erp_action_1(erp);\n\n\t\tif (sense && !(sense[2] & DASD_SENSE_BIT_0)) {\n\n\t\t\t \n\n\t\t\tswitch (sense[25]) {\n\t\t\tcase 0x17:\n\t\t\tcase 0x57:{\t \n\t\t\t\t\terp = dasd_3990_erp_DCTL(erp, 0x20);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 0x18:\n\t\t\tcase 0x58:{\t \n\t\t\t\t\terp = dasd_3990_erp_DCTL(erp, 0x40);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 0x19:\n\t\t\tcase 0x59:{\t \n\t\t\t\t\terp = dasd_3990_erp_DCTL(erp, 0x80);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tDBF_DEV_EVENT(DBF_WARNING, device,\n\t\t\t\t\t    \"invalid subcommand modifier 0x%x \"\n\t\t\t\t\t    \"for Diagnostic Control Command\",\n\t\t\t\t\t    sense[25]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t} else if (sense &&\n\t\t   ((erp->function == dasd_3990_erp_compound_retry) ||\n\t\t    (erp->function == dasd_3990_erp_compound_path) ||\n\t\t    (erp->function == dasd_3990_erp_compound_code) ||\n\t\t    (erp->function == dasd_3990_erp_compound_config))) {\n\n\t\terp = dasd_3990_erp_compound(erp, sense);\n\n\t} else {\n\t\t \n\t\tdev_err(&device->cdev->dev,\n\t\t\t\"ERP %p has run out of retries and failed\\n\", erp);\n\n\t\terp->status = DASD_CQR_FAILED;\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstatic struct dasd_ccw_req *\ndasd_3990_erp_handle_match_erp(struct dasd_ccw_req *erp_head,\n\t\t\t       struct dasd_ccw_req *erp)\n{\n\n\tstruct dasd_device *device = erp_head->startdev;\n\tstruct dasd_ccw_req *erp_done = erp_head;\t \n\tstruct dasd_ccw_req *erp_free = NULL;\t \n\n\t \n\twhile (erp_done != erp) {\n\n\t\tif (erp_done == NULL)\t \n\t\t\tpanic(PRINTK_HEADER \"Programming error in ERP! The \"\n\t\t\t      \"original request was lost\\n\");\n\n\t\t \n\t\tlist_del(&erp_done->blocklist);\n\n\t\terp_free = erp_done;\n\t\terp_done = erp_done->refers;\n\n\t\t \n\t\tdasd_free_erp_request(erp_free, erp_free->memdev);\n\n\t}\t\t\t \n\n\tif (erp->retries > 0) {\n\n\t\tchar *sense = dasd_get_sense(&erp->refers->irb);\n\n\t\t \n\t\tif (sense && erp->function == dasd_3990_erp_action_4) {\n\n\t\t\terp = dasd_3990_erp_action_4(erp, sense);\n\n\t\t} else if (sense &&\n\t\t\t   erp->function == dasd_3990_erp_action_1B_32) {\n\n\t\t\terp = dasd_3990_update_1B(erp, sense);\n\n\t\t} else if (sense && erp->function == dasd_3990_erp_int_req) {\n\n\t\t\terp = dasd_3990_erp_int_req(erp);\n\n\t\t} else {\n\t\t\t \n\t\t\tDBF_DEV_EVENT(DBF_DEBUG, device,\n\t\t\t\t    \"%i retries left for erp %p\",\n\t\t\t\t    erp->retries, erp);\n\n\t\t\t \n\t\t\terp->status = DASD_CQR_FILLED;\n\t\t}\n\n\t} else {\n\t\t \n\t\t \n\t\terp = dasd_3990_erp_further_erp(erp);\n\t}\n\n\treturn erp;\n\n}\t\t\t\t \n\n \nstruct dasd_ccw_req *\ndasd_3990_erp_action(struct dasd_ccw_req * cqr)\n{\n\tstruct dasd_ccw_req *erp = NULL;\n\tstruct dasd_device *device = cqr->startdev;\n\tstruct dasd_ccw_req *temp_erp = NULL;\n\n\tif (device->features & DASD_FEATURE_ERPLOG) {\n\t\t \n\t\tdev_err(&device->cdev->dev,\n\t\t\t    \"ERP chain at BEGINNING of ERP-ACTION\\n\");\n\t\tfor (temp_erp = cqr;\n\t\t     temp_erp != NULL; temp_erp = temp_erp->refers) {\n\n\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t    \"ERP %p (%02x) refers to %p\\n\",\n\t\t\t\t    temp_erp, temp_erp->status,\n\t\t\t\t    temp_erp->refers);\n\t\t}\n\t}\n\n\t \n\tif ((scsw_cstat(&cqr->irb.scsw) == 0x00) &&\n\t    (scsw_dstat(&cqr->irb.scsw) ==\n\t     (DEV_STAT_CHN_END | DEV_STAT_DEV_END))) {\n\n\t\tDBF_DEV_EVENT(DBF_DEBUG, device,\n\t\t\t    \"ERP called for successful request %p\"\n\t\t\t    \" - NO ERP necessary\", cqr);\n\n\t\tcqr->status = DASD_CQR_DONE;\n\n\t\treturn cqr;\n\t}\n\n\t \n\terp = dasd_3990_erp_in_erp(cqr);\n\n\tif (erp == NULL) {\n\t\t \n\t\terp = dasd_3990_erp_additional_erp(cqr);\n\t\tif (IS_ERR(erp))\n\t\t\treturn erp;\n\t} else {\n\t\t \n\t\terp = dasd_3990_erp_handle_match_erp(cqr, erp);\n\t}\n\n\n\t \n\tif (test_bit(DASD_CQR_VERIFY_PATH, &erp->flags) && cqr->lpm) {\n\t\terp->lpm = cqr->lpm;\n\t}\n\n\tif (device->features & DASD_FEATURE_ERPLOG) {\n\t\t \n\t\tdev_err(&device->cdev->dev,\n\t\t\t    \"ERP chain at END of ERP-ACTION\\n\");\n\t\tfor (temp_erp = erp;\n\t\t     temp_erp != NULL; temp_erp = temp_erp->refers) {\n\n\t\t\tdev_err(&device->cdev->dev,\n\t\t\t\t    \"ERP %p (%02x) refers to %p\\n\",\n\t\t\t\t    temp_erp, temp_erp->status,\n\t\t\t\t    temp_erp->refers);\n\t\t}\n\t}\n\n\t \n\tif (list_empty(&erp->blocklist)) {\n\t\tcqr->status = DASD_CQR_IN_ERP;\n\t\t \n\t\tlist_add_tail(&erp->blocklist, &cqr->blocklist);\n\t}\n\n\n\n\treturn erp;\n\n}\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}