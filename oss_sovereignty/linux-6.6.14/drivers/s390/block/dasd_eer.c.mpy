{
  "module_name": "dasd_eer.c",
  "hash_id": "77bf43e5c36540791dd5276b8496b89e2d221e4cbb622256b5eba4eedb8d1c85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/block/dasd_eer.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"dasd-eckd\"\n\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/poll.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n#include <asm/ebcdic.h>\n\n#include \"dasd_int.h\"\n#include \"dasd_eckd.h\"\n\n#ifdef PRINTK_HEADER\n#undef PRINTK_HEADER\n#endif\t\t\t\t \n#define PRINTK_HEADER \"dasd(eer):\"\n\n \n\n \n\nstatic int eer_pages = 5;\nmodule_param(eer_pages, int, S_IRUGO|S_IWUSR);\n\nstruct eerbuffer {\n\tstruct list_head list;\n\tchar **buffer;\n\tint buffersize;\n\tint buffer_page_count;\n\tint head;\n        int tail;\n\tint residual;\n};\n\nstatic LIST_HEAD(bufferlist);\nstatic DEFINE_SPINLOCK(bufferlock);\nstatic DECLARE_WAIT_QUEUE_HEAD(dasd_eer_read_wait_queue);\n\n \nstatic int dasd_eer_get_free_bytes(struct eerbuffer *eerb)\n{\n\tif (eerb->head < eerb->tail)\n\t\treturn eerb->tail - eerb->head - 1;\n\treturn eerb->buffersize - eerb->head + eerb->tail -1;\n}\n\n \nstatic int dasd_eer_get_filled_bytes(struct eerbuffer *eerb)\n{\n\n\tif (eerb->head >= eerb->tail)\n\t\treturn eerb->head - eerb->tail;\n\treturn eerb->buffersize - eerb->tail + eerb->head;\n}\n\n \nstatic void dasd_eer_write_buffer(struct eerbuffer *eerb,\n\t\t\t\t  char *data, int count)\n{\n\n\tunsigned long headindex,localhead;\n\tunsigned long rest, len;\n\tchar *nextdata;\n\n\tnextdata = data;\n\trest = count;\n\twhile (rest > 0) {\n \t\theadindex = eerb->head / PAGE_SIZE;\n \t\tlocalhead = eerb->head % PAGE_SIZE;\n\t\tlen = min(rest, PAGE_SIZE - localhead);\n\t\tmemcpy(eerb->buffer[headindex]+localhead, nextdata, len);\n\t\tnextdata += len;\n\t\trest -= len;\n\t\teerb->head += len;\n\t\tif (eerb->head == eerb->buffersize)\n\t\t\teerb->head = 0;  \n\t\tBUG_ON(eerb->head > eerb->buffersize);\n\t}\n}\n\n \nstatic int dasd_eer_read_buffer(struct eerbuffer *eerb, char *data, int count)\n{\n\n\tunsigned long tailindex,localtail;\n\tunsigned long rest, len, finalcount;\n\tchar *nextdata;\n\n\tfinalcount = min(count, dasd_eer_get_filled_bytes(eerb));\n\tnextdata = data;\n\trest = finalcount;\n\twhile (rest > 0) {\n \t\ttailindex = eerb->tail / PAGE_SIZE;\n \t\tlocaltail = eerb->tail % PAGE_SIZE;\n\t\tlen = min(rest, PAGE_SIZE - localtail);\n\t\tmemcpy(nextdata, eerb->buffer[tailindex] + localtail, len);\n\t\tnextdata += len;\n\t\trest -= len;\n\t\teerb->tail += len;\n\t\tif (eerb->tail == eerb->buffersize)\n\t\t\teerb->tail = 0;  \n\t\tBUG_ON(eerb->tail > eerb->buffersize);\n\t}\n\treturn finalcount;\n}\n\n \nstatic int dasd_eer_start_record(struct eerbuffer *eerb, int count)\n{\n\tint tailcount;\n\n\tif (count + sizeof(count) > eerb->buffersize)\n\t\treturn -ENOMEM;\n\twhile (dasd_eer_get_free_bytes(eerb) < count + sizeof(count)) {\n\t\tif (eerb->residual > 0) {\n\t\t\teerb->tail += eerb->residual;\n\t\t\tif (eerb->tail >= eerb->buffersize)\n\t\t\t\teerb->tail -= eerb->buffersize;\n\t\t\teerb->residual = -1;\n\t\t}\n\t\tdasd_eer_read_buffer(eerb, (char *) &tailcount,\n\t\t\t\t     sizeof(tailcount));\n\t\teerb->tail += tailcount;\n\t\tif (eerb->tail >= eerb->buffersize)\n\t\t\teerb->tail -= eerb->buffersize;\n\t}\n\tdasd_eer_write_buffer(eerb, (char*) &count, sizeof(count));\n\n\treturn 0;\n};\n\n \nstatic void dasd_eer_free_buffer_pages(char **buf, int no_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < no_pages; i++)\n\t\tfree_page((unsigned long) buf[i]);\n}\n\n \nstatic int dasd_eer_allocate_buffer_pages(char **buf, int no_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < no_pages; i++) {\n\t\tbuf[i] = (char *) get_zeroed_page(GFP_KERNEL);\n\t\tif (!buf[i]) {\n\t\t\tdasd_eer_free_buffer_pages(buf, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\n \n\n#define SNSS_DATA_SIZE 44\n\n#define DASD_EER_BUSID_SIZE 10\nstruct dasd_eer_header {\n\t__u32 total_size;\n\t__u32 trigger;\n\t__u64 tv_sec;\n\t__u64 tv_usec;\n\tchar busid[DASD_EER_BUSID_SIZE];\n} __attribute__ ((packed));\n\n \nstatic void dasd_eer_write_standard_trigger(struct dasd_device *device,\n\t\t\t\t\t    struct dasd_ccw_req *cqr,\n\t\t\t\t\t    int trigger)\n{\n\tstruct dasd_ccw_req *temp_cqr;\n\tint data_size;\n\tstruct timespec64 ts;\n\tstruct dasd_eer_header header;\n\tunsigned long flags;\n\tstruct eerbuffer *eerb;\n\tchar *sense;\n\n\t \n\tdata_size = 0;\n\tfor (temp_cqr = cqr; temp_cqr; temp_cqr = temp_cqr->refers)\n\t\tif (dasd_get_sense(&temp_cqr->irb))\n\t\t\tdata_size += 32;\n\n\theader.total_size = sizeof(header) + data_size + 4;  \n\theader.trigger = trigger;\n\tktime_get_real_ts64(&ts);\n\theader.tv_sec = ts.tv_sec;\n\theader.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\tstrscpy(header.busid, dev_name(&device->cdev->dev),\n\t\tDASD_EER_BUSID_SIZE);\n\n\tspin_lock_irqsave(&bufferlock, flags);\n\tlist_for_each_entry(eerb, &bufferlist, list) {\n\t\tdasd_eer_start_record(eerb, header.total_size);\n\t\tdasd_eer_write_buffer(eerb, (char *) &header, sizeof(header));\n\t\tfor (temp_cqr = cqr; temp_cqr; temp_cqr = temp_cqr->refers) {\n\t\t\tsense = dasd_get_sense(&temp_cqr->irb);\n\t\t\tif (sense)\n\t\t\t\tdasd_eer_write_buffer(eerb, sense, 32);\n\t\t}\n\t\tdasd_eer_write_buffer(eerb, \"EOR\", 4);\n\t}\n\tspin_unlock_irqrestore(&bufferlock, flags);\n\twake_up_interruptible(&dasd_eer_read_wait_queue);\n}\n\n \nstatic void dasd_eer_write_snss_trigger(struct dasd_device *device,\n\t\t\t\t\tstruct dasd_ccw_req *cqr,\n\t\t\t\t\tint trigger)\n{\n\tint data_size;\n\tint snss_rc;\n\tstruct timespec64 ts;\n\tstruct dasd_eer_header header;\n\tunsigned long flags;\n\tstruct eerbuffer *eerb;\n\n\tsnss_rc = (cqr->status == DASD_CQR_DONE) ? 0 : -EIO;\n\tif (snss_rc)\n\t\tdata_size = 0;\n\telse\n\t\tdata_size = SNSS_DATA_SIZE;\n\n\theader.total_size = sizeof(header) + data_size + 4;  \n\theader.trigger = DASD_EER_STATECHANGE;\n\tktime_get_real_ts64(&ts);\n\theader.tv_sec = ts.tv_sec;\n\theader.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\tstrscpy(header.busid, dev_name(&device->cdev->dev),\n\t\tDASD_EER_BUSID_SIZE);\n\n\tspin_lock_irqsave(&bufferlock, flags);\n\tlist_for_each_entry(eerb, &bufferlist, list) {\n\t\tdasd_eer_start_record(eerb, header.total_size);\n\t\tdasd_eer_write_buffer(eerb, (char *) &header , sizeof(header));\n\t\tif (!snss_rc)\n\t\t\tdasd_eer_write_buffer(eerb, cqr->data, SNSS_DATA_SIZE);\n\t\tdasd_eer_write_buffer(eerb, \"EOR\", 4);\n\t}\n\tspin_unlock_irqrestore(&bufferlock, flags);\n\twake_up_interruptible(&dasd_eer_read_wait_queue);\n}\n\n \nvoid dasd_eer_write(struct dasd_device *device, struct dasd_ccw_req *cqr,\n\t\t    unsigned int id)\n{\n\tif (!device->eer_cqr)\n\t\treturn;\n\tswitch (id) {\n\tcase DASD_EER_FATALERROR:\n\tcase DASD_EER_PPRCSUSPEND:\n\t\tdasd_eer_write_standard_trigger(device, cqr, id);\n\t\tbreak;\n\tcase DASD_EER_NOPATH:\n\tcase DASD_EER_NOSPC:\n\tcase DASD_EER_AUTOQUIESCE:\n\t\tdasd_eer_write_standard_trigger(device, NULL, id);\n\t\tbreak;\n\tcase DASD_EER_STATECHANGE:\n\t\tdasd_eer_write_snss_trigger(device, cqr, id);\n\t\tbreak;\n\tdefault:  \n\t\tdasd_eer_write_standard_trigger(device, NULL, id);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(dasd_eer_write);\n\n \nvoid dasd_eer_snss(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\n\tcqr = device->eer_cqr;\n\tif (!cqr)\t \n\t\treturn;\n\tif (test_and_set_bit(DASD_FLAG_EER_IN_USE, &device->flags)) {\n\t\t \n\t\tset_bit(DASD_FLAG_EER_SNSS, &device->flags);\n\t\treturn;\n\t}\n\t \n\tclear_bit(DASD_FLAG_EER_SNSS, &device->flags);\n\tcqr->status = DASD_CQR_QUEUED;\n\tlist_add(&cqr->devlist, &device->ccw_queue);\n\tdasd_schedule_device_bh(device);\n}\n\n \nstatic void dasd_eer_snss_cb(struct dasd_ccw_req *cqr, void *data)\n{\n\tstruct dasd_device *device = cqr->startdev;\n\tunsigned long flags;\n\n\tdasd_eer_write(device, cqr, DASD_EER_STATECHANGE);\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tif (device->eer_cqr == cqr) {\n\t\tclear_bit(DASD_FLAG_EER_IN_USE, &device->flags);\n\t\tif (test_bit(DASD_FLAG_EER_SNSS, &device->flags))\n\t\t\t \n\t\t\tdasd_eer_snss(device);\n\t\tcqr = NULL;\n\t}\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\tif (cqr)\n\t\t \n\t\tdasd_sfree_request(cqr, device);\n}\n\n \nint dasd_eer_enable(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr = NULL;\n\tunsigned long flags;\n\tstruct ccw1 *ccw;\n\tint rc = 0;\n\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tif (device->eer_cqr)\n\t\tgoto out;\n\telse if (!device->discipline ||\n\t\t strcmp(device->discipline->name, \"ECKD\"))\n\t\trc = -EMEDIUMTYPE;\n\telse if (test_bit(DASD_FLAG_OFFLINE, &device->flags))\n\t\trc = -EBUSY;\n\n\tif (rc)\n\t\tgoto out;\n\n\tcqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1  ,\n\t\t\t\t   SNSS_DATA_SIZE, device, NULL);\n\tif (IS_ERR(cqr)) {\n\t\trc = -ENOMEM;\n\t\tcqr = NULL;\n\t\tgoto out;\n\t}\n\n\tcqr->startdev = device;\n\tcqr->retries = 255;\n\tcqr->expires = 10 * HZ;\n\tclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\n\tset_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags);\n\n\tccw = cqr->cpaddr;\n\tccw->cmd_code = DASD_ECKD_CCW_SNSS;\n\tccw->count = SNSS_DATA_SIZE;\n\tccw->flags = 0;\n\tccw->cda = (__u32)virt_to_phys(cqr->data);\n\n\tcqr->buildclk = get_tod_clock();\n\tcqr->status = DASD_CQR_FILLED;\n\tcqr->callback = dasd_eer_snss_cb;\n\n\tif (!device->eer_cqr) {\n\t\tdevice->eer_cqr = cqr;\n\t\tcqr = NULL;\n\t}\n\nout:\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\n\tif (cqr)\n\t\tdasd_sfree_request(cqr, device);\n\n\treturn rc;\n}\n\n \nvoid dasd_eer_disable(struct dasd_device *device)\n{\n\tstruct dasd_ccw_req *cqr;\n\tunsigned long flags;\n\tint in_use;\n\n\tif (!device->eer_cqr)\n\t\treturn;\n\tspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\n\tcqr = device->eer_cqr;\n\tdevice->eer_cqr = NULL;\n\tclear_bit(DASD_FLAG_EER_SNSS, &device->flags);\n\tin_use = test_and_clear_bit(DASD_FLAG_EER_IN_USE, &device->flags);\n\tspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\n\tif (cqr && !in_use)\n\t\tdasd_sfree_request(cqr, device);\n}\n\n \n\n \nstatic char readbuffer[PAGE_SIZE];\nstatic DEFINE_MUTEX(readbuffer_mutex);\n\nstatic int dasd_eer_open(struct inode *inp, struct file *filp)\n{\n\tstruct eerbuffer *eerb;\n\tunsigned long flags;\n\n\teerb = kzalloc(sizeof(struct eerbuffer), GFP_KERNEL);\n\tif (!eerb)\n\t\treturn -ENOMEM;\n\teerb->buffer_page_count = eer_pages;\n\tif (eerb->buffer_page_count < 1 ||\n\t    eerb->buffer_page_count > INT_MAX / PAGE_SIZE) {\n\t\tkfree(eerb);\n\t\tDBF_EVENT(DBF_WARNING, \"can't open device since module \"\n\t\t\t\"parameter eer_pages is smaller than 1 or\"\n\t\t\t\" bigger than %d\", (int)(INT_MAX / PAGE_SIZE));\n\t\treturn -EINVAL;\n\t}\n\teerb->buffersize = eerb->buffer_page_count * PAGE_SIZE;\n\teerb->buffer = kmalloc_array(eerb->buffer_page_count, sizeof(char *),\n\t\t\t\t     GFP_KERNEL);\n        if (!eerb->buffer) {\n\t\tkfree(eerb);\n                return -ENOMEM;\n\t}\n\tif (dasd_eer_allocate_buffer_pages(eerb->buffer,\n\t\t\t\t\t   eerb->buffer_page_count)) {\n\t\tkfree(eerb->buffer);\n\t\tkfree(eerb);\n\t\treturn -ENOMEM;\n\t}\n\tfilp->private_data = eerb;\n\tspin_lock_irqsave(&bufferlock, flags);\n\tlist_add(&eerb->list, &bufferlist);\n\tspin_unlock_irqrestore(&bufferlock, flags);\n\n\treturn nonseekable_open(inp,filp);\n}\n\nstatic int dasd_eer_close(struct inode *inp, struct file *filp)\n{\n\tstruct eerbuffer *eerb;\n\tunsigned long flags;\n\n\teerb = (struct eerbuffer *) filp->private_data;\n\tspin_lock_irqsave(&bufferlock, flags);\n\tlist_del(&eerb->list);\n\tspin_unlock_irqrestore(&bufferlock, flags);\n\tdasd_eer_free_buffer_pages(eerb->buffer, eerb->buffer_page_count);\n\tkfree(eerb->buffer);\n\tkfree(eerb);\n\n\treturn 0;\n}\n\nstatic ssize_t dasd_eer_read(struct file *filp, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tint tc,rc;\n\tint tailcount,effective_count;\n        unsigned long flags;\n\tstruct eerbuffer *eerb;\n\n\teerb = (struct eerbuffer *) filp->private_data;\n\tif (mutex_lock_interruptible(&readbuffer_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tspin_lock_irqsave(&bufferlock, flags);\n\n\tif (eerb->residual < 0) {  \n\t\t                   \n\t\teerb->residual = 0;\n\t\tspin_unlock_irqrestore(&bufferlock, flags);\n\t\tmutex_unlock(&readbuffer_mutex);\n\t\treturn -EIO;\n\t} else if (eerb->residual > 0) {\n\t\t \n\t\teffective_count = min(eerb->residual, (int) count);\n\t\teerb->residual -= effective_count;\n\t} else {\n\t\ttc = 0;\n\t\twhile (!tc) {\n\t\t\ttc = dasd_eer_read_buffer(eerb, (char *) &tailcount,\n\t\t\t\t\t\t  sizeof(tailcount));\n\t\t\tif (!tc) {\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&bufferlock, flags);\n\t\t\t\tmutex_unlock(&readbuffer_mutex);\n\t\t\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\t\t\treturn -EAGAIN;\n\t\t\t\trc = wait_event_interruptible(\n\t\t\t\t\tdasd_eer_read_wait_queue,\n\t\t\t\t\teerb->head != eerb->tail);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (mutex_lock_interruptible(&readbuffer_mutex))\n\t\t\t\t\treturn -ERESTARTSYS;\n\t\t\t\tspin_lock_irqsave(&bufferlock, flags);\n\t\t\t}\n\t\t}\n\t\tWARN_ON(tc != sizeof(tailcount));\n\t\teffective_count = min(tailcount,(int)count);\n\t\teerb->residual = tailcount - effective_count;\n\t}\n\n\ttc = dasd_eer_read_buffer(eerb, readbuffer, effective_count);\n\tWARN_ON(tc != effective_count);\n\n\tspin_unlock_irqrestore(&bufferlock, flags);\n\n\tif (copy_to_user(buf, readbuffer, effective_count)) {\n\t\tmutex_unlock(&readbuffer_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\tmutex_unlock(&readbuffer_mutex);\n\treturn effective_count;\n}\n\nstatic __poll_t dasd_eer_poll(struct file *filp, poll_table *ptable)\n{\n\t__poll_t mask;\n\tunsigned long flags;\n\tstruct eerbuffer *eerb;\n\n\teerb = (struct eerbuffer *) filp->private_data;\n\tpoll_wait(filp, &dasd_eer_read_wait_queue, ptable);\n\tspin_lock_irqsave(&bufferlock, flags);\n\tif (eerb->head != eerb->tail)\n\t\tmask = EPOLLIN | EPOLLRDNORM ;\n\telse\n\t\tmask = 0;\n\tspin_unlock_irqrestore(&bufferlock, flags);\n\treturn mask;\n}\n\nstatic const struct file_operations dasd_eer_fops = {\n\t.open\t\t= &dasd_eer_open,\n\t.release\t= &dasd_eer_close,\n\t.read\t\t= &dasd_eer_read,\n\t.poll\t\t= &dasd_eer_poll,\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice *dasd_eer_dev = NULL;\n\nint __init dasd_eer_init(void)\n{\n\tint rc;\n\n\tdasd_eer_dev = kzalloc(sizeof(*dasd_eer_dev), GFP_KERNEL);\n\tif (!dasd_eer_dev)\n\t\treturn -ENOMEM;\n\n\tdasd_eer_dev->minor = MISC_DYNAMIC_MINOR;\n\tdasd_eer_dev->name  = \"dasd_eer\";\n\tdasd_eer_dev->fops  = &dasd_eer_fops;\n\n\trc = misc_register(dasd_eer_dev);\n\tif (rc) {\n\t\tkfree(dasd_eer_dev);\n\t\tdasd_eer_dev = NULL;\n\t\tDBF_EVENT(DBF_ERR, \"%s\", \"dasd_eer_init could not \"\n\t\t       \"register misc device\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nvoid dasd_eer_exit(void)\n{\n\tif (dasd_eer_dev) {\n\t\tmisc_deregister(dasd_eer_dev);\n\t\tkfree(dasd_eer_dev);\n\t\tdasd_eer_dev = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}