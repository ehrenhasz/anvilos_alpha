{
  "module_name": "zcrypt_ep11misc.c",
  "hash_id": "5d65ef0ec7b68baf9e4457523d386c78af35b75a1d699a842f560fc79726b6cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/zcrypt_ep11misc.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zcrypt\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <asm/zcrypt.h>\n#include <asm/pkey.h>\n#include <crypto/aes.h>\n\n#include \"ap_bus.h\"\n#include \"zcrypt_api.h\"\n#include \"zcrypt_debug.h\"\n#include \"zcrypt_msgtype6.h\"\n#include \"zcrypt_ep11misc.h\"\n#include \"zcrypt_ccamisc.h\"\n\n#define DEBUG_DBG(...)\tZCRYPT_DBF(DBF_DEBUG, ##__VA_ARGS__)\n#define DEBUG_INFO(...) ZCRYPT_DBF(DBF_INFO, ##__VA_ARGS__)\n#define DEBUG_WARN(...) ZCRYPT_DBF(DBF_WARN, ##__VA_ARGS__)\n#define DEBUG_ERR(...)\tZCRYPT_DBF(DBF_ERR, ##__VA_ARGS__)\n\n#define EP11_PINBLOB_V1_BYTES 56\n\n \nstatic const u8 def_iv[16] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n\t\t\t       0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff };\n\n \nstruct card_list_entry {\n\tstruct list_head list;\n\tu16 cardnr;\n\tstruct ep11_card_info info;\n};\nstatic LIST_HEAD(card_list);\nstatic DEFINE_SPINLOCK(card_list_lock);\n\nstatic int card_cache_fetch(u16 cardnr, struct ep11_card_info *ci)\n{\n\tint rc = -ENOENT;\n\tstruct card_list_entry *ptr;\n\n\tspin_lock_bh(&card_list_lock);\n\tlist_for_each_entry(ptr, &card_list, list) {\n\t\tif (ptr->cardnr == cardnr) {\n\t\t\tmemcpy(ci, &ptr->info, sizeof(*ci));\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&card_list_lock);\n\n\treturn rc;\n}\n\nstatic void card_cache_update(u16 cardnr, const struct ep11_card_info *ci)\n{\n\tint found = 0;\n\tstruct card_list_entry *ptr;\n\n\tspin_lock_bh(&card_list_lock);\n\tlist_for_each_entry(ptr, &card_list, list) {\n\t\tif (ptr->cardnr == cardnr) {\n\t\t\tmemcpy(&ptr->info, ci, sizeof(*ci));\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tptr = kmalloc(sizeof(*ptr), GFP_ATOMIC);\n\t\tif (!ptr) {\n\t\t\tspin_unlock_bh(&card_list_lock);\n\t\t\treturn;\n\t\t}\n\t\tptr->cardnr = cardnr;\n\t\tmemcpy(&ptr->info, ci, sizeof(*ci));\n\t\tlist_add(&ptr->list, &card_list);\n\t}\n\tspin_unlock_bh(&card_list_lock);\n}\n\nstatic void card_cache_scrub(u16 cardnr)\n{\n\tstruct card_list_entry *ptr;\n\n\tspin_lock_bh(&card_list_lock);\n\tlist_for_each_entry(ptr, &card_list, list) {\n\t\tif (ptr->cardnr == cardnr) {\n\t\t\tlist_del(&ptr->list);\n\t\t\tkfree(ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&card_list_lock);\n}\n\nstatic void __exit card_cache_free(void)\n{\n\tstruct card_list_entry *ptr, *pnext;\n\n\tspin_lock_bh(&card_list_lock);\n\tlist_for_each_entry_safe(ptr, pnext, &card_list, list) {\n\t\tlist_del(&ptr->list);\n\t\tkfree(ptr);\n\t}\n\tspin_unlock_bh(&card_list_lock);\n}\n\nstatic int ep11_kb_split(const u8 *kb, size_t kblen, u32 kbver,\n\t\t\t struct ep11kblob_header **kbhdr, size_t *kbhdrsize,\n\t\t\t u8 **kbpl, size_t *kbplsize)\n{\n\tstruct ep11kblob_header *hdr = NULL;\n\tsize_t hdrsize, plsize = 0;\n\tint rc = -EINVAL;\n\tu8 *pl = NULL;\n\n\tif (kblen < sizeof(struct ep11kblob_header))\n\t\tgoto out;\n\thdr = (struct ep11kblob_header *)kb;\n\n\tswitch (kbver) {\n\tcase TOKVER_EP11_AES:\n\t\t \n\t\thdrsize = 0;\n\t\tbreak;\n\tcase TOKVER_EP11_ECC_WITH_HEADER:\n\tcase TOKVER_EP11_AES_WITH_HEADER:\n\t\t \n\t\thdrsize = sizeof(struct ep11kblob_header);\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tplsize = kblen - hdrsize;\n\tpl = (u8 *)kb + hdrsize;\n\n\tif (kbhdr)\n\t\t*kbhdr = hdr;\n\tif (kbhdrsize)\n\t\t*kbhdrsize = hdrsize;\n\tif (kbpl)\n\t\t*kbpl = pl;\n\tif (kbplsize)\n\t\t*kbplsize = plsize;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic int ep11_kb_decode(const u8 *kb, size_t kblen,\n\t\t\t  struct ep11kblob_header **kbhdr, size_t *kbhdrsize,\n\t\t\t  struct ep11keyblob **kbpl, size_t *kbplsize)\n{\n\tstruct ep11kblob_header *tmph, *hdr = NULL;\n\tsize_t hdrsize = 0, plsize = 0;\n\tstruct ep11keyblob *pl = NULL;\n\tint rc = -EINVAL;\n\tu8 *tmpp;\n\n\tif (kblen < sizeof(struct ep11kblob_header))\n\t\tgoto out;\n\ttmph = (struct ep11kblob_header *)kb;\n\n\tif (tmph->type != TOKTYPE_NON_CCA &&\n\t    tmph->len > kblen)\n\t\tgoto out;\n\n\tif (ep11_kb_split(kb, kblen, tmph->version,\n\t\t\t  &hdr, &hdrsize, &tmpp, &plsize))\n\t\tgoto out;\n\n\tif (plsize < sizeof(struct ep11keyblob))\n\t\tgoto out;\n\n\tif (!is_ep11_keyblob(tmpp))\n\t\tgoto out;\n\n\tpl = (struct ep11keyblob *)tmpp;\n\tplsize = hdr->len - hdrsize;\n\n\tif (kbhdr)\n\t\t*kbhdr = hdr;\n\tif (kbhdrsize)\n\t\t*kbhdrsize = hdrsize;\n\tif (kbpl)\n\t\t*kbpl = pl;\n\tif (kbplsize)\n\t\t*kbplsize = plsize;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nconst u8 *ep11_kb_wkvp(const u8 *keyblob, size_t keybloblen)\n{\n\tstruct ep11keyblob *kb;\n\n\tif (ep11_kb_decode(keyblob, keybloblen, NULL, NULL, &kb, NULL))\n\t\treturn NULL;\n\treturn kb->wkvp;\n}\nEXPORT_SYMBOL(ep11_kb_wkvp);\n\n \nint ep11_check_aes_key_with_hdr(debug_info_t *dbg, int dbflvl,\n\t\t\t\tconst u8 *key, size_t keylen, int checkcpacfexp)\n{\n\tstruct ep11kblob_header *hdr = (struct ep11kblob_header *)key;\n\tstruct ep11keyblob *kb = (struct ep11keyblob *)(key + sizeof(*hdr));\n\n#define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)\n\n\tif (keylen < sizeof(*hdr) + sizeof(*kb)) {\n\t\tDBF(\"%s key check failed, keylen %zu < %zu\\n\",\n\t\t    __func__, keylen, sizeof(*hdr) + sizeof(*kb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->type != TOKTYPE_NON_CCA) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, type 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)hdr->type, TOKTYPE_NON_CCA);\n\t\treturn -EINVAL;\n\t}\n\tif (hdr->hver != 0x00) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, header version 0x%02x != 0x00\\n\",\n\t\t\t    __func__, (int)hdr->hver);\n\t\treturn -EINVAL;\n\t}\n\tif (hdr->version != TOKVER_EP11_AES_WITH_HEADER) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, version 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)hdr->version, TOKVER_EP11_AES_WITH_HEADER);\n\t\treturn -EINVAL;\n\t}\n\tif (hdr->len > keylen) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, header len %d keylen %zu mismatch\\n\",\n\t\t\t    __func__, (int)hdr->len, keylen);\n\t\treturn -EINVAL;\n\t}\n\tif (hdr->len < sizeof(*hdr) + sizeof(*kb)) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, header len %d < %zu\\n\",\n\t\t\t    __func__, (int)hdr->len, sizeof(*hdr) + sizeof(*kb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (kb->version != EP11_STRUCT_MAGIC) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, blob magic 0x%04x != 0x%04x\\n\",\n\t\t\t    __func__, (int)kb->version, EP11_STRUCT_MAGIC);\n\t\treturn -EINVAL;\n\t}\n\tif (checkcpacfexp && !(kb->attr & EP11_BLOB_PKEY_EXTRACTABLE)) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, PKEY_EXTRACTABLE is off\\n\",\n\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n#undef DBF\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ep11_check_aes_key_with_hdr);\n\n \nint ep11_check_ecc_key_with_hdr(debug_info_t *dbg, int dbflvl,\n\t\t\t\tconst u8 *key, size_t keylen, int checkcpacfexp)\n{\n\tstruct ep11kblob_header *hdr = (struct ep11kblob_header *)key;\n\tstruct ep11keyblob *kb = (struct ep11keyblob *)(key + sizeof(*hdr));\n\n#define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)\n\n\tif (keylen < sizeof(*hdr) + sizeof(*kb)) {\n\t\tDBF(\"%s key check failed, keylen %zu < %zu\\n\",\n\t\t    __func__, keylen, sizeof(*hdr) + sizeof(*kb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->type != TOKTYPE_NON_CCA) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, type 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)hdr->type, TOKTYPE_NON_CCA);\n\t\treturn -EINVAL;\n\t}\n\tif (hdr->hver != 0x00) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, header version 0x%02x != 0x00\\n\",\n\t\t\t    __func__, (int)hdr->hver);\n\t\treturn -EINVAL;\n\t}\n\tif (hdr->version != TOKVER_EP11_ECC_WITH_HEADER) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, version 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)hdr->version, TOKVER_EP11_ECC_WITH_HEADER);\n\t\treturn -EINVAL;\n\t}\n\tif (hdr->len > keylen) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, header len %d keylen %zu mismatch\\n\",\n\t\t\t    __func__, (int)hdr->len, keylen);\n\t\treturn -EINVAL;\n\t}\n\tif (hdr->len < sizeof(*hdr) + sizeof(*kb)) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, header len %d < %zu\\n\",\n\t\t\t    __func__, (int)hdr->len, sizeof(*hdr) + sizeof(*kb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (kb->version != EP11_STRUCT_MAGIC) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, blob magic 0x%04x != 0x%04x\\n\",\n\t\t\t    __func__, (int)kb->version, EP11_STRUCT_MAGIC);\n\t\treturn -EINVAL;\n\t}\n\tif (checkcpacfexp && !(kb->attr & EP11_BLOB_PKEY_EXTRACTABLE)) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, PKEY_EXTRACTABLE is off\\n\",\n\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n#undef DBF\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ep11_check_ecc_key_with_hdr);\n\n \nint ep11_check_aes_key(debug_info_t *dbg, int dbflvl,\n\t\t       const u8 *key, size_t keylen, int checkcpacfexp)\n{\n\tstruct ep11keyblob *kb = (struct ep11keyblob *)key;\n\n#define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)\n\n\tif (keylen < sizeof(*kb)) {\n\t\tDBF(\"%s key check failed, keylen %zu < %zu\\n\",\n\t\t    __func__, keylen, sizeof(*kb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (kb->head.type != TOKTYPE_NON_CCA) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, type 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)kb->head.type, TOKTYPE_NON_CCA);\n\t\treturn -EINVAL;\n\t}\n\tif (kb->head.version != TOKVER_EP11_AES) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, version 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)kb->head.version, TOKVER_EP11_AES);\n\t\treturn -EINVAL;\n\t}\n\tif (kb->head.len > keylen) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, header len %d keylen %zu mismatch\\n\",\n\t\t\t    __func__, (int)kb->head.len, keylen);\n\t\treturn -EINVAL;\n\t}\n\tif (kb->head.len < sizeof(*kb)) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, header len %d < %zu\\n\",\n\t\t\t    __func__, (int)kb->head.len, sizeof(*kb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (kb->version != EP11_STRUCT_MAGIC) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, blob magic 0x%04x != 0x%04x\\n\",\n\t\t\t    __func__, (int)kb->version, EP11_STRUCT_MAGIC);\n\t\treturn -EINVAL;\n\t}\n\tif (checkcpacfexp && !(kb->attr & EP11_BLOB_PKEY_EXTRACTABLE)) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s key check failed, PKEY_EXTRACTABLE is off\\n\",\n\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n#undef DBF\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ep11_check_aes_key);\n\n \nstatic inline struct ep11_cprb *alloc_cprb(size_t payload_len)\n{\n\tsize_t len = sizeof(struct ep11_cprb) + payload_len;\n\tstruct ep11_cprb *cprb;\n\n\tcprb = kzalloc(len, GFP_KERNEL);\n\tif (!cprb)\n\t\treturn NULL;\n\n\tcprb->cprb_len = sizeof(struct ep11_cprb);\n\tcprb->cprb_ver_id = 0x04;\n\tmemcpy(cprb->func_id, \"T4\", 2);\n\tcprb->ret_code = 0xFFFFFFFF;\n\tcprb->payload_len = payload_len;\n\n\treturn cprb;\n}\n\n \n\n#define ASN1TAGLEN(x) (2 + (x) + ((x) > 127 ? 1 : 0) + ((x) > 255 ? 1 : 0))\n\nstatic int asn1tag_write(u8 *ptr, u8 tag, const u8 *pvalue, u16 valuelen)\n{\n\tptr[0] = tag;\n\tif (valuelen > 255) {\n\t\tptr[1] = 0x82;\n\t\t*((u16 *)(ptr + 2)) = valuelen;\n\t\tmemcpy(ptr + 4, pvalue, valuelen);\n\t\treturn 4 + valuelen;\n\t}\n\tif (valuelen > 127) {\n\t\tptr[1] = 0x81;\n\t\tptr[2] = (u8)valuelen;\n\t\tmemcpy(ptr + 3, pvalue, valuelen);\n\t\treturn 3 + valuelen;\n\t}\n\tptr[1] = (u8)valuelen;\n\tmemcpy(ptr + 2, pvalue, valuelen);\n\treturn 2 + valuelen;\n}\n\n \nstruct pl_head {\n\tu8  tag;\n\tu8  lenfmt;\n\tu16 len;\n\tu8  func_tag;\n\tu8  func_len;\n\tu32 func;\n\tu8  dom_tag;\n\tu8  dom_len;\n\tu32 dom;\n} __packed;\n\n \nstatic inline void prep_head(struct pl_head *h,\n\t\t\t     size_t pl_size, int api, int func)\n{\n\th->tag = 0x30;\n\th->lenfmt = 0x82;\n\th->len = pl_size - 4;\n\th->func_tag = 0x04;\n\th->func_len = sizeof(u32);\n\th->func = (api << 16) + func;\n\th->dom_tag = 0x04;\n\th->dom_len = sizeof(u32);\n}\n\n \nstatic inline void prep_urb(struct ep11_urb *u,\n\t\t\t    struct ep11_target_dev *t, int nt,\n\t\t\t    struct ep11_cprb *req, size_t req_len,\n\t\t\t    struct ep11_cprb *rep, size_t rep_len)\n{\n\tu->targets = (u8 __user *)t;\n\tu->targets_num = nt;\n\tu->req = (u8 __user *)req;\n\tu->req_len = req_len;\n\tu->resp = (u8 __user *)rep;\n\tu->resp_len = rep_len;\n}\n\n \nstatic int check_reply_pl(const u8 *pl, const char *func)\n{\n\tint len;\n\tu32 ret;\n\n\t \n\tif (*pl++ != 0x30) {\n\t\tDEBUG_ERR(\"%s reply start tag mismatch\\n\", func);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (*pl < 127) {\n\t\tlen = *pl;\n\t\tpl++;\n\t} else if (*pl == 0x81) {\n\t\tpl++;\n\t\tlen = *pl;\n\t\tpl++;\n\t} else if (*pl == 0x82) {\n\t\tpl++;\n\t\tlen = *((u16 *)pl);\n\t\tpl += 2;\n\t} else {\n\t\tDEBUG_ERR(\"%s reply start tag lenfmt mismatch 0x%02hhx\\n\",\n\t\t\t  func, *pl);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (len < 3 * 6) {\n\t\tDEBUG_ERR(\"%s reply length %d too small\\n\", func, len);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (pl[0] != 0x04 || pl[1] != 0x04) {\n\t\tDEBUG_ERR(\"%s function tag or length mismatch\\n\", func);\n\t\treturn -EIO;\n\t}\n\tpl += 6;\n\n\t \n\tif (pl[0] != 0x04 || pl[1] != 0x04) {\n\t\tDEBUG_ERR(\"%s dom tag or length mismatch\\n\", func);\n\t\treturn -EIO;\n\t}\n\tpl += 6;\n\n\t \n\tif (pl[0] != 0x04 || pl[1] != 0x04) {\n\t\tDEBUG_ERR(\"%s return value tag or length mismatch\\n\", func);\n\t\treturn -EIO;\n\t}\n\tpl += 2;\n\tret = *((u32 *)pl);\n\tif (ret != 0) {\n\t\tDEBUG_ERR(\"%s return value 0x%04x != 0\\n\", func, ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ep11_query_info(u16 cardnr, u16 domain, u32 query_type,\n\t\t\t   size_t buflen, u8 *buf)\n{\n\tstruct ep11_info_req_pl {\n\t\tstruct pl_head head;\n\t\tu8  query_type_tag;\n\t\tu8  query_type_len;\n\t\tu32 query_type;\n\t\tu8  query_subtype_tag;\n\t\tu8  query_subtype_len;\n\t\tu32 query_subtype;\n\t} __packed * req_pl;\n\tstruct ep11_info_rep_pl {\n\t\tstruct pl_head head;\n\t\tu8  rc_tag;\n\t\tu8  rc_len;\n\t\tu32 rc;\n\t\tu8  data_tag;\n\t\tu8  data_lenfmt;\n\t\tu16 data_len;\n\t} __packed * rep_pl;\n\tstruct ep11_cprb *req = NULL, *rep = NULL;\n\tstruct ep11_target_dev target;\n\tstruct ep11_urb *urb = NULL;\n\tint api = EP11_API_V1, rc = -ENOMEM;\n\n\t \n\treq = alloc_cprb(sizeof(struct ep11_info_req_pl));\n\tif (!req)\n\t\tgoto out;\n\treq_pl = (struct ep11_info_req_pl *)(((u8 *)req) + sizeof(*req));\n\tprep_head(&req_pl->head, sizeof(*req_pl), api, 38);  \n\treq_pl->query_type_tag = 0x04;\n\treq_pl->query_type_len = sizeof(u32);\n\treq_pl->query_type = query_type;\n\treq_pl->query_subtype_tag = 0x04;\n\treq_pl->query_subtype_len = sizeof(u32);\n\n\t \n\trep = alloc_cprb(sizeof(struct ep11_info_rep_pl) + buflen);\n\tif (!rep)\n\t\tgoto out;\n\trep_pl = (struct ep11_info_rep_pl *)(((u8 *)rep) + sizeof(*rep));\n\n\t \n\turb = kmalloc(sizeof(*urb), GFP_KERNEL);\n\tif (!urb)\n\t\tgoto out;\n\ttarget.ap_id = cardnr;\n\ttarget.dom_id = domain;\n\tprep_urb(urb, &target, 1,\n\t\t req, sizeof(*req) + sizeof(*req_pl),\n\t\t rep, sizeof(*rep) + sizeof(*rep_pl) + buflen);\n\n\trc = zcrypt_send_ep11_cprb(urb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\trc = check_reply_pl((u8 *)rep_pl, __func__);\n\tif (rc)\n\t\tgoto out;\n\tif (rep_pl->data_tag != 0x04 || rep_pl->data_lenfmt != 0x82) {\n\t\tDEBUG_ERR(\"%s unknown reply data format\\n\", __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (rep_pl->data_len > buflen) {\n\t\tDEBUG_ERR(\"%s mismatch between reply data len and buffer len\\n\",\n\t\t\t  __func__);\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, ((u8 *)rep_pl) + sizeof(*rep_pl), rep_pl->data_len);\n\nout:\n\tkfree(req);\n\tkfree(rep);\n\tkfree(urb);\n\treturn rc;\n}\n\n \nint ep11_get_card_info(u16 card, struct ep11_card_info *info, int verify)\n{\n\tint rc;\n\tstruct ep11_module_query_info {\n\t\tu32 API_ord_nr;\n\t\tu32 firmware_id;\n\t\tu8  FW_major_vers;\n\t\tu8  FW_minor_vers;\n\t\tu8  CSP_major_vers;\n\t\tu8  CSP_minor_vers;\n\t\tu8  fwid[32];\n\t\tu8  xcp_config_hash[32];\n\t\tu8  CSP_config_hash[32];\n\t\tu8  serial[16];\n\t\tu8  module_date_time[16];\n\t\tu64 op_mode;\n\t\tu32 PKCS11_flags;\n\t\tu32 ext_flags;\n\t\tu32 domains;\n\t\tu32 sym_state_bytes;\n\t\tu32 digest_state_bytes;\n\t\tu32 pin_blob_bytes;\n\t\tu32 SPKI_bytes;\n\t\tu32 priv_key_blob_bytes;\n\t\tu32 sym_blob_bytes;\n\t\tu32 max_payload_bytes;\n\t\tu32 CP_profile_bytes;\n\t\tu32 max_CP_index;\n\t} __packed * pmqi = NULL;\n\n\trc = card_cache_fetch(card, info);\n\tif (rc || verify) {\n\t\tpmqi = kmalloc(sizeof(*pmqi), GFP_KERNEL);\n\t\tif (!pmqi)\n\t\t\treturn -ENOMEM;\n\t\trc = ep11_query_info(card, AUTOSEL_DOM,\n\t\t\t\t     0x01  ,\n\t\t\t\t     sizeof(*pmqi), (u8 *)pmqi);\n\t\tif (rc) {\n\t\t\tif (rc == -ENODEV)\n\t\t\t\tcard_cache_scrub(card);\n\t\t\tgoto out;\n\t\t}\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->API_ord_nr = pmqi->API_ord_nr;\n\t\tinfo->FW_version =\n\t\t\t(pmqi->FW_major_vers << 8) + pmqi->FW_minor_vers;\n\t\tmemcpy(info->serial, pmqi->serial, sizeof(info->serial));\n\t\tinfo->op_mode = pmqi->op_mode;\n\t\tcard_cache_update(card, info);\n\t}\n\nout:\n\tkfree(pmqi);\n\treturn rc;\n}\nEXPORT_SYMBOL(ep11_get_card_info);\n\n \nint ep11_get_domain_info(u16 card, u16 domain, struct ep11_domain_info *info)\n{\n\tint rc;\n\tstruct ep11_domain_query_info {\n\t\tu32 dom_index;\n\t\tu8  cur_WK_VP[32];\n\t\tu8  new_WK_VP[32];\n\t\tu32 dom_flags;\n\t\tu64 op_mode;\n\t} __packed * p_dom_info;\n\n\tp_dom_info = kmalloc(sizeof(*p_dom_info), GFP_KERNEL);\n\tif (!p_dom_info)\n\t\treturn -ENOMEM;\n\n\trc = ep11_query_info(card, domain, 0x03  ,\n\t\t\t     sizeof(*p_dom_info), (u8 *)p_dom_info);\n\tif (rc)\n\t\tgoto out;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->cur_wk_state = '0';\n\tinfo->new_wk_state = '0';\n\tif (p_dom_info->dom_flags & 0x10  ) {\n\t\tif (p_dom_info->dom_flags & 0x02  ) {\n\t\t\tinfo->cur_wk_state = '1';\n\t\t\tmemcpy(info->cur_wkvp, p_dom_info->cur_WK_VP, 32);\n\t\t}\n\t\tif (p_dom_info->dom_flags & 0x04 ||  \n\t\t    p_dom_info->dom_flags & 0x08  ) {\n\t\t\tinfo->new_wk_state =\n\t\t\t\tp_dom_info->dom_flags & 0x08 ? '2' : '1';\n\t\t\tmemcpy(info->new_wkvp, p_dom_info->new_WK_VP, 32);\n\t\t}\n\t}\n\tinfo->op_mode = p_dom_info->op_mode;\n\nout:\n\tkfree(p_dom_info);\n\treturn rc;\n}\nEXPORT_SYMBOL(ep11_get_domain_info);\n\n \n#define KEY_ATTR_DEFAULTS 0x00200c00\n\nstatic int _ep11_genaeskey(u16 card, u16 domain,\n\t\t\t   u32 keybitsize, u32 keygenflags,\n\t\t\t   u8 *keybuf, size_t *keybufsize)\n{\n\tstruct keygen_req_pl {\n\t\tstruct pl_head head;\n\t\tu8  var_tag;\n\t\tu8  var_len;\n\t\tu32 var;\n\t\tu8  keybytes_tag;\n\t\tu8  keybytes_len;\n\t\tu32 keybytes;\n\t\tu8  mech_tag;\n\t\tu8  mech_len;\n\t\tu32 mech;\n\t\tu8  attr_tag;\n\t\tu8  attr_len;\n\t\tu32 attr_header;\n\t\tu32 attr_bool_mask;\n\t\tu32 attr_bool_bits;\n\t\tu32 attr_val_len_type;\n\t\tu32 attr_val_len_value;\n\t\t \n\t} __packed * req_pl;\n\tstruct keygen_rep_pl {\n\t\tstruct pl_head head;\n\t\tu8  rc_tag;\n\t\tu8  rc_len;\n\t\tu32 rc;\n\t\tu8  data_tag;\n\t\tu8  data_lenfmt;\n\t\tu16 data_len;\n\t\tu8  data[512];\n\t} __packed * rep_pl;\n\tstruct ep11_cprb *req = NULL, *rep = NULL;\n\tsize_t req_pl_size, pinblob_size = 0;\n\tstruct ep11_target_dev target;\n\tstruct ep11_urb *urb = NULL;\n\tint api, rc = -ENOMEM;\n\tu8 *p;\n\n\tswitch (keybitsize) {\n\tcase 128:\n\tcase 192:\n\tcase 256:\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\n\t\t\t\"%s unknown/unsupported keybitsize %d\\n\",\n\t\t\t__func__, keybitsize);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tapi = (!keygenflags || keygenflags & 0x00200000) ?\n\t\tEP11_API_V4 : EP11_API_V1;\n\tif (ap_is_se_guest()) {\n\t\t \n\t\tapi = EP11_API_V6;\n\t\tpinblob_size = EP11_PINBLOB_V1_BYTES;\n\t}\n\treq_pl_size = sizeof(struct keygen_req_pl) + ASN1TAGLEN(pinblob_size);\n\treq = alloc_cprb(req_pl_size);\n\tif (!req)\n\t\tgoto out;\n\treq_pl = (struct keygen_req_pl *)(((u8 *)req) + sizeof(*req));\n\tprep_head(&req_pl->head, req_pl_size, api, 21);  \n\treq_pl->var_tag = 0x04;\n\treq_pl->var_len = sizeof(u32);\n\treq_pl->keybytes_tag = 0x04;\n\treq_pl->keybytes_len = sizeof(u32);\n\treq_pl->keybytes = keybitsize / 8;\n\treq_pl->mech_tag = 0x04;\n\treq_pl->mech_len = sizeof(u32);\n\treq_pl->mech = 0x00001080;  \n\treq_pl->attr_tag = 0x04;\n\treq_pl->attr_len = 5 * sizeof(u32);\n\treq_pl->attr_header = 0x10010000;\n\treq_pl->attr_bool_mask = keygenflags ? keygenflags : KEY_ATTR_DEFAULTS;\n\treq_pl->attr_bool_bits = keygenflags ? keygenflags : KEY_ATTR_DEFAULTS;\n\treq_pl->attr_val_len_type = 0x00000161;  \n\treq_pl->attr_val_len_value = keybitsize / 8;\n\tp = ((u8 *)req_pl) + sizeof(*req_pl);\n\t \n\t*p++ = 0x04;\n\t*p++ = pinblob_size;\n\n\t \n\trep = alloc_cprb(sizeof(struct keygen_rep_pl));\n\tif (!rep)\n\t\tgoto out;\n\trep_pl = (struct keygen_rep_pl *)(((u8 *)rep) + sizeof(*rep));\n\n\t \n\turb = kmalloc(sizeof(*urb), GFP_KERNEL);\n\tif (!urb)\n\t\tgoto out;\n\ttarget.ap_id = card;\n\ttarget.dom_id = domain;\n\tprep_urb(urb, &target, 1,\n\t\t req, sizeof(*req) + req_pl_size,\n\t\t rep, sizeof(*rep) + sizeof(*rep_pl));\n\n\trc = zcrypt_send_ep11_cprb(urb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)card, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\trc = check_reply_pl((u8 *)rep_pl, __func__);\n\tif (rc)\n\t\tgoto out;\n\tif (rep_pl->data_tag != 0x04 || rep_pl->data_lenfmt != 0x82) {\n\t\tDEBUG_ERR(\"%s unknown reply data format\\n\", __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (rep_pl->data_len > *keybufsize) {\n\t\tDEBUG_ERR(\"%s mismatch reply data len / key buffer len\\n\",\n\t\t\t  __func__);\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(keybuf, rep_pl->data, rep_pl->data_len);\n\t*keybufsize = rep_pl->data_len;\n\nout:\n\tkfree(req);\n\tkfree(rep);\n\tkfree(urb);\n\treturn rc;\n}\n\nint ep11_genaeskey(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,\n\t\t   u8 *keybuf, size_t *keybufsize, u32 keybufver)\n{\n\tstruct ep11kblob_header *hdr;\n\tsize_t hdr_size, pl_size;\n\tu8 *pl;\n\tint rc;\n\n\tswitch (keybufver) {\n\tcase TOKVER_EP11_AES:\n\tcase TOKVER_EP11_AES_WITH_HEADER:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trc = ep11_kb_split(keybuf, *keybufsize, keybufver,\n\t\t\t   &hdr, &hdr_size, &pl, &pl_size);\n\tif (rc)\n\t\treturn rc;\n\n\trc = _ep11_genaeskey(card, domain, keybitsize, keygenflags,\n\t\t\t     pl, &pl_size);\n\tif (rc)\n\t\treturn rc;\n\n\t*keybufsize = hdr_size + pl_size;\n\n\t \n\thdr->type = TOKTYPE_NON_CCA;\n\thdr->len = *keybufsize;\n\thdr->version = keybufver;\n\thdr->bitlen = keybitsize;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ep11_genaeskey);\n\nstatic int ep11_cryptsingle(u16 card, u16 domain,\n\t\t\t    u16 mode, u32 mech, const u8 *iv,\n\t\t\t    const u8 *key, size_t keysize,\n\t\t\t    const u8 *inbuf, size_t inbufsize,\n\t\t\t    u8 *outbuf, size_t *outbufsize)\n{\n\tstruct crypt_req_pl {\n\t\tstruct pl_head head;\n\t\tu8  var_tag;\n\t\tu8  var_len;\n\t\tu32 var;\n\t\tu8  mech_tag;\n\t\tu8  mech_len;\n\t\tu32 mech;\n\t\t \n\t} __packed * req_pl;\n\tstruct crypt_rep_pl {\n\t\tstruct pl_head head;\n\t\tu8  rc_tag;\n\t\tu8  rc_len;\n\t\tu32 rc;\n\t\tu8  data_tag;\n\t\tu8  data_lenfmt;\n\t\t \n\t} __packed * rep_pl;\n\tstruct ep11_cprb *req = NULL, *rep = NULL;\n\tstruct ep11_target_dev target;\n\tstruct ep11_urb *urb = NULL;\n\tsize_t req_pl_size, rep_pl_size;\n\tint n, api = EP11_API_V1, rc = -ENOMEM;\n\tu8 *p;\n\n\t \n\tif (keysize > 0xFFFF || inbufsize > 0xFFFF)\n\t\treturn -EINVAL;\n\n\t \n\treq_pl_size = sizeof(struct crypt_req_pl) + (iv ? 16 : 0)\n\t\t+ ASN1TAGLEN(keysize) + ASN1TAGLEN(inbufsize);\n\treq = alloc_cprb(req_pl_size);\n\tif (!req)\n\t\tgoto out;\n\treq_pl = (struct crypt_req_pl *)(((u8 *)req) + sizeof(*req));\n\tprep_head(&req_pl->head, req_pl_size, api, (mode ? 20 : 19));\n\treq_pl->var_tag = 0x04;\n\treq_pl->var_len = sizeof(u32);\n\t \n\treq_pl->mech_tag = 0x04;\n\treq_pl->mech_len = sizeof(u32) + (iv ? 16 : 0);\n\treq_pl->mech = (mech ? mech : 0x00001085);  \n\tp = ((u8 *)req_pl) + sizeof(*req_pl);\n\tif (iv) {\n\t\tmemcpy(p, iv, 16);\n\t\tp += 16;\n\t}\n\t \n\tp += asn1tag_write(p, 0x04, key, keysize);\n\tp += asn1tag_write(p, 0x04, inbuf, inbufsize);\n\n\t \n\trep_pl_size = sizeof(struct crypt_rep_pl) + ASN1TAGLEN(inbufsize + 32);\n\trep = alloc_cprb(rep_pl_size);\n\tif (!rep)\n\t\tgoto out;\n\trep_pl = (struct crypt_rep_pl *)(((u8 *)rep) + sizeof(*rep));\n\n\t \n\turb = kmalloc(sizeof(*urb), GFP_KERNEL);\n\tif (!urb)\n\t\tgoto out;\n\ttarget.ap_id = card;\n\ttarget.dom_id = domain;\n\tprep_urb(urb, &target, 1,\n\t\t req, sizeof(*req) + req_pl_size,\n\t\t rep, sizeof(*rep) + rep_pl_size);\n\n\trc = zcrypt_send_ep11_cprb(urb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)card, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\trc = check_reply_pl((u8 *)rep_pl, __func__);\n\tif (rc)\n\t\tgoto out;\n\tif (rep_pl->data_tag != 0x04) {\n\t\tDEBUG_ERR(\"%s unknown reply data format\\n\", __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tp = ((u8 *)rep_pl) + sizeof(*rep_pl);\n\tif (rep_pl->data_lenfmt <= 127) {\n\t\tn = rep_pl->data_lenfmt;\n\t} else if (rep_pl->data_lenfmt == 0x81) {\n\t\tn = *p++;\n\t} else if (rep_pl->data_lenfmt == 0x82) {\n\t\tn = *((u16 *)p);\n\t\tp += 2;\n\t} else {\n\t\tDEBUG_ERR(\"%s unknown reply data length format 0x%02hhx\\n\",\n\t\t\t  __func__, rep_pl->data_lenfmt);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (n > *outbufsize) {\n\t\tDEBUG_ERR(\"%s mismatch reply data len %d / output buffer %zu\\n\",\n\t\t\t  __func__, n, *outbufsize);\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tmemcpy(outbuf, p, n);\n\t*outbufsize = n;\n\nout:\n\tkfree(req);\n\tkfree(rep);\n\tkfree(urb);\n\treturn rc;\n}\n\nstatic int _ep11_unwrapkey(u16 card, u16 domain,\n\t\t\t   const u8 *kek, size_t keksize,\n\t\t\t   const u8 *enckey, size_t enckeysize,\n\t\t\t   u32 mech, const u8 *iv,\n\t\t\t   u32 keybitsize, u32 keygenflags,\n\t\t\t   u8 *keybuf, size_t *keybufsize)\n{\n\tstruct uw_req_pl {\n\t\tstruct pl_head head;\n\t\tu8  attr_tag;\n\t\tu8  attr_len;\n\t\tu32 attr_header;\n\t\tu32 attr_bool_mask;\n\t\tu32 attr_bool_bits;\n\t\tu32 attr_key_type;\n\t\tu32 attr_key_type_value;\n\t\tu32 attr_val_len;\n\t\tu32 attr_val_len_value;\n\t\tu8  mech_tag;\n\t\tu8  mech_len;\n\t\tu32 mech;\n\t\t \n\t} __packed * req_pl;\n\tstruct uw_rep_pl {\n\t\tstruct pl_head head;\n\t\tu8  rc_tag;\n\t\tu8  rc_len;\n\t\tu32 rc;\n\t\tu8  data_tag;\n\t\tu8  data_lenfmt;\n\t\tu16 data_len;\n\t\tu8  data[512];\n\t} __packed * rep_pl;\n\tstruct ep11_cprb *req = NULL, *rep = NULL;\n\tsize_t req_pl_size, pinblob_size = 0;\n\tstruct ep11_target_dev target;\n\tstruct ep11_urb *urb = NULL;\n\tint api, rc = -ENOMEM;\n\tu8 *p;\n\n\t \n\tapi = (!keygenflags || keygenflags & 0x00200000) ?\n\t\tEP11_API_V4 : EP11_API_V1;\n\tif (ap_is_se_guest()) {\n\t\t \n\t\tapi = EP11_API_V6;\n\t\tpinblob_size = EP11_PINBLOB_V1_BYTES;\n\t}\n\treq_pl_size = sizeof(struct uw_req_pl) + (iv ? 16 : 0)\n\t\t+ ASN1TAGLEN(keksize) + ASN1TAGLEN(0)\n\t\t+ ASN1TAGLEN(pinblob_size) + ASN1TAGLEN(enckeysize);\n\treq = alloc_cprb(req_pl_size);\n\tif (!req)\n\t\tgoto out;\n\treq_pl = (struct uw_req_pl *)(((u8 *)req) + sizeof(*req));\n\tprep_head(&req_pl->head, req_pl_size, api, 34);  \n\treq_pl->attr_tag = 0x04;\n\treq_pl->attr_len = 7 * sizeof(u32);\n\treq_pl->attr_header = 0x10020000;\n\treq_pl->attr_bool_mask = keygenflags ? keygenflags : KEY_ATTR_DEFAULTS;\n\treq_pl->attr_bool_bits = keygenflags ? keygenflags : KEY_ATTR_DEFAULTS;\n\treq_pl->attr_key_type = 0x00000100;  \n\treq_pl->attr_key_type_value = 0x0000001f;  \n\treq_pl->attr_val_len = 0x00000161;  \n\treq_pl->attr_val_len_value = keybitsize / 8;\n\t \n\treq_pl->mech_tag = 0x04;\n\treq_pl->mech_len = sizeof(u32) + (iv ? 16 : 0);\n\treq_pl->mech = (mech ? mech : 0x00001085);  \n\tp = ((u8 *)req_pl) + sizeof(*req_pl);\n\tif (iv) {\n\t\tmemcpy(p, iv, 16);\n\t\tp += 16;\n\t}\n\t \n\tp += asn1tag_write(p, 0x04, kek, keksize);\n\t \n\t*p++ = 0x04;\n\t*p++ = 0;\n\t \n\t*p++ = 0x04;\n\t*p++ = pinblob_size;\n\tp += pinblob_size;\n\t \n\tp += asn1tag_write(p, 0x04, enckey, enckeysize);\n\n\t \n\trep = alloc_cprb(sizeof(struct uw_rep_pl));\n\tif (!rep)\n\t\tgoto out;\n\trep_pl = (struct uw_rep_pl *)(((u8 *)rep) + sizeof(*rep));\n\n\t \n\turb = kmalloc(sizeof(*urb), GFP_KERNEL);\n\tif (!urb)\n\t\tgoto out;\n\ttarget.ap_id = card;\n\ttarget.dom_id = domain;\n\tprep_urb(urb, &target, 1,\n\t\t req, sizeof(*req) + req_pl_size,\n\t\t rep, sizeof(*rep) + sizeof(*rep_pl));\n\n\trc = zcrypt_send_ep11_cprb(urb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)card, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\trc = check_reply_pl((u8 *)rep_pl, __func__);\n\tif (rc)\n\t\tgoto out;\n\tif (rep_pl->data_tag != 0x04 || rep_pl->data_lenfmt != 0x82) {\n\t\tDEBUG_ERR(\"%s unknown reply data format\\n\", __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (rep_pl->data_len > *keybufsize) {\n\t\tDEBUG_ERR(\"%s mismatch reply data len / key buffer len\\n\",\n\t\t\t  __func__);\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(keybuf, rep_pl->data, rep_pl->data_len);\n\t*keybufsize = rep_pl->data_len;\n\nout:\n\tkfree(req);\n\tkfree(rep);\n\tkfree(urb);\n\treturn rc;\n}\n\nstatic int ep11_unwrapkey(u16 card, u16 domain,\n\t\t\t  const u8 *kek, size_t keksize,\n\t\t\t  const u8 *enckey, size_t enckeysize,\n\t\t\t  u32 mech, const u8 *iv,\n\t\t\t  u32 keybitsize, u32 keygenflags,\n\t\t\t  u8 *keybuf, size_t *keybufsize,\n\t\t\t  u8 keybufver)\n{\n\tstruct ep11kblob_header *hdr;\n\tsize_t hdr_size, pl_size;\n\tu8 *pl;\n\tint rc;\n\n\trc = ep11_kb_split(keybuf, *keybufsize, keybufver,\n\t\t\t   &hdr, &hdr_size, &pl, &pl_size);\n\tif (rc)\n\t\treturn rc;\n\n\trc = _ep11_unwrapkey(card, domain, kek, keksize, enckey, enckeysize,\n\t\t\t     mech, iv, keybitsize, keygenflags,\n\t\t\t     pl, &pl_size);\n\tif (rc)\n\t\treturn rc;\n\n\t*keybufsize = hdr_size + pl_size;\n\n\t \n\thdr = (struct ep11kblob_header *)keybuf;\n\thdr->type = TOKTYPE_NON_CCA;\n\thdr->len = *keybufsize;\n\thdr->version = keybufver;\n\thdr->bitlen = keybitsize;\n\n\treturn 0;\n}\n\nstatic int _ep11_wrapkey(u16 card, u16 domain,\n\t\t\t const u8 *key, size_t keysize,\n\t\t\t u32 mech, const u8 *iv,\n\t\t\t u8 *databuf, size_t *datasize)\n{\n\tstruct wk_req_pl {\n\t\tstruct pl_head head;\n\t\tu8  var_tag;\n\t\tu8  var_len;\n\t\tu32 var;\n\t\tu8  mech_tag;\n\t\tu8  mech_len;\n\t\tu32 mech;\n\t\t \n\t} __packed * req_pl;\n\tstruct wk_rep_pl {\n\t\tstruct pl_head head;\n\t\tu8  rc_tag;\n\t\tu8  rc_len;\n\t\tu32 rc;\n\t\tu8  data_tag;\n\t\tu8  data_lenfmt;\n\t\tu16 data_len;\n\t\tu8  data[1024];\n\t} __packed * rep_pl;\n\tstruct ep11_cprb *req = NULL, *rep = NULL;\n\tstruct ep11_target_dev target;\n\tstruct ep11_urb *urb = NULL;\n\tsize_t req_pl_size;\n\tint api, rc = -ENOMEM;\n\tu8 *p;\n\n\t \n\treq_pl_size = sizeof(struct wk_req_pl) + (iv ? 16 : 0)\n\t\t+ ASN1TAGLEN(keysize) + 4;\n\treq = alloc_cprb(req_pl_size);\n\tif (!req)\n\t\tgoto out;\n\tif (!mech || mech == 0x80060001)\n\t\treq->flags |= 0x20;  \n\treq_pl = (struct wk_req_pl *)(((u8 *)req) + sizeof(*req));\n\tapi = (!mech || mech == 0x80060001) ?  \n\t\tEP11_API_V4 : EP11_API_V1;\n\tprep_head(&req_pl->head, req_pl_size, api, 33);  \n\treq_pl->var_tag = 0x04;\n\treq_pl->var_len = sizeof(u32);\n\t \n\treq_pl->mech_tag = 0x04;\n\treq_pl->mech_len = sizeof(u32) + (iv ? 16 : 0);\n\treq_pl->mech = (mech ? mech : 0x80060001);  \n\tp = ((u8 *)req_pl) + sizeof(*req_pl);\n\tif (iv) {\n\t\tmemcpy(p, iv, 16);\n\t\tp += 16;\n\t}\n\t \n\tp += asn1tag_write(p, 0x04, key, keysize);\n\t \n\t*p++ = 0x04;\n\t*p++ = 0;\n\t \n\t*p++ = 0x04;\n\t*p++ = 0;\n\n\t \n\trep = alloc_cprb(sizeof(struct wk_rep_pl));\n\tif (!rep)\n\t\tgoto out;\n\trep_pl = (struct wk_rep_pl *)(((u8 *)rep) + sizeof(*rep));\n\n\t \n\turb = kmalloc(sizeof(*urb), GFP_KERNEL);\n\tif (!urb)\n\t\tgoto out;\n\ttarget.ap_id = card;\n\ttarget.dom_id = domain;\n\tprep_urb(urb, &target, 1,\n\t\t req, sizeof(*req) + req_pl_size,\n\t\t rep, sizeof(*rep) + sizeof(*rep_pl));\n\n\trc = zcrypt_send_ep11_cprb(urb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)card, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\trc = check_reply_pl((u8 *)rep_pl, __func__);\n\tif (rc)\n\t\tgoto out;\n\tif (rep_pl->data_tag != 0x04 || rep_pl->data_lenfmt != 0x82) {\n\t\tDEBUG_ERR(\"%s unknown reply data format\\n\", __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (rep_pl->data_len > *datasize) {\n\t\tDEBUG_ERR(\"%s mismatch reply data len / data buffer len\\n\",\n\t\t\t  __func__);\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(databuf, rep_pl->data, rep_pl->data_len);\n\t*datasize = rep_pl->data_len;\n\nout:\n\tkfree(req);\n\tkfree(rep);\n\tkfree(urb);\n\treturn rc;\n}\n\nint ep11_clr2keyblob(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,\n\t\t     const u8 *clrkey, u8 *keybuf, size_t *keybufsize,\n\t\t     u32 keytype)\n{\n\tint rc;\n\tu8 encbuf[64], *kek = NULL;\n\tsize_t clrkeylen, keklen, encbuflen = sizeof(encbuf);\n\n\tif (keybitsize == 128 || keybitsize == 192 || keybitsize == 256) {\n\t\tclrkeylen = keybitsize / 8;\n\t} else {\n\t\tDEBUG_ERR(\n\t\t\t\"%s unknown/unsupported keybitsize %d\\n\",\n\t\t\t__func__, keybitsize);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tkeklen = MAXEP11AESKEYBLOBSIZE;\n\tkek = kmalloc(keklen, GFP_ATOMIC);\n\tif (!kek) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\trc = _ep11_genaeskey(card, domain, 256,\n\t\t\t     0x00006c00,  \n\t\t\t     kek, &keklen);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s generate kek key failed, rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\trc = ep11_cryptsingle(card, domain, 0, 0, def_iv, kek, keklen,\n\t\t\t      clrkey, clrkeylen, encbuf, &encbuflen);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s encrypting key value with kek key failed, rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\trc = ep11_unwrapkey(card, domain, kek, keklen,\n\t\t\t    encbuf, encbuflen, 0, def_iv,\n\t\t\t    keybitsize, 0, keybuf, keybufsize, keytype);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s importing key value as new key failed,, rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(kek);\n\treturn rc;\n}\nEXPORT_SYMBOL(ep11_clr2keyblob);\n\nint ep11_kblob2protkey(u16 card, u16 dom,\n\t\t       const u8 *keyblob, size_t keybloblen,\n\t\t       u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tstruct ep11kblob_header *hdr;\n\tstruct ep11keyblob *key;\n\tsize_t wkbuflen, keylen;\n\tstruct wk_info {\n\t\tu16 version;\n\t\tu8  res1[16];\n\t\tu32 pkeytype;\n\t\tu32 pkeybitsize;\n\t\tu64 pkeysize;\n\t\tu8  res2[8];\n\t\tu8  pkey[];\n\t} __packed * wki;\n\tu8 *wkbuf = NULL;\n\tint rc = -EIO;\n\n\tif (ep11_kb_decode((u8 *)keyblob, keybloblen, &hdr, NULL, &key, &keylen))\n\t\treturn -EINVAL;\n\n\tif (hdr->version == TOKVER_EP11_AES) {\n\t\t \n\t\tmemset(hdr, 0, sizeof(*hdr));\n\t}\n\t \n\n\t \n\twkbuflen = (keylen + AES_BLOCK_SIZE) & (~(AES_BLOCK_SIZE - 1));\n\twkbuf = kmalloc(wkbuflen, GFP_ATOMIC);\n\tif (!wkbuf)\n\t\treturn -ENOMEM;\n\n\t \n\trc = _ep11_wrapkey(card, dom, (u8 *)key, keylen,\n\t\t\t   0, def_iv, wkbuf, &wkbuflen);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s rewrapping ep11 key to pkey failed, rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\twki = (struct wk_info *)wkbuf;\n\n\t \n\tif (wki->version != 1 || wki->pkeytype < 1 || wki->pkeytype > 5) {\n\t\tDEBUG_ERR(\"%s wk info version %d or pkeytype %d mismatch.\\n\",\n\t\t\t  __func__, (int)wki->version, (int)wki->pkeytype);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (wki->pkeytype) {\n\tcase 1:  \n\t\tswitch (wki->pkeysize) {\n\t\tcase 16 + 32:\n\t\t\t \n\t\t\tif (protkeytype)\n\t\t\t\t*protkeytype = PKEY_KEYTYPE_AES_128;\n\t\t\tbreak;\n\t\tcase 24 + 32:\n\t\t\t \n\t\t\tif (protkeytype)\n\t\t\t\t*protkeytype = PKEY_KEYTYPE_AES_192;\n\t\t\tbreak;\n\t\tcase 32 + 32:\n\t\t\t \n\t\t\tif (protkeytype)\n\t\t\t\t*protkeytype = PKEY_KEYTYPE_AES_256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG_ERR(\"%s unknown/unsupported AES pkeysize %d\\n\",\n\t\t\t\t  __func__, (int)wki->pkeysize);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase 3:  \n\tcase 4:  \n\tcase 5:  \n\t\tif (protkeytype)\n\t\t\t*protkeytype = PKEY_KEYTYPE_ECC;\n\t\tbreak;\n\tcase 2:  \n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported key type %d\\n\",\n\t\t\t  __func__, (int)wki->pkeytype);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tif (wki->pkeysize > *protkeylen) {\n\t\tDEBUG_ERR(\"%s wk info pkeysize %llu > protkeysize %u\\n\",\n\t\t\t  __func__, wki->pkeysize, *protkeylen);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy(protkey, wki->pkey, wki->pkeysize);\n\t*protkeylen = wki->pkeysize;\n\nout:\n\tkfree(wkbuf);\n\treturn rc;\n}\nEXPORT_SYMBOL(ep11_kblob2protkey);\n\nint ep11_findcard2(u32 **apqns, u32 *nr_apqns, u16 cardnr, u16 domain,\n\t\t   int minhwtype, int minapi, const u8 *wkvp)\n{\n\tstruct zcrypt_device_status_ext *device_status;\n\tu32 *_apqns = NULL, _nr_apqns = 0;\n\tint i, card, dom, rc = -ENOMEM;\n\tstruct ep11_domain_info edi;\n\tstruct ep11_card_info eci;\n\n\t \n\tdevice_status = kvmalloc_array(MAX_ZDEV_ENTRIES_EXT,\n\t\t\t\t       sizeof(struct zcrypt_device_status_ext),\n\t\t\t\t       GFP_KERNEL);\n\tif (!device_status)\n\t\treturn -ENOMEM;\n\tzcrypt_device_status_mask_ext(device_status);\n\n\t \n\t_apqns = kmalloc_array(256, sizeof(u32), GFP_KERNEL);\n\tif (!_apqns) {\n\t\tkvfree(device_status);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_ZDEV_ENTRIES_EXT; i++) {\n\t\tcard = AP_QID_CARD(device_status[i].qid);\n\t\tdom = AP_QID_QUEUE(device_status[i].qid);\n\t\t \n\t\tif (!device_status[i].online)\n\t\t\tcontinue;\n\t\t \n\t\tif (!(device_status[i].functions & 0x01))\n\t\t\tcontinue;\n\t\t \n\t\tif (cardnr != 0xFFFF && card != cardnr)\n\t\t\tcontinue;\n\t\t \n\t\tif (domain != 0xFFFF && dom != domain)\n\t\t\tcontinue;\n\t\t \n\t\tif (minhwtype && device_status[i].hwtype < minhwtype)\n\t\t\tcontinue;\n\t\t \n\t\tif (minapi > 0) {\n\t\t\tif (ep11_get_card_info(card, &eci, 0))\n\t\t\t\tcontinue;\n\t\t\tif (minapi > eci.API_ord_nr)\n\t\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (wkvp) {\n\t\t\tif (ep11_get_domain_info(card, dom, &edi))\n\t\t\t\tcontinue;\n\t\t\tif (edi.cur_wk_state != '1')\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(wkvp, edi.cur_wkvp, 16))\n\t\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (_nr_apqns < 256)\n\t\t\t_apqns[_nr_apqns++] = (((u16)card) << 16) | ((u16)dom);\n\t}\n\n\t \n\tif (!_nr_apqns) {\n\t\tkfree(_apqns);\n\t\trc = -ENODEV;\n\t} else {\n\t\t \n\t\t*apqns = _apqns;\n\t\t*nr_apqns = _nr_apqns;\n\t\trc = 0;\n\t}\n\n\tkvfree(device_status);\n\treturn rc;\n}\nEXPORT_SYMBOL(ep11_findcard2);\n\nvoid __exit zcrypt_ep11misc_exit(void)\n{\n\tcard_cache_free();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}