{
  "module_name": "vfio_ap_drv.c",
  "hash_id": "a13dfc5006eadf00b5d4a5a61824b48405da700e81699233822e4e911dfe69e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/vfio_ap_drv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <asm/facility.h>\n#include \"vfio_ap_private.h\"\n#include \"vfio_ap_debug.h\"\n\n#define VFIO_AP_ROOT_NAME \"vfio_ap\"\n#define VFIO_AP_DEV_NAME \"matrix\"\n\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"VFIO AP device driver, Copyright IBM Corp. 2018\");\nMODULE_LICENSE(\"GPL v2\");\n\nstruct ap_matrix_dev *matrix_dev;\ndebug_info_t *vfio_ap_dbf_info;\n\n \nstatic struct ap_device_id ap_queue_ids[] = {\n\t{ .dev_type = AP_DEVICE_TYPE_CEX4,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX5,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX6,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX7,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX8,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{   },\n};\n\nstatic struct ap_driver vfio_ap_drv = {\n\t.probe = vfio_ap_mdev_probe_queue,\n\t.remove = vfio_ap_mdev_remove_queue,\n\t.in_use = vfio_ap_mdev_resource_in_use,\n\t.on_config_changed = vfio_ap_on_cfg_changed,\n\t.on_scan_complete = vfio_ap_on_scan_complete,\n\t.ids = ap_queue_ids,\n};\n\nstatic void vfio_ap_matrix_dev_release(struct device *dev)\n{\n\tstruct ap_matrix_dev *matrix_dev;\n\n\tmatrix_dev = container_of(dev, struct ap_matrix_dev, device);\n\tkfree(matrix_dev);\n}\n\nstatic struct bus_type matrix_bus = {\n\t.name = \"matrix\",\n};\n\nstatic struct device_driver matrix_driver = {\n\t.name = \"vfio_ap\",\n\t.bus = &matrix_bus,\n\t.suppress_bind_attrs = true,\n};\n\nstatic int vfio_ap_matrix_dev_create(void)\n{\n\tint ret;\n\tstruct device *root_device;\n\n\troot_device = root_device_register(VFIO_AP_ROOT_NAME);\n\tif (IS_ERR(root_device))\n\t\treturn PTR_ERR(root_device);\n\n\tret = bus_register(&matrix_bus);\n\tif (ret)\n\t\tgoto bus_register_err;\n\n\tmatrix_dev = kzalloc(sizeof(*matrix_dev), GFP_KERNEL);\n\tif (!matrix_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto matrix_alloc_err;\n\t}\n\n\t \n\tif (test_facility(12)) {\n\t\tret = ap_qci(&matrix_dev->info);\n\t\tif (ret)\n\t\t\tgoto matrix_alloc_err;\n\t}\n\n\tmutex_init(&matrix_dev->mdevs_lock);\n\tINIT_LIST_HEAD(&matrix_dev->mdev_list);\n\tmutex_init(&matrix_dev->guests_lock);\n\n\tdev_set_name(&matrix_dev->device, \"%s\", VFIO_AP_DEV_NAME);\n\tmatrix_dev->device.parent = root_device;\n\tmatrix_dev->device.bus = &matrix_bus;\n\tmatrix_dev->device.release = vfio_ap_matrix_dev_release;\n\tmatrix_dev->vfio_ap_drv = &vfio_ap_drv;\n\n\tret = device_register(&matrix_dev->device);\n\tif (ret)\n\t\tgoto matrix_reg_err;\n\n\tret = driver_register(&matrix_driver);\n\tif (ret)\n\t\tgoto matrix_drv_err;\n\n\treturn 0;\n\nmatrix_drv_err:\n\tdevice_del(&matrix_dev->device);\nmatrix_reg_err:\n\tput_device(&matrix_dev->device);\nmatrix_alloc_err:\n\tbus_unregister(&matrix_bus);\nbus_register_err:\n\troot_device_unregister(root_device);\n\treturn ret;\n}\n\nstatic void vfio_ap_matrix_dev_destroy(void)\n{\n\tstruct device *root_device = matrix_dev->device.parent;\n\n\tdriver_unregister(&matrix_driver);\n\tdevice_unregister(&matrix_dev->device);\n\tbus_unregister(&matrix_bus);\n\troot_device_unregister(root_device);\n}\n\nstatic int __init vfio_ap_dbf_info_init(void)\n{\n\tvfio_ap_dbf_info = debug_register(\"vfio_ap\", 1, 1,\n\t\t\t\t\t  DBF_MAX_SPRINTF_ARGS * sizeof(long));\n\n\tif (!vfio_ap_dbf_info)\n\t\treturn -ENOENT;\n\n\tdebug_register_view(vfio_ap_dbf_info, &debug_sprintf_view);\n\tdebug_set_level(vfio_ap_dbf_info, DBF_WARN);\n\n\treturn 0;\n}\n\nstatic int __init vfio_ap_init(void)\n{\n\tint ret;\n\n\tret = vfio_ap_dbf_info_init();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!ap_instructions_available())\n\t\treturn -ENODEV;\n\n\tret = vfio_ap_matrix_dev_create();\n\tif (ret)\n\t\treturn ret;\n\n\tret = ap_driver_register(&vfio_ap_drv, THIS_MODULE, VFIO_AP_DRV_NAME);\n\tif (ret) {\n\t\tvfio_ap_matrix_dev_destroy();\n\t\treturn ret;\n\t}\n\n\tret = vfio_ap_mdev_register();\n\tif (ret) {\n\t\tap_driver_unregister(&vfio_ap_drv);\n\t\tvfio_ap_matrix_dev_destroy();\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit vfio_ap_exit(void)\n{\n\tvfio_ap_mdev_unregister();\n\tap_driver_unregister(&vfio_ap_drv);\n\tvfio_ap_matrix_dev_destroy();\n\tdebug_unregister(vfio_ap_dbf_info);\n}\n\nmodule_init(vfio_ap_init);\nmodule_exit(vfio_ap_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}