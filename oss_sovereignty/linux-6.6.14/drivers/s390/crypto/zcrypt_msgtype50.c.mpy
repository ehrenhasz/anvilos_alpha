{
  "module_name": "zcrypt_msgtype50.c",
  "hash_id": "6879cc498bdaf68f0b945bb2d7a79d58ddb4f8b9fbf62088fccf741bc08783ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/zcrypt_msgtype50.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zcrypt\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n\n#include \"ap_bus.h\"\n#include \"zcrypt_api.h\"\n#include \"zcrypt_error.h\"\n#include \"zcrypt_msgtype50.h\"\n\n \n#define CEX3A_MAX_MOD_SIZE 512\n\n \n#define CEX3A_MAX_RESPONSE_SIZE 0x210\n\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"Cryptographic Accelerator (message type 50), \" \\\n\t\t   \"Copyright IBM Corp. 2001, 2023\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct type50_hdr {\n\tunsigned char\treserved1;\n\tunsigned char\tmsg_type_code;\t \n\tunsigned short\tmsg_len;\n\tunsigned char\treserved2;\n\tunsigned char\tignored;\n\tunsigned short\treserved3;\n} __packed;\n\n#define TYPE50_TYPE_CODE\t0x50\n\n#define TYPE50_MEB1_FMT\t\t0x0001\n#define TYPE50_MEB2_FMT\t\t0x0002\n#define TYPE50_MEB3_FMT\t\t0x0003\n#define TYPE50_CRB1_FMT\t\t0x0011\n#define TYPE50_CRB2_FMT\t\t0x0012\n#define TYPE50_CRB3_FMT\t\t0x0013\n\n \nstruct type50_meb1_msg {\n\tstruct type50_hdr header;\n\tunsigned short\tkeyblock_type;\t \n\tunsigned char\treserved[6];\n\tunsigned char\texponent[128];\n\tunsigned char\tmodulus[128];\n\tunsigned char\tmessage[128];\n} __packed;\n\n \nstruct type50_meb2_msg {\n\tstruct type50_hdr header;\n\tunsigned short\tkeyblock_type;\t \n\tunsigned char\treserved[6];\n\tunsigned char\texponent[256];\n\tunsigned char\tmodulus[256];\n\tunsigned char\tmessage[256];\n} __packed;\n\n \nstruct type50_meb3_msg {\n\tstruct type50_hdr header;\n\tunsigned short\tkeyblock_type;\t \n\tunsigned char\treserved[6];\n\tunsigned char\texponent[512];\n\tunsigned char\tmodulus[512];\n\tunsigned char\tmessage[512];\n} __packed;\n\n \nstruct type50_crb1_msg {\n\tstruct type50_hdr header;\n\tunsigned short\tkeyblock_type;\t \n\tunsigned char\treserved[6];\n\tunsigned char\tp[64];\n\tunsigned char\tq[64];\n\tunsigned char\tdp[64];\n\tunsigned char\tdq[64];\n\tunsigned char\tu[64];\n\tunsigned char\tmessage[128];\n} __packed;\n\n \nstruct type50_crb2_msg {\n\tstruct type50_hdr header;\n\tunsigned short\tkeyblock_type;\t \n\tunsigned char\treserved[6];\n\tunsigned char\tp[128];\n\tunsigned char\tq[128];\n\tunsigned char\tdp[128];\n\tunsigned char\tdq[128];\n\tunsigned char\tu[128];\n\tunsigned char\tmessage[256];\n} __packed;\n\n \nstruct type50_crb3_msg {\n\tstruct type50_hdr header;\n\tunsigned short\tkeyblock_type;\t \n\tunsigned char\treserved[6];\n\tunsigned char\tp[256];\n\tunsigned char\tq[256];\n\tunsigned char\tdp[256];\n\tunsigned char\tdq[256];\n\tunsigned char\tu[256];\n\tunsigned char\tmessage[512];\n} __packed;\n\n \n\n#define TYPE80_RSP_CODE 0x80\n\nstruct type80_hdr {\n\tunsigned char\treserved1;\n\tunsigned char\ttype;\t\t \n\tunsigned short\tlen;\n\tunsigned char\tcode;\t\t \n\tunsigned char\treserved2[3];\n\tunsigned char\treserved3[8];\n} __packed;\n\nint get_rsa_modex_fc(struct ica_rsa_modexpo *mex, int *fcode)\n{\n\tif (!mex->inputdatalength)\n\t\treturn -EINVAL;\n\n\tif (mex->inputdatalength <= 128)\t \n\t\t*fcode = MEX_1K;\n\telse if (mex->inputdatalength <= 256)\t \n\t\t*fcode = MEX_2K;\n\telse\t\t\t\t\t \n\t\t*fcode = MEX_4K;\n\n\treturn 0;\n}\n\nint get_rsa_crt_fc(struct ica_rsa_modexpo_crt *crt, int *fcode)\n{\n\tif (!crt->inputdatalength)\n\t\treturn -EINVAL;\n\n\tif (crt->inputdatalength <= 128)\t \n\t\t*fcode = CRT_1K;\n\telse if (crt->inputdatalength <= 256)\t \n\t\t*fcode = CRT_2K;\n\telse\t\t\t\t\t \n\t\t*fcode = CRT_4K;\n\n\treturn 0;\n}\n\n \nstatic int ICAMEX_msg_to_type50MEX_msg(struct zcrypt_queue *zq,\n\t\t\t\t       struct ap_message *ap_msg,\n\t\t\t\t       struct ica_rsa_modexpo *mex)\n{\n\tunsigned char *mod, *exp, *inp;\n\tint mod_len;\n\n\tmod_len = mex->inputdatalength;\n\n\tif (mod_len <= 128) {\n\t\tstruct type50_meb1_msg *meb1 = ap_msg->msg;\n\n\t\tmemset(meb1, 0, sizeof(*meb1));\n\t\tap_msg->len = sizeof(*meb1);\n\t\tmeb1->header.msg_type_code = TYPE50_TYPE_CODE;\n\t\tmeb1->header.msg_len = sizeof(*meb1);\n\t\tmeb1->keyblock_type = TYPE50_MEB1_FMT;\n\t\tmod = meb1->modulus + sizeof(meb1->modulus) - mod_len;\n\t\texp = meb1->exponent + sizeof(meb1->exponent) - mod_len;\n\t\tinp = meb1->message + sizeof(meb1->message) - mod_len;\n\t} else if (mod_len <= 256) {\n\t\tstruct type50_meb2_msg *meb2 = ap_msg->msg;\n\n\t\tmemset(meb2, 0, sizeof(*meb2));\n\t\tap_msg->len = sizeof(*meb2);\n\t\tmeb2->header.msg_type_code = TYPE50_TYPE_CODE;\n\t\tmeb2->header.msg_len = sizeof(*meb2);\n\t\tmeb2->keyblock_type = TYPE50_MEB2_FMT;\n\t\tmod = meb2->modulus + sizeof(meb2->modulus) - mod_len;\n\t\texp = meb2->exponent + sizeof(meb2->exponent) - mod_len;\n\t\tinp = meb2->message + sizeof(meb2->message) - mod_len;\n\t} else if (mod_len <= 512) {\n\t\tstruct type50_meb3_msg *meb3 = ap_msg->msg;\n\n\t\tmemset(meb3, 0, sizeof(*meb3));\n\t\tap_msg->len = sizeof(*meb3);\n\t\tmeb3->header.msg_type_code = TYPE50_TYPE_CODE;\n\t\tmeb3->header.msg_len = sizeof(*meb3);\n\t\tmeb3->keyblock_type = TYPE50_MEB3_FMT;\n\t\tmod = meb3->modulus + sizeof(meb3->modulus) - mod_len;\n\t\texp = meb3->exponent + sizeof(meb3->exponent) - mod_len;\n\t\tinp = meb3->message + sizeof(meb3->message) - mod_len;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(mod, mex->n_modulus, mod_len) ||\n\t    copy_from_user(exp, mex->b_key, mod_len) ||\n\t    copy_from_user(inp, mex->inputdata, mod_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int ICACRT_msg_to_type50CRT_msg(struct zcrypt_queue *zq,\n\t\t\t\t       struct ap_message *ap_msg,\n\t\t\t\t       struct ica_rsa_modexpo_crt *crt)\n{\n\tint mod_len, short_len;\n\tunsigned char *p, *q, *dp, *dq, *u, *inp;\n\n\tmod_len = crt->inputdatalength;\n\tshort_len = (mod_len + 1) / 2;\n\n\t \n\tif (mod_len <= 128) {\t\t \n\t\tstruct type50_crb1_msg *crb1 = ap_msg->msg;\n\n\t\tmemset(crb1, 0, sizeof(*crb1));\n\t\tap_msg->len = sizeof(*crb1);\n\t\tcrb1->header.msg_type_code = TYPE50_TYPE_CODE;\n\t\tcrb1->header.msg_len = sizeof(*crb1);\n\t\tcrb1->keyblock_type = TYPE50_CRB1_FMT;\n\t\tp = crb1->p + sizeof(crb1->p) - short_len;\n\t\tq = crb1->q + sizeof(crb1->q) - short_len;\n\t\tdp = crb1->dp + sizeof(crb1->dp) - short_len;\n\t\tdq = crb1->dq + sizeof(crb1->dq) - short_len;\n\t\tu = crb1->u + sizeof(crb1->u) - short_len;\n\t\tinp = crb1->message + sizeof(crb1->message) - mod_len;\n\t} else if (mod_len <= 256) {\t \n\t\tstruct type50_crb2_msg *crb2 = ap_msg->msg;\n\n\t\tmemset(crb2, 0, sizeof(*crb2));\n\t\tap_msg->len = sizeof(*crb2);\n\t\tcrb2->header.msg_type_code = TYPE50_TYPE_CODE;\n\t\tcrb2->header.msg_len = sizeof(*crb2);\n\t\tcrb2->keyblock_type = TYPE50_CRB2_FMT;\n\t\tp = crb2->p + sizeof(crb2->p) - short_len;\n\t\tq = crb2->q + sizeof(crb2->q) - short_len;\n\t\tdp = crb2->dp + sizeof(crb2->dp) - short_len;\n\t\tdq = crb2->dq + sizeof(crb2->dq) - short_len;\n\t\tu = crb2->u + sizeof(crb2->u) - short_len;\n\t\tinp = crb2->message + sizeof(crb2->message) - mod_len;\n\t} else if ((mod_len <= 512) &&\t \n\t\t   (zq->zcard->max_mod_size == CEX3A_MAX_MOD_SIZE)) {\n\t\tstruct type50_crb3_msg *crb3 = ap_msg->msg;\n\n\t\tmemset(crb3, 0, sizeof(*crb3));\n\t\tap_msg->len = sizeof(*crb3);\n\t\tcrb3->header.msg_type_code = TYPE50_TYPE_CODE;\n\t\tcrb3->header.msg_len = sizeof(*crb3);\n\t\tcrb3->keyblock_type = TYPE50_CRB3_FMT;\n\t\tp = crb3->p + sizeof(crb3->p) - short_len;\n\t\tq = crb3->q + sizeof(crb3->q) - short_len;\n\t\tdp = crb3->dp + sizeof(crb3->dp) - short_len;\n\t\tdq = crb3->dq + sizeof(crb3->dq) - short_len;\n\t\tu = crb3->u + sizeof(crb3->u) - short_len;\n\t\tinp = crb3->message + sizeof(crb3->message) - mod_len;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (copy_from_user(p, crt->np_prime + MSGTYPE_ADJUSTMENT, short_len) ||\n\t    copy_from_user(q, crt->nq_prime, short_len) ||\n\t    copy_from_user(dp, crt->bp_key + MSGTYPE_ADJUSTMENT, short_len) ||\n\t    copy_from_user(dq, crt->bq_key, short_len) ||\n\t    copy_from_user(u, crt->u_mult_inv + MSGTYPE_ADJUSTMENT, short_len) ||\n\t    copy_from_user(inp, crt->inputdata, mod_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int convert_type80(struct zcrypt_queue *zq,\n\t\t\t  struct ap_message *reply,\n\t\t\t  char __user *outputdata,\n\t\t\t  unsigned int outputdatalength)\n{\n\tstruct type80_hdr *t80h = reply->msg;\n\tunsigned char *data;\n\n\tif (t80h->len < sizeof(*t80h) + outputdatalength) {\n\t\t \n\t\tzq->online = 0;\n\t\tpr_err(\"Crypto dev=%02x.%04x code=0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t       AP_QID_CARD(zq->queue->qid),\n\t\t       AP_QID_QUEUE(zq->queue->qid), t80h->code);\n\t\tZCRYPT_DBF_ERR(\"%s dev=%02x.%04x code=0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t\t       __func__, AP_QID_CARD(zq->queue->qid),\n\t\t\t       AP_QID_QUEUE(zq->queue->qid), t80h->code);\n\t\tap_send_online_uevent(&zq->queue->ap_dev, zq->online);\n\t\treturn -EAGAIN;\n\t}\n\tBUG_ON(t80h->len > CEX3A_MAX_RESPONSE_SIZE);\n\tdata = reply->msg + t80h->len - outputdatalength;\n\tif (copy_to_user(outputdata, data, outputdatalength))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int convert_response(struct zcrypt_queue *zq,\n\t\t\t    struct ap_message *reply,\n\t\t\t    char __user *outputdata,\n\t\t\t    unsigned int outputdatalength)\n{\n\t \n\tunsigned char rtype = ((unsigned char *)reply->msg)[1];\n\n\tswitch (rtype) {\n\tcase TYPE82_RSP_CODE:\n\tcase TYPE88_RSP_CODE:\n\t\treturn convert_error(zq, reply);\n\tcase TYPE80_RSP_CODE:\n\t\treturn convert_type80(zq, reply,\n\t\t\t\t      outputdata, outputdatalength);\n\tdefault:  \n\t\tzq->online = 0;\n\t\tpr_err(\"Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t       AP_QID_CARD(zq->queue->qid),\n\t\t       AP_QID_QUEUE(zq->queue->qid),\n\t\t       (int)rtype);\n\t\tZCRYPT_DBF_ERR(\n\t\t\t\"%s dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\tAP_QID_QUEUE(zq->queue->qid), (int)rtype);\n\t\tap_send_online_uevent(&zq->queue->ap_dev, zq->online);\n\t\treturn -EAGAIN;\n\t}\n}\n\n \nstatic void zcrypt_msgtype50_receive(struct ap_queue *aq,\n\t\t\t\t     struct ap_message *msg,\n\t\t\t\t     struct ap_message *reply)\n{\n\tstatic struct error_hdr error_reply = {\n\t\t.type = TYPE82_RSP_CODE,\n\t\t.reply_code = REP82_ERROR_MACHINE_FAILURE,\n\t};\n\tstruct type80_hdr *t80h;\n\tint len;\n\n\t \n\tif (!reply)\n\t\tgoto out;\t \n\tt80h = reply->msg;\n\tif (t80h->type == TYPE80_RSP_CODE) {\n\t\tlen = t80h->len;\n\t\tif (len > reply->bufsize || len > msg->bufsize ||\n\t\t    len != reply->len) {\n\t\t\tZCRYPT_DBF_DBG(\"%s len mismatch => EMSGSIZE\\n\", __func__);\n\t\t\tmsg->rc = -EMSGSIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(msg->msg, reply->msg, len);\n\t\tmsg->len = len;\n\t} else {\n\t\tmemcpy(msg->msg, reply->msg, sizeof(error_reply));\n\t\tmsg->len = sizeof(error_reply);\n\t}\nout:\n\tcomplete((struct completion *)msg->private);\n}\n\nstatic atomic_t zcrypt_step = ATOMIC_INIT(0);\n\n \nstatic long zcrypt_msgtype50_modexpo(struct zcrypt_queue *zq,\n\t\t\t\t     struct ica_rsa_modexpo *mex,\n\t\t\t\t     struct ap_message *ap_msg)\n{\n\tstruct completion work;\n\tint rc;\n\n\tap_msg->bufsize = MSGTYPE50_CRB3_MAX_MSG_SIZE;\n\tap_msg->msg = kmalloc(ap_msg->bufsize, GFP_KERNEL);\n\tif (!ap_msg->msg)\n\t\treturn -ENOMEM;\n\tap_msg->receive = zcrypt_msgtype50_receive;\n\tap_msg->psmid = (((unsigned long)current->pid) << 32) +\n\t\tatomic_inc_return(&zcrypt_step);\n\tap_msg->private = &work;\n\trc = ICAMEX_msg_to_type50MEX_msg(zq, ap_msg, mex);\n\tif (rc)\n\t\tgoto out;\n\tinit_completion(&work);\n\trc = ap_queue_message(zq->queue, ap_msg);\n\tif (rc)\n\t\tgoto out;\n\trc = wait_for_completion_interruptible(&work);\n\tif (rc == 0) {\n\t\trc = ap_msg->rc;\n\t\tif (rc == 0)\n\t\t\trc = convert_response(zq, ap_msg,\n\t\t\t\t\t      mex->outputdata,\n\t\t\t\t\t      mex->outputdatalength);\n\t} else {\n\t\t \n\t\tap_cancel_message(zq->queue, ap_msg);\n\t}\n\nout:\n\tap_msg->private = NULL;\n\tif (rc)\n\t\tZCRYPT_DBF_DBG(\"%s send me cprb at dev=%02x.%04x rc=%d\\n\",\n\t\t\t       __func__, AP_QID_CARD(zq->queue->qid),\n\t\t\t       AP_QID_QUEUE(zq->queue->qid), rc);\n\treturn rc;\n}\n\n \nstatic long zcrypt_msgtype50_modexpo_crt(struct zcrypt_queue *zq,\n\t\t\t\t\t struct ica_rsa_modexpo_crt *crt,\n\t\t\t\t\t struct ap_message *ap_msg)\n{\n\tstruct completion work;\n\tint rc;\n\n\tap_msg->bufsize = MSGTYPE50_CRB3_MAX_MSG_SIZE;\n\tap_msg->msg = kmalloc(ap_msg->bufsize, GFP_KERNEL);\n\tif (!ap_msg->msg)\n\t\treturn -ENOMEM;\n\tap_msg->receive = zcrypt_msgtype50_receive;\n\tap_msg->psmid = (((unsigned long)current->pid) << 32) +\n\t\tatomic_inc_return(&zcrypt_step);\n\tap_msg->private = &work;\n\trc = ICACRT_msg_to_type50CRT_msg(zq, ap_msg, crt);\n\tif (rc)\n\t\tgoto out;\n\tinit_completion(&work);\n\trc = ap_queue_message(zq->queue, ap_msg);\n\tif (rc)\n\t\tgoto out;\n\trc = wait_for_completion_interruptible(&work);\n\tif (rc == 0) {\n\t\trc = ap_msg->rc;\n\t\tif (rc == 0)\n\t\t\trc = convert_response(zq, ap_msg,\n\t\t\t\t\t      crt->outputdata,\n\t\t\t\t\t      crt->outputdatalength);\n\t} else {\n\t\t \n\t\tap_cancel_message(zq->queue, ap_msg);\n\t}\n\nout:\n\tap_msg->private = NULL;\n\tif (rc)\n\t\tZCRYPT_DBF_DBG(\"%s send crt cprb at dev=%02x.%04x rc=%d\\n\",\n\t\t\t       __func__, AP_QID_CARD(zq->queue->qid),\n\t\t\t       AP_QID_QUEUE(zq->queue->qid), rc);\n\treturn rc;\n}\n\n \nstatic struct zcrypt_ops zcrypt_msgtype50_ops = {\n\t.rsa_modexpo = zcrypt_msgtype50_modexpo,\n\t.rsa_modexpo_crt = zcrypt_msgtype50_modexpo_crt,\n\t.owner = THIS_MODULE,\n\t.name = MSGTYPE50_NAME,\n\t.variant = MSGTYPE50_VARIANT_DEFAULT,\n};\n\nvoid __init zcrypt_msgtype50_init(void)\n{\n\tzcrypt_msgtype_register(&zcrypt_msgtype50_ops);\n}\n\nvoid __exit zcrypt_msgtype50_exit(void)\n{\n\tzcrypt_msgtype_unregister(&zcrypt_msgtype50_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}