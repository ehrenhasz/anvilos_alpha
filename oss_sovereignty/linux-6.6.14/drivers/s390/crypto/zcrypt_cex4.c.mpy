{
  "module_name": "zcrypt_cex4.c",
  "hash_id": "c5b2b5a6f533f2302033f174d9fee1f1b566383d9e843df5ef984487dc76418f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/zcrypt_cex4.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/mod_devicetable.h>\n\n#include \"ap_bus.h\"\n#include \"zcrypt_api.h\"\n#include \"zcrypt_msgtype6.h\"\n#include \"zcrypt_msgtype50.h\"\n#include \"zcrypt_error.h\"\n#include \"zcrypt_cex4.h\"\n#include \"zcrypt_ccamisc.h\"\n#include \"zcrypt_ep11misc.h\"\n\n#define CEX4A_MIN_MOD_SIZE\t  1\t \n#define CEX4A_MAX_MOD_SIZE_2K\t256\t \n#define CEX4A_MAX_MOD_SIZE_4K\t512\t \n\n#define CEX4C_MIN_MOD_SIZE\t 16\t \n#define CEX4C_MAX_MOD_SIZE\t512\t \n\n \n#define CEX4_CLEANUP_TIME\t(900 * HZ)\n\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"CEX[45678] Cryptographic Card device driver, \" \\\n\t\t   \"Copyright IBM Corp. 2022\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct ap_device_id zcrypt_cex4_card_ids[] = {\n\t{ .dev_type = AP_DEVICE_TYPE_CEX4,\n\t  .match_flags = AP_DEVICE_ID_MATCH_CARD_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX5,\n\t  .match_flags = AP_DEVICE_ID_MATCH_CARD_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX6,\n\t  .match_flags = AP_DEVICE_ID_MATCH_CARD_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX7,\n\t  .match_flags = AP_DEVICE_ID_MATCH_CARD_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX8,\n\t  .match_flags = AP_DEVICE_ID_MATCH_CARD_TYPE },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(ap, zcrypt_cex4_card_ids);\n\nstatic struct ap_device_id zcrypt_cex4_queue_ids[] = {\n\t{ .dev_type = AP_DEVICE_TYPE_CEX4,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX5,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX6,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX7,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{ .dev_type = AP_DEVICE_TYPE_CEX8,\n\t  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(ap, zcrypt_cex4_queue_ids);\n\n \nstatic ssize_t cca_serialnr_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct zcrypt_card *zc = dev_get_drvdata(dev);\n\tstruct cca_info ci;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tmemset(&ci, 0, sizeof(ci));\n\n\tif (ap_domain_index >= 0)\n\t\tcca_get_info(ac->id, ap_domain_index, &ci, zc->online);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ci.serial);\n}\n\nstatic struct device_attribute dev_attr_cca_serialnr =\n\t__ATTR(serialnr, 0444, cca_serialnr_show, NULL);\n\nstatic struct attribute *cca_card_attrs[] = {\n\t&dev_attr_cca_serialnr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cca_card_attr_grp = {\n\t.attrs = cca_card_attrs,\n};\n\n  \nstatic ssize_t cca_mkvps_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct zcrypt_queue *zq = dev_get_drvdata(dev);\n\tint n = 0;\n\tstruct cca_info ci;\n\tstatic const char * const cao_state[] = { \"invalid\", \"valid\" };\n\tstatic const char * const new_state[] = { \"empty\", \"partial\", \"full\" };\n\n\tmemset(&ci, 0, sizeof(ci));\n\n\tcca_get_info(AP_QID_CARD(zq->queue->qid),\n\t\t     AP_QID_QUEUE(zq->queue->qid),\n\t\t     &ci, zq->online);\n\n\tif (ci.new_aes_mk_state >= '1' && ci.new_aes_mk_state <= '3')\n\t\tn += sysfs_emit_at(buf, n, \"AES NEW: %s 0x%016llx\\n\",\n\t\t\t\t   new_state[ci.new_aes_mk_state - '1'],\n\t\t\t\t   ci.new_aes_mkvp);\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"AES NEW: - -\\n\");\n\n\tif (ci.cur_aes_mk_state >= '1' && ci.cur_aes_mk_state <= '2')\n\t\tn += sysfs_emit_at(buf, n, \"AES CUR: %s 0x%016llx\\n\",\n\t\t\t\t   cao_state[ci.cur_aes_mk_state - '1'],\n\t\t\t\t   ci.cur_aes_mkvp);\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"AES CUR: - -\\n\");\n\n\tif (ci.old_aes_mk_state >= '1' && ci.old_aes_mk_state <= '2')\n\t\tn += sysfs_emit_at(buf, n, \"AES OLD: %s 0x%016llx\\n\",\n\t\t\t\t   cao_state[ci.old_aes_mk_state - '1'],\n\t\t\t\t   ci.old_aes_mkvp);\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"AES OLD: - -\\n\");\n\n\tif (ci.new_apka_mk_state >= '1' && ci.new_apka_mk_state <= '3')\n\t\tn += sysfs_emit_at(buf, n, \"APKA NEW: %s 0x%016llx\\n\",\n\t\t\t\t   new_state[ci.new_apka_mk_state - '1'],\n\t\t\t\t   ci.new_apka_mkvp);\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"APKA NEW: - -\\n\");\n\n\tif (ci.cur_apka_mk_state >= '1' && ci.cur_apka_mk_state <= '2')\n\t\tn += sysfs_emit_at(buf, n, \"APKA CUR: %s 0x%016llx\\n\",\n\t\t\t\t   cao_state[ci.cur_apka_mk_state - '1'],\n\t\t\t\t   ci.cur_apka_mkvp);\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"APKA CUR: - -\\n\");\n\n\tif (ci.old_apka_mk_state >= '1' && ci.old_apka_mk_state <= '2')\n\t\tn += sysfs_emit_at(buf, n, \"APKA OLD: %s 0x%016llx\\n\",\n\t\t\t\t   cao_state[ci.old_apka_mk_state - '1'],\n\t\t\t\t   ci.old_apka_mkvp);\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"APKA OLD: - -\\n\");\n\n\tif (ci.new_asym_mk_state >= '1' && ci.new_asym_mk_state <= '3')\n\t\tn += sysfs_emit_at(buf, n, \"ASYM NEW: %s 0x%016llx%016llx\\n\",\n\t\t\t\t   new_state[ci.new_asym_mk_state - '1'],\n\t\t\t\t   *((u64 *)(ci.new_asym_mkvp)),\n\t\t\t\t   *((u64 *)(ci.new_asym_mkvp + sizeof(u64))));\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"ASYM NEW: - -\\n\");\n\n\tif (ci.cur_asym_mk_state >= '1' && ci.cur_asym_mk_state <= '2')\n\t\tn += sysfs_emit_at(buf, n, \"ASYM CUR: %s 0x%016llx%016llx\\n\",\n\t\t\t\t   cao_state[ci.cur_asym_mk_state - '1'],\n\t\t\t\t   *((u64 *)(ci.cur_asym_mkvp)),\n\t\t\t\t   *((u64 *)(ci.cur_asym_mkvp + sizeof(u64))));\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"ASYM CUR: - -\\n\");\n\n\tif (ci.old_asym_mk_state >= '1' && ci.old_asym_mk_state <= '2')\n\t\tn += sysfs_emit_at(buf, n, \"ASYM OLD: %s 0x%016llx%016llx\\n\",\n\t\t\t\t   cao_state[ci.old_asym_mk_state - '1'],\n\t\t\t\t   *((u64 *)(ci.old_asym_mkvp)),\n\t\t\t\t   *((u64 *)(ci.old_asym_mkvp + sizeof(u64))));\n\telse\n\t\tn += sysfs_emit_at(buf, n, \"ASYM OLD: - -\\n\");\n\n\treturn n;\n}\n\nstatic struct device_attribute dev_attr_cca_mkvps =\n\t__ATTR(mkvps, 0444, cca_mkvps_show, NULL);\n\nstatic struct attribute *cca_queue_attrs[] = {\n\t&dev_attr_cca_mkvps.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cca_queue_attr_grp = {\n\t.attrs = cca_queue_attrs,\n};\n\n \nstatic ssize_t ep11_api_ordinalnr_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct zcrypt_card *zc = dev_get_drvdata(dev);\n\tstruct ep11_card_info ci;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tmemset(&ci, 0, sizeof(ci));\n\n\tep11_get_card_info(ac->id, &ci, zc->online);\n\n\tif (ci.API_ord_nr > 0)\n\t\treturn sysfs_emit(buf, \"%u\\n\", ci.API_ord_nr);\n\telse\n\t\treturn sysfs_emit(buf, \"\\n\");\n}\n\nstatic struct device_attribute dev_attr_ep11_api_ordinalnr =\n\t__ATTR(API_ordinalnr, 0444, ep11_api_ordinalnr_show, NULL);\n\nstatic ssize_t ep11_fw_version_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct zcrypt_card *zc = dev_get_drvdata(dev);\n\tstruct ep11_card_info ci;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tmemset(&ci, 0, sizeof(ci));\n\n\tep11_get_card_info(ac->id, &ci, zc->online);\n\n\tif (ci.FW_version > 0)\n\t\treturn sysfs_emit(buf, \"%d.%d\\n\",\n\t\t\t\t  (int)(ci.FW_version >> 8),\n\t\t\t\t  (int)(ci.FW_version & 0xFF));\n\telse\n\t\treturn sysfs_emit(buf, \"\\n\");\n}\n\nstatic struct device_attribute dev_attr_ep11_fw_version =\n\t__ATTR(FW_version, 0444, ep11_fw_version_show, NULL);\n\nstatic ssize_t ep11_serialnr_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct zcrypt_card *zc = dev_get_drvdata(dev);\n\tstruct ep11_card_info ci;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tmemset(&ci, 0, sizeof(ci));\n\n\tep11_get_card_info(ac->id, &ci, zc->online);\n\n\tif (ci.serial[0])\n\t\treturn sysfs_emit(buf, \"%16.16s\\n\", ci.serial);\n\telse\n\t\treturn sysfs_emit(buf, \"\\n\");\n}\n\nstatic struct device_attribute dev_attr_ep11_serialnr =\n\t__ATTR(serialnr, 0444, ep11_serialnr_show, NULL);\n\nstatic const struct {\n\tint\t    mode_bit;\n\tconst char *mode_txt;\n} ep11_op_modes[] = {\n\t{ 0, \"FIPS2009\" },\n\t{ 1, \"BSI2009\" },\n\t{ 2, \"FIPS2011\" },\n\t{ 3, \"BSI2011\" },\n\t{ 6, \"BSICC2017\" },\n\t{ 0, NULL }\n};\n\nstatic ssize_t ep11_card_op_modes_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct zcrypt_card *zc = dev_get_drvdata(dev);\n\tint i, n = 0;\n\tstruct ep11_card_info ci;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tmemset(&ci, 0, sizeof(ci));\n\n\tep11_get_card_info(ac->id, &ci, zc->online);\n\n\tfor (i = 0; ep11_op_modes[i].mode_txt; i++) {\n\t\tif (ci.op_mode & (1ULL << ep11_op_modes[i].mode_bit)) {\n\t\t\tif (n > 0)\n\t\t\t\tbuf[n++] = ' ';\n\t\t\tn += sysfs_emit_at(buf, n, \"%s\",\n\t\t\t\t\t   ep11_op_modes[i].mode_txt);\n\t\t}\n\t}\n\tn += sysfs_emit_at(buf, n, \"\\n\");\n\n\treturn n;\n}\n\nstatic struct device_attribute dev_attr_ep11_card_op_modes =\n\t__ATTR(op_modes, 0444, ep11_card_op_modes_show, NULL);\n\nstatic struct attribute *ep11_card_attrs[] = {\n\t&dev_attr_ep11_api_ordinalnr.attr,\n\t&dev_attr_ep11_fw_version.attr,\n\t&dev_attr_ep11_serialnr.attr,\n\t&dev_attr_ep11_card_op_modes.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ep11_card_attr_grp = {\n\t.attrs = ep11_card_attrs,\n};\n\n \n\nstatic ssize_t ep11_mkvps_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct zcrypt_queue *zq = dev_get_drvdata(dev);\n\tint n = 0;\n\tstruct ep11_domain_info di;\n\tstatic const char * const cwk_state[] = { \"invalid\", \"valid\" };\n\tstatic const char * const nwk_state[] = { \"empty\", \"uncommitted\",\n\t\t\t\t\t\t  \"committed\" };\n\n\tmemset(&di, 0, sizeof(di));\n\n\tif (zq->online)\n\t\tep11_get_domain_info(AP_QID_CARD(zq->queue->qid),\n\t\t\t\t     AP_QID_QUEUE(zq->queue->qid),\n\t\t\t\t     &di);\n\n\tif (di.cur_wk_state == '0') {\n\t\tn = sysfs_emit(buf, \"WK CUR: %s -\\n\",\n\t\t\t       cwk_state[di.cur_wk_state - '0']);\n\t} else if (di.cur_wk_state == '1') {\n\t\tn = sysfs_emit(buf, \"WK CUR: %s 0x\",\n\t\t\t       cwk_state[di.cur_wk_state - '0']);\n\t\tbin2hex(buf + n, di.cur_wkvp, sizeof(di.cur_wkvp));\n\t\tn += 2 * sizeof(di.cur_wkvp);\n\t\tn += sysfs_emit_at(buf, n, \"\\n\");\n\t} else {\n\t\tn = sysfs_emit(buf, \"WK CUR: - -\\n\");\n\t}\n\n\tif (di.new_wk_state == '0') {\n\t\tn += sysfs_emit_at(buf, n, \"WK NEW: %s -\\n\",\n\t\t\t\t   nwk_state[di.new_wk_state - '0']);\n\t} else if (di.new_wk_state >= '1' && di.new_wk_state <= '2') {\n\t\tn += sysfs_emit_at(buf, n, \"WK NEW: %s 0x\",\n\t\t\t\t   nwk_state[di.new_wk_state - '0']);\n\t\tbin2hex(buf + n, di.new_wkvp, sizeof(di.new_wkvp));\n\t\tn += 2 * sizeof(di.new_wkvp);\n\t\tn += sysfs_emit_at(buf, n, \"\\n\");\n\t} else {\n\t\tn += sysfs_emit_at(buf, n, \"WK NEW: - -\\n\");\n\t}\n\n\treturn n;\n}\n\nstatic struct device_attribute dev_attr_ep11_mkvps =\n\t__ATTR(mkvps, 0444, ep11_mkvps_show, NULL);\n\nstatic ssize_t ep11_queue_op_modes_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct zcrypt_queue *zq = dev_get_drvdata(dev);\n\tint i, n = 0;\n\tstruct ep11_domain_info di;\n\n\tmemset(&di, 0, sizeof(di));\n\n\tif (zq->online)\n\t\tep11_get_domain_info(AP_QID_CARD(zq->queue->qid),\n\t\t\t\t     AP_QID_QUEUE(zq->queue->qid),\n\t\t\t\t     &di);\n\n\tfor (i = 0; ep11_op_modes[i].mode_txt; i++) {\n\t\tif (di.op_mode & (1ULL << ep11_op_modes[i].mode_bit)) {\n\t\t\tif (n > 0)\n\t\t\t\tbuf[n++] = ' ';\n\t\t\tn += sysfs_emit_at(buf, n, \"%s\",\n\t\t\t\t\t   ep11_op_modes[i].mode_txt);\n\t\t}\n\t}\n\tn += sysfs_emit_at(buf, n, \"\\n\");\n\n\treturn n;\n}\n\nstatic struct device_attribute dev_attr_ep11_queue_op_modes =\n\t__ATTR(op_modes, 0444, ep11_queue_op_modes_show, NULL);\n\nstatic struct attribute *ep11_queue_attrs[] = {\n\t&dev_attr_ep11_mkvps.attr,\n\t&dev_attr_ep11_queue_op_modes.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ep11_queue_attr_grp = {\n\t.attrs = ep11_queue_attrs,\n};\n\n \nstatic int zcrypt_cex4_card_probe(struct ap_device *ap_dev)\n{\n\t \n\tstatic const int CEX4A_SPEED_IDX[NUM_OPS] = {\n\t\t 14,  19, 249, 42, 228, 1458, 0, 0};\n\tstatic const int CEX5A_SPEED_IDX[NUM_OPS] = {\n\t\t  8,   9,  20, 18,  66,\t 458, 0, 0};\n\tstatic const int CEX6A_SPEED_IDX[NUM_OPS] = {\n\t\t  6,   9,  20, 17,  65,\t 438, 0, 0};\n\tstatic const int CEX7A_SPEED_IDX[NUM_OPS] = {\n\t\t  6,   8,  17, 15,  54,\t 362, 0, 0};\n\tstatic const int CEX8A_SPEED_IDX[NUM_OPS] = {\n\t\t  6,   8,  17, 15,  54,\t 362, 0, 0};\n\n\tstatic const int CEX4C_SPEED_IDX[NUM_OPS] = {\n\t\t 59,  69, 308, 83, 278, 2204, 209, 40};\n\tstatic const int CEX5C_SPEED_IDX[] = {\n\t\t 24,  31,  50, 37,  90,\t 479,  27, 10};\n\tstatic const int CEX6C_SPEED_IDX[NUM_OPS] = {\n\t\t 16,  20,  32, 27,  77,\t 455,  24,  9};\n\tstatic const int CEX7C_SPEED_IDX[NUM_OPS] = {\n\t\t 14,  16,  26, 23,  64,\t 376,  23,  8};\n\tstatic const int CEX8C_SPEED_IDX[NUM_OPS] = {\n\t\t 14,  16,  26, 23,  64,\t 376,  23,  8};\n\n\tstatic const int CEX4P_SPEED_IDX[NUM_OPS] = {\n\t\t  0,   0,   0,\t 0,   0,   0,\t0,  50};\n\tstatic const int CEX5P_SPEED_IDX[NUM_OPS] = {\n\t\t  0,   0,   0,\t 0,   0,   0,\t0,  10};\n\tstatic const int CEX6P_SPEED_IDX[NUM_OPS] = {\n\t\t  0,   0,   0,\t 0,   0,   0,\t0,   9};\n\tstatic const int CEX7P_SPEED_IDX[NUM_OPS] = {\n\t\t  0,   0,   0,\t 0,   0,   0,\t0,   8};\n\tstatic const int CEX8P_SPEED_IDX[NUM_OPS] = {\n\t\t  0,   0,   0,\t 0,   0,   0,\t0,   8};\n\n\tstruct ap_card *ac = to_ap_card(&ap_dev->device);\n\tstruct zcrypt_card *zc;\n\tint rc = 0;\n\n\tzc = zcrypt_card_alloc();\n\tif (!zc)\n\t\treturn -ENOMEM;\n\tzc->card = ac;\n\tdev_set_drvdata(&ap_dev->device, zc);\n\tif (ap_test_bit(&ac->functions, AP_FUNC_ACCEL)) {\n\t\tif (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX4) {\n\t\t\tzc->type_string = \"CEX4A\";\n\t\t\tzc->user_space_type = ZCRYPT_CEX4;\n\t\t\tzc->speed_rating = CEX4A_SPEED_IDX;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX5) {\n\t\t\tzc->type_string = \"CEX5A\";\n\t\t\tzc->user_space_type = ZCRYPT_CEX5;\n\t\t\tzc->speed_rating = CEX5A_SPEED_IDX;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX6) {\n\t\t\tzc->type_string = \"CEX6A\";\n\t\t\tzc->user_space_type = ZCRYPT_CEX6;\n\t\t\tzc->speed_rating = CEX6A_SPEED_IDX;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX7) {\n\t\t\tzc->type_string = \"CEX7A\";\n\t\t\tzc->speed_rating = CEX7A_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX6;\n\t\t} else {\n\t\t\tzc->type_string = \"CEX8A\";\n\t\t\tzc->speed_rating = CEX8A_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX6;\n\t\t}\n\t\tzc->min_mod_size = CEX4A_MIN_MOD_SIZE;\n\t\tif (ap_test_bit(&ac->functions, AP_FUNC_MEX4K) &&\n\t\t    ap_test_bit(&ac->functions, AP_FUNC_CRT4K)) {\n\t\t\tzc->max_mod_size = CEX4A_MAX_MOD_SIZE_4K;\n\t\t\tzc->max_exp_bit_length =\n\t\t\t\tCEX4A_MAX_MOD_SIZE_4K;\n\t\t} else {\n\t\t\tzc->max_mod_size = CEX4A_MAX_MOD_SIZE_2K;\n\t\t\tzc->max_exp_bit_length =\n\t\t\t\tCEX4A_MAX_MOD_SIZE_2K;\n\t\t}\n\t} else if (ap_test_bit(&ac->functions, AP_FUNC_COPRO)) {\n\t\tif (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX4) {\n\t\t\tzc->type_string = \"CEX4C\";\n\t\t\tzc->speed_rating = CEX4C_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX3C;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX5) {\n\t\t\tzc->type_string = \"CEX5C\";\n\t\t\tzc->speed_rating = CEX5C_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX3C;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX6) {\n\t\t\tzc->type_string = \"CEX6C\";\n\t\t\tzc->speed_rating = CEX6C_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX3C;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX7) {\n\t\t\tzc->type_string = \"CEX7C\";\n\t\t\tzc->speed_rating = CEX7C_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX3C;\n\t\t} else {\n\t\t\tzc->type_string = \"CEX8C\";\n\t\t\tzc->speed_rating = CEX8C_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX3C;\n\t\t}\n\t\tzc->min_mod_size = CEX4C_MIN_MOD_SIZE;\n\t\tzc->max_mod_size = CEX4C_MAX_MOD_SIZE;\n\t\tzc->max_exp_bit_length = CEX4C_MAX_MOD_SIZE;\n\t} else if (ap_test_bit(&ac->functions, AP_FUNC_EP11)) {\n\t\tif (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX4) {\n\t\t\tzc->type_string = \"CEX4P\";\n\t\t\tzc->user_space_type = ZCRYPT_CEX4;\n\t\t\tzc->speed_rating = CEX4P_SPEED_IDX;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX5) {\n\t\t\tzc->type_string = \"CEX5P\";\n\t\t\tzc->user_space_type = ZCRYPT_CEX5;\n\t\t\tzc->speed_rating = CEX5P_SPEED_IDX;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX6) {\n\t\t\tzc->type_string = \"CEX6P\";\n\t\t\tzc->user_space_type = ZCRYPT_CEX6;\n\t\t\tzc->speed_rating = CEX6P_SPEED_IDX;\n\t\t} else if (ac->ap_dev.device_type == AP_DEVICE_TYPE_CEX7) {\n\t\t\tzc->type_string = \"CEX7P\";\n\t\t\tzc->speed_rating = CEX7P_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX6;\n\t\t} else {\n\t\t\tzc->type_string = \"CEX8P\";\n\t\t\tzc->speed_rating = CEX8P_SPEED_IDX;\n\t\t\t \n\t\t\tzc->user_space_type = ZCRYPT_CEX6;\n\t\t}\n\t\tzc->min_mod_size = CEX4C_MIN_MOD_SIZE;\n\t\tzc->max_mod_size = CEX4C_MAX_MOD_SIZE;\n\t\tzc->max_exp_bit_length = CEX4C_MAX_MOD_SIZE;\n\t} else {\n\t\tzcrypt_card_free(zc);\n\t\treturn -ENODEV;\n\t}\n\tzc->online = 1;\n\n\trc = zcrypt_card_register(zc);\n\tif (rc) {\n\t\tzcrypt_card_free(zc);\n\t\treturn rc;\n\t}\n\n\tif (ap_test_bit(&ac->functions, AP_FUNC_COPRO)) {\n\t\trc = sysfs_create_group(&ap_dev->device.kobj,\n\t\t\t\t\t&cca_card_attr_grp);\n\t\tif (rc) {\n\t\t\tzcrypt_card_unregister(zc);\n\t\t\tzcrypt_card_free(zc);\n\t\t}\n\t} else if (ap_test_bit(&ac->functions, AP_FUNC_EP11)) {\n\t\trc = sysfs_create_group(&ap_dev->device.kobj,\n\t\t\t\t\t&ep11_card_attr_grp);\n\t\tif (rc) {\n\t\t\tzcrypt_card_unregister(zc);\n\t\t\tzcrypt_card_free(zc);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic void zcrypt_cex4_card_remove(struct ap_device *ap_dev)\n{\n\tstruct zcrypt_card *zc = dev_get_drvdata(&ap_dev->device);\n\tstruct ap_card *ac = to_ap_card(&ap_dev->device);\n\n\tif (ap_test_bit(&ac->functions, AP_FUNC_COPRO))\n\t\tsysfs_remove_group(&ap_dev->device.kobj, &cca_card_attr_grp);\n\telse if (ap_test_bit(&ac->functions, AP_FUNC_EP11))\n\t\tsysfs_remove_group(&ap_dev->device.kobj, &ep11_card_attr_grp);\n\n\tzcrypt_card_unregister(zc);\n}\n\nstatic struct ap_driver zcrypt_cex4_card_driver = {\n\t.probe = zcrypt_cex4_card_probe,\n\t.remove = zcrypt_cex4_card_remove,\n\t.ids = zcrypt_cex4_card_ids,\n\t.flags = AP_DRIVER_FLAG_DEFAULT,\n};\n\n \nstatic int zcrypt_cex4_queue_probe(struct ap_device *ap_dev)\n{\n\tstruct ap_queue *aq = to_ap_queue(&ap_dev->device);\n\tstruct zcrypt_queue *zq;\n\tint rc;\n\n\tif (ap_test_bit(&aq->card->functions, AP_FUNC_ACCEL)) {\n\t\tzq = zcrypt_queue_alloc(aq->card->maxmsgsize);\n\t\tif (!zq)\n\t\t\treturn -ENOMEM;\n\t\tzq->ops = zcrypt_msgtype(MSGTYPE50_NAME,\n\t\t\t\t\t MSGTYPE50_VARIANT_DEFAULT);\n\t} else if (ap_test_bit(&aq->card->functions, AP_FUNC_COPRO)) {\n\t\tzq = zcrypt_queue_alloc(aq->card->maxmsgsize);\n\t\tif (!zq)\n\t\t\treturn -ENOMEM;\n\t\tzq->ops = zcrypt_msgtype(MSGTYPE06_NAME,\n\t\t\t\t\t MSGTYPE06_VARIANT_DEFAULT);\n\t} else if (ap_test_bit(&aq->card->functions, AP_FUNC_EP11)) {\n\t\tzq = zcrypt_queue_alloc(aq->card->maxmsgsize);\n\t\tif (!zq)\n\t\t\treturn -ENOMEM;\n\t\tzq->ops = zcrypt_msgtype(MSGTYPE06_NAME,\n\t\t\t\t\t MSGTYPE06_VARIANT_EP11);\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\tzq->queue = aq;\n\tzq->online = 1;\n\tatomic_set(&zq->load, 0);\n\tap_queue_init_state(aq);\n\tap_queue_init_reply(aq, &zq->reply);\n\taq->request_timeout = CEX4_CLEANUP_TIME;\n\tdev_set_drvdata(&ap_dev->device, zq);\n\trc = zcrypt_queue_register(zq);\n\tif (rc) {\n\t\tzcrypt_queue_free(zq);\n\t\treturn rc;\n\t}\n\n\tif (ap_test_bit(&aq->card->functions, AP_FUNC_COPRO)) {\n\t\trc = sysfs_create_group(&ap_dev->device.kobj,\n\t\t\t\t\t&cca_queue_attr_grp);\n\t\tif (rc) {\n\t\t\tzcrypt_queue_unregister(zq);\n\t\t\tzcrypt_queue_free(zq);\n\t\t}\n\t} else if (ap_test_bit(&aq->card->functions, AP_FUNC_EP11)) {\n\t\trc = sysfs_create_group(&ap_dev->device.kobj,\n\t\t\t\t\t&ep11_queue_attr_grp);\n\t\tif (rc) {\n\t\t\tzcrypt_queue_unregister(zq);\n\t\t\tzcrypt_queue_free(zq);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic void zcrypt_cex4_queue_remove(struct ap_device *ap_dev)\n{\n\tstruct zcrypt_queue *zq = dev_get_drvdata(&ap_dev->device);\n\tstruct ap_queue *aq = to_ap_queue(&ap_dev->device);\n\n\tif (ap_test_bit(&aq->card->functions, AP_FUNC_COPRO))\n\t\tsysfs_remove_group(&ap_dev->device.kobj, &cca_queue_attr_grp);\n\telse if (ap_test_bit(&aq->card->functions, AP_FUNC_EP11))\n\t\tsysfs_remove_group(&ap_dev->device.kobj, &ep11_queue_attr_grp);\n\n\tzcrypt_queue_unregister(zq);\n}\n\nstatic struct ap_driver zcrypt_cex4_queue_driver = {\n\t.probe = zcrypt_cex4_queue_probe,\n\t.remove = zcrypt_cex4_queue_remove,\n\t.ids = zcrypt_cex4_queue_ids,\n\t.flags = AP_DRIVER_FLAG_DEFAULT,\n};\n\nint __init zcrypt_cex4_init(void)\n{\n\tint rc;\n\n\trc = ap_driver_register(&zcrypt_cex4_card_driver,\n\t\t\t\tTHIS_MODULE, \"cex4card\");\n\tif (rc)\n\t\treturn rc;\n\n\trc = ap_driver_register(&zcrypt_cex4_queue_driver,\n\t\t\t\tTHIS_MODULE, \"cex4queue\");\n\tif (rc)\n\t\tap_driver_unregister(&zcrypt_cex4_card_driver);\n\n\treturn rc;\n}\n\nvoid __exit zcrypt_cex4_exit(void)\n{\n\tap_driver_unregister(&zcrypt_cex4_queue_driver);\n\tap_driver_unregister(&zcrypt_cex4_card_driver);\n}\n\nmodule_init(zcrypt_cex4_init);\nmodule_exit(zcrypt_cex4_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}