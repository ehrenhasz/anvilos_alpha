{
  "module_name": "zcrypt_api.c",
  "hash_id": "25aadbf0dc0337f3fb1d9b635eeac05311b609b4b48e54def23f23e96c050c56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/zcrypt_api.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/hw_random.h>\n#include <linux/debugfs.h>\n#include <linux/cdev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <asm/debug.h>\n\n#define CREATE_TRACE_POINTS\n#include <asm/trace/zcrypt.h>\n\n#include \"zcrypt_api.h\"\n#include \"zcrypt_debug.h\"\n\n#include \"zcrypt_msgtype6.h\"\n#include \"zcrypt_msgtype50.h\"\n#include \"zcrypt_ccamisc.h\"\n#include \"zcrypt_ep11misc.h\"\n\n \nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"Cryptographic Coprocessor interface, \" \\\n\t\t   \"Copyright IBM Corp. 2001, 2012\");\nMODULE_LICENSE(\"GPL\");\n\n \nEXPORT_TRACEPOINT_SYMBOL(s390_zcrypt_req);\nEXPORT_TRACEPOINT_SYMBOL(s390_zcrypt_rep);\n\nDEFINE_SPINLOCK(zcrypt_list_lock);\nLIST_HEAD(zcrypt_card_list);\n\nstatic atomic_t zcrypt_open_count = ATOMIC_INIT(0);\nstatic atomic_t zcrypt_rescan_count = ATOMIC_INIT(0);\n\natomic_t zcrypt_rescan_req = ATOMIC_INIT(0);\nEXPORT_SYMBOL(zcrypt_rescan_req);\n\nstatic LIST_HEAD(zcrypt_ops_list);\n\n \ndebug_info_t *zcrypt_dbf_info;\n\n \nstatic inline int zcrypt_process_rescan(void)\n{\n\tif (atomic_read(&zcrypt_rescan_req)) {\n\t\tatomic_set(&zcrypt_rescan_req, 0);\n\t\tatomic_inc(&zcrypt_rescan_count);\n\t\tap_bus_force_rescan();\n\t\tZCRYPT_DBF_INFO(\"%s rescan count=%07d\\n\", __func__,\n\t\t\t\tatomic_inc_return(&zcrypt_rescan_count));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid zcrypt_msgtype_register(struct zcrypt_ops *zops)\n{\n\tlist_add_tail(&zops->list, &zcrypt_ops_list);\n}\n\nvoid zcrypt_msgtype_unregister(struct zcrypt_ops *zops)\n{\n\tlist_del_init(&zops->list);\n}\n\nstruct zcrypt_ops *zcrypt_msgtype(unsigned char *name, int variant)\n{\n\tstruct zcrypt_ops *zops;\n\n\tlist_for_each_entry(zops, &zcrypt_ops_list, list)\n\t\tif (zops->variant == variant &&\n\t\t    (!strncmp(zops->name, name, sizeof(zops->name))))\n\t\t\treturn zops;\n\treturn NULL;\n}\nEXPORT_SYMBOL(zcrypt_msgtype);\n\n \n\nstruct zcdn_device;\n\nstatic struct class *zcrypt_class;\nstatic dev_t zcrypt_devt;\nstatic struct cdev zcrypt_cdev;\n\nstruct zcdn_device {\n\tstruct device device;\n\tstruct ap_perms perms;\n};\n\n#define to_zcdn_dev(x) container_of((x), struct zcdn_device, device)\n\n#define ZCDN_MAX_NAME 32\n\nstatic int zcdn_create(const char *name);\nstatic int zcdn_destroy(const char *name);\n\n \nstatic inline struct zcdn_device *find_zcdndev_by_name(const char *name)\n{\n\tstruct device *dev = class_find_device_by_name(zcrypt_class, name);\n\n\treturn dev ? to_zcdn_dev(dev) : NULL;\n}\n\n \nstatic inline struct zcdn_device *find_zcdndev_by_devt(dev_t devt)\n{\n\tstruct device *dev = class_find_device_by_devt(zcrypt_class, devt);\n\n\treturn dev ? to_zcdn_dev(dev) : NULL;\n}\n\nstatic ssize_t ioctlmask_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\tint i, n;\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tn = sysfs_emit(buf, \"0x\");\n\tfor (i = 0; i < sizeof(zcdndev->perms.ioctlm) / sizeof(long); i++)\n\t\tn += sysfs_emit_at(buf, n, \"%016lx\", zcdndev->perms.ioctlm[i]);\n\tn += sysfs_emit_at(buf, n, \"\\n\");\n\n\tmutex_unlock(&ap_perms_mutex);\n\n\treturn n;\n}\n\nstatic ssize_t ioctlmask_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tint rc;\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\n\trc = ap_parse_mask_str(buf, zcdndev->perms.ioctlm,\n\t\t\t       AP_IOCTLS, &ap_perms_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(ioctlmask);\n\nstatic ssize_t apmask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\tint i, n;\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tn = sysfs_emit(buf, \"0x\");\n\tfor (i = 0; i < sizeof(zcdndev->perms.apm) / sizeof(long); i++)\n\t\tn += sysfs_emit_at(buf, n, \"%016lx\", zcdndev->perms.apm[i]);\n\tn += sysfs_emit_at(buf, n, \"\\n\");\n\n\tmutex_unlock(&ap_perms_mutex);\n\n\treturn n;\n}\n\nstatic ssize_t apmask_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint rc;\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\n\trc = ap_parse_mask_str(buf, zcdndev->perms.apm,\n\t\t\t       AP_DEVICES, &ap_perms_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(apmask);\n\nstatic ssize_t aqmask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\tint i, n;\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tn = sysfs_emit(buf, \"0x\");\n\tfor (i = 0; i < sizeof(zcdndev->perms.aqm) / sizeof(long); i++)\n\t\tn += sysfs_emit_at(buf, n, \"%016lx\", zcdndev->perms.aqm[i]);\n\tn += sysfs_emit_at(buf, n, \"\\n\");\n\n\tmutex_unlock(&ap_perms_mutex);\n\n\treturn n;\n}\n\nstatic ssize_t aqmask_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint rc;\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\n\trc = ap_parse_mask_str(buf, zcdndev->perms.aqm,\n\t\t\t       AP_DOMAINS, &ap_perms_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(aqmask);\n\nstatic ssize_t admask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\tint i, n;\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tn = sysfs_emit(buf, \"0x\");\n\tfor (i = 0; i < sizeof(zcdndev->perms.adm) / sizeof(long); i++)\n\t\tn += sysfs_emit_at(buf, n, \"%016lx\", zcdndev->perms.adm[i]);\n\tn += sysfs_emit_at(buf, n, \"\\n\");\n\n\tmutex_unlock(&ap_perms_mutex);\n\n\treturn n;\n}\n\nstatic ssize_t admask_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint rc;\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\n\trc = ap_parse_mask_str(buf, zcdndev->perms.adm,\n\t\t\t       AP_DOMAINS, &ap_perms_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(admask);\n\nstatic struct attribute *zcdn_dev_attrs[] = {\n\t&dev_attr_ioctlmask.attr,\n\t&dev_attr_apmask.attr,\n\t&dev_attr_aqmask.attr,\n\t&dev_attr_admask.attr,\n\tNULL\n};\n\nstatic struct attribute_group zcdn_dev_attr_group = {\n\t.attrs = zcdn_dev_attrs\n};\n\nstatic const struct attribute_group *zcdn_dev_attr_groups[] = {\n\t&zcdn_dev_attr_group,\n\tNULL\n};\n\nstatic ssize_t zcdn_create_store(const struct class *class,\n\t\t\t\t const struct class_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint rc;\n\tchar name[ZCDN_MAX_NAME];\n\n\tstrscpy(name, skip_spaces(buf), sizeof(name));\n\n\trc = zcdn_create(strim(name));\n\n\treturn rc ? rc : count;\n}\n\nstatic const struct class_attribute class_attr_zcdn_create =\n\t__ATTR(create, 0600, NULL, zcdn_create_store);\n\nstatic ssize_t zcdn_destroy_store(const struct class *class,\n\t\t\t\t  const struct class_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint rc;\n\tchar name[ZCDN_MAX_NAME];\n\n\tstrscpy(name, skip_spaces(buf), sizeof(name));\n\n\trc = zcdn_destroy(strim(name));\n\n\treturn rc ? rc : count;\n}\n\nstatic const struct class_attribute class_attr_zcdn_destroy =\n\t__ATTR(destroy, 0600, NULL, zcdn_destroy_store);\n\nstatic void zcdn_device_release(struct device *dev)\n{\n\tstruct zcdn_device *zcdndev = to_zcdn_dev(dev);\n\n\tZCRYPT_DBF_INFO(\"%s releasing zcdn device %d:%d\\n\",\n\t\t\t__func__, MAJOR(dev->devt), MINOR(dev->devt));\n\n\tkfree(zcdndev);\n}\n\nstatic int zcdn_create(const char *name)\n{\n\tdev_t devt;\n\tint i, rc = 0;\n\tstruct zcdn_device *zcdndev;\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (name[0]) {\n\t\tzcdndev = find_zcdndev_by_name(name);\n\t\tif (zcdndev) {\n\t\t\tput_device(&zcdndev->device);\n\t\t\trc = -EEXIST;\n\t\t\tgoto unlockout;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ZCRYPT_MAX_MINOR_NODES; i++) {\n\t\tdevt = MKDEV(MAJOR(zcrypt_devt), MINOR(zcrypt_devt) + i);\n\t\tzcdndev = find_zcdndev_by_devt(devt);\n\t\tif (zcdndev)\n\t\t\tput_device(&zcdndev->device);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (i == ZCRYPT_MAX_MINOR_NODES) {\n\t\trc = -ENOSPC;\n\t\tgoto unlockout;\n\t}\n\n\t \n\tzcdndev = kzalloc(sizeof(*zcdndev), GFP_KERNEL);\n\tif (!zcdndev) {\n\t\trc = -ENOMEM;\n\t\tgoto unlockout;\n\t}\n\tzcdndev->device.release = zcdn_device_release;\n\tzcdndev->device.class = zcrypt_class;\n\tzcdndev->device.devt = devt;\n\tzcdndev->device.groups = zcdn_dev_attr_groups;\n\tif (name[0])\n\t\trc = dev_set_name(&zcdndev->device, \"%s\", name);\n\telse\n\t\trc = dev_set_name(&zcdndev->device, ZCRYPT_NAME \"_%d\", (int)MINOR(devt));\n\tif (rc) {\n\t\tkfree(zcdndev);\n\t\tgoto unlockout;\n\t}\n\trc = device_register(&zcdndev->device);\n\tif (rc) {\n\t\tput_device(&zcdndev->device);\n\t\tgoto unlockout;\n\t}\n\n\tZCRYPT_DBF_INFO(\"%s created zcdn device %d:%d\\n\",\n\t\t\t__func__, MAJOR(devt), MINOR(devt));\n\nunlockout:\n\tmutex_unlock(&ap_perms_mutex);\n\treturn rc;\n}\n\nstatic int zcdn_destroy(const char *name)\n{\n\tint rc = 0;\n\tstruct zcdn_device *zcdndev;\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tzcdndev = find_zcdndev_by_name(name);\n\tif (!zcdndev) {\n\t\trc = -ENOENT;\n\t\tgoto unlockout;\n\t}\n\n\t \n\tput_device(&zcdndev->device);\n\tdevice_unregister(&zcdndev->device);\n\nunlockout:\n\tmutex_unlock(&ap_perms_mutex);\n\treturn rc;\n}\n\nstatic void zcdn_destroy_all(void)\n{\n\tint i;\n\tdev_t devt;\n\tstruct zcdn_device *zcdndev;\n\n\tmutex_lock(&ap_perms_mutex);\n\tfor (i = 0; i < ZCRYPT_MAX_MINOR_NODES; i++) {\n\t\tdevt = MKDEV(MAJOR(zcrypt_devt), MINOR(zcrypt_devt) + i);\n\t\tzcdndev = find_zcdndev_by_devt(devt);\n\t\tif (zcdndev) {\n\t\t\tput_device(&zcdndev->device);\n\t\t\tdevice_unregister(&zcdndev->device);\n\t\t}\n\t}\n\tmutex_unlock(&ap_perms_mutex);\n}\n\n \nstatic ssize_t zcrypt_read(struct file *filp, char __user *buf,\n\t\t\t   size_t count, loff_t *f_pos)\n{\n\treturn -EPERM;\n}\n\n \nstatic ssize_t zcrypt_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t count, loff_t *f_pos)\n{\n\treturn -EPERM;\n}\n\n \nstatic int zcrypt_open(struct inode *inode, struct file *filp)\n{\n\tstruct ap_perms *perms = &ap_perms;\n\n\tif (filp->f_inode->i_cdev == &zcrypt_cdev) {\n\t\tstruct zcdn_device *zcdndev;\n\n\t\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\t\treturn -ERESTARTSYS;\n\t\tzcdndev = find_zcdndev_by_devt(filp->f_inode->i_rdev);\n\t\t \n\t\tmutex_unlock(&ap_perms_mutex);\n\t\tif (zcdndev)\n\t\t\tperms = &zcdndev->perms;\n\t}\n\tfilp->private_data = (void *)perms;\n\n\tatomic_inc(&zcrypt_open_count);\n\treturn stream_open(inode, filp);\n}\n\n \nstatic int zcrypt_release(struct inode *inode, struct file *filp)\n{\n\tif (filp->f_inode->i_cdev == &zcrypt_cdev) {\n\t\tstruct zcdn_device *zcdndev;\n\n\t\tmutex_lock(&ap_perms_mutex);\n\t\tzcdndev = find_zcdndev_by_devt(filp->f_inode->i_rdev);\n\t\tmutex_unlock(&ap_perms_mutex);\n\t\tif (zcdndev) {\n\t\t\t \n\t\t\tput_device(&zcdndev->device);\n\t\t\tput_device(&zcdndev->device);\n\t\t}\n\t}\n\n\tatomic_dec(&zcrypt_open_count);\n\treturn 0;\n}\n\nstatic inline int zcrypt_check_ioctl(struct ap_perms *perms,\n\t\t\t\t     unsigned int cmd)\n{\n\tint rc = -EPERM;\n\tint ioctlnr = (cmd & _IOC_NRMASK) >> _IOC_NRSHIFT;\n\n\tif (ioctlnr > 0 && ioctlnr < AP_IOCTLS) {\n\t\tif (test_bit_inv(ioctlnr, perms->ioctlm))\n\t\t\trc = 0;\n\t}\n\n\tif (rc)\n\t\tZCRYPT_DBF_WARN(\"%s ioctl check failed: ioctlnr=0x%04x rc=%d\\n\",\n\t\t\t\t__func__, ioctlnr, rc);\n\n\treturn rc;\n}\n\nstatic inline bool zcrypt_check_card(struct ap_perms *perms, int card)\n{\n\treturn test_bit_inv(card, perms->apm) ? true : false;\n}\n\nstatic inline bool zcrypt_check_queue(struct ap_perms *perms, int queue)\n{\n\treturn test_bit_inv(queue, perms->aqm) ? true : false;\n}\n\nstatic inline struct zcrypt_queue *zcrypt_pick_queue(struct zcrypt_card *zc,\n\t\t\t\t\t\t     struct zcrypt_queue *zq,\n\t\t\t\t\t\t     struct module **pmod,\n\t\t\t\t\t\t     unsigned int weight)\n{\n\tif (!zq || !try_module_get(zq->queue->ap_dev.device.driver->owner))\n\t\treturn NULL;\n\tzcrypt_queue_get(zq);\n\tget_device(&zq->queue->ap_dev.device);\n\tatomic_add(weight, &zc->load);\n\tatomic_add(weight, &zq->load);\n\tzq->request_count++;\n\t*pmod = zq->queue->ap_dev.device.driver->owner;\n\treturn zq;\n}\n\nstatic inline void zcrypt_drop_queue(struct zcrypt_card *zc,\n\t\t\t\t     struct zcrypt_queue *zq,\n\t\t\t\t     struct module *mod,\n\t\t\t\t     unsigned int weight)\n{\n\tzq->request_count--;\n\tatomic_sub(weight, &zc->load);\n\tatomic_sub(weight, &zq->load);\n\tput_device(&zq->queue->ap_dev.device);\n\tzcrypt_queue_put(zq);\n\tmodule_put(mod);\n}\n\nstatic inline bool zcrypt_card_compare(struct zcrypt_card *zc,\n\t\t\t\t       struct zcrypt_card *pref_zc,\n\t\t\t\t       unsigned int weight,\n\t\t\t\t       unsigned int pref_weight)\n{\n\tif (!pref_zc)\n\t\treturn true;\n\tweight += atomic_read(&zc->load);\n\tpref_weight += atomic_read(&pref_zc->load);\n\tif (weight == pref_weight)\n\t\treturn atomic64_read(&zc->card->total_request_count) <\n\t\t\tatomic64_read(&pref_zc->card->total_request_count);\n\treturn weight < pref_weight;\n}\n\nstatic inline bool zcrypt_queue_compare(struct zcrypt_queue *zq,\n\t\t\t\t\tstruct zcrypt_queue *pref_zq,\n\t\t\t\t\tunsigned int weight,\n\t\t\t\t\tunsigned int pref_weight)\n{\n\tif (!pref_zq)\n\t\treturn true;\n\tweight += atomic_read(&zq->load);\n\tpref_weight += atomic_read(&pref_zq->load);\n\tif (weight == pref_weight)\n\t\treturn zq->queue->total_request_count <\n\t\t\tpref_zq->queue->total_request_count;\n\treturn weight < pref_weight;\n}\n\n \nstatic long zcrypt_rsa_modexpo(struct ap_perms *perms,\n\t\t\t       struct zcrypt_track *tr,\n\t\t\t       struct ica_rsa_modexpo *mex)\n{\n\tstruct zcrypt_card *zc, *pref_zc;\n\tstruct zcrypt_queue *zq, *pref_zq;\n\tstruct ap_message ap_msg;\n\tunsigned int wgt = 0, pref_wgt = 0;\n\tunsigned int func_code;\n\tint cpen, qpen, qid = 0, rc = -ENODEV;\n\tstruct module *mod;\n\n\ttrace_s390_zcrypt_req(mex, TP_ICARSAMODEXPO);\n\n\tap_init_message(&ap_msg);\n\n\tif (mex->outputdatalength < mex->inputdatalength) {\n\t\tfunc_code = 0;\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tmex->outputdatalength = mex->inputdatalength;\n\n\trc = get_rsa_modex_fc(mex, &func_code);\n\tif (rc)\n\t\tgoto out;\n\n\tpref_zc = NULL;\n\tpref_zq = NULL;\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\t \n\t\tif (!zc->online || !zc->card->config || zc->card->chkstop ||\n\t\t    !(zc->card->functions & 0x18000000))\n\t\t\tcontinue;\n\t\t \n\t\tif (zc->min_mod_size > mex->inputdatalength ||\n\t\t    zc->max_mod_size < mex->inputdatalength)\n\t\t\tcontinue;\n\t\t \n\t\tif (!zcrypt_check_card(perms, zc->card->id))\n\t\t\tcontinue;\n\t\t \n\t\twgt = zc->speed_rating[func_code];\n\t\t \n\t\tcpen = (tr && tr->again_counter && tr->last_qid &&\n\t\t\tAP_QID_CARD(tr->last_qid) == zc->card->id) ?\n\t\t\tTRACK_AGAIN_CARD_WEIGHT_PENALTY : 0;\n\t\tif (!zcrypt_card_compare(zc, pref_zc, wgt + cpen, pref_wgt))\n\t\t\tcontinue;\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\t \n\t\t\tif (!zq->online || !zq->ops->rsa_modexpo ||\n\t\t\t    !zq->queue->config || zq->queue->chkstop)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!zcrypt_check_queue(perms,\n\t\t\t\t\t\tAP_QID_QUEUE(zq->queue->qid)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tqpen = (tr && tr->again_counter && tr->last_qid &&\n\t\t\t\ttr->last_qid == zq->queue->qid) ?\n\t\t\t\tTRACK_AGAIN_QUEUE_WEIGHT_PENALTY : 0;\n\t\t\tif (!zcrypt_queue_compare(zq, pref_zq,\n\t\t\t\t\t\t  wgt + cpen + qpen, pref_wgt))\n\t\t\t\tcontinue;\n\t\t\tpref_zc = zc;\n\t\t\tpref_zq = zq;\n\t\t\tpref_wgt = wgt + cpen + qpen;\n\t\t}\n\t}\n\tpref_zq = zcrypt_pick_queue(pref_zc, pref_zq, &mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\n\tif (!pref_zq) {\n\t\tZCRYPT_DBF_DBG(\"%s no matching queue found => ENODEV\\n\",\n\t\t\t       __func__);\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tqid = pref_zq->queue->qid;\n\trc = pref_zq->ops->rsa_modexpo(pref_zq, mex, &ap_msg);\n\n\tspin_lock(&zcrypt_list_lock);\n\tzcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\nout:\n\tap_release_message(&ap_msg);\n\tif (tr) {\n\t\ttr->last_rc = rc;\n\t\ttr->last_qid = qid;\n\t}\n\ttrace_s390_zcrypt_rep(mex, func_code, rc,\n\t\t\t      AP_QID_CARD(qid), AP_QID_QUEUE(qid));\n\treturn rc;\n}\n\nstatic long zcrypt_rsa_crt(struct ap_perms *perms,\n\t\t\t   struct zcrypt_track *tr,\n\t\t\t   struct ica_rsa_modexpo_crt *crt)\n{\n\tstruct zcrypt_card *zc, *pref_zc;\n\tstruct zcrypt_queue *zq, *pref_zq;\n\tstruct ap_message ap_msg;\n\tunsigned int wgt = 0, pref_wgt = 0;\n\tunsigned int func_code;\n\tint cpen, qpen, qid = 0, rc = -ENODEV;\n\tstruct module *mod;\n\n\ttrace_s390_zcrypt_req(crt, TP_ICARSACRT);\n\n\tap_init_message(&ap_msg);\n\n\tif (crt->outputdatalength < crt->inputdatalength) {\n\t\tfunc_code = 0;\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tcrt->outputdatalength = crt->inputdatalength;\n\n\trc = get_rsa_crt_fc(crt, &func_code);\n\tif (rc)\n\t\tgoto out;\n\n\tpref_zc = NULL;\n\tpref_zq = NULL;\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\t \n\t\tif (!zc->online || !zc->card->config || zc->card->chkstop ||\n\t\t    !(zc->card->functions & 0x18000000))\n\t\t\tcontinue;\n\t\t \n\t\tif (zc->min_mod_size > crt->inputdatalength ||\n\t\t    zc->max_mod_size < crt->inputdatalength)\n\t\t\tcontinue;\n\t\t \n\t\tif (!zcrypt_check_card(perms, zc->card->id))\n\t\t\tcontinue;\n\t\t \n\t\twgt = zc->speed_rating[func_code];\n\t\t \n\t\tcpen = (tr && tr->again_counter && tr->last_qid &&\n\t\t\tAP_QID_CARD(tr->last_qid) == zc->card->id) ?\n\t\t\tTRACK_AGAIN_CARD_WEIGHT_PENALTY : 0;\n\t\tif (!zcrypt_card_compare(zc, pref_zc, wgt + cpen, pref_wgt))\n\t\t\tcontinue;\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\t \n\t\t\tif (!zq->online || !zq->ops->rsa_modexpo_crt ||\n\t\t\t    !zq->queue->config || zq->queue->chkstop)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!zcrypt_check_queue(perms,\n\t\t\t\t\t\tAP_QID_QUEUE(zq->queue->qid)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tqpen = (tr && tr->again_counter && tr->last_qid &&\n\t\t\t\ttr->last_qid == zq->queue->qid) ?\n\t\t\t\tTRACK_AGAIN_QUEUE_WEIGHT_PENALTY : 0;\n\t\t\tif (!zcrypt_queue_compare(zq, pref_zq,\n\t\t\t\t\t\t  wgt + cpen + qpen, pref_wgt))\n\t\t\t\tcontinue;\n\t\t\tpref_zc = zc;\n\t\t\tpref_zq = zq;\n\t\t\tpref_wgt = wgt + cpen + qpen;\n\t\t}\n\t}\n\tpref_zq = zcrypt_pick_queue(pref_zc, pref_zq, &mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\n\tif (!pref_zq) {\n\t\tZCRYPT_DBF_DBG(\"%s no matching queue found => ENODEV\\n\",\n\t\t\t       __func__);\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tqid = pref_zq->queue->qid;\n\trc = pref_zq->ops->rsa_modexpo_crt(pref_zq, crt, &ap_msg);\n\n\tspin_lock(&zcrypt_list_lock);\n\tzcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\nout:\n\tap_release_message(&ap_msg);\n\tif (tr) {\n\t\ttr->last_rc = rc;\n\t\ttr->last_qid = qid;\n\t}\n\ttrace_s390_zcrypt_rep(crt, func_code, rc,\n\t\t\t      AP_QID_CARD(qid), AP_QID_QUEUE(qid));\n\treturn rc;\n}\n\nstatic long _zcrypt_send_cprb(bool userspace, struct ap_perms *perms,\n\t\t\t      struct zcrypt_track *tr,\n\t\t\t      struct ica_xcRB *xcrb)\n{\n\tstruct zcrypt_card *zc, *pref_zc;\n\tstruct zcrypt_queue *zq, *pref_zq;\n\tstruct ap_message ap_msg;\n\tunsigned int wgt = 0, pref_wgt = 0;\n\tunsigned int func_code;\n\tunsigned short *domain, tdom;\n\tint cpen, qpen, qid = 0, rc = -ENODEV;\n\tstruct module *mod;\n\n\ttrace_s390_zcrypt_req(xcrb, TB_ZSECSENDCPRB);\n\n\txcrb->status = 0;\n\tap_init_message(&ap_msg);\n\n\trc = prep_cca_ap_msg(userspace, xcrb, &ap_msg, &func_code, &domain);\n\tif (rc)\n\t\tgoto out;\n\n\ttdom = *domain;\n\tif (perms != &ap_perms && tdom < AP_DOMAINS) {\n\t\tif (ap_msg.flags & AP_MSG_FLAG_ADMIN) {\n\t\t\tif (!test_bit_inv(tdom, perms->adm)) {\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if ((ap_msg.flags & AP_MSG_FLAG_USAGE) == 0) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tif (tdom < AP_DOMAINS &&\n\t    !ap_test_config_usage_domain(tdom) &&\n\t    ap_test_config_ctrl_domain(tdom))\n\t\ttdom = AUTOSEL_DOM;\n\n\tpref_zc = NULL;\n\tpref_zq = NULL;\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\t \n\t\tif (!zc->online || !zc->card->config || zc->card->chkstop ||\n\t\t    !(zc->card->functions & 0x10000000))\n\t\t\tcontinue;\n\t\t \n\t\tif (xcrb->user_defined != AUTOSELECT &&\n\t\t    xcrb->user_defined != zc->card->id)\n\t\t\tcontinue;\n\t\t \n\t\tif (ap_msg.len > zc->card->maxmsgsize)\n\t\t\tcontinue;\n\t\t \n\t\tif (!zcrypt_check_card(perms, zc->card->id))\n\t\t\tcontinue;\n\t\t \n\t\twgt = speed_idx_cca(func_code) * zc->speed_rating[SECKEY];\n\t\t \n\t\tcpen = (tr && tr->again_counter && tr->last_qid &&\n\t\t\tAP_QID_CARD(tr->last_qid) == zc->card->id) ?\n\t\t\tTRACK_AGAIN_CARD_WEIGHT_PENALTY : 0;\n\t\tif (!zcrypt_card_compare(zc, pref_zc, wgt + cpen, pref_wgt))\n\t\t\tcontinue;\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\t \n\t\t\tif (!zq->online || !zq->ops->send_cprb ||\n\t\t\t    !zq->queue->config || zq->queue->chkstop ||\n\t\t\t    (tdom != AUTOSEL_DOM &&\n\t\t\t     tdom != AP_QID_QUEUE(zq->queue->qid)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!zcrypt_check_queue(perms,\n\t\t\t\t\t\tAP_QID_QUEUE(zq->queue->qid)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tqpen = (tr && tr->again_counter && tr->last_qid &&\n\t\t\t\ttr->last_qid == zq->queue->qid) ?\n\t\t\t\tTRACK_AGAIN_QUEUE_WEIGHT_PENALTY : 0;\n\t\t\tif (!zcrypt_queue_compare(zq, pref_zq,\n\t\t\t\t\t\t  wgt + cpen + qpen, pref_wgt))\n\t\t\t\tcontinue;\n\t\t\tpref_zc = zc;\n\t\t\tpref_zq = zq;\n\t\t\tpref_wgt = wgt + cpen + qpen;\n\t\t}\n\t}\n\tpref_zq = zcrypt_pick_queue(pref_zc, pref_zq, &mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\n\tif (!pref_zq) {\n\t\tZCRYPT_DBF_DBG(\"%s no match for address %02x.%04x => ENODEV\\n\",\n\t\t\t       __func__, xcrb->user_defined, *domain);\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tqid = pref_zq->queue->qid;\n\tif (*domain == AUTOSEL_DOM)\n\t\t*domain = AP_QID_QUEUE(qid);\n\n\trc = pref_zq->ops->send_cprb(userspace, pref_zq, xcrb, &ap_msg);\n\n\tspin_lock(&zcrypt_list_lock);\n\tzcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\nout:\n\tap_release_message(&ap_msg);\n\tif (tr) {\n\t\ttr->last_rc = rc;\n\t\ttr->last_qid = qid;\n\t}\n\ttrace_s390_zcrypt_rep(xcrb, func_code, rc,\n\t\t\t      AP_QID_CARD(qid), AP_QID_QUEUE(qid));\n\treturn rc;\n}\n\nlong zcrypt_send_cprb(struct ica_xcRB *xcrb)\n{\n\treturn _zcrypt_send_cprb(false, &ap_perms, NULL, xcrb);\n}\nEXPORT_SYMBOL(zcrypt_send_cprb);\n\nstatic bool is_desired_ep11_card(unsigned int dev_id,\n\t\t\t\t unsigned short target_num,\n\t\t\t\t struct ep11_target_dev *targets)\n{\n\twhile (target_num-- > 0) {\n\t\tif (targets->ap_id == dev_id || targets->ap_id == AUTOSEL_AP)\n\t\t\treturn true;\n\t\ttargets++;\n\t}\n\treturn false;\n}\n\nstatic bool is_desired_ep11_queue(unsigned int dev_qid,\n\t\t\t\t  unsigned short target_num,\n\t\t\t\t  struct ep11_target_dev *targets)\n{\n\tint card = AP_QID_CARD(dev_qid), dom = AP_QID_QUEUE(dev_qid);\n\n\twhile (target_num-- > 0) {\n\t\tif ((targets->ap_id == card || targets->ap_id == AUTOSEL_AP) &&\n\t\t    (targets->dom_id == dom || targets->dom_id == AUTOSEL_DOM))\n\t\t\treturn true;\n\t\ttargets++;\n\t}\n\treturn false;\n}\n\nstatic long _zcrypt_send_ep11_cprb(bool userspace, struct ap_perms *perms,\n\t\t\t\t   struct zcrypt_track *tr,\n\t\t\t\t   struct ep11_urb *xcrb)\n{\n\tstruct zcrypt_card *zc, *pref_zc;\n\tstruct zcrypt_queue *zq, *pref_zq;\n\tstruct ep11_target_dev *targets;\n\tunsigned short target_num;\n\tunsigned int wgt = 0, pref_wgt = 0;\n\tunsigned int func_code, domain;\n\tstruct ap_message ap_msg;\n\tint cpen, qpen, qid = 0, rc = -ENODEV;\n\tstruct module *mod;\n\n\ttrace_s390_zcrypt_req(xcrb, TP_ZSENDEP11CPRB);\n\n\tap_init_message(&ap_msg);\n\n\ttarget_num = (unsigned short)xcrb->targets_num;\n\n\t \n\ttargets = NULL;\n\tif (target_num != 0) {\n\t\tstruct ep11_target_dev __user *uptr;\n\n\t\ttargets = kcalloc(target_num, sizeof(*targets), GFP_KERNEL);\n\t\tif (!targets) {\n\t\t\tfunc_code = 0;\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tuptr = (struct ep11_target_dev __force __user *)xcrb->targets;\n\t\tif (z_copy_from_user(userspace, targets, uptr,\n\t\t\t\t     target_num * sizeof(*targets))) {\n\t\t\tfunc_code = 0;\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\trc = prep_ep11_ap_msg(userspace, xcrb, &ap_msg, &func_code, &domain);\n\tif (rc)\n\t\tgoto out_free;\n\n\tif (perms != &ap_perms && domain < AUTOSEL_DOM) {\n\t\tif (ap_msg.flags & AP_MSG_FLAG_ADMIN) {\n\t\t\tif (!test_bit_inv(domain, perms->adm)) {\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t} else if ((ap_msg.flags & AP_MSG_FLAG_USAGE) == 0) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tpref_zc = NULL;\n\tpref_zq = NULL;\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\t \n\t\tif (!zc->online || !zc->card->config || zc->card->chkstop ||\n\t\t    !(zc->card->functions & 0x04000000))\n\t\t\tcontinue;\n\t\t \n\t\tif (targets &&\n\t\t    !is_desired_ep11_card(zc->card->id, target_num, targets))\n\t\t\tcontinue;\n\t\t \n\t\tif (ap_msg.len > zc->card->maxmsgsize)\n\t\t\tcontinue;\n\t\t \n\t\tif (!zcrypt_check_card(perms, zc->card->id))\n\t\t\tcontinue;\n\t\t \n\t\twgt = speed_idx_ep11(func_code) * zc->speed_rating[SECKEY];\n\t\t \n\t\tcpen = (tr && tr->again_counter && tr->last_qid &&\n\t\t\tAP_QID_CARD(tr->last_qid) == zc->card->id) ?\n\t\t\tTRACK_AGAIN_CARD_WEIGHT_PENALTY : 0;\n\t\tif (!zcrypt_card_compare(zc, pref_zc, wgt + cpen, pref_wgt))\n\t\t\tcontinue;\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\t \n\t\t\tif (!zq->online || !zq->ops->send_ep11_cprb ||\n\t\t\t    !zq->queue->config || zq->queue->chkstop ||\n\t\t\t    (targets &&\n\t\t\t     !is_desired_ep11_queue(zq->queue->qid,\n\t\t\t\t\t\t    target_num, targets)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!zcrypt_check_queue(perms,\n\t\t\t\t\t\tAP_QID_QUEUE(zq->queue->qid)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tqpen = (tr && tr->again_counter && tr->last_qid &&\n\t\t\t\ttr->last_qid == zq->queue->qid) ?\n\t\t\t\tTRACK_AGAIN_QUEUE_WEIGHT_PENALTY : 0;\n\t\t\tif (!zcrypt_queue_compare(zq, pref_zq,\n\t\t\t\t\t\t  wgt + cpen + qpen, pref_wgt))\n\t\t\t\tcontinue;\n\t\t\tpref_zc = zc;\n\t\t\tpref_zq = zq;\n\t\t\tpref_wgt = wgt + cpen + qpen;\n\t\t}\n\t}\n\tpref_zq = zcrypt_pick_queue(pref_zc, pref_zq, &mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\n\tif (!pref_zq) {\n\t\tif (targets && target_num == 1) {\n\t\t\tZCRYPT_DBF_DBG(\"%s no match for address %02x.%04x => ENODEV\\n\",\n\t\t\t\t       __func__, (int)targets->ap_id,\n\t\t\t\t       (int)targets->dom_id);\n\t\t} else if (targets) {\n\t\t\tZCRYPT_DBF_DBG(\"%s no match for %d target addrs => ENODEV\\n\",\n\t\t\t\t       __func__, (int)target_num);\n\t\t} else {\n\t\t\tZCRYPT_DBF_DBG(\"%s no match for address ff.ffff => ENODEV\\n\",\n\t\t\t\t       __func__);\n\t\t}\n\t\trc = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tqid = pref_zq->queue->qid;\n\trc = pref_zq->ops->send_ep11_cprb(userspace, pref_zq, xcrb, &ap_msg);\n\n\tspin_lock(&zcrypt_list_lock);\n\tzcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\nout_free:\n\tkfree(targets);\nout:\n\tap_release_message(&ap_msg);\n\tif (tr) {\n\t\ttr->last_rc = rc;\n\t\ttr->last_qid = qid;\n\t}\n\ttrace_s390_zcrypt_rep(xcrb, func_code, rc,\n\t\t\t      AP_QID_CARD(qid), AP_QID_QUEUE(qid));\n\treturn rc;\n}\n\nlong zcrypt_send_ep11_cprb(struct ep11_urb *xcrb)\n{\n\treturn _zcrypt_send_ep11_cprb(false, &ap_perms, NULL, xcrb);\n}\nEXPORT_SYMBOL(zcrypt_send_ep11_cprb);\n\nstatic long zcrypt_rng(char *buffer)\n{\n\tstruct zcrypt_card *zc, *pref_zc;\n\tstruct zcrypt_queue *zq, *pref_zq;\n\tunsigned int wgt = 0, pref_wgt = 0;\n\tunsigned int func_code;\n\tstruct ap_message ap_msg;\n\tunsigned int domain;\n\tint qid = 0, rc = -ENODEV;\n\tstruct module *mod;\n\n\ttrace_s390_zcrypt_req(buffer, TP_HWRNGCPRB);\n\n\tap_init_message(&ap_msg);\n\trc = prep_rng_ap_msg(&ap_msg, &func_code, &domain);\n\tif (rc)\n\t\tgoto out;\n\n\tpref_zc = NULL;\n\tpref_zq = NULL;\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\t \n\t\tif (!zc->online || !zc->card->config || zc->card->chkstop ||\n\t\t    !(zc->card->functions & 0x10000000))\n\t\t\tcontinue;\n\t\t \n\t\twgt = zc->speed_rating[func_code];\n\t\tif (!zcrypt_card_compare(zc, pref_zc, wgt, pref_wgt))\n\t\t\tcontinue;\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\t \n\t\t\tif (!zq->online || !zq->ops->rng ||\n\t\t\t    !zq->queue->config || zq->queue->chkstop)\n\t\t\t\tcontinue;\n\t\t\tif (!zcrypt_queue_compare(zq, pref_zq, wgt, pref_wgt))\n\t\t\t\tcontinue;\n\t\t\tpref_zc = zc;\n\t\t\tpref_zq = zq;\n\t\t\tpref_wgt = wgt;\n\t\t}\n\t}\n\tpref_zq = zcrypt_pick_queue(pref_zc, pref_zq, &mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\n\tif (!pref_zq) {\n\t\tZCRYPT_DBF_DBG(\"%s no matching queue found => ENODEV\\n\",\n\t\t\t       __func__);\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tqid = pref_zq->queue->qid;\n\trc = pref_zq->ops->rng(pref_zq, buffer, &ap_msg);\n\n\tspin_lock(&zcrypt_list_lock);\n\tzcrypt_drop_queue(pref_zc, pref_zq, mod, wgt);\n\tspin_unlock(&zcrypt_list_lock);\n\nout:\n\tap_release_message(&ap_msg);\n\ttrace_s390_zcrypt_rep(buffer, func_code, rc,\n\t\t\t      AP_QID_CARD(qid), AP_QID_QUEUE(qid));\n\treturn rc;\n}\n\nstatic void zcrypt_device_status_mask(struct zcrypt_device_status *devstatus)\n{\n\tstruct zcrypt_card *zc;\n\tstruct zcrypt_queue *zq;\n\tstruct zcrypt_device_status *stat;\n\tint card, queue;\n\n\tmemset(devstatus, 0, MAX_ZDEV_ENTRIES\n\t       * sizeof(struct zcrypt_device_status));\n\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\tcard = AP_QID_CARD(zq->queue->qid);\n\t\t\tif (card >= MAX_ZDEV_CARDIDS)\n\t\t\t\tcontinue;\n\t\t\tqueue = AP_QID_QUEUE(zq->queue->qid);\n\t\t\tstat = &devstatus[card * AP_DOMAINS + queue];\n\t\t\tstat->hwtype = zc->card->ap_dev.device_type;\n\t\t\tstat->functions = zc->card->functions >> 26;\n\t\t\tstat->qid = zq->queue->qid;\n\t\t\tstat->online = zq->online ? 0x01 : 0x00;\n\t\t}\n\t}\n\tspin_unlock(&zcrypt_list_lock);\n}\n\nvoid zcrypt_device_status_mask_ext(struct zcrypt_device_status_ext *devstatus)\n{\n\tstruct zcrypt_card *zc;\n\tstruct zcrypt_queue *zq;\n\tstruct zcrypt_device_status_ext *stat;\n\tint card, queue;\n\n\tmemset(devstatus, 0, MAX_ZDEV_ENTRIES_EXT\n\t       * sizeof(struct zcrypt_device_status_ext));\n\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\tcard = AP_QID_CARD(zq->queue->qid);\n\t\t\tqueue = AP_QID_QUEUE(zq->queue->qid);\n\t\t\tstat = &devstatus[card * AP_DOMAINS + queue];\n\t\t\tstat->hwtype = zc->card->ap_dev.device_type;\n\t\t\tstat->functions = zc->card->functions >> 26;\n\t\t\tstat->qid = zq->queue->qid;\n\t\t\tstat->online = zq->online ? 0x01 : 0x00;\n\t\t}\n\t}\n\tspin_unlock(&zcrypt_list_lock);\n}\nEXPORT_SYMBOL(zcrypt_device_status_mask_ext);\n\nint zcrypt_device_status_ext(int card, int queue,\n\t\t\t     struct zcrypt_device_status_ext *devstat)\n{\n\tstruct zcrypt_card *zc;\n\tstruct zcrypt_queue *zq;\n\n\tmemset(devstat, 0, sizeof(*devstat));\n\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\tif (card == AP_QID_CARD(zq->queue->qid) &&\n\t\t\t    queue == AP_QID_QUEUE(zq->queue->qid)) {\n\t\t\t\tdevstat->hwtype = zc->card->ap_dev.device_type;\n\t\t\t\tdevstat->functions = zc->card->functions >> 26;\n\t\t\t\tdevstat->qid = zq->queue->qid;\n\t\t\t\tdevstat->online = zq->online ? 0x01 : 0x00;\n\t\t\t\tspin_unlock(&zcrypt_list_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&zcrypt_list_lock);\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(zcrypt_device_status_ext);\n\nstatic void zcrypt_status_mask(char status[], size_t max_adapters)\n{\n\tstruct zcrypt_card *zc;\n\tstruct zcrypt_queue *zq;\n\tint card;\n\n\tmemset(status, 0, max_adapters);\n\tspin_lock(&zcrypt_list_lock);\n\tfor_each_zcrypt_card(zc) {\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\tcard = AP_QID_CARD(zq->queue->qid);\n\t\t\tif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index ||\n\t\t\t    card >= max_adapters)\n\t\t\t\tcontinue;\n\t\t\tstatus[card] = zc->online ? zc->user_space_type : 0x0d;\n\t\t}\n\t}\n\tspin_unlock(&zcrypt_list_lock);\n}\n\nstatic void zcrypt_qdepth_mask(char qdepth[], size_t max_adapters)\n{\n\tstruct zcrypt_card *zc;\n\tstruct zcrypt_queue *zq;\n\tint card;\n\n\tmemset(qdepth, 0, max_adapters);\n\tspin_lock(&zcrypt_list_lock);\n\tlocal_bh_disable();\n\tfor_each_zcrypt_card(zc) {\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\tcard = AP_QID_CARD(zq->queue->qid);\n\t\t\tif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index ||\n\t\t\t    card >= max_adapters)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&zq->queue->lock);\n\t\t\tqdepth[card] =\n\t\t\t\tzq->queue->pendingq_count +\n\t\t\t\tzq->queue->requestq_count;\n\t\t\tspin_unlock(&zq->queue->lock);\n\t\t}\n\t}\n\tlocal_bh_enable();\n\tspin_unlock(&zcrypt_list_lock);\n}\n\nstatic void zcrypt_perdev_reqcnt(u32 reqcnt[], size_t max_adapters)\n{\n\tstruct zcrypt_card *zc;\n\tstruct zcrypt_queue *zq;\n\tint card;\n\tu64 cnt;\n\n\tmemset(reqcnt, 0, sizeof(int) * max_adapters);\n\tspin_lock(&zcrypt_list_lock);\n\tlocal_bh_disable();\n\tfor_each_zcrypt_card(zc) {\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\tcard = AP_QID_CARD(zq->queue->qid);\n\t\t\tif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index ||\n\t\t\t    card >= max_adapters)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&zq->queue->lock);\n\t\t\tcnt = zq->queue->total_request_count;\n\t\t\tspin_unlock(&zq->queue->lock);\n\t\t\treqcnt[card] = (cnt < UINT_MAX) ? (u32)cnt : UINT_MAX;\n\t\t}\n\t}\n\tlocal_bh_enable();\n\tspin_unlock(&zcrypt_list_lock);\n}\n\nstatic int zcrypt_pendingq_count(void)\n{\n\tstruct zcrypt_card *zc;\n\tstruct zcrypt_queue *zq;\n\tint pendingq_count;\n\n\tpendingq_count = 0;\n\tspin_lock(&zcrypt_list_lock);\n\tlocal_bh_disable();\n\tfor_each_zcrypt_card(zc) {\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\tif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&zq->queue->lock);\n\t\t\tpendingq_count += zq->queue->pendingq_count;\n\t\t\tspin_unlock(&zq->queue->lock);\n\t\t}\n\t}\n\tlocal_bh_enable();\n\tspin_unlock(&zcrypt_list_lock);\n\treturn pendingq_count;\n}\n\nstatic int zcrypt_requestq_count(void)\n{\n\tstruct zcrypt_card *zc;\n\tstruct zcrypt_queue *zq;\n\tint requestq_count;\n\n\trequestq_count = 0;\n\tspin_lock(&zcrypt_list_lock);\n\tlocal_bh_disable();\n\tfor_each_zcrypt_card(zc) {\n\t\tfor_each_zcrypt_queue(zq, zc) {\n\t\t\tif (AP_QID_QUEUE(zq->queue->qid) != ap_domain_index)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&zq->queue->lock);\n\t\t\trequestq_count += zq->queue->requestq_count;\n\t\t\tspin_unlock(&zq->queue->lock);\n\t\t}\n\t}\n\tlocal_bh_enable();\n\tspin_unlock(&zcrypt_list_lock);\n\treturn requestq_count;\n}\n\nstatic int icarsamodexpo_ioctl(struct ap_perms *perms, unsigned long arg)\n{\n\tint rc;\n\tstruct zcrypt_track tr;\n\tstruct ica_rsa_modexpo mex;\n\tstruct ica_rsa_modexpo __user *umex = (void __user *)arg;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tif (copy_from_user(&mex, umex, sizeof(mex)))\n\t\treturn -EFAULT;\n\n\tdo {\n\t\trc = zcrypt_rsa_modexpo(perms, &tr, &mex);\n\t\tif (rc == -EAGAIN)\n\t\t\ttr.again_counter++;\n\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\t \n\tif ((rc == -ENODEV) && (zcrypt_process_rescan()))\n\t\tdo {\n\t\t\trc = zcrypt_rsa_modexpo(perms, &tr, &mex);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\ttr.again_counter++;\n\t\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\tif (rc == -EAGAIN && tr.again_counter >= TRACK_AGAIN_MAX)\n\t\trc = -EIO;\n\tif (rc) {\n\t\tZCRYPT_DBF_DBG(\"ioctl ICARSAMODEXPO rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\treturn put_user(mex.outputdatalength, &umex->outputdatalength);\n}\n\nstatic int icarsacrt_ioctl(struct ap_perms *perms, unsigned long arg)\n{\n\tint rc;\n\tstruct zcrypt_track tr;\n\tstruct ica_rsa_modexpo_crt crt;\n\tstruct ica_rsa_modexpo_crt __user *ucrt = (void __user *)arg;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tif (copy_from_user(&crt, ucrt, sizeof(crt)))\n\t\treturn -EFAULT;\n\n\tdo {\n\t\trc = zcrypt_rsa_crt(perms, &tr, &crt);\n\t\tif (rc == -EAGAIN)\n\t\t\ttr.again_counter++;\n\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\t \n\tif ((rc == -ENODEV) && (zcrypt_process_rescan()))\n\t\tdo {\n\t\t\trc = zcrypt_rsa_crt(perms, &tr, &crt);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\ttr.again_counter++;\n\t\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\tif (rc == -EAGAIN && tr.again_counter >= TRACK_AGAIN_MAX)\n\t\trc = -EIO;\n\tif (rc) {\n\t\tZCRYPT_DBF_DBG(\"ioctl ICARSACRT rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\treturn put_user(crt.outputdatalength, &ucrt->outputdatalength);\n}\n\nstatic int zsecsendcprb_ioctl(struct ap_perms *perms, unsigned long arg)\n{\n\tint rc;\n\tstruct ica_xcRB xcrb;\n\tstruct zcrypt_track tr;\n\tstruct ica_xcRB __user *uxcrb = (void __user *)arg;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tif (copy_from_user(&xcrb, uxcrb, sizeof(xcrb)))\n\t\treturn -EFAULT;\n\n\tdo {\n\t\trc = _zcrypt_send_cprb(true, perms, &tr, &xcrb);\n\t\tif (rc == -EAGAIN)\n\t\t\ttr.again_counter++;\n\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\t \n\tif ((rc == -ENODEV) && (zcrypt_process_rescan()))\n\t\tdo {\n\t\t\trc = _zcrypt_send_cprb(true, perms, &tr, &xcrb);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\ttr.again_counter++;\n\t\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\tif (rc == -EAGAIN && tr.again_counter >= TRACK_AGAIN_MAX)\n\t\trc = -EIO;\n\tif (rc)\n\t\tZCRYPT_DBF_DBG(\"ioctl ZSENDCPRB rc=%d status=0x%x\\n\",\n\t\t\t       rc, xcrb.status);\n\tif (copy_to_user(uxcrb, &xcrb, sizeof(xcrb)))\n\t\treturn -EFAULT;\n\treturn rc;\n}\n\nstatic int zsendep11cprb_ioctl(struct ap_perms *perms, unsigned long arg)\n{\n\tint rc;\n\tstruct ep11_urb xcrb;\n\tstruct zcrypt_track tr;\n\tstruct ep11_urb __user *uxcrb = (void __user *)arg;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tif (copy_from_user(&xcrb, uxcrb, sizeof(xcrb)))\n\t\treturn -EFAULT;\n\n\tdo {\n\t\trc = _zcrypt_send_ep11_cprb(true, perms, &tr, &xcrb);\n\t\tif (rc == -EAGAIN)\n\t\t\ttr.again_counter++;\n\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\t \n\tif ((rc == -ENODEV) && (zcrypt_process_rescan()))\n\t\tdo {\n\t\t\trc = _zcrypt_send_ep11_cprb(true, perms, &tr, &xcrb);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\ttr.again_counter++;\n\t\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\tif (rc == -EAGAIN && tr.again_counter >= TRACK_AGAIN_MAX)\n\t\trc = -EIO;\n\tif (rc)\n\t\tZCRYPT_DBF_DBG(\"ioctl ZSENDEP11CPRB rc=%d\\n\", rc);\n\tif (copy_to_user(uxcrb, &xcrb, sizeof(xcrb)))\n\t\treturn -EFAULT;\n\treturn rc;\n}\n\nstatic long zcrypt_unlocked_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\tint rc;\n\tstruct ap_perms *perms =\n\t\t(struct ap_perms *)filp->private_data;\n\n\trc = zcrypt_check_ioctl(perms, cmd);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (cmd) {\n\tcase ICARSAMODEXPO:\n\t\treturn icarsamodexpo_ioctl(perms, arg);\n\tcase ICARSACRT:\n\t\treturn icarsacrt_ioctl(perms, arg);\n\tcase ZSECSENDCPRB:\n\t\treturn zsecsendcprb_ioctl(perms, arg);\n\tcase ZSENDEP11CPRB:\n\t\treturn zsendep11cprb_ioctl(perms, arg);\n\tcase ZCRYPT_DEVICE_STATUS: {\n\t\tstruct zcrypt_device_status_ext *device_status;\n\t\tsize_t total_size = MAX_ZDEV_ENTRIES_EXT\n\t\t\t* sizeof(struct zcrypt_device_status_ext);\n\n\t\tdevice_status = kvmalloc_array(MAX_ZDEV_ENTRIES_EXT,\n\t\t\t\t\t       sizeof(struct zcrypt_device_status_ext),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!device_status)\n\t\t\treturn -ENOMEM;\n\t\tzcrypt_device_status_mask_ext(device_status);\n\t\tif (copy_to_user((char __user *)arg, device_status,\n\t\t\t\t total_size))\n\t\t\trc = -EFAULT;\n\t\tkvfree(device_status);\n\t\treturn rc;\n\t}\n\tcase ZCRYPT_STATUS_MASK: {\n\t\tchar status[AP_DEVICES];\n\n\t\tzcrypt_status_mask(status, AP_DEVICES);\n\t\tif (copy_to_user((char __user *)arg, status, sizeof(status)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase ZCRYPT_QDEPTH_MASK: {\n\t\tchar qdepth[AP_DEVICES];\n\n\t\tzcrypt_qdepth_mask(qdepth, AP_DEVICES);\n\t\tif (copy_to_user((char __user *)arg, qdepth, sizeof(qdepth)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase ZCRYPT_PERDEV_REQCNT: {\n\t\tu32 *reqcnt;\n\n\t\treqcnt = kcalloc(AP_DEVICES, sizeof(u32), GFP_KERNEL);\n\t\tif (!reqcnt)\n\t\t\treturn -ENOMEM;\n\t\tzcrypt_perdev_reqcnt(reqcnt, AP_DEVICES);\n\t\tif (copy_to_user((int __user *)arg, reqcnt,\n\t\t\t\t sizeof(u32) * AP_DEVICES))\n\t\t\trc = -EFAULT;\n\t\tkfree(reqcnt);\n\t\treturn rc;\n\t}\n\tcase Z90STAT_REQUESTQ_COUNT:\n\t\treturn put_user(zcrypt_requestq_count(), (int __user *)arg);\n\tcase Z90STAT_PENDINGQ_COUNT:\n\t\treturn put_user(zcrypt_pendingq_count(), (int __user *)arg);\n\tcase Z90STAT_TOTALOPEN_COUNT:\n\t\treturn put_user(atomic_read(&zcrypt_open_count),\n\t\t\t\t(int __user *)arg);\n\tcase Z90STAT_DOMAIN_INDEX:\n\t\treturn put_user(ap_domain_index, (int __user *)arg);\n\t \n\tcase ZDEVICESTATUS: {\n\t\t \n\t\tstruct zcrypt_device_status *device_status;\n\t\tsize_t total_size = MAX_ZDEV_ENTRIES\n\t\t\t* sizeof(struct zcrypt_device_status);\n\n\t\tdevice_status = kzalloc(total_size, GFP_KERNEL);\n\t\tif (!device_status)\n\t\t\treturn -ENOMEM;\n\t\tzcrypt_device_status_mask(device_status);\n\t\tif (copy_to_user((char __user *)arg, device_status,\n\t\t\t\t total_size))\n\t\t\trc = -EFAULT;\n\t\tkfree(device_status);\n\t\treturn rc;\n\t}\n\tcase Z90STAT_STATUS_MASK: {\n\t\t \n\t\tchar status[MAX_ZDEV_CARDIDS];\n\n\t\tzcrypt_status_mask(status, MAX_ZDEV_CARDIDS);\n\t\tif (copy_to_user((char __user *)arg, status, sizeof(status)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase Z90STAT_QDEPTH_MASK: {\n\t\t \n\t\tchar qdepth[MAX_ZDEV_CARDIDS];\n\n\t\tzcrypt_qdepth_mask(qdepth, MAX_ZDEV_CARDIDS);\n\t\tif (copy_to_user((char __user *)arg, qdepth, sizeof(qdepth)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase Z90STAT_PERDEV_REQCNT: {\n\t\t \n\t\tu32 reqcnt[MAX_ZDEV_CARDIDS];\n\n\t\tzcrypt_perdev_reqcnt(reqcnt, MAX_ZDEV_CARDIDS);\n\t\tif (copy_to_user((int __user *)arg, reqcnt, sizeof(reqcnt)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\t \n\tdefault:\n\t\tZCRYPT_DBF_DBG(\"unknown ioctl 0x%08x\\n\", cmd);\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\n \nstruct compat_ica_rsa_modexpo {\n\tcompat_uptr_t\tinputdata;\n\tunsigned int\tinputdatalength;\n\tcompat_uptr_t\toutputdata;\n\tunsigned int\toutputdatalength;\n\tcompat_uptr_t\tb_key;\n\tcompat_uptr_t\tn_modulus;\n};\n\nstatic long trans_modexpo32(struct ap_perms *perms, struct file *filp,\n\t\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct compat_ica_rsa_modexpo __user *umex32 = compat_ptr(arg);\n\tstruct compat_ica_rsa_modexpo mex32;\n\tstruct ica_rsa_modexpo mex64;\n\tstruct zcrypt_track tr;\n\tlong rc;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tif (copy_from_user(&mex32, umex32, sizeof(mex32)))\n\t\treturn -EFAULT;\n\tmex64.inputdata = compat_ptr(mex32.inputdata);\n\tmex64.inputdatalength = mex32.inputdatalength;\n\tmex64.outputdata = compat_ptr(mex32.outputdata);\n\tmex64.outputdatalength = mex32.outputdatalength;\n\tmex64.b_key = compat_ptr(mex32.b_key);\n\tmex64.n_modulus = compat_ptr(mex32.n_modulus);\n\tdo {\n\t\trc = zcrypt_rsa_modexpo(perms, &tr, &mex64);\n\t\tif (rc == -EAGAIN)\n\t\t\ttr.again_counter++;\n\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\t \n\tif ((rc == -ENODEV) && (zcrypt_process_rescan()))\n\t\tdo {\n\t\t\trc = zcrypt_rsa_modexpo(perms, &tr, &mex64);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\ttr.again_counter++;\n\t\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\tif (rc == -EAGAIN && tr.again_counter >= TRACK_AGAIN_MAX)\n\t\trc = -EIO;\n\tif (rc)\n\t\treturn rc;\n\treturn put_user(mex64.outputdatalength,\n\t\t\t&umex32->outputdatalength);\n}\n\nstruct compat_ica_rsa_modexpo_crt {\n\tcompat_uptr_t\tinputdata;\n\tunsigned int\tinputdatalength;\n\tcompat_uptr_t\toutputdata;\n\tunsigned int\toutputdatalength;\n\tcompat_uptr_t\tbp_key;\n\tcompat_uptr_t\tbq_key;\n\tcompat_uptr_t\tnp_prime;\n\tcompat_uptr_t\tnq_prime;\n\tcompat_uptr_t\tu_mult_inv;\n};\n\nstatic long trans_modexpo_crt32(struct ap_perms *perms, struct file *filp,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct compat_ica_rsa_modexpo_crt __user *ucrt32 = compat_ptr(arg);\n\tstruct compat_ica_rsa_modexpo_crt crt32;\n\tstruct ica_rsa_modexpo_crt crt64;\n\tstruct zcrypt_track tr;\n\tlong rc;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tif (copy_from_user(&crt32, ucrt32, sizeof(crt32)))\n\t\treturn -EFAULT;\n\tcrt64.inputdata = compat_ptr(crt32.inputdata);\n\tcrt64.inputdatalength = crt32.inputdatalength;\n\tcrt64.outputdata = compat_ptr(crt32.outputdata);\n\tcrt64.outputdatalength = crt32.outputdatalength;\n\tcrt64.bp_key = compat_ptr(crt32.bp_key);\n\tcrt64.bq_key = compat_ptr(crt32.bq_key);\n\tcrt64.np_prime = compat_ptr(crt32.np_prime);\n\tcrt64.nq_prime = compat_ptr(crt32.nq_prime);\n\tcrt64.u_mult_inv = compat_ptr(crt32.u_mult_inv);\n\tdo {\n\t\trc = zcrypt_rsa_crt(perms, &tr, &crt64);\n\t\tif (rc == -EAGAIN)\n\t\t\ttr.again_counter++;\n\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\t \n\tif ((rc == -ENODEV) && (zcrypt_process_rescan()))\n\t\tdo {\n\t\t\trc = zcrypt_rsa_crt(perms, &tr, &crt64);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\ttr.again_counter++;\n\t\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\tif (rc == -EAGAIN && tr.again_counter >= TRACK_AGAIN_MAX)\n\t\trc = -EIO;\n\tif (rc)\n\t\treturn rc;\n\treturn put_user(crt64.outputdatalength,\n\t\t\t&ucrt32->outputdatalength);\n}\n\nstruct compat_ica_xcrb {\n\tunsigned short\tagent_ID;\n\tunsigned int\tuser_defined;\n\tunsigned short\trequest_ID;\n\tunsigned int\trequest_control_blk_length;\n\tunsigned char\tpadding1[16 - sizeof(compat_uptr_t)];\n\tcompat_uptr_t\trequest_control_blk_addr;\n\tunsigned int\trequest_data_length;\n\tchar\t\tpadding2[16 - sizeof(compat_uptr_t)];\n\tcompat_uptr_t\trequest_data_address;\n\tunsigned int\treply_control_blk_length;\n\tchar\t\tpadding3[16 - sizeof(compat_uptr_t)];\n\tcompat_uptr_t\treply_control_blk_addr;\n\tunsigned int\treply_data_length;\n\tchar\t\tpadding4[16 - sizeof(compat_uptr_t)];\n\tcompat_uptr_t\treply_data_addr;\n\tunsigned short\tpriority_window;\n\tunsigned int\tstatus;\n} __packed;\n\nstatic long trans_xcrb32(struct ap_perms *perms, struct file *filp,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct compat_ica_xcrb __user *uxcrb32 = compat_ptr(arg);\n\tstruct compat_ica_xcrb xcrb32;\n\tstruct zcrypt_track tr;\n\tstruct ica_xcRB xcrb64;\n\tlong rc;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tif (copy_from_user(&xcrb32, uxcrb32, sizeof(xcrb32)))\n\t\treturn -EFAULT;\n\txcrb64.agent_ID = xcrb32.agent_ID;\n\txcrb64.user_defined = xcrb32.user_defined;\n\txcrb64.request_ID = xcrb32.request_ID;\n\txcrb64.request_control_blk_length =\n\t\txcrb32.request_control_blk_length;\n\txcrb64.request_control_blk_addr =\n\t\tcompat_ptr(xcrb32.request_control_blk_addr);\n\txcrb64.request_data_length =\n\t\txcrb32.request_data_length;\n\txcrb64.request_data_address =\n\t\tcompat_ptr(xcrb32.request_data_address);\n\txcrb64.reply_control_blk_length =\n\t\txcrb32.reply_control_blk_length;\n\txcrb64.reply_control_blk_addr =\n\t\tcompat_ptr(xcrb32.reply_control_blk_addr);\n\txcrb64.reply_data_length = xcrb32.reply_data_length;\n\txcrb64.reply_data_addr =\n\t\tcompat_ptr(xcrb32.reply_data_addr);\n\txcrb64.priority_window = xcrb32.priority_window;\n\txcrb64.status = xcrb32.status;\n\tdo {\n\t\trc = _zcrypt_send_cprb(true, perms, &tr, &xcrb64);\n\t\tif (rc == -EAGAIN)\n\t\t\ttr.again_counter++;\n\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\t \n\tif ((rc == -ENODEV) && (zcrypt_process_rescan()))\n\t\tdo {\n\t\t\trc = _zcrypt_send_cprb(true, perms, &tr, &xcrb64);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\ttr.again_counter++;\n\t\t} while (rc == -EAGAIN && tr.again_counter < TRACK_AGAIN_MAX);\n\tif (rc == -EAGAIN && tr.again_counter >= TRACK_AGAIN_MAX)\n\t\trc = -EIO;\n\txcrb32.reply_control_blk_length = xcrb64.reply_control_blk_length;\n\txcrb32.reply_data_length = xcrb64.reply_data_length;\n\txcrb32.status = xcrb64.status;\n\tif (copy_to_user(uxcrb32, &xcrb32, sizeof(xcrb32)))\n\t\treturn -EFAULT;\n\treturn rc;\n}\n\nstatic long zcrypt_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tint rc;\n\tstruct ap_perms *perms =\n\t\t(struct ap_perms *)filp->private_data;\n\n\trc = zcrypt_check_ioctl(perms, cmd);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cmd == ICARSAMODEXPO)\n\t\treturn trans_modexpo32(perms, filp, cmd, arg);\n\tif (cmd == ICARSACRT)\n\t\treturn trans_modexpo_crt32(perms, filp, cmd, arg);\n\tif (cmd == ZSECSENDCPRB)\n\t\treturn trans_xcrb32(perms, filp, cmd, arg);\n\treturn zcrypt_unlocked_ioctl(filp, cmd, arg);\n}\n#endif\n\n \nstatic const struct file_operations zcrypt_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= zcrypt_read,\n\t.write\t\t= zcrypt_write,\n\t.unlocked_ioctl\t= zcrypt_unlocked_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= zcrypt_compat_ioctl,\n#endif\n\t.open\t\t= zcrypt_open,\n\t.release\t= zcrypt_release,\n\t.llseek\t\t= no_llseek,\n};\n\n \nstatic struct miscdevice zcrypt_misc_device = {\n\t.minor\t    = MISC_DYNAMIC_MINOR,\n\t.name\t    = \"z90crypt\",\n\t.fops\t    = &zcrypt_fops,\n};\n\nstatic int zcrypt_rng_device_count;\nstatic u32 *zcrypt_rng_buffer;\nstatic int zcrypt_rng_buffer_index;\nstatic DEFINE_MUTEX(zcrypt_rng_mutex);\n\nstatic int zcrypt_rng_data_read(struct hwrng *rng, u32 *data)\n{\n\tint rc;\n\n\t \n\tif (zcrypt_rng_buffer_index == 0) {\n\t\trc = zcrypt_rng((char *)zcrypt_rng_buffer);\n\t\t \n\t\tif ((rc == -ENODEV) && (zcrypt_process_rescan()))\n\t\t\trc = zcrypt_rng((char *)zcrypt_rng_buffer);\n\t\tif (rc < 0)\n\t\t\treturn -EIO;\n\t\tzcrypt_rng_buffer_index = rc / sizeof(*data);\n\t}\n\t*data = zcrypt_rng_buffer[--zcrypt_rng_buffer_index];\n\treturn sizeof(*data);\n}\n\nstatic struct hwrng zcrypt_rng_dev = {\n\t.name\t\t= \"zcrypt\",\n\t.data_read\t= zcrypt_rng_data_read,\n\t.quality\t= 990,\n};\n\nint zcrypt_rng_device_add(void)\n{\n\tint rc = 0;\n\n\tmutex_lock(&zcrypt_rng_mutex);\n\tif (zcrypt_rng_device_count == 0) {\n\t\tzcrypt_rng_buffer = (u32 *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!zcrypt_rng_buffer) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tzcrypt_rng_buffer_index = 0;\n\t\trc = hwrng_register(&zcrypt_rng_dev);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\t\tzcrypt_rng_device_count = 1;\n\t} else {\n\t\tzcrypt_rng_device_count++;\n\t}\n\tmutex_unlock(&zcrypt_rng_mutex);\n\treturn 0;\n\nout_free:\n\tfree_page((unsigned long)zcrypt_rng_buffer);\nout:\n\tmutex_unlock(&zcrypt_rng_mutex);\n\treturn rc;\n}\n\nvoid zcrypt_rng_device_remove(void)\n{\n\tmutex_lock(&zcrypt_rng_mutex);\n\tzcrypt_rng_device_count--;\n\tif (zcrypt_rng_device_count == 0) {\n\t\thwrng_unregister(&zcrypt_rng_dev);\n\t\tfree_page((unsigned long)zcrypt_rng_buffer);\n\t}\n\tmutex_unlock(&zcrypt_rng_mutex);\n}\n\n \nint zcrypt_wait_api_operational(void)\n{\n\tstatic DEFINE_MUTEX(zcrypt_wait_api_lock);\n\tstatic int zcrypt_wait_api_state;\n\tint rc;\n\n\trc = mutex_lock_interruptible(&zcrypt_wait_api_lock);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (zcrypt_wait_api_state) {\n\tcase 0:\n\t\t \n\t\trc = ap_wait_init_apqn_bindings_complete(\n\t\t\tmsecs_to_jiffies(60 * 1000));\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\t \n\t\t\tzcrypt_wait_api_state = 1;\n\t\t\tbreak;\n\t\tcase -EINTR:\n\t\t\t \n\t\t\tbreak;\n\t\tcase -ETIME:\n\t\t\t \n\t\t\tZCRYPT_DBF_WARN(\"%s ap_wait_init_apqn_bindings_complete()=ETIME\\n\",\n\t\t\t\t\t__func__);\n\t\t\tzcrypt_wait_api_state = -ETIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tZCRYPT_DBF_DBG(\"%s ap_wait_init_apqn_bindings_complete()=%d\\n\",\n\t\t\t\t       __func__, rc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\trc = 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\trc = zcrypt_wait_api_state;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&zcrypt_wait_api_lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(zcrypt_wait_api_operational);\n\nint __init zcrypt_debug_init(void)\n{\n\tzcrypt_dbf_info = debug_register(\"zcrypt\", 2, 1,\n\t\t\t\t\t DBF_MAX_SPRINTF_ARGS * sizeof(long));\n\tdebug_register_view(zcrypt_dbf_info, &debug_sprintf_view);\n\tdebug_set_level(zcrypt_dbf_info, DBF_ERR);\n\n\treturn 0;\n}\n\nvoid zcrypt_debug_exit(void)\n{\n\tdebug_unregister(zcrypt_dbf_info);\n}\n\nstatic int __init zcdn_init(void)\n{\n\tint rc;\n\n\t \n\tzcrypt_class = class_create(ZCRYPT_NAME);\n\tif (IS_ERR(zcrypt_class)) {\n\t\trc = PTR_ERR(zcrypt_class);\n\t\tgoto out_class_create_failed;\n\t}\n\tzcrypt_class->dev_release = zcdn_device_release;\n\n\t \n\trc = alloc_chrdev_region(&zcrypt_devt,\n\t\t\t\t 0, ZCRYPT_MAX_MINOR_NODES,\n\t\t\t\t ZCRYPT_NAME);\n\tif (rc)\n\t\tgoto out_alloc_chrdev_failed;\n\n\tcdev_init(&zcrypt_cdev, &zcrypt_fops);\n\tzcrypt_cdev.owner = THIS_MODULE;\n\trc = cdev_add(&zcrypt_cdev, zcrypt_devt, ZCRYPT_MAX_MINOR_NODES);\n\tif (rc)\n\t\tgoto out_cdev_add_failed;\n\n\t \n\trc = class_create_file(zcrypt_class, &class_attr_zcdn_create);\n\tif (rc)\n\t\tgoto out_class_create_file_1_failed;\n\trc = class_create_file(zcrypt_class, &class_attr_zcdn_destroy);\n\tif (rc)\n\t\tgoto out_class_create_file_2_failed;\n\n\treturn 0;\n\nout_class_create_file_2_failed:\n\tclass_remove_file(zcrypt_class, &class_attr_zcdn_create);\nout_class_create_file_1_failed:\n\tcdev_del(&zcrypt_cdev);\nout_cdev_add_failed:\n\tunregister_chrdev_region(zcrypt_devt, ZCRYPT_MAX_MINOR_NODES);\nout_alloc_chrdev_failed:\n\tclass_destroy(zcrypt_class);\nout_class_create_failed:\n\treturn rc;\n}\n\nstatic void zcdn_exit(void)\n{\n\tclass_remove_file(zcrypt_class, &class_attr_zcdn_create);\n\tclass_remove_file(zcrypt_class, &class_attr_zcdn_destroy);\n\tzcdn_destroy_all();\n\tcdev_del(&zcrypt_cdev);\n\tunregister_chrdev_region(zcrypt_devt, ZCRYPT_MAX_MINOR_NODES);\n\tclass_destroy(zcrypt_class);\n}\n\n \nint __init zcrypt_api_init(void)\n{\n\tint rc;\n\n\trc = zcrypt_debug_init();\n\tif (rc)\n\t\tgoto out;\n\n\trc = zcdn_init();\n\tif (rc)\n\t\tgoto out;\n\n\t \n\trc = misc_register(&zcrypt_misc_device);\n\tif (rc < 0)\n\t\tgoto out_misc_register_failed;\n\n\tzcrypt_msgtype6_init();\n\tzcrypt_msgtype50_init();\n\n\treturn 0;\n\nout_misc_register_failed:\n\tzcdn_exit();\n\tzcrypt_debug_exit();\nout:\n\treturn rc;\n}\n\n \nvoid __exit zcrypt_api_exit(void)\n{\n\tzcdn_exit();\n\tmisc_deregister(&zcrypt_misc_device);\n\tzcrypt_msgtype6_exit();\n\tzcrypt_msgtype50_exit();\n\tzcrypt_ccamisc_exit();\n\tzcrypt_ep11misc_exit();\n\tzcrypt_debug_exit();\n}\n\nmodule_init(zcrypt_api_init);\nmodule_exit(zcrypt_api_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}