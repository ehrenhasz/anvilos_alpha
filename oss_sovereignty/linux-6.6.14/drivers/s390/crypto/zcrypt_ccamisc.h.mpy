{
  "module_name": "zcrypt_ccamisc.h",
  "hash_id": "db5c1d060de572b70eb9263061f31bc195411362d7fccaeba040afad6e022e6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/zcrypt_ccamisc.h",
  "human_readable_source": " \n \n\n#ifndef _ZCRYPT_CCAMISC_H_\n#define _ZCRYPT_CCAMISC_H_\n\n#include <asm/zcrypt.h>\n#include <asm/pkey.h>\n\n \n#define TOKTYPE_NON_CCA\t\t 0x00  \n#define TOKTYPE_CCA_INTERNAL\t 0x01  \n#define TOKTYPE_CCA_INTERNAL_PKA 0x1f  \n\n \n#define TOKVER_PROTECTED_KEY\t0x01  \n#define TOKVER_CLEAR_KEY\t0x02  \n\n \n#define TOKVER_CCA_AES\t\t0x04  \n#define TOKVER_CCA_VLSC\t\t0x05  \n\n \n#define MAXCCAVLSCTOKENSIZE 725\n\n \nstruct keytoken_header {\n\tu8  type;      \n\tu8  res0[1];\n\tu16 len;       \n\tu8  version;   \n\tu8  res1[3];\n} __packed;\n\n \nstruct secaeskeytoken {\n\tu8  type;      \n\tu8  res0[3];\n\tu8  version;   \n\tu8  res1[1];\n\tu8  flag;      \n\tu8  res2[1];\n\tu64 mkvp;      \n\tu8  key[32];   \n\tu8  cv[8];     \n\tu16 bitsize;   \n\tu16 keysize;   \n\tu8  tvv[4];    \n} __packed;\n\n \nstruct cipherkeytoken {\n\tu8  type;      \n\tu8  res0[1];\n\tu16 len;       \n\tu8  version;   \n\tu8  res1[3];\n\tu8  kms;       \n\tu8  kvpt;      \n\tu64 mkvp0;     \n\tu64 mkvp1;     \n\tu8  eskwm;     \n\tu8  hashalg;   \n\tu8  plfver;    \n\tu8  res2[1];\n\tu8  adsver;    \n\tu8  res3[1];\n\tu16 adslen;    \n\tu8  kllen;     \n\tu8  ieaslen;   \n\tu8  uadlen;    \n\tu8  res4[1];\n\tu16 wpllen;    \n\t\t       \n\t\t       \n\t\t       \n\t\t       \n\tu8  res5[1];\n\tu8  algtype;   \n\tu16 keytype;   \n\tu8  kufc;      \n\tu16 kuf1;      \n\tu16 kuf2;      \n\tu8  kmfc;      \n\tu16 kmf1;      \n\tu16 kmf2;      \n\tu16 kmf3;      \n\tu8  vdata[];  \n} __packed;\n\n \nstruct eccprivkeytoken {\n\tu8  type;      \n\tu8  version;   \n\tu16 len;       \n\tu8  res1[4];\n\tu8  secid;     \n\tu8  secver;    \n\tu16 seclen;    \n\tu8  wtype;     \n\tu8  htype;     \n\tu8  res2[2];\n\tu8  kutc;      \n\tu8  ctype;     \n\tu8  kfs;       \n\tu8  ksrc;      \n\tu16 pbitlen;   \n\tu16 ibmadlen;  \n\tu64 mkvp;      \n\tu8  opk[48];   \n\tu16 adatalen;  \n\tu16 fseclen;   \n\tu8  more_data[];  \n} __packed;\n\n \n#define KMF1_XPRT_SYM  0x8000\n#define KMF1_XPRT_UASY 0x4000\n#define KMF1_XPRT_AASY 0x2000\n#define KMF1_XPRT_RAW  0x1000\n#define KMF1_XPRT_CPAC 0x0800\n#define KMF1_XPRT_DES  0x0080\n#define KMF1_XPRT_AES  0x0040\n#define KMF1_XPRT_RSA  0x0008\n\n \nint cca_check_secaeskeytoken(debug_info_t *dbg, int dbflvl,\n\t\t\t     const u8 *token, int keybitsize);\n\n \nint cca_check_secaescipherkey(debug_info_t *dbg, int dbflvl,\n\t\t\t      const u8 *token, int keybitsize,\n\t\t\t      int checkcpacfexport);\n\n \nint cca_check_sececckeytoken(debug_info_t *dbg, int dbflvl,\n\t\t\t     const u8 *token, size_t keysize,\n\t\t\t     int checkcpacfexport);\n\n \nint cca_genseckey(u16 cardnr, u16 domain, u32 keybitsize, u8 *seckey);\n\n \nint cca_clr2seckey(u16 cardnr, u16 domain, u32 keybitsize,\n\t\t   const u8 *clrkey, u8 *seckey);\n\n \nint cca_sec2protkey(u16 cardnr, u16 domain,\n\t\t    const u8 *seckey, u8 *protkey, u32 *protkeylen,\n\t\t    u32 *protkeytype);\n\n \nint cca_gencipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,\n\t\t     u8 *keybuf, size_t *keybufsize);\n\n \nint cca_cipher2protkey(u16 cardnr, u16 domain, const u8 *ckey,\n\t\t       u8 *protkey, u32 *protkeylen, u32 *protkeytype);\n\n \nint cca_clr2cipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,\n\t\t      const u8 *clrkey, u8 *keybuf, size_t *keybufsize);\n\n \nint cca_ecc2protkey(u16 cardnr, u16 domain, const u8 *key,\n\t\t    u8 *protkey, u32 *protkeylen, u32 *protkeytype);\n\n \nint cca_query_crypto_facility(u16 cardnr, u16 domain,\n\t\t\t      const char *keyword,\n\t\t\t      u8 *rarray, size_t *rarraylen,\n\t\t\t      u8 *varray, size_t *varraylen);\n\n \nint cca_findcard(const u8 *key, u16 *pcardnr, u16 *pdomain, int verify);\n\n \nint cca_findcard2(u32 **apqns, u32 *nr_apqns, u16 cardnr, u16 domain,\n\t\t  int minhwtype, int mktype, u64 cur_mkvp, u64 old_mkvp,\n\t\t  int verify);\n\n#define AES_MK_SET  0\n#define APKA_MK_SET 1\n\n \nstruct cca_info {\n\tint  hwtype;\t\t \n\tchar new_aes_mk_state;\t \n\tchar cur_aes_mk_state;\t \n\tchar old_aes_mk_state;\t \n\tchar new_apka_mk_state;  \n\tchar cur_apka_mk_state;  \n\tchar old_apka_mk_state;  \n\tchar new_asym_mk_state;\t \n\tchar cur_asym_mk_state;\t \n\tchar old_asym_mk_state;\t \n\tu64  new_aes_mkvp;\t \n\tu64  cur_aes_mkvp;\t \n\tu64  old_aes_mkvp;\t \n\tu64  new_apka_mkvp;\t \n\tu64  cur_apka_mkvp;\t \n\tu64  old_apka_mkvp;\t \n\tu8   new_asym_mkvp[16];\t \n\tu8   cur_asym_mkvp[16];\t \n\tu8   old_asym_mkvp[16];\t \n\tchar serial[9];\t\t \n};\n\n \nint cca_get_info(u16 card, u16 dom, struct cca_info *ci, int verify);\n\nvoid zcrypt_ccamisc_exit(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}