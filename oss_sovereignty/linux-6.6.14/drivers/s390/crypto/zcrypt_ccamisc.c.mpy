{
  "module_name": "zcrypt_ccamisc.c",
  "hash_id": "4f735f5577f81362aee125ad1f7103126fe4ffa4a99f84e7b54a9d7bd47a5976",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/zcrypt_ccamisc.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zcrypt\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <asm/zcrypt.h>\n#include <asm/pkey.h>\n\n#include \"ap_bus.h\"\n#include \"zcrypt_api.h\"\n#include \"zcrypt_debug.h\"\n#include \"zcrypt_msgtype6.h\"\n#include \"zcrypt_ccamisc.h\"\n\n#define DEBUG_DBG(...)\tZCRYPT_DBF(DBF_DEBUG, ##__VA_ARGS__)\n#define DEBUG_INFO(...) ZCRYPT_DBF(DBF_INFO, ##__VA_ARGS__)\n#define DEBUG_WARN(...) ZCRYPT_DBF(DBF_WARN, ##__VA_ARGS__)\n#define DEBUG_ERR(...)\tZCRYPT_DBF(DBF_ERR, ##__VA_ARGS__)\n\n \n#define PARMBSIZE 512\n\n \n#define VARDATASIZE 4096\n\nstruct cca_info_list_entry {\n\tstruct list_head list;\n\tu16 cardnr;\n\tu16 domain;\n\tstruct cca_info info;\n};\n\n \nstatic LIST_HEAD(cca_info_list);\nstatic DEFINE_SPINLOCK(cca_info_list_lock);\n\n \nint cca_check_secaeskeytoken(debug_info_t *dbg, int dbflvl,\n\t\t\t     const u8 *token, int keybitsize)\n{\n\tstruct secaeskeytoken *t = (struct secaeskeytoken *)token;\n\n#define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)\n\n\tif (t->type != TOKTYPE_CCA_INTERNAL) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, type 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)t->type, TOKTYPE_CCA_INTERNAL);\n\t\treturn -EINVAL;\n\t}\n\tif (t->version != TOKVER_CCA_AES) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, version 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)t->version, TOKVER_CCA_AES);\n\t\treturn -EINVAL;\n\t}\n\tif (keybitsize > 0 && t->bitsize != keybitsize) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, bitsize %d != %d\\n\",\n\t\t\t    __func__, (int)t->bitsize, keybitsize);\n\t\treturn -EINVAL;\n\t}\n\n#undef DBF\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cca_check_secaeskeytoken);\n\n \nint cca_check_secaescipherkey(debug_info_t *dbg, int dbflvl,\n\t\t\t      const u8 *token, int keybitsize,\n\t\t\t      int checkcpacfexport)\n{\n\tstruct cipherkeytoken *t = (struct cipherkeytoken *)token;\n\tbool keybitsizeok = true;\n\n#define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)\n\n\tif (t->type != TOKTYPE_CCA_INTERNAL) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, type 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)t->type, TOKTYPE_CCA_INTERNAL);\n\t\treturn -EINVAL;\n\t}\n\tif (t->version != TOKVER_CCA_VLSC) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, version 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)t->version, TOKVER_CCA_VLSC);\n\t\treturn -EINVAL;\n\t}\n\tif (t->algtype != 0x02) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, algtype 0x%02x != 0x02\\n\",\n\t\t\t    __func__, (int)t->algtype);\n\t\treturn -EINVAL;\n\t}\n\tif (t->keytype != 0x0001) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, keytype 0x%04x != 0x0001\\n\",\n\t\t\t    __func__, (int)t->keytype);\n\t\treturn -EINVAL;\n\t}\n\tif (t->plfver != 0x00 && t->plfver != 0x01) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, unknown plfver 0x%02x\\n\",\n\t\t\t    __func__, (int)t->plfver);\n\t\treturn -EINVAL;\n\t}\n\tif (t->wpllen != 512 && t->wpllen != 576 && t->wpllen != 640) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, unknown wpllen %d\\n\",\n\t\t\t    __func__, (int)t->wpllen);\n\t\treturn -EINVAL;\n\t}\n\tif (keybitsize > 0) {\n\t\tswitch (keybitsize) {\n\t\tcase 128:\n\t\t\tif (t->wpllen != (t->plfver ? 640 : 512))\n\t\t\t\tkeybitsizeok = false;\n\t\t\tbreak;\n\t\tcase 192:\n\t\t\tif (t->wpllen != (t->plfver ? 640 : 576))\n\t\t\t\tkeybitsizeok = false;\n\t\t\tbreak;\n\t\tcase 256:\n\t\t\tif (t->wpllen != 640)\n\t\t\t\tkeybitsizeok = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkeybitsizeok = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (!keybitsizeok) {\n\t\t\tif (dbg)\n\t\t\t\tDBF(\"%s token check failed, bitsize %d\\n\",\n\t\t\t\t    __func__, keybitsize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (checkcpacfexport && !(t->kmf1 & KMF1_XPRT_CPAC)) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, XPRT_CPAC bit is 0\\n\",\n\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n#undef DBF\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cca_check_secaescipherkey);\n\n \nint cca_check_sececckeytoken(debug_info_t *dbg, int dbflvl,\n\t\t\t     const u8 *token, size_t keysize,\n\t\t\t     int checkcpacfexport)\n{\n\tstruct eccprivkeytoken *t = (struct eccprivkeytoken *)token;\n\n#define DBF(...) debug_sprintf_event(dbg, dbflvl, ##__VA_ARGS__)\n\n\tif (t->type != TOKTYPE_CCA_INTERNAL_PKA) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, type 0x%02x != 0x%02x\\n\",\n\t\t\t    __func__, (int)t->type, TOKTYPE_CCA_INTERNAL_PKA);\n\t\treturn -EINVAL;\n\t}\n\tif (t->len > keysize) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, len %d > keysize %zu\\n\",\n\t\t\t    __func__, (int)t->len, keysize);\n\t\treturn -EINVAL;\n\t}\n\tif (t->secid != 0x20) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, secid 0x%02x != 0x20\\n\",\n\t\t\t    __func__, (int)t->secid);\n\t\treturn -EINVAL;\n\t}\n\tif (checkcpacfexport && !(t->kutc & 0x01)) {\n\t\tif (dbg)\n\t\t\tDBF(\"%s token check failed, XPRTCPAC bit is 0\\n\",\n\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n#undef DBF\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cca_check_sececckeytoken);\n\n \nstatic int alloc_and_prep_cprbmem(size_t paramblen,\n\t\t\t\t  u8 **p_cprb_mem,\n\t\t\t\t  struct CPRBX **p_req_cprb,\n\t\t\t\t  struct CPRBX **p_rep_cprb)\n{\n\tu8 *cprbmem;\n\tsize_t cprbplusparamblen = sizeof(struct CPRBX) + paramblen;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\n\t \n\tcprbmem = kcalloc(2, cprbplusparamblen, GFP_KERNEL);\n\tif (!cprbmem)\n\t\treturn -ENOMEM;\n\n\tpreqcblk = (struct CPRBX *)cprbmem;\n\tprepcblk = (struct CPRBX *)(cprbmem + cprbplusparamblen);\n\n\t \n\tpreqcblk->cprb_len = sizeof(struct CPRBX);\n\tpreqcblk->cprb_ver_id = 0x02;\n\tmemcpy(preqcblk->func_id, \"T2\", 2);\n\tpreqcblk->rpl_msgbl = cprbplusparamblen;\n\tif (paramblen) {\n\t\tpreqcblk->req_parmb =\n\t\t\t((u8 __user *)preqcblk) + sizeof(struct CPRBX);\n\t\tpreqcblk->rpl_parmb =\n\t\t\t((u8 __user *)prepcblk) + sizeof(struct CPRBX);\n\t}\n\n\t*p_cprb_mem = cprbmem;\n\t*p_req_cprb = preqcblk;\n\t*p_rep_cprb = prepcblk;\n\n\treturn 0;\n}\n\n \nstatic void free_cprbmem(void *mem, size_t paramblen, int scrub)\n{\n\tif (scrub)\n\t\tmemzero_explicit(mem, 2 * (sizeof(struct CPRBX) + paramblen));\n\tkfree(mem);\n}\n\n \nstatic inline void prep_xcrb(struct ica_xcRB *pxcrb,\n\t\t\t     u16 cardnr,\n\t\t\t     struct CPRBX *preqcblk,\n\t\t\t     struct CPRBX *prepcblk)\n{\n\tmemset(pxcrb, 0, sizeof(*pxcrb));\n\tpxcrb->agent_ID = 0x4341;  \n\tpxcrb->user_defined = (cardnr == 0xFFFF ? AUTOSELECT : cardnr);\n\tpxcrb->request_control_blk_length =\n\t\tpreqcblk->cprb_len + preqcblk->req_parml;\n\tpxcrb->request_control_blk_addr = (void __user *)preqcblk;\n\tpxcrb->reply_control_blk_length = preqcblk->rpl_msgbl;\n\tpxcrb->reply_control_blk_addr = (void __user *)prepcblk;\n}\n\n \nint cca_genseckey(u16 cardnr, u16 domain,\n\t\t  u32 keybitsize, u8 *seckey)\n{\n\tint i, rc, keysize;\n\tint seckeysize;\n\tu8 *mem, *ptr;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\tstruct ica_xcRB xcrb;\n\tstruct kgreqparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct lv1 {\n\t\t\tu16 len;\n\t\t\tchar  key_form[8];\n\t\t\tchar  key_length[8];\n\t\t\tchar  key_type1[8];\n\t\t\tchar  key_type2[8];\n\t\t} lv1;\n\t\tstruct lv2 {\n\t\t\tu16 len;\n\t\t\tstruct keyid {\n\t\t\t\tu16 len;\n\t\t\t\tu16 attr;\n\t\t\t\tu8  data[SECKEYBLOBSIZE];\n\t\t\t} keyid[6];\n\t\t} lv2;\n\t} __packed * preqparm;\n\tstruct kgrepparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct lv3 {\n\t\t\tu16 len;\n\t\t\tu16 keyblocklen;\n\t\t\tstruct {\n\t\t\t\tu16 toklen;\n\t\t\t\tu16 tokattr;\n\t\t\t\tu8  tok[];\n\t\t\t\t \n\t\t\t} keyblock;\n\t\t} lv3;\n\t} __packed * prepparm;\n\n\t \n\trc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpreqcblk->domain = domain;\n\n\t \n\tpreqparm = (struct kgreqparm __force *)preqcblk->req_parmb;\n\tmemcpy(preqparm->subfunc_code, \"KG\", 2);\n\tpreqparm->rule_array_len = sizeof(preqparm->rule_array_len);\n\tpreqparm->lv1.len = sizeof(struct lv1);\n\tmemcpy(preqparm->lv1.key_form,\t \"OP      \", 8);\n\tswitch (keybitsize) {\n\tcase PKEY_SIZE_AES_128:\n\tcase PKEY_KEYTYPE_AES_128:  \n\t\tkeysize = 16;\n\t\tmemcpy(preqparm->lv1.key_length, \"KEYLN16 \", 8);\n\t\tbreak;\n\tcase PKEY_SIZE_AES_192:\n\tcase PKEY_KEYTYPE_AES_192:  \n\t\tkeysize = 24;\n\t\tmemcpy(preqparm->lv1.key_length, \"KEYLN24 \", 8);\n\t\tbreak;\n\tcase PKEY_SIZE_AES_256:\n\tcase PKEY_KEYTYPE_AES_256:  \n\t\tkeysize = 32;\n\t\tmemcpy(preqparm->lv1.key_length, \"KEYLN32 \", 8);\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported keybitsize %d\\n\",\n\t\t\t  __func__, keybitsize);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy(preqparm->lv1.key_type1,  \"AESDATA \", 8);\n\tpreqparm->lv2.len = sizeof(struct lv2);\n\tfor (i = 0; i < 6; i++) {\n\t\tpreqparm->lv2.keyid[i].len = sizeof(struct keyid);\n\t\tpreqparm->lv2.keyid[i].attr = (i == 2 ? 0x30 : 0x10);\n\t}\n\tpreqcblk->req_parml = sizeof(struct kgreqparm);\n\n\t \n\tprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\n\n\t \n\trc = zcrypt_send_cprb(&xcrb);\n\tif (rc) {\n\t\tDEBUG_ERR(\"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, errno %d\\n\",\n\t\t\t  __func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepcblk->ccp_rtcode != 0) {\n\t\tDEBUG_ERR(\"%s secure key generate failure, card response %d/%d\\n\",\n\t\t\t  __func__,\n\t\t\t  (int)prepcblk->ccp_rtcode,\n\t\t\t  (int)prepcblk->ccp_rscode);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tptr =  ((u8 *)prepcblk) + sizeof(struct CPRBX);\n\tprepcblk->rpl_parmb = (u8 __user *)ptr;\n\tprepparm = (struct kgrepparm *)ptr;\n\n\t \n\tseckeysize = prepparm->lv3.keyblock.toklen\n\t\t- sizeof(prepparm->lv3.keyblock.toklen)\n\t\t- sizeof(prepparm->lv3.keyblock.tokattr);\n\tif (seckeysize != SECKEYBLOBSIZE) {\n\t\tDEBUG_ERR(\"%s secure token size mismatch %d != %d bytes\\n\",\n\t\t\t  __func__, seckeysize, SECKEYBLOBSIZE);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\trc = cca_check_secaeskeytoken(zcrypt_dbf_info, DBF_ERR,\n\t\t\t\t      prepparm->lv3.keyblock.tok, 8 * keysize);\n\tif (rc) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(seckey, prepparm->lv3.keyblock.tok, SECKEYBLOBSIZE);\n\nout:\n\tfree_cprbmem(mem, PARMBSIZE, 0);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_genseckey);\n\n \nint cca_clr2seckey(u16 cardnr, u16 domain, u32 keybitsize,\n\t\t   const u8 *clrkey, u8 *seckey)\n{\n\tint rc, keysize, seckeysize;\n\tu8 *mem, *ptr;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\tstruct ica_xcRB xcrb;\n\tstruct cmreqparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tchar  rule_array[8];\n\t\tstruct lv1 {\n\t\t\tu16 len;\n\t\t\tu8  clrkey[];\n\t\t} lv1;\n\t\t \n\t} __packed * preqparm;\n\tstruct lv2 {\n\t\tu16 len;\n\t\tstruct keyid {\n\t\t\tu16 len;\n\t\t\tu16 attr;\n\t\t\tu8  data[SECKEYBLOBSIZE];\n\t\t} keyid;\n\t} __packed * plv2;\n\tstruct cmrepparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct lv3 {\n\t\t\tu16 len;\n\t\t\tu16 keyblocklen;\n\t\t\tstruct {\n\t\t\t\tu16 toklen;\n\t\t\t\tu16 tokattr;\n\t\t\t\tu8  tok[];\n\t\t\t\t \n\t\t\t} keyblock;\n\t\t} lv3;\n\t} __packed * prepparm;\n\n\t \n\trc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpreqcblk->domain = domain;\n\n\t \n\tpreqparm = (struct cmreqparm __force *)preqcblk->req_parmb;\n\tmemcpy(preqparm->subfunc_code, \"CM\", 2);\n\tmemcpy(preqparm->rule_array, \"AES     \", 8);\n\tpreqparm->rule_array_len =\n\t\tsizeof(preqparm->rule_array_len) + sizeof(preqparm->rule_array);\n\tswitch (keybitsize) {\n\tcase PKEY_SIZE_AES_128:\n\tcase PKEY_KEYTYPE_AES_128:  \n\t\tkeysize = 16;\n\t\tbreak;\n\tcase PKEY_SIZE_AES_192:\n\tcase PKEY_KEYTYPE_AES_192:  \n\t\tkeysize = 24;\n\t\tbreak;\n\tcase PKEY_SIZE_AES_256:\n\tcase PKEY_KEYTYPE_AES_256:  \n\t\tkeysize = 32;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported keybitsize %d\\n\",\n\t\t\t  __func__, keybitsize);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tpreqparm->lv1.len = sizeof(struct lv1) + keysize;\n\tmemcpy(preqparm->lv1.clrkey, clrkey, keysize);\n\tplv2 = (struct lv2 *)(((u8 *)preqparm) + sizeof(*preqparm) + keysize);\n\tplv2->len = sizeof(struct lv2);\n\tplv2->keyid.len = sizeof(struct keyid);\n\tplv2->keyid.attr = 0x30;\n\tpreqcblk->req_parml = sizeof(*preqparm) + keysize + sizeof(*plv2);\n\n\t \n\tprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\n\n\t \n\trc = zcrypt_send_cprb(&xcrb);\n\tif (rc) {\n\t\tDEBUG_ERR(\"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\\n\",\n\t\t\t  __func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepcblk->ccp_rtcode != 0) {\n\t\tDEBUG_ERR(\"%s clear key import failure, card response %d/%d\\n\",\n\t\t\t  __func__,\n\t\t\t  (int)prepcblk->ccp_rtcode,\n\t\t\t  (int)prepcblk->ccp_rscode);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tptr = ((u8 *)prepcblk) + sizeof(struct CPRBX);\n\tprepcblk->rpl_parmb = (u8 __user *)ptr;\n\tprepparm = (struct cmrepparm *)ptr;\n\n\t \n\tseckeysize = prepparm->lv3.keyblock.toklen\n\t\t- sizeof(prepparm->lv3.keyblock.toklen)\n\t\t- sizeof(prepparm->lv3.keyblock.tokattr);\n\tif (seckeysize != SECKEYBLOBSIZE) {\n\t\tDEBUG_ERR(\"%s secure token size mismatch %d != %d bytes\\n\",\n\t\t\t  __func__, seckeysize, SECKEYBLOBSIZE);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\trc = cca_check_secaeskeytoken(zcrypt_dbf_info, DBF_ERR,\n\t\t\t\t      prepparm->lv3.keyblock.tok, 8 * keysize);\n\tif (rc) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tif (seckey)\n\t\tmemcpy(seckey, prepparm->lv3.keyblock.tok, SECKEYBLOBSIZE);\n\nout:\n\tfree_cprbmem(mem, PARMBSIZE, 1);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_clr2seckey);\n\n \nint cca_sec2protkey(u16 cardnr, u16 domain,\n\t\t    const u8 *seckey, u8 *protkey, u32 *protkeylen,\n\t\t    u32 *protkeytype)\n{\n\tint rc;\n\tu8 *mem, *ptr;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\tstruct ica_xcRB xcrb;\n\tstruct uskreqparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct lv1 {\n\t\t\tu16 len;\n\t\t\tu16 attr_len;\n\t\t\tu16 attr_flags;\n\t\t} lv1;\n\t\tstruct lv2 {\n\t\t\tu16 len;\n\t\t\tu16 attr_len;\n\t\t\tu16 attr_flags;\n\t\t\tu8  token[];\t       \n\t\t} lv2;\n\t} __packed * preqparm;\n\tstruct uskrepparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct lv3 {\n\t\t\tu16 len;\n\t\t\tu16 attr_len;\n\t\t\tu16 attr_flags;\n\t\t\tstruct cpacfkeyblock {\n\t\t\t\tu8  version;   \n\t\t\t\tu8  flags[2];\n\t\t\t\tu8  algo;\n\t\t\t\tu8  form;\n\t\t\t\tu8  pad1[3];\n\t\t\t\tu16 len;\n\t\t\t\tu8  key[64];   \n\t\t\t\tu16 keyattrlen;\n\t\t\t\tu8  keyattr[32];\n\t\t\t\tu8  pad2[1];\n\t\t\t\tu8  vptype;\n\t\t\t\tu8  vp[32];   \n\t\t\t} ckb;\n\t\t} lv3;\n\t} __packed * prepparm;\n\n\t \n\trc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpreqcblk->domain = domain;\n\n\t \n\tpreqparm = (struct uskreqparm __force *)preqcblk->req_parmb;\n\tmemcpy(preqparm->subfunc_code, \"US\", 2);\n\tpreqparm->rule_array_len = sizeof(preqparm->rule_array_len);\n\tpreqparm->lv1.len = sizeof(struct lv1);\n\tpreqparm->lv1.attr_len = sizeof(struct lv1) - sizeof(preqparm->lv1.len);\n\tpreqparm->lv1.attr_flags = 0x0001;\n\tpreqparm->lv2.len = sizeof(struct lv2) + SECKEYBLOBSIZE;\n\tpreqparm->lv2.attr_len = sizeof(struct lv2)\n\t\t- sizeof(preqparm->lv2.len) + SECKEYBLOBSIZE;\n\tpreqparm->lv2.attr_flags = 0x0000;\n\tmemcpy(preqparm->lv2.token, seckey, SECKEYBLOBSIZE);\n\tpreqcblk->req_parml = sizeof(struct uskreqparm) + SECKEYBLOBSIZE;\n\n\t \n\tprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\n\n\t \n\trc = zcrypt_send_cprb(&xcrb);\n\tif (rc) {\n\t\tDEBUG_ERR(\"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\\n\",\n\t\t\t  __func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepcblk->ccp_rtcode != 0) {\n\t\tDEBUG_ERR(\"%s unwrap secure key failure, card response %d/%d\\n\",\n\t\t\t  __func__,\n\t\t\t  (int)prepcblk->ccp_rtcode,\n\t\t\t  (int)prepcblk->ccp_rscode);\n\t\tif (prepcblk->ccp_rtcode == 8 && prepcblk->ccp_rscode == 2290)\n\t\t\trc = -EAGAIN;\n\t\telse\n\t\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (prepcblk->ccp_rscode != 0) {\n\t\tDEBUG_WARN(\"%s unwrap secure key warning, card response %d/%d\\n\",\n\t\t\t   __func__,\n\t\t\t   (int)prepcblk->ccp_rtcode,\n\t\t\t   (int)prepcblk->ccp_rscode);\n\t}\n\n\t \n\tptr = ((u8 *)prepcblk) + sizeof(struct CPRBX);\n\tprepcblk->rpl_parmb = (u8 __user *)ptr;\n\tprepparm = (struct uskrepparm *)ptr;\n\n\t \n\tif (prepparm->lv3.ckb.version != 0x01 &&\n\t    prepparm->lv3.ckb.version != 0x02) {\n\t\tDEBUG_ERR(\"%s reply param keyblock version mismatch 0x%02x\\n\",\n\t\t\t  __func__, (int)prepparm->lv3.ckb.version);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (prepparm->lv3.ckb.len) {\n\tcase 16 + 32:\n\t\t \n\t\tif (protkeytype)\n\t\t\t*protkeytype = PKEY_KEYTYPE_AES_128;\n\t\tbreak;\n\tcase 24 + 32:\n\t\t \n\t\tif (protkeytype)\n\t\t\t*protkeytype = PKEY_KEYTYPE_AES_192;\n\t\tbreak;\n\tcase 32 + 32:\n\t\t \n\t\tif (protkeytype)\n\t\t\t*protkeytype = PKEY_KEYTYPE_AES_256;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported keylen %d\\n\",\n\t\t\t  __func__, prepparm->lv3.ckb.len);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(protkey, prepparm->lv3.ckb.key, prepparm->lv3.ckb.len);\n\tif (protkeylen)\n\t\t*protkeylen = prepparm->lv3.ckb.len;\n\nout:\n\tfree_cprbmem(mem, PARMBSIZE, 0);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_sec2protkey);\n\n \nstatic const u8 aes_cipher_key_skeleton[] = {\n\t0x01, 0x00, 0x00, 0x38, 0x05, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,\n\t0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x02, 0x00, 0x01, 0x02, 0xc0, 0x00, 0xff,\n\t0x00, 0x03, 0x08, 0xc8, 0x00, 0x00, 0x00, 0x00 };\n#define SIZEOF_SKELETON (sizeof(aes_cipher_key_skeleton))\n\n \nint cca_gencipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,\n\t\t     u8 *keybuf, size_t *keybufsize)\n{\n\tint rc;\n\tu8 *mem, *ptr;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\tstruct ica_xcRB xcrb;\n\tstruct gkreqparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tchar rule_array[2 * 8];\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu8  key_type_1[8];\n\t\t\tu8  key_type_2[8];\n\t\t\tu16 clear_key_bit_len;\n\t\t\tu16 key_name_1_len;\n\t\t\tu16 key_name_2_len;\n\t\t\tu16 user_data_1_len;\n\t\t\tu16 user_data_2_len;\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t} vud;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tstruct {\n\t\t\t\tu16 len;\n\t\t\t\tu16 flag;\n\t\t\t\t \n\t\t\t} tlv1;\n\t\t\tstruct {\n\t\t\t\tu16 len;\n\t\t\t\tu16 flag;\n\t\t\t\t \n\t\t\t} tlv2;\n\t\t\tstruct {\n\t\t\t\tu16 len;\n\t\t\t\tu16 flag;\n\t\t\t\tu8  gen_key_id_1[SIZEOF_SKELETON];\n\t\t\t} tlv3;\n\t\t\tstruct {\n\t\t\t\tu16 len;\n\t\t\t\tu16 flag;\n\t\t\t\t \n\t\t\t} tlv4;\n\t\t\tstruct {\n\t\t\t\tu16 len;\n\t\t\t\tu16 flag;\n\t\t\t\t \n\t\t\t} tlv5;\n\t\t\tstruct {\n\t\t\t\tu16 len;\n\t\t\t\tu16 flag;\n\t\t\t\t \n\t\t\t} tlv6;\n\t\t} kb;\n\t} __packed * preqparm;\n\tstruct gkrepparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t} vud;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tstruct {\n\t\t\t\tu16 len;\n\t\t\t\tu16 flag;\n\t\t\t\tu8  gen_key[];  \n\t\t\t} tlv1;\n\t\t} kb;\n\t} __packed * prepparm;\n\tstruct cipherkeytoken *t;\n\n\t \n\trc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpreqcblk->domain = domain;\n\tpreqcblk->req_parml = sizeof(struct gkreqparm);\n\n\t \n\tpreqparm = (struct gkreqparm __force *)preqcblk->req_parmb;\n\tmemcpy(preqparm->subfunc_code, \"GK\", 2);\n\tpreqparm->rule_array_len =  sizeof(uint16_t) + 2 * 8;\n\tmemcpy(preqparm->rule_array, \"AES     OP      \", 2 * 8);\n\n\t \n\tpreqparm->vud.len = sizeof(preqparm->vud);\n\tswitch (keybitsize) {\n\tcase 128:\n\tcase 192:\n\tcase 256:\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\n\t\t\t\"%s unknown/unsupported keybitsize %d\\n\",\n\t\t\t__func__, keybitsize);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tpreqparm->vud.clear_key_bit_len = keybitsize;\n\tmemcpy(preqparm->vud.key_type_1, \"TOKEN   \", 8);\n\tmemset(preqparm->vud.key_type_2, ' ', sizeof(preqparm->vud.key_type_2));\n\n\t \n\tpreqparm->kb.len = sizeof(preqparm->kb);\n\tpreqparm->kb.tlv1.len = sizeof(preqparm->kb.tlv1);\n\tpreqparm->kb.tlv1.flag = 0x0030;\n\tpreqparm->kb.tlv2.len = sizeof(preqparm->kb.tlv2);\n\tpreqparm->kb.tlv2.flag = 0x0030;\n\tpreqparm->kb.tlv3.len = sizeof(preqparm->kb.tlv3);\n\tpreqparm->kb.tlv3.flag = 0x0030;\n\tmemcpy(preqparm->kb.tlv3.gen_key_id_1,\n\t       aes_cipher_key_skeleton, SIZEOF_SKELETON);\n\tpreqparm->kb.tlv4.len = sizeof(preqparm->kb.tlv4);\n\tpreqparm->kb.tlv4.flag = 0x0030;\n\tpreqparm->kb.tlv5.len = sizeof(preqparm->kb.tlv5);\n\tpreqparm->kb.tlv5.flag = 0x0030;\n\tpreqparm->kb.tlv6.len = sizeof(preqparm->kb.tlv6);\n\tpreqparm->kb.tlv6.flag = 0x0030;\n\n\t \n\tif (keygenflags) {\n\t\tt = (struct cipherkeytoken *)preqparm->kb.tlv3.gen_key_id_1;\n\t\tt->kmf1 |= (u16)(keygenflags & 0x0000FF00);\n\t\tt->kmf1 &= (u16)~(keygenflags & 0x000000FF);\n\t}\n\n\t \n\tprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\n\n\t \n\trc = zcrypt_send_cprb(&xcrb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepcblk->ccp_rtcode != 0) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s cipher key generate failure, card response %d/%d\\n\",\n\t\t\t__func__,\n\t\t\t(int)prepcblk->ccp_rtcode,\n\t\t\t(int)prepcblk->ccp_rscode);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tptr = ((u8 *)prepcblk) + sizeof(struct CPRBX);\n\tprepcblk->rpl_parmb = (u8 __user *)ptr;\n\tprepparm = (struct gkrepparm *)ptr;\n\n\t \n\tif (prepparm->kb.len < 120 + 5 * sizeof(uint16_t) ||\n\t    prepparm->kb.len > 136 + 5 * sizeof(uint16_t)) {\n\t\tDEBUG_ERR(\"%s reply with invalid or unknown key block\\n\",\n\t\t\t  __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\trc = cca_check_secaescipherkey(zcrypt_dbf_info, DBF_ERR,\n\t\t\t\t       prepparm->kb.tlv1.gen_key,\n\t\t\t\t       keybitsize, 1);\n\tif (rc) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tt = (struct cipherkeytoken *)prepparm->kb.tlv1.gen_key;\n\tif (keybuf) {\n\t\tif (*keybufsize >= t->len)\n\t\t\tmemcpy(keybuf, t, t->len);\n\t\telse\n\t\t\trc = -EINVAL;\n\t}\n\t*keybufsize = t->len;\n\nout:\n\tfree_cprbmem(mem, PARMBSIZE, 0);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_gencipherkey);\n\n \nstatic int _ip_cprb_helper(u16 cardnr, u16 domain,\n\t\t\t   const char *rule_array_1,\n\t\t\t   const char *rule_array_2,\n\t\t\t   const char *rule_array_3,\n\t\t\t   const u8 *clr_key_value,\n\t\t\t   int clr_key_bit_size,\n\t\t\t   u8 *key_token,\n\t\t\t   int *key_token_size)\n{\n\tint rc, n;\n\tu8 *mem, *ptr;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\tstruct ica_xcRB xcrb;\n\tstruct rule_array_block {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tchar rule_array[];\n\t} __packed * preq_ra_block;\n\tstruct vud_block {\n\t\tu16 len;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 flag;\t      \n\t\t\tu16 clr_key_bit_len;\n\t\t} tlv1;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 flag;\t \n\t\t\tu8  clr_key[];\t \n\t\t} tlv2;\n\t} __packed * preq_vud_block;\n\tstruct key_block {\n\t\tu16 len;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 flag;\t   \n\t\t\tu8  key_token[];   \n\t\t} tlv1;\n\t} __packed * preq_key_block;\n\tstruct iprepparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t} vud;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tstruct {\n\t\t\t\tu16 len;\n\t\t\t\tu16 flag;\t   \n\t\t\t\tu8  key_token[];   \n\t\t\t} tlv1;\n\t\t} kb;\n\t} __packed * prepparm;\n\tstruct cipherkeytoken *t;\n\tint complete = strncmp(rule_array_2, \"COMPLETE\", 8) ? 0 : 1;\n\n\t \n\trc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpreqcblk->domain = domain;\n\tpreqcblk->req_parml = 0;\n\n\t \n\tpreq_ra_block = (struct rule_array_block __force *)preqcblk->req_parmb;\n\tmemcpy(preq_ra_block->subfunc_code, \"IP\", 2);\n\tpreq_ra_block->rule_array_len =  sizeof(uint16_t) + 2 * 8;\n\tmemcpy(preq_ra_block->rule_array, rule_array_1, 8);\n\tmemcpy(preq_ra_block->rule_array + 8, rule_array_2, 8);\n\tpreqcblk->req_parml = sizeof(struct rule_array_block) + 2 * 8;\n\tif (rule_array_3) {\n\t\tpreq_ra_block->rule_array_len += 8;\n\t\tmemcpy(preq_ra_block->rule_array + 16, rule_array_3, 8);\n\t\tpreqcblk->req_parml += 8;\n\t}\n\n\t \n\tpreq_vud_block = (struct vud_block __force *)\n\t\t(preqcblk->req_parmb + preqcblk->req_parml);\n\tn = complete ? 0 : (clr_key_bit_size + 7) / 8;\n\tpreq_vud_block->len = sizeof(struct vud_block) + n;\n\tpreq_vud_block->tlv1.len = sizeof(preq_vud_block->tlv1);\n\tpreq_vud_block->tlv1.flag = 0x0064;\n\tpreq_vud_block->tlv1.clr_key_bit_len = complete ? 0 : clr_key_bit_size;\n\tpreq_vud_block->tlv2.len = sizeof(preq_vud_block->tlv2) + n;\n\tpreq_vud_block->tlv2.flag = 0x0063;\n\tif (!complete)\n\t\tmemcpy(preq_vud_block->tlv2.clr_key, clr_key_value, n);\n\tpreqcblk->req_parml += preq_vud_block->len;\n\n\t \n\tpreq_key_block = (struct key_block __force *)\n\t\t(preqcblk->req_parmb + preqcblk->req_parml);\n\tn = *key_token_size;\n\tpreq_key_block->len = sizeof(struct key_block) + n;\n\tpreq_key_block->tlv1.len = sizeof(preq_key_block->tlv1) + n;\n\tpreq_key_block->tlv1.flag = 0x0030;\n\tmemcpy(preq_key_block->tlv1.key_token, key_token, *key_token_size);\n\tpreqcblk->req_parml += preq_key_block->len;\n\n\t \n\tprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\n\n\t \n\trc = zcrypt_send_cprb(&xcrb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepcblk->ccp_rtcode != 0) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s CSNBKPI2 failure, card response %d/%d\\n\",\n\t\t\t__func__,\n\t\t\t(int)prepcblk->ccp_rtcode,\n\t\t\t(int)prepcblk->ccp_rscode);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tptr = ((u8 *)prepcblk) + sizeof(struct CPRBX);\n\tprepcblk->rpl_parmb = (u8 __user *)ptr;\n\tprepparm = (struct iprepparm *)ptr;\n\n\t \n\tif (prepparm->kb.len < 120 + 3 * sizeof(uint16_t) ||\n\t    prepparm->kb.len > 136 + 3 * sizeof(uint16_t)) {\n\t\tDEBUG_ERR(\"%s reply with invalid or unknown key block\\n\",\n\t\t\t  __func__);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\n\t \n\tt = (struct cipherkeytoken *)prepparm->kb.tlv1.key_token;\n\tmemcpy(key_token, t, t->len);\n\t*key_token_size = t->len;\n\nout:\n\tfree_cprbmem(mem, PARMBSIZE, 0);\n\treturn rc;\n}\n\n \nint cca_clr2cipherkey(u16 card, u16 dom, u32 keybitsize, u32 keygenflags,\n\t\t      const u8 *clrkey, u8 *keybuf, size_t *keybufsize)\n{\n\tint rc;\n\tu8 *token;\n\tint tokensize;\n\tu8 exorbuf[32];\n\tstruct cipherkeytoken *t;\n\n\t \n\tget_random_bytes(exorbuf, sizeof(exorbuf));\n\n\t \n\ttoken = kmalloc(MAXCCAVLSCTOKENSIZE, GFP_KERNEL);\n\tif (!token)\n\t\treturn -ENOMEM;\n\n\t \n\ttokensize = SIZEOF_SKELETON;\n\tmemcpy(token, aes_cipher_key_skeleton, tokensize);\n\n\t \n\tif (keygenflags) {\n\t\tt = (struct cipherkeytoken *)token;\n\t\tt->kmf1 |= (u16)(keygenflags & 0x0000FF00);\n\t\tt->kmf1 &= (u16)~(keygenflags & 0x000000FF);\n\t}\n\n\t \n\trc = _ip_cprb_helper(card, dom, \"AES     \", \"FIRST   \", \"MIN3PART\",\n\t\t\t     exorbuf, keybitsize, token, &tokensize);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s clear key import 1/4 with CSNBKPI2 failed, rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\trc = _ip_cprb_helper(card, dom, \"AES     \", \"ADD-PART\", NULL,\n\t\t\t     clrkey, keybitsize, token, &tokensize);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s clear key import 2/4 with CSNBKPI2 failed, rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\trc = _ip_cprb_helper(card, dom, \"AES     \", \"ADD-PART\", NULL,\n\t\t\t     exorbuf, keybitsize, token, &tokensize);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s clear key import 3/4 with CSNBKPI2 failed, rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\trc = _ip_cprb_helper(card, dom, \"AES     \", \"COMPLETE\", NULL,\n\t\t\t     NULL, keybitsize, token, &tokensize);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s clear key import 4/4 with CSNBKPI2 failed, rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (keybuf) {\n\t\tif (tokensize > *keybufsize)\n\t\t\trc = -EINVAL;\n\t\telse\n\t\t\tmemcpy(keybuf, token, tokensize);\n\t}\n\t*keybufsize = tokensize;\n\nout:\n\tkfree(token);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_clr2cipherkey);\n\n \nint cca_cipher2protkey(u16 cardnr, u16 domain, const u8 *ckey,\n\t\t       u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tint rc;\n\tu8 *mem, *ptr;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\tstruct ica_xcRB xcrb;\n\tstruct aureqparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tu8  rule_array[8];\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 tk_blob_len;\n\t\t\tu16 tk_blob_tag;\n\t\t\tu8  tk_blob[66];\n\t\t} vud;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 cca_key_token_len;\n\t\t\tu16 cca_key_token_flags;\n\t\t\tu8  cca_key_token[];  \n\t\t} kb;\n\t} __packed * preqparm;\n\tstruct aurepparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 sublen;\n\t\t\tu16 tag;\n\t\t\tstruct cpacfkeyblock {\n\t\t\t\tu8  version;   \n\t\t\t\tu8  flags[2];\n\t\t\t\tu8  algo;\n\t\t\t\tu8  form;\n\t\t\t\tu8  pad1[3];\n\t\t\t\tu16 keylen;\n\t\t\t\tu8  key[64];   \n\t\t\t\tu16 keyattrlen;\n\t\t\t\tu8  keyattr[32];\n\t\t\t\tu8  pad2[1];\n\t\t\t\tu8  vptype;\n\t\t\t\tu8  vp[32];   \n\t\t\t} ckb;\n\t\t} vud;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t} kb;\n\t} __packed * prepparm;\n\tint keytoklen = ((struct cipherkeytoken *)ckey)->len;\n\n\t \n\trc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpreqcblk->domain = domain;\n\n\t \n\tpreqparm = (struct aureqparm __force *)preqcblk->req_parmb;\n\tmemcpy(preqparm->subfunc_code, \"AU\", 2);\n\tpreqparm->rule_array_len =\n\t\tsizeof(preqparm->rule_array_len)\n\t\t+ sizeof(preqparm->rule_array);\n\tmemcpy(preqparm->rule_array, \"EXPT-SK \", 8);\n\t \n\tpreqparm->vud.len = sizeof(preqparm->vud);\n\tpreqparm->vud.tk_blob_len = sizeof(preqparm->vud.tk_blob)\n\t\t+ 2 * sizeof(uint16_t);\n\tpreqparm->vud.tk_blob_tag = 0x00C2;\n\t \n\tpreqparm->kb.len = keytoklen + 3 * sizeof(uint16_t);\n\tpreqparm->kb.cca_key_token_len = keytoklen + 2 * sizeof(uint16_t);\n\tmemcpy(preqparm->kb.cca_key_token, ckey, keytoklen);\n\t \n\tpreqcblk->req_parml = sizeof(struct aureqparm) + keytoklen;\n\n\t \n\tprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\n\n\t \n\trc = zcrypt_send_cprb(&xcrb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepcblk->ccp_rtcode != 0) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s unwrap secure key failure, card response %d/%d\\n\",\n\t\t\t__func__,\n\t\t\t(int)prepcblk->ccp_rtcode,\n\t\t\t(int)prepcblk->ccp_rscode);\n\t\tif (prepcblk->ccp_rtcode == 8 && prepcblk->ccp_rscode == 2290)\n\t\t\trc = -EAGAIN;\n\t\telse\n\t\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (prepcblk->ccp_rscode != 0) {\n\t\tDEBUG_WARN(\n\t\t\t\"%s unwrap secure key warning, card response %d/%d\\n\",\n\t\t\t__func__,\n\t\t\t(int)prepcblk->ccp_rtcode,\n\t\t\t(int)prepcblk->ccp_rscode);\n\t}\n\n\t \n\tptr = ((u8 *)prepcblk) + sizeof(struct CPRBX);\n\tprepcblk->rpl_parmb = (u8 __user *)ptr;\n\tprepparm = (struct aurepparm *)ptr;\n\n\t \n\tif (prepparm->vud.ckb.version != 0x01 &&\n\t    prepparm->vud.ckb.version != 0x02) {\n\t\tDEBUG_ERR(\"%s reply param keyblock version mismatch 0x%02x\\n\",\n\t\t\t  __func__, (int)prepparm->vud.ckb.version);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (prepparm->vud.ckb.algo != 0x02) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s reply param keyblock algo mismatch 0x%02x != 0x02\\n\",\n\t\t\t__func__, (int)prepparm->vud.ckb.algo);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (prepparm->vud.ckb.keylen) {\n\tcase 16 + 32:\n\t\t \n\t\tif (protkeytype)\n\t\t\t*protkeytype = PKEY_KEYTYPE_AES_128;\n\t\tbreak;\n\tcase 24 + 32:\n\t\t \n\t\tif (protkeytype)\n\t\t\t*protkeytype = PKEY_KEYTYPE_AES_192;\n\t\tbreak;\n\tcase 32 + 32:\n\t\t \n\t\tif (protkeytype)\n\t\t\t*protkeytype = PKEY_KEYTYPE_AES_256;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported keylen %d\\n\",\n\t\t\t  __func__, prepparm->vud.ckb.keylen);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(protkey, prepparm->vud.ckb.key, prepparm->vud.ckb.keylen);\n\tif (protkeylen)\n\t\t*protkeylen = prepparm->vud.ckb.keylen;\n\nout:\n\tfree_cprbmem(mem, PARMBSIZE, 0);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_cipher2protkey);\n\n \nint cca_ecc2protkey(u16 cardnr, u16 domain, const u8 *key,\n\t\t    u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tint rc;\n\tu8 *mem, *ptr;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\tstruct ica_xcRB xcrb;\n\tstruct aureqparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tu8  rule_array[8];\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 tk_blob_len;\n\t\t\tu16 tk_blob_tag;\n\t\t\tu8  tk_blob[66];\n\t\t} vud;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 cca_key_token_len;\n\t\t\tu16 cca_key_token_flags;\n\t\t\tu8  cca_key_token[];\n\t\t} kb;\n\t} __packed * preqparm;\n\tstruct aurepparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tstruct {\n\t\t\tu16 len;\n\t\t\tu16 sublen;\n\t\t\tu16 tag;\n\t\t\tstruct cpacfkeyblock {\n\t\t\t\tu8  version;   \n\t\t\t\tu8  flags[2];\n\t\t\t\tu8  algo;\n\t\t\t\tu8  form;\n\t\t\t\tu8  pad1[3];\n\t\t\t\tu16 keylen;\n\t\t\t\tu8  key[];   \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t} ckb;\n\t\t} vud;\n\t\t \n\t} __packed * prepparm;\n\tint keylen = ((struct eccprivkeytoken *)key)->len;\n\n\t \n\trc = alloc_and_prep_cprbmem(PARMBSIZE, &mem, &preqcblk, &prepcblk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpreqcblk->domain = domain;\n\n\t \n\tpreqparm = (struct aureqparm __force *)preqcblk->req_parmb;\n\tmemcpy(preqparm->subfunc_code, \"AU\", 2);\n\tpreqparm->rule_array_len =\n\t\tsizeof(preqparm->rule_array_len)\n\t\t+ sizeof(preqparm->rule_array);\n\tmemcpy(preqparm->rule_array, \"EXPT-SK \", 8);\n\t \n\tpreqparm->vud.len = sizeof(preqparm->vud);\n\tpreqparm->vud.tk_blob_len = sizeof(preqparm->vud.tk_blob)\n\t\t+ 2 * sizeof(uint16_t);\n\tpreqparm->vud.tk_blob_tag = 0x00C2;\n\t \n\tpreqparm->kb.len = keylen + 3 * sizeof(uint16_t);\n\tpreqparm->kb.cca_key_token_len = keylen + 2 * sizeof(uint16_t);\n\tmemcpy(preqparm->kb.cca_key_token, key, keylen);\n\t \n\tpreqcblk->req_parml = sizeof(struct aureqparm) + keylen;\n\n\t \n\tprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\n\n\t \n\trc = zcrypt_send_cprb(&xcrb);\n\tif (rc) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\\n\",\n\t\t\t__func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepcblk->ccp_rtcode != 0) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s unwrap secure key failure, card response %d/%d\\n\",\n\t\t\t__func__,\n\t\t\t(int)prepcblk->ccp_rtcode,\n\t\t\t(int)prepcblk->ccp_rscode);\n\t\tif (prepcblk->ccp_rtcode == 8 && prepcblk->ccp_rscode == 2290)\n\t\t\trc = -EAGAIN;\n\t\telse\n\t\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (prepcblk->ccp_rscode != 0) {\n\t\tDEBUG_WARN(\n\t\t\t\"%s unwrap secure key warning, card response %d/%d\\n\",\n\t\t\t__func__,\n\t\t\t(int)prepcblk->ccp_rtcode,\n\t\t\t(int)prepcblk->ccp_rscode);\n\t}\n\n\t \n\tptr = ((u8 *)prepcblk) + sizeof(struct CPRBX);\n\tprepcblk->rpl_parmb = (u8 __user *)ptr;\n\tprepparm = (struct aurepparm *)ptr;\n\n\t \n\tif (prepparm->vud.ckb.version != 0x02) {\n\t\tDEBUG_ERR(\"%s reply param keyblock version mismatch 0x%02x != 0x02\\n\",\n\t\t\t  __func__, (int)prepparm->vud.ckb.version);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (prepparm->vud.ckb.algo != 0x81) {\n\t\tDEBUG_ERR(\n\t\t\t\"%s reply param keyblock algo mismatch 0x%02x != 0x81\\n\",\n\t\t\t__func__, (int)prepparm->vud.ckb.algo);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepparm->vud.ckb.keylen > *protkeylen) {\n\t\tDEBUG_ERR(\"%s prot keylen mismatch %d > buffersize %u\\n\",\n\t\t\t  __func__, prepparm->vud.ckb.keylen, *protkeylen);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(protkey, prepparm->vud.ckb.key, prepparm->vud.ckb.keylen);\n\t*protkeylen = prepparm->vud.ckb.keylen;\n\tif (protkeytype)\n\t\t*protkeytype = PKEY_KEYTYPE_ECC;\n\nout:\n\tfree_cprbmem(mem, PARMBSIZE, 0);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_ecc2protkey);\n\n \nint cca_query_crypto_facility(u16 cardnr, u16 domain,\n\t\t\t      const char *keyword,\n\t\t\t      u8 *rarray, size_t *rarraylen,\n\t\t\t      u8 *varray, size_t *varraylen)\n{\n\tint rc;\n\tu16 len;\n\tu8 *mem, *ptr;\n\tstruct CPRBX *preqcblk, *prepcblk;\n\tstruct ica_xcRB xcrb;\n\tstruct fqreqparm {\n\t\tu8  subfunc_code[2];\n\t\tu16 rule_array_len;\n\t\tchar  rule_array[8];\n\t\tstruct lv1 {\n\t\t\tu16 len;\n\t\t\tu8  data[VARDATASIZE];\n\t\t} lv1;\n\t\tu16 dummylen;\n\t} __packed * preqparm;\n\tsize_t parmbsize = sizeof(struct fqreqparm);\n\tstruct fqrepparm {\n\t\tu8  subfunc_code[2];\n\t\tu8  lvdata[];\n\t} __packed * prepparm;\n\n\t \n\trc = alloc_and_prep_cprbmem(parmbsize, &mem, &preqcblk, &prepcblk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tpreqcblk->domain = domain;\n\n\t \n\tpreqparm = (struct fqreqparm __force *)preqcblk->req_parmb;\n\tmemcpy(preqparm->subfunc_code, \"FQ\", 2);\n\tmemcpy(preqparm->rule_array, keyword, sizeof(preqparm->rule_array));\n\tpreqparm->rule_array_len =\n\t\tsizeof(preqparm->rule_array_len) + sizeof(preqparm->rule_array);\n\tpreqparm->lv1.len = sizeof(preqparm->lv1);\n\tpreqparm->dummylen = sizeof(preqparm->dummylen);\n\tpreqcblk->req_parml = parmbsize;\n\n\t \n\tprep_xcrb(&xcrb, cardnr, preqcblk, prepcblk);\n\n\t \n\trc = zcrypt_send_cprb(&xcrb);\n\tif (rc) {\n\t\tDEBUG_ERR(\"%s zcrypt_send_cprb (cardnr=%d domain=%d) failed, rc=%d\\n\",\n\t\t\t  __func__, (int)cardnr, (int)domain, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (prepcblk->ccp_rtcode != 0) {\n\t\tDEBUG_ERR(\"%s unwrap secure key failure, card response %d/%d\\n\",\n\t\t\t  __func__,\n\t\t\t  (int)prepcblk->ccp_rtcode,\n\t\t\t  (int)prepcblk->ccp_rscode);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tptr = ((u8 *)prepcblk) + sizeof(struct CPRBX);\n\tprepcblk->rpl_parmb = (u8 __user *)ptr;\n\tprepparm = (struct fqrepparm *)ptr;\n\tptr = prepparm->lvdata;\n\n\t \n\tlen = *((u16 *)ptr);\n\tif (len > sizeof(u16)) {\n\t\tptr += sizeof(u16);\n\t\tlen -= sizeof(u16);\n\t\tif (rarray && rarraylen && *rarraylen > 0) {\n\t\t\t*rarraylen = (len > *rarraylen ? *rarraylen : len);\n\t\t\tmemcpy(rarray, ptr, *rarraylen);\n\t\t}\n\t\tptr += len;\n\t}\n\t \n\tlen = *((u16 *)ptr);\n\tif (len > sizeof(u16)) {\n\t\tptr += sizeof(u16);\n\t\tlen -= sizeof(u16);\n\t\tif (varray && varraylen && *varraylen > 0) {\n\t\t\t*varraylen = (len > *varraylen ? *varraylen : len);\n\t\t\tmemcpy(varray, ptr, *varraylen);\n\t\t}\n\t\tptr += len;\n\t}\n\nout:\n\tfree_cprbmem(mem, parmbsize, 0);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_query_crypto_facility);\n\nstatic int cca_info_cache_fetch(u16 cardnr, u16 domain, struct cca_info *ci)\n{\n\tint rc = -ENOENT;\n\tstruct cca_info_list_entry *ptr;\n\n\tspin_lock_bh(&cca_info_list_lock);\n\tlist_for_each_entry(ptr, &cca_info_list, list) {\n\t\tif (ptr->cardnr == cardnr && ptr->domain == domain) {\n\t\t\tmemcpy(ci, &ptr->info, sizeof(*ci));\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&cca_info_list_lock);\n\n\treturn rc;\n}\n\nstatic void cca_info_cache_update(u16 cardnr, u16 domain,\n\t\t\t\t  const struct cca_info *ci)\n{\n\tint found = 0;\n\tstruct cca_info_list_entry *ptr;\n\n\tspin_lock_bh(&cca_info_list_lock);\n\tlist_for_each_entry(ptr, &cca_info_list, list) {\n\t\tif (ptr->cardnr == cardnr &&\n\t\t    ptr->domain == domain) {\n\t\t\tmemcpy(&ptr->info, ci, sizeof(*ci));\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tptr = kmalloc(sizeof(*ptr), GFP_ATOMIC);\n\t\tif (!ptr) {\n\t\t\tspin_unlock_bh(&cca_info_list_lock);\n\t\t\treturn;\n\t\t}\n\t\tptr->cardnr = cardnr;\n\t\tptr->domain = domain;\n\t\tmemcpy(&ptr->info, ci, sizeof(*ci));\n\t\tlist_add(&ptr->list, &cca_info_list);\n\t}\n\tspin_unlock_bh(&cca_info_list_lock);\n}\n\nstatic void cca_info_cache_scrub(u16 cardnr, u16 domain)\n{\n\tstruct cca_info_list_entry *ptr;\n\n\tspin_lock_bh(&cca_info_list_lock);\n\tlist_for_each_entry(ptr, &cca_info_list, list) {\n\t\tif (ptr->cardnr == cardnr &&\n\t\t    ptr->domain == domain) {\n\t\t\tlist_del(&ptr->list);\n\t\t\tkfree(ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&cca_info_list_lock);\n}\n\nstatic void __exit mkvp_cache_free(void)\n{\n\tstruct cca_info_list_entry *ptr, *pnext;\n\n\tspin_lock_bh(&cca_info_list_lock);\n\tlist_for_each_entry_safe(ptr, pnext, &cca_info_list, list) {\n\t\tlist_del(&ptr->list);\n\t\tkfree(ptr);\n\t}\n\tspin_unlock_bh(&cca_info_list_lock);\n}\n\n \nstatic int fetch_cca_info(u16 cardnr, u16 domain, struct cca_info *ci)\n{\n\tint rc, found = 0;\n\tsize_t rlen, vlen;\n\tu8 *rarray, *varray, *pg;\n\tstruct zcrypt_device_status_ext devstat;\n\n\tmemset(ci, 0, sizeof(*ci));\n\n\t \n\trc = zcrypt_device_status_ext(cardnr, domain, &devstat);\n\tif (rc)\n\t\treturn rc;\n\tci->hwtype = devstat.hwtype;\n\n\t \n\tpg = (u8 *)__get_free_page(GFP_KERNEL);\n\tif (!pg)\n\t\treturn -ENOMEM;\n\trarray = pg;\n\tvarray = pg + PAGE_SIZE / 2;\n\trlen = vlen = PAGE_SIZE / 2;\n\n\t \n\trc = cca_query_crypto_facility(cardnr, domain, \"STATICSA\",\n\t\t\t\t       rarray, &rlen, varray, &vlen);\n\tif (rc == 0 && rlen >= 10 * 8 && vlen >= 204) {\n\t\tmemcpy(ci->serial, rarray, 8);\n\t\tci->new_asym_mk_state = (char)rarray[4 * 8];\n\t\tci->cur_asym_mk_state = (char)rarray[5 * 8];\n\t\tci->old_asym_mk_state = (char)rarray[6 * 8];\n\t\tif (ci->old_asym_mk_state == '2')\n\t\t\tmemcpy(ci->old_asym_mkvp, varray + 64, 16);\n\t\tif (ci->cur_asym_mk_state == '2')\n\t\t\tmemcpy(ci->cur_asym_mkvp, varray + 84, 16);\n\t\tif (ci->new_asym_mk_state == '3')\n\t\t\tmemcpy(ci->new_asym_mkvp, varray + 104, 16);\n\t\tci->new_aes_mk_state = (char)rarray[7 * 8];\n\t\tci->cur_aes_mk_state = (char)rarray[8 * 8];\n\t\tci->old_aes_mk_state = (char)rarray[9 * 8];\n\t\tif (ci->old_aes_mk_state == '2')\n\t\t\tmemcpy(&ci->old_aes_mkvp, varray + 172, 8);\n\t\tif (ci->cur_aes_mk_state == '2')\n\t\t\tmemcpy(&ci->cur_aes_mkvp, varray + 184, 8);\n\t\tif (ci->new_aes_mk_state == '3')\n\t\t\tmemcpy(&ci->new_aes_mkvp, varray + 196, 8);\n\t\tfound++;\n\t}\n\tif (!found)\n\t\tgoto out;\n\trlen = vlen = PAGE_SIZE / 2;\n\trc = cca_query_crypto_facility(cardnr, domain, \"STATICSB\",\n\t\t\t\t       rarray, &rlen, varray, &vlen);\n\tif (rc == 0 && rlen >= 13 * 8 && vlen >= 240) {\n\t\tci->new_apka_mk_state = (char)rarray[10 * 8];\n\t\tci->cur_apka_mk_state = (char)rarray[11 * 8];\n\t\tci->old_apka_mk_state = (char)rarray[12 * 8];\n\t\tif (ci->old_apka_mk_state == '2')\n\t\t\tmemcpy(&ci->old_apka_mkvp, varray + 208, 8);\n\t\tif (ci->cur_apka_mk_state == '2')\n\t\t\tmemcpy(&ci->cur_apka_mkvp, varray + 220, 8);\n\t\tif (ci->new_apka_mk_state == '3')\n\t\t\tmemcpy(&ci->new_apka_mkvp, varray + 232, 8);\n\t\tfound++;\n\t}\n\nout:\n\tfree_page((unsigned long)pg);\n\treturn found == 2 ? 0 : -ENOENT;\n}\n\n \nint cca_get_info(u16 card, u16 dom, struct cca_info *ci, int verify)\n{\n\tint rc;\n\n\trc = cca_info_cache_fetch(card, dom, ci);\n\tif (rc || verify) {\n\t\trc = fetch_cca_info(card, dom, ci);\n\t\tif (rc == 0)\n\t\t\tcca_info_cache_update(card, dom, ci);\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_get_info);\n\n \nstatic int findcard(u64 mkvp, u16 *pcardnr, u16 *pdomain,\n\t\t    int verify, int minhwtype)\n{\n\tstruct zcrypt_device_status_ext *device_status;\n\tu16 card, dom;\n\tstruct cca_info ci;\n\tint i, rc, oi = -1;\n\n\t \n\tif (mkvp == 0 || minhwtype < 0)\n\t\treturn -EINVAL;\n\n\t \n\tdevice_status = kvmalloc_array(MAX_ZDEV_ENTRIES_EXT,\n\t\t\t\t       sizeof(struct zcrypt_device_status_ext),\n\t\t\t\t       GFP_KERNEL);\n\tif (!device_status)\n\t\treturn -ENOMEM;\n\tzcrypt_device_status_mask_ext(device_status);\n\n\t \n\tfor (i = 0; i < MAX_ZDEV_ENTRIES_EXT; i++) {\n\t\tcard = AP_QID_CARD(device_status[i].qid);\n\t\tdom = AP_QID_QUEUE(device_status[i].qid);\n\t\tif (device_status[i].online &&\n\t\t    device_status[i].functions & 0x04) {\n\t\t\t \n\t\t\tif (cca_info_cache_fetch(card, dom, &ci) == 0 &&\n\t\t\t    ci.hwtype >= minhwtype &&\n\t\t\t    ci.cur_aes_mk_state == '2' &&\n\t\t\t    ci.cur_aes_mkvp == mkvp) {\n\t\t\t\tif (!verify)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tif (fetch_cca_info(card, dom, &ci) == 0) {\n\t\t\t\t\tcca_info_cache_update(card, dom, &ci);\n\t\t\t\t\tif (ci.hwtype >= minhwtype &&\n\t\t\t\t\t    ci.cur_aes_mk_state == '2' &&\n\t\t\t\t\t    ci.cur_aes_mkvp == mkvp)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tcca_info_cache_scrub(card, dom);\n\t\t}\n\t}\n\tif (i >= MAX_ZDEV_ENTRIES_EXT) {\n\t\t \n\t\tfor (i = 0; i < MAX_ZDEV_ENTRIES_EXT; i++) {\n\t\t\tif (!(device_status[i].online &&\n\t\t\t      device_status[i].functions & 0x04))\n\t\t\t\tcontinue;\n\t\t\tcard = AP_QID_CARD(device_status[i].qid);\n\t\t\tdom = AP_QID_QUEUE(device_status[i].qid);\n\t\t\t \n\t\t\tif (fetch_cca_info(card, dom, &ci) == 0) {\n\t\t\t\tcca_info_cache_update(card, dom, &ci);\n\t\t\t\tif (ci.hwtype >= minhwtype &&\n\t\t\t\t    ci.cur_aes_mk_state == '2' &&\n\t\t\t\t    ci.cur_aes_mkvp == mkvp)\n\t\t\t\t\tbreak;\n\t\t\t\tif (ci.hwtype >= minhwtype &&\n\t\t\t\t    ci.old_aes_mk_state == '2' &&\n\t\t\t\t    ci.old_aes_mkvp == mkvp &&\n\t\t\t\t    oi < 0)\n\t\t\t\t\toi = i;\n\t\t\t}\n\t\t}\n\t\tif (i >= MAX_ZDEV_ENTRIES_EXT && oi >= 0) {\n\t\t\t \n\t\t\tcard = AP_QID_CARD(device_status[oi].qid);\n\t\t\tdom = AP_QID_QUEUE(device_status[oi].qid);\n\t\t}\n\t}\n\tif (i < MAX_ZDEV_ENTRIES_EXT || oi >= 0) {\n\t\tif (pcardnr)\n\t\t\t*pcardnr = card;\n\t\tif (pdomain)\n\t\t\t*pdomain = dom;\n\t\trc = (i < MAX_ZDEV_ENTRIES_EXT ? 0 : 1);\n\t} else {\n\t\trc = -ENODEV;\n\t}\n\n\tkvfree(device_status);\n\treturn rc;\n}\n\n \nint cca_findcard(const u8 *key, u16 *pcardnr, u16 *pdomain, int verify)\n{\n\tu64 mkvp;\n\tint minhwtype = 0;\n\tconst struct keytoken_header *hdr = (struct keytoken_header *)key;\n\n\tif (hdr->type != TOKTYPE_CCA_INTERNAL)\n\t\treturn -EINVAL;\n\n\tswitch (hdr->version) {\n\tcase TOKVER_CCA_AES:\n\t\tmkvp = ((struct secaeskeytoken *)key)->mkvp;\n\t\tbreak;\n\tcase TOKVER_CCA_VLSC:\n\t\tmkvp = ((struct cipherkeytoken *)key)->mkvp0;\n\t\tminhwtype = AP_DEVICE_TYPE_CEX6;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn findcard(mkvp, pcardnr, pdomain, verify, minhwtype);\n}\nEXPORT_SYMBOL(cca_findcard);\n\nint cca_findcard2(u32 **apqns, u32 *nr_apqns, u16 cardnr, u16 domain,\n\t\t  int minhwtype, int mktype, u64 cur_mkvp, u64 old_mkvp,\n\t\t  int verify)\n{\n\tstruct zcrypt_device_status_ext *device_status;\n\tu32 *_apqns = NULL, _nr_apqns = 0;\n\tint i, card, dom, curmatch, oldmatch, rc = 0;\n\tstruct cca_info ci;\n\n\t \n\tdevice_status = kvmalloc_array(MAX_ZDEV_ENTRIES_EXT,\n\t\t\t\t       sizeof(struct zcrypt_device_status_ext),\n\t\t\t\t       GFP_KERNEL);\n\tif (!device_status)\n\t\treturn -ENOMEM;\n\tzcrypt_device_status_mask_ext(device_status);\n\n\t \n\t_apqns = kmalloc_array(256, sizeof(u32), GFP_KERNEL);\n\tif (!_apqns) {\n\t\tkvfree(device_status);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_ZDEV_ENTRIES_EXT; i++) {\n\t\tcard = AP_QID_CARD(device_status[i].qid);\n\t\tdom = AP_QID_QUEUE(device_status[i].qid);\n\t\t \n\t\tif (!device_status[i].online)\n\t\t\tcontinue;\n\t\t \n\t\tif (!(device_status[i].functions & 0x04))\n\t\t\tcontinue;\n\t\t \n\t\tif (cardnr != 0xFFFF && card != cardnr)\n\t\t\tcontinue;\n\t\t \n\t\tif (domain != 0xFFFF && dom != domain)\n\t\t\tcontinue;\n\t\t \n\t\tif (cca_get_info(card, dom, &ci, verify))\n\t\t\tcontinue;\n\t\t \n\t\tif (mktype == AES_MK_SET && ci.cur_aes_mk_state != '2')\n\t\t\tcontinue;\n\t\tif (mktype == APKA_MK_SET && ci.cur_apka_mk_state != '2')\n\t\t\tcontinue;\n\t\t \n\t\tif (minhwtype > 0 && minhwtype > ci.hwtype)\n\t\t\tcontinue;\n\t\tif (cur_mkvp || old_mkvp) {\n\t\t\t \n\t\t\tcurmatch = oldmatch = 0;\n\t\t\tif (mktype == AES_MK_SET) {\n\t\t\t\tif (cur_mkvp && cur_mkvp == ci.cur_aes_mkvp)\n\t\t\t\t\tcurmatch = 1;\n\t\t\t\tif (old_mkvp && ci.old_aes_mk_state == '2' &&\n\t\t\t\t    old_mkvp == ci.old_aes_mkvp)\n\t\t\t\t\toldmatch = 1;\n\t\t\t} else {\n\t\t\t\tif (cur_mkvp && cur_mkvp == ci.cur_apka_mkvp)\n\t\t\t\t\tcurmatch = 1;\n\t\t\t\tif (old_mkvp && ci.old_apka_mk_state == '2' &&\n\t\t\t\t    old_mkvp == ci.old_apka_mkvp)\n\t\t\t\t\toldmatch = 1;\n\t\t\t}\n\t\t\tif (curmatch + oldmatch < 1)\n\t\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (_nr_apqns < 256)\n\t\t\t_apqns[_nr_apqns++] = (((u16)card) << 16) | ((u16)dom);\n\t}\n\n\t \n\tif (!_nr_apqns) {\n\t\tkfree(_apqns);\n\t\trc = -ENODEV;\n\t} else {\n\t\t \n\t\t*apqns = _apqns;\n\t\t*nr_apqns = _nr_apqns;\n\t\trc = 0;\n\t}\n\n\tkvfree(device_status);\n\treturn rc;\n}\nEXPORT_SYMBOL(cca_findcard2);\n\nvoid __exit zcrypt_ccamisc_exit(void)\n{\n\tmkvp_cache_free();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}