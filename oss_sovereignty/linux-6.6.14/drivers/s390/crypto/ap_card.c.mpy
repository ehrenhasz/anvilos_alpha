{
  "module_name": "ap_card.c",
  "hash_id": "a399c8a9b41713a977016ce3dd644f160e4bb047ead664ae2c8a3578505253f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/ap_card.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"ap\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <asm/facility.h>\n#include <asm/sclp.h>\n\n#include \"ap_bus.h\"\n\n \nstatic ssize_t hwtype_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ac->ap_dev.device_type);\n}\n\nstatic DEVICE_ATTR_RO(hwtype);\n\nstatic ssize_t raw_hwtype_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ac->raw_hwtype);\n}\n\nstatic DEVICE_ATTR_RO(raw_hwtype);\n\nstatic ssize_t depth_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ac->queue_depth);\n}\n\nstatic DEVICE_ATTR_RO(depth);\n\nstatic ssize_t ap_functions_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\treturn sysfs_emit(buf, \"0x%08X\\n\", ac->functions);\n}\n\nstatic DEVICE_ATTR_RO(ap_functions);\n\nstatic ssize_t request_count_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\tu64 req_cnt;\n\n\treq_cnt = 0;\n\tspin_lock_bh(&ap_queues_lock);\n\treq_cnt = atomic64_read(&ac->total_request_count);\n\tspin_unlock_bh(&ap_queues_lock);\n\treturn sysfs_emit(buf, \"%llu\\n\", req_cnt);\n}\n\nstatic ssize_t request_count_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint bkt;\n\tstruct ap_queue *aq;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tspin_lock_bh(&ap_queues_lock);\n\thash_for_each(ap_queues, bkt, aq, hnode)\n\t\tif (ac == aq->card)\n\t\t\taq->total_request_count = 0;\n\tspin_unlock_bh(&ap_queues_lock);\n\tatomic64_set(&ac->total_request_count, 0);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(request_count);\n\nstatic ssize_t requestq_count_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint bkt;\n\tstruct ap_queue *aq;\n\tunsigned int reqq_cnt;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\treqq_cnt = 0;\n\tspin_lock_bh(&ap_queues_lock);\n\thash_for_each(ap_queues, bkt, aq, hnode)\n\t\tif (ac == aq->card)\n\t\t\treqq_cnt += aq->requestq_count;\n\tspin_unlock_bh(&ap_queues_lock);\n\treturn sysfs_emit(buf, \"%d\\n\", reqq_cnt);\n}\n\nstatic DEVICE_ATTR_RO(requestq_count);\n\nstatic ssize_t pendingq_count_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint bkt;\n\tstruct ap_queue *aq;\n\tunsigned int penq_cnt;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tpenq_cnt = 0;\n\tspin_lock_bh(&ap_queues_lock);\n\thash_for_each(ap_queues, bkt, aq, hnode)\n\t\tif (ac == aq->card)\n\t\t\tpenq_cnt += aq->pendingq_count;\n\tspin_unlock_bh(&ap_queues_lock);\n\treturn sysfs_emit(buf, \"%d\\n\", penq_cnt);\n}\n\nstatic DEVICE_ATTR_RO(pendingq_count);\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"ap:t%02X\\n\", to_ap_dev(dev)->device_type);\n}\n\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t config_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ac->config ? 1 : 0);\n}\n\nstatic ssize_t config_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint rc = 0, cfg;\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tif (sscanf(buf, \"%d\\n\", &cfg) != 1 || cfg < 0 || cfg > 1)\n\t\treturn -EINVAL;\n\n\tif (cfg && !ac->config)\n\t\trc = sclp_ap_configure(ac->id);\n\telse if (!cfg && ac->config)\n\t\trc = sclp_ap_deconfigure(ac->id);\n\tif (rc)\n\t\treturn rc;\n\n\tac->config = cfg ? true : false;\n\n\tap_send_config_uevent(&ac->ap_dev, ac->config);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(config);\n\nstatic ssize_t chkstop_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ac->chkstop ? 1 : 0);\n}\n\nstatic DEVICE_ATTR_RO(chkstop);\n\nstatic ssize_t max_msg_size_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", ac->maxmsgsize);\n}\n\nstatic DEVICE_ATTR_RO(max_msg_size);\n\nstatic struct attribute *ap_card_dev_attrs[] = {\n\t&dev_attr_hwtype.attr,\n\t&dev_attr_raw_hwtype.attr,\n\t&dev_attr_depth.attr,\n\t&dev_attr_ap_functions.attr,\n\t&dev_attr_request_count.attr,\n\t&dev_attr_requestq_count.attr,\n\t&dev_attr_pendingq_count.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_config.attr,\n\t&dev_attr_chkstop.attr,\n\t&dev_attr_max_msg_size.attr,\n\tNULL\n};\n\nstatic struct attribute_group ap_card_dev_attr_group = {\n\t.attrs = ap_card_dev_attrs\n};\n\nstatic const struct attribute_group *ap_card_dev_attr_groups[] = {\n\t&ap_card_dev_attr_group,\n\tNULL\n};\n\nstatic struct device_type ap_card_type = {\n\t.name = \"ap_card\",\n\t.groups = ap_card_dev_attr_groups,\n};\n\nstatic void ap_card_device_release(struct device *dev)\n{\n\tstruct ap_card *ac = to_ap_card(dev);\n\n\tkfree(ac);\n}\n\nstruct ap_card *ap_card_create(int id, int queue_depth, int raw_type,\n\t\t\t       int comp_type, unsigned int functions, int ml)\n{\n\tstruct ap_card *ac;\n\n\tac = kzalloc(sizeof(*ac), GFP_KERNEL);\n\tif (!ac)\n\t\treturn NULL;\n\tac->ap_dev.device.release = ap_card_device_release;\n\tac->ap_dev.device.type = &ap_card_type;\n\tac->ap_dev.device_type = comp_type;\n\tac->raw_hwtype = raw_type;\n\tac->queue_depth = queue_depth;\n\tac->functions = functions;\n\tac->id = id;\n\tac->maxmsgsize = ml > 0 ?\n\t\tml * AP_TAPQ_ML_FIELD_CHUNK_SIZE : AP_DEFAULT_MAX_MSG_SIZE;\n\n\treturn ac;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}