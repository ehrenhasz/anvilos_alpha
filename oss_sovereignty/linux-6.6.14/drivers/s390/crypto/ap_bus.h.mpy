{
  "module_name": "ap_bus.h",
  "hash_id": "6686a789c2c33c4531bdc7580635556411b28bb4f980d86fab479f4f1ad13258",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/ap_bus.h",
  "human_readable_source": " \n \n\n#ifndef _AP_BUS_H_\n#define _AP_BUS_H_\n\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/hashtable.h>\n#include <asm/isc.h>\n#include <asm/ap.h>\n\n#define AP_DEVICES 256\t\t \n#define AP_DOMAINS 256\t\t \n#define AP_IOCTLS  256\t\t \n#define AP_RESET_TIMEOUT (HZ*0.7)\t \n#define AP_CONFIG_TIME 30\t \n#define AP_POLL_TIME 1\t\t \n#define AP_DEFAULT_MAX_MSG_SIZE (12 * 1024)\n#define AP_TAPQ_ML_FIELD_CHUNK_SIZE (4096)\n\nextern int ap_domain_index;\nextern atomic_t ap_max_msg_size;\n\nextern DECLARE_HASHTABLE(ap_queues, 8);\nextern spinlock_t ap_queues_lock;\n\nstatic inline int ap_test_bit(unsigned int *ptr, unsigned int nr)\n{\n\treturn (*ptr & (0x80000000u >> nr)) != 0;\n}\n\n#define AP_RESPONSE_NORMAL\t\t     0x00\n#define AP_RESPONSE_Q_NOT_AVAIL\t\t     0x01\n#define AP_RESPONSE_RESET_IN_PROGRESS\t     0x02\n#define AP_RESPONSE_DECONFIGURED\t     0x03\n#define AP_RESPONSE_CHECKSTOPPED\t     0x04\n#define AP_RESPONSE_BUSY\t\t     0x05\n#define AP_RESPONSE_INVALID_ADDRESS\t     0x06\n#define AP_RESPONSE_OTHERWISE_CHANGED\t     0x07\n#define AP_RESPONSE_INVALID_GISA\t     0x08\n#define AP_RESPONSE_Q_BOUND_TO_ANOTHER\t     0x09\n#define AP_RESPONSE_STATE_CHANGE_IN_PROGRESS 0x0A\n#define AP_RESPONSE_Q_NOT_BOUND\t\t     0x0B\n#define AP_RESPONSE_Q_FULL\t\t     0x10\n#define AP_RESPONSE_NO_PENDING_REPLY\t     0x10\n#define AP_RESPONSE_INDEX_TOO_BIG\t     0x11\n#define AP_RESPONSE_NO_FIRST_PART\t     0x13\n#define AP_RESPONSE_MESSAGE_TOO_BIG\t     0x15\n#define AP_RESPONSE_REQ_FAC_NOT_INST\t     0x16\n#define AP_RESPONSE_Q_BIND_ERROR\t     0x30\n#define AP_RESPONSE_Q_NOT_AVAIL_FOR_ASSOC    0x31\n#define AP_RESPONSE_Q_NOT_EMPTY\t\t     0x32\n#define AP_RESPONSE_BIND_LIMIT_EXCEEDED\t     0x33\n#define AP_RESPONSE_INVALID_ASSOC_SECRET     0x34\n#define AP_RESPONSE_ASSOC_SECRET_NOT_UNIQUE  0x35\n#define AP_RESPONSE_ASSOC_FAILED\t     0x36\n#define AP_RESPONSE_INVALID_DOMAIN\t     0x42\n\n \n#define AP_DEVICE_TYPE_CEX4\t10\n#define AP_DEVICE_TYPE_CEX5\t11\n#define AP_DEVICE_TYPE_CEX6\t12\n#define AP_DEVICE_TYPE_CEX7\t13\n#define AP_DEVICE_TYPE_CEX8\t14\n\n \n#define AP_FUNC_MEX4K 1\n#define AP_FUNC_CRT4K 2\n#define AP_FUNC_COPRO 3\n#define AP_FUNC_ACCEL 4\n#define AP_FUNC_EP11  5\n#define AP_FUNC_APXA  6\n\n \nenum ap_sm_state {\n\tAP_SM_STATE_RESET_START = 0,\n\tAP_SM_STATE_RESET_WAIT,\n\tAP_SM_STATE_SETIRQ_WAIT,\n\tAP_SM_STATE_IDLE,\n\tAP_SM_STATE_WORKING,\n\tAP_SM_STATE_QUEUE_FULL,\n\tAP_SM_STATE_ASSOC_WAIT,\n\tNR_AP_SM_STATES\n};\n\n \nenum ap_sm_event {\n\tAP_SM_EVENT_POLL,\n\tAP_SM_EVENT_TIMEOUT,\n\tNR_AP_SM_EVENTS\n};\n\n \nenum ap_sm_wait {\n\tAP_SM_WAIT_AGAIN = 0,\t  \n\tAP_SM_WAIT_HIGH_TIMEOUT,  \n\tAP_SM_WAIT_LOW_TIMEOUT,\t  \n\tAP_SM_WAIT_INTERRUPT,\t  \n\tAP_SM_WAIT_NONE,\t  \n\tNR_AP_SM_WAIT\n};\n\n \nenum ap_dev_state {\n\tAP_DEV_STATE_UNINITIATED = 0,\t \n\tAP_DEV_STATE_OPERATING,\t\t \n\tAP_DEV_STATE_SHUTDOWN,\t\t \n\tAP_DEV_STATE_ERROR,\t\t \n\tNR_AP_DEV_STATES\n};\n\nstruct ap_device;\nstruct ap_message;\n\n \n#define AP_DRIVER_FLAG_DEFAULT 0x0001\n\nstruct ap_driver {\n\tstruct device_driver driver;\n\tstruct ap_device_id *ids;\n\tunsigned int flags;\n\n\tint (*probe)(struct ap_device *);\n\tvoid (*remove)(struct ap_device *);\n\tint (*in_use)(unsigned long *apm, unsigned long *aqm);\n\t \n\tvoid (*on_config_changed)(struct ap_config_info *new_config_info,\n\t\t\t\t  struct ap_config_info *old_config_info);\n\t \n\tvoid (*on_scan_complete)(struct ap_config_info *new_config_info,\n\t\t\t\t struct ap_config_info *old_config_info);\n};\n\n#define to_ap_drv(x) container_of((x), struct ap_driver, driver)\n\nint ap_driver_register(struct ap_driver *, struct module *, char *);\nvoid ap_driver_unregister(struct ap_driver *);\n\nstruct ap_device {\n\tstruct device device;\n\tint device_type;\t\t \n};\n\n#define to_ap_dev(x) container_of((x), struct ap_device, device)\n\nstruct ap_card {\n\tstruct ap_device ap_dev;\n\tint raw_hwtype;\t\t\t \n\tunsigned int functions;\t\t \n\tint queue_depth;\t\t \n\tint id;\t\t\t\t \n\tunsigned int maxmsgsize;\t \n\tbool config;\t\t\t \n\tbool chkstop;\t\t\t \n\tatomic64_t total_request_count;\t \n};\n\n#define TAPQ_CARD_FUNC_CMP_MASK 0xFFFF0000\n#define ASSOC_IDX_INVALID 0x10000\n\n#define to_ap_card(x) container_of((x), struct ap_card, ap_dev.device)\n\nstruct ap_queue {\n\tstruct ap_device ap_dev;\n\tstruct hlist_node hnode;\t \n\tstruct ap_card *card;\t\t \n\tspinlock_t lock;\t\t \n\tenum ap_dev_state dev_state;\t \n\tbool config;\t\t\t \n\tbool chkstop;\t\t\t \n\tap_qid_t qid;\t\t\t \n\tbool interrupt;\t\t\t \n\tunsigned int assoc_idx;\t\t \n\tint queue_count;\t\t \n\tint pendingq_count;\t\t \n\tint requestq_count;\t\t \n\tu64 total_request_count;\t \n\tint request_timeout;\t\t \n\tstruct timer_list timeout;\t \n\tstruct list_head pendingq;\t \n\tstruct list_head requestq;\t \n\tstruct ap_message *reply;\t \n\tenum ap_sm_state sm_state;\t \n\tint rapq_fbit;\t\t\t \n\tint last_err_rc;\t\t \n};\n\n#define to_ap_queue(x) container_of((x), struct ap_queue, ap_dev.device)\n\ntypedef enum ap_sm_wait (ap_func_t)(struct ap_queue *queue);\n\nstruct ap_message {\n\tstruct list_head list;\t\t \n\tunsigned long psmid;\t\t \n\tvoid *msg;\t\t\t \n\tsize_t len;\t\t\t \n\tsize_t bufsize;\t\t\t \n\tu16 flags;\t\t\t \n\tint rc;\t\t\t\t \n\tvoid *private;\t\t\t \n\t \n\tvoid (*receive)(struct ap_queue *, struct ap_message *,\n\t\t\tstruct ap_message *);\n};\n\n#define AP_MSG_FLAG_SPECIAL  0x0001\t \n#define AP_MSG_FLAG_USAGE    0x0002\t \n#define AP_MSG_FLAG_ADMIN    0x0004\t \n\n \nstatic inline void ap_init_message(struct ap_message *ap_msg)\n{\n\tmemset(ap_msg, 0, sizeof(*ap_msg));\n}\n\n \nstatic inline void ap_release_message(struct ap_message *ap_msg)\n{\n\tkfree_sensitive(ap_msg->msg);\n\tkfree_sensitive(ap_msg->private);\n}\n\nenum ap_sm_wait ap_sm_event(struct ap_queue *aq, enum ap_sm_event event);\nenum ap_sm_wait ap_sm_event_loop(struct ap_queue *aq, enum ap_sm_event event);\n\nint ap_queue_message(struct ap_queue *aq, struct ap_message *ap_msg);\nvoid ap_cancel_message(struct ap_queue *aq, struct ap_message *ap_msg);\nvoid ap_flush_queue(struct ap_queue *aq);\n\nvoid *ap_airq_ptr(void);\nint ap_sb_available(void);\nbool ap_is_se_guest(void);\nvoid ap_wait(enum ap_sm_wait wait);\nvoid ap_request_timeout(struct timer_list *t);\nvoid ap_bus_force_rescan(void);\n\nint ap_test_config_usage_domain(unsigned int domain);\nint ap_test_config_ctrl_domain(unsigned int domain);\n\nvoid ap_queue_init_reply(struct ap_queue *aq, struct ap_message *ap_msg);\nstruct ap_queue *ap_queue_create(ap_qid_t qid, int device_type);\nvoid ap_queue_prepare_remove(struct ap_queue *aq);\nvoid ap_queue_remove(struct ap_queue *aq);\nvoid ap_queue_init_state(struct ap_queue *aq);\nvoid _ap_queue_init_state(struct ap_queue *aq);\n\nstruct ap_card *ap_card_create(int id, int queue_depth, int raw_type,\n\t\t\t       int comp_type, unsigned int functions, int ml);\n\n#define APMASKSIZE (BITS_TO_LONGS(AP_DEVICES) * sizeof(unsigned long))\n#define AQMASKSIZE (BITS_TO_LONGS(AP_DOMAINS) * sizeof(unsigned long))\n\nstruct ap_perms {\n\tunsigned long ioctlm[BITS_TO_LONGS(AP_IOCTLS)];\n\tunsigned long apm[BITS_TO_LONGS(AP_DEVICES)];\n\tunsigned long aqm[BITS_TO_LONGS(AP_DOMAINS)];\n\tunsigned long adm[BITS_TO_LONGS(AP_DOMAINS)];\n};\n\nextern struct ap_perms ap_perms;\nextern struct mutex ap_perms_mutex;\n\n \nstruct ap_queue *ap_get_qdev(ap_qid_t qid);\n\n \nint ap_owned_by_def_drv(int card, int queue);\n\n \nint ap_apqn_in_matrix_owned_by_def_drv(unsigned long *apm,\n\t\t\t\t       unsigned long *aqm);\n\n \nint ap_parse_mask_str(const char *str,\n\t\t      unsigned long *bitmap, int bits,\n\t\t      struct mutex *lock);\n\n \nint ap_wait_init_apqn_bindings_complete(unsigned long timeout);\n\nvoid ap_send_config_uevent(struct ap_device *ap_dev, bool cfg);\nvoid ap_send_online_uevent(struct ap_device *ap_dev, int online);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}