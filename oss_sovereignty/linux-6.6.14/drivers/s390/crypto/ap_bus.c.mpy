{
  "module_name": "ap_bus.c",
  "hash_id": "4e03b5c01a506257ba30079d449451252ccfe52aa66c4846341b993bab630984",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/ap_bus.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"ap\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel_stat.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/freezer.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/notifier.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <asm/airq.h>\n#include <asm/tpi.h>\n#include <linux/atomic.h>\n#include <asm/isc.h>\n#include <linux/hrtimer.h>\n#include <linux/ktime.h>\n#include <asm/facility.h>\n#include <linux/crypto.h>\n#include <linux/mod_devicetable.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#include \"ap_bus.h\"\n#include \"ap_debug.h\"\n\n \nint ap_domain_index = -1;\t \nstatic DEFINE_SPINLOCK(ap_domain_lock);\nmodule_param_named(domain, ap_domain_index, int, 0440);\nMODULE_PARM_DESC(domain, \"domain index for ap devices\");\nEXPORT_SYMBOL(ap_domain_index);\n\nstatic int ap_thread_flag;\nmodule_param_named(poll_thread, ap_thread_flag, int, 0440);\nMODULE_PARM_DESC(poll_thread, \"Turn on/off poll thread, default is 0 (off).\");\n\nstatic char *apm_str;\nmodule_param_named(apmask, apm_str, charp, 0440);\nMODULE_PARM_DESC(apmask, \"AP bus adapter mask.\");\n\nstatic char *aqm_str;\nmodule_param_named(aqmask, aqm_str, charp, 0440);\nMODULE_PARM_DESC(aqmask, \"AP bus domain mask.\");\n\nstatic int ap_useirq = 1;\nmodule_param_named(useirq, ap_useirq, int, 0440);\nMODULE_PARM_DESC(useirq, \"Use interrupt if available, default is 1 (on).\");\n\natomic_t ap_max_msg_size = ATOMIC_INIT(AP_DEFAULT_MAX_MSG_SIZE);\nEXPORT_SYMBOL(ap_max_msg_size);\n\nstatic struct device *ap_root_device;\n\n \nDEFINE_HASHTABLE(ap_queues, 8);\n \nDEFINE_SPINLOCK(ap_queues_lock);\n\n \nstruct ap_perms ap_perms;\nEXPORT_SYMBOL(ap_perms);\nDEFINE_MUTEX(ap_perms_mutex);\nEXPORT_SYMBOL(ap_perms_mutex);\n\n \nstatic atomic64_t ap_scan_bus_count;\n\n \nstatic atomic64_t ap_bindings_complete_count = ATOMIC64_INIT(0);\n\n \nstatic DECLARE_COMPLETION(ap_init_apqn_bindings_complete);\n\nstatic struct ap_config_info *ap_qci_info;\nstatic struct ap_config_info *ap_qci_info_old;\n\n \ndebug_info_t *ap_dbf_info;\n\n \nstatic struct timer_list ap_config_timer;\nstatic int ap_config_time = AP_CONFIG_TIME;\nstatic void ap_scan_bus(struct work_struct *);\nstatic DECLARE_WORK(ap_scan_work, ap_scan_bus);\n\n \nstatic void ap_tasklet_fn(unsigned long);\nstatic DECLARE_TASKLET_OLD(ap_tasklet, ap_tasklet_fn);\nstatic DECLARE_WAIT_QUEUE_HEAD(ap_poll_wait);\nstatic struct task_struct *ap_poll_kthread;\nstatic DEFINE_MUTEX(ap_poll_thread_mutex);\nstatic DEFINE_SPINLOCK(ap_poll_timer_lock);\nstatic struct hrtimer ap_poll_timer;\n \nstatic unsigned long poll_high_timeout = 250000UL;\n\n \nstatic unsigned long poll_low_timeout = 40000000UL;\n\n \nstatic int ap_max_domain_id = 15;\n \nstatic int ap_max_adapter_id = 63;\n\nstatic struct bus_type ap_bus_type;\n\n \nstatic void ap_interrupt_handler(struct airq_struct *airq,\n\t\t\t\t struct tpi_info *tpi_info);\n\nstatic bool ap_irq_flag;\n\nstatic struct airq_struct ap_airq = {\n\t.handler = ap_interrupt_handler,\n\t.isc = AP_ISC,\n};\n\n \nvoid *ap_airq_ptr(void)\n{\n\tif (ap_irq_flag)\n\t\treturn ap_airq.lsi_ptr;\n\treturn NULL;\n}\n\n \nstatic int ap_interrupts_available(void)\n{\n\treturn test_facility(65);\n}\n\n \nstatic int ap_qci_available(void)\n{\n\treturn test_facility(12);\n}\n\n \nstatic int ap_apft_available(void)\n{\n\treturn test_facility(15);\n}\n\n \nstatic inline int ap_qact_available(void)\n{\n\tif (ap_qci_info)\n\t\treturn ap_qci_info->qact;\n\treturn 0;\n}\n\n \nint ap_sb_available(void)\n{\n\tif (ap_qci_info)\n\t\treturn ap_qci_info->apsb;\n\treturn 0;\n}\n\n \nbool ap_is_se_guest(void)\n{\n\treturn is_prot_virt_guest() && ap_sb_available();\n}\nEXPORT_SYMBOL(ap_is_se_guest);\n\n \nstatic inline int ap_fetch_qci_info(struct ap_config_info *info)\n{\n\tif (!ap_qci_available())\n\t\treturn -EOPNOTSUPP;\n\tif (!info)\n\t\treturn -EINVAL;\n\treturn ap_qci(info);\n}\n\n \nstatic void __init ap_init_qci_info(void)\n{\n\tif (!ap_qci_available()) {\n\t\tAP_DBF_INFO(\"%s QCI not supported\\n\", __func__);\n\t\treturn;\n\t}\n\n\tap_qci_info = kzalloc(sizeof(*ap_qci_info), GFP_KERNEL);\n\tif (!ap_qci_info)\n\t\treturn;\n\tap_qci_info_old = kzalloc(sizeof(*ap_qci_info_old), GFP_KERNEL);\n\tif (!ap_qci_info_old) {\n\t\tkfree(ap_qci_info);\n\t\tap_qci_info = NULL;\n\t\treturn;\n\t}\n\tif (ap_fetch_qci_info(ap_qci_info) != 0) {\n\t\tkfree(ap_qci_info);\n\t\tkfree(ap_qci_info_old);\n\t\tap_qci_info = NULL;\n\t\tap_qci_info_old = NULL;\n\t\treturn;\n\t}\n\tAP_DBF_INFO(\"%s successful fetched initial qci info\\n\", __func__);\n\n\tif (ap_qci_info->apxa) {\n\t\tif (ap_qci_info->na) {\n\t\t\tap_max_adapter_id = ap_qci_info->na;\n\t\t\tAP_DBF_INFO(\"%s new ap_max_adapter_id is %d\\n\",\n\t\t\t\t    __func__, ap_max_adapter_id);\n\t\t}\n\t\tif (ap_qci_info->nd) {\n\t\t\tap_max_domain_id = ap_qci_info->nd;\n\t\t\tAP_DBF_INFO(\"%s new ap_max_domain_id is %d\\n\",\n\t\t\t\t    __func__, ap_max_domain_id);\n\t\t}\n\t}\n\n\tmemcpy(ap_qci_info_old, ap_qci_info, sizeof(*ap_qci_info));\n}\n\n \nstatic inline int ap_test_config(unsigned int *field, unsigned int nr)\n{\n\treturn ap_test_bit((field + (nr >> 5)), (nr & 0x1f));\n}\n\n \nstatic inline int ap_test_config_card_id(unsigned int id)\n{\n\tif (id > ap_max_adapter_id)\n\t\treturn 0;\n\tif (ap_qci_info)\n\t\treturn ap_test_config(ap_qci_info->apm, id);\n\treturn 1;\n}\n\n \nint ap_test_config_usage_domain(unsigned int domain)\n{\n\tif (domain > ap_max_domain_id)\n\t\treturn 0;\n\tif (ap_qci_info)\n\t\treturn ap_test_config(ap_qci_info->aqm, domain);\n\treturn 1;\n}\nEXPORT_SYMBOL(ap_test_config_usage_domain);\n\n \nint ap_test_config_ctrl_domain(unsigned int domain)\n{\n\tif (!ap_qci_info || domain > ap_max_domain_id)\n\t\treturn 0;\n\treturn ap_test_config(ap_qci_info->adm, domain);\n}\nEXPORT_SYMBOL(ap_test_config_ctrl_domain);\n\n \nstatic int ap_queue_info(ap_qid_t qid, int *q_type, unsigned int *q_fac,\n\t\t\t int *q_depth, int *q_ml, bool *q_decfg, bool *q_cstop)\n{\n\tstruct ap_queue_status status;\n\tstruct ap_tapq_gr2 tapq_info;\n\n\ttapq_info.value = 0;\n\n\t \n\tif (AP_QID_CARD(qid) > ap_max_adapter_id ||\n\t    AP_QID_QUEUE(qid) > ap_max_domain_id)\n\t\treturn -1;\n\n\t \n\tstatus = ap_test_queue(qid, ap_apft_available(), &tapq_info);\n\n\t \n\tif (status.async)\n\t\treturn 0;\n\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\tcase AP_RESPONSE_RESET_IN_PROGRESS:\n\tcase AP_RESPONSE_DECONFIGURED:\n\tcase AP_RESPONSE_CHECKSTOPPED:\n\tcase AP_RESPONSE_BUSY:\n\t\t \n\t\tif (WARN_ON_ONCE(!tapq_info.value))\n\t\t\treturn 0;\n\t\t*q_type = tapq_info.at;\n\t\t*q_fac = tapq_info.fac;\n\t\t*q_depth = tapq_info.qd;\n\t\t*q_ml = tapq_info.ml;\n\t\t*q_decfg = status.response_code == AP_RESPONSE_DECONFIGURED;\n\t\t*q_cstop = status.response_code == AP_RESPONSE_CHECKSTOPPED;\n\t\treturn 1;\n\tdefault:\n\t\t \n\t\treturn -1;\n\t}\n}\n\nvoid ap_wait(enum ap_sm_wait wait)\n{\n\tktime_t hr_time;\n\n\tswitch (wait) {\n\tcase AP_SM_WAIT_AGAIN:\n\tcase AP_SM_WAIT_INTERRUPT:\n\t\tif (ap_irq_flag)\n\t\t\tbreak;\n\t\tif (ap_poll_kthread) {\n\t\t\twake_up(&ap_poll_wait);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase AP_SM_WAIT_LOW_TIMEOUT:\n\tcase AP_SM_WAIT_HIGH_TIMEOUT:\n\t\tspin_lock_bh(&ap_poll_timer_lock);\n\t\tif (!hrtimer_is_queued(&ap_poll_timer)) {\n\t\t\thr_time =\n\t\t\t\twait == AP_SM_WAIT_LOW_TIMEOUT ?\n\t\t\t\tpoll_low_timeout : poll_high_timeout;\n\t\t\thrtimer_forward_now(&ap_poll_timer, hr_time);\n\t\t\thrtimer_restart(&ap_poll_timer);\n\t\t}\n\t\tspin_unlock_bh(&ap_poll_timer_lock);\n\t\tbreak;\n\tcase AP_SM_WAIT_NONE:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid ap_request_timeout(struct timer_list *t)\n{\n\tstruct ap_queue *aq = from_timer(aq, t, timeout);\n\n\tspin_lock_bh(&aq->lock);\n\tap_wait(ap_sm_event(aq, AP_SM_EVENT_TIMEOUT));\n\tspin_unlock_bh(&aq->lock);\n}\n\n \nstatic enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)\n{\n\ttasklet_schedule(&ap_tasklet);\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic void ap_interrupt_handler(struct airq_struct *airq,\n\t\t\t\t struct tpi_info *tpi_info)\n{\n\tinc_irq_stat(IRQIO_APB);\n\ttasklet_schedule(&ap_tasklet);\n}\n\n \nstatic void ap_tasklet_fn(unsigned long dummy)\n{\n\tint bkt;\n\tstruct ap_queue *aq;\n\tenum ap_sm_wait wait = AP_SM_WAIT_NONE;\n\n\t \n\tif (ap_irq_flag)\n\t\txchg(ap_airq.lsi_ptr, 0);\n\n\tspin_lock_bh(&ap_queues_lock);\n\thash_for_each(ap_queues, bkt, aq, hnode) {\n\t\tspin_lock_bh(&aq->lock);\n\t\twait = min(wait, ap_sm_event_loop(aq, AP_SM_EVENT_POLL));\n\t\tspin_unlock_bh(&aq->lock);\n\t}\n\tspin_unlock_bh(&ap_queues_lock);\n\n\tap_wait(wait);\n}\n\nstatic int ap_pending_requests(void)\n{\n\tint bkt;\n\tstruct ap_queue *aq;\n\n\tspin_lock_bh(&ap_queues_lock);\n\thash_for_each(ap_queues, bkt, aq, hnode) {\n\t\tif (aq->queue_count == 0)\n\t\t\tcontinue;\n\t\tspin_unlock_bh(&ap_queues_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock_bh(&ap_queues_lock);\n\treturn 0;\n}\n\n \nstatic int ap_poll_thread(void *data)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tset_user_nice(current, MAX_NICE);\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\tadd_wait_queue(&ap_poll_wait, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!ap_pending_requests()) {\n\t\t\tschedule();\n\t\t\ttry_to_freeze();\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tremove_wait_queue(&ap_poll_wait, &wait);\n\t\tif (need_resched()) {\n\t\t\tschedule();\n\t\t\ttry_to_freeze();\n\t\t\tcontinue;\n\t\t}\n\t\tap_tasklet_fn(0);\n\t}\n\n\treturn 0;\n}\n\nstatic int ap_poll_thread_start(void)\n{\n\tint rc;\n\n\tif (ap_irq_flag || ap_poll_kthread)\n\t\treturn 0;\n\tmutex_lock(&ap_poll_thread_mutex);\n\tap_poll_kthread = kthread_run(ap_poll_thread, NULL, \"appoll\");\n\trc = PTR_ERR_OR_ZERO(ap_poll_kthread);\n\tif (rc)\n\t\tap_poll_kthread = NULL;\n\tmutex_unlock(&ap_poll_thread_mutex);\n\treturn rc;\n}\n\nstatic void ap_poll_thread_stop(void)\n{\n\tif (!ap_poll_kthread)\n\t\treturn;\n\tmutex_lock(&ap_poll_thread_mutex);\n\tkthread_stop(ap_poll_kthread);\n\tap_poll_kthread = NULL;\n\tmutex_unlock(&ap_poll_thread_mutex);\n}\n\n#define is_card_dev(x) ((x)->parent == ap_root_device)\n#define is_queue_dev(x) ((x)->parent != ap_root_device)\n\n \nstatic int ap_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct ap_driver *ap_drv = to_ap_drv(drv);\n\tstruct ap_device_id *id;\n\n\t \n\tfor (id = ap_drv->ids; id->match_flags; id++) {\n\t\tif (is_card_dev(dev) &&\n\t\t    id->match_flags & AP_DEVICE_ID_MATCH_CARD_TYPE &&\n\t\t    id->dev_type == to_ap_dev(dev)->device_type)\n\t\t\treturn 1;\n\t\tif (is_queue_dev(dev) &&\n\t\t    id->match_flags & AP_DEVICE_ID_MATCH_QUEUE_TYPE &&\n\t\t    id->dev_type == to_ap_dev(dev)->device_type)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int ap_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tint rc = 0;\n\tconst struct ap_device *ap_dev = to_ap_dev(dev);\n\n\t \n\tif (dev == ap_root_device)\n\t\treturn 0;\n\n\tif (is_card_dev(dev)) {\n\t\tstruct ap_card *ac = to_ap_card(&ap_dev->device);\n\n\t\t \n\t\trc = add_uevent_var(env, \"DEV_TYPE=%04X\", ap_dev->device_type);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t \n\t\trc = add_uevent_var(env, \"MODALIAS=ap:t%02X\", ap_dev->device_type);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (ap_test_bit(&ac->functions, AP_FUNC_ACCEL))\n\t\t\trc = add_uevent_var(env, \"MODE=accel\");\n\t\telse if (ap_test_bit(&ac->functions, AP_FUNC_COPRO))\n\t\t\trc = add_uevent_var(env, \"MODE=cca\");\n\t\telse if (ap_test_bit(&ac->functions, AP_FUNC_EP11))\n\t\t\trc = add_uevent_var(env, \"MODE=ep11\");\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tstruct ap_queue *aq = to_ap_queue(&ap_dev->device);\n\n\t\t \n\t\tif (ap_test_bit(&aq->card->functions, AP_FUNC_ACCEL))\n\t\t\trc = add_uevent_var(env, \"MODE=accel\");\n\t\telse if (ap_test_bit(&aq->card->functions, AP_FUNC_COPRO))\n\t\t\trc = add_uevent_var(env, \"MODE=cca\");\n\t\telse if (ap_test_bit(&aq->card->functions, AP_FUNC_EP11))\n\t\t\trc = add_uevent_var(env, \"MODE=ep11\");\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void ap_send_init_scan_done_uevent(void)\n{\n\tchar *envp[] = { \"INITSCAN=done\", NULL };\n\n\tkobject_uevent_env(&ap_root_device->kobj, KOBJ_CHANGE, envp);\n}\n\nstatic void ap_send_bindings_complete_uevent(void)\n{\n\tchar buf[32];\n\tchar *envp[] = { \"BINDINGS=complete\", buf, NULL };\n\n\tsnprintf(buf, sizeof(buf), \"COMPLETECOUNT=%llu\",\n\t\t atomic64_inc_return(&ap_bindings_complete_count));\n\tkobject_uevent_env(&ap_root_device->kobj, KOBJ_CHANGE, envp);\n}\n\nvoid ap_send_config_uevent(struct ap_device *ap_dev, bool cfg)\n{\n\tchar buf[16];\n\tchar *envp[] = { buf, NULL };\n\n\tsnprintf(buf, sizeof(buf), \"CONFIG=%d\", cfg ? 1 : 0);\n\n\tkobject_uevent_env(&ap_dev->device.kobj, KOBJ_CHANGE, envp);\n}\nEXPORT_SYMBOL(ap_send_config_uevent);\n\nvoid ap_send_online_uevent(struct ap_device *ap_dev, int online)\n{\n\tchar buf[16];\n\tchar *envp[] = { buf, NULL };\n\n\tsnprintf(buf, sizeof(buf), \"ONLINE=%d\", online ? 1 : 0);\n\n\tkobject_uevent_env(&ap_dev->device.kobj, KOBJ_CHANGE, envp);\n}\nEXPORT_SYMBOL(ap_send_online_uevent);\n\nstatic void ap_send_mask_changed_uevent(unsigned long *newapm,\n\t\t\t\t\tunsigned long *newaqm)\n{\n\tchar buf[100];\n\tchar *envp[] = { buf, NULL };\n\n\tif (newapm)\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t \"APMASK=0x%016lx%016lx%016lx%016lx\\n\",\n\t\t\t newapm[0], newapm[1], newapm[2], newapm[3]);\n\telse\n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t \"AQMASK=0x%016lx%016lx%016lx%016lx\\n\",\n\t\t\t newaqm[0], newaqm[1], newaqm[2], newaqm[3]);\n\n\tkobject_uevent_env(&ap_root_device->kobj, KOBJ_CHANGE, envp);\n}\n\n \n\nstruct __ap_calc_ctrs {\n\tunsigned int apqns;\n\tunsigned int bound;\n};\n\nstatic int __ap_calc_helper(struct device *dev, void *arg)\n{\n\tstruct __ap_calc_ctrs *pctrs = (struct __ap_calc_ctrs *)arg;\n\n\tif (is_queue_dev(dev)) {\n\t\tpctrs->apqns++;\n\t\tif (dev->driver)\n\t\t\tpctrs->bound++;\n\t}\n\n\treturn 0;\n}\n\nstatic void ap_calc_bound_apqns(unsigned int *apqns, unsigned int *bound)\n{\n\tstruct __ap_calc_ctrs ctrs;\n\n\tmemset(&ctrs, 0, sizeof(ctrs));\n\tbus_for_each_dev(&ap_bus_type, NULL, (void *)&ctrs, __ap_calc_helper);\n\n\t*apqns = ctrs.apqns;\n\t*bound = ctrs.bound;\n}\n\n \nstatic void ap_check_bindings_complete(void)\n{\n\tunsigned int apqns, bound;\n\n\tif (atomic64_read(&ap_scan_bus_count) >= 1) {\n\t\tap_calc_bound_apqns(&apqns, &bound);\n\t\tif (bound == apqns) {\n\t\t\tif (!completion_done(&ap_init_apqn_bindings_complete)) {\n\t\t\t\tcomplete_all(&ap_init_apqn_bindings_complete);\n\t\t\t\tAP_DBF_INFO(\"%s complete\\n\", __func__);\n\t\t\t}\n\t\t\tap_send_bindings_complete_uevent();\n\t\t}\n\t}\n}\n\n \nint ap_wait_init_apqn_bindings_complete(unsigned long timeout)\n{\n\tlong l;\n\n\tif (completion_done(&ap_init_apqn_bindings_complete))\n\t\treturn 0;\n\n\tif (timeout)\n\t\tl = wait_for_completion_interruptible_timeout(\n\t\t\t&ap_init_apqn_bindings_complete, timeout);\n\telse\n\t\tl = wait_for_completion_interruptible(\n\t\t\t&ap_init_apqn_bindings_complete);\n\tif (l < 0)\n\t\treturn l == -ERESTARTSYS ? -EINTR : l;\n\telse if (l == 0 && timeout)\n\t\treturn -ETIME;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ap_wait_init_apqn_bindings_complete);\n\nstatic int __ap_queue_devices_with_id_unregister(struct device *dev, void *data)\n{\n\tif (is_queue_dev(dev) &&\n\t    AP_QID_CARD(to_ap_queue(dev)->qid) == (int)(long)data)\n\t\tdevice_unregister(dev);\n\treturn 0;\n}\n\nstatic int __ap_revise_reserved(struct device *dev, void *dummy)\n{\n\tint rc, card, queue, devres, drvres;\n\n\tif (is_queue_dev(dev)) {\n\t\tcard = AP_QID_CARD(to_ap_queue(dev)->qid);\n\t\tqueue = AP_QID_QUEUE(to_ap_queue(dev)->qid);\n\t\tmutex_lock(&ap_perms_mutex);\n\t\tdevres = test_bit_inv(card, ap_perms.apm) &&\n\t\t\ttest_bit_inv(queue, ap_perms.aqm);\n\t\tmutex_unlock(&ap_perms_mutex);\n\t\tdrvres = to_ap_drv(dev->driver)->flags\n\t\t\t& AP_DRIVER_FLAG_DEFAULT;\n\t\tif (!!devres != !!drvres) {\n\t\t\tAP_DBF_DBG(\"%s reprobing queue=%02x.%04x\\n\",\n\t\t\t\t   __func__, card, queue);\n\t\t\trc = device_reprobe(dev);\n\t\t\tif (rc)\n\t\t\t\tAP_DBF_WARN(\"%s reprobing queue=%02x.%04x failed\\n\",\n\t\t\t\t\t    __func__, card, queue);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ap_bus_revise_bindings(void)\n{\n\tbus_for_each_dev(&ap_bus_type, NULL, NULL, __ap_revise_reserved);\n}\n\n \nint ap_owned_by_def_drv(int card, int queue)\n{\n\tint rc = 0;\n\n\tif (card < 0 || card >= AP_DEVICES || queue < 0 || queue >= AP_DOMAINS)\n\t\treturn -EINVAL;\n\n\tif (test_bit_inv(card, ap_perms.apm) &&\n\t    test_bit_inv(queue, ap_perms.aqm))\n\t\trc = 1;\n\n\treturn rc;\n}\nEXPORT_SYMBOL(ap_owned_by_def_drv);\n\n \nint ap_apqn_in_matrix_owned_by_def_drv(unsigned long *apm,\n\t\t\t\t       unsigned long *aqm)\n{\n\tint card, queue, rc = 0;\n\n\tfor (card = 0; !rc && card < AP_DEVICES; card++)\n\t\tif (test_bit_inv(card, apm) &&\n\t\t    test_bit_inv(card, ap_perms.apm))\n\t\t\tfor (queue = 0; !rc && queue < AP_DOMAINS; queue++)\n\t\t\t\tif (test_bit_inv(queue, aqm) &&\n\t\t\t\t    test_bit_inv(queue, ap_perms.aqm))\n\t\t\t\t\trc = 1;\n\n\treturn rc;\n}\nEXPORT_SYMBOL(ap_apqn_in_matrix_owned_by_def_drv);\n\nstatic int ap_device_probe(struct device *dev)\n{\n\tstruct ap_device *ap_dev = to_ap_dev(dev);\n\tstruct ap_driver *ap_drv = to_ap_drv(dev->driver);\n\tint card, queue, devres, drvres, rc = -ENODEV;\n\n\tif (!get_device(dev))\n\t\treturn rc;\n\n\tif (is_queue_dev(dev)) {\n\t\t \n\t\tcard = AP_QID_CARD(to_ap_queue(dev)->qid);\n\t\tqueue = AP_QID_QUEUE(to_ap_queue(dev)->qid);\n\t\tmutex_lock(&ap_perms_mutex);\n\t\tdevres = test_bit_inv(card, ap_perms.apm) &&\n\t\t\ttest_bit_inv(queue, ap_perms.aqm);\n\t\tmutex_unlock(&ap_perms_mutex);\n\t\tdrvres = ap_drv->flags & AP_DRIVER_FLAG_DEFAULT;\n\t\tif (!!devres != !!drvres)\n\t\t\tgoto out;\n\t}\n\n\t \n\tspin_lock_bh(&ap_queues_lock);\n\tif (is_queue_dev(dev))\n\t\thash_add(ap_queues, &to_ap_queue(dev)->hnode,\n\t\t\t to_ap_queue(dev)->qid);\n\tspin_unlock_bh(&ap_queues_lock);\n\n\trc = ap_drv->probe ? ap_drv->probe(ap_dev) : -ENODEV;\n\n\tif (rc) {\n\t\tspin_lock_bh(&ap_queues_lock);\n\t\tif (is_queue_dev(dev))\n\t\t\thash_del(&to_ap_queue(dev)->hnode);\n\t\tspin_unlock_bh(&ap_queues_lock);\n\t} else {\n\t\tap_check_bindings_complete();\n\t}\n\nout:\n\tif (rc)\n\t\tput_device(dev);\n\treturn rc;\n}\n\nstatic void ap_device_remove(struct device *dev)\n{\n\tstruct ap_device *ap_dev = to_ap_dev(dev);\n\tstruct ap_driver *ap_drv = to_ap_drv(dev->driver);\n\n\t \n\tif (is_queue_dev(dev))\n\t\tap_queue_prepare_remove(to_ap_queue(dev));\n\n\t \n\tif (ap_drv->remove)\n\t\tap_drv->remove(ap_dev);\n\n\t \n\tif (is_queue_dev(dev))\n\t\tap_queue_remove(to_ap_queue(dev));\n\n\t \n\tspin_lock_bh(&ap_queues_lock);\n\tif (is_queue_dev(dev))\n\t\thash_del(&to_ap_queue(dev)->hnode);\n\tspin_unlock_bh(&ap_queues_lock);\n\n\tput_device(dev);\n}\n\nstruct ap_queue *ap_get_qdev(ap_qid_t qid)\n{\n\tint bkt;\n\tstruct ap_queue *aq;\n\n\tspin_lock_bh(&ap_queues_lock);\n\thash_for_each(ap_queues, bkt, aq, hnode) {\n\t\tif (aq->qid == qid) {\n\t\t\tget_device(&aq->ap_dev.device);\n\t\t\tspin_unlock_bh(&ap_queues_lock);\n\t\t\treturn aq;\n\t\t}\n\t}\n\tspin_unlock_bh(&ap_queues_lock);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(ap_get_qdev);\n\nint ap_driver_register(struct ap_driver *ap_drv, struct module *owner,\n\t\t       char *name)\n{\n\tstruct device_driver *drv = &ap_drv->driver;\n\n\tdrv->bus = &ap_bus_type;\n\tdrv->owner = owner;\n\tdrv->name = name;\n\treturn driver_register(drv);\n}\nEXPORT_SYMBOL(ap_driver_register);\n\nvoid ap_driver_unregister(struct ap_driver *ap_drv)\n{\n\tdriver_unregister(&ap_drv->driver);\n}\nEXPORT_SYMBOL(ap_driver_unregister);\n\nvoid ap_bus_force_rescan(void)\n{\n\t \n\tif (atomic64_read(&ap_scan_bus_count) <= 0)\n\t\treturn;\n\n\t \n\tdel_timer(&ap_config_timer);\n\tqueue_work(system_long_wq, &ap_scan_work);\n\tflush_work(&ap_scan_work);\n}\nEXPORT_SYMBOL(ap_bus_force_rescan);\n\n \nvoid ap_bus_cfg_chg(void)\n{\n\tAP_DBF_DBG(\"%s config change, forcing bus rescan\\n\", __func__);\n\n\tap_bus_force_rescan();\n}\n\n \nstatic int hex2bitmap(const char *str, unsigned long *bitmap, int bits)\n{\n\tint i, n, b;\n\n\t \n\tif (bits & 0x07)\n\t\treturn -EINVAL;\n\n\tif (str[0] == '0' && str[1] == 'x')\n\t\tstr++;\n\tif (*str == 'x')\n\t\tstr++;\n\n\tfor (i = 0; isxdigit(*str) && i < bits; str++) {\n\t\tb = hex_to_bin(*str);\n\t\tfor (n = 0; n < 4; n++)\n\t\t\tif (b & (0x08 >> n))\n\t\t\t\tset_bit_inv(i + n, bitmap);\n\t\ti += 4;\n\t}\n\n\tif (*str == '\\n')\n\t\tstr++;\n\tif (*str)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int modify_bitmap(const char *str, unsigned long *bitmap, int bits)\n{\n\tint a, i, z;\n\tchar *np, sign;\n\n\t \n\tif (bits & 0x07)\n\t\treturn -EINVAL;\n\n\twhile (*str) {\n\t\tsign = *str++;\n\t\tif (sign != '+' && sign != '-')\n\t\t\treturn -EINVAL;\n\t\ta = z = simple_strtoul(str, &np, 0);\n\t\tif (str == np || a >= bits)\n\t\t\treturn -EINVAL;\n\t\tstr = np;\n\t\tif (*str == '-') {\n\t\t\tz = simple_strtoul(++str, &np, 0);\n\t\t\tif (str == np || a > z || z >= bits)\n\t\t\t\treturn -EINVAL;\n\t\t\tstr = np;\n\t\t}\n\t\tfor (i = a; i <= z; i++)\n\t\t\tif (sign == '+')\n\t\t\t\tset_bit_inv(i, bitmap);\n\t\t\telse\n\t\t\t\tclear_bit_inv(i, bitmap);\n\t\twhile (*str == ',' || *str == '\\n')\n\t\t\tstr++;\n\t}\n\n\treturn 0;\n}\n\nstatic int ap_parse_bitmap_str(const char *str, unsigned long *bitmap, int bits,\n\t\t\t       unsigned long *newmap)\n{\n\tunsigned long size;\n\tint rc;\n\n\tsize = BITS_TO_LONGS(bits) * sizeof(unsigned long);\n\tif (*str == '+' || *str == '-') {\n\t\tmemcpy(newmap, bitmap, size);\n\t\trc = modify_bitmap(str, newmap, bits);\n\t} else {\n\t\tmemset(newmap, 0, size);\n\t\trc = hex2bitmap(str, newmap, bits);\n\t}\n\treturn rc;\n}\n\nint ap_parse_mask_str(const char *str,\n\t\t      unsigned long *bitmap, int bits,\n\t\t      struct mutex *lock)\n{\n\tunsigned long *newmap, size;\n\tint rc;\n\n\t \n\tif (bits & 0x07)\n\t\treturn -EINVAL;\n\n\tsize = BITS_TO_LONGS(bits) * sizeof(unsigned long);\n\tnewmap = kmalloc(size, GFP_KERNEL);\n\tif (!newmap)\n\t\treturn -ENOMEM;\n\tif (mutex_lock_interruptible(lock)) {\n\t\tkfree(newmap);\n\t\treturn -ERESTARTSYS;\n\t}\n\trc = ap_parse_bitmap_str(str, bitmap, bits, newmap);\n\tif (rc == 0)\n\t\tmemcpy(bitmap, newmap, size);\n\tmutex_unlock(lock);\n\tkfree(newmap);\n\treturn rc;\n}\nEXPORT_SYMBOL(ap_parse_mask_str);\n\n \n\nstatic ssize_t ap_domain_show(const struct bus_type *bus, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ap_domain_index);\n}\n\nstatic ssize_t ap_domain_store(const struct bus_type *bus,\n\t\t\t       const char *buf, size_t count)\n{\n\tint domain;\n\n\tif (sscanf(buf, \"%i\\n\", &domain) != 1 ||\n\t    domain < 0 || domain > ap_max_domain_id ||\n\t    !test_bit_inv(domain, ap_perms.aqm))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&ap_domain_lock);\n\tap_domain_index = domain;\n\tspin_unlock_bh(&ap_domain_lock);\n\n\tAP_DBF_INFO(\"%s stored new default domain=%d\\n\",\n\t\t    __func__, domain);\n\n\treturn count;\n}\n\nstatic BUS_ATTR_RW(ap_domain);\n\nstatic ssize_t ap_control_domain_mask_show(const struct bus_type *bus, char *buf)\n{\n\tif (!ap_qci_info)\t \n\t\treturn sysfs_emit(buf, \"not supported\\n\");\n\n\treturn sysfs_emit(buf, \"0x%08x%08x%08x%08x%08x%08x%08x%08x\\n\",\n\t\t\t  ap_qci_info->adm[0], ap_qci_info->adm[1],\n\t\t\t  ap_qci_info->adm[2], ap_qci_info->adm[3],\n\t\t\t  ap_qci_info->adm[4], ap_qci_info->adm[5],\n\t\t\t  ap_qci_info->adm[6], ap_qci_info->adm[7]);\n}\n\nstatic BUS_ATTR_RO(ap_control_domain_mask);\n\nstatic ssize_t ap_usage_domain_mask_show(const struct bus_type *bus, char *buf)\n{\n\tif (!ap_qci_info)\t \n\t\treturn sysfs_emit(buf, \"not supported\\n\");\n\n\treturn sysfs_emit(buf, \"0x%08x%08x%08x%08x%08x%08x%08x%08x\\n\",\n\t\t\t  ap_qci_info->aqm[0], ap_qci_info->aqm[1],\n\t\t\t  ap_qci_info->aqm[2], ap_qci_info->aqm[3],\n\t\t\t  ap_qci_info->aqm[4], ap_qci_info->aqm[5],\n\t\t\t  ap_qci_info->aqm[6], ap_qci_info->aqm[7]);\n}\n\nstatic BUS_ATTR_RO(ap_usage_domain_mask);\n\nstatic ssize_t ap_adapter_mask_show(const struct bus_type *bus, char *buf)\n{\n\tif (!ap_qci_info)\t \n\t\treturn sysfs_emit(buf, \"not supported\\n\");\n\n\treturn sysfs_emit(buf, \"0x%08x%08x%08x%08x%08x%08x%08x%08x\\n\",\n\t\t\t  ap_qci_info->apm[0], ap_qci_info->apm[1],\n\t\t\t  ap_qci_info->apm[2], ap_qci_info->apm[3],\n\t\t\t  ap_qci_info->apm[4], ap_qci_info->apm[5],\n\t\t\t  ap_qci_info->apm[6], ap_qci_info->apm[7]);\n}\n\nstatic BUS_ATTR_RO(ap_adapter_mask);\n\nstatic ssize_t ap_interrupts_show(const struct bus_type *bus, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ap_irq_flag ? 1 : 0);\n}\n\nstatic BUS_ATTR_RO(ap_interrupts);\n\nstatic ssize_t config_time_show(const struct bus_type *bus, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ap_config_time);\n}\n\nstatic ssize_t config_time_store(const struct bus_type *bus,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint time;\n\n\tif (sscanf(buf, \"%d\\n\", &time) != 1 || time < 5 || time > 120)\n\t\treturn -EINVAL;\n\tap_config_time = time;\n\tmod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);\n\treturn count;\n}\n\nstatic BUS_ATTR_RW(config_time);\n\nstatic ssize_t poll_thread_show(const struct bus_type *bus, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ap_poll_kthread ? 1 : 0);\n}\n\nstatic ssize_t poll_thread_store(const struct bus_type *bus,\n\t\t\t\t const char *buf, size_t count)\n{\n\tbool value;\n\tint rc;\n\n\trc = kstrtobool(buf, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tif (value) {\n\t\trc = ap_poll_thread_start();\n\t\tif (rc)\n\t\t\tcount = rc;\n\t} else {\n\t\tap_poll_thread_stop();\n\t}\n\treturn count;\n}\n\nstatic BUS_ATTR_RW(poll_thread);\n\nstatic ssize_t poll_timeout_show(const struct bus_type *bus, char *buf)\n{\n\treturn sysfs_emit(buf, \"%lu\\n\", poll_high_timeout);\n}\n\nstatic ssize_t poll_timeout_store(const struct bus_type *bus, const char *buf,\n\t\t\t\t  size_t count)\n{\n\tunsigned long value;\n\tktime_t hr_time;\n\tint rc;\n\n\trc = kstrtoul(buf, 0, &value);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (value > 120000000000UL)\n\t\treturn -EINVAL;\n\tpoll_high_timeout = value;\n\thr_time = poll_high_timeout;\n\n\tspin_lock_bh(&ap_poll_timer_lock);\n\thrtimer_cancel(&ap_poll_timer);\n\thrtimer_set_expires(&ap_poll_timer, hr_time);\n\thrtimer_start_expires(&ap_poll_timer, HRTIMER_MODE_ABS);\n\tspin_unlock_bh(&ap_poll_timer_lock);\n\n\treturn count;\n}\n\nstatic BUS_ATTR_RW(poll_timeout);\n\nstatic ssize_t ap_max_domain_id_show(const struct bus_type *bus, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ap_max_domain_id);\n}\n\nstatic BUS_ATTR_RO(ap_max_domain_id);\n\nstatic ssize_t ap_max_adapter_id_show(const struct bus_type *bus, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", ap_max_adapter_id);\n}\n\nstatic BUS_ATTR_RO(ap_max_adapter_id);\n\nstatic ssize_t apmask_show(const struct bus_type *bus, char *buf)\n{\n\tint rc;\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\trc = sysfs_emit(buf, \"0x%016lx%016lx%016lx%016lx\\n\",\n\t\t\tap_perms.apm[0], ap_perms.apm[1],\n\t\t\tap_perms.apm[2], ap_perms.apm[3]);\n\tmutex_unlock(&ap_perms_mutex);\n\n\treturn rc;\n}\n\nstatic int __verify_card_reservations(struct device_driver *drv, void *data)\n{\n\tint rc = 0;\n\tstruct ap_driver *ap_drv = to_ap_drv(drv);\n\tunsigned long *newapm = (unsigned long *)data;\n\n\t \n\tif (!try_module_get(drv->owner))\n\t\treturn 0;\n\n\tif (ap_drv->in_use) {\n\t\trc = ap_drv->in_use(newapm, ap_perms.aqm);\n\t\tif (rc)\n\t\t\trc = -EBUSY;\n\t}\n\n\t \n\tmodule_put(drv->owner);\n\n\treturn rc;\n}\n\nstatic int apmask_commit(unsigned long *newapm)\n{\n\tint rc;\n\tunsigned long reserved[BITS_TO_LONGS(AP_DEVICES)];\n\n\t \n\tif (bitmap_andnot(reserved, newapm, ap_perms.apm, AP_DEVICES)) {\n\t\trc = bus_for_each_drv(&ap_bus_type, NULL, reserved,\n\t\t\t\t      __verify_card_reservations);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tmemcpy(ap_perms.apm, newapm, APMASKSIZE);\n\n\treturn 0;\n}\n\nstatic ssize_t apmask_store(const struct bus_type *bus, const char *buf,\n\t\t\t    size_t count)\n{\n\tint rc, changes = 0;\n\tDECLARE_BITMAP(newapm, AP_DEVICES);\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\n\trc = ap_parse_bitmap_str(buf, ap_perms.apm, AP_DEVICES, newapm);\n\tif (rc)\n\t\tgoto done;\n\n\tchanges = memcmp(ap_perms.apm, newapm, APMASKSIZE);\n\tif (changes)\n\t\trc = apmask_commit(newapm);\n\ndone:\n\tmutex_unlock(&ap_perms_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\tif (changes) {\n\t\tap_bus_revise_bindings();\n\t\tap_send_mask_changed_uevent(newapm, NULL);\n\t}\n\n\treturn count;\n}\n\nstatic BUS_ATTR_RW(apmask);\n\nstatic ssize_t aqmask_show(const struct bus_type *bus, char *buf)\n{\n\tint rc;\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\trc = sysfs_emit(buf, \"0x%016lx%016lx%016lx%016lx\\n\",\n\t\t\tap_perms.aqm[0], ap_perms.aqm[1],\n\t\t\tap_perms.aqm[2], ap_perms.aqm[3]);\n\tmutex_unlock(&ap_perms_mutex);\n\n\treturn rc;\n}\n\nstatic int __verify_queue_reservations(struct device_driver *drv, void *data)\n{\n\tint rc = 0;\n\tstruct ap_driver *ap_drv = to_ap_drv(drv);\n\tunsigned long *newaqm = (unsigned long *)data;\n\n\t \n\tif (!try_module_get(drv->owner))\n\t\treturn 0;\n\n\tif (ap_drv->in_use) {\n\t\trc = ap_drv->in_use(ap_perms.apm, newaqm);\n\t\tif (rc)\n\t\t\trc = -EBUSY;\n\t}\n\n\t \n\tmodule_put(drv->owner);\n\n\treturn rc;\n}\n\nstatic int aqmask_commit(unsigned long *newaqm)\n{\n\tint rc;\n\tunsigned long reserved[BITS_TO_LONGS(AP_DOMAINS)];\n\n\t \n\tif (bitmap_andnot(reserved, newaqm, ap_perms.aqm, AP_DOMAINS)) {\n\t\trc = bus_for_each_drv(&ap_bus_type, NULL, reserved,\n\t\t\t\t      __verify_queue_reservations);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tmemcpy(ap_perms.aqm, newaqm, AQMASKSIZE);\n\n\treturn 0;\n}\n\nstatic ssize_t aqmask_store(const struct bus_type *bus, const char *buf,\n\t\t\t    size_t count)\n{\n\tint rc, changes = 0;\n\tDECLARE_BITMAP(newaqm, AP_DOMAINS);\n\n\tif (mutex_lock_interruptible(&ap_perms_mutex))\n\t\treturn -ERESTARTSYS;\n\n\trc = ap_parse_bitmap_str(buf, ap_perms.aqm, AP_DOMAINS, newaqm);\n\tif (rc)\n\t\tgoto done;\n\n\tchanges = memcmp(ap_perms.aqm, newaqm, APMASKSIZE);\n\tif (changes)\n\t\trc = aqmask_commit(newaqm);\n\ndone:\n\tmutex_unlock(&ap_perms_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\tif (changes) {\n\t\tap_bus_revise_bindings();\n\t\tap_send_mask_changed_uevent(NULL, newaqm);\n\t}\n\n\treturn count;\n}\n\nstatic BUS_ATTR_RW(aqmask);\n\nstatic ssize_t scans_show(const struct bus_type *bus, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\", atomic64_read(&ap_scan_bus_count));\n}\n\nstatic ssize_t scans_store(const struct bus_type *bus, const char *buf,\n\t\t\t   size_t count)\n{\n\tAP_DBF_INFO(\"%s force AP bus rescan\\n\", __func__);\n\n\tap_bus_force_rescan();\n\n\treturn count;\n}\n\nstatic BUS_ATTR_RW(scans);\n\nstatic ssize_t bindings_show(const struct bus_type *bus, char *buf)\n{\n\tint rc;\n\tunsigned int apqns, n;\n\n\tap_calc_bound_apqns(&apqns, &n);\n\tif (atomic64_read(&ap_scan_bus_count) >= 1 && n == apqns)\n\t\trc = sysfs_emit(buf, \"%u/%u (complete)\\n\", n, apqns);\n\telse\n\t\trc = sysfs_emit(buf, \"%u/%u\\n\", n, apqns);\n\n\treturn rc;\n}\n\nstatic BUS_ATTR_RO(bindings);\n\nstatic ssize_t features_show(const struct bus_type *bus, char *buf)\n{\n\tint n = 0;\n\n\tif (!ap_qci_info)\t \n\t\treturn sysfs_emit(buf, \"-\\n\");\n\n\tif (ap_qci_info->apsc)\n\t\tn += sysfs_emit_at(buf, n, \"APSC \");\n\tif (ap_qci_info->apxa)\n\t\tn += sysfs_emit_at(buf, n, \"APXA \");\n\tif (ap_qci_info->qact)\n\t\tn += sysfs_emit_at(buf, n, \"QACT \");\n\tif (ap_qci_info->rc8a)\n\t\tn += sysfs_emit_at(buf, n, \"RC8A \");\n\tif (ap_qci_info->apsb)\n\t\tn += sysfs_emit_at(buf, n, \"APSB \");\n\n\tsysfs_emit_at(buf, n == 0 ? 0 : n - 1, \"\\n\");\n\n\treturn n;\n}\n\nstatic BUS_ATTR_RO(features);\n\nstatic struct attribute *ap_bus_attrs[] = {\n\t&bus_attr_ap_domain.attr,\n\t&bus_attr_ap_control_domain_mask.attr,\n\t&bus_attr_ap_usage_domain_mask.attr,\n\t&bus_attr_ap_adapter_mask.attr,\n\t&bus_attr_config_time.attr,\n\t&bus_attr_poll_thread.attr,\n\t&bus_attr_ap_interrupts.attr,\n\t&bus_attr_poll_timeout.attr,\n\t&bus_attr_ap_max_domain_id.attr,\n\t&bus_attr_ap_max_adapter_id.attr,\n\t&bus_attr_apmask.attr,\n\t&bus_attr_aqmask.attr,\n\t&bus_attr_scans.attr,\n\t&bus_attr_bindings.attr,\n\t&bus_attr_features.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ap_bus);\n\nstatic struct bus_type ap_bus_type = {\n\t.name = \"ap\",\n\t.bus_groups = ap_bus_groups,\n\t.match = &ap_bus_match,\n\t.uevent = &ap_uevent,\n\t.probe = ap_device_probe,\n\t.remove = ap_device_remove,\n};\n\n \nstatic void ap_select_domain(void)\n{\n\tstruct ap_queue_status status;\n\tint card, dom;\n\n\t \n\tspin_lock_bh(&ap_domain_lock);\n\tif (ap_domain_index >= 0) {\n\t\t \n\t\tgoto out;\n\t}\n\tfor (dom = 0; dom <= ap_max_domain_id; dom++) {\n\t\tif (!ap_test_config_usage_domain(dom) ||\n\t\t    !test_bit_inv(dom, ap_perms.aqm))\n\t\t\tcontinue;\n\t\tfor (card = 0; card <= ap_max_adapter_id; card++) {\n\t\t\tif (!ap_test_config_card_id(card) ||\n\t\t\t    !test_bit_inv(card, ap_perms.apm))\n\t\t\t\tcontinue;\n\t\t\tstatus = ap_test_queue(AP_MKQID(card, dom),\n\t\t\t\t\t       ap_apft_available(),\n\t\t\t\t\t       NULL);\n\t\t\tif (status.response_code == AP_RESPONSE_NORMAL)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (card <= ap_max_adapter_id)\n\t\t\tbreak;\n\t}\n\tif (dom <= ap_max_domain_id) {\n\t\tap_domain_index = dom;\n\t\tAP_DBF_INFO(\"%s new default domain is %d\\n\",\n\t\t\t    __func__, ap_domain_index);\n\t}\nout:\n\tspin_unlock_bh(&ap_domain_lock);\n}\n\n \nstatic int ap_get_compatible_type(ap_qid_t qid, int rawtype, unsigned int func)\n{\n\tint comp_type = 0;\n\n\t \n\tif (rawtype < AP_DEVICE_TYPE_CEX4) {\n\t\tAP_DBF_WARN(\"%s queue=%02x.%04x unsupported type %d\\n\",\n\t\t\t    __func__, AP_QID_CARD(qid),\n\t\t\t    AP_QID_QUEUE(qid), rawtype);\n\t\treturn 0;\n\t}\n\t \n\tif (rawtype <= AP_DEVICE_TYPE_CEX8)\n\t\treturn rawtype;\n\t \n\tif (ap_qact_available()) {\n\t\tstruct ap_queue_status status;\n\t\tunion ap_qact_ap_info apinfo = {0};\n\n\t\tapinfo.mode = (func >> 26) & 0x07;\n\t\tapinfo.cat = AP_DEVICE_TYPE_CEX8;\n\t\tstatus = ap_qact(qid, 0, &apinfo);\n\t\tif (status.response_code == AP_RESPONSE_NORMAL &&\n\t\t    apinfo.cat >= AP_DEVICE_TYPE_CEX4 &&\n\t\t    apinfo.cat <= AP_DEVICE_TYPE_CEX8)\n\t\t\tcomp_type = apinfo.cat;\n\t}\n\tif (!comp_type)\n\t\tAP_DBF_WARN(\"%s queue=%02x.%04x unable to map type %d\\n\",\n\t\t\t    __func__, AP_QID_CARD(qid),\n\t\t\t    AP_QID_QUEUE(qid), rawtype);\n\telse if (comp_type != rawtype)\n\t\tAP_DBF_INFO(\"%s queue=%02x.%04x map type %d to %d\\n\",\n\t\t\t    __func__, AP_QID_CARD(qid), AP_QID_QUEUE(qid),\n\t\t\t    rawtype, comp_type);\n\treturn comp_type;\n}\n\n \nstatic int __match_card_device_with_id(struct device *dev, const void *data)\n{\n\treturn is_card_dev(dev) && to_ap_card(dev)->id == (int)(long)(void *)data;\n}\n\n \nstatic int __match_queue_device_with_qid(struct device *dev, const void *data)\n{\n\treturn is_queue_dev(dev) && to_ap_queue(dev)->qid == (int)(long)data;\n}\n\n \nstatic int __match_queue_device_with_queue_id(struct device *dev, const void *data)\n{\n\treturn is_queue_dev(dev) &&\n\t\tAP_QID_QUEUE(to_ap_queue(dev)->qid) == (int)(long)data;\n}\n\n \nstatic int __drv_notify_config_changed(struct device_driver *drv, void *data)\n{\n\tstruct ap_driver *ap_drv = to_ap_drv(drv);\n\n\tif (try_module_get(drv->owner)) {\n\t\tif (ap_drv->on_config_changed)\n\t\t\tap_drv->on_config_changed(ap_qci_info, ap_qci_info_old);\n\t\tmodule_put(drv->owner);\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void notify_config_changed(void)\n{\n\tbus_for_each_drv(&ap_bus_type, NULL, NULL,\n\t\t\t __drv_notify_config_changed);\n}\n\n \nstatic int __drv_notify_scan_complete(struct device_driver *drv, void *data)\n{\n\tstruct ap_driver *ap_drv = to_ap_drv(drv);\n\n\tif (try_module_get(drv->owner)) {\n\t\tif (ap_drv->on_scan_complete)\n\t\t\tap_drv->on_scan_complete(ap_qci_info,\n\t\t\t\t\t\t ap_qci_info_old);\n\t\tmodule_put(drv->owner);\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void notify_scan_complete(void)\n{\n\tbus_for_each_drv(&ap_bus_type, NULL, NULL,\n\t\t\t __drv_notify_scan_complete);\n}\n\n \nstatic inline void ap_scan_rm_card_dev_and_queue_devs(struct ap_card *ac)\n{\n\tbus_for_each_dev(&ap_bus_type, NULL,\n\t\t\t (void *)(long)ac->id,\n\t\t\t __ap_queue_devices_with_id_unregister);\n\tdevice_unregister(&ac->ap_dev.device);\n}\n\n \nstatic inline void ap_scan_domains(struct ap_card *ac)\n{\n\tint rc, dom, depth, type, ml;\n\tbool decfg, chkstop;\n\tstruct ap_queue *aq;\n\tstruct device *dev;\n\tunsigned int func;\n\tap_qid_t qid;\n\n\t \n\n\tfor (dom = 0; dom <= ap_max_domain_id; dom++) {\n\t\tqid = AP_MKQID(ac->id, dom);\n\t\tdev = bus_find_device(&ap_bus_type, NULL,\n\t\t\t\t      (void *)(long)qid,\n\t\t\t\t      __match_queue_device_with_qid);\n\t\taq = dev ? to_ap_queue(dev) : NULL;\n\t\tif (!ap_test_config_usage_domain(dom)) {\n\t\t\tif (dev) {\n\t\t\t\tAP_DBF_INFO(\"%s(%d,%d) not in config anymore, rm queue dev\\n\",\n\t\t\t\t\t    __func__, ac->id, dom);\n\t\t\t\tdevice_unregister(dev);\n\t\t\t}\n\t\t\tgoto put_dev_and_continue;\n\t\t}\n\t\t \n\t\trc = ap_queue_info(qid, &type, &func, &depth,\n\t\t\t\t   &ml, &decfg, &chkstop);\n\t\tswitch (rc) {\n\t\tcase -1:\n\t\t\tif (dev) {\n\t\t\t\tAP_DBF_INFO(\"%s(%d,%d) queue_info() failed, rm queue dev\\n\",\n\t\t\t\t\t    __func__, ac->id, dom);\n\t\t\t\tdevice_unregister(dev);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\tgoto put_dev_and_continue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!aq) {\n\t\t\taq = ap_queue_create(qid, ac->ap_dev.device_type);\n\t\t\tif (!aq) {\n\t\t\t\tAP_DBF_WARN(\"%s(%d,%d) ap_queue_create() failed\\n\",\n\t\t\t\t\t    __func__, ac->id, dom);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taq->card = ac;\n\t\t\taq->config = !decfg;\n\t\t\taq->chkstop = chkstop;\n\t\t\tdev = &aq->ap_dev.device;\n\t\t\tdev->bus = &ap_bus_type;\n\t\t\tdev->parent = &ac->ap_dev.device;\n\t\t\tdev_set_name(dev, \"%02x.%04x\", ac->id, dom);\n\t\t\t \n\t\t\trc = device_register(dev);\n\t\t\tif (rc) {\n\t\t\t\tAP_DBF_WARN(\"%s(%d,%d) device_register() failed\\n\",\n\t\t\t\t\t    __func__, ac->id, dom);\n\t\t\t\tgoto put_dev_and_continue;\n\t\t\t}\n\t\t\t \n\t\t\tget_device(dev);\n\t\t\tif (decfg) {\n\t\t\t\tAP_DBF_INFO(\"%s(%d,%d) new (decfg) queue dev created\\n\",\n\t\t\t\t\t    __func__, ac->id, dom);\n\t\t\t} else if (chkstop) {\n\t\t\t\tAP_DBF_INFO(\"%s(%d,%d) new (chkstop) queue dev created\\n\",\n\t\t\t\t\t    __func__, ac->id, dom);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tap_queue_init_state(aq);\n\t\t\t\tAP_DBF_INFO(\"%s(%d,%d) new queue dev created\\n\",\n\t\t\t\t\t    __func__, ac->id, dom);\n\t\t\t}\n\t\t\tgoto put_dev_and_continue;\n\t\t}\n\t\t \n\t\tspin_lock_bh(&aq->lock);\n\t\t \n\t\tif (chkstop && !aq->chkstop) {\n\t\t\t \n\t\t\taq->chkstop = true;\n\t\t\tif (aq->dev_state > AP_DEV_STATE_UNINITIATED) {\n\t\t\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\t\t\taq->last_err_rc = AP_RESPONSE_CHECKSTOPPED;\n\t\t\t}\n\t\t\tspin_unlock_bh(&aq->lock);\n\t\t\tAP_DBF_DBG(\"%s(%d,%d) queue dev checkstop on\\n\",\n\t\t\t\t   __func__, ac->id, dom);\n\t\t\t \n\t\t\tap_flush_queue(aq);\n\t\t\tgoto put_dev_and_continue;\n\t\t} else if (!chkstop && aq->chkstop) {\n\t\t\t \n\t\t\taq->chkstop = false;\n\t\t\tif (aq->dev_state > AP_DEV_STATE_UNINITIATED)\n\t\t\t\t_ap_queue_init_state(aq);\n\t\t\tspin_unlock_bh(&aq->lock);\n\t\t\tAP_DBF_DBG(\"%s(%d,%d) queue dev checkstop off\\n\",\n\t\t\t\t   __func__, ac->id, dom);\n\t\t\tgoto put_dev_and_continue;\n\t\t}\n\t\t \n\t\tif (decfg && aq->config) {\n\t\t\t \n\t\t\taq->config = false;\n\t\t\tif (aq->dev_state > AP_DEV_STATE_UNINITIATED) {\n\t\t\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\t\t\taq->last_err_rc = AP_RESPONSE_DECONFIGURED;\n\t\t\t}\n\t\t\tspin_unlock_bh(&aq->lock);\n\t\t\tAP_DBF_DBG(\"%s(%d,%d) queue dev config off\\n\",\n\t\t\t\t   __func__, ac->id, dom);\n\t\t\tap_send_config_uevent(&aq->ap_dev, aq->config);\n\t\t\t \n\t\t\tap_flush_queue(aq);\n\t\t\tgoto put_dev_and_continue;\n\t\t} else if (!decfg && !aq->config) {\n\t\t\t \n\t\t\taq->config = true;\n\t\t\tif (aq->dev_state > AP_DEV_STATE_UNINITIATED)\n\t\t\t\t_ap_queue_init_state(aq);\n\t\t\tspin_unlock_bh(&aq->lock);\n\t\t\tAP_DBF_DBG(\"%s(%d,%d) queue dev config on\\n\",\n\t\t\t\t   __func__, ac->id, dom);\n\t\t\tap_send_config_uevent(&aq->ap_dev, aq->config);\n\t\t\tgoto put_dev_and_continue;\n\t\t}\n\t\t \n\t\tif (!decfg && aq->dev_state == AP_DEV_STATE_ERROR) {\n\t\t\tspin_unlock_bh(&aq->lock);\n\t\t\t \n\t\t\tap_flush_queue(aq);\n\t\t\t \n\t\t\tap_queue_init_state(aq);\n\t\t\tAP_DBF_INFO(\"%s(%d,%d) queue dev reinit enforced\\n\",\n\t\t\t\t    __func__, ac->id, dom);\n\t\t\tgoto put_dev_and_continue;\n\t\t}\n\t\tspin_unlock_bh(&aq->lock);\nput_dev_and_continue:\n\t\tput_device(dev);\n\t}\n}\n\n \nstatic inline void ap_scan_adapter(int ap)\n{\n\tint rc, dom, depth, type, comp_type, ml;\n\tbool decfg, chkstop;\n\tstruct ap_card *ac;\n\tstruct device *dev;\n\tunsigned int func;\n\tap_qid_t qid;\n\n\t \n\tdev = bus_find_device(&ap_bus_type, NULL,\n\t\t\t      (void *)(long)ap,\n\t\t\t      __match_card_device_with_id);\n\tac = dev ? to_ap_card(dev) : NULL;\n\n\t \n\tif (!ap_test_config_card_id(ap)) {\n\t\tif (ac) {\n\t\t\tAP_DBF_INFO(\"%s(%d) ap not in config any more, rm card and queue devs\\n\",\n\t\t\t\t    __func__, ap);\n\t\t\tap_scan_rm_card_dev_and_queue_devs(ac);\n\t\t\tput_device(dev);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\n\tfor (dom = 0; dom <= ap_max_domain_id; dom++)\n\t\tif (ap_test_config_usage_domain(dom)) {\n\t\t\tqid = AP_MKQID(ap, dom);\n\t\t\tif (ap_queue_info(qid, &type, &func, &depth,\n\t\t\t\t\t  &ml, &decfg, &chkstop) > 0)\n\t\t\t\tbreak;\n\t\t}\n\tif (dom > ap_max_domain_id) {\n\t\t \n\t\tif (ac) {\n\t\t\tAP_DBF_INFO(\"%s(%d) no type info (no APQN found), rm card and queue devs\\n\",\n\t\t\t\t    __func__, ap);\n\t\t\tap_scan_rm_card_dev_and_queue_devs(ac);\n\t\t\tput_device(dev);\n\t\t} else {\n\t\t\tAP_DBF_DBG(\"%s(%d) no type info (no APQN found), ignored\\n\",\n\t\t\t\t   __func__, ap);\n\t\t}\n\t\treturn;\n\t}\n\tif (!type) {\n\t\t \n\t\tif (ac) {\n\t\t\tAP_DBF_INFO(\"%s(%d) no valid type (0) info, rm card and queue devs\\n\",\n\t\t\t\t    __func__, ap);\n\t\t\tap_scan_rm_card_dev_and_queue_devs(ac);\n\t\t\tput_device(dev);\n\t\t} else {\n\t\t\tAP_DBF_DBG(\"%s(%d) no valid type (0) info, ignored\\n\",\n\t\t\t\t   __func__, ap);\n\t\t}\n\t\treturn;\n\t}\n\tif (ac) {\n\t\t \n\t\tif (ac->raw_hwtype != type) {\n\t\t\tAP_DBF_INFO(\"%s(%d) hwtype %d changed, rm card and queue devs\\n\",\n\t\t\t\t    __func__, ap, type);\n\t\t\tap_scan_rm_card_dev_and_queue_devs(ac);\n\t\t\tput_device(dev);\n\t\t\tac = NULL;\n\t\t} else if ((ac->functions & TAPQ_CARD_FUNC_CMP_MASK) !=\n\t\t\t   (func & TAPQ_CARD_FUNC_CMP_MASK)) {\n\t\t\tAP_DBF_INFO(\"%s(%d) functions 0x%08x changed, rm card and queue devs\\n\",\n\t\t\t\t    __func__, ap, func);\n\t\t\tap_scan_rm_card_dev_and_queue_devs(ac);\n\t\t\tput_device(dev);\n\t\t\tac = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tif (chkstop && !ac->chkstop) {\n\t\t\t\t \n\t\t\t\tac->chkstop = true;\n\t\t\t\tAP_DBF_INFO(\"%s(%d) card dev checkstop on\\n\",\n\t\t\t\t\t    __func__, ap);\n\t\t\t} else if (!chkstop && ac->chkstop) {\n\t\t\t\t \n\t\t\t\tac->chkstop = false;\n\t\t\t\tAP_DBF_INFO(\"%s(%d) card dev checkstop off\\n\",\n\t\t\t\t\t    __func__, ap);\n\t\t\t}\n\t\t\t \n\t\t\tif (decfg && ac->config) {\n\t\t\t\tac->config = false;\n\t\t\t\tAP_DBF_INFO(\"%s(%d) card dev config off\\n\",\n\t\t\t\t\t    __func__, ap);\n\t\t\t\tap_send_config_uevent(&ac->ap_dev, ac->config);\n\t\t\t} else if (!decfg && !ac->config) {\n\t\t\t\tac->config = true;\n\t\t\t\tAP_DBF_INFO(\"%s(%d) card dev config on\\n\",\n\t\t\t\t\t    __func__, ap);\n\t\t\t\tap_send_config_uevent(&ac->ap_dev, ac->config);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ac) {\n\t\t \n\t\tcomp_type = ap_get_compatible_type(qid, type, func);\n\t\tif (!comp_type) {\n\t\t\tAP_DBF_WARN(\"%s(%d) type %d, can't get compatibility type\\n\",\n\t\t\t\t    __func__, ap, type);\n\t\t\treturn;\n\t\t}\n\t\tac = ap_card_create(ap, depth, type, comp_type, func, ml);\n\t\tif (!ac) {\n\t\t\tAP_DBF_WARN(\"%s(%d) ap_card_create() failed\\n\",\n\t\t\t\t    __func__, ap);\n\t\t\treturn;\n\t\t}\n\t\tac->config = !decfg;\n\t\tac->chkstop = chkstop;\n\t\tdev = &ac->ap_dev.device;\n\t\tdev->bus = &ap_bus_type;\n\t\tdev->parent = ap_root_device;\n\t\tdev_set_name(dev, \"card%02x\", ap);\n\t\t \n\t\tif (ac->maxmsgsize > atomic_read(&ap_max_msg_size)) {\n\t\t\tatomic_set(&ap_max_msg_size, ac->maxmsgsize);\n\t\t\tAP_DBF_INFO(\"%s(%d) ap_max_msg_size update to %d byte\\n\",\n\t\t\t\t    __func__, ap,\n\t\t\t\t    atomic_read(&ap_max_msg_size));\n\t\t}\n\t\t \n\t\trc = device_register(dev);\n\t\tif (rc) {\n\t\t\tAP_DBF_WARN(\"%s(%d) device_register() failed\\n\",\n\t\t\t\t    __func__, ap);\n\t\t\tput_device(dev);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tget_device(dev);\n\t\tif (decfg)\n\t\t\tAP_DBF_INFO(\"%s(%d) new (decfg) card dev type=%d func=0x%08x created\\n\",\n\t\t\t\t    __func__, ap, type, func);\n\t\telse if (chkstop)\n\t\t\tAP_DBF_INFO(\"%s(%d) new (chkstop) card dev type=%d func=0x%08x created\\n\",\n\t\t\t\t    __func__, ap, type, func);\n\t\telse\n\t\t\tAP_DBF_INFO(\"%s(%d) new card dev type=%d func=0x%08x created\\n\",\n\t\t\t\t    __func__, ap, type, func);\n\t}\n\n\t \n\tap_scan_domains(ac);\n\n\t \n\tput_device(&ac->ap_dev.device);\n}\n\n \nstatic bool ap_get_configuration(void)\n{\n\tif (!ap_qci_info)\t \n\t\treturn false;\n\n\tmemcpy(ap_qci_info_old, ap_qci_info, sizeof(*ap_qci_info));\n\tap_fetch_qci_info(ap_qci_info);\n\n\treturn memcmp(ap_qci_info, ap_qci_info_old,\n\t\t      sizeof(struct ap_config_info)) != 0;\n}\n\n \nstatic void ap_scan_bus(struct work_struct *unused)\n{\n\tint ap, config_changed = 0;\n\n\t \n\tconfig_changed = ap_get_configuration();\n\tif (config_changed)\n\t\tnotify_config_changed();\n\tap_select_domain();\n\n\tAP_DBF_DBG(\"%s running\\n\", __func__);\n\n\t \n\tfor (ap = 0; ap <= ap_max_adapter_id; ap++)\n\t\tap_scan_adapter(ap);\n\n\t \n\tif (config_changed)\n\t\tnotify_scan_complete();\n\n\t \n\tif (ap_domain_index >= 0) {\n\t\tstruct device *dev =\n\t\t\tbus_find_device(&ap_bus_type, NULL,\n\t\t\t\t\t(void *)(long)ap_domain_index,\n\t\t\t\t\t__match_queue_device_with_queue_id);\n\t\tif (dev)\n\t\t\tput_device(dev);\n\t\telse\n\t\t\tAP_DBF_INFO(\"%s no queue device with default domain %d available\\n\",\n\t\t\t\t    __func__, ap_domain_index);\n\t}\n\n\tif (atomic64_inc_return(&ap_scan_bus_count) == 1) {\n\t\tAP_DBF_DBG(\"%s init scan complete\\n\", __func__);\n\t\tap_send_init_scan_done_uevent();\n\t\tap_check_bindings_complete();\n\t}\n\n\tmod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);\n}\n\nstatic void ap_config_timeout(struct timer_list *unused)\n{\n\tqueue_work(system_long_wq, &ap_scan_work);\n}\n\nstatic int __init ap_debug_init(void)\n{\n\tap_dbf_info = debug_register(\"ap\", 2, 1,\n\t\t\t\t     DBF_MAX_SPRINTF_ARGS * sizeof(long));\n\tdebug_register_view(ap_dbf_info, &debug_sprintf_view);\n\tdebug_set_level(ap_dbf_info, DBF_ERR);\n\n\treturn 0;\n}\n\nstatic void __init ap_perms_init(void)\n{\n\t \n\tmemset(&ap_perms.ioctlm, 0xFF, sizeof(ap_perms.ioctlm));\n\tmemset(&ap_perms.apm, 0xFF, sizeof(ap_perms.apm));\n\tmemset(&ap_perms.aqm, 0xFF, sizeof(ap_perms.aqm));\n\n\t \n\tif (apm_str) {\n\t\tmemset(&ap_perms.apm, 0, sizeof(ap_perms.apm));\n\t\tap_parse_mask_str(apm_str, ap_perms.apm, AP_DEVICES,\n\t\t\t\t  &ap_perms_mutex);\n\t}\n\n\t \n\tif (aqm_str) {\n\t\tmemset(&ap_perms.aqm, 0, sizeof(ap_perms.aqm));\n\t\tap_parse_mask_str(aqm_str, ap_perms.aqm, AP_DOMAINS,\n\t\t\t\t  &ap_perms_mutex);\n\t}\n}\n\n \nstatic int __init ap_module_init(void)\n{\n\tint rc;\n\n\trc = ap_debug_init();\n\tif (rc)\n\t\treturn rc;\n\n\tif (!ap_instructions_available()) {\n\t\tpr_warn(\"The hardware system does not support AP instructions\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thash_init(ap_queues);\n\n\t \n\tap_perms_init();\n\n\t \n\tap_init_qci_info();\n\n\t \n\tif (ap_domain_index < -1 || ap_domain_index > ap_max_domain_id ||\n\t    (ap_domain_index >= 0 &&\n\t     !test_bit_inv(ap_domain_index, ap_perms.aqm))) {\n\t\tpr_warn(\"%d is not a valid cryptographic domain\\n\",\n\t\t\tap_domain_index);\n\t\tap_domain_index = -1;\n\t}\n\n\t \n\tif (ap_interrupts_available() && ap_useirq) {\n\t\trc = register_adapter_interrupt(&ap_airq);\n\t\tap_irq_flag = (rc == 0);\n\t}\n\n\t \n\trc = bus_register(&ap_bus_type);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tap_root_device = root_device_register(\"ap\");\n\trc = PTR_ERR_OR_ZERO(ap_root_device);\n\tif (rc)\n\t\tgoto out_bus;\n\tap_root_device->bus = &ap_bus_type;\n\n\t \n\ttimer_setup(&ap_config_timer, ap_config_timeout, 0);\n\n\t \n\tif (MACHINE_IS_VM)\n\t\tpoll_high_timeout = 1500000;\n\thrtimer_init(&ap_poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tap_poll_timer.function = ap_poll_timeout;\n\n\t \n\tif (ap_thread_flag) {\n\t\trc = ap_poll_thread_start();\n\t\tif (rc)\n\t\t\tgoto out_work;\n\t}\n\n\tqueue_work(system_long_wq, &ap_scan_work);\n\n\treturn 0;\n\nout_work:\n\thrtimer_cancel(&ap_poll_timer);\n\troot_device_unregister(ap_root_device);\nout_bus:\n\tbus_unregister(&ap_bus_type);\nout:\n\tif (ap_irq_flag)\n\t\tunregister_adapter_interrupt(&ap_airq);\n\tkfree(ap_qci_info);\n\treturn rc;\n}\ndevice_initcall(ap_module_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}