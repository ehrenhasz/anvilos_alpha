{
  "module_name": "zcrypt_queue.c",
  "hash_id": "c3380046340cb68ac2ad29ee648028cc34a3454410f6264c44a7e6dc1bfa5552",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/zcrypt_queue.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/hw_random.h>\n#include <linux/debugfs.h>\n#include <asm/debug.h>\n\n#include \"zcrypt_debug.h\"\n#include \"zcrypt_api.h\"\n\n#include \"zcrypt_msgtype6.h\"\n#include \"zcrypt_msgtype50.h\"\n\n \n\nstatic ssize_t online_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct zcrypt_queue *zq = dev_get_drvdata(dev);\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tint online = aq->config && zq->online ? 1 : 0;\n\n\treturn sysfs_emit(buf, \"%d\\n\", online);\n}\n\nstatic ssize_t online_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct zcrypt_queue *zq = dev_get_drvdata(dev);\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tstruct zcrypt_card *zc = zq->zcard;\n\tint online;\n\n\tif (sscanf(buf, \"%d\\n\", &online) != 1 || online < 0 || online > 1)\n\t\treturn -EINVAL;\n\n\tif (online && (!aq->config || !aq->card->config))\n\t\treturn -ENODEV;\n\tif (online && !zc->online)\n\t\treturn -EINVAL;\n\tzq->online = online;\n\n\tZCRYPT_DBF_INFO(\"%s queue=%02x.%04x online=%d\\n\",\n\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\tAP_QID_QUEUE(zq->queue->qid), online);\n\n\tap_send_online_uevent(&aq->ap_dev, online);\n\n\tif (!online)\n\t\tap_flush_queue(zq->queue);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(online);\n\nstatic ssize_t load_show(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct zcrypt_queue *zq = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", atomic_read(&zq->load));\n}\n\nstatic DEVICE_ATTR_RO(load);\n\nstatic struct attribute *zcrypt_queue_attrs[] = {\n\t&dev_attr_online.attr,\n\t&dev_attr_load.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group zcrypt_queue_attr_group = {\n\t.attrs = zcrypt_queue_attrs,\n};\n\nbool zcrypt_queue_force_online(struct zcrypt_queue *zq, int online)\n{\n\tif (!!zq->online != !!online) {\n\t\tzq->online = online;\n\t\tif (!online)\n\t\t\tap_flush_queue(zq->queue);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct zcrypt_queue *zcrypt_queue_alloc(size_t reply_buf_size)\n{\n\tstruct zcrypt_queue *zq;\n\n\tzq = kzalloc(sizeof(*zq), GFP_KERNEL);\n\tif (!zq)\n\t\treturn NULL;\n\tzq->reply.msg = kmalloc(reply_buf_size, GFP_KERNEL);\n\tif (!zq->reply.msg)\n\t\tgoto out_free;\n\tzq->reply.bufsize = reply_buf_size;\n\tINIT_LIST_HEAD(&zq->list);\n\tkref_init(&zq->refcount);\n\treturn zq;\n\nout_free:\n\tkfree(zq);\n\treturn NULL;\n}\nEXPORT_SYMBOL(zcrypt_queue_alloc);\n\nvoid zcrypt_queue_free(struct zcrypt_queue *zq)\n{\n\tkfree(zq->reply.msg);\n\tkfree(zq);\n}\nEXPORT_SYMBOL(zcrypt_queue_free);\n\nstatic void zcrypt_queue_release(struct kref *kref)\n{\n\tstruct zcrypt_queue *zq =\n\t\tcontainer_of(kref, struct zcrypt_queue, refcount);\n\tzcrypt_queue_free(zq);\n}\n\nvoid zcrypt_queue_get(struct zcrypt_queue *zq)\n{\n\tkref_get(&zq->refcount);\n}\nEXPORT_SYMBOL(zcrypt_queue_get);\n\nint zcrypt_queue_put(struct zcrypt_queue *zq)\n{\n\treturn kref_put(&zq->refcount, zcrypt_queue_release);\n}\nEXPORT_SYMBOL(zcrypt_queue_put);\n\n \nint zcrypt_queue_register(struct zcrypt_queue *zq)\n{\n\tstruct zcrypt_card *zc;\n\tint rc;\n\n\tspin_lock(&zcrypt_list_lock);\n\tzc = dev_get_drvdata(&zq->queue->card->ap_dev.device);\n\tzcrypt_card_get(zc);\n\tzq->zcard = zc;\n\tzq->online = 1;\t \n\n\tZCRYPT_DBF_INFO(\"%s queue=%02x.%04x register online=1\\n\",\n\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\tAP_QID_QUEUE(zq->queue->qid));\n\n\tlist_add_tail(&zq->list, &zc->zqueues);\n\tspin_unlock(&zcrypt_list_lock);\n\n\trc = sysfs_create_group(&zq->queue->ap_dev.device.kobj,\n\t\t\t\t&zcrypt_queue_attr_group);\n\tif (rc)\n\t\tgoto out;\n\n\tif (zq->ops->rng) {\n\t\trc = zcrypt_rng_device_add();\n\t\tif (rc)\n\t\t\tgoto out_unregister;\n\t}\n\treturn 0;\n\nout_unregister:\n\tsysfs_remove_group(&zq->queue->ap_dev.device.kobj,\n\t\t\t   &zcrypt_queue_attr_group);\nout:\n\tspin_lock(&zcrypt_list_lock);\n\tlist_del_init(&zq->list);\n\tspin_unlock(&zcrypt_list_lock);\n\tzcrypt_card_put(zc);\n\treturn rc;\n}\nEXPORT_SYMBOL(zcrypt_queue_register);\n\n \nvoid zcrypt_queue_unregister(struct zcrypt_queue *zq)\n{\n\tstruct zcrypt_card *zc;\n\n\tZCRYPT_DBF_INFO(\"%s queue=%02x.%04x unregister\\n\",\n\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\tAP_QID_QUEUE(zq->queue->qid));\n\n\tzc = zq->zcard;\n\tspin_lock(&zcrypt_list_lock);\n\tlist_del_init(&zq->list);\n\tspin_unlock(&zcrypt_list_lock);\n\tif (zq->ops->rng)\n\t\tzcrypt_rng_device_remove();\n\tsysfs_remove_group(&zq->queue->ap_dev.device.kobj,\n\t\t\t   &zcrypt_queue_attr_group);\n\tzcrypt_card_put(zc);\n\tzcrypt_queue_put(zq);\n}\nEXPORT_SYMBOL(zcrypt_queue_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}