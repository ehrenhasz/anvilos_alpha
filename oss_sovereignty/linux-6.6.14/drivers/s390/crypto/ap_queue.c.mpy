{
  "module_name": "ap_queue.c",
  "hash_id": "194538db68d0a2b7363a84e65fb9640ea7cc41d25e7e8a6aa394bd29e8e558e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/ap_queue.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"ap\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <asm/facility.h>\n\n#include \"ap_bus.h\"\n#include \"ap_debug.h\"\n\nstatic void __ap_flush_queue(struct ap_queue *aq);\n\n \n\nstatic inline bool ap_q_supports_bind(struct ap_queue *aq)\n{\n\treturn ap_test_bit(&aq->card->functions, AP_FUNC_EP11) ||\n\t\tap_test_bit(&aq->card->functions, AP_FUNC_ACCEL);\n}\n\nstatic inline bool ap_q_supports_assoc(struct ap_queue *aq)\n{\n\treturn ap_test_bit(&aq->card->functions, AP_FUNC_EP11);\n}\n\n \nstatic int ap_queue_enable_irq(struct ap_queue *aq, void *ind)\n{\n\tunion ap_qirq_ctrl qirqctrl = { .value = 0 };\n\tstruct ap_queue_status status;\n\n\tqirqctrl.ir = 1;\n\tqirqctrl.isc = AP_ISC;\n\tstatus = ap_aqic(aq->qid, qirqctrl, virt_to_phys(ind));\n\tif (status.async)\n\t\treturn -EPERM;\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\tcase AP_RESPONSE_OTHERWISE_CHANGED:\n\t\treturn 0;\n\tcase AP_RESPONSE_Q_NOT_AVAIL:\n\tcase AP_RESPONSE_DECONFIGURED:\n\tcase AP_RESPONSE_CHECKSTOPPED:\n\tcase AP_RESPONSE_INVALID_ADDRESS:\n\t\tpr_err(\"Registering adapter interrupts for AP device %02x.%04x failed\\n\",\n\t\t       AP_QID_CARD(aq->qid),\n\t\t       AP_QID_QUEUE(aq->qid));\n\t\treturn -EOPNOTSUPP;\n\tcase AP_RESPONSE_RESET_IN_PROGRESS:\n\tcase AP_RESPONSE_BUSY:\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n}\n\n \nstatic inline struct ap_queue_status\n__ap_send(ap_qid_t qid, unsigned long psmid, void *msg, size_t msglen,\n\t  int special)\n{\n\tif (special)\n\t\tqid |= 0x400000UL;\n\treturn ap_nqap(qid, psmid, msg, msglen);\n}\n\n \n\nstatic enum ap_sm_wait ap_sm_nop(struct ap_queue *aq)\n{\n\treturn AP_SM_WAIT_NONE;\n}\n\n \nstatic struct ap_queue_status ap_sm_recv(struct ap_queue *aq)\n{\n\tstruct ap_queue_status status;\n\tstruct ap_message *ap_msg;\n\tbool found = false;\n\tsize_t reslen;\n\tunsigned long resgr0 = 0;\n\tint parts = 0;\n\n\t \n\tdo {\n\t\tstatus = ap_dqap(aq->qid, &aq->reply->psmid,\n\t\t\t\t aq->reply->msg, aq->reply->bufsize,\n\t\t\t\t &aq->reply->len, &reslen, &resgr0);\n\t\tparts++;\n\t} while (status.response_code == 0xFF && resgr0 != 0);\n\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\t\taq->queue_count = max_t(int, 0, aq->queue_count - 1);\n\t\tif (!status.queue_empty && !aq->queue_count)\n\t\t\taq->queue_count++;\n\t\tif (aq->queue_count > 0)\n\t\t\tmod_timer(&aq->timeout,\n\t\t\t\t  jiffies + aq->request_timeout);\n\t\tlist_for_each_entry(ap_msg, &aq->pendingq, list) {\n\t\t\tif (ap_msg->psmid != aq->reply->psmid)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&ap_msg->list);\n\t\t\taq->pendingq_count--;\n\t\t\tif (parts > 1) {\n\t\t\t\tap_msg->rc = -EMSGSIZE;\n\t\t\t\tap_msg->receive(aq, ap_msg, NULL);\n\t\t\t} else {\n\t\t\t\tap_msg->receive(aq, ap_msg, aq->reply);\n\t\t\t}\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\tAP_DBF_WARN(\"%s unassociated reply psmid=0x%016lx on 0x%02x.%04x\\n\",\n\t\t\t\t    __func__, aq->reply->psmid,\n\t\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\t}\n\t\tfallthrough;\n\tcase AP_RESPONSE_NO_PENDING_REPLY:\n\t\tif (!status.queue_empty || aq->queue_count <= 0)\n\t\t\tbreak;\n\t\t \n\t\taq->queue_count = 0;\n\t\tlist_splice_init(&aq->pendingq, &aq->requestq);\n\t\taq->requestq_count += aq->pendingq_count;\n\t\taq->pendingq_count = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn status;\n}\n\n \nstatic enum ap_sm_wait ap_sm_read(struct ap_queue *aq)\n{\n\tstruct ap_queue_status status;\n\n\tif (!aq->reply)\n\t\treturn AP_SM_WAIT_NONE;\n\tstatus = ap_sm_recv(aq);\n\tif (status.async)\n\t\treturn AP_SM_WAIT_NONE;\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\t\tif (aq->queue_count > 0) {\n\t\t\taq->sm_state = AP_SM_STATE_WORKING;\n\t\t\treturn AP_SM_WAIT_AGAIN;\n\t\t}\n\t\taq->sm_state = AP_SM_STATE_IDLE;\n\t\treturn AP_SM_WAIT_NONE;\n\tcase AP_RESPONSE_NO_PENDING_REPLY:\n\t\tif (aq->queue_count > 0)\n\t\t\treturn aq->interrupt ?\n\t\t\t\tAP_SM_WAIT_INTERRUPT : AP_SM_WAIT_HIGH_TIMEOUT;\n\t\taq->sm_state = AP_SM_STATE_IDLE;\n\t\treturn AP_SM_WAIT_NONE;\n\tdefault:\n\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\taq->last_err_rc = status.response_code;\n\t\tAP_DBF_WARN(\"%s RC 0x%02x on 0x%02x.%04x -> AP_DEV_STATE_ERROR\\n\",\n\t\t\t    __func__, status.response_code,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn AP_SM_WAIT_NONE;\n\t}\n}\n\n \nstatic enum ap_sm_wait ap_sm_write(struct ap_queue *aq)\n{\n\tstruct ap_queue_status status;\n\tstruct ap_message *ap_msg;\n\tap_qid_t qid = aq->qid;\n\n\tif (aq->requestq_count <= 0)\n\t\treturn AP_SM_WAIT_NONE;\n\n\t \n\tap_msg = list_entry(aq->requestq.next, struct ap_message, list);\n\tstatus = __ap_send(qid, ap_msg->psmid,\n\t\t\t   ap_msg->msg, ap_msg->len,\n\t\t\t   ap_msg->flags & AP_MSG_FLAG_SPECIAL);\n\tif (status.async)\n\t\treturn AP_SM_WAIT_NONE;\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\t\taq->queue_count = max_t(int, 1, aq->queue_count + 1);\n\t\tif (aq->queue_count == 1)\n\t\t\tmod_timer(&aq->timeout, jiffies + aq->request_timeout);\n\t\tlist_move_tail(&ap_msg->list, &aq->pendingq);\n\t\taq->requestq_count--;\n\t\taq->pendingq_count++;\n\t\tif (aq->queue_count < aq->card->queue_depth) {\n\t\t\taq->sm_state = AP_SM_STATE_WORKING;\n\t\t\treturn AP_SM_WAIT_AGAIN;\n\t\t}\n\t\tfallthrough;\n\tcase AP_RESPONSE_Q_FULL:\n\t\taq->sm_state = AP_SM_STATE_QUEUE_FULL;\n\t\treturn aq->interrupt ?\n\t\t\tAP_SM_WAIT_INTERRUPT : AP_SM_WAIT_HIGH_TIMEOUT;\n\tcase AP_RESPONSE_RESET_IN_PROGRESS:\n\t\taq->sm_state = AP_SM_STATE_RESET_WAIT;\n\t\treturn AP_SM_WAIT_LOW_TIMEOUT;\n\tcase AP_RESPONSE_INVALID_DOMAIN:\n\t\tAP_DBF_WARN(\"%s RESPONSE_INVALID_DOMAIN on NQAP\\n\", __func__);\n\t\tfallthrough;\n\tcase AP_RESPONSE_MESSAGE_TOO_BIG:\n\tcase AP_RESPONSE_REQ_FAC_NOT_INST:\n\t\tlist_del_init(&ap_msg->list);\n\t\taq->requestq_count--;\n\t\tap_msg->rc = -EINVAL;\n\t\tap_msg->receive(aq, ap_msg, NULL);\n\t\treturn AP_SM_WAIT_AGAIN;\n\tdefault:\n\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\taq->last_err_rc = status.response_code;\n\t\tAP_DBF_WARN(\"%s RC 0x%02x on 0x%02x.%04x -> AP_DEV_STATE_ERROR\\n\",\n\t\t\t    __func__, status.response_code,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn AP_SM_WAIT_NONE;\n\t}\n}\n\n \nstatic enum ap_sm_wait ap_sm_read_write(struct ap_queue *aq)\n{\n\treturn min(ap_sm_read(aq), ap_sm_write(aq));\n}\n\n \nstatic enum ap_sm_wait ap_sm_reset(struct ap_queue *aq)\n{\n\tstruct ap_queue_status status;\n\n\tstatus = ap_rapq(aq->qid, aq->rapq_fbit);\n\tif (status.async)\n\t\treturn AP_SM_WAIT_NONE;\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\tcase AP_RESPONSE_RESET_IN_PROGRESS:\n\t\taq->sm_state = AP_SM_STATE_RESET_WAIT;\n\t\taq->interrupt = false;\n\t\taq->rapq_fbit = 0;\n\t\treturn AP_SM_WAIT_LOW_TIMEOUT;\n\tdefault:\n\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\taq->last_err_rc = status.response_code;\n\t\tAP_DBF_WARN(\"%s RC 0x%02x on 0x%02x.%04x -> AP_DEV_STATE_ERROR\\n\",\n\t\t\t    __func__, status.response_code,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn AP_SM_WAIT_NONE;\n\t}\n}\n\n \nstatic enum ap_sm_wait ap_sm_reset_wait(struct ap_queue *aq)\n{\n\tstruct ap_queue_status status;\n\tvoid *lsi_ptr;\n\n\tif (aq->queue_count > 0 && aq->reply)\n\t\t \n\t\tstatus = ap_sm_recv(aq);\n\telse\n\t\t \n\t\tstatus = ap_tapq(aq->qid, NULL);\n\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\t\tlsi_ptr = ap_airq_ptr();\n\t\tif (lsi_ptr && ap_queue_enable_irq(aq, lsi_ptr) == 0)\n\t\t\taq->sm_state = AP_SM_STATE_SETIRQ_WAIT;\n\t\telse\n\t\t\taq->sm_state = (aq->queue_count > 0) ?\n\t\t\t\tAP_SM_STATE_WORKING : AP_SM_STATE_IDLE;\n\t\treturn AP_SM_WAIT_AGAIN;\n\tcase AP_RESPONSE_BUSY:\n\tcase AP_RESPONSE_RESET_IN_PROGRESS:\n\t\treturn AP_SM_WAIT_LOW_TIMEOUT;\n\tcase AP_RESPONSE_Q_NOT_AVAIL:\n\tcase AP_RESPONSE_DECONFIGURED:\n\tcase AP_RESPONSE_CHECKSTOPPED:\n\tdefault:\n\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\taq->last_err_rc = status.response_code;\n\t\tAP_DBF_WARN(\"%s RC 0x%02x on 0x%02x.%04x -> AP_DEV_STATE_ERROR\\n\",\n\t\t\t    __func__, status.response_code,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn AP_SM_WAIT_NONE;\n\t}\n}\n\n \nstatic enum ap_sm_wait ap_sm_setirq_wait(struct ap_queue *aq)\n{\n\tstruct ap_queue_status status;\n\n\tif (aq->queue_count > 0 && aq->reply)\n\t\t \n\t\tstatus = ap_sm_recv(aq);\n\telse\n\t\t \n\t\tstatus = ap_tapq(aq->qid, NULL);\n\n\tif (status.irq_enabled == 1) {\n\t\t \n\t\taq->interrupt = true;\n\t\taq->sm_state = (aq->queue_count > 0) ?\n\t\t\tAP_SM_STATE_WORKING : AP_SM_STATE_IDLE;\n\t}\n\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\t\tif (aq->queue_count > 0)\n\t\t\treturn AP_SM_WAIT_AGAIN;\n\t\tfallthrough;\n\tcase AP_RESPONSE_NO_PENDING_REPLY:\n\t\treturn AP_SM_WAIT_LOW_TIMEOUT;\n\tdefault:\n\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\taq->last_err_rc = status.response_code;\n\t\tAP_DBF_WARN(\"%s RC 0x%02x on 0x%02x.%04x -> AP_DEV_STATE_ERROR\\n\",\n\t\t\t    __func__, status.response_code,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn AP_SM_WAIT_NONE;\n\t}\n}\n\n \nstatic enum ap_sm_wait ap_sm_assoc_wait(struct ap_queue *aq)\n{\n\tstruct ap_queue_status status;\n\tstruct ap_tapq_gr2 info;\n\n\tstatus = ap_test_queue(aq->qid, 1, &info);\n\t \n\tif (status.async && status.response_code) {\n\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\taq->last_err_rc = status.response_code;\n\t\tAP_DBF_WARN(\"%s asynch RC 0x%02x on 0x%02x.%04x -> AP_DEV_STATE_ERROR\\n\",\n\t\t\t    __func__, status.response_code,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn AP_SM_WAIT_NONE;\n\t}\n\tif (status.response_code > AP_RESPONSE_BUSY) {\n\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\taq->last_err_rc = status.response_code;\n\t\tAP_DBF_WARN(\"%s RC 0x%02x on 0x%02x.%04x -> AP_DEV_STATE_ERROR\\n\",\n\t\t\t    __func__, status.response_code,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn AP_SM_WAIT_NONE;\n\t}\n\n\t \n\tswitch (info.bs) {\n\tcase AP_BS_Q_USABLE:\n\t\t \n\t\taq->sm_state = AP_SM_STATE_IDLE;\n\t\tAP_DBF_DBG(\"%s queue 0x%02x.%04x associated with %u\\n\",\n\t\t\t   __func__, AP_QID_CARD(aq->qid),\n\t\t\t   AP_QID_QUEUE(aq->qid), aq->assoc_idx);\n\t\treturn AP_SM_WAIT_NONE;\n\tcase AP_BS_Q_USABLE_NO_SECURE_KEY:\n\t\t \n\t\treturn AP_SM_WAIT_LOW_TIMEOUT;\n\tdefault:\n\t\t \n\t\taq->assoc_idx = ASSOC_IDX_INVALID;\n\t\taq->dev_state = AP_DEV_STATE_ERROR;\n\t\taq->last_err_rc = status.response_code;\n\t\tAP_DBF_WARN(\"%s bs 0x%02x on 0x%02x.%04x -> AP_DEV_STATE_ERROR\\n\",\n\t\t\t    __func__, info.bs,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn AP_SM_WAIT_NONE;\n\t}\n}\n\n \nstatic ap_func_t *ap_jumptable[NR_AP_SM_STATES][NR_AP_SM_EVENTS] = {\n\t[AP_SM_STATE_RESET_START] = {\n\t\t[AP_SM_EVENT_POLL] = ap_sm_reset,\n\t\t[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,\n\t},\n\t[AP_SM_STATE_RESET_WAIT] = {\n\t\t[AP_SM_EVENT_POLL] = ap_sm_reset_wait,\n\t\t[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,\n\t},\n\t[AP_SM_STATE_SETIRQ_WAIT] = {\n\t\t[AP_SM_EVENT_POLL] = ap_sm_setirq_wait,\n\t\t[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,\n\t},\n\t[AP_SM_STATE_IDLE] = {\n\t\t[AP_SM_EVENT_POLL] = ap_sm_write,\n\t\t[AP_SM_EVENT_TIMEOUT] = ap_sm_nop,\n\t},\n\t[AP_SM_STATE_WORKING] = {\n\t\t[AP_SM_EVENT_POLL] = ap_sm_read_write,\n\t\t[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,\n\t},\n\t[AP_SM_STATE_QUEUE_FULL] = {\n\t\t[AP_SM_EVENT_POLL] = ap_sm_read,\n\t\t[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,\n\t},\n\t[AP_SM_STATE_ASSOC_WAIT] = {\n\t\t[AP_SM_EVENT_POLL] = ap_sm_assoc_wait,\n\t\t[AP_SM_EVENT_TIMEOUT] = ap_sm_reset,\n\t},\n};\n\nenum ap_sm_wait ap_sm_event(struct ap_queue *aq, enum ap_sm_event event)\n{\n\tif (aq->config && !aq->chkstop &&\n\t    aq->dev_state > AP_DEV_STATE_UNINITIATED)\n\t\treturn ap_jumptable[aq->sm_state][event](aq);\n\telse\n\t\treturn AP_SM_WAIT_NONE;\n}\n\nenum ap_sm_wait ap_sm_event_loop(struct ap_queue *aq, enum ap_sm_event event)\n{\n\tenum ap_sm_wait wait;\n\n\twhile ((wait = ap_sm_event(aq, event)) == AP_SM_WAIT_AGAIN)\n\t\t;\n\treturn wait;\n}\n\n \nstatic ssize_t request_count_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tbool valid = false;\n\tu64 req_cnt;\n\n\tspin_lock_bh(&aq->lock);\n\tif (aq->dev_state > AP_DEV_STATE_UNINITIATED) {\n\t\treq_cnt = aq->total_request_count;\n\t\tvalid = true;\n\t}\n\tspin_unlock_bh(&aq->lock);\n\n\tif (valid)\n\t\treturn sysfs_emit(buf, \"%llu\\n\", req_cnt);\n\telse\n\t\treturn sysfs_emit(buf, \"-\\n\");\n}\n\nstatic ssize_t request_count_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\n\tspin_lock_bh(&aq->lock);\n\taq->total_request_count = 0;\n\tspin_unlock_bh(&aq->lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(request_count);\n\nstatic ssize_t requestq_count_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tunsigned int reqq_cnt = 0;\n\n\tspin_lock_bh(&aq->lock);\n\tif (aq->dev_state > AP_DEV_STATE_UNINITIATED)\n\t\treqq_cnt = aq->requestq_count;\n\tspin_unlock_bh(&aq->lock);\n\treturn sysfs_emit(buf, \"%d\\n\", reqq_cnt);\n}\n\nstatic DEVICE_ATTR_RO(requestq_count);\n\nstatic ssize_t pendingq_count_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tunsigned int penq_cnt = 0;\n\n\tspin_lock_bh(&aq->lock);\n\tif (aq->dev_state > AP_DEV_STATE_UNINITIATED)\n\t\tpenq_cnt = aq->pendingq_count;\n\tspin_unlock_bh(&aq->lock);\n\treturn sysfs_emit(buf, \"%d\\n\", penq_cnt);\n}\n\nstatic DEVICE_ATTR_RO(pendingq_count);\n\nstatic ssize_t reset_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tint rc = 0;\n\n\tspin_lock_bh(&aq->lock);\n\tswitch (aq->sm_state) {\n\tcase AP_SM_STATE_RESET_START:\n\tcase AP_SM_STATE_RESET_WAIT:\n\t\trc = sysfs_emit(buf, \"Reset in progress.\\n\");\n\t\tbreak;\n\tcase AP_SM_STATE_WORKING:\n\tcase AP_SM_STATE_QUEUE_FULL:\n\t\trc = sysfs_emit(buf, \"Reset Timer armed.\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = sysfs_emit(buf, \"No Reset Timer set.\\n\");\n\t}\n\tspin_unlock_bh(&aq->lock);\n\treturn rc;\n}\n\nstatic ssize_t reset_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\n\tspin_lock_bh(&aq->lock);\n\t__ap_flush_queue(aq);\n\taq->sm_state = AP_SM_STATE_RESET_START;\n\tap_wait(ap_sm_event(aq, AP_SM_EVENT_POLL));\n\tspin_unlock_bh(&aq->lock);\n\n\tAP_DBF_INFO(\"%s reset queue=%02x.%04x triggered by user\\n\",\n\t\t    __func__, AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(reset);\n\nstatic ssize_t interrupt_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tint rc = 0;\n\n\tspin_lock_bh(&aq->lock);\n\tif (aq->sm_state == AP_SM_STATE_SETIRQ_WAIT)\n\t\trc = sysfs_emit(buf, \"Enable Interrupt pending.\\n\");\n\telse if (aq->interrupt)\n\t\trc = sysfs_emit(buf, \"Interrupts enabled.\\n\");\n\telse\n\t\trc = sysfs_emit(buf, \"Interrupts disabled.\\n\");\n\tspin_unlock_bh(&aq->lock);\n\treturn rc;\n}\n\nstatic DEVICE_ATTR_RO(interrupt);\n\nstatic ssize_t config_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tint rc;\n\n\tspin_lock_bh(&aq->lock);\n\trc = sysfs_emit(buf, \"%d\\n\", aq->config ? 1 : 0);\n\tspin_unlock_bh(&aq->lock);\n\treturn rc;\n}\n\nstatic DEVICE_ATTR_RO(config);\n\nstatic ssize_t chkstop_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tint rc;\n\n\tspin_lock_bh(&aq->lock);\n\trc = sysfs_emit(buf, \"%d\\n\", aq->chkstop ? 1 : 0);\n\tspin_unlock_bh(&aq->lock);\n\treturn rc;\n}\n\nstatic DEVICE_ATTR_RO(chkstop);\n\nstatic ssize_t ap_functions_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tstruct ap_queue_status status;\n\tstruct ap_tapq_gr2 info;\n\n\tstatus = ap_test_queue(aq->qid, 1, &info);\n\tif (status.response_code > AP_RESPONSE_BUSY) {\n\t\tAP_DBF_DBG(\"%s RC 0x%02x on tapq(0x%02x.%04x)\\n\",\n\t\t\t   __func__, status.response_code,\n\t\t\t   AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn -EIO;\n\t}\n\n\treturn sysfs_emit(buf, \"0x%08X\\n\", info.fac);\n}\n\nstatic DEVICE_ATTR_RO(ap_functions);\n\n#ifdef CONFIG_ZCRYPT_DEBUG\nstatic ssize_t states_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tint rc = 0;\n\n\tspin_lock_bh(&aq->lock);\n\t \n\tswitch (aq->dev_state) {\n\tcase AP_DEV_STATE_UNINITIATED:\n\t\trc = sysfs_emit(buf, \"UNINITIATED\\n\");\n\t\tbreak;\n\tcase AP_DEV_STATE_OPERATING:\n\t\trc = sysfs_emit(buf, \"OPERATING\");\n\t\tbreak;\n\tcase AP_DEV_STATE_SHUTDOWN:\n\t\trc = sysfs_emit(buf, \"SHUTDOWN\");\n\t\tbreak;\n\tcase AP_DEV_STATE_ERROR:\n\t\trc = sysfs_emit(buf, \"ERROR\");\n\t\tbreak;\n\tdefault:\n\t\trc = sysfs_emit(buf, \"UNKNOWN\");\n\t}\n\t \n\tif (aq->dev_state) {\n\t\tswitch (aq->sm_state) {\n\t\tcase AP_SM_STATE_RESET_START:\n\t\t\trc += sysfs_emit_at(buf, rc, \" [RESET_START]\\n\");\n\t\t\tbreak;\n\t\tcase AP_SM_STATE_RESET_WAIT:\n\t\t\trc += sysfs_emit_at(buf, rc, \" [RESET_WAIT]\\n\");\n\t\t\tbreak;\n\t\tcase AP_SM_STATE_SETIRQ_WAIT:\n\t\t\trc += sysfs_emit_at(buf, rc, \" [SETIRQ_WAIT]\\n\");\n\t\t\tbreak;\n\t\tcase AP_SM_STATE_IDLE:\n\t\t\trc += sysfs_emit_at(buf, rc, \" [IDLE]\\n\");\n\t\t\tbreak;\n\t\tcase AP_SM_STATE_WORKING:\n\t\t\trc += sysfs_emit_at(buf, rc, \" [WORKING]\\n\");\n\t\t\tbreak;\n\t\tcase AP_SM_STATE_QUEUE_FULL:\n\t\t\trc += sysfs_emit_at(buf, rc, \" [FULL]\\n\");\n\t\t\tbreak;\n\t\tcase AP_SM_STATE_ASSOC_WAIT:\n\t\t\trc += sysfs_emit_at(buf, rc, \" [ASSOC_WAIT]\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc += sysfs_emit_at(buf, rc, \" [UNKNOWN]\\n\");\n\t\t}\n\t}\n\tspin_unlock_bh(&aq->lock);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(states);\n\nstatic ssize_t last_err_rc_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tint rc;\n\n\tspin_lock_bh(&aq->lock);\n\trc = aq->last_err_rc;\n\tspin_unlock_bh(&aq->lock);\n\n\tswitch (rc) {\n\tcase AP_RESPONSE_NORMAL:\n\t\treturn sysfs_emit(buf, \"NORMAL\\n\");\n\tcase AP_RESPONSE_Q_NOT_AVAIL:\n\t\treturn sysfs_emit(buf, \"Q_NOT_AVAIL\\n\");\n\tcase AP_RESPONSE_RESET_IN_PROGRESS:\n\t\treturn sysfs_emit(buf, \"RESET_IN_PROGRESS\\n\");\n\tcase AP_RESPONSE_DECONFIGURED:\n\t\treturn sysfs_emit(buf, \"DECONFIGURED\\n\");\n\tcase AP_RESPONSE_CHECKSTOPPED:\n\t\treturn sysfs_emit(buf, \"CHECKSTOPPED\\n\");\n\tcase AP_RESPONSE_BUSY:\n\t\treturn sysfs_emit(buf, \"BUSY\\n\");\n\tcase AP_RESPONSE_INVALID_ADDRESS:\n\t\treturn sysfs_emit(buf, \"INVALID_ADDRESS\\n\");\n\tcase AP_RESPONSE_OTHERWISE_CHANGED:\n\t\treturn sysfs_emit(buf, \"OTHERWISE_CHANGED\\n\");\n\tcase AP_RESPONSE_Q_FULL:\n\t\treturn sysfs_emit(buf, \"Q_FULL/NO_PENDING_REPLY\\n\");\n\tcase AP_RESPONSE_INDEX_TOO_BIG:\n\t\treturn sysfs_emit(buf, \"INDEX_TOO_BIG\\n\");\n\tcase AP_RESPONSE_NO_FIRST_PART:\n\t\treturn sysfs_emit(buf, \"NO_FIRST_PART\\n\");\n\tcase AP_RESPONSE_MESSAGE_TOO_BIG:\n\t\treturn sysfs_emit(buf, \"MESSAGE_TOO_BIG\\n\");\n\tcase AP_RESPONSE_REQ_FAC_NOT_INST:\n\t\treturn sysfs_emit(buf, \"REQ_FAC_NOT_INST\\n\");\n\tdefault:\n\t\treturn sysfs_emit(buf, \"response code %d\\n\", rc);\n\t}\n}\nstatic DEVICE_ATTR_RO(last_err_rc);\n#endif\n\nstatic struct attribute *ap_queue_dev_attrs[] = {\n\t&dev_attr_request_count.attr,\n\t&dev_attr_requestq_count.attr,\n\t&dev_attr_pendingq_count.attr,\n\t&dev_attr_reset.attr,\n\t&dev_attr_interrupt.attr,\n\t&dev_attr_config.attr,\n\t&dev_attr_chkstop.attr,\n\t&dev_attr_ap_functions.attr,\n#ifdef CONFIG_ZCRYPT_DEBUG\n\t&dev_attr_states.attr,\n\t&dev_attr_last_err_rc.attr,\n#endif\n\tNULL\n};\n\nstatic struct attribute_group ap_queue_dev_attr_group = {\n\t.attrs = ap_queue_dev_attrs\n};\n\nstatic const struct attribute_group *ap_queue_dev_attr_groups[] = {\n\t&ap_queue_dev_attr_group,\n\tNULL\n};\n\nstatic struct device_type ap_queue_type = {\n\t.name = \"ap_queue\",\n\t.groups = ap_queue_dev_attr_groups,\n};\n\nstatic ssize_t se_bind_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tstruct ap_queue_status status;\n\tstruct ap_tapq_gr2 info;\n\n\tif (!ap_q_supports_bind(aq))\n\t\treturn sysfs_emit(buf, \"-\\n\");\n\n\tstatus = ap_test_queue(aq->qid, 1, &info);\n\tif (status.response_code > AP_RESPONSE_BUSY) {\n\t\tAP_DBF_DBG(\"%s RC 0x%02x on tapq(0x%02x.%04x)\\n\",\n\t\t\t   __func__, status.response_code,\n\t\t\t   AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn -EIO;\n\t}\n\tswitch (info.bs) {\n\tcase AP_BS_Q_USABLE:\n\tcase AP_BS_Q_USABLE_NO_SECURE_KEY:\n\t\treturn sysfs_emit(buf, \"bound\\n\");\n\tdefault:\n\t\treturn sysfs_emit(buf, \"unbound\\n\");\n\t}\n}\n\nstatic ssize_t se_bind_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tstruct ap_queue_status status;\n\tbool value;\n\tint rc;\n\n\tif (!ap_q_supports_bind(aq))\n\t\treturn -EINVAL;\n\n\t \n\trc = kstrtobool(buf, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tif (value) {\n\t\t \n\t\tspin_lock_bh(&aq->lock);\n\t\tif (aq->sm_state < AP_SM_STATE_IDLE) {\n\t\t\tspin_unlock_bh(&aq->lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tstatus = ap_bapq(aq->qid);\n\t\tspin_unlock_bh(&aq->lock);\n\t\tif (status.response_code) {\n\t\t\tAP_DBF_WARN(\"%s RC 0x%02x on bapq(0x%02x.%04x)\\n\",\n\t\t\t\t    __func__, status.response_code,\n\t\t\t\t    AP_QID_CARD(aq->qid),\n\t\t\t\t    AP_QID_QUEUE(aq->qid));\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t \n\t\tspin_lock_bh(&aq->lock);\n\t\t__ap_flush_queue(aq);\n\t\taq->rapq_fbit = 1;\n\t\taq->assoc_idx = ASSOC_IDX_INVALID;\n\t\taq->sm_state = AP_SM_STATE_RESET_START;\n\t\tap_wait(ap_sm_event(aq, AP_SM_EVENT_POLL));\n\t\tspin_unlock_bh(&aq->lock);\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(se_bind);\n\nstatic ssize_t se_associate_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tstruct ap_queue_status status;\n\tstruct ap_tapq_gr2 info;\n\n\tif (!ap_q_supports_assoc(aq))\n\t\treturn sysfs_emit(buf, \"-\\n\");\n\n\tstatus = ap_test_queue(aq->qid, 1, &info);\n\tif (status.response_code > AP_RESPONSE_BUSY) {\n\t\tAP_DBF_DBG(\"%s RC 0x%02x on tapq(0x%02x.%04x)\\n\",\n\t\t\t   __func__, status.response_code,\n\t\t\t   AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn -EIO;\n\t}\n\n\tswitch (info.bs) {\n\tcase AP_BS_Q_USABLE:\n\t\tif (aq->assoc_idx == ASSOC_IDX_INVALID) {\n\t\t\tAP_DBF_WARN(\"%s AP_BS_Q_USABLE but invalid assoc_idx\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn sysfs_emit(buf, \"associated %u\\n\", aq->assoc_idx);\n\tcase AP_BS_Q_USABLE_NO_SECURE_KEY:\n\t\tif (aq->assoc_idx != ASSOC_IDX_INVALID)\n\t\t\treturn sysfs_emit(buf, \"association pending\\n\");\n\t\tfallthrough;\n\tdefault:\n\t\treturn sysfs_emit(buf, \"unassociated\\n\");\n\t}\n}\n\nstatic ssize_t se_associate_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\tstruct ap_queue_status status;\n\tunsigned int value;\n\tint rc;\n\n\tif (!ap_q_supports_assoc(aq))\n\t\treturn -EINVAL;\n\n\t \n\trc = kstrtouint(buf, 0, &value);\n\tif (rc)\n\t\treturn rc;\n\tif (value >= ASSOC_IDX_INVALID)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&aq->lock);\n\n\t \n\tif (aq->sm_state != AP_SM_STATE_IDLE) {\n\t\tspin_unlock_bh(&aq->lock);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (aq->assoc_idx != ASSOC_IDX_INVALID) {\n\t\tspin_unlock_bh(&aq->lock);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstatus = ap_aapq(aq->qid, value);\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\tcase AP_RESPONSE_STATE_CHANGE_IN_PROGRESS:\n\t\taq->sm_state = AP_SM_STATE_ASSOC_WAIT;\n\t\taq->assoc_idx = value;\n\t\tap_wait(ap_sm_event(aq, AP_SM_EVENT_POLL));\n\t\tspin_unlock_bh(&aq->lock);\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock_bh(&aq->lock);\n\t\tAP_DBF_WARN(\"%s RC 0x%02x on aapq(0x%02x.%04x)\\n\",\n\t\t\t    __func__, status.response_code,\n\t\t\t    AP_QID_CARD(aq->qid), AP_QID_QUEUE(aq->qid));\n\t\treturn -EIO;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(se_associate);\n\nstatic struct attribute *ap_queue_dev_sb_attrs[] = {\n\t&dev_attr_se_bind.attr,\n\t&dev_attr_se_associate.attr,\n\tNULL\n};\n\nstatic struct attribute_group ap_queue_dev_sb_attr_group = {\n\t.attrs = ap_queue_dev_sb_attrs\n};\n\nstatic const struct attribute_group *ap_queue_dev_sb_attr_groups[] = {\n\t&ap_queue_dev_sb_attr_group,\n\tNULL\n};\n\nstatic void ap_queue_device_release(struct device *dev)\n{\n\tstruct ap_queue *aq = to_ap_queue(dev);\n\n\tspin_lock_bh(&ap_queues_lock);\n\thash_del(&aq->hnode);\n\tspin_unlock_bh(&ap_queues_lock);\n\n\tkfree(aq);\n}\n\nstruct ap_queue *ap_queue_create(ap_qid_t qid, int device_type)\n{\n\tstruct ap_queue *aq;\n\n\taq = kzalloc(sizeof(*aq), GFP_KERNEL);\n\tif (!aq)\n\t\treturn NULL;\n\taq->ap_dev.device.release = ap_queue_device_release;\n\taq->ap_dev.device.type = &ap_queue_type;\n\taq->ap_dev.device_type = device_type;\n\t \n\tif (ap_sb_available() && is_prot_virt_guest())\n\t\taq->ap_dev.device.groups = ap_queue_dev_sb_attr_groups;\n\taq->qid = qid;\n\taq->interrupt = false;\n\tspin_lock_init(&aq->lock);\n\tINIT_LIST_HEAD(&aq->pendingq);\n\tINIT_LIST_HEAD(&aq->requestq);\n\ttimer_setup(&aq->timeout, ap_request_timeout, 0);\n\n\treturn aq;\n}\n\nvoid ap_queue_init_reply(struct ap_queue *aq, struct ap_message *reply)\n{\n\taq->reply = reply;\n\n\tspin_lock_bh(&aq->lock);\n\tap_wait(ap_sm_event(aq, AP_SM_EVENT_POLL));\n\tspin_unlock_bh(&aq->lock);\n}\nEXPORT_SYMBOL(ap_queue_init_reply);\n\n \nint ap_queue_message(struct ap_queue *aq, struct ap_message *ap_msg)\n{\n\tint rc = 0;\n\n\t \n\tBUG_ON(!ap_msg->receive);\n\n\tspin_lock_bh(&aq->lock);\n\n\t \n\tif (aq->dev_state == AP_DEV_STATE_OPERATING) {\n\t\tlist_add_tail(&ap_msg->list, &aq->requestq);\n\t\taq->requestq_count++;\n\t\taq->total_request_count++;\n\t\tatomic64_inc(&aq->card->total_request_count);\n\t} else {\n\t\trc = -ENODEV;\n\t}\n\n\t \n\tap_wait(ap_sm_event_loop(aq, AP_SM_EVENT_POLL));\n\n\tspin_unlock_bh(&aq->lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(ap_queue_message);\n\n \nvoid ap_cancel_message(struct ap_queue *aq, struct ap_message *ap_msg)\n{\n\tstruct ap_message *tmp;\n\n\tspin_lock_bh(&aq->lock);\n\tif (!list_empty(&ap_msg->list)) {\n\t\tlist_for_each_entry(tmp, &aq->pendingq, list)\n\t\t\tif (tmp->psmid == ap_msg->psmid) {\n\t\t\t\taq->pendingq_count--;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\taq->requestq_count--;\nfound:\n\t\tlist_del_init(&ap_msg->list);\n\t}\n\tspin_unlock_bh(&aq->lock);\n}\nEXPORT_SYMBOL(ap_cancel_message);\n\n \nstatic void __ap_flush_queue(struct ap_queue *aq)\n{\n\tstruct ap_message *ap_msg, *next;\n\n\tlist_for_each_entry_safe(ap_msg, next, &aq->pendingq, list) {\n\t\tlist_del_init(&ap_msg->list);\n\t\taq->pendingq_count--;\n\t\tap_msg->rc = -EAGAIN;\n\t\tap_msg->receive(aq, ap_msg, NULL);\n\t}\n\tlist_for_each_entry_safe(ap_msg, next, &aq->requestq, list) {\n\t\tlist_del_init(&ap_msg->list);\n\t\taq->requestq_count--;\n\t\tap_msg->rc = -EAGAIN;\n\t\tap_msg->receive(aq, ap_msg, NULL);\n\t}\n\taq->queue_count = 0;\n}\n\nvoid ap_flush_queue(struct ap_queue *aq)\n{\n\tspin_lock_bh(&aq->lock);\n\t__ap_flush_queue(aq);\n\tspin_unlock_bh(&aq->lock);\n}\nEXPORT_SYMBOL(ap_flush_queue);\n\nvoid ap_queue_prepare_remove(struct ap_queue *aq)\n{\n\tspin_lock_bh(&aq->lock);\n\t \n\t__ap_flush_queue(aq);\n\t \n\taq->dev_state = AP_DEV_STATE_SHUTDOWN;\n\tspin_unlock_bh(&aq->lock);\n\tdel_timer_sync(&aq->timeout);\n}\n\nvoid ap_queue_remove(struct ap_queue *aq)\n{\n\t \n\tspin_lock_bh(&aq->lock);\n\tap_zapq(aq->qid, 0);\n\taq->dev_state = AP_DEV_STATE_UNINITIATED;\n\tspin_unlock_bh(&aq->lock);\n}\n\nvoid _ap_queue_init_state(struct ap_queue *aq)\n{\n\taq->dev_state = AP_DEV_STATE_OPERATING;\n\taq->sm_state = AP_SM_STATE_RESET_START;\n\taq->last_err_rc = 0;\n\taq->assoc_idx = ASSOC_IDX_INVALID;\n\tap_wait(ap_sm_event(aq, AP_SM_EVENT_POLL));\n}\n\nvoid ap_queue_init_state(struct ap_queue *aq)\n{\n\tspin_lock_bh(&aq->lock);\n\t_ap_queue_init_state(aq);\n\tspin_unlock_bh(&aq->lock);\n}\nEXPORT_SYMBOL(ap_queue_init_state);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}