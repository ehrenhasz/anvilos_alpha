{
  "module_name": "pkey_api.c",
  "hash_id": "6ae16f60705e99e78361fe0ef22d52c935f5854c2f5fc1220efb10830e36a1fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/pkey_api.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"pkey\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/debugfs.h>\n#include <linux/random.h>\n#include <linux/cpufeature.h>\n#include <asm/zcrypt.h>\n#include <asm/cpacf.h>\n#include <asm/pkey.h>\n#include <crypto/aes.h>\n\n#include \"zcrypt_api.h\"\n#include \"zcrypt_ccamisc.h\"\n#include \"zcrypt_ep11misc.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"s390 protected key interface\");\n\n#define KEYBLOBBUFSIZE 8192\t \n#define MINKEYBLOBBUFSIZE (sizeof(struct keytoken_header))\n#define PROTKEYBLOBBUFSIZE 256\t \n#define MAXAPQNSINLIST 64\t \n#define AES_WK_VP_SIZE 32\t \n\n \n\nstatic debug_info_t *debug_info;\n\n#define DEBUG_DBG(...)\tdebug_sprintf_event(debug_info, 6, ##__VA_ARGS__)\n#define DEBUG_INFO(...) debug_sprintf_event(debug_info, 5, ##__VA_ARGS__)\n#define DEBUG_WARN(...) debug_sprintf_event(debug_info, 4, ##__VA_ARGS__)\n#define DEBUG_ERR(...)\tdebug_sprintf_event(debug_info, 3, ##__VA_ARGS__)\n\nstatic void __init pkey_debug_init(void)\n{\n\t \n\tdebug_info = debug_register(\"pkey\", 1, 1, 5 * sizeof(long));\n\tdebug_register_view(debug_info, &debug_sprintf_view);\n\tdebug_set_level(debug_info, 3);\n}\n\nstatic void __exit pkey_debug_exit(void)\n{\n\tdebug_unregister(debug_info);\n}\n\n \nstruct protaeskeytoken {\n\tu8  type;      \n\tu8  res0[3];\n\tu8  version;   \n\tu8  res1[3];\n\tu32 keytype;   \n\tu32 len;       \n\tu8  protkey[MAXPROTKEYSIZE];  \n} __packed;\n\n \nstruct clearkeytoken {\n\tu8  type;\t \n\tu8  res0[3];\n\tu8  version;\t \n\tu8  res1[3];\n\tu32 keytype;\t \n\tu32 len;\t \n\tu8  clearkey[];  \n} __packed;\n\n \nstatic inline u32 pkey_keytype_aes_to_size(u32 keytype)\n{\n\tswitch (keytype) {\n\tcase PKEY_KEYTYPE_AES_128:\n\t\treturn 16;\n\tcase PKEY_KEYTYPE_AES_192:\n\t\treturn 24;\n\tcase PKEY_KEYTYPE_AES_256:\n\t\treturn 32;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int pkey_clr2protkey(u32 keytype, const u8 *clrkey,\n\t\t\t    u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\t \n\tstatic cpacf_mask_t pckmo_functions;\n\n\tu8 paramblock[112];\n\tu32 pkeytype;\n\tint keysize;\n\tlong fc;\n\n\tswitch (keytype) {\n\tcase PKEY_KEYTYPE_AES_128:\n\t\t \n\t\tkeysize = 16;\n\t\tpkeytype = keytype;\n\t\tfc = CPACF_PCKMO_ENC_AES_128_KEY;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_AES_192:\n\t\t \n\t\tkeysize = 24;\n\t\tpkeytype = keytype;\n\t\tfc = CPACF_PCKMO_ENC_AES_192_KEY;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_AES_256:\n\t\t \n\t\tkeysize = 32;\n\t\tpkeytype = keytype;\n\t\tfc = CPACF_PCKMO_ENC_AES_256_KEY;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_P256:\n\t\t \n\t\tkeysize = 32;\n\t\tpkeytype = PKEY_KEYTYPE_ECC;\n\t\tfc = CPACF_PCKMO_ENC_ECC_P256_KEY;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_P384:\n\t\t \n\t\tkeysize = 48;\n\t\tpkeytype = PKEY_KEYTYPE_ECC;\n\t\tfc = CPACF_PCKMO_ENC_ECC_P384_KEY;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_P521:\n\t\t \n\t\tkeysize = 80;\n\t\tpkeytype = PKEY_KEYTYPE_ECC;\n\t\tfc = CPACF_PCKMO_ENC_ECC_P521_KEY;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_ED25519:\n\t\t \n\t\tkeysize = 32;\n\t\tpkeytype = PKEY_KEYTYPE_ECC;\n\t\tfc = CPACF_PCKMO_ENC_ECC_ED25519_KEY;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_ED448:\n\t\t \n\t\tkeysize = 64;\n\t\tpkeytype = PKEY_KEYTYPE_ECC;\n\t\tfc = CPACF_PCKMO_ENC_ECC_ED448_KEY;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported keytype %u\\n\",\n\t\t\t  __func__, keytype);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*protkeylen < keysize + AES_WK_VP_SIZE) {\n\t\tDEBUG_ERR(\"%s prot key buffer size too small: %u < %d\\n\",\n\t\t\t  __func__, *protkeylen, keysize + AES_WK_VP_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!pckmo_functions.bytes[0]) {\n\t\t \n\t\tif (!cpacf_query(CPACF_PCKMO, &pckmo_functions))\n\t\t\treturn -ENODEV;\n\t}\n\t \n\tif (!cpacf_test_func(&pckmo_functions, fc)) {\n\t\tDEBUG_ERR(\"%s pckmo functions not available\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmemset(paramblock, 0, sizeof(paramblock));\n\tmemcpy(paramblock, clrkey, keysize);\n\n\t \n\tcpacf_pckmo(fc, paramblock);\n\n\t \n\t*protkeylen = keysize + AES_WK_VP_SIZE;\n\tmemcpy(protkey, paramblock, *protkeylen);\n\t*protkeytype = pkeytype;\n\n\treturn 0;\n}\n\n \nstatic int pkey_skey2pkey(const u8 *key, u8 *protkey,\n\t\t\t  u32 *protkeylen, u32 *protkeytype)\n{\n\tstruct keytoken_header *hdr = (struct keytoken_header *)key;\n\tu16 cardnr, domain;\n\tint rc, verify;\n\n\tzcrypt_wait_api_operational();\n\n\t \n\tfor (verify = 0; verify < 3; verify++) {\n\t\trc = cca_findcard(key, &cardnr, &domain, verify);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\t\tif (rc > 0 && verify < 2)\n\t\t\tcontinue;\n\t\tswitch (hdr->version) {\n\t\tcase TOKVER_CCA_AES:\n\t\t\trc = cca_sec2protkey(cardnr, domain, key,\n\t\t\t\t\t     protkey, protkeylen, protkeytype);\n\t\t\tbreak;\n\t\tcase TOKVER_CCA_VLSC:\n\t\t\trc = cca_cipher2protkey(cardnr, domain, key,\n\t\t\t\t\t\tprotkey, protkeylen,\n\t\t\t\t\t\tprotkeytype);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tDEBUG_DBG(\"%s failed rc=%d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\n \nstatic int pkey_clr2ep11key(const u8 *clrkey, size_t clrkeylen,\n\t\t\t    u8 *keybuf, size_t *keybuflen)\n{\n\tu32 nr_apqns, *apqns = NULL;\n\tu16 card, dom;\n\tint i, rc;\n\n\tzcrypt_wait_api_operational();\n\n\t \n\trc = ep11_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t    ZCRYPT_CEX7,\n\t\t\t    ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4,\n\t\t\t    NULL);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tfor (rc = -ENODEV, i = 0; i < nr_apqns; i++) {\n\t\tcard = apqns[i] >> 16;\n\t\tdom = apqns[i] & 0xFFFF;\n\t\trc = ep11_clr2keyblob(card, dom, clrkeylen * 8,\n\t\t\t\t      0, clrkey, keybuf, keybuflen,\n\t\t\t\t      PKEY_TYPE_EP11);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\nout:\n\tkfree(apqns);\n\tif (rc)\n\t\tDEBUG_DBG(\"%s failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic int pkey_ep11key2pkey(const u8 *key, size_t keylen,\n\t\t\t     u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tu32 nr_apqns, *apqns = NULL;\n\tu16 card, dom;\n\tint i, rc;\n\n\tzcrypt_wait_api_operational();\n\n\t \n\trc = ep11_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t    ZCRYPT_CEX7,\n\t\t\t    ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4,\n\t\t\t    ep11_kb_wkvp(key, keylen));\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tfor (rc = -ENODEV, i = 0; i < nr_apqns; i++) {\n\t\tcard = apqns[i] >> 16;\n\t\tdom = apqns[i] & 0xFFFF;\n\t\trc = ep11_kblob2protkey(card, dom, key, keylen,\n\t\t\t\t\tprotkey, protkeylen, protkeytype);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\nout:\n\tkfree(apqns);\n\tif (rc)\n\t\tDEBUG_DBG(\"%s failed rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic int pkey_verifykey(const struct pkey_seckey *seckey,\n\t\t\t  u16 *pcardnr, u16 *pdomain,\n\t\t\t  u16 *pkeysize, u32 *pattributes)\n{\n\tstruct secaeskeytoken *t = (struct secaeskeytoken *)seckey;\n\tu16 cardnr, domain;\n\tint rc;\n\n\t \n\trc = cca_check_secaeskeytoken(debug_info, 3, (u8 *)seckey, 0);\n\tif (rc)\n\t\tgoto out;\n\tif (pattributes)\n\t\t*pattributes = PKEY_VERIFY_ATTR_AES;\n\tif (pkeysize)\n\t\t*pkeysize = t->bitsize;\n\n\t \n\trc = cca_findcard(seckey->seckey, &cardnr, &domain, 1);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (rc > 0) {\n\t\t \n\t\tDEBUG_DBG(\"%s secure key has old mkvp\\n\", __func__);\n\t\tif (pattributes)\n\t\t\t*pattributes |= PKEY_VERIFY_ATTR_OLD_MKVP;\n\t\trc = 0;\n\t}\n\n\tif (pcardnr)\n\t\t*pcardnr = cardnr;\n\tif (pdomain)\n\t\t*pdomain = domain;\n\nout:\n\tDEBUG_DBG(\"%s rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic int pkey_genprotkey(u32 keytype, u8 *protkey,\n\t\t\t   u32 *protkeylen, u32 *protkeytype)\n{\n\tu8 clrkey[32];\n\tint keysize;\n\tint rc;\n\n\tkeysize = pkey_keytype_aes_to_size(keytype);\n\tif (!keysize) {\n\t\tDEBUG_ERR(\"%s unknown/unsupported keytype %d\\n\", __func__,\n\t\t\t  keytype);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tget_random_bytes(clrkey, keysize);\n\n\t \n\trc = pkey_clr2protkey(keytype, clrkey,\n\t\t\t      protkey, protkeylen, protkeytype);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tget_random_bytes(protkey, keysize);\n\n\treturn 0;\n}\n\n \nstatic int pkey_verifyprotkey(const u8 *protkey, u32 protkeylen,\n\t\t\t      u32 protkeytype)\n{\n\tstruct {\n\t\tu8 iv[AES_BLOCK_SIZE];\n\t\tu8 key[MAXPROTKEYSIZE];\n\t} param;\n\tu8 null_msg[AES_BLOCK_SIZE];\n\tu8 dest_buf[AES_BLOCK_SIZE];\n\tunsigned int k, pkeylen;\n\tunsigned long fc;\n\n\tswitch (protkeytype) {\n\tcase PKEY_KEYTYPE_AES_128:\n\t\tpkeylen = 16 + AES_WK_VP_SIZE;\n\t\tfc = CPACF_KMC_PAES_128;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_AES_192:\n\t\tpkeylen = 24 + AES_WK_VP_SIZE;\n\t\tfc = CPACF_KMC_PAES_192;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_AES_256:\n\t\tpkeylen = 32 + AES_WK_VP_SIZE;\n\t\tfc = CPACF_KMC_PAES_256;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported keytype %u\\n\", __func__,\n\t\t\t  protkeytype);\n\t\treturn -EINVAL;\n\t}\n\tif (protkeylen != pkeylen) {\n\t\tDEBUG_ERR(\"%s invalid protected key size %u for keytype %u\\n\",\n\t\t\t  __func__, protkeylen, protkeytype);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(null_msg, 0, sizeof(null_msg));\n\n\tmemset(param.iv, 0, sizeof(param.iv));\n\tmemcpy(param.key, protkey, protkeylen);\n\n\tk = cpacf_kmc(fc | CPACF_ENCRYPT, &param, null_msg, dest_buf,\n\t\t      sizeof(null_msg));\n\tif (k != sizeof(null_msg)) {\n\t\tDEBUG_ERR(\"%s protected key is not valid\\n\", __func__);\n\t\treturn -EKEYREJECTED;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nonccatokaes2pkey(const struct clearkeytoken *t,\n\t\t\t     u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tsize_t tmpbuflen = max_t(size_t, SECKEYBLOBSIZE, MAXEP11AESKEYBLOBSIZE);\n\tu8 *tmpbuf = NULL;\n\tu32 keysize;\n\tint rc;\n\n\tkeysize = pkey_keytype_aes_to_size(t->keytype);\n\tif (!keysize) {\n\t\tDEBUG_ERR(\"%s unknown/unsupported keytype %u\\n\",\n\t\t\t  __func__, t->keytype);\n\t\treturn -EINVAL;\n\t}\n\tif (t->len != keysize) {\n\t\tDEBUG_ERR(\"%s non clear key aes token: invalid key len %u\\n\",\n\t\t\t  __func__, t->len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = pkey_clr2protkey(t->keytype, t->clearkey,\n\t\t\t      protkey, protkeylen, protkeytype);\n\tif (!rc)\n\t\tgoto out;\n\n\t \n\ttmpbuf = kmalloc(tmpbuflen, GFP_ATOMIC);\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\tzcrypt_wait_api_operational();\n\trc = cca_clr2seckey(0xFFFF, 0xFFFF, t->keytype, t->clearkey, tmpbuf);\n\tif (rc)\n\t\tgoto try_via_ep11;\n\trc = pkey_skey2pkey(tmpbuf,\n\t\t\t    protkey, protkeylen, protkeytype);\n\tif (!rc)\n\t\tgoto out;\n\ntry_via_ep11:\n\t \n\trc = pkey_clr2ep11key(t->clearkey, t->len,\n\t\t\t      tmpbuf, &tmpbuflen);\n\tif (rc)\n\t\tgoto failure;\n\trc = pkey_ep11key2pkey(tmpbuf, tmpbuflen,\n\t\t\t       protkey, protkeylen, protkeytype);\n\tif (!rc)\n\t\tgoto out;\n\nfailure:\n\tDEBUG_ERR(\"%s unable to build protected key from clear\", __func__);\n\nout:\n\tkfree(tmpbuf);\n\treturn rc;\n}\n\n \nstatic int nonccatokecc2pkey(const struct clearkeytoken *t,\n\t\t\t     u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tu32 keylen;\n\tint rc;\n\n\tswitch (t->keytype) {\n\tcase PKEY_KEYTYPE_ECC_P256:\n\t\tkeylen = 32;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_P384:\n\t\tkeylen = 48;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_P521:\n\t\tkeylen = 80;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_ED25519:\n\t\tkeylen = 32;\n\t\tbreak;\n\tcase PKEY_KEYTYPE_ECC_ED448:\n\t\tkeylen = 64;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported keytype %u\\n\",\n\t\t\t  __func__, t->keytype);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->len != keylen) {\n\t\tDEBUG_ERR(\"%s non clear key ecc token: invalid key len %u\\n\",\n\t\t\t  __func__, t->len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trc = pkey_clr2protkey(t->keytype, t->clearkey,\n\t\t\t      protkey, protkeylen, protkeytype);\n\tif (rc) {\n\t\tDEBUG_ERR(\"%s unable to build protected key from clear\",\n\t\t\t  __func__);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int pkey_nonccatok2pkey(const u8 *key, u32 keylen,\n\t\t\t       u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tstruct keytoken_header *hdr = (struct keytoken_header *)key;\n\tint rc = -EINVAL;\n\n\tswitch (hdr->version) {\n\tcase TOKVER_PROTECTED_KEY: {\n\t\tstruct protaeskeytoken *t;\n\n\t\tif (keylen != sizeof(struct protaeskeytoken))\n\t\t\tgoto out;\n\t\tt = (struct protaeskeytoken *)key;\n\t\trc = pkey_verifyprotkey(t->protkey, t->len, t->keytype);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tmemcpy(protkey, t->protkey, t->len);\n\t\t*protkeylen = t->len;\n\t\t*protkeytype = t->keytype;\n\t\tbreak;\n\t}\n\tcase TOKVER_CLEAR_KEY: {\n\t\tstruct clearkeytoken *t = (struct clearkeytoken *)key;\n\n\t\tif (keylen < sizeof(struct clearkeytoken) ||\n\t\t    keylen != sizeof(*t) + t->len)\n\t\t\tgoto out;\n\t\tswitch (t->keytype) {\n\t\tcase PKEY_KEYTYPE_AES_128:\n\t\tcase PKEY_KEYTYPE_AES_192:\n\t\tcase PKEY_KEYTYPE_AES_256:\n\t\t\trc = nonccatokaes2pkey(t, protkey,\n\t\t\t\t\t       protkeylen, protkeytype);\n\t\t\tbreak;\n\t\tcase PKEY_KEYTYPE_ECC_P256:\n\t\tcase PKEY_KEYTYPE_ECC_P384:\n\t\tcase PKEY_KEYTYPE_ECC_P521:\n\t\tcase PKEY_KEYTYPE_ECC_ED25519:\n\t\tcase PKEY_KEYTYPE_ECC_ED448:\n\t\t\trc = nonccatokecc2pkey(t, protkey,\n\t\t\t\t\t       protkeylen, protkeytype);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDEBUG_ERR(\"%s unknown/unsupported non cca clear key type %u\\n\",\n\t\t\t\t  __func__, t->keytype);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase TOKVER_EP11_AES: {\n\t\t \n\t\trc = ep11_check_aes_key(debug_info, 3, key, keylen, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\trc = pkey_ep11key2pkey(key, keylen,\n\t\t\t\t       protkey, protkeylen, protkeytype);\n\t\tbreak;\n\t}\n\tcase TOKVER_EP11_AES_WITH_HEADER:\n\t\t \n\t\trc = ep11_check_aes_key_with_hdr(debug_info, 3, key, keylen, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\trc = pkey_ep11key2pkey(key, keylen,\n\t\t\t\t       protkey, protkeylen, protkeytype);\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported non-CCA token version %d\\n\",\n\t\t\t  __func__, hdr->version);\n\t}\n\nout:\n\treturn rc;\n}\n\n \nstatic int pkey_ccainttok2pkey(const u8 *key, u32 keylen,\n\t\t\t       u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tstruct keytoken_header *hdr = (struct keytoken_header *)key;\n\n\tswitch (hdr->version) {\n\tcase TOKVER_CCA_AES:\n\t\tif (keylen != sizeof(struct secaeskeytoken))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase TOKVER_CCA_VLSC:\n\t\tif (keylen < hdr->len || keylen > MAXCCAVLSCTOKENSIZE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported CCA internal token version %d\\n\",\n\t\t\t  __func__, hdr->version);\n\t\treturn -EINVAL;\n\t}\n\n\treturn pkey_skey2pkey(key, protkey, protkeylen, protkeytype);\n}\n\n \nint pkey_keyblob2pkey(const u8 *key, u32 keylen,\n\t\t      u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tstruct keytoken_header *hdr = (struct keytoken_header *)key;\n\tint rc;\n\n\tif (keylen < sizeof(struct keytoken_header)) {\n\t\tDEBUG_ERR(\"%s invalid keylen %d\\n\", __func__, keylen);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (hdr->type) {\n\tcase TOKTYPE_NON_CCA:\n\t\trc = pkey_nonccatok2pkey(key, keylen,\n\t\t\t\t\t protkey, protkeylen, protkeytype);\n\t\tbreak;\n\tcase TOKTYPE_CCA_INTERNAL:\n\t\trc = pkey_ccainttok2pkey(key, keylen,\n\t\t\t\t\t protkey, protkeylen, protkeytype);\n\t\tbreak;\n\tdefault:\n\t\tDEBUG_ERR(\"%s unknown/unsupported blob type %d\\n\",\n\t\t\t  __func__, hdr->type);\n\t\treturn -EINVAL;\n\t}\n\n\tDEBUG_DBG(\"%s rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\nEXPORT_SYMBOL(pkey_keyblob2pkey);\n\nstatic int pkey_genseckey2(const struct pkey_apqn *apqns, size_t nr_apqns,\n\t\t\t   enum pkey_key_type ktype, enum pkey_key_size ksize,\n\t\t\t   u32 kflags, u8 *keybuf, size_t *keybufsize)\n{\n\tint i, card, dom, rc;\n\n\t \n\tif (!apqns || !nr_apqns)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (ktype) {\n\tcase PKEY_TYPE_CCA_DATA:\n\tcase PKEY_TYPE_CCA_CIPHER:\n\t\tif (*keybufsize < SECKEYBLOBSIZE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PKEY_TYPE_EP11:\n\t\tif (*keybufsize < MINEP11AESKEYBLOBSIZE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PKEY_TYPE_EP11_AES:\n\t\tif (*keybufsize < (sizeof(struct ep11kblob_header) +\n\t\t\t\t   MINEP11AESKEYBLOBSIZE))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (ksize) {\n\tcase PKEY_SIZE_AES_128:\n\tcase PKEY_SIZE_AES_192:\n\tcase PKEY_SIZE_AES_256:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0, rc = -ENODEV; i < nr_apqns; i++) {\n\t\tcard = apqns[i].card;\n\t\tdom = apqns[i].domain;\n\t\tif (ktype == PKEY_TYPE_EP11 ||\n\t\t    ktype == PKEY_TYPE_EP11_AES) {\n\t\t\trc = ep11_genaeskey(card, dom, ksize, kflags,\n\t\t\t\t\t    keybuf, keybufsize, ktype);\n\t\t} else if (ktype == PKEY_TYPE_CCA_DATA) {\n\t\t\trc = cca_genseckey(card, dom, ksize, keybuf);\n\t\t\t*keybufsize = (rc ? 0 : SECKEYBLOBSIZE);\n\t\t} else {\n\t\t\t \n\t\t\trc = cca_gencipherkey(card, dom, ksize, kflags,\n\t\t\t\t\t      keybuf, keybufsize);\n\t\t}\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int pkey_clr2seckey2(const struct pkey_apqn *apqns, size_t nr_apqns,\n\t\t\t    enum pkey_key_type ktype, enum pkey_key_size ksize,\n\t\t\t    u32 kflags, const u8 *clrkey,\n\t\t\t    u8 *keybuf, size_t *keybufsize)\n{\n\tint i, card, dom, rc;\n\n\t \n\tif (!apqns || !nr_apqns)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (ktype) {\n\tcase PKEY_TYPE_CCA_DATA:\n\tcase PKEY_TYPE_CCA_CIPHER:\n\t\tif (*keybufsize < SECKEYBLOBSIZE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PKEY_TYPE_EP11:\n\t\tif (*keybufsize < MINEP11AESKEYBLOBSIZE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PKEY_TYPE_EP11_AES:\n\t\tif (*keybufsize < (sizeof(struct ep11kblob_header) +\n\t\t\t\t   MINEP11AESKEYBLOBSIZE))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (ksize) {\n\tcase PKEY_SIZE_AES_128:\n\tcase PKEY_SIZE_AES_192:\n\tcase PKEY_SIZE_AES_256:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tzcrypt_wait_api_operational();\n\n\t \n\tfor (i = 0, rc = -ENODEV; i < nr_apqns; i++) {\n\t\tcard = apqns[i].card;\n\t\tdom = apqns[i].domain;\n\t\tif (ktype == PKEY_TYPE_EP11 ||\n\t\t    ktype == PKEY_TYPE_EP11_AES) {\n\t\t\trc = ep11_clr2keyblob(card, dom, ksize, kflags,\n\t\t\t\t\t      clrkey, keybuf, keybufsize,\n\t\t\t\t\t      ktype);\n\t\t} else if (ktype == PKEY_TYPE_CCA_DATA) {\n\t\t\trc = cca_clr2seckey(card, dom, ksize,\n\t\t\t\t\t    clrkey, keybuf);\n\t\t\t*keybufsize = (rc ? 0 : SECKEYBLOBSIZE);\n\t\t} else {\n\t\t\t \n\t\t\trc = cca_clr2cipherkey(card, dom, ksize, kflags,\n\t\t\t\t\t       clrkey, keybuf, keybufsize);\n\t\t}\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int pkey_verifykey2(const u8 *key, size_t keylen,\n\t\t\t   u16 *cardnr, u16 *domain,\n\t\t\t   enum pkey_key_type *ktype,\n\t\t\t   enum pkey_key_size *ksize, u32 *flags)\n{\n\tstruct keytoken_header *hdr = (struct keytoken_header *)key;\n\tu32 _nr_apqns, *_apqns = NULL;\n\tint rc;\n\n\tif (keylen < sizeof(struct keytoken_header))\n\t\treturn -EINVAL;\n\n\tif (hdr->type == TOKTYPE_CCA_INTERNAL &&\n\t    hdr->version == TOKVER_CCA_AES) {\n\t\tstruct secaeskeytoken *t = (struct secaeskeytoken *)key;\n\n\t\trc = cca_check_secaeskeytoken(debug_info, 3, key, 0);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tif (ktype)\n\t\t\t*ktype = PKEY_TYPE_CCA_DATA;\n\t\tif (ksize)\n\t\t\t*ksize = (enum pkey_key_size)t->bitsize;\n\n\t\trc = cca_findcard2(&_apqns, &_nr_apqns, *cardnr, *domain,\n\t\t\t\t   ZCRYPT_CEX3C, AES_MK_SET, t->mkvp, 0, 1);\n\t\tif (rc == 0 && flags)\n\t\t\t*flags = PKEY_FLAGS_MATCH_CUR_MKVP;\n\t\tif (rc == -ENODEV) {\n\t\t\trc = cca_findcard2(&_apqns, &_nr_apqns,\n\t\t\t\t\t   *cardnr, *domain,\n\t\t\t\t\t   ZCRYPT_CEX3C, AES_MK_SET,\n\t\t\t\t\t   0, t->mkvp, 1);\n\t\t\tif (rc == 0 && flags)\n\t\t\t\t*flags = PKEY_FLAGS_MATCH_ALT_MKVP;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\t*cardnr = ((struct pkey_apqn *)_apqns)->card;\n\t\t*domain = ((struct pkey_apqn *)_apqns)->domain;\n\n\t} else if (hdr->type == TOKTYPE_CCA_INTERNAL &&\n\t\t   hdr->version == TOKVER_CCA_VLSC) {\n\t\tstruct cipherkeytoken *t = (struct cipherkeytoken *)key;\n\n\t\trc = cca_check_secaescipherkey(debug_info, 3, key, 0, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tif (ktype)\n\t\t\t*ktype = PKEY_TYPE_CCA_CIPHER;\n\t\tif (ksize) {\n\t\t\t*ksize = PKEY_SIZE_UNKNOWN;\n\t\t\tif (!t->plfver && t->wpllen == 512)\n\t\t\t\t*ksize = PKEY_SIZE_AES_128;\n\t\t\telse if (!t->plfver && t->wpllen == 576)\n\t\t\t\t*ksize = PKEY_SIZE_AES_192;\n\t\t\telse if (!t->plfver && t->wpllen == 640)\n\t\t\t\t*ksize = PKEY_SIZE_AES_256;\n\t\t}\n\n\t\trc = cca_findcard2(&_apqns, &_nr_apqns, *cardnr, *domain,\n\t\t\t\t   ZCRYPT_CEX6, AES_MK_SET, t->mkvp0, 0, 1);\n\t\tif (rc == 0 && flags)\n\t\t\t*flags = PKEY_FLAGS_MATCH_CUR_MKVP;\n\t\tif (rc == -ENODEV) {\n\t\t\trc = cca_findcard2(&_apqns, &_nr_apqns,\n\t\t\t\t\t   *cardnr, *domain,\n\t\t\t\t\t   ZCRYPT_CEX6, AES_MK_SET,\n\t\t\t\t\t   0, t->mkvp0, 1);\n\t\t\tif (rc == 0 && flags)\n\t\t\t\t*flags = PKEY_FLAGS_MATCH_ALT_MKVP;\n\t\t}\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\t*cardnr = ((struct pkey_apqn *)_apqns)->card;\n\t\t*domain = ((struct pkey_apqn *)_apqns)->domain;\n\n\t} else if (hdr->type == TOKTYPE_NON_CCA &&\n\t\t   hdr->version == TOKVER_EP11_AES) {\n\t\tstruct ep11keyblob *kb = (struct ep11keyblob *)key;\n\t\tint api;\n\n\t\trc = ep11_check_aes_key(debug_info, 3, key, keylen, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tif (ktype)\n\t\t\t*ktype = PKEY_TYPE_EP11;\n\t\tif (ksize)\n\t\t\t*ksize = kb->head.bitlen;\n\n\t\tapi = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;\n\t\trc = ep11_findcard2(&_apqns, &_nr_apqns, *cardnr, *domain,\n\t\t\t\t    ZCRYPT_CEX7, api,\n\t\t\t\t    ep11_kb_wkvp(key, keylen));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif (flags)\n\t\t\t*flags = PKEY_FLAGS_MATCH_CUR_MKVP;\n\n\t\t*cardnr = ((struct pkey_apqn *)_apqns)->card;\n\t\t*domain = ((struct pkey_apqn *)_apqns)->domain;\n\n\t} else if (hdr->type == TOKTYPE_NON_CCA &&\n\t\t   hdr->version == TOKVER_EP11_AES_WITH_HEADER) {\n\t\tstruct ep11kblob_header *kh = (struct ep11kblob_header *)key;\n\t\tint api;\n\n\t\trc = ep11_check_aes_key_with_hdr(debug_info, 3,\n\t\t\t\t\t\t key, keylen, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tif (ktype)\n\t\t\t*ktype = PKEY_TYPE_EP11_AES;\n\t\tif (ksize)\n\t\t\t*ksize = kh->bitlen;\n\n\t\tapi = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;\n\t\trc = ep11_findcard2(&_apqns, &_nr_apqns, *cardnr, *domain,\n\t\t\t\t    ZCRYPT_CEX7, api,\n\t\t\t\t    ep11_kb_wkvp(key, keylen));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif (flags)\n\t\t\t*flags = PKEY_FLAGS_MATCH_CUR_MKVP;\n\n\t\t*cardnr = ((struct pkey_apqn *)_apqns)->card;\n\t\t*domain = ((struct pkey_apqn *)_apqns)->domain;\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\nout:\n\tkfree(_apqns);\n\treturn rc;\n}\n\nstatic int pkey_keyblob2pkey2(const struct pkey_apqn *apqns, size_t nr_apqns,\n\t\t\t      const u8 *key, size_t keylen,\n\t\t\t      u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tstruct keytoken_header *hdr = (struct keytoken_header *)key;\n\tint i, card, dom, rc;\n\n\t \n\tif (!apqns || !nr_apqns)\n\t\treturn -EINVAL;\n\n\tif (keylen < sizeof(struct keytoken_header))\n\t\treturn -EINVAL;\n\n\tif (hdr->type == TOKTYPE_CCA_INTERNAL) {\n\t\tif (hdr->version == TOKVER_CCA_AES) {\n\t\t\tif (keylen != sizeof(struct secaeskeytoken))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (cca_check_secaeskeytoken(debug_info, 3, key, 0))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (hdr->version == TOKVER_CCA_VLSC) {\n\t\t\tif (keylen < hdr->len || keylen > MAXCCAVLSCTOKENSIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (cca_check_secaescipherkey(debug_info, 3, key, 0, 1))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tDEBUG_ERR(\"%s unknown CCA internal token version %d\\n\",\n\t\t\t\t  __func__, hdr->version);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (hdr->type == TOKTYPE_NON_CCA) {\n\t\tif (hdr->version == TOKVER_EP11_AES) {\n\t\t\tif (ep11_check_aes_key(debug_info, 3, key, keylen, 1))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (hdr->version == TOKVER_EP11_AES_WITH_HEADER) {\n\t\t\tif (ep11_check_aes_key_with_hdr(debug_info, 3,\n\t\t\t\t\t\t\tkey, keylen, 1))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn pkey_nonccatok2pkey(key, keylen,\n\t\t\t\t\t\t   protkey, protkeylen,\n\t\t\t\t\t\t   protkeytype);\n\t\t}\n\t} else {\n\t\tDEBUG_ERR(\"%s unknown/unsupported blob type %d\\n\",\n\t\t\t  __func__, hdr->type);\n\t\treturn -EINVAL;\n\t}\n\n\tzcrypt_wait_api_operational();\n\n\t \n\tfor (i = 0, rc = -ENODEV; i < nr_apqns; i++) {\n\t\tcard = apqns[i].card;\n\t\tdom = apqns[i].domain;\n\t\tif (hdr->type == TOKTYPE_CCA_INTERNAL &&\n\t\t    hdr->version == TOKVER_CCA_AES) {\n\t\t\trc = cca_sec2protkey(card, dom, key,\n\t\t\t\t\t     protkey, protkeylen, protkeytype);\n\t\t} else if (hdr->type == TOKTYPE_CCA_INTERNAL &&\n\t\t\t   hdr->version == TOKVER_CCA_VLSC) {\n\t\t\trc = cca_cipher2protkey(card, dom, key,\n\t\t\t\t\t\tprotkey, protkeylen,\n\t\t\t\t\t\tprotkeytype);\n\t\t} else {\n\t\t\trc = ep11_kblob2protkey(card, dom, key, keylen,\n\t\t\t\t\t\tprotkey, protkeylen,\n\t\t\t\t\t\tprotkeytype);\n\t\t}\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int pkey_apqns4key(const u8 *key, size_t keylen, u32 flags,\n\t\t\t  struct pkey_apqn *apqns, size_t *nr_apqns)\n{\n\tstruct keytoken_header *hdr = (struct keytoken_header *)key;\n\tu32 _nr_apqns, *_apqns = NULL;\n\tint rc;\n\n\tif (keylen < sizeof(struct keytoken_header) || flags == 0)\n\t\treturn -EINVAL;\n\n\tzcrypt_wait_api_operational();\n\n\tif (hdr->type == TOKTYPE_NON_CCA &&\n\t    (hdr->version == TOKVER_EP11_AES_WITH_HEADER ||\n\t     hdr->version == TOKVER_EP11_ECC_WITH_HEADER) &&\n\t    is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {\n\t\tstruct ep11keyblob *kb = (struct ep11keyblob *)\n\t\t\t(key + sizeof(struct ep11kblob_header));\n\t\tint minhwtype = 0, api = 0;\n\n\t\tif (flags != PKEY_FLAGS_MATCH_CUR_MKVP)\n\t\t\treturn -EINVAL;\n\t\tif (kb->attr & EP11_BLOB_PKEY_EXTRACTABLE) {\n\t\t\tminhwtype = ZCRYPT_CEX7;\n\t\t\tapi = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;\n\t\t}\n\t\trc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t\t    minhwtype, api, kb->wkvp);\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else if (hdr->type == TOKTYPE_NON_CCA &&\n\t\t   hdr->version == TOKVER_EP11_AES &&\n\t\t   is_ep11_keyblob(key)) {\n\t\tstruct ep11keyblob *kb = (struct ep11keyblob *)key;\n\t\tint minhwtype = 0, api = 0;\n\n\t\tif (flags != PKEY_FLAGS_MATCH_CUR_MKVP)\n\t\t\treturn -EINVAL;\n\t\tif (kb->attr & EP11_BLOB_PKEY_EXTRACTABLE) {\n\t\t\tminhwtype = ZCRYPT_CEX7;\n\t\t\tapi = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;\n\t\t}\n\t\trc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t\t    minhwtype, api, kb->wkvp);\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else if (hdr->type == TOKTYPE_CCA_INTERNAL) {\n\t\tu64 cur_mkvp = 0, old_mkvp = 0;\n\t\tint minhwtype = ZCRYPT_CEX3C;\n\n\t\tif (hdr->version == TOKVER_CCA_AES) {\n\t\t\tstruct secaeskeytoken *t = (struct secaeskeytoken *)key;\n\n\t\t\tif (flags & PKEY_FLAGS_MATCH_CUR_MKVP)\n\t\t\t\tcur_mkvp = t->mkvp;\n\t\t\tif (flags & PKEY_FLAGS_MATCH_ALT_MKVP)\n\t\t\t\told_mkvp = t->mkvp;\n\t\t} else if (hdr->version == TOKVER_CCA_VLSC) {\n\t\t\tstruct cipherkeytoken *t = (struct cipherkeytoken *)key;\n\n\t\t\tminhwtype = ZCRYPT_CEX6;\n\t\t\tif (flags & PKEY_FLAGS_MATCH_CUR_MKVP)\n\t\t\t\tcur_mkvp = t->mkvp0;\n\t\t\tif (flags & PKEY_FLAGS_MATCH_ALT_MKVP)\n\t\t\t\told_mkvp = t->mkvp0;\n\t\t} else {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t\trc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t\t   minhwtype, AES_MK_SET,\n\t\t\t\t   cur_mkvp, old_mkvp, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else if (hdr->type == TOKTYPE_CCA_INTERNAL_PKA) {\n\t\tstruct eccprivkeytoken *t = (struct eccprivkeytoken *)key;\n\t\tu64 cur_mkvp = 0, old_mkvp = 0;\n\n\t\tif (t->secid == 0x20) {\n\t\t\tif (flags & PKEY_FLAGS_MATCH_CUR_MKVP)\n\t\t\t\tcur_mkvp = t->mkvp;\n\t\t\tif (flags & PKEY_FLAGS_MATCH_ALT_MKVP)\n\t\t\t\told_mkvp = t->mkvp;\n\t\t} else {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t\trc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t\t   ZCRYPT_CEX7, APKA_MK_SET,\n\t\t\t\t   cur_mkvp, old_mkvp, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (apqns) {\n\t\tif (*nr_apqns < _nr_apqns)\n\t\t\trc = -ENOSPC;\n\t\telse\n\t\t\tmemcpy(apqns, _apqns, _nr_apqns * sizeof(u32));\n\t}\n\t*nr_apqns = _nr_apqns;\n\nout:\n\tkfree(_apqns);\n\treturn rc;\n}\n\nstatic int pkey_apqns4keytype(enum pkey_key_type ktype,\n\t\t\t      u8 cur_mkvp[32], u8 alt_mkvp[32], u32 flags,\n\t\t\t      struct pkey_apqn *apqns, size_t *nr_apqns)\n{\n\tu32 _nr_apqns, *_apqns = NULL;\n\tint rc;\n\n\tzcrypt_wait_api_operational();\n\n\tif (ktype == PKEY_TYPE_CCA_DATA || ktype == PKEY_TYPE_CCA_CIPHER) {\n\t\tu64 cur_mkvp = 0, old_mkvp = 0;\n\t\tint minhwtype = ZCRYPT_CEX3C;\n\n\t\tif (flags & PKEY_FLAGS_MATCH_CUR_MKVP)\n\t\t\tcur_mkvp = *((u64 *)cur_mkvp);\n\t\tif (flags & PKEY_FLAGS_MATCH_ALT_MKVP)\n\t\t\told_mkvp = *((u64 *)alt_mkvp);\n\t\tif (ktype == PKEY_TYPE_CCA_CIPHER)\n\t\t\tminhwtype = ZCRYPT_CEX6;\n\t\trc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t\t   minhwtype, AES_MK_SET,\n\t\t\t\t   cur_mkvp, old_mkvp, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else if (ktype == PKEY_TYPE_CCA_ECC) {\n\t\tu64 cur_mkvp = 0, old_mkvp = 0;\n\n\t\tif (flags & PKEY_FLAGS_MATCH_CUR_MKVP)\n\t\t\tcur_mkvp = *((u64 *)cur_mkvp);\n\t\tif (flags & PKEY_FLAGS_MATCH_ALT_MKVP)\n\t\t\told_mkvp = *((u64 *)alt_mkvp);\n\t\trc = cca_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t\t   ZCRYPT_CEX7, APKA_MK_SET,\n\t\t\t\t   cur_mkvp, old_mkvp, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t} else if (ktype == PKEY_TYPE_EP11 ||\n\t\t   ktype == PKEY_TYPE_EP11_AES ||\n\t\t   ktype == PKEY_TYPE_EP11_ECC) {\n\t\tu8 *wkvp = NULL;\n\t\tint api;\n\n\t\tif (flags & PKEY_FLAGS_MATCH_CUR_MKVP)\n\t\t\twkvp = cur_mkvp;\n\t\tapi = ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4;\n\t\trc = ep11_findcard2(&_apqns, &_nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t\t    ZCRYPT_CEX7, api, wkvp);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (apqns) {\n\t\tif (*nr_apqns < _nr_apqns)\n\t\t\trc = -ENOSPC;\n\t\telse\n\t\t\tmemcpy(apqns, _apqns, _nr_apqns * sizeof(u32));\n\t}\n\t*nr_apqns = _nr_apqns;\n\nout:\n\tkfree(_apqns);\n\treturn rc;\n}\n\nstatic int pkey_keyblob2pkey3(const struct pkey_apqn *apqns, size_t nr_apqns,\n\t\t\t      const u8 *key, size_t keylen,\n\t\t\t      u8 *protkey, u32 *protkeylen, u32 *protkeytype)\n{\n\tstruct keytoken_header *hdr = (struct keytoken_header *)key;\n\tint i, card, dom, rc;\n\n\t \n\tif (!apqns || !nr_apqns)\n\t\treturn -EINVAL;\n\n\tif (keylen < sizeof(struct keytoken_header))\n\t\treturn -EINVAL;\n\n\tif (hdr->type == TOKTYPE_NON_CCA &&\n\t    hdr->version == TOKVER_EP11_AES_WITH_HEADER &&\n\t    is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {\n\t\t \n\t\tif (ep11_check_aes_key_with_hdr(debug_info, 3, key, keylen, 1))\n\t\t\treturn -EINVAL;\n\t} else if (hdr->type == TOKTYPE_NON_CCA &&\n\t\t   hdr->version == TOKVER_EP11_ECC_WITH_HEADER &&\n\t\t   is_ep11_keyblob(key + sizeof(struct ep11kblob_header))) {\n\t\t \n\t\tif (ep11_check_ecc_key_with_hdr(debug_info, 3, key, keylen, 1))\n\t\t\treturn -EINVAL;\n\t} else if (hdr->type == TOKTYPE_NON_CCA &&\n\t\t   hdr->version == TOKVER_EP11_AES &&\n\t\t   is_ep11_keyblob(key)) {\n\t\t \n\t\tif (ep11_check_aes_key(debug_info, 3, key, keylen, 1))\n\t\t\treturn -EINVAL;\n\t} else\tif (hdr->type == TOKTYPE_CCA_INTERNAL) {\n\t\tif (hdr->version == TOKVER_CCA_AES) {\n\t\t\t \n\t\t\tif (keylen != sizeof(struct secaeskeytoken))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (cca_check_secaeskeytoken(debug_info, 3, key, 0))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (hdr->version == TOKVER_CCA_VLSC) {\n\t\t\t \n\t\t\tif (keylen < hdr->len || keylen > MAXCCAVLSCTOKENSIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (cca_check_secaescipherkey(debug_info, 3, key, 0, 1))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tDEBUG_ERR(\"%s unknown CCA internal token version %d\\n\",\n\t\t\t\t  __func__, hdr->version);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (hdr->type == TOKTYPE_CCA_INTERNAL_PKA) {\n\t\t \n\t\tif (keylen < sizeof(struct eccprivkeytoken))\n\t\t\treturn -EINVAL;\n\t\tif (cca_check_sececckeytoken(debug_info, 3, key, keylen, 1))\n\t\t\treturn -EINVAL;\n\t} else if (hdr->type == TOKTYPE_NON_CCA) {\n\t\treturn pkey_nonccatok2pkey(key, keylen,\n\t\t\t\t\t   protkey, protkeylen, protkeytype);\n\t} else {\n\t\tDEBUG_ERR(\"%s unknown/unsupported blob type %d\\n\",\n\t\t\t  __func__, hdr->type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (rc = -ENODEV, i = 0; rc && i < nr_apqns; i++) {\n\t\tcard = apqns[i].card;\n\t\tdom = apqns[i].domain;\n\t\tif (hdr->type == TOKTYPE_NON_CCA &&\n\t\t    (hdr->version == TOKVER_EP11_AES_WITH_HEADER ||\n\t\t     hdr->version == TOKVER_EP11_ECC_WITH_HEADER) &&\n\t\t    is_ep11_keyblob(key + sizeof(struct ep11kblob_header)))\n\t\t\trc = ep11_kblob2protkey(card, dom, key, hdr->len,\n\t\t\t\t\t\tprotkey, protkeylen,\n\t\t\t\t\t\tprotkeytype);\n\t\telse if (hdr->type == TOKTYPE_NON_CCA &&\n\t\t\t hdr->version == TOKVER_EP11_AES &&\n\t\t\t is_ep11_keyblob(key))\n\t\t\trc = ep11_kblob2protkey(card, dom, key, hdr->len,\n\t\t\t\t\t\tprotkey, protkeylen,\n\t\t\t\t\t\tprotkeytype);\n\t\telse if (hdr->type == TOKTYPE_CCA_INTERNAL &&\n\t\t\t hdr->version == TOKVER_CCA_AES)\n\t\t\trc = cca_sec2protkey(card, dom, key, protkey,\n\t\t\t\t\t     protkeylen, protkeytype);\n\t\telse if (hdr->type == TOKTYPE_CCA_INTERNAL &&\n\t\t\t hdr->version == TOKVER_CCA_VLSC)\n\t\t\trc = cca_cipher2protkey(card, dom, key, protkey,\n\t\t\t\t\t\tprotkeylen, protkeytype);\n\t\telse if (hdr->type == TOKTYPE_CCA_INTERNAL_PKA)\n\t\t\trc = cca_ecc2protkey(card, dom, key, protkey,\n\t\t\t\t\t     protkeylen, protkeytype);\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn rc;\n}\n\n \n\nstatic void *_copy_key_from_user(void __user *ukey, size_t keylen)\n{\n\tif (!ukey || keylen < MINKEYBLOBBUFSIZE || keylen > KEYBLOBBUFSIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn memdup_user(ukey, keylen);\n}\n\nstatic void *_copy_apqns_from_user(void __user *uapqns, size_t nr_apqns)\n{\n\tif (!uapqns || nr_apqns == 0)\n\t\treturn NULL;\n\n\treturn memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));\n}\n\nstatic long pkey_unlocked_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tint rc;\n\n\tswitch (cmd) {\n\tcase PKEY_GENSECK: {\n\t\tstruct pkey_genseck __user *ugs = (void __user *)arg;\n\t\tstruct pkey_genseck kgs;\n\n\t\tif (copy_from_user(&kgs, ugs, sizeof(kgs)))\n\t\t\treturn -EFAULT;\n\t\trc = cca_genseckey(kgs.cardnr, kgs.domain,\n\t\t\t\t   kgs.keytype, kgs.seckey.seckey);\n\t\tDEBUG_DBG(\"%s cca_genseckey()=%d\\n\", __func__, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(ugs, &kgs, sizeof(kgs)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_CLR2SECK: {\n\t\tstruct pkey_clr2seck __user *ucs = (void __user *)arg;\n\t\tstruct pkey_clr2seck kcs;\n\n\t\tif (copy_from_user(&kcs, ucs, sizeof(kcs)))\n\t\t\treturn -EFAULT;\n\t\trc = cca_clr2seckey(kcs.cardnr, kcs.domain, kcs.keytype,\n\t\t\t\t    kcs.clrkey.clrkey, kcs.seckey.seckey);\n\t\tDEBUG_DBG(\"%s cca_clr2seckey()=%d\\n\", __func__, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(ucs, &kcs, sizeof(kcs)))\n\t\t\treturn -EFAULT;\n\t\tmemzero_explicit(&kcs, sizeof(kcs));\n\t\tbreak;\n\t}\n\tcase PKEY_SEC2PROTK: {\n\t\tstruct pkey_sec2protk __user *usp = (void __user *)arg;\n\t\tstruct pkey_sec2protk ksp;\n\n\t\tif (copy_from_user(&ksp, usp, sizeof(ksp)))\n\t\t\treturn -EFAULT;\n\t\tksp.protkey.len = sizeof(ksp.protkey.protkey);\n\t\trc = cca_sec2protkey(ksp.cardnr, ksp.domain,\n\t\t\t\t     ksp.seckey.seckey, ksp.protkey.protkey,\n\t\t\t\t     &ksp.protkey.len, &ksp.protkey.type);\n\t\tDEBUG_DBG(\"%s cca_sec2protkey()=%d\\n\", __func__, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(usp, &ksp, sizeof(ksp)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_CLR2PROTK: {\n\t\tstruct pkey_clr2protk __user *ucp = (void __user *)arg;\n\t\tstruct pkey_clr2protk kcp;\n\n\t\tif (copy_from_user(&kcp, ucp, sizeof(kcp)))\n\t\t\treturn -EFAULT;\n\t\tkcp.protkey.len = sizeof(kcp.protkey.protkey);\n\t\trc = pkey_clr2protkey(kcp.keytype, kcp.clrkey.clrkey,\n\t\t\t\t      kcp.protkey.protkey,\n\t\t\t\t      &kcp.protkey.len, &kcp.protkey.type);\n\t\tDEBUG_DBG(\"%s pkey_clr2protkey()=%d\\n\", __func__, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(ucp, &kcp, sizeof(kcp)))\n\t\t\treturn -EFAULT;\n\t\tmemzero_explicit(&kcp, sizeof(kcp));\n\t\tbreak;\n\t}\n\tcase PKEY_FINDCARD: {\n\t\tstruct pkey_findcard __user *ufc = (void __user *)arg;\n\t\tstruct pkey_findcard kfc;\n\n\t\tif (copy_from_user(&kfc, ufc, sizeof(kfc)))\n\t\t\treturn -EFAULT;\n\t\trc = cca_findcard(kfc.seckey.seckey,\n\t\t\t\t  &kfc.cardnr, &kfc.domain, 1);\n\t\tDEBUG_DBG(\"%s cca_findcard()=%d\\n\", __func__, rc);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(ufc, &kfc, sizeof(kfc)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_SKEY2PKEY: {\n\t\tstruct pkey_skey2pkey __user *usp = (void __user *)arg;\n\t\tstruct pkey_skey2pkey ksp;\n\n\t\tif (copy_from_user(&ksp, usp, sizeof(ksp)))\n\t\t\treturn -EFAULT;\n\t\tksp.protkey.len = sizeof(ksp.protkey.protkey);\n\t\trc = pkey_skey2pkey(ksp.seckey.seckey, ksp.protkey.protkey,\n\t\t\t\t    &ksp.protkey.len, &ksp.protkey.type);\n\t\tDEBUG_DBG(\"%s pkey_skey2pkey()=%d\\n\", __func__, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(usp, &ksp, sizeof(ksp)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_VERIFYKEY: {\n\t\tstruct pkey_verifykey __user *uvk = (void __user *)arg;\n\t\tstruct pkey_verifykey kvk;\n\n\t\tif (copy_from_user(&kvk, uvk, sizeof(kvk)))\n\t\t\treturn -EFAULT;\n\t\trc = pkey_verifykey(&kvk.seckey, &kvk.cardnr, &kvk.domain,\n\t\t\t\t    &kvk.keysize, &kvk.attributes);\n\t\tDEBUG_DBG(\"%s pkey_verifykey()=%d\\n\", __func__, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(uvk, &kvk, sizeof(kvk)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_GENPROTK: {\n\t\tstruct pkey_genprotk __user *ugp = (void __user *)arg;\n\t\tstruct pkey_genprotk kgp;\n\n\t\tif (copy_from_user(&kgp, ugp, sizeof(kgp)))\n\t\t\treturn -EFAULT;\n\t\tkgp.protkey.len = sizeof(kgp.protkey.protkey);\n\t\trc = pkey_genprotkey(kgp.keytype, kgp.protkey.protkey,\n\t\t\t\t     &kgp.protkey.len, &kgp.protkey.type);\n\t\tDEBUG_DBG(\"%s pkey_genprotkey()=%d\\n\", __func__, rc);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(ugp, &kgp, sizeof(kgp)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_VERIFYPROTK: {\n\t\tstruct pkey_verifyprotk __user *uvp = (void __user *)arg;\n\t\tstruct pkey_verifyprotk kvp;\n\n\t\tif (copy_from_user(&kvp, uvp, sizeof(kvp)))\n\t\t\treturn -EFAULT;\n\t\trc = pkey_verifyprotkey(kvp.protkey.protkey,\n\t\t\t\t\tkvp.protkey.len, kvp.protkey.type);\n\t\tDEBUG_DBG(\"%s pkey_verifyprotkey()=%d\\n\", __func__, rc);\n\t\tbreak;\n\t}\n\tcase PKEY_KBLOB2PROTK: {\n\t\tstruct pkey_kblob2pkey __user *utp = (void __user *)arg;\n\t\tstruct pkey_kblob2pkey ktp;\n\t\tu8 *kkey;\n\n\t\tif (copy_from_user(&ktp, utp, sizeof(ktp)))\n\t\t\treturn -EFAULT;\n\t\tkkey = _copy_key_from_user(ktp.key, ktp.keylen);\n\t\tif (IS_ERR(kkey))\n\t\t\treturn PTR_ERR(kkey);\n\t\tktp.protkey.len = sizeof(ktp.protkey.protkey);\n\t\trc = pkey_keyblob2pkey(kkey, ktp.keylen, ktp.protkey.protkey,\n\t\t\t\t       &ktp.protkey.len, &ktp.protkey.type);\n\t\tDEBUG_DBG(\"%s pkey_keyblob2pkey()=%d\\n\", __func__, rc);\n\t\tmemzero_explicit(kkey, ktp.keylen);\n\t\tkfree(kkey);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(utp, &ktp, sizeof(ktp)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_GENSECK2: {\n\t\tstruct pkey_genseck2 __user *ugs = (void __user *)arg;\n\t\tsize_t klen = KEYBLOBBUFSIZE;\n\t\tstruct pkey_genseck2 kgs;\n\t\tstruct pkey_apqn *apqns;\n\t\tu8 *kkey;\n\n\t\tif (copy_from_user(&kgs, ugs, sizeof(kgs)))\n\t\t\treturn -EFAULT;\n\t\tapqns = _copy_apqns_from_user(kgs.apqns, kgs.apqn_entries);\n\t\tif (IS_ERR(apqns))\n\t\t\treturn PTR_ERR(apqns);\n\t\tkkey = kzalloc(klen, GFP_KERNEL);\n\t\tif (!kkey) {\n\t\t\tkfree(apqns);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trc = pkey_genseckey2(apqns, kgs.apqn_entries,\n\t\t\t\t     kgs.type, kgs.size, kgs.keygenflags,\n\t\t\t\t     kkey, &klen);\n\t\tDEBUG_DBG(\"%s pkey_genseckey2()=%d\\n\", __func__, rc);\n\t\tkfree(apqns);\n\t\tif (rc) {\n\t\t\tkfree(kkey);\n\t\t\tbreak;\n\t\t}\n\t\tif (kgs.key) {\n\t\t\tif (kgs.keylen < klen) {\n\t\t\t\tkfree(kkey);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (copy_to_user(kgs.key, kkey, klen)) {\n\t\t\t\tkfree(kkey);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tkgs.keylen = klen;\n\t\tif (copy_to_user(ugs, &kgs, sizeof(kgs)))\n\t\t\trc = -EFAULT;\n\t\tkfree(kkey);\n\t\tbreak;\n\t}\n\tcase PKEY_CLR2SECK2: {\n\t\tstruct pkey_clr2seck2 __user *ucs = (void __user *)arg;\n\t\tsize_t klen = KEYBLOBBUFSIZE;\n\t\tstruct pkey_clr2seck2 kcs;\n\t\tstruct pkey_apqn *apqns;\n\t\tu8 *kkey;\n\n\t\tif (copy_from_user(&kcs, ucs, sizeof(kcs)))\n\t\t\treturn -EFAULT;\n\t\tapqns = _copy_apqns_from_user(kcs.apqns, kcs.apqn_entries);\n\t\tif (IS_ERR(apqns))\n\t\t\treturn PTR_ERR(apqns);\n\t\tkkey = kzalloc(klen, GFP_KERNEL);\n\t\tif (!kkey) {\n\t\t\tkfree(apqns);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trc = pkey_clr2seckey2(apqns, kcs.apqn_entries,\n\t\t\t\t      kcs.type, kcs.size, kcs.keygenflags,\n\t\t\t\t      kcs.clrkey.clrkey, kkey, &klen);\n\t\tDEBUG_DBG(\"%s pkey_clr2seckey2()=%d\\n\", __func__, rc);\n\t\tkfree(apqns);\n\t\tif (rc) {\n\t\t\tkfree(kkey);\n\t\t\tbreak;\n\t\t}\n\t\tif (kcs.key) {\n\t\t\tif (kcs.keylen < klen) {\n\t\t\t\tkfree(kkey);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (copy_to_user(kcs.key, kkey, klen)) {\n\t\t\t\tkfree(kkey);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tkcs.keylen = klen;\n\t\tif (copy_to_user(ucs, &kcs, sizeof(kcs)))\n\t\t\trc = -EFAULT;\n\t\tmemzero_explicit(&kcs, sizeof(kcs));\n\t\tkfree(kkey);\n\t\tbreak;\n\t}\n\tcase PKEY_VERIFYKEY2: {\n\t\tstruct pkey_verifykey2 __user *uvk = (void __user *)arg;\n\t\tstruct pkey_verifykey2 kvk;\n\t\tu8 *kkey;\n\n\t\tif (copy_from_user(&kvk, uvk, sizeof(kvk)))\n\t\t\treturn -EFAULT;\n\t\tkkey = _copy_key_from_user(kvk.key, kvk.keylen);\n\t\tif (IS_ERR(kkey))\n\t\t\treturn PTR_ERR(kkey);\n\t\trc = pkey_verifykey2(kkey, kvk.keylen,\n\t\t\t\t     &kvk.cardnr, &kvk.domain,\n\t\t\t\t     &kvk.type, &kvk.size, &kvk.flags);\n\t\tDEBUG_DBG(\"%s pkey_verifykey2()=%d\\n\", __func__, rc);\n\t\tkfree(kkey);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(uvk, &kvk, sizeof(kvk)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_KBLOB2PROTK2: {\n\t\tstruct pkey_kblob2pkey2 __user *utp = (void __user *)arg;\n\t\tstruct pkey_apqn *apqns = NULL;\n\t\tstruct pkey_kblob2pkey2 ktp;\n\t\tu8 *kkey;\n\n\t\tif (copy_from_user(&ktp, utp, sizeof(ktp)))\n\t\t\treturn -EFAULT;\n\t\tapqns = _copy_apqns_from_user(ktp.apqns, ktp.apqn_entries);\n\t\tif (IS_ERR(apqns))\n\t\t\treturn PTR_ERR(apqns);\n\t\tkkey = _copy_key_from_user(ktp.key, ktp.keylen);\n\t\tif (IS_ERR(kkey)) {\n\t\t\tkfree(apqns);\n\t\t\treturn PTR_ERR(kkey);\n\t\t}\n\t\tktp.protkey.len = sizeof(ktp.protkey.protkey);\n\t\trc = pkey_keyblob2pkey2(apqns, ktp.apqn_entries,\n\t\t\t\t\tkkey, ktp.keylen,\n\t\t\t\t\tktp.protkey.protkey, &ktp.protkey.len,\n\t\t\t\t\t&ktp.protkey.type);\n\t\tDEBUG_DBG(\"%s pkey_keyblob2pkey2()=%d\\n\", __func__, rc);\n\t\tkfree(apqns);\n\t\tmemzero_explicit(kkey, ktp.keylen);\n\t\tkfree(kkey);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (copy_to_user(utp, &ktp, sizeof(ktp)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase PKEY_APQNS4K: {\n\t\tstruct pkey_apqns4key __user *uak = (void __user *)arg;\n\t\tstruct pkey_apqn *apqns = NULL;\n\t\tstruct pkey_apqns4key kak;\n\t\tsize_t nr_apqns, len;\n\t\tu8 *kkey;\n\n\t\tif (copy_from_user(&kak, uak, sizeof(kak)))\n\t\t\treturn -EFAULT;\n\t\tnr_apqns = kak.apqn_entries;\n\t\tif (nr_apqns) {\n\t\t\tapqns = kmalloc_array(nr_apqns,\n\t\t\t\t\t      sizeof(struct pkey_apqn),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!apqns)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkkey = _copy_key_from_user(kak.key, kak.keylen);\n\t\tif (IS_ERR(kkey)) {\n\t\t\tkfree(apqns);\n\t\t\treturn PTR_ERR(kkey);\n\t\t}\n\t\trc = pkey_apqns4key(kkey, kak.keylen, kak.flags,\n\t\t\t\t    apqns, &nr_apqns);\n\t\tDEBUG_DBG(\"%s pkey_apqns4key()=%d\\n\", __func__, rc);\n\t\tkfree(kkey);\n\t\tif (rc && rc != -ENOSPC) {\n\t\t\tkfree(apqns);\n\t\t\tbreak;\n\t\t}\n\t\tif (!rc && kak.apqns) {\n\t\t\tif (nr_apqns > kak.apqn_entries) {\n\t\t\t\tkfree(apqns);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlen = nr_apqns * sizeof(struct pkey_apqn);\n\t\t\tif (len) {\n\t\t\t\tif (copy_to_user(kak.apqns, apqns, len)) {\n\t\t\t\t\tkfree(apqns);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tkak.apqn_entries = nr_apqns;\n\t\tif (copy_to_user(uak, &kak, sizeof(kak)))\n\t\t\trc = -EFAULT;\n\t\tkfree(apqns);\n\t\tbreak;\n\t}\n\tcase PKEY_APQNS4KT: {\n\t\tstruct pkey_apqns4keytype __user *uat = (void __user *)arg;\n\t\tstruct pkey_apqn *apqns = NULL;\n\t\tstruct pkey_apqns4keytype kat;\n\t\tsize_t nr_apqns, len;\n\n\t\tif (copy_from_user(&kat, uat, sizeof(kat)))\n\t\t\treturn -EFAULT;\n\t\tnr_apqns = kat.apqn_entries;\n\t\tif (nr_apqns) {\n\t\t\tapqns = kmalloc_array(nr_apqns,\n\t\t\t\t\t      sizeof(struct pkey_apqn),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!apqns)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\trc = pkey_apqns4keytype(kat.type, kat.cur_mkvp, kat.alt_mkvp,\n\t\t\t\t\tkat.flags, apqns, &nr_apqns);\n\t\tDEBUG_DBG(\"%s pkey_apqns4keytype()=%d\\n\", __func__, rc);\n\t\tif (rc && rc != -ENOSPC) {\n\t\t\tkfree(apqns);\n\t\t\tbreak;\n\t\t}\n\t\tif (!rc && kat.apqns) {\n\t\t\tif (nr_apqns > kat.apqn_entries) {\n\t\t\t\tkfree(apqns);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlen = nr_apqns * sizeof(struct pkey_apqn);\n\t\t\tif (len) {\n\t\t\t\tif (copy_to_user(kat.apqns, apqns, len)) {\n\t\t\t\t\tkfree(apqns);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tkat.apqn_entries = nr_apqns;\n\t\tif (copy_to_user(uat, &kat, sizeof(kat)))\n\t\t\trc = -EFAULT;\n\t\tkfree(apqns);\n\t\tbreak;\n\t}\n\tcase PKEY_KBLOB2PROTK3: {\n\t\tstruct pkey_kblob2pkey3 __user *utp = (void __user *)arg;\n\t\tu32 protkeylen = PROTKEYBLOBBUFSIZE;\n\t\tstruct pkey_apqn *apqns = NULL;\n\t\tstruct pkey_kblob2pkey3 ktp;\n\t\tu8 *kkey, *protkey;\n\n\t\tif (copy_from_user(&ktp, utp, sizeof(ktp)))\n\t\t\treturn -EFAULT;\n\t\tapqns = _copy_apqns_from_user(ktp.apqns, ktp.apqn_entries);\n\t\tif (IS_ERR(apqns))\n\t\t\treturn PTR_ERR(apqns);\n\t\tkkey = _copy_key_from_user(ktp.key, ktp.keylen);\n\t\tif (IS_ERR(kkey)) {\n\t\t\tkfree(apqns);\n\t\t\treturn PTR_ERR(kkey);\n\t\t}\n\t\tprotkey = kmalloc(protkeylen, GFP_KERNEL);\n\t\tif (!protkey) {\n\t\t\tkfree(apqns);\n\t\t\tkfree(kkey);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trc = pkey_keyblob2pkey3(apqns, ktp.apqn_entries,\n\t\t\t\t\tkkey, ktp.keylen,\n\t\t\t\t\tprotkey, &protkeylen, &ktp.pkeytype);\n\t\tDEBUG_DBG(\"%s pkey_keyblob2pkey3()=%d\\n\", __func__, rc);\n\t\tkfree(apqns);\n\t\tmemzero_explicit(kkey, ktp.keylen);\n\t\tkfree(kkey);\n\t\tif (rc) {\n\t\t\tkfree(protkey);\n\t\t\tbreak;\n\t\t}\n\t\tif (ktp.pkey && ktp.pkeylen) {\n\t\t\tif (protkeylen > ktp.pkeylen) {\n\t\t\t\tkfree(protkey);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (copy_to_user(ktp.pkey, protkey, protkeylen)) {\n\t\t\t\tkfree(protkey);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t\tkfree(protkey);\n\t\tktp.pkeylen = protkeylen;\n\t\tif (copy_to_user(utp, &ktp, sizeof(ktp)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tdefault:\n\t\t \n\t\treturn -ENOTTY;\n\t}\n\n\treturn rc;\n}\n\n \n\n \nstatic ssize_t pkey_protkey_aes_attr_read(u32 keytype, bool is_xts, char *buf,\n\t\t\t\t\t  loff_t off, size_t count)\n{\n\tstruct protaeskeytoken protkeytoken;\n\tstruct pkey_protkey protkey;\n\tint rc;\n\n\tif (off != 0 || count < sizeof(protkeytoken))\n\t\treturn -EINVAL;\n\tif (is_xts)\n\t\tif (count < 2 * sizeof(protkeytoken))\n\t\t\treturn -EINVAL;\n\n\tmemset(&protkeytoken, 0, sizeof(protkeytoken));\n\tprotkeytoken.type = TOKTYPE_NON_CCA;\n\tprotkeytoken.version = TOKVER_PROTECTED_KEY;\n\tprotkeytoken.keytype = keytype;\n\n\tprotkey.len = sizeof(protkey.protkey);\n\trc = pkey_genprotkey(protkeytoken.keytype,\n\t\t\t     protkey.protkey, &protkey.len, &protkey.type);\n\tif (rc)\n\t\treturn rc;\n\n\tprotkeytoken.len = protkey.len;\n\tmemcpy(&protkeytoken.protkey, &protkey.protkey, protkey.len);\n\n\tmemcpy(buf, &protkeytoken, sizeof(protkeytoken));\n\n\tif (is_xts) {\n\t\t \n\t\tprotkey.len = sizeof(protkey.protkey);\n\t\trc = pkey_genprotkey(protkeytoken.keytype,\n\t\t\t\t     protkey.protkey, &protkey.len, &protkey.type);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tprotkeytoken.len = protkey.len;\n\t\tmemcpy(&protkeytoken.protkey, &protkey.protkey, protkey.len);\n\n\t\tmemcpy(buf + sizeof(protkeytoken), &protkeytoken,\n\t\t       sizeof(protkeytoken));\n\n\t\treturn 2 * sizeof(protkeytoken);\n\t}\n\n\treturn sizeof(protkeytoken);\n}\n\nstatic ssize_t protkey_aes_128_read(struct file *filp,\n\t\t\t\t    struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t    char *buf, loff_t off,\n\t\t\t\t    size_t count)\n{\n\treturn pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_128, false, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic ssize_t protkey_aes_192_read(struct file *filp,\n\t\t\t\t    struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t    char *buf, loff_t off,\n\t\t\t\t    size_t count)\n{\n\treturn pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_192, false, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic ssize_t protkey_aes_256_read(struct file *filp,\n\t\t\t\t    struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t    char *buf, loff_t off,\n\t\t\t\t    size_t count)\n{\n\treturn pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_256, false, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic ssize_t protkey_aes_128_xts_read(struct file *filp,\n\t\t\t\t\tstruct kobject *kobj,\n\t\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\t\tchar *buf, loff_t off,\n\t\t\t\t\tsize_t count)\n{\n\treturn pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_128, true, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic ssize_t protkey_aes_256_xts_read(struct file *filp,\n\t\t\t\t\tstruct kobject *kobj,\n\t\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\t\tchar *buf, loff_t off,\n\t\t\t\t\tsize_t count)\n{\n\treturn pkey_protkey_aes_attr_read(PKEY_KEYTYPE_AES_256, true, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic BIN_ATTR_RO(protkey_aes_128, sizeof(struct protaeskeytoken));\nstatic BIN_ATTR_RO(protkey_aes_192, sizeof(struct protaeskeytoken));\nstatic BIN_ATTR_RO(protkey_aes_256, sizeof(struct protaeskeytoken));\nstatic BIN_ATTR_RO(protkey_aes_128_xts, 2 * sizeof(struct protaeskeytoken));\nstatic BIN_ATTR_RO(protkey_aes_256_xts, 2 * sizeof(struct protaeskeytoken));\n\nstatic struct bin_attribute *protkey_attrs[] = {\n\t&bin_attr_protkey_aes_128,\n\t&bin_attr_protkey_aes_192,\n\t&bin_attr_protkey_aes_256,\n\t&bin_attr_protkey_aes_128_xts,\n\t&bin_attr_protkey_aes_256_xts,\n\tNULL\n};\n\nstatic struct attribute_group protkey_attr_group = {\n\t.name\t   = \"protkey\",\n\t.bin_attrs = protkey_attrs,\n};\n\n \nstatic ssize_t pkey_ccadata_aes_attr_read(u32 keytype, bool is_xts, char *buf,\n\t\t\t\t\t  loff_t off, size_t count)\n{\n\tstruct pkey_seckey *seckey = (struct pkey_seckey *)buf;\n\tint rc;\n\n\tif (off != 0 || count < sizeof(struct secaeskeytoken))\n\t\treturn -EINVAL;\n\tif (is_xts)\n\t\tif (count < 2 * sizeof(struct secaeskeytoken))\n\t\t\treturn -EINVAL;\n\n\trc = cca_genseckey(-1, -1, keytype, seckey->seckey);\n\tif (rc)\n\t\treturn rc;\n\n\tif (is_xts) {\n\t\tseckey++;\n\t\trc = cca_genseckey(-1, -1, keytype, seckey->seckey);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\treturn 2 * sizeof(struct secaeskeytoken);\n\t}\n\n\treturn sizeof(struct secaeskeytoken);\n}\n\nstatic ssize_t ccadata_aes_128_read(struct file *filp,\n\t\t\t\t    struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t    char *buf, loff_t off,\n\t\t\t\t    size_t count)\n{\n\treturn pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_128, false, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic ssize_t ccadata_aes_192_read(struct file *filp,\n\t\t\t\t    struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t    char *buf, loff_t off,\n\t\t\t\t    size_t count)\n{\n\treturn pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_192, false, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic ssize_t ccadata_aes_256_read(struct file *filp,\n\t\t\t\t    struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *attr,\n\t\t\t\t    char *buf, loff_t off,\n\t\t\t\t    size_t count)\n{\n\treturn pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_256, false, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic ssize_t ccadata_aes_128_xts_read(struct file *filp,\n\t\t\t\t\tstruct kobject *kobj,\n\t\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\t\tchar *buf, loff_t off,\n\t\t\t\t\tsize_t count)\n{\n\treturn pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_128, true, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic ssize_t ccadata_aes_256_xts_read(struct file *filp,\n\t\t\t\t\tstruct kobject *kobj,\n\t\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\t\tchar *buf, loff_t off,\n\t\t\t\t\tsize_t count)\n{\n\treturn pkey_ccadata_aes_attr_read(PKEY_KEYTYPE_AES_256, true, buf,\n\t\t\t\t\t  off, count);\n}\n\nstatic BIN_ATTR_RO(ccadata_aes_128, sizeof(struct secaeskeytoken));\nstatic BIN_ATTR_RO(ccadata_aes_192, sizeof(struct secaeskeytoken));\nstatic BIN_ATTR_RO(ccadata_aes_256, sizeof(struct secaeskeytoken));\nstatic BIN_ATTR_RO(ccadata_aes_128_xts, 2 * sizeof(struct secaeskeytoken));\nstatic BIN_ATTR_RO(ccadata_aes_256_xts, 2 * sizeof(struct secaeskeytoken));\n\nstatic struct bin_attribute *ccadata_attrs[] = {\n\t&bin_attr_ccadata_aes_128,\n\t&bin_attr_ccadata_aes_192,\n\t&bin_attr_ccadata_aes_256,\n\t&bin_attr_ccadata_aes_128_xts,\n\t&bin_attr_ccadata_aes_256_xts,\n\tNULL\n};\n\nstatic struct attribute_group ccadata_attr_group = {\n\t.name\t   = \"ccadata\",\n\t.bin_attrs = ccadata_attrs,\n};\n\n#define CCACIPHERTOKENSIZE\t(sizeof(struct cipherkeytoken) + 80)\n\n \nstatic ssize_t pkey_ccacipher_aes_attr_read(enum pkey_key_size keybits,\n\t\t\t\t\t    bool is_xts, char *buf, loff_t off,\n\t\t\t\t\t    size_t count)\n{\n\tsize_t keysize = CCACIPHERTOKENSIZE;\n\tu32 nr_apqns, *apqns = NULL;\n\tint i, rc, card, dom;\n\n\tif (off != 0 || count < CCACIPHERTOKENSIZE)\n\t\treturn -EINVAL;\n\tif (is_xts)\n\t\tif (count < 2 * CCACIPHERTOKENSIZE)\n\t\t\treturn -EINVAL;\n\n\t \n\trc = cca_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t   ZCRYPT_CEX6, 0, 0, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tmemset(buf, 0, is_xts ? 2 * keysize : keysize);\n\n\t \n\tfor (i = 0, rc = -ENODEV; i < nr_apqns; i++) {\n\t\tcard = apqns[i] >> 16;\n\t\tdom = apqns[i] & 0xFFFF;\n\t\trc = cca_gencipherkey(card, dom, keybits, 0, buf, &keysize);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\tif (is_xts) {\n\t\tkeysize = CCACIPHERTOKENSIZE;\n\t\tbuf += CCACIPHERTOKENSIZE;\n\t\trc = cca_gencipherkey(card, dom, keybits, 0, buf, &keysize);\n\t\tif (rc == 0)\n\t\t\treturn 2 * CCACIPHERTOKENSIZE;\n\t}\n\n\treturn CCACIPHERTOKENSIZE;\n}\n\nstatic ssize_t ccacipher_aes_128_read(struct file *filp,\n\t\t\t\t      struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr,\n\t\t\t\t      char *buf, loff_t off,\n\t\t\t\t      size_t count)\n{\n\treturn pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_128, false, buf,\n\t\t\t\t\t    off, count);\n}\n\nstatic ssize_t ccacipher_aes_192_read(struct file *filp,\n\t\t\t\t      struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr,\n\t\t\t\t      char *buf, loff_t off,\n\t\t\t\t      size_t count)\n{\n\treturn pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_192, false, buf,\n\t\t\t\t\t    off, count);\n}\n\nstatic ssize_t ccacipher_aes_256_read(struct file *filp,\n\t\t\t\t      struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr,\n\t\t\t\t      char *buf, loff_t off,\n\t\t\t\t      size_t count)\n{\n\treturn pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_256, false, buf,\n\t\t\t\t\t    off, count);\n}\n\nstatic ssize_t ccacipher_aes_128_xts_read(struct file *filp,\n\t\t\t\t\t  struct kobject *kobj,\n\t\t\t\t\t  struct bin_attribute *attr,\n\t\t\t\t\t  char *buf, loff_t off,\n\t\t\t\t\t  size_t count)\n{\n\treturn pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_128, true, buf,\n\t\t\t\t\t    off, count);\n}\n\nstatic ssize_t ccacipher_aes_256_xts_read(struct file *filp,\n\t\t\t\t\t  struct kobject *kobj,\n\t\t\t\t\t  struct bin_attribute *attr,\n\t\t\t\t\t  char *buf, loff_t off,\n\t\t\t\t\t  size_t count)\n{\n\treturn pkey_ccacipher_aes_attr_read(PKEY_SIZE_AES_256, true, buf,\n\t\t\t\t\t    off, count);\n}\n\nstatic BIN_ATTR_RO(ccacipher_aes_128, CCACIPHERTOKENSIZE);\nstatic BIN_ATTR_RO(ccacipher_aes_192, CCACIPHERTOKENSIZE);\nstatic BIN_ATTR_RO(ccacipher_aes_256, CCACIPHERTOKENSIZE);\nstatic BIN_ATTR_RO(ccacipher_aes_128_xts, 2 * CCACIPHERTOKENSIZE);\nstatic BIN_ATTR_RO(ccacipher_aes_256_xts, 2 * CCACIPHERTOKENSIZE);\n\nstatic struct bin_attribute *ccacipher_attrs[] = {\n\t&bin_attr_ccacipher_aes_128,\n\t&bin_attr_ccacipher_aes_192,\n\t&bin_attr_ccacipher_aes_256,\n\t&bin_attr_ccacipher_aes_128_xts,\n\t&bin_attr_ccacipher_aes_256_xts,\n\tNULL\n};\n\nstatic struct attribute_group ccacipher_attr_group = {\n\t.name\t   = \"ccacipher\",\n\t.bin_attrs = ccacipher_attrs,\n};\n\n \nstatic ssize_t pkey_ep11_aes_attr_read(enum pkey_key_size keybits,\n\t\t\t\t       bool is_xts, char *buf, loff_t off,\n\t\t\t\t       size_t count)\n{\n\tsize_t keysize = MAXEP11AESKEYBLOBSIZE;\n\tu32 nr_apqns, *apqns = NULL;\n\tint i, rc, card, dom;\n\n\tif (off != 0 || count < MAXEP11AESKEYBLOBSIZE)\n\t\treturn -EINVAL;\n\tif (is_xts)\n\t\tif (count < 2 * MAXEP11AESKEYBLOBSIZE)\n\t\t\treturn -EINVAL;\n\n\t \n\trc = ep11_findcard2(&apqns, &nr_apqns, 0xFFFF, 0xFFFF,\n\t\t\t    ZCRYPT_CEX7,\n\t\t\t    ap_is_se_guest() ? EP11_API_V6 : EP11_API_V4,\n\t\t\t    NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tmemset(buf, 0, is_xts ? 2 * keysize : keysize);\n\n\t \n\tfor (i = 0, rc = -ENODEV; i < nr_apqns; i++) {\n\t\tcard = apqns[i] >> 16;\n\t\tdom = apqns[i] & 0xFFFF;\n\t\trc = ep11_genaeskey(card, dom, keybits, 0, buf, &keysize,\n\t\t\t\t    PKEY_TYPE_EP11_AES);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\tif (is_xts) {\n\t\tkeysize = MAXEP11AESKEYBLOBSIZE;\n\t\tbuf += MAXEP11AESKEYBLOBSIZE;\n\t\trc = ep11_genaeskey(card, dom, keybits, 0, buf, &keysize,\n\t\t\t\t    PKEY_TYPE_EP11_AES);\n\t\tif (rc == 0)\n\t\t\treturn 2 * MAXEP11AESKEYBLOBSIZE;\n\t}\n\n\treturn MAXEP11AESKEYBLOBSIZE;\n}\n\nstatic ssize_t ep11_aes_128_read(struct file *filp,\n\t\t\t\t struct kobject *kobj,\n\t\t\t\t struct bin_attribute *attr,\n\t\t\t\t char *buf, loff_t off,\n\t\t\t\t size_t count)\n{\n\treturn pkey_ep11_aes_attr_read(PKEY_SIZE_AES_128, false, buf,\n\t\t\t\t       off, count);\n}\n\nstatic ssize_t ep11_aes_192_read(struct file *filp,\n\t\t\t\t struct kobject *kobj,\n\t\t\t\t struct bin_attribute *attr,\n\t\t\t\t char *buf, loff_t off,\n\t\t\t\t size_t count)\n{\n\treturn pkey_ep11_aes_attr_read(PKEY_SIZE_AES_192, false, buf,\n\t\t\t\t       off, count);\n}\n\nstatic ssize_t ep11_aes_256_read(struct file *filp,\n\t\t\t\t struct kobject *kobj,\n\t\t\t\t struct bin_attribute *attr,\n\t\t\t\t char *buf, loff_t off,\n\t\t\t\t size_t count)\n{\n\treturn pkey_ep11_aes_attr_read(PKEY_SIZE_AES_256, false, buf,\n\t\t\t\t       off, count);\n}\n\nstatic ssize_t ep11_aes_128_xts_read(struct file *filp,\n\t\t\t\t     struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr,\n\t\t\t\t     char *buf, loff_t off,\n\t\t\t\t     size_t count)\n{\n\treturn pkey_ep11_aes_attr_read(PKEY_SIZE_AES_128, true, buf,\n\t\t\t\t       off, count);\n}\n\nstatic ssize_t ep11_aes_256_xts_read(struct file *filp,\n\t\t\t\t     struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr,\n\t\t\t\t     char *buf, loff_t off,\n\t\t\t\t     size_t count)\n{\n\treturn pkey_ep11_aes_attr_read(PKEY_SIZE_AES_256, true, buf,\n\t\t\t\t       off, count);\n}\n\nstatic BIN_ATTR_RO(ep11_aes_128, MAXEP11AESKEYBLOBSIZE);\nstatic BIN_ATTR_RO(ep11_aes_192, MAXEP11AESKEYBLOBSIZE);\nstatic BIN_ATTR_RO(ep11_aes_256, MAXEP11AESKEYBLOBSIZE);\nstatic BIN_ATTR_RO(ep11_aes_128_xts, 2 * MAXEP11AESKEYBLOBSIZE);\nstatic BIN_ATTR_RO(ep11_aes_256_xts, 2 * MAXEP11AESKEYBLOBSIZE);\n\nstatic struct bin_attribute *ep11_attrs[] = {\n\t&bin_attr_ep11_aes_128,\n\t&bin_attr_ep11_aes_192,\n\t&bin_attr_ep11_aes_256,\n\t&bin_attr_ep11_aes_128_xts,\n\t&bin_attr_ep11_aes_256_xts,\n\tNULL\n};\n\nstatic struct attribute_group ep11_attr_group = {\n\t.name\t   = \"ep11\",\n\t.bin_attrs = ep11_attrs,\n};\n\nstatic const struct attribute_group *pkey_attr_groups[] = {\n\t&protkey_attr_group,\n\t&ccadata_attr_group,\n\t&ccacipher_attr_group,\n\t&ep11_attr_group,\n\tNULL,\n};\n\nstatic const struct file_operations pkey_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= nonseekable_open,\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = pkey_unlocked_ioctl,\n};\n\nstatic struct miscdevice pkey_dev = {\n\t.name\t= \"pkey\",\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.mode\t= 0666,\n\t.fops\t= &pkey_fops,\n\t.groups = pkey_attr_groups,\n};\n\n \nstatic int __init pkey_init(void)\n{\n\tcpacf_mask_t func_mask;\n\n\t \n\tif (!cpacf_query(CPACF_PCKMO, &func_mask))\n\t\treturn -ENODEV;\n\n\t \n\tif (!cpacf_query(CPACF_KMC, &func_mask))\n\t\treturn -ENODEV;\n\tif (!cpacf_test_func(&func_mask, CPACF_KMC_PAES_128) ||\n\t    !cpacf_test_func(&func_mask, CPACF_KMC_PAES_192) ||\n\t    !cpacf_test_func(&func_mask, CPACF_KMC_PAES_256))\n\t\treturn -ENODEV;\n\n\tpkey_debug_init();\n\n\treturn misc_register(&pkey_dev);\n}\n\n \nstatic void __exit pkey_exit(void)\n{\n\tmisc_deregister(&pkey_dev);\n\tpkey_debug_exit();\n}\n\nmodule_cpu_feature_match(S390_CPU_FEATURE_MSA, pkey_init);\nmodule_exit(pkey_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}