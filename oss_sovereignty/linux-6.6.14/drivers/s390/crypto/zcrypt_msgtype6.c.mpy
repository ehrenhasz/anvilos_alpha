{
  "module_name": "zcrypt_msgtype6.c",
  "hash_id": "2622a207202f5f5b642fe1dd4bfe1be88c7067cdd15b3bdcd3f1c16fb2adb7d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/crypto/zcrypt_msgtype6.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zcrypt\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n\n#include \"ap_bus.h\"\n#include \"zcrypt_api.h\"\n#include \"zcrypt_error.h\"\n#include \"zcrypt_msgtype6.h\"\n#include \"zcrypt_cca_key.h\"\n\n#define CEXXC_MAX_ICA_RESPONSE_SIZE 0x77c  \n\n#define CEIL4(x) ((((x) + 3) / 4) * 4)\n\nstruct response_type {\n\tstruct completion work;\n\tint type;\n};\n\n#define CEXXC_RESPONSE_TYPE_ICA  0\n#define CEXXC_RESPONSE_TYPE_XCRB 1\n#define CEXXC_RESPONSE_TYPE_EP11 2\n\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"Cryptographic Coprocessor (message type 6), \" \\\n\t\t   \"Copyright IBM Corp. 2001, 2023\");\nMODULE_LICENSE(\"GPL\");\n\nstruct function_and_rules_block {\n\tunsigned char function_code[2];\n\tunsigned short ulen;\n\tunsigned char only_rule[8];\n} __packed;\n\n \nstatic const struct CPRBX static_cprbx = {\n\t.cprb_len\t=  0x00DC,\n\t.cprb_ver_id\t=  0x02,\n\t.func_id\t= {0x54, 0x32},\n};\n\nint speed_idx_cca(int req_type)\n{\n\tswitch (req_type) {\n\tcase 0x4142:\n\tcase 0x4149:\n\tcase 0x414D:\n\tcase 0x4341:\n\tcase 0x4344:\n\tcase 0x4354:\n\tcase 0x4358:\n\tcase 0x444B:\n\tcase 0x4558:\n\tcase 0x4643:\n\tcase 0x4651:\n\tcase 0x4C47:\n\tcase 0x4C4B:\n\tcase 0x4C51:\n\tcase 0x4F48:\n\tcase 0x504F:\n\tcase 0x5053:\n\tcase 0x5058:\n\tcase 0x5343:\n\tcase 0x5344:\n\tcase 0x5345:\n\tcase 0x5350:\n\t\treturn LOW;\n\tcase 0x414B:\n\tcase 0x4345:\n\tcase 0x4349:\n\tcase 0x434D:\n\tcase 0x4847:\n\tcase 0x4849:\n\tcase 0x484D:\n\tcase 0x4850:\n\tcase 0x4851:\n\tcase 0x4954:\n\tcase 0x4958:\n\tcase 0x4B43:\n\tcase 0x4B44:\n\tcase 0x4B45:\n\tcase 0x4B47:\n\tcase 0x4B48:\n\tcase 0x4B49:\n\tcase 0x4B4E:\n\tcase 0x4B50:\n\tcase 0x4B52:\n\tcase 0x4B54:\n\tcase 0x4B58:\n\tcase 0x4D50:\n\tcase 0x4D53:\n\tcase 0x4D56:\n\tcase 0x4D58:\n\tcase 0x5044:\n\tcase 0x5045:\n\tcase 0x5046:\n\tcase 0x5047:\n\tcase 0x5049:\n\tcase 0x504B:\n\tcase 0x504D:\n\tcase 0x5254:\n\tcase 0x5347:\n\tcase 0x5349:\n\tcase 0x534B:\n\tcase 0x534D:\n\tcase 0x5356:\n\tcase 0x5358:\n\tcase 0x5443:\n\tcase 0x544B:\n\tcase 0x5647:\n\t\treturn HIGH;\n\tdefault:\n\t\treturn MEDIUM;\n\t}\n}\n\nint speed_idx_ep11(int req_type)\n{\n\tswitch (req_type) {\n\tcase  1:\n\tcase  2:\n\tcase 36:\n\tcase 37:\n\tcase 38:\n\tcase 39:\n\tcase 40:\n\t\treturn LOW;\n\tcase 17:\n\tcase 18:\n\tcase 19:\n\tcase 20:\n\tcase 21:\n\tcase 22:\n\tcase 26:\n\tcase 30:\n\tcase 31:\n\tcase 32:\n\tcase 33:\n\tcase 34:\n\tcase 35:\n\t\treturn HIGH;\n\tdefault:\n\t\treturn MEDIUM;\n\t}\n}\n\n \nstatic int icamex_msg_to_type6mex_msgx(struct zcrypt_queue *zq,\n\t\t\t\t       struct ap_message *ap_msg,\n\t\t\t\t       struct ica_rsa_modexpo *mex)\n{\n\tstatic struct type6_hdr static_type6_hdrX = {\n\t\t.type\t\t=  0x06,\n\t\t.offset1\t=  0x00000058,\n\t\t.agent_id\t= {'C', 'A',},\n\t\t.function_code\t= {'P', 'K'},\n\t};\n\tstatic struct function_and_rules_block static_pke_fnr = {\n\t\t.function_code\t= {'P', 'K'},\n\t\t.ulen\t\t= 10,\n\t\t.only_rule\t= {'M', 'R', 'P', ' ', ' ', ' ', ' ', ' '}\n\t};\n\tstruct {\n\t\tstruct type6_hdr hdr;\n\t\tstruct CPRBX cprbx;\n\t\tstruct function_and_rules_block fr;\n\t\tunsigned short length;\n\t\tchar text[];\n\t} __packed * msg = ap_msg->msg;\n\tint size;\n\n\t \n\tif (WARN_ON_ONCE(mex->inputdatalength > PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t \n\tmsg->length = mex->inputdatalength + 2;\n\tif (copy_from_user(msg->text, mex->inputdata, mex->inputdatalength))\n\t\treturn -EFAULT;\n\n\t \n\tsize = zcrypt_type6_mex_key_en(mex, msg->text + mex->inputdatalength);\n\tif (size < 0)\n\t\treturn size;\n\tsize += sizeof(*msg) + mex->inputdatalength;\n\n\t \n\tmsg->hdr = static_type6_hdrX;\n\tmsg->hdr.tocardlen1 = size - sizeof(msg->hdr);\n\tmsg->hdr.fromcardlen1 = CEXXC_MAX_ICA_RESPONSE_SIZE - sizeof(msg->hdr);\n\n\tmsg->cprbx = static_cprbx;\n\tmsg->cprbx.domain = AP_QID_QUEUE(zq->queue->qid);\n\tmsg->cprbx.rpl_msgbl = msg->hdr.fromcardlen1;\n\n\tmsg->fr = static_pke_fnr;\n\n\tmsg->cprbx.req_parml = size - sizeof(msg->hdr) - sizeof(msg->cprbx);\n\n\tap_msg->len = size;\n\treturn 0;\n}\n\n \nstatic int icacrt_msg_to_type6crt_msgx(struct zcrypt_queue *zq,\n\t\t\t\t       struct ap_message *ap_msg,\n\t\t\t\t       struct ica_rsa_modexpo_crt *crt)\n{\n\tstatic struct type6_hdr static_type6_hdrX = {\n\t\t.type\t\t=  0x06,\n\t\t.offset1\t=  0x00000058,\n\t\t.agent_id\t= {'C', 'A',},\n\t\t.function_code\t= {'P', 'D'},\n\t};\n\tstatic struct function_and_rules_block static_pkd_fnr = {\n\t\t.function_code\t= {'P', 'D'},\n\t\t.ulen\t\t= 10,\n\t\t.only_rule\t= {'Z', 'E', 'R', 'O', '-', 'P', 'A', 'D'}\n\t};\n\n\tstruct {\n\t\tstruct type6_hdr hdr;\n\t\tstruct CPRBX cprbx;\n\t\tstruct function_and_rules_block fr;\n\t\tunsigned short length;\n\t\tchar text[];\n\t} __packed * msg = ap_msg->msg;\n\tint size;\n\n\t \n\tif (WARN_ON_ONCE(crt->inputdatalength > PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\t \n\tmsg->length = crt->inputdatalength + 2;\n\tif (copy_from_user(msg->text, crt->inputdata, crt->inputdatalength))\n\t\treturn -EFAULT;\n\n\t \n\tsize = zcrypt_type6_crt_key(crt, msg->text + crt->inputdatalength);\n\tif (size < 0)\n\t\treturn size;\n\tsize += sizeof(*msg) + crt->inputdatalength;\t \n\n\t \n\tmsg->hdr = static_type6_hdrX;\n\tmsg->hdr.tocardlen1 = size -  sizeof(msg->hdr);\n\tmsg->hdr.fromcardlen1 = CEXXC_MAX_ICA_RESPONSE_SIZE - sizeof(msg->hdr);\n\n\tmsg->cprbx = static_cprbx;\n\tmsg->cprbx.domain = AP_QID_QUEUE(zq->queue->qid);\n\tmsg->cprbx.req_parml = msg->cprbx.rpl_msgbl =\n\t\tsize - sizeof(msg->hdr) - sizeof(msg->cprbx);\n\n\tmsg->fr = static_pkd_fnr;\n\n\tap_msg->len = size;\n\treturn 0;\n}\n\n \nstruct type86_fmt2_msg {\n\tstruct type86_hdr hdr;\n\tstruct type86_fmt2_ext fmt2;\n} __packed;\n\nstatic int xcrb_msg_to_type6cprb_msgx(bool userspace, struct ap_message *ap_msg,\n\t\t\t\t      struct ica_xcRB *xcrb,\n\t\t\t\t      unsigned int *fcode,\n\t\t\t\t      unsigned short **dom)\n{\n\tstatic struct type6_hdr static_type6_hdrX = {\n\t\t.type\t\t=  0x06,\n\t\t.offset1\t=  0x00000058,\n\t};\n\tstruct {\n\t\tstruct type6_hdr hdr;\n\t\tunion {\n\t\t\tstruct CPRBX cprbx;\n\t\t\tDECLARE_FLEX_ARRAY(u8, userdata);\n\t\t};\n\t} __packed * msg = ap_msg->msg;\n\n\tint rcblen = CEIL4(xcrb->request_control_blk_length);\n\tint req_sumlen, resp_sumlen;\n\tchar *req_data = ap_msg->msg + sizeof(struct type6_hdr) + rcblen;\n\tchar *function_code;\n\n\tif (CEIL4(xcrb->request_control_blk_length) <\n\t\t\txcrb->request_control_blk_length)\n\t\treturn -EINVAL;  \n\n\t \n\tap_msg->len = sizeof(struct type6_hdr) +\n\t\tCEIL4(xcrb->request_control_blk_length) +\n\t\txcrb->request_data_length;\n\tif (ap_msg->len > ap_msg->bufsize)\n\t\treturn -EINVAL;\n\n\t \n\treq_sumlen = CEIL4(xcrb->request_control_blk_length) +\n\t\t\txcrb->request_data_length;\n\tif ((CEIL4(xcrb->request_control_blk_length) <=\n\t     xcrb->request_data_length) ?\n\t    req_sumlen < xcrb->request_data_length :\n\t    req_sumlen < CEIL4(xcrb->request_control_blk_length)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (CEIL4(xcrb->reply_control_blk_length) <\n\t\t\txcrb->reply_control_blk_length)\n\t\treturn -EINVAL;  \n\n\t \n\tresp_sumlen = CEIL4(xcrb->reply_control_blk_length) +\n\t\t\txcrb->reply_data_length;\n\tif ((CEIL4(xcrb->reply_control_blk_length) <=\n\t     xcrb->reply_data_length) ?\n\t    resp_sumlen < xcrb->reply_data_length :\n\t    resp_sumlen < CEIL4(xcrb->reply_control_blk_length)) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmsg->hdr = static_type6_hdrX;\n\tmemcpy(msg->hdr.agent_id, &xcrb->agent_ID, sizeof(xcrb->agent_ID));\n\tmsg->hdr.tocardlen1 = xcrb->request_control_blk_length;\n\tif (xcrb->request_data_length) {\n\t\tmsg->hdr.offset2 = msg->hdr.offset1 + rcblen;\n\t\tmsg->hdr.tocardlen2 = xcrb->request_data_length;\n\t}\n\tmsg->hdr.fromcardlen1 = xcrb->reply_control_blk_length;\n\tmsg->hdr.fromcardlen2 = xcrb->reply_data_length;\n\n\t \n\tif (z_copy_from_user(userspace, msg->userdata,\n\t\t\t     xcrb->request_control_blk_addr,\n\t\t\t     xcrb->request_control_blk_length))\n\t\treturn -EFAULT;\n\tif (msg->cprbx.cprb_len + sizeof(msg->hdr.function_code) >\n\t    xcrb->request_control_blk_length)\n\t\treturn -EINVAL;\n\tfunction_code = ((unsigned char *)&msg->cprbx) + msg->cprbx.cprb_len;\n\tmemcpy(msg->hdr.function_code, function_code,\n\t       sizeof(msg->hdr.function_code));\n\n\t*fcode = (msg->hdr.function_code[0] << 8) | msg->hdr.function_code[1];\n\t*dom = (unsigned short *)&msg->cprbx.domain;\n\n\t \n\tif (memcmp(function_code, \"US\", 2) == 0 ||\n\t    memcmp(function_code, \"AU\", 2) == 0)\n\t\tap_msg->flags |= AP_MSG_FLAG_SPECIAL;\n\n\t \n\tswitch (*(unsigned short *)(&msg->cprbx.func_id[0])) {\n\tcase 0x5432:  \n\t\tap_msg->flags |= AP_MSG_FLAG_USAGE;\n\t\tbreak;\n\tcase 0x5433:  \n\tcase 0x5435:  \n\tcase 0x5436:  \n\tcase 0x5437:  \n\t\tap_msg->flags |= AP_MSG_FLAG_ADMIN;\n\t\tbreak;\n\tdefault:\n\t\tZCRYPT_DBF_DBG(\"%s unknown CPRB minor version '%c%c'\\n\",\n\t\t\t       __func__, msg->cprbx.func_id[0],\n\t\t\t       msg->cprbx.func_id[1]);\n\t}\n\n\t \n\tif (xcrb->request_data_length &&\n\t    z_copy_from_user(userspace, req_data, xcrb->request_data_address,\n\t\t\t     xcrb->request_data_length))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int xcrb_msg_to_type6_ep11cprb_msgx(bool userspace, struct ap_message *ap_msg,\n\t\t\t\t\t   struct ep11_urb *xcrb,\n\t\t\t\t\t   unsigned int *fcode,\n\t\t\t\t\t   unsigned int *domain)\n{\n\tunsigned int lfmt;\n\tstatic struct type6_hdr static_type6_ep11_hdr = {\n\t\t.type\t\t=  0x06,\n\t\t.rqid\t\t= {0x00, 0x01},\n\t\t.function_code\t= {0x00, 0x00},\n\t\t.agent_id[0]\t=  0x58,\t \n\t\t.agent_id[1]\t=  0x43,\t \n\t\t.offset1\t=  0x00000058,\n\t};\n\n\tstruct {\n\t\tstruct type6_hdr hdr;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tstruct ep11_cprb cprbx;\n\t\t\t\tunsigned char pld_tag;     \n\t\t\t\tunsigned char pld_lenfmt;  \n\t\t\t} __packed;\n\t\t\tDECLARE_FLEX_ARRAY(u8, userdata);\n\t\t};\n\t} __packed * msg = ap_msg->msg;\n\n\tstruct pld_hdr {\n\t\tunsigned char\tfunc_tag;\t \n\t\tunsigned char\tfunc_len;\t \n\t\tunsigned int\tfunc_val;\t \n\t\tunsigned char\tdom_tag;\t \n\t\tunsigned char\tdom_len;\t \n\t\tunsigned int\tdom_val;\t \n\t} __packed * payload_hdr = NULL;\n\n\tif (CEIL4(xcrb->req_len) < xcrb->req_len)\n\t\treturn -EINVAL;  \n\n\t \n\tap_msg->len = sizeof(struct type6_hdr) + CEIL4(xcrb->req_len);\n\tif (ap_msg->len > ap_msg->bufsize)\n\t\treturn -EINVAL;\n\n\tif (CEIL4(xcrb->resp_len) < xcrb->resp_len)\n\t\treturn -EINVAL;  \n\n\t \n\tmsg->hdr = static_type6_ep11_hdr;\n\tmsg->hdr.tocardlen1   = xcrb->req_len;\n\tmsg->hdr.fromcardlen1 = xcrb->resp_len;\n\n\t \n\tif (z_copy_from_user(userspace, msg->userdata,\n\t\t\t     (char __force __user *)xcrb->req, xcrb->req_len)) {\n\t\treturn -EFAULT;\n\t}\n\n\tif ((msg->pld_lenfmt & 0x80) == 0x80) {  \n\t\tswitch (msg->pld_lenfmt & 0x03) {\n\t\tcase 1:\n\t\t\tlfmt = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlfmt = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tlfmt = 1;  \n\t}\n\tpayload_hdr = (struct pld_hdr *)((&msg->pld_lenfmt) + lfmt);\n\t*fcode = payload_hdr->func_val & 0xFFFF;\n\n\t \n\tif (msg->cprbx.flags & 0x20)\n\t\tap_msg->flags |= AP_MSG_FLAG_SPECIAL;\n\n\t \n\tif (msg->cprbx.flags & 0x80)\n\t\tap_msg->flags |= AP_MSG_FLAG_ADMIN;\n\telse\n\t\tap_msg->flags |= AP_MSG_FLAG_USAGE;\n\n\t*domain = msg->cprbx.target_id;\n\n\treturn 0;\n}\n\n \nstruct type86x_reply {\n\tstruct type86_hdr hdr;\n\tstruct type86_fmt2_ext fmt2;\n\tstruct CPRBX cprbx;\n\tunsigned char pad[4];\t \n\tunsigned short length;\t \n\tchar data[];\n} __packed;\n\nstruct type86_ep11_reply {\n\tstruct type86_hdr hdr;\n\tstruct type86_fmt2_ext fmt2;\n\tstruct ep11_cprb cprbx;\n} __packed;\n\nstatic int convert_type86_ica(struct zcrypt_queue *zq,\n\t\t\t      struct ap_message *reply,\n\t\t\t      char __user *outputdata,\n\t\t\t      unsigned int outputdatalength)\n{\n\tstruct type86x_reply *msg = reply->msg;\n\tunsigned short service_rc, service_rs;\n\tunsigned int data_len;\n\n\tservice_rc = msg->cprbx.ccp_rtcode;\n\tif (unlikely(service_rc != 0)) {\n\t\tservice_rs = msg->cprbx.ccp_rscode;\n\t\tif ((service_rc == 8 && service_rs == 66) ||\n\t\t    (service_rc == 8 && service_rs == 65) ||\n\t\t    (service_rc == 8 && service_rs == 72) ||\n\t\t    (service_rc == 8 && service_rs == 770) ||\n\t\t    (service_rc == 12 && service_rs == 769)) {\n\t\t\tZCRYPT_DBF_WARN(\"%s dev=%02x.%04x rc/rs=%d/%d => rc=EINVAL\\n\",\n\t\t\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\t\t\tAP_QID_QUEUE(zq->queue->qid),\n\t\t\t\t\t(int)service_rc, (int)service_rs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tzq->online = 0;\n\t\tpr_err(\"Crypto dev=%02x.%04x rc/rs=%d/%d online=0 rc=EAGAIN\\n\",\n\t\t       AP_QID_CARD(zq->queue->qid),\n\t\t       AP_QID_QUEUE(zq->queue->qid),\n\t\t       (int)service_rc, (int)service_rs);\n\t\tZCRYPT_DBF_ERR(\"%s dev=%02x.%04x rc/rs=%d/%d => online=0 rc=EAGAIN\\n\",\n\t\t\t       __func__, AP_QID_CARD(zq->queue->qid),\n\t\t\t       AP_QID_QUEUE(zq->queue->qid),\n\t\t\t       (int)service_rc, (int)service_rs);\n\t\tap_send_online_uevent(&zq->queue->ap_dev, zq->online);\n\t\treturn -EAGAIN;\n\t}\n\tdata_len = msg->length - sizeof(msg->length);\n\tif (data_len > outputdatalength)\n\t\treturn -EMSGSIZE;\n\n\t \n\tif (copy_to_user(outputdata, msg->data, data_len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int convert_type86_xcrb(bool userspace, struct zcrypt_queue *zq,\n\t\t\t       struct ap_message *reply,\n\t\t\t       struct ica_xcRB *xcrb)\n{\n\tstruct type86_fmt2_msg *msg = reply->msg;\n\tchar *data = reply->msg;\n\n\t \n\tif (xcrb->reply_control_blk_length < msg->fmt2.count1) {\n\t\tZCRYPT_DBF_DBG(\"%s reply_control_blk_length %u < required %u => EMSGSIZE\\n\",\n\t\t\t       __func__, xcrb->reply_control_blk_length,\n\t\t\t       msg->fmt2.count1);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (z_copy_to_user(userspace, xcrb->reply_control_blk_addr,\n\t\t\t   data + msg->fmt2.offset1, msg->fmt2.count1))\n\t\treturn -EFAULT;\n\txcrb->reply_control_blk_length = msg->fmt2.count1;\n\n\t \n\tif (msg->fmt2.count2) {\n\t\tif (xcrb->reply_data_length < msg->fmt2.count2) {\n\t\t\tZCRYPT_DBF_DBG(\"%s reply_data_length %u < required %u => EMSGSIZE\\n\",\n\t\t\t\t       __func__, xcrb->reply_data_length,\n\t\t\t\t       msg->fmt2.count2);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\tif (z_copy_to_user(userspace, xcrb->reply_data_addr,\n\t\t\t\t   data + msg->fmt2.offset2, msg->fmt2.count2))\n\t\t\treturn -EFAULT;\n\t}\n\txcrb->reply_data_length = msg->fmt2.count2;\n\n\treturn 0;\n}\n\n \nstatic int convert_type86_ep11_xcrb(bool userspace, struct zcrypt_queue *zq,\n\t\t\t\t    struct ap_message *reply,\n\t\t\t\t    struct ep11_urb *xcrb)\n{\n\tstruct type86_fmt2_msg *msg = reply->msg;\n\tchar *data = reply->msg;\n\n\tif (xcrb->resp_len < msg->fmt2.count1) {\n\t\tZCRYPT_DBF_DBG(\"%s resp_len %u < required %u => EMSGSIZE\\n\",\n\t\t\t       __func__, (unsigned int)xcrb->resp_len,\n\t\t\t       msg->fmt2.count1);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tif (z_copy_to_user(userspace, (char __force __user *)xcrb->resp,\n\t\t\t   data + msg->fmt2.offset1, msg->fmt2.count1))\n\t\treturn -EFAULT;\n\txcrb->resp_len = msg->fmt2.count1;\n\treturn 0;\n}\n\nstatic int convert_type86_rng(struct zcrypt_queue *zq,\n\t\t\t      struct ap_message *reply,\n\t\t\t      char *buffer)\n{\n\tstruct {\n\t\tstruct type86_hdr hdr;\n\t\tstruct type86_fmt2_ext fmt2;\n\t\tstruct CPRBX cprbx;\n\t} __packed * msg = reply->msg;\n\tchar *data = reply->msg;\n\n\tif (msg->cprbx.ccp_rtcode != 0 || msg->cprbx.ccp_rscode != 0)\n\t\treturn -EINVAL;\n\tmemcpy(buffer, data + msg->fmt2.offset2, msg->fmt2.count2);\n\treturn msg->fmt2.count2;\n}\n\nstatic int convert_response_ica(struct zcrypt_queue *zq,\n\t\t\t\tstruct ap_message *reply,\n\t\t\t\tchar __user *outputdata,\n\t\t\t\tunsigned int outputdatalength)\n{\n\tstruct type86x_reply *msg = reply->msg;\n\n\tswitch (msg->hdr.type) {\n\tcase TYPE82_RSP_CODE:\n\tcase TYPE88_RSP_CODE:\n\t\treturn convert_error(zq, reply);\n\tcase TYPE86_RSP_CODE:\n\t\tif (msg->cprbx.ccp_rtcode &&\n\t\t    msg->cprbx.ccp_rscode == 0x14f &&\n\t\t    outputdatalength > 256) {\n\t\t\tif (zq->zcard->max_exp_bit_length <= 17) {\n\t\t\t\tzq->zcard->max_exp_bit_length = 17;\n\t\t\t\treturn -EAGAIN;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (msg->hdr.reply_code)\n\t\t\treturn convert_error(zq, reply);\n\t\tif (msg->cprbx.cprb_ver_id == 0x02)\n\t\t\treturn convert_type86_ica(zq, reply,\n\t\t\t\t\t\t  outputdata, outputdatalength);\n\t\tfallthrough;\t \n\tdefault:\n\t\t \n\t\tzq->online = 0;\n\t\tpr_err(\"Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t       AP_QID_CARD(zq->queue->qid),\n\t\t       AP_QID_QUEUE(zq->queue->qid),\n\t\t       (int)msg->hdr.type);\n\t\tZCRYPT_DBF_ERR(\n\t\t\t\"%s dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\tAP_QID_QUEUE(zq->queue->qid), (int)msg->hdr.type);\n\t\tap_send_online_uevent(&zq->queue->ap_dev, zq->online);\n\t\treturn -EAGAIN;\n\t}\n}\n\nstatic int convert_response_xcrb(bool userspace, struct zcrypt_queue *zq,\n\t\t\t\t struct ap_message *reply,\n\t\t\t\t struct ica_xcRB *xcrb)\n{\n\tstruct type86x_reply *msg = reply->msg;\n\n\tswitch (msg->hdr.type) {\n\tcase TYPE82_RSP_CODE:\n\tcase TYPE88_RSP_CODE:\n\t\txcrb->status = 0x0008044DL;  \n\t\treturn convert_error(zq, reply);\n\tcase TYPE86_RSP_CODE:\n\t\tif (msg->hdr.reply_code) {\n\t\t\tmemcpy(&xcrb->status, msg->fmt2.apfs, sizeof(u32));\n\t\t\treturn convert_error(zq, reply);\n\t\t}\n\t\tif (msg->cprbx.cprb_ver_id == 0x02)\n\t\t\treturn convert_type86_xcrb(userspace, zq, reply, xcrb);\n\t\tfallthrough;\t \n\tdefault:  \n\t\txcrb->status = 0x0008044DL;  \n\t\tzq->online = 0;\n\t\tpr_err(\"Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t       AP_QID_CARD(zq->queue->qid),\n\t\t       AP_QID_QUEUE(zq->queue->qid),\n\t\t       (int)msg->hdr.type);\n\t\tZCRYPT_DBF_ERR(\n\t\t\t\"%s dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\tAP_QID_QUEUE(zq->queue->qid), (int)msg->hdr.type);\n\t\tap_send_online_uevent(&zq->queue->ap_dev, zq->online);\n\t\treturn -EAGAIN;\n\t}\n}\n\nstatic int convert_response_ep11_xcrb(bool userspace, struct zcrypt_queue *zq,\n\t\t\t\t      struct ap_message *reply, struct ep11_urb *xcrb)\n{\n\tstruct type86_ep11_reply *msg = reply->msg;\n\n\tswitch (msg->hdr.type) {\n\tcase TYPE82_RSP_CODE:\n\tcase TYPE87_RSP_CODE:\n\t\treturn convert_error(zq, reply);\n\tcase TYPE86_RSP_CODE:\n\t\tif (msg->hdr.reply_code)\n\t\t\treturn convert_error(zq, reply);\n\t\tif (msg->cprbx.cprb_ver_id == 0x04)\n\t\t\treturn convert_type86_ep11_xcrb(userspace, zq, reply, xcrb);\n\t\tfallthrough;\t \n\tdefault:  \n\t\tzq->online = 0;\n\t\tpr_err(\"Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t       AP_QID_CARD(zq->queue->qid),\n\t\t       AP_QID_QUEUE(zq->queue->qid),\n\t\t       (int)msg->hdr.type);\n\t\tZCRYPT_DBF_ERR(\n\t\t\t\"%s dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\tAP_QID_QUEUE(zq->queue->qid), (int)msg->hdr.type);\n\t\tap_send_online_uevent(&zq->queue->ap_dev, zq->online);\n\t\treturn -EAGAIN;\n\t}\n}\n\nstatic int convert_response_rng(struct zcrypt_queue *zq,\n\t\t\t\tstruct ap_message *reply,\n\t\t\t\tchar *data)\n{\n\tstruct type86x_reply *msg = reply->msg;\n\n\tswitch (msg->hdr.type) {\n\tcase TYPE82_RSP_CODE:\n\tcase TYPE88_RSP_CODE:\n\t\treturn -EINVAL;\n\tcase TYPE86_RSP_CODE:\n\t\tif (msg->hdr.reply_code)\n\t\t\treturn -EINVAL;\n\t\tif (msg->cprbx.cprb_ver_id == 0x02)\n\t\t\treturn convert_type86_rng(zq, reply, data);\n\t\tfallthrough;\t \n\tdefault:  \n\t\tzq->online = 0;\n\t\tpr_err(\"Crypto dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t       AP_QID_CARD(zq->queue->qid),\n\t\t       AP_QID_QUEUE(zq->queue->qid),\n\t\t       (int)msg->hdr.type);\n\t\tZCRYPT_DBF_ERR(\n\t\t\t\"%s dev=%02x.%04x unknown response type 0x%02x => online=0 rc=EAGAIN\\n\",\n\t\t\t__func__, AP_QID_CARD(zq->queue->qid),\n\t\t\tAP_QID_QUEUE(zq->queue->qid), (int)msg->hdr.type);\n\t\tap_send_online_uevent(&zq->queue->ap_dev, zq->online);\n\t\treturn -EAGAIN;\n\t}\n}\n\n \nstatic void zcrypt_msgtype6_receive(struct ap_queue *aq,\n\t\t\t\t    struct ap_message *msg,\n\t\t\t\t    struct ap_message *reply)\n{\n\tstatic struct error_hdr error_reply = {\n\t\t.type = TYPE82_RSP_CODE,\n\t\t.reply_code = REP82_ERROR_MACHINE_FAILURE,\n\t};\n\tstruct response_type *resp_type = msg->private;\n\tstruct type86x_reply *t86r;\n\tint len;\n\n\t \n\tif (!reply)\n\t\tgoto out;\t \n\tt86r = reply->msg;\n\tif (t86r->hdr.type == TYPE86_RSP_CODE &&\n\t    t86r->cprbx.cprb_ver_id == 0x02) {\n\t\tswitch (resp_type->type) {\n\t\tcase CEXXC_RESPONSE_TYPE_ICA:\n\t\t\tlen = sizeof(struct type86x_reply) + t86r->length;\n\t\t\tif (len > reply->bufsize || len > msg->bufsize ||\n\t\t\t    len != reply->len) {\n\t\t\t\tZCRYPT_DBF_DBG(\"%s len mismatch => EMSGSIZE\\n\", __func__);\n\t\t\t\tmsg->rc = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(msg->msg, reply->msg, len);\n\t\t\tmsg->len = len;\n\t\t\tbreak;\n\t\tcase CEXXC_RESPONSE_TYPE_XCRB:\n\t\t\tif (t86r->fmt2.count2)\n\t\t\t\tlen = t86r->fmt2.offset2 + t86r->fmt2.count2;\n\t\t\telse\n\t\t\t\tlen = t86r->fmt2.offset1 + t86r->fmt2.count1;\n\t\t\tif (len > reply->bufsize || len > msg->bufsize ||\n\t\t\t    len != reply->len) {\n\t\t\t\tZCRYPT_DBF_DBG(\"%s len mismatch => EMSGSIZE\\n\", __func__);\n\t\t\t\tmsg->rc = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(msg->msg, reply->msg, len);\n\t\t\tmsg->len = len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemcpy(msg->msg, &error_reply, sizeof(error_reply));\n\t\t\tmsg->len = sizeof(error_reply);\n\t\t}\n\t} else {\n\t\tmemcpy(msg->msg, reply->msg, sizeof(error_reply));\n\t\tmsg->len = sizeof(error_reply);\n\t}\nout:\n\tcomplete(&resp_type->work);\n}\n\n \nstatic void zcrypt_msgtype6_receive_ep11(struct ap_queue *aq,\n\t\t\t\t\t struct ap_message *msg,\n\t\t\t\t\t struct ap_message *reply)\n{\n\tstatic struct error_hdr error_reply = {\n\t\t.type = TYPE82_RSP_CODE,\n\t\t.reply_code = REP82_ERROR_MACHINE_FAILURE,\n\t};\n\tstruct response_type *resp_type = msg->private;\n\tstruct type86_ep11_reply *t86r;\n\tint len;\n\n\t \n\tif (!reply)\n\t\tgoto out;\t \n\tt86r = reply->msg;\n\tif (t86r->hdr.type == TYPE86_RSP_CODE &&\n\t    t86r->cprbx.cprb_ver_id == 0x04) {\n\t\tswitch (resp_type->type) {\n\t\tcase CEXXC_RESPONSE_TYPE_EP11:\n\t\t\tlen = t86r->fmt2.offset1 + t86r->fmt2.count1;\n\t\t\tif (len > reply->bufsize || len > msg->bufsize ||\n\t\t\t    len != reply->len) {\n\t\t\t\tZCRYPT_DBF_DBG(\"%s len mismatch => EMSGSIZE\\n\", __func__);\n\t\t\t\tmsg->rc = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(msg->msg, reply->msg, len);\n\t\t\tmsg->len = len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemcpy(msg->msg, &error_reply, sizeof(error_reply));\n\t\t\tmsg->len = sizeof(error_reply);\n\t\t}\n\t} else {\n\t\tmemcpy(msg->msg, reply->msg, sizeof(error_reply));\n\t\tmsg->len = sizeof(error_reply);\n\t}\nout:\n\tcomplete(&resp_type->work);\n}\n\nstatic atomic_t zcrypt_step = ATOMIC_INIT(0);\n\n \nstatic long zcrypt_msgtype6_modexpo(struct zcrypt_queue *zq,\n\t\t\t\t    struct ica_rsa_modexpo *mex,\n\t\t\t\t    struct ap_message *ap_msg)\n{\n\tstruct response_type resp_type = {\n\t\t.type = CEXXC_RESPONSE_TYPE_ICA,\n\t};\n\tint rc;\n\n\tap_msg->msg = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!ap_msg->msg)\n\t\treturn -ENOMEM;\n\tap_msg->bufsize = PAGE_SIZE;\n\tap_msg->receive = zcrypt_msgtype6_receive;\n\tap_msg->psmid = (((unsigned long)current->pid) << 32) +\n\t\tatomic_inc_return(&zcrypt_step);\n\tap_msg->private = &resp_type;\n\trc = icamex_msg_to_type6mex_msgx(zq, ap_msg, mex);\n\tif (rc)\n\t\tgoto out_free;\n\tinit_completion(&resp_type.work);\n\trc = ap_queue_message(zq->queue, ap_msg);\n\tif (rc)\n\t\tgoto out_free;\n\trc = wait_for_completion_interruptible(&resp_type.work);\n\tif (rc == 0) {\n\t\trc = ap_msg->rc;\n\t\tif (rc == 0)\n\t\t\trc = convert_response_ica(zq, ap_msg,\n\t\t\t\t\t\t  mex->outputdata,\n\t\t\t\t\t\t  mex->outputdatalength);\n\t} else {\n\t\t \n\t\tap_cancel_message(zq->queue, ap_msg);\n\t}\n\nout_free:\n\tfree_page((unsigned long)ap_msg->msg);\n\tap_msg->private = NULL;\n\tap_msg->msg = NULL;\n\treturn rc;\n}\n\n \nstatic long zcrypt_msgtype6_modexpo_crt(struct zcrypt_queue *zq,\n\t\t\t\t\tstruct ica_rsa_modexpo_crt *crt,\n\t\t\t\t\tstruct ap_message *ap_msg)\n{\n\tstruct response_type resp_type = {\n\t\t.type = CEXXC_RESPONSE_TYPE_ICA,\n\t};\n\tint rc;\n\n\tap_msg->msg = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!ap_msg->msg)\n\t\treturn -ENOMEM;\n\tap_msg->bufsize = PAGE_SIZE;\n\tap_msg->receive = zcrypt_msgtype6_receive;\n\tap_msg->psmid = (((unsigned long)current->pid) << 32) +\n\t\tatomic_inc_return(&zcrypt_step);\n\tap_msg->private = &resp_type;\n\trc = icacrt_msg_to_type6crt_msgx(zq, ap_msg, crt);\n\tif (rc)\n\t\tgoto out_free;\n\tinit_completion(&resp_type.work);\n\trc = ap_queue_message(zq->queue, ap_msg);\n\tif (rc)\n\t\tgoto out_free;\n\trc = wait_for_completion_interruptible(&resp_type.work);\n\tif (rc == 0) {\n\t\trc = ap_msg->rc;\n\t\tif (rc == 0)\n\t\t\trc = convert_response_ica(zq, ap_msg,\n\t\t\t\t\t\t  crt->outputdata,\n\t\t\t\t\t\t  crt->outputdatalength);\n\t} else {\n\t\t \n\t\tap_cancel_message(zq->queue, ap_msg);\n\t}\n\nout_free:\n\tfree_page((unsigned long)ap_msg->msg);\n\tap_msg->private = NULL;\n\tap_msg->msg = NULL;\n\treturn rc;\n}\n\n \nint prep_cca_ap_msg(bool userspace, struct ica_xcRB *xcrb,\n\t\t    struct ap_message *ap_msg,\n\t\t    unsigned int *func_code, unsigned short **dom)\n{\n\tstruct response_type resp_type = {\n\t\t.type = CEXXC_RESPONSE_TYPE_XCRB,\n\t};\n\n\tap_msg->bufsize = atomic_read(&ap_max_msg_size);\n\tap_msg->msg = kmalloc(ap_msg->bufsize, GFP_KERNEL);\n\tif (!ap_msg->msg)\n\t\treturn -ENOMEM;\n\tap_msg->receive = zcrypt_msgtype6_receive;\n\tap_msg->psmid = (((unsigned long)current->pid) << 32) +\n\t\t\t\tatomic_inc_return(&zcrypt_step);\n\tap_msg->private = kmemdup(&resp_type, sizeof(resp_type), GFP_KERNEL);\n\tif (!ap_msg->private)\n\t\treturn -ENOMEM;\n\treturn xcrb_msg_to_type6cprb_msgx(userspace, ap_msg, xcrb, func_code, dom);\n}\n\n \nstatic long zcrypt_msgtype6_send_cprb(bool userspace, struct zcrypt_queue *zq,\n\t\t\t\t      struct ica_xcRB *xcrb,\n\t\t\t\t      struct ap_message *ap_msg)\n{\n\tstruct response_type *rtype = ap_msg->private;\n\tstruct {\n\t\tstruct type6_hdr hdr;\n\t\tstruct CPRBX cprbx;\n\t\t \n\t} __packed * msg = ap_msg->msg;\n\tunsigned int max_payload_size;\n\tint rc, delta;\n\n\t \n\tmax_payload_size = zq->reply.bufsize - sizeof(struct type86_fmt2_msg);\n\n\t \n\tmsg->hdr.fromcardlen1 = min(msg->hdr.fromcardlen1, max_payload_size);\n\tmsg->hdr.fromcardlen2 = min(msg->hdr.fromcardlen2, max_payload_size);\n\n\t \n\tdelta = msg->hdr.fromcardlen1 + msg->hdr.fromcardlen2\n\t\t- max_payload_size;\n\tif (delta > 0) {\n\t\t \n\t\tif (delta > msg->hdr.fromcardlen1) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmsg->hdr.fromcardlen1 -= delta;\n\t}\n\n\tinit_completion(&rtype->work);\n\trc = ap_queue_message(zq->queue, ap_msg);\n\tif (rc)\n\t\tgoto out;\n\trc = wait_for_completion_interruptible(&rtype->work);\n\tif (rc == 0) {\n\t\trc = ap_msg->rc;\n\t\tif (rc == 0)\n\t\t\trc = convert_response_xcrb(userspace, zq, ap_msg, xcrb);\n\t} else {\n\t\t \n\t\tap_cancel_message(zq->queue, ap_msg);\n\t}\n\n\tif (rc == -EAGAIN && ap_msg->flags & AP_MSG_FLAG_ADMIN)\n\t\trc = -EIO;  \n\nout:\n\tif (rc)\n\t\tZCRYPT_DBF_DBG(\"%s send cprb at dev=%02x.%04x rc=%d\\n\",\n\t\t\t       __func__, AP_QID_CARD(zq->queue->qid),\n\t\t\t       AP_QID_QUEUE(zq->queue->qid), rc);\n\treturn rc;\n}\n\n \nint prep_ep11_ap_msg(bool userspace, struct ep11_urb *xcrb,\n\t\t     struct ap_message *ap_msg,\n\t\t     unsigned int *func_code, unsigned int *domain)\n{\n\tstruct response_type resp_type = {\n\t\t.type = CEXXC_RESPONSE_TYPE_EP11,\n\t};\n\n\tap_msg->bufsize = atomic_read(&ap_max_msg_size);\n\tap_msg->msg = kmalloc(ap_msg->bufsize, GFP_KERNEL);\n\tif (!ap_msg->msg)\n\t\treturn -ENOMEM;\n\tap_msg->receive = zcrypt_msgtype6_receive_ep11;\n\tap_msg->psmid = (((unsigned long)current->pid) << 32) +\n\t\t\t\tatomic_inc_return(&zcrypt_step);\n\tap_msg->private = kmemdup(&resp_type, sizeof(resp_type), GFP_KERNEL);\n\tif (!ap_msg->private)\n\t\treturn -ENOMEM;\n\treturn xcrb_msg_to_type6_ep11cprb_msgx(userspace, ap_msg, xcrb,\n\t\t\t\t\t       func_code, domain);\n}\n\n \nstatic long zcrypt_msgtype6_send_ep11_cprb(bool userspace, struct zcrypt_queue *zq,\n\t\t\t\t\t   struct ep11_urb *xcrb,\n\t\t\t\t\t   struct ap_message *ap_msg)\n{\n\tint rc;\n\tunsigned int lfmt;\n\tstruct response_type *rtype = ap_msg->private;\n\tstruct {\n\t\tstruct type6_hdr hdr;\n\t\tstruct ep11_cprb cprbx;\n\t\tunsigned char\tpld_tag;\t \n\t\tunsigned char\tpld_lenfmt;\t \n\t} __packed * msg = ap_msg->msg;\n\tstruct pld_hdr {\n\t\tunsigned char\tfunc_tag;\t \n\t\tunsigned char\tfunc_len;\t \n\t\tunsigned int\tfunc_val;\t \n\t\tunsigned char\tdom_tag;\t \n\t\tunsigned char\tdom_len;\t \n\t\tunsigned int\tdom_val;\t \n\t} __packed * payload_hdr = NULL;\n\n\t \n\tif (!((msg->cprbx.flags & 0x80) == 0x80)) {\n\t\tmsg->cprbx.target_id = (unsigned int)\n\t\t\t\t\tAP_QID_QUEUE(zq->queue->qid);\n\n\t\tif ((msg->pld_lenfmt & 0x80) == 0x80) {  \n\t\t\tswitch (msg->pld_lenfmt & 0x03) {\n\t\t\tcase 1:\n\t\t\t\tlfmt = 2;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlfmt = 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tlfmt = 1;  \n\t\t}\n\t\tpayload_hdr = (struct pld_hdr *)((&msg->pld_lenfmt) + lfmt);\n\t\tpayload_hdr->dom_val = (unsigned int)\n\t\t\t\t\tAP_QID_QUEUE(zq->queue->qid);\n\t}\n\n\t \n\tmsg->hdr.fromcardlen1 = zq->reply.bufsize -\n\t\tsizeof(struct type86_hdr) - sizeof(struct type86_fmt2_ext);\n\n\tinit_completion(&rtype->work);\n\trc = ap_queue_message(zq->queue, ap_msg);\n\tif (rc)\n\t\tgoto out;\n\trc = wait_for_completion_interruptible(&rtype->work);\n\tif (rc == 0) {\n\t\trc = ap_msg->rc;\n\t\tif (rc == 0)\n\t\t\trc = convert_response_ep11_xcrb(userspace, zq, ap_msg, xcrb);\n\t} else {\n\t\t \n\t\tap_cancel_message(zq->queue, ap_msg);\n\t}\n\n\tif (rc == -EAGAIN && ap_msg->flags & AP_MSG_FLAG_ADMIN)\n\t\trc = -EIO;  \n\nout:\n\tif (rc)\n\t\tZCRYPT_DBF_DBG(\"%s send cprb at dev=%02x.%04x rc=%d\\n\",\n\t\t\t       __func__, AP_QID_CARD(zq->queue->qid),\n\t\t\t       AP_QID_QUEUE(zq->queue->qid), rc);\n\treturn rc;\n}\n\nint prep_rng_ap_msg(struct ap_message *ap_msg, int *func_code,\n\t\t    unsigned int *domain)\n{\n\tstruct response_type resp_type = {\n\t\t.type = CEXXC_RESPONSE_TYPE_XCRB,\n\t};\n\n\tap_msg->bufsize = AP_DEFAULT_MAX_MSG_SIZE;\n\tap_msg->msg = kmalloc(ap_msg->bufsize, GFP_KERNEL);\n\tif (!ap_msg->msg)\n\t\treturn -ENOMEM;\n\tap_msg->receive = zcrypt_msgtype6_receive;\n\tap_msg->psmid = (((unsigned long)current->pid) << 32) +\n\t\t\t\tatomic_inc_return(&zcrypt_step);\n\tap_msg->private = kmemdup(&resp_type, sizeof(resp_type), GFP_KERNEL);\n\tif (!ap_msg->private)\n\t\treturn -ENOMEM;\n\n\trng_type6cprb_msgx(ap_msg, ZCRYPT_RNG_BUFFER_SIZE, domain);\n\n\t*func_code = HWRNG;\n\treturn 0;\n}\n\n \nstatic long zcrypt_msgtype6_rng(struct zcrypt_queue *zq,\n\t\t\t\tchar *buffer, struct ap_message *ap_msg)\n{\n\tstruct {\n\t\tstruct type6_hdr hdr;\n\t\tstruct CPRBX cprbx;\n\t\tchar function_code[2];\n\t\tshort int rule_length;\n\t\tchar rule[8];\n\t\tshort int verb_length;\n\t\tshort int key_length;\n\t} __packed * msg = ap_msg->msg;\n\tstruct response_type *rtype = ap_msg->private;\n\tint rc;\n\n\tmsg->cprbx.domain = AP_QID_QUEUE(zq->queue->qid);\n\n\tinit_completion(&rtype->work);\n\trc = ap_queue_message(zq->queue, ap_msg);\n\tif (rc)\n\t\tgoto out;\n\trc = wait_for_completion_interruptible(&rtype->work);\n\tif (rc == 0) {\n\t\trc = ap_msg->rc;\n\t\tif (rc == 0)\n\t\t\trc = convert_response_rng(zq, ap_msg, buffer);\n\t} else {\n\t\t \n\t\tap_cancel_message(zq->queue, ap_msg);\n\t}\nout:\n\treturn rc;\n}\n\n \n\nstatic struct zcrypt_ops zcrypt_msgtype6_ops = {\n\t.owner = THIS_MODULE,\n\t.name = MSGTYPE06_NAME,\n\t.variant = MSGTYPE06_VARIANT_DEFAULT,\n\t.rsa_modexpo = zcrypt_msgtype6_modexpo,\n\t.rsa_modexpo_crt = zcrypt_msgtype6_modexpo_crt,\n\t.send_cprb = zcrypt_msgtype6_send_cprb,\n\t.rng = zcrypt_msgtype6_rng,\n};\n\nstatic struct zcrypt_ops zcrypt_msgtype6_ep11_ops = {\n\t.owner = THIS_MODULE,\n\t.name = MSGTYPE06_NAME,\n\t.variant = MSGTYPE06_VARIANT_EP11,\n\t.rsa_modexpo = NULL,\n\t.rsa_modexpo_crt = NULL,\n\t.send_ep11_cprb = zcrypt_msgtype6_send_ep11_cprb,\n};\n\nvoid __init zcrypt_msgtype6_init(void)\n{\n\tzcrypt_msgtype_register(&zcrypt_msgtype6_ops);\n\tzcrypt_msgtype_register(&zcrypt_msgtype6_ep11_ops);\n}\n\nvoid __exit zcrypt_msgtype6_exit(void)\n{\n\tzcrypt_msgtype_unregister(&zcrypt_msgtype6_ops);\n\tzcrypt_msgtype_unregister(&zcrypt_msgtype6_ep11_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}