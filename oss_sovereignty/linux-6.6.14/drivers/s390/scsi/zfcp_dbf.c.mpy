{
  "module_name": "zfcp_dbf.c",
  "hash_id": "8fdaa42978a60b53907b26cb8dd19b497359507997e6c4b71e0b383870cea053",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_dbf.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <asm/debug.h>\n#include \"zfcp_dbf.h\"\n#include \"zfcp_ext.h\"\n#include \"zfcp_fc.h\"\n\nstatic u32 dbfsize = 4;\n\nmodule_param(dbfsize, uint, 0400);\nMODULE_PARM_DESC(dbfsize,\n\t\t \"number of pages for each debug feature area (default 4)\");\n\nstatic u32 dbflevel = 3;\n\nmodule_param(dbflevel, uint, 0400);\nMODULE_PARM_DESC(dbflevel,\n\t\t \"log level for each debug feature area \"\n\t\t \"(default 3, range 0..6)\");\n\nstatic inline unsigned int zfcp_dbf_plen(unsigned int offset)\n{\n\treturn sizeof(struct zfcp_dbf_pay) + offset - ZFCP_DBF_PAY_MAX_REC;\n}\n\nstatic inline\nvoid zfcp_dbf_pl_write(struct zfcp_dbf *dbf, void *data, u16 length, char *area,\n\t\t       u64 req_id)\n{\n\tstruct zfcp_dbf_pay *pl = &dbf->pay_buf;\n\tu16 offset = 0, rec_length;\n\n\tspin_lock(&dbf->pay_lock);\n\tmemset(pl, 0, sizeof(*pl));\n\tpl->fsf_req_id = req_id;\n\tmemcpy(pl->area, area, ZFCP_DBF_TAG_LEN);\n\n\twhile (offset < length) {\n\t\trec_length = min((u16) ZFCP_DBF_PAY_MAX_REC,\n\t\t\t\t (u16) (length - offset));\n\t\tmemcpy(pl->data, data + offset, rec_length);\n\t\tdebug_event(dbf->pay, 1, pl, zfcp_dbf_plen(rec_length));\n\n\t\toffset += rec_length;\n\t\tpl->counter++;\n\t}\n\n\tspin_unlock(&dbf->pay_lock);\n}\n\n \nvoid zfcp_dbf_hba_fsf_res(char *tag, int level, struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_dbf *dbf = req->adapter->dbf;\n\tstruct fsf_qtcb_prefix *q_pref = &req->qtcb->prefix;\n\tstruct fsf_qtcb_header *q_head = &req->qtcb->header;\n\tstruct zfcp_dbf_hba *rec = &dbf->hba_buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dbf->hba_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\trec->id = ZFCP_DBF_HBA_RES;\n\trec->fsf_req_id = req->req_id;\n\trec->fsf_req_status = req->status;\n\trec->fsf_cmd = q_head->fsf_command;\n\trec->fsf_seq_no = q_pref->req_seq_no;\n\trec->u.res.req_issued = req->issued;\n\trec->u.res.prot_status = q_pref->prot_status;\n\trec->u.res.fsf_status = q_head->fsf_status;\n\trec->u.res.port_handle = q_head->port_handle;\n\trec->u.res.lun_handle = q_head->lun_handle;\n\n\tmemcpy(rec->u.res.prot_status_qual, &q_pref->prot_status_qual,\n\t       FSF_PROT_STATUS_QUAL_SIZE);\n\tmemcpy(rec->u.res.fsf_status_qual, &q_head->fsf_status_qual,\n\t       FSF_STATUS_QUALIFIER_SIZE);\n\n\trec->pl_len = q_head->log_length;\n\tzfcp_dbf_pl_write(dbf, (char *)q_pref + q_head->log_start,\n\t\t\t  rec->pl_len, \"fsf_res\", req->req_id);\n\n\tdebug_event(dbf->hba, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->hba_lock, flags);\n}\n\n \nvoid zfcp_dbf_hba_fsf_fces(char *tag, const struct zfcp_fsf_req *req, u64 wwpn,\n\t\t\t   u32 fc_security_old, u32 fc_security_new)\n{\n\tstruct zfcp_dbf *dbf = req->adapter->dbf;\n\tstruct fsf_qtcb_prefix *q_pref = &req->qtcb->prefix;\n\tstruct fsf_qtcb_header *q_head = &req->qtcb->header;\n\tstruct zfcp_dbf_hba *rec = &dbf->hba_buf;\n\tstatic int const level = 3;\n\tunsigned long flags;\n\n\tif (unlikely(!debug_level_enabled(dbf->hba, level)))\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->hba_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\trec->id = ZFCP_DBF_HBA_FCES;\n\trec->fsf_req_id = req->req_id;\n\trec->fsf_req_status = req->status;\n\trec->fsf_cmd = q_head->fsf_command;\n\trec->fsf_seq_no = q_pref->req_seq_no;\n\trec->u.fces.req_issued = req->issued;\n\trec->u.fces.fsf_status = q_head->fsf_status;\n\trec->u.fces.port_handle = q_head->port_handle;\n\trec->u.fces.wwpn = wwpn;\n\trec->u.fces.fc_security_old = fc_security_old;\n\trec->u.fces.fc_security_new = fc_security_new;\n\n\tdebug_event(dbf->hba, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->hba_lock, flags);\n}\n\n \nvoid zfcp_dbf_hba_fsf_reqid(const char *const tag, const int level,\n\t\t\t    struct zfcp_adapter *const adapter,\n\t\t\t    const u64 req_id)\n{\n\tstruct zfcp_dbf *const dbf = adapter->dbf;\n\tstruct zfcp_dbf_hba *const rec = &dbf->hba_buf;\n\tstruct zfcp_dbf_hba_res *const res = &rec->u.res;\n\tunsigned long flags;\n\n\tif (unlikely(!debug_level_enabled(dbf->hba, level)))\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->hba_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\n\trec->id = ZFCP_DBF_HBA_RES;\n\trec->fsf_req_id = req_id;\n\trec->fsf_req_status = ~0u;\n\trec->fsf_cmd = ~0u;\n\trec->fsf_seq_no = ~0u;\n\n\tres->req_issued = ~0ull;\n\tres->prot_status = ~0u;\n\tmemset(res->prot_status_qual, 0xff, sizeof(res->prot_status_qual));\n\tres->fsf_status = ~0u;\n\tmemset(res->fsf_status_qual, 0xff, sizeof(res->fsf_status_qual));\n\tres->port_handle = ~0u;\n\tres->lun_handle = ~0u;\n\n\tdebug_event(dbf->hba, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->hba_lock, flags);\n}\n\n \nvoid zfcp_dbf_hba_fsf_uss(char *tag, struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_dbf *dbf = req->adapter->dbf;\n\tstruct fsf_status_read_buffer *srb = req->data;\n\tstruct zfcp_dbf_hba *rec = &dbf->hba_buf;\n\tstatic int const level = 2;\n\tunsigned long flags;\n\n\tif (unlikely(!debug_level_enabled(dbf->hba, level)))\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->hba_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\trec->id = ZFCP_DBF_HBA_USS;\n\trec->fsf_req_id = req->req_id;\n\trec->fsf_req_status = req->status;\n\trec->fsf_cmd = FSF_QTCB_UNSOLICITED_STATUS;\n\n\tif (!srb)\n\t\tgoto log;\n\n\trec->u.uss.status_type = srb->status_type;\n\trec->u.uss.status_subtype = srb->status_subtype;\n\trec->u.uss.d_id = ntoh24(srb->d_id);\n\trec->u.uss.lun = srb->fcp_lun;\n\tmemcpy(&rec->u.uss.queue_designator, &srb->queue_designator,\n\t       sizeof(rec->u.uss.queue_designator));\n\n\t \n\trec->pl_len = (!srb->length) ? 0 : srb->length -\n\t\t\toffsetof(struct fsf_status_read_buffer, payload);\n\n\tif (rec->pl_len)\n\t\tzfcp_dbf_pl_write(dbf, srb->payload.data, rec->pl_len,\n\t\t\t\t  \"fsf_uss\", req->req_id);\nlog:\n\tdebug_event(dbf->hba, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->hba_lock, flags);\n}\n\n \nvoid zfcp_dbf_hba_bit_err(char *tag, struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_dbf *dbf = req->adapter->dbf;\n\tstruct zfcp_dbf_hba *rec = &dbf->hba_buf;\n\tstruct fsf_status_read_buffer *sr_buf = req->data;\n\tstatic int const level = 1;\n\tunsigned long flags;\n\n\tif (unlikely(!debug_level_enabled(dbf->hba, level)))\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->hba_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\trec->id = ZFCP_DBF_HBA_BIT;\n\trec->fsf_req_id = req->req_id;\n\trec->fsf_req_status = req->status;\n\trec->fsf_cmd = FSF_QTCB_UNSOLICITED_STATUS;\n\tmemcpy(&rec->u.be, &sr_buf->payload.bit_error,\n\t       sizeof(struct fsf_bit_error_payload));\n\n\tdebug_event(dbf->hba, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->hba_lock, flags);\n}\n\n \nvoid zfcp_dbf_hba_def_err(struct zfcp_adapter *adapter, u64 req_id, u16 scount,\n\t\t\t  void **pl)\n{\n\tstruct zfcp_dbf *dbf = adapter->dbf;\n\tstruct zfcp_dbf_pay *payload = &dbf->pay_buf;\n\tunsigned long flags;\n\tstatic int const level = 1;\n\tu16 length;\n\n\tif (unlikely(!debug_level_enabled(dbf->pay, level)))\n\t\treturn;\n\n\tif (!pl)\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->pay_lock, flags);\n\tmemset(payload, 0, sizeof(*payload));\n\n\tmemcpy(payload->area, \"def_err\", 7);\n\tpayload->fsf_req_id = req_id;\n\tpayload->counter = 0;\n\tlength = min((u16)sizeof(struct qdio_buffer),\n\t\t     (u16)ZFCP_DBF_PAY_MAX_REC);\n\n\twhile (payload->counter < scount && (char *)pl[payload->counter]) {\n\t\tmemcpy(payload->data, (char *)pl[payload->counter], length);\n\t\tdebug_event(dbf->pay, level, payload, zfcp_dbf_plen(length));\n\t\tpayload->counter++;\n\t}\n\n\tspin_unlock_irqrestore(&dbf->pay_lock, flags);\n}\n\nstatic void zfcp_dbf_set_common(struct zfcp_dbf_rec *rec,\n\t\t\t\tstruct zfcp_adapter *adapter,\n\t\t\t\tstruct zfcp_port *port,\n\t\t\t\tstruct scsi_device *sdev)\n{\n\trec->adapter_status = atomic_read(&adapter->status);\n\tif (port) {\n\t\trec->port_status = atomic_read(&port->status);\n\t\trec->wwpn = port->wwpn;\n\t\trec->d_id = port->d_id;\n\t}\n\tif (sdev) {\n\t\trec->lun_status = atomic_read(&sdev_to_zfcp(sdev)->status);\n\t\trec->lun = zfcp_scsi_dev_lun(sdev);\n\t} else\n\t\trec->lun = ZFCP_DBF_INVALID_LUN;\n}\n\n \nvoid zfcp_dbf_rec_trig(char *tag, struct zfcp_adapter *adapter,\n\t\t       struct zfcp_port *port, struct scsi_device *sdev,\n\t\t       u8 want, u8 need)\n{\n\tstruct zfcp_dbf *dbf = adapter->dbf;\n\tstruct zfcp_dbf_rec *rec = &dbf->rec_buf;\n\tstatic int const level = 1;\n\tstruct list_head *entry;\n\tunsigned long flags;\n\n\tlockdep_assert_held(&adapter->erp_lock);\n\n\tif (unlikely(!debug_level_enabled(dbf->rec, level)))\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->rec_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\trec->id = ZFCP_DBF_REC_TRIG;\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\tzfcp_dbf_set_common(rec, adapter, port, sdev);\n\n\tlist_for_each(entry, &adapter->erp_ready_head)\n\t\trec->u.trig.ready++;\n\n\tlist_for_each(entry, &adapter->erp_running_head)\n\t\trec->u.trig.running++;\n\n\trec->u.trig.want = want;\n\trec->u.trig.need = need;\n\n\tdebug_event(dbf->rec, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->rec_lock, flags);\n}\n\n \nvoid zfcp_dbf_rec_trig_lock(char *tag, struct zfcp_adapter *adapter,\n\t\t\t    struct zfcp_port *port, struct scsi_device *sdev,\n\t\t\t    u8 want, u8 need)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&adapter->erp_lock, flags);\n\tzfcp_dbf_rec_trig(tag, adapter, port, sdev, want, need);\n\tread_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\n \nvoid zfcp_dbf_rec_run_lvl(int level, char *tag, struct zfcp_erp_action *erp)\n{\n\tstruct zfcp_dbf *dbf = erp->adapter->dbf;\n\tstruct zfcp_dbf_rec *rec = &dbf->rec_buf;\n\tunsigned long flags;\n\n\tif (!debug_level_enabled(dbf->rec, level))\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->rec_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\trec->id = ZFCP_DBF_REC_RUN;\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\tzfcp_dbf_set_common(rec, erp->adapter, erp->port, erp->sdev);\n\n\trec->u.run.fsf_req_id = erp->fsf_req_id;\n\trec->u.run.rec_status = erp->status;\n\trec->u.run.rec_step = erp->step;\n\trec->u.run.rec_action = erp->type;\n\n\tif (erp->sdev)\n\t\trec->u.run.rec_count =\n\t\t\tatomic_read(&sdev_to_zfcp(erp->sdev)->erp_counter);\n\telse if (erp->port)\n\t\trec->u.run.rec_count = atomic_read(&erp->port->erp_counter);\n\telse\n\t\trec->u.run.rec_count = atomic_read(&erp->adapter->erp_counter);\n\n\tdebug_event(dbf->rec, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->rec_lock, flags);\n}\n\n \nvoid zfcp_dbf_rec_run(char *tag, struct zfcp_erp_action *erp)\n{\n\tzfcp_dbf_rec_run_lvl(1, tag, erp);\n}\n\n \nvoid zfcp_dbf_rec_run_wka(char *tag, struct zfcp_fc_wka_port *wka_port,\n\t\t\t  u64 req_id)\n{\n\tstruct zfcp_dbf *dbf = wka_port->adapter->dbf;\n\tstruct zfcp_dbf_rec *rec = &dbf->rec_buf;\n\tstatic int const level = 1;\n\tunsigned long flags;\n\n\tif (unlikely(!debug_level_enabled(dbf->rec, level)))\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->rec_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\trec->id = ZFCP_DBF_REC_RUN;\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\trec->port_status = wka_port->status;\n\trec->d_id = wka_port->d_id;\n\trec->lun = ZFCP_DBF_INVALID_LUN;\n\n\trec->u.run.fsf_req_id = req_id;\n\trec->u.run.rec_status = ~0;\n\trec->u.run.rec_step = ~0;\n\trec->u.run.rec_action = ~0;\n\trec->u.run.rec_count = ~0;\n\n\tdebug_event(dbf->rec, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->rec_lock, flags);\n}\n\n#define ZFCP_DBF_SAN_LEVEL 1\n\nstatic inline\nvoid zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf,\n\t\t  char *paytag, struct scatterlist *sg, u8 id, u16 len,\n\t\t  u64 req_id, u32 d_id, u16 cap_len)\n{\n\tstruct zfcp_dbf_san *rec = &dbf->san_buf;\n\tu16 rec_len;\n\tunsigned long flags;\n\tstruct zfcp_dbf_pay *payload = &dbf->pay_buf;\n\tu16 pay_sum = 0;\n\n\tspin_lock_irqsave(&dbf->san_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\trec->id = id;\n\trec->fsf_req_id = req_id;\n\trec->d_id = d_id;\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\trec->pl_len = len;  \n\tif (!sg)\n\t\tgoto out;\n\trec_len = min_t(unsigned int, sg->length, ZFCP_DBF_SAN_MAX_PAYLOAD);\n\tmemcpy(rec->payload, sg_virt(sg), rec_len);  \n\tif (len <= rec_len)\n\t\tgoto out;  \n\n\t \n\tspin_lock(&dbf->pay_lock);\n\tmemset(payload, 0, sizeof(*payload));\n\tmemcpy(payload->area, paytag, ZFCP_DBF_TAG_LEN);\n\tpayload->fsf_req_id = req_id;\n\tpayload->counter = 0;\n\tfor (; sg && pay_sum < cap_len; sg = sg_next(sg)) {\n\t\tu16 pay_len, offset = 0;\n\n\t\twhile (offset < sg->length && pay_sum < cap_len) {\n\t\t\tpay_len = min((u16)ZFCP_DBF_PAY_MAX_REC,\n\t\t\t\t      (u16)(sg->length - offset));\n\t\t\t \n\t\t\tmemcpy(payload->data, sg_virt(sg) + offset, pay_len);\n\t\t\tdebug_event(dbf->pay, ZFCP_DBF_SAN_LEVEL, payload,\n\t\t\t\t    zfcp_dbf_plen(pay_len));\n\t\t\tpayload->counter++;\n\t\t\toffset += pay_len;\n\t\t\tpay_sum += pay_len;\n\t\t}\n\t}\n\tspin_unlock(&dbf->pay_lock);\n\nout:\n\tdebug_event(dbf->san, ZFCP_DBF_SAN_LEVEL, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->san_lock, flags);\n}\n\n \nvoid zfcp_dbf_san_req(char *tag, struct zfcp_fsf_req *fsf, u32 d_id)\n{\n\tstruct zfcp_dbf *dbf = fsf->adapter->dbf;\n\tstruct zfcp_fsf_ct_els *ct_els = fsf->data;\n\tu16 length;\n\n\tif (unlikely(!debug_level_enabled(dbf->san, ZFCP_DBF_SAN_LEVEL)))\n\t\treturn;\n\n\tlength = (u16)zfcp_qdio_real_bytes(ct_els->req);\n\tzfcp_dbf_san(tag, dbf, \"san_req\", ct_els->req, ZFCP_DBF_SAN_REQ,\n\t\t     length, fsf->req_id, d_id, length);\n}\n\nstatic u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,\n\t\t\t\t\t      struct zfcp_fsf_req *fsf,\n\t\t\t\t\t      u16 len)\n{\n\tstruct zfcp_fsf_ct_els *ct_els = fsf->data;\n\tstruct fc_ct_hdr *reqh = sg_virt(ct_els->req);\n\tstruct fc_ns_gid_ft *reqn = (struct fc_ns_gid_ft *)(reqh + 1);\n\tstruct scatterlist *resp_entry = ct_els->resp;\n\tstruct fc_ct_hdr *resph;\n\tstruct fc_gpn_ft_resp *acc;\n\tint max_entries, x, last = 0;\n\n\tif (!(memcmp(tag, \"fsscth2\", 7) == 0\n\t      && ct_els->d_id == FC_FID_DIR_SERV\n\t      && reqh->ct_rev == FC_CT_REV\n\t      && reqh->ct_in_id[0] == 0\n\t      && reqh->ct_in_id[1] == 0\n\t      && reqh->ct_in_id[2] == 0\n\t      && reqh->ct_fs_type == FC_FST_DIR\n\t      && reqh->ct_fs_subtype == FC_NS_SUBTYPE\n\t      && reqh->ct_options == 0\n\t      && reqh->_ct_resvd1 == 0\n\t      && reqh->ct_cmd == cpu_to_be16(FC_NS_GPN_FT)\n\t       \n\t      && reqh->_ct_resvd2 == 0\n\t      && reqh->ct_reason == 0\n\t      && reqh->ct_explan == 0\n\t      && reqh->ct_vendor == 0\n\t      && reqn->fn_resvd == 0\n\t      && reqn->fn_domain_id_scope == 0\n\t      && reqn->fn_area_id_scope == 0\n\t      && reqn->fn_fc4_type == FC_TYPE_FCP))\n\t\treturn len;  \n\n\tacc = sg_virt(resp_entry);\n\n\t \n\tresph = (struct fc_ct_hdr *)acc;\n\tif ((ct_els->status) ||\n\t    (resph->ct_cmd != cpu_to_be16(FC_FS_ACC)))\n\t\treturn max(FC_CT_HDR_LEN, ZFCP_DBF_SAN_MAX_PAYLOAD);\n\n\tmax_entries = (be16_to_cpu(reqh->ct_mr_size) * 4 /\n\t\t       sizeof(struct fc_gpn_ft_resp))\n\t\t+ 1  ;\n\n\t \n\tfor (x = 1; x < max_entries && !last; x++) {\n\t\tif (x % (ZFCP_FC_GPN_FT_ENT_PAGE + 1))\n\t\t\tacc++;\n\t\telse\n\t\t\tacc = sg_virt(++resp_entry);\n\n\t\tlast = acc->fp_flags & FC_NS_FID_LAST;\n\t}\n\tlen = min(len, (u16)(x * sizeof(struct fc_gpn_ft_resp)));\n\treturn len;  \n}\n\n \nvoid zfcp_dbf_san_res(char *tag, struct zfcp_fsf_req *fsf)\n{\n\tstruct zfcp_dbf *dbf = fsf->adapter->dbf;\n\tstruct zfcp_fsf_ct_els *ct_els = fsf->data;\n\tu16 length;\n\n\tif (unlikely(!debug_level_enabled(dbf->san, ZFCP_DBF_SAN_LEVEL)))\n\t\treturn;\n\n\tlength = (u16)zfcp_qdio_real_bytes(ct_els->resp);\n\tzfcp_dbf_san(tag, dbf, \"san_res\", ct_els->resp, ZFCP_DBF_SAN_RES,\n\t\t     length, fsf->req_id, ct_els->d_id,\n\t\t     zfcp_dbf_san_res_cap_len_if_gpn_ft(tag, fsf, length));\n}\n\n \nvoid zfcp_dbf_san_in_els(char *tag, struct zfcp_fsf_req *fsf)\n{\n\tstruct zfcp_dbf *dbf = fsf->adapter->dbf;\n\tstruct fsf_status_read_buffer *srb =\n\t\t(struct fsf_status_read_buffer *) fsf->data;\n\tu16 length;\n\tstruct scatterlist sg;\n\n\tif (unlikely(!debug_level_enabled(dbf->san, ZFCP_DBF_SAN_LEVEL)))\n\t\treturn;\n\n\tlength = (u16)(srb->length -\n\t\t\toffsetof(struct fsf_status_read_buffer, payload));\n\tsg_init_one(&sg, srb->payload.data, length);\n\tzfcp_dbf_san(tag, dbf, \"san_els\", &sg, ZFCP_DBF_SAN_ELS, length,\n\t\t     fsf->req_id, ntoh24(srb->d_id), length);\n}\n\n \nvoid zfcp_dbf_scsi_common(char *tag, int level, struct scsi_device *sdev,\n\t\t\t  struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)\n{\n\tstruct zfcp_adapter *adapter =\n\t\t(struct zfcp_adapter *) sdev->host->hostdata[0];\n\tstruct zfcp_dbf *dbf = adapter->dbf;\n\tstruct zfcp_dbf_scsi *rec = &dbf->scsi_buf;\n\tstruct fcp_resp_with_ext *fcp_rsp;\n\tstruct fcp_resp_rsp_info *fcp_rsp_info;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dbf->scsi_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\trec->id = ZFCP_DBF_SCSI_CMND;\n\tif (sc) {\n\t\trec->scsi_result = sc->result;\n\t\trec->scsi_retries = sc->retries;\n\t\trec->scsi_allowed = sc->allowed;\n\t\trec->scsi_id = sc->device->id;\n\t\trec->scsi_lun = (u32)sc->device->lun;\n\t\trec->scsi_lun_64_hi = (u32)(sc->device->lun >> 32);\n\t\trec->host_scribble = (u64)sc->host_scribble;\n\n\t\tmemcpy(rec->scsi_opcode, sc->cmnd,\n\t\t       min_t(int, sc->cmd_len, ZFCP_DBF_SCSI_OPCODE));\n\t} else {\n\t\trec->scsi_result = ~0;\n\t\trec->scsi_retries = ~0;\n\t\trec->scsi_allowed = ~0;\n\t\trec->scsi_id = sdev->id;\n\t\trec->scsi_lun = (u32)sdev->lun;\n\t\trec->scsi_lun_64_hi = (u32)(sdev->lun >> 32);\n\t\trec->host_scribble = ~0;\n\n\t\tmemset(rec->scsi_opcode, 0xff, ZFCP_DBF_SCSI_OPCODE);\n\t}\n\n\tif (fsf) {\n\t\trec->fsf_req_id = fsf->req_id;\n\t\trec->pl_len = FCP_RESP_WITH_EXT;\n\t\tfcp_rsp = &(fsf->qtcb->bottom.io.fcp_rsp.iu);\n\t\t \n\t\tmemcpy(&rec->fcp_rsp, fcp_rsp, FCP_RESP_WITH_EXT);\n\t\tif (fcp_rsp->resp.fr_flags & FCP_RSP_LEN_VAL) {\n\t\t\tfcp_rsp_info = (struct fcp_resp_rsp_info *) &fcp_rsp[1];\n\t\t\trec->fcp_rsp_info = fcp_rsp_info->rsp_code;\n\t\t\trec->pl_len += be32_to_cpu(fcp_rsp->ext.fr_rsp_len);\n\t\t}\n\t\tif (fcp_rsp->resp.fr_flags & FCP_SNS_LEN_VAL) {\n\t\t\trec->pl_len += be32_to_cpu(fcp_rsp->ext.fr_sns_len);\n\t\t}\n\t\t \n\t\tif (fcp_rsp->resp.fr_flags != 0)\n\t\t\tzfcp_dbf_pl_write(\n\t\t\t\tdbf, fcp_rsp,\n\t\t\t\t \n\t\t\t\tmin_t(u16, max_t(u16, rec->pl_len,\n\t\t\t\t\t\t ZFCP_DBF_PAY_MAX_REC),\n\t\t\t\t      FSF_FCP_RSP_SIZE),\n\t\t\t\t\"fcp_riu\", fsf->req_id);\n\t}\n\n\tdebug_event(dbf->scsi, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->scsi_lock, flags);\n}\n\n \nvoid zfcp_dbf_scsi_eh(char *tag, struct zfcp_adapter *adapter,\n\t\t      unsigned int scsi_id, int ret)\n{\n\tstruct zfcp_dbf *dbf = adapter->dbf;\n\tstruct zfcp_dbf_scsi *rec = &dbf->scsi_buf;\n\tunsigned long flags;\n\tstatic int const level = 1;\n\n\tif (unlikely(!debug_level_enabled(adapter->dbf->scsi, level)))\n\t\treturn;\n\n\tspin_lock_irqsave(&dbf->scsi_lock, flags);\n\tmemset(rec, 0, sizeof(*rec));\n\n\tmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\n\trec->id = ZFCP_DBF_SCSI_CMND;\n\trec->scsi_result = ret;  \n\trec->scsi_retries = ~0;\n\trec->scsi_allowed = ~0;\n\trec->fcp_rsp_info = ~0;\n\trec->scsi_id = scsi_id;\n\trec->scsi_lun = (u32)ZFCP_DBF_INVALID_LUN;\n\trec->scsi_lun_64_hi = (u32)(ZFCP_DBF_INVALID_LUN >> 32);\n\trec->host_scribble = ~0;\n\tmemset(rec->scsi_opcode, 0xff, ZFCP_DBF_SCSI_OPCODE);\n\n\tdebug_event(dbf->scsi, level, rec, sizeof(*rec));\n\tspin_unlock_irqrestore(&dbf->scsi_lock, flags);\n}\n\nstatic debug_info_t *zfcp_dbf_reg(const char *name, int size, int rec_size)\n{\n\tstruct debug_info *d;\n\n\td = debug_register(name, size, 1, rec_size);\n\tif (!d)\n\t\treturn NULL;\n\n\tdebug_register_view(d, &debug_hex_ascii_view);\n\tdebug_set_level(d, dbflevel);\n\n\treturn d;\n}\n\nstatic void zfcp_dbf_unregister(struct zfcp_dbf *dbf)\n{\n\tif (!dbf)\n\t\treturn;\n\n\tdebug_unregister(dbf->scsi);\n\tdebug_unregister(dbf->san);\n\tdebug_unregister(dbf->hba);\n\tdebug_unregister(dbf->pay);\n\tdebug_unregister(dbf->rec);\n\tkfree(dbf);\n}\n\n \nint zfcp_dbf_adapter_register(struct zfcp_adapter *adapter)\n{\n\tchar name[DEBUG_MAX_NAME_LEN];\n\tstruct zfcp_dbf *dbf;\n\n\tdbf = kzalloc(sizeof(struct zfcp_dbf), GFP_KERNEL);\n\tif (!dbf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dbf->pay_lock);\n\tspin_lock_init(&dbf->hba_lock);\n\tspin_lock_init(&dbf->san_lock);\n\tspin_lock_init(&dbf->scsi_lock);\n\tspin_lock_init(&dbf->rec_lock);\n\n\t \n\tsprintf(name, \"zfcp_%s_rec\", dev_name(&adapter->ccw_device->dev));\n\tdbf->rec = zfcp_dbf_reg(name, dbfsize, sizeof(struct zfcp_dbf_rec));\n\tif (!dbf->rec)\n\t\tgoto err_out;\n\n\t \n\tsprintf(name, \"zfcp_%s_hba\", dev_name(&adapter->ccw_device->dev));\n\tdbf->hba = zfcp_dbf_reg(name, dbfsize, sizeof(struct zfcp_dbf_hba));\n\tif (!dbf->hba)\n\t\tgoto err_out;\n\n\t \n\tsprintf(name, \"zfcp_%s_pay\", dev_name(&adapter->ccw_device->dev));\n\tdbf->pay = zfcp_dbf_reg(name, dbfsize * 2, sizeof(struct zfcp_dbf_pay));\n\tif (!dbf->pay)\n\t\tgoto err_out;\n\n\t \n\tsprintf(name, \"zfcp_%s_san\", dev_name(&adapter->ccw_device->dev));\n\tdbf->san = zfcp_dbf_reg(name, dbfsize, sizeof(struct zfcp_dbf_san));\n\tif (!dbf->san)\n\t\tgoto err_out;\n\n\t \n\tsprintf(name, \"zfcp_%s_scsi\", dev_name(&adapter->ccw_device->dev));\n\tdbf->scsi = zfcp_dbf_reg(name, dbfsize, sizeof(struct zfcp_dbf_scsi));\n\tif (!dbf->scsi)\n\t\tgoto err_out;\n\n\tadapter->dbf = dbf;\n\n\treturn 0;\nerr_out:\n\tzfcp_dbf_unregister(dbf);\n\treturn -ENOMEM;\n}\n\n \nvoid zfcp_dbf_adapter_unregister(struct zfcp_adapter *adapter)\n{\n\tstruct zfcp_dbf *dbf = adapter->dbf;\n\n\tadapter->dbf = NULL;\n\tzfcp_dbf_unregister(dbf);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}