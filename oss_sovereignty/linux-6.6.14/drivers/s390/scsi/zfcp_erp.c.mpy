{
  "module_name": "zfcp_erp.c",
  "hash_id": "22e95a0a73958b6f403826cbdeff5ccb2cf160c0f468984fdf66a480bf66a3de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_erp.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include \"zfcp_ext.h\"\n#include \"zfcp_reqlist.h\"\n#include \"zfcp_diag.h\"\n\n#define ZFCP_MAX_ERPS                   3\n\nenum zfcp_erp_act_flags {\n\tZFCP_STATUS_ERP_TIMEDOUT\t= 0x10000000,\n\tZFCP_STATUS_ERP_CLOSE_ONLY\t= 0x01000000,\n\tZFCP_STATUS_ERP_DISMISSED\t= 0x00200000,\n\tZFCP_STATUS_ERP_LOWMEM\t\t= 0x00400000,\n\tZFCP_STATUS_ERP_NO_REF\t\t= 0x00800000,\n};\n\n \n#define ZFCP_ERP_ACTION_NONE\t\t0xc0\n \n#define ZFCP_ERP_ACTION_FAILED\t\t0xe0\n\nenum zfcp_erp_act_result {\n\tZFCP_ERP_SUCCEEDED = 0,\n\tZFCP_ERP_FAILED    = 1,\n\tZFCP_ERP_CONTINUES = 2,\n\tZFCP_ERP_EXIT      = 3,\n\tZFCP_ERP_DISMISSED = 4,\n\tZFCP_ERP_NOMEM     = 5,\n};\n\nstatic void zfcp_erp_adapter_block(struct zfcp_adapter *adapter, int mask)\n{\n\tzfcp_erp_clear_adapter_status(adapter,\n\t\t\t\t       ZFCP_STATUS_COMMON_UNBLOCKED | mask);\n}\n\nstatic bool zfcp_erp_action_is_running(struct zfcp_erp_action *act)\n{\n\tstruct zfcp_erp_action *curr_act;\n\n\tlist_for_each_entry(curr_act, &act->adapter->erp_running_head, list)\n\t\tif (act == curr_act)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic void zfcp_erp_action_ready(struct zfcp_erp_action *act)\n{\n\tstruct zfcp_adapter *adapter = act->adapter;\n\n\tlist_move(&act->list, &adapter->erp_ready_head);\n\tzfcp_dbf_rec_run(\"erardy1\", act);\n\twake_up(&adapter->erp_ready_wq);\n\tzfcp_dbf_rec_run(\"erardy2\", act);\n}\n\nstatic void zfcp_erp_action_dismiss(struct zfcp_erp_action *act)\n{\n\tact->status |= ZFCP_STATUS_ERP_DISMISSED;\n\tif (zfcp_erp_action_is_running(act))\n\t\tzfcp_erp_action_ready(act);\n}\n\nstatic void zfcp_erp_action_dismiss_lun(struct scsi_device *sdev)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\n\tif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_ERP_INUSE)\n\t\tzfcp_erp_action_dismiss(&zfcp_sdev->erp_action);\n}\n\nstatic void zfcp_erp_action_dismiss_port(struct zfcp_port *port)\n{\n\tstruct scsi_device *sdev;\n\n\tif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_INUSE)\n\t\tzfcp_erp_action_dismiss(&port->erp_action);\n\telse {\n\t\tspin_lock(port->adapter->scsi_host->host_lock);\n\t\t__shost_for_each_device(sdev, port->adapter->scsi_host)\n\t\t\tif (sdev_to_zfcp(sdev)->port == port)\n\t\t\t\tzfcp_erp_action_dismiss_lun(sdev);\n\t\tspin_unlock(port->adapter->scsi_host->host_lock);\n\t}\n}\n\nstatic void zfcp_erp_action_dismiss_adapter(struct zfcp_adapter *adapter)\n{\n\tstruct zfcp_port *port;\n\n\tif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_ERP_INUSE)\n\t\tzfcp_erp_action_dismiss(&adapter->erp_action);\n\telse {\n\t\tread_lock(&adapter->port_list_lock);\n\t\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\t    zfcp_erp_action_dismiss_port(port);\n\t\tread_unlock(&adapter->port_list_lock);\n\t}\n}\n\nstatic enum zfcp_erp_act_type zfcp_erp_handle_failed(\n\tenum zfcp_erp_act_type want, struct zfcp_adapter *adapter,\n\tstruct zfcp_port *port,\tstruct scsi_device *sdev)\n{\n\tenum zfcp_erp_act_type need = want;\n\tstruct zfcp_scsi_dev *zsdev;\n\n\tswitch (want) {\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\tzsdev = sdev_to_zfcp(sdev);\n\t\tif (atomic_read(&zsdev->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\n\t\t\tneed = 0;\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\t\tif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\n\t\t\tneed = 0;\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\tif (atomic_read(&port->status) &\n\t\t    ZFCP_STATUS_COMMON_ERP_FAILED) {\n\t\t\tneed = 0;\n\t\t\t \n\t\t\tzfcp_erp_set_port_status(\n\t\t\t\tport, ZFCP_STATUS_COMMON_ERP_FAILED);\n\t\t}\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\tif (atomic_read(&adapter->status) &\n\t\t    ZFCP_STATUS_COMMON_ERP_FAILED) {\n\t\t\tneed = 0;\n\t\t\t \n\t\t\tzfcp_erp_set_adapter_status(\n\t\t\t\tadapter, ZFCP_STATUS_COMMON_ERP_FAILED);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn need;\n}\n\nstatic enum zfcp_erp_act_type zfcp_erp_required_act(enum zfcp_erp_act_type want,\n\t\t\t\t struct zfcp_adapter *adapter,\n\t\t\t\t struct zfcp_port *port,\n\t\t\t\t struct scsi_device *sdev)\n{\n\tenum zfcp_erp_act_type need = want;\n\tint l_status, p_status, a_status;\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\n\tswitch (want) {\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\tzfcp_sdev = sdev_to_zfcp(sdev);\n\t\tl_status = atomic_read(&zfcp_sdev->status);\n\t\tif (l_status & ZFCP_STATUS_COMMON_ERP_INUSE)\n\t\t\treturn 0;\n\t\tp_status = atomic_read(&port->status);\n\t\tif (!(p_status & ZFCP_STATUS_COMMON_RUNNING) ||\n\t\t    p_status & ZFCP_STATUS_COMMON_ERP_FAILED)\n\t\t\treturn 0;\n\t\tif (!(p_status & ZFCP_STATUS_COMMON_UNBLOCKED))\n\t\t\tneed = ZFCP_ERP_ACTION_REOPEN_PORT;\n\t\tfallthrough;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\t\tp_status = atomic_read(&port->status);\n\t\tif (!(p_status & ZFCP_STATUS_COMMON_OPEN))\n\t\t\tneed = ZFCP_ERP_ACTION_REOPEN_PORT;\n\t\tfallthrough;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\tp_status = atomic_read(&port->status);\n\t\tif (p_status & ZFCP_STATUS_COMMON_ERP_INUSE)\n\t\t\treturn 0;\n\t\ta_status = atomic_read(&adapter->status);\n\t\tif (!(a_status & ZFCP_STATUS_COMMON_RUNNING) ||\n\t\t    a_status & ZFCP_STATUS_COMMON_ERP_FAILED)\n\t\t\treturn 0;\n\t\tif (p_status & ZFCP_STATUS_COMMON_NOESC)\n\t\t\treturn need;\n\t\tif (!(a_status & ZFCP_STATUS_COMMON_UNBLOCKED))\n\t\t\tneed = ZFCP_ERP_ACTION_REOPEN_ADAPTER;\n\t\tfallthrough;\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\ta_status = atomic_read(&adapter->status);\n\t\tif (a_status & ZFCP_STATUS_COMMON_ERP_INUSE)\n\t\t\treturn 0;\n\t\tif (!(a_status & ZFCP_STATUS_COMMON_RUNNING) &&\n\t\t    !(a_status & ZFCP_STATUS_COMMON_OPEN))\n\t\t\treturn 0;  \n\t}\n\n\treturn need;\n}\n\nstatic struct zfcp_erp_action *zfcp_erp_setup_act(enum zfcp_erp_act_type need,\n\t\t\t\t\t\t  u32 act_status,\n\t\t\t\t\t\t  struct zfcp_adapter *adapter,\n\t\t\t\t\t\t  struct zfcp_port *port,\n\t\t\t\t\t\t  struct scsi_device *sdev)\n{\n\tstruct zfcp_erp_action *erp_action;\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\n\tif (WARN_ON_ONCE(need != ZFCP_ERP_ACTION_REOPEN_LUN &&\n\t\t\t need != ZFCP_ERP_ACTION_REOPEN_PORT &&\n\t\t\t need != ZFCP_ERP_ACTION_REOPEN_PORT_FORCED &&\n\t\t\t need != ZFCP_ERP_ACTION_REOPEN_ADAPTER))\n\t\treturn NULL;\n\n\tswitch (need) {\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\tzfcp_sdev = sdev_to_zfcp(sdev);\n\t\tif (!(act_status & ZFCP_STATUS_ERP_NO_REF))\n\t\t\tif (scsi_device_get(sdev))\n\t\t\t\treturn NULL;\n\t\tatomic_or(ZFCP_STATUS_COMMON_ERP_INUSE,\n\t\t\t\t&zfcp_sdev->status);\n\t\terp_action = &zfcp_sdev->erp_action;\n\t\tWARN_ON_ONCE(erp_action->port != port);\n\t\tWARN_ON_ONCE(erp_action->sdev != sdev);\n\t\tif (!(atomic_read(&zfcp_sdev->status) &\n\t\t      ZFCP_STATUS_COMMON_RUNNING))\n\t\t\tact_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\t\tif (!get_device(&port->dev))\n\t\t\treturn NULL;\n\t\tzfcp_erp_action_dismiss_port(port);\n\t\tatomic_or(ZFCP_STATUS_COMMON_ERP_INUSE, &port->status);\n\t\terp_action = &port->erp_action;\n\t\tWARN_ON_ONCE(erp_action->port != port);\n\t\tWARN_ON_ONCE(erp_action->sdev != NULL);\n\t\tif (!(atomic_read(&port->status) & ZFCP_STATUS_COMMON_RUNNING))\n\t\t\tact_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\tkref_get(&adapter->ref);\n\t\tzfcp_erp_action_dismiss_adapter(adapter);\n\t\tatomic_or(ZFCP_STATUS_COMMON_ERP_INUSE, &adapter->status);\n\t\terp_action = &adapter->erp_action;\n\t\tWARN_ON_ONCE(erp_action->port != NULL);\n\t\tWARN_ON_ONCE(erp_action->sdev != NULL);\n\t\tif (!(atomic_read(&adapter->status) &\n\t\t      ZFCP_STATUS_COMMON_RUNNING))\n\t\t\tact_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;\n\t\tbreak;\n\t}\n\n\tWARN_ON_ONCE(erp_action->adapter != adapter);\n\tmemset(&erp_action->list, 0, sizeof(erp_action->list));\n\tmemset(&erp_action->timer, 0, sizeof(erp_action->timer));\n\terp_action->step = ZFCP_ERP_STEP_UNINITIALIZED;\n\terp_action->fsf_req_id = 0;\n\terp_action->type = need;\n\terp_action->status = act_status;\n\n\treturn erp_action;\n}\n\nstatic void zfcp_erp_action_enqueue(enum zfcp_erp_act_type want,\n\t\t\t\t    struct zfcp_adapter *adapter,\n\t\t\t\t    struct zfcp_port *port,\n\t\t\t\t    struct scsi_device *sdev,\n\t\t\t\t    char *dbftag, u32 act_status)\n{\n\tenum zfcp_erp_act_type need;\n\tstruct zfcp_erp_action *act;\n\n\tneed = zfcp_erp_handle_failed(want, adapter, port, sdev);\n\tif (!need) {\n\t\tneed = ZFCP_ERP_ACTION_FAILED;  \n\t\tgoto out;\n\t}\n\n\tif (!adapter->erp_thread) {\n\t\tneed = ZFCP_ERP_ACTION_NONE;  \n\t\tgoto out;\n\t}\n\n\tneed = zfcp_erp_required_act(want, adapter, port, sdev);\n\tif (!need)\n\t\tgoto out;\n\n\tact = zfcp_erp_setup_act(need, act_status, adapter, port, sdev);\n\tif (!act) {\n\t\tneed |= ZFCP_ERP_ACTION_NONE;  \n\t\tgoto out;\n\t}\n\tatomic_or(ZFCP_STATUS_ADAPTER_ERP_PENDING, &adapter->status);\n\t++adapter->erp_total_count;\n\tlist_add_tail(&act->list, &adapter->erp_ready_head);\n\twake_up(&adapter->erp_ready_wq);\n out:\n\tzfcp_dbf_rec_trig(dbftag, adapter, port, sdev, want, need);\n}\n\nvoid zfcp_erp_port_forced_no_port_dbf(char *dbftag,\n\t\t\t\t      struct zfcp_adapter *adapter,\n\t\t\t\t      u64 port_name, u32 port_id)\n{\n\tunsigned long flags;\n\tstatic   struct zfcp_port tmpport;\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\t \n\tatomic_set(&tmpport.status, -1);  \n\ttmpport.wwpn = port_name;\n\ttmpport.d_id = port_id;\n\tzfcp_dbf_rec_trig(dbftag, adapter, &tmpport, NULL,\n\t\t\t  ZFCP_ERP_ACTION_REOPEN_PORT_FORCED,\n\t\t\t  ZFCP_ERP_ACTION_NONE);\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\nstatic void _zfcp_erp_adapter_reopen(struct zfcp_adapter *adapter,\n\t\t\t\t    int clear_mask, char *dbftag)\n{\n\tzfcp_erp_adapter_block(adapter, clear_mask);\n\tzfcp_scsi_schedule_rports_block(adapter);\n\n\tzfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_ADAPTER,\n\t\t\t\tadapter, NULL, NULL, dbftag, 0);\n}\n\n \nvoid zfcp_erp_adapter_reopen(struct zfcp_adapter *adapter, int clear,\n\t\t\t     char *dbftag)\n{\n\tunsigned long flags;\n\n\tzfcp_erp_adapter_block(adapter, clear);\n\tzfcp_scsi_schedule_rports_block(adapter);\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\tzfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_ADAPTER, adapter,\n\t\t\t\tNULL, NULL, dbftag, 0);\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\n \nvoid zfcp_erp_adapter_shutdown(struct zfcp_adapter *adapter, int clear,\n\t\t\t       char *dbftag)\n{\n\tint flags = ZFCP_STATUS_COMMON_RUNNING | ZFCP_STATUS_COMMON_ERP_FAILED;\n\tzfcp_erp_adapter_reopen(adapter, clear | flags, dbftag);\n}\n\n \nvoid zfcp_erp_port_shutdown(struct zfcp_port *port, int clear, char *dbftag)\n{\n\tint flags = ZFCP_STATUS_COMMON_RUNNING | ZFCP_STATUS_COMMON_ERP_FAILED;\n\tzfcp_erp_port_reopen(port, clear | flags, dbftag);\n}\n\nstatic void zfcp_erp_port_block(struct zfcp_port *port, int clear)\n{\n\tzfcp_erp_clear_port_status(port,\n\t\t\t\t    ZFCP_STATUS_COMMON_UNBLOCKED | clear);\n}\n\nstatic void _zfcp_erp_port_forced_reopen(struct zfcp_port *port, int clear,\n\t\t\t\t\t char *dbftag)\n{\n\tzfcp_erp_port_block(port, clear);\n\tzfcp_scsi_schedule_rport_block(port);\n\n\tzfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_PORT_FORCED,\n\t\t\t\tport->adapter, port, NULL, dbftag, 0);\n}\n\n \nvoid zfcp_erp_port_forced_reopen(struct zfcp_port *port, int clear,\n\t\t\t\t char *dbftag)\n{\n\tunsigned long flags;\n\tstruct zfcp_adapter *adapter = port->adapter;\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\t_zfcp_erp_port_forced_reopen(port, clear, dbftag);\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\nstatic void _zfcp_erp_port_reopen(struct zfcp_port *port, int clear,\n\t\t\t\t  char *dbftag)\n{\n\tzfcp_erp_port_block(port, clear);\n\tzfcp_scsi_schedule_rport_block(port);\n\n\tzfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_PORT,\n\t\t\t\tport->adapter, port, NULL, dbftag, 0);\n}\n\n \nvoid zfcp_erp_port_reopen(struct zfcp_port *port, int clear, char *dbftag)\n{\n\tunsigned long flags;\n\tstruct zfcp_adapter *adapter = port->adapter;\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\t_zfcp_erp_port_reopen(port, clear, dbftag);\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\nstatic void zfcp_erp_lun_block(struct scsi_device *sdev, int clear_mask)\n{\n\tzfcp_erp_clear_lun_status(sdev,\n\t\t\t\t  ZFCP_STATUS_COMMON_UNBLOCKED | clear_mask);\n}\n\nstatic void _zfcp_erp_lun_reopen(struct scsi_device *sdev, int clear,\n\t\t\t\t char *dbftag, u32 act_status)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\tstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\n\n\tzfcp_erp_lun_block(sdev, clear);\n\n\tzfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_LUN, adapter,\n\t\t\t\tzfcp_sdev->port, sdev, dbftag, act_status);\n}\n\n \nvoid zfcp_erp_lun_reopen(struct scsi_device *sdev, int clear, char *dbftag)\n{\n\tunsigned long flags;\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\tstruct zfcp_port *port = zfcp_sdev->port;\n\tstruct zfcp_adapter *adapter = port->adapter;\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\t_zfcp_erp_lun_reopen(sdev, clear, dbftag, 0);\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\n \nvoid zfcp_erp_lun_shutdown(struct scsi_device *sdev, int clear, char *dbftag)\n{\n\tint flags = ZFCP_STATUS_COMMON_RUNNING | ZFCP_STATUS_COMMON_ERP_FAILED;\n\tzfcp_erp_lun_reopen(sdev, clear | flags, dbftag);\n}\n\n \nvoid zfcp_erp_lun_shutdown_wait(struct scsi_device *sdev, char *dbftag)\n{\n\tunsigned long flags;\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\tstruct zfcp_port *port = zfcp_sdev->port;\n\tstruct zfcp_adapter *adapter = port->adapter;\n\tint clear = ZFCP_STATUS_COMMON_RUNNING | ZFCP_STATUS_COMMON_ERP_FAILED;\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\t_zfcp_erp_lun_reopen(sdev, clear, dbftag, ZFCP_STATUS_ERP_NO_REF);\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n\n\tzfcp_erp_wait(adapter);\n}\n\nstatic int zfcp_erp_status_change_set(unsigned long mask, atomic_t *status)\n{\n\treturn (atomic_read(status) ^ mask) & mask;\n}\n\nstatic void zfcp_erp_adapter_unblock(struct zfcp_adapter *adapter)\n{\n\tif (zfcp_erp_status_change_set(ZFCP_STATUS_COMMON_UNBLOCKED,\n\t\t\t\t       &adapter->status))\n\t\tzfcp_dbf_rec_run(\"eraubl1\", &adapter->erp_action);\n\tatomic_or(ZFCP_STATUS_COMMON_UNBLOCKED, &adapter->status);\n}\n\nstatic void zfcp_erp_port_unblock(struct zfcp_port *port)\n{\n\tif (zfcp_erp_status_change_set(ZFCP_STATUS_COMMON_UNBLOCKED,\n\t\t\t\t       &port->status))\n\t\tzfcp_dbf_rec_run(\"erpubl1\", &port->erp_action);\n\tatomic_or(ZFCP_STATUS_COMMON_UNBLOCKED, &port->status);\n}\n\nstatic void zfcp_erp_lun_unblock(struct scsi_device *sdev)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\n\tif (zfcp_erp_status_change_set(ZFCP_STATUS_COMMON_UNBLOCKED,\n\t\t\t\t       &zfcp_sdev->status))\n\t\tzfcp_dbf_rec_run(\"erlubl1\", &sdev_to_zfcp(sdev)->erp_action);\n\tatomic_or(ZFCP_STATUS_COMMON_UNBLOCKED, &zfcp_sdev->status);\n}\n\nstatic void zfcp_erp_action_to_running(struct zfcp_erp_action *erp_action)\n{\n\tlist_move(&erp_action->list, &erp_action->adapter->erp_running_head);\n\tzfcp_dbf_rec_run(\"erator1\", erp_action);\n}\n\nstatic void zfcp_erp_strategy_check_fsfreq(struct zfcp_erp_action *act)\n{\n\tstruct zfcp_adapter *adapter = act->adapter;\n\tstruct zfcp_fsf_req *req;\n\n\tif (!act->fsf_req_id)\n\t\treturn;\n\n\tspin_lock(&adapter->req_list->lock);\n\treq = _zfcp_reqlist_find(adapter->req_list, act->fsf_req_id);\n\tif (req && req->erp_action == act) {\n\t\tif (act->status & (ZFCP_STATUS_ERP_DISMISSED |\n\t\t\t\t   ZFCP_STATUS_ERP_TIMEDOUT)) {\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_DISMISSED;\n\t\t\tzfcp_dbf_rec_run(\"erscf_1\", act);\n\t\t\t \n\t\t\tWRITE_ONCE(req->erp_action, NULL);\n\t\t}\n\t\tif (act->status & ZFCP_STATUS_ERP_TIMEDOUT)\n\t\t\tzfcp_dbf_rec_run(\"erscf_2\", act);\n\t\tif (req->status & ZFCP_STATUS_FSFREQ_DISMISSED)\n\t\t\tact->fsf_req_id = 0;\n\t} else\n\t\tact->fsf_req_id = 0;\n\tspin_unlock(&adapter->req_list->lock);\n}\n\n \nvoid zfcp_erp_notify(struct zfcp_erp_action *erp_action, unsigned long set_mask)\n{\n\tstruct zfcp_adapter *adapter = erp_action->adapter;\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\tif (zfcp_erp_action_is_running(erp_action)) {\n\t\terp_action->status |= set_mask;\n\t\tzfcp_erp_action_ready(erp_action);\n\t}\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\n \nvoid zfcp_erp_timeout_handler(struct timer_list *t)\n{\n\tstruct zfcp_fsf_req *fsf_req = from_timer(fsf_req, t, timer);\n\tstruct zfcp_erp_action *act;\n\n\tif (fsf_req->status & ZFCP_STATUS_FSFREQ_DISMISSED)\n\t\treturn;\n\t \n\tact = READ_ONCE(fsf_req->erp_action);\n\tif (!act)\n\t\treturn;\n\tzfcp_erp_notify(act, ZFCP_STATUS_ERP_TIMEDOUT);\n}\n\nstatic void zfcp_erp_memwait_handler(struct timer_list *t)\n{\n\tstruct zfcp_erp_action *act = from_timer(act, t, timer);\n\n\tzfcp_erp_notify(act, 0);\n}\n\nstatic void zfcp_erp_strategy_memwait(struct zfcp_erp_action *erp_action)\n{\n\ttimer_setup(&erp_action->timer, zfcp_erp_memwait_handler, 0);\n\terp_action->timer.expires = jiffies + HZ;\n\tadd_timer(&erp_action->timer);\n}\n\nvoid zfcp_erp_port_forced_reopen_all(struct zfcp_adapter *adapter,\n\t\t\t\t     int clear, char *dbftag)\n{\n\tunsigned long flags;\n\tstruct zfcp_port *port;\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\tread_lock(&adapter->port_list_lock);\n\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\t_zfcp_erp_port_forced_reopen(port, clear, dbftag);\n\tread_unlock(&adapter->port_list_lock);\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\nstatic void _zfcp_erp_port_reopen_all(struct zfcp_adapter *adapter,\n\t\t\t\t      int clear, char *dbftag)\n{\n\tstruct zfcp_port *port;\n\n\tread_lock(&adapter->port_list_lock);\n\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\t_zfcp_erp_port_reopen(port, clear, dbftag);\n\tread_unlock(&adapter->port_list_lock);\n}\n\nstatic void _zfcp_erp_lun_reopen_all(struct zfcp_port *port, int clear,\n\t\t\t\t     char *dbftag)\n{\n\tstruct scsi_device *sdev;\n\n\tspin_lock(port->adapter->scsi_host->host_lock);\n\t__shost_for_each_device(sdev, port->adapter->scsi_host)\n\t\tif (sdev_to_zfcp(sdev)->port == port)\n\t\t\t_zfcp_erp_lun_reopen(sdev, clear, dbftag, 0);\n\tspin_unlock(port->adapter->scsi_host->host_lock);\n}\n\nstatic void zfcp_erp_strategy_followup_failed(struct zfcp_erp_action *act)\n{\n\tswitch (act->type) {\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\t_zfcp_erp_adapter_reopen(act->adapter, 0, \"ersff_1\");\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\t\t_zfcp_erp_port_forced_reopen(act->port, 0, \"ersff_2\");\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\t_zfcp_erp_port_reopen(act->port, 0, \"ersff_3\");\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\t_zfcp_erp_lun_reopen(act->sdev, 0, \"ersff_4\", 0);\n\t\tbreak;\n\t}\n}\n\nstatic void zfcp_erp_strategy_followup_success(struct zfcp_erp_action *act)\n{\n\tswitch (act->type) {\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\t_zfcp_erp_port_reopen_all(act->adapter, 0, \"ersfs_1\");\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\t\t_zfcp_erp_port_reopen(act->port, 0, \"ersfs_2\");\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\t_zfcp_erp_lun_reopen_all(act->port, 0, \"ersfs_3\");\n\t\tbreak;\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void zfcp_erp_wakeup(struct zfcp_adapter *adapter)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&adapter->erp_lock, flags);\n\tif (list_empty(&adapter->erp_ready_head) &&\n\t    list_empty(&adapter->erp_running_head)) {\n\t\t\tatomic_andnot(ZFCP_STATUS_ADAPTER_ERP_PENDING,\n\t\t\t\t\t  &adapter->status);\n\t\t\twake_up(&adapter->erp_done_wqh);\n\t}\n\tread_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\nstatic void zfcp_erp_enqueue_ptp_port(struct zfcp_adapter *adapter)\n{\n\tstruct zfcp_port *port;\n\tport = zfcp_port_enqueue(adapter, adapter->peer_wwpn, 0,\n\t\t\t\t adapter->peer_d_id);\n\tif (IS_ERR(port))  \n\t\treturn;\n\tzfcp_erp_port_reopen(port, 0, \"ereptp1\");\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_adapter_strat_fsf_xconf(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tint retries;\n\tint sleep = 1;\n\tstruct zfcp_adapter *adapter = erp_action->adapter;\n\n\tatomic_andnot(ZFCP_STATUS_ADAPTER_XCONFIG_OK, &adapter->status);\n\n\tfor (retries = 7; retries; retries--) {\n\t\tatomic_andnot(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,\n\t\t\t\t  &adapter->status);\n\t\twrite_lock_irq(&adapter->erp_lock);\n\t\tzfcp_erp_action_to_running(erp_action);\n\t\twrite_unlock_irq(&adapter->erp_lock);\n\t\tif (zfcp_fsf_exchange_config_data(erp_action)) {\n\t\t\tatomic_andnot(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,\n\t\t\t\t\t  &adapter->status);\n\t\t\treturn ZFCP_ERP_FAILED;\n\t\t}\n\n\t\twait_event(adapter->erp_ready_wq,\n\t\t\t   !list_empty(&adapter->erp_ready_head));\n\t\tif (erp_action->status & ZFCP_STATUS_ERP_TIMEDOUT)\n\t\t\tbreak;\n\n\t\tif (!(atomic_read(&adapter->status) &\n\t\t      ZFCP_STATUS_ADAPTER_HOST_CON_INIT))\n\t\t\tbreak;\n\n\t\tssleep(sleep);\n\t\tsleep *= 2;\n\t}\n\n\tatomic_andnot(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,\n\t\t\t  &adapter->status);\n\n\tif (!(atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_XCONFIG_OK))\n\t\treturn ZFCP_ERP_FAILED;\n\n\treturn ZFCP_ERP_SUCCEEDED;\n}\n\nstatic void\nzfcp_erp_adapter_strategy_open_ptp_port(struct zfcp_adapter *const adapter)\n{\n\tif (fc_host_port_type(adapter->scsi_host) == FC_PORTTYPE_PTP)\n\t\tzfcp_erp_enqueue_ptp_port(adapter);\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_adapter_strategy_open_fsf_xport(\n\tstruct zfcp_erp_action *act)\n{\n\tint ret;\n\tstruct zfcp_adapter *adapter = act->adapter;\n\n\twrite_lock_irq(&adapter->erp_lock);\n\tzfcp_erp_action_to_running(act);\n\twrite_unlock_irq(&adapter->erp_lock);\n\n\tret = zfcp_fsf_exchange_port_data(act);\n\tif (ret == -EOPNOTSUPP)\n\t\treturn ZFCP_ERP_SUCCEEDED;\n\tif (ret)\n\t\treturn ZFCP_ERP_FAILED;\n\n\tzfcp_dbf_rec_run(\"erasox1\", act);\n\twait_event(adapter->erp_ready_wq,\n\t\t   !list_empty(&adapter->erp_ready_head));\n\tzfcp_dbf_rec_run(\"erasox2\", act);\n\tif (act->status & ZFCP_STATUS_ERP_TIMEDOUT)\n\t\treturn ZFCP_ERP_FAILED;\n\n\treturn ZFCP_ERP_SUCCEEDED;\n}\n\nstatic enum zfcp_erp_act_result\nzfcp_erp_adapter_strategy_alloc_shost(struct zfcp_adapter *const adapter)\n{\n\tstruct zfcp_diag_adapter_config_data *const config_data =\n\t\t&adapter->diagnostics->config_data;\n\tstruct zfcp_diag_adapter_port_data *const port_data =\n\t\t&adapter->diagnostics->port_data;\n\tunsigned long flags;\n\tint rc;\n\n\trc = zfcp_scsi_adapter_register(adapter);\n\tif (rc == -EEXIST)\n\t\treturn ZFCP_ERP_SUCCEEDED;\n\telse if (rc)\n\t\treturn ZFCP_ERP_FAILED;\n\n\t \n\n\tspin_lock_irqsave(&config_data->header.access_lock, flags);\n\tzfcp_scsi_shost_update_config_data(adapter, &config_data->data,\n\t\t\t\t\t   !!config_data->header.incomplete);\n\tspin_unlock_irqrestore(&config_data->header.access_lock, flags);\n\n\tif (adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT) {\n\t\tspin_lock_irqsave(&port_data->header.access_lock, flags);\n\t\tzfcp_scsi_shost_update_port_data(adapter, &port_data->data);\n\t\tspin_unlock_irqrestore(&port_data->header.access_lock, flags);\n\t}\n\n\t \n\tif (config_data->header.incomplete)\n\t\tzfcp_fsf_fc_host_link_down(adapter);\n\n\treturn ZFCP_ERP_SUCCEEDED;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_adapter_strategy_open_fsf(\n\tstruct zfcp_erp_action *act)\n{\n\tif (zfcp_erp_adapter_strat_fsf_xconf(act) == ZFCP_ERP_FAILED)\n\t\treturn ZFCP_ERP_FAILED;\n\n\tif (zfcp_erp_adapter_strategy_open_fsf_xport(act) == ZFCP_ERP_FAILED)\n\t\treturn ZFCP_ERP_FAILED;\n\n\tif (zfcp_erp_adapter_strategy_alloc_shost(act->adapter) ==\n\t    ZFCP_ERP_FAILED)\n\t\treturn ZFCP_ERP_FAILED;\n\n\tzfcp_erp_adapter_strategy_open_ptp_port(act->adapter);\n\n\tif (mempool_resize(act->adapter->pool.sr_data,\n\t\t\t   act->adapter->stat_read_buf_num))\n\t\treturn ZFCP_ERP_FAILED;\n\n\tif (mempool_resize(act->adapter->pool.status_read_req,\n\t\t\t   act->adapter->stat_read_buf_num))\n\t\treturn ZFCP_ERP_FAILED;\n\n\tatomic_set(&act->adapter->stat_miss, act->adapter->stat_read_buf_num);\n\tif (zfcp_status_read_refill(act->adapter))\n\t\treturn ZFCP_ERP_FAILED;\n\n\treturn ZFCP_ERP_SUCCEEDED;\n}\n\nstatic void zfcp_erp_adapter_strategy_close(struct zfcp_erp_action *act)\n{\n\tstruct zfcp_adapter *adapter = act->adapter;\n\n\t \n\tzfcp_qdio_close(adapter->qdio);\n\tzfcp_fsf_req_dismiss_all(adapter);\n\tadapter->fsf_req_seq_no = 0;\n\tzfcp_fc_wka_ports_force_offline(adapter->gs);\n\t \n\tzfcp_erp_clear_adapter_status(adapter, ZFCP_STATUS_COMMON_OPEN);\n\n\tatomic_andnot(ZFCP_STATUS_ADAPTER_XCONFIG_OK |\n\t\t\t  ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED, &adapter->status);\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_adapter_strategy_open(\n\tstruct zfcp_erp_action *act)\n{\n\tstruct zfcp_adapter *adapter = act->adapter;\n\n\tif (zfcp_qdio_open(adapter->qdio)) {\n\t\tatomic_andnot(ZFCP_STATUS_ADAPTER_XCONFIG_OK |\n\t\t\t\t  ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED,\n\t\t\t\t  &adapter->status);\n\t\treturn ZFCP_ERP_FAILED;\n\t}\n\n\tif (zfcp_erp_adapter_strategy_open_fsf(act)) {\n\t\tzfcp_erp_adapter_strategy_close(act);\n\t\treturn ZFCP_ERP_FAILED;\n\t}\n\n\tatomic_or(ZFCP_STATUS_COMMON_OPEN, &adapter->status);\n\n\treturn ZFCP_ERP_SUCCEEDED;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_adapter_strategy(\n\tstruct zfcp_erp_action *act)\n{\n\tstruct zfcp_adapter *adapter = act->adapter;\n\n\tif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_OPEN) {\n\t\tzfcp_erp_adapter_strategy_close(act);\n\t\tif (act->status & ZFCP_STATUS_ERP_CLOSE_ONLY)\n\t\t\treturn ZFCP_ERP_EXIT;\n\t}\n\n\tif (zfcp_erp_adapter_strategy_open(act)) {\n\t\tssleep(8);\n\t\treturn ZFCP_ERP_FAILED;\n\t}\n\n\treturn ZFCP_ERP_SUCCEEDED;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_port_forced_strategy_close(\n\tstruct zfcp_erp_action *act)\n{\n\tint retval;\n\n\tretval = zfcp_fsf_close_physical_port(act);\n\tif (retval == -ENOMEM)\n\t\treturn ZFCP_ERP_NOMEM;\n\tact->step = ZFCP_ERP_STEP_PHYS_PORT_CLOSING;\n\tif (retval)\n\t\treturn ZFCP_ERP_FAILED;\n\n\treturn ZFCP_ERP_CONTINUES;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_port_forced_strategy(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_port *port = erp_action->port;\n\tint status = atomic_read(&port->status);\n\n\tswitch (erp_action->step) {\n\tcase ZFCP_ERP_STEP_UNINITIALIZED:\n\t\tif ((status & ZFCP_STATUS_PORT_PHYS_OPEN) &&\n\t\t    (status & ZFCP_STATUS_COMMON_OPEN))\n\t\t\treturn zfcp_erp_port_forced_strategy_close(erp_action);\n\t\telse\n\t\t\treturn ZFCP_ERP_FAILED;\n\n\tcase ZFCP_ERP_STEP_PHYS_PORT_CLOSING:\n\t\tif (!(status & ZFCP_STATUS_PORT_PHYS_OPEN))\n\t\t\treturn ZFCP_ERP_SUCCEEDED;\n\t\tbreak;\n\tcase ZFCP_ERP_STEP_PORT_CLOSING:\n\tcase ZFCP_ERP_STEP_PORT_OPENING:\n\tcase ZFCP_ERP_STEP_LUN_CLOSING:\n\tcase ZFCP_ERP_STEP_LUN_OPENING:\n\t\t \n\t\tbreak;\n\t}\n\treturn ZFCP_ERP_FAILED;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_port_strategy_close(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tint retval;\n\n\tretval = zfcp_fsf_close_port(erp_action);\n\tif (retval == -ENOMEM)\n\t\treturn ZFCP_ERP_NOMEM;\n\terp_action->step = ZFCP_ERP_STEP_PORT_CLOSING;\n\tif (retval)\n\t\treturn ZFCP_ERP_FAILED;\n\treturn ZFCP_ERP_CONTINUES;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_port_strategy_open_port(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tint retval;\n\n\tretval = zfcp_fsf_open_port(erp_action);\n\tif (retval == -ENOMEM)\n\t\treturn ZFCP_ERP_NOMEM;\n\terp_action->step = ZFCP_ERP_STEP_PORT_OPENING;\n\tif (retval)\n\t\treturn ZFCP_ERP_FAILED;\n\treturn ZFCP_ERP_CONTINUES;\n}\n\nstatic int zfcp_erp_open_ptp_port(struct zfcp_erp_action *act)\n{\n\tstruct zfcp_adapter *adapter = act->adapter;\n\tstruct zfcp_port *port = act->port;\n\n\tif (port->wwpn != adapter->peer_wwpn) {\n\t\tzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_ERP_FAILED);\n\t\treturn ZFCP_ERP_FAILED;\n\t}\n\tport->d_id = adapter->peer_d_id;\n\treturn zfcp_erp_port_strategy_open_port(act);\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_port_strategy_open_common(\n\tstruct zfcp_erp_action *act)\n{\n\tstruct zfcp_adapter *adapter = act->adapter;\n\tstruct zfcp_port *port = act->port;\n\tint p_status = atomic_read(&port->status);\n\n\tswitch (act->step) {\n\tcase ZFCP_ERP_STEP_UNINITIALIZED:\n\tcase ZFCP_ERP_STEP_PHYS_PORT_CLOSING:\n\tcase ZFCP_ERP_STEP_PORT_CLOSING:\n\t\tif (fc_host_port_type(adapter->scsi_host) == FC_PORTTYPE_PTP)\n\t\t\treturn zfcp_erp_open_ptp_port(act);\n\t\tif (!port->d_id) {\n\t\t\tzfcp_fc_trigger_did_lookup(port);\n\t\t\treturn ZFCP_ERP_EXIT;\n\t\t}\n\t\treturn zfcp_erp_port_strategy_open_port(act);\n\n\tcase ZFCP_ERP_STEP_PORT_OPENING:\n\t\t \n\t\tif (p_status & ZFCP_STATUS_COMMON_OPEN) {\n\t\t\tif (!port->d_id) {\n\t\t\t\tzfcp_fc_trigger_did_lookup(port);\n\t\t\t\treturn ZFCP_ERP_EXIT;\n\t\t\t}\n\t\t\treturn ZFCP_ERP_SUCCEEDED;\n\t\t}\n\t\tif (port->d_id && !(p_status & ZFCP_STATUS_COMMON_NOESC)) {\n\t\t\tport->d_id = 0;\n\t\t\treturn ZFCP_ERP_FAILED;\n\t\t}\n\t\t \n\t\tbreak;\n\tcase ZFCP_ERP_STEP_LUN_CLOSING:\n\tcase ZFCP_ERP_STEP_LUN_OPENING:\n\t\t \n\t\tbreak;\n\t}\n\treturn ZFCP_ERP_FAILED;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_port_strategy(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_port *port = erp_action->port;\n\tint p_status = atomic_read(&port->status);\n\n\tif ((p_status & ZFCP_STATUS_COMMON_NOESC) &&\n\t    !(p_status & ZFCP_STATUS_COMMON_OPEN))\n\t\tgoto close_init_done;\n\n\tswitch (erp_action->step) {\n\tcase ZFCP_ERP_STEP_UNINITIALIZED:\n\t\tif (p_status & ZFCP_STATUS_COMMON_OPEN)\n\t\t\treturn zfcp_erp_port_strategy_close(erp_action);\n\t\tbreak;\n\n\tcase ZFCP_ERP_STEP_PORT_CLOSING:\n\t\tif (p_status & ZFCP_STATUS_COMMON_OPEN)\n\t\t\treturn ZFCP_ERP_FAILED;\n\t\tbreak;\n\tcase ZFCP_ERP_STEP_PHYS_PORT_CLOSING:\n\tcase ZFCP_ERP_STEP_PORT_OPENING:\n\tcase ZFCP_ERP_STEP_LUN_CLOSING:\n\tcase ZFCP_ERP_STEP_LUN_OPENING:\n\t\t \n\t\tbreak;\n\t}\n\nclose_init_done:\n\tif (erp_action->status & ZFCP_STATUS_ERP_CLOSE_ONLY)\n\t\treturn ZFCP_ERP_EXIT;\n\n\treturn zfcp_erp_port_strategy_open_common(erp_action);\n}\n\nstatic void zfcp_erp_lun_strategy_clearstati(struct scsi_device *sdev)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\n\tatomic_andnot(ZFCP_STATUS_COMMON_ACCESS_DENIED,\n\t\t\t  &zfcp_sdev->status);\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_lun_strategy_close(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tint retval = zfcp_fsf_close_lun(erp_action);\n\tif (retval == -ENOMEM)\n\t\treturn ZFCP_ERP_NOMEM;\n\terp_action->step = ZFCP_ERP_STEP_LUN_CLOSING;\n\tif (retval)\n\t\treturn ZFCP_ERP_FAILED;\n\treturn ZFCP_ERP_CONTINUES;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_lun_strategy_open(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tint retval = zfcp_fsf_open_lun(erp_action);\n\tif (retval == -ENOMEM)\n\t\treturn ZFCP_ERP_NOMEM;\n\terp_action->step = ZFCP_ERP_STEP_LUN_OPENING;\n\tif (retval)\n\t\treturn  ZFCP_ERP_FAILED;\n\treturn ZFCP_ERP_CONTINUES;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_lun_strategy(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tstruct scsi_device *sdev = erp_action->sdev;\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\n\tswitch (erp_action->step) {\n\tcase ZFCP_ERP_STEP_UNINITIALIZED:\n\t\tzfcp_erp_lun_strategy_clearstati(sdev);\n\t\tif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_OPEN)\n\t\t\treturn zfcp_erp_lun_strategy_close(erp_action);\n\t\t \n\t\tfallthrough;\n\tcase ZFCP_ERP_STEP_LUN_CLOSING:\n\t\tif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_OPEN)\n\t\t\treturn ZFCP_ERP_FAILED;\n\t\tif (erp_action->status & ZFCP_STATUS_ERP_CLOSE_ONLY)\n\t\t\treturn ZFCP_ERP_EXIT;\n\t\treturn zfcp_erp_lun_strategy_open(erp_action);\n\n\tcase ZFCP_ERP_STEP_LUN_OPENING:\n\t\tif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_OPEN)\n\t\t\treturn ZFCP_ERP_SUCCEEDED;\n\t\tbreak;\n\tcase ZFCP_ERP_STEP_PHYS_PORT_CLOSING:\n\tcase ZFCP_ERP_STEP_PORT_CLOSING:\n\tcase ZFCP_ERP_STEP_PORT_OPENING:\n\t\t \n\t\tbreak;\n\t}\n\treturn ZFCP_ERP_FAILED;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_strategy_check_lun(\n\tstruct scsi_device *sdev, enum zfcp_erp_act_result result)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\n\tswitch (result) {\n\tcase ZFCP_ERP_SUCCEEDED :\n\t\tatomic_set(&zfcp_sdev->erp_counter, 0);\n\t\tzfcp_erp_lun_unblock(sdev);\n\t\tbreak;\n\tcase ZFCP_ERP_FAILED :\n\t\tatomic_inc(&zfcp_sdev->erp_counter);\n\t\tif (atomic_read(&zfcp_sdev->erp_counter) > ZFCP_MAX_ERPS) {\n\t\t\tdev_err(&zfcp_sdev->port->adapter->ccw_device->dev,\n\t\t\t\t\"ERP failed for LUN 0x%016Lx on \"\n\t\t\t\t\"port 0x%016Lx\\n\",\n\t\t\t\t(unsigned long long)zfcp_scsi_dev_lun(sdev),\n\t\t\t\t(unsigned long long)zfcp_sdev->port->wwpn);\n\t\t\tzfcp_erp_set_lun_status(sdev,\n\t\t\t\t\t\tZFCP_STATUS_COMMON_ERP_FAILED);\n\t\t}\n\t\tbreak;\n\tcase ZFCP_ERP_CONTINUES:\n\tcase ZFCP_ERP_EXIT:\n\tcase ZFCP_ERP_DISMISSED:\n\tcase ZFCP_ERP_NOMEM:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_ERP_FAILED) {\n\t\tzfcp_erp_lun_block(sdev, 0);\n\t\tresult = ZFCP_ERP_EXIT;\n\t}\n\treturn result;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_strategy_check_port(\n\tstruct zfcp_port *port, enum zfcp_erp_act_result result)\n{\n\tswitch (result) {\n\tcase ZFCP_ERP_SUCCEEDED :\n\t\tatomic_set(&port->erp_counter, 0);\n\t\tzfcp_erp_port_unblock(port);\n\t\tbreak;\n\n\tcase ZFCP_ERP_FAILED :\n\t\tif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_NOESC) {\n\t\t\tzfcp_erp_port_block(port, 0);\n\t\t\tresult = ZFCP_ERP_EXIT;\n\t\t}\n\t\tatomic_inc(&port->erp_counter);\n\t\tif (atomic_read(&port->erp_counter) > ZFCP_MAX_ERPS) {\n\t\t\tdev_err(&port->adapter->ccw_device->dev,\n\t\t\t\t\"ERP failed for remote port 0x%016Lx\\n\",\n\t\t\t\t(unsigned long long)port->wwpn);\n\t\t\tzfcp_erp_set_port_status(port,\n\t\t\t\t\t ZFCP_STATUS_COMMON_ERP_FAILED);\n\t\t}\n\t\tbreak;\n\tcase ZFCP_ERP_CONTINUES:\n\tcase ZFCP_ERP_EXIT:\n\tcase ZFCP_ERP_DISMISSED:\n\tcase ZFCP_ERP_NOMEM:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_FAILED) {\n\t\tzfcp_erp_port_block(port, 0);\n\t\tresult = ZFCP_ERP_EXIT;\n\t}\n\treturn result;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_strategy_check_adapter(\n\tstruct zfcp_adapter *adapter, enum zfcp_erp_act_result result)\n{\n\tswitch (result) {\n\tcase ZFCP_ERP_SUCCEEDED :\n\t\tatomic_set(&adapter->erp_counter, 0);\n\t\tzfcp_erp_adapter_unblock(adapter);\n\t\tbreak;\n\n\tcase ZFCP_ERP_FAILED :\n\t\tatomic_inc(&adapter->erp_counter);\n\t\tif (atomic_read(&adapter->erp_counter) > ZFCP_MAX_ERPS) {\n\t\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\t\"ERP cannot recover an error \"\n\t\t\t\t\"on the FCP device\\n\");\n\t\t\tzfcp_erp_set_adapter_status(adapter,\n\t\t\t\t\t    ZFCP_STATUS_COMMON_ERP_FAILED);\n\t\t}\n\t\tbreak;\n\tcase ZFCP_ERP_CONTINUES:\n\tcase ZFCP_ERP_EXIT:\n\tcase ZFCP_ERP_DISMISSED:\n\tcase ZFCP_ERP_NOMEM:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_ERP_FAILED) {\n\t\tzfcp_erp_adapter_block(adapter, 0);\n\t\tresult = ZFCP_ERP_EXIT;\n\t}\n\treturn result;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_strategy_check_target(\n\tstruct zfcp_erp_action *erp_action, enum zfcp_erp_act_result result)\n{\n\tstruct zfcp_adapter *adapter = erp_action->adapter;\n\tstruct zfcp_port *port = erp_action->port;\n\tstruct scsi_device *sdev = erp_action->sdev;\n\n\tswitch (erp_action->type) {\n\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\tresult = zfcp_erp_strategy_check_lun(sdev, result);\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\tresult = zfcp_erp_strategy_check_port(port, result);\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\tresult = zfcp_erp_strategy_check_adapter(adapter, result);\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic int zfcp_erp_strat_change_det(atomic_t *target_status, u32 erp_status)\n{\n\tint status = atomic_read(target_status);\n\n\tif ((status & ZFCP_STATUS_COMMON_RUNNING) &&\n\t    (erp_status & ZFCP_STATUS_ERP_CLOSE_ONLY))\n\t\treturn 1;  \n\n\tif (!(status & ZFCP_STATUS_COMMON_RUNNING) &&\n\t    !(erp_status & ZFCP_STATUS_ERP_CLOSE_ONLY))\n\t\treturn 1;  \n\n\treturn 0;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_strategy_statechange(\n\tstruct zfcp_erp_action *act, enum zfcp_erp_act_result result)\n{\n\tenum zfcp_erp_act_type type = act->type;\n\tstruct zfcp_adapter *adapter = act->adapter;\n\tstruct zfcp_port *port = act->port;\n\tstruct scsi_device *sdev = act->sdev;\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\tu32 erp_status = act->status;\n\n\tswitch (type) {\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\tif (zfcp_erp_strat_change_det(&adapter->status, erp_status)) {\n\t\t\t_zfcp_erp_adapter_reopen(adapter,\n\t\t\t\t\t\t ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\t\t \"ersscg1\");\n\t\t\treturn ZFCP_ERP_EXIT;\n\t\t}\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\tif (zfcp_erp_strat_change_det(&port->status, erp_status)) {\n\t\t\t_zfcp_erp_port_reopen(port,\n\t\t\t\t\t      ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\t      \"ersscg2\");\n\t\t\treturn ZFCP_ERP_EXIT;\n\t\t}\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\tzfcp_sdev = sdev_to_zfcp(sdev);\n\t\tif (zfcp_erp_strat_change_det(&zfcp_sdev->status, erp_status)) {\n\t\t\t_zfcp_erp_lun_reopen(sdev,\n\t\t\t\t\t     ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\t     \"ersscg3\", 0);\n\t\t\treturn ZFCP_ERP_EXIT;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic void zfcp_erp_action_dequeue(struct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_adapter *adapter = erp_action->adapter;\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\n\tadapter->erp_total_count--;\n\tif (erp_action->status & ZFCP_STATUS_ERP_LOWMEM) {\n\t\tadapter->erp_low_mem_count--;\n\t\terp_action->status &= ~ZFCP_STATUS_ERP_LOWMEM;\n\t}\n\n\tlist_del(&erp_action->list);\n\tzfcp_dbf_rec_run(\"eractd1\", erp_action);\n\n\tswitch (erp_action->type) {\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\tzfcp_sdev = sdev_to_zfcp(erp_action->sdev);\n\t\tatomic_andnot(ZFCP_STATUS_COMMON_ERP_INUSE,\n\t\t\t\t  &zfcp_sdev->status);\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\tatomic_andnot(ZFCP_STATUS_COMMON_ERP_INUSE,\n\t\t\t\t  &erp_action->port->status);\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\tatomic_andnot(ZFCP_STATUS_COMMON_ERP_INUSE,\n\t\t\t\t  &erp_action->adapter->status);\n\t\tbreak;\n\t}\n}\n\n \nstatic void zfcp_erp_try_rport_unblock(struct zfcp_port *port)\n{\n\tunsigned long flags;\n\tstruct zfcp_adapter *adapter = port->adapter;\n\tint port_status;\n\tstruct Scsi_Host *shost = adapter->scsi_host;\n\tstruct scsi_device *sdev;\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\tport_status = atomic_read(&port->status);\n\tif ((port_status & ZFCP_STATUS_COMMON_UNBLOCKED)    == 0 ||\n\t    (port_status & (ZFCP_STATUS_COMMON_ERP_INUSE |\n\t\t\t    ZFCP_STATUS_COMMON_ERP_FAILED)) != 0) {\n\t\t \n\t\tzfcp_dbf_rec_run_lvl(4, \"ertru_p\", &port->erp_action);\n\t\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n\t\treturn;\n\t}\n\tspin_lock(shost->host_lock);\n\t__shost_for_each_device(sdev, shost) {\n\t\tstruct zfcp_scsi_dev *zsdev = sdev_to_zfcp(sdev);\n\t\tint lun_status;\n\n\t\tif (sdev->sdev_state == SDEV_DEL ||\n\t\t    sdev->sdev_state == SDEV_CANCEL)\n\t\t\tcontinue;\n\t\tif (zsdev->port != port)\n\t\t\tcontinue;\n\t\t \n\t\tlun_status = atomic_read(&zsdev->status);\n\t\tif ((lun_status & ZFCP_STATUS_COMMON_ERP_FAILED) != 0)\n\t\t\tcontinue;  \n\t\t \n\t\tif ((lun_status & ZFCP_STATUS_COMMON_UNBLOCKED) == 0 ||\n\t\t    (lun_status & ZFCP_STATUS_COMMON_ERP_INUSE) != 0) {\n\t\t\t \n\t\t\tzfcp_dbf_rec_run_lvl(4, \"ertru_l\", &zsdev->erp_action);\n\t\t\tspin_unlock(shost->host_lock);\n\t\t\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tzfcp_scsi_schedule_rport_register(port);\n\tspin_unlock(shost->host_lock);\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n}\n\nstatic void zfcp_erp_action_cleanup(struct zfcp_erp_action *act,\n\t\t\t\t    enum zfcp_erp_act_result result)\n{\n\tstruct zfcp_adapter *adapter = act->adapter;\n\tstruct zfcp_port *port = act->port;\n\tstruct scsi_device *sdev = act->sdev;\n\n\tswitch (act->type) {\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\tif (!(act->status & ZFCP_STATUS_ERP_NO_REF))\n\t\t\tscsi_device_put(sdev);\n\t\tzfcp_erp_try_rport_unblock(port);\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\t \n\t\tif (act->step != ZFCP_ERP_STEP_UNINITIALIZED)\n\t\t\tif (result == ZFCP_ERP_SUCCEEDED)\n\t\t\t\tzfcp_erp_try_rport_unblock(port);\n\t\tfallthrough;\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\t\tput_device(&port->dev);\n\t\tbreak;\n\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\tif (result == ZFCP_ERP_SUCCEEDED) {\n\t\t\tregister_service_level(&adapter->service_level);\n\t\t\tzfcp_fc_conditional_port_scan(adapter);\n\t\t\tqueue_work(adapter->work_queue, &adapter->ns_up_work);\n\t\t} else\n\t\t\tunregister_service_level(&adapter->service_level);\n\n\t\tkref_put(&adapter->ref, zfcp_adapter_release);\n\t\tbreak;\n\t}\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_strategy_do_action(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tswitch (erp_action->type) {\n\tcase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\n\t\treturn zfcp_erp_adapter_strategy(erp_action);\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\n\t\treturn zfcp_erp_port_forced_strategy(erp_action);\n\tcase ZFCP_ERP_ACTION_REOPEN_PORT:\n\t\treturn zfcp_erp_port_strategy(erp_action);\n\tcase ZFCP_ERP_ACTION_REOPEN_LUN:\n\t\treturn zfcp_erp_lun_strategy(erp_action);\n\t}\n\treturn ZFCP_ERP_FAILED;\n}\n\nstatic enum zfcp_erp_act_result zfcp_erp_strategy(\n\tstruct zfcp_erp_action *erp_action)\n{\n\tenum zfcp_erp_act_result result;\n\tunsigned long flags;\n\tstruct zfcp_adapter *adapter = erp_action->adapter;\n\n\tkref_get(&adapter->ref);\n\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\tzfcp_erp_strategy_check_fsfreq(erp_action);\n\n\tif (erp_action->status & ZFCP_STATUS_ERP_DISMISSED) {\n\t\tzfcp_erp_action_dequeue(erp_action);\n\t\tresult = ZFCP_ERP_DISMISSED;\n\t\tgoto unlock;\n\t}\n\n\tif (erp_action->status & ZFCP_STATUS_ERP_TIMEDOUT) {\n\t\tresult = ZFCP_ERP_FAILED;\n\t\tgoto check_target;\n\t}\n\n\tzfcp_erp_action_to_running(erp_action);\n\n\t \n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n\tresult = zfcp_erp_strategy_do_action(erp_action);\n\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\n\tif (erp_action->status & ZFCP_STATUS_ERP_DISMISSED)\n\t\tresult = ZFCP_ERP_CONTINUES;\n\n\tswitch (result) {\n\tcase ZFCP_ERP_NOMEM:\n\t\tif (!(erp_action->status & ZFCP_STATUS_ERP_LOWMEM)) {\n\t\t\t++adapter->erp_low_mem_count;\n\t\t\terp_action->status |= ZFCP_STATUS_ERP_LOWMEM;\n\t\t}\n\t\tif (adapter->erp_total_count == adapter->erp_low_mem_count)\n\t\t\t_zfcp_erp_adapter_reopen(adapter, 0, \"erstgy1\");\n\t\telse {\n\t\t\tzfcp_erp_strategy_memwait(erp_action);\n\t\t\tresult = ZFCP_ERP_CONTINUES;\n\t\t}\n\t\tgoto unlock;\n\n\tcase ZFCP_ERP_CONTINUES:\n\t\tif (erp_action->status & ZFCP_STATUS_ERP_LOWMEM) {\n\t\t\t--adapter->erp_low_mem_count;\n\t\t\terp_action->status &= ~ZFCP_STATUS_ERP_LOWMEM;\n\t\t}\n\t\tgoto unlock;\n\tcase ZFCP_ERP_SUCCEEDED:\n\tcase ZFCP_ERP_FAILED:\n\tcase ZFCP_ERP_EXIT:\n\tcase ZFCP_ERP_DISMISSED:\n\t\t \n\t\tbreak;\n\t}\n\ncheck_target:\n\tresult = zfcp_erp_strategy_check_target(erp_action, result);\n\tzfcp_erp_action_dequeue(erp_action);\n\tresult = zfcp_erp_strategy_statechange(erp_action, result);\n\tif (result == ZFCP_ERP_EXIT)\n\t\tgoto unlock;\n\tif (result == ZFCP_ERP_SUCCEEDED)\n\t\tzfcp_erp_strategy_followup_success(erp_action);\n\tif (result == ZFCP_ERP_FAILED)\n\t\tzfcp_erp_strategy_followup_failed(erp_action);\n\n unlock:\n\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n\n\tif (result != ZFCP_ERP_CONTINUES)\n\t\tzfcp_erp_action_cleanup(erp_action, result);\n\n\tkref_put(&adapter->ref, zfcp_adapter_release);\n\treturn result;\n}\n\nstatic int zfcp_erp_thread(void *data)\n{\n\tstruct zfcp_adapter *adapter = (struct zfcp_adapter *) data;\n\tstruct zfcp_erp_action *act;\n\tunsigned long flags;\n\n\tfor (;;) {\n\t\twait_event_interruptible(adapter->erp_ready_wq,\n\t\t\t   !list_empty(&adapter->erp_ready_head) ||\n\t\t\t   kthread_should_stop());\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\twrite_lock_irqsave(&adapter->erp_lock, flags);\n\t\tact = list_first_entry_or_null(&adapter->erp_ready_head,\n\t\t\t\t\t       struct zfcp_erp_action, list);\n\t\twrite_unlock_irqrestore(&adapter->erp_lock, flags);\n\n\t\tif (act) {\n\t\t\t \n\t\t\tif (zfcp_erp_strategy(act) != ZFCP_ERP_DISMISSED)\n\t\t\t\tzfcp_erp_wakeup(adapter);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint zfcp_erp_thread_setup(struct zfcp_adapter *adapter)\n{\n\tstruct task_struct *thread;\n\n\tthread = kthread_run(zfcp_erp_thread, adapter, \"zfcperp%s\",\n\t\t\t     dev_name(&adapter->ccw_device->dev));\n\tif (IS_ERR(thread)) {\n\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\"Creating an ERP thread for the FCP device failed.\\n\");\n\t\treturn PTR_ERR(thread);\n\t}\n\n\tadapter->erp_thread = thread;\n\treturn 0;\n}\n\n \nvoid zfcp_erp_thread_kill(struct zfcp_adapter *adapter)\n{\n\tkthread_stop(adapter->erp_thread);\n\tadapter->erp_thread = NULL;\n\tWARN_ON(!list_empty(&adapter->erp_ready_head));\n\tWARN_ON(!list_empty(&adapter->erp_running_head));\n}\n\n \nvoid zfcp_erp_wait(struct zfcp_adapter *adapter)\n{\n\twait_event(adapter->erp_done_wqh,\n\t\t   !(atomic_read(&adapter->status) &\n\t\t\tZFCP_STATUS_ADAPTER_ERP_PENDING));\n}\n\n \nvoid zfcp_erp_set_adapter_status(struct zfcp_adapter *adapter, u32 mask)\n{\n\tstruct zfcp_port *port;\n\tstruct scsi_device *sdev;\n\tunsigned long flags;\n\tu32 common_mask = mask & ZFCP_COMMON_FLAGS;\n\n\tatomic_or(mask, &adapter->status);\n\n\tif (!common_mask)\n\t\treturn;\n\n\tread_lock_irqsave(&adapter->port_list_lock, flags);\n\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\tatomic_or(common_mask, &port->status);\n\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n\n\t \n\tif (adapter->scsi_host == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(adapter->scsi_host->host_lock, flags);\n\t__shost_for_each_device(sdev, adapter->scsi_host)\n\t\tatomic_or(common_mask, &sdev_to_zfcp(sdev)->status);\n\tspin_unlock_irqrestore(adapter->scsi_host->host_lock, flags);\n}\n\n \nvoid zfcp_erp_clear_adapter_status(struct zfcp_adapter *adapter, u32 mask)\n{\n\tstruct zfcp_port *port;\n\tstruct scsi_device *sdev;\n\tunsigned long flags;\n\tu32 common_mask = mask & ZFCP_COMMON_FLAGS;\n\tu32 clear_counter = mask & ZFCP_STATUS_COMMON_ERP_FAILED;\n\n\tatomic_andnot(mask, &adapter->status);\n\n\tif (!common_mask)\n\t\treturn;\n\n\tif (clear_counter)\n\t\tatomic_set(&adapter->erp_counter, 0);\n\n\tread_lock_irqsave(&adapter->port_list_lock, flags);\n\tlist_for_each_entry(port, &adapter->port_list, list) {\n\t\tatomic_andnot(common_mask, &port->status);\n\t\tif (clear_counter)\n\t\t\tatomic_set(&port->erp_counter, 0);\n\t}\n\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n\n\t \n\tif (adapter->scsi_host == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(adapter->scsi_host->host_lock, flags);\n\t__shost_for_each_device(sdev, adapter->scsi_host) {\n\t\tatomic_andnot(common_mask, &sdev_to_zfcp(sdev)->status);\n\t\tif (clear_counter)\n\t\t\tatomic_set(&sdev_to_zfcp(sdev)->erp_counter, 0);\n\t}\n\tspin_unlock_irqrestore(adapter->scsi_host->host_lock, flags);\n}\n\n \nvoid zfcp_erp_set_port_status(struct zfcp_port *port, u32 mask)\n{\n\tstruct scsi_device *sdev;\n\tu32 common_mask = mask & ZFCP_COMMON_FLAGS;\n\tunsigned long flags;\n\n\tatomic_or(mask, &port->status);\n\n\tif (!common_mask)\n\t\treturn;\n\n\tspin_lock_irqsave(port->adapter->scsi_host->host_lock, flags);\n\t__shost_for_each_device(sdev, port->adapter->scsi_host)\n\t\tif (sdev_to_zfcp(sdev)->port == port)\n\t\t\tatomic_or(common_mask,\n\t\t\t\t\t&sdev_to_zfcp(sdev)->status);\n\tspin_unlock_irqrestore(port->adapter->scsi_host->host_lock, flags);\n}\n\n \nvoid zfcp_erp_clear_port_status(struct zfcp_port *port, u32 mask)\n{\n\tstruct scsi_device *sdev;\n\tu32 common_mask = mask & ZFCP_COMMON_FLAGS;\n\tu32 clear_counter = mask & ZFCP_STATUS_COMMON_ERP_FAILED;\n\tunsigned long flags;\n\n\tatomic_andnot(mask, &port->status);\n\n\tif (!common_mask)\n\t\treturn;\n\n\tif (clear_counter)\n\t\tatomic_set(&port->erp_counter, 0);\n\n\tspin_lock_irqsave(port->adapter->scsi_host->host_lock, flags);\n\t__shost_for_each_device(sdev, port->adapter->scsi_host)\n\t\tif (sdev_to_zfcp(sdev)->port == port) {\n\t\t\tatomic_andnot(common_mask,\n\t\t\t\t\t  &sdev_to_zfcp(sdev)->status);\n\t\t\tif (clear_counter)\n\t\t\t\tatomic_set(&sdev_to_zfcp(sdev)->erp_counter, 0);\n\t\t}\n\tspin_unlock_irqrestore(port->adapter->scsi_host->host_lock, flags);\n}\n\n \nvoid zfcp_erp_set_lun_status(struct scsi_device *sdev, u32 mask)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\n\tatomic_or(mask, &zfcp_sdev->status);\n}\n\n \nvoid zfcp_erp_clear_lun_status(struct scsi_device *sdev, u32 mask)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\n\tatomic_andnot(mask, &zfcp_sdev->status);\n\n\tif (mask & ZFCP_STATUS_COMMON_ERP_FAILED)\n\t\tatomic_set(&zfcp_sdev->erp_counter, 0);\n}\n\n \nvoid zfcp_erp_adapter_reset_sync(struct zfcp_adapter *adapter, char *dbftag)\n{\n\tzfcp_erp_set_adapter_status(adapter, ZFCP_STATUS_COMMON_RUNNING);\n\tzfcp_erp_adapter_reopen(adapter, ZFCP_STATUS_COMMON_ERP_FAILED, dbftag);\n\tzfcp_erp_wait(adapter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}