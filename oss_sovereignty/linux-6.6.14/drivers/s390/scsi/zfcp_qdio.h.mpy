{
  "module_name": "zfcp_qdio.h",
  "hash_id": "880261ef4bcad7705746810b195688d00b123e9cca7ec57338f05ddbebbb7460",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_qdio.h",
  "human_readable_source": " \n \n\n#ifndef ZFCP_QDIO_H\n#define ZFCP_QDIO_H\n\n#include <linux/interrupt.h>\n#include <asm/qdio.h>\n\n#define ZFCP_QDIO_SBALE_LEN\tPAGE_SIZE\n\n \n#define ZFCP_QDIO_MAX_SBALS_PER_REQ\t36\n\n \nstruct zfcp_qdio {\n\tstruct qdio_buffer\t*res_q[QDIO_MAX_BUFFERS_PER_Q];\n\tstruct qdio_buffer\t*req_q[QDIO_MAX_BUFFERS_PER_Q];\n\tu8\t\t\treq_q_idx;\n\tatomic_t\t\treq_q_free;\n\tspinlock_t\t\tstat_lock;\n\tspinlock_t\t\treq_q_lock;\n\tunsigned long long\treq_q_time;\n\tu64\t\t\treq_q_util;\n\tatomic_t\t\treq_q_full;\n\twait_queue_head_t\treq_q_wq;\n\tstruct tasklet_struct\tirq_tasklet;\n\tstruct tasklet_struct\trequest_tasklet;\n\tstruct timer_list\trequest_timer;\n\tstruct zfcp_adapter\t*adapter;\n\tu16\t\t\tmax_sbale_per_sbal;\n\tu16\t\t\tmax_sbale_per_req;\n};\n\n \nstruct zfcp_qdio_req {\n\tu8\tsbtype;\n\tu8\tsbal_number;\n\tu8\tsbal_first;\n\tu8\tsbal_last;\n\tu8\tsbal_limit;\n\tu8\tsbale_curr;\n\tu16\tqdio_outb_usage;\n};\n\n \nstatic inline struct qdio_buffer_element *\nzfcp_qdio_sbale_req(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\n{\n\treturn &qdio->req_q[q_req->sbal_last]->element[0];\n}\n\n \nstatic inline struct qdio_buffer_element *\nzfcp_qdio_sbale_curr(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\n{\n\treturn &qdio->req_q[q_req->sbal_last]->element[q_req->sbale_curr];\n}\n\n \nstatic inline\nvoid zfcp_qdio_req_init(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req,\n\t\t\tu64 req_id, u8 sbtype, void *data, u32 len)\n{\n\tstruct qdio_buffer_element *sbale;\n\tint count = min(atomic_read(&qdio->req_q_free),\n\t\t\tZFCP_QDIO_MAX_SBALS_PER_REQ);\n\n\tq_req->sbal_first = q_req->sbal_last = qdio->req_q_idx;\n\tq_req->sbal_number = 1;\n\tq_req->sbtype = sbtype;\n\tq_req->sbale_curr = 1;\n\tq_req->sbal_limit = (q_req->sbal_first + count - 1)\n\t\t\t\t\t% QDIO_MAX_BUFFERS_PER_Q;\n\n\tsbale = zfcp_qdio_sbale_req(qdio, q_req);\n\tsbale->addr = req_id;\n\tsbale->eflags = 0;\n\tsbale->sflags = SBAL_SFLAGS0_COMMAND | sbtype;\n\n\tif (unlikely(!data))\n\t\treturn;\n\tsbale++;\n\tsbale->addr = virt_to_phys(data);\n\tsbale->length = len;\n}\n\n \nstatic inline\nvoid zfcp_qdio_fill_next(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req,\n\t\t\t void *data, u32 len)\n{\n\tstruct qdio_buffer_element *sbale;\n\n\tBUG_ON(q_req->sbale_curr == qdio->max_sbale_per_sbal - 1);\n\tq_req->sbale_curr++;\n\tsbale = zfcp_qdio_sbale_curr(qdio, q_req);\n\tsbale->addr = virt_to_phys(data);\n\tsbale->length = len;\n}\n\n \nstatic inline\nvoid zfcp_qdio_set_sbale_last(struct zfcp_qdio *qdio,\n\t\t\t      struct zfcp_qdio_req *q_req)\n{\n\tstruct qdio_buffer_element *sbale;\n\n\tsbale = zfcp_qdio_sbale_curr(qdio, q_req);\n\tsbale->eflags |= SBAL_EFLAGS_LAST_ENTRY;\n}\n\n \nstatic inline\nint zfcp_qdio_sg_one_sbale(struct scatterlist *sg)\n{\n\treturn sg_is_last(sg) && sg->length <= ZFCP_QDIO_SBALE_LEN;\n}\n\n \nstatic inline\nvoid zfcp_qdio_skip_to_last_sbale(struct zfcp_qdio *qdio,\n\t\t\t\t  struct zfcp_qdio_req *q_req)\n{\n\tq_req->sbale_curr = qdio->max_sbale_per_sbal - 1;\n}\n\n \nstatic inline\nvoid zfcp_qdio_sbal_limit(struct zfcp_qdio *qdio,\n\t\t\t  struct zfcp_qdio_req *q_req, int max_sbals)\n{\n\tint count = min(atomic_read(&qdio->req_q_free), max_sbals);\n\n\tq_req->sbal_limit = (q_req->sbal_first + count - 1) %\n\t\t\t\tQDIO_MAX_BUFFERS_PER_Q;\n}\n\n \nstatic inline\nvoid zfcp_qdio_set_data_div(struct zfcp_qdio *qdio,\n\t\t\t    struct zfcp_qdio_req *q_req, u32 count)\n{\n\tstruct qdio_buffer_element *sbale;\n\n\tsbale = qdio->req_q[q_req->sbal_first]->element;\n\tsbale->length = count;\n}\n\n \nstatic inline\nunsigned int zfcp_qdio_real_bytes(struct scatterlist *sg)\n{\n\tunsigned int real_bytes = 0;\n\n\tfor (; sg; sg = sg_next(sg))\n\t\treal_bytes += sg->length;\n\n\treturn real_bytes;\n}\n\n \nstatic inline\nvoid zfcp_qdio_set_scount(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\n{\n\tstruct qdio_buffer_element *sbale;\n\n\tsbale = qdio->req_q[q_req->sbal_first]->element;\n\tsbale->scount = q_req->sbal_number - 1;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}