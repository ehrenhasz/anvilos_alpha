{
  "module_name": "zfcp_qdio.c",
  "hash_id": "8651dd0f254a2a003b24ac95467fdd8afbea7a69d56b6258890a145d1f293ddc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_qdio.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/lockdep.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include \"zfcp_ext.h\"\n#include \"zfcp_qdio.h\"\n\nstatic bool enable_multibuffer = true;\nmodule_param_named(datarouter, enable_multibuffer, bool, 0400);\nMODULE_PARM_DESC(datarouter, \"Enable hardware data router support (default on)\");\n\n#define ZFCP_QDIO_REQUEST_RESCAN_MSECS\t(MSEC_PER_SEC * 10)\n#define ZFCP_QDIO_REQUEST_SCAN_MSECS\tMSEC_PER_SEC\n\nstatic void zfcp_qdio_handler_error(struct zfcp_qdio *qdio, char *dbftag,\n\t\t\t\t    unsigned int qdio_err)\n{\n\tstruct zfcp_adapter *adapter = qdio->adapter;\n\n\tdev_warn(&adapter->ccw_device->dev, \"A QDIO problem occurred\\n\");\n\n\tif (qdio_err & QDIO_ERROR_SLSB_STATE) {\n\t\tzfcp_qdio_siosl(adapter);\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, dbftag);\n\t\treturn;\n\t}\n\tzfcp_erp_adapter_reopen(adapter,\n\t\t\t\tZFCP_STATUS_ADAPTER_LINK_UNPLUGGED |\n\t\t\t\tZFCP_STATUS_COMMON_ERP_FAILED, dbftag);\n}\n\nstatic void zfcp_qdio_zero_sbals(struct qdio_buffer *sbal[], int first, int cnt)\n{\n\tint i, sbal_idx;\n\n\tfor (i = first; i < first + cnt; i++) {\n\t\tsbal_idx = i % QDIO_MAX_BUFFERS_PER_Q;\n\t\tmemset(sbal[sbal_idx], 0, sizeof(struct qdio_buffer));\n\t}\n}\n\n \nstatic inline void zfcp_qdio_account(struct zfcp_qdio *qdio)\n{\n\tunsigned long long now, span;\n\tint used;\n\n\tnow = get_tod_clock_monotonic();\n\tspan = (now - qdio->req_q_time) >> 12;\n\tused = QDIO_MAX_BUFFERS_PER_Q - atomic_read(&qdio->req_q_free);\n\tqdio->req_q_util += used * span;\n\tqdio->req_q_time = now;\n}\n\nstatic void zfcp_qdio_int_req(struct ccw_device *cdev, unsigned int qdio_err,\n\t\t\t      int queue_no, int idx, int count,\n\t\t\t      unsigned long parm)\n{\n\tstruct zfcp_qdio *qdio = (struct zfcp_qdio *) parm;\n\n\tzfcp_qdio_handler_error(qdio, \"qdireq1\", qdio_err);\n}\n\nstatic void zfcp_qdio_request_tasklet(struct tasklet_struct *tasklet)\n{\n\tstruct zfcp_qdio *qdio = from_tasklet(qdio, tasklet, request_tasklet);\n\tstruct ccw_device *cdev = qdio->adapter->ccw_device;\n\tunsigned int start, error;\n\tint completed;\n\n\tcompleted = qdio_inspect_output_queue(cdev, 0, &start, &error);\n\tif (completed > 0) {\n\t\tif (error) {\n\t\t\tzfcp_qdio_handler_error(qdio, \"qdreqt1\", error);\n\t\t} else {\n\t\t\t \n\t\t\tzfcp_qdio_zero_sbals(qdio->req_q, start, completed);\n\n\t\t\tspin_lock_irq(&qdio->stat_lock);\n\t\t\tzfcp_qdio_account(qdio);\n\t\t\tspin_unlock_irq(&qdio->stat_lock);\n\t\t\tatomic_add(completed, &qdio->req_q_free);\n\t\t\twake_up(&qdio->req_q_wq);\n\t\t}\n\t}\n\n\tif (atomic_read(&qdio->req_q_free) < QDIO_MAX_BUFFERS_PER_Q)\n\t\ttimer_reduce(&qdio->request_timer,\n\t\t\t     jiffies + msecs_to_jiffies(ZFCP_QDIO_REQUEST_RESCAN_MSECS));\n}\n\nstatic void zfcp_qdio_request_timer(struct timer_list *timer)\n{\n\tstruct zfcp_qdio *qdio = from_timer(qdio, timer, request_timer);\n\n\ttasklet_schedule(&qdio->request_tasklet);\n}\n\nstatic void zfcp_qdio_int_resp(struct ccw_device *cdev, unsigned int qdio_err,\n\t\t\t       int queue_no, int idx, int count,\n\t\t\t       unsigned long parm)\n{\n\tstruct zfcp_qdio *qdio = (struct zfcp_qdio *) parm;\n\tstruct zfcp_adapter *adapter = qdio->adapter;\n\tint sbal_no, sbal_idx;\n\n\tif (unlikely(qdio_err)) {\n\t\tif (zfcp_adapter_multi_buffer_active(adapter)) {\n\t\t\tvoid *pl[ZFCP_QDIO_MAX_SBALS_PER_REQ + 1];\n\t\t\tstruct qdio_buffer_element *sbale;\n\t\t\tu64 req_id;\n\t\t\tu8 scount;\n\n\t\t\tmemset(pl, 0,\n\t\t\t       ZFCP_QDIO_MAX_SBALS_PER_REQ * sizeof(void *));\n\t\t\tsbale = qdio->res_q[idx]->element;\n\t\t\treq_id = sbale->addr;\n\t\t\tscount = min(sbale->scount + 1,\n\t\t\t\t     ZFCP_QDIO_MAX_SBALS_PER_REQ + 1);\n\t\t\t\t      \n\n\t\t\tfor (sbal_no = 0; sbal_no < scount; sbal_no++) {\n\t\t\t\tsbal_idx = (idx + sbal_no) %\n\t\t\t\t\tQDIO_MAX_BUFFERS_PER_Q;\n\t\t\t\tpl[sbal_no] = qdio->res_q[sbal_idx];\n\t\t\t}\n\t\t\tzfcp_dbf_hba_def_err(adapter, req_id, scount, pl);\n\t\t}\n\t\tzfcp_qdio_handler_error(qdio, \"qdires1\", qdio_err);\n\t\treturn;\n\t}\n\n\t \n\tfor (sbal_no = 0; sbal_no < count; sbal_no++) {\n\t\tsbal_idx = (idx + sbal_no) % QDIO_MAX_BUFFERS_PER_Q;\n\t\t \n\t\tzfcp_fsf_reqid_check(qdio, sbal_idx);\n\t}\n\n\t \n\tif (qdio_add_bufs_to_input_queue(cdev, 0, idx, count))\n\t\tzfcp_erp_adapter_reopen(qdio->adapter, 0, \"qdires2\");\n}\n\nstatic void zfcp_qdio_irq_tasklet(struct tasklet_struct *tasklet)\n{\n\tstruct zfcp_qdio *qdio = from_tasklet(qdio, tasklet, irq_tasklet);\n\tstruct ccw_device *cdev = qdio->adapter->ccw_device;\n\tunsigned int start, error;\n\tint completed;\n\n\tif (atomic_read(&qdio->req_q_free) < QDIO_MAX_BUFFERS_PER_Q)\n\t\ttasklet_schedule(&qdio->request_tasklet);\n\n\t \n\tcompleted = qdio_inspect_input_queue(cdev, 0, &start, &error);\n\tif (completed < 0)\n\t\treturn;\n\tif (completed > 0)\n\t\tzfcp_qdio_int_resp(cdev, error, 0, start, completed,\n\t\t\t\t   (unsigned long) qdio);\n\n\tif (qdio_start_irq(cdev))\n\t\t \n\t\ttasklet_schedule(&qdio->irq_tasklet);\n}\n\nstatic void zfcp_qdio_poll(struct ccw_device *cdev, unsigned long data)\n{\n\tstruct zfcp_qdio *qdio = (struct zfcp_qdio *) data;\n\n\ttasklet_schedule(&qdio->irq_tasklet);\n}\n\nstatic struct qdio_buffer_element *\nzfcp_qdio_sbal_chain(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\n{\n\tstruct qdio_buffer_element *sbale;\n\n\t \n\tsbale = zfcp_qdio_sbale_curr(qdio, q_req);\n\tsbale->eflags |= SBAL_EFLAGS_LAST_ENTRY;\n\n\t \n\tif (q_req->sbal_last == q_req->sbal_limit)\n\t\treturn NULL;\n\n\t \n\tsbale = zfcp_qdio_sbale_req(qdio, q_req);\n\tsbale->sflags |= SBAL_SFLAGS0_MORE_SBALS;\n\n\t \n\tq_req->sbal_last++;\n\tq_req->sbal_last %= QDIO_MAX_BUFFERS_PER_Q;\n\n\t \n\tq_req->sbal_number++;\n\tBUG_ON(q_req->sbal_number > ZFCP_QDIO_MAX_SBALS_PER_REQ);\n\n\t \n\tq_req->sbale_curr = 0;\n\n\t \n\tsbale = zfcp_qdio_sbale_curr(qdio, q_req);\n\tsbale->sflags |= q_req->sbtype;\n\n\treturn sbale;\n}\n\nstatic struct qdio_buffer_element *\nzfcp_qdio_sbale_next(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\n{\n\tif (q_req->sbale_curr == qdio->max_sbale_per_sbal - 1)\n\t\treturn zfcp_qdio_sbal_chain(qdio, q_req);\n\tq_req->sbale_curr++;\n\treturn zfcp_qdio_sbale_curr(qdio, q_req);\n}\n\n \nint zfcp_qdio_sbals_from_sg(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req,\n\t\t\t    struct scatterlist *sg)\n{\n\tstruct qdio_buffer_element *sbale;\n\n\t \n\tsbale = zfcp_qdio_sbale_req(qdio, q_req);\n\tsbale->sflags |= q_req->sbtype;\n\n\tfor (; sg; sg = sg_next(sg)) {\n\t\tsbale = zfcp_qdio_sbale_next(qdio, q_req);\n\t\tif (!sbale) {\n\t\t\tatomic_inc(&qdio->req_q_full);\n\t\t\tzfcp_qdio_zero_sbals(qdio->req_q, q_req->sbal_first,\n\t\t\t\t\t     q_req->sbal_number);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsbale->addr = sg_phys(sg);\n\t\tsbale->length = sg->length;\n\t}\n\treturn 0;\n}\n\nstatic int zfcp_qdio_sbal_check(struct zfcp_qdio *qdio)\n{\n\tif (atomic_read(&qdio->req_q_free) ||\n\t    !(atomic_read(&qdio->adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nint zfcp_qdio_sbal_get(struct zfcp_qdio *qdio)\n{\n\tlong ret;\n\n\tret = wait_event_interruptible_lock_irq_timeout(qdio->req_q_wq,\n\t\t       zfcp_qdio_sbal_check(qdio), qdio->req_q_lock, 5 * HZ);\n\n\tif (!(atomic_read(&qdio->adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))\n\t\treturn -EIO;\n\n\tif (ret > 0)\n\t\treturn 0;\n\n\tif (!ret) {\n\t\tatomic_inc(&qdio->req_q_full);\n\t\t \n\t\tzfcp_erp_adapter_reopen(qdio->adapter, 0, \"qdsbg_1\");\n\t}\n\n\treturn -EIO;\n}\n\n \nint zfcp_qdio_send(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\n{\n\tint retval;\n\tu8 sbal_number = q_req->sbal_number;\n\n\t \n\tlockdep_assert_irqs_disabled();\n\tspin_lock(&qdio->stat_lock);\n\tzfcp_qdio_account(qdio);\n\tspin_unlock(&qdio->stat_lock);\n\n\tatomic_sub(sbal_number, &qdio->req_q_free);\n\n\tretval = qdio_add_bufs_to_output_queue(qdio->adapter->ccw_device, 0,\n\t\t\t\t\t       q_req->sbal_first, sbal_number,\n\t\t\t\t\t       NULL);\n\n\tif (unlikely(retval)) {\n\t\t \n\t\tatomic_add(sbal_number, &qdio->req_q_free);\n\t\tzfcp_qdio_zero_sbals(qdio->req_q, q_req->sbal_first,\n\t\t\t\t     sbal_number);\n\t\treturn retval;\n\t}\n\n\tif (atomic_read(&qdio->req_q_free) <= 2 * ZFCP_QDIO_MAX_SBALS_PER_REQ)\n\t\ttasklet_schedule(&qdio->request_tasklet);\n\telse\n\t\ttimer_reduce(&qdio->request_timer,\n\t\t\t     jiffies + msecs_to_jiffies(ZFCP_QDIO_REQUEST_SCAN_MSECS));\n\n\t \n\tqdio->req_q_idx += sbal_number;\n\tqdio->req_q_idx %= QDIO_MAX_BUFFERS_PER_Q;\n\n\treturn 0;\n}\n\n \nstatic int zfcp_qdio_allocate(struct zfcp_qdio *qdio)\n{\n\tint ret;\n\n\tret = qdio_alloc_buffers(qdio->req_q, QDIO_MAX_BUFFERS_PER_Q);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tret = qdio_alloc_buffers(qdio->res_q, QDIO_MAX_BUFFERS_PER_Q);\n\tif (ret)\n\t\tgoto free_req_q;\n\n\tinit_waitqueue_head(&qdio->req_q_wq);\n\n\tret = qdio_allocate(qdio->adapter->ccw_device, 1, 1);\n\tif (ret)\n\t\tgoto free_res_q;\n\n\treturn 0;\n\nfree_res_q:\n\tqdio_free_buffers(qdio->res_q, QDIO_MAX_BUFFERS_PER_Q);\nfree_req_q:\n\tqdio_free_buffers(qdio->req_q, QDIO_MAX_BUFFERS_PER_Q);\n\treturn ret;\n}\n\n \nvoid zfcp_qdio_close(struct zfcp_qdio *qdio)\n{\n\tstruct zfcp_adapter *adapter = qdio->adapter;\n\tint idx, count;\n\n\tif (!(atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))\n\t\treturn;\n\n\t \n\tspin_lock_irq(&qdio->req_q_lock);\n\tatomic_andnot(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status);\n\tspin_unlock_irq(&qdio->req_q_lock);\n\n\twake_up(&qdio->req_q_wq);\n\n\ttasklet_disable(&qdio->irq_tasklet);\n\ttasklet_disable(&qdio->request_tasklet);\n\tdel_timer_sync(&qdio->request_timer);\n\tqdio_stop_irq(adapter->ccw_device);\n\tqdio_shutdown(adapter->ccw_device, QDIO_FLAG_CLEANUP_USING_CLEAR);\n\n\t \n\tcount = atomic_read(&qdio->req_q_free);\n\tif (count < QDIO_MAX_BUFFERS_PER_Q) {\n\t\tidx = (qdio->req_q_idx + count) % QDIO_MAX_BUFFERS_PER_Q;\n\t\tcount = QDIO_MAX_BUFFERS_PER_Q - count;\n\t\tzfcp_qdio_zero_sbals(qdio->req_q, idx, count);\n\t}\n\tqdio->req_q_idx = 0;\n\tatomic_set(&qdio->req_q_free, 0);\n}\n\nvoid zfcp_qdio_shost_update(struct zfcp_adapter *const adapter,\n\t\t\t    const struct zfcp_qdio *const qdio)\n{\n\tstruct Scsi_Host *const shost = adapter->scsi_host;\n\n\tif (shost == NULL)\n\t\treturn;\n\n\tshost->sg_tablesize = qdio->max_sbale_per_req;\n\tshost->max_sectors = qdio->max_sbale_per_req * 8;\n}\n\n \nint zfcp_qdio_open(struct zfcp_qdio *qdio)\n{\n\tstruct qdio_buffer **input_sbals[1] = {qdio->res_q};\n\tstruct qdio_buffer **output_sbals[1] = {qdio->req_q};\n\tstruct qdio_buffer_element *sbale;\n\tstruct qdio_initialize init_data = {0};\n\tstruct zfcp_adapter *adapter = qdio->adapter;\n\tstruct ccw_device *cdev = adapter->ccw_device;\n\tstruct qdio_ssqd_desc ssqd;\n\tint cc;\n\n\tif (atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP)\n\t\treturn -EIO;\n\n\tatomic_andnot(ZFCP_STATUS_ADAPTER_SIOSL_ISSUED,\n\t\t\t  &qdio->adapter->status);\n\n\tinit_data.q_format = QDIO_ZFCP_QFMT;\n\tinit_data.qib_rflags = QIB_RFLAGS_ENABLE_DATA_DIV;\n\tif (enable_multibuffer)\n\t\tinit_data.qdr_ac |= QDR_AC_MULTI_BUFFER_ENABLE;\n\tinit_data.no_input_qs = 1;\n\tinit_data.no_output_qs = 1;\n\tinit_data.input_handler = zfcp_qdio_int_resp;\n\tinit_data.output_handler = zfcp_qdio_int_req;\n\tinit_data.irq_poll = zfcp_qdio_poll;\n\tinit_data.int_parm = (unsigned long) qdio;\n\tinit_data.input_sbal_addr_array = input_sbals;\n\tinit_data.output_sbal_addr_array = output_sbals;\n\n\tif (qdio_establish(cdev, &init_data))\n\t\tgoto failed_establish;\n\n\tif (qdio_get_ssqd_desc(cdev, &ssqd))\n\t\tgoto failed_qdio;\n\n\tif (ssqd.qdioac2 & CHSC_AC2_DATA_DIV_ENABLED)\n\t\tatomic_or(ZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED,\n\t\t\t\t&qdio->adapter->status);\n\n\tif (ssqd.qdioac2 & CHSC_AC2_MULTI_BUFFER_ENABLED) {\n\t\tatomic_or(ZFCP_STATUS_ADAPTER_MB_ACT, &adapter->status);\n\t\tqdio->max_sbale_per_sbal = QDIO_MAX_ELEMENTS_PER_BUFFER;\n\t} else {\n\t\tatomic_andnot(ZFCP_STATUS_ADAPTER_MB_ACT, &adapter->status);\n\t\tqdio->max_sbale_per_sbal = QDIO_MAX_ELEMENTS_PER_BUFFER - 1;\n\t}\n\n\tqdio->max_sbale_per_req =\n\t\tZFCP_QDIO_MAX_SBALS_PER_REQ * qdio->max_sbale_per_sbal\n\t\t- 2;\n\tif (qdio_activate(cdev))\n\t\tgoto failed_qdio;\n\n\tfor (cc = 0; cc < QDIO_MAX_BUFFERS_PER_Q; cc++) {\n\t\tsbale = &(qdio->res_q[cc]->element[0]);\n\t\tsbale->length = 0;\n\t\tsbale->eflags = SBAL_EFLAGS_LAST_ENTRY;\n\t\tsbale->sflags = 0;\n\t\tsbale->addr = 0;\n\t}\n\n\tif (qdio_add_bufs_to_input_queue(cdev, 0, 0, QDIO_MAX_BUFFERS_PER_Q))\n\t\tgoto failed_qdio;\n\n\t \n\tqdio->req_q_idx = 0;\n\tatomic_set(&qdio->req_q_free, QDIO_MAX_BUFFERS_PER_Q);\n\tatomic_or(ZFCP_STATUS_ADAPTER_QDIOUP, &qdio->adapter->status);\n\n\t \n\ttasklet_enable(&qdio->request_tasklet);\n\t \n\ttasklet_enable(&qdio->irq_tasklet);\n\t \n\ttasklet_schedule(&qdio->irq_tasklet);\n\n\tzfcp_qdio_shost_update(adapter, qdio);\n\n\treturn 0;\n\nfailed_qdio:\n\tqdio_shutdown(cdev, QDIO_FLAG_CLEANUP_USING_CLEAR);\nfailed_establish:\n\tdev_err(&cdev->dev,\n\t\t\"Setting up the QDIO connection to the FCP adapter failed\\n\");\n\treturn -EIO;\n}\n\nvoid zfcp_qdio_destroy(struct zfcp_qdio *qdio)\n{\n\tif (!qdio)\n\t\treturn;\n\n\ttasklet_kill(&qdio->irq_tasklet);\n\ttasklet_kill(&qdio->request_tasklet);\n\n\tif (qdio->adapter->ccw_device)\n\t\tqdio_free(qdio->adapter->ccw_device);\n\n\tqdio_free_buffers(qdio->req_q, QDIO_MAX_BUFFERS_PER_Q);\n\tqdio_free_buffers(qdio->res_q, QDIO_MAX_BUFFERS_PER_Q);\n\tkfree(qdio);\n}\n\nint zfcp_qdio_setup(struct zfcp_adapter *adapter)\n{\n\tstruct zfcp_qdio *qdio;\n\n\tqdio = kzalloc(sizeof(struct zfcp_qdio), GFP_KERNEL);\n\tif (!qdio)\n\t\treturn -ENOMEM;\n\n\tqdio->adapter = adapter;\n\n\tif (zfcp_qdio_allocate(qdio)) {\n\t\tkfree(qdio);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&qdio->req_q_lock);\n\tspin_lock_init(&qdio->stat_lock);\n\ttimer_setup(&qdio->request_timer, zfcp_qdio_request_timer, 0);\n\ttasklet_setup(&qdio->irq_tasklet, zfcp_qdio_irq_tasklet);\n\ttasklet_setup(&qdio->request_tasklet, zfcp_qdio_request_tasklet);\n\ttasklet_disable(&qdio->irq_tasklet);\n\ttasklet_disable(&qdio->request_tasklet);\n\n\tadapter->qdio = qdio;\n\treturn 0;\n}\n\n \nvoid zfcp_qdio_siosl(struct zfcp_adapter *adapter)\n{\n\tint rc;\n\n\tif (atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_SIOSL_ISSUED)\n\t\treturn;\n\n\trc = ccw_device_siosl(adapter->ccw_device);\n\tif (!rc)\n\t\tatomic_or(ZFCP_STATUS_ADAPTER_SIOSL_ISSUED,\n\t\t\t\t&adapter->status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}