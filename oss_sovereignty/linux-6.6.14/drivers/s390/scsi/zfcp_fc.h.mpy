{
  "module_name": "zfcp_fc.h",
  "hash_id": "4ce61140b89a9ebc706390b3105ef9da94f701f8326ec9881f343626b1c260be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_fc.h",
  "human_readable_source": " \n \n\n#ifndef ZFCP_FC_H\n#define ZFCP_FC_H\n\n#include <scsi/fc/fc_els.h>\n#include <scsi/fc/fc_fcp.h>\n#include <scsi/fc/fc_ns.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include \"zfcp_fsf.h\"\n\n#define ZFCP_FC_CT_SIZE_PAGE\t  (PAGE_SIZE - sizeof(struct fc_ct_hdr))\n#define ZFCP_FC_GPN_FT_ENT_PAGE\t  (ZFCP_FC_CT_SIZE_PAGE \\\n\t\t\t\t\t/ sizeof(struct fc_gpn_ft_resp))\n#define ZFCP_FC_GPN_FT_NUM_BUFS\t  4  \n\n#define ZFCP_FC_GPN_FT_MAX_SIZE\t  (ZFCP_FC_GPN_FT_NUM_BUFS * PAGE_SIZE \\\n\t\t\t\t\t- sizeof(struct fc_ct_hdr))\n#define ZFCP_FC_GPN_FT_MAX_ENT\t  (ZFCP_FC_GPN_FT_NUM_BUFS * \\\n\t\t\t\t\t(ZFCP_FC_GPN_FT_ENT_PAGE + 1))\n\n#define ZFCP_FC_CTELS_TMO\t(2 * FC_DEF_R_A_TOV / 1000)\n\n \nstruct zfcp_fc_event {\n\tenum fc_host_event_code code;\n\tu32 data;\n\tstruct list_head list;\n};\n\n \nstruct zfcp_fc_events {\n\tstruct list_head list;\n\tspinlock_t list_lock;\n\tstruct work_struct work;\n};\n\n \nstruct zfcp_fc_gid_pn_req {\n\tstruct fc_ct_hdr\tct_hdr;\n\tstruct fc_ns_gid_pn\tgid_pn;\n} __packed;\n\n \nstruct zfcp_fc_gid_pn_rsp {\n\tstruct fc_ct_hdr\tct_hdr;\n\tstruct fc_gid_pn_resp\tgid_pn;\n} __packed;\n\n \nstruct zfcp_fc_gpn_ft_req {\n\tstruct fc_ct_hdr\tct_hdr;\n\tstruct fc_ns_gid_ft\tgpn_ft;\n} __packed;\n\n \nstruct zfcp_fc_gspn_req {\n\tstruct fc_ct_hdr\tct_hdr;\n\tstruct fc_gid_pn_resp\tgspn;\n} __packed;\n\n \nstruct zfcp_fc_gspn_rsp {\n\tstruct fc_ct_hdr\tct_hdr;\n\tstruct fc_gspn_resp\tgspn;\n\tchar\t\t\tname[FC_SYMBOLIC_NAME_SIZE];\n} __packed;\n\n \nstruct zfcp_fc_rspn_req {\n\tstruct fc_ct_hdr\tct_hdr;\n\tstruct fc_ns_rspn\trspn;\n\tchar\t\t\tname[FC_SYMBOLIC_NAME_SIZE];\n} __packed;\n\n \nstruct zfcp_fc_req {\n\tstruct zfcp_fsf_ct_els\t\t\t\tct_els;\n\tstruct scatterlist\t\t\t\tsg_req;\n\tstruct scatterlist\t\t\t\tsg_rsp;\n\tunion {\n\t\tstruct {\n\t\t\tstruct fc_els_adisc\t\treq;\n\t\t\tstruct fc_els_adisc\t\trsp;\n\t\t} adisc;\n\t\tstruct {\n\t\t\tstruct zfcp_fc_gid_pn_req\treq;\n\t\t\tstruct zfcp_fc_gid_pn_rsp\trsp;\n\t\t} gid_pn;\n\t\tstruct {\n\t\t\tstruct scatterlist sg_rsp2[ZFCP_FC_GPN_FT_NUM_BUFS - 1];\n\t\t\tstruct zfcp_fc_gpn_ft_req\treq;\n\t\t} gpn_ft;\n\t\tstruct {\n\t\t\tstruct zfcp_fc_gspn_req\t\treq;\n\t\t\tstruct zfcp_fc_gspn_rsp\t\trsp;\n\t\t} gspn;\n\t\tstruct {\n\t\t\tstruct zfcp_fc_rspn_req\t\treq;\n\t\t\tstruct fc_ct_hdr\t\trsp;\n\t\t} rspn;\n\t} u;\n};\n\n \nenum zfcp_fc_wka_status {\n\tZFCP_FC_WKA_PORT_OFFLINE,\n\tZFCP_FC_WKA_PORT_CLOSING,\n\tZFCP_FC_WKA_PORT_OPENING,\n\tZFCP_FC_WKA_PORT_ONLINE,\n};\n\n \nstruct zfcp_fc_wka_port {\n\tstruct zfcp_adapter\t*adapter;\n\twait_queue_head_t\topened;\n\twait_queue_head_t\tclosed;\n\tenum zfcp_fc_wka_status\tstatus;\n\tatomic_t\t\trefcount;\n\tu32\t\t\td_id;\n\tu32\t\t\thandle;\n\tstruct mutex\t\tmutex;\n\tstruct delayed_work\twork;\n};\n\n \nstruct zfcp_fc_wka_ports {\n\tstruct zfcp_fc_wka_port ms;\n\tstruct zfcp_fc_wka_port ts;\n\tstruct zfcp_fc_wka_port ds;\n\tstruct zfcp_fc_wka_port as;\n};\n\n \nstatic inline\nvoid zfcp_fc_scsi_to_fcp(struct fcp_cmnd *fcp, struct scsi_cmnd *scsi)\n{\n\tu32 datalen;\n\n\tint_to_scsilun(scsi->device->lun, (struct scsi_lun *) &fcp->fc_lun);\n\n\tfcp->fc_pri_ta = FCP_PTA_SIMPLE;\n\n\tif (scsi->sc_data_direction == DMA_FROM_DEVICE)\n\t\tfcp->fc_flags |= FCP_CFL_RDDATA;\n\tif (scsi->sc_data_direction == DMA_TO_DEVICE)\n\t\tfcp->fc_flags |= FCP_CFL_WRDATA;\n\n\tmemcpy(fcp->fc_cdb, scsi->cmnd, scsi->cmd_len);\n\n\tdatalen = scsi_bufflen(scsi);\n\tfcp->fc_dl = cpu_to_be32(datalen);\n\n\tif (scsi_get_prot_type(scsi) == SCSI_PROT_DIF_TYPE1) {\n\t\tdatalen += datalen / scsi->device->sector_size * 8;\n\t\tfcp->fc_dl = cpu_to_be32(datalen);\n\t}\n}\n\n \nstatic inline\nvoid zfcp_fc_fcp_tm(struct fcp_cmnd *fcp, struct scsi_device *dev, u8 tm_flags)\n{\n\tint_to_scsilun(dev->lun, (struct scsi_lun *) &fcp->fc_lun);\n\tfcp->fc_tm_flags = tm_flags;\n}\n\n \nstatic inline\nvoid zfcp_fc_eval_fcp_rsp(struct fcp_resp_with_ext *fcp_rsp,\n\t\t\t  struct scsi_cmnd *scsi)\n{\n\tstruct fcp_resp_rsp_info *rsp_info;\n\tchar *sense;\n\tu32 sense_len, resid;\n\tu8 rsp_flags;\n\n\tscsi->result |= fcp_rsp->resp.fr_status;\n\n\trsp_flags = fcp_rsp->resp.fr_flags;\n\n\tif (unlikely(rsp_flags & FCP_RSP_LEN_VAL)) {\n\t\trsp_info = (struct fcp_resp_rsp_info *) &fcp_rsp[1];\n\t\tif (rsp_info->rsp_code == FCP_TMF_CMPL)\n\t\t\tset_host_byte(scsi, DID_OK);\n\t\telse {\n\t\t\tset_host_byte(scsi, DID_ERROR);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (unlikely(rsp_flags & FCP_SNS_LEN_VAL)) {\n\t\tsense = (char *) &fcp_rsp[1];\n\t\tif (rsp_flags & FCP_RSP_LEN_VAL)\n\t\t\tsense += be32_to_cpu(fcp_rsp->ext.fr_rsp_len);\n\t\tsense_len = min_t(u32, be32_to_cpu(fcp_rsp->ext.fr_sns_len),\n\t\t\t\t  SCSI_SENSE_BUFFERSIZE);\n\t\tmemcpy(scsi->sense_buffer, sense, sense_len);\n\t}\n\n\tif (unlikely(rsp_flags & FCP_RESID_UNDER)) {\n\t\tresid = be32_to_cpu(fcp_rsp->ext.fr_resid);\n\t\tscsi_set_resid(scsi, resid);\n\t\tif (scsi_bufflen(scsi) - resid < scsi->underflow &&\n\t\t     !(rsp_flags & FCP_SNS_LEN_VAL) &&\n\t\t     fcp_rsp->resp.fr_status == SAM_STAT_GOOD)\n\t\t\tset_host_byte(scsi, DID_ERROR);\n\t} else if (unlikely(rsp_flags & FCP_RESID_OVER)) {\n\t\t \n\t\tif (fcp_rsp->resp.fr_status == SAM_STAT_GOOD)\n\t\t\tset_host_byte(scsi, DID_ERROR);\n\t}\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}