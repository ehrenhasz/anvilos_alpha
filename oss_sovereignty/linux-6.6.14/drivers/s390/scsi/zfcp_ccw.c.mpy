{
  "module_name": "zfcp_ccw.c",
  "hash_id": "27efdf5e36c31dd253df13defbb7f75951f233e17d8f2d10b9b9aa7d19d39721",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_ccw.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include \"zfcp_ext.h\"\n#include \"zfcp_reqlist.h\"\n\n#define ZFCP_MODEL_PRIV 0x4\n\nstatic DEFINE_SPINLOCK(zfcp_ccw_adapter_ref_lock);\n\nstruct zfcp_adapter *zfcp_ccw_adapter_by_cdev(struct ccw_device *cdev)\n{\n\tstruct zfcp_adapter *adapter;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&zfcp_ccw_adapter_ref_lock, flags);\n\tadapter = dev_get_drvdata(&cdev->dev);\n\tif (adapter)\n\t\tkref_get(&adapter->ref);\n\tspin_unlock_irqrestore(&zfcp_ccw_adapter_ref_lock, flags);\n\treturn adapter;\n}\n\nvoid zfcp_ccw_adapter_put(struct zfcp_adapter *adapter)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&zfcp_ccw_adapter_ref_lock, flags);\n\tkref_put(&adapter->ref, zfcp_adapter_release);\n\tspin_unlock_irqrestore(&zfcp_ccw_adapter_ref_lock, flags);\n}\n\n \nstatic int zfcp_ccw_activate(struct ccw_device *cdev, int clear, char *tag)\n{\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\n\tif (!adapter)\n\t\treturn 0;\n\n\tzfcp_erp_clear_adapter_status(adapter, clear);\n\tzfcp_erp_set_adapter_status(adapter, ZFCP_STATUS_COMMON_RUNNING);\n\tzfcp_erp_adapter_reopen(adapter, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\ttag);\n\n\t \n\tmsleep(zfcp_fc_port_scan_backoff());\n\tzfcp_erp_wait(adapter);\n\tflush_delayed_work(&adapter->scan_work);\n\n\tzfcp_ccw_adapter_put(adapter);\n\n\treturn 0;\n}\n\nstatic struct ccw_device_id zfcp_ccw_device_id[] = {\n\t{ CCW_DEVICE_DEVTYPE(0x1731, 0x3, 0x1732, 0x3) },\n\t{ CCW_DEVICE_DEVTYPE(0x1731, 0x3, 0x1732, ZFCP_MODEL_PRIV) },\n\t{},\n};\nMODULE_DEVICE_TABLE(ccw, zfcp_ccw_device_id);\n\n \nstatic int zfcp_ccw_probe(struct ccw_device *cdev)\n{\n\treturn 0;\n}\n\n \nstatic void zfcp_ccw_remove(struct ccw_device *cdev)\n{\n\tstruct zfcp_adapter *adapter;\n\tstruct zfcp_port *port, *p;\n\tstruct zfcp_unit *unit, *u;\n\tLIST_HEAD(unit_remove_lh);\n\tLIST_HEAD(port_remove_lh);\n\n\tccw_device_set_offline(cdev);\n\n\tadapter = zfcp_ccw_adapter_by_cdev(cdev);\n\tif (!adapter)\n\t\treturn;\n\n\twrite_lock_irq(&adapter->port_list_lock);\n\tlist_for_each_entry(port, &adapter->port_list, list) {\n\t\twrite_lock(&port->unit_list_lock);\n\t\tlist_splice_init(&port->unit_list, &unit_remove_lh);\n\t\twrite_unlock(&port->unit_list_lock);\n\t}\n\tlist_splice_init(&adapter->port_list, &port_remove_lh);\n\twrite_unlock_irq(&adapter->port_list_lock);\n\tzfcp_ccw_adapter_put(adapter);  \n\n\tlist_for_each_entry_safe(unit, u, &unit_remove_lh, list)\n\t\tdevice_unregister(&unit->dev);\n\n\tlist_for_each_entry_safe(port, p, &port_remove_lh, list)\n\t\tdevice_unregister(&port->dev);\n\n\tzfcp_adapter_unregister(adapter);\n}\n\n \nstatic int zfcp_ccw_set_online(struct ccw_device *cdev)\n{\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\n\tif (!adapter) {\n\t\tadapter = zfcp_adapter_enqueue(cdev);\n\n\t\tif (IS_ERR(adapter)) {\n\t\t\tdev_err(&cdev->dev,\n\t\t\t\t\"Setting up data structures for the \"\n\t\t\t\t\"FCP adapter failed\\n\");\n\t\t\treturn PTR_ERR(adapter);\n\t\t}\n\t\tkref_get(&adapter->ref);\n\t}\n\n\t \n\tBUG_ON(!zfcp_reqlist_isempty(adapter->req_list));\n\tadapter->req_no = 0;\n\n\tzfcp_ccw_activate(cdev, 0, \"ccsonl1\");\n\n\t \n\tzfcp_fc_inverse_conditional_port_scan(adapter);\n\tflush_delayed_work(&adapter->scan_work);\n\tzfcp_ccw_adapter_put(adapter);\n\treturn 0;\n}\n\n \nstatic int zfcp_ccw_set_offline(struct ccw_device *cdev)\n{\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\n\tif (!adapter)\n\t\treturn 0;\n\n\tzfcp_erp_set_adapter_status(adapter, 0);\n\tzfcp_erp_adapter_shutdown(adapter, 0, \"ccsoff1\");\n\tzfcp_erp_wait(adapter);\n\n\tzfcp_ccw_adapter_put(adapter);\n\treturn 0;\n}\n\n \nstatic int zfcp_ccw_notify(struct ccw_device *cdev, int event)\n{\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\n\tif (!adapter)\n\t\treturn 1;\n\n\tswitch (event) {\n\tcase CIO_GONE:\n\t\tdev_warn(&cdev->dev, \"The FCP device has been detached\\n\");\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"ccnoti1\");\n\t\tbreak;\n\tcase CIO_NO_PATH:\n\t\tdev_warn(&cdev->dev,\n\t\t\t \"The CHPID for the FCP device is offline\\n\");\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"ccnoti2\");\n\t\tbreak;\n\tcase CIO_OPER:\n\t\tdev_info(&cdev->dev, \"The FCP device is operational again\\n\");\n\t\tzfcp_erp_set_adapter_status(adapter,\n\t\t\t\t\t    ZFCP_STATUS_COMMON_RUNNING);\n\t\tzfcp_erp_adapter_reopen(adapter, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\t\"ccnoti4\");\n\t\tbreak;\n\tcase CIO_BOXED:\n\t\tdev_warn(&cdev->dev, \"The FCP device did not respond within \"\n\t\t\t\t     \"the specified time\\n\");\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"ccnoti5\");\n\t\tbreak;\n\t}\n\n\tzfcp_ccw_adapter_put(adapter);\n\treturn 1;\n}\n\n \nstatic void zfcp_ccw_shutdown(struct ccw_device *cdev)\n{\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\n\tif (!adapter)\n\t\treturn;\n\n\tzfcp_erp_adapter_shutdown(adapter, 0, \"ccshut1\");\n\tzfcp_erp_wait(adapter);\n\tzfcp_erp_thread_kill(adapter);\n\n\tzfcp_ccw_adapter_put(adapter);\n}\n\nstruct ccw_driver zfcp_ccw_driver = {\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"zfcp\",\n\t},\n\t.ids         = zfcp_ccw_device_id,\n\t.probe       = zfcp_ccw_probe,\n\t.remove      = zfcp_ccw_remove,\n\t.set_online  = zfcp_ccw_set_online,\n\t.set_offline = zfcp_ccw_set_offline,\n\t.notify      = zfcp_ccw_notify,\n\t.shutdown    = zfcp_ccw_shutdown,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}