{
  "module_name": "zfcp_scsi.c",
  "hash_id": "2a0c606868e3393f8466c25ba5c2ed9c50284930899aa64d459b37328618b190",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_scsi.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <scsi/fc/fc_fcp.h>\n#include <scsi/scsi_eh.h>\n#include <linux/atomic.h>\n#include \"zfcp_ext.h\"\n#include \"zfcp_dbf.h\"\n#include \"zfcp_fc.h\"\n#include \"zfcp_reqlist.h\"\n\nstatic unsigned int default_depth = 32;\nmodule_param_named(queue_depth, default_depth, uint, 0600);\nMODULE_PARM_DESC(queue_depth, \"Default queue depth for new SCSI devices\");\n\nstatic bool enable_dif;\nmodule_param_named(dif, enable_dif, bool, 0400);\nMODULE_PARM_DESC(dif, \"Enable DIF data integrity support (default off)\");\n\nbool zfcp_experimental_dix;\nmodule_param_named(dix, zfcp_experimental_dix, bool, 0400);\nMODULE_PARM_DESC(dix, \"Enable experimental DIX (data integrity extension) support which implies DIF support (default off)\");\n\nstatic bool allow_lun_scan = true;\nmodule_param(allow_lun_scan, bool, 0600);\nMODULE_PARM_DESC(allow_lun_scan, \"For NPIV, scan and attach all storage LUNs\");\n\nstatic void zfcp_scsi_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\n\t \n\tif (!zfcp_sdev->port)\n\t\treturn;\n\n\tzfcp_erp_lun_shutdown_wait(sdev, \"scssd_1\");\n\tput_device(&zfcp_sdev->port->dev);\n}\n\nstatic int zfcp_scsi_slave_configure(struct scsi_device *sdp)\n{\n\tif (sdp->tagged_supported)\n\t\tscsi_change_queue_depth(sdp, default_depth);\n\treturn 0;\n}\n\nstatic void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)\n{\n\tset_host_byte(scpnt, result);\n\tzfcp_dbf_scsi_fail_send(scpnt);\n\tscsi_done(scpnt);\n}\n\nstatic\nint zfcp_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scpnt)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(scpnt->device));\n\tint    status, scsi_result, ret;\n\n\t \n\tscpnt->result = 0;\n\tscpnt->host_scribble = NULL;\n\n\tscsi_result = fc_remote_port_chkready(rport);\n\tif (unlikely(scsi_result)) {\n\t\tscpnt->result = scsi_result;\n\t\tzfcp_dbf_scsi_fail_send(scpnt);\n\t\tscsi_done(scpnt);\n\t\treturn 0;\n\t}\n\n\tstatus = atomic_read(&zfcp_sdev->status);\n\tif (unlikely(status & ZFCP_STATUS_COMMON_ERP_FAILED) &&\n\t\t     !(atomic_read(&zfcp_sdev->port->status) &\n\t\t       ZFCP_STATUS_COMMON_ERP_FAILED)) {\n\t\t \n\t\tzfcp_scsi_command_fail(scpnt, DID_ERROR);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!(status & ZFCP_STATUS_COMMON_UNBLOCKED))) {\n\t\t \n\t\tzfcp_scsi_command_fail(scpnt, DID_IMM_RETRY);\n\t\treturn 0;\n\t}\n\n\tret = zfcp_fsf_fcp_cmnd(scpnt);\n\tif (unlikely(ret == -EBUSY))\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\telse if (unlikely(ret < 0))\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\treturn ret;\n}\n\nstatic int zfcp_scsi_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tstruct zfcp_adapter *adapter =\n\t\t(struct zfcp_adapter *) sdev->host->hostdata[0];\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\tstruct zfcp_port *port;\n\tstruct zfcp_unit *unit;\n\tint npiv = adapter->connection_features & FSF_FEATURE_NPIV_MODE;\n\n\tzfcp_sdev->erp_action.adapter = adapter;\n\tzfcp_sdev->erp_action.sdev = sdev;\n\n\tport = zfcp_get_port_by_wwpn(adapter, rport->port_name);\n\tif (!port)\n\t\treturn -ENXIO;\n\n\tzfcp_sdev->erp_action.port = port;\n\n\tmutex_lock(&zfcp_sysfs_port_units_mutex);\n\tif (zfcp_sysfs_port_is_removing(port)) {\n\t\t \n\t\tmutex_unlock(&zfcp_sysfs_port_units_mutex);\n\t\tput_device(&port->dev);  \n\t\treturn -ENXIO;\n\t}\n\tmutex_unlock(&zfcp_sysfs_port_units_mutex);\n\n\tunit = zfcp_unit_find(port, zfcp_scsi_dev_lun(sdev));\n\tif (unit)\n\t\tput_device(&unit->dev);\n\n\tif (!unit && !(allow_lun_scan && npiv)) {\n\t\tput_device(&port->dev);\n\t\treturn -ENXIO;\n\t}\n\n\tzfcp_sdev->port = port;\n\tzfcp_sdev->latencies.write.channel.min = 0xFFFFFFFF;\n\tzfcp_sdev->latencies.write.fabric.min = 0xFFFFFFFF;\n\tzfcp_sdev->latencies.read.channel.min = 0xFFFFFFFF;\n\tzfcp_sdev->latencies.read.fabric.min = 0xFFFFFFFF;\n\tzfcp_sdev->latencies.cmd.channel.min = 0xFFFFFFFF;\n\tzfcp_sdev->latencies.cmd.fabric.min = 0xFFFFFFFF;\n\tspin_lock_init(&zfcp_sdev->latencies.lock);\n\n\tzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_RUNNING);\n\tzfcp_erp_lun_reopen(sdev, 0, \"scsla_1\");\n\tzfcp_erp_wait(port->adapter);\n\n\treturn 0;\n}\n\nstatic int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)\n{\n\tstruct Scsi_Host *scsi_host = scpnt->device->host;\n\tstruct zfcp_adapter *adapter =\n\t\t(struct zfcp_adapter *) scsi_host->hostdata[0];\n\tstruct zfcp_fsf_req *old_req, *abrt_req;\n\tunsigned long flags;\n\tu64 old_reqid = (u64) scpnt->host_scribble;\n\tint retval = SUCCESS, ret;\n\tint retry = 3;\n\tchar *dbf_tag;\n\n\t \n\twrite_lock_irqsave(&adapter->abort_lock, flags);\n\n\told_req = zfcp_reqlist_find(adapter->req_list, old_reqid);\n\tif (!old_req) {\n\t\twrite_unlock_irqrestore(&adapter->abort_lock, flags);\n\t\tzfcp_dbf_scsi_abort(\"abrt_or\", scpnt, NULL);\n\t\treturn FAILED;  \n\t}\n\told_req->data = NULL;\n\n\t \n\twrite_unlock_irqrestore(&adapter->abort_lock, flags);\n\n\twhile (retry--) {\n\t\tabrt_req = zfcp_fsf_abort_fcp_cmnd(scpnt);\n\t\tif (abrt_req)\n\t\t\tbreak;\n\n\t\tzfcp_dbf_scsi_abort(\"abrt_wt\", scpnt, NULL);\n\t\tzfcp_erp_wait(adapter);\n\t\tret = fc_block_scsi_eh(scpnt);\n\t\tif (ret) {\n\t\t\tzfcp_dbf_scsi_abort(\"abrt_bl\", scpnt, NULL);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(atomic_read(&adapter->status) &\n\t\t      ZFCP_STATUS_COMMON_RUNNING)) {\n\t\t\tzfcp_dbf_scsi_abort(\"abrt_ru\", scpnt, NULL);\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\tif (!abrt_req) {\n\t\tzfcp_dbf_scsi_abort(\"abrt_ar\", scpnt, NULL);\n\t\treturn FAILED;\n\t}\n\n\twait_for_completion(&abrt_req->completion);\n\n\tif (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED)\n\t\tdbf_tag = \"abrt_ok\";\n\telse if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED)\n\t\tdbf_tag = \"abrt_nn\";\n\telse {\n\t\tdbf_tag = \"abrt_fa\";\n\t\tretval = FAILED;\n\t}\n\tzfcp_dbf_scsi_abort(dbf_tag, scpnt, abrt_req);\n\tzfcp_fsf_req_free(abrt_req);\n\treturn retval;\n}\n\nstruct zfcp_scsi_req_filter {\n\tu8 tmf_scope;\n\tu32 lun_handle;\n\tu32 port_handle;\n};\n\nstatic void zfcp_scsi_forget_cmnd(struct zfcp_fsf_req *old_req, void *data)\n{\n\tstruct zfcp_scsi_req_filter *filter =\n\t\t(struct zfcp_scsi_req_filter *)data;\n\n\t \n\tif (old_req->data == NULL ||\n\t    zfcp_fsf_req_is_status_read_buffer(old_req) ||\n\t    old_req->qtcb->header.fsf_command != FSF_QTCB_FCP_CMND)\n\t\treturn;\n\n\t \n\tif (old_req->qtcb->header.port_handle != filter->port_handle)\n\t\treturn;\n\n\tif (filter->tmf_scope == FCP_TMF_LUN_RESET &&\n\t    old_req->qtcb->header.lun_handle != filter->lun_handle)\n\t\treturn;\n\n\tzfcp_dbf_scsi_nullcmnd((struct scsi_cmnd *)old_req->data, old_req);\n\told_req->data = NULL;\n}\n\nstatic void zfcp_scsi_forget_cmnds(struct zfcp_scsi_dev *zsdev, u8 tm_flags)\n{\n\tstruct zfcp_adapter *adapter = zsdev->port->adapter;\n\tstruct zfcp_scsi_req_filter filter = {\n\t\t.tmf_scope = FCP_TMF_TGT_RESET,\n\t\t.port_handle = zsdev->port->handle,\n\t};\n\tunsigned long flags;\n\n\tif (tm_flags == FCP_TMF_LUN_RESET) {\n\t\tfilter.tmf_scope = FCP_TMF_LUN_RESET;\n\t\tfilter.lun_handle = zsdev->lun_handle;\n\t}\n\n\t \n\twrite_lock_irqsave(&adapter->abort_lock, flags);\n\tzfcp_reqlist_apply_for_all(adapter->req_list, zfcp_scsi_forget_cmnd,\n\t\t\t\t   &filter);\n\twrite_unlock_irqrestore(&adapter->abort_lock, flags);\n}\n\n \nstatic int zfcp_scsi_task_mgmt_function(struct scsi_device *sdev, u8 tm_flags)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\tstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tstruct zfcp_fsf_req *fsf_req = NULL;\n\tint retval = SUCCESS, ret;\n\tint retry = 3;\n\n\twhile (retry--) {\n\t\tfsf_req = zfcp_fsf_fcp_task_mgmt(sdev, tm_flags);\n\t\tif (fsf_req)\n\t\t\tbreak;\n\n\t\tzfcp_dbf_scsi_devreset(\"wait\", sdev, tm_flags, NULL);\n\t\tzfcp_erp_wait(adapter);\n\t\tret = fc_block_rport(rport);\n\t\tif (ret) {\n\t\t\tzfcp_dbf_scsi_devreset(\"fiof\", sdev, tm_flags, NULL);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(atomic_read(&adapter->status) &\n\t\t      ZFCP_STATUS_COMMON_RUNNING)) {\n\t\t\tzfcp_dbf_scsi_devreset(\"nres\", sdev, tm_flags, NULL);\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\tif (!fsf_req) {\n\t\tzfcp_dbf_scsi_devreset(\"reqf\", sdev, tm_flags, NULL);\n\t\treturn FAILED;\n\t}\n\n\twait_for_completion(&fsf_req->completion);\n\n\tif (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {\n\t\tzfcp_dbf_scsi_devreset(\"fail\", sdev, tm_flags, fsf_req);\n\t\tretval = FAILED;\n\t} else {\n\t\tzfcp_dbf_scsi_devreset(\"okay\", sdev, tm_flags, fsf_req);\n\t\tzfcp_scsi_forget_cmnds(zfcp_sdev, tm_flags);\n\t}\n\n\tzfcp_fsf_req_free(fsf_req);\n\treturn retval;\n}\n\nstatic int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)\n{\n\tstruct scsi_device *sdev = scpnt->device;\n\n\treturn zfcp_scsi_task_mgmt_function(sdev, FCP_TMF_LUN_RESET);\n}\n\nstatic int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)\n{\n\tstruct scsi_target *starget = scsi_target(scpnt->device);\n\tstruct fc_rport *rport = starget_to_rport(starget);\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct scsi_device *sdev = NULL, *tmp_sdev;\n\tstruct zfcp_adapter *adapter =\n\t\t(struct zfcp_adapter *)shost->hostdata[0];\n\tint ret;\n\n\tshost_for_each_device(tmp_sdev, shost) {\n\t\tif (tmp_sdev->id == starget->id) {\n\t\t\tsdev = tmp_sdev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!sdev) {\n\t\tret = FAILED;\n\t\tzfcp_dbf_scsi_eh(\"tr_nosd\", adapter, starget->id, ret);\n\t\treturn ret;\n\t}\n\n\tret = zfcp_scsi_task_mgmt_function(sdev, FCP_TMF_TGT_RESET);\n\n\t \n\tif (sdev)\n\t\tscsi_device_put(tmp_sdev);\n\n\treturn ret;\n}\n\nstatic int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);\n\tstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\n\tint ret = SUCCESS, fc_ret;\n\n\tif (!(adapter->connection_features & FSF_FEATURE_NPIV_MODE)) {\n\t\tzfcp_erp_port_forced_reopen_all(adapter, 0, \"schrh_p\");\n\t\tzfcp_erp_wait(adapter);\n\t}\n\tzfcp_erp_adapter_reopen(adapter, 0, \"schrh_1\");\n\tzfcp_erp_wait(adapter);\n\tfc_ret = fc_block_scsi_eh(scpnt);\n\tif (fc_ret)\n\t\tret = fc_ret;\n\n\tzfcp_dbf_scsi_eh(\"schrh_r\", adapter, ~0, ret);\n\treturn ret;\n}\n\n \nstatic int zfcp_scsi_sysfs_host_reset(struct Scsi_Host *shost, int reset_type)\n{\n\tstruct zfcp_adapter *adapter =\n\t\t(struct zfcp_adapter *)shost->hostdata[0];\n\tint ret = 0;\n\n\tif (reset_type != SCSI_ADAPTER_RESET) {\n\t\tret = -EOPNOTSUPP;\n\t\tzfcp_dbf_scsi_eh(\"scshr_n\", adapter, ~0, ret);\n\t\treturn ret;\n\t}\n\n\tzfcp_erp_adapter_reset_sync(adapter, \"scshr_y\");\n\treturn ret;\n}\n\nstruct scsi_transport_template *zfcp_scsi_transport_template;\n\nstatic const struct scsi_host_template zfcp_scsi_host_template = {\n\t.module\t\t\t = THIS_MODULE,\n\t.name\t\t\t = \"zfcp\",\n\t.queuecommand\t\t = zfcp_scsi_queuecommand,\n\t.eh_timed_out\t\t = fc_eh_timed_out,\n\t.eh_abort_handler\t = zfcp_scsi_eh_abort_handler,\n\t.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,\n\t.eh_target_reset_handler = zfcp_scsi_eh_target_reset_handler,\n\t.eh_host_reset_handler\t = zfcp_scsi_eh_host_reset_handler,\n\t.slave_alloc\t\t = zfcp_scsi_slave_alloc,\n\t.slave_configure\t = zfcp_scsi_slave_configure,\n\t.slave_destroy\t\t = zfcp_scsi_slave_destroy,\n\t.change_queue_depth\t = scsi_change_queue_depth,\n\t.host_reset\t\t = zfcp_scsi_sysfs_host_reset,\n\t.proc_name\t\t = \"zfcp\",\n\t.can_queue\t\t = 4096,\n\t.this_id\t\t = -1,\n\t.sg_tablesize\t\t = (((QDIO_MAX_ELEMENTS_PER_BUFFER - 1)\n\t\t\t\t     * ZFCP_QDIO_MAX_SBALS_PER_REQ) - 2),\n\t\t\t\t    \n\t.max_sectors\t\t = (((QDIO_MAX_ELEMENTS_PER_BUFFER - 1)\n\t\t\t\t     * ZFCP_QDIO_MAX_SBALS_PER_REQ) - 2) * 8,\n\t\t\t\t    \n\t \n\t.max_segment_size\t = ZFCP_QDIO_SBALE_LEN,\n\t.dma_boundary\t\t = ZFCP_QDIO_SBALE_LEN - 1,\n\t.shost_groups\t\t = zfcp_sysfs_shost_attr_groups,\n\t.sdev_groups\t\t = zfcp_sysfs_sdev_attr_groups,\n\t.track_queue_depth\t = 1,\n\t.supported_mode\t\t = MODE_INITIATOR,\n};\n\n \nint zfcp_scsi_adapter_register(struct zfcp_adapter *adapter)\n{\n\tstruct ccw_dev_id dev_id;\n\n\tif (adapter->scsi_host)\n\t\treturn -EEXIST;\n\n\tccw_device_get_id(adapter->ccw_device, &dev_id);\n\t \n\tadapter->scsi_host = scsi_host_alloc(&zfcp_scsi_host_template,\n\t\t\t\t\t     sizeof (struct zfcp_adapter *));\n\tif (!adapter->scsi_host)\n\t\tgoto err_out;\n\n\t \n\tadapter->scsi_host->max_id = 511;\n\tadapter->scsi_host->max_lun = 0xFFFFFFFF;\n\tadapter->scsi_host->max_channel = 0;\n\tadapter->scsi_host->unique_id = dev_id.devno;\n\tadapter->scsi_host->max_cmd_len = 16;  \n\tadapter->scsi_host->transportt = zfcp_scsi_transport_template;\n\n\t \n\tzfcp_qdio_shost_update(adapter, adapter->qdio);\n\tzfcp_scsi_set_prot(adapter);\n\n\tadapter->scsi_host->hostdata[0] = (unsigned long) adapter;\n\n\tif (scsi_add_host(adapter->scsi_host, &adapter->ccw_device->dev)) {\n\t\tscsi_host_put(adapter->scsi_host);\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\nerr_out:\n\tadapter->scsi_host = NULL;\n\tdev_err(&adapter->ccw_device->dev,\n\t\t\"Registering the FCP device with the SCSI stack failed\\n\");\n\treturn -EIO;\n}\n\n \nvoid zfcp_scsi_adapter_unregister(struct zfcp_adapter *adapter)\n{\n\tstruct Scsi_Host *shost;\n\tstruct zfcp_port *port;\n\n\tshost = adapter->scsi_host;\n\tif (!shost)\n\t\treturn;\n\n\tread_lock_irq(&adapter->port_list_lock);\n\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\tport->rport = NULL;\n\tread_unlock_irq(&adapter->port_list_lock);\n\n\tfc_remove_host(shost);\n\tscsi_remove_host(shost);\n\tscsi_host_put(shost);\n\tadapter->scsi_host = NULL;\n}\n\nstatic struct fc_host_statistics*\nzfcp_scsi_init_fc_host_stats(struct zfcp_adapter *adapter)\n{\n\tstruct fc_host_statistics *fc_stats;\n\n\tif (!adapter->fc_stats) {\n\t\tfc_stats = kmalloc(sizeof(*fc_stats), GFP_KERNEL);\n\t\tif (!fc_stats)\n\t\t\treturn NULL;\n\t\tadapter->fc_stats = fc_stats;  \n\t}\n\tmemset(adapter->fc_stats, 0, sizeof(*adapter->fc_stats));\n\treturn adapter->fc_stats;\n}\n\nstatic void zfcp_scsi_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,\n\t\t\t\t\t   struct fsf_qtcb_bottom_port *data,\n\t\t\t\t\t   struct fsf_qtcb_bottom_port *old)\n{\n\tfc_stats->seconds_since_last_reset =\n\t\tdata->seconds_since_last_reset - old->seconds_since_last_reset;\n\tfc_stats->tx_frames = data->tx_frames - old->tx_frames;\n\tfc_stats->tx_words = data->tx_words - old->tx_words;\n\tfc_stats->rx_frames = data->rx_frames - old->rx_frames;\n\tfc_stats->rx_words = data->rx_words - old->rx_words;\n\tfc_stats->lip_count = data->lip - old->lip;\n\tfc_stats->nos_count = data->nos - old->nos;\n\tfc_stats->error_frames = data->error_frames - old->error_frames;\n\tfc_stats->dumped_frames = data->dumped_frames - old->dumped_frames;\n\tfc_stats->link_failure_count = data->link_failure - old->link_failure;\n\tfc_stats->loss_of_sync_count = data->loss_of_sync - old->loss_of_sync;\n\tfc_stats->loss_of_signal_count =\n\t\tdata->loss_of_signal - old->loss_of_signal;\n\tfc_stats->prim_seq_protocol_err_count =\n\t\tdata->psp_error_counts - old->psp_error_counts;\n\tfc_stats->invalid_tx_word_count =\n\t\tdata->invalid_tx_words - old->invalid_tx_words;\n\tfc_stats->invalid_crc_count = data->invalid_crcs - old->invalid_crcs;\n\tfc_stats->fcp_input_requests =\n\t\tdata->input_requests - old->input_requests;\n\tfc_stats->fcp_output_requests =\n\t\tdata->output_requests - old->output_requests;\n\tfc_stats->fcp_control_requests =\n\t\tdata->control_requests - old->control_requests;\n\tfc_stats->fcp_input_megabytes = data->input_mb - old->input_mb;\n\tfc_stats->fcp_output_megabytes = data->output_mb - old->output_mb;\n}\n\nstatic void zfcp_scsi_set_fc_host_stats(struct fc_host_statistics *fc_stats,\n\t\t\t\t\tstruct fsf_qtcb_bottom_port *data)\n{\n\tfc_stats->seconds_since_last_reset = data->seconds_since_last_reset;\n\tfc_stats->tx_frames = data->tx_frames;\n\tfc_stats->tx_words = data->tx_words;\n\tfc_stats->rx_frames = data->rx_frames;\n\tfc_stats->rx_words = data->rx_words;\n\tfc_stats->lip_count = data->lip;\n\tfc_stats->nos_count = data->nos;\n\tfc_stats->error_frames = data->error_frames;\n\tfc_stats->dumped_frames = data->dumped_frames;\n\tfc_stats->link_failure_count = data->link_failure;\n\tfc_stats->loss_of_sync_count = data->loss_of_sync;\n\tfc_stats->loss_of_signal_count = data->loss_of_signal;\n\tfc_stats->prim_seq_protocol_err_count = data->psp_error_counts;\n\tfc_stats->invalid_tx_word_count = data->invalid_tx_words;\n\tfc_stats->invalid_crc_count = data->invalid_crcs;\n\tfc_stats->fcp_input_requests = data->input_requests;\n\tfc_stats->fcp_output_requests = data->output_requests;\n\tfc_stats->fcp_control_requests = data->control_requests;\n\tfc_stats->fcp_input_megabytes = data->input_mb;\n\tfc_stats->fcp_output_megabytes = data->output_mb;\n}\n\nstatic struct fc_host_statistics *\nzfcp_scsi_get_fc_host_stats(struct Scsi_Host *host)\n{\n\tstruct zfcp_adapter *adapter;\n\tstruct fc_host_statistics *fc_stats;\n\tstruct fsf_qtcb_bottom_port *data;\n\tint ret;\n\n\tadapter = (struct zfcp_adapter *)host->hostdata[0];\n\tfc_stats = zfcp_scsi_init_fc_host_stats(adapter);\n\tif (!fc_stats)\n\t\treturn NULL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tret = zfcp_fsf_exchange_port_data_sync(adapter->qdio, data);\n\tif (ret != 0 && ret != -EAGAIN) {\n\t\tkfree(data);\n\t\treturn NULL;\n\t}\n\n\tif (adapter->stats_reset &&\n\t    ((jiffies/HZ - adapter->stats_reset) <\n\t     data->seconds_since_last_reset))\n\t\tzfcp_scsi_adjust_fc_host_stats(fc_stats, data,\n\t\t\t\t\t       adapter->stats_reset_data);\n\telse\n\t\tzfcp_scsi_set_fc_host_stats(fc_stats, data);\n\n\tkfree(data);\n\treturn fc_stats;\n}\n\nstatic void zfcp_scsi_reset_fc_host_stats(struct Scsi_Host *shost)\n{\n\tstruct zfcp_adapter *adapter;\n\tstruct fsf_qtcb_bottom_port *data;\n\tint ret;\n\n\tadapter = (struct zfcp_adapter *)shost->hostdata[0];\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\tret = zfcp_fsf_exchange_port_data_sync(adapter->qdio, data);\n\tif (ret != 0 && ret != -EAGAIN)\n\t\tkfree(data);\n\telse {\n\t\tadapter->stats_reset = jiffies/HZ;\n\t\tkfree(adapter->stats_reset_data);\n\t\tadapter->stats_reset_data = data;  \n\t}\n}\n\nstatic void zfcp_scsi_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct zfcp_adapter *adapter =\n\t\t(struct zfcp_adapter *)shost->hostdata[0];\n\tint status = atomic_read(&adapter->status);\n\n\tif ((status & ZFCP_STATUS_COMMON_RUNNING) &&\n\t    !(status & ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED))\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\telse if (status & ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED)\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\telse if (status & ZFCP_STATUS_COMMON_ERP_FAILED)\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ERROR;\n\telse\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n}\n\nstatic void zfcp_scsi_set_rport_dev_loss_tmo(struct fc_rport *rport,\n\t\t\t\t\t     u32 timeout)\n{\n\trport->dev_loss_tmo = timeout;\n}\n\n \nstatic void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)\n{\n\tstruct zfcp_port *port;\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct zfcp_adapter *adapter =\n\t\t(struct zfcp_adapter *)shost->hostdata[0];\n\n\tport = zfcp_get_port_by_wwpn(adapter, rport->port_name);\n\n\tif (port) {\n\t\tzfcp_erp_port_forced_reopen(port, 0, \"sctrpi1\");\n\t\tput_device(&port->dev);\n\t} else {\n\t\tzfcp_erp_port_forced_no_port_dbf(\n\t\t\t\"sctrpin\", adapter,\n\t\t\trport->port_name  ,\n\t\t\trport->port_id  );\n\t}\n}\n\nstatic void zfcp_scsi_rport_register(struct zfcp_port *port)\n{\n\tstruct fc_rport_identifiers ids;\n\tstruct fc_rport *rport;\n\n\tif (port->rport)\n\t\treturn;\n\n\tids.node_name = port->wwnn;\n\tids.port_name = port->wwpn;\n\tids.port_id = port->d_id;\n\tids.roles = FC_RPORT_ROLE_FCP_TARGET;\n\n\tzfcp_dbf_rec_trig_lock(\"scpaddy\", port->adapter, port, NULL,\n\t\t\t       ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD,\n\t\t\t       ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD);\n\trport = fc_remote_port_add(port->adapter->scsi_host, 0, &ids);\n\tif (!rport) {\n\t\tdev_err(&port->adapter->ccw_device->dev,\n\t\t\t\"Registering port 0x%016Lx failed\\n\",\n\t\t\t(unsigned long long)port->wwpn);\n\t\treturn;\n\t}\n\n\trport->maxframe_size = port->maxframe_size;\n\trport->supported_classes = port->supported_classes;\n\tport->rport = rport;\n\tport->starget_id = rport->scsi_target_id;\n\n\tzfcp_unit_queue_scsi_scan(port);\n}\n\nstatic void zfcp_scsi_rport_block(struct zfcp_port *port)\n{\n\tstruct fc_rport *rport = port->rport;\n\n\tif (rport) {\n\t\tzfcp_dbf_rec_trig_lock(\"scpdely\", port->adapter, port, NULL,\n\t\t\t\t       ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL,\n\t\t\t\t       ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL);\n\t\tfc_remote_port_delete(rport);\n\t\tport->rport = NULL;\n\t}\n}\n\nvoid zfcp_scsi_schedule_rport_register(struct zfcp_port *port)\n{\n\tget_device(&port->dev);\n\tport->rport_task = RPORT_ADD;\n\n\tif (!queue_work(port->adapter->work_queue, &port->rport_work))\n\t\tput_device(&port->dev);\n}\n\nvoid zfcp_scsi_schedule_rport_block(struct zfcp_port *port)\n{\n\tget_device(&port->dev);\n\tport->rport_task = RPORT_DEL;\n\n\tif (port->rport && queue_work(port->adapter->work_queue,\n\t\t\t\t      &port->rport_work))\n\t\treturn;\n\n\tput_device(&port->dev);\n}\n\nvoid zfcp_scsi_schedule_rports_block(struct zfcp_adapter *adapter)\n{\n\tunsigned long flags;\n\tstruct zfcp_port *port;\n\n\tread_lock_irqsave(&adapter->port_list_lock, flags);\n\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\tzfcp_scsi_schedule_rport_block(port);\n\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n}\n\nvoid zfcp_scsi_rport_work(struct work_struct *work)\n{\n\tstruct zfcp_port *port = container_of(work, struct zfcp_port,\n\t\t\t\t\t      rport_work);\n\n\tset_worker_desc(\"zrp%c-%16llx\",\n\t\t\t(port->rport_task == RPORT_ADD) ? 'a' : 'd',\n\t\t\tport->wwpn);  \n\twhile (port->rport_task) {\n\t\tif (port->rport_task == RPORT_ADD) {\n\t\t\tport->rport_task = RPORT_NONE;\n\t\t\tzfcp_scsi_rport_register(port);\n\t\t} else {\n\t\t\tport->rport_task = RPORT_NONE;\n\t\t\tzfcp_scsi_rport_block(port);\n\t\t}\n\t}\n\n\tput_device(&port->dev);\n}\n\n \nvoid zfcp_scsi_set_prot(struct zfcp_adapter *adapter)\n{\n\tunsigned int mask = 0;\n\tunsigned int data_div;\n\tstruct Scsi_Host *shost = adapter->scsi_host;\n\n\tdata_div = atomic_read(&adapter->status) &\n\t\t   ZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED;\n\n\tif ((enable_dif || zfcp_experimental_dix) &&\n\t    adapter->adapter_features & FSF_FEATURE_DIF_PROT_TYPE1)\n\t\tmask |= SHOST_DIF_TYPE1_PROTECTION;\n\n\tif (zfcp_experimental_dix && data_div &&\n\t    adapter->adapter_features & FSF_FEATURE_DIX_PROT_TCPIP) {\n\t\tmask |= SHOST_DIX_TYPE1_PROTECTION;\n\t\tscsi_host_set_guard(shost, SHOST_DIX_GUARD_IP);\n\t\tshost->sg_prot_tablesize = adapter->qdio->max_sbale_per_req / 2;\n\t\tshost->sg_tablesize = adapter->qdio->max_sbale_per_req / 2;\n\t\tshost->max_sectors = shost->sg_tablesize * 8;\n\t}\n\n\tscsi_host_set_prot(shost, mask);\n}\n\n \nvoid zfcp_scsi_dif_sense_error(struct scsi_cmnd *scmd, int ascq)\n{\n\tscsi_build_sense(scmd, 1, ILLEGAL_REQUEST, 0x10, ascq);\n\tset_host_byte(scmd, DID_SOFT_ERROR);\n}\n\nvoid zfcp_scsi_shost_update_config_data(\n\tstruct zfcp_adapter *const adapter,\n\tconst struct fsf_qtcb_bottom_config *const bottom,\n\tconst bool bottom_incomplete)\n{\n\tstruct Scsi_Host *const shost = adapter->scsi_host;\n\tconst struct fc_els_flogi *nsp, *plogi;\n\n\tif (shost == NULL)\n\t\treturn;\n\n\tsnprintf(fc_host_firmware_version(shost), FC_VERSION_STRING_SIZE,\n\t\t \"0x%08x\", bottom->lic_version);\n\n\tif (adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT) {\n\t\tsnprintf(fc_host_hardware_version(shost),\n\t\t\t FC_VERSION_STRING_SIZE,\n\t\t\t \"0x%08x\", bottom->hardware_version);\n\t\tmemcpy(fc_host_serial_number(shost), bottom->serial_number,\n\t\t       min(FC_SERIAL_NUMBER_SIZE, 17));\n\t\tEBCASC(fc_host_serial_number(shost),\n\t\t       min(FC_SERIAL_NUMBER_SIZE, 17));\n\t}\n\n\t \n\tnsp = (struct fc_els_flogi *) ((u8 *)&bottom->nport_serv_param\n\t\t\t\t\t- sizeof(u32));\n\tplogi = (struct fc_els_flogi *) ((u8 *)&bottom->plogi_payload\n\t\t\t\t\t- sizeof(u32));\n\n\tsnprintf(fc_host_manufacturer(shost), FC_SERIAL_NUMBER_SIZE, \"%s\",\n\t\t \"IBM\");\n\tfc_host_port_name(shost) = be64_to_cpu(nsp->fl_wwpn);\n\tfc_host_node_name(shost) = be64_to_cpu(nsp->fl_wwnn);\n\tfc_host_supported_classes(shost) = FC_COS_CLASS2 | FC_COS_CLASS3;\n\n\tzfcp_scsi_set_prot(adapter);\n\n\t \n\tif (bottom_incomplete)\n\t\treturn;\n\n\tfc_host_port_id(shost) = ntoh24(bottom->s_id);\n\tfc_host_speed(shost) =\n\t\tzfcp_fsf_convert_portspeed(bottom->fc_link_speed);\n\n\tsnprintf(fc_host_model(shost), FC_SYMBOLIC_NAME_SIZE, \"0x%04x\",\n\t\t bottom->adapter_type);\n\n\tswitch (bottom->fc_topology) {\n\tcase FSF_TOPO_P2P:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_PTP;\n\t\tfc_host_fabric_name(shost) = 0;\n\t\tbreak;\n\tcase FSF_TOPO_FABRIC:\n\t\tfc_host_fabric_name(shost) = be64_to_cpu(plogi->fl_wwnn);\n\t\tif (bottom->connection_features & FSF_FEATURE_NPIV_MODE)\n\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\n\t\telse\n\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\n\t\tbreak;\n\tcase FSF_TOPO_AL:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\n\t\tfallthrough;\n\tdefault:\n\t\tfc_host_fabric_name(shost) = 0;\n\t\tbreak;\n\t}\n}\n\nvoid zfcp_scsi_shost_update_port_data(\n\tstruct zfcp_adapter *const adapter,\n\tconst struct fsf_qtcb_bottom_port *const bottom)\n{\n\tstruct Scsi_Host *const shost = adapter->scsi_host;\n\n\tif (shost == NULL)\n\t\treturn;\n\n\tfc_host_permanent_port_name(shost) = bottom->wwpn;\n\tfc_host_maxframe_size(shost) = bottom->maximum_frame_size;\n\tfc_host_supported_speeds(shost) =\n\t\tzfcp_fsf_convert_portspeed(bottom->supported_speed);\n\tmemcpy(fc_host_supported_fc4s(shost), bottom->supported_fc4_types,\n\t       FC_FC4_LIST_SIZE);\n\tmemcpy(fc_host_active_fc4s(shost), bottom->active_fc4_types,\n\t       FC_FC4_LIST_SIZE);\n}\n\nstruct fc_function_template zfcp_transport_functions = {\n\t.show_starget_port_id = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_node_name = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_permanent_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\t.show_host_serial_number = 1,\n\t.show_host_manufacturer = 1,\n\t.show_host_model = 1,\n\t.show_host_hardware_version = 1,\n\t.show_host_firmware_version = 1,\n\t.get_fc_host_stats = zfcp_scsi_get_fc_host_stats,\n\t.reset_fc_host_stats = zfcp_scsi_reset_fc_host_stats,\n\t.set_rport_dev_loss_tmo = zfcp_scsi_set_rport_dev_loss_tmo,\n\t.get_host_port_state = zfcp_scsi_get_host_port_state,\n\t.terminate_rport_io = zfcp_scsi_terminate_rport_io,\n\t.show_host_port_state = 1,\n\t.show_host_active_fc4s = 1,\n\t.bsg_request = zfcp_fc_exec_bsg_job,\n\t.bsg_timeout = zfcp_fc_timeout_bsg_job,\n\t \n\t.show_host_port_type = 1,\n\t.show_host_symbolic_name = 1,\n\t.show_host_speed = 1,\n\t.show_host_port_id = 1,\n\t.show_host_fabric_name = 1,\n\t.dd_bsg_size = sizeof(struct zfcp_fsf_ct_els),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}