{
  "module_name": "zfcp_fsf.c",
  "hash_id": "d1abd25a3862fb89d76ce4223787d38a28f6fa73e0a74e09a56235ff404f5b28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_fsf.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/blktrace_api.h>\n#include <linux/jiffies.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <scsi/fc/fc_els.h>\n#include \"zfcp_ext.h\"\n#include \"zfcp_fc.h\"\n#include \"zfcp_dbf.h\"\n#include \"zfcp_qdio.h\"\n#include \"zfcp_reqlist.h\"\n#include \"zfcp_diag.h\"\n\n \n#define ZFCP_FSF_SCSI_ER_TIMEOUT (10*HZ)\n \n#define ZFCP_FSF_REQUEST_TIMEOUT (60*HZ)\n\nstruct kmem_cache *zfcp_fsf_qtcb_cache;\n\nstatic bool ber_stop = true;\nmodule_param(ber_stop, bool, 0600);\nMODULE_PARM_DESC(ber_stop,\n\t\t \"Shuts down FCP devices for FCP channels that report a bit-error count in excess of its threshold (default on)\");\n\nstatic void zfcp_fsf_request_timeout_handler(struct timer_list *t)\n{\n\tstruct zfcp_fsf_req *fsf_req = from_timer(fsf_req, t, timer);\n\tstruct zfcp_adapter *adapter = fsf_req->adapter;\n\n\tzfcp_qdio_siosl(adapter);\n\tzfcp_erp_adapter_reopen(adapter, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\"fsrth_1\");\n}\n\nstatic void zfcp_fsf_start_timer(struct zfcp_fsf_req *fsf_req,\n\t\t\t\t unsigned long timeout)\n{\n\tfsf_req->timer.function = zfcp_fsf_request_timeout_handler;\n\tfsf_req->timer.expires = jiffies + timeout;\n\tadd_timer(&fsf_req->timer);\n}\n\nstatic void zfcp_fsf_start_erp_timer(struct zfcp_fsf_req *fsf_req)\n{\n\tBUG_ON(!fsf_req->erp_action);\n\tfsf_req->timer.function = zfcp_erp_timeout_handler;\n\tfsf_req->timer.expires = jiffies + 30 * HZ;\n\tadd_timer(&fsf_req->timer);\n}\n\n \nstatic u32 fsf_qtcb_type[] = {\n\t[FSF_QTCB_FCP_CMND] =             FSF_IO_COMMAND,\n\t[FSF_QTCB_ABORT_FCP_CMND] =       FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_OPEN_PORT_WITH_DID] =   FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_OPEN_LUN] =             FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_CLOSE_LUN] =            FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_CLOSE_PORT] =           FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_CLOSE_PHYSICAL_PORT] =  FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_SEND_ELS] =             FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_SEND_GENERIC] =         FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_EXCHANGE_CONFIG_DATA] = FSF_CONFIG_COMMAND,\n\t[FSF_QTCB_EXCHANGE_PORT_DATA] =   FSF_PORT_COMMAND,\n\t[FSF_QTCB_DOWNLOAD_CONTROL_FILE] = FSF_SUPPORT_COMMAND,\n\t[FSF_QTCB_UPLOAD_CONTROL_FILE] =  FSF_SUPPORT_COMMAND\n};\n\nstatic void zfcp_fsf_class_not_supp(struct zfcp_fsf_req *req)\n{\n\tdev_err(&req->adapter->ccw_device->dev, \"FCP device not \"\n\t\t\"operational because of an unsupported FC class\\n\");\n\tzfcp_erp_adapter_shutdown(req->adapter, 0, \"fscns_1\");\n\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n}\n\n \nvoid zfcp_fsf_req_free(struct zfcp_fsf_req *req)\n{\n\tif (likely(req->pool)) {\n\t\tif (likely(!zfcp_fsf_req_is_status_read_buffer(req)))\n\t\t\tmempool_free(req->qtcb, req->adapter->pool.qtcb_pool);\n\t\tmempool_free(req, req->pool);\n\t\treturn;\n\t}\n\n\tif (likely(!zfcp_fsf_req_is_status_read_buffer(req)))\n\t\tkmem_cache_free(zfcp_fsf_qtcb_cache, req->qtcb);\n\tkfree(req);\n}\n\nstatic void zfcp_fsf_status_read_port_closed(struct zfcp_fsf_req *req)\n{\n\tunsigned long flags;\n\tstruct fsf_status_read_buffer *sr_buf = req->data;\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct zfcp_port *port;\n\tint d_id = ntoh24(sr_buf->d_id);\n\n\tread_lock_irqsave(&adapter->port_list_lock, flags);\n\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\tif (port->d_id == d_id) {\n\t\t\tzfcp_erp_port_reopen(port, 0, \"fssrpc1\");\n\t\t\tbreak;\n\t\t}\n\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n}\n\nvoid zfcp_fsf_fc_host_link_down(struct zfcp_adapter *adapter)\n{\n\tstruct Scsi_Host *shost = adapter->scsi_host;\n\n\tadapter->hydra_version = 0;\n\tadapter->peer_wwpn = 0;\n\tadapter->peer_wwnn = 0;\n\tadapter->peer_d_id = 0;\n\n\t \n\tif (shost == NULL)\n\t\treturn;\n\n\tfc_host_port_id(shost) = 0;\n\tfc_host_fabric_name(shost) = 0;\n\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\tfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\n\tsnprintf(fc_host_model(shost), FC_SYMBOLIC_NAME_SIZE, \"0x%04x\", 0);\n\tmemset(fc_host_active_fc4s(shost), 0, FC_FC4_LIST_SIZE);\n}\n\nstatic void zfcp_fsf_link_down_info_eval(struct zfcp_fsf_req *req,\n\t\t\t\t\t struct fsf_link_down_info *link_down)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\n\tif (atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED)\n\t\treturn;\n\n\tatomic_or(ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED, &adapter->status);\n\n\tzfcp_scsi_schedule_rports_block(adapter);\n\n\tzfcp_fsf_fc_host_link_down(adapter);\n\n\tif (!link_down)\n\t\tgoto out;\n\n\tswitch (link_down->error_code) {\n\tcase FSF_PSQ_LINK_NO_LIGHT:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"There is no light signal from the local \"\n\t\t\t \"fibre channel cable\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_WRAP_PLUG:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"There is a wrap plug instead of a fibre \"\n\t\t\t \"channel cable\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_NO_FCP:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The adjacent fibre channel node does not \"\n\t\t\t \"support FCP\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_FIRMWARE_UPDATE:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The FCP device is suspended because of a \"\n\t\t\t \"firmware update\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_INVALID_WWPN:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The FCP device detected a WWPN that is \"\n\t\t\t \"duplicate or not valid\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_NO_NPIV_SUPPORT:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The fibre channel fabric does not support NPIV\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_NO_FCP_RESOURCES:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The FCP adapter cannot support more NPIV ports\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_NO_FABRIC_RESOURCES:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The adjacent switch cannot support \"\n\t\t\t \"more NPIV ports\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_FABRIC_LOGIN_UNABLE:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The FCP adapter could not log in to the \"\n\t\t\t \"fibre channel fabric\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_WWPN_ASSIGNMENT_CORRUPTED:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The WWPN assignment file on the FCP adapter \"\n\t\t\t \"has been damaged\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_MODE_TABLE_CURRUPTED:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The mode table on the FCP adapter \"\n\t\t\t \"has been damaged\\n\");\n\t\tbreak;\n\tcase FSF_PSQ_LINK_NO_WWPN_ASSIGNMENT:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"All NPIV ports on the FCP adapter have \"\n\t\t\t \"been assigned\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"The link between the FCP adapter and \"\n\t\t\t \"the FC fabric is down\\n\");\n\t}\nout:\n\tzfcp_erp_set_adapter_status(adapter, ZFCP_STATUS_COMMON_ERP_FAILED);\n}\n\nstatic void zfcp_fsf_status_read_link_down(struct zfcp_fsf_req *req)\n{\n\tstruct fsf_status_read_buffer *sr_buf = req->data;\n\tstruct fsf_link_down_info *ldi =\n\t\t(struct fsf_link_down_info *) &sr_buf->payload;\n\n\tswitch (sr_buf->status_subtype) {\n\tcase FSF_STATUS_READ_SUB_NO_PHYSICAL_LINK:\n\tcase FSF_STATUS_READ_SUB_FDISC_FAILED:\n\t\tzfcp_fsf_link_down_info_eval(req, ldi);\n\t\tbreak;\n\tcase FSF_STATUS_READ_SUB_FIRMWARE_UPDATE:\n\t\tzfcp_fsf_link_down_info_eval(req, NULL);\n\t}\n}\n\nstatic void\nzfcp_fsf_status_read_version_change(struct zfcp_adapter *adapter,\n\t\t\t\t    struct fsf_status_read_buffer *sr_buf)\n{\n\tif (sr_buf->status_subtype == FSF_STATUS_READ_SUB_LIC_CHANGE) {\n\t\tu32 version = sr_buf->payload.version_change.current_version;\n\n\t\tWRITE_ONCE(adapter->fsf_lic_version, version);\n\t\tsnprintf(fc_host_firmware_version(adapter->scsi_host),\n\t\t\t FC_VERSION_STRING_SIZE, \"%#08x\", version);\n\t}\n}\n\nstatic void zfcp_fsf_status_read_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct fsf_status_read_buffer *sr_buf = req->data;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_DISMISSED) {\n\t\tzfcp_dbf_hba_fsf_uss(\"fssrh_1\", req);\n\t\tmempool_free(virt_to_page(sr_buf), adapter->pool.sr_data);\n\t\tzfcp_fsf_req_free(req);\n\t\treturn;\n\t}\n\n\tzfcp_dbf_hba_fsf_uss(\"fssrh_4\", req);\n\n\tswitch (sr_buf->status_type) {\n\tcase FSF_STATUS_READ_PORT_CLOSED:\n\t\tzfcp_fsf_status_read_port_closed(req);\n\t\tbreak;\n\tcase FSF_STATUS_READ_INCOMING_ELS:\n\t\tzfcp_fc_incoming_els(req);\n\t\tbreak;\n\tcase FSF_STATUS_READ_SENSE_DATA_AVAIL:\n\t\tbreak;\n\tcase FSF_STATUS_READ_BIT_ERROR_THRESHOLD:\n\t\tzfcp_dbf_hba_bit_err(\"fssrh_3\", req);\n\t\tif (ber_stop) {\n\t\t\tdev_warn(&adapter->ccw_device->dev,\n\t\t\t\t \"All paths over this FCP device are disused because of excessive bit errors\\n\");\n\t\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fssrh_b\");\n\t\t} else {\n\t\t\tdev_warn(&adapter->ccw_device->dev,\n\t\t\t\t \"The error threshold for checksum statistics has been exceeded\\n\");\n\t\t}\n\t\tbreak;\n\tcase FSF_STATUS_READ_LINK_DOWN:\n\t\tzfcp_fsf_status_read_link_down(req);\n\t\tzfcp_fc_enqueue_event(adapter, FCH_EVT_LINKDOWN, 0);\n\t\tbreak;\n\tcase FSF_STATUS_READ_LINK_UP:\n\t\tdev_info(&adapter->ccw_device->dev,\n\t\t\t \"The local link has been restored\\n\");\n\t\t \n\t\tzfcp_erp_set_adapter_status(adapter,\n\t\t\t\t\t    ZFCP_STATUS_COMMON_RUNNING);\n\t\tzfcp_erp_adapter_reopen(adapter,\n\t\t\t\t\tZFCP_STATUS_ADAPTER_LINK_UNPLUGGED |\n\t\t\t\t\tZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\t\"fssrh_2\");\n\t\tzfcp_fc_enqueue_event(adapter, FCH_EVT_LINKUP, 0);\n\n\t\tbreak;\n\tcase FSF_STATUS_READ_NOTIFICATION_LOST:\n\t\tif (sr_buf->status_subtype & FSF_STATUS_READ_SUB_INCOMING_ELS)\n\t\t\tzfcp_fc_conditional_port_scan(adapter);\n\t\tif (sr_buf->status_subtype & FSF_STATUS_READ_SUB_VERSION_CHANGE)\n\t\t\tqueue_work(adapter->work_queue,\n\t\t\t\t   &adapter->version_change_lost_work);\n\t\tbreak;\n\tcase FSF_STATUS_READ_FEATURE_UPDATE_ALERT:\n\t\tadapter->adapter_features = sr_buf->payload.word[0];\n\t\tbreak;\n\tcase FSF_STATUS_READ_VERSION_CHANGE:\n\t\tzfcp_fsf_status_read_version_change(adapter, sr_buf);\n\t\tbreak;\n\t}\n\n\tmempool_free(virt_to_page(sr_buf), adapter->pool.sr_data);\n\tzfcp_fsf_req_free(req);\n\n\tatomic_inc(&adapter->stat_miss);\n\tqueue_work(adapter->work_queue, &adapter->stat_work);\n}\n\nstatic void zfcp_fsf_fsfstatus_qual_eval(struct zfcp_fsf_req *req)\n{\n\tswitch (req->qtcb->header.fsf_status_qual.word[0]) {\n\tcase FSF_SQ_FCP_RSP_AVAILABLE:\n\tcase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\n\tcase FSF_SQ_NO_RETRY_POSSIBLE:\n\tcase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\n\t\treturn;\n\tcase FSF_SQ_COMMAND_ABORTED:\n\t\tbreak;\n\tcase FSF_SQ_NO_RECOM:\n\t\tdev_err(&req->adapter->ccw_device->dev,\n\t\t\t\"The FCP adapter reported a problem \"\n\t\t\t\"that cannot be recovered\\n\");\n\t\tzfcp_qdio_siosl(req->adapter);\n\t\tzfcp_erp_adapter_shutdown(req->adapter, 0, \"fsfsqe1\");\n\t\tbreak;\n\t}\n\t \n\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n}\n\nstatic void zfcp_fsf_fsfstatus_eval(struct zfcp_fsf_req *req)\n{\n\tif (unlikely(req->status & ZFCP_STATUS_FSFREQ_ERROR))\n\t\treturn;\n\n\tswitch (req->qtcb->header.fsf_status) {\n\tcase FSF_UNKNOWN_COMMAND:\n\t\tdev_err(&req->adapter->ccw_device->dev,\n\t\t\t\"The FCP adapter does not recognize the command 0x%x\\n\",\n\t\t\treq->qtcb->header.fsf_command);\n\t\tzfcp_erp_adapter_shutdown(req->adapter, 0, \"fsfse_1\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tzfcp_fsf_fsfstatus_qual_eval(req);\n\t\tbreak;\n\t}\n}\n\nstatic void zfcp_fsf_protstatus_eval(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct fsf_qtcb *qtcb = req->qtcb;\n\tunion fsf_prot_status_qual *psq = &qtcb->prefix.prot_status_qual;\n\n\tzfcp_dbf_hba_fsf_response(req);\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_DISMISSED) {\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\treturn;\n\t}\n\n\tswitch (qtcb->prefix.prot_status) {\n\tcase FSF_PROT_GOOD:\n\tcase FSF_PROT_FSF_STATUS_PRESENTED:\n\t\treturn;\n\tcase FSF_PROT_QTCB_VERSION_ERROR:\n\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\"QTCB version 0x%x not supported by FCP adapter \"\n\t\t\t\"(0x%x to 0x%x)\\n\", FSF_QTCB_CURRENT_VERSION,\n\t\t\tpsq->word[0], psq->word[1]);\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fspse_1\");\n\t\tbreak;\n\tcase FSF_PROT_ERROR_STATE:\n\tcase FSF_PROT_SEQ_NUMB_ERROR:\n\t\tzfcp_erp_adapter_reopen(adapter, 0, \"fspse_2\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_PROT_UNSUPP_QTCB_TYPE:\n\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\"The QTCB type is not supported by the FCP adapter\\n\");\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fspse_3\");\n\t\tbreak;\n\tcase FSF_PROT_HOST_CONNECTION_INITIALIZING:\n\t\tatomic_or(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,\n\t\t\t\t&adapter->status);\n\t\tbreak;\n\tcase FSF_PROT_DUPLICATE_REQUEST_ID:\n\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\"0x%Lx is an ambiguous request identifier\\n\",\n\t\t\t(unsigned long long)qtcb->bottom.support.req_handle);\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fspse_4\");\n\t\tbreak;\n\tcase FSF_PROT_LINK_DOWN:\n\t\tzfcp_fsf_link_down_info_eval(req, &psq->link_down_info);\n\t\t \n\t\tzfcp_erp_adapter_reopen(adapter, 0, \"fspse_6\");\n\t\tbreak;\n\tcase FSF_PROT_REEST_QUEUE:\n\t\t \n\t\tzfcp_erp_set_adapter_status(adapter,\n\t\t\t\t\t    ZFCP_STATUS_COMMON_RUNNING);\n\t\tzfcp_erp_adapter_reopen(adapter,\n\t\t\t\t\tZFCP_STATUS_ADAPTER_LINK_UNPLUGGED |\n\t\t\t\t\tZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\t\"fspse_8\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\"0x%x is not a valid transfer protocol status\\n\",\n\t\t\tqtcb->prefix.prot_status);\n\t\tzfcp_qdio_siosl(adapter);\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fspse_9\");\n\t}\n\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n}\n\n \nstatic void zfcp_fsf_req_complete(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_erp_action *erp_action;\n\n\tif (unlikely(zfcp_fsf_req_is_status_read_buffer(req))) {\n\t\tzfcp_fsf_status_read_handler(req);\n\t\treturn;\n\t}\n\n\tdel_timer_sync(&req->timer);\n\tzfcp_fsf_protstatus_eval(req);\n\tzfcp_fsf_fsfstatus_eval(req);\n\treq->handler(req);\n\n\terp_action = req->erp_action;\n\tif (erp_action)\n\t\tzfcp_erp_notify(erp_action, 0);\n\n\tif (likely(req->status & ZFCP_STATUS_FSFREQ_CLEANUP))\n\t\tzfcp_fsf_req_free(req);\n\telse\n\t\tcomplete(&req->completion);\n}\n\n \nvoid zfcp_fsf_req_dismiss_all(struct zfcp_adapter *adapter)\n{\n\tstruct zfcp_fsf_req *req, *tmp;\n\tLIST_HEAD(remove_queue);\n\n\tBUG_ON(atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP);\n\tzfcp_reqlist_move(adapter->req_list, &remove_queue);\n\n\tlist_for_each_entry_safe(req, tmp, &remove_queue, list) {\n\t\tlist_del(&req->list);\n\t\treq->status |= ZFCP_STATUS_FSFREQ_DISMISSED;\n\t\tzfcp_fsf_req_complete(req);\n\t}\n}\n\n#define ZFCP_FSF_PORTSPEED_1GBIT\t(1 <<  0)\n#define ZFCP_FSF_PORTSPEED_2GBIT\t(1 <<  1)\n#define ZFCP_FSF_PORTSPEED_4GBIT\t(1 <<  2)\n#define ZFCP_FSF_PORTSPEED_10GBIT\t(1 <<  3)\n#define ZFCP_FSF_PORTSPEED_8GBIT\t(1 <<  4)\n#define ZFCP_FSF_PORTSPEED_16GBIT\t(1 <<  5)\n#define ZFCP_FSF_PORTSPEED_32GBIT\t(1 <<  6)\n#define ZFCP_FSF_PORTSPEED_64GBIT\t(1 <<  7)\n#define ZFCP_FSF_PORTSPEED_128GBIT\t(1 <<  8)\n#define ZFCP_FSF_PORTSPEED_NOT_NEGOTIATED (1 << 15)\n\nu32 zfcp_fsf_convert_portspeed(u32 fsf_speed)\n{\n\tu32 fdmi_speed = 0;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_1GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_1GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_2GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_2GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_4GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_4GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_10GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_10GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_8GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_8GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_16GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_16GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_32GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_32GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_64GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_64GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_128GBIT)\n\t\tfdmi_speed |= FC_PORTSPEED_128GBIT;\n\tif (fsf_speed & ZFCP_FSF_PORTSPEED_NOT_NEGOTIATED)\n\t\tfdmi_speed |= FC_PORTSPEED_NOT_NEGOTIATED;\n\treturn fdmi_speed;\n}\n\nstatic int zfcp_fsf_exchange_config_evaluate(struct zfcp_fsf_req *req)\n{\n\tstruct fsf_qtcb_bottom_config *bottom = &req->qtcb->bottom.config;\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct fc_els_flogi *plogi;\n\n\t \n\tplogi = (struct fc_els_flogi *) ((u8 *)&bottom->plogi_payload\n\t\t\t\t\t- sizeof(u32));\n\n\tif (req->data)\n\t\tmemcpy(req->data, bottom, sizeof(*bottom));\n\n\tadapter->timer_ticks = bottom->timer_interval & ZFCP_FSF_TIMER_INT_MASK;\n\tadapter->stat_read_buf_num = max(bottom->status_read_buf_num,\n\t\t\t\t\t (u16)FSF_STATUS_READS_RECOM);\n\n\t \n\t \n\tif (req->qtcb->header.fsf_status == FSF_EXCHANGE_CONFIG_DATA_INCOMPLETE)\n\t\treturn 0;\n\n\tadapter->hydra_version = bottom->adapter_type;\n\n\tswitch (bottom->fc_topology) {\n\tcase FSF_TOPO_P2P:\n\t\tadapter->peer_d_id = ntoh24(bottom->peer_d_id);\n\t\tadapter->peer_wwpn = be64_to_cpu(plogi->fl_wwpn);\n\t\tadapter->peer_wwnn = be64_to_cpu(plogi->fl_wwnn);\n\t\tbreak;\n\tcase FSF_TOPO_FABRIC:\n\t\tbreak;\n\tcase FSF_TOPO_AL:\n\tdefault:\n\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\"Unknown or unsupported arbitrated loop \"\n\t\t\t\"fibre channel topology detected\\n\");\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fsece_1\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void zfcp_fsf_exchange_config_data_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct zfcp_diag_header *const diag_hdr =\n\t\t&adapter->diagnostics->config_data.header;\n\tstruct fsf_qtcb *qtcb = req->qtcb;\n\tstruct fsf_qtcb_bottom_config *bottom = &qtcb->bottom.config;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\treturn;\n\n\tadapter->fsf_lic_version = bottom->lic_version;\n\tadapter->adapter_features = bottom->adapter_features;\n\tadapter->connection_features = bottom->connection_features;\n\tadapter->peer_wwpn = 0;\n\tadapter->peer_wwnn = 0;\n\tadapter->peer_d_id = 0;\n\n\tswitch (qtcb->header.fsf_status) {\n\tcase FSF_GOOD:\n\t\t \n\t\tzfcp_diag_update_xdata(diag_hdr, bottom, false);\n\n\t\tzfcp_scsi_shost_update_config_data(adapter, bottom, false);\n\t\tif (zfcp_fsf_exchange_config_evaluate(req))\n\t\t\treturn;\n\n\t\tif (bottom->max_qtcb_size < sizeof(struct fsf_qtcb)) {\n\t\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\t\"FCP adapter maximum QTCB size (%d bytes) \"\n\t\t\t\t\"is too small\\n\",\n\t\t\t\tbottom->max_qtcb_size);\n\t\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fsecdh1\");\n\t\t\treturn;\n\t\t}\n\t\tatomic_or(ZFCP_STATUS_ADAPTER_XCONFIG_OK,\n\t\t\t\t&adapter->status);\n\t\tbreak;\n\tcase FSF_EXCHANGE_CONFIG_DATA_INCOMPLETE:\n\t\tzfcp_diag_update_xdata(diag_hdr, bottom, true);\n\t\treq->status |= ZFCP_STATUS_FSFREQ_XDATAINCOMPLETE;\n\n\t\t \n\t\tatomic_or(ZFCP_STATUS_ADAPTER_XCONFIG_OK,\n\t\t\t\t&adapter->status);\n\t\tzfcp_fsf_link_down_info_eval(req,\n\t\t\t&qtcb->header.fsf_status_qual.link_down_info);\n\n\t\tzfcp_scsi_shost_update_config_data(adapter, bottom, true);\n\t\tif (zfcp_fsf_exchange_config_evaluate(req))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fsecdh3\");\n\t\treturn;\n\t}\n\n\tif (adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT)\n\t\tadapter->hardware_version = bottom->hardware_version;\n\n\tif (FSF_QTCB_CURRENT_VERSION < bottom->low_qtcb_version) {\n\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\"The FCP adapter only supports newer \"\n\t\t\t\"control block versions\\n\");\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fsecdh4\");\n\t\treturn;\n\t}\n\tif (FSF_QTCB_CURRENT_VERSION > bottom->high_qtcb_version) {\n\t\tdev_err(&adapter->ccw_device->dev,\n\t\t\t\"The FCP adapter only supports older \"\n\t\t\t\"control block versions\\n\");\n\t\tzfcp_erp_adapter_shutdown(adapter, 0, \"fsecdh5\");\n\t}\n}\n\n \nstatic const struct {\n\tu32\tmask;\n\tchar\t*name;\n} zfcp_fsf_fc_security_mnemonics[] = {\n\t{ FSF_FC_SECURITY_AUTH,\t\t\"Authentication\" },\n\t{ FSF_FC_SECURITY_ENC_FCSP2 |\n\t  FSF_FC_SECURITY_ENC_ERAS,\t\"Encryption\" },\n};\n\n \n#define ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH 15\n\n \nssize_t zfcp_fsf_scnprint_fc_security(char *buf, size_t size, u32 fc_security,\n\t\t\t\t      enum zfcp_fsf_print_fmt fmt)\n{\n\tconst char *prefix = \"\";\n\tssize_t len = 0;\n\tint i;\n\n\tif (fc_security == 0)\n\t\treturn scnprintf(buf, size, \"none\");\n\tif (fmt == ZFCP_FSF_PRINT_FMT_SINGLEITEM && hweight32(fc_security) != 1)\n\t\treturn scnprintf(buf, size, \"0x%08x\", fc_security);\n\n\tfor (i = 0; i < ARRAY_SIZE(zfcp_fsf_fc_security_mnemonics); i++) {\n\t\tif (!(fc_security & zfcp_fsf_fc_security_mnemonics[i].mask))\n\t\t\tcontinue;\n\n\t\tlen += scnprintf(buf + len, size - len, \"%s%s\", prefix,\n\t\t\t\t zfcp_fsf_fc_security_mnemonics[i].name);\n\t\tprefix = \", \";\n\t\tfc_security &= ~zfcp_fsf_fc_security_mnemonics[i].mask;\n\t}\n\n\tif (fc_security != 0)\n\t\tlen += scnprintf(buf + len, size - len, \"%s0x%08x\",\n\t\t\t\t prefix, fc_security);\n\n\treturn len;\n}\n\nstatic void zfcp_fsf_dbf_adapter_fc_security(struct zfcp_adapter *adapter,\n\t\t\t\t\t     struct zfcp_fsf_req *req)\n{\n\tif (adapter->fc_security_algorithms ==\n\t    adapter->fc_security_algorithms_old) {\n\t\t \n\t\treturn;\n\t}\n\n\tzfcp_dbf_hba_fsf_fces(\"fsfcesa\", req, ZFCP_DBF_INVALID_WWPN,\n\t\t\t      adapter->fc_security_algorithms_old,\n\t\t\t      adapter->fc_security_algorithms);\n\n\tadapter->fc_security_algorithms_old = adapter->fc_security_algorithms;\n}\n\nstatic void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct fsf_qtcb_bottom_port *bottom = &req->qtcb->bottom.port;\n\n\tif (req->data)\n\t\tmemcpy(req->data, bottom, sizeof(*bottom));\n\n\tif (adapter->adapter_features & FSF_FEATURE_FC_SECURITY)\n\t\tadapter->fc_security_algorithms =\n\t\t\tbottom->fc_security_algorithms;\n\telse\n\t\tadapter->fc_security_algorithms = 0;\n\tzfcp_fsf_dbf_adapter_fc_security(adapter, req);\n}\n\nstatic void zfcp_fsf_exchange_port_data_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_diag_header *const diag_hdr =\n\t\t&req->adapter->diagnostics->port_data.header;\n\tstruct fsf_qtcb *qtcb = req->qtcb;\n\tstruct fsf_qtcb_bottom_port *bottom = &qtcb->bottom.port;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\treturn;\n\n\tswitch (qtcb->header.fsf_status) {\n\tcase FSF_GOOD:\n\t\t \n\t\tzfcp_diag_update_xdata(diag_hdr, bottom, false);\n\n\t\tzfcp_scsi_shost_update_port_data(req->adapter, bottom);\n\t\tzfcp_fsf_exchange_port_evaluate(req);\n\t\tbreak;\n\tcase FSF_EXCHANGE_CONFIG_DATA_INCOMPLETE:\n\t\tzfcp_diag_update_xdata(diag_hdr, bottom, true);\n\t\treq->status |= ZFCP_STATUS_FSFREQ_XDATAINCOMPLETE;\n\n\t\tzfcp_fsf_link_down_info_eval(req,\n\t\t\t&qtcb->header.fsf_status_qual.link_down_info);\n\n\t\tzfcp_scsi_shost_update_port_data(req->adapter, bottom);\n\t\tzfcp_fsf_exchange_port_evaluate(req);\n\t\tbreak;\n\t}\n}\n\nstatic struct zfcp_fsf_req *zfcp_fsf_alloc(mempool_t *pool)\n{\n\tstruct zfcp_fsf_req *req;\n\n\tif (likely(pool))\n\t\treq = mempool_alloc(pool, GFP_ATOMIC);\n\telse\n\t\treq = kmalloc(sizeof(*req), GFP_ATOMIC);\n\n\tif (unlikely(!req))\n\t\treturn NULL;\n\n\tmemset(req, 0, sizeof(*req));\n\treq->pool = pool;\n\treturn req;\n}\n\nstatic struct fsf_qtcb *zfcp_fsf_qtcb_alloc(mempool_t *pool)\n{\n\tstruct fsf_qtcb *qtcb;\n\n\tif (likely(pool))\n\t\tqtcb = mempool_alloc(pool, GFP_ATOMIC);\n\telse\n\t\tqtcb = kmem_cache_alloc(zfcp_fsf_qtcb_cache, GFP_ATOMIC);\n\n\tif (unlikely(!qtcb))\n\t\treturn NULL;\n\n\tmemset(qtcb, 0, sizeof(*qtcb));\n\treturn qtcb;\n}\n\nstatic struct zfcp_fsf_req *zfcp_fsf_req_create(struct zfcp_qdio *qdio,\n\t\t\t\t\t\tu32 fsf_cmd, u8 sbtype,\n\t\t\t\t\t\tmempool_t *pool)\n{\n\tstruct zfcp_adapter *adapter = qdio->adapter;\n\tstruct zfcp_fsf_req *req = zfcp_fsf_alloc(pool);\n\n\tif (unlikely(!req))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (adapter->req_no == 0)\n\t\tadapter->req_no++;\n\n\ttimer_setup(&req->timer, NULL, 0);\n\tinit_completion(&req->completion);\n\n\treq->adapter = adapter;\n\treq->req_id = adapter->req_no;\n\n\tif (likely(fsf_cmd != FSF_QTCB_UNSOLICITED_STATUS)) {\n\t\tif (likely(pool))\n\t\t\treq->qtcb = zfcp_fsf_qtcb_alloc(\n\t\t\t\tadapter->pool.qtcb_pool);\n\t\telse\n\t\t\treq->qtcb = zfcp_fsf_qtcb_alloc(NULL);\n\n\t\tif (unlikely(!req->qtcb)) {\n\t\t\tzfcp_fsf_req_free(req);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\treq->qtcb->prefix.req_seq_no = adapter->fsf_req_seq_no;\n\t\treq->qtcb->prefix.req_id = req->req_id;\n\t\treq->qtcb->prefix.ulp_info = 26;\n\t\treq->qtcb->prefix.qtcb_type = fsf_qtcb_type[fsf_cmd];\n\t\treq->qtcb->prefix.qtcb_version = FSF_QTCB_CURRENT_VERSION;\n\t\treq->qtcb->header.req_handle = req->req_id;\n\t\treq->qtcb->header.fsf_command = fsf_cmd;\n\t}\n\n\tzfcp_qdio_req_init(adapter->qdio, &req->qdio_req, req->req_id, sbtype,\n\t\t\t   req->qtcb, sizeof(struct fsf_qtcb));\n\n\treturn req;\n}\n\nstatic int zfcp_fsf_req_send(struct zfcp_fsf_req *req)\n{\n\tconst bool is_srb = zfcp_fsf_req_is_status_read_buffer(req);\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct zfcp_qdio *qdio = adapter->qdio;\n\tu64 req_id = req->req_id;\n\n\tzfcp_reqlist_add(adapter->req_list, req);\n\n\treq->qdio_req.qdio_outb_usage = atomic_read(&qdio->req_q_free);\n\treq->issued = get_tod_clock();\n\tif (zfcp_qdio_send(qdio, &req->qdio_req)) {\n\t\tdel_timer_sync(&req->timer);\n\n\t\t \n\t\tif (zfcp_reqlist_find_rm(adapter->req_list, req_id) == NULL)\n\t\t\tzfcp_dbf_hba_fsf_reqid(\"fsrsrmf\", 1, adapter, req_id);\n\n\t\tzfcp_erp_adapter_reopen(adapter, 0, \"fsrs__1\");\n\t\treturn -EIO;\n\t}\n\n\t \n\n\t \n\tif (!is_srb)\n\t\tadapter->fsf_req_seq_no++;\n\tadapter->req_no++;\n\n\treturn 0;\n}\n\n \nint zfcp_fsf_status_read(struct zfcp_qdio *qdio)\n{\n\tstruct zfcp_adapter *adapter = qdio->adapter;\n\tstruct zfcp_fsf_req *req;\n\tstruct fsf_status_read_buffer *sr_buf;\n\tstruct page *page;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_UNSOLICITED_STATUS,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_STATUS,\n\t\t\t\t  adapter->pool.status_read_req);\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tpage = mempool_alloc(adapter->pool.sr_data, GFP_ATOMIC);\n\tif (!page) {\n\t\tretval = -ENOMEM;\n\t\tgoto failed_buf;\n\t}\n\tsr_buf = page_address(page);\n\tmemset(sr_buf, 0, sizeof(*sr_buf));\n\treq->data = sr_buf;\n\n\tzfcp_qdio_fill_next(qdio, &req->qdio_req, sr_buf, sizeof(*sr_buf));\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval)\n\t\tgoto failed_req_send;\n\t \n\n\tgoto out;\n\nfailed_req_send:\n\treq->data = NULL;\n\tmempool_free(virt_to_page(sr_buf), adapter->pool.sr_data);\nfailed_buf:\n\tzfcp_dbf_hba_fsf_uss(\"fssr__1\", req);\n\tzfcp_fsf_req_free(req);\nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_abort_fcp_command_handler(struct zfcp_fsf_req *req)\n{\n\tstruct scsi_device *sdev = req->data;\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\tunion fsf_status_qual *fsq = &req->qtcb->header.fsf_status_qual;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\treturn;\n\n\tzfcp_sdev = sdev_to_zfcp(sdev);\n\n\tswitch (req->qtcb->header.fsf_status) {\n\tcase FSF_PORT_HANDLE_NOT_VALID:\n\t\tif (fsq->word[0] == fsq->word[1]) {\n\t\t\tzfcp_erp_adapter_reopen(zfcp_sdev->port->adapter, 0,\n\t\t\t\t\t\t\"fsafch1\");\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t}\n\t\tbreak;\n\tcase FSF_LUN_HANDLE_NOT_VALID:\n\t\tif (fsq->word[0] == fsq->word[1]) {\n\t\t\tzfcp_erp_port_reopen(zfcp_sdev->port, 0, \"fsafch2\");\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t}\n\t\tbreak;\n\tcase FSF_FCP_COMMAND_DOES_NOT_EXIST:\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED;\n\t\tbreak;\n\tcase FSF_PORT_BOXED:\n\t\tzfcp_erp_set_port_status(zfcp_sdev->port,\n\t\t\t\t\t ZFCP_STATUS_COMMON_ACCESS_BOXED);\n\t\tzfcp_erp_port_reopen(zfcp_sdev->port,\n\t\t\t\t     ZFCP_STATUS_COMMON_ERP_FAILED, \"fsafch3\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_LUN_BOXED:\n\t\tzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_ACCESS_BOXED);\n\t\tzfcp_erp_lun_reopen(sdev, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t    \"fsafch4\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n                break;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tswitch (fsq->word[0]) {\n\t\tcase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\n\t\t\tzfcp_fc_test_link(zfcp_sdev->port);\n\t\t\tfallthrough;\n\t\tcase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FSF_GOOD:\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED;\n\t\tbreak;\n\t}\n}\n\n \n\nstruct zfcp_fsf_req *zfcp_fsf_abort_fcp_cmnd(struct scsi_cmnd *scmnd)\n{\n\tstruct zfcp_fsf_req *req = NULL;\n\tstruct scsi_device *sdev = scmnd->device;\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\tstruct zfcp_qdio *qdio = zfcp_sdev->port->adapter->qdio;\n\tu64 old_req_id = (u64) scmnd->host_scribble;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_ABORT_FCP_CMND,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.scsi_abort);\n\tif (IS_ERR(req)) {\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!(atomic_read(&zfcp_sdev->status) &\n\t\t       ZFCP_STATUS_COMMON_UNBLOCKED)))\n\t\tgoto out_error_free;\n\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->data = sdev;\n\treq->handler = zfcp_fsf_abort_fcp_command_handler;\n\treq->qtcb->header.lun_handle = zfcp_sdev->lun_handle;\n\treq->qtcb->header.port_handle = zfcp_sdev->port->handle;\n\treq->qtcb->bottom.support.req_handle = old_req_id;\n\n\tzfcp_fsf_start_timer(req, ZFCP_FSF_SCSI_ER_TIMEOUT);\n\tif (!zfcp_fsf_req_send(req)) {\n\t\t \n\t\tgoto out;\n\t}\n\nout_error_free:\n\tzfcp_fsf_req_free(req);\n\treq = NULL;\nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn req;\n}\n\nstatic void zfcp_fsf_send_ct_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct zfcp_fsf_ct_els *ct = req->data;\n\tstruct fsf_qtcb_header *header = &req->qtcb->header;\n\n\tct->status = -EINVAL;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\tgoto skip_fsfstatus;\n\n\tswitch (header->fsf_status) {\n        case FSF_GOOD:\n\t\tct->status = 0;\n\t\tzfcp_dbf_san_res(\"fsscth2\", req);\n\t\tbreak;\n        case FSF_SERVICE_CLASS_NOT_SUPPORTED:\n\t\tzfcp_fsf_class_not_supp(req);\n\t\tbreak;\n        case FSF_ADAPTER_STATUS_AVAILABLE:\n                switch (header->fsf_status_qual.word[0]){\n                case FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\n                case FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t\tbreak;\n                }\n                break;\n        case FSF_PORT_BOXED:\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_PORT_HANDLE_NOT_VALID:\n\t\tzfcp_erp_adapter_reopen(adapter, 0, \"fsscth1\");\n\t\tfallthrough;\n\tcase FSF_GENERIC_COMMAND_REJECTED:\n\tcase FSF_PAYLOAD_SIZE_MISMATCH:\n\tcase FSF_REQUEST_SIZE_TOO_LARGE:\n\tcase FSF_RESPONSE_SIZE_TOO_LARGE:\n\tcase FSF_SBAL_MISMATCH:\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\t}\n\nskip_fsfstatus:\n\tif (ct->handler)\n\t\tct->handler(ct->handler_data);\n}\n\nstatic void zfcp_fsf_setup_ct_els_unchained(struct zfcp_qdio *qdio,\n\t\t\t\t\t    struct zfcp_qdio_req *q_req,\n\t\t\t\t\t    struct scatterlist *sg_req,\n\t\t\t\t\t    struct scatterlist *sg_resp)\n{\n\tzfcp_qdio_fill_next(qdio, q_req, sg_virt(sg_req), sg_req->length);\n\tzfcp_qdio_fill_next(qdio, q_req, sg_virt(sg_resp), sg_resp->length);\n\tzfcp_qdio_set_sbale_last(qdio, q_req);\n}\n\nstatic int zfcp_fsf_setup_ct_els_sbals(struct zfcp_fsf_req *req,\n\t\t\t\t       struct scatterlist *sg_req,\n\t\t\t\t       struct scatterlist *sg_resp)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct zfcp_qdio *qdio = adapter->qdio;\n\tstruct fsf_qtcb *qtcb = req->qtcb;\n\tu32 feat = adapter->adapter_features;\n\n\tif (zfcp_adapter_multi_buffer_active(adapter)) {\n\t\tif (zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req, sg_req))\n\t\t\treturn -EIO;\n\t\tqtcb->bottom.support.req_buf_length =\n\t\t\tzfcp_qdio_real_bytes(sg_req);\n\t\tif (zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req, sg_resp))\n\t\t\treturn -EIO;\n\t\tqtcb->bottom.support.resp_buf_length =\n\t\t\tzfcp_qdio_real_bytes(sg_resp);\n\n\t\tzfcp_qdio_set_data_div(qdio, &req->qdio_req, sg_nents(sg_req));\n\t\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\t\tzfcp_qdio_set_scount(qdio, &req->qdio_req);\n\t\treturn 0;\n\t}\n\n\t \n\tif (zfcp_qdio_sg_one_sbale(sg_req) && zfcp_qdio_sg_one_sbale(sg_resp)) {\n\t\tzfcp_fsf_setup_ct_els_unchained(qdio, &req->qdio_req,\n\t\t\t\t\t\tsg_req, sg_resp);\n\t\treturn 0;\n\t}\n\n\tif (!(feat & FSF_FEATURE_ELS_CT_CHAINED_SBALS))\n\t\treturn -EOPNOTSUPP;\n\n\tif (zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req, sg_req))\n\t\treturn -EIO;\n\n\tqtcb->bottom.support.req_buf_length = zfcp_qdio_real_bytes(sg_req);\n\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\tzfcp_qdio_skip_to_last_sbale(qdio, &req->qdio_req);\n\n\tif (zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req, sg_resp))\n\t\treturn -EIO;\n\n\tqtcb->bottom.support.resp_buf_length = zfcp_qdio_real_bytes(sg_resp);\n\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treturn 0;\n}\n\nstatic int zfcp_fsf_setup_ct_els(struct zfcp_fsf_req *req,\n\t\t\t\t struct scatterlist *sg_req,\n\t\t\t\t struct scatterlist *sg_resp,\n\t\t\t\t unsigned int timeout)\n{\n\tint ret;\n\n\tret = zfcp_fsf_setup_ct_els_sbals(req, sg_req, sg_resp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (timeout > 255)\n\t\ttimeout = 255;  \n\treq->qtcb->bottom.support.service_class = FSF_CLASS_3;\n\treq->qtcb->bottom.support.timeout = timeout;\n\tzfcp_fsf_start_timer(req, (timeout + 10) * HZ);\n\n\treturn 0;\n}\n\n \nint zfcp_fsf_send_ct(struct zfcp_fc_wka_port *wka_port,\n\t\t     struct zfcp_fsf_ct_els *ct, mempool_t *pool,\n\t\t     unsigned int timeout)\n{\n\tstruct zfcp_qdio *qdio = wka_port->adapter->qdio;\n\tstruct zfcp_fsf_req *req;\n\tint ret = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_SEND_GENERIC,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_WRITE_READ, pool);\n\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tret = zfcp_fsf_setup_ct_els(req, ct->req, ct->resp, timeout);\n\tif (ret)\n\t\tgoto failed_send;\n\n\treq->handler = zfcp_fsf_send_ct_handler;\n\treq->qtcb->header.port_handle = wka_port->handle;\n\tct->d_id = wka_port->d_id;\n\treq->data = ct;\n\n\tzfcp_dbf_san_req(\"fssct_1\", req, wka_port->d_id);\n\n\tret = zfcp_fsf_req_send(req);\n\tif (ret)\n\t\tgoto failed_send;\n\t \n\n\tgoto out;\n\nfailed_send:\n\tzfcp_fsf_req_free(req);\nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn ret;\n}\n\nstatic void zfcp_fsf_send_els_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_fsf_ct_els *send_els = req->data;\n\tstruct fsf_qtcb_header *header = &req->qtcb->header;\n\n\tsend_els->status = -EINVAL;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\tgoto skip_fsfstatus;\n\n\tswitch (header->fsf_status) {\n\tcase FSF_GOOD:\n\t\tsend_els->status = 0;\n\t\tzfcp_dbf_san_res(\"fsselh1\", req);\n\t\tbreak;\n\tcase FSF_SERVICE_CLASS_NOT_SUPPORTED:\n\t\tzfcp_fsf_class_not_supp(req);\n\t\tbreak;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tswitch (header->fsf_status_qual.word[0]){\n\t\tcase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\n\t\tcase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\n\t\tcase FSF_SQ_RETRY_IF_POSSIBLE:\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FSF_ELS_COMMAND_REJECTED:\n\tcase FSF_PAYLOAD_SIZE_MISMATCH:\n\tcase FSF_REQUEST_SIZE_TOO_LARGE:\n\tcase FSF_RESPONSE_SIZE_TOO_LARGE:\n\t\tbreak;\n\tcase FSF_SBAL_MISMATCH:\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\t}\nskip_fsfstatus:\n\tif (send_els->handler)\n\t\tsend_els->handler(send_els->handler_data);\n}\n\n \nint zfcp_fsf_send_els(struct zfcp_adapter *adapter, u32 d_id,\n\t\t      struct zfcp_fsf_ct_els *els, unsigned int timeout)\n{\n\tstruct zfcp_fsf_req *req;\n\tstruct zfcp_qdio *qdio = adapter->qdio;\n\tint ret = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_SEND_ELS,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_WRITE_READ, NULL);\n\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\n\tif (!zfcp_adapter_multi_buffer_active(adapter))\n\t\tzfcp_qdio_sbal_limit(qdio, &req->qdio_req, 2);\n\n\tret = zfcp_fsf_setup_ct_els(req, els->req, els->resp, timeout);\n\n\tif (ret)\n\t\tgoto failed_send;\n\n\thton24(req->qtcb->bottom.support.d_id, d_id);\n\treq->handler = zfcp_fsf_send_els_handler;\n\tels->d_id = d_id;\n\treq->data = els;\n\n\tzfcp_dbf_san_req(\"fssels1\", req, d_id);\n\n\tret = zfcp_fsf_req_send(req);\n\tif (ret)\n\t\tgoto failed_send;\n\t \n\n\tgoto out;\n\nfailed_send:\n\tzfcp_fsf_req_free(req);\nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn ret;\n}\n\nint zfcp_fsf_exchange_config_data(struct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_fsf_req *req;\n\tstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_EXCHANGE_CONFIG_DATA,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->qtcb->bottom.config.feature_selection =\n\t\t\tFSF_FEATURE_NOTIFICATION_LOST |\n\t\t\tFSF_FEATURE_UPDATE_ALERT |\n\t\t\tFSF_FEATURE_REQUEST_SFP_DATA |\n\t\t\tFSF_FEATURE_FC_SECURITY;\n\treq->erp_action = erp_action;\n\treq->handler = zfcp_fsf_exchange_config_data_handler;\n\terp_action->fsf_req_id = req->req_id;\n\n\tzfcp_fsf_start_erp_timer(req);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval) {\n\t\tzfcp_fsf_req_free(req);\n\t\terp_action->fsf_req_id = 0;\n\t}\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\n\n \nint zfcp_fsf_exchange_config_data_sync(struct zfcp_qdio *qdio,\n\t\t\t\t       struct fsf_qtcb_bottom_config *data)\n{\n\tstruct zfcp_fsf_req *req = NULL;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out_unlock;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_EXCHANGE_CONFIG_DATA,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ, NULL);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out_unlock;\n\t}\n\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\treq->handler = zfcp_fsf_exchange_config_data_handler;\n\n\treq->qtcb->bottom.config.feature_selection =\n\t\t\tFSF_FEATURE_NOTIFICATION_LOST |\n\t\t\tFSF_FEATURE_UPDATE_ALERT |\n\t\t\tFSF_FEATURE_REQUEST_SFP_DATA |\n\t\t\tFSF_FEATURE_FC_SECURITY;\n\n\tif (data)\n\t\treq->data = data;\n\n\tzfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);\n\tretval = zfcp_fsf_req_send(req);\n\tspin_unlock_irq(&qdio->req_q_lock);\n\n\tif (!retval) {\n\t\t \n\t\twait_for_completion(&req->completion);\n\n\t\tif (req->status &\n\t\t    (ZFCP_STATUS_FSFREQ_ERROR | ZFCP_STATUS_FSFREQ_DISMISSED))\n\t\t\tretval = -EIO;\n\t\telse if (req->status & ZFCP_STATUS_FSFREQ_XDATAINCOMPLETE)\n\t\t\tretval = -EAGAIN;\n\t}\n\n\tzfcp_fsf_req_free(req);\n\treturn retval;\n\nout_unlock:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\n \nint zfcp_fsf_exchange_port_data(struct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\n\tstruct zfcp_fsf_req *req;\n\tint retval = -EIO;\n\n\tif (!(qdio->adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT))\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_EXCHANGE_PORT_DATA,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->handler = zfcp_fsf_exchange_port_data_handler;\n\treq->erp_action = erp_action;\n\terp_action->fsf_req_id = req->req_id;\n\n\tzfcp_fsf_start_erp_timer(req);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval) {\n\t\tzfcp_fsf_req_free(req);\n\t\terp_action->fsf_req_id = 0;\n\t}\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\n \nint zfcp_fsf_exchange_port_data_sync(struct zfcp_qdio *qdio,\n\t\t\t\t     struct fsf_qtcb_bottom_port *data)\n{\n\tstruct zfcp_fsf_req *req = NULL;\n\tint retval = -EIO;\n\n\tif (!(qdio->adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT))\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out_unlock;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_EXCHANGE_PORT_DATA,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ, NULL);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out_unlock;\n\t}\n\n\tif (data)\n\t\treq->data = data;\n\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->handler = zfcp_fsf_exchange_port_data_handler;\n\tzfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);\n\tretval = zfcp_fsf_req_send(req);\n\tspin_unlock_irq(&qdio->req_q_lock);\n\n\tif (!retval) {\n\t\t \n\t\twait_for_completion(&req->completion);\n\n\t\tif (req->status &\n\t\t    (ZFCP_STATUS_FSFREQ_ERROR | ZFCP_STATUS_FSFREQ_DISMISSED))\n\t\t\tretval = -EIO;\n\t\telse if (req->status & ZFCP_STATUS_FSFREQ_XDATAINCOMPLETE)\n\t\t\tretval = -EAGAIN;\n\t}\n\n\tzfcp_fsf_req_free(req);\n\treturn retval;\n\nout_unlock:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_log_port_fc_security(struct zfcp_port *port,\n\t\t\t\t\t  struct zfcp_fsf_req *req)\n{\n\tchar mnemonic_old[ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH];\n\tchar mnemonic_new[ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH];\n\n\tif (port->connection_info == port->connection_info_old) {\n\t\t \n\t\treturn;\n\t}\n\n\tzfcp_dbf_hba_fsf_fces(\"fsfcesp\", req, port->wwpn,\n\t\t\t      port->connection_info_old,\n\t\t\t      port->connection_info);\n\n\tzfcp_fsf_scnprint_fc_security(mnemonic_old, sizeof(mnemonic_old),\n\t\t\t\t      port->connection_info_old,\n\t\t\t\t      ZFCP_FSF_PRINT_FMT_SINGLEITEM);\n\tzfcp_fsf_scnprint_fc_security(mnemonic_new, sizeof(mnemonic_new),\n\t\t\t\t      port->connection_info,\n\t\t\t\t      ZFCP_FSF_PRINT_FMT_SINGLEITEM);\n\n\tif (strncmp(mnemonic_old, mnemonic_new,\n\t\t    ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH) == 0) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (port->connection_info_old == 0) {\n\t\t \n\t\tdev_info(&port->adapter->ccw_device->dev,\n\t\t\t \"FC Endpoint Security of connection to remote port 0x%16llx enabled: %s\\n\",\n\t\t\t port->wwpn, mnemonic_new);\n\t} else if (port->connection_info == 0) {\n\t\t \n\t\tdev_warn(&port->adapter->ccw_device->dev,\n\t\t\t \"FC Endpoint Security of connection to remote port 0x%16llx disabled: was %s\\n\",\n\t\t\t port->wwpn, mnemonic_old);\n\t} else {\n\t\t \n\t\tdev_warn(&port->adapter->ccw_device->dev,\n\t\t\t \"FC Endpoint Security of connection to remote port 0x%16llx changed: from %s to %s\\n\",\n\t\t\t port->wwpn, mnemonic_old, mnemonic_new);\n\t}\n\nout:\n\tport->connection_info_old = port->connection_info;\n}\n\nstatic void zfcp_fsf_log_security_error(const struct device *dev, u32 fsf_sqw0,\n\t\t\t\t\tu64 wwpn)\n{\n\tswitch (fsf_sqw0) {\n\n\t \n\n\tcase FSF_SQ_SECURITY_REQUIRED:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"FC Endpoint Security error: FC security is required but not supported or configured on remote port 0x%016llx\\n\",\n\t\t\t\t     wwpn);\n\t\tbreak;\n\tcase FSF_SQ_SECURITY_TIMEOUT:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"FC Endpoint Security error: a timeout prevented opening remote port 0x%016llx\\n\",\n\t\t\t\t     wwpn);\n\t\tbreak;\n\tcase FSF_SQ_SECURITY_KM_UNAVAILABLE:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"FC Endpoint Security error: opening remote port 0x%016llx failed because local and external key manager cannot communicate\\n\",\n\t\t\t\t     wwpn);\n\t\tbreak;\n\tcase FSF_SQ_SECURITY_RKM_UNAVAILABLE:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"FC Endpoint Security error: opening remote port 0x%016llx failed because it cannot communicate with the external key manager\\n\",\n\t\t\t\t     wwpn);\n\t\tbreak;\n\tcase FSF_SQ_SECURITY_AUTH_FAILURE:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"FC Endpoint Security error: the device could not verify the identity of remote port 0x%016llx\\n\",\n\t\t\t\t     wwpn);\n\t\tbreak;\n\n\t \n\n\tcase FSF_SQ_SECURITY_ENC_FAILURE:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"FC Endpoint Security error: FC connection to remote port 0x%016llx closed because encryption broke down\\n\",\n\t\t\t\t     wwpn);\n\t\tbreak;\n\n\t \n\n\tdefault:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"FC Endpoint Security error: the device issued an unknown error code 0x%08x related to the FC connection to remote port 0x%016llx\\n\",\n\t\t\t\t     fsf_sqw0, wwpn);\n\t}\n}\n\nstatic void zfcp_fsf_open_port_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct zfcp_port *port = req->data;\n\tstruct fsf_qtcb_header *header = &req->qtcb->header;\n\tstruct fsf_qtcb_bottom_support *bottom = &req->qtcb->bottom.support;\n\tstruct fc_els_flogi *plogi;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\tgoto out;\n\n\tswitch (header->fsf_status) {\n\tcase FSF_PORT_ALREADY_OPEN:\n\t\tbreak;\n\tcase FSF_MAXIMUM_NUMBER_OF_PORTS_EXCEEDED:\n\t\tdev_warn(&adapter->ccw_device->dev,\n\t\t\t \"Not enough FCP adapter resources to open \"\n\t\t\t \"remote port 0x%016Lx\\n\",\n\t\t\t (unsigned long long)port->wwpn);\n\t\tzfcp_erp_set_port_status(port,\n\t\t\t\t\t ZFCP_STATUS_COMMON_ERP_FAILED);\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_SECURITY_ERROR:\n\t\tzfcp_fsf_log_security_error(&req->adapter->ccw_device->dev,\n\t\t\t\t\t    header->fsf_status_qual.word[0],\n\t\t\t\t\t    port->wwpn);\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tswitch (header->fsf_status_qual.word[0]) {\n\t\tcase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\n\t\tcase FSF_SQ_NO_RETRY_POSSIBLE:\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FSF_GOOD:\n\t\tport->handle = header->port_handle;\n\t\tif (adapter->adapter_features & FSF_FEATURE_FC_SECURITY)\n\t\t\tport->connection_info = bottom->connection_info;\n\t\telse\n\t\t\tport->connection_info = 0;\n\t\tzfcp_fsf_log_port_fc_security(port, req);\n\t\tatomic_or(ZFCP_STATUS_COMMON_OPEN |\n\t\t\t\tZFCP_STATUS_PORT_PHYS_OPEN, &port->status);\n\t\tatomic_andnot(ZFCP_STATUS_COMMON_ACCESS_BOXED,\n\t\t                  &port->status);\n\t\t \n\t\t \n\t\tplogi = (struct fc_els_flogi *) bottom->els;\n\t\tif (bottom->els1_length >= FSF_PLOGI_MIN_LEN)\n\t\t\tzfcp_fc_plogi_evaluate(port, plogi);\n\t\tbreak;\n\tcase FSF_UNKNOWN_OP_SUBTYPE:\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\t}\n\nout:\n\tput_device(&port->dev);\n}\n\n \nint zfcp_fsf_open_port(struct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\n\tstruct zfcp_port *port = erp_action->port;\n\tstruct zfcp_fsf_req *req;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_OPEN_PORT_WITH_DID,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->handler = zfcp_fsf_open_port_handler;\n\thton24(req->qtcb->bottom.support.d_id, port->d_id);\n\treq->data = port;\n\treq->erp_action = erp_action;\n\terp_action->fsf_req_id = req->req_id;\n\tget_device(&port->dev);\n\n\tzfcp_fsf_start_erp_timer(req);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval) {\n\t\tzfcp_fsf_req_free(req);\n\t\terp_action->fsf_req_id = 0;\n\t\tput_device(&port->dev);\n\t}\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_close_port_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_port *port = req->data;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\treturn;\n\n\tswitch (req->qtcb->header.fsf_status) {\n\tcase FSF_PORT_HANDLE_NOT_VALID:\n\t\tzfcp_erp_adapter_reopen(port->adapter, 0, \"fscph_1\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tbreak;\n\tcase FSF_GOOD:\n\t\tzfcp_erp_clear_port_status(port, ZFCP_STATUS_COMMON_OPEN);\n\t\tbreak;\n\t}\n}\n\n \nint zfcp_fsf_close_port(struct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\n\tstruct zfcp_fsf_req *req;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_CLOSE_PORT,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->handler = zfcp_fsf_close_port_handler;\n\treq->data = erp_action->port;\n\treq->erp_action = erp_action;\n\treq->qtcb->header.port_handle = erp_action->port->handle;\n\terp_action->fsf_req_id = req->req_id;\n\n\tzfcp_fsf_start_erp_timer(req);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval) {\n\t\tzfcp_fsf_req_free(req);\n\t\terp_action->fsf_req_id = 0;\n\t}\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_open_wka_port_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_fc_wka_port *wka_port = req->data;\n\tstruct fsf_qtcb_header *header = &req->qtcb->header;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR) {\n\t\twka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\n\t\tgoto out;\n\t}\n\n\tswitch (header->fsf_status) {\n\tcase FSF_MAXIMUM_NUMBER_OF_PORTS_EXCEEDED:\n\t\tdev_warn(&req->adapter->ccw_device->dev,\n\t\t\t \"Opening WKA port 0x%x failed\\n\", wka_port->d_id);\n\t\tfallthrough;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\twka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\n\t\tbreak;\n\tcase FSF_GOOD:\n\t\twka_port->handle = header->port_handle;\n\t\tfallthrough;\n\tcase FSF_PORT_ALREADY_OPEN:\n\t\twka_port->status = ZFCP_FC_WKA_PORT_ONLINE;\n\t}\nout:\n\twake_up(&wka_port->opened);\n}\n\n \nint zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)\n{\n\tstruct zfcp_qdio *qdio = wka_port->adapter->qdio;\n\tstruct zfcp_fsf_req *req;\n\tu64 req_id = 0;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_OPEN_PORT_WITH_DID,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->handler = zfcp_fsf_open_wka_port_handler;\n\thton24(req->qtcb->bottom.support.d_id, wka_port->d_id);\n\treq->data = wka_port;\n\n\treq_id = req->req_id;\n\n\tzfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval)\n\t\tzfcp_fsf_req_free(req);\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\tif (!retval)\n\t\tzfcp_dbf_rec_run_wka(\"fsowp_1\", wka_port, req_id);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_close_wka_port_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_fc_wka_port *wka_port = req->data;\n\n\tif (req->qtcb->header.fsf_status == FSF_PORT_HANDLE_NOT_VALID) {\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tzfcp_erp_adapter_reopen(wka_port->adapter, 0, \"fscwph1\");\n\t}\n\n\twka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\n\twake_up(&wka_port->closed);\n}\n\n \nint zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)\n{\n\tstruct zfcp_qdio *qdio = wka_port->adapter->qdio;\n\tstruct zfcp_fsf_req *req;\n\tu64 req_id = 0;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_CLOSE_PORT,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->handler = zfcp_fsf_close_wka_port_handler;\n\treq->data = wka_port;\n\treq->qtcb->header.port_handle = wka_port->handle;\n\n\treq_id = req->req_id;\n\n\tzfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval)\n\t\tzfcp_fsf_req_free(req);\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\tif (!retval)\n\t\tzfcp_dbf_rec_run_wka(\"fscwp_1\", wka_port, req_id);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_close_physical_port_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_port *port = req->data;\n\tstruct fsf_qtcb_header *header = &req->qtcb->header;\n\tstruct scsi_device *sdev;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\treturn;\n\n\tswitch (header->fsf_status) {\n\tcase FSF_PORT_HANDLE_NOT_VALID:\n\t\tzfcp_erp_adapter_reopen(port->adapter, 0, \"fscpph1\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_PORT_BOXED:\n\t\t \n\t\tatomic_andnot(ZFCP_STATUS_PORT_PHYS_OPEN, &port->status);\n\t\tshost_for_each_device(sdev, port->adapter->scsi_host)\n\t\t\tif (sdev_to_zfcp(sdev)->port == port)\n\t\t\t\tatomic_andnot(ZFCP_STATUS_COMMON_OPEN,\n\t\t\t\t\t\t  &sdev_to_zfcp(sdev)->status);\n\t\tzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_ACCESS_BOXED);\n\t\tzfcp_erp_port_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t     \"fscpph2\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tswitch (header->fsf_status_qual.word[0]) {\n\t\tcase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\n\t\tcase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FSF_GOOD:\n\t\t \n\t\tatomic_andnot(ZFCP_STATUS_PORT_PHYS_OPEN, &port->status);\n\t\tshost_for_each_device(sdev, port->adapter->scsi_host)\n\t\t\tif (sdev_to_zfcp(sdev)->port == port)\n\t\t\t\tatomic_andnot(ZFCP_STATUS_COMMON_OPEN,\n\t\t\t\t\t\t  &sdev_to_zfcp(sdev)->status);\n\t\tbreak;\n\t}\n}\n\n \nint zfcp_fsf_close_physical_port(struct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\n\tstruct zfcp_fsf_req *req;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_CLOSE_PHYSICAL_PORT,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->data = erp_action->port;\n\treq->qtcb->header.port_handle = erp_action->port->handle;\n\treq->erp_action = erp_action;\n\treq->handler = zfcp_fsf_close_physical_port_handler;\n\terp_action->fsf_req_id = req->req_id;\n\n\tzfcp_fsf_start_erp_timer(req);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval) {\n\t\tzfcp_fsf_req_free(req);\n\t\terp_action->fsf_req_id = 0;\n\t}\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_open_lun_handler(struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct scsi_device *sdev = req->data;\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\tstruct fsf_qtcb_header *header = &req->qtcb->header;\n\tunion fsf_status_qual *qual = &header->fsf_status_qual;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\treturn;\n\n\tzfcp_sdev = sdev_to_zfcp(sdev);\n\n\tatomic_andnot(ZFCP_STATUS_COMMON_ACCESS_DENIED |\n\t\t\t  ZFCP_STATUS_COMMON_ACCESS_BOXED,\n\t\t\t  &zfcp_sdev->status);\n\n\tswitch (header->fsf_status) {\n\n\tcase FSF_PORT_HANDLE_NOT_VALID:\n\t\tzfcp_erp_adapter_reopen(adapter, 0, \"fsouh_1\");\n\t\tfallthrough;\n\tcase FSF_LUN_ALREADY_OPEN:\n\t\tbreak;\n\tcase FSF_PORT_BOXED:\n\t\tzfcp_erp_set_port_status(zfcp_sdev->port,\n\t\t\t\t\t ZFCP_STATUS_COMMON_ACCESS_BOXED);\n\t\tzfcp_erp_port_reopen(zfcp_sdev->port,\n\t\t\t\t     ZFCP_STATUS_COMMON_ERP_FAILED, \"fsouh_2\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_LUN_SHARING_VIOLATION:\n\t\tif (qual->word[0])\n\t\t\tdev_warn(&zfcp_sdev->port->adapter->ccw_device->dev,\n\t\t\t\t \"LUN 0x%016Lx on port 0x%016Lx is already in \"\n\t\t\t\t \"use by CSS%d, MIF Image ID %x\\n\",\n\t\t\t\t zfcp_scsi_dev_lun(sdev),\n\t\t\t\t (unsigned long long)zfcp_sdev->port->wwpn,\n\t\t\t\t qual->fsf_queue_designator.cssid,\n\t\t\t\t qual->fsf_queue_designator.hla);\n\t\tzfcp_erp_set_lun_status(sdev,\n\t\t\t\t\tZFCP_STATUS_COMMON_ERP_FAILED |\n\t\t\t\t\tZFCP_STATUS_COMMON_ACCESS_DENIED);\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_MAXIMUM_NUMBER_OF_LUNS_EXCEEDED:\n\t\tdev_warn(&adapter->ccw_device->dev,\n\t\t\t \"No handle is available for LUN \"\n\t\t\t \"0x%016Lx on port 0x%016Lx\\n\",\n\t\t\t (unsigned long long)zfcp_scsi_dev_lun(sdev),\n\t\t\t (unsigned long long)zfcp_sdev->port->wwpn);\n\t\tzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_ERP_FAILED);\n\t\tfallthrough;\n\tcase FSF_INVALID_COMMAND_OPTION:\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tswitch (header->fsf_status_qual.word[0]) {\n\t\tcase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\n\t\t\tzfcp_fc_test_link(zfcp_sdev->port);\n\t\t\tfallthrough;\n\t\tcase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase FSF_GOOD:\n\t\tzfcp_sdev->lun_handle = header->lun_handle;\n\t\tatomic_or(ZFCP_STATUS_COMMON_OPEN, &zfcp_sdev->status);\n\t\tbreak;\n\t}\n}\n\n \nint zfcp_fsf_open_lun(struct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_adapter *adapter = erp_action->adapter;\n\tstruct zfcp_qdio *qdio = adapter->qdio;\n\tstruct zfcp_fsf_req *req;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_OPEN_LUN,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->qtcb->header.port_handle = erp_action->port->handle;\n\treq->qtcb->bottom.support.fcp_lun = zfcp_scsi_dev_lun(erp_action->sdev);\n\treq->handler = zfcp_fsf_open_lun_handler;\n\treq->data = erp_action->sdev;\n\treq->erp_action = erp_action;\n\terp_action->fsf_req_id = req->req_id;\n\n\tif (!(adapter->connection_features & FSF_FEATURE_NPIV_MODE))\n\t\treq->qtcb->bottom.support.option = FSF_OPEN_LUN_SUPPRESS_BOXING;\n\n\tzfcp_fsf_start_erp_timer(req);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval) {\n\t\tzfcp_fsf_req_free(req);\n\t\terp_action->fsf_req_id = 0;\n\t}\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_close_lun_handler(struct zfcp_fsf_req *req)\n{\n\tstruct scsi_device *sdev = req->data;\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\treturn;\n\n\tzfcp_sdev = sdev_to_zfcp(sdev);\n\n\tswitch (req->qtcb->header.fsf_status) {\n\tcase FSF_PORT_HANDLE_NOT_VALID:\n\t\tzfcp_erp_adapter_reopen(zfcp_sdev->port->adapter, 0, \"fscuh_1\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_LUN_HANDLE_NOT_VALID:\n\t\tzfcp_erp_port_reopen(zfcp_sdev->port, 0, \"fscuh_2\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_PORT_BOXED:\n\t\tzfcp_erp_set_port_status(zfcp_sdev->port,\n\t\t\t\t\t ZFCP_STATUS_COMMON_ACCESS_BOXED);\n\t\tzfcp_erp_port_reopen(zfcp_sdev->port,\n\t\t\t\t     ZFCP_STATUS_COMMON_ERP_FAILED, \"fscuh_3\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tswitch (req->qtcb->header.fsf_status_qual.word[0]) {\n\t\tcase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\n\t\t\tzfcp_fc_test_link(zfcp_sdev->port);\n\t\t\tfallthrough;\n\t\tcase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\n\t\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FSF_GOOD:\n\t\tatomic_andnot(ZFCP_STATUS_COMMON_OPEN, &zfcp_sdev->status);\n\t\tbreak;\n\t}\n}\n\n \nint zfcp_fsf_close_lun(struct zfcp_erp_action *erp_action)\n{\n\tstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(erp_action->sdev);\n\tstruct zfcp_fsf_req *req;\n\tint retval = -EIO;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_CLOSE_LUN,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_READ,\n\t\t\t\t  qdio->adapter->pool.erp_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\treq->qtcb->header.port_handle = erp_action->port->handle;\n\treq->qtcb->header.lun_handle = zfcp_sdev->lun_handle;\n\treq->handler = zfcp_fsf_close_lun_handler;\n\treq->data = erp_action->sdev;\n\treq->erp_action = erp_action;\n\terp_action->fsf_req_id = req->req_id;\n\n\tzfcp_fsf_start_erp_timer(req);\n\tretval = zfcp_fsf_req_send(req);\n\tif (retval) {\n\t\tzfcp_fsf_req_free(req);\n\t\terp_action->fsf_req_id = 0;\n\t}\n\t \nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_update_lat(struct zfcp_latency_record *lat_rec, u32 lat)\n{\n\tlat_rec->sum += lat;\n\tlat_rec->min = min(lat_rec->min, lat);\n\tlat_rec->max = max(lat_rec->max, lat);\n}\n\nstatic void zfcp_fsf_req_trace(struct zfcp_fsf_req *req, struct scsi_cmnd *scsi)\n{\n\tstruct fsf_qual_latency_info *lat_in;\n\tstruct zfcp_latency_cont *lat = NULL;\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\tstruct zfcp_blk_drv_data blktrc;\n\tint ticks = req->adapter->timer_ticks;\n\n\tlat_in = &req->qtcb->prefix.prot_status_qual.latency_info;\n\n\tblktrc.flags = 0;\n\tblktrc.magic = ZFCP_BLK_DRV_DATA_MAGIC;\n\tif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\n\t\tblktrc.flags |= ZFCP_BLK_REQ_ERROR;\n\tblktrc.inb_usage = 0;\n\tblktrc.outb_usage = req->qdio_req.qdio_outb_usage;\n\n\tif (req->adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA &&\n\t    !(req->status & ZFCP_STATUS_FSFREQ_ERROR)) {\n\t\tzfcp_sdev = sdev_to_zfcp(scsi->device);\n\t\tblktrc.flags |= ZFCP_BLK_LAT_VALID;\n\t\tblktrc.channel_lat = lat_in->channel_lat * ticks;\n\t\tblktrc.fabric_lat = lat_in->fabric_lat * ticks;\n\n\t\tswitch (req->qtcb->bottom.io.data_direction) {\n\t\tcase FSF_DATADIR_DIF_READ_STRIP:\n\t\tcase FSF_DATADIR_DIF_READ_CONVERT:\n\t\tcase FSF_DATADIR_READ:\n\t\t\tlat = &zfcp_sdev->latencies.read;\n\t\t\tbreak;\n\t\tcase FSF_DATADIR_DIF_WRITE_INSERT:\n\t\tcase FSF_DATADIR_DIF_WRITE_CONVERT:\n\t\tcase FSF_DATADIR_WRITE:\n\t\t\tlat = &zfcp_sdev->latencies.write;\n\t\t\tbreak;\n\t\tcase FSF_DATADIR_CMND:\n\t\t\tlat = &zfcp_sdev->latencies.cmd;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (lat) {\n\t\t\tspin_lock(&zfcp_sdev->latencies.lock);\n\t\t\tzfcp_fsf_update_lat(&lat->channel, lat_in->channel_lat);\n\t\t\tzfcp_fsf_update_lat(&lat->fabric, lat_in->fabric_lat);\n\t\t\tlat->counter++;\n\t\t\tspin_unlock(&zfcp_sdev->latencies.lock);\n\t\t}\n\t}\n\n\tblk_add_driver_data(scsi_cmd_to_rq(scsi), &blktrc, sizeof(blktrc));\n}\n\n \nstatic void zfcp_fsf_fcp_handler_common(struct zfcp_fsf_req *req,\n\t\t\t\t\tstruct scsi_device *sdev)\n{\n\tstruct zfcp_scsi_dev *zfcp_sdev;\n\tstruct fsf_qtcb_header *header = &req->qtcb->header;\n\n\tif (unlikely(req->status & ZFCP_STATUS_FSFREQ_ERROR))\n\t\treturn;\n\n\tzfcp_sdev = sdev_to_zfcp(sdev);\n\n\tswitch (header->fsf_status) {\n\tcase FSF_HANDLE_MISMATCH:\n\tcase FSF_PORT_HANDLE_NOT_VALID:\n\t\tzfcp_erp_adapter_reopen(req->adapter, 0, \"fssfch1\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_FCPLUN_NOT_VALID:\n\tcase FSF_LUN_HANDLE_NOT_VALID:\n\t\tzfcp_erp_port_reopen(zfcp_sdev->port, 0, \"fssfch2\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_SERVICE_CLASS_NOT_SUPPORTED:\n\t\tzfcp_fsf_class_not_supp(req);\n\t\tbreak;\n\tcase FSF_DIRECTION_INDICATOR_NOT_VALID:\n\t\tdev_err(&req->adapter->ccw_device->dev,\n\t\t\t\"Incorrect direction %d, LUN 0x%016Lx on port \"\n\t\t\t\"0x%016Lx closed\\n\",\n\t\t\treq->qtcb->bottom.io.data_direction,\n\t\t\t(unsigned long long)zfcp_scsi_dev_lun(sdev),\n\t\t\t(unsigned long long)zfcp_sdev->port->wwpn);\n\t\tzfcp_erp_adapter_shutdown(req->adapter, 0, \"fssfch3\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_CMND_LENGTH_NOT_VALID:\n\t\tdev_err(&req->adapter->ccw_device->dev,\n\t\t\t\"Incorrect FCP_CMND length %d, FCP device closed\\n\",\n\t\t\treq->qtcb->bottom.io.fcp_cmnd_length);\n\t\tzfcp_erp_adapter_shutdown(req->adapter, 0, \"fssfch4\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_PORT_BOXED:\n\t\tzfcp_erp_set_port_status(zfcp_sdev->port,\n\t\t\t\t\t ZFCP_STATUS_COMMON_ACCESS_BOXED);\n\t\tzfcp_erp_port_reopen(zfcp_sdev->port,\n\t\t\t\t     ZFCP_STATUS_COMMON_ERP_FAILED, \"fssfch5\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_LUN_BOXED:\n\t\tzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_ACCESS_BOXED);\n\t\tzfcp_erp_lun_reopen(sdev, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t    \"fssfch6\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_ADAPTER_STATUS_AVAILABLE:\n\t\tif (header->fsf_status_qual.word[0] ==\n\t\t    FSF_SQ_INVOKE_LINK_TEST_PROCEDURE)\n\t\t\tzfcp_fc_test_link(zfcp_sdev->port);\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\tcase FSF_SECURITY_ERROR:\n\t\tzfcp_fsf_log_security_error(&req->adapter->ccw_device->dev,\n\t\t\t\t\t    header->fsf_status_qual.word[0],\n\t\t\t\t\t    zfcp_sdev->port->wwpn);\n\t\tzfcp_erp_port_forced_reopen(zfcp_sdev->port, 0, \"fssfch7\");\n\t\treq->status |= ZFCP_STATUS_FSFREQ_ERROR;\n\t\tbreak;\n\t}\n}\n\nstatic void zfcp_fsf_fcp_cmnd_handler(struct zfcp_fsf_req *req)\n{\n\tstruct scsi_cmnd *scpnt;\n\tstruct fcp_resp_with_ext *fcp_rsp;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&req->adapter->abort_lock, flags);\n\n\tscpnt = req->data;\n\tif (unlikely(!scpnt)) {\n\t\tread_unlock_irqrestore(&req->adapter->abort_lock, flags);\n\t\treturn;\n\t}\n\n\tzfcp_fsf_fcp_handler_common(req, scpnt->device);\n\n\tif (unlikely(req->status & ZFCP_STATUS_FSFREQ_ERROR)) {\n\t\tset_host_byte(scpnt, DID_TRANSPORT_DISRUPTED);\n\t\tgoto skip_fsfstatus;\n\t}\n\n\tswitch (req->qtcb->header.fsf_status) {\n\tcase FSF_INCONSISTENT_PROT_DATA:\n\tcase FSF_INVALID_PROT_PARM:\n\t\tset_host_byte(scpnt, DID_ERROR);\n\t\tgoto skip_fsfstatus;\n\tcase FSF_BLOCK_GUARD_CHECK_FAILURE:\n\t\tzfcp_scsi_dif_sense_error(scpnt, 0x1);\n\t\tgoto skip_fsfstatus;\n\tcase FSF_APP_TAG_CHECK_FAILURE:\n\t\tzfcp_scsi_dif_sense_error(scpnt, 0x2);\n\t\tgoto skip_fsfstatus;\n\tcase FSF_REF_TAG_CHECK_FAILURE:\n\t\tzfcp_scsi_dif_sense_error(scpnt, 0x3);\n\t\tgoto skip_fsfstatus;\n\t}\n\tBUILD_BUG_ON(sizeof(struct fcp_resp_with_ext) > FSF_FCP_RSP_SIZE);\n\tfcp_rsp = &req->qtcb->bottom.io.fcp_rsp.iu;\n\tzfcp_fc_eval_fcp_rsp(fcp_rsp, scpnt);\n\nskip_fsfstatus:\n\tzfcp_fsf_req_trace(req, scpnt);\n\tzfcp_dbf_scsi_result(scpnt, req);\n\n\tscpnt->host_scribble = NULL;\n\tscsi_done(scpnt);\n\t \n\tread_unlock_irqrestore(&req->adapter->abort_lock, flags);\n}\n\nstatic int zfcp_fsf_set_data_dir(struct scsi_cmnd *scsi_cmnd, u32 *data_dir)\n{\n\tswitch (scsi_get_prot_op(scsi_cmnd)) {\n\tcase SCSI_PROT_NORMAL:\n\t\tswitch (scsi_cmnd->sc_data_direction) {\n\t\tcase DMA_NONE:\n\t\t\t*data_dir = FSF_DATADIR_CMND;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\t\t*data_dir = FSF_DATADIR_READ;\n\t\t\tbreak;\n\t\tcase DMA_TO_DEVICE:\n\t\t\t*data_dir = FSF_DATADIR_WRITE;\n\t\t\tbreak;\n\t\tcase DMA_BIDIRECTIONAL:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase SCSI_PROT_READ_STRIP:\n\t\t*data_dir = FSF_DATADIR_DIF_READ_STRIP;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_INSERT:\n\t\t*data_dir = FSF_DATADIR_DIF_WRITE_INSERT;\n\t\tbreak;\n\tcase SCSI_PROT_READ_PASS:\n\t\t*data_dir = FSF_DATADIR_DIF_READ_CONVERT;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_PASS:\n\t\t*data_dir = FSF_DATADIR_DIF_WRITE_CONVERT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint zfcp_fsf_fcp_cmnd(struct scsi_cmnd *scsi_cmnd)\n{\n\tstruct zfcp_fsf_req *req;\n\tstruct fcp_cmnd *fcp_cmnd;\n\tu8 sbtype = SBAL_SFLAGS0_TYPE_READ;\n\tint retval = -EIO;\n\tstruct scsi_device *sdev = scsi_cmnd->device;\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\tstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\n\tstruct zfcp_qdio *qdio = adapter->qdio;\n\tstruct fsf_qtcb_bottom_io *io;\n\tunsigned long flags;\n\n\tif (unlikely(!(atomic_read(&zfcp_sdev->status) &\n\t\t       ZFCP_STATUS_COMMON_UNBLOCKED)))\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&qdio->req_q_lock, flags);\n\tif (atomic_read(&qdio->req_q_free) <= 0) {\n\t\tatomic_inc(&qdio->req_q_full);\n\t\tgoto out;\n\t}\n\n\tif (scsi_cmnd->sc_data_direction == DMA_TO_DEVICE)\n\t\tsbtype = SBAL_SFLAGS0_TYPE_WRITE;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_FCP_CMND,\n\t\t\t\t  sbtype, adapter->pool.scsi_req);\n\n\tif (IS_ERR(req)) {\n\t\tretval = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tBUILD_BUG_ON(sizeof(scsi_cmnd->host_scribble) < sizeof(req->req_id));\n\tscsi_cmnd->host_scribble = (unsigned char *) req->req_id;\n\n\tio = &req->qtcb->bottom.io;\n\treq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\n\treq->data = scsi_cmnd;\n\treq->handler = zfcp_fsf_fcp_cmnd_handler;\n\treq->qtcb->header.lun_handle = zfcp_sdev->lun_handle;\n\treq->qtcb->header.port_handle = zfcp_sdev->port->handle;\n\tio->service_class = FSF_CLASS_3;\n\tio->fcp_cmnd_length = FCP_CMND_LEN;\n\n\tif (scsi_get_prot_op(scsi_cmnd) != SCSI_PROT_NORMAL) {\n\t\tio->data_block_length = scsi_prot_interval(scsi_cmnd);\n\t\tio->ref_tag_value = scsi_prot_ref_tag(scsi_cmnd);\n\t}\n\n\tif (zfcp_fsf_set_data_dir(scsi_cmnd, &io->data_direction))\n\t\tgoto failed_scsi_cmnd;\n\n\tBUILD_BUG_ON(sizeof(struct fcp_cmnd) > FSF_FCP_CMND_SIZE);\n\tfcp_cmnd = &req->qtcb->bottom.io.fcp_cmnd.iu;\n\tzfcp_fc_scsi_to_fcp(fcp_cmnd, scsi_cmnd);\n\n\tif ((scsi_get_prot_op(scsi_cmnd) != SCSI_PROT_NORMAL) &&\n\t    scsi_prot_sg_count(scsi_cmnd)) {\n\t\tzfcp_qdio_set_data_div(qdio, &req->qdio_req,\n\t\t\t\t       scsi_prot_sg_count(scsi_cmnd));\n\t\tretval = zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req,\n\t\t\t\t\t\t scsi_prot_sglist(scsi_cmnd));\n\t\tif (retval)\n\t\t\tgoto failed_scsi_cmnd;\n\t\tio->prot_data_length = zfcp_qdio_real_bytes(\n\t\t\t\t\t\tscsi_prot_sglist(scsi_cmnd));\n\t}\n\n\tretval = zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req,\n\t\t\t\t\t scsi_sglist(scsi_cmnd));\n\tif (unlikely(retval))\n\t\tgoto failed_scsi_cmnd;\n\n\tzfcp_qdio_set_sbale_last(adapter->qdio, &req->qdio_req);\n\tif (zfcp_adapter_multi_buffer_active(adapter))\n\t\tzfcp_qdio_set_scount(qdio, &req->qdio_req);\n\n\tretval = zfcp_fsf_req_send(req);\n\tif (unlikely(retval))\n\t\tgoto failed_scsi_cmnd;\n\t \n\n\tgoto out;\n\nfailed_scsi_cmnd:\n\tzfcp_fsf_req_free(req);\n\tscsi_cmnd->host_scribble = NULL;\nout:\n\tspin_unlock_irqrestore(&qdio->req_q_lock, flags);\n\treturn retval;\n}\n\nstatic void zfcp_fsf_fcp_task_mgmt_handler(struct zfcp_fsf_req *req)\n{\n\tstruct scsi_device *sdev = req->data;\n\tstruct fcp_resp_with_ext *fcp_rsp;\n\tstruct fcp_resp_rsp_info *rsp_info;\n\n\tzfcp_fsf_fcp_handler_common(req, sdev);\n\n\tfcp_rsp = &req->qtcb->bottom.io.fcp_rsp.iu;\n\trsp_info = (struct fcp_resp_rsp_info *) &fcp_rsp[1];\n\n\tif ((rsp_info->rsp_code != FCP_TMF_CMPL) ||\n\t     (req->status & ZFCP_STATUS_FSFREQ_ERROR))\n\t\treq->status |= ZFCP_STATUS_FSFREQ_TMFUNCFAILED;\n}\n\n \nstruct zfcp_fsf_req *zfcp_fsf_fcp_task_mgmt(struct scsi_device *sdev,\n\t\t\t\t\t    u8 tm_flags)\n{\n\tstruct zfcp_fsf_req *req = NULL;\n\tstruct fcp_cmnd *fcp_cmnd;\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\n\tstruct zfcp_qdio *qdio = zfcp_sdev->port->adapter->qdio;\n\n\tif (unlikely(!(atomic_read(&zfcp_sdev->status) &\n\t\t       ZFCP_STATUS_COMMON_UNBLOCKED)))\n\t\treturn NULL;\n\n\tspin_lock_irq(&qdio->req_q_lock);\n\tif (zfcp_qdio_sbal_get(qdio))\n\t\tgoto out;\n\n\treq = zfcp_fsf_req_create(qdio, FSF_QTCB_FCP_CMND,\n\t\t\t\t  SBAL_SFLAGS0_TYPE_WRITE,\n\t\t\t\t  qdio->adapter->pool.scsi_req);\n\n\tif (IS_ERR(req)) {\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\n\treq->data = sdev;\n\n\treq->handler = zfcp_fsf_fcp_task_mgmt_handler;\n\treq->qtcb->header.lun_handle = zfcp_sdev->lun_handle;\n\treq->qtcb->header.port_handle = zfcp_sdev->port->handle;\n\treq->qtcb->bottom.io.data_direction = FSF_DATADIR_CMND;\n\treq->qtcb->bottom.io.service_class = FSF_CLASS_3;\n\treq->qtcb->bottom.io.fcp_cmnd_length = FCP_CMND_LEN;\n\n\tzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\n\n\tfcp_cmnd = &req->qtcb->bottom.io.fcp_cmnd.iu;\n\tzfcp_fc_fcp_tm(fcp_cmnd, sdev, tm_flags);\n\n\tzfcp_fsf_start_timer(req, ZFCP_FSF_SCSI_ER_TIMEOUT);\n\tif (!zfcp_fsf_req_send(req)) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tzfcp_fsf_req_free(req);\n\treq = NULL;\nout:\n\tspin_unlock_irq(&qdio->req_q_lock);\n\treturn req;\n}\n\n \nvoid zfcp_fsf_reqid_check(struct zfcp_qdio *qdio, int sbal_idx)\n{\n\tstruct zfcp_adapter *adapter = qdio->adapter;\n\tstruct qdio_buffer *sbal = qdio->res_q[sbal_idx];\n\tstruct qdio_buffer_element *sbale;\n\tstruct zfcp_fsf_req *fsf_req;\n\tu64 req_id;\n\tint idx;\n\n\tfor (idx = 0; idx < QDIO_MAX_ELEMENTS_PER_BUFFER; idx++) {\n\n\t\tsbale = &sbal->element[idx];\n\t\treq_id = sbale->addr;\n\t\tfsf_req = zfcp_reqlist_find_rm(adapter->req_list, req_id);\n\n\t\tif (!fsf_req) {\n\t\t\t \n\t\t\tzfcp_qdio_siosl(adapter);\n\t\t\tpanic(\"error: unknown req_id (%llx) on adapter %s.\\n\",\n\t\t\t      req_id, dev_name(&adapter->ccw_device->dev));\n\t\t}\n\n\t\tzfcp_fsf_req_complete(fsf_req);\n\n\t\tif (likely(sbale->eflags & SBAL_EFLAGS_LAST_ENTRY))\n\t\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}