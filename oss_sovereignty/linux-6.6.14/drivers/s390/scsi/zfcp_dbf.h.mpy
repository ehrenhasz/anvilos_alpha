{
  "module_name": "zfcp_dbf.h",
  "hash_id": "d7eead349fd4bb72a256c01cdcdb4758039ac6253064217971acc735154b5132",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_dbf.h",
  "human_readable_source": " \n \n\n#ifndef ZFCP_DBF_H\n#define ZFCP_DBF_H\n\n#include <scsi/fc/fc_fcp.h>\n#include \"zfcp_ext.h\"\n#include \"zfcp_fsf.h\"\n#include \"zfcp_def.h\"\n\n#define ZFCP_DBF_TAG_LEN       7\n\n#define ZFCP_DBF_INVALID_WWPN\t0x0000000000000000ull\n#define ZFCP_DBF_INVALID_LUN\t0xFFFFFFFFFFFFFFFFull\n\nenum zfcp_dbf_pseudo_erp_act_type {\n\tZFCP_PSEUDO_ERP_ACTION_RPORT_ADD = 0xff,\n\tZFCP_PSEUDO_ERP_ACTION_RPORT_DEL = 0xfe,\n};\n\n \nstruct zfcp_dbf_rec_trigger {\n\tu32 ready;\n\tu32 running;\n\tu8 want;\n\tu8 need;\n} __packed;\n\n \nstruct zfcp_dbf_rec_running {\n\tu64 fsf_req_id;\n\tu32 rec_status;\n\tu16 rec_step;\n\tu8 rec_action;\n\tu8 rec_count;\n} __packed;\n\n \nenum zfcp_dbf_rec_id {\n\tZFCP_DBF_REC_TRIG\t= 1,\n\tZFCP_DBF_REC_RUN\t= 2,\n};\n\n \nstruct zfcp_dbf_rec {\n\tu8 id;\n\tchar tag[ZFCP_DBF_TAG_LEN];\n\tu64 lun;\n\tu64 wwpn;\n\tu32 d_id;\n\tu32 adapter_status;\n\tu32 port_status;\n\tu32 lun_status;\n\tunion {\n\t\tstruct zfcp_dbf_rec_trigger trig;\n\t\tstruct zfcp_dbf_rec_running run;\n\t} u;\n} __packed;\n\n \nenum zfcp_dbf_san_id {\n\tZFCP_DBF_SAN_REQ\t= 1,\n\tZFCP_DBF_SAN_RES\t= 2,\n\tZFCP_DBF_SAN_ELS\t= 3,\n};\n\n \nstruct zfcp_dbf_san {\n\tu8 id;\n\tchar tag[ZFCP_DBF_TAG_LEN];\n\tu64 fsf_req_id;\n\tu32 d_id;\n#define ZFCP_DBF_SAN_MAX_PAYLOAD (FC_CT_HDR_LEN + 32)\n\tchar payload[ZFCP_DBF_SAN_MAX_PAYLOAD];\n\tu16 pl_len;\n} __packed;\n\n \nstruct zfcp_dbf_hba_res {\n\tu64 req_issued;\n\tu32 prot_status;\n\tu8  prot_status_qual[FSF_PROT_STATUS_QUAL_SIZE];\n\tu32 fsf_status;\n\tu8  fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];\n\tu32 port_handle;\n\tu32 lun_handle;\n} __packed;\n\n \nstruct zfcp_dbf_hba_uss {\n\tu32 status_type;\n\tu32 status_subtype;\n\tu32 d_id;\n\tu64 lun;\n\tu64 queue_designator;\n} __packed;\n\n \nstruct zfcp_dbf_hba_fces {\n\tu64 req_issued;\n\tu32 fsf_status;\n\tu32 port_handle;\n\tu64 wwpn;\n\tu32 fc_security_old;\n\tu32 fc_security_new;\n} __packed;\n\n \nenum zfcp_dbf_hba_id {\n\tZFCP_DBF_HBA_RES\t= 1,\n\tZFCP_DBF_HBA_USS\t= 2,\n\tZFCP_DBF_HBA_BIT\t= 3,\n\tZFCP_DBF_HBA_BASIC\t= 4,\n\tZFCP_DBF_HBA_FCES\t= 5,\n};\n\n \nstruct zfcp_dbf_hba {\n\tu8 id;\n\tchar tag[ZFCP_DBF_TAG_LEN];\n\tu64 fsf_req_id;\n\tu32 fsf_req_status;\n\tu32 fsf_cmd;\n\tu32 fsf_seq_no;\n\tu16 pl_len;\n\tunion {\n\t\tstruct zfcp_dbf_hba_res res;\n\t\tstruct zfcp_dbf_hba_uss uss;\n\t\tstruct fsf_bit_error_payload be;\n\t\tstruct zfcp_dbf_hba_fces fces;\n\t} u;\n} __packed;\n\n \nenum zfcp_dbf_scsi_id {\n\tZFCP_DBF_SCSI_CMND\t= 1,\n};\n\n \nstruct zfcp_dbf_scsi {\n\tu8 id;\n\tchar tag[ZFCP_DBF_TAG_LEN];\n\tu32 scsi_id;\n\tu32 scsi_lun;\n\tu32 scsi_result;\n\tu8 scsi_retries;\n\tu8 scsi_allowed;\n\tu8 fcp_rsp_info;\n#define ZFCP_DBF_SCSI_OPCODE\t16\n\tu8 scsi_opcode[ZFCP_DBF_SCSI_OPCODE];\n\tu64 fsf_req_id;\n\tu64 host_scribble;\n\tu16 pl_len;\n\tstruct fcp_resp_with_ext fcp_rsp;\n\tu32 scsi_lun_64_hi;\n} __packed;\n\n \nstruct zfcp_dbf_pay {\n\tu8 counter;\n\tchar area[ZFCP_DBF_TAG_LEN];\n\tu64 fsf_req_id;\n#define ZFCP_DBF_PAY_MAX_REC 0x100\n\tchar data[ZFCP_DBF_PAY_MAX_REC];\n} __packed;\n\n \nstruct zfcp_dbf {\n\tdebug_info_t\t\t\t*pay;\n\tdebug_info_t\t\t\t*rec;\n\tdebug_info_t\t\t\t*hba;\n\tdebug_info_t\t\t\t*san;\n\tdebug_info_t\t\t\t*scsi;\n\tspinlock_t\t\t\tpay_lock;\n\tspinlock_t\t\t\trec_lock;\n\tspinlock_t\t\t\thba_lock;\n\tspinlock_t\t\t\tsan_lock;\n\tspinlock_t\t\t\tscsi_lock;\n\tstruct zfcp_dbf_pay\t\tpay_buf;\n\tstruct zfcp_dbf_rec\t\trec_buf;\n\tstruct zfcp_dbf_hba\t\thba_buf;\n\tstruct zfcp_dbf_san\t\tsan_buf;\n\tstruct zfcp_dbf_scsi\t\tscsi_buf;\n};\n\n \nstatic inline\nbool zfcp_dbf_hba_fsf_resp_suppress(struct zfcp_fsf_req *req)\n{\n\tstruct fsf_qtcb *qtcb = req->qtcb;\n\tu32 fsf_stat = qtcb->header.fsf_status;\n\tstruct fcp_resp *fcp_rsp;\n\tu8 rsp_flags, fr_status;\n\n\tif (qtcb->prefix.qtcb_type != FSF_IO_COMMAND)\n\t\treturn false;  \n\tfcp_rsp = &qtcb->bottom.io.fcp_rsp.iu.resp;\n\trsp_flags = fcp_rsp->fr_flags;\n\tfr_status = fcp_rsp->fr_status;\n\treturn (fsf_stat == FSF_FCP_RSP_AVAILABLE) &&\n\t\t(rsp_flags == FCP_RESID_UNDER) &&\n\t\t(fr_status == SAM_STAT_GOOD);\n}\n\nstatic inline\nvoid zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)\n{\n\tif (debug_level_enabled(req->adapter->dbf->hba, level))\n\t\tzfcp_dbf_hba_fsf_res(tag, level, req);\n}\n\n \nstatic inline\nvoid zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)\n{\n\tstruct fsf_qtcb *qtcb = req->qtcb;\n\n\tif (unlikely(req->status & (ZFCP_STATUS_FSFREQ_DISMISSED |\n\t\t\t\t    ZFCP_STATUS_FSFREQ_ERROR))) {\n\t\tzfcp_dbf_hba_fsf_resp(\"fs_rerr\", 3, req);\n\n\t} else if ((qtcb->prefix.prot_status != FSF_PROT_GOOD) &&\n\t    (qtcb->prefix.prot_status != FSF_PROT_FSF_STATUS_PRESENTED)) {\n\t\tzfcp_dbf_hba_fsf_resp(\"fs_perr\", 1, req);\n\n\t} else if (qtcb->header.fsf_status != FSF_GOOD) {\n\t\tzfcp_dbf_hba_fsf_resp(\"fs_ferr\",\n\t\t\t\t      zfcp_dbf_hba_fsf_resp_suppress(req)\n\t\t\t\t      ? 5 : 1, req);\n\n\t} else if ((qtcb->header.fsf_command == FSF_QTCB_OPEN_PORT_WITH_DID) ||\n\t\t   (qtcb->header.fsf_command == FSF_QTCB_OPEN_LUN)) {\n\t\tzfcp_dbf_hba_fsf_resp(\"fs_open\", 4, req);\n\n\t} else if (qtcb->header.log_length) {\n\t\tzfcp_dbf_hba_fsf_resp(\"fs_qtcb\", 5, req);\n\n\t} else {\n\t\tzfcp_dbf_hba_fsf_resp(\"fs_norm\", 6, req);\n\t}\n}\n\nstatic inline\nvoid _zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *scmd,\n\t\t   struct zfcp_fsf_req *req)\n{\n\tstruct zfcp_adapter *adapter = (struct zfcp_adapter *)\n\t\t\t\t\tscmd->device->host->hostdata[0];\n\n\tif (debug_level_enabled(adapter->dbf->scsi, level))\n\t\tzfcp_dbf_scsi_common(tag, level, scmd->device, scmd, req);\n}\n\n \nstatic inline\nvoid zfcp_dbf_scsi_result(struct scsi_cmnd *scmd, struct zfcp_fsf_req *req)\n{\n\tif (scmd->result != 0)\n\t\t_zfcp_dbf_scsi(\"rsl_err\", 3, scmd, req);\n\telse if (scmd->retries > 0)\n\t\t_zfcp_dbf_scsi(\"rsl_ret\", 4, scmd, req);\n\telse\n\t\t_zfcp_dbf_scsi(\"rsl_nor\", 6, scmd, req);\n}\n\n \nstatic inline\nvoid zfcp_dbf_scsi_fail_send(struct scsi_cmnd *scmd)\n{\n\t_zfcp_dbf_scsi(\"rsl_fai\", 4, scmd, NULL);\n}\n\n \nstatic inline\nvoid zfcp_dbf_scsi_abort(char *tag, struct scsi_cmnd *scmd,\n\t\t\t struct zfcp_fsf_req *fsf_req)\n{\n\t_zfcp_dbf_scsi(tag, 1, scmd, fsf_req);\n}\n\n \nstatic inline\nvoid zfcp_dbf_scsi_devreset(char *tag, struct scsi_device *sdev, u8 flag,\n\t\t\t    struct zfcp_fsf_req *fsf_req)\n{\n\tstruct zfcp_adapter *adapter = (struct zfcp_adapter *)\n\t\t\t\t\tsdev->host->hostdata[0];\n\tchar tmp_tag[ZFCP_DBF_TAG_LEN];\n\tstatic int const level = 1;\n\n\tif (unlikely(!debug_level_enabled(adapter->dbf->scsi, level)))\n\t\treturn;\n\n\tif (flag == FCP_TMF_TGT_RESET)\n\t\tmemcpy(tmp_tag, \"tr_\", 3);\n\telse\n\t\tmemcpy(tmp_tag, \"lr_\", 3);\n\n\tmemcpy(&tmp_tag[3], tag, 4);\n\tzfcp_dbf_scsi_common(tmp_tag, level, sdev, NULL, fsf_req);\n}\n\n \nstatic inline void zfcp_dbf_scsi_nullcmnd(struct scsi_cmnd *scmnd,\n\t\t\t\t\t  struct zfcp_fsf_req *fsf_req)\n{\n\t_zfcp_dbf_scsi(\"scfc__1\", 3, scmnd, fsf_req);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}