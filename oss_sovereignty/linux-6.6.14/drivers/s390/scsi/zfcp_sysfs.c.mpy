{
  "module_name": "zfcp_sysfs.c",
  "hash_id": "5fec3250a2ff93f28537d8dcaebde354c42e2afbb03371f9923b421f96eb818e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_sysfs.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/slab.h>\n#include \"zfcp_diag.h\"\n#include \"zfcp_ext.h\"\n\n#define ZFCP_DEV_ATTR(_feat, _name, _mode, _show, _store) \\\nstruct device_attribute dev_attr_##_feat##_##_name = __ATTR(_name, _mode,\\\n\t\t\t\t\t\t\t    _show, _store)\n#define ZFCP_DEFINE_ATTR(_feat_def, _feat, _name, _format, _value)\t       \\\nstatic ssize_t zfcp_sysfs_##_feat##_##_name##_show(struct device *dev,\t       \\\n\t\t\t\t\t\t   struct device_attribute *at,\\\n\t\t\t\t\t\t   char *buf)\t\t       \\\n{\t\t\t\t\t\t\t\t\t       \\\n\tstruct _feat_def *_feat = container_of(dev, struct _feat_def, dev);    \\\n\t\t\t\t\t\t\t\t\t       \\\n\treturn sprintf(buf, _format, _value);\t\t\t\t       \\\n}\t\t\t\t\t\t\t\t\t       \\\nstatic ZFCP_DEV_ATTR(_feat, _name, S_IRUGO,\t\t\t\t       \\\n\t\t     zfcp_sysfs_##_feat##_##_name##_show, NULL);\n\n#define ZFCP_DEFINE_ATTR_CONST(_feat, _name, _format, _value)\t\t       \\\nstatic ssize_t zfcp_sysfs_##_feat##_##_name##_show(struct device *dev,\t       \\\n\t\t\t\t\t\t   struct device_attribute *at,\\\n\t\t\t\t\t\t   char *buf)\t\t       \\\n{\t\t\t\t\t\t\t\t\t       \\\n\treturn sprintf(buf, _format, _value);\t\t\t\t       \\\n}\t\t\t\t\t\t\t\t\t       \\\nstatic ZFCP_DEV_ATTR(_feat, _name, S_IRUGO,\t\t\t\t       \\\n\t\t     zfcp_sysfs_##_feat##_##_name##_show, NULL);\n\n#define ZFCP_DEFINE_A_ATTR(_name, _format, _value)\t\t\t     \\\nstatic ssize_t zfcp_sysfs_adapter_##_name##_show(struct device *dev,\t     \\\n\t\t\t\t\t\t struct device_attribute *at,\\\n\t\t\t\t\t\t char *buf)\t\t     \\\n{\t\t\t\t\t\t\t\t\t     \\\n\tstruct ccw_device *cdev = to_ccwdev(dev);\t\t\t     \\\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\t     \\\n\tint i;\t\t\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tif (!adapter)\t\t\t\t\t\t\t     \\\n\t\treturn -ENODEV;\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\ti = sprintf(buf, _format, _value);\t\t\t\t     \\\n\tzfcp_ccw_adapter_put(adapter);\t\t\t\t\t     \\\n\treturn i;\t\t\t\t\t\t\t     \\\n}\t\t\t\t\t\t\t\t\t     \\\nstatic ZFCP_DEV_ATTR(adapter, _name, S_IRUGO,\t\t\t\t     \\\n\t\t     zfcp_sysfs_adapter_##_name##_show, NULL);\n\nZFCP_DEFINE_A_ATTR(status, \"0x%08x\\n\", atomic_read(&adapter->status));\nZFCP_DEFINE_A_ATTR(peer_wwnn, \"0x%016llx\\n\",\n\t\t   (unsigned long long) adapter->peer_wwnn);\nZFCP_DEFINE_A_ATTR(peer_wwpn, \"0x%016llx\\n\",\n\t\t   (unsigned long long) adapter->peer_wwpn);\nZFCP_DEFINE_A_ATTR(peer_d_id, \"0x%06x\\n\", adapter->peer_d_id);\nZFCP_DEFINE_A_ATTR(card_version, \"0x%04x\\n\", adapter->hydra_version);\nZFCP_DEFINE_A_ATTR(lic_version, \"0x%08x\\n\", adapter->fsf_lic_version);\nZFCP_DEFINE_A_ATTR(hardware_version, \"0x%08x\\n\", adapter->hardware_version);\nZFCP_DEFINE_A_ATTR(in_recovery, \"%d\\n\", (atomic_read(&adapter->status) &\n\t\t\t\t\t ZFCP_STATUS_COMMON_ERP_INUSE) != 0);\n\nZFCP_DEFINE_ATTR(zfcp_port, port, status, \"0x%08x\\n\",\n\t\t atomic_read(&port->status));\nZFCP_DEFINE_ATTR(zfcp_port, port, in_recovery, \"%d\\n\",\n\t\t (atomic_read(&port->status) &\n\t\t  ZFCP_STATUS_COMMON_ERP_INUSE) != 0);\nZFCP_DEFINE_ATTR_CONST(port, access_denied, \"%d\\n\", 0);\n\nZFCP_DEFINE_ATTR(zfcp_unit, unit, status, \"0x%08x\\n\",\n\t\t zfcp_unit_sdev_status(unit));\nZFCP_DEFINE_ATTR(zfcp_unit, unit, in_recovery, \"%d\\n\",\n\t\t (zfcp_unit_sdev_status(unit) &\n\t\t  ZFCP_STATUS_COMMON_ERP_INUSE) != 0);\nZFCP_DEFINE_ATTR(zfcp_unit, unit, access_denied, \"%d\\n\",\n\t\t (zfcp_unit_sdev_status(unit) &\n\t\t  ZFCP_STATUS_COMMON_ACCESS_DENIED) != 0);\nZFCP_DEFINE_ATTR_CONST(unit, access_shared, \"%d\\n\", 0);\nZFCP_DEFINE_ATTR_CONST(unit, access_readonly, \"%d\\n\", 0);\n\nstatic ssize_t zfcp_sysfs_port_failed_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\n\n\tif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\n\t\treturn sprintf(buf, \"1\\n\");\n\n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t zfcp_sysfs_port_failed_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) || val != 0)\n\t\treturn -EINVAL;\n\n\tzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_RUNNING);\n\tzfcp_erp_port_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED, \"sypfai2\");\n\tzfcp_erp_wait(port->adapter);\n\n\treturn count;\n}\nstatic ZFCP_DEV_ATTR(port, failed, S_IWUSR | S_IRUGO,\n\t\t     zfcp_sysfs_port_failed_show,\n\t\t     zfcp_sysfs_port_failed_store);\n\nstatic ssize_t zfcp_sysfs_unit_failed_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct zfcp_unit *unit = container_of(dev, struct zfcp_unit, dev);\n\tstruct scsi_device *sdev;\n\tunsigned int status, failed = 1;\n\n\tsdev = zfcp_unit_sdev(unit);\n\tif (sdev) {\n\t\tstatus = atomic_read(&sdev_to_zfcp(sdev)->status);\n\t\tfailed = status & ZFCP_STATUS_COMMON_ERP_FAILED ? 1 : 0;\n\t\tscsi_device_put(sdev);\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", failed);\n}\n\nstatic ssize_t zfcp_sysfs_unit_failed_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct zfcp_unit *unit = container_of(dev, struct zfcp_unit, dev);\n\tunsigned long val;\n\tstruct scsi_device *sdev;\n\n\tif (kstrtoul(buf, 0, &val) || val != 0)\n\t\treturn -EINVAL;\n\n\tsdev = zfcp_unit_sdev(unit);\n\tif (sdev) {\n\t\tzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_RUNNING);\n\t\tzfcp_erp_lun_reopen(sdev, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t    \"syufai2\");\n\t\tzfcp_erp_wait(unit->port->adapter);\n\t} else\n\t\tzfcp_unit_scsi_scan(unit);\n\n\treturn count;\n}\nstatic ZFCP_DEV_ATTR(unit, failed, S_IWUSR | S_IRUGO,\n\t\t     zfcp_sysfs_unit_failed_show,\n\t\t     zfcp_sysfs_unit_failed_store);\n\nstatic ssize_t zfcp_sysfs_adapter_failed_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\tint i;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\tif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\n\t\ti = sprintf(buf, \"1\\n\");\n\telse\n\t\ti = sprintf(buf, \"0\\n\");\n\n\tzfcp_ccw_adapter_put(adapter);\n\treturn i;\n}\n\nstatic ssize_t zfcp_sysfs_adapter_failed_store(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\tunsigned long val;\n\tint retval = 0;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\tif (kstrtoul(buf, 0, &val) || val != 0) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tzfcp_erp_adapter_reset_sync(adapter, \"syafai2\");\nout:\n\tzfcp_ccw_adapter_put(adapter);\n\treturn retval ? retval : (ssize_t) count;\n}\nstatic ZFCP_DEV_ATTR(adapter, failed, S_IWUSR | S_IRUGO,\n\t\t     zfcp_sysfs_adapter_failed_show,\n\t\t     zfcp_sysfs_adapter_failed_store);\n\nstatic ssize_t zfcp_sysfs_port_rescan_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\tint retval = 0;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\t \n\tif (adapter->scsi_host == NULL) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tqueue_delayed_work(adapter->work_queue, &adapter->scan_work, 0);\n\tflush_delayed_work(&adapter->scan_work);\nout:\n\tzfcp_ccw_adapter_put(adapter);\n\treturn retval ? retval : (ssize_t) count;\n}\nstatic ZFCP_DEV_ATTR(adapter, port_rescan, S_IWUSR, NULL,\n\t\t     zfcp_sysfs_port_rescan_store);\n\nDEFINE_MUTEX(zfcp_sysfs_port_units_mutex);\n\nstatic void zfcp_sysfs_port_set_removing(struct zfcp_port *const port)\n{\n\tlockdep_assert_held(&zfcp_sysfs_port_units_mutex);\n\tatomic_set(&port->units, -1);\n}\n\nbool zfcp_sysfs_port_is_removing(const struct zfcp_port *const port)\n{\n\tlockdep_assert_held(&zfcp_sysfs_port_units_mutex);\n\treturn atomic_read(&port->units) == -1;\n}\n\nstatic bool zfcp_sysfs_port_in_use(struct zfcp_port *const port)\n{\n\tstruct zfcp_adapter *const adapter = port->adapter;\n\tunsigned long flags;\n\tstruct scsi_device *sdev;\n\tbool in_use = true;\n\n\tmutex_lock(&zfcp_sysfs_port_units_mutex);\n\tif (atomic_read(&port->units) > 0)\n\t\tgoto unlock_port_units_mutex;  \n\n\tspin_lock_irqsave(adapter->scsi_host->host_lock, flags);\n\t__shost_for_each_device(sdev, adapter->scsi_host) {\n\t\tconst struct zfcp_scsi_dev *zsdev = sdev_to_zfcp(sdev);\n\n\t\tif (sdev->sdev_state == SDEV_DEL ||\n\t\t    sdev->sdev_state == SDEV_CANCEL)\n\t\t\tcontinue;\n\t\tif (zsdev->port != port)\n\t\t\tcontinue;\n\t\t \n\t\tgoto unlock_host_lock;\n\t}\n\n\t \n\tzfcp_sysfs_port_set_removing(port);\n\tin_use = false;\n\nunlock_host_lock:\n\tspin_unlock_irqrestore(adapter->scsi_host->host_lock, flags);\nunlock_port_units_mutex:\n\tmutex_unlock(&zfcp_sysfs_port_units_mutex);\n\treturn in_use;\n}\n\nstatic ssize_t zfcp_sysfs_port_remove_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\tstruct zfcp_port *port;\n\tu64 wwpn;\n\tint retval = -EINVAL;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\tif (kstrtoull(buf, 0, (unsigned long long *) &wwpn))\n\t\tgoto out;\n\n\tport = zfcp_get_port_by_wwpn(adapter, wwpn);\n\tif (!port)\n\t\tgoto out;\n\telse\n\t\tretval = 0;\n\n\tif (zfcp_sysfs_port_in_use(port)) {\n\t\tretval = -EBUSY;\n\t\tput_device(&port->dev);  \n\t\tgoto out;\n\t}\n\n\twrite_lock_irq(&adapter->port_list_lock);\n\tlist_del(&port->list);\n\twrite_unlock_irq(&adapter->port_list_lock);\n\n\tzfcp_erp_port_shutdown(port, 0, \"syprs_1\");\n\tdevice_unregister(&port->dev);\n\n\tput_device(&port->dev);  \n out:\n\tzfcp_ccw_adapter_put(adapter);\n\treturn retval ? retval : (ssize_t) count;\n}\nstatic ZFCP_DEV_ATTR(adapter, port_remove, S_IWUSR, NULL,\n\t\t     zfcp_sysfs_port_remove_store);\n\nstatic ssize_t\nzfcp_sysfs_adapter_diag_max_age_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));\n\tssize_t rc;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\t \n\trc = scnprintf(buf, 20 + 2, \"%lu\\n\", adapter->diagnostics->max_age);\n\n\tzfcp_ccw_adapter_put(adapter);\n\treturn rc;\n}\n\nstatic ssize_t\nzfcp_sysfs_adapter_diag_max_age_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));\n\tunsigned long max_age;\n\tssize_t rc;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\trc = kstrtoul(buf, 10, &max_age);\n\tif (rc != 0)\n\t\tgoto out;\n\n\tadapter->diagnostics->max_age = max_age;\n\n\trc = count;\nout:\n\tzfcp_ccw_adapter_put(adapter);\n\treturn rc;\n}\nstatic ZFCP_DEV_ATTR(adapter, diag_max_age, 0644,\n\t\t     zfcp_sysfs_adapter_diag_max_age_show,\n\t\t     zfcp_sysfs_adapter_diag_max_age_store);\n\nstatic ssize_t zfcp_sysfs_adapter_fc_security_show(\n\tstruct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ccw_device *cdev = to_ccwdev(dev);\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\n\tunsigned int status;\n\tint i;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\t \n\tstatus = atomic_read(&adapter->status);\n\tif (0 == (status & ZFCP_STATUS_COMMON_OPEN))\n\t\ti = sprintf(buf, \"unknown\\n\");\n\telse if (!(adapter->adapter_features & FSF_FEATURE_FC_SECURITY))\n\t\ti = sprintf(buf, \"unsupported\\n\");\n\telse {\n\t\ti = zfcp_fsf_scnprint_fc_security(\n\t\t\tbuf, PAGE_SIZE - 1, adapter->fc_security_algorithms,\n\t\t\tZFCP_FSF_PRINT_FMT_LIST);\n\t\ti += scnprintf(buf + i, PAGE_SIZE - i, \"\\n\");\n\t}\n\n\tzfcp_ccw_adapter_put(adapter);\n\treturn i;\n}\nstatic ZFCP_DEV_ATTR(adapter, fc_security, S_IRUGO,\n\t\t     zfcp_sysfs_adapter_fc_security_show,\n\t\t     NULL);\n\nstatic struct attribute *zfcp_adapter_attrs[] = {\n\t&dev_attr_adapter_failed.attr,\n\t&dev_attr_adapter_in_recovery.attr,\n\t&dev_attr_adapter_port_remove.attr,\n\t&dev_attr_adapter_port_rescan.attr,\n\t&dev_attr_adapter_peer_wwnn.attr,\n\t&dev_attr_adapter_peer_wwpn.attr,\n\t&dev_attr_adapter_peer_d_id.attr,\n\t&dev_attr_adapter_card_version.attr,\n\t&dev_attr_adapter_lic_version.attr,\n\t&dev_attr_adapter_status.attr,\n\t&dev_attr_adapter_hardware_version.attr,\n\t&dev_attr_adapter_diag_max_age.attr,\n\t&dev_attr_adapter_fc_security.attr,\n\tNULL\n};\n\nstatic const struct attribute_group zfcp_sysfs_adapter_attr_group = {\n\t.attrs = zfcp_adapter_attrs,\n};\n\nstatic ssize_t zfcp_sysfs_unit_add_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\n\tu64 fcp_lun;\n\tint retval;\n\n\tif (kstrtoull(buf, 0, (unsigned long long *) &fcp_lun))\n\t\treturn -EINVAL;\n\n\tretval = zfcp_unit_add(port, fcp_lun);\n\tif (retval)\n\t\treturn retval;\n\n\treturn count;\n}\nstatic DEVICE_ATTR(unit_add, S_IWUSR, NULL, zfcp_sysfs_unit_add_store);\n\nstatic ssize_t zfcp_sysfs_unit_remove_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\n\tu64 fcp_lun;\n\n\tif (kstrtoull(buf, 0, (unsigned long long *) &fcp_lun))\n\t\treturn -EINVAL;\n\n\tif (zfcp_unit_remove(port, fcp_lun))\n\t\treturn -EINVAL;\n\n\treturn count;\n}\nstatic DEVICE_ATTR(unit_remove, S_IWUSR, NULL, zfcp_sysfs_unit_remove_store);\n\nstatic ssize_t zfcp_sysfs_port_fc_security_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\n\tstruct zfcp_adapter *adapter = port->adapter;\n\tunsigned int status = atomic_read(&port->status);\n\tint i;\n\n\tif (0 == (status & ZFCP_STATUS_COMMON_OPEN) ||\n\t    0 == (status & ZFCP_STATUS_COMMON_UNBLOCKED) ||\n\t    0 == (status & ZFCP_STATUS_PORT_PHYS_OPEN) ||\n\t    0 != (status & ZFCP_STATUS_PORT_LINK_TEST) ||\n\t    0 != (status & ZFCP_STATUS_COMMON_ERP_FAILED) ||\n\t    0 != (status & ZFCP_STATUS_COMMON_ACCESS_BOXED))\n\t\ti = sprintf(buf, \"unknown\\n\");\n\telse if (!(adapter->adapter_features & FSF_FEATURE_FC_SECURITY))\n\t\ti = sprintf(buf, \"unsupported\\n\");\n\telse {\n\t\ti = zfcp_fsf_scnprint_fc_security(\n\t\t\tbuf, PAGE_SIZE - 1, port->connection_info,\n\t\t\tZFCP_FSF_PRINT_FMT_SINGLEITEM);\n\t\ti += scnprintf(buf + i, PAGE_SIZE - i, \"\\n\");\n\t}\n\n\treturn i;\n}\nstatic ZFCP_DEV_ATTR(port, fc_security, S_IRUGO,\n\t\t     zfcp_sysfs_port_fc_security_show,\n\t\t     NULL);\n\nstatic struct attribute *zfcp_port_attrs[] = {\n\t&dev_attr_unit_add.attr,\n\t&dev_attr_unit_remove.attr,\n\t&dev_attr_port_failed.attr,\n\t&dev_attr_port_in_recovery.attr,\n\t&dev_attr_port_status.attr,\n\t&dev_attr_port_access_denied.attr,\n\t&dev_attr_port_fc_security.attr,\n\tNULL\n};\nstatic struct attribute_group zfcp_port_attr_group = {\n\t.attrs = zfcp_port_attrs,\n};\nconst struct attribute_group *zfcp_port_attr_groups[] = {\n\t&zfcp_port_attr_group,\n\tNULL,\n};\n\nstatic struct attribute *zfcp_unit_attrs[] = {\n\t&dev_attr_unit_failed.attr,\n\t&dev_attr_unit_in_recovery.attr,\n\t&dev_attr_unit_status.attr,\n\t&dev_attr_unit_access_denied.attr,\n\t&dev_attr_unit_access_shared.attr,\n\t&dev_attr_unit_access_readonly.attr,\n\tNULL\n};\nstatic struct attribute_group zfcp_unit_attr_group = {\n\t.attrs = zfcp_unit_attrs,\n};\nconst struct attribute_group *zfcp_unit_attr_groups[] = {\n\t&zfcp_unit_attr_group,\n\tNULL,\n};\n\n#define ZFCP_DEFINE_LATENCY_ATTR(_name) \t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nzfcp_sysfs_unit_##_name##_latency_show(struct device *dev,\t\t\\\n\t\t\t\t       struct device_attribute *attr,\t\\\n\t\t\t\t       char *buf) {\t\t\t\\\n\tstruct scsi_device *sdev = to_scsi_device(dev);\t\t\t\\\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\t\t\\\n\tstruct zfcp_latencies *lat = &zfcp_sdev->latencies;\t\t\\\n\tstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\t\\\n\tunsigned long long fsum, fmin, fmax, csum, cmin, cmax, cc;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspin_lock_bh(&lat->lock);\t\t\t\t\t\\\n\tfsum = lat->_name.fabric.sum * adapter->timer_ticks;\t\t\\\n\tfmin = lat->_name.fabric.min * adapter->timer_ticks;\t\t\\\n\tfmax = lat->_name.fabric.max * adapter->timer_ticks;\t\t\\\n\tcsum = lat->_name.channel.sum * adapter->timer_ticks;\t\t\\\n\tcmin = lat->_name.channel.min * adapter->timer_ticks;\t\t\\\n\tcmax = lat->_name.channel.max * adapter->timer_ticks;\t\t\\\n\tcc  = lat->_name.counter;\t\t\t\t\t\\\n\tspin_unlock_bh(&lat->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdo_div(fsum, 1000);\t\t\t\t\t\t\\\n\tdo_div(fmin, 1000);\t\t\t\t\t\t\\\n\tdo_div(fmax, 1000);\t\t\t\t\t\t\\\n\tdo_div(csum, 1000);\t\t\t\t\t\t\\\n\tdo_div(cmin, 1000);\t\t\t\t\t\t\\\n\tdo_div(cmax, 1000);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%llu %llu %llu %llu %llu %llu %llu\\n\",\t\\\n\t\t       fmin, fmax, fsum, cmin, cmax, csum, cc); \t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nzfcp_sysfs_unit_##_name##_latency_store(struct device *dev,\t\t\\\n\t\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\t\tconst char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_device *sdev = to_scsi_device(dev);\t\t\t\\\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\t\t\\\n\tstruct zfcp_latencies *lat = &zfcp_sdev->latencies;\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspin_lock_irqsave(&lat->lock, flags);\t\t\t\t\\\n\tlat->_name.fabric.sum = 0;\t\t\t\t\t\\\n\tlat->_name.fabric.min = 0xFFFFFFFF;\t\t\t\t\\\n\tlat->_name.fabric.max = 0;\t\t\t\t\t\\\n\tlat->_name.channel.sum = 0;\t\t\t\t\t\\\n\tlat->_name.channel.min = 0xFFFFFFFF;\t\t\t\t\\\n\tlat->_name.channel.max = 0;\t\t\t\t\t\\\n\tlat->_name.counter = 0;\t\t\t\t\t\t\\\n\tspin_unlock_irqrestore(&lat->lock, flags);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn (ssize_t) count;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(_name##_latency, S_IWUSR | S_IRUGO,\t\t\t\\\n\t\t   zfcp_sysfs_unit_##_name##_latency_show,\t\t\\\n\t\t   zfcp_sysfs_unit_##_name##_latency_store);\n\nZFCP_DEFINE_LATENCY_ATTR(read);\nZFCP_DEFINE_LATENCY_ATTR(write);\nZFCP_DEFINE_LATENCY_ATTR(cmd);\n\n#define ZFCP_DEFINE_SCSI_ATTR(_name, _format, _value)\t\t\t\\\nstatic ssize_t zfcp_sysfs_scsi_##_name##_show(struct device *dev,\t\\\n\t\t\t\t\t      struct device_attribute *attr,\\\n\t\t\t\t\t      char *buf)                 \\\n{                                                                        \\\n\tstruct scsi_device *sdev = to_scsi_device(dev);\t\t\t \\\n\tstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\t\t \\\n\t\t\t\t\t\t\t\t\t \\\n\treturn sprintf(buf, _format, _value);                            \\\n}                                                                        \\\nstatic DEVICE_ATTR(_name, S_IRUGO, zfcp_sysfs_scsi_##_name##_show, NULL);\n\nZFCP_DEFINE_SCSI_ATTR(hba_id, \"%s\\n\",\n\t\t      dev_name(&zfcp_sdev->port->adapter->ccw_device->dev));\nZFCP_DEFINE_SCSI_ATTR(wwpn, \"0x%016llx\\n\",\n\t\t      (unsigned long long) zfcp_sdev->port->wwpn);\n\nstatic ssize_t zfcp_sysfs_scsi_fcp_lun_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\treturn sprintf(buf, \"0x%016llx\\n\", zfcp_scsi_dev_lun(sdev));\n}\nstatic DEVICE_ATTR(fcp_lun, S_IRUGO, zfcp_sysfs_scsi_fcp_lun_show, NULL);\n\nZFCP_DEFINE_SCSI_ATTR(zfcp_access_denied, \"%d\\n\",\n\t\t      (atomic_read(&zfcp_sdev->status) &\n\t\t       ZFCP_STATUS_COMMON_ACCESS_DENIED) != 0);\n\nstatic ssize_t zfcp_sysfs_scsi_zfcp_failed_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tunsigned int status = atomic_read(&sdev_to_zfcp(sdev)->status);\n\tunsigned int failed = status & ZFCP_STATUS_COMMON_ERP_FAILED ? 1 : 0;\n\n\treturn sprintf(buf, \"%d\\n\", failed);\n}\n\nstatic ssize_t zfcp_sysfs_scsi_zfcp_failed_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) || val != 0)\n\t\treturn -EINVAL;\n\n\tzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_RUNNING);\n\tzfcp_erp_lun_reopen(sdev, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t    \"syufai3\");\n\tzfcp_erp_wait(sdev_to_zfcp(sdev)->port->adapter);\n\n\treturn count;\n}\nstatic DEVICE_ATTR(zfcp_failed, S_IWUSR | S_IRUGO,\n\t\t   zfcp_sysfs_scsi_zfcp_failed_show,\n\t\t   zfcp_sysfs_scsi_zfcp_failed_store);\n\nZFCP_DEFINE_SCSI_ATTR(zfcp_in_recovery, \"%d\\n\",\n\t\t      (atomic_read(&zfcp_sdev->status) &\n\t\t       ZFCP_STATUS_COMMON_ERP_INUSE) != 0);\n\nZFCP_DEFINE_SCSI_ATTR(zfcp_status, \"0x%08x\\n\",\n\t\t      atomic_read(&zfcp_sdev->status));\n\nstatic struct attribute *zfcp_sdev_attrs[] = {\n\t&dev_attr_fcp_lun.attr,\n\t&dev_attr_wwpn.attr,\n\t&dev_attr_hba_id.attr,\n\t&dev_attr_read_latency.attr,\n\t&dev_attr_write_latency.attr,\n\t&dev_attr_cmd_latency.attr,\n\t&dev_attr_zfcp_access_denied.attr,\n\t&dev_attr_zfcp_failed.attr,\n\t&dev_attr_zfcp_in_recovery.attr,\n\t&dev_attr_zfcp_status.attr,\n\tNULL\n};\n\nstatic const struct attribute_group zfcp_sysfs_sdev_attr_group = {\n\t.attrs = zfcp_sdev_attrs\n};\n\nconst struct attribute_group *zfcp_sysfs_sdev_attr_groups[] = {\n\t&zfcp_sysfs_sdev_attr_group,\n\tNULL\n};\n\nstatic ssize_t zfcp_sysfs_adapter_util_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct Scsi_Host *scsi_host = dev_to_shost(dev);\n\tstruct fsf_qtcb_bottom_port *qtcb_port;\n\tstruct zfcp_adapter *adapter;\n\tint retval;\n\n\tadapter = (struct zfcp_adapter *) scsi_host->hostdata[0];\n\tif (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tqtcb_port = kzalloc(sizeof(struct fsf_qtcb_bottom_port), GFP_KERNEL);\n\tif (!qtcb_port)\n\t\treturn -ENOMEM;\n\n\tretval = zfcp_fsf_exchange_port_data_sync(adapter->qdio, qtcb_port);\n\tif (retval == 0 || retval == -EAGAIN)\n\t\tretval = sprintf(buf, \"%u %u %u\\n\", qtcb_port->cp_util,\n\t\t\t\t qtcb_port->cb_util, qtcb_port->a_util);\n\tkfree(qtcb_port);\n\treturn retval;\n}\nstatic DEVICE_ATTR(utilization, S_IRUGO, zfcp_sysfs_adapter_util_show, NULL);\n\nstatic int zfcp_sysfs_adapter_ex_config(struct device *dev,\n\t\t\t\t\tstruct fsf_statistics_info *stat_inf)\n{\n\tstruct Scsi_Host *scsi_host = dev_to_shost(dev);\n\tstruct fsf_qtcb_bottom_config *qtcb_config;\n\tstruct zfcp_adapter *adapter;\n\tint retval;\n\n\tadapter = (struct zfcp_adapter *) scsi_host->hostdata[0];\n\tif (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tqtcb_config = kzalloc(sizeof(struct fsf_qtcb_bottom_config),\n\t\t\t      GFP_KERNEL);\n\tif (!qtcb_config)\n\t\treturn -ENOMEM;\n\n\tretval = zfcp_fsf_exchange_config_data_sync(adapter->qdio, qtcb_config);\n\tif (retval == 0 || retval == -EAGAIN)\n\t\t*stat_inf = qtcb_config->stat_info;\n\n\tkfree(qtcb_config);\n\treturn retval;\n}\n\n#define ZFCP_SHOST_ATTR(_name, _format, _arg...)\t\t\t\\\nstatic ssize_t zfcp_sysfs_adapter_##_name##_show(struct device *dev,\t\\\n\t\t\t\t\t\t struct device_attribute *attr,\\\n\t\t\t\t\t\t char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fsf_statistics_info stat_info;\t\t\t\t\\\n\tint retval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tretval = zfcp_sysfs_adapter_ex_config(dev, &stat_info);\t\t\\\n\tif (retval)\t\t\t\t\t\t\t\\\n\t\treturn retval;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, _format, ## _arg);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(_name, S_IRUGO, zfcp_sysfs_adapter_##_name##_show, NULL);\n\nZFCP_SHOST_ATTR(requests, \"%llu %llu %llu\\n\",\n\t\t(unsigned long long) stat_info.input_req,\n\t\t(unsigned long long) stat_info.output_req,\n\t\t(unsigned long long) stat_info.control_req);\n\nZFCP_SHOST_ATTR(megabytes, \"%llu %llu\\n\",\n\t\t(unsigned long long) stat_info.input_mb,\n\t\t(unsigned long long) stat_info.output_mb);\n\nZFCP_SHOST_ATTR(seconds_active, \"%llu\\n\",\n\t\t(unsigned long long) stat_info.seconds_act);\n\nstatic ssize_t zfcp_sysfs_adapter_q_full_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct Scsi_Host *scsi_host = class_to_shost(dev);\n\tstruct zfcp_qdio *qdio =\n\t\t((struct zfcp_adapter *) scsi_host->hostdata[0])->qdio;\n\tu64 util;\n\n\tspin_lock_bh(&qdio->stat_lock);\n\tutil = qdio->req_q_util;\n\tspin_unlock_bh(&qdio->stat_lock);\n\n\treturn sprintf(buf, \"%d %llu\\n\", atomic_read(&qdio->req_q_full),\n\t\t       (unsigned long long)util);\n}\nstatic DEVICE_ATTR(queue_full, S_IRUGO, zfcp_sysfs_adapter_q_full_show, NULL);\n\nstatic struct attribute *zfcp_sysfs_shost_attrs[] = {\n\t&dev_attr_utilization.attr,\n\t&dev_attr_requests.attr,\n\t&dev_attr_megabytes.attr,\n\t&dev_attr_seconds_active.attr,\n\t&dev_attr_queue_full.attr,\n\tNULL\n};\n\nstatic const struct attribute_group zfcp_sysfs_shost_attr_group = {\n\t.attrs = zfcp_sysfs_shost_attrs\n};\n\nconst struct attribute_group *zfcp_sysfs_shost_attr_groups[] = {\n\t&zfcp_sysfs_shost_attr_group,\n\tNULL\n};\n\nstatic ssize_t zfcp_sysfs_adapter_diag_b2b_credit_show(\n\tstruct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));\n\tstruct zfcp_diag_header *diag_hdr;\n\tstruct fc_els_flogi *nsp;\n\tssize_t rc = -ENOLINK;\n\tunsigned long flags;\n\tunsigned int status;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\tstatus = atomic_read(&adapter->status);\n\tif (0 == (status & ZFCP_STATUS_COMMON_OPEN) ||\n\t    0 == (status & ZFCP_STATUS_COMMON_UNBLOCKED) ||\n\t    0 != (status & ZFCP_STATUS_COMMON_ERP_FAILED))\n\t\tgoto out;\n\n\tdiag_hdr = &adapter->diagnostics->config_data.header;\n\n\trc = zfcp_diag_update_buffer_limited(\n\t\tadapter, diag_hdr, zfcp_diag_update_config_data_buffer);\n\tif (rc != 0)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&diag_hdr->access_lock, flags);\n\t \n\tnsp = (struct fc_els_flogi *)((unsigned long)\n\t\t\t\t\t      adapter->diagnostics->config_data\n\t\t\t\t\t\t      .data.nport_serv_param -\n\t\t\t\t      sizeof(u32));\n\n\trc = scnprintf(buf, 5 + 2, \"%hu\\n\",\n\t\t       be16_to_cpu(nsp->fl_csp.sp_bb_cred));\n\tspin_unlock_irqrestore(&diag_hdr->access_lock, flags);\n\nout:\n\tzfcp_ccw_adapter_put(adapter);\n\treturn rc;\n}\nstatic ZFCP_DEV_ATTR(adapter_diag, b2b_credit, 0400,\n\t\t     zfcp_sysfs_adapter_diag_b2b_credit_show, NULL);\n\n#define ZFCP_DEFINE_DIAG_SFP_ATTR(_name, _qtcb_member, _prtsize, _prtfmt)      \\\n\tstatic ssize_t zfcp_sysfs_adapter_diag_sfp_##_name##_show(\t       \\\n\t\tstruct device *dev, struct device_attribute *attr, char *buf)  \\\n\t{\t\t\t\t\t\t\t\t       \\\n\t\tstruct zfcp_adapter *const adapter =\t\t\t       \\\n\t\t\tzfcp_ccw_adapter_by_cdev(to_ccwdev(dev));\t       \\\n\t\tstruct zfcp_diag_header *diag_hdr;\t\t\t       \\\n\t\tssize_t rc = -ENOLINK;\t\t\t\t\t       \\\n\t\tunsigned long flags;\t\t\t\t\t       \\\n\t\tunsigned int status;\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tif (!adapter)\t\t\t\t\t\t       \\\n\t\t\treturn -ENODEV;\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tstatus = atomic_read(&adapter->status);\t\t\t       \\\n\t\tif (0 == (status & ZFCP_STATUS_COMMON_OPEN) ||\t\t       \\\n\t\t    0 == (status & ZFCP_STATUS_COMMON_UNBLOCKED) ||\t       \\\n\t\t    0 != (status & ZFCP_STATUS_COMMON_ERP_FAILED))\t       \\\n\t\t\tgoto out;\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tif (!zfcp_diag_support_sfp(adapter)) {\t\t\t       \\\n\t\t\trc = -EOPNOTSUPP;\t\t\t\t       \\\n\t\t\tgoto out;\t\t\t\t\t       \\\n\t\t}\t\t\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tdiag_hdr = &adapter->diagnostics->port_data.header;\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\trc = zfcp_diag_update_buffer_limited(\t\t\t       \\\n\t\t\tadapter, diag_hdr, zfcp_diag_update_port_data_buffer); \\\n\t\tif (rc != 0)\t\t\t\t\t\t       \\\n\t\t\tgoto out;\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tspin_lock_irqsave(&diag_hdr->access_lock, flags);\t       \\\n\t\trc = scnprintf(\t\t\t\t\t\t       \\\n\t\t\tbuf, (_prtsize) + 2, _prtfmt \"\\n\",\t\t       \\\n\t\t\tadapter->diagnostics->port_data.data._qtcb_member);    \\\n\t\tspin_unlock_irqrestore(&diag_hdr->access_lock, flags);\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tout:\t\t\t\t\t\t\t\t       \\\n\t\tzfcp_ccw_adapter_put(adapter);\t\t\t\t       \\\n\t\treturn rc;\t\t\t\t\t\t       \\\n\t}\t\t\t\t\t\t\t\t       \\\n\tstatic ZFCP_DEV_ATTR(adapter_diag_sfp, _name, 0400,\t\t       \\\n\t\t\t     zfcp_sysfs_adapter_diag_sfp_##_name##_show, NULL)\n\nZFCP_DEFINE_DIAG_SFP_ATTR(temperature, temperature, 6, \"%hd\");\nZFCP_DEFINE_DIAG_SFP_ATTR(vcc, vcc, 5, \"%hu\");\nZFCP_DEFINE_DIAG_SFP_ATTR(tx_bias, tx_bias, 5, \"%hu\");\nZFCP_DEFINE_DIAG_SFP_ATTR(tx_power, tx_power, 5, \"%hu\");\nZFCP_DEFINE_DIAG_SFP_ATTR(rx_power, rx_power, 5, \"%hu\");\nZFCP_DEFINE_DIAG_SFP_ATTR(port_tx_type, sfp_flags.port_tx_type, 2, \"%hu\");\nZFCP_DEFINE_DIAG_SFP_ATTR(optical_port, sfp_flags.optical_port, 1, \"%hu\");\nZFCP_DEFINE_DIAG_SFP_ATTR(sfp_invalid, sfp_flags.sfp_invalid, 1, \"%hu\");\nZFCP_DEFINE_DIAG_SFP_ATTR(connector_type, sfp_flags.connector_type, 1, \"%hu\");\nZFCP_DEFINE_DIAG_SFP_ATTR(fec_active, sfp_flags.fec_active, 1, \"%hu\");\n\nstatic struct attribute *zfcp_sysfs_diag_attrs[] = {\n\t&dev_attr_adapter_diag_sfp_temperature.attr,\n\t&dev_attr_adapter_diag_sfp_vcc.attr,\n\t&dev_attr_adapter_diag_sfp_tx_bias.attr,\n\t&dev_attr_adapter_diag_sfp_tx_power.attr,\n\t&dev_attr_adapter_diag_sfp_rx_power.attr,\n\t&dev_attr_adapter_diag_sfp_port_tx_type.attr,\n\t&dev_attr_adapter_diag_sfp_optical_port.attr,\n\t&dev_attr_adapter_diag_sfp_sfp_invalid.attr,\n\t&dev_attr_adapter_diag_sfp_connector_type.attr,\n\t&dev_attr_adapter_diag_sfp_fec_active.attr,\n\t&dev_attr_adapter_diag_b2b_credit.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group zfcp_sysfs_diag_attr_group = {\n\t.name = \"diagnostics\",\n\t.attrs = zfcp_sysfs_diag_attrs,\n};\n\nconst struct attribute_group *zfcp_sysfs_adapter_attr_groups[] = {\n\t&zfcp_sysfs_adapter_attr_group,\n\t&zfcp_sysfs_diag_attr_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}