{
  "module_name": "zfcp_aux.c",
  "hash_id": "2e4b93357567412d7ba0094e3bafbd7963da0607031a2bc7d5c4d98cfcaa9c89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_aux.c",
  "human_readable_source": "\n \n\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include \"zfcp_ext.h\"\n#include \"zfcp_fc.h\"\n#include \"zfcp_reqlist.h\"\n#include \"zfcp_diag.h\"\n\n#define ZFCP_BUS_ID_SIZE\t20\n\nMODULE_AUTHOR(\"IBM Deutschland Entwicklung GmbH - linux390@de.ibm.com\");\nMODULE_DESCRIPTION(\"FCP HBA driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic char *init_device;\nmodule_param_named(device, init_device, charp, 0400);\nMODULE_PARM_DESC(device, \"specify initial device\");\n\nstatic struct kmem_cache * __init zfcp_cache_hw_align(const char *name,\n\t\t\t\t\t\t      unsigned long size)\n{\n\treturn kmem_cache_create(name, size, roundup_pow_of_two(size), 0, NULL);\n}\n\nstatic void __init zfcp_init_device_configure(char *busid, u64 wwpn, u64 lun)\n{\n\tstruct ccw_device *cdev;\n\tstruct zfcp_adapter *adapter;\n\tstruct zfcp_port *port;\n\n\tcdev = get_ccwdev_by_busid(&zfcp_ccw_driver, busid);\n\tif (!cdev)\n\t\treturn;\n\n\tif (ccw_device_set_online(cdev))\n\t\tgoto out_ccw_device;\n\n\tadapter = zfcp_ccw_adapter_by_cdev(cdev);\n\tif (!adapter)\n\t\tgoto out_ccw_device;\n\n\tport = zfcp_get_port_by_wwpn(adapter, wwpn);\n\tif (!port)\n\t\tgoto out_port;\n\tflush_work(&port->rport_work);\n\n\tzfcp_unit_add(port, lun);\n\tput_device(&port->dev);\n\nout_port:\n\tzfcp_ccw_adapter_put(adapter);\nout_ccw_device:\n\tput_device(&cdev->dev);\n\treturn;\n}\n\nstatic void __init zfcp_init_device_setup(char *devstr)\n{\n\tchar *token;\n\tchar *str, *str_saved;\n\tchar busid[ZFCP_BUS_ID_SIZE];\n\tu64 wwpn, lun;\n\n\t \n\tstr_saved = kstrdup(devstr, GFP_KERNEL);\n\tstr = str_saved;\n\tif (!str)\n\t\treturn;\n\n\ttoken = strsep(&str, \",\");\n\tif (!token || strlen(token) >= ZFCP_BUS_ID_SIZE)\n\t\tgoto err_out;\n\tstrscpy(busid, token, ZFCP_BUS_ID_SIZE);\n\n\ttoken = strsep(&str, \",\");\n\tif (!token || kstrtoull(token, 0, (unsigned long long *) &wwpn))\n\t\tgoto err_out;\n\n\ttoken = strsep(&str, \",\");\n\tif (!token || kstrtoull(token, 0, (unsigned long long *) &lun))\n\t\tgoto err_out;\n\n\tkfree(str_saved);\n\tzfcp_init_device_configure(busid, wwpn, lun);\n\treturn;\n\nerr_out:\n\tkfree(str_saved);\n\tpr_err(\"%s is not a valid SCSI device\\n\", devstr);\n}\n\nstatic int __init zfcp_module_init(void)\n{\n\tint retval = -ENOMEM;\n\n\tif (zfcp_experimental_dix)\n\t\tpr_warn(\"DIX is enabled. It is experimental and might cause problems\\n\");\n\n\tzfcp_fsf_qtcb_cache = zfcp_cache_hw_align(\"zfcp_fsf_qtcb\",\n\t\t\t\t\t\t  sizeof(struct fsf_qtcb));\n\tif (!zfcp_fsf_qtcb_cache)\n\t\tgoto out_qtcb_cache;\n\n\tzfcp_fc_req_cache = zfcp_cache_hw_align(\"zfcp_fc_req\",\n\t\t\t\t\t\tsizeof(struct zfcp_fc_req));\n\tif (!zfcp_fc_req_cache)\n\t\tgoto out_fc_cache;\n\n\tzfcp_scsi_transport_template =\n\t\tfc_attach_transport(&zfcp_transport_functions);\n\tif (!zfcp_scsi_transport_template)\n\t\tgoto out_transport;\n\tscsi_transport_reserve_device(zfcp_scsi_transport_template,\n\t\t\t\t      sizeof(struct zfcp_scsi_dev));\n\n\tretval = ccw_driver_register(&zfcp_ccw_driver);\n\tif (retval) {\n\t\tpr_err(\"The zfcp device driver could not register with \"\n\t\t       \"the common I/O layer\\n\");\n\t\tgoto out_ccw_register;\n\t}\n\n\tif (init_device)\n\t\tzfcp_init_device_setup(init_device);\n\treturn 0;\n\nout_ccw_register:\n\tfc_release_transport(zfcp_scsi_transport_template);\nout_transport:\n\tkmem_cache_destroy(zfcp_fc_req_cache);\nout_fc_cache:\n\tkmem_cache_destroy(zfcp_fsf_qtcb_cache);\nout_qtcb_cache:\n\treturn retval;\n}\n\nmodule_init(zfcp_module_init);\n\nstatic void __exit zfcp_module_exit(void)\n{\n\tccw_driver_unregister(&zfcp_ccw_driver);\n\tfc_release_transport(zfcp_scsi_transport_template);\n\tkmem_cache_destroy(zfcp_fc_req_cache);\n\tkmem_cache_destroy(zfcp_fsf_qtcb_cache);\n}\n\nmodule_exit(zfcp_module_exit);\n\n \nstruct zfcp_port *zfcp_get_port_by_wwpn(struct zfcp_adapter *adapter,\n\t\t\t\t\tu64 wwpn)\n{\n\tunsigned long flags;\n\tstruct zfcp_port *port;\n\n\tread_lock_irqsave(&adapter->port_list_lock, flags);\n\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\tif (port->wwpn == wwpn) {\n\t\t\tif (!get_device(&port->dev))\n\t\t\t\tport = NULL;\n\t\t\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n\t\t\treturn port;\n\t\t}\n\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n\treturn NULL;\n}\n\nstatic int zfcp_allocate_low_mem_buffers(struct zfcp_adapter *adapter)\n{\n\tadapter->pool.erp_req =\n\t\tmempool_create_kmalloc_pool(1, sizeof(struct zfcp_fsf_req));\n\tif (!adapter->pool.erp_req)\n\t\treturn -ENOMEM;\n\n\tadapter->pool.gid_pn_req =\n\t\tmempool_create_kmalloc_pool(1, sizeof(struct zfcp_fsf_req));\n\tif (!adapter->pool.gid_pn_req)\n\t\treturn -ENOMEM;\n\n\tadapter->pool.scsi_req =\n\t\tmempool_create_kmalloc_pool(1, sizeof(struct zfcp_fsf_req));\n\tif (!adapter->pool.scsi_req)\n\t\treturn -ENOMEM;\n\n\tadapter->pool.scsi_abort =\n\t\tmempool_create_kmalloc_pool(1, sizeof(struct zfcp_fsf_req));\n\tif (!adapter->pool.scsi_abort)\n\t\treturn -ENOMEM;\n\n\tadapter->pool.status_read_req =\n\t\tmempool_create_kmalloc_pool(FSF_STATUS_READS_RECOM,\n\t\t\t\t\t    sizeof(struct zfcp_fsf_req));\n\tif (!adapter->pool.status_read_req)\n\t\treturn -ENOMEM;\n\n\tadapter->pool.qtcb_pool =\n\t\tmempool_create_slab_pool(4, zfcp_fsf_qtcb_cache);\n\tif (!adapter->pool.qtcb_pool)\n\t\treturn -ENOMEM;\n\n\tBUILD_BUG_ON(sizeof(struct fsf_status_read_buffer) > PAGE_SIZE);\n\tadapter->pool.sr_data =\n\t\tmempool_create_page_pool(FSF_STATUS_READS_RECOM, 0);\n\tif (!adapter->pool.sr_data)\n\t\treturn -ENOMEM;\n\n\tadapter->pool.gid_pn =\n\t\tmempool_create_slab_pool(1, zfcp_fc_req_cache);\n\tif (!adapter->pool.gid_pn)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void zfcp_free_low_mem_buffers(struct zfcp_adapter *adapter)\n{\n\tmempool_destroy(adapter->pool.erp_req);\n\tmempool_destroy(adapter->pool.scsi_req);\n\tmempool_destroy(adapter->pool.scsi_abort);\n\tmempool_destroy(adapter->pool.qtcb_pool);\n\tmempool_destroy(adapter->pool.status_read_req);\n\tmempool_destroy(adapter->pool.sr_data);\n\tmempool_destroy(adapter->pool.gid_pn);\n}\n\n \nint zfcp_status_read_refill(struct zfcp_adapter *adapter)\n{\n\twhile (atomic_add_unless(&adapter->stat_miss, -1, 0))\n\t\tif (zfcp_fsf_status_read(adapter->qdio)) {\n\t\t\tatomic_inc(&adapter->stat_miss);  \n\t\t\tif (atomic_read(&adapter->stat_miss) >=\n\t\t\t    adapter->stat_read_buf_num) {\n\t\t\t\tzfcp_erp_adapter_reopen(adapter, 0, \"axsref1\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\treturn 0;\n}\n\nstatic void _zfcp_status_read_scheduler(struct work_struct *work)\n{\n\tzfcp_status_read_refill(container_of(work, struct zfcp_adapter,\n\t\t\t\t\t     stat_work));\n}\n\nstatic void zfcp_version_change_lost_work(struct work_struct *work)\n{\n\tstruct zfcp_adapter *adapter = container_of(work, struct zfcp_adapter,\n\t\t\t\t\t\t    version_change_lost_work);\n\n\tzfcp_fsf_exchange_config_data_sync(adapter->qdio, NULL);\n}\n\nstatic void zfcp_print_sl(struct seq_file *m, struct service_level *sl)\n{\n\tstruct zfcp_adapter *adapter =\n\t\tcontainer_of(sl, struct zfcp_adapter, service_level);\n\n\tseq_printf(m, \"zfcp: %s microcode level %x\\n\",\n\t\t   dev_name(&adapter->ccw_device->dev),\n\t\t   adapter->fsf_lic_version);\n}\n\nstatic int zfcp_setup_adapter_work_queue(struct zfcp_adapter *adapter)\n{\n\tchar name[TASK_COMM_LEN];\n\n\tsnprintf(name, sizeof(name), \"zfcp_q_%s\",\n\t\t dev_name(&adapter->ccw_device->dev));\n\tadapter->work_queue = alloc_ordered_workqueue(name, WQ_MEM_RECLAIM);\n\n\tif (adapter->work_queue)\n\t\treturn 0;\n\treturn -ENOMEM;\n}\n\nstatic void zfcp_destroy_adapter_work_queue(struct zfcp_adapter *adapter)\n{\n\tif (adapter->work_queue)\n\t\tdestroy_workqueue(adapter->work_queue);\n\tadapter->work_queue = NULL;\n\n}\n\n \nstruct zfcp_adapter *zfcp_adapter_enqueue(struct ccw_device *ccw_device)\n{\n\tstruct zfcp_adapter *adapter;\n\n\tif (!get_device(&ccw_device->dev))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tadapter = kzalloc(sizeof(struct zfcp_adapter), GFP_KERNEL);\n\tif (!adapter) {\n\t\tput_device(&ccw_device->dev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkref_init(&adapter->ref);\n\n\tccw_device->handler = NULL;\n\tadapter->ccw_device = ccw_device;\n\n\tINIT_WORK(&adapter->stat_work, _zfcp_status_read_scheduler);\n\tINIT_DELAYED_WORK(&adapter->scan_work, zfcp_fc_scan_ports);\n\tINIT_WORK(&adapter->ns_up_work, zfcp_fc_sym_name_update);\n\tINIT_WORK(&adapter->version_change_lost_work,\n\t\t  zfcp_version_change_lost_work);\n\n\tadapter->next_port_scan = jiffies;\n\n\tadapter->erp_action.adapter = adapter;\n\n\tif (zfcp_diag_adapter_setup(adapter))\n\t\tgoto failed;\n\n\tif (zfcp_qdio_setup(adapter))\n\t\tgoto failed;\n\n\tif (zfcp_allocate_low_mem_buffers(adapter))\n\t\tgoto failed;\n\n\tadapter->req_list = zfcp_reqlist_alloc();\n\tif (!adapter->req_list)\n\t\tgoto failed;\n\n\tif (zfcp_dbf_adapter_register(adapter))\n\t\tgoto failed;\n\n\tif (zfcp_setup_adapter_work_queue(adapter))\n\t\tgoto failed;\n\n\tif (zfcp_fc_gs_setup(adapter))\n\t\tgoto failed;\n\n\trwlock_init(&adapter->port_list_lock);\n\tINIT_LIST_HEAD(&adapter->port_list);\n\n\tINIT_LIST_HEAD(&adapter->events.list);\n\tINIT_WORK(&adapter->events.work, zfcp_fc_post_event);\n\tspin_lock_init(&adapter->events.list_lock);\n\n\tinit_waitqueue_head(&adapter->erp_ready_wq);\n\tinit_waitqueue_head(&adapter->erp_done_wqh);\n\n\tINIT_LIST_HEAD(&adapter->erp_ready_head);\n\tINIT_LIST_HEAD(&adapter->erp_running_head);\n\n\trwlock_init(&adapter->erp_lock);\n\trwlock_init(&adapter->abort_lock);\n\n\tif (zfcp_erp_thread_setup(adapter))\n\t\tgoto failed;\n\n\tadapter->service_level.seq_print = zfcp_print_sl;\n\n\tdev_set_drvdata(&ccw_device->dev, adapter);\n\n\tif (device_add_groups(&ccw_device->dev, zfcp_sysfs_adapter_attr_groups))\n\t\tgoto err_sysfs;\n\n\t \n\tadapter->ccw_device->dev.dma_parms = &adapter->dma_parms;\n\n\tadapter->stat_read_buf_num = FSF_STATUS_READS_RECOM;\n\n\treturn adapter;\n\nerr_sysfs:\nfailed:\n\t \n\tcancel_delayed_work_sync(&adapter->scan_work);\n\tcancel_work_sync(&adapter->stat_work);\n\tcancel_work_sync(&adapter->ns_up_work);\n\tcancel_work_sync(&adapter->version_change_lost_work);\n\tzfcp_destroy_adapter_work_queue(adapter);\n\n\tzfcp_fc_wka_ports_force_offline(adapter->gs);\n\tzfcp_scsi_adapter_unregister(adapter);\n\n\tzfcp_erp_thread_kill(adapter);\n\tzfcp_dbf_adapter_unregister(adapter);\n\tzfcp_qdio_destroy(adapter->qdio);\n\n\tzfcp_ccw_adapter_put(adapter);  \n\treturn ERR_PTR(-ENOMEM);\n}\n\nvoid zfcp_adapter_unregister(struct zfcp_adapter *adapter)\n{\n\tstruct ccw_device *cdev = adapter->ccw_device;\n\n\tcancel_delayed_work_sync(&adapter->scan_work);\n\tcancel_work_sync(&adapter->stat_work);\n\tcancel_work_sync(&adapter->ns_up_work);\n\tcancel_work_sync(&adapter->version_change_lost_work);\n\tzfcp_destroy_adapter_work_queue(adapter);\n\n\tzfcp_fc_wka_ports_force_offline(adapter->gs);\n\tzfcp_scsi_adapter_unregister(adapter);\n\tdevice_remove_groups(&cdev->dev, zfcp_sysfs_adapter_attr_groups);\n\n\tzfcp_erp_thread_kill(adapter);\n\tzfcp_dbf_adapter_unregister(adapter);\n\tzfcp_qdio_destroy(adapter->qdio);\n\n\tzfcp_ccw_adapter_put(adapter);  \n}\n\n \nvoid zfcp_adapter_release(struct kref *ref)\n{\n\tstruct zfcp_adapter *adapter = container_of(ref, struct zfcp_adapter,\n\t\t\t\t\t\t    ref);\n\tstruct ccw_device *cdev = adapter->ccw_device;\n\n\tdev_set_drvdata(&adapter->ccw_device->dev, NULL);\n\tzfcp_fc_gs_destroy(adapter);\n\tzfcp_free_low_mem_buffers(adapter);\n\tzfcp_diag_adapter_free(adapter);\n\tkfree(adapter->req_list);\n\tkfree(adapter->fc_stats);\n\tkfree(adapter->stats_reset_data);\n\tkfree(adapter);\n\tput_device(&cdev->dev);\n}\n\nstatic void zfcp_port_release(struct device *dev)\n{\n\tstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\n\n\tzfcp_ccw_adapter_put(port->adapter);\n\tkfree(port);\n}\n\n \nstruct zfcp_port *zfcp_port_enqueue(struct zfcp_adapter *adapter, u64 wwpn,\n\t\t\t\t     u32 status, u32 d_id)\n{\n\tstruct zfcp_port *port;\n\tint retval = -ENOMEM;\n\n\tkref_get(&adapter->ref);\n\n\tport = zfcp_get_port_by_wwpn(adapter, wwpn);\n\tif (port) {\n\t\tput_device(&port->dev);\n\t\tretval = -EEXIST;\n\t\tgoto err_put;\n\t}\n\n\tport = kzalloc(sizeof(struct zfcp_port), GFP_KERNEL);\n\tif (!port)\n\t\tgoto err_put;\n\n\trwlock_init(&port->unit_list_lock);\n\tINIT_LIST_HEAD(&port->unit_list);\n\tatomic_set(&port->units, 0);\n\n\tINIT_WORK(&port->gid_pn_work, zfcp_fc_port_did_lookup);\n\tINIT_WORK(&port->test_link_work, zfcp_fc_link_test_work);\n\tINIT_WORK(&port->rport_work, zfcp_scsi_rport_work);\n\n\tport->adapter = adapter;\n\tport->d_id = d_id;\n\tport->wwpn = wwpn;\n\tport->rport_task = RPORT_NONE;\n\tport->dev.parent = &adapter->ccw_device->dev;\n\tport->dev.groups = zfcp_port_attr_groups;\n\tport->dev.release = zfcp_port_release;\n\n\tport->erp_action.adapter = adapter;\n\tport->erp_action.port = port;\n\n\tif (dev_set_name(&port->dev, \"0x%016llx\", (unsigned long long)wwpn)) {\n\t\tkfree(port);\n\t\tgoto err_put;\n\t}\n\tretval = -EINVAL;\n\n\tif (device_register(&port->dev)) {\n\t\tput_device(&port->dev);\n\t\tgoto err_out;\n\t}\n\n\twrite_lock_irq(&adapter->port_list_lock);\n\tlist_add_tail(&port->list, &adapter->port_list);\n\twrite_unlock_irq(&adapter->port_list_lock);\n\n\tatomic_or(status | ZFCP_STATUS_COMMON_RUNNING, &port->status);\n\n\treturn port;\n\nerr_put:\n\tzfcp_ccw_adapter_put(adapter);\nerr_out:\n\treturn ERR_PTR(retval);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}