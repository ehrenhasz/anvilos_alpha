{
  "module_name": "zfcp_fc.c",
  "hash_id": "9ed75b0509f42e63b02799bc96b0abae92c3fb4de069706059ad246ace21931c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_fc.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"zfcp\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/utsname.h>\n#include <linux/random.h>\n#include <linux/bsg-lib.h>\n#include <scsi/fc/fc_els.h>\n#include <scsi/libfc.h>\n#include \"zfcp_ext.h\"\n#include \"zfcp_fc.h\"\n\nstruct kmem_cache *zfcp_fc_req_cache;\n\nstatic u32 zfcp_fc_rscn_range_mask[] = {\n\t[ELS_ADDR_FMT_PORT]\t\t= 0xFFFFFF,\n\t[ELS_ADDR_FMT_AREA]\t\t= 0xFFFF00,\n\t[ELS_ADDR_FMT_DOM]\t\t= 0xFF0000,\n\t[ELS_ADDR_FMT_FAB]\t\t= 0x000000,\n};\n\nstatic bool no_auto_port_rescan;\nmodule_param(no_auto_port_rescan, bool, 0600);\nMODULE_PARM_DESC(no_auto_port_rescan,\n\t\t \"no automatic port_rescan (default off)\");\n\nstatic unsigned int port_scan_backoff = 500;\nmodule_param(port_scan_backoff, uint, 0600);\nMODULE_PARM_DESC(port_scan_backoff,\n\t\"upper limit of port scan random backoff in msecs (default 500)\");\n\nstatic unsigned int port_scan_ratelimit = 60000;\nmodule_param(port_scan_ratelimit, uint, 0600);\nMODULE_PARM_DESC(port_scan_ratelimit,\n\t\"minimum interval between port scans in msecs (default 60000)\");\n\nunsigned int zfcp_fc_port_scan_backoff(void)\n{\n\tif (!port_scan_backoff)\n\t\treturn 0;\n\treturn get_random_u32_below(port_scan_backoff);\n}\n\nstatic void zfcp_fc_port_scan_time(struct zfcp_adapter *adapter)\n{\n\tunsigned long interval = msecs_to_jiffies(port_scan_ratelimit);\n\tunsigned long backoff = msecs_to_jiffies(zfcp_fc_port_scan_backoff());\n\n\tadapter->next_port_scan = jiffies + interval + backoff;\n}\n\nstatic void zfcp_fc_port_scan(struct zfcp_adapter *adapter)\n{\n\tunsigned long now = jiffies;\n\tunsigned long next = adapter->next_port_scan;\n\tunsigned long delay = 0, max;\n\n\t \n\tif (time_before(now, next)) {\n\t\tdelay = next - now;\n\t\t \n\t\tmax = msecs_to_jiffies(port_scan_ratelimit + port_scan_backoff);\n\t\tdelay = min(delay, max);\n\t}\n\n\tqueue_delayed_work(adapter->work_queue, &adapter->scan_work, delay);\n}\n\nvoid zfcp_fc_conditional_port_scan(struct zfcp_adapter *adapter)\n{\n\tif (no_auto_port_rescan)\n\t\treturn;\n\n\tzfcp_fc_port_scan(adapter);\n}\n\nvoid zfcp_fc_inverse_conditional_port_scan(struct zfcp_adapter *adapter)\n{\n\tif (!no_auto_port_rescan)\n\t\treturn;\n\n\tzfcp_fc_port_scan(adapter);\n}\n\n \nvoid zfcp_fc_post_event(struct work_struct *work)\n{\n\tstruct zfcp_fc_event *event = NULL, *tmp = NULL;\n\tLIST_HEAD(tmp_lh);\n\tstruct zfcp_fc_events *events = container_of(work,\n\t\t\t\t\tstruct zfcp_fc_events, work);\n\tstruct zfcp_adapter *adapter = container_of(events, struct zfcp_adapter,\n\t\t\t\t\t\tevents);\n\n\tspin_lock_bh(&events->list_lock);\n\tlist_splice_init(&events->list, &tmp_lh);\n\tspin_unlock_bh(&events->list_lock);\n\n\tlist_for_each_entry_safe(event, tmp, &tmp_lh, list) {\n\t\tfc_host_post_event(adapter->scsi_host, fc_get_event_number(),\n\t\t\t\t   event->code, event->data);\n\t\tlist_del(&event->list);\n\t\tkfree(event);\n\t}\n}\n\n \nvoid zfcp_fc_enqueue_event(struct zfcp_adapter *adapter,\n\t\t\t   enum fc_host_event_code event_code, u32 event_data)\n{\n\tstruct zfcp_fc_event *event;\n\n\tevent = kmalloc(sizeof(struct zfcp_fc_event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn;\n\n\tevent->code = event_code;\n\tevent->data = event_data;\n\n\tspin_lock(&adapter->events.list_lock);\n\tlist_add_tail(&event->list, &adapter->events.list);\n\tspin_unlock(&adapter->events.list_lock);\n\n\tqueue_work(adapter->work_queue, &adapter->events.work);\n}\n\nstatic int zfcp_fc_wka_port_get(struct zfcp_fc_wka_port *wka_port)\n{\n\tint ret = -EIO;\n\n\tif (mutex_lock_interruptible(&wka_port->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (wka_port->status == ZFCP_FC_WKA_PORT_OFFLINE ||\n\t    wka_port->status == ZFCP_FC_WKA_PORT_CLOSING) {\n\t\twka_port->status = ZFCP_FC_WKA_PORT_OPENING;\n\t\tif (zfcp_fsf_open_wka_port(wka_port)) {\n\t\t\t \n\t\t\twka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twait_event(wka_port->opened,\n\t\t   wka_port->status == ZFCP_FC_WKA_PORT_ONLINE ||\n\t\t   wka_port->status == ZFCP_FC_WKA_PORT_OFFLINE);\n\n\tif (wka_port->status == ZFCP_FC_WKA_PORT_ONLINE) {\n\t\tatomic_inc(&wka_port->refcount);\n\t\tret = 0;\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wka_port->mutex);\n\treturn ret;\n}\n\nstatic void zfcp_fc_wka_port_offline(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct zfcp_fc_wka_port *wka_port =\n\t\t\tcontainer_of(dw, struct zfcp_fc_wka_port, work);\n\n\tmutex_lock(&wka_port->mutex);\n\tif ((atomic_read(&wka_port->refcount) != 0) ||\n\t    (wka_port->status != ZFCP_FC_WKA_PORT_ONLINE))\n\t\tgoto out;\n\n\twka_port->status = ZFCP_FC_WKA_PORT_CLOSING;\n\tif (zfcp_fsf_close_wka_port(wka_port)) {\n\t\t \n\t\twka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\n\t\tgoto out;\n\t}\n\twait_event(wka_port->closed,\n\t\t   wka_port->status == ZFCP_FC_WKA_PORT_OFFLINE);\nout:\n\tmutex_unlock(&wka_port->mutex);\n}\n\nstatic void zfcp_fc_wka_port_put(struct zfcp_fc_wka_port *wka_port)\n{\n\tif (atomic_dec_return(&wka_port->refcount) != 0)\n\t\treturn;\n\t \n\tqueue_delayed_work(wka_port->adapter->work_queue, &wka_port->work,\n\t\t\t   msecs_to_jiffies(10));\n}\n\nstatic void zfcp_fc_wka_port_init(struct zfcp_fc_wka_port *wka_port, u32 d_id,\n\t\t\t\t  struct zfcp_adapter *adapter)\n{\n\tinit_waitqueue_head(&wka_port->opened);\n\tinit_waitqueue_head(&wka_port->closed);\n\n\twka_port->adapter = adapter;\n\twka_port->d_id = d_id;\n\n\twka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\n\tatomic_set(&wka_port->refcount, 0);\n\tmutex_init(&wka_port->mutex);\n\tINIT_DELAYED_WORK(&wka_port->work, zfcp_fc_wka_port_offline);\n}\n\nstatic void zfcp_fc_wka_port_force_offline(struct zfcp_fc_wka_port *wka)\n{\n\tcancel_delayed_work_sync(&wka->work);\n\tmutex_lock(&wka->mutex);\n\twka->status = ZFCP_FC_WKA_PORT_OFFLINE;\n\tmutex_unlock(&wka->mutex);\n}\n\nvoid zfcp_fc_wka_ports_force_offline(struct zfcp_fc_wka_ports *gs)\n{\n\tif (!gs)\n\t\treturn;\n\tzfcp_fc_wka_port_force_offline(&gs->ms);\n\tzfcp_fc_wka_port_force_offline(&gs->ts);\n\tzfcp_fc_wka_port_force_offline(&gs->ds);\n\tzfcp_fc_wka_port_force_offline(&gs->as);\n}\n\nstatic void _zfcp_fc_incoming_rscn(struct zfcp_fsf_req *fsf_req, u32 range,\n\t\t\t\t   struct fc_els_rscn_page *page)\n{\n\tunsigned long flags;\n\tstruct zfcp_adapter *adapter = fsf_req->adapter;\n\tstruct zfcp_port *port;\n\n\tread_lock_irqsave(&adapter->port_list_lock, flags);\n\tlist_for_each_entry(port, &adapter->port_list, list) {\n\t\tif ((port->d_id & range) == (ntoh24(page->rscn_fid) & range))\n\t\t\tzfcp_fc_test_link(port);\n\t}\n\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n}\n\nstatic void zfcp_fc_incoming_rscn(struct zfcp_fsf_req *fsf_req)\n{\n\tstruct fsf_status_read_buffer *status_buffer = (void *)fsf_req->data;\n\tstruct zfcp_adapter *adapter = fsf_req->adapter;\n\tstruct fc_els_rscn *head;\n\tstruct fc_els_rscn_page *page;\n\tu16 i;\n\tu16 no_entries;\n\tunsigned int afmt;\n\n\thead = (struct fc_els_rscn *) status_buffer->payload.data;\n\tpage = (struct fc_els_rscn_page *) head;\n\n\t \n\tno_entries = be16_to_cpu(head->rscn_plen) /\n\t\tsizeof(struct fc_els_rscn_page);\n\n\tif (no_entries > 1) {\n\t\t \n\t\tunsigned long flags;\n\t\tstruct zfcp_port *port;\n\n\t\tread_lock_irqsave(&adapter->port_list_lock, flags);\n\t\tlist_for_each_entry(port, &adapter->port_list, list) {\n\t\t\tif (port->d_id)\n\t\t\t\tcontinue;\n\t\t\tzfcp_erp_port_reopen(port,\n\t\t\t\t\t     ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\t     \"fcrscn1\");\n\t\t}\n\t\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n\t}\n\n\tfor (i = 1; i < no_entries; i++) {\n\t\t \n\t\tpage++;\n\t\tafmt = page->rscn_page_flags & ELS_RSCN_ADDR_FMT_MASK;\n\t\t_zfcp_fc_incoming_rscn(fsf_req, zfcp_fc_rscn_range_mask[afmt],\n\t\t\t\t       page);\n\t\tzfcp_fc_enqueue_event(fsf_req->adapter, FCH_EVT_RSCN,\n\t\t\t\t      *(u32 *)page);\n\t}\n\tzfcp_fc_conditional_port_scan(fsf_req->adapter);\n}\n\nstatic void zfcp_fc_incoming_wwpn(struct zfcp_fsf_req *req, u64 wwpn)\n{\n\tunsigned long flags;\n\tstruct zfcp_adapter *adapter = req->adapter;\n\tstruct zfcp_port *port;\n\n\tread_lock_irqsave(&adapter->port_list_lock, flags);\n\tlist_for_each_entry(port, &adapter->port_list, list)\n\t\tif (port->wwpn == wwpn) {\n\t\t\tzfcp_erp_port_forced_reopen(port, 0, \"fciwwp1\");\n\t\t\tbreak;\n\t\t}\n\tread_unlock_irqrestore(&adapter->port_list_lock, flags);\n}\n\nstatic void zfcp_fc_incoming_plogi(struct zfcp_fsf_req *req)\n{\n\tstruct fsf_status_read_buffer *status_buffer;\n\tstruct fc_els_flogi *plogi;\n\n\tstatus_buffer = (struct fsf_status_read_buffer *) req->data;\n\tplogi = (struct fc_els_flogi *) status_buffer->payload.data;\n\tzfcp_fc_incoming_wwpn(req, be64_to_cpu(plogi->fl_wwpn));\n}\n\nstatic void zfcp_fc_incoming_logo(struct zfcp_fsf_req *req)\n{\n\tstruct fsf_status_read_buffer *status_buffer =\n\t\t(struct fsf_status_read_buffer *)req->data;\n\tstruct fc_els_logo *logo =\n\t\t(struct fc_els_logo *) status_buffer->payload.data;\n\n\tzfcp_fc_incoming_wwpn(req, be64_to_cpu(logo->fl_n_port_wwn));\n}\n\n \nvoid zfcp_fc_incoming_els(struct zfcp_fsf_req *fsf_req)\n{\n\tstruct fsf_status_read_buffer *status_buffer =\n\t\t(struct fsf_status_read_buffer *) fsf_req->data;\n\tunsigned int els_type = status_buffer->payload.data[0];\n\n\tzfcp_dbf_san_in_els(\"fciels1\", fsf_req);\n\tif (els_type == ELS_PLOGI)\n\t\tzfcp_fc_incoming_plogi(fsf_req);\n\telse if (els_type == ELS_LOGO)\n\t\tzfcp_fc_incoming_logo(fsf_req);\n\telse if (els_type == ELS_RSCN)\n\t\tzfcp_fc_incoming_rscn(fsf_req);\n}\n\nstatic void zfcp_fc_ns_gid_pn_eval(struct zfcp_fc_req *fc_req)\n{\n\tstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\n\tstruct zfcp_fc_gid_pn_rsp *gid_pn_rsp = &fc_req->u.gid_pn.rsp;\n\n\tif (ct_els->status)\n\t\treturn;\n\tif (gid_pn_rsp->ct_hdr.ct_cmd != cpu_to_be16(FC_FS_ACC))\n\t\treturn;\n\n\t \n\tct_els->port->d_id = ntoh24(gid_pn_rsp->gid_pn.fp_fid);\n}\n\nstatic void zfcp_fc_complete(void *data)\n{\n\tcomplete(data);\n}\n\nstatic void zfcp_fc_ct_ns_init(struct fc_ct_hdr *ct_hdr, u16 cmd, u16 mr_size)\n{\n\tct_hdr->ct_rev = FC_CT_REV;\n\tct_hdr->ct_fs_type = FC_FST_DIR;\n\tct_hdr->ct_fs_subtype = FC_NS_SUBTYPE;\n\tct_hdr->ct_cmd = cpu_to_be16(cmd);\n\tct_hdr->ct_mr_size = cpu_to_be16(mr_size / 4);\n}\n\nstatic int zfcp_fc_ns_gid_pn_request(struct zfcp_port *port,\n\t\t\t\t     struct zfcp_fc_req *fc_req)\n{\n\tstruct zfcp_adapter *adapter = port->adapter;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct zfcp_fc_gid_pn_req *gid_pn_req = &fc_req->u.gid_pn.req;\n\tstruct zfcp_fc_gid_pn_rsp *gid_pn_rsp = &fc_req->u.gid_pn.rsp;\n\tint ret;\n\n\t \n\tfc_req->ct_els.port = port;\n\tfc_req->ct_els.handler = zfcp_fc_complete;\n\tfc_req->ct_els.handler_data = &completion;\n\tfc_req->ct_els.req = &fc_req->sg_req;\n\tfc_req->ct_els.resp = &fc_req->sg_rsp;\n\tsg_init_one(&fc_req->sg_req, gid_pn_req, sizeof(*gid_pn_req));\n\tsg_init_one(&fc_req->sg_rsp, gid_pn_rsp, sizeof(*gid_pn_rsp));\n\n\tzfcp_fc_ct_ns_init(&gid_pn_req->ct_hdr,\n\t\t\t   FC_NS_GID_PN, ZFCP_FC_CT_SIZE_PAGE);\n\tgid_pn_req->gid_pn.fn_wwpn = cpu_to_be64(port->wwpn);\n\n\tret = zfcp_fsf_send_ct(&adapter->gs->ds, &fc_req->ct_els,\n\t\t\t       adapter->pool.gid_pn_req,\n\t\t\t       ZFCP_FC_CTELS_TMO);\n\tif (!ret) {\n\t\twait_for_completion(&completion);\n\t\tzfcp_fc_ns_gid_pn_eval(fc_req);\n\t}\n\treturn ret;\n}\n\n \nstatic int zfcp_fc_ns_gid_pn(struct zfcp_port *port)\n{\n\tint ret;\n\tstruct zfcp_fc_req *fc_req;\n\tstruct zfcp_adapter *adapter = port->adapter;\n\n\tfc_req = mempool_alloc(adapter->pool.gid_pn, GFP_ATOMIC);\n\tif (!fc_req)\n\t\treturn -ENOMEM;\n\n\tmemset(fc_req, 0, sizeof(*fc_req));\n\n\tret = zfcp_fc_wka_port_get(&adapter->gs->ds);\n\tif (ret)\n\t\tgoto out;\n\n\tret = zfcp_fc_ns_gid_pn_request(port, fc_req);\n\n\tzfcp_fc_wka_port_put(&adapter->gs->ds);\nout:\n\tmempool_free(fc_req, adapter->pool.gid_pn);\n\treturn ret;\n}\n\nvoid zfcp_fc_port_did_lookup(struct work_struct *work)\n{\n\tint ret;\n\tstruct zfcp_port *port = container_of(work, struct zfcp_port,\n\t\t\t\t\t      gid_pn_work);\n\n\tset_worker_desc(\"zgidpn%16llx\", port->wwpn);  \n\tret = zfcp_fc_ns_gid_pn(port);\n\tif (ret) {\n\t\t \n\t\tzfcp_erp_adapter_reopen(port->adapter, 0, \"fcgpn_1\");\n\t\tgoto out;\n\t}\n\n\tif (!port->d_id) {\n\t\tzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_ERP_FAILED);\n\t\tgoto out;\n\t}\n\n\tzfcp_erp_port_reopen(port, 0, \"fcgpn_3\");\nout:\n\tput_device(&port->dev);\n}\n\n \nvoid zfcp_fc_trigger_did_lookup(struct zfcp_port *port)\n{\n\tget_device(&port->dev);\n\tif (!queue_work(port->adapter->work_queue, &port->gid_pn_work))\n\t\tput_device(&port->dev);\n}\n\n \nvoid zfcp_fc_plogi_evaluate(struct zfcp_port *port, struct fc_els_flogi *plogi)\n{\n\tif (be64_to_cpu(plogi->fl_wwpn) != port->wwpn) {\n\t\tport->d_id = 0;\n\t\tdev_warn(&port->adapter->ccw_device->dev,\n\t\t\t \"A port opened with WWPN 0x%016Lx returned data that \"\n\t\t\t \"identifies it as WWPN 0x%016Lx\\n\",\n\t\t\t (unsigned long long) port->wwpn,\n\t\t\t (unsigned long long) be64_to_cpu(plogi->fl_wwpn));\n\t\treturn;\n\t}\n\n\tport->wwnn = be64_to_cpu(plogi->fl_wwnn);\n\tport->maxframe_size = be16_to_cpu(plogi->fl_csp.sp_bb_data);\n\n\tif (plogi->fl_cssp[0].cp_class & cpu_to_be16(FC_CPC_VALID))\n\t\tport->supported_classes |= FC_COS_CLASS1;\n\tif (plogi->fl_cssp[1].cp_class & cpu_to_be16(FC_CPC_VALID))\n\t\tport->supported_classes |= FC_COS_CLASS2;\n\tif (plogi->fl_cssp[2].cp_class & cpu_to_be16(FC_CPC_VALID))\n\t\tport->supported_classes |= FC_COS_CLASS3;\n\tif (plogi->fl_cssp[3].cp_class & cpu_to_be16(FC_CPC_VALID))\n\t\tport->supported_classes |= FC_COS_CLASS4;\n}\n\nstatic void zfcp_fc_adisc_handler(void *data)\n{\n\tstruct zfcp_fc_req *fc_req = data;\n\tstruct zfcp_port *port = fc_req->ct_els.port;\n\tstruct fc_els_adisc *adisc_resp = &fc_req->u.adisc.rsp;\n\n\tif (fc_req->ct_els.status) {\n\t\t \n\t\tzfcp_erp_port_forced_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t\t    \"fcadh_1\");\n\t\tgoto out;\n\t}\n\n\tif (!port->wwnn)\n\t\tport->wwnn = be64_to_cpu(adisc_resp->adisc_wwnn);\n\n\tif ((port->wwpn != be64_to_cpu(adisc_resp->adisc_wwpn)) ||\n\t    !(atomic_read(&port->status) & ZFCP_STATUS_COMMON_OPEN)) {\n\t\tzfcp_erp_port_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED,\n\t\t\t\t     \"fcadh_2\");\n\t\tgoto out;\n\t}\n\n\t \n\tport->d_id = ntoh24(adisc_resp->adisc_port_id);\n\t \n out:\n\tatomic_andnot(ZFCP_STATUS_PORT_LINK_TEST, &port->status);\n\tput_device(&port->dev);\n\tkmem_cache_free(zfcp_fc_req_cache, fc_req);\n}\n\nstatic int zfcp_fc_adisc(struct zfcp_port *port)\n{\n\tstruct zfcp_fc_req *fc_req;\n\tstruct zfcp_adapter *adapter = port->adapter;\n\tstruct Scsi_Host *shost = adapter->scsi_host;\n\tu32 d_id;\n\tint ret;\n\n\tfc_req = kmem_cache_zalloc(zfcp_fc_req_cache, GFP_ATOMIC);\n\tif (!fc_req)\n\t\treturn -ENOMEM;\n\n\tfc_req->ct_els.port = port;\n\tfc_req->ct_els.req = &fc_req->sg_req;\n\tfc_req->ct_els.resp = &fc_req->sg_rsp;\n\tsg_init_one(&fc_req->sg_req, &fc_req->u.adisc.req,\n\t\t    sizeof(struct fc_els_adisc));\n\tsg_init_one(&fc_req->sg_rsp, &fc_req->u.adisc.rsp,\n\t\t    sizeof(struct fc_els_adisc));\n\n\tfc_req->ct_els.handler = zfcp_fc_adisc_handler;\n\tfc_req->ct_els.handler_data = fc_req;\n\n\t \n\tfc_req->u.adisc.req.adisc_wwpn = cpu_to_be64(fc_host_port_name(shost));\n\tfc_req->u.adisc.req.adisc_wwnn = cpu_to_be64(fc_host_node_name(shost));\n\tfc_req->u.adisc.req.adisc_cmd = ELS_ADISC;\n\thton24(fc_req->u.adisc.req.adisc_port_id, fc_host_port_id(shost));\n\n\td_id = port->d_id;  \n\t \n\tport->d_id = 0;\n\n\tret = zfcp_fsf_send_els(adapter, d_id, &fc_req->ct_els,\n\t\t\t\tZFCP_FC_CTELS_TMO);\n\tif (ret)\n\t\tkmem_cache_free(zfcp_fc_req_cache, fc_req);\n\n\treturn ret;\n}\n\nvoid zfcp_fc_link_test_work(struct work_struct *work)\n{\n\tstruct zfcp_port *port =\n\t\tcontainer_of(work, struct zfcp_port, test_link_work);\n\tint retval;\n\n\tset_worker_desc(\"zadisc%16llx\", port->wwpn);  \n\n\t \n\tif (atomic_read(&port->status) & ZFCP_STATUS_PORT_LINK_TEST)\n\t\tgoto out;\n\n\tatomic_or(ZFCP_STATUS_PORT_LINK_TEST, &port->status);\n\n\tretval = zfcp_fc_adisc(port);\n\tif (retval == 0)\n\t\treturn;\n\n\t \n\tatomic_andnot(ZFCP_STATUS_PORT_LINK_TEST, &port->status);\n\tzfcp_erp_port_forced_reopen(port, 0, \"fcltwk1\");\n\nout:\n\tput_device(&port->dev);\n}\n\n \nvoid zfcp_fc_test_link(struct zfcp_port *port)\n{\n\tget_device(&port->dev);\n\tif (!queue_work(port->adapter->work_queue, &port->test_link_work))\n\t\tput_device(&port->dev);\n}\n\n \nstatic void zfcp_fc_sg_free_table(struct scatterlist *sg, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++, sg = sg_next(sg))\n\t\tif (sg)\n\t\t\tfree_page((unsigned long) sg_virt(sg));\n\t\telse\n\t\t\tbreak;\n}\n\n \nstatic int zfcp_fc_sg_setup_table(struct scatterlist *sg, int count)\n{\n\tvoid *addr;\n\tint i;\n\n\tsg_init_table(sg, count);\n\tfor (i = 0; i < count; i++, sg = sg_next(sg)) {\n\t\taddr = (void *) get_zeroed_page(GFP_KERNEL);\n\t\tif (!addr) {\n\t\t\tzfcp_fc_sg_free_table(sg, i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsg_set_buf(sg, addr, PAGE_SIZE);\n\t}\n\treturn 0;\n}\n\nstatic struct zfcp_fc_req *zfcp_fc_alloc_sg_env(int buf_num)\n{\n\tstruct zfcp_fc_req *fc_req;\n\n\tfc_req = kmem_cache_zalloc(zfcp_fc_req_cache, GFP_KERNEL);\n\tif (!fc_req)\n\t\treturn NULL;\n\n\tif (zfcp_fc_sg_setup_table(&fc_req->sg_rsp, buf_num)) {\n\t\tkmem_cache_free(zfcp_fc_req_cache, fc_req);\n\t\treturn NULL;\n\t}\n\n\tsg_init_one(&fc_req->sg_req, &fc_req->u.gpn_ft.req,\n\t\t    sizeof(struct zfcp_fc_gpn_ft_req));\n\n\treturn fc_req;\n}\n\nstatic int zfcp_fc_send_gpn_ft(struct zfcp_fc_req *fc_req,\n\t\t\t       struct zfcp_adapter *adapter, int max_bytes)\n{\n\tstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\n\tstruct zfcp_fc_gpn_ft_req *req = &fc_req->u.gpn_ft.req;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint ret;\n\n\tzfcp_fc_ct_ns_init(&req->ct_hdr, FC_NS_GPN_FT, max_bytes);\n\treq->gpn_ft.fn_fc4_type = FC_TYPE_FCP;\n\n\tct_els->handler = zfcp_fc_complete;\n\tct_els->handler_data = &completion;\n\tct_els->req = &fc_req->sg_req;\n\tct_els->resp = &fc_req->sg_rsp;\n\n\tret = zfcp_fsf_send_ct(&adapter->gs->ds, ct_els, NULL,\n\t\t\t       ZFCP_FC_CTELS_TMO);\n\tif (!ret)\n\t\twait_for_completion(&completion);\n\treturn ret;\n}\n\nstatic void zfcp_fc_validate_port(struct zfcp_port *port, struct list_head *lh)\n{\n\tif (!(atomic_read(&port->status) & ZFCP_STATUS_COMMON_NOESC))\n\t\treturn;\n\n\tatomic_andnot(ZFCP_STATUS_COMMON_NOESC, &port->status);\n\n\tif ((port->supported_classes != 0) ||\n\t    !list_empty(&port->unit_list))\n\t\treturn;\n\n\tlist_move_tail(&port->list, lh);\n}\n\nstatic int zfcp_fc_eval_gpn_ft(struct zfcp_fc_req *fc_req,\n\t\t\t       struct zfcp_adapter *adapter, int max_entries)\n{\n\tstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\n\tstruct scatterlist *sg = &fc_req->sg_rsp;\n\tstruct fc_ct_hdr *hdr = sg_virt(sg);\n\tstruct fc_gpn_ft_resp *acc = sg_virt(sg);\n\tstruct zfcp_port *port, *tmp;\n\tunsigned long flags;\n\tLIST_HEAD(remove_lh);\n\tu32 d_id;\n\tint ret = 0, x, last = 0;\n\n\tif (ct_els->status)\n\t\treturn -EIO;\n\n\tif (hdr->ct_cmd != cpu_to_be16(FC_FS_ACC)) {\n\t\tif (hdr->ct_reason == FC_FS_RJT_UNABL)\n\t\t\treturn -EAGAIN;  \n\t\treturn -EIO;\n\t}\n\n\tif (hdr->ct_mr_size) {\n\t\tdev_warn(&adapter->ccw_device->dev,\n\t\t\t \"The name server reported %d words residual data\\n\",\n\t\t\t hdr->ct_mr_size);\n\t\treturn -E2BIG;\n\t}\n\n\t \n\tfor (x = 1; x < max_entries && !last; x++) {\n\t\tif (x % (ZFCP_FC_GPN_FT_ENT_PAGE + 1))\n\t\t\tacc++;\n\t\telse\n\t\t\tacc = sg_virt(++sg);\n\n\t\tlast = acc->fp_flags & FC_NS_FID_LAST;\n\t\td_id = ntoh24(acc->fp_fid);\n\n\t\t \n\t\tif (d_id >= FC_FID_WELL_KNOWN_BASE)\n\t\t\tcontinue;\n\t\t \n\t\tif (be64_to_cpu(acc->fp_wwpn) ==\n\t\t    fc_host_port_name(adapter->scsi_host))\n\t\t\tcontinue;\n\n\t\tport = zfcp_port_enqueue(adapter, be64_to_cpu(acc->fp_wwpn),\n\t\t\t\t\t ZFCP_STATUS_COMMON_NOESC, d_id);\n\t\tif (!IS_ERR(port))\n\t\t\tzfcp_erp_port_reopen(port, 0, \"fcegpf1\");\n\t\telse if (PTR_ERR(port) != -EEXIST)\n\t\t\tret = PTR_ERR(port);\n\t}\n\n\tzfcp_erp_wait(adapter);\n\twrite_lock_irqsave(&adapter->port_list_lock, flags);\n\tlist_for_each_entry_safe(port, tmp, &adapter->port_list, list)\n\t\tzfcp_fc_validate_port(port, &remove_lh);\n\twrite_unlock_irqrestore(&adapter->port_list_lock, flags);\n\n\tlist_for_each_entry_safe(port, tmp, &remove_lh, list) {\n\t\tzfcp_erp_port_shutdown(port, 0, \"fcegpf2\");\n\t\tdevice_unregister(&port->dev);\n\t}\n\n\treturn ret;\n}\n\n \nvoid zfcp_fc_scan_ports(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct zfcp_adapter *adapter = container_of(dw, struct zfcp_adapter,\n\t\t\t\t\t\t    scan_work);\n\tint ret, i;\n\tstruct zfcp_fc_req *fc_req;\n\tint chain, max_entries, buf_num, max_bytes;\n\n\tzfcp_fc_port_scan_time(adapter);\n\n\tchain = adapter->adapter_features & FSF_FEATURE_ELS_CT_CHAINED_SBALS;\n\tbuf_num = chain ? ZFCP_FC_GPN_FT_NUM_BUFS : 1;\n\tmax_entries = chain ? ZFCP_FC_GPN_FT_MAX_ENT : ZFCP_FC_GPN_FT_ENT_PAGE;\n\tmax_bytes = chain ? ZFCP_FC_GPN_FT_MAX_SIZE : ZFCP_FC_CT_SIZE_PAGE;\n\n\tif (fc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPORT &&\n\t    fc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPIV)\n\t\treturn;\n\n\tif (zfcp_fc_wka_port_get(&adapter->gs->ds))\n\t\treturn;\n\n\tfc_req = zfcp_fc_alloc_sg_env(buf_num);\n\tif (!fc_req)\n\t\tgoto out;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = zfcp_fc_send_gpn_ft(fc_req, adapter, max_bytes);\n\t\tif (!ret) {\n\t\t\tret = zfcp_fc_eval_gpn_ft(fc_req, adapter, max_entries);\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tssleep(1);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tzfcp_fc_sg_free_table(&fc_req->sg_rsp, buf_num);\n\tkmem_cache_free(zfcp_fc_req_cache, fc_req);\nout:\n\tzfcp_fc_wka_port_put(&adapter->gs->ds);\n}\n\nstatic int zfcp_fc_gspn(struct zfcp_adapter *adapter,\n\t\t\tstruct zfcp_fc_req *fc_req)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tchar devno[] = \"DEVNO:\";\n\tstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\n\tstruct zfcp_fc_gspn_req *gspn_req = &fc_req->u.gspn.req;\n\tstruct zfcp_fc_gspn_rsp *gspn_rsp = &fc_req->u.gspn.rsp;\n\tint ret;\n\n\tzfcp_fc_ct_ns_init(&gspn_req->ct_hdr, FC_NS_GSPN_ID,\n\t\t\t   FC_SYMBOLIC_NAME_SIZE);\n\thton24(gspn_req->gspn.fp_fid, fc_host_port_id(adapter->scsi_host));\n\n\tsg_init_one(&fc_req->sg_req, gspn_req, sizeof(*gspn_req));\n\tsg_init_one(&fc_req->sg_rsp, gspn_rsp, sizeof(*gspn_rsp));\n\n\tct_els->handler = zfcp_fc_complete;\n\tct_els->handler_data = &completion;\n\tct_els->req = &fc_req->sg_req;\n\tct_els->resp = &fc_req->sg_rsp;\n\n\tret = zfcp_fsf_send_ct(&adapter->gs->ds, ct_els, NULL,\n\t\t\t       ZFCP_FC_CTELS_TMO);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&completion);\n\tif (ct_els->status)\n\t\treturn ct_els->status;\n\n\tif (fc_host_port_type(adapter->scsi_host) == FC_PORTTYPE_NPIV &&\n\t    !(strstr(gspn_rsp->gspn.fp_name, devno)))\n\t\tsnprintf(fc_host_symbolic_name(adapter->scsi_host),\n\t\t\t FC_SYMBOLIC_NAME_SIZE, \"%s%s %s NAME: %s\",\n\t\t\t gspn_rsp->gspn.fp_name, devno,\n\t\t\t dev_name(&adapter->ccw_device->dev),\n\t\t\t init_utsname()->nodename);\n\telse\n\t\tstrscpy(fc_host_symbolic_name(adapter->scsi_host),\n\t\t\tgspn_rsp->gspn.fp_name, FC_SYMBOLIC_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic void zfcp_fc_rspn(struct zfcp_adapter *adapter,\n\t\t\t struct zfcp_fc_req *fc_req)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct Scsi_Host *shost = adapter->scsi_host;\n\tstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\n\tstruct zfcp_fc_rspn_req *rspn_req = &fc_req->u.rspn.req;\n\tstruct fc_ct_hdr *rspn_rsp = &fc_req->u.rspn.rsp;\n\tint ret, len;\n\n\tzfcp_fc_ct_ns_init(&rspn_req->ct_hdr, FC_NS_RSPN_ID,\n\t\t\t   FC_SYMBOLIC_NAME_SIZE);\n\thton24(rspn_req->rspn.fr_fid.fp_fid, fc_host_port_id(shost));\n\tlen = strlcpy(rspn_req->rspn.fr_name, fc_host_symbolic_name(shost),\n\t\t      FC_SYMBOLIC_NAME_SIZE);\n\trspn_req->rspn.fr_name_len = len;\n\n\tsg_init_one(&fc_req->sg_req, rspn_req, sizeof(*rspn_req));\n\tsg_init_one(&fc_req->sg_rsp, rspn_rsp, sizeof(*rspn_rsp));\n\n\tct_els->handler = zfcp_fc_complete;\n\tct_els->handler_data = &completion;\n\tct_els->req = &fc_req->sg_req;\n\tct_els->resp = &fc_req->sg_rsp;\n\n\tret = zfcp_fsf_send_ct(&adapter->gs->ds, ct_els, NULL,\n\t\t\t       ZFCP_FC_CTELS_TMO);\n\tif (!ret)\n\t\twait_for_completion(&completion);\n}\n\n \nvoid zfcp_fc_sym_name_update(struct work_struct *work)\n{\n\tstruct zfcp_adapter *adapter = container_of(work, struct zfcp_adapter,\n\t\t\t\t\t\t    ns_up_work);\n\tint ret;\n\tstruct zfcp_fc_req *fc_req;\n\n\tif (fc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPORT &&\n\t    fc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPIV)\n\t\treturn;\n\n\tfc_req = kmem_cache_zalloc(zfcp_fc_req_cache, GFP_KERNEL);\n\tif (!fc_req)\n\t\treturn;\n\n\tret = zfcp_fc_wka_port_get(&adapter->gs->ds);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = zfcp_fc_gspn(adapter, fc_req);\n\tif (ret || fc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPIV)\n\t\tgoto out_ds_put;\n\n\tmemset(fc_req, 0, sizeof(*fc_req));\n\tzfcp_fc_rspn(adapter, fc_req);\n\nout_ds_put:\n\tzfcp_fc_wka_port_put(&adapter->gs->ds);\nout_free:\n\tkmem_cache_free(zfcp_fc_req_cache, fc_req);\n}\n\nstatic void zfcp_fc_ct_els_job_handler(void *data)\n{\n\tstruct bsg_job *job = data;\n\tstruct zfcp_fsf_ct_els *zfcp_ct_els = job->dd_data;\n\tstruct fc_bsg_reply *jr = job->reply;\n\n\tjr->reply_payload_rcv_len = job->reply_payload.payload_len;\n\tjr->reply_data.ctels_reply.status = FC_CTELS_STATUS_OK;\n\tjr->result = zfcp_ct_els->status ? -EIO : 0;\n\tbsg_job_done(job, jr->result, jr->reply_payload_rcv_len);\n}\n\nstatic struct zfcp_fc_wka_port *zfcp_fc_job_wka_port(struct bsg_job *job)\n{\n\tu32 preamble_word1;\n\tu8 gs_type;\n\tstruct zfcp_adapter *adapter;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_rport *rport = fc_bsg_to_rport(job);\n\tstruct Scsi_Host *shost;\n\n\tpreamble_word1 = bsg_request->rqst_data.r_ct.preamble_word1;\n\tgs_type = (preamble_word1 & 0xff000000) >> 24;\n\n\tshost = rport ? rport_to_shost(rport) : fc_bsg_to_shost(job);\n\tadapter = (struct zfcp_adapter *) shost->hostdata[0];\n\n\tswitch (gs_type) {\n\tcase FC_FST_ALIAS:\n\t\treturn &adapter->gs->as;\n\tcase FC_FST_MGMT:\n\t\treturn &adapter->gs->ms;\n\tcase FC_FST_TIME:\n\t\treturn &adapter->gs->ts;\n\t\tbreak;\n\tcase FC_FST_DIR:\n\t\treturn &adapter->gs->ds;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic void zfcp_fc_ct_job_handler(void *data)\n{\n\tstruct bsg_job *job = data;\n\tstruct zfcp_fc_wka_port *wka_port;\n\n\twka_port = zfcp_fc_job_wka_port(job);\n\tzfcp_fc_wka_port_put(wka_port);\n\n\tzfcp_fc_ct_els_job_handler(data);\n}\n\nstatic int zfcp_fc_exec_els_job(struct bsg_job *job,\n\t\t\t\tstruct zfcp_adapter *adapter)\n{\n\tstruct zfcp_fsf_ct_els *els = job->dd_data;\n\tstruct fc_rport *rport = fc_bsg_to_rport(job);\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct zfcp_port *port;\n\tu32 d_id;\n\n\tif (rport) {\n\t\tport = zfcp_get_port_by_wwpn(adapter, rport->port_name);\n\t\tif (!port)\n\t\t\treturn -EINVAL;\n\n\t\td_id = port->d_id;\n\t\tput_device(&port->dev);\n\t} else\n\t\td_id = ntoh24(bsg_request->rqst_data.h_els.port_id);\n\n\tels->handler = zfcp_fc_ct_els_job_handler;\n\treturn zfcp_fsf_send_els(adapter, d_id, els, job->timeout / HZ);\n}\n\nstatic int zfcp_fc_exec_ct_job(struct bsg_job *job,\n\t\t\t       struct zfcp_adapter *adapter)\n{\n\tint ret;\n\tstruct zfcp_fsf_ct_els *ct = job->dd_data;\n\tstruct zfcp_fc_wka_port *wka_port;\n\n\twka_port = zfcp_fc_job_wka_port(job);\n\tif (!wka_port)\n\t\treturn -EINVAL;\n\n\tret = zfcp_fc_wka_port_get(wka_port);\n\tif (ret)\n\t\treturn ret;\n\n\tct->handler = zfcp_fc_ct_job_handler;\n\tret = zfcp_fsf_send_ct(wka_port, ct, NULL, job->timeout / HZ);\n\tif (ret)\n\t\tzfcp_fc_wka_port_put(wka_port);\n\n\treturn ret;\n}\n\nint zfcp_fc_exec_bsg_job(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost;\n\tstruct zfcp_adapter *adapter;\n\tstruct zfcp_fsf_ct_els *ct_els = job->dd_data;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_rport *rport = fc_bsg_to_rport(job);\n\n\tshost = rport ? rport_to_shost(rport) : fc_bsg_to_shost(job);\n\tadapter = (struct zfcp_adapter *)shost->hostdata[0];\n\n\tif (!(atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_OPEN))\n\t\treturn -EINVAL;\n\n\tct_els->req = job->request_payload.sg_list;\n\tct_els->resp = job->reply_payload.sg_list;\n\tct_els->handler_data = job;\n\n\tswitch (bsg_request->msgcode) {\n\tcase FC_BSG_RPT_ELS:\n\tcase FC_BSG_HST_ELS_NOLOGIN:\n\t\treturn zfcp_fc_exec_els_job(job, adapter);\n\tcase FC_BSG_RPT_CT:\n\tcase FC_BSG_HST_CT:\n\t\treturn zfcp_fc_exec_ct_job(job, adapter);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint zfcp_fc_timeout_bsg_job(struct bsg_job *job)\n{\n\t \n\treturn -EAGAIN;\n}\n\nint zfcp_fc_gs_setup(struct zfcp_adapter *adapter)\n{\n\tstruct zfcp_fc_wka_ports *wka_ports;\n\n\twka_ports = kzalloc(sizeof(struct zfcp_fc_wka_ports), GFP_KERNEL);\n\tif (!wka_ports)\n\t\treturn -ENOMEM;\n\n\tadapter->gs = wka_ports;\n\tzfcp_fc_wka_port_init(&wka_ports->ms, FC_FID_MGMT_SERV, adapter);\n\tzfcp_fc_wka_port_init(&wka_ports->ts, FC_FID_TIME_SERV, adapter);\n\tzfcp_fc_wka_port_init(&wka_ports->ds, FC_FID_DIR_SERV, adapter);\n\tzfcp_fc_wka_port_init(&wka_ports->as, FC_FID_ALIASES, adapter);\n\n\treturn 0;\n}\n\nvoid zfcp_fc_gs_destroy(struct zfcp_adapter *adapter)\n{\n\tkfree(adapter->gs);\n\tadapter->gs = NULL;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}