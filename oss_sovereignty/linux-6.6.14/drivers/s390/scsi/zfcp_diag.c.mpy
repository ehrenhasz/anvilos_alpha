{
  "module_name": "zfcp_diag.c",
  "hash_id": "0d9f0802eb04b797b5ca287f777e83c3d4a90c44abff083787b1d9ffa6dae4ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/scsi/zfcp_diag.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n\n#include \"zfcp_diag.h\"\n#include \"zfcp_ext.h\"\n#include \"zfcp_def.h\"\n\nstatic DECLARE_WAIT_QUEUE_HEAD(__zfcp_diag_publish_wait);\n\n \nint zfcp_diag_adapter_setup(struct zfcp_adapter *const adapter)\n{\n\tstruct zfcp_diag_adapter *diag;\n\tstruct zfcp_diag_header *hdr;\n\n\tdiag = kzalloc(sizeof(*diag), GFP_KERNEL);\n\tif (diag == NULL)\n\t\treturn -ENOMEM;\n\n\tdiag->max_age = (5 * 1000);  \n\n\t \n\thdr = &diag->port_data.header;\n\n\tspin_lock_init(&hdr->access_lock);\n\thdr->buffer = &diag->port_data.data;\n\thdr->buffer_size = sizeof(diag->port_data.data);\n\t \n\thdr->timestamp = jiffies - msecs_to_jiffies(diag->max_age);\n\n\t \n\thdr = &diag->config_data.header;\n\n\tspin_lock_init(&hdr->access_lock);\n\thdr->buffer = &diag->config_data.data;\n\thdr->buffer_size = sizeof(diag->config_data.data);\n\t \n\thdr->timestamp = jiffies - msecs_to_jiffies(diag->max_age);\n\n\tadapter->diagnostics = diag;\n\treturn 0;\n}\n\n \nvoid zfcp_diag_adapter_free(struct zfcp_adapter *const adapter)\n{\n\tkfree(adapter->diagnostics);\n\tadapter->diagnostics = NULL;\n}\n\n \nvoid zfcp_diag_update_xdata(struct zfcp_diag_header *const hdr,\n\t\t\t    const void *const data, const bool incomplete)\n{\n\tconst unsigned long capture_timestamp = jiffies;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hdr->access_lock, flags);\n\n\t \n\tif (!time_after_eq(capture_timestamp, hdr->timestamp))\n\t\tgoto out;\n\n\thdr->timestamp = capture_timestamp;\n\thdr->incomplete = incomplete;\n\tmemcpy(hdr->buffer, data, hdr->buffer_size);\nout:\n\tspin_unlock_irqrestore(&hdr->access_lock, flags);\n}\n\n \nint zfcp_diag_update_port_data_buffer(struct zfcp_adapter *const adapter)\n{\n\tint rc;\n\n\trc = zfcp_fsf_exchange_port_data_sync(adapter->qdio, NULL);\n\tif (rc == -EAGAIN)\n\t\trc = 0;  \n\n\t \n\n\treturn rc;\n}\n\n \nint zfcp_diag_update_config_data_buffer(struct zfcp_adapter *const adapter)\n{\n\tint rc;\n\n\trc = zfcp_fsf_exchange_config_data_sync(adapter->qdio, NULL);\n\tif (rc == -EAGAIN)\n\t\trc = 0;  \n\n\t \n\n\treturn rc;\n}\n\nstatic int __zfcp_diag_update_buffer(struct zfcp_adapter *const adapter,\n\t\t\t\t     struct zfcp_diag_header *const hdr,\n\t\t\t\t     zfcp_diag_update_buffer_func buffer_update,\n\t\t\t\t     unsigned long *const flags)\n\t__must_hold(hdr->access_lock)\n{\n\tint rc;\n\n\tif (hdr->updating == 1) {\n\t\trc = wait_event_interruptible_lock_irq(__zfcp_diag_publish_wait,\n\t\t\t\t\t\t       hdr->updating == 0,\n\t\t\t\t\t\t       hdr->access_lock);\n\t\trc = (rc == 0 ? -EAGAIN : -EINTR);\n\t} else {\n\t\thdr->updating = 1;\n\t\tspin_unlock_irqrestore(&hdr->access_lock, *flags);\n\n\t\t \n\t\trc = buffer_update(adapter);\n\n\t\tspin_lock_irqsave(&hdr->access_lock, *flags);\n\t\thdr->updating = 0;\n\n\t\t \n\t\twake_up_interruptible_all(&__zfcp_diag_publish_wait);\n\t}\n\n\treturn rc;\n}\n\nstatic bool\n__zfcp_diag_test_buffer_age_isfresh(const struct zfcp_diag_adapter *const diag,\n\t\t\t\t    const struct zfcp_diag_header *const hdr)\n\t__must_hold(hdr->access_lock)\n{\n\tconst unsigned long now = jiffies;\n\n\t \n\tif (!time_after_eq(now, hdr->timestamp))\n\t\treturn false;\n\n\tif (jiffies_to_msecs(now - hdr->timestamp) >= diag->max_age)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint zfcp_diag_update_buffer_limited(struct zfcp_adapter *const adapter,\n\t\t\t\t    struct zfcp_diag_header *const hdr,\n\t\t\t\t    zfcp_diag_update_buffer_func buffer_update)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&hdr->access_lock, flags);\n\n\tfor (rc = 0;\n\t     !__zfcp_diag_test_buffer_age_isfresh(adapter->diagnostics, hdr);\n\t     rc = 0) {\n\t\trc = __zfcp_diag_update_buffer(adapter, hdr, buffer_update,\n\t\t\t\t\t       &flags);\n\t\tif (rc != -EAGAIN)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&hdr->access_lock, flags);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}