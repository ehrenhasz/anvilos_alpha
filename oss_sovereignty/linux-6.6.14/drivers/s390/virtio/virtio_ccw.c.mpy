{
  "module_name": "virtio_ccw.c",
  "hash_id": "947666aab197f0c6a97dcc19da1710953e714334a99f6e0aba66dfd296163710",
  "original_prompt": "Ingested from linux-6.6.14/drivers/s390/virtio/virtio_ccw.c",
  "human_readable_source": "\n \n\n#include <linux/kernel_stat.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n#include <linux/err.h>\n#include <linux/virtio.h>\n#include <linux/virtio_config.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/virtio_ring.h>\n#include <linux/pfn.h>\n#include <linux/async.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/moduleparam.h>\n#include <linux/io.h>\n#include <linux/kvm_para.h>\n#include <linux/notifier.h>\n#include <asm/diag.h>\n#include <asm/setup.h>\n#include <asm/irq.h>\n#include <asm/cio.h>\n#include <asm/ccwdev.h>\n#include <asm/virtio-ccw.h>\n#include <asm/isc.h>\n#include <asm/airq.h>\n#include <asm/tpi.h>\n\n \n\nstruct vq_config_block {\n\t__u16 index;\n\t__u16 num;\n} __packed;\n\n#define VIRTIO_CCW_CONFIG_SIZE 0x100\n \n\nstruct vcdev_dma_area {\n\tunsigned long indicators;\n\tunsigned long indicators2;\n\tstruct vq_config_block config_block;\n\t__u8 status;\n};\n\nstruct virtio_ccw_device {\n\tstruct virtio_device vdev;\n\t__u8 config[VIRTIO_CCW_CONFIG_SIZE];\n\tstruct ccw_device *cdev;\n\t__u32 curr_io;\n\tint err;\n\tunsigned int revision;  \n\twait_queue_head_t wait_q;\n\tspinlock_t lock;\n\trwlock_t irq_lock;\n\tstruct mutex io_lock;  \n\tstruct list_head virtqueues;\n\tbool is_thinint;\n\tbool going_away;\n\tbool device_lost;\n\tunsigned int config_ready;\n\tvoid *airq_info;\n\tstruct vcdev_dma_area *dma_area;\n};\n\nstatic inline unsigned long *indicators(struct virtio_ccw_device *vcdev)\n{\n\treturn &vcdev->dma_area->indicators;\n}\n\nstatic inline unsigned long *indicators2(struct virtio_ccw_device *vcdev)\n{\n\treturn &vcdev->dma_area->indicators2;\n}\n\nstruct vq_info_block_legacy {\n\t__u64 queue;\n\t__u32 align;\n\t__u16 index;\n\t__u16 num;\n} __packed;\n\nstruct vq_info_block {\n\t__u64 desc;\n\t__u32 res0;\n\t__u16 index;\n\t__u16 num;\n\t__u64 avail;\n\t__u64 used;\n} __packed;\n\nstruct virtio_feature_desc {\n\t__le32 features;\n\t__u8 index;\n} __packed;\n\nstruct virtio_thinint_area {\n\tunsigned long summary_indicator;\n\tunsigned long indicator;\n\tu64 bit_nr;\n\tu8 isc;\n} __packed;\n\nstruct virtio_rev_info {\n\t__u16 revision;\n\t__u16 length;\n\t__u8 data[];\n};\n\n \n#define VIRTIO_CCW_REV_MAX 2\n\nstruct virtio_ccw_vq_info {\n\tstruct virtqueue *vq;\n\tint num;\n\tunion {\n\t\tstruct vq_info_block s;\n\t\tstruct vq_info_block_legacy l;\n\t} *info_block;\n\tint bit_nr;\n\tstruct list_head node;\n\tlong cookie;\n};\n\n#define VIRTIO_AIRQ_ISC IO_SCH_ISC  \n\n#define VIRTIO_IV_BITS (L1_CACHE_BYTES * 8)\n#define MAX_AIRQ_AREAS 20\n\nstatic int virtio_ccw_use_airq = 1;\n\nstruct airq_info {\n\trwlock_t lock;\n\tu8 summary_indicator_idx;\n\tstruct airq_struct airq;\n\tstruct airq_iv *aiv;\n};\nstatic struct airq_info *airq_areas[MAX_AIRQ_AREAS];\nstatic DEFINE_MUTEX(airq_areas_lock);\n\nstatic u8 *summary_indicators;\n\nstatic inline u8 *get_summary_indicator(struct airq_info *info)\n{\n\treturn summary_indicators + info->summary_indicator_idx;\n}\n\n#define CCW_CMD_SET_VQ 0x13\n#define CCW_CMD_VDEV_RESET 0x33\n#define CCW_CMD_SET_IND 0x43\n#define CCW_CMD_SET_CONF_IND 0x53\n#define CCW_CMD_READ_FEAT 0x12\n#define CCW_CMD_WRITE_FEAT 0x11\n#define CCW_CMD_READ_CONF 0x22\n#define CCW_CMD_WRITE_CONF 0x21\n#define CCW_CMD_WRITE_STATUS 0x31\n#define CCW_CMD_READ_VQ_CONF 0x32\n#define CCW_CMD_READ_STATUS 0x72\n#define CCW_CMD_SET_IND_ADAPTER 0x73\n#define CCW_CMD_SET_VIRTIO_REV 0x83\n\n#define VIRTIO_CCW_DOING_SET_VQ 0x00010000\n#define VIRTIO_CCW_DOING_RESET 0x00040000\n#define VIRTIO_CCW_DOING_READ_FEAT 0x00080000\n#define VIRTIO_CCW_DOING_WRITE_FEAT 0x00100000\n#define VIRTIO_CCW_DOING_READ_CONFIG 0x00200000\n#define VIRTIO_CCW_DOING_WRITE_CONFIG 0x00400000\n#define VIRTIO_CCW_DOING_WRITE_STATUS 0x00800000\n#define VIRTIO_CCW_DOING_SET_IND 0x01000000\n#define VIRTIO_CCW_DOING_READ_VQ_CONF 0x02000000\n#define VIRTIO_CCW_DOING_SET_CONF_IND 0x04000000\n#define VIRTIO_CCW_DOING_SET_IND_ADAPTER 0x08000000\n#define VIRTIO_CCW_DOING_SET_VIRTIO_REV 0x10000000\n#define VIRTIO_CCW_DOING_READ_STATUS 0x20000000\n#define VIRTIO_CCW_INTPARM_MASK 0xffff0000\n\nstatic struct virtio_ccw_device *to_vc_device(struct virtio_device *vdev)\n{\n\treturn container_of(vdev, struct virtio_ccw_device, vdev);\n}\n\nstatic void drop_airq_indicator(struct virtqueue *vq, struct airq_info *info)\n{\n\tunsigned long i, flags;\n\n\twrite_lock_irqsave(&info->lock, flags);\n\tfor (i = 0; i < airq_iv_end(info->aiv); i++) {\n\t\tif (vq == (void *)airq_iv_get_ptr(info->aiv, i)) {\n\t\t\tairq_iv_free_bit(info->aiv, i);\n\t\t\tairq_iv_set_ptr(info->aiv, i, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\twrite_unlock_irqrestore(&info->lock, flags);\n}\n\nstatic void virtio_airq_handler(struct airq_struct *airq,\n\t\t\t\tstruct tpi_info *tpi_info)\n{\n\tstruct airq_info *info = container_of(airq, struct airq_info, airq);\n\tunsigned long ai;\n\n\tinc_irq_stat(IRQIO_VAI);\n\tread_lock(&info->lock);\n\t \n\tfor (ai = 0;;) {\n\t\tai = airq_iv_scan(info->aiv, ai, airq_iv_end(info->aiv));\n\t\tif (ai == -1UL)\n\t\t\tbreak;\n\t\tvring_interrupt(0, (void *)airq_iv_get_ptr(info->aiv, ai));\n\t}\n\t*(get_summary_indicator(info)) = 0;\n\tsmp_wmb();\n\t \n\tfor (ai = 0;;) {\n\t\tai = airq_iv_scan(info->aiv, ai, airq_iv_end(info->aiv));\n\t\tif (ai == -1UL)\n\t\t\tbreak;\n\t\tvring_interrupt(0, (void *)airq_iv_get_ptr(info->aiv, ai));\n\t}\n\tread_unlock(&info->lock);\n}\n\nstatic struct airq_info *new_airq_info(int index)\n{\n\tstruct airq_info *info;\n\tint rc;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn NULL;\n\trwlock_init(&info->lock);\n\tinfo->aiv = airq_iv_create(VIRTIO_IV_BITS, AIRQ_IV_ALLOC | AIRQ_IV_PTR\n\t\t\t\t   | AIRQ_IV_CACHELINE, NULL);\n\tif (!info->aiv) {\n\t\tkfree(info);\n\t\treturn NULL;\n\t}\n\tinfo->airq.handler = virtio_airq_handler;\n\tinfo->summary_indicator_idx = index;\n\tinfo->airq.lsi_ptr = get_summary_indicator(info);\n\tinfo->airq.isc = VIRTIO_AIRQ_ISC;\n\trc = register_adapter_interrupt(&info->airq);\n\tif (rc) {\n\t\tairq_iv_release(info->aiv);\n\t\tkfree(info);\n\t\treturn NULL;\n\t}\n\treturn info;\n}\n\nstatic unsigned long get_airq_indicator(struct virtqueue *vqs[], int nvqs,\n\t\t\t\t\tu64 *first, void **airq_info)\n{\n\tint i, j;\n\tstruct airq_info *info;\n\tunsigned long indicator_addr = 0;\n\tunsigned long bit, flags;\n\n\tfor (i = 0; i < MAX_AIRQ_AREAS && !indicator_addr; i++) {\n\t\tmutex_lock(&airq_areas_lock);\n\t\tif (!airq_areas[i])\n\t\t\tairq_areas[i] = new_airq_info(i);\n\t\tinfo = airq_areas[i];\n\t\tmutex_unlock(&airq_areas_lock);\n\t\tif (!info)\n\t\t\treturn 0;\n\t\twrite_lock_irqsave(&info->lock, flags);\n\t\tbit = airq_iv_alloc(info->aiv, nvqs);\n\t\tif (bit == -1UL) {\n\t\t\t \n\t\t\twrite_unlock_irqrestore(&info->lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\t*first = bit;\n\t\t*airq_info = info;\n\t\tindicator_addr = (unsigned long)info->aiv->vector;\n\t\tfor (j = 0; j < nvqs; j++) {\n\t\t\tairq_iv_set_ptr(info->aiv, bit + j,\n\t\t\t\t\t(unsigned long)vqs[j]);\n\t\t}\n\t\twrite_unlock_irqrestore(&info->lock, flags);\n\t}\n\treturn indicator_addr;\n}\n\nstatic void virtio_ccw_drop_indicators(struct virtio_ccw_device *vcdev)\n{\n\tstruct virtio_ccw_vq_info *info;\n\n\tif (!vcdev->airq_info)\n\t\treturn;\n\tlist_for_each_entry(info, &vcdev->virtqueues, node)\n\t\tdrop_airq_indicator(info->vq, vcdev->airq_info);\n}\n\nstatic int doing_io(struct virtio_ccw_device *vcdev, __u32 flag)\n{\n\tunsigned long flags;\n\t__u32 ret;\n\n\tspin_lock_irqsave(get_ccwdev_lock(vcdev->cdev), flags);\n\tif (vcdev->err)\n\t\tret = 0;\n\telse\n\t\tret = vcdev->curr_io & flag;\n\tspin_unlock_irqrestore(get_ccwdev_lock(vcdev->cdev), flags);\n\treturn ret;\n}\n\nstatic int ccw_io_helper(struct virtio_ccw_device *vcdev,\n\t\t\t struct ccw1 *ccw, __u32 intparm)\n{\n\tint ret;\n\tunsigned long flags;\n\tint flag = intparm & VIRTIO_CCW_INTPARM_MASK;\n\n\tmutex_lock(&vcdev->io_lock);\n\tdo {\n\t\tspin_lock_irqsave(get_ccwdev_lock(vcdev->cdev), flags);\n\t\tret = ccw_device_start(vcdev->cdev, ccw, intparm, 0, 0);\n\t\tif (!ret) {\n\t\t\tif (!vcdev->curr_io)\n\t\t\t\tvcdev->err = 0;\n\t\t\tvcdev->curr_io |= flag;\n\t\t}\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(vcdev->cdev), flags);\n\t\tcpu_relax();\n\t} while (ret == -EBUSY);\n\twait_event(vcdev->wait_q, doing_io(vcdev, flag) == 0);\n\tret = ret ? ret : vcdev->err;\n\tmutex_unlock(&vcdev->io_lock);\n\treturn ret;\n}\n\nstatic void virtio_ccw_drop_indicator(struct virtio_ccw_device *vcdev,\n\t\t\t\t      struct ccw1 *ccw)\n{\n\tint ret;\n\tunsigned long *indicatorp = NULL;\n\tstruct virtio_thinint_area *thinint_area = NULL;\n\tstruct airq_info *airq_info = vcdev->airq_info;\n\n\tif (vcdev->is_thinint) {\n\t\tthinint_area = ccw_device_dma_zalloc(vcdev->cdev,\n\t\t\t\t\t\t     sizeof(*thinint_area));\n\t\tif (!thinint_area)\n\t\t\treturn;\n\t\tthinint_area->summary_indicator =\n\t\t\t(unsigned long) get_summary_indicator(airq_info);\n\t\tthinint_area->isc = VIRTIO_AIRQ_ISC;\n\t\tccw->cmd_code = CCW_CMD_SET_IND_ADAPTER;\n\t\tccw->count = sizeof(*thinint_area);\n\t\tccw->cda = (__u32)virt_to_phys(thinint_area);\n\t} else {\n\t\t \n\t\tindicatorp = ccw_device_dma_zalloc(vcdev->cdev,\n\t\t\t\t\t\t   sizeof(indicators(vcdev)));\n\t\tif (!indicatorp)\n\t\t\treturn;\n\t\t*indicatorp = 0;\n\t\tccw->cmd_code = CCW_CMD_SET_IND;\n\t\tccw->count = sizeof(indicators(vcdev));\n\t\tccw->cda = (__u32)virt_to_phys(indicatorp);\n\t}\n\t \n\t*indicators(vcdev) = 0;\n\tccw->flags = 0;\n\tret = ccw_io_helper(vcdev, ccw,\n\t\t\t    vcdev->is_thinint ?\n\t\t\t    VIRTIO_CCW_DOING_SET_IND_ADAPTER :\n\t\t\t    VIRTIO_CCW_DOING_SET_IND);\n\tif (ret && (ret != -ENODEV))\n\t\tdev_info(&vcdev->cdev->dev,\n\t\t\t \"Failed to deregister indicators (%d)\\n\", ret);\n\telse if (vcdev->is_thinint)\n\t\tvirtio_ccw_drop_indicators(vcdev);\n\tccw_device_dma_free(vcdev->cdev, indicatorp, sizeof(indicators(vcdev)));\n\tccw_device_dma_free(vcdev->cdev, thinint_area, sizeof(*thinint_area));\n}\n\nstatic inline bool virtio_ccw_do_kvm_notify(struct virtqueue *vq, u32 data)\n{\n\tstruct virtio_ccw_vq_info *info = vq->priv;\n\tstruct virtio_ccw_device *vcdev;\n\tstruct subchannel_id schid;\n\n\tvcdev = to_vc_device(info->vq->vdev);\n\tccw_device_get_schid(vcdev->cdev, &schid);\n\tBUILD_BUG_ON(sizeof(struct subchannel_id) != sizeof(unsigned int));\n\tinfo->cookie = kvm_hypercall3(KVM_S390_VIRTIO_CCW_NOTIFY,\n\t\t\t\t      *((unsigned int *)&schid),\n\t\t\t\t      data, info->cookie);\n\tif (info->cookie < 0)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool virtio_ccw_kvm_notify(struct virtqueue *vq)\n{\n\treturn virtio_ccw_do_kvm_notify(vq, vq->index);\n}\n\nstatic bool virtio_ccw_kvm_notify_with_data(struct virtqueue *vq)\n{\n\treturn virtio_ccw_do_kvm_notify(vq, vring_notification_data(vq));\n}\n\nstatic int virtio_ccw_read_vq_conf(struct virtio_ccw_device *vcdev,\n\t\t\t\t   struct ccw1 *ccw, int index)\n{\n\tint ret;\n\n\tvcdev->dma_area->config_block.index = index;\n\tccw->cmd_code = CCW_CMD_READ_VQ_CONF;\n\tccw->flags = 0;\n\tccw->count = sizeof(struct vq_config_block);\n\tccw->cda = (__u32)virt_to_phys(&vcdev->dma_area->config_block);\n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_VQ_CONF);\n\tif (ret)\n\t\treturn ret;\n\treturn vcdev->dma_area->config_block.num ?: -ENOENT;\n}\n\nstatic void virtio_ccw_del_vq(struct virtqueue *vq, struct ccw1 *ccw)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vq->vdev);\n\tstruct virtio_ccw_vq_info *info = vq->priv;\n\tunsigned long flags;\n\tint ret;\n\tunsigned int index = vq->index;\n\n\t \n\tspin_lock_irqsave(&vcdev->lock, flags);\n\tlist_del(&info->node);\n\tspin_unlock_irqrestore(&vcdev->lock, flags);\n\n\t \n\tif (vcdev->revision == 0) {\n\t\tinfo->info_block->l.queue = 0;\n\t\tinfo->info_block->l.align = 0;\n\t\tinfo->info_block->l.index = index;\n\t\tinfo->info_block->l.num = 0;\n\t\tccw->count = sizeof(info->info_block->l);\n\t} else {\n\t\tinfo->info_block->s.desc = 0;\n\t\tinfo->info_block->s.index = index;\n\t\tinfo->info_block->s.num = 0;\n\t\tinfo->info_block->s.avail = 0;\n\t\tinfo->info_block->s.used = 0;\n\t\tccw->count = sizeof(info->info_block->s);\n\t}\n\tccw->cmd_code = CCW_CMD_SET_VQ;\n\tccw->flags = 0;\n\tccw->cda = (__u32)virt_to_phys(info->info_block);\n\tret = ccw_io_helper(vcdev, ccw,\n\t\t\t    VIRTIO_CCW_DOING_SET_VQ | index);\n\t \n\tif (ret && (ret != -ENODEV))\n\t\tdev_warn(&vq->vdev->dev, \"Error %d while deleting queue %d\\n\",\n\t\t\t ret, index);\n\n\tvring_del_virtqueue(vq);\n\tccw_device_dma_free(vcdev->cdev, info->info_block,\n\t\t\t    sizeof(*info->info_block));\n\tkfree(info);\n}\n\nstatic void virtio_ccw_del_vqs(struct virtio_device *vdev)\n{\n\tstruct virtqueue *vq, *n;\n\tstruct ccw1 *ccw;\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn;\n\n\tvirtio_ccw_drop_indicator(vcdev, ccw);\n\n\tlist_for_each_entry_safe(vq, n, &vdev->vqs, list)\n\t\tvirtio_ccw_del_vq(vq, ccw);\n\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n}\n\nstatic struct virtqueue *virtio_ccw_setup_vq(struct virtio_device *vdev,\n\t\t\t\t\t     int i, vq_callback_t *callback,\n\t\t\t\t\t     const char *name, bool ctx,\n\t\t\t\t\t     struct ccw1 *ccw)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tbool (*notify)(struct virtqueue *vq);\n\tint err;\n\tstruct virtqueue *vq = NULL;\n\tstruct virtio_ccw_vq_info *info;\n\tu64 queue;\n\tunsigned long flags;\n\tbool may_reduce;\n\n\tif (__virtio_test_bit(vdev, VIRTIO_F_NOTIFICATION_DATA))\n\t\tnotify = virtio_ccw_kvm_notify_with_data;\n\telse\n\t\tnotify = virtio_ccw_kvm_notify;\n\n\t \n\tinfo = kzalloc(sizeof(struct virtio_ccw_vq_info), GFP_KERNEL);\n\tif (!info) {\n\t\tdev_warn(&vcdev->cdev->dev, \"no info\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tinfo->info_block = ccw_device_dma_zalloc(vcdev->cdev,\n\t\t\t\t\t\t sizeof(*info->info_block));\n\tif (!info->info_block) {\n\t\tdev_warn(&vcdev->cdev->dev, \"no info block\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tinfo->num = virtio_ccw_read_vq_conf(vcdev, ccw, i);\n\tif (info->num < 0) {\n\t\terr = info->num;\n\t\tgoto out_err;\n\t}\n\tmay_reduce = vcdev->revision > 0;\n\tvq = vring_create_virtqueue(i, info->num, KVM_VIRTIO_CCW_RING_ALIGN,\n\t\t\t\t    vdev, true, may_reduce, ctx,\n\t\t\t\t    notify, callback, name);\n\n\tif (!vq) {\n\t\t \n\t\tdev_warn(&vcdev->cdev->dev, \"no vq\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tvq->num_max = info->num;\n\n\t \n\tinfo->num = virtqueue_get_vring_size(vq);\n\n\t \n\tqueue = virtqueue_get_desc_addr(vq);\n\tif (vcdev->revision == 0) {\n\t\tinfo->info_block->l.queue = queue;\n\t\tinfo->info_block->l.align = KVM_VIRTIO_CCW_RING_ALIGN;\n\t\tinfo->info_block->l.index = i;\n\t\tinfo->info_block->l.num = info->num;\n\t\tccw->count = sizeof(info->info_block->l);\n\t} else {\n\t\tinfo->info_block->s.desc = queue;\n\t\tinfo->info_block->s.index = i;\n\t\tinfo->info_block->s.num = info->num;\n\t\tinfo->info_block->s.avail = (__u64)virtqueue_get_avail_addr(vq);\n\t\tinfo->info_block->s.used = (__u64)virtqueue_get_used_addr(vq);\n\t\tccw->count = sizeof(info->info_block->s);\n\t}\n\tccw->cmd_code = CCW_CMD_SET_VQ;\n\tccw->flags = 0;\n\tccw->cda = (__u32)virt_to_phys(info->info_block);\n\terr = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_SET_VQ | i);\n\tif (err) {\n\t\tdev_warn(&vcdev->cdev->dev, \"SET_VQ failed\\n\");\n\t\tgoto out_err;\n\t}\n\n\tinfo->vq = vq;\n\tvq->priv = info;\n\n\t \n\tspin_lock_irqsave(&vcdev->lock, flags);\n\tlist_add(&info->node, &vcdev->virtqueues);\n\tspin_unlock_irqrestore(&vcdev->lock, flags);\n\n\treturn vq;\n\nout_err:\n\tif (vq)\n\t\tvring_del_virtqueue(vq);\n\tif (info) {\n\t\tccw_device_dma_free(vcdev->cdev, info->info_block,\n\t\t\t\t    sizeof(*info->info_block));\n\t}\n\tkfree(info);\n\treturn ERR_PTR(err);\n}\n\nstatic int virtio_ccw_register_adapter_ind(struct virtio_ccw_device *vcdev,\n\t\t\t\t\t   struct virtqueue *vqs[], int nvqs,\n\t\t\t\t\t   struct ccw1 *ccw)\n{\n\tint ret;\n\tstruct virtio_thinint_area *thinint_area = NULL;\n\tunsigned long indicator_addr;\n\tstruct airq_info *info;\n\n\tthinint_area = ccw_device_dma_zalloc(vcdev->cdev,\n\t\t\t\t\t     sizeof(*thinint_area));\n\tif (!thinint_area) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t \n\tindicator_addr = get_airq_indicator(vqs, nvqs,\n\t\t\t\t\t    &thinint_area->bit_nr,\n\t\t\t\t\t    &vcdev->airq_info);\n\tif (!indicator_addr) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\tthinint_area->indicator = virt_to_phys((void *)indicator_addr);\n\tinfo = vcdev->airq_info;\n\tthinint_area->summary_indicator =\n\t\tvirt_to_phys(get_summary_indicator(info));\n\tthinint_area->isc = VIRTIO_AIRQ_ISC;\n\tccw->cmd_code = CCW_CMD_SET_IND_ADAPTER;\n\tccw->flags = CCW_FLAG_SLI;\n\tccw->count = sizeof(*thinint_area);\n\tccw->cda = (__u32)virt_to_phys(thinint_area);\n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_SET_IND_ADAPTER);\n\tif (ret) {\n\t\tif (ret == -EOPNOTSUPP) {\n\t\t\t \n\t\t\tvirtio_ccw_use_airq = 0;\n\t\t\tpr_info(\"Adapter interrupts unsupported on host\\n\");\n\t\t} else\n\t\t\tdev_warn(&vcdev->cdev->dev,\n\t\t\t\t \"enabling adapter interrupts = %d\\n\", ret);\n\t\tvirtio_ccw_drop_indicators(vcdev);\n\t}\nout:\n\tccw_device_dma_free(vcdev->cdev, thinint_area, sizeof(*thinint_area));\n\treturn ret;\n}\n\nstatic int virtio_ccw_find_vqs(struct virtio_device *vdev, unsigned nvqs,\n\t\t\t       struct virtqueue *vqs[],\n\t\t\t       vq_callback_t *callbacks[],\n\t\t\t       const char * const names[],\n\t\t\t       const bool *ctx,\n\t\t\t       struct irq_affinity *desc)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tunsigned long *indicatorp = NULL;\n\tint ret, i, queue_idx = 0;\n\tstruct ccw1 *ccw;\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nvqs; ++i) {\n\t\tif (!names[i]) {\n\t\t\tvqs[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvqs[i] = virtio_ccw_setup_vq(vdev, queue_idx++, callbacks[i],\n\t\t\t\t\t     names[i], ctx ? ctx[i] : false,\n\t\t\t\t\t     ccw);\n\t\tif (IS_ERR(vqs[i])) {\n\t\t\tret = PTR_ERR(vqs[i]);\n\t\t\tvqs[i] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = -ENOMEM;\n\t \n\tindicatorp = ccw_device_dma_zalloc(vcdev->cdev,\n\t\t\t\t\t   sizeof(indicators(vcdev)));\n\tif (!indicatorp)\n\t\tgoto out;\n\t*indicatorp = (unsigned long) indicators(vcdev);\n\tif (vcdev->is_thinint) {\n\t\tret = virtio_ccw_register_adapter_ind(vcdev, vqs, nvqs, ccw);\n\t\tif (ret)\n\t\t\t \n\t\t\tvcdev->is_thinint = false;\n\t}\n\tif (!vcdev->is_thinint) {\n\t\t \n\t\t*indicators(vcdev) = 0;\n\t\tccw->cmd_code = CCW_CMD_SET_IND;\n\t\tccw->flags = 0;\n\t\tccw->count = sizeof(indicators(vcdev));\n\t\tccw->cda = (__u32)virt_to_phys(indicatorp);\n\t\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_SET_IND);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t \n\t*indicatorp = (unsigned long) indicators2(vcdev);\n\t*indicators2(vcdev) = 0;\n\tccw->cmd_code = CCW_CMD_SET_CONF_IND;\n\tccw->flags = 0;\n\tccw->count = sizeof(indicators2(vcdev));\n\tccw->cda = (__u32)virt_to_phys(indicatorp);\n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_SET_CONF_IND);\n\tif (ret)\n\t\tgoto out;\n\n\tif (indicatorp)\n\t\tccw_device_dma_free(vcdev->cdev, indicatorp,\n\t\t\t\t    sizeof(indicators(vcdev)));\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n\treturn 0;\nout:\n\tif (indicatorp)\n\t\tccw_device_dma_free(vcdev->cdev, indicatorp,\n\t\t\t\t    sizeof(indicators(vcdev)));\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n\tvirtio_ccw_del_vqs(vdev);\n\treturn ret;\n}\n\nstatic void virtio_ccw_reset(struct virtio_device *vdev)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tstruct ccw1 *ccw;\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn;\n\n\t \n\tvcdev->dma_area->status = 0;\n\n\t \n\tccw->cmd_code = CCW_CMD_VDEV_RESET;\n\tccw->flags = 0;\n\tccw->count = 0;\n\tccw->cda = 0;\n\tccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_RESET);\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n}\n\nstatic u64 virtio_ccw_get_features(struct virtio_device *vdev)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tstruct virtio_feature_desc *features;\n\tint ret;\n\tu64 rc;\n\tstruct ccw1 *ccw;\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn 0;\n\n\tfeatures = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*features));\n\tif (!features) {\n\t\trc = 0;\n\t\tgoto out_free;\n\t}\n\t \n\tfeatures->index = 0;\n\tccw->cmd_code = CCW_CMD_READ_FEAT;\n\tccw->flags = 0;\n\tccw->count = sizeof(*features);\n\tccw->cda = (__u32)virt_to_phys(features);\n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_FEAT);\n\tif (ret) {\n\t\trc = 0;\n\t\tgoto out_free;\n\t}\n\n\trc = le32_to_cpu(features->features);\n\n\tif (vcdev->revision == 0)\n\t\tgoto out_free;\n\n\t \n\tfeatures->index = 1;\n\tccw->cmd_code = CCW_CMD_READ_FEAT;\n\tccw->flags = 0;\n\tccw->count = sizeof(*features);\n\tccw->cda = (__u32)virt_to_phys(features);\n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_FEAT);\n\tif (ret == 0)\n\t\trc |= (u64)le32_to_cpu(features->features) << 32;\n\nout_free:\n\tccw_device_dma_free(vcdev->cdev, features, sizeof(*features));\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n\treturn rc;\n}\n\nstatic void ccw_transport_features(struct virtio_device *vdev)\n{\n\t \n}\n\nstatic int virtio_ccw_finalize_features(struct virtio_device *vdev)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tstruct virtio_feature_desc *features;\n\tstruct ccw1 *ccw;\n\tint ret;\n\n\tif (vcdev->revision >= 1 &&\n\t    !__virtio_test_bit(vdev, VIRTIO_F_VERSION_1)) {\n\t\tdev_err(&vdev->dev, \"virtio: device uses revision 1 \"\n\t\t\t\"but does not have VIRTIO_F_VERSION_1\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn -ENOMEM;\n\n\tfeatures = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*features));\n\tif (!features) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\t \n\tvring_transport_features(vdev);\n\n\t \n\tccw_transport_features(vdev);\n\n\tfeatures->index = 0;\n\tfeatures->features = cpu_to_le32((u32)vdev->features);\n\t \n\tccw->cmd_code = CCW_CMD_WRITE_FEAT;\n\tccw->flags = 0;\n\tccw->count = sizeof(*features);\n\tccw->cda = (__u32)virt_to_phys(features);\n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (vcdev->revision == 0)\n\t\tgoto out_free;\n\n\tfeatures->index = 1;\n\tfeatures->features = cpu_to_le32(vdev->features >> 32);\n\t \n\tccw->cmd_code = CCW_CMD_WRITE_FEAT;\n\tccw->flags = 0;\n\tccw->count = sizeof(*features);\n\tccw->cda = (__u32)virt_to_phys(features);\n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_FEAT);\n\nout_free:\n\tccw_device_dma_free(vcdev->cdev, features, sizeof(*features));\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n\n\treturn ret;\n}\n\nstatic void virtio_ccw_get_config(struct virtio_device *vdev,\n\t\t\t\t  unsigned int offset, void *buf, unsigned len)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tint ret;\n\tstruct ccw1 *ccw;\n\tvoid *config_area;\n\tunsigned long flags;\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn;\n\n\tconfig_area = ccw_device_dma_zalloc(vcdev->cdev,\n\t\t\t\t\t    VIRTIO_CCW_CONFIG_SIZE);\n\tif (!config_area)\n\t\tgoto out_free;\n\n\t \n\tccw->cmd_code = CCW_CMD_READ_CONF;\n\tccw->flags = 0;\n\tccw->count = offset + len;\n\tccw->cda = (__u32)virt_to_phys(config_area);\n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_CONFIG);\n\tif (ret)\n\t\tgoto out_free;\n\n\tspin_lock_irqsave(&vcdev->lock, flags);\n\tmemcpy(vcdev->config, config_area, offset + len);\n\tif (vcdev->config_ready < offset + len)\n\t\tvcdev->config_ready = offset + len;\n\tspin_unlock_irqrestore(&vcdev->lock, flags);\n\tif (buf)\n\t\tmemcpy(buf, config_area + offset, len);\n\nout_free:\n\tccw_device_dma_free(vcdev->cdev, config_area, VIRTIO_CCW_CONFIG_SIZE);\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n}\n\nstatic void virtio_ccw_set_config(struct virtio_device *vdev,\n\t\t\t\t  unsigned int offset, const void *buf,\n\t\t\t\t  unsigned len)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tstruct ccw1 *ccw;\n\tvoid *config_area;\n\tunsigned long flags;\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn;\n\n\tconfig_area = ccw_device_dma_zalloc(vcdev->cdev,\n\t\t\t\t\t    VIRTIO_CCW_CONFIG_SIZE);\n\tif (!config_area)\n\t\tgoto out_free;\n\n\t \n\tif (vcdev->config_ready < offset)\n\t\tvirtio_ccw_get_config(vdev, 0, NULL, offset);\n\tspin_lock_irqsave(&vcdev->lock, flags);\n\tmemcpy(&vcdev->config[offset], buf, len);\n\t \n\tmemcpy(config_area, vcdev->config, sizeof(vcdev->config));\n\tspin_unlock_irqrestore(&vcdev->lock, flags);\n\tccw->cmd_code = CCW_CMD_WRITE_CONF;\n\tccw->flags = 0;\n\tccw->count = offset + len;\n\tccw->cda = (__u32)virt_to_phys(config_area);\n\tccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_CONFIG);\n\nout_free:\n\tccw_device_dma_free(vcdev->cdev, config_area, VIRTIO_CCW_CONFIG_SIZE);\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n}\n\nstatic u8 virtio_ccw_get_status(struct virtio_device *vdev)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tu8 old_status = vcdev->dma_area->status;\n\tstruct ccw1 *ccw;\n\n\tif (vcdev->revision < 2)\n\t\treturn vcdev->dma_area->status;\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn old_status;\n\n\tccw->cmd_code = CCW_CMD_READ_STATUS;\n\tccw->flags = 0;\n\tccw->count = sizeof(vcdev->dma_area->status);\n\tccw->cda = (__u32)virt_to_phys(&vcdev->dma_area->status);\n\tccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_READ_STATUS);\n \n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n\n\treturn vcdev->dma_area->status;\n}\n\nstatic void virtio_ccw_set_status(struct virtio_device *vdev, u8 status)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tu8 old_status = vcdev->dma_area->status;\n\tstruct ccw1 *ccw;\n\tint ret;\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn;\n\n\t \n\tvcdev->dma_area->status = status;\n\tccw->cmd_code = CCW_CMD_WRITE_STATUS;\n\tccw->flags = 0;\n\tccw->count = sizeof(status);\n\tccw->cda = (__u32)virt_to_phys(&vcdev->dma_area->status);\n\t \n\tret = ccw_io_helper(vcdev, ccw, VIRTIO_CCW_DOING_WRITE_STATUS);\n\t \n\tif (ret)\n\t\tvcdev->dma_area->status = old_status;\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n}\n\nstatic const char *virtio_ccw_bus_name(struct virtio_device *vdev)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\n\treturn dev_name(&vcdev->cdev->dev);\n}\n\nstatic void virtio_ccw_synchronize_cbs(struct virtio_device *vdev)\n{\n\tstruct virtio_ccw_device *vcdev = to_vc_device(vdev);\n\tstruct airq_info *info = vcdev->airq_info;\n\n\tif (info) {\n\t\t \n\t\twrite_lock_irq(&info->lock);\n\t\twrite_unlock_irq(&info->lock);\n\t} else {\n\t\t \n\t\twrite_lock_irq(&vcdev->irq_lock);\n\t\twrite_unlock_irq(&vcdev->irq_lock);\n\t}\n}\n\nstatic const struct virtio_config_ops virtio_ccw_config_ops = {\n\t.get_features = virtio_ccw_get_features,\n\t.finalize_features = virtio_ccw_finalize_features,\n\t.get = virtio_ccw_get_config,\n\t.set = virtio_ccw_set_config,\n\t.get_status = virtio_ccw_get_status,\n\t.set_status = virtio_ccw_set_status,\n\t.reset = virtio_ccw_reset,\n\t.find_vqs = virtio_ccw_find_vqs,\n\t.del_vqs = virtio_ccw_del_vqs,\n\t.bus_name = virtio_ccw_bus_name,\n\t.synchronize_cbs = virtio_ccw_synchronize_cbs,\n};\n\n\n \n\nstatic void virtio_ccw_release_dev(struct device *_d)\n{\n\tstruct virtio_device *dev = dev_to_virtio(_d);\n\tstruct virtio_ccw_device *vcdev = to_vc_device(dev);\n\n\tccw_device_dma_free(vcdev->cdev, vcdev->dma_area,\n\t\t\t    sizeof(*vcdev->dma_area));\n\tkfree(vcdev);\n}\n\nstatic int irb_is_error(struct irb *irb)\n{\n\tif (scsw_cstat(&irb->scsw) != 0)\n\t\treturn 1;\n\tif (scsw_dstat(&irb->scsw) & ~(DEV_STAT_CHN_END | DEV_STAT_DEV_END))\n\t\treturn 1;\n\tif (scsw_cc(&irb->scsw) != 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic struct virtqueue *virtio_ccw_vq_by_ind(struct virtio_ccw_device *vcdev,\n\t\t\t\t\t      int index)\n{\n\tstruct virtio_ccw_vq_info *info;\n\tunsigned long flags;\n\tstruct virtqueue *vq;\n\n\tvq = NULL;\n\tspin_lock_irqsave(&vcdev->lock, flags);\n\tlist_for_each_entry(info, &vcdev->virtqueues, node) {\n\t\tif (info->vq->index == index) {\n\t\t\tvq = info->vq;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vcdev->lock, flags);\n\treturn vq;\n}\n\nstatic void virtio_ccw_check_activity(struct virtio_ccw_device *vcdev,\n\t\t\t\t      __u32 activity)\n{\n\tif (vcdev->curr_io & activity) {\n\t\tswitch (activity) {\n\t\tcase VIRTIO_CCW_DOING_READ_FEAT:\n\t\tcase VIRTIO_CCW_DOING_WRITE_FEAT:\n\t\tcase VIRTIO_CCW_DOING_READ_CONFIG:\n\t\tcase VIRTIO_CCW_DOING_WRITE_CONFIG:\n\t\tcase VIRTIO_CCW_DOING_WRITE_STATUS:\n\t\tcase VIRTIO_CCW_DOING_READ_STATUS:\n\t\tcase VIRTIO_CCW_DOING_SET_VQ:\n\t\tcase VIRTIO_CCW_DOING_SET_IND:\n\t\tcase VIRTIO_CCW_DOING_SET_CONF_IND:\n\t\tcase VIRTIO_CCW_DOING_RESET:\n\t\tcase VIRTIO_CCW_DOING_READ_VQ_CONF:\n\t\tcase VIRTIO_CCW_DOING_SET_IND_ADAPTER:\n\t\tcase VIRTIO_CCW_DOING_SET_VIRTIO_REV:\n\t\t\tvcdev->curr_io &= ~activity;\n\t\t\twake_up(&vcdev->wait_q);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_warn(&vcdev->cdev->dev,\n\t\t\t\t \"Suspicious activity '%08x'\\n\", activity);\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void virtio_ccw_int_handler(struct ccw_device *cdev,\n\t\t\t\t   unsigned long intparm,\n\t\t\t\t   struct irb *irb)\n{\n\t__u32 activity = intparm & VIRTIO_CCW_INTPARM_MASK;\n\tstruct virtio_ccw_device *vcdev = dev_get_drvdata(&cdev->dev);\n\tint i;\n\tstruct virtqueue *vq;\n\n\tif (!vcdev)\n\t\treturn;\n\tif (IS_ERR(irb)) {\n\t\tvcdev->err = PTR_ERR(irb);\n\t\tvirtio_ccw_check_activity(vcdev, activity);\n\t\t \n\t\treturn;\n\t}\n\t \n\tif ((intparm == 0) &&\n\t    (scsw_stctl(&irb->scsw) ==\n\t     (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND))) {\n\t\t \n\t}\n\tif (irb_is_error(irb)) {\n\t\t \n\t\tif ((scsw_dstat(&irb->scsw) & DEV_STAT_UNIT_CHECK) &&\n\t\t    (irb->ecw[0] & SNS0_CMD_REJECT))\n\t\t\tvcdev->err = -EOPNOTSUPP;\n\t\telse\n\t\t\t \n\t\t\tvcdev->err = -EIO;\n\t}\n\tvirtio_ccw_check_activity(vcdev, activity);\n#ifdef CONFIG_VIRTIO_HARDEN_NOTIFICATION\n\t \n\tread_lock(&vcdev->irq_lock);\n#endif\n\tfor_each_set_bit(i, indicators(vcdev),\n\t\t\t sizeof(*indicators(vcdev)) * BITS_PER_BYTE) {\n\t\t \n\t\tclear_bit(i, indicators(vcdev));\n\t\tbarrier();\n\t\tvq = virtio_ccw_vq_by_ind(vcdev, i);\n\t\tvring_interrupt(0, vq);\n\t}\n#ifdef CONFIG_VIRTIO_HARDEN_NOTIFICATION\n\tread_unlock(&vcdev->irq_lock);\n#endif\n\tif (test_bit(0, indicators2(vcdev))) {\n\t\tvirtio_config_changed(&vcdev->vdev);\n\t\tclear_bit(0, indicators2(vcdev));\n\t}\n}\n\n \n#define __DEV_WORDS ((__MAX_SUBCHANNEL + (8*sizeof(long) - 1)) / \\\n\t\t     (8*sizeof(long)))\nstatic unsigned long devs_no_auto[__MAX_SSID + 1][__DEV_WORDS];\n\nstatic char *no_auto = \"\";\n\nmodule_param(no_auto, charp, 0444);\nMODULE_PARM_DESC(no_auto, \"list of ccw bus id ranges not to be auto-onlined\");\n\nstatic int virtio_ccw_check_autoonline(struct ccw_device *cdev)\n{\n\tstruct ccw_dev_id id;\n\n\tccw_device_get_id(cdev, &id);\n\tif (test_bit(id.devno, devs_no_auto[id.ssid]))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void virtio_ccw_auto_online(void *data, async_cookie_t cookie)\n{\n\tstruct ccw_device *cdev = data;\n\tint ret;\n\n\tret = ccw_device_set_online(cdev);\n\tif (ret)\n\t\tdev_warn(&cdev->dev, \"Failed to set online: %d\\n\", ret);\n}\n\nstatic int virtio_ccw_probe(struct ccw_device *cdev)\n{\n\tcdev->handler = virtio_ccw_int_handler;\n\n\tif (virtio_ccw_check_autoonline(cdev))\n\t\tasync_schedule(virtio_ccw_auto_online, cdev);\n\treturn 0;\n}\n\nstatic struct virtio_ccw_device *virtio_grab_drvdata(struct ccw_device *cdev)\n{\n\tunsigned long flags;\n\tstruct virtio_ccw_device *vcdev;\n\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tvcdev = dev_get_drvdata(&cdev->dev);\n\tif (!vcdev || vcdev->going_away) {\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\t\treturn NULL;\n\t}\n\tvcdev->going_away = true;\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\treturn vcdev;\n}\n\nstatic void virtio_ccw_remove(struct ccw_device *cdev)\n{\n\tunsigned long flags;\n\tstruct virtio_ccw_device *vcdev = virtio_grab_drvdata(cdev);\n\n\tif (vcdev && cdev->online) {\n\t\tif (vcdev->device_lost)\n\t\t\tvirtio_break_device(&vcdev->vdev);\n\t\tunregister_virtio_device(&vcdev->vdev);\n\t\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\t\tdev_set_drvdata(&cdev->dev, NULL);\n\t\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\t}\n\tcdev->handler = NULL;\n}\n\nstatic int virtio_ccw_offline(struct ccw_device *cdev)\n{\n\tunsigned long flags;\n\tstruct virtio_ccw_device *vcdev = virtio_grab_drvdata(cdev);\n\n\tif (!vcdev)\n\t\treturn 0;\n\tif (vcdev->device_lost)\n\t\tvirtio_break_device(&vcdev->vdev);\n\tunregister_virtio_device(&vcdev->vdev);\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tdev_set_drvdata(&cdev->dev, NULL);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\treturn 0;\n}\n\nstatic int virtio_ccw_set_transport_rev(struct virtio_ccw_device *vcdev)\n{\n\tstruct virtio_rev_info *rev;\n\tstruct ccw1 *ccw;\n\tint ret;\n\n\tccw = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*ccw));\n\tif (!ccw)\n\t\treturn -ENOMEM;\n\trev = ccw_device_dma_zalloc(vcdev->cdev, sizeof(*rev));\n\tif (!rev) {\n\t\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tccw->cmd_code = CCW_CMD_SET_VIRTIO_REV;\n\tccw->flags = 0;\n\tccw->count = sizeof(*rev);\n\tccw->cda = (__u32)virt_to_phys(rev);\n\n\tvcdev->revision = VIRTIO_CCW_REV_MAX;\n\tdo {\n\t\trev->revision = vcdev->revision;\n\t\t \n\t\trev->length = 0;\n\t\tret = ccw_io_helper(vcdev, ccw,\n\t\t\t\t    VIRTIO_CCW_DOING_SET_VIRTIO_REV);\n\t\tif (ret == -EOPNOTSUPP) {\n\t\t\tif (vcdev->revision == 0)\n\t\t\t\t \n\t\t\t\tret = 0;\n\t\t\telse\n\t\t\t\tvcdev->revision--;\n\t\t}\n\t} while (ret == -EOPNOTSUPP);\n\n\tccw_device_dma_free(vcdev->cdev, ccw, sizeof(*ccw));\n\tccw_device_dma_free(vcdev->cdev, rev, sizeof(*rev));\n\treturn ret;\n}\n\nstatic int virtio_ccw_online(struct ccw_device *cdev)\n{\n\tint ret;\n\tstruct virtio_ccw_device *vcdev;\n\tunsigned long flags;\n\n\tvcdev = kzalloc(sizeof(*vcdev), GFP_KERNEL);\n\tif (!vcdev) {\n\t\tdev_warn(&cdev->dev, \"Could not get memory for virtio\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tvcdev->vdev.dev.parent = &cdev->dev;\n\tvcdev->cdev = cdev;\n\tvcdev->dma_area = ccw_device_dma_zalloc(vcdev->cdev,\n\t\t\t\t\t\tsizeof(*vcdev->dma_area));\n\tif (!vcdev->dma_area) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tvcdev->is_thinint = virtio_ccw_use_airq;  \n\n\tvcdev->vdev.dev.release = virtio_ccw_release_dev;\n\tvcdev->vdev.config = &virtio_ccw_config_ops;\n\tinit_waitqueue_head(&vcdev->wait_q);\n\tINIT_LIST_HEAD(&vcdev->virtqueues);\n\tspin_lock_init(&vcdev->lock);\n\trwlock_init(&vcdev->irq_lock);\n\tmutex_init(&vcdev->io_lock);\n\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tdev_set_drvdata(&cdev->dev, vcdev);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\tvcdev->vdev.id.vendor = cdev->id.cu_type;\n\tvcdev->vdev.id.device = cdev->id.cu_model;\n\n\tret = virtio_ccw_set_transport_rev(vcdev);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = register_virtio_device(&vcdev->vdev);\n\tif (ret) {\n\t\tdev_warn(&cdev->dev, \"Failed to register virtio device: %d\\n\",\n\t\t\t ret);\n\t\tgoto out_put;\n\t}\n\treturn 0;\nout_put:\n\tspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\n\tdev_set_drvdata(&cdev->dev, NULL);\n\tspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\n\tput_device(&vcdev->vdev.dev);\n\treturn ret;\nout_free:\n\tif (vcdev) {\n\t\tccw_device_dma_free(vcdev->cdev, vcdev->dma_area,\n\t\t\t\t    sizeof(*vcdev->dma_area));\n\t}\n\tkfree(vcdev);\n\treturn ret;\n}\n\nstatic int virtio_ccw_cio_notify(struct ccw_device *cdev, int event)\n{\n\tint rc;\n\tstruct virtio_ccw_device *vcdev = dev_get_drvdata(&cdev->dev);\n\n\t \n\tif (!vcdev)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase CIO_GONE:\n\t\tvcdev->device_lost = true;\n\t\trc = NOTIFY_DONE;\n\t\tbreak;\n\tcase CIO_OPER:\n\t\trc = NOTIFY_OK;\n\t\tbreak;\n\tdefault:\n\t\trc = NOTIFY_DONE;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic struct ccw_device_id virtio_ids[] = {\n\t{ CCW_DEVICE(0x3832, 0) },\n\t{},\n};\n\nstatic struct ccw_driver virtio_ccw_driver = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"virtio_ccw\",\n\t},\n\t.ids = virtio_ids,\n\t.probe = virtio_ccw_probe,\n\t.remove = virtio_ccw_remove,\n\t.set_offline = virtio_ccw_offline,\n\t.set_online = virtio_ccw_online,\n\t.notify = virtio_ccw_cio_notify,\n\t.int_class = IRQIO_VIR,\n};\n\nstatic int __init pure_hex(char **cp, unsigned int *val, int min_digit,\n\t\t\t   int max_digit, int max_val)\n{\n\tint diff;\n\n\tdiff = 0;\n\t*val = 0;\n\n\twhile (diff <= max_digit) {\n\t\tint value = hex_to_bin(**cp);\n\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*val = *val * 16 + value;\n\t\t(*cp)++;\n\t\tdiff++;\n\t}\n\n\tif ((diff < min_digit) || (diff > max_digit) || (*val > max_val))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int __init parse_busid(char *str, unsigned int *cssid,\n\t\t\t      unsigned int *ssid, unsigned int *devno)\n{\n\tchar *str_work;\n\tint rc, ret;\n\n\trc = 1;\n\n\tif (*str == '\\0')\n\t\tgoto out;\n\n\tstr_work = str;\n\tret = pure_hex(&str_work, cssid, 1, 2, __MAX_CSSID);\n\tif (ret || (str_work[0] != '.'))\n\t\tgoto out;\n\tstr_work++;\n\tret = pure_hex(&str_work, ssid, 1, 1, __MAX_SSID);\n\tif (ret || (str_work[0] != '.'))\n\t\tgoto out;\n\tstr_work++;\n\tret = pure_hex(&str_work, devno, 4, 4, __MAX_SUBCHANNEL);\n\tif (ret || (str_work[0] != '\\0'))\n\t\tgoto out;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic void __init no_auto_parse(void)\n{\n\tunsigned int from_cssid, to_cssid, from_ssid, to_ssid, from, to;\n\tchar *parm, *str;\n\tint rc;\n\n\tstr = no_auto;\n\twhile ((parm = strsep(&str, \",\"))) {\n\t\trc = parse_busid(strsep(&parm, \"-\"), &from_cssid,\n\t\t\t\t &from_ssid, &from);\n\t\tif (rc)\n\t\t\tcontinue;\n\t\tif (parm != NULL) {\n\t\t\trc = parse_busid(parm, &to_cssid,\n\t\t\t\t\t &to_ssid, &to);\n\t\t\tif ((from_ssid > to_ssid) ||\n\t\t\t    ((from_ssid == to_ssid) && (from > to)))\n\t\t\t\trc = -EINVAL;\n\t\t} else {\n\t\t\tto_cssid = from_cssid;\n\t\t\tto_ssid = from_ssid;\n\t\t\tto = from;\n\t\t}\n\t\tif (rc)\n\t\t\tcontinue;\n\t\twhile ((from_ssid < to_ssid) ||\n\t\t       ((from_ssid == to_ssid) && (from <= to))) {\n\t\t\tset_bit(from, devs_no_auto[from_ssid]);\n\t\t\tfrom++;\n\t\t\tif (from > __MAX_SUBCHANNEL) {\n\t\t\t\tfrom_ssid++;\n\t\t\t\tfrom = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __init virtio_ccw_init(void)\n{\n\tint rc;\n\n\t \n\tno_auto_parse();\n\n\tsummary_indicators = cio_dma_zalloc(MAX_AIRQ_AREAS);\n\tif (!summary_indicators)\n\t\treturn -ENOMEM;\n\trc = ccw_driver_register(&virtio_ccw_driver);\n\tif (rc)\n\t\tcio_dma_free(summary_indicators, MAX_AIRQ_AREAS);\n\treturn rc;\n}\ndevice_initcall(virtio_ccw_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}