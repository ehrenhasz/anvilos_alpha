{
  "module_name": "phy-meson-g12a-usb3-pcie.c",
  "hash_id": "b8cfe6301166d4cb4e16ec0e3b157a3f37a075b52d847153de6e848899059207",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/amlogic/phy-meson-g12a-usb3-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/phy/phy.h>\n\n#define PHY_R0\t\t\t\t\t\t\t0x00\n\t#define PHY_R0_PCIE_POWER_STATE\t\t\t\tGENMASK(4, 0)\n\t#define PHY_R0_PCIE_USB3_SWITCH\t\t\t\tGENMASK(6, 5)\n\n#define PHY_R1\t\t\t\t\t\t\t0x04\n\t#define PHY_R1_PHY_TX1_TERM_OFFSET\t\t\tGENMASK(4, 0)\n\t#define PHY_R1_PHY_TX0_TERM_OFFSET\t\t\tGENMASK(9, 5)\n\t#define PHY_R1_PHY_RX1_EQ\t\t\t\tGENMASK(12, 10)\n\t#define PHY_R1_PHY_RX0_EQ\t\t\t\tGENMASK(15, 13)\n\t#define PHY_R1_PHY_LOS_LEVEL\t\t\t\tGENMASK(20, 16)\n\t#define PHY_R1_PHY_LOS_BIAS\t\t\t\tGENMASK(23, 21)\n\t#define PHY_R1_PHY_REF_CLKDIV2\t\t\t\tBIT(24)\n\t#define PHY_R1_PHY_MPLL_MULTIPLIER\t\t\tGENMASK(31, 25)\n\n#define PHY_R2\t\t\t\t\t\t\t0x08\n\t#define PHY_R2_PCS_TX_DEEMPH_GEN2_6DB\t\t\tGENMASK(5, 0)\n\t#define PHY_R2_PCS_TX_DEEMPH_GEN2_3P5DB\t\t\tGENMASK(11, 6)\n\t#define PHY_R2_PCS_TX_DEEMPH_GEN1\t\t\tGENMASK(17, 12)\n\t#define PHY_R2_PHY_TX_VBOOST_LVL\t\t\tGENMASK(20, 18)\n\n#define PHY_R4\t\t\t\t\t\t\t0x10\n\t#define PHY_R4_PHY_CR_WRITE\t\t\t\tBIT(0)\n\t#define PHY_R4_PHY_CR_READ\t\t\t\tBIT(1)\n\t#define PHY_R4_PHY_CR_DATA_IN\t\t\t\tGENMASK(17, 2)\n\t#define PHY_R4_PHY_CR_CAP_DATA\t\t\t\tBIT(18)\n\t#define PHY_R4_PHY_CR_CAP_ADDR\t\t\t\tBIT(19)\n\n#define PHY_R5\t\t\t\t\t\t\t0x14\n\t#define PHY_R5_PHY_CR_DATA_OUT\t\t\t\tGENMASK(15, 0)\n\t#define PHY_R5_PHY_CR_ACK\t\t\t\tBIT(16)\n\t#define PHY_R5_PHY_BS_OUT\t\t\t\tBIT(17)\n\n#define PCIE_RESET_DELAY\t\t\t\t\t500\n\nstruct phy_g12a_usb3_pcie_priv {\n\tstruct regmap\t\t*regmap;\n\tstruct regmap\t\t*regmap_cr;\n\tstruct clk\t\t*clk_ref;\n\tstruct reset_control\t*reset;\n\tstruct phy\t\t*phy;\n\tunsigned int\t\tmode;\n};\n\nstatic const struct regmap_config phy_g12a_usb3_pcie_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = PHY_R5,\n};\n\nstatic int phy_g12a_usb3_pcie_cr_bus_addr(struct phy_g12a_usb3_pcie_priv *priv,\n\t\t\t\t\t  unsigned int addr)\n{\n\tunsigned int val, reg;\n\tint ret;\n\n\treg = FIELD_PREP(PHY_R4_PHY_CR_DATA_IN, addr);\n\n\tregmap_write(priv->regmap, PHY_R4, reg);\n\tregmap_write(priv->regmap, PHY_R4, reg);\n\n\tregmap_write(priv->regmap, PHY_R4, reg | PHY_R4_PHY_CR_CAP_ADDR);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_R5, val,\n\t\t\t\t       (val & PHY_R5_PHY_CR_ACK),\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(priv->regmap, PHY_R4, reg);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_R5, val,\n\t\t\t\t       !(val & PHY_R5_PHY_CR_ACK),\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int phy_g12a_usb3_pcie_cr_bus_read(void *context, unsigned int addr,\n\t\t\t\t\t  unsigned int *data)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = context;\n\tunsigned int val;\n\tint ret;\n\n\tret = phy_g12a_usb3_pcie_cr_bus_addr(priv, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(priv->regmap, PHY_R4, 0);\n\tregmap_write(priv->regmap, PHY_R4, PHY_R4_PHY_CR_READ);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_R5, val,\n\t\t\t\t       (val & PHY_R5_PHY_CR_ACK),\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\t*data = FIELD_GET(PHY_R5_PHY_CR_DATA_OUT, val);\n\n\tregmap_write(priv->regmap, PHY_R4, 0);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_R5, val,\n\t\t\t\t       !(val & PHY_R5_PHY_CR_ACK),\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int phy_g12a_usb3_pcie_cr_bus_write(void *context, unsigned int addr,\n\t\t\t\t\t   unsigned int data)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = context;\n\tunsigned int val, reg;\n\tint ret;\n\n\tret = phy_g12a_usb3_pcie_cr_bus_addr(priv, addr);\n\tif (ret)\n\t\treturn ret;\n\n\treg = FIELD_PREP(PHY_R4_PHY_CR_DATA_IN, data);\n\n\tregmap_write(priv->regmap, PHY_R4, reg);\n\tregmap_write(priv->regmap, PHY_R4, reg);\n\n\tregmap_write(priv->regmap, PHY_R4, reg | PHY_R4_PHY_CR_CAP_DATA);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_R5, val,\n\t\t\t\t       (val & PHY_R5_PHY_CR_ACK),\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(priv->regmap, PHY_R4, reg);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_R5, val,\n\t\t\t\t       (val & PHY_R5_PHY_CR_ACK) == 0,\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(priv->regmap, PHY_R4, reg);\n\n\tregmap_write(priv->regmap, PHY_R4, reg | PHY_R4_PHY_CR_WRITE);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_R5, val,\n\t\t\t\t       (val & PHY_R5_PHY_CR_ACK),\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(priv->regmap, PHY_R4, reg);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_R5, val,\n\t\t\t\t       (val & PHY_R5_PHY_CR_ACK) == 0,\n\t\t\t\t       5, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct regmap_config phy_g12a_usb3_pcie_cr_regmap_conf = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.reg_read = phy_g12a_usb3_pcie_cr_bus_read,\n\t.reg_write = phy_g12a_usb3_pcie_cr_bus_write,\n\t.max_register = 0xffff,\n\t.disable_locking = true,\n};\n\nstatic int phy_g12a_usb3_init(struct phy *phy)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = phy_get_drvdata(phy);\n\tint data, ret;\n\n\tret = reset_control_reset(priv->reset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t \n\tregmap_update_bits(priv->regmap, PHY_R0,\n\t\t\t   PHY_R0_PCIE_USB3_SWITCH,\n\t\t\t   PHY_R0_PCIE_USB3_SWITCH);\n\n\t \n\tret = regmap_update_bits(priv->regmap_cr, 0x102d, BIT(7), BIT(7));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(priv->regmap_cr, 0x1010, 0xff0, 20);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(priv->regmap_cr, 0x1006, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata &= ~BIT(6);\n\tdata |= BIT(7);\n\tdata &= ~(0x7 << 8);\n\tdata |= (0x3 << 8);\n\tdata |= (1 << 11);\n\tret = regmap_write(priv->regmap_cr, 0x1006, data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(priv->regmap_cr, 0x1002, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata &= ~0x3f80;\n\tdata |= (0x16 << 7);\n\tdata &= ~0x7f;\n\tdata |= (0x7f | BIT(14));\n\tret = regmap_write(priv->regmap_cr, 0x1002, data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(priv->regmap_cr, 0x30, 0xf << 4, 8 << 4);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(priv->regmap, PHY_R2,\n\t\t\tPHY_R2_PHY_TX_VBOOST_LVL,\n\t\t\tFIELD_PREP(PHY_R2_PHY_TX_VBOOST_LVL, 0x4));\n\n\tregmap_update_bits(priv->regmap, PHY_R1,\n\t\t\tPHY_R1_PHY_LOS_BIAS | PHY_R1_PHY_LOS_LEVEL,\n\t\t\tFIELD_PREP(PHY_R1_PHY_LOS_BIAS, 4) |\n\t\t\tFIELD_PREP(PHY_R1_PHY_LOS_LEVEL, 9));\n\n\treturn 0;\n}\n\nstatic int phy_g12a_usb3_pcie_power_on(struct phy *phy)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->mode == PHY_TYPE_USB3)\n\t\treturn 0;\n\n\tregmap_update_bits(priv->regmap, PHY_R0,\n\t\t\t   PHY_R0_PCIE_POWER_STATE,\n\t\t\t   FIELD_PREP(PHY_R0_PCIE_POWER_STATE, 0x1c));\n\n\treturn 0;\n}\n\nstatic int phy_g12a_usb3_pcie_power_off(struct phy *phy)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->mode == PHY_TYPE_USB3)\n\t\treturn 0;\n\n\tregmap_update_bits(priv->regmap, PHY_R0,\n\t\t\t   PHY_R0_PCIE_POWER_STATE,\n\t\t\t   FIELD_PREP(PHY_R0_PCIE_POWER_STATE, 0x1d));\n\n\treturn 0;\n}\n\nstatic int phy_g12a_usb3_pcie_reset(struct phy *phy)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tif (priv->mode == PHY_TYPE_USB3)\n\t\treturn 0;\n\n\tret = reset_control_assert(priv->reset);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(PCIE_RESET_DELAY);\n\n\tret = reset_control_deassert(priv->reset);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(PCIE_RESET_DELAY);\n\n\treturn 0;\n}\n\nstatic int phy_g12a_usb3_pcie_init(struct phy *phy)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->mode == PHY_TYPE_USB3)\n\t\treturn phy_g12a_usb3_init(phy);\n\n\treturn 0;\n}\n\nstatic int phy_g12a_usb3_pcie_exit(struct phy *phy)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->mode == PHY_TYPE_USB3)\n\t\treturn reset_control_reset(priv->reset);\n\n\treturn 0;\n}\n\nstatic struct phy *phy_g12a_usb3_pcie_xlate(struct device *dev,\n\t\t\t\t\t    struct of_phandle_args *args)\n{\n\tstruct phy_g12a_usb3_pcie_priv *priv = dev_get_drvdata(dev);\n\tunsigned int mode;\n\n\tif (args->args_count < 1) {\n\t\tdev_err(dev, \"invalid number of arguments\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmode = args->args[0];\n\n\tif (mode != PHY_TYPE_USB3 && mode != PHY_TYPE_PCIE) {\n\t\tdev_err(dev, \"invalid phy mode select argument\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpriv->mode = mode;\n\n\treturn priv->phy;\n}\n\nstatic const struct phy_ops phy_g12a_usb3_pcie_ops = {\n\t.init\t\t= phy_g12a_usb3_pcie_init,\n\t.exit\t\t= phy_g12a_usb3_pcie_exit,\n\t.power_on\t= phy_g12a_usb3_pcie_power_on,\n\t.power_off\t= phy_g12a_usb3_pcie_power_off,\n\t.reset\t\t= phy_g12a_usb3_pcie_reset,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int phy_g12a_usb3_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct phy_g12a_usb3_pcie_priv *priv;\n\tstruct phy_provider *phy_provider;\n\tvoid __iomem *base;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t     &phy_g12a_usb3_pcie_regmap_conf);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->regmap_cr = devm_regmap_init(dev, NULL, priv,\n\t\t\t\t\t   &phy_g12a_usb3_pcie_cr_regmap_conf);\n\tif (IS_ERR(priv->regmap_cr))\n\t\treturn PTR_ERR(priv->regmap_cr);\n\n\tpriv->clk_ref = devm_clk_get_enabled(dev, \"ref_clk\");\n\tif (IS_ERR(priv->clk_ref))\n\t\treturn PTR_ERR(priv->clk_ref);\n\n\tpriv->reset = devm_reset_control_array_get_exclusive(dev);\n\tif (IS_ERR(priv->reset))\n\t\treturn PTR_ERR(priv->reset);\n\n\tpriv->phy = devm_phy_create(dev, np, &phy_g12a_usb3_pcie_ops);\n\tif (IS_ERR(priv->phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->phy), \"failed to create PHY\\n\");\n\n\tphy_set_drvdata(priv->phy, priv);\n\tdev_set_drvdata(dev, priv);\n\n\tphy_provider = devm_of_phy_provider_register(dev,\n\t\t\t\t\t\t     phy_g12a_usb3_pcie_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id phy_g12a_usb3_pcie_of_match[] = {\n\t{ .compatible = \"amlogic,g12a-usb3-pcie-phy\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, phy_g12a_usb3_pcie_of_match);\n\nstatic struct platform_driver phy_g12a_usb3_pcie_driver = {\n\t.probe\t= phy_g12a_usb3_pcie_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"phy-g12a-usb3-pcie\",\n\t\t.of_match_table\t= phy_g12a_usb3_pcie_of_match,\n\t},\n};\nmodule_platform_driver(phy_g12a_usb3_pcie_driver);\n\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_DESCRIPTION(\"Amlogic G12A USB3 + PCIE Combo PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}