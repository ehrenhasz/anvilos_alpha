{
  "module_name": "phy-meson-axg-mipi-pcie-analog.c",
  "hash_id": "c7383230a4fa7ff756593d31c75633d4a2c8112b6bea5b62ae783f98bae80bc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/amlogic/phy-meson-axg-mipi-pcie-analog.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/phy/phy.h>\n\n#define HHI_MIPI_CNTL0 0x00\n#define\t\tHHI_MIPI_CNTL0_COMMON_BLOCK\tGENMASK(31, 28)\n#define\t\tHHI_MIPI_CNTL0_ENABLE\t\tBIT(29)\n#define\t\tHHI_MIPI_CNTL0_BANDGAP\t\tBIT(26)\n#define\t\tHHI_MIPI_CNTL0_DIF_REF_CTL1\tGENMASK(25, 16)\n#define\t\tHHI_MIPI_CNTL0_DIF_REF_CTL0\tGENMASK(15, 0)\n\n#define HHI_MIPI_CNTL1 0x04\n#define\t\tHHI_MIPI_CNTL1_CH0_CML_PDR_EN\tBIT(12)\n#define\t\tHHI_MIPI_CNTL1_LP_ABILITY\tGENMASK(5, 4)\n#define\t\tHHI_MIPI_CNTL1_LP_RESISTER\tBIT(3)\n#define\t\tHHI_MIPI_CNTL1_INPUT_SETTING\tBIT(2)\n#define\t\tHHI_MIPI_CNTL1_INPUT_SEL\tBIT(1)\n#define\t\tHHI_MIPI_CNTL1_PRBS7_EN\t\tBIT(0)\n\n#define HHI_MIPI_CNTL2 0x08\n#define\t\tHHI_MIPI_CNTL2_CH_PU\t\tGENMASK(31, 25)\n#define\t\tHHI_MIPI_CNTL2_CH_CTL\t\tGENMASK(24, 19)\n#define\t\tHHI_MIPI_CNTL2_CH0_DIGDR_EN\tBIT(18)\n#define\t\tHHI_MIPI_CNTL2_CH_DIGDR_EN\tBIT(17)\n#define\t\tHHI_MIPI_CNTL2_LPULPS_EN\tBIT(16)\n#define\t\tHHI_MIPI_CNTL2_CH_EN\t\tGENMASK(15, 11)\n#define\t\tHHI_MIPI_CNTL2_CH0_LP_CTL\tGENMASK(10, 1)\n\n#define DSI_LANE_0              BIT(4)\n#define DSI_LANE_1              BIT(3)\n#define DSI_LANE_CLK            BIT(2)\n#define DSI_LANE_2              BIT(1)\n#define DSI_LANE_3              BIT(0)\n\nstruct phy_axg_mipi_pcie_analog_priv {\n\tstruct phy *phy;\n\tstruct regmap *regmap;\n\tbool dsi_configured;\n\tbool dsi_enabled;\n\tbool powered;\n\tstruct phy_configure_opts_mipi_dphy config;\n};\n\nstatic void phy_bandgap_enable(struct phy_axg_mipi_pcie_analog_priv *priv)\n{\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\tHHI_MIPI_CNTL0_BANDGAP, HHI_MIPI_CNTL0_BANDGAP);\n\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\tHHI_MIPI_CNTL0_ENABLE, HHI_MIPI_CNTL0_ENABLE);\n}\n\nstatic void phy_bandgap_disable(struct phy_axg_mipi_pcie_analog_priv *priv)\n{\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\tHHI_MIPI_CNTL0_BANDGAP, 0);\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\tHHI_MIPI_CNTL0_ENABLE, 0);\n}\n\nstatic void phy_dsi_analog_enable(struct phy_axg_mipi_pcie_analog_priv *priv)\n{\n\tu32 reg;\n\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\t   HHI_MIPI_CNTL0_DIF_REF_CTL1,\n\t\t\t   FIELD_PREP(HHI_MIPI_CNTL0_DIF_REF_CTL1, 0x1b8));\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\t   BIT(31), BIT(31));\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\t   HHI_MIPI_CNTL0_DIF_REF_CTL0,\n\t\t\t   FIELD_PREP(HHI_MIPI_CNTL0_DIF_REF_CTL0, 0x8));\n\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL1, 0x001e);\n\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL2,\n\t\t     (0x26e0 << 16) | (0x459 << 0));\n\n\treg = DSI_LANE_CLK;\n\tswitch (priv->config.lanes) {\n\tcase 4:\n\t\treg |= DSI_LANE_3;\n\t\tfallthrough;\n\tcase 3:\n\t\treg |= DSI_LANE_2;\n\t\tfallthrough;\n\tcase 2:\n\t\treg |= DSI_LANE_1;\n\t\tfallthrough;\n\tcase 1:\n\t\treg |= DSI_LANE_0;\n\t\tbreak;\n\tdefault:\n\t\treg = 0;\n\t}\n\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL2,\n\t\t\t   HHI_MIPI_CNTL2_CH_EN,\n\t\t\t   FIELD_PREP(HHI_MIPI_CNTL2_CH_EN, reg));\n\n\tpriv->dsi_enabled = true;\n}\n\nstatic void phy_dsi_analog_disable(struct phy_axg_mipi_pcie_analog_priv *priv)\n{\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\tHHI_MIPI_CNTL0_DIF_REF_CTL1,\n\t\t\tFIELD_PREP(HHI_MIPI_CNTL0_DIF_REF_CTL1, 0));\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0, BIT(31), 0);\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL0,\n\t\t\tHHI_MIPI_CNTL0_DIF_REF_CTL1, 0);\n\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL1, 0x6);\n\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL2, 0x00200000);\n\n\tpriv->dsi_enabled = false;\n}\n\nstatic int phy_axg_mipi_pcie_analog_configure(struct phy *phy,\n\t\t\t\t\t      union phy_configure_opts *opts)\n{\n\tstruct phy_axg_mipi_pcie_analog_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_mipi_dphy_config_validate(&opts->mipi_dphy);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&priv->config, opts, sizeof(priv->config));\n\n\tpriv->dsi_configured = true;\n\n\t \n\tif (priv->powered) {\n\t\t \n\t\tif (priv->dsi_enabled)\n\t\t\tphy_dsi_analog_disable(priv);\n\n\t\tusleep_range(100, 200);\n\n\t\tphy_dsi_analog_enable(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic int phy_axg_mipi_pcie_analog_power_on(struct phy *phy)\n{\n\tstruct phy_axg_mipi_pcie_analog_priv *priv = phy_get_drvdata(phy);\n\n\tphy_bandgap_enable(priv);\n\n\tif (priv->dsi_configured)\n\t\tphy_dsi_analog_enable(priv);\n\n\tpriv->powered = true;\n\n\treturn 0;\n}\n\nstatic int phy_axg_mipi_pcie_analog_power_off(struct phy *phy)\n{\n\tstruct phy_axg_mipi_pcie_analog_priv *priv = phy_get_drvdata(phy);\n\n\tphy_bandgap_disable(priv);\n\n\tif (priv->dsi_enabled)\n\t\tphy_dsi_analog_disable(priv);\n\n\tpriv->powered = false;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops phy_axg_mipi_pcie_analog_ops = {\n\t.configure = phy_axg_mipi_pcie_analog_configure,\n\t.power_on = phy_axg_mipi_pcie_analog_power_on,\n\t.power_off = phy_axg_mipi_pcie_analog_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic int phy_axg_mipi_pcie_analog_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_axg_mipi_pcie_analog_priv *priv;\n\tstruct device_node *np = dev->of_node, *parent_np;\n\tstruct regmap *map;\n\tint ret;\n\n\tpriv = devm_kmalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tparent_np = of_get_parent(dev->of_node);\n\tmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev,\n\t\t\t\"failed to get HHI regmap\\n\");\n\t\treturn PTR_ERR(map);\n\t}\n\n\tpriv->regmap = map;\n\n\tpriv->phy = devm_phy_create(dev, np, &phy_axg_mipi_pcie_analog_ops);\n\tif (IS_ERR(priv->phy)) {\n\t\tret = PTR_ERR(priv->phy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn ret;\n\t}\n\n\tphy_set_drvdata(priv->phy, priv);\n\tdev_set_drvdata(dev, priv);\n\n\tphy = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy);\n}\n\nstatic const struct of_device_id phy_axg_mipi_pcie_analog_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-mipi-pcie-analog-phy\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, phy_axg_mipi_pcie_analog_of_match);\n\nstatic struct platform_driver phy_axg_mipi_pcie_analog_driver = {\n\t.probe = phy_axg_mipi_pcie_analog_probe,\n\t.driver = {\n\t\t.name = \"phy-axg-mipi-pcie-analog\",\n\t\t.of_match_table = phy_axg_mipi_pcie_analog_of_match,\n\t},\n};\nmodule_platform_driver(phy_axg_mipi_pcie_analog_driver);\n\nMODULE_AUTHOR(\"Remi Pommarel <repk@triplefau.lt>\");\nMODULE_DESCRIPTION(\"Amlogic AXG MIPI + PCIE analog PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}