{
  "module_name": "phy-meson8b-usb2.c",
  "hash_id": "c7fcacab78054536b2054c09fe7f23d2dafea9a484acdead736b8a7e68cd1d79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/amlogic/phy-meson8b-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/usb/of.h>\n\n#define REG_CONFIG\t\t\t\t\t0x00\n\t#define REG_CONFIG_CLK_EN\t\t\tBIT(0)\n\t#define REG_CONFIG_CLK_SEL_MASK\t\t\tGENMASK(3, 1)\n\t#define REG_CONFIG_CLK_DIV_MASK\t\t\tGENMASK(10, 4)\n\t#define REG_CONFIG_CLK_32k_ALTSEL\t\tBIT(15)\n\t#define REG_CONFIG_TEST_TRIG\t\t\tBIT(31)\n\n#define REG_CTRL\t\t\t\t\t0x04\n\t#define REG_CTRL_SOFT_PRST\t\t\tBIT(0)\n\t#define REG_CTRL_SOFT_HRESET\t\t\tBIT(1)\n\t#define REG_CTRL_SS_SCALEDOWN_MODE_MASK\t\tGENMASK(3, 2)\n\t#define REG_CTRL_CLK_DET_RST\t\t\tBIT(4)\n\t#define REG_CTRL_INTR_SEL\t\t\tBIT(5)\n\t#define REG_CTRL_CLK_DETECTED\t\t\tBIT(8)\n\t#define REG_CTRL_SOF_SENT_RCVD_TGL\t\tBIT(9)\n\t#define REG_CTRL_SOF_TOGGLE_OUT\t\t\tBIT(10)\n\t#define REG_CTRL_POWER_ON_RESET\t\t\tBIT(15)\n\t#define REG_CTRL_SLEEPM\t\t\t\tBIT(16)\n\t#define REG_CTRL_TX_BITSTUFF_ENN_H\t\tBIT(17)\n\t#define REG_CTRL_TX_BITSTUFF_ENN\t\tBIT(18)\n\t#define REG_CTRL_COMMON_ON\t\t\tBIT(19)\n\t#define REG_CTRL_REF_CLK_SEL_MASK\t\tGENMASK(21, 20)\n\t#define REG_CTRL_REF_CLK_SEL_SHIFT\t\t20\n\t#define REG_CTRL_FSEL_MASK\t\t\tGENMASK(24, 22)\n\t#define REG_CTRL_FSEL_SHIFT\t\t\t22\n\t#define REG_CTRL_PORT_RESET\t\t\tBIT(25)\n\t#define REG_CTRL_THREAD_ID_MASK\t\t\tGENMASK(31, 26)\n\n#define REG_ENDP_INTR\t\t\t\t\t0x08\n\n \n#define REG_ADP_BC\t\t\t\t\t0x0c\n\t#define REG_ADP_BC_VBUS_VLD_EXT_SEL\t\tBIT(0)\n\t#define REG_ADP_BC_VBUS_VLD_EXT\t\t\tBIT(1)\n\t#define REG_ADP_BC_OTG_DISABLE\t\t\tBIT(2)\n\t#define REG_ADP_BC_ID_PULLUP\t\t\tBIT(3)\n\t#define REG_ADP_BC_DRV_VBUS\t\t\tBIT(4)\n\t#define REG_ADP_BC_ADP_PRB_EN\t\t\tBIT(5)\n\t#define REG_ADP_BC_ADP_DISCHARGE\t\tBIT(6)\n\t#define REG_ADP_BC_ADP_CHARGE\t\t\tBIT(7)\n\t#define REG_ADP_BC_SESS_END\t\t\tBIT(8)\n\t#define REG_ADP_BC_DEVICE_SESS_VLD\t\tBIT(9)\n\t#define REG_ADP_BC_B_VALID\t\t\tBIT(10)\n\t#define REG_ADP_BC_A_VALID\t\t\tBIT(11)\n\t#define REG_ADP_BC_ID_DIG\t\t\tBIT(12)\n\t#define REG_ADP_BC_VBUS_VALID\t\t\tBIT(13)\n\t#define REG_ADP_BC_ADP_PROBE\t\t\tBIT(14)\n\t#define REG_ADP_BC_ADP_SENSE\t\t\tBIT(15)\n\t#define REG_ADP_BC_ACA_ENABLE\t\t\tBIT(16)\n\t#define REG_ADP_BC_DCD_ENABLE\t\t\tBIT(17)\n\t#define REG_ADP_BC_VDAT_DET_EN_B\t\tBIT(18)\n\t#define REG_ADP_BC_VDAT_SRC_EN_B\t\tBIT(19)\n\t#define REG_ADP_BC_CHARGE_SEL\t\t\tBIT(20)\n\t#define REG_ADP_BC_CHARGE_DETECT\t\tBIT(21)\n\t#define REG_ADP_BC_ACA_PIN_RANGE_C\t\tBIT(22)\n\t#define REG_ADP_BC_ACA_PIN_RANGE_B\t\tBIT(23)\n\t#define REG_ADP_BC_ACA_PIN_RANGE_A\t\tBIT(24)\n\t#define REG_ADP_BC_ACA_PIN_GND\t\t\tBIT(25)\n\t#define REG_ADP_BC_ACA_PIN_FLOAT\t\tBIT(26)\n\n#define REG_DBG_UART\t\t\t\t\t0x10\n\t#define REG_DBG_UART_BYPASS_SEL\t\t\tBIT(0)\n\t#define REG_DBG_UART_BYPASS_DM_EN\t\tBIT(1)\n\t#define REG_DBG_UART_BYPASS_DP_EN\t\tBIT(2)\n\t#define REG_DBG_UART_BYPASS_DM_DATA\t\tBIT(3)\n\t#define REG_DBG_UART_BYPASS_DP_DATA\t\tBIT(4)\n\t#define REG_DBG_UART_FSV_MINUS\t\t\tBIT(5)\n\t#define REG_DBG_UART_FSV_PLUS\t\t\tBIT(6)\n\t#define REG_DBG_UART_FSV_BURN_IN_TEST\t\tBIT(7)\n\t#define REG_DBG_UART_LOOPBACK_EN_B\t\tBIT(8)\n\t#define REG_DBG_UART_SET_IDDQ\t\t\tBIT(9)\n\t#define REG_DBG_UART_ATE_RESET\t\t\tBIT(10)\n\n#define REG_TEST\t\t\t\t\t0x14\n\t#define REG_TEST_DATA_IN_MASK\t\t\tGENMASK(3, 0)\n\t#define REG_TEST_EN_MASK\t\t\tGENMASK(7, 4)\n\t#define REG_TEST_ADDR_MASK\t\t\tGENMASK(11, 8)\n\t#define REG_TEST_DATA_OUT_SEL\t\t\tBIT(12)\n\t#define REG_TEST_CLK\t\t\t\tBIT(13)\n\t#define REG_TEST_VA_TEST_EN_B_MASK\t\tGENMASK(15, 14)\n\t#define REG_TEST_DATA_OUT_MASK\t\t\tGENMASK(19, 16)\n\t#define REG_TEST_DISABLE_ID_PULLUP\t\tBIT(20)\n\n#define REG_TUNE\t\t\t\t\t0x18\n\t#define REG_TUNE_TX_RES_TUNE_MASK\t\tGENMASK(1, 0)\n\t#define REG_TUNE_TX_HSXV_TUNE_MASK\t\tGENMASK(3, 2)\n\t#define REG_TUNE_TX_VREF_TUNE_MASK\t\tGENMASK(7, 4)\n\t#define REG_TUNE_TX_RISE_TUNE_MASK\t\tGENMASK(9, 8)\n\t#define REG_TUNE_TX_PREEMP_PULSE_TUNE\t\tBIT(10)\n\t#define REG_TUNE_TX_PREEMP_AMP_TUNE_MASK\tGENMASK(12, 11)\n\t#define REG_TUNE_TX_FSLS_TUNE_MASK\t\tGENMASK(16, 13)\n\t#define REG_TUNE_SQRX_TUNE_MASK\t\t\tGENMASK(19, 17)\n\t#define REG_TUNE_OTG_TUNE\t\t\tGENMASK(22, 20)\n\t#define REG_TUNE_COMP_DIS_TUNE\t\t\tGENMASK(25, 23)\n\t#define REG_TUNE_HOST_DM_PULLDOWN\t\tBIT(26)\n\t#define REG_TUNE_HOST_DP_PULLDOWN\t\tBIT(27)\n\n#define RESET_COMPLETE_TIME\t\t\t\t500\n#define ACA_ENABLE_COMPLETE_TIME\t\t\t50\n\nstruct phy_meson8b_usb2_match_data {\n\tbool\t\t\thost_enable_aca;\n};\n\nstruct phy_meson8b_usb2_priv {\n\tstruct regmap\t\t\t\t\t*regmap;\n\tenum usb_dr_mode\t\t\t\tdr_mode;\n\tstruct clk\t\t\t\t\t*clk_usb_general;\n\tstruct clk\t\t\t\t\t*clk_usb;\n\tstruct reset_control\t\t\t\t*reset;\n\tconst struct phy_meson8b_usb2_match_data\t*match;\n};\n\nstatic const struct regmap_config phy_meson8b_usb2_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = REG_TUNE,\n};\n\nstatic int phy_meson8b_usb2_power_on(struct phy *phy)\n{\n\tstruct phy_meson8b_usb2_priv *priv = phy_get_drvdata(phy);\n\tu32 reg;\n\tint ret;\n\n\tif (!IS_ERR_OR_NULL(priv->reset)) {\n\t\tret = reset_control_reset(priv->reset);\n\t\tif (ret) {\n\t\t\tdev_err(&phy->dev, \"Failed to trigger USB reset\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(priv->clk_usb_general);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"Failed to enable USB general clock\\n\");\n\t\treset_control_rearm(priv->reset);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(priv->clk_usb);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"Failed to enable USB DDR clock\\n\");\n\t\tclk_disable_unprepare(priv->clk_usb_general);\n\t\treset_control_rearm(priv->reset);\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(priv->regmap, REG_CONFIG, REG_CONFIG_CLK_32k_ALTSEL,\n\t\t\t   REG_CONFIG_CLK_32k_ALTSEL);\n\n\tregmap_update_bits(priv->regmap, REG_CTRL, REG_CTRL_REF_CLK_SEL_MASK,\n\t\t\t   0x2 << REG_CTRL_REF_CLK_SEL_SHIFT);\n\n\tregmap_update_bits(priv->regmap, REG_CTRL, REG_CTRL_FSEL_MASK,\n\t\t\t   0x5 << REG_CTRL_FSEL_SHIFT);\n\n\t \n\tregmap_update_bits(priv->regmap, REG_CTRL, REG_CTRL_POWER_ON_RESET,\n\t\t\t   REG_CTRL_POWER_ON_RESET);\n\tudelay(RESET_COMPLETE_TIME);\n\tregmap_update_bits(priv->regmap, REG_CTRL, REG_CTRL_POWER_ON_RESET, 0);\n\tudelay(RESET_COMPLETE_TIME);\n\n\tregmap_update_bits(priv->regmap, REG_CTRL, REG_CTRL_SOF_TOGGLE_OUT,\n\t\t\t   REG_CTRL_SOF_TOGGLE_OUT);\n\n\tif (priv->dr_mode == USB_DR_MODE_HOST) {\n\t\tregmap_update_bits(priv->regmap, REG_DBG_UART,\n\t\t\t\t   REG_DBG_UART_SET_IDDQ, 0);\n\n\t\tif (priv->match->host_enable_aca) {\n\t\t\tregmap_update_bits(priv->regmap, REG_ADP_BC,\n\t\t\t\t\t   REG_ADP_BC_ACA_ENABLE,\n\t\t\t\t\t   REG_ADP_BC_ACA_ENABLE);\n\n\t\t\tudelay(ACA_ENABLE_COMPLETE_TIME);\n\n\t\t\tregmap_read(priv->regmap, REG_ADP_BC, &reg);\n\t\t\tif (reg & REG_ADP_BC_ACA_PIN_FLOAT) {\n\t\t\t\tdev_warn(&phy->dev, \"USB ID detect failed!\\n\");\n\t\t\t\tclk_disable_unprepare(priv->clk_usb);\n\t\t\t\tclk_disable_unprepare(priv->clk_usb_general);\n\t\t\t\treset_control_rearm(priv->reset);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int phy_meson8b_usb2_power_off(struct phy *phy)\n{\n\tstruct phy_meson8b_usb2_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->dr_mode == USB_DR_MODE_HOST)\n\t\tregmap_update_bits(priv->regmap, REG_DBG_UART,\n\t\t\t\t   REG_DBG_UART_SET_IDDQ,\n\t\t\t\t   REG_DBG_UART_SET_IDDQ);\n\n\tclk_disable_unprepare(priv->clk_usb);\n\tclk_disable_unprepare(priv->clk_usb_general);\n\treset_control_rearm(priv->reset);\n\n\t \n\tregmap_update_bits(priv->regmap, REG_CTRL, REG_CTRL_POWER_ON_RESET,\n\t\t\t   REG_CTRL_POWER_ON_RESET);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops phy_meson8b_usb2_ops = {\n\t.power_on\t= phy_meson8b_usb2_power_on,\n\t.power_off\t= phy_meson8b_usb2_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int phy_meson8b_usb2_probe(struct platform_device *pdev)\n{\n\tstruct phy_meson8b_usb2_priv *priv;\n\tstruct phy *phy;\n\tstruct phy_provider *phy_provider;\n\tvoid __iomem *base;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->match = device_get_match_data(&pdev->dev);\n\tif (!priv->match)\n\t\treturn -ENODEV;\n\n\tpriv->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t     &phy_meson8b_usb2_regmap_conf);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->clk_usb_general = devm_clk_get(&pdev->dev, \"usb_general\");\n\tif (IS_ERR(priv->clk_usb_general))\n\t\treturn PTR_ERR(priv->clk_usb_general);\n\n\tpriv->clk_usb = devm_clk_get(&pdev->dev, \"usb\");\n\tif (IS_ERR(priv->clk_usb))\n\t\treturn PTR_ERR(priv->clk_usb);\n\n\tpriv->reset = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\n\tif (IS_ERR(priv->reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->reset),\n\t\t\t\t     \"Failed to get the reset line\");\n\n\tpriv->dr_mode = of_usb_get_dr_mode_by_phy(pdev->dev.of_node, -1);\n\tif (priv->dr_mode == USB_DR_MODE_UNKNOWN) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"missing dual role configuration of the controller\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tphy = devm_phy_create(&pdev->dev, NULL, &phy_meson8b_usb2_ops);\n\tif (IS_ERR(phy)) {\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(phy),\n\t\t\t\t     \"failed to create PHY\\n\");\n\t}\n\n\tphy_set_drvdata(phy, priv);\n\n\tphy_provider =\n\t\tdevm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct phy_meson8b_usb2_match_data phy_meson8_usb2_match_data = {\n\t.host_enable_aca = false,\n};\n\nstatic const struct phy_meson8b_usb2_match_data phy_meson8b_usb2_match_data = {\n\t.host_enable_aca = true,\n};\n\nstatic const struct of_device_id phy_meson8b_usb2_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,meson8-usb2-phy\",\n\t\t.data = &phy_meson8_usb2_match_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson8b-usb2-phy\",\n\t\t.data = &phy_meson8b_usb2_match_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson8m2-usb2-phy\",\n\t\t.data = &phy_meson8b_usb2_match_data\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-gxbb-usb2-phy\",\n\t\t.data = &phy_meson8b_usb2_match_data\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, phy_meson8b_usb2_of_match);\n\nstatic struct platform_driver phy_meson8b_usb2_driver = {\n\t.probe\t= phy_meson8b_usb2_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"phy-meson-usb2\",\n\t\t.of_match_table\t= phy_meson8b_usb2_of_match,\n\t},\n};\nmodule_platform_driver(phy_meson8b_usb2_driver);\n\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_DESCRIPTION(\"Meson8, Meson8b, Meson8m2 and GXBB USB2 PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}