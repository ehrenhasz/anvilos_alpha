{
  "module_name": "phy-meson-gxl-usb2.c",
  "hash_id": "5210e8a1ea0eab30acbd241a43125358a950f74afb6dc6880cc29ef8d47086d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/amlogic/phy-meson-gxl-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n \n#define U2P_R0\t\t\t\t\t\t\t0x0\n\t#define U2P_R0_BYPASS_SEL\t\t\t\tBIT(0)\n\t#define U2P_R0_BYPASS_DM_EN\t\t\t\tBIT(1)\n\t#define U2P_R0_BYPASS_DP_EN\t\t\t\tBIT(2)\n\t#define U2P_R0_TXBITSTUFF_ENH\t\t\t\tBIT(3)\n\t#define U2P_R0_TXBITSTUFF_EN\t\t\t\tBIT(4)\n\t#define U2P_R0_DM_PULLDOWN\t\t\t\tBIT(5)\n\t#define U2P_R0_DP_PULLDOWN\t\t\t\tBIT(6)\n\t#define U2P_R0_DP_VBUS_VLD_EXT_SEL\t\t\tBIT(7)\n\t#define U2P_R0_DP_VBUS_VLD_EXT\t\t\t\tBIT(8)\n\t#define U2P_R0_ADP_PRB_EN\t\t\t\tBIT(9)\n\t#define U2P_R0_ADP_DISCHARGE\t\t\t\tBIT(10)\n\t#define U2P_R0_ADP_CHARGE\t\t\t\tBIT(11)\n\t#define U2P_R0_DRV_VBUS\t\t\t\t\tBIT(12)\n\t#define U2P_R0_ID_PULLUP\t\t\t\tBIT(13)\n\t#define U2P_R0_LOOPBACK_EN_B\t\t\t\tBIT(14)\n\t#define U2P_R0_OTG_DISABLE\t\t\t\tBIT(15)\n\t#define U2P_R0_COMMON_ONN\t\t\t\tBIT(16)\n\t#define U2P_R0_FSEL_MASK\t\t\t\tGENMASK(19, 17)\n\t#define U2P_R0_REF_CLK_SEL_MASK\t\t\t\tGENMASK(21, 20)\n\t#define U2P_R0_POWER_ON_RESET\t\t\t\tBIT(22)\n\t#define U2P_R0_V_ATE_TEST_EN_B_MASK\t\t\tGENMASK(24, 23)\n\t#define U2P_R0_ID_SET_ID_DQ\t\t\t\tBIT(25)\n\t#define U2P_R0_ATE_RESET\t\t\t\tBIT(26)\n\t#define U2P_R0_FSV_MINUS\t\t\t\tBIT(27)\n\t#define U2P_R0_FSV_PLUS\t\t\t\t\tBIT(28)\n\t#define U2P_R0_BYPASS_DM_DATA\t\t\t\tBIT(29)\n\t#define U2P_R0_BYPASS_DP_DATA\t\t\t\tBIT(30)\n\n#define U2P_R1\t\t\t\t\t\t\t0x4\n\t#define U2P_R1_BURN_IN_TEST\t\t\t\tBIT(0)\n\t#define U2P_R1_ACA_ENABLE\t\t\t\tBIT(1)\n\t#define U2P_R1_DCD_ENABLE\t\t\t\tBIT(2)\n\t#define U2P_R1_VDAT_SRC_EN_B\t\t\t\tBIT(3)\n\t#define U2P_R1_VDAT_DET_EN_B\t\t\t\tBIT(4)\n\t#define U2P_R1_CHARGES_SEL\t\t\t\tBIT(5)\n\t#define U2P_R1_TX_PREEMP_PULSE_TUNE\t\t\tBIT(6)\n\t#define U2P_R1_TX_PREEMP_AMP_TUNE_MASK\t\t\tGENMASK(8, 7)\n\t#define U2P_R1_TX_RES_TUNE_MASK\t\t\t\tGENMASK(10, 9)\n\t#define U2P_R1_TX_RISE_TUNE_MASK\t\t\tGENMASK(12, 11)\n\t#define U2P_R1_TX_VREF_TUNE_MASK\t\t\tGENMASK(16, 13)\n\t#define U2P_R1_TX_FSLS_TUNE_MASK\t\t\tGENMASK(20, 17)\n\t#define U2P_R1_TX_HSXV_TUNE_MASK\t\t\tGENMASK(22, 21)\n\t#define U2P_R1_OTG_TUNE_MASK\t\t\t\tGENMASK(25, 23)\n\t#define U2P_R1_SQRX_TUNE_MASK\t\t\t\tGENMASK(28, 26)\n\t#define U2P_R1_COMP_DIS_TUNE_MASK\t\t\tGENMASK(31, 29)\n\n \n#define U2P_R2\t\t\t\t\t\t\t0x8\n\t#define U2P_R2_TESTDATA_IN_MASK\t\t\t\tGENMASK(7, 0)\n\t#define U2P_R2_TESTADDR_MASK\t\t\t\tGENMASK(11, 8)\n\t#define U2P_R2_TESTDATA_OUT_SEL\t\t\t\tBIT(12)\n\t#define U2P_R2_TESTCLK\t\t\t\t\tBIT(13)\n\t#define U2P_R2_TESTDATA_OUT_MASK\t\t\tGENMASK(17, 14)\n\t#define U2P_R2_ACA_PIN_RANGE_C\t\t\t\tBIT(18)\n\t#define U2P_R2_ACA_PIN_RANGE_B\t\t\t\tBIT(19)\n\t#define U2P_R2_ACA_PIN_RANGE_A\t\t\t\tBIT(20)\n\t#define U2P_R2_ACA_PIN_GND\t\t\t\tBIT(21)\n\t#define U2P_R2_ACA_PIN_FLOAT\t\t\t\tBIT(22)\n\t#define U2P_R2_CHARGE_DETECT\t\t\t\tBIT(23)\n\t#define U2P_R2_DEVICE_SESSION_VALID\t\t\tBIT(24)\n\t#define U2P_R2_ADP_PROBE\t\t\t\tBIT(25)\n\t#define U2P_R2_ADP_SENSE\t\t\t\tBIT(26)\n\t#define U2P_R2_SESSION_END\t\t\t\tBIT(27)\n\t#define U2P_R2_VBUS_VALID\t\t\t\tBIT(28)\n\t#define U2P_R2_B_VALID\t\t\t\t\tBIT(29)\n\t#define U2P_R2_A_VALID\t\t\t\t\tBIT(30)\n\t#define U2P_R2_ID_DIG\t\t\t\t\tBIT(31)\n\n#define U2P_R3\t\t\t\t\t\t\t0xc\n\n#define RESET_COMPLETE_TIME\t\t\t\t500\n\nstruct phy_meson_gxl_usb2_priv {\n\tstruct regmap\t\t*regmap;\n\tenum phy_mode\t\tmode;\n\tint\t\t\tis_enabled;\n\tstruct clk\t\t*clk;\n\tstruct reset_control\t*reset;\n};\n\nstatic const struct regmap_config phy_meson_gxl_usb2_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = U2P_R3,\n};\n\nstatic int phy_meson_gxl_usb2_init(struct phy *phy)\n{\n\tstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = reset_control_reset(priv->reset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\treset_control_rearm(priv->reset);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int phy_meson_gxl_usb2_exit(struct phy *phy)\n{\n\tstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(priv->clk);\n\treset_control_rearm(priv->reset);\n\n\treturn 0;\n}\n\nstatic int phy_meson_gxl_usb2_reset(struct phy *phy)\n{\n\tstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->is_enabled) {\n\t\t \n\t\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_POWER_ON_RESET,\n\t\t\t\t   U2P_R0_POWER_ON_RESET);\n\t\tudelay(RESET_COMPLETE_TIME);\n\t\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_POWER_ON_RESET,\n\t\t\t\t   0);\n\t\tudelay(RESET_COMPLETE_TIME);\n\t}\n\n\treturn 0;\n}\n\nstatic int phy_meson_gxl_usb2_set_mode(struct phy *phy,\n\t\t\t\t       enum phy_mode mode, int submode)\n{\n\tstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\n\n\tswitch (mode) {\n\tcase PHY_MODE_USB_HOST:\n\tcase PHY_MODE_USB_OTG:\n\t\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_DM_PULLDOWN,\n\t\t\t\t   U2P_R0_DM_PULLDOWN);\n\t\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_DP_PULLDOWN,\n\t\t\t\t   U2P_R0_DP_PULLDOWN);\n\t\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_ID_PULLUP,\n\t\t\t\t   U2P_R0_ID_PULLUP);\n\t\tbreak;\n\n\tcase PHY_MODE_USB_DEVICE:\n\t\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_DM_PULLDOWN,\n\t\t\t\t   0);\n\t\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_DP_PULLDOWN,\n\t\t\t\t   0);\n\t\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_ID_PULLUP,\n\t\t\t\t   U2P_R0_ID_PULLUP);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tphy_meson_gxl_usb2_reset(phy);\n\n\tpriv->mode = mode;\n\n\treturn 0;\n}\n\nstatic int phy_meson_gxl_usb2_power_off(struct phy *phy)\n{\n\tstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\n\n\tpriv->is_enabled = 0;\n\n\t \n\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_POWER_ON_RESET,\n\t\t\t   U2P_R0_POWER_ON_RESET);\n\n\treturn 0;\n}\n\nstatic int phy_meson_gxl_usb2_power_on(struct phy *phy)\n{\n\tstruct phy_meson_gxl_usb2_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tpriv->is_enabled = 1;\n\n\t \n\tregmap_update_bits(priv->regmap, U2P_R0, U2P_R0_POWER_ON_RESET, 0);\n\n\tret = phy_meson_gxl_usb2_set_mode(phy, priv->mode, 0);\n\tif (ret) {\n\t\tphy_meson_gxl_usb2_power_off(phy);\n\n\t\tdev_err(&phy->dev, \"Failed to initialize PHY with mode %d\\n\",\n\t\t\tpriv->mode);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct phy_ops phy_meson_gxl_usb2_ops = {\n\t.init\t\t= phy_meson_gxl_usb2_init,\n\t.exit\t\t= phy_meson_gxl_usb2_exit,\n\t.power_on\t= phy_meson_gxl_usb2_power_on,\n\t.power_off\t= phy_meson_gxl_usb2_power_off,\n\t.set_mode\t= phy_meson_gxl_usb2_set_mode,\n\t.reset\t\t= phy_meson_gxl_usb2_reset,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int phy_meson_gxl_usb2_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tstruct phy_meson_gxl_usb2_priv *priv;\n\tstruct phy *phy;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\t \n\tpriv->mode = PHY_MODE_USB_HOST;\n\n\tpriv->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t     &phy_meson_gxl_usb2_regmap_conf);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->clk = devm_clk_get_optional(dev, \"phy\");\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpriv->reset = devm_reset_control_get_optional_shared(dev, \"phy\");\n\tif (IS_ERR(priv->reset))\n\t\treturn PTR_ERR(priv->reset);\n\n\tphy = devm_phy_create(dev, NULL, &phy_meson_gxl_usb2_ops);\n\tif (IS_ERR(phy)) {\n\t\tret = PTR_ERR(phy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to create PHY\\n\");\n\n\t\treturn ret;\n\t}\n\n\tphy_set_drvdata(phy, priv);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id phy_meson_gxl_usb2_of_match[] = {\n\t{ .compatible = \"amlogic,meson-gxl-usb2-phy\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, phy_meson_gxl_usb2_of_match);\n\nstatic struct platform_driver phy_meson_gxl_usb2_driver = {\n\t.probe\t= phy_meson_gxl_usb2_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"phy-meson-gxl-usb2\",\n\t\t.of_match_table\t= phy_meson_gxl_usb2_of_match,\n\t},\n};\nmodule_platform_driver(phy_meson_gxl_usb2_driver);\n\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_DESCRIPTION(\"Meson GXL and GXM USB2 PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}