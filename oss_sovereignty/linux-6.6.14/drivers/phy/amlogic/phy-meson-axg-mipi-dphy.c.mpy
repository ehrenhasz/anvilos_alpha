{
  "module_name": "phy-meson-axg-mipi-dphy.c",
  "hash_id": "4f3f7305001e6cc50863acbd54a22952e8c6b7576108b2d9181023c890cc3958",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/amlogic/phy-meson-axg-mipi-dphy.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n \n#define MIPI_DSI_PHY_CTRL\t\t\t\t0x0\n\n \n#define MIPI_DSI_CHAN_CTRL\t\t\t\t0x4\n\n \n#define MIPI_DSI_CHAN_STS\t\t\t\t0x8\n\n \n#define MIPI_DSI_CLK_TIM\t\t\t\t0xc\n\n \n#define MIPI_DSI_HS_TIM\t\t\t\t\t0x10\n\n \n#define MIPI_DSI_LP_TIM\t\t\t\t\t0x14\n\n \n#define MIPI_DSI_ANA_UP_TIM\t\t\t\t0x18\n\n \n#define MIPI_DSI_INIT_TIM\t\t\t\t0x1c\n\n \n#define MIPI_DSI_WAKEUP_TIM\t\t\t\t0x20\n\n \n#define MIPI_DSI_LPOK_TIM\t\t\t\t0x24\n\n \n#define MIPI_DSI_LP_WCHDOG\t\t\t\t0x28\n\n \n#define MIPI_DSI_ANA_CTRL\t\t\t\t0x2c\n\n \n#define MIPI_DSI_CLK_TIM1\t\t\t\t0x30\n\n \n#define MIPI_DSI_TURN_WCHDOG\t\t\t\t0x34\n\n \n#define MIPI_DSI_ULPS_CHECK\t\t\t\t0x38\n#define MIPI_DSI_TEST_CTRL0\t\t\t\t0x3c\n#define MIPI_DSI_TEST_CTRL1\t\t\t\t0x40\n\nstruct phy_meson_axg_mipi_dphy_priv {\n\tstruct device\t\t\t\t*dev;\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct clk\t\t\t\t*clk;\n\tstruct reset_control\t\t\t*reset;\n\tstruct phy\t\t\t\t*analog;\n\tstruct phy_configure_opts_mipi_dphy\tconfig;\n};\n\nstatic const struct regmap_config phy_meson_axg_mipi_dphy_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = MIPI_DSI_TEST_CTRL1,\n};\n\nstatic int phy_meson_axg_mipi_dphy_init(struct phy *phy)\n{\n\tstruct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_init(priv->analog);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_reset(priv->reset);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int phy_meson_axg_mipi_dphy_configure(struct phy *phy,\n\t\t\t\t\t      union phy_configure_opts *opts)\n{\n\tstruct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_mipi_dphy_config_validate(&opts->mipi_dphy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_configure(priv->analog, opts);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&priv->config, opts, sizeof(priv->config));\n\n\treturn 0;\n}\n\nstatic int phy_meson_axg_mipi_dphy_power_on(struct phy *phy)\n{\n\tstruct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\tunsigned long temp;\n\n\tret = phy_power_on(priv->analog);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_write(priv->regmap, MIPI_DSI_PHY_CTRL,  0x1);\n\tregmap_write(priv->regmap, MIPI_DSI_PHY_CTRL,\n\t\t     BIT(0) |  \n\t\t     BIT(7) |  \n\t\t     BIT(8));  \n\n\t \n\tregmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(9), BIT(9));\n\n\t \n\tregmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(12), BIT(12));\n\tregmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(31), BIT(31));\n\tregmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(31), 0);\n\n\t \n\ttemp = (1000000 * 100) / (priv->config.hs_clk_rate / 1000);\n\ttemp = temp * 8 * 10;\n\n\tregmap_write(priv->regmap, MIPI_DSI_CLK_TIM,\n\t\t     DIV_ROUND_UP(priv->config.clk_trail, temp) |\n\t\t     (DIV_ROUND_UP(priv->config.clk_post +\n\t\t\t\t   priv->config.hs_trail, temp) << 8) |\n\t\t     (DIV_ROUND_UP(priv->config.clk_zero, temp) << 16) |\n\t\t     (DIV_ROUND_UP(priv->config.clk_prepare, temp) << 24));\n\tregmap_write(priv->regmap, MIPI_DSI_CLK_TIM1,\n\t\t     DIV_ROUND_UP(priv->config.clk_pre, BITS_PER_BYTE));\n\n\tregmap_write(priv->regmap, MIPI_DSI_HS_TIM,\n\t\t     DIV_ROUND_UP(priv->config.hs_exit, temp) |\n\t\t     (DIV_ROUND_UP(priv->config.hs_trail, temp) << 8) |\n\t\t     (DIV_ROUND_UP(priv->config.hs_zero, temp) << 16) |\n\t\t     (DIV_ROUND_UP(priv->config.hs_prepare, temp) << 24));\n\n\tregmap_write(priv->regmap, MIPI_DSI_LP_TIM,\n\t\t     DIV_ROUND_UP(priv->config.lpx, temp) |\n\t\t     (DIV_ROUND_UP(priv->config.ta_sure, temp) << 8) |\n\t\t     (DIV_ROUND_UP(priv->config.ta_go, temp) << 16) |\n\t\t     (DIV_ROUND_UP(priv->config.ta_get, temp) << 24));\n\n\tregmap_write(priv->regmap, MIPI_DSI_ANA_UP_TIM, 0x0100);\n\tregmap_write(priv->regmap, MIPI_DSI_INIT_TIM,\n\t\t     DIV_ROUND_UP(priv->config.init * NSEC_PER_MSEC, temp));\n\tregmap_write(priv->regmap, MIPI_DSI_WAKEUP_TIM,\n\t\t     DIV_ROUND_UP(priv->config.wakeup * NSEC_PER_MSEC, temp));\n\tregmap_write(priv->regmap, MIPI_DSI_LPOK_TIM, 0x7C);\n\tregmap_write(priv->regmap, MIPI_DSI_ULPS_CHECK, 0x927C);\n\tregmap_write(priv->regmap, MIPI_DSI_LP_WCHDOG, 0x1000);\n\tregmap_write(priv->regmap, MIPI_DSI_TURN_WCHDOG, 0x1000);\n\n\t \n\tswitch (priv->config.lanes) {\n\tcase 1:\n\t\tregmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0xe);\n\t\tbreak;\n\tcase 2:\n\t\tregmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0xc);\n\t\tbreak;\n\tcase 3:\n\t\tregmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0x8);\n\t\tbreak;\n\tcase 4:\n\tdefault:\n\t\tregmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0);\n\t\tbreak;\n\t}\n\n\t \n\tregmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(1), BIT(1));\n\n\treturn 0;\n}\n\nstatic int phy_meson_axg_mipi_dphy_power_off(struct phy *phy)\n{\n\tstruct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);\n\n\tregmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0xf);\n\tregmap_write(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(31));\n\n\tphy_power_off(priv->analog);\n\n\treturn 0;\n}\n\nstatic int phy_meson_axg_mipi_dphy_exit(struct phy *phy)\n{\n\tstruct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_exit(priv->analog);\n\tif (ret)\n\t\treturn ret;\n\n\treturn reset_control_reset(priv->reset);\n}\n\nstatic const struct phy_ops phy_meson_axg_mipi_dphy_ops = {\n\t.configure\t= phy_meson_axg_mipi_dphy_configure,\n\t.init\t\t= phy_meson_axg_mipi_dphy_init,\n\t.exit\t\t= phy_meson_axg_mipi_dphy_exit,\n\t.power_on\t= phy_meson_axg_mipi_dphy_power_on,\n\t.power_off\t= phy_meson_axg_mipi_dphy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int phy_meson_axg_mipi_dphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tstruct phy_meson_axg_mipi_dphy_priv *priv;\n\tstruct phy *phy;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tplatform_set_drvdata(pdev, priv);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t&phy_meson_axg_mipi_dphy_regmap_conf);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->clk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpriv->reset = devm_reset_control_get(dev, \"phy\");\n\tif (IS_ERR(priv->reset))\n\t\treturn PTR_ERR(priv->reset);\n\n\tpriv->analog = devm_phy_get(dev, \"analog\");\n\tif (IS_ERR(priv->analog))\n\t\treturn PTR_ERR(priv->analog);\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_deassert(priv->reset);\n\tif (ret)\n\t\treturn ret;\n\n\tphy = devm_phy_create(dev, NULL, &phy_meson_axg_mipi_dphy_ops);\n\tif (IS_ERR(phy)) {\n\t\tret = PTR_ERR(phy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to create PHY\\n\");\n\n\t\treturn ret;\n\t}\n\n\tphy_set_drvdata(phy, priv);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id phy_meson_axg_mipi_dphy_of_match[] = {\n\t{ .compatible = \"amlogic,axg-mipi-dphy\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, phy_meson_axg_mipi_dphy_of_match);\n\nstatic struct platform_driver phy_meson_axg_mipi_dphy_driver = {\n\t.probe\t= phy_meson_axg_mipi_dphy_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"phy-meson-axg-mipi-dphy\",\n\t\t.of_match_table\t= phy_meson_axg_mipi_dphy_of_match,\n\t},\n};\nmodule_platform_driver(phy_meson_axg_mipi_dphy_driver);\n\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_DESCRIPTION(\"Meson AXG MIPI DPHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}