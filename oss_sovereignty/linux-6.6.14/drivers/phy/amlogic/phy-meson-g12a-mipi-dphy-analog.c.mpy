{
  "module_name": "phy-meson-g12a-mipi-dphy-analog.c",
  "hash_id": "f1429ec756b120d82e5a06a3951b86a4cb32285299cc867fe55864f436f868fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/amlogic/phy-meson-g12a-mipi-dphy-analog.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/phy/phy.h>\n\n#define HHI_MIPI_CNTL0 0x00\n#define\t\tHHI_MIPI_CNTL0_DIF_REF_CTL1\tGENMASK(31, 16)\n#define\t\tHHI_MIPI_CNTL0_DIF_REF_CTL0\tGENMASK(15, 0)\n\n#define HHI_MIPI_CNTL1 0x04\n#define\t\tHHI_MIPI_CNTL1_BANDGAP\t\tBIT(16)\n#define\t\tHHI_MIPI_CNTL2_DIF_REF_CTL2\tGENMASK(15, 0)\n\n#define HHI_MIPI_CNTL2 0x08\n#define\t\tHHI_MIPI_CNTL2_DIF_TX_CTL1\tGENMASK(31, 16)\n#define\t\tHHI_MIPI_CNTL2_CH_EN\t\tGENMASK(15, 11)\n#define\t\tHHI_MIPI_CNTL2_DIF_TX_CTL0\tGENMASK(10, 0)\n\n#define DSI_LANE_0\t\t\t\tBIT(4)\n#define DSI_LANE_1\t\t\t\tBIT(3)\n#define DSI_LANE_CLK\t\t\t\tBIT(2)\n#define DSI_LANE_2\t\t\t\tBIT(1)\n#define DSI_LANE_3\t\t\t\tBIT(0)\n\nstruct phy_g12a_mipi_dphy_analog_priv {\n\tstruct phy *phy;\n\tstruct regmap *regmap;\n\tstruct phy_configure_opts_mipi_dphy config;\n};\n\nstatic int phy_g12a_mipi_dphy_analog_configure(struct phy *phy,\n\t\t\t\t\t       union phy_configure_opts *opts)\n{\n\tstruct phy_g12a_mipi_dphy_analog_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_mipi_dphy_config_validate(&opts->mipi_dphy);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&priv->config, opts, sizeof(priv->config));\n\n\treturn 0;\n}\n\nstatic int phy_g12a_mipi_dphy_analog_power_on(struct phy *phy)\n{\n\tstruct phy_g12a_mipi_dphy_analog_priv *priv = phy_get_drvdata(phy);\n\tunsigned int reg;\n\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL0,\n\t\t     FIELD_PREP(HHI_MIPI_CNTL0_DIF_REF_CTL0, 0x8) |\n\t\t     FIELD_PREP(HHI_MIPI_CNTL0_DIF_REF_CTL1, 0xa487));\n\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL1,\n\t\t     FIELD_PREP(HHI_MIPI_CNTL2_DIF_REF_CTL2, 0x2e) |\n\t\t     HHI_MIPI_CNTL1_BANDGAP);\n\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL2,\n\t\t     FIELD_PREP(HHI_MIPI_CNTL2_DIF_TX_CTL0, 0x45a) |\n\t\t     FIELD_PREP(HHI_MIPI_CNTL2_DIF_TX_CTL1, 0x2680));\n\n\treg = DSI_LANE_CLK;\n\tswitch (priv->config.lanes) {\n\tcase 4:\n\t\treg |= DSI_LANE_3;\n\t\tfallthrough;\n\tcase 3:\n\t\treg |= DSI_LANE_2;\n\t\tfallthrough;\n\tcase 2:\n\t\treg |= DSI_LANE_1;\n\t\tfallthrough;\n\tcase 1:\n\t\treg |= DSI_LANE_0;\n\t\tbreak;\n\tdefault:\n\t\treg = 0;\n\t}\n\n\tregmap_update_bits(priv->regmap, HHI_MIPI_CNTL2,\n\t\t\t   HHI_MIPI_CNTL2_CH_EN,\n\t\t\t   FIELD_PREP(HHI_MIPI_CNTL2_CH_EN, reg));\n\n\treturn 0;\n}\n\nstatic int phy_g12a_mipi_dphy_analog_power_off(struct phy *phy)\n{\n\tstruct phy_g12a_mipi_dphy_analog_priv *priv = phy_get_drvdata(phy);\n\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL0, 0);\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL1, 0);\n\tregmap_write(priv->regmap, HHI_MIPI_CNTL2, 0);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops phy_g12a_mipi_dphy_analog_ops = {\n\t.configure = phy_g12a_mipi_dphy_analog_configure,\n\t.power_on = phy_g12a_mipi_dphy_analog_power_on,\n\t.power_off = phy_g12a_mipi_dphy_analog_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic int phy_g12a_mipi_dphy_analog_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_g12a_mipi_dphy_analog_priv *priv;\n\tstruct device_node *np = dev->of_node, *parent_np;\n\tstruct regmap *map;\n\n\tpriv = devm_kmalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tparent_np = of_get_parent(np);\n\tmap = syscon_node_to_regmap(parent_np);\n\tof_node_put(parent_np);\n\tif (IS_ERR(map))\n\t\treturn dev_err_probe(dev, PTR_ERR(map), \"failed to get HHI regmap\\n\");\n\n\tpriv->regmap = map;\n\n\tpriv->phy = devm_phy_create(dev, np, &phy_g12a_mipi_dphy_analog_ops);\n\tif (IS_ERR(priv->phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->phy), \"failed to create PHY\\n\");\n\n\tphy_set_drvdata(priv->phy, priv);\n\tdev_set_drvdata(dev, priv);\n\n\tphy = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy);\n}\n\nstatic const struct of_device_id phy_g12a_mipi_dphy_analog_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,g12a-mipi-dphy-analog\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, phy_g12a_mipi_dphy_analog_of_match);\n\nstatic struct platform_driver phy_g12a_mipi_dphy_analog_driver = {\n\t.probe = phy_g12a_mipi_dphy_analog_probe,\n\t.driver = {\n\t\t.name = \"phy-meson-g12a-mipi-dphy-analog\",\n\t\t.of_match_table = phy_g12a_mipi_dphy_analog_of_match,\n\t},\n};\nmodule_platform_driver(phy_g12a_mipi_dphy_analog_driver);\n\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_DESCRIPTION(\"Meson G12A MIPI Analog D-PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}