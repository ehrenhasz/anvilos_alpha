{
  "module_name": "phy-meson-axg-pcie.c",
  "hash_id": "c64e67dcc41880f8029012057443b64ce216b048e1ea7fabe119eec0c1157263",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/amlogic/phy-meson-axg-pcie.c",
  "human_readable_source": "\n \n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/platform_device.h>\n#include <linux/bitfield.h>\n#include <dt-bindings/phy/phy.h>\n\n#define MESON_PCIE_REG0 0x00\n#define\t\tMESON_PCIE_COMMON_CLK\tBIT(4)\n#define\t\tMESON_PCIE_PORT_SEL\tGENMASK(3, 2)\n#define\t\tMESON_PCIE_CLK\t\tBIT(1)\n#define\t\tMESON_PCIE_POWERDOWN\tBIT(0)\n\n#define MESON_PCIE_TWO_X1\t\tFIELD_PREP(MESON_PCIE_PORT_SEL, 0x3)\n#define MESON_PCIE_COMMON_REF_CLK\tFIELD_PREP(MESON_PCIE_COMMON_CLK, 0x1)\n#define MESON_PCIE_PHY_INIT\t\t(MESON_PCIE_TWO_X1 |\t\t\\\n\t\t\t\t\t MESON_PCIE_COMMON_REF_CLK)\n#define MESON_PCIE_RESET_DELAY\t\t500\n\nstruct phy_axg_pcie_priv {\n\tstruct phy *phy;\n\tstruct phy *analog;\n\tstruct regmap *regmap;\n\tstruct reset_control *reset;\n};\n\nstatic const struct regmap_config phy_axg_pcie_regmap_conf = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = MESON_PCIE_REG0,\n};\n\nstatic int phy_axg_pcie_power_on(struct phy *phy)\n{\n\tstruct phy_axg_pcie_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_power_on(priv->analog);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tregmap_update_bits(priv->regmap, MESON_PCIE_REG0,\n\t\t\t   MESON_PCIE_POWERDOWN, 0);\n\treturn 0;\n}\n\nstatic int phy_axg_pcie_power_off(struct phy *phy)\n{\n\tstruct phy_axg_pcie_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_power_off(priv->analog);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tregmap_update_bits(priv->regmap, MESON_PCIE_REG0,\n\t\t\t   MESON_PCIE_POWERDOWN, 1);\n\treturn 0;\n}\n\nstatic int phy_axg_pcie_init(struct phy *phy)\n{\n\tstruct phy_axg_pcie_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_init(priv->analog);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tregmap_write(priv->regmap, MESON_PCIE_REG0, MESON_PCIE_PHY_INIT);\n\treturn reset_control_reset(priv->reset);\n}\n\nstatic int phy_axg_pcie_exit(struct phy *phy)\n{\n\tstruct phy_axg_pcie_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = phy_exit(priv->analog);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn reset_control_reset(priv->reset);\n}\n\nstatic int phy_axg_pcie_reset(struct phy *phy)\n{\n\tstruct phy_axg_pcie_priv *priv = phy_get_drvdata(phy);\n\tint ret = 0;\n\n\tret = phy_reset(priv->analog);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = reset_control_assert(priv->reset);\n\tif (ret != 0)\n\t\tgoto out;\n\tudelay(MESON_PCIE_RESET_DELAY);\n\n\tret = reset_control_deassert(priv->reset);\n\tif (ret != 0)\n\t\tgoto out;\n\tudelay(MESON_PCIE_RESET_DELAY);\n\nout:\n\treturn ret;\n}\n\nstatic const struct phy_ops phy_axg_pcie_ops = {\n\t.init = phy_axg_pcie_init,\n\t.exit = phy_axg_pcie_exit,\n\t.power_on = phy_axg_pcie_power_on,\n\t.power_off = phy_axg_pcie_power_off,\n\t.reset = phy_axg_pcie_reset,\n\t.owner = THIS_MODULE,\n};\n\nstatic int phy_axg_pcie_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *pphy;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_axg_pcie_priv *priv;\n\tstruct device_node *np = dev->of_node;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpriv = devm_kmalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->phy = devm_phy_create(dev, np, &phy_axg_pcie_ops);\n\tif (IS_ERR(priv->phy)) {\n\t\tret = PTR_ERR(priv->phy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn ret;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t     &phy_axg_pcie_regmap_conf);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tpriv->reset = devm_reset_control_array_get_exclusive(dev);\n\tif (IS_ERR(priv->reset))\n\t\treturn PTR_ERR(priv->reset);\n\n\tpriv->analog = devm_phy_get(dev, \"analog\");\n\tif (IS_ERR(priv->analog))\n\t\treturn PTR_ERR(priv->analog);\n\n\tphy_set_drvdata(priv->phy, priv);\n\tdev_set_drvdata(dev, priv);\n\tpphy = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(pphy);\n}\n\nstatic const struct of_device_id phy_axg_pcie_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-pcie-phy\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, phy_axg_pcie_of_match);\n\nstatic struct platform_driver phy_axg_pcie_driver = {\n\t.probe = phy_axg_pcie_probe,\n\t.driver = {\n\t\t.name = \"phy-axg-pcie\",\n\t\t.of_match_table = phy_axg_pcie_of_match,\n\t},\n};\nmodule_platform_driver(phy_axg_pcie_driver);\n\nMODULE_AUTHOR(\"Remi Pommarel <repk@triplefau.lt>\");\nMODULE_DESCRIPTION(\"Amlogic AXG PCIE PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}