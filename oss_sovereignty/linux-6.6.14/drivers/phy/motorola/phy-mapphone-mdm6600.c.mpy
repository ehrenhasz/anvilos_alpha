{
  "module_name": "phy-mapphone-mdm6600.c",
  "hash_id": "ca14708552a58fcde600ccabf5ccea23deb997e6b48de6bb9444a555aa8aed70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/motorola/phy-mapphone-mdm6600.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/pinctrl/consumer.h>\n\n#define PHY_MDM6600_PHY_DELAY_MS\t4000\t \n#define PHY_MDM6600_ENABLED_DELAY_MS\t8000\t \n#define PHY_MDM6600_WAKE_KICK_MS\t600\t \n#define MDM6600_MODEM_IDLE_DELAY_MS\t1000\t \n#define MDM6600_MODEM_WAKE_DELAY_MS\t200\t \n\nenum phy_mdm6600_ctrl_lines {\n\tPHY_MDM6600_ENABLE,\t\t\t \n\tPHY_MDM6600_POWER,\t\t\t \n\tPHY_MDM6600_RESET,\t\t\t \n\tPHY_MDM6600_NR_CTRL_LINES,\n};\n\nenum phy_mdm6600_bootmode_lines {\n\tPHY_MDM6600_MODE0,\t\t\t \n\tPHY_MDM6600_MODE1,\t\t\t \n\tPHY_MDM6600_NR_MODE_LINES,\n};\n\nenum phy_mdm6600_cmd_lines {\n\tPHY_MDM6600_CMD0,\n\tPHY_MDM6600_CMD1,\n\tPHY_MDM6600_CMD2,\n\tPHY_MDM6600_NR_CMD_LINES,\n};\n\nenum phy_mdm6600_status_lines {\n\tPHY_MDM6600_STATUS0,\n\tPHY_MDM6600_STATUS1,\n\tPHY_MDM6600_STATUS2,\n\tPHY_MDM6600_NR_STATUS_LINES,\n};\n\n \nenum phy_mdm6600_cmd {\n\tPHY_MDM6600_CMD_BP_PANIC_ACK,\n\tPHY_MDM6600_CMD_DATA_ONLY_BYPASS,\t \n\tPHY_MDM6600_CMD_FULL_BYPASS,\t\t \n\tPHY_MDM6600_CMD_NO_BYPASS,\t\t \n\tPHY_MDM6600_CMD_BP_SHUTDOWN_REQ,\t \n\tPHY_MDM6600_CMD_BP_UNKNOWN_5,\n\tPHY_MDM6600_CMD_BP_UNKNOWN_6,\n\tPHY_MDM6600_CMD_UNDEFINED,\n};\n\n \nenum phy_mdm6600_status {\n\tPHY_MDM6600_STATUS_PANIC,\t\t \n\tPHY_MDM6600_STATUS_PANIC_BUSY_WAIT,\n\tPHY_MDM6600_STATUS_QC_DLOAD,\n\tPHY_MDM6600_STATUS_RAM_DOWNLOADER,\t \n\tPHY_MDM6600_STATUS_PHONE_CODE_AWAKE,\t \n\tPHY_MDM6600_STATUS_PHONE_CODE_ASLEEP,\n\tPHY_MDM6600_STATUS_SHUTDOWN_ACK,\n\tPHY_MDM6600_STATUS_UNDEFINED,\n};\n\nstatic const char * const\nphy_mdm6600_status_name[] = {\n\t\"off\", \"busy\", \"qc_dl\", \"ram_dl\", \"awake\",\n\t\"asleep\", \"shutdown\", \"undefined\",\n};\n\nstruct phy_mdm6600 {\n\tstruct device *dev;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct gpio_desc *ctrl_gpios[PHY_MDM6600_NR_CTRL_LINES];\n\tstruct gpio_descs *mode_gpios;\n\tstruct gpio_descs *status_gpios;\n\tstruct gpio_descs *cmd_gpios;\n\tstruct delayed_work bootup_work;\n\tstruct delayed_work status_work;\n\tstruct delayed_work modem_wake_work;\n\tstruct completion ack;\n\tbool enabled;\t\t\t\t \n\tbool running;\t\t\t\t \n\tbool awake;\t\t\t\t \n\tint status;\n};\n\nstatic int phy_mdm6600_init(struct phy *x)\n{\n\tstruct phy_mdm6600 *ddata = phy_get_drvdata(x);\n\tstruct gpio_desc *enable_gpio = ddata->ctrl_gpios[PHY_MDM6600_ENABLE];\n\n\tif (!ddata->enabled)\n\t\treturn -EPROBE_DEFER;\n\n\tgpiod_set_value_cansleep(enable_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int phy_mdm6600_power_on(struct phy *x)\n{\n\tstruct phy_mdm6600 *ddata = phy_get_drvdata(x);\n\tstruct gpio_desc *enable_gpio = ddata->ctrl_gpios[PHY_MDM6600_ENABLE];\n\n\tif (!ddata->enabled)\n\t\treturn -ENODEV;\n\n\tgpiod_set_value_cansleep(enable_gpio, 1);\n\n\t \n\tif (pm_runtime_enabled(&x->dev))\n\t\tphy_pm_runtime_put(x);\n\n\treturn 0;\n}\n\nstatic int phy_mdm6600_power_off(struct phy *x)\n{\n\tstruct phy_mdm6600 *ddata = phy_get_drvdata(x);\n\tstruct gpio_desc *enable_gpio = ddata->ctrl_gpios[PHY_MDM6600_ENABLE];\n\tint error;\n\n\tif (!ddata->enabled)\n\t\treturn -ENODEV;\n\n\t \n\tif (pm_runtime_enabled(&x->dev)) {\n\t\terror = phy_pm_runtime_get(x);\n\t\tif (error < 0 && error != -EINPROGRESS)\n\t\t\tdev_warn(ddata->dev, \"%s: phy_pm_runtime_get: %i\\n\",\n\t\t\t\t __func__, error);\n\t}\n\n\tgpiod_set_value_cansleep(enable_gpio, 0);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops gpio_usb_ops = {\n\t.init = phy_mdm6600_init,\n\t.power_on = phy_mdm6600_power_on,\n\t.power_off = phy_mdm6600_power_off,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic void phy_mdm6600_cmd(struct phy_mdm6600 *ddata, int val)\n{\n\tDECLARE_BITMAP(values, PHY_MDM6600_NR_CMD_LINES);\n\n\tvalues[0] = val;\n\n\tgpiod_set_array_value_cansleep(PHY_MDM6600_NR_CMD_LINES,\n\t\t\t\t       ddata->cmd_gpios->desc,\n\t\t\t\t       ddata->cmd_gpios->info, values);\n}\n\n \nstatic void phy_mdm6600_status(struct work_struct *work)\n{\n\tstruct phy_mdm6600 *ddata;\n\tstruct device *dev;\n\tDECLARE_BITMAP(values, PHY_MDM6600_NR_STATUS_LINES);\n\tint error;\n\n\tddata = container_of(work, struct phy_mdm6600, status_work.work);\n\tdev = ddata->dev;\n\n\terror = gpiod_get_array_value_cansleep(PHY_MDM6600_NR_STATUS_LINES,\n\t\t\t\t\t       ddata->status_gpios->desc,\n\t\t\t\t\t       ddata->status_gpios->info,\n\t\t\t\t\t       values);\n\tif (error)\n\t\treturn;\n\n\tddata->status = values[0] & ((1 << PHY_MDM6600_NR_STATUS_LINES) - 1);\n\n\tdev_info(dev, \"modem status: %i %s\\n\",\n\t\t ddata->status,\n\t\t phy_mdm6600_status_name[ddata->status]);\n\tcomplete(&ddata->ack);\n}\n\nstatic irqreturn_t phy_mdm6600_irq_thread(int irq, void *data)\n{\n\tstruct phy_mdm6600 *ddata = data;\n\n\tschedule_delayed_work(&ddata->status_work, msecs_to_jiffies(10));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t phy_mdm6600_wakeirq_thread(int irq, void *data)\n{\n\tstruct phy_mdm6600 *ddata = data;\n\tstruct gpio_desc *mode_gpio1;\n\tint error, wakeup;\n\n\tmode_gpio1 = ddata->mode_gpios->desc[PHY_MDM6600_MODE1];\n\twakeup = gpiod_get_value(mode_gpio1);\n\tif (!wakeup)\n\t\treturn IRQ_NONE;\n\n\tdev_dbg(ddata->dev, \"OOB wake on mode_gpio1: %i\\n\", wakeup);\n\terror = pm_runtime_get_sync(ddata->dev);\n\tif (error < 0) {\n\t\tpm_runtime_put_noidle(ddata->dev);\n\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tpm_runtime_mark_last_busy(ddata->dev);\n\tpm_runtime_put_autosuspend(ddata->dev);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void phy_mdm6600_init_irq(struct phy_mdm6600 *ddata)\n{\n\tstruct device *dev = ddata->dev;\n\tint i, error, irq;\n\n\tfor (i = PHY_MDM6600_STATUS0;\n\t     i <= PHY_MDM6600_STATUS2; i++) {\n\t\tstruct gpio_desc *gpio = ddata->status_gpios->desc[i];\n\n\t\tirq = gpiod_to_irq(gpio);\n\t\tif (irq <= 0)\n\t\t\tcontinue;\n\n\t\terror = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\tphy_mdm6600_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"mdm6600\",\n\t\t\t\t\tddata);\n\t\tif (error)\n\t\t\tdev_warn(dev, \"no modem status irq%i: %i\\n\",\n\t\t\t\t irq, error);\n\t}\n}\n\nstruct phy_mdm6600_map {\n\tconst char *name;\n\tint direction;\n};\n\nstatic const struct phy_mdm6600_map\nphy_mdm6600_ctrl_gpio_map[PHY_MDM6600_NR_CTRL_LINES] = {\n\t{ \"enable\", GPIOD_OUT_LOW, },\t\t \n\t{ \"power\", GPIOD_OUT_LOW, },\t\t \n\t{ \"reset\", GPIOD_OUT_HIGH, },\t\t \n};\n\n \nstatic int phy_mdm6600_init_lines(struct phy_mdm6600 *ddata)\n{\n\tstruct device *dev = ddata->dev;\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(phy_mdm6600_ctrl_gpio_map); i++) {\n\t\tconst struct phy_mdm6600_map *map =\n\t\t\t&phy_mdm6600_ctrl_gpio_map[i];\n\t\tstruct gpio_desc **gpio = &ddata->ctrl_gpios[i];\n\n\t\t*gpio = devm_gpiod_get(dev, map->name, map->direction);\n\t\tif (IS_ERR(*gpio)) {\n\t\t\tdev_info(dev, \"gpio %s error %li\\n\",\n\t\t\t\t map->name, PTR_ERR(*gpio));\n\t\t\treturn PTR_ERR(*gpio);\n\t\t}\n\t}\n\n\t \n\tddata->mode_gpios = devm_gpiod_get_array(dev, \"motorola,mode\",\n\t\t\t\t\t\t GPIOD_OUT_LOW);\n\tif (IS_ERR(ddata->mode_gpios))\n\t\treturn PTR_ERR(ddata->mode_gpios);\n\n\tif (ddata->mode_gpios->ndescs != PHY_MDM6600_NR_MODE_LINES)\n\t\treturn -EINVAL;\n\n\t \n\tddata->status_gpios = devm_gpiod_get_array(dev, \"motorola,status\",\n\t\t\t\t\t\t   GPIOD_IN);\n\tif (IS_ERR(ddata->status_gpios))\n\t\treturn PTR_ERR(ddata->status_gpios);\n\n\tif (ddata->status_gpios->ndescs != PHY_MDM6600_NR_STATUS_LINES)\n\t\treturn -EINVAL;\n\n\t \n\tddata->cmd_gpios = devm_gpiod_get_array(dev, \"motorola,cmd\",\n\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(ddata->cmd_gpios))\n\t\treturn PTR_ERR(ddata->cmd_gpios);\n\n\tif (ddata->cmd_gpios->ndescs != PHY_MDM6600_NR_CMD_LINES)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int phy_mdm6600_device_power_on(struct phy_mdm6600 *ddata)\n{\n\tstruct gpio_desc *mode_gpio0, *mode_gpio1, *reset_gpio, *power_gpio;\n\tint error = 0, wakeirq;\n\n\tmode_gpio0 = ddata->mode_gpios->desc[PHY_MDM6600_MODE0];\n\tmode_gpio1 = ddata->mode_gpios->desc[PHY_MDM6600_MODE1];\n\treset_gpio = ddata->ctrl_gpios[PHY_MDM6600_RESET];\n\tpower_gpio = ddata->ctrl_gpios[PHY_MDM6600_POWER];\n\n\t \n\tgpiod_set_value_cansleep(mode_gpio0, 0);\n\tgpiod_set_value_cansleep(mode_gpio1, 0);\n\n\t \n\tphy_mdm6600_cmd(ddata, PHY_MDM6600_CMD_NO_BYPASS);\n\n\t \n\tgpiod_set_value_cansleep(reset_gpio, 0);\n\tmsleep(100);\n\n\t \n\tgpiod_set_value_cansleep(power_gpio, 1);\n\tmsleep(100);\n\tgpiod_set_value_cansleep(power_gpio, 0);\n\n\t \n\tmsleep(PHY_MDM6600_PHY_DELAY_MS);\n\tddata->enabled = true;\n\n\t \n\tdev_info(ddata->dev, \"Waiting for power up request to complete..\\n\");\n\tif (wait_for_completion_timeout(&ddata->ack,\n\t\t\tmsecs_to_jiffies(PHY_MDM6600_ENABLED_DELAY_MS))) {\n\t\tif (ddata->status > PHY_MDM6600_STATUS_PANIC &&\n\t\t    ddata->status < PHY_MDM6600_STATUS_SHUTDOWN_ACK)\n\t\t\tdev_info(ddata->dev, \"Powered up OK\\n\");\n\t} else {\n\t\tddata->enabled = false;\n\t\terror = -ETIMEDOUT;\n\t\tdev_err(ddata->dev, \"Timed out powering up\\n\");\n\t}\n\n\t \n\tgpiod_direction_input(mode_gpio1);\n\n\twakeirq = gpiod_to_irq(mode_gpio1);\n\tif (wakeirq <= 0)\n\t\treturn wakeirq;\n\n\terror = devm_request_threaded_irq(ddata->dev, wakeirq, NULL,\n\t\t\t\t\t  phy_mdm6600_wakeirq_thread,\n\t\t\t\t\t  IRQF_TRIGGER_RISING |\n\t\t\t\t\t  IRQF_TRIGGER_FALLING |\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  \"mdm6600-wake\",\n\t\t\t\t\t  ddata);\n\tif (error)\n\t\tdev_warn(ddata->dev, \"no modem wakeirq irq%i: %i\\n\",\n\t\t\t wakeirq, error);\n\n\tddata->running = true;\n\n\treturn error;\n}\n\n \nstatic void phy_mdm6600_device_power_off(struct phy_mdm6600 *ddata)\n{\n\tstruct gpio_desc *reset_gpio =\n\t\tddata->ctrl_gpios[PHY_MDM6600_RESET];\n\tint error;\n\n\tddata->enabled = false;\n\tphy_mdm6600_cmd(ddata, PHY_MDM6600_CMD_BP_SHUTDOWN_REQ);\n\tmsleep(100);\n\n\tgpiod_set_value_cansleep(reset_gpio, 1);\n\n\tdev_info(ddata->dev, \"Waiting for power down request to complete.. \");\n\tif (wait_for_completion_timeout(&ddata->ack,\n\t\t\t\t\tmsecs_to_jiffies(5000))) {\n\t\tif (ddata->status == PHY_MDM6600_STATUS_PANIC)\n\t\t\tdev_info(ddata->dev, \"Powered down OK\\n\");\n\t} else {\n\t\tdev_err(ddata->dev, \"Timed out powering down\\n\");\n\t}\n\n\t \n\terror = pinctrl_pm_select_sleep_state(ddata->dev);\n\tif (error)\n\t\tdev_warn(ddata->dev, \"%s: error with sleep_state: %i\\n\",\n\t\t\t __func__, error);\n}\n\nstatic void phy_mdm6600_deferred_power_on(struct work_struct *work)\n{\n\tstruct phy_mdm6600 *ddata;\n\tint error;\n\n\tddata = container_of(work, struct phy_mdm6600, bootup_work.work);\n\n\terror = phy_mdm6600_device_power_on(ddata);\n\tif (error)\n\t\tdev_err(ddata->dev, \"Device not functional\\n\");\n}\n\n \nstatic void phy_mdm6600_wake_modem(struct phy_mdm6600 *ddata)\n{\n\tstruct gpio_desc *mode_gpio0;\n\n\tmode_gpio0 = ddata->mode_gpios->desc[PHY_MDM6600_MODE0];\n\tgpiod_set_value_cansleep(mode_gpio0, 1);\n\tusleep_range(5, 15);\n\tgpiod_set_value_cansleep(mode_gpio0, 0);\n\tif (ddata->awake)\n\t\tusleep_range(5, 15);\n\telse\n\t\tmsleep(MDM6600_MODEM_WAKE_DELAY_MS);\n}\n\nstatic void phy_mdm6600_modem_wake(struct work_struct *work)\n{\n\tstruct phy_mdm6600 *ddata;\n\n\tddata = container_of(work, struct phy_mdm6600, modem_wake_work.work);\n\tphy_mdm6600_wake_modem(ddata);\n\n\t \n\tschedule_delayed_work(&ddata->modem_wake_work,\n\t\t\t      msecs_to_jiffies(PHY_MDM6600_WAKE_KICK_MS));\n}\n\nstatic int __maybe_unused phy_mdm6600_runtime_suspend(struct device *dev)\n{\n\tstruct phy_mdm6600 *ddata = dev_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&ddata->modem_wake_work);\n\tddata->awake = false;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused phy_mdm6600_runtime_resume(struct device *dev)\n{\n\tstruct phy_mdm6600 *ddata = dev_get_drvdata(dev);\n\n\tphy_mdm6600_modem_wake(&ddata->modem_wake_work.work);\n\tddata->awake = true;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops phy_mdm6600_pm_ops = {\n\tSET_RUNTIME_PM_OPS(phy_mdm6600_runtime_suspend,\n\t\t\t   phy_mdm6600_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id phy_mdm6600_id_table[] = {\n\t{ .compatible = \"motorola,mapphone-mdm6600\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, phy_mdm6600_id_table);\n\nstatic int phy_mdm6600_probe(struct platform_device *pdev)\n{\n\tstruct phy_mdm6600 *ddata;\n\tint error;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&ddata->bootup_work,\n\t\t\t  phy_mdm6600_deferred_power_on);\n\tINIT_DELAYED_WORK(&ddata->status_work, phy_mdm6600_status);\n\tINIT_DELAYED_WORK(&ddata->modem_wake_work, phy_mdm6600_modem_wake);\n\tinit_completion(&ddata->ack);\n\n\tddata->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ddata);\n\n\terror = phy_mdm6600_init_lines(ddata);\n\tif (error)\n\t\treturn error;\n\n\tphy_mdm6600_init_irq(ddata);\n\tschedule_delayed_work(&ddata->bootup_work, 0);\n\n\t \n\tmsleep(PHY_MDM6600_PHY_DELAY_MS + 500);\n\n\t \n\tpm_runtime_use_autosuspend(ddata->dev);\n\tpm_runtime_set_autosuspend_delay(ddata->dev,\n\t\t\t\t\t MDM6600_MODEM_IDLE_DELAY_MS);\n\tpm_runtime_enable(ddata->dev);\n\terror = pm_runtime_get_sync(ddata->dev);\n\tif (error < 0) {\n\t\tdev_warn(ddata->dev, \"failed to wake modem: %i\\n\", error);\n\t\tpm_runtime_put_noidle(ddata->dev);\n\t\tgoto cleanup;\n\t}\n\n\tddata->generic_phy = devm_phy_create(ddata->dev, NULL, &gpio_usb_ops);\n\tif (IS_ERR(ddata->generic_phy)) {\n\t\terror = PTR_ERR(ddata->generic_phy);\n\t\tgoto idle;\n\t}\n\n\tphy_set_drvdata(ddata->generic_phy, ddata);\n\n\tddata->phy_provider =\n\t\tdevm_of_phy_provider_register(ddata->dev,\n\t\t\t\t\t      of_phy_simple_xlate);\n\tif (IS_ERR(ddata->phy_provider))\n\t\terror = PTR_ERR(ddata->phy_provider);\n\nidle:\n\tpm_runtime_mark_last_busy(ddata->dev);\n\tpm_runtime_put_autosuspend(ddata->dev);\n\ncleanup:\n\tif (error < 0) {\n\t\tphy_mdm6600_device_power_off(ddata);\n\t\tpm_runtime_disable(ddata->dev);\n\t\tpm_runtime_dont_use_autosuspend(ddata->dev);\n\t}\n\n\treturn error;\n}\n\nstatic void phy_mdm6600_remove(struct platform_device *pdev)\n{\n\tstruct phy_mdm6600 *ddata = platform_get_drvdata(pdev);\n\tstruct gpio_desc *reset_gpio = ddata->ctrl_gpios[PHY_MDM6600_RESET];\n\n\tpm_runtime_get_noresume(ddata->dev);\n\tpm_runtime_dont_use_autosuspend(ddata->dev);\n\tpm_runtime_put_sync(ddata->dev);\n\tpm_runtime_disable(ddata->dev);\n\n\tif (!ddata->running)\n\t\twait_for_completion_timeout(&ddata->ack,\n\t\t\tmsecs_to_jiffies(PHY_MDM6600_ENABLED_DELAY_MS));\n\n\tgpiod_set_value_cansleep(reset_gpio, 1);\n\tphy_mdm6600_device_power_off(ddata);\n\n\tcancel_delayed_work_sync(&ddata->modem_wake_work);\n\tcancel_delayed_work_sync(&ddata->bootup_work);\n\tcancel_delayed_work_sync(&ddata->status_work);\n}\n\nstatic struct platform_driver phy_mdm6600_driver = {\n\t.probe = phy_mdm6600_probe,\n\t.remove_new = phy_mdm6600_remove,\n\t.driver = {\n\t\t.name = \"phy-mapphone-mdm6600\",\n\t\t.pm = &phy_mdm6600_pm_ops,\n\t\t.of_match_table = of_match_ptr(phy_mdm6600_id_table),\n\t},\n};\n\nmodule_platform_driver(phy_mdm6600_driver);\n\nMODULE_ALIAS(\"platform:gpio_usb\");\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_DESCRIPTION(\"mdm6600 gpio usb phy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}