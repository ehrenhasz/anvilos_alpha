{
  "module_name": "phy-cpcap-usb.c",
  "hash_id": "09dbd4d47c13050820abc11bec8b5e3e7964e123badf709e8cb6ba77d25ca067",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/motorola/phy-cpcap-usb.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/iio/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/mfd/motorola-cpcap.h>\n#include <linux/phy/omap_usb.h>\n#include <linux/phy/phy.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb/musb.h>\n\n \n#define CPCAP_BIT_IDPULSE\t\tBIT(15)\n#define CPCAP_BIT_ID100KPU\t\tBIT(14)\n#define CPCAP_BIT_IDPUCNTRL\t\tBIT(13)\n#define CPCAP_BIT_IDPU\t\t\tBIT(12)\n#define CPCAP_BIT_IDPD\t\t\tBIT(11)\n#define CPCAP_BIT_VBUSCHRGTMR3\t\tBIT(10)\n#define CPCAP_BIT_VBUSCHRGTMR2\t\tBIT(9)\n#define CPCAP_BIT_VBUSCHRGTMR1\t\tBIT(8)\n#define CPCAP_BIT_VBUSCHRGTMR0\t\tBIT(7)\n#define CPCAP_BIT_VBUSPU\t\tBIT(6)\n#define CPCAP_BIT_VBUSPD\t\tBIT(5)\n#define CPCAP_BIT_DMPD\t\t\tBIT(4)\n#define CPCAP_BIT_DPPD\t\t\tBIT(3)\n#define CPCAP_BIT_DM1K5PU\t\tBIT(2)\n#define CPCAP_BIT_DP1K5PU\t\tBIT(1)\n#define CPCAP_BIT_DP150KPU\t\tBIT(0)\n\n \n#define CPCAP_BIT_ZHSDRV1\t\tBIT(15)\n#define CPCAP_BIT_ZHSDRV0\t\tBIT(14)\n#define CPCAP_BIT_DPLLCLKREQ\t\tBIT(13)\n#define CPCAP_BIT_SE0CONN\t\tBIT(12)\n#define CPCAP_BIT_UARTTXTRI\t\tBIT(11)\n#define CPCAP_BIT_UARTSWAP\t\tBIT(10)\n#define CPCAP_BIT_UARTMUX1\t\tBIT(9)\n#define CPCAP_BIT_UARTMUX0\t\tBIT(8)\n#define CPCAP_BIT_ULPISTPLOW\t\tBIT(7)\n#define CPCAP_BIT_TXENPOL\t\tBIT(6)\n#define CPCAP_BIT_USBXCVREN\t\tBIT(5)\n#define CPCAP_BIT_USBCNTRL\t\tBIT(4)\n#define CPCAP_BIT_USBSUSPEND\t\tBIT(3)\n#define CPCAP_BIT_EMUMODE2\t\tBIT(2)\n#define CPCAP_BIT_EMUMODE1\t\tBIT(1)\n#define CPCAP_BIT_EMUMODE0\t\tBIT(0)\n\n \n#define CPCAP_BIT_SPARE_898_15\t\tBIT(15)\n#define CPCAP_BIT_IHSTX03\t\tBIT(14)\n#define CPCAP_BIT_IHSTX02\t\tBIT(13)\n#define CPCAP_BIT_IHSTX01\t\tBIT(12)\n#define CPCAP_BIT_IHSTX0\t\tBIT(11)\n#define CPCAP_BIT_IDPU_SPI\t\tBIT(10)\n#define CPCAP_BIT_UNUSED_898_9\t\tBIT(9)\n#define CPCAP_BIT_VBUSSTBY_EN\t\tBIT(8)\n#define CPCAP_BIT_VBUSEN_SPI\t\tBIT(7)\n#define CPCAP_BIT_VBUSPU_SPI\t\tBIT(6)\n#define CPCAP_BIT_VBUSPD_SPI\t\tBIT(5)\n#define CPCAP_BIT_DMPD_SPI\t\tBIT(4)\n#define CPCAP_BIT_DPPD_SPI\t\tBIT(3)\n#define CPCAP_BIT_SUSPEND_SPI\t\tBIT(2)\n#define CPCAP_BIT_PU_SPI\t\tBIT(1)\n#define CPCAP_BIT_ULPI_SPI_SEL\t\tBIT(0)\n\nstruct cpcap_usb_ints_state {\n\tbool id_ground;\n\tbool id_float;\n\tbool chrg_det;\n\tbool rvrs_chrg;\n\tbool vbusov;\n\n\tbool chrg_se1b;\n\tbool se0conn;\n\tbool rvrs_mode;\n\tbool chrgcurr1;\n\tbool vbusvld;\n\tbool sessvld;\n\tbool sessend;\n\tbool se1;\n\n\tbool battdetb;\n\tbool dm;\n\tbool dp;\n};\n\nenum cpcap_gpio_mode {\n\tCPCAP_DM_DP,\n\tCPCAP_MDM_RX_TX,\n\tCPCAP_UNKNOWN_DISABLED,\t \n\tCPCAP_OTG_DM_DP,\n};\n\nstruct cpcap_phy_ddata {\n\tstruct regmap *reg;\n\tstruct device *dev;\n\tstruct usb_phy phy;\n\tstruct delayed_work detect_work;\n\tstruct pinctrl *pins;\n\tstruct pinctrl_state *pins_ulpi;\n\tstruct pinctrl_state *pins_utmi;\n\tstruct pinctrl_state *pins_uart;\n\tstruct gpio_desc *gpio[2];\n\tstruct iio_channel *vbus;\n\tstruct iio_channel *id;\n\tstruct regulator *vusb;\n\tatomic_t active;\n\tunsigned int vbus_provider:1;\n\tunsigned int docked:1;\n};\n\nstatic bool cpcap_usb_vbus_valid(struct cpcap_phy_ddata *ddata)\n{\n\tint error, value = 0;\n\n\terror = iio_read_channel_processed(ddata->vbus, &value);\n\tif (error >= 0)\n\t\treturn value > 3900;\n\n\tdev_err(ddata->dev, \"error reading VBUS: %i\\n\", error);\n\n\treturn false;\n}\n\nstatic int cpcap_usb_phy_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\totg->host = host;\n\tif (!host)\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\treturn 0;\n}\n\nstatic int cpcap_usb_phy_set_peripheral(struct usb_otg *otg,\n\t\t\t\t\tstruct usb_gadget *gadget)\n{\n\totg->gadget = gadget;\n\tif (!gadget)\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ops = {\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int cpcap_phy_get_ints_state(struct cpcap_phy_ddata *ddata,\n\t\t\t\t    struct cpcap_usb_ints_state *s)\n{\n\tint val, error;\n\n\terror = regmap_read(ddata->reg, CPCAP_REG_INTS1, &val);\n\tif (error)\n\t\treturn error;\n\n\ts->id_ground = val & BIT(15);\n\ts->id_float = val & BIT(14);\n\ts->vbusov = val & BIT(11);\n\n\terror = regmap_read(ddata->reg, CPCAP_REG_INTS2, &val);\n\tif (error)\n\t\treturn error;\n\n\ts->vbusvld = val & BIT(3);\n\ts->sessvld = val & BIT(2);\n\ts->sessend = val & BIT(1);\n\ts->se1 = val & BIT(0);\n\n\terror = regmap_read(ddata->reg, CPCAP_REG_INTS4, &val);\n\tif (error)\n\t\treturn error;\n\n\ts->dm = val & BIT(1);\n\ts->dp = val & BIT(0);\n\n\treturn 0;\n}\n\nstatic int cpcap_usb_set_uart_mode(struct cpcap_phy_ddata *ddata);\nstatic int cpcap_usb_set_usb_mode(struct cpcap_phy_ddata *ddata);\n\nstatic void cpcap_usb_try_musb_mailbox(struct cpcap_phy_ddata *ddata,\n\t\t\t\t       enum musb_vbus_id_status status)\n{\n\tint error;\n\n\terror = musb_mailbox(status);\n\tif (!error)\n\t\treturn;\n\n\tdev_dbg(ddata->dev, \"%s: musb_mailbox failed: %i\\n\",\n\t\t__func__, error);\n}\n\nstatic void cpcap_usb_detect(struct work_struct *work)\n{\n\tstruct cpcap_phy_ddata *ddata;\n\tstruct cpcap_usb_ints_state s;\n\tbool vbus = false;\n\tint error;\n\n\tddata = container_of(work, struct cpcap_phy_ddata, detect_work.work);\n\n\terror = cpcap_phy_get_ints_state(ddata, &s);\n\tif (error)\n\t\treturn;\n\n\tvbus = cpcap_usb_vbus_valid(ddata);\n\n\t \n\tif (s.id_ground && ddata->vbus_provider) {\n\t\tdev_dbg(ddata->dev, \"still in USB A-host mode, kicking VBUS\\n\");\n\n\t\tcpcap_usb_try_musb_mailbox(ddata, MUSB_ID_GROUND);\n\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC3,\n\t\t\t\t\t   CPCAP_BIT_VBUSSTBY_EN |\n\t\t\t\t\t   CPCAP_BIT_VBUSEN_SPI,\n\t\t\t\t\t   CPCAP_BIT_VBUSEN_SPI);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\treturn;\n\t}\n\n\tif (vbus && s.id_ground && ddata->docked) {\n\t\tdev_dbg(ddata->dev, \"still docked as A-host, signal ID down\\n\");\n\n\t\tcpcap_usb_try_musb_mailbox(ddata, MUSB_ID_GROUND);\n\n\t\treturn;\n\t}\n\n\t \n\tif (vbus && s.id_ground && !ddata->vbus_provider) {\n\t\tdev_dbg(ddata->dev, \"connected to a dock\\n\");\n\n\t\tddata->docked = true;\n\n\t\terror = cpcap_usb_set_usb_mode(ddata);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\tcpcap_usb_try_musb_mailbox(ddata, MUSB_ID_GROUND);\n\n\t\t \n\t\tschedule_delayed_work(&ddata->detect_work,\n\t\t\t\t      msecs_to_jiffies(1000));\n\n\t\treturn;\n\t}\n\n\tif (s.id_ground && !ddata->docked) {\n\t\tdev_dbg(ddata->dev, \"id ground, USB host mode\\n\");\n\n\t\tddata->vbus_provider = true;\n\n\t\terror = cpcap_usb_set_usb_mode(ddata);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\tcpcap_usb_try_musb_mailbox(ddata, MUSB_ID_GROUND);\n\n\t\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC3,\n\t\t\t\t\t   CPCAP_BIT_VBUSSTBY_EN |\n\t\t\t\t\t   CPCAP_BIT_VBUSEN_SPI,\n\t\t\t\t\t   CPCAP_BIT_VBUSEN_SPI);\n\t\tif (error)\n\t\t\tgoto out_err;\n\n\t\treturn;\n\t}\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC3,\n\t\t\t\t   CPCAP_BIT_VBUSSTBY_EN |\n\t\t\t\t   CPCAP_BIT_VBUSEN_SPI, 0);\n\tif (error)\n\t\tgoto out_err;\n\n\tvbus = cpcap_usb_vbus_valid(ddata);\n\n\t \n\tif (vbus) {\n\t\tdev_dbg(ddata->dev, \"connected to USB host\\n\");\n\t\terror = cpcap_usb_set_usb_mode(ddata);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t\tcpcap_usb_try_musb_mailbox(ddata, MUSB_VBUS_VALID);\n\n\t\treturn;\n\t}\n\n\tddata->vbus_provider = false;\n\tddata->docked = false;\n\tcpcap_usb_try_musb_mailbox(ddata, MUSB_VBUS_OFF);\n\n\t \n\terror = cpcap_usb_set_uart_mode(ddata);\n\tif (error)\n\t\tgoto out_err;\n\n\tdev_dbg(ddata->dev, \"set UART mode\\n\");\n\n\treturn;\n\nout_err:\n\tdev_err(ddata->dev, \"error setting cable state: %i\\n\", error);\n}\n\nstatic irqreturn_t cpcap_phy_irq_thread(int irq, void *data)\n{\n\tstruct cpcap_phy_ddata *ddata = data;\n\n\tif (!atomic_read(&ddata->active))\n\t\treturn IRQ_NONE;\n\n\tschedule_delayed_work(&ddata->detect_work, msecs_to_jiffies(1));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cpcap_usb_init_irq(struct platform_device *pdev,\n\t\t\t      struct cpcap_phy_ddata *ddata,\n\t\t\t      const char *name)\n{\n\tint irq, error;\n\n\tirq = platform_get_irq_byname(pdev, name);\n\tif (irq < 0)\n\t\treturn -ENODEV;\n\n\terror = devm_request_threaded_irq(ddata->dev, irq, NULL,\n\t\t\t\t\t  cpcap_phy_irq_thread,\n\t\t\t\t\t  IRQF_SHARED |\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  name, ddata);\n\tif (error) {\n\t\tdev_err(ddata->dev, \"could not get irq %s: %i\\n\",\n\t\t\tname, error);\n\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const cpcap_phy_irqs[] = {\n\t \n\t\"id_ground\", \"id_float\",\n\n\t \n\t\"se0conn\", \"vbusvld\", \"sessvld\", \"sessend\", \"se1\",\n\n\t \n\t\"dm\", \"dp\",\n};\n\nstatic int cpcap_usb_init_interrupts(struct platform_device *pdev,\n\t\t\t\t     struct cpcap_phy_ddata *ddata)\n{\n\tint i, error;\n\n\tfor (i = 0; i < ARRAY_SIZE(cpcap_phy_irqs); i++) {\n\t\terror = cpcap_usb_init_irq(pdev, ddata, cpcap_phy_irqs[i]);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int cpcap_usb_gpio_set_mode(struct cpcap_phy_ddata *ddata,\n\t\t\t\t   enum cpcap_gpio_mode mode)\n{\n\tif (!ddata->gpio[0] || !ddata->gpio[1])\n\t\treturn 0;\n\n\tgpiod_set_value(ddata->gpio[0], mode & 1);\n\tgpiod_set_value(ddata->gpio[1], mode >> 1);\n\n\treturn 0;\n}\n\nstatic int cpcap_usb_set_uart_mode(struct cpcap_phy_ddata *ddata)\n{\n\tint error;\n\n\t \n\terror = cpcap_usb_gpio_set_mode(ddata, CPCAP_UNKNOWN_DISABLED);\n\tif (error)\n\t\tgoto out_err;\n\n\tif (ddata->pins_uart) {\n\t\terror = pinctrl_select_state(ddata->pins, ddata->pins_uart);\n\t\tif (error)\n\t\t\tgoto out_err;\n\t}\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC1,\n\t\t\t\t   CPCAP_BIT_VBUSPD,\n\t\t\t\t   CPCAP_BIT_VBUSPD);\n\tif (error)\n\t\tgoto out_err;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC2,\n\t\t\t\t   0xffff, CPCAP_BIT_UARTMUX0 |\n\t\t\t\t   CPCAP_BIT_EMUMODE0);\n\tif (error)\n\t\tgoto out_err;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC3, 0x7fff,\n\t\t\t\t   CPCAP_BIT_IDPU_SPI);\n\tif (error)\n\t\tgoto out_err;\n\n\t \n\terror = cpcap_usb_gpio_set_mode(ddata, CPCAP_DM_DP);\n\tif (error)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tdev_err(ddata->dev, \"%s failed with %i\\n\", __func__, error);\n\n\treturn error;\n}\n\nstatic int cpcap_usb_set_usb_mode(struct cpcap_phy_ddata *ddata)\n{\n\tint error;\n\n\t \n\terror = cpcap_usb_gpio_set_mode(ddata, CPCAP_UNKNOWN_DISABLED);\n\tif (error)\n\t\treturn error;\n\n\tif (ddata->pins_utmi) {\n\t\terror = pinctrl_select_state(ddata->pins, ddata->pins_utmi);\n\t\tif (error) {\n\t\t\tdev_err(ddata->dev, \"could not set usb mode: %i\\n\",\n\t\t\t\terror);\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC1,\n\t\t\t\t   CPCAP_BIT_VBUSPD, 0);\n\tif (error)\n\t\tgoto out_err;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC3,\n\t\t\t\t   CPCAP_BIT_PU_SPI |\n\t\t\t\t   CPCAP_BIT_DMPD_SPI |\n\t\t\t\t   CPCAP_BIT_DPPD_SPI |\n\t\t\t\t   CPCAP_BIT_SUSPEND_SPI |\n\t\t\t\t   CPCAP_BIT_ULPI_SPI_SEL, 0);\n\tif (error)\n\t\tgoto out_err;\n\n\terror = regmap_update_bits(ddata->reg, CPCAP_REG_USBC2,\n\t\t\t\t   CPCAP_BIT_USBXCVREN,\n\t\t\t\t   CPCAP_BIT_USBXCVREN);\n\tif (error)\n\t\tgoto out_err;\n\n\t \n\terror = cpcap_usb_gpio_set_mode(ddata, CPCAP_OTG_DM_DP);\n\tif (error)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tdev_err(ddata->dev, \"%s failed with %i\\n\", __func__, error);\n\n\treturn error;\n}\n\nstatic int cpcap_usb_init_optional_pins(struct cpcap_phy_ddata *ddata)\n{\n\tddata->pins = devm_pinctrl_get(ddata->dev);\n\tif (IS_ERR(ddata->pins)) {\n\t\tdev_info(ddata->dev, \"default pins not configured: %ld\\n\",\n\t\t\t PTR_ERR(ddata->pins));\n\t\tddata->pins = NULL;\n\n\t\treturn 0;\n\t}\n\n\tddata->pins_ulpi = pinctrl_lookup_state(ddata->pins, \"ulpi\");\n\tif (IS_ERR(ddata->pins_ulpi)) {\n\t\tdev_info(ddata->dev, \"ulpi pins not configured\\n\");\n\t\tddata->pins_ulpi = NULL;\n\t}\n\n\tddata->pins_utmi = pinctrl_lookup_state(ddata->pins, \"utmi\");\n\tif (IS_ERR(ddata->pins_utmi)) {\n\t\tdev_info(ddata->dev, \"utmi pins not configured\\n\");\n\t\tddata->pins_utmi = NULL;\n\t}\n\n\tddata->pins_uart = pinctrl_lookup_state(ddata->pins, \"uart\");\n\tif (IS_ERR(ddata->pins_uart)) {\n\t\tdev_info(ddata->dev, \"uart pins not configured\\n\");\n\t\tddata->pins_uart = NULL;\n\t}\n\n\tif (ddata->pins_uart)\n\t\treturn pinctrl_select_state(ddata->pins, ddata->pins_uart);\n\n\treturn 0;\n}\n\nstatic void cpcap_usb_init_optional_gpios(struct cpcap_phy_ddata *ddata)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tddata->gpio[i] = devm_gpiod_get_index(ddata->dev, \"mode\",\n\t\t\t\t\t\t      i, GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(ddata->gpio[i])) {\n\t\t\tdev_info(ddata->dev, \"no mode change GPIO%i: %li\\n\",\n\t\t\t\t i, PTR_ERR(ddata->gpio[i]));\n\t\t\tddata->gpio[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic int cpcap_usb_init_iio(struct cpcap_phy_ddata *ddata)\n{\n\tenum iio_chan_type type;\n\tint error;\n\n\tddata->vbus = devm_iio_channel_get(ddata->dev, \"vbus\");\n\tif (IS_ERR(ddata->vbus)) {\n\t\terror = PTR_ERR(ddata->vbus);\n\t\tgoto out_err;\n\t}\n\n\tif (!ddata->vbus->indio_dev) {\n\t\terror = -ENXIO;\n\t\tgoto out_err;\n\t}\n\n\terror = iio_get_channel_type(ddata->vbus, &type);\n\tif (error < 0)\n\t\tgoto out_err;\n\n\tif (type != IIO_VOLTAGE) {\n\t\terror = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tdev_err(ddata->dev, \"could not initialize VBUS or ID IIO: %i\\n\",\n\t\terror);\n\n\treturn error;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cpcap_usb_phy_id_table[] = {\n\t{\n\t\t.compatible = \"motorola,cpcap-usb-phy\",\n\t},\n\t{\n\t\t.compatible = \"motorola,mapphone-cpcap-usb-phy\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cpcap_usb_phy_id_table);\n#endif\n\nstatic int cpcap_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct cpcap_phy_ddata *ddata;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct usb_otg *otg;\n\tconst struct of_device_id *of_id;\n\tint error;\n\n\tof_id = of_match_device(of_match_ptr(cpcap_usb_phy_id_table),\n\t\t\t\t&pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->reg = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!ddata->reg)\n\t\treturn -ENODEV;\n\n\totg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\n\tif (!otg)\n\t\treturn -ENOMEM;\n\n\tddata->dev = &pdev->dev;\n\tddata->phy.dev = ddata->dev;\n\tddata->phy.label = \"cpcap_usb_phy\";\n\tddata->phy.otg = otg;\n\tddata->phy.type = USB_PHY_TYPE_USB2;\n\totg->set_host = cpcap_usb_phy_set_host;\n\totg->set_peripheral = cpcap_usb_phy_set_peripheral;\n\totg->usb_phy = &ddata->phy;\n\tINIT_DELAYED_WORK(&ddata->detect_work, cpcap_usb_detect);\n\tplatform_set_drvdata(pdev, ddata);\n\n\tddata->vusb = devm_regulator_get(&pdev->dev, \"vusb\");\n\tif (IS_ERR(ddata->vusb))\n\t\treturn PTR_ERR(ddata->vusb);\n\n\terror = regulator_enable(ddata->vusb);\n\tif (error)\n\t\treturn error;\n\n\tgeneric_phy = devm_phy_create(ddata->dev, NULL, &ops);\n\tif (IS_ERR(generic_phy)) {\n\t\terror = PTR_ERR(generic_phy);\n\t\tgoto out_reg_disable;\n\t}\n\n\tphy_set_drvdata(generic_phy, ddata);\n\n\tphy_provider = devm_of_phy_provider_register(ddata->dev,\n\t\t\t\t\t\t     of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\terror = PTR_ERR(phy_provider);\n\t\tgoto out_reg_disable;\n\t}\n\n\terror = cpcap_usb_init_optional_pins(ddata);\n\tif (error)\n\t\tgoto out_reg_disable;\n\n\tcpcap_usb_init_optional_gpios(ddata);\n\n\terror = cpcap_usb_init_iio(ddata);\n\tif (error)\n\t\tgoto out_reg_disable;\n\n\terror = cpcap_usb_init_interrupts(pdev, ddata);\n\tif (error)\n\t\tgoto out_reg_disable;\n\n\tusb_add_phy_dev(&ddata->phy);\n\tatomic_set(&ddata->active, 1);\n\tschedule_delayed_work(&ddata->detect_work, msecs_to_jiffies(1));\n\n\treturn 0;\n\nout_reg_disable:\n\tregulator_disable(ddata->vusb);\n\n\treturn error;\n}\n\nstatic void cpcap_usb_phy_remove(struct platform_device *pdev)\n{\n\tstruct cpcap_phy_ddata *ddata = platform_get_drvdata(pdev);\n\tint error;\n\n\tatomic_set(&ddata->active, 0);\n\terror = cpcap_usb_set_uart_mode(ddata);\n\tif (error)\n\t\tdev_err(ddata->dev, \"could not set UART mode\\n\");\n\n\tcpcap_usb_try_musb_mailbox(ddata, MUSB_VBUS_OFF);\n\n\tusb_remove_phy(&ddata->phy);\n\tcancel_delayed_work_sync(&ddata->detect_work);\n\tregulator_disable(ddata->vusb);\n}\n\nstatic struct platform_driver cpcap_usb_phy_driver = {\n\t.probe\t\t= cpcap_usb_phy_probe,\n\t.remove_new\t= cpcap_usb_phy_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"cpcap-usb-phy\",\n\t\t.of_match_table = of_match_ptr(cpcap_usb_phy_id_table),\n\t},\n};\n\nmodule_platform_driver(cpcap_usb_phy_driver);\n\nMODULE_ALIAS(\"platform:cpcap_usb\");\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_DESCRIPTION(\"CPCAP usb phy driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}