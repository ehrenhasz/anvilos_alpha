{
  "module_name": "phy-ingenic-usb.c",
  "hash_id": "c74e55086be3af638d2249b7cf3ab0fffb82f5299d2a6c7bc2d62d0da4929e95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ingenic/phy-ingenic-usb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n \n#define REG_USBPCR_OFFSET\t\t\t0x00\n#define REG_USBRDT_OFFSET\t\t\t0x04\n#define REG_USBVBFIL_OFFSET\t\t\t0x08\n#define REG_USBPCR1_OFFSET\t\t\t0x0c\n\n \n#define USBPCR_USB_MODE\t\t\t\tBIT(31)\n#define USBPCR_AVLD_REG\t\t\t\tBIT(30)\n#define USBPCR_COMMONONN\t\t\tBIT(25)\n#define USBPCR_VBUSVLDEXT\t\t\tBIT(24)\n#define USBPCR_VBUSVLDEXTSEL\t\tBIT(23)\n#define USBPCR_POR\t\t\t\t\tBIT(22)\n#define USBPCR_SIDDQ\t\t\t\tBIT(21)\n#define USBPCR_OTG_DISABLE\t\t\tBIT(20)\n#define USBPCR_TXPREEMPHTUNE\t\tBIT(6)\n\n#define USBPCR_IDPULLUP_MASK\t\tGENMASK(29, 28)\n#define USBPCR_IDPULLUP_ALWAYS\t\t0x2\n#define USBPCR_IDPULLUP_SUSPEND\t\t0x1\n#define USBPCR_IDPULLUP_OTG\t\t\t0x0\n\n#define USBPCR_COMPDISTUNE_MASK\t\tGENMASK(19, 17)\n#define USBPCR_COMPDISTUNE_DFT\t\t0x4\n\n#define USBPCR_OTGTUNE_MASK\t\t\tGENMASK(16, 14)\n#define USBPCR_OTGTUNE_DFT\t\t\t0x4\n\n#define USBPCR_SQRXTUNE_MASK\t\tGENMASK(13, 11)\n#define USBPCR_SQRXTUNE_DCR_20PCT\t0x7\n#define USBPCR_SQRXTUNE_DFT\t\t\t0x3\n\n#define USBPCR_TXFSLSTUNE_MASK\t\tGENMASK(10, 7)\n#define USBPCR_TXFSLSTUNE_DCR_50PPT\t0xf\n#define USBPCR_TXFSLSTUNE_DCR_25PPT\t0x7\n#define USBPCR_TXFSLSTUNE_DFT\t\t0x3\n#define USBPCR_TXFSLSTUNE_INC_25PPT\t0x1\n#define USBPCR_TXFSLSTUNE_INC_50PPT\t0x0\n\n#define USBPCR_TXHSXVTUNE_MASK\t\tGENMASK(5, 4)\n#define USBPCR_TXHSXVTUNE_DFT\t\t0x3\n#define USBPCR_TXHSXVTUNE_DCR_15MV\t0x1\n\n#define USBPCR_TXRISETUNE_MASK\t\tGENMASK(5, 4)\n#define USBPCR_TXRISETUNE_DFT\t\t0x3\n\n#define USBPCR_TXVREFTUNE_MASK\t\tGENMASK(3, 0)\n#define USBPCR_TXVREFTUNE_INC_75PPT\t0xb\n#define USBPCR_TXVREFTUNE_INC_25PPT\t0x7\n#define USBPCR_TXVREFTUNE_DFT\t\t0x5\n\n \n#define USBRDT_UTMI_RST\t\t\t\tBIT(27)\n#define USBRDT_HB_MASK\t\t\t\tBIT(26)\n#define USBRDT_VBFIL_LD_EN\t\t\tBIT(25)\n#define USBRDT_IDDIG_EN\t\t\t\tBIT(24)\n#define USBRDT_IDDIG_REG\t\t\tBIT(23)\n#define USBRDT_VBFIL_EN\t\t\t\tBIT(2)\n\n \n#define USBPCR1_BVLD_REG\t\t\tBIT(31)\n#define USBPCR1_DPPD\t\t\t\tBIT(29)\n#define USBPCR1_DMPD\t\t\t\tBIT(28)\n#define USBPCR1_USB_SEL\t\t\t\tBIT(28)\n#define USBPCR1_PORT_RST\t\t\tBIT(21)\n#define USBPCR1_WORD_IF_16BIT\t\tBIT(19)\n\nstruct ingenic_soc_info {\n\tvoid (*usb_phy_init)(struct phy *phy);\n};\n\nstruct ingenic_usb_phy {\n\tconst struct ingenic_soc_info *soc_info;\n\n\tstruct phy *phy;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct regulator *vcc_supply;\n};\n\nstatic int ingenic_usb_phy_init(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tint err;\n\tu32 reg;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tdev_err(&phy->dev, \"Unable to start clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->soc_info->usb_phy_init(phy);\n\n\t \n\tusleep_range(30, 300);\n\treg = readl(priv->base + REG_USBPCR_OFFSET);\n\twritel(reg & ~USBPCR_POR, priv->base + REG_USBPCR_OFFSET);\n\tusleep_range(300, 1000);\n\n\treturn 0;\n}\n\nstatic int ingenic_usb_phy_exit(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(priv->clk);\n\tregulator_disable(priv->vcc_supply);\n\n\treturn 0;\n}\n\nstatic int ingenic_usb_phy_power_on(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tint err;\n\n\terr = regulator_enable(priv->vcc_supply);\n\tif (err) {\n\t\tdev_err(&phy->dev, \"Unable to enable VCC: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ingenic_usb_phy_power_off(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\n\tregulator_disable(priv->vcc_supply);\n\n\treturn 0;\n}\n\nstatic int ingenic_usb_phy_set_mode(struct phy *phy,\n\t\t\t\t  enum phy_mode mode, int submode)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tu32 reg;\n\n\tswitch (mode) {\n\tcase PHY_MODE_USB_HOST:\n\t\treg = readl(priv->base + REG_USBPCR_OFFSET);\n\t\tu32p_replace_bits(&reg, 1, USBPCR_USB_MODE);\n\t\tu32p_replace_bits(&reg, 0, USBPCR_VBUSVLDEXT);\n\t\tu32p_replace_bits(&reg, 0, USBPCR_VBUSVLDEXTSEL);\n\t\tu32p_replace_bits(&reg, 0, USBPCR_OTG_DISABLE);\n\t\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n\n\t\tbreak;\n\tcase PHY_MODE_USB_DEVICE:\n\t\treg = readl(priv->base + REG_USBPCR_OFFSET);\n\t\tu32p_replace_bits(&reg, 0, USBPCR_USB_MODE);\n\t\tu32p_replace_bits(&reg, 1, USBPCR_VBUSVLDEXT);\n\t\tu32p_replace_bits(&reg, 1, USBPCR_VBUSVLDEXTSEL);\n\t\tu32p_replace_bits(&reg, 1, USBPCR_OTG_DISABLE);\n\t\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n\n\t\tbreak;\n\tcase PHY_MODE_USB_OTG:\n\t\treg = readl(priv->base + REG_USBPCR_OFFSET);\n\t\tu32p_replace_bits(&reg, 1, USBPCR_USB_MODE);\n\t\tu32p_replace_bits(&reg, 1, USBPCR_VBUSVLDEXT);\n\t\tu32p_replace_bits(&reg, 1, USBPCR_VBUSVLDEXTSEL);\n\t\tu32p_replace_bits(&reg, 0, USBPCR_OTG_DISABLE);\n\t\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ingenic_usb_phy_ops = {\n\t.init\t\t= ingenic_usb_phy_init,\n\t.exit\t\t= ingenic_usb_phy_exit,\n\t.power_on\t= ingenic_usb_phy_power_on,\n\t.power_off\t= ingenic_usb_phy_power_off,\n\t.set_mode\t= ingenic_usb_phy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void jz4770_usb_phy_init(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tu32 reg;\n\n\treg = USBPCR_AVLD_REG | USBPCR_COMMONONN | USBPCR_POR |\n\t\tFIELD_PREP(USBPCR_IDPULLUP_MASK, USBPCR_IDPULLUP_ALWAYS) |\n\t\tFIELD_PREP(USBPCR_COMPDISTUNE_MASK, USBPCR_COMPDISTUNE_DFT) |\n\t\tFIELD_PREP(USBPCR_OTGTUNE_MASK, USBPCR_OTGTUNE_DFT) |\n\t\tFIELD_PREP(USBPCR_SQRXTUNE_MASK, USBPCR_SQRXTUNE_DFT) |\n\t\tFIELD_PREP(USBPCR_TXFSLSTUNE_MASK, USBPCR_TXFSLSTUNE_DFT) |\n\t\tFIELD_PREP(USBPCR_TXRISETUNE_MASK, USBPCR_TXRISETUNE_DFT) |\n\t\tFIELD_PREP(USBPCR_TXVREFTUNE_MASK, USBPCR_TXVREFTUNE_DFT);\n\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n}\n\nstatic void jz4775_usb_phy_init(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tu32 reg;\n\n\treg = readl(priv->base + REG_USBPCR1_OFFSET) | USBPCR1_USB_SEL |\n\t\tUSBPCR1_WORD_IF_16BIT;\n\twritel(reg, priv->base + REG_USBPCR1_OFFSET);\n\n\treg = USBPCR_COMMONONN | USBPCR_POR |\n\t\tFIELD_PREP(USBPCR_TXVREFTUNE_MASK, USBPCR_TXVREFTUNE_INC_75PPT);\n\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n}\n\nstatic void jz4780_usb_phy_init(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tu32 reg;\n\n\treg = readl(priv->base + REG_USBPCR1_OFFSET) | USBPCR1_USB_SEL |\n\t\tUSBPCR1_WORD_IF_16BIT;\n\twritel(reg, priv->base + REG_USBPCR1_OFFSET);\n\n\treg = USBPCR_TXPREEMPHTUNE | USBPCR_COMMONONN | USBPCR_POR;\n\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n}\n\nstatic void x1000_usb_phy_init(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tu32 reg;\n\n\treg = readl(priv->base + REG_USBPCR1_OFFSET) | USBPCR1_WORD_IF_16BIT;\n\twritel(reg, priv->base + REG_USBPCR1_OFFSET);\n\n\treg = USBPCR_TXPREEMPHTUNE | USBPCR_COMMONONN | USBPCR_POR |\n\t\tFIELD_PREP(USBPCR_SQRXTUNE_MASK, USBPCR_SQRXTUNE_DCR_20PCT) |\n\t\tFIELD_PREP(USBPCR_TXHSXVTUNE_MASK, USBPCR_TXHSXVTUNE_DCR_15MV) |\n\t\tFIELD_PREP(USBPCR_TXVREFTUNE_MASK, USBPCR_TXVREFTUNE_INC_25PPT);\n\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n}\n\nstatic void x1830_usb_phy_init(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tu32 reg;\n\n\t \n\twritel(USBRDT_VBFIL_EN | USBRDT_UTMI_RST, priv->base + REG_USBRDT_OFFSET);\n\n\treg = readl(priv->base + REG_USBPCR1_OFFSET) | USBPCR1_WORD_IF_16BIT |\n\t\tUSBPCR1_DMPD | USBPCR1_DPPD;\n\twritel(reg, priv->base + REG_USBPCR1_OFFSET);\n\n\treg = USBPCR_VBUSVLDEXT | USBPCR_TXPREEMPHTUNE | USBPCR_COMMONONN | USBPCR_POR |\n\t\tFIELD_PREP(USBPCR_IDPULLUP_MASK, USBPCR_IDPULLUP_OTG);\n\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n}\n\nstatic void x2000_usb_phy_init(struct phy *phy)\n{\n\tstruct ingenic_usb_phy *priv = phy_get_drvdata(phy);\n\tu32 reg;\n\n\treg = readl(priv->base + REG_USBPCR1_OFFSET) | USBPCR1_DPPD | USBPCR1_DMPD;\n\twritel(reg & ~USBPCR1_PORT_RST, priv->base + REG_USBPCR1_OFFSET);\n\n\treg = USBPCR_POR | FIELD_PREP(USBPCR_IDPULLUP_MASK, USBPCR_IDPULLUP_OTG);\n\twritel(reg, priv->base + REG_USBPCR_OFFSET);\n}\n\nstatic const struct ingenic_soc_info jz4770_soc_info = {\n\t.usb_phy_init = jz4770_usb_phy_init,\n};\n\nstatic const struct ingenic_soc_info jz4775_soc_info = {\n\t.usb_phy_init = jz4775_usb_phy_init,\n};\n\nstatic const struct ingenic_soc_info jz4780_soc_info = {\n\t.usb_phy_init = jz4780_usb_phy_init,\n};\n\nstatic const struct ingenic_soc_info x1000_soc_info = {\n\t.usb_phy_init = x1000_usb_phy_init,\n};\n\nstatic const struct ingenic_soc_info x1830_soc_info = {\n\t.usb_phy_init = x1830_usb_phy_init,\n};\n\nstatic const struct ingenic_soc_info x2000_soc_info = {\n\t.usb_phy_init = x2000_usb_phy_init,\n};\n\nstatic int ingenic_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct ingenic_usb_phy *priv;\n\tstruct phy_provider *provider;\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->soc_info = device_get_match_data(dev);\n\tif (!priv->soc_info) {\n\t\tdev_err(dev, \"Error: No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tdev_err(dev, \"Failed to map registers\\n\");\n\t\treturn PTR_ERR(priv->base);\n\t}\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\terr = PTR_ERR(priv->clk);\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get clock\\n\");\n\t\treturn err;\n\t}\n\n\tpriv->vcc_supply = devm_regulator_get(dev, \"vcc\");\n\tif (IS_ERR(priv->vcc_supply)) {\n\t\terr = PTR_ERR(priv->vcc_supply);\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get regulator\\n\");\n\t\treturn err;\n\t}\n\n\tpriv->phy = devm_phy_create(dev, NULL, &ingenic_usb_phy_ops);\n\tif (IS_ERR(priv->phy))\n\t\treturn PTR_ERR(priv->phy);\n\n\tphy_set_drvdata(priv->phy, priv);\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id ingenic_usb_phy_of_matches[] = {\n\t{ .compatible = \"ingenic,jz4770-phy\", .data = &jz4770_soc_info },\n\t{ .compatible = \"ingenic,jz4775-phy\", .data = &jz4775_soc_info },\n\t{ .compatible = \"ingenic,jz4780-phy\", .data = &jz4780_soc_info },\n\t{ .compatible = \"ingenic,x1000-phy\", .data = &x1000_soc_info },\n\t{ .compatible = \"ingenic,x1830-phy\", .data = &x1830_soc_info },\n\t{ .compatible = \"ingenic,x2000-phy\", .data = &x2000_soc_info },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ingenic_usb_phy_of_matches);\n\nstatic struct platform_driver ingenic_usb_phy_driver = {\n\t.probe\t\t= ingenic_usb_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ingenic-usb-phy\",\n\t\t.of_match_table = ingenic_usb_phy_of_matches,\n\t},\n};\nmodule_platform_driver(ingenic_usb_phy_driver);\n\nMODULE_AUTHOR(\"\u5468\u7430\u6770 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>\");\nMODULE_AUTHOR(\"\u6f06\u9e4f\u632f (Qi Pengzhen) <aric.pzqi@ingenic.com>\");\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_DESCRIPTION(\"Ingenic SoCs USB PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}