{
  "module_name": "phy-mtk-tphy.c",
  "hash_id": "7f5fea635e31b13b44a5ca42be5dd8f1e7975abb43b3dc171d0c9508290bac72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/mediatek/phy-mtk-tphy.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/phy/phy.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"phy-mtk-io.h\"\n\n \n \n#define SSUSB_SIFSLV_V1_SPLLC\t\t0x000\t \n#define SSUSB_SIFSLV_V1_U2FREQ\t\t0x100\t \n#define SSUSB_SIFSLV_V1_CHIP\t\t0x300\t \n \n#define SSUSB_SIFSLV_V1_U2PHY_COM\t0x000\n \n#define SSUSB_SIFSLV_V1_U3PHYD\t\t0x000\n#define SSUSB_SIFSLV_V1_U3PHYA\t\t0x200\n\n \n \n \n#define SSUSB_SIFSLV_V2_MISC\t\t0x000\n#define SSUSB_SIFSLV_V2_U2FREQ\t\t0x100\n#define SSUSB_SIFSLV_V2_U2PHY_COM\t0x300\n \n#define SSUSB_SIFSLV_V2_SPLLC\t\t0x000\n#define SSUSB_SIFSLV_V2_CHIP\t\t0x100\n#define SSUSB_SIFSLV_V2_U3PHYD\t\t0x200\n#define SSUSB_SIFSLV_V2_U3PHYA\t\t0x400\n\n#define U3P_MISC_REG1\t\t0x04\n#define MR1_EFUSE_AUTO_LOAD_DIS\t\tBIT(6)\n\n#define U3P_USBPHYACR0\t\t0x000\n#define PA0_RG_U2PLL_FORCE_ON\t\tBIT(15)\n#define PA0_USB20_PLL_PREDIV\t\tGENMASK(7, 6)\n#define PA0_RG_USB20_INTR_EN\t\tBIT(5)\n\n#define U3P_USBPHYACR1\t\t0x004\n#define PA1_RG_INTR_CAL\t\tGENMASK(23, 19)\n#define PA1_RG_VRT_SEL\t\t\tGENMASK(14, 12)\n#define PA1_RG_TERM_SEL\t\tGENMASK(10, 8)\n\n#define U3P_USBPHYACR2\t\t0x008\n#define PA2_RG_U2PLL_BW\t\t\tGENMASK(21, 19)\n#define PA2_RG_SIF_U2PLL_FORCE_EN\tBIT(18)\n\n#define U3P_USBPHYACR5\t\t0x014\n#define PA5_RG_U2_HSTX_SRCAL_EN\tBIT(15)\n#define PA5_RG_U2_HSTX_SRCTRL\t\tGENMASK(14, 12)\n#define PA5_RG_U2_HS_100U_U3_EN\tBIT(11)\n\n#define U3P_USBPHYACR6\t\t0x018\n#define PA6_RG_U2_PRE_EMP\t\tGENMASK(31, 30)\n#define PA6_RG_U2_BC11_SW_EN\t\tBIT(23)\n#define PA6_RG_U2_OTG_VBUSCMP_EN\tBIT(20)\n#define PA6_RG_U2_DISCTH\t\tGENMASK(7, 4)\n#define PA6_RG_U2_SQTH\t\tGENMASK(3, 0)\n\n#define U3P_U2PHYACR4\t\t0x020\n#define P2C_RG_USB20_GPIO_CTL\t\tBIT(9)\n#define P2C_USB20_GPIO_MODE\t\tBIT(8)\n#define P2C_U2_GPIO_CTR_MSK\t(P2C_RG_USB20_GPIO_CTL | P2C_USB20_GPIO_MODE)\n\n#define U3P_U2PHYA_RESV\t\t0x030\n#define P2R_RG_U2PLL_FBDIV_26M\t\t0x1bb13b\n#define P2R_RG_U2PLL_FBDIV_48M\t\t0x3c0000\n\n#define U3P_U2PHYA_RESV1\t0x044\n#define P2R_RG_U2PLL_REFCLK_SEL\tBIT(5)\n#define P2R_RG_U2PLL_FRA_EN\t\tBIT(3)\n\n#define U3D_U2PHYDCR0\t\t0x060\n#define P2C_RG_SIF_U2PLL_FORCE_ON\tBIT(24)\n\n#define U3P_U2PHYDTM0\t\t0x068\n#define P2C_FORCE_UART_EN\t\tBIT(26)\n#define P2C_FORCE_DATAIN\t\tBIT(23)\n#define P2C_FORCE_DM_PULLDOWN\t\tBIT(21)\n#define P2C_FORCE_DP_PULLDOWN\t\tBIT(20)\n#define P2C_FORCE_XCVRSEL\t\tBIT(19)\n#define P2C_FORCE_SUSPENDM\t\tBIT(18)\n#define P2C_FORCE_TERMSEL\t\tBIT(17)\n#define P2C_RG_DATAIN\t\t\tGENMASK(13, 10)\n#define P2C_RG_DMPULLDOWN\t\tBIT(7)\n#define P2C_RG_DPPULLDOWN\t\tBIT(6)\n#define P2C_RG_XCVRSEL\t\t\tGENMASK(5, 4)\n#define P2C_RG_SUSPENDM\t\t\tBIT(3)\n#define P2C_RG_TERMSEL\t\t\tBIT(2)\n#define P2C_DTM0_PART_MASK \\\n\t\t(P2C_FORCE_DATAIN | P2C_FORCE_DM_PULLDOWN | \\\n\t\tP2C_FORCE_DP_PULLDOWN | P2C_FORCE_XCVRSEL | \\\n\t\tP2C_FORCE_TERMSEL | P2C_RG_DMPULLDOWN | \\\n\t\tP2C_RG_DPPULLDOWN | P2C_RG_TERMSEL)\n\n#define U3P_U2PHYDTM1\t\t0x06C\n#define P2C_RG_UART_EN\t\t\tBIT(16)\n#define P2C_FORCE_IDDIG\t\tBIT(9)\n#define P2C_RG_VBUSVALID\t\tBIT(5)\n#define P2C_RG_SESSEND\t\t\tBIT(4)\n#define P2C_RG_AVALID\t\t\tBIT(2)\n#define P2C_RG_IDDIG\t\t\tBIT(1)\n\n#define U3P_U2PHYBC12C\t\t0x080\n#define P2C_RG_CHGDT_EN\t\tBIT(0)\n\n#define U3P_U3_CHIP_GPIO_CTLD\t\t0x0c\n#define P3C_REG_IP_SW_RST\t\tBIT(31)\n#define P3C_MCU_BUS_CK_GATE_EN\t\tBIT(30)\n#define P3C_FORCE_IP_SW_RST\t\tBIT(29)\n\n#define U3P_U3_CHIP_GPIO_CTLE\t\t0x10\n#define P3C_RG_SWRST_U3_PHYD\t\tBIT(25)\n#define P3C_RG_SWRST_U3_PHYD_FORCE_EN\tBIT(24)\n\n#define U3P_U3_PHYA_REG0\t0x000\n#define P3A_RG_IEXT_INTR\t\tGENMASK(15, 10)\n#define P3A_RG_CLKDRV_OFF\t\tGENMASK(3, 2)\n\n#define U3P_U3_PHYA_REG1\t0x004\n#define P3A_RG_CLKDRV_AMP\t\tGENMASK(31, 29)\n\n#define U3P_U3_PHYA_REG6\t0x018\n#define P3A_RG_TX_EIDLE_CM\t\tGENMASK(31, 28)\n\n#define U3P_U3_PHYA_REG9\t0x024\n#define P3A_RG_RX_DAC_MUX\t\tGENMASK(5, 1)\n\n#define U3P_U3_PHYA_DA_REG0\t0x100\n#define P3A_RG_XTAL_EXT_PE2H\t\tGENMASK(17, 16)\n#define P3A_RG_XTAL_EXT_PE1H\t\tGENMASK(13, 12)\n#define P3A_RG_XTAL_EXT_EN_U3\t\tGENMASK(11, 10)\n\n#define U3P_U3_PHYA_DA_REG4\t0x108\n#define P3A_RG_PLL_DIVEN_PE2H\t\tGENMASK(21, 19)\n#define P3A_RG_PLL_BC_PE2H\t\tGENMASK(7, 6)\n\n#define U3P_U3_PHYA_DA_REG5\t0x10c\n#define P3A_RG_PLL_BR_PE2H\t\tGENMASK(29, 28)\n#define P3A_RG_PLL_IC_PE2H\t\tGENMASK(15, 12)\n\n#define U3P_U3_PHYA_DA_REG6\t0x110\n#define P3A_RG_PLL_IR_PE2H\t\tGENMASK(19, 16)\n\n#define U3P_U3_PHYA_DA_REG7\t0x114\n#define P3A_RG_PLL_BP_PE2H\t\tGENMASK(19, 16)\n\n#define U3P_U3_PHYA_DA_REG20\t0x13c\n#define P3A_RG_PLL_DELTA1_PE2H\t\tGENMASK(31, 16)\n\n#define U3P_U3_PHYA_DA_REG25\t0x148\n#define P3A_RG_PLL_DELTA_PE2H\t\tGENMASK(15, 0)\n\n#define U3P_U3_PHYD_LFPS1\t\t0x00c\n#define P3D_RG_FWAKE_TH\t\tGENMASK(21, 16)\n\n#define U3P_U3_PHYD_IMPCAL0\t\t0x010\n#define P3D_RG_FORCE_TX_IMPEL\t\tBIT(31)\n#define P3D_RG_TX_IMPEL\t\t\tGENMASK(28, 24)\n\n#define U3P_U3_PHYD_IMPCAL1\t\t0x014\n#define P3D_RG_FORCE_RX_IMPEL\t\tBIT(31)\n#define P3D_RG_RX_IMPEL\t\t\tGENMASK(28, 24)\n\n#define U3P_U3_PHYD_RSV\t\t\t0x054\n#define P3D_RG_EFUSE_AUTO_LOAD_DIS\tBIT(12)\n\n#define U3P_U3_PHYD_CDR1\t\t0x05c\n#define P3D_RG_CDR_BIR_LTD1\t\tGENMASK(28, 24)\n#define P3D_RG_CDR_BIR_LTD0\t\tGENMASK(12, 8)\n\n#define U3P_U3_PHYD_RXDET1\t\t0x128\n#define P3D_RG_RXDET_STB2_SET\t\tGENMASK(17, 9)\n\n#define U3P_U3_PHYD_RXDET2\t\t0x12c\n#define P3D_RG_RXDET_STB2_SET_P3\tGENMASK(8, 0)\n\n#define U3P_SPLLC_XTALCTL3\t\t0x018\n#define XC3_RG_U3_XTAL_RX_PWD\t\tBIT(9)\n#define XC3_RG_U3_FRC_XTAL_RX_PWD\tBIT(8)\n\n#define U3P_U2FREQ_FMCR0\t0x00\n#define P2F_RG_MONCLK_SEL\tGENMASK(27, 26)\n#define P2F_RG_FREQDET_EN\tBIT(24)\n#define P2F_RG_CYCLECNT\t\tGENMASK(23, 0)\n\n#define U3P_U2FREQ_VALUE\t0x0c\n\n#define U3P_U2FREQ_FMMONR1\t0x10\n#define P2F_USB_FM_VALID\tBIT(0)\n#define P2F_RG_FRCK_EN\t\tBIT(8)\n\n#define U3P_REF_CLK\t\t26\t \n#define U3P_SLEW_RATE_COEF\t28\n#define U3P_SR_COEF_DIVISOR\t1000\n#define U3P_FM_DET_CYCLE_CNT\t1024\n\n \n#define PHYD_CTRL_SIGNAL_MODE4\t\t0x1c\n \n#define RG_CDR_BICLTD1_GEN1_MSK\t\tGENMASK(23, 20)\n#define RG_CDR_BICLTD0_GEN1_MSK\t\tGENMASK(11, 8)\n\n#define PHYD_DESIGN_OPTION2\t\t0x24\n \n#define RG_LOCK_CNT_SEL_MSK\t\tGENMASK(5, 4)\n\n#define PHYD_DESIGN_OPTION9\t0x40\n \n#define RG_TG_MAX_MSK\t\tGENMASK(20, 16)\n \n#define RG_T2_MAX_MSK\t\tGENMASK(13, 8)\n \n#define RG_TG_MIN_MSK\t\tGENMASK(7, 5)\n \n#define RG_T2_MIN_MSK\t\tGENMASK(4, 0)\n\n#define ANA_RG_CTRL_SIGNAL1\t\t0x4c\n \n#define RG_IDRV_0DB_GEN1_MSK\t\tGENMASK(13, 8)\n\n#define ANA_RG_CTRL_SIGNAL4\t\t0x58\n#define RG_CDR_BICLTR_GEN1_MSK\t\tGENMASK(23, 20)\n \n#define RG_CDR_BR_GEN2_MSK\t\tGENMASK(10, 8)\n\n#define ANA_RG_CTRL_SIGNAL6\t\t0x60\n \n#define RG_CDR_BC_GEN1_MSK\t\tGENMASK(28, 24)\n#define RG_CDR_BIRLTR_GEN1_MSK\t\tGENMASK(4, 0)\n\n#define ANA_EQ_EYE_CTRL_SIGNAL1\t\t0x6c\n \n#define RG_EQ_DLEQ_LFI_GEN1_MSK\t\tGENMASK(11, 8)\n\n#define ANA_EQ_EYE_CTRL_SIGNAL4\t\t0xd8\n#define RG_CDR_BIRLTD0_GEN1_MSK\t\tGENMASK(20, 16)\n\n#define ANA_EQ_EYE_CTRL_SIGNAL5\t\t0xdc\n#define RG_CDR_BIRLTD0_GEN3_MSK\t\tGENMASK(4, 0)\n\n \n#define USB_PHY_SWITCH_CTRL\t0x0\n#define RG_PHY_SW_TYPE\t\tGENMASK(3, 0)\n#define RG_PHY_SW_PCIE\t\t0x0\n#define RG_PHY_SW_USB3\t\t0x1\n#define RG_PHY_SW_SGMII\t\t0x2\n#define RG_PHY_SW_SATA\t\t0x3\n\n#define TPHY_CLKS_CNT\t2\n\n#define USER_BUF_LEN(count) min_t(size_t, 8, (count))\n\nenum mtk_phy_version {\n\tMTK_PHY_V1 = 1,\n\tMTK_PHY_V2,\n\tMTK_PHY_V3,\n};\n\nstruct mtk_phy_pdata {\n\t \n\tbool avoid_rx_sen_degradation;\n\t \n\tbool sw_pll_48m_to_26m;\n\t \n\tbool sw_efuse_supported;\n\tenum mtk_phy_version version;\n};\n\nstruct u2phy_banks {\n\tvoid __iomem *misc;\n\tvoid __iomem *fmreg;\n\tvoid __iomem *com;\n};\n\nstruct u3phy_banks {\n\tvoid __iomem *spllc;\n\tvoid __iomem *chip;\n\tvoid __iomem *phyd;  \n\tvoid __iomem *phya;  \n};\n\nstruct mtk_phy_instance {\n\tstruct phy *phy;\n\tvoid __iomem *port_base;\n\tunion {\n\t\tstruct u2phy_banks u2_banks;\n\t\tstruct u3phy_banks u3_banks;\n\t};\n\tstruct clk_bulk_data clks[TPHY_CLKS_CNT];\n\tu32 index;\n\tu32 type;\n\tstruct regmap *type_sw;\n\tu32 type_sw_reg;\n\tu32 type_sw_index;\n\tu32 efuse_sw_en;\n\tu32 efuse_intr;\n\tu32 efuse_tx_imp;\n\tu32 efuse_rx_imp;\n\tint eye_src;\n\tint eye_vrt;\n\tint eye_term;\n\tint intr;\n\tint discth;\n\tint pre_emphasis;\n\tbool bc12_en;\n};\n\nstruct mtk_tphy {\n\tstruct device *dev;\n\tvoid __iomem *sif_base;\t \n\tconst struct mtk_phy_pdata *pdata;\n\tstruct mtk_phy_instance **phys;\n\tint nphys;\n\tint src_ref_clk;  \n\tint src_coef;  \n};\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\n\nenum u2_phy_params {\n\tU2P_EYE_VRT = 0,\n\tU2P_EYE_TERM,\n\tU2P_EFUSE_EN,\n\tU2P_EFUSE_INTR,\n\tU2P_DISCTH,\n\tU2P_PRE_EMPHASIS,\n};\n\nenum u3_phy_params {\n\tU3P_EFUSE_EN = 0,\n\tU3P_EFUSE_INTR,\n\tU3P_EFUSE_TX_IMP,\n\tU3P_EFUSE_RX_IMP,\n};\n\nstatic const char *const u2_phy_files[] = {\n\t[U2P_EYE_VRT] = \"vrt\",\n\t[U2P_EYE_TERM] = \"term\",\n\t[U2P_EFUSE_EN] = \"efuse\",\n\t[U2P_EFUSE_INTR] = \"intr\",\n\t[U2P_DISCTH] = \"discth\",\n\t[U2P_PRE_EMPHASIS] = \"preemph\",\n};\n\nstatic const char *const u3_phy_files[] = {\n\t[U3P_EFUSE_EN] = \"efuse\",\n\t[U3P_EFUSE_INTR] = \"intr\",\n\t[U3P_EFUSE_TX_IMP] = \"tx-imp\",\n\t[U3P_EFUSE_RX_IMP] = \"rx-imp\",\n};\n\nstatic int u2_phy_params_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtk_phy_instance *inst = sf->private;\n\tconst char *fname = file_dentry(sf->file)->d_iname;\n\tstruct u2phy_banks *u2_banks = &inst->u2_banks;\n\tvoid __iomem *com = u2_banks->com;\n\tu32 max = 0;\n\tu32 tmp = 0;\n\tu32 val = 0;\n\tint ret;\n\n\tret = match_string(u2_phy_files, ARRAY_SIZE(u2_phy_files), fname);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret) {\n\tcase U2P_EYE_VRT:\n\t\ttmp = readl(com + U3P_USBPHYACR1);\n\t\tval = FIELD_GET(PA1_RG_VRT_SEL, tmp);\n\t\tmax = FIELD_MAX(PA1_RG_VRT_SEL);\n\t\tbreak;\n\n\tcase U2P_EYE_TERM:\n\t\ttmp = readl(com + U3P_USBPHYACR1);\n\t\tval = FIELD_GET(PA1_RG_TERM_SEL, tmp);\n\t\tmax = FIELD_MAX(PA1_RG_TERM_SEL);\n\t\tbreak;\n\n\tcase U2P_EFUSE_EN:\n\t\tif (u2_banks->misc) {\n\t\t\ttmp = readl(u2_banks->misc + U3P_MISC_REG1);\n\t\t\tmax = 1;\n\t\t}\n\n\t\tval = !!(tmp & MR1_EFUSE_AUTO_LOAD_DIS);\n\t\tbreak;\n\n\tcase U2P_EFUSE_INTR:\n\t\ttmp = readl(com + U3P_USBPHYACR1);\n\t\tval = FIELD_GET(PA1_RG_INTR_CAL, tmp);\n\t\tmax = FIELD_MAX(PA1_RG_INTR_CAL);\n\t\tbreak;\n\n\tcase U2P_DISCTH:\n\t\ttmp = readl(com + U3P_USBPHYACR6);\n\t\tval = FIELD_GET(PA6_RG_U2_DISCTH, tmp);\n\t\tmax = FIELD_MAX(PA6_RG_U2_DISCTH);\n\t\tbreak;\n\n\tcase U2P_PRE_EMPHASIS:\n\t\ttmp = readl(com + U3P_USBPHYACR6);\n\t\tval = FIELD_GET(PA6_RG_U2_PRE_EMP, tmp);\n\t\tmax = FIELD_MAX(PA6_RG_U2_PRE_EMP);\n\t\tbreak;\n\n\tdefault:\n\t\tseq_printf(sf, \"invalid, %d\\n\", ret);\n\t\tbreak;\n\t}\n\n\tseq_printf(sf, \"%s : %d [0, %d]\\n\", fname, val, max);\n\n\treturn 0;\n}\n\nstatic int u2_phy_params_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, u2_phy_params_show, inode->i_private);\n}\n\nstatic ssize_t u2_phy_params_write(struct file *file, const char __user *ubuf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tconst char *fname = file_dentry(file)->d_iname;\n\tstruct seq_file *sf = file->private_data;\n\tstruct mtk_phy_instance *inst = sf->private;\n\tstruct u2phy_banks *u2_banks = &inst->u2_banks;\n\tvoid __iomem *com = u2_banks->com;\n\tssize_t rc;\n\tu32 val;\n\tint ret;\n\n\trc = kstrtouint_from_user(ubuf, USER_BUF_LEN(count), 0, &val);\n\tif (rc)\n\t\treturn rc;\n\n\tret = match_string(u2_phy_files, ARRAY_SIZE(u2_phy_files), fname);\n\tif (ret < 0)\n\t\treturn (ssize_t)ret;\n\n\tswitch (ret) {\n\tcase U2P_EYE_VRT:\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR1, PA1_RG_VRT_SEL, val);\n\t\tbreak;\n\n\tcase U2P_EYE_TERM:\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR1, PA1_RG_TERM_SEL, val);\n\t\tbreak;\n\n\tcase U2P_EFUSE_EN:\n\t\tif (u2_banks->misc)\n\t\t\tmtk_phy_update_field(u2_banks->misc + U3P_MISC_REG1,\n\t\t\t\t\t     MR1_EFUSE_AUTO_LOAD_DIS, !!val);\n\t\tbreak;\n\n\tcase U2P_EFUSE_INTR:\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR1, PA1_RG_INTR_CAL, val);\n\t\tbreak;\n\n\tcase U2P_DISCTH:\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR6, PA6_RG_U2_DISCTH, val);\n\t\tbreak;\n\n\tcase U2P_PRE_EMPHASIS:\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR6, PA6_RG_U2_PRE_EMP, val);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations u2_phy_fops = {\n\t.open = u2_phy_params_open,\n\t.write = u2_phy_params_write,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void u2_phy_dbgfs_files_create(struct mtk_phy_instance *inst)\n{\n\tu32 count = ARRAY_SIZE(u2_phy_files);\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tdebugfs_create_file(u2_phy_files[i], 0644, inst->phy->debugfs,\n\t\t\t\t    inst, &u2_phy_fops);\n}\n\nstatic int u3_phy_params_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtk_phy_instance *inst = sf->private;\n\tconst char *fname = file_dentry(sf->file)->d_iname;\n\tstruct u3phy_banks *u3_banks = &inst->u3_banks;\n\tu32 val = 0;\n\tu32 max = 0;\n\tu32 tmp;\n\tint ret;\n\n\tret = match_string(u3_phy_files, ARRAY_SIZE(u3_phy_files), fname);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret) {\n\tcase U3P_EFUSE_EN:\n\t\ttmp = readl(u3_banks->phyd + U3P_U3_PHYD_RSV);\n\t\tval = !!(tmp & P3D_RG_EFUSE_AUTO_LOAD_DIS);\n\t\tmax = 1;\n\t\tbreak;\n\n\tcase U3P_EFUSE_INTR:\n\t\ttmp = readl(u3_banks->phya + U3P_U3_PHYA_REG0);\n\t\tval = FIELD_GET(P3A_RG_IEXT_INTR, tmp);\n\t\tmax = FIELD_MAX(P3A_RG_IEXT_INTR);\n\t\tbreak;\n\n\tcase U3P_EFUSE_TX_IMP:\n\t\ttmp = readl(u3_banks->phyd + U3P_U3_PHYD_IMPCAL0);\n\t\tval = FIELD_GET(P3D_RG_TX_IMPEL, tmp);\n\t\tmax = FIELD_MAX(P3D_RG_TX_IMPEL);\n\t\tbreak;\n\n\tcase U3P_EFUSE_RX_IMP:\n\t\ttmp = readl(u3_banks->phyd + U3P_U3_PHYD_IMPCAL1);\n\t\tval = FIELD_GET(P3D_RG_RX_IMPEL, tmp);\n\t\tmax = FIELD_MAX(P3D_RG_RX_IMPEL);\n\t\tbreak;\n\n\tdefault:\n\t\tseq_printf(sf, \"invalid, %d\\n\", ret);\n\t\tbreak;\n\t}\n\n\tseq_printf(sf, \"%s : %d [0, %d]\\n\", fname, val, max);\n\n\treturn 0;\n}\n\nstatic int u3_phy_params_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, u3_phy_params_show, inode->i_private);\n}\n\nstatic ssize_t u3_phy_params_write(struct file *file, const char __user *ubuf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tconst char *fname = file_dentry(file)->d_iname;\n\tstruct seq_file *sf = file->private_data;\n\tstruct mtk_phy_instance *inst = sf->private;\n\tstruct u3phy_banks *u3_banks = &inst->u3_banks;\n\tvoid __iomem *phyd = u3_banks->phyd;\n\tssize_t rc;\n\tu32 val;\n\tint ret;\n\n\trc = kstrtouint_from_user(ubuf, USER_BUF_LEN(count), 0, &val);\n\tif (rc)\n\t\treturn rc;\n\n\tret = match_string(u3_phy_files, ARRAY_SIZE(u3_phy_files), fname);\n\tif (ret < 0)\n\t\treturn (ssize_t)ret;\n\n\tswitch (ret) {\n\tcase U3P_EFUSE_EN:\n\t\tmtk_phy_update_field(phyd + U3P_U3_PHYD_RSV,\n\t\t\t\t     P3D_RG_EFUSE_AUTO_LOAD_DIS, !!val);\n\t\tbreak;\n\n\tcase U3P_EFUSE_INTR:\n\t\tmtk_phy_update_field(u3_banks->phya + U3P_U3_PHYA_REG0,\n\t\t\t\t     P3A_RG_IEXT_INTR, val);\n\t\tbreak;\n\n\tcase U3P_EFUSE_TX_IMP:\n\t\tmtk_phy_update_field(phyd + U3P_U3_PHYD_IMPCAL0, P3D_RG_TX_IMPEL, val);\n\t\tmtk_phy_set_bits(phyd + U3P_U3_PHYD_IMPCAL0, P3D_RG_FORCE_TX_IMPEL);\n\t\tbreak;\n\n\tcase U3P_EFUSE_RX_IMP:\n\t\tmtk_phy_update_field(phyd + U3P_U3_PHYD_IMPCAL1, P3D_RG_RX_IMPEL, val);\n\t\tmtk_phy_set_bits(phyd + U3P_U3_PHYD_IMPCAL1, P3D_RG_FORCE_RX_IMPEL);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations u3_phy_fops = {\n\t.open = u3_phy_params_open,\n\t.write = u3_phy_params_write,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void u3_phy_dbgfs_files_create(struct mtk_phy_instance *inst)\n{\n\tu32 count = ARRAY_SIZE(u3_phy_files);\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tdebugfs_create_file(u3_phy_files[i], 0644, inst->phy->debugfs,\n\t\t\t\t    inst, &u3_phy_fops);\n}\n\nstatic int phy_type_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtk_phy_instance *inst = sf->private;\n\tconst char *type;\n\n\tswitch (inst->type) {\n\tcase PHY_TYPE_USB2:\n\t\ttype = \"USB2\";\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\t\ttype = \"USB3\";\n\t\tbreak;\n\tcase PHY_TYPE_PCIE:\n\t\ttype = \"PCIe\";\n\t\tbreak;\n\tcase PHY_TYPE_SGMII:\n\t\ttype = \"SGMII\";\n\t\tbreak;\n\tcase PHY_TYPE_SATA:\n\t\ttype = \"SATA\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"\";\n\t}\n\n\tseq_printf(sf, \"%s\\n\", type);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(phy_type);\n\n \nstatic void phy_debugfs_init(struct mtk_phy_instance *inst)\n{\n\tdebugfs_create_file(\"type\", 0444, inst->phy->debugfs, inst, &phy_type_fops);\n\n\tswitch (inst->type) {\n\tcase PHY_TYPE_USB2:\n\t\tu2_phy_dbgfs_files_create(inst);\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\tcase PHY_TYPE_PCIE:\n\t\tu3_phy_dbgfs_files_create(inst);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#else\n\nstatic void phy_debugfs_init(struct mtk_phy_instance *inst)\n{}\n\n#endif\n\nstatic void hs_slew_rate_calibrate(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tvoid __iomem *fmreg = u2_banks->fmreg;\n\tvoid __iomem *com = u2_banks->com;\n\tint calibration_val;\n\tint fm_out;\n\tu32 tmp;\n\n\t \n\tif (tphy->pdata->version == MTK_PHY_V3)\n\t\treturn;\n\n\t \n\tif (instance->eye_src)\n\t\treturn;\n\n\t \n\tmtk_phy_set_bits(com + U3P_USBPHYACR5, PA5_RG_U2_HSTX_SRCAL_EN);\n\tudelay(1);\n\n\t \n\tmtk_phy_set_bits(fmreg + U3P_U2FREQ_FMMONR1, P2F_RG_FRCK_EN);\n\n\t \n\ttmp = readl(fmreg + U3P_U2FREQ_FMCR0);\n\ttmp &= ~(P2F_RG_CYCLECNT | P2F_RG_MONCLK_SEL);\n\ttmp |= FIELD_PREP(P2F_RG_CYCLECNT, U3P_FM_DET_CYCLE_CNT);\n\tif (tphy->pdata->version == MTK_PHY_V1)\n\t\ttmp |= FIELD_PREP(P2F_RG_MONCLK_SEL, instance->index >> 1);\n\n\twritel(tmp, fmreg + U3P_U2FREQ_FMCR0);\n\n\t \n\tmtk_phy_set_bits(fmreg + U3P_U2FREQ_FMCR0, P2F_RG_FREQDET_EN);\n\n\t \n\treadl_poll_timeout(fmreg + U3P_U2FREQ_FMMONR1, tmp,\n\t\t\t   (tmp & P2F_USB_FM_VALID), 10, 200);\n\n\tfm_out = readl(fmreg + U3P_U2FREQ_VALUE);\n\n\t \n\tmtk_phy_clear_bits(fmreg + U3P_U2FREQ_FMCR0, P2F_RG_FREQDET_EN);\n\n\t \n\tmtk_phy_clear_bits(fmreg + U3P_U2FREQ_FMMONR1, P2F_RG_FRCK_EN);\n\n\tif (fm_out) {\n\t\t \n\t\ttmp = tphy->src_ref_clk * tphy->src_coef;\n\t\ttmp = (tmp * U3P_FM_DET_CYCLE_CNT) / fm_out;\n\t\tcalibration_val = DIV_ROUND_CLOSEST(tmp, U3P_SR_COEF_DIVISOR);\n\t} else {\n\t\t \n\t\tcalibration_val = 4;\n\t}\n\tdev_dbg(tphy->dev, \"phy:%d, fm_out:%d, calib:%d (clk:%d, coef:%d)\\n\",\n\t\tinstance->index, fm_out, calibration_val,\n\t\ttphy->src_ref_clk, tphy->src_coef);\n\n\t \n\tmtk_phy_update_field(com + U3P_USBPHYACR5, PA5_RG_U2_HSTX_SRCTRL,\n\t\t\t     calibration_val);\n\n\t \n\tmtk_phy_clear_bits(com + U3P_USBPHYACR5, PA5_RG_U2_HSTX_SRCAL_EN);\n}\n\nstatic void u3_phy_instance_init(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u3phy_banks *u3_banks = &instance->u3_banks;\n\tvoid __iomem *phya = u3_banks->phya;\n\tvoid __iomem *phyd = u3_banks->phyd;\n\n\t \n\tmtk_phy_set_bits(u3_banks->spllc + U3P_SPLLC_XTALCTL3,\n\t\t\t XC3_RG_U3_XTAL_RX_PWD | XC3_RG_U3_FRC_XTAL_RX_PWD);\n\n\t \n\tmtk_phy_update_field(phya + U3P_U3_PHYA_DA_REG0, P3A_RG_XTAL_EXT_EN_U3, 2);\n\n\tmtk_phy_update_field(phya + U3P_U3_PHYA_REG9, P3A_RG_RX_DAC_MUX, 4);\n\n\tmtk_phy_update_field(phya + U3P_U3_PHYA_REG6, P3A_RG_TX_EIDLE_CM, 0xe);\n\n\tmtk_phy_update_bits(u3_banks->phyd + U3P_U3_PHYD_CDR1,\n\t\t\t    P3D_RG_CDR_BIR_LTD0 | P3D_RG_CDR_BIR_LTD1,\n\t\t\t    FIELD_PREP(P3D_RG_CDR_BIR_LTD0, 0xc) |\n\t\t\t    FIELD_PREP(P3D_RG_CDR_BIR_LTD1, 0x3));\n\n\tmtk_phy_update_field(phyd + U3P_U3_PHYD_LFPS1, P3D_RG_FWAKE_TH, 0x34);\n\n\tmtk_phy_update_field(phyd + U3P_U3_PHYD_RXDET1, P3D_RG_RXDET_STB2_SET, 0x10);\n\n\tmtk_phy_update_field(phyd + U3P_U3_PHYD_RXDET2, P3D_RG_RXDET_STB2_SET_P3, 0x10);\n\n\tdev_dbg(tphy->dev, \"%s(%d)\\n\", __func__, instance->index);\n}\n\nstatic void u2_phy_pll_26m_set(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tvoid __iomem *com = u2_banks->com;\n\n\tif (!tphy->pdata->sw_pll_48m_to_26m)\n\t\treturn;\n\n\tmtk_phy_update_field(com + U3P_USBPHYACR0, PA0_USB20_PLL_PREDIV, 0);\n\n\tmtk_phy_update_field(com + U3P_USBPHYACR2, PA2_RG_U2PLL_BW, 3);\n\n\twritel(P2R_RG_U2PLL_FBDIV_26M, com + U3P_U2PHYA_RESV);\n\n\tmtk_phy_set_bits(com + U3P_U2PHYA_RESV1,\n\t\t\t P2R_RG_U2PLL_FRA_EN | P2R_RG_U2PLL_REFCLK_SEL);\n}\n\nstatic void u2_phy_instance_init(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tvoid __iomem *com = u2_banks->com;\n\tu32 index = instance->index;\n\n\t \n\tmtk_phy_clear_bits(com + U3P_U2PHYDTM0, P2C_FORCE_UART_EN | P2C_FORCE_SUSPENDM);\n\n\tmtk_phy_clear_bits(com + U3P_U2PHYDTM0,\n\t\t\t   P2C_RG_XCVRSEL | P2C_RG_DATAIN | P2C_DTM0_PART_MASK);\n\n\tmtk_phy_clear_bits(com + U3P_U2PHYDTM1, P2C_RG_UART_EN);\n\n\tmtk_phy_set_bits(com + U3P_USBPHYACR0, PA0_RG_USB20_INTR_EN);\n\n\t \n\tmtk_phy_clear_bits(com + U3P_USBPHYACR5, PA5_RG_U2_HS_100U_U3_EN);\n\n\tmtk_phy_clear_bits(com + U3P_U2PHYACR4, P2C_U2_GPIO_CTR_MSK);\n\n\tif (tphy->pdata->avoid_rx_sen_degradation) {\n\t\tif (!index) {\n\t\t\tmtk_phy_set_bits(com + U3P_USBPHYACR2, PA2_RG_SIF_U2PLL_FORCE_EN);\n\n\t\t\tmtk_phy_clear_bits(com + U3D_U2PHYDCR0, P2C_RG_SIF_U2PLL_FORCE_ON);\n\t\t} else {\n\t\t\tmtk_phy_set_bits(com + U3D_U2PHYDCR0, P2C_RG_SIF_U2PLL_FORCE_ON);\n\n\t\t\tmtk_phy_set_bits(com + U3P_U2PHYDTM0,\n\t\t\t\t\t P2C_RG_SUSPENDM | P2C_FORCE_SUSPENDM);\n\t\t}\n\t}\n\n\t \n\tmtk_phy_clear_bits(com + U3P_USBPHYACR6, PA6_RG_U2_BC11_SW_EN);\n\n\tmtk_phy_update_field(com + U3P_USBPHYACR6, PA6_RG_U2_SQTH, 2);\n\n\t \n\tu2_phy_pll_26m_set(tphy, instance);\n\n\tdev_dbg(tphy->dev, \"%s(%d)\\n\", __func__, index);\n}\n\nstatic void u2_phy_instance_power_on(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tvoid __iomem *com = u2_banks->com;\n\tu32 index = instance->index;\n\n\t \n\tmtk_phy_set_bits(com + U3P_USBPHYACR6, PA6_RG_U2_OTG_VBUSCMP_EN);\n\n\tmtk_phy_set_bits(com + U3P_U2PHYDTM1, P2C_RG_VBUSVALID | P2C_RG_AVALID);\n\n\tmtk_phy_clear_bits(com + U3P_U2PHYDTM1, P2C_RG_SESSEND);\n\n\tif (tphy->pdata->avoid_rx_sen_degradation && index) {\n\t\tmtk_phy_set_bits(com + U3D_U2PHYDCR0, P2C_RG_SIF_U2PLL_FORCE_ON);\n\n\t\tmtk_phy_set_bits(com + U3P_U2PHYDTM0, P2C_RG_SUSPENDM | P2C_FORCE_SUSPENDM);\n\t}\n\tdev_dbg(tphy->dev, \"%s(%d)\\n\", __func__, index);\n}\n\nstatic void u2_phy_instance_power_off(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tvoid __iomem *com = u2_banks->com;\n\tu32 index = instance->index;\n\n\t \n\tmtk_phy_clear_bits(com + U3P_USBPHYACR6, PA6_RG_U2_OTG_VBUSCMP_EN);\n\n\tmtk_phy_clear_bits(com + U3P_U2PHYDTM1, P2C_RG_VBUSVALID | P2C_RG_AVALID);\n\n\tmtk_phy_set_bits(com + U3P_U2PHYDTM1, P2C_RG_SESSEND);\n\n\tif (tphy->pdata->avoid_rx_sen_degradation && index) {\n\t\tmtk_phy_clear_bits(com + U3P_U2PHYDTM0, P2C_RG_SUSPENDM | P2C_FORCE_SUSPENDM);\n\n\t\tmtk_phy_clear_bits(com + U3D_U2PHYDCR0, P2C_RG_SIF_U2PLL_FORCE_ON);\n\t}\n\n\tdev_dbg(tphy->dev, \"%s(%d)\\n\", __func__, index);\n}\n\nstatic void u2_phy_instance_exit(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tvoid __iomem *com = u2_banks->com;\n\tu32 index = instance->index;\n\n\tif (tphy->pdata->avoid_rx_sen_degradation && index) {\n\t\tmtk_phy_clear_bits(com + U3D_U2PHYDCR0, P2C_RG_SIF_U2PLL_FORCE_ON);\n\n\t\tmtk_phy_clear_bits(com + U3P_U2PHYDTM0, P2C_FORCE_SUSPENDM);\n\t}\n}\n\nstatic void u2_phy_instance_set_mode(struct mtk_tphy *tphy,\n\t\t\t\t     struct mtk_phy_instance *instance,\n\t\t\t\t     enum phy_mode mode)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tu32 tmp;\n\n\ttmp = readl(u2_banks->com + U3P_U2PHYDTM1);\n\tswitch (mode) {\n\tcase PHY_MODE_USB_DEVICE:\n\t\ttmp |= P2C_FORCE_IDDIG | P2C_RG_IDDIG;\n\t\tbreak;\n\tcase PHY_MODE_USB_HOST:\n\t\ttmp |= P2C_FORCE_IDDIG;\n\t\ttmp &= ~P2C_RG_IDDIG;\n\t\tbreak;\n\tcase PHY_MODE_USB_OTG:\n\t\ttmp &= ~(P2C_FORCE_IDDIG | P2C_RG_IDDIG);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\twritel(tmp, u2_banks->com + U3P_U2PHYDTM1);\n}\n\nstatic void pcie_phy_instance_init(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u3phy_banks *u3_banks = &instance->u3_banks;\n\tvoid __iomem *phya = u3_banks->phya;\n\n\tif (tphy->pdata->version != MTK_PHY_V1)\n\t\treturn;\n\n\tmtk_phy_update_bits(phya + U3P_U3_PHYA_DA_REG0,\n\t\t\t    P3A_RG_XTAL_EXT_PE1H | P3A_RG_XTAL_EXT_PE2H,\n\t\t\t    FIELD_PREP(P3A_RG_XTAL_EXT_PE1H, 0x2) |\n\t\t\t    FIELD_PREP(P3A_RG_XTAL_EXT_PE2H, 0x2));\n\n\t \n\tmtk_phy_update_field(phya + U3P_U3_PHYA_REG1, P3A_RG_CLKDRV_AMP, 0x4);\n\n\tmtk_phy_update_field(phya + U3P_U3_PHYA_REG0, P3A_RG_CLKDRV_OFF, 0x1);\n\n\t \n\tmtk_phy_update_field(phya + U3P_U3_PHYA_DA_REG20, P3A_RG_PLL_DELTA1_PE2H, 0x3c);\n\n\tmtk_phy_update_field(phya + U3P_U3_PHYA_DA_REG25, P3A_RG_PLL_DELTA_PE2H, 0x36);\n\n\t \n\tmtk_phy_update_bits(phya + U3P_U3_PHYA_DA_REG5,\n\t\t\t    P3A_RG_PLL_BR_PE2H | P3A_RG_PLL_IC_PE2H,\n\t\t\t    FIELD_PREP(P3A_RG_PLL_BR_PE2H, 0x1) |\n\t\t\t    FIELD_PREP(P3A_RG_PLL_IC_PE2H, 0x1));\n\n\tmtk_phy_update_bits(phya + U3P_U3_PHYA_DA_REG4,\n\t\t\t    P3A_RG_PLL_DIVEN_PE2H | P3A_RG_PLL_BC_PE2H,\n\t\t\t    FIELD_PREP(P3A_RG_PLL_BC_PE2H, 0x3));\n\n\tmtk_phy_update_field(phya + U3P_U3_PHYA_DA_REG6, P3A_RG_PLL_IR_PE2H, 0x2);\n\n\tmtk_phy_update_field(phya + U3P_U3_PHYA_DA_REG7, P3A_RG_PLL_BP_PE2H, 0xa);\n\n\t \n\tmtk_phy_update_field(u3_banks->phyd + U3P_U3_PHYD_RXDET1,\n\t\t\t     P3D_RG_RXDET_STB2_SET, 0x10);\n\n\tmtk_phy_update_field(u3_banks->phyd + U3P_U3_PHYD_RXDET2,\n\t\t\t     P3D_RG_RXDET_STB2_SET_P3, 0x10);\n\n\t \n\tusleep_range(2500, 3000);\n\tdev_dbg(tphy->dev, \"%s(%d)\\n\", __func__, instance->index);\n}\n\nstatic void pcie_phy_instance_power_on(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u3phy_banks *bank = &instance->u3_banks;\n\n\tmtk_phy_clear_bits(bank->chip + U3P_U3_CHIP_GPIO_CTLD,\n\t\t\t   P3C_FORCE_IP_SW_RST | P3C_REG_IP_SW_RST);\n\n\tmtk_phy_clear_bits(bank->chip + U3P_U3_CHIP_GPIO_CTLE,\n\t\t\t   P3C_RG_SWRST_U3_PHYD_FORCE_EN | P3C_RG_SWRST_U3_PHYD);\n}\n\nstatic void pcie_phy_instance_power_off(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n\n{\n\tstruct u3phy_banks *bank = &instance->u3_banks;\n\n\tmtk_phy_set_bits(bank->chip + U3P_U3_CHIP_GPIO_CTLD,\n\t\t\t P3C_FORCE_IP_SW_RST | P3C_REG_IP_SW_RST);\n\n\tmtk_phy_set_bits(bank->chip + U3P_U3_CHIP_GPIO_CTLE,\n\t\t\t P3C_RG_SWRST_U3_PHYD_FORCE_EN | P3C_RG_SWRST_U3_PHYD);\n}\n\nstatic void sata_phy_instance_init(struct mtk_tphy *tphy,\n\tstruct mtk_phy_instance *instance)\n{\n\tstruct u3phy_banks *u3_banks = &instance->u3_banks;\n\tvoid __iomem *phyd = u3_banks->phyd;\n\n\t \n\tmtk_phy_update_bits(phyd + ANA_RG_CTRL_SIGNAL6,\n\t\t\t    RG_CDR_BIRLTR_GEN1_MSK | RG_CDR_BC_GEN1_MSK,\n\t\t\t    FIELD_PREP(RG_CDR_BIRLTR_GEN1_MSK, 0x6) |\n\t\t\t    FIELD_PREP(RG_CDR_BC_GEN1_MSK, 0x1a));\n\n\tmtk_phy_update_field(phyd + ANA_EQ_EYE_CTRL_SIGNAL4, RG_CDR_BIRLTD0_GEN1_MSK, 0x18);\n\n\tmtk_phy_update_field(phyd + ANA_EQ_EYE_CTRL_SIGNAL5, RG_CDR_BIRLTD0_GEN3_MSK, 0x06);\n\n\tmtk_phy_update_bits(phyd + ANA_RG_CTRL_SIGNAL4,\n\t\t\t    RG_CDR_BICLTR_GEN1_MSK | RG_CDR_BR_GEN2_MSK,\n\t\t\t    FIELD_PREP(RG_CDR_BICLTR_GEN1_MSK, 0x0c) |\n\t\t\t    FIELD_PREP(RG_CDR_BR_GEN2_MSK, 0x07));\n\n\tmtk_phy_update_bits(phyd + PHYD_CTRL_SIGNAL_MODE4,\n\t\t\t    RG_CDR_BICLTD0_GEN1_MSK | RG_CDR_BICLTD1_GEN1_MSK,\n\t\t\t    FIELD_PREP(RG_CDR_BICLTD0_GEN1_MSK, 0x08) |\n\t\t\t    FIELD_PREP(RG_CDR_BICLTD1_GEN1_MSK, 0x02));\n\n\tmtk_phy_update_field(phyd + PHYD_DESIGN_OPTION2, RG_LOCK_CNT_SEL_MSK, 0x02);\n\n\tmtk_phy_update_bits(phyd + PHYD_DESIGN_OPTION9,\n\t\t\t    RG_T2_MIN_MSK | RG_TG_MIN_MSK,\n\t\t\t    FIELD_PREP(RG_T2_MIN_MSK, 0x12) |\n\t\t\t    FIELD_PREP(RG_TG_MIN_MSK, 0x04));\n\n\tmtk_phy_update_bits(phyd + PHYD_DESIGN_OPTION9,\n\t\t\t    RG_T2_MAX_MSK | RG_TG_MAX_MSK,\n\t\t\t    FIELD_PREP(RG_T2_MAX_MSK, 0x31) |\n\t\t\t    FIELD_PREP(RG_TG_MAX_MSK, 0x0e));\n\n\tmtk_phy_update_field(phyd + ANA_RG_CTRL_SIGNAL1, RG_IDRV_0DB_GEN1_MSK, 0x20);\n\n\tmtk_phy_update_field(phyd + ANA_EQ_EYE_CTRL_SIGNAL1, RG_EQ_DLEQ_LFI_GEN1_MSK, 0x03);\n\n\tdev_dbg(tphy->dev, \"%s(%d)\\n\", __func__, instance->index);\n}\n\nstatic void phy_v1_banks_init(struct mtk_tphy *tphy,\n\t\t\t      struct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tstruct u3phy_banks *u3_banks = &instance->u3_banks;\n\n\tswitch (instance->type) {\n\tcase PHY_TYPE_USB2:\n\t\tu2_banks->misc = NULL;\n\t\tu2_banks->fmreg = tphy->sif_base + SSUSB_SIFSLV_V1_U2FREQ;\n\t\tu2_banks->com = instance->port_base + SSUSB_SIFSLV_V1_U2PHY_COM;\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\tcase PHY_TYPE_PCIE:\n\t\tu3_banks->spllc = tphy->sif_base + SSUSB_SIFSLV_V1_SPLLC;\n\t\tu3_banks->chip = tphy->sif_base + SSUSB_SIFSLV_V1_CHIP;\n\t\tu3_banks->phyd = instance->port_base + SSUSB_SIFSLV_V1_U3PHYD;\n\t\tu3_banks->phya = instance->port_base + SSUSB_SIFSLV_V1_U3PHYA;\n\t\tbreak;\n\tcase PHY_TYPE_SATA:\n\t\tu3_banks->phyd = instance->port_base + SSUSB_SIFSLV_V1_U3PHYD;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tphy->dev, \"incompatible PHY type\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void phy_v2_banks_init(struct mtk_tphy *tphy,\n\t\t\t      struct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tstruct u3phy_banks *u3_banks = &instance->u3_banks;\n\n\tswitch (instance->type) {\n\tcase PHY_TYPE_USB2:\n\t\tu2_banks->misc = instance->port_base + SSUSB_SIFSLV_V2_MISC;\n\t\tu2_banks->fmreg = instance->port_base + SSUSB_SIFSLV_V2_U2FREQ;\n\t\tu2_banks->com = instance->port_base + SSUSB_SIFSLV_V2_U2PHY_COM;\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\tcase PHY_TYPE_PCIE:\n\t\tu3_banks->spllc = instance->port_base + SSUSB_SIFSLV_V2_SPLLC;\n\t\tu3_banks->chip = instance->port_base + SSUSB_SIFSLV_V2_CHIP;\n\t\tu3_banks->phyd = instance->port_base + SSUSB_SIFSLV_V2_U3PHYD;\n\t\tu3_banks->phya = instance->port_base + SSUSB_SIFSLV_V2_U3PHYA;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tphy->dev, \"incompatible PHY type\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void phy_parse_property(struct mtk_tphy *tphy,\n\t\t\t\tstruct mtk_phy_instance *instance)\n{\n\tstruct device *dev = &instance->phy->dev;\n\n\tif (instance->type != PHY_TYPE_USB2)\n\t\treturn;\n\n\tinstance->bc12_en = device_property_read_bool(dev, \"mediatek,bc12\");\n\tdevice_property_read_u32(dev, \"mediatek,eye-src\",\n\t\t\t\t &instance->eye_src);\n\tdevice_property_read_u32(dev, \"mediatek,eye-vrt\",\n\t\t\t\t &instance->eye_vrt);\n\tdevice_property_read_u32(dev, \"mediatek,eye-term\",\n\t\t\t\t &instance->eye_term);\n\tdevice_property_read_u32(dev, \"mediatek,intr\",\n\t\t\t\t &instance->intr);\n\tdevice_property_read_u32(dev, \"mediatek,discth\",\n\t\t\t\t &instance->discth);\n\tdevice_property_read_u32(dev, \"mediatek,pre-emphasis\",\n\t\t\t\t &instance->pre_emphasis);\n\tdev_dbg(dev, \"bc12:%d, src:%d, vrt:%d, term:%d, intr:%d, disc:%d\\n\",\n\t\tinstance->bc12_en, instance->eye_src,\n\t\tinstance->eye_vrt, instance->eye_term,\n\t\tinstance->intr, instance->discth);\n\tdev_dbg(dev, \"pre-emp:%d\\n\", instance->pre_emphasis);\n}\n\nstatic void u2_phy_props_set(struct mtk_tphy *tphy,\n\t\t\t     struct mtk_phy_instance *instance)\n{\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tvoid __iomem *com = u2_banks->com;\n\n\tif (instance->bc12_en)  \n\t\tmtk_phy_set_bits(com + U3P_U2PHYBC12C, P2C_RG_CHGDT_EN);\n\n\tif (tphy->pdata->version < MTK_PHY_V3 && instance->eye_src)\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR5, PA5_RG_U2_HSTX_SRCTRL,\n\t\t\t\t     instance->eye_src);\n\n\tif (instance->eye_vrt)\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR1, PA1_RG_VRT_SEL,\n\t\t\t\t     instance->eye_vrt);\n\n\tif (instance->eye_term)\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR1, PA1_RG_TERM_SEL,\n\t\t\t\t     instance->eye_term);\n\n\tif (instance->intr) {\n\t\tif (u2_banks->misc)\n\t\t\tmtk_phy_set_bits(u2_banks->misc + U3P_MISC_REG1,\n\t\t\t\t\t MR1_EFUSE_AUTO_LOAD_DIS);\n\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR1, PA1_RG_INTR_CAL,\n\t\t\t\t     instance->intr);\n\t}\n\n\tif (instance->discth)\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR6, PA6_RG_U2_DISCTH,\n\t\t\t\t     instance->discth);\n\n\tif (instance->pre_emphasis)\n\t\tmtk_phy_update_field(com + U3P_USBPHYACR6, PA6_RG_U2_PRE_EMP,\n\t\t\t\t     instance->pre_emphasis);\n}\n\n \nstatic int phy_type_syscon_get(struct mtk_phy_instance *instance,\n\t\t\t       struct device_node *dn)\n{\n\tstruct of_phandle_args args;\n\tint ret;\n\n\t \n\tif (!of_property_read_bool(dn, \"mediatek,syscon-type\"))\n\t\treturn 0;\n\n\tret = of_parse_phandle_with_fixed_args(dn, \"mediatek,syscon-type\",\n\t\t\t\t\t       2, 0, &args);\n\tif (ret)\n\t\treturn ret;\n\n\tinstance->type_sw_reg = args.args[0];\n\tinstance->type_sw_index = args.args[1] & 0x3;  \n\tinstance->type_sw = syscon_node_to_regmap(args.np);\n\tof_node_put(args.np);\n\tdev_info(&instance->phy->dev, \"type_sw - reg %#x, index %d\\n\",\n\t\t instance->type_sw_reg, instance->type_sw_index);\n\n\treturn PTR_ERR_OR_ZERO(instance->type_sw);\n}\n\nstatic int phy_type_set(struct mtk_phy_instance *instance)\n{\n\tint type;\n\tu32 offset;\n\n\tif (!instance->type_sw)\n\t\treturn 0;\n\n\tswitch (instance->type) {\n\tcase PHY_TYPE_USB3:\n\t\ttype = RG_PHY_SW_USB3;\n\t\tbreak;\n\tcase PHY_TYPE_PCIE:\n\t\ttype = RG_PHY_SW_PCIE;\n\t\tbreak;\n\tcase PHY_TYPE_SGMII:\n\t\ttype = RG_PHY_SW_SGMII;\n\t\tbreak;\n\tcase PHY_TYPE_SATA:\n\t\ttype = RG_PHY_SW_SATA;\n\t\tbreak;\n\tcase PHY_TYPE_USB2:\n\tdefault:\n\t\treturn 0;\n\t}\n\n\toffset = instance->type_sw_index * BITS_PER_BYTE;\n\tregmap_update_bits(instance->type_sw, instance->type_sw_reg,\n\t\t\t   RG_PHY_SW_TYPE << offset, type << offset);\n\n\treturn 0;\n}\n\nstatic int phy_efuse_get(struct mtk_tphy *tphy, struct mtk_phy_instance *instance)\n{\n\tstruct device *dev = &instance->phy->dev;\n\tint ret = 0;\n\n\t \n\tif (!tphy->pdata->sw_efuse_supported) {\n\t\tinstance->efuse_sw_en = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tinstance->efuse_sw_en = device_property_read_bool(dev, \"nvmem-cells\");\n\tif (!instance->efuse_sw_en)\n\t\treturn 0;\n\n\tswitch (instance->type) {\n\tcase PHY_TYPE_USB2:\n\t\tret = nvmem_cell_read_variable_le_u32(dev, \"intr\", &instance->efuse_intr);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"fail to get u2 intr efuse, %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!instance->efuse_intr) {\n\t\t\tdev_warn(dev, \"no u2 intr efuse, but dts enable it\\n\");\n\t\t\tinstance->efuse_sw_en = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(dev, \"u2 efuse - intr %x\\n\", instance->efuse_intr);\n\t\tbreak;\n\n\tcase PHY_TYPE_USB3:\n\tcase PHY_TYPE_PCIE:\n\t\tret = nvmem_cell_read_variable_le_u32(dev, \"intr\", &instance->efuse_intr);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"fail to get u3 intr efuse, %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nvmem_cell_read_variable_le_u32(dev, \"rx_imp\", &instance->efuse_rx_imp);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"fail to get u3 rx_imp efuse, %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = nvmem_cell_read_variable_le_u32(dev, \"tx_imp\", &instance->efuse_tx_imp);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"fail to get u3 tx_imp efuse, %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!instance->efuse_intr &&\n\t\t    !instance->efuse_rx_imp &&\n\t\t    !instance->efuse_tx_imp) {\n\t\t\tdev_warn(dev, \"no u3 intr efuse, but dts enable it\\n\");\n\t\t\tinstance->efuse_sw_en = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(dev, \"u3 efuse - intr %x, rx_imp %x, tx_imp %x\\n\",\n\t\t\tinstance->efuse_intr, instance->efuse_rx_imp,instance->efuse_tx_imp);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"no sw efuse for type %d\\n\", instance->type);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void phy_efuse_set(struct mtk_phy_instance *instance)\n{\n\tstruct device *dev = &instance->phy->dev;\n\tstruct u2phy_banks *u2_banks = &instance->u2_banks;\n\tstruct u3phy_banks *u3_banks = &instance->u3_banks;\n\n\tif (!instance->efuse_sw_en)\n\t\treturn;\n\n\tswitch (instance->type) {\n\tcase PHY_TYPE_USB2:\n\t\tmtk_phy_set_bits(u2_banks->misc + U3P_MISC_REG1, MR1_EFUSE_AUTO_LOAD_DIS);\n\n\t\tmtk_phy_update_field(u2_banks->com + U3P_USBPHYACR1, PA1_RG_INTR_CAL,\n\t\t\t\t     instance->efuse_intr);\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\tcase PHY_TYPE_PCIE:\n\t\tmtk_phy_set_bits(u3_banks->phyd + U3P_U3_PHYD_RSV, P3D_RG_EFUSE_AUTO_LOAD_DIS);\n\n\t\tmtk_phy_update_field(u3_banks->phyd + U3P_U3_PHYD_IMPCAL0, P3D_RG_TX_IMPEL,\n\t\t\t\t    instance->efuse_tx_imp);\n\t\tmtk_phy_set_bits(u3_banks->phyd + U3P_U3_PHYD_IMPCAL0, P3D_RG_FORCE_TX_IMPEL);\n\n\t\tmtk_phy_update_field(u3_banks->phyd + U3P_U3_PHYD_IMPCAL1, P3D_RG_RX_IMPEL,\n\t\t\t\t    instance->efuse_rx_imp);\n\t\tmtk_phy_set_bits(u3_banks->phyd + U3P_U3_PHYD_IMPCAL1, P3D_RG_FORCE_RX_IMPEL);\n\n\t\tmtk_phy_update_field(u3_banks->phya + U3P_U3_PHYA_REG0, P3A_RG_IEXT_INTR,\n\t\t\t\t    instance->efuse_intr);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"no sw efuse for type %d\\n\", instance->type);\n\t\tbreak;\n\t}\n}\n\nstatic int mtk_phy_init(struct phy *phy)\n{\n\tstruct mtk_phy_instance *instance = phy_get_drvdata(phy);\n\tstruct mtk_tphy *tphy = dev_get_drvdata(phy->dev.parent);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(TPHY_CLKS_CNT, instance->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_efuse_set(instance);\n\n\tswitch (instance->type) {\n\tcase PHY_TYPE_USB2:\n\t\tu2_phy_instance_init(tphy, instance);\n\t\tu2_phy_props_set(tphy, instance);\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\t\tu3_phy_instance_init(tphy, instance);\n\t\tbreak;\n\tcase PHY_TYPE_PCIE:\n\t\tpcie_phy_instance_init(tphy, instance);\n\t\tbreak;\n\tcase PHY_TYPE_SATA:\n\t\tsata_phy_instance_init(tphy, instance);\n\t\tbreak;\n\tcase PHY_TYPE_SGMII:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(tphy->dev, \"incompatible PHY type\\n\");\n\t\tclk_bulk_disable_unprepare(TPHY_CLKS_CNT, instance->clks);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_phy_power_on(struct phy *phy)\n{\n\tstruct mtk_phy_instance *instance = phy_get_drvdata(phy);\n\tstruct mtk_tphy *tphy = dev_get_drvdata(phy->dev.parent);\n\n\tif (instance->type == PHY_TYPE_USB2) {\n\t\tu2_phy_instance_power_on(tphy, instance);\n\t\ths_slew_rate_calibrate(tphy, instance);\n\t} else if (instance->type == PHY_TYPE_PCIE) {\n\t\tpcie_phy_instance_power_on(tphy, instance);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_phy_power_off(struct phy *phy)\n{\n\tstruct mtk_phy_instance *instance = phy_get_drvdata(phy);\n\tstruct mtk_tphy *tphy = dev_get_drvdata(phy->dev.parent);\n\n\tif (instance->type == PHY_TYPE_USB2)\n\t\tu2_phy_instance_power_off(tphy, instance);\n\telse if (instance->type == PHY_TYPE_PCIE)\n\t\tpcie_phy_instance_power_off(tphy, instance);\n\n\treturn 0;\n}\n\nstatic int mtk_phy_exit(struct phy *phy)\n{\n\tstruct mtk_phy_instance *instance = phy_get_drvdata(phy);\n\tstruct mtk_tphy *tphy = dev_get_drvdata(phy->dev.parent);\n\n\tif (instance->type == PHY_TYPE_USB2)\n\t\tu2_phy_instance_exit(tphy, instance);\n\n\tclk_bulk_disable_unprepare(TPHY_CLKS_CNT, instance->clks);\n\treturn 0;\n}\n\nstatic int mtk_phy_set_mode(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tstruct mtk_phy_instance *instance = phy_get_drvdata(phy);\n\tstruct mtk_tphy *tphy = dev_get_drvdata(phy->dev.parent);\n\n\tif (instance->type == PHY_TYPE_USB2)\n\t\tu2_phy_instance_set_mode(tphy, instance, mode);\n\n\treturn 0;\n}\n\nstatic struct phy *mtk_phy_xlate(struct device *dev,\n\t\t\t\t\tstruct of_phandle_args *args)\n{\n\tstruct mtk_tphy *tphy = dev_get_drvdata(dev);\n\tstruct mtk_phy_instance *instance = NULL;\n\tstruct device_node *phy_np = args->np;\n\tint index;\n\tint ret;\n\n\tif (args->args_count != 1) {\n\t\tdev_err(dev, \"invalid number of cells in 'phy' property\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfor (index = 0; index < tphy->nphys; index++)\n\t\tif (phy_np == tphy->phys[index]->phy->dev.of_node) {\n\t\t\tinstance = tphy->phys[index];\n\t\t\tbreak;\n\t\t}\n\n\tif (!instance) {\n\t\tdev_err(dev, \"failed to find appropriate phy\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinstance->type = args->args[0];\n\tif (!(instance->type == PHY_TYPE_USB2 ||\n\t      instance->type == PHY_TYPE_USB3 ||\n\t      instance->type == PHY_TYPE_PCIE ||\n\t      instance->type == PHY_TYPE_SATA ||\n\t      instance->type == PHY_TYPE_SGMII)) {\n\t\tdev_err(dev, \"unsupported device type: %d\\n\", instance->type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tswitch (tphy->pdata->version) {\n\tcase MTK_PHY_V1:\n\t\tphy_v1_banks_init(tphy, instance);\n\t\tbreak;\n\tcase MTK_PHY_V2:\n\tcase MTK_PHY_V3:\n\t\tphy_v2_banks_init(tphy, instance);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"phy version is not supported\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = phy_efuse_get(tphy, instance);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tphy_parse_property(tphy, instance);\n\tphy_type_set(instance);\n\tphy_debugfs_init(instance);\n\n\treturn instance->phy;\n}\n\nstatic const struct phy_ops mtk_tphy_ops = {\n\t.init\t\t= mtk_phy_init,\n\t.exit\t\t= mtk_phy_exit,\n\t.power_on\t= mtk_phy_power_on,\n\t.power_off\t= mtk_phy_power_off,\n\t.set_mode\t= mtk_phy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct mtk_phy_pdata tphy_v1_pdata = {\n\t.avoid_rx_sen_degradation = false,\n\t.version = MTK_PHY_V1,\n};\n\nstatic const struct mtk_phy_pdata tphy_v2_pdata = {\n\t.avoid_rx_sen_degradation = false,\n\t.sw_efuse_supported = true,\n\t.version = MTK_PHY_V2,\n};\n\nstatic const struct mtk_phy_pdata tphy_v3_pdata = {\n\t.sw_efuse_supported = true,\n\t.version = MTK_PHY_V3,\n};\n\nstatic const struct mtk_phy_pdata mt8173_pdata = {\n\t.avoid_rx_sen_degradation = true,\n\t.version = MTK_PHY_V1,\n};\n\nstatic const struct mtk_phy_pdata mt8195_pdata = {\n\t.sw_pll_48m_to_26m = true,\n\t.sw_efuse_supported = true,\n\t.version = MTK_PHY_V3,\n};\n\nstatic const struct of_device_id mtk_tphy_id_table[] = {\n\t{ .compatible = \"mediatek,mt2701-u3phy\", .data = &tphy_v1_pdata },\n\t{ .compatible = \"mediatek,mt2712-u3phy\", .data = &tphy_v2_pdata },\n\t{ .compatible = \"mediatek,mt8173-u3phy\", .data = &mt8173_pdata },\n\t{ .compatible = \"mediatek,mt8195-tphy\", .data = &mt8195_pdata },\n\t{ .compatible = \"mediatek,generic-tphy-v1\", .data = &tphy_v1_pdata },\n\t{ .compatible = \"mediatek,generic-tphy-v2\", .data = &tphy_v2_pdata },\n\t{ .compatible = \"mediatek,generic-tphy-v3\", .data = &tphy_v3_pdata },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mtk_tphy_id_table);\n\nstatic int mtk_tphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child_np;\n\tstruct phy_provider *provider;\n\tstruct resource *sif_res;\n\tstruct mtk_tphy *tphy;\n\tstruct resource res;\n\tint port, retval;\n\n\ttphy = devm_kzalloc(dev, sizeof(*tphy), GFP_KERNEL);\n\tif (!tphy)\n\t\treturn -ENOMEM;\n\n\ttphy->pdata = of_device_get_match_data(dev);\n\tif (!tphy->pdata)\n\t\treturn -EINVAL;\n\n\ttphy->nphys = of_get_child_count(np);\n\ttphy->phys = devm_kcalloc(dev, tphy->nphys,\n\t\t\t\t       sizeof(*tphy->phys), GFP_KERNEL);\n\tif (!tphy->phys)\n\t\treturn -ENOMEM;\n\n\ttphy->dev = dev;\n\tplatform_set_drvdata(pdev, tphy);\n\n\tsif_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t \n\tif (sif_res && tphy->pdata->version == MTK_PHY_V1) {\n\t\t \n\t\ttphy->sif_base = devm_ioremap_resource(dev, sif_res);\n\t\tif (IS_ERR(tphy->sif_base)) {\n\t\t\tdev_err(dev, \"failed to remap sif regs\\n\");\n\t\t\treturn PTR_ERR(tphy->sif_base);\n\t\t}\n\t}\n\n\tif (tphy->pdata->version < MTK_PHY_V3) {\n\t\ttphy->src_ref_clk = U3P_REF_CLK;\n\t\ttphy->src_coef = U3P_SLEW_RATE_COEF;\n\t\t \n\t\tdevice_property_read_u32(dev, \"mediatek,src-ref-clk-mhz\",\n\t\t\t\t\t &tphy->src_ref_clk);\n\t\tdevice_property_read_u32(dev, \"mediatek,src-coef\",\n\t\t\t\t\t &tphy->src_coef);\n\t}\n\n\tport = 0;\n\tfor_each_child_of_node(np, child_np) {\n\t\tstruct mtk_phy_instance *instance;\n\t\tstruct clk_bulk_data *clks;\n\t\tstruct device *subdev;\n\t\tstruct phy *phy;\n\n\t\tinstance = devm_kzalloc(dev, sizeof(*instance), GFP_KERNEL);\n\t\tif (!instance) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\ttphy->phys[port] = instance;\n\n\t\tphy = devm_phy_create(dev, child_np, &mtk_tphy_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(dev, \"failed to create phy\\n\");\n\t\t\tretval = PTR_ERR(phy);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tsubdev = &phy->dev;\n\t\tretval = of_address_to_resource(child_np, 0, &res);\n\t\tif (retval) {\n\t\t\tdev_err(subdev, \"failed to get address resource(id-%d)\\n\",\n\t\t\t\tport);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tinstance->port_base = devm_ioremap_resource(subdev, &res);\n\t\tif (IS_ERR(instance->port_base)) {\n\t\t\tretval = PTR_ERR(instance->port_base);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tinstance->phy = phy;\n\t\tinstance->index = port;\n\t\tphy_set_drvdata(phy, instance);\n\t\tport++;\n\n\t\tclks = instance->clks;\n\t\tclks[0].id = \"ref\";      \n\t\tclks[1].id = \"da_ref\";   \n\t\tretval = devm_clk_bulk_get_optional(subdev, TPHY_CLKS_CNT, clks);\n\t\tif (retval)\n\t\t\tgoto put_child;\n\n\t\tretval = phy_type_syscon_get(instance, child_np);\n\t\tif (retval)\n\t\t\tgoto put_child;\n\t}\n\n\tprovider = devm_of_phy_provider_register(dev, mtk_phy_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\nput_child:\n\tof_node_put(child_np);\n\treturn retval;\n}\n\nstatic struct platform_driver mtk_tphy_driver = {\n\t.probe\t\t= mtk_tphy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"mtk-tphy\",\n\t\t.of_match_table = mtk_tphy_id_table,\n\t},\n};\n\nmodule_platform_driver(mtk_tphy_driver);\n\nMODULE_AUTHOR(\"Chunfeng Yun <chunfeng.yun@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek T-PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}