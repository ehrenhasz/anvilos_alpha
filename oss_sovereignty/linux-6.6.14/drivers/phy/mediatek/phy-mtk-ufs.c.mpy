{
  "module_name": "phy-mtk-ufs.c",
  "hash_id": "0519e1cd299ee1c52ca39417471c26c40c57a02e2e3561e39b9e90631cdb22f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/mediatek/phy-mtk-ufs.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#include \"phy-mtk-io.h\"\n\n \n#define MP_GLB_DIG_8C               0x008C\n#define FRC_PLL_ISO_EN              BIT(8)\n#define PLL_ISO_EN                  BIT(9)\n#define FRC_FRC_PWR_ON              BIT(10)\n#define PLL_PWR_ON                  BIT(11)\n\n#define MP_LN_DIG_RX_9C             0xA09C\n#define FSM_DIFZ_FRC                BIT(18)\n\n#define MP_LN_DIG_RX_AC             0xA0AC\n#define FRC_RX_SQ_EN                BIT(0)\n#define RX_SQ_EN                    BIT(1)\n\n#define MP_LN_RX_44                 0xB044\n#define FRC_CDR_PWR_ON              BIT(17)\n#define CDR_PWR_ON                  BIT(18)\n#define FRC_CDR_ISO_EN              BIT(19)\n#define CDR_ISO_EN                  BIT(20)\n\n#define UFSPHY_CLKS_CNT    2\n\nstruct ufs_mtk_phy {\n\tstruct device *dev;\n\tvoid __iomem *mmio;\n\tstruct clk_bulk_data clks[UFSPHY_CLKS_CNT];\n};\n\nstatic struct ufs_mtk_phy *get_ufs_mtk_phy(struct phy *generic_phy)\n{\n\treturn (struct ufs_mtk_phy *)phy_get_drvdata(generic_phy);\n}\n\nstatic int ufs_mtk_phy_clk_init(struct ufs_mtk_phy *phy)\n{\n\tstruct device *dev = phy->dev;\n\tstruct clk_bulk_data *clks = phy->clks;\n\n\tclks[0].id = \"unipro\";\n\tclks[1].id = \"mp\";\n\treturn devm_clk_bulk_get(dev, UFSPHY_CLKS_CNT, clks);\n}\n\nstatic void ufs_mtk_phy_set_active(struct ufs_mtk_phy *phy)\n{\n\tvoid __iomem *mmio = phy->mmio;\n\n\t \n\tmtk_phy_set_bits(mmio + MP_GLB_DIG_8C, PLL_PWR_ON);\n\tmtk_phy_clear_bits(mmio + MP_GLB_DIG_8C, FRC_FRC_PWR_ON);\n\n\t \n\tmtk_phy_clear_bits(mmio + MP_GLB_DIG_8C, PLL_ISO_EN);\n\tmtk_phy_clear_bits(mmio + MP_GLB_DIG_8C, FRC_PLL_ISO_EN);\n\n\t \n\tmtk_phy_set_bits(mmio + MP_LN_RX_44, CDR_PWR_ON);\n\tmtk_phy_clear_bits(mmio + MP_LN_RX_44, FRC_CDR_PWR_ON);\n\n\t \n\tmtk_phy_clear_bits(mmio + MP_LN_RX_44, CDR_ISO_EN);\n\tmtk_phy_clear_bits(mmio + MP_LN_RX_44, FRC_CDR_ISO_EN);\n\n\t \n\tmtk_phy_set_bits(mmio + MP_LN_DIG_RX_AC, RX_SQ_EN);\n\tmtk_phy_clear_bits(mmio + MP_LN_DIG_RX_AC, FRC_RX_SQ_EN);\n\n\t \n\tudelay(1);\n\n\t \n\tmtk_phy_clear_bits(mmio + MP_LN_DIG_RX_9C, FSM_DIFZ_FRC);\n}\n\nstatic void ufs_mtk_phy_set_deep_hibern(struct ufs_mtk_phy *phy)\n{\n\tvoid __iomem *mmio = phy->mmio;\n\n\t \n\tmtk_phy_set_bits(mmio + MP_LN_DIG_RX_9C, FSM_DIFZ_FRC);\n\n\t \n\tmtk_phy_set_bits(mmio + MP_LN_DIG_RX_AC, FRC_RX_SQ_EN);\n\tmtk_phy_clear_bits(mmio + MP_LN_DIG_RX_AC, RX_SQ_EN);\n\n\t \n\tmtk_phy_set_bits(mmio + MP_LN_RX_44, FRC_CDR_ISO_EN);\n\tmtk_phy_set_bits(mmio + MP_LN_RX_44, CDR_ISO_EN);\n\n\t \n\tmtk_phy_set_bits(mmio + MP_LN_RX_44, FRC_CDR_PWR_ON);\n\tmtk_phy_clear_bits(mmio + MP_LN_RX_44, CDR_PWR_ON);\n\n\t \n\tmtk_phy_set_bits(mmio + MP_GLB_DIG_8C, FRC_PLL_ISO_EN);\n\tmtk_phy_set_bits(mmio + MP_GLB_DIG_8C, PLL_ISO_EN);\n\n\t \n\tmtk_phy_set_bits(mmio + MP_GLB_DIG_8C, FRC_FRC_PWR_ON);\n\tmtk_phy_clear_bits(mmio + MP_GLB_DIG_8C, PLL_PWR_ON);\n}\n\nstatic int ufs_mtk_phy_power_on(struct phy *generic_phy)\n{\n\tstruct ufs_mtk_phy *phy = get_ufs_mtk_phy(generic_phy);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(UFSPHY_CLKS_CNT, phy->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tufs_mtk_phy_set_active(phy);\n\n\treturn 0;\n}\n\nstatic int ufs_mtk_phy_power_off(struct phy *generic_phy)\n{\n\tstruct ufs_mtk_phy *phy = get_ufs_mtk_phy(generic_phy);\n\n\tufs_mtk_phy_set_deep_hibern(phy);\n\n\tclk_bulk_disable_unprepare(UFSPHY_CLKS_CNT, phy->clks);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ufs_mtk_phy_ops = {\n\t.power_on       = ufs_mtk_phy_power_on,\n\t.power_off      = ufs_mtk_phy_power_off,\n\t.owner          = THIS_MODULE,\n};\n\nstatic int ufs_mtk_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct ufs_mtk_phy *phy;\n\tint ret;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->mmio))\n\t\treturn PTR_ERR(phy->mmio);\n\n\tphy->dev = dev;\n\n\tret = ufs_mtk_phy_clk_init(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tgeneric_phy = devm_phy_create(dev, NULL, &ufs_mtk_phy_ops);\n\tif (IS_ERR(generic_phy))\n\t\treturn PTR_ERR(generic_phy);\n\n\tphy_set_drvdata(generic_phy, phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id ufs_mtk_phy_of_match[] = {\n\t{.compatible = \"mediatek,mt8183-ufsphy\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ufs_mtk_phy_of_match);\n\nstatic struct platform_driver ufs_mtk_phy_driver = {\n\t.probe = ufs_mtk_phy_probe,\n\t.driver = {\n\t\t.of_match_table = ufs_mtk_phy_of_match,\n\t\t.name = \"ufs_mtk_phy\",\n\t},\n};\nmodule_platform_driver(ufs_mtk_phy_driver);\n\nMODULE_DESCRIPTION(\"Universal Flash Storage (UFS) MediaTek MPHY\");\nMODULE_AUTHOR(\"Stanley Chu <stanley.chu@mediatek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}