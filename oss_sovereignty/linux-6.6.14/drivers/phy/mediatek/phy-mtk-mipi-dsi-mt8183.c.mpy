{
  "module_name": "phy-mtk-mipi-dsi-mt8183.c",
  "hash_id": "185757259c5c8e7592b4b8f5867188662bf378fbfa391da305ef6cac3dd68344",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/mediatek/phy-mtk-mipi-dsi-mt8183.c",
  "human_readable_source": "\n \n\n#include \"phy-mtk-io.h\"\n#include \"phy-mtk-mipi-dsi.h\"\n\n#define MIPITX_LANE_CON\t\t0x000c\n#define RG_DSI_CPHY_T1DRV_EN\t\tBIT(0)\n#define RG_DSI_ANA_CK_SEL\t\tBIT(1)\n#define RG_DSI_PHY_CK_SEL\t\tBIT(2)\n#define RG_DSI_CPHY_EN\t\t\tBIT(3)\n#define RG_DSI_PHYCK_INV_EN\t\tBIT(4)\n#define RG_DSI_PWR04_EN\t\t\tBIT(5)\n#define RG_DSI_BG_LPF_EN\t\tBIT(6)\n#define RG_DSI_BG_CORE_EN\t\tBIT(7)\n#define RG_DSI_PAD_TIEL_SEL\t\tBIT(8)\n\n#define MIPITX_VOLTAGE_SEL\t0x0010\n#define RG_DSI_HSTX_LDO_REF_SEL\t\tGENMASK(9, 6)\n\n#define MIPITX_PLL_PWR\t\t0x0028\n#define MIPITX_PLL_CON0\t\t0x002c\n#define MIPITX_PLL_CON1\t\t0x0030\n#define MIPITX_PLL_CON2\t\t0x0034\n#define MIPITX_PLL_CON3\t\t0x0038\n#define MIPITX_PLL_CON4\t\t0x003c\n#define RG_DSI_PLL_IBIAS\t\tGENMASK(11, 10)\n\n#define MIPITX_D2P_RTCODE\t0x0100\n#define MIPITX_D2_SW_CTL_EN\t0x0144\n#define MIPITX_D0_SW_CTL_EN\t0x0244\n#define MIPITX_CK_CKMODE_EN\t0x0328\n#define DSI_CK_CKMODE_EN\t\tBIT(0)\n#define MIPITX_CK_SW_CTL_EN\t0x0344\n#define MIPITX_D1_SW_CTL_EN\t0x0444\n#define MIPITX_D3_SW_CTL_EN\t0x0544\n#define DSI_SW_CTL_EN\t\t\tBIT(0)\n#define AD_DSI_PLL_SDM_PWR_ON\t\tBIT(0)\n#define AD_DSI_PLL_SDM_ISO_EN\t\tBIT(1)\n\n#define RG_DSI_PLL_EN\t\t\tBIT(4)\n#define RG_DSI_PLL_POSDIV\t\tGENMASK(10, 8)\n\nstatic int mtk_mipi_tx_pll_enable(struct clk_hw *hw)\n{\n\tstruct mtk_mipi_tx *mipi_tx = mtk_mipi_tx_from_clk_hw(hw);\n\tvoid __iomem *base = mipi_tx->regs;\n\tunsigned int txdiv, txdiv0;\n\tu64 pcw;\n\n\tdev_dbg(mipi_tx->dev, \"enable: %u bps\\n\", mipi_tx->data_rate);\n\n\tif (mipi_tx->data_rate >= 2000000000) {\n\t\ttxdiv = 1;\n\t\ttxdiv0 = 0;\n\t} else if (mipi_tx->data_rate >= 1000000000) {\n\t\ttxdiv = 2;\n\t\ttxdiv0 = 1;\n\t} else if (mipi_tx->data_rate >= 500000000) {\n\t\ttxdiv = 4;\n\t\ttxdiv0 = 2;\n\t} else if (mipi_tx->data_rate > 250000000) {\n\t\ttxdiv = 8;\n\t\ttxdiv0 = 3;\n\t} else if (mipi_tx->data_rate >= 125000000) {\n\t\ttxdiv = 16;\n\t\ttxdiv0 = 4;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_phy_clear_bits(base + MIPITX_PLL_CON4, RG_DSI_PLL_IBIAS);\n\n\tmtk_phy_set_bits(base + MIPITX_PLL_PWR, AD_DSI_PLL_SDM_PWR_ON);\n\tmtk_phy_clear_bits(base + MIPITX_PLL_CON1, RG_DSI_PLL_EN);\n\tudelay(1);\n\tmtk_phy_clear_bits(base + MIPITX_PLL_PWR, AD_DSI_PLL_SDM_ISO_EN);\n\tpcw = div_u64(((u64)mipi_tx->data_rate * txdiv) << 24, 26000000);\n\twritel(pcw, base + MIPITX_PLL_CON0);\n\tmtk_phy_update_field(base + MIPITX_PLL_CON1, RG_DSI_PLL_POSDIV, txdiv0);\n\tmtk_phy_set_bits(base + MIPITX_PLL_CON1, RG_DSI_PLL_EN);\n\n\treturn 0;\n}\n\nstatic void mtk_mipi_tx_pll_disable(struct clk_hw *hw)\n{\n\tstruct mtk_mipi_tx *mipi_tx = mtk_mipi_tx_from_clk_hw(hw);\n\tvoid __iomem *base = mipi_tx->regs;\n\n\tmtk_phy_clear_bits(base + MIPITX_PLL_CON1, RG_DSI_PLL_EN);\n\n\tmtk_phy_set_bits(base + MIPITX_PLL_PWR, AD_DSI_PLL_SDM_ISO_EN);\n\tmtk_phy_clear_bits(base + MIPITX_PLL_PWR, AD_DSI_PLL_SDM_PWR_ON);\n}\n\nstatic long mtk_mipi_tx_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *prate)\n{\n\treturn clamp_val(rate, 125000000, 1600000000);\n}\n\nstatic const struct clk_ops mtk_mipi_tx_pll_ops = {\n\t.enable = mtk_mipi_tx_pll_enable,\n\t.disable = mtk_mipi_tx_pll_disable,\n\t.round_rate = mtk_mipi_tx_pll_round_rate,\n\t.set_rate = mtk_mipi_tx_pll_set_rate,\n\t.recalc_rate = mtk_mipi_tx_pll_recalc_rate,\n};\n\nstatic void mtk_mipi_tx_config_calibration_data(struct mtk_mipi_tx *mipi_tx)\n{\n\tint i, j;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tif ((mipi_tx->rt_code[i] & 0x1f) == 0)\n\t\t\tmipi_tx->rt_code[i] |= 0x10;\n\n\t\tif ((mipi_tx->rt_code[i] >> 5 & 0x1f) == 0)\n\t\t\tmipi_tx->rt_code[i] |= 0x10 << 5;\n\n\t\tfor (j = 0; j < 10; j++)\n\t\t\tmtk_phy_update_bits(mipi_tx->regs +\n\t\t\t\tMIPITX_D2P_RTCODE * (i + 1) + j * 4,\n\t\t\t\t1, mipi_tx->rt_code[i] >> j & 1);\n\t}\n}\n\nstatic void mtk_mipi_tx_power_on_signal(struct phy *phy)\n{\n\tstruct mtk_mipi_tx *mipi_tx = phy_get_drvdata(phy);\n\tvoid __iomem *base = mipi_tx->regs;\n\n\t \n\twritel(RG_DSI_PAD_TIEL_SEL | RG_DSI_BG_CORE_EN, base + MIPITX_LANE_CON);\n\tusleep_range(30, 100);\n\twritel(RG_DSI_BG_CORE_EN | RG_DSI_BG_LPF_EN, base + MIPITX_LANE_CON);\n\n\t \n\tmtk_phy_clear_bits(base + MIPITX_D0_SW_CTL_EN, DSI_SW_CTL_EN);\n\tmtk_phy_clear_bits(base + MIPITX_D1_SW_CTL_EN, DSI_SW_CTL_EN);\n\tmtk_phy_clear_bits(base + MIPITX_D2_SW_CTL_EN, DSI_SW_CTL_EN);\n\tmtk_phy_clear_bits(base + MIPITX_D3_SW_CTL_EN, DSI_SW_CTL_EN);\n\tmtk_phy_clear_bits(base + MIPITX_CK_SW_CTL_EN, DSI_SW_CTL_EN);\n\n\tmtk_phy_update_field(base + MIPITX_VOLTAGE_SEL, RG_DSI_HSTX_LDO_REF_SEL,\n\t\t\t     (mipi_tx->mipitx_drive - 3000) / 200);\n\n\tmtk_mipi_tx_config_calibration_data(mipi_tx);\n\n\tmtk_phy_set_bits(base + MIPITX_CK_CKMODE_EN, DSI_CK_CKMODE_EN);\n}\n\nstatic void mtk_mipi_tx_power_off_signal(struct phy *phy)\n{\n\tstruct mtk_mipi_tx *mipi_tx = phy_get_drvdata(phy);\n\tvoid __iomem *base = mipi_tx->regs;\n\n\t \n\tmtk_phy_set_bits(base + MIPITX_D0_SW_CTL_EN, DSI_SW_CTL_EN);\n\tmtk_phy_set_bits(base + MIPITX_D1_SW_CTL_EN, DSI_SW_CTL_EN);\n\tmtk_phy_set_bits(base + MIPITX_D2_SW_CTL_EN, DSI_SW_CTL_EN);\n\tmtk_phy_set_bits(base + MIPITX_D3_SW_CTL_EN, DSI_SW_CTL_EN);\n\tmtk_phy_set_bits(base + MIPITX_CK_SW_CTL_EN, DSI_SW_CTL_EN);\n\n\twritel(RG_DSI_PAD_TIEL_SEL | RG_DSI_BG_CORE_EN, base + MIPITX_LANE_CON);\n\twritel(RG_DSI_PAD_TIEL_SEL, base + MIPITX_LANE_CON);\n}\n\nconst struct mtk_mipitx_data mt8183_mipitx_data = {\n\t.mipi_tx_clk_ops = &mtk_mipi_tx_pll_ops,\n\t.mipi_tx_enable_signal = mtk_mipi_tx_power_on_signal,\n\t.mipi_tx_disable_signal = mtk_mipi_tx_power_off_signal,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}