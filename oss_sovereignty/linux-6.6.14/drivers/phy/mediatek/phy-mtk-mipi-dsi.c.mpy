{
  "module_name": "phy-mtk-mipi-dsi.c",
  "hash_id": "59efb4a482f2bae9f3bc7fd38b80da219faee4d6e7af5dbe30ab5107f027e2f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/mediatek/phy-mtk-mipi-dsi.c",
  "human_readable_source": "\n \n\n#include \"phy-mtk-mipi-dsi.h\"\n\ninline struct mtk_mipi_tx *mtk_mipi_tx_from_clk_hw(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct mtk_mipi_tx, pll_hw);\n}\n\nint mtk_mipi_tx_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t     unsigned long parent_rate)\n{\n\tstruct mtk_mipi_tx *mipi_tx = mtk_mipi_tx_from_clk_hw(hw);\n\n\tdev_dbg(mipi_tx->dev, \"set rate: %lu Hz\\n\", rate);\n\n\tmipi_tx->data_rate = rate;\n\n\treturn 0;\n}\n\nunsigned long mtk_mipi_tx_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct mtk_mipi_tx *mipi_tx = mtk_mipi_tx_from_clk_hw(hw);\n\n\treturn mipi_tx->data_rate;\n}\n\nstatic int mtk_mipi_tx_power_on(struct phy *phy)\n{\n\tstruct mtk_mipi_tx *mipi_tx = phy_get_drvdata(phy);\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(mipi_tx->pll_hw.clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmipi_tx->driver_data->mipi_tx_enable_signal(phy);\n\treturn 0;\n}\n\nstatic int mtk_mipi_tx_power_off(struct phy *phy)\n{\n\tstruct mtk_mipi_tx *mipi_tx = phy_get_drvdata(phy);\n\n\t \n\tmipi_tx->driver_data->mipi_tx_disable_signal(phy);\n\n\t \n\tclk_disable_unprepare(mipi_tx->pll_hw.clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops mtk_mipi_tx_ops = {\n\t.power_on = mtk_mipi_tx_power_on,\n\t.power_off = mtk_mipi_tx_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic void mtk_mipi_tx_get_calibration_datal(struct mtk_mipi_tx *mipi_tx)\n{\n\tstruct nvmem_cell *cell;\n\tsize_t len;\n\tu32 *buf;\n\n\tcell = nvmem_cell_get(mipi_tx->dev, \"calibration-data\");\n\tif (IS_ERR(cell)) {\n\t\tdev_info(mipi_tx->dev, \"can't get nvmem_cell_get, ignore it\\n\");\n\t\treturn;\n\t}\n\tbuf = (u32 *)nvmem_cell_read(cell, &len);\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(buf)) {\n\t\tdev_info(mipi_tx->dev, \"can't get data, ignore it\\n\");\n\t\treturn;\n\t}\n\n\tif (len < 3 * sizeof(u32)) {\n\t\tdev_info(mipi_tx->dev, \"invalid calibration data\\n\");\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tmipi_tx->rt_code[0] = ((buf[0] >> 6 & 0x1f) << 5) |\n\t\t\t       (buf[0] >> 11 & 0x1f);\n\tmipi_tx->rt_code[1] = ((buf[1] >> 27 & 0x1f) << 5) |\n\t\t\t       (buf[0] >> 1 & 0x1f);\n\tmipi_tx->rt_code[2] = ((buf[1] >> 17 & 0x1f) << 5) |\n\t\t\t       (buf[1] >> 22 & 0x1f);\n\tmipi_tx->rt_code[3] = ((buf[1] >> 7 & 0x1f) << 5) |\n\t\t\t       (buf[1] >> 12 & 0x1f);\n\tmipi_tx->rt_code[4] = ((buf[2] >> 27 & 0x1f) << 5) |\n\t\t\t       (buf[1] >> 2 & 0x1f);\n\tkfree(buf);\n}\n\nstatic int mtk_mipi_tx_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_mipi_tx *mipi_tx;\n\tconst char *ref_clk_name;\n\tstruct clk *ref_clk;\n\tstruct clk_init_data clk_init = {\n\t\t.num_parents = 1,\n\t\t.parent_names = (const char * const *)&ref_clk_name,\n\t\t.flags = CLK_SET_RATE_GATE,\n\t};\n\tstruct phy *phy;\n\tstruct phy_provider *phy_provider;\n\tint ret;\n\n\tmipi_tx = devm_kzalloc(dev, sizeof(*mipi_tx), GFP_KERNEL);\n\tif (!mipi_tx)\n\t\treturn -ENOMEM;\n\n\tmipi_tx->driver_data = of_device_get_match_data(dev);\n\tif (!mipi_tx->driver_data)\n\t\treturn -ENODEV;\n\n\tmipi_tx->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mipi_tx->regs))\n\t\treturn PTR_ERR(mipi_tx->regs);\n\n\tref_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ref_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(ref_clk),\n\t\t\t\t     \"Failed to get reference clock\\n\");\n\n\tret = of_property_read_u32(dev->of_node, \"drive-strength-microamp\",\n\t\t\t\t   &mipi_tx->mipitx_drive);\n\t \n\tif (ret < 0)\n\t\tmipi_tx->mipitx_drive = 4600;\n\n\t \n\tif (mipi_tx->mipitx_drive > 6000 || mipi_tx->mipitx_drive < 3000) {\n\t\tdev_warn(dev, \"drive-strength-microamp is invalid %d, not in 3000 ~ 6000\\n\",\n\t\t\t mipi_tx->mipitx_drive);\n\t\tmipi_tx->mipitx_drive = clamp_val(mipi_tx->mipitx_drive, 3000,\n\t\t\t\t\t\t  6000);\n\t}\n\n\tref_clk_name = __clk_get_name(ref_clk);\n\n\tret = of_property_read_string(dev->of_node, \"clock-output-names\",\n\t\t\t\t      &clk_init.name);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read clock-output-names\\n\");\n\n\tclk_init.ops = mipi_tx->driver_data->mipi_tx_clk_ops;\n\n\tmipi_tx->pll_hw.init = &clk_init;\n\tret = devm_clk_hw_register(dev, &mipi_tx->pll_hw);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to register PLL\\n\");\n\n\tphy = devm_phy_create(dev, NULL, &mtk_mipi_tx_ops);\n\tif (IS_ERR(phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy), \"Failed to create MIPI D-PHY\\n\");\n\n\tphy_set_drvdata(phy, mipi_tx);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\treturn PTR_ERR(phy_provider);\n\n\tmipi_tx->dev = dev;\n\n\tmtk_mipi_tx_get_calibration_datal(mipi_tx);\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, &mipi_tx->pll_hw);\n}\n\nstatic const struct of_device_id mtk_mipi_tx_match[] = {\n\t{ .compatible = \"mediatek,mt2701-mipi-tx\", .data = &mt2701_mipitx_data },\n\t{ .compatible = \"mediatek,mt8173-mipi-tx\", .data = &mt8173_mipitx_data },\n\t{ .compatible = \"mediatek,mt8183-mipi-tx\", .data = &mt8183_mipitx_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mtk_mipi_tx_match);\n\nstatic struct platform_driver mtk_mipi_tx_driver = {\n\t.probe = mtk_mipi_tx_probe,\n\t.driver = {\n\t\t.name = \"mediatek-mipi-tx\",\n\t\t.of_match_table = mtk_mipi_tx_match,\n\t},\n};\nmodule_platform_driver(mtk_mipi_tx_driver);\n\nMODULE_DESCRIPTION(\"MediaTek MIPI TX Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}