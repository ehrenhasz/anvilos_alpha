{
  "module_name": "phy-mtk-hdmi-mt8195.c",
  "hash_id": "4cbde5770a623bb6da2821046d3c4edd2340634b730709c1df17d3c106dba96a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/mediatek/phy-mtk-hdmi-mt8195.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/units.h>\n#include <linux/nvmem-consumer.h>\n\n#include \"phy-mtk-io.h\"\n#include \"phy-mtk-hdmi.h\"\n#include \"phy-mtk-hdmi-mt8195.h\"\n\nstatic void mtk_hdmi_ana_fifo_en(struct mtk_hdmi_phy *hdmi_phy)\n{\n\t \n\tmtk_phy_set_bits(hdmi_phy->regs + HDMI_ANA_CTL, REG_ANA_HDMI20_FIFO_EN);\n}\n\nstatic void\nmtk_phy_tmds_clk_ratio(struct mtk_hdmi_phy *hdmi_phy, bool enable)\n{\n\tvoid __iomem *regs = hdmi_phy->regs;\n\n\tmtk_hdmi_ana_fifo_en(hdmi_phy);\n\n\t \n\tif (enable)\n\t\tmtk_phy_update_field(regs + HDMI20_CLK_CFG, REG_TXC_DIV, 3);\n\telse\n\t\tmtk_phy_clear_bits(regs + HDMI20_CLK_CFG, REG_TXC_DIV);\n}\n\nstatic void mtk_hdmi_pll_sel_src(struct clk_hw *hw)\n{\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\tvoid __iomem *regs = hdmi_phy->regs;\n\n\tmtk_phy_clear_bits(regs + HDMI_CTL_3, REG_HDMITX_REF_XTAL_SEL);\n\tmtk_phy_clear_bits(regs + HDMI_CTL_3, REG_HDMITX_REF_RESPLL_SEL);\n\n\t \n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_10, RG_HDMITXPLL_REF_CK_SEL);\n}\n\nstatic void mtk_hdmi_pll_perf(struct clk_hw *hw)\n{\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\tvoid __iomem *regs = hdmi_phy->regs;\n\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_0, RG_HDMITXPLL_BP2);\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_BC);\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_IC, 0x1);\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_BR, 0x2);\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_IR, 0x2);\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_BP);\n\tmtk_phy_clear_bits(regs + HDMI_1_PLL_CFG_0, RG_HDMITXPLL_IBAND_FIX_EN);\n\tmtk_phy_clear_bits(regs + HDMI_1_PLL_CFG_1, RG_HDMITXPLL_RESERVE_BIT14);\n\tmtk_phy_clear_bits(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_HIKVCO);\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_0, RG_HDMITXPLL_HREN, 0x1);\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_0, RG_HDMITXPLL_LVR_SEL, 0x1);\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_1, RG_HDMITXPLL_RESERVE_BIT12_11);\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_0, RG_HDMITXPLL_TCL_EN);\n}\n\nstatic int mtk_hdmi_pll_set_hw(struct clk_hw *hw, u8 prediv,\n\t\t\t       u8 fbkdiv_high,\n\t\t\t       u32 fbkdiv_low,\n\t\t\t       u8 fbkdiv_hs3, u8 posdiv1,\n\t\t\t       u8 posdiv2, u8 txprediv,\n\t\t\t       u8 txposdiv,\n\t\t\t       u8 digital_div)\n{\n\tu8 txposdiv_value;\n\tu8 div3_ctrl_value;\n\tu8 posdiv_vallue;\n\tu8 div_ctrl_value;\n\tu8 reserve_3_2_value;\n\tu8 prediv_value;\n\tu8 reserve13_value;\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\tvoid __iomem *regs = hdmi_phy->regs;\n\n\tmtk_hdmi_pll_sel_src(hw);\n\n\tmtk_hdmi_pll_perf(hw);\n\n\tmtk_phy_update_field(regs + HDMI_1_CFG_10, RG_HDMITX21_BIAS_PE_BG_VREF_SEL, 0x2);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_10, RG_HDMITX21_VREF_SEL);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_9, RG_HDMITX21_SLDO_VREF_SEL, 0x2);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_10, RG_HDMITX21_BIAS_PE_VREF_SELB);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_3, RG_HDMITX21_SLDOLPF_EN);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_6, RG_HDMITX21_INTR_CAL, 0x11);\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_PWD);\n\n\t \n\ttxposdiv_value = ilog2(txposdiv);\n\n\tmtk_phy_update_field(regs + HDMI_1_CFG_6, RG_HDMITX21_TX_POSDIV, txposdiv_value);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_TX_POSDIV_EN);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_FRL_EN);\n\n\t \n\tswitch (txprediv) {\n\tcase 2:\n\t\tdiv3_ctrl_value = 0x0;\n\t\tposdiv_vallue = 0x0;\n\t\tbreak;\n\tcase 4:\n\t\tdiv3_ctrl_value = 0x0;\n\t\tposdiv_vallue = 0x1;\n\t\tbreak;\n\tcase 6:\n\t\tdiv3_ctrl_value = 0x1;\n\t\tposdiv_vallue = 0x0;\n\t\tbreak;\n\tcase 12:\n\t\tdiv3_ctrl_value = 0x1;\n\t\tposdiv_vallue = 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_4, RG_HDMITXPLL_POSDIV_DIV3_CTRL, div3_ctrl_value);\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_4, RG_HDMITXPLL_POSDIV, posdiv_vallue);\n\n\t \n\tswitch (posdiv1) {\n\tcase 5:\n\t\tdiv_ctrl_value = 0x0;\n\t\tbreak;\n\tcase 10:\n\t\tdiv_ctrl_value = 0x1;\n\t\tbreak;\n\tcase 12:\n\t\tdiv_ctrl_value = 0x2;\n\t\tbreak;\n\tcase 15:\n\t\tdiv_ctrl_value = 0x3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_4, RG_HDMITXPLL_DIV_CTRL, div_ctrl_value);\n\n\t \n\tmtk_phy_clear_bits(regs + HDMI_1_PLL_CFG_1, RG_HDMITXPLL_RESERVE_BIT14);\n\n\t \n\tswitch (posdiv2) {\n\tcase 1:\n\t\treserve_3_2_value = 0x0;\n\t\tbreak;\n\tcase 2:\n\t\treserve_3_2_value = 0x1;\n\t\tbreak;\n\tcase 4:\n\t\treserve_3_2_value = 0x2;\n\t\tbreak;\n\tcase 6:\n\t\treserve_3_2_value = 0x3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_1, RG_HDMITXPLL_RESERVE_BIT3_2, reserve_3_2_value);\n\n\t \n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_1, RG_HDMITXPLL_RESERVE_BIT1_0, 0x2);\n\n\t \n\tprediv_value = ilog2(prediv);\n\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_4, RG_HDMITXPLL_PREDIV, prediv_value);\n\n\t \n\treserve13_value = ilog2(fbkdiv_hs3);\n\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_1, RG_HDMITXPLL_RESERVE_BIT13, reserve13_value);\n\n\t \n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_4, RG_HDMITXPLL_FBKDIV_HIGH, fbkdiv_high);\n\tmtk_phy_update_field(regs + HDMI_1_PLL_CFG_3, RG_HDMITXPLL_FBKDIV_LOW, fbkdiv_low);\n\n\t \n\tmtk_phy_clear_bits(regs + HDMI_CTL_3, REG_PIXEL_CLOCK_SEL);\n\n\tif (digital_div == 1) {\n\t\tmtk_phy_clear_bits(regs + HDMI_CTL_3, REG_HDMITX_PIXEL_CLOCK);\n\t} else {\n\t\tmtk_phy_set_bits(regs + HDMI_CTL_3, REG_HDMITX_PIXEL_CLOCK);\n\t\tmtk_phy_update_field(regs + HDMI_CTL_3, REG_HDMITXPLL_DIV, digital_div - 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_hdmi_pll_calc(struct mtk_hdmi_phy *hdmi_phy, struct clk_hw *hw,\n\t\t\t     unsigned long rate, unsigned long parent_rate)\n{\n\tu8 digital_div, txprediv, txposdiv, fbkdiv_high, posdiv1, posdiv2;\n\tu64 tmds_clk, pixel_clk, da_hdmitx21_ref_ck, ns_hdmipll_ck, pcw;\n\tu8 txpredivs[4] = { 2, 4, 6, 12 };\n\tu32 fbkdiv_low;\n\tint i;\n\n\tpixel_clk = rate;\n\ttmds_clk = pixel_clk;\n\n\tif (tmds_clk < 25 * MEGA || tmds_clk > 594 * MEGA)\n\t\treturn -EINVAL;\n\n\tif (tmds_clk >= 340 * MEGA)\n\t\thdmi_phy->tmds_over_340M = true;\n\telse\n\t\thdmi_phy->tmds_over_340M = false;\n\n\t \n\tda_hdmitx21_ref_ck = 26 * MEGA;\n\n\t \n\tif (tmds_clk < 54 * MEGA)\n\t\ttxposdiv = 8;\n\telse if (tmds_clk >= 54 * MEGA && (tmds_clk * 100) < 14835 * MEGA)\n\t\ttxposdiv = 4;\n\telse if ((tmds_clk * 100) >= 14835 * MEGA && (tmds_clk * 10) < 2967 * MEGA)\n\t\ttxposdiv = 2;\n\telse if ((tmds_clk * 10) >= 2967 * MEGA && tmds_clk <= 594 * MEGA)\n\t\ttxposdiv = 1;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(txpredivs); i++) {\n\t\tns_hdmipll_ck = 5 * tmds_clk * txposdiv * txpredivs[i];\n\t\tif (ns_hdmipll_ck >= 5 * GIGA &&\n\t\t    ns_hdmipll_ck <= 12 * GIGA)\n\t\t\tbreak;\n\t}\n\tif (i == (ARRAY_SIZE(txpredivs) - 1) &&\n\t    (ns_hdmipll_ck < 5 * GIGA || ns_hdmipll_ck > 12 * GIGA)) {\n\t\treturn -EINVAL;\n\t}\n\tif (i == ARRAY_SIZE(txpredivs))\n\t\treturn -EINVAL;\n\n\ttxprediv = txpredivs[i];\n\n\t \n\tpcw = div_u64(((u64)ns_hdmipll_ck) << PCW_DECIMAL_WIDTH,\n\t\t      da_hdmitx21_ref_ck * PLL_FBKDIV_HS3);\n\n\tif (pcw > GENMASK_ULL(32, 0))\n\t\treturn -EINVAL;\n\n\tfbkdiv_high = FIELD_GET(GENMASK_ULL(63, 32), pcw);\n\tfbkdiv_low = FIELD_GET(GENMASK(31, 0), pcw);\n\n\t \n\tposdiv1 = 10;\n\tposdiv2 = 1;\n\n\t \n\tdigital_div = div_u64(ns_hdmipll_ck, posdiv1 * posdiv2 * pixel_clk);\n\tif (!(digital_div <= 32 && digital_div >= 1))\n\t\treturn -EINVAL;\n\n\treturn mtk_hdmi_pll_set_hw(hw, PLL_PREDIV, fbkdiv_high, fbkdiv_low,\n\t\t\t    PLL_FBKDIV_HS3, posdiv1, posdiv2, txprediv,\n\t\t\t    txposdiv, digital_div);\n}\n\nstatic int mtk_hdmi_pll_drv_setting(struct clk_hw *hw)\n{\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\tvoid __iomem *regs = hdmi_phy->regs;\n\tu8 data_channel_bias, clk_channel_bias;\n\tu8 impedance, impedance_en;\n\tu32 tmds_clk;\n\tu32 pixel_clk = hdmi_phy->pll_rate;\n\n\ttmds_clk = pixel_clk;\n\n\t \n\n\t \n\tif (tmds_clk > 300 * MEGA && tmds_clk <= 594 * MEGA) {\n\t\tdata_channel_bias = 0x3c;  \n\t\tclk_channel_bias = 0x34;  \n\t\timpedance_en = 0xf;\n\t\timpedance = 0x36;  \n\t} else if (((u64)pixel_clk * 1000) >= 74175 * MEGA && pixel_clk <= 300 * MEGA) {\n\t\tdata_channel_bias = 0x34;  \n\t\tclk_channel_bias = 0x2c;  \n\t\timpedance_en = 0xf;\n\t\timpedance = 0x36;  \n\t} else if (pixel_clk >= 27 * MEGA && ((u64)pixel_clk * 1000) < 74175 * MEGA) {\n\t\tdata_channel_bias = 0x14;  \n\t\tclk_channel_bias = 0x14;  \n\t\timpedance_en = 0x0;\n\t\timpedance = 0x0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmtk_phy_update_field(regs + HDMI_1_CFG_1, RG_HDMITX21_DRV_IBIAS_D0, data_channel_bias);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_1, RG_HDMITX21_DRV_IBIAS_D1, data_channel_bias);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_1, RG_HDMITX21_DRV_IBIAS_D2, data_channel_bias);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_0, RG_HDMITX21_DRV_IBIAS_CLK, clk_channel_bias);\n\n\t \n\tmtk_phy_update_field(regs + HDMI_1_CFG_0, RG_HDMITX21_DRV_IMP_EN, impedance_en);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_2, RG_HDMITX21_DRV_IMP_D0_EN1, impedance);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_2, RG_HDMITX21_DRV_IMP_D1_EN1, impedance);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_2, RG_HDMITX21_DRV_IMP_D2_EN1, impedance);\n\tmtk_phy_update_field(regs + HDMI_1_CFG_2, RG_HDMITX21_DRV_IMP_CLK_EN1, impedance);\n\n\treturn 0;\n}\n\nstatic int mtk_hdmi_pll_prepare(struct clk_hw *hw)\n{\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\tvoid __iomem *regs = hdmi_phy->regs;\n\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_TX_POSDIV_EN);\n\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_0, RG_HDMITX21_SER_EN);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_D0_DRV_OP_EN);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_D1_DRV_OP_EN);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_D2_DRV_OP_EN);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_CK_DRV_OP_EN);\n\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_FRL_D0_EN);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_FRL_D1_EN);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_FRL_D2_EN);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_FRL_CK_EN);\n\n\tmtk_hdmi_pll_drv_setting(hw);\n\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_10, RG_HDMITX21_BG_PWD);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_BIAS_EN);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_3, RG_HDMITX21_CKLDO_EN);\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_3, RG_HDMITX21_SLDO_EN);\n\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_4, DA_HDMITXPLL_PWR_ON);\n\tusleep_range(5, 10);\n\tmtk_phy_clear_bits(regs + HDMI_1_PLL_CFG_4, DA_HDMITXPLL_ISO_EN);\n\tusleep_range(5, 10);\n\tmtk_phy_clear_bits(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_PWD);\n\tusleep_range(30, 50);\n\treturn 0;\n}\n\nstatic void mtk_hdmi_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\tvoid __iomem *regs = hdmi_phy->regs;\n\n\tmtk_phy_set_bits(regs + HDMI_1_CFG_10, RG_HDMITX21_BG_PWD);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_6, RG_HDMITX21_BIAS_EN);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_3, RG_HDMITX21_CKLDO_EN);\n\tmtk_phy_clear_bits(regs + HDMI_1_CFG_3, RG_HDMITX21_SLDO_EN);\n\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_2, RG_HDMITXPLL_PWD);\n\tusleep_range(10, 20);\n\tmtk_phy_set_bits(regs + HDMI_1_PLL_CFG_4, DA_HDMITXPLL_ISO_EN);\n\tusleep_range(10, 20);\n\tmtk_phy_clear_bits(regs + HDMI_1_PLL_CFG_4, DA_HDMITXPLL_PWR_ON);\n}\n\nstatic int mtk_hdmi_pll_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long parent_rate)\n{\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\n\tdev_dbg(hdmi_phy->dev, \"%s: %lu Hz, parent: %lu Hz\\n\", __func__, rate,\n\t\tparent_rate);\n\n\treturn mtk_hdmi_pll_calc(hdmi_phy, hw, rate, parent_rate);\n}\n\nstatic long mtk_hdmi_pll_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long *parent_rate)\n{\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\n\thdmi_phy->pll_rate = rate;\n\treturn rate;\n}\n\nstatic unsigned long mtk_hdmi_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);\n\n\treturn hdmi_phy->pll_rate;\n}\n\nstatic const struct clk_ops mtk_hdmi_pll_ops = {\n\t.prepare = mtk_hdmi_pll_prepare,\n\t.unprepare = mtk_hdmi_pll_unprepare,\n\t.set_rate = mtk_hdmi_pll_set_rate,\n\t.round_rate = mtk_hdmi_pll_round_rate,\n\t.recalc_rate = mtk_hdmi_pll_recalc_rate,\n};\n\nstatic void vtx_signal_en(struct mtk_hdmi_phy *hdmi_phy, bool on)\n{\n\tvoid __iomem *regs = hdmi_phy->regs;\n\n\tif (on)\n\t\tmtk_phy_set_bits(regs + HDMI_1_CFG_0, RG_HDMITX21_DRV_EN);\n\telse\n\t\tmtk_phy_clear_bits(regs + HDMI_1_CFG_0, RG_HDMITX21_DRV_EN);\n}\n\nstatic void mtk_hdmi_phy_enable_tmds(struct mtk_hdmi_phy *hdmi_phy)\n{\n\tvtx_signal_en(hdmi_phy, true);\n\tusleep_range(100, 150);\n}\n\nstatic void mtk_hdmi_phy_disable_tmds(struct mtk_hdmi_phy *hdmi_phy)\n{\n\tvtx_signal_en(hdmi_phy, false);\n}\n\nstatic int mtk_hdmi_phy_configure(struct phy *phy, union phy_configure_opts *opts)\n{\n\tstruct phy_configure_opts_dp *dp_opts = &opts->dp;\n\tstruct mtk_hdmi_phy *hdmi_phy = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_set_rate(hdmi_phy->pll, dp_opts->link_rate);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmtk_phy_tmds_clk_ratio(hdmi_phy, hdmi_phy->tmds_over_340M);\n\n\treturn ret;\n}\n\nstruct mtk_hdmi_phy_conf mtk_hdmi_phy_8195_conf = {\n\t.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_GATE,\n\t.hdmi_phy_clk_ops = &mtk_hdmi_pll_ops,\n\t.hdmi_phy_enable_tmds = mtk_hdmi_phy_enable_tmds,\n\t.hdmi_phy_disable_tmds = mtk_hdmi_phy_disable_tmds,\n\t.hdmi_phy_configure = mtk_hdmi_phy_configure,\n};\n\nMODULE_AUTHOR(\"Can Zeng <can.zeng@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek MT8195 HDMI PHY Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}