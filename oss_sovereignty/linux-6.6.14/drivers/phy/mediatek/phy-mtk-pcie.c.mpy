{
  "module_name": "phy-mtk-pcie.c",
  "hash_id": "633db562cf91d4286d013bc67218d824b66926af3ead56e44fbbdfaf087cf1e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/mediatek/phy-mtk-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"phy-mtk-io.h\"\n\n#define PEXTP_ANA_GLB_00_REG\t\t0x9000\n \n#define EFUSE_GLB_INTR_SEL\t\tGENMASK(28, 24)\n\n#define PEXTP_ANA_LN0_TRX_REG\t\t0xa000\n\n#define PEXTP_ANA_TX_REG\t\t0x04\n \n#define EFUSE_LN_TX_PMOS_SEL\t\tGENMASK(5, 2)\n \n#define EFUSE_LN_TX_NMOS_SEL\t\tGENMASK(11, 8)\n\n#define PEXTP_ANA_RX_REG\t\t0x3c\n \n#define EFUSE_LN_RX_SEL\t\t\tGENMASK(3, 0)\n\n#define PEXTP_ANA_LANE_OFFSET\t\t0x100\n\n \nstruct mtk_pcie_lane_efuse {\n\tu32 tx_pmos;\n\tu32 tx_nmos;\n\tu32 rx_data;\n\tbool lane_efuse_supported;\n};\n\n \nstruct mtk_pcie_phy_data {\n\tint num_lanes;\n\tbool sw_efuse_supported;\n};\n\n \nstruct mtk_pcie_phy {\n\tstruct device *dev;\n\tstruct phy *phy;\n\tvoid __iomem *sif_base;\n\tconst struct mtk_pcie_phy_data *data;\n\n\tbool sw_efuse_en;\n\tu32 efuse_glb_intr;\n\tstruct mtk_pcie_lane_efuse *efuse;\n};\n\nstatic void mtk_pcie_efuse_set_lane(struct mtk_pcie_phy *pcie_phy,\n\t\t\t\t    unsigned int lane)\n{\n\tstruct mtk_pcie_lane_efuse *data = &pcie_phy->efuse[lane];\n\tvoid __iomem *addr;\n\n\tif (!data->lane_efuse_supported)\n\t\treturn;\n\n\taddr = pcie_phy->sif_base + PEXTP_ANA_LN0_TRX_REG +\n\t       lane * PEXTP_ANA_LANE_OFFSET;\n\n\tmtk_phy_update_field(addr + PEXTP_ANA_TX_REG, EFUSE_LN_TX_PMOS_SEL,\n\t\t\t     data->tx_pmos);\n\n\tmtk_phy_update_field(addr + PEXTP_ANA_TX_REG, EFUSE_LN_TX_NMOS_SEL,\n\t\t\t     data->tx_nmos);\n\n\tmtk_phy_update_field(addr + PEXTP_ANA_RX_REG, EFUSE_LN_RX_SEL,\n\t\t\t     data->rx_data);\n}\n\n \nstatic int mtk_pcie_phy_init(struct phy *phy)\n{\n\tstruct mtk_pcie_phy *pcie_phy = phy_get_drvdata(phy);\n\tint i;\n\n\tif (!pcie_phy->sw_efuse_en)\n\t\treturn 0;\n\n\t \n\tmtk_phy_update_field(pcie_phy->sif_base + PEXTP_ANA_GLB_00_REG,\n\t\t\t     EFUSE_GLB_INTR_SEL, pcie_phy->efuse_glb_intr);\n\n\tfor (i = 0; i < pcie_phy->data->num_lanes; i++)\n\t\tmtk_pcie_efuse_set_lane(pcie_phy, i);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops mtk_pcie_phy_ops = {\n\t.init\t= mtk_pcie_phy_init,\n\t.owner\t= THIS_MODULE,\n};\n\nstatic int mtk_pcie_efuse_read_for_lane(struct mtk_pcie_phy *pcie_phy,\n\t\t\t\t\tunsigned int lane)\n{\n\tstruct mtk_pcie_lane_efuse *efuse = &pcie_phy->efuse[lane];\n\tstruct device *dev = pcie_phy->dev;\n\tchar efuse_id[16];\n\tint ret;\n\n\tsnprintf(efuse_id, sizeof(efuse_id), \"tx_ln%d_pmos\", lane);\n\tret = nvmem_cell_read_variable_le_u32(dev, efuse_id, &efuse->tx_pmos);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read %s\\n\", efuse_id);\n\n\tsnprintf(efuse_id, sizeof(efuse_id), \"tx_ln%d_nmos\", lane);\n\tret = nvmem_cell_read_variable_le_u32(dev, efuse_id, &efuse->tx_nmos);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read %s\\n\", efuse_id);\n\n\tsnprintf(efuse_id, sizeof(efuse_id), \"rx_ln%d\", lane);\n\tret = nvmem_cell_read_variable_le_u32(dev, efuse_id, &efuse->rx_data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read %s\\n\", efuse_id);\n\n\tif (!(efuse->tx_pmos || efuse->tx_nmos || efuse->rx_data))\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\t     \"No eFuse data found for lane%d, but dts enable it\\n\",\n\t\t\t\t     lane);\n\n\tefuse->lane_efuse_supported = true;\n\n\treturn 0;\n}\n\nstatic int mtk_pcie_read_efuse(struct mtk_pcie_phy *pcie_phy)\n{\n\tstruct device *dev = pcie_phy->dev;\n\tbool nvmem_enabled;\n\tint ret, i;\n\n\t \n\tnvmem_enabled = device_property_present(dev, \"nvmem-cells\");\n\tif (!nvmem_enabled)\n\t\treturn 0;\n\n\tret = nvmem_cell_read_variable_le_u32(dev, \"glb_intr\",\n\t\t\t\t\t      &pcie_phy->efuse_glb_intr);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read glb_intr\\n\");\n\n\tpcie_phy->sw_efuse_en = true;\n\n\tpcie_phy->efuse = devm_kzalloc(dev, pcie_phy->data->num_lanes *\n\t\t\t\t       sizeof(*pcie_phy->efuse), GFP_KERNEL);\n\tif (!pcie_phy->efuse)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pcie_phy->data->num_lanes; i++) {\n\t\tret = mtk_pcie_efuse_read_for_lane(pcie_phy, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pcie_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *provider;\n\tstruct mtk_pcie_phy *pcie_phy;\n\tint ret;\n\n\tpcie_phy = devm_kzalloc(dev, sizeof(*pcie_phy), GFP_KERNEL);\n\tif (!pcie_phy)\n\t\treturn -ENOMEM;\n\n\tpcie_phy->sif_base = devm_platform_ioremap_resource_byname(pdev, \"sif\");\n\tif (IS_ERR(pcie_phy->sif_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcie_phy->sif_base),\n\t\t\t\t     \"Failed to map phy-sif base\\n\");\n\n\tpcie_phy->phy = devm_phy_create(dev, dev->of_node, &mtk_pcie_phy_ops);\n\tif (IS_ERR(pcie_phy->phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcie_phy->phy),\n\t\t\t\t     \"Failed to create PCIe phy\\n\");\n\n\tpcie_phy->dev = dev;\n\tpcie_phy->data = of_device_get_match_data(dev);\n\tif (!pcie_phy->data)\n\t\treturn dev_err_probe(dev, -EINVAL, \"Failed to get phy data\\n\");\n\n\tif (pcie_phy->data->sw_efuse_supported) {\n\t\t \n\t\tret = mtk_pcie_read_efuse(pcie_phy);\n\t\tif (ret == -EPROBE_DEFER || ret == -ENOMEM)\n\t\t\treturn ret;\n\t}\n\n\tphy_set_drvdata(pcie_phy->phy, pcie_phy);\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(provider))\n\t\treturn dev_err_probe(dev, PTR_ERR(provider),\n\t\t\t\t     \"PCIe phy probe failed\\n\");\n\n\treturn 0;\n}\n\nstatic const struct mtk_pcie_phy_data mt8195_data = {\n\t.num_lanes = 2,\n\t.sw_efuse_supported = true,\n};\n\nstatic const struct of_device_id mtk_pcie_phy_of_match[] = {\n\t{ .compatible = \"mediatek,mt8195-pcie-phy\", .data = &mt8195_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mtk_pcie_phy_of_match);\n\nstatic struct platform_driver mtk_pcie_phy_driver = {\n\t.probe\t= mtk_pcie_phy_probe,\n\t.driver\t= {\n\t\t.name = \"mtk-pcie-phy\",\n\t\t.of_match_table = mtk_pcie_phy_of_match,\n\t},\n};\nmodule_platform_driver(mtk_pcie_phy_driver);\n\nMODULE_DESCRIPTION(\"MediaTek PCIe PHY driver\");\nMODULE_AUTHOR(\"Jianjun Wang <jianjun.wang@mediatek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}