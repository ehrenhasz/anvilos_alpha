{
  "module_name": "phy-mtk-xsphy.c",
  "hash_id": "d5b56d285a039f4b9cda24518a24524f7b697f1c24a32611352e856ef309180f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/mediatek/phy-mtk-xsphy.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/phy/phy.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#include \"phy-mtk-io.h\"\n\n \n#define SSUSB_SIFSLV_MISC\t\t0x000\n#define SSUSB_SIFSLV_U2FREQ\t\t0x100\n#define SSUSB_SIFSLV_U2PHY_COM\t0x300\n\n \n#define SSPXTP_SIFSLV_DIG_GLB\t\t0x000\n#define SSPXTP_SIFSLV_PHYA_GLB\t\t0x100\n\n \n#define SSPXTP_SIFSLV_DIG_LN_TOP\t0x000\n#define SSPXTP_SIFSLV_DIG_LN_TX0\t0x100\n#define SSPXTP_SIFSLV_DIG_LN_RX0\t0x200\n#define SSPXTP_SIFSLV_DIG_LN_DAIF\t0x300\n#define SSPXTP_SIFSLV_PHYA_LN\t\t0x400\n\n#define XSP_U2FREQ_FMCR0\t((SSUSB_SIFSLV_U2FREQ) + 0x00)\n#define P2F_RG_FREQDET_EN\tBIT(24)\n#define P2F_RG_CYCLECNT\t\tGENMASK(23, 0)\n\n#define XSP_U2FREQ_MMONR0  ((SSUSB_SIFSLV_U2FREQ) + 0x0c)\n\n#define XSP_U2FREQ_FMMONR1\t((SSUSB_SIFSLV_U2FREQ) + 0x10)\n#define P2F_RG_FRCK_EN\t\tBIT(8)\n#define P2F_USB_FM_VALID\tBIT(0)\n\n#define XSP_USBPHYACR0\t((SSUSB_SIFSLV_U2PHY_COM) + 0x00)\n#define P2A0_RG_INTR_EN\tBIT(5)\n\n#define XSP_USBPHYACR1\t\t((SSUSB_SIFSLV_U2PHY_COM) + 0x04)\n#define P2A1_RG_INTR_CAL\t\tGENMASK(23, 19)\n#define P2A1_RG_VRT_SEL\t\t\tGENMASK(14, 12)\n#define P2A1_RG_TERM_SEL\t\tGENMASK(10, 8)\n\n#define XSP_USBPHYACR5\t\t((SSUSB_SIFSLV_U2PHY_COM) + 0x014)\n#define P2A5_RG_HSTX_SRCAL_EN\tBIT(15)\n#define P2A5_RG_HSTX_SRCTRL\t\tGENMASK(14, 12)\n\n#define XSP_USBPHYACR6\t\t((SSUSB_SIFSLV_U2PHY_COM) + 0x018)\n#define P2A6_RG_BC11_SW_EN\tBIT(23)\n#define P2A6_RG_OTG_VBUSCMP_EN\tBIT(20)\n\n#define XSP_U2PHYDTM1\t\t((SSUSB_SIFSLV_U2PHY_COM) + 0x06C)\n#define P2D_FORCE_IDDIG\t\tBIT(9)\n#define P2D_RG_VBUSVALID\tBIT(5)\n#define P2D_RG_SESSEND\t\tBIT(4)\n#define P2D_RG_AVALID\t\tBIT(2)\n#define P2D_RG_IDDIG\t\tBIT(1)\n\n#define SSPXTP_PHYA_GLB_00\t\t((SSPXTP_SIFSLV_PHYA_GLB) + 0x00)\n#define RG_XTP_GLB_BIAS_INTR_CTRL\t\tGENMASK(21, 16)\n\n#define SSPXTP_PHYA_LN_04\t((SSPXTP_SIFSLV_PHYA_LN) + 0x04)\n#define RG_XTP_LN0_TX_IMPSEL\t\tGENMASK(4, 0)\n\n#define SSPXTP_PHYA_LN_14\t((SSPXTP_SIFSLV_PHYA_LN) + 0x014)\n#define RG_XTP_LN0_RX_IMPSEL\t\tGENMASK(4, 0)\n\n#define XSP_REF_CLK\t\t26\t \n#define XSP_SLEW_RATE_COEF\t17\n#define XSP_SR_COEF_DIVISOR\t1000\n#define XSP_FM_DET_CYCLE_CNT\t1024\n\nstruct xsphy_instance {\n\tstruct phy *phy;\n\tvoid __iomem *port_base;\n\tstruct clk *ref_clk;\t \n\tu32 index;\n\tu32 type;\n\t \n\tint efuse_intr;\n\tint efuse_tx_imp;\n\tint efuse_rx_imp;\n\t \n\tint eye_src;\n\tint eye_vrt;\n\tint eye_term;\n};\n\nstruct mtk_xsphy {\n\tstruct device *dev;\n\tvoid __iomem *glb_base;\t \n\tstruct xsphy_instance **phys;\n\tint nphys;\n\tint src_ref_clk;  \n\tint src_coef;     \n};\n\nstatic void u2_phy_slew_rate_calibrate(struct mtk_xsphy *xsphy,\n\t\t\t\t\tstruct xsphy_instance *inst)\n{\n\tvoid __iomem *pbase = inst->port_base;\n\tint calib_val;\n\tint fm_out;\n\tu32 tmp;\n\n\t \n\tif (inst->eye_src)\n\t\treturn;\n\n\t \n\tmtk_phy_set_bits(pbase + XSP_USBPHYACR5, P2A5_RG_HSTX_SRCAL_EN);\n\tudelay(1);\t \n\n\t \n\tmtk_phy_set_bits(pbase + XSP_U2FREQ_FMMONR1, P2F_RG_FRCK_EN);\n\n\t \n\tmtk_phy_update_field(pbase + XSP_U2FREQ_FMCR0, P2F_RG_CYCLECNT,\n\t\t\t     XSP_FM_DET_CYCLE_CNT);\n\n\t \n\tmtk_phy_set_bits(pbase + XSP_U2FREQ_FMCR0, P2F_RG_FREQDET_EN);\n\n\t \n\treadl_poll_timeout(pbase + XSP_U2FREQ_FMMONR1, tmp,\n\t\t\t   (tmp & P2F_USB_FM_VALID), 10, 200);\n\n\tfm_out = readl(pbase + XSP_U2FREQ_MMONR0);\n\n\t \n\tmtk_phy_clear_bits(pbase + XSP_U2FREQ_FMCR0, P2F_RG_FREQDET_EN);\n\n\t \n\tmtk_phy_clear_bits(pbase + XSP_U2FREQ_FMMONR1, P2F_RG_FRCK_EN);\n\n\tif (fm_out) {\n\t\t \n\t\ttmp = xsphy->src_ref_clk * xsphy->src_coef;\n\t\ttmp = (tmp * XSP_FM_DET_CYCLE_CNT) / fm_out;\n\t\tcalib_val = DIV_ROUND_CLOSEST(tmp, XSP_SR_COEF_DIVISOR);\n\t} else {\n\t\t \n\t\tcalib_val = 3;\n\t}\n\tdev_dbg(xsphy->dev, \"phy.%d, fm_out:%d, calib:%d (clk:%d, coef:%d)\\n\",\n\t\tinst->index, fm_out, calib_val,\n\t\txsphy->src_ref_clk, xsphy->src_coef);\n\n\t \n\tmtk_phy_update_field(pbase + XSP_USBPHYACR5, P2A5_RG_HSTX_SRCTRL, calib_val);\n\n\t \n\tmtk_phy_clear_bits(pbase + XSP_USBPHYACR5, P2A5_RG_HSTX_SRCAL_EN);\n}\n\nstatic void u2_phy_instance_init(struct mtk_xsphy *xsphy,\n\t\t\t\t struct xsphy_instance *inst)\n{\n\tvoid __iomem *pbase = inst->port_base;\n\n\t \n\tmtk_phy_clear_bits(pbase + XSP_USBPHYACR6, P2A6_RG_BC11_SW_EN);\n\n\tmtk_phy_set_bits(pbase + XSP_USBPHYACR0, P2A0_RG_INTR_EN);\n}\n\nstatic void u2_phy_instance_power_on(struct mtk_xsphy *xsphy,\n\t\t\t\t     struct xsphy_instance *inst)\n{\n\tvoid __iomem *pbase = inst->port_base;\n\tu32 index = inst->index;\n\n\tmtk_phy_set_bits(pbase + XSP_USBPHYACR6, P2A6_RG_OTG_VBUSCMP_EN);\n\n\tmtk_phy_update_bits(pbase + XSP_U2PHYDTM1,\n\t\t\t    P2D_RG_VBUSVALID | P2D_RG_AVALID | P2D_RG_SESSEND,\n\t\t\t    P2D_RG_VBUSVALID | P2D_RG_AVALID);\n\n\tdev_dbg(xsphy->dev, \"%s(%d)\\n\", __func__, index);\n}\n\nstatic void u2_phy_instance_power_off(struct mtk_xsphy *xsphy,\n\t\t\t\t      struct xsphy_instance *inst)\n{\n\tvoid __iomem *pbase = inst->port_base;\n\tu32 index = inst->index;\n\n\tmtk_phy_clear_bits(pbase + XSP_USBPHYACR6, P2A6_RG_OTG_VBUSCMP_EN);\n\n\tmtk_phy_update_bits(pbase + XSP_U2PHYDTM1,\n\t\t\t    P2D_RG_VBUSVALID | P2D_RG_AVALID | P2D_RG_SESSEND,\n\t\t\t    P2D_RG_SESSEND);\n\n\tdev_dbg(xsphy->dev, \"%s(%d)\\n\", __func__, index);\n}\n\nstatic void u2_phy_instance_set_mode(struct mtk_xsphy *xsphy,\n\t\t\t\t     struct xsphy_instance *inst,\n\t\t\t\t     enum phy_mode mode)\n{\n\tu32 tmp;\n\n\ttmp = readl(inst->port_base + XSP_U2PHYDTM1);\n\tswitch (mode) {\n\tcase PHY_MODE_USB_DEVICE:\n\t\ttmp |= P2D_FORCE_IDDIG | P2D_RG_IDDIG;\n\t\tbreak;\n\tcase PHY_MODE_USB_HOST:\n\t\ttmp |= P2D_FORCE_IDDIG;\n\t\ttmp &= ~P2D_RG_IDDIG;\n\t\tbreak;\n\tcase PHY_MODE_USB_OTG:\n\t\ttmp &= ~(P2D_FORCE_IDDIG | P2D_RG_IDDIG);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\twritel(tmp, inst->port_base + XSP_U2PHYDTM1);\n}\n\nstatic void phy_parse_property(struct mtk_xsphy *xsphy,\n\t\t\t\tstruct xsphy_instance *inst)\n{\n\tstruct device *dev = &inst->phy->dev;\n\n\tswitch (inst->type) {\n\tcase PHY_TYPE_USB2:\n\t\tdevice_property_read_u32(dev, \"mediatek,efuse-intr\",\n\t\t\t\t\t &inst->efuse_intr);\n\t\tdevice_property_read_u32(dev, \"mediatek,eye-src\",\n\t\t\t\t\t &inst->eye_src);\n\t\tdevice_property_read_u32(dev, \"mediatek,eye-vrt\",\n\t\t\t\t\t &inst->eye_vrt);\n\t\tdevice_property_read_u32(dev, \"mediatek,eye-term\",\n\t\t\t\t\t &inst->eye_term);\n\t\tdev_dbg(dev, \"intr:%d, src:%d, vrt:%d, term:%d\\n\",\n\t\t\tinst->efuse_intr, inst->eye_src,\n\t\t\tinst->eye_vrt, inst->eye_term);\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\t\tdevice_property_read_u32(dev, \"mediatek,efuse-intr\",\n\t\t\t\t\t &inst->efuse_intr);\n\t\tdevice_property_read_u32(dev, \"mediatek,efuse-tx-imp\",\n\t\t\t\t\t &inst->efuse_tx_imp);\n\t\tdevice_property_read_u32(dev, \"mediatek,efuse-rx-imp\",\n\t\t\t\t\t &inst->efuse_rx_imp);\n\t\tdev_dbg(dev, \"intr:%d, tx-imp:%d, rx-imp:%d\\n\",\n\t\t\tinst->efuse_intr, inst->efuse_tx_imp,\n\t\t\tinst->efuse_rx_imp);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(xsphy->dev, \"incompatible phy type\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void u2_phy_props_set(struct mtk_xsphy *xsphy,\n\t\t\t     struct xsphy_instance *inst)\n{\n\tvoid __iomem *pbase = inst->port_base;\n\n\tif (inst->efuse_intr)\n\t\tmtk_phy_update_field(pbase + XSP_USBPHYACR1, P2A1_RG_INTR_CAL,\n\t\t\t\t     inst->efuse_intr);\n\n\tif (inst->eye_src)\n\t\tmtk_phy_update_field(pbase + XSP_USBPHYACR5, P2A5_RG_HSTX_SRCTRL,\n\t\t\t\t     inst->eye_src);\n\n\tif (inst->eye_vrt)\n\t\tmtk_phy_update_field(pbase + XSP_USBPHYACR1, P2A1_RG_VRT_SEL,\n\t\t\t\t     inst->eye_vrt);\n\n\tif (inst->eye_term)\n\t\tmtk_phy_update_field(pbase + XSP_USBPHYACR1, P2A1_RG_TERM_SEL,\n\t\t\t\t     inst->eye_term);\n}\n\nstatic void u3_phy_props_set(struct mtk_xsphy *xsphy,\n\t\t\t     struct xsphy_instance *inst)\n{\n\tvoid __iomem *pbase = inst->port_base;\n\n\tif (inst->efuse_intr)\n\t\tmtk_phy_update_field(xsphy->glb_base + SSPXTP_PHYA_GLB_00,\n\t\t\t\t     RG_XTP_GLB_BIAS_INTR_CTRL, inst->efuse_intr);\n\n\tif (inst->efuse_tx_imp)\n\t\tmtk_phy_update_field(pbase + SSPXTP_PHYA_LN_04,\n\t\t\t\t     RG_XTP_LN0_TX_IMPSEL, inst->efuse_tx_imp);\n\n\tif (inst->efuse_rx_imp)\n\t\tmtk_phy_update_field(pbase + SSPXTP_PHYA_LN_14,\n\t\t\t\t     RG_XTP_LN0_RX_IMPSEL, inst->efuse_rx_imp);\n}\n\nstatic int mtk_phy_init(struct phy *phy)\n{\n\tstruct xsphy_instance *inst = phy_get_drvdata(phy);\n\tstruct mtk_xsphy *xsphy = dev_get_drvdata(phy->dev.parent);\n\tint ret;\n\n\tret = clk_prepare_enable(inst->ref_clk);\n\tif (ret) {\n\t\tdev_err(xsphy->dev, \"failed to enable ref_clk\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (inst->type) {\n\tcase PHY_TYPE_USB2:\n\t\tu2_phy_instance_init(xsphy, inst);\n\t\tu2_phy_props_set(xsphy, inst);\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\t\tu3_phy_props_set(xsphy, inst);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(xsphy->dev, \"incompatible phy type\\n\");\n\t\tclk_disable_unprepare(inst->ref_clk);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_phy_power_on(struct phy *phy)\n{\n\tstruct xsphy_instance *inst = phy_get_drvdata(phy);\n\tstruct mtk_xsphy *xsphy = dev_get_drvdata(phy->dev.parent);\n\n\tif (inst->type == PHY_TYPE_USB2) {\n\t\tu2_phy_instance_power_on(xsphy, inst);\n\t\tu2_phy_slew_rate_calibrate(xsphy, inst);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_phy_power_off(struct phy *phy)\n{\n\tstruct xsphy_instance *inst = phy_get_drvdata(phy);\n\tstruct mtk_xsphy *xsphy = dev_get_drvdata(phy->dev.parent);\n\n\tif (inst->type == PHY_TYPE_USB2)\n\t\tu2_phy_instance_power_off(xsphy, inst);\n\n\treturn 0;\n}\n\nstatic int mtk_phy_exit(struct phy *phy)\n{\n\tstruct xsphy_instance *inst = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(inst->ref_clk);\n\treturn 0;\n}\n\nstatic int mtk_phy_set_mode(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tstruct xsphy_instance *inst = phy_get_drvdata(phy);\n\tstruct mtk_xsphy *xsphy = dev_get_drvdata(phy->dev.parent);\n\n\tif (inst->type == PHY_TYPE_USB2)\n\t\tu2_phy_instance_set_mode(xsphy, inst, mode);\n\n\treturn 0;\n}\n\nstatic struct phy *mtk_phy_xlate(struct device *dev,\n\t\t\t\t struct of_phandle_args *args)\n{\n\tstruct mtk_xsphy *xsphy = dev_get_drvdata(dev);\n\tstruct xsphy_instance *inst = NULL;\n\tstruct device_node *phy_np = args->np;\n\tint index;\n\n\tif (args->args_count != 1) {\n\t\tdev_err(dev, \"invalid number of cells in 'phy' property\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfor (index = 0; index < xsphy->nphys; index++)\n\t\tif (phy_np == xsphy->phys[index]->phy->dev.of_node) {\n\t\t\tinst = xsphy->phys[index];\n\t\t\tbreak;\n\t\t}\n\n\tif (!inst) {\n\t\tdev_err(dev, \"failed to find appropriate phy\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinst->type = args->args[0];\n\tif (!(inst->type == PHY_TYPE_USB2 ||\n\t      inst->type == PHY_TYPE_USB3)) {\n\t\tdev_err(dev, \"unsupported phy type: %d\\n\", inst->type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tphy_parse_property(xsphy, inst);\n\n\treturn inst->phy;\n}\n\nstatic const struct phy_ops mtk_xsphy_ops = {\n\t.init\t\t= mtk_phy_init,\n\t.exit\t\t= mtk_phy_exit,\n\t.power_on\t= mtk_phy_power_on,\n\t.power_off\t= mtk_phy_power_off,\n\t.set_mode\t= mtk_phy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id mtk_xsphy_id_table[] = {\n\t{ .compatible = \"mediatek,xsphy\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mtk_xsphy_id_table);\n\nstatic int mtk_xsphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child_np;\n\tstruct phy_provider *provider;\n\tstruct resource *glb_res;\n\tstruct mtk_xsphy *xsphy;\n\tstruct resource res;\n\tint port, retval;\n\n\txsphy = devm_kzalloc(dev, sizeof(*xsphy), GFP_KERNEL);\n\tif (!xsphy)\n\t\treturn -ENOMEM;\n\n\txsphy->nphys = of_get_child_count(np);\n\txsphy->phys = devm_kcalloc(dev, xsphy->nphys,\n\t\t\t\t       sizeof(*xsphy->phys), GFP_KERNEL);\n\tif (!xsphy->phys)\n\t\treturn -ENOMEM;\n\n\txsphy->dev = dev;\n\tplatform_set_drvdata(pdev, xsphy);\n\n\tglb_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t \n\tif (glb_res) {\n\t\t \n\t\txsphy->glb_base = devm_ioremap_resource(dev, glb_res);\n\t\tif (IS_ERR(xsphy->glb_base)) {\n\t\t\tdev_err(dev, \"failed to remap glb regs\\n\");\n\t\t\treturn PTR_ERR(xsphy->glb_base);\n\t\t}\n\t}\n\n\txsphy->src_ref_clk = XSP_REF_CLK;\n\txsphy->src_coef = XSP_SLEW_RATE_COEF;\n\t \n\tdevice_property_read_u32(dev, \"mediatek,src-ref-clk-mhz\",\n\t\t\t\t &xsphy->src_ref_clk);\n\tdevice_property_read_u32(dev, \"mediatek,src-coef\", &xsphy->src_coef);\n\n\tport = 0;\n\tfor_each_child_of_node(np, child_np) {\n\t\tstruct xsphy_instance *inst;\n\t\tstruct phy *phy;\n\n\t\tinst = devm_kzalloc(dev, sizeof(*inst), GFP_KERNEL);\n\t\tif (!inst) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\txsphy->phys[port] = inst;\n\n\t\tphy = devm_phy_create(dev, child_np, &mtk_xsphy_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(dev, \"failed to create phy\\n\");\n\t\t\tretval = PTR_ERR(phy);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tretval = of_address_to_resource(child_np, 0, &res);\n\t\tif (retval) {\n\t\t\tdev_err(dev, \"failed to get address resource(id-%d)\\n\",\n\t\t\t\tport);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tinst->port_base = devm_ioremap_resource(&phy->dev, &res);\n\t\tif (IS_ERR(inst->port_base)) {\n\t\t\tdev_err(dev, \"failed to remap phy regs\\n\");\n\t\t\tretval = PTR_ERR(inst->port_base);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tinst->phy = phy;\n\t\tinst->index = port;\n\t\tphy_set_drvdata(phy, inst);\n\t\tport++;\n\n\t\tinst->ref_clk = devm_clk_get(&phy->dev, \"ref\");\n\t\tif (IS_ERR(inst->ref_clk)) {\n\t\t\tdev_err(dev, \"failed to get ref_clk(id-%d)\\n\", port);\n\t\t\tretval = PTR_ERR(inst->ref_clk);\n\t\t\tgoto put_child;\n\t\t}\n\t}\n\n\tprovider = devm_of_phy_provider_register(dev, mtk_phy_xlate);\n\treturn PTR_ERR_OR_ZERO(provider);\n\nput_child:\n\tof_node_put(child_np);\n\treturn retval;\n}\n\nstatic struct platform_driver mtk_xsphy_driver = {\n\t.probe\t\t= mtk_xsphy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"mtk-xsphy\",\n\t\t.of_match_table = mtk_xsphy_id_table,\n\t},\n};\n\nmodule_platform_driver(mtk_xsphy_driver);\n\nMODULE_AUTHOR(\"Chunfeng Yun <chunfeng.yun@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek USB XS-PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}