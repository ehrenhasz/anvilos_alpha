{
  "module_name": "phy-stm32-usbphyc.c",
  "hash_id": "8b1213aa967bc01e79c9a2d11576b67cac38a62edd27630ca2fbe315d2af12a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/st/phy-stm32-usbphyc.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/units.h>\n\n#define STM32_USBPHYC_PLL\t0x0\n#define STM32_USBPHYC_MISC\t0x8\n#define STM32_USBPHYC_MONITOR(X) (0x108 + ((X) * 0x100))\n#define STM32_USBPHYC_TUNE(X)\t(0x10C + ((X) * 0x100))\n#define STM32_USBPHYC_VERSION\t0x3F4\n\n \n#define PLLNDIV\t\t\tGENMASK(6, 0)\n#define PLLFRACIN\t\tGENMASK(25, 10)\n#define PLLEN\t\t\tBIT(26)\n#define PLLSTRB\t\t\tBIT(27)\n#define PLLSTRBYP\t\tBIT(28)\n#define PLLFRACCTL\t\tBIT(29)\n#define PLLDITHEN0\t\tBIT(30)\n#define PLLDITHEN1\t\tBIT(31)\n\n \n#define SWITHOST\t\tBIT(0)\n\n \n#define STM32_USBPHYC_MON_OUT\tGENMASK(3, 0)\n#define STM32_USBPHYC_MON_SEL\tGENMASK(8, 4)\n#define STM32_USBPHYC_MON_SEL_LOCKP 0x1F\n#define STM32_USBPHYC_MON_OUT_LOCKP BIT(3)\n\n \n#define INCURREN\t\tBIT(0)\n#define INCURRINT\t\tBIT(1)\n#define LFSCAPEN\t\tBIT(2)\n#define HSDRVSLEW\t\tBIT(3)\n#define HSDRVDCCUR\t\tBIT(4)\n#define HSDRVDCLEV\t\tBIT(5)\n#define HSDRVCURINCR\t\tBIT(6)\n#define FSDRVRFADJ\t\tBIT(7)\n#define HSDRVRFRED\t\tBIT(8)\n#define HSDRVCHKITRM\t\tGENMASK(12, 9)\n#define HSDRVCHKZTRM\t\tGENMASK(14, 13)\n#define OTPCOMP\t\t\tGENMASK(19, 15)\n#define SQLCHCTL\t\tGENMASK(21, 20)\n#define HDRXGNEQEN\t\tBIT(22)\n#define HSRXOFF\t\t\tGENMASK(24, 23)\n#define HSFALLPREEM\t\tBIT(25)\n#define SHTCCTCTLPROT\t\tBIT(26)\n#define STAGSEL\t\t\tBIT(27)\n\nenum boosting_vals {\n\tBOOST_1000_UA = 1000,\n\tBOOST_2000_UA = 2000,\n};\n\nenum dc_level_vals {\n\tDC_NOMINAL,\n\tDC_PLUS_5_TO_7_MV,\n\tDC_PLUS_10_TO_14_MV,\n\tDC_MINUS_5_TO_7_MV,\n\tDC_MAX,\n};\n\nenum current_trim {\n\tCUR_NOMINAL,\n\tCUR_PLUS_1_56_PCT,\n\tCUR_PLUS_3_12_PCT,\n\tCUR_PLUS_4_68_PCT,\n\tCUR_PLUS_6_24_PCT,\n\tCUR_PLUS_7_8_PCT,\n\tCUR_PLUS_9_36_PCT,\n\tCUR_PLUS_10_92_PCT,\n\tCUR_PLUS_12_48_PCT,\n\tCUR_PLUS_14_04_PCT,\n\tCUR_PLUS_15_6_PCT,\n\tCUR_PLUS_17_16_PCT,\n\tCUR_PLUS_19_01_PCT,\n\tCUR_PLUS_20_58_PCT,\n\tCUR_PLUS_22_16_PCT,\n\tCUR_PLUS_23_73_PCT,\n\tCUR_MAX,\n};\n\nenum impedance_trim {\n\tIMP_NOMINAL,\n\tIMP_MINUS_2_OHMS,\n\tIMP_MINUS_4_OMHS,\n\tIMP_MINUS_6_OHMS,\n\tIMP_MAX,\n};\n\nenum squelch_level {\n\tSQLCH_NOMINAL,\n\tSQLCH_PLUS_7_MV,\n\tSQLCH_MINUS_5_MV,\n\tSQLCH_PLUS_14_MV,\n\tSQLCH_MAX,\n};\n\nenum rx_offset {\n\tNO_RX_OFFSET,\n\tRX_OFFSET_PLUS_5_MV,\n\tRX_OFFSET_PLUS_10_MV,\n\tRX_OFFSET_MINUS_5_MV,\n\tRX_OFFSET_MAX,\n};\n\n \n#define MINREV\t\t\tGENMASK(3, 0)\n#define MAJREV\t\t\tGENMASK(7, 4)\n\n#define PLL_FVCO_MHZ\t\t2880\n#define PLL_INFF_MIN_RATE_HZ\t19200000\n#define PLL_INFF_MAX_RATE_HZ\t38400000\n\nstruct pll_params {\n\tu8 ndiv;\n\tu16 frac;\n};\n\nstruct stm32_usbphyc_phy {\n\tstruct phy *phy;\n\tstruct stm32_usbphyc *usbphyc;\n\tstruct regulator *vbus;\n\tu32 index;\n\tbool active;\n\tu32 tune;\n};\n\nstruct stm32_usbphyc {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tstruct stm32_usbphyc_phy **phys;\n\tint nphys;\n\tstruct regulator *vdda1v1;\n\tstruct regulator *vdda1v8;\n\tatomic_t n_pll_cons;\n\tstruct clk_hw clk48_hw;\n\tint switch_setup;\n};\n\nstatic inline void stm32_usbphyc_set_bits(void __iomem *reg, u32 bits)\n{\n\twritel_relaxed(readl_relaxed(reg) | bits, reg);\n}\n\nstatic inline void stm32_usbphyc_clr_bits(void __iomem *reg, u32 bits)\n{\n\twritel_relaxed(readl_relaxed(reg) & ~bits, reg);\n}\n\nstatic int stm32_usbphyc_regulators_enable(struct stm32_usbphyc *usbphyc)\n{\n\tint ret;\n\n\tret = regulator_enable(usbphyc->vdda1v1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(usbphyc->vdda1v8);\n\tif (ret)\n\t\tgoto vdda1v1_disable;\n\n\treturn 0;\n\nvdda1v1_disable:\n\tregulator_disable(usbphyc->vdda1v1);\n\n\treturn ret;\n}\n\nstatic int stm32_usbphyc_regulators_disable(struct stm32_usbphyc *usbphyc)\n{\n\tint ret;\n\n\tret = regulator_disable(usbphyc->vdda1v8);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_disable(usbphyc->vdda1v1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void stm32_usbphyc_get_pll_params(u32 clk_rate,\n\t\t\t\t\t struct pll_params *pll_params)\n{\n\tunsigned long long fvco, ndiv, frac;\n\n\t \n\tfvco = (unsigned long long)PLL_FVCO_MHZ * HZ_PER_MHZ;\n\n\tndiv = fvco;\n\tdo_div(ndiv, (clk_rate * 2));\n\tpll_params->ndiv = (u8)ndiv;\n\n\tfrac = fvco * (1 << 16);\n\tdo_div(frac, (clk_rate * 2));\n\tfrac = frac - (ndiv * (1 << 16));\n\tpll_params->frac = (u16)frac;\n}\n\nstatic int stm32_usbphyc_pll_init(struct stm32_usbphyc *usbphyc)\n{\n\tstruct pll_params pll_params;\n\tu32 clk_rate = clk_get_rate(usbphyc->clk);\n\tu32 ndiv, frac;\n\tu32 usbphyc_pll;\n\n\tif ((clk_rate < PLL_INFF_MIN_RATE_HZ) ||\n\t    (clk_rate > PLL_INFF_MAX_RATE_HZ)) {\n\t\tdev_err(usbphyc->dev, \"input clk freq (%dHz) out of range\\n\",\n\t\t\tclk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tstm32_usbphyc_get_pll_params(clk_rate, &pll_params);\n\tndiv = FIELD_PREP(PLLNDIV, pll_params.ndiv);\n\tfrac = FIELD_PREP(PLLFRACIN, pll_params.frac);\n\n\tusbphyc_pll = PLLDITHEN1 | PLLDITHEN0 | PLLSTRBYP | ndiv;\n\n\tif (pll_params.frac)\n\t\tusbphyc_pll |= PLLFRACCTL | frac;\n\n\twritel_relaxed(usbphyc_pll, usbphyc->base + STM32_USBPHYC_PLL);\n\n\tdev_dbg(usbphyc->dev, \"input clk freq=%dHz, ndiv=%lu, frac=%lu\\n\",\n\t\tclk_rate, FIELD_GET(PLLNDIV, usbphyc_pll),\n\t\tFIELD_GET(PLLFRACIN, usbphyc_pll));\n\n\treturn 0;\n}\n\nstatic int __stm32_usbphyc_pll_disable(struct stm32_usbphyc *usbphyc)\n{\n\tvoid __iomem *pll_reg = usbphyc->base + STM32_USBPHYC_PLL;\n\tu32 pllen;\n\n\tstm32_usbphyc_clr_bits(pll_reg, PLLEN);\n\n\t \n\tif (readl_relaxed_poll_timeout(pll_reg, pllen, !(pllen & PLLEN), 5, 50))\n\t\tdev_err(usbphyc->dev, \"PLL not reset\\n\");\n\n\treturn stm32_usbphyc_regulators_disable(usbphyc);\n}\n\nstatic int stm32_usbphyc_pll_disable(struct stm32_usbphyc *usbphyc)\n{\n\t \n\tif (atomic_dec_return(&usbphyc->n_pll_cons) > 0)\n\t\treturn 0;\n\n\treturn __stm32_usbphyc_pll_disable(usbphyc);\n}\n\nstatic int stm32_usbphyc_pll_enable(struct stm32_usbphyc *usbphyc)\n{\n\tvoid __iomem *pll_reg = usbphyc->base + STM32_USBPHYC_PLL;\n\tbool pllen = readl_relaxed(pll_reg) & PLLEN;\n\tint ret;\n\n\t \n\tif (atomic_inc_return(&usbphyc->n_pll_cons) > 1 && pllen)\n\t\treturn 0;\n\n\tif (pllen) {\n\t\t \n\t\tdev_warn(usbphyc->dev, \"PLL enabled without known consumers\\n\");\n\n\t\tret = __stm32_usbphyc_pll_disable(usbphyc);\n\t\tif (ret)\n\t\t\tgoto dec_n_pll_cons;\n\t}\n\n\tret = stm32_usbphyc_regulators_enable(usbphyc);\n\tif (ret)\n\t\tgoto dec_n_pll_cons;\n\n\tret = stm32_usbphyc_pll_init(usbphyc);\n\tif (ret)\n\t\tgoto reg_disable;\n\n\tstm32_usbphyc_set_bits(pll_reg, PLLEN);\n\n\t \n\tusleep_range(200, 300);\n\n\treturn 0;\n\nreg_disable:\n\tstm32_usbphyc_regulators_disable(usbphyc);\n\ndec_n_pll_cons:\n\tatomic_dec(&usbphyc->n_pll_cons);\n\n\treturn ret;\n}\n\nstatic int stm32_usbphyc_phy_init(struct phy *phy)\n{\n\tstruct stm32_usbphyc_phy *usbphyc_phy = phy_get_drvdata(phy);\n\tstruct stm32_usbphyc *usbphyc = usbphyc_phy->usbphyc;\n\tu32 reg_mon = STM32_USBPHYC_MONITOR(usbphyc_phy->index);\n\tu32 monsel = FIELD_PREP(STM32_USBPHYC_MON_SEL,\n\t\t\t\tSTM32_USBPHYC_MON_SEL_LOCKP);\n\tu32 monout;\n\tint ret;\n\n\tret = stm32_usbphyc_pll_enable(usbphyc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel_relaxed(monsel, usbphyc->base + reg_mon);\n\tret = readl_relaxed_poll_timeout(usbphyc->base + reg_mon, monout,\n\t\t\t\t\t (monout & STM32_USBPHYC_MON_OUT_LOCKP),\n\t\t\t\t\t 100, 1000);\n\tif (ret) {\n\t\tdev_err(usbphyc->dev, \"PLL Lock input to PHY is Low (val=%x)\\n\",\n\t\t\t(u32)(monout & STM32_USBPHYC_MON_OUT));\n\t\tgoto pll_disable;\n\t}\n\n\tusbphyc_phy->active = true;\n\n\treturn 0;\n\npll_disable:\n\tstm32_usbphyc_pll_disable(usbphyc);\n\n\treturn ret;\n}\n\nstatic int stm32_usbphyc_phy_exit(struct phy *phy)\n{\n\tstruct stm32_usbphyc_phy *usbphyc_phy = phy_get_drvdata(phy);\n\tstruct stm32_usbphyc *usbphyc = usbphyc_phy->usbphyc;\n\n\tusbphyc_phy->active = false;\n\n\treturn stm32_usbphyc_pll_disable(usbphyc);\n}\n\nstatic int stm32_usbphyc_phy_power_on(struct phy *phy)\n{\n\tstruct stm32_usbphyc_phy *usbphyc_phy = phy_get_drvdata(phy);\n\n\tif (usbphyc_phy->vbus)\n\t\treturn regulator_enable(usbphyc_phy->vbus);\n\n\treturn 0;\n}\n\nstatic int stm32_usbphyc_phy_power_off(struct phy *phy)\n{\n\tstruct stm32_usbphyc_phy *usbphyc_phy = phy_get_drvdata(phy);\n\n\tif (usbphyc_phy->vbus)\n\t\treturn regulator_disable(usbphyc_phy->vbus);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops stm32_usbphyc_phy_ops = {\n\t.init = stm32_usbphyc_phy_init,\n\t.exit = stm32_usbphyc_phy_exit,\n\t.power_on = stm32_usbphyc_phy_power_on,\n\t.power_off = stm32_usbphyc_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic int stm32_usbphyc_clk48_prepare(struct clk_hw *hw)\n{\n\tstruct stm32_usbphyc *usbphyc = container_of(hw, struct stm32_usbphyc, clk48_hw);\n\n\treturn stm32_usbphyc_pll_enable(usbphyc);\n}\n\nstatic void stm32_usbphyc_clk48_unprepare(struct clk_hw *hw)\n{\n\tstruct stm32_usbphyc *usbphyc = container_of(hw, struct stm32_usbphyc, clk48_hw);\n\n\tstm32_usbphyc_pll_disable(usbphyc);\n}\n\nstatic unsigned long stm32_usbphyc_clk48_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\treturn 48000000;\n}\n\nstatic const struct clk_ops usbphyc_clk48_ops = {\n\t.prepare = stm32_usbphyc_clk48_prepare,\n\t.unprepare = stm32_usbphyc_clk48_unprepare,\n\t.recalc_rate = stm32_usbphyc_clk48_recalc_rate,\n};\n\nstatic void stm32_usbphyc_clk48_unregister(void *data)\n{\n\tstruct stm32_usbphyc *usbphyc = data;\n\n\tof_clk_del_provider(usbphyc->dev->of_node);\n\tclk_hw_unregister(&usbphyc->clk48_hw);\n}\n\nstatic int stm32_usbphyc_clk48_register(struct stm32_usbphyc *usbphyc)\n{\n\tstruct device_node *node = usbphyc->dev->of_node;\n\tstruct clk_init_data init = { };\n\tint ret = 0;\n\n\tinit.name = \"ck_usbo_48m\";\n\tinit.ops = &usbphyc_clk48_ops;\n\n\tusbphyc->clk48_hw.init = &init;\n\n\tret = clk_hw_register(usbphyc->dev, &usbphyc->clk48_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_clk_add_hw_provider(node, of_clk_hw_simple_get, &usbphyc->clk48_hw);\n\tif (ret)\n\t\tclk_hw_unregister(&usbphyc->clk48_hw);\n\n\treturn ret;\n}\n\nstatic void stm32_usbphyc_phy_tuning(struct stm32_usbphyc *usbphyc,\n\t\t\t\t     struct device_node *np, u32 index)\n{\n\tstruct stm32_usbphyc_phy *usbphyc_phy = usbphyc->phys[index];\n\tu32 reg = STM32_USBPHYC_TUNE(index);\n\tu32 otpcomp, val;\n\tint ret;\n\n\t \n\totpcomp = FIELD_GET(OTPCOMP, readl_relaxed(usbphyc->base + reg));\n\n\tret = of_property_read_u32(np, \"st,current-boost-microamp\", &val);\n\tif (ret != -EINVAL) {\n\t\tif (!ret && (val == BOOST_1000_UA || val == BOOST_2000_UA)) {\n\t\t\tval = (val == BOOST_2000_UA) ? 1 : 0;\n\t\t\tusbphyc_phy->tune |= INCURREN | FIELD_PREP(INCURRINT, val);\n\t\t} else {\n\t\t\tdev_warn(usbphyc->dev, \"phy%d: invalid st,current-boost-microamp\\n\", index);\n\t\t}\n\t}\n\n\tif (!of_property_read_bool(np, \"st,no-lsfs-fb-cap\"))\n\t\tusbphyc_phy->tune |= LFSCAPEN;\n\n\tif (of_property_read_bool(np, \"st,decrease-hs-slew-rate\"))\n\t\tusbphyc_phy->tune |= HSDRVSLEW;\n\n\tret = of_property_read_u32(np, \"st,tune-hs-dc-level\", &val);\n\tif (ret != -EINVAL) {\n\t\tif (!ret && val < DC_MAX) {\n\t\t\tif (val == DC_MINUS_5_TO_7_MV) { \n\t\t\t\tusbphyc_phy->tune |= HSDRVDCCUR;\n\t\t\t} else if (val > 0) {\t\t \n\t\t\t\tval = (val == DC_PLUS_10_TO_14_MV) ? 1 : 0;\n\t\t\t\tusbphyc_phy->tune |= HSDRVCURINCR | FIELD_PREP(HSDRVDCLEV, val);\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(usbphyc->dev, \"phy%d: invalid st,tune-hs-dc-level\\n\", index);\n\t\t}\n\t}\n\n\tif (of_property_read_bool(np, \"st,enable-fs-rftime-tuning\"))\n\t\tusbphyc_phy->tune |= FSDRVRFADJ;\n\n\tif (of_property_read_bool(np, \"st,enable-hs-rftime-reduction\"))\n\t\tusbphyc_phy->tune |= HSDRVRFRED;\n\n\tret = of_property_read_u32(np, \"st,trim-hs-current\", &val);\n\tif (ret != -EINVAL) {\n\t\tif (!ret && val < CUR_MAX)\n\t\t\tusbphyc_phy->tune |= FIELD_PREP(HSDRVCHKITRM, val);\n\t\telse\n\t\t\tdev_warn(usbphyc->dev, \"phy%d: invalid st,trim-hs-current\\n\", index);\n\t}\n\n\tret = of_property_read_u32(np, \"st,trim-hs-impedance\", &val);\n\tif (ret != -EINVAL) {\n\t\tif (!ret && val < IMP_MAX)\n\t\t\tusbphyc_phy->tune |= FIELD_PREP(HSDRVCHKZTRM, val);\n\t\telse\n\t\t\tdev_warn(usbphyc->dev, \"phy%d: invalid st,trim-hs-impedance\\n\", index);\n\t}\n\n\tret = of_property_read_u32(np, \"st,tune-squelch-level\", &val);\n\tif (ret != -EINVAL) {\n\t\tif (!ret && val < SQLCH_MAX)\n\t\t\tusbphyc_phy->tune |= FIELD_PREP(SQLCHCTL, val);\n\t\telse\n\t\t\tdev_warn(usbphyc->dev, \"phy%d: invalid st,tune-squelch\\n\", index);\n\t}\n\n\tif (of_property_read_bool(np, \"st,enable-hs-rx-gain-eq\"))\n\t\tusbphyc_phy->tune |= HDRXGNEQEN;\n\n\tret = of_property_read_u32(np, \"st,tune-hs-rx-offset\", &val);\n\tif (ret != -EINVAL) {\n\t\tif (!ret && val < RX_OFFSET_MAX)\n\t\t\tusbphyc_phy->tune |= FIELD_PREP(HSRXOFF, val);\n\t\telse\n\t\t\tdev_warn(usbphyc->dev, \"phy%d: invalid st,tune-hs-rx-offset\\n\", index);\n\t}\n\n\tif (of_property_read_bool(np, \"st,no-hs-ftime-ctrl\"))\n\t\tusbphyc_phy->tune |= HSFALLPREEM;\n\n\tif (!of_property_read_bool(np, \"st,no-lsfs-sc\"))\n\t\tusbphyc_phy->tune |= SHTCCTCTLPROT;\n\n\tif (of_property_read_bool(np, \"st,enable-hs-tx-staggering\"))\n\t\tusbphyc_phy->tune |= STAGSEL;\n\n\t \n\tusbphyc_phy->tune |= FIELD_PREP(OTPCOMP, otpcomp);\n\n\t \n\twritel_relaxed(usbphyc_phy->tune, usbphyc->base + reg);\n}\n\nstatic void stm32_usbphyc_switch_setup(struct stm32_usbphyc *usbphyc,\n\t\t\t\t       u32 utmi_switch)\n{\n\tif (!utmi_switch)\n\t\tstm32_usbphyc_clr_bits(usbphyc->base + STM32_USBPHYC_MISC,\n\t\t\t\t       SWITHOST);\n\telse\n\t\tstm32_usbphyc_set_bits(usbphyc->base + STM32_USBPHYC_MISC,\n\t\t\t\t       SWITHOST);\n\tusbphyc->switch_setup = utmi_switch;\n}\n\nstatic struct phy *stm32_usbphyc_of_xlate(struct device *dev,\n\t\t\t\t\t  struct of_phandle_args *args)\n{\n\tstruct stm32_usbphyc *usbphyc = dev_get_drvdata(dev);\n\tstruct stm32_usbphyc_phy *usbphyc_phy = NULL;\n\tstruct device_node *phynode = args->np;\n\tint port = 0;\n\n\tfor (port = 0; port < usbphyc->nphys; port++) {\n\t\tif (phynode == usbphyc->phys[port]->phy->dev.of_node) {\n\t\t\tusbphyc_phy = usbphyc->phys[port];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!usbphyc_phy) {\n\t\tdev_err(dev, \"failed to find phy\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (((usbphyc_phy->index == 0) && (args->args_count != 0)) ||\n\t    ((usbphyc_phy->index == 1) && (args->args_count != 1))) {\n\t\tdev_err(dev, \"invalid number of cells for phy port%d\\n\",\n\t\t\tusbphyc_phy->index);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tif (usbphyc_phy->index == 1) {\n\t\tif (usbphyc->switch_setup < 0) {\n\t\t\tstm32_usbphyc_switch_setup(usbphyc, args->args[0]);\n\t\t} else {\n\t\t\tif (args->args[0] != usbphyc->switch_setup) {\n\t\t\t\tdev_err(dev, \"phy port1 already used\\n\");\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn usbphyc_phy->phy;\n}\n\nstatic int stm32_usbphyc_probe(struct platform_device *pdev)\n{\n\tstruct stm32_usbphyc *usbphyc;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child, *np = dev->of_node;\n\tstruct phy_provider *phy_provider;\n\tu32 pllen, version;\n\tint ret, port = 0;\n\n\tusbphyc = devm_kzalloc(dev, sizeof(*usbphyc), GFP_KERNEL);\n\tif (!usbphyc)\n\t\treturn -ENOMEM;\n\tusbphyc->dev = dev;\n\tdev_set_drvdata(dev, usbphyc);\n\n\tusbphyc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(usbphyc->base))\n\t\treturn PTR_ERR(usbphyc->base);\n\n\tusbphyc->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(usbphyc->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(usbphyc->clk), \"clk get_failed\\n\");\n\n\tret = clk_prepare_enable(usbphyc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"clk enable failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusbphyc->rst = devm_reset_control_get(dev, NULL);\n\tif (!IS_ERR(usbphyc->rst)) {\n\t\treset_control_assert(usbphyc->rst);\n\t\tudelay(2);\n\t\treset_control_deassert(usbphyc->rst);\n\t} else {\n\t\tret = PTR_ERR(usbphyc->rst);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto clk_disable;\n\n\t\tstm32_usbphyc_clr_bits(usbphyc->base + STM32_USBPHYC_PLL, PLLEN);\n\t}\n\n\t \n\tif (readl_relaxed_poll_timeout(usbphyc->base + STM32_USBPHYC_PLL,\n\t\t\t\t       pllen, !(pllen & PLLEN), 5, 50)) {\n\t\tdev_warn(usbphyc->dev, \"PLL not reset\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto clk_disable;\n\t}\n\n\tusbphyc->switch_setup = -EINVAL;\n\tusbphyc->nphys = of_get_child_count(np);\n\tusbphyc->phys = devm_kcalloc(dev, usbphyc->nphys,\n\t\t\t\t     sizeof(*usbphyc->phys), GFP_KERNEL);\n\tif (!usbphyc->phys) {\n\t\tret = -ENOMEM;\n\t\tgoto clk_disable;\n\t}\n\n\tusbphyc->vdda1v1 = devm_regulator_get(dev, \"vdda1v1\");\n\tif (IS_ERR(usbphyc->vdda1v1)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(usbphyc->vdda1v1),\n\t\t\t\t    \"failed to get vdda1v1 supply\\n\");\n\t\tgoto clk_disable;\n\t}\n\n\tusbphyc->vdda1v8 = devm_regulator_get(dev, \"vdda1v8\");\n\tif (IS_ERR(usbphyc->vdda1v8)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(usbphyc->vdda1v8),\n\t\t\t\t    \"failed to get vdda1v8 supply\\n\");\n\t\tgoto clk_disable;\n\t}\n\n\tfor_each_child_of_node(np, child) {\n\t\tstruct stm32_usbphyc_phy *usbphyc_phy;\n\t\tstruct phy *phy;\n\t\tu32 index;\n\n\t\tphy = devm_phy_create(dev, child, &stm32_usbphyc_phy_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tret = PTR_ERR(phy);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"failed to create phy%d: %d\\n\",\n\t\t\t\t\tport, ret);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tusbphyc_phy = devm_kzalloc(dev, sizeof(*usbphyc_phy),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!usbphyc_phy) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tret = of_property_read_u32(child, \"reg\", &index);\n\t\tif (ret || index > usbphyc->nphys) {\n\t\t\tdev_err(&phy->dev, \"invalid reg property: %d\\n\", ret);\n\t\t\tif (!ret)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tusbphyc->phys[port] = usbphyc_phy;\n\t\tphy_set_bus_width(phy, 8);\n\t\tphy_set_drvdata(phy, usbphyc_phy);\n\n\t\tusbphyc->phys[port]->phy = phy;\n\t\tusbphyc->phys[port]->usbphyc = usbphyc;\n\t\tusbphyc->phys[port]->index = index;\n\t\tusbphyc->phys[port]->active = false;\n\n\t\tusbphyc->phys[port]->vbus = devm_regulator_get_optional(&phy->dev, \"vbus\");\n\t\tif (IS_ERR(usbphyc->phys[port]->vbus)) {\n\t\t\tret = PTR_ERR(usbphyc->phys[port]->vbus);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\tgoto put_child;\n\t\t\tusbphyc->phys[port]->vbus = NULL;\n\t\t}\n\n\t\t \n\t\tstm32_usbphyc_phy_tuning(usbphyc, child, index);\n\n\t\tport++;\n\t}\n\n\tphy_provider = devm_of_phy_provider_register(dev,\n\t\t\t\t\t\t     stm32_usbphyc_of_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tret = PTR_ERR(phy_provider);\n\t\tdev_err(dev, \"failed to register phy provider: %d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\tret = stm32_usbphyc_clk48_register(usbphyc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register ck_usbo_48m clock: %d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\tversion = readl_relaxed(usbphyc->base + STM32_USBPHYC_VERSION);\n\tdev_info(dev, \"registered rev:%lu.%lu\\n\",\n\t\t FIELD_GET(MAJREV, version), FIELD_GET(MINREV, version));\n\n\treturn 0;\n\nput_child:\n\tof_node_put(child);\nclk_disable:\n\tclk_disable_unprepare(usbphyc->clk);\n\n\treturn ret;\n}\n\nstatic void stm32_usbphyc_remove(struct platform_device *pdev)\n{\n\tstruct stm32_usbphyc *usbphyc = dev_get_drvdata(&pdev->dev);\n\tint port;\n\n\t \n\tfor (port = 0; port < usbphyc->nphys; port++)\n\t\tif (usbphyc->phys[port]->active)\n\t\t\tstm32_usbphyc_phy_exit(usbphyc->phys[port]->phy);\n\n\tstm32_usbphyc_clk48_unregister(usbphyc);\n\n\tclk_disable_unprepare(usbphyc->clk);\n}\n\nstatic int __maybe_unused stm32_usbphyc_resume(struct device *dev)\n{\n\tstruct stm32_usbphyc *usbphyc = dev_get_drvdata(dev);\n\tstruct stm32_usbphyc_phy *usbphyc_phy;\n\tint port;\n\n\tif (usbphyc->switch_setup >= 0)\n\t\tstm32_usbphyc_switch_setup(usbphyc, usbphyc->switch_setup);\n\n\tfor (port = 0; port < usbphyc->nphys; port++) {\n\t\tusbphyc_phy = usbphyc->phys[port];\n\t\twritel_relaxed(usbphyc_phy->tune, usbphyc->base + STM32_USBPHYC_TUNE(port));\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(stm32_usbphyc_pm_ops, NULL, stm32_usbphyc_resume);\n\nstatic const struct of_device_id stm32_usbphyc_of_match[] = {\n\t{ .compatible = \"st,stm32mp1-usbphyc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, stm32_usbphyc_of_match);\n\nstatic struct platform_driver stm32_usbphyc_driver = {\n\t.probe = stm32_usbphyc_probe,\n\t.remove_new = stm32_usbphyc_remove,\n\t.driver = {\n\t\t.of_match_table = stm32_usbphyc_of_match,\n\t\t.name = \"stm32-usbphyc\",\n\t\t.pm = &stm32_usbphyc_pm_ops,\n\t}\n};\nmodule_platform_driver(stm32_usbphyc_driver);\n\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 USBPHYC driver\");\nMODULE_AUTHOR(\"Amelie Delaunay <amelie.delaunay@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}