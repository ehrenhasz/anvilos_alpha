{
  "module_name": "phy-miphy28lp.c",
  "hash_id": "ff73e352fb4ea4af13e8ea0538cede35555776a6c3f845d44330467f92920a5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/st/phy-miphy28lp.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/clk.h>\n#include <linux/phy/phy.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <dt-bindings/phy/phy.h>\n\n \n#define MIPHY_CONF_RESET\t\t0x00\n#define RST_APPLI_SW\t\tBIT(0)\n#define RST_CONF_SW\t\tBIT(1)\n#define RST_MACRO_SW\t\tBIT(2)\n\n#define MIPHY_RESET\t\t\t0x01\n#define RST_PLL_SW\t\tBIT(0)\n#define RST_COMP_SW\t\tBIT(2)\n\n#define MIPHY_STATUS_1\t\t\t0x02\n#define PHY_RDY\t\t\tBIT(0)\n#define HFC_RDY\t\t\tBIT(1)\n#define HFC_PLL\t\t\tBIT(2)\n\n#define MIPHY_CONTROL\t\t\t0x04\n#define TERM_EN_SW\t\tBIT(2)\n#define DIS_LINK_RST\t\tBIT(3)\n#define AUTO_RST_RX\t\tBIT(4)\n#define PX_RX_POL\t\tBIT(5)\n\n#define MIPHY_BOUNDARY_SEL\t\t0x0a\n#define TX_SEL\t\t\tBIT(6)\n#define SSC_SEL\t\t\tBIT(4)\n#define GENSEL_SEL\t\tBIT(0)\n\n#define MIPHY_BOUNDARY_1\t\t0x0b\n#define MIPHY_BOUNDARY_2\t\t0x0c\n#define SSC_EN_SW\t\tBIT(2)\n\n#define MIPHY_PLL_CLKREF_FREQ\t\t0x0d\n#define MIPHY_SPEED\t\t\t0x0e\n#define TX_SPDSEL_80DEC\t\t0\n#define TX_SPDSEL_40DEC\t\t1\n#define TX_SPDSEL_20DEC\t\t2\n#define RX_SPDSEL_80DEC\t\t0\n#define RX_SPDSEL_40DEC\t\t(1 << 2)\n#define RX_SPDSEL_20DEC\t\t(2 << 2)\n\n#define MIPHY_CONF\t\t\t0x0f\n#define MIPHY_CTRL_TEST_SEL\t\t0x20\n#define MIPHY_CTRL_TEST_1\t\t0x21\n#define MIPHY_CTRL_TEST_2\t\t0x22\n#define MIPHY_CTRL_TEST_3\t\t0x23\n#define MIPHY_CTRL_TEST_4\t\t0x24\n#define MIPHY_FEEDBACK_TEST\t\t0x25\n#define MIPHY_DEBUG_BUS\t\t\t0x26\n#define MIPHY_DEBUG_STATUS_MSB\t\t0x27\n#define MIPHY_DEBUG_STATUS_LSB\t\t0x28\n#define MIPHY_PWR_RAIL_1\t\t0x29\n#define MIPHY_PWR_RAIL_2\t\t0x2a\n#define MIPHY_SYNCHAR_CONTROL\t\t0x30\n\n#define MIPHY_COMP_FSM_1\t\t0x3a\n#define COMP_START\t\tBIT(6)\n\n#define MIPHY_COMP_FSM_6\t\t0x3f\n#define COMP_DONE\t\tBIT(7)\n\n#define MIPHY_COMP_POSTP\t\t0x42\n#define MIPHY_TX_CTRL_1\t\t\t0x49\n#define TX_REG_STEP_0V\t\t0\n#define TX_REG_STEP_P_25MV\t1\n#define TX_REG_STEP_P_50MV\t2\n#define TX_REG_STEP_N_25MV\t7\n#define TX_REG_STEP_N_50MV\t6\n#define TX_REG_STEP_N_75MV\t5\n\n#define MIPHY_TX_CTRL_2\t\t\t0x4a\n#define TX_SLEW_SW_40_PS\t0\n#define TX_SLEW_SW_80_PS\t1\n#define TX_SLEW_SW_120_PS\t2\n\n#define MIPHY_TX_CTRL_3\t\t\t0x4b\n#define MIPHY_TX_CAL_MAN\t\t0x4e\n#define TX_SLEW_CAL_MAN_EN\tBIT(0)\n\n#define MIPHY_TST_BIAS_BOOST_2\t\t0x62\n#define MIPHY_BIAS_BOOST_1\t\t0x63\n#define MIPHY_BIAS_BOOST_2\t\t0x64\n#define MIPHY_RX_DESBUFF_FDB_2\t\t0x67\n#define MIPHY_RX_DESBUFF_FDB_3\t\t0x68\n#define MIPHY_SIGDET_COMPENS1\t\t0x69\n#define MIPHY_SIGDET_COMPENS2\t\t0x6a\n#define MIPHY_JITTER_PERIOD\t\t0x6b\n#define MIPHY_JITTER_AMPLITUDE_1\t0x6c\n#define MIPHY_JITTER_AMPLITUDE_2\t0x6d\n#define MIPHY_JITTER_AMPLITUDE_3\t0x6e\n#define MIPHY_RX_K_GAIN\t\t\t0x78\n#define MIPHY_RX_BUFFER_CTRL\t\t0x7a\n#define VGA_GAIN\t\tBIT(0)\n#define EQ_DC_GAIN\t\tBIT(2)\n#define EQ_BOOST_GAIN\t\tBIT(3)\n\n#define MIPHY_RX_VGA_GAIN\t\t0x7b\n#define MIPHY_RX_EQU_GAIN_1\t\t0x7f\n#define MIPHY_RX_EQU_GAIN_2\t\t0x80\n#define MIPHY_RX_EQU_GAIN_3\t\t0x81\n#define MIPHY_RX_CAL_CTRL_1\t\t0x97\n#define MIPHY_RX_CAL_CTRL_2\t\t0x98\n\n#define MIPHY_RX_CAL_OFFSET_CTRL\t0x99\n#define CAL_OFFSET_VGA_64\t(0x03 << 0)\n#define CAL_OFFSET_THRESHOLD_64\t(0x03 << 2)\n#define VGA_OFFSET_POLARITY\tBIT(4)\n#define OFFSET_COMPENSATION_EN\tBIT(6)\n\n#define MIPHY_RX_CAL_VGA_STEP\t\t0x9a\n#define MIPHY_RX_CAL_EYE_MIN\t\t0x9d\n#define MIPHY_RX_CAL_OPT_LENGTH\t\t0x9f\n#define MIPHY_RX_LOCK_CTRL_1\t\t0xc1\n#define MIPHY_RX_LOCK_SETTINGS_OPT\t0xc2\n#define MIPHY_RX_LOCK_STEP\t\t0xc4\n\n#define MIPHY_RX_SIGDET_SLEEP_OA\t0xc9\n#define MIPHY_RX_SIGDET_SLEEP_SEL\t0xca\n#define MIPHY_RX_SIGDET_WAIT_SEL\t0xcb\n#define MIPHY_RX_SIGDET_DATA_SEL\t0xcc\n#define EN_ULTRA_LOW_POWER\tBIT(0)\n#define EN_FIRST_HALF\t\tBIT(1)\n#define EN_SECOND_HALF\t\tBIT(2)\n#define EN_DIGIT_SIGNAL_CHECK\tBIT(3)\n\n#define MIPHY_RX_POWER_CTRL_1\t\t0xcd\n#define MIPHY_RX_POWER_CTRL_2\t\t0xce\n#define MIPHY_PLL_CALSET_CTRL\t\t0xd3\n#define MIPHY_PLL_CALSET_1\t\t0xd4\n#define MIPHY_PLL_CALSET_2\t\t0xd5\n#define MIPHY_PLL_CALSET_3\t\t0xd6\n#define MIPHY_PLL_CALSET_4\t\t0xd7\n#define MIPHY_PLL_SBR_1\t\t\t0xe3\n#define SET_NEW_CHANGE\t\tBIT(1)\n\n#define MIPHY_PLL_SBR_2\t\t\t0xe4\n#define MIPHY_PLL_SBR_3\t\t\t0xe5\n#define MIPHY_PLL_SBR_4\t\t\t0xe6\n#define MIPHY_PLL_COMMON_MISC_2\t\t0xe9\n#define START_ACT_FILT\t\tBIT(6)\n\n#define MIPHY_PLL_SPAREIN\t\t0xeb\n\n \n#define MIPHY_OSC_FORCE_EXT\tBIT(3)\n#define MIPHY_OSC_RDY\t\tBIT(5)\n\n#define MIPHY_CTRL_MASK\t\t0x0f\n#define MIPHY_CTRL_DEFAULT\t0\n#define MIPHY_CTRL_SYNC_D_EN\tBIT(2)\n\n \n#define SATA_CTRL_MASK\t\t0x07\n#define PCIE_CTRL_MASK\t\t0xff\n#define SATA_CTRL_SELECT_SATA\t1\n#define SATA_CTRL_SELECT_PCIE\t0\n#define SYSCFG_PCIE_PCIE_VAL\t0x80\n#define SATA_SPDMODE\t\t1\n\n#define MIPHY_SATA_BANK_NB\t3\n#define MIPHY_PCIE_BANK_NB\t2\n\nenum {\n\tSYSCFG_CTRL,\n\tSYSCFG_STATUS,\n\tSYSCFG_PCI,\n\tSYSCFG_SATA,\n\tSYSCFG_REG_MAX,\n};\n\nstruct miphy28lp_phy {\n\tstruct phy *phy;\n\tstruct miphy28lp_dev *phydev;\n\tvoid __iomem *base;\n\tvoid __iomem *pipebase;\n\n\tbool osc_force_ext;\n\tbool osc_rdy;\n\tbool px_rx_pol_inv;\n\tbool ssc;\n\tbool tx_impedance;\n\n\tstruct reset_control *miphy_rst;\n\n\tu32 sata_gen;\n\n\t \n\tu32 syscfg_reg[SYSCFG_REG_MAX];\n\tu8 type;\n};\n\nstruct miphy28lp_dev {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mutex miphy_mutex;\n\tstruct miphy28lp_phy **phys;\n\tint nphys;\n};\n\nstruct miphy_initval {\n\tu16 reg;\n\tu16 val;\n};\n\nenum miphy_sata_gen { SATA_GEN1, SATA_GEN2, SATA_GEN3 };\n\nstatic char *PHY_TYPE_name[] = { \"sata-up\", \"pcie-up\", \"\", \"usb3-up\" };\n\nstruct pll_ratio {\n\tint clk_ref;\n\tint calset_1;\n\tint calset_2;\n\tint calset_3;\n\tint calset_4;\n\tint cal_ctrl;\n};\n\nstatic struct pll_ratio sata_pll_ratio = {\n\t.clk_ref = 0x1e,\n\t.calset_1 = 0xc8,\n\t.calset_2 = 0x00,\n\t.calset_3 = 0x00,\n\t.calset_4 = 0x00,\n\t.cal_ctrl = 0x00,\n};\n\nstatic struct pll_ratio pcie_pll_ratio = {\n\t.clk_ref = 0x1e,\n\t.calset_1 = 0xa6,\n\t.calset_2 = 0xaa,\n\t.calset_3 = 0xaa,\n\t.calset_4 = 0x00,\n\t.cal_ctrl = 0x00,\n};\n\nstatic struct pll_ratio usb3_pll_ratio = {\n\t.clk_ref = 0x1e,\n\t.calset_1 = 0xa6,\n\t.calset_2 = 0xaa,\n\t.calset_3 = 0xaa,\n\t.calset_4 = 0x04,\n\t.cal_ctrl = 0x00,\n};\n\nstruct miphy28lp_pll_gen {\n\tint bank;\n\tint speed;\n\tint bias_boost_1;\n\tint bias_boost_2;\n\tint tx_ctrl_1;\n\tint tx_ctrl_2;\n\tint tx_ctrl_3;\n\tint rx_k_gain;\n\tint rx_vga_gain;\n\tint rx_equ_gain_1;\n\tint rx_equ_gain_2;\n\tint rx_equ_gain_3;\n\tint rx_buff_ctrl;\n};\n\nstatic struct miphy28lp_pll_gen sata_pll_gen[] = {\n\t{\n\t\t.bank\t\t= 0x00,\n\t\t.speed\t\t= TX_SPDSEL_80DEC | RX_SPDSEL_80DEC,\n\t\t.bias_boost_1\t= 0x00,\n\t\t.bias_boost_2\t= 0xae,\n\t\t.tx_ctrl_2\t= 0x53,\n\t\t.tx_ctrl_3\t= 0x00,\n\t\t.rx_buff_ctrl\t= EQ_BOOST_GAIN | EQ_DC_GAIN | VGA_GAIN,\n\t\t.rx_vga_gain\t= 0x00,\n\t\t.rx_equ_gain_1\t= 0x7d,\n\t\t.rx_equ_gain_2\t= 0x56,\n\t\t.rx_equ_gain_3\t= 0x00,\n\t},\n\t{\n\t\t.bank\t\t= 0x01,\n\t\t.speed\t\t= TX_SPDSEL_40DEC | RX_SPDSEL_40DEC,\n\t\t.bias_boost_1\t= 0x00,\n\t\t.bias_boost_2\t= 0xae,\n\t\t.tx_ctrl_2\t= 0x72,\n\t\t.tx_ctrl_3\t= 0x20,\n\t\t.rx_buff_ctrl\t= EQ_BOOST_GAIN | EQ_DC_GAIN | VGA_GAIN,\n\t\t.rx_vga_gain\t= 0x00,\n\t\t.rx_equ_gain_1\t= 0x7d,\n\t\t.rx_equ_gain_2\t= 0x56,\n\t\t.rx_equ_gain_3\t= 0x00,\n\t},\n\t{\n\t\t.bank\t\t= 0x02,\n\t\t.speed\t\t= TX_SPDSEL_20DEC | RX_SPDSEL_20DEC,\n\t\t.bias_boost_1\t= 0x00,\n\t\t.bias_boost_2\t= 0xae,\n\t\t.tx_ctrl_2\t= 0xc0,\n\t\t.tx_ctrl_3\t= 0x20,\n\t\t.rx_buff_ctrl\t= EQ_BOOST_GAIN | EQ_DC_GAIN | VGA_GAIN,\n\t\t.rx_vga_gain\t= 0x00,\n\t\t.rx_equ_gain_1\t= 0x7d,\n\t\t.rx_equ_gain_2\t= 0x56,\n\t\t.rx_equ_gain_3\t= 0x00,\n\t},\n};\n\nstatic struct miphy28lp_pll_gen pcie_pll_gen[] = {\n\t{\n\t\t.bank\t\t= 0x00,\n\t\t.speed\t\t= TX_SPDSEL_40DEC | RX_SPDSEL_40DEC,\n\t\t.bias_boost_1\t= 0x00,\n\t\t.bias_boost_2\t= 0xa5,\n\t\t.tx_ctrl_1\t= TX_REG_STEP_N_25MV,\n\t\t.tx_ctrl_2\t= 0x71,\n\t\t.tx_ctrl_3\t= 0x60,\n\t\t.rx_k_gain\t= 0x98,\n\t\t.rx_buff_ctrl\t= EQ_BOOST_GAIN | EQ_DC_GAIN | VGA_GAIN,\n\t\t.rx_vga_gain\t= 0x00,\n\t\t.rx_equ_gain_1\t= 0x79,\n\t\t.rx_equ_gain_2\t= 0x56,\n\t},\n\t{\n\t\t.bank\t\t= 0x01,\n\t\t.speed\t\t= TX_SPDSEL_20DEC | RX_SPDSEL_20DEC,\n\t\t.bias_boost_1\t= 0x00,\n\t\t.bias_boost_2\t= 0xa5,\n\t\t.tx_ctrl_1\t= TX_REG_STEP_N_25MV,\n\t\t.tx_ctrl_2\t= 0x70,\n\t\t.tx_ctrl_3\t= 0x60,\n\t\t.rx_k_gain\t= 0xcc,\n\t\t.rx_buff_ctrl\t= EQ_BOOST_GAIN | EQ_DC_GAIN | VGA_GAIN,\n\t\t.rx_vga_gain\t= 0x00,\n\t\t.rx_equ_gain_1\t= 0x78,\n\t\t.rx_equ_gain_2\t= 0x07,\n\t},\n};\n\nstatic inline void miphy28lp_set_reset(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tu8 val;\n\n\t \n\twriteb_relaxed(RST_APPLI_SW, base + MIPHY_CONF_RESET);\n\n\tval = RST_APPLI_SW | RST_CONF_SW;\n\twriteb_relaxed(val, base + MIPHY_CONF_RESET);\n\n\twriteb_relaxed(RST_APPLI_SW, base + MIPHY_CONF_RESET);\n\n\t \n\tif (miphy_phy->type == PHY_TYPE_PCIE) {\n\t\tval = AUTO_RST_RX | TERM_EN_SW;\n\t\twriteb_relaxed(val, base + MIPHY_CONTROL);\n\t} else {\n\t\tval = AUTO_RST_RX | TERM_EN_SW | DIS_LINK_RST;\n\t\twriteb_relaxed(val, base + MIPHY_CONTROL);\n\t}\n}\n\nstatic inline void miphy28lp_pll_calibration(struct miphy28lp_phy *miphy_phy,\n\t\tstruct pll_ratio *pll_ratio)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tu8 val;\n\n\t \n\twriteb_relaxed(0x1d, base + MIPHY_PLL_SPAREIN);\n\twriteb_relaxed(pll_ratio->clk_ref, base + MIPHY_PLL_CLKREF_FREQ);\n\n\t \n\twriteb_relaxed(pll_ratio->calset_1, base + MIPHY_PLL_CALSET_1);\n\twriteb_relaxed(pll_ratio->calset_2, base + MIPHY_PLL_CALSET_2);\n\twriteb_relaxed(pll_ratio->calset_3, base + MIPHY_PLL_CALSET_3);\n\twriteb_relaxed(pll_ratio->calset_4, base + MIPHY_PLL_CALSET_4);\n\twriteb_relaxed(pll_ratio->cal_ctrl, base + MIPHY_PLL_CALSET_CTRL);\n\n\twriteb_relaxed(TX_SEL, base + MIPHY_BOUNDARY_SEL);\n\n\tval = (0x68 << 1) | TX_SLEW_CAL_MAN_EN;\n\twriteb_relaxed(val, base + MIPHY_TX_CAL_MAN);\n\n\tval = VGA_OFFSET_POLARITY | CAL_OFFSET_THRESHOLD_64 | CAL_OFFSET_VGA_64;\n\n\tif (miphy_phy->type != PHY_TYPE_SATA)\n\t\tval |= OFFSET_COMPENSATION_EN;\n\n\twriteb_relaxed(val, base + MIPHY_RX_CAL_OFFSET_CTRL);\n\n\tif (miphy_phy->type == PHY_TYPE_USB3) {\n\t\twriteb_relaxed(0x00, base + MIPHY_CONF);\n\t\twriteb_relaxed(0x70, base + MIPHY_RX_LOCK_STEP);\n\t\twriteb_relaxed(EN_FIRST_HALF, base + MIPHY_RX_SIGDET_SLEEP_OA);\n\t\twriteb_relaxed(EN_FIRST_HALF, base + MIPHY_RX_SIGDET_SLEEP_SEL);\n\t\twriteb_relaxed(EN_FIRST_HALF, base + MIPHY_RX_SIGDET_WAIT_SEL);\n\n\t\tval = EN_DIGIT_SIGNAL_CHECK | EN_FIRST_HALF;\n\t\twriteb_relaxed(val, base + MIPHY_RX_SIGDET_DATA_SEL);\n\t}\n\n}\n\nstatic inline void miphy28lp_sata_config_gen(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sata_pll_gen); i++) {\n\t\tstruct miphy28lp_pll_gen *gen = &sata_pll_gen[i];\n\n\t\t \n\t\twriteb_relaxed(gen->bank, base + MIPHY_CONF);\n\t\twriteb_relaxed(gen->speed, base + MIPHY_SPEED);\n\t\twriteb_relaxed(gen->bias_boost_1, base + MIPHY_BIAS_BOOST_1);\n\t\twriteb_relaxed(gen->bias_boost_2, base + MIPHY_BIAS_BOOST_2);\n\n\t\t \n\t\twriteb_relaxed(gen->tx_ctrl_2, base + MIPHY_TX_CTRL_2);\n\t\twriteb_relaxed(gen->tx_ctrl_3, base + MIPHY_TX_CTRL_3);\n\n\t\t \n\t\twriteb_relaxed(gen->rx_buff_ctrl, base + MIPHY_RX_BUFFER_CTRL);\n\t\twriteb_relaxed(gen->rx_vga_gain, base + MIPHY_RX_VGA_GAIN);\n\t\twriteb_relaxed(gen->rx_equ_gain_1, base + MIPHY_RX_EQU_GAIN_1);\n\t\twriteb_relaxed(gen->rx_equ_gain_2, base + MIPHY_RX_EQU_GAIN_2);\n\t\twriteb_relaxed(gen->rx_equ_gain_3, base + MIPHY_RX_EQU_GAIN_3);\n\t}\n}\n\nstatic inline void miphy28lp_pcie_config_gen(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pcie_pll_gen); i++) {\n\t\tstruct miphy28lp_pll_gen *gen = &pcie_pll_gen[i];\n\n\t\t \n\t\twriteb_relaxed(gen->bank, base + MIPHY_CONF);\n\t\twriteb_relaxed(gen->speed, base + MIPHY_SPEED);\n\t\twriteb_relaxed(gen->bias_boost_1, base + MIPHY_BIAS_BOOST_1);\n\t\twriteb_relaxed(gen->bias_boost_2, base + MIPHY_BIAS_BOOST_2);\n\n\t\t \n\t\twriteb_relaxed(gen->tx_ctrl_1, base + MIPHY_TX_CTRL_1);\n\t\twriteb_relaxed(gen->tx_ctrl_2, base + MIPHY_TX_CTRL_2);\n\t\twriteb_relaxed(gen->tx_ctrl_3, base + MIPHY_TX_CTRL_3);\n\n\t\twriteb_relaxed(gen->rx_k_gain, base + MIPHY_RX_K_GAIN);\n\n\t\t \n\t\twriteb_relaxed(gen->rx_buff_ctrl, base + MIPHY_RX_BUFFER_CTRL);\n\t\twriteb_relaxed(gen->rx_vga_gain, base + MIPHY_RX_VGA_GAIN);\n\t\twriteb_relaxed(gen->rx_equ_gain_1, base + MIPHY_RX_EQU_GAIN_1);\n\t\twriteb_relaxed(gen->rx_equ_gain_2, base + MIPHY_RX_EQU_GAIN_2);\n\t}\n}\n\nstatic inline int miphy28lp_wait_compensation(struct miphy28lp_phy *miphy_phy)\n{\n\tu8 val;\n\n\t \n\treturn readb_relaxed_poll_timeout(miphy_phy->base + MIPHY_COMP_FSM_6,\n\t\t\t\t\t  val, val & COMP_DONE, 1, 5 * USEC_PER_SEC);\n}\n\n\nstatic inline int miphy28lp_compensation(struct miphy28lp_phy *miphy_phy,\n\t\tstruct pll_ratio *pll_ratio)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\n\t \n\t \n\twriteb_relaxed(RST_PLL_SW | RST_COMP_SW, base + MIPHY_RESET);\n\n\twriteb_relaxed(0x00, base + MIPHY_PLL_COMMON_MISC_2);\n\twriteb_relaxed(pll_ratio->clk_ref, base + MIPHY_PLL_CLKREF_FREQ);\n\twriteb_relaxed(COMP_START, base + MIPHY_COMP_FSM_1);\n\n\tif (miphy_phy->type == PHY_TYPE_PCIE)\n\t\twriteb_relaxed(RST_PLL_SW, base + MIPHY_RESET);\n\n\twriteb_relaxed(0x00, base + MIPHY_RESET);\n\twriteb_relaxed(START_ACT_FILT, base + MIPHY_PLL_COMMON_MISC_2);\n\twriteb_relaxed(SET_NEW_CHANGE, base + MIPHY_PLL_SBR_1);\n\n\t \n\twriteb_relaxed(0x00, base + MIPHY_COMP_POSTP);\n\n\tif (miphy_phy->type == PHY_TYPE_PCIE)\n\t\treturn miphy28lp_wait_compensation(miphy_phy);\n\n\treturn 0;\n}\n\nstatic inline void miphy28_usb3_miphy_reset(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tu8 val;\n\n\t \n\twriteb_relaxed(RST_APPLI_SW, base + MIPHY_CONF_RESET);\n\twriteb_relaxed(0x00, base + MIPHY_CONF_RESET);\n\twriteb_relaxed(RST_COMP_SW, base + MIPHY_RESET);\n\n\tval = RST_COMP_SW | RST_PLL_SW;\n\twriteb_relaxed(val, base + MIPHY_RESET);\n\n\twriteb_relaxed(0x00, base + MIPHY_PLL_COMMON_MISC_2);\n\twriteb_relaxed(0x1e, base + MIPHY_PLL_CLKREF_FREQ);\n\twriteb_relaxed(COMP_START, base + MIPHY_COMP_FSM_1);\n\twriteb_relaxed(RST_PLL_SW, base + MIPHY_RESET);\n\twriteb_relaxed(0x00, base + MIPHY_RESET);\n\twriteb_relaxed(START_ACT_FILT, base + MIPHY_PLL_COMMON_MISC_2);\n\twriteb_relaxed(0x00, base + MIPHY_CONF);\n\twriteb_relaxed(0x00, base + MIPHY_BOUNDARY_1);\n\twriteb_relaxed(0x00, base + MIPHY_TST_BIAS_BOOST_2);\n\twriteb_relaxed(0x00, base + MIPHY_CONF);\n\twriteb_relaxed(SET_NEW_CHANGE, base + MIPHY_PLL_SBR_1);\n\twriteb_relaxed(0xa5, base + MIPHY_DEBUG_BUS);\n\twriteb_relaxed(0x00, base + MIPHY_CONF);\n}\n\nstatic void miphy_sata_tune_ssc(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tu8 val;\n\n\t \n\t \n\tval = readb_relaxed(base + MIPHY_BOUNDARY_2);\n\tval |= SSC_EN_SW;\n\twriteb_relaxed(val, base + MIPHY_BOUNDARY_2);\n\n\tval = readb_relaxed(base + MIPHY_BOUNDARY_SEL);\n\tval |= SSC_SEL;\n\twriteb_relaxed(val, base + MIPHY_BOUNDARY_SEL);\n\n\tfor (val = 0; val < MIPHY_SATA_BANK_NB; val++) {\n\t\twriteb_relaxed(val, base + MIPHY_CONF);\n\n\t\t \n\t\t \n\t\twriteb_relaxed(0x3c, base + MIPHY_PLL_SBR_2);\n\t\twriteb_relaxed(0x6c, base + MIPHY_PLL_SBR_3);\n\t\twriteb_relaxed(0x81, base + MIPHY_PLL_SBR_4);\n\n\t\t \n\t\twriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\n\n\t\t \n\t\twriteb_relaxed(SET_NEW_CHANGE, base + MIPHY_PLL_SBR_1);\n\n\t\t \n\t\twriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\n\t}\n}\n\nstatic void miphy_pcie_tune_ssc(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tu8 val;\n\n\t \n\t \n\tval = readb_relaxed(base + MIPHY_BOUNDARY_2);\n\tval |= SSC_EN_SW;\n\twriteb_relaxed(val, base + MIPHY_BOUNDARY_2);\n\n\tval = readb_relaxed(base + MIPHY_BOUNDARY_SEL);\n\tval |= SSC_SEL;\n\twriteb_relaxed(val, base + MIPHY_BOUNDARY_SEL);\n\n\tfor (val = 0; val < MIPHY_PCIE_BANK_NB; val++) {\n\t\twriteb_relaxed(val, base + MIPHY_CONF);\n\n\t\t \n\t\twriteb_relaxed(0x69, base + MIPHY_PLL_SBR_3);\n\t\twriteb_relaxed(0x21, base + MIPHY_PLL_SBR_4);\n\n\t\t \n\t\twriteb_relaxed(0x3c, base + MIPHY_PLL_SBR_2);\n\t\twriteb_relaxed(0x21, base + MIPHY_PLL_SBR_4);\n\n\t\t \n\t\twriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\n\n\t\t \n\t\twriteb_relaxed(SET_NEW_CHANGE, base + MIPHY_PLL_SBR_1);\n\n\t\t \n\t\twriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\n\t}\n}\n\nstatic inline void miphy_tune_tx_impedance(struct miphy28lp_phy *miphy_phy)\n{\n\t \n\twriteb_relaxed(0x02, miphy_phy->base + MIPHY_COMP_POSTP);\n}\n\nstatic inline int miphy28lp_configure_sata(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tint err;\n\tu8 val;\n\n\t \n\tmiphy28lp_set_reset(miphy_phy);\n\n\t \n\tmiphy28lp_pll_calibration(miphy_phy, &sata_pll_ratio);\n\n\t \n\tmiphy28lp_sata_config_gen(miphy_phy);\n\n\t \n\t \n\twriteb_relaxed(0x21, base + MIPHY_RX_POWER_CTRL_1);\n\n\t \n\twriteb_relaxed(0x00, base + MIPHY_CONF_RESET);\n\n\t \n\t \n\terr = miphy28lp_compensation(miphy_phy, &sata_pll_ratio);\n\tif (err)\n\t\treturn err;\n\n\tif (miphy_phy->px_rx_pol_inv) {\n\t\t \n\t\tval = readb_relaxed(miphy_phy->base + MIPHY_CONTROL);\n\t\tval |= PX_RX_POL;\n\t\twriteb_relaxed(val, miphy_phy->base + MIPHY_CONTROL);\n\t}\n\n\tif (miphy_phy->ssc)\n\t\tmiphy_sata_tune_ssc(miphy_phy);\n\n\tif (miphy_phy->tx_impedance)\n\t\tmiphy_tune_tx_impedance(miphy_phy);\n\n\treturn 0;\n}\n\nstatic inline int miphy28lp_configure_pcie(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tint err;\n\n\t \n\tmiphy28lp_set_reset(miphy_phy);\n\n\t \n\tmiphy28lp_pll_calibration(miphy_phy, &pcie_pll_ratio);\n\n\t \n\tmiphy28lp_pcie_config_gen(miphy_phy);\n\n\t \n\t \n\twriteb_relaxed(0x21, base + MIPHY_RX_POWER_CTRL_1);\n\n\t \n\twriteb_relaxed(0x00, base + MIPHY_CONF_RESET);\n\n\t \n\t \n\terr = miphy28lp_compensation(miphy_phy, &pcie_pll_ratio);\n\tif (err)\n\t\treturn err;\n\n\tif (miphy_phy->ssc)\n\t\tmiphy_pcie_tune_ssc(miphy_phy);\n\n\tif (miphy_phy->tx_impedance)\n\t\tmiphy_tune_tx_impedance(miphy_phy);\n\n\treturn 0;\n}\n\n\nstatic inline void miphy28lp_configure_usb3(struct miphy28lp_phy *miphy_phy)\n{\n\tvoid __iomem *base = miphy_phy->base;\n\tu8 val;\n\n\t \n\tmiphy28lp_set_reset(miphy_phy);\n\n\t \n\tmiphy28lp_pll_calibration(miphy_phy, &usb3_pll_ratio);\n\n\t \n\twriteb_relaxed(0x00, base + MIPHY_CONF);\n\n\tval = RX_SPDSEL_20DEC | TX_SPDSEL_20DEC;\n\twriteb_relaxed(val, base + MIPHY_SPEED);\n\n\t \n\twriteb_relaxed(0x1c, base + MIPHY_RX_LOCK_SETTINGS_OPT);\n\twriteb_relaxed(0x51, base + MIPHY_RX_CAL_CTRL_1);\n\twriteb_relaxed(0x70, base + MIPHY_RX_CAL_CTRL_2);\n\n\tval = OFFSET_COMPENSATION_EN | VGA_OFFSET_POLARITY |\n\t      CAL_OFFSET_THRESHOLD_64 | CAL_OFFSET_VGA_64;\n\twriteb_relaxed(val, base + MIPHY_RX_CAL_OFFSET_CTRL);\n\twriteb_relaxed(0x22, base + MIPHY_RX_CAL_VGA_STEP);\n\twriteb_relaxed(0x0e, base + MIPHY_RX_CAL_OPT_LENGTH);\n\n\tval = EQ_DC_GAIN | VGA_GAIN;\n\twriteb_relaxed(val, base + MIPHY_RX_BUFFER_CTRL);\n\twriteb_relaxed(0x78, base + MIPHY_RX_EQU_GAIN_1);\n\twriteb_relaxed(0x1b, base + MIPHY_SYNCHAR_CONTROL);\n\n\t \n\twriteb_relaxed(0x02, base + MIPHY_COMP_POSTP);\n\n\t \n\t \n\tval = SSC_SEL | GENSEL_SEL;\n\twriteb_relaxed(val, base + MIPHY_BOUNDARY_SEL);\n\n\t \n\twriteb_relaxed(0x00, base + MIPHY_BIAS_BOOST_1);\n\twriteb_relaxed(0xa7, base + MIPHY_BIAS_BOOST_2);\n\n\t \n\twriteb_relaxed(SSC_EN_SW, base + MIPHY_BOUNDARY_2);\n\n\t \n\twriteb_relaxed(0x00, base + MIPHY_CONF);\n\n\t \n\twriteb_relaxed(0x5a, base + MIPHY_PLL_SBR_3);\n\twriteb_relaxed(0xa0, base + MIPHY_PLL_SBR_4);\n\n\t \n\twriteb_relaxed(0x3c, base + MIPHY_PLL_SBR_2);\n\twriteb_relaxed(0xa1, base + MIPHY_PLL_SBR_4);\n\n\t \n\twriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\n\n\t \n\twriteb_relaxed(0x02, base + MIPHY_PLL_SBR_1);\n\n\t \n\twriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\n\n\t \n\twriteb_relaxed(0xca, base + MIPHY_RX_K_GAIN);\n\n\t \n\t \n\twriteb_relaxed(0x21, base + MIPHY_RX_POWER_CTRL_1);\n\twriteb_relaxed(0x29, base + MIPHY_RX_POWER_CTRL_1);\n\twriteb_relaxed(0x1a, base + MIPHY_RX_POWER_CTRL_2);\n\n\t \n\tmiphy28_usb3_miphy_reset(miphy_phy);\n}\n\nstatic inline int miphy_is_ready(struct miphy28lp_phy *miphy_phy)\n{\n\tu8 mask = HFC_PLL | HFC_RDY;\n\tu8 val;\n\n\t \n\tif (miphy_phy->type == PHY_TYPE_SATA)\n\t\tmask |= PHY_RDY;\n\n\treturn readb_relaxed_poll_timeout(miphy_phy->base + MIPHY_STATUS_1,\n\t\t\t\t\t  val, (val & mask) == mask, 1,\n\t\t\t\t\t  5 * USEC_PER_SEC);\n}\n\nstatic int miphy_osc_is_ready(struct miphy28lp_phy *miphy_phy)\n{\n\tstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\n\tu32 val;\n\n\tif (!miphy_phy->osc_rdy)\n\t\treturn 0;\n\n\tif (!miphy_phy->syscfg_reg[SYSCFG_STATUS])\n\t\treturn -EINVAL;\n\n\treturn regmap_read_poll_timeout(miphy_dev->regmap,\n\t\t\t\t\tmiphy_phy->syscfg_reg[SYSCFG_STATUS],\n\t\t\t\t\tval, val & MIPHY_OSC_RDY, 1,\n\t\t\t\t\t5 * USEC_PER_SEC);\n}\n\nstatic int miphy28lp_get_resource_byname(struct device_node *child,\n\t\t\t\t\t  char *rname, struct resource *res)\n{\n\tint index;\n\n\tindex = of_property_match_string(child, \"reg-names\", rname);\n\tif (index < 0)\n\t\treturn -ENODEV;\n\n\treturn of_address_to_resource(child, index, res);\n}\n\nstatic int miphy28lp_get_one_addr(struct device *dev,\n\t\t\t\t  struct device_node *child, char *rname,\n\t\t\t\t  void __iomem **base)\n{\n\tstruct resource res;\n\tint ret;\n\n\tret = miphy28lp_get_resource_byname(child, rname, &res);\n\tif (!ret) {\n\t\t*base = devm_ioremap(dev, res.start, resource_size(&res));\n\t\tif (!*base) {\n\t\t\tdev_err(dev, \"failed to ioremap %s address region\\n\"\n\t\t\t\t\t, rname);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int miphy28lp_setup(struct miphy28lp_phy *miphy_phy, u32 miphy_val)\n{\n\tint err;\n\tstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\n\n\tif (!miphy_phy->syscfg_reg[SYSCFG_CTRL])\n\t\treturn -EINVAL;\n\n\terr = reset_control_assert(miphy_phy->miphy_rst);\n\tif (err) {\n\t\tdev_err(miphy_dev->dev, \"unable to bring out of miphy reset\\n\");\n\t\treturn err;\n\t}\n\n\tif (miphy_phy->osc_force_ext)\n\t\tmiphy_val |= MIPHY_OSC_FORCE_EXT;\n\n\tregmap_update_bits(miphy_dev->regmap,\n\t\t\t   miphy_phy->syscfg_reg[SYSCFG_CTRL],\n\t\t\t   MIPHY_CTRL_MASK, miphy_val);\n\n\terr = reset_control_deassert(miphy_phy->miphy_rst);\n\tif (err) {\n\t\tdev_err(miphy_dev->dev, \"unable to bring out of miphy reset\\n\");\n\t\treturn err;\n\t}\n\n\treturn miphy_osc_is_ready(miphy_phy);\n}\n\nstatic int miphy28lp_init_sata(struct miphy28lp_phy *miphy_phy)\n{\n\tstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\n\tint err, sata_conf = SATA_CTRL_SELECT_SATA;\n\n\tif ((!miphy_phy->syscfg_reg[SYSCFG_SATA]) ||\n\t\t\t(!miphy_phy->syscfg_reg[SYSCFG_PCI]) ||\n\t\t\t(!miphy_phy->base))\n\t\treturn -EINVAL;\n\n\tdev_info(miphy_dev->dev, \"sata-up mode, addr 0x%p\\n\", miphy_phy->base);\n\n\t \n\tsata_conf |= ((miphy_phy->sata_gen - SATA_GEN1) << SATA_SPDMODE);\n\n\tregmap_update_bits(miphy_dev->regmap,\n\t\t\t   miphy_phy->syscfg_reg[SYSCFG_SATA],\n\t\t\t   SATA_CTRL_MASK, sata_conf);\n\n\tregmap_update_bits(miphy_dev->regmap, miphy_phy->syscfg_reg[SYSCFG_PCI],\n\t\t\t   PCIE_CTRL_MASK, SATA_CTRL_SELECT_PCIE);\n\n\t \n\terr = miphy28lp_setup(miphy_phy, MIPHY_CTRL_DEFAULT);\n\n\tif (err) {\n\t\tdev_err(miphy_dev->dev, \"SATA phy setup failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tmiphy28lp_configure_sata(miphy_phy);\n\n\treturn miphy_is_ready(miphy_phy);\n}\n\nstatic int miphy28lp_init_pcie(struct miphy28lp_phy *miphy_phy)\n{\n\tstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\n\tint err;\n\n\tif ((!miphy_phy->syscfg_reg[SYSCFG_SATA]) ||\n\t\t\t(!miphy_phy->syscfg_reg[SYSCFG_PCI])\n\t\t|| (!miphy_phy->base) || (!miphy_phy->pipebase))\n\t\treturn -EINVAL;\n\n\tdev_info(miphy_dev->dev, \"pcie-up mode, addr 0x%p\\n\", miphy_phy->base);\n\n\t \n\tregmap_update_bits(miphy_dev->regmap,\n\t\t\t   miphy_phy->syscfg_reg[SYSCFG_SATA],\n\t\t\t   SATA_CTRL_MASK, SATA_CTRL_SELECT_PCIE);\n\n\tregmap_update_bits(miphy_dev->regmap, miphy_phy->syscfg_reg[SYSCFG_PCI],\n\t\t\t   PCIE_CTRL_MASK, SYSCFG_PCIE_PCIE_VAL);\n\n\t \n\terr = miphy28lp_setup(miphy_phy, MIPHY_CTRL_DEFAULT);\n\n\tif (err) {\n\t\tdev_err(miphy_dev->dev, \"PCIe phy setup failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = miphy28lp_configure_pcie(miphy_phy);\n\tif (err)\n\t\treturn err;\n\n\t \n\twriteb_relaxed(0x68, miphy_phy->pipebase + 0x104);  \n\twriteb_relaxed(0x61, miphy_phy->pipebase + 0x105);  \n\twriteb_relaxed(0x68, miphy_phy->pipebase + 0x108);  \n\twriteb_relaxed(0x61, miphy_phy->pipebase + 0x109);  \n\twriteb_relaxed(0x68, miphy_phy->pipebase + 0x10c);  \n\twriteb_relaxed(0x60, miphy_phy->pipebase + 0x10d);  \n\n\t \n\treturn miphy_is_ready(miphy_phy);\n}\n\nstatic int miphy28lp_init_usb3(struct miphy28lp_phy *miphy_phy)\n{\n\tstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\n\tint err;\n\n\tif ((!miphy_phy->base) || (!miphy_phy->pipebase))\n\t\treturn -EINVAL;\n\n\tdev_info(miphy_dev->dev, \"usb3-up mode, addr 0x%p\\n\", miphy_phy->base);\n\n\t \n\terr = miphy28lp_setup(miphy_phy, MIPHY_CTRL_SYNC_D_EN);\n\tif (err) {\n\t\tdev_err(miphy_dev->dev, \"USB3 phy setup failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tmiphy28lp_configure_usb3(miphy_phy);\n\n\t \n\twriteb_relaxed(0x68, miphy_phy->pipebase + 0x23);\n\twriteb_relaxed(0x61, miphy_phy->pipebase + 0x24);\n\twriteb_relaxed(0x68, miphy_phy->pipebase + 0x26);\n\twriteb_relaxed(0x61, miphy_phy->pipebase + 0x27);\n\twriteb_relaxed(0x18, miphy_phy->pipebase + 0x29);\n\twriteb_relaxed(0x61, miphy_phy->pipebase + 0x2a);\n\n\t \n\twriteb_relaxed(0X67, miphy_phy->pipebase + 0x68);\n\twriteb_relaxed(0x0d, miphy_phy->pipebase + 0x69);\n\twriteb_relaxed(0X67, miphy_phy->pipebase + 0x6a);\n\twriteb_relaxed(0X0d, miphy_phy->pipebase + 0x6b);\n\twriteb_relaxed(0X67, miphy_phy->pipebase + 0x6c);\n\twriteb_relaxed(0X0d, miphy_phy->pipebase + 0x6d);\n\twriteb_relaxed(0X67, miphy_phy->pipebase + 0x6e);\n\twriteb_relaxed(0X0d, miphy_phy->pipebase + 0x6f);\n\n\treturn miphy_is_ready(miphy_phy);\n}\n\nstatic int miphy28lp_init(struct phy *phy)\n{\n\tstruct miphy28lp_phy *miphy_phy = phy_get_drvdata(phy);\n\tstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\n\tint ret;\n\n\tmutex_lock(&miphy_dev->miphy_mutex);\n\n\tswitch (miphy_phy->type) {\n\n\tcase PHY_TYPE_SATA:\n\t\tret = miphy28lp_init_sata(miphy_phy);\n\t\tbreak;\n\tcase PHY_TYPE_PCIE:\n\t\tret = miphy28lp_init_pcie(miphy_phy);\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\t\tret = miphy28lp_init_usb3(miphy_phy);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&miphy_dev->miphy_mutex);\n\n\treturn ret;\n}\n\nstatic int miphy28lp_get_addr(struct miphy28lp_phy *miphy_phy)\n{\n\tstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\n\tstruct device_node *phynode = miphy_phy->phy->dev.of_node;\n\tint err;\n\n\tif ((miphy_phy->type != PHY_TYPE_SATA) &&\n\t    (miphy_phy->type != PHY_TYPE_PCIE) &&\n\t    (miphy_phy->type != PHY_TYPE_USB3)) {\n\t\treturn -EINVAL;\n\t}\n\n\terr = miphy28lp_get_one_addr(miphy_dev->dev, phynode,\n\t\t\tPHY_TYPE_name[miphy_phy->type - PHY_TYPE_SATA],\n\t\t\t&miphy_phy->base);\n\tif (err)\n\t\treturn err;\n\n\tif ((miphy_phy->type == PHY_TYPE_PCIE) ||\n\t    (miphy_phy->type == PHY_TYPE_USB3)) {\n\t\terr = miphy28lp_get_one_addr(miphy_dev->dev, phynode, \"pipew\",\n\t\t\t\t\t     &miphy_phy->pipebase);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct phy *miphy28lp_xlate(struct device *dev,\n\t\t\t\t   struct of_phandle_args *args)\n{\n\tstruct miphy28lp_dev *miphy_dev = dev_get_drvdata(dev);\n\tstruct miphy28lp_phy *miphy_phy = NULL;\n\tstruct device_node *phynode = args->np;\n\tint ret, index = 0;\n\n\tif (args->args_count != 1) {\n\t\tdev_err(dev, \"Invalid number of cells in 'phy' property\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfor (index = 0; index < miphy_dev->nphys; index++)\n\t\tif (phynode == miphy_dev->phys[index]->phy->dev.of_node) {\n\t\t\tmiphy_phy = miphy_dev->phys[index];\n\t\t\tbreak;\n\t\t}\n\n\tif (!miphy_phy) {\n\t\tdev_err(dev, \"Failed to find appropriate phy\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmiphy_phy->type = args->args[0];\n\n\tret = miphy28lp_get_addr(miphy_phy);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn miphy_phy->phy;\n}\n\nstatic const struct phy_ops miphy28lp_ops = {\n\t.init = miphy28lp_init,\n\t.owner = THIS_MODULE,\n};\n\nstatic int miphy28lp_probe_resets(struct device_node *node,\n\t\t\t\t  struct miphy28lp_phy *miphy_phy)\n{\n\tstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\n\tint err;\n\n\tmiphy_phy->miphy_rst =\n\t\tof_reset_control_get_shared(node, \"miphy-sw-rst\");\n\n\tif (IS_ERR(miphy_phy->miphy_rst)) {\n\t\tdev_err(miphy_dev->dev,\n\t\t\t\t\"miphy soft reset control not defined\\n\");\n\t\treturn PTR_ERR(miphy_phy->miphy_rst);\n\t}\n\n\terr = reset_control_deassert(miphy_phy->miphy_rst);\n\tif (err) {\n\t\tdev_err(miphy_dev->dev, \"unable to bring out of miphy reset\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int miphy28lp_of_probe(struct device_node *np,\n\t\t\t      struct miphy28lp_phy *miphy_phy)\n{\n\tint i;\n\tu32 ctrlreg;\n\n\tmiphy_phy->osc_force_ext =\n\t\tof_property_read_bool(np, \"st,osc-force-ext\");\n\n\tmiphy_phy->osc_rdy = of_property_read_bool(np, \"st,osc-rdy\");\n\n\tmiphy_phy->px_rx_pol_inv =\n\t\tof_property_read_bool(np, \"st,px_rx_pol_inv\");\n\n\tmiphy_phy->ssc = of_property_read_bool(np, \"st,ssc-on\");\n\n\tmiphy_phy->tx_impedance =\n\t\tof_property_read_bool(np, \"st,tx-impedance-comp\");\n\n\tof_property_read_u32(np, \"st,sata-gen\", &miphy_phy->sata_gen);\n\tif (!miphy_phy->sata_gen)\n\t\tmiphy_phy->sata_gen = SATA_GEN1;\n\n\tfor (i = 0; i < SYSCFG_REG_MAX; i++) {\n\t\tif (!of_property_read_u32_index(np, \"st,syscfg\", i, &ctrlreg))\n\t\t\tmiphy_phy->syscfg_reg[i] = ctrlreg;\n\t}\n\n\treturn 0;\n}\n\nstatic int miphy28lp_probe(struct platform_device *pdev)\n{\n\tstruct device_node *child, *np = pdev->dev.of_node;\n\tstruct miphy28lp_dev *miphy_dev;\n\tstruct phy_provider *provider;\n\tstruct phy *phy;\n\tint ret, port = 0;\n\n\tmiphy_dev = devm_kzalloc(&pdev->dev, sizeof(*miphy_dev), GFP_KERNEL);\n\tif (!miphy_dev)\n\t\treturn -ENOMEM;\n\n\tmiphy_dev->nphys = of_get_child_count(np);\n\tmiphy_dev->phys = devm_kcalloc(&pdev->dev, miphy_dev->nphys,\n\t\t\t\t       sizeof(*miphy_dev->phys), GFP_KERNEL);\n\tif (!miphy_dev->phys)\n\t\treturn -ENOMEM;\n\n\tmiphy_dev->regmap = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(miphy_dev->regmap)) {\n\t\tdev_err(miphy_dev->dev, \"No syscfg phandle specified\\n\");\n\t\treturn PTR_ERR(miphy_dev->regmap);\n\t}\n\n\tmiphy_dev->dev = &pdev->dev;\n\n\tdev_set_drvdata(&pdev->dev, miphy_dev);\n\n\tmutex_init(&miphy_dev->miphy_mutex);\n\n\tfor_each_child_of_node(np, child) {\n\t\tstruct miphy28lp_phy *miphy_phy;\n\n\t\tmiphy_phy = devm_kzalloc(&pdev->dev, sizeof(*miphy_phy),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!miphy_phy) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tmiphy_dev->phys[port] = miphy_phy;\n\n\t\tphy = devm_phy_create(&pdev->dev, child, &miphy28lp_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(&pdev->dev, \"failed to create PHY\\n\");\n\t\t\tret = PTR_ERR(phy);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tmiphy_dev->phys[port]->phy = phy;\n\t\tmiphy_dev->phys[port]->phydev = miphy_dev;\n\n\t\tret = miphy28lp_of_probe(child, miphy_phy);\n\t\tif (ret)\n\t\t\tgoto put_child;\n\n\t\tret = miphy28lp_probe_resets(child, miphy_dev->phys[port]);\n\t\tif (ret)\n\t\t\tgoto put_child;\n\n\t\tphy_set_drvdata(phy, miphy_dev->phys[port]);\n\t\tport++;\n\n\t}\n\n\tprovider = devm_of_phy_provider_register(&pdev->dev, miphy28lp_xlate);\n\treturn PTR_ERR_OR_ZERO(provider);\nput_child:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic const struct of_device_id miphy28lp_of_match[] = {\n\t{.compatible = \"st,miphy28lp-phy\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, miphy28lp_of_match);\n\nstatic struct platform_driver miphy28lp_driver = {\n\t.probe = miphy28lp_probe,\n\t.driver = {\n\t\t.name = \"miphy28lp-phy\",\n\t\t.of_match_table = miphy28lp_of_match,\n\t}\n};\n\nmodule_platform_driver(miphy28lp_driver);\n\nMODULE_AUTHOR(\"Alexandre Torgue <alexandre.torgue@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics miphy28lp driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}