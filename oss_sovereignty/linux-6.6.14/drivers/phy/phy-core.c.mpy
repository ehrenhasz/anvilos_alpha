{
  "module_name": "phy-core.c",
  "hash_id": "4a6e97140561e0d7b76076a7992f929c8e519536227a4b8e7a2b270e3898dcb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/phy-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/idr.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\nstatic struct class *phy_class;\nstatic struct dentry *phy_debugfs_root;\nstatic DEFINE_MUTEX(phy_provider_mutex);\nstatic LIST_HEAD(phy_provider_list);\nstatic LIST_HEAD(phys);\nstatic DEFINE_IDA(phy_ida);\n\nstatic void devm_phy_release(struct device *dev, void *res)\n{\n\tstruct phy *phy = *(struct phy **)res;\n\n\tphy_put(dev, phy);\n}\n\nstatic void devm_phy_provider_release(struct device *dev, void *res)\n{\n\tstruct phy_provider *phy_provider = *(struct phy_provider **)res;\n\n\tof_phy_provider_unregister(phy_provider);\n}\n\nstatic void devm_phy_consume(struct device *dev, void *res)\n{\n\tstruct phy *phy = *(struct phy **)res;\n\n\tphy_destroy(phy);\n}\n\nstatic int devm_phy_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct phy **phy = res;\n\n\treturn *phy == match_data;\n}\n\n \nint phy_create_lookup(struct phy *phy, const char *con_id, const char *dev_id)\n{\n\tstruct phy_lookup *pl;\n\n\tif (!phy || !dev_id || !con_id)\n\t\treturn -EINVAL;\n\n\tpl = kzalloc(sizeof(*pl), GFP_KERNEL);\n\tif (!pl)\n\t\treturn -ENOMEM;\n\n\tpl->dev_id = dev_id;\n\tpl->con_id = con_id;\n\tpl->phy = phy;\n\n\tmutex_lock(&phy_provider_mutex);\n\tlist_add_tail(&pl->node, &phys);\n\tmutex_unlock(&phy_provider_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(phy_create_lookup);\n\n \nvoid phy_remove_lookup(struct phy *phy, const char *con_id, const char *dev_id)\n{\n\tstruct phy_lookup *pl;\n\n\tif (!phy || !dev_id || !con_id)\n\t\treturn;\n\n\tmutex_lock(&phy_provider_mutex);\n\tlist_for_each_entry(pl, &phys, node)\n\t\tif (pl->phy == phy && !strcmp(pl->dev_id, dev_id) &&\n\t\t    !strcmp(pl->con_id, con_id)) {\n\t\t\tlist_del(&pl->node);\n\t\t\tkfree(pl);\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&phy_provider_mutex);\n}\nEXPORT_SYMBOL_GPL(phy_remove_lookup);\n\nstatic struct phy *phy_find(struct device *dev, const char *con_id)\n{\n\tconst char *dev_id = dev_name(dev);\n\tstruct phy_lookup *p, *pl = NULL;\n\n\tmutex_lock(&phy_provider_mutex);\n\tlist_for_each_entry(p, &phys, node)\n\t\tif (!strcmp(p->dev_id, dev_id) && !strcmp(p->con_id, con_id)) {\n\t\t\tpl = p;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&phy_provider_mutex);\n\n\treturn pl ? pl->phy : ERR_PTR(-ENODEV);\n}\n\nstatic struct phy_provider *of_phy_provider_lookup(struct device_node *node)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device_node *child;\n\n\tlist_for_each_entry(phy_provider, &phy_provider_list, list) {\n\t\tif (phy_provider->dev->of_node == node)\n\t\t\treturn phy_provider;\n\n\t\tfor_each_child_of_node(phy_provider->children, child)\n\t\t\tif (child == node)\n\t\t\t\treturn phy_provider;\n\t}\n\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\n\nint phy_pm_runtime_get(struct phy *phy)\n{\n\tint ret;\n\n\tif (!phy)\n\t\treturn 0;\n\n\tif (!pm_runtime_enabled(&phy->dev))\n\t\treturn -ENOTSUPP;\n\n\tret = pm_runtime_get(&phy->dev);\n\tif (ret < 0 && ret != -EINPROGRESS)\n\t\tpm_runtime_put_noidle(&phy->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_pm_runtime_get);\n\nint phy_pm_runtime_get_sync(struct phy *phy)\n{\n\tint ret;\n\n\tif (!phy)\n\t\treturn 0;\n\n\tif (!pm_runtime_enabled(&phy->dev))\n\t\treturn -ENOTSUPP;\n\n\tret = pm_runtime_get_sync(&phy->dev);\n\tif (ret < 0)\n\t\tpm_runtime_put_sync(&phy->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_pm_runtime_get_sync);\n\nint phy_pm_runtime_put(struct phy *phy)\n{\n\tif (!phy)\n\t\treturn 0;\n\n\tif (!pm_runtime_enabled(&phy->dev))\n\t\treturn -ENOTSUPP;\n\n\treturn pm_runtime_put(&phy->dev);\n}\nEXPORT_SYMBOL_GPL(phy_pm_runtime_put);\n\nint phy_pm_runtime_put_sync(struct phy *phy)\n{\n\tif (!phy)\n\t\treturn 0;\n\n\tif (!pm_runtime_enabled(&phy->dev))\n\t\treturn -ENOTSUPP;\n\n\treturn pm_runtime_put_sync(&phy->dev);\n}\nEXPORT_SYMBOL_GPL(phy_pm_runtime_put_sync);\n\nvoid phy_pm_runtime_allow(struct phy *phy)\n{\n\tif (!phy)\n\t\treturn;\n\n\tif (!pm_runtime_enabled(&phy->dev))\n\t\treturn;\n\n\tpm_runtime_allow(&phy->dev);\n}\nEXPORT_SYMBOL_GPL(phy_pm_runtime_allow);\n\nvoid phy_pm_runtime_forbid(struct phy *phy)\n{\n\tif (!phy)\n\t\treturn;\n\n\tif (!pm_runtime_enabled(&phy->dev))\n\t\treturn;\n\n\tpm_runtime_forbid(&phy->dev);\n}\nEXPORT_SYMBOL_GPL(phy_pm_runtime_forbid);\n\n \nint phy_init(struct phy *phy)\n{\n\tint ret;\n\n\tif (!phy)\n\t\treturn 0;\n\n\tret = phy_pm_runtime_get_sync(phy);\n\tif (ret < 0 && ret != -ENOTSUPP)\n\t\treturn ret;\n\tret = 0;  \n\n\tmutex_lock(&phy->mutex);\n\tif (phy->power_count > phy->init_count)\n\t\tdev_warn(&phy->dev, \"phy_power_on was called before phy_init\\n\");\n\n\tif (phy->init_count == 0 && phy->ops->init) {\n\t\tret = phy->ops->init(phy);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&phy->dev, \"phy init failed --> %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t++phy->init_count;\n\nout:\n\tmutex_unlock(&phy->mutex);\n\tphy_pm_runtime_put(phy);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_init);\n\n \nint phy_exit(struct phy *phy)\n{\n\tint ret;\n\n\tif (!phy)\n\t\treturn 0;\n\n\tret = phy_pm_runtime_get_sync(phy);\n\tif (ret < 0 && ret != -ENOTSUPP)\n\t\treturn ret;\n\tret = 0;  \n\n\tmutex_lock(&phy->mutex);\n\tif (phy->init_count == 1 && phy->ops->exit) {\n\t\tret = phy->ops->exit(phy);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&phy->dev, \"phy exit failed --> %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t--phy->init_count;\n\nout:\n\tmutex_unlock(&phy->mutex);\n\tphy_pm_runtime_put(phy);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_exit);\n\n \nint phy_power_on(struct phy *phy)\n{\n\tint ret = 0;\n\n\tif (!phy)\n\t\tgoto out;\n\n\tif (phy->pwr) {\n\t\tret = regulator_enable(phy->pwr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = phy_pm_runtime_get_sync(phy);\n\tif (ret < 0 && ret != -ENOTSUPP)\n\t\tgoto err_pm_sync;\n\n\tret = 0;  \n\n\tmutex_lock(&phy->mutex);\n\tif (phy->power_count == 0 && phy->ops->power_on) {\n\t\tret = phy->ops->power_on(phy);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&phy->dev, \"phy poweron failed --> %d\\n\", ret);\n\t\t\tgoto err_pwr_on;\n\t\t}\n\t}\n\t++phy->power_count;\n\tmutex_unlock(&phy->mutex);\n\treturn 0;\n\nerr_pwr_on:\n\tmutex_unlock(&phy->mutex);\n\tphy_pm_runtime_put_sync(phy);\nerr_pm_sync:\n\tif (phy->pwr)\n\t\tregulator_disable(phy->pwr);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_power_on);\n\n \nint phy_power_off(struct phy *phy)\n{\n\tint ret;\n\n\tif (!phy)\n\t\treturn 0;\n\n\tmutex_lock(&phy->mutex);\n\tif (phy->power_count == 1 && phy->ops->power_off) {\n\t\tret =  phy->ops->power_off(phy);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&phy->dev, \"phy poweroff failed --> %d\\n\", ret);\n\t\t\tmutex_unlock(&phy->mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t--phy->power_count;\n\tmutex_unlock(&phy->mutex);\n\tphy_pm_runtime_put(phy);\n\n\tif (phy->pwr)\n\t\tregulator_disable(phy->pwr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(phy_power_off);\n\nint phy_set_mode_ext(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tint ret;\n\n\tif (!phy || !phy->ops->set_mode)\n\t\treturn 0;\n\n\tmutex_lock(&phy->mutex);\n\tret = phy->ops->set_mode(phy, mode, submode);\n\tif (!ret)\n\t\tphy->attrs.mode = mode;\n\tmutex_unlock(&phy->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_set_mode_ext);\n\nint phy_set_media(struct phy *phy, enum phy_media media)\n{\n\tint ret;\n\n\tif (!phy || !phy->ops->set_media)\n\t\treturn 0;\n\n\tmutex_lock(&phy->mutex);\n\tret = phy->ops->set_media(phy, media);\n\tmutex_unlock(&phy->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_set_media);\n\nint phy_set_speed(struct phy *phy, int speed)\n{\n\tint ret;\n\n\tif (!phy || !phy->ops->set_speed)\n\t\treturn 0;\n\n\tmutex_lock(&phy->mutex);\n\tret = phy->ops->set_speed(phy, speed);\n\tmutex_unlock(&phy->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_set_speed);\n\nint phy_reset(struct phy *phy)\n{\n\tint ret;\n\n\tif (!phy || !phy->ops->reset)\n\t\treturn 0;\n\n\tret = phy_pm_runtime_get_sync(phy);\n\tif (ret < 0 && ret != -ENOTSUPP)\n\t\treturn ret;\n\n\tmutex_lock(&phy->mutex);\n\tret = phy->ops->reset(phy);\n\tmutex_unlock(&phy->mutex);\n\n\tphy_pm_runtime_put(phy);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_reset);\n\n \nint phy_calibrate(struct phy *phy)\n{\n\tint ret;\n\n\tif (!phy || !phy->ops->calibrate)\n\t\treturn 0;\n\n\tmutex_lock(&phy->mutex);\n\tret = phy->ops->calibrate(phy);\n\tmutex_unlock(&phy->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_calibrate);\n\n \nint phy_configure(struct phy *phy, union phy_configure_opts *opts)\n{\n\tint ret;\n\n\tif (!phy)\n\t\treturn -EINVAL;\n\n\tif (!phy->ops->configure)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&phy->mutex);\n\tret = phy->ops->configure(phy, opts);\n\tmutex_unlock(&phy->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_configure);\n\n \nint phy_validate(struct phy *phy, enum phy_mode mode, int submode,\n\t\t union phy_configure_opts *opts)\n{\n\tint ret;\n\n\tif (!phy)\n\t\treturn -EINVAL;\n\n\tif (!phy->ops->validate)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&phy->mutex);\n\tret = phy->ops->validate(phy, mode, submode, opts);\n\tmutex_unlock(&phy->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_validate);\n\n \nstatic struct phy *_of_phy_get(struct device_node *np, int index)\n{\n\tint ret;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *phy = NULL;\n\tstruct of_phandle_args args;\n\n\tret = of_parse_phandle_with_args(np, \"phys\", \"#phy-cells\",\n\t\tindex, &args);\n\tif (ret)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tif (of_device_is_compatible(args.np, \"usb-nop-xceiv\"))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&phy_provider_mutex);\n\tphy_provider = of_phy_provider_lookup(args.np);\n\tif (IS_ERR(phy_provider) || !try_module_get(phy_provider->owner)) {\n\t\tphy = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto out_unlock;\n\t}\n\n\tif (!of_device_is_available(args.np)) {\n\t\tdev_warn(phy_provider->dev, \"Requested PHY is disabled\\n\");\n\t\tphy = ERR_PTR(-ENODEV);\n\t\tgoto out_put_module;\n\t}\n\n\tphy = phy_provider->of_xlate(phy_provider->dev, &args);\n\nout_put_module:\n\tmodule_put(phy_provider->owner);\n\nout_unlock:\n\tmutex_unlock(&phy_provider_mutex);\n\tof_node_put(args.np);\n\n\treturn phy;\n}\n\n \nstruct phy *of_phy_get(struct device_node *np, const char *con_id)\n{\n\tstruct phy *phy = NULL;\n\tint index = 0;\n\n\tif (con_id)\n\t\tindex = of_property_match_string(np, \"phy-names\", con_id);\n\n\tphy = _of_phy_get(np, index);\n\tif (IS_ERR(phy))\n\t\treturn phy;\n\n\tif (!try_module_get(phy->ops->owner))\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tget_device(&phy->dev);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(of_phy_get);\n\n \nvoid of_phy_put(struct phy *phy)\n{\n\tif (!phy || IS_ERR(phy))\n\t\treturn;\n\n\tmutex_lock(&phy->mutex);\n\tif (phy->ops->release)\n\t\tphy->ops->release(phy);\n\tmutex_unlock(&phy->mutex);\n\n\tmodule_put(phy->ops->owner);\n\tput_device(&phy->dev);\n}\nEXPORT_SYMBOL_GPL(of_phy_put);\n\n \nvoid phy_put(struct device *dev, struct phy *phy)\n{\n\tdevice_link_remove(dev, &phy->dev);\n\tof_phy_put(phy);\n}\nEXPORT_SYMBOL_GPL(phy_put);\n\n \nvoid devm_phy_put(struct device *dev, struct phy *phy)\n{\n\tint r;\n\n\tif (!phy)\n\t\treturn;\n\n\tr = devres_destroy(dev, devm_phy_release, devm_phy_match, phy);\n\tdev_WARN_ONCE(dev, r, \"couldn't find PHY resource\\n\");\n}\nEXPORT_SYMBOL_GPL(devm_phy_put);\n\n \nstruct phy *of_phy_simple_xlate(struct device *dev, struct of_phandle_args\n\t*args)\n{\n\tstruct phy *phy;\n\tstruct class_dev_iter iter;\n\n\tclass_dev_iter_init(&iter, phy_class, NULL, NULL);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tphy = to_phy(dev);\n\t\tif (args->np != phy->dev.of_node)\n\t\t\tcontinue;\n\n\t\tclass_dev_iter_exit(&iter);\n\t\treturn phy;\n\t}\n\n\tclass_dev_iter_exit(&iter);\n\treturn ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL_GPL(of_phy_simple_xlate);\n\n \nstruct phy *phy_get(struct device *dev, const char *string)\n{\n\tint index = 0;\n\tstruct phy *phy;\n\tstruct device_link *link;\n\n\tif (dev->of_node) {\n\t\tif (string)\n\t\t\tindex = of_property_match_string(dev->of_node, \"phy-names\",\n\t\t\t\tstring);\n\t\telse\n\t\t\tindex = 0;\n\t\tphy = _of_phy_get(dev->of_node, index);\n\t} else {\n\t\tif (string == NULL) {\n\t\t\tdev_WARN(dev, \"missing string\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tphy = phy_find(dev, string);\n\t}\n\tif (IS_ERR(phy))\n\t\treturn phy;\n\n\tif (!try_module_get(phy->ops->owner))\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tget_device(&phy->dev);\n\n\tlink = device_link_add(dev, &phy->dev, DL_FLAG_STATELESS);\n\tif (!link)\n\t\tdev_dbg(dev, \"failed to create device link to %s\\n\",\n\t\t\tdev_name(phy->dev.parent));\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(phy_get);\n\n \nstruct phy *devm_phy_get(struct device *dev, const char *string)\n{\n\tstruct phy **ptr, *phy;\n\n\tptr = devres_alloc(devm_phy_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy = phy_get(dev, string);\n\tif (!IS_ERR(phy)) {\n\t\t*ptr = phy;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_phy_get);\n\n \nstruct phy *devm_phy_optional_get(struct device *dev, const char *string)\n{\n\tstruct phy *phy = devm_phy_get(dev, string);\n\n\tif (PTR_ERR(phy) == -ENODEV)\n\t\tphy = NULL;\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_phy_optional_get);\n\n \nstruct phy *devm_of_phy_get(struct device *dev, struct device_node *np,\n\t\t\t    const char *con_id)\n{\n\tstruct phy **ptr, *phy;\n\tstruct device_link *link;\n\n\tptr = devres_alloc(devm_phy_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy = of_phy_get(np, con_id);\n\tif (!IS_ERR(phy)) {\n\t\t*ptr = phy;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t\treturn phy;\n\t}\n\n\tlink = device_link_add(dev, &phy->dev, DL_FLAG_STATELESS);\n\tif (!link)\n\t\tdev_dbg(dev, \"failed to create device link to %s\\n\",\n\t\t\tdev_name(phy->dev.parent));\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_of_phy_get);\n\n \nstruct phy *devm_of_phy_optional_get(struct device *dev, struct device_node *np,\n\t\t\t\t     const char *con_id)\n{\n\tstruct phy *phy = devm_of_phy_get(dev, np, con_id);\n\n\tif (PTR_ERR(phy) == -ENODEV)\n\t\tphy = NULL;\n\n\tif (IS_ERR(phy))\n\t\tdev_err_probe(dev, PTR_ERR(phy), \"failed to get PHY %pOF:%s\",\n\t\t\t      np, con_id);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_of_phy_optional_get);\n\n \nstruct phy *devm_of_phy_get_by_index(struct device *dev, struct device_node *np,\n\t\t\t\t     int index)\n{\n\tstruct phy **ptr, *phy;\n\tstruct device_link *link;\n\n\tptr = devres_alloc(devm_phy_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy = _of_phy_get(np, index);\n\tif (IS_ERR(phy)) {\n\t\tdevres_free(ptr);\n\t\treturn phy;\n\t}\n\n\tif (!try_module_get(phy->ops->owner)) {\n\t\tdevres_free(ptr);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tget_device(&phy->dev);\n\n\t*ptr = phy;\n\tdevres_add(dev, ptr);\n\n\tlink = device_link_add(dev, &phy->dev, DL_FLAG_STATELESS);\n\tif (!link)\n\t\tdev_dbg(dev, \"failed to create device link to %s\\n\",\n\t\t\tdev_name(phy->dev.parent));\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_of_phy_get_by_index);\n\n \nstruct phy *phy_create(struct device *dev, struct device_node *node,\n\t\t       const struct phy_ops *ops)\n{\n\tint ret;\n\tint id;\n\tstruct phy *phy;\n\n\tif (WARN_ON(!dev))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tphy = kzalloc(sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = ida_simple_get(&phy_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0) {\n\t\tdev_err(dev, \"unable to get id\\n\");\n\t\tret = id;\n\t\tgoto free_phy;\n\t}\n\n\tdevice_initialize(&phy->dev);\n\tmutex_init(&phy->mutex);\n\n\tphy->dev.class = phy_class;\n\tphy->dev.parent = dev;\n\tphy->dev.of_node = node ?: dev->of_node;\n\tphy->id = id;\n\tphy->ops = ops;\n\n\tret = dev_set_name(&phy->dev, \"phy-%s.%d\", dev_name(dev), id);\n\tif (ret)\n\t\tgoto put_dev;\n\n\t \n\tphy->pwr = regulator_get_optional(&phy->dev, \"phy\");\n\tif (IS_ERR(phy->pwr)) {\n\t\tret = PTR_ERR(phy->pwr);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto put_dev;\n\n\t\tphy->pwr = NULL;\n\t}\n\n\tret = device_add(&phy->dev);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tif (pm_runtime_enabled(dev)) {\n\t\tpm_runtime_enable(&phy->dev);\n\t\tpm_runtime_no_callbacks(&phy->dev);\n\t}\n\n\tphy->debugfs = debugfs_create_dir(dev_name(&phy->dev), phy_debugfs_root);\n\n\treturn phy;\n\nput_dev:\n\tput_device(&phy->dev);   \n\treturn ERR_PTR(ret);\n\nfree_phy:\n\tkfree(phy);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(phy_create);\n\n \nstruct phy *devm_phy_create(struct device *dev, struct device_node *node,\n\t\t\t    const struct phy_ops *ops)\n{\n\tstruct phy **ptr, *phy;\n\n\tptr = devres_alloc(devm_phy_consume, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy = phy_create(dev, node, ops);\n\tif (!IS_ERR(phy)) {\n\t\t*ptr = phy;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_phy_create);\n\n \nvoid phy_destroy(struct phy *phy)\n{\n\tpm_runtime_disable(&phy->dev);\n\tdevice_unregister(&phy->dev);\n}\nEXPORT_SYMBOL_GPL(phy_destroy);\n\n \nvoid devm_phy_destroy(struct device *dev, struct phy *phy)\n{\n\tint r;\n\n\tr = devres_destroy(dev, devm_phy_consume, devm_phy_match, phy);\n\tdev_WARN_ONCE(dev, r, \"couldn't find PHY resource\\n\");\n}\nEXPORT_SYMBOL_GPL(devm_phy_destroy);\n\n \nstruct phy_provider *__of_phy_provider_register(struct device *dev,\n\tstruct device_node *children, struct module *owner,\n\tstruct phy * (*of_xlate)(struct device *dev,\n\t\t\t\t struct of_phandle_args *args))\n{\n\tstruct phy_provider *phy_provider;\n\n\t \n\tif (children) {\n\t\tstruct device_node *parent = of_node_get(children), *next;\n\n\t\twhile (parent) {\n\t\t\tif (parent == dev->of_node)\n\t\t\t\tbreak;\n\n\t\t\tnext = of_get_parent(parent);\n\t\t\tof_node_put(parent);\n\t\t\tparent = next;\n\t\t}\n\n\t\tif (!parent)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tof_node_put(parent);\n\t} else {\n\t\tchildren = dev->of_node;\n\t}\n\n\tphy_provider = kzalloc(sizeof(*phy_provider), GFP_KERNEL);\n\tif (!phy_provider)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy_provider->dev = dev;\n\tphy_provider->children = of_node_get(children);\n\tphy_provider->owner = owner;\n\tphy_provider->of_xlate = of_xlate;\n\n\tmutex_lock(&phy_provider_mutex);\n\tlist_add_tail(&phy_provider->list, &phy_provider_list);\n\tmutex_unlock(&phy_provider_mutex);\n\n\treturn phy_provider;\n}\nEXPORT_SYMBOL_GPL(__of_phy_provider_register);\n\n \nstruct phy_provider *__devm_of_phy_provider_register(struct device *dev,\n\tstruct device_node *children, struct module *owner,\n\tstruct phy * (*of_xlate)(struct device *dev,\n\t\t\t\t struct of_phandle_args *args))\n{\n\tstruct phy_provider **ptr, *phy_provider;\n\n\tptr = devres_alloc(devm_phy_provider_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy_provider = __of_phy_provider_register(dev, children, owner,\n\t\t\t\t\t\t  of_xlate);\n\tif (!IS_ERR(phy_provider)) {\n\t\t*ptr = phy_provider;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn phy_provider;\n}\nEXPORT_SYMBOL_GPL(__devm_of_phy_provider_register);\n\n \nvoid of_phy_provider_unregister(struct phy_provider *phy_provider)\n{\n\tif (IS_ERR(phy_provider))\n\t\treturn;\n\n\tmutex_lock(&phy_provider_mutex);\n\tlist_del(&phy_provider->list);\n\tof_node_put(phy_provider->children);\n\tkfree(phy_provider);\n\tmutex_unlock(&phy_provider_mutex);\n}\nEXPORT_SYMBOL_GPL(of_phy_provider_unregister);\n\n \nvoid devm_of_phy_provider_unregister(struct device *dev,\n\tstruct phy_provider *phy_provider)\n{\n\tint r;\n\n\tr = devres_destroy(dev, devm_phy_provider_release, devm_phy_match,\n\t\tphy_provider);\n\tdev_WARN_ONCE(dev, r, \"couldn't find PHY provider device resource\\n\");\n}\nEXPORT_SYMBOL_GPL(devm_of_phy_provider_unregister);\n\n \nstatic void phy_release(struct device *dev)\n{\n\tstruct phy *phy;\n\n\tphy = to_phy(dev);\n\tdev_vdbg(dev, \"releasing '%s'\\n\", dev_name(dev));\n\tdebugfs_remove_recursive(phy->debugfs);\n\tregulator_put(phy->pwr);\n\tida_simple_remove(&phy_ida, phy->id);\n\tkfree(phy);\n}\n\nstatic int __init phy_core_init(void)\n{\n\tphy_class = class_create(\"phy\");\n\tif (IS_ERR(phy_class)) {\n\t\tpr_err(\"failed to create phy class --> %ld\\n\",\n\t\t\tPTR_ERR(phy_class));\n\t\treturn PTR_ERR(phy_class);\n\t}\n\n\tphy_class->dev_release = phy_release;\n\n\tphy_debugfs_root = debugfs_create_dir(\"phy\", NULL);\n\n\treturn 0;\n}\ndevice_initcall(phy_core_init);\n\nstatic void __exit phy_core_exit(void)\n{\n\tdebugfs_remove_recursive(phy_debugfs_root);\n\tclass_destroy(phy_class);\n}\nmodule_exit(phy_core_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}