{
  "module_name": "phy-xgene.c",
  "hash_id": "d72079500993080546f23af5966ee2084fb5982ea6eb6a0b0d95d93987814ce3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/phy-xgene.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/phy/phy.h>\n#include <linux/clk.h>\n\n \n#define MAX_LANE\t\t\t2\n\n \n#define SERDES_PLL_INDIRECT_OFFSET\t0x0000\n#define SERDES_PLL_REF_INDIRECT_OFFSET\t0x2000\n#define SERDES_INDIRECT_OFFSET\t\t0x0400\n#define SERDES_LANE_STRIDE\t\t0x0200\n\n \n#define DEFAULT_SATA_TXBOOST_GAIN\t{ 0x1e, 0x1e, 0x1e }\n#define DEFAULT_SATA_TXEYEDIRECTION\t{ 0x0, 0x0, 0x0 }\n#define DEFAULT_SATA_TXEYETUNING\t{ 0xa, 0xa, 0xa }\n#define DEFAULT_SATA_SPD_SEL\t\t{ 0x1, 0x3, 0x7 }\n#define DEFAULT_SATA_TXAMP\t\t{ 0x8, 0x8, 0x8 }\n#define DEFAULT_SATA_TXCN1\t\t{ 0x2, 0x2, 0x2 }\n#define DEFAULT_SATA_TXCN2\t\t{ 0x0, 0x0, 0x0 }\n#define DEFAULT_SATA_TXCP1\t\t{ 0xa, 0xa, 0xa }\n\n#define SATA_SPD_SEL_GEN3\t\t0x7\n#define SATA_SPD_SEL_GEN2\t\t0x3\n#define SATA_SPD_SEL_GEN1\t\t0x1\n\n#define SSC_DISABLE\t\t\t0\n#define SSC_ENABLE\t\t\t1\n\n#define FBDIV_VAL_50M\t\t\t0x77\n#define REFDIV_VAL_50M\t\t\t0x1\n#define FBDIV_VAL_100M\t\t\t0x3B\n#define REFDIV_VAL_100M\t\t\t0x0\n\n \n#define SATACLKENREG\t\t\t0x00000000\n#define  SATA0_CORE_CLKEN\t\t0x00000002\n#define  SATA1_CORE_CLKEN\t\t0x00000004\n#define SATASRESETREG\t\t\t0x00000004\n#define  SATA_MEM_RESET_MASK\t\t0x00000020\n#define  SATA_MEM_RESET_RD(src)\t\t(((src) & 0x00000020) >> 5)\n#define  SATA_SDS_RESET_MASK\t\t0x00000004\n#define  SATA_CSR_RESET_MASK\t\t0x00000001\n#define  SATA_CORE_RESET_MASK\t\t0x00000002\n#define  SATA_PMCLK_RESET_MASK\t\t0x00000010\n#define  SATA_PCLK_RESET_MASK\t\t0x00000008\n\n \n#define SATA_ENET_SDS_PCS_CTL0\t\t0x00000000\n#define  REGSPEC_CFG_I_TX_WORDMODE0_SET(dst, src) \\\n\t\t(((dst) & ~0x00070000) | (((u32) (src) << 16) & 0x00070000))\n#define  REGSPEC_CFG_I_RX_WORDMODE0_SET(dst, src) \\\n\t\t(((dst) & ~0x00e00000) | (((u32) (src) << 21) & 0x00e00000))\n#define SATA_ENET_SDS_CTL0\t\t0x0000000c\n#define  REGSPEC_CFG_I_CUSTOMER_PIN_MODE0_SET(dst, src) \\\n\t\t(((dst) & ~0x00007fff) | (((u32) (src)) & 0x00007fff))\n#define SATA_ENET_SDS_CTL1\t\t0x00000010\n#define  CFG_I_SPD_SEL_CDR_OVR1_SET(dst, src) \\\n\t\t(((dst) & ~0x0000000f) | (((u32) (src)) & 0x0000000f))\n#define SATA_ENET_SDS_RST_CTL\t\t0x00000024\n#define SATA_ENET_SDS_IND_CMD_REG\t0x0000003c\n#define  CFG_IND_WR_CMD_MASK\t\t0x00000001\n#define  CFG_IND_RD_CMD_MASK\t\t0x00000002\n#define  CFG_IND_CMD_DONE_MASK\t\t0x00000004\n#define  CFG_IND_ADDR_SET(dst, src) \\\n\t\t(((dst) & ~0x003ffff0) | (((u32) (src) << 4) & 0x003ffff0))\n#define SATA_ENET_SDS_IND_RDATA_REG\t0x00000040\n#define SATA_ENET_SDS_IND_WDATA_REG\t0x00000044\n#define SATA_ENET_CLK_MACRO_REG\t\t0x0000004c\n#define  I_RESET_B_SET(dst, src) \\\n\t\t(((dst) & ~0x00000001) | (((u32) (src)) & 0x00000001))\n#define  I_PLL_FBDIV_SET(dst, src) \\\n\t\t(((dst) & ~0x001ff000) | (((u32) (src) << 12) & 0x001ff000))\n#define  I_CUSTOMEROV_SET(dst, src) \\\n\t\t(((dst) & ~0x00000f80) | (((u32) (src) << 7) & 0x00000f80))\n#define  O_PLL_LOCK_RD(src)\t\t(((src) & 0x40000000) >> 30)\n#define  O_PLL_READY_RD(src)\t\t(((src) & 0x80000000) >> 31)\n\n \n#define CMU_REG0\t\t\t0x00000\n#define  CMU_REG0_PLL_REF_SEL_MASK\t0x00002000\n#define  CMU_REG0_PLL_REF_SEL_SET(dst, src)\t\\\n\t\t(((dst) & ~0x00002000) | (((u32) (src) << 13) & 0x00002000))\n#define  CMU_REG0_PDOWN_MASK\t\t0x00004000\n#define  CMU_REG0_CAL_COUNT_RESOL_SET(dst, src) \\\n\t\t(((dst) & ~0x000000e0) | (((u32) (src) << 5) & 0x000000e0))\n#define CMU_REG1\t\t\t0x00002\n#define  CMU_REG1_PLL_CP_SET(dst, src) \\\n\t\t(((dst) & ~0x00003c00) | (((u32) (src) << 10) & 0x00003c00))\n#define  CMU_REG1_PLL_MANUALCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x00000008) | (((u32) (src) << 3) & 0x00000008))\n#define  CMU_REG1_PLL_CP_SEL_SET(dst, src) \\\n\t\t(((dst) & ~0x000003e0) | (((u32) (src) << 5) & 0x000003e0))\n#define  CMU_REG1_REFCLK_CMOS_SEL_MASK\t0x00000001\n#define  CMU_REG1_REFCLK_CMOS_SEL_SET(dst, src)\t\\\n\t\t(((dst) & ~0x00000001) | (((u32) (src) << 0) & 0x00000001))\n#define CMU_REG2\t\t\t0x00004\n#define  CMU_REG2_PLL_REFDIV_SET(dst, src) \\\n\t\t(((dst) & ~0x0000c000) | (((u32) (src) << 14) & 0x0000c000))\n#define  CMU_REG2_PLL_LFRES_SET(dst, src) \\\n\t\t(((dst) & ~0x0000001e) | (((u32) (src) << 1) & 0x0000001e))\n#define  CMU_REG2_PLL_FBDIV_SET(dst, src) \\\n\t\t(((dst) & ~0x00003fe0) | (((u32) (src) << 5) & 0x00003fe0))\n#define CMU_REG3\t\t\t0x00006\n#define  CMU_REG3_VCOVARSEL_SET(dst, src) \\\n\t\t(((dst) & ~0x0000000f) | (((u32) (src) << 0) & 0x0000000f))\n#define  CMU_REG3_VCO_MOMSEL_INIT_SET(dst, src) \\\n\t\t(((dst) & ~0x000003f0) | (((u32) (src) << 4) & 0x000003f0))\n#define  CMU_REG3_VCO_MANMOMSEL_SET(dst, src) \\\n\t\t(((dst) & ~0x0000fc00) | (((u32) (src) << 10) & 0x0000fc00))\n#define CMU_REG4\t\t\t0x00008\n#define CMU_REG5\t\t\t0x0000a\n#define  CMU_REG5_PLL_LFSMCAP_SET(dst, src) \\\n\t\t(((dst) & ~0x0000c000) | (((u32) (src) << 14) & 0x0000c000))\n#define  CMU_REG5_PLL_LOCK_RESOLUTION_SET(dst, src) \\\n\t\t(((dst) & ~0x0000000e) | (((u32) (src) << 1) & 0x0000000e))\n#define  CMU_REG5_PLL_LFCAP_SET(dst, src) \\\n\t\t(((dst) & ~0x00003000) | (((u32) (src) << 12) & 0x00003000))\n#define  CMU_REG5_PLL_RESETB_MASK\t0x00000001\n#define CMU_REG6\t\t\t0x0000c\n#define  CMU_REG6_PLL_VREGTRIM_SET(dst, src) \\\n\t\t(((dst) & ~0x00000600) | (((u32) (src) << 9) & 0x00000600))\n#define  CMU_REG6_MAN_PVT_CAL_SET(dst, src) \\\n\t\t(((dst) & ~0x00000004) | (((u32) (src) << 2) & 0x00000004))\n#define CMU_REG7\t\t\t0x0000e\n#define  CMU_REG7_PLL_CALIB_DONE_RD(src) ((0x00004000 & (u32) (src)) >> 14)\n#define  CMU_REG7_VCO_CAL_FAIL_RD(src)\t((0x00000c00 & (u32) (src)) >> 10)\n#define CMU_REG8\t\t\t0x00010\n#define CMU_REG9\t\t\t0x00012\n#define  CMU_REG9_WORD_LEN_8BIT\t\t0x000\n#define  CMU_REG9_WORD_LEN_10BIT\t0x001\n#define  CMU_REG9_WORD_LEN_16BIT\t0x002\n#define  CMU_REG9_WORD_LEN_20BIT\t0x003\n#define  CMU_REG9_WORD_LEN_32BIT\t0x004\n#define  CMU_REG9_WORD_LEN_40BIT\t0x005\n#define  CMU_REG9_WORD_LEN_64BIT\t0x006\n#define  CMU_REG9_WORD_LEN_66BIT\t0x007\n#define  CMU_REG9_TX_WORD_MODE_CH1_SET(dst, src) \\\n\t\t(((dst) & ~0x00000380) | (((u32) (src) << 7) & 0x00000380))\n#define  CMU_REG9_TX_WORD_MODE_CH0_SET(dst, src) \\\n\t\t(((dst) & ~0x00000070) | (((u32) (src) << 4) & 0x00000070))\n#define  CMU_REG9_PLL_POST_DIVBY2_SET(dst, src) \\\n\t\t(((dst) & ~0x00000008) | (((u32) (src) << 3) & 0x00000008))\n#define  CMU_REG9_VBG_BYPASSB_SET(dst, src) \\\n\t\t(((dst) & ~0x00000004) | (((u32) (src) << 2) & 0x00000004))\n#define  CMU_REG9_IGEN_BYPASS_SET(dst, src) \\\n\t\t(((dst) & ~0x00000002) | (((u32) (src) << 1) & 0x00000002))\n#define CMU_REG10\t\t\t0x00014\n#define  CMU_REG10_VREG_REFSEL_SET(dst, src) \\\n\t\t(((dst) & ~0x00000001) | (((u32) (src) << 0) & 0x00000001))\n#define CMU_REG11\t\t\t0x00016\n#define CMU_REG12\t\t\t0x00018\n#define  CMU_REG12_STATE_DELAY9_SET(dst, src) \\\n\t\t(((dst) & ~0x000000f0) | (((u32) (src) << 4) & 0x000000f0))\n#define CMU_REG13\t\t\t0x0001a\n#define CMU_REG14\t\t\t0x0001c\n#define CMU_REG15\t\t\t0x0001e\n#define CMU_REG16\t\t\t0x00020\n#define  CMU_REG16_PVT_DN_MAN_ENA_MASK\t0x00000001\n#define  CMU_REG16_PVT_UP_MAN_ENA_MASK\t0x00000002\n#define  CMU_REG16_VCOCAL_WAIT_BTW_CODE_SET(dst, src) \\\n\t\t(((dst) & ~0x0000001c) | (((u32) (src) << 2) & 0x0000001c))\n#define  CMU_REG16_CALIBRATION_DONE_OVERRIDE_SET(dst, src) \\\n\t\t(((dst) & ~0x00000040) | (((u32) (src) << 6) & 0x00000040))\n#define  CMU_REG16_BYPASS_PLL_LOCK_SET(dst, src) \\\n\t\t(((dst) & ~0x00000020) | (((u32) (src) << 5) & 0x00000020))\n#define CMU_REG17\t\t\t0x00022\n#define  CMU_REG17_PVT_CODE_R2A_SET(dst, src) \\\n\t\t(((dst) & ~0x00007f00) | (((u32) (src) << 8) & 0x00007f00))\n#define  CMU_REG17_RESERVED_7_SET(dst, src) \\\n\t\t(((dst) & ~0x000000e0) | (((u32) (src) << 5) & 0x000000e0))\n#define  CMU_REG17_PVT_TERM_MAN_ENA_MASK\t0x00008000\n#define CMU_REG18\t\t\t0x00024\n#define CMU_REG19\t\t\t0x00026\n#define CMU_REG20\t\t\t0x00028\n#define CMU_REG21\t\t\t0x0002a\n#define CMU_REG22\t\t\t0x0002c\n#define CMU_REG23\t\t\t0x0002e\n#define CMU_REG24\t\t\t0x00030\n#define CMU_REG25\t\t\t0x00032\n#define CMU_REG26\t\t\t0x00034\n#define  CMU_REG26_FORCE_PLL_LOCK_SET(dst, src) \\\n\t\t(((dst) & ~0x00000001) | (((u32) (src) << 0) & 0x00000001))\n#define CMU_REG27\t\t\t0x00036\n#define CMU_REG28\t\t\t0x00038\n#define CMU_REG29\t\t\t0x0003a\n#define CMU_REG30\t\t\t0x0003c\n#define  CMU_REG30_LOCK_COUNT_SET(dst, src) \\\n\t\t(((dst) & ~0x00000006) | (((u32) (src) << 1) & 0x00000006))\n#define  CMU_REG30_PCIE_MODE_SET(dst, src) \\\n\t\t(((dst) & ~0x00000008) | (((u32) (src) << 3) & 0x00000008))\n#define CMU_REG31\t\t\t0x0003e\n#define CMU_REG32\t\t\t0x00040\n#define  CMU_REG32_FORCE_VCOCAL_START_MASK\t0x00004000\n#define  CMU_REG32_PVT_CAL_WAIT_SEL_SET(dst, src) \\\n\t\t(((dst) & ~0x00000006) | (((u32) (src) << 1) & 0x00000006))\n#define  CMU_REG32_IREF_ADJ_SET(dst, src) \\\n\t\t(((dst) & ~0x00000180) | (((u32) (src) << 7) & 0x00000180))\n#define CMU_REG33\t\t\t0x00042\n#define CMU_REG34\t\t\t0x00044\n#define  CMU_REG34_VCO_CAL_VTH_LO_MAX_SET(dst, src) \\\n\t\t(((dst) & ~0x0000000f) | (((u32) (src) << 0) & 0x0000000f))\n#define  CMU_REG34_VCO_CAL_VTH_HI_MAX_SET(dst, src) \\\n\t\t(((dst) & ~0x00000f00) | (((u32) (src) << 8) & 0x00000f00))\n#define  CMU_REG34_VCO_CAL_VTH_LO_MIN_SET(dst, src) \\\n\t\t(((dst) & ~0x000000f0) | (((u32) (src) << 4) & 0x000000f0))\n#define  CMU_REG34_VCO_CAL_VTH_HI_MIN_SET(dst, src) \\\n\t\t(((dst) & ~0x0000f000) | (((u32) (src) << 12) & 0x0000f000))\n#define CMU_REG35\t\t\t0x00046\n#define  CMU_REG35_PLL_SSC_MOD_SET(dst, src) \\\n\t\t(((dst) & ~0x0000fe00) | (((u32) (src) << 9) & 0x0000fe00))\n#define CMU_REG36\t\t\t\t0x00048\n#define  CMU_REG36_PLL_SSC_EN_SET(dst, src) \\\n\t\t(((dst) & ~0x00000010) | (((u32) (src) << 4) & 0x00000010))\n#define  CMU_REG36_PLL_SSC_VSTEP_SET(dst, src) \\\n\t\t(((dst) & ~0x0000ffc0) | (((u32) (src) << 6) & 0x0000ffc0))\n#define  CMU_REG36_PLL_SSC_DSMSEL_SET(dst, src) \\\n\t\t(((dst) & ~0x00000020) | (((u32) (src) << 5) & 0x00000020))\n#define CMU_REG37\t\t\t0x0004a\n#define CMU_REG38\t\t\t0x0004c\n#define CMU_REG39\t\t\t0x0004e\n\n \n#define RXTX_REG0\t\t\t0x000\n#define  RXTX_REG0_CTLE_EQ_HR_SET(dst, src) \\\n\t\t(((dst) & ~0x0000f800) | (((u32) (src) << 11) & 0x0000f800))\n#define  RXTX_REG0_CTLE_EQ_QR_SET(dst, src) \\\n\t\t(((dst) & ~0x000007c0) | (((u32) (src) << 6) & 0x000007c0))\n#define  RXTX_REG0_CTLE_EQ_FR_SET(dst, src) \\\n\t\t(((dst) & ~0x0000003e) | (((u32) (src) << 1) & 0x0000003e))\n#define RXTX_REG1\t\t\t0x002\n#define  RXTX_REG1_RXACVCM_SET(dst, src) \\\n\t\t(((dst) & ~0x0000f000) | (((u32) (src) << 12) & 0x0000f000))\n#define  RXTX_REG1_CTLE_EQ_SET(dst, src) \\\n\t\t(((dst) & ~0x00000f80) | (((u32) (src) << 7) & 0x00000f80))\n#define  RXTX_REG1_RXVREG1_SET(dst, src) \\\n\t\t(((dst) & ~0x00000060) | (((u32) (src) << 5) & 0x00000060))\n#define  RXTX_REG1_RXIREF_ADJ_SET(dst, src) \\\n\t\t(((dst) & ~0x00000006) | (((u32) (src) << 1) &  0x00000006))\n#define RXTX_REG2\t\t\t0x004\n#define  RXTX_REG2_VTT_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000100) | (((u32) (src) << 8) & 0x00000100))\n#define  RXTX_REG2_TX_FIFO_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000020) | (((u32) (src) << 5) & 0x00000020))\n#define  RXTX_REG2_VTT_SEL_SET(dst, src) \\\n\t\t(((dst) & ~0x000000c0) | (((u32) (src) << 6) & 0x000000c0))\n#define RXTX_REG4\t\t\t0x008\n#define  RXTX_REG4_TX_LOOPBACK_BUF_EN_MASK\t0x00000040\n#define  RXTX_REG4_TX_DATA_RATE_SET(dst, src) \\\n\t\t(((dst) & ~0x0000c000) | (((u32) (src) << 14) & 0x0000c000))\n#define  RXTX_REG4_TX_WORD_MODE_SET(dst, src) \\\n\t\t(((dst) & ~0x00003800) | (((u32) (src) << 11) & 0x00003800))\n#define RXTX_REG5\t\t\t0x00a\n#define  RXTX_REG5_TX_CN1_SET(dst, src) \\\n\t\t(((dst) & ~0x0000f800) | (((u32) (src) << 11) & 0x0000f800))\n#define  RXTX_REG5_TX_CP1_SET(dst, src) \\\n\t\t(((dst) & ~0x000007e0) | (((u32) (src) << 5) & 0x000007e0))\n#define  RXTX_REG5_TX_CN2_SET(dst, src) \\\n\t\t(((dst) & ~0x0000001f) | (((u32) (src) << 0) & 0x0000001f))\n#define RXTX_REG6\t\t\t0x00c\n#define  RXTX_REG6_TXAMP_CNTL_SET(dst, src) \\\n\t\t(((dst) & ~0x00000780) | (((u32) (src) << 7) & 0x00000780))\n#define  RXTX_REG6_TXAMP_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000040) | (((u32) (src) << 6) & 0x00000040))\n#define  RXTX_REG6_RX_BIST_ERRCNT_RD_SET(dst, src) \\\n\t\t(((dst) & ~0x00000001) | (((u32) (src) << 0) & 0x00000001))\n#define  RXTX_REG6_TX_IDLE_SET(dst, src) \\\n\t\t(((dst) & ~0x00000008) | (((u32) (src) << 3) & 0x00000008))\n#define  RXTX_REG6_RX_BIST_RESYNC_SET(dst, src) \\\n\t\t(((dst) & ~0x00000002) | (((u32) (src) << 1) & 0x00000002))\n#define RXTX_REG7\t\t\t0x00e\n#define  RXTX_REG7_RESETB_RXD_MASK\t0x00000100\n#define  RXTX_REG7_RESETB_RXA_MASK\t0x00000080\n#define  RXTX_REG7_BIST_ENA_RX_SET(dst, src) \\\n\t\t(((dst) & ~0x00000040) | (((u32) (src) << 6) & 0x00000040))\n#define  RXTX_REG7_RX_WORD_MODE_SET(dst, src) \\\n\t\t(((dst) & ~0x00003800) | (((u32) (src) << 11) & 0x00003800))\n#define RXTX_REG8\t\t\t0x010\n#define  RXTX_REG8_CDR_LOOP_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00004000) | (((u32) (src) << 14) & 0x00004000))\n#define  RXTX_REG8_CDR_BYPASS_RXLOS_SET(dst, src) \\\n\t\t(((dst) & ~0x00000800) | (((u32) (src) << 11) & 0x00000800))\n#define  RXTX_REG8_SSC_ENABLE_SET(dst, src) \\\n\t\t(((dst) & ~0x00000200) | (((u32) (src) << 9) & 0x00000200))\n#define  RXTX_REG8_SD_VREF_SET(dst, src) \\\n\t\t(((dst) & ~0x000000f0) | (((u32) (src) << 4) & 0x000000f0))\n#define  RXTX_REG8_SD_DISABLE_SET(dst, src) \\\n\t\t(((dst) & ~0x00000100) | (((u32) (src) << 8) & 0x00000100))\n#define RXTX_REG7\t\t\t0x00e\n#define  RXTX_REG7_RESETB_RXD_SET(dst, src) \\\n\t\t(((dst) & ~0x00000100) | (((u32) (src) << 8) & 0x00000100))\n#define  RXTX_REG7_RESETB_RXA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000080) | (((u32) (src) << 7) & 0x00000080))\n#define  RXTX_REG7_LOOP_BACK_ENA_CTLE_MASK\t0x00004000\n#define  RXTX_REG7_LOOP_BACK_ENA_CTLE_SET(dst, src) \\\n\t\t(((dst) & ~0x00004000) | (((u32) (src) << 14) & 0x00004000))\n#define RXTX_REG11\t\t\t0x016\n#define  RXTX_REG11_PHASE_ADJUST_LIMIT_SET(dst, src) \\\n\t\t(((dst) & ~0x0000f800) | (((u32) (src) << 11) & 0x0000f800))\n#define RXTX_REG12\t\t\t0x018\n#define  RXTX_REG12_LATCH_OFF_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00002000) | (((u32) (src) << 13) & 0x00002000))\n#define  RXTX_REG12_SUMOS_ENABLE_SET(dst, src) \\\n\t\t(((dst) & ~0x00000004) | (((u32) (src) << 2) & 0x00000004))\n#define  RXTX_REG12_RX_DET_TERM_ENABLE_MASK\t0x00000002\n#define  RXTX_REG12_RX_DET_TERM_ENABLE_SET(dst, src) \\\n\t\t(((dst) & ~0x00000002) | (((u32) (src) << 1) & 0x00000002))\n#define RXTX_REG13\t\t\t0x01a\n#define RXTX_REG14\t\t\t0x01c\n#define  RXTX_REG14_CLTE_LATCAL_MAN_PROG_SET(dst, src) \\\n\t\t(((dst) & ~0x0000003f) | (((u32) (src) << 0) & 0x0000003f))\n#define  RXTX_REG14_CTLE_LATCAL_MAN_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000040) | (((u32) (src) << 6) & 0x00000040))\n#define RXTX_REG26\t\t\t0x034\n#define  RXTX_REG26_PERIOD_ERROR_LATCH_SET(dst, src) \\\n\t\t(((dst) & ~0x00003800) | (((u32) (src) << 11) & 0x00003800))\n#define  RXTX_REG26_BLWC_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000008) | (((u32) (src) << 3) & 0x00000008))\n#define RXTX_REG21\t\t\t0x02a\n#define  RXTX_REG21_DO_LATCH_CALOUT_RD(src) ((0x0000fc00 & (u32) (src)) >> 10)\n#define  RXTX_REG21_XO_LATCH_CALOUT_RD(src) ((0x000003f0 & (u32) (src)) >> 4)\n#define  RXTX_REG21_LATCH_CAL_FAIL_ODD_RD(src)\t((0x0000000f & (u32)(src)))\n#define RXTX_REG22\t\t\t0x02c\n#define  RXTX_REG22_SO_LATCH_CALOUT_RD(src) ((0x000003f0 & (u32) (src)) >> 4)\n#define  RXTX_REG22_EO_LATCH_CALOUT_RD(src) ((0x0000fc00 & (u32) (src)) >> 10)\n#define  RXTX_REG22_LATCH_CAL_FAIL_EVEN_RD(src)\t((0x0000000f & (u32)(src)))\n#define RXTX_REG23\t\t\t0x02e\n#define  RXTX_REG23_DE_LATCH_CALOUT_RD(src) ((0x0000fc00 & (u32) (src)) >> 10)\n#define  RXTX_REG23_XE_LATCH_CALOUT_RD(src) ((0x000003f0 & (u32) (src)) >> 4)\n#define RXTX_REG24\t\t\t0x030\n#define  RXTX_REG24_EE_LATCH_CALOUT_RD(src) ((0x0000fc00 & (u32) (src)) >> 10)\n#define  RXTX_REG24_SE_LATCH_CALOUT_RD(src) ((0x000003f0 & (u32) (src)) >> 4)\n#define RXTX_REG27\t\t\t0x036\n#define RXTX_REG28\t\t\t0x038\n#define RXTX_REG31\t\t\t0x03e\n#define RXTX_REG38\t\t\t0x04c\n#define  RXTX_REG38_CUSTOMER_PINMODE_INV_SET(dst, src) \\\n\t\t(((dst) & 0x0000fffe) | (((u32) (src) << 1) & 0x0000fffe))\n#define RXTX_REG39\t\t\t0x04e\n#define RXTX_REG40\t\t\t0x050\n#define RXTX_REG41\t\t\t0x052\n#define RXTX_REG42\t\t\t0x054\n#define RXTX_REG43\t\t\t0x056\n#define RXTX_REG44\t\t\t0x058\n#define RXTX_REG45\t\t\t0x05a\n#define RXTX_REG46\t\t\t0x05c\n#define RXTX_REG47\t\t\t0x05e\n#define RXTX_REG48\t\t\t0x060\n#define RXTX_REG49\t\t\t0x062\n#define RXTX_REG50\t\t\t0x064\n#define RXTX_REG51\t\t\t0x066\n#define RXTX_REG52\t\t\t0x068\n#define RXTX_REG53\t\t\t0x06a\n#define RXTX_REG54\t\t\t0x06c\n#define RXTX_REG55\t\t\t0x06e\n#define RXTX_REG61\t\t\t0x07a\n#define  RXTX_REG61_ISCAN_INBERT_SET(dst, src) \\\n\t\t(((dst) & ~0x00000010) | (((u32) (src) << 4) & 0x00000010))\n#define  RXTX_REG61_LOADFREQ_SHIFT_SET(dst, src) \\\n\t\t(((dst) & ~0x00000008) | (((u32) (src) << 3) & 0x00000008))\n#define  RXTX_REG61_EYE_COUNT_WIDTH_SEL_SET(dst, src) \\\n\t\t(((dst) & ~0x000000c0) | (((u32) (src) << 6) & 0x000000c0))\n#define  RXTX_REG61_SPD_SEL_CDR_SET(dst, src) \\\n\t\t(((dst) & ~0x00003c00) | (((u32) (src) << 10) & 0x00003c00))\n#define RXTX_REG62\t\t\t0x07c\n#define  RXTX_REG62_PERIOD_H1_QLATCH_SET(dst, src) \\\n\t\t(((dst) & ~0x00003800) | (((u32) (src) << 11) & 0x00003800))\n#define RXTX_REG81\t\t\t0x0a2\n#define  RXTX_REG89_MU_TH7_SET(dst, src) \\\n\t\t(((dst) & ~0x0000f800) | (((u32) (src) << 11) & 0x0000f800))\n#define  RXTX_REG89_MU_TH8_SET(dst, src) \\\n\t\t(((dst) & ~0x000007c0) | (((u32) (src) << 6) & 0x000007c0))\n#define  RXTX_REG89_MU_TH9_SET(dst, src) \\\n\t\t(((dst) & ~0x0000003e) | (((u32) (src) << 1) & 0x0000003e))\n#define RXTX_REG96\t\t\t0x0c0\n#define  RXTX_REG96_MU_FREQ1_SET(dst, src) \\\n\t\t(((dst) & ~0x0000f800) | (((u32) (src) << 11) & 0x0000f800))\n#define  RXTX_REG96_MU_FREQ2_SET(dst, src) \\\n\t\t(((dst) & ~0x000007c0) | (((u32) (src) << 6) & 0x000007c0))\n#define  RXTX_REG96_MU_FREQ3_SET(dst, src) \\\n\t\t(((dst) & ~0x0000003e) | (((u32) (src) << 1) & 0x0000003e))\n#define RXTX_REG99\t\t\t0x0c6\n#define  RXTX_REG99_MU_PHASE1_SET(dst, src) \\\n\t\t(((dst) & ~0x0000f800) | (((u32) (src) << 11) & 0x0000f800))\n#define  RXTX_REG99_MU_PHASE2_SET(dst, src) \\\n\t\t(((dst) & ~0x000007c0) | (((u32) (src) << 6) & 0x000007c0))\n#define  RXTX_REG99_MU_PHASE3_SET(dst, src) \\\n\t\t(((dst) & ~0x0000003e) | (((u32) (src) << 1) & 0x0000003e))\n#define RXTX_REG102\t\t\t0x0cc\n#define  RXTX_REG102_FREQLOOP_LIMIT_SET(dst, src) \\\n\t\t(((dst) & ~0x00000060) | (((u32) (src) << 5) & 0x00000060))\n#define RXTX_REG114\t\t\t0x0e4\n#define RXTX_REG121\t\t\t0x0f2\n#define  RXTX_REG121_SUMOS_CAL_CODE_RD(src) ((0x0000003e & (u32)(src)) >> 0x1)\n#define RXTX_REG125\t\t\t0x0fa\n#define  RXTX_REG125_PQ_REG_SET(dst, src) \\\n\t\t(((dst) & ~0x0000fe00) | (((u32) (src) << 9) & 0x0000fe00))\n#define  RXTX_REG125_SIGN_PQ_SET(dst, src) \\\n\t\t(((dst) & ~0x00000100) | (((u32) (src) << 8) & 0x00000100))\n#define  RXTX_REG125_SIGN_PQ_2C_SET(dst, src) \\\n\t\t(((dst) & ~0x00000080) | (((u32) (src) << 7) & 0x00000080))\n#define  RXTX_REG125_PHZ_MANUALCODE_SET(dst, src) \\\n\t\t(((dst) & ~0x0000007c) | (((u32) (src) << 2) & 0x0000007c))\n#define  RXTX_REG125_PHZ_MANUAL_SET(dst, src) \\\n\t\t(((dst) & ~0x00000002) | (((u32) (src) << 1) & 0x00000002))\n#define RXTX_REG127\t\t\t0x0fe\n#define  RXTX_REG127_FORCE_SUM_CAL_START_MASK\t0x00000002\n#define  RXTX_REG127_FORCE_LAT_CAL_START_MASK\t0x00000004\n#define  RXTX_REG127_FORCE_SUM_CAL_START_SET(dst, src) \\\n\t\t(((dst) & ~0x00000002) | (((u32) (src) << 1) & 0x00000002))\n#define  RXTX_REG127_FORCE_LAT_CAL_START_SET(dst, src) \\\n\t\t(((dst) & ~0x00000004) | (((u32) (src) << 2) & 0x00000004))\n#define  RXTX_REG127_LATCH_MAN_CAL_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000008) | (((u32) (src) << 3) & 0x00000008))\n#define  RXTX_REG127_DO_LATCH_MANCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x0000fc00) | (((u32) (src) << 10) & 0x0000fc00))\n#define  RXTX_REG127_XO_LATCH_MANCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x000003f0) | (((u32) (src) << 4) & 0x000003f0))\n#define RXTX_REG128\t\t\t0x100\n#define  RXTX_REG128_LATCH_CAL_WAIT_SEL_SET(dst, src) \\\n\t\t(((dst) & ~0x0000000c) | (((u32) (src) << 2) & 0x0000000c))\n#define  RXTX_REG128_EO_LATCH_MANCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x0000fc00) | (((u32) (src) << 10) & 0x0000fc00))\n#define  RXTX_REG128_SO_LATCH_MANCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x000003f0) | (((u32) (src) << 4) & 0x000003f0))\n#define RXTX_REG129\t\t\t0x102\n#define  RXTX_REG129_DE_LATCH_MANCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x0000fc00) | (((u32) (src) << 10) & 0x0000fc00))\n#define  RXTX_REG129_XE_LATCH_MANCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x000003f0) | (((u32) (src) << 4) & 0x000003f0))\n#define RXTX_REG130\t\t\t0x104\n#define  RXTX_REG130_EE_LATCH_MANCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x0000fc00) | (((u32) (src) << 10) & 0x0000fc00))\n#define  RXTX_REG130_SE_LATCH_MANCAL_SET(dst, src) \\\n\t\t(((dst) & ~0x000003f0) | (((u32) (src) << 4) & 0x000003f0))\n#define RXTX_REG145\t\t\t0x122\n#define  RXTX_REG145_TX_IDLE_SATA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000001) | (((u32) (src) << 0) & 0x00000001))\n#define  RXTX_REG145_RXES_ENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000002) | (((u32) (src) << 1) & 0x00000002))\n#define  RXTX_REG145_RXDFE_CONFIG_SET(dst, src) \\\n\t\t(((dst) & ~0x0000c000) | (((u32) (src) << 14) & 0x0000c000))\n#define  RXTX_REG145_RXVWES_LATENA_SET(dst, src) \\\n\t\t(((dst) & ~0x00000004) | (((u32) (src) << 2) & 0x00000004))\n#define RXTX_REG147\t\t\t0x126\n#define RXTX_REG148\t\t\t0x128\n\n \nenum cmu_type_t {\n\tREF_CMU = 0,\t \n\tPHY_CMU = 1,\t \n};\n\nenum mux_type_t {\n\tMUX_SELECT_ATA = 0,\t \n\tMUX_SELECT_SGMMII = 0,\t \n};\n\nenum clk_type_t {\n\tCLK_EXT_DIFF = 0,\t \n\tCLK_INT_DIFF = 1,\t \n\tCLK_INT_SING = 2,\t \n};\n\nenum xgene_phy_mode {\n\tMODE_SATA\t= 0,\t \n\tMODE_SGMII\t= 1,\n\tMODE_PCIE\t= 2,\n\tMODE_USB\t= 3,\n\tMODE_XFI\t= 4,\n\tMODE_MAX\n};\n\nstruct xgene_sata_override_param {\n\tu32 speed[MAX_LANE];  \n\tu32 txspeed[3];\t\t\t \n\tu32 txboostgain[MAX_LANE*3];\t \n\tu32 txeyetuning[MAX_LANE*3];\t \n\tu32 txeyedirection[MAX_LANE*3];  \n\tu32 txamplitude[MAX_LANE*3];\t \n\tu32 txprecursor_cn1[MAX_LANE*3];  \n\tu32 txprecursor_cn2[MAX_LANE*3];  \n\tu32 txpostcursor_cp1[MAX_LANE*3];  \n};\n\nstruct xgene_phy_ctx {\n\tstruct device *dev;\n\tstruct phy *phy;\n\tenum xgene_phy_mode mode;\t\t \n\tenum clk_type_t clk_type;\t \n\tvoid __iomem *sds_base;\t\t \n\tstruct clk *clk;\t\t \n\n\t \n\tstruct xgene_sata_override_param sata_param;\n};\n\n \nstatic int preA3Chip;\nMODULE_PARM_DESC(preA3Chip, \"Enable pre-A3 chip support (1=enable 0=disable)\");\nmodule_param_named(preA3Chip, preA3Chip, int, 0444);\n\nstatic void sds_wr(void __iomem *csr_base, u32 indirect_cmd_reg,\n\t\t   u32 indirect_data_reg, u32 addr, u32 data)\n{\n\tunsigned long deadline = jiffies + HZ;\n\tu32 val;\n\tu32 cmd;\n\n\tcmd = CFG_IND_WR_CMD_MASK | CFG_IND_CMD_DONE_MASK;\n\tcmd = CFG_IND_ADDR_SET(cmd, addr);\n\twritel(data, csr_base + indirect_data_reg);\n\treadl(csr_base + indirect_data_reg);  \n\twritel(cmd, csr_base + indirect_cmd_reg);\n\treadl(csr_base + indirect_cmd_reg);  \n\tdo {\n\t\tval = readl(csr_base + indirect_cmd_reg);\n\t} while (!(val & CFG_IND_CMD_DONE_MASK) &&\n\t\t time_before(jiffies, deadline));\n\tif (!(val & CFG_IND_CMD_DONE_MASK))\n\t\tpr_err(\"SDS WR timeout at 0x%p offset 0x%08X value 0x%08X\\n\",\n\t\t       csr_base + indirect_cmd_reg, addr, data);\n}\n\nstatic void sds_rd(void __iomem *csr_base, u32 indirect_cmd_reg,\n\t\t   u32 indirect_data_reg, u32 addr, u32 *data)\n{\n\tunsigned long deadline = jiffies + HZ;\n\tu32 val;\n\tu32 cmd;\n\n\tcmd = CFG_IND_RD_CMD_MASK | CFG_IND_CMD_DONE_MASK;\n\tcmd = CFG_IND_ADDR_SET(cmd, addr);\n\twritel(cmd, csr_base + indirect_cmd_reg);\n\treadl(csr_base + indirect_cmd_reg);  \n\tdo {\n\t\tval = readl(csr_base + indirect_cmd_reg);\n\t} while (!(val & CFG_IND_CMD_DONE_MASK) &&\n\t\t time_before(jiffies, deadline));\n\t*data = readl(csr_base + indirect_data_reg);\n\tif (!(val & CFG_IND_CMD_DONE_MASK))\n\t\tpr_err(\"SDS WR timeout at 0x%p offset 0x%08X value 0x%08X\\n\",\n\t\t       csr_base + indirect_cmd_reg, addr, *data);\n}\n\nstatic void cmu_wr(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\n\t\t   u32 reg, u32 data)\n{\n\tvoid __iomem *sds_base = ctx->sds_base;\n\tu32 val;\n\n\tif (cmu_type == REF_CMU)\n\t\treg += SERDES_PLL_REF_INDIRECT_OFFSET;\n\telse\n\t\treg += SERDES_PLL_INDIRECT_OFFSET;\n\tsds_wr(sds_base, SATA_ENET_SDS_IND_CMD_REG,\n\t\tSATA_ENET_SDS_IND_WDATA_REG, reg, data);\n\tsds_rd(sds_base, SATA_ENET_SDS_IND_CMD_REG,\n\t\tSATA_ENET_SDS_IND_RDATA_REG, reg, &val);\n\tpr_debug(\"CMU WR addr 0x%X value 0x%08X <-> 0x%08X\\n\", reg, data, val);\n}\n\nstatic void cmu_rd(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\n\t\t   u32 reg, u32 *data)\n{\n\tvoid __iomem *sds_base = ctx->sds_base;\n\n\tif (cmu_type == REF_CMU)\n\t\treg += SERDES_PLL_REF_INDIRECT_OFFSET;\n\telse\n\t\treg += SERDES_PLL_INDIRECT_OFFSET;\n\tsds_rd(sds_base, SATA_ENET_SDS_IND_CMD_REG,\n\t\tSATA_ENET_SDS_IND_RDATA_REG, reg, data);\n\tpr_debug(\"CMU RD addr 0x%X value 0x%08X\\n\", reg, *data);\n}\n\nstatic void cmu_toggle1to0(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\n\t\t\t   u32 reg, u32 bits)\n{\n\tu32 val;\n\n\tcmu_rd(ctx, cmu_type, reg, &val);\n\tval |= bits;\n\tcmu_wr(ctx, cmu_type, reg, val);\n\tcmu_rd(ctx, cmu_type, reg, &val);\n\tval &= ~bits;\n\tcmu_wr(ctx, cmu_type, reg, val);\n}\n\nstatic void cmu_clrbits(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\n\t\t\tu32 reg, u32 bits)\n{\n\tu32 val;\n\n\tcmu_rd(ctx, cmu_type, reg, &val);\n\tval &= ~bits;\n\tcmu_wr(ctx, cmu_type, reg, val);\n}\n\nstatic void cmu_setbits(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\n\t\t\tu32 reg, u32 bits)\n{\n\tu32 val;\n\n\tcmu_rd(ctx, cmu_type, reg, &val);\n\tval |= bits;\n\tcmu_wr(ctx, cmu_type, reg, val);\n}\n\nstatic void serdes_wr(struct xgene_phy_ctx *ctx, int lane, u32 reg, u32 data)\n{\n\tvoid __iomem *sds_base = ctx->sds_base;\n\tu32 val;\n\n\treg += SERDES_INDIRECT_OFFSET;\n\treg += lane * SERDES_LANE_STRIDE;\n\tsds_wr(sds_base, SATA_ENET_SDS_IND_CMD_REG,\n\t       SATA_ENET_SDS_IND_WDATA_REG, reg, data);\n\tsds_rd(sds_base, SATA_ENET_SDS_IND_CMD_REG,\n\t       SATA_ENET_SDS_IND_RDATA_REG, reg, &val);\n\tpr_debug(\"SERDES WR addr 0x%X value 0x%08X <-> 0x%08X\\n\", reg, data,\n\t\t val);\n}\n\nstatic void serdes_rd(struct xgene_phy_ctx *ctx, int lane, u32 reg, u32 *data)\n{\n\tvoid __iomem *sds_base = ctx->sds_base;\n\n\treg += SERDES_INDIRECT_OFFSET;\n\treg += lane * SERDES_LANE_STRIDE;\n\tsds_rd(sds_base, SATA_ENET_SDS_IND_CMD_REG,\n\t       SATA_ENET_SDS_IND_RDATA_REG, reg, data);\n\tpr_debug(\"SERDES RD addr 0x%X value 0x%08X\\n\", reg, *data);\n}\n\nstatic void serdes_clrbits(struct xgene_phy_ctx *ctx, int lane, u32 reg,\n\t\t\t   u32 bits)\n{\n\tu32 val;\n\n\tserdes_rd(ctx, lane, reg, &val);\n\tval &= ~bits;\n\tserdes_wr(ctx, lane, reg, val);\n}\n\nstatic void serdes_setbits(struct xgene_phy_ctx *ctx, int lane, u32 reg,\n\t\t\t   u32 bits)\n{\n\tu32 val;\n\n\tserdes_rd(ctx, lane, reg, &val);\n\tval |= bits;\n\tserdes_wr(ctx, lane, reg, val);\n}\n\nstatic void xgene_phy_cfg_cmu_clk_type(struct xgene_phy_ctx *ctx,\n\t\t\t\t       enum cmu_type_t cmu_type,\n\t\t\t\t       enum clk_type_t clk_type)\n{\n\tu32 val;\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG12, &val);\n\tval = CMU_REG12_STATE_DELAY9_SET(val, 0x1);\n\tcmu_wr(ctx, cmu_type, CMU_REG12, val);\n\t \n\tcmu_wr(ctx, cmu_type, CMU_REG13, 0x0222);\n\tcmu_wr(ctx, cmu_type, CMU_REG14, 0x2225);\n\n\t \n\tif (clk_type == CLK_EXT_DIFF) {\n\t\t \n\t\tcmu_rd(ctx, cmu_type, CMU_REG0, &val);\n\t\tval = CMU_REG0_PLL_REF_SEL_SET(val, 0x0);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG0, val);\n\t\t \n\t\tcmu_rd(ctx, cmu_type, CMU_REG1, &val);\n\t\tval = CMU_REG1_REFCLK_CMOS_SEL_SET(val, 0x0);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG1, val);\n\t\tdev_dbg(ctx->dev, \"Set external reference clock\\n\");\n\t} else if (clk_type == CLK_INT_DIFF) {\n\t\t \n\t\tcmu_rd(ctx, cmu_type, CMU_REG0, &val);\n\t\tval = CMU_REG0_PLL_REF_SEL_SET(val, 0x1);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG0, val);\n\t\t \n\t\tcmu_rd(ctx, cmu_type, CMU_REG1, &val);\n\t\tval = CMU_REG1_REFCLK_CMOS_SEL_SET(val, 0x1);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG1, val);\n\t\tdev_dbg(ctx->dev, \"Set internal reference clock\\n\");\n\t} else if (clk_type == CLK_INT_SING) {\n\t\t \n\t\tcmu_rd(ctx, cmu_type, CMU_REG1, &val);\n\t\tval = CMU_REG1_REFCLK_CMOS_SEL_SET(val, 0x1);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG1, val);\n\t\t \n\t\tcmu_rd(ctx, cmu_type, CMU_REG1, &val);\n\t\tval = CMU_REG1_REFCLK_CMOS_SEL_SET(val, 0x0);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG1, val);\n\t\tdev_dbg(ctx->dev,\n\t\t\t\"Set internal single ended reference clock\\n\");\n\t}\n}\n\nstatic void xgene_phy_sata_cfg_cmu_core(struct xgene_phy_ctx *ctx,\n\t\t\t\t\tenum cmu_type_t cmu_type,\n\t\t\t\t\tenum clk_type_t clk_type)\n{\n\tu32 val;\n\tint ref_100MHz;\n\n\tif (cmu_type == REF_CMU) {\n\t\t \n\t\tcmu_rd(ctx, cmu_type, CMU_REG34, &val);\n\t\tval = CMU_REG34_VCO_CAL_VTH_LO_MAX_SET(val, 0x7);\n\t\tval = CMU_REG34_VCO_CAL_VTH_HI_MAX_SET(val, 0xc);\n\t\tval = CMU_REG34_VCO_CAL_VTH_LO_MIN_SET(val, 0x3);\n\t\tval = CMU_REG34_VCO_CAL_VTH_HI_MIN_SET(val, 0x8);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG34, val);\n\t}\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG0, &val);\n\tif (cmu_type == REF_CMU || preA3Chip)\n\t\tval = CMU_REG0_CAL_COUNT_RESOL_SET(val, 0x4);\n\telse\n\t\tval = CMU_REG0_CAL_COUNT_RESOL_SET(val, 0x7);\n\tcmu_wr(ctx, cmu_type, CMU_REG0, val);\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG1, &val);\n\tval = CMU_REG1_PLL_CP_SET(val, 0x1);\n\tif (cmu_type == REF_CMU || preA3Chip)\n\t\tval = CMU_REG1_PLL_CP_SEL_SET(val, 0x5);\n\telse\n\t\tval = CMU_REG1_PLL_CP_SEL_SET(val, 0x3);\n\tif (cmu_type == REF_CMU)\n\t\tval = CMU_REG1_PLL_MANUALCAL_SET(val, 0x0);\n\telse\n\t\tval = CMU_REG1_PLL_MANUALCAL_SET(val, 0x1);\n\tcmu_wr(ctx, cmu_type, CMU_REG1, val);\n\n\tif (cmu_type != REF_CMU)\n\t\tcmu_clrbits(ctx, cmu_type, CMU_REG5, CMU_REG5_PLL_RESETB_MASK);\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG2, &val);\n\tif (cmu_type == REF_CMU) {\n\t\tval = CMU_REG2_PLL_LFRES_SET(val, 0xa);\n\t\tref_100MHz = 1;\n\t} else {\n\t\tval = CMU_REG2_PLL_LFRES_SET(val, 0x3);\n\t\tif (clk_type == CLK_EXT_DIFF)\n\t\t\tref_100MHz = 0;\n\t\telse\n\t\t\tref_100MHz = 1;\n\t}\n\tif (ref_100MHz) {\n\t\tval = CMU_REG2_PLL_FBDIV_SET(val, FBDIV_VAL_100M);\n\t\tval = CMU_REG2_PLL_REFDIV_SET(val, REFDIV_VAL_100M);\n\t} else {\n\t\tval = CMU_REG2_PLL_FBDIV_SET(val, FBDIV_VAL_50M);\n\t\tval = CMU_REG2_PLL_REFDIV_SET(val, REFDIV_VAL_50M);\n\t}\n\tcmu_wr(ctx, cmu_type, CMU_REG2, val);\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG3, &val);\n\tif (cmu_type == REF_CMU) {\n\t\tval = CMU_REG3_VCOVARSEL_SET(val, 0x3);\n\t\tval = CMU_REG3_VCO_MOMSEL_INIT_SET(val, 0x10);\n\t} else {\n\t\tval = CMU_REG3_VCOVARSEL_SET(val, 0xF);\n\t\tif (preA3Chip)\n\t\t\tval = CMU_REG3_VCO_MOMSEL_INIT_SET(val, 0x15);\n\t\telse\n\t\t\tval = CMU_REG3_VCO_MOMSEL_INIT_SET(val, 0x1a);\n\t\tval = CMU_REG3_VCO_MANMOMSEL_SET(val, 0x15);\n\t}\n\tcmu_wr(ctx, cmu_type, CMU_REG3, val);\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG26, &val);\n\tval = CMU_REG26_FORCE_PLL_LOCK_SET(val, 0x0);\n\tcmu_wr(ctx, cmu_type, CMU_REG26, val);\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG5, &val);\n\tval = CMU_REG5_PLL_LFSMCAP_SET(val, 0x3);\n\tval = CMU_REG5_PLL_LFCAP_SET(val, 0x3);\n\tif (cmu_type == REF_CMU || !preA3Chip)\n\t\tval = CMU_REG5_PLL_LOCK_RESOLUTION_SET(val, 0x7);\n\telse\n\t\tval = CMU_REG5_PLL_LOCK_RESOLUTION_SET(val, 0x4);\n\tcmu_wr(ctx, cmu_type, CMU_REG5, val);\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG6, &val);\n\tval = CMU_REG6_PLL_VREGTRIM_SET(val, preA3Chip ? 0x0 : 0x2);\n\tval = CMU_REG6_MAN_PVT_CAL_SET(val, preA3Chip ? 0x1 : 0x0);\n\tcmu_wr(ctx, cmu_type, CMU_REG6, val);\n\n\t \n\tif (cmu_type == PHY_CMU) {\n\t\tcmu_rd(ctx, cmu_type, CMU_REG9, &val);\n\t\tval = CMU_REG9_TX_WORD_MODE_CH1_SET(val,\n\t\t\t\t\t\t    CMU_REG9_WORD_LEN_20BIT);\n\t\tval = CMU_REG9_TX_WORD_MODE_CH0_SET(val,\n\t\t\t\t\t\t    CMU_REG9_WORD_LEN_20BIT);\n\t\tval = CMU_REG9_PLL_POST_DIVBY2_SET(val, 0x1);\n\t\tif (!preA3Chip) {\n\t\t\tval = CMU_REG9_VBG_BYPASSB_SET(val, 0x0);\n\t\t\tval = CMU_REG9_IGEN_BYPASS_SET(val , 0x0);\n\t\t}\n\t\tcmu_wr(ctx, cmu_type, CMU_REG9, val);\n\n\t\tif (!preA3Chip) {\n\t\t\tcmu_rd(ctx, cmu_type, CMU_REG10, &val);\n\t\t\tval = CMU_REG10_VREG_REFSEL_SET(val, 0x1);\n\t\t\tcmu_wr(ctx, cmu_type, CMU_REG10, val);\n\t\t}\n\t}\n\n\tcmu_rd(ctx, cmu_type, CMU_REG16, &val);\n\tval = CMU_REG16_CALIBRATION_DONE_OVERRIDE_SET(val, 0x1);\n\tval = CMU_REG16_BYPASS_PLL_LOCK_SET(val, 0x1);\n\tif (cmu_type == REF_CMU || preA3Chip)\n\t\tval = CMU_REG16_VCOCAL_WAIT_BTW_CODE_SET(val, 0x4);\n\telse\n\t\tval = CMU_REG16_VCOCAL_WAIT_BTW_CODE_SET(val, 0x7);\n\tcmu_wr(ctx, cmu_type, CMU_REG16, val);\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG30, &val);\n\tval = CMU_REG30_PCIE_MODE_SET(val, 0x0);\n\tval = CMU_REG30_LOCK_COUNT_SET(val, 0x3);\n\tcmu_wr(ctx, cmu_type, CMU_REG30, val);\n\n\t \n\tcmu_wr(ctx, cmu_type, CMU_REG31, 0xF);\n\n\tcmu_rd(ctx, cmu_type, CMU_REG32, &val);\n\tval = CMU_REG32_PVT_CAL_WAIT_SEL_SET(val, 0x3);\n\tif (cmu_type == REF_CMU || preA3Chip)\n\t\tval = CMU_REG32_IREF_ADJ_SET(val, 0x3);\n\telse\n\t\tval = CMU_REG32_IREF_ADJ_SET(val, 0x1);\n\tcmu_wr(ctx, cmu_type, CMU_REG32, val);\n\n\t \n\tif (cmu_type != REF_CMU && preA3Chip)\n\t\tcmu_wr(ctx, cmu_type, CMU_REG34, 0x8d27);\n\telse\n\t\tcmu_wr(ctx, cmu_type, CMU_REG34, 0x873c);\n\n\t \n\tcmu_wr(ctx, cmu_type, CMU_REG37, 0xF00F);\n}\n\nstatic void xgene_phy_ssc_enable(struct xgene_phy_ctx *ctx,\n\t\t\t\t enum cmu_type_t cmu_type)\n{\n\tu32 val;\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG35, &val);\n\tval = CMU_REG35_PLL_SSC_MOD_SET(val, 98);\n\tcmu_wr(ctx, cmu_type, CMU_REG35, val);\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG36, &val);\n\tval = CMU_REG36_PLL_SSC_VSTEP_SET(val, 30);\n\tval = CMU_REG36_PLL_SSC_EN_SET(val, 1);\n\tval = CMU_REG36_PLL_SSC_DSMSEL_SET(val, 1);\n\tcmu_wr(ctx, cmu_type, CMU_REG36, val);\n\n\t \n\tcmu_clrbits(ctx, cmu_type, CMU_REG5, CMU_REG5_PLL_RESETB_MASK);\n\tcmu_setbits(ctx, cmu_type, CMU_REG5, CMU_REG5_PLL_RESETB_MASK);\n\n\t \n\tcmu_toggle1to0(ctx, cmu_type, CMU_REG32,\n\t\t       CMU_REG32_FORCE_VCOCAL_START_MASK);\n}\n\nstatic void xgene_phy_sata_cfg_lanes(struct xgene_phy_ctx *ctx)\n{\n\tu32 val;\n\tu32 reg;\n\tint i;\n\tint lane;\n\n\tfor (lane = 0; lane < MAX_LANE; lane++) {\n\t\tserdes_wr(ctx, lane, RXTX_REG147, 0x6);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG0, &val);\n\t\tval = RXTX_REG0_CTLE_EQ_HR_SET(val, 0x10);\n\t\tval = RXTX_REG0_CTLE_EQ_QR_SET(val, 0x10);\n\t\tval = RXTX_REG0_CTLE_EQ_FR_SET(val, 0x10);\n\t\tserdes_wr(ctx, lane, RXTX_REG0, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG1, &val);\n\t\tval = RXTX_REG1_RXACVCM_SET(val, 0x7);\n\t\tval = RXTX_REG1_CTLE_EQ_SET(val,\n\t\t\tctx->sata_param.txboostgain[lane * 3 +\n\t\t\tctx->sata_param.speed[lane]]);\n\t\tserdes_wr(ctx, lane, RXTX_REG1, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG2, &val);\n\t\tval = RXTX_REG2_VTT_ENA_SET(val, 0x1);\n\t\tval = RXTX_REG2_VTT_SEL_SET(val, 0x1);\n\t\tval = RXTX_REG2_TX_FIFO_ENA_SET(val, 0x1);\n\t\tserdes_wr(ctx, lane, RXTX_REG2, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG4, &val);\n\t\tval = RXTX_REG4_TX_WORD_MODE_SET(val, CMU_REG9_WORD_LEN_20BIT);\n\t\tserdes_wr(ctx, lane, RXTX_REG4, val);\n\n\t\tif (!preA3Chip) {\n\t\t\tserdes_rd(ctx, lane, RXTX_REG1, &val);\n\t\t\tval = RXTX_REG1_RXVREG1_SET(val, 0x2);\n\t\t\tval = RXTX_REG1_RXIREF_ADJ_SET(val, 0x2);\n\t\t\tserdes_wr(ctx, lane, RXTX_REG1, val);\n\t\t}\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG5, &val);\n\t\tval = RXTX_REG5_TX_CN1_SET(val,\n\t\t\tctx->sata_param.txprecursor_cn1[lane * 3 +\n\t\t\tctx->sata_param.speed[lane]]);\n\t\tval = RXTX_REG5_TX_CP1_SET(val,\n\t\t\tctx->sata_param.txpostcursor_cp1[lane * 3 +\n\t\t\tctx->sata_param.speed[lane]]);\n\t\tval = RXTX_REG5_TX_CN2_SET(val,\n\t\t\tctx->sata_param.txprecursor_cn2[lane * 3 +\n\t\t\tctx->sata_param.speed[lane]]);\n\t\tserdes_wr(ctx, lane, RXTX_REG5, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG6, &val);\n\t\tval = RXTX_REG6_TXAMP_CNTL_SET(val,\n\t\t\tctx->sata_param.txamplitude[lane * 3 +\n\t\t\tctx->sata_param.speed[lane]]);\n\t\tval = RXTX_REG6_TXAMP_ENA_SET(val, 0x1);\n\t\tval = RXTX_REG6_TX_IDLE_SET(val, 0x0);\n\t\tval = RXTX_REG6_RX_BIST_RESYNC_SET(val, 0x0);\n\t\tval = RXTX_REG6_RX_BIST_ERRCNT_RD_SET(val, 0x0);\n\t\tserdes_wr(ctx, lane, RXTX_REG6, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG7, &val);\n\t\tval = RXTX_REG7_BIST_ENA_RX_SET(val, 0x0);\n\t\tval = RXTX_REG7_RX_WORD_MODE_SET(val, CMU_REG9_WORD_LEN_20BIT);\n\t\tserdes_wr(ctx, lane, RXTX_REG7, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG8, &val);\n\t\tval = RXTX_REG8_CDR_LOOP_ENA_SET(val, 0x1);\n\t\tval = RXTX_REG8_CDR_BYPASS_RXLOS_SET(val, 0x0);\n\t\tval = RXTX_REG8_SSC_ENABLE_SET(val, 0x1);\n\t\tval = RXTX_REG8_SD_DISABLE_SET(val, 0x0);\n\t\tval = RXTX_REG8_SD_VREF_SET(val, 0x4);\n\t\tserdes_wr(ctx, lane, RXTX_REG8, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG11, &val);\n\t\tval = RXTX_REG11_PHASE_ADJUST_LIMIT_SET(val, 0x0);\n\t\tserdes_wr(ctx, lane, RXTX_REG11, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG12, &val);\n\t\tval = RXTX_REG12_LATCH_OFF_ENA_SET(val, 0x1);\n\t\tval = RXTX_REG12_SUMOS_ENABLE_SET(val, 0x0);\n\t\tval = RXTX_REG12_RX_DET_TERM_ENABLE_SET(val, 0x0);\n\t\tserdes_wr(ctx, lane, RXTX_REG12, val);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG26, &val);\n\t\tval = RXTX_REG26_PERIOD_ERROR_LATCH_SET(val, 0x0);\n\t\tval = RXTX_REG26_BLWC_ENA_SET(val, 0x1);\n\t\tserdes_wr(ctx, lane, RXTX_REG26, val);\n\n\t\tserdes_wr(ctx, lane, RXTX_REG28, 0x0);\n\n\t\t \n\t\tserdes_wr(ctx, lane, RXTX_REG31, 0x0);\n\n\t\t \n\t\tserdes_rd(ctx, lane, RXTX_REG61, &val);\n\t\tval = RXTX_REG61_ISCAN_INBERT_SET(val, 0x1);\n\t\tval = RXTX_REG61_LOADFREQ_SHIFT_SET(val, 0x0);\n\t\tval = RXTX_REG61_EYE_COUNT_WIDTH_SEL_SET(val, 0x0);\n\t\tserdes_wr(ctx, lane, RXTX_REG61, val);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG62, &val);\n\t\tval = RXTX_REG62_PERIOD_H1_QLATCH_SET(val, 0x0);\n\t\tserdes_wr(ctx, lane, RXTX_REG62, val);\n\n\t\t \n\t\tfor (i = 0; i < 9; i++) {\n\t\t\treg = RXTX_REG81 + i * 2;\n\t\t\tserdes_rd(ctx, lane, reg, &val);\n\t\t\tval = RXTX_REG89_MU_TH7_SET(val, 0xe);\n\t\t\tval = RXTX_REG89_MU_TH8_SET(val, 0xe);\n\t\t\tval = RXTX_REG89_MU_TH9_SET(val, 0xe);\n\t\t\tserdes_wr(ctx, lane, reg, val);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\treg = RXTX_REG96 + i * 2;\n\t\t\tserdes_rd(ctx, lane, reg, &val);\n\t\t\tval = RXTX_REG96_MU_FREQ1_SET(val, 0x10);\n\t\t\tval = RXTX_REG96_MU_FREQ2_SET(val, 0x10);\n\t\t\tval = RXTX_REG96_MU_FREQ3_SET(val, 0x10);\n\t\t\tserdes_wr(ctx, lane, reg, val);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\treg = RXTX_REG99 + i * 2;\n\t\t\tserdes_rd(ctx, lane, reg, &val);\n\t\t\tval = RXTX_REG99_MU_PHASE1_SET(val, 0x7);\n\t\t\tval = RXTX_REG99_MU_PHASE2_SET(val, 0x7);\n\t\t\tval = RXTX_REG99_MU_PHASE3_SET(val, 0x7);\n\t\t\tserdes_wr(ctx, lane, reg, val);\n\t\t}\n\n\t\tserdes_rd(ctx, lane, RXTX_REG102, &val);\n\t\tval = RXTX_REG102_FREQLOOP_LIMIT_SET(val, 0x0);\n\t\tserdes_wr(ctx, lane, RXTX_REG102, val);\n\n\t\tserdes_wr(ctx, lane, RXTX_REG114, 0xffe0);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG125, &val);\n\t\tval = RXTX_REG125_SIGN_PQ_SET(val,\n\t\t\tctx->sata_param.txeyedirection[lane * 3 +\n\t\t\tctx->sata_param.speed[lane]]);\n\t\tval = RXTX_REG125_PQ_REG_SET(val,\n\t\t\tctx->sata_param.txeyetuning[lane * 3 +\n\t\t\tctx->sata_param.speed[lane]]);\n\t\tval = RXTX_REG125_PHZ_MANUAL_SET(val, 0x1);\n\t\tserdes_wr(ctx, lane, RXTX_REG125, val);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG127, &val);\n\t\tval = RXTX_REG127_LATCH_MAN_CAL_ENA_SET(val, 0x0);\n\t\tserdes_wr(ctx, lane, RXTX_REG127, val);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG128, &val);\n\t\tval = RXTX_REG128_LATCH_CAL_WAIT_SEL_SET(val, 0x3);\n\t\tserdes_wr(ctx, lane, RXTX_REG128, val);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG145, &val);\n\t\tval = RXTX_REG145_RXDFE_CONFIG_SET(val, 0x3);\n\t\tval = RXTX_REG145_TX_IDLE_SATA_SET(val, 0x0);\n\t\tif (preA3Chip) {\n\t\t\tval = RXTX_REG145_RXES_ENA_SET(val, 0x1);\n\t\t\tval = RXTX_REG145_RXVWES_LATENA_SET(val, 0x1);\n\t\t} else {\n\t\t\tval = RXTX_REG145_RXES_ENA_SET(val, 0x0);\n\t\t\tval = RXTX_REG145_RXVWES_LATENA_SET(val, 0x0);\n\t\t}\n\t\tserdes_wr(ctx, lane, RXTX_REG145, val);\n\n\t\t \n\t\tfor (i = 0; i < 4; i++) {\n\t\t\treg = RXTX_REG148 + i * 2;\n\t\t\tserdes_wr(ctx, lane, reg, 0xFFFF);\n\t\t}\n\t}\n}\n\nstatic int xgene_phy_cal_rdy_chk(struct xgene_phy_ctx *ctx,\n\t\t\t\t enum cmu_type_t cmu_type,\n\t\t\t\t enum clk_type_t clk_type)\n{\n\tvoid __iomem *csr_serdes = ctx->sds_base;\n\tint loop;\n\tu32 val;\n\n\t \n\twritel(0xdf, csr_serdes + SATA_ENET_SDS_RST_CTL);\n\treadl(csr_serdes + SATA_ENET_SDS_RST_CTL);  \n\n\tif (cmu_type != REF_CMU) {\n\t\tcmu_setbits(ctx, cmu_type, CMU_REG5, CMU_REG5_PLL_RESETB_MASK);\n\t\t \n\t\tusleep_range(800, 1000);\n\n\t\tcmu_rd(ctx, cmu_type, CMU_REG1, &val);\n\t\tval = CMU_REG1_PLL_MANUALCAL_SET(val, 0x0);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG1, val);\n\t\t \n\t\tusleep_range(800, 1000);\n\n\t\tcmu_toggle1to0(ctx, cmu_type, CMU_REG32,\n\t\t\t       CMU_REG32_FORCE_VCOCAL_START_MASK);\n\t\t \n\t\tusleep_range(800, 1000);\n\t}\n\n\tif (!preA3Chip)\n\t\tgoto skip_manual_cal;\n\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG17, &val);\n\tval = CMU_REG17_PVT_CODE_R2A_SET(val, 0x12);\n\tval = CMU_REG17_RESERVED_7_SET(val, 0x0);\n\tcmu_wr(ctx, cmu_type, CMU_REG17, val);\n\tcmu_toggle1to0(ctx, cmu_type, CMU_REG17,\n\t\t       CMU_REG17_PVT_TERM_MAN_ENA_MASK);\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG17, &val);\n\tval = CMU_REG17_PVT_CODE_R2A_SET(val, 0x29);\n\tval = CMU_REG17_RESERVED_7_SET(val, 0x0);\n\tcmu_wr(ctx, cmu_type, CMU_REG17, val);\n\tcmu_toggle1to0(ctx, cmu_type, CMU_REG16,\n\t\t       CMU_REG16_PVT_DN_MAN_ENA_MASK);\n\t \n\tcmu_rd(ctx, cmu_type, CMU_REG17, &val);\n\tval = CMU_REG17_PVT_CODE_R2A_SET(val, 0x28);\n\tval = CMU_REG17_RESERVED_7_SET(val, 0x0);\n\tcmu_wr(ctx, cmu_type, CMU_REG17, val);\n\tcmu_toggle1to0(ctx, cmu_type, CMU_REG16,\n\t\t       CMU_REG16_PVT_UP_MAN_ENA_MASK);\n\nskip_manual_cal:\n\t \n\tloop = 100;\n\tdo {\n\t\tcmu_rd(ctx, cmu_type, CMU_REG7, &val);\n\t\tif (CMU_REG7_PLL_CALIB_DONE_RD(val))\n\t\t\tbreak;\n\t\t \n\t\tusleep_range(10, 100);\n\t} while (--loop > 0);\n\n\tcmu_rd(ctx, cmu_type, CMU_REG7, &val);\n\tdev_dbg(ctx->dev, \"PLL calibration %s\\n\",\n\t\tCMU_REG7_PLL_CALIB_DONE_RD(val) ? \"done\" : \"failed\");\n\tif (CMU_REG7_VCO_CAL_FAIL_RD(val)) {\n\t\tdev_err(ctx->dev,\n\t\t\t\"PLL calibration failed due to VCO failure\\n\");\n\t\treturn -1;\n\t}\n\tdev_dbg(ctx->dev, \"PLL calibration successful\\n\");\n\n\tcmu_rd(ctx, cmu_type, CMU_REG15, &val);\n\tdev_dbg(ctx->dev, \"PHY Tx is %sready\\n\", val & 0x300 ? \"\" : \"not \");\n\treturn 0;\n}\n\nstatic void xgene_phy_pdwn_force_vco(struct xgene_phy_ctx *ctx,\n\t\t\t\t     enum cmu_type_t cmu_type,\n\t\t\t\t     enum clk_type_t clk_type)\n{\n\tu32 val;\n\n\tdev_dbg(ctx->dev, \"Reset VCO and re-start again\\n\");\n\tif (cmu_type == PHY_CMU) {\n\t\tcmu_rd(ctx, cmu_type, CMU_REG16, &val);\n\t\tval = CMU_REG16_VCOCAL_WAIT_BTW_CODE_SET(val, 0x7);\n\t\tcmu_wr(ctx, cmu_type, CMU_REG16, val);\n\t}\n\n\tcmu_toggle1to0(ctx, cmu_type, CMU_REG0, CMU_REG0_PDOWN_MASK);\n\tcmu_toggle1to0(ctx, cmu_type, CMU_REG32,\n\t\t       CMU_REG32_FORCE_VCOCAL_START_MASK);\n}\n\nstatic int xgene_phy_hw_init_sata(struct xgene_phy_ctx *ctx,\n\t\t\t\t  enum clk_type_t clk_type, int ssc_enable)\n{\n\tvoid __iomem *sds_base = ctx->sds_base;\n\tu32 val;\n\tint i;\n\n\t \n\tdev_dbg(ctx->dev, \"Reset PHY\\n\");\n\t \n\twritel(0x0, sds_base + SATA_ENET_SDS_RST_CTL);\n\tval = readl(sds_base + SATA_ENET_SDS_RST_CTL);\t \n\t \n\twritel(0x20, sds_base + SATA_ENET_SDS_RST_CTL);\n\treadl(sds_base + SATA_ENET_SDS_RST_CTL);\t \n\t \n\twritel(0xde, sds_base + SATA_ENET_SDS_RST_CTL);\n\treadl(sds_base + SATA_ENET_SDS_RST_CTL);\t \n\n\t \n\tval = readl(sds_base + SATA_ENET_SDS_CTL1);\n\tval = CFG_I_SPD_SEL_CDR_OVR1_SET(val,\n\t\tctx->sata_param.txspeed[ctx->sata_param.speed[0]]);\n\twritel(val, sds_base + SATA_ENET_SDS_CTL1);\n\n\tdev_dbg(ctx->dev, \"Set the customer pin mode to SATA\\n\");\n\tval = readl(sds_base + SATA_ENET_SDS_CTL0);\n\tval = REGSPEC_CFG_I_CUSTOMER_PIN_MODE0_SET(val, 0x4421);\n\twritel(val, sds_base + SATA_ENET_SDS_CTL0);\n\n\t \n\txgene_phy_cfg_cmu_clk_type(ctx, PHY_CMU, clk_type);\n\n\t \n\txgene_phy_sata_cfg_cmu_core(ctx, PHY_CMU, clk_type);\n\n\t \n\tif (ssc_enable)\n\t\txgene_phy_ssc_enable(ctx, PHY_CMU);\n\n\t \n\txgene_phy_sata_cfg_lanes(ctx);\n\n\t \n\tval = readl(sds_base + SATA_ENET_SDS_PCS_CTL0);\n\tval = REGSPEC_CFG_I_RX_WORDMODE0_SET(val, 0x3);\n\tval = REGSPEC_CFG_I_TX_WORDMODE0_SET(val, 0x3);\n\twritel(val, sds_base + SATA_ENET_SDS_PCS_CTL0);\n\n\t \n\ti = 10;\n\tdo {\n\t\tif (!xgene_phy_cal_rdy_chk(ctx, PHY_CMU, clk_type))\n\t\t\tbreak;\n\t\t \n\t\txgene_phy_pdwn_force_vco(ctx, PHY_CMU, clk_type);\n\t} while (--i > 0);\n\t \n\tif (i <= 0)\n\t\tdev_err(ctx->dev, \"PLL calibration failed\\n\");\n\n\treturn 0;\n}\n\nstatic int xgene_phy_hw_initialize(struct xgene_phy_ctx *ctx,\n\t\t\t\t   enum clk_type_t clk_type,\n\t\t\t\t   int ssc_enable)\n{\n\tint rc;\n\n\tdev_dbg(ctx->dev, \"PHY init clk type %d\\n\", clk_type);\n\n\tif (ctx->mode == MODE_SATA) {\n\t\trc = xgene_phy_hw_init_sata(ctx, clk_type, ssc_enable);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\tdev_err(ctx->dev, \"Un-supported customer pin mode %d\\n\",\n\t\t\tctx->mode);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void xgene_phy_force_lat_summer_cal(struct xgene_phy_ctx *ctx, int lane)\n{\n\tint i;\n\tstatic const struct {\n\t\tu32 reg;\n\t\tu32 val;\n\t} serdes_reg[] = {\n\t\t{RXTX_REG38, 0x0},\n\t\t{RXTX_REG39, 0xff00},\n\t\t{RXTX_REG40, 0xffff},\n\t\t{RXTX_REG41, 0xffff},\n\t\t{RXTX_REG42, 0xffff},\n\t\t{RXTX_REG43, 0xffff},\n\t\t{RXTX_REG44, 0xffff},\n\t\t{RXTX_REG45, 0xffff},\n\t\t{RXTX_REG46, 0xffff},\n\t\t{RXTX_REG47, 0xfffc},\n\t\t{RXTX_REG48, 0x0},\n\t\t{RXTX_REG49, 0x0},\n\t\t{RXTX_REG50, 0x0},\n\t\t{RXTX_REG51, 0x0},\n\t\t{RXTX_REG52, 0x0},\n\t\t{RXTX_REG53, 0x0},\n\t\t{RXTX_REG54, 0x0},\n\t\t{RXTX_REG55, 0x0},\n\t};\n\n\t \n\tserdes_setbits(ctx, lane, RXTX_REG127,\n\t\t       RXTX_REG127_FORCE_SUM_CAL_START_MASK);\n\t \n\tusleep_range(100, 500);\n\tserdes_clrbits(ctx, lane, RXTX_REG127,\n\t\t\tRXTX_REG127_FORCE_SUM_CAL_START_MASK);\n\t \n\tusleep_range(100, 500);\n\n\t \n\tserdes_setbits(ctx, lane, RXTX_REG127,\n\t\t       RXTX_REG127_FORCE_LAT_CAL_START_MASK);\n\t \n\tusleep_range(100, 500);\n\tserdes_clrbits(ctx, lane, RXTX_REG127,\n\t\t       RXTX_REG127_FORCE_LAT_CAL_START_MASK);\n\n\t \n\tserdes_wr(ctx, lane, RXTX_REG28, 0x7);\n\tserdes_wr(ctx, lane, RXTX_REG31, 0x7e00);\n\tserdes_clrbits(ctx, lane, RXTX_REG4,\n\t\t       RXTX_REG4_TX_LOOPBACK_BUF_EN_MASK);\n\tserdes_clrbits(ctx, lane, RXTX_REG7,\n\t\t       RXTX_REG7_LOOP_BACK_ENA_CTLE_MASK);\n\tfor (i = 0; i < ARRAY_SIZE(serdes_reg); i++)\n\t\tserdes_wr(ctx, lane, serdes_reg[i].reg,\n\t\t\t  serdes_reg[i].val);\n}\n\nstatic void xgene_phy_reset_rxd(struct xgene_phy_ctx *ctx, int lane)\n{\n\t \n\tserdes_clrbits(ctx, lane, RXTX_REG7, RXTX_REG7_RESETB_RXD_MASK);\n\t \n\tusleep_range(100, 150);\n\tserdes_setbits(ctx, lane, RXTX_REG7, RXTX_REG7_RESETB_RXD_MASK);\n}\n\nstatic int xgene_phy_get_avg(int accum, int samples)\n{\n\treturn (accum + (samples / 2)) / samples;\n}\n\nstatic void xgene_phy_gen_avg_val(struct xgene_phy_ctx *ctx, int lane)\n{\n\tint max_loop = 10;\n\tint avg_loop = 0;\n\tint lat_do = 0, lat_xo = 0, lat_eo = 0, lat_so = 0;\n\tint lat_de = 0, lat_xe = 0, lat_ee = 0, lat_se = 0;\n\tint sum_cal = 0;\n\tint lat_do_itr, lat_xo_itr, lat_eo_itr, lat_so_itr;\n\tint lat_de_itr, lat_xe_itr, lat_ee_itr, lat_se_itr;\n\tint sum_cal_itr;\n\tint fail_even;\n\tint fail_odd;\n\tu32 val;\n\n\tdev_dbg(ctx->dev, \"Generating avg calibration value for lane %d\\n\",\n\t\tlane);\n\n\t \n\tserdes_setbits(ctx, lane, RXTX_REG12,\n\t\t\tRXTX_REG12_RX_DET_TERM_ENABLE_MASK);\n\t \n\tserdes_wr(ctx, lane, RXTX_REG28, 0x0000);\n\t \n\tserdes_wr(ctx, lane, RXTX_REG31, 0x0000);\n\n\t \n\twhile (avg_loop < max_loop) {\n\t\t \n\t\txgene_phy_force_lat_summer_cal(ctx, lane);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG21, &val);\n\t\tlat_do_itr = RXTX_REG21_DO_LATCH_CALOUT_RD(val);\n\t\tlat_xo_itr = RXTX_REG21_XO_LATCH_CALOUT_RD(val);\n\t\tfail_odd = RXTX_REG21_LATCH_CAL_FAIL_ODD_RD(val);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG22, &val);\n\t\tlat_eo_itr = RXTX_REG22_EO_LATCH_CALOUT_RD(val);\n\t\tlat_so_itr = RXTX_REG22_SO_LATCH_CALOUT_RD(val);\n\t\tfail_even = RXTX_REG22_LATCH_CAL_FAIL_EVEN_RD(val);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG23, &val);\n\t\tlat_de_itr = RXTX_REG23_DE_LATCH_CALOUT_RD(val);\n\t\tlat_xe_itr = RXTX_REG23_XE_LATCH_CALOUT_RD(val);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG24, &val);\n\t\tlat_ee_itr = RXTX_REG24_EE_LATCH_CALOUT_RD(val);\n\t\tlat_se_itr = RXTX_REG24_SE_LATCH_CALOUT_RD(val);\n\n\t\tserdes_rd(ctx, lane, RXTX_REG121, &val);\n\t\tsum_cal_itr = RXTX_REG121_SUMOS_CAL_CODE_RD(val);\n\n\t\t \n\t\tif ((fail_even == 0 || fail_even == 1) &&\n\t\t    (fail_odd == 0 || fail_odd == 1)) {\n\t\t\tlat_do += lat_do_itr;\n\t\t\tlat_xo += lat_xo_itr;\n\t\t\tlat_eo += lat_eo_itr;\n\t\t\tlat_so += lat_so_itr;\n\t\t\tlat_de += lat_de_itr;\n\t\t\tlat_xe += lat_xe_itr;\n\t\t\tlat_ee += lat_ee_itr;\n\t\t\tlat_se += lat_se_itr;\n\t\t\tsum_cal += sum_cal_itr;\n\n\t\t\tdev_dbg(ctx->dev, \"Iteration %d:\\n\", avg_loop);\n\t\t\tdev_dbg(ctx->dev, \"DO 0x%x XO 0x%x EO 0x%x SO 0x%x\\n\",\n\t\t\t\tlat_do_itr, lat_xo_itr, lat_eo_itr,\n\t\t\t\tlat_so_itr);\n\t\t\tdev_dbg(ctx->dev, \"DE 0x%x XE 0x%x EE 0x%x SE 0x%x\\n\",\n\t\t\t\tlat_de_itr, lat_xe_itr, lat_ee_itr,\n\t\t\t\tlat_se_itr);\n\t\t\tdev_dbg(ctx->dev, \"SUM 0x%x\\n\", sum_cal_itr);\n\t\t\t++avg_loop;\n\t\t} else {\n\t\t\tdev_err(ctx->dev,\n\t\t\t\t\"Receiver calibration failed at %d loop\\n\",\n\t\t\t\tavg_loop);\n\t\t}\n\t\txgene_phy_reset_rxd(ctx, lane);\n\t}\n\n\t \n\tserdes_rd(ctx, lane, RXTX_REG127, &val);\n\tval = RXTX_REG127_DO_LATCH_MANCAL_SET(val,\n\t\txgene_phy_get_avg(lat_do, max_loop));\n\tval = RXTX_REG127_XO_LATCH_MANCAL_SET(val,\n\t\txgene_phy_get_avg(lat_xo, max_loop));\n\tserdes_wr(ctx, lane, RXTX_REG127, val);\n\n\tserdes_rd(ctx, lane, RXTX_REG128, &val);\n\tval = RXTX_REG128_EO_LATCH_MANCAL_SET(val,\n\t\txgene_phy_get_avg(lat_eo, max_loop));\n\tval = RXTX_REG128_SO_LATCH_MANCAL_SET(val,\n\t\txgene_phy_get_avg(lat_so, max_loop));\n\tserdes_wr(ctx, lane, RXTX_REG128, val);\n\n\tserdes_rd(ctx, lane, RXTX_REG129, &val);\n\tval = RXTX_REG129_DE_LATCH_MANCAL_SET(val,\n\t\txgene_phy_get_avg(lat_de, max_loop));\n\tval = RXTX_REG129_XE_LATCH_MANCAL_SET(val,\n\t\txgene_phy_get_avg(lat_xe, max_loop));\n\tserdes_wr(ctx, lane, RXTX_REG129, val);\n\n\tserdes_rd(ctx, lane, RXTX_REG130, &val);\n\tval = RXTX_REG130_EE_LATCH_MANCAL_SET(val,\n\t\txgene_phy_get_avg(lat_ee, max_loop));\n\tval = RXTX_REG130_SE_LATCH_MANCAL_SET(val,\n\t\txgene_phy_get_avg(lat_se, max_loop));\n\tserdes_wr(ctx, lane, RXTX_REG130, val);\n\n\t \n\tserdes_rd(ctx, lane, RXTX_REG14, &val);\n\tval = RXTX_REG14_CLTE_LATCAL_MAN_PROG_SET(val,\n\t\txgene_phy_get_avg(sum_cal, max_loop));\n\tserdes_wr(ctx, lane, RXTX_REG14, val);\n\n\tdev_dbg(ctx->dev, \"Average Value:\\n\");\n\tdev_dbg(ctx->dev, \"DO 0x%x XO 0x%x EO 0x%x SO 0x%x\\n\",\n\t\t xgene_phy_get_avg(lat_do, max_loop),\n\t\t xgene_phy_get_avg(lat_xo, max_loop),\n\t\t xgene_phy_get_avg(lat_eo, max_loop),\n\t\t xgene_phy_get_avg(lat_so, max_loop));\n\tdev_dbg(ctx->dev, \"DE 0x%x XE 0x%x EE 0x%x SE 0x%x\\n\",\n\t\t xgene_phy_get_avg(lat_de, max_loop),\n\t\t xgene_phy_get_avg(lat_xe, max_loop),\n\t\t xgene_phy_get_avg(lat_ee, max_loop),\n\t\t xgene_phy_get_avg(lat_se, max_loop));\n\tdev_dbg(ctx->dev, \"SUM 0x%x\\n\",\n\t\txgene_phy_get_avg(sum_cal, max_loop));\n\n\tserdes_rd(ctx, lane, RXTX_REG14, &val);\n\tval = RXTX_REG14_CTLE_LATCAL_MAN_ENA_SET(val, 0x1);\n\tserdes_wr(ctx, lane, RXTX_REG14, val);\n\tdev_dbg(ctx->dev, \"Enable Manual Summer calibration\\n\");\n\n\tserdes_rd(ctx, lane, RXTX_REG127, &val);\n\tval = RXTX_REG127_LATCH_MAN_CAL_ENA_SET(val, 0x1);\n\tdev_dbg(ctx->dev, \"Enable Manual Latch calibration\\n\");\n\tserdes_wr(ctx, lane, RXTX_REG127, val);\n\n\t \n\tserdes_rd(ctx, lane, RXTX_REG12, &val);\n\tval = RXTX_REG12_RX_DET_TERM_ENABLE_SET(val, 0);\n\tserdes_wr(ctx, lane, RXTX_REG12, val);\n\t \n\tserdes_wr(ctx, lane, RXTX_REG28, 0x0007);\n\t \n\tserdes_wr(ctx, lane, RXTX_REG31, 0x7e00);\n}\n\nstatic int xgene_phy_hw_init(struct phy *phy)\n{\n\tstruct xgene_phy_ctx *ctx = phy_get_drvdata(phy);\n\tint rc;\n\tint i;\n\n\trc = xgene_phy_hw_initialize(ctx, CLK_EXT_DIFF, SSC_DISABLE);\n\tif (rc) {\n\t\tdev_err(ctx->dev, \"PHY initialize failed %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tif (!IS_ERR(ctx->clk)) {\n\t\t \n\t\tclk_prepare_enable(ctx->clk);\n\t\tclk_disable_unprepare(ctx->clk);\n\t\tclk_prepare_enable(ctx->clk);\n\t}\n\n\t \n\tfor (i = 0; i < MAX_LANE; i++)\n\t\txgene_phy_gen_avg_val(ctx, i);\n\n\tdev_dbg(ctx->dev, \"PHY initialized\\n\");\n\treturn 0;\n}\n\nstatic const struct phy_ops xgene_phy_ops = {\n\t.init\t\t= xgene_phy_hw_init,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *xgene_phy_xlate(struct device *dev,\n\t\t\t\t   struct of_phandle_args *args)\n{\n\tstruct xgene_phy_ctx *ctx = dev_get_drvdata(dev);\n\n\tif (args->args_count <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (args->args[0] >= MODE_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tctx->mode = args->args[0];\n\treturn ctx->phy;\n}\n\nstatic void xgene_phy_get_param(struct platform_device *pdev,\n\t\t\t\tconst char *name, u32 *buffer,\n\t\t\t\tint count, u32 *default_val,\n\t\t\t\tu32 conv_factor)\n{\n\tint i;\n\n\tif (!of_property_read_u32_array(pdev->dev.of_node, name, buffer,\n\t\t\t\t\tcount)) {\n\t\tfor (i = 0; i < count; i++)\n\t\t\tbuffer[i] /= conv_factor;\n\t\treturn;\n\t}\n\t \n\tfor (i = 0; i < count; i++)\n\t\tbuffer[i] = default_val[i % 3];\n}\n\nstatic int xgene_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct xgene_phy_ctx *ctx;\n\tu32 default_spd[] = DEFAULT_SATA_SPD_SEL;\n\tu32 default_txboost_gain[] = DEFAULT_SATA_TXBOOST_GAIN;\n\tu32 default_txeye_direction[] = DEFAULT_SATA_TXEYEDIRECTION;\n\tu32 default_txeye_tuning[] = DEFAULT_SATA_TXEYETUNING;\n\tu32 default_txamp[] = DEFAULT_SATA_TXAMP;\n\tu32 default_txcn1[] = DEFAULT_SATA_TXCN1;\n\tu32 default_txcn2[] = DEFAULT_SATA_TXCN2;\n\tu32 default_txcp1[] = DEFAULT_SATA_TXCP1;\n\tint i;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = &pdev->dev;\n\n\tctx->sds_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->sds_base))\n\t\treturn PTR_ERR(ctx->sds_base);\n\n\t \n\tctx->clk = clk_get(&pdev->dev, NULL);\n\n\t \n\txgene_phy_get_param(pdev, \"apm,tx-eye-tuning\",\n\t\tctx->sata_param.txeyetuning, 6, default_txeye_tuning, 1);\n\txgene_phy_get_param(pdev, \"apm,tx-eye-direction\",\n\t\tctx->sata_param.txeyedirection, 6, default_txeye_direction, 1);\n\txgene_phy_get_param(pdev, \"apm,tx-boost-gain\",\n\t\tctx->sata_param.txboostgain, 6, default_txboost_gain, 1);\n\txgene_phy_get_param(pdev, \"apm,tx-amplitude\",\n\t\tctx->sata_param.txamplitude, 6, default_txamp, 13300);\n\txgene_phy_get_param(pdev, \"apm,tx-pre-cursor1\",\n\t\tctx->sata_param.txprecursor_cn1, 6, default_txcn1, 18200);\n\txgene_phy_get_param(pdev, \"apm,tx-pre-cursor2\",\n\t\tctx->sata_param.txprecursor_cn2, 6, default_txcn2, 18200);\n\txgene_phy_get_param(pdev, \"apm,tx-post-cursor\",\n\t\tctx->sata_param.txpostcursor_cp1, 6, default_txcp1, 18200);\n\txgene_phy_get_param(pdev, \"apm,tx-speed\",\n\t\tctx->sata_param.txspeed, 3, default_spd, 1);\n\tfor (i = 0; i < MAX_LANE; i++)\n\t\tctx->sata_param.speed[i] = 2;  \n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tctx->phy = devm_phy_create(ctx->dev, NULL, &xgene_phy_ops);\n\tif (IS_ERR(ctx->phy)) {\n\t\tdev_dbg(&pdev->dev, \"Failed to create PHY\\n\");\n\t\treturn PTR_ERR(ctx->phy);\n\t}\n\tphy_set_drvdata(ctx->phy, ctx);\n\n\tphy_provider = devm_of_phy_provider_register(ctx->dev, xgene_phy_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id xgene_phy_of_match[] = {\n\t{.compatible = \"apm,xgene-phy\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xgene_phy_of_match);\n\nstatic struct platform_driver xgene_phy_driver = {\n\t.probe = xgene_phy_probe,\n\t.driver = {\n\t\t   .name = \"xgene-phy\",\n\t\t   .of_match_table = xgene_phy_of_match,\n\t},\n};\nmodule_platform_driver(xgene_phy_driver);\n\nMODULE_DESCRIPTION(\"APM X-Gene Multi-Purpose PHY driver\");\nMODULE_AUTHOR(\"Loc Ho <lho@apm.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"0.1\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}