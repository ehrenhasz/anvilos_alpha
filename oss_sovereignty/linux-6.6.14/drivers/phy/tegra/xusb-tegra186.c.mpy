{
  "module_name": "xusb-tegra186.c",
  "hash_id": "eafc4ddacc5fad399da5f9cc09e35ba1cc1e955dd6c01aa2075d92a10402ebab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/tegra/xusb-tegra186.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/regulator/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"xusb.h\"\n\n \n#define HS_CURR_LEVEL_PADX_SHIFT(x)\t((x) ? (11 + (x - 1) * 6) : 0)\n#define HS_CURR_LEVEL_PAD_MASK\t\t0x3f\n#define HS_TERM_RANGE_ADJ_SHIFT\t\t7\n#define HS_TERM_RANGE_ADJ_MASK\t\t0xf\n#define HS_SQUELCH_SHIFT\t\t29\n#define HS_SQUELCH_MASK\t\t\t0x7\n\n#define RPD_CTRL_SHIFT\t\t\t0\n#define RPD_CTRL_MASK\t\t\t0x1f\n\n \n#define XUSB_PADCTL_USB2_PAD_MUX\t0x4\n#define  USB2_PORT_SHIFT(x)\t\t((x) * 2)\n#define  USB2_PORT_MASK\t\t\t0x3\n#define   PORT_XUSB\t\t\t1\n#define  HSIC_PORT_SHIFT(x)\t\t((x) + 20)\n#define  HSIC_PORT_MASK\t\t\t0x1\n#define   PORT_HSIC\t\t\t0\n\n#define XUSB_PADCTL_USB2_PORT_CAP\t0x8\n#define XUSB_PADCTL_SS_PORT_CAP\t\t0xc\n#define  PORTX_CAP_SHIFT(x)\t\t((x) * 4)\n#define  PORT_CAP_MASK\t\t\t0x3\n#define   PORT_CAP_DISABLED\t\t0x0\n#define   PORT_CAP_HOST\t\t\t0x1\n#define   PORT_CAP_DEVICE\t\t0x2\n#define   PORT_CAP_OTG\t\t\t0x3\n\n#define XUSB_PADCTL_ELPG_PROGRAM\t\t0x20\n#define  USB2_PORT_WAKE_INTERRUPT_ENABLE(x)\t\tBIT(x)\n#define  USB2_PORT_WAKEUP_EVENT(x)\t\t\tBIT((x) +  7)\n#define  SS_PORT_WAKE_INTERRUPT_ENABLE(x)\t\tBIT((x) + 14)\n#define  SS_PORT_WAKEUP_EVENT(x)\t\t\tBIT((x) + 21)\n#define  USB2_HSIC_PORT_WAKE_INTERRUPT_ENABLE(x)\tBIT((x) + 28)\n#define  USB2_HSIC_PORT_WAKEUP_EVENT(x)\t\t\tBIT((x) + 30)\n#define  ALL_WAKE_EVENTS\t\t\t\t\t\t\\\n\t(USB2_PORT_WAKEUP_EVENT(0) | USB2_PORT_WAKEUP_EVENT(1) |\t\\\n\tUSB2_PORT_WAKEUP_EVENT(2) | SS_PORT_WAKEUP_EVENT(0) |\t\t\\\n\tSS_PORT_WAKEUP_EVENT(1) | SS_PORT_WAKEUP_EVENT(2) |\t\t\\\n\tUSB2_HSIC_PORT_WAKEUP_EVENT(0))\n\n#define XUSB_PADCTL_ELPG_PROGRAM_1\t\t0x24\n#define  SSPX_ELPG_CLAMP_EN(x)\t\t\tBIT(0 + (x) * 3)\n#define  SSPX_ELPG_CLAMP_EN_EARLY(x)\t\tBIT(1 + (x) * 3)\n#define  SSPX_ELPG_VCORE_DOWN(x)\t\tBIT(2 + (x) * 3)\n#define XUSB_PADCTL_SS_PORT_CFG\t\t\t0x2c\n#define   PORTX_SPEED_SUPPORT_SHIFT(x)\t\t((x) * 4)\n#define   PORTX_SPEED_SUPPORT_MASK\t\t(0x3)\n#define     PORT_SPEED_SUPPORT_GEN1\t\t(0x0)\n\n#define XUSB_PADCTL_USB2_OTG_PADX_CTL0(x)\t(0x88 + (x) * 0x40)\n#define  HS_CURR_LEVEL(x)\t\t\t((x) & 0x3f)\n#define  TERM_SEL\t\t\t\tBIT(25)\n#define  USB2_OTG_PD\t\t\t\tBIT(26)\n#define  USB2_OTG_PD2\t\t\t\tBIT(27)\n#define  USB2_OTG_PD2_OVRD_EN\t\t\tBIT(28)\n#define  USB2_OTG_PD_ZI\t\t\t\tBIT(29)\n\n#define XUSB_PADCTL_USB2_OTG_PADX_CTL1(x)\t(0x8c + (x) * 0x40)\n#define  USB2_OTG_PD_DR\t\t\t\tBIT(2)\n#define  TERM_RANGE_ADJ(x)\t\t\t(((x) & 0xf) << 3)\n#define  RPD_CTRL(x)\t\t\t\t(((x) & 0x1f) << 26)\n\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0\t\t0x284\n#define  BIAS_PAD_PD\t\t\t\tBIT(11)\n#define  HS_SQUELCH_LEVEL(x)\t\t\t(((x) & 0x7) << 0)\n\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1\t\t0x288\n#define  USB2_TRK_START_TIMER(x)\t\t(((x) & 0x7f) << 12)\n#define  USB2_TRK_DONE_RESET_TIMER(x)\t\t(((x) & 0x7f) << 19)\n#define  USB2_PD_TRK\t\t\t\tBIT(26)\n#define  USB2_TRK_COMPLETED\t\t\tBIT(31)\n\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL2\t\t0x28c\n#define  USB2_TRK_HW_MODE\t\t\tBIT(0)\n#define  CYA_TRK_CODE_UPDATE_ON_IDLE\t\tBIT(31)\n\n#define XUSB_PADCTL_HSIC_PADX_CTL0(x)\t\t(0x300 + (x) * 0x20)\n#define  HSIC_PD_TX_DATA0\t\t\tBIT(1)\n#define  HSIC_PD_TX_STROBE\t\t\tBIT(3)\n#define  HSIC_PD_RX_DATA0\t\t\tBIT(4)\n#define  HSIC_PD_RX_STROBE\t\t\tBIT(6)\n#define  HSIC_PD_ZI_DATA0\t\t\tBIT(7)\n#define  HSIC_PD_ZI_STROBE\t\t\tBIT(9)\n#define  HSIC_RPD_DATA0\t\t\t\tBIT(13)\n#define  HSIC_RPD_STROBE\t\t\tBIT(15)\n#define  HSIC_RPU_DATA0\t\t\t\tBIT(16)\n#define  HSIC_RPU_STROBE\t\t\tBIT(18)\n\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL0\t\t0x340\n#define  HSIC_TRK_START_TIMER(x)\t\t(((x) & 0x7f) << 5)\n#define  HSIC_TRK_DONE_RESET_TIMER(x)\t\t(((x) & 0x7f) << 12)\n#define  HSIC_PD_TRK\t\t\t\tBIT(19)\n\n#define USB2_VBUS_ID\t\t\t\t0x360\n#define  VBUS_OVERRIDE\t\t\t\tBIT(14)\n#define  ID_OVERRIDE(x)\t\t\t\t(((x) & 0xf) << 18)\n#define  ID_OVERRIDE_FLOATING\t\t\tID_OVERRIDE(8)\n#define  ID_OVERRIDE_GROUNDED\t\t\tID_OVERRIDE(0)\n\n \n#define XUSB_AO_USB_DEBOUNCE_DEL\t\t(0x4)\n#define   UHSIC_LINE_DEB_CNT(x)\t\t\t(((x) & 0xf) << 4)\n#define   UTMIP_LINE_DEB_CNT(x)\t\t\t((x) & 0xf)\n\n#define XUSB_AO_UTMIP_TRIGGERS(x)\t\t(0x40 + (x) * 4)\n#define   CLR_WALK_PTR\t\t\t\tBIT(0)\n#define   CAP_CFG\t\t\t\tBIT(1)\n#define   CLR_WAKE_ALARM\t\t\tBIT(3)\n\n#define XUSB_AO_UHSIC_TRIGGERS(x)\t\t(0x60 + (x) * 4)\n#define   HSIC_CLR_WALK_PTR\t\t\tBIT(0)\n#define   HSIC_CLR_WAKE_ALARM\t\t\tBIT(3)\n#define   HSIC_CAP_CFG\t\t\t\tBIT(4)\n\n#define XUSB_AO_UTMIP_SAVED_STATE(x)\t\t(0x70 + (x) * 4)\n#define   SPEED(x)\t\t\t\t((x) & 0x3)\n#define     UTMI_HS\t\t\t\tSPEED(0)\n#define     UTMI_FS\t\t\t\tSPEED(1)\n#define     UTMI_LS\t\t\t\tSPEED(2)\n#define     UTMI_RST\t\t\t\tSPEED(3)\n\n#define XUSB_AO_UHSIC_SAVED_STATE(x)\t\t(0x90 + (x) * 4)\n#define   MODE(x)\t\t\t\t((x) & 0x1)\n#define   MODE_HS\t\t\t\tMODE(0)\n#define   MODE_RST\t\t\t\tMODE(1)\n\n#define XUSB_AO_UTMIP_SLEEPWALK_STATUS(x)\t(0xa0 + (x) * 4)\n\n#define XUSB_AO_UTMIP_SLEEPWALK_CFG(x)\t\t(0xd0 + (x) * 4)\n#define XUSB_AO_UHSIC_SLEEPWALK_CFG(x)\t\t(0xf0 + (x) * 4)\n#define   FAKE_USBOP_VAL\t\t\tBIT(0)\n#define   FAKE_USBON_VAL\t\t\tBIT(1)\n#define   FAKE_USBOP_EN\t\t\t\tBIT(2)\n#define   FAKE_USBON_EN\t\t\t\tBIT(3)\n#define   FAKE_STROBE_VAL\t\t\tBIT(0)\n#define   FAKE_DATA_VAL\t\t\t\tBIT(1)\n#define   FAKE_STROBE_EN\t\t\tBIT(2)\n#define   FAKE_DATA_EN\t\t\t\tBIT(3)\n#define   WAKE_WALK_EN\t\t\t\tBIT(14)\n#define   MASTER_ENABLE\t\t\t\tBIT(15)\n#define   LINEVAL_WALK_EN\t\t\tBIT(16)\n#define   WAKE_VAL(x)\t\t\t\t(((x) & 0xf) << 17)\n#define     WAKE_VAL_NONE\t\t\tWAKE_VAL(12)\n#define     WAKE_VAL_ANY\t\t\tWAKE_VAL(15)\n#define     WAKE_VAL_DS10\t\t\tWAKE_VAL(2)\n#define   LINE_WAKEUP_EN\t\t\tBIT(21)\n#define   MASTER_CFG_SEL\t\t\tBIT(22)\n\n#define XUSB_AO_UTMIP_SLEEPWALK(x)\t\t(0x100 + (x) * 4)\n \n#define   USBOP_RPD_A\t\t\t\tBIT(0)\n#define   USBON_RPD_A\t\t\t\tBIT(1)\n#define   AP_A\t\t\t\t\tBIT(4)\n#define   AN_A\t\t\t\t\tBIT(5)\n#define   HIGHZ_A\t\t\t\tBIT(6)\n#define   MASTER_ENABLE_A\t\t\tBIT(7)\n \n#define   USBOP_RPD_B\t\t\t\tBIT(8)\n#define   USBON_RPD_B\t\t\t\tBIT(9)\n#define   AP_B\t\t\t\t\tBIT(12)\n#define   AN_B\t\t\t\t\tBIT(13)\n#define   HIGHZ_B\t\t\t\tBIT(14)\n#define   MASTER_ENABLE_B\t\t\tBIT(15)\n \n#define   USBOP_RPD_C\t\t\t\tBIT(16)\n#define   USBON_RPD_C\t\t\t\tBIT(17)\n#define   AP_C\t\t\t\t\tBIT(20)\n#define   AN_C\t\t\t\t\tBIT(21)\n#define   HIGHZ_C\t\t\t\tBIT(22)\n#define   MASTER_ENABLE_C\t\t\tBIT(23)\n \n#define   USBOP_RPD_D\t\t\t\tBIT(24)\n#define   USBON_RPD_D\t\t\t\tBIT(25)\n#define   AP_D\t\t\t\t\tBIT(28)\n#define   AN_D\t\t\t\t\tBIT(29)\n#define   HIGHZ_D\t\t\t\tBIT(30)\n#define   MASTER_ENABLE_D\t\t\tBIT(31)\n#define   MASTER_ENABLE_B_C_D\t\t\t\t\t\\\n\t (MASTER_ENABLE_B | MASTER_ENABLE_C | MASTER_ENABLE_D)\n\n#define XUSB_AO_UHSIC_SLEEPWALK(x)\t\t(0x120 + (x) * 4)\n \n#define   RPD_STROBE_A\t\t\t\tBIT(0)\n#define   RPD_DATA0_A\t\t\t\tBIT(1)\n#define   RPU_STROBE_A\t\t\t\tBIT(2)\n#define   RPU_DATA0_A\t\t\t\tBIT(3)\n \n#define   RPD_STROBE_B\t\t\t\tBIT(8)\n#define   RPD_DATA0_B\t\t\t\tBIT(9)\n#define   RPU_STROBE_B\t\t\t\tBIT(10)\n#define   RPU_DATA0_B\t\t\t\tBIT(11)\n \n#define   RPD_STROBE_C\t\t\t\tBIT(16)\n#define   RPD_DATA0_C\t\t\t\tBIT(17)\n#define   RPU_STROBE_C\t\t\t\tBIT(18)\n#define   RPU_DATA0_C\t\t\t\tBIT(19)\n \n#define   RPD_STROBE_D\t\t\t\tBIT(24)\n#define   RPD_DATA0_D\t\t\t\tBIT(25)\n#define   RPU_STROBE_D\t\t\t\tBIT(26)\n#define   RPU_DATA0_D\t\t\t\tBIT(27)\n\n#define XUSB_AO_UTMIP_PAD_CFG(x)\t\t(0x130 + (x) * 4)\n#define   FSLS_USE_XUSB_AO\t\t\tBIT(3)\n#define   TRK_CTRL_USE_XUSB_AO\t\t\tBIT(4)\n#define   RPD_CTRL_USE_XUSB_AO\t\t\tBIT(5)\n#define   RPU_USE_XUSB_AO\t\t\tBIT(6)\n#define   VREG_USE_XUSB_AO\t\t\tBIT(7)\n#define   USBOP_VAL_PD\t\t\t\tBIT(8)\n#define   USBON_VAL_PD\t\t\t\tBIT(9)\n#define   E_DPD_OVRD_EN\t\t\t\tBIT(10)\n#define   E_DPD_OVRD_VAL\t\t\tBIT(11)\n\n#define XUSB_AO_UHSIC_PAD_CFG(x)\t\t(0x150 + (x) * 4)\n#define   STROBE_VAL_PD\t\t\t\tBIT(0)\n#define   DATA0_VAL_PD\t\t\t\tBIT(1)\n#define   USE_XUSB_AO\t\t\t\tBIT(4)\n\n#define TEGRA186_LANE(_name, _offset, _shift, _mask, _type)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.offset = _offset,\t\t\t\t\t\\\n\t\t.shift = _shift,\t\t\t\t\t\\\n\t\t.mask = _mask,\t\t\t\t\t\t\\\n\t\t.num_funcs = ARRAY_SIZE(tegra186_##_type##_functions),\t\\\n\t\t.funcs = tegra186_##_type##_functions,\t\t\t\\\n\t}\n\nstruct tegra_xusb_fuse_calibration {\n\tu32 *hs_curr_level;\n\tu32 hs_squelch;\n\tu32 hs_term_range_adj;\n\tu32 rpd_ctrl;\n};\n\nstruct tegra186_xusb_padctl_context {\n\tu32 vbus_id;\n\tu32 usb2_pad_mux;\n\tu32 usb2_port_cap;\n\tu32 ss_port_cap;\n};\n\nstruct tegra186_xusb_padctl {\n\tstruct tegra_xusb_padctl base;\n\tvoid __iomem *ao_regs;\n\n\tstruct tegra_xusb_fuse_calibration calib;\n\n\t \n\tstruct clk *usb2_trk_clk;\n\tunsigned int bias_pad_enable;\n\n\t \n\tstruct tegra186_xusb_padctl_context context;\n};\n\nstatic inline void ao_writel(struct tegra186_xusb_padctl *priv, u32 value, unsigned int offset)\n{\n\twritel(value, priv->ao_regs + offset);\n}\n\nstatic inline u32 ao_readl(struct tegra186_xusb_padctl *priv, unsigned int offset)\n{\n\treturn readl(priv->ao_regs + offset);\n}\n\nstatic inline struct tegra186_xusb_padctl *\nto_tegra186_xusb_padctl(struct tegra_xusb_padctl *padctl)\n{\n\treturn container_of(padctl, struct tegra186_xusb_padctl, base);\n}\n\n \nstatic struct tegra_xusb_lane *\ntegra186_usb2_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_usb2_lane *usb2;\n\tint err;\n\n\tusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&usb2->base.list);\n\tusb2->base.soc = &pad->soc->lanes[index];\n\tusb2->base.index = index;\n\tusb2->base.pad = pad;\n\tusb2->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&usb2->base, np);\n\tif (err < 0) {\n\t\tkfree(usb2);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &usb2->base;\n}\n\nstatic void tegra186_usb2_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\n\n\tkfree(usb2);\n}\n\nstatic int tegra186_utmi_enable_phy_sleepwalk(struct tegra_xusb_lane *lane,\n\t\t\t\t\t      enum usb_device_speed speed)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra186_xusb_padctl *priv = to_tegra186_xusb_padctl(padctl);\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue &= ~MASTER_ENABLE;\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue |= MASTER_CFG_SEL;\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_USB_DEBOUNCE_DEL);\n\tvalue &= ~UTMIP_LINE_DEB_CNT(~0);\n\tvalue |= UTMIP_LINE_DEB_CNT(1);\n\tao_writel(priv, value, XUSB_AO_USB_DEBOUNCE_DEL);\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue &= ~(FAKE_USBOP_VAL | FAKE_USBON_VAL |\n\t\tFAKE_USBOP_EN | FAKE_USBON_EN);\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue &= ~LINE_WAKEUP_EN;\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue &= ~WAKE_VAL(~0);\n\tvalue |= WAKE_VAL_NONE;\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_PAD_CFG(index));\n\tvalue |= (USBOP_VAL_PD | USBON_VAL_PD);\n\tao_writel(priv, value, XUSB_AO_UTMIP_PAD_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SAVED_STATE(index));\n\tvalue &= ~SPEED(~0);\n\n\tswitch (speed) {\n\tcase USB_SPEED_HIGH:\n\t\tvalue |= UTMI_HS;\n\t\tbreak;\n\n\tcase USB_SPEED_FULL:\n\t\tvalue |= UTMI_FS;\n\t\tbreak;\n\n\tcase USB_SPEED_LOW:\n\t\tvalue |= UTMI_LS;\n\t\tbreak;\n\n\tdefault:\n\t\tvalue |= UTMI_RST;\n\t\tbreak;\n\t}\n\n\tao_writel(priv, value, XUSB_AO_UTMIP_SAVED_STATE(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue |= LINEVAL_WALK_EN;\n\tvalue &= ~WAKE_WALK_EN;\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_TRIGGERS(index));\n\tvalue |= (CLR_WALK_PTR | CLR_WAKE_ALARM | CAP_CFG);\n\tao_writel(priv, value, XUSB_AO_UTMIP_TRIGGERS(index));\n\n\t \n\tvalue = USBOP_RPD_A | USBOP_RPD_B | USBOP_RPD_C | USBOP_RPD_D;\n\tvalue |= USBON_RPD_A | USBON_RPD_B | USBON_RPD_C | USBON_RPD_D;\n\n\tswitch (speed) {\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_FULL:\n\t\t \n\t\tvalue |= HIGHZ_A;\n\t\tvalue |= AP_A;\n\t\tvalue |= AN_B | AN_C | AN_D;\n\t\tif (padctl->soc->supports_lp_cfg_en)\n\t\t\tvalue |= MASTER_ENABLE_B_C_D;\n\t\tbreak;\n\n\tcase USB_SPEED_LOW:\n\t\t \n\t\tvalue |= HIGHZ_A;\n\t\tvalue |= AN_A;\n\t\tvalue |= AP_B | AP_C | AP_D;\n\t\tif (padctl->soc->supports_lp_cfg_en)\n\t\t\tvalue |= MASTER_ENABLE_B_C_D;\n\t\tbreak;\n\n\tdefault:\n\t\tvalue |= HIGHZ_A | HIGHZ_B | HIGHZ_C | HIGHZ_D;\n\t\tbreak;\n\t}\n\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_PAD_CFG(index));\n\tvalue &= ~(USBOP_VAL_PD | USBON_VAL_PD);\n\tao_writel(priv, value, XUSB_AO_UTMIP_PAD_CFG(index));\n\n\tusleep_range(150, 200);\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_PAD_CFG(index));\n\tvalue |= FSLS_USE_XUSB_AO | TRK_CTRL_USE_XUSB_AO | RPD_CTRL_USE_XUSB_AO |\n\t\t RPU_USE_XUSB_AO | VREG_USE_XUSB_AO;\n\tao_writel(priv, value, XUSB_AO_UTMIP_PAD_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue &= ~WAKE_VAL(~0);\n\tvalue |= WAKE_VAL_ANY;\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue |= MASTER_ENABLE | LINE_WAKEUP_EN;\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra186_utmi_disable_phy_sleepwalk(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra186_xusb_padctl *priv = to_tegra186_xusb_padctl(padctl);\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue &= ~(MASTER_ENABLE | LINE_WAKEUP_EN);\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_PAD_CFG(index));\n\tvalue &= ~(FSLS_USE_XUSB_AO | TRK_CTRL_USE_XUSB_AO | RPD_CTRL_USE_XUSB_AO |\n\t\t   RPU_USE_XUSB_AO | VREG_USE_XUSB_AO);\n\tao_writel(priv, value, XUSB_AO_UTMIP_PAD_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\tvalue &= ~WAKE_VAL(~0);\n\tvalue |= WAKE_VAL_NONE;\n\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK_CFG(index));\n\n\tif (padctl->soc->supports_lp_cfg_en) {\n\t\t \n\t\tvalue = ao_readl(priv, XUSB_AO_UTMIP_SLEEPWALK(index));\n\t\tvalue &= ~(MASTER_ENABLE_A | MASTER_ENABLE_B_C_D);\n\t\tao_writel(priv, value, XUSB_AO_UTMIP_SLEEPWALK(index));\n\t}\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_PAD_CFG(index));\n\tvalue |= USBOP_VAL_PD | USBON_VAL_PD;\n\tao_writel(priv, value, XUSB_AO_UTMIP_PAD_CFG(index));\n\n\t \n\tvalue = ao_readl(priv, XUSB_AO_UTMIP_TRIGGERS(index));\n\tvalue |= CLR_WAKE_ALARM;\n\tao_writel(priv, value, XUSB_AO_UTMIP_TRIGGERS(index));\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra186_utmi_enable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_PORT_WAKEUP_EVENT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_PORT_WAKE_INTERRUPT_ENABLE(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra186_utmi_disable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue &= ~USB2_PORT_WAKE_INTERRUPT_ENABLE(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_PORT_WAKEUP_EVENT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic bool tegra186_utmi_phy_remote_wake_detected(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tif ((value & USB2_PORT_WAKE_INTERRUPT_ENABLE(index)) &&\n\t    (value & USB2_PORT_WAKEUP_EVENT(index)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct tegra_xusb_lane_ops tegra186_usb2_lane_ops = {\n\t.probe = tegra186_usb2_lane_probe,\n\t.remove = tegra186_usb2_lane_remove,\n\t.enable_phy_sleepwalk = tegra186_utmi_enable_phy_sleepwalk,\n\t.disable_phy_sleepwalk = tegra186_utmi_disable_phy_sleepwalk,\n\t.enable_phy_wake = tegra186_utmi_enable_phy_wake,\n\t.disable_phy_wake = tegra186_utmi_disable_phy_wake,\n\t.remote_wake_detected = tegra186_utmi_phy_remote_wake_detected,\n};\n\nstatic void tegra186_utmi_bias_pad_power_on(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra186_xusb_padctl *priv = to_tegra186_xusb_padctl(padctl);\n\tstruct device *dev = padctl->dev;\n\tu32 value;\n\tint err;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (priv->bias_pad_enable++ > 0) {\n\t\tmutex_unlock(&padctl->lock);\n\t\treturn;\n\t}\n\n\terr = clk_prepare_enable(priv->usb2_trk_clk);\n\tif (err < 0)\n\t\tdev_warn(dev, \"failed to enable USB2 trk clock: %d\\n\", err);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\tvalue &= ~USB2_TRK_START_TIMER(~0);\n\tvalue |= USB2_TRK_START_TIMER(0x1e);\n\tvalue &= ~USB2_TRK_DONE_RESET_TIMER(~0);\n\tvalue |= USB2_TRK_DONE_RESET_TIMER(0xa);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\tvalue &= ~BIAS_PAD_PD;\n\tvalue &= ~HS_SQUELCH_LEVEL(~0);\n\tvalue |= HS_SQUELCH_LEVEL(priv->calib.hs_squelch);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\n\tudelay(1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\tvalue &= ~USB2_PD_TRK;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\n\tif (padctl->soc->poll_trk_completed) {\n\t\terr = padctl_readl_poll(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1,\n\t\t\t\t\tUSB2_TRK_COMPLETED, USB2_TRK_COMPLETED, 100);\n\t\tif (err) {\n\t\t\t \n\t\t\tdev_warn(dev, \"failed to poll USB2 trk completed: %d\\n\", err);\n\t\t}\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\t\tvalue |= USB2_TRK_COMPLETED;\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\t} else {\n\t\tudelay(100);\n\t}\n\n\tif (padctl->soc->trk_hw_mode) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL2);\n\t\tvalue |= USB2_TRK_HW_MODE;\n\t\tvalue &= ~CYA_TRK_CODE_UPDATE_ON_IDLE;\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL2);\n\t} else {\n\t\tclk_disable_unprepare(priv->usb2_trk_clk);\n\t}\n\n\tmutex_unlock(&padctl->lock);\n}\n\nstatic void tegra186_utmi_bias_pad_power_off(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra186_xusb_padctl *priv = to_tegra186_xusb_padctl(padctl);\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (WARN_ON(priv->bias_pad_enable == 0)) {\n\t\tmutex_unlock(&padctl->lock);\n\t\treturn;\n\t}\n\n\tif (--priv->bias_pad_enable > 0) {\n\t\tmutex_unlock(&padctl->lock);\n\t\treturn;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\tvalue |= USB2_PD_TRK;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\n\tif (padctl->soc->trk_hw_mode) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL2);\n\t\tvalue &= ~USB2_TRK_HW_MODE;\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL2);\n\t\tclk_disable_unprepare(priv->usb2_trk_clk);\n\t}\n\n\tmutex_unlock(&padctl->lock);\n}\n\nstatic void tegra186_utmi_pad_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb2_port *port;\n\tstruct device *dev = padctl->dev;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tif (!phy)\n\t\treturn;\n\n\tport = tegra_xusb_find_usb2_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(dev, \"no port found for USB2 lane %u\\n\", index);\n\t\treturn;\n\t}\n\n\tdev_dbg(dev, \"power on UTMI pad %u\\n\", index);\n\n\ttegra186_utmi_bias_pad_power_on(padctl);\n\n\tudelay(2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\tvalue &= ~USB2_OTG_PD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\tvalue &= ~USB2_OTG_PD_DR;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n}\n\nstatic void tegra186_utmi_pad_power_down(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tif (!phy)\n\t\treturn;\n\n\tdev_dbg(padctl->dev, \"power down UTMI pad %u\\n\", index);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\tvalue |= USB2_OTG_PD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\tvalue |= USB2_OTG_PD_DR;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\n\tudelay(2);\n\n\ttegra186_utmi_bias_pad_power_off(padctl);\n}\n\nstatic int tegra186_xusb_padctl_vbus_override(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t       bool status)\n{\n\tu32 value;\n\n\tdev_dbg(padctl->dev, \"%s vbus override\\n\", status ? \"set\" : \"clear\");\n\n\tvalue = padctl_readl(padctl, USB2_VBUS_ID);\n\n\tif (status) {\n\t\tvalue |= VBUS_OVERRIDE;\n\t\tvalue &= ~ID_OVERRIDE(~0);\n\t\tvalue |= ID_OVERRIDE_FLOATING;\n\t} else {\n\t\tvalue &= ~VBUS_OVERRIDE;\n\t}\n\n\tpadctl_writel(padctl, value, USB2_VBUS_ID);\n\n\treturn 0;\n}\n\nstatic int tegra186_xusb_padctl_id_override(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t    bool status)\n{\n\tu32 value;\n\n\tdev_dbg(padctl->dev, \"%s id override\\n\", status ? \"set\" : \"clear\");\n\n\tvalue = padctl_readl(padctl, USB2_VBUS_ID);\n\n\tif (status) {\n\t\tif (value & VBUS_OVERRIDE) {\n\t\t\tvalue &= ~VBUS_OVERRIDE;\n\t\t\tpadctl_writel(padctl, value, USB2_VBUS_ID);\n\t\t\tusleep_range(1000, 2000);\n\n\t\t\tvalue = padctl_readl(padctl, USB2_VBUS_ID);\n\t\t}\n\n\t\tvalue &= ~ID_OVERRIDE(~0);\n\t\tvalue |= ID_OVERRIDE_GROUNDED;\n\t} else {\n\t\tvalue &= ~ID_OVERRIDE(~0);\n\t\tvalue |= ID_OVERRIDE_FLOATING;\n\t}\n\n\tpadctl_writel(padctl, value, USB2_VBUS_ID);\n\n\treturn 0;\n}\n\nstatic int tegra186_utmi_phy_set_mode(struct phy *phy, enum phy_mode mode,\n\t\t\t\t      int submode)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb2_port *port = tegra_xusb_find_usb2_port(padctl,\n\t\t\t\t\t\t\t\tlane->index);\n\tint err = 0;\n\n\tmutex_lock(&padctl->lock);\n\n\tdev_dbg(&port->base.dev, \"%s: mode %d\", __func__, mode);\n\n\tif (mode == PHY_MODE_USB_OTG) {\n\t\tif (submode == USB_ROLE_HOST) {\n\t\t\ttegra186_xusb_padctl_id_override(padctl, true);\n\n\t\t\terr = regulator_enable(port->supply);\n\t\t} else if (submode == USB_ROLE_DEVICE) {\n\t\t\ttegra186_xusb_padctl_vbus_override(padctl, true);\n\t\t} else if (submode == USB_ROLE_NONE) {\n\t\t\t \n\t\t\tif (regulator_is_enabled(port->supply))\n\t\t\t\tregulator_disable(port->supply);\n\n\t\t\ttegra186_xusb_padctl_id_override(padctl, false);\n\t\t\ttegra186_xusb_padctl_vbus_override(padctl, false);\n\t\t}\n\t}\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn err;\n}\n\nstatic int tegra186_utmi_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra186_xusb_padctl *priv = to_tegra186_xusb_padctl(padctl);\n\tstruct tegra_xusb_usb2_port *port;\n\tunsigned int index = lane->index;\n\tstruct device *dev = padctl->dev;\n\tu32 value;\n\n\tport = tegra_xusb_find_usb2_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(dev, \"no port found for USB2 lane %u\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PAD_MUX);\n\tvalue &= ~(USB2_PORT_MASK << USB2_PORT_SHIFT(index));\n\tvalue |= (PORT_XUSB << USB2_PORT_SHIFT(index));\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_PAD_MUX);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PORT_CAP);\n\tvalue &= ~(PORT_CAP_MASK << PORTX_CAP_SHIFT(index));\n\n\tif (port->mode == USB_DR_MODE_UNKNOWN)\n\t\tvalue |= (PORT_CAP_DISABLED << PORTX_CAP_SHIFT(index));\n\telse if (port->mode == USB_DR_MODE_PERIPHERAL)\n\t\tvalue |= (PORT_CAP_DEVICE << PORTX_CAP_SHIFT(index));\n\telse if (port->mode == USB_DR_MODE_HOST)\n\t\tvalue |= (PORT_CAP_HOST << PORTX_CAP_SHIFT(index));\n\telse if (port->mode == USB_DR_MODE_OTG)\n\t\tvalue |= (PORT_CAP_OTG << PORTX_CAP_SHIFT(index));\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_PORT_CAP);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\tvalue &= ~USB2_OTG_PD_ZI;\n\tvalue |= TERM_SEL;\n\tvalue &= ~HS_CURR_LEVEL(~0);\n\n\tif (usb2->hs_curr_level_offset) {\n\t\tint hs_current_level;\n\n\t\ths_current_level = (int)priv->calib.hs_curr_level[index] +\n\t\t\t\t\t\tusb2->hs_curr_level_offset;\n\n\t\tif (hs_current_level < 0)\n\t\t\ths_current_level = 0;\n\t\tif (hs_current_level > 0x3f)\n\t\t\ths_current_level = 0x3f;\n\n\t\tvalue |= HS_CURR_LEVEL(hs_current_level);\n\t} else {\n\t\tvalue |= HS_CURR_LEVEL(priv->calib.hs_curr_level[index]);\n\t}\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\tvalue &= ~TERM_RANGE_ADJ(~0);\n\tvalue |= TERM_RANGE_ADJ(priv->calib.hs_term_range_adj);\n\tvalue &= ~RPD_CTRL(~0);\n\tvalue |= RPD_CTRL(priv->calib.rpd_ctrl);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\n\ttegra186_utmi_pad_power_on(phy);\n\n\treturn 0;\n}\n\nstatic int tegra186_utmi_phy_power_off(struct phy *phy)\n{\n\ttegra186_utmi_pad_power_down(phy);\n\n\treturn 0;\n}\n\nstatic int tegra186_utmi_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb2_port *port;\n\tunsigned int index = lane->index;\n\tstruct device *dev = padctl->dev;\n\tint err;\n\n\tport = tegra_xusb_find_usb2_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(dev, \"no port found for USB2 lane %u\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tif (port->supply && port->mode == USB_DR_MODE_HOST) {\n\t\terr = regulator_enable(port->supply);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to enable port %u VBUS: %d\\n\",\n\t\t\t\tindex, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra186_utmi_phy_exit(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb2_port *port;\n\tunsigned int index = lane->index;\n\tstruct device *dev = padctl->dev;\n\tint err;\n\n\tport = tegra_xusb_find_usb2_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(dev, \"no port found for USB2 lane %u\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tif (port->supply && port->mode == USB_DR_MODE_HOST) {\n\t\terr = regulator_disable(port->supply);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to disable port %u VBUS: %d\\n\",\n\t\t\t\tindex, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct phy_ops utmi_phy_ops = {\n\t.init = tegra186_utmi_phy_init,\n\t.exit = tegra186_utmi_phy_exit,\n\t.power_on = tegra186_utmi_phy_power_on,\n\t.power_off = tegra186_utmi_phy_power_off,\n\t.set_mode = tegra186_utmi_phy_set_mode,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra186_usb2_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra186_xusb_padctl *priv = to_tegra186_xusb_padctl(padctl);\n\tstruct tegra_xusb_usb2_pad *usb2;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &usb2->base;\n\tpad->ops = &tegra186_usb2_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(usb2);\n\t\tgoto out;\n\t}\n\n\tpriv->usb2_trk_clk = devm_clk_get(&pad->dev, \"trk\");\n\tif (IS_ERR(priv->usb2_trk_clk)) {\n\t\terr = PTR_ERR(priv->usb2_trk_clk);\n\t\tdev_dbg(&pad->dev, \"failed to get usb2 trk clock: %d\\n\", err);\n\t\tgoto unregister;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &utmi_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra186_usb2_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_usb2_pad *usb2 = to_usb2_pad(pad);\n\n\tkfree(usb2);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra186_usb2_pad_ops = {\n\t.probe = tegra186_usb2_pad_probe,\n\t.remove = tegra186_usb2_pad_remove,\n};\n\nstatic const char * const tegra186_usb2_functions[] = {\n\t\"xusb\",\n};\n\nstatic int tegra186_usb2_port_enable(struct tegra_xusb_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra186_usb2_port_disable(struct tegra_xusb_port *port)\n{\n}\n\nstatic struct tegra_xusb_lane *\ntegra186_usb2_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_find_lane(port->padctl, \"usb2\", port->index);\n}\n\nstatic const struct tegra_xusb_port_ops tegra186_usb2_port_ops = {\n\t.release = tegra_xusb_usb2_port_release,\n\t.remove = tegra_xusb_usb2_port_remove,\n\t.enable = tegra186_usb2_port_enable,\n\t.disable = tegra186_usb2_port_disable,\n\t.map = tegra186_usb2_port_map,\n};\n\n \nstatic struct tegra_xusb_lane *\ntegra186_usb3_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_usb3_lane *usb3;\n\tint err;\n\n\tusb3 = kzalloc(sizeof(*usb3), GFP_KERNEL);\n\tif (!usb3)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&usb3->base.list);\n\tusb3->base.soc = &pad->soc->lanes[index];\n\tusb3->base.index = index;\n\tusb3->base.pad = pad;\n\tusb3->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&usb3->base, np);\n\tif (err < 0) {\n\t\tkfree(usb3);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &usb3->base;\n}\n\nstatic void tegra186_usb3_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_usb3_lane *usb3 = to_usb3_lane(lane);\n\n\tkfree(usb3);\n}\n\nstatic int tegra186_usb3_enable_phy_sleepwalk(struct tegra_xusb_lane *lane,\n\t\t\t\t\t      enum usb_device_speed speed)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue |= SSPX_ELPG_CLAMP_EN_EARLY(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue |= SSPX_ELPG_CLAMP_EN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tusleep_range(250, 350);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra186_usb3_disable_phy_sleepwalk(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue &= ~SSPX_ELPG_CLAMP_EN_EARLY(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue &= ~SSPX_ELPG_CLAMP_EN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra186_usb3_enable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= SS_PORT_WAKEUP_EVENT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= SS_PORT_WAKE_INTERRUPT_ENABLE(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra186_usb3_disable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue &= ~SS_PORT_WAKE_INTERRUPT_ENABLE(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= SS_PORT_WAKEUP_EVENT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic bool tegra186_usb3_phy_remote_wake_detected(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tif ((value & SS_PORT_WAKE_INTERRUPT_ENABLE(index)) && (value & SS_PORT_WAKEUP_EVENT(index)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct tegra_xusb_lane_ops tegra186_usb3_lane_ops = {\n\t.probe = tegra186_usb3_lane_probe,\n\t.remove = tegra186_usb3_lane_remove,\n\t.enable_phy_sleepwalk = tegra186_usb3_enable_phy_sleepwalk,\n\t.disable_phy_sleepwalk = tegra186_usb3_disable_phy_sleepwalk,\n\t.enable_phy_wake = tegra186_usb3_enable_phy_wake,\n\t.disable_phy_wake = tegra186_usb3_disable_phy_wake,\n\t.remote_wake_detected = tegra186_usb3_phy_remote_wake_detected,\n};\n\nstatic int tegra186_usb3_port_enable(struct tegra_xusb_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra186_usb3_port_disable(struct tegra_xusb_port *port)\n{\n}\n\nstatic struct tegra_xusb_lane *\ntegra186_usb3_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_find_lane(port->padctl, \"usb3\", port->index);\n}\n\nstatic const struct tegra_xusb_port_ops tegra186_usb3_port_ops = {\n\t.release = tegra_xusb_usb3_port_release,\n\t.enable = tegra186_usb3_port_enable,\n\t.disable = tegra186_usb3_port_disable,\n\t.map = tegra186_usb3_port_map,\n};\n\nstatic int tegra186_usb3_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb3_port *port;\n\tstruct tegra_xusb_usb2_port *usb2;\n\tunsigned int index = lane->index;\n\tstruct device *dev = padctl->dev;\n\tu32 value;\n\n\tport = tegra_xusb_find_usb3_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(dev, \"no port found for USB3 lane %u\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tusb2 = tegra_xusb_find_usb2_port(padctl, port->port);\n\tif (!usb2) {\n\t\tdev_err(dev, \"no companion port found for USB3 lane %u\\n\",\n\t\t\tindex);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_CAP);\n\tvalue &= ~(PORT_CAP_MASK << PORTX_CAP_SHIFT(index));\n\n\tif (usb2->mode == USB_DR_MODE_UNKNOWN)\n\t\tvalue |= (PORT_CAP_DISABLED << PORTX_CAP_SHIFT(index));\n\telse if (usb2->mode == USB_DR_MODE_PERIPHERAL)\n\t\tvalue |= (PORT_CAP_DEVICE << PORTX_CAP_SHIFT(index));\n\telse if (usb2->mode == USB_DR_MODE_HOST)\n\t\tvalue |= (PORT_CAP_HOST << PORTX_CAP_SHIFT(index));\n\telse if (usb2->mode == USB_DR_MODE_OTG)\n\t\tvalue |= (PORT_CAP_OTG << PORTX_CAP_SHIFT(index));\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_CAP);\n\n\tif (padctl->soc->supports_gen2 && port->disable_gen2) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_CFG);\n\t\tvalue &= ~(PORTX_SPEED_SUPPORT_MASK <<\n\t\t\tPORTX_SPEED_SUPPORT_SHIFT(index));\n\t\tvalue |= (PORT_SPEED_SUPPORT_GEN1 <<\n\t\t\tPORTX_SPEED_SUPPORT_SHIFT(index));\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_CFG);\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue &= ~SSPX_ELPG_VCORE_DOWN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue &= ~SSPX_ELPG_CLAMP_EN_EARLY(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue &= ~SSPX_ELPG_CLAMP_EN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra186_usb3_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb3_port *port;\n\tunsigned int index = lane->index;\n\tstruct device *dev = padctl->dev;\n\tu32 value;\n\n\tport = tegra_xusb_find_usb3_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(dev, \"no port found for USB3 lane %u\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue |= SSPX_ELPG_CLAMP_EN_EARLY(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue |= SSPX_ELPG_CLAMP_EN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tusleep_range(250, 350);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_1);\n\tvalue |= SSPX_ELPG_VCORE_DOWN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_1);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra186_usb3_phy_init(struct phy *phy)\n{\n\treturn 0;\n}\n\nstatic int tegra186_usb3_phy_exit(struct phy *phy)\n{\n\treturn 0;\n}\n\nstatic const struct phy_ops usb3_phy_ops = {\n\t.init = tegra186_usb3_phy_init,\n\t.exit = tegra186_usb3_phy_exit,\n\t.power_on = tegra186_usb3_phy_power_on,\n\t.power_off = tegra186_usb3_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra186_usb3_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_usb3_pad *usb3;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tusb3 = kzalloc(sizeof(*usb3), GFP_KERNEL);\n\tif (!usb3)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &usb3->base;\n\tpad->ops = &tegra186_usb3_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(usb3);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &usb3_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra186_usb3_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_usb2_pad *usb2 = to_usb2_pad(pad);\n\n\tkfree(usb2);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra186_usb3_pad_ops = {\n\t.probe = tegra186_usb3_pad_probe,\n\t.remove = tegra186_usb3_pad_remove,\n};\n\nstatic const char * const tegra186_usb3_functions[] = {\n\t\"xusb\",\n};\n\nstatic int\ntegra186_xusb_read_fuse_calibration(struct tegra186_xusb_padctl *padctl)\n{\n\tstruct device *dev = padctl->base.dev;\n\tunsigned int i, count;\n\tu32 value, *level;\n\tint err;\n\n\tcount = padctl->base.soc->ports.usb2.count;\n\n\tlevel = devm_kcalloc(dev, count, sizeof(u32), GFP_KERNEL);\n\tif (!level)\n\t\treturn -ENOMEM;\n\n\terr = tegra_fuse_readl(TEGRA_FUSE_SKU_CALIB_0, &value);\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"failed to read calibration fuse\\n\");\n\n\tdev_dbg(dev, \"FUSE_USB_CALIB_0 %#x\\n\", value);\n\n\tfor (i = 0; i < count; i++)\n\t\tlevel[i] = (value >> HS_CURR_LEVEL_PADX_SHIFT(i)) &\n\t\t\t\tHS_CURR_LEVEL_PAD_MASK;\n\n\tpadctl->calib.hs_curr_level = level;\n\n\tpadctl->calib.hs_squelch = (value >> HS_SQUELCH_SHIFT) &\n\t\t\t\t\tHS_SQUELCH_MASK;\n\tpadctl->calib.hs_term_range_adj = (value >> HS_TERM_RANGE_ADJ_SHIFT) &\n\t\t\t\t\t\tHS_TERM_RANGE_ADJ_MASK;\n\n\terr = tegra_fuse_readl(TEGRA_FUSE_USB_CALIB_EXT_0, &value);\n\tif (err) {\n\t\tdev_err(dev, \"failed to read calibration fuse: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdev_dbg(dev, \"FUSE_USB_CALIB_EXT_0 %#x\\n\", value);\n\n\tpadctl->calib.rpd_ctrl = (value >> RPD_CTRL_SHIFT) & RPD_CTRL_MASK;\n\n\treturn 0;\n}\n\nstatic struct tegra_xusb_padctl *\ntegra186_xusb_padctl_probe(struct device *dev,\n\t\t\t   const struct tegra_xusb_padctl_soc *soc)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct tegra186_xusb_padctl *priv;\n\tstruct resource *res;\n\tint err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->base.dev = dev;\n\tpriv->base.soc = soc;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ao\");\n\tpriv->ao_regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(priv->ao_regs))\n\t\treturn ERR_CAST(priv->ao_regs);\n\n\terr = tegra186_xusb_read_fuse_calibration(priv);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\treturn &priv->base;\n}\n\nstatic void tegra186_xusb_padctl_save(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra186_xusb_padctl *priv = to_tegra186_xusb_padctl(padctl);\n\n\tpriv->context.vbus_id = padctl_readl(padctl, USB2_VBUS_ID);\n\tpriv->context.usb2_pad_mux = padctl_readl(padctl, XUSB_PADCTL_USB2_PAD_MUX);\n\tpriv->context.usb2_port_cap = padctl_readl(padctl, XUSB_PADCTL_USB2_PORT_CAP);\n\tpriv->context.ss_port_cap = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_CAP);\n}\n\nstatic void tegra186_xusb_padctl_restore(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra186_xusb_padctl *priv = to_tegra186_xusb_padctl(padctl);\n\n\tpadctl_writel(padctl, priv->context.usb2_pad_mux, XUSB_PADCTL_USB2_PAD_MUX);\n\tpadctl_writel(padctl, priv->context.usb2_port_cap, XUSB_PADCTL_USB2_PORT_CAP);\n\tpadctl_writel(padctl, priv->context.ss_port_cap, XUSB_PADCTL_SS_PORT_CAP);\n\tpadctl_writel(padctl, priv->context.vbus_id, USB2_VBUS_ID);\n}\n\nstatic int tegra186_xusb_padctl_suspend_noirq(struct tegra_xusb_padctl *padctl)\n{\n\ttegra186_xusb_padctl_save(padctl);\n\n\treturn 0;\n}\n\nstatic int tegra186_xusb_padctl_resume_noirq(struct tegra_xusb_padctl *padctl)\n{\n\ttegra186_xusb_padctl_restore(padctl);\n\n\treturn 0;\n}\n\nstatic void tegra186_xusb_padctl_remove(struct tegra_xusb_padctl *padctl)\n{\n}\n\nstatic const struct tegra_xusb_padctl_ops tegra186_xusb_padctl_ops = {\n\t.probe = tegra186_xusb_padctl_probe,\n\t.remove = tegra186_xusb_padctl_remove,\n\t.suspend_noirq = tegra186_xusb_padctl_suspend_noirq,\n\t.resume_noirq = tegra186_xusb_padctl_resume_noirq,\n\t.vbus_override = tegra186_xusb_padctl_vbus_override,\n\t.utmi_pad_power_on = tegra186_utmi_pad_power_on,\n\t.utmi_pad_power_down = tegra186_utmi_pad_power_down,\n};\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_186_SOC)\nstatic const char * const tegra186_xusb_padctl_supply_names[] = {\n\t\"avdd-pll-erefeut\",\n\t\"avdd-usb\",\n\t\"vclamp-usb\",\n\t\"vddio-hsic\",\n};\n\nstatic const struct tegra_xusb_lane_soc tegra186_usb2_lanes[] = {\n\tTEGRA186_LANE(\"usb2-0\", 0,  0, 0, usb2),\n\tTEGRA186_LANE(\"usb2-1\", 0,  0, 0, usb2),\n\tTEGRA186_LANE(\"usb2-2\", 0,  0, 0, usb2),\n};\n\nstatic const struct tegra_xusb_pad_soc tegra186_usb2_pad = {\n\t.name = \"usb2\",\n\t.num_lanes = ARRAY_SIZE(tegra186_usb2_lanes),\n\t.lanes = tegra186_usb2_lanes,\n\t.ops = &tegra186_usb2_pad_ops,\n};\n\nstatic const struct tegra_xusb_lane_soc tegra186_usb3_lanes[] = {\n\tTEGRA186_LANE(\"usb3-0\", 0,  0, 0, usb3),\n\tTEGRA186_LANE(\"usb3-1\", 0,  0, 0, usb3),\n\tTEGRA186_LANE(\"usb3-2\", 0,  0, 0, usb3),\n};\n\nstatic const struct tegra_xusb_pad_soc tegra186_usb3_pad = {\n\t.name = \"usb3\",\n\t.num_lanes = ARRAY_SIZE(tegra186_usb3_lanes),\n\t.lanes = tegra186_usb3_lanes,\n\t.ops = &tegra186_usb3_pad_ops,\n};\n\nstatic const struct tegra_xusb_pad_soc * const tegra186_pads[] = {\n\t&tegra186_usb2_pad,\n\t&tegra186_usb3_pad,\n#if 0  \n\t&tegra186_hsic_pad,\n#endif\n};\n\nconst struct tegra_xusb_padctl_soc tegra186_xusb_padctl_soc = {\n\t.num_pads = ARRAY_SIZE(tegra186_pads),\n\t.pads = tegra186_pads,\n\t.ports = {\n\t\t.usb2 = {\n\t\t\t.ops = &tegra186_usb2_port_ops,\n\t\t\t.count = 3,\n\t\t},\n#if 0  \n\t\t.hsic = {\n\t\t\t.ops = &tegra186_hsic_port_ops,\n\t\t\t.count = 1,\n\t\t},\n#endif\n\t\t.usb3 = {\n\t\t\t.ops = &tegra186_usb3_port_ops,\n\t\t\t.count = 3,\n\t\t},\n\t},\n\t.ops = &tegra186_xusb_padctl_ops,\n\t.supply_names = tegra186_xusb_padctl_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra186_xusb_padctl_supply_names),\n};\nEXPORT_SYMBOL_GPL(tegra186_xusb_padctl_soc);\n#endif\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_194_SOC) || \\\n\tIS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC)\nstatic const char * const tegra194_xusb_padctl_supply_names[] = {\n\t\"avdd-usb\",\n\t\"vclamp-usb\",\n};\n\nstatic const struct tegra_xusb_lane_soc tegra194_usb2_lanes[] = {\n\tTEGRA186_LANE(\"usb2-0\", 0,  0, 0, usb2),\n\tTEGRA186_LANE(\"usb2-1\", 0,  0, 0, usb2),\n\tTEGRA186_LANE(\"usb2-2\", 0,  0, 0, usb2),\n\tTEGRA186_LANE(\"usb2-3\", 0,  0, 0, usb2),\n};\n\nstatic const struct tegra_xusb_pad_soc tegra194_usb2_pad = {\n\t.name = \"usb2\",\n\t.num_lanes = ARRAY_SIZE(tegra194_usb2_lanes),\n\t.lanes = tegra194_usb2_lanes,\n\t.ops = &tegra186_usb2_pad_ops,\n};\n\nstatic const struct tegra_xusb_lane_soc tegra194_usb3_lanes[] = {\n\tTEGRA186_LANE(\"usb3-0\", 0,  0, 0, usb3),\n\tTEGRA186_LANE(\"usb3-1\", 0,  0, 0, usb3),\n\tTEGRA186_LANE(\"usb3-2\", 0,  0, 0, usb3),\n\tTEGRA186_LANE(\"usb3-3\", 0,  0, 0, usb3),\n};\n\nstatic const struct tegra_xusb_pad_soc tegra194_usb3_pad = {\n\t.name = \"usb3\",\n\t.num_lanes = ARRAY_SIZE(tegra194_usb3_lanes),\n\t.lanes = tegra194_usb3_lanes,\n\t.ops = &tegra186_usb3_pad_ops,\n};\n\nstatic const struct tegra_xusb_pad_soc * const tegra194_pads[] = {\n\t&tegra194_usb2_pad,\n\t&tegra194_usb3_pad,\n};\n\nconst struct tegra_xusb_padctl_soc tegra194_xusb_padctl_soc = {\n\t.num_pads = ARRAY_SIZE(tegra194_pads),\n\t.pads = tegra194_pads,\n\t.ports = {\n\t\t.usb2 = {\n\t\t\t.ops = &tegra186_usb2_port_ops,\n\t\t\t.count = 4,\n\t\t},\n\t\t.usb3 = {\n\t\t\t.ops = &tegra186_usb3_port_ops,\n\t\t\t.count = 4,\n\t\t},\n\t},\n\t.ops = &tegra186_xusb_padctl_ops,\n\t.supply_names = tegra194_xusb_padctl_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra194_xusb_padctl_supply_names),\n\t.supports_gen2 = true,\n\t.poll_trk_completed = true,\n};\nEXPORT_SYMBOL_GPL(tegra194_xusb_padctl_soc);\n\nconst struct tegra_xusb_padctl_soc tegra234_xusb_padctl_soc = {\n\t.num_pads = ARRAY_SIZE(tegra194_pads),\n\t.pads = tegra194_pads,\n\t.ports = {\n\t\t.usb2 = {\n\t\t\t.ops = &tegra186_usb2_port_ops,\n\t\t\t.count = 4,\n\t\t},\n\t\t.usb3 = {\n\t\t\t.ops = &tegra186_usb3_port_ops,\n\t\t\t.count = 4,\n\t\t},\n\t},\n\t.ops = &tegra186_xusb_padctl_ops,\n\t.supply_names = tegra194_xusb_padctl_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra194_xusb_padctl_supply_names),\n\t.supports_gen2 = true,\n\t.poll_trk_completed = true,\n\t.trk_hw_mode = true,\n\t.supports_lp_cfg_en = true,\n};\nEXPORT_SYMBOL_GPL(tegra234_xusb_padctl_soc);\n#endif\n\nMODULE_AUTHOR(\"JC Kuo <jckuo@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra186 XUSB Pad Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}