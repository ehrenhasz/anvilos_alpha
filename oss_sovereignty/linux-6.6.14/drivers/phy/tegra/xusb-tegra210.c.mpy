{
  "module_name": "xusb-tegra210.c",
  "hash_id": "a2d918466edcf7238239fb7bcd6d87dd46b9099f3dde755131e469408bb5de8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/tegra/xusb-tegra210.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk/tegra.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"xusb.h\"\n\n#define FUSE_SKU_CALIB_HS_CURR_LEVEL_PADX_SHIFT(x) \\\n\t\t\t\t\t((x) ? (11 + ((x) - 1) * 6) : 0)\n#define FUSE_SKU_CALIB_HS_CURR_LEVEL_PAD_MASK 0x3f\n#define FUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_SHIFT 7\n#define FUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_MASK 0xf\n\n#define FUSE_USB_CALIB_EXT_RPD_CTRL_SHIFT 0\n#define FUSE_USB_CALIB_EXT_RPD_CTRL_MASK 0x1f\n\n#define XUSB_PADCTL_USB2_PAD_MUX 0x004\n#define XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_SHIFT 16\n#define XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_MASK 0x3\n#define XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_XUSB 0x1\n#define XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_SHIFT 18\n#define XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_MASK 0x3\n#define XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_XUSB 0x1\n\n#define XUSB_PADCTL_USB2_PORT_CAP 0x008\n#define XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_DISABLED(x) (0x0 << ((x) * 4))\n#define XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_HOST(x) (0x1 << ((x) * 4))\n#define XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_DEVICE(x) (0x2 << ((x) * 4))\n#define XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_OTG(x) (0x3 << ((x) * 4))\n#define XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_MASK(x) (0x3 << ((x) * 4))\n\n#define XUSB_PADCTL_SS_PORT_MAP 0x014\n#define XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(x) (1 << (((x) * 5) + 4))\n#define XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_SHIFT(x) ((x) * 5)\n#define XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(x) (0x7 << ((x) * 5))\n#define XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(x, v) (((v) & 0x7) << ((x) * 5))\n#define XUSB_PADCTL_SS_PORT_MAP_PORT_DISABLED 0x7\n\n#define XUSB_PADCTL_ELPG_PROGRAM_0 0x20\n#define   USB2_PORT_WAKE_INTERRUPT_ENABLE(x)      BIT((x))\n#define   USB2_PORT_WAKEUP_EVENT(x)               BIT((x) + 7)\n#define   SS_PORT_WAKE_INTERRUPT_ENABLE(x)        BIT((x) + 14)\n#define   SS_PORT_WAKEUP_EVENT(x)                 BIT((x) + 21)\n#define   USB2_HSIC_PORT_WAKE_INTERRUPT_ENABLE(x) BIT((x) + 28)\n#define   USB2_HSIC_PORT_WAKEUP_EVENT(x)          BIT((x) + 30)\n#define   ALL_WAKE_EVENTS ( \\\n\t\tUSB2_PORT_WAKEUP_EVENT(0) | USB2_PORT_WAKEUP_EVENT(1) | \\\n\t\tUSB2_PORT_WAKEUP_EVENT(2) | USB2_PORT_WAKEUP_EVENT(3) | \\\n\t\tSS_PORT_WAKEUP_EVENT(0) | SS_PORT_WAKEUP_EVENT(1) | \\\n\t\tSS_PORT_WAKEUP_EVENT(2) | SS_PORT_WAKEUP_EVENT(3) | \\\n\t\tUSB2_HSIC_PORT_WAKEUP_EVENT(0))\n\n#define XUSB_PADCTL_ELPG_PROGRAM1 0x024\n#define XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_VCORE_DOWN (1 << 31)\n#define XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN_EARLY (1 << 30)\n#define XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN (1 << 29)\n#define XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_VCORE_DOWN(x) (1 << (2 + (x) * 3))\n#define XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(x) \\\n\t\t\t\t\t\t\t(1 << (1 + (x) * 3))\n#define XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(x) (1 << ((x) * 3))\n\n#define XUSB_PADCTL_USB3_PAD_MUX 0x028\n#define XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(x) (1 << (1 + (x)))\n#define XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(x) (1 << (8 + (x)))\n\n#define XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPADX_CTL0(x) (0x080 + (x) * 0x40)\n#define XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL0_ZIP (1 << 18)\n#define XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL0_ZIN (1 << 22)\n\n#define XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPADX_CTL1(x) (0x084 + (x) * 0x40)\n#define XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_SHIFT 7\n#define XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_MASK 0x3\n#define XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_VAL 0x1\n#define XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_FIX18 (1 << 6)\n\n#define XUSB_PADCTL_USB2_OTG_PADX_CTL0(x) (0x088 + (x) * 0x40)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD_ZI (1 << 29)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD2 (1 << 27)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD (1 << 26)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT 0\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_MASK 0x3f\n\n#define XUSB_PADCTL_USB2_OTG_PADX_CTL1(x) (0x08c + (x) * 0x40)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_RPD_CTRL_SHIFT 26\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_RPD_CTRL_MASK 0x1f\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT 3\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_MASK 0xf\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DR (1 << 2)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DISC_OVRD (1 << 1)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_CHRP_OVRD (1 << 0)\n#define   RPD_CTRL(x)                      (((x) & 0x1f) << 26)\n#define   RPD_CTRL_VALUE(x)                (((x) >> 26) & 0x1f)\n\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0 0x284\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD (1 << 11)\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT 3\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_MASK 0x7\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_VAL 0x7\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT 0\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_MASK 0x7\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_VAL 0x2\n\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1 0x288\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1_PD_TRK (1 << 26)\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_SHIFT 19\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_MASK 0x7f\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_VAL 0x0a\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_SHIFT 12\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_MASK 0x7f\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_VAL 0x1e\n#define   TCTRL_VALUE(x)                (((x) & 0x3f) >> 0)\n#define   PCTRL_VALUE(x)                (((x) >> 6) & 0x3f)\n\n#define XUSB_PADCTL_HSIC_PADX_CTL0(x) (0x300 + (x) * 0x20)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_RPU_STROBE (1 << 18)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA1 (1 << 17)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA0 (1 << 16)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_RPD_STROBE (1 << 15)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA1 (1 << 14)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA0 (1 << 13)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_STROBE (1 << 9)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA1 (1 << 8)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA0 (1 << 7)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_STROBE (1 << 6)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA1 (1 << 5)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA0 (1 << 4)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_STROBE (1 << 3)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA1 (1 << 2)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA0 (1 << 1)\n\n#define XUSB_PADCTL_HSIC_PADX_CTL1(x) (0x304 + (x) * 0x20)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_TX_RTUNEP_SHIFT 0\n#define XUSB_PADCTL_HSIC_PAD_CTL1_TX_RTUNEP_MASK 0xf\n\n#define XUSB_PADCTL_HSIC_PADX_CTL2(x) (0x308 + (x) * 0x20)\n#define XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT 8\n#define XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_MASK 0xf\n#define XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT 0\n#define XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_MASK 0xff\n\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL 0x340\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL_PD_TRK (1 << 19)\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_SHIFT 12\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_MASK 0x7f\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_VAL 0x0a\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_SHIFT 5\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_MASK 0x7f\n#define XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_VAL 0x1e\n\n#define XUSB_PADCTL_HSIC_STRB_TRIM_CONTROL 0x344\n\n#define XUSB_PADCTL_UPHY_PLL_P0_CTL1 0x360\n#define XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT 20\n#define XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_MASK 0xff\n#define XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_USB_VAL 0x19\n#define XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SATA_VAL 0x1e\n#define XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_SHIFT 16\n#define XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_MASK 0x3\n#define XUSB_PADCTL_UPHY_PLL_CTL1_LOCKDET_STATUS (1 << 15)\n#define XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD (1 << 4)\n#define XUSB_PADCTL_UPHY_PLL_CTL1_ENABLE (1 << 3)\n#define XUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_SHIFT 1\n#define XUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_MASK 0x3\n#define XUSB_PADCTL_UPHY_PLL_CTL1_IDDQ (1 << 0)\n\n#define XUSB_PADCTL_UPHY_PLL_P0_CTL2 0x364\n#define XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT 4\n#define XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_MASK 0xffffff\n#define XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_VAL 0x136\n#define XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD (1 << 2)\n#define XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE (1 << 1)\n#define XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN (1 << 0)\n\n#define XUSB_PADCTL_UPHY_PLL_P0_CTL4 0x36c\n#define XUSB_PADCTL_UPHY_PLL_CTL4_XDIGCLK_EN (1 << 19)\n#define XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_EN (1 << 15)\n#define XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT 12\n#define XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_MASK 0x3\n#define XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_USB_VAL 0x2\n#define XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SATA_VAL 0x0\n#define XUSB_PADCTL_UPHY_PLL_CTL4_REFCLKBUF_EN (1 << 8)\n#define XUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_SHIFT 4\n#define XUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_MASK 0xf\n\n#define XUSB_PADCTL_UPHY_PLL_P0_CTL5 0x370\n#define XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT 16\n#define XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_MASK 0xff\n#define XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_VAL 0x2a\n\n#define XUSB_PADCTL_UPHY_PLL_P0_CTL8 0x37c\n#define XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE (1 << 31)\n#define XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD (1 << 15)\n#define XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN (1 << 13)\n#define XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN (1 << 12)\n\n#define XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL1(x) (0x460 + (x) * 0x40)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_SHIFT 20\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_MASK 0x3\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_VAL 0x1\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_TERM_EN BIT(18)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_MODE_OVRD BIT(13)\n\n#define XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL2(x) (0x464 + (x) * 0x40)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_IDDQ BIT(0)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_IDDQ_OVRD BIT(1)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_SLEEP_MASK GENMASK(5, 4)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_SLEEP_VAL GENMASK(5, 4)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_PWR_OVRD BIT(24)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_IDDQ BIT(8)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_IDDQ_OVRD BIT(9)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_SLEEP_MASK GENMASK(13, 12)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_SLEEP_VAL GENMASK(13, 12)\n#define XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_PWR_OVRD BIT(25)\n\n#define XUSB_PADCTL_UPHY_PLL_S0_CTL1 0x860\n\n#define XUSB_PADCTL_UPHY_PLL_S0_CTL2 0x864\n\n#define XUSB_PADCTL_UPHY_PLL_S0_CTL4 0x86c\n\n#define XUSB_PADCTL_UPHY_PLL_S0_CTL5 0x870\n\n#define XUSB_PADCTL_UPHY_PLL_S0_CTL8 0x87c\n\n#define XUSB_PADCTL_UPHY_MISC_PAD_S0_CTL1 0x960\n#define XUSB_PADCTL_UPHY_MISC_PAD_S0_CTL2 0x964\n\n#define XUSB_PADCTL_UPHY_USB3_PADX_ECTL1(x) (0xa60 + (x) * 0x40)\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_SHIFT 16\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_MASK 0x3\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_VAL 0x2\n\n#define XUSB_PADCTL_UPHY_USB3_PADX_ECTL2(x) (0xa64 + (x) * 0x40)\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_SHIFT 0\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_MASK 0xffff\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_VAL 0x00fc\n\n#define XUSB_PADCTL_UPHY_USB3_PADX_ECTL3(x) (0xa68 + (x) * 0x40)\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL3_RX_DFE_VAL 0xc0077f1f\n\n#define XUSB_PADCTL_UPHY_USB3_PADX_ECTL4(x) (0xa6c + (x) * 0x40)\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_SHIFT 16\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_MASK 0xffff\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_VAL 0x01c7\n\n#define XUSB_PADCTL_UPHY_USB3_PADX_ECTL6(x) (0xa74 + (x) * 0x40)\n#define XUSB_PADCTL_UPHY_USB3_PAD_ECTL6_RX_EQ_CTRL_H_VAL 0xfcf01368\n\n#define XUSB_PADCTL_USB2_VBUS_ID 0xc60\n#define XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_VBUS_ON (1 << 14)\n#define XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_SHIFT 18\n#define XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_MASK 0xf\n#define XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_FLOATING 8\n#define XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_GROUNDED 0\n\n \n#define UTMIP(_port, _offset1, _offset2) \\\n\t\t(((_port) <= 2) ? (_offset1) : (_offset2))\n\n#define PMC_UTMIP_UHSIC_SLEEP_CFG(x)\tUTMIP(x, 0x1fc, 0x4d0)\n#define   UTMIP_MASTER_ENABLE(x)\t\tUTMIP(x, BIT(8 * (x)), BIT(0))\n#define   UTMIP_FSLS_USE_PMC(x)\t\t\tUTMIP(x, BIT(8 * (x) + 1), \\\n\t\t\t\t\t\t\tBIT(1))\n#define   UTMIP_PCTRL_USE_PMC(x)\t\tUTMIP(x, BIT(8 * (x) + 2), \\\n\t\t\t\t\t\t\tBIT(2))\n#define   UTMIP_TCTRL_USE_PMC(x)\t\tUTMIP(x, BIT(8 * (x) + 3), \\\n\t\t\t\t\t\t\tBIT(3))\n#define   UTMIP_WAKE_VAL(_port, _value)\t\t(((_value) & 0xf) << \\\n\t\t\t\t\t(UTMIP(_port, 8 * (_port) + 4, 4)))\n#define   UTMIP_WAKE_VAL_NONE(_port)\t\tUTMIP_WAKE_VAL(_port, 12)\n#define   UTMIP_WAKE_VAL_ANY(_port)\t\tUTMIP_WAKE_VAL(_port, 15)\n\n#define PMC_UTMIP_UHSIC_SLEEP_CFG1\t(0x4d0)\n#define   UTMIP_RPU_SWITC_LOW_USE_PMC_PX(x)\tBIT((x) + 8)\n#define   UTMIP_RPD_CTRL_USE_PMC_PX(x)\t\tBIT((x) + 16)\n\n#define PMC_UTMIP_MASTER_CONFIG\t\t(0x274)\n#define   UTMIP_PWR(x)\t\t\t\tUTMIP(x, BIT(x), BIT(4))\n#define   UHSIC_PWR\t\t\t\tBIT(3)\n\n#define PMC_USB_DEBOUNCE_DEL\t\t(0xec)\n#define   DEBOUNCE_VAL(x)\t\t\t(((x) & 0xffff) << 0)\n#define   UTMIP_LINE_DEB_CNT(x)\t\t\t(((x) & 0xf) << 16)\n#define   UHSIC_LINE_DEB_CNT(x)\t\t\t(((x) & 0xf) << 20)\n\n#define PMC_UTMIP_UHSIC_FAKE(x)\t\tUTMIP(x, 0x218, 0x294)\n#define   UTMIP_FAKE_USBOP_VAL(x)\t\tUTMIP(x, BIT(4 * (x)), BIT(8))\n#define   UTMIP_FAKE_USBON_VAL(x)\t\tUTMIP(x, BIT(4 * (x) + 1), \\\n\t\t\t\t\t\t\tBIT(9))\n#define   UTMIP_FAKE_USBOP_EN(x)\t\tUTMIP(x, BIT(4 * (x) + 2), \\\n\t\t\t\t\t\t\tBIT(10))\n#define   UTMIP_FAKE_USBON_EN(x)\t\tUTMIP(x, BIT(4 * (x) + 3), \\\n\t\t\t\t\t\t\tBIT(11))\n\n#define PMC_UTMIP_UHSIC_SLEEPWALK_CFG(x)\tUTMIP(x, 0x200, 0x288)\n#define   UTMIP_LINEVAL_WALK_EN(x)\t\tUTMIP(x, BIT(8 * (x) + 7), \\\n\t\t\t\t\t\t\tBIT(15))\n\n#define PMC_USB_AO\t\t\t(0xf0)\n#define   USBOP_VAL_PD(x)\t\t\tUTMIP(x, BIT(4 * (x)), BIT(20))\n#define   USBON_VAL_PD(x)\t\t\tUTMIP(x, BIT(4 * (x) + 1), \\\n\t\t\t\t\t\t\tBIT(21))\n#define   STROBE_VAL_PD\t\t\t\tBIT(12)\n#define   DATA0_VAL_PD\t\t\t\tBIT(13)\n#define   DATA1_VAL_PD\t\t\t\tBIT(24)\n\n#define PMC_UTMIP_UHSIC_SAVED_STATE(x)\tUTMIP(x, 0x1f0, 0x280)\n#define   SPEED(_port, _value)\t\t\t(((_value) & 0x3) << \\\n\t\t\t\t\t\t(UTMIP(_port, 8 * (_port), 8)))\n#define   UTMI_HS(_port)\t\t\tSPEED(_port, 0)\n#define   UTMI_FS(_port)\t\t\tSPEED(_port, 1)\n#define   UTMI_LS(_port)\t\t\tSPEED(_port, 2)\n#define   UTMI_RST(_port)\t\t\tSPEED(_port, 3)\n\n#define PMC_UTMIP_UHSIC_TRIGGERS\t\t(0x1ec)\n#define   UTMIP_CLR_WALK_PTR(x)\t\t\tUTMIP(x, BIT(x), BIT(16))\n#define   UTMIP_CAP_CFG(x)\t\t\tUTMIP(x, BIT((x) + 4), BIT(17))\n#define   UTMIP_CLR_WAKE_ALARM(x)\t\tUTMIP(x, BIT((x) + 12), \\\n\t\t\t\t\t\t\tBIT(19))\n#define   UHSIC_CLR_WALK_PTR\t\t\tBIT(3)\n#define   UHSIC_CLR_WAKE_ALARM\t\t\tBIT(15)\n\n#define PMC_UTMIP_SLEEPWALK_PX(x)\tUTMIP(x, 0x204 + (4 * (x)), \\\n\t\t\t\t\t\t\t0x4e0)\n \n#define   UTMIP_USBOP_RPD_A\t\t\tBIT(0)\n#define   UTMIP_USBON_RPD_A\t\t\tBIT(1)\n#define   UTMIP_AP_A\t\t\t\tBIT(4)\n#define   UTMIP_AN_A\t\t\t\tBIT(5)\n#define   UTMIP_HIGHZ_A\t\t\t\tBIT(6)\n \n#define   UTMIP_USBOP_RPD_B\t\t\tBIT(8)\n#define   UTMIP_USBON_RPD_B\t\t\tBIT(9)\n#define   UTMIP_AP_B\t\t\t\tBIT(12)\n#define   UTMIP_AN_B\t\t\t\tBIT(13)\n#define   UTMIP_HIGHZ_B\t\t\t\tBIT(14)\n \n#define   UTMIP_USBOP_RPD_C\t\t\tBIT(16)\n#define   UTMIP_USBON_RPD_C\t\t\tBIT(17)\n#define   UTMIP_AP_C\t\t\t\tBIT(20)\n#define   UTMIP_AN_C\t\t\t\tBIT(21)\n#define   UTMIP_HIGHZ_C\t\t\t\tBIT(22)\n \n#define   UTMIP_USBOP_RPD_D\t\t\tBIT(24)\n#define   UTMIP_USBON_RPD_D\t\t\tBIT(25)\n#define   UTMIP_AP_D\t\t\t\tBIT(28)\n#define   UTMIP_AN_D\t\t\t\tBIT(29)\n#define   UTMIP_HIGHZ_D\t\t\t\tBIT(30)\n\n#define PMC_UTMIP_UHSIC_LINE_WAKEUP\t(0x26c)\n#define   UTMIP_LINE_WAKEUP_EN(x)\t\tUTMIP(x, BIT(x), BIT(4))\n#define   UHSIC_LINE_WAKEUP_EN\t\t\tBIT(3)\n\n#define PMC_UTMIP_TERM_PAD_CFG\t\t(0x1f8)\n#define   PCTRL_VAL(x)\t\t\t\t(((x) & 0x3f) << 1)\n#define   TCTRL_VAL(x)\t\t\t\t(((x) & 0x3f) << 7)\n\n#define PMC_UTMIP_PAD_CFGX(x)\t\t(0x4c0 + (4 * (x)))\n#define   RPD_CTRL_PX(x)\t\t\t(((x) & 0x1f) << 22)\n\n#define PMC_UHSIC_SLEEP_CFG\tPMC_UTMIP_UHSIC_SLEEP_CFG(0)\n#define   UHSIC_MASTER_ENABLE\t\t\tBIT(24)\n#define   UHSIC_WAKE_VAL(_value)\t\t(((_value) & 0xf) << 28)\n#define   UHSIC_WAKE_VAL_SD10\t\t\tUHSIC_WAKE_VAL(2)\n#define   UHSIC_WAKE_VAL_NONE\t\t\tUHSIC_WAKE_VAL(12)\n\n#define PMC_UHSIC_FAKE\t\t\tPMC_UTMIP_UHSIC_FAKE(0)\n#define   UHSIC_FAKE_STROBE_VAL\t\t\tBIT(12)\n#define   UHSIC_FAKE_DATA_VAL\t\t\tBIT(13)\n#define   UHSIC_FAKE_STROBE_EN\t\t\tBIT(14)\n#define   UHSIC_FAKE_DATA_EN\t\t\tBIT(15)\n\n#define PMC_UHSIC_SAVED_STATE\t\tPMC_UTMIP_UHSIC_SAVED_STATE(0)\n#define   UHSIC_MODE(_value)\t\t\t(((_value) & 0x1) << 24)\n#define   UHSIC_HS\t\t\t\tUHSIC_MODE(0)\n#define   UHSIC_RST\t\t\t\tUHSIC_MODE(1)\n\n#define PMC_UHSIC_SLEEPWALK_CFG\t\tPMC_UTMIP_UHSIC_SLEEPWALK_CFG(0)\n#define   UHSIC_WAKE_WALK_EN\t\t\tBIT(30)\n#define   UHSIC_LINEVAL_WALK_EN\t\t\tBIT(31)\n\n#define PMC_UHSIC_SLEEPWALK_P0\t\t(0x210)\n#define   UHSIC_DATA0_RPD_A\t\t\tBIT(1)\n#define   UHSIC_DATA0_RPU_B\t\t\tBIT(11)\n#define   UHSIC_DATA0_RPU_C\t\t\tBIT(19)\n#define   UHSIC_DATA0_RPU_D\t\t\tBIT(27)\n#define   UHSIC_STROBE_RPU_A\t\t\tBIT(2)\n#define   UHSIC_STROBE_RPD_B\t\t\tBIT(8)\n#define   UHSIC_STROBE_RPD_C\t\t\tBIT(16)\n#define   UHSIC_STROBE_RPD_D\t\t\tBIT(24)\n\nstruct tegra210_xusb_fuse_calibration {\n\tu32 hs_curr_level[4];\n\tu32 hs_term_range_adj;\n\tu32 rpd_ctrl;\n};\n\nstruct tegra210_xusb_padctl_context {\n\tu32 usb2_pad_mux;\n\tu32 usb2_port_cap;\n\tu32 ss_port_map;\n\tu32 usb3_pad_mux;\n};\n\nstruct tegra210_xusb_padctl {\n\tstruct tegra_xusb_padctl base;\n\tstruct regmap *regmap;\n\n\tstruct tegra210_xusb_fuse_calibration fuse;\n\tstruct tegra210_xusb_padctl_context context;\n};\n\nstatic inline struct tegra210_xusb_padctl *\nto_tegra210_xusb_padctl(struct tegra_xusb_padctl *padctl)\n{\n\treturn container_of(padctl, struct tegra210_xusb_padctl, base);\n}\n\nstatic const struct tegra_xusb_lane_map tegra210_usb3_map[] = {\n\t{ 0, \"pcie\", 6 },\n\t{ 1, \"pcie\", 5 },\n\t{ 2, \"pcie\", 0 },\n\t{ 2, \"pcie\", 3 },\n\t{ 3, \"pcie\", 4 },\n\t{ 3, \"sata\", 0 },\n\t{ 0, NULL,   0 }\n};\n\nstatic int tegra210_usb3_lane_map(struct tegra_xusb_lane *lane)\n{\n\tconst struct tegra_xusb_lane_map *map;\n\n\tfor (map = tegra210_usb3_map; map->type; map++) {\n\t\tif (map->index == lane->index &&\n\t\t    strcmp(map->type, lane->pad->soc->name) == 0) {\n\t\t\tdev_dbg(lane->pad->padctl->dev, \"lane = %s map to port = usb3-%d\\n\",\n\t\t\t\tlane->pad->soc->lanes[lane->index].name, map->port);\n\t\t\treturn map->port;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int tegra210_pex_uphy_enable(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_pcie_pad *pcie = to_pcie_pad(padctl->pcie);\n\tunsigned long timeout;\n\tu32 value;\n\tunsigned int i;\n\tint err;\n\n\tif (pcie->enable)\n\t\treturn 0;\n\n\terr = clk_prepare_enable(pcie->pll);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tegra210_plle_hw_sequence_is_enabled())\n\t\tgoto skip_pll_init;\n\n\terr = reset_control_deassert(pcie->rst);\n\tif (err < 0)\n\t\tgoto disable;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\tvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_MASK <<\n\t\t   XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_VAL <<\n\t\t XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL5);\n\tvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_MASK <<\n\t\t   XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_VAL <<\n\t\t XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL5);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL4);\n\tvalue &= ~((XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_MASK <<\n\t\t    XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT) |\n\t\t   (XUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_MASK <<\n\t\t    XUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_SHIFT));\n\tvalue |= (XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_USB_VAL <<\n\t\t  XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT) |\n\t\t XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL4);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\tvalue &= ~((XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_MASK <<\n\t\t    XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_SHIFT) |\n\t\t   (XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_MASK <<\n\t\t    XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT));\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_USB_VAL <<\n\t\t XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL1_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\tvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_MASK <<\n\t\t   XUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL4);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL4_REFCLKBUF_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL4);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\t\tif (value & XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\t\tif (!(value & XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE))\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_ENABLE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\t\tif (value & XUSB_PADCTL_UPHY_PLL_CTL1_LOCKDET_STATUS)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN |\n\t\t XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\t\tif (value & XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\t\tif (!(value & XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE))\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\n\ttegra210_xusb_pll_hw_control_enable();\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_P0_CTL8);\n\n\tusleep_range(10, 20);\n\n\ttegra210_xusb_pll_hw_sequence_start();\n\nskip_pll_init:\n\tpcie->enable = true;\n\n\tfor (i = 0; i < padctl->pcie->soc->num_lanes; i++) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n\t\tvalue |= XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(i);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\n\t}\n\n\treturn 0;\n\nreset:\n\treset_control_assert(pcie->rst);\ndisable:\n\tclk_disable_unprepare(pcie->pll);\n\treturn err;\n}\n\nstatic void tegra210_pex_uphy_disable(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_pcie_pad *pcie = to_pcie_pad(padctl->pcie);\n\tu32 value;\n\tunsigned int i;\n\n\tif (WARN_ON(!pcie->enable))\n\t\treturn;\n\n\tpcie->enable = false;\n\n\tfor (i = 0; i < padctl->pcie->soc->num_lanes; i++) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n\t\tvalue &= ~XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(i);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\n\t}\n\n\tclk_disable_unprepare(pcie->pll);\n}\n\n \nstatic int tegra210_sata_uphy_enable(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_sata_pad *sata = to_sata_pad(padctl->sata);\n\tstruct tegra_xusb_lane *lane = tegra_xusb_find_lane(padctl, \"sata\", 0);\n\tunsigned long timeout;\n\tu32 value;\n\tunsigned int i;\n\tint err;\n\tbool usb;\n\n\tif (sata->enable)\n\t\treturn 0;\n\n\tif (IS_ERR(lane))\n\t\treturn 0;\n\n\tif (tegra210_plle_hw_sequence_is_enabled())\n\t\tgoto skip_pll_init;\n\n\tusb = tegra_xusb_lane_check(lane, \"usb3-ss\");\n\n\terr = clk_prepare_enable(sata->pll);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = reset_control_deassert(sata->rst);\n\tif (err < 0)\n\t\tgoto disable;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\tvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_MASK <<\n\t\t   XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_VAL <<\n\t\t XUSB_PADCTL_UPHY_PLL_CTL2_CAL_CTRL_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL5);\n\tvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_MASK <<\n\t\t   XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_VAL <<\n\t\t XUSB_PADCTL_UPHY_PLL_CTL5_DCO_CTRL_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL5);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL4);\n\tvalue &= ~((XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_MASK <<\n\t\t    XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT) |\n\t\t   (XUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_MASK <<\n\t\t    XUSB_PADCTL_UPHY_PLL_CTL4_REFCLK_SEL_SHIFT));\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_EN;\n\n\tif (usb)\n\t\tvalue |= (XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_USB_VAL <<\n\t\t\t  XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT);\n\telse\n\t\tvalue |= (XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SATA_VAL <<\n\t\t\t  XUSB_PADCTL_UPHY_PLL_CTL4_TXCLKREF_SEL_SHIFT);\n\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL4_XDIGCLK_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL4);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\tvalue &= ~((XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_MASK <<\n\t\t    XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_MDIV_SHIFT) |\n\t\t   (XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_MASK <<\n\t\t    XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT));\n\n\tif (usb)\n\t\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_USB_VAL <<\n\t\t\t XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT;\n\telse\n\t\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SATA_VAL <<\n\t\t\t XUSB_PADCTL_UPHY_PLL_CTL1_FREQ_NDIV_SHIFT;\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL1_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\tvalue &= ~(XUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_MASK <<\n\t\t   XUSB_PADCTL_UPHY_PLL_CTL1_SLEEP_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL4);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL4_REFCLKBUF_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL4);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\t\tif (value & XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL2_CAL_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\t\tif (!(value & XUSB_PADCTL_UPHY_PLL_CTL2_CAL_DONE))\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL1_ENABLE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\t\tif (value & XUSB_PADCTL_UPHY_PLL_CTL1_LOCKDET_STATUS)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\tvalue |= XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN |\n\t\t XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\t\tif (value & XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\t\tif (!(value & XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_DONE))\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (time_after_eq(jiffies, timeout)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto reset;\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_CLK_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\n\ttegra210_sata_pll_hw_control_enable();\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL1_PWR_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL2_CAL_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\tvalue &= ~XUSB_PADCTL_UPHY_PLL_CTL8_RCAL_OVRD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_PLL_S0_CTL8);\n\n\tusleep_range(10, 20);\n\n\ttegra210_sata_pll_hw_sequence_start();\n\nskip_pll_init:\n\tsata->enable = true;\n\n\tfor (i = 0; i < padctl->sata->soc->num_lanes; i++) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n\t\tvalue |= XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(i);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\n\t}\n\n\treturn 0;\n\nreset:\n\treset_control_assert(sata->rst);\ndisable:\n\tclk_disable_unprepare(sata->pll);\n\treturn err;\n}\n\nstatic void tegra210_sata_uphy_disable(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra_xusb_sata_pad *sata = to_sata_pad(padctl->sata);\n\tu32 value;\n\tunsigned int i;\n\n\tif (WARN_ON(!sata->enable))\n\t\treturn;\n\n\tsata->enable = false;\n\n\tfor (i = 0; i < padctl->sata->soc->num_lanes; i++) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n\t\tvalue &= ~XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(i);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\n\t}\n\n\tclk_disable_unprepare(sata->pll);\n}\n\nstatic void tegra210_aux_mux_lp0_clamp_disable(struct tegra_xusb_padctl *padctl)\n{\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN_EARLY;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_VCORE_DOWN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n}\n\nstatic void tegra210_aux_mux_lp0_clamp_enable(struct tegra_xusb_padctl *padctl)\n{\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_VCORE_DOWN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN_EARLY;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_AUX_MUX_LP0_CLAMP_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n}\n\nstatic int tegra210_uphy_init(struct tegra_xusb_padctl *padctl)\n{\n\tif (padctl->pcie)\n\t\ttegra210_pex_uphy_enable(padctl);\n\n\tif (padctl->sata)\n\t\ttegra210_sata_uphy_enable(padctl);\n\n\tif (!tegra210_plle_hw_sequence_is_enabled())\n\t\ttegra210_plle_hw_sequence_start();\n\telse\n\t\tdev_dbg(padctl->dev, \"PLLE is already in HW control\\n\");\n\n\ttegra210_aux_mux_lp0_clamp_disable(padctl);\n\n\treturn 0;\n}\n\nstatic void __maybe_unused\ntegra210_uphy_deinit(struct tegra_xusb_padctl *padctl)\n{\n\ttegra210_aux_mux_lp0_clamp_enable(padctl);\n\n\tif (padctl->sata)\n\t\ttegra210_sata_uphy_disable(padctl);\n\n\tif (padctl->pcie)\n\t\ttegra210_pex_uphy_disable(padctl);\n}\n\nstatic int tegra210_hsic_set_idle(struct tegra_xusb_padctl *padctl,\n\t\t\t\t  unsigned int index, bool idle)\n{\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL0(index));\n\n\tvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA0 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA1 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_RPD_STROBE);\n\n\tif (idle)\n\t\tvalue |= XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA0 |\n\t\t\t XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA1 |\n\t\t\t XUSB_PADCTL_HSIC_PAD_CTL0_RPU_STROBE;\n\telse\n\t\tvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA0 |\n\t\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA1 |\n\t\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_RPU_STROBE);\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL0(index));\n\n\treturn 0;\n}\n\nstatic int tegra210_usb3_enable_phy_sleepwalk(struct tegra_xusb_lane *lane,\n\t\t\t\t\t      enum usb_device_speed speed)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint port = tegra210_usb3_lane_map(lane);\n\tstruct device *dev = padctl->dev;\n\tu32 value;\n\n\tif (port < 0) {\n\t\tdev_err(dev, \"invalid usb3 port number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(250, 350);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra210_usb3_disable_phy_sleepwalk(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint port = tegra210_usb3_lane_map(lane);\n\tstruct device *dev = padctl->dev;\n\tu32 value;\n\n\tif (port < 0) {\n\t\tdev_err(dev, \"invalid usb3 port number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra210_usb3_enable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint port = tegra210_usb3_lane_map(lane);\n\tstruct device *dev = padctl->dev;\n\tu32 value;\n\n\tif (port < 0) {\n\t\tdev_err(dev, \"invalid usb3 port number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= SS_PORT_WAKEUP_EVENT(port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= SS_PORT_WAKE_INTERRUPT_ENABLE(port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra210_usb3_disable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint port = tegra210_usb3_lane_map(lane);\n\tstruct device *dev = padctl->dev;\n\tu32 value;\n\n\tif (port < 0) {\n\t\tdev_err(dev, \"invalid usb3 port number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue &= ~SS_PORT_WAKE_INTERRUPT_ENABLE(port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= SS_PORT_WAKEUP_EVENT(port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic bool tegra210_usb3_phy_remote_wake_detected(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint index = tegra210_usb3_lane_map(lane);\n\tu32 value;\n\n\tif (index < 0)\n\t\treturn false;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tif ((value & SS_PORT_WAKE_INTERRUPT_ENABLE(index)) && (value & SS_PORT_WAKEUP_EVENT(index)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tegra210_utmi_enable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_PORT_WAKEUP_EVENT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_PORT_WAKE_INTERRUPT_ENABLE(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra210_utmi_disable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue &= ~USB2_PORT_WAKE_INTERRUPT_ENABLE(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_PORT_WAKEUP_EVENT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic bool tegra210_utmi_phy_remote_wake_detected(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tif ((value & USB2_PORT_WAKE_INTERRUPT_ENABLE(index)) &&\n\t    (value & USB2_PORT_WAKEUP_EVENT(index)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int tegra210_hsic_enable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_HSIC_PORT_WAKEUP_EVENT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_HSIC_PORT_WAKE_INTERRUPT_ENABLE(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra210_hsic_disable_phy_wake(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue &= ~USB2_HSIC_PORT_WAKE_INTERRUPT_ENABLE(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tusleep_range(10, 20);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tvalue &= ~ALL_WAKE_EVENTS;\n\tvalue |= USB2_HSIC_PORT_WAKEUP_EVENT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM_0);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic bool tegra210_hsic_phy_remote_wake_detected(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM_0);\n\tif ((value & USB2_HSIC_PORT_WAKE_INTERRUPT_ENABLE(index)) &&\n\t    (value & USB2_HSIC_PORT_WAKEUP_EVENT(index)))\n\t\treturn true;\n\n\treturn false;\n}\n\n#define padctl_pmc_readl(_priv, _offset)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\t\\\n\tu32 value;\t\t\t\t\t\t\t\t\t\\\n\tWARN(regmap_read(_priv->regmap, _offset, &value), \"read %s failed\\n\", #_offset);\\\n\tvalue;\t\t\t\t\t\t\t\t\t\t\\\n})\n\n#define padctl_pmc_writel(_priv, _value, _offset)\t\t\t\t\t\\\n\tWARN(regmap_write(_priv->regmap, _offset, _value), \"write %s failed\\n\", #_offset)\n\nstatic int tegra210_pmc_utmi_enable_phy_sleepwalk(struct tegra_xusb_lane *lane,\n\t\t\t\t\t\t  enum usb_device_speed speed)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra210_xusb_padctl *priv = to_tegra210_xusb_padctl(padctl);\n\tunsigned int port = lane->index;\n\tu32 value, tctrl, pctrl, rpd_ctrl;\n\n\tif (!priv->regmap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed > USB_SPEED_HIGH)\n\t\treturn -EINVAL;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\ttctrl = TCTRL_VALUE(value);\n\tpctrl = PCTRL_VALUE(value);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL1(port));\n\trpd_ctrl = RPD_CTRL_VALUE(value);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\tvalue &= ~UTMIP_MASTER_ENABLE(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_MASTER_CONFIG);\n\tvalue |= UTMIP_PWR(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_MASTER_CONFIG);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_USB_DEBOUNCE_DEL);\n\tvalue &= ~UTMIP_LINE_DEB_CNT(~0);\n\tvalue |= UTMIP_LINE_DEB_CNT(0x1);\n\tpadctl_pmc_writel(priv, value, PMC_USB_DEBOUNCE_DEL);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_FAKE(port));\n\tvalue &= ~(UTMIP_FAKE_USBOP_VAL(port) | UTMIP_FAKE_USBON_VAL(port) |\n\t\t   UTMIP_FAKE_USBOP_EN(port) | UTMIP_FAKE_USBON_EN(port));\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_FAKE(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\tvalue &= ~UTMIP_LINE_WAKEUP_EN(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\tvalue &= ~UTMIP_WAKE_VAL(port, ~0);\n\tvalue |= UTMIP_WAKE_VAL_NONE(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_USB_AO);\n\tvalue |= (USBOP_VAL_PD(port) | USBON_VAL_PD(port));\n\tpadctl_pmc_writel(priv, value, PMC_USB_AO);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SAVED_STATE(port));\n\tvalue &= ~SPEED(port, ~0);\n\n\tswitch (speed) {\n\tcase USB_SPEED_HIGH:\n\t\tvalue |= UTMI_HS(port);\n\t\tbreak;\n\n\tcase USB_SPEED_FULL:\n\t\tvalue |= UTMI_FS(port);\n\t\tbreak;\n\n\tcase USB_SPEED_LOW:\n\t\tvalue |= UTMI_LS(port);\n\t\tbreak;\n\n\tdefault:\n\t\tvalue |= UTMI_RST(port);\n\t\tbreak;\n\t}\n\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SAVED_STATE(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEPWALK_CFG(port));\n\tvalue |= UTMIP_LINEVAL_WALK_EN(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEPWALK_CFG(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_TRIGGERS);\n\tvalue |= UTMIP_CLR_WALK_PTR(port) | UTMIP_CLR_WAKE_ALARM(port) | UTMIP_CAP_CFG(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_TRIGGERS);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_TERM_PAD_CFG);\n\tvalue &= ~(TCTRL_VAL(~0) | PCTRL_VAL(~0));\n\tvalue |= (TCTRL_VAL(tctrl) | PCTRL_VAL(pctrl));\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_TERM_PAD_CFG);\n\n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_PAD_CFGX(port));\n\tvalue &= ~RPD_CTRL_PX(~0);\n\tvalue |= RPD_CTRL_PX(rpd_ctrl);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_PAD_CFGX(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_SLEEPWALK_PX(port));\n\tvalue = UTMIP_USBOP_RPD_A | UTMIP_USBOP_RPD_B | UTMIP_USBOP_RPD_C | UTMIP_USBOP_RPD_D;\n\tvalue |= UTMIP_USBON_RPD_A | UTMIP_USBON_RPD_B | UTMIP_USBON_RPD_C | UTMIP_USBON_RPD_D;\n\n\tswitch (speed) {\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_FULL:\n\t\t \n\t\tvalue |= UTMIP_HIGHZ_A;\n\t\tvalue |= UTMIP_AP_A;\n\t\tvalue |= UTMIP_AN_B | UTMIP_AN_C | UTMIP_AN_D;\n\t\tbreak;\n\n\tcase USB_SPEED_LOW:\n\t\t \n\t\tvalue |= UTMIP_HIGHZ_A;\n\t\tvalue |= UTMIP_AN_A;\n\t\tvalue |= UTMIP_AP_B | UTMIP_AP_C | UTMIP_AP_D;\n\t\tbreak;\n\n\tdefault:\n\t\tvalue |= UTMIP_HIGHZ_A | UTMIP_HIGHZ_B | UTMIP_HIGHZ_C | UTMIP_HIGHZ_D;\n\t\tbreak;\n\t}\n\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_SLEEPWALK_PX(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_USB_AO);\n\tvalue &= ~(USBOP_VAL_PD(port) | USBON_VAL_PD(port));\n\tpadctl_pmc_writel(priv, value, PMC_USB_AO);\n\n\tusleep_range(50, 100);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\tvalue |= UTMIP_FSLS_USE_PMC(port) | UTMIP_PCTRL_USE_PMC(port) | UTMIP_TCTRL_USE_PMC(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG1);\n\tvalue |= UTMIP_RPD_CTRL_USE_PMC_PX(port) | UTMIP_RPU_SWITC_LOW_USE_PMC_PX(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG1);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\tvalue &= ~UTMIP_WAKE_VAL(port, ~0);\n\tvalue |= UTMIP_WAKE_VAL_ANY(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\tvalue |= UTMIP_MASTER_ENABLE(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\tvalue |= UTMIP_LINE_WAKEUP_EN(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\n\treturn 0;\n}\n\nstatic int tegra210_pmc_utmi_disable_phy_sleepwalk(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra210_xusb_padctl *priv = to_tegra210_xusb_padctl(padctl);\n\tunsigned int port = lane->index;\n\tu32 value;\n\n\tif (!priv->regmap)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\tvalue &= ~UTMIP_MASTER_ENABLE(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\tvalue &= ~UTMIP_LINE_WAKEUP_EN(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\tvalue &= ~(UTMIP_FSLS_USE_PMC(port) | UTMIP_PCTRL_USE_PMC(port) |\n\t\t   UTMIP_TCTRL_USE_PMC(port));\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG1);\n\tvalue &= ~(UTMIP_RPD_CTRL_USE_PMC_PX(port) | UTMIP_RPU_SWITC_LOW_USE_PMC_PX(port));\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG1);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\tvalue &= ~UTMIP_WAKE_VAL(port, ~0);\n\tvalue |= UTMIP_WAKE_VAL_NONE(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_SLEEP_CFG(port));\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_USB_AO);\n\tvalue |= (USBOP_VAL_PD(port) | USBON_VAL_PD(port));\n\tpadctl_pmc_writel(priv, value, PMC_USB_AO);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_TRIGGERS);\n\tvalue |= UTMIP_CLR_WAKE_ALARM(port);\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_TRIGGERS);\n\n\treturn 0;\n}\n\nstatic int tegra210_pmc_hsic_enable_phy_sleepwalk(struct tegra_xusb_lane *lane,\n\t\t\t\t\t\t  enum usb_device_speed speed)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra210_xusb_padctl *priv = to_tegra210_xusb_padctl(padctl);\n\tu32 value;\n\n\tif (!priv->regmap)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SLEEP_CFG);\n\tvalue &= ~UHSIC_MASTER_ENABLE;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SLEEP_CFG);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_MASTER_CONFIG);\n\tvalue |= UHSIC_PWR;\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_MASTER_CONFIG);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_USB_DEBOUNCE_DEL);\n\tvalue &= ~UHSIC_LINE_DEB_CNT(~0);\n\tvalue |= UHSIC_LINE_DEB_CNT(0x1);\n\tpadctl_pmc_writel(priv, value, PMC_USB_DEBOUNCE_DEL);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_FAKE);\n\tvalue &= ~(UHSIC_FAKE_STROBE_VAL | UHSIC_FAKE_DATA_VAL |\n\t\t   UHSIC_FAKE_STROBE_EN | UHSIC_FAKE_DATA_EN);\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_FAKE);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\tvalue &= ~UHSIC_LINE_WAKEUP_EN;\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SLEEP_CFG);\n\tvalue &= ~UHSIC_WAKE_VAL(~0);\n\tvalue |= UHSIC_WAKE_VAL_NONE;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SLEEP_CFG);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_USB_AO);\n\tvalue |= STROBE_VAL_PD | DATA0_VAL_PD | DATA1_VAL_PD;\n\tpadctl_pmc_writel(priv, value, PMC_USB_AO);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SAVED_STATE);\n\tvalue &= ~UHSIC_MODE(~0);\n\tvalue |= UHSIC_HS;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SAVED_STATE);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SLEEPWALK_CFG);\n\tvalue |= UHSIC_WAKE_WALK_EN | UHSIC_LINEVAL_WALK_EN;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SLEEPWALK_CFG);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_TRIGGERS);\n\tvalue |= UHSIC_CLR_WALK_PTR | UHSIC_CLR_WAKE_ALARM;\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_TRIGGERS);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SLEEPWALK_P0);\n\tvalue = UHSIC_DATA0_RPD_A | UHSIC_DATA0_RPU_B | UHSIC_DATA0_RPU_C | UHSIC_DATA0_RPU_D |\n\t\tUHSIC_STROBE_RPU_A | UHSIC_STROBE_RPD_B | UHSIC_STROBE_RPD_C | UHSIC_STROBE_RPD_D;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SLEEPWALK_P0);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_USB_AO);\n\tvalue &= ~(STROBE_VAL_PD | DATA0_VAL_PD | DATA1_VAL_PD);\n\tpadctl_pmc_writel(priv, value, PMC_USB_AO);\n\n\tusleep_range(50, 100);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SLEEP_CFG);\n\tvalue &= ~UHSIC_WAKE_VAL(~0);\n\tvalue |= UHSIC_WAKE_VAL_SD10;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SLEEP_CFG);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SLEEP_CFG);\n\tvalue |= UHSIC_MASTER_ENABLE;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SLEEP_CFG);\n\n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\tvalue |= UHSIC_LINE_WAKEUP_EN;\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\n\treturn 0;\n}\n\nstatic int tegra210_pmc_hsic_disable_phy_sleepwalk(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra210_xusb_padctl *priv = to_tegra210_xusb_padctl(padctl);\n\tu32 value;\n\n\tif (!priv->regmap)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SLEEP_CFG);\n\tvalue &= ~UHSIC_MASTER_ENABLE;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SLEEP_CFG);\n\n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\tvalue &= ~UHSIC_LINE_WAKEUP_EN;\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_LINE_WAKEUP);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UHSIC_SLEEP_CFG);\n\tvalue &= ~UHSIC_WAKE_VAL(~0);\n\tvalue |= UHSIC_WAKE_VAL_NONE;\n\tpadctl_pmc_writel(priv, value, PMC_UHSIC_SLEEP_CFG);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_USB_AO);\n\tvalue |= STROBE_VAL_PD | DATA0_VAL_PD | DATA1_VAL_PD;\n\tpadctl_pmc_writel(priv, value, PMC_USB_AO);\n\n\t \n\tvalue = padctl_pmc_readl(priv, PMC_UTMIP_UHSIC_TRIGGERS);\n\tvalue |= UHSIC_CLR_WAKE_ALARM;\n\tpadctl_pmc_writel(priv, value, PMC_UTMIP_UHSIC_TRIGGERS);\n\n\treturn 0;\n}\n\nstatic int tegra210_usb3_set_lfps_detect(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t unsigned int index, bool enable)\n{\n\tstruct tegra_xusb_port *port;\n\tstruct tegra_xusb_lane *lane;\n\tu32 value, offset;\n\n\tport = tegra_xusb_find_port(padctl, \"usb3\", index);\n\tif (!port)\n\t\treturn -ENODEV;\n\n\tlane = port->lane;\n\n\tif (lane->pad == padctl->pcie)\n\t\toffset = XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL1(lane->index);\n\telse\n\t\toffset = XUSB_PADCTL_UPHY_MISC_PAD_S0_CTL1;\n\n\tvalue = padctl_readl(padctl, offset);\n\n\tvalue &= ~((XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_MASK <<\n\t\t    XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_SHIFT) |\n\t\t   XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_TERM_EN |\n\t\t   XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_MODE_OVRD);\n\n\tif (!enable) {\n\t\tvalue |= (XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_VAL <<\n\t\t\t  XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_IDLE_MODE_SHIFT) |\n\t\t\t XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_TERM_EN |\n\t\t\t XUSB_PADCTL_UPHY_MISC_PAD_CTL1_AUX_RX_MODE_OVRD;\n\t}\n\n\tpadctl_writel(padctl, value, offset);\n\n\treturn 0;\n}\n\n#define TEGRA210_LANE(_name, _offset, _shift, _mask, _type)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.offset = _offset,\t\t\t\t\t\\\n\t\t.shift = _shift,\t\t\t\t\t\\\n\t\t.mask = _mask,\t\t\t\t\t\t\\\n\t\t.num_funcs = ARRAY_SIZE(tegra210_##_type##_functions),\t\\\n\t\t.funcs = tegra210_##_type##_functions,\t\t\t\\\n\t}\n\nstatic const char *tegra210_usb2_functions[] = {\n\t\"snps\",\n\t\"xusb\",\n\t\"uart\"\n};\n\nstatic const struct tegra_xusb_lane_soc tegra210_usb2_lanes[] = {\n\tTEGRA210_LANE(\"usb2-0\", 0x004,  0, 0x3, usb2),\n\tTEGRA210_LANE(\"usb2-1\", 0x004,  2, 0x3, usb2),\n\tTEGRA210_LANE(\"usb2-2\", 0x004,  4, 0x3, usb2),\n\tTEGRA210_LANE(\"usb2-3\", 0x004,  6, 0x3, usb2),\n};\n\nstatic struct tegra_xusb_lane *\ntegra210_usb2_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_usb2_lane *usb2;\n\tint err;\n\n\tusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&usb2->base.list);\n\tusb2->base.soc = &pad->soc->lanes[index];\n\tusb2->base.index = index;\n\tusb2->base.pad = pad;\n\tusb2->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&usb2->base, np);\n\tif (err < 0) {\n\t\tkfree(usb2);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &usb2->base;\n}\n\nstatic void tegra210_usb2_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\n\n\tkfree(usb2);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra210_usb2_lane_ops = {\n\t.probe = tegra210_usb2_lane_probe,\n\t.remove = tegra210_usb2_lane_remove,\n\t.enable_phy_sleepwalk = tegra210_pmc_utmi_enable_phy_sleepwalk,\n\t.disable_phy_sleepwalk = tegra210_pmc_utmi_disable_phy_sleepwalk,\n\t.enable_phy_wake = tegra210_utmi_enable_phy_wake,\n\t.disable_phy_wake = tegra210_utmi_disable_phy_wake,\n\t.remote_wake_detected = tegra210_utmi_phy_remote_wake_detected,\n};\n\nstatic int tegra210_usb2_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tstruct tegra_xusb_usb2_port *port;\n\tint err;\n\tu32 value;\n\n\tport = tegra_xusb_find_usb2_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(&phy->dev, \"no port found for USB2 lane %u\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tif (port->supply && port->mode == USB_DR_MODE_HOST) {\n\t\terr = regulator_enable(port->supply);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmutex_lock(&padctl->lock);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PAD_MUX);\n\tvalue &= ~(XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_MASK <<\n\t\t   XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_SHIFT);\n\tvalue |= XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_XUSB <<\n\t\t XUSB_PADCTL_USB2_PAD_MUX_USB2_BIAS_PAD_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_PAD_MUX);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra210_usb2_phy_exit(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb2_port *port;\n\tint err;\n\n\tport = tegra_xusb_find_usb2_port(padctl, lane->index);\n\tif (!port) {\n\t\tdev_err(&phy->dev, \"no port found for USB2 lane %u\\n\", lane->index);\n\t\treturn -ENODEV;\n\t}\n\n\tif (port->supply && port->mode == USB_DR_MODE_HOST) {\n\t\terr = regulator_disable(port->supply);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra210_xusb_padctl_vbus_override(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t      bool status)\n{\n\tu32 value;\n\n\tdev_dbg(padctl->dev, \"%s vbus override\\n\", status ? \"set\" : \"clear\");\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_VBUS_ID);\n\n\tif (status) {\n\t\tvalue |= XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_VBUS_ON;\n\t\tvalue &= ~(XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_MASK <<\n\t\t\t   XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_SHIFT);\n\t\tvalue |= XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_FLOATING <<\n\t\t\t XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_SHIFT;\n\t} else {\n\t\tvalue &= ~XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_VBUS_ON;\n\t}\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_VBUS_ID);\n\n\treturn 0;\n}\n\nstatic int tegra210_xusb_padctl_id_override(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t    bool status)\n{\n\tu32 value;\n\n\tdev_dbg(padctl->dev, \"%s id override\\n\", status ? \"set\" : \"clear\");\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_VBUS_ID);\n\n\tif (status) {\n\t\tif (value & XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_VBUS_ON) {\n\t\t\tvalue &= ~XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_VBUS_ON;\n\t\t\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_VBUS_ID);\n\t\t\tusleep_range(1000, 2000);\n\n\t\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_VBUS_ID);\n\t\t}\n\n\t\tvalue &= ~(XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_MASK <<\n\t\t\t   XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_SHIFT);\n\t\tvalue |= XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_GROUNDED <<\n\t\t\t XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_SHIFT;\n\t} else {\n\t\tvalue &= ~(XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_MASK <<\n\t\t\t   XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_SHIFT);\n\t\tvalue |= XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_FLOATING <<\n\t\t\t XUSB_PADCTL_USB2_VBUS_ID_OVERRIDE_SHIFT;\n\t}\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_VBUS_ID);\n\n\treturn 0;\n}\n\nstatic int tegra210_usb2_phy_set_mode(struct phy *phy, enum phy_mode mode,\n\t\t\t\t      int submode)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb2_port *port = tegra_xusb_find_usb2_port(padctl,\n\t\t\t\t\t\t\t\tlane->index);\n\tint err = 0;\n\n\tmutex_lock(&padctl->lock);\n\n\tdev_dbg(&port->base.dev, \"%s: mode %d\", __func__, mode);\n\n\tif (mode == PHY_MODE_USB_OTG) {\n\t\tif (submode == USB_ROLE_HOST) {\n\t\t\ttegra210_xusb_padctl_id_override(padctl, true);\n\n\t\t\terr = regulator_enable(port->supply);\n\t\t} else if (submode == USB_ROLE_DEVICE) {\n\t\t\ttegra210_xusb_padctl_vbus_override(padctl, true);\n\t\t} else if (submode == USB_ROLE_NONE) {\n\t\t\t \n\t\t\tif (regulator_is_enabled(port->supply))\n\t\t\t\tregulator_disable(port->supply);\n\n\t\t\ttegra210_xusb_padctl_id_override(padctl, false);\n\t\t\ttegra210_xusb_padctl_vbus_override(padctl, false);\n\t\t}\n\t}\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn err;\n}\n\nstatic int tegra210_usb2_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\n\tstruct tegra_xusb_usb2_pad *pad = to_usb2_pad(lane->pad);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra210_xusb_padctl *priv;\n\tstruct tegra_xusb_usb2_port *port;\n\tunsigned int index = lane->index;\n\tu32 value;\n\tint err;\n\n\tport = tegra_xusb_find_usb2_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(&phy->dev, \"no port found for USB2 lane %u\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = to_tegra210_xusb_padctl(padctl);\n\n\tmutex_lock(&padctl->lock);\n\n\tif (port->usb3_port_fake != -1) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\n\t\tvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(\n\t\t\t\t\tport->usb3_port_fake);\n\t\tvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(\n\t\t\t\t\tport->usb3_port_fake, index);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\t\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_VCORE_DOWN(\n\t\t\t\t\tport->usb3_port_fake);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\t\tusleep_range(100, 200);\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\t\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(\n\t\t\t\t\tport->usb3_port_fake);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\t\tusleep_range(100, 200);\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\t\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(\n\t\t\t\t\tport->usb3_port_fake);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\tvalue &= ~((XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_MASK <<\n\t\t    XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT) |\n\t\t   (XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_MASK <<\n\t\t    XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT));\n\tvalue |= (XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_VAL <<\n\t\t  XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT);\n\n\tif (tegra_sku_info.revision < TEGRA_REVISION_A02)\n\t\tvalue |=\n\t\t\t(XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_VAL <<\n\t\t\tXUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT);\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PORT_CAP);\n\tvalue &= ~XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_MASK(index);\n\tif (port->mode == USB_DR_MODE_UNKNOWN)\n\t\tvalue |= XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_DISABLED(index);\n\telse if (port->mode == USB_DR_MODE_PERIPHERAL)\n\t\tvalue |= XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_DEVICE(index);\n\telse if (port->mode == USB_DR_MODE_HOST)\n\t\tvalue |= XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_HOST(index);\n\telse if (port->mode == USB_DR_MODE_OTG)\n\t\tvalue |= XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_OTG(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_PORT_CAP);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\tvalue &= ~((XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_MASK <<\n\t\t    XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT) |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD2 |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD_ZI);\n\tvalue |= (priv->fuse.hs_curr_level[index] +\n\t\t  usb2->hs_curr_level_offset) <<\n\t\t XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\tvalue &= ~((XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_MASK <<\n\t\t    XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT) |\n\t\t   (XUSB_PADCTL_USB2_OTG_PAD_CTL1_RPD_CTRL_MASK <<\n\t\t    XUSB_PADCTL_USB2_OTG_PAD_CTL1_RPD_CTRL_SHIFT) |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DR |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_CHRP_OVRD |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DISC_OVRD);\n\tvalue |= (priv->fuse.hs_term_range_adj <<\n\t\t  XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT) |\n\t\t (priv->fuse.rpd_ctrl <<\n\t\t  XUSB_PADCTL_USB2_OTG_PAD_CTL1_RPD_CTRL_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\n\tvalue = padctl_readl(padctl,\n\t\t\t     XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPADX_CTL1(index));\n\tvalue &= ~(XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_MASK <<\n\t\t   XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_SHIFT);\n\tif (port->mode == USB_DR_MODE_HOST)\n\t\tvalue |= XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_FIX18;\n\telse\n\t\tvalue |=\n\t\t      XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_VAL <<\n\t\t      XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL1_VREG_LEV_SHIFT;\n\tpadctl_writel(padctl, value,\n\t\t      XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPADX_CTL1(index));\n\n\tif (pad->enable > 0) {\n\t\tpad->enable++;\n\t\tmutex_unlock(&padctl->lock);\n\t\treturn 0;\n\t}\n\n\terr = clk_prepare_enable(pad->clk);\n\tif (err)\n\t\tgoto out;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\tvalue &= ~((XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_MASK <<\n\t\t    XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_SHIFT) |\n\t\t   (XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_MASK <<\n\t\t    XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_SHIFT));\n\tvalue |= (XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_VAL <<\n\t\t  XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_START_TIMER_SHIFT) |\n\t\t (XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_VAL <<\n\t\t  XUSB_PADCTL_USB2_BIAS_PAD_CTL1_TRK_DONE_RESET_TIMER_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\tvalue &= ~XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\n\tudelay(1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\tvalue &= ~XUSB_PADCTL_USB2_BIAS_PAD_CTL1_PD_TRK;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL1);\n\n\tudelay(50);\n\n\tclk_disable_unprepare(pad->clk);\n\n\tpad->enable++;\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n\nout:\n\tmutex_unlock(&padctl->lock);\n\treturn err;\n}\n\nstatic int tegra210_usb2_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_usb2_pad *pad = to_usb2_pad(lane->pad);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb2_port *port;\n\tu32 value;\n\n\tport = tegra_xusb_find_usb2_port(padctl, lane->index);\n\tif (!port) {\n\t\tdev_err(&phy->dev, \"no port found for USB2 lane %u\\n\",\n\t\t\tlane->index);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&padctl->lock);\n\n\tif (port->usb3_port_fake != -1) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\t\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(\n\t\t\t\t\tport->usb3_port_fake);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\t\tusleep_range(100, 200);\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\t\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(\n\t\t\t\t\tport->usb3_port_fake);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\t\tusleep_range(250, 350);\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\t\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_VCORE_DOWN(\n\t\t\t\t\tport->usb3_port_fake);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\n\t\tvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(port->usb3_port_fake,\n\t\t\t\t\tXUSB_PADCTL_SS_PORT_MAP_PORT_DISABLED);\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\n\t}\n\n\tif (WARN_ON(pad->enable == 0))\n\t\tgoto out;\n\n\tif (--pad->enable > 0)\n\t\tgoto out;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\tvalue |= XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\nout:\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nstatic const struct phy_ops tegra210_usb2_phy_ops = {\n\t.init = tegra210_usb2_phy_init,\n\t.exit = tegra210_usb2_phy_exit,\n\t.power_on = tegra210_usb2_phy_power_on,\n\t.power_off = tegra210_usb2_phy_power_off,\n\t.set_mode = tegra210_usb2_phy_set_mode,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra210_usb2_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_usb2_pad *usb2;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &usb2->base;\n\tpad->ops = &tegra210_usb2_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(usb2);\n\t\tgoto out;\n\t}\n\n\tusb2->clk = devm_clk_get(&pad->dev, \"trk\");\n\tif (IS_ERR(usb2->clk)) {\n\t\terr = PTR_ERR(usb2->clk);\n\t\tdev_err(&pad->dev, \"failed to get trk clock: %d\\n\", err);\n\t\tgoto unregister;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra210_usb2_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra210_usb2_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_usb2_pad *usb2 = to_usb2_pad(pad);\n\n\tkfree(usb2);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra210_usb2_ops = {\n\t.probe = tegra210_usb2_pad_probe,\n\t.remove = tegra210_usb2_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra210_usb2_pad = {\n\t.name = \"usb2\",\n\t.num_lanes = ARRAY_SIZE(tegra210_usb2_lanes),\n\t.lanes = tegra210_usb2_lanes,\n\t.ops = &tegra210_usb2_ops,\n};\n\nstatic const char *tegra210_hsic_functions[] = {\n\t\"snps\",\n\t\"xusb\",\n};\n\nstatic const struct tegra_xusb_lane_soc tegra210_hsic_lanes[] = {\n\tTEGRA210_LANE(\"hsic-0\", 0x004, 14, 0x1, hsic),\n};\n\nstatic struct tegra_xusb_lane *\ntegra210_hsic_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_hsic_lane *hsic;\n\tint err;\n\n\thsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\n\tif (!hsic)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&hsic->base.list);\n\thsic->base.soc = &pad->soc->lanes[index];\n\thsic->base.index = index;\n\thsic->base.pad = pad;\n\thsic->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&hsic->base, np);\n\tif (err < 0) {\n\t\tkfree(hsic);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &hsic->base;\n}\n\nstatic void tegra210_hsic_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_hsic_lane *hsic = to_hsic_lane(lane);\n\n\tkfree(hsic);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra210_hsic_lane_ops = {\n\t.probe = tegra210_hsic_lane_probe,\n\t.remove = tegra210_hsic_lane_remove,\n\t.enable_phy_sleepwalk = tegra210_pmc_hsic_enable_phy_sleepwalk,\n\t.disable_phy_sleepwalk = tegra210_pmc_hsic_disable_phy_sleepwalk,\n\t.enable_phy_wake = tegra210_hsic_enable_phy_wake,\n\t.disable_phy_wake = tegra210_hsic_disable_phy_wake,\n\t.remote_wake_detected = tegra210_hsic_phy_remote_wake_detected,\n};\n\nstatic int tegra210_hsic_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PAD_MUX);\n\tvalue &= ~(XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_MASK <<\n\t\t   XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_SHIFT);\n\tvalue |= XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_XUSB <<\n\t\t XUSB_PADCTL_USB2_PAD_MUX_HSIC_PAD_TRK_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_PAD_MUX);\n\n\treturn 0;\n}\n\nstatic int tegra210_hsic_phy_exit(struct phy *phy)\n{\n\treturn 0;\n}\n\nstatic int tegra210_hsic_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_hsic_lane *hsic = to_hsic_lane(lane);\n\tstruct tegra_xusb_hsic_pad *pad = to_hsic_pad(lane->pad);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\tint err;\n\n\terr = regulator_enable(pad->supply);\n\tif (err)\n\t\treturn err;\n\n\tpadctl_writel(padctl, hsic->strobe_trim,\n\t\t      XUSB_PADCTL_HSIC_STRB_TRIM_CONTROL);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\tvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL1_TX_RTUNEP_MASK <<\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL1_TX_RTUNEP_SHIFT);\n\tvalue |= (hsic->tx_rtune_p <<\n\t\t  XUSB_PADCTL_HSIC_PAD_CTL1_TX_RTUNEP_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL2(index));\n\tvalue &= ~((XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT) |\n\t\t   (XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT));\n\tvalue |= (hsic->rx_strobe_trim <<\n\t\t  XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT) |\n\t\t (hsic->rx_data_trim <<\n\t\t  XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL2(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL0(index));\n\tvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA0 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_RPU_DATA1 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_RPU_STROBE |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA0 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA1 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_STROBE |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA0 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA1 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_STROBE |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA0 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA1 |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_STROBE);\n\tvalue |= XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA0 |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_RPD_DATA1 |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_RPD_STROBE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL0(index));\n\n\terr = clk_prepare_enable(pad->clk);\n\tif (err)\n\t\tgoto disable;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PAD_TRK_CTL);\n\tvalue &= ~((XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_SHIFT) |\n\t\t   (XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_SHIFT));\n\tvalue |= (XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_VAL <<\n\t\t  XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_START_TIMER_SHIFT) |\n\t\t (XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_VAL <<\n\t\t  XUSB_PADCTL_HSIC_PAD_TRK_CTL_TRK_DONE_RESET_TIMER_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PAD_TRK_CTL);\n\n\tudelay(1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PAD_TRK_CTL);\n\tvalue &= ~XUSB_PADCTL_HSIC_PAD_TRK_CTL_PD_TRK;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PAD_TRK_CTL);\n\n\tudelay(50);\n\n\tclk_disable_unprepare(pad->clk);\n\n\treturn 0;\n\ndisable:\n\tregulator_disable(pad->supply);\n\treturn err;\n}\n\nstatic int tegra210_hsic_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_hsic_pad *pad = to_hsic_pad(lane->pad);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL0(index));\n\tvalue |= XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA0 |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_DATA1 |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_PD_RX_STROBE |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA0 |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_DATA1 |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_PD_ZI_STROBE |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA0 |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_DATA1 |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_PD_TX_STROBE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\n\tregulator_disable(pad->supply);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops tegra210_hsic_phy_ops = {\n\t.init = tegra210_hsic_phy_init,\n\t.exit = tegra210_hsic_phy_exit,\n\t.power_on = tegra210_hsic_phy_power_on,\n\t.power_off = tegra210_hsic_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra210_hsic_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_hsic_pad *hsic;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\thsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\n\tif (!hsic)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &hsic->base;\n\tpad->ops = &tegra210_hsic_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(hsic);\n\t\tgoto out;\n\t}\n\n\thsic->clk = devm_clk_get(&pad->dev, \"trk\");\n\tif (IS_ERR(hsic->clk)) {\n\t\terr = PTR_ERR(hsic->clk);\n\t\tdev_err(&pad->dev, \"failed to get trk clock: %d\\n\", err);\n\t\tgoto unregister;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra210_hsic_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra210_hsic_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_hsic_pad *hsic = to_hsic_pad(pad);\n\n\tkfree(hsic);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra210_hsic_ops = {\n\t.probe = tegra210_hsic_pad_probe,\n\t.remove = tegra210_hsic_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra210_hsic_pad = {\n\t.name = \"hsic\",\n\t.num_lanes = ARRAY_SIZE(tegra210_hsic_lanes),\n\t.lanes = tegra210_hsic_lanes,\n\t.ops = &tegra210_hsic_ops,\n};\n\nstatic void tegra210_uphy_lane_iddq_enable(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, lane->soc->regs.misc_ctl2);\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_IDDQ_OVRD;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_IDDQ_OVRD;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_PWR_OVRD;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_PWR_OVRD;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_IDDQ;\n\tvalue &= ~XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_SLEEP_MASK;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_SLEEP_VAL;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_IDDQ;\n\tvalue &= ~XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_SLEEP_MASK;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_SLEEP_VAL;\n\tpadctl_writel(padctl, value, lane->soc->regs.misc_ctl2);\n}\n\nstatic void tegra210_uphy_lane_iddq_disable(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, lane->soc->regs.misc_ctl2);\n\tvalue &= ~XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_IDDQ_OVRD;\n\tvalue &= ~XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_IDDQ_OVRD;\n\tvalue &= ~XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_PWR_OVRD;\n\tvalue &= ~XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_PWR_OVRD;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_IDDQ;\n\tvalue &= ~XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_SLEEP_MASK;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_TX_SLEEP_VAL;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_IDDQ;\n\tvalue &= ~XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_SLEEP_MASK;\n\tvalue |= XUSB_PADCTL_UPHY_MISC_PAD_CTL2_RX_SLEEP_VAL;\n\tpadctl_writel(padctl, value, lane->soc->regs.misc_ctl2);\n}\n\n#define TEGRA210_UPHY_LANE(_name, _offset, _shift, _mask, _type, _misc)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.offset = _offset,\t\t\t\t\t\\\n\t\t.shift = _shift,\t\t\t\t\t\\\n\t\t.mask = _mask,\t\t\t\t\t\t\\\n\t\t.num_funcs = ARRAY_SIZE(tegra210_##_type##_functions),\t\\\n\t\t.funcs = tegra210_##_type##_functions,\t\t\t\\\n\t\t.regs.misc_ctl2 = _misc,\t\t\t\t\\\n\t}\n\nstatic const char *tegra210_pcie_functions[] = {\n\t\"pcie-x1\",\n\t\"usb3-ss\",\n\t\"sata\",\n\t\"pcie-x4\",\n};\n\nstatic const struct tegra_xusb_lane_soc tegra210_pcie_lanes[] = {\n\tTEGRA210_UPHY_LANE(\"pcie-0\", 0x028, 12, 0x3, pcie, XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL2(0)),\n\tTEGRA210_UPHY_LANE(\"pcie-1\", 0x028, 14, 0x3, pcie, XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL2(1)),\n\tTEGRA210_UPHY_LANE(\"pcie-2\", 0x028, 16, 0x3, pcie, XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL2(2)),\n\tTEGRA210_UPHY_LANE(\"pcie-3\", 0x028, 18, 0x3, pcie, XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL2(3)),\n\tTEGRA210_UPHY_LANE(\"pcie-4\", 0x028, 20, 0x3, pcie, XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL2(4)),\n\tTEGRA210_UPHY_LANE(\"pcie-5\", 0x028, 22, 0x3, pcie, XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL2(5)),\n\tTEGRA210_UPHY_LANE(\"pcie-6\", 0x028, 24, 0x3, pcie, XUSB_PADCTL_UPHY_MISC_PAD_PX_CTL2(6)),\n};\n\nstatic struct tegra_xusb_usb3_port *\ntegra210_lane_to_usb3_port(struct tegra_xusb_lane *lane)\n{\n\tint port;\n\n\tif (!lane || !lane->pad || !lane->pad->padctl)\n\t\treturn NULL;\n\n\tport = tegra210_usb3_lane_map(lane);\n\tif (port < 0)\n\t\treturn NULL;\n\n\treturn tegra_xusb_find_usb3_port(lane->pad->padctl, port);\n}\n\nstatic int tegra210_usb3_phy_power_on(struct phy *phy)\n{\n\tstruct device *dev = &phy->dev;\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb3_port *usb3 = tegra210_lane_to_usb3_port(lane);\n\tunsigned int index;\n\tu32 value;\n\n\tif (!usb3) {\n\t\tdev_err(dev, \"no USB3 port found for lane %u\\n\", lane->index);\n\t\treturn -ENODEV;\n\t}\n\n\tindex = usb3->base.index;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\n\n\tif (!usb3->internal)\n\t\tvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(index);\n\telse\n\t\tvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(index);\n\n\tvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(index);\n\tvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(index, usb3->port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_USB3_PADX_ECTL1(index));\n\tvalue &= ~(XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_MASK <<\n\t\t   XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_SHIFT);\n\tvalue |= XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_VAL <<\n\t\t XUSB_PADCTL_UPHY_USB3_PAD_ECTL1_TX_TERM_CTRL_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_USB3_PADX_ECTL1(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_USB3_PADX_ECTL2(index));\n\tvalue &= ~(XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_MASK <<\n\t\t   XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_SHIFT);\n\tvalue |= XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_VAL <<\n\t\t XUSB_PADCTL_UPHY_USB3_PAD_ECTL2_RX_CTLE_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_USB3_PADX_ECTL2(index));\n\n\tpadctl_writel(padctl, XUSB_PADCTL_UPHY_USB3_PAD_ECTL3_RX_DFE_VAL,\n\t\t      XUSB_PADCTL_UPHY_USB3_PADX_ECTL3(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_UPHY_USB3_PADX_ECTL4(index));\n\tvalue &= ~(XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_MASK <<\n\t\t   XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_SHIFT);\n\tvalue |= XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_VAL <<\n\t\t XUSB_PADCTL_UPHY_USB3_PAD_ECTL4_RX_CDR_CTRL_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_UPHY_USB3_PADX_ECTL4(index));\n\n\tpadctl_writel(padctl, XUSB_PADCTL_UPHY_USB3_PAD_ECTL6_RX_EQ_CTRL_H_VAL,\n\t\t      XUSB_PADCTL_UPHY_USB3_PADX_ECTL6(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_VCORE_DOWN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\treturn 0;\n}\n\nstatic int tegra210_usb3_phy_power_off(struct phy *phy)\n{\n\tstruct device *dev = &phy->dev;\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb3_port *usb3 = tegra210_lane_to_usb3_port(lane);\n\tunsigned int index;\n\tu32 value;\n\n\tif (!usb3) {\n\t\tdev_err(dev, \"no USB3 port found for lane %u\\n\", lane->index);\n\t\treturn -ENODEV;\n\t}\n\n\tindex = usb3->base.index;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN_EARLY(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_CLAMP_EN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\tusleep_range(250, 350);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM1);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM1_SSPX_ELPG_VCORE_DOWN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM1);\n\n\treturn 0;\n}\nstatic struct tegra_xusb_lane *\ntegra210_pcie_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_pcie_lane *pcie;\n\tint err;\n\n\tpcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&pcie->base.list);\n\tpcie->base.soc = &pad->soc->lanes[index];\n\tpcie->base.index = index;\n\tpcie->base.pad = pad;\n\tpcie->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&pcie->base, np);\n\tif (err < 0) {\n\t\tkfree(pcie);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &pcie->base;\n}\n\nstatic void tegra210_pcie_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_pcie_lane *pcie = to_pcie_lane(lane);\n\n\tkfree(pcie);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra210_pcie_lane_ops = {\n\t.probe = tegra210_pcie_lane_probe,\n\t.remove = tegra210_pcie_lane_remove,\n\t.iddq_enable = tegra210_uphy_lane_iddq_enable,\n\t.iddq_disable = tegra210_uphy_lane_iddq_disable,\n\t.enable_phy_sleepwalk = tegra210_usb3_enable_phy_sleepwalk,\n\t.disable_phy_sleepwalk = tegra210_usb3_disable_phy_sleepwalk,\n\t.enable_phy_wake = tegra210_usb3_enable_phy_wake,\n\t.disable_phy_wake = tegra210_usb3_disable_phy_wake,\n\t.remote_wake_detected = tegra210_usb3_phy_remote_wake_detected,\n};\n\nstatic int tegra210_pcie_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\n\tmutex_lock(&padctl->lock);\n\n\ttegra210_uphy_init(padctl);\n\n\tmutex_unlock(&padctl->lock);\n\n\treturn 0;\n}\n\nstatic int tegra210_pcie_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint err = 0;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (tegra_xusb_lane_check(lane, \"usb3-ss\"))\n\t\terr = tegra210_usb3_phy_power_on(phy);\n\n\tmutex_unlock(&padctl->lock);\n\treturn err;\n}\n\nstatic int tegra210_pcie_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint err = 0;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (tegra_xusb_lane_check(lane, \"usb3-ss\"))\n\t\terr = tegra210_usb3_phy_power_off(phy);\n\n\tmutex_unlock(&padctl->lock);\n\treturn err;\n}\n\nstatic const struct phy_ops tegra210_pcie_phy_ops = {\n\t.init = tegra210_pcie_phy_init,\n\t.power_on = tegra210_pcie_phy_power_on,\n\t.power_off = tegra210_pcie_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra210_pcie_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_pcie_pad *pcie;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tpcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &pcie->base;\n\tpad->ops = &tegra210_pcie_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(pcie);\n\t\tgoto out;\n\t}\n\n\tpcie->pll = devm_clk_get(&pad->dev, \"pll\");\n\tif (IS_ERR(pcie->pll)) {\n\t\terr = PTR_ERR(pcie->pll);\n\t\tdev_err(&pad->dev, \"failed to get PLL: %d\\n\", err);\n\t\tgoto unregister;\n\t}\n\n\tpcie->rst = devm_reset_control_get(&pad->dev, \"phy\");\n\tif (IS_ERR(pcie->rst)) {\n\t\terr = PTR_ERR(pcie->rst);\n\t\tdev_err(&pad->dev, \"failed to get PCIe pad reset: %d\\n\", err);\n\t\tgoto unregister;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra210_pcie_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra210_pcie_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_pcie_pad *pcie = to_pcie_pad(pad);\n\n\tkfree(pcie);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra210_pcie_ops = {\n\t.probe = tegra210_pcie_pad_probe,\n\t.remove = tegra210_pcie_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra210_pcie_pad = {\n\t.name = \"pcie\",\n\t.num_lanes = ARRAY_SIZE(tegra210_pcie_lanes),\n\t.lanes = tegra210_pcie_lanes,\n\t.ops = &tegra210_pcie_ops,\n};\n\nstatic const struct tegra_xusb_lane_soc tegra210_sata_lanes[] = {\n\tTEGRA210_UPHY_LANE(\"sata-0\", 0x028, 30, 0x3, pcie, XUSB_PADCTL_UPHY_MISC_PAD_S0_CTL2),\n};\n\nstatic struct tegra_xusb_lane *\ntegra210_sata_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_sata_lane *sata;\n\tint err;\n\n\tsata = kzalloc(sizeof(*sata), GFP_KERNEL);\n\tif (!sata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&sata->base.list);\n\tsata->base.soc = &pad->soc->lanes[index];\n\tsata->base.index = index;\n\tsata->base.pad = pad;\n\tsata->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&sata->base, np);\n\tif (err < 0) {\n\t\tkfree(sata);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &sata->base;\n}\n\nstatic void tegra210_sata_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_sata_lane *sata = to_sata_lane(lane);\n\n\tkfree(sata);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra210_sata_lane_ops = {\n\t.probe = tegra210_sata_lane_probe,\n\t.remove = tegra210_sata_lane_remove,\n\t.iddq_enable = tegra210_uphy_lane_iddq_enable,\n\t.iddq_disable = tegra210_uphy_lane_iddq_disable,\n\t.enable_phy_sleepwalk = tegra210_usb3_enable_phy_sleepwalk,\n\t.disable_phy_sleepwalk = tegra210_usb3_disable_phy_sleepwalk,\n\t.enable_phy_wake = tegra210_usb3_enable_phy_wake,\n\t.disable_phy_wake = tegra210_usb3_disable_phy_wake,\n\t.remote_wake_detected = tegra210_usb3_phy_remote_wake_detected,\n};\n\nstatic int tegra210_sata_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\n\tmutex_lock(&padctl->lock);\n\n\ttegra210_uphy_init(padctl);\n\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nstatic int tegra210_sata_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint err = 0;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (tegra_xusb_lane_check(lane, \"usb3-ss\"))\n\t\terr = tegra210_usb3_phy_power_on(phy);\n\n\tmutex_unlock(&padctl->lock);\n\treturn err;\n}\n\nstatic int tegra210_sata_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tint err = 0;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (tegra_xusb_lane_check(lane, \"usb3-ss\"))\n\t\terr = tegra210_usb3_phy_power_off(phy);\n\n\tmutex_unlock(&padctl->lock);\n\treturn err;\n}\n\nstatic const struct phy_ops tegra210_sata_phy_ops = {\n\t.init = tegra210_sata_phy_init,\n\t.power_on = tegra210_sata_phy_power_on,\n\t.power_off = tegra210_sata_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra210_sata_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_sata_pad *sata;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tsata = kzalloc(sizeof(*sata), GFP_KERNEL);\n\tif (!sata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &sata->base;\n\tpad->ops = &tegra210_sata_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(sata);\n\t\tgoto out;\n\t}\n\n\tsata->rst = devm_reset_control_get(&pad->dev, \"phy\");\n\tif (IS_ERR(sata->rst)) {\n\t\terr = PTR_ERR(sata->rst);\n\t\tdev_err(&pad->dev, \"failed to get SATA pad reset: %d\\n\", err);\n\t\tgoto unregister;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra210_sata_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra210_sata_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_sata_pad *sata = to_sata_pad(pad);\n\n\tkfree(sata);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra210_sata_ops = {\n\t.probe = tegra210_sata_pad_probe,\n\t.remove = tegra210_sata_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra210_sata_pad = {\n\t.name = \"sata\",\n\t.num_lanes = ARRAY_SIZE(tegra210_sata_lanes),\n\t.lanes = tegra210_sata_lanes,\n\t.ops = &tegra210_sata_ops,\n};\n\nstatic const struct tegra_xusb_pad_soc * const tegra210_pads[] = {\n\t&tegra210_usb2_pad,\n\t&tegra210_hsic_pad,\n\t&tegra210_pcie_pad,\n\t&tegra210_sata_pad,\n};\n\nstatic int tegra210_usb2_port_enable(struct tegra_xusb_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra210_usb2_port_disable(struct tegra_xusb_port *port)\n{\n}\n\nstatic struct tegra_xusb_lane *\ntegra210_usb2_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_find_lane(port->padctl, \"usb2\", port->index);\n}\n\nstatic const struct tegra_xusb_port_ops tegra210_usb2_port_ops = {\n\t.release = tegra_xusb_usb2_port_release,\n\t.remove = tegra_xusb_usb2_port_remove,\n\t.enable = tegra210_usb2_port_enable,\n\t.disable = tegra210_usb2_port_disable,\n\t.map = tegra210_usb2_port_map,\n};\n\nstatic int tegra210_hsic_port_enable(struct tegra_xusb_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra210_hsic_port_disable(struct tegra_xusb_port *port)\n{\n}\n\nstatic struct tegra_xusb_lane *\ntegra210_hsic_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_find_lane(port->padctl, \"hsic\", port->index);\n}\n\nstatic const struct tegra_xusb_port_ops tegra210_hsic_port_ops = {\n\t.release = tegra_xusb_hsic_port_release,\n\t.enable = tegra210_hsic_port_enable,\n\t.disable = tegra210_hsic_port_disable,\n\t.map = tegra210_hsic_port_map,\n};\n\nstatic int tegra210_usb3_port_enable(struct tegra_xusb_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra210_usb3_port_disable(struct tegra_xusb_port *port)\n{\n}\n\nstatic struct tegra_xusb_lane *\ntegra210_usb3_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_port_find_lane(port, tegra210_usb3_map, \"usb3-ss\");\n}\n\nstatic const struct tegra_xusb_port_ops tegra210_usb3_port_ops = {\n\t.release = tegra_xusb_usb3_port_release,\n\t.enable = tegra210_usb3_port_enable,\n\t.disable = tegra210_usb3_port_disable,\n\t.map = tegra210_usb3_port_map,\n};\n\nstatic int tegra210_utmi_port_reset(struct phy *phy)\n{\n\tstruct tegra_xusb_padctl *padctl;\n\tstruct tegra_xusb_lane *lane;\n\tu32 value;\n\n\tlane = phy_get_drvdata(phy);\n\tpadctl = lane->pad->padctl;\n\n\tvalue = padctl_readl(padctl,\n\t\t     XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPADX_CTL0(lane->index));\n\n\tif ((value & XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL0_ZIP) ||\n\t    (value & XUSB_PADCTL_USB2_BATTERY_CHRG_OTGPAD_CTL0_ZIN)) {\n\t\ttegra210_xusb_padctl_vbus_override(padctl, false);\n\t\ttegra210_xusb_padctl_vbus_override(padctl, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ntegra210_xusb_read_fuse_calibration(struct tegra210_xusb_fuse_calibration *fuse)\n{\n\tunsigned int i;\n\tu32 value;\n\tint err;\n\n\terr = tegra_fuse_readl(TEGRA_FUSE_SKU_CALIB_0, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(fuse->hs_curr_level); i++) {\n\t\tfuse->hs_curr_level[i] =\n\t\t\t(value >> FUSE_SKU_CALIB_HS_CURR_LEVEL_PADX_SHIFT(i)) &\n\t\t\tFUSE_SKU_CALIB_HS_CURR_LEVEL_PAD_MASK;\n\t}\n\n\tfuse->hs_term_range_adj =\n\t\t(value >> FUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_SHIFT) &\n\t\tFUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_MASK;\n\n\terr = tegra_fuse_readl(TEGRA_FUSE_USB_CALIB_EXT_0, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tfuse->rpd_ctrl =\n\t\t(value >> FUSE_USB_CALIB_EXT_RPD_CTRL_SHIFT) &\n\t\tFUSE_USB_CALIB_EXT_RPD_CTRL_MASK;\n\n\treturn 0;\n}\n\nstatic struct tegra_xusb_padctl *\ntegra210_xusb_padctl_probe(struct device *dev,\n\t\t\t   const struct tegra_xusb_padctl_soc *soc)\n{\n\tstruct tegra210_xusb_padctl *padctl;\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tint err;\n\n\tpadctl = devm_kzalloc(dev, sizeof(*padctl), GFP_KERNEL);\n\tif (!padctl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpadctl->base.dev = dev;\n\tpadctl->base.soc = soc;\n\n\terr = tegra210_xusb_read_fuse_calibration(&padctl->fuse);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tnp = of_parse_phandle(dev->of_node, \"nvidia,pmc\", 0);\n\tif (!np) {\n\t\tdev_warn(dev, \"nvidia,pmc property is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev) {\n\t\tdev_warn(dev, \"PMC device is not available\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!platform_get_drvdata(pdev))\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tpadctl->regmap = dev_get_regmap(&pdev->dev, \"usb_sleepwalk\");\n\tif (!padctl->regmap)\n\t\tdev_info(dev, \"failed to find PMC regmap\\n\");\n\nout:\n\treturn &padctl->base;\n}\n\nstatic void tegra210_xusb_padctl_remove(struct tegra_xusb_padctl *padctl)\n{\n}\n\nstatic void tegra210_xusb_padctl_save(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra210_xusb_padctl *priv = to_tegra210_xusb_padctl(padctl);\n\n\tpriv->context.usb2_pad_mux =\n\t\tpadctl_readl(padctl, XUSB_PADCTL_USB2_PAD_MUX);\n\tpriv->context.usb2_port_cap =\n\t\tpadctl_readl(padctl, XUSB_PADCTL_USB2_PORT_CAP);\n\tpriv->context.ss_port_map =\n\t\tpadctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\n\tpriv->context.usb3_pad_mux =\n\t\tpadctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n}\n\nstatic void tegra210_xusb_padctl_restore(struct tegra_xusb_padctl *padctl)\n{\n\tstruct tegra210_xusb_padctl *priv = to_tegra210_xusb_padctl(padctl);\n\tstruct tegra_xusb_lane *lane;\n\n\tpadctl_writel(padctl, priv->context.usb2_pad_mux,\n\t\tXUSB_PADCTL_USB2_PAD_MUX);\n\tpadctl_writel(padctl, priv->context.usb2_port_cap,\n\t\tXUSB_PADCTL_USB2_PORT_CAP);\n\tpadctl_writel(padctl, priv->context.ss_port_map,\n\t\tXUSB_PADCTL_SS_PORT_MAP);\n\n\tlist_for_each_entry(lane, &padctl->lanes, list) {\n\t\tif (lane->pad->ops->iddq_enable)\n\t\t\ttegra210_uphy_lane_iddq_enable(lane);\n\t}\n\n\tpadctl_writel(padctl, priv->context.usb3_pad_mux,\n\t\tXUSB_PADCTL_USB3_PAD_MUX);\n\n\tlist_for_each_entry(lane, &padctl->lanes, list) {\n\t\tif (lane->pad->ops->iddq_disable)\n\t\t\ttegra210_uphy_lane_iddq_disable(lane);\n\t}\n}\n\nstatic int tegra210_xusb_padctl_suspend_noirq(struct tegra_xusb_padctl *padctl)\n{\n\tmutex_lock(&padctl->lock);\n\n\ttegra210_uphy_deinit(padctl);\n\n\ttegra210_xusb_padctl_save(padctl);\n\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nstatic int tegra210_xusb_padctl_resume_noirq(struct tegra_xusb_padctl *padctl)\n{\n\tmutex_lock(&padctl->lock);\n\n\ttegra210_xusb_padctl_restore(padctl);\n\n\ttegra210_uphy_init(padctl);\n\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nstatic const struct tegra_xusb_padctl_ops tegra210_xusb_padctl_ops = {\n\t.probe = tegra210_xusb_padctl_probe,\n\t.remove = tegra210_xusb_padctl_remove,\n\t.suspend_noirq = tegra210_xusb_padctl_suspend_noirq,\n\t.resume_noirq = tegra210_xusb_padctl_resume_noirq,\n\t.usb3_set_lfps_detect = tegra210_usb3_set_lfps_detect,\n\t.hsic_set_idle = tegra210_hsic_set_idle,\n\t.vbus_override = tegra210_xusb_padctl_vbus_override,\n\t.utmi_port_reset = tegra210_utmi_port_reset,\n};\n\nstatic const char * const tegra210_xusb_padctl_supply_names[] = {\n\t\"avdd-pll-utmip\",\n\t\"avdd-pll-uerefe\",\n\t\"dvdd-pex-pll\",\n\t\"hvdd-pex-pll-e\",\n};\n\nconst struct tegra_xusb_padctl_soc tegra210_xusb_padctl_soc = {\n\t.num_pads = ARRAY_SIZE(tegra210_pads),\n\t.pads = tegra210_pads,\n\t.ports = {\n\t\t.usb2 = {\n\t\t\t.ops = &tegra210_usb2_port_ops,\n\t\t\t.count = 4,\n\t\t},\n\t\t.hsic = {\n\t\t\t.ops = &tegra210_hsic_port_ops,\n\t\t\t.count = 1,\n\t\t},\n\t\t.usb3 = {\n\t\t\t.ops = &tegra210_usb3_port_ops,\n\t\t\t.count = 4,\n\t\t},\n\t},\n\t.ops = &tegra210_xusb_padctl_ops,\n\t.supply_names = tegra210_xusb_padctl_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra210_xusb_padctl_supply_names),\n\t.need_fake_usb3_port = true,\n};\nEXPORT_SYMBOL_GPL(tegra210_xusb_padctl_soc);\n\nMODULE_AUTHOR(\"Andrew Bresticker <abrestic@chromium.org>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra 210 XUSB Pad Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}