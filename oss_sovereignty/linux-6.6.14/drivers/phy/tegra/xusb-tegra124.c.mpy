{
  "module_name": "xusb-tegra124.c",
  "hash_id": "79b573551a92f54b4dbbae7f63f6a86b781aba96c0a7acdb02d6868d49fd140b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/tegra/xusb-tegra124.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"xusb.h\"\n\n#define FUSE_SKU_CALIB_HS_CURR_LEVEL_PADX_SHIFT(x) ((x) ? 15 : 0)\n#define FUSE_SKU_CALIB_HS_CURR_LEVEL_PAD_MASK 0x3f\n#define FUSE_SKU_CALIB_HS_IREF_CAP_SHIFT 13\n#define FUSE_SKU_CALIB_HS_IREF_CAP_MASK 0x3\n#define FUSE_SKU_CALIB_HS_SQUELCH_LEVEL_SHIFT 11\n#define FUSE_SKU_CALIB_HS_SQUELCH_LEVEL_MASK 0x3\n#define FUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_SHIFT 7\n#define FUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_MASK 0xf\n\n#define XUSB_PADCTL_USB2_PORT_CAP 0x008\n#define XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_SHIFT(x) ((x) * 4)\n#define XUSB_PADCTL_USB2_PORT_CAP_PORT_CAP_MASK 0x3\n#define XUSB_PADCTL_USB2_PORT_CAP_DISABLED 0x0\n#define XUSB_PADCTL_USB2_PORT_CAP_HOST 0x1\n#define XUSB_PADCTL_USB2_PORT_CAP_DEVICE 0x2\n#define XUSB_PADCTL_USB2_PORT_CAP_OTG 0x3\n\n#define XUSB_PADCTL_SS_PORT_MAP 0x014\n#define XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(x) (1 << (((x) * 4) + 3))\n#define XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_SHIFT(x) ((x) * 4)\n#define XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(x) (0x7 << ((x) * 4))\n#define XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(x, v) (((v) & 0x7) << ((x) * 4))\n#define XUSB_PADCTL_SS_PORT_MAP_PORT_MAP_MASK 0x7\n\n#define XUSB_PADCTL_ELPG_PROGRAM 0x01c\n#define XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN (1 << 26)\n#define XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY (1 << 25)\n#define XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN (1 << 24)\n#define XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_VCORE_DOWN(x) (1 << (18 + (x) * 4))\n#define XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN_EARLY(x) \\\n\t\t\t\t\t\t\t(1 << (17 + (x) * 4))\n#define XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN(x) (1 << (16 + (x) * 4))\n\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL1 0x040\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL0_LOCKDET (1 << 19)\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL1_REFCLK_SEL_MASK (0xf << 12)\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST (1 << 1)\n\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL2 0x044\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL2_REFCLKBUF_EN (1 << 6)\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_EN (1 << 5)\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_SEL (1 << 4)\n\n#define XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(x) (0x058 + (x) * 4)\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_SHIFT 24\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_MASK 0xff\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_VAL 0x24\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT 16\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_MASK 0x3f\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT 8\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_MASK 0x3f\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_SHIFT 8\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_MASK 0xffff\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_VAL 0xf070\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_SHIFT 4\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_MASK 0xf\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_VAL 0xf\n\n#define XUSB_PADCTL_IOPHY_USB3_PADX_CTL4(x) (0x068 + (x) * 4)\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT 24\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_MASK 0x1f\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT 16\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_MASK 0x7f\n#define XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_VAL 0x002008ee\n\n#define XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL2(x) ((x) < 2 ? 0x078 + (x) * 4 : \\\n\t\t\t\t\t       0x0f8 + (x) * 4)\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_SHIFT 28\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_MASK 0x3\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_VAL 0x1\n\n#define XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL5(x) ((x) < 2 ? 0x090 + (x) * 4 : \\\n\t\t\t\t\t       0x11c + (x) * 4)\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL5_RX_QEYE_EN (1 << 8)\n\n#define XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL6(x) ((x) < 2 ? 0x098 + (x) * 4 : \\\n\t\t\t\t\t       0x128 + (x) * 4)\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT 24\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_G_Z_MASK 0x3f\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_TAP_MASK 0x1f\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_AMP_MASK 0x7f\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT 16\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK 0xff\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_G_Z 0x21\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_TAP 0x32\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_AMP 0x33\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_CTLE_Z 0x48\n#define XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_LATCH_G_Z 0xa1\n\n#define XUSB_PADCTL_USB2_OTG_PADX_CTL0(x) (0x0a0 + (x) * 4)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD_ZI (1 << 21)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD2 (1 << 20)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD (1 << 19)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_SHIFT 14\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_MASK 0x3\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_VAL(x) ((x) ? 0x0 : 0x3)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_SHIFT 6\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_MASK 0x3f\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_VAL 0x0e\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT 0\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_MASK 0x3f\n\n#define XUSB_PADCTL_USB2_OTG_PADX_CTL1(x) (0x0ac + (x) * 4)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_HS_IREF_CAP_SHIFT 9\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_HS_IREF_CAP_MASK 0x3\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT 3\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_MASK 0x7\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DR (1 << 2)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DISC_FORCE_POWERUP (1 << 1)\n#define XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_CHRP_FORCE_POWERUP (1 << 0)\n\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0 0x0b8\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD (1 << 12)\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT 2\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_MASK 0x7\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_VAL 0x5\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT 0\n#define XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_MASK 0x3\n\n#define XUSB_PADCTL_HSIC_PADX_CTL0(x) (0x0c0 + (x) * 4)\n#define XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWN_SHIFT 12\n#define XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWN_MASK 0x7\n#define XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWP_SHIFT 8\n#define XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWP_MASK 0x7\n#define XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEN_SHIFT 4\n#define XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEN_MASK 0x7\n#define XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEP_SHIFT 0\n#define XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEP_MASK 0x7\n\n#define XUSB_PADCTL_HSIC_PADX_CTL1(x) (0x0c8 + (x) * 4)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_RPU_STROBE (1 << 10)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_RPU_DATA (1 << 9)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_RPD_STROBE (1 << 8)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_RPD_DATA (1 << 7)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_PD_ZI (1 << 5)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_PD_RX (1 << 4)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_PD_TRX (1 << 3)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_PD_TX (1 << 2)\n#define XUSB_PADCTL_HSIC_PAD_CTL1_AUTO_TERM_EN (1 << 0)\n\n#define XUSB_PADCTL_HSIC_PADX_CTL2(x) (0x0d0 + (x) * 4)\n#define XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT 4\n#define XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_MASK 0x7\n#define XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT 0\n#define XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_MASK 0x7\n\n#define XUSB_PADCTL_HSIC_STRB_TRIM_CONTROL 0x0e0\n#define XUSB_PADCTL_HSIC_STRB_TRIM_CONTROL_STRB_TRIM_MASK 0x1f\n\n#define XUSB_PADCTL_USB3_PAD_MUX 0x134\n#define XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(x) (1 << (1 + (x)))\n#define XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(x) (1 << (6 + (x)))\n\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1 0x138\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_LOCKDET (1 << 27)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE (1 << 24)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL0_REFCLK_NDIV_SHIFT 20\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL0_REFCLK_NDIV_MASK 0x3\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD (1 << 3)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST (1 << 1)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ (1 << 0)\n\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2 0x13c\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL1_CP_CNTL_SHIFT 20\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL1_CP_CNTL_MASK 0xf\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL0_CP_CNTL_SHIFT 16\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL0_CP_CNTL_MASK 0xf\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2_TCLKOUT_EN (1 << 12)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2_TXCLKREF_SEL (1 << 4)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2_XDIGCLK_SEL_SHIFT 0\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL2_XDIGCLK_SEL_MASK 0x7\n\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL3 0x140\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL3_RCAL_BYPASS (1 << 7)\n\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1 0x148\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD (1 << 1)\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ (1 << 0)\n\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL2 0x14c\n\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL5 0x158\n\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL6 0x15c\n\nstruct tegra124_xusb_fuse_calibration {\n\tu32 hs_curr_level[3];\n\tu32 hs_iref_cap;\n\tu32 hs_term_range_adj;\n\tu32 hs_squelch_level;\n};\n\nstruct tegra124_xusb_padctl {\n\tstruct tegra_xusb_padctl base;\n\n\tstruct tegra124_xusb_fuse_calibration fuse;\n};\n\nstatic inline struct tegra124_xusb_padctl *\nto_tegra124_xusb_padctl(struct tegra_xusb_padctl *padctl)\n{\n\treturn container_of(padctl, struct tegra124_xusb_padctl, base);\n}\n\nstatic int tegra124_xusb_padctl_enable(struct tegra_xusb_padctl *padctl)\n{\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (padctl->enable++ > 0)\n\t\tgoto out;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\nout:\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nstatic int tegra124_xusb_padctl_disable(struct tegra_xusb_padctl *padctl)\n{\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (WARN_ON(padctl->enable == 0))\n\t\tgoto out;\n\n\tif (--padctl->enable > 0)\n\t\tgoto out;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\nout:\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nstatic int tegra124_usb3_save_context(struct tegra_xusb_padctl *padctl,\n\t\t\t\t      unsigned int index)\n{\n\tstruct tegra_xusb_usb3_port *port;\n\tstruct tegra_xusb_lane *lane;\n\tu32 value, offset;\n\n\tport = tegra_xusb_find_usb3_port(padctl, index);\n\tif (!port)\n\t\treturn -ENODEV;\n\n\tport->context_saved = true;\n\tlane = port->base.lane;\n\n\tif (lane->pad == padctl->pcie)\n\t\toffset = XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL6(lane->index);\n\telse\n\t\toffset = XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL6;\n\n\tvalue = padctl_readl(padctl, offset);\n\tvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\n\t\t   XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\n\tvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_TAP <<\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\n\tpadctl_writel(padctl, value, offset);\n\n\tvalue = padctl_readl(padctl, offset) >>\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT;\n\tport->tap1 = value & XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_TAP_MASK;\n\n\tvalue = padctl_readl(padctl, offset);\n\tvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\n\t\t   XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\n\tvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_AMP <<\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\n\tpadctl_writel(padctl, value, offset);\n\n\tvalue = padctl_readl(padctl, offset) >>\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT;\n\tport->amp = value & XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_AMP_MASK;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_USB3_PADX_CTL4(index));\n\tvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_MASK <<\n\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT) |\n\t\t   (XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_MASK <<\n\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT));\n\tvalue |= (port->tap1 <<\n\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT) |\n\t\t (port->amp <<\n\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_USB3_PADX_CTL4(index));\n\n\tvalue = padctl_readl(padctl, offset);\n\tvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\n\t\t   XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\n\tvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_LATCH_G_Z <<\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\n\tpadctl_writel(padctl, value, offset);\n\n\tvalue = padctl_readl(padctl, offset);\n\tvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\n\t\t   XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\n\tvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_G_Z <<\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\n\tpadctl_writel(padctl, value, offset);\n\n\tvalue = padctl_readl(padctl, offset) >>\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT;\n\tport->ctle_g = value &\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_G_Z_MASK;\n\n\tvalue = padctl_readl(padctl, offset);\n\tvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_MASK <<\n\t\t   XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT);\n\tvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_CTLE_Z <<\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SEL_SHIFT;\n\tpadctl_writel(padctl, value, offset);\n\n\tvalue = padctl_readl(padctl, offset) >>\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_SHIFT;\n\tport->ctle_z = value &\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL6_MISC_OUT_G_Z_MASK;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(index));\n\tvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_MASK <<\n\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT) |\n\t\t   (XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_MASK <<\n\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT));\n\tvalue |= (port->ctle_g <<\n\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT) |\n\t\t (port->ctle_z <<\n\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(index));\n\n\treturn 0;\n}\n\nstatic int tegra124_hsic_set_idle(struct tegra_xusb_padctl *padctl,\n\t\t\t\t  unsigned int index, bool idle)\n{\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\n\tif (idle)\n\t\tvalue |= XUSB_PADCTL_HSIC_PAD_CTL1_RPD_DATA |\n\t\t\t XUSB_PADCTL_HSIC_PAD_CTL1_RPU_STROBE;\n\telse\n\t\tvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL1_RPD_DATA |\n\t\t\t   XUSB_PADCTL_HSIC_PAD_CTL1_RPU_STROBE);\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\n\treturn 0;\n}\n\n#define TEGRA124_LANE(_name, _offset, _shift, _mask, _type)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.offset = _offset,\t\t\t\t\t\\\n\t\t.shift = _shift,\t\t\t\t\t\\\n\t\t.mask = _mask,\t\t\t\t\t\t\\\n\t\t.num_funcs = ARRAY_SIZE(tegra124_##_type##_functions),\t\\\n\t\t.funcs = tegra124_##_type##_functions,\t\t\t\\\n\t}\n\nstatic const char * const tegra124_usb2_functions[] = {\n\t\"snps\",\n\t\"xusb\",\n\t\"uart\",\n};\n\nstatic const struct tegra_xusb_lane_soc tegra124_usb2_lanes[] = {\n\tTEGRA124_LANE(\"usb2-0\", 0x004,  0, 0x3, usb2),\n\tTEGRA124_LANE(\"usb2-1\", 0x004,  2, 0x3, usb2),\n\tTEGRA124_LANE(\"usb2-2\", 0x004,  4, 0x3, usb2),\n};\n\nstatic struct tegra_xusb_lane *\ntegra124_usb2_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_usb2_lane *usb2;\n\tint err;\n\n\tusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&usb2->base.list);\n\tusb2->base.soc = &pad->soc->lanes[index];\n\tusb2->base.index = index;\n\tusb2->base.pad = pad;\n\tusb2->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&usb2->base, np);\n\tif (err < 0) {\n\t\tkfree(usb2);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &usb2->base;\n}\n\nstatic void tegra124_usb2_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\n\n\tkfree(usb2);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra124_usb2_lane_ops = {\n\t.probe = tegra124_usb2_lane_probe,\n\t.remove = tegra124_usb2_lane_remove,\n};\n\nstatic int tegra124_usb2_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_enable(lane->pad->padctl);\n}\n\nstatic int tegra124_usb2_phy_exit(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_disable(lane->pad->padctl);\n}\n\nstatic int tegra124_usb2_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_usb2_lane *usb2 = to_usb2_lane(lane);\n\tstruct tegra_xusb_usb2_pad *pad = to_usb2_pad(lane->pad);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra124_xusb_padctl *priv;\n\tstruct tegra_xusb_usb2_port *port;\n\tunsigned int index = lane->index;\n\tu32 value;\n\tint err;\n\n\tport = tegra_xusb_find_usb2_port(padctl, index);\n\tif (!port) {\n\t\tdev_err(&phy->dev, \"no port found for USB2 lane %u\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = to_tegra124_xusb_padctl(padctl);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\tvalue &= ~((XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_MASK <<\n\t\t    XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT) |\n\t\t   (XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_MASK <<\n\t\t    XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT));\n\tvalue |= (priv->fuse.hs_squelch_level <<\n\t\t  XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL_SHIFT) |\n\t\t (XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_VAL <<\n\t\t  XUSB_PADCTL_USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_PORT_CAP);\n\tvalue &= ~(XUSB_PADCTL_USB2_PORT_CAP_PORT_CAP_MASK <<\n\t\t   XUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_SHIFT(index));\n\tvalue |= XUSB_PADCTL_USB2_PORT_CAP_HOST <<\n\t\tXUSB_PADCTL_USB2_PORT_CAP_PORTX_CAP_SHIFT(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_PORT_CAP);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\tvalue &= ~((XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_MASK <<\n\t\t    XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT) |\n\t\t   (XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_MASK <<\n\t\t    XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_SHIFT) |\n\t\t   (XUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_MASK <<\n\t\t    XUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_SHIFT) |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD2 |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL0_PD_ZI);\n\tvalue |= (priv->fuse.hs_curr_level[index] +\n\t\t  usb2->hs_curr_level_offset) <<\n\t\tXUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_CURR_LEVEL_SHIFT;\n\tvalue |= XUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_VAL <<\n\t\tXUSB_PADCTL_USB2_OTG_PAD_CTL0_HS_SLEW_SHIFT;\n\tvalue |= XUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_VAL(index) <<\n\t\tXUSB_PADCTL_USB2_OTG_PAD_CTL0_LS_RSLEW_SHIFT;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\tvalue &= ~((XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_MASK <<\n\t\t    XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT) |\n\t\t   (XUSB_PADCTL_USB2_OTG_PAD_CTL1_HS_IREF_CAP_MASK <<\n\t\t    XUSB_PADCTL_USB2_OTG_PAD_CTL1_HS_IREF_CAP_SHIFT) |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DR |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_CHRP_FORCE_POWERUP |\n\t\t   XUSB_PADCTL_USB2_OTG_PAD_CTL1_PD_DISC_FORCE_POWERUP);\n\tvalue |= (priv->fuse.hs_term_range_adj <<\n\t\t  XUSB_PADCTL_USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ_SHIFT) |\n\t\t (priv->fuse.hs_iref_cap <<\n\t\t  XUSB_PADCTL_USB2_OTG_PAD_CTL1_HS_IREF_CAP_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));\n\n\terr = regulator_enable(port->supply);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&pad->lock);\n\n\tif (pad->enable++ > 0)\n\t\tgoto out;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\tvalue &= ~XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\nout:\n\tmutex_unlock(&pad->lock);\n\treturn 0;\n}\n\nstatic int tegra124_usb2_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_usb2_pad *pad = to_usb2_pad(lane->pad);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tstruct tegra_xusb_usb2_port *port;\n\tu32 value;\n\n\tport = tegra_xusb_find_usb2_port(padctl, lane->index);\n\tif (!port) {\n\t\tdev_err(&phy->dev, \"no port found for USB2 lane %u\\n\",\n\t\t\tlane->index);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&pad->lock);\n\n\tif (WARN_ON(pad->enable == 0))\n\t\tgoto out;\n\n\tif (--pad->enable > 0)\n\t\tgoto out;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\tvalue |= XUSB_PADCTL_USB2_BIAS_PAD_CTL0_PD;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB2_BIAS_PAD_CTL0);\n\nout:\n\tregulator_disable(port->supply);\n\tmutex_unlock(&pad->lock);\n\treturn 0;\n}\n\nstatic const struct phy_ops tegra124_usb2_phy_ops = {\n\t.init = tegra124_usb2_phy_init,\n\t.exit = tegra124_usb2_phy_exit,\n\t.power_on = tegra124_usb2_phy_power_on,\n\t.power_off = tegra124_usb2_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra124_usb2_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_usb2_pad *usb2;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tusb2 = kzalloc(sizeof(*usb2), GFP_KERNEL);\n\tif (!usb2)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&usb2->lock);\n\n\tpad = &usb2->base;\n\tpad->ops = &tegra124_usb2_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(usb2);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra124_usb2_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra124_usb2_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_usb2_pad *usb2 = to_usb2_pad(pad);\n\n\tkfree(usb2);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra124_usb2_ops = {\n\t.probe = tegra124_usb2_pad_probe,\n\t.remove = tegra124_usb2_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra124_usb2_pad = {\n\t.name = \"usb2\",\n\t.num_lanes = ARRAY_SIZE(tegra124_usb2_lanes),\n\t.lanes = tegra124_usb2_lanes,\n\t.ops = &tegra124_usb2_ops,\n};\n\nstatic const char * const tegra124_ulpi_functions[] = {\n\t\"snps\",\n\t\"xusb\",\n};\n\nstatic const struct tegra_xusb_lane_soc tegra124_ulpi_lanes[] = {\n\tTEGRA124_LANE(\"ulpi-0\", 0x004, 12, 0x1, ulpi),\n};\n\nstatic struct tegra_xusb_lane *\ntegra124_ulpi_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_ulpi_lane *ulpi;\n\tint err;\n\n\tulpi = kzalloc(sizeof(*ulpi), GFP_KERNEL);\n\tif (!ulpi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&ulpi->base.list);\n\tulpi->base.soc = &pad->soc->lanes[index];\n\tulpi->base.index = index;\n\tulpi->base.pad = pad;\n\tulpi->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&ulpi->base, np);\n\tif (err < 0) {\n\t\tkfree(ulpi);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &ulpi->base;\n}\n\nstatic void tegra124_ulpi_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_ulpi_lane *ulpi = to_ulpi_lane(lane);\n\n\tkfree(ulpi);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra124_ulpi_lane_ops = {\n\t.probe = tegra124_ulpi_lane_probe,\n\t.remove = tegra124_ulpi_lane_remove,\n};\n\nstatic int tegra124_ulpi_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_enable(lane->pad->padctl);\n}\n\nstatic int tegra124_ulpi_phy_exit(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_disable(lane->pad->padctl);\n}\n\nstatic int tegra124_ulpi_phy_power_on(struct phy *phy)\n{\n\treturn 0;\n}\n\nstatic int tegra124_ulpi_phy_power_off(struct phy *phy)\n{\n\treturn 0;\n}\n\nstatic const struct phy_ops tegra124_ulpi_phy_ops = {\n\t.init = tegra124_ulpi_phy_init,\n\t.exit = tegra124_ulpi_phy_exit,\n\t.power_on = tegra124_ulpi_phy_power_on,\n\t.power_off = tegra124_ulpi_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra124_ulpi_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_ulpi_pad *ulpi;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tulpi = kzalloc(sizeof(*ulpi), GFP_KERNEL);\n\tif (!ulpi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &ulpi->base;\n\tpad->ops = &tegra124_ulpi_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(ulpi);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra124_ulpi_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra124_ulpi_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_ulpi_pad *ulpi = to_ulpi_pad(pad);\n\n\tkfree(ulpi);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra124_ulpi_ops = {\n\t.probe = tegra124_ulpi_pad_probe,\n\t.remove = tegra124_ulpi_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra124_ulpi_pad = {\n\t.name = \"ulpi\",\n\t.num_lanes = ARRAY_SIZE(tegra124_ulpi_lanes),\n\t.lanes = tegra124_ulpi_lanes,\n\t.ops = &tegra124_ulpi_ops,\n};\n\nstatic const char * const tegra124_hsic_functions[] = {\n\t\"snps\",\n\t\"xusb\",\n};\n\nstatic const struct tegra_xusb_lane_soc tegra124_hsic_lanes[] = {\n\tTEGRA124_LANE(\"hsic-0\", 0x004, 14, 0x1, hsic),\n\tTEGRA124_LANE(\"hsic-1\", 0x004, 15, 0x1, hsic),\n};\n\nstatic struct tegra_xusb_lane *\ntegra124_hsic_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_hsic_lane *hsic;\n\tint err;\n\n\thsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\n\tif (!hsic)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&hsic->base.list);\n\thsic->base.soc = &pad->soc->lanes[index];\n\thsic->base.index = index;\n\thsic->base.pad = pad;\n\thsic->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&hsic->base, np);\n\tif (err < 0) {\n\t\tkfree(hsic);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &hsic->base;\n}\n\nstatic void tegra124_hsic_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_hsic_lane *hsic = to_hsic_lane(lane);\n\n\tkfree(hsic);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra124_hsic_lane_ops = {\n\t.probe = tegra124_hsic_lane_probe,\n\t.remove = tegra124_hsic_lane_remove,\n};\n\nstatic int tegra124_hsic_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_enable(lane->pad->padctl);\n}\n\nstatic int tegra124_hsic_phy_exit(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_disable(lane->pad->padctl);\n}\n\nstatic int tegra124_hsic_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_hsic_lane *hsic = to_hsic_lane(lane);\n\tstruct tegra_xusb_hsic_pad *pad = to_hsic_pad(lane->pad);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\tint err;\n\n\terr = regulator_enable(pad->supply);\n\tif (err)\n\t\treturn err;\n\n\tpadctl_writel(padctl, hsic->strobe_trim,\n\t\t      XUSB_PADCTL_HSIC_STRB_TRIM_CONTROL);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\n\tif (hsic->auto_term)\n\t\tvalue |= XUSB_PADCTL_HSIC_PAD_CTL1_AUTO_TERM_EN;\n\telse\n\t\tvalue &= ~XUSB_PADCTL_HSIC_PAD_CTL1_AUTO_TERM_EN;\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL0(index));\n\tvalue &= ~((XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEN_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEN_SHIFT) |\n\t\t   (XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEP_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEP_SHIFT) |\n\t\t   (XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWN_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWN_SHIFT) |\n\t\t   (XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWP_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWP_SHIFT));\n\tvalue |= (hsic->tx_rtune_n <<\n\t\t  XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEN_SHIFT) |\n\t\t(hsic->tx_rtune_p <<\n\t\t  XUSB_PADCTL_HSIC_PAD_CTL0_TX_RTUNEP_SHIFT) |\n\t\t(hsic->tx_rslew_n <<\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWN_SHIFT) |\n\t\t(hsic->tx_rslew_p <<\n\t\t XUSB_PADCTL_HSIC_PAD_CTL0_TX_RSLEWP_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL0(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL2(index));\n\tvalue &= ~((XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT) |\n\t\t   (XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_MASK <<\n\t\t    XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT));\n\tvalue |= (hsic->rx_strobe_trim <<\n\t\t  XUSB_PADCTL_HSIC_PAD_CTL2_RX_STROBE_TRIM_SHIFT) |\n\t\t(hsic->rx_data_trim <<\n\t\t XUSB_PADCTL_HSIC_PAD_CTL2_RX_DATA_TRIM_SHIFT);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL2(index));\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\tvalue &= ~(XUSB_PADCTL_HSIC_PAD_CTL1_RPD_STROBE |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL1_RPU_DATA |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL1_PD_RX |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL1_PD_ZI |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL1_PD_TRX |\n\t\t   XUSB_PADCTL_HSIC_PAD_CTL1_PD_TX);\n\tvalue |= XUSB_PADCTL_HSIC_PAD_CTL1_RPD_DATA |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL1_RPU_STROBE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\n\treturn 0;\n}\n\nstatic int tegra124_hsic_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_hsic_pad *pad = to_hsic_pad(lane->pad);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned int index = lane->index;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\tvalue |= XUSB_PADCTL_HSIC_PAD_CTL1_PD_RX |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL1_PD_ZI |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL1_PD_TRX |\n\t\t XUSB_PADCTL_HSIC_PAD_CTL1_PD_TX;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_HSIC_PADX_CTL1(index));\n\n\tregulator_disable(pad->supply);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops tegra124_hsic_phy_ops = {\n\t.init = tegra124_hsic_phy_init,\n\t.exit = tegra124_hsic_phy_exit,\n\t.power_on = tegra124_hsic_phy_power_on,\n\t.power_off = tegra124_hsic_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra124_hsic_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_hsic_pad *hsic;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\thsic = kzalloc(sizeof(*hsic), GFP_KERNEL);\n\tif (!hsic)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &hsic->base;\n\tpad->ops = &tegra124_hsic_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(hsic);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra124_hsic_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra124_hsic_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_hsic_pad *hsic = to_hsic_pad(pad);\n\n\tkfree(hsic);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra124_hsic_ops = {\n\t.probe = tegra124_hsic_pad_probe,\n\t.remove = tegra124_hsic_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra124_hsic_pad = {\n\t.name = \"hsic\",\n\t.num_lanes = ARRAY_SIZE(tegra124_hsic_lanes),\n\t.lanes = tegra124_hsic_lanes,\n\t.ops = &tegra124_hsic_ops,\n};\n\nstatic const char * const tegra124_pcie_functions[] = {\n\t\"pcie\",\n\t\"usb3-ss\",\n\t\"sata\",\n};\n\nstatic const struct tegra_xusb_lane_soc tegra124_pcie_lanes[] = {\n\tTEGRA124_LANE(\"pcie-0\", 0x134, 16, 0x3, pcie),\n\tTEGRA124_LANE(\"pcie-1\", 0x134, 18, 0x3, pcie),\n\tTEGRA124_LANE(\"pcie-2\", 0x134, 20, 0x3, pcie),\n\tTEGRA124_LANE(\"pcie-3\", 0x134, 22, 0x3, pcie),\n\tTEGRA124_LANE(\"pcie-4\", 0x134, 24, 0x3, pcie),\n};\n\nstatic struct tegra_xusb_lane *\ntegra124_pcie_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_pcie_lane *pcie;\n\tint err;\n\n\tpcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&pcie->base.list);\n\tpcie->base.soc = &pad->soc->lanes[index];\n\tpcie->base.index = index;\n\tpcie->base.pad = pad;\n\tpcie->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&pcie->base, np);\n\tif (err < 0) {\n\t\tkfree(pcie);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &pcie->base;\n}\n\nstatic void tegra124_pcie_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_pcie_lane *pcie = to_pcie_lane(lane);\n\n\tkfree(pcie);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra124_pcie_lane_ops = {\n\t.probe = tegra124_pcie_lane_probe,\n\t.remove = tegra124_pcie_lane_remove,\n};\n\nstatic int tegra124_pcie_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_enable(lane->pad->padctl);\n}\n\nstatic int tegra124_pcie_phy_exit(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_disable(lane->pad->padctl);\n}\n\nstatic int tegra124_pcie_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned long timeout;\n\tint err = -ETIMEDOUT;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_P0_CTL1_REFCLK_SEL_MASK;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL2);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_P0_CTL2_REFCLKBUF_EN |\n\t\t XUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_EN |\n\t\t XUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_SEL;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\n\ttimeout = jiffies + msecs_to_jiffies(50);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\t\tif (value & XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL0_LOCKDET) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(100, 200);\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n\tvalue |= XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(lane->index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\n\n\treturn err;\n}\n\nstatic int tegra124_pcie_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n\tvalue &= ~XUSB_PADCTL_USB3_PAD_MUX_PCIE_IDDQ_DISABLE(lane->index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops tegra124_pcie_phy_ops = {\n\t.init = tegra124_pcie_phy_init,\n\t.exit = tegra124_pcie_phy_exit,\n\t.power_on = tegra124_pcie_phy_power_on,\n\t.power_off = tegra124_pcie_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra124_pcie_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_pcie_pad *pcie;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tpcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &pcie->base;\n\tpad->ops = &tegra124_pcie_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(pcie);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra124_pcie_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra124_pcie_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_pcie_pad *pcie = to_pcie_pad(pad);\n\n\tkfree(pcie);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra124_pcie_ops = {\n\t.probe = tegra124_pcie_pad_probe,\n\t.remove = tegra124_pcie_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra124_pcie_pad = {\n\t.name = \"pcie\",\n\t.num_lanes = ARRAY_SIZE(tegra124_pcie_lanes),\n\t.lanes = tegra124_pcie_lanes,\n\t.ops = &tegra124_pcie_ops,\n};\n\nstatic const struct tegra_xusb_lane_soc tegra124_sata_lanes[] = {\n\tTEGRA124_LANE(\"sata-0\", 0x134, 26, 0x3, pcie),\n};\n\nstatic struct tegra_xusb_lane *\ntegra124_sata_lane_probe(struct tegra_xusb_pad *pad, struct device_node *np,\n\t\t\t unsigned int index)\n{\n\tstruct tegra_xusb_sata_lane *sata;\n\tint err;\n\n\tsata = kzalloc(sizeof(*sata), GFP_KERNEL);\n\tif (!sata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&sata->base.list);\n\tsata->base.soc = &pad->soc->lanes[index];\n\tsata->base.index = index;\n\tsata->base.pad = pad;\n\tsata->base.np = np;\n\n\terr = tegra_xusb_lane_parse_dt(&sata->base, np);\n\tif (err < 0) {\n\t\tkfree(sata);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn &sata->base;\n}\n\nstatic void tegra124_sata_lane_remove(struct tegra_xusb_lane *lane)\n{\n\tstruct tegra_xusb_sata_lane *sata = to_sata_lane(lane);\n\n\tkfree(sata);\n}\n\nstatic const struct tegra_xusb_lane_ops tegra124_sata_lane_ops = {\n\t.probe = tegra124_sata_lane_probe,\n\t.remove = tegra124_sata_lane_remove,\n};\n\nstatic int tegra124_sata_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_enable(lane->pad->padctl);\n}\n\nstatic int tegra124_sata_phy_exit(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\n\treturn tegra124_xusb_padctl_disable(lane->pad->padctl);\n}\n\nstatic int tegra124_sata_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tunsigned long timeout;\n\tint err = -ETIMEDOUT;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD;\n\tvalue &= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD;\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\ttimeout = jiffies + msecs_to_jiffies(50);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\t\tif (value & XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_LOCKDET) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(100, 200);\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n\tvalue |= XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(lane->index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\n\n\treturn err;\n}\n\nstatic int tegra124_sata_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\n\tstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_USB3_PAD_MUX);\n\tvalue &= ~XUSB_PADCTL_USB3_PAD_MUX_SATA_IDDQ_DISABLE(lane->index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_USB3_PAD_MUX);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD;\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\n\tvalue |= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD;\n\tvalue |= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops tegra124_sata_phy_ops = {\n\t.init = tegra124_sata_phy_init,\n\t.exit = tegra124_sata_phy_exit,\n\t.power_on = tegra124_sata_phy_power_on,\n\t.power_off = tegra124_sata_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct tegra_xusb_pad *\ntegra124_sata_pad_probe(struct tegra_xusb_padctl *padctl,\n\t\t\tconst struct tegra_xusb_pad_soc *soc,\n\t\t\tstruct device_node *np)\n{\n\tstruct tegra_xusb_sata_pad *sata;\n\tstruct tegra_xusb_pad *pad;\n\tint err;\n\n\tsata = kzalloc(sizeof(*sata), GFP_KERNEL);\n\tif (!sata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpad = &sata->base;\n\tpad->ops = &tegra124_sata_lane_ops;\n\tpad->soc = soc;\n\n\terr = tegra_xusb_pad_init(pad, padctl, np);\n\tif (err < 0) {\n\t\tkfree(sata);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_pad_register(pad, &tegra124_sata_phy_ops);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\tdev_set_drvdata(&pad->dev, pad);\n\n\treturn pad;\n\nunregister:\n\tdevice_unregister(&pad->dev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void tegra124_sata_pad_remove(struct tegra_xusb_pad *pad)\n{\n\tstruct tegra_xusb_sata_pad *sata = to_sata_pad(pad);\n\n\tkfree(sata);\n}\n\nstatic const struct tegra_xusb_pad_ops tegra124_sata_ops = {\n\t.probe = tegra124_sata_pad_probe,\n\t.remove = tegra124_sata_pad_remove,\n};\n\nstatic const struct tegra_xusb_pad_soc tegra124_sata_pad = {\n\t.name = \"sata\",\n\t.num_lanes = ARRAY_SIZE(tegra124_sata_lanes),\n\t.lanes = tegra124_sata_lanes,\n\t.ops = &tegra124_sata_ops,\n};\n\nstatic const struct tegra_xusb_pad_soc *tegra124_pads[] = {\n\t&tegra124_usb2_pad,\n\t&tegra124_ulpi_pad,\n\t&tegra124_hsic_pad,\n\t&tegra124_pcie_pad,\n\t&tegra124_sata_pad,\n};\n\nstatic int tegra124_usb2_port_enable(struct tegra_xusb_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra124_usb2_port_disable(struct tegra_xusb_port *port)\n{\n}\n\nstatic struct tegra_xusb_lane *\ntegra124_usb2_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_find_lane(port->padctl, \"usb2\", port->index);\n}\n\nstatic const struct tegra_xusb_port_ops tegra124_usb2_port_ops = {\n\t.release = tegra_xusb_usb2_port_release,\n\t.remove = tegra_xusb_usb2_port_remove,\n\t.enable = tegra124_usb2_port_enable,\n\t.disable = tegra124_usb2_port_disable,\n\t.map = tegra124_usb2_port_map,\n};\n\nstatic int tegra124_ulpi_port_enable(struct tegra_xusb_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra124_ulpi_port_disable(struct tegra_xusb_port *port)\n{\n}\n\nstatic struct tegra_xusb_lane *\ntegra124_ulpi_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_find_lane(port->padctl, \"ulpi\", port->index);\n}\n\nstatic const struct tegra_xusb_port_ops tegra124_ulpi_port_ops = {\n\t.release = tegra_xusb_ulpi_port_release,\n\t.enable = tegra124_ulpi_port_enable,\n\t.disable = tegra124_ulpi_port_disable,\n\t.map = tegra124_ulpi_port_map,\n};\n\nstatic int tegra124_hsic_port_enable(struct tegra_xusb_port *port)\n{\n\treturn 0;\n}\n\nstatic void tegra124_hsic_port_disable(struct tegra_xusb_port *port)\n{\n}\n\nstatic struct tegra_xusb_lane *\ntegra124_hsic_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_find_lane(port->padctl, \"hsic\", port->index);\n}\n\nstatic const struct tegra_xusb_port_ops tegra124_hsic_port_ops = {\n\t.release = tegra_xusb_hsic_port_release,\n\t.enable = tegra124_hsic_port_enable,\n\t.disable = tegra124_hsic_port_disable,\n\t.map = tegra124_hsic_port_map,\n};\n\nstatic int tegra124_usb3_port_enable(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_usb3_port *usb3 = to_usb3_port(port);\n\tstruct tegra_xusb_padctl *padctl = port->padctl;\n\tstruct tegra_xusb_lane *lane = usb3->base.lane;\n\tunsigned int index = port->index, offset;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\n\n\tif (!usb3->internal)\n\t\tvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(index);\n\telse\n\t\tvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_INTERNAL(index);\n\n\tvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(index);\n\tvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(index, usb3->port);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\n\n\t \n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(index));\n\tvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_MASK <<\n\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_SHIFT) |\n\t\t   (XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_MASK <<\n\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_SHIFT) |\n\t\t   (XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_MASK <<\n\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_SHIFT));\n\tvalue |= (XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_VAL <<\n\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_WANDER_SHIFT) |\n\t\t (XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_VAL <<\n\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_CDR_CNTL_SHIFT) |\n\t\t (XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_VAL <<\n\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_SHIFT);\n\n\tif (usb3->context_saved) {\n\t\tvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_MASK <<\n\t\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT) |\n\t\t\t   (XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_MASK <<\n\t\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT));\n\t\tvalue |= (usb3->ctle_g <<\n\t\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_G_SHIFT) |\n\t\t\t (usb3->ctle_z <<\n\t\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL2_RX_EQ_Z_SHIFT);\n\t}\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_USB3_PADX_CTL2(index));\n\n\tvalue = XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_VAL;\n\n\tif (usb3->context_saved) {\n\t\tvalue &= ~((XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_MASK <<\n\t\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT) |\n\t\t\t   (XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_MASK <<\n\t\t\t    XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT));\n\t\tvalue |= (usb3->tap1 <<\n\t\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_TAP_SHIFT) |\n\t\t\t (usb3->amp <<\n\t\t\t  XUSB_PADCTL_IOPHY_USB3_PAD_CTL4_DFE_CNTL_AMP_SHIFT);\n\t}\n\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_USB3_PADX_CTL4(index));\n\n\tif (lane->pad == padctl->pcie)\n\t\toffset = XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL2(lane->index);\n\telse\n\t\toffset = XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL2;\n\n\tvalue = padctl_readl(padctl, offset);\n\tvalue &= ~(XUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_MASK <<\n\t\t   XUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_SHIFT);\n\tvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_VAL <<\n\t\tXUSB_PADCTL_IOPHY_MISC_PAD_CTL2_SPARE_IN_SHIFT;\n\tpadctl_writel(padctl, value, offset);\n\n\tif (lane->pad == padctl->pcie)\n\t\toffset = XUSB_PADCTL_IOPHY_MISC_PAD_PX_CTL5(lane->index);\n\telse\n\t\toffset = XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL5;\n\n\tvalue = padctl_readl(padctl, offset);\n\tvalue |= XUSB_PADCTL_IOPHY_MISC_PAD_CTL5_RX_QEYE_EN;\n\tpadctl_writel(padctl, value, offset);\n\n\t \n\tif (lane->pad == padctl->sata) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\t\tvalue &= ~(XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL0_REFCLK_NDIV_MASK <<\n\t\t\t   XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL0_REFCLK_NDIV_SHIFT);\n\t\tvalue |= 0x2 <<\n\t\t\tXUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL0_REFCLK_NDIV_SHIFT;\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL2);\n\t\tvalue &= ~((XUSB_PADCTL_IOPHY_PLL_S0_CTL2_XDIGCLK_SEL_MASK <<\n\t\t\t    XUSB_PADCTL_IOPHY_PLL_S0_CTL2_XDIGCLK_SEL_SHIFT) |\n\t\t\t   (XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL1_CP_CNTL_MASK <<\n\t\t\t    XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL1_CP_CNTL_SHIFT) |\n\t\t\t   (XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL0_CP_CNTL_MASK <<\n\t\t\t    XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL0_CP_CNTL_SHIFT) |\n\t\t\t   XUSB_PADCTL_IOPHY_PLL_S0_CTL2_TCLKOUT_EN);\n\t\tvalue |= (0x7 <<\n\t\t\t  XUSB_PADCTL_IOPHY_PLL_S0_CTL2_XDIGCLK_SEL_SHIFT) |\n\t\t\t (0x8 <<\n\t\t\t  XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL1_CP_CNTL_SHIFT) |\n\t\t\t (0x8 <<\n\t\t\t  XUSB_PADCTL_IOPHY_PLL_S0_CTL2_PLL0_CP_CNTL_SHIFT) |\n\t\t\t XUSB_PADCTL_IOPHY_PLL_S0_CTL2_TXCLKREF_SEL;\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL2);\n\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL3);\n\t\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL3_RCAL_BYPASS;\n\t\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL3);\n\t}\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_VCORE_DOWN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN_EARLY(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN(index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\treturn 0;\n}\n\nstatic void tegra124_usb3_port_disable(struct tegra_xusb_port *port)\n{\n\tstruct tegra_xusb_padctl *padctl = port->padctl;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN_EARLY(port->index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_CLAMP_EN(port->index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(250, 350);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_SSPX_ELPG_VCORE_DOWN(port->index);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_SS_PORT_MAP);\n\tvalue &= ~XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP_MASK(port->index);\n\tvalue |= XUSB_PADCTL_SS_PORT_MAP_PORTX_MAP(port->index, 0x7);\n\tpadctl_writel(padctl, value, XUSB_PADCTL_SS_PORT_MAP);\n}\n\nstatic const struct tegra_xusb_lane_map tegra124_usb3_map[] = {\n\t{ 0, \"pcie\", 0 },\n\t{ 1, \"pcie\", 1 },\n\t{ 1, \"sata\", 0 },\n\t{ 0, NULL,   0 },\n};\n\nstatic struct tegra_xusb_lane *\ntegra124_usb3_port_map(struct tegra_xusb_port *port)\n{\n\treturn tegra_xusb_port_find_lane(port, tegra124_usb3_map, \"usb3-ss\");\n}\n\nstatic const struct tegra_xusb_port_ops tegra124_usb3_port_ops = {\n\t.release = tegra_xusb_usb3_port_release,\n\t.enable = tegra124_usb3_port_enable,\n\t.disable = tegra124_usb3_port_disable,\n\t.map = tegra124_usb3_port_map,\n};\n\nstatic int\ntegra124_xusb_read_fuse_calibration(struct tegra124_xusb_fuse_calibration *fuse)\n{\n\tunsigned int i;\n\tint err;\n\tu32 value;\n\n\terr = tegra_fuse_readl(TEGRA_FUSE_SKU_CALIB_0, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(fuse->hs_curr_level); i++) {\n\t\tfuse->hs_curr_level[i] =\n\t\t\t(value >> FUSE_SKU_CALIB_HS_CURR_LEVEL_PADX_SHIFT(i)) &\n\t\t\tFUSE_SKU_CALIB_HS_CURR_LEVEL_PAD_MASK;\n\t}\n\tfuse->hs_iref_cap =\n\t\t(value >> FUSE_SKU_CALIB_HS_IREF_CAP_SHIFT) &\n\t\tFUSE_SKU_CALIB_HS_IREF_CAP_MASK;\n\tfuse->hs_term_range_adj =\n\t\t(value >> FUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_SHIFT) &\n\t\tFUSE_SKU_CALIB_HS_TERM_RANGE_ADJ_MASK;\n\tfuse->hs_squelch_level =\n\t\t(value >> FUSE_SKU_CALIB_HS_SQUELCH_LEVEL_SHIFT) &\n\t\tFUSE_SKU_CALIB_HS_SQUELCH_LEVEL_MASK;\n\n\treturn 0;\n}\n\nstatic struct tegra_xusb_padctl *\ntegra124_xusb_padctl_probe(struct device *dev,\n\t\t\t   const struct tegra_xusb_padctl_soc *soc)\n{\n\tstruct tegra124_xusb_padctl *padctl;\n\tint err;\n\n\tpadctl = devm_kzalloc(dev, sizeof(*padctl), GFP_KERNEL);\n\tif (!padctl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpadctl->base.dev = dev;\n\tpadctl->base.soc = soc;\n\n\terr = tegra124_xusb_read_fuse_calibration(&padctl->fuse);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\treturn &padctl->base;\n}\n\nstatic void tegra124_xusb_padctl_remove(struct tegra_xusb_padctl *padctl)\n{\n}\n\nstatic const struct tegra_xusb_padctl_ops tegra124_xusb_padctl_ops = {\n\t.probe = tegra124_xusb_padctl_probe,\n\t.remove = tegra124_xusb_padctl_remove,\n\t.usb3_save_context = tegra124_usb3_save_context,\n\t.hsic_set_idle = tegra124_hsic_set_idle,\n};\n\nstatic const char * const tegra124_xusb_padctl_supply_names[] = {\n\t\"avdd-pll-utmip\",\n\t\"avdd-pll-erefe\",\n\t\"avdd-pex-pll\",\n\t\"hvdd-pex-pll-e\",\n};\n\nconst struct tegra_xusb_padctl_soc tegra124_xusb_padctl_soc = {\n\t.num_pads = ARRAY_SIZE(tegra124_pads),\n\t.pads = tegra124_pads,\n\t.ports = {\n\t\t.usb2 = {\n\t\t\t.ops = &tegra124_usb2_port_ops,\n\t\t\t.count = 3,\n\t\t},\n\t\t.ulpi = {\n\t\t\t.ops = &tegra124_ulpi_port_ops,\n\t\t\t.count = 1,\n\t\t},\n\t\t.hsic = {\n\t\t\t.ops = &tegra124_hsic_port_ops,\n\t\t\t.count = 2,\n\t\t},\n\t\t.usb3 = {\n\t\t\t.ops = &tegra124_usb3_port_ops,\n\t\t\t.count = 2,\n\t\t},\n\t},\n\t.ops = &tegra124_xusb_padctl_ops,\n\t.supply_names = tegra124_xusb_padctl_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra124_xusb_padctl_supply_names),\n};\nEXPORT_SYMBOL_GPL(tegra124_xusb_padctl_soc);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra 124 XUSB Pad Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}