{
  "module_name": "phy-tegra194-p2u.c",
  "hash_id": "265710aacaa4673bb3d3fb4ec25730240d242f1ba9a890a5c54fcaed0cfa3cb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/tegra/phy-tegra194-p2u.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#define P2U_CONTROL_CMN\t\t\t0x74\n#define P2U_CONTROL_CMN_ENABLE_L2_EXIT_RATE_CHANGE\t\tBIT(13)\n#define P2U_CONTROL_CMN_SKP_SIZE_PROTECTION_EN\t\t\tBIT(20)\n\n#define P2U_PERIODIC_EQ_CTRL_GEN3\t0xc0\n#define P2U_PERIODIC_EQ_CTRL_GEN3_PERIODIC_EQ_EN\t\tBIT(0)\n#define P2U_PERIODIC_EQ_CTRL_GEN3_INIT_PRESET_EQ_TRAIN_EN\tBIT(1)\n#define P2U_PERIODIC_EQ_CTRL_GEN4\t0xc4\n#define P2U_PERIODIC_EQ_CTRL_GEN4_INIT_PRESET_EQ_TRAIN_EN\tBIT(1)\n\n#define P2U_RX_DEBOUNCE_TIME\t\t\t\t0xa4\n#define P2U_RX_DEBOUNCE_TIME_DEBOUNCE_TIMER_MASK\t0xffff\n#define P2U_RX_DEBOUNCE_TIME_DEBOUNCE_TIMER_VAL\t\t160\n\n#define P2U_DIR_SEARCH_CTRL\t\t\t\t0xd4\n#define P2U_DIR_SEARCH_CTRL_GEN4_FINE_GRAIN_SEARCH_TWICE\tBIT(18)\n\nstruct tegra_p2u_of_data {\n\tbool one_dir_search;\n};\n\nstruct tegra_p2u {\n\tvoid __iomem *base;\n\tbool skip_sz_protection_en;  \n\tstruct tegra_p2u_of_data *of_data;\n};\n\nstatic inline void p2u_writel(struct tegra_p2u *phy, const u32 value,\n\t\t\t      const u32 reg)\n{\n\twritel_relaxed(value, phy->base + reg);\n}\n\nstatic inline u32 p2u_readl(struct tegra_p2u *phy, const u32 reg)\n{\n\treturn readl_relaxed(phy->base + reg);\n}\n\nstatic int tegra_p2u_power_on(struct phy *x)\n{\n\tstruct tegra_p2u *phy = phy_get_drvdata(x);\n\tu32 val;\n\n\tif (phy->skip_sz_protection_en) {\n\t\tval = p2u_readl(phy, P2U_CONTROL_CMN);\n\t\tval |= P2U_CONTROL_CMN_SKP_SIZE_PROTECTION_EN;\n\t\tp2u_writel(phy, val, P2U_CONTROL_CMN);\n\t}\n\n\tval = p2u_readl(phy, P2U_PERIODIC_EQ_CTRL_GEN3);\n\tval &= ~P2U_PERIODIC_EQ_CTRL_GEN3_PERIODIC_EQ_EN;\n\tval |= P2U_PERIODIC_EQ_CTRL_GEN3_INIT_PRESET_EQ_TRAIN_EN;\n\tp2u_writel(phy, val, P2U_PERIODIC_EQ_CTRL_GEN3);\n\n\tval = p2u_readl(phy, P2U_PERIODIC_EQ_CTRL_GEN4);\n\tval |= P2U_PERIODIC_EQ_CTRL_GEN4_INIT_PRESET_EQ_TRAIN_EN;\n\tp2u_writel(phy, val, P2U_PERIODIC_EQ_CTRL_GEN4);\n\n\tval = p2u_readl(phy, P2U_RX_DEBOUNCE_TIME);\n\tval &= ~P2U_RX_DEBOUNCE_TIME_DEBOUNCE_TIMER_MASK;\n\tval |= P2U_RX_DEBOUNCE_TIME_DEBOUNCE_TIMER_VAL;\n\tp2u_writel(phy, val, P2U_RX_DEBOUNCE_TIME);\n\n\tif (phy->of_data->one_dir_search) {\n\t\tval = p2u_readl(phy, P2U_DIR_SEARCH_CTRL);\n\t\tval &= ~P2U_DIR_SEARCH_CTRL_GEN4_FINE_GRAIN_SEARCH_TWICE;\n\t\tp2u_writel(phy, val, P2U_DIR_SEARCH_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_p2u_calibrate(struct phy *x)\n{\n\tstruct tegra_p2u *phy = phy_get_drvdata(x);\n\tu32 val;\n\n\tval = p2u_readl(phy, P2U_CONTROL_CMN);\n\tval |= P2U_CONTROL_CMN_ENABLE_L2_EXIT_RATE_CHANGE;\n\tp2u_writel(phy, val, P2U_CONTROL_CMN);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ops = {\n\t.power_on = tegra_p2u_power_on,\n\t.calibrate = tegra_p2u_calibrate,\n\t.owner = THIS_MODULE,\n};\n\nstatic int tegra_p2u_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy *generic_phy;\n\tstruct tegra_p2u *phy;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->of_data =\n\t\t(struct tegra_p2u_of_data *)of_device_get_match_data(dev);\n\tif (!phy->of_data)\n\t\treturn -EINVAL;\n\n\tphy->base = devm_platform_ioremap_resource_byname(pdev, \"ctl\");\n\tif (IS_ERR(phy->base))\n\t\treturn PTR_ERR(phy->base);\n\n\tphy->skip_sz_protection_en =\n\t\tof_property_read_bool(dev->of_node,\n\t\t\t\t      \"nvidia,skip-sz-protect-en\");\n\n\tplatform_set_drvdata(pdev, phy);\n\n\tgeneric_phy = devm_phy_create(dev, NULL, &ops);\n\tif (IS_ERR(generic_phy))\n\t\treturn PTR_ERR(generic_phy);\n\n\tphy_set_drvdata(generic_phy, phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\treturn PTR_ERR(phy_provider);\n\n\treturn 0;\n}\n\nstatic const struct tegra_p2u_of_data tegra194_p2u_of_data = {\n\t.one_dir_search = false,\n};\n\nstatic const struct tegra_p2u_of_data tegra234_p2u_of_data = {\n\t.one_dir_search = true,\n};\n\nstatic const struct of_device_id tegra_p2u_id_table[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra194-p2u\",\n\t\t.data = &tegra194_p2u_of_data,\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra234-p2u\",\n\t\t.data = &tegra234_p2u_of_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tegra_p2u_id_table);\n\nstatic struct platform_driver tegra_p2u_driver = {\n\t.probe = tegra_p2u_probe,\n\t.driver = {\n\t\t.name = \"tegra194-p2u\",\n\t\t.of_match_table = tegra_p2u_id_table,\n\t},\n};\nmodule_platform_driver(tegra_p2u_driver);\n\nMODULE_AUTHOR(\"Vidya Sagar <vidyas@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra194 PIPE2UPHY PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}