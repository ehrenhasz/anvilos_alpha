{
  "module_name": "phy-pistachio-usb.c",
  "hash_id": "9b4fd2cafd0fc8b024883b0aefe23da11b1d2146173c838ba98e4229a224045d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/phy-pistachio-usb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/phy/phy-pistachio-usb.h>\n\n#define USB_PHY_CONTROL1\t\t\t\t0x04\n#define USB_PHY_CONTROL1_FSEL_SHIFT\t\t\t2\n#define USB_PHY_CONTROL1_FSEL_MASK\t\t\t0x7\n\n#define USB_PHY_STRAP_CONTROL\t\t\t\t0x10\n#define USB_PHY_STRAP_CONTROL_REFCLK_SHIFT\t\t4\n#define USB_PHY_STRAP_CONTROL_REFCLK_MASK\t\t0x3\n\n#define USB_PHY_STATUS\t\t\t\t\t0x14\n#define USB_PHY_STATUS_RX_PHY_CLK\t\t\tBIT(9)\n#define USB_PHY_STATUS_RX_UTMI_CLK\t\t\tBIT(8)\n#define USB_PHY_STATUS_VBUS_FAULT\t\t\tBIT(7)\n\nstruct pistachio_usb_phy {\n\tstruct device *dev;\n\tstruct regmap *cr_top;\n\tstruct clk *phy_clk;\n\tunsigned int refclk;\n};\n\nstatic const unsigned long fsel_rate_map[] = {\n\t9600000,\n\t10000000,\n\t12000000,\n\t19200000,\n\t20000000,\n\t24000000,\n\t0,\n\t50000000,\n};\n\nstatic int pistachio_usb_phy_power_on(struct phy *phy)\n{\n\tstruct pistachio_usb_phy *p_phy = phy_get_drvdata(phy);\n\tunsigned long timeout, rate;\n\tunsigned int i;\n\tint ret;\n\n\tret = clk_prepare_enable(p_phy->phy_clk);\n\tif (ret < 0) {\n\t\tdev_err(p_phy->dev, \"Failed to enable PHY clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(p_phy->cr_top, USB_PHY_STRAP_CONTROL,\n\t\t\t   USB_PHY_STRAP_CONTROL_REFCLK_MASK <<\n\t\t\t   USB_PHY_STRAP_CONTROL_REFCLK_SHIFT,\n\t\t\t   p_phy->refclk << USB_PHY_STRAP_CONTROL_REFCLK_SHIFT);\n\n\trate = clk_get_rate(p_phy->phy_clk);\n\tif (p_phy->refclk == REFCLK_XO_CRYSTAL && rate != 12000000) {\n\t\tdev_err(p_phy->dev, \"Unsupported rate for XO crystal: %ld\\n\",\n\t\t\trate);\n\t\tret = -EINVAL;\n\t\tgoto disable_clk;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(fsel_rate_map); i++) {\n\t\tif (rate == fsel_rate_map[i])\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fsel_rate_map)) {\n\t\tdev_err(p_phy->dev, \"Unsupported clock rate: %lu\\n\", rate);\n\t\tret = -EINVAL;\n\t\tgoto disable_clk;\n\t}\n\n\tregmap_update_bits(p_phy->cr_top, USB_PHY_CONTROL1,\n\t\t\t   USB_PHY_CONTROL1_FSEL_MASK <<\n\t\t\t   USB_PHY_CONTROL1_FSEL_SHIFT,\n\t\t\t   i << USB_PHY_CONTROL1_FSEL_SHIFT);\n\n\ttimeout = jiffies + msecs_to_jiffies(200);\n\twhile (time_before(jiffies, timeout)) {\n\t\tunsigned int val;\n\n\t\tregmap_read(p_phy->cr_top, USB_PHY_STATUS, &val);\n\t\tif (val & USB_PHY_STATUS_VBUS_FAULT) {\n\t\t\tdev_err(p_phy->dev, \"VBUS fault detected\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto disable_clk;\n\t\t}\n\t\tif ((val & USB_PHY_STATUS_RX_PHY_CLK) &&\n\t\t    (val & USB_PHY_STATUS_RX_UTMI_CLK))\n\t\t\treturn 0;\n\t\tusleep_range(1000, 1500);\n\t}\n\n\tdev_err(p_phy->dev, \"Timed out waiting for PHY to power on\\n\");\n\tret = -ETIMEDOUT;\n\ndisable_clk:\n\tclk_disable_unprepare(p_phy->phy_clk);\n\treturn ret;\n}\n\nstatic int pistachio_usb_phy_power_off(struct phy *phy)\n{\n\tstruct pistachio_usb_phy *p_phy = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(p_phy->phy_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops pistachio_usb_phy_ops = {\n\t.power_on = pistachio_usb_phy_power_on,\n\t.power_off = pistachio_usb_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pistachio_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct pistachio_usb_phy *p_phy;\n\tstruct phy_provider *provider;\n\tstruct phy *phy;\n\tint ret;\n\n\tp_phy = devm_kzalloc(&pdev->dev, sizeof(*p_phy), GFP_KERNEL);\n\tif (!p_phy)\n\t\treturn -ENOMEM;\n\tp_phy->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, p_phy);\n\n\tp_phy->cr_top = syscon_regmap_lookup_by_phandle(p_phy->dev->of_node,\n\t\t\t\t\t\t\t\"img,cr-top\");\n\tif (IS_ERR(p_phy->cr_top)) {\n\t\tdev_err(p_phy->dev, \"Failed to get CR_TOP registers: %ld\\n\",\n\t\t\tPTR_ERR(p_phy->cr_top));\n\t\treturn PTR_ERR(p_phy->cr_top);\n\t}\n\n\tp_phy->phy_clk = devm_clk_get(p_phy->dev, \"usb_phy\");\n\tif (IS_ERR(p_phy->phy_clk)) {\n\t\tdev_err(p_phy->dev, \"Failed to get usb_phy clock: %ld\\n\",\n\t\t\tPTR_ERR(p_phy->phy_clk));\n\t\treturn PTR_ERR(p_phy->phy_clk);\n\t}\n\n\tret = of_property_read_u32(p_phy->dev->of_node, \"img,refclk\",\n\t\t\t\t   &p_phy->refclk);\n\tif (ret < 0) {\n\t\tdev_err(p_phy->dev, \"No reference clock selector specified\\n\");\n\t\treturn ret;\n\t}\n\n\tphy = devm_phy_create(p_phy->dev, NULL, &pistachio_usb_phy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(p_phy->dev, \"Failed to create PHY: %ld\\n\",\n\t\t\tPTR_ERR(phy));\n\t\treturn PTR_ERR(phy);\n\t}\n\tphy_set_drvdata(phy, p_phy);\n\n\tprovider = devm_of_phy_provider_register(p_phy->dev,\n\t\t\t\t\t\t of_phy_simple_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(p_phy->dev, \"Failed to register PHY provider: %ld\\n\",\n\t\t\tPTR_ERR(provider));\n\t\treturn PTR_ERR(provider);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id pistachio_usb_phy_of_match[] = {\n\t{ .compatible = \"img,pistachio-usb-phy\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pistachio_usb_phy_of_match);\n\nstatic struct platform_driver pistachio_usb_phy_driver = {\n\t.probe\t\t= pistachio_usb_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"pistachio-usb-phy\",\n\t\t.of_match_table = pistachio_usb_phy_of_match,\n\t},\n};\nmodule_platform_driver(pistachio_usb_phy_driver);\n\nMODULE_AUTHOR(\"Andrew Bresticker <abrestic@chromium.org>\");\nMODULE_DESCRIPTION(\"IMG Pistachio USB2.0 PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}