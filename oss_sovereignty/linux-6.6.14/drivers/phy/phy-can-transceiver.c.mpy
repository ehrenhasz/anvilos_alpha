{
  "module_name": "phy-can-transceiver.c",
  "hash_id": "577a286fbf15682d8c6fb2c40d12f786608a2d0df0467ec9bbe04c29c77b2781",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/phy-can-transceiver.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include<linux/phy/phy.h>\n#include<linux/platform_device.h>\n#include<linux/module.h>\n#include<linux/gpio.h>\n#include<linux/gpio/consumer.h>\n#include <linux/mux/consumer.h>\n\nstruct can_transceiver_data {\n\tu32 flags;\n#define CAN_TRANSCEIVER_STB_PRESENT\tBIT(0)\n#define CAN_TRANSCEIVER_EN_PRESENT\tBIT(1)\n};\n\nstruct can_transceiver_phy {\n\tstruct phy *generic_phy;\n\tstruct gpio_desc *standby_gpio;\n\tstruct gpio_desc *enable_gpio;\n\tstruct mux_state *mux_state;\n};\n\n \nstatic int can_transceiver_phy_power_on(struct phy *phy)\n{\n\tstruct can_transceiver_phy *can_transceiver_phy = phy_get_drvdata(phy);\n\tint ret;\n\n\tif (can_transceiver_phy->mux_state) {\n\t\tret = mux_state_select(can_transceiver_phy->mux_state);\n\t\tif (ret) {\n\t\t\tdev_err(&phy->dev, \"Failed to select CAN mux: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (can_transceiver_phy->standby_gpio)\n\t\tgpiod_set_value_cansleep(can_transceiver_phy->standby_gpio, 0);\n\tif (can_transceiver_phy->enable_gpio)\n\t\tgpiod_set_value_cansleep(can_transceiver_phy->enable_gpio, 1);\n\n\treturn 0;\n}\n\n \nstatic int can_transceiver_phy_power_off(struct phy *phy)\n{\n\tstruct can_transceiver_phy *can_transceiver_phy = phy_get_drvdata(phy);\n\n\tif (can_transceiver_phy->standby_gpio)\n\t\tgpiod_set_value_cansleep(can_transceiver_phy->standby_gpio, 1);\n\tif (can_transceiver_phy->enable_gpio)\n\t\tgpiod_set_value_cansleep(can_transceiver_phy->enable_gpio, 0);\n\tif (can_transceiver_phy->mux_state)\n\t\tmux_state_deselect(can_transceiver_phy->mux_state);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops can_transceiver_phy_ops = {\n\t.power_on\t= can_transceiver_phy_power_on,\n\t.power_off\t= can_transceiver_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct can_transceiver_data tcan1042_drvdata = {\n\t.flags = CAN_TRANSCEIVER_STB_PRESENT,\n};\n\nstatic const struct can_transceiver_data tcan1043_drvdata = {\n\t.flags = CAN_TRANSCEIVER_STB_PRESENT | CAN_TRANSCEIVER_EN_PRESENT,\n};\n\nstatic const struct of_device_id can_transceiver_phy_ids[] = {\n\t{\n\t\t.compatible = \"ti,tcan1042\",\n\t\t.data = &tcan1042_drvdata\n\t},\n\t{\n\t\t.compatible = \"ti,tcan1043\",\n\t\t.data = &tcan1043_drvdata\n\t},\n\t{\n\t\t.compatible = \"nxp,tjr1443\",\n\t\t.data = &tcan1043_drvdata\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, can_transceiver_phy_ids);\n\nstatic int can_transceiver_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct can_transceiver_phy *can_transceiver_phy;\n\tconst struct can_transceiver_data *drvdata;\n\tconst struct of_device_id *match;\n\tstruct phy *phy;\n\tstruct gpio_desc *standby_gpio;\n\tstruct gpio_desc *enable_gpio;\n\tu32 max_bitrate = 0;\n\tint err;\n\n\tcan_transceiver_phy = devm_kzalloc(dev, sizeof(struct can_transceiver_phy), GFP_KERNEL);\n\tif (!can_transceiver_phy)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_node(can_transceiver_phy_ids, pdev->dev.of_node);\n\tdrvdata = match->data;\n\n\tif (of_property_read_bool(dev->of_node, \"mux-states\")) {\n\t\tstruct mux_state *mux_state;\n\n\t\tmux_state = devm_mux_state_get(dev, NULL);\n\t\tif (IS_ERR(mux_state))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(mux_state),\n\t\t\t\t\t     \"failed to get mux\\n\");\n\t\tcan_transceiver_phy->mux_state = mux_state;\n\t}\n\n\tphy = devm_phy_create(dev, dev->of_node,\n\t\t\t      &can_transceiver_phy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"failed to create can transceiver phy\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\terr = device_property_read_u32(dev, \"max-bitrate\", &max_bitrate);\n\tif ((err != -EINVAL) && !max_bitrate)\n\t\tdev_warn(dev, \"Invalid value for transceiver max bitrate. Ignoring bitrate limit\\n\");\n\tphy->attrs.max_link_rate = max_bitrate;\n\n\tcan_transceiver_phy->generic_phy = phy;\n\n\tif (drvdata->flags & CAN_TRANSCEIVER_STB_PRESENT) {\n\t\tstandby_gpio = devm_gpiod_get_optional(dev, \"standby\", GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(standby_gpio))\n\t\t\treturn PTR_ERR(standby_gpio);\n\t\tcan_transceiver_phy->standby_gpio = standby_gpio;\n\t}\n\n\tif (drvdata->flags & CAN_TRANSCEIVER_EN_PRESENT) {\n\t\tenable_gpio = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_LOW);\n\t\tif (IS_ERR(enable_gpio))\n\t\t\treturn PTR_ERR(enable_gpio);\n\t\tcan_transceiver_phy->enable_gpio = enable_gpio;\n\t}\n\n\tphy_set_drvdata(can_transceiver_phy->generic_phy, can_transceiver_phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver can_transceiver_phy_driver = {\n\t.probe = can_transceiver_phy_probe,\n\t.driver = {\n\t\t.name = \"can-transceiver-phy\",\n\t\t.of_match_table = can_transceiver_phy_ids,\n\t},\n};\n\nmodule_platform_driver(can_transceiver_phy_driver);\n\nMODULE_AUTHOR(\"Faiz Abbas <faiz_abbas@ti.com>\");\nMODULE_AUTHOR(\"Aswath Govindraju <a-govindraju@ti.com>\");\nMODULE_DESCRIPTION(\"CAN TRANSCEIVER PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}