{
  "module_name": "phy-rockchip-dp.c",
  "hash_id": "f9eadc9813d8d4f3ea71db008a47d7bdee01dcbc2f983d27fd8e97c7547f09a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-dp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define GRF_SOC_CON12                           0x0274\n\n#define GRF_EDP_REF_CLK_SEL_INTER_HIWORD_MASK   BIT(20)\n#define GRF_EDP_REF_CLK_SEL_INTER               BIT(4)\n\n#define GRF_EDP_PHY_SIDDQ_HIWORD_MASK           BIT(21)\n#define GRF_EDP_PHY_SIDDQ_ON                    0\n#define GRF_EDP_PHY_SIDDQ_OFF                   BIT(5)\n\nstruct rockchip_dp_phy {\n\tstruct device  *dev;\n\tstruct regmap  *grf;\n\tstruct clk     *phy_24m;\n};\n\nstatic int rockchip_set_phy_state(struct phy *phy, bool enable)\n{\n\tstruct rockchip_dp_phy *dp = phy_get_drvdata(phy);\n\tint ret;\n\n\tif (enable) {\n\t\tret = regmap_write(dp->grf, GRF_SOC_CON12,\n\t\t\t\t   GRF_EDP_PHY_SIDDQ_HIWORD_MASK |\n\t\t\t\t   GRF_EDP_PHY_SIDDQ_ON);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dp->dev, \"Can't enable PHY power %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_prepare_enable(dp->phy_24m);\n\t} else {\n\t\tclk_disable_unprepare(dp->phy_24m);\n\n\t\tret = regmap_write(dp->grf, GRF_SOC_CON12,\n\t\t\t\t   GRF_EDP_PHY_SIDDQ_HIWORD_MASK |\n\t\t\t\t   GRF_EDP_PHY_SIDDQ_OFF);\n\t}\n\n\treturn ret;\n}\n\nstatic int rockchip_dp_phy_power_on(struct phy *phy)\n{\n\treturn rockchip_set_phy_state(phy, true);\n}\n\nstatic int rockchip_dp_phy_power_off(struct phy *phy)\n{\n\treturn rockchip_set_phy_state(phy, false);\n}\n\nstatic const struct phy_ops rockchip_dp_phy_ops = {\n\t.power_on\t= rockchip_dp_phy_power_on,\n\t.power_off\t= rockchip_dp_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int rockchip_dp_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct phy_provider *phy_provider;\n\tstruct rockchip_dp_phy *dp;\n\tstruct phy *phy;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tif (!dev->parent || !dev->parent->of_node)\n\t\treturn -ENODEV;\n\n\tdp = devm_kzalloc(dev, sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->dev = dev;\n\n\tdp->phy_24m = devm_clk_get(dev, \"24m\");\n\tif (IS_ERR(dp->phy_24m)) {\n\t\tdev_err(dev, \"cannot get clock 24m\\n\");\n\t\treturn PTR_ERR(dp->phy_24m);\n\t}\n\n\tret = clk_set_rate(dp->phy_24m, 24000000);\n\tif (ret < 0) {\n\t\tdev_err(dp->dev, \"cannot set clock phy_24m %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdp->grf = syscon_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(dp->grf)) {\n\t\tdev_err(dev, \"rk3288-dp needs the General Register Files syscon\\n\");\n\t\treturn PTR_ERR(dp->grf);\n\t}\n\n\tret = regmap_write(dp->grf, GRF_SOC_CON12, GRF_EDP_REF_CLK_SEL_INTER |\n\t\t\t   GRF_EDP_REF_CLK_SEL_INTER_HIWORD_MASK);\n\tif (ret != 0) {\n\t\tdev_err(dp->dev, \"Could not config GRF edp ref clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy = devm_phy_create(dev, np, &rockchip_dp_phy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"failed to create phy\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\tphy_set_drvdata(phy, dp);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id rockchip_dp_phy_dt_ids[] = {\n\t{ .compatible = \"rockchip,rk3288-dp-phy\" },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, rockchip_dp_phy_dt_ids);\n\nstatic struct platform_driver rockchip_dp_phy_driver = {\n\t.probe\t\t= rockchip_dp_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rockchip-dp-phy\",\n\t\t.of_match_table = rockchip_dp_phy_dt_ids,\n\t},\n};\n\nmodule_platform_driver(rockchip_dp_phy_driver);\n\nMODULE_AUTHOR(\"Yakir Yang <ykk@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip DP PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}