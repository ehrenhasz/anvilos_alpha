{
  "module_name": "phy-rockchip-naneng-combphy.c",
  "hash_id": "e8bc11373e094fee66511d2072d12011ab271ef33b670e23aae966ba561e8bfa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-naneng-combphy.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/phy/phy.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/units.h>\n\n#define BIT_WRITEABLE_SHIFT\t\t16\n#define REF_CLOCK_24MHz\t\t\t(24 * HZ_PER_MHZ)\n#define REF_CLOCK_25MHz\t\t\t(25 * HZ_PER_MHZ)\n#define REF_CLOCK_100MHz\t\t(100 * HZ_PER_MHZ)\n\n \n#define PHYREG6\t\t\t\t0x14\n#define PHYREG6_PLL_DIV_MASK\t\tGENMASK(7, 6)\n#define PHYREG6_PLL_DIV_SHIFT\t\t6\n#define PHYREG6_PLL_DIV_2\t\t1\n\n#define PHYREG7\t\t\t\t0x18\n#define PHYREG7_TX_RTERM_MASK\t\tGENMASK(7, 4)\n#define PHYREG7_TX_RTERM_SHIFT\t\t4\n#define PHYREG7_TX_RTERM_50OHM\t\t8\n#define PHYREG7_RX_RTERM_MASK\t\tGENMASK(3, 0)\n#define PHYREG7_RX_RTERM_SHIFT\t\t0\n#define PHYREG7_RX_RTERM_44OHM\t\t15\n\n#define PHYREG8\t\t\t\t0x1C\n#define PHYREG8_SSC_EN\t\t\tBIT(4)\n\n#define PHYREG11\t\t\t0x28\n#define PHYREG11_SU_TRIM_0_7\t\t0xF0\n\n#define PHYREG12\t\t\t0x2C\n#define PHYREG12_PLL_LPF_ADJ_VALUE\t4\n\n#define PHYREG13\t\t\t0x30\n#define PHYREG13_RESISTER_MASK\t\tGENMASK(5, 4)\n#define PHYREG13_RESISTER_SHIFT\t\t0x4\n#define PHYREG13_RESISTER_HIGH_Z\t3\n#define PHYREG13_CKRCV_AMP0\t\tBIT(7)\n\n#define PHYREG14\t\t\t0x34\n#define PHYREG14_CKRCV_AMP1\t\tBIT(0)\n\n#define PHYREG15\t\t\t0x38\n#define PHYREG15_CTLE_EN\t\tBIT(0)\n#define PHYREG15_SSC_CNT_MASK\t\tGENMASK(7, 6)\n#define PHYREG15_SSC_CNT_SHIFT\t\t6\n#define PHYREG15_SSC_CNT_VALUE\t\t1\n\n#define PHYREG16\t\t\t0x3C\n#define PHYREG16_SSC_CNT_VALUE\t\t0x5f\n\n#define PHYREG18\t\t\t0x44\n#define PHYREG18_PLL_LOOP\t\t0x32\n\n#define PHYREG27\t\t\t0x6C\n#define PHYREG27_RX_TRIM_RK3588\t\t0x4C\n\n#define PHYREG32\t\t\t0x7C\n#define PHYREG32_SSC_MASK\t\tGENMASK(7, 4)\n#define PHYREG32_SSC_DIR_SHIFT\t\t4\n#define PHYREG32_SSC_UPWARD\t\t0\n#define PHYREG32_SSC_DOWNWARD\t\t1\n#define PHYREG32_SSC_OFFSET_SHIFT\t6\n#define PHYREG32_SSC_OFFSET_500PPM\t1\n\n#define PHYREG33\t\t\t0x80\n#define PHYREG33_PLL_KVCO_MASK\t\tGENMASK(4, 2)\n#define PHYREG33_PLL_KVCO_SHIFT\t\t2\n#define PHYREG33_PLL_KVCO_VALUE\t\t2\n\nstruct rockchip_combphy_priv;\n\nstruct combphy_reg {\n\tu16 offset;\n\tu16 bitend;\n\tu16 bitstart;\n\tu16 disable;\n\tu16 enable;\n};\n\nstruct rockchip_combphy_grfcfg {\n\tstruct combphy_reg pcie_mode_set;\n\tstruct combphy_reg usb_mode_set;\n\tstruct combphy_reg sgmii_mode_set;\n\tstruct combphy_reg qsgmii_mode_set;\n\tstruct combphy_reg pipe_rxterm_set;\n\tstruct combphy_reg pipe_txelec_set;\n\tstruct combphy_reg pipe_txcomp_set;\n\tstruct combphy_reg pipe_clk_25m;\n\tstruct combphy_reg pipe_clk_100m;\n\tstruct combphy_reg pipe_phymode_sel;\n\tstruct combphy_reg pipe_rate_sel;\n\tstruct combphy_reg pipe_rxterm_sel;\n\tstruct combphy_reg pipe_txelec_sel;\n\tstruct combphy_reg pipe_txcomp_sel;\n\tstruct combphy_reg pipe_clk_ext;\n\tstruct combphy_reg pipe_sel_usb;\n\tstruct combphy_reg pipe_sel_qsgmii;\n\tstruct combphy_reg pipe_phy_status;\n\tstruct combphy_reg con0_for_pcie;\n\tstruct combphy_reg con1_for_pcie;\n\tstruct combphy_reg con2_for_pcie;\n\tstruct combphy_reg con3_for_pcie;\n\tstruct combphy_reg con0_for_sata;\n\tstruct combphy_reg con1_for_sata;\n\tstruct combphy_reg con2_for_sata;\n\tstruct combphy_reg con3_for_sata;\n\tstruct combphy_reg pipe_con0_for_sata;\n\tstruct combphy_reg pipe_con1_for_sata;\n\tstruct combphy_reg pipe_xpcs_phy_ready;\n\tstruct combphy_reg pipe_pcie1l0_sel;\n\tstruct combphy_reg pipe_pcie1l1_sel;\n};\n\nstruct rockchip_combphy_cfg {\n\tconst struct rockchip_combphy_grfcfg *grfcfg;\n\tint (*combphy_cfg)(struct rockchip_combphy_priv *priv);\n};\n\nstruct rockchip_combphy_priv {\n\tu8 type;\n\tvoid __iomem *mmio;\n\tint num_clks;\n\tstruct clk_bulk_data *clks;\n\tstruct device *dev;\n\tstruct regmap *pipe_grf;\n\tstruct regmap *phy_grf;\n\tstruct phy *phy;\n\tstruct reset_control *phy_rst;\n\tconst struct rockchip_combphy_cfg *cfg;\n\tbool enable_ssc;\n\tbool ext_refclk;\n\tstruct clk *refclk;\n};\n\nstatic void rockchip_combphy_updatel(struct rockchip_combphy_priv *priv,\n\t\t\t\t     int mask, int val, int reg)\n{\n\tunsigned int temp;\n\n\ttemp = readl(priv->mmio + reg);\n\ttemp = (temp & ~(mask)) | val;\n\twritel(temp, priv->mmio + reg);\n}\n\nstatic int rockchip_combphy_param_write(struct regmap *base,\n\t\t\t\t\tconst struct combphy_reg *reg, bool en)\n{\n\tu32 val, mask, tmp;\n\n\ttmp = en ? reg->enable : reg->disable;\n\tmask = GENMASK(reg->bitend, reg->bitstart);\n\tval = (tmp << reg->bitstart) | (mask << BIT_WRITEABLE_SHIFT);\n\n\treturn regmap_write(base, reg->offset, val);\n}\n\nstatic u32 rockchip_combphy_is_ready(struct rockchip_combphy_priv *priv)\n{\n\tconst struct rockchip_combphy_grfcfg *cfg = priv->cfg->grfcfg;\n\tu32 mask, val;\n\n\tmask = GENMASK(cfg->pipe_phy_status.bitend,\n\t\t       cfg->pipe_phy_status.bitstart);\n\n\tregmap_read(priv->phy_grf, cfg->pipe_phy_status.offset, &val);\n\tval = (val & mask) >> cfg->pipe_phy_status.bitstart;\n\n\treturn val;\n}\n\nstatic int rockchip_combphy_init(struct phy *phy)\n{\n\tstruct rockchip_combphy_priv *priv = phy_get_drvdata(phy);\n\tconst struct rockchip_combphy_grfcfg *cfg = priv->cfg->grfcfg;\n\tu32 val;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(priv->num_clks, priv->clks);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to enable clks\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (priv->type) {\n\tcase PHY_TYPE_PCIE:\n\tcase PHY_TYPE_USB3:\n\tcase PHY_TYPE_SATA:\n\tcase PHY_TYPE_SGMII:\n\tcase PHY_TYPE_QSGMII:\n\t\tif (priv->cfg->combphy_cfg)\n\t\t\tret = priv->cfg->combphy_cfg(priv);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"incompatible PHY type\\n\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to init phy for phy type %x\\n\", priv->type);\n\t\tgoto err_clk;\n\t}\n\n\tret = reset_control_deassert(priv->phy_rst);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tif (priv->type == PHY_TYPE_USB3) {\n\t\tret = readx_poll_timeout_atomic(rockchip_combphy_is_ready,\n\t\t\t\t\t\tpriv, val,\n\t\t\t\t\t\tval == cfg->pipe_phy_status.enable,\n\t\t\t\t\t\t10, 1000);\n\t\tif (ret)\n\t\t\tdev_warn(priv->dev, \"wait phy status ready timeout\\n\");\n\t}\n\n\treturn 0;\n\nerr_clk:\n\tclk_bulk_disable_unprepare(priv->num_clks, priv->clks);\n\n\treturn ret;\n}\n\nstatic int rockchip_combphy_exit(struct phy *phy)\n{\n\tstruct rockchip_combphy_priv *priv = phy_get_drvdata(phy);\n\n\tclk_bulk_disable_unprepare(priv->num_clks, priv->clks);\n\treset_control_assert(priv->phy_rst);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops rochchip_combphy_ops = {\n\t.init = rockchip_combphy_init,\n\t.exit = rockchip_combphy_exit,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct phy *rockchip_combphy_xlate(struct device *dev, struct of_phandle_args *args)\n{\n\tstruct rockchip_combphy_priv *priv = dev_get_drvdata(dev);\n\n\tif (args->args_count != 1) {\n\t\tdev_err(dev, \"invalid number of arguments\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (priv->type != PHY_NONE && priv->type != args->args[0])\n\t\tdev_warn(dev, \"phy type select %d overwriting type %d\\n\",\n\t\t\t args->args[0], priv->type);\n\n\tpriv->type = args->args[0];\n\n\treturn priv->phy;\n}\n\nstatic int rockchip_combphy_parse_dt(struct device *dev, struct rockchip_combphy_priv *priv)\n{\n\tint i;\n\n\tpriv->num_clks = devm_clk_bulk_get_all(dev, &priv->clks);\n\tif (priv->num_clks < 1)\n\t\treturn -EINVAL;\n\n\tpriv->refclk = NULL;\n\tfor (i = 0; i < priv->num_clks; i++) {\n\t\tif (!strncmp(priv->clks[i].id, \"ref\", 3)) {\n\t\t\tpriv->refclk = priv->clks[i].clk;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!priv->refclk) {\n\t\tdev_err(dev, \"no refclk found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->pipe_grf = syscon_regmap_lookup_by_phandle(dev->of_node, \"rockchip,pipe-grf\");\n\tif (IS_ERR(priv->pipe_grf)) {\n\t\tdev_err(dev, \"failed to find peri_ctrl pipe-grf regmap\\n\");\n\t\treturn PTR_ERR(priv->pipe_grf);\n\t}\n\n\tpriv->phy_grf = syscon_regmap_lookup_by_phandle(dev->of_node, \"rockchip,pipe-phy-grf\");\n\tif (IS_ERR(priv->phy_grf)) {\n\t\tdev_err(dev, \"failed to find peri_ctrl pipe-phy-grf regmap\\n\");\n\t\treturn PTR_ERR(priv->phy_grf);\n\t}\n\n\tpriv->enable_ssc = device_property_present(dev, \"rockchip,enable-ssc\");\n\n\tpriv->ext_refclk = device_property_present(dev, \"rockchip,ext-refclk\");\n\n\tpriv->phy_rst = devm_reset_control_array_get_exclusive(dev);\n\tif (IS_ERR(priv->phy_rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->phy_rst), \"failed to get phy reset\\n\");\n\n\treturn 0;\n}\n\nstatic int rockchip_combphy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_combphy_priv *priv;\n\tconst struct rockchip_combphy_cfg *phy_cfg;\n\tstruct resource *res;\n\tint ret;\n\n\tphy_cfg = of_device_get_match_data(dev);\n\tif (!phy_cfg) {\n\t\tdev_err(dev, \"no OF match data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->mmio = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->mmio)) {\n\t\tret = PTR_ERR(priv->mmio);\n\t\treturn ret;\n\t}\n\n\tpriv->dev = dev;\n\tpriv->type = PHY_NONE;\n\tpriv->cfg = phy_cfg;\n\n\tret = rockchip_combphy_parse_dt(dev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_assert(priv->phy_rst);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to reset phy\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->phy = devm_phy_create(dev, NULL, &rochchip_combphy_ops);\n\tif (IS_ERR(priv->phy)) {\n\t\tdev_err(dev, \"failed to create combphy\\n\");\n\t\treturn PTR_ERR(priv->phy);\n\t}\n\n\tdev_set_drvdata(dev, priv);\n\tphy_set_drvdata(priv->phy, priv);\n\n\tphy_provider = devm_of_phy_provider_register(dev, rockchip_combphy_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic int rk3568_combphy_cfg(struct rockchip_combphy_priv *priv)\n{\n\tconst struct rockchip_combphy_grfcfg *cfg = priv->cfg->grfcfg;\n\tunsigned long rate;\n\tu32 val;\n\n\tswitch (priv->type) {\n\tcase PHY_TYPE_PCIE:\n\t\t \n\t\trockchip_combphy_updatel(priv, PHYREG32_SSC_MASK,\n\t\t\t\t\t PHYREG32_SSC_DOWNWARD << PHYREG32_SSC_DIR_SHIFT,\n\t\t\t\t\t PHYREG32);\n\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con0_for_pcie, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con1_for_pcie, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con2_for_pcie, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con3_for_pcie, true);\n\t\tbreak;\n\n\tcase PHY_TYPE_USB3:\n\t\t \n\t\trockchip_combphy_updatel(priv, PHYREG32_SSC_MASK,\n\t\t\t\t\t PHYREG32_SSC_DOWNWARD << PHYREG32_SSC_DIR_SHIFT,\n\t\t\t\t\t PHYREG32);\n\n\t\t \n\t\tval = readl(priv->mmio + PHYREG15);\n\t\tval |= PHYREG15_CTLE_EN;\n\t\twritel(val, priv->mmio + PHYREG15);\n\n\t\t \n\t\trockchip_combphy_updatel(priv, PHYREG33_PLL_KVCO_MASK,\n\t\t\t\t\t PHYREG33_PLL_KVCO_VALUE << PHYREG33_PLL_KVCO_SHIFT,\n\t\t\t\t\t PHYREG33);\n\n\t\t \n\t\twritel(PHYREG12_PLL_LPF_ADJ_VALUE, priv->mmio + PHYREG12);\n\n\t\t \n\t\trockchip_combphy_updatel(priv, PHYREG6_PLL_DIV_MASK,\n\t\t\t\t\t PHYREG6_PLL_DIV_2 << PHYREG6_PLL_DIV_SHIFT,\n\t\t\t\t\t PHYREG6);\n\n\t\twritel(PHYREG18_PLL_LOOP, priv->mmio + PHYREG18);\n\t\twritel(PHYREG11_SU_TRIM_0_7, priv->mmio + PHYREG11);\n\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_sel_usb, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_txcomp_sel, false);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_txelec_sel, false);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->usb_mode_set, true);\n\t\tbreak;\n\n\tcase PHY_TYPE_SATA:\n\t\t \n\t\tval = readl(priv->mmio + PHYREG15);\n\t\tval |= PHYREG15_CTLE_EN;\n\t\twritel(val, priv->mmio + PHYREG15);\n\t\t \n\t\tval = PHYREG7_TX_RTERM_50OHM << PHYREG7_TX_RTERM_SHIFT;\n\t\tval |= PHYREG7_RX_RTERM_44OHM << PHYREG7_RX_RTERM_SHIFT;\n\t\twritel(val, priv->mmio + PHYREG7);\n\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con0_for_sata, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con1_for_sata, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con2_for_sata, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con3_for_sata, true);\n\t\trockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_con0_for_sata, true);\n\t\tbreak;\n\n\tcase PHY_TYPE_SGMII:\n\t\trockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_xpcs_phy_ready, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_phymode_sel, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_sel_qsgmii, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->sgmii_mode_set, true);\n\t\tbreak;\n\n\tcase PHY_TYPE_QSGMII:\n\t\trockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_xpcs_phy_ready, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_phymode_sel, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_rate_sel, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_sel_qsgmii, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->qsgmii_mode_set, true);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(priv->dev, \"incompatible PHY type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trate = clk_get_rate(priv->refclk);\n\n\tswitch (rate) {\n\tcase REF_CLOCK_24MHz:\n\t\tif (priv->type == PHY_TYPE_USB3 || priv->type == PHY_TYPE_SATA) {\n\t\t\t \n\t\t\tval = PHYREG15_SSC_CNT_VALUE << PHYREG15_SSC_CNT_SHIFT;\n\t\t\trockchip_combphy_updatel(priv, PHYREG15_SSC_CNT_MASK,\n\t\t\t\t\t\t val, PHYREG15);\n\n\t\t\twritel(PHYREG16_SSC_CNT_VALUE, priv->mmio + PHYREG16);\n\t\t}\n\t\tbreak;\n\n\tcase REF_CLOCK_25MHz:\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_25m, true);\n\t\tbreak;\n\n\tcase REF_CLOCK_100MHz:\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_100m, true);\n\t\tif (priv->type == PHY_TYPE_PCIE) {\n\t\t\t \n\t\t\tval = PHYREG33_PLL_KVCO_VALUE << PHYREG33_PLL_KVCO_SHIFT;\n\t\t\trockchip_combphy_updatel(priv, PHYREG33_PLL_KVCO_MASK,\n\t\t\t\t\t\t val, PHYREG33);\n\n\t\t\t \n\t\t\twritel(PHYREG12_PLL_LPF_ADJ_VALUE, priv->mmio + PHYREG12);\n\n\t\t\tval = PHYREG6_PLL_DIV_2 << PHYREG6_PLL_DIV_SHIFT;\n\t\t\trockchip_combphy_updatel(priv, PHYREG6_PLL_DIV_MASK,\n\t\t\t\t\t\t val, PHYREG6);\n\n\t\t\twritel(PHYREG18_PLL_LOOP, priv->mmio + PHYREG18);\n\t\t\twritel(PHYREG11_SU_TRIM_0_7, priv->mmio + PHYREG11);\n\t\t} else if (priv->type == PHY_TYPE_SATA) {\n\t\t\t \n\t\t\tval = PHYREG32_SSC_DOWNWARD << PHYREG32_SSC_DIR_SHIFT;\n\t\t\tval |= PHYREG32_SSC_OFFSET_500PPM << PHYREG32_SSC_OFFSET_SHIFT;\n\t\t\trockchip_combphy_updatel(priv, PHYREG32_SSC_MASK, val, PHYREG32);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(priv->dev, \"unsupported rate: %lu\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->ext_refclk) {\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_ext, true);\n\t\tif (priv->type == PHY_TYPE_PCIE && rate == REF_CLOCK_100MHz) {\n\t\t\tval = PHYREG13_RESISTER_HIGH_Z << PHYREG13_RESISTER_SHIFT;\n\t\t\tval |= PHYREG13_CKRCV_AMP0;\n\t\t\trockchip_combphy_updatel(priv, PHYREG13_RESISTER_MASK, val, PHYREG13);\n\n\t\t\tval = readl(priv->mmio + PHYREG14);\n\t\t\tval |= PHYREG14_CKRCV_AMP1;\n\t\t\twritel(val, priv->mmio + PHYREG14);\n\t\t}\n\t}\n\n\tif (priv->enable_ssc) {\n\t\tval = readl(priv->mmio + PHYREG8);\n\t\tval |= PHYREG8_SSC_EN;\n\t\twritel(val, priv->mmio + PHYREG8);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rockchip_combphy_grfcfg rk3568_combphy_grfcfgs = {\n\t \n\t.pcie_mode_set\t\t= { 0x0000, 5, 0, 0x00, 0x11 },\n\t.usb_mode_set\t\t= { 0x0000, 5, 0, 0x00, 0x04 },\n\t.sgmii_mode_set\t\t= { 0x0000, 5, 0, 0x00, 0x01 },\n\t.qsgmii_mode_set\t= { 0x0000, 5, 0, 0x00, 0x21 },\n\t.pipe_rxterm_set\t= { 0x0000, 12, 12, 0x00, 0x01 },\n\t.pipe_txelec_set\t= { 0x0004, 1, 1, 0x00, 0x01 },\n\t.pipe_txcomp_set\t= { 0x0004, 4, 4, 0x00, 0x01 },\n\t.pipe_clk_25m\t\t= { 0x0004, 14, 13, 0x00, 0x01 },\n\t.pipe_clk_100m\t\t= { 0x0004, 14, 13, 0x00, 0x02 },\n\t.pipe_phymode_sel\t= { 0x0008, 1, 1, 0x00, 0x01 },\n\t.pipe_rate_sel\t\t= { 0x0008, 2, 2, 0x00, 0x01 },\n\t.pipe_rxterm_sel\t= { 0x0008, 8, 8, 0x00, 0x01 },\n\t.pipe_txelec_sel\t= { 0x0008, 12, 12, 0x00, 0x01 },\n\t.pipe_txcomp_sel\t= { 0x0008, 15, 15, 0x00, 0x01 },\n\t.pipe_clk_ext\t\t= { 0x000c, 9, 8, 0x02, 0x01 },\n\t.pipe_sel_usb\t\t= { 0x000c, 14, 13, 0x00, 0x01 },\n\t.pipe_sel_qsgmii\t= { 0x000c, 15, 13, 0x00, 0x07 },\n\t.pipe_phy_status\t= { 0x0034, 6, 6, 0x01, 0x00 },\n\t.con0_for_pcie\t\t= { 0x0000, 15, 0, 0x00, 0x1000 },\n\t.con1_for_pcie\t\t= { 0x0004, 15, 0, 0x00, 0x0000 },\n\t.con2_for_pcie\t\t= { 0x0008, 15, 0, 0x00, 0x0101 },\n\t.con3_for_pcie\t\t= { 0x000c, 15, 0, 0x00, 0x0200 },\n\t.con0_for_sata\t\t= { 0x0000, 15, 0, 0x00, 0x0119 },\n\t.con1_for_sata\t\t= { 0x0004, 15, 0, 0x00, 0x0040 },\n\t.con2_for_sata\t\t= { 0x0008, 15, 0, 0x00, 0x80c3 },\n\t.con3_for_sata\t\t= { 0x000c, 15, 0, 0x00, 0x4407 },\n\t \n\t.pipe_con0_for_sata\t= { 0x0000, 15, 0, 0x00, 0x2220 },\n\t.pipe_xpcs_phy_ready\t= { 0x0040, 2, 2, 0x00, 0x01 },\n};\n\nstatic const struct rockchip_combphy_cfg rk3568_combphy_cfgs = {\n\t.grfcfg\t\t= &rk3568_combphy_grfcfgs,\n\t.combphy_cfg\t= rk3568_combphy_cfg,\n};\n\nstatic int rk3588_combphy_cfg(struct rockchip_combphy_priv *priv)\n{\n\tconst struct rockchip_combphy_grfcfg *cfg = priv->cfg->grfcfg;\n\tunsigned long rate;\n\tu32 val;\n\n\tswitch (priv->type) {\n\tcase PHY_TYPE_PCIE:\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con0_for_pcie, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con1_for_pcie, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con2_for_pcie, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con3_for_pcie, true);\n\t\trockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_pcie1l0_sel, true);\n\t\trockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_pcie1l1_sel, true);\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\t\t \n\t\trockchip_combphy_updatel(priv, PHYREG32_SSC_MASK,\n\t\t\t\t\t PHYREG32_SSC_DOWNWARD << PHYREG32_SSC_DIR_SHIFT,\n\t\t\t\t\t PHYREG32);\n\n\t\t \n\t\tval = readl(priv->mmio + PHYREG15);\n\t\tval |= PHYREG15_CTLE_EN;\n\t\twritel(val, priv->mmio + PHYREG15);\n\n\t\t \n\t\trockchip_combphy_updatel(priv, PHYREG33_PLL_KVCO_MASK,\n\t\t\t\t\t PHYREG33_PLL_KVCO_VALUE << PHYREG33_PLL_KVCO_SHIFT,\n\t\t\t\t\t PHYREG33);\n\n\t\t \n\t\twritel(PHYREG12_PLL_LPF_ADJ_VALUE, priv->mmio + PHYREG12);\n\n\t\t \n\t\trockchip_combphy_updatel(priv, PHYREG6_PLL_DIV_MASK,\n\t\t\t\t\t PHYREG6_PLL_DIV_2 << PHYREG6_PLL_DIV_SHIFT,\n\t\t\t\t\t PHYREG6);\n\n\t\twritel(PHYREG18_PLL_LOOP, priv->mmio + PHYREG18);\n\t\twritel(PHYREG11_SU_TRIM_0_7, priv->mmio + PHYREG11);\n\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_txcomp_sel, false);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_txelec_sel, false);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->usb_mode_set, true);\n\t\tbreak;\n\tcase PHY_TYPE_SATA:\n\t\t \n\t\tval = readl(priv->mmio + PHYREG15);\n\t\tval |= PHYREG15_CTLE_EN;\n\t\twritel(val, priv->mmio + PHYREG15);\n\t\t \n\t\tval = PHYREG7_TX_RTERM_50OHM << PHYREG7_TX_RTERM_SHIFT;\n\t\tval |= PHYREG7_RX_RTERM_44OHM << PHYREG7_RX_RTERM_SHIFT;\n\t\twritel(val, priv->mmio + PHYREG7);\n\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con0_for_sata, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con1_for_sata, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con2_for_sata, true);\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->con3_for_sata, true);\n\t\trockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_con0_for_sata, true);\n\t\trockchip_combphy_param_write(priv->pipe_grf, &cfg->pipe_con1_for_sata, true);\n\t\tbreak;\n\tcase PHY_TYPE_SGMII:\n\tcase PHY_TYPE_QSGMII:\n\tdefault:\n\t\tdev_err(priv->dev, \"incompatible PHY type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trate = clk_get_rate(priv->refclk);\n\n\tswitch (rate) {\n\tcase REF_CLOCK_24MHz:\n\t\tif (priv->type == PHY_TYPE_USB3 || priv->type == PHY_TYPE_SATA) {\n\t\t\t \n\t\t\tval = PHYREG15_SSC_CNT_VALUE << PHYREG15_SSC_CNT_SHIFT;\n\t\t\trockchip_combphy_updatel(priv, PHYREG15_SSC_CNT_MASK,\n\t\t\t\t\t\t val, PHYREG15);\n\n\t\t\twritel(PHYREG16_SSC_CNT_VALUE, priv->mmio + PHYREG16);\n\t\t}\n\t\tbreak;\n\n\tcase REF_CLOCK_25MHz:\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_25m, true);\n\t\tbreak;\n\tcase REF_CLOCK_100MHz:\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_100m, true);\n\t\tif (priv->type == PHY_TYPE_PCIE) {\n\t\t\t \n\t\t\tval = 4 << PHYREG33_PLL_KVCO_SHIFT;\n\t\t\trockchip_combphy_updatel(priv, PHYREG33_PLL_KVCO_MASK,\n\t\t\t\t\t\t val, PHYREG33);\n\n\t\t\t \n\t\t\twritel(PHYREG12_PLL_LPF_ADJ_VALUE, priv->mmio + PHYREG12);\n\n\t\t\t \n\t\t\twritel(PHYREG27_RX_TRIM_RK3588, priv->mmio + PHYREG27);\n\n\t\t\t \n\t\t\twritel(PHYREG11_SU_TRIM_0_7, priv->mmio + PHYREG11);\n\t\t} else if (priv->type == PHY_TYPE_SATA) {\n\t\t\t \n\t\t\tval = PHYREG32_SSC_DOWNWARD << PHYREG32_SSC_DIR_SHIFT;\n\t\t\tval |= PHYREG32_SSC_OFFSET_500PPM << PHYREG32_SSC_OFFSET_SHIFT;\n\t\t\trockchip_combphy_updatel(priv, PHYREG32_SSC_MASK, val, PHYREG32);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"Unsupported rate: %lu\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->ext_refclk) {\n\t\trockchip_combphy_param_write(priv->phy_grf, &cfg->pipe_clk_ext, true);\n\t\tif (priv->type == PHY_TYPE_PCIE && rate == REF_CLOCK_100MHz) {\n\t\t\tval = PHYREG13_RESISTER_HIGH_Z << PHYREG13_RESISTER_SHIFT;\n\t\t\tval |= PHYREG13_CKRCV_AMP0;\n\t\t\trockchip_combphy_updatel(priv, PHYREG13_RESISTER_MASK, val, PHYREG13);\n\n\t\t\tval = readl(priv->mmio + PHYREG14);\n\t\t\tval |= PHYREG14_CKRCV_AMP1;\n\t\t\twritel(val, priv->mmio + PHYREG14);\n\t\t}\n\t}\n\n\tif (priv->enable_ssc) {\n\t\tval = readl(priv->mmio + PHYREG8);\n\t\tval |= PHYREG8_SSC_EN;\n\t\twritel(val, priv->mmio + PHYREG8);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rockchip_combphy_grfcfg rk3588_combphy_grfcfgs = {\n\t \n\t.pcie_mode_set\t\t= { 0x0000, 5, 0, 0x00, 0x11 },\n\t.usb_mode_set\t\t= { 0x0000, 5, 0, 0x00, 0x04 },\n\t.pipe_rxterm_set\t= { 0x0000, 12, 12, 0x00, 0x01 },\n\t.pipe_txelec_set\t= { 0x0004, 1, 1, 0x00, 0x01 },\n\t.pipe_txcomp_set\t= { 0x0004, 4, 4, 0x00, 0x01 },\n\t.pipe_clk_25m\t\t= { 0x0004, 14, 13, 0x00, 0x01 },\n\t.pipe_clk_100m\t\t= { 0x0004, 14, 13, 0x00, 0x02 },\n\t.pipe_rxterm_sel\t= { 0x0008, 8, 8, 0x00, 0x01 },\n\t.pipe_txelec_sel\t= { 0x0008, 12, 12, 0x00, 0x01 },\n\t.pipe_txcomp_sel\t= { 0x0008, 15, 15, 0x00, 0x01 },\n\t.pipe_clk_ext\t\t= { 0x000c, 9, 8, 0x02, 0x01 },\n\t.pipe_phy_status\t= { 0x0034, 6, 6, 0x01, 0x00 },\n\t.con0_for_pcie\t\t= { 0x0000, 15, 0, 0x00, 0x1000 },\n\t.con1_for_pcie\t\t= { 0x0004, 15, 0, 0x00, 0x0000 },\n\t.con2_for_pcie\t\t= { 0x0008, 15, 0, 0x00, 0x0101 },\n\t.con3_for_pcie\t\t= { 0x000c, 15, 0, 0x00, 0x0200 },\n\t.con0_for_sata\t\t= { 0x0000, 15, 0, 0x00, 0x0129 },\n\t.con1_for_sata\t\t= { 0x0004, 15, 0, 0x00, 0x0000 },\n\t.con2_for_sata\t\t= { 0x0008, 15, 0, 0x00, 0x80c1 },\n\t.con3_for_sata\t\t= { 0x000c, 15, 0, 0x00, 0x0407 },\n\t \n\t.pipe_con0_for_sata\t= { 0x0000, 11, 5, 0x00, 0x22 },\n\t.pipe_con1_for_sata\t= { 0x0000, 2, 0, 0x00, 0x2 },\n\t.pipe_pcie1l0_sel\t= { 0x0100, 0, 0, 0x01, 0x0 },\n\t.pipe_pcie1l1_sel\t= { 0x0100, 1, 1, 0x01, 0x0 },\n};\n\nstatic const struct rockchip_combphy_cfg rk3588_combphy_cfgs = {\n\t.grfcfg\t\t= &rk3588_combphy_grfcfgs,\n\t.combphy_cfg\t= rk3588_combphy_cfg,\n};\n\nstatic const struct of_device_id rockchip_combphy_of_match[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3568-naneng-combphy\",\n\t\t.data = &rk3568_combphy_cfgs,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3588-naneng-combphy\",\n\t\t.data = &rk3588_combphy_cfgs,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rockchip_combphy_of_match);\n\nstatic struct platform_driver rockchip_combphy_driver = {\n\t.probe\t= rockchip_combphy_probe,\n\t.driver = {\n\t\t.name = \"rockchip-naneng-combphy\",\n\t\t.of_match_table = rockchip_combphy_of_match,\n\t},\n};\nmodule_platform_driver(rockchip_combphy_driver);\n\nMODULE_DESCRIPTION(\"Rockchip NANENG COMBPHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}