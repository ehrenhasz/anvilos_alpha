{
  "module_name": "phy-rockchip-emmc.c",
  "hash_id": "cbea2366f63dc1cde3aa48512195bcbc620a056aa0c5f5fcb77ddbb8a6d4a990",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-emmc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define HIWORD_UPDATE(val, mask, shift) \\\n\t\t((val) << (shift) | (mask) << ((shift) + 16))\n\n \n#define GRF_EMMCPHY_CON0\t\t0x0\n#define GRF_EMMCPHY_CON1\t\t0x4\n#define GRF_EMMCPHY_CON2\t\t0x8\n#define GRF_EMMCPHY_CON3\t\t0xc\n#define GRF_EMMCPHY_CON4\t\t0x10\n#define GRF_EMMCPHY_CON5\t\t0x14\n#define GRF_EMMCPHY_CON6\t\t0x18\n#define GRF_EMMCPHY_STATUS\t\t0x20\n\n#define PHYCTRL_PDB_MASK\t\t0x1\n#define PHYCTRL_PDB_SHIFT\t\t0x0\n#define PHYCTRL_PDB_PWR_ON\t\t0x1\n#define PHYCTRL_PDB_PWR_OFF\t\t0x0\n#define PHYCTRL_ENDLL_MASK\t\t0x1\n#define PHYCTRL_ENDLL_SHIFT\t\t0x1\n#define PHYCTRL_ENDLL_ENABLE\t\t0x1\n#define PHYCTRL_ENDLL_DISABLE\t\t0x0\n#define PHYCTRL_CALDONE_MASK\t\t0x1\n#define PHYCTRL_CALDONE_SHIFT\t\t0x6\n#define PHYCTRL_CALDONE_DONE\t\t0x1\n#define PHYCTRL_CALDONE_GOING\t\t0x0\n#define PHYCTRL_DLLRDY_MASK\t\t0x1\n#define PHYCTRL_DLLRDY_SHIFT\t\t0x5\n#define PHYCTRL_DLLRDY_DONE\t\t0x1\n#define PHYCTRL_DLLRDY_GOING\t\t0x0\n#define PHYCTRL_FREQSEL_200M\t\t0x0\n#define PHYCTRL_FREQSEL_50M\t\t0x1\n#define PHYCTRL_FREQSEL_100M\t\t0x2\n#define PHYCTRL_FREQSEL_150M\t\t0x3\n#define PHYCTRL_FREQSEL_MASK\t\t0x3\n#define PHYCTRL_FREQSEL_SHIFT\t\t0xc\n#define PHYCTRL_DR_MASK\t\t\t0x7\n#define PHYCTRL_DR_SHIFT\t\t0x4\n#define PHYCTRL_DR_50OHM\t\t0x0\n#define PHYCTRL_DR_33OHM\t\t0x1\n#define PHYCTRL_DR_66OHM\t\t0x2\n#define PHYCTRL_DR_100OHM\t\t0x3\n#define PHYCTRL_DR_40OHM\t\t0x4\n#define PHYCTRL_OTAPDLYENA\t\t0x1\n#define PHYCTRL_OTAPDLYENA_MASK\t\t0x1\n#define PHYCTRL_OTAPDLYENA_SHIFT\t0xb\n#define PHYCTRL_OTAPDLYSEL_DEFAULT\t0x4\n#define PHYCTRL_OTAPDLYSEL_MAXVALUE\t0xf\n#define PHYCTRL_OTAPDLYSEL_MASK\t\t0xf\n#define PHYCTRL_OTAPDLYSEL_SHIFT\t0x7\n#define PHYCTRL_REN_STRB_DISABLE\t0x0\n#define PHYCTRL_REN_STRB_ENABLE\t\t0x1\n#define PHYCTRL_REN_STRB_MASK\t\t0x1\n#define PHYCTRL_REN_STRB_SHIFT\t\t0x9\n\n#define PHYCTRL_IS_CALDONE(x) \\\n\t((((x) >> PHYCTRL_CALDONE_SHIFT) & \\\n\t  PHYCTRL_CALDONE_MASK) == PHYCTRL_CALDONE_DONE)\n#define PHYCTRL_IS_DLLRDY(x) \\\n\t((((x) >> PHYCTRL_DLLRDY_SHIFT) & \\\n\t  PHYCTRL_DLLRDY_MASK) == PHYCTRL_DLLRDY_DONE)\n\nstruct rockchip_emmc_phy {\n\tunsigned int\treg_offset;\n\tstruct regmap\t*reg_base;\n\tstruct clk\t*emmcclk;\n\tunsigned int drive_impedance;\n\tunsigned int enable_strobe_pulldown;\n\tunsigned int output_tapdelay_select;\n};\n\nstatic int rockchip_emmc_phy_power(struct phy *phy, bool on_off)\n{\n\tstruct rockchip_emmc_phy *rk_phy = phy_get_drvdata(phy);\n\tunsigned int caldone;\n\tunsigned int dllrdy;\n\tunsigned int freqsel = PHYCTRL_FREQSEL_200M;\n\tunsigned long rate;\n\tint ret;\n\n\t \n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON6,\n\t\t     HIWORD_UPDATE(PHYCTRL_PDB_PWR_OFF,\n\t\t\t\t   PHYCTRL_PDB_MASK,\n\t\t\t\t   PHYCTRL_PDB_SHIFT));\n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON6,\n\t\t     HIWORD_UPDATE(PHYCTRL_ENDLL_DISABLE,\n\t\t\t\t   PHYCTRL_ENDLL_MASK,\n\t\t\t\t   PHYCTRL_ENDLL_SHIFT));\n\n\t \n\tif (on_off == PHYCTRL_PDB_PWR_OFF)\n\t\treturn 0;\n\n\trate = clk_get_rate(rk_phy->emmcclk);\n\n\tif (rate != 0) {\n\t\tunsigned long ideal_rate;\n\t\tunsigned long diff;\n\n\t\tswitch (rate) {\n\t\tcase 1 ... 74999999:\n\t\t\tideal_rate = 50000000;\n\t\t\tfreqsel = PHYCTRL_FREQSEL_50M;\n\t\t\tbreak;\n\t\tcase 75000000 ... 124999999:\n\t\t\tideal_rate = 100000000;\n\t\t\tfreqsel = PHYCTRL_FREQSEL_100M;\n\t\t\tbreak;\n\t\tcase 125000000 ... 174999999:\n\t\t\tideal_rate = 150000000;\n\t\t\tfreqsel = PHYCTRL_FREQSEL_150M;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tideal_rate = 200000000;\n\t\t\tbreak;\n\t\t}\n\n\t\tdiff = (rate > ideal_rate) ?\n\t\t\trate - ideal_rate : ideal_rate - rate;\n\n\t\t \n\t\tif ((rate > 50000000 && diff > 15000000) || (rate > 200000000))\n\t\t\tdev_warn(&phy->dev, \"Unsupported rate: %lu\\n\", rate);\n\t}\n\n\t \n\tudelay(3);\n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON6,\n\t\t     HIWORD_UPDATE(PHYCTRL_PDB_PWR_ON,\n\t\t\t\t   PHYCTRL_PDB_MASK,\n\t\t\t\t   PHYCTRL_PDB_SHIFT));\n\n\t \n\tret = regmap_read_poll_timeout(rk_phy->reg_base,\n\t\t\t\t       rk_phy->reg_offset + GRF_EMMCPHY_STATUS,\n\t\t\t\t       caldone, PHYCTRL_IS_CALDONE(caldone),\n\t\t\t\t       0, 50);\n\tif (ret) {\n\t\tpr_err(\"%s: caldone failed, ret=%d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON0,\n\t\t     HIWORD_UPDATE(freqsel, PHYCTRL_FREQSEL_MASK,\n\t\t\t\t   PHYCTRL_FREQSEL_SHIFT));\n\n\t \n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON6,\n\t\t     HIWORD_UPDATE(PHYCTRL_ENDLL_ENABLE,\n\t\t\t\t   PHYCTRL_ENDLL_MASK,\n\t\t\t\t   PHYCTRL_ENDLL_SHIFT));\n\n\t \n\tif (rate == 0)\n\t\treturn 0;\n\n\t \n\tret = regmap_read_poll_timeout(rk_phy->reg_base,\n\t\t\t\t       rk_phy->reg_offset + GRF_EMMCPHY_STATUS,\n\t\t\t\t       dllrdy, PHYCTRL_IS_DLLRDY(dllrdy),\n\t\t\t\t       0, 50 * USEC_PER_MSEC);\n\tif (ret) {\n\t\tpr_err(\"%s: dllrdy failed. ret=%d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_emmc_phy_init(struct phy *phy)\n{\n\tstruct rockchip_emmc_phy *rk_phy = phy_get_drvdata(phy);\n\tint ret = 0;\n\n\t \n\trk_phy->emmcclk = clk_get_optional(&phy->dev, \"emmcclk\");\n\tif (IS_ERR(rk_phy->emmcclk)) {\n\t\tret = PTR_ERR(rk_phy->emmcclk);\n\t\tdev_err(&phy->dev, \"Error getting emmcclk: %d\\n\", ret);\n\t\trk_phy->emmcclk = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int rockchip_emmc_phy_exit(struct phy *phy)\n{\n\tstruct rockchip_emmc_phy *rk_phy = phy_get_drvdata(phy);\n\n\tclk_put(rk_phy->emmcclk);\n\n\treturn 0;\n}\n\nstatic int rockchip_emmc_phy_power_off(struct phy *phy)\n{\n\t \n\treturn rockchip_emmc_phy_power(phy, PHYCTRL_PDB_PWR_OFF);\n}\n\nstatic int rockchip_emmc_phy_power_on(struct phy *phy)\n{\n\tstruct rockchip_emmc_phy *rk_phy = phy_get_drvdata(phy);\n\n\t \n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON6,\n\t\t     HIWORD_UPDATE(rk_phy->drive_impedance,\n\t\t\t\t   PHYCTRL_DR_MASK,\n\t\t\t\t   PHYCTRL_DR_SHIFT));\n\n\t \n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON0,\n\t\t     HIWORD_UPDATE(PHYCTRL_OTAPDLYENA,\n\t\t\t\t   PHYCTRL_OTAPDLYENA_MASK,\n\t\t\t\t   PHYCTRL_OTAPDLYENA_SHIFT));\n\n\t \n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON0,\n\t\t     HIWORD_UPDATE(rk_phy->output_tapdelay_select,\n\t\t\t\t   PHYCTRL_OTAPDLYSEL_MASK,\n\t\t\t\t   PHYCTRL_OTAPDLYSEL_SHIFT));\n\n\t \n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->reg_offset + GRF_EMMCPHY_CON2,\n\t\t     HIWORD_UPDATE(rk_phy->enable_strobe_pulldown,\n\t\t\t\t   PHYCTRL_REN_STRB_MASK,\n\t\t\t\t   PHYCTRL_REN_STRB_SHIFT));\n\n\t \n\treturn rockchip_emmc_phy_power(phy, PHYCTRL_PDB_PWR_ON);\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= rockchip_emmc_phy_init,\n\t.exit\t\t= rockchip_emmc_phy_exit,\n\t.power_on\t= rockchip_emmc_phy_power_on,\n\t.power_off\t= rockchip_emmc_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic u32 convert_drive_impedance_ohm(struct platform_device *pdev, u32 dr_ohm)\n{\n\tswitch (dr_ohm) {\n\tcase 100:\n\t\treturn PHYCTRL_DR_100OHM;\n\tcase 66:\n\t\treturn PHYCTRL_DR_66OHM;\n\tcase 50:\n\t\treturn PHYCTRL_DR_50OHM;\n\tcase 40:\n\t\treturn PHYCTRL_DR_40OHM;\n\tcase 33:\n\t\treturn PHYCTRL_DR_33OHM;\n\t}\n\n\tdev_warn(&pdev->dev, \"Invalid value %u for drive-impedance-ohm.\\n\",\n\t\t dr_ohm);\n\treturn PHYCTRL_DR_50OHM;\n}\n\nstatic int rockchip_emmc_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_emmc_phy *rk_phy;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct regmap *grf;\n\tunsigned int reg_offset;\n\tu32 val;\n\n\tif (!dev->parent || !dev->parent->of_node)\n\t\treturn -ENODEV;\n\n\tgrf = syscon_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(grf)) {\n\t\tdev_err(dev, \"Missing rockchip,grf property\\n\");\n\t\treturn PTR_ERR(grf);\n\t}\n\n\trk_phy = devm_kzalloc(dev, sizeof(*rk_phy), GFP_KERNEL);\n\tif (!rk_phy)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u32(dev->of_node, \"reg\", &reg_offset)) {\n\t\tdev_err(dev, \"missing reg property in node %pOFn\\n\",\n\t\t\tdev->of_node);\n\t\treturn -EINVAL;\n\t}\n\n\trk_phy->reg_offset = reg_offset;\n\trk_phy->reg_base = grf;\n\trk_phy->drive_impedance = PHYCTRL_DR_50OHM;\n\trk_phy->enable_strobe_pulldown = PHYCTRL_REN_STRB_DISABLE;\n\trk_phy->output_tapdelay_select = PHYCTRL_OTAPDLYSEL_DEFAULT;\n\n\tif (!of_property_read_u32(dev->of_node, \"drive-impedance-ohm\", &val))\n\t\trk_phy->drive_impedance = convert_drive_impedance_ohm(pdev, val);\n\n\tif (of_property_read_bool(dev->of_node, \"rockchip,enable-strobe-pulldown\"))\n\t\trk_phy->enable_strobe_pulldown = PHYCTRL_REN_STRB_ENABLE;\n\n\tif (!of_property_read_u32(dev->of_node, \"rockchip,output-tapdelay-select\", &val)) {\n\t\tif (val <= PHYCTRL_OTAPDLYSEL_MAXVALUE)\n\t\t\trk_phy->output_tapdelay_select = val;\n\t\telse\n\t\t\tdev_err(dev, \"output-tapdelay-select exceeds limit, apply default\\n\");\n\t}\n\n\tgeneric_phy = devm_phy_create(dev, dev->of_node, &ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(generic_phy);\n\t}\n\n\tphy_set_drvdata(generic_phy, rk_phy);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id rockchip_emmc_phy_dt_ids[] = {\n\t{ .compatible = \"rockchip,rk3399-emmc-phy\" },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, rockchip_emmc_phy_dt_ids);\n\nstatic struct platform_driver rockchip_emmc_driver = {\n\t.probe\t\t= rockchip_emmc_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rockchip-emmc-phy\",\n\t\t.of_match_table = rockchip_emmc_phy_dt_ids,\n\t},\n};\n\nmodule_platform_driver(rockchip_emmc_driver);\n\nMODULE_AUTHOR(\"Shawn Lin <shawn.lin@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip EMMC PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}