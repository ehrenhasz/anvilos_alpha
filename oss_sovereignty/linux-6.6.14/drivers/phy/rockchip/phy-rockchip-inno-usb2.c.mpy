{
  "module_name": "phy-rockchip-inno-usb2.c",
  "hash_id": "0f1084c83e6f065d8baf5f6bf9e6ec478f9675f0f830bdc4ce9bf498a0720bd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-inno-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/extcon-provider.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/gpio/consumer.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/mfd/syscon.h>\n#include <linux/usb/of.h>\n#include <linux/usb/otg.h>\n\n#define BIT_WRITEABLE_SHIFT\t16\n#define SCHEDULE_DELAY\t\t(60 * HZ)\n#define OTG_SCHEDULE_DELAY\t(2 * HZ)\n\nstruct rockchip_usb2phy;\n\nenum rockchip_usb2phy_port_id {\n\tUSB2PHY_PORT_OTG,\n\tUSB2PHY_PORT_HOST,\n\tUSB2PHY_NUM_PORTS,\n};\n\nenum rockchip_usb2phy_host_state {\n\tPHY_STATE_HS_ONLINE\t= 0,\n\tPHY_STATE_DISCONNECT\t= 1,\n\tPHY_STATE_CONNECT\t= 2,\n\tPHY_STATE_FS_LS_ONLINE\t= 4,\n};\n\n \nenum usb_chg_state {\n\tUSB_CHG_STATE_UNDEFINED = 0,\n\tUSB_CHG_STATE_WAIT_FOR_DCD,\n\tUSB_CHG_STATE_DCD_DONE,\n\tUSB_CHG_STATE_PRIMARY_DONE,\n\tUSB_CHG_STATE_SECONDARY_DONE,\n\tUSB_CHG_STATE_DETECTED,\n};\n\nstatic const unsigned int rockchip_usb2phy_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_CHG_USB_SDP,\n\tEXTCON_CHG_USB_CDP,\n\tEXTCON_CHG_USB_DCP,\n\tEXTCON_CHG_USB_SLOW,\n\tEXTCON_NONE,\n};\n\nstruct usb2phy_reg {\n\tunsigned int\toffset;\n\tunsigned int\tbitend;\n\tunsigned int\tbitstart;\n\tunsigned int\tdisable;\n\tunsigned int\tenable;\n};\n\n \nstruct rockchip_chg_det_reg {\n\tstruct usb2phy_reg\tcp_det;\n\tstruct usb2phy_reg\tdcp_det;\n\tstruct usb2phy_reg\tdp_det;\n\tstruct usb2phy_reg\tidm_sink_en;\n\tstruct usb2phy_reg\tidp_sink_en;\n\tstruct usb2phy_reg\tidp_src_en;\n\tstruct usb2phy_reg\trdm_pdwn_en;\n\tstruct usb2phy_reg\tvdm_src_en;\n\tstruct usb2phy_reg\tvdp_src_en;\n\tstruct usb2phy_reg\topmode;\n};\n\n \nstruct rockchip_usb2phy_port_cfg {\n\tstruct usb2phy_reg\tphy_sus;\n\tstruct usb2phy_reg\tbvalid_det_en;\n\tstruct usb2phy_reg\tbvalid_det_st;\n\tstruct usb2phy_reg\tbvalid_det_clr;\n\tstruct usb2phy_reg      disfall_en;\n\tstruct usb2phy_reg      disfall_st;\n\tstruct usb2phy_reg      disfall_clr;\n\tstruct usb2phy_reg      disrise_en;\n\tstruct usb2phy_reg      disrise_st;\n\tstruct usb2phy_reg      disrise_clr;\n\tstruct usb2phy_reg\tid_det_en;\n\tstruct usb2phy_reg\tid_det_st;\n\tstruct usb2phy_reg\tid_det_clr;\n\tstruct usb2phy_reg\tls_det_en;\n\tstruct usb2phy_reg\tls_det_st;\n\tstruct usb2phy_reg\tls_det_clr;\n\tstruct usb2phy_reg\tutmi_avalid;\n\tstruct usb2phy_reg\tutmi_bvalid;\n\tstruct usb2phy_reg\tutmi_id;\n\tstruct usb2phy_reg\tutmi_ls;\n\tstruct usb2phy_reg\tutmi_hstdet;\n};\n\n \nstruct rockchip_usb2phy_cfg {\n\tunsigned int\treg;\n\tunsigned int\tnum_ports;\n\tint (*phy_tuning)(struct rockchip_usb2phy *rphy);\n\tstruct usb2phy_reg\tclkout_ctl;\n\tconst struct rockchip_usb2phy_port_cfg\tport_cfgs[USB2PHY_NUM_PORTS];\n\tconst struct rockchip_chg_det_reg\tchg_det;\n};\n\n \nstruct rockchip_usb2phy_port {\n\tstruct phy\t*phy;\n\tunsigned int\tport_id;\n\tbool\t\tsuspended;\n\tbool\t\tvbus_attached;\n\tbool            host_disconnect;\n\tint\t\tbvalid_irq;\n\tint\t\tid_irq;\n\tint\t\tls_irq;\n\tint\t\totg_mux_irq;\n\tstruct mutex\tmutex;\n\tstruct\t\tdelayed_work chg_work;\n\tstruct\t\tdelayed_work otg_sm_work;\n\tstruct\t\tdelayed_work sm_work;\n\tconst struct\trockchip_usb2phy_port_cfg *port_cfg;\n\tstruct notifier_block\tevent_nb;\n\tenum usb_otg_state\tstate;\n\tenum usb_dr_mode\tmode;\n};\n\n \nstruct rockchip_usb2phy {\n\tstruct device\t*dev;\n\tstruct regmap\t*grf;\n\tstruct regmap\t*usbgrf;\n\tstruct clk\t*clk;\n\tstruct clk\t*clk480m;\n\tstruct clk_hw\tclk480m_hw;\n\tstruct reset_control\t*phy_reset;\n\tenum usb_chg_state\tchg_state;\n\tenum power_supply_type\tchg_type;\n\tu8\t\t\tdcd_retries;\n\tstruct extcon_dev\t*edev;\n\tint\t\t\tirq;\n\tconst struct rockchip_usb2phy_cfg\t*phy_cfg;\n\tstruct rockchip_usb2phy_port\tports[USB2PHY_NUM_PORTS];\n};\n\nstatic inline struct regmap *get_reg_base(struct rockchip_usb2phy *rphy)\n{\n\treturn rphy->usbgrf == NULL ? rphy->grf : rphy->usbgrf;\n}\n\nstatic inline int property_enable(struct regmap *base,\n\t\t\t\t  const struct usb2phy_reg *reg, bool en)\n{\n\tunsigned int val, mask, tmp;\n\n\ttmp = en ? reg->enable : reg->disable;\n\tmask = GENMASK(reg->bitend, reg->bitstart);\n\tval = (tmp << reg->bitstart) | (mask << BIT_WRITEABLE_SHIFT);\n\n\treturn regmap_write(base, reg->offset, val);\n}\n\nstatic inline bool property_enabled(struct regmap *base,\n\t\t\t\t    const struct usb2phy_reg *reg)\n{\n\tint ret;\n\tunsigned int tmp, orig;\n\tunsigned int mask = GENMASK(reg->bitend, reg->bitstart);\n\n\tret = regmap_read(base, reg->offset, &orig);\n\tif (ret)\n\t\treturn false;\n\n\ttmp = (orig & mask) >> reg->bitstart;\n\treturn tmp != reg->disable;\n}\n\nstatic int rockchip_usb2phy_reset(struct rockchip_usb2phy *rphy)\n{\n\tint ret;\n\n\tret = reset_control_assert(rphy->phy_reset);\n\tif (ret)\n\t\treturn ret;\n\n\tudelay(10);\n\n\tret = reset_control_deassert(rphy->phy_reset);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(100, 200);\n\n\treturn 0;\n}\n\nstatic int rockchip_usb2phy_clk480m_prepare(struct clk_hw *hw)\n{\n\tstruct rockchip_usb2phy *rphy =\n\t\tcontainer_of(hw, struct rockchip_usb2phy, clk480m_hw);\n\tstruct regmap *base = get_reg_base(rphy);\n\tint ret;\n\n\t \n\tif (!property_enabled(base, &rphy->phy_cfg->clkout_ctl)) {\n\t\tret = property_enable(base, &rphy->phy_cfg->clkout_ctl, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tusleep_range(1200, 1300);\n\t}\n\n\treturn 0;\n}\n\nstatic void rockchip_usb2phy_clk480m_unprepare(struct clk_hw *hw)\n{\n\tstruct rockchip_usb2phy *rphy =\n\t\tcontainer_of(hw, struct rockchip_usb2phy, clk480m_hw);\n\tstruct regmap *base = get_reg_base(rphy);\n\n\t \n\tproperty_enable(base, &rphy->phy_cfg->clkout_ctl, false);\n}\n\nstatic int rockchip_usb2phy_clk480m_prepared(struct clk_hw *hw)\n{\n\tstruct rockchip_usb2phy *rphy =\n\t\tcontainer_of(hw, struct rockchip_usb2phy, clk480m_hw);\n\tstruct regmap *base = get_reg_base(rphy);\n\n\treturn property_enabled(base, &rphy->phy_cfg->clkout_ctl);\n}\n\nstatic unsigned long\nrockchip_usb2phy_clk480m_recalc_rate(struct clk_hw *hw,\n\t\t\t\t     unsigned long parent_rate)\n{\n\treturn 480000000;\n}\n\nstatic const struct clk_ops rockchip_usb2phy_clkout_ops = {\n\t.prepare = rockchip_usb2phy_clk480m_prepare,\n\t.unprepare = rockchip_usb2phy_clk480m_unprepare,\n\t.is_prepared = rockchip_usb2phy_clk480m_prepared,\n\t.recalc_rate = rockchip_usb2phy_clk480m_recalc_rate,\n};\n\nstatic void rockchip_usb2phy_clk480m_unregister(void *data)\n{\n\tstruct rockchip_usb2phy *rphy = data;\n\n\tof_clk_del_provider(rphy->dev->of_node);\n\tclk_unregister(rphy->clk480m);\n}\n\nstatic int\nrockchip_usb2phy_clk480m_register(struct rockchip_usb2phy *rphy)\n{\n\tstruct device_node *node = rphy->dev->of_node;\n\tstruct clk_init_data init;\n\tconst char *clk_name;\n\tint ret = 0;\n\n\tinit.flags = 0;\n\tinit.name = \"clk_usbphy_480m\";\n\tinit.ops = &rockchip_usb2phy_clkout_ops;\n\n\t \n\tof_property_read_string(node, \"clock-output-names\", &init.name);\n\n\tif (rphy->clk) {\n\t\tclk_name = __clk_get_name(rphy->clk);\n\t\tinit.parent_names = &clk_name;\n\t\tinit.num_parents = 1;\n\t} else {\n\t\tinit.parent_names = NULL;\n\t\tinit.num_parents = 0;\n\t}\n\n\trphy->clk480m_hw.init = &init;\n\n\t \n\trphy->clk480m = clk_register(rphy->dev, &rphy->clk480m_hw);\n\tif (IS_ERR(rphy->clk480m)) {\n\t\tret = PTR_ERR(rphy->clk480m);\n\t\tgoto err_ret;\n\t}\n\n\tret = of_clk_add_provider(node, of_clk_src_simple_get, rphy->clk480m);\n\tif (ret < 0)\n\t\tgoto err_clk_provider;\n\n\treturn devm_add_action_or_reset(rphy->dev, rockchip_usb2phy_clk480m_unregister, rphy);\n\nerr_clk_provider:\n\tclk_unregister(rphy->clk480m);\nerr_ret:\n\treturn ret;\n}\n\nstatic int rockchip_usb2phy_extcon_register(struct rockchip_usb2phy *rphy)\n{\n\tint ret;\n\tstruct device_node *node = rphy->dev->of_node;\n\tstruct extcon_dev *edev;\n\n\tif (of_property_read_bool(node, \"extcon\")) {\n\t\tedev = extcon_get_edev_by_phandle(rphy->dev, 0);\n\t\tif (IS_ERR(edev)) {\n\t\t\tif (PTR_ERR(edev) != -EPROBE_DEFER)\n\t\t\t\tdev_err(rphy->dev, \"Invalid or missing extcon\\n\");\n\t\t\treturn PTR_ERR(edev);\n\t\t}\n\t} else {\n\t\t \n\t\tedev = devm_extcon_dev_allocate(rphy->dev,\n\t\t\t\t\t\trockchip_usb2phy_extcon_cable);\n\n\t\tif (IS_ERR(edev))\n\t\t\treturn -ENOMEM;\n\n\t\tret = devm_extcon_dev_register(rphy->dev, edev);\n\t\tif (ret) {\n\t\t\tdev_err(rphy->dev, \"failed to register extcon device\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\trphy->edev = edev;\n\n\treturn 0;\n}\n\nstatic int rockchip_usb2phy_enable_host_disc_irq(struct rockchip_usb2phy *rphy,\n\t\t\t\t\t\t struct rockchip_usb2phy_port *rport,\n\t\t\t\t\t\t bool en)\n{\n\tint ret;\n\n\tret = property_enable(rphy->grf, &rport->port_cfg->disfall_clr, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = property_enable(rphy->grf, &rport->port_cfg->disfall_en, en);\n\tif (ret)\n\t\treturn ret;\n\n\tret = property_enable(rphy->grf, &rport->port_cfg->disrise_clr, true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn property_enable(rphy->grf, &rport->port_cfg->disrise_en, en);\n}\n\nstatic int rockchip_usb2phy_init(struct phy *phy)\n{\n\tstruct rockchip_usb2phy_port *rport = phy_get_drvdata(phy);\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(phy->dev.parent);\n\tint ret = 0;\n\n\tmutex_lock(&rport->mutex);\n\n\tif (rport->port_id == USB2PHY_PORT_OTG) {\n\t\tif (rport->mode != USB_DR_MODE_HOST &&\n\t\t    rport->mode != USB_DR_MODE_UNKNOWN) {\n\t\t\t \n\t\t\tret = property_enable(rphy->grf,\n\t\t\t\t\t      &rport->port_cfg->bvalid_det_clr,\n\t\t\t\t\t      true);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = property_enable(rphy->grf,\n\t\t\t\t\t      &rport->port_cfg->bvalid_det_en,\n\t\t\t\t\t      true);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tret = property_enable(rphy->grf,\n\t\t\t\t\t      &rport->port_cfg->id_det_clr,\n\t\t\t\t\t      true);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tret = property_enable(rphy->grf,\n\t\t\t\t\t      &rport->port_cfg->id_det_en,\n\t\t\t\t\t      true);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tschedule_delayed_work(&rport->otg_sm_work,\n\t\t\t\t\t      OTG_SCHEDULE_DELAY * 3);\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(&rport->phy->dev, \"mode %d\\n\", rport->mode);\n\t\t}\n\t} else if (rport->port_id == USB2PHY_PORT_HOST) {\n\t\tif (rport->port_cfg->disfall_en.offset) {\n\t\t\trport->host_disconnect = true;\n\t\t\tret = rockchip_usb2phy_enable_host_disc_irq(rphy, rport, true);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(rphy->dev, \"failed to enable disconnect irq\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = property_enable(rphy->grf,\n\t\t\t\t      &rport->port_cfg->ls_det_clr, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = property_enable(rphy->grf,\n\t\t\t\t      &rport->port_cfg->ls_det_en, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tschedule_delayed_work(&rport->sm_work, SCHEDULE_DELAY);\n\t}\n\nout:\n\tmutex_unlock(&rport->mutex);\n\treturn ret;\n}\n\nstatic int rockchip_usb2phy_power_on(struct phy *phy)\n{\n\tstruct rockchip_usb2phy_port *rport = phy_get_drvdata(phy);\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(phy->dev.parent);\n\tstruct regmap *base = get_reg_base(rphy);\n\tint ret;\n\n\tdev_dbg(&rport->phy->dev, \"port power on\\n\");\n\n\tif (!rport->suspended)\n\t\treturn 0;\n\n\tret = clk_prepare_enable(rphy->clk480m);\n\tif (ret)\n\t\treturn ret;\n\n\tret = property_enable(base, &rport->port_cfg->phy_sus, false);\n\tif (ret) {\n\t\tclk_disable_unprepare(rphy->clk480m);\n\t\treturn ret;\n\t}\n\n\t \n\tret = rockchip_usb2phy_reset(rphy);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(1500, 2000);\n\n\trport->suspended = false;\n\treturn 0;\n}\n\nstatic int rockchip_usb2phy_power_off(struct phy *phy)\n{\n\tstruct rockchip_usb2phy_port *rport = phy_get_drvdata(phy);\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(phy->dev.parent);\n\tstruct regmap *base = get_reg_base(rphy);\n\tint ret;\n\n\tdev_dbg(&rport->phy->dev, \"port power off\\n\");\n\n\tif (rport->suspended)\n\t\treturn 0;\n\n\tret = property_enable(base, &rport->port_cfg->phy_sus, true);\n\tif (ret)\n\t\treturn ret;\n\n\trport->suspended = true;\n\tclk_disable_unprepare(rphy->clk480m);\n\n\treturn 0;\n}\n\nstatic int rockchip_usb2phy_exit(struct phy *phy)\n{\n\tstruct rockchip_usb2phy_port *rport = phy_get_drvdata(phy);\n\n\tif (rport->port_id == USB2PHY_PORT_OTG &&\n\t    rport->mode != USB_DR_MODE_HOST &&\n\t    rport->mode != USB_DR_MODE_UNKNOWN) {\n\t\tcancel_delayed_work_sync(&rport->otg_sm_work);\n\t\tcancel_delayed_work_sync(&rport->chg_work);\n\t} else if (rport->port_id == USB2PHY_PORT_HOST)\n\t\tcancel_delayed_work_sync(&rport->sm_work);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops rockchip_usb2phy_ops = {\n\t.init\t\t= rockchip_usb2phy_init,\n\t.exit\t\t= rockchip_usb2phy_exit,\n\t.power_on\t= rockchip_usb2phy_power_on,\n\t.power_off\t= rockchip_usb2phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void rockchip_usb2phy_otg_sm_work(struct work_struct *work)\n{\n\tstruct rockchip_usb2phy_port *rport =\n\t\tcontainer_of(work, struct rockchip_usb2phy_port,\n\t\t\t     otg_sm_work.work);\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);\n\tstatic unsigned int cable;\n\tunsigned long delay;\n\tbool vbus_attach, sch_work, notify_charger;\n\n\tvbus_attach = property_enabled(rphy->grf,\n\t\t\t\t       &rport->port_cfg->utmi_bvalid);\n\n\tsch_work = false;\n\tnotify_charger = false;\n\tdelay = OTG_SCHEDULE_DELAY;\n\tdev_dbg(&rport->phy->dev, \"%s otg sm work\\n\",\n\t\tusb_otg_state_string(rport->state));\n\n\tswitch (rport->state) {\n\tcase OTG_STATE_UNDEFINED:\n\t\trport->state = OTG_STATE_B_IDLE;\n\t\tif (!vbus_attach)\n\t\t\trockchip_usb2phy_power_off(rport->phy);\n\t\tfallthrough;\n\tcase OTG_STATE_B_IDLE:\n\t\tif (extcon_get_state(rphy->edev, EXTCON_USB_HOST) > 0) {\n\t\t\tdev_dbg(&rport->phy->dev, \"usb otg host connect\\n\");\n\t\t\trport->state = OTG_STATE_A_HOST;\n\t\t\trockchip_usb2phy_power_on(rport->phy);\n\t\t\treturn;\n\t\t} else if (vbus_attach) {\n\t\t\tdev_dbg(&rport->phy->dev, \"vbus_attach\\n\");\n\t\t\tswitch (rphy->chg_state) {\n\t\t\tcase USB_CHG_STATE_UNDEFINED:\n\t\t\t\tschedule_delayed_work(&rport->chg_work, 0);\n\t\t\t\treturn;\n\t\t\tcase USB_CHG_STATE_DETECTED:\n\t\t\t\tswitch (rphy->chg_type) {\n\t\t\t\tcase POWER_SUPPLY_TYPE_USB:\n\t\t\t\t\tdev_dbg(&rport->phy->dev, \"sdp cable is connected\\n\");\n\t\t\t\t\trockchip_usb2phy_power_on(rport->phy);\n\t\t\t\t\trport->state = OTG_STATE_B_PERIPHERAL;\n\t\t\t\t\tnotify_charger = true;\n\t\t\t\t\tsch_work = true;\n\t\t\t\t\tcable = EXTCON_CHG_USB_SDP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_TYPE_USB_DCP:\n\t\t\t\t\tdev_dbg(&rport->phy->dev, \"dcp cable is connected\\n\");\n\t\t\t\t\trockchip_usb2phy_power_off(rport->phy);\n\t\t\t\t\tnotify_charger = true;\n\t\t\t\t\tsch_work = true;\n\t\t\t\t\tcable = EXTCON_CHG_USB_DCP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase POWER_SUPPLY_TYPE_USB_CDP:\n\t\t\t\t\tdev_dbg(&rport->phy->dev, \"cdp cable is connected\\n\");\n\t\t\t\t\trockchip_usb2phy_power_on(rport->phy);\n\t\t\t\t\trport->state = OTG_STATE_B_PERIPHERAL;\n\t\t\t\t\tnotify_charger = true;\n\t\t\t\t\tsch_work = true;\n\t\t\t\t\tcable = EXTCON_CHG_USB_CDP;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tnotify_charger = true;\n\t\t\trphy->chg_state = USB_CHG_STATE_UNDEFINED;\n\t\t\trphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;\n\t\t}\n\n\t\tif (rport->vbus_attached != vbus_attach) {\n\t\t\trport->vbus_attached = vbus_attach;\n\n\t\t\tif (notify_charger && rphy->edev) {\n\t\t\t\textcon_set_state_sync(rphy->edev,\n\t\t\t\t\t\t\tcable, vbus_attach);\n\t\t\t\tif (cable == EXTCON_CHG_USB_SDP)\n\t\t\t\t\textcon_set_state_sync(rphy->edev,\n\t\t\t\t\t\t\t      EXTCON_USB,\n\t\t\t\t\t\t\t      vbus_attach);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tif (!vbus_attach) {\n\t\t\tdev_dbg(&rport->phy->dev, \"usb disconnect\\n\");\n\t\t\trphy->chg_state = USB_CHG_STATE_UNDEFINED;\n\t\t\trphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;\n\t\t\trport->state = OTG_STATE_B_IDLE;\n\t\t\tdelay = 0;\n\t\t\trockchip_usb2phy_power_off(rport->phy);\n\t\t}\n\t\tsch_work = true;\n\t\tbreak;\n\tcase OTG_STATE_A_HOST:\n\t\tif (extcon_get_state(rphy->edev, EXTCON_USB_HOST) == 0) {\n\t\t\tdev_dbg(&rport->phy->dev, \"usb otg host disconnect\\n\");\n\t\t\trport->state = OTG_STATE_B_IDLE;\n\t\t\trockchip_usb2phy_power_off(rport->phy);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sch_work)\n\t\tschedule_delayed_work(&rport->otg_sm_work, delay);\n}\n\nstatic const char *chg_to_string(enum power_supply_type chg_type)\n{\n\tswitch (chg_type) {\n\tcase POWER_SUPPLY_TYPE_USB:\n\t\treturn \"USB_SDP_CHARGER\";\n\tcase POWER_SUPPLY_TYPE_USB_DCP:\n\t\treturn \"USB_DCP_CHARGER\";\n\tcase POWER_SUPPLY_TYPE_USB_CDP:\n\t\treturn \"USB_CDP_CHARGER\";\n\tdefault:\n\t\treturn \"INVALID_CHARGER\";\n\t}\n}\n\nstatic void rockchip_chg_enable_dcd(struct rockchip_usb2phy *rphy,\n\t\t\t\t    bool en)\n{\n\tstruct regmap *base = get_reg_base(rphy);\n\n\tproperty_enable(base, &rphy->phy_cfg->chg_det.rdm_pdwn_en, en);\n\tproperty_enable(base, &rphy->phy_cfg->chg_det.idp_src_en, en);\n}\n\nstatic void rockchip_chg_enable_primary_det(struct rockchip_usb2phy *rphy,\n\t\t\t\t\t    bool en)\n{\n\tstruct regmap *base = get_reg_base(rphy);\n\n\tproperty_enable(base, &rphy->phy_cfg->chg_det.vdp_src_en, en);\n\tproperty_enable(base, &rphy->phy_cfg->chg_det.idm_sink_en, en);\n}\n\nstatic void rockchip_chg_enable_secondary_det(struct rockchip_usb2phy *rphy,\n\t\t\t\t\t      bool en)\n{\n\tstruct regmap *base = get_reg_base(rphy);\n\n\tproperty_enable(base, &rphy->phy_cfg->chg_det.vdm_src_en, en);\n\tproperty_enable(base, &rphy->phy_cfg->chg_det.idp_sink_en, en);\n}\n\n#define CHG_DCD_POLL_TIME\t(100 * HZ / 1000)\n#define CHG_DCD_MAX_RETRIES\t6\n#define CHG_PRIMARY_DET_TIME\t(40 * HZ / 1000)\n#define CHG_SECONDARY_DET_TIME\t(40 * HZ / 1000)\nstatic void rockchip_chg_detect_work(struct work_struct *work)\n{\n\tstruct rockchip_usb2phy_port *rport =\n\t\tcontainer_of(work, struct rockchip_usb2phy_port, chg_work.work);\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);\n\tstruct regmap *base = get_reg_base(rphy);\n\tbool is_dcd, tmout, vout;\n\tunsigned long delay;\n\n\tdev_dbg(&rport->phy->dev, \"chg detection work state = %d\\n\",\n\t\trphy->chg_state);\n\tswitch (rphy->chg_state) {\n\tcase USB_CHG_STATE_UNDEFINED:\n\t\tif (!rport->suspended)\n\t\t\trockchip_usb2phy_power_off(rport->phy);\n\t\t \n\t\tproperty_enable(base, &rphy->phy_cfg->chg_det.opmode, false);\n\t\t \n\t\trockchip_chg_enable_dcd(rphy, true);\n\t\trphy->chg_state = USB_CHG_STATE_WAIT_FOR_DCD;\n\t\trphy->dcd_retries = 0;\n\t\tdelay = CHG_DCD_POLL_TIME;\n\t\tbreak;\n\tcase USB_CHG_STATE_WAIT_FOR_DCD:\n\t\t \n\t\tis_dcd = property_enabled(rphy->grf,\n\t\t\t\t\t  &rphy->phy_cfg->chg_det.dp_det);\n\t\ttmout = ++rphy->dcd_retries == CHG_DCD_MAX_RETRIES;\n\t\t \n\t\tif (is_dcd || tmout) {\n\t\t\t \n\t\t\t \n\t\t\trockchip_chg_enable_dcd(rphy, false);\n\t\t\t \n\t\t\trockchip_chg_enable_primary_det(rphy, true);\n\t\t\tdelay = CHG_PRIMARY_DET_TIME;\n\t\t\trphy->chg_state = USB_CHG_STATE_DCD_DONE;\n\t\t} else {\n\t\t\t \n\t\t\tdelay = CHG_DCD_POLL_TIME;\n\t\t}\n\t\tbreak;\n\tcase USB_CHG_STATE_DCD_DONE:\n\t\tvout = property_enabled(rphy->grf,\n\t\t\t\t\t&rphy->phy_cfg->chg_det.cp_det);\n\t\trockchip_chg_enable_primary_det(rphy, false);\n\t\tif (vout) {\n\t\t\t \n\t\t\trockchip_chg_enable_secondary_det(rphy, true);\n\t\t\tdelay = CHG_SECONDARY_DET_TIME;\n\t\t\trphy->chg_state = USB_CHG_STATE_PRIMARY_DONE;\n\t\t} else {\n\t\t\tif (rphy->dcd_retries == CHG_DCD_MAX_RETRIES) {\n\t\t\t\t \n\t\t\t\trphy->chg_type = POWER_SUPPLY_TYPE_USB_DCP;\n\t\t\t\trphy->chg_state = USB_CHG_STATE_DETECTED;\n\t\t\t\tdelay = 0;\n\t\t\t} else {\n\t\t\t\trphy->chg_type = POWER_SUPPLY_TYPE_USB;\n\t\t\t\trphy->chg_state = USB_CHG_STATE_DETECTED;\n\t\t\t\tdelay = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase USB_CHG_STATE_PRIMARY_DONE:\n\t\tvout = property_enabled(rphy->grf,\n\t\t\t\t\t&rphy->phy_cfg->chg_det.dcp_det);\n\t\t \n\t\trockchip_chg_enable_secondary_det(rphy, false);\n\t\tif (vout)\n\t\t\trphy->chg_type = POWER_SUPPLY_TYPE_USB_DCP;\n\t\telse\n\t\t\trphy->chg_type = POWER_SUPPLY_TYPE_USB_CDP;\n\t\tfallthrough;\n\tcase USB_CHG_STATE_SECONDARY_DONE:\n\t\trphy->chg_state = USB_CHG_STATE_DETECTED;\n\t\tfallthrough;\n\tcase USB_CHG_STATE_DETECTED:\n\t\t \n\t\tproperty_enable(base, &rphy->phy_cfg->chg_det.opmode, true);\n\t\trockchip_usb2phy_otg_sm_work(&rport->otg_sm_work.work);\n\t\tdev_dbg(&rport->phy->dev, \"charger = %s\\n\",\n\t\t\t chg_to_string(rphy->chg_type));\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n\n\tschedule_delayed_work(&rport->chg_work, delay);\n}\n\n \nstatic void rockchip_usb2phy_sm_work(struct work_struct *work)\n{\n\tstruct rockchip_usb2phy_port *rport =\n\t\tcontainer_of(work, struct rockchip_usb2phy_port, sm_work.work);\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);\n\tunsigned int sh, ul, uhd, state;\n\tunsigned int ul_mask, uhd_mask;\n\tint ret;\n\n\tmutex_lock(&rport->mutex);\n\n\tret = regmap_read(rphy->grf, rport->port_cfg->utmi_ls.offset, &ul);\n\tif (ret < 0)\n\t\tgoto next_schedule;\n\n\tul_mask = GENMASK(rport->port_cfg->utmi_ls.bitend,\n\t\t\t  rport->port_cfg->utmi_ls.bitstart);\n\n\tif (rport->port_cfg->utmi_hstdet.offset) {\n\t\tret = regmap_read(rphy->grf, rport->port_cfg->utmi_hstdet.offset, &uhd);\n\t\tif (ret < 0)\n\t\t\tgoto next_schedule;\n\n\t\tuhd_mask = GENMASK(rport->port_cfg->utmi_hstdet.bitend,\n\t\t\t\t   rport->port_cfg->utmi_hstdet.bitstart);\n\n\t\tsh = rport->port_cfg->utmi_hstdet.bitend -\n\t\t     rport->port_cfg->utmi_hstdet.bitstart + 1;\n\t\t \n\t\tstate = ((uhd & uhd_mask) >> rport->port_cfg->utmi_hstdet.bitstart) |\n\t\t\t(((ul & ul_mask) >> rport->port_cfg->utmi_ls.bitstart) << sh);\n\t} else {\n\t\tstate = ((ul & ul_mask) >> rport->port_cfg->utmi_ls.bitstart) << 1 |\n\t\t\trport->host_disconnect;\n\t}\n\n\tswitch (state) {\n\tcase PHY_STATE_HS_ONLINE:\n\t\tdev_dbg(&rport->phy->dev, \"HS online\\n\");\n\t\tbreak;\n\tcase PHY_STATE_FS_LS_ONLINE:\n\t\t \n\t\tif (!rport->suspended) {\n\t\t\t \n\t\t\tdev_dbg(&rport->phy->dev, \"FS/LS online\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase PHY_STATE_CONNECT:\n\t\tif (rport->suspended) {\n\t\t\tdev_dbg(&rport->phy->dev, \"Connected\\n\");\n\t\t\trockchip_usb2phy_power_on(rport->phy);\n\t\t\trport->suspended = false;\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(&rport->phy->dev, \"FS/LS online\\n\");\n\t\t}\n\t\tbreak;\n\tcase PHY_STATE_DISCONNECT:\n\t\tif (!rport->suspended) {\n\t\t\tdev_dbg(&rport->phy->dev, \"Disconnected\\n\");\n\t\t\trockchip_usb2phy_power_off(rport->phy);\n\t\t\trport->suspended = true;\n\t\t}\n\n\t\t \n\t\tproperty_enable(rphy->grf, &rport->port_cfg->ls_det_clr, true);\n\t\tproperty_enable(rphy->grf, &rport->port_cfg->ls_det_en, true);\n\n\t\t \n\t\tmutex_unlock(&rport->mutex);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&rport->phy->dev, \"unknown phy state\\n\");\n\t\tbreak;\n\t}\n\nnext_schedule:\n\tmutex_unlock(&rport->mutex);\n\tschedule_delayed_work(&rport->sm_work, SCHEDULE_DELAY);\n}\n\nstatic irqreturn_t rockchip_usb2phy_linestate_irq(int irq, void *data)\n{\n\tstruct rockchip_usb2phy_port *rport = data;\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);\n\n\tif (!property_enabled(rphy->grf, &rport->port_cfg->ls_det_st))\n\t\treturn IRQ_NONE;\n\n\tmutex_lock(&rport->mutex);\n\n\t \n\tproperty_enable(rphy->grf, &rport->port_cfg->ls_det_en, false);\n\tproperty_enable(rphy->grf, &rport->port_cfg->ls_det_clr, true);\n\n\tmutex_unlock(&rport->mutex);\n\n\t \n\tif (rport->suspended && rport->port_id == USB2PHY_PORT_HOST)\n\t\trockchip_usb2phy_sm_work(&rport->sm_work.work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rockchip_usb2phy_bvalid_irq(int irq, void *data)\n{\n\tstruct rockchip_usb2phy_port *rport = data;\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);\n\n\tif (!property_enabled(rphy->grf, &rport->port_cfg->bvalid_det_st))\n\t\treturn IRQ_NONE;\n\n\t \n\tproperty_enable(rphy->grf, &rport->port_cfg->bvalid_det_clr, true);\n\n\trockchip_usb2phy_otg_sm_work(&rport->otg_sm_work.work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rockchip_usb2phy_id_irq(int irq, void *data)\n{\n\tstruct rockchip_usb2phy_port *rport = data;\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);\n\tbool id;\n\n\tif (!property_enabled(rphy->grf, &rport->port_cfg->id_det_st))\n\t\treturn IRQ_NONE;\n\n\t \n\tproperty_enable(rphy->grf, &rport->port_cfg->id_det_clr, true);\n\n\tid = property_enabled(rphy->grf, &rport->port_cfg->utmi_id);\n\textcon_set_state_sync(rphy->edev, EXTCON_USB_HOST, !id);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rockchip_usb2phy_otg_mux_irq(int irq, void *data)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\n\tret |= rockchip_usb2phy_bvalid_irq(irq, data);\n\tret |= rockchip_usb2phy_id_irq(irq, data);\n\n\treturn ret;\n}\n\nstatic irqreturn_t rockchip_usb2phy_host_disc_irq(int irq, void *data)\n{\n\tstruct rockchip_usb2phy_port *rport = data;\n\tstruct rockchip_usb2phy *rphy = dev_get_drvdata(rport->phy->dev.parent);\n\n\tif (!property_enabled(rphy->grf, &rport->port_cfg->disfall_st) &&\n\t    !property_enabled(rphy->grf, &rport->port_cfg->disrise_st))\n\t\treturn IRQ_NONE;\n\n\tmutex_lock(&rport->mutex);\n\n\t \n\tif (property_enabled(rphy->grf, &rport->port_cfg->disfall_st)) {\n\t\tproperty_enable(rphy->grf, &rport->port_cfg->disfall_clr, true);\n\t\trport->host_disconnect = false;\n\t} else if (property_enabled(rphy->grf, &rport->port_cfg->disrise_st)) {\n\t\tproperty_enable(rphy->grf, &rport->port_cfg->disrise_clr, true);\n\t\trport->host_disconnect = true;\n\t}\n\n\tmutex_unlock(&rport->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rockchip_usb2phy_irq(int irq, void *data)\n{\n\tstruct rockchip_usb2phy *rphy = data;\n\tstruct rockchip_usb2phy_port *rport;\n\tirqreturn_t ret = IRQ_NONE;\n\tunsigned int index;\n\n\tfor (index = 0; index < rphy->phy_cfg->num_ports; index++) {\n\t\trport = &rphy->ports[index];\n\t\tif (!rport->phy)\n\t\t\tcontinue;\n\n\t\tif (rport->port_id == USB2PHY_PORT_HOST &&\n\t\t    rport->port_cfg->disfall_en.offset)\n\t\t\tret |= rockchip_usb2phy_host_disc_irq(irq, rport);\n\n\t\tswitch (rport->port_id) {\n\t\tcase USB2PHY_PORT_OTG:\n\t\t\tif (rport->mode != USB_DR_MODE_HOST &&\n\t\t\t    rport->mode != USB_DR_MODE_UNKNOWN)\n\t\t\t\tret |= rockchip_usb2phy_otg_mux_irq(irq, rport);\n\t\t\tbreak;\n\t\tcase USB2PHY_PORT_HOST:\n\t\t\tret |= rockchip_usb2phy_linestate_irq(irq, rport);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int rockchip_usb2phy_port_irq_init(struct rockchip_usb2phy *rphy,\n\t\t\t\t\t  struct rockchip_usb2phy_port *rport,\n\t\t\t\t\t  struct device_node *child_np)\n{\n\tint ret;\n\n\t \n\tif (rphy->irq > 0)\n\t\treturn 0;\n\n\tswitch (rport->port_id) {\n\tcase USB2PHY_PORT_HOST:\n\t\trport->ls_irq = of_irq_get_byname(child_np, \"linestate\");\n\t\tif (rport->ls_irq < 0) {\n\t\t\tdev_err(rphy->dev, \"no linestate irq provided\\n\");\n\t\t\treturn rport->ls_irq;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(rphy->dev, rport->ls_irq, NULL,\n\t\t\t\t\t\trockchip_usb2phy_linestate_irq,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"rockchip_usb2phy\", rport);\n\t\tif (ret) {\n\t\t\tdev_err(rphy->dev, \"failed to request linestate irq handle\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase USB2PHY_PORT_OTG:\n\t\t \n\t\trport->otg_mux_irq = of_irq_get_byname(child_np, \"otg-mux\");\n\t\tif (rport->otg_mux_irq > 0) {\n\t\t\tret = devm_request_threaded_irq(rphy->dev, rport->otg_mux_irq,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\trockchip_usb2phy_otg_mux_irq,\n\t\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\t\"rockchip_usb2phy_otg\",\n\t\t\t\t\t\t\trport);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(rphy->dev,\n\t\t\t\t\t\"failed to request otg-mux irq handle\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\trport->bvalid_irq = of_irq_get_byname(child_np, \"otg-bvalid\");\n\t\t\tif (rport->bvalid_irq < 0) {\n\t\t\t\tdev_err(rphy->dev, \"no vbus valid irq provided\\n\");\n\t\t\t\tret = rport->bvalid_irq;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = devm_request_threaded_irq(rphy->dev, rport->bvalid_irq,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\trockchip_usb2phy_bvalid_irq,\n\t\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\t\"rockchip_usb2phy_bvalid\",\n\t\t\t\t\t\t\trport);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(rphy->dev,\n\t\t\t\t\t\"failed to request otg-bvalid irq handle\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\trport->id_irq = of_irq_get_byname(child_np, \"otg-id\");\n\t\t\tif (rport->id_irq < 0) {\n\t\t\t\tdev_err(rphy->dev, \"no otg-id irq provided\\n\");\n\t\t\t\tret = rport->id_irq;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = devm_request_threaded_irq(rphy->dev, rport->id_irq,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\trockchip_usb2phy_id_irq,\n\t\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\t\"rockchip_usb2phy_id\",\n\t\t\t\t\t\t\trport);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(rphy->dev,\n\t\t\t\t\t\"failed to request otg-id irq handle\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_usb2phy_host_port_init(struct rockchip_usb2phy *rphy,\n\t\t\t\t\t   struct rockchip_usb2phy_port *rport,\n\t\t\t\t\t   struct device_node *child_np)\n{\n\tint ret;\n\n\trport->port_id = USB2PHY_PORT_HOST;\n\trport->port_cfg = &rphy->phy_cfg->port_cfgs[USB2PHY_PORT_HOST];\n\trport->suspended = true;\n\n\tmutex_init(&rport->mutex);\n\tINIT_DELAYED_WORK(&rport->sm_work, rockchip_usb2phy_sm_work);\n\n\tret = rockchip_usb2phy_port_irq_init(rphy, rport, child_np);\n\tif (ret) {\n\t\tdev_err(rphy->dev, \"failed to setup host irq\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_otg_event(struct notifier_block *nb,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct rockchip_usb2phy_port *rport =\n\t\tcontainer_of(nb, struct rockchip_usb2phy_port, event_nb);\n\n\tschedule_delayed_work(&rport->otg_sm_work, OTG_SCHEDULE_DELAY);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int rockchip_usb2phy_otg_port_init(struct rockchip_usb2phy *rphy,\n\t\t\t\t\t  struct rockchip_usb2phy_port *rport,\n\t\t\t\t\t  struct device_node *child_np)\n{\n\tint ret, id;\n\n\trport->port_id = USB2PHY_PORT_OTG;\n\trport->port_cfg = &rphy->phy_cfg->port_cfgs[USB2PHY_PORT_OTG];\n\trport->state = OTG_STATE_UNDEFINED;\n\n\t \n\trport->suspended = true;\n\trport->vbus_attached = false;\n\n\tmutex_init(&rport->mutex);\n\n\trport->mode = of_usb_get_dr_mode_by_phy(child_np, -1);\n\tif (rport->mode == USB_DR_MODE_HOST ||\n\t    rport->mode == USB_DR_MODE_UNKNOWN) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tINIT_DELAYED_WORK(&rport->chg_work, rockchip_chg_detect_work);\n\tINIT_DELAYED_WORK(&rport->otg_sm_work, rockchip_usb2phy_otg_sm_work);\n\n\tret = rockchip_usb2phy_port_irq_init(rphy, rport, child_np);\n\tif (ret) {\n\t\tdev_err(rphy->dev, \"failed to init irq for host port\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!IS_ERR(rphy->edev)) {\n\t\trport->event_nb.notifier_call = rockchip_otg_event;\n\n\t\tret = devm_extcon_register_notifier(rphy->dev, rphy->edev,\n\t\t\t\t\tEXTCON_USB_HOST, &rport->event_nb);\n\t\tif (ret) {\n\t\t\tdev_err(rphy->dev, \"register USB HOST notifier failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!of_property_read_bool(rphy->dev->of_node, \"extcon\")) {\n\t\t\t \n\t\t\tid = property_enabled(rphy->grf, &rport->port_cfg->utmi_id);\n\t\t\textcon_set_state_sync(rphy->edev, EXTCON_USB_HOST, !id);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int rockchip_usb2phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child_np;\n\tstruct phy_provider *provider;\n\tstruct rockchip_usb2phy *rphy;\n\tconst struct rockchip_usb2phy_cfg *phy_cfgs;\n\tunsigned int reg;\n\tint index, ret;\n\n\trphy = devm_kzalloc(dev, sizeof(*rphy), GFP_KERNEL);\n\tif (!rphy)\n\t\treturn -ENOMEM;\n\n\tif (!dev->parent || !dev->parent->of_node) {\n\t\trphy->grf = syscon_regmap_lookup_by_phandle(np, \"rockchip,usbgrf\");\n\t\tif (IS_ERR(rphy->grf)) {\n\t\t\tdev_err(dev, \"failed to locate usbgrf\\n\");\n\t\t\treturn PTR_ERR(rphy->grf);\n\t\t}\n\t}\n\n\telse {\n\t\trphy->grf = syscon_node_to_regmap(dev->parent->of_node);\n\t\tif (IS_ERR(rphy->grf))\n\t\t\treturn PTR_ERR(rphy->grf);\n\t}\n\n\tif (of_device_is_compatible(np, \"rockchip,rv1108-usb2phy\")) {\n\t\trphy->usbgrf =\n\t\t\tsyscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"rockchip,usbgrf\");\n\t\tif (IS_ERR(rphy->usbgrf))\n\t\t\treturn PTR_ERR(rphy->usbgrf);\n\t} else {\n\t\trphy->usbgrf = NULL;\n\t}\n\n\tif (of_property_read_u32_index(np, \"reg\", 0, &reg)) {\n\t\tdev_err(dev, \"the reg property is not assigned in %pOFn node\\n\",\n\t\t\tnp);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (of_property_count_u32_elems(np, \"reg\") > 2 && reg == 0) {\n\t\tif (of_property_read_u32_index(np, \"reg\", 1, &reg)) {\n\t\t\tdev_err(dev, \"the reg property is not assigned in %pOFn node\\n\",\n\t\t\t\tnp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trphy->dev = dev;\n\tphy_cfgs = device_get_match_data(dev);\n\trphy->chg_state = USB_CHG_STATE_UNDEFINED;\n\trphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;\n\trphy->irq = platform_get_irq_optional(pdev, 0);\n\tplatform_set_drvdata(pdev, rphy);\n\n\tif (!phy_cfgs)\n\t\treturn dev_err_probe(dev, -EINVAL, \"phy configs are not assigned!\\n\");\n\n\tret = rockchip_usb2phy_extcon_register(rphy);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tindex = 0;\n\tdo {\n\t\tif (phy_cfgs[index].reg == reg) {\n\t\t\trphy->phy_cfg = &phy_cfgs[index];\n\t\t\tbreak;\n\t\t}\n\n\t\t++index;\n\t} while (phy_cfgs[index].reg);\n\n\tif (!rphy->phy_cfg) {\n\t\tdev_err(dev, \"could not find phy config for reg=0x%08x\\n\", reg);\n\t\treturn -EINVAL;\n\t}\n\n\trphy->phy_reset = devm_reset_control_get_optional(dev, \"phy\");\n\tif (IS_ERR(rphy->phy_reset))\n\t\treturn PTR_ERR(rphy->phy_reset);\n\n\trphy->clk = devm_clk_get_optional_enabled(dev, \"phyclk\");\n\tif (IS_ERR(rphy->clk)) {\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rphy->clk),\n\t\t\t\t     \"failed to get phyclk\\n\");\n\t}\n\n\tret = rockchip_usb2phy_clk480m_register(rphy);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register 480m output clock\\n\");\n\t\treturn ret;\n\t}\n\n\tif (rphy->phy_cfg->phy_tuning) {\n\t\tret = rphy->phy_cfg->phy_tuning(rphy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tindex = 0;\n\tfor_each_available_child_of_node(np, child_np) {\n\t\tstruct rockchip_usb2phy_port *rport = &rphy->ports[index];\n\t\tstruct phy *phy;\n\n\t\t \n\t\tif (!of_node_name_eq(child_np, \"host-port\") &&\n\t\t    !of_node_name_eq(child_np, \"otg-port\"))\n\t\t\tgoto next_child;\n\n\t\tphy = devm_phy_create(dev, child_np, &rockchip_usb2phy_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err_probe(dev, PTR_ERR(phy), \"failed to create phy\\n\");\n\t\t\tret = PTR_ERR(phy);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\trport->phy = phy;\n\t\tphy_set_drvdata(rport->phy, rport);\n\n\t\t \n\t\tif (of_node_name_eq(child_np, \"host-port\")) {\n\t\t\tret = rockchip_usb2phy_host_port_init(rphy, rport,\n\t\t\t\t\t\t\t      child_np);\n\t\t\tif (ret)\n\t\t\t\tgoto put_child;\n\t\t} else {\n\t\t\tret = rockchip_usb2phy_otg_port_init(rphy, rport,\n\t\t\t\t\t\t\t     child_np);\n\t\t\tif (ret)\n\t\t\t\tgoto put_child;\n\t\t}\n\nnext_child:\n\t\t \n\t\tif (++index >= rphy->phy_cfg->num_ports) {\n\t\t\tof_node_put(child_np);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\tif (rphy->irq > 0) {\n\t\tret = devm_request_threaded_irq(rphy->dev, rphy->irq, NULL,\n\t\t\t\t\t\trockchip_usb2phy_irq,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"rockchip_usb2phy\",\n\t\t\t\t\t\trphy);\n\t\tif (ret) {\n\t\t\tdev_err(rphy->dev,\n\t\t\t\t\"failed to request usb2phy irq handle\\n\");\n\t\t\tgoto put_child;\n\t\t}\n\t}\n\n\treturn PTR_ERR_OR_ZERO(provider);\n\nput_child:\n\tof_node_put(child_np);\n\treturn ret;\n}\n\nstatic int rk3588_usb2phy_tuning(struct rockchip_usb2phy *rphy)\n{\n\tint ret;\n\tbool usb3otg = false;\n\t \n\tint suspend_cfg = 0x14;\n\n\tif (rphy->phy_cfg->reg == 0x0000 || rphy->phy_cfg->reg == 0x4000) {\n\t\t \n\t\tsuspend_cfg |= 0x01;  \n\t\tusb3otg = true;\n\t} else if (rphy->phy_cfg->reg == 0x8000 || rphy->phy_cfg->reg == 0xc000) {\n\t\t \n\t\tsuspend_cfg |= 0x00;  \n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_write(rphy->grf, 0x0008, GENMASK(29, 29) | 0x0000);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = rockchip_usb2phy_reset(rphy);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret |= regmap_write(rphy->grf, 0x000c, GENMASK(20, 16) | suspend_cfg);\n\n\t \n\tret |= regmap_write(rphy->grf, 0x0004, GENMASK(27, 24) | 0x0900);\n\n\t \n\tret |= regmap_write(rphy->grf, 0x0008, GENMASK(20, 19) | 0x0010);\n\n\tif (!usb3otg)\n\t\treturn ret;\n\n\t \n\tret |= regmap_write(rphy->grf, 0x0010, GENMASK(17, 16) | 0x0003);\n\n\treturn ret;\n}\n\nstatic const struct rockchip_usb2phy_cfg rk3228_phy_cfgs[] = {\n\t{\n\t\t.reg = 0x760,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0x0768, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x0760, 15, 0, 0, 0x1d1 },\n\t\t\t\t.bvalid_det_en\t= { 0x0680, 3, 3, 0, 1 },\n\t\t\t\t.bvalid_det_st\t= { 0x0690, 3, 3, 0, 1 },\n\t\t\t\t.bvalid_det_clr\t= { 0x06a0, 3, 3, 0, 1 },\n\t\t\t\t.id_det_en\t= { 0x0680, 6, 5, 0, 3 },\n\t\t\t\t.id_det_st\t= { 0x0690, 6, 5, 0, 3 },\n\t\t\t\t.id_det_clr\t= { 0x06a0, 6, 5, 0, 3 },\n\t\t\t\t.ls_det_en\t= { 0x0680, 2, 2, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0690, 2, 2, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x06a0, 2, 2, 0, 1 },\n\t\t\t\t.utmi_bvalid\t= { 0x0480, 4, 4, 0, 1 },\n\t\t\t\t.utmi_id\t= { 0x0480, 1, 1, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x0480, 3, 2, 0, 1 },\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x0764, 15, 0, 0, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x0680, 4, 4, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0690, 4, 4, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x06a0, 4, 4, 0, 1 }\n\t\t\t}\n\t\t},\n\t\t.chg_det = {\n\t\t\t.opmode\t\t= { 0x0760, 3, 0, 5, 1 },\n\t\t\t.cp_det\t\t= { 0x0884, 4, 4, 0, 1 },\n\t\t\t.dcp_det\t= { 0x0884, 3, 3, 0, 1 },\n\t\t\t.dp_det\t\t= { 0x0884, 5, 5, 0, 1 },\n\t\t\t.idm_sink_en\t= { 0x0768, 8, 8, 0, 1 },\n\t\t\t.idp_sink_en\t= { 0x0768, 7, 7, 0, 1 },\n\t\t\t.idp_src_en\t= { 0x0768, 9, 9, 0, 1 },\n\t\t\t.rdm_pdwn_en\t= { 0x0768, 10, 10, 0, 1 },\n\t\t\t.vdm_src_en\t= { 0x0768, 12, 12, 0, 1 },\n\t\t\t.vdp_src_en\t= { 0x0768, 11, 11, 0, 1 },\n\t\t},\n\t},\n\t{\n\t\t.reg = 0x800,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0x0808, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x800, 15, 0, 0, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x0684, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0694, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x06a4, 0, 0, 0, 1 }\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x804, 15, 0, 0, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x0684, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0694, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x06a4, 1, 1, 0, 1 }\n\t\t\t}\n\t\t},\n\t},\n\t{   }\n};\n\nstatic const struct rockchip_usb2phy_cfg rk3308_phy_cfgs[] = {\n\t{\n\t\t.reg = 0x100,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0x108, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x0100, 8, 0, 0, 0x1d1 },\n\t\t\t\t.bvalid_det_en\t= { 0x3020, 3, 2, 0, 3 },\n\t\t\t\t.bvalid_det_st\t= { 0x3024, 3, 2, 0, 3 },\n\t\t\t\t.bvalid_det_clr = { 0x3028, 3, 2, 0, 3 },\n\t\t\t\t.id_det_en\t= { 0x3020, 5, 4, 0, 3 },\n\t\t\t\t.id_det_st\t= { 0x3024, 5, 4, 0, 3 },\n\t\t\t\t.id_det_clr\t= { 0x3028, 5, 4, 0, 3 },\n\t\t\t\t.ls_det_en\t= { 0x3020, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x3024, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x3028, 0, 0, 0, 1 },\n\t\t\t\t.utmi_avalid\t= { 0x0120, 10, 10, 0, 1 },\n\t\t\t\t.utmi_bvalid\t= { 0x0120, 9, 9, 0, 1 },\n\t\t\t\t.utmi_id\t= { 0x0120, 6, 6, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x0120, 5, 4, 0, 1 },\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x0104, 8, 0, 0, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x3020, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x3024, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x3028, 1, 1, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x0120, 17, 16, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0x0120, 19, 19, 0, 1 }\n\t\t\t}\n\t\t},\n\t\t.chg_det = {\n\t\t\t.opmode\t\t= { 0x0100, 3, 0, 5, 1 },\n\t\t\t.cp_det\t\t= { 0x0120, 24, 24, 0, 1 },\n\t\t\t.dcp_det\t= { 0x0120, 23, 23, 0, 1 },\n\t\t\t.dp_det\t\t= { 0x0120, 25, 25, 0, 1 },\n\t\t\t.idm_sink_en\t= { 0x0108, 8, 8, 0, 1 },\n\t\t\t.idp_sink_en\t= { 0x0108, 7, 7, 0, 1 },\n\t\t\t.idp_src_en\t= { 0x0108, 9, 9, 0, 1 },\n\t\t\t.rdm_pdwn_en\t= { 0x0108, 10, 10, 0, 1 },\n\t\t\t.vdm_src_en\t= { 0x0108, 12, 12, 0, 1 },\n\t\t\t.vdp_src_en\t= { 0x0108, 11, 11, 0, 1 },\n\t\t},\n\t},\n\t{   }\n};\n\nstatic const struct rockchip_usb2phy_cfg rk3328_phy_cfgs[] = {\n\t{\n\t\t.reg = 0x100,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0x108, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x0100, 15, 0, 0, 0x1d1 },\n\t\t\t\t.bvalid_det_en\t= { 0x0110, 3, 2, 0, 3 },\n\t\t\t\t.bvalid_det_st\t= { 0x0114, 3, 2, 0, 3 },\n\t\t\t\t.bvalid_det_clr = { 0x0118, 3, 2, 0, 3 },\n\t\t\t\t.id_det_en\t= { 0x0110, 5, 4, 0, 3 },\n\t\t\t\t.id_det_st\t= { 0x0114, 5, 4, 0, 3 },\n\t\t\t\t.id_det_clr\t= { 0x0118, 5, 4, 0, 3 },\n\t\t\t\t.ls_det_en\t= { 0x0110, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0114, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x0118, 0, 0, 0, 1 },\n\t\t\t\t.utmi_avalid\t= { 0x0120, 10, 10, 0, 1 },\n\t\t\t\t.utmi_bvalid\t= { 0x0120, 9, 9, 0, 1 },\n\t\t\t\t.utmi_id\t= { 0x0120, 6, 6, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x0120, 5, 4, 0, 1 },\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x104, 15, 0, 0, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x110, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x114, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x118, 1, 1, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x120, 17, 16, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0x120, 19, 19, 0, 1 }\n\t\t\t}\n\t\t},\n\t\t.chg_det = {\n\t\t\t.opmode\t\t= { 0x0100, 3, 0, 5, 1 },\n\t\t\t.cp_det\t\t= { 0x0120, 24, 24, 0, 1 },\n\t\t\t.dcp_det\t= { 0x0120, 23, 23, 0, 1 },\n\t\t\t.dp_det\t\t= { 0x0120, 25, 25, 0, 1 },\n\t\t\t.idm_sink_en\t= { 0x0108, 8, 8, 0, 1 },\n\t\t\t.idp_sink_en\t= { 0x0108, 7, 7, 0, 1 },\n\t\t\t.idp_src_en\t= { 0x0108, 9, 9, 0, 1 },\n\t\t\t.rdm_pdwn_en\t= { 0x0108, 10, 10, 0, 1 },\n\t\t\t.vdm_src_en\t= { 0x0108, 12, 12, 0, 1 },\n\t\t\t.vdp_src_en\t= { 0x0108, 11, 11, 0, 1 },\n\t\t},\n\t},\n\t{   }\n};\n\nstatic const struct rockchip_usb2phy_cfg rk3366_phy_cfgs[] = {\n\t{\n\t\t.reg = 0x700,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0x0724, 15, 15, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x0728, 15, 0, 0, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x0680, 4, 4, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0690, 4, 4, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x06a0, 4, 4, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x049c, 14, 13, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0x049c, 12, 12, 0, 1 }\n\t\t\t}\n\t\t},\n\t},\n\t{   }\n};\n\nstatic const struct rockchip_usb2phy_cfg rk3399_phy_cfgs[] = {\n\t{\n\t\t.reg\t\t= 0xe450,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0xe450, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0xe454, 1, 0, 2, 1 },\n\t\t\t\t.bvalid_det_en\t= { 0xe3c0, 3, 3, 0, 1 },\n\t\t\t\t.bvalid_det_st\t= { 0xe3e0, 3, 3, 0, 1 },\n\t\t\t\t.bvalid_det_clr\t= { 0xe3d0, 3, 3, 0, 1 },\n\t\t\t\t.id_det_en\t= { 0xe3c0, 5, 4, 0, 3 },\n\t\t\t\t.id_det_st\t= { 0xe3e0, 5, 4, 0, 3 },\n\t\t\t\t.id_det_clr\t= { 0xe3d0, 5, 4, 0, 3 },\n\t\t\t\t.utmi_avalid\t= { 0xe2ac, 7, 7, 0, 1 },\n\t\t\t\t.utmi_bvalid\t= { 0xe2ac, 12, 12, 0, 1 },\n\t\t\t\t.utmi_id\t= { 0xe2ac, 8, 8, 0, 1 },\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0xe458, 1, 0, 0x2, 0x1 },\n\t\t\t\t.ls_det_en\t= { 0xe3c0, 6, 6, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0xe3e0, 6, 6, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0xe3d0, 6, 6, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0xe2ac, 22, 21, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0xe2ac, 23, 23, 0, 1 }\n\t\t\t}\n\t\t},\n\t\t.chg_det = {\n\t\t\t.opmode\t\t= { 0xe454, 3, 0, 5, 1 },\n\t\t\t.cp_det\t\t= { 0xe2ac, 2, 2, 0, 1 },\n\t\t\t.dcp_det\t= { 0xe2ac, 1, 1, 0, 1 },\n\t\t\t.dp_det\t\t= { 0xe2ac, 0, 0, 0, 1 },\n\t\t\t.idm_sink_en\t= { 0xe450, 8, 8, 0, 1 },\n\t\t\t.idp_sink_en\t= { 0xe450, 7, 7, 0, 1 },\n\t\t\t.idp_src_en\t= { 0xe450, 9, 9, 0, 1 },\n\t\t\t.rdm_pdwn_en\t= { 0xe450, 10, 10, 0, 1 },\n\t\t\t.vdm_src_en\t= { 0xe450, 12, 12, 0, 1 },\n\t\t\t.vdp_src_en\t= { 0xe450, 11, 11, 0, 1 },\n\t\t},\n\t},\n\t{\n\t\t.reg\t\t= 0xe460,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0xe460, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus        = { 0xe464, 1, 0, 2, 1 },\n\t\t\t\t.bvalid_det_en  = { 0xe3c0, 8, 8, 0, 1 },\n\t\t\t\t.bvalid_det_st  = { 0xe3e0, 8, 8, 0, 1 },\n\t\t\t\t.bvalid_det_clr = { 0xe3d0, 8, 8, 0, 1 },\n\t\t\t\t.id_det_en\t= { 0xe3c0, 10, 9, 0, 3 },\n\t\t\t\t.id_det_st\t= { 0xe3e0, 10, 9, 0, 3 },\n\t\t\t\t.id_det_clr\t= { 0xe3d0, 10, 9, 0, 3 },\n\t\t\t\t.utmi_avalid\t= { 0xe2ac, 10, 10, 0, 1 },\n\t\t\t\t.utmi_bvalid    = { 0xe2ac, 16, 16, 0, 1 },\n\t\t\t\t.utmi_id\t= { 0xe2ac, 11, 11, 0, 1 },\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0xe468, 1, 0, 0x2, 0x1 },\n\t\t\t\t.ls_det_en\t= { 0xe3c0, 11, 11, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0xe3e0, 11, 11, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0xe3d0, 11, 11, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0xe2ac, 26, 25, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0xe2ac, 27, 27, 0, 1 }\n\t\t\t}\n\t\t},\n\t},\n\t{   }\n};\n\nstatic const struct rockchip_usb2phy_cfg rk3568_phy_cfgs[] = {\n\t{\n\t\t.reg = 0xfe8a0000,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0x0008, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x0000, 8, 0, 0, 0x1d1 },\n\t\t\t\t.bvalid_det_en\t= { 0x0080, 3, 2, 0, 3 },\n\t\t\t\t.bvalid_det_st\t= { 0x0084, 3, 2, 0, 3 },\n\t\t\t\t.bvalid_det_clr = { 0x0088, 3, 2, 0, 3 },\n\t\t\t\t.id_det_en\t= { 0x0080, 5, 4, 0, 3 },\n\t\t\t\t.id_det_st\t= { 0x0084, 5, 4, 0, 3 },\n\t\t\t\t.id_det_clr\t= { 0x0088, 5, 4, 0, 3 },\n\t\t\t\t.utmi_avalid\t= { 0x00c0, 10, 10, 0, 1 },\n\t\t\t\t.utmi_bvalid\t= { 0x00c0, 9, 9, 0, 1 },\n\t\t\t\t.utmi_id\t= { 0x00c0, 6, 6, 0, 1 },\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t \n\t\t\t\t.phy_sus\t= { 0x0004, 8, 0, 0x1d2, 0x1d2 },\n\t\t\t\t.ls_det_en\t= { 0x0080, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0084, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x0088, 1, 1, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x00c0, 17, 16, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0x00c0, 19, 19, 0, 1 }\n\t\t\t}\n\t\t},\n\t\t.chg_det = {\n\t\t\t.opmode\t\t= { 0x0000, 3, 0, 5, 1 },\n\t\t\t.cp_det\t\t= { 0x00c0, 24, 24, 0, 1 },\n\t\t\t.dcp_det\t= { 0x00c0, 23, 23, 0, 1 },\n\t\t\t.dp_det\t\t= { 0x00c0, 25, 25, 0, 1 },\n\t\t\t.idm_sink_en\t= { 0x0008, 8, 8, 0, 1 },\n\t\t\t.idp_sink_en\t= { 0x0008, 7, 7, 0, 1 },\n\t\t\t.idp_src_en\t= { 0x0008, 9, 9, 0, 1 },\n\t\t\t.rdm_pdwn_en\t= { 0x0008, 10, 10, 0, 1 },\n\t\t\t.vdm_src_en\t= { 0x0008, 12, 12, 0, 1 },\n\t\t\t.vdp_src_en\t= { 0x0008, 11, 11, 0, 1 },\n\t\t},\n\t},\n\t{\n\t\t.reg = 0xfe8b0000,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0x0008, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x0000, 8, 0, 0x1d2, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x0080, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0084, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x0088, 0, 0, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x00c0, 5, 4, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0x00c0, 7, 7, 0, 1 }\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x0004, 8, 0, 0x1d2, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x0080, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0084, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x0088, 1, 1, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x00c0, 17, 16, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0x00c0, 19, 19, 0, 1 }\n\t\t\t}\n\t\t},\n\t},\n\t{   }\n};\n\nstatic const struct rockchip_usb2phy_cfg rk3588_phy_cfgs[] = {\n\t{\n\t\t.reg = 0x0000,\n\t\t.num_ports\t= 1,\n\t\t.phy_tuning\t= rk3588_usb2phy_tuning,\n\t\t.clkout_ctl\t= { 0x0000, 0, 0, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x000c, 11, 11, 0, 1 },\n\t\t\t\t.bvalid_det_en\t= { 0x0080, 1, 1, 0, 1 },\n\t\t\t\t.bvalid_det_st\t= { 0x0084, 1, 1, 0, 1 },\n\t\t\t\t.bvalid_det_clr = { 0x0088, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_en\t= { 0x0080, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0084, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x0088, 0, 0, 0, 1 },\n\t\t\t\t.disfall_en\t= { 0x0080, 6, 6, 0, 1 },\n\t\t\t\t.disfall_st\t= { 0x0084, 6, 6, 0, 1 },\n\t\t\t\t.disfall_clr\t= { 0x0088, 6, 6, 0, 1 },\n\t\t\t\t.disrise_en\t= { 0x0080, 5, 5, 0, 1 },\n\t\t\t\t.disrise_st\t= { 0x0084, 5, 5, 0, 1 },\n\t\t\t\t.disrise_clr\t= { 0x0088, 5, 5, 0, 1 },\n\t\t\t\t.utmi_avalid\t= { 0x00c0, 7, 7, 0, 1 },\n\t\t\t\t.utmi_bvalid\t= { 0x00c0, 6, 6, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x00c0, 10, 9, 0, 1 },\n\t\t\t}\n\t\t},\n\t\t.chg_det = {\n\t\t\t.cp_det\t\t= { 0x00c0, 0, 0, 0, 1 },\n\t\t\t.dcp_det\t= { 0x00c0, 0, 0, 0, 1 },\n\t\t\t.dp_det\t\t= { 0x00c0, 1, 1, 1, 0 },\n\t\t\t.idm_sink_en\t= { 0x0008, 5, 5, 1, 0 },\n\t\t\t.idp_sink_en\t= { 0x0008, 5, 5, 0, 1 },\n\t\t\t.idp_src_en\t= { 0x0008, 14, 14, 0, 1 },\n\t\t\t.rdm_pdwn_en\t= { 0x0008, 14, 14, 0, 1 },\n\t\t\t.vdm_src_en\t= { 0x0008, 7, 6, 0, 3 },\n\t\t\t.vdp_src_en\t= { 0x0008, 7, 6, 0, 3 },\n\t\t},\n\t},\n\t{\n\t\t.reg = 0x4000,\n\t\t.num_ports\t= 1,\n\t\t.phy_tuning\t= rk3588_usb2phy_tuning,\n\t\t.clkout_ctl\t= { 0x0000, 0, 0, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x000c, 11, 11, 0, 1 },\n\t\t\t\t.bvalid_det_en\t= { 0x0080, 1, 1, 0, 1 },\n\t\t\t\t.bvalid_det_st\t= { 0x0084, 1, 1, 0, 1 },\n\t\t\t\t.bvalid_det_clr = { 0x0088, 1, 1, 0, 1 },\n\t\t\t\t.ls_det_en\t= { 0x0080, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0084, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x0088, 0, 0, 0, 1 },\n\t\t\t\t.disfall_en\t= { 0x0080, 6, 6, 0, 1 },\n\t\t\t\t.disfall_st\t= { 0x0084, 6, 6, 0, 1 },\n\t\t\t\t.disfall_clr\t= { 0x0088, 6, 6, 0, 1 },\n\t\t\t\t.disrise_en\t= { 0x0080, 5, 5, 0, 1 },\n\t\t\t\t.disrise_st\t= { 0x0084, 5, 5, 0, 1 },\n\t\t\t\t.disrise_clr\t= { 0x0088, 5, 5, 0, 1 },\n\t\t\t\t.utmi_avalid\t= { 0x00c0, 7, 7, 0, 1 },\n\t\t\t\t.utmi_bvalid\t= { 0x00c0, 6, 6, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x00c0, 10, 9, 0, 1 },\n\t\t\t}\n\t\t},\n\t\t.chg_det = {\n\t\t\t.cp_det\t\t= { 0x00c0, 0, 0, 0, 1 },\n\t\t\t.dcp_det\t= { 0x00c0, 0, 0, 0, 1 },\n\t\t\t.dp_det\t\t= { 0x00c0, 1, 1, 1, 0 },\n\t\t\t.idm_sink_en\t= { 0x0008, 5, 5, 1, 0 },\n\t\t\t.idp_sink_en\t= { 0x0008, 5, 5, 0, 1 },\n\t\t\t.idp_src_en\t= { 0x0008, 14, 14, 0, 1 },\n\t\t\t.rdm_pdwn_en\t= { 0x0008, 14, 14, 0, 1 },\n\t\t\t.vdm_src_en\t= { 0x0008, 7, 6, 0, 3 },\n\t\t\t.vdp_src_en\t= { 0x0008, 7, 6, 0, 3 },\n\t\t},\n\t},\n\t{\n\t\t.reg = 0x8000,\n\t\t.num_ports\t= 1,\n\t\t.phy_tuning\t= rk3588_usb2phy_tuning,\n\t\t.clkout_ctl\t= { 0x0000, 0, 0, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x0008, 2, 2, 0, 1 },\n\t\t\t\t.ls_det_en\t= { 0x0080, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0084, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x0088, 0, 0, 0, 1 },\n\t\t\t\t.disfall_en\t= { 0x0080, 6, 6, 0, 1 },\n\t\t\t\t.disfall_st\t= { 0x0084, 6, 6, 0, 1 },\n\t\t\t\t.disfall_clr\t= { 0x0088, 6, 6, 0, 1 },\n\t\t\t\t.disrise_en\t= { 0x0080, 5, 5, 0, 1 },\n\t\t\t\t.disrise_st\t= { 0x0084, 5, 5, 0, 1 },\n\t\t\t\t.disrise_clr\t= { 0x0088, 5, 5, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x00c0, 10, 9, 0, 1 },\n\t\t\t}\n\t\t},\n\t},\n\t{\n\t\t.reg = 0xc000,\n\t\t.num_ports\t= 1,\n\t\t.phy_tuning\t= rk3588_usb2phy_tuning,\n\t\t.clkout_ctl\t= { 0x0000, 0, 0, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x0008, 2, 2, 0, 1 },\n\t\t\t\t.ls_det_en\t= { 0x0080, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0084, 0, 0, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x0088, 0, 0, 0, 1 },\n\t\t\t\t.disfall_en\t= { 0x0080, 6, 6, 0, 1 },\n\t\t\t\t.disfall_st\t= { 0x0084, 6, 6, 0, 1 },\n\t\t\t\t.disfall_clr\t= { 0x0088, 6, 6, 0, 1 },\n\t\t\t\t.disrise_en\t= { 0x0080, 5, 5, 0, 1 },\n\t\t\t\t.disrise_st\t= { 0x0084, 5, 5, 0, 1 },\n\t\t\t\t.disrise_clr\t= { 0x0088, 5, 5, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x00c0, 10, 9, 0, 1 },\n\t\t\t}\n\t\t},\n\t},\n\t{   }\n};\n\nstatic const struct rockchip_usb2phy_cfg rv1108_phy_cfgs[] = {\n\t{\n\t\t.reg = 0x100,\n\t\t.num_ports\t= 2,\n\t\t.clkout_ctl\t= { 0x108, 4, 4, 1, 0 },\n\t\t.port_cfgs\t= {\n\t\t\t[USB2PHY_PORT_OTG] = {\n\t\t\t\t.phy_sus\t= { 0x0100, 15, 0, 0, 0x1d1 },\n\t\t\t\t.bvalid_det_en\t= { 0x0680, 3, 3, 0, 1 },\n\t\t\t\t.bvalid_det_st\t= { 0x0690, 3, 3, 0, 1 },\n\t\t\t\t.bvalid_det_clr = { 0x06a0, 3, 3, 0, 1 },\n\t\t\t\t.ls_det_en\t= { 0x0680, 2, 2, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0690, 2, 2, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x06a0, 2, 2, 0, 1 },\n\t\t\t\t.utmi_bvalid\t= { 0x0804, 10, 10, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x0804, 13, 12, 0, 1 },\n\t\t\t},\n\t\t\t[USB2PHY_PORT_HOST] = {\n\t\t\t\t.phy_sus\t= { 0x0104, 15, 0, 0, 0x1d1 },\n\t\t\t\t.ls_det_en\t= { 0x0680, 4, 4, 0, 1 },\n\t\t\t\t.ls_det_st\t= { 0x0690, 4, 4, 0, 1 },\n\t\t\t\t.ls_det_clr\t= { 0x06a0, 4, 4, 0, 1 },\n\t\t\t\t.utmi_ls\t= { 0x0804, 9, 8, 0, 1 },\n\t\t\t\t.utmi_hstdet\t= { 0x0804, 7, 7, 0, 1 }\n\t\t\t}\n\t\t},\n\t\t.chg_det = {\n\t\t\t.opmode\t\t= { 0x0100, 3, 0, 5, 1 },\n\t\t\t.cp_det\t\t= { 0x0804, 1, 1, 0, 1 },\n\t\t\t.dcp_det\t= { 0x0804, 0, 0, 0, 1 },\n\t\t\t.dp_det\t\t= { 0x0804, 2, 2, 0, 1 },\n\t\t\t.idm_sink_en\t= { 0x0108, 8, 8, 0, 1 },\n\t\t\t.idp_sink_en\t= { 0x0108, 7, 7, 0, 1 },\n\t\t\t.idp_src_en\t= { 0x0108, 9, 9, 0, 1 },\n\t\t\t.rdm_pdwn_en\t= { 0x0108, 10, 10, 0, 1 },\n\t\t\t.vdm_src_en\t= { 0x0108, 12, 12, 0, 1 },\n\t\t\t.vdp_src_en\t= { 0x0108, 11, 11, 0, 1 },\n\t\t},\n\t},\n\t{   }\n};\n\nstatic const struct of_device_id rockchip_usb2phy_dt_match[] = {\n\t{ .compatible = \"rockchip,px30-usb2phy\", .data = &rk3328_phy_cfgs },\n\t{ .compatible = \"rockchip,rk3228-usb2phy\", .data = &rk3228_phy_cfgs },\n\t{ .compatible = \"rockchip,rk3308-usb2phy\", .data = &rk3308_phy_cfgs },\n\t{ .compatible = \"rockchip,rk3328-usb2phy\", .data = &rk3328_phy_cfgs },\n\t{ .compatible = \"rockchip,rk3366-usb2phy\", .data = &rk3366_phy_cfgs },\n\t{ .compatible = \"rockchip,rk3399-usb2phy\", .data = &rk3399_phy_cfgs },\n\t{ .compatible = \"rockchip,rk3568-usb2phy\", .data = &rk3568_phy_cfgs },\n\t{ .compatible = \"rockchip,rk3588-usb2phy\", .data = &rk3588_phy_cfgs },\n\t{ .compatible = \"rockchip,rv1108-usb2phy\", .data = &rv1108_phy_cfgs },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rockchip_usb2phy_dt_match);\n\nstatic struct platform_driver rockchip_usb2phy_driver = {\n\t.probe\t\t= rockchip_usb2phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rockchip-usb2phy\",\n\t\t.of_match_table = rockchip_usb2phy_dt_match,\n\t},\n};\nmodule_platform_driver(rockchip_usb2phy_driver);\n\nMODULE_AUTHOR(\"Frank Wang <frank.wang@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip USB2.0 PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}