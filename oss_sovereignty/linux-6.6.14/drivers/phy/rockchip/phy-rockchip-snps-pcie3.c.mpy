{
  "module_name": "phy-rockchip-snps-pcie3.c",
  "hash_id": "4b0b3e492453cf5c870359b710308e5805d296f015e1c8786bdd35caafe3bee1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-snps-pcie3.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/pcie.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n \n#define GRF_PCIE30PHY_CON1\t\t\t0x4\n#define GRF_PCIE30PHY_CON6\t\t\t0x18\n#define GRF_PCIE30PHY_CON9\t\t\t0x24\n#define GRF_PCIE30PHY_DA_OCM\t\t\t(BIT(15) | BIT(31))\n#define GRF_PCIE30PHY_STATUS0\t\t\t0x80\n#define GRF_PCIE30PHY_WR_EN\t\t\t(0xf << 16)\n#define SRAM_INIT_DONE(reg)\t\t\t(reg & BIT(14))\n\n#define RK3568_BIFURCATION_LANE_0_1\t\tBIT(0)\n\n \n#define PHP_GRF_PCIESEL_CON\t\t\t0x100\n#define RK3588_PCIE3PHY_GRF_CMN_CON0\t\t0x0\n#define RK3588_PCIE3PHY_GRF_PHY0_STATUS1\t0x904\n#define RK3588_PCIE3PHY_GRF_PHY1_STATUS1\t0xa04\n#define RK3588_SRAM_INIT_DONE(reg)\t\t(reg & BIT(0))\n\n#define RK3588_BIFURCATION_LANE_0_1\t\tBIT(0)\n#define RK3588_BIFURCATION_LANE_2_3\t\tBIT(1)\n#define RK3588_LANE_AGGREGATION\t\tBIT(2)\n\nstruct rockchip_p3phy_ops;\n\nstruct rockchip_p3phy_priv {\n\tconst struct rockchip_p3phy_ops *ops;\n\tvoid __iomem *mmio;\n\t \n\tint mode;\n\t \n\tint pcie30_phymode;\n\tstruct regmap *phy_grf;\n\tstruct regmap *pipe_grf;\n\tstruct reset_control *p30phy;\n\tstruct phy *phy;\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\tint num_lanes;\n\tu32 lanes[4];\n};\n\nstruct rockchip_p3phy_ops {\n\tint (*phy_init)(struct rockchip_p3phy_priv *priv);\n};\n\nstatic int rockchip_p3phy_set_mode(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tstruct rockchip_p3phy_priv *priv = phy_get_drvdata(phy);\n\n\t \n\tswitch (submode) {\n\tcase PHY_MODE_PCIE_RC:\n\t\tpriv->mode = PHY_MODE_PCIE_RC;\n\t\tbreak;\n\tcase PHY_MODE_PCIE_EP:\n\t\tpriv->mode = PHY_MODE_PCIE_EP;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&phy->dev, \"%s, invalid mode\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_p3phy_rk3568_init(struct rockchip_p3phy_priv *priv)\n{\n\tstruct phy *phy = priv->phy;\n\tbool bifurcation = false;\n\tint ret;\n\tu32 reg;\n\n\t \n\tregmap_write(priv->phy_grf, GRF_PCIE30PHY_CON9, GRF_PCIE30PHY_DA_OCM);\n\n\tfor (int i = 0; i < priv->num_lanes; i++) {\n\t\tdev_info(&phy->dev, \"lane number %d, val %d\\n\", i, priv->lanes[i]);\n\t\tif (priv->lanes[i] > 1)\n\t\t\tbifurcation = true;\n\t}\n\n\t \n\tif (bifurcation) {\n\t\tdev_info(&phy->dev, \"bifurcation enabled\\n\");\n\t\tregmap_write(priv->phy_grf, GRF_PCIE30PHY_CON6,\n\t\t\t     GRF_PCIE30PHY_WR_EN | RK3568_BIFURCATION_LANE_0_1);\n\t\tregmap_write(priv->phy_grf, GRF_PCIE30PHY_CON1,\n\t\t\t     GRF_PCIE30PHY_DA_OCM);\n\t} else {\n\t\tdev_dbg(&phy->dev, \"bifurcation disabled\\n\");\n\t\tregmap_write(priv->phy_grf, GRF_PCIE30PHY_CON6,\n\t\t\t     GRF_PCIE30PHY_WR_EN & ~RK3568_BIFURCATION_LANE_0_1);\n\t}\n\n\treset_control_deassert(priv->p30phy);\n\n\tret = regmap_read_poll_timeout(priv->phy_grf,\n\t\t\t\t       GRF_PCIE30PHY_STATUS0,\n\t\t\t\t       reg, SRAM_INIT_DONE(reg),\n\t\t\t\t       0, 500);\n\tif (ret)\n\t\tdev_err(&priv->phy->dev, \"%s: lock failed 0x%x, check input refclk and power supply\\n\",\n\t\t       __func__, reg);\n\treturn ret;\n}\n\nstatic const struct rockchip_p3phy_ops rk3568_ops = {\n\t.phy_init = rockchip_p3phy_rk3568_init,\n};\n\nstatic int rockchip_p3phy_rk3588_init(struct rockchip_p3phy_priv *priv)\n{\n\tu32 reg = 0;\n\tu8 mode = 0;\n\tint ret;\n\n\t \n\tregmap_write(priv->phy_grf, RK3588_PCIE3PHY_GRF_CMN_CON0, BIT(8) | BIT(24));\n\n\t \n\tfor (int i = 0; i < priv->num_lanes; i++) {\n\t\tif (!priv->lanes[i])\n\t\t\tmode |= (BIT(i) << 3);\n\n\t\tif (priv->lanes[i] > 1)\n\t\t\tmode |= (BIT(i) >> 1);\n\t}\n\n\tif (!mode)\n\t\treg = RK3588_LANE_AGGREGATION;\n\telse {\n\t\tif (mode & (BIT(0) | BIT(1)))\n\t\t\treg |= RK3588_BIFURCATION_LANE_0_1;\n\n\t\tif (mode & (BIT(2) | BIT(3)))\n\t\t\treg |= RK3588_BIFURCATION_LANE_2_3;\n\t}\n\n\tregmap_write(priv->phy_grf, RK3588_PCIE3PHY_GRF_CMN_CON0, (0x7<<16) | reg);\n\n\t \n\tif (!IS_ERR(priv->pipe_grf)) {\n\t\treg = (mode & (BIT(6) | BIT(7))) >> 6;\n\t\tif (reg)\n\t\t\tregmap_write(priv->pipe_grf, PHP_GRF_PCIESEL_CON,\n\t\t\t\t     (reg << 16) | reg);\n\t}\n\n\treset_control_deassert(priv->p30phy);\n\n\tret = regmap_read_poll_timeout(priv->phy_grf,\n\t\t\t\t       RK3588_PCIE3PHY_GRF_PHY0_STATUS1,\n\t\t\t\t       reg, RK3588_SRAM_INIT_DONE(reg),\n\t\t\t\t       0, 500);\n\tret |= regmap_read_poll_timeout(priv->phy_grf,\n\t\t\t\t\tRK3588_PCIE3PHY_GRF_PHY1_STATUS1,\n\t\t\t\t\treg, RK3588_SRAM_INIT_DONE(reg),\n\t\t\t\t\t0, 500);\n\tif (ret)\n\t\tdev_err(&priv->phy->dev, \"lock failed 0x%x, check input refclk and power supply\\n\",\n\t\t\treg);\n\treturn ret;\n}\n\nstatic const struct rockchip_p3phy_ops rk3588_ops = {\n\t.phy_init = rockchip_p3phy_rk3588_init,\n};\n\nstatic int rochchip_p3phy_init(struct phy *phy)\n{\n\tstruct rockchip_p3phy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(priv->num_clks, priv->clks);\n\tif (ret) {\n\t\tdev_err(&priv->phy->dev, \"failed to enable PCIe bulk clks %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treset_control_assert(priv->p30phy);\n\tudelay(1);\n\n\tif (priv->ops->phy_init) {\n\t\tret = priv->ops->phy_init(priv);\n\t\tif (ret)\n\t\t\tclk_bulk_disable_unprepare(priv->num_clks, priv->clks);\n\t}\n\n\treturn ret;\n}\n\nstatic int rochchip_p3phy_exit(struct phy *phy)\n{\n\tstruct rockchip_p3phy_priv *priv = phy_get_drvdata(phy);\n\n\tclk_bulk_disable_unprepare(priv->num_clks, priv->clks);\n\treset_control_assert(priv->p30phy);\n\treturn 0;\n}\n\nstatic const struct phy_ops rochchip_p3phy_ops = {\n\t.init = rochchip_p3phy_init,\n\t.exit = rochchip_p3phy_exit,\n\t.set_mode = rockchip_p3phy_set_mode,\n\t.owner = THIS_MODULE,\n};\n\nstatic int rockchip_p3phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_p3phy_priv *priv;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->mmio = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(priv->mmio)) {\n\t\tret = PTR_ERR(priv->mmio);\n\t\treturn ret;\n\t}\n\n\tpriv->ops = of_device_get_match_data(&pdev->dev);\n\tif (!priv->ops) {\n\t\tdev_err(dev, \"no of match data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->phy_grf = syscon_regmap_lookup_by_phandle(np, \"rockchip,phy-grf\");\n\tif (IS_ERR(priv->phy_grf)) {\n\t\tdev_err(dev, \"failed to find rockchip,phy_grf regmap\\n\");\n\t\treturn PTR_ERR(priv->phy_grf);\n\t}\n\n\tif (of_device_is_compatible(np, \"rockchip,rk3588-pcie3-phy\")) {\n\t\tpriv->pipe_grf =\n\t\t\tsyscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"rockchip,pipe-grf\");\n\t\tif (IS_ERR(priv->pipe_grf))\n\t\t\tdev_info(dev, \"failed to find rockchip,pipe_grf regmap\\n\");\n\t} else {\n\t\tpriv->pipe_grf = NULL;\n\t}\n\n\tpriv->num_lanes = of_property_read_variable_u32_array(dev->of_node, \"data-lanes\",\n\t\t\t\t\t\t\t     priv->lanes, 2,\n\t\t\t\t\t\t\t     ARRAY_SIZE(priv->lanes));\n\n\t \n\tif (priv->num_lanes == -EINVAL) {\n\t\tdev_dbg(dev, \"no data-lanes property found\\n\");\n\t\tpriv->num_lanes = 1;\n\t\tpriv->lanes[0] = 1;\n\t} else if (priv->num_lanes < 0) {\n\t\tdev_err(dev, \"failed to read data-lanes property %d\\n\", priv->num_lanes);\n\t\treturn priv->num_lanes;\n\t}\n\n\tpriv->phy = devm_phy_create(dev, NULL, &rochchip_p3phy_ops);\n\tif (IS_ERR(priv->phy)) {\n\t\tdev_err(dev, \"failed to create combphy\\n\");\n\t\treturn PTR_ERR(priv->phy);\n\t}\n\n\tpriv->p30phy = devm_reset_control_get_optional_exclusive(dev, \"phy\");\n\tif (IS_ERR(priv->p30phy)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->p30phy),\n\t\t\t\t     \"failed to get phy reset control\\n\");\n\t}\n\tif (!priv->p30phy)\n\t\tdev_info(dev, \"no phy reset control specified\\n\");\n\n\tpriv->num_clks = devm_clk_bulk_get_all(dev, &priv->clks);\n\tif (priv->num_clks < 1)\n\t\treturn -ENODEV;\n\n\tdev_set_drvdata(dev, priv);\n\tphy_set_drvdata(priv->phy, priv);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id rockchip_p3phy_of_match[] = {\n\t{ .compatible = \"rockchip,rk3568-pcie3-phy\", .data = &rk3568_ops },\n\t{ .compatible = \"rockchip,rk3588-pcie3-phy\", .data = &rk3588_ops },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rockchip_p3phy_of_match);\n\nstatic struct platform_driver rockchip_p3phy_driver = {\n\t.probe\t= rockchip_p3phy_probe,\n\t.driver = {\n\t\t.name = \"rockchip-snps-pcie3-phy\",\n\t\t.of_match_table = rockchip_p3phy_of_match,\n\t},\n};\nmodule_platform_driver(rockchip_p3phy_driver);\nMODULE_DESCRIPTION(\"Rockchip Synopsys PCIe 3.0 PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}