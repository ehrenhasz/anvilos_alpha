{
  "module_name": "phy-rockchip-pcie.c",
  "hash_id": "b855ea08f457125d72d004d3e7c040f81b54942cc74eb7f0eb8d3ead4d860eeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n \n#define HIWORD_UPDATE(val, mask, shift) \\\n\t\t((val) << (shift) | (mask) << ((shift) + 16))\n\n#define PHY_MAX_LANE_NUM      4\n#define PHY_CFG_DATA_SHIFT    7\n#define PHY_CFG_ADDR_SHIFT    1\n#define PHY_CFG_DATA_MASK     0xf\n#define PHY_CFG_ADDR_MASK     0x3f\n#define PHY_CFG_RD_MASK       0x3ff\n#define PHY_CFG_WR_ENABLE     1\n#define PHY_CFG_WR_DISABLE    1\n#define PHY_CFG_WR_SHIFT      0\n#define PHY_CFG_WR_MASK       1\n#define PHY_CFG_PLL_LOCK      0x10\n#define PHY_CFG_CLK_TEST      0x10\n#define PHY_CFG_CLK_SCC       0x12\n#define PHY_CFG_SEPE_RATE     BIT(3)\n#define PHY_CFG_PLL_100M      BIT(3)\n#define PHY_PLL_LOCKED        BIT(9)\n#define PHY_PLL_OUTPUT        BIT(10)\n#define PHY_LANE_A_STATUS     0x30\n#define PHY_LANE_B_STATUS     0x31\n#define PHY_LANE_C_STATUS     0x32\n#define PHY_LANE_D_STATUS     0x33\n#define PHY_LANE_RX_DET_SHIFT 11\n#define PHY_LANE_RX_DET_TH    0x1\n#define PHY_LANE_IDLE_OFF     0x1\n#define PHY_LANE_IDLE_MASK    0x1\n#define PHY_LANE_IDLE_A_SHIFT 3\n#define PHY_LANE_IDLE_B_SHIFT 4\n#define PHY_LANE_IDLE_C_SHIFT 5\n#define PHY_LANE_IDLE_D_SHIFT 6\n\nstruct rockchip_pcie_data {\n\tunsigned int pcie_conf;\n\tunsigned int pcie_status;\n\tunsigned int pcie_laneoff;\n};\n\nstruct rockchip_pcie_phy {\n\tstruct rockchip_pcie_data *phy_data;\n\tstruct regmap *reg_base;\n\tstruct phy_pcie_instance {\n\t\tstruct phy *phy;\n\t\tu32 index;\n\t} phys[PHY_MAX_LANE_NUM];\n\tstruct mutex pcie_mutex;\n\tstruct reset_control *phy_rst;\n\tstruct clk *clk_pciephy_ref;\n\tint pwr_cnt;\n\tint init_cnt;\n};\n\nstatic struct rockchip_pcie_phy *to_pcie_phy(struct phy_pcie_instance *inst)\n{\n\treturn container_of(inst, struct rockchip_pcie_phy,\n\t\t\t\t\tphys[inst->index]);\n}\n\nstatic struct phy *rockchip_pcie_phy_of_xlate(struct device *dev,\n\t\t\t\t\t      struct of_phandle_args *args)\n{\n\tstruct rockchip_pcie_phy *rk_phy = dev_get_drvdata(dev);\n\n\tif (args->args_count == 0)\n\t\treturn rk_phy->phys[0].phy;\n\n\tif (WARN_ON(args->args[0] >= PHY_MAX_LANE_NUM))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn rk_phy->phys[args->args[0]].phy;\n}\n\n\nstatic inline void phy_wr_cfg(struct rockchip_pcie_phy *rk_phy,\n\t\t\t      u32 addr, u32 data)\n{\n\tregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\n\t\t     HIWORD_UPDATE(data,\n\t\t\t\t   PHY_CFG_DATA_MASK,\n\t\t\t\t   PHY_CFG_DATA_SHIFT) |\n\t\t     HIWORD_UPDATE(addr,\n\t\t\t\t   PHY_CFG_ADDR_MASK,\n\t\t\t\t   PHY_CFG_ADDR_SHIFT));\n\tudelay(1);\n\tregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\n\t\t     HIWORD_UPDATE(PHY_CFG_WR_ENABLE,\n\t\t\t\t   PHY_CFG_WR_MASK,\n\t\t\t\t   PHY_CFG_WR_SHIFT));\n\tudelay(1);\n\tregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\n\t\t     HIWORD_UPDATE(PHY_CFG_WR_DISABLE,\n\t\t\t\t   PHY_CFG_WR_MASK,\n\t\t\t\t   PHY_CFG_WR_SHIFT));\n}\n\nstatic int rockchip_pcie_phy_power_off(struct phy *phy)\n{\n\tstruct phy_pcie_instance *inst = phy_get_drvdata(phy);\n\tstruct rockchip_pcie_phy *rk_phy = to_pcie_phy(inst);\n\tint err = 0;\n\n\tmutex_lock(&rk_phy->pcie_mutex);\n\n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->phy_data->pcie_laneoff,\n\t\t     HIWORD_UPDATE(PHY_LANE_IDLE_OFF,\n\t\t\t\t   PHY_LANE_IDLE_MASK,\n\t\t\t\t   PHY_LANE_IDLE_A_SHIFT + inst->index));\n\n\tif (--rk_phy->pwr_cnt)\n\t\tgoto err_out;\n\n\terr = reset_control_assert(rk_phy->phy_rst);\n\tif (err) {\n\t\tdev_err(&phy->dev, \"assert phy_rst err %d\\n\", err);\n\t\tgoto err_restore;\n\t}\n\nerr_out:\n\tmutex_unlock(&rk_phy->pcie_mutex);\n\treturn 0;\n\nerr_restore:\n\trk_phy->pwr_cnt++;\n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->phy_data->pcie_laneoff,\n\t\t     HIWORD_UPDATE(!PHY_LANE_IDLE_OFF,\n\t\t\t\t   PHY_LANE_IDLE_MASK,\n\t\t\t\t   PHY_LANE_IDLE_A_SHIFT + inst->index));\n\tmutex_unlock(&rk_phy->pcie_mutex);\n\treturn err;\n}\n\nstatic int rockchip_pcie_phy_power_on(struct phy *phy)\n{\n\tstruct phy_pcie_instance *inst = phy_get_drvdata(phy);\n\tstruct rockchip_pcie_phy *rk_phy = to_pcie_phy(inst);\n\tint err = 0;\n\tu32 status;\n\tunsigned long timeout;\n\n\tmutex_lock(&rk_phy->pcie_mutex);\n\n\tif (rk_phy->pwr_cnt++)\n\t\tgoto err_out;\n\n\terr = reset_control_deassert(rk_phy->phy_rst);\n\tif (err) {\n\t\tdev_err(&phy->dev, \"deassert phy_rst err %d\\n\", err);\n\t\tgoto err_pwr_cnt;\n\t}\n\n\tregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\n\t\t     HIWORD_UPDATE(PHY_CFG_PLL_LOCK,\n\t\t\t\t   PHY_CFG_ADDR_MASK,\n\t\t\t\t   PHY_CFG_ADDR_SHIFT));\n\n\tregmap_write(rk_phy->reg_base,\n\t\t     rk_phy->phy_data->pcie_laneoff,\n\t\t     HIWORD_UPDATE(!PHY_LANE_IDLE_OFF,\n\t\t\t\t   PHY_LANE_IDLE_MASK,\n\t\t\t\t   PHY_LANE_IDLE_A_SHIFT + inst->index));\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\n\terr = -EINVAL;\n\twhile (time_before(jiffies, timeout)) {\n\t\tregmap_read(rk_phy->reg_base,\n\t\t\t    rk_phy->phy_data->pcie_status,\n\t\t\t    &status);\n\t\tif (status & PHY_PLL_LOCKED) {\n\t\t\tdev_dbg(&phy->dev, \"pll locked!\\n\");\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tif (err) {\n\t\tdev_err(&phy->dev, \"pll lock timeout!\\n\");\n\t\tgoto err_pll_lock;\n\t}\n\n\tphy_wr_cfg(rk_phy, PHY_CFG_CLK_TEST, PHY_CFG_SEPE_RATE);\n\tphy_wr_cfg(rk_phy, PHY_CFG_CLK_SCC, PHY_CFG_PLL_100M);\n\n\terr = -ETIMEDOUT;\n\twhile (time_before(jiffies, timeout)) {\n\t\tregmap_read(rk_phy->reg_base,\n\t\t\t    rk_phy->phy_data->pcie_status,\n\t\t\t    &status);\n\t\tif (!(status & PHY_PLL_OUTPUT)) {\n\t\t\tdev_dbg(&phy->dev, \"pll output enable done!\\n\");\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tif (err) {\n\t\tdev_err(&phy->dev, \"pll output enable timeout!\\n\");\n\t\tgoto err_pll_lock;\n\t}\n\n\tregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\n\t\t     HIWORD_UPDATE(PHY_CFG_PLL_LOCK,\n\t\t\t\t   PHY_CFG_ADDR_MASK,\n\t\t\t\t   PHY_CFG_ADDR_SHIFT));\n\terr = -EINVAL;\n\twhile (time_before(jiffies, timeout)) {\n\t\tregmap_read(rk_phy->reg_base,\n\t\t\t    rk_phy->phy_data->pcie_status,\n\t\t\t    &status);\n\t\tif (status & PHY_PLL_LOCKED) {\n\t\t\tdev_dbg(&phy->dev, \"pll relocked!\\n\");\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tif (err) {\n\t\tdev_err(&phy->dev, \"pll relock timeout!\\n\");\n\t\tgoto err_pll_lock;\n\t}\n\nerr_out:\n\tmutex_unlock(&rk_phy->pcie_mutex);\n\treturn 0;\n\nerr_pll_lock:\n\treset_control_assert(rk_phy->phy_rst);\nerr_pwr_cnt:\n\trk_phy->pwr_cnt--;\n\tmutex_unlock(&rk_phy->pcie_mutex);\n\treturn err;\n}\n\nstatic int rockchip_pcie_phy_init(struct phy *phy)\n{\n\tstruct phy_pcie_instance *inst = phy_get_drvdata(phy);\n\tstruct rockchip_pcie_phy *rk_phy = to_pcie_phy(inst);\n\tint err = 0;\n\n\tmutex_lock(&rk_phy->pcie_mutex);\n\n\tif (rk_phy->init_cnt++)\n\t\tgoto err_out;\n\n\terr = clk_prepare_enable(rk_phy->clk_pciephy_ref);\n\tif (err) {\n\t\tdev_err(&phy->dev, \"Fail to enable pcie ref clock.\\n\");\n\t\tgoto err_refclk;\n\t}\n\n\terr = reset_control_assert(rk_phy->phy_rst);\n\tif (err) {\n\t\tdev_err(&phy->dev, \"assert phy_rst err %d\\n\", err);\n\t\tgoto err_reset;\n\t}\n\nerr_out:\n\tmutex_unlock(&rk_phy->pcie_mutex);\n\treturn 0;\n\nerr_reset:\n\n\tclk_disable_unprepare(rk_phy->clk_pciephy_ref);\nerr_refclk:\n\trk_phy->init_cnt--;\n\tmutex_unlock(&rk_phy->pcie_mutex);\n\treturn err;\n}\n\nstatic int rockchip_pcie_phy_exit(struct phy *phy)\n{\n\tstruct phy_pcie_instance *inst = phy_get_drvdata(phy);\n\tstruct rockchip_pcie_phy *rk_phy = to_pcie_phy(inst);\n\n\tmutex_lock(&rk_phy->pcie_mutex);\n\n\tif (--rk_phy->init_cnt)\n\t\tgoto err_init_cnt;\n\n\tclk_disable_unprepare(rk_phy->clk_pciephy_ref);\n\nerr_init_cnt:\n\tmutex_unlock(&rk_phy->pcie_mutex);\n\treturn 0;\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= rockchip_pcie_phy_init,\n\t.exit\t\t= rockchip_pcie_phy_exit,\n\t.power_on\t= rockchip_pcie_phy_power_on,\n\t.power_off\t= rockchip_pcie_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct rockchip_pcie_data rk3399_pcie_data = {\n\t.pcie_conf = 0xe220,\n\t.pcie_status = 0xe2a4,\n\t.pcie_laneoff = 0xe214,\n};\n\nstatic const struct of_device_id rockchip_pcie_phy_dt_ids[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3399-pcie-phy\",\n\t\t.data = &rk3399_pcie_data,\n\t},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, rockchip_pcie_phy_dt_ids);\n\nstatic int rockchip_pcie_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_pcie_phy *rk_phy;\n\tstruct phy_provider *phy_provider;\n\tstruct regmap *grf;\n\tconst struct of_device_id *of_id;\n\tint i;\n\tu32 phy_num;\n\n\tgrf = syscon_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(grf)) {\n\t\tdev_err(dev, \"Cannot find GRF syscon\\n\");\n\t\treturn PTR_ERR(grf);\n\t}\n\n\trk_phy = devm_kzalloc(dev, sizeof(*rk_phy), GFP_KERNEL);\n\tif (!rk_phy)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_device(rockchip_pcie_phy_dt_ids, &pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\trk_phy->phy_data = (struct rockchip_pcie_data *)of_id->data;\n\trk_phy->reg_base = grf;\n\n\tmutex_init(&rk_phy->pcie_mutex);\n\n\trk_phy->phy_rst = devm_reset_control_get(dev, \"phy\");\n\tif (IS_ERR(rk_phy->phy_rst)) {\n\t\tif (PTR_ERR(rk_phy->phy_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev,\n\t\t\t\t\"missing phy property for reset controller\\n\");\n\t\treturn PTR_ERR(rk_phy->phy_rst);\n\t}\n\n\trk_phy->clk_pciephy_ref = devm_clk_get(dev, \"refclk\");\n\tif (IS_ERR(rk_phy->clk_pciephy_ref)) {\n\t\tdev_err(dev, \"refclk not found.\\n\");\n\t\treturn PTR_ERR(rk_phy->clk_pciephy_ref);\n\t}\n\n\t \n\tif (of_property_read_u32(dev->of_node, \"#phy-cells\", &phy_num))\n\t\treturn -ENOENT;\n\n\tphy_num = (phy_num == 0) ? 1 : PHY_MAX_LANE_NUM;\n\tdev_dbg(dev, \"phy number is %d\\n\", phy_num);\n\n\tfor (i = 0; i < phy_num; i++) {\n\t\trk_phy->phys[i].phy = devm_phy_create(dev, dev->of_node, &ops);\n\t\tif (IS_ERR(rk_phy->phys[i].phy)) {\n\t\t\tdev_err(dev, \"failed to create PHY%d\\n\", i);\n\t\t\treturn PTR_ERR(rk_phy->phys[i].phy);\n\t\t}\n\t\trk_phy->phys[i].index = i;\n\t\tphy_set_drvdata(rk_phy->phys[i].phy, &rk_phy->phys[i]);\n\t}\n\n\tplatform_set_drvdata(pdev, rk_phy);\n\tphy_provider = devm_of_phy_provider_register(dev,\n\t\t\t\t\trockchip_pcie_phy_of_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver rockchip_pcie_driver = {\n\t.probe\t\t= rockchip_pcie_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rockchip-pcie-phy\",\n\t\t.of_match_table = rockchip_pcie_phy_dt_ids,\n\t},\n};\n\nmodule_platform_driver(rockchip_pcie_driver);\n\nMODULE_AUTHOR(\"Shawn Lin <shawn.lin@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip PCIe PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}