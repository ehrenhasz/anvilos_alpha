{
  "module_name": "phy-rockchip-dphy-rx0.c",
  "hash_id": "7142d77c31ac8bdbb48edc4f737b120f3ad5f443557e68737a279baf7a8f47ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-dphy-rx0.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-mipi-dphy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define RK3399_GRF_SOC_CON9\t\t0x6224\n#define RK3399_GRF_SOC_CON21\t\t0x6254\n#define RK3399_GRF_SOC_CON22\t\t0x6258\n#define RK3399_GRF_SOC_CON23\t\t0x625c\n#define RK3399_GRF_SOC_CON24\t\t0x6260\n#define RK3399_GRF_SOC_CON25\t\t0x6264\n#define RK3399_GRF_SOC_STATUS1\t\t0xe2a4\n\n#define CLOCK_LANE_HS_RX_CONTROL\t0x34\n#define LANE0_HS_RX_CONTROL\t\t0x44\n#define LANE1_HS_RX_CONTROL\t\t0x54\n#define LANE2_HS_RX_CONTROL\t\t0x84\n#define LANE3_HS_RX_CONTROL\t\t0x94\n#define LANES_THS_SETTLE_CONTROL\t0x75\n#define THS_SETTLE_COUNTER_THRESHOLD\t0x04\n\nstruct hsfreq_range {\n\tu16 range_h;\n\tu8 cfg_bit;\n};\n\nstatic const struct hsfreq_range rk3399_mipidphy_hsfreq_ranges[] = {\n\t{   89, 0x00 }, {   99, 0x10 }, {  109, 0x20 }, {  129, 0x01 },\n\t{  139, 0x11 }, {  149, 0x21 }, {  169, 0x02 }, {  179, 0x12 },\n\t{  199, 0x22 }, {  219, 0x03 }, {  239, 0x13 }, {  249, 0x23 },\n\t{  269, 0x04 }, {  299, 0x14 }, {  329, 0x05 }, {  359, 0x15 },\n\t{  399, 0x25 }, {  449, 0x06 }, {  499, 0x16 }, {  549, 0x07 },\n\t{  599, 0x17 }, {  649, 0x08 }, {  699, 0x18 }, {  749, 0x09 },\n\t{  799, 0x19 }, {  849, 0x29 }, {  899, 0x39 }, {  949, 0x0a },\n\t{  999, 0x1a }, { 1049, 0x2a }, { 1099, 0x3a }, { 1149, 0x0b },\n\t{ 1199, 0x1b }, { 1249, 0x2b }, { 1299, 0x3b }, { 1349, 0x0c },\n\t{ 1399, 0x1c }, { 1449, 0x2c }, { 1500, 0x3c }\n};\n\nstatic const char * const rk3399_mipidphy_clks[] = {\n\t\"dphy-ref\",\n\t\"dphy-cfg\",\n\t\"grf\",\n};\n\nenum dphy_reg_id {\n\tGRF_DPHY_RX0_TURNDISABLE = 0,\n\tGRF_DPHY_RX0_FORCERXMODE,\n\tGRF_DPHY_RX0_FORCETXSTOPMODE,\n\tGRF_DPHY_RX0_ENABLE,\n\tGRF_DPHY_RX0_TESTCLR,\n\tGRF_DPHY_RX0_TESTCLK,\n\tGRF_DPHY_RX0_TESTEN,\n\tGRF_DPHY_RX0_TESTDIN,\n\tGRF_DPHY_RX0_TURNREQUEST,\n\tGRF_DPHY_RX0_TESTDOUT,\n\tGRF_DPHY_TX0_TURNDISABLE,\n\tGRF_DPHY_TX0_FORCERXMODE,\n\tGRF_DPHY_TX0_FORCETXSTOPMODE,\n\tGRF_DPHY_TX0_TURNREQUEST,\n\tGRF_DPHY_TX1RX1_TURNDISABLE,\n\tGRF_DPHY_TX1RX1_FORCERXMODE,\n\tGRF_DPHY_TX1RX1_FORCETXSTOPMODE,\n\tGRF_DPHY_TX1RX1_ENABLE,\n\tGRF_DPHY_TX1RX1_MASTERSLAVEZ,\n\tGRF_DPHY_TX1RX1_BASEDIR,\n\tGRF_DPHY_TX1RX1_ENABLECLK,\n\tGRF_DPHY_TX1RX1_TURNREQUEST,\n\tGRF_DPHY_RX1_SRC_SEL,\n\t \n\tGRF_CON_DISABLE_ISP,\n\tGRF_CON_ISP_DPHY_SEL,\n\tGRF_DSI_CSI_TESTBUS_SEL,\n\tGRF_DVP_V18SEL,\n\t \n\tGRF_DPHY_RX0_CLK_INV_SEL,\n\tGRF_DPHY_RX1_CLK_INV_SEL,\n};\n\nstruct dphy_reg {\n\tu16 offset;\n\tu8 mask;\n\tu8 shift;\n};\n\n#define PHY_REG(_offset, _width, _shift) \\\n\t{ .offset = _offset, .mask = BIT(_width) - 1, .shift = _shift, }\n\nstatic const struct dphy_reg rk3399_grf_dphy_regs[] = {\n\t[GRF_DPHY_RX0_TURNREQUEST] = PHY_REG(RK3399_GRF_SOC_CON9, 4, 0),\n\t[GRF_DPHY_RX0_CLK_INV_SEL] = PHY_REG(RK3399_GRF_SOC_CON9, 1, 10),\n\t[GRF_DPHY_RX1_CLK_INV_SEL] = PHY_REG(RK3399_GRF_SOC_CON9, 1, 11),\n\t[GRF_DPHY_RX0_ENABLE] = PHY_REG(RK3399_GRF_SOC_CON21, 4, 0),\n\t[GRF_DPHY_RX0_FORCERXMODE] = PHY_REG(RK3399_GRF_SOC_CON21, 4, 4),\n\t[GRF_DPHY_RX0_FORCETXSTOPMODE] = PHY_REG(RK3399_GRF_SOC_CON21, 4, 8),\n\t[GRF_DPHY_RX0_TURNDISABLE] = PHY_REG(RK3399_GRF_SOC_CON21, 4, 12),\n\t[GRF_DPHY_TX0_FORCERXMODE] = PHY_REG(RK3399_GRF_SOC_CON22, 4, 0),\n\t[GRF_DPHY_TX0_FORCETXSTOPMODE] = PHY_REG(RK3399_GRF_SOC_CON22, 4, 4),\n\t[GRF_DPHY_TX0_TURNDISABLE] = PHY_REG(RK3399_GRF_SOC_CON22, 4, 8),\n\t[GRF_DPHY_TX0_TURNREQUEST] = PHY_REG(RK3399_GRF_SOC_CON22, 4, 12),\n\t[GRF_DPHY_TX1RX1_ENABLE] = PHY_REG(RK3399_GRF_SOC_CON23, 4, 0),\n\t[GRF_DPHY_TX1RX1_FORCERXMODE] = PHY_REG(RK3399_GRF_SOC_CON23, 4, 4),\n\t[GRF_DPHY_TX1RX1_FORCETXSTOPMODE] = PHY_REG(RK3399_GRF_SOC_CON23, 4, 8),\n\t[GRF_DPHY_TX1RX1_TURNDISABLE] = PHY_REG(RK3399_GRF_SOC_CON23, 4, 12),\n\t[GRF_DPHY_TX1RX1_TURNREQUEST] = PHY_REG(RK3399_GRF_SOC_CON24, 4, 0),\n\t[GRF_DPHY_RX1_SRC_SEL] = PHY_REG(RK3399_GRF_SOC_CON24, 1, 4),\n\t[GRF_DPHY_TX1RX1_BASEDIR] = PHY_REG(RK3399_GRF_SOC_CON24, 1, 5),\n\t[GRF_DPHY_TX1RX1_ENABLECLK] = PHY_REG(RK3399_GRF_SOC_CON24, 1, 6),\n\t[GRF_DPHY_TX1RX1_MASTERSLAVEZ] = PHY_REG(RK3399_GRF_SOC_CON24, 1, 7),\n\t[GRF_DPHY_RX0_TESTDIN] = PHY_REG(RK3399_GRF_SOC_CON25, 8, 0),\n\t[GRF_DPHY_RX0_TESTEN] = PHY_REG(RK3399_GRF_SOC_CON25, 1, 8),\n\t[GRF_DPHY_RX0_TESTCLK] = PHY_REG(RK3399_GRF_SOC_CON25, 1, 9),\n\t[GRF_DPHY_RX0_TESTCLR] = PHY_REG(RK3399_GRF_SOC_CON25, 1, 10),\n\t[GRF_DPHY_RX0_TESTDOUT] = PHY_REG(RK3399_GRF_SOC_STATUS1, 8, 0),\n};\n\nstruct rk_dphy_drv_data {\n\tconst char * const *clks;\n\tunsigned int num_clks;\n\tconst struct hsfreq_range *hsfreq_ranges;\n\tunsigned int num_hsfreq_ranges;\n\tconst struct dphy_reg *regs;\n};\n\nstruct rk_dphy {\n\tstruct device *dev;\n\tstruct regmap *grf;\n\tstruct clk_bulk_data *clks;\n\n\tconst struct rk_dphy_drv_data *drv_data;\n\tstruct phy_configure_opts_mipi_dphy config;\n\n\tu8 hsfreq;\n};\n\nstatic inline void rk_dphy_write_grf(struct rk_dphy *priv,\n\t\t\t\t     unsigned int index, u8 value)\n{\n\tconst struct dphy_reg *reg = &priv->drv_data->regs[index];\n\t \n\tunsigned int val = (value << reg->shift) |\n\t\t\t   (reg->mask << (reg->shift + 16));\n\n\tif (WARN_ON(!reg->offset))\n\t\treturn;\n\tregmap_write(priv->grf, reg->offset, val);\n}\n\nstatic void rk_dphy_write(struct rk_dphy *priv, u8 test_code, u8 test_data)\n{\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTDIN, test_code);\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTEN, 1);\n\t \n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTCLK, 0);\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTEN, 0);\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTDIN, test_data);\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTCLK, 1);\n}\n\nstatic void rk_dphy_enable(struct rk_dphy *priv)\n{\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_FORCERXMODE, 0);\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_FORCETXSTOPMODE, 0);\n\n\t \n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TURNREQUEST, 0);\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TURNDISABLE, 0xf);\n\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_ENABLE,\n\t\t\t  GENMASK(priv->config.lanes - 1, 0));\n\n\t \n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTCLK, 1);\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTCLR, 1);\n\tusleep_range(100, 150);\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_TESTCLR, 0);\n\tusleep_range(100, 150);\n\n\t \n\t \n\trk_dphy_write(priv, CLOCK_LANE_HS_RX_CONTROL, 0);\n\t \n\trk_dphy_write(priv, LANE0_HS_RX_CONTROL, priv->hsfreq << 1);\n\t \n\trk_dphy_write(priv, LANE1_HS_RX_CONTROL, priv->hsfreq << 1);\n\t \n\trk_dphy_write(priv, LANE2_HS_RX_CONTROL, priv->hsfreq << 1);\n\t \n\trk_dphy_write(priv, LANE3_HS_RX_CONTROL, priv->hsfreq << 1);\n\t \n\trk_dphy_write(priv, LANES_THS_SETTLE_CONTROL,\n\t\t      THS_SETTLE_COUNTER_THRESHOLD);\n\n\t \n\trk_dphy_write(priv, 0x0, 0);\n}\n\nstatic int rk_dphy_configure(struct phy *phy, union phy_configure_opts *opts)\n{\n\tstruct rk_dphy *priv = phy_get_drvdata(phy);\n\tconst struct rk_dphy_drv_data *drv_data = priv->drv_data;\n\tstruct phy_configure_opts_mipi_dphy *config = &opts->mipi_dphy;\n\tunsigned int hsfreq = 0;\n\tunsigned int i;\n\tu64 data_rate_mbps;\n\tint ret;\n\n\t \n\tret = phy_mipi_dphy_config_validate(config);\n\tif (ret)\n\t\treturn ret;\n\n\tdata_rate_mbps = div_u64(config->hs_clk_rate, 1000 * 1000);\n\n\tdev_dbg(priv->dev, \"lanes %d - data_rate_mbps %llu\\n\",\n\t\tconfig->lanes, data_rate_mbps);\n\tfor (i = 0; i < drv_data->num_hsfreq_ranges; i++) {\n\t\tif (drv_data->hsfreq_ranges[i].range_h >= data_rate_mbps) {\n\t\t\thsfreq = drv_data->hsfreq_ranges[i].cfg_bit;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!hsfreq)\n\t\treturn -EINVAL;\n\n\tpriv->hsfreq = hsfreq;\n\tpriv->config = *config;\n\treturn 0;\n}\n\nstatic int rk_dphy_power_on(struct phy *phy)\n{\n\tstruct rk_dphy *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_bulk_enable(priv->drv_data->num_clks, priv->clks);\n\tif (ret)\n\t\treturn ret;\n\n\trk_dphy_enable(priv);\n\n\treturn 0;\n}\n\nstatic int rk_dphy_power_off(struct phy *phy)\n{\n\tstruct rk_dphy *priv = phy_get_drvdata(phy);\n\n\trk_dphy_write_grf(priv, GRF_DPHY_RX0_ENABLE, 0);\n\tclk_bulk_disable(priv->drv_data->num_clks, priv->clks);\n\treturn 0;\n}\n\nstatic int rk_dphy_init(struct phy *phy)\n{\n\tstruct rk_dphy *priv = phy_get_drvdata(phy);\n\n\treturn clk_bulk_prepare(priv->drv_data->num_clks, priv->clks);\n}\n\nstatic int rk_dphy_exit(struct phy *phy)\n{\n\tstruct rk_dphy *priv = phy_get_drvdata(phy);\n\n\tclk_bulk_unprepare(priv->drv_data->num_clks, priv->clks);\n\treturn 0;\n}\n\nstatic const struct phy_ops rk_dphy_ops = {\n\t.power_on\t= rk_dphy_power_on,\n\t.power_off\t= rk_dphy_power_off,\n\t.init\t\t= rk_dphy_init,\n\t.exit\t\t= rk_dphy_exit,\n\t.configure\t= rk_dphy_configure,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct rk_dphy_drv_data rk3399_mipidphy_drv_data = {\n\t.clks = rk3399_mipidphy_clks,\n\t.num_clks = ARRAY_SIZE(rk3399_mipidphy_clks),\n\t.hsfreq_ranges = rk3399_mipidphy_hsfreq_ranges,\n\t.num_hsfreq_ranges = ARRAY_SIZE(rk3399_mipidphy_hsfreq_ranges),\n\t.regs = rk3399_grf_dphy_regs,\n};\n\nstatic const struct of_device_id rk_dphy_dt_ids[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3399-mipi-dphy-rx0\",\n\t\t.data = &rk3399_mipidphy_drv_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rk_dphy_dt_ids);\n\nstatic int rk_dphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct rk_dphy_drv_data *drv_data;\n\tstruct phy_provider *phy_provider;\n\tstruct rk_dphy *priv;\n\tstruct phy *phy;\n\tunsigned int i;\n\tint ret;\n\n\tif (!dev->parent || !dev->parent->of_node)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dev = dev;\n\n\tpriv->grf = syscon_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(priv->grf)) {\n\t\tdev_err(dev, \"Can't find GRF syscon\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrv_data = of_device_get_match_data(dev);\n\tpriv->drv_data = drv_data;\n\tpriv->clks = devm_kcalloc(&pdev->dev, drv_data->num_clks,\n\t\t\t\t  sizeof(*priv->clks), GFP_KERNEL);\n\tif (!priv->clks)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < drv_data->num_clks; i++)\n\t\tpriv->clks[i].id = drv_data->clks[i];\n\tret = devm_clk_bulk_get(&pdev->dev, drv_data->num_clks, priv->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tphy = devm_phy_create(dev, np, &rk_dphy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"failed to create phy\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\tphy_set_drvdata(phy, priv);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver rk_dphy_driver = {\n\t.probe = rk_dphy_probe,\n\t.driver = {\n\t\t.name\t= \"rockchip-mipi-dphy-rx0\",\n\t\t.of_match_table = rk_dphy_dt_ids,\n\t},\n};\nmodule_platform_driver(rk_dphy_driver);\n\nMODULE_AUTHOR(\"Ezequiel Garcia <ezequiel@collabora.com>\");\nMODULE_DESCRIPTION(\"Rockchip MIPI Synopsys DPHY RX0 driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}