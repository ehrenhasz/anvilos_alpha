{
  "module_name": "phy-rockchip-inno-dsidphy.c",
  "hash_id": "b5914a61810d7254bbedb1fe8be0ec962406c9a7024736ff80aaef460874830b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-inno-dsidphy.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/time64.h>\n\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-mipi-dphy.h>\n\n#define UPDATE(x, h, l)\t(((x) << (l)) & GENMASK((h), (l)))\n\n \n#define FIRST_ADDRESS(x)\t\t(((x) & 0x7) << 5)\n#define SECOND_ADDRESS(x)\t\t(((x) & 0x1f) << 0)\n#define PHY_REG(first, second)\t\t(FIRST_ADDRESS(first) | \\\n\t\t\t\t\t SECOND_ADDRESS(second))\n\n \n#define BANDGAP_POWER_MASK\t\t\tBIT(7)\n#define BANDGAP_POWER_DOWN\t\t\tBIT(7)\n#define BANDGAP_POWER_ON\t\t\t0\n#define LANE_EN_MASK\t\t\t\tGENMASK(6, 2)\n#define LANE_EN_CK\t\t\t\tBIT(6)\n#define LANE_EN_3\t\t\t\tBIT(5)\n#define LANE_EN_2\t\t\t\tBIT(4)\n#define LANE_EN_1\t\t\t\tBIT(3)\n#define LANE_EN_0\t\t\t\tBIT(2)\n#define POWER_WORK_MASK\t\t\t\tGENMASK(1, 0)\n#define POWER_WORK_ENABLE\t\t\tUPDATE(1, 1, 0)\n#define POWER_WORK_DISABLE\t\t\tUPDATE(2, 1, 0)\n \n#define REG_SYNCRST_MASK\t\t\tBIT(2)\n#define REG_SYNCRST_RESET\t\t\tBIT(2)\n#define REG_SYNCRST_NORMAL\t\t\t0\n#define REG_LDOPD_MASK\t\t\t\tBIT(1)\n#define REG_LDOPD_POWER_DOWN\t\t\tBIT(1)\n#define REG_LDOPD_POWER_ON\t\t\t0\n#define REG_PLLPD_MASK\t\t\t\tBIT(0)\n#define REG_PLLPD_POWER_DOWN\t\t\tBIT(0)\n#define REG_PLLPD_POWER_ON\t\t\t0\n \n#define REG_FBDIV_HI_MASK\t\t\tBIT(5)\n#define REG_FBDIV_HI(x)\t\t\t\tUPDATE((x >> 8), 5, 5)\n#define REG_PREDIV_MASK\t\t\t\tGENMASK(4, 0)\n#define REG_PREDIV(x)\t\t\t\tUPDATE(x, 4, 0)\n \n#define REG_FBDIV_LO_MASK\t\t\tGENMASK(7, 0)\n#define REG_FBDIV_LO(x)\t\t\t\tUPDATE(x, 7, 0)\n \n#define SAMPLE_CLOCK_PHASE_MASK\t\t\tGENMASK(6, 4)\n#define SAMPLE_CLOCK_PHASE(x)\t\t\tUPDATE(x, 6, 4)\n#define CLOCK_LANE_SKEW_PHASE_MASK\t\tGENMASK(2, 0)\n#define CLOCK_LANE_SKEW_PHASE(x)\t\tUPDATE(x, 2, 0)\n \n#define DATA_LANE_3_SKEW_PHASE_MASK\t\tGENMASK(6, 4)\n#define DATA_LANE_3_SKEW_PHASE(x)\t\tUPDATE(x, 6, 4)\n#define DATA_LANE_2_SKEW_PHASE_MASK\t\tGENMASK(2, 0)\n#define DATA_LANE_2_SKEW_PHASE(x)\t\tUPDATE(x, 2, 0)\n \n#define DATA_LANE_1_SKEW_PHASE_MASK\t\tGENMASK(6, 4)\n#define DATA_LANE_1_SKEW_PHASE(x)\t\tUPDATE(x, 6, 4)\n#define DATA_LANE_0_SKEW_PHASE_MASK\t\tGENMASK(2, 0)\n#define DATA_LANE_0_SKEW_PHASE(x)\t\tUPDATE(x, 2, 0)\n \n#define PLL_POST_DIV_ENABLE_MASK\t\tBIT(5)\n#define PLL_POST_DIV_ENABLE\t\t\tBIT(5)\n#define SAMPLE_CLOCK_DIRECTION_MASK\t\tBIT(4)\n#define SAMPLE_CLOCK_DIRECTION_REVERSE\t\tBIT(4)\n#define SAMPLE_CLOCK_DIRECTION_FORWARD\t\t0\n#define LOWFRE_EN_MASK\t\t\t\tBIT(5)\n#define PLL_OUTPUT_FREQUENCY_DIV_BY_1\t\t0\n#define PLL_OUTPUT_FREQUENCY_DIV_BY_2\t\t1\n \n#define CLOCK_LANE_VOD_RANGE_SET_MASK\t\tGENMASK(3, 0)\n#define CLOCK_LANE_VOD_RANGE_SET(x)\t\tUPDATE(x, 3, 0)\n#define VOD_MIN_RANGE\t\t\t\t0x1\n#define VOD_MID_RANGE\t\t\t\t0x3\n#define VOD_BIG_RANGE\t\t\t\t0x7\n#define VOD_MAX_RANGE\t\t\t\t0xf\n \n#define PLL_MODE_SEL_MASK\t\t\tGENMASK(6, 5)\n#define PLL_MODE_SEL_LVDS_MODE\t\t\t0\n#define PLL_MODE_SEL_MIPI_MODE\t\t\tBIT(5)\n \n#define REG_DIG_RSTN_MASK\t\t\tBIT(0)\n#define REG_DIG_RSTN_NORMAL\t\t\tBIT(0)\n#define REG_DIG_RSTN_RESET\t\t\t0\n \n#define INVERT_TXCLKESC_MASK\t\t\tBIT(1)\n#define INVERT_TXCLKESC_ENABLE\t\t\tBIT(1)\n#define INVERT_TXCLKESC_DISABLE\t\t\t0\n#define INVERT_TXBYTECLKHS_MASK\t\t\tBIT(0)\n#define INVERT_TXBYTECLKHS_ENABLE\t\tBIT(0)\n#define INVERT_TXBYTECLKHS_DISABLE\t\t0\n \n#define T_LPX_CNT_MASK\t\t\t\tGENMASK(5, 0)\n#define T_LPX_CNT(x)\t\t\t\tUPDATE(x, 5, 0)\n \n#define T_HS_ZERO_CNT_HI_MASK\t\t\tBIT(7)\n#define T_HS_ZERO_CNT_HI(x)\t\t\tUPDATE(x, 7, 7)\n#define T_HS_PREPARE_CNT_MASK\t\t\tGENMASK(6, 0)\n#define T_HS_PREPARE_CNT(x)\t\t\tUPDATE(x, 6, 0)\n \n#define T_HS_ZERO_CNT_LO_MASK\t\t\tGENMASK(5, 0)\n#define T_HS_ZERO_CNT_LO(x)\t\t\tUPDATE(x, 5, 0)\n \n#define T_HS_TRAIL_CNT_MASK\t\t\tGENMASK(6, 0)\n#define T_HS_TRAIL_CNT(x)\t\t\tUPDATE(x, 6, 0)\n \n#define T_HS_EXIT_CNT_LO_MASK\t\t\tGENMASK(4, 0)\n#define T_HS_EXIT_CNT_LO(x)\t\t\tUPDATE(x, 4, 0)\n \n#define T_CLK_POST_CNT_LO_MASK\t\t\tGENMASK(3, 0)\n#define T_CLK_POST_CNT_LO(x)\t\t\tUPDATE(x, 3, 0)\n \n#define LPDT_TX_PPI_SYNC_MASK\t\t\tBIT(2)\n#define LPDT_TX_PPI_SYNC_ENABLE\t\t\tBIT(2)\n#define LPDT_TX_PPI_SYNC_DISABLE\t\t0\n#define T_WAKEUP_CNT_HI_MASK\t\t\tGENMASK(1, 0)\n#define T_WAKEUP_CNT_HI(x)\t\t\tUPDATE(x, 1, 0)\n \n#define T_WAKEUP_CNT_LO_MASK\t\t\tGENMASK(7, 0)\n#define T_WAKEUP_CNT_LO(x)\t\t\tUPDATE(x, 7, 0)\n \n#define T_CLK_PRE_CNT_MASK\t\t\tGENMASK(3, 0)\n#define T_CLK_PRE_CNT(x)\t\t\tUPDATE(x, 3, 0)\n \n#define T_CLK_POST_CNT_HI_MASK\t\t\tGENMASK(7, 6)\n#define T_CLK_POST_CNT_HI(x)\t\t\tUPDATE(x, 7, 6)\n#define T_TA_GO_CNT_MASK\t\t\tGENMASK(5, 0)\n#define T_TA_GO_CNT(x)\t\t\t\tUPDATE(x, 5, 0)\n \n#define T_HS_EXIT_CNT_HI_MASK\t\t\tBIT(6)\n#define T_HS_EXIT_CNT_HI(x)\t\t\tUPDATE(x, 6, 6)\n#define T_TA_SURE_CNT_MASK\t\t\tGENMASK(5, 0)\n#define T_TA_SURE_CNT(x)\t\t\tUPDATE(x, 5, 0)\n \n#define T_TA_WAIT_CNT_MASK\t\t\tGENMASK(5, 0)\n#define T_TA_WAIT_CNT(x)\t\t\tUPDATE(x, 5, 0)\n \n#define LVDS_DIGITAL_INTERNAL_RESET_MASK\tBIT(2)\n#define LVDS_DIGITAL_INTERNAL_RESET_DISABLE\tBIT(2)\n#define LVDS_DIGITAL_INTERNAL_RESET_ENABLE\t0\n \n#define LVDS_DIGITAL_INTERNAL_ENABLE_MASK\tBIT(7)\n#define LVDS_DIGITAL_INTERNAL_ENABLE\t\tBIT(7)\n#define LVDS_DIGITAL_INTERNAL_DISABLE\t\t0\n \n#define MODE_ENABLE_MASK\t\t\tGENMASK(2, 0)\n#define TTL_MODE_ENABLE\t\t\t\tBIT(2)\n#define LVDS_MODE_ENABLE\t\t\tBIT(1)\n#define MIPI_MODE_ENABLE\t\t\tBIT(0)\n \n#define LVDS_LANE_EN_MASK\t\t\tGENMASK(7, 3)\n#define LVDS_DATA_LANE0_EN\t\t\tBIT(7)\n#define LVDS_DATA_LANE1_EN\t\t\tBIT(6)\n#define LVDS_DATA_LANE2_EN\t\t\tBIT(5)\n#define LVDS_DATA_LANE3_EN\t\t\tBIT(4)\n#define LVDS_CLK_LANE_EN\t\t\tBIT(3)\n#define LVDS_PLL_POWER_MASK\t\t\tBIT(2)\n#define LVDS_PLL_POWER_OFF\t\t\tBIT(2)\n#define LVDS_PLL_POWER_ON\t\t\t0\n#define LVDS_BANDGAP_POWER_MASK\t\t\tBIT(0)\n#define LVDS_BANDGAP_POWER_DOWN\t\t\tBIT(0)\n#define LVDS_BANDGAP_POWER_ON\t\t\t0\n\n#define DSI_PHY_RSTZ\t\t0xa0\n#define PHY_ENABLECLK\t\tBIT(2)\n#define DSI_PHY_STATUS\t\t0xb0\n#define PHY_LOCK\t\tBIT(0)\n\nenum phy_max_rate {\n\tMAX_1GHZ,\n\tMAX_2_5GHZ,\n};\n\nstruct inno_video_phy_plat_data {\n\tconst struct inno_mipi_dphy_timing *inno_mipi_dphy_timing_table;\n\tconst unsigned int num_timings;\n\tenum phy_max_rate max_rate;\n};\n\nstruct inno_dsidphy {\n\tstruct device *dev;\n\tstruct clk *ref_clk;\n\tstruct clk *pclk_phy;\n\tstruct clk *pclk_host;\n\tconst struct inno_video_phy_plat_data *pdata;\n\tvoid __iomem *phy_base;\n\tvoid __iomem *host_base;\n\tstruct reset_control *rst;\n\tenum phy_mode mode;\n\tstruct phy_configure_opts_mipi_dphy dphy_cfg;\n\n\tstruct clk *pll_clk;\n\tstruct {\n\t\tstruct clk_hw hw;\n\t\tu8 prediv;\n\t\tu16 fbdiv;\n\t\tunsigned long rate;\n\t} pll;\n};\n\nenum {\n\tREGISTER_PART_ANALOG,\n\tREGISTER_PART_DIGITAL,\n\tREGISTER_PART_CLOCK_LANE,\n\tREGISTER_PART_DATA0_LANE,\n\tREGISTER_PART_DATA1_LANE,\n\tREGISTER_PART_DATA2_LANE,\n\tREGISTER_PART_DATA3_LANE,\n\tREGISTER_PART_LVDS,\n};\n\nstruct inno_mipi_dphy_timing {\n\tunsigned long rate;\n\tu8 lpx;\n\tu8 hs_prepare;\n\tu8 clk_lane_hs_zero;\n\tu8 data_lane_hs_zero;\n\tu8 hs_trail;\n};\n\nstatic const\nstruct inno_mipi_dphy_timing inno_mipi_dphy_timing_table_max_1ghz[] = {\n\t{ 110000000, 0x0, 0x20, 0x16, 0x02, 0x22},\n\t{ 150000000, 0x0, 0x06, 0x16, 0x03, 0x45},\n\t{ 200000000, 0x0, 0x18, 0x17, 0x04, 0x0b},\n\t{ 250000000, 0x0, 0x05, 0x17, 0x05, 0x16},\n\t{ 300000000, 0x0, 0x51, 0x18, 0x06, 0x2c},\n\t{ 400000000, 0x0, 0x64, 0x19, 0x07, 0x33},\n\t{ 500000000, 0x0, 0x20, 0x1b, 0x07, 0x4e},\n\t{ 600000000, 0x0, 0x6a, 0x1d, 0x08, 0x3a},\n\t{ 700000000, 0x0, 0x3e, 0x1e, 0x08, 0x6a},\n\t{ 800000000, 0x0, 0x21, 0x1f, 0x09, 0x29},\n\t{1000000000, 0x0, 0x09, 0x20, 0x09, 0x27},\n};\n\nstatic const\nstruct inno_mipi_dphy_timing inno_mipi_dphy_timing_table_max_2_5ghz[] = {\n\t{ 110000000, 0x02, 0x7f, 0x16, 0x02, 0x02},\n\t{ 150000000, 0x02, 0x7f, 0x16, 0x03, 0x02},\n\t{ 200000000, 0x02, 0x7f, 0x17, 0x04, 0x02},\n\t{ 250000000, 0x02, 0x7f, 0x17, 0x05, 0x04},\n\t{ 300000000, 0x02, 0x7f, 0x18, 0x06, 0x04},\n\t{ 400000000, 0x03, 0x7e, 0x19, 0x07, 0x04},\n\t{ 500000000, 0x03, 0x7c, 0x1b, 0x07, 0x08},\n\t{ 600000000, 0x03, 0x70, 0x1d, 0x08, 0x10},\n\t{ 700000000, 0x05, 0x40, 0x1e, 0x08, 0x30},\n\t{ 800000000, 0x05, 0x02, 0x1f, 0x09, 0x30},\n\t{1000000000, 0x05, 0x08, 0x20, 0x09, 0x30},\n\t{1200000000, 0x06, 0x03, 0x32, 0x14, 0x0f},\n\t{1400000000, 0x09, 0x03, 0x32, 0x14, 0x0f},\n\t{1600000000, 0x0d, 0x42, 0x36, 0x0e, 0x0f},\n\t{1800000000, 0x0e, 0x47, 0x7a, 0x0e, 0x0f},\n\t{2000000000, 0x11, 0x64, 0x7a, 0x0e, 0x0b},\n\t{2200000000, 0x13, 0x64, 0x7e, 0x15, 0x0b},\n\t{2400000000, 0x13, 0x33, 0x7f, 0x15, 0x6a},\n\t{2500000000, 0x15, 0x54, 0x7f, 0x15, 0x6a},\n};\n\nstatic void phy_update_bits(struct inno_dsidphy *inno,\n\t\t\t    u8 first, u8 second, u8 mask, u8 val)\n{\n\tu32 reg = PHY_REG(first, second) << 2;\n\tunsigned int tmp, orig;\n\n\torig = readl(inno->phy_base + reg);\n\ttmp = orig & ~mask;\n\ttmp |= val & mask;\n\twritel(tmp, inno->phy_base + reg);\n}\n\nstatic unsigned long inno_dsidphy_pll_calc_rate(struct inno_dsidphy *inno,\n\t\t\t\t\t\tunsigned long rate)\n{\n\tunsigned long prate = clk_get_rate(inno->ref_clk);\n\tunsigned long best_freq = 0;\n\tunsigned long fref, fout;\n\tu8 min_prediv, max_prediv;\n\tu8 _prediv, best_prediv = 1;\n\tu16 _fbdiv, best_fbdiv = 1;\n\tu32 min_delta = UINT_MAX;\n\n\t \n\tfref = prate / 2;\n\tif (rate > 1000000000UL)\n\t\tfout = 1000000000UL;\n\telse\n\t\tfout = rate;\n\n\t \n\tmin_prediv = DIV_ROUND_UP(fref, 40000000);\n\tmax_prediv = fref / 5000000;\n\n\tfor (_prediv = min_prediv; _prediv <= max_prediv; _prediv++) {\n\t\tu64 tmp;\n\t\tu32 delta;\n\n\t\ttmp = (u64)fout * _prediv;\n\t\tdo_div(tmp, fref);\n\t\t_fbdiv = tmp;\n\n\t\t \n\t\tif (_fbdiv == 15)\n\t\t\tcontinue;\n\n\t\tif (_fbdiv < 12 || _fbdiv > 511)\n\t\t\tcontinue;\n\n\t\ttmp = (u64)_fbdiv * fref;\n\t\tdo_div(tmp, _prediv);\n\n\t\tdelta = abs(fout - tmp);\n\t\tif (!delta) {\n\t\t\tbest_prediv = _prediv;\n\t\t\tbest_fbdiv = _fbdiv;\n\t\t\tbest_freq = tmp;\n\t\t\tbreak;\n\t\t} else if (delta < min_delta) {\n\t\t\tbest_prediv = _prediv;\n\t\t\tbest_fbdiv = _fbdiv;\n\t\t\tbest_freq = tmp;\n\t\t\tmin_delta = delta;\n\t\t}\n\t}\n\n\tif (best_freq) {\n\t\tinno->pll.prediv = best_prediv;\n\t\tinno->pll.fbdiv = best_fbdiv;\n\t\tinno->pll.rate = best_freq;\n\t}\n\n\treturn best_freq;\n}\n\nstatic void inno_dsidphy_mipi_mode_enable(struct inno_dsidphy *inno)\n{\n\tstruct phy_configure_opts_mipi_dphy *cfg = &inno->dphy_cfg;\n\tconst struct inno_mipi_dphy_timing *timings;\n\tu32 t_txbyteclkhs, t_txclkesc;\n\tu32 txbyteclkhs, txclkesc, esc_clk_div;\n\tu32 hs_exit, clk_post, clk_pre, wakeup, lpx, ta_go, ta_sure, ta_wait;\n\tu32 hs_prepare, hs_trail, hs_zero, clk_lane_hs_zero, data_lane_hs_zero;\n\tunsigned int i;\n\n\ttimings = inno->pdata->inno_mipi_dphy_timing_table;\n\n\tinno_dsidphy_pll_calc_rate(inno, cfg->hs_clk_rate);\n\n\t \n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x03,\n\t\t\tMODE_ENABLE_MASK, MIPI_MODE_ENABLE);\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,\n\t\t\tREG_PREDIV_MASK, REG_PREDIV(inno->pll.prediv));\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,\n\t\t\tREG_FBDIV_HI_MASK, REG_FBDIV_HI(inno->pll.fbdiv));\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x04,\n\t\t\tREG_FBDIV_LO_MASK, REG_FBDIV_LO(inno->pll.fbdiv));\n\tif (inno->pdata->max_rate == MAX_2_5GHZ) {\n\t\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x08,\n\t\t\t\tPLL_POST_DIV_ENABLE_MASK, PLL_POST_DIV_ENABLE);\n\t\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x0b,\n\t\t\t\tCLOCK_LANE_VOD_RANGE_SET_MASK,\n\t\t\t\tCLOCK_LANE_VOD_RANGE_SET(VOD_MAX_RANGE));\n\t}\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,\n\t\t\tREG_LDOPD_MASK | REG_PLLPD_MASK,\n\t\t\tREG_LDOPD_POWER_ON | REG_PLLPD_POWER_ON);\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,\n\t\t\tREG_SYNCRST_MASK, REG_SYNCRST_RESET);\n\tudelay(1);\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,\n\t\t\tREG_SYNCRST_MASK, REG_SYNCRST_NORMAL);\n\t \n\tphy_update_bits(inno, REGISTER_PART_DIGITAL, 0x00,\n\t\t\tREG_DIG_RSTN_MASK, REG_DIG_RSTN_RESET);\n\tudelay(1);\n\tphy_update_bits(inno, REGISTER_PART_DIGITAL, 0x00,\n\t\t\tREG_DIG_RSTN_MASK, REG_DIG_RSTN_NORMAL);\n\n\ttxbyteclkhs = inno->pll.rate / 8;\n\tt_txbyteclkhs = div_u64(PSEC_PER_SEC, txbyteclkhs);\n\n\tesc_clk_div = DIV_ROUND_UP(txbyteclkhs, 20000000);\n\ttxclkesc = txbyteclkhs / esc_clk_div;\n\tt_txclkesc = div_u64(PSEC_PER_SEC, txclkesc);\n\n\t \n\ths_exit = DIV_ROUND_UP(cfg->hs_exit, t_txbyteclkhs);\n\t \n\tclk_post = DIV_ROUND_UP(cfg->clk_post, t_txbyteclkhs);\n\t \n\tclk_pre = DIV_ROUND_UP(cfg->clk_pre, BITS_PER_BYTE);\n\n\t \n\tta_go = DIV_ROUND_UP(cfg->ta_go, t_txclkesc);\n\t \n\tta_sure = DIV_ROUND_UP(cfg->ta_sure, t_txclkesc);\n\t \n\tta_wait = DIV_ROUND_UP(cfg->ta_get, t_txclkesc);\n\n\tfor (i = 0; i < inno->pdata->num_timings; i++)\n\t\tif (inno->pll.rate <= timings[i].rate)\n\t\t\tbreak;\n\n\tif (i == inno->pdata->num_timings)\n\t\t--i;\n\n\t \n\tif (inno->pdata->max_rate == MAX_1GHZ) {\n\t\tlpx = DIV_ROUND_UP(cfg->lpx, t_txbyteclkhs);\n\t\tif (lpx >= 2)\n\t\t\tlpx -= 2;\n\t} else\n\t\tlpx = timings[i].lpx;\n\n\ths_prepare = timings[i].hs_prepare;\n\ths_trail = timings[i].hs_trail;\n\tclk_lane_hs_zero = timings[i].clk_lane_hs_zero;\n\tdata_lane_hs_zero = timings[i].data_lane_hs_zero;\n\twakeup = 0x3ff;\n\n\tfor (i = REGISTER_PART_CLOCK_LANE; i <= REGISTER_PART_DATA3_LANE; i++) {\n\t\tif (i == REGISTER_PART_CLOCK_LANE)\n\t\t\ths_zero = clk_lane_hs_zero;\n\t\telse\n\t\t\ths_zero = data_lane_hs_zero;\n\n\t\tphy_update_bits(inno, i, 0x05, T_LPX_CNT_MASK,\n\t\t\t\tT_LPX_CNT(lpx));\n\t\tphy_update_bits(inno, i, 0x06, T_HS_PREPARE_CNT_MASK,\n\t\t\t\tT_HS_PREPARE_CNT(hs_prepare));\n\t\tif (inno->pdata->max_rate == MAX_2_5GHZ)\n\t\t\tphy_update_bits(inno, i, 0x06, T_HS_ZERO_CNT_HI_MASK,\n\t\t\t\t\tT_HS_ZERO_CNT_HI(hs_zero >> 6));\n\t\tphy_update_bits(inno, i, 0x07, T_HS_ZERO_CNT_LO_MASK,\n\t\t\t\tT_HS_ZERO_CNT_LO(hs_zero));\n\t\tphy_update_bits(inno, i, 0x08, T_HS_TRAIL_CNT_MASK,\n\t\t\t\tT_HS_TRAIL_CNT(hs_trail));\n\t\tif (inno->pdata->max_rate == MAX_2_5GHZ)\n\t\t\tphy_update_bits(inno, i, 0x11, T_HS_EXIT_CNT_HI_MASK,\n\t\t\t\t\tT_HS_EXIT_CNT_HI(hs_exit >> 5));\n\t\tphy_update_bits(inno, i, 0x09, T_HS_EXIT_CNT_LO_MASK,\n\t\t\t\tT_HS_EXIT_CNT_LO(hs_exit));\n\t\tif (inno->pdata->max_rate == MAX_2_5GHZ)\n\t\t\tphy_update_bits(inno, i, 0x10, T_CLK_POST_CNT_HI_MASK,\n\t\t\t\t\tT_CLK_POST_CNT_HI(clk_post >> 4));\n\t\tphy_update_bits(inno, i, 0x0a, T_CLK_POST_CNT_LO_MASK,\n\t\t\t\tT_CLK_POST_CNT_LO(clk_post));\n\t\tphy_update_bits(inno, i, 0x0e, T_CLK_PRE_CNT_MASK,\n\t\t\t\tT_CLK_PRE_CNT(clk_pre));\n\t\tphy_update_bits(inno, i, 0x0c, T_WAKEUP_CNT_HI_MASK,\n\t\t\t\tT_WAKEUP_CNT_HI(wakeup >> 8));\n\t\tphy_update_bits(inno, i, 0x0d, T_WAKEUP_CNT_LO_MASK,\n\t\t\t\tT_WAKEUP_CNT_LO(wakeup));\n\t\tphy_update_bits(inno, i, 0x10, T_TA_GO_CNT_MASK,\n\t\t\t\tT_TA_GO_CNT(ta_go));\n\t\tphy_update_bits(inno, i, 0x11, T_TA_SURE_CNT_MASK,\n\t\t\t\tT_TA_SURE_CNT(ta_sure));\n\t\tphy_update_bits(inno, i, 0x12, T_TA_WAIT_CNT_MASK,\n\t\t\t\tT_TA_WAIT_CNT(ta_wait));\n\t}\n\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,\n\t\t\tLANE_EN_MASK, LANE_EN_CK | LANE_EN_3 | LANE_EN_2 |\n\t\t\tLANE_EN_1 | LANE_EN_0);\n}\n\nstatic void inno_dsidphy_lvds_mode_enable(struct inno_dsidphy *inno)\n{\n\tu8 prediv = 2;\n\tu16 fbdiv = 28;\n\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x08,\n\t\t\tSAMPLE_CLOCK_DIRECTION_MASK | LOWFRE_EN_MASK,\n\t\t\tSAMPLE_CLOCK_DIRECTION_REVERSE |\n\t\t\tPLL_OUTPUT_FREQUENCY_DIV_BY_1);\n\n\t \n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x03,\n\t\t\tMODE_ENABLE_MASK, LVDS_MODE_ENABLE);\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,\n\t\t\tREG_PREDIV_MASK, REG_PREDIV(prediv));\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,\n\t\t\tREG_FBDIV_HI_MASK, REG_FBDIV_HI(fbdiv));\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x04,\n\t\t\tREG_FBDIV_LO_MASK, REG_FBDIV_LO(fbdiv));\n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x08, 0xff, 0xfc);\n\t \n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,\n\t\t\tLVDS_PLL_POWER_MASK | LVDS_BANDGAP_POWER_MASK,\n\t\t\tLVDS_PLL_POWER_ON | LVDS_BANDGAP_POWER_ON);\n\n\tmsleep(20);\n\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x1e,\n\t\t\tPLL_MODE_SEL_MASK, PLL_MODE_SEL_LVDS_MODE);\n\n\t \n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x00,\n\t\t\tLVDS_DIGITAL_INTERNAL_RESET_MASK,\n\t\t\tLVDS_DIGITAL_INTERNAL_RESET_ENABLE);\n\tudelay(1);\n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x00,\n\t\t\tLVDS_DIGITAL_INTERNAL_RESET_MASK,\n\t\t\tLVDS_DIGITAL_INTERNAL_RESET_DISABLE);\n\t \n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x01,\n\t\t\tLVDS_DIGITAL_INTERNAL_ENABLE_MASK,\n\t\t\tLVDS_DIGITAL_INTERNAL_ENABLE);\n\t \n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,\n\t\t\tLVDS_LANE_EN_MASK, LVDS_CLK_LANE_EN |\n\t\t\tLVDS_DATA_LANE0_EN | LVDS_DATA_LANE1_EN |\n\t\t\tLVDS_DATA_LANE2_EN | LVDS_DATA_LANE3_EN);\n}\n\nstatic int inno_dsidphy_power_on(struct phy *phy)\n{\n\tstruct inno_dsidphy *inno = phy_get_drvdata(phy);\n\n\tclk_prepare_enable(inno->pclk_phy);\n\tclk_prepare_enable(inno->ref_clk);\n\tpm_runtime_get_sync(inno->dev);\n\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,\n\t\t\tBANDGAP_POWER_MASK, BANDGAP_POWER_ON);\n\t \n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,\n\t\t\tPOWER_WORK_MASK, POWER_WORK_ENABLE);\n\n\tswitch (inno->mode) {\n\tcase PHY_MODE_MIPI_DPHY:\n\t\tinno_dsidphy_mipi_mode_enable(inno);\n\t\tbreak;\n\tcase PHY_MODE_LVDS:\n\t\tinno_dsidphy_lvds_mode_enable(inno);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int inno_dsidphy_power_off(struct phy *phy)\n{\n\tstruct inno_dsidphy *inno = phy_get_drvdata(phy);\n\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x00, LANE_EN_MASK, 0);\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,\n\t\t\tREG_LDOPD_MASK | REG_PLLPD_MASK,\n\t\t\tREG_LDOPD_POWER_DOWN | REG_PLLPD_POWER_DOWN);\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,\n\t\t\tPOWER_WORK_MASK, POWER_WORK_DISABLE);\n\tphy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,\n\t\t\tBANDGAP_POWER_MASK, BANDGAP_POWER_DOWN);\n\n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x0b, LVDS_LANE_EN_MASK, 0);\n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x01,\n\t\t\tLVDS_DIGITAL_INTERNAL_ENABLE_MASK,\n\t\t\tLVDS_DIGITAL_INTERNAL_DISABLE);\n\tphy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,\n\t\t\tLVDS_PLL_POWER_MASK | LVDS_BANDGAP_POWER_MASK,\n\t\t\tLVDS_PLL_POWER_OFF | LVDS_BANDGAP_POWER_DOWN);\n\n\tpm_runtime_put(inno->dev);\n\tclk_disable_unprepare(inno->ref_clk);\n\tclk_disable_unprepare(inno->pclk_phy);\n\n\treturn 0;\n}\n\nstatic int inno_dsidphy_set_mode(struct phy *phy, enum phy_mode mode,\n\t\t\t\t   int submode)\n{\n\tstruct inno_dsidphy *inno = phy_get_drvdata(phy);\n\n\tswitch (mode) {\n\tcase PHY_MODE_MIPI_DPHY:\n\tcase PHY_MODE_LVDS:\n\t\tinno->mode = mode;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int inno_dsidphy_configure(struct phy *phy,\n\t\t\t\t  union phy_configure_opts *opts)\n{\n\tstruct inno_dsidphy *inno = phy_get_drvdata(phy);\n\tint ret;\n\n\tif (inno->mode != PHY_MODE_MIPI_DPHY)\n\t\treturn -EINVAL;\n\n\tret = phy_mipi_dphy_config_validate(&opts->mipi_dphy);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&inno->dphy_cfg, &opts->mipi_dphy, sizeof(inno->dphy_cfg));\n\n\treturn 0;\n}\n\nstatic const struct phy_ops inno_dsidphy_ops = {\n\t.configure = inno_dsidphy_configure,\n\t.set_mode = inno_dsidphy_set_mode,\n\t.power_on = inno_dsidphy_power_on,\n\t.power_off = inno_dsidphy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct inno_video_phy_plat_data max_1ghz_video_phy_plat_data = {\n\t.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_1ghz,\n\t.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_1ghz),\n\t.max_rate = MAX_1GHZ,\n};\n\nstatic const struct inno_video_phy_plat_data max_2_5ghz_video_phy_plat_data = {\n\t.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_2_5ghz,\n\t.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_2_5ghz),\n\t.max_rate = MAX_2_5GHZ,\n};\n\nstatic int inno_dsidphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct inno_dsidphy *inno;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *phy;\n\tint ret;\n\n\tinno = devm_kzalloc(dev, sizeof(*inno), GFP_KERNEL);\n\tif (!inno)\n\t\treturn -ENOMEM;\n\n\tinno->dev = dev;\n\tinno->pdata = of_device_get_match_data(inno->dev);\n\tplatform_set_drvdata(pdev, inno);\n\n\tinno->phy_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(inno->phy_base))\n\t\treturn PTR_ERR(inno->phy_base);\n\n\tinno->ref_clk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(inno->ref_clk)) {\n\t\tret = PTR_ERR(inno->ref_clk);\n\t\tdev_err(dev, \"failed to get ref clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinno->pclk_phy = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(inno->pclk_phy)) {\n\t\tret = PTR_ERR(inno->pclk_phy);\n\t\tdev_err(dev, \"failed to get phy pclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinno->rst = devm_reset_control_get(dev, \"apb\");\n\tif (IS_ERR(inno->rst)) {\n\t\tret = PTR_ERR(inno->rst);\n\t\tdev_err(dev, \"failed to get system reset control: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy = devm_phy_create(dev, NULL, &inno_dsidphy_ops);\n\tif (IS_ERR(phy)) {\n\t\tret = PTR_ERR(phy);\n\t\tdev_err(dev, \"failed to create phy: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy_set_drvdata(phy, inno);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tret = PTR_ERR(phy_provider);\n\t\tdev_err(dev, \"failed to register phy provider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void inno_dsidphy_remove(struct platform_device *pdev)\n{\n\tstruct inno_dsidphy *inno = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(inno->dev);\n}\n\nstatic const struct of_device_id inno_dsidphy_of_match[] = {\n\t{\n\t\t.compatible = \"rockchip,px30-dsi-dphy\",\n\t\t.data = &max_1ghz_video_phy_plat_data,\n\t}, {\n\t\t.compatible = \"rockchip,rk3128-dsi-dphy\",\n\t\t.data = &max_1ghz_video_phy_plat_data,\n\t}, {\n\t\t.compatible = \"rockchip,rk3368-dsi-dphy\",\n\t\t.data = &max_1ghz_video_phy_plat_data,\n\t}, {\n\t\t.compatible = \"rockchip,rk3568-dsi-dphy\",\n\t\t.data = &max_2_5ghz_video_phy_plat_data,\n\t}, {\n\t\t.compatible = \"rockchip,rv1126-dsi-dphy\",\n\t\t.data = &max_2_5ghz_video_phy_plat_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, inno_dsidphy_of_match);\n\nstatic struct platform_driver inno_dsidphy_driver = {\n\t.driver = {\n\t\t.name = \"inno-dsidphy\",\n\t\t.of_match_table\t= of_match_ptr(inno_dsidphy_of_match),\n\t},\n\t.probe = inno_dsidphy_probe,\n\t.remove_new = inno_dsidphy_remove,\n};\nmodule_platform_driver(inno_dsidphy_driver);\n\nMODULE_AUTHOR(\"Wyon Bi <bivvy.bi@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Innosilicon MIPI/LVDS/TTL Video Combo PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}