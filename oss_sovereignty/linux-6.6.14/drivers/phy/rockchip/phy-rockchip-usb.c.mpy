{
  "module_name": "phy-rockchip-usb.c",
  "hash_id": "22af685d0aa24ac3532833e15b71cb831914b1d34bd8590d05e3a02edf6416a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-usb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/delay.h>\n\nstatic int enable_usb_uart;\n\n#define HIWORD_UPDATE(val, mask) \\\n\t\t((val) | (mask) << 16)\n\n#define UOC_CON0\t\t\t\t\t0x00\n#define UOC_CON0_SIDDQ\t\t\t\t\tBIT(13)\n#define UOC_CON0_DISABLE\t\t\t\tBIT(4)\n#define UOC_CON0_COMMON_ON_N\t\t\t\tBIT(0)\n\n#define UOC_CON2\t\t\t\t\t0x08\n#define UOC_CON2_SOFT_CON_SEL\t\t\t\tBIT(2)\n\n#define UOC_CON3\t\t\t\t\t0x0c\n \n#define UOC_CON3_UTMI_TERMSEL_FULLSPEED\t\t\tBIT(5)\n#define UOC_CON3_UTMI_XCVRSEELCT_FSTRANSC\t\t(1 << 3)\n#define UOC_CON3_UTMI_XCVRSEELCT_MASK\t\t\t(3 << 3)\n#define UOC_CON3_UTMI_OPMODE_NODRIVING\t\t\t(1 << 1)\n#define UOC_CON3_UTMI_OPMODE_MASK\t\t\t(3 << 1)\n#define UOC_CON3_UTMI_SUSPENDN\t\t\t\tBIT(0)\n\nstruct rockchip_usb_phys {\n\tint reg;\n\tconst char *pll_name;\n};\n\nstruct rockchip_usb_phy_base;\nstruct rockchip_usb_phy_pdata {\n\tstruct rockchip_usb_phys *phys;\n\tint (*init_usb_uart)(struct regmap *grf,\n\t\t\t     const struct rockchip_usb_phy_pdata *pdata);\n\tint usb_uart_phy;\n};\n\nstruct rockchip_usb_phy_base {\n\tstruct device *dev;\n\tstruct regmap *reg_base;\n\tconst struct rockchip_usb_phy_pdata *pdata;\n};\n\nstruct rockchip_usb_phy {\n\tstruct rockchip_usb_phy_base *base;\n\tstruct device_node *np;\n\tunsigned int\treg_offset;\n\tstruct clk\t*clk;\n\tstruct clk      *clk480m;\n\tstruct clk_hw\tclk480m_hw;\n\tstruct phy\t*phy;\n\tbool\t\tuart_enabled;\n\tstruct reset_control *reset;\n\tstruct regulator *vbus;\n};\n\nstatic int rockchip_usb_phy_power(struct rockchip_usb_phy *phy,\n\t\t\t\t\t   bool siddq)\n{\n\tu32 val = HIWORD_UPDATE(siddq ? UOC_CON0_SIDDQ : 0, UOC_CON0_SIDDQ);\n\n\treturn regmap_write(phy->base->reg_base, phy->reg_offset, val);\n}\n\nstatic unsigned long rockchip_usb_phy480m_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\treturn 480000000;\n}\n\nstatic void rockchip_usb_phy480m_disable(struct clk_hw *hw)\n{\n\tstruct rockchip_usb_phy *phy = container_of(hw,\n\t\t\t\t\t\t    struct rockchip_usb_phy,\n\t\t\t\t\t\t    clk480m_hw);\n\n\tif (phy->vbus)\n\t\tregulator_disable(phy->vbus);\n\n\t \n\trockchip_usb_phy_power(phy, 1);\n}\n\nstatic int rockchip_usb_phy480m_enable(struct clk_hw *hw)\n{\n\tstruct rockchip_usb_phy *phy = container_of(hw,\n\t\t\t\t\t\t    struct rockchip_usb_phy,\n\t\t\t\t\t\t    clk480m_hw);\n\n\t \n\treturn rockchip_usb_phy_power(phy, 0);\n}\n\nstatic int rockchip_usb_phy480m_is_enabled(struct clk_hw *hw)\n{\n\tstruct rockchip_usb_phy *phy = container_of(hw,\n\t\t\t\t\t\t    struct rockchip_usb_phy,\n\t\t\t\t\t\t    clk480m_hw);\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read(phy->base->reg_base, phy->reg_offset, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (val & UOC_CON0_SIDDQ) ? 0 : 1;\n}\n\nstatic const struct clk_ops rockchip_usb_phy480m_ops = {\n\t.enable = rockchip_usb_phy480m_enable,\n\t.disable = rockchip_usb_phy480m_disable,\n\t.is_enabled = rockchip_usb_phy480m_is_enabled,\n\t.recalc_rate = rockchip_usb_phy480m_recalc_rate,\n};\n\nstatic int rockchip_usb_phy_power_off(struct phy *_phy)\n{\n\tstruct rockchip_usb_phy *phy = phy_get_drvdata(_phy);\n\n\tif (phy->uart_enabled)\n\t\treturn -EBUSY;\n\n\tclk_disable_unprepare(phy->clk480m);\n\n\treturn 0;\n}\n\nstatic int rockchip_usb_phy_power_on(struct phy *_phy)\n{\n\tstruct rockchip_usb_phy *phy = phy_get_drvdata(_phy);\n\n\tif (phy->uart_enabled)\n\t\treturn -EBUSY;\n\n\tif (phy->vbus) {\n\t\tint ret;\n\n\t\tret = regulator_enable(phy->vbus);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn clk_prepare_enable(phy->clk480m);\n}\n\nstatic int rockchip_usb_phy_reset(struct phy *_phy)\n{\n\tstruct rockchip_usb_phy *phy = phy_get_drvdata(_phy);\n\n\tif (phy->reset) {\n\t\treset_control_assert(phy->reset);\n\t\tudelay(10);\n\t\treset_control_deassert(phy->reset);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ops = {\n\t.power_on\t= rockchip_usb_phy_power_on,\n\t.power_off\t= rockchip_usb_phy_power_off,\n\t.reset\t\t= rockchip_usb_phy_reset,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void rockchip_usb_phy_action(void *data)\n{\n\tstruct rockchip_usb_phy *rk_phy = data;\n\n\tif (!rk_phy->uart_enabled) {\n\t\tof_clk_del_provider(rk_phy->np);\n\t\tclk_unregister(rk_phy->clk480m);\n\t}\n\n\tif (rk_phy->clk)\n\t\tclk_put(rk_phy->clk);\n}\n\nstatic int rockchip_usb_phy_init(struct rockchip_usb_phy_base *base,\n\t\t\t\t struct device_node *child)\n{\n\tstruct rockchip_usb_phy *rk_phy;\n\tunsigned int reg_offset;\n\tconst char *clk_name;\n\tstruct clk_init_data init;\n\tint err, i;\n\n\trk_phy = devm_kzalloc(base->dev, sizeof(*rk_phy), GFP_KERNEL);\n\tif (!rk_phy)\n\t\treturn -ENOMEM;\n\n\trk_phy->base = base;\n\trk_phy->np = child;\n\n\tif (of_property_read_u32(child, \"reg\", &reg_offset)) {\n\t\tdev_err(base->dev, \"missing reg property in node %pOFn\\n\",\n\t\t\tchild);\n\t\treturn -EINVAL;\n\t}\n\n\trk_phy->reset = of_reset_control_get(child, \"phy-reset\");\n\tif (IS_ERR(rk_phy->reset))\n\t\trk_phy->reset = NULL;\n\n\trk_phy->reg_offset = reg_offset;\n\n\trk_phy->clk = of_clk_get_by_name(child, \"phyclk\");\n\tif (IS_ERR(rk_phy->clk))\n\t\trk_phy->clk = NULL;\n\n\ti = 0;\n\tinit.name = NULL;\n\twhile (base->pdata->phys[i].reg) {\n\t\tif (base->pdata->phys[i].reg == reg_offset) {\n\t\t\tinit.name = base->pdata->phys[i].pll_name;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (!init.name) {\n\t\tdev_err(base->dev, \"phy data not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (enable_usb_uart && base->pdata->usb_uart_phy == i) {\n\t\tdev_dbg(base->dev, \"phy%d used as uart output\\n\", i);\n\t\trk_phy->uart_enabled = true;\n\t} else {\n\t\tif (rk_phy->clk) {\n\t\t\tclk_name = __clk_get_name(rk_phy->clk);\n\t\t\tinit.flags = 0;\n\t\t\tinit.parent_names = &clk_name;\n\t\t\tinit.num_parents = 1;\n\t\t} else {\n\t\t\tinit.flags = 0;\n\t\t\tinit.parent_names = NULL;\n\t\t\tinit.num_parents = 0;\n\t\t}\n\n\t\tinit.ops = &rockchip_usb_phy480m_ops;\n\t\trk_phy->clk480m_hw.init = &init;\n\n\t\trk_phy->clk480m = clk_register(base->dev, &rk_phy->clk480m_hw);\n\t\tif (IS_ERR(rk_phy->clk480m)) {\n\t\t\terr = PTR_ERR(rk_phy->clk480m);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\terr = of_clk_add_provider(child, of_clk_src_simple_get,\n\t\t\t\t\trk_phy->clk480m);\n\t\tif (err < 0)\n\t\t\tgoto err_clk_prov;\n\t}\n\n\terr = devm_add_action_or_reset(base->dev, rockchip_usb_phy_action,\n\t\t\t\t       rk_phy);\n\tif (err)\n\t\treturn err;\n\n\trk_phy->phy = devm_phy_create(base->dev, child, &ops);\n\tif (IS_ERR(rk_phy->phy)) {\n\t\tdev_err(base->dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(rk_phy->phy);\n\t}\n\tphy_set_drvdata(rk_phy->phy, rk_phy);\n\n\trk_phy->vbus = devm_regulator_get_optional(&rk_phy->phy->dev, \"vbus\");\n\tif (IS_ERR(rk_phy->vbus)) {\n\t\tif (PTR_ERR(rk_phy->vbus) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(rk_phy->vbus);\n\t\trk_phy->vbus = NULL;\n\t}\n\n\t \n\tif (rk_phy->uart_enabled)\n\t\treturn clk_prepare_enable(rk_phy->clk);\n\telse\n\t\treturn rockchip_usb_phy_power(rk_phy, 1);\n\nerr_clk_prov:\n\tif (!rk_phy->uart_enabled)\n\t\tclk_unregister(rk_phy->clk480m);\nerr_clk:\n\tif (rk_phy->clk)\n\t\tclk_put(rk_phy->clk);\n\treturn err;\n}\n\nstatic const struct rockchip_usb_phy_pdata rk3066a_pdata = {\n\t.phys = (struct rockchip_usb_phys[]){\n\t\t{ .reg = 0x17c, .pll_name = \"sclk_otgphy0_480m\" },\n\t\t{ .reg = 0x188, .pll_name = \"sclk_otgphy1_480m\" },\n\t\t{   }\n\t},\n};\n\nstatic int __init rockchip_init_usb_uart_common(struct regmap *grf,\n\t\t\t\tconst struct rockchip_usb_phy_pdata *pdata)\n{\n\tint regoffs = pdata->phys[pdata->usb_uart_phy].reg;\n\tint ret;\n\tu32 val;\n\n\t \n\tval = HIWORD_UPDATE(UOC_CON0_COMMON_ON_N\n\t\t\t\t| UOC_CON0_DISABLE\n\t\t\t\t| UOC_CON0_SIDDQ,\n\t\t\t    UOC_CON0_COMMON_ON_N\n\t\t\t\t| UOC_CON0_DISABLE\n\t\t\t\t| UOC_CON0_SIDDQ);\n\tret = regmap_write(grf, regoffs + UOC_CON0, val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = HIWORD_UPDATE(UOC_CON2_SOFT_CON_SEL,\n\t\t\t    UOC_CON2_SOFT_CON_SEL);\n\tret = regmap_write(grf, regoffs + UOC_CON2, val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = HIWORD_UPDATE(UOC_CON3_UTMI_OPMODE_NODRIVING\n\t\t\t\t| UOC_CON3_UTMI_XCVRSEELCT_FSTRANSC\n\t\t\t\t| UOC_CON3_UTMI_TERMSEL_FULLSPEED,\n\t\t\t    UOC_CON3_UTMI_SUSPENDN\n\t\t\t\t| UOC_CON3_UTMI_OPMODE_MASK\n\t\t\t\t| UOC_CON3_UTMI_XCVRSEELCT_MASK\n\t\t\t\t| UOC_CON3_UTMI_TERMSEL_FULLSPEED);\n\tret = regmap_write(grf, UOC_CON3, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#define RK3188_UOC0_CON0\t\t\t\t0x10c\n#define RK3188_UOC0_CON0_BYPASSSEL\t\t\tBIT(9)\n#define RK3188_UOC0_CON0_BYPASSDMEN\t\t\tBIT(8)\n\n \nstatic int __init rk3188_init_usb_uart(struct regmap *grf,\n\t\t\t\tconst struct rockchip_usb_phy_pdata *pdata)\n{\n\tu32 val;\n\tint ret;\n\n\tret = rockchip_init_usb_uart_common(grf, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tval = HIWORD_UPDATE(RK3188_UOC0_CON0_BYPASSSEL\n\t\t\t\t| RK3188_UOC0_CON0_BYPASSDMEN,\n\t\t\t    RK3188_UOC0_CON0_BYPASSSEL\n\t\t\t\t| RK3188_UOC0_CON0_BYPASSDMEN);\n\tret = regmap_write(grf, RK3188_UOC0_CON0, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct rockchip_usb_phy_pdata rk3188_pdata = {\n\t.phys = (struct rockchip_usb_phys[]){\n\t\t{ .reg = 0x10c, .pll_name = \"sclk_otgphy0_480m\" },\n\t\t{ .reg = 0x11c, .pll_name = \"sclk_otgphy1_480m\" },\n\t\t{   }\n\t},\n\t.init_usb_uart = rk3188_init_usb_uart,\n\t.usb_uart_phy = 0,\n};\n\n#define RK3288_UOC0_CON3\t\t\t\t0x32c\n#define RK3288_UOC0_CON3_BYPASSDMEN\t\t\tBIT(6)\n#define RK3288_UOC0_CON3_BYPASSSEL\t\t\tBIT(7)\n\n \nstatic int __init rk3288_init_usb_uart(struct regmap *grf,\n\t\t\t\tconst struct rockchip_usb_phy_pdata *pdata)\n{\n\tu32 val;\n\tint ret;\n\n\tret = rockchip_init_usb_uart_common(grf, pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tval = HIWORD_UPDATE(RK3288_UOC0_CON3_BYPASSSEL\n\t\t\t\t| RK3288_UOC0_CON3_BYPASSDMEN,\n\t\t\t    RK3288_UOC0_CON3_BYPASSSEL\n\t\t\t\t| RK3288_UOC0_CON3_BYPASSDMEN);\n\tret = regmap_write(grf, RK3288_UOC0_CON3, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct rockchip_usb_phy_pdata rk3288_pdata = {\n\t.phys = (struct rockchip_usb_phys[]){\n\t\t{ .reg = 0x320, .pll_name = \"sclk_otgphy0_480m\" },\n\t\t{ .reg = 0x334, .pll_name = \"sclk_otgphy1_480m\" },\n\t\t{ .reg = 0x348, .pll_name = \"sclk_otgphy2_480m\" },\n\t\t{   }\n\t},\n\t.init_usb_uart = rk3288_init_usb_uart,\n\t.usb_uart_phy = 0,\n};\n\nstatic int rockchip_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_usb_phy_base *phy_base;\n\tstruct phy_provider *phy_provider;\n\tconst struct of_device_id *match;\n\tstruct device_node *child;\n\tint err;\n\n\tphy_base = devm_kzalloc(dev, sizeof(*phy_base), GFP_KERNEL);\n\tif (!phy_base)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!match || !match->data) {\n\t\tdev_err(dev, \"missing phy data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tphy_base->pdata = match->data;\n\n\tphy_base->dev = dev;\n\tphy_base->reg_base = ERR_PTR(-ENODEV);\n\tif (dev->parent && dev->parent->of_node)\n\t\tphy_base->reg_base = syscon_node_to_regmap(\n\t\t\t\t\t\tdev->parent->of_node);\n\tif (IS_ERR(phy_base->reg_base))\n\t\tphy_base->reg_base = syscon_regmap_lookup_by_phandle(\n\t\t\t\t\t\tdev->of_node, \"rockchip,grf\");\n\tif (IS_ERR(phy_base->reg_base)) {\n\t\tdev_err(&pdev->dev, \"Missing rockchip,grf property\\n\");\n\t\treturn PTR_ERR(phy_base->reg_base);\n\t}\n\n\tfor_each_available_child_of_node(dev->of_node, child) {\n\t\terr = rockchip_usb_phy_init(phy_base, child);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id rockchip_usb_phy_dt_ids[] = {\n\t{ .compatible = \"rockchip,rk3066a-usb-phy\", .data = &rk3066a_pdata },\n\t{ .compatible = \"rockchip,rk3188-usb-phy\", .data = &rk3188_pdata },\n\t{ .compatible = \"rockchip,rk3288-usb-phy\", .data = &rk3288_pdata },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, rockchip_usb_phy_dt_ids);\n\nstatic struct platform_driver rockchip_usb_driver = {\n\t.probe\t\t= rockchip_usb_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"rockchip-usb-phy\",\n\t\t.of_match_table = rockchip_usb_phy_dt_ids,\n\t},\n};\n\nmodule_platform_driver(rockchip_usb_driver);\n\n#ifndef MODULE\nstatic int __init rockchip_init_usb_uart(void)\n{\n\tconst struct of_device_id *match;\n\tconst struct rockchip_usb_phy_pdata *data;\n\tstruct device_node *np;\n\tstruct regmap *grf;\n\tint ret;\n\n\tif (!enable_usb_uart)\n\t\treturn 0;\n\n\tnp = of_find_matching_node_and_match(NULL, rockchip_usb_phy_dt_ids,\n\t\t\t\t\t     &match);\n\tif (!np) {\n\t\tpr_err(\"%s: failed to find usbphy node\\n\", __func__);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tpr_debug(\"%s: using settings for %s\\n\", __func__, match->compatible);\n\tdata = match->data;\n\n\tif (!data->init_usb_uart) {\n\t\tpr_err(\"%s: usb-uart not available on %s\\n\",\n\t\t       __func__, match->compatible);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tgrf = ERR_PTR(-ENODEV);\n\tif (np->parent)\n\t\tgrf = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(grf))\n\t\tgrf = syscon_regmap_lookup_by_phandle(np, \"rockchip,grf\");\n\tif (IS_ERR(grf)) {\n\t\tpr_err(\"%s: Missing rockchip,grf property, %lu\\n\",\n\t\t       __func__, PTR_ERR(grf));\n\t\treturn PTR_ERR(grf);\n\t}\n\n\tret = data->init_usb_uart(grf, data);\n\tif (ret) {\n\t\tpr_err(\"%s: could not init usb_uart, %d\\n\", __func__, ret);\n\t\tenable_usb_uart = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nearly_initcall(rockchip_init_usb_uart);\n\nstatic int __init rockchip_usb_uart(char *buf)\n{\n\tenable_usb_uart = true;\n\treturn 0;\n}\nearly_param(\"rockchip.usb_uart\", rockchip_usb_uart);\n#endif\n\nMODULE_AUTHOR(\"Yunzhi Li <lyz@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip USB 2.0 PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}