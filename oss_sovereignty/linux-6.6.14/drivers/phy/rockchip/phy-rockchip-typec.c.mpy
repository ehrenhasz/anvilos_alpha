{
  "module_name": "phy-rockchip-typec.c",
  "hash_id": "e23e40fb69d4b4c2857e7206d68e1e58d990af44e8df58aff8bbc4085c0f26f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-typec.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/extcon.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <linux/mfd/syscon.h>\n#include <linux/phy/phy.h>\n\n#define CMN_SSM_BANDGAP\t\t\t(0x21 << 2)\n#define CMN_SSM_BIAS\t\t\t(0x22 << 2)\n#define CMN_PLLSM0_PLLEN\t\t(0x29 << 2)\n#define CMN_PLLSM0_PLLPRE\t\t(0x2a << 2)\n#define CMN_PLLSM0_PLLVREF\t\t(0x2b << 2)\n#define CMN_PLLSM0_PLLLOCK\t\t(0x2c << 2)\n#define CMN_PLLSM1_PLLEN\t\t(0x31 << 2)\n#define CMN_PLLSM1_PLLPRE\t\t(0x32 << 2)\n#define CMN_PLLSM1_PLLVREF\t\t(0x33 << 2)\n#define CMN_PLLSM1_PLLLOCK\t\t(0x34 << 2)\n#define CMN_PLLSM1_USER_DEF_CTRL\t(0x37 << 2)\n#define CMN_ICAL_OVRD\t\t\t(0xc1 << 2)\n#define CMN_PLL0_VCOCAL_OVRD\t\t(0x83 << 2)\n#define CMN_PLL0_VCOCAL_INIT\t\t(0x84 << 2)\n#define CMN_PLL0_VCOCAL_ITER\t\t(0x85 << 2)\n#define CMN_PLL0_LOCK_REFCNT_START\t(0x90 << 2)\n#define CMN_PLL0_LOCK_PLLCNT_START\t(0x92 << 2)\n#define CMN_PLL0_LOCK_PLLCNT_THR\t(0x93 << 2)\n#define CMN_PLL0_INTDIV\t\t\t(0x94 << 2)\n#define CMN_PLL0_FRACDIV\t\t(0x95 << 2)\n#define CMN_PLL0_HIGH_THR\t\t(0x96 << 2)\n#define CMN_PLL0_DSM_DIAG\t\t(0x97 << 2)\n#define CMN_PLL0_SS_CTRL1\t\t(0x98 << 2)\n#define CMN_PLL0_SS_CTRL2\t\t(0x99 << 2)\n#define CMN_PLL1_VCOCAL_START\t\t(0xa1 << 2)\n#define CMN_PLL1_VCOCAL_OVRD\t\t(0xa3 << 2)\n#define CMN_PLL1_VCOCAL_INIT\t\t(0xa4 << 2)\n#define CMN_PLL1_VCOCAL_ITER\t\t(0xa5 << 2)\n#define CMN_PLL1_LOCK_REFCNT_START\t(0xb0 << 2)\n#define CMN_PLL1_LOCK_PLLCNT_START\t(0xb2 << 2)\n#define CMN_PLL1_LOCK_PLLCNT_THR\t(0xb3 << 2)\n#define CMN_PLL1_INTDIV\t\t\t(0xb4 << 2)\n#define CMN_PLL1_FRACDIV\t\t(0xb5 << 2)\n#define CMN_PLL1_HIGH_THR\t\t(0xb6 << 2)\n#define CMN_PLL1_DSM_DIAG\t\t(0xb7 << 2)\n#define CMN_PLL1_SS_CTRL1\t\t(0xb8 << 2)\n#define CMN_PLL1_SS_CTRL2\t\t(0xb9 << 2)\n#define CMN_RXCAL_OVRD\t\t\t(0xd1 << 2)\n\n#define CMN_TXPUCAL_CTRL\t\t(0xe0 << 2)\n#define CMN_TXPUCAL_OVRD\t\t(0xe1 << 2)\n#define CMN_TXPDCAL_CTRL\t\t(0xf0 << 2)\n#define CMN_TXPDCAL_OVRD\t\t(0xf1 << 2)\n\n \n#define CMN_TXPXCAL_START\t\tBIT(15)\n#define CMN_TXPXCAL_DONE\t\tBIT(14)\n#define CMN_TXPXCAL_NO_RESPONSE\t\tBIT(13)\n#define CMN_TXPXCAL_CURRENT_RESPONSE\tBIT(12)\n\n#define CMN_TXPU_ADJ_CTRL\t\t(0x108 << 2)\n#define CMN_TXPD_ADJ_CTRL\t\t(0x10c << 2)\n\n \n#define CMN_CALIB_CODE_WIDTH\t7\n#define CMN_CALIB_CODE_OFFSET\t0\n#define CMN_CALIB_CODE_MASK\tGENMASK(CMN_CALIB_CODE_WIDTH, 0)\n#define CMN_CALIB_CODE(x)\t\\\n\tsign_extend32((x) >> CMN_CALIB_CODE_OFFSET, CMN_CALIB_CODE_WIDTH)\n\n#define CMN_CALIB_CODE_POS_MASK\tGENMASK(CMN_CALIB_CODE_WIDTH - 1, 0)\n#define CMN_CALIB_CODE_POS(x)\t\\\n\t(((x) >> CMN_CALIB_CODE_OFFSET) & CMN_CALIB_CODE_POS_MASK)\n\n#define CMN_DIAG_PLL0_FBH_OVRD\t\t(0x1c0 << 2)\n#define CMN_DIAG_PLL0_FBL_OVRD\t\t(0x1c1 << 2)\n#define CMN_DIAG_PLL0_OVRD\t\t(0x1c2 << 2)\n#define CMN_DIAG_PLL0_V2I_TUNE\t\t(0x1c5 << 2)\n#define CMN_DIAG_PLL0_CP_TUNE\t\t(0x1c6 << 2)\n#define CMN_DIAG_PLL0_LF_PROG\t\t(0x1c7 << 2)\n#define CMN_DIAG_PLL1_FBH_OVRD\t\t(0x1d0 << 2)\n#define CMN_DIAG_PLL1_FBL_OVRD\t\t(0x1d1 << 2)\n#define CMN_DIAG_PLL1_OVRD\t\t(0x1d2 << 2)\n#define CMN_DIAG_PLL1_V2I_TUNE\t\t(0x1d5 << 2)\n#define CMN_DIAG_PLL1_CP_TUNE\t\t(0x1d6 << 2)\n#define CMN_DIAG_PLL1_LF_PROG\t\t(0x1d7 << 2)\n#define CMN_DIAG_PLL1_PTATIS_TUNE1\t(0x1d8 << 2)\n#define CMN_DIAG_PLL1_PTATIS_TUNE2\t(0x1d9 << 2)\n#define CMN_DIAG_PLL1_INCLK_CTRL\t(0x1da << 2)\n#define CMN_DIAG_HSCLK_SEL\t\t(0x1e0 << 2)\n\n#define XCVR_PSM_RCTRL(n)\t\t((0x4001 | ((n) << 9)) << 2)\n#define XCVR_PSM_CAL_TMR(n)\t\t((0x4002 | ((n) << 9)) << 2)\n#define XCVR_PSM_A0IN_TMR(n)\t\t((0x4003 | ((n) << 9)) << 2)\n#define TX_TXCC_CAL_SCLR_MULT(n)\t((0x4047 | ((n) << 9)) << 2)\n#define TX_TXCC_CPOST_MULT_00(n)\t((0x404c | ((n) << 9)) << 2)\n#define TX_TXCC_CPOST_MULT_01(n)\t((0x404d | ((n) << 9)) << 2)\n#define TX_TXCC_CPOST_MULT_10(n)\t((0x404e | ((n) << 9)) << 2)\n#define TX_TXCC_CPOST_MULT_11(n)\t((0x404f | ((n) << 9)) << 2)\n#define TX_TXCC_MGNFS_MULT_000(n)\t((0x4050 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNFS_MULT_001(n)\t((0x4051 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNFS_MULT_010(n)\t((0x4052 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNFS_MULT_011(n)\t((0x4053 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNFS_MULT_100(n)\t((0x4054 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNFS_MULT_101(n)\t((0x4055 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNFS_MULT_110(n)\t((0x4056 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNFS_MULT_111(n)\t((0x4057 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNLS_MULT_000(n)\t((0x4058 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNLS_MULT_001(n)\t((0x4059 | ((n) << 9)) << 2)\n#define TX_TXCC_MGNLS_MULT_010(n)\t((0x405a | ((n) << 9)) << 2)\n#define TX_TXCC_MGNLS_MULT_011(n)\t((0x405b | ((n) << 9)) << 2)\n#define TX_TXCC_MGNLS_MULT_100(n)\t((0x405c | ((n) << 9)) << 2)\n#define TX_TXCC_MGNLS_MULT_101(n)\t((0x405d | ((n) << 9)) << 2)\n#define TX_TXCC_MGNLS_MULT_110(n)\t((0x405e | ((n) << 9)) << 2)\n#define TX_TXCC_MGNLS_MULT_111(n)\t((0x405f | ((n) << 9)) << 2)\n\n#define XCVR_DIAG_PLLDRC_CTRL(n)\t((0x40e0 | ((n) << 9)) << 2)\n#define XCVR_DIAG_BIDI_CTRL(n)\t\t((0x40e8 | ((n) << 9)) << 2)\n#define XCVR_DIAG_LANE_FCM_EN_MGN(n)\t((0x40f2 | ((n) << 9)) << 2)\n#define TX_PSC_A0(n)\t\t\t((0x4100 | ((n) << 9)) << 2)\n#define TX_PSC_A1(n)\t\t\t((0x4101 | ((n) << 9)) << 2)\n#define TX_PSC_A2(n)\t\t\t((0x4102 | ((n) << 9)) << 2)\n#define TX_PSC_A3(n)\t\t\t((0x4103 | ((n) << 9)) << 2)\n#define TX_RCVDET_CTRL(n)\t\t((0x4120 | ((n) << 9)) << 2)\n#define TX_RCVDET_EN_TMR(n)\t\t((0x4122 | ((n) << 9)) << 2)\n#define TX_RCVDET_ST_TMR(n)\t\t((0x4123 | ((n) << 9)) << 2)\n#define TX_DIAG_TX_DRV(n)\t\t((0x41e1 | ((n) << 9)) << 2)\n#define TX_DIAG_BGREF_PREDRV_DELAY\t(0x41e7 << 2)\n\n \n#define AUX_CH_LANE\t\t\t8\n\n#define TX_ANA_CTRL_REG_1\t\t(0x5020 << 2)\n\n#define TXDA_DP_AUX_EN\t\t\tBIT(15)\n#define AUXDA_SE_EN\t\t\tBIT(14)\n#define TXDA_CAL_LATCH_EN\t\tBIT(13)\n#define AUXDA_POLARITY\t\t\tBIT(12)\n#define TXDA_DRV_POWER_ISOLATION_EN\tBIT(11)\n#define TXDA_DRV_POWER_EN_PH_2_N\tBIT(10)\n#define TXDA_DRV_POWER_EN_PH_1_N\tBIT(9)\n#define TXDA_BGREF_EN\t\t\tBIT(8)\n#define TXDA_DRV_LDO_EN\t\t\tBIT(7)\n#define TXDA_DECAP_EN_DEL\t\tBIT(6)\n#define TXDA_DECAP_EN\t\t\tBIT(5)\n#define TXDA_UPHY_SUPPLY_EN_DEL\t\tBIT(4)\n#define TXDA_UPHY_SUPPLY_EN\t\tBIT(3)\n#define TXDA_LOW_LEAKAGE_EN\t\tBIT(2)\n#define TXDA_DRV_IDLE_LOWI_EN\t\tBIT(1)\n#define TXDA_DRV_CMN_MODE_EN\t\tBIT(0)\n\n#define TX_ANA_CTRL_REG_2\t\t(0x5021 << 2)\n\n#define AUXDA_DEBOUNCING_CLK\t\tBIT(15)\n#define TXDA_LPBK_RECOVERED_CLK_EN\tBIT(14)\n#define TXDA_LPBK_ISI_GEN_EN\t\tBIT(13)\n#define TXDA_LPBK_SERIAL_EN\t\tBIT(12)\n#define TXDA_LPBK_LINE_EN\t\tBIT(11)\n#define TXDA_DRV_LDO_REDC_SINKIQ\tBIT(10)\n#define XCVR_DECAP_EN_DEL\t\tBIT(9)\n#define XCVR_DECAP_EN\t\t\tBIT(8)\n#define TXDA_MPHY_ENABLE_HS_NT\t\tBIT(7)\n#define TXDA_MPHY_SA_MODE\t\tBIT(6)\n#define TXDA_DRV_LDO_RBYR_FB_EN\t\tBIT(5)\n#define TXDA_DRV_RST_PULL_DOWN\t\tBIT(4)\n#define TXDA_DRV_LDO_BG_FB_EN\t\tBIT(3)\n#define TXDA_DRV_LDO_BG_REF_EN\t\tBIT(2)\n#define TXDA_DRV_PREDRV_EN_DEL\t\tBIT(1)\n#define TXDA_DRV_PREDRV_EN\t\tBIT(0)\n\n#define TXDA_COEFF_CALC_CTRL\t\t(0x5022 << 2)\n\n#define TX_HIGH_Z\t\t\tBIT(6)\n#define TX_VMARGIN_OFFSET\t\t3\n#define TX_VMARGIN_MASK\t\t\t0x7\n#define LOW_POWER_SWING_EN\t\tBIT(2)\n#define TX_FCM_DRV_MAIN_EN\t\tBIT(1)\n#define TX_FCM_FULL_MARGIN\t\tBIT(0)\n\n#define TX_DIG_CTRL_REG_2\t\t(0x5024 << 2)\n\n#define TX_HIGH_Z_TM_EN\t\t\tBIT(15)\n#define TX_RESCAL_CODE_OFFSET\t\t0\n#define TX_RESCAL_CODE_MASK\t\t0x3f\n\n#define TXDA_CYA_AUXDA_CYA\t\t(0x5025 << 2)\n#define TX_ANA_CTRL_REG_3\t\t(0x5026 << 2)\n#define TX_ANA_CTRL_REG_4\t\t(0x5027 << 2)\n#define TX_ANA_CTRL_REG_5\t\t(0x5029 << 2)\n\n#define RX_PSC_A0(n)\t\t\t((0x8000 | ((n) << 9)) << 2)\n#define RX_PSC_A1(n)\t\t\t((0x8001 | ((n) << 9)) << 2)\n#define RX_PSC_A2(n)\t\t\t((0x8002 | ((n) << 9)) << 2)\n#define RX_PSC_A3(n)\t\t\t((0x8003 | ((n) << 9)) << 2)\n#define RX_PSC_CAL(n)\t\t\t((0x8006 | ((n) << 9)) << 2)\n#define RX_PSC_RDY(n)\t\t\t((0x8007 | ((n) << 9)) << 2)\n#define RX_IQPI_ILL_CAL_OVRD\t\t(0x8023 << 2)\n#define RX_EPI_ILL_CAL_OVRD\t\t(0x8033 << 2)\n#define RX_SDCAL0_OVRD\t\t\t(0x8041 << 2)\n#define RX_SDCAL1_OVRD\t\t\t(0x8049 << 2)\n#define RX_SLC_INIT\t\t\t(0x806d << 2)\n#define RX_SLC_RUN\t\t\t(0x806e << 2)\n#define RX_CDRLF_CNFG2\t\t\t(0x8081 << 2)\n#define RX_SIGDET_HL_FILT_TMR(n)\t((0x8090 | ((n) << 9)) << 2)\n#define RX_SLC_IOP0_OVRD\t\t(0x8101 << 2)\n#define RX_SLC_IOP1_OVRD\t\t(0x8105 << 2)\n#define RX_SLC_QOP0_OVRD\t\t(0x8109 << 2)\n#define RX_SLC_QOP1_OVRD\t\t(0x810d << 2)\n#define RX_SLC_EOP0_OVRD\t\t(0x8111 << 2)\n#define RX_SLC_EOP1_OVRD\t\t(0x8115 << 2)\n#define RX_SLC_ION0_OVRD\t\t(0x8119 << 2)\n#define RX_SLC_ION1_OVRD\t\t(0x811d << 2)\n#define RX_SLC_QON0_OVRD\t\t(0x8121 << 2)\n#define RX_SLC_QON1_OVRD\t\t(0x8125 << 2)\n#define RX_SLC_EON0_OVRD\t\t(0x8129 << 2)\n#define RX_SLC_EON1_OVRD\t\t(0x812d << 2)\n#define RX_SLC_IEP0_OVRD\t\t(0x8131 << 2)\n#define RX_SLC_IEP1_OVRD\t\t(0x8135 << 2)\n#define RX_SLC_QEP0_OVRD\t\t(0x8139 << 2)\n#define RX_SLC_QEP1_OVRD\t\t(0x813d << 2)\n#define RX_SLC_EEP0_OVRD\t\t(0x8141 << 2)\n#define RX_SLC_EEP1_OVRD\t\t(0x8145 << 2)\n#define RX_SLC_IEN0_OVRD\t\t(0x8149 << 2)\n#define RX_SLC_IEN1_OVRD\t\t(0x814d << 2)\n#define RX_SLC_QEN0_OVRD\t\t(0x8151 << 2)\n#define RX_SLC_QEN1_OVRD\t\t(0x8155 << 2)\n#define RX_SLC_EEN0_OVRD\t\t(0x8159 << 2)\n#define RX_SLC_EEN1_OVRD\t\t(0x815d << 2)\n#define RX_REE_CTRL_DATA_MASK(n)\t((0x81bb | ((n) << 9)) << 2)\n#define RX_DIAG_SIGDET_TUNE(n)\t\t((0x81dc | ((n) << 9)) << 2)\n#define RX_DIAG_SC2C_DELAY\t\t(0x81e1 << 2)\n\n#define PMA_LANE_CFG\t\t\t(0xc000 << 2)\n#define PIPE_CMN_CTRL1\t\t\t(0xc001 << 2)\n#define PIPE_CMN_CTRL2\t\t\t(0xc002 << 2)\n#define PIPE_COM_LOCK_CFG1\t\t(0xc003 << 2)\n#define PIPE_COM_LOCK_CFG2\t\t(0xc004 << 2)\n#define PIPE_RCV_DET_INH\t\t(0xc005 << 2)\n#define DP_MODE_CTL\t\t\t(0xc008 << 2)\n#define DP_CLK_CTL\t\t\t(0xc009 << 2)\n#define STS\t\t\t\t(0xc00F << 2)\n#define PHY_ISO_CMN_CTRL\t\t(0xc010 << 2)\n#define PHY_DP_TX_CTL\t\t\t(0xc408 << 2)\n#define PMA_CMN_CTRL1\t\t\t(0xc800 << 2)\n#define PHY_PMA_ISO_CMN_CTRL\t\t(0xc810 << 2)\n#define PHY_ISOLATION_CTRL\t\t(0xc81f << 2)\n#define PHY_PMA_ISO_XCVR_CTRL(n)\t((0xcc11 | ((n) << 6)) << 2)\n#define PHY_PMA_ISO_LINK_MODE(n)\t((0xcc12 | ((n) << 6)) << 2)\n#define PHY_PMA_ISO_PWRST_CTRL(n)\t((0xcc13 | ((n) << 6)) << 2)\n#define PHY_PMA_ISO_TX_DATA_LO(n)\t((0xcc14 | ((n) << 6)) << 2)\n#define PHY_PMA_ISO_TX_DATA_HI(n)\t((0xcc15 | ((n) << 6)) << 2)\n#define PHY_PMA_ISO_RX_DATA_LO(n)\t((0xcc16 | ((n) << 6)) << 2)\n#define PHY_PMA_ISO_RX_DATA_HI(n)\t((0xcc17 | ((n) << 6)) << 2)\n#define TX_BIST_CTRL(n)\t\t\t((0x4140 | ((n) << 9)) << 2)\n#define TX_BIST_UDDWR(n)\t\t((0x4141 | ((n) << 9)) << 2)\n\n \n#define CLK_PLL_CONFIG\t\t\t0X30\n#define CLK_PLL_MASK\t\t\t0x33\n\n#define CMN_READY\t\t\tBIT(0)\n\n#define DP_PLL_CLOCK_ENABLE\t\tBIT(2)\n#define DP_PLL_ENABLE\t\t\tBIT(0)\n#define DP_PLL_DATA_RATE_RBR\t\t((2 << 12) | (4 << 8))\n#define DP_PLL_DATA_RATE_HBR\t\t((2 << 12) | (4 << 8))\n#define DP_PLL_DATA_RATE_HBR2\t\t((1 << 12) | (2 << 8))\n\n#define DP_MODE_A0\t\t\tBIT(4)\n#define DP_MODE_A2\t\t\tBIT(6)\n#define DP_MODE_ENTER_A0\t\t0xc101\n#define DP_MODE_ENTER_A2\t\t0xc104\n\n#define PHY_MODE_SET_TIMEOUT\t\t100000\n\n#define PIN_ASSIGN_C_E\t\t\t0x51d9\n#define PIN_ASSIGN_D_F\t\t\t0x5100\n\n#define MODE_DISCONNECT\t\t\t0\n#define MODE_UFP_USB\t\t\tBIT(0)\n#define MODE_DFP_USB\t\t\tBIT(1)\n#define MODE_DFP_DP\t\t\tBIT(2)\n\nstruct usb3phy_reg {\n\tu32 offset;\n\tu32 enable_bit;\n\tu32 write_enable;\n};\n\n \nstruct rockchip_usb3phy_port_cfg {\n\tunsigned int reg;\n\tstruct usb3phy_reg typec_conn_dir;\n\tstruct usb3phy_reg usb3tousb2_en;\n\tstruct usb3phy_reg external_psm;\n\tstruct usb3phy_reg pipe_status;\n\tstruct usb3phy_reg usb3_host_disable;\n\tstruct usb3phy_reg usb3_host_port;\n\tstruct usb3phy_reg uphy_dp_sel;\n};\n\nstruct rockchip_typec_phy {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct extcon_dev *extcon;\n\tstruct regmap *grf_regs;\n\tstruct clk *clk_core;\n\tstruct clk *clk_ref;\n\tstruct reset_control *uphy_rst;\n\tstruct reset_control *pipe_rst;\n\tstruct reset_control *tcphy_rst;\n\tconst struct rockchip_usb3phy_port_cfg *port_cfgs;\n\t \n\tstruct mutex lock;\n\n\tbool flip;\n\tu8 mode;\n};\n\nstruct phy_reg {\n\tu16 value;\n\tu32 addr;\n};\n\nstatic struct phy_reg usb3_pll_cfg[] = {\n\t{ 0xf0,\t\tCMN_PLL0_VCOCAL_INIT },\n\t{ 0x18,\t\tCMN_PLL0_VCOCAL_ITER },\n\t{ 0xd0,\t\tCMN_PLL0_INTDIV },\n\t{ 0x4a4a,\tCMN_PLL0_FRACDIV },\n\t{ 0x34,\t\tCMN_PLL0_HIGH_THR },\n\t{ 0x1ee,\tCMN_PLL0_SS_CTRL1 },\n\t{ 0x7f03,\tCMN_PLL0_SS_CTRL2 },\n\t{ 0x20,\t\tCMN_PLL0_DSM_DIAG },\n\t{ 0,\t\tCMN_DIAG_PLL0_OVRD },\n\t{ 0,\t\tCMN_DIAG_PLL0_FBH_OVRD },\n\t{ 0,\t\tCMN_DIAG_PLL0_FBL_OVRD },\n\t{ 0x7,\t\tCMN_DIAG_PLL0_V2I_TUNE },\n\t{ 0x45,\t\tCMN_DIAG_PLL0_CP_TUNE },\n\t{ 0x8,\t\tCMN_DIAG_PLL0_LF_PROG },\n};\n\nstatic struct phy_reg dp_pll_cfg[] = {\n\t{ 0xf0,\t\tCMN_PLL1_VCOCAL_INIT },\n\t{ 0x18,\t\tCMN_PLL1_VCOCAL_ITER },\n\t{ 0x30b9,\tCMN_PLL1_VCOCAL_START },\n\t{ 0x21c,\tCMN_PLL1_INTDIV },\n\t{ 0,\t\tCMN_PLL1_FRACDIV },\n\t{ 0x5,\t\tCMN_PLL1_HIGH_THR },\n\t{ 0x35,\t\tCMN_PLL1_SS_CTRL1 },\n\t{ 0x7f1e,\tCMN_PLL1_SS_CTRL2 },\n\t{ 0x20,\t\tCMN_PLL1_DSM_DIAG },\n\t{ 0,\t\tCMN_PLLSM1_USER_DEF_CTRL },\n\t{ 0,\t\tCMN_DIAG_PLL1_OVRD },\n\t{ 0,\t\tCMN_DIAG_PLL1_FBH_OVRD },\n\t{ 0,\t\tCMN_DIAG_PLL1_FBL_OVRD },\n\t{ 0x6,\t\tCMN_DIAG_PLL1_V2I_TUNE },\n\t{ 0x45,\t\tCMN_DIAG_PLL1_CP_TUNE },\n\t{ 0x8,\t\tCMN_DIAG_PLL1_LF_PROG },\n\t{ 0x100,\tCMN_DIAG_PLL1_PTATIS_TUNE1 },\n\t{ 0x7,\t\tCMN_DIAG_PLL1_PTATIS_TUNE2 },\n\t{ 0x4,\t\tCMN_DIAG_PLL1_INCLK_CTRL },\n};\n\nstatic const struct rockchip_usb3phy_port_cfg rk3399_usb3phy_port_cfgs[] = {\n\t{\n\t\t.reg = 0xff7c0000,\n\t\t.typec_conn_dir\t= { 0xe580, 0, 16 },\n\t\t.usb3tousb2_en\t= { 0xe580, 3, 19 },\n\t\t.external_psm\t= { 0xe588, 14, 30 },\n\t\t.pipe_status\t= { 0xe5c0, 0, 0 },\n\t\t.usb3_host_disable = { 0x2434, 0, 16 },\n\t\t.usb3_host_port = { 0x2434, 12, 28 },\n\t\t.uphy_dp_sel\t= { 0x6268, 19, 19 },\n\t},\n\t{\n\t\t.reg = 0xff800000,\n\t\t.typec_conn_dir\t= { 0xe58c, 0, 16 },\n\t\t.usb3tousb2_en\t= { 0xe58c, 3, 19 },\n\t\t.external_psm\t= { 0xe594, 14, 30 },\n\t\t.pipe_status\t= { 0xe5c0, 16, 16 },\n\t\t.usb3_host_disable = { 0x2444, 0, 16 },\n\t\t.usb3_host_port = { 0x2444, 12, 28 },\n\t\t.uphy_dp_sel\t= { 0x6268, 3, 19 },\n\t},\n\t{   }\n};\n\nstatic void tcphy_cfg_24m(struct rockchip_typec_phy *tcphy)\n{\n\tu32 i, rdata;\n\n\t \n\twritel(0x830, tcphy->base + PMA_CMN_CTRL1);\n\tfor (i = 0; i < 4; i++) {\n\t\t \n\t\twritel(0x90, tcphy->base + XCVR_DIAG_LANE_FCM_EN_MGN(i));\n\t\twritel(0x960, tcphy->base + TX_RCVDET_EN_TMR(i));\n\t\twritel(0x30, tcphy->base + TX_RCVDET_ST_TMR(i));\n\t}\n\n\trdata = readl(tcphy->base + CMN_DIAG_HSCLK_SEL);\n\trdata &= ~CLK_PLL_MASK;\n\trdata |= CLK_PLL_CONFIG;\n\twritel(rdata, tcphy->base + CMN_DIAG_HSCLK_SEL);\n}\n\nstatic void tcphy_cfg_usb3_pll(struct rockchip_typec_phy *tcphy)\n{\n\tu32 i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(usb3_pll_cfg); i++)\n\t\twritel(usb3_pll_cfg[i].value,\n\t\t       tcphy->base + usb3_pll_cfg[i].addr);\n}\n\nstatic void tcphy_cfg_dp_pll(struct rockchip_typec_phy *tcphy)\n{\n\tu32 i;\n\n\t \n\twritel(DP_PLL_CLOCK_ENABLE | DP_PLL_ENABLE | DP_PLL_DATA_RATE_RBR,\n\t       tcphy->base + DP_CLK_CTL);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dp_pll_cfg); i++)\n\t\twritel(dp_pll_cfg[i].value, tcphy->base + dp_pll_cfg[i].addr);\n}\n\nstatic void tcphy_tx_usb3_cfg_lane(struct rockchip_typec_phy *tcphy, u32 lane)\n{\n\twritel(0x7799, tcphy->base + TX_PSC_A0(lane));\n\twritel(0x7798, tcphy->base + TX_PSC_A1(lane));\n\twritel(0x5098, tcphy->base + TX_PSC_A2(lane));\n\twritel(0x5098, tcphy->base + TX_PSC_A3(lane));\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_000(lane));\n\twritel(0xbf, tcphy->base + XCVR_DIAG_BIDI_CTRL(lane));\n}\n\nstatic void tcphy_rx_usb3_cfg_lane(struct rockchip_typec_phy *tcphy, u32 lane)\n{\n\twritel(0xa6fd, tcphy->base + RX_PSC_A0(lane));\n\twritel(0xa6fd, tcphy->base + RX_PSC_A1(lane));\n\twritel(0xa410, tcphy->base + RX_PSC_A2(lane));\n\twritel(0x2410, tcphy->base + RX_PSC_A3(lane));\n\twritel(0x23ff, tcphy->base + RX_PSC_CAL(lane));\n\twritel(0x13, tcphy->base + RX_SIGDET_HL_FILT_TMR(lane));\n\twritel(0x03e7, tcphy->base + RX_REE_CTRL_DATA_MASK(lane));\n\twritel(0x1004, tcphy->base + RX_DIAG_SIGDET_TUNE(lane));\n\twritel(0x2010, tcphy->base + RX_PSC_RDY(lane));\n\twritel(0xfb, tcphy->base + XCVR_DIAG_BIDI_CTRL(lane));\n}\n\nstatic void tcphy_dp_cfg_lane(struct rockchip_typec_phy *tcphy, u32 lane)\n{\n\tu16 rdata;\n\n\twritel(0xbefc, tcphy->base + XCVR_PSM_RCTRL(lane));\n\twritel(0x6799, tcphy->base + TX_PSC_A0(lane));\n\twritel(0x6798, tcphy->base + TX_PSC_A1(lane));\n\twritel(0x98, tcphy->base + TX_PSC_A2(lane));\n\twritel(0x98, tcphy->base + TX_PSC_A3(lane));\n\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_000(lane));\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_001(lane));\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_010(lane));\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_011(lane));\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_100(lane));\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_101(lane));\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_110(lane));\n\twritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_111(lane));\n\twritel(0, tcphy->base + TX_TXCC_CPOST_MULT_10(lane));\n\twritel(0, tcphy->base + TX_TXCC_CPOST_MULT_01(lane));\n\twritel(0, tcphy->base + TX_TXCC_CPOST_MULT_00(lane));\n\twritel(0, tcphy->base + TX_TXCC_CPOST_MULT_11(lane));\n\n\twritel(0x128, tcphy->base + TX_TXCC_CAL_SCLR_MULT(lane));\n\twritel(0x400, tcphy->base + TX_DIAG_TX_DRV(lane));\n\n\trdata = readl(tcphy->base + XCVR_DIAG_PLLDRC_CTRL(lane));\n\trdata = (rdata & 0x8fff) | 0x6000;\n\twritel(rdata, tcphy->base + XCVR_DIAG_PLLDRC_CTRL(lane));\n}\n\nstatic inline int property_enable(struct rockchip_typec_phy *tcphy,\n\t\t\t\t  const struct usb3phy_reg *reg, bool en)\n{\n\tu32 mask = 1 << reg->write_enable;\n\tu32 val = en << reg->enable_bit;\n\n\treturn regmap_write(tcphy->grf_regs, reg->offset, val | mask);\n}\n\nstatic void tcphy_dp_aux_set_flip(struct rockchip_typec_phy *tcphy)\n{\n\tu16 tx_ana_ctrl_reg_1;\n\n\t \n\ttx_ana_ctrl_reg_1 = readl(tcphy->base + TX_ANA_CTRL_REG_1);\n\tif (!tcphy->flip)\n\t\ttx_ana_ctrl_reg_1 |= AUXDA_POLARITY;\n\telse\n\t\ttx_ana_ctrl_reg_1 &= ~AUXDA_POLARITY;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n}\n\nstatic void tcphy_dp_aux_calibration(struct rockchip_typec_phy *tcphy)\n{\n\tu16 val;\n\tu16 tx_ana_ctrl_reg_1;\n\tu16 tx_ana_ctrl_reg_2;\n\ts32 pu_calib_code, pd_calib_code;\n\ts32 pu_adj, pd_adj;\n\tu16 calib;\n\n\t \n\tval = readl(tcphy->base + CMN_TXPUCAL_CTRL);\n\tpu_calib_code = CMN_CALIB_CODE_POS(val);\n\tval = readl(tcphy->base + CMN_TXPDCAL_CTRL);\n\tpd_calib_code = CMN_CALIB_CODE_POS(val);\n\tval = readl(tcphy->base + CMN_TXPU_ADJ_CTRL);\n\tpu_adj = CMN_CALIB_CODE(val);\n\tval = readl(tcphy->base + CMN_TXPD_ADJ_CTRL);\n\tpd_adj = CMN_CALIB_CODE(val);\n\tcalib = (pu_calib_code + pd_calib_code) / 2 + pu_adj + pd_adj;\n\n\t \n\ttx_ana_ctrl_reg_1 = readl(tcphy->base + TX_ANA_CTRL_REG_1);\n\ttx_ana_ctrl_reg_1 &= ~TXDA_CAL_LATCH_EN;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n\n\t \n\tval = readl(tcphy->base + TX_DIG_CTRL_REG_2);\n\tval &= ~(TX_RESCAL_CODE_MASK << TX_RESCAL_CODE_OFFSET);\n\tval |= calib << TX_RESCAL_CODE_OFFSET;\n\twritel(val, tcphy->base + TX_DIG_CTRL_REG_2);\n\tusleep_range(10000, 10050);\n\n\t \n\ttx_ana_ctrl_reg_1 |= TXDA_CAL_LATCH_EN;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n\tusleep_range(150, 200);\n\n\t \n\twritel(0, tcphy->base + PHY_DP_TX_CTL);\n\n\t \n\ttx_ana_ctrl_reg_2 = XCVR_DECAP_EN;\n\twritel(tx_ana_ctrl_reg_2, tcphy->base + TX_ANA_CTRL_REG_2);\n\tudelay(1);\n\ttx_ana_ctrl_reg_2 |= XCVR_DECAP_EN_DEL;\n\twritel(tx_ana_ctrl_reg_2, tcphy->base + TX_ANA_CTRL_REG_2);\n\n\twritel(0, tcphy->base + TX_ANA_CTRL_REG_3);\n\n\ttx_ana_ctrl_reg_1 |= TXDA_UPHY_SUPPLY_EN;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n\tudelay(1);\n\ttx_ana_ctrl_reg_1 |= TXDA_UPHY_SUPPLY_EN_DEL;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n\n\twritel(0, tcphy->base + TX_ANA_CTRL_REG_5);\n\n\t \n\twritel(0x1001, tcphy->base + TX_ANA_CTRL_REG_4);\n\n\t \n\ttx_ana_ctrl_reg_1 |= TXDA_DRV_LDO_EN;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n\tudelay(5);\n\ttx_ana_ctrl_reg_1 |= TXDA_BGREF_EN;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n\n\t \n\ttx_ana_ctrl_reg_2 |= TXDA_DRV_PREDRV_EN;\n\twritel(tx_ana_ctrl_reg_2, tcphy->base + TX_ANA_CTRL_REG_2);\n\tudelay(1);\n\ttx_ana_ctrl_reg_2 |= TXDA_DRV_PREDRV_EN_DEL;\n\twritel(tx_ana_ctrl_reg_2, tcphy->base + TX_ANA_CTRL_REG_2);\n\n\t \n\ttx_ana_ctrl_reg_1 |= TXDA_DP_AUX_EN;\n\ttx_ana_ctrl_reg_1 |= TXDA_DECAP_EN;\n\ttx_ana_ctrl_reg_1 &= ~TXDA_DRV_LDO_EN;\n\ttx_ana_ctrl_reg_1 &= ~TXDA_BGREF_EN;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n\tudelay(1);\n\ttx_ana_ctrl_reg_1 |= TXDA_DECAP_EN_DEL;\n\twritel(tx_ana_ctrl_reg_1, tcphy->base + TX_ANA_CTRL_REG_1);\n\n\t \n\twritel(0, tcphy->base + TX_ANA_CTRL_REG_4);\n\n\t \n\twritel(0, tcphy->base + TXDA_COEFF_CALC_CTRL);\n\n\t \n\twritel(0, tcphy->base + TXDA_CYA_AUXDA_CYA);\n\n\t \n\tval = readl(tcphy->base + TX_DIG_CTRL_REG_2);\n\tval |= TX_HIGH_Z_TM_EN;\n\twritel(val, tcphy->base + TX_DIG_CTRL_REG_2);\n}\n\nstatic int tcphy_phy_init(struct rockchip_typec_phy *tcphy, u8 mode)\n{\n\tconst struct rockchip_usb3phy_port_cfg *cfg = tcphy->port_cfgs;\n\tint ret, i;\n\tu32 val;\n\n\tret = clk_prepare_enable(tcphy->clk_core);\n\tif (ret) {\n\t\tdev_err(tcphy->dev, \"Failed to prepare_enable core clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(tcphy->clk_ref);\n\tif (ret) {\n\t\tdev_err(tcphy->dev, \"Failed to prepare_enable ref clock\\n\");\n\t\tgoto err_clk_core;\n\t}\n\n\treset_control_deassert(tcphy->tcphy_rst);\n\n\tproperty_enable(tcphy, &cfg->typec_conn_dir, tcphy->flip);\n\ttcphy_dp_aux_set_flip(tcphy);\n\n\ttcphy_cfg_24m(tcphy);\n\n\tif (mode == MODE_DFP_DP) {\n\t\ttcphy_cfg_dp_pll(tcphy);\n\t\tfor (i = 0; i < 4; i++)\n\t\t\ttcphy_dp_cfg_lane(tcphy, i);\n\n\t\twritel(PIN_ASSIGN_C_E, tcphy->base + PMA_LANE_CFG);\n\t} else {\n\t\ttcphy_cfg_usb3_pll(tcphy);\n\t\ttcphy_cfg_dp_pll(tcphy);\n\t\tif (tcphy->flip) {\n\t\t\ttcphy_tx_usb3_cfg_lane(tcphy, 3);\n\t\t\ttcphy_rx_usb3_cfg_lane(tcphy, 2);\n\t\t\ttcphy_dp_cfg_lane(tcphy, 0);\n\t\t\ttcphy_dp_cfg_lane(tcphy, 1);\n\t\t} else {\n\t\t\ttcphy_tx_usb3_cfg_lane(tcphy, 0);\n\t\t\ttcphy_rx_usb3_cfg_lane(tcphy, 1);\n\t\t\ttcphy_dp_cfg_lane(tcphy, 2);\n\t\t\ttcphy_dp_cfg_lane(tcphy, 3);\n\t\t}\n\n\t\twritel(PIN_ASSIGN_D_F, tcphy->base + PMA_LANE_CFG);\n\t}\n\n\twritel(DP_MODE_ENTER_A2, tcphy->base + DP_MODE_CTL);\n\n\treset_control_deassert(tcphy->uphy_rst);\n\n\tret = readx_poll_timeout(readl, tcphy->base + PMA_CMN_CTRL1,\n\t\t\t\t val, val & CMN_READY, 10,\n\t\t\t\t PHY_MODE_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(tcphy->dev, \"wait pma ready timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_wait_pma;\n\t}\n\n\treset_control_deassert(tcphy->pipe_rst);\n\n\treturn 0;\n\nerr_wait_pma:\n\treset_control_assert(tcphy->uphy_rst);\n\treset_control_assert(tcphy->tcphy_rst);\n\tclk_disable_unprepare(tcphy->clk_ref);\nerr_clk_core:\n\tclk_disable_unprepare(tcphy->clk_core);\n\treturn ret;\n}\n\nstatic void tcphy_phy_deinit(struct rockchip_typec_phy *tcphy)\n{\n\treset_control_assert(tcphy->tcphy_rst);\n\treset_control_assert(tcphy->uphy_rst);\n\treset_control_assert(tcphy->pipe_rst);\n\tclk_disable_unprepare(tcphy->clk_core);\n\tclk_disable_unprepare(tcphy->clk_ref);\n}\n\nstatic int tcphy_get_mode(struct rockchip_typec_phy *tcphy)\n{\n\tstruct extcon_dev *edev = tcphy->extcon;\n\tunion extcon_property_value property;\n\tunsigned int id;\n\tu8 mode;\n\tint ret, ufp, dp;\n\n\tif (!edev)\n\t\treturn MODE_DFP_USB;\n\n\tufp = extcon_get_state(edev, EXTCON_USB);\n\tdp = extcon_get_state(edev, EXTCON_DISP_DP);\n\n\tmode = MODE_DFP_USB;\n\tid = EXTCON_USB_HOST;\n\n\tif (ufp > 0) {\n\t\tmode = MODE_UFP_USB;\n\t\tid = EXTCON_USB;\n\t} else if (dp > 0) {\n\t\tmode = MODE_DFP_DP;\n\t\tid = EXTCON_DISP_DP;\n\n\t\tret = extcon_get_property(edev, id, EXTCON_PROP_USB_SS,\n\t\t\t\t\t  &property);\n\t\tif (ret) {\n\t\t\tdev_err(tcphy->dev, \"get superspeed property failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (property.intval)\n\t\t\tmode |= MODE_DFP_USB;\n\t}\n\n\tret = extcon_get_property(edev, id, EXTCON_PROP_USB_TYPEC_POLARITY,\n\t\t\t\t  &property);\n\tif (ret) {\n\t\tdev_err(tcphy->dev, \"get polarity property failed\\n\");\n\t\treturn ret;\n\t}\n\n\ttcphy->flip = property.intval ? 1 : 0;\n\n\treturn mode;\n}\n\nstatic int tcphy_cfg_usb3_to_usb2_only(struct rockchip_typec_phy *tcphy,\n\t\t\t\t       bool value)\n{\n\tconst struct rockchip_usb3phy_port_cfg *cfg = tcphy->port_cfgs;\n\n\tproperty_enable(tcphy, &cfg->usb3tousb2_en, value);\n\tproperty_enable(tcphy, &cfg->usb3_host_disable, value);\n\tproperty_enable(tcphy, &cfg->usb3_host_port, !value);\n\n\treturn 0;\n}\n\nstatic int rockchip_usb3_phy_power_on(struct phy *phy)\n{\n\tstruct rockchip_typec_phy *tcphy = phy_get_drvdata(phy);\n\tconst struct rockchip_usb3phy_port_cfg *cfg = tcphy->port_cfgs;\n\tconst struct usb3phy_reg *reg = &cfg->pipe_status;\n\tint timeout, new_mode, ret = 0;\n\tu32 val;\n\n\tmutex_lock(&tcphy->lock);\n\n\tnew_mode = tcphy_get_mode(tcphy);\n\tif (new_mode < 0) {\n\t\tret = new_mode;\n\t\tgoto unlock_ret;\n\t}\n\n\t \n\tif (!(new_mode & (MODE_DFP_USB | MODE_UFP_USB))) {\n\t\ttcphy_cfg_usb3_to_usb2_only(tcphy, true);\n\t\tgoto unlock_ret;\n\t}\n\n\tif (tcphy->mode == new_mode)\n\t\tgoto unlock_ret;\n\n\tif (tcphy->mode == MODE_DISCONNECT) {\n\t\tret = tcphy_phy_init(tcphy, new_mode);\n\t\tif (ret)\n\t\t\tgoto unlock_ret;\n\t}\n\n\t \n\tfor (timeout = 0; timeout < 100; timeout++) {\n\t\tregmap_read(tcphy->grf_regs, reg->offset, &val);\n\t\tif (!(val & BIT(reg->enable_bit))) {\n\t\t\ttcphy->mode |= new_mode & (MODE_DFP_USB | MODE_UFP_USB);\n\n\t\t\t \n\t\t\ttcphy_cfg_usb3_to_usb2_only(tcphy, false);\n\t\t\tgoto unlock_ret;\n\t\t}\n\t\tusleep_range(10, 20);\n\t}\n\n\tif (tcphy->mode == MODE_DISCONNECT)\n\t\ttcphy_phy_deinit(tcphy);\n\n\tret = -ETIMEDOUT;\n\nunlock_ret:\n\tmutex_unlock(&tcphy->lock);\n\treturn ret;\n}\n\nstatic int rockchip_usb3_phy_power_off(struct phy *phy)\n{\n\tstruct rockchip_typec_phy *tcphy = phy_get_drvdata(phy);\n\n\tmutex_lock(&tcphy->lock);\n\ttcphy_cfg_usb3_to_usb2_only(tcphy, false);\n\n\tif (tcphy->mode == MODE_DISCONNECT)\n\t\tgoto unlock;\n\n\ttcphy->mode &= ~(MODE_UFP_USB | MODE_DFP_USB);\n\tif (tcphy->mode == MODE_DISCONNECT)\n\t\ttcphy_phy_deinit(tcphy);\n\nunlock:\n\tmutex_unlock(&tcphy->lock);\n\treturn 0;\n}\n\nstatic const struct phy_ops rockchip_usb3_phy_ops = {\n\t.power_on\t= rockchip_usb3_phy_power_on,\n\t.power_off\t= rockchip_usb3_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int rockchip_dp_phy_power_on(struct phy *phy)\n{\n\tstruct rockchip_typec_phy *tcphy = phy_get_drvdata(phy);\n\tconst struct rockchip_usb3phy_port_cfg *cfg = tcphy->port_cfgs;\n\tint new_mode, ret = 0;\n\tu32 val;\n\n\tmutex_lock(&tcphy->lock);\n\n\tnew_mode = tcphy_get_mode(tcphy);\n\tif (new_mode < 0) {\n\t\tret = new_mode;\n\t\tgoto unlock_ret;\n\t}\n\n\tif (!(new_mode & MODE_DFP_DP)) {\n\t\tret = -ENODEV;\n\t\tgoto unlock_ret;\n\t}\n\n\tif (tcphy->mode == new_mode)\n\t\tgoto unlock_ret;\n\n\t \n\tif (new_mode == MODE_DFP_DP && tcphy->mode != MODE_DISCONNECT) {\n\t\ttcphy_phy_deinit(tcphy);\n\t\tret = tcphy_phy_init(tcphy, new_mode);\n\t} else if (tcphy->mode == MODE_DISCONNECT) {\n\t\tret = tcphy_phy_init(tcphy, new_mode);\n\t}\n\tif (ret)\n\t\tgoto unlock_ret;\n\n\tproperty_enable(tcphy, &cfg->uphy_dp_sel, 1);\n\n\tret = readx_poll_timeout(readl, tcphy->base + DP_MODE_CTL,\n\t\t\t\t val, val & DP_MODE_A2, 1000,\n\t\t\t\t PHY_MODE_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(tcphy->dev, \"failed to wait TCPHY enter A2\\n\");\n\t\tgoto power_on_finish;\n\t}\n\n\ttcphy_dp_aux_calibration(tcphy);\n\n\twritel(DP_MODE_ENTER_A0, tcphy->base + DP_MODE_CTL);\n\n\tret = readx_poll_timeout(readl, tcphy->base + DP_MODE_CTL,\n\t\t\t\t val, val & DP_MODE_A0, 1000,\n\t\t\t\t PHY_MODE_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\twritel(DP_MODE_ENTER_A2, tcphy->base + DP_MODE_CTL);\n\t\tdev_err(tcphy->dev, \"failed to wait TCPHY enter A0\\n\");\n\t\tgoto power_on_finish;\n\t}\n\n\ttcphy->mode |= MODE_DFP_DP;\n\npower_on_finish:\n\tif (tcphy->mode == MODE_DISCONNECT)\n\t\ttcphy_phy_deinit(tcphy);\nunlock_ret:\n\tmutex_unlock(&tcphy->lock);\n\treturn ret;\n}\n\nstatic int rockchip_dp_phy_power_off(struct phy *phy)\n{\n\tstruct rockchip_typec_phy *tcphy = phy_get_drvdata(phy);\n\n\tmutex_lock(&tcphy->lock);\n\n\tif (tcphy->mode == MODE_DISCONNECT)\n\t\tgoto unlock;\n\n\ttcphy->mode &= ~MODE_DFP_DP;\n\n\twritel(DP_MODE_ENTER_A2, tcphy->base + DP_MODE_CTL);\n\n\tif (tcphy->mode == MODE_DISCONNECT)\n\t\ttcphy_phy_deinit(tcphy);\n\nunlock:\n\tmutex_unlock(&tcphy->lock);\n\treturn 0;\n}\n\nstatic const struct phy_ops rockchip_dp_phy_ops = {\n\t.power_on\t= rockchip_dp_phy_power_on,\n\t.power_off\t= rockchip_dp_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int tcphy_parse_dt(struct rockchip_typec_phy *tcphy,\n\t\t\t  struct device *dev)\n{\n\ttcphy->grf_regs = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t  \"rockchip,grf\");\n\tif (IS_ERR(tcphy->grf_regs)) {\n\t\tdev_err(dev, \"could not find grf dt node\\n\");\n\t\treturn PTR_ERR(tcphy->grf_regs);\n\t}\n\n\ttcphy->clk_core = devm_clk_get(dev, \"tcpdcore\");\n\tif (IS_ERR(tcphy->clk_core)) {\n\t\tdev_err(dev, \"could not get uphy core clock\\n\");\n\t\treturn PTR_ERR(tcphy->clk_core);\n\t}\n\n\ttcphy->clk_ref = devm_clk_get(dev, \"tcpdphy-ref\");\n\tif (IS_ERR(tcphy->clk_ref)) {\n\t\tdev_err(dev, \"could not get uphy ref clock\\n\");\n\t\treturn PTR_ERR(tcphy->clk_ref);\n\t}\n\n\ttcphy->uphy_rst = devm_reset_control_get(dev, \"uphy\");\n\tif (IS_ERR(tcphy->uphy_rst)) {\n\t\tdev_err(dev, \"no uphy_rst reset control found\\n\");\n\t\treturn PTR_ERR(tcphy->uphy_rst);\n\t}\n\n\ttcphy->pipe_rst = devm_reset_control_get(dev, \"uphy-pipe\");\n\tif (IS_ERR(tcphy->pipe_rst)) {\n\t\tdev_err(dev, \"no pipe_rst reset control found\\n\");\n\t\treturn PTR_ERR(tcphy->pipe_rst);\n\t}\n\n\ttcphy->tcphy_rst = devm_reset_control_get(dev, \"uphy-tcphy\");\n\tif (IS_ERR(tcphy->tcphy_rst)) {\n\t\tdev_err(dev, \"no tcphy_rst reset control found\\n\");\n\t\treturn PTR_ERR(tcphy->tcphy_rst);\n\t}\n\n\treturn 0;\n}\n\nstatic void typec_phy_pre_init(struct rockchip_typec_phy *tcphy)\n{\n\tconst struct rockchip_usb3phy_port_cfg *cfg = tcphy->port_cfgs;\n\n\treset_control_assert(tcphy->tcphy_rst);\n\treset_control_assert(tcphy->uphy_rst);\n\treset_control_assert(tcphy->pipe_rst);\n\n\t \n\tproperty_enable(tcphy, &cfg->external_psm, 1);\n\tproperty_enable(tcphy, &cfg->usb3tousb2_en, 0);\n\n\ttcphy->mode = MODE_DISCONNECT;\n}\n\nstatic int rockchip_typec_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child_np;\n\tstruct rockchip_typec_phy *tcphy;\n\tstruct phy_provider *phy_provider;\n\tstruct resource *res;\n\tconst struct rockchip_usb3phy_port_cfg *phy_cfgs;\n\tint index, ret;\n\n\ttcphy = devm_kzalloc(dev, sizeof(*tcphy), GFP_KERNEL);\n\tif (!tcphy)\n\t\treturn -ENOMEM;\n\n\tphy_cfgs = of_device_get_match_data(dev);\n\tif (!phy_cfgs) {\n\t\tdev_err(dev, \"phy configs are not assigned!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttcphy->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(tcphy->base))\n\t\treturn PTR_ERR(tcphy->base);\n\n\t \n\tindex = 0;\n\twhile (phy_cfgs[index].reg) {\n\t\tif (phy_cfgs[index].reg == res->start) {\n\t\t\ttcphy->port_cfgs = &phy_cfgs[index];\n\t\t\tbreak;\n\t\t}\n\n\t\t++index;\n\t}\n\n\tif (!tcphy->port_cfgs) {\n\t\tdev_err(dev, \"no phy-config can be matched with %pOFn node\\n\",\n\t\t\tnp);\n\t\treturn -EINVAL;\n\t}\n\n\tret = tcphy_parse_dt(tcphy, dev);\n\tif (ret)\n\t\treturn ret;\n\n\ttcphy->dev = dev;\n\tplatform_set_drvdata(pdev, tcphy);\n\tmutex_init(&tcphy->lock);\n\n\ttypec_phy_pre_init(tcphy);\n\n\ttcphy->extcon = extcon_get_edev_by_phandle(dev, 0);\n\tif (IS_ERR(tcphy->extcon)) {\n\t\tif (PTR_ERR(tcphy->extcon) == -ENODEV) {\n\t\t\ttcphy->extcon = NULL;\n\t\t} else {\n\t\t\tif (PTR_ERR(tcphy->extcon) != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Invalid or missing extcon\\n\");\n\t\t\treturn PTR_ERR(tcphy->extcon);\n\t\t}\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tfor_each_available_child_of_node(np, child_np) {\n\t\tstruct phy *phy;\n\n\t\tif (of_node_name_eq(child_np, \"dp-port\"))\n\t\t\tphy = devm_phy_create(dev, child_np,\n\t\t\t\t\t      &rockchip_dp_phy_ops);\n\t\telse if (of_node_name_eq(child_np, \"usb3-port\"))\n\t\t\tphy = devm_phy_create(dev, child_np,\n\t\t\t\t\t      &rockchip_usb3_phy_ops);\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(dev, \"failed to create phy: %pOFn\\n\",\n\t\t\t\tchild_np);\n\t\t\tpm_runtime_disable(dev);\n\t\t\tof_node_put(child_np);\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\n\t\tphy_set_drvdata(phy, tcphy);\n\t}\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tdev_err(dev, \"Failed to register phy provider\\n\");\n\t\tpm_runtime_disable(dev);\n\t\treturn PTR_ERR(phy_provider);\n\t}\n\n\treturn 0;\n}\n\nstatic void rockchip_typec_phy_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id rockchip_typec_phy_dt_ids[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3399-typec-phy\",\n\t\t.data = &rk3399_usb3phy_port_cfgs\n\t},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, rockchip_typec_phy_dt_ids);\n\nstatic struct platform_driver rockchip_typec_phy_driver = {\n\t.probe\t\t= rockchip_typec_phy_probe,\n\t.remove_new\t= rockchip_typec_phy_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"rockchip-typec-phy\",\n\t\t.of_match_table = rockchip_typec_phy_dt_ids,\n\t},\n};\n\nmodule_platform_driver(rockchip_typec_phy_driver);\n\nMODULE_AUTHOR(\"Chris Zhong <zyw@rock-chips.com>\");\nMODULE_AUTHOR(\"Kever Yang <kever.yang@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip USB TYPE-C PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}