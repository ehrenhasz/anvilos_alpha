{
  "module_name": "phy-rockchip-inno-csidphy.c",
  "hash_id": "9eca4fd2387c166ebad2049db33bb34a391dcca6a9d7dfe8e98e9de406fd2250",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-inno-csidphy.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-mipi-dphy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n \n#define RK1808_GRF_PD_VI_CON_OFFSET\t0x0430\n\n#define RK3326_GRF_PD_VI_CON_OFFSET\t0x0430\n\n#define RK3368_GRF_SOC_CON6_OFFSET\t0x0418\n\n#define RK3568_GRF_VI_CON0\t\t0x0340\n#define RK3568_GRF_VI_CON1\t\t0x0344\n\n \n#define CSIDPHY_CTRL_LANE_ENABLE\t\t0x00\n#define CSIDPHY_CTRL_LANE_ENABLE_CK\t\tBIT(6)\n#define CSIDPHY_CTRL_LANE_ENABLE_MASK\t\tGENMASK(5, 2)\n#define CSIDPHY_CTRL_LANE_ENABLE_UNDEFINED\tBIT(0)\n\n \n#define CSIDPHY_CTRL_PWRCTL\t\t\t0x04\n#define CSIDPHY_CTRL_PWRCTL_UNDEFINED\t\tGENMASK(7, 5)\n#define CSIDPHY_CTRL_PWRCTL_SYNCRST\t\tBIT(2)\n#define CSIDPHY_CTRL_PWRCTL_LDO_PD\t\tBIT(1)\n#define CSIDPHY_CTRL_PWRCTL_PLL_PD\t\tBIT(0)\n\n#define CSIDPHY_CTRL_DIG_RST\t\t\t0x80\n#define CSIDPHY_CTRL_DIG_RST_UNDEFINED\t\t0x1e\n#define CSIDPHY_CTRL_DIG_RST_RESET\t\tBIT(0)\n\n \n#define CSIDPHY_CLK_THS_SETTLE\t\t\t0\n#define CSIDPHY_LANE_THS_SETTLE(n)\t\t(((n) + 1) * 0x80)\n#define CSIDPHY_THS_SETTLE_MASK\t\t\tGENMASK(6, 0)\n\n \n#define CSIDPHY_CLK_CALIB_EN\t\t\t0\n#define CSIDPHY_LANE_CALIB_EN(n)\t\t(((n) + 1) * 0x80)\n#define CSIDPHY_CALIB_EN\t\t\tBIT(7)\n\n \n#define RK1808_CSIDPHY_CLK_WR_THS_SETTLE\t0x160\n#define RK3326_CSIDPHY_CLK_WR_THS_SETTLE\t0x100\n#define RK3368_CSIDPHY_CLK_WR_THS_SETTLE\t0x100\n#define RK3568_CSIDPHY_CLK_WR_THS_SETTLE\t0x160\n\n \n#define RK1808_CSIDPHY_CLK_CALIB_EN\t\t0x168\n#define RK3568_CSIDPHY_CLK_CALIB_EN\t\t0x168\n\n \n#define HIWORD_UPDATE(val, mask, shift) \\\n\t\t((val) << (shift) | (mask) << ((shift) + 16))\n\n#define HZ_TO_MHZ(freq)\t\t\t\tdiv_u64(freq, 1000 * 1000)\n\nenum dphy_reg_id {\n\t \n\tGRF_DPHY_CSIPHY_FORCERXMODE,\n\tGRF_DPHY_CSIPHY_CLKLANE_EN,\n\tGRF_DPHY_CSIPHY_DATALANE_EN,\n};\n\nstruct dphy_reg {\n\tu32 offset;\n\tu32 mask;\n\tu32 shift;\n};\n\n#define PHY_REG(_offset, _width, _shift) \\\n\t{ .offset = _offset, .mask = BIT(_width) - 1, .shift = _shift, }\n\nstatic const struct dphy_reg rk1808_grf_dphy_regs[] = {\n\t[GRF_DPHY_CSIPHY_FORCERXMODE] = PHY_REG(RK1808_GRF_PD_VI_CON_OFFSET, 4, 0),\n\t[GRF_DPHY_CSIPHY_CLKLANE_EN] = PHY_REG(RK1808_GRF_PD_VI_CON_OFFSET, 1, 8),\n\t[GRF_DPHY_CSIPHY_DATALANE_EN] = PHY_REG(RK1808_GRF_PD_VI_CON_OFFSET, 4, 4),\n};\n\nstatic const struct dphy_reg rk3326_grf_dphy_regs[] = {\n\t[GRF_DPHY_CSIPHY_FORCERXMODE] = PHY_REG(RK3326_GRF_PD_VI_CON_OFFSET, 4, 0),\n\t[GRF_DPHY_CSIPHY_CLKLANE_EN] = PHY_REG(RK3326_GRF_PD_VI_CON_OFFSET, 1, 8),\n\t[GRF_DPHY_CSIPHY_DATALANE_EN] = PHY_REG(RK3326_GRF_PD_VI_CON_OFFSET, 4, 4),\n};\n\nstatic const struct dphy_reg rk3368_grf_dphy_regs[] = {\n\t[GRF_DPHY_CSIPHY_FORCERXMODE] = PHY_REG(RK3368_GRF_SOC_CON6_OFFSET, 4, 8),\n};\n\nstatic const struct dphy_reg rk3568_grf_dphy_regs[] = {\n\t[GRF_DPHY_CSIPHY_FORCERXMODE] = PHY_REG(RK3568_GRF_VI_CON0, 4, 0),\n\t[GRF_DPHY_CSIPHY_DATALANE_EN] = PHY_REG(RK3568_GRF_VI_CON0, 4, 4),\n\t[GRF_DPHY_CSIPHY_CLKLANE_EN] = PHY_REG(RK3568_GRF_VI_CON0, 1, 8),\n};\n\nstruct hsfreq_range {\n\tu32 range_h;\n\tu8 cfg_bit;\n};\n\nstruct dphy_drv_data {\n\tint pwrctl_offset;\n\tint ths_settle_offset;\n\tint calib_offset;\n\tconst struct hsfreq_range *hsfreq_ranges;\n\tint num_hsfreq_ranges;\n\tconst struct dphy_reg *grf_regs;\n};\n\nstruct rockchip_inno_csidphy {\n\tstruct device *dev;\n\tvoid __iomem *phy_base;\n\tstruct clk *pclk;\n\tstruct regmap *grf;\n\tstruct reset_control *rst;\n\tconst struct dphy_drv_data *drv_data;\n\tstruct phy_configure_opts_mipi_dphy config;\n\tu8 hsfreq;\n};\n\nstatic inline void write_grf_reg(struct rockchip_inno_csidphy *priv,\n\t\t\t\t int index, u8 value)\n{\n\tconst struct dphy_drv_data *drv_data = priv->drv_data;\n\tconst struct dphy_reg *reg = &drv_data->grf_regs[index];\n\n\tif (reg->offset)\n\t\tregmap_write(priv->grf, reg->offset,\n\t\t\t     HIWORD_UPDATE(value, reg->mask, reg->shift));\n}\n\n \nstatic const struct hsfreq_range rk1808_mipidphy_hsfreq_ranges[] = {\n\t{ 109, 0x02}, { 149, 0x03}, { 199, 0x06}, { 249, 0x06},\n\t{ 299, 0x06}, { 399, 0x08}, { 499, 0x0b}, { 599, 0x0e},\n\t{ 699, 0x10}, { 799, 0x12}, { 999, 0x16}, {1199, 0x1e},\n\t{1399, 0x23}, {1599, 0x2d}, {1799, 0x32}, {1999, 0x37},\n\t{2199, 0x3c}, {2399, 0x41}, {2499, 0x46}\n};\n\nstatic const struct hsfreq_range rk3326_mipidphy_hsfreq_ranges[] = {\n\t{ 109, 0x00}, { 149, 0x01}, { 199, 0x02}, { 249, 0x03},\n\t{ 299, 0x04}, { 399, 0x05}, { 499, 0x06}, { 599, 0x07},\n\t{ 699, 0x08}, { 799, 0x09}, { 899, 0x0a}, {1099, 0x0b},\n\t{1249, 0x0c}, {1349, 0x0d}, {1500, 0x0e}\n};\n\nstatic const struct hsfreq_range rk3368_mipidphy_hsfreq_ranges[] = {\n\t{ 109, 0x00}, { 149, 0x01}, { 199, 0x02}, { 249, 0x03},\n\t{ 299, 0x04}, { 399, 0x05}, { 499, 0x06}, { 599, 0x07},\n\t{ 699, 0x08}, { 799, 0x09}, { 899, 0x0a}, {1099, 0x0b},\n\t{1249, 0x0c}, {1349, 0x0d}, {1500, 0x0e}\n};\n\nstatic void rockchip_inno_csidphy_ths_settle(struct rockchip_inno_csidphy *priv,\n\t\t\t\t\t     int hsfreq, int offset)\n{\n\tconst struct dphy_drv_data *drv_data = priv->drv_data;\n\tu32 val;\n\n\tval = readl(priv->phy_base + drv_data->ths_settle_offset + offset);\n\tval &= ~CSIDPHY_THS_SETTLE_MASK;\n\tval |= hsfreq;\n\twritel(val, priv->phy_base + drv_data->ths_settle_offset + offset);\n}\n\nstatic int rockchip_inno_csidphy_configure(struct phy *phy,\n\t\t\t\t\t   union phy_configure_opts *opts)\n{\n\tstruct rockchip_inno_csidphy *priv = phy_get_drvdata(phy);\n\tconst struct dphy_drv_data *drv_data = priv->drv_data;\n\tstruct phy_configure_opts_mipi_dphy *config = &opts->mipi_dphy;\n\tunsigned int hsfreq = 0;\n\tunsigned int i;\n\tu64 data_rate_mbps;\n\tint ret;\n\n\t \n\tret = phy_mipi_dphy_config_validate(config);\n\tif (ret)\n\t\treturn ret;\n\n\tdata_rate_mbps = HZ_TO_MHZ(config->hs_clk_rate);\n\n\tdev_dbg(priv->dev, \"lanes %d - data_rate_mbps %llu\\n\",\n\t\tconfig->lanes, data_rate_mbps);\n\tfor (i = 0; i < drv_data->num_hsfreq_ranges; i++) {\n\t\tif (drv_data->hsfreq_ranges[i].range_h >= data_rate_mbps) {\n\t\t\thsfreq = drv_data->hsfreq_ranges[i].cfg_bit;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!hsfreq)\n\t\treturn -EINVAL;\n\n\tpriv->hsfreq = hsfreq;\n\tpriv->config = *config;\n\treturn 0;\n}\n\nstatic int rockchip_inno_csidphy_power_on(struct phy *phy)\n{\n\tstruct rockchip_inno_csidphy *priv = phy_get_drvdata(phy);\n\tconst struct dphy_drv_data *drv_data = priv->drv_data;\n\tu64 data_rate_mbps = HZ_TO_MHZ(priv->config.hs_clk_rate);\n\tu32 val;\n\tint ret, i;\n\n\tret = clk_enable(priv->pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret < 0) {\n\t\tclk_disable(priv->pclk);\n\t\treturn ret;\n\t}\n\n\t \n\tif (drv_data->pwrctl_offset >= 0)\n\t\twritel(CSIDPHY_CTRL_PWRCTL_UNDEFINED |\n\t\t       CSIDPHY_CTRL_PWRCTL_SYNCRST,\n\t\t       priv->phy_base + drv_data->pwrctl_offset);\n\n\t \n\tval = FIELD_PREP(CSIDPHY_CTRL_LANE_ENABLE_MASK, GENMASK(priv->config.lanes - 1, 0)) |\n\t      FIELD_PREP(CSIDPHY_CTRL_LANE_ENABLE_CK, 1) |\n\t      FIELD_PREP(CSIDPHY_CTRL_LANE_ENABLE_UNDEFINED, 1);\n\twritel(val, priv->phy_base + CSIDPHY_CTRL_LANE_ENABLE);\n\n\t \n\tif (drv_data->pwrctl_offset >= 0)\n\t\twritel(CSIDPHY_CTRL_PWRCTL_UNDEFINED,\n\t\t       priv->phy_base + drv_data->pwrctl_offset);\n\tusleep_range(500, 1000);\n\n\t \n\twritel(CSIDPHY_CTRL_DIG_RST_UNDEFINED,\n\t       priv->phy_base + CSIDPHY_CTRL_DIG_RST);\n\twritel(CSIDPHY_CTRL_DIG_RST_UNDEFINED + CSIDPHY_CTRL_DIG_RST_RESET,\n\t       priv->phy_base + CSIDPHY_CTRL_DIG_RST);\n\n\t \n\twrite_grf_reg(priv, GRF_DPHY_CSIPHY_FORCERXMODE, 0x0);\n\n\t \n\tif (data_rate_mbps > 1500 && drv_data->calib_offset >= 0) {\n\t\twritel(CSIDPHY_CALIB_EN,\n\t\t       priv->phy_base + drv_data->calib_offset +\n\t\t\t\t\tCSIDPHY_CLK_CALIB_EN);\n\t\tfor (i = 0; i < priv->config.lanes; i++)\n\t\t\twritel(CSIDPHY_CALIB_EN,\n\t\t\t       priv->phy_base + drv_data->calib_offset +\n\t\t\t\t\t\tCSIDPHY_LANE_CALIB_EN(i));\n\t}\n\n\trockchip_inno_csidphy_ths_settle(priv, priv->hsfreq,\n\t\t\t\t\t CSIDPHY_CLK_THS_SETTLE);\n\tfor (i = 0; i < priv->config.lanes; i++)\n\t\trockchip_inno_csidphy_ths_settle(priv, priv->hsfreq,\n\t\t\t\t\t\t CSIDPHY_LANE_THS_SETTLE(i));\n\n\twrite_grf_reg(priv, GRF_DPHY_CSIPHY_CLKLANE_EN, 0x1);\n\twrite_grf_reg(priv, GRF_DPHY_CSIPHY_DATALANE_EN,\n\t\t      GENMASK(priv->config.lanes - 1, 0));\n\n\treturn 0;\n}\n\nstatic int rockchip_inno_csidphy_power_off(struct phy *phy)\n{\n\tstruct rockchip_inno_csidphy *priv = phy_get_drvdata(phy);\n\tconst struct dphy_drv_data *drv_data = priv->drv_data;\n\n\t \n\twritel(CSIDPHY_CTRL_LANE_ENABLE_UNDEFINED,\n\t       priv->phy_base + CSIDPHY_CTRL_LANE_ENABLE);\n\n\t \n\tif (drv_data->pwrctl_offset >= 0)\n\t\twritel(CSIDPHY_CTRL_PWRCTL_UNDEFINED |\n\t\t       CSIDPHY_CTRL_PWRCTL_LDO_PD |\n\t\t       CSIDPHY_CTRL_PWRCTL_PLL_PD,\n\t\t       priv->phy_base + drv_data->pwrctl_offset);\n\tusleep_range(500, 1000);\n\n\tpm_runtime_put(priv->dev);\n\tclk_disable(priv->pclk);\n\n\treturn 0;\n}\n\nstatic int rockchip_inno_csidphy_init(struct phy *phy)\n{\n\tstruct rockchip_inno_csidphy *priv = phy_get_drvdata(phy);\n\n\treturn clk_prepare(priv->pclk);\n}\n\nstatic int rockchip_inno_csidphy_exit(struct phy *phy)\n{\n\tstruct rockchip_inno_csidphy *priv = phy_get_drvdata(phy);\n\n\tclk_unprepare(priv->pclk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops rockchip_inno_csidphy_ops = {\n\t.power_on\t= rockchip_inno_csidphy_power_on,\n\t.power_off\t= rockchip_inno_csidphy_power_off,\n\t.init\t\t= rockchip_inno_csidphy_init,\n\t.exit\t\t= rockchip_inno_csidphy_exit,\n\t.configure\t= rockchip_inno_csidphy_configure,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct dphy_drv_data rk1808_mipidphy_drv_data = {\n\t.pwrctl_offset = -1,\n\t.ths_settle_offset = RK1808_CSIDPHY_CLK_WR_THS_SETTLE,\n\t.calib_offset = RK1808_CSIDPHY_CLK_CALIB_EN,\n\t.hsfreq_ranges = rk1808_mipidphy_hsfreq_ranges,\n\t.num_hsfreq_ranges = ARRAY_SIZE(rk1808_mipidphy_hsfreq_ranges),\n\t.grf_regs = rk1808_grf_dphy_regs,\n};\n\nstatic const struct dphy_drv_data rk3326_mipidphy_drv_data = {\n\t.pwrctl_offset = CSIDPHY_CTRL_PWRCTL,\n\t.ths_settle_offset = RK3326_CSIDPHY_CLK_WR_THS_SETTLE,\n\t.calib_offset = -1,\n\t.hsfreq_ranges = rk3326_mipidphy_hsfreq_ranges,\n\t.num_hsfreq_ranges = ARRAY_SIZE(rk3326_mipidphy_hsfreq_ranges),\n\t.grf_regs = rk3326_grf_dphy_regs,\n};\n\nstatic const struct dphy_drv_data rk3368_mipidphy_drv_data = {\n\t.pwrctl_offset = CSIDPHY_CTRL_PWRCTL,\n\t.ths_settle_offset = RK3368_CSIDPHY_CLK_WR_THS_SETTLE,\n\t.calib_offset = -1,\n\t.hsfreq_ranges = rk3368_mipidphy_hsfreq_ranges,\n\t.num_hsfreq_ranges = ARRAY_SIZE(rk3368_mipidphy_hsfreq_ranges),\n\t.grf_regs = rk3368_grf_dphy_regs,\n};\n\nstatic const struct dphy_drv_data rk3568_mipidphy_drv_data = {\n\t.pwrctl_offset = -1,\n\t.ths_settle_offset = RK3568_CSIDPHY_CLK_WR_THS_SETTLE,\n\t.calib_offset = RK3568_CSIDPHY_CLK_CALIB_EN,\n\t.hsfreq_ranges = rk1808_mipidphy_hsfreq_ranges,\n\t.num_hsfreq_ranges = ARRAY_SIZE(rk1808_mipidphy_hsfreq_ranges),\n\t.grf_regs = rk3568_grf_dphy_regs,\n};\n\nstatic const struct of_device_id rockchip_inno_csidphy_match_id[] = {\n\t{\n\t\t.compatible = \"rockchip,px30-csi-dphy\",\n\t\t.data = &rk3326_mipidphy_drv_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk1808-csi-dphy\",\n\t\t.data = &rk1808_mipidphy_drv_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3326-csi-dphy\",\n\t\t.data = &rk3326_mipidphy_drv_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3368-csi-dphy\",\n\t\t.data = &rk3368_mipidphy_drv_data,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3568-csi-dphy\",\n\t\t.data = &rk3568_mipidphy_drv_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rockchip_inno_csidphy_match_id);\n\nstatic int rockchip_inno_csidphy_probe(struct platform_device *pdev)\n{\n\tstruct rockchip_inno_csidphy *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *phy;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->drv_data = of_device_get_match_data(dev);\n\tif (!priv->drv_data) {\n\t\tdev_err(dev, \"Can't find device data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->grf = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t    \"rockchip,grf\");\n\tif (IS_ERR(priv->grf)) {\n\t\tdev_err(dev, \"Can't find GRF syscon\\n\");\n\t\treturn PTR_ERR(priv->grf);\n\t}\n\n\tpriv->phy_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->phy_base))\n\t\treturn PTR_ERR(priv->phy_base);\n\n\tpriv->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(priv->pclk)) {\n\t\tdev_err(dev, \"failed to get pclk\\n\");\n\t\treturn PTR_ERR(priv->pclk);\n\t}\n\n\tpriv->rst = devm_reset_control_get(dev, \"apb\");\n\tif (IS_ERR(priv->rst)) {\n\t\tdev_err(dev, \"failed to get system reset control\\n\");\n\t\treturn PTR_ERR(priv->rst);\n\t}\n\n\tphy = devm_phy_create(dev, NULL, &rockchip_inno_csidphy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"failed to create phy\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\tphy_set_drvdata(phy, priv);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tdev_err(dev, \"failed to register phy provider\\n\");\n\t\treturn PTR_ERR(phy_provider);\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void rockchip_inno_csidphy_remove(struct platform_device *pdev)\n{\n\tstruct rockchip_inno_csidphy *priv = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(priv->dev);\n}\n\nstatic struct platform_driver rockchip_inno_csidphy_driver = {\n\t.driver = {\n\t\t.name = \"rockchip-inno-csidphy\",\n\t\t.of_match_table = rockchip_inno_csidphy_match_id,\n\t},\n\t.probe = rockchip_inno_csidphy_probe,\n\t.remove_new = rockchip_inno_csidphy_remove,\n};\n\nmodule_platform_driver(rockchip_inno_csidphy_driver);\nMODULE_AUTHOR(\"Heiko Stuebner <heiko.stuebner@theobroma-systems.com>\");\nMODULE_DESCRIPTION(\"Rockchip MIPI Innosilicon CSI-DPHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}