{
  "module_name": "phy-rockchip-inno-hdmi.c",
  "hash_id": "972f3d038b541b281add08a468fe847592ec7f77ae05473c2b7483449251bfa0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/rockchip/phy-rockchip-inno-hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/phy/phy.h>\n#include <linux/slab.h>\n\n#define UPDATE(x, h, l)\t\t(((x) << (l)) & GENMASK((h), (l)))\n\n \n#define RK3228_PRE_PLL_REFCLK_SEL_PCLK\t\t\tBIT(0)\n \n#define RK3228_BYPASS_RXSENSE_EN\t\t\tBIT(2)\n#define RK3228_BYPASS_PWRON_EN\t\t\t\tBIT(1)\n#define RK3228_BYPASS_PLLPD_EN\t\t\t\tBIT(0)\n \n#define RK3228_BYPASS_PDATA_EN\t\t\t\tBIT(4)\n#define RK3228_PDATAEN_DISABLE\t\t\t\tBIT(0)\n \n#define RK3228_BYPASS_AUTO_TERM_RES_CAL\t\t\tBIT(7)\n#define RK3228_AUTO_TERM_RES_CAL_SPEED_14_8(x)\t\tUPDATE(x, 6, 0)\n \n#define RK3228_AUTO_TERM_RES_CAL_SPEED_7_0(x)\t\tUPDATE(x, 7, 0)\n \n#define RK3228_POST_PLL_CTRL_MANUAL\t\t\tBIT(0)\n \n#define RK3228_POST_PLL_POWER_DOWN\t\t\tBIT(5)\n#define RK3228_PRE_PLL_POWER_DOWN\t\t\tBIT(4)\n#define RK3228_RXSENSE_CLK_CH_ENABLE\t\t\tBIT(3)\n#define RK3228_RXSENSE_DATA_CH2_ENABLE\t\t\tBIT(2)\n#define RK3228_RXSENSE_DATA_CH1_ENABLE\t\t\tBIT(1)\n#define RK3228_RXSENSE_DATA_CH0_ENABLE\t\t\tBIT(0)\n \n#define RK3228_BANDGAP_ENABLE\t\t\t\tBIT(4)\n#define RK3228_TMDS_DRIVER_ENABLE\t\t\tGENMASK(3, 0)\n \n#define RK3228_PRE_PLL_FB_DIV_8_MASK\t\t\tBIT(7)\n#define RK3228_PRE_PLL_FB_DIV_8(x)\t\t\tUPDATE((x) >> 8, 7, 7)\n#define RK3228_PCLK_VCO_DIV_5_MASK\t\t\tBIT(5)\n#define RK3228_PCLK_VCO_DIV_5(x)\t\t\tUPDATE(x, 5, 5)\n#define RK3228_PRE_PLL_PRE_DIV_MASK\t\t\tGENMASK(4, 0)\n#define RK3228_PRE_PLL_PRE_DIV(x)\t\t\tUPDATE(x, 4, 0)\n \n#define RK3228_PRE_PLL_FB_DIV_7_0(x)\t\t\tUPDATE(x, 7, 0)\n \n#define RK3228_PRE_PLL_PCLK_DIV_B_MASK\t\t\tGENMASK(6, 5)\n#define RK3228_PRE_PLL_PCLK_DIV_B_SHIFT\t\t\t5\n#define RK3228_PRE_PLL_PCLK_DIV_B(x)\t\t\tUPDATE(x, 6, 5)\n#define RK3228_PRE_PLL_PCLK_DIV_A_MASK\t\t\tGENMASK(4, 0)\n#define RK3228_PRE_PLL_PCLK_DIV_A(x)\t\t\tUPDATE(x, 4, 0)\n \n#define RK3228_PRE_PLL_PCLK_DIV_C_MASK\t\t\tGENMASK(6, 5)\n#define RK3228_PRE_PLL_PCLK_DIV_C(x)\t\t\tUPDATE(x, 6, 5)\n#define RK3228_PRE_PLL_PCLK_DIV_D_MASK\t\t\tGENMASK(4, 0)\n#define RK3228_PRE_PLL_PCLK_DIV_D(x)\t\t\tUPDATE(x, 4, 0)\n \n#define RK3228_PRE_PLL_TMDSCLK_DIV_C_MASK\t\tGENMASK(5, 4)\n#define RK3228_PRE_PLL_TMDSCLK_DIV_C(x)\t\t\tUPDATE(x, 5, 4)\n#define RK3228_PRE_PLL_TMDSCLK_DIV_A_MASK\t\tGENMASK(3, 2)\n#define RK3228_PRE_PLL_TMDSCLK_DIV_A(x)\t\t\tUPDATE(x, 3, 2)\n#define RK3228_PRE_PLL_TMDSCLK_DIV_B_MASK\t\tGENMASK(1, 0)\n#define RK3228_PRE_PLL_TMDSCLK_DIV_B(x)\t\t\tUPDATE(x, 1, 0)\n \n#define RK3228_PRE_PLL_LOCK_STATUS\t\t\tBIT(0)\n \n#define RK3228_POST_PLL_POST_DIV_ENABLE\t\t\tUPDATE(3, 7, 6)\n#define RK3228_POST_PLL_PRE_DIV_MASK\t\t\tGENMASK(4, 0)\n#define RK3228_POST_PLL_PRE_DIV(x)\t\t\tUPDATE(x, 4, 0)\n \n#define RK3228_POST_PLL_FB_DIV_7_0(x)\t\t\tUPDATE(x, 7, 0)\n \n#define RK3228_POST_PLL_FB_DIV_8_MASK\t\t\tBIT(7)\n#define RK3228_POST_PLL_FB_DIV_8(x)\t\t\tUPDATE((x) >> 8, 7, 7)\n#define RK3228_POST_PLL_POST_DIV_MASK\t\t\tGENMASK(5, 4)\n#define RK3228_POST_PLL_POST_DIV(x)\t\t\tUPDATE(x, 5, 4)\n#define RK3228_POST_PLL_LOCK_STATUS\t\t\tBIT(0)\n \n#define RK3228_TMDS_CH_TA_ENABLE\t\t\tGENMASK(7, 4)\n \n#define RK3228_TMDS_CLK_CH_TA(x)\t\t\tUPDATE(x, 7, 6)\n#define RK3228_TMDS_DATA_CH2_TA(x)\t\t\tUPDATE(x, 5, 4)\n#define RK3228_TMDS_DATA_CH1_TA(x)\t\t\tUPDATE(x, 3, 2)\n#define RK3228_TMDS_DATA_CH0_TA(x)\t\t\tUPDATE(x, 1, 0)\n \n#define RK3228_TMDS_DATA_CH2_PRE_EMPHASIS_MASK\t\tGENMASK(5, 4)\n#define RK3228_TMDS_DATA_CH2_PRE_EMPHASIS(x)\t\tUPDATE(x, 5, 4)\n#define RK3228_TMDS_DATA_CH1_PRE_EMPHASIS_MASK\t\tGENMASK(3, 2)\n#define RK3228_TMDS_DATA_CH1_PRE_EMPHASIS(x)\t\tUPDATE(x, 3, 2)\n#define RK3228_TMDS_DATA_CH0_PRE_EMPHASIS_MASK\t\tGENMASK(1, 0)\n#define RK3228_TMDS_DATA_CH0_PRE_EMPHASIS(x)\t\tUPDATE(x, 1, 0)\n \n#define RK3228_TMDS_CLK_CH_OUTPUT_SWING(x)\t\tUPDATE(x, 7, 4)\n#define RK3228_TMDS_DATA_CH2_OUTPUT_SWING(x)\t\tUPDATE(x, 3, 0)\n \n#define RK3228_TMDS_DATA_CH1_OUTPUT_SWING(x)\t\tUPDATE(x, 7, 4)\n#define RK3228_TMDS_DATA_CH0_OUTPUT_SWING(x)\t\tUPDATE(x, 3, 0)\n\n \n#define RK3328_BYPASS_RXSENSE_EN\t\t\tBIT(2)\n#define RK3328_BYPASS_POWERON_EN\t\t\tBIT(1)\n#define RK3328_BYPASS_PLLPD_EN\t\t\t\tBIT(0)\n \n#define RK3328_INT_POL_HIGH\t\t\t\tBIT(7)\n#define RK3328_BYPASS_PDATA_EN\t\t\t\tBIT(4)\n#define RK3328_PDATA_EN\t\t\t\t\tBIT(0)\n \n#define RK3328_INT_TMDS_CLK(x)\t\t\t\tUPDATE(x, 7, 4)\n#define RK3328_INT_TMDS_D2(x)\t\t\t\tUPDATE(x, 3, 0)\n \n#define RK3328_INT_TMDS_D1(x)\t\t\t\tUPDATE(x, 7, 4)\n#define RK3328_INT_TMDS_D0(x)\t\t\t\tUPDATE(x, 3, 0)\n \n#define RK3328_INT_AGND_LOW_PULSE_LOCKED\t\tBIT(3)\n#define RK3328_INT_RXSENSE_LOW_PULSE_LOCKED\t\tBIT(2)\n#define RK3328_INT_VSS_AGND_ESD_DET\t\t\tBIT(1)\n#define RK3328_INT_AGND_VSS_ESD_DET\t\t\tBIT(0)\n \n#define RK3328_PCLK_VCO_DIV_5_MASK\t\t\tBIT(1)\n#define RK3328_PCLK_VCO_DIV_5(x)\t\t\tUPDATE(x, 1, 1)\n#define RK3328_PRE_PLL_POWER_DOWN\t\t\tBIT(0)\n \n#define RK3328_PRE_PLL_PRE_DIV_MASK\t\t\tGENMASK(5, 0)\n#define RK3328_PRE_PLL_PRE_DIV(x)\t\t\tUPDATE(x, 5, 0)\n \n \n#define RK3328_SPREAD_SPECTRUM_MOD_DOWN\t\t\tBIT(7)\n#define RK3328_SPREAD_SPECTRUM_MOD_DISABLE\t\tBIT(6)\n#define RK3328_PRE_PLL_FRAC_DIV_DISABLE\t\t\tUPDATE(3, 5, 4)\n#define RK3328_PRE_PLL_FB_DIV_11_8_MASK\t\t\tGENMASK(3, 0)\n#define RK3328_PRE_PLL_FB_DIV_11_8(x)\t\t\tUPDATE((x) >> 8, 3, 0)\n \n#define RK3328_PRE_PLL_FB_DIV_7_0(x)\t\t\tUPDATE(x, 7, 0)\n \n#define RK3328_PRE_PLL_TMDSCLK_DIV_C_MASK\t\tGENMASK(1, 0)\n#define RK3328_PRE_PLL_TMDSCLK_DIV_C(x)\t\t\tUPDATE(x, 1, 0)\n#define RK3328_PRE_PLL_TMDSCLK_DIV_B_MASK\t\tGENMASK(3, 2)\n#define RK3328_PRE_PLL_TMDSCLK_DIV_B(x)\t\t\tUPDATE(x, 3, 2)\n#define RK3328_PRE_PLL_TMDSCLK_DIV_A_MASK\t\tGENMASK(5, 4)\n#define RK3328_PRE_PLL_TMDSCLK_DIV_A(x)\t\t\tUPDATE(x, 5, 4)\n \n#define RK3328_PRE_PLL_PCLK_DIV_B_SHIFT\t\t\t5\n#define RK3328_PRE_PLL_PCLK_DIV_B_MASK\t\t\tGENMASK(6, 5)\n#define RK3328_PRE_PLL_PCLK_DIV_B(x)\t\t\tUPDATE(x, 6, 5)\n#define RK3328_PRE_PLL_PCLK_DIV_A_MASK\t\t\tGENMASK(4, 0)\n#define RK3328_PRE_PLL_PCLK_DIV_A(x)\t\t\tUPDATE(x, 4, 0)\n \n#define RK3328_PRE_PLL_PCLK_DIV_C_SHIFT\t\t\t5\n#define RK3328_PRE_PLL_PCLK_DIV_C_MASK\t\t\tGENMASK(6, 5)\n#define RK3328_PRE_PLL_PCLK_DIV_C(x)\t\t\tUPDATE(x, 6, 5)\n#define RK3328_PRE_PLL_PCLK_DIV_D_MASK\t\t\tGENMASK(4, 0)\n#define RK3328_PRE_PLL_PCLK_DIV_D(x)\t\t\tUPDATE(x, 4, 0)\n \n#define RK3328_PRE_PLL_LOCK_STATUS\t\t\tBIT(0)\n \n#define RK3328_POST_PLL_POST_DIV_ENABLE\t\t\tGENMASK(3, 2)\n#define RK3328_POST_PLL_REFCLK_SEL_TMDS\t\t\tBIT(1)\n#define RK3328_POST_PLL_POWER_DOWN\t\t\tBIT(0)\n \n#define RK3328_POST_PLL_FB_DIV_8(x)\t\t\tUPDATE((x) >> 8, 7, 7)\n#define RK3328_POST_PLL_PRE_DIV(x)\t\t\tUPDATE(x, 4, 0)\n \n#define RK3328_POST_PLL_FB_DIV_7_0(x)\t\t\tUPDATE(x, 7, 0)\n \n#define RK3328_POST_PLL_POST_DIV_MASK\t\t\tGENMASK(1, 0)\n#define RK3328_POST_PLL_POST_DIV_2\t\t\t0x0\n#define RK3328_POST_PLL_POST_DIV_4\t\t\t0x1\n#define RK3328_POST_PLL_POST_DIV_8\t\t\t0x3\n \n#define RK3328_POST_PLL_LOCK_STATUS\t\t\tBIT(0)\n \n#define RK3328_BANDGAP_ENABLE\t\t\t\tBIT(2)\n \n#define RK3328_TMDS_CLK_DRIVER_EN\t\t\tBIT(3)\n#define RK3328_TMDS_D2_DRIVER_EN\t\t\tBIT(2)\n#define RK3328_TMDS_D1_DRIVER_EN\t\t\tBIT(1)\n#define RK3328_TMDS_D0_DRIVER_EN\t\t\tBIT(0)\n#define RK3328_TMDS_DRIVER_ENABLE\t\t(RK3328_TMDS_CLK_DRIVER_EN | \\\n\t\t\t\t\t\tRK3328_TMDS_D2_DRIVER_EN | \\\n\t\t\t\t\t\tRK3328_TMDS_D1_DRIVER_EN | \\\n\t\t\t\t\t\tRK3328_TMDS_D0_DRIVER_EN)\n \n#define RK3328_BYPASS_TERM_RESISTOR_CALIB\t\tBIT(7)\n#define RK3328_TERM_RESISTOR_CALIB_SPEED_14_8(x)\tUPDATE((x) >> 8, 6, 0)\n \n#define RK3328_TERM_RESISTOR_CALIB_SPEED_7_0(x)\t\tUPDATE(x, 7, 0)\n \n#define RK3328_TERM_RESISTOR_50\t\t\t\tUPDATE(0, 2, 1)\n#define RK3328_TERM_RESISTOR_62_5\t\t\tUPDATE(1, 2, 1)\n#define RK3328_TERM_RESISTOR_75\t\t\t\tUPDATE(2, 2, 1)\n#define RK3328_TERM_RESISTOR_100\t\t\tUPDATE(3, 2, 1)\n \n#define RK3328_ESD_DETECT_MASK\t\t\t\tGENMASK(7, 6)\n#define RK3328_ESD_DETECT_340MV\t\t\t\t(0x0 << 6)\n#define RK3328_ESD_DETECT_280MV\t\t\t\t(0x1 << 6)\n#define RK3328_ESD_DETECT_260MV\t\t\t\t(0x2 << 6)\n#define RK3328_ESD_DETECT_240MV\t\t\t\t(0x3 << 6)\n \n#define RK3328_TMDS_TERM_RESIST_MASK\t\t\tGENMASK(5, 0)\n#define RK3328_TMDS_TERM_RESIST_75\t\t\tBIT(5)\n#define RK3328_TMDS_TERM_RESIST_150\t\t\tBIT(4)\n#define RK3328_TMDS_TERM_RESIST_300\t\t\tBIT(3)\n#define RK3328_TMDS_TERM_RESIST_600\t\t\tBIT(2)\n#define RK3328_TMDS_TERM_RESIST_1000\t\t\tBIT(1)\n#define RK3328_TMDS_TERM_RESIST_2000\t\t\tBIT(0)\n \n#define RK3328_PRE_PLL_FRAC_DIV_23_16(x)\t\tUPDATE((x) >> 16, 7, 0)\n \n#define RK3328_PRE_PLL_FRAC_DIV_15_8(x)\t\t\tUPDATE((x) >> 8, 7, 0)\n \n#define RK3328_PRE_PLL_FRAC_DIV_7_0(x)\t\t\tUPDATE(x, 7, 0)\n\nstruct inno_hdmi_phy_drv_data;\n\nstruct inno_hdmi_phy {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tint irq;\n\n\tstruct phy *phy;\n\tstruct clk *sysclk;\n\tstruct clk *refoclk;\n\tstruct clk *refpclk;\n\n\t \n\tconst struct inno_hdmi_phy_drv_data *plat_data;\n\tint chip_version;\n\n\t \n\tstruct clk_hw hw;\n\tstruct clk *phyclk;\n\tunsigned long pixclock;\n\tunsigned long tmdsclock;\n};\n\nstruct pre_pll_config {\n\tunsigned long pixclock;\n\tunsigned long tmdsclock;\n\tu8 prediv;\n\tu16 fbdiv;\n\tu8 tmds_div_a;\n\tu8 tmds_div_b;\n\tu8 tmds_div_c;\n\tu8 pclk_div_a;\n\tu8 pclk_div_b;\n\tu8 pclk_div_c;\n\tu8 pclk_div_d;\n\tu8 vco_div_5_en;\n\tu32 fracdiv;\n};\n\nstruct post_pll_config {\n\tunsigned long tmdsclock;\n\tu8 prediv;\n\tu16 fbdiv;\n\tu8 postdiv;\n\tu8 version;\n};\n\nstruct phy_config {\n\tunsigned long\ttmdsclock;\n\tu8\t\tregs[14];\n};\n\nstruct inno_hdmi_phy_ops {\n\tint (*init)(struct inno_hdmi_phy *inno);\n\tint (*power_on)(struct inno_hdmi_phy *inno,\n\t\t\tconst struct post_pll_config *cfg,\n\t\t\tconst struct phy_config *phy_cfg);\n\tvoid (*power_off)(struct inno_hdmi_phy *inno);\n};\n\nstruct inno_hdmi_phy_drv_data {\n\tconst struct inno_hdmi_phy_ops\t*ops;\n\tconst struct clk_ops\t\t*clk_ops;\n\tconst struct phy_config\t\t*phy_cfg_table;\n};\n\nstatic const struct pre_pll_config pre_pll_cfg_table[] = {\n\t{ 25175000,  25175000,  3,  125, 3, 1, 1,  1, 3, 3,  4, 0, 0xe00000},\n\t{ 25175000,  31468750,  1,   41, 0, 3, 3,  1, 3, 3,  4, 0, 0xf5554f},\n\t{ 27000000,  27000000,  1,   36, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 27000000,  33750000,  1,   45, 0, 3, 3,  1, 3, 3,  4, 0,      0x0},\n\t{ 31500000,  31500000,  1,   42, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 31500000,  39375000,  1,  105, 1, 3, 3, 10, 0, 3,  4, 0,      0x0},\n\t{ 33750000,  33750000,  1,   45, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 33750000,  42187500,  1,  169, 2, 3, 3, 15, 0, 3,  4, 0,      0x0},\n\t{ 35500000,  35500000,  1,   71, 2, 2, 2,  6, 0, 3,  4, 0,      0x0},\n\t{ 35500000,  44375000,  1,   74, 3, 1, 1, 25, 0, 1,  1, 0,      0x0},\n\t{ 36000000,  36000000,  1,   36, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{ 36000000,  45000000,  1,   45, 2, 1, 1, 15, 0, 1,  1, 0,      0x0},\n\t{ 40000000,  40000000,  1,   40, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{ 40000000,  50000000,  1,   50, 2, 1, 1, 15, 0, 1,  1, 0,      0x0},\n\t{ 49500000,  49500000,  1,   66, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 49500000,  61875000,  1,  165, 1, 3, 3, 10, 0, 3,  4, 0,      0x0},\n\t{ 50000000,  50000000,  1,   50, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{ 50000000,  62500000,  1,  125, 2, 2, 2, 15, 0, 2,  2, 0,      0x0},\n\t{ 54000000,  54000000,  1,   36, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{ 54000000,  67500000,  1,   45, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{ 56250000,  56250000,  1,   75, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 56250000,  70312500,  1,  117, 3, 1, 1, 25, 0, 1,  1, 0,      0x0},\n\t{ 59341000,  59341000,  1,  118, 2, 2, 2,  6, 0, 3,  4, 0, 0xae978d},\n\t{ 59341000,  74176250,  2,  148, 2, 1, 1, 15, 0, 1,  1, 0, 0x5a3d70},\n\t{ 59400000,  59400000,  1,   99, 3, 1, 1,  1, 3, 3,  4, 0,      0x0},\n\t{ 59400000,  74250000,  1,   99, 0, 3, 3,  1, 3, 3,  4, 0,      0x0},\n\t{ 65000000,  65000000,  1,   65, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{ 65000000,  81250000,  3,  325, 0, 3, 3,  1, 3, 3,  4, 0,      0x0},\n\t{ 68250000,  68250000,  1,   91, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 68250000,  85312500,  1,  142, 3, 1, 1, 25, 0, 1,  1, 0,      0x0},\n\t{ 71000000,  71000000,  1,   71, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{ 71000000,  88750000,  3,  355, 0, 3, 3,  1, 3, 3,  4, 0,      0x0},\n\t{ 72000000,  72000000,  1,   36, 2, 0, 0,  1, 1, 2,  2, 0,      0x0},\n\t{ 72000000,  90000000,  1,   60, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{ 73250000,  73250000,  3,  293, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 73250000,  91562500,  1,   61, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{ 74176000,  74176000,  1,   37, 2, 0, 0,  1, 1, 2,  2, 0, 0x16872b},\n\t{ 74176000,  92720000,  2,  185, 2, 1, 1, 15, 0, 1,  1, 0, 0x70a3d7},\n\t{ 74250000,  74250000,  1,   99, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 74250000,  92812500,  4,  495, 0, 3, 3,  1, 3, 3,  4, 0,      0x0},\n\t{ 75000000,  75000000,  1,   50, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{ 75000000,  93750000,  1,  125, 0, 3, 3,  1, 3, 3,  4, 0,      0x0},\n\t{ 78750000,  78750000,  1,  105, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 78750000,  98437500,  1,  164, 3, 1, 1, 25, 0, 1,  1, 0,      0x0},\n\t{ 79500000,  79500000,  1,   53, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{ 79500000,  99375000,  1,  199, 2, 2, 2, 15, 0, 2,  2, 0,      0x0},\n\t{ 83500000,  83500000,  2,  167, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{ 83500000, 104375000,  1,  104, 2, 1, 1, 15, 0, 1,  1, 0, 0x600000},\n\t{ 85500000,  85500000,  1,   57, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{ 85500000, 106875000,  1,  178, 3, 1, 1, 25, 0, 1,  1, 0,      0x0},\n\t{ 85750000,  85750000,  3,  343, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 85750000, 107187500,  1,  143, 0, 3, 3,  1, 3, 3,  4, 0,      0x0},\n\t{ 88750000,  88750000,  3,  355, 0, 3, 3,  1, 2, 3,  4, 0,      0x0},\n\t{ 88750000, 110937500,  1,  110, 2, 1, 1, 15, 0, 1,  1, 0, 0xf00000},\n\t{ 94500000,  94500000,  1,   63, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{ 94500000, 118125000,  1,  197, 3, 1, 1, 25, 0, 1,  1, 0,      0x0},\n\t{101000000, 101000000,  1,  101, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{101000000, 126250000,  1,   42, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{102250000, 102250000,  4,  409, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{102250000, 127812500,  1,  128, 2, 1, 1, 15, 0, 1,  1, 0,      0x0},\n\t{106500000, 106500000,  1,   71, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{106500000, 133125000,  1,  133, 2, 1, 1, 15, 0, 1,  1, 0,      0x0},\n\t{108000000, 108000000,  1,   36, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{108000000, 135000000,  1,   45, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{115500000, 115500000,  1,   77, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{115500000, 144375000,  1,   48, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{117500000, 117500000,  2,  235, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{117500000, 146875000,  1,   49, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{119000000, 119000000,  1,  119, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{119000000, 148750000,  3,  148, 0, 1, 1,  1, 3, 1,  1, 0, 0xc00000},\n\t{121750000, 121750000,  4,  487, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{121750000, 152187500,  1,  203, 0, 3, 3,  1, 3, 3,  4, 0,      0x0},\n\t{122500000, 122500000,  2,  245, 2, 1, 1,  1, 1, 3,  4, 0,      0x0},\n\t{122500000, 153125000,  1,   51, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{135000000, 135000000,  1,   45, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{135000000, 168750000,  1,  169, 2, 1, 1, 15, 0, 1,  1, 0,      0x0},\n\t{136750000, 136750000,  1,   68, 2, 0, 0,  1, 1, 2,  2, 0, 0x600000},\n\t{136750000, 170937500,  1,  113, 0, 2, 2,  1, 3, 2,  2, 0, 0xf5554f},\n\t{140250000, 140250000,  2,  187, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{140250000, 175312500,  1,  117, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{146250000, 146250000,  2,  195, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{146250000, 182812500,  1,   61, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{148250000, 148250000,  3,  222, 2, 0, 0,  1, 1, 2,  2, 0, 0x600000},\n\t{148250000, 185312500,  1,  123, 0, 2, 2,  1, 3, 2,  2, 0, 0x8aaab0},\n\t{148352000, 148352000,  2,  148, 2, 0, 0,  1, 1, 2,  2, 0, 0x5a1cac},\n\t{148352000, 185440000,  3,  185, 0, 1, 1,  1, 3, 1,  1, 0, 0x70a3d7},\n\t{148500000, 148500000,  1,   99, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{148500000, 185625000,  4,  495, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{154000000, 154000000,  1,   77, 2, 0, 0,  1, 1, 2,  2, 0,      0x0},\n\t{154000000, 192500000,  1,   64, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{156000000, 156000000,  1,   52, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{156000000, 195000000,  1,   65, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{156750000, 156750000,  2,  209, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{156750000, 195937500,  1,  196, 2, 1, 1, 15, 0, 1,  1, 0,      0x0},\n\t{157000000, 157000000,  2,  157, 2, 0, 0,  1, 1, 2,  2, 0,      0x0},\n\t{157000000, 196250000,  1,  131, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{157500000, 157500000,  1,  105, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{157500000, 196875000,  1,  197, 2, 1, 1, 15, 0, 1,  1, 0,      0x0},\n\t{162000000, 162000000,  1,   54, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{162000000, 202500000,  2,  135, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{175500000, 175500000,  1,  117, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{175500000, 219375000,  1,   73, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{179500000, 179500000,  3,  359, 0, 2, 2,  1, 0, 3,  4, 0,      0x0},\n\t{179500000, 224375000,  1,   75, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{182750000, 182750000,  1,   91, 2, 0, 0,  1, 1, 2,  2, 0, 0x600000},\n\t{182750000, 228437500,  1,  152, 0, 2, 2,  1, 3, 2,  2, 0, 0x4aaab0},\n\t{182750000, 228437500,  1,  152, 0, 2, 2,  1, 3, 2,  2, 0, 0x4aaab0},\n\t{187000000, 187000000,  2,  187, 2, 0, 0,  1, 1, 2,  2, 0,      0x0},\n\t{187000000, 233750000,  1,   39, 0, 0, 0,  1, 3, 0,  0, 1,      0x0},\n\t{187250000, 187250000,  3,  280, 2, 0, 0,  1, 1, 2,  2, 0, 0xe00000},\n\t{187250000, 234062500,  1,  156, 0, 2, 2,  1, 3, 2,  2, 0,  0xaaab0},\n\t{189000000, 189000000,  1,   63, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{189000000, 236250000,  1,   79, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{193250000, 193250000,  3,  289, 2, 0, 0,  1, 1, 2,  2, 0, 0xe00000},\n\t{193250000, 241562500,  1,  161, 0, 2, 2,  1, 3, 2,  2, 0,  0xaaab0},\n\t{202500000, 202500000,  2,  135, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{202500000, 253125000,  1,  169, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{204750000, 204750000,  4,  273, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{204750000, 255937500,  1,  171, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{208000000, 208000000,  1,  104, 2, 0, 0,  1, 1, 2,  2, 0,      0x0},\n\t{208000000, 260000000,  1,  173, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{214750000, 214750000,  1,  107, 2, 0, 0,  1, 1, 2,  2, 0, 0x600000},\n\t{214750000, 268437500,  1,  178, 0, 2, 2,  1, 3, 2,  2, 0, 0xf5554f},\n\t{218250000, 218250000,  4,  291, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{218250000, 272812500,  1,   91, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{229500000, 229500000,  2,  153, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{229500000, 286875000,  1,  191, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{234000000, 234000000,  1,   39, 0, 0, 0,  1, 0, 1,  1, 0,      0x0},\n\t{234000000, 292500000,  1,  195, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{241500000, 241500000,  2,  161, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{241500000, 301875000,  1,  201, 0, 2, 2,  1, 3, 2,  2, 0,      0x0},\n\t{245250000, 245250000,  4,  327, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{245250000, 306562500,  1,   51, 0, 0, 0,  1, 3, 0,  0, 1,      0x0},\n\t{245500000, 245500000,  4,  491, 2, 0, 0,  1, 1, 2,  2, 0,      0x0},\n\t{245500000, 306875000,  1,   51, 0, 0, 0,  1, 3, 0,  0, 1,      0x0},\n\t{261000000, 261000000,  1,   87, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{261000000, 326250000,  1,  109, 0, 1, 1,  1, 3, 1,  1, 0,      0x0},\n\t{268250000, 268250000,  9,  402, 0, 0, 0,  1, 0, 1,  1, 0, 0x600000},\n\t{268250000, 335312500,  1,  111, 0, 1, 1,  1, 3, 1,  1, 0, 0xc5554f},\n\t{268500000, 268500000,  2,  179, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{268500000, 335625000,  1,   56, 0, 0, 0,  1, 3, 0,  0, 1,      0x0},\n\t{281250000, 281250000,  4,  375, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{281250000, 351562500,  1,  117, 0, 3, 1,  1, 3, 1,  1, 0,      0x0},\n\t{288000000, 288000000,  1,   48, 0, 0, 0,  1, 0, 1,  1, 0,      0x0},\n\t{288000000, 360000000,  1,   60, 0, 2, 0,  1, 3, 0,  0, 1,      0x0},\n\t{296703000, 296703000,  1,   49, 0, 0, 0,  1, 0, 1,  1, 0, 0x7353f7},\n\t{296703000, 370878750,  1,  123, 0, 3, 1,  1, 3, 1,  1, 0, 0xa051eb},\n\t{297000000, 297000000,  1,   99, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{297000000, 371250000,  4,  495, 0, 3, 1,  1, 3, 1,  1, 0,      0x0},\n\t{312250000, 312250000,  9,  468, 0, 0, 0,  1, 0, 1,  1, 0, 0x600000},\n\t{312250000, 390312500,  1,  130, 0, 3, 1,  1, 3, 1,  1, 0, 0x1aaab0},\n\t{317000000, 317000000,  3,  317, 0, 1, 1,  1, 0, 2,  2, 0,      0x0},\n\t{317000000, 396250000,  1,   66, 0, 2, 0,  1, 3, 0,  0, 1,      0x0},\n\t{319750000, 319750000,  3,  159, 0, 0, 0,  1, 0, 1,  1, 0, 0xe00000},\n\t{319750000, 399687500,  3,  199, 0, 2, 0,  1, 3, 0,  0, 1, 0xd80000},\n\t{333250000, 333250000,  9,  499, 0, 0, 0,  1, 0, 1,  1, 0, 0xe00000},\n\t{333250000, 416562500,  1,  138, 0, 3, 1,  1, 3, 1,  1, 0, 0xdaaab0},\n\t{348500000, 348500000,  9,  522, 0, 2, 0,  1, 0, 1,  1, 0, 0xc00000},\n\t{348500000, 435625000,  1,  145, 0, 3, 1,  1, 3, 1,  1, 0, 0x35554f},\n\t{356500000, 356500000,  9,  534, 0, 2, 0,  1, 0, 1,  1, 0, 0xc00000},\n\t{356500000, 445625000,  1,  148, 0, 3, 1,  1, 3, 1,  1, 0, 0x8aaab0},\n\t{380500000, 380500000,  9,  570, 0, 2, 0,  1, 0, 1,  1, 0, 0xc00000},\n\t{380500000, 475625000,  1,  158, 0, 3, 1,  1, 3, 1,  1, 0, 0x8aaab0},\n\t{443250000, 443250000,  1,   73, 0, 2, 0,  1, 0, 1,  1, 0, 0xe00000},\n\t{443250000, 554062500,  1,   92, 0, 2, 0,  1, 3, 0,  0, 1, 0x580000},\n\t{505250000, 505250000,  9,  757, 0, 2, 0,  1, 0, 1,  1, 0, 0xe00000},\n\t{552750000, 552750000,  3,  276, 0, 2, 0,  1, 0, 1,  1, 0, 0x600000},\n\t{593407000, 296703500,  3,  296, 0, 1, 1,  1, 0, 1,  1, 0, 0xb41893},\n\t{593407000, 370879375,  4,  494, 0, 3, 1,  1, 3, 0,  0, 1, 0x817e4a},\n\t{593407000, 593407000,  3,  296, 0, 2, 0,  1, 0, 1,  1, 0, 0xb41893},\n\t{594000000, 297000000,  1,   99, 0, 1, 1,  1, 0, 1,  1, 0,      0x0},\n\t{594000000, 371250000,  4,  495, 0, 3, 1,  1, 3, 0,  0, 1,      0x0},\n\t{594000000, 594000000,  1,   99, 0, 2, 0,  1, 0, 1,  1, 0,      0x0},\n\t{   }\n};\n\nstatic const struct post_pll_config post_pll_cfg_table[] = {\n\t{33750000,  1, 40, 8, 1},\n\t{33750000,  1, 80, 8, 2},\n\t{74250000,  1, 40, 8, 1},\n\t{74250000, 18, 80, 8, 2},\n\t{148500000, 2, 40, 4, 3},\n\t{297000000, 4, 40, 2, 3},\n\t{594000000, 8, 40, 1, 3},\n\t{   }\n};\n\n \nstatic const struct phy_config rk3228_phy_cfg[] = {\n\t{\t165000000, {\n\t\t\t0xaa, 0x00, 0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t}, {\n\t\t340000000, {\n\t\t\t0xaa, 0x15, 0x6a, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t}, {\n\t\t594000000, {\n\t\t\t0xaa, 0x15, 0x7a, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t}, {   },\n};\n\n \nstatic const struct phy_config rk3328_phy_cfg[] = {\n\t{\t165000000, {\n\t\t\t0x07, 0x0a, 0x0a, 0x0a, 0x00, 0x00, 0x08, 0x08, 0x08,\n\t\t\t0x00, 0xac, 0xcc, 0xcc, 0xcc,\n\t\t},\n\t}, {\n\t\t340000000, {\n\t\t\t0x0b, 0x0d, 0x0d, 0x0d, 0x07, 0x15, 0x08, 0x08, 0x08,\n\t\t\t0x3f, 0xac, 0xcc, 0xcd, 0xdd,\n\t\t},\n\t}, {\n\t\t594000000, {\n\t\t\t0x10, 0x1a, 0x1a, 0x1a, 0x07, 0x15, 0x08, 0x08, 0x08,\n\t\t\t0x00, 0xac, 0xcc, 0xcc, 0xcc,\n\t\t},\n\t}, {   },\n};\n\nstatic inline struct inno_hdmi_phy *to_inno_hdmi_phy(struct clk_hw *hw)\n{\n\treturn container_of(hw, struct inno_hdmi_phy, hw);\n}\n\n \nstatic inline void inno_write(struct inno_hdmi_phy *inno, u32 reg, u8 val)\n{\n\tregmap_write(inno->regmap, reg * 4, val);\n}\n\nstatic inline u8 inno_read(struct inno_hdmi_phy *inno, u32 reg)\n{\n\tu32 val;\n\n\tregmap_read(inno->regmap, reg * 4, &val);\n\n\treturn val;\n}\n\nstatic inline void inno_update_bits(struct inno_hdmi_phy *inno, u8 reg,\n\t\t\t\t    u8 mask, u8 val)\n{\n\tregmap_update_bits(inno->regmap, reg * 4, mask, val);\n}\n\n#define inno_poll(inno, reg, val, cond, sleep_us, timeout_us) \\\n\tregmap_read_poll_timeout((inno)->regmap, (reg) * 4, val, cond, \\\n\t\t\t\t sleep_us, timeout_us)\n\nstatic unsigned long inno_hdmi_phy_get_tmdsclk(struct inno_hdmi_phy *inno,\n\t\t\t\t\t       unsigned long rate)\n{\n\tint bus_width = phy_get_bus_width(inno->phy);\n\n\tswitch (bus_width) {\n\tcase 4:\n\tcase 5:\n\tcase 6:\n\tcase 10:\n\tcase 12:\n\tcase 16:\n\t\treturn (u64)rate * bus_width / 8;\n\tdefault:\n\t\treturn rate;\n\t}\n}\n\nstatic irqreturn_t inno_hdmi_phy_rk3328_hardirq(int irq, void *dev_id)\n{\n\tstruct inno_hdmi_phy *inno = dev_id;\n\tint intr_stat1, intr_stat2, intr_stat3;\n\n\tintr_stat1 = inno_read(inno, 0x04);\n\tintr_stat2 = inno_read(inno, 0x06);\n\tintr_stat3 = inno_read(inno, 0x08);\n\n\tif (intr_stat1)\n\t\tinno_write(inno, 0x04, intr_stat1);\n\tif (intr_stat2)\n\t\tinno_write(inno, 0x06, intr_stat2);\n\tif (intr_stat3)\n\t\tinno_write(inno, 0x08, intr_stat3);\n\n\tif (intr_stat1 || intr_stat2 || intr_stat3)\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t inno_hdmi_phy_rk3328_irq(int irq, void *dev_id)\n{\n\tstruct inno_hdmi_phy *inno = dev_id;\n\n\tinno_update_bits(inno, 0x02, RK3328_PDATA_EN, 0);\n\tusleep_range(10, 20);\n\tinno_update_bits(inno, 0x02, RK3328_PDATA_EN, RK3328_PDATA_EN);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int inno_hdmi_phy_power_on(struct phy *phy)\n{\n\tstruct inno_hdmi_phy *inno = phy_get_drvdata(phy);\n\tconst struct post_pll_config *cfg = post_pll_cfg_table;\n\tconst struct phy_config *phy_cfg = inno->plat_data->phy_cfg_table;\n\tunsigned long tmdsclock = inno_hdmi_phy_get_tmdsclk(inno,\n\t\t\t\t\t\t\t    inno->pixclock);\n\tint ret;\n\n\tif (!tmdsclock) {\n\t\tdev_err(inno->dev, \"TMDS clock is zero!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inno->plat_data->ops->power_on)\n\t\treturn -EINVAL;\n\n\tfor (; cfg->tmdsclock != 0; cfg++)\n\t\tif (tmdsclock <= cfg->tmdsclock &&\n\t\t    cfg->version & inno->chip_version)\n\t\t\tbreak;\n\n\tfor (; phy_cfg->tmdsclock != 0; phy_cfg++)\n\t\tif (tmdsclock <= phy_cfg->tmdsclock)\n\t\t\tbreak;\n\n\tif (cfg->tmdsclock == 0 || phy_cfg->tmdsclock == 0)\n\t\treturn -EINVAL;\n\n\tdev_dbg(inno->dev, \"Inno HDMI PHY Power On\\n\");\n\n\tinno->plat_data->clk_ops->set_rate(&inno->hw, inno->pixclock, 24000000);\n\n\tret = clk_prepare_enable(inno->phyclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = inno->plat_data->ops->power_on(inno, cfg, phy_cfg);\n\tif (ret) {\n\t\tclk_disable_unprepare(inno->phyclk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int inno_hdmi_phy_power_off(struct phy *phy)\n{\n\tstruct inno_hdmi_phy *inno = phy_get_drvdata(phy);\n\n\tif (!inno->plat_data->ops->power_off)\n\t\treturn -EINVAL;\n\n\tinno->plat_data->ops->power_off(inno);\n\n\tclk_disable_unprepare(inno->phyclk);\n\n\tinno->tmdsclock = 0;\n\n\tdev_dbg(inno->dev, \"Inno HDMI PHY Power Off\\n\");\n\n\treturn 0;\n}\n\nstatic const struct phy_ops inno_hdmi_phy_ops = {\n\t.owner = THIS_MODULE,\n\t.power_on = inno_hdmi_phy_power_on,\n\t.power_off = inno_hdmi_phy_power_off,\n};\n\nstatic const\nstruct pre_pll_config *inno_hdmi_phy_get_pre_pll_cfg(struct inno_hdmi_phy *inno,\n\t\t\t\t\t\t     unsigned long rate)\n{\n\tconst struct pre_pll_config *cfg = pre_pll_cfg_table;\n\tunsigned long tmdsclock = inno_hdmi_phy_get_tmdsclk(inno, rate);\n\n\tfor (; cfg->pixclock != 0; cfg++)\n\t\tif (cfg->pixclock == rate && cfg->tmdsclock == tmdsclock)\n\t\t\tbreak;\n\n\tif (cfg->pixclock == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn cfg;\n}\n\nstatic int inno_hdmi_phy_rk3228_clk_is_prepared(struct clk_hw *hw)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\tu8 status;\n\n\tstatus = inno_read(inno, 0xe0) & RK3228_PRE_PLL_POWER_DOWN;\n\treturn status ? 0 : 1;\n}\n\nstatic int inno_hdmi_phy_rk3228_clk_prepare(struct clk_hw *hw)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\n\tinno_update_bits(inno, 0xe0, RK3228_PRE_PLL_POWER_DOWN, 0);\n\treturn 0;\n}\n\nstatic void inno_hdmi_phy_rk3228_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\n\tinno_update_bits(inno, 0xe0, RK3228_PRE_PLL_POWER_DOWN,\n\t\t\t RK3228_PRE_PLL_POWER_DOWN);\n}\n\nstatic\nunsigned long inno_hdmi_phy_rk3228_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\tu8 nd, no_a, no_b, no_d;\n\tu64 vco;\n\tu16 nf;\n\n\tnd = inno_read(inno, 0xe2) & RK3228_PRE_PLL_PRE_DIV_MASK;\n\tnf = (inno_read(inno, 0xe2) & RK3228_PRE_PLL_FB_DIV_8_MASK) << 1;\n\tnf |= inno_read(inno, 0xe3);\n\tvco = parent_rate * nf;\n\n\tif (inno_read(inno, 0xe2) & RK3228_PCLK_VCO_DIV_5_MASK) {\n\t\tdo_div(vco, nd * 5);\n\t} else {\n\t\tno_a = inno_read(inno, 0xe4) & RK3228_PRE_PLL_PCLK_DIV_A_MASK;\n\t\tif (!no_a)\n\t\t\tno_a = 1;\n\t\tno_b = inno_read(inno, 0xe4) & RK3228_PRE_PLL_PCLK_DIV_B_MASK;\n\t\tno_b >>= RK3228_PRE_PLL_PCLK_DIV_B_SHIFT;\n\t\tno_b += 2;\n\t\tno_d = inno_read(inno, 0xe5) & RK3228_PRE_PLL_PCLK_DIV_D_MASK;\n\n\t\tdo_div(vco, (nd * (no_a == 1 ? no_b : no_a) * no_d * 2));\n\t}\n\n\tinno->pixclock = vco;\n\n\tdev_dbg(inno->dev, \"%s rate %lu\\n\", __func__, inno->pixclock);\n\n\treturn vco;\n}\n\nstatic long inno_hdmi_phy_rk3228_clk_round_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long rate,\n\t\t\t\t\t\tunsigned long *parent_rate)\n{\n\tconst struct pre_pll_config *cfg = pre_pll_cfg_table;\n\n\trate = (rate / 1000) * 1000;\n\n\tfor (; cfg->pixclock != 0; cfg++)\n\t\tif (cfg->pixclock == rate && !cfg->fracdiv)\n\t\t\tbreak;\n\n\tif (cfg->pixclock == 0)\n\t\treturn -EINVAL;\n\n\treturn cfg->pixclock;\n}\n\nstatic int inno_hdmi_phy_rk3228_clk_set_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long rate,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\tconst struct pre_pll_config *cfg;\n\tunsigned long tmdsclock = inno_hdmi_phy_get_tmdsclk(inno, rate);\n\tu32 v;\n\tint ret;\n\n\tdev_dbg(inno->dev, \"%s rate %lu tmdsclk %lu\\n\",\n\t\t__func__, rate, tmdsclock);\n\n\tif (inno->pixclock == rate && inno->tmdsclock == tmdsclock)\n\t\treturn 0;\n\n\tcfg = inno_hdmi_phy_get_pre_pll_cfg(inno, rate);\n\tif (IS_ERR(cfg))\n\t\treturn PTR_ERR(cfg);\n\n\t \n\tinno_update_bits(inno, 0xe0, RK3228_PRE_PLL_POWER_DOWN,\n\t\t\t RK3228_PRE_PLL_POWER_DOWN);\n\n\tinno_update_bits(inno, 0xe2, RK3228_PRE_PLL_FB_DIV_8_MASK |\n\t\t\t RK3228_PCLK_VCO_DIV_5_MASK |\n\t\t\t RK3228_PRE_PLL_PRE_DIV_MASK,\n\t\t\t RK3228_PRE_PLL_FB_DIV_8(cfg->fbdiv) |\n\t\t\t RK3228_PCLK_VCO_DIV_5(cfg->vco_div_5_en) |\n\t\t\t RK3228_PRE_PLL_PRE_DIV(cfg->prediv));\n\tinno_write(inno, 0xe3, RK3228_PRE_PLL_FB_DIV_7_0(cfg->fbdiv));\n\tinno_update_bits(inno, 0xe4, RK3228_PRE_PLL_PCLK_DIV_B_MASK |\n\t\t\t RK3228_PRE_PLL_PCLK_DIV_A_MASK,\n\t\t\t RK3228_PRE_PLL_PCLK_DIV_B(cfg->pclk_div_b) |\n\t\t\t RK3228_PRE_PLL_PCLK_DIV_A(cfg->pclk_div_a));\n\tinno_update_bits(inno, 0xe5, RK3228_PRE_PLL_PCLK_DIV_C_MASK |\n\t\t\t RK3228_PRE_PLL_PCLK_DIV_D_MASK,\n\t\t\t RK3228_PRE_PLL_PCLK_DIV_C(cfg->pclk_div_c) |\n\t\t\t RK3228_PRE_PLL_PCLK_DIV_D(cfg->pclk_div_d));\n\tinno_update_bits(inno, 0xe6, RK3228_PRE_PLL_TMDSCLK_DIV_C_MASK |\n\t\t\t RK3228_PRE_PLL_TMDSCLK_DIV_A_MASK |\n\t\t\t RK3228_PRE_PLL_TMDSCLK_DIV_B_MASK,\n\t\t\t RK3228_PRE_PLL_TMDSCLK_DIV_C(cfg->tmds_div_c) |\n\t\t\t RK3228_PRE_PLL_TMDSCLK_DIV_A(cfg->tmds_div_a) |\n\t\t\t RK3228_PRE_PLL_TMDSCLK_DIV_B(cfg->tmds_div_b));\n\n\t \n\tinno_update_bits(inno, 0xe0, RK3228_PRE_PLL_POWER_DOWN, 0);\n\n\t \n\tret = inno_poll(inno, 0xe8, v, v & RK3228_PRE_PLL_LOCK_STATUS,\n\t\t\t100, 100000);\n\tif (ret) {\n\t\tdev_err(inno->dev, \"Pre-PLL locking failed\\n\");\n\t\treturn ret;\n\t}\n\n\tinno->pixclock = rate;\n\tinno->tmdsclock = tmdsclock;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops inno_hdmi_phy_rk3228_clk_ops = {\n\t.prepare = inno_hdmi_phy_rk3228_clk_prepare,\n\t.unprepare = inno_hdmi_phy_rk3228_clk_unprepare,\n\t.is_prepared = inno_hdmi_phy_rk3228_clk_is_prepared,\n\t.recalc_rate = inno_hdmi_phy_rk3228_clk_recalc_rate,\n\t.round_rate = inno_hdmi_phy_rk3228_clk_round_rate,\n\t.set_rate = inno_hdmi_phy_rk3228_clk_set_rate,\n};\n\nstatic int inno_hdmi_phy_rk3328_clk_is_prepared(struct clk_hw *hw)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\tu8 status;\n\n\tstatus = inno_read(inno, 0xa0) & RK3328_PRE_PLL_POWER_DOWN;\n\treturn status ? 0 : 1;\n}\n\nstatic int inno_hdmi_phy_rk3328_clk_prepare(struct clk_hw *hw)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\n\tinno_update_bits(inno, 0xa0, RK3328_PRE_PLL_POWER_DOWN, 0);\n\treturn 0;\n}\n\nstatic void inno_hdmi_phy_rk3328_clk_unprepare(struct clk_hw *hw)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\n\tinno_update_bits(inno, 0xa0, RK3328_PRE_PLL_POWER_DOWN,\n\t\t\t RK3328_PRE_PLL_POWER_DOWN);\n}\n\nstatic\nunsigned long inno_hdmi_phy_rk3328_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\tunsigned long frac;\n\tu8 nd, no_a, no_b, no_d;\n\tu64 vco;\n\tu16 nf;\n\n\tnd = inno_read(inno, 0xa1) & RK3328_PRE_PLL_PRE_DIV_MASK;\n\tnf = ((inno_read(inno, 0xa2) & RK3328_PRE_PLL_FB_DIV_11_8_MASK) << 8);\n\tnf |= inno_read(inno, 0xa3);\n\tvco = parent_rate * nf;\n\n\tif (!(inno_read(inno, 0xa2) & RK3328_PRE_PLL_FRAC_DIV_DISABLE)) {\n\t\tfrac = inno_read(inno, 0xd3) |\n\t\t       (inno_read(inno, 0xd2) << 8) |\n\t\t       (inno_read(inno, 0xd1) << 16);\n\t\tvco += DIV_ROUND_CLOSEST(parent_rate * frac, (1 << 24));\n\t}\n\n\tif (inno_read(inno, 0xa0) & RK3328_PCLK_VCO_DIV_5_MASK) {\n\t\tdo_div(vco, nd * 5);\n\t} else {\n\t\tno_a = inno_read(inno, 0xa5) & RK3328_PRE_PLL_PCLK_DIV_A_MASK;\n\t\tno_b = inno_read(inno, 0xa5) & RK3328_PRE_PLL_PCLK_DIV_B_MASK;\n\t\tno_b >>= RK3328_PRE_PLL_PCLK_DIV_B_SHIFT;\n\t\tno_b += 2;\n\t\tno_d = inno_read(inno, 0xa6) & RK3328_PRE_PLL_PCLK_DIV_D_MASK;\n\n\t\tdo_div(vco, (nd * (no_a == 1 ? no_b : no_a) * no_d * 2));\n\t}\n\n\tinno->pixclock = DIV_ROUND_CLOSEST((unsigned long)vco, 1000) * 1000;\n\n\tdev_dbg(inno->dev, \"%s rate %lu vco %llu\\n\",\n\t\t__func__, inno->pixclock, vco);\n\n\treturn inno->pixclock;\n}\n\nstatic long inno_hdmi_phy_rk3328_clk_round_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long rate,\n\t\t\t\t\t\tunsigned long *parent_rate)\n{\n\tconst struct pre_pll_config *cfg = pre_pll_cfg_table;\n\n\trate = (rate / 1000) * 1000;\n\n\tfor (; cfg->pixclock != 0; cfg++)\n\t\tif (cfg->pixclock == rate)\n\t\t\tbreak;\n\n\tif (cfg->pixclock == 0)\n\t\treturn -EINVAL;\n\n\treturn cfg->pixclock;\n}\n\nstatic int inno_hdmi_phy_rk3328_clk_set_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long rate,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct inno_hdmi_phy *inno = to_inno_hdmi_phy(hw);\n\tconst struct pre_pll_config *cfg;\n\tunsigned long tmdsclock = inno_hdmi_phy_get_tmdsclk(inno, rate);\n\tu32 val;\n\tint ret;\n\n\tdev_dbg(inno->dev, \"%s rate %lu tmdsclk %lu\\n\",\n\t\t__func__, rate, tmdsclock);\n\n\tif (inno->pixclock == rate && inno->tmdsclock == tmdsclock)\n\t\treturn 0;\n\n\tcfg = inno_hdmi_phy_get_pre_pll_cfg(inno, rate);\n\tif (IS_ERR(cfg))\n\t\treturn PTR_ERR(cfg);\n\n\tinno_update_bits(inno, 0xa0, RK3328_PRE_PLL_POWER_DOWN,\n\t\t\t RK3328_PRE_PLL_POWER_DOWN);\n\n\t \n\tinno_update_bits(inno, 0xa0, RK3328_PCLK_VCO_DIV_5_MASK,\n\t\t\t RK3328_PCLK_VCO_DIV_5(cfg->vco_div_5_en));\n\tinno_write(inno, 0xa1, RK3328_PRE_PLL_PRE_DIV(cfg->prediv));\n\n\tval = RK3328_SPREAD_SPECTRUM_MOD_DISABLE;\n\tif (!cfg->fracdiv)\n\t\tval |= RK3328_PRE_PLL_FRAC_DIV_DISABLE;\n\tinno_write(inno, 0xa2, RK3328_PRE_PLL_FB_DIV_11_8(cfg->fbdiv) | val);\n\tinno_write(inno, 0xa3, RK3328_PRE_PLL_FB_DIV_7_0(cfg->fbdiv));\n\tinno_write(inno, 0xa5, RK3328_PRE_PLL_PCLK_DIV_A(cfg->pclk_div_a) |\n\t\t   RK3328_PRE_PLL_PCLK_DIV_B(cfg->pclk_div_b));\n\tinno_write(inno, 0xa6, RK3328_PRE_PLL_PCLK_DIV_C(cfg->pclk_div_c) |\n\t\t   RK3328_PRE_PLL_PCLK_DIV_D(cfg->pclk_div_d));\n\tinno_write(inno, 0xa4, RK3328_PRE_PLL_TMDSCLK_DIV_C(cfg->tmds_div_c) |\n\t\t   RK3328_PRE_PLL_TMDSCLK_DIV_A(cfg->tmds_div_a) |\n\t\t   RK3328_PRE_PLL_TMDSCLK_DIV_B(cfg->tmds_div_b));\n\tinno_write(inno, 0xd3, RK3328_PRE_PLL_FRAC_DIV_7_0(cfg->fracdiv));\n\tinno_write(inno, 0xd2, RK3328_PRE_PLL_FRAC_DIV_15_8(cfg->fracdiv));\n\tinno_write(inno, 0xd1, RK3328_PRE_PLL_FRAC_DIV_23_16(cfg->fracdiv));\n\n\tinno_update_bits(inno, 0xa0, RK3328_PRE_PLL_POWER_DOWN, 0);\n\n\t \n\tret = inno_poll(inno, 0xa9, val, val & RK3328_PRE_PLL_LOCK_STATUS,\n\t\t\t1000, 10000);\n\tif (ret) {\n\t\tdev_err(inno->dev, \"Pre-PLL locking failed\\n\");\n\t\treturn ret;\n\t}\n\n\tinno->pixclock = rate;\n\tinno->tmdsclock = tmdsclock;\n\n\treturn 0;\n}\n\nstatic const struct clk_ops inno_hdmi_phy_rk3328_clk_ops = {\n\t.prepare = inno_hdmi_phy_rk3328_clk_prepare,\n\t.unprepare = inno_hdmi_phy_rk3328_clk_unprepare,\n\t.is_prepared = inno_hdmi_phy_rk3328_clk_is_prepared,\n\t.recalc_rate = inno_hdmi_phy_rk3328_clk_recalc_rate,\n\t.round_rate = inno_hdmi_phy_rk3328_clk_round_rate,\n\t.set_rate = inno_hdmi_phy_rk3328_clk_set_rate,\n};\n\nstatic int inno_hdmi_phy_clk_register(struct inno_hdmi_phy *inno)\n{\n\tstruct device *dev = inno->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct clk_init_data init;\n\tconst char *parent_name;\n\tint ret;\n\n\tparent_name = __clk_get_name(inno->refoclk);\n\n\tinit.parent_names = &parent_name;\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\tinit.name = \"pin_hd20_pclk\";\n\tinit.ops = inno->plat_data->clk_ops;\n\n\t \n\tof_property_read_string(np, \"clock-output-names\", &init.name);\n\n\tinno->hw.init = &init;\n\n\tinno->phyclk = devm_clk_register(dev, &inno->hw);\n\tif (IS_ERR(inno->phyclk)) {\n\t\tret = PTR_ERR(inno->phyclk);\n\t\tdev_err(dev, \"failed to register clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_clk_add_provider(np, of_clk_src_simple_get, inno->phyclk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register clock provider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int inno_hdmi_phy_rk3228_init(struct inno_hdmi_phy *inno)\n{\n\t \n\tinno_write(inno, 0x01, RK3228_BYPASS_RXSENSE_EN |\n\t\t   RK3228_BYPASS_PWRON_EN |\n\t\t   RK3228_BYPASS_PLLPD_EN);\n\tinno_update_bits(inno, 0x02, RK3228_BYPASS_PDATA_EN,\n\t\t\t RK3228_BYPASS_PDATA_EN);\n\n\t \n\tinno_update_bits(inno, 0xaa, RK3228_POST_PLL_CTRL_MANUAL,\n\t\t\t RK3228_POST_PLL_CTRL_MANUAL);\n\n\tinno->chip_version = 1;\n\n\treturn 0;\n}\n\nstatic int\ninno_hdmi_phy_rk3228_power_on(struct inno_hdmi_phy *inno,\n\t\t\t      const struct post_pll_config *cfg,\n\t\t\t      const struct phy_config *phy_cfg)\n{\n\tint ret;\n\tu32 v;\n\n\tinno_update_bits(inno, 0x02, RK3228_PDATAEN_DISABLE,\n\t\t\t RK3228_PDATAEN_DISABLE);\n\tinno_update_bits(inno, 0xe0, RK3228_PRE_PLL_POWER_DOWN |\n\t\t\t RK3228_POST_PLL_POWER_DOWN,\n\t\t\t RK3228_PRE_PLL_POWER_DOWN |\n\t\t\t RK3228_POST_PLL_POWER_DOWN);\n\n\t \n\tinno_update_bits(inno, 0xe9, RK3228_POST_PLL_PRE_DIV_MASK,\n\t\t\t RK3228_POST_PLL_PRE_DIV(cfg->prediv));\n\tinno_update_bits(inno, 0xeb, RK3228_POST_PLL_FB_DIV_8_MASK,\n\t\t\t RK3228_POST_PLL_FB_DIV_8(cfg->fbdiv));\n\tinno_write(inno, 0xea, RK3228_POST_PLL_FB_DIV_7_0(cfg->fbdiv));\n\n\tif (cfg->postdiv == 1) {\n\t\tinno_update_bits(inno, 0xe9, RK3228_POST_PLL_POST_DIV_ENABLE,\n\t\t\t\t 0);\n\t} else {\n\t\tint div = cfg->postdiv / 2 - 1;\n\n\t\tinno_update_bits(inno, 0xe9, RK3228_POST_PLL_POST_DIV_ENABLE,\n\t\t\t\t RK3228_POST_PLL_POST_DIV_ENABLE);\n\t\tinno_update_bits(inno, 0xeb, RK3228_POST_PLL_POST_DIV_MASK,\n\t\t\t\t RK3228_POST_PLL_POST_DIV(div));\n\t}\n\n\tfor (v = 0; v < 4; v++)\n\t\tinno_write(inno, 0xef + v, phy_cfg->regs[v]);\n\n\tinno_update_bits(inno, 0xe0, RK3228_PRE_PLL_POWER_DOWN |\n\t\t\t RK3228_POST_PLL_POWER_DOWN, 0);\n\tinno_update_bits(inno, 0xe1, RK3228_BANDGAP_ENABLE,\n\t\t\t RK3228_BANDGAP_ENABLE);\n\tinno_update_bits(inno, 0xe1, RK3228_TMDS_DRIVER_ENABLE,\n\t\t\t RK3228_TMDS_DRIVER_ENABLE);\n\n\t \n\tret = inno_poll(inno, 0xeb, v, v & RK3228_POST_PLL_LOCK_STATUS,\n\t\t\t100, 100000);\n\tif (ret) {\n\t\tdev_err(inno->dev, \"Post-PLL locking failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cfg->tmdsclock > 340000000)\n\t\tmsleep(100);\n\n\tinno_update_bits(inno, 0x02, RK3228_PDATAEN_DISABLE, 0);\n\treturn 0;\n}\n\nstatic void inno_hdmi_phy_rk3228_power_off(struct inno_hdmi_phy *inno)\n{\n\tinno_update_bits(inno, 0xe1, RK3228_TMDS_DRIVER_ENABLE, 0);\n\tinno_update_bits(inno, 0xe1, RK3228_BANDGAP_ENABLE, 0);\n\tinno_update_bits(inno, 0xe0, RK3228_POST_PLL_POWER_DOWN,\n\t\t\t RK3228_POST_PLL_POWER_DOWN);\n}\n\nstatic const struct inno_hdmi_phy_ops rk3228_hdmi_phy_ops = {\n\t.init = inno_hdmi_phy_rk3228_init,\n\t.power_on = inno_hdmi_phy_rk3228_power_on,\n\t.power_off = inno_hdmi_phy_rk3228_power_off,\n};\n\nstatic int inno_hdmi_phy_rk3328_init(struct inno_hdmi_phy *inno)\n{\n\tstruct nvmem_cell *cell;\n\tunsigned char *efuse_buf;\n\tsize_t len;\n\n\t \n\tinno_write(inno, 0x01, RK3328_BYPASS_RXSENSE_EN |\n\t\t   RK3328_BYPASS_POWERON_EN |\n\t\t   RK3328_BYPASS_PLLPD_EN);\n\tinno_write(inno, 0x02, RK3328_INT_POL_HIGH | RK3328_BYPASS_PDATA_EN |\n\t\t   RK3328_PDATA_EN);\n\n\t \n\tinno_write(inno, 0x05, 0);\n\tinno_write(inno, 0x07, 0);\n\n\t \n\tinno->chip_version = 1;\n\tcell = nvmem_cell_get(inno->dev, \"cpu-version\");\n\tif (IS_ERR(cell)) {\n\t\tif (PTR_ERR(cell) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\treturn 0;\n\t}\n\n\tefuse_buf = nvmem_cell_read(cell, &len);\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(efuse_buf))\n\t\treturn 0;\n\tif (len == 1)\n\t\tinno->chip_version = efuse_buf[0] + 1;\n\tkfree(efuse_buf);\n\n\treturn 0;\n}\n\nstatic int\ninno_hdmi_phy_rk3328_power_on(struct inno_hdmi_phy *inno,\n\t\t\t      const struct post_pll_config *cfg,\n\t\t\t      const struct phy_config *phy_cfg)\n{\n\tint ret;\n\tu32 v;\n\n\tinno_update_bits(inno, 0x02, RK3328_PDATA_EN, 0);\n\tinno_update_bits(inno, 0xaa, RK3328_POST_PLL_POWER_DOWN,\n\t\t\t RK3328_POST_PLL_POWER_DOWN);\n\n\tinno_write(inno, 0xac, RK3328_POST_PLL_FB_DIV_7_0(cfg->fbdiv));\n\tif (cfg->postdiv == 1) {\n\t\tinno_write(inno, 0xab, RK3328_POST_PLL_FB_DIV_8(cfg->fbdiv) |\n\t\t\t   RK3328_POST_PLL_PRE_DIV(cfg->prediv));\n\t\tinno_write(inno, 0xaa, RK3328_POST_PLL_REFCLK_SEL_TMDS |\n\t\t\t   RK3328_POST_PLL_POWER_DOWN);\n\t} else {\n\t\tv = (cfg->postdiv / 2) - 1;\n\t\tv &= RK3328_POST_PLL_POST_DIV_MASK;\n\t\tinno_write(inno, 0xad, v);\n\t\tinno_write(inno, 0xab, RK3328_POST_PLL_FB_DIV_8(cfg->fbdiv) |\n\t\t\t   RK3328_POST_PLL_PRE_DIV(cfg->prediv));\n\t\tinno_write(inno, 0xaa, RK3328_POST_PLL_POST_DIV_ENABLE |\n\t\t\t   RK3328_POST_PLL_REFCLK_SEL_TMDS |\n\t\t\t   RK3328_POST_PLL_POWER_DOWN);\n\t}\n\n\tfor (v = 0; v < 14; v++)\n\t\tinno_write(inno, 0xb5 + v, phy_cfg->regs[v]);\n\n\t \n\tfor (v = 0; v < 4; v++)\n\t\tinno_update_bits(inno, 0xc8 + v, RK3328_ESD_DETECT_MASK,\n\t\t\t\t RK3328_ESD_DETECT_340MV);\n\n\tif (phy_cfg->tmdsclock > 340000000) {\n\t\t \n\t\tv = clk_get_rate(inno->sysclk) / 100000;\n\t\tinno_write(inno, 0xc5, RK3328_TERM_RESISTOR_CALIB_SPEED_14_8(v)\n\t\t\t   | RK3328_BYPASS_TERM_RESISTOR_CALIB);\n\t\tinno_write(inno, 0xc6, RK3328_TERM_RESISTOR_CALIB_SPEED_7_0(v));\n\t\tinno_write(inno, 0xc7, RK3328_TERM_RESISTOR_100);\n\t\tinno_update_bits(inno, 0xc5,\n\t\t\t\t RK3328_BYPASS_TERM_RESISTOR_CALIB, 0);\n\t} else {\n\t\tinno_write(inno, 0xc5, RK3328_BYPASS_TERM_RESISTOR_CALIB);\n\n\t\t \n\t\tif (phy_cfg->tmdsclock > 165000000)\n\t\t\tinno_update_bits(inno, 0xc8,\n\t\t\t\t\t RK3328_TMDS_TERM_RESIST_MASK,\n\t\t\t\t\t RK3328_TMDS_TERM_RESIST_75 |\n\t\t\t\t\t RK3328_TMDS_TERM_RESIST_150);\n\n\t\t \n\t\tfor (v = 0; v < 3; v++)\n\t\t\tinno_update_bits(inno, 0xc9 + v,\n\t\t\t\t\t RK3328_TMDS_TERM_RESIST_MASK,\n\t\t\t\t\t RK3328_TMDS_TERM_RESIST_150);\n\t}\n\n\tinno_update_bits(inno, 0xaa, RK3328_POST_PLL_POWER_DOWN, 0);\n\tinno_update_bits(inno, 0xb0, RK3328_BANDGAP_ENABLE,\n\t\t\t RK3328_BANDGAP_ENABLE);\n\tinno_update_bits(inno, 0xb2, RK3328_TMDS_DRIVER_ENABLE,\n\t\t\t RK3328_TMDS_DRIVER_ENABLE);\n\n\t \n\tret = inno_poll(inno, 0xaf, v, v & RK3328_POST_PLL_LOCK_STATUS,\n\t\t\t1000, 10000);\n\tif (ret) {\n\t\tdev_err(inno->dev, \"Post-PLL locking failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (phy_cfg->tmdsclock > 340000000)\n\t\tmsleep(100);\n\n\tinno_update_bits(inno, 0x02, RK3328_PDATA_EN, RK3328_PDATA_EN);\n\n\t \n\tinno_write(inno, 0x05, RK3328_INT_TMDS_CLK(RK3328_INT_VSS_AGND_ESD_DET)\n\t\t   | RK3328_INT_TMDS_D2(RK3328_INT_VSS_AGND_ESD_DET));\n\tinno_write(inno, 0x07, RK3328_INT_TMDS_D1(RK3328_INT_VSS_AGND_ESD_DET)\n\t\t   | RK3328_INT_TMDS_D0(RK3328_INT_VSS_AGND_ESD_DET));\n\treturn 0;\n}\n\nstatic void inno_hdmi_phy_rk3328_power_off(struct inno_hdmi_phy *inno)\n{\n\tinno_update_bits(inno, 0xb2, RK3328_TMDS_DRIVER_ENABLE, 0);\n\tinno_update_bits(inno, 0xb0, RK3328_BANDGAP_ENABLE, 0);\n\tinno_update_bits(inno, 0xaa, RK3328_POST_PLL_POWER_DOWN,\n\t\t\t RK3328_POST_PLL_POWER_DOWN);\n\n\t \n\tinno_write(inno, 0x05, 0);\n\tinno_write(inno, 0x07, 0);\n}\n\nstatic const struct inno_hdmi_phy_ops rk3328_hdmi_phy_ops = {\n\t.init = inno_hdmi_phy_rk3328_init,\n\t.power_on = inno_hdmi_phy_rk3328_power_on,\n\t.power_off = inno_hdmi_phy_rk3328_power_off,\n};\n\nstatic const struct inno_hdmi_phy_drv_data rk3228_hdmi_phy_drv_data = {\n\t.ops = &rk3228_hdmi_phy_ops,\n\t.clk_ops = &inno_hdmi_phy_rk3228_clk_ops,\n\t.phy_cfg_table = rk3228_phy_cfg,\n};\n\nstatic const struct inno_hdmi_phy_drv_data rk3328_hdmi_phy_drv_data = {\n\t.ops = &rk3328_hdmi_phy_ops,\n\t.clk_ops = &inno_hdmi_phy_rk3328_clk_ops,\n\t.phy_cfg_table = rk3328_phy_cfg,\n};\n\nstatic const struct regmap_config inno_hdmi_phy_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = 0x400,\n};\n\nstatic void inno_hdmi_phy_action(void *data)\n{\n\tstruct inno_hdmi_phy *inno = data;\n\n\tclk_disable_unprepare(inno->refpclk);\n\tclk_disable_unprepare(inno->sysclk);\n}\n\nstatic int inno_hdmi_phy_probe(struct platform_device *pdev)\n{\n\tstruct inno_hdmi_phy *inno;\n\tstruct phy_provider *phy_provider;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tinno = devm_kzalloc(&pdev->dev, sizeof(*inno), GFP_KERNEL);\n\tif (!inno)\n\t\treturn -ENOMEM;\n\n\tinno->dev = &pdev->dev;\n\n\tinno->plat_data = of_device_get_match_data(inno->dev);\n\tif (!inno->plat_data || !inno->plat_data->ops)\n\t\treturn -EINVAL;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tinno->sysclk = devm_clk_get(inno->dev, \"sysclk\");\n\tif (IS_ERR(inno->sysclk)) {\n\t\tret = PTR_ERR(inno->sysclk);\n\t\tdev_err(inno->dev, \"failed to get sysclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinno->refpclk = devm_clk_get(inno->dev, \"refpclk\");\n\tif (IS_ERR(inno->refpclk)) {\n\t\tret = PTR_ERR(inno->refpclk);\n\t\tdev_err(inno->dev, \"failed to get ref clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinno->refoclk = devm_clk_get(inno->dev, \"refoclk\");\n\tif (IS_ERR(inno->refoclk)) {\n\t\tret = PTR_ERR(inno->refoclk);\n\t\tdev_err(inno->dev, \"failed to get oscillator-ref clock: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(inno->sysclk);\n\tif (ret) {\n\t\tdev_err(inno->dev, \"Cannot enable inno phy sysclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_prepare_enable(inno->refpclk);\n\tif (ret) {\n\t\tdev_err(inno->dev, \"failed to enable refpclk\\n\");\n\t\tclk_disable_unprepare(inno->sysclk);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(inno->dev, inno_hdmi_phy_action,\n\t\t\t\t       inno);\n\tif (ret)\n\t\treturn ret;\n\n\tinno->regmap = devm_regmap_init_mmio(inno->dev, regs,\n\t\t\t\t\t     &inno_hdmi_phy_regmap_config);\n\tif (IS_ERR(inno->regmap))\n\t\treturn PTR_ERR(inno->regmap);\n\n\t \n\tinno->irq = platform_get_irq(pdev, 0);\n\tif (inno->irq > 0) {\n\t\tret = devm_request_threaded_irq(inno->dev, inno->irq,\n\t\t\t\t\t\tinno_hdmi_phy_rk3328_hardirq,\n\t\t\t\t\t\tinno_hdmi_phy_rk3328_irq,\n\t\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\t\tdev_name(inno->dev), inno);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinno->phy = devm_phy_create(inno->dev, NULL, &inno_hdmi_phy_ops);\n\tif (IS_ERR(inno->phy)) {\n\t\tdev_err(inno->dev, \"failed to create HDMI PHY\\n\");\n\t\treturn PTR_ERR(inno->phy);\n\t}\n\n\tphy_set_drvdata(inno->phy, inno);\n\tphy_set_bus_width(inno->phy, 8);\n\n\tif (inno->plat_data->ops->init) {\n\t\tret = inno->plat_data->ops->init(inno);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = inno_hdmi_phy_clk_register(inno);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_provider = devm_of_phy_provider_register(inno->dev,\n\t\t\t\t\t\t     of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic void inno_hdmi_phy_remove(struct platform_device *pdev)\n{\n\tof_clk_del_provider(pdev->dev.of_node);\n}\n\nstatic const struct of_device_id inno_hdmi_phy_of_match[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3228-hdmi-phy\",\n\t\t.data = &rk3228_hdmi_phy_drv_data\n\t}, {\n\t\t.compatible = \"rockchip,rk3328-hdmi-phy\",\n\t\t.data = &rk3328_hdmi_phy_drv_data\n\t}, {   }\n};\nMODULE_DEVICE_TABLE(of, inno_hdmi_phy_of_match);\n\nstatic struct platform_driver inno_hdmi_phy_driver = {\n\t.probe  = inno_hdmi_phy_probe,\n\t.remove_new = inno_hdmi_phy_remove,\n\t.driver = {\n\t\t.name = \"inno-hdmi-phy\",\n\t\t.of_match_table = inno_hdmi_phy_of_match,\n\t},\n};\nmodule_platform_driver(inno_hdmi_phy_driver);\n\nMODULE_AUTHOR(\"Zheng Yang <zhengyang@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Innosilion HDMI 2.0 Transmitter PHY Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}