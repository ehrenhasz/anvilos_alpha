{
  "module_name": "phy-sunplus-usb2.c",
  "hash_id": "5529b5d8061b6ae2873b0901a95a13bf852c6298a3db4f47445eb04e4ce3a540",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/sunplus/phy-sunplus-usb2.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#define HIGH_MASK_BITS\t\t\t\tGENMASK(31, 16)\n#define LOW_MASK_BITS\t\t\t\tGENMASK(15, 0)\n#define OTP_DISC_LEVEL_DEFAULT\t\t\t0xd\n\n \n#define CONFIG1\t\t\t\t\t0x4\n#define J_HS_TX_PWRSAV\t\t\t\tBIT(5)\n#define CONFIG3\t\t\t\t\t0xc\n#define J_FORCE_DISC_ON\t\t\t\tBIT(5)\n#define J_DEBUG_CTRL_ADDR_MACRO\t\t\tBIT(0)\n#define CONFIG7\t\t\t\t\t0x1c\n#define J_DISC\t\t\t\t\t0X1f\n#define CONFIG9\t\t\t\t\t0x24\n#define J_ECO_PATH\t\t\t\tBIT(6)\n#define CONFIG16\t\t\t\t0x40\n#define J_TBCWAIT_MASK\t\t\t\tGENMASK(6, 5)\n#define J_TBCWAIT_1P1_MS\t\t\tFIELD_PREP(J_TBCWAIT_MASK, 0)\n#define J_TVDM_SRC_DIS_MASK\t\t\tGENMASK(4, 3)\n#define J_TVDM_SRC_DIS_8P2_MS\t\t\tFIELD_PREP(J_TVDM_SRC_DIS_MASK, 3)\n#define J_TVDM_SRC_EN_MASK\t\t\tGENMASK(2, 1)\n#define J_TVDM_SRC_EN_1P6_MS\t\t\tFIELD_PREP(J_TVDM_SRC_EN_MASK, 0)\n#define J_BC_EN\t\t\t\t\tBIT(0)\n#define CONFIG17\t\t\t\t0x44\n#define IBG_TRIM0_MASK\t\t\t\tGENMASK(7, 5)\n#define IBG_TRIM0_SSLVHT\t\t\tFIELD_PREP(IBG_TRIM0_MASK, 4)\n#define J_VDATREE_TRIM_MASK\t\t\tGENMASK(4, 1)\n#define J_VDATREE_TRIM_DEFAULT\t\t\tFIELD_PREP(J_VDATREE_TRIM_MASK, 9)\n#define CONFIG23\t\t\t\t0x5c\n#define PROB_MASK\t\t\t\tGENMASK(5, 3)\n#define PROB\t\t\t\t\tFIELD_PREP(PROB_MASK, 7)\n\n \n#define UPHY_CONTROL0\t\t\t\t0x0\n#define UPHY_CONTROL1\t\t\t\t0x4\n#define UPHY_CONTROL2\t\t\t\t0x8\n#define MO1_UPHY_RX_CLK_SEL\t\t\tBIT(6)\n#define MASK_MO1_UPHY_RX_CLK_SEL\t\tBIT(6 + 16)\n#define UPHY_CONTROL3\t\t\t\t0xc\n#define MO1_UPHY_PLL_POWER_OFF_SEL\t\tBIT(7)\n#define MASK_MO1_UPHY_PLL_POWER_OFF_SEL\t\tBIT(7 + 16)\n#define MO1_UPHY_PLL_POWER_OFF\t\t\tBIT(3)\n#define MASK_UPHY_PLL_POWER_OFF\t\t\tBIT(3 + 16)\n\nstruct sp_usbphy {\n\tstruct device *dev;\n\tstruct resource *phy_res_mem;\n\tstruct resource *moon4_res_mem;\n\tstruct reset_control *rstc;\n\tstruct clk *phy_clk;\n\tvoid __iomem *phy_regs;\n\tvoid __iomem *moon4_regs;\n\tu32 disc_vol_addr_off;\n};\n\nstatic int update_disc_vol(struct sp_usbphy *usbphy)\n{\n\tstruct nvmem_cell *cell;\n\tchar *disc_name = \"disc_vol\";\n\tssize_t otp_l = 0;\n\tchar *otp_v;\n\tu32 val, set;\n\n\tcell = nvmem_cell_get(usbphy->dev, disc_name);\n\tif (IS_ERR_OR_NULL(cell)) {\n\t\tif (PTR_ERR(cell) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\totp_v = nvmem_cell_read(cell, &otp_l);\n\tnvmem_cell_put(cell);\n\n\tif (!IS_ERR(otp_v)) {\n\t\tset = *(otp_v + 1);\n\t\tset = (set << (sizeof(char) * 8)) | *otp_v;\n\t\tset = (set >> usbphy->disc_vol_addr_off) & J_DISC;\n\t}\n\n\tif (IS_ERR(otp_v) || set == 0)\n\t\tset = OTP_DISC_LEVEL_DEFAULT;\n\n\tval = readl(usbphy->phy_regs + CONFIG7);\n\tval = (val & ~J_DISC) | set;\n\twritel(val, usbphy->phy_regs + CONFIG7);\n\n\treturn 0;\n}\n\nstatic int sp_uphy_init(struct phy *phy)\n{\n\tstruct sp_usbphy *usbphy = phy_get_drvdata(phy);\n\tu32 val;\n\tint ret;\n\n\tret = clk_prepare_enable(usbphy->phy_clk);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tret = reset_control_deassert(usbphy->rstc);\n\tif (ret)\n\t\tgoto err_reset;\n\n\t \n\twritel(HIGH_MASK_BITS | 0x4002, usbphy->moon4_regs + UPHY_CONTROL0);\n\twritel(HIGH_MASK_BITS | 0x8747, usbphy->moon4_regs + UPHY_CONTROL1);\n\n\t \n\tret = update_disc_vol(usbphy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = readl(usbphy->phy_regs + CONFIG9);\n\tval &= ~(J_ECO_PATH);\n\twritel(val, usbphy->phy_regs + CONFIG9);\n\n\tval = readl(usbphy->phy_regs + CONFIG1);\n\tval &= ~(J_HS_TX_PWRSAV);\n\twritel(val, usbphy->phy_regs + CONFIG1);\n\n\tval = readl(usbphy->phy_regs + CONFIG23);\n\tval = (val & ~PROB) | PROB;\n\twritel(val, usbphy->phy_regs + CONFIG23);\n\n\t \n\twritel(MASK_MO1_UPHY_RX_CLK_SEL | MO1_UPHY_RX_CLK_SEL,\n\t       usbphy->moon4_regs + UPHY_CONTROL2);\n\n\t \n\twritel(J_TBCWAIT_1P1_MS | J_TVDM_SRC_DIS_8P2_MS | J_TVDM_SRC_EN_1P6_MS | J_BC_EN,\n\t       usbphy->phy_regs + CONFIG16);\n\twritel(IBG_TRIM0_SSLVHT | J_VDATREE_TRIM_DEFAULT, usbphy->phy_regs + CONFIG17);\n\n\t \n\twritel(J_FORCE_DISC_ON | J_DEBUG_CTRL_ADDR_MACRO, usbphy->phy_regs + CONFIG3);\n\n\treturn 0;\n\nerr_reset:\n\treset_control_assert(usbphy->rstc);\nerr_clk:\n\tclk_disable_unprepare(usbphy->phy_clk);\n\n\treturn ret;\n}\n\nstatic int sp_uphy_power_on(struct phy *phy)\n{\n\tstruct sp_usbphy *usbphy = phy_get_drvdata(phy);\n\tu32 pll_pwr_on, pll_pwr_off;\n\n\t \n\tpll_pwr_off = (readl(usbphy->moon4_regs + UPHY_CONTROL3) & ~LOW_MASK_BITS)\n\t\t\t| MO1_UPHY_PLL_POWER_OFF_SEL | MO1_UPHY_PLL_POWER_OFF;\n\tpll_pwr_on = (readl(usbphy->moon4_regs + UPHY_CONTROL3) & ~LOW_MASK_BITS)\n\t\t\t| MO1_UPHY_PLL_POWER_OFF_SEL;\n\n\twritel(MASK_MO1_UPHY_PLL_POWER_OFF_SEL | MASK_UPHY_PLL_POWER_OFF | pll_pwr_off,\n\t       usbphy->moon4_regs + UPHY_CONTROL3);\n\tmdelay(1);\n\twritel(MASK_MO1_UPHY_PLL_POWER_OFF_SEL | MASK_UPHY_PLL_POWER_OFF | pll_pwr_on,\n\t       usbphy->moon4_regs + UPHY_CONTROL3);\n\tmdelay(1);\n\twritel(MASK_MO1_UPHY_PLL_POWER_OFF_SEL | MASK_UPHY_PLL_POWER_OFF | pll_pwr_off,\n\t       usbphy->moon4_regs + UPHY_CONTROL3);\n\tmdelay(1);\n\twritel(MASK_MO1_UPHY_PLL_POWER_OFF_SEL | MASK_UPHY_PLL_POWER_OFF | pll_pwr_on,\n\t       usbphy->moon4_regs + UPHY_CONTROL3);\n\tmdelay(1);\n\twritel(MASK_MO1_UPHY_PLL_POWER_OFF_SEL | MASK_UPHY_PLL_POWER_OFF | 0x0,\n\t       usbphy->moon4_regs + UPHY_CONTROL3);\n\n\treturn 0;\n}\n\nstatic int sp_uphy_power_off(struct phy *phy)\n{\n\tstruct sp_usbphy *usbphy = phy_get_drvdata(phy);\n\tu32 pll_pwr_off;\n\n\tpll_pwr_off = (readl(usbphy->moon4_regs + UPHY_CONTROL3) & ~LOW_MASK_BITS)\n\t\t\t| MO1_UPHY_PLL_POWER_OFF_SEL | MO1_UPHY_PLL_POWER_OFF;\n\n\twritel(MASK_MO1_UPHY_PLL_POWER_OFF_SEL | MASK_UPHY_PLL_POWER_OFF | pll_pwr_off,\n\t       usbphy->moon4_regs + UPHY_CONTROL3);\n\tmdelay(1);\n\twritel(MASK_MO1_UPHY_PLL_POWER_OFF_SEL | MASK_UPHY_PLL_POWER_OFF | 0x0,\n\t       usbphy->moon4_regs + UPHY_CONTROL3);\n\n\treturn 0;\n}\n\nstatic int sp_uphy_exit(struct phy *phy)\n{\n\tstruct sp_usbphy *usbphy = phy_get_drvdata(phy);\n\n\treset_control_assert(usbphy->rstc);\n\tclk_disable_unprepare(usbphy->phy_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops sp_uphy_ops = {\n\t.init\t\t= sp_uphy_init,\n\t.power_on\t= sp_uphy_power_on,\n\t.power_off\t= sp_uphy_power_off,\n\t.exit\t\t= sp_uphy_exit,\n};\n\nstatic const struct of_device_id sp_uphy_dt_ids[] = {\n\t{.compatible = \"sunplus,sp7021-usb2-phy\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sp_uphy_dt_ids);\n\nstatic int sp_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct sp_usbphy *usbphy;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *phy;\n\tint ret;\n\n\tusbphy = devm_kzalloc(&pdev->dev, sizeof(*usbphy), GFP_KERNEL);\n\tif (!usbphy)\n\t\treturn -ENOMEM;\n\n\tusbphy->dev = &pdev->dev;\n\n\tusbphy->phy_res_mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"phy\");\n\tusbphy->phy_regs = devm_ioremap_resource(&pdev->dev, usbphy->phy_res_mem);\n\tif (IS_ERR(usbphy->phy_regs))\n\t\treturn PTR_ERR(usbphy->phy_regs);\n\n\tusbphy->moon4_res_mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"moon4\");\n\tif (!usbphy->moon4_res_mem)\n\t\treturn -EINVAL;\n\n\tusbphy->moon4_regs = devm_ioremap(&pdev->dev, usbphy->moon4_res_mem->start,\n\t\t\t\t\t  resource_size(usbphy->moon4_res_mem));\n\tif (!usbphy->moon4_regs)\n\t\treturn -ENOMEM;\n\n\tusbphy->phy_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(usbphy->phy_clk))\n\t\treturn PTR_ERR(usbphy->phy_clk);\n\n\tusbphy->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(usbphy->rstc))\n\t\treturn PTR_ERR(usbphy->rstc);\n\n\tof_property_read_u32(pdev->dev.of_node, \"sunplus,disc-vol-addr-off\",\n\t\t\t     &usbphy->disc_vol_addr_off);\n\n\tphy = devm_phy_create(&pdev->dev, NULL, &sp_uphy_ops);\n\tif (IS_ERR(phy)) {\n\t\tret = PTR_ERR(phy);\n\t\treturn ret;\n\t}\n\n\tphy_set_drvdata(phy, usbphy);\n\tphy_provider = devm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver sunplus_usb_phy_driver = {\n\t.probe\t\t= sp_usb_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"sunplus-usb2-phy\",\n\t\t.of_match_table = sp_uphy_dt_ids,\n\t},\n};\nmodule_platform_driver(sunplus_usb_phy_driver);\n\nMODULE_AUTHOR(\"Vincent Shih <vincent.shih@sunplus.com>\");\nMODULE_DESCRIPTION(\"Sunplus USB 2.0 phy driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}