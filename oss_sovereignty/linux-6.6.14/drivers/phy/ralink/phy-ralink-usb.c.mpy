{
  "module_name": "phy-ralink-usb.c",
  "hash_id": "13397c16035850fab98e0d830f1d9cf6c195ce34eabb9636da8f93c3e5fb5916",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ralink/phy-ralink-usb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#define RT_SYSC_REG_SYSCFG1\t\t0x014\n#define RT_SYSC_REG_CLKCFG1\t\t0x030\n#define RT_SYSC_REG_USB_PHY_CFG\t\t0x05c\n\n#define OFS_U2_PHY_AC0\t\t\t0x800\n#define OFS_U2_PHY_AC1\t\t\t0x804\n#define OFS_U2_PHY_AC2\t\t\t0x808\n#define OFS_U2_PHY_ACR0\t\t\t0x810\n#define OFS_U2_PHY_ACR1\t\t\t0x814\n#define OFS_U2_PHY_ACR2\t\t\t0x818\n#define OFS_U2_PHY_ACR3\t\t\t0x81C\n#define OFS_U2_PHY_ACR4\t\t\t0x820\n#define OFS_U2_PHY_AMON0\t\t0x824\n#define OFS_U2_PHY_DCR0\t\t\t0x860\n#define OFS_U2_PHY_DCR1\t\t\t0x864\n#define OFS_U2_PHY_DTM0\t\t\t0x868\n#define OFS_U2_PHY_DTM1\t\t\t0x86C\n\n#define RT_RSTCTRL_UDEV\t\t\tBIT(25)\n#define RT_RSTCTRL_UHST\t\t\tBIT(22)\n#define RT_SYSCFG1_USB0_HOST_MODE\tBIT(10)\n\n#define MT7620_CLKCFG1_UPHY0_CLK_EN\tBIT(25)\n#define MT7620_CLKCFG1_UPHY1_CLK_EN\tBIT(22)\n#define RT_CLKCFG1_UPHY1_CLK_EN\t\tBIT(20)\n#define RT_CLKCFG1_UPHY0_CLK_EN\t\tBIT(18)\n\n#define USB_PHY_UTMI_8B60M\t\tBIT(1)\n#define UDEV_WAKEUP\t\t\tBIT(0)\n\nstruct ralink_usb_phy {\n\tstruct reset_control\t*rstdev;\n\tstruct reset_control\t*rsthost;\n\tu32\t\t\tclk;\n\tstruct phy\t\t*phy;\n\tvoid __iomem\t\t*base;\n\tstruct regmap\t\t*sysctl;\n};\n\nstatic void u2_phy_w32(struct ralink_usb_phy *phy, u32 val, u32 reg)\n{\n\twritel(val, phy->base + reg);\n}\n\nstatic u32 u2_phy_r32(struct ralink_usb_phy *phy, u32 reg)\n{\n\treturn readl(phy->base + reg);\n}\n\nstatic void ralink_usb_phy_init(struct ralink_usb_phy *phy)\n{\n\tu2_phy_r32(phy, OFS_U2_PHY_AC2);\n\tu2_phy_r32(phy, OFS_U2_PHY_ACR0);\n\tu2_phy_r32(phy, OFS_U2_PHY_DCR0);\n\n\tu2_phy_w32(phy, 0x00ffff02, OFS_U2_PHY_DCR0);\n\tu2_phy_r32(phy, OFS_U2_PHY_DCR0);\n\tu2_phy_w32(phy, 0x00555502, OFS_U2_PHY_DCR0);\n\tu2_phy_r32(phy, OFS_U2_PHY_DCR0);\n\tu2_phy_w32(phy, 0x00aaaa02, OFS_U2_PHY_DCR0);\n\tu2_phy_r32(phy, OFS_U2_PHY_DCR0);\n\tu2_phy_w32(phy, 0x00000402, OFS_U2_PHY_DCR0);\n\tu2_phy_r32(phy, OFS_U2_PHY_DCR0);\n\tu2_phy_w32(phy, 0x0048086a, OFS_U2_PHY_AC0);\n\tu2_phy_w32(phy, 0x4400001c, OFS_U2_PHY_AC1);\n\tu2_phy_w32(phy, 0xc0200000, OFS_U2_PHY_ACR3);\n\tu2_phy_w32(phy, 0x02000000, OFS_U2_PHY_DTM0);\n}\n\nstatic int ralink_usb_phy_power_on(struct phy *_phy)\n{\n\tstruct ralink_usb_phy *phy = phy_get_drvdata(_phy);\n\tu32 t;\n\n\t \n\tregmap_update_bits(phy->sysctl, RT_SYSC_REG_CLKCFG1,\n\t\t\t   phy->clk, phy->clk);\n\n\t \n\tregmap_update_bits(phy->sysctl, RT_SYSC_REG_SYSCFG1,\n\t\t\t   RT_SYSCFG1_USB0_HOST_MODE,\n\t\t\t   RT_SYSCFG1_USB0_HOST_MODE);\n\n\t \n\treset_control_deassert(phy->rsthost);\n\treset_control_deassert(phy->rstdev);\n\n\t \n\tmdelay(10);\n\n\tif (phy->base)\n\t\tralink_usb_phy_init(phy);\n\n\t \n\tregmap_read(phy->sysctl, RT_SYSC_REG_USB_PHY_CFG, &t);\n\tdev_info(&phy->phy->dev, \"remote usb device wakeup %s\\n\",\n\t\t(t & UDEV_WAKEUP) ? (\"enabled\") : (\"disabled\"));\n\tif (t & USB_PHY_UTMI_8B60M)\n\t\tdev_info(&phy->phy->dev, \"UTMI 8bit 60MHz\\n\");\n\telse\n\t\tdev_info(&phy->phy->dev, \"UTMI 16bit 30MHz\\n\");\n\n\treturn 0;\n}\n\nstatic int ralink_usb_phy_power_off(struct phy *_phy)\n{\n\tstruct ralink_usb_phy *phy = phy_get_drvdata(_phy);\n\n\t \n\tregmap_update_bits(phy->sysctl, RT_SYSC_REG_CLKCFG1,\n\t\t\t   phy->clk, 0);\n\n\t \n\treset_control_assert(phy->rstdev);\n\treset_control_assert(phy->rsthost);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ralink_usb_phy_ops = {\n\t.power_on\t= ralink_usb_phy_power_on,\n\t.power_off\t= ralink_usb_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id ralink_usb_phy_of_match[] = {\n\t{\n\t\t.compatible = \"ralink,rt3352-usbphy\",\n\t\t.data = (void *)(uintptr_t)(RT_CLKCFG1_UPHY1_CLK_EN |\n\t\t\t\t\t    RT_CLKCFG1_UPHY0_CLK_EN)\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt7620-usbphy\",\n\t\t.data = (void *)(uintptr_t)(MT7620_CLKCFG1_UPHY1_CLK_EN |\n\t\t\t\t\t    MT7620_CLKCFG1_UPHY0_CLK_EN)\n\t},\n\t{\n\t\t.compatible = \"mediatek,mt7628-usbphy\",\n\t\t.data = (void *)(uintptr_t)(MT7620_CLKCFG1_UPHY1_CLK_EN |\n\t\t\t\t\t    MT7620_CLKCFG1_UPHY0_CLK_EN) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ralink_usb_phy_of_match);\n\nstatic int ralink_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tconst struct of_device_id *match;\n\tstruct ralink_usb_phy *phy;\n\n\tmatch = of_match_device(ralink_usb_phy_of_match, &pdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->clk = (uintptr_t)match->data;\n\tphy->base = NULL;\n\n\tphy->sysctl = syscon_regmap_lookup_by_phandle(dev->of_node, \"ralink,sysctl\");\n\tif (IS_ERR(phy->sysctl)) {\n\t\tdev_err(dev, \"failed to get sysctl registers\\n\");\n\t\treturn PTR_ERR(phy->sysctl);\n\t}\n\n\t \n\tif (of_device_is_compatible(dev->of_node, \"mediatek,mt7628-usbphy\")) {\n\t\tphy->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(phy->base)) {\n\t\t\tdev_err(dev, \"failed to remap register memory\\n\");\n\t\t\treturn PTR_ERR(phy->base);\n\t\t}\n\t}\n\n\tphy->rsthost = devm_reset_control_get(&pdev->dev, \"host\");\n\tif (IS_ERR(phy->rsthost)) {\n\t\tdev_err(dev, \"host reset is missing\\n\");\n\t\treturn PTR_ERR(phy->rsthost);\n\t}\n\n\tphy->rstdev = devm_reset_control_get(&pdev->dev, \"device\");\n\tif (IS_ERR(phy->rstdev)) {\n\t\tdev_err(dev, \"device reset is missing\\n\");\n\t\treturn PTR_ERR(phy->rstdev);\n\t}\n\n\tphy->phy = devm_phy_create(dev, NULL, &ralink_usb_phy_ops);\n\tif (IS_ERR(phy->phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(phy->phy);\n\t}\n\tphy_set_drvdata(phy->phy, phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver ralink_usb_phy_driver = {\n\t.probe\t= ralink_usb_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= ralink_usb_phy_of_match,\n\t\t.name  = \"ralink-usb-phy\",\n\t}\n};\nmodule_platform_driver(ralink_usb_phy_driver);\n\nMODULE_DESCRIPTION(\"Ralink USB phy driver\");\nMODULE_AUTHOR(\"John Crispin <john@phrozen.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}