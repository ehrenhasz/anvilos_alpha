{
  "module_name": "phy-mt7621-pci.c",
  "hash_id": "2115fa5b6d0ca06a9fe09ce9736217ac36edd7c58d31391b27548964d1904b31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ralink/phy-mt7621-pci.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/phy/phy.h>\n#include <linux/clk.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/sys_soc.h>\n\n#define RG_PE1_PIPE_REG\t\t\t\t0x02c\n#define RG_PE1_PIPE_RST\t\t\t\tBIT(12)\n#define RG_PE1_PIPE_CMD_FRC\t\t\tBIT(4)\n\n#define RG_P0_TO_P1_WIDTH\t\t\t0x100\n#define RG_PE1_H_LCDDS_REG\t\t\t0x49c\n#define RG_PE1_H_LCDDS_PCW\t\t\tGENMASK(30, 0)\n\n#define RG_PE1_FRC_H_XTAL_REG\t\t\t0x400\n#define RG_PE1_FRC_H_XTAL_TYPE\t\t\tBIT(8)\n#define RG_PE1_H_XTAL_TYPE\t\t\tGENMASK(10, 9)\n\n#define RG_PE1_FRC_PHY_REG\t\t\t0x000\n#define RG_PE1_FRC_PHY_EN\t\t\tBIT(4)\n#define RG_PE1_PHY_EN\t\t\t\tBIT(5)\n\n#define RG_PE1_H_PLL_REG\t\t\t0x490\n#define RG_PE1_H_PLL_BC\t\t\t\tGENMASK(23, 22)\n#define RG_PE1_H_PLL_BP\t\t\t\tGENMASK(21, 18)\n#define RG_PE1_H_PLL_IR\t\t\t\tGENMASK(15, 12)\n#define RG_PE1_H_PLL_IC\t\t\t\tGENMASK(11, 8)\n#define RG_PE1_H_PLL_PREDIV\t\t\tGENMASK(7, 6)\n#define RG_PE1_PLL_DIVEN\t\t\tGENMASK(3, 1)\n\n#define RG_PE1_H_PLL_FBKSEL_REG\t\t\t0x4bc\n#define RG_PE1_H_PLL_FBKSEL\t\t\tGENMASK(5, 4)\n\n#define\tRG_PE1_H_LCDDS_SSC_PRD_REG\t\t0x4a4\n#define RG_PE1_H_LCDDS_SSC_PRD\t\t\tGENMASK(15, 0)\n\n#define RG_PE1_H_LCDDS_SSC_DELTA_REG\t\t0x4a8\n#define RG_PE1_H_LCDDS_SSC_DELTA\t\tGENMASK(11, 0)\n#define RG_PE1_H_LCDDS_SSC_DELTA1\t\tGENMASK(27, 16)\n\n#define RG_PE1_LCDDS_CLK_PH_INV_REG\t\t0x4a0\n#define RG_PE1_LCDDS_CLK_PH_INV\t\t\tBIT(5)\n\n#define RG_PE1_H_PLL_BR_REG\t\t\t0x4ac\n#define RG_PE1_H_PLL_BR\t\t\t\tGENMASK(18, 16)\n\n#define\tRG_PE1_MSTCKDIV_REG\t\t\t0x414\n#define RG_PE1_MSTCKDIV\t\t\t\tGENMASK(7, 6)\n\n#define RG_PE1_FRC_MSTCKDIV\t\t\tBIT(5)\n\n#define MAX_PHYS\t2\n\n \nstruct mt7621_pci_phy {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct phy *phy;\n\tstruct clk *sys_clk;\n\tvoid __iomem *port_base;\n\tbool has_dual_port;\n\tbool bypass_pipe_rst;\n};\n\nstatic inline void mt7621_phy_rmw(struct mt7621_pci_phy *phy,\n\t\t\t\t  u32 reg, u32 clr, u32 set)\n{\n\tu32 val;\n\n\t \n\tregmap_read(phy->regmap, reg, &val);\n\tval &= ~clr;\n\tval |= set;\n\tregmap_write(phy->regmap, reg, val);\n}\n\nstatic void mt7621_bypass_pipe_rst(struct mt7621_pci_phy *phy)\n{\n\tmt7621_phy_rmw(phy, RG_PE1_PIPE_REG, 0, RG_PE1_PIPE_RST);\n\tmt7621_phy_rmw(phy, RG_PE1_PIPE_REG, 0, RG_PE1_PIPE_CMD_FRC);\n\n\tif (phy->has_dual_port) {\n\t\tmt7621_phy_rmw(phy, RG_PE1_PIPE_REG + RG_P0_TO_P1_WIDTH,\n\t\t\t       0, RG_PE1_PIPE_RST);\n\t\tmt7621_phy_rmw(phy, RG_PE1_PIPE_REG + RG_P0_TO_P1_WIDTH,\n\t\t\t       0, RG_PE1_PIPE_CMD_FRC);\n\t}\n}\n\nstatic int mt7621_set_phy_for_ssc(struct mt7621_pci_phy *phy)\n{\n\tstruct device *dev = phy->dev;\n\tunsigned long clk_rate;\n\n\tclk_rate = clk_get_rate(phy->sys_clk);\n\tif (!clk_rate)\n\t\treturn -EINVAL;\n\n\t \n\t \n\tmt7621_phy_rmw(phy, RG_PE1_FRC_H_XTAL_REG,\n\t\t       RG_PE1_FRC_H_XTAL_TYPE | RG_PE1_H_XTAL_TYPE,\n\t\t       RG_PE1_FRC_H_XTAL_TYPE |\n\t\t       FIELD_PREP(RG_PE1_H_XTAL_TYPE, 0x00));\n\n\t \n\tmt7621_phy_rmw(phy, RG_PE1_FRC_PHY_REG, RG_PE1_PHY_EN,\n\t\t       RG_PE1_FRC_PHY_EN);\n\n\tif (phy->has_dual_port) {\n\t\tmt7621_phy_rmw(phy, RG_PE1_FRC_PHY_REG + RG_P0_TO_P1_WIDTH,\n\t\t\t       RG_PE1_PHY_EN, RG_PE1_FRC_PHY_EN);\n\t}\n\n\tif (clk_rate == 40000000) {  \n\t\t \n\t\tmt7621_phy_rmw(phy, RG_PE1_H_PLL_REG, RG_PE1_H_PLL_PREDIV,\n\t\t\t       FIELD_PREP(RG_PE1_H_PLL_PREDIV, 0x01));\n\n\t\tdev_dbg(dev, \"Xtal is 40MHz\\n\");\n\t} else if (clk_rate == 25000000) {  \n\t\tmt7621_phy_rmw(phy, RG_PE1_H_PLL_REG, RG_PE1_H_PLL_PREDIV,\n\t\t\t       FIELD_PREP(RG_PE1_H_PLL_PREDIV, 0x00));\n\n\t\t \n\t\tmt7621_phy_rmw(phy, RG_PE1_H_PLL_FBKSEL_REG,\n\t\t\t       RG_PE1_H_PLL_FBKSEL,\n\t\t\t       FIELD_PREP(RG_PE1_H_PLL_FBKSEL, 0x01));\n\n\t\t \n\t\tmt7621_phy_rmw(phy, RG_PE1_H_LCDDS_SSC_PRD_REG,\n\t\t\t       RG_PE1_H_LCDDS_SSC_PRD,\n\t\t\t       FIELD_PREP(RG_PE1_H_LCDDS_SSC_PRD, 0x00));\n\n\t\t \n\t\tmt7621_phy_rmw(phy, RG_PE1_H_LCDDS_SSC_PRD_REG,\n\t\t\t       RG_PE1_H_LCDDS_SSC_PRD,\n\t\t\t       FIELD_PREP(RG_PE1_H_LCDDS_SSC_PRD, 0x18d));\n\n\t\t \n\t\tmt7621_phy_rmw(phy, RG_PE1_H_LCDDS_SSC_DELTA_REG,\n\t\t\t       RG_PE1_H_LCDDS_SSC_DELTA |\n\t\t\t       RG_PE1_H_LCDDS_SSC_DELTA1,\n\t\t\t       FIELD_PREP(RG_PE1_H_LCDDS_SSC_DELTA, 0x4a) |\n\t\t\t       FIELD_PREP(RG_PE1_H_LCDDS_SSC_DELTA1, 0x4a));\n\n\t\tdev_dbg(dev, \"Xtal is 25MHz\\n\");\n\t} else {  \n\t\tmt7621_phy_rmw(phy, RG_PE1_H_PLL_REG, RG_PE1_H_PLL_PREDIV,\n\t\t\t       FIELD_PREP(RG_PE1_H_PLL_PREDIV, 0x00));\n\n\t\tdev_dbg(dev, \"Xtal is 20MHz\\n\");\n\t}\n\n\t \n\tmt7621_phy_rmw(phy, RG_PE1_LCDDS_CLK_PH_INV_REG,\n\t\t       RG_PE1_LCDDS_CLK_PH_INV, RG_PE1_LCDDS_CLK_PH_INV);\n\n\t \n\tmt7621_phy_rmw(phy, RG_PE1_H_PLL_REG,\n\t\t       RG_PE1_H_PLL_BC | RG_PE1_H_PLL_BP | RG_PE1_H_PLL_IR |\n\t\t       RG_PE1_H_PLL_IC | RG_PE1_PLL_DIVEN,\n\t\t       FIELD_PREP(RG_PE1_H_PLL_BC, 0x02) |\n\t\t       FIELD_PREP(RG_PE1_H_PLL_BP, 0x06) |\n\t\t       FIELD_PREP(RG_PE1_H_PLL_IR, 0x02) |\n\t\t       FIELD_PREP(RG_PE1_H_PLL_IC, 0x01) |\n\t\t       FIELD_PREP(RG_PE1_PLL_DIVEN, 0x02));\n\n\tmt7621_phy_rmw(phy, RG_PE1_H_PLL_BR_REG, RG_PE1_H_PLL_BR,\n\t\t       FIELD_PREP(RG_PE1_H_PLL_BR, 0x00));\n\n\tif (clk_rate == 40000000) {  \n\t\t \n\t\tmt7621_phy_rmw(phy, RG_PE1_MSTCKDIV_REG,\n\t\t\t       RG_PE1_MSTCKDIV | RG_PE1_FRC_MSTCKDIV,\n\t\t\t       FIELD_PREP(RG_PE1_MSTCKDIV, 0x01) |\n\t\t\t       RG_PE1_FRC_MSTCKDIV);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7621_pci_phy_init(struct phy *phy)\n{\n\tstruct mt7621_pci_phy *mphy = phy_get_drvdata(phy);\n\n\tif (mphy->bypass_pipe_rst)\n\t\tmt7621_bypass_pipe_rst(mphy);\n\n\treturn mt7621_set_phy_for_ssc(mphy);\n}\n\nstatic int mt7621_pci_phy_power_on(struct phy *phy)\n{\n\tstruct mt7621_pci_phy *mphy = phy_get_drvdata(phy);\n\n\t \n\tmt7621_phy_rmw(mphy, RG_PE1_FRC_PHY_REG,\n\t\t       RG_PE1_FRC_PHY_EN, RG_PE1_PHY_EN);\n\n\tif (mphy->has_dual_port) {\n\t\tmt7621_phy_rmw(mphy, RG_PE1_FRC_PHY_REG + RG_P0_TO_P1_WIDTH,\n\t\t\t       RG_PE1_FRC_PHY_EN, RG_PE1_PHY_EN);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7621_pci_phy_power_off(struct phy *phy)\n{\n\tstruct mt7621_pci_phy *mphy = phy_get_drvdata(phy);\n\n\t \n\tmt7621_phy_rmw(mphy, RG_PE1_FRC_PHY_REG,\n\t\t       RG_PE1_PHY_EN, RG_PE1_FRC_PHY_EN);\n\n\tif (mphy->has_dual_port) {\n\t\tmt7621_phy_rmw(mphy, RG_PE1_FRC_PHY_REG + RG_P0_TO_P1_WIDTH,\n\t\t\t       RG_PE1_PHY_EN, RG_PE1_FRC_PHY_EN);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7621_pci_phy_exit(struct phy *phy)\n{\n\treturn 0;\n}\n\nstatic const struct phy_ops mt7621_pci_phy_ops = {\n\t.init\t\t= mt7621_pci_phy_init,\n\t.exit\t\t= mt7621_pci_phy_exit,\n\t.power_on\t= mt7621_pci_phy_power_on,\n\t.power_off\t= mt7621_pci_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *mt7621_pcie_phy_of_xlate(struct device *dev,\n\t\t\t\t\t    struct of_phandle_args *args)\n{\n\tstruct mt7621_pci_phy *mt7621_phy = dev_get_drvdata(dev);\n\n\tif (WARN_ON(args->args[0] >= MAX_PHYS))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmt7621_phy->has_dual_port = args->args[0];\n\n\tdev_dbg(dev, \"PHY for 0x%px (dual port = %d)\\n\",\n\t\tmt7621_phy->port_base, mt7621_phy->has_dual_port);\n\n\treturn mt7621_phy->phy;\n}\n\nstatic const struct soc_device_attribute mt7621_pci_quirks_match[] = {\n\t{ .soc_id = \"mt7621\", .revision = \"E2\" },\n\t{   }\n};\n\nstatic const struct regmap_config mt7621_pci_phy_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = 0x700,\n};\n\nstatic int mt7621_pci_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct soc_device_attribute *attr;\n\tstruct phy_provider *provider;\n\tstruct mt7621_pci_phy *phy;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tattr = soc_device_match(mt7621_pci_quirks_match);\n\tif (attr)\n\t\tphy->bypass_pipe_rst = true;\n\n\tphy->dev = dev;\n\tplatform_set_drvdata(pdev, phy);\n\n\tphy->port_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->port_base)) {\n\t\tdev_err(dev, \"failed to remap phy regs\\n\");\n\t\treturn PTR_ERR(phy->port_base);\n\t}\n\n\tphy->regmap = devm_regmap_init_mmio(phy->dev, phy->port_base,\n\t\t\t\t\t    &mt7621_pci_phy_regmap_config);\n\tif (IS_ERR(phy->regmap))\n\t\treturn PTR_ERR(phy->regmap);\n\n\tphy->phy = devm_phy_create(dev, dev->of_node, &mt7621_pci_phy_ops);\n\tif (IS_ERR(phy->phy)) {\n\t\tdev_err(dev, \"failed to create phy\\n\");\n\t\treturn PTR_ERR(phy->phy);\n\t}\n\n\tphy->sys_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(phy->sys_clk)) {\n\t\tdev_err(dev, \"failed to get phy clock\\n\");\n\t\treturn PTR_ERR(phy->sys_clk);\n\t}\n\n\tphy_set_drvdata(phy->phy, phy);\n\n\tprovider = devm_of_phy_provider_register(dev, mt7621_pcie_phy_of_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id mt7621_pci_phy_ids[] = {\n\t{ .compatible = \"mediatek,mt7621-pci-phy\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mt7621_pci_phy_ids);\n\nstatic struct platform_driver mt7621_pci_phy_driver = {\n\t.probe = mt7621_pci_phy_probe,\n\t.driver = {\n\t\t.name = \"mt7621-pci-phy\",\n\t\t.of_match_table = mt7621_pci_phy_ids,\n\t},\n};\n\nbuiltin_platform_driver(mt7621_pci_phy_driver);\n\nMODULE_AUTHOR(\"Sergio Paracuellos <sergio.paracuellos@gmail.com>\");\nMODULE_DESCRIPTION(\"MediaTek MT7621 PCIe PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}