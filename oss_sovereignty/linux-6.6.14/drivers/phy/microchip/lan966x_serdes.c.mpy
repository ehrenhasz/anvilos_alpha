{
  "module_name": "lan966x_serdes.c",
  "hash_id": "a0cc2db18d8250d7951d29b254491f949831cd95f1588db6a7eb7408601dd94c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/microchip/lan966x_serdes.c",
  "human_readable_source": "\n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/phy/phy-lan966x-serdes.h>\n#include \"lan966x_serdes_regs.h\"\n\n#define PLL_CONF_MASK\t\tGENMASK(4, 3)\n#define PLL_CONF_25MHZ\t\t0\n#define PLL_CONF_125MHZ\t\t1\n#define PLL_CONF_SERDES_125MHZ\t2\n#define PLL_CONF_BYPASS\t\t3\n\n#define lan_offset_(id, tinst, tcnt,\t\t\t\\\n\t\t   gbase, ginst, gcnt, gwidth,\t\t\\\n\t\t   raddr, rinst, rcnt, rwidth)\t\t\\\n\t(gbase + ((ginst) * gwidth) + raddr + ((rinst) * rwidth))\n#define lan_offset(...) lan_offset_(__VA_ARGS__)\n\n#define lan_rmw(val, mask, reg, off)\t\t\\\n\tlan_rmw_(val, mask, reg, lan_offset(off))\n\n#define SERDES_MUX(_idx, _port, _mode, _submode, _mask, _mux) { \\\n\t.idx = _idx,\t\t\t\t\t\t\\\n\t.port = _port,\t\t\t\t\t\t\\\n\t.mode = _mode,\t\t\t\t\t\t\\\n\t.submode = _submode,\t\t\t\t\t\\\n\t.mask = _mask,\t\t\t\t\t\t\\\n\t.mux = _mux,\t\t\t\t\t\t\\\n}\n\n#define SERDES_MUX_GMII(i, p, m, c) \\\n\tSERDES_MUX(i, p, PHY_MODE_ETHERNET, PHY_INTERFACE_MODE_GMII, m, c)\n#define SERDES_MUX_SGMII(i, p, m, c) \\\n\tSERDES_MUX(i, p, PHY_MODE_ETHERNET, PHY_INTERFACE_MODE_SGMII, m, c)\n#define SERDES_MUX_QSGMII(i, p, m, c) \\\n\tSERDES_MUX(i, p, PHY_MODE_ETHERNET, PHY_INTERFACE_MODE_QSGMII, m, c)\n#define SERDES_MUX_RGMII(i, p, m, c) \\\n\tSERDES_MUX(i, p, PHY_MODE_ETHERNET, PHY_INTERFACE_MODE_RGMII, m, c), \\\n\tSERDES_MUX(i, p, PHY_MODE_ETHERNET, PHY_INTERFACE_MODE_RGMII_TXID, m, c), \\\n\tSERDES_MUX(i, p, PHY_MODE_ETHERNET, PHY_INTERFACE_MODE_RGMII_RXID, m, c), \\\n\tSERDES_MUX(i, p, PHY_MODE_ETHERNET, PHY_INTERFACE_MODE_RGMII_ID, m, c)\n\nstatic void lan_rmw_(u32 val, u32 mask, void __iomem *mem, u32 offset)\n{\n\tu32 v;\n\n\tv = readl(mem + offset);\n\tv = (v & ~mask) | (val & mask);\n\twritel(v, mem + offset);\n}\n\nstruct serdes_mux {\n\tu8\t\t\tidx;\n\tu8\t\t\tport;\n\tenum phy_mode\t\tmode;\n\tint\t\t\tsubmode;\n\tu32\t\t\tmask;\n\tu32\t\t\tmux;\n};\n\nstatic const struct serdes_mux lan966x_serdes_muxes[] = {\n\tSERDES_MUX_QSGMII(SERDES6G(1), 0, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA_SET(BIT(0))),\n\tSERDES_MUX_QSGMII(SERDES6G(1), 1, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA_SET(BIT(0))),\n\tSERDES_MUX_QSGMII(SERDES6G(1), 2, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA_SET(BIT(0))),\n\tSERDES_MUX_QSGMII(SERDES6G(1), 3, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA_SET(BIT(0))),\n\n\tSERDES_MUX_QSGMII(SERDES6G(2), 4, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA_SET(BIT(1))),\n\tSERDES_MUX_QSGMII(SERDES6G(2), 5, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA_SET(BIT(1))),\n\tSERDES_MUX_QSGMII(SERDES6G(2), 6, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA_SET(BIT(1))),\n\tSERDES_MUX_QSGMII(SERDES6G(2), 7, HSIO_HW_CFG_QSGMII_ENA,\n\t\t\t  HSIO_HW_CFG_QSGMII_ENA_SET(BIT(1))),\n\n\tSERDES_MUX_GMII(CU(0), 0, HSIO_HW_CFG_GMII_ENA,\n\t\t\tHSIO_HW_CFG_GMII_ENA_SET(BIT(0))),\n\tSERDES_MUX_GMII(CU(1), 1, HSIO_HW_CFG_GMII_ENA,\n\t\t\tHSIO_HW_CFG_GMII_ENA_SET(BIT(1))),\n\n\tSERDES_MUX_SGMII(SERDES6G(0), 0, HSIO_HW_CFG_SD6G_0_CFG, 0),\n\tSERDES_MUX_SGMII(SERDES6G(1), 1, HSIO_HW_CFG_SD6G_1_CFG, 0),\n\tSERDES_MUX_SGMII(SERDES6G(0), 2, HSIO_HW_CFG_SD6G_0_CFG,\n\t\t\t HSIO_HW_CFG_SD6G_0_CFG_SET(1)),\n\tSERDES_MUX_SGMII(SERDES6G(1), 3, HSIO_HW_CFG_SD6G_1_CFG,\n\t\t\t HSIO_HW_CFG_SD6G_1_CFG_SET(1)),\n\n\tSERDES_MUX_RGMII(RGMII(0), 2, HSIO_HW_CFG_RGMII_0_CFG |\n\t\t\t HSIO_HW_CFG_RGMII_ENA |\n\t\t\t HSIO_HW_CFG_GMII_ENA,\n\t\t\t HSIO_HW_CFG_RGMII_0_CFG_SET(0) |\n\t\t\t HSIO_HW_CFG_RGMII_ENA_SET(BIT(0)) |\n\t\t\t HSIO_HW_CFG_GMII_ENA_SET(BIT(2))),\n\tSERDES_MUX_RGMII(RGMII(1), 3, HSIO_HW_CFG_RGMII_1_CFG |\n\t\t\t HSIO_HW_CFG_RGMII_ENA |\n\t\t\t HSIO_HW_CFG_GMII_ENA,\n\t\t\t HSIO_HW_CFG_RGMII_1_CFG_SET(0) |\n\t\t\t HSIO_HW_CFG_RGMII_ENA_SET(BIT(1)) |\n\t\t\t HSIO_HW_CFG_GMII_ENA_SET(BIT(3))),\n\tSERDES_MUX_RGMII(RGMII(0), 5, HSIO_HW_CFG_RGMII_0_CFG |\n\t\t\t HSIO_HW_CFG_RGMII_ENA |\n\t\t\t HSIO_HW_CFG_GMII_ENA,\n\t\t\t HSIO_HW_CFG_RGMII_0_CFG_SET(BIT(0)) |\n\t\t\t HSIO_HW_CFG_RGMII_ENA_SET(BIT(0)) |\n\t\t\t HSIO_HW_CFG_GMII_ENA_SET(BIT(5))),\n\tSERDES_MUX_RGMII(RGMII(1), 6, HSIO_HW_CFG_RGMII_1_CFG |\n\t\t\t HSIO_HW_CFG_RGMII_ENA |\n\t\t\t HSIO_HW_CFG_GMII_ENA,\n\t\t\t HSIO_HW_CFG_RGMII_1_CFG_SET(BIT(0)) |\n\t\t\t HSIO_HW_CFG_RGMII_ENA_SET(BIT(1)) |\n\t\t\t HSIO_HW_CFG_GMII_ENA_SET(BIT(6))),\n};\n\nstruct serdes_ctrl {\n\tvoid __iomem\t\t*regs;\n\tstruct device\t\t*dev;\n\tstruct phy\t\t*phys[SERDES_MAX];\n\tint\t\t\tref125;\n};\n\nstruct serdes_macro {\n\tu8\t\t\tidx;\n\tint\t\t\tport;\n\tstruct serdes_ctrl\t*ctrl;\n\tint\t\t\tspeed;\n\tphy_interface_t\t\tmode;\n};\n\nenum lan966x_sd6g40_mode {\n\tLAN966X_SD6G40_MODE_QSGMII,\n\tLAN966X_SD6G40_MODE_SGMII,\n};\n\nenum lan966x_sd6g40_ltx2rx {\n\tLAN966X_SD6G40_TX2RX_LOOP_NONE,\n\tLAN966X_SD6G40_LTX2RX\n};\n\nstruct lan966x_sd6g40_setup_args {\n\tenum lan966x_sd6g40_mode\tmode;\n\tenum lan966x_sd6g40_ltx2rx\ttx2rx_loop;\n\tbool\t\t\t\ttxinvert;\n\tbool\t\t\t\trxinvert;\n\tbool\t\t\t\trefclk125M;\n\tbool\t\t\t\tmute;\n};\n\nstruct lan966x_sd6g40_mode_args {\n\tenum lan966x_sd6g40_mode\tmode;\n\tu8\t\t\t\t lane_10bit_sel;\n\tu8\t\t\t\t mpll_multiplier;\n\tu8\t\t\t\t ref_clkdiv2;\n\tu8\t\t\t\t tx_rate;\n\tu8\t\t\t\t rx_rate;\n};\n\nstruct lan966x_sd6g40_setup {\n\tu8\trx_term_en;\n\tu8\tlane_10bit_sel;\n\tu8\ttx_invert;\n\tu8\trx_invert;\n\tu8\tmpll_multiplier;\n\tu8\tlane_loopbk_en;\n\tu8\tref_clkdiv2;\n\tu8\ttx_rate;\n\tu8\trx_rate;\n};\n\nstatic int lan966x_sd6g40_reg_cfg(struct serdes_macro *macro,\n\t\t\t\t  struct lan966x_sd6g40_setup *res_struct,\n\t\t\t\t  u32 idx)\n{\n\tu32 value;\n\n\t \n\tlan_rmw(HSIO_SD_CFG_LANE_10BIT_SEL_SET(res_struct->lane_10bit_sel) |\n\t\tHSIO_SD_CFG_RX_RATE_SET(res_struct->rx_rate) |\n\t\tHSIO_SD_CFG_TX_RATE_SET(res_struct->tx_rate) |\n\t\tHSIO_SD_CFG_TX_INVERT_SET(res_struct->tx_invert) |\n\t\tHSIO_SD_CFG_RX_INVERT_SET(res_struct->rx_invert) |\n\t\tHSIO_SD_CFG_LANE_LOOPBK_EN_SET(res_struct->lane_loopbk_en) |\n\t\tHSIO_SD_CFG_RX_RESET_SET(0) |\n\t\tHSIO_SD_CFG_TX_RESET_SET(0),\n\t\tHSIO_SD_CFG_LANE_10BIT_SEL |\n\t\tHSIO_SD_CFG_RX_RATE |\n\t\tHSIO_SD_CFG_TX_RATE |\n\t\tHSIO_SD_CFG_TX_INVERT |\n\t\tHSIO_SD_CFG_RX_INVERT |\n\t\tHSIO_SD_CFG_LANE_LOOPBK_EN |\n\t\tHSIO_SD_CFG_RX_RESET |\n\t\tHSIO_SD_CFG_TX_RESET,\n\t\tmacro->ctrl->regs, HSIO_SD_CFG(idx));\n\n\tlan_rmw(HSIO_MPLL_CFG_MPLL_MULTIPLIER_SET(res_struct->mpll_multiplier) |\n\t\tHSIO_MPLL_CFG_REF_CLKDIV2_SET(res_struct->ref_clkdiv2),\n\t\tHSIO_MPLL_CFG_MPLL_MULTIPLIER |\n\t\tHSIO_MPLL_CFG_REF_CLKDIV2,\n\t\tmacro->ctrl->regs, HSIO_MPLL_CFG(idx));\n\n\tlan_rmw(HSIO_SD_CFG_RX_TERM_EN_SET(res_struct->rx_term_en),\n\t\tHSIO_SD_CFG_RX_TERM_EN,\n\t\tmacro->ctrl->regs, HSIO_SD_CFG(idx));\n\n\tlan_rmw(HSIO_MPLL_CFG_REF_SSP_EN_SET(1),\n\t\tHSIO_MPLL_CFG_REF_SSP_EN,\n\t\tmacro->ctrl->regs, HSIO_MPLL_CFG(idx));\n\n\tusleep_range(USEC_PER_MSEC, 2 * USEC_PER_MSEC);\n\n\tlan_rmw(HSIO_SD_CFG_PHY_RESET_SET(0),\n\t\tHSIO_SD_CFG_PHY_RESET,\n\t\tmacro->ctrl->regs, HSIO_SD_CFG(idx));\n\n\tusleep_range(USEC_PER_MSEC, 2 * USEC_PER_MSEC);\n\n\tlan_rmw(HSIO_MPLL_CFG_MPLL_EN_SET(1),\n\t\tHSIO_MPLL_CFG_MPLL_EN,\n\t\tmacro->ctrl->regs, HSIO_MPLL_CFG(idx));\n\n\tusleep_range(7 * USEC_PER_MSEC, 8 * USEC_PER_MSEC);\n\n\tvalue = readl(macro->ctrl->regs + lan_offset(HSIO_SD_STAT(idx)));\n\tvalue = HSIO_SD_STAT_MPLL_STATE_GET(value);\n\tif (value != 0x1) {\n\t\tdev_err(macro->ctrl->dev,\n\t\t\t\"Unexpected sd_sd_stat[%u] mpll_state was 0x1 but is 0x%x\\n\",\n\t\t\tidx, value);\n\t\treturn -EIO;\n\t}\n\n\tlan_rmw(HSIO_SD_CFG_TX_CM_EN_SET(1),\n\t\tHSIO_SD_CFG_TX_CM_EN,\n\t\tmacro->ctrl->regs, HSIO_SD_CFG(idx));\n\n\tusleep_range(USEC_PER_MSEC, 2 * USEC_PER_MSEC);\n\n\tvalue = readl(macro->ctrl->regs + lan_offset(HSIO_SD_STAT(idx)));\n\tvalue = HSIO_SD_STAT_TX_CM_STATE_GET(value);\n\tif (value != 0x1) {\n\t\tdev_err(macro->ctrl->dev,\n\t\t\t\"Unexpected sd_sd_stat[%u] tx_cm_state was 0x1 but is 0x%x\\n\",\n\t\t\tidx, value);\n\t\treturn -EIO;\n\t}\n\n\tlan_rmw(HSIO_SD_CFG_RX_PLL_EN_SET(1) |\n\t\tHSIO_SD_CFG_TX_EN_SET(1),\n\t\tHSIO_SD_CFG_RX_PLL_EN |\n\t\tHSIO_SD_CFG_TX_EN,\n\t\tmacro->ctrl->regs, HSIO_SD_CFG(idx));\n\n\tusleep_range(USEC_PER_MSEC, 2 * USEC_PER_MSEC);\n\n\t \n\tvalue = readl(macro->ctrl->regs + lan_offset(HSIO_SD_STAT(idx)));\n\tvalue = HSIO_SD_STAT_RX_PLL_STATE_GET(value);\n\tif (value != 0x1) {\n\t\tdev_err(macro->ctrl->dev,\n\t\t\t\"Unexpected sd_sd_stat[%u] rx_pll_state was 0x1 but is 0x%x\\n\",\n\t\t\tidx, value);\n\t\treturn -EIO;\n\t}\n\n\t \n\tvalue = readl(macro->ctrl->regs + lan_offset(HSIO_SD_STAT(idx)));\n\tvalue = HSIO_SD_STAT_TX_STATE_GET(value);\n\tif (value != 0x1) {\n\t\tdev_err(macro->ctrl->dev,\n\t\t\t\"Unexpected sd_sd_stat[%u] tx_state was 0x1 but is 0x%x\\n\",\n\t\t\tidx, value);\n\t\treturn -EIO;\n\t}\n\n\tlan_rmw(HSIO_SD_CFG_TX_DATA_EN_SET(1) |\n\t\tHSIO_SD_CFG_RX_DATA_EN_SET(1),\n\t\tHSIO_SD_CFG_TX_DATA_EN |\n\t\tHSIO_SD_CFG_RX_DATA_EN,\n\t\tmacro->ctrl->regs, HSIO_SD_CFG(idx));\n\n\treturn 0;\n}\n\nstatic int lan966x_sd6g40_get_conf_from_mode(struct serdes_macro *macro,\n\t\t\t\t\t     enum lan966x_sd6g40_mode f_mode,\n\t\t\t\t\t     bool ref125M,\n\t\t\t\t\t     struct lan966x_sd6g40_mode_args *ret_val)\n{\n\tswitch (f_mode) {\n\tcase LAN966X_SD6G40_MODE_QSGMII:\n\t\tret_val->lane_10bit_sel = 0;\n\t\tif (ref125M) {\n\t\t\tret_val->mpll_multiplier = 40;\n\t\t\tret_val->ref_clkdiv2 = 0x1;\n\t\t\tret_val->tx_rate = 0x0;\n\t\t\tret_val->rx_rate = 0x0;\n\t\t} else {\n\t\t\tret_val->mpll_multiplier = 100;\n\t\t\tret_val->ref_clkdiv2 = 0x0;\n\t\t\tret_val->tx_rate = 0x0;\n\t\t\tret_val->rx_rate = 0x0;\n\t\t}\n\t\tbreak;\n\n\tcase LAN966X_SD6G40_MODE_SGMII:\n\t\tret_val->lane_10bit_sel = 1;\n\t\tif (ref125M) {\n\t\t\tret_val->mpll_multiplier = macro->speed == SPEED_2500 ? 50 : 40;\n\t\t\tret_val->ref_clkdiv2 = 0x1;\n\t\t\tret_val->tx_rate = macro->speed == SPEED_2500 ? 0x1 : 0x2;\n\t\t\tret_val->rx_rate = macro->speed == SPEED_2500 ? 0x1 : 0x2;\n\t\t} else {\n\t\t\tret_val->mpll_multiplier = macro->speed == SPEED_2500 ? 125 : 100;\n\t\t\tret_val->ref_clkdiv2 = 0x0;\n\t\t\tret_val->tx_rate = macro->speed == SPEED_2500 ? 0x1 : 0x2;\n\t\t\tret_val->rx_rate = macro->speed == SPEED_2500 ? 0x1 : 0x2;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lan966x_calc_sd6g40_setup_lane(struct serdes_macro *macro,\n\t\t\t\t\t  struct lan966x_sd6g40_setup_args config,\n\t\t\t\t\t  struct lan966x_sd6g40_setup *ret_val)\n{\n\tstruct lan966x_sd6g40_mode_args sd6g40_mode;\n\tstruct lan966x_sd6g40_mode_args *mode_args = &sd6g40_mode;\n\tint ret;\n\n\tret = lan966x_sd6g40_get_conf_from_mode(macro, config.mode,\n\t\t\t\t\t\tconfig.refclk125M, mode_args);\n\tif (ret)\n\t\treturn ret;\n\n\tret_val->lane_10bit_sel = mode_args->lane_10bit_sel;\n\tret_val->rx_rate = mode_args->rx_rate;\n\tret_val->tx_rate = mode_args->tx_rate;\n\tret_val->mpll_multiplier = mode_args->mpll_multiplier;\n\tret_val->ref_clkdiv2 = mode_args->ref_clkdiv2;\n\tret_val->rx_term_en = 0;\n\n\tif (config.tx2rx_loop == LAN966X_SD6G40_LTX2RX)\n\t\tret_val->lane_loopbk_en = 1;\n\telse\n\t\tret_val->lane_loopbk_en = 0;\n\n\tret_val->tx_invert = !!config.txinvert;\n\tret_val->rx_invert = !!config.rxinvert;\n\n\treturn 0;\n}\n\nstatic int lan966x_sd6g40_setup_lane(struct serdes_macro *macro,\n\t\t\t\t     struct lan966x_sd6g40_setup_args config,\n\t\t\t\t     u32 idx)\n{\n\tstruct lan966x_sd6g40_setup calc_results = {};\n\tint ret;\n\n\tret = lan966x_calc_sd6g40_setup_lane(macro, config, &calc_results);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lan966x_sd6g40_reg_cfg(macro, &calc_results, idx);\n}\n\nstatic int lan966x_sd6g40_setup(struct serdes_macro *macro, u32 idx, int mode)\n{\n\tstruct lan966x_sd6g40_setup_args conf = {};\n\n\tconf.refclk125M = macro->ctrl->ref125;\n\n\tif (mode == PHY_INTERFACE_MODE_QSGMII)\n\t\tconf.mode = LAN966X_SD6G40_MODE_QSGMII;\n\telse\n\t\tconf.mode = LAN966X_SD6G40_MODE_SGMII;\n\n\treturn lan966x_sd6g40_setup_lane(macro, conf, idx);\n}\n\nstatic int lan966x_rgmii_setup(struct serdes_macro *macro, u32 idx, int mode)\n{\n\tbool tx_delay = false;\n\tbool rx_delay = false;\n\n\t \n\tlan_rmw(HSIO_RGMII_CFG_RGMII_RX_RST_SET(0) |\n\t\tHSIO_RGMII_CFG_RGMII_TX_RST_SET(0) |\n\t\tHSIO_RGMII_CFG_TX_CLK_CFG_SET(macro->speed == SPEED_1000 ? 1 :\n\t\t\t\t\t      macro->speed == SPEED_100 ? 2 :\n\t\t\t\t\t      macro->speed == SPEED_10 ? 3 : 0),\n\t\tHSIO_RGMII_CFG_RGMII_RX_RST |\n\t\tHSIO_RGMII_CFG_RGMII_TX_RST |\n\t\tHSIO_RGMII_CFG_TX_CLK_CFG,\n\t\tmacro->ctrl->regs, HSIO_RGMII_CFG(idx));\n\n\tif (mode == PHY_INTERFACE_MODE_RGMII ||\n\t    mode == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\trx_delay = true;\n\n\tif (mode == PHY_INTERFACE_MODE_RGMII ||\n\t    mode == PHY_INTERFACE_MODE_RGMII_RXID)\n\t\ttx_delay = true;\n\n\t \n\tlan_rmw(HSIO_DLL_CFG_DLL_RST_SET(0) |\n\t\tHSIO_DLL_CFG_DLL_ENA_SET(rx_delay),\n\t\tHSIO_DLL_CFG_DLL_RST |\n\t\tHSIO_DLL_CFG_DLL_ENA,\n\t\tmacro->ctrl->regs, HSIO_DLL_CFG(idx == 0 ? 0x0 : 0x2));\n\n\tlan_rmw(HSIO_DLL_CFG_DELAY_ENA_SET(rx_delay),\n\t\tHSIO_DLL_CFG_DELAY_ENA,\n\t\tmacro->ctrl->regs, HSIO_DLL_CFG(idx == 0 ? 0x0 : 0x2));\n\n\tlan_rmw(HSIO_DLL_CFG_DLL_RST_SET(0) |\n\t\tHSIO_DLL_CFG_DLL_ENA_SET(tx_delay),\n\t\tHSIO_DLL_CFG_DLL_RST |\n\t\tHSIO_DLL_CFG_DLL_ENA,\n\t\tmacro->ctrl->regs, HSIO_DLL_CFG(idx == 0 ? 0x1 : 0x3));\n\n\tlan_rmw(HSIO_DLL_CFG_DELAY_ENA_SET(tx_delay),\n\t\tHSIO_DLL_CFG_DELAY_ENA,\n\t\tmacro->ctrl->regs, HSIO_DLL_CFG(idx == 0 ? 0x1 : 0x3));\n\n\treturn 0;\n}\n\nstatic int serdes_set_speed(struct phy *phy, int speed)\n{\n\tstruct serdes_macro *macro = phy_get_drvdata(phy);\n\n\tif (!phy_interface_mode_is_rgmii(macro->mode))\n\t\treturn 0;\n\n\tmacro->speed = speed;\n\tlan966x_rgmii_setup(macro, macro->idx - (SERDES6G_MAX + 1), macro->mode);\n\n\treturn 0;\n}\n\nstatic int serdes_set_mode(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tstruct serdes_macro *macro = phy_get_drvdata(phy);\n\tunsigned int i;\n\tint val;\n\n\t \n\tif (mode != PHY_MODE_ETHERNET)\n\t\treturn -EOPNOTSUPP;\n\n\tif (submode == PHY_INTERFACE_MODE_2500BASEX)\n\t\tmacro->speed = SPEED_2500;\n\telse\n\t\tmacro->speed = SPEED_1000;\n\n\tif (submode == PHY_INTERFACE_MODE_1000BASEX ||\n\t    submode == PHY_INTERFACE_MODE_2500BASEX)\n\t\tsubmode = PHY_INTERFACE_MODE_SGMII;\n\n\tif (submode == PHY_INTERFACE_MODE_QUSGMII)\n\t\tsubmode = PHY_INTERFACE_MODE_QSGMII;\n\n\tfor (i = 0; i < ARRAY_SIZE(lan966x_serdes_muxes); i++) {\n\t\tif (macro->idx != lan966x_serdes_muxes[i].idx ||\n\t\t    mode != lan966x_serdes_muxes[i].mode ||\n\t\t    submode != lan966x_serdes_muxes[i].submode ||\n\t\t    macro->port != lan966x_serdes_muxes[i].port)\n\t\t\tcontinue;\n\n\t\tval = readl(macro->ctrl->regs + lan_offset(HSIO_HW_CFG));\n\t\tval |= lan966x_serdes_muxes[i].mux;\n\t\tlan_rmw(val, lan966x_serdes_muxes[i].mask,\n\t\t\tmacro->ctrl->regs, HSIO_HW_CFG);\n\n\t\tmacro->mode = lan966x_serdes_muxes[i].submode;\n\n\t\tif (macro->idx < CU_MAX)\n\t\t\treturn 0;\n\n\t\tif (macro->idx < SERDES6G_MAX)\n\t\t\treturn lan966x_sd6g40_setup(macro,\n\t\t\t\t\t\t    macro->idx - (CU_MAX + 1),\n\t\t\t\t\t\t    macro->mode);\n\n\t\tif (macro->idx < RGMII_MAX)\n\t\t\treturn lan966x_rgmii_setup(macro,\n\t\t\t\t\t\t   macro->idx - (SERDES6G_MAX + 1),\n\t\t\t\t\t\t   macro->mode);\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct phy_ops serdes_ops = {\n\t.set_mode\t= serdes_set_mode,\n\t.set_speed\t= serdes_set_speed,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int serdes_phy_create(struct serdes_ctrl *ctrl, u8 idx, struct phy **phy)\n{\n\tstruct serdes_macro *macro;\n\n\t*phy = devm_phy_create(ctrl->dev, NULL, &serdes_ops);\n\tif (IS_ERR(*phy))\n\t\treturn PTR_ERR(*phy);\n\n\tmacro = devm_kzalloc(ctrl->dev, sizeof(*macro), GFP_KERNEL);\n\tif (!macro)\n\t\treturn -ENOMEM;\n\n\tmacro->idx = idx;\n\tmacro->ctrl = ctrl;\n\tmacro->port = -1;\n\n\tphy_set_drvdata(*phy, macro);\n\n\treturn 0;\n}\n\nstatic int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tvoid __iomem *hw_stat;\n\tunsigned int i;\n\tu32 val;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\thw_stat = devm_platform_get_and_ioremap_resource(pdev, 1, NULL);\n\tif (IS_ERR(hw_stat))\n\t\treturn PTR_ERR(hw_stat);\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tval = readl(hw_stat);\n\tval = FIELD_GET(PLL_CONF_MASK, val);\n\tctrl->ref125 = (val == PLL_CONF_125MHZ ||\n\t\t\tval == PLL_CONF_SERDES_125MHZ);\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id serdes_ids[] = {\n\t{ .compatible = \"microchip,lan966x-serdes\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, serdes_ids);\n\nstatic struct platform_driver mscc_lan966x_serdes = {\n\t.probe\t\t= serdes_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"microchip,lan966x-serdes\",\n\t\t.of_match_table = of_match_ptr(serdes_ids),\n\t},\n};\n\nmodule_platform_driver(mscc_lan966x_serdes);\n\nMODULE_DESCRIPTION(\"Microchip lan966x switch serdes driver\");\nMODULE_AUTHOR(\"Horatiu Vultur <horatiu.vultur@microchip.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}