{
  "module_name": "phy-intel-keembay-usb.c",
  "hash_id": "f238cdc8ef1602eb5fea554ea4b0da9162e533570c33848311ae2d33bd1f225a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/intel/phy-intel-keembay-usb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define USS_CPR_CLK_EN\t\t0x00\n#define USS_CPR_CLK_SET\t\t0x04\n#define USS_CPR_CLK_CLR\t\t0x08\n#define USS_CPR_RST_EN\t\t0x10\n#define USS_CPR_RST_SET\t\t0x14\n#define USS_CPR_RST_CLR\t\t0x18\n\n \n#define USS_CPR_PHY_TST\t\tBIT(6)\n#define USS_CPR_LOW_JIT\t\tBIT(5)\n#define USS_CPR_CORE\t\tBIT(4)\n#define USS_CPR_SUSPEND\t\tBIT(3)\n#define USS_CPR_ALT_REF\t\tBIT(2)\n#define USS_CPR_REF\t\tBIT(1)\n#define USS_CPR_SYS\t\tBIT(0)\n#define USS_CPR_MASK\t\tGENMASK(6, 0)\n\n \n#define USS_USB_CTRL_CFG0\t\t0x10\n#define  VCC_RESET_N_MASK\t\tBIT(31)\n\n#define USS_USB_PHY_CFG0\t\t0x30\n#define  POR_MASK\t\t\tBIT(15)\n#define  PHY_RESET_MASK\t\t\tBIT(14)\n#define  PHY_REF_USE_PAD_MASK\t\tBIT(5)\n\n#define USS_USB_PHY_CFG6\t\t0x64\n#define  PHY0_SRAM_EXT_LD_DONE_MASK\tBIT(23)\n\n#define USS_USB_PARALLEL_IF_CTRL\t0xa0\n#define  USB_PHY_CR_PARA_SEL_MASK\tBIT(2)\n\n#define USS_USB_TSET_SIGNALS_AND_GLOB\t0xac\n#define  USB_PHY_CR_PARA_CLK_EN_MASK\tBIT(7)\n\n#define USS_USB_STATUS_REG\t\t0xb8\n#define  PHY0_SRAM_INIT_DONE_MASK\tBIT(3)\n\n#define USS_USB_TIEOFFS_CONSTANTS_REG1\t0xc0\n#define  IDDQ_ENABLE_MASK\t\tBIT(10)\n\nstruct keembay_usb_phy {\n\tstruct device *dev;\n\tstruct regmap *regmap_cpr;\n\tstruct regmap *regmap_slv;\n};\n\nstatic const struct regmap_config keembay_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = USS_USB_TIEOFFS_CONSTANTS_REG1,\n};\n\nstatic int keembay_usb_clocks_on(struct keembay_usb_phy *priv)\n{\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap_cpr, USS_CPR_CLK_SET,\n\t\t\t\t USS_CPR_MASK, USS_CPR_MASK);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"error clock set: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(priv->regmap_cpr, USS_CPR_RST_SET,\n\t\t\t\t USS_CPR_MASK, USS_CPR_MASK);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"error reset set: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(priv->regmap_slv,\n\t\t\t\t USS_USB_TIEOFFS_CONSTANTS_REG1,\n\t\t\t\t IDDQ_ENABLE_MASK,\n\t\t\t\t FIELD_PREP(IDDQ_ENABLE_MASK, 0));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"error iddq disable: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(30, 60);\n\n\tret = regmap_update_bits(priv->regmap_slv, USS_USB_PHY_CFG0,\n\t\t\t\t PHY_REF_USE_PAD_MASK,\n\t\t\t\t FIELD_PREP(PHY_REF_USE_PAD_MASK, 1));\n\tif (ret)\n\t\tdev_err(priv->dev, \"error ref clock select: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int keembay_usb_core_off(struct keembay_usb_phy *priv)\n{\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap_slv, USS_USB_CTRL_CFG0,\n\t\t\t\t VCC_RESET_N_MASK,\n\t\t\t\t FIELD_PREP(VCC_RESET_N_MASK, 0));\n\tif (ret)\n\t\tdev_err(priv->dev, \"error core reset: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int keembay_usb_core_on(struct keembay_usb_phy *priv)\n{\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap_slv, USS_USB_CTRL_CFG0,\n\t\t\t\t VCC_RESET_N_MASK,\n\t\t\t\t FIELD_PREP(VCC_RESET_N_MASK, 1));\n\tif (ret)\n\t\tdev_err(priv->dev, \"error core on: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int keembay_usb_phys_on(struct keembay_usb_phy *priv)\n{\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap_slv, USS_USB_PHY_CFG0,\n\t\t\t\t POR_MASK | PHY_RESET_MASK,\n\t\t\t\t FIELD_PREP(POR_MASK | PHY_RESET_MASK, 0));\n\tif (ret)\n\t\tdev_err(priv->dev, \"error phys on: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int keembay_usb_phy_init(struct phy *phy)\n{\n\tstruct keembay_usb_phy *priv = phy_get_drvdata(phy);\n\tu32 val;\n\tint ret;\n\n\tret = keembay_usb_core_off(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(20, 40);\n\n\tret = keembay_usb_phys_on(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(priv->regmap_slv,\n\t\t\t\t USS_USB_TSET_SIGNALS_AND_GLOB,\n\t\t\t\t USB_PHY_CR_PARA_CLK_EN_MASK,\n\t\t\t\t FIELD_PREP(USB_PHY_CR_PARA_CLK_EN_MASK, 0));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"error cr clock disable: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tudelay(2);\n\n\tret = regmap_update_bits(priv->regmap_slv,\n\t\t\t\t USS_USB_PARALLEL_IF_CTRL,\n\t\t\t\t USB_PHY_CR_PARA_SEL_MASK,\n\t\t\t\t FIELD_PREP(USB_PHY_CR_PARA_SEL_MASK, 1));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"error cr select: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(priv->regmap_slv,\n\t\t\t\t USS_USB_TSET_SIGNALS_AND_GLOB,\n\t\t\t\t USB_PHY_CR_PARA_CLK_EN_MASK,\n\t\t\t\t FIELD_PREP(USB_PHY_CR_PARA_CLK_EN_MASK, 1));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"error cr clock enable: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read_poll_timeout(priv->regmap_slv, USS_USB_STATUS_REG,\n\t\t\t\t       val, val & PHY0_SRAM_INIT_DONE_MASK,\n\t\t\t\t       USEC_PER_MSEC, 10 * USEC_PER_MSEC);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"SRAM init not done: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(priv->regmap_slv, USS_USB_PHY_CFG6,\n\t\t\t\t PHY0_SRAM_EXT_LD_DONE_MASK,\n\t\t\t\t FIELD_PREP(PHY0_SRAM_EXT_LD_DONE_MASK, 1));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"error SRAM init done set: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(20, 40);\n\n\treturn keembay_usb_core_on(priv);\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= keembay_usb_phy_init,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int keembay_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct keembay_usb_phy *priv;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource_byname(pdev, \"cpr-apb-base\");\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap_cpr = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t\t &keembay_regmap_config);\n\tif (IS_ERR(priv->regmap_cpr))\n\t\treturn PTR_ERR(priv->regmap_cpr);\n\n\tbase = devm_platform_ioremap_resource_byname(pdev, \"slv-apb-base\");\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap_slv = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t\t &keembay_regmap_config);\n\tif (IS_ERR(priv->regmap_slv))\n\t\treturn PTR_ERR(priv->regmap_slv);\n\n\tgeneric_phy = devm_phy_create(dev, dev->of_node, &ops);\n\tif (IS_ERR(generic_phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(generic_phy),\n\t\t\t\t     \"failed to create PHY\\n\");\n\n\tphy_set_drvdata(generic_phy, priv);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy_provider),\n\t\t\t\t     \"failed to register phy provider\\n\");\n\n\t \n\tret = keembay_usb_clocks_on(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn keembay_usb_core_on(priv);\n}\n\nstatic const struct of_device_id keembay_usb_phy_dt_ids[] = {\n\t{ .compatible = \"intel,keembay-usb-phy\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, keembay_usb_phy_dt_ids);\n\nstatic struct platform_driver keembay_usb_phy_driver = {\n\t.probe\t\t= keembay_usb_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"keembay-usb-phy\",\n\t\t.of_match_table = keembay_usb_phy_dt_ids,\n\t},\n};\nmodule_platform_driver(keembay_usb_phy_driver);\n\nMODULE_AUTHOR(\"Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Keem Bay USB PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}