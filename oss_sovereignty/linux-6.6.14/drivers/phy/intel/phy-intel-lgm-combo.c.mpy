{
  "module_name": "phy-intel-lgm-combo.c",
  "hash_id": "f377993a7213f7368e7454aeb0a40ea2d9f584f50de5de836354967ad32818a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/intel/phy-intel-lgm-combo.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <dt-bindings/phy/phy.h>\n\n#define PCIE_PHY_GEN_CTRL\t0x00\n#define PCIE_PHY_CLK_PAD\tBIT(17)\n\n#define PAD_DIS_CFG\t\t0x174\n\n#define PCS_XF_ATE_OVRD_IN_2\t0x3008\n#define ADAPT_REQ_MSK\t\tGENMASK(5, 4)\n\n#define PCS_XF_RX_ADAPT_ACK\t0x3010\n#define RX_ADAPT_ACK_BIT\tBIT(0)\n\n#define CR_ADDR(addr, lane)\t(((addr) + (lane) * 0x100) << 2)\n#define REG_COMBO_MODE(x)\t((x) * 0x200)\n#define REG_CLK_DISABLE(x)\t((x) * 0x200 + 0x124)\n\n#define COMBO_PHY_ID(x)\t\t((x)->parent->id)\n#define PHY_ID(x)\t\t((x)->id)\n\n#define CLK_100MHZ\t\t100000000\n#define CLK_156_25MHZ\t\t156250000\n\nstatic const unsigned long intel_iphy_clk_rates[] = {\n\tCLK_100MHZ, CLK_156_25MHZ, CLK_100MHZ,\n};\n\nenum {\n\tPHY_0,\n\tPHY_1,\n\tPHY_MAX_NUM\n};\n\n \nenum intel_phy_mode {\n\tPHY_PCIE_MODE = 0,\n\tPHY_XPCS_MODE,\n\tPHY_SATA_MODE,\n};\n\n \nenum intel_combo_mode {\n\tPCIE0_PCIE1_MODE = 0,\n\tPCIE_DL_MODE,\n\tRXAUI_MODE,\n\tXPCS0_XPCS1_MODE,\n\tSATA0_SATA1_MODE,\n};\n\nenum aggregated_mode {\n\tPHY_SL_MODE,\n\tPHY_DL_MODE,\n};\n\nstruct intel_combo_phy;\n\nstruct intel_cbphy_iphy {\n\tstruct phy\t\t*phy;\n\tstruct intel_combo_phy\t*parent;\n\tstruct reset_control\t*app_rst;\n\tu32\t\t\tid;\n};\n\nstruct intel_combo_phy {\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*core_clk;\n\tunsigned long\t\tclk_rate;\n\tvoid __iomem\t\t*app_base;\n\tvoid __iomem\t\t*cr_base;\n\tstruct regmap\t\t*syscfg;\n\tstruct regmap\t\t*hsiocfg;\n\tu32\t\t\tid;\n\tu32\t\t\tbid;\n\tstruct reset_control\t*phy_rst;\n\tstruct reset_control\t*core_rst;\n\tstruct intel_cbphy_iphy\tiphy[PHY_MAX_NUM];\n\tenum intel_phy_mode\tphy_mode;\n\tenum aggregated_mode\taggr_mode;\n\tu32\t\t\tinit_cnt;\n\tstruct mutex\t\tlock;\n};\n\nstatic int intel_cbphy_iphy_enable(struct intel_cbphy_iphy *iphy, bool set)\n{\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tu32 mask = BIT(cbphy->phy_mode * 2 + iphy->id);\n\tu32 val;\n\n\t \n\tval = set ? 0 : mask;\n\n\treturn regmap_update_bits(cbphy->hsiocfg, REG_CLK_DISABLE(cbphy->bid),\n\t\t\t\t  mask, val);\n}\n\nstatic int intel_cbphy_pcie_refclk_cfg(struct intel_cbphy_iphy *iphy, bool set)\n{\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tu32 mask = BIT(cbphy->id * 2 + iphy->id);\n\tu32 val;\n\n\t \n\tval = set ? 0 : mask;\n\n\treturn regmap_update_bits(cbphy->syscfg, PAD_DIS_CFG, mask, val);\n}\n\nstatic inline void combo_phy_w32_off_mask(void __iomem *base, unsigned int reg,\n\t\t\t\t\t  u32 mask, u32 val)\n{\n\tu32 reg_val;\n\n\treg_val = readl(base + reg);\n\treg_val &= ~mask;\n\treg_val |= val;\n\twritel(reg_val, base + reg);\n}\n\nstatic int intel_cbphy_iphy_cfg(struct intel_cbphy_iphy *iphy,\n\t\t\t\tint (*phy_cfg)(struct intel_cbphy_iphy *))\n{\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tint ret;\n\n\tret = phy_cfg(iphy);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cbphy->aggr_mode != PHY_DL_MODE)\n\t\treturn 0;\n\n\treturn phy_cfg(&cbphy->iphy[PHY_1]);\n}\n\nstatic int intel_cbphy_pcie_en_pad_refclk(struct intel_cbphy_iphy *iphy)\n{\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tint ret;\n\n\tret = intel_cbphy_pcie_refclk_cfg(iphy, true);\n\tif (ret) {\n\t\tdev_err(cbphy->dev, \"Failed to enable PCIe pad refclk\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cbphy->init_cnt)\n\t\treturn 0;\n\n\tcombo_phy_w32_off_mask(cbphy->app_base, PCIE_PHY_GEN_CTRL,\n\t\t\t       PCIE_PHY_CLK_PAD, FIELD_PREP(PCIE_PHY_CLK_PAD, 0));\n\n\t \n\tusleep_range(50, 100);\n\n\treturn 0;\n}\n\nstatic int intel_cbphy_pcie_dis_pad_refclk(struct intel_cbphy_iphy *iphy)\n{\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tint ret;\n\n\tret = intel_cbphy_pcie_refclk_cfg(iphy, false);\n\tif (ret) {\n\t\tdev_err(cbphy->dev, \"Failed to disable PCIe pad refclk\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cbphy->init_cnt)\n\t\treturn 0;\n\n\tcombo_phy_w32_off_mask(cbphy->app_base, PCIE_PHY_GEN_CTRL,\n\t\t\t       PCIE_PHY_CLK_PAD, FIELD_PREP(PCIE_PHY_CLK_PAD, 1));\n\n\treturn 0;\n}\n\nstatic int intel_cbphy_set_mode(struct intel_combo_phy *cbphy)\n{\n\tenum intel_combo_mode cb_mode;\n\tenum aggregated_mode aggr = cbphy->aggr_mode;\n\tstruct device *dev = cbphy->dev;\n\tenum intel_phy_mode mode;\n\tint ret;\n\n\tmode = cbphy->phy_mode;\n\n\tswitch (mode) {\n\tcase PHY_PCIE_MODE:\n\t\tcb_mode = (aggr == PHY_DL_MODE) ? PCIE_DL_MODE : PCIE0_PCIE1_MODE;\n\t\tbreak;\n\n\tcase PHY_XPCS_MODE:\n\t\tcb_mode = (aggr == PHY_DL_MODE) ? RXAUI_MODE : XPCS0_XPCS1_MODE;\n\t\tbreak;\n\n\tcase PHY_SATA_MODE:\n\t\tif (aggr == PHY_DL_MODE) {\n\t\t\tdev_err(dev, \"Mode:%u not support dual lane!\\n\", mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcb_mode = SATA0_SATA1_MODE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(cbphy->hsiocfg, REG_COMBO_MODE(cbphy->bid), cb_mode);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to set ComboPhy mode: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void intel_cbphy_rst_assert(struct intel_combo_phy *cbphy)\n{\n\treset_control_assert(cbphy->core_rst);\n\treset_control_assert(cbphy->phy_rst);\n}\n\nstatic void intel_cbphy_rst_deassert(struct intel_combo_phy *cbphy)\n{\n\treset_control_deassert(cbphy->core_rst);\n\treset_control_deassert(cbphy->phy_rst);\n\t \n\tusleep_range(10, 20);\n}\n\nstatic int intel_cbphy_iphy_power_on(struct intel_cbphy_iphy *iphy)\n{\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tint ret;\n\n\tif (!cbphy->init_cnt) {\n\t\tret = clk_prepare_enable(cbphy->core_clk);\n\t\tif (ret) {\n\t\t\tdev_err(cbphy->dev, \"Clock enable failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_set_rate(cbphy->core_clk, cbphy->clk_rate);\n\t\tif (ret) {\n\t\t\tdev_err(cbphy->dev, \"Clock freq set to %lu failed!\\n\",\n\t\t\t\tcbphy->clk_rate);\n\t\t\tgoto clk_err;\n\t\t}\n\n\t\tintel_cbphy_rst_assert(cbphy);\n\t\tintel_cbphy_rst_deassert(cbphy);\n\t\tret = intel_cbphy_set_mode(cbphy);\n\t\tif (ret)\n\t\t\tgoto clk_err;\n\t}\n\n\tret = intel_cbphy_iphy_enable(iphy, true);\n\tif (ret) {\n\t\tdev_err(cbphy->dev, \"Failed enabling PHY core\\n\");\n\t\tgoto clk_err;\n\t}\n\n\tret = reset_control_deassert(iphy->app_rst);\n\tif (ret) {\n\t\tdev_err(cbphy->dev, \"PHY(%u:%u) reset deassert failed!\\n\",\n\t\t\tCOMBO_PHY_ID(iphy), PHY_ID(iphy));\n\t\tgoto clk_err;\n\t}\n\n\t \n\tudelay(1);\n\n\treturn 0;\n\nclk_err:\n\tclk_disable_unprepare(cbphy->core_clk);\n\n\treturn ret;\n}\n\nstatic int intel_cbphy_iphy_power_off(struct intel_cbphy_iphy *iphy)\n{\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tint ret;\n\n\tret = reset_control_assert(iphy->app_rst);\n\tif (ret) {\n\t\tdev_err(cbphy->dev, \"PHY(%u:%u) reset assert failed!\\n\",\n\t\t\tCOMBO_PHY_ID(iphy), PHY_ID(iphy));\n\t\treturn ret;\n\t}\n\n\tret = intel_cbphy_iphy_enable(iphy, false);\n\tif (ret) {\n\t\tdev_err(cbphy->dev, \"Failed disabling PHY core\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cbphy->init_cnt)\n\t\treturn 0;\n\n\tclk_disable_unprepare(cbphy->core_clk);\n\tintel_cbphy_rst_assert(cbphy);\n\n\treturn 0;\n}\n\nstatic int intel_cbphy_init(struct phy *phy)\n{\n\tstruct intel_cbphy_iphy *iphy = phy_get_drvdata(phy);\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tint ret;\n\n\tmutex_lock(&cbphy->lock);\n\tret = intel_cbphy_iphy_cfg(iphy, intel_cbphy_iphy_power_on);\n\tif (ret)\n\t\tgoto err;\n\n\tif (cbphy->phy_mode == PHY_PCIE_MODE) {\n\t\tret = intel_cbphy_iphy_cfg(iphy, intel_cbphy_pcie_en_pad_refclk);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tcbphy->init_cnt++;\n\nerr:\n\tmutex_unlock(&cbphy->lock);\n\n\treturn ret;\n}\n\nstatic int intel_cbphy_exit(struct phy *phy)\n{\n\tstruct intel_cbphy_iphy *iphy = phy_get_drvdata(phy);\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tint ret;\n\n\tmutex_lock(&cbphy->lock);\n\tcbphy->init_cnt--;\n\tif (cbphy->phy_mode == PHY_PCIE_MODE) {\n\t\tret = intel_cbphy_iphy_cfg(iphy, intel_cbphy_pcie_dis_pad_refclk);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = intel_cbphy_iphy_cfg(iphy, intel_cbphy_iphy_power_off);\n\nerr:\n\tmutex_unlock(&cbphy->lock);\n\n\treturn ret;\n}\n\nstatic int intel_cbphy_calibrate(struct phy *phy)\n{\n\tstruct intel_cbphy_iphy *iphy = phy_get_drvdata(phy);\n\tstruct intel_combo_phy *cbphy = iphy->parent;\n\tvoid __iomem *cr_base = cbphy->cr_base;\n\tint val, ret, id;\n\n\tif (cbphy->phy_mode != PHY_XPCS_MODE)\n\t\treturn 0;\n\n\tid = PHY_ID(iphy);\n\n\t \n\tcombo_phy_w32_off_mask(cr_base, CR_ADDR(PCS_XF_ATE_OVRD_IN_2, id),\n\t\t\t       ADAPT_REQ_MSK, FIELD_PREP(ADAPT_REQ_MSK, 3));\n\t \n\tret = readl_poll_timeout(cr_base + CR_ADDR(PCS_XF_RX_ADAPT_ACK, id),\n\t\t\t\t val, val & RX_ADAPT_ACK_BIT, 10, 5000);\n\tif (ret)\n\t\tdev_err(cbphy->dev, \"RX Adaptation failed!\\n\");\n\telse\n\t\tdev_dbg(cbphy->dev, \"RX Adaptation success!\\n\");\n\n\t \n\tcombo_phy_w32_off_mask(cr_base, CR_ADDR(PCS_XF_ATE_OVRD_IN_2, id),\n\t\t\t       ADAPT_REQ_MSK, FIELD_PREP(ADAPT_REQ_MSK, 0));\n\n\treturn ret;\n}\n\nstatic int intel_cbphy_fwnode_parse(struct intel_combo_phy *cbphy)\n{\n\tstruct device *dev = cbphy->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct fwnode_reference_args ref;\n\tint ret;\n\tu32 val;\n\n\tcbphy->core_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(cbphy->core_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(cbphy->core_clk),\n\t\t\t\t     \"Get clk failed!\\n\");\n\n\tcbphy->core_rst = devm_reset_control_get_optional(dev, \"core\");\n\tif (IS_ERR(cbphy->core_rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(cbphy->core_rst),\n\t\t\t\t     \"Get core reset control err!\\n\");\n\n\tcbphy->phy_rst = devm_reset_control_get_optional(dev, \"phy\");\n\tif (IS_ERR(cbphy->phy_rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(cbphy->phy_rst),\n\t\t\t\t     \"Get PHY reset control err!\\n\");\n\n\tcbphy->iphy[0].app_rst = devm_reset_control_get_optional(dev, \"iphy0\");\n\tif (IS_ERR(cbphy->iphy[0].app_rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(cbphy->iphy[0].app_rst),\n\t\t\t\t     \"Get phy0 reset control err!\\n\");\n\n\tcbphy->iphy[1].app_rst = devm_reset_control_get_optional(dev, \"iphy1\");\n\tif (IS_ERR(cbphy->iphy[1].app_rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(cbphy->iphy[1].app_rst),\n\t\t\t\t     \"Get phy1 reset control err!\\n\");\n\n\tcbphy->app_base = devm_platform_ioremap_resource_byname(pdev, \"app\");\n\tif (IS_ERR(cbphy->app_base))\n\t\treturn PTR_ERR(cbphy->app_base);\n\n\tcbphy->cr_base = devm_platform_ioremap_resource_byname(pdev, \"core\");\n\tif (IS_ERR(cbphy->cr_base))\n\t\treturn PTR_ERR(cbphy->cr_base);\n\n\t \n\tret = fwnode_property_get_reference_args(fwnode, \"intel,syscfg\", NULL,\n\t\t\t\t\t\t 1, 0, &ref);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcbphy->id = ref.args[0];\n\tcbphy->syscfg = device_node_to_regmap(to_of_node(ref.fwnode));\n\tfwnode_handle_put(ref.fwnode);\n\n\tret = fwnode_property_get_reference_args(fwnode, \"intel,hsio\", NULL, 1,\n\t\t\t\t\t\t 0, &ref);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcbphy->bid = ref.args[0];\n\tcbphy->hsiocfg = device_node_to_regmap(to_of_node(ref.fwnode));\n\tfwnode_handle_put(ref.fwnode);\n\n\tret = fwnode_property_read_u32_array(fwnode, \"intel,phy-mode\", &val, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase PHY_TYPE_PCIE:\n\t\tcbphy->phy_mode = PHY_PCIE_MODE;\n\t\tbreak;\n\n\tcase PHY_TYPE_SATA:\n\t\tcbphy->phy_mode = PHY_SATA_MODE;\n\t\tbreak;\n\n\tcase PHY_TYPE_XPCS:\n\t\tcbphy->phy_mode = PHY_XPCS_MODE;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid PHY mode: %u\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tcbphy->clk_rate = intel_iphy_clk_rates[cbphy->phy_mode];\n\n\tif (fwnode_property_present(fwnode, \"intel,aggregation\"))\n\t\tcbphy->aggr_mode = PHY_DL_MODE;\n\telse\n\t\tcbphy->aggr_mode = PHY_SL_MODE;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops intel_cbphy_ops = {\n\t.init\t\t= intel_cbphy_init,\n\t.exit\t\t= intel_cbphy_exit,\n\t.calibrate\t= intel_cbphy_calibrate,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *intel_cbphy_xlate(struct device *dev,\n\t\t\t\t     struct of_phandle_args *args)\n{\n\tstruct intel_combo_phy *cbphy = dev_get_drvdata(dev);\n\tu32 iphy_id;\n\n\tif (args->args_count < 1) {\n\t\tdev_err(dev, \"Invalid number of arguments\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tiphy_id = args->args[0];\n\tif (iphy_id >= PHY_MAX_NUM) {\n\t\tdev_err(dev, \"Invalid phy instance %d\\n\", iphy_id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (cbphy->aggr_mode == PHY_DL_MODE && iphy_id == PHY_1) {\n\t\tdev_err(dev, \"Invalid. ComboPhy is in Dual lane mode %d\\n\", iphy_id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn cbphy->iphy[iphy_id].phy;\n}\n\nstatic int intel_cbphy_create(struct intel_combo_phy *cbphy)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = cbphy->dev;\n\tstruct intel_cbphy_iphy *iphy;\n\tint i;\n\n\tfor (i = 0; i < PHY_MAX_NUM; i++) {\n\t\tiphy = &cbphy->iphy[i];\n\t\tiphy->parent = cbphy;\n\t\tiphy->id = i;\n\n\t\t \n\t\tif (cbphy->aggr_mode == PHY_DL_MODE && iphy->id == PHY_1)\n\t\t\tcontinue;\n\n\t\tiphy->phy = devm_phy_create(dev, NULL, &intel_cbphy_ops);\n\t\tif (IS_ERR(iphy->phy)) {\n\t\t\tdev_err(dev, \"PHY[%u:%u]: create PHY instance failed!\\n\",\n\t\t\t\tCOMBO_PHY_ID(iphy), PHY_ID(iphy));\n\n\t\t\treturn PTR_ERR(iphy->phy);\n\t\t}\n\n\t\tphy_set_drvdata(iphy->phy, iphy);\n\t}\n\n\tdev_set_drvdata(dev, cbphy);\n\tphy_provider = devm_of_phy_provider_register(dev, intel_cbphy_xlate);\n\tif (IS_ERR(phy_provider))\n\t\tdev_err(dev, \"Register PHY provider failed!\\n\");\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic int intel_cbphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_combo_phy *cbphy;\n\tint ret;\n\n\tcbphy = devm_kzalloc(dev, sizeof(*cbphy), GFP_KERNEL);\n\tif (!cbphy)\n\t\treturn -ENOMEM;\n\n\tcbphy->dev = dev;\n\tcbphy->init_cnt = 0;\n\tmutex_init(&cbphy->lock);\n\tret = intel_cbphy_fwnode_parse(cbphy);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, cbphy);\n\n\treturn intel_cbphy_create(cbphy);\n}\n\nstatic void intel_cbphy_remove(struct platform_device *pdev)\n{\n\tstruct intel_combo_phy *cbphy = platform_get_drvdata(pdev);\n\n\tintel_cbphy_rst_assert(cbphy);\n\tclk_disable_unprepare(cbphy->core_clk);\n}\n\nstatic const struct of_device_id of_intel_cbphy_match[] = {\n\t{ .compatible = \"intel,combo-phy\" },\n\t{ .compatible = \"intel,combophy-lgm\" },\n\t{}\n};\n\nstatic struct platform_driver intel_cbphy_driver = {\n\t.probe = intel_cbphy_probe,\n\t.remove_new = intel_cbphy_remove,\n\t.driver = {\n\t\t.name = \"intel-combo-phy\",\n\t\t.of_match_table = of_intel_cbphy_match,\n\t}\n};\n\nmodule_platform_driver(intel_cbphy_driver);\n\nMODULE_DESCRIPTION(\"Intel Combo-phy driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}