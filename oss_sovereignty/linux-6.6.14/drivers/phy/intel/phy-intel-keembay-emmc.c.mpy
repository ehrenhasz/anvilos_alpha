{
  "module_name": "phy-intel-keembay-emmc.c",
  "hash_id": "515f2162acecfef9fdf9cf637e14fa1a9603ffc8c72668d1572c18ed4f4cbab6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/intel/phy-intel-keembay-emmc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define PHY_CFG_0\t\t0x24\n#define  SEL_DLY_TXCLK_MASK\tBIT(29)\n#define  OTAP_DLY_ENA_MASK\tBIT(27)\n#define  OTAP_DLY_SEL_MASK\tGENMASK(26, 23)\n#define  DLL_EN_MASK\t\tBIT(10)\n#define  PWR_DOWN_MASK\t\tBIT(0)\n\n#define PHY_CFG_2\t\t0x2c\n#define  SEL_FREQ_MASK\t\tGENMASK(12, 10)\n\n#define PHY_STAT\t\t0x40\n#define  CAL_DONE_MASK\t\tBIT(6)\n#define  IS_CALDONE(x)\t\t((x) & CAL_DONE_MASK)\n#define  DLL_RDY_MASK\t\tBIT(5)\n#define  IS_DLLRDY(x)\t\t((x) & DLL_RDY_MASK)\n\n \n#define FREQSEL_200M_170M\t0x0\n#define FREQSEL_170M_140M\t0x1\n#define FREQSEL_140M_110M\t0x2\n#define FREQSEL_110M_80M\t0x3\n#define FREQSEL_80M_50M\t\t0x4\n\nstruct keembay_emmc_phy {\n\tstruct regmap *syscfg;\n\tstruct clk *emmcclk;\n};\n\nstatic const struct regmap_config keembay_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic int keembay_emmc_phy_power(struct phy *phy, bool on_off)\n{\n\tstruct keembay_emmc_phy *priv = phy_get_drvdata(phy);\n\tunsigned int caldone;\n\tunsigned int dllrdy;\n\tunsigned int freqsel;\n\tunsigned int mhz;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(priv->syscfg, PHY_CFG_0, PWR_DOWN_MASK,\n\t\t\t\t FIELD_PREP(PWR_DOWN_MASK, 0));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"CALIO power down bar failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(priv->syscfg, PHY_CFG_0, DLL_EN_MASK,\n\t\t\t\t FIELD_PREP(DLL_EN_MASK, 0));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"turn off the dll failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!on_off)\n\t\treturn 0;\n\n\tmhz = DIV_ROUND_CLOSEST(clk_get_rate(priv->emmcclk), 1000000);\n\tif (mhz <= 200 && mhz >= 170)\n\t\tfreqsel = FREQSEL_200M_170M;\n\telse if (mhz <= 170 && mhz >= 140)\n\t\tfreqsel = FREQSEL_170M_140M;\n\telse if (mhz <= 140 && mhz >= 110)\n\t\tfreqsel = FREQSEL_140M_110M;\n\telse if (mhz <= 110 && mhz >= 80)\n\t\tfreqsel = FREQSEL_110M_80M;\n\telse if (mhz <= 80 && mhz >= 50)\n\t\tfreqsel = FREQSEL_80M_50M;\n\telse\n\t\tfreqsel = 0x0;\n\n\t \n\tif (mhz > 175)\n\t\tdev_warn(&phy->dev, \"Unsupported rate: %d MHz\\n\", mhz);\n\n\t \n\tudelay(5);\n\n\tret = regmap_update_bits(priv->syscfg, PHY_CFG_0, PWR_DOWN_MASK,\n\t\t\t\t FIELD_PREP(PWR_DOWN_MASK, 1));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"CALIO power down bar failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read_poll_timeout(priv->syscfg, PHY_STAT,\n\t\t\t\t       caldone, IS_CALDONE(caldone),\n\t\t\t\t       0, 50);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"caldone failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->syscfg, PHY_CFG_2, SEL_FREQ_MASK,\n\t\t\t\t FIELD_PREP(SEL_FREQ_MASK, freqsel));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"set the frequency of dll failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->syscfg, PHY_CFG_0, DLL_EN_MASK,\n\t\t\t\t FIELD_PREP(DLL_EN_MASK, 1));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"turn on the dll failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (mhz == 0)\n\t\treturn 0;\n\n\t \n\tret = regmap_read_poll_timeout(priv->syscfg, PHY_STAT,\n\t\t\t\t       dllrdy, IS_DLLRDY(dllrdy),\n\t\t\t\t       0, 50 * USEC_PER_MSEC);\n\tif (ret)\n\t\tdev_err(&phy->dev, \"dllrdy failed, ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int keembay_emmc_phy_init(struct phy *phy)\n{\n\tstruct keembay_emmc_phy *priv = phy_get_drvdata(phy);\n\n\t \n\tpriv->emmcclk = clk_get_optional(&phy->dev, \"emmcclk\");\n\n\treturn PTR_ERR_OR_ZERO(priv->emmcclk);\n}\n\nstatic int keembay_emmc_phy_exit(struct phy *phy)\n{\n\tstruct keembay_emmc_phy *priv = phy_get_drvdata(phy);\n\n\tclk_put(priv->emmcclk);\n\n\treturn 0;\n};\n\nstatic int keembay_emmc_phy_power_on(struct phy *phy)\n{\n\tstruct keembay_emmc_phy *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(priv->syscfg, PHY_CFG_0, SEL_DLY_TXCLK_MASK,\n\t\t\t\t FIELD_PREP(SEL_DLY_TXCLK_MASK, 1));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"ERROR: delay chain txclk set: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->syscfg, PHY_CFG_0, OTAP_DLY_ENA_MASK,\n\t\t\t\t FIELD_PREP(OTAP_DLY_ENA_MASK, 1));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"ERROR: output tap delay set: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->syscfg, PHY_CFG_0, OTAP_DLY_SEL_MASK,\n\t\t\t\t FIELD_PREP(OTAP_DLY_SEL_MASK, 2));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"ERROR: output tap delay select: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn keembay_emmc_phy_power(phy, true);\n}\n\nstatic int keembay_emmc_phy_power_off(struct phy *phy)\n{\n\t \n\treturn keembay_emmc_phy_power(phy, false);\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= keembay_emmc_phy_init,\n\t.exit\t\t= keembay_emmc_phy_exit,\n\t.power_on\t= keembay_emmc_phy_power_on,\n\t.power_off\t= keembay_emmc_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int keembay_emmc_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct keembay_emmc_phy *priv;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\tvoid __iomem *base;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->syscfg = devm_regmap_init_mmio(dev, base, &keembay_regmap_config);\n\tif (IS_ERR(priv->syscfg))\n\t\treturn PTR_ERR(priv->syscfg);\n\n\tgeneric_phy = devm_phy_create(dev, np, &ops);\n\tif (IS_ERR(generic_phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(generic_phy),\n\t\t\t\t     \"failed to create PHY\\n\");\n\n\tphy_set_drvdata(generic_phy, priv);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id keembay_emmc_phy_dt_ids[] = {\n\t{ .compatible = \"intel,keembay-emmc-phy\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, keembay_emmc_phy_dt_ids);\n\nstatic struct platform_driver keembay_emmc_phy_driver = {\n\t.probe\t\t= keembay_emmc_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"keembay-emmc-phy\",\n\t\t.of_match_table = keembay_emmc_phy_dt_ids,\n\t},\n};\nmodule_platform_driver(keembay_emmc_phy_driver);\n\nMODULE_AUTHOR(\"Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Keem Bay eMMC PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}