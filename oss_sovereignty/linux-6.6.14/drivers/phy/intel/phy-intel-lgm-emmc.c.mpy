{
  "module_name": "phy-intel-lgm-emmc.c",
  "hash_id": "25e49ecffba3b9a0f5bc5e9fdf1f3e77cfbaf17891181050aa8048c02b74c174",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/intel/phy-intel-lgm-emmc.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define EMMC_PHYCTRL0_REG\t0xa8\n#define DR_TY_MASK\t\tGENMASK(30, 28)\n#define DR_TY_SHIFT(x)\t\t(((x) << 28) & DR_TY_MASK)\n#define OTAPDLYENA\t\tBIT(14)\n#define OTAPDLYSEL_MASK\t\tGENMASK(13, 10)\n#define OTAPDLYSEL_SHIFT(x)\t(((x) << 10) & OTAPDLYSEL_MASK)\n\n#define EMMC_PHYCTRL1_REG\t0xac\n#define PDB_MASK\t\tBIT(0)\n#define PDB_SHIFT(x)\t\t(((x) << 0) & PDB_MASK)\n#define ENDLL_MASK\t\tBIT(7)\n#define ENDLL_SHIFT(x)\t\t(((x) << 7) & ENDLL_MASK)\n\n#define EMMC_PHYCTRL2_REG\t0xb0\n#define FRQSEL_25M\t\t0\n#define FRQSEL_50M\t\t1\n#define FRQSEL_100M\t\t2\n#define FRQSEL_150M\t\t3\n#define FRQSEL_MASK\t\tGENMASK(24, 22)\n#define FRQSEL_SHIFT(x)\t\t(((x) << 22) & FRQSEL_MASK)\n\n#define EMMC_PHYSTAT_REG\t0xbc\n#define CALDONE_MASK\t\tBIT(9)\n#define DLLRDY_MASK\t\tBIT(8)\n#define IS_CALDONE(x)\t((x) & CALDONE_MASK)\n#define IS_DLLRDY(x)\t((x) & DLLRDY_MASK)\n\nstruct intel_emmc_phy {\n\tstruct regmap *syscfg;\n\tstruct clk *emmcclk;\n};\n\nstatic int intel_emmc_phy_power(struct phy *phy, bool on_off)\n{\n\tstruct intel_emmc_phy *priv = phy_get_drvdata(phy);\n\tunsigned int caldone;\n\tunsigned int dllrdy;\n\tunsigned int freqsel;\n\tunsigned long rate;\n\tint ret, quot;\n\n\t \n\tret = regmap_update_bits(priv->syscfg, EMMC_PHYCTRL1_REG, PDB_MASK,\n\t\t\t\t PDB_SHIFT(0));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"CALIO power down bar failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!on_off)\n\t\treturn 0;\n\n\trate = clk_get_rate(priv->emmcclk);\n\tquot = DIV_ROUND_CLOSEST(rate, 50000000);\n\tif (quot > FRQSEL_150M)\n\t\tdev_warn(&phy->dev, \"Unsupported rate: %lu\\n\", rate);\n\tfreqsel = clamp_t(int, quot, FRQSEL_25M, FRQSEL_150M);\n\n\t \n\tudelay(5);\n\n\tret = regmap_update_bits(priv->syscfg, EMMC_PHYCTRL1_REG, PDB_MASK,\n\t\t\t\t PDB_SHIFT(1));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"CALIO power down bar failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read_poll_timeout(priv->syscfg, EMMC_PHYSTAT_REG,\n\t\t\t\t       caldone, IS_CALDONE(caldone),\n\t\t\t\t       0, 50);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"caldone failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->syscfg, EMMC_PHYCTRL2_REG, FRQSEL_MASK,\n\t\t\t\t FRQSEL_SHIFT(freqsel));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"set the frequency of dll failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->syscfg, EMMC_PHYCTRL1_REG, ENDLL_MASK,\n\t\t\t\t ENDLL_SHIFT(1));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"turn on the dll failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read_poll_timeout(priv->syscfg,\n\t\t\t\t       EMMC_PHYSTAT_REG,\n\t\t\t\t       dllrdy, IS_DLLRDY(dllrdy),\n\t\t\t\t       0, 50 * USEC_PER_MSEC);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"dllrdy failed. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_emmc_phy_init(struct phy *phy)\n{\n\tstruct intel_emmc_phy *priv = phy_get_drvdata(phy);\n\n\t \n\tpriv->emmcclk = clk_get_optional(&phy->dev, \"emmcclk\");\n\tif (IS_ERR(priv->emmcclk)) {\n\t\tdev_err(&phy->dev, \"ERROR: getting emmcclk\\n\");\n\t\treturn PTR_ERR(priv->emmcclk);\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_emmc_phy_exit(struct phy *phy)\n{\n\tstruct intel_emmc_phy *priv = phy_get_drvdata(phy);\n\n\tclk_put(priv->emmcclk);\n\n\treturn 0;\n}\n\nstatic int intel_emmc_phy_power_on(struct phy *phy)\n{\n\tstruct intel_emmc_phy *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(priv->syscfg, EMMC_PHYCTRL0_REG, DR_TY_MASK,\n\t\t\t\t DR_TY_SHIFT(6));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"ERROR set drive-impednce-50ohm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->syscfg, EMMC_PHYCTRL0_REG, OTAPDLYENA,\n\t\t\t\t 0);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"ERROR Set output tap delay : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->syscfg, EMMC_PHYCTRL0_REG,\n\t\t\t\t OTAPDLYSEL_MASK, OTAPDLYSEL_SHIFT(4));\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"ERROR: output tap dly select: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn intel_emmc_phy_power(phy, true);\n}\n\nstatic int intel_emmc_phy_power_off(struct phy *phy)\n{\n\t \n\treturn intel_emmc_phy_power(phy, false);\n}\n\nstatic const struct phy_ops ops = {\n\t.init\t\t= intel_emmc_phy_init,\n\t.exit\t\t= intel_emmc_phy_exit,\n\t.power_on\t= intel_emmc_phy_power_on,\n\t.power_off\t= intel_emmc_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int intel_emmc_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct intel_emmc_phy *priv;\n\tstruct phy *generic_phy;\n\tstruct phy_provider *phy_provider;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->syscfg = syscon_regmap_lookup_by_phandle(np, \"intel,syscon\");\n\tif (IS_ERR(priv->syscfg)) {\n\t\tdev_err(dev, \"failed to find syscon\\n\");\n\t\treturn PTR_ERR(priv->syscfg);\n\t}\n\n\tgeneric_phy = devm_phy_create(dev, np, &ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(generic_phy);\n\t}\n\n\tphy_set_drvdata(generic_phy, priv);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id intel_emmc_phy_dt_ids[] = {\n\t{ .compatible = \"intel,lgm-emmc-phy\" },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, intel_emmc_phy_dt_ids);\n\nstatic struct platform_driver intel_emmc_driver = {\n\t.probe\t\t= intel_emmc_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"intel-emmc-phy\",\n\t\t.of_match_table = intel_emmc_phy_dt_ids,\n\t},\n};\n\nmodule_platform_driver(intel_emmc_driver);\n\nMODULE_AUTHOR(\"Peter Harliman Liem <peter.harliman.liem@intel.com>\");\nMODULE_DESCRIPTION(\"Intel eMMC PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}