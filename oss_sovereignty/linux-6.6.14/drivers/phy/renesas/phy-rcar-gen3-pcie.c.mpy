{
  "module_name": "phy-rcar-gen3-pcie.c",
  "hash_id": "a7ed97a0863a5fd43923f8890ad9203fc76ed9927054eefbd5d3cf2ae9d41f98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/renesas/phy-rcar-gen3-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#define PHY_CTRL\t\t0x4000\t\t \n\n \n#define PHY_CTRL_PHY_PWDN\tBIT(2)\n\nstruct rcar_gen3_phy {\n\tstruct phy *phy;\n\tspinlock_t lock;\n\tvoid __iomem *base;\n};\n\nstatic void rcar_gen3_phy_pcie_modify_reg(struct phy *p, unsigned int reg,\n\t\t\t\t\t  u32 clear, u32 set)\n{\n\tstruct rcar_gen3_phy *phy = phy_get_drvdata(p);\n\tvoid __iomem *base = phy->base;\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&phy->lock, flags);\n\n\tvalue = readl(base + reg);\n\tvalue &= ~clear;\n\tvalue |= set;\n\twritel(value, base + reg);\n\n\tspin_unlock_irqrestore(&phy->lock, flags);\n}\n\nstatic int r8a77980_phy_pcie_power_on(struct phy *p)\n{\n\t \n\trcar_gen3_phy_pcie_modify_reg(p, PHY_CTRL, PHY_CTRL_PHY_PWDN, 0);\n\n\treturn 0;\n}\n\nstatic int r8a77980_phy_pcie_power_off(struct phy *p)\n{\n\t \n\trcar_gen3_phy_pcie_modify_reg(p, PHY_CTRL, 0, PHY_CTRL_PHY_PWDN);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops r8a77980_phy_pcie_ops = {\n\t.power_on\t= r8a77980_phy_pcie_power_on,\n\t.power_off\t= r8a77980_phy_pcie_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id rcar_gen3_phy_pcie_match_table[] = {\n\t{ .compatible = \"renesas,r8a77980-pcie-phy\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rcar_gen3_phy_pcie_match_table);\n\nstatic int rcar_gen3_phy_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *provider;\n\tstruct rcar_gen3_phy *phy;\n\tvoid __iomem *base;\n\tint error;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev,\n\t\t\t\"This driver must only be instantiated from the device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&phy->lock);\n\n\tphy->base = base;\n\n\t \n\tpm_runtime_enable(dev);\n\n\tphy->phy = devm_phy_create(dev, NULL, &r8a77980_phy_pcie_ops);\n\tif (IS_ERR(phy->phy)) {\n\t\tdev_err(dev, \"Failed to create PCIe PHY\\n\");\n\t\terror = PTR_ERR(phy->phy);\n\t\tgoto error;\n\t}\n\tphy_set_drvdata(phy->phy, phy);\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(dev, \"Failed to register PHY provider\\n\");\n\t\terror = PTR_ERR(provider);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tpm_runtime_disable(dev);\n\n\treturn error;\n}\n\nstatic void rcar_gen3_phy_pcie_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n};\n\nstatic struct platform_driver rcar_gen3_phy_driver = {\n\t.driver = {\n\t\t.name\t\t= \"phy_rcar_gen3_pcie\",\n\t\t.of_match_table\t= rcar_gen3_phy_pcie_match_table,\n\t},\n\t.probe\t= rcar_gen3_phy_pcie_probe,\n\t.remove_new = rcar_gen3_phy_pcie_remove,\n};\n\nmodule_platform_driver(rcar_gen3_phy_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Renesas R-Car Gen3 PCIe PHY\");\nMODULE_AUTHOR(\"Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}