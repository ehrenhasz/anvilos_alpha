{
  "module_name": "phy-rcar-gen3-usb3.c",
  "hash_id": "e8d7998fe289c8bc8b5cfa33f39583cfbf69731a5a3af299e4520eaf26d67b8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/renesas/phy-rcar-gen3-usb3.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#define USB30_CLKSET0\t\t0x034\n#define USB30_CLKSET1\t\t0x036\n#define USB30_SSC_SET\t\t0x038\n#define USB30_PHY_ENABLE\t0x060\n#define USB30_VBUS_EN\t\t0x064\n\n \n#define CLKSET0_PRIVATE\t\t\t0x05c0\n#define CLKSET0_USB30_FSEL_USB_EXTAL\t0x0002\n\n \n#define CLKSET1_USB30_PLL_MULTI_SHIFT\t\t6\n#define CLKSET1_USB30_PLL_MULTI_USB_EXTAL\t(0x64 << \\\n\t\t\t\t\t\t CLKSET1_USB30_PLL_MULTI_SHIFT)\n#define CLKSET1_PHYRESET\tBIT(4)\t \n#define CLKSET1_REF_CLKDIV\tBIT(3)\t \n#define CLKSET1_PRIVATE_2_1\tBIT(1)\t \n#define CLKSET1_REF_CLK_SEL\tBIT(0)\t \n\n \n#define SSC_SET_SSC_EN\t\tBIT(12)\n#define SSC_SET_RANGE_SHIFT\t9\n#define SSC_SET_RANGE_4980\t(0x0 << SSC_SET_RANGE_SHIFT)\n#define SSC_SET_RANGE_4492\t(0x1 << SSC_SET_RANGE_SHIFT)\n#define SSC_SET_RANGE_4003\t(0x2 << SSC_SET_RANGE_SHIFT)\n\n \n#define PHY_ENABLE_RESET_EN\tBIT(4)\n\n \n#define VBUS_EN_VBUS_EN\t\tBIT(1)\n\nstruct rcar_gen3_usb3 {\n\tvoid __iomem *base;\n\tstruct phy *phy;\n\tu32 ssc_range;\n\tbool usb3s_clk;\n\tbool usb_extal;\n};\n\nstatic void write_clkset1_for_usb_extal(struct rcar_gen3_usb3 *r, bool reset)\n{\n\tu16 val = CLKSET1_USB30_PLL_MULTI_USB_EXTAL |\n\t\t  CLKSET1_REF_CLKDIV | CLKSET1_PRIVATE_2_1;\n\n\tif (reset)\n\t\tval |= CLKSET1_PHYRESET;\n\n\twritew(val, r->base + USB30_CLKSET1);\n}\n\nstatic void rcar_gen3_phy_usb3_enable_ssc(struct rcar_gen3_usb3 *r)\n{\n\tu16 val = SSC_SET_SSC_EN;\n\n\tswitch (r->ssc_range) {\n\tcase 4980:\n\t\tval |= SSC_SET_RANGE_4980;\n\t\tbreak;\n\tcase 4492:\n\t\tval |= SSC_SET_RANGE_4492;\n\t\tbreak;\n\tcase 4003:\n\t\tval |= SSC_SET_RANGE_4003;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&r->phy->dev, \"%s: unsupported range (%x)\\n\", __func__,\n\t\t\tr->ssc_range);\n\t\treturn;\n\t}\n\n\twritew(val, r->base + USB30_SSC_SET);\n}\n\nstatic void rcar_gen3_phy_usb3_select_usb_extal(struct rcar_gen3_usb3 *r)\n{\n\twrite_clkset1_for_usb_extal(r, false);\n\tif (r->ssc_range)\n\t\trcar_gen3_phy_usb3_enable_ssc(r);\n\twritew(CLKSET0_PRIVATE | CLKSET0_USB30_FSEL_USB_EXTAL,\n\t       r->base + USB30_CLKSET0);\n\twritew(PHY_ENABLE_RESET_EN, r->base + USB30_PHY_ENABLE);\n\twrite_clkset1_for_usb_extal(r, true);\n\tusleep_range(10, 20);\n\twrite_clkset1_for_usb_extal(r, false);\n}\n\nstatic int rcar_gen3_phy_usb3_init(struct phy *p)\n{\n\tstruct rcar_gen3_usb3 *r = phy_get_drvdata(p);\n\n\tdev_vdbg(&r->phy->dev, \"%s: enter (%d, %d, %d)\\n\", __func__,\n\t\t r->usb3s_clk, r->usb_extal, r->ssc_range);\n\n\tif (!r->usb3s_clk && r->usb_extal)\n\t\trcar_gen3_phy_usb3_select_usb_extal(r);\n\n\t \n\twritew(VBUS_EN_VBUS_EN, r->base + USB30_VBUS_EN);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops rcar_gen3_phy_usb3_ops = {\n\t.init\t\t= rcar_gen3_phy_usb3_init,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id rcar_gen3_phy_usb3_match_table[] = {\n\t{ .compatible = \"renesas,rcar-gen3-usb3-phy\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rcar_gen3_phy_usb3_match_table);\n\nstatic int rcar_gen3_phy_usb3_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rcar_gen3_usb3 *r;\n\tstruct phy_provider *provider;\n\tint ret = 0;\n\tstruct clk *clk;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"This driver needs device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = devm_kzalloc(dev, sizeof(*r), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tr->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(r->base))\n\t\treturn PTR_ERR(r->base);\n\n\tclk = devm_clk_get(dev, \"usb3s_clk\");\n\tif (!IS_ERR(clk) && !clk_prepare_enable(clk)) {\n\t\tr->usb3s_clk = !!clk_get_rate(clk);\n\t\tclk_disable_unprepare(clk);\n\t}\n\tclk = devm_clk_get(dev, \"usb_extal\");\n\tif (!IS_ERR(clk) && !clk_prepare_enable(clk)) {\n\t\tr->usb_extal = !!clk_get_rate(clk);\n\t\tclk_disable_unprepare(clk);\n\t}\n\n\tif (!r->usb3s_clk && !r->usb_extal) {\n\t\tdev_err(dev, \"This driver needs usb3s_clk and/or usb_extal\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tpm_runtime_enable(dev);\n\n\tr->phy = devm_phy_create(dev, NULL, &rcar_gen3_phy_usb3_ops);\n\tif (IS_ERR(r->phy)) {\n\t\tdev_err(dev, \"Failed to create USB3 PHY\\n\");\n\t\tret = PTR_ERR(r->phy);\n\t\tgoto error;\n\t}\n\n\tof_property_read_u32(dev->of_node, \"renesas,ssc-range\", &r->ssc_range);\n\n\tplatform_set_drvdata(pdev, r);\n\tphy_set_drvdata(r->phy, r);\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(dev, \"Failed to register PHY provider\\n\");\n\t\tret = PTR_ERR(provider);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void rcar_gen3_phy_usb3_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n};\n\nstatic struct platform_driver rcar_gen3_phy_usb3_driver = {\n\t.driver = {\n\t\t.name\t\t= \"phy_rcar_gen3_usb3\",\n\t\t.of_match_table\t= rcar_gen3_phy_usb3_match_table,\n\t},\n\t.probe\t= rcar_gen3_phy_usb3_probe,\n\t.remove_new = rcar_gen3_phy_usb3_remove,\n};\nmodule_platform_driver(rcar_gen3_phy_usb3_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Renesas R-Car Gen3 USB 3.0 PHY\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}