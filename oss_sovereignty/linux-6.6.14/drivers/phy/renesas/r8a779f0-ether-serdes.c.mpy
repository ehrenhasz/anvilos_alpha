{
  "module_name": "r8a779f0-ether-serdes.c",
  "hash_id": "47798624c442fde05c03de1c75ac2c940a0900c1e4c43aa2149b58dd2849de5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/renesas/r8a779f0-ether-serdes.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#define R8A779F0_ETH_SERDES_NUM\t\t\t3\n#define R8A779F0_ETH_SERDES_OFFSET\t\t0x0400\n#define R8A779F0_ETH_SERDES_BANK_SELECT\t\t0x03fc\n#define R8A779F0_ETH_SERDES_TIMEOUT_US\t\t100000\n#define R8A779F0_ETH_SERDES_NUM_RETRY_LINKUP\t3\n\nstruct r8a779f0_eth_serdes_drv_data;\nstruct r8a779f0_eth_serdes_channel {\n\tstruct r8a779f0_eth_serdes_drv_data *dd;\n\tstruct phy *phy;\n\tvoid __iomem *addr;\n\tphy_interface_t phy_interface;\n\tint speed;\n\tint index;\n};\n\nstruct r8a779f0_eth_serdes_drv_data {\n\tvoid __iomem *addr;\n\tstruct platform_device *pdev;\n\tstruct reset_control *reset;\n\tstruct r8a779f0_eth_serdes_channel channel[R8A779F0_ETH_SERDES_NUM];\n\tbool initialized;\n};\n\n \nstatic void r8a779f0_eth_serdes_write32(void __iomem *addr, u32 offs, u32 bank, u32 data)\n{\n\tiowrite32(bank, addr + R8A779F0_ETH_SERDES_BANK_SELECT);\n\tiowrite32(data, addr + offs);\n}\n\nstatic int\nr8a779f0_eth_serdes_reg_wait(struct r8a779f0_eth_serdes_channel *channel,\n\t\t\t     u32 offs, u32 bank, u32 mask, u32 expected)\n{\n\tint ret;\n\tu32 val;\n\n\tiowrite32(bank, channel->addr + R8A779F0_ETH_SERDES_BANK_SELECT);\n\n\tret = readl_poll_timeout_atomic(channel->addr + offs, val,\n\t\t\t\t\t(val & mask) == expected,\n\t\t\t\t\t1, R8A779F0_ETH_SERDES_TIMEOUT_US);\n\tif (ret)\n\t\tdev_dbg(&channel->phy->dev,\n\t\t\t\"%s: index %d, offs %x, bank %x, mask %x, expected %x\\n\",\n\t\t\t __func__, channel->index, offs, bank, mask, expected);\n\n\treturn ret;\n}\n\nstatic int\nr8a779f0_eth_serdes_common_init_ram(struct r8a779f0_eth_serdes_drv_data *dd)\n{\n\tstruct r8a779f0_eth_serdes_channel *channel;\n\tint i, ret;\n\n\tfor (i = 0; i < R8A779F0_ETH_SERDES_NUM; i++) {\n\t\tchannel = &dd->channel[i];\n\t\tret = r8a779f0_eth_serdes_reg_wait(channel, 0x026c, 0x180, BIT(0), 0x01);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tr8a779f0_eth_serdes_write32(dd->addr, 0x026c, 0x180, 0x03);\n\n\treturn ret;\n}\n\nstatic int\nr8a779f0_eth_serdes_common_setting(struct r8a779f0_eth_serdes_channel *channel)\n{\n\tstruct r8a779f0_eth_serdes_drv_data *dd = channel->dd;\n\n\tswitch (channel->phy_interface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tr8a779f0_eth_serdes_write32(dd->addr, 0x0244, 0x180, 0x0097);\n\t\tr8a779f0_eth_serdes_write32(dd->addr, 0x01d0, 0x180, 0x0060);\n\t\tr8a779f0_eth_serdes_write32(dd->addr, 0x01d8, 0x180, 0x2200);\n\t\tr8a779f0_eth_serdes_write32(dd->addr, 0x01d4, 0x180, 0x0000);\n\t\tr8a779f0_eth_serdes_write32(dd->addr, 0x01e0, 0x180, 0x003d);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nr8a779f0_eth_serdes_chan_setting(struct r8a779f0_eth_serdes_channel *channel)\n{\n\tint ret;\n\n\tswitch (channel->phy_interface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0000, 0x380, 0x2000);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x01c0, 0x180, 0x0011);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0248, 0x180, 0x0540);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0258, 0x180, 0x0015);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0144, 0x180, 0x0100);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x01a0, 0x180, 0x0000);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x00d0, 0x180, 0x0002);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0150, 0x180, 0x0003);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x00c8, 0x180, 0x0100);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0148, 0x180, 0x0100);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0174, 0x180, 0x0000);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0160, 0x180, 0x0007);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x01ac, 0x180, 0x0000);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x00c4, 0x180, 0x0310);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x00c8, 0x180, 0x0101);\n\t\tret = r8a779f0_eth_serdes_reg_wait(channel, 0x00c8, 0x0180, BIT(0), 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0148, 0x180, 0x0101);\n\t\tret = r8a779f0_eth_serdes_reg_wait(channel, 0x0148, 0x0180, BIT(0), 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x00c4, 0x180, 0x1310);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x00d8, 0x180, 0x1800);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x00dc, 0x180, 0x0000);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x001c, 0x300, 0x0001);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0000, 0x380, 0x2100);\n\t\tret = r8a779f0_eth_serdes_reg_wait(channel, 0x0000, 0x0380, BIT(8), 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (channel->speed == 1000)\n\t\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0000, 0x1f00, 0x0140);\n\t\telse if (channel->speed == 100)\n\t\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0000, 0x1f00, 0x2100);\n\n\t\t \n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0004, 0x1f80, 0x0005);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0028, 0x1f80, 0x07a1);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0000, 0x1f80, 0x0208);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nr8a779f0_eth_serdes_chan_speed(struct r8a779f0_eth_serdes_channel *channel)\n{\n\tint ret;\n\n\tswitch (channel->phy_interface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\t \n\t\tif (channel->speed == 1000)\n\t\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0000, 0x1f00, 0x1140);\n\t\telse if (channel->speed == 100)\n\t\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0000, 0x1f00, 0x3100);\n\t\tret = r8a779f0_eth_serdes_reg_wait(channel, 0x0008, 0x1f80, BIT(0), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0008, 0x1f80, 0x0000);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int r8a779f0_eth_serdes_monitor_linkup(struct r8a779f0_eth_serdes_channel *channel)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < R8A779F0_ETH_SERDES_NUM_RETRY_LINKUP; i++) {\n\t\tret = r8a779f0_eth_serdes_reg_wait(channel, 0x0004, 0x300,\n\t\t\t\t\t\t   BIT(2), BIT(2));\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\t \n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0144, 0x180, 0x0100);\n\t\tudelay(1);\n\t\tr8a779f0_eth_serdes_write32(channel->addr, 0x0144, 0x180, 0x0000);\n\t}\n\n\treturn ret;\n}\n\nstatic int r8a779f0_eth_serdes_hw_init(struct r8a779f0_eth_serdes_channel *channel)\n{\n\tstruct r8a779f0_eth_serdes_drv_data *dd = channel->dd;\n\tint i, ret;\n\n\tif (dd->initialized)\n\t\treturn 0;\n\n\tret = r8a779f0_eth_serdes_common_init_ram(dd);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < R8A779F0_ETH_SERDES_NUM; i++) {\n\t\tret = r8a779f0_eth_serdes_reg_wait(&dd->channel[i], 0x0000,\n\t\t\t\t\t\t   0x300, BIT(15), 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < R8A779F0_ETH_SERDES_NUM; i++)\n\t\tr8a779f0_eth_serdes_write32(dd->channel[i].addr, 0x03d4, 0x380, 0x0443);\n\n\tret = r8a779f0_eth_serdes_common_setting(channel);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < R8A779F0_ETH_SERDES_NUM; i++)\n\t\tr8a779f0_eth_serdes_write32(dd->channel[i].addr, 0x03d0, 0x380, 0x0001);\n\n\n\tr8a779f0_eth_serdes_write32(dd->addr, 0x0000, 0x380, 0x8000);\n\n\tret = r8a779f0_eth_serdes_common_init_ram(dd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn r8a779f0_eth_serdes_reg_wait(&dd->channel[0], 0x0000, 0x380, BIT(15), 0);\n}\n\nstatic int r8a779f0_eth_serdes_init(struct phy *p)\n{\n\tstruct r8a779f0_eth_serdes_channel *channel = phy_get_drvdata(p);\n\tint ret;\n\n\tret = r8a779f0_eth_serdes_hw_init(channel);\n\tif (!ret)\n\t\tchannel->dd->initialized = true;\n\n\treturn ret;\n}\n\nstatic int r8a779f0_eth_serdes_hw_init_late(struct r8a779f0_eth_serdes_channel\n*channel)\n{\n\tint ret;\n\n\tret = r8a779f0_eth_serdes_chan_setting(channel);\n\tif (ret)\n\t\treturn ret;\n\n\tret = r8a779f0_eth_serdes_chan_speed(channel);\n\tif (ret)\n\t\treturn ret;\n\n\tr8a779f0_eth_serdes_write32(channel->addr, 0x03c0, 0x380, 0x0000);\n\n\tr8a779f0_eth_serdes_write32(channel->addr, 0x03d0, 0x380, 0x0000);\n\n\treturn r8a779f0_eth_serdes_monitor_linkup(channel);\n}\n\nstatic int r8a779f0_eth_serdes_power_on(struct phy *p)\n{\n\tstruct r8a779f0_eth_serdes_channel *channel = phy_get_drvdata(p);\n\n\treturn r8a779f0_eth_serdes_hw_init_late(channel);\n}\n\nstatic int r8a779f0_eth_serdes_set_mode(struct phy *p, enum phy_mode mode,\n\t\t\t\t\tint submode)\n{\n\tstruct r8a779f0_eth_serdes_channel *channel = phy_get_drvdata(p);\n\n\tif (mode != PHY_MODE_ETHERNET)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (submode) {\n\tcase PHY_INTERFACE_MODE_GMII:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\tchannel->phy_interface = submode;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int r8a779f0_eth_serdes_set_speed(struct phy *p, int speed)\n{\n\tstruct r8a779f0_eth_serdes_channel *channel = phy_get_drvdata(p);\n\n\tchannel->speed = speed;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops r8a779f0_eth_serdes_ops = {\n\t.init\t\t= r8a779f0_eth_serdes_init,\n\t.power_on\t= r8a779f0_eth_serdes_power_on,\n\t.set_mode\t= r8a779f0_eth_serdes_set_mode,\n\t.set_speed\t= r8a779f0_eth_serdes_set_speed,\n};\n\nstatic struct phy *r8a779f0_eth_serdes_xlate(struct device *dev,\n\t\t\t\t\t     struct of_phandle_args *args)\n{\n\tstruct r8a779f0_eth_serdes_drv_data *dd = dev_get_drvdata(dev);\n\n\tif (args->args[0] >= R8A779F0_ETH_SERDES_NUM)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn dd->channel[args->args[0]].phy;\n}\n\nstatic const struct of_device_id r8a779f0_eth_serdes_of_table[] = {\n\t{ .compatible = \"renesas,r8a779f0-ether-serdes\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, r8a779f0_eth_serdes_of_table);\n\nstatic int r8a779f0_eth_serdes_probe(struct platform_device *pdev)\n{\n\tstruct r8a779f0_eth_serdes_drv_data *dd;\n\tstruct phy_provider *provider;\n\tint i;\n\n\tdd = devm_kzalloc(&pdev->dev, sizeof(*dd), GFP_KERNEL);\n\tif (!dd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dd);\n\tdd->pdev = pdev;\n\tdd->addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dd->addr))\n\t\treturn PTR_ERR(dd->addr);\n\n\tdd->reset = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(dd->reset))\n\t\treturn PTR_ERR(dd->reset);\n\n\treset_control_reset(dd->reset);\n\n\tfor (i = 0; i < R8A779F0_ETH_SERDES_NUM; i++) {\n\t\tstruct r8a779f0_eth_serdes_channel *channel = &dd->channel[i];\n\n\t\tchannel->phy = devm_phy_create(&pdev->dev, NULL,\n\t\t\t\t\t       &r8a779f0_eth_serdes_ops);\n\t\tif (IS_ERR(channel->phy))\n\t\t\treturn PTR_ERR(channel->phy);\n\t\tchannel->addr = dd->addr + R8A779F0_ETH_SERDES_OFFSET * i;\n\t\tchannel->dd = dd;\n\t\tchannel->index = i;\n\t\tphy_set_drvdata(channel->phy, channel);\n\t}\n\n\tprovider = devm_of_phy_provider_register(&pdev->dev,\n\t\t\t\t\t\t r8a779f0_eth_serdes_xlate);\n\tif (IS_ERR(provider))\n\t\treturn PTR_ERR(provider);\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void r8a779f0_eth_serdes_remove(struct platform_device *pdev)\n{\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic struct platform_driver r8a779f0_eth_serdes_driver_platform = {\n\t.probe = r8a779f0_eth_serdes_probe,\n\t.remove_new = r8a779f0_eth_serdes_remove,\n\t.driver = {\n\t\t.name = \"r8a779f0_eth_serdes\",\n\t\t.of_match_table = r8a779f0_eth_serdes_of_table,\n\t}\n};\nmodule_platform_driver(r8a779f0_eth_serdes_driver_platform);\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\nMODULE_DESCRIPTION(\"Renesas Ethernet SERDES device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}