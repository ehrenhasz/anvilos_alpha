{
  "module_name": "phy-rcar-gen3-usb2.c",
  "hash_id": "422d0d822acb4755ee50a1128e2d1ddf4c18fbd70ed2d096963ceb8a123246f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/renesas/phy-rcar-gen3-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/extcon-provider.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/string.h>\n#include <linux/usb/of.h>\n#include <linux/workqueue.h>\n\n \n#define USB2_INT_ENABLE\t\t0x000\n#define USB2_USBCTR\t\t0x00c\n#define USB2_SPD_RSM_TIMSET\t0x10c\n#define USB2_OC_TIMSET\t\t0x110\n#define USB2_COMMCTRL\t\t0x600\n#define USB2_OBINTSTA\t\t0x604\n#define USB2_OBINTEN\t\t0x608\n#define USB2_VBCTRL\t\t0x60c\n#define USB2_LINECTRL1\t\t0x610\n#define USB2_ADPCTRL\t\t0x630\n\n \n#define USB2_INT_ENABLE_UCOM_INTEN\tBIT(3)\n#define USB2_INT_ENABLE_USBH_INTB_EN\tBIT(2)\t \n#define USB2_INT_ENABLE_USBH_INTA_EN\tBIT(1)\t \n\n \n#define USB2_USBCTR_DIRPD\tBIT(2)\n#define USB2_USBCTR_PLL_RST\tBIT(1)\n\n \n#define USB2_SPD_RSM_TIMSET_INIT\t0x014e029b\n\n \n#define USB2_OC_TIMSET_INIT\t\t0x000209ab\n\n \n#define USB2_COMMCTRL_OTG_PERI\t\tBIT(31)\t \n\n \n#define USB2_OBINT_SESSVLDCHG\t\tBIT(12)\n#define USB2_OBINT_IDDIGCHG\t\tBIT(11)\n#define USB2_OBINT_BITS\t\t\t(USB2_OBINT_SESSVLDCHG | \\\n\t\t\t\t\t USB2_OBINT_IDDIGCHG)\n\n \n#define USB2_VBCTRL_OCCLREN\t\tBIT(16)\n#define USB2_VBCTRL_DRVVBUSSEL\t\tBIT(8)\n#define USB2_VBCTRL_VBOUT\t\tBIT(0)\n\n \n#define USB2_LINECTRL1_DPRPD_EN\t\tBIT(19)\n#define USB2_LINECTRL1_DP_RPD\t\tBIT(18)\n#define USB2_LINECTRL1_DMRPD_EN\t\tBIT(17)\n#define USB2_LINECTRL1_DM_RPD\t\tBIT(16)\n#define USB2_LINECTRL1_OPMODE_NODRV\tBIT(6)\n\n \n#define USB2_ADPCTRL_OTGSESSVLD\t\tBIT(20)\n#define USB2_ADPCTRL_IDDIG\t\tBIT(19)\n#define USB2_ADPCTRL_IDPULLUP\t\tBIT(5)\t \n#define USB2_ADPCTRL_DRVVBUS\t\tBIT(4)\n\n \n#define USB2_OBINT_IDCHG_EN\t\tBIT(0)\n#define USB2_LINECTRL1_USB2_IDMON\tBIT(0)\n\n#define NUM_OF_PHYS\t\t\t4\nenum rcar_gen3_phy_index {\n\tPHY_INDEX_BOTH_HC,\n\tPHY_INDEX_OHCI,\n\tPHY_INDEX_EHCI,\n\tPHY_INDEX_HSUSB\n};\n\nstatic const u32 rcar_gen3_int_enable[NUM_OF_PHYS] = {\n\tUSB2_INT_ENABLE_USBH_INTB_EN | USB2_INT_ENABLE_USBH_INTA_EN,\n\tUSB2_INT_ENABLE_USBH_INTA_EN,\n\tUSB2_INT_ENABLE_USBH_INTB_EN,\n\t0\n};\n\nstruct rcar_gen3_phy {\n\tstruct phy *phy;\n\tstruct rcar_gen3_chan *ch;\n\tu32 int_enable_bits;\n\tbool initialized;\n\tbool otg_initialized;\n\tbool powered;\n};\n\nstruct rcar_gen3_chan {\n\tvoid __iomem *base;\n\tstruct device *dev;\t \n\tstruct extcon_dev *extcon;\n\tstruct rcar_gen3_phy rphys[NUM_OF_PHYS];\n\tstruct regulator *vbus;\n\tstruct work_struct work;\n\tstruct mutex lock;\t \n\tenum usb_dr_mode dr_mode;\n\tint irq;\n\tu32 obint_enable_bits;\n\tbool extcon_host;\n\tbool is_otg_channel;\n\tbool uses_otg_pins;\n\tbool soc_no_adp_ctrl;\n};\n\nstruct rcar_gen3_phy_drv_data {\n\tconst struct phy_ops *phy_usb2_ops;\n\tbool no_adp_ctrl;\n};\n\n \n\nstatic void rcar_gen3_phy_usb2_work(struct work_struct *work)\n{\n\tstruct rcar_gen3_chan *ch = container_of(work, struct rcar_gen3_chan,\n\t\t\t\t\t\t work);\n\n\tif (ch->extcon_host) {\n\t\textcon_set_state_sync(ch->extcon, EXTCON_USB_HOST, true);\n\t\textcon_set_state_sync(ch->extcon, EXTCON_USB, false);\n\t} else {\n\t\textcon_set_state_sync(ch->extcon, EXTCON_USB_HOST, false);\n\t\textcon_set_state_sync(ch->extcon, EXTCON_USB, true);\n\t}\n}\n\nstatic void rcar_gen3_set_host_mode(struct rcar_gen3_chan *ch, int host)\n{\n\tvoid __iomem *usb2_base = ch->base;\n\tu32 val = readl(usb2_base + USB2_COMMCTRL);\n\n\tdev_vdbg(ch->dev, \"%s: %08x, %d\\n\", __func__, val, host);\n\tif (host)\n\t\tval &= ~USB2_COMMCTRL_OTG_PERI;\n\telse\n\t\tval |= USB2_COMMCTRL_OTG_PERI;\n\twritel(val, usb2_base + USB2_COMMCTRL);\n}\n\nstatic void rcar_gen3_set_linectrl(struct rcar_gen3_chan *ch, int dp, int dm)\n{\n\tvoid __iomem *usb2_base = ch->base;\n\tu32 val = readl(usb2_base + USB2_LINECTRL1);\n\n\tdev_vdbg(ch->dev, \"%s: %08x, %d, %d\\n\", __func__, val, dp, dm);\n\tval &= ~(USB2_LINECTRL1_DP_RPD | USB2_LINECTRL1_DM_RPD);\n\tif (dp)\n\t\tval |= USB2_LINECTRL1_DP_RPD;\n\tif (dm)\n\t\tval |= USB2_LINECTRL1_DM_RPD;\n\twritel(val, usb2_base + USB2_LINECTRL1);\n}\n\nstatic void rcar_gen3_enable_vbus_ctrl(struct rcar_gen3_chan *ch, int vbus)\n{\n\tvoid __iomem *usb2_base = ch->base;\n\tu32 vbus_ctrl_reg = USB2_ADPCTRL;\n\tu32 vbus_ctrl_val = USB2_ADPCTRL_DRVVBUS;\n\tu32 val;\n\n\tdev_vdbg(ch->dev, \"%s: %08x, %d\\n\", __func__, val, vbus);\n\tif (ch->soc_no_adp_ctrl) {\n\t\tvbus_ctrl_reg = USB2_VBCTRL;\n\t\tvbus_ctrl_val = USB2_VBCTRL_VBOUT;\n\t}\n\n\tval = readl(usb2_base + vbus_ctrl_reg);\n\tif (vbus)\n\t\tval |= vbus_ctrl_val;\n\telse\n\t\tval &= ~vbus_ctrl_val;\n\twritel(val, usb2_base + vbus_ctrl_reg);\n}\n\nstatic void rcar_gen3_control_otg_irq(struct rcar_gen3_chan *ch, int enable)\n{\n\tvoid __iomem *usb2_base = ch->base;\n\tu32 val = readl(usb2_base + USB2_OBINTEN);\n\n\tif (ch->uses_otg_pins && enable)\n\t\tval |= ch->obint_enable_bits;\n\telse\n\t\tval &= ~ch->obint_enable_bits;\n\twritel(val, usb2_base + USB2_OBINTEN);\n}\n\nstatic void rcar_gen3_init_for_host(struct rcar_gen3_chan *ch)\n{\n\trcar_gen3_set_linectrl(ch, 1, 1);\n\trcar_gen3_set_host_mode(ch, 1);\n\trcar_gen3_enable_vbus_ctrl(ch, 1);\n\n\tch->extcon_host = true;\n\tschedule_work(&ch->work);\n}\n\nstatic void rcar_gen3_init_for_peri(struct rcar_gen3_chan *ch)\n{\n\trcar_gen3_set_linectrl(ch, 0, 1);\n\trcar_gen3_set_host_mode(ch, 0);\n\trcar_gen3_enable_vbus_ctrl(ch, 0);\n\n\tch->extcon_host = false;\n\tschedule_work(&ch->work);\n}\n\nstatic void rcar_gen3_init_for_b_host(struct rcar_gen3_chan *ch)\n{\n\tvoid __iomem *usb2_base = ch->base;\n\tu32 val;\n\n\tval = readl(usb2_base + USB2_LINECTRL1);\n\twritel(val | USB2_LINECTRL1_OPMODE_NODRV, usb2_base + USB2_LINECTRL1);\n\n\trcar_gen3_set_linectrl(ch, 1, 1);\n\trcar_gen3_set_host_mode(ch, 1);\n\trcar_gen3_enable_vbus_ctrl(ch, 0);\n\n\tval = readl(usb2_base + USB2_LINECTRL1);\n\twritel(val & ~USB2_LINECTRL1_OPMODE_NODRV, usb2_base + USB2_LINECTRL1);\n}\n\nstatic void rcar_gen3_init_for_a_peri(struct rcar_gen3_chan *ch)\n{\n\trcar_gen3_set_linectrl(ch, 0, 1);\n\trcar_gen3_set_host_mode(ch, 0);\n\trcar_gen3_enable_vbus_ctrl(ch, 1);\n}\n\nstatic void rcar_gen3_init_from_a_peri_to_a_host(struct rcar_gen3_chan *ch)\n{\n\trcar_gen3_control_otg_irq(ch, 0);\n\n\trcar_gen3_enable_vbus_ctrl(ch, 1);\n\trcar_gen3_init_for_host(ch);\n\n\trcar_gen3_control_otg_irq(ch, 1);\n}\n\nstatic bool rcar_gen3_check_id(struct rcar_gen3_chan *ch)\n{\n\tif (!ch->uses_otg_pins)\n\t\treturn (ch->dr_mode == USB_DR_MODE_HOST) ? false : true;\n\n\tif (ch->soc_no_adp_ctrl)\n\t\treturn !!(readl(ch->base + USB2_LINECTRL1) & USB2_LINECTRL1_USB2_IDMON);\n\n\treturn !!(readl(ch->base + USB2_ADPCTRL) & USB2_ADPCTRL_IDDIG);\n}\n\nstatic void rcar_gen3_device_recognition(struct rcar_gen3_chan *ch)\n{\n\tif (!rcar_gen3_check_id(ch))\n\t\trcar_gen3_init_for_host(ch);\n\telse\n\t\trcar_gen3_init_for_peri(ch);\n}\n\nstatic bool rcar_gen3_is_host(struct rcar_gen3_chan *ch)\n{\n\treturn !(readl(ch->base + USB2_COMMCTRL) & USB2_COMMCTRL_OTG_PERI);\n}\n\nstatic enum phy_mode rcar_gen3_get_phy_mode(struct rcar_gen3_chan *ch)\n{\n\tif (rcar_gen3_is_host(ch))\n\t\treturn PHY_MODE_USB_HOST;\n\n\treturn PHY_MODE_USB_DEVICE;\n}\n\nstatic bool rcar_gen3_is_any_rphy_initialized(struct rcar_gen3_chan *ch)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_OF_PHYS; i++) {\n\t\tif (ch->rphys[i].initialized)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool rcar_gen3_needs_init_otg(struct rcar_gen3_chan *ch)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_OF_PHYS; i++) {\n\t\tif (ch->rphys[i].otg_initialized)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool rcar_gen3_are_all_rphys_power_off(struct rcar_gen3_chan *ch)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_OF_PHYS; i++) {\n\t\tif (ch->rphys[i].powered)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic ssize_t role_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct rcar_gen3_chan *ch = dev_get_drvdata(dev);\n\tbool is_b_device;\n\tenum phy_mode cur_mode, new_mode;\n\n\tif (!ch->is_otg_channel || !rcar_gen3_is_any_rphy_initialized(ch))\n\t\treturn -EIO;\n\n\tif (sysfs_streq(buf, \"host\"))\n\t\tnew_mode = PHY_MODE_USB_HOST;\n\telse if (sysfs_streq(buf, \"peripheral\"))\n\t\tnew_mode = PHY_MODE_USB_DEVICE;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tis_b_device = rcar_gen3_check_id(ch);\n\tcur_mode = rcar_gen3_get_phy_mode(ch);\n\n\t \n\tif (cur_mode == new_mode)\n\t\treturn -EINVAL;\n\n\tif (new_mode == PHY_MODE_USB_HOST) {  \n\t\tif (!is_b_device)\t \n\t\t\trcar_gen3_init_from_a_peri_to_a_host(ch);\n\t\telse\t\t\t \n\t\t\trcar_gen3_init_for_b_host(ch);\n\t} else {\t\t\t \n\t\tif (!is_b_device)\t \n\t\t\trcar_gen3_init_for_a_peri(ch);\n\t\telse\t\t\t \n\t\t\trcar_gen3_init_for_peri(ch);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t role_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rcar_gen3_chan *ch = dev_get_drvdata(dev);\n\n\tif (!ch->is_otg_channel || !rcar_gen3_is_any_rphy_initialized(ch))\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"%s\\n\", rcar_gen3_is_host(ch) ? \"host\" :\n\t\t\t\t\t\t\t    \"peripheral\");\n}\nstatic DEVICE_ATTR_RW(role);\n\nstatic void rcar_gen3_init_otg(struct rcar_gen3_chan *ch)\n{\n\tvoid __iomem *usb2_base = ch->base;\n\tu32 val;\n\n\t \n\tval = readl(usb2_base + USB2_LINECTRL1);\n\tval = (val & ~USB2_LINECTRL1_DP_RPD) | USB2_LINECTRL1_DPRPD_EN |\n\t      USB2_LINECTRL1_DMRPD_EN | USB2_LINECTRL1_DM_RPD;\n\twritel(val, usb2_base + USB2_LINECTRL1);\n\n\tif (!ch->soc_no_adp_ctrl) {\n\t\tval = readl(usb2_base + USB2_VBCTRL);\n\t\tval &= ~USB2_VBCTRL_OCCLREN;\n\t\twritel(val | USB2_VBCTRL_DRVVBUSSEL, usb2_base + USB2_VBCTRL);\n\t\tval = readl(usb2_base + USB2_ADPCTRL);\n\t\twritel(val | USB2_ADPCTRL_IDPULLUP, usb2_base + USB2_ADPCTRL);\n\t}\n\tmsleep(20);\n\n\twritel(0xffffffff, usb2_base + USB2_OBINTSTA);\n\twritel(ch->obint_enable_bits, usb2_base + USB2_OBINTEN);\n\n\trcar_gen3_device_recognition(ch);\n}\n\nstatic irqreturn_t rcar_gen3_phy_usb2_irq(int irq, void *_ch)\n{\n\tstruct rcar_gen3_chan *ch = _ch;\n\tvoid __iomem *usb2_base = ch->base;\n\tu32 status = readl(usb2_base + USB2_OBINTSTA);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (status & ch->obint_enable_bits) {\n\t\tdev_vdbg(ch->dev, \"%s: %08x\\n\", __func__, status);\n\t\twritel(ch->obint_enable_bits, usb2_base + USB2_OBINTSTA);\n\t\trcar_gen3_device_recognition(ch);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int rcar_gen3_phy_usb2_init(struct phy *p)\n{\n\tstruct rcar_gen3_phy *rphy = phy_get_drvdata(p);\n\tstruct rcar_gen3_chan *channel = rphy->ch;\n\tvoid __iomem *usb2_base = channel->base;\n\tu32 val;\n\tint ret;\n\n\tif (!rcar_gen3_is_any_rphy_initialized(channel) && channel->irq >= 0) {\n\t\tINIT_WORK(&channel->work, rcar_gen3_phy_usb2_work);\n\t\tret = request_irq(channel->irq, rcar_gen3_phy_usb2_irq,\n\t\t\t\t  IRQF_SHARED, dev_name(channel->dev), channel);\n\t\tif (ret < 0) {\n\t\t\tdev_err(channel->dev, \"No irq handler (%d)\\n\", channel->irq);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tval = readl(usb2_base + USB2_INT_ENABLE);\n\tval |= USB2_INT_ENABLE_UCOM_INTEN | rphy->int_enable_bits;\n\twritel(val, usb2_base + USB2_INT_ENABLE);\n\twritel(USB2_SPD_RSM_TIMSET_INIT, usb2_base + USB2_SPD_RSM_TIMSET);\n\twritel(USB2_OC_TIMSET_INIT, usb2_base + USB2_OC_TIMSET);\n\n\t \n\tif (channel->is_otg_channel) {\n\t\tif (rcar_gen3_needs_init_otg(channel))\n\t\t\trcar_gen3_init_otg(channel);\n\t\trphy->otg_initialized = true;\n\t}\n\n\trphy->initialized = true;\n\n\treturn 0;\n}\n\nstatic int rcar_gen3_phy_usb2_exit(struct phy *p)\n{\n\tstruct rcar_gen3_phy *rphy = phy_get_drvdata(p);\n\tstruct rcar_gen3_chan *channel = rphy->ch;\n\tvoid __iomem *usb2_base = channel->base;\n\tu32 val;\n\n\trphy->initialized = false;\n\n\tif (channel->is_otg_channel)\n\t\trphy->otg_initialized = false;\n\n\tval = readl(usb2_base + USB2_INT_ENABLE);\n\tval &= ~rphy->int_enable_bits;\n\tif (!rcar_gen3_is_any_rphy_initialized(channel))\n\t\tval &= ~USB2_INT_ENABLE_UCOM_INTEN;\n\twritel(val, usb2_base + USB2_INT_ENABLE);\n\n\tif (channel->irq >= 0 && !rcar_gen3_is_any_rphy_initialized(channel))\n\t\tfree_irq(channel->irq, channel);\n\n\treturn 0;\n}\n\nstatic int rcar_gen3_phy_usb2_power_on(struct phy *p)\n{\n\tstruct rcar_gen3_phy *rphy = phy_get_drvdata(p);\n\tstruct rcar_gen3_chan *channel = rphy->ch;\n\tvoid __iomem *usb2_base = channel->base;\n\tu32 val;\n\tint ret = 0;\n\n\tmutex_lock(&channel->lock);\n\tif (!rcar_gen3_are_all_rphys_power_off(channel))\n\t\tgoto out;\n\n\tif (channel->vbus) {\n\t\tret = regulator_enable(channel->vbus);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tval = readl(usb2_base + USB2_USBCTR);\n\tval |= USB2_USBCTR_PLL_RST;\n\twritel(val, usb2_base + USB2_USBCTR);\n\tval &= ~USB2_USBCTR_PLL_RST;\n\twritel(val, usb2_base + USB2_USBCTR);\n\nout:\n\t \n\trphy->powered = true;\n\tmutex_unlock(&channel->lock);\n\n\treturn 0;\n}\n\nstatic int rcar_gen3_phy_usb2_power_off(struct phy *p)\n{\n\tstruct rcar_gen3_phy *rphy = phy_get_drvdata(p);\n\tstruct rcar_gen3_chan *channel = rphy->ch;\n\tint ret = 0;\n\n\tmutex_lock(&channel->lock);\n\trphy->powered = false;\n\n\tif (!rcar_gen3_are_all_rphys_power_off(channel))\n\t\tgoto out;\n\n\tif (channel->vbus)\n\t\tret = regulator_disable(channel->vbus);\n\nout:\n\tmutex_unlock(&channel->lock);\n\n\treturn ret;\n}\n\nstatic const struct phy_ops rcar_gen3_phy_usb2_ops = {\n\t.init\t\t= rcar_gen3_phy_usb2_init,\n\t.exit\t\t= rcar_gen3_phy_usb2_exit,\n\t.power_on\t= rcar_gen3_phy_usb2_power_on,\n\t.power_off\t= rcar_gen3_phy_usb2_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct phy_ops rz_g1c_phy_usb2_ops = {\n\t.init\t\t= rcar_gen3_phy_usb2_init,\n\t.exit\t\t= rcar_gen3_phy_usb2_exit,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct rcar_gen3_phy_drv_data rcar_gen3_phy_usb2_data = {\n\t.phy_usb2_ops = &rcar_gen3_phy_usb2_ops,\n\t.no_adp_ctrl = false,\n};\n\nstatic const struct rcar_gen3_phy_drv_data rz_g1c_phy_usb2_data = {\n\t.phy_usb2_ops = &rz_g1c_phy_usb2_ops,\n\t.no_adp_ctrl = false,\n};\n\nstatic const struct rcar_gen3_phy_drv_data rz_g2l_phy_usb2_data = {\n\t.phy_usb2_ops = &rcar_gen3_phy_usb2_ops,\n\t.no_adp_ctrl = true,\n};\n\nstatic const struct of_device_id rcar_gen3_phy_usb2_match_table[] = {\n\t{\n\t\t.compatible = \"renesas,usb2-phy-r8a77470\",\n\t\t.data = &rz_g1c_phy_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"renesas,usb2-phy-r8a7795\",\n\t\t.data = &rcar_gen3_phy_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"renesas,usb2-phy-r8a7796\",\n\t\t.data = &rcar_gen3_phy_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"renesas,usb2-phy-r8a77965\",\n\t\t.data = &rcar_gen3_phy_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"renesas,rzg2l-usb2-phy\",\n\t\t.data = &rz_g2l_phy_usb2_data,\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen3-usb2-phy\",\n\t\t.data = &rcar_gen3_phy_usb2_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, rcar_gen3_phy_usb2_match_table);\n\nstatic const unsigned int rcar_gen3_phy_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic struct phy *rcar_gen3_phy_usb2_xlate(struct device *dev,\n\t\t\t\t\t    struct of_phandle_args *args)\n{\n\tstruct rcar_gen3_chan *ch = dev_get_drvdata(dev);\n\n\tif (args->args_count == 0)\t \n\t\treturn ch->rphys[PHY_INDEX_BOTH_HC].phy;\n\telse if (args->args_count > 1)\t \n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (args->args[0] >= NUM_OF_PHYS)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn ch->rphys[args->args[0]].phy;\n}\n\nstatic enum usb_dr_mode rcar_gen3_get_dr_mode(struct device_node *np)\n{\n\tenum usb_dr_mode candidate = USB_DR_MODE_UNKNOWN;\n\tint i;\n\n\t \n\tfor (i = 0; i < NUM_OF_PHYS; i++) {\n\t\tenum usb_dr_mode mode = of_usb_get_dr_mode_by_phy(np, i);\n\n\t\tif (mode != USB_DR_MODE_UNKNOWN) {\n\t\t\tif (candidate == USB_DR_MODE_UNKNOWN)\n\t\t\t\tcandidate = mode;\n\t\t\telse if (candidate != mode)\n\t\t\t\treturn USB_DR_MODE_UNKNOWN;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nstatic int rcar_gen3_phy_usb2_probe(struct platform_device *pdev)\n{\n\tconst struct rcar_gen3_phy_drv_data *phy_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct rcar_gen3_chan *channel;\n\tstruct phy_provider *provider;\n\tint ret = 0, i;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"This driver needs device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannel = devm_kzalloc(dev, sizeof(*channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn -ENOMEM;\n\n\tchannel->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(channel->base))\n\t\treturn PTR_ERR(channel->base);\n\n\tchannel->obint_enable_bits = USB2_OBINT_BITS;\n\t \n\tchannel->irq = platform_get_irq_optional(pdev, 0);\n\tchannel->dr_mode = rcar_gen3_get_dr_mode(dev->of_node);\n\tif (channel->dr_mode != USB_DR_MODE_UNKNOWN) {\n\t\tint ret;\n\n\t\tchannel->is_otg_channel = true;\n\t\tchannel->uses_otg_pins = !of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\t\"renesas,no-otg-pins\");\n\t\tchannel->extcon = devm_extcon_dev_allocate(dev,\n\t\t\t\t\t\t\trcar_gen3_phy_cable);\n\t\tif (IS_ERR(channel->extcon))\n\t\t\treturn PTR_ERR(channel->extcon);\n\n\t\tret = devm_extcon_dev_register(dev, channel->extcon);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to register extcon\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tpm_runtime_enable(dev);\n\n\tphy_data = of_device_get_match_data(dev);\n\tif (!phy_data) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tchannel->soc_no_adp_ctrl = phy_data->no_adp_ctrl;\n\tif (phy_data->no_adp_ctrl)\n\t\tchannel->obint_enable_bits = USB2_OBINT_IDCHG_EN;\n\n\tmutex_init(&channel->lock);\n\tfor (i = 0; i < NUM_OF_PHYS; i++) {\n\t\tchannel->rphys[i].phy = devm_phy_create(dev, NULL,\n\t\t\t\t\t\t\tphy_data->phy_usb2_ops);\n\t\tif (IS_ERR(channel->rphys[i].phy)) {\n\t\t\tdev_err(dev, \"Failed to create USB2 PHY\\n\");\n\t\t\tret = PTR_ERR(channel->rphys[i].phy);\n\t\t\tgoto error;\n\t\t}\n\t\tchannel->rphys[i].ch = channel;\n\t\tchannel->rphys[i].int_enable_bits = rcar_gen3_int_enable[i];\n\t\tphy_set_drvdata(channel->rphys[i].phy, &channel->rphys[i]);\n\t}\n\n\tchannel->vbus = devm_regulator_get_optional(dev, \"vbus\");\n\tif (IS_ERR(channel->vbus)) {\n\t\tif (PTR_ERR(channel->vbus) == -EPROBE_DEFER) {\n\t\t\tret = PTR_ERR(channel->vbus);\n\t\t\tgoto error;\n\t\t}\n\t\tchannel->vbus = NULL;\n\t}\n\n\tplatform_set_drvdata(pdev, channel);\n\tchannel->dev = dev;\n\n\tprovider = devm_of_phy_provider_register(dev, rcar_gen3_phy_usb2_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(dev, \"Failed to register PHY provider\\n\");\n\t\tret = PTR_ERR(provider);\n\t\tgoto error;\n\t} else if (channel->is_otg_channel) {\n\t\tint ret;\n\n\t\tret = device_create_file(dev, &dev_attr_role);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void rcar_gen3_phy_usb2_remove(struct platform_device *pdev)\n{\n\tstruct rcar_gen3_chan *channel = platform_get_drvdata(pdev);\n\n\tif (channel->is_otg_channel)\n\t\tdevice_remove_file(&pdev->dev, &dev_attr_role);\n\n\tpm_runtime_disable(&pdev->dev);\n};\n\nstatic struct platform_driver rcar_gen3_phy_usb2_driver = {\n\t.driver = {\n\t\t.name\t\t= \"phy_rcar_gen3_usb2\",\n\t\t.of_match_table\t= rcar_gen3_phy_usb2_match_table,\n\t},\n\t.probe\t= rcar_gen3_phy_usb2_probe,\n\t.remove_new = rcar_gen3_phy_usb2_remove,\n};\nmodule_platform_driver(rcar_gen3_phy_usb2_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Renesas R-Car Gen3 USB 2.0 PHY\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}