{
  "module_name": "phy-hisi-inno-usb2.c",
  "hash_id": "af597faf5a7638ff946d6558bf2c7c228d1d2e231da31999c15bc9145890256e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/hisilicon/phy-hisi-inno-usb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#define INNO_PHY_PORT_NUM\t2\n#define REF_CLK_STABLE_TIME\t100\t \n#define UTMI_CLK_STABLE_TIME\t200\t \n#define TEST_CLK_STABLE_TIME\t2\t \n#define PHY_CLK_STABLE_TIME\t2\t \n#define UTMI_RST_COMPLETE_TIME\t2\t \n#define POR_RST_COMPLETE_TIME\t300\t \n\n#define PHY_TYPE_0\t0\n#define PHY_TYPE_1\t1\n\n#define PHY_TEST_DATA\t\tGENMASK(7, 0)\n#define PHY_TEST_ADDR_OFFSET\t8\n#define PHY0_TEST_ADDR\t\tGENMASK(15, 8)\n#define PHY0_TEST_PORT_OFFSET\t16\n#define PHY0_TEST_PORT\t\tGENMASK(18, 16)\n#define PHY0_TEST_WREN\t\tBIT(21)\n#define PHY0_TEST_CLK\t\tBIT(22)\t \n#define PHY0_TEST_RST\t\tBIT(23)\t \n#define PHY1_TEST_ADDR\t\tGENMASK(11, 8)\n#define PHY1_TEST_PORT_OFFSET\t12\n#define PHY1_TEST_PORT\t\tBIT(12)\n#define PHY1_TEST_WREN\t\tBIT(13)\n#define PHY1_TEST_CLK\t\tBIT(14)\t \n#define PHY1_TEST_RST\t\tBIT(15)\t \n\n#define PHY_CLK_ENABLE\t\tBIT(2)\n\nstruct hisi_inno_phy_port {\n\tstruct reset_control *utmi_rst;\n\tstruct hisi_inno_phy_priv *priv;\n};\n\nstruct hisi_inno_phy_priv {\n\tvoid __iomem *mmio;\n\tstruct clk *ref_clk;\n\tstruct reset_control *por_rst;\n\tunsigned int type;\n\tstruct hisi_inno_phy_port ports[INNO_PHY_PORT_NUM];\n};\n\nstatic void hisi_inno_phy_write_reg(struct hisi_inno_phy_priv *priv,\n\t\t\t\t    u8 port, u32 addr, u32 data)\n{\n\tvoid __iomem *reg = priv->mmio;\n\tu32 val;\n\tu32 value;\n\n\tif (priv->type == PHY_TYPE_0)\n\t\tval = (data & PHY_TEST_DATA) |\n\t\t      ((addr << PHY_TEST_ADDR_OFFSET) & PHY0_TEST_ADDR) |\n\t\t      ((port << PHY0_TEST_PORT_OFFSET) & PHY0_TEST_PORT) |\n\t\t      PHY0_TEST_WREN | PHY0_TEST_RST;\n\telse\n\t\tval = (data & PHY_TEST_DATA) |\n\t\t      ((addr << PHY_TEST_ADDR_OFFSET) & PHY1_TEST_ADDR) |\n\t\t      ((port << PHY1_TEST_PORT_OFFSET) & PHY1_TEST_PORT) |\n\t\t      PHY1_TEST_WREN | PHY1_TEST_RST;\n\twritel(val, reg);\n\n\tvalue = val;\n\tif (priv->type == PHY_TYPE_0)\n\t\tvalue |= PHY0_TEST_CLK;\n\telse\n\t\tvalue |= PHY1_TEST_CLK;\n\twritel(value, reg);\n\n\twritel(val, reg);\n}\n\nstatic void hisi_inno_phy_setup(struct hisi_inno_phy_priv *priv)\n{\n\t \n\thisi_inno_phy_write_reg(priv, 0, 0x06, PHY_CLK_ENABLE);\n\tmsleep(PHY_CLK_STABLE_TIME);\n}\n\nstatic int hisi_inno_phy_init(struct phy *phy)\n{\n\tstruct hisi_inno_phy_port *port = phy_get_drvdata(phy);\n\tstruct hisi_inno_phy_priv *priv = port->priv;\n\tint ret;\n\n\tret = clk_prepare_enable(priv->ref_clk);\n\tif (ret)\n\t\treturn ret;\n\tudelay(REF_CLK_STABLE_TIME);\n\n\treset_control_deassert(priv->por_rst);\n\tudelay(POR_RST_COMPLETE_TIME);\n\n\t \n\thisi_inno_phy_setup(priv);\n\n\treset_control_deassert(port->utmi_rst);\n\tudelay(UTMI_RST_COMPLETE_TIME);\n\n\treturn 0;\n}\n\nstatic int hisi_inno_phy_exit(struct phy *phy)\n{\n\tstruct hisi_inno_phy_port *port = phy_get_drvdata(phy);\n\tstruct hisi_inno_phy_priv *priv = port->priv;\n\n\treset_control_assert(port->utmi_rst);\n\treset_control_assert(priv->por_rst);\n\tclk_disable_unprepare(priv->ref_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops hisi_inno_phy_ops = {\n\t.init = hisi_inno_phy_init,\n\t.exit = hisi_inno_phy_exit,\n\t.owner = THIS_MODULE,\n};\n\nstatic int hisi_inno_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct hisi_inno_phy_priv *priv;\n\tstruct phy_provider *provider;\n\tstruct device_node *child;\n\tint i = 0;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->mmio)) {\n\t\tret = PTR_ERR(priv->mmio);\n\t\treturn ret;\n\t}\n\n\tpriv->ref_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->ref_clk))\n\t\treturn PTR_ERR(priv->ref_clk);\n\n\tpriv->por_rst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(priv->por_rst))\n\t\treturn PTR_ERR(priv->por_rst);\n\n\tpriv->type = (uintptr_t) of_device_get_match_data(dev);\n\n\tfor_each_child_of_node(np, child) {\n\t\tstruct reset_control *rst;\n\t\tstruct phy *phy;\n\n\t\trst = of_reset_control_get_exclusive(child, NULL);\n\t\tif (IS_ERR(rst)) {\n\t\t\tof_node_put(child);\n\t\t\treturn PTR_ERR(rst);\n\t\t}\n\n\t\tpriv->ports[i].utmi_rst = rst;\n\t\tpriv->ports[i].priv = priv;\n\n\t\tphy = devm_phy_create(dev, child, &hisi_inno_phy_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tof_node_put(child);\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\n\t\tphy_set_bus_width(phy, 8);\n\t\tphy_set_drvdata(phy, &priv->ports[i]);\n\t\ti++;\n\n\t\tif (i >= INNO_PHY_PORT_NUM) {\n\t\t\tdev_warn(dev, \"Support %d ports in maximum\\n\", i);\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id hisi_inno_phy_of_match[] = {\n\t{ .compatible = \"hisilicon,inno-usb2-phy\",\n\t  .data = (void *) PHY_TYPE_0 },\n\t{ .compatible = \"hisilicon,hi3798cv200-usb2-phy\",\n\t  .data = (void *) PHY_TYPE_0 },\n\t{ .compatible = \"hisilicon,hi3798mv100-usb2-phy\",\n\t  .data = (void *) PHY_TYPE_1 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, hisi_inno_phy_of_match);\n\nstatic struct platform_driver hisi_inno_phy_driver = {\n\t.probe\t= hisi_inno_phy_probe,\n\t.driver = {\n\t\t.name\t= \"hisi-inno-phy\",\n\t\t.of_match_table\t= hisi_inno_phy_of_match,\n\t}\n};\nmodule_platform_driver(hisi_inno_phy_driver);\n\nMODULE_DESCRIPTION(\"HiSilicon INNO USB2 PHY Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}