{
  "module_name": "phy-hi3670-pcie.c",
  "hash_id": "3f506eb74ea501830a9546174a0a1c7339ca74d2d7bad4aa3fc088078cca8a4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/hisilicon/phy-hi3670-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/gpio.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define AXI_CLK_FREQ\t\t\t\t207500000\n#define REF_CLK_FREQ\t\t\t\t100000000\n\n \n#define SOC_PCIECTRL_CTRL7_ADDR\t\t\t0x01c\n#define SOC_PCIECTRL_CTRL12_ADDR\t\t0x030\n#define SOC_PCIECTRL_CTRL20_ADDR\t\t0x050\n#define SOC_PCIECTRL_CTRL21_ADDR\t\t0x054\n\n#define PCIE_OUTPUT_PULL_BITS\t\t\tGENMASK(3, 0)\n#define SOC_PCIECTRL_CTRL20_2P_MEM_CTRL\t\t0x02605550\n#define SOC_PCIECTRL_CTRL21_DEFAULT\t\t0x20000070\n#define PCIE_PULL_UP_SYS_AUX_PWR_DET\t\tBIT(10)\n#define PCIE_OUTPUT_PULL_DOWN\t\t\tBIT(1)\n\n \n#define SOC_PCIEPHY_CTRL0_ADDR\t\t\t0x000\n#define SOC_PCIEPHY_CTRL1_ADDR\t\t\t0x004\n#define SOC_PCIEPHY_CTRL38_ADDR\t\t\t0x0098\n#define SOC_PCIEPHY_STATE0_ADDR\t\t\t0x400\n\n#define RAWLANEN_DIG_PCS_XF_TX_OVRD_IN_1\t0xc004\n#define SUP_DIG_LVL_OVRD_IN\t\t\t0x003c\n#define LANEN_DIG_ASIC_TX_OVRD_IN_1\t\t0x4008\n#define LANEN_DIG_ASIC_TX_OVRD_IN_2\t\t0x400c\n\n#define PCIEPHY_RESET_BIT\t\t\tBIT(17)\n#define PCIEPHY_PIPE_LINE0_RESET_BIT\t\tBIT(19)\n#define PCIE_TXDETECT_RX_FAIL\t\t\tBIT(2)\n#define PCIE_CLK_SOURCE\t\t\t\tBIT(8)\n#define PCIE_IS_CLOCK_STABLE\t\t\tBIT(19)\n#define PCIE_PULL_DOWN_PHY_TEST_POWERDOWN\tBIT(22)\n#define PCIE_DEASSERT_CONTROLLER_PERST\t\tBIT(2)\n\n#define EYEPARAM_NOCFG\t\t\t\t0xffffffff\n#define EYE_PARM0_MASK\t\t\t\tGENMASK(8, 6)\n#define EYE_PARM1_MASK\t\t\t\tGENMASK(11, 8)\n#define EYE_PARM2_MASK\t\t\t\tGENMASK(5, 0)\n#define EYE_PARM3_MASK\t\t\t\tGENMASK(12, 7)\n#define EYE_PARM4_MASK\t\t\t\tGENMASK(14, 9)\n#define EYE_PARM0_EN\t\t\t\tBIT(9)\n#define EYE_PARM1_EN\t\t\t\tBIT(12)\n#define EYE_PARM2_EN\t\t\t\tBIT(6)\n#define EYE_PARM3_EN\t\t\t\tBIT(13)\n#define EYE_PARM4_EN\t\t\t\tBIT(15)\n\n \n#define APB_PHY_START_ADDR\t\t\t0x40000\n#define SOC_PCIEPHY_MMC1PLL_CTRL1\t\t0xc04\n#define SOC_PCIEPHY_MMC1PLL_CTRL16\t\t0xC40\n#define SOC_PCIEPHY_MMC1PLL_CTRL17\t\t0xC44\n#define SOC_PCIEPHY_MMC1PLL_CTRL20\t\t0xC50\n#define SOC_PCIEPHY_MMC1PLL_CTRL21\t\t0xC54\n#define SOC_PCIEPHY_MMC1PLL_STAT0\t\t0xE00\n\n#define CRGPERIPH_PEREN12\t\t\t0x470\n#define CRGPERIPH_PERDIS12\t\t\t0x474\n#define CRGPERIPH_PCIECTRL0\t\t\t0x800\n\n#define PCIE_FNPLL_FBDIV_MASK\t\t\tGENMASK(27, 16)\n#define PCIE_FNPLL_FRACDIV_MASK\t\t\tGENMASK(23, 0)\n#define PCIE_FNPLL_POSTDIV1_MASK\t\tGENMASK(10, 8)\n#define PCIE_FNPLL_POSTDIV2_MASK\t\tGENMASK(14, 12)\n#define PCIE_FNPLL_PLL_MODE_MASK\t\tBIT(25)\n\n#define PCIE_FNPLL_DLL_EN\t\t\tBIT(27)\n#define PCIE_FNPLL_FBDIV\t\t\t0xd0\n#define PCIE_FNPLL_FRACDIV\t\t\t0x555555\n#define PCIE_FNPLL_POSTDIV1\t\t\t0x5\n#define PCIE_FNPLL_POSTDIV2\t\t\t0x4\n#define PCIE_FNPLL_PLL_MODE\t\t\t0x0\n\n#define PCIE_PHY_MMC1PLL\t\t\t0x20\n#define PCIE_PHY_CHOOSE_FNPLL\t\t\tBIT(27)\n#define PCIE_PHY_MMC1PLL_DISABLE\t\tBIT(0)\n#define PCIE_PHY_PCIEPL_BP\t\t\tBIT(16)\n\n \n#define IO_OE_HARD_GT_MODE\t\t\tBIT(1)\n#define IO_IE_EN_HARD_BYPASS\t\t\tBIT(27)\n#define IO_OE_EN_HARD_BYPASS\t\t\tBIT(11)\n#define IO_HARD_CTRL_DEBOUNCE_BYPASS\t\tBIT(10)\n#define IO_OE_GT_MODE\t\t\t\tBIT(8)\n#define DEBOUNCE_WAITCFG_IN\t\t\tGENMASK(23, 20)\n#define DEBOUNCE_WAITCFG_OUT\t\t\tGENMASK(16, 13)\n\n#define IO_HP_DEBOUNCE_GT\t\t\t(BIT(12) | BIT(15))\n#define IO_PHYREF_SOFT_GT_MODE\t\t\tBIT(14)\n#define IO_REF_SOFT_GT_MODE\t\t\tBIT(13)\n#define IO_REF_HARD_GT_MODE\t\t\tBIT(0)\n\n \n#define NOC_POWER_IDLEREQ_1\t\t\t0x38c\n#define NOC_POWER_IDLE_1\t\t\t0x394\n#define NOC_PW_MASK\t\t\t\t0x10000\n#define NOC_PW_SET_BIT\t\t\t\t0x1\n\n#define NUM_EYEPARAM\t\t\t\t5\n\n \n#define SCTRL_PCIE_CMOS_OFFSET\t\t\t0x60\n#define SCTRL_PCIE_CMOS_BIT\t\t\t0x10\n#define SCTRL_PCIE_ISO_OFFSET\t\t\t0x44\n#define SCTRL_PCIE_ISO_BIT\t\t\t0x30\n#define SCTRL_PCIE_HPCLK_OFFSET\t\t\t0x190\n#define SCTRL_PCIE_HPCLK_BIT\t\t\t0x184000\n#define SCTRL_PCIE_OE_OFFSET\t\t\t0x14a\n#define PCIE_DEBOUNCE_PARAM\t\t\t0xf0f400\n#define PCIE_OE_BYPASS\t\t\t\tGENMASK(29, 28)\n\n \n#define CRGCTRL_PCIE_ASSERT_OFFSET\t\t0x88\n#define CRGCTRL_PCIE_ASSERT_BIT\t\t\t0x8c000000\n\n#define FNPLL_HAS_LOCKED\t\t\tBIT(4)\n\n \n#define TIME_CMOS_MIN\t\t100\n#define TIME_CMOS_MAX\t\t105\n#define PIPE_CLK_STABLE_TIME\t100\n#define PLL_CTRL_WAIT_TIME\t200\n#define NOC_POWER_TIME\t\t100\n\nstruct hi3670_pcie_phy {\n\tstruct device\t*dev;\n\tvoid __iomem\t*base;\n\tstruct regmap\t*apb;\n\tstruct regmap\t*crgctrl;\n\tstruct regmap\t*sysctrl;\n\tstruct regmap\t*pmctrl;\n\tstruct clk\t*apb_sys_clk;\n\tstruct clk\t*apb_phy_clk;\n\tstruct clk\t*phy_ref_clk;\n\tstruct clk\t*aclk;\n\tstruct clk\t*aux_clk;\n\tu32\t\teye_param[NUM_EYEPARAM];\n};\n\n \nstatic inline void hi3670_apb_phy_writel(struct hi3670_pcie_phy *phy, u32 val,\n\t\t\t\t\t u32 reg)\n{\n\twritel(val, phy->base + APB_PHY_START_ADDR + reg);\n}\n\nstatic inline u32 hi3670_apb_phy_readl(struct hi3670_pcie_phy *phy, u32 reg)\n{\n\treturn readl(phy->base + APB_PHY_START_ADDR + reg);\n}\n\nstatic inline void hi3670_apb_phy_updatel(struct hi3670_pcie_phy *phy,\n\t\t\t\t\t  u32 val, u32 mask, u32 reg)\n{\n\tu32 regval;\n\n\tregval = hi3670_apb_phy_readl(phy, reg);\n\tregval &= ~mask;\n\tregval |= val;\n\thi3670_apb_phy_writel(phy, regval, reg);\n}\n\nstatic inline void kirin_apb_natural_phy_writel(struct hi3670_pcie_phy *phy,\n\t\t\t\t\t\tu32 val, u32 reg)\n{\n\twritel(val, phy->base + reg);\n}\n\nstatic inline u32 kirin_apb_natural_phy_readl(struct hi3670_pcie_phy *phy,\n\t\t\t\t\t      u32 reg)\n{\n\treturn readl(phy->base + reg);\n}\n\nstatic void hi3670_pcie_phy_oe_enable(struct hi3670_pcie_phy *phy, bool enable)\n{\n\tu32 val;\n\n\tregmap_read(phy->sysctrl, SCTRL_PCIE_OE_OFFSET, &val);\n\tval |= PCIE_DEBOUNCE_PARAM;\n\tif (enable)\n\t\tval &= ~PCIE_OE_BYPASS;\n\telse\n\t\tval |= PCIE_OE_BYPASS;\n\tregmap_write(phy->sysctrl, SCTRL_PCIE_OE_OFFSET, val);\n}\n\nstatic void hi3670_pcie_get_eyeparam(struct hi3670_pcie_phy *phy)\n{\n\tstruct device *dev = phy->dev;\n\tstruct device_node *np;\n\tint ret, i;\n\n\tnp = dev->of_node;\n\n\tret = of_property_read_u32_array(np, \"hisilicon,eye-diagram-param\",\n\t\t\t\t\t phy->eye_param, NUM_EYEPARAM);\n\tif (!ret)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < NUM_EYEPARAM; i++)\n\t\tphy->eye_param[i] = EYEPARAM_NOCFG;\n}\n\nstatic void hi3670_pcie_set_eyeparam(struct hi3670_pcie_phy *phy)\n{\n\tu32 val;\n\n\tval = kirin_apb_natural_phy_readl(phy, RAWLANEN_DIG_PCS_XF_TX_OVRD_IN_1);\n\n\tif (phy->eye_param[1] != EYEPARAM_NOCFG) {\n\t\tval &= ~EYE_PARM1_MASK;\n\t\tval |= FIELD_PREP(EYE_PARM1_MASK, phy->eye_param[1]);\n\t\tval |= EYE_PARM1_EN;\n\t}\n\tkirin_apb_natural_phy_writel(phy, val,\n\t\t\t\t     RAWLANEN_DIG_PCS_XF_TX_OVRD_IN_1);\n\n\tval = kirin_apb_natural_phy_readl(phy, LANEN_DIG_ASIC_TX_OVRD_IN_2);\n\tval &= ~(EYE_PARM2_MASK | EYE_PARM3_MASK);\n\tif (phy->eye_param[2] != EYEPARAM_NOCFG) {\n\t\tval |= FIELD_PREP(EYE_PARM2_MASK, phy->eye_param[2]);\n\t\tval |= EYE_PARM2_EN;\n\t}\n\n\tif (phy->eye_param[3] != EYEPARAM_NOCFG) {\n\t\tval |= FIELD_PREP(EYE_PARM3_MASK, phy->eye_param[3]);\n\t\tval |= EYE_PARM3_EN;\n\t}\n\n\tkirin_apb_natural_phy_writel(phy, val, LANEN_DIG_ASIC_TX_OVRD_IN_2);\n\n\tval = kirin_apb_natural_phy_readl(phy, SUP_DIG_LVL_OVRD_IN);\n\tif (phy->eye_param[0] != EYEPARAM_NOCFG) {\n\t\tval &= ~EYE_PARM0_MASK;\n\t\tval |= FIELD_PREP(EYE_PARM0_MASK, phy->eye_param[0]);\n\t\tval |= EYE_PARM0_EN;\n\t}\n\tkirin_apb_natural_phy_writel(phy, val, SUP_DIG_LVL_OVRD_IN);\n\n\tval = kirin_apb_natural_phy_readl(phy, LANEN_DIG_ASIC_TX_OVRD_IN_1);\n\tif (phy->eye_param[4] != EYEPARAM_NOCFG) {\n\t\tval &= ~EYE_PARM4_MASK;\n\t\tval |= FIELD_PREP(EYE_PARM4_MASK, phy->eye_param[4]);\n\t\tval |= EYE_PARM4_EN;\n\t}\n\tkirin_apb_natural_phy_writel(phy, val, LANEN_DIG_ASIC_TX_OVRD_IN_1);\n}\n\nstatic void hi3670_pcie_natural_cfg(struct hi3670_pcie_phy *phy)\n{\n\tu32 val;\n\n\t \n\tregmap_write(phy->apb, SOC_PCIECTRL_CTRL20_ADDR,\n\t\t     SOC_PCIECTRL_CTRL20_2P_MEM_CTRL);\n\n\tregmap_read(phy->apb, SOC_PCIECTRL_CTRL7_ADDR, &val);\n\tval |= PCIE_PULL_UP_SYS_AUX_PWR_DET;\n\tregmap_write(phy->apb, SOC_PCIECTRL_CTRL7_ADDR, val);\n\n\t \n\tregmap_read(phy->apb, SOC_PCIECTRL_CTRL12_ADDR, &val);\n\tval &= ~PCIE_OUTPUT_PULL_BITS;\n\tval |= PCIE_OUTPUT_PULL_DOWN;\n\tregmap_write(phy->apb, SOC_PCIECTRL_CTRL12_ADDR, val);\n\n\t \n\thi3670_apb_phy_updatel(phy, PCIEPHY_RESET_BIT,\n\t\t\t       PCIEPHY_PIPE_LINE0_RESET_BIT | PCIEPHY_RESET_BIT,\n\t\t\t       SOC_PCIEPHY_CTRL1_ADDR);\n\n\t \n\thi3670_apb_phy_updatel(phy, PCIE_TXDETECT_RX_FAIL, PCIE_TXDETECT_RX_FAIL,\n\t\t\t       SOC_PCIEPHY_CTRL38_ADDR);\n}\n\nstatic void hi3670_pcie_pll_init(struct hi3670_pcie_phy *phy)\n{\n\thi3670_apb_phy_updatel(phy, PCIE_PHY_CHOOSE_FNPLL, PCIE_PHY_CHOOSE_FNPLL,\n\t\t\t       SOC_PCIEPHY_MMC1PLL_CTRL1);\n\n\thi3670_apb_phy_updatel(phy,\n\t\t\t       FIELD_PREP(PCIE_FNPLL_FBDIV_MASK, PCIE_FNPLL_FBDIV),\n\t\t\t       PCIE_FNPLL_FBDIV_MASK,\n\t\t\t       SOC_PCIEPHY_MMC1PLL_CTRL16);\n\n\thi3670_apb_phy_updatel(phy,\n\t\t\t       FIELD_PREP(PCIE_FNPLL_FRACDIV_MASK, PCIE_FNPLL_FRACDIV),\n\t\t\t       PCIE_FNPLL_FRACDIV_MASK, SOC_PCIEPHY_MMC1PLL_CTRL17);\n\n\thi3670_apb_phy_updatel(phy,\n\t\t\t       PCIE_FNPLL_DLL_EN |\n\t\t\t       FIELD_PREP(PCIE_FNPLL_POSTDIV1_MASK, PCIE_FNPLL_POSTDIV1) |\n\t\t\t       FIELD_PREP(PCIE_FNPLL_POSTDIV2_MASK, PCIE_FNPLL_POSTDIV2) |\n\t\t\t       FIELD_PREP(PCIE_FNPLL_PLL_MODE_MASK, PCIE_FNPLL_PLL_MODE),\n\t\t\t       PCIE_FNPLL_POSTDIV1_MASK |\n\t\t\t       PCIE_FNPLL_POSTDIV2_MASK |\n\t\t\t       PCIE_FNPLL_PLL_MODE_MASK | PCIE_FNPLL_DLL_EN,\n\t\t\t       SOC_PCIEPHY_MMC1PLL_CTRL20);\n\n\thi3670_apb_phy_writel(phy, PCIE_PHY_MMC1PLL,\n\t\t\t      SOC_PCIEPHY_MMC1PLL_CTRL21);\n}\n\nstatic int hi3670_pcie_pll_ctrl(struct hi3670_pcie_phy *phy, bool enable)\n{\n\tstruct device *dev = phy->dev;\n\tu32 val;\n\tint time = PLL_CTRL_WAIT_TIME;\n\n\tif (enable) {\n\t\t \n\t\thi3670_apb_phy_updatel(phy, 0, PCIE_PHY_MMC1PLL_DISABLE,\n\t\t\t\t       SOC_PCIEPHY_MMC1PLL_CTRL16);\n\n\t\t \n\t\tval = hi3670_apb_phy_readl(phy, SOC_PCIEPHY_MMC1PLL_STAT0);\n\t\twhile (!(val & FNPLL_HAS_LOCKED)) {\n\t\t\tif (!time) {\n\t\t\t\tdev_err(dev, \"wait for pll_lock timeout\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttime--;\n\t\t\tudelay(1);\n\t\t\tval = hi3670_apb_phy_readl(phy, SOC_PCIEPHY_MMC1PLL_STAT0);\n\t\t}\n\n\t\thi3670_apb_phy_updatel(phy, 0, PCIE_PHY_PCIEPL_BP,\n\t\t\t\t       SOC_PCIEPHY_MMC1PLL_CTRL20);\n\n\t} else {\n\t\thi3670_apb_phy_updatel(phy,\n\t\t\t\t       PCIE_PHY_MMC1PLL_DISABLE,\n\t\t\t\t       PCIE_PHY_MMC1PLL_DISABLE,\n\t\t\t\t       SOC_PCIEPHY_MMC1PLL_CTRL16);\n\n\t\thi3670_apb_phy_updatel(phy, PCIE_PHY_PCIEPL_BP,\n\t\t\t\t       PCIE_PHY_PCIEPL_BP,\n\t\t\t\t       SOC_PCIEPHY_MMC1PLL_CTRL20);\n\t}\n\n\treturn 0;\n}\n\nstatic void hi3670_pcie_hp_debounce_gt(struct hi3670_pcie_phy *phy, bool open)\n{\n\tif (open)\n\t\t \n\t\tregmap_write(phy->crgctrl, CRGPERIPH_PEREN12,\n\t\t\t     IO_HP_DEBOUNCE_GT);\n\telse\n\t\t \n\t\tregmap_write(phy->crgctrl, CRGPERIPH_PERDIS12,\n\t\t\t     IO_HP_DEBOUNCE_GT);\n}\n\nstatic void hi3670_pcie_phyref_gt(struct hi3670_pcie_phy *phy, bool open)\n{\n\tunsigned int val;\n\n\tregmap_read(phy->crgctrl, CRGPERIPH_PCIECTRL0, &val);\n\n\tif (open)\n\t\tval &= ~IO_OE_HARD_GT_MODE;  \n\telse\n\t\tval |= IO_OE_HARD_GT_MODE;  \n\n\tregmap_write(phy->crgctrl, CRGPERIPH_PCIECTRL0, val);\n\n\t \n\tregmap_write(phy->crgctrl, CRGPERIPH_PERDIS12, IO_PHYREF_SOFT_GT_MODE);\n}\n\nstatic void hi3670_pcie_oe_ctrl(struct hi3670_pcie_phy *phy, bool en_flag)\n{\n\tunsigned int val;\n\n\tregmap_read(phy->crgctrl, CRGPERIPH_PCIECTRL0, &val);\n\n\t \n\tval |= IO_IE_EN_HARD_BYPASS;\n\n\t \n\tval &= ~IO_HARD_CTRL_DEBOUNCE_BYPASS;\n\n\t \n\tval |= (DEBOUNCE_WAITCFG_IN | DEBOUNCE_WAITCFG_OUT);\n\n\t \n\tval |= IO_OE_GT_MODE;\n\n\tif (en_flag)\n\t\tval &= ~IO_OE_EN_HARD_BYPASS;\n\telse\n\t\tval |= IO_OE_EN_HARD_BYPASS;\n\n\tregmap_write(phy->crgctrl, CRGPERIPH_PCIECTRL0, val);\n}\n\nstatic void hi3670_pcie_ioref_gt(struct hi3670_pcie_phy *phy, bool open)\n{\n\tunsigned int val;\n\n\tif (open) {\n\t\tregmap_write(phy->apb, SOC_PCIECTRL_CTRL21_ADDR,\n\t\t\t     SOC_PCIECTRL_CTRL21_DEFAULT);\n\n\t\thi3670_pcie_oe_ctrl(phy, true);\n\n\t\t \n\t\tregmap_read(phy->crgctrl, CRGPERIPH_PCIECTRL0, &val);\n\t\tval &= ~IO_REF_HARD_GT_MODE;\n\t\tregmap_write(phy->crgctrl, CRGPERIPH_PCIECTRL0, val);\n\n\t\t \n\t\tregmap_write(phy->crgctrl, CRGPERIPH_PERDIS12,\n\t\t\t     IO_REF_SOFT_GT_MODE);\n\n\t} else {\n\t\t \n\t\tregmap_read(phy->crgctrl, CRGPERIPH_PCIECTRL0, &val);\n\t\tval |= IO_REF_HARD_GT_MODE;\n\t\tregmap_write(phy->crgctrl, CRGPERIPH_PCIECTRL0, val);\n\n\t\t \n\t\tregmap_write(phy->crgctrl, CRGPERIPH_PERDIS12,\n\t\t\t     IO_REF_SOFT_GT_MODE);\n\n\t\thi3670_pcie_oe_ctrl(phy, false);\n\t}\n}\n\nstatic int hi3670_pcie_allclk_ctrl(struct hi3670_pcie_phy *phy, bool clk_on)\n{\n\tstruct device *dev = phy->dev;\n\tint ret = 0;\n\n\tif (!clk_on)\n\t\tgoto close_clocks;\n\n\t \n\thi3670_apb_phy_updatel(phy, 0, PCIE_CLK_SOURCE,\n\t\t\t       SOC_PCIEPHY_CTRL1_ADDR);\n\n\thi3670_pcie_pll_init(phy);\n\n\tret = hi3670_pcie_pll_ctrl(phy, true);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable pll\\n\");\n\t\treturn -EINVAL;\n\t}\n\thi3670_pcie_hp_debounce_gt(phy, true);\n\thi3670_pcie_phyref_gt(phy, true);\n\thi3670_pcie_ioref_gt(phy, true);\n\n\tret = clk_set_rate(phy->aclk, AXI_CLK_FREQ);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set rate\\n\");\n\t\tgoto close_clocks;\n\t}\n\n\treturn 0;\n\nclose_clocks:\n\thi3670_pcie_ioref_gt(phy, false);\n\thi3670_pcie_phyref_gt(phy, false);\n\thi3670_pcie_hp_debounce_gt(phy, false);\n\n\thi3670_pcie_pll_ctrl(phy, false);\n\n\treturn ret;\n}\n\nstatic bool is_pipe_clk_stable(struct hi3670_pcie_phy *phy)\n{\n\tstruct device *dev = phy->dev;\n\tu32 val;\n\tu32 time = PIPE_CLK_STABLE_TIME;\n\tu32 pipe_clk_stable = PCIE_IS_CLOCK_STABLE;\n\n\tval = hi3670_apb_phy_readl(phy, SOC_PCIEPHY_STATE0_ADDR);\n\twhile (val & pipe_clk_stable) {\n\t\tmdelay(1);\n\t\tif (!time) {\n\t\t\tdev_err(dev, \"PIPE clk is not stable\\n\");\n\t\t\treturn false;\n\t\t}\n\t\ttime--;\n\t\tval = hi3670_apb_phy_readl(phy, SOC_PCIEPHY_STATE0_ADDR);\n\t}\n\n\treturn true;\n}\n\nstatic int hi3670_pcie_noc_power(struct hi3670_pcie_phy *phy, bool enable)\n{\n\tstruct device *dev = phy->dev;\n\tu32 time = NOC_POWER_TIME;\n\tunsigned int val = NOC_PW_MASK;\n\tint rst;\n\n\tif (enable)\n\t\tval = NOC_PW_MASK | NOC_PW_SET_BIT;\n\telse\n\t\tval = NOC_PW_MASK;\n\trst = enable ? 1 : 0;\n\n\tregmap_write(phy->pmctrl, NOC_POWER_IDLEREQ_1, val);\n\n\ttime = NOC_POWER_TIME;\n\tregmap_read(phy->pmctrl, NOC_POWER_IDLE_1, &val);\n\twhile ((val & NOC_PW_SET_BIT) != rst) {\n\t\tudelay(10);\n\t\tif (!time) {\n\t\t\tdev_err(dev, \"Failed to reverse noc power-status\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttime--;\n\t\tregmap_read(phy->pmctrl, NOC_POWER_IDLE_1, &val);\n\t}\n\n\treturn 0;\n}\n\nstatic int hi3670_pcie_get_resources_from_pcie(struct hi3670_pcie_phy *phy)\n{\n\tstruct device_node *pcie_port;\n\tstruct device *dev = phy->dev;\n\tstruct device *pcie_dev;\n\n\tpcie_port = of_get_child_by_name(dev->parent->of_node, \"pcie\");\n\tif (!pcie_port) {\n\t\tdev_err(dev, \"no pcie node found in %s\\n\",\n\t\t\tdev->parent->of_node->full_name);\n\t\treturn -ENODEV;\n\t}\n\n\tpcie_dev = bus_find_device_by_of_node(&platform_bus_type, pcie_port);\n\tif (!pcie_dev) {\n\t\tdev_err(dev, \"Didn't find pcie device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tphy->apb = dev_get_regmap(pcie_dev, \"kirin_pcie_apb\");\n\tif (!phy->apb) {\n\t\tdev_err(dev, \"Failed to get APB regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int kirin_pcie_clk_ctrl(struct hi3670_pcie_phy *phy, bool enable)\n{\n\tint ret = 0;\n\n\tif (!enable)\n\t\tgoto close_clk;\n\n\tret = clk_set_rate(phy->phy_ref_clk, REF_CLK_FREQ);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(phy->phy_ref_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(phy->apb_sys_clk);\n\tif (ret)\n\t\tgoto apb_sys_fail;\n\n\tret = clk_prepare_enable(phy->apb_phy_clk);\n\tif (ret)\n\t\tgoto apb_phy_fail;\n\n\tret = clk_prepare_enable(phy->aclk);\n\tif (ret)\n\t\tgoto aclk_fail;\n\n\tret = clk_prepare_enable(phy->aux_clk);\n\tif (ret)\n\t\tgoto aux_clk_fail;\n\n\treturn 0;\n\nclose_clk:\n\tclk_disable_unprepare(phy->aux_clk);\naux_clk_fail:\n\tclk_disable_unprepare(phy->aclk);\naclk_fail:\n\tclk_disable_unprepare(phy->apb_phy_clk);\napb_phy_fail:\n\tclk_disable_unprepare(phy->apb_sys_clk);\napb_sys_fail:\n\tclk_disable_unprepare(phy->phy_ref_clk);\n\n\treturn ret;\n}\n\nstatic int hi3670_pcie_phy_init(struct phy *generic_phy)\n{\n\tstruct hi3670_pcie_phy *phy = phy_get_drvdata(generic_phy);\n\tint ret;\n\n\t \n\n\tret = hi3670_pcie_get_resources_from_pcie(phy);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int hi3670_pcie_phy_power_on(struct phy *generic_phy)\n{\n\tstruct hi3670_pcie_phy *phy = phy_get_drvdata(generic_phy);\n\tint val, ret;\n\n\t \n\tregmap_write(phy->sysctrl, SCTRL_PCIE_CMOS_OFFSET, SCTRL_PCIE_CMOS_BIT);\n\tusleep_range(TIME_CMOS_MIN, TIME_CMOS_MAX);\n\n\thi3670_pcie_phy_oe_enable(phy, true);\n\n\tret = kirin_pcie_clk_ctrl(phy, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_write(phy->sysctrl, SCTRL_PCIE_ISO_OFFSET, SCTRL_PCIE_ISO_BIT);\n\tregmap_write(phy->crgctrl, CRGCTRL_PCIE_ASSERT_OFFSET,\n\t\t     CRGCTRL_PCIE_ASSERT_BIT);\n\tregmap_write(phy->sysctrl, SCTRL_PCIE_HPCLK_OFFSET,\n\t\t     SCTRL_PCIE_HPCLK_BIT);\n\n\thi3670_pcie_natural_cfg(phy);\n\n\tret = hi3670_pcie_allclk_ctrl(phy, true);\n\tif (ret)\n\t\tgoto disable_clks;\n\n\t \n\thi3670_apb_phy_updatel(phy, 0, PCIE_PULL_DOWN_PHY_TEST_POWERDOWN,\n\t\t\t       SOC_PCIEPHY_CTRL0_ADDR);\n\n\t \n\tregmap_read(phy->apb, SOC_PCIECTRL_CTRL12_ADDR, &val);\n\tval |= PCIE_DEASSERT_CONTROLLER_PERST;\n\tregmap_write(phy->apb, SOC_PCIECTRL_CTRL12_ADDR, val);\n\tudelay(10);\n\n\tret = is_pipe_clk_stable(phy);\n\tif (!ret)\n\t\tgoto disable_clks;\n\n\thi3670_pcie_set_eyeparam(phy);\n\n\tret = hi3670_pcie_noc_power(phy, false);\n\tif (ret)\n\t\tgoto disable_clks;\n\n\treturn 0;\n\ndisable_clks:\n\tkirin_pcie_clk_ctrl(phy, false);\n\treturn ret;\n}\n\nstatic int hi3670_pcie_phy_power_off(struct phy *generic_phy)\n{\n\tstruct hi3670_pcie_phy *phy = phy_get_drvdata(generic_phy);\n\n\thi3670_pcie_phy_oe_enable(phy, false);\n\n\thi3670_pcie_allclk_ctrl(phy, false);\n\n\t \n\tregmap_write(phy->sysctrl, SCTRL_PCIE_CMOS_OFFSET, 0);\n\n\t \n\n\treturn 0;\n}\n\nstatic const struct phy_ops hi3670_phy_ops = {\n\t.init\t\t= hi3670_pcie_phy_init,\n\t.power_on\t= hi3670_pcie_phy_power_on,\n\t.power_off\t= hi3670_pcie_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int hi3670_pcie_phy_get_resources(struct hi3670_pcie_phy *phy,\n\t\t\t\t\t struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\t \n\tphy->crgctrl = syscon_regmap_lookup_by_compatible(\"hisilicon,hi3670-crgctrl\");\n\tif (IS_ERR(phy->crgctrl))\n\t\treturn PTR_ERR(phy->crgctrl);\n\n\tphy->sysctrl = syscon_regmap_lookup_by_compatible(\"hisilicon,hi3670-sctrl\");\n\tif (IS_ERR(phy->sysctrl))\n\t\treturn PTR_ERR(phy->sysctrl);\n\n\tphy->pmctrl = syscon_regmap_lookup_by_compatible(\"hisilicon,hi3670-pmctrl\");\n\tif (IS_ERR(phy->pmctrl))\n\t\treturn PTR_ERR(phy->pmctrl);\n\n\t \n\tphy->phy_ref_clk = devm_clk_get(dev, \"phy_ref\");\n\tif (IS_ERR(phy->phy_ref_clk))\n\t\treturn PTR_ERR(phy->phy_ref_clk);\n\n\tphy->aux_clk = devm_clk_get(dev, \"aux\");\n\tif (IS_ERR(phy->aux_clk))\n\t\treturn PTR_ERR(phy->aux_clk);\n\n\tphy->apb_phy_clk = devm_clk_get(dev, \"apb_phy\");\n\tif (IS_ERR(phy->apb_phy_clk))\n\t\treturn PTR_ERR(phy->apb_phy_clk);\n\n\tphy->apb_sys_clk = devm_clk_get(dev, \"apb_sys\");\n\tif (IS_ERR(phy->apb_sys_clk))\n\t\treturn PTR_ERR(phy->apb_sys_clk);\n\n\tphy->aclk = devm_clk_get(dev, \"aclk\");\n\tif (IS_ERR(phy->aclk))\n\t\treturn PTR_ERR(phy->aclk);\n\n\t \n\tphy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->base))\n\t\treturn PTR_ERR(phy->base);\n\n\thi3670_pcie_get_eyeparam(phy);\n\n\treturn 0;\n}\n\nstatic int hi3670_pcie_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct hi3670_pcie_phy *phy;\n\tstruct phy *generic_phy;\n\tint ret;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->dev = dev;\n\n\tret = hi3670_pcie_phy_get_resources(phy, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tgeneric_phy = devm_phy_create(dev, dev->of_node, &hi3670_phy_ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(generic_phy);\n\t}\n\n\tphy_set_drvdata(generic_phy, phy);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id hi3670_pcie_phy_match[] = {\n\t{\n\t\t.compatible = \"hisilicon,hi970-pcie-phy\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver hi3670_pcie_phy_driver = {\n\t.probe\t= hi3670_pcie_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= hi3670_pcie_phy_match,\n\t\t.name\t\t= \"hi3670_pcie_phy\",\n\t\t.suppress_bind_attrs = true,\n\t}\n};\nbuiltin_platform_driver(hi3670_pcie_phy_driver);\n\nMODULE_DEVICE_TABLE(of, hi3670_pcie_phy_match);\nMODULE_DESCRIPTION(\"PCIe phy driver for Kirin 970\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab <mchehab@kernel.org>\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <mani@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}