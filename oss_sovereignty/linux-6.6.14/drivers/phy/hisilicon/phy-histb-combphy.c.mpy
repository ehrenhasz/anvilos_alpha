{
  "module_name": "phy-histb-combphy.c",
  "hash_id": "34159b3ad8516211186c3416c961b16265043cbc59bd15e15d2ebe1c87a215fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/hisilicon/phy-histb-combphy.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <dt-bindings/phy/phy.h>\n\n#define COMBPHY_MODE_PCIE\t\t0\n#define COMBPHY_MODE_USB3\t\t1\n#define COMBPHY_MODE_SATA\t\t2\n\n#define COMBPHY_CFG_REG\t\t\t0x0\n#define COMBPHY_BYPASS_CODEC\t\tBIT(31)\n#define COMBPHY_TEST_WRITE\t\tBIT(24)\n#define COMBPHY_TEST_DATA_SHIFT\t\t20\n#define COMBPHY_TEST_DATA_MASK\t\tGENMASK(23, 20)\n#define COMBPHY_TEST_ADDR_SHIFT\t\t12\n#define COMBPHY_TEST_ADDR_MASK\t\tGENMASK(16, 12)\n#define COMBPHY_CLKREF_OUT_OEN\t\tBIT(0)\n\nstruct histb_combphy_mode {\n\tint fixed;\n\tint select;\n\tu32 reg;\n\tu32 shift;\n\tu32 mask;\n};\n\nstruct histb_combphy_priv {\n\tvoid __iomem *mmio;\n\tstruct regmap *syscon;\n\tstruct reset_control *por_rst;\n\tstruct clk *ref_clk;\n\tstruct phy *phy;\n\tstruct histb_combphy_mode mode;\n};\n\nstatic void nano_register_write(struct histb_combphy_priv *priv,\n\t\t\t\tu32 addr, u32 data)\n{\n\tvoid __iomem *reg = priv->mmio + COMBPHY_CFG_REG;\n\tu32 val;\n\n\t \n\tval = readl(reg);\n\tval &= ~COMBPHY_TEST_ADDR_MASK;\n\tval |= addr << COMBPHY_TEST_ADDR_SHIFT;\n\tval &= ~COMBPHY_TEST_DATA_MASK;\n\tval |= data << COMBPHY_TEST_DATA_SHIFT;\n\twritel(val, reg);\n\n\t \n\tval &= ~COMBPHY_TEST_WRITE;\n\twritel(val, reg);\n\tval |= COMBPHY_TEST_WRITE;\n\twritel(val, reg);\n}\n\nstatic int is_mode_fixed(struct histb_combphy_mode *mode)\n{\n\treturn (mode->fixed != PHY_NONE) ? true : false;\n}\n\nstatic int histb_combphy_set_mode(struct histb_combphy_priv *priv)\n{\n\tstruct histb_combphy_mode *mode = &priv->mode;\n\tstruct regmap *syscon = priv->syscon;\n\tu32 hw_sel;\n\n\tif (is_mode_fixed(mode))\n\t\treturn 0;\n\n\tswitch (mode->select) {\n\tcase PHY_TYPE_SATA:\n\t\thw_sel = COMBPHY_MODE_SATA;\n\t\tbreak;\n\tcase PHY_TYPE_PCIE:\n\t\thw_sel = COMBPHY_MODE_PCIE;\n\t\tbreak;\n\tcase PHY_TYPE_USB3:\n\t\thw_sel = COMBPHY_MODE_USB3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(syscon, mode->reg, mode->mask,\n\t\t\t\t  hw_sel << mode->shift);\n}\n\nstatic int histb_combphy_init(struct phy *phy)\n{\n\tstruct histb_combphy_priv *priv = phy_get_drvdata(phy);\n\tu32 val;\n\tint ret;\n\n\tret = histb_combphy_set_mode(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = readl(priv->mmio + COMBPHY_CFG_REG);\n\tval &= ~COMBPHY_BYPASS_CODEC;\n\twritel(val, priv->mmio + COMBPHY_CFG_REG);\n\n\tret = clk_prepare_enable(priv->ref_clk);\n\tif (ret)\n\t\treturn ret;\n\n\treset_control_deassert(priv->por_rst);\n\n\t \n\tval = readl(priv->mmio + COMBPHY_CFG_REG);\n\tval |= COMBPHY_CLKREF_OUT_OEN;\n\twritel(val, priv->mmio + COMBPHY_CFG_REG);\n\n\t \n\tmdelay(5);\n\n\t \n\tnano_register_write(priv, 0x1, 0x8);\n\tnano_register_write(priv, 0xc, 0x9);\n\tnano_register_write(priv, 0x1a, 0x4);\n\n\treturn 0;\n}\n\nstatic int histb_combphy_exit(struct phy *phy)\n{\n\tstruct histb_combphy_priv *priv = phy_get_drvdata(phy);\n\tu32 val;\n\n\t \n\tval = readl(priv->mmio + COMBPHY_CFG_REG);\n\tval &= ~COMBPHY_CLKREF_OUT_OEN;\n\twritel(val, priv->mmio + COMBPHY_CFG_REG);\n\n\treset_control_assert(priv->por_rst);\n\tclk_disable_unprepare(priv->ref_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops histb_combphy_ops = {\n\t.init = histb_combphy_init,\n\t.exit = histb_combphy_exit,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct phy *histb_combphy_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct histb_combphy_priv *priv = dev_get_drvdata(dev);\n\tstruct histb_combphy_mode *mode = &priv->mode;\n\n\tif (args->args_count < 1) {\n\t\tdev_err(dev, \"invalid number of arguments\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmode->select = args->args[0];\n\n\tif (mode->select < PHY_TYPE_SATA || mode->select > PHY_TYPE_USB3) {\n\t\tdev_err(dev, \"invalid phy mode select argument\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (is_mode_fixed(mode) && mode->select != mode->fixed) {\n\t\tdev_err(dev, \"mode select %d mismatch fixed phy mode %d\\n\",\n\t\t\tmode->select, mode->fixed);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn priv->phy;\n}\n\nstatic int histb_combphy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct histb_combphy_priv *priv;\n\tstruct device_node *np = dev->of_node;\n\tstruct histb_combphy_mode *mode;\n\tu32 vals[3];\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->mmio)) {\n\t\tret = PTR_ERR(priv->mmio);\n\t\treturn ret;\n\t}\n\n\tpriv->syscon = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(priv->syscon)) {\n\t\tdev_err(dev, \"failed to find peri_ctrl syscon regmap\\n\");\n\t\treturn PTR_ERR(priv->syscon);\n\t}\n\n\tmode = &priv->mode;\n\tmode->fixed = PHY_NONE;\n\n\tret = of_property_read_u32(np, \"hisilicon,fixed-mode\", &mode->fixed);\n\tif (ret == 0)\n\t\tdev_dbg(dev, \"found fixed phy mode %d\\n\", mode->fixed);\n\n\tret = of_property_read_u32_array(np, \"hisilicon,mode-select-bits\",\n\t\t\t\t\t vals, ARRAY_SIZE(vals));\n\tif (ret == 0) {\n\t\tif (is_mode_fixed(mode)) {\n\t\t\tdev_err(dev, \"found select bits for fixed mode phy\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmode->reg = vals[0];\n\t\tmode->shift = vals[1];\n\t\tmode->mask = vals[2];\n\t\tdev_dbg(dev, \"found mode select bits\\n\");\n\t} else {\n\t\tif (!is_mode_fixed(mode)) {\n\t\t\tdev_err(dev, \"no valid select bits found for non-fixed phy\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tpriv->ref_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->ref_clk)) {\n\t\tdev_err(dev, \"failed to find ref clock\\n\");\n\t\treturn PTR_ERR(priv->ref_clk);\n\t}\n\n\tpriv->por_rst = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(priv->por_rst)) {\n\t\tdev_err(dev, \"failed to get poweron reset\\n\");\n\t\treturn PTR_ERR(priv->por_rst);\n\t}\n\n\tpriv->phy = devm_phy_create(dev, NULL, &histb_combphy_ops);\n\tif (IS_ERR(priv->phy)) {\n\t\tdev_err(dev, \"failed to create combphy\\n\");\n\t\treturn PTR_ERR(priv->phy);\n\t}\n\n\tdev_set_drvdata(dev, priv);\n\tphy_set_drvdata(priv->phy, priv);\n\n\tphy_provider = devm_of_phy_provider_register(dev, histb_combphy_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id histb_combphy_of_match[] = {\n\t{ .compatible = \"hisilicon,hi3798cv200-combphy\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, histb_combphy_of_match);\n\nstatic struct platform_driver histb_combphy_driver = {\n\t.probe\t= histb_combphy_probe,\n\t.driver = {\n\t\t.name = \"combphy\",\n\t\t.of_match_table = histb_combphy_of_match,\n\t},\n};\nmodule_platform_driver(histb_combphy_driver);\n\nMODULE_DESCRIPTION(\"HiSilicon STB COMBPHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}