{
  "module_name": "phy-uniphier-usb3ss.c",
  "hash_id": "ca7f7b50094f01058327af81088e385117bc62d825fb7ffd51fd954fe65b07d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/socionext/phy-uniphier-usb3ss.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#define SSPHY_TESTI\t\t0x0\n#define TESTI_DAT_MASK\t\tGENMASK(13, 6)\n#define TESTI_ADR_MASK\t\tGENMASK(5, 1)\n#define TESTI_WR_EN\t\tBIT(0)\n\n#define SSPHY_TESTO\t\t0x4\n#define TESTO_DAT_MASK\t\tGENMASK(7, 0)\n\n#define PHY_F(regno, msb, lsb) { (regno), (msb), (lsb) }\n\n#define CDR_CPD_TRIM\tPHY_F(7, 3, 0)\t \n#define CDR_CPF_TRIM\tPHY_F(8, 3, 0)\t \n#define TX_PLL_TRIM\tPHY_F(9, 3, 0)\t \n#define BGAP_TRIM\tPHY_F(11, 3, 0)\t \n#define CDR_TRIM\tPHY_F(13, 6, 5)\t \n#define VCO_CTRL\tPHY_F(26, 7, 4)\t \n#define VCOPLL_CTRL\tPHY_F(27, 2, 0)\t \n#define VCOPLL_CM\tPHY_F(28, 1, 0)\t \n\n#define MAX_PHY_PARAMS\t7\n\nstruct uniphier_u3ssphy_param {\n\tstruct {\n\t\tint reg_no;\n\t\tint msb;\n\t\tint lsb;\n\t} field;\n\tu8 value;\n};\n\nstruct uniphier_u3ssphy_priv {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *clk, *clk_ext, *clk_parent, *clk_parent_gio;\n\tstruct reset_control *rst, *rst_parent, *rst_parent_gio;\n\tstruct regulator *vbus;\n\tconst struct uniphier_u3ssphy_soc_data *data;\n};\n\nstruct uniphier_u3ssphy_soc_data {\n\tbool is_legacy;\n\tint nparams;\n\tconst struct uniphier_u3ssphy_param param[MAX_PHY_PARAMS];\n};\n\nstatic void uniphier_u3ssphy_testio_write(struct uniphier_u3ssphy_priv *priv,\n\t\t\t\t\t  u32 data)\n{\n\t \n\twritel(data, priv->base + SSPHY_TESTI);\n\treadl(priv->base + SSPHY_TESTO);\n\treadl(priv->base + SSPHY_TESTO);\n}\n\nstatic void uniphier_u3ssphy_set_param(struct uniphier_u3ssphy_priv *priv,\n\t\t\t\t       const struct uniphier_u3ssphy_param *p)\n{\n\tu32 val;\n\tu8 field_mask = GENMASK(p->field.msb, p->field.lsb);\n\tu8 data;\n\n\t \n\tval  = FIELD_PREP(TESTI_DAT_MASK, 1);\n\tval |= FIELD_PREP(TESTI_ADR_MASK, p->field.reg_no);\n\tuniphier_u3ssphy_testio_write(priv, val);\n\tval = readl(priv->base + SSPHY_TESTO) & TESTO_DAT_MASK;\n\n\t \n\tval &= ~field_mask;\n\tdata = field_mask & (p->value << p->field.lsb);\n\tval  = FIELD_PREP(TESTI_DAT_MASK, data | val);\n\tval |= FIELD_PREP(TESTI_ADR_MASK, p->field.reg_no);\n\tuniphier_u3ssphy_testio_write(priv, val);\n\tuniphier_u3ssphy_testio_write(priv, val | TESTI_WR_EN);\n\tuniphier_u3ssphy_testio_write(priv, val);\n\n\t \n\tval  = FIELD_PREP(TESTI_DAT_MASK, 1);\n\tval |= FIELD_PREP(TESTI_ADR_MASK, p->field.reg_no);\n\tuniphier_u3ssphy_testio_write(priv, val);\n\treadl(priv->base + SSPHY_TESTO);\n}\n\nstatic int uniphier_u3ssphy_power_on(struct phy *phy)\n{\n\tstruct uniphier_u3ssphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk_ext);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\tgoto out_clk_ext_disable;\n\n\tret = reset_control_deassert(priv->rst);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tif (priv->vbus) {\n\t\tret = regulator_enable(priv->vbus);\n\t\tif (ret)\n\t\t\tgoto out_rst_assert;\n\t}\n\n\treturn 0;\n\nout_rst_assert:\n\treset_control_assert(priv->rst);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk);\nout_clk_ext_disable:\n\tclk_disable_unprepare(priv->clk_ext);\n\n\treturn ret;\n}\n\nstatic int uniphier_u3ssphy_power_off(struct phy *phy)\n{\n\tstruct uniphier_u3ssphy_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->vbus)\n\t\tregulator_disable(priv->vbus);\n\n\treset_control_assert(priv->rst);\n\tclk_disable_unprepare(priv->clk);\n\tclk_disable_unprepare(priv->clk_ext);\n\n\treturn 0;\n}\n\nstatic int uniphier_u3ssphy_init(struct phy *phy)\n{\n\tstruct uniphier_u3ssphy_priv *priv = phy_get_drvdata(phy);\n\tint i, ret;\n\n\tret = clk_prepare_enable(priv->clk_parent);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clk_parent_gio);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tret = reset_control_deassert(priv->rst_parent);\n\tif (ret)\n\t\tgoto out_clk_gio_disable;\n\n\tret = reset_control_deassert(priv->rst_parent_gio);\n\tif (ret)\n\t\tgoto out_rst_assert;\n\n\tif (priv->data->is_legacy)\n\t\treturn 0;\n\n\tfor (i = 0; i < priv->data->nparams; i++)\n\t\tuniphier_u3ssphy_set_param(priv, &priv->data->param[i]);\n\n\treturn 0;\n\nout_rst_assert:\n\treset_control_assert(priv->rst_parent);\nout_clk_gio_disable:\n\tclk_disable_unprepare(priv->clk_parent_gio);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk_parent);\n\n\treturn ret;\n}\n\nstatic int uniphier_u3ssphy_exit(struct phy *phy)\n{\n\tstruct uniphier_u3ssphy_priv *priv = phy_get_drvdata(phy);\n\n\treset_control_assert(priv->rst_parent_gio);\n\treset_control_assert(priv->rst_parent);\n\tclk_disable_unprepare(priv->clk_parent_gio);\n\tclk_disable_unprepare(priv->clk_parent);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops uniphier_u3ssphy_ops = {\n\t.init           = uniphier_u3ssphy_init,\n\t.exit           = uniphier_u3ssphy_exit,\n\t.power_on       = uniphier_u3ssphy_power_on,\n\t.power_off      = uniphier_u3ssphy_power_off,\n\t.owner          = THIS_MODULE,\n};\n\nstatic int uniphier_u3ssphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_u3ssphy_priv *priv;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *phy;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->data = of_device_get_match_data(dev);\n\tif (WARN_ON(!priv->data ||\n\t\t    priv->data->nparams > MAX_PHY_PARAMS))\n\t\treturn -EINVAL;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tif (!priv->data->is_legacy) {\n\t\tpriv->clk = devm_clk_get(dev, \"phy\");\n\t\tif (IS_ERR(priv->clk))\n\t\t\treturn PTR_ERR(priv->clk);\n\n\t\tpriv->clk_ext = devm_clk_get_optional(dev, \"phy-ext\");\n\t\tif (IS_ERR(priv->clk_ext))\n\t\t\treturn PTR_ERR(priv->clk_ext);\n\n\t\tpriv->rst = devm_reset_control_get_shared(dev, \"phy\");\n\t\tif (IS_ERR(priv->rst))\n\t\t\treturn PTR_ERR(priv->rst);\n\t} else {\n\t\tpriv->clk_parent_gio = devm_clk_get(dev, \"gio\");\n\t\tif (IS_ERR(priv->clk_parent_gio))\n\t\t\treturn PTR_ERR(priv->clk_parent_gio);\n\n\t\tpriv->rst_parent_gio =\n\t\t\tdevm_reset_control_get_shared(dev, \"gio\");\n\t\tif (IS_ERR(priv->rst_parent_gio))\n\t\t\treturn PTR_ERR(priv->rst_parent_gio);\n\t}\n\n\tpriv->clk_parent = devm_clk_get(dev, \"link\");\n\tif (IS_ERR(priv->clk_parent))\n\t\treturn PTR_ERR(priv->clk_parent);\n\n\tpriv->rst_parent = devm_reset_control_get_shared(dev, \"link\");\n\tif (IS_ERR(priv->rst_parent))\n\t\treturn PTR_ERR(priv->rst_parent);\n\n\tpriv->vbus = devm_regulator_get_optional(dev, \"vbus\");\n\tif (IS_ERR(priv->vbus)) {\n\t\tif (PTR_ERR(priv->vbus) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(priv->vbus);\n\t\tpriv->vbus = NULL;\n\t}\n\n\tphy = devm_phy_create(dev, dev->of_node, &uniphier_u3ssphy_ops);\n\tif (IS_ERR(phy))\n\t\treturn PTR_ERR(phy);\n\n\tphy_set_drvdata(phy, priv);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct uniphier_u3ssphy_soc_data uniphier_pro4_data = {\n\t.is_legacy = true,\n};\n\nstatic const struct uniphier_u3ssphy_soc_data uniphier_pxs2_data = {\n\t.is_legacy = false,\n\t.nparams = 7,\n\t.param = {\n\t\t{ CDR_CPD_TRIM, 10 },\n\t\t{ CDR_CPF_TRIM, 3 },\n\t\t{ TX_PLL_TRIM, 5 },\n\t\t{ BGAP_TRIM, 9 },\n\t\t{ CDR_TRIM, 2 },\n\t\t{ VCOPLL_CTRL, 7 },\n\t\t{ VCOPLL_CM, 1 },\n\t},\n};\n\nstatic const struct uniphier_u3ssphy_soc_data uniphier_ld20_data = {\n\t.is_legacy = false,\n\t.nparams = 3,\n\t.param = {\n\t\t{ CDR_CPD_TRIM, 6 },\n\t\t{ CDR_TRIM, 2 },\n\t\t{ VCO_CTRL, 5 },\n\t},\n};\n\nstatic const struct of_device_id uniphier_u3ssphy_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-pro4-usb3-ssphy\",\n\t\t.data = &uniphier_pro4_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pro5-usb3-ssphy\",\n\t\t.data = &uniphier_pro4_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs2-usb3-ssphy\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-ld20-usb3-ssphy\",\n\t\t.data = &uniphier_ld20_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-usb3-ssphy\",\n\t\t.data = &uniphier_ld20_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-nx1-usb3-ssphy\",\n\t\t.data = &uniphier_ld20_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_u3ssphy_match);\n\nstatic struct platform_driver uniphier_u3ssphy_driver = {\n\t.probe = uniphier_u3ssphy_probe,\n\t.driver\t= {\n\t\t.name = \"uniphier-usb3-ssphy\",\n\t\t.of_match_table\t= uniphier_u3ssphy_match,\n\t},\n};\n\nmodule_platform_driver(uniphier_u3ssphy_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier SS-PHY driver for USB3 controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}