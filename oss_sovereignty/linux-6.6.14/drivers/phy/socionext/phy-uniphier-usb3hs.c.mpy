{
  "module_name": "phy-uniphier-usb3hs.c",
  "hash_id": "3324dfdb8209d5073524cac0c0a0a58baae4387263f045600b2358f4b59a9817",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/socionext/phy-uniphier-usb3hs.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#define HSPHY_CFG0\t\t0x0\n#define HSPHY_CFG0_HS_I_MASK\tGENMASK(31, 28)\n#define HSPHY_CFG0_HSDISC_MASK\tGENMASK(27, 26)\n#define HSPHY_CFG0_SWING_MASK\tGENMASK(17, 16)\n#define HSPHY_CFG0_SEL_T_MASK\tGENMASK(15, 12)\n#define HSPHY_CFG0_RTERM_MASK\tGENMASK(7, 6)\n#define HSPHY_CFG0_TRIMMASK\t(HSPHY_CFG0_HS_I_MASK \\\n\t\t\t\t | HSPHY_CFG0_SEL_T_MASK \\\n\t\t\t\t | HSPHY_CFG0_RTERM_MASK)\n\n#define HSPHY_CFG1\t\t0x4\n#define HSPHY_CFG1_DAT_EN\tBIT(29)\n#define HSPHY_CFG1_ADR_EN\tBIT(28)\n#define HSPHY_CFG1_ADR_MASK\tGENMASK(27, 16)\n#define HSPHY_CFG1_DAT_MASK\tGENMASK(23, 16)\n\n#define PHY_F(regno, msb, lsb) { (regno), (msb), (lsb) }\n\n#define RX_CHK_SYNC\tPHY_F(0, 5, 5)\t \n#define RX_SYNC_SEL\tPHY_F(1, 1, 0)\t \n#define LS_SLEW\t\tPHY_F(10, 6, 6)\t \n#define FS_LS_DRV\tPHY_F(10, 5, 5)\t \n\n#define MAX_PHY_PARAMS\t4\n\nstruct uniphier_u3hsphy_param {\n\tstruct {\n\t\tint reg_no;\n\t\tint msb;\n\t\tint lsb;\n\t} field;\n\tu8 value;\n};\n\nstruct uniphier_u3hsphy_trim_param {\n\tunsigned int rterm;\n\tunsigned int sel_t;\n\tunsigned int hs_i;\n};\n\n#define trim_param_is_valid(p)\t((p)->rterm || (p)->sel_t || (p)->hs_i)\n\nstruct uniphier_u3hsphy_priv {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *clk, *clk_parent, *clk_ext, *clk_parent_gio;\n\tstruct reset_control *rst, *rst_parent, *rst_parent_gio;\n\tstruct regulator *vbus;\n\tconst struct uniphier_u3hsphy_soc_data *data;\n};\n\nstruct uniphier_u3hsphy_soc_data {\n\tbool is_legacy;\n\tint nparams;\n\tconst struct uniphier_u3hsphy_param param[MAX_PHY_PARAMS];\n\tu32 config0;\n\tu32 config1;\n\tvoid (*trim_func)(struct uniphier_u3hsphy_priv *priv, u32 *pconfig,\n\t\t\t  struct uniphier_u3hsphy_trim_param *pt);\n};\n\nstatic void uniphier_u3hsphy_trim_ld20(struct uniphier_u3hsphy_priv *priv,\n\t\t\t\t       u32 *pconfig,\n\t\t\t\t       struct uniphier_u3hsphy_trim_param *pt)\n{\n\t*pconfig &= ~HSPHY_CFG0_RTERM_MASK;\n\t*pconfig |= FIELD_PREP(HSPHY_CFG0_RTERM_MASK, pt->rterm);\n\n\t*pconfig &= ~HSPHY_CFG0_SEL_T_MASK;\n\t*pconfig |= FIELD_PREP(HSPHY_CFG0_SEL_T_MASK, pt->sel_t);\n\n\t*pconfig &= ~HSPHY_CFG0_HS_I_MASK;\n\t*pconfig |= FIELD_PREP(HSPHY_CFG0_HS_I_MASK,  pt->hs_i);\n}\n\nstatic int uniphier_u3hsphy_get_nvparam(struct uniphier_u3hsphy_priv *priv,\n\t\t\t\t\tconst char *name, unsigned int *val)\n{\n\tstruct nvmem_cell *cell;\n\tu8 *buf;\n\n\tcell = devm_nvmem_cell_get(priv->dev, name);\n\tif (IS_ERR(cell))\n\t\treturn PTR_ERR(cell);\n\n\tbuf = nvmem_cell_read(cell, NULL);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\t*val = *buf;\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int uniphier_u3hsphy_get_nvparams(struct uniphier_u3hsphy_priv *priv,\n\t\t\t\t\t struct uniphier_u3hsphy_trim_param *pt)\n{\n\tint ret;\n\n\tret = uniphier_u3hsphy_get_nvparam(priv, \"rterm\", &pt->rterm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uniphier_u3hsphy_get_nvparam(priv, \"sel_t\", &pt->sel_t);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uniphier_u3hsphy_get_nvparam(priv, \"hs_i\", &pt->hs_i);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int uniphier_u3hsphy_update_config(struct uniphier_u3hsphy_priv *priv,\n\t\t\t\t\t  u32 *pconfig)\n{\n\tstruct uniphier_u3hsphy_trim_param trim;\n\tint ret, trimmed = 0;\n\n\tif (priv->data->trim_func) {\n\t\tret = uniphier_u3hsphy_get_nvparams(priv, &trim);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!ret && trim_param_is_valid(&trim)) {\n\t\t\tpriv->data->trim_func(priv, pconfig, &trim);\n\t\t\ttrimmed = 1;\n\t\t} else {\n\t\t\tdev_dbg(priv->dev, \"can't get parameter from nvmem\\n\");\n\t\t}\n\t}\n\n\t \n\tif (!trimmed) {\n\t\t*pconfig &= ~HSPHY_CFG0_HSDISC_MASK;\n\t\t*pconfig |= FIELD_PREP(HSPHY_CFG0_HSDISC_MASK, 3);\n\t}\n\n\treturn 0;\n}\n\nstatic void uniphier_u3hsphy_set_param(struct uniphier_u3hsphy_priv *priv,\n\t\t\t\t       const struct uniphier_u3hsphy_param *p)\n{\n\tu32 val;\n\tu32 field_mask = GENMASK(p->field.msb, p->field.lsb);\n\tu8 data;\n\n\tval = readl(priv->base + HSPHY_CFG1);\n\tval &= ~HSPHY_CFG1_ADR_MASK;\n\tval |= FIELD_PREP(HSPHY_CFG1_ADR_MASK, p->field.reg_no)\n\t\t| HSPHY_CFG1_ADR_EN;\n\twritel(val, priv->base + HSPHY_CFG1);\n\n\tval = readl(priv->base + HSPHY_CFG1);\n\tval &= ~HSPHY_CFG1_ADR_EN;\n\twritel(val, priv->base + HSPHY_CFG1);\n\n\tval = readl(priv->base + HSPHY_CFG1);\n\tval &= ~FIELD_PREP(HSPHY_CFG1_DAT_MASK, field_mask);\n\tdata = field_mask & (p->value << p->field.lsb);\n\tval |=  FIELD_PREP(HSPHY_CFG1_DAT_MASK, data) | HSPHY_CFG1_DAT_EN;\n\twritel(val, priv->base + HSPHY_CFG1);\n\n\tval = readl(priv->base + HSPHY_CFG1);\n\tval &= ~HSPHY_CFG1_DAT_EN;\n\twritel(val, priv->base + HSPHY_CFG1);\n}\n\nstatic int uniphier_u3hsphy_power_on(struct phy *phy)\n{\n\tstruct uniphier_u3hsphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk_ext);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\tgoto out_clk_ext_disable;\n\n\tret = reset_control_deassert(priv->rst);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tif (priv->vbus) {\n\t\tret = regulator_enable(priv->vbus);\n\t\tif (ret)\n\t\t\tgoto out_rst_assert;\n\t}\n\n\treturn 0;\n\nout_rst_assert:\n\treset_control_assert(priv->rst);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk);\nout_clk_ext_disable:\n\tclk_disable_unprepare(priv->clk_ext);\n\n\treturn ret;\n}\n\nstatic int uniphier_u3hsphy_power_off(struct phy *phy)\n{\n\tstruct uniphier_u3hsphy_priv *priv = phy_get_drvdata(phy);\n\n\tif (priv->vbus)\n\t\tregulator_disable(priv->vbus);\n\n\treset_control_assert(priv->rst);\n\tclk_disable_unprepare(priv->clk);\n\tclk_disable_unprepare(priv->clk_ext);\n\n\treturn 0;\n}\n\nstatic int uniphier_u3hsphy_init(struct phy *phy)\n{\n\tstruct uniphier_u3hsphy_priv *priv = phy_get_drvdata(phy);\n\tu32 config0, config1;\n\tint i, ret;\n\n\tret = clk_prepare_enable(priv->clk_parent);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clk_parent_gio);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tret = reset_control_deassert(priv->rst_parent);\n\tif (ret)\n\t\tgoto out_clk_gio_disable;\n\n\tret = reset_control_deassert(priv->rst_parent_gio);\n\tif (ret)\n\t\tgoto out_rst_assert;\n\n\tif ((priv->data->is_legacy)\n\t    || (!priv->data->config0 && !priv->data->config1))\n\t\treturn 0;\n\n\tconfig0 = priv->data->config0;\n\tconfig1 = priv->data->config1;\n\n\tret = uniphier_u3hsphy_update_config(priv, &config0);\n\tif (ret)\n\t\tgoto out_rst_assert;\n\n\twritel(config0, priv->base + HSPHY_CFG0);\n\twritel(config1, priv->base + HSPHY_CFG1);\n\n\tfor (i = 0; i < priv->data->nparams; i++)\n\t\tuniphier_u3hsphy_set_param(priv, &priv->data->param[i]);\n\n\treturn 0;\n\nout_rst_assert:\n\treset_control_assert(priv->rst_parent);\nout_clk_gio_disable:\n\tclk_disable_unprepare(priv->clk_parent_gio);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk_parent);\n\n\treturn ret;\n}\n\nstatic int uniphier_u3hsphy_exit(struct phy *phy)\n{\n\tstruct uniphier_u3hsphy_priv *priv = phy_get_drvdata(phy);\n\n\treset_control_assert(priv->rst_parent_gio);\n\treset_control_assert(priv->rst_parent);\n\tclk_disable_unprepare(priv->clk_parent_gio);\n\tclk_disable_unprepare(priv->clk_parent);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops uniphier_u3hsphy_ops = {\n\t.init           = uniphier_u3hsphy_init,\n\t.exit           = uniphier_u3hsphy_exit,\n\t.power_on       = uniphier_u3hsphy_power_on,\n\t.power_off      = uniphier_u3hsphy_power_off,\n\t.owner          = THIS_MODULE,\n};\n\nstatic int uniphier_u3hsphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_u3hsphy_priv *priv;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *phy;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->data = of_device_get_match_data(dev);\n\tif (WARN_ON(!priv->data ||\n\t\t    priv->data->nparams > MAX_PHY_PARAMS))\n\t\treturn -EINVAL;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tif (!priv->data->is_legacy) {\n\t\tpriv->clk = devm_clk_get(dev, \"phy\");\n\t\tif (IS_ERR(priv->clk))\n\t\t\treturn PTR_ERR(priv->clk);\n\n\t\tpriv->clk_ext = devm_clk_get_optional(dev, \"phy-ext\");\n\t\tif (IS_ERR(priv->clk_ext))\n\t\t\treturn PTR_ERR(priv->clk_ext);\n\n\t\tpriv->rst = devm_reset_control_get_shared(dev, \"phy\");\n\t\tif (IS_ERR(priv->rst))\n\t\t\treturn PTR_ERR(priv->rst);\n\n\t} else {\n\t\tpriv->clk_parent_gio = devm_clk_get(dev, \"gio\");\n\t\tif (IS_ERR(priv->clk_parent_gio))\n\t\t\treturn PTR_ERR(priv->clk_parent_gio);\n\n\t\tpriv->rst_parent_gio =\n\t\t\tdevm_reset_control_get_shared(dev, \"gio\");\n\t\tif (IS_ERR(priv->rst_parent_gio))\n\t\t\treturn PTR_ERR(priv->rst_parent_gio);\n\t}\n\n\tpriv->clk_parent = devm_clk_get(dev, \"link\");\n\tif (IS_ERR(priv->clk_parent))\n\t\treturn PTR_ERR(priv->clk_parent);\n\n\tpriv->rst_parent = devm_reset_control_get_shared(dev, \"link\");\n\tif (IS_ERR(priv->rst_parent))\n\t\treturn PTR_ERR(priv->rst_parent);\n\n\tpriv->vbus = devm_regulator_get_optional(dev, \"vbus\");\n\tif (IS_ERR(priv->vbus)) {\n\t\tif (PTR_ERR(priv->vbus) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(priv->vbus);\n\t\tpriv->vbus = NULL;\n\t}\n\n\tphy = devm_phy_create(dev, dev->of_node, &uniphier_u3hsphy_ops);\n\tif (IS_ERR(phy))\n\t\treturn PTR_ERR(phy);\n\n\tphy_set_drvdata(phy, priv);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct uniphier_u3hsphy_soc_data uniphier_pro5_data = {\n\t.is_legacy = true,\n\t.nparams = 0,\n};\n\nstatic const struct uniphier_u3hsphy_soc_data uniphier_pxs2_data = {\n\t.is_legacy = false,\n\t.nparams = 2,\n\t.param = {\n\t\t{ RX_CHK_SYNC, 1 },\n\t\t{ RX_SYNC_SEL, 1 },\n\t},\n};\n\nstatic const struct uniphier_u3hsphy_soc_data uniphier_ld20_data = {\n\t.is_legacy = false,\n\t.nparams = 4,\n\t.param = {\n\t\t{ RX_CHK_SYNC, 1 },\n\t\t{ RX_SYNC_SEL, 1 },\n\t\t{ LS_SLEW, 1 },\n\t\t{ FS_LS_DRV, 1 },\n\t},\n\t.trim_func = uniphier_u3hsphy_trim_ld20,\n\t.config0 = 0x92316680,\n\t.config1 = 0x00000106,\n};\n\nstatic const struct uniphier_u3hsphy_soc_data uniphier_pxs3_data = {\n\t.is_legacy = false,\n\t.nparams = 2,\n\t.param = {\n\t\t{ RX_CHK_SYNC, 1 },\n\t\t{ RX_SYNC_SEL, 1 },\n\t},\n\t.trim_func = uniphier_u3hsphy_trim_ld20,\n\t.config0 = 0x92316680,\n\t.config1 = 0x00000106,\n};\n\nstatic const struct of_device_id uniphier_u3hsphy_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-pro5-usb3-hsphy\",\n\t\t.data = &uniphier_pro5_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs2-usb3-hsphy\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-ld20-usb3-hsphy\",\n\t\t.data = &uniphier_ld20_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-usb3-hsphy\",\n\t\t.data = &uniphier_pxs3_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-nx1-usb3-hsphy\",\n\t\t.data = &uniphier_pxs3_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_u3hsphy_match);\n\nstatic struct platform_driver uniphier_u3hsphy_driver = {\n\t.probe = uniphier_u3hsphy_probe,\n\t.driver\t= {\n\t\t.name = \"uniphier-usb3-hsphy\",\n\t\t.of_match_table\t= uniphier_u3hsphy_match,\n\t},\n};\n\nmodule_platform_driver(uniphier_u3hsphy_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier HS-PHY driver for USB3 controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}