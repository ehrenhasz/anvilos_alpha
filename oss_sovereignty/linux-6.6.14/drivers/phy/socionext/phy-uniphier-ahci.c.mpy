{
  "module_name": "phy-uniphier-ahci.c",
  "hash_id": "b840c9b1d49669b8a2297fd55395c0a5414c5c2b833dd66960ad5c939a87b969",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/socionext/phy-uniphier-ahci.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\nstruct uniphier_ahciphy_priv {\n\tstruct device *dev;\n\tvoid __iomem  *base;\n\tstruct clk *clk, *clk_parent, *clk_parent_gio;\n\tstruct reset_control *rst, *rst_parent, *rst_parent_gio;\n\tstruct reset_control *rst_pm, *rst_tx, *rst_rx;\n\tconst struct uniphier_ahciphy_soc_data *data;\n};\n\nstruct uniphier_ahciphy_soc_data {\n\tint (*init)(struct uniphier_ahciphy_priv *priv);\n\tint (*power_on)(struct uniphier_ahciphy_priv *priv);\n\tint (*power_off)(struct uniphier_ahciphy_priv *priv);\n\tbool is_legacy;\n\tbool is_ready_high;\n\tbool is_phy_clk;\n};\n\n \n#define CKCTRL0\t\t\t\t0x0\n#define CKCTRL0_CK_OFF\t\t\tBIT(9)\n#define CKCTRL0_NCY_MASK\t\tGENMASK(8, 4)\n#define CKCTRL0_NCY5_MASK\t\tGENMASK(3, 2)\n#define CKCTRL0_PRESCALE_MASK\t\tGENMASK(1, 0)\n#define CKCTRL1\t\t\t\t0x4\n#define CKCTRL1_LOS_LVL_MASK\t\tGENMASK(20, 16)\n#define CKCTRL1_TX_LVL_MASK\t\tGENMASK(12, 8)\n#define RXTXCTRL\t\t\t0x8\n#define RXTXCTRL_RX_EQ_VALL_MASK\tGENMASK(31, 29)\n#define RXTXCTRL_RX_DPLL_MODE_MASK\tGENMASK(28, 26)\n#define RXTXCTRL_TX_ATTEN_MASK\t\tGENMASK(14, 12)\n#define RXTXCTRL_TX_BOOST_MASK\t\tGENMASK(11, 8)\n#define RXTXCTRL_TX_EDGERATE_MASK\tGENMASK(3, 2)\n#define RXTXCTRL_TX_CKO_EN\t\tBIT(0)\n#define RSTPWR\t\t\t\t0x30\n#define RSTPWR_RX_EN_VAL\t\tBIT(18)\n\n \n#define CKCTRL\t\t\t\t0x0\n#define CKCTRL_P0_READY\t\t\tBIT(15)\n#define CKCTRL_P0_RESET\t\t\tBIT(10)\n#define CKCTRL_REF_SSP_EN\t\tBIT(9)\n#define TXCTRL0\t\t\t\t0x4\n#define TXCTRL0_AMP_G3_MASK\t\tGENMASK(22, 16)\n#define TXCTRL0_AMP_G2_MASK\t\tGENMASK(14, 8)\n#define TXCTRL0_AMP_G1_MASK\t\tGENMASK(6, 0)\n#define TXCTRL1\t\t\t\t0x8\n#define TXCTRL1_DEEMPH_G3_MASK\t\tGENMASK(21, 16)\n#define TXCTRL1_DEEMPH_G2_MASK\t\tGENMASK(13, 8)\n#define TXCTRL1_DEEMPH_G1_MASK\t\tGENMASK(5, 0)\n#define RXCTRL\t\t\t\t0xc\n#define RXCTRL_LOS_LVL_MASK\t\tGENMASK(20, 16)\n#define RXCTRL_LOS_BIAS_MASK\t\tGENMASK(10, 8)\n#define RXCTRL_RX_EQ_MASK\t\tGENMASK(2, 0)\n\nstatic int uniphier_ahciphy_pro4_init(struct uniphier_ahciphy_priv *priv)\n{\n\tu32 val;\n\n\t \n\tval = readl(priv->base + CKCTRL0);\n\tval &= ~CKCTRL0_NCY_MASK;\n\tval |= FIELD_PREP(CKCTRL0_NCY_MASK, 0x6);\n\tval &= ~CKCTRL0_NCY5_MASK;\n\tval |= FIELD_PREP(CKCTRL0_NCY5_MASK, 0x2);\n\tval &= ~CKCTRL0_PRESCALE_MASK;\n\tval |= FIELD_PREP(CKCTRL0_PRESCALE_MASK, 0x1);\n\twritel(val, priv->base + CKCTRL0);\n\n\t \n\tval = readl(priv->base + CKCTRL1);\n\tval &= ~CKCTRL1_LOS_LVL_MASK;\n\tval |= FIELD_PREP(CKCTRL1_LOS_LVL_MASK, 0x10);\n\tval &= ~CKCTRL1_TX_LVL_MASK;\n\tval |= FIELD_PREP(CKCTRL1_TX_LVL_MASK, 0x06);\n\twritel(val, priv->base + CKCTRL1);\n\n\tval = readl(priv->base + RXTXCTRL);\n\tval &= ~RXTXCTRL_RX_EQ_VALL_MASK;\n\tval |= FIELD_PREP(RXTXCTRL_RX_EQ_VALL_MASK, 0x6);\n\tval &= ~RXTXCTRL_RX_DPLL_MODE_MASK;\n\tval |= FIELD_PREP(RXTXCTRL_RX_DPLL_MODE_MASK, 0x3);\n\tval &= ~RXTXCTRL_TX_ATTEN_MASK;\n\tval |= FIELD_PREP(RXTXCTRL_TX_ATTEN_MASK, 0x3);\n\tval &= ~RXTXCTRL_TX_BOOST_MASK;\n\tval |= FIELD_PREP(RXTXCTRL_TX_BOOST_MASK, 0x5);\n\tval &= ~RXTXCTRL_TX_EDGERATE_MASK;\n\tval |= FIELD_PREP(RXTXCTRL_TX_EDGERATE_MASK, 0x0);\n\twritel(val, priv->base + RXTXCTRL);\n\n\treturn 0;\n}\n\nstatic int uniphier_ahciphy_pro4_power_on(struct uniphier_ahciphy_priv *priv)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tval = readl(priv->base + CKCTRL0);\n\tval &= ~CKCTRL0_CK_OFF;\n\twritel(val, priv->base + CKCTRL0);\n\n\t \n\tval = readl(priv->base + RXTXCTRL);\n\tval |= RXTXCTRL_TX_CKO_EN;\n\twritel(val, priv->base + RXTXCTRL);\n\n\t \n\tret = readl_poll_timeout(priv->base + RSTPWR, val,\n\t\t\t\t !(val & RSTPWR_RX_EN_VAL), 200, 2000);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to check whether Rx is ready\\n\");\n\t\tgoto out_disable_clock;\n\t}\n\n\t \n\tret = reset_control_deassert(priv->rst_pm);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to release PM reset\\n\");\n\t\tgoto out_disable_clock;\n\t}\n\n\tret = reset_control_deassert(priv->rst_tx);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to release Tx reset\\n\");\n\t\tgoto out_reset_pm_assert;\n\t}\n\n\tret = reset_control_deassert(priv->rst_rx);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to release Rx reset\\n\");\n\t\tgoto out_reset_tx_assert;\n\t}\n\n\treturn 0;\n\nout_reset_tx_assert:\n\treset_control_assert(priv->rst_tx);\nout_reset_pm_assert:\n\treset_control_assert(priv->rst_pm);\n\nout_disable_clock:\n\t \n\tval = readl(priv->base + RXTXCTRL);\n\tval &= ~RXTXCTRL_TX_CKO_EN;\n\twritel(val, priv->base + RXTXCTRL);\n\n\t \n\tval = readl(priv->base + CKCTRL0);\n\tval |= CKCTRL0_CK_OFF;\n\twritel(val, priv->base + CKCTRL0);\n\n\treturn ret;\n}\n\nstatic int uniphier_ahciphy_pro4_power_off(struct uniphier_ahciphy_priv *priv)\n{\n\tu32 val;\n\n\treset_control_assert(priv->rst_rx);\n\treset_control_assert(priv->rst_tx);\n\treset_control_assert(priv->rst_pm);\n\n\t \n\tval = readl(priv->base + RXTXCTRL);\n\tval &= ~RXTXCTRL_TX_CKO_EN;\n\twritel(val, priv->base + RXTXCTRL);\n\n\t \n\tval = readl(priv->base + CKCTRL0);\n\tval |= CKCTRL0_CK_OFF;\n\twritel(val, priv->base + CKCTRL0);\n\n\treturn 0;\n}\n\nstatic void uniphier_ahciphy_pxs2_enable(struct uniphier_ahciphy_priv *priv,\n\t\t\t\t\t bool enable)\n{\n\tu32 val;\n\n\tval = readl(priv->base + CKCTRL);\n\n\tif (enable) {\n\t\tval |= CKCTRL_REF_SSP_EN;\n\t\twritel(val, priv->base + CKCTRL);\n\t\tval &= ~CKCTRL_P0_RESET;\n\t\twritel(val, priv->base + CKCTRL);\n\t} else {\n\t\tval |= CKCTRL_P0_RESET;\n\t\twritel(val, priv->base + CKCTRL);\n\t\tval &= ~CKCTRL_REF_SSP_EN;\n\t\twritel(val, priv->base + CKCTRL);\n\t}\n}\n\nstatic int uniphier_ahciphy_pxs2_power_on(struct uniphier_ahciphy_priv *priv)\n{\n\tint ret;\n\tu32 val;\n\n\tuniphier_ahciphy_pxs2_enable(priv, true);\n\n\t \n\tif (priv->data->is_ready_high)\n\t\tret = readl_poll_timeout(priv->base + CKCTRL, val,\n\t\t\t\t\t (val & CKCTRL_P0_READY), 200, 400);\n\telse\n\t\tret = readl_poll_timeout(priv->base + CKCTRL, val,\n\t\t\t\t\t !(val & CKCTRL_P0_READY), 200, 400);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to check whether PHY PLL is ready\\n\");\n\t\tuniphier_ahciphy_pxs2_enable(priv, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int uniphier_ahciphy_pxs2_power_off(struct uniphier_ahciphy_priv *priv)\n{\n\tuniphier_ahciphy_pxs2_enable(priv, false);\n\n\treturn 0;\n}\n\nstatic int uniphier_ahciphy_pxs3_init(struct uniphier_ahciphy_priv *priv)\n{\n\tint i;\n\tu32 val;\n\n\t \n\tval = readl(priv->base + TXCTRL0);\n\tval &= ~TXCTRL0_AMP_G3_MASK;\n\tval |= FIELD_PREP(TXCTRL0_AMP_G3_MASK, 0x73);\n\tval &= ~TXCTRL0_AMP_G2_MASK;\n\tval |= FIELD_PREP(TXCTRL0_AMP_G2_MASK, 0x46);\n\tval &= ~TXCTRL0_AMP_G1_MASK;\n\tval |= FIELD_PREP(TXCTRL0_AMP_G1_MASK, 0x42);\n\twritel(val, priv->base + TXCTRL0);\n\n\tval = readl(priv->base + TXCTRL1);\n\tval &= ~TXCTRL1_DEEMPH_G3_MASK;\n\tval |= FIELD_PREP(TXCTRL1_DEEMPH_G3_MASK, 0x23);\n\tval &= ~TXCTRL1_DEEMPH_G2_MASK;\n\tval |= FIELD_PREP(TXCTRL1_DEEMPH_G2_MASK, 0x05);\n\tval &= ~TXCTRL1_DEEMPH_G1_MASK;\n\tval |= FIELD_PREP(TXCTRL1_DEEMPH_G1_MASK, 0x05);\n\n\tval = readl(priv->base + RXCTRL);\n\tval &= ~RXCTRL_LOS_LVL_MASK;\n\tval |= FIELD_PREP(RXCTRL_LOS_LVL_MASK, 0x9);\n\tval &= ~RXCTRL_LOS_BIAS_MASK;\n\tval |= FIELD_PREP(RXCTRL_LOS_BIAS_MASK, 0x2);\n\tval &= ~RXCTRL_RX_EQ_MASK;\n\tval |= FIELD_PREP(RXCTRL_RX_EQ_MASK, 0x1);\n\n\t \n\tfor (i = 0; i < 25; i++)\n\t\treadl(priv->base + CKCTRL);\n\n\treturn 0;\n}\n\nstatic int uniphier_ahciphy_init(struct phy *phy)\n{\n\tstruct uniphier_ahciphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk_parent_gio);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clk_parent);\n\tif (ret)\n\t\tgoto out_clk_gio_disable;\n\n\tret = reset_control_deassert(priv->rst_parent_gio);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tret = reset_control_deassert(priv->rst_parent);\n\tif (ret)\n\t\tgoto out_rst_gio_assert;\n\n\tif (priv->data->init) {\n\t\tret = priv->data->init(priv);\n\t\tif (ret)\n\t\t\tgoto out_rst_assert;\n\t}\n\n\treturn 0;\n\nout_rst_assert:\n\treset_control_assert(priv->rst_parent);\nout_rst_gio_assert:\n\treset_control_assert(priv->rst_parent_gio);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk_parent);\nout_clk_gio_disable:\n\tclk_disable_unprepare(priv->clk_parent_gio);\n\n\treturn ret;\n}\n\nstatic int uniphier_ahciphy_exit(struct phy *phy)\n{\n\tstruct uniphier_ahciphy_priv *priv = phy_get_drvdata(phy);\n\n\treset_control_assert(priv->rst_parent);\n\treset_control_assert(priv->rst_parent_gio);\n\tclk_disable_unprepare(priv->clk_parent);\n\tclk_disable_unprepare(priv->clk_parent_gio);\n\n\treturn 0;\n}\n\nstatic int uniphier_ahciphy_power_on(struct phy *phy)\n{\n\tstruct uniphier_ahciphy_priv *priv = phy_get_drvdata(phy);\n\tint ret = 0;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_deassert(priv->rst);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tif (priv->data->power_on) {\n\t\tret = priv->data->power_on(priv);\n\t\tif (ret)\n\t\t\tgoto out_reset_assert;\n\t}\n\n\treturn 0;\n\nout_reset_assert:\n\treset_control_assert(priv->rst);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic int uniphier_ahciphy_power_off(struct phy *phy)\n{\n\tstruct uniphier_ahciphy_priv *priv = phy_get_drvdata(phy);\n\tint ret = 0;\n\n\tif (priv->data->power_off)\n\t\tret = priv->data->power_off(priv);\n\n\treset_control_assert(priv->rst);\n\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic const struct phy_ops uniphier_ahciphy_ops = {\n\t.init  = uniphier_ahciphy_init,\n\t.exit  = uniphier_ahciphy_exit,\n\t.power_on  = uniphier_ahciphy_power_on,\n\t.power_off = uniphier_ahciphy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic int uniphier_ahciphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_ahciphy_priv *priv;\n\tstruct phy *phy;\n\tstruct phy_provider *phy_provider;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->data = of_device_get_match_data(dev);\n\tif (WARN_ON(!priv->data))\n\t\treturn -EINVAL;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->clk_parent = devm_clk_get(dev, \"link\");\n\tif (IS_ERR(priv->clk_parent))\n\t\treturn PTR_ERR(priv->clk_parent);\n\n\tif (priv->data->is_phy_clk) {\n\t\tpriv->clk = devm_clk_get(dev, \"phy\");\n\t\tif (IS_ERR(priv->clk))\n\t\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tpriv->rst_parent = devm_reset_control_get_shared(dev, \"link\");\n\tif (IS_ERR(priv->rst_parent))\n\t\treturn PTR_ERR(priv->rst_parent);\n\n\tpriv->rst = devm_reset_control_get_shared(dev, \"phy\");\n\tif (IS_ERR(priv->rst))\n\t\treturn PTR_ERR(priv->rst);\n\n\tif (priv->data->is_legacy) {\n\t\tpriv->clk_parent_gio = devm_clk_get(dev, \"gio\");\n\t\tif (IS_ERR(priv->clk_parent_gio))\n\t\t\treturn PTR_ERR(priv->clk_parent_gio);\n\t\tpriv->rst_parent_gio =\n\t\t\tdevm_reset_control_get_shared(dev, \"gio\");\n\t\tif (IS_ERR(priv->rst_parent_gio))\n\t\t\treturn PTR_ERR(priv->rst_parent_gio);\n\n\t\tpriv->rst_pm = devm_reset_control_get_shared(dev, \"pm\");\n\t\tif (IS_ERR(priv->rst_pm))\n\t\t\treturn PTR_ERR(priv->rst_pm);\n\n\t\tpriv->rst_tx = devm_reset_control_get_shared(dev, \"tx\");\n\t\tif (IS_ERR(priv->rst_tx))\n\t\t\treturn PTR_ERR(priv->rst_tx);\n\n\t\tpriv->rst_rx = devm_reset_control_get_shared(dev, \"rx\");\n\t\tif (IS_ERR(priv->rst_rx))\n\t\t\treturn PTR_ERR(priv->rst_rx);\n\t}\n\n\tphy = devm_phy_create(dev, dev->of_node, &uniphier_ahciphy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"failed to create phy\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\tphy_set_drvdata(phy, priv);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\treturn PTR_ERR(phy_provider);\n\n\treturn 0;\n}\n\nstatic const struct uniphier_ahciphy_soc_data uniphier_pro4_data = {\n\t.init = uniphier_ahciphy_pro4_init,\n\t.power_on  = uniphier_ahciphy_pro4_power_on,\n\t.power_off = uniphier_ahciphy_pro4_power_off,\n\t.is_legacy = true,\n\t.is_phy_clk = false,\n};\n\nstatic const struct uniphier_ahciphy_soc_data uniphier_pxs2_data = {\n\t.power_on  = uniphier_ahciphy_pxs2_power_on,\n\t.power_off = uniphier_ahciphy_pxs2_power_off,\n\t.is_legacy = false,\n\t.is_ready_high = false,\n\t.is_phy_clk = false,\n};\n\nstatic const struct uniphier_ahciphy_soc_data uniphier_pxs3_data = {\n\t.init      = uniphier_ahciphy_pxs3_init,\n\t.power_on  = uniphier_ahciphy_pxs2_power_on,\n\t.power_off = uniphier_ahciphy_pxs2_power_off,\n\t.is_legacy = false,\n\t.is_ready_high = true,\n\t.is_phy_clk = true,\n};\n\nstatic const struct of_device_id uniphier_ahciphy_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-pro4-ahci-phy\",\n\t\t.data = &uniphier_pro4_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs2-ahci-phy\",\n\t\t.data = &uniphier_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-ahci-phy\",\n\t\t.data = &uniphier_pxs3_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, uniphier_ahciphy_match);\n\nstatic struct platform_driver uniphier_ahciphy_driver = {\n\t.probe = uniphier_ahciphy_probe,\n\t.driver = {\n\t\t.name = \"uniphier-ahci-phy\",\n\t\t.of_match_table = uniphier_ahciphy_match,\n\t},\n};\nmodule_platform_driver(uniphier_ahciphy_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier PHY driver for AHCI controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}