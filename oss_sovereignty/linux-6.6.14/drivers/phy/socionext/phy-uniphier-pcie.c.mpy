{
  "module_name": "phy-uniphier-pcie.c",
  "hash_id": "1d117f42c01689d15b3597824409ba522ece86158c31b72402487207b765bf40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/socionext/phy-uniphier-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/resource.h>\n\n \n#define PCL_PHY_CLKCTRL\t\t0x0000\n#define PORT_SEL_MASK\t\tGENMASK(11, 9)\n#define PORT_SEL_1\t\tFIELD_PREP(PORT_SEL_MASK, 1)\n\n#define PCL_PHY_TEST_I\t\t0x2000\n#define TESTI_DAT_MASK\t\tGENMASK(13, 6)\n#define TESTI_ADR_MASK\t\tGENMASK(5, 1)\n#define TESTI_WR_EN\t\tBIT(0)\n#define TESTIO_PHY_SHIFT\t16\n\n#define PCL_PHY_TEST_O\t\t0x2004\n#define TESTO_DAT_MASK\t\tGENMASK(7, 0)\n\n#define PCL_PHY_RESET\t\t0x200c\n#define PCL_PHY_RESET_N_MNMODE\tBIT(8)\t \n#define PCL_PHY_RESET_N\t\tBIT(0)\t \n\n \n#define SG_USBPCIESEL\t\t0x590\n#define SG_USBPCIESEL_PCIE\tBIT(0)\n\n \n#define SC_US3SRCSEL\t\t0x2244\n#define SC_US3SRCSEL_2LANE\tGENMASK(9, 8)\n\n#define PCL_PHY_R00\t\t0\n#define   RX_EQ_ADJ_EN\t\tBIT(3)\t\t \n#define PCL_PHY_R06\t\t6\n#define   RX_EQ_ADJ\t\tGENMASK(5, 0)\t \n#define   RX_EQ_ADJ_VAL\t\t0\n#define PCL_PHY_R26\t\t26\n#define   VCO_CTRL\t\tGENMASK(7, 4)\t \n#define   VCO_CTRL_INIT_VAL\t5\n#define PCL_PHY_R28\t\t28\n#define   VCOPLL_CLMP\t\tGENMASK(3, 2)\t \n#define   VCOPLL_CLMP_VAL\t0\n\nstruct uniphier_pciephy_priv {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct clk *clk, *clk_gio;\n\tstruct reset_control *rst, *rst_gio;\n\tconst struct uniphier_pciephy_soc_data *data;\n};\n\nstruct uniphier_pciephy_soc_data {\n\tbool is_legacy;\n\tbool is_dual_phy;\n\tvoid (*set_phymode)(struct regmap *regmap);\n};\n\nstatic void uniphier_pciephy_testio_write(struct uniphier_pciephy_priv *priv,\n\t\t\t\t\t  int id, u32 data)\n{\n\tif (id)\n\t\tdata <<= TESTIO_PHY_SHIFT;\n\n\t \n\twritel(data, priv->base + PCL_PHY_TEST_I);\n\treadl(priv->base + PCL_PHY_TEST_O);\n\treadl(priv->base + PCL_PHY_TEST_O);\n}\n\nstatic u32 uniphier_pciephy_testio_read(struct uniphier_pciephy_priv *priv, int id)\n{\n\tu32 val = readl(priv->base + PCL_PHY_TEST_O);\n\n\tif (id)\n\t\tval >>= TESTIO_PHY_SHIFT;\n\n\treturn val & TESTO_DAT_MASK;\n}\n\nstatic void uniphier_pciephy_set_param(struct uniphier_pciephy_priv *priv,\n\t\t\t\t       int id, u32 reg, u32 mask, u32 param)\n{\n\tu32 val;\n\n\t \n\tval  = FIELD_PREP(TESTI_DAT_MASK, 1);\n\tval |= FIELD_PREP(TESTI_ADR_MASK, reg);\n\tuniphier_pciephy_testio_write(priv, id, val);\n\tval = uniphier_pciephy_testio_read(priv, id);\n\n\t \n\tval &= ~mask;\n\tval |= mask & param;\n\tval = FIELD_PREP(TESTI_DAT_MASK, val);\n\tval |= FIELD_PREP(TESTI_ADR_MASK, reg);\n\tuniphier_pciephy_testio_write(priv, id, val);\n\tuniphier_pciephy_testio_write(priv, id, val | TESTI_WR_EN);\n\tuniphier_pciephy_testio_write(priv, id, val);\n\n\t \n\tval  = FIELD_PREP(TESTI_DAT_MASK, 1);\n\tval |= FIELD_PREP(TESTI_ADR_MASK, reg);\n\tuniphier_pciephy_testio_write(priv, id, val);\n\tuniphier_pciephy_testio_read(priv, id);\n}\n\nstatic void uniphier_pciephy_assert(struct uniphier_pciephy_priv *priv)\n{\n\tu32 val;\n\n\tval = readl(priv->base + PCL_PHY_RESET);\n\tval &= ~PCL_PHY_RESET_N;\n\tval |= PCL_PHY_RESET_N_MNMODE;\n\twritel(val, priv->base + PCL_PHY_RESET);\n}\n\nstatic void uniphier_pciephy_deassert(struct uniphier_pciephy_priv *priv)\n{\n\tu32 val;\n\n\tval = readl(priv->base + PCL_PHY_RESET);\n\tval |= PCL_PHY_RESET_N_MNMODE | PCL_PHY_RESET_N;\n\twritel(val, priv->base + PCL_PHY_RESET);\n}\n\nstatic int uniphier_pciephy_init(struct phy *phy)\n{\n\tstruct uniphier_pciephy_priv *priv = phy_get_drvdata(phy);\n\tu32 val;\n\tint ret, id;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clk_gio);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tret = reset_control_deassert(priv->rst);\n\tif (ret)\n\t\tgoto out_clk_gio_disable;\n\n\tret = reset_control_deassert(priv->rst_gio);\n\tif (ret)\n\t\tgoto out_rst_assert;\n\n\t \n\tval = readl(priv->base + PCL_PHY_CLKCTRL);\n\tval &= ~PORT_SEL_MASK;\n\tval |= PORT_SEL_1;\n\twritel(val, priv->base + PCL_PHY_CLKCTRL);\n\n\t \n\tif (priv->data->is_legacy)\n\t\treturn 0;\n\n\tfor (id = 0; id < (priv->data->is_dual_phy ? 2 : 1); id++) {\n\t\tuniphier_pciephy_set_param(priv, id, PCL_PHY_R00,\n\t\t\t\t   RX_EQ_ADJ_EN, RX_EQ_ADJ_EN);\n\t\tuniphier_pciephy_set_param(priv, id, PCL_PHY_R06, RX_EQ_ADJ,\n\t\t\t\t   FIELD_PREP(RX_EQ_ADJ, RX_EQ_ADJ_VAL));\n\t\tuniphier_pciephy_set_param(priv, id, PCL_PHY_R26, VCO_CTRL,\n\t\t\t\t   FIELD_PREP(VCO_CTRL, VCO_CTRL_INIT_VAL));\n\t\tuniphier_pciephy_set_param(priv, id, PCL_PHY_R28, VCOPLL_CLMP,\n\t\t\t\t   FIELD_PREP(VCOPLL_CLMP, VCOPLL_CLMP_VAL));\n\t}\n\tusleep_range(1, 10);\n\n\tuniphier_pciephy_deassert(priv);\n\tusleep_range(1, 10);\n\n\treturn 0;\n\nout_rst_assert:\n\treset_control_assert(priv->rst);\nout_clk_gio_disable:\n\tclk_disable_unprepare(priv->clk_gio);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic int uniphier_pciephy_exit(struct phy *phy)\n{\n\tstruct uniphier_pciephy_priv *priv = phy_get_drvdata(phy);\n\n\tif (!priv->data->is_legacy)\n\t\tuniphier_pciephy_assert(priv);\n\treset_control_assert(priv->rst_gio);\n\treset_control_assert(priv->rst);\n\tclk_disable_unprepare(priv->clk_gio);\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops uniphier_pciephy_ops = {\n\t.init  = uniphier_pciephy_init,\n\t.exit  = uniphier_pciephy_exit,\n\t.owner = THIS_MODULE,\n};\n\nstatic int uniphier_pciephy_probe(struct platform_device *pdev)\n{\n\tstruct uniphier_pciephy_priv *priv;\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\tstruct phy *phy;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->data = of_device_get_match_data(dev);\n\tif (WARN_ON(!priv->data))\n\t\treturn -EINVAL;\n\n\tpriv->dev = dev;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tif (priv->data->is_legacy) {\n\t\tpriv->clk_gio = devm_clk_get(dev, \"gio\");\n\t\tif (IS_ERR(priv->clk_gio))\n\t\t\treturn PTR_ERR(priv->clk_gio);\n\n\t\tpriv->rst_gio =\n\t\t\tdevm_reset_control_get_shared(dev, \"gio\");\n\t\tif (IS_ERR(priv->rst_gio))\n\t\t\treturn PTR_ERR(priv->rst_gio);\n\n\t\tpriv->clk = devm_clk_get(dev, \"link\");\n\t\tif (IS_ERR(priv->clk))\n\t\t\treturn PTR_ERR(priv->clk);\n\n\t\tpriv->rst = devm_reset_control_get_shared(dev, \"link\");\n\t\tif (IS_ERR(priv->rst))\n\t\t\treturn PTR_ERR(priv->rst);\n\t} else {\n\t\tpriv->clk = devm_clk_get(dev, NULL);\n\t\tif (IS_ERR(priv->clk))\n\t\t\treturn PTR_ERR(priv->clk);\n\n\t\tpriv->rst = devm_reset_control_get_shared(dev, NULL);\n\t\tif (IS_ERR(priv->rst))\n\t\t\treturn PTR_ERR(priv->rst);\n\t}\n\n\tphy = devm_phy_create(dev, dev->of_node, &uniphier_pciephy_ops);\n\tif (IS_ERR(phy))\n\t\treturn PTR_ERR(phy);\n\n\tregmap = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t \"socionext,syscon\");\n\tif (!IS_ERR(regmap) && priv->data->set_phymode)\n\t\tpriv->data->set_phymode(regmap);\n\n\tphy_set_drvdata(phy, priv);\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic void uniphier_pciephy_ld20_setmode(struct regmap *regmap)\n{\n\tregmap_update_bits(regmap, SG_USBPCIESEL,\n\t\t\t   SG_USBPCIESEL_PCIE, SG_USBPCIESEL_PCIE);\n}\n\nstatic void uniphier_pciephy_nx1_setmode(struct regmap *regmap)\n{\n\tregmap_update_bits(regmap, SC_US3SRCSEL,\n\t\t\t   SC_US3SRCSEL_2LANE, SC_US3SRCSEL_2LANE);\n}\n\nstatic const struct uniphier_pciephy_soc_data uniphier_pro5_data = {\n\t.is_legacy = true,\n};\n\nstatic const struct uniphier_pciephy_soc_data uniphier_ld20_data = {\n\t.is_legacy = false,\n\t.is_dual_phy = false,\n\t.set_phymode = uniphier_pciephy_ld20_setmode,\n};\n\nstatic const struct uniphier_pciephy_soc_data uniphier_pxs3_data = {\n\t.is_legacy = false,\n\t.is_dual_phy = false,\n};\n\nstatic const struct uniphier_pciephy_soc_data uniphier_nx1_data = {\n\t.is_legacy = false,\n\t.is_dual_phy = true,\n\t.set_phymode = uniphier_pciephy_nx1_setmode,\n};\n\nstatic const struct of_device_id uniphier_pciephy_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-pro5-pcie-phy\",\n\t\t.data = &uniphier_pro5_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-ld20-pcie-phy\",\n\t\t.data = &uniphier_ld20_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-pcie-phy\",\n\t\t.data = &uniphier_pxs3_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-nx1-pcie-phy\",\n\t\t.data = &uniphier_nx1_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, uniphier_pciephy_match);\n\nstatic struct platform_driver uniphier_pciephy_driver = {\n\t.probe = uniphier_pciephy_probe,\n\t.driver = {\n\t\t.name = \"uniphier-pcie-phy\",\n\t\t.of_match_table = uniphier_pciephy_match,\n\t},\n};\nmodule_platform_driver(uniphier_pciephy_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier PHY driver for PCIe controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}