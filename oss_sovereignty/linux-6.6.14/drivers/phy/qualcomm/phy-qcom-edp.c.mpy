{
  "module_name": "phy-qcom-edp.c",
  "hash_id": "3b43ddb010c085751aa5afd724d9de15711749b90fe7372d1f16c018ff36cbb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-edp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/phy/phy.h>\n\n#include \"phy-qcom-qmp.h\"\n\n \n#define DP_PHY_CFG                              0x0010\n#define DP_PHY_CFG_1                            0x0014\n#define DP_PHY_PD_CTL                           0x001c\n#define DP_PHY_MODE                             0x0020\n\n#define DP_PHY_AUX_CFG0\t\t\t\t0x0024\n#define DP_PHY_AUX_CFG1\t\t\t\t0x0028\n#define DP_PHY_AUX_CFG2\t\t\t\t0x002C\n#define DP_PHY_AUX_CFG3\t\t\t\t0x0030\n#define DP_PHY_AUX_CFG4\t\t\t\t0x0034\n#define DP_PHY_AUX_CFG5\t\t\t\t0x0038\n#define DP_PHY_AUX_CFG6\t\t\t\t0x003C\n#define DP_PHY_AUX_CFG7\t\t\t\t0x0040\n#define DP_PHY_AUX_CFG8\t\t\t\t0x0044\n#define DP_PHY_AUX_CFG9\t\t\t\t0x0048\n\n#define DP_PHY_AUX_INTERRUPT_MASK\t\t0x0058\n\n#define DP_PHY_VCO_DIV                          0x0074\n#define DP_PHY_TX0_TX1_LANE_CTL                 0x007c\n#define DP_PHY_TX2_TX3_LANE_CTL                 0x00a0\n\n#define DP_PHY_STATUS                           0x00e0\n\n \n#define TXn_CLKBUF_ENABLE                       0x0000\n#define TXn_TX_EMP_POST1_LVL                    0x0004\n\n#define TXn_TX_DRV_LVL                          0x0014\n#define TXn_TX_DRV_LVL_OFFSET                   0x0018\n#define TXn_RESET_TSYNC_EN                      0x001c\n#define TXn_LDO_CONFIG                          0x0084\n#define TXn_TX_BAND                             0x0028\n\n#define TXn_RES_CODE_LANE_OFFSET_TX0            0x0044\n#define TXn_RES_CODE_LANE_OFFSET_TX1            0x0048\n\n#define TXn_TRANSCEIVER_BIAS_EN                 0x0054\n#define TXn_HIGHZ_DRVR_EN                       0x0058\n#define TXn_TX_POL_INV                          0x005c\n#define TXn_LANE_MODE_1                         0x0064\n\n#define TXn_TRAN_DRVR_EMP_EN                    0x0078\n\nstruct qcom_edp_cfg {\n\tbool is_dp;\n\n\t \n\tconst u8 (*swing_hbr_rbr)[4][4];\n\tconst u8 (*swing_hbr3_hbr2)[4][4];\n\tconst u8 (*pre_emphasis_hbr_rbr)[4][4];\n\tconst u8 (*pre_emphasis_hbr3_hbr2)[4][4];\n};\n\nstruct qcom_edp {\n\tstruct device *dev;\n\tconst struct qcom_edp_cfg *cfg;\n\n\tstruct phy *phy;\n\n\tvoid __iomem *edp;\n\tvoid __iomem *tx0;\n\tvoid __iomem *tx1;\n\tvoid __iomem *pll;\n\n\tstruct clk_hw dp_link_hw;\n\tstruct clk_hw dp_pixel_hw;\n\n\tstruct phy_configure_opts_dp dp_opts;\n\n\tstruct clk_bulk_data clks[2];\n\tstruct regulator_bulk_data supplies[2];\n};\n\nstatic const u8 dp_swing_hbr_rbr[4][4] = {\n\t{ 0x08, 0x0f, 0x16, 0x1f },\n\t{ 0x11, 0x1e, 0x1f, 0xff },\n\t{ 0x16, 0x1f, 0xff, 0xff },\n\t{ 0x1f, 0xff, 0xff, 0xff }\n};\n\nstatic const u8 dp_pre_emp_hbr_rbr[4][4] = {\n\t{ 0x00, 0x0d, 0x14, 0x1a },\n\t{ 0x00, 0x0e, 0x15, 0xff },\n\t{ 0x00, 0x0e, 0xff, 0xff },\n\t{ 0x03, 0xff, 0xff, 0xff }\n};\n\nstatic const u8 dp_swing_hbr2_hbr3[4][4] = {\n\t{ 0x02, 0x12, 0x16, 0x1a },\n\t{ 0x09, 0x19, 0x1f, 0xff },\n\t{ 0x10, 0x1f, 0xff, 0xff },\n\t{ 0x1f, 0xff, 0xff, 0xff }\n};\n\nstatic const u8 dp_pre_emp_hbr2_hbr3[4][4] = {\n\t{ 0x00, 0x0c, 0x15, 0x1b },\n\t{ 0x02, 0x0e, 0x16, 0xff },\n\t{ 0x02, 0x11, 0xff, 0xff },\n\t{ 0x04, 0xff, 0xff, 0xff }\n};\n\nstatic const struct qcom_edp_cfg dp_phy_cfg = {\n\t.is_dp = true,\n\t.swing_hbr_rbr = &dp_swing_hbr_rbr,\n\t.swing_hbr3_hbr2 = &dp_swing_hbr2_hbr3,\n\t.pre_emphasis_hbr_rbr = &dp_pre_emp_hbr_rbr,\n\t.pre_emphasis_hbr3_hbr2 = &dp_pre_emp_hbr2_hbr3,\n};\n\nstatic const u8 edp_swing_hbr_rbr[4][4] = {\n\t{ 0x07, 0x0f, 0x16, 0x1f },\n\t{ 0x0d, 0x16, 0x1e, 0xff },\n\t{ 0x11, 0x1b, 0xff, 0xff },\n\t{ 0x16, 0xff, 0xff, 0xff }\n};\n\nstatic const u8 edp_pre_emp_hbr_rbr[4][4] = {\n\t{ 0x05, 0x12, 0x17, 0x1d },\n\t{ 0x05, 0x11, 0x18, 0xff },\n\t{ 0x06, 0x11, 0xff, 0xff },\n\t{ 0x00, 0xff, 0xff, 0xff }\n};\n\nstatic const u8 edp_swing_hbr2_hbr3[4][4] = {\n\t{ 0x0b, 0x11, 0x17, 0x1c },\n\t{ 0x10, 0x19, 0x1f, 0xff },\n\t{ 0x19, 0x1f, 0xff, 0xff },\n\t{ 0x1f, 0xff, 0xff, 0xff }\n};\n\nstatic const u8 edp_pre_emp_hbr2_hbr3[4][4] = {\n\t{ 0x08, 0x11, 0x17, 0x1b },\n\t{ 0x00, 0x0c, 0x13, 0xff },\n\t{ 0x05, 0x10, 0xff, 0xff },\n\t{ 0x00, 0xff, 0xff, 0xff }\n};\n\nstatic const struct qcom_edp_cfg edp_phy_cfg = {\n\t.is_dp = false,\n\t.swing_hbr_rbr = &edp_swing_hbr_rbr,\n\t.swing_hbr3_hbr2 = &edp_swing_hbr2_hbr3,\n\t.pre_emphasis_hbr_rbr = &edp_pre_emp_hbr_rbr,\n\t.pre_emphasis_hbr3_hbr2 = &edp_pre_emp_hbr2_hbr3,\n};\n\nstatic int qcom_edp_phy_init(struct phy *phy)\n{\n\tstruct qcom_edp *edp = phy_get_drvdata(phy);\n\tconst struct qcom_edp_cfg *cfg = edp->cfg;\n\tint ret;\n\tu8 cfg8;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(edp->supplies), edp->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(ARRAY_SIZE(edp->clks), edp->clks);\n\tif (ret)\n\t\tgoto out_disable_supplies;\n\n\twritel(DP_PHY_PD_CTL_PWRDN | DP_PHY_PD_CTL_AUX_PWRDN |\n\t       DP_PHY_PD_CTL_PLL_PWRDN | DP_PHY_PD_CTL_DP_CLAMP_EN,\n\t       edp->edp + DP_PHY_PD_CTL);\n\n\t \n\twritel(0x17, edp->pll + QSERDES_V4_COM_BIAS_EN_CLKBUFLR_EN);\n\n\twritel(DP_PHY_PD_CTL_PSR_PWRDN, edp->edp + DP_PHY_PD_CTL);\n\tmsleep(20);\n\n\twritel(DP_PHY_PD_CTL_PWRDN | DP_PHY_PD_CTL_AUX_PWRDN |\n\t       DP_PHY_PD_CTL_LANE_0_1_PWRDN | DP_PHY_PD_CTL_LANE_2_3_PWRDN |\n\t       DP_PHY_PD_CTL_PLL_PWRDN | DP_PHY_PD_CTL_DP_CLAMP_EN,\n\t       edp->edp + DP_PHY_PD_CTL);\n\n\tif (cfg && cfg->is_dp)\n\t\tcfg8 = 0xb7;\n\telse\n\t\tcfg8 = 0x37;\n\n\twritel(0xfc, edp->edp + DP_PHY_MODE);\n\n\twritel(0x00, edp->edp + DP_PHY_AUX_CFG0);\n\twritel(0x13, edp->edp + DP_PHY_AUX_CFG1);\n\twritel(0x24, edp->edp + DP_PHY_AUX_CFG2);\n\twritel(0x00, edp->edp + DP_PHY_AUX_CFG3);\n\twritel(0x0a, edp->edp + DP_PHY_AUX_CFG4);\n\twritel(0x26, edp->edp + DP_PHY_AUX_CFG5);\n\twritel(0x0a, edp->edp + DP_PHY_AUX_CFG6);\n\twritel(0x03, edp->edp + DP_PHY_AUX_CFG7);\n\twritel(cfg8, edp->edp + DP_PHY_AUX_CFG8);\n\twritel(0x03, edp->edp + DP_PHY_AUX_CFG9);\n\n\twritel(PHY_AUX_STOP_ERR_MASK | PHY_AUX_DEC_ERR_MASK |\n\t       PHY_AUX_SYNC_ERR_MASK | PHY_AUX_ALIGN_ERR_MASK |\n\t       PHY_AUX_REQ_ERR_MASK, edp->edp + DP_PHY_AUX_INTERRUPT_MASK);\n\n\tmsleep(20);\n\n\treturn 0;\n\nout_disable_supplies:\n\tregulator_bulk_disable(ARRAY_SIZE(edp->supplies), edp->supplies);\n\n\treturn ret;\n}\n\nstatic int qcom_edp_set_voltages(struct qcom_edp *edp, const struct phy_configure_opts_dp *dp_opts)\n{\n\tconst struct qcom_edp_cfg *cfg = edp->cfg;\n\tunsigned int v_level = 0;\n\tunsigned int p_level = 0;\n\tu8 ldo_config;\n\tu8 swing;\n\tu8 emph;\n\tint i;\n\n\tif (!cfg)\n\t\treturn 0;\n\n\tfor (i = 0; i < dp_opts->lanes; i++) {\n\t\tv_level = max(v_level, dp_opts->voltage[i]);\n\t\tp_level = max(p_level, dp_opts->pre[i]);\n\t}\n\n\tif (dp_opts->link_rate <= 2700) {\n\t\tswing = (*cfg->swing_hbr_rbr)[v_level][p_level];\n\t\temph = (*cfg->pre_emphasis_hbr_rbr)[v_level][p_level];\n\t} else {\n\t\tswing = (*cfg->swing_hbr3_hbr2)[v_level][p_level];\n\t\temph = (*cfg->pre_emphasis_hbr3_hbr2)[v_level][p_level];\n\t}\n\n\tif (swing == 0xff || emph == 0xff)\n\t\treturn -EINVAL;\n\n\tldo_config = (cfg && cfg->is_dp) ? 0x1 : 0x0;\n\n\twritel(ldo_config, edp->tx0 + TXn_LDO_CONFIG);\n\twritel(swing, edp->tx0 + TXn_TX_DRV_LVL);\n\twritel(emph, edp->tx0 + TXn_TX_EMP_POST1_LVL);\n\n\twritel(ldo_config, edp->tx1 + TXn_LDO_CONFIG);\n\twritel(swing, edp->tx1 + TXn_TX_DRV_LVL);\n\twritel(emph, edp->tx1 + TXn_TX_EMP_POST1_LVL);\n\n\treturn 0;\n}\n\nstatic int qcom_edp_phy_configure(struct phy *phy, union phy_configure_opts *opts)\n{\n\tconst struct phy_configure_opts_dp *dp_opts = &opts->dp;\n\tstruct qcom_edp *edp = phy_get_drvdata(phy);\n\tint ret = 0;\n\n\tmemcpy(&edp->dp_opts, dp_opts, sizeof(*dp_opts));\n\n\tif (dp_opts->set_voltages)\n\t\tret = qcom_edp_set_voltages(edp, dp_opts);\n\n\treturn ret;\n}\n\nstatic int qcom_edp_configure_ssc(const struct qcom_edp *edp)\n{\n\tconst struct phy_configure_opts_dp *dp_opts = &edp->dp_opts;\n\tu32 step1;\n\tu32 step2;\n\n\tswitch (dp_opts->link_rate) {\n\tcase 1620:\n\tcase 2700:\n\tcase 8100:\n\t\tstep1 = 0x45;\n\t\tstep2 = 0x06;\n\t\tbreak;\n\n\tcase 5400:\n\t\tstep1 = 0x5c;\n\t\tstep2 = 0x08;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\twritel(0x01, edp->pll + QSERDES_V4_COM_SSC_EN_CENTER);\n\twritel(0x00, edp->pll + QSERDES_V4_COM_SSC_ADJ_PER1);\n\twritel(0x36, edp->pll + QSERDES_V4_COM_SSC_PER1);\n\twritel(0x01, edp->pll + QSERDES_V4_COM_SSC_PER2);\n\twritel(step1, edp->pll + QSERDES_V4_COM_SSC_STEP_SIZE1_MODE0);\n\twritel(step2, edp->pll + QSERDES_V4_COM_SSC_STEP_SIZE2_MODE0);\n\n\treturn 0;\n}\n\nstatic int qcom_edp_configure_pll(const struct qcom_edp *edp)\n{\n\tconst struct phy_configure_opts_dp *dp_opts = &edp->dp_opts;\n\tu32 div_frac_start2_mode0;\n\tu32 div_frac_start3_mode0;\n\tu32 dec_start_mode0;\n\tu32 lock_cmp1_mode0;\n\tu32 lock_cmp2_mode0;\n\tu32 hsclk_sel;\n\n\tswitch (dp_opts->link_rate) {\n\tcase 1620:\n\t\thsclk_sel = 0x5;\n\t\tdec_start_mode0 = 0x69;\n\t\tdiv_frac_start2_mode0 = 0x80;\n\t\tdiv_frac_start3_mode0 = 0x07;\n\t\tlock_cmp1_mode0 = 0x6f;\n\t\tlock_cmp2_mode0 = 0x08;\n\t\tbreak;\n\n\tcase 2700:\n\t\thsclk_sel = 0x3;\n\t\tdec_start_mode0 = 0x69;\n\t\tdiv_frac_start2_mode0 = 0x80;\n\t\tdiv_frac_start3_mode0 = 0x07;\n\t\tlock_cmp1_mode0 = 0x0f;\n\t\tlock_cmp2_mode0 = 0x0e;\n\t\tbreak;\n\n\tcase 5400:\n\t\thsclk_sel = 0x1;\n\t\tdec_start_mode0 = 0x8c;\n\t\tdiv_frac_start2_mode0 = 0x00;\n\t\tdiv_frac_start3_mode0 = 0x0a;\n\t\tlock_cmp1_mode0 = 0x1f;\n\t\tlock_cmp2_mode0 = 0x1c;\n\t\tbreak;\n\n\tcase 8100:\n\t\thsclk_sel = 0x0;\n\t\tdec_start_mode0 = 0x69;\n\t\tdiv_frac_start2_mode0 = 0x80;\n\t\tdiv_frac_start3_mode0 = 0x07;\n\t\tlock_cmp1_mode0 = 0x2f;\n\t\tlock_cmp2_mode0 = 0x2a;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\twritel(0x01, edp->pll + QSERDES_V4_COM_SVS_MODE_CLK_SEL);\n\twritel(0x0b, edp->pll + QSERDES_V4_COM_SYSCLK_EN_SEL);\n\twritel(0x02, edp->pll + QSERDES_V4_COM_SYS_CLK_CTRL);\n\twritel(0x0c, edp->pll + QSERDES_V4_COM_CLK_ENABLE1);\n\twritel(0x06, edp->pll + QSERDES_V4_COM_SYSCLK_BUF_ENABLE);\n\twritel(0x30, edp->pll + QSERDES_V4_COM_CLK_SELECT);\n\twritel(hsclk_sel, edp->pll + QSERDES_V4_COM_HSCLK_SEL);\n\twritel(0x0f, edp->pll + QSERDES_V4_COM_PLL_IVCO);\n\twritel(0x08, edp->pll + QSERDES_V4_COM_LOCK_CMP_EN);\n\twritel(0x36, edp->pll + QSERDES_V4_COM_PLL_CCTRL_MODE0);\n\twritel(0x16, edp->pll + QSERDES_V4_COM_PLL_RCTRL_MODE0);\n\twritel(0x06, edp->pll + QSERDES_V4_COM_CP_CTRL_MODE0);\n\twritel(dec_start_mode0, edp->pll + QSERDES_V4_COM_DEC_START_MODE0);\n\twritel(0x00, edp->pll + QSERDES_V4_COM_DIV_FRAC_START1_MODE0);\n\twritel(div_frac_start2_mode0, edp->pll + QSERDES_V4_COM_DIV_FRAC_START2_MODE0);\n\twritel(div_frac_start3_mode0, edp->pll + QSERDES_V4_COM_DIV_FRAC_START3_MODE0);\n\twritel(0x02, edp->pll + QSERDES_V4_COM_CMN_CONFIG);\n\twritel(0x3f, edp->pll + QSERDES_V4_COM_INTEGLOOP_GAIN0_MODE0);\n\twritel(0x00, edp->pll + QSERDES_V4_COM_INTEGLOOP_GAIN1_MODE0);\n\twritel(0x00, edp->pll + QSERDES_V4_COM_VCO_TUNE_MAP);\n\twritel(lock_cmp1_mode0, edp->pll + QSERDES_V4_COM_LOCK_CMP1_MODE0);\n\twritel(lock_cmp2_mode0, edp->pll + QSERDES_V4_COM_LOCK_CMP2_MODE0);\n\n\twritel(0x0a, edp->pll + QSERDES_V4_COM_BG_TIMER);\n\twritel(0x14, edp->pll + QSERDES_V4_COM_CORECLK_DIV_MODE0);\n\twritel(0x00, edp->pll + QSERDES_V4_COM_VCO_TUNE_CTRL);\n\twritel(0x17, edp->pll + QSERDES_V4_COM_BIAS_EN_CLKBUFLR_EN);\n\twritel(0x0f, edp->pll + QSERDES_V4_COM_CORE_CLK_EN);\n\twritel(0xa0, edp->pll + QSERDES_V4_COM_VCO_TUNE1_MODE0);\n\twritel(0x03, edp->pll + QSERDES_V4_COM_VCO_TUNE2_MODE0);\n\n\treturn 0;\n}\n\nstatic int qcom_edp_set_vco_div(const struct qcom_edp *edp, unsigned long *pixel_freq)\n{\n\tconst struct phy_configure_opts_dp *dp_opts = &edp->dp_opts;\n\tu32 vco_div;\n\n\tswitch (dp_opts->link_rate) {\n\tcase 1620:\n\t\tvco_div = 0x1;\n\t\t*pixel_freq = 1620000000UL / 2;\n\t\tbreak;\n\n\tcase 2700:\n\t\tvco_div = 0x1;\n\t\t*pixel_freq = 2700000000UL / 2;\n\t\tbreak;\n\n\tcase 5400:\n\t\tvco_div = 0x2;\n\t\t*pixel_freq = 5400000000UL / 4;\n\t\tbreak;\n\n\tcase 8100:\n\t\tvco_div = 0x0;\n\t\t*pixel_freq = 8100000000UL / 6;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\twritel(vco_div, edp->edp + DP_PHY_VCO_DIV);\n\n\treturn 0;\n}\n\nstatic int qcom_edp_phy_power_on(struct phy *phy)\n{\n\tconst struct qcom_edp *edp = phy_get_drvdata(phy);\n\tconst struct qcom_edp_cfg *cfg = edp->cfg;\n\tu32 bias0_en, drvr0_en, bias1_en, drvr1_en;\n\tunsigned long pixel_freq;\n\tu8 ldo_config;\n\tint timeout;\n\tint ret;\n\tu32 val;\n\tu8 cfg1;\n\n\twritel(DP_PHY_PD_CTL_PWRDN | DP_PHY_PD_CTL_AUX_PWRDN |\n\t       DP_PHY_PD_CTL_LANE_0_1_PWRDN | DP_PHY_PD_CTL_LANE_2_3_PWRDN |\n\t       DP_PHY_PD_CTL_PLL_PWRDN | DP_PHY_PD_CTL_DP_CLAMP_EN,\n\t       edp->edp + DP_PHY_PD_CTL);\n\twritel(0xfc, edp->edp + DP_PHY_MODE);\n\n\ttimeout = readl_poll_timeout(edp->pll + QSERDES_V4_COM_CMN_STATUS,\n\t\t\t\t     val, val & BIT(7), 5, 200);\n\tif (timeout)\n\t\treturn timeout;\n\n\n\tldo_config = (cfg && cfg->is_dp) ? 0x1 : 0x0;\n\n\twritel(ldo_config, edp->tx0 + TXn_LDO_CONFIG);\n\twritel(ldo_config, edp->tx1 + TXn_LDO_CONFIG);\n\twritel(0x00, edp->tx0 + TXn_LANE_MODE_1);\n\twritel(0x00, edp->tx1 + TXn_LANE_MODE_1);\n\n\tif (edp->dp_opts.ssc) {\n\t\tret = qcom_edp_configure_ssc(edp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = qcom_edp_configure_pll(edp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(0x05, edp->edp + DP_PHY_TX0_TX1_LANE_CTL);\n\twritel(0x05, edp->edp + DP_PHY_TX2_TX3_LANE_CTL);\n\n\t \n\twritel(0x03, edp->tx0 + TXn_TRANSCEIVER_BIAS_EN);\n\twritel(0x0f, edp->tx0 + TXn_CLKBUF_ENABLE);\n\twritel(0x03, edp->tx0 + TXn_RESET_TSYNC_EN);\n\twritel(0x01, edp->tx0 + TXn_TRAN_DRVR_EMP_EN);\n\twritel(0x04, edp->tx0 + TXn_TX_BAND);\n\n\t \n\twritel(0x03, edp->tx1 + TXn_TRANSCEIVER_BIAS_EN);\n\twritel(0x0f, edp->tx1 + TXn_CLKBUF_ENABLE);\n\twritel(0x03, edp->tx1 + TXn_RESET_TSYNC_EN);\n\twritel(0x01, edp->tx1 + TXn_TRAN_DRVR_EMP_EN);\n\twritel(0x04, edp->tx1 + TXn_TX_BAND);\n\n\tret = qcom_edp_set_vco_div(edp, &pixel_freq);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(0x01, edp->edp + DP_PHY_CFG);\n\twritel(0x05, edp->edp + DP_PHY_CFG);\n\twritel(0x01, edp->edp + DP_PHY_CFG);\n\twritel(0x09, edp->edp + DP_PHY_CFG);\n\n\twritel(0x20, edp->pll + QSERDES_V4_COM_RESETSM_CNTRL);\n\n\ttimeout = readl_poll_timeout(edp->pll + QSERDES_V4_COM_C_READY_STATUS,\n\t\t\t\t     val, val & BIT(0), 500, 10000);\n\tif (timeout)\n\t\treturn timeout;\n\n\twritel(0x19, edp->edp + DP_PHY_CFG);\n\twritel(0x1f, edp->tx0 + TXn_HIGHZ_DRVR_EN);\n\twritel(0x04, edp->tx0 + TXn_HIGHZ_DRVR_EN);\n\twritel(0x00, edp->tx0 + TXn_TX_POL_INV);\n\twritel(0x1f, edp->tx1 + TXn_HIGHZ_DRVR_EN);\n\twritel(0x04, edp->tx1 + TXn_HIGHZ_DRVR_EN);\n\twritel(0x00, edp->tx1 + TXn_TX_POL_INV);\n\twritel(0x10, edp->tx0 + TXn_TX_DRV_LVL_OFFSET);\n\twritel(0x10, edp->tx1 + TXn_TX_DRV_LVL_OFFSET);\n\twritel(0x11, edp->tx0 + TXn_RES_CODE_LANE_OFFSET_TX0);\n\twritel(0x11, edp->tx0 + TXn_RES_CODE_LANE_OFFSET_TX1);\n\twritel(0x11, edp->tx1 + TXn_RES_CODE_LANE_OFFSET_TX0);\n\twritel(0x11, edp->tx1 + TXn_RES_CODE_LANE_OFFSET_TX1);\n\n\twritel(0x10, edp->tx0 + TXn_TX_EMP_POST1_LVL);\n\twritel(0x10, edp->tx1 + TXn_TX_EMP_POST1_LVL);\n\twritel(0x1f, edp->tx0 + TXn_TX_DRV_LVL);\n\twritel(0x1f, edp->tx1 + TXn_TX_DRV_LVL);\n\n\tif (edp->dp_opts.lanes == 1) {\n\t\tbias0_en = 0x01;\n\t\tbias1_en = 0x00;\n\t\tdrvr0_en = 0x06;\n\t\tdrvr1_en = 0x07;\n\t\tcfg1 = 0x1;\n\t} else if (edp->dp_opts.lanes == 2) {\n\t\tbias0_en = 0x03;\n\t\tbias1_en = 0x00;\n\t\tdrvr0_en = 0x04;\n\t\tdrvr1_en = 0x07;\n\t\tcfg1 = 0x3;\n\t} else {\n\t\tbias0_en = 0x03;\n\t\tbias1_en = 0x03;\n\t\tdrvr0_en = 0x04;\n\t\tdrvr1_en = 0x04;\n\t\tcfg1 = 0xf;\n\t}\n\n\twritel(drvr0_en, edp->tx0 + TXn_HIGHZ_DRVR_EN);\n\twritel(bias0_en, edp->tx0 + TXn_TRANSCEIVER_BIAS_EN);\n\twritel(drvr1_en, edp->tx1 + TXn_HIGHZ_DRVR_EN);\n\twritel(bias1_en, edp->tx1 + TXn_TRANSCEIVER_BIAS_EN);\n\twritel(cfg1, edp->edp + DP_PHY_CFG_1);\n\n\twritel(0x18, edp->edp + DP_PHY_CFG);\n\tusleep_range(100, 1000);\n\n\twritel(0x19, edp->edp + DP_PHY_CFG);\n\n\tret = readl_poll_timeout(edp->edp + DP_PHY_STATUS,\n\t\t\t\t val, val & BIT(1), 500, 10000);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_set_rate(edp->dp_link_hw.clk, edp->dp_opts.link_rate * 100000);\n\tclk_set_rate(edp->dp_pixel_hw.clk, pixel_freq);\n\n\treturn 0;\n}\n\nstatic int qcom_edp_phy_power_off(struct phy *phy)\n{\n\tconst struct qcom_edp *edp = phy_get_drvdata(phy);\n\n\twritel(DP_PHY_PD_CTL_PSR_PWRDN, edp->edp + DP_PHY_PD_CTL);\n\n\treturn 0;\n}\n\nstatic int qcom_edp_phy_exit(struct phy *phy)\n{\n\tstruct qcom_edp *edp = phy_get_drvdata(phy);\n\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(edp->clks), edp->clks);\n\tregulator_bulk_disable(ARRAY_SIZE(edp->supplies), edp->supplies);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops qcom_edp_ops = {\n\t.init\t\t= qcom_edp_phy_init,\n\t.configure\t= qcom_edp_phy_configure,\n\t.power_on\t= qcom_edp_phy_power_on,\n\t.power_off\t= qcom_edp_phy_power_off,\n\t.exit\t\t= qcom_edp_phy_exit,\n\t.owner\t\t= THIS_MODULE,\n};\n\n \nstatic int qcom_edp_dp_pixel_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t\tstruct clk_rate_request *req)\n{\n\tswitch (req->rate) {\n\tcase 1620000000UL / 2:\n\tcase 2700000000UL / 2:\n\t \n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic unsigned long\nqcom_edp_dp_pixel_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tconst struct qcom_edp *edp = container_of(hw, struct qcom_edp, dp_pixel_hw);\n\tconst struct phy_configure_opts_dp *dp_opts = &edp->dp_opts;\n\n\tswitch (dp_opts->link_rate) {\n\tcase 1620:\n\t\treturn 1620000000UL / 2;\n\tcase 2700:\n\t\treturn 2700000000UL / 2;\n\tcase 5400:\n\t\treturn 5400000000UL / 4;\n\tcase 8100:\n\t\treturn 8100000000UL / 6;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct clk_ops qcom_edp_dp_pixel_clk_ops = {\n\t.determine_rate = qcom_edp_dp_pixel_clk_determine_rate,\n\t.recalc_rate = qcom_edp_dp_pixel_clk_recalc_rate,\n};\n\nstatic int qcom_edp_dp_link_clk_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t       struct clk_rate_request *req)\n{\n\tswitch (req->rate) {\n\tcase 162000000:\n\tcase 270000000:\n\tcase 540000000:\n\tcase 810000000:\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic unsigned long\nqcom_edp_dp_link_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\n{\n\tconst struct qcom_edp *edp = container_of(hw, struct qcom_edp, dp_link_hw);\n\tconst struct phy_configure_opts_dp *dp_opts = &edp->dp_opts;\n\n\tswitch (dp_opts->link_rate) {\n\tcase 1620:\n\tcase 2700:\n\tcase 5400:\n\tcase 8100:\n\t\treturn dp_opts->link_rate * 100000;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct clk_ops qcom_edp_dp_link_clk_ops = {\n\t.determine_rate = qcom_edp_dp_link_clk_determine_rate,\n\t.recalc_rate = qcom_edp_dp_link_clk_recalc_rate,\n};\n\nstatic int qcom_edp_clks_register(struct qcom_edp *edp, struct device_node *np)\n{\n\tstruct clk_hw_onecell_data *data;\n\tstruct clk_init_data init = { };\n\tchar name[64];\n\tint ret;\n\n\tdata = devm_kzalloc(edp->dev, struct_size(data, hws, 2), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->num = 2;\n\n\tsnprintf(name, sizeof(name), \"%s::link_clk\", dev_name(edp->dev));\n\tinit.ops = &qcom_edp_dp_link_clk_ops;\n\tinit.name = name;\n\tedp->dp_link_hw.init = &init;\n\tret = devm_clk_hw_register(edp->dev, &edp->dp_link_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(name, sizeof(name), \"%s::vco_div_clk\", dev_name(edp->dev));\n\tinit.ops = &qcom_edp_dp_pixel_clk_ops;\n\tinit.name = name;\n\tedp->dp_pixel_hw.init = &init;\n\tret = devm_clk_hw_register(edp->dev, &edp->dp_pixel_hw);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->hws[0] = &edp->dp_link_hw;\n\tdata->hws[1] = &edp->dp_pixel_hw;\n\n\treturn devm_of_clk_add_hw_provider(edp->dev, of_clk_hw_onecell_get, data);\n}\n\nstatic int qcom_edp_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_edp *edp;\n\tint ret;\n\n\tedp = devm_kzalloc(dev, sizeof(*edp), GFP_KERNEL);\n\tif (!edp)\n\t\treturn -ENOMEM;\n\n\tedp->dev = dev;\n\tedp->cfg = of_device_get_match_data(&pdev->dev);\n\n\tedp->edp = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(edp->edp))\n\t\treturn PTR_ERR(edp->edp);\n\n\tedp->tx0 = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(edp->tx0))\n\t\treturn PTR_ERR(edp->tx0);\n\n\tedp->tx1 = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(edp->tx1))\n\t\treturn PTR_ERR(edp->tx1);\n\n\tedp->pll = devm_platform_ioremap_resource(pdev, 3);\n\tif (IS_ERR(edp->pll))\n\t\treturn PTR_ERR(edp->pll);\n\n\tedp->clks[0].id = \"aux\";\n\tedp->clks[1].id = \"cfg_ahb\";\n\tret = devm_clk_bulk_get(dev, ARRAY_SIZE(edp->clks), edp->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tedp->supplies[0].supply = \"vdda-phy\";\n\tedp->supplies[1].supply = \"vdda-pll\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(edp->supplies), edp->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_set_load(edp->supplies[0].consumer, 21800);  \n\tif (ret) {\n\t\tdev_err(dev, \"failed to set load at %s\\n\", edp->supplies[0].supply);\n\t\treturn ret;\n\t}\n\n\tret = regulator_set_load(edp->supplies[1].consumer, 36000);  \n\tif (ret) {\n\t\tdev_err(dev, \"failed to set load at %s\\n\", edp->supplies[1].supply);\n\t\treturn ret;\n\t}\n\n\tret = qcom_edp_clks_register(edp, pdev->dev.of_node);\n\tif (ret)\n\t\treturn ret;\n\n\tedp->phy = devm_phy_create(dev, pdev->dev.of_node, &qcom_edp_ops);\n\tif (IS_ERR(edp->phy)) {\n\t\tdev_err(dev, \"failed to register phy\\n\");\n\t\treturn PTR_ERR(edp->phy);\n\t}\n\n\tphy_set_drvdata(edp->phy, edp);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id qcom_edp_phy_match_table[] = {\n\t{ .compatible = \"qcom,sc7280-edp-phy\" },\n\t{ .compatible = \"qcom,sc8180x-edp-phy\" },\n\t{ .compatible = \"qcom,sc8280xp-dp-phy\", .data = &dp_phy_cfg },\n\t{ .compatible = \"qcom,sc8280xp-edp-phy\", .data = &edp_phy_cfg },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_edp_phy_match_table);\n\nstatic struct platform_driver qcom_edp_phy_driver = {\n\t.probe\t\t= qcom_edp_phy_probe,\n\t.driver = {\n\t\t.name\t= \"qcom-edp-phy\",\n\t\t.of_match_table = qcom_edp_phy_match_table,\n\t},\n};\n\nmodule_platform_driver(qcom_edp_phy_driver);\n\nMODULE_AUTHOR(\"Bjorn Andersson <bjorn.andersson@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm eDP QMP PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}