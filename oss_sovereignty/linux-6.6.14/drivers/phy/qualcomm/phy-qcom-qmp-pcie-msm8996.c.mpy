{
  "module_name": "phy-qcom-qmp-pcie-msm8996.c",
  "hash_id": "4f3dbe4f1a0940e02d13dc5d3b9a3292437b37e0d344f7992b09c262d99979e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-qmp-pcie-msm8996.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include \"phy-qcom-qmp.h\"\n\n \n#define SW_RESET\t\t\t\tBIT(0)\n \n#define SW_PWRDN\t\t\t\tBIT(0)\n#define REFCLK_DRV_DSBL\t\t\t\tBIT(1)\n \n#define SERDES_START\t\t\t\tBIT(0)\n#define PCS_START\t\t\t\tBIT(1)\n#define PLL_READY_GATE_EN\t\t\tBIT(3)\n \n#define PHYSTATUS\t\t\t\tBIT(6)\n \n#define PCS_READY\t\t\t\tBIT(0)\n\n#define PHY_INIT_COMPLETE_TIMEOUT\t\t10000\n#define POWER_DOWN_DELAY_US_MIN\t\t\t10\n#define POWER_DOWN_DELAY_US_MAX\t\t\t20\n\nstruct qmp_phy_init_tbl {\n\tunsigned int offset;\n\tunsigned int val;\n\t \n\tu8 lane_mask;\n};\n\n#define QMP_PHY_INIT_CFG(o, v)\t\t\\\n\t{\t\t\t\t\\\n\t\t.offset = o,\t\t\\\n\t\t.val = v,\t\t\\\n\t\t.lane_mask = 0xff,\t\\\n\t}\n\n#define QMP_PHY_INIT_CFG_LANE(o, v, l)\t\\\n\t{\t\t\t\t\\\n\t\t.offset = o,\t\t\\\n\t\t.val = v,\t\t\\\n\t\t.lane_mask = l,\t\t\\\n\t}\n\n \nenum qphy_reg_layout {\n\t \n\tQPHY_COM_SW_RESET,\n\tQPHY_COM_POWER_DOWN_CONTROL,\n\tQPHY_COM_START_CONTROL,\n\tQPHY_COM_PCS_READY_STATUS,\n\t \n\tQPHY_SW_RESET,\n\tQPHY_START_CTRL,\n\tQPHY_PCS_STATUS,\n\t \n\tQPHY_LAYOUT_SIZE\n};\n\nstatic const unsigned int pciephy_regs_layout[QPHY_LAYOUT_SIZE] = {\n\t[QPHY_COM_SW_RESET]\t\t= 0x400,\n\t[QPHY_COM_POWER_DOWN_CONTROL]\t= 0x404,\n\t[QPHY_COM_START_CONTROL]\t= 0x408,\n\t[QPHY_COM_PCS_READY_STATUS]\t= 0x448,\n\t[QPHY_SW_RESET]\t\t\t= QPHY_V2_PCS_SW_RESET,\n\t[QPHY_START_CTRL]\t\t= QPHY_V2_PCS_START_CONTROL,\n\t[QPHY_PCS_STATUS]\t\t= QPHY_V2_PCS_PCI_PCS_STATUS,\n};\n\nstatic const struct qmp_phy_init_tbl msm8996_pcie_serdes_tbl[] = {\n\tQMP_PHY_INIT_CFG(QSERDES_COM_BIAS_EN_CLKBUFLR_EN, 0x1c),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CLK_ENABLE1, 0x10),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CLK_SELECT, 0x33),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CMN_CONFIG, 0x06),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_LOCK_CMP_EN, 0x42),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_VCO_TUNE_MAP, 0x00),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_VCO_TUNE_TIMER1, 0xff),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_VCO_TUNE_TIMER2, 0x1f),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_HSCLK_SEL, 0x01),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SVS_MODE_CLK_SEL, 0x01),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CORE_CLK_EN, 0x00),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CORECLK_DIV, 0x0a),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_BG_TIMER, 0x09),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_DEC_START_MODE0, 0x82),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_DIV_FRAC_START3_MODE0, 0x03),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_DIV_FRAC_START2_MODE0, 0x55),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_DIV_FRAC_START1_MODE0, 0x55),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_LOCK_CMP3_MODE0, 0x00),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_LOCK_CMP2_MODE0, 0x1a),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_LOCK_CMP1_MODE0, 0x0a),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CLK_SELECT, 0x33),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SYS_CLK_CTRL, 0x02),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SYSCLK_BUF_ENABLE, 0x1f),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SYSCLK_EN_SEL, 0x04),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CP_CTRL_MODE0, 0x0b),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_PLL_RCTRL_MODE0, 0x16),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_PLL_CCTRL_MODE0, 0x28),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_INTEGLOOP_GAIN1_MODE0, 0x00),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_INTEGLOOP_GAIN0_MODE0, 0x80),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SSC_EN_CENTER, 0x01),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SSC_PER1, 0x31),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SSC_PER2, 0x01),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SSC_ADJ_PER1, 0x02),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SSC_ADJ_PER2, 0x00),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SSC_STEP_SIZE1, 0x2f),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_SSC_STEP_SIZE2, 0x19),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_RESCODE_DIV_NUM, 0x15),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_BG_TRIM, 0x0f),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_PLL_IVCO, 0x0f),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CLK_EP_DIV, 0x19),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_CLK_ENABLE1, 0x10),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_HSCLK_SEL, 0x00),\n\tQMP_PHY_INIT_CFG(QSERDES_COM_RESCODE_DIV_NUM, 0x40),\n};\n\nstatic const struct qmp_phy_init_tbl msm8996_pcie_tx_tbl[] = {\n\tQMP_PHY_INIT_CFG(QSERDES_TX_HIGHZ_TRANSCEIVEREN_BIAS_DRVR_EN, 0x45),\n\tQMP_PHY_INIT_CFG(QSERDES_TX_LANE_MODE, 0x06),\n};\n\nstatic const struct qmp_phy_init_tbl msm8996_pcie_rx_tbl[] = {\n\tQMP_PHY_INIT_CFG(QSERDES_RX_SIGDET_ENABLES, 0x1c),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_RX_EQU_ADAPTOR_CNTRL2, 0x01),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_RX_EQU_ADAPTOR_CNTRL3, 0x00),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_RX_EQU_ADAPTOR_CNTRL4, 0xdb),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_RX_BAND, 0x18),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_UCDR_SO_GAIN, 0x04),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_UCDR_SO_GAIN_HALF, 0x04),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_UCDR_SO_SATURATION_AND_ENABLE, 0x4b),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_SIGDET_DEGLITCH_CNTRL, 0x14),\n\tQMP_PHY_INIT_CFG(QSERDES_RX_SIGDET_LVL, 0x19),\n};\n\nstatic const struct qmp_phy_init_tbl msm8996_pcie_pcs_tbl[] = {\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_RX_IDLE_DTCT_CNTRL, 0x4c),\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_PWRUP_RESET_DLY_TIME_AUXCLK, 0x00),\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_LP_WAKEUP_DLY_TIME_AUXCLK, 0x01),\n\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_PLL_LOCK_CHK_DLY_TIME, 0x05),\n\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_ENDPOINT_REFCLK_DRIVE, 0x05),\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_POWER_DOWN_CONTROL, 0x02),\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_POWER_STATE_CONFIG4, 0x00),\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_POWER_STATE_CONFIG1, 0xa3),\n\tQMP_PHY_INIT_CFG(QPHY_V2_PCS_TXDEEMPH_M3P5DB_V0, 0x0e),\n};\n\n \nstruct qmp_phy_cfg {\n\t \n\tint num_phys;\n\n\t \n\tconst struct qmp_phy_init_tbl *serdes_tbl;\n\tint serdes_tbl_num;\n\tconst struct qmp_phy_init_tbl *tx_tbl;\n\tint tx_tbl_num;\n\tconst struct qmp_phy_init_tbl *rx_tbl;\n\tint rx_tbl_num;\n\tconst struct qmp_phy_init_tbl *pcs_tbl;\n\tint pcs_tbl_num;\n\n\t \n\tconst char * const *clk_list;\n\tint num_clks;\n\t \n\tconst char * const *reset_list;\n\tint num_resets;\n\t \n\tconst char * const *vreg_list;\n\tint num_vregs;\n\n\t \n\tconst unsigned int *regs;\n};\n\n \nstruct qmp_phy {\n\tstruct phy *phy;\n\tconst struct qmp_phy_cfg *cfg;\n\tvoid __iomem *serdes;\n\tvoid __iomem *tx;\n\tvoid __iomem *rx;\n\tvoid __iomem *pcs;\n\tstruct clk *pipe_clk;\n\tunsigned int index;\n\tstruct qcom_qmp *qmp;\n\tstruct reset_control *lane_rst;\n};\n\n \nstruct qcom_qmp {\n\tstruct device *dev;\n\n\tstruct clk_bulk_data *clks;\n\tstruct reset_control_bulk_data *resets;\n\tstruct regulator_bulk_data *vregs;\n\n\tstruct qmp_phy **phys;\n\n\tstruct mutex phy_mutex;\n\tint init_count;\n};\n\nstatic inline void qphy_setbits(void __iomem *base, u32 offset, u32 val)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg |= val;\n\twritel(reg, base + offset);\n\n\t \n\treadl(base + offset);\n}\n\nstatic inline void qphy_clrbits(void __iomem *base, u32 offset, u32 val)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg &= ~val;\n\twritel(reg, base + offset);\n\n\t \n\treadl(base + offset);\n}\n\n \nstatic const char * const msm8996_phy_clk_l[] = {\n\t\"aux\", \"cfg_ahb\", \"ref\",\n};\n\n \nstatic const char * const msm8996_pciephy_reset_l[] = {\n\t\"phy\", \"common\", \"cfg\",\n};\n\n \nstatic const char * const qmp_phy_vreg_l[] = {\n\t\"vdda-phy\", \"vdda-pll\",\n};\n\nstatic const struct qmp_phy_cfg msm8996_pciephy_cfg = {\n\t.num_phys\t\t= 3,\n\n\t.serdes_tbl\t\t= msm8996_pcie_serdes_tbl,\n\t.serdes_tbl_num\t\t= ARRAY_SIZE(msm8996_pcie_serdes_tbl),\n\t.tx_tbl\t\t\t= msm8996_pcie_tx_tbl,\n\t.tx_tbl_num\t\t= ARRAY_SIZE(msm8996_pcie_tx_tbl),\n\t.rx_tbl\t\t\t= msm8996_pcie_rx_tbl,\n\t.rx_tbl_num\t\t= ARRAY_SIZE(msm8996_pcie_rx_tbl),\n\t.pcs_tbl\t\t= msm8996_pcie_pcs_tbl,\n\t.pcs_tbl_num\t\t= ARRAY_SIZE(msm8996_pcie_pcs_tbl),\n\t.clk_list\t\t= msm8996_phy_clk_l,\n\t.num_clks\t\t= ARRAY_SIZE(msm8996_phy_clk_l),\n\t.reset_list\t\t= msm8996_pciephy_reset_l,\n\t.num_resets\t\t= ARRAY_SIZE(msm8996_pciephy_reset_l),\n\t.vreg_list\t\t= qmp_phy_vreg_l,\n\t.num_vregs\t\t= ARRAY_SIZE(qmp_phy_vreg_l),\n\t.regs\t\t\t= pciephy_regs_layout,\n};\n\nstatic void qmp_pcie_msm8996_configure_lane(void __iomem *base,\n\t\t\t\t\tconst struct qmp_phy_init_tbl tbl[],\n\t\t\t\t\tint num,\n\t\t\t\t\tu8 lane_mask)\n{\n\tint i;\n\tconst struct qmp_phy_init_tbl *t = tbl;\n\n\tif (!t)\n\t\treturn;\n\n\tfor (i = 0; i < num; i++, t++) {\n\t\tif (!(t->lane_mask & lane_mask))\n\t\t\tcontinue;\n\n\t\twritel(t->val, base + t->offset);\n\t}\n}\n\nstatic void qmp_pcie_msm8996_configure(void __iomem *base,\n\t\t\t\t   const struct qmp_phy_init_tbl tbl[],\n\t\t\t\t   int num)\n{\n\tqmp_pcie_msm8996_configure_lane(base, tbl, num, 0xff);\n}\n\nstatic int qmp_pcie_msm8996_serdes_init(struct qmp_phy *qphy)\n{\n\tstruct qcom_qmp *qmp = qphy->qmp;\n\tconst struct qmp_phy_cfg *cfg = qphy->cfg;\n\tvoid __iomem *serdes = qphy->serdes;\n\tconst struct qmp_phy_init_tbl *serdes_tbl = cfg->serdes_tbl;\n\tint serdes_tbl_num = cfg->serdes_tbl_num;\n\tvoid __iomem *status;\n\tunsigned int val;\n\tint ret;\n\n\tqmp_pcie_msm8996_configure(serdes, serdes_tbl, serdes_tbl_num);\n\n\tqphy_clrbits(serdes, cfg->regs[QPHY_COM_SW_RESET], SW_RESET);\n\tqphy_setbits(serdes, cfg->regs[QPHY_COM_START_CONTROL],\n\t\t     SERDES_START | PCS_START);\n\n\tstatus = serdes + cfg->regs[QPHY_COM_PCS_READY_STATUS];\n\tret = readl_poll_timeout(status, val, (val & PCS_READY), 200,\n\t\t\t\t PHY_INIT_COMPLETE_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(qmp->dev,\n\t\t\t\"phy common block init timed-out\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int qmp_pcie_msm8996_com_init(struct qmp_phy *qphy)\n{\n\tstruct qcom_qmp *qmp = qphy->qmp;\n\tconst struct qmp_phy_cfg *cfg = qphy->cfg;\n\tvoid __iomem *serdes = qphy->serdes;\n\tint ret;\n\n\tmutex_lock(&qmp->phy_mutex);\n\tif (qmp->init_count++) {\n\t\tmutex_unlock(&qmp->phy_mutex);\n\t\treturn 0;\n\t}\n\n\tret = regulator_bulk_enable(cfg->num_vregs, qmp->vregs);\n\tif (ret) {\n\t\tdev_err(qmp->dev, \"failed to enable regulators, err=%d\\n\", ret);\n\t\tgoto err_decrement_count;\n\t}\n\n\tret = reset_control_bulk_assert(cfg->num_resets, qmp->resets);\n\tif (ret) {\n\t\tdev_err(qmp->dev, \"reset assert failed\\n\");\n\t\tgoto err_disable_regulators;\n\t}\n\n\tret = reset_control_bulk_deassert(cfg->num_resets, qmp->resets);\n\tif (ret) {\n\t\tdev_err(qmp->dev, \"reset deassert failed\\n\");\n\t\tgoto err_disable_regulators;\n\t}\n\n\tret = clk_bulk_prepare_enable(cfg->num_clks, qmp->clks);\n\tif (ret)\n\t\tgoto err_assert_reset;\n\n\tqphy_setbits(serdes, cfg->regs[QPHY_COM_POWER_DOWN_CONTROL],\n\t\t     SW_PWRDN);\n\n\tmutex_unlock(&qmp->phy_mutex);\n\n\treturn 0;\n\nerr_assert_reset:\n\treset_control_bulk_assert(cfg->num_resets, qmp->resets);\nerr_disable_regulators:\n\tregulator_bulk_disable(cfg->num_vregs, qmp->vregs);\nerr_decrement_count:\n\tqmp->init_count--;\n\tmutex_unlock(&qmp->phy_mutex);\n\n\treturn ret;\n}\n\nstatic int qmp_pcie_msm8996_com_exit(struct qmp_phy *qphy)\n{\n\tstruct qcom_qmp *qmp = qphy->qmp;\n\tconst struct qmp_phy_cfg *cfg = qphy->cfg;\n\tvoid __iomem *serdes = qphy->serdes;\n\n\tmutex_lock(&qmp->phy_mutex);\n\tif (--qmp->init_count) {\n\t\tmutex_unlock(&qmp->phy_mutex);\n\t\treturn 0;\n\t}\n\n\tqphy_setbits(serdes, cfg->regs[QPHY_COM_START_CONTROL],\n\t\t     SERDES_START | PCS_START);\n\tqphy_clrbits(serdes, cfg->regs[QPHY_COM_SW_RESET],\n\t\t     SW_RESET);\n\tqphy_setbits(serdes, cfg->regs[QPHY_COM_POWER_DOWN_CONTROL],\n\t\t     SW_PWRDN);\n\n\treset_control_bulk_assert(cfg->num_resets, qmp->resets);\n\n\tclk_bulk_disable_unprepare(cfg->num_clks, qmp->clks);\n\n\tregulator_bulk_disable(cfg->num_vregs, qmp->vregs);\n\n\tmutex_unlock(&qmp->phy_mutex);\n\n\treturn 0;\n}\n\nstatic int qmp_pcie_msm8996_init(struct phy *phy)\n{\n\tstruct qmp_phy *qphy = phy_get_drvdata(phy);\n\tstruct qcom_qmp *qmp = qphy->qmp;\n\tint ret;\n\tdev_vdbg(qmp->dev, \"Initializing QMP phy\\n\");\n\n\tret = qmp_pcie_msm8996_com_init(qphy);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int qmp_pcie_msm8996_power_on(struct phy *phy)\n{\n\tstruct qmp_phy *qphy = phy_get_drvdata(phy);\n\tstruct qcom_qmp *qmp = qphy->qmp;\n\tconst struct qmp_phy_cfg *cfg = qphy->cfg;\n\tvoid __iomem *tx = qphy->tx;\n\tvoid __iomem *rx = qphy->rx;\n\tvoid __iomem *pcs = qphy->pcs;\n\tvoid __iomem *status;\n\tunsigned int val;\n\tint ret;\n\n\tqmp_pcie_msm8996_serdes_init(qphy);\n\n\tret = reset_control_deassert(qphy->lane_rst);\n\tif (ret) {\n\t\tdev_err(qmp->dev, \"lane%d reset deassert failed\\n\",\n\t\t\tqphy->index);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(qphy->pipe_clk);\n\tif (ret) {\n\t\tdev_err(qmp->dev, \"pipe_clk enable failed err=%d\\n\", ret);\n\t\tgoto err_reset_lane;\n\t}\n\n\t \n\tqmp_pcie_msm8996_configure_lane(tx, cfg->tx_tbl, cfg->tx_tbl_num, 1);\n\tqmp_pcie_msm8996_configure_lane(rx, cfg->rx_tbl, cfg->rx_tbl_num, 1);\n\tqmp_pcie_msm8996_configure(pcs, cfg->pcs_tbl, cfg->pcs_tbl_num);\n\n\t \n\tqphy_setbits(pcs, QPHY_V2_PCS_POWER_DOWN_CONTROL,\n\t\t\tSW_PWRDN | REFCLK_DRV_DSBL);\n\n\tusleep_range(POWER_DOWN_DELAY_US_MIN, POWER_DOWN_DELAY_US_MAX);\n\n\t \n\tqphy_clrbits(pcs, cfg->regs[QPHY_SW_RESET], SW_RESET);\n\n\t \n\tqphy_setbits(pcs, cfg->regs[QPHY_START_CTRL],\n\t\t\tPCS_START | PLL_READY_GATE_EN);\n\n\tstatus = pcs + cfg->regs[QPHY_PCS_STATUS];\n\tret = readl_poll_timeout(status, val, !(val & PHYSTATUS), 200,\n\t\t\t\t PHY_INIT_COMPLETE_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(qmp->dev, \"phy initialization timed-out\\n\");\n\t\tgoto err_disable_pipe_clk;\n\t}\n\n\treturn 0;\n\nerr_disable_pipe_clk:\n\tclk_disable_unprepare(qphy->pipe_clk);\nerr_reset_lane:\n\treset_control_assert(qphy->lane_rst);\n\n\treturn ret;\n}\n\nstatic int qmp_pcie_msm8996_power_off(struct phy *phy)\n{\n\tstruct qmp_phy *qphy = phy_get_drvdata(phy);\n\tconst struct qmp_phy_cfg *cfg = qphy->cfg;\n\n\tclk_disable_unprepare(qphy->pipe_clk);\n\n\t \n\tqphy_setbits(qphy->pcs, cfg->regs[QPHY_SW_RESET], SW_RESET);\n\n\t \n\tqphy_clrbits(qphy->pcs, cfg->regs[QPHY_START_CTRL],\n\t\t\tSERDES_START | PCS_START);\n\n\t \n\tqphy_clrbits(qphy->pcs, QPHY_V2_PCS_POWER_DOWN_CONTROL,\n\t\t\tSW_PWRDN | REFCLK_DRV_DSBL);\n\n\treturn 0;\n}\n\nstatic int qmp_pcie_msm8996_exit(struct phy *phy)\n{\n\tstruct qmp_phy *qphy = phy_get_drvdata(phy);\n\n\treset_control_assert(qphy->lane_rst);\n\n\tqmp_pcie_msm8996_com_exit(qphy);\n\n\treturn 0;\n}\n\nstatic int qmp_pcie_msm8996_enable(struct phy *phy)\n{\n\tint ret;\n\n\tret = qmp_pcie_msm8996_init(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qmp_pcie_msm8996_power_on(phy);\n\tif (ret)\n\t\tqmp_pcie_msm8996_exit(phy);\n\n\treturn ret;\n}\n\nstatic int qmp_pcie_msm8996_disable(struct phy *phy)\n{\n\tint ret;\n\n\tret = qmp_pcie_msm8996_power_off(phy);\n\tif (ret)\n\t\treturn ret;\n\treturn qmp_pcie_msm8996_exit(phy);\n}\n\nstatic int qmp_pcie_msm8996_vreg_init(struct device *dev, const struct qmp_phy_cfg *cfg)\n{\n\tstruct qcom_qmp *qmp = dev_get_drvdata(dev);\n\tint num = cfg->num_vregs;\n\tint i;\n\n\tqmp->vregs = devm_kcalloc(dev, num, sizeof(*qmp->vregs), GFP_KERNEL);\n\tif (!qmp->vregs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++)\n\t\tqmp->vregs[i].supply = cfg->vreg_list[i];\n\n\treturn devm_regulator_bulk_get(dev, num, qmp->vregs);\n}\n\nstatic int qmp_pcie_msm8996_reset_init(struct device *dev, const struct qmp_phy_cfg *cfg)\n{\n\tstruct qcom_qmp *qmp = dev_get_drvdata(dev);\n\tint i;\n\tint ret;\n\n\tqmp->resets = devm_kcalloc(dev, cfg->num_resets,\n\t\t\t\t   sizeof(*qmp->resets), GFP_KERNEL);\n\tif (!qmp->resets)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cfg->num_resets; i++)\n\t\tqmp->resets[i].id = cfg->reset_list[i];\n\n\tret = devm_reset_control_bulk_get_exclusive(dev, cfg->num_resets, qmp->resets);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to get resets\\n\");\n\n\treturn 0;\n}\n\nstatic int qmp_pcie_msm8996_clk_init(struct device *dev, const struct qmp_phy_cfg *cfg)\n{\n\tstruct qcom_qmp *qmp = dev_get_drvdata(dev);\n\tint num = cfg->num_clks;\n\tint i;\n\n\tqmp->clks = devm_kcalloc(dev, num, sizeof(*qmp->clks), GFP_KERNEL);\n\tif (!qmp->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++)\n\t\tqmp->clks[i].id = cfg->clk_list[i];\n\n\treturn devm_clk_bulk_get(dev, num, qmp->clks);\n}\n\nstatic void phy_clk_release_provider(void *res)\n{\n\tof_clk_del_provider(res);\n}\n\n \nstatic int phy_pipe_clk_register(struct qcom_qmp *qmp, struct device_node *np)\n{\n\tstruct clk_fixed_rate *fixed;\n\tstruct clk_init_data init = { };\n\tint ret;\n\n\tret = of_property_read_string(np, \"clock-output-names\", &init.name);\n\tif (ret) {\n\t\tdev_err(qmp->dev, \"%pOFn: No clock-output-names\\n\", np);\n\t\treturn ret;\n\t}\n\n\tfixed = devm_kzalloc(qmp->dev, sizeof(*fixed), GFP_KERNEL);\n\tif (!fixed)\n\t\treturn -ENOMEM;\n\n\tinit.ops = &clk_fixed_rate_ops;\n\n\t \n\tfixed->fixed_rate = 125000000;\n\tfixed->hw.init = &init;\n\n\tret = devm_clk_hw_register(qmp->dev, &fixed->hw);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_clk_add_hw_provider(np, of_clk_hw_simple_get, &fixed->hw);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn devm_add_action_or_reset(qmp->dev, phy_clk_release_provider, np);\n}\n\nstatic const struct phy_ops qmp_pcie_msm8996_ops = {\n\t.power_on\t= qmp_pcie_msm8996_enable,\n\t.power_off\t= qmp_pcie_msm8996_disable,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void qcom_qmp_reset_control_put(void *data)\n{\n\treset_control_put(data);\n}\n\nstatic int qmp_pcie_msm8996_create(struct device *dev, struct device_node *np, int id,\n\t\t\tvoid __iomem *serdes, const struct qmp_phy_cfg *cfg)\n{\n\tstruct qcom_qmp *qmp = dev_get_drvdata(dev);\n\tstruct phy *generic_phy;\n\tstruct qmp_phy *qphy;\n\tint ret;\n\n\tqphy = devm_kzalloc(dev, sizeof(*qphy), GFP_KERNEL);\n\tif (!qphy)\n\t\treturn -ENOMEM;\n\n\tqphy->cfg = cfg;\n\tqphy->serdes = serdes;\n\t \n\tqphy->tx = devm_of_iomap(dev, np, 0, NULL);\n\tif (IS_ERR(qphy->tx))\n\t\treturn PTR_ERR(qphy->tx);\n\n\tqphy->rx = devm_of_iomap(dev, np, 1, NULL);\n\tif (IS_ERR(qphy->rx))\n\t\treturn PTR_ERR(qphy->rx);\n\n\tqphy->pcs = devm_of_iomap(dev, np, 2, NULL);\n\tif (IS_ERR(qphy->pcs))\n\t\treturn PTR_ERR(qphy->pcs);\n\n\tqphy->pipe_clk = devm_get_clk_from_child(dev, np, NULL);\n\tif (IS_ERR(qphy->pipe_clk)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(qphy->pipe_clk),\n\t\t\t\t     \"failed to get lane%d pipe clock\\n\", id);\n\t}\n\n\tqphy->lane_rst = of_reset_control_get_exclusive_by_index(np, 0);\n\tif (IS_ERR(qphy->lane_rst)) {\n\t\tdev_err(dev, \"failed to get lane%d reset\\n\", id);\n\t\treturn PTR_ERR(qphy->lane_rst);\n\t}\n\tret = devm_add_action_or_reset(dev, qcom_qmp_reset_control_put,\n\t\t\t\t       qphy->lane_rst);\n\tif (ret)\n\t\treturn ret;\n\n\tgeneric_phy = devm_phy_create(dev, np, &qmp_pcie_msm8996_ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tret = PTR_ERR(generic_phy);\n\t\tdev_err(dev, \"failed to create qphy %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tqphy->phy = generic_phy;\n\tqphy->index = id;\n\tqphy->qmp = qmp;\n\tqmp->phys[id] = qphy;\n\tphy_set_drvdata(generic_phy, qphy);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qmp_pcie_msm8996_of_match_table[] = {\n\t{\n\t\t.compatible = \"qcom,msm8996-qmp-pcie-phy\",\n\t\t.data = &msm8996_pciephy_cfg,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qmp_pcie_msm8996_of_match_table);\n\nstatic int qmp_pcie_msm8996_probe(struct platform_device *pdev)\n{\n\tstruct qcom_qmp *qmp;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child;\n\tstruct phy_provider *phy_provider;\n\tvoid __iomem *serdes;\n\tconst struct qmp_phy_cfg *cfg = NULL;\n\tint num, id, expected_phys;\n\tint ret;\n\n\tqmp = devm_kzalloc(dev, sizeof(*qmp), GFP_KERNEL);\n\tif (!qmp)\n\t\treturn -ENOMEM;\n\n\tqmp->dev = dev;\n\tdev_set_drvdata(dev, qmp);\n\n\tcfg = of_device_get_match_data(dev);\n\tif (!cfg)\n\t\treturn -EINVAL;\n\n\tserdes = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(serdes))\n\t\treturn PTR_ERR(serdes);\n\n\texpected_phys = cfg->num_phys;\n\n\tmutex_init(&qmp->phy_mutex);\n\n\tret = qmp_pcie_msm8996_clk_init(dev, cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qmp_pcie_msm8996_reset_init(dev, cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qmp_pcie_msm8996_vreg_init(dev, cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tnum = of_get_available_child_count(dev->of_node);\n\t \n\tif (num > expected_phys)\n\t\treturn -EINVAL;\n\n\tqmp->phys = devm_kcalloc(dev, num, sizeof(*qmp->phys), GFP_KERNEL);\n\tif (!qmp->phys)\n\t\treturn -ENOMEM;\n\n\tid = 0;\n\tfor_each_available_child_of_node(dev->of_node, child) {\n\t\t \n\t\tret = qmp_pcie_msm8996_create(dev, child, id, serdes, cfg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to create lane%d phy, %d\\n\",\n\t\t\t\tid, ret);\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\t \n\t\tret = phy_pipe_clk_register(qmp, child);\n\t\tif (ret) {\n\t\t\tdev_err(qmp->dev,\n\t\t\t\t\"failed to register pipe clock source\\n\");\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tid++;\n\t}\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n\nerr_node_put:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic struct platform_driver qmp_pcie_msm8996_driver = {\n\t.probe\t\t= qmp_pcie_msm8996_probe,\n\t.driver = {\n\t\t.name\t= \"qcom-qmp-msm8996-pcie-phy\",\n\t\t.of_match_table = qmp_pcie_msm8996_of_match_table,\n\t},\n};\n\nmodule_platform_driver(qmp_pcie_msm8996_driver);\n\nMODULE_AUTHOR(\"Vivek Gautam <vivek.gautam@codeaurora.org>\");\nMODULE_DESCRIPTION(\"Qualcomm QMP MSM8996 PCIe PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}