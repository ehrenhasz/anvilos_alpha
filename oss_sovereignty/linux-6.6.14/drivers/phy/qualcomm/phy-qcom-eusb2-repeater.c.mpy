{
  "module_name": "phy-qcom-eusb2-repeater.c",
  "hash_id": "13dc1413211824c45f2db64b1af4a36f86a3f86f5c3eeac175f0b0779bd70f4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n\n \n#define EUSB2_RPTR_STATUS\t\t0x08\n#define\tRPTR_OK\t\t\t\tBIT(7)\n\n \n#define EUSB2_EN_CTL1\t\t\t0x46\n#define EUSB2_RPTR_EN\t\t\tBIT(7)\n\n#define EUSB2_FORCE_EN_5\t\t0xe8\n#define F_CLK_19P2M_EN\t\t\tBIT(6)\n\n#define EUSB2_FORCE_VAL_5\t\t0xeD\n#define V_CLK_19P2M_EN\t\t\tBIT(6)\n\n#define EUSB2_TUNE_USB2_CROSSOVER\t0x50\n#define EUSB2_TUNE_IUSB2\t\t0x51\n#define EUSB2_TUNE_RES_FSDIF\t\t0x52\n#define EUSB2_TUNE_HSDISC\t\t0x53\n#define EUSB2_TUNE_SQUELCH_U\t\t0x54\n#define EUSB2_TUNE_USB2_SLEW\t\t0x55\n#define EUSB2_TUNE_USB2_EQU\t\t0x56\n#define EUSB2_TUNE_USB2_PREEM\t\t0x57\n#define EUSB2_TUNE_USB2_HS_COMP_CUR\t0x58\n#define EUSB2_TUNE_EUSB_SLEW\t\t0x59\n#define EUSB2_TUNE_EUSB_EQU\t\t0x5A\n#define EUSB2_TUNE_EUSB_HS_COMP_CUR\t0x5B\n\n#define QCOM_EUSB2_REPEATER_INIT_CFG(r, v)\t\\\n\t{\t\t\t\t\t\\\n\t\t.reg = r,\t\t\t\\\n\t\t.val = v,\t\t\t\\\n\t}\n\nenum reg_fields {\n\tF_TUNE_EUSB_HS_COMP_CUR,\n\tF_TUNE_EUSB_EQU,\n\tF_TUNE_EUSB_SLEW,\n\tF_TUNE_USB2_HS_COMP_CUR,\n\tF_TUNE_USB2_PREEM,\n\tF_TUNE_USB2_EQU,\n\tF_TUNE_USB2_SLEW,\n\tF_TUNE_SQUELCH_U,\n\tF_TUNE_HSDISC,\n\tF_TUNE_RES_FSDIF,\n\tF_TUNE_IUSB2,\n\tF_TUNE_USB2_CROSSOVER,\n\tF_NUM_TUNE_FIELDS,\n\n\tF_FORCE_VAL_5 = F_NUM_TUNE_FIELDS,\n\tF_FORCE_EN_5,\n\n\tF_EN_CTL1,\n\n\tF_RPTR_STATUS,\n\tF_NUM_FIELDS,\n};\n\nstatic struct reg_field eusb2_repeater_tune_reg_fields[F_NUM_FIELDS] = {\n\t[F_TUNE_EUSB_HS_COMP_CUR] = REG_FIELD(EUSB2_TUNE_EUSB_HS_COMP_CUR, 0, 1),\n\t[F_TUNE_EUSB_EQU] = REG_FIELD(EUSB2_TUNE_EUSB_EQU, 0, 1),\n\t[F_TUNE_EUSB_SLEW] = REG_FIELD(EUSB2_TUNE_EUSB_SLEW, 0, 1),\n\t[F_TUNE_USB2_HS_COMP_CUR] = REG_FIELD(EUSB2_TUNE_USB2_HS_COMP_CUR, 0, 1),\n\t[F_TUNE_USB2_PREEM] = REG_FIELD(EUSB2_TUNE_USB2_PREEM, 0, 2),\n\t[F_TUNE_USB2_EQU] = REG_FIELD(EUSB2_TUNE_USB2_EQU, 0, 1),\n\t[F_TUNE_USB2_SLEW] = REG_FIELD(EUSB2_TUNE_USB2_SLEW, 0, 1),\n\t[F_TUNE_SQUELCH_U] = REG_FIELD(EUSB2_TUNE_SQUELCH_U, 0, 2),\n\t[F_TUNE_HSDISC] = REG_FIELD(EUSB2_TUNE_HSDISC, 0, 2),\n\t[F_TUNE_RES_FSDIF] = REG_FIELD(EUSB2_TUNE_RES_FSDIF, 0, 2),\n\t[F_TUNE_IUSB2] = REG_FIELD(EUSB2_TUNE_IUSB2, 0, 3),\n\t[F_TUNE_USB2_CROSSOVER] = REG_FIELD(EUSB2_TUNE_USB2_CROSSOVER, 0, 2),\n\n\t[F_FORCE_VAL_5] = REG_FIELD(EUSB2_FORCE_VAL_5, 0, 7),\n\t[F_FORCE_EN_5] = REG_FIELD(EUSB2_FORCE_EN_5, 0, 7),\n\n\t[F_EN_CTL1] = REG_FIELD(EUSB2_EN_CTL1, 0, 7),\n\n\t[F_RPTR_STATUS] = REG_FIELD(EUSB2_RPTR_STATUS, 0, 7),\n};\n\nstruct eusb2_repeater_cfg {\n\tconst u32 *init_tbl;\n\tint init_tbl_num;\n\tconst char * const *vreg_list;\n\tint num_vregs;\n};\n\nstruct eusb2_repeater {\n\tstruct device *dev;\n\tstruct regmap_field *regs[F_NUM_FIELDS];\n\tstruct phy *phy;\n\tstruct regulator_bulk_data *vregs;\n\tconst struct eusb2_repeater_cfg *cfg;\n\tenum phy_mode mode;\n};\n\nstatic const char * const pm8550b_vreg_l[] = {\n\t\"vdd18\", \"vdd3\",\n};\n\nstatic const u32 pm8550b_init_tbl[F_NUM_TUNE_FIELDS] = {\n\t[F_TUNE_IUSB2] = 0x8,\n\t[F_TUNE_SQUELCH_U] = 0x3,\n\t[F_TUNE_USB2_PREEM] = 0x5,\n};\n\nstatic const struct eusb2_repeater_cfg pm8550b_eusb2_cfg = {\n\t.init_tbl\t= pm8550b_init_tbl,\n\t.init_tbl_num\t= ARRAY_SIZE(pm8550b_init_tbl),\n\t.vreg_list\t= pm8550b_vreg_l,\n\t.num_vregs\t= ARRAY_SIZE(pm8550b_vreg_l),\n};\n\nstatic int eusb2_repeater_init_vregs(struct eusb2_repeater *rptr)\n{\n\tint num = rptr->cfg->num_vregs;\n\tstruct device *dev = rptr->dev;\n\tint i;\n\n\trptr->vregs = devm_kcalloc(dev, num, sizeof(*rptr->vregs), GFP_KERNEL);\n\tif (!rptr->vregs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++)\n\t\trptr->vregs[i].supply = rptr->cfg->vreg_list[i];\n\n\treturn devm_regulator_bulk_get(dev, num, rptr->vregs);\n}\n\nstatic int eusb2_repeater_init(struct phy *phy)\n{\n\tstruct reg_field *regfields = eusb2_repeater_tune_reg_fields;\n\tstruct eusb2_repeater *rptr = phy_get_drvdata(phy);\n\tconst u32 *init_tbl = rptr->cfg->init_tbl;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tret = regulator_bulk_enable(rptr->cfg->num_vregs, rptr->vregs);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_field_update_bits(rptr->regs[F_EN_CTL1], EUSB2_RPTR_EN, EUSB2_RPTR_EN);\n\n\tfor (i = 0; i < F_NUM_TUNE_FIELDS; i++) {\n\t\tif (init_tbl[i]) {\n\t\t\tregmap_field_update_bits(rptr->regs[i], init_tbl[i], init_tbl[i]);\n\t\t} else {\n\t\t\t \n\t\t\tu32 mask = GENMASK(regfields[i].msb, regfields[i].lsb);\n\n\t\t\tregmap_field_update_bits(rptr->regs[i], mask, 0);\n\t\t}\n\t}\n\n\tret = regmap_field_read_poll_timeout(rptr->regs[F_RPTR_STATUS],\n\t\t\t\t\t     val, val & RPTR_OK, 10, 5);\n\tif (ret)\n\t\tdev_err(rptr->dev, \"initialization timed-out\\n\");\n\n\treturn ret;\n}\n\nstatic int eusb2_repeater_set_mode(struct phy *phy,\n\t\t\t\t   enum phy_mode mode, int submode)\n{\n\tstruct eusb2_repeater *rptr = phy_get_drvdata(phy);\n\n\tswitch (mode) {\n\tcase PHY_MODE_USB_HOST:\n\t\t \n\t\tregmap_field_update_bits(rptr->regs[F_FORCE_EN_5],\n\t\t\t\t\t F_CLK_19P2M_EN, F_CLK_19P2M_EN);\n\t\tregmap_field_update_bits(rptr->regs[F_FORCE_VAL_5],\n\t\t\t\t\t V_CLK_19P2M_EN, V_CLK_19P2M_EN);\n\t\tbreak;\n\tcase PHY_MODE_USB_DEVICE:\n\t\t \n\t\tregmap_field_update_bits(rptr->regs[F_FORCE_EN_5],\n\t\t\t\t\t F_CLK_19P2M_EN, 0);\n\t\tregmap_field_update_bits(rptr->regs[F_FORCE_VAL_5],\n\t\t\t\t\t V_CLK_19P2M_EN, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int eusb2_repeater_exit(struct phy *phy)\n{\n\tstruct eusb2_repeater *rptr = phy_get_drvdata(phy);\n\n\treturn regulator_bulk_disable(rptr->cfg->num_vregs, rptr->vregs);\n}\n\nstatic const struct phy_ops eusb2_repeater_ops = {\n\t.init\t\t= eusb2_repeater_init,\n\t.exit\t\t= eusb2_repeater_exit,\n\t.set_mode\t= eusb2_repeater_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int eusb2_repeater_probe(struct platform_device *pdev)\n{\n\tstruct eusb2_repeater *rptr;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap *regmap;\n\tint i, ret;\n\tu32 res;\n\n\trptr = devm_kzalloc(dev, sizeof(*rptr), GFP_KERNEL);\n\tif (!rptr)\n\t\treturn -ENOMEM;\n\n\trptr->dev = dev;\n\tdev_set_drvdata(dev, rptr);\n\n\trptr->cfg = of_device_get_match_data(dev);\n\tif (!rptr->cfg)\n\t\treturn -EINVAL;\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap)\n\t\treturn -ENODEV;\n\n\tret = of_property_read_u32(np, \"reg\", &res);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < F_NUM_FIELDS; i++)\n\t\teusb2_repeater_tune_reg_fields[i].reg += res;\n\n\tret = devm_regmap_field_bulk_alloc(dev, regmap, rptr->regs,\n\t\t\t\t\t   eusb2_repeater_tune_reg_fields,\n\t\t\t\t\t   F_NUM_FIELDS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = eusb2_repeater_init_vregs(rptr);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to get supplies\\n\");\n\t\treturn ret;\n\t}\n\n\trptr->phy = devm_phy_create(dev, np, &eusb2_repeater_ops);\n\tif (IS_ERR(rptr->phy)) {\n\t\tdev_err(dev, \"failed to create PHY: %d\\n\", ret);\n\t\treturn PTR_ERR(rptr->phy);\n\t}\n\n\tphy_set_drvdata(rptr->phy, rptr);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\treturn PTR_ERR(phy_provider);\n\n\tdev_info(dev, \"Registered Qcom-eUSB2 repeater\\n\");\n\n\treturn 0;\n}\n\nstatic void eusb2_repeater_remove(struct platform_device *pdev)\n{\n\tstruct eusb2_repeater *rptr = platform_get_drvdata(pdev);\n\n\tif (!rptr)\n\t\treturn;\n\n\teusb2_repeater_exit(rptr->phy);\n}\n\nstatic const struct of_device_id eusb2_repeater_of_match_table[] = {\n\t{\n\t\t.compatible = \"qcom,pm8550b-eusb2-repeater\",\n\t\t.data = &pm8550b_eusb2_cfg,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, eusb2_repeater_of_match_table);\n\nstatic struct platform_driver eusb2_repeater_driver = {\n\t.probe\t\t= eusb2_repeater_probe,\n\t.remove_new\t= eusb2_repeater_remove,\n\t.driver = {\n\t\t.name\t= \"qcom-eusb2-repeater\",\n\t\t.of_match_table = eusb2_repeater_of_match_table,\n\t},\n};\n\nmodule_platform_driver(eusb2_repeater_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm PMIC eUSB2 Repeater driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}