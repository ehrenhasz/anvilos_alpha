{
  "module_name": "phy-qcom-usb-ss.c",
  "hash_id": "ecf5bf6a2c8575b6d1c1fc0063f430116c414c7d51982162f4244dcaaf7fe52d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-usb-ss.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#define PHY_CTRL0\t\t\t0x6C\n#define PHY_CTRL1\t\t\t0x70\n#define PHY_CTRL2\t\t\t0x74\n#define PHY_CTRL4\t\t\t0x7C\n\n \n#define REF_PHY_EN\t\t\tBIT(0)\n#define LANE0_PWR_ON\t\t\tBIT(2)\n#define SWI_PCS_CLK_SEL\t\t\tBIT(4)\n#define TST_PWR_DOWN\t\t\tBIT(4)\n#define PHY_RESET\t\t\tBIT(7)\n\n#define NUM_BULK_CLKS\t\t\t3\n#define NUM_BULK_REGS\t\t\t2\n\nstruct ssphy_priv {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct reset_control *reset_com;\n\tstruct reset_control *reset_phy;\n\tstruct regulator_bulk_data regs[NUM_BULK_REGS];\n\tstruct clk_bulk_data clks[NUM_BULK_CLKS];\n\tenum phy_mode mode;\n};\n\nstatic inline void qcom_ssphy_updatel(void __iomem *addr, u32 mask, u32 val)\n{\n\twritel((readl(addr) & ~mask) | val, addr);\n}\n\nstatic int qcom_ssphy_do_reset(struct ssphy_priv *priv)\n{\n\tint ret;\n\n\tif (!priv->reset_com) {\n\t\tqcom_ssphy_updatel(priv->base + PHY_CTRL1, PHY_RESET,\n\t\t\t\t   PHY_RESET);\n\t\tusleep_range(10, 20);\n\t\tqcom_ssphy_updatel(priv->base + PHY_CTRL1, PHY_RESET, 0);\n\t} else {\n\t\tret = reset_control_assert(priv->reset_com);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Failed to assert reset com\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = reset_control_assert(priv->reset_phy);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Failed to assert reset phy\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tusleep_range(10, 20);\n\n\t\tret = reset_control_deassert(priv->reset_com);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Failed to deassert reset com\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = reset_control_deassert(priv->reset_phy);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Failed to deassert reset phy\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_ssphy_power_on(struct phy *phy)\n{\n\tstruct ssphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = regulator_bulk_enable(NUM_BULK_REGS, priv->regs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(NUM_BULK_CLKS, priv->clks);\n\tif (ret)\n\t\tgoto err_disable_regulator;\n\n\tret = qcom_ssphy_do_reset(priv);\n\tif (ret)\n\t\tgoto err_disable_clock;\n\n\twriteb(SWI_PCS_CLK_SEL, priv->base + PHY_CTRL0);\n\tqcom_ssphy_updatel(priv->base + PHY_CTRL4, LANE0_PWR_ON, LANE0_PWR_ON);\n\tqcom_ssphy_updatel(priv->base + PHY_CTRL2, REF_PHY_EN, REF_PHY_EN);\n\tqcom_ssphy_updatel(priv->base + PHY_CTRL4, TST_PWR_DOWN, 0);\n\n\treturn 0;\nerr_disable_clock:\n\tclk_bulk_disable_unprepare(NUM_BULK_CLKS, priv->clks);\nerr_disable_regulator:\n\tregulator_bulk_disable(NUM_BULK_REGS, priv->regs);\n\n\treturn ret;\n}\n\nstatic int qcom_ssphy_power_off(struct phy *phy)\n{\n\tstruct ssphy_priv *priv = phy_get_drvdata(phy);\n\n\tqcom_ssphy_updatel(priv->base + PHY_CTRL4, LANE0_PWR_ON, 0);\n\tqcom_ssphy_updatel(priv->base + PHY_CTRL2, REF_PHY_EN, 0);\n\tqcom_ssphy_updatel(priv->base + PHY_CTRL4, TST_PWR_DOWN, TST_PWR_DOWN);\n\n\tclk_bulk_disable_unprepare(NUM_BULK_CLKS, priv->clks);\n\tregulator_bulk_disable(NUM_BULK_REGS, priv->regs);\n\n\treturn 0;\n}\n\nstatic int qcom_ssphy_init_clock(struct ssphy_priv *priv)\n{\n\tpriv->clks[0].id = \"ref\";\n\tpriv->clks[1].id = \"ahb\";\n\tpriv->clks[2].id = \"pipe\";\n\n\treturn devm_clk_bulk_get(priv->dev, NUM_BULK_CLKS, priv->clks);\n}\n\nstatic int qcom_ssphy_init_regulator(struct ssphy_priv *priv)\n{\n\tint ret;\n\n\tpriv->regs[0].supply = \"vdd\";\n\tpriv->regs[1].supply = \"vdda1p8\";\n\tret = devm_regulator_bulk_get(priv->dev, NUM_BULK_REGS, priv->regs);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(priv->dev, \"Failed to get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int qcom_ssphy_init_reset(struct ssphy_priv *priv)\n{\n\tpriv->reset_com = devm_reset_control_get_optional_exclusive(priv->dev, \"com\");\n\tif (IS_ERR(priv->reset_com)) {\n\t\tdev_err(priv->dev, \"Failed to get reset control com\\n\");\n\t\treturn PTR_ERR(priv->reset_com);\n\t}\n\n\tif (priv->reset_com) {\n\t\t \n\t\tpriv->reset_phy = devm_reset_control_get_exclusive(priv->dev, \"phy\");\n\t\tif (IS_ERR(priv->reset_phy)) {\n\t\t\tdev_err(priv->dev, \"Failed to get reset control phy\\n\");\n\t\t\treturn PTR_ERR(priv->reset_phy);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct phy_ops qcom_ssphy_ops = {\n\t.power_off = qcom_ssphy_power_off,\n\t.power_on = qcom_ssphy_power_on,\n\t.owner = THIS_MODULE,\n};\n\nstatic int qcom_ssphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *provider;\n\tstruct ssphy_priv *priv;\n\tstruct phy *phy;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct ssphy_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->mode = PHY_MODE_INVALID;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tret = qcom_ssphy_init_clock(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_ssphy_init_reset(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_ssphy_init_regulator(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tphy = devm_phy_create(dev, dev->of_node, &qcom_ssphy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"Failed to create the SS phy\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\tphy_set_drvdata(phy, priv);\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic const struct of_device_id qcom_ssphy_match[] = {\n\t{ .compatible = \"qcom,usb-ss-28nm-phy\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qcom_ssphy_match);\n\nstatic struct platform_driver qcom_ssphy_driver = {\n\t.probe\t\t= qcom_ssphy_probe,\n\t.driver = {\n\t\t.name\t= \"qcom-usb-ssphy\",\n\t\t.of_match_table = qcom_ssphy_match,\n\t},\n};\nmodule_platform_driver(qcom_ssphy_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm SuperSpeed USB PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}