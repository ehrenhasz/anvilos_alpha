{
  "module_name": "phy-qcom-m31.c",
  "hash_id": "62775af09254cb6e1688f4aa82c01acb282bf584cebf689bfdf1edcf3f8eef0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-m31.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#define USB2PHY_PORT_UTMI_CTRL1\t\t0x40\n\n#define USB2PHY_PORT_UTMI_CTRL2\t\t0x44\n #define UTMI_ULPI_SEL\t\t\tBIT(7)\n #define UTMI_TEST_MUX_SEL\t\tBIT(6)\n\n#define HS_PHY_CTRL_REG\t\t\t0x10\n #define UTMI_OTG_VBUS_VALID\t\tBIT(20)\n #define SW_SESSVLD_SEL\t\t\tBIT(28)\n\n#define USB_PHY_UTMI_CTRL0\t\t0x3c\n\n#define USB_PHY_UTMI_CTRL5\t\t0x50\n #define POR_EN\t\t\t\tBIT(1)\n\n#define USB_PHY_HS_PHY_CTRL_COMMON0\t0x54\n #define COMMONONN\t\t\tBIT(7)\n #define FSEL\t\t\t\tBIT(4)\n #define RETENABLEN\t\t\tBIT(3)\n #define FREQ_24MHZ\t\t\t(BIT(6) | BIT(4))\n\n#define USB_PHY_HS_PHY_CTRL2\t\t0x64\n #define USB2_SUSPEND_N_SEL\t\tBIT(3)\n #define USB2_SUSPEND_N\t\t\tBIT(2)\n #define USB2_UTMI_CLK_EN\t\tBIT(1)\n\n#define USB_PHY_CFG0\t\t\t0x94\n #define UTMI_PHY_OVERRIDE_EN\t\tBIT(1)\n\n#define USB_PHY_REFCLK_CTRL\t\t0xa0\n #define CLKCORE\t\t\tBIT(1)\n\n#define USB2PHY_PORT_POWERDOWN\t\t0xa4\n #define POWER_UP\t\t\tBIT(0)\n #define POWER_DOWN\t\t\t0\n\n#define USB_PHY_FSEL_SEL\t\t0xb8\n #define FREQ_SEL\t\t\tBIT(0)\n\n#define USB2PHY_USB_PHY_M31_XCFGI_1\t0xbc\n #define USB2_0_TX_ENABLE\t\tBIT(2)\n\n#define USB2PHY_USB_PHY_M31_XCFGI_4\t0xc8\n #define HSTX_SLEW_RATE_565PS\t\tGENMASK(1, 0)\n #define PLL_CHARGING_PUMP_CURRENT_35UA\tGENMASK(4, 3)\n #define ODT_VALUE_38_02_OHM\t\tGENMASK(7, 6)\n\n#define USB2PHY_USB_PHY_M31_XCFGI_5\t0xcc\n #define ODT_VALUE_45_02_OHM\t\tBIT(2)\n #define HSTX_PRE_EMPHASIS_LEVEL_0_55MA\tBIT(0)\n\n#define USB2PHY_USB_PHY_M31_XCFGI_11\t0xe4\n #define XCFG_COARSE_TUNE_NUM\t\tBIT(1)\n #define XCFG_FINE_TUNE_NUM\t\tBIT(3)\n\nstruct m31_phy_regs {\n\tu32 off;\n\tu32 val;\n\tu32 delay;\n};\n\nstruct m31_priv_data {\n\tbool\t\t\t\tulpi_mode;\n\tconst struct m31_phy_regs\t*regs;\n\tunsigned int\t\t\tnregs;\n};\n\nstatic struct m31_phy_regs m31_ipq5332_regs[] = {\n\t{\n\t\tUSB_PHY_CFG0,\n\t\tUTMI_PHY_OVERRIDE_EN,\n\t\t0\n\t},\n\t{\n\t\tUSB_PHY_UTMI_CTRL5,\n\t\tPOR_EN,\n\t\t15\n\t},\n\t{\n\t\tUSB_PHY_FSEL_SEL,\n\t\tFREQ_SEL,\n\t\t0\n\t},\n\t{\n\t\tUSB_PHY_HS_PHY_CTRL_COMMON0,\n\t\tCOMMONONN | FREQ_24MHZ | RETENABLEN,\n\t\t0\n\t},\n\t{\n\t\tUSB_PHY_UTMI_CTRL5,\n\t\tPOR_EN,\n\t\t0\n\t},\n\t{\n\t\tUSB_PHY_HS_PHY_CTRL2,\n\t\tUSB2_SUSPEND_N_SEL | USB2_SUSPEND_N | USB2_UTMI_CLK_EN,\n\t\t0\n\t},\n\t{\n\t\tUSB2PHY_USB_PHY_M31_XCFGI_11,\n\t\tXCFG_COARSE_TUNE_NUM  | XCFG_FINE_TUNE_NUM,\n\t\t0\n\t},\n\t{\n\t\tUSB2PHY_USB_PHY_M31_XCFGI_4,\n\t\tHSTX_SLEW_RATE_565PS | PLL_CHARGING_PUMP_CURRENT_35UA | ODT_VALUE_38_02_OHM,\n\t\t0\n\t},\n\t{\n\t\tUSB2PHY_USB_PHY_M31_XCFGI_1,\n\t\tUSB2_0_TX_ENABLE,\n\t\t0\n\t},\n\t{\n\t\tUSB2PHY_USB_PHY_M31_XCFGI_5,\n\t\tODT_VALUE_45_02_OHM | HSTX_PRE_EMPHASIS_LEVEL_0_55MA,\n\t\t4\n\t},\n\t{\n\t\tUSB_PHY_UTMI_CTRL5,\n\t\t0x0,\n\t\t0\n\t},\n\t{\n\t\tUSB_PHY_HS_PHY_CTRL2,\n\t\tUSB2_SUSPEND_N | USB2_UTMI_CLK_EN,\n\t\t0\n\t},\n};\n\nstruct m31usb_phy {\n\tstruct phy\t\t\t*phy;\n\tvoid __iomem\t\t\t*base;\n\tconst struct m31_phy_regs\t*regs;\n\tint\t\t\t\tnregs;\n\n\tstruct regulator\t\t*vreg;\n\tstruct clk\t\t\t*clk;\n\tstruct reset_control\t\t*reset;\n\n\tbool\t\t\t\tulpi_mode;\n};\n\nstatic int m31usb_phy_init(struct phy *phy)\n{\n\tstruct m31usb_phy *qphy = phy_get_drvdata(phy);\n\tconst struct m31_phy_regs *regs = qphy->regs;\n\tint i, ret;\n\n\tret = regulator_enable(qphy->vreg);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"failed to enable regulator, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(qphy->clk);\n\tif (ret) {\n\t\tregulator_disable(qphy->vreg);\n\t\tdev_err(&phy->dev, \"failed to enable cfg ahb clock, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treset_control_assert(qphy->reset);\n\tudelay(5);\n\treset_control_deassert(qphy->reset);\n\n\t \n\tif (qphy->ulpi_mode)\n\t\twritel(0x0, qphy->base + USB2PHY_PORT_UTMI_CTRL2);\n\n\t \n\twritel(POWER_UP, qphy->base + USB2PHY_PORT_POWERDOWN);\n\n\t \n\tfor (i = 0; i < qphy->nregs; i++) {\n\t\twritel(regs[i].val, qphy->base + regs[i].off);\n\t\tif (regs[i].delay)\n\t\t\tudelay(regs[i].delay);\n\t}\n\n\treturn 0;\n}\n\nstatic int m31usb_phy_shutdown(struct phy *phy)\n{\n\tstruct m31usb_phy *qphy = phy_get_drvdata(phy);\n\n\t \n\twritel_relaxed(POWER_DOWN, qphy->base + USB2PHY_PORT_POWERDOWN);\n\n\tclk_disable_unprepare(qphy->clk);\n\n\tregulator_disable(qphy->vreg);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops m31usb_phy_gen_ops = {\n\t.power_on\t= m31usb_phy_init,\n\t.power_off\t= m31usb_phy_shutdown,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int m31usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tconst struct m31_priv_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct m31usb_phy *qphy;\n\n\tqphy = devm_kzalloc(dev, sizeof(*qphy), GFP_KERNEL);\n\tif (!qphy)\n\t\treturn -ENOMEM;\n\n\tqphy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qphy->base))\n\t\treturn PTR_ERR(qphy->base);\n\n\tqphy->reset = devm_reset_control_get_exclusive_by_index(dev, 0);\n\tif (IS_ERR(qphy->reset))\n\t\treturn PTR_ERR(qphy->reset);\n\n\tqphy->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(qphy->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(qphy->clk),\n\t\t\t\t\t\t\"failed to get clk\\n\");\n\n\tdata = of_device_get_match_data(dev);\n\tqphy->regs\t\t= data->regs;\n\tqphy->nregs\t\t= data->nregs;\n\tqphy->ulpi_mode\t\t= data->ulpi_mode;\n\n\tqphy->phy = devm_phy_create(dev, NULL, &m31usb_phy_gen_ops);\n\tif (IS_ERR(qphy->phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(qphy->phy),\n\t\t\t\t\t\t\"failed to create phy\\n\");\n\n\tqphy->vreg = devm_regulator_get(dev, \"vdda-phy\");\n\tif (IS_ERR(qphy->vreg))\n\t\treturn dev_err_probe(dev, PTR_ERR(qphy->vreg),\n\t\t\t\t\t\t\"failed to get vreg\\n\");\n\n\tphy_set_drvdata(qphy->phy, qphy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (!IS_ERR(phy_provider))\n\t\tdev_info(dev, \"Registered M31 USB phy\\n\");\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct m31_priv_data m31_ipq5332_data = {\n\t.ulpi_mode = false,\n\t.regs = m31_ipq5332_regs,\n\t.nregs = ARRAY_SIZE(m31_ipq5332_regs),\n};\n\nstatic const struct of_device_id m31usb_phy_id_table[] = {\n\t{ .compatible = \"qcom,ipq5332-usb-hsphy\", .data = &m31_ipq5332_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, m31usb_phy_id_table);\n\nstatic struct platform_driver m31usb_phy_driver = {\n\t.probe = m31usb_phy_probe,\n\t.driver = {\n\t\t.name = \"qcom-m31usb-phy\",\n\t\t.of_match_table = m31usb_phy_id_table,\n\t},\n};\n\nmodule_platform_driver(m31usb_phy_driver);\n\nMODULE_DESCRIPTION(\"USB2 Qualcomm M31 HSPHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}