{
  "module_name": "phy-qcom-usb-hs.c",
  "hash_id": "c7b727d7d392854187ba56647345c823e9a6bbc705d70f3762f17dd0b892ec2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-usb-hs.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/ulpi/driver.h>\n#include <linux/ulpi/regs.h>\n#include <linux/clk.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/reset.h>\n#include <linux/extcon.h>\n#include <linux/notifier.h>\n\n#define ULPI_PWR_CLK_MNG_REG\t\t0x88\n# define ULPI_PWR_OTG_COMP_DISABLE\tBIT(0)\n\n#define ULPI_MISC_A\t\t\t0x96\n# define ULPI_MISC_A_VBUSVLDEXTSEL\tBIT(1)\n# define ULPI_MISC_A_VBUSVLDEXT\t\tBIT(0)\n\n\nstruct ulpi_seq {\n\tu8 addr;\n\tu8 val;\n};\n\nstruct qcom_usb_hs_phy {\n\tstruct ulpi *ulpi;\n\tstruct phy *phy;\n\tstruct clk *ref_clk;\n\tstruct clk *sleep_clk;\n\tstruct regulator *v1p8;\n\tstruct regulator *v3p3;\n\tstruct reset_control *reset;\n\tstruct ulpi_seq *init_seq;\n\tstruct extcon_dev *vbus_edev;\n\tstruct notifier_block vbus_notify;\n};\n\nstatic int qcom_usb_hs_phy_set_mode(struct phy *phy,\n\t\t\t\t    enum phy_mode mode, int submode)\n{\n\tstruct qcom_usb_hs_phy *uphy = phy_get_drvdata(phy);\n\tu8 addr;\n\tint ret;\n\n\tif (!uphy->vbus_edev) {\n\t\tu8 val = 0;\n\n\t\tswitch (mode) {\n\t\tcase PHY_MODE_USB_OTG:\n\t\tcase PHY_MODE_USB_HOST:\n\t\t\tval |= ULPI_INT_IDGRD;\n\t\t\tfallthrough;\n\t\tcase PHY_MODE_USB_DEVICE:\n\t\t\tval |= ULPI_INT_SESS_VALID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ulpi_write(uphy->ulpi, ULPI_USB_INT_EN_RISE, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ulpi_write(uphy->ulpi, ULPI_USB_INT_EN_FALL, val);\n\t} else {\n\t\tswitch (mode) {\n\t\tcase PHY_MODE_USB_OTG:\n\t\tcase PHY_MODE_USB_DEVICE:\n\t\t\taddr = ULPI_SET(ULPI_MISC_A);\n\t\t\tbreak;\n\t\tcase PHY_MODE_USB_HOST:\n\t\t\taddr = ULPI_CLR(ULPI_MISC_A);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = ulpi_write(uphy->ulpi, ULPI_SET(ULPI_PWR_CLK_MNG_REG),\n\t\t\t\t ULPI_PWR_OTG_COMP_DISABLE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = ulpi_write(uphy->ulpi, addr, ULPI_MISC_A_VBUSVLDEXTSEL);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nqcom_usb_hs_phy_vbus_notifier(struct notifier_block *nb, unsigned long event,\n\t\t\t      void *ptr)\n{\n\tstruct qcom_usb_hs_phy *uphy;\n\tu8 addr;\n\n\tuphy = container_of(nb, struct qcom_usb_hs_phy, vbus_notify);\n\n\tif (event)\n\t\taddr = ULPI_SET(ULPI_MISC_A);\n\telse\n\t\taddr = ULPI_CLR(ULPI_MISC_A);\n\n\treturn ulpi_write(uphy->ulpi, addr, ULPI_MISC_A_VBUSVLDEXT);\n}\n\nstatic int qcom_usb_hs_phy_power_on(struct phy *phy)\n{\n\tstruct qcom_usb_hs_phy *uphy = phy_get_drvdata(phy);\n\tstruct ulpi *ulpi = uphy->ulpi;\n\tconst struct ulpi_seq *seq;\n\tint ret, state;\n\n\tret = clk_prepare_enable(uphy->ref_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(uphy->sleep_clk);\n\tif (ret)\n\t\tgoto err_sleep;\n\n\tret = regulator_set_load(uphy->v1p8, 50000);\n\tif (ret < 0)\n\t\tgoto err_1p8;\n\n\tret = regulator_enable(uphy->v1p8);\n\tif (ret)\n\t\tgoto err_1p8;\n\n\tret = regulator_set_voltage_triplet(uphy->v3p3, 3050000, 3300000,\n\t\t\t\t\t    3300000);\n\tif (ret)\n\t\tgoto err_3p3;\n\n\tret = regulator_set_load(uphy->v3p3, 50000);\n\tif (ret < 0)\n\t\tgoto err_3p3;\n\n\tret = regulator_enable(uphy->v3p3);\n\tif (ret)\n\t\tgoto err_3p3;\n\n\tfor (seq = uphy->init_seq; seq->addr; seq++) {\n\t\tret = ulpi_write(ulpi, ULPI_EXT_VENDOR_SPECIFIC + seq->addr,\n\t\t\t\t seq->val);\n\t\tif (ret)\n\t\t\tgoto err_ulpi;\n\t}\n\n\tif (uphy->reset) {\n\t\tret = reset_control_reset(uphy->reset);\n\t\tif (ret)\n\t\t\tgoto err_ulpi;\n\t}\n\n\tif (uphy->vbus_edev) {\n\t\tstate = extcon_get_state(uphy->vbus_edev, EXTCON_USB);\n\t\t \n\t\tqcom_usb_hs_phy_vbus_notifier(&uphy->vbus_notify, state,\n\t\t\t\t\t      uphy->vbus_edev);\n\t\tret = extcon_register_notifier(uphy->vbus_edev, EXTCON_USB,\n\t\t\t\t\t       &uphy->vbus_notify);\n\t\tif (ret)\n\t\t\tgoto err_ulpi;\n\t}\n\n\treturn 0;\nerr_ulpi:\n\tregulator_disable(uphy->v3p3);\nerr_3p3:\n\tregulator_disable(uphy->v1p8);\nerr_1p8:\n\tclk_disable_unprepare(uphy->sleep_clk);\nerr_sleep:\n\tclk_disable_unprepare(uphy->ref_clk);\n\treturn ret;\n}\n\nstatic int qcom_usb_hs_phy_power_off(struct phy *phy)\n{\n\tstruct qcom_usb_hs_phy *uphy = phy_get_drvdata(phy);\n\n\tif (uphy->vbus_edev)\n\t\textcon_unregister_notifier(uphy->vbus_edev, EXTCON_USB,\n\t\t\t\t\t   &uphy->vbus_notify);\n\tregulator_disable(uphy->v3p3);\n\tregulator_disable(uphy->v1p8);\n\tclk_disable_unprepare(uphy->sleep_clk);\n\tclk_disable_unprepare(uphy->ref_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops qcom_usb_hs_phy_ops = {\n\t.power_on = qcom_usb_hs_phy_power_on,\n\t.power_off = qcom_usb_hs_phy_power_off,\n\t.set_mode = qcom_usb_hs_phy_set_mode,\n\t.owner = THIS_MODULE,\n};\n\nstatic int qcom_usb_hs_phy_probe(struct ulpi *ulpi)\n{\n\tstruct qcom_usb_hs_phy *uphy;\n\tstruct phy_provider *p;\n\tstruct clk *clk;\n\tstruct regulator *reg;\n\tstruct reset_control *reset;\n\tint size;\n\tint ret;\n\n\tuphy = devm_kzalloc(&ulpi->dev, sizeof(*uphy), GFP_KERNEL);\n\tif (!uphy)\n\t\treturn -ENOMEM;\n\tulpi_set_drvdata(ulpi, uphy);\n\tuphy->ulpi = ulpi;\n\n\tsize = of_property_count_u8_elems(ulpi->dev.of_node, \"qcom,init-seq\");\n\tif (size < 0)\n\t\tsize = 0;\n\tuphy->init_seq = devm_kmalloc_array(&ulpi->dev, (size / 2) + 1,\n\t\t\t\t\t   sizeof(*uphy->init_seq), GFP_KERNEL);\n\tif (!uphy->init_seq)\n\t\treturn -ENOMEM;\n\tret = of_property_read_u8_array(ulpi->dev.of_node, \"qcom,init-seq\",\n\t\t\t\t\t(u8 *)uphy->init_seq, size);\n\tif (ret && size)\n\t\treturn ret;\n\t \n\tuphy->init_seq[size / 2].addr = uphy->init_seq[size / 2].val = 0;\n\n\tuphy->ref_clk = clk = devm_clk_get(&ulpi->dev, \"ref\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tuphy->sleep_clk = clk = devm_clk_get(&ulpi->dev, \"sleep\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tuphy->v1p8 = reg = devm_regulator_get(&ulpi->dev, \"v1p8\");\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tuphy->v3p3 = reg = devm_regulator_get(&ulpi->dev, \"v3p3\");\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tuphy->reset = reset = devm_reset_control_get(&ulpi->dev, \"por\");\n\tif (IS_ERR(reset)) {\n\t\tif (PTR_ERR(reset) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(reset);\n\t\tuphy->reset = NULL;\n\t}\n\n\tuphy->phy = devm_phy_create(&ulpi->dev, ulpi->dev.of_node,\n\t\t\t\t    &qcom_usb_hs_phy_ops);\n\tif (IS_ERR(uphy->phy))\n\t\treturn PTR_ERR(uphy->phy);\n\n\tuphy->vbus_edev = extcon_get_edev_by_phandle(&ulpi->dev, 0);\n\tif (IS_ERR(uphy->vbus_edev)) {\n\t\tif (PTR_ERR(uphy->vbus_edev) != -ENODEV)\n\t\t\treturn PTR_ERR(uphy->vbus_edev);\n\t\tuphy->vbus_edev = NULL;\n\t}\n\n\tuphy->vbus_notify.notifier_call = qcom_usb_hs_phy_vbus_notifier;\n\tphy_set_drvdata(uphy->phy, uphy);\n\n\tp = devm_of_phy_provider_register(&ulpi->dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(p);\n}\n\nstatic const struct of_device_id qcom_usb_hs_phy_match[] = {\n\t{ .compatible = \"qcom,usb-hs-phy\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_usb_hs_phy_match);\n\nstatic struct ulpi_driver qcom_usb_hs_phy_driver = {\n\t.probe = qcom_usb_hs_phy_probe,\n\t.driver = {\n\t\t.name = \"qcom_usb_hs_phy\",\n\t\t.of_match_table = qcom_usb_hs_phy_match,\n\t},\n};\nmodule_ulpi_driver(qcom_usb_hs_phy_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm USB HS phy\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}