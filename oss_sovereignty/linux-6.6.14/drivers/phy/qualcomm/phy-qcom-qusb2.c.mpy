{
  "module_name": "phy-qcom-qusb2.c",
  "hash_id": "0856729e6b892d16f9cbd6e69f5606a5363550b8f0849144cbe224154fb3227b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-qusb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/phy/phy-qcom-qusb2.h>\n\n#define QUSB2PHY_PLL\t\t\t0x0\n#define QUSB2PHY_PLL_TEST\t\t0x04\n#define CLK_REF_SEL\t\t\tBIT(7)\n\n#define QUSB2PHY_PLL_TUNE\t\t0x08\n#define QUSB2PHY_PLL_USER_CTL1\t\t0x0c\n#define QUSB2PHY_PLL_USER_CTL2\t\t0x10\n#define QUSB2PHY_PLL_AUTOPGM_CTL1\t0x1c\n#define QUSB2PHY_PLL_PWR_CTRL\t\t0x18\n\n \n#define PLL_LOCKED\t\t\tBIT(5)\n\n \n#define CORE_READY_STATUS\t\tBIT(0)\n\n \n#define CLAMP_N_EN\t\t\tBIT(5)\n#define FREEZIO_N\t\t\tBIT(1)\n#define POWER_DOWN\t\t\tBIT(0)\n\n \n#define PWR_CTRL1_VREF_SUPPLY_TRIM\tBIT(5)\n#define PWR_CTRL1_CLAMP_N_EN\t\tBIT(1)\n\n#define QUSB2PHY_REFCLK_ENABLE\t\tBIT(0)\n\n#define PHY_CLK_SCHEME_SEL\t\tBIT(0)\n\n \n#define DMSE_INTR_HIGH_SEL\t\t\tBIT(4)\n#define DPSE_INTR_HIGH_SEL\t\t\tBIT(3)\n#define CHG_DET_INTR_EN\t\t\t\tBIT(2)\n#define DMSE_INTR_EN\t\t\t\tBIT(1)\n#define DPSE_INTR_EN\t\t\t\tBIT(0)\n\n \n#define CORE_PLL_EN_FROM_RESET\t\t\tBIT(4)\n#define CORE_RESET\t\t\t\tBIT(5)\n#define CORE_RESET_MUX\t\t\t\tBIT(6)\n\n \n#define IMP_RES_OFFSET_MASK\t\t\tGENMASK(5, 0)\n#define IMP_RES_OFFSET_SHIFT\t\t\t0x0\n\n \n#define BIAS_CTRL2_RES_OFFSET_MASK\t\tGENMASK(5, 0)\n#define BIAS_CTRL2_RES_OFFSET_SHIFT\t\t0x0\n\n \n#define CHG_CTRL2_OFFSET_MASK\t\t\tGENMASK(5, 4)\n#define CHG_CTRL2_OFFSET_SHIFT\t\t\t0x4\n\n \n#define HSTX_TRIM_MASK\t\t\t\tGENMASK(7, 4)\n#define HSTX_TRIM_SHIFT\t\t\t\t0x4\n#define PREEMPH_WIDTH_HALF_BIT\t\t\tBIT(2)\n#define PREEMPHASIS_EN_MASK\t\t\tGENMASK(1, 0)\n#define PREEMPHASIS_EN_SHIFT\t\t\t0x0\n\n \n#define HSDISC_TRIM_MASK\t\t\tGENMASK(1, 0)\n#define HSDISC_TRIM_SHIFT\t\t\t0x0\n\n#define QUSB2PHY_PLL_ANALOG_CONTROLS_TWO\t0x04\n#define QUSB2PHY_PLL_CLOCK_INVERTERS\t\t0x18c\n#define QUSB2PHY_PLL_CMODE\t\t\t0x2c\n#define QUSB2PHY_PLL_LOCK_DELAY\t\t\t0x184\n#define QUSB2PHY_PLL_DIGITAL_TIMERS_TWO\t\t0xb4\n#define QUSB2PHY_PLL_BIAS_CONTROL_1\t\t0x194\n#define QUSB2PHY_PLL_BIAS_CONTROL_2\t\t0x198\n#define QUSB2PHY_PWR_CTRL2\t\t\t0x214\n#define QUSB2PHY_IMP_CTRL1\t\t\t0x220\n#define QUSB2PHY_IMP_CTRL2\t\t\t0x224\n#define QUSB2PHY_CHG_CTRL2\t\t\t0x23c\n\nstruct qusb2_phy_init_tbl {\n\tunsigned int offset;\n\tunsigned int val;\n\t \n\tint in_layout;\n};\n\n#define QUSB2_PHY_INIT_CFG(o, v) \\\n\t{\t\t\t\\\n\t\t.offset = o,\t\\\n\t\t.val = v,\t\\\n\t}\n\n#define QUSB2_PHY_INIT_CFG_L(o, v) \\\n\t{\t\t\t\\\n\t\t.offset = o,\t\\\n\t\t.val = v,\t\\\n\t\t.in_layout = 1,\t\\\n\t}\n\n \nenum qusb2phy_reg_layout {\n\tQUSB2PHY_PLL_CORE_INPUT_OVERRIDE,\n\tQUSB2PHY_PLL_STATUS,\n\tQUSB2PHY_PORT_TUNE1,\n\tQUSB2PHY_PORT_TUNE2,\n\tQUSB2PHY_PORT_TUNE3,\n\tQUSB2PHY_PORT_TUNE4,\n\tQUSB2PHY_PORT_TUNE5,\n\tQUSB2PHY_PORT_TEST1,\n\tQUSB2PHY_PORT_TEST2,\n\tQUSB2PHY_PORT_POWERDOWN,\n\tQUSB2PHY_INTR_CTRL,\n};\n\nstatic const struct qusb2_phy_init_tbl ipq6018_init_tbl[] = {\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL, 0x14),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE1, 0xF8),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE2, 0xB3),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE3, 0x83),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE4, 0xC0),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_TUNE, 0x30),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_USER_CTL1, 0x79),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_USER_CTL2, 0x21),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE5, 0x00),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_PWR_CTRL, 0x00),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TEST2, 0x14),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_TEST, 0x80),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_AUTOPGM_CTL1, 0x9F),\n};\n\nstatic const unsigned int ipq6018_regs_layout[] = {\n\t[QUSB2PHY_PLL_STATUS]              = 0x38,\n\t[QUSB2PHY_PORT_TUNE1]              = 0x80,\n\t[QUSB2PHY_PORT_TUNE2]              = 0x84,\n\t[QUSB2PHY_PORT_TUNE3]              = 0x88,\n\t[QUSB2PHY_PORT_TUNE4]              = 0x8C,\n\t[QUSB2PHY_PORT_TUNE5]              = 0x90,\n\t[QUSB2PHY_PORT_TEST1]              = 0x98,\n\t[QUSB2PHY_PORT_TEST2]              = 0x9C,\n\t[QUSB2PHY_PORT_POWERDOWN]          = 0xB4,\n\t[QUSB2PHY_INTR_CTRL]               = 0xBC,\n};\n\nstatic const unsigned int msm8996_regs_layout[] = {\n\t[QUSB2PHY_PLL_STATUS]\t\t= 0x38,\n\t[QUSB2PHY_PORT_TUNE1]\t\t= 0x80,\n\t[QUSB2PHY_PORT_TUNE2]\t\t= 0x84,\n\t[QUSB2PHY_PORT_TUNE3]\t\t= 0x88,\n\t[QUSB2PHY_PORT_TUNE4]\t\t= 0x8c,\n\t[QUSB2PHY_PORT_TUNE5]\t\t= 0x90,\n\t[QUSB2PHY_PORT_TEST1]\t\t= 0xb8,\n\t[QUSB2PHY_PORT_TEST2]\t\t= 0x9c,\n\t[QUSB2PHY_PORT_POWERDOWN]\t= 0xb4,\n\t[QUSB2PHY_INTR_CTRL]\t\t= 0xbc,\n};\n\nstatic const struct qusb2_phy_init_tbl msm8996_init_tbl[] = {\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE1, 0xf8),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE2, 0xb3),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE3, 0x83),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE4, 0xc0),\n\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_TUNE, 0x30),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_USER_CTL1, 0x79),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_USER_CTL2, 0x21),\n\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TEST2, 0x14),\n\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_AUTOPGM_CTL1, 0x9f),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_PWR_CTRL, 0x00),\n};\n\nstatic const unsigned int msm8998_regs_layout[] = {\n\t[QUSB2PHY_PLL_CORE_INPUT_OVERRIDE] = 0xa8,\n\t[QUSB2PHY_PLL_STATUS]              = 0x1a0,\n\t[QUSB2PHY_PORT_TUNE1]              = 0x23c,\n\t[QUSB2PHY_PORT_TUNE2]              = 0x240,\n\t[QUSB2PHY_PORT_TUNE3]              = 0x244,\n\t[QUSB2PHY_PORT_TUNE4]              = 0x248,\n\t[QUSB2PHY_PORT_TEST1]              = 0x24c,\n\t[QUSB2PHY_PORT_TEST2]              = 0x250,\n\t[QUSB2PHY_PORT_POWERDOWN]          = 0x210,\n\t[QUSB2PHY_INTR_CTRL]               = 0x22c,\n};\n\nstatic const struct qusb2_phy_init_tbl msm8998_init_tbl[] = {\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_ANALOG_CONTROLS_TWO, 0x13),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_CLOCK_INVERTERS, 0x7c),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_CMODE, 0x80),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_LOCK_DELAY, 0x0a),\n\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE1, 0xa5),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE2, 0x09),\n\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_DIGITAL_TIMERS_TWO, 0x19),\n};\n\nstatic const struct qusb2_phy_init_tbl sm6115_init_tbl[] = {\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE1, 0xf8),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE2, 0x53),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE3, 0x81),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE4, 0x17),\n\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_TUNE, 0x30),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_USER_CTL1, 0x79),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_USER_CTL2, 0x21),\n\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TEST2, 0x14),\n\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_AUTOPGM_CTL1, 0x9f),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_PWR_CTRL, 0x00),\n};\n\nstatic const unsigned int qusb2_v2_regs_layout[] = {\n\t[QUSB2PHY_PLL_CORE_INPUT_OVERRIDE] = 0xa8,\n\t[QUSB2PHY_PLL_STATUS]\t\t= 0x1a0,\n\t[QUSB2PHY_PORT_TUNE1]\t\t= 0x240,\n\t[QUSB2PHY_PORT_TUNE2]\t\t= 0x244,\n\t[QUSB2PHY_PORT_TUNE3]\t\t= 0x248,\n\t[QUSB2PHY_PORT_TUNE4]\t\t= 0x24c,\n\t[QUSB2PHY_PORT_TUNE5]\t\t= 0x250,\n\t[QUSB2PHY_PORT_TEST1]\t\t= 0x254,\n\t[QUSB2PHY_PORT_TEST2]\t\t= 0x258,\n\t[QUSB2PHY_PORT_POWERDOWN]\t= 0x210,\n\t[QUSB2PHY_INTR_CTRL]\t\t= 0x230,\n};\n\nstatic const struct qusb2_phy_init_tbl qusb2_v2_init_tbl[] = {\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_ANALOG_CONTROLS_TWO, 0x03),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_CLOCK_INVERTERS, 0x7c),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_CMODE, 0x80),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_LOCK_DELAY, 0x0a),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_DIGITAL_TIMERS_TWO, 0x19),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_BIAS_CONTROL_1, 0x40),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PLL_BIAS_CONTROL_2, 0x20),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_PWR_CTRL2, 0x21),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_IMP_CTRL1, 0x0),\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_IMP_CTRL2, 0x58),\n\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE1, 0x30),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE2, 0x29),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE3, 0xca),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE4, 0x04),\n\tQUSB2_PHY_INIT_CFG_L(QUSB2PHY_PORT_TUNE5, 0x03),\n\n\tQUSB2_PHY_INIT_CFG(QUSB2PHY_CHG_CTRL2, 0x0),\n};\n\nstruct qusb2_phy_cfg {\n\tconst struct qusb2_phy_init_tbl *tbl;\n\t \n\tunsigned int tbl_num;\n\t \n\tunsigned int clk_scheme_offset;\n\n\t \n\tconst unsigned int *regs;\n\tunsigned int mask_core_ready;\n\tunsigned int disable_ctrl;\n\tunsigned int autoresume_en;\n\n\t \n\tbool has_pll_test;\n\n\t \n\tbool update_tune1_with_efuse;\n\n\t \n\tbool has_pll_override;\n\n\t \n\tbool se_clk_scheme_default;\n};\n\nstatic const struct qusb2_phy_cfg msm8996_phy_cfg = {\n\t.tbl\t\t= msm8996_init_tbl,\n\t.tbl_num\t= ARRAY_SIZE(msm8996_init_tbl),\n\t.regs\t\t= msm8996_regs_layout,\n\n\t.has_pll_test\t= true,\n\t.se_clk_scheme_default = true,\n\t.disable_ctrl\t= (CLAMP_N_EN | FREEZIO_N | POWER_DOWN),\n\t.mask_core_ready = PLL_LOCKED,\n\t.autoresume_en\t = BIT(3),\n};\n\nstatic const struct qusb2_phy_cfg msm8998_phy_cfg = {\n\t.tbl            = msm8998_init_tbl,\n\t.tbl_num        = ARRAY_SIZE(msm8998_init_tbl),\n\t.regs           = msm8998_regs_layout,\n\n\t.disable_ctrl   = POWER_DOWN,\n\t.mask_core_ready = CORE_READY_STATUS,\n\t.has_pll_override = true,\n\t.se_clk_scheme_default = true,\n\t.autoresume_en   = BIT(0),\n\t.update_tune1_with_efuse = true,\n};\n\nstatic const struct qusb2_phy_cfg ipq6018_phy_cfg = {\n\t.tbl            = ipq6018_init_tbl,\n\t.tbl_num        = ARRAY_SIZE(ipq6018_init_tbl),\n\t.regs           = ipq6018_regs_layout,\n\n\t.disable_ctrl   = POWER_DOWN,\n\t.mask_core_ready = PLL_LOCKED,\n\t \n\t.autoresume_en   = BIT(0),\n};\n\nstatic const struct qusb2_phy_cfg qusb2_v2_phy_cfg = {\n\t.tbl\t\t= qusb2_v2_init_tbl,\n\t.tbl_num\t= ARRAY_SIZE(qusb2_v2_init_tbl),\n\t.regs\t\t= qusb2_v2_regs_layout,\n\n\t.disable_ctrl\t= (PWR_CTRL1_VREF_SUPPLY_TRIM | PWR_CTRL1_CLAMP_N_EN |\n\t\t\t   POWER_DOWN),\n\t.mask_core_ready = CORE_READY_STATUS,\n\t.has_pll_override = true,\n\t.se_clk_scheme_default = true,\n\t.autoresume_en\t  = BIT(0),\n\t.update_tune1_with_efuse = true,\n};\n\nstatic const struct qusb2_phy_cfg sdm660_phy_cfg = {\n\t.tbl\t\t= msm8996_init_tbl,\n\t.tbl_num\t= ARRAY_SIZE(msm8996_init_tbl),\n\t.regs\t\t= msm8996_regs_layout,\n\n\t.has_pll_test\t= true,\n\t.se_clk_scheme_default = false,\n\t.disable_ctrl\t= (CLAMP_N_EN | FREEZIO_N | POWER_DOWN),\n\t.mask_core_ready = PLL_LOCKED,\n\t.autoresume_en\t = BIT(3),\n};\n\nstatic const struct qusb2_phy_cfg sm6115_phy_cfg = {\n\t.tbl\t\t= sm6115_init_tbl,\n\t.tbl_num\t= ARRAY_SIZE(sm6115_init_tbl),\n\t.regs\t\t= msm8996_regs_layout,\n\n\t.has_pll_test\t= true,\n\t.se_clk_scheme_default = true,\n\t.disable_ctrl\t= (CLAMP_N_EN | FREEZIO_N | POWER_DOWN),\n\t.mask_core_ready = PLL_LOCKED,\n\t.autoresume_en\t = BIT(3),\n};\n\nstatic const char * const qusb2_phy_vreg_names[] = {\n\t\"vdd\", \"vdda-pll\", \"vdda-phy-dpdm\",\n};\n\n#define QUSB2_NUM_VREGS\t\tARRAY_SIZE(qusb2_phy_vreg_names)\n\n \nstruct override_param {\n\tbool override;\n\tu8 value;\n};\n\n \nstruct override_params {\n\tstruct override_param imp_res_offset;\n\tstruct override_param hstx_trim;\n\tstruct override_param preemphasis;\n\tstruct override_param preemphasis_width;\n\tstruct override_param bias_ctrl;\n\tstruct override_param charge_ctrl;\n\tstruct override_param hsdisc_trim;\n};\n\n \nstruct qusb2_phy {\n\tstruct phy *phy;\n\tvoid __iomem *base;\n\n\tstruct clk *cfg_ahb_clk;\n\tstruct clk *ref_clk;\n\tstruct clk *iface_clk;\n\tstruct reset_control *phy_reset;\n\tstruct regulator_bulk_data vregs[QUSB2_NUM_VREGS];\n\n\tstruct regmap *tcsr;\n\tstruct nvmem_cell *cell;\n\n\tstruct override_params overrides;\n\n\tconst struct qusb2_phy_cfg *cfg;\n\tbool has_se_clk_scheme;\n\tbool phy_initialized;\n\tenum phy_mode mode;\n};\n\nstatic inline void qusb2_write_mask(void __iomem *base, u32 offset,\n\t\t\t\t    u32 val, u32 mask)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg &= ~mask;\n\treg |= val & mask;\n\twritel(reg, base + offset);\n\n\t \n\treadl(base + offset);\n}\n\nstatic inline void qusb2_setbits(void __iomem *base, u32 offset, u32 val)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg |= val;\n\twritel(reg, base + offset);\n\n\t \n\treadl(base + offset);\n}\n\nstatic inline void qusb2_clrbits(void __iomem *base, u32 offset, u32 val)\n{\n\tu32 reg;\n\n\treg = readl(base + offset);\n\treg &= ~val;\n\twritel(reg, base + offset);\n\n\t \n\treadl(base + offset);\n}\n\nstatic inline\nvoid qcom_qusb2_phy_configure(void __iomem *base,\n\t\t\t      const unsigned int *regs,\n\t\t\t      const struct qusb2_phy_init_tbl tbl[], int num)\n{\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (tbl[i].in_layout)\n\t\t\twritel(tbl[i].val, base + regs[tbl[i].offset]);\n\t\telse\n\t\t\twritel(tbl[i].val, base + tbl[i].offset);\n\t}\n}\n\n \nstatic void qusb2_phy_override_phy_params(struct qusb2_phy *qphy)\n{\n\tconst struct qusb2_phy_cfg *cfg = qphy->cfg;\n\tstruct override_params *or = &qphy->overrides;\n\n\tif (or->imp_res_offset.override)\n\t\tqusb2_write_mask(qphy->base, QUSB2PHY_IMP_CTRL1,\n\t\tor->imp_res_offset.value << IMP_RES_OFFSET_SHIFT,\n\t\t\t     IMP_RES_OFFSET_MASK);\n\n\tif (or->bias_ctrl.override)\n\t\tqusb2_write_mask(qphy->base, QUSB2PHY_PLL_BIAS_CONTROL_2,\n\t\tor->bias_ctrl.value << BIAS_CTRL2_RES_OFFSET_SHIFT,\n\t\t\t   BIAS_CTRL2_RES_OFFSET_MASK);\n\n\tif (or->charge_ctrl.override)\n\t\tqusb2_write_mask(qphy->base, QUSB2PHY_CHG_CTRL2,\n\t\tor->charge_ctrl.value << CHG_CTRL2_OFFSET_SHIFT,\n\t\t\t     CHG_CTRL2_OFFSET_MASK);\n\n\tif (or->hstx_trim.override)\n\t\tqusb2_write_mask(qphy->base, cfg->regs[QUSB2PHY_PORT_TUNE1],\n\t\tor->hstx_trim.value << HSTX_TRIM_SHIFT,\n\t\t\t\t HSTX_TRIM_MASK);\n\n\tif (or->preemphasis.override)\n\t\tqusb2_write_mask(qphy->base, cfg->regs[QUSB2PHY_PORT_TUNE1],\n\t\tor->preemphasis.value << PREEMPHASIS_EN_SHIFT,\n\t\t\t\tPREEMPHASIS_EN_MASK);\n\n\tif (or->preemphasis_width.override) {\n\t\tif (or->preemphasis_width.value ==\n\t\t    QUSB2_V2_PREEMPHASIS_WIDTH_HALF_BIT)\n\t\t\tqusb2_setbits(qphy->base,\n\t\t\t\t      cfg->regs[QUSB2PHY_PORT_TUNE1],\n\t\t\t\t      PREEMPH_WIDTH_HALF_BIT);\n\t\telse\n\t\t\tqusb2_clrbits(qphy->base,\n\t\t\t\t      cfg->regs[QUSB2PHY_PORT_TUNE1],\n\t\t\t\t      PREEMPH_WIDTH_HALF_BIT);\n\t}\n\n\tif (or->hsdisc_trim.override)\n\t\tqusb2_write_mask(qphy->base, cfg->regs[QUSB2PHY_PORT_TUNE2],\n\t\tor->hsdisc_trim.value << HSDISC_TRIM_SHIFT,\n\t\t\t\t HSDISC_TRIM_MASK);\n}\n\n \nstatic void qusb2_phy_set_tune2_param(struct qusb2_phy *qphy)\n{\n\tstruct device *dev = &qphy->phy->dev;\n\tconst struct qusb2_phy_cfg *cfg = qphy->cfg;\n\tu8 *val, hstx_trim;\n\n\t \n\tif (!qphy->cell)\n\t\treturn;\n\n\t \n\tval = nvmem_cell_read(qphy->cell, NULL);\n\tif (IS_ERR(val)) {\n\t\tdev_dbg(dev, \"failed to read a valid hs-tx trim value\\n\");\n\t\treturn;\n\t}\n\thstx_trim = val[0];\n\tkfree(val);\n\tif (!hstx_trim) {\n\t\tdev_dbg(dev, \"failed to read a valid hs-tx trim value\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (cfg->update_tune1_with_efuse)\n\t\tqusb2_write_mask(qphy->base, cfg->regs[QUSB2PHY_PORT_TUNE1],\n\t\t\t\t hstx_trim << HSTX_TRIM_SHIFT, HSTX_TRIM_MASK);\n\telse\n\t\tqusb2_write_mask(qphy->base, cfg->regs[QUSB2PHY_PORT_TUNE2],\n\t\t\t\t hstx_trim << HSTX_TRIM_SHIFT, HSTX_TRIM_MASK);\n}\n\nstatic int qusb2_phy_set_mode(struct phy *phy,\n\t\t\t      enum phy_mode mode, int submode)\n{\n\tstruct qusb2_phy *qphy = phy_get_drvdata(phy);\n\n\tqphy->mode = mode;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused qusb2_phy_runtime_suspend(struct device *dev)\n{\n\tstruct qusb2_phy *qphy = dev_get_drvdata(dev);\n\tconst struct qusb2_phy_cfg *cfg = qphy->cfg;\n\tu32 intr_mask;\n\n\tdev_vdbg(dev, \"Suspending QUSB2 Phy, mode:%d\\n\", qphy->mode);\n\n\tif (!qphy->phy_initialized) {\n\t\tdev_vdbg(dev, \"PHY not initialized, bailing out\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tintr_mask = DPSE_INTR_EN | DMSE_INTR_EN;\n\tswitch (qphy->mode) {\n\tcase PHY_MODE_USB_HOST_HS:\n\tcase PHY_MODE_USB_HOST_FS:\n\tcase PHY_MODE_USB_DEVICE_HS:\n\tcase PHY_MODE_USB_DEVICE_FS:\n\t\tintr_mask |= DMSE_INTR_HIGH_SEL;\n\t\tbreak;\n\tcase PHY_MODE_USB_HOST_LS:\n\tcase PHY_MODE_USB_DEVICE_LS:\n\t\tintr_mask |= DPSE_INTR_HIGH_SEL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tintr_mask |= DMSE_INTR_HIGH_SEL;\n\t\tintr_mask |= DPSE_INTR_HIGH_SEL;\n\t\tbreak;\n\t}\n\n\twritel(intr_mask, qphy->base + cfg->regs[QUSB2PHY_INTR_CTRL]);\n\n\t \n\tif (cfg->has_pll_override) {\n\t\tqusb2_setbits(qphy->base,\n\t\t\t      cfg->regs[QUSB2PHY_PLL_CORE_INPUT_OVERRIDE],\n\t\t\t      CORE_PLL_EN_FROM_RESET | CORE_RESET |\n\t\t\t      CORE_RESET_MUX);\n\t}\n\n\t \n\tif (qphy->mode != PHY_MODE_INVALID) {\n\t\tqusb2_setbits(qphy->base, cfg->regs[QUSB2PHY_PORT_TEST1],\n\t\t\t      cfg->autoresume_en);\n\t\t \n\t\tqusb2_clrbits(qphy->base, cfg->regs[QUSB2PHY_PORT_TEST1],\n\t\t\t      cfg->autoresume_en);\n\t}\n\n\tif (!qphy->has_se_clk_scheme)\n\t\tclk_disable_unprepare(qphy->ref_clk);\n\n\tclk_disable_unprepare(qphy->cfg_ahb_clk);\n\tclk_disable_unprepare(qphy->iface_clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused qusb2_phy_runtime_resume(struct device *dev)\n{\n\tstruct qusb2_phy *qphy = dev_get_drvdata(dev);\n\tconst struct qusb2_phy_cfg *cfg = qphy->cfg;\n\tint ret;\n\n\tdev_vdbg(dev, \"Resuming QUSB2 phy, mode:%d\\n\", qphy->mode);\n\n\tif (!qphy->phy_initialized) {\n\t\tdev_vdbg(dev, \"PHY not initialized, bailing out\\n\");\n\t\treturn 0;\n\t}\n\n\tret = clk_prepare_enable(qphy->iface_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable iface_clk, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(qphy->cfg_ahb_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable cfg ahb clock, %d\\n\", ret);\n\t\tgoto disable_iface_clk;\n\t}\n\n\tif (!qphy->has_se_clk_scheme) {\n\t\tret = clk_prepare_enable(qphy->ref_clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable ref clk, %d\\n\", ret);\n\t\t\tgoto disable_ahb_clk;\n\t\t}\n\t}\n\n\twritel(0x0, qphy->base + cfg->regs[QUSB2PHY_INTR_CTRL]);\n\n\t \n\tif (cfg->has_pll_override) {\n\t\tqusb2_clrbits(qphy->base,\n\t\t\t      cfg->regs[QUSB2PHY_PLL_CORE_INPUT_OVERRIDE],\n\t\t\t      CORE_RESET | CORE_RESET_MUX);\n\t}\n\n\treturn 0;\n\ndisable_ahb_clk:\n\tclk_disable_unprepare(qphy->cfg_ahb_clk);\ndisable_iface_clk:\n\tclk_disable_unprepare(qphy->iface_clk);\n\n\treturn ret;\n}\n\nstatic int qusb2_phy_init(struct phy *phy)\n{\n\tstruct qusb2_phy *qphy = phy_get_drvdata(phy);\n\tconst struct qusb2_phy_cfg *cfg = qphy->cfg;\n\tunsigned int val = 0;\n\tunsigned int clk_scheme;\n\tint ret;\n\n\tdev_vdbg(&phy->dev, \"%s(): Initializing QUSB2 phy\\n\", __func__);\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(qphy->vregs), qphy->vregs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(qphy->iface_clk);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"failed to enable iface_clk, %d\\n\", ret);\n\t\tgoto poweroff_phy;\n\t}\n\n\t \n\tret = clk_prepare_enable(qphy->cfg_ahb_clk);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"failed to enable cfg ahb clock, %d\\n\", ret);\n\t\tgoto disable_iface_clk;\n\t}\n\n\t \n\tret = reset_control_assert(qphy->phy_reset);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"failed to assert phy_reset, %d\\n\", ret);\n\t\tgoto disable_ahb_clk;\n\t}\n\n\t \n\tusleep_range(100, 150);\n\n\tret = reset_control_deassert(qphy->phy_reset);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"failed to de-assert phy_reset, %d\\n\", ret);\n\t\tgoto disable_ahb_clk;\n\t}\n\n\t \n\tqusb2_setbits(qphy->base, cfg->regs[QUSB2PHY_PORT_POWERDOWN],\n\t\t      qphy->cfg->disable_ctrl);\n\n\tif (cfg->has_pll_test) {\n\t\t \n\t\tval = readl(qphy->base + QUSB2PHY_PLL_TEST);\n\t}\n\n\tqcom_qusb2_phy_configure(qphy->base, cfg->regs, cfg->tbl,\n\t\t\t\t cfg->tbl_num);\n\n\t \n\tqusb2_phy_override_phy_params(qphy);\n\n\t \n\tqusb2_phy_set_tune2_param(qphy);\n\n\t \n\tqusb2_clrbits(qphy->base, cfg->regs[QUSB2PHY_PORT_POWERDOWN],\n\t\t      POWER_DOWN);\n\n\t \n\tusleep_range(150, 160);\n\n\t \n\tqphy->has_se_clk_scheme = cfg->se_clk_scheme_default;\n\n\t \n\tif (qphy->tcsr) {\n\t\tret = regmap_read(qphy->tcsr, qphy->cfg->clk_scheme_offset,\n\t\t\t\t  &clk_scheme);\n\t\tif (ret) {\n\t\t\tdev_err(&phy->dev, \"failed to read clk scheme reg\\n\");\n\t\t\tgoto assert_phy_reset;\n\t\t}\n\n\t\t \n\t\tif (!(clk_scheme & PHY_CLK_SCHEME_SEL)) {\n\t\t\tdev_vdbg(&phy->dev, \"%s(): select differential clk\\n\",\n\t\t\t\t __func__);\n\t\t\tqphy->has_se_clk_scheme = false;\n\t\t} else {\n\t\t\tdev_vdbg(&phy->dev, \"%s(): select single-ended clk\\n\",\n\t\t\t\t __func__);\n\t\t}\n\t}\n\n\tif (!qphy->has_se_clk_scheme) {\n\t\tret = clk_prepare_enable(qphy->ref_clk);\n\t\tif (ret) {\n\t\t\tdev_err(&phy->dev, \"failed to enable ref clk, %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto assert_phy_reset;\n\t\t}\n\t}\n\n\tif (cfg->has_pll_test) {\n\t\tif (!qphy->has_se_clk_scheme)\n\t\t\tval &= ~CLK_REF_SEL;\n\t\telse\n\t\t\tval |= CLK_REF_SEL;\n\n\t\twritel(val, qphy->base + QUSB2PHY_PLL_TEST);\n\n\t\t \n\t\treadl(qphy->base + QUSB2PHY_PLL_TEST);\n\t}\n\n\t \n\tusleep_range(100, 110);\n\n\tval = readb(qphy->base + cfg->regs[QUSB2PHY_PLL_STATUS]);\n\tif (!(val & cfg->mask_core_ready)) {\n\t\tdev_err(&phy->dev,\n\t\t\t\"QUSB2PHY pll lock failed: status reg = %x\\n\", val);\n\t\tret = -EBUSY;\n\t\tgoto disable_ref_clk;\n\t}\n\tqphy->phy_initialized = true;\n\n\treturn 0;\n\ndisable_ref_clk:\n\tif (!qphy->has_se_clk_scheme)\n\t\tclk_disable_unprepare(qphy->ref_clk);\nassert_phy_reset:\n\treset_control_assert(qphy->phy_reset);\ndisable_ahb_clk:\n\tclk_disable_unprepare(qphy->cfg_ahb_clk);\ndisable_iface_clk:\n\tclk_disable_unprepare(qphy->iface_clk);\npoweroff_phy:\n\tregulator_bulk_disable(ARRAY_SIZE(qphy->vregs), qphy->vregs);\n\n\treturn ret;\n}\n\nstatic int qusb2_phy_exit(struct phy *phy)\n{\n\tstruct qusb2_phy *qphy = phy_get_drvdata(phy);\n\n\t \n\tqusb2_setbits(qphy->base, qphy->cfg->regs[QUSB2PHY_PORT_POWERDOWN],\n\t\t      qphy->cfg->disable_ctrl);\n\n\tif (!qphy->has_se_clk_scheme)\n\t\tclk_disable_unprepare(qphy->ref_clk);\n\n\treset_control_assert(qphy->phy_reset);\n\n\tclk_disable_unprepare(qphy->cfg_ahb_clk);\n\tclk_disable_unprepare(qphy->iface_clk);\n\n\tregulator_bulk_disable(ARRAY_SIZE(qphy->vregs), qphy->vregs);\n\n\tqphy->phy_initialized = false;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops qusb2_phy_gen_ops = {\n\t.init\t\t= qusb2_phy_init,\n\t.exit\t\t= qusb2_phy_exit,\n\t.set_mode\t= qusb2_phy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id qusb2_phy_of_match_table[] = {\n\t{\n\t\t.compatible\t= \"qcom,ipq6018-qusb2-phy\",\n\t\t.data\t\t= &ipq6018_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,ipq8074-qusb2-phy\",\n\t\t.data\t\t= &msm8996_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,ipq9574-qusb2-phy\",\n\t\t.data\t\t= &ipq6018_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,msm8953-qusb2-phy\",\n\t\t.data\t\t= &msm8996_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,msm8996-qusb2-phy\",\n\t\t.data\t\t= &msm8996_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,msm8998-qusb2-phy\",\n\t\t.data\t\t= &msm8998_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,qcm2290-qusb2-phy\",\n\t\t.data\t\t= &sm6115_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,sdm660-qusb2-phy\",\n\t\t.data\t\t= &sdm660_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,sm4250-qusb2-phy\",\n\t\t.data\t\t= &sm6115_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,sm6115-qusb2-phy\",\n\t\t.data\t\t= &sm6115_phy_cfg,\n\t}, {\n\t\t \n\t\t.compatible\t= \"qcom,sdm845-qusb2-phy\",\n\t\t.data\t\t= &qusb2_v2_phy_cfg,\n\t}, {\n\t\t.compatible\t= \"qcom,qusb2-v2-phy\",\n\t\t.data\t\t= &qusb2_v2_phy_cfg,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qusb2_phy_of_match_table);\n\nstatic const struct dev_pm_ops qusb2_phy_pm_ops = {\n\tSET_RUNTIME_PM_OPS(qusb2_phy_runtime_suspend,\n\t\t\t   qusb2_phy_runtime_resume, NULL)\n};\n\nstatic int qusb2_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct qusb2_phy *qphy;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *generic_phy;\n\tint ret, i;\n\tint num;\n\tu32 value;\n\tstruct override_params *or;\n\n\tqphy = devm_kzalloc(dev, sizeof(*qphy), GFP_KERNEL);\n\tif (!qphy)\n\t\treturn -ENOMEM;\n\tor = &qphy->overrides;\n\n\tqphy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qphy->base))\n\t\treturn PTR_ERR(qphy->base);\n\n\tqphy->cfg_ahb_clk = devm_clk_get(dev, \"cfg_ahb\");\n\tif (IS_ERR(qphy->cfg_ahb_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(qphy->cfg_ahb_clk),\n\t\t\t\t     \"failed to get cfg ahb clk\\n\");\n\n\tqphy->ref_clk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(qphy->ref_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(qphy->ref_clk),\n\t\t\t\t     \"failed to get ref clk\\n\");\n\n\tqphy->iface_clk = devm_clk_get_optional(dev, \"iface\");\n\tif (IS_ERR(qphy->iface_clk))\n\t\treturn PTR_ERR(qphy->iface_clk);\n\n\tqphy->phy_reset = devm_reset_control_get_by_index(&pdev->dev, 0);\n\tif (IS_ERR(qphy->phy_reset)) {\n\t\tdev_err(dev, \"failed to get phy core reset\\n\");\n\t\treturn PTR_ERR(qphy->phy_reset);\n\t}\n\n\tnum = ARRAY_SIZE(qphy->vregs);\n\tfor (i = 0; i < num; i++)\n\t\tqphy->vregs[i].supply = qusb2_phy_vreg_names[i];\n\n\tret = devm_regulator_bulk_get(dev, num, qphy->vregs);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to get regulator supplies\\n\");\n\n\t \n\tqphy->cfg = of_device_get_match_data(dev);\n\n\tqphy->tcsr = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"qcom,tcsr-syscon\");\n\tif (IS_ERR(qphy->tcsr)) {\n\t\tdev_dbg(dev, \"failed to lookup TCSR regmap\\n\");\n\t\tqphy->tcsr = NULL;\n\t}\n\n\tqphy->cell = devm_nvmem_cell_get(dev, NULL);\n\tif (IS_ERR(qphy->cell)) {\n\t\tif (PTR_ERR(qphy->cell) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tqphy->cell = NULL;\n\t\tdev_dbg(dev, \"failed to lookup tune2 hstx trim value\\n\");\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"qcom,imp-res-offset-value\",\n\t\t\t\t  &value)) {\n\t\tor->imp_res_offset.value = (u8)value;\n\t\tor->imp_res_offset.override = true;\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"qcom,bias-ctrl-value\",\n\t\t\t\t  &value)) {\n\t\tor->bias_ctrl.value = (u8)value;\n\t\tor->bias_ctrl.override = true;\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"qcom,charge-ctrl-value\",\n\t\t\t\t  &value)) {\n\t\tor->charge_ctrl.value = (u8)value;\n\t\tor->charge_ctrl.override = true;\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"qcom,hstx-trim-value\",\n\t\t\t\t  &value)) {\n\t\tor->hstx_trim.value = (u8)value;\n\t\tor->hstx_trim.override = true;\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"qcom,preemphasis-level\",\n\t\t\t\t     &value)) {\n\t\tor->preemphasis.value = (u8)value;\n\t\tor->preemphasis.override = true;\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"qcom,preemphasis-width\",\n\t\t\t\t     &value)) {\n\t\tor->preemphasis_width.value = (u8)value;\n\t\tor->preemphasis_width.override = true;\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"qcom,hsdisc-trim-value\",\n\t\t\t\t  &value)) {\n\t\tor->hsdisc_trim.value = (u8)value;\n\t\tor->hsdisc_trim.override = true;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\t \n\tpm_runtime_forbid(dev);\n\n\tgeneric_phy = devm_phy_create(dev, NULL, &qusb2_phy_gen_ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tret = PTR_ERR(generic_phy);\n\t\tdev_err(dev, \"failed to create phy, %d\\n\", ret);\n\t\tpm_runtime_disable(dev);\n\t\treturn ret;\n\t}\n\tqphy->phy = generic_phy;\n\n\tdev_set_drvdata(dev, qphy);\n\tphy_set_drvdata(generic_phy, qphy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (!IS_ERR(phy_provider))\n\t\tdev_info(dev, \"Registered Qcom-QUSB2 phy\\n\");\n\telse\n\t\tpm_runtime_disable(dev);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver qusb2_phy_driver = {\n\t.probe\t\t= qusb2_phy_probe,\n\t.driver = {\n\t\t.name\t= \"qcom-qusb2-phy\",\n\t\t.pm\t= &qusb2_phy_pm_ops,\n\t\t.of_match_table = qusb2_phy_of_match_table,\n\t},\n};\n\nmodule_platform_driver(qusb2_phy_driver);\n\nMODULE_AUTHOR(\"Vivek Gautam <vivek.gautam@codeaurora.org>\");\nMODULE_DESCRIPTION(\"Qualcomm QUSB2 PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}