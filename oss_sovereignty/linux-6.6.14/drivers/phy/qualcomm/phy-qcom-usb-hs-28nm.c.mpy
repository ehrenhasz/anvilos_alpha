{
  "module_name": "phy-qcom-usb-hs-28nm.c",
  "hash_id": "8190b740f2db28c6cbb24cc633c3c9d7aed2e962594270a12b9e1253eede18b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-usb-hs-28nm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n \n#define PHY_CTRL_COMMON0\t\t0x078\n#define SIDDQ\t\t\t\tBIT(2)\n#define PHY_IRQ_CMD\t\t\t0x0d0\n#define PHY_INTR_MASK0\t\t\t0x0d4\n#define PHY_INTR_CLEAR0\t\t\t0x0dc\n#define DPDM_MASK\t\t\t0x1e\n#define DP_1_0\t\t\t\tBIT(4)\n#define DP_0_1\t\t\t\tBIT(3)\n#define DM_1_0\t\t\t\tBIT(2)\n#define DM_0_1\t\t\t\tBIT(1)\n\nenum hsphy_voltage {\n\tVOL_NONE,\n\tVOL_MIN,\n\tVOL_MAX,\n\tVOL_NUM,\n};\n\nenum hsphy_vreg {\n\tVDD,\n\tVDDA_1P8,\n\tVDDA_3P3,\n\tVREG_NUM,\n};\n\nstruct hsphy_init_seq {\n\tint offset;\n\tint val;\n\tint delay;\n};\n\nstruct hsphy_data {\n\tconst struct hsphy_init_seq *init_seq;\n\tunsigned int init_seq_num;\n};\n\nstruct hsphy_priv {\n\tvoid __iomem *base;\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\tstruct reset_control *phy_reset;\n\tstruct reset_control *por_reset;\n\tstruct regulator_bulk_data vregs[VREG_NUM];\n\tconst struct hsphy_data *data;\n\tenum phy_mode mode;\n};\n\nstatic int qcom_snps_hsphy_set_mode(struct phy *phy, enum phy_mode mode,\n\t\t\t\t    int submode)\n{\n\tstruct hsphy_priv *priv = phy_get_drvdata(phy);\n\n\tpriv->mode = PHY_MODE_INVALID;\n\n\tif (mode > 0)\n\t\tpriv->mode = mode;\n\n\treturn 0;\n}\n\nstatic void qcom_snps_hsphy_enable_hv_interrupts(struct hsphy_priv *priv)\n{\n\tu32 val;\n\n\t \n\tval = readb(priv->base + PHY_INTR_CLEAR0);\n\tval |= DPDM_MASK;\n\twriteb(val, priv->base + PHY_INTR_CLEAR0);\n\n\twriteb(0x0, priv->base + PHY_IRQ_CMD);\n\tusleep_range(200, 220);\n\twriteb(0x1, priv->base + PHY_IRQ_CMD);\n\n\t \n\tusleep_range(200, 220);\n\n\tval = readb(priv->base + PHY_INTR_MASK0);\n\tswitch (priv->mode) {\n\tcase PHY_MODE_USB_HOST_HS:\n\tcase PHY_MODE_USB_HOST_FS:\n\tcase PHY_MODE_USB_DEVICE_HS:\n\tcase PHY_MODE_USB_DEVICE_FS:\n\t\tval |= DP_1_0 | DM_0_1;\n\t\tbreak;\n\tcase PHY_MODE_USB_HOST_LS:\n\tcase PHY_MODE_USB_DEVICE_LS:\n\t\tval |= DP_0_1 | DM_1_0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tval |= DP_0_1 | DM_0_1;\n\t\tbreak;\n\t}\n\twriteb(val, priv->base + PHY_INTR_MASK0);\n}\n\nstatic void qcom_snps_hsphy_disable_hv_interrupts(struct hsphy_priv *priv)\n{\n\tu32 val;\n\n\tval = readb(priv->base + PHY_INTR_MASK0);\n\tval &= ~DPDM_MASK;\n\twriteb(val, priv->base + PHY_INTR_MASK0);\n\n\t \n\tval = readb(priv->base + PHY_INTR_CLEAR0);\n\tval |= DPDM_MASK;\n\twriteb(val, priv->base + PHY_INTR_CLEAR0);\n\n\twriteb(0x0, priv->base + PHY_IRQ_CMD);\n\tusleep_range(200, 220);\n\n\twriteb(0x1, priv->base + PHY_IRQ_CMD);\n\tusleep_range(200, 220);\n}\n\nstatic void qcom_snps_hsphy_enter_retention(struct hsphy_priv *priv)\n{\n\tu32 val;\n\n\tval = readb(priv->base + PHY_CTRL_COMMON0);\n\tval |= SIDDQ;\n\twriteb(val, priv->base + PHY_CTRL_COMMON0);\n}\n\nstatic void qcom_snps_hsphy_exit_retention(struct hsphy_priv *priv)\n{\n\tu32 val;\n\n\tval = readb(priv->base + PHY_CTRL_COMMON0);\n\tval &= ~SIDDQ;\n\twriteb(val, priv->base + PHY_CTRL_COMMON0);\n}\n\nstatic int qcom_snps_hsphy_power_on(struct phy *phy)\n{\n\tstruct hsphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = regulator_bulk_enable(VREG_NUM, priv->vregs);\n\tif (ret)\n\t\treturn ret;\n\n\tqcom_snps_hsphy_disable_hv_interrupts(priv);\n\tqcom_snps_hsphy_exit_retention(priv);\n\n\treturn 0;\n}\n\nstatic int qcom_snps_hsphy_power_off(struct phy *phy)\n{\n\tstruct hsphy_priv *priv = phy_get_drvdata(phy);\n\n\tqcom_snps_hsphy_enter_retention(priv);\n\tqcom_snps_hsphy_enable_hv_interrupts(priv);\n\tregulator_bulk_disable(VREG_NUM, priv->vregs);\n\n\treturn 0;\n}\n\nstatic int qcom_snps_hsphy_reset(struct hsphy_priv *priv)\n{\n\tint ret;\n\n\tret = reset_control_assert(priv->phy_reset);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(10, 15);\n\n\tret = reset_control_deassert(priv->phy_reset);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(80, 100);\n\n\treturn 0;\n}\n\nstatic void qcom_snps_hsphy_init_sequence(struct hsphy_priv *priv)\n{\n\tconst struct hsphy_data *data = priv->data;\n\tconst struct hsphy_init_seq *seq;\n\tint i;\n\n\t \n\tif (!data)\n\t\treturn;\n\n\tseq = data->init_seq;\n\n\tfor (i = 0; i < data->init_seq_num; i++, seq++) {\n\t\twriteb(seq->val, priv->base + seq->offset);\n\t\tif (seq->delay)\n\t\t\tusleep_range(seq->delay, seq->delay + 10);\n\t}\n}\n\nstatic int qcom_snps_hsphy_por_reset(struct hsphy_priv *priv)\n{\n\tint ret;\n\n\tret = reset_control_assert(priv->por_reset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tqcom_snps_hsphy_exit_retention(priv);\n\n\t \n\tusleep_range(10, 20);\n\tret = reset_control_deassert(priv->por_reset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(80, 100);\n\n\treturn 0;\n}\n\nstatic int qcom_snps_hsphy_init(struct phy *phy)\n{\n\tstruct hsphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(priv->num_clks, priv->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_snps_hsphy_reset(priv);\n\tif (ret)\n\t\tgoto disable_clocks;\n\n\tqcom_snps_hsphy_init_sequence(priv);\n\n\tret = qcom_snps_hsphy_por_reset(priv);\n\tif (ret)\n\t\tgoto disable_clocks;\n\n\treturn 0;\n\ndisable_clocks:\n\tclk_bulk_disable_unprepare(priv->num_clks, priv->clks);\n\treturn ret;\n}\n\nstatic int qcom_snps_hsphy_exit(struct phy *phy)\n{\n\tstruct hsphy_priv *priv = phy_get_drvdata(phy);\n\n\tclk_bulk_disable_unprepare(priv->num_clks, priv->clks);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops qcom_snps_hsphy_ops = {\n\t.init = qcom_snps_hsphy_init,\n\t.exit = qcom_snps_hsphy_exit,\n\t.power_on = qcom_snps_hsphy_power_on,\n\t.power_off = qcom_snps_hsphy_power_off,\n\t.set_mode = qcom_snps_hsphy_set_mode,\n\t.owner = THIS_MODULE,\n};\n\nstatic const char * const qcom_snps_hsphy_clks[] = {\n\t\"ref\",\n\t\"ahb\",\n\t\"sleep\",\n};\n\nstatic int qcom_snps_hsphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *provider;\n\tstruct hsphy_priv *priv;\n\tstruct phy *phy;\n\tint ret;\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->num_clks = ARRAY_SIZE(qcom_snps_hsphy_clks);\n\tpriv->clks = devm_kcalloc(dev, priv->num_clks, sizeof(*priv->clks),\n\t\t\t\t  GFP_KERNEL);\n\tif (!priv->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->num_clks; i++)\n\t\tpriv->clks[i].id = qcom_snps_hsphy_clks[i];\n\n\tret = devm_clk_bulk_get(dev, priv->num_clks, priv->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->phy_reset = devm_reset_control_get_exclusive(dev, \"phy\");\n\tif (IS_ERR(priv->phy_reset))\n\t\treturn PTR_ERR(priv->phy_reset);\n\n\tpriv->por_reset = devm_reset_control_get_exclusive(dev, \"por\");\n\tif (IS_ERR(priv->por_reset))\n\t\treturn PTR_ERR(priv->por_reset);\n\n\tpriv->vregs[VDD].supply = \"vdd\";\n\tpriv->vregs[VDDA_1P8].supply = \"vdda1p8\";\n\tpriv->vregs[VDDA_3P3].supply = \"vdda3p3\";\n\n\tret = devm_regulator_bulk_get(dev, VREG_NUM, priv->vregs);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->data = device_get_match_data(dev);\n\n\tphy = devm_phy_create(dev, dev->of_node, &qcom_snps_hsphy_ops);\n\tif (IS_ERR(phy))\n\t\treturn PTR_ERR(phy);\n\n\tphy_set_drvdata(phy, priv);\n\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(provider))\n\t\treturn PTR_ERR(provider);\n\n\tret = regulator_set_load(priv->vregs[VDDA_1P8].consumer, 19000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regulator_set_load(priv->vregs[VDDA_3P3].consumer, 16000);\n\tif (ret < 0)\n\t\tgoto unset_1p8_load;\n\n\treturn 0;\n\nunset_1p8_load:\n\tregulator_set_load(priv->vregs[VDDA_1P8].consumer, 0);\n\n\treturn ret;\n}\n\n \n#define HSPHY_INIT_CFG(o, v, d)\t{ .offset = o, .val = v, .delay = d, }\n\nstatic const struct hsphy_init_seq init_seq_femtophy[] = {\n\tHSPHY_INIT_CFG(0xc0, 0x01, 0),\n\tHSPHY_INIT_CFG(0xe8, 0x0d, 0),\n\tHSPHY_INIT_CFG(0x74, 0x12, 0),\n\tHSPHY_INIT_CFG(0x98, 0x63, 0),\n\tHSPHY_INIT_CFG(0x9c, 0x03, 0),\n\tHSPHY_INIT_CFG(0xa0, 0x1d, 0),\n\tHSPHY_INIT_CFG(0xa4, 0x03, 0),\n\tHSPHY_INIT_CFG(0x8c, 0x23, 0),\n\tHSPHY_INIT_CFG(0x78, 0x08, 0),\n\tHSPHY_INIT_CFG(0x7c, 0xdc, 0),\n\tHSPHY_INIT_CFG(0x90, 0xe0, 20),\n\tHSPHY_INIT_CFG(0x74, 0x10, 0),\n\tHSPHY_INIT_CFG(0x90, 0x60, 0),\n};\n\nstatic const struct hsphy_data hsphy_data_femtophy = {\n\t.init_seq = init_seq_femtophy,\n\t.init_seq_num = ARRAY_SIZE(init_seq_femtophy),\n};\n\nstatic const struct of_device_id qcom_snps_hsphy_match[] = {\n\t{ .compatible = \"qcom,usb-hs-28nm-femtophy\", .data = &hsphy_data_femtophy, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qcom_snps_hsphy_match);\n\nstatic struct platform_driver qcom_snps_hsphy_driver = {\n\t.probe = qcom_snps_hsphy_probe,\n\t.driver\t= {\n\t\t.name = \"qcom,usb-hs-28nm-phy\",\n\t\t.of_match_table = qcom_snps_hsphy_match,\n\t},\n};\nmodule_platform_driver(qcom_snps_hsphy_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm 28nm Hi-Speed USB PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}