{
  "module_name": "phy-qcom-ipq4019-usb.c",
  "hash_id": "109af5451b96a12203a77d4b846b6ad332e6d93aa69962c7b88f25f6c74fb2ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-ipq4019-usb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\nstruct ipq4019_usb_phy {\n\tstruct device\t\t*dev;\n\tstruct phy\t\t*phy;\n\tvoid __iomem\t\t*base;\n\tstruct reset_control\t*por_rst;\n\tstruct reset_control\t*srif_rst;\n};\n\nstatic int ipq4019_ss_phy_power_off(struct phy *_phy)\n{\n\tstruct ipq4019_usb_phy *phy = phy_get_drvdata(_phy);\n\n\treset_control_assert(phy->por_rst);\n\tmsleep(10);\n\n\treturn 0;\n}\n\nstatic int ipq4019_ss_phy_power_on(struct phy *_phy)\n{\n\tstruct ipq4019_usb_phy *phy = phy_get_drvdata(_phy);\n\n\tipq4019_ss_phy_power_off(_phy);\n\n\treset_control_deassert(phy->por_rst);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ipq4019_usb_ss_phy_ops = {\n\t.power_on\t= ipq4019_ss_phy_power_on,\n\t.power_off\t= ipq4019_ss_phy_power_off,\n};\n\nstatic int ipq4019_hs_phy_power_off(struct phy *_phy)\n{\n\tstruct ipq4019_usb_phy *phy = phy_get_drvdata(_phy);\n\n\treset_control_assert(phy->por_rst);\n\tmsleep(10);\n\n\treset_control_assert(phy->srif_rst);\n\tmsleep(10);\n\n\treturn 0;\n}\n\nstatic int ipq4019_hs_phy_power_on(struct phy *_phy)\n{\n\tstruct ipq4019_usb_phy *phy = phy_get_drvdata(_phy);\n\n\tipq4019_hs_phy_power_off(_phy);\n\n\treset_control_deassert(phy->srif_rst);\n\tmsleep(10);\n\n\treset_control_deassert(phy->por_rst);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops ipq4019_usb_hs_phy_ops = {\n\t.power_on\t= ipq4019_hs_phy_power_on,\n\t.power_off\t= ipq4019_hs_phy_power_off,\n};\n\nstatic const struct of_device_id ipq4019_usb_phy_of_match[] = {\n\t{ .compatible = \"qcom,usb-hs-ipq4019-phy\", .data = &ipq4019_usb_hs_phy_ops},\n\t{ .compatible = \"qcom,usb-ss-ipq4019-phy\", .data = &ipq4019_usb_ss_phy_ops},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ipq4019_usb_phy_of_match);\n\nstatic int ipq4019_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tstruct ipq4019_usb_phy *phy;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->dev = &pdev->dev;\n\tphy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->base)) {\n\t\tdev_err(dev, \"failed to remap register memory\\n\");\n\t\treturn PTR_ERR(phy->base);\n\t}\n\n\tphy->por_rst = devm_reset_control_get(phy->dev, \"por_rst\");\n\tif (IS_ERR(phy->por_rst)) {\n\t\tif (PTR_ERR(phy->por_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"POR reset is missing\\n\");\n\t\treturn PTR_ERR(phy->por_rst);\n\t}\n\n\tphy->srif_rst = devm_reset_control_get_optional(phy->dev, \"srif_rst\");\n\tif (IS_ERR(phy->srif_rst))\n\t\treturn PTR_ERR(phy->srif_rst);\n\n\tphy->phy = devm_phy_create(dev, NULL, of_device_get_match_data(dev));\n\tif (IS_ERR(phy->phy)) {\n\t\tdev_err(dev, \"failed to create PHY\\n\");\n\t\treturn PTR_ERR(phy->phy);\n\t}\n\tphy_set_drvdata(phy->phy, phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver ipq4019_usb_phy_driver = {\n\t.probe\t= ipq4019_usb_phy_probe,\n\t.driver = {\n\t\t.of_match_table\t= ipq4019_usb_phy_of_match,\n\t\t.name  = \"ipq4019-usb-phy\",\n\t}\n};\nmodule_platform_driver(ipq4019_usb_phy_driver);\n\nMODULE_DESCRIPTION(\"QCOM/IPQ4019 USB phy driver\");\nMODULE_AUTHOR(\"John Crispin <john@phrozen.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}