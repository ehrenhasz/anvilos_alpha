{
  "module_name": "phy-qcom-snps-eusb2.c",
  "hash_id": "1cbec38f8f638f2335957f913881562d2688b0addeadcc45501c4d04cfe4b8d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-snps-eusb2.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#define USB_PHY_UTMI_CTRL0\t\t(0x3c)\n#define SLEEPM\t\t\t\tBIT(0)\n#define OPMODE_MASK\t\t\tGENMASK(4, 3)\n#define OPMODE_NONDRIVING\t\tBIT(3)\n\n#define USB_PHY_UTMI_CTRL5\t\t(0x50)\n#define POR\t\t\t\tBIT(1)\n\n#define USB_PHY_HS_PHY_CTRL_COMMON0\t(0x54)\n#define PHY_ENABLE\t\t\tBIT(0)\n#define SIDDQ_SEL\t\t\tBIT(1)\n#define SIDDQ\t\t\t\tBIT(2)\n#define RETENABLEN\t\t\tBIT(3)\n#define FSEL_MASK\t\t\tGENMASK(6, 4)\n#define FSEL_19_2_MHZ_VAL\t\t(0x0)\n#define FSEL_38_4_MHZ_VAL\t\t(0x4)\n\n#define USB_PHY_CFG_CTRL_1\t\t(0x58)\n#define PHY_CFG_PLL_CPBIAS_CNTRL_MASK\tGENMASK(7, 1)\n\n#define USB_PHY_CFG_CTRL_2\t\t(0x5c)\n#define PHY_CFG_PLL_FB_DIV_7_0_MASK\tGENMASK(7, 0)\n#define DIV_7_0_19_2_MHZ_VAL\t\t(0x90)\n#define DIV_7_0_38_4_MHZ_VAL\t\t(0xc8)\n\n#define USB_PHY_CFG_CTRL_3\t\t(0x60)\n#define PHY_CFG_PLL_FB_DIV_11_8_MASK\tGENMASK(3, 0)\n#define DIV_11_8_19_2_MHZ_VAL\t\t(0x1)\n#define DIV_11_8_38_4_MHZ_VAL\t\t(0x0)\n\n#define PHY_CFG_PLL_REF_DIV\t\tGENMASK(7, 4)\n#define PLL_REF_DIV_VAL\t\t\t(0x0)\n\n#define USB_PHY_HS_PHY_CTRL2\t\t(0x64)\n#define VBUSVLDEXT0\t\t\tBIT(0)\n#define USB2_SUSPEND_N\t\t\tBIT(2)\n#define USB2_SUSPEND_N_SEL\t\tBIT(3)\n#define VBUS_DET_EXT_SEL\t\tBIT(4)\n\n#define USB_PHY_CFG_CTRL_4\t\t(0x68)\n#define PHY_CFG_PLL_GMP_CNTRL_MASK\tGENMASK(1, 0)\n#define PHY_CFG_PLL_INT_CNTRL_MASK\tGENMASK(7, 2)\n\n#define USB_PHY_CFG_CTRL_5\t\t(0x6c)\n#define PHY_CFG_PLL_PROP_CNTRL_MASK\tGENMASK(4, 0)\n#define PHY_CFG_PLL_VREF_TUNE_MASK\tGENMASK(7, 6)\n\n#define USB_PHY_CFG_CTRL_6\t\t(0x70)\n#define PHY_CFG_PLL_VCO_CNTRL_MASK\tGENMASK(2, 0)\n\n#define USB_PHY_CFG_CTRL_7\t\t(0x74)\n\n#define USB_PHY_CFG_CTRL_8\t\t(0x78)\n#define PHY_CFG_TX_FSLS_VREF_TUNE_MASK\tGENMASK(1, 0)\n#define PHY_CFG_TX_FSLS_VREG_BYPASS\tBIT(2)\n#define PHY_CFG_TX_HS_VREF_TUNE_MASK\tGENMASK(5, 3)\n#define PHY_CFG_TX_HS_XV_TUNE_MASK\tGENMASK(7, 6)\n\n#define USB_PHY_CFG_CTRL_9\t\t(0x7c)\n#define PHY_CFG_TX_PREEMP_TUNE_MASK\tGENMASK(2, 0)\n#define PHY_CFG_TX_RES_TUNE_MASK\tGENMASK(4, 3)\n#define PHY_CFG_TX_RISE_TUNE_MASK\tGENMASK(6, 5)\n#define PHY_CFG_RCAL_BYPASS\t\tBIT(7)\n\n#define USB_PHY_CFG_CTRL_10\t\t(0x80)\n\n#define USB_PHY_CFG0\t\t\t(0x94)\n#define DATAPATH_CTRL_OVERRIDE_EN\tBIT(0)\n#define CMN_CTRL_OVERRIDE_EN\t\tBIT(1)\n\n#define UTMI_PHY_CMN_CTRL0\t\t(0x98)\n#define TESTBURNIN\t\t\tBIT(6)\n\n#define USB_PHY_FSEL_SEL\t\t(0xb8)\n#define FSEL_SEL\t\t\tBIT(0)\n\n#define USB_PHY_APB_ACCESS_CMD\t\t(0x130)\n#define RW_ACCESS\t\t\tBIT(0)\n#define APB_START_CMD\t\t\tBIT(1)\n#define APB_LOGIC_RESET\t\t\tBIT(2)\n\n#define USB_PHY_APB_ACCESS_STATUS\t(0x134)\n#define ACCESS_DONE\t\t\tBIT(0)\n#define TIMED_OUT\t\t\tBIT(1)\n#define ACCESS_ERROR\t\t\tBIT(2)\n#define ACCESS_IN_PROGRESS\t\tBIT(3)\n\n#define USB_PHY_APB_ADDRESS\t\t(0x138)\n#define APB_REG_ADDR_MASK\t\tGENMASK(7, 0)\n\n#define USB_PHY_APB_WRDATA_LSB\t\t(0x13c)\n#define APB_REG_WRDATA_7_0_MASK\t\tGENMASK(3, 0)\n\n#define USB_PHY_APB_WRDATA_MSB\t\t(0x140)\n#define APB_REG_WRDATA_15_8_MASK\tGENMASK(7, 4)\n\n#define USB_PHY_APB_RDDATA_LSB\t\t(0x144)\n#define APB_REG_RDDATA_7_0_MASK\t\tGENMASK(3, 0)\n\n#define USB_PHY_APB_RDDATA_MSB\t\t(0x148)\n#define APB_REG_RDDATA_15_8_MASK\tGENMASK(7, 4)\n\nstatic const char * const eusb2_hsphy_vreg_names[] = {\n\t\"vdd\", \"vdda12\",\n};\n\n#define EUSB2_NUM_VREGS\t\tARRAY_SIZE(eusb2_hsphy_vreg_names)\n\nstruct qcom_snps_eusb2_hsphy {\n\tstruct phy *phy;\n\tvoid __iomem *base;\n\n\tstruct clk *ref_clk;\n\tstruct reset_control *phy_reset;\n\n\tstruct regulator_bulk_data vregs[EUSB2_NUM_VREGS];\n\n\tenum phy_mode mode;\n\n\tstruct phy *repeater;\n};\n\nstatic int qcom_snps_eusb2_hsphy_set_mode(struct phy *p, enum phy_mode mode, int submode)\n{\n\tstruct qcom_snps_eusb2_hsphy *phy = phy_get_drvdata(p);\n\n\tphy->mode = mode;\n\n\treturn phy_set_mode_ext(phy->repeater, mode, submode);\n}\n\nstatic void qcom_snps_eusb2_hsphy_write_mask(void __iomem *base, u32 offset,\n\t\t\t\t\t     u32 mask, u32 val)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(base + offset);\n\treg &= ~mask;\n\treg |= val & mask;\n\twritel_relaxed(reg, base + offset);\n\n\t \n\treadl_relaxed(base + offset);\n}\n\nstatic void qcom_eusb2_default_parameters(struct qcom_snps_eusb2_hsphy *phy)\n{\n\t \n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_9,\n\t\t\t\t\t PHY_CFG_TX_PREEMP_TUNE_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_TX_PREEMP_TUNE_MASK, 0));\n\n\t \n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_9,\n\t\t\t\t\t PHY_CFG_TX_RISE_TUNE_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_TX_RISE_TUNE_MASK, 0x2));\n\n\t \n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_9,\n\t\t\t\t\t PHY_CFG_TX_RES_TUNE_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_TX_RES_TUNE_MASK, 0x1));\n\n\t \n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_8,\n\t\t\t\t\t PHY_CFG_TX_HS_VREF_TUNE_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_TX_HS_VREF_TUNE_MASK, 0x3));\n\n\t \n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_8,\n\t\t\t\t\t PHY_CFG_TX_HS_XV_TUNE_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_TX_HS_XV_TUNE_MASK, 0x0));\n}\n\nstatic int qcom_eusb2_ref_clk_init(struct qcom_snps_eusb2_hsphy *phy)\n{\n\tunsigned long ref_clk_freq = clk_get_rate(phy->ref_clk);\n\n\tswitch (ref_clk_freq) {\n\tcase 19200000:\n\t\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_HS_PHY_CTRL_COMMON0,\n\t\t\t\t\t\t FSEL_MASK,\n\t\t\t\t\t\t FIELD_PREP(FSEL_MASK, FSEL_19_2_MHZ_VAL));\n\n\t\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_2,\n\t\t\t\t\t\t PHY_CFG_PLL_FB_DIV_7_0_MASK,\n\t\t\t\t\t\t DIV_7_0_19_2_MHZ_VAL);\n\n\t\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_3,\n\t\t\t\t\t\t PHY_CFG_PLL_FB_DIV_11_8_MASK,\n\t\t\t\t\t\t DIV_11_8_19_2_MHZ_VAL);\n\t\tbreak;\n\n\tcase 38400000:\n\t\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_HS_PHY_CTRL_COMMON0,\n\t\t\t\t\t\t FSEL_MASK,\n\t\t\t\t\t\t FIELD_PREP(FSEL_MASK, FSEL_38_4_MHZ_VAL));\n\n\t\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_2,\n\t\t\t\t\t\t PHY_CFG_PLL_FB_DIV_7_0_MASK,\n\t\t\t\t\t\t DIV_7_0_38_4_MHZ_VAL);\n\n\t\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_3,\n\t\t\t\t\t\t PHY_CFG_PLL_FB_DIV_11_8_MASK,\n\t\t\t\t\t\t DIV_11_8_38_4_MHZ_VAL);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&phy->phy->dev, \"unsupported ref_clk_freq:%lu\\n\", ref_clk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_3,\n\t\t\t\t\t PHY_CFG_PLL_REF_DIV, PLL_REF_DIV_VAL);\n\n\treturn 0;\n}\n\nstatic int qcom_snps_eusb2_hsphy_init(struct phy *p)\n{\n\tstruct qcom_snps_eusb2_hsphy *phy = phy_get_drvdata(p);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(phy->vregs), phy->vregs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_init(phy->repeater);\n\tif (ret) {\n\t\tdev_err(&p->dev, \"repeater init failed. %d\\n\", ret);\n\t\tgoto disable_vreg;\n\t}\n\n\tret = clk_prepare_enable(phy->ref_clk);\n\tif (ret) {\n\t\tdev_err(&p->dev, \"failed to enable ref clock, %d\\n\", ret);\n\t\tgoto disable_vreg;\n\t}\n\n\tret = reset_control_assert(phy->phy_reset);\n\tif (ret) {\n\t\tdev_err(&p->dev, \"failed to assert phy_reset, %d\\n\", ret);\n\t\tgoto disable_ref_clk;\n\t}\n\n\tusleep_range(100, 150);\n\n\tret = reset_control_deassert(phy->phy_reset);\n\tif (ret) {\n\t\tdev_err(&p->dev, \"failed to de-assert phy_reset, %d\\n\", ret);\n\t\tgoto disable_ref_clk;\n\t}\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG0,\n\t\t\t\t\t CMN_CTRL_OVERRIDE_EN, CMN_CTRL_OVERRIDE_EN);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_UTMI_CTRL5, POR, POR);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_HS_PHY_CTRL_COMMON0,\n\t\t\t\t\t PHY_ENABLE | RETENABLEN, PHY_ENABLE | RETENABLEN);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_APB_ACCESS_CMD,\n\t\t\t\t\t APB_LOGIC_RESET, APB_LOGIC_RESET);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, UTMI_PHY_CMN_CTRL0, TESTBURNIN, 0);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_FSEL_SEL,\n\t\t\t\t\t FSEL_SEL, FSEL_SEL);\n\n\t \n\tret = qcom_eusb2_ref_clk_init(phy);\n\tif (ret)\n\t\tgoto disable_ref_clk;\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_1,\n\t\t\t\t\t PHY_CFG_PLL_CPBIAS_CNTRL_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_PLL_CPBIAS_CNTRL_MASK, 0x1));\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_4,\n\t\t\t\t\t PHY_CFG_PLL_INT_CNTRL_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_PLL_INT_CNTRL_MASK, 0x8));\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_4,\n\t\t\t\t\t PHY_CFG_PLL_GMP_CNTRL_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_PLL_GMP_CNTRL_MASK, 0x1));\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_5,\n\t\t\t\t\t PHY_CFG_PLL_PROP_CNTRL_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_PLL_PROP_CNTRL_MASK, 0x10));\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_6,\n\t\t\t\t\t PHY_CFG_PLL_VCO_CNTRL_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_PLL_VCO_CNTRL_MASK, 0x0));\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_CFG_CTRL_5,\n\t\t\t\t\t PHY_CFG_PLL_VREF_TUNE_MASK,\n\t\t\t\t\t FIELD_PREP(PHY_CFG_PLL_VREF_TUNE_MASK, 0x1));\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_HS_PHY_CTRL2,\n\t\t\t\t\t VBUS_DET_EXT_SEL, VBUS_DET_EXT_SEL);\n\n\t \n\tqcom_eusb2_default_parameters(phy);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_HS_PHY_CTRL2,\n\t\t\t\t\t USB2_SUSPEND_N_SEL | USB2_SUSPEND_N,\n\t\t\t\t\t USB2_SUSPEND_N_SEL | USB2_SUSPEND_N);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_UTMI_CTRL0, SLEEPM, SLEEPM);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_HS_PHY_CTRL_COMMON0,\n\t\t\t\t\t SIDDQ_SEL, SIDDQ_SEL);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_HS_PHY_CTRL_COMMON0,\n\t\t\t\t\t SIDDQ, 0);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_UTMI_CTRL5, POR, 0);\n\n\tqcom_snps_eusb2_hsphy_write_mask(phy->base, USB_PHY_HS_PHY_CTRL2,\n\t\t\t\t\t USB2_SUSPEND_N_SEL, 0);\n\n\treturn 0;\n\ndisable_ref_clk:\n\tclk_disable_unprepare(phy->ref_clk);\n\ndisable_vreg:\n\tregulator_bulk_disable(ARRAY_SIZE(phy->vregs), phy->vregs);\n\n\treturn ret;\n}\n\nstatic int qcom_snps_eusb2_hsphy_exit(struct phy *p)\n{\n\tstruct qcom_snps_eusb2_hsphy *phy = phy_get_drvdata(p);\n\n\tclk_disable_unprepare(phy->ref_clk);\n\n\tregulator_bulk_disable(ARRAY_SIZE(phy->vregs), phy->vregs);\n\n\tphy_exit(phy->repeater);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops qcom_snps_eusb2_hsphy_ops = {\n\t.init\t\t= qcom_snps_eusb2_hsphy_init,\n\t.exit\t\t= qcom_snps_eusb2_hsphy_exit,\n\t.set_mode\t= qcom_snps_eusb2_hsphy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int qcom_snps_eusb2_hsphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct qcom_snps_eusb2_hsphy *phy;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *generic_phy;\n\tint ret, i;\n\tint num;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->base))\n\t\treturn PTR_ERR(phy->base);\n\n\tphy->phy_reset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(phy->phy_reset))\n\t\treturn PTR_ERR(phy->phy_reset);\n\n\tphy->ref_clk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(phy->ref_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy->ref_clk),\n\t\t\t\t     \"failed to get ref clk\\n\");\n\n\tnum = ARRAY_SIZE(phy->vregs);\n\tfor (i = 0; i < num; i++)\n\t\tphy->vregs[i].supply = eusb2_hsphy_vreg_names[i];\n\n\tret = devm_regulator_bulk_get(dev, num, phy->vregs);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to get regulator supplies\\n\");\n\n\tphy->repeater = devm_of_phy_get_by_index(dev, np, 0);\n\tif (IS_ERR(phy->repeater))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy->repeater),\n\t\t\t\t     \"failed to get repeater\\n\");\n\n\tgeneric_phy = devm_phy_create(dev, NULL, &qcom_snps_eusb2_hsphy_ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tdev_err(dev, \"failed to create phy %d\\n\", ret);\n\t\treturn PTR_ERR(generic_phy);\n\t}\n\n\tdev_set_drvdata(dev, phy);\n\tphy_set_drvdata(generic_phy, phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\treturn PTR_ERR(phy_provider);\n\n\tdev_info(dev, \"Registered Qcom-eUSB2 phy\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_snps_eusb2_hsphy_of_match_table[] = {\n\t{ .compatible = \"qcom,sm8550-snps-eusb2-phy\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qcom_snps_eusb2_hsphy_of_match_table);\n\nstatic struct platform_driver qcom_snps_eusb2_hsphy_driver = {\n\t.probe\t\t= qcom_snps_eusb2_hsphy_probe,\n\t.driver = {\n\t\t.name\t= \"qcom-snps-eusb2-hsphy\",\n\t\t.of_match_table = qcom_snps_eusb2_hsphy_of_match_table,\n\t},\n};\n\nmodule_platform_driver(qcom_snps_eusb2_hsphy_driver);\nMODULE_DESCRIPTION(\"Qualcomm SNPS eUSB2 HS PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}