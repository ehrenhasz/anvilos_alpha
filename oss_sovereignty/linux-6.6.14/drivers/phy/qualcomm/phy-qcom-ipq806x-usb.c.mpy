{
  "module_name": "phy-qcom-ipq806x-usb.c",
  "hash_id": "7bf7dbc8ca6ed1a4d906e9f2face914a95d903e12b13bcf2a8df44479ae6958d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-ipq806x-usb.c",
  "human_readable_source": "\n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/bitfield.h>\n\n \n#define QSCRATCH_GENERAL_CFG\t\t(0x08)\n#define HSUSB_PHY_CTRL_REG\t\t(0x10)\n\n \n#define HSUSB_CTRL_DMSEHV_CLAMP\t\tBIT(24)\n#define HSUSB_CTRL_USB2_SUSPEND\t\tBIT(23)\n#define HSUSB_CTRL_UTMI_CLK_EN\t\tBIT(21)\n#define HSUSB_CTRL_UTMI_OTG_VBUS_VALID\tBIT(20)\n#define HSUSB_CTRL_USE_CLKCORE\t\tBIT(18)\n#define HSUSB_CTRL_DPSEHV_CLAMP\t\tBIT(17)\n#define HSUSB_CTRL_COMMONONN\t\tBIT(11)\n#define HSUSB_CTRL_ID_HV_CLAMP\t\tBIT(9)\n#define HSUSB_CTRL_OTGSESSVLD_CLAMP\tBIT(8)\n#define HSUSB_CTRL_CLAMP_EN\t\tBIT(7)\n#define HSUSB_CTRL_RETENABLEN\t\tBIT(1)\n#define HSUSB_CTRL_POR\t\t\tBIT(0)\n\n \n#define HSUSB_GCFG_XHCI_REV\t\tBIT(2)\n\n \n#define SSUSB_PHY_CTRL_REG\t\t(0x00)\n#define SSUSB_PHY_PARAM_CTRL_1\t\t(0x04)\n#define SSUSB_PHY_PARAM_CTRL_2\t\t(0x08)\n#define CR_PROTOCOL_DATA_IN_REG\t\t(0x0c)\n#define CR_PROTOCOL_DATA_OUT_REG\t(0x10)\n#define CR_PROTOCOL_CAP_ADDR_REG\t(0x14)\n#define CR_PROTOCOL_CAP_DATA_REG\t(0x18)\n#define CR_PROTOCOL_READ_REG\t\t(0x1c)\n#define CR_PROTOCOL_WRITE_REG\t\t(0x20)\n\n \n#define SSUSB_CTRL_REF_USE_PAD\t\tBIT(28)\n#define SSUSB_CTRL_TEST_POWERDOWN\tBIT(27)\n#define SSUSB_CTRL_LANE0_PWR_PRESENT\tBIT(24)\n#define SSUSB_CTRL_SS_PHY_EN\t\tBIT(8)\n#define SSUSB_CTRL_SS_PHY_RESET\t\tBIT(7)\n\n \n#define SSPHY_CTRL_RX_OVRD_IN_HI(lane)\t(0x1006 + 0x100 * (lane))\n#define SSPHY_CTRL_TX_OVRD_DRV_LO(lane)\t(0x1002 + 0x100 * (lane))\n\n \n#define SSPHY_RX_EQ_VALUE\t\t4  \n \n#define SSPHY_TX_DEEMPH_3_5DB\t\t23\n \n#define SSPHY_MPLL_VALUE\t\t0\n\n \n#define PHY_PARAM_CTRL1_TX_FULL_SWING_MASK\tGENMASK(26, 19)\n#define PHY_PARAM_CTRL1_TX_DEEMPH_6DB_MASK\tGENMASK(19, 13)\n#define PHY_PARAM_CTRL1_TX_DEEMPH_3_5DB_MASK\tGENMASK(13, 7)\n#define PHY_PARAM_CTRL1_LOS_BIAS_MASK\t\tGENMASK(7, 2)\n\n#define PHY_PARAM_CTRL1_MASK\t\t\t\t\\\n\t\t(PHY_PARAM_CTRL1_TX_FULL_SWING_MASK |\t\\\n\t\t PHY_PARAM_CTRL1_TX_DEEMPH_6DB_MASK |\t\\\n\t\t PHY_PARAM_CTRL1_TX_DEEMPH_3_5DB_MASK |\t\\\n\t\t PHY_PARAM_CTRL1_LOS_BIAS_MASK)\n\n#define PHY_PARAM_CTRL1_TX_FULL_SWING(x)\t\\\n\t\tFIELD_PREP(PHY_PARAM_CTRL1_TX_FULL_SWING_MASK, (x))\n#define PHY_PARAM_CTRL1_TX_DEEMPH_6DB(x)\t\\\n\t\tFIELD_PREP(PHY_PARAM_CTRL1_TX_DEEMPH_6DB_MASK, (x))\n#define PHY_PARAM_CTRL1_TX_DEEMPH_3_5DB(x)\t\\\n\t\tFIELD_PREP(PHY_PARAM_CTRL1_TX_DEEMPH_3_5DB_MASK, x)\n#define PHY_PARAM_CTRL1_LOS_BIAS(x)\t\\\n\t\tFIELD_PREP(PHY_PARAM_CTRL1_LOS_BIAS_MASK, (x))\n\n \n#define RX_OVRD_IN_HI_RX_RESET_OVRD\t\tBIT(13)\n#define RX_OVRD_IN_HI_RX_RX_RESET\t\tBIT(12)\n#define RX_OVRD_IN_HI_RX_EQ_OVRD\t\tBIT(11)\n#define RX_OVRD_IN_HI_RX_EQ_MASK\t\tGENMASK(10, 7)\n#define RX_OVRD_IN_HI_RX_EQ(x)\t\t\tFIELD_PREP(RX_OVRD_IN_HI_RX_EQ_MASK, (x))\n#define RX_OVRD_IN_HI_RX_EQ_EN_OVRD\t\tBIT(7)\n#define RX_OVRD_IN_HI_RX_EQ_EN\t\t\tBIT(6)\n#define RX_OVRD_IN_HI_RX_LOS_FILTER_OVRD\tBIT(5)\n#define RX_OVRD_IN_HI_RX_LOS_FILTER_MASK\tGENMASK(4, 2)\n#define RX_OVRD_IN_HI_RX_RATE_OVRD\t\tBIT(2)\n#define RX_OVRD_IN_HI_RX_RATE_MASK\t\tGENMASK(2, 0)\n\n \n#define TX_OVRD_DRV_LO_AMPLITUDE_MASK\t\tGENMASK(6, 0)\n#define TX_OVRD_DRV_LO_PREEMPH_MASK\t\tGENMASK(13, 6)\n#define TX_OVRD_DRV_LO_PREEMPH(x)\t\t((x) << 7)\n#define TX_OVRD_DRV_LO_EN\t\t\tBIT(14)\n\n \n#define SSPHY_MPLL_MASK\t\t\t\tGENMASK(8, 5)\n#define SSPHY_MPLL(x)\t\t\t\t((x) << 5)\n\n \n#define SS_CR_CAP_ADDR_REG\t\t\tBIT(0)\n#define SS_CR_CAP_DATA_REG\t\t\tBIT(0)\n#define SS_CR_READ_REG\t\t\t\tBIT(0)\n#define SS_CR_WRITE_REG\t\t\t\tBIT(0)\n\n#define LATCH_SLEEP\t\t\t\t40\n#define LATCH_TIMEOUT\t\t\t\t100\n\nstruct usb_phy {\n\tvoid __iomem\t\t*base;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*xo_clk;\n\tstruct clk\t\t*ref_clk;\n\tu32\t\t\trx_eq;\n\tu32\t\t\ttx_deamp_3_5db;\n\tu32\t\t\tmpll;\n};\n\nstruct phy_drvdata {\n\tstruct phy_ops\tops;\n\tu32\t\tclk_rate;\n};\n\n \nstatic inline void usb_phy_write_readback(struct usb_phy *phy_dwc3,\n\t\t\t\t\t  u32 offset,\n\t\t\t\t\t  const u32 mask, u32 val)\n{\n\tu32 write_val, tmp = readl(phy_dwc3->base + offset);\n\n\ttmp &= ~mask;\t\t \n\twrite_val = tmp | val;\n\n\twritel(write_val, phy_dwc3->base + offset);\n\n\t \n\ttmp = readl(phy_dwc3->base + offset);\n\ttmp &= mask;\t\t \n\n\tif (tmp != val)\n\t\tdev_err(phy_dwc3->dev, \"write: %x to QSCRATCH: %x FAILED\\n\", val, offset);\n}\n\nstatic int wait_for_latch(void __iomem *addr)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(addr, val, !val, LATCH_SLEEP, LATCH_TIMEOUT);\n}\n\n \nstatic int usb_ss_write_phycreg(struct usb_phy *phy_dwc3,\n\t\t\t\tu32 addr, u32 val)\n{\n\tint ret;\n\n\twritel(addr, phy_dwc3->base + CR_PROTOCOL_DATA_IN_REG);\n\twritel(SS_CR_CAP_ADDR_REG,\n\t       phy_dwc3->base + CR_PROTOCOL_CAP_ADDR_REG);\n\n\tret = wait_for_latch(phy_dwc3->base + CR_PROTOCOL_CAP_ADDR_REG);\n\tif (ret)\n\t\tgoto err_wait;\n\n\twritel(val, phy_dwc3->base + CR_PROTOCOL_DATA_IN_REG);\n\twritel(SS_CR_CAP_DATA_REG,\n\t       phy_dwc3->base + CR_PROTOCOL_CAP_DATA_REG);\n\n\tret = wait_for_latch(phy_dwc3->base + CR_PROTOCOL_CAP_DATA_REG);\n\tif (ret)\n\t\tgoto err_wait;\n\n\twritel(SS_CR_WRITE_REG, phy_dwc3->base + CR_PROTOCOL_WRITE_REG);\n\n\tret = wait_for_latch(phy_dwc3->base + CR_PROTOCOL_WRITE_REG);\n\nerr_wait:\n\tif (ret)\n\t\tdev_err(phy_dwc3->dev, \"timeout waiting for latch\\n\");\n\treturn ret;\n}\n\n \nstatic int usb_ss_read_phycreg(struct usb_phy *phy_dwc3,\n\t\t\t       u32 addr, u32 *val)\n{\n\tint ret;\n\n\twritel(addr, phy_dwc3->base + CR_PROTOCOL_DATA_IN_REG);\n\twritel(SS_CR_CAP_ADDR_REG,\n\t       phy_dwc3->base + CR_PROTOCOL_CAP_ADDR_REG);\n\n\tret = wait_for_latch(phy_dwc3->base + CR_PROTOCOL_CAP_ADDR_REG);\n\tif (ret)\n\t\tgoto err_wait;\n\n\t \n\twritel(SS_CR_READ_REG, phy_dwc3->base + CR_PROTOCOL_READ_REG);\n\n\tret = wait_for_latch(phy_dwc3->base + CR_PROTOCOL_READ_REG);\n\tif (ret)\n\t\tgoto err_wait;\n\n\t \n\treadl(phy_dwc3->base + CR_PROTOCOL_DATA_OUT_REG);\n\n\twritel(SS_CR_READ_REG, phy_dwc3->base + CR_PROTOCOL_READ_REG);\n\n\tret = wait_for_latch(phy_dwc3->base + CR_PROTOCOL_READ_REG);\n\tif (ret)\n\t\tgoto err_wait;\n\n\t*val = readl(phy_dwc3->base + CR_PROTOCOL_DATA_OUT_REG);\n\nerr_wait:\n\treturn ret;\n}\n\nstatic int qcom_ipq806x_usb_hs_phy_init(struct phy *phy)\n{\n\tstruct usb_phy *phy_dwc3 = phy_get_drvdata(phy);\n\tint ret;\n\tu32 val;\n\n\tret = clk_prepare_enable(phy_dwc3->xo_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(phy_dwc3->ref_clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(phy_dwc3->xo_clk);\n\t\treturn ret;\n\t}\n\n\t \n\tval = HSUSB_CTRL_DPSEHV_CLAMP | HSUSB_CTRL_DMSEHV_CLAMP |\n\t\tHSUSB_CTRL_RETENABLEN  | HSUSB_CTRL_COMMONONN |\n\t\tHSUSB_CTRL_OTGSESSVLD_CLAMP | HSUSB_CTRL_ID_HV_CLAMP |\n\t\tHSUSB_CTRL_UTMI_OTG_VBUS_VALID | HSUSB_CTRL_UTMI_CLK_EN |\n\t\tHSUSB_CTRL_CLAMP_EN | 0x70;\n\n\t \n\tif (!phy_dwc3->xo_clk)\n\t\tval |= HSUSB_CTRL_USE_CLKCORE;\n\n\twritel(val, phy_dwc3->base + HSUSB_PHY_CTRL_REG);\n\tusleep_range(2000, 2200);\n\n\t \n\twritel(HSUSB_GCFG_XHCI_REV, phy_dwc3->base + QSCRATCH_GENERAL_CFG);\n\n\treturn 0;\n}\n\nstatic int qcom_ipq806x_usb_hs_phy_exit(struct phy *phy)\n{\n\tstruct usb_phy *phy_dwc3 = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(phy_dwc3->ref_clk);\n\tclk_disable_unprepare(phy_dwc3->xo_clk);\n\n\treturn 0;\n}\n\nstatic int qcom_ipq806x_usb_ss_phy_init(struct phy *phy)\n{\n\tstruct usb_phy *phy_dwc3 = phy_get_drvdata(phy);\n\tint ret;\n\tu32 data;\n\n\tret = clk_prepare_enable(phy_dwc3->xo_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(phy_dwc3->ref_clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(phy_dwc3->xo_clk);\n\t\treturn ret;\n\t}\n\n\t \n\tdata = readl(phy_dwc3->base + SSUSB_PHY_CTRL_REG);\n\twritel(data | SSUSB_CTRL_SS_PHY_RESET,\n\t       phy_dwc3->base + SSUSB_PHY_CTRL_REG);\n\tusleep_range(2000, 2200);\n\twritel(data, phy_dwc3->base + SSUSB_PHY_CTRL_REG);\n\n\t \n\tif (!phy_dwc3->xo_clk)\n\t\tdata &= ~SSUSB_CTRL_REF_USE_PAD;\n\telse\n\t\tdata |= SSUSB_CTRL_REF_USE_PAD;\n\n\twritel(data, phy_dwc3->base + SSUSB_PHY_CTRL_REG);\n\n\t \n\tmsleep(30);\n\n\tdata |= SSUSB_CTRL_SS_PHY_EN | SSUSB_CTRL_LANE0_PWR_PRESENT;\n\twritel(data, phy_dwc3->base + SSUSB_PHY_CTRL_REG);\n\n\t \n\tret = usb_ss_read_phycreg(phy_dwc3, 0x102D, &data);\n\tif (ret)\n\t\tgoto err_phy_trans;\n\n\tdata |= (1 << 7);\n\tret = usb_ss_write_phycreg(phy_dwc3, 0x102D, data);\n\tif (ret)\n\t\tgoto err_phy_trans;\n\n\tret = usb_ss_read_phycreg(phy_dwc3, 0x1010, &data);\n\tif (ret)\n\t\tgoto err_phy_trans;\n\n\tdata &= ~0xff0;\n\tdata |= 0x20;\n\tret = usb_ss_write_phycreg(phy_dwc3, 0x1010, data);\n\tif (ret)\n\t\tgoto err_phy_trans;\n\n\t \n\tret = usb_ss_read_phycreg(phy_dwc3, SSPHY_CTRL_RX_OVRD_IN_HI(0), &data);\n\tif (ret)\n\t\tgoto err_phy_trans;\n\n\tdata &= ~RX_OVRD_IN_HI_RX_EQ_EN;\n\tdata |= RX_OVRD_IN_HI_RX_EQ_EN_OVRD;\n\tdata &= ~RX_OVRD_IN_HI_RX_EQ_MASK;\n\tdata |= RX_OVRD_IN_HI_RX_EQ(phy_dwc3->rx_eq);\n\tdata |= RX_OVRD_IN_HI_RX_EQ_OVRD;\n\tret = usb_ss_write_phycreg(phy_dwc3,\n\t\t\t\t   SSPHY_CTRL_RX_OVRD_IN_HI(0), data);\n\tif (ret)\n\t\tgoto err_phy_trans;\n\n\t \n\tret = usb_ss_read_phycreg(phy_dwc3,\n\t\t\t\t  SSPHY_CTRL_TX_OVRD_DRV_LO(0), &data);\n\tif (ret)\n\t\tgoto err_phy_trans;\n\n\tdata &= ~TX_OVRD_DRV_LO_PREEMPH_MASK;\n\tdata |= TX_OVRD_DRV_LO_PREEMPH(phy_dwc3->tx_deamp_3_5db);\n\tdata &= ~TX_OVRD_DRV_LO_AMPLITUDE_MASK;\n\tdata |= 0x6E;\n\tdata |= TX_OVRD_DRV_LO_EN;\n\tret = usb_ss_write_phycreg(phy_dwc3,\n\t\t\t\t   SSPHY_CTRL_TX_OVRD_DRV_LO(0), data);\n\tif (ret)\n\t\tgoto err_phy_trans;\n\n\tdata = 0;\n\tdata &= ~SSPHY_MPLL_MASK;\n\tdata |= SSPHY_MPLL(phy_dwc3->mpll);\n\tusb_ss_write_phycreg(phy_dwc3, 0x30, data);\n\n\t \n\tdata = readl(phy_dwc3->base + SSUSB_PHY_PARAM_CTRL_1);\n\n\tdata &= ~PHY_PARAM_CTRL1_MASK;\n\n\tdata |= PHY_PARAM_CTRL1_TX_FULL_SWING(0x6e) |\n\t\tPHY_PARAM_CTRL1_TX_DEEMPH_6DB(0x20) |\n\t\tPHY_PARAM_CTRL1_TX_DEEMPH_3_5DB(phy_dwc3->tx_deamp_3_5db) |\n\t\tPHY_PARAM_CTRL1_LOS_BIAS(0x9);\n\n\tusb_phy_write_readback(phy_dwc3, SSUSB_PHY_PARAM_CTRL_1,\n\t\t\t       PHY_PARAM_CTRL1_MASK, data);\n\nerr_phy_trans:\n\treturn ret;\n}\n\nstatic int qcom_ipq806x_usb_ss_phy_exit(struct phy *phy)\n{\n\tstruct usb_phy *phy_dwc3 = phy_get_drvdata(phy);\n\n\t \n\tusb_phy_write_readback(phy_dwc3, SSUSB_PHY_CTRL_REG,\n\t\t\t       SSUSB_CTRL_SS_PHY_EN, 0x0);\n\tusb_phy_write_readback(phy_dwc3, SSUSB_PHY_CTRL_REG,\n\t\t\t       SSUSB_CTRL_REF_USE_PAD, 0x0);\n\tusb_phy_write_readback(phy_dwc3, SSUSB_PHY_CTRL_REG,\n\t\t\t       SSUSB_CTRL_TEST_POWERDOWN, 0x0);\n\n\tclk_disable_unprepare(phy_dwc3->ref_clk);\n\tclk_disable_unprepare(phy_dwc3->xo_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_drvdata qcom_ipq806x_usb_hs_drvdata = {\n\t.ops = {\n\t\t.init\t\t= qcom_ipq806x_usb_hs_phy_init,\n\t\t.exit\t\t= qcom_ipq806x_usb_hs_phy_exit,\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n\t.clk_rate = 60000000,\n};\n\nstatic const struct phy_drvdata qcom_ipq806x_usb_ss_drvdata = {\n\t.ops = {\n\t\t.init\t\t= qcom_ipq806x_usb_ss_phy_init,\n\t\t.exit\t\t= qcom_ipq806x_usb_ss_phy_exit,\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n\t.clk_rate = 125000000,\n};\n\nstatic const struct of_device_id qcom_ipq806x_usb_phy_table[] = {\n\t{ .compatible = \"qcom,ipq806x-usb-phy-hs\",\n\t  .data = &qcom_ipq806x_usb_hs_drvdata },\n\t{ .compatible = \"qcom,ipq806x-usb-phy-ss\",\n\t  .data = &qcom_ipq806x_usb_ss_drvdata },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, qcom_ipq806x_usb_phy_table);\n\nstatic int qcom_ipq806x_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tresource_size_t size;\n\tstruct phy *generic_phy;\n\tstruct usb_phy *phy_dwc3;\n\tconst struct phy_drvdata *data;\n\tstruct phy_provider *phy_provider;\n\n\tphy_dwc3 = devm_kzalloc(&pdev->dev, sizeof(*phy_dwc3), GFP_KERNEL);\n\tif (!phy_dwc3)\n\t\treturn -ENOMEM;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\n\tphy_dwc3->dev = &pdev->dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tsize = resource_size(res);\n\tphy_dwc3->base = devm_ioremap(phy_dwc3->dev, res->start, size);\n\n\tif (!phy_dwc3->base) {\n\t\tdev_err(phy_dwc3->dev, \"failed to map reg\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tphy_dwc3->ref_clk = devm_clk_get(phy_dwc3->dev, \"ref\");\n\tif (IS_ERR(phy_dwc3->ref_clk)) {\n\t\tdev_dbg(phy_dwc3->dev, \"cannot get reference clock\\n\");\n\t\treturn PTR_ERR(phy_dwc3->ref_clk);\n\t}\n\n\tclk_set_rate(phy_dwc3->ref_clk, data->clk_rate);\n\n\tphy_dwc3->xo_clk = devm_clk_get(phy_dwc3->dev, \"xo\");\n\tif (IS_ERR(phy_dwc3->xo_clk)) {\n\t\tdev_dbg(phy_dwc3->dev, \"cannot get TCXO clock\\n\");\n\t\tphy_dwc3->xo_clk = NULL;\n\t}\n\n\t \n\tif (device_property_read_u32(&pdev->dev, \"qcom,rx-eq\",\n\t\t\t\t     &phy_dwc3->rx_eq))\n\t\tphy_dwc3->rx_eq = SSPHY_RX_EQ_VALUE;\n\n\tif (device_property_read_u32(&pdev->dev, \"qcom,tx-deamp_3_5db\",\n\t\t\t\t     &phy_dwc3->tx_deamp_3_5db))\n\t\tphy_dwc3->tx_deamp_3_5db = SSPHY_TX_DEEMPH_3_5DB;\n\n\tif (device_property_read_u32(&pdev->dev, \"qcom,mpll\", &phy_dwc3->mpll))\n\t\tphy_dwc3->mpll = SSPHY_MPLL_VALUE;\n\n\tgeneric_phy = devm_phy_create(phy_dwc3->dev, pdev->dev.of_node, &data->ops);\n\n\tif (IS_ERR(generic_phy))\n\t\treturn PTR_ERR(generic_phy);\n\n\tphy_set_drvdata(generic_phy, phy_dwc3);\n\tplatform_set_drvdata(pdev, phy_dwc3);\n\n\tphy_provider = devm_of_phy_provider_register(phy_dwc3->dev,\n\t\t\t\t\t\t     of_phy_simple_xlate);\n\n\tif (IS_ERR(phy_provider))\n\t\treturn PTR_ERR(phy_provider);\n\n\treturn 0;\n}\n\nstatic struct platform_driver qcom_ipq806x_usb_phy_driver = {\n\t.probe\t\t= qcom_ipq806x_usb_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"qcom-ipq806x-usb-phy\",\n\t\t.of_match_table = qcom_ipq806x_usb_phy_table,\n\t},\n};\n\nmodule_platform_driver(qcom_ipq806x_usb_phy_driver);\n\nMODULE_ALIAS(\"platform:phy-qcom-ipq806x-usb\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Andy Gross <agross@codeaurora.org>\");\nMODULE_AUTHOR(\"Ivan T. Ivanov <iivanov@mm-sol.com>\");\nMODULE_DESCRIPTION(\"DesignWare USB3 QCOM PHY driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}