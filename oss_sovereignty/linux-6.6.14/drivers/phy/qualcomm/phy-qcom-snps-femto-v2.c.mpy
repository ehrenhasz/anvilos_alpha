{
  "module_name": "phy-qcom-snps-femto-v2.c",
  "hash_id": "8baa8550786af6a4642a9a8d3966b5d9471fdece382b4b3e4ccc18855f50e4de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-snps-femto-v2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#define USB2_PHY_USB_PHY_UTMI_CTRL0\t\t(0x3c)\n#define SLEEPM\t\t\t\t\tBIT(0)\n#define OPMODE_MASK\t\t\t\tGENMASK(4, 3)\n#define OPMODE_NORMAL\t\t\t\t(0x00)\n#define OPMODE_NONDRIVING\t\t\tBIT(3)\n#define TERMSEL\t\t\t\t\tBIT(5)\n\n#define USB2_PHY_USB_PHY_UTMI_CTRL1\t\t(0x40)\n#define XCVRSEL\t\t\t\t\tBIT(0)\n\n#define USB2_PHY_USB_PHY_UTMI_CTRL5\t\t(0x50)\n#define POR\t\t\t\t\tBIT(1)\n\n#define USB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON0\t(0x54)\n#define SIDDQ\t\t\t\t\tBIT(2)\n#define RETENABLEN\t\t\t\tBIT(3)\n#define FSEL_MASK\t\t\t\tGENMASK(6, 4)\n#define FSEL_DEFAULT\t\t\t\t(0x3 << 4)\n\n#define USB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON1\t(0x58)\n#define VBUSVLDEXTSEL0\t\t\t\tBIT(4)\n#define PLLBTUNE\t\t\t\tBIT(5)\n\n#define USB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON2\t(0x5c)\n#define VREGBYPASS\t\t\t\tBIT(0)\n\n#define USB2_PHY_USB_PHY_HS_PHY_CTRL1\t\t(0x60)\n#define VBUSVLDEXT0\t\t\t\tBIT(0)\n\n#define USB2_PHY_USB_PHY_HS_PHY_CTRL2\t\t(0x64)\n#define USB2_AUTO_RESUME\t\t\tBIT(0)\n#define USB2_SUSPEND_N\t\t\t\tBIT(2)\n#define USB2_SUSPEND_N_SEL\t\t\tBIT(3)\n\n#define USB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X0\t\t(0x6c)\n#define USB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X1\t\t(0x70)\n#define USB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X2\t\t(0x74)\n#define USB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X3\t\t(0x78)\n#define PARAM_OVRD_MASK\t\t\t\t0xFF\n\n#define USB2_PHY_USB_PHY_CFG0\t\t\t(0x94)\n#define UTMI_PHY_DATAPATH_CTRL_OVERRIDE_EN\tBIT(0)\n#define UTMI_PHY_CMN_CTRL_OVERRIDE_EN\t\tBIT(1)\n\n#define USB2_PHY_USB_PHY_REFCLK_CTRL\t\t(0xa0)\n#define REFCLK_SEL_MASK\t\t\t\tGENMASK(1, 0)\n#define REFCLK_SEL_DEFAULT\t\t\t(0x2 << 0)\n\n#define HS_DISCONNECT_MASK\t\t\tGENMASK(2, 0)\n#define SQUELCH_DETECTOR_MASK\t\t\tGENMASK(7, 5)\n\n#define HS_AMPLITUDE_MASK\t\t\tGENMASK(3, 0)\n#define PREEMPHASIS_DURATION_MASK\t\tBIT(5)\n#define PREEMPHASIS_AMPLITUDE_MASK\t\tGENMASK(7, 6)\n\n#define HS_RISE_FALL_MASK\t\t\tGENMASK(1, 0)\n#define HS_CROSSOVER_VOLTAGE_MASK\t\tGENMASK(3, 2)\n#define HS_OUTPUT_IMPEDANCE_MASK\t\tGENMASK(5, 4)\n\n#define LS_FS_OUTPUT_IMPEDANCE_MASK\t\tGENMASK(3, 0)\n\nstatic const char * const qcom_snps_hsphy_vreg_names[] = {\n\t\"vdda-pll\", \"vdda33\", \"vdda18\",\n};\n\n#define SNPS_HS_NUM_VREGS\t\tARRAY_SIZE(qcom_snps_hsphy_vreg_names)\n\nstruct override_param {\n\ts32\tvalue;\n\tu8\treg_val;\n};\n\nstruct override_param_map {\n\tconst char *prop_name;\n\tconst struct override_param *param_table;\n\tu8 table_size;\n\tu8 reg_offset;\n\tu8 param_mask;\n};\n\nstruct phy_override_seq {\n\tbool\tneed_update;\n\tu8\toffset;\n\tu8\tvalue;\n\tu8\tmask;\n};\n\n#define NUM_HSPHY_TUNING_PARAMS\t(9)\n\n \nstruct qcom_snps_hsphy {\n\tstruct device *dev;\n\n\tstruct phy *phy;\n\tvoid __iomem *base;\n\n\tint num_clks;\n\tstruct clk_bulk_data *clks;\n\tstruct reset_control *phy_reset;\n\tstruct regulator_bulk_data vregs[SNPS_HS_NUM_VREGS];\n\n\tbool phy_initialized;\n\tenum phy_mode mode;\n\tstruct phy_override_seq update_seq_cfg[NUM_HSPHY_TUNING_PARAMS];\n};\n\nstatic int qcom_snps_hsphy_clk_init(struct qcom_snps_hsphy *hsphy)\n{\n\tstruct device *dev = hsphy->dev;\n\n\thsphy->num_clks = 2;\n\thsphy->clks = devm_kcalloc(dev, hsphy->num_clks, sizeof(*hsphy->clks), GFP_KERNEL);\n\tif (!hsphy->clks)\n\t\treturn -ENOMEM;\n\n\t \n\thsphy->clks[0].id = \"cfg_ahb\";\n\thsphy->clks[0].clk = devm_clk_get_optional(dev, \"cfg_ahb\");\n\tif (IS_ERR(hsphy->clks[0].clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(hsphy->clks[0].clk),\n\t\t\t\t     \"failed to get cfg_ahb clk\\n\");\n\n\thsphy->clks[1].id = \"ref\";\n\thsphy->clks[1].clk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(hsphy->clks[1].clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(hsphy->clks[1].clk),\n\t\t\t\t     \"failed to get ref clk\\n\");\n\n\treturn 0;\n}\n\nstatic inline void qcom_snps_hsphy_write_mask(void __iomem *base, u32 offset,\n\t\t\t\t\t\tu32 mask, u32 val)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(base + offset);\n\treg &= ~mask;\n\treg |= val & mask;\n\twritel_relaxed(reg, base + offset);\n\n\t \n\treadl_relaxed(base + offset);\n}\n\nstatic int qcom_snps_hsphy_suspend(struct qcom_snps_hsphy *hsphy)\n{\n\tdev_dbg(&hsphy->phy->dev, \"Suspend QCOM SNPS PHY\\n\");\n\n\tif (hsphy->mode == PHY_MODE_USB_HOST) {\n\t\t \n\t\tqcom_snps_hsphy_write_mask(hsphy->base,\n\t\t\t\t\t   USB2_PHY_USB_PHY_HS_PHY_CTRL2,\n\t\t\t\t\t   USB2_AUTO_RESUME,\n\t\t\t\t\t   USB2_AUTO_RESUME);\n\t\tusleep_range(500, 1000);\n\t\tqcom_snps_hsphy_write_mask(hsphy->base,\n\t\t\t\t\t   USB2_PHY_USB_PHY_HS_PHY_CTRL2,\n\t\t\t\t\t   0, USB2_AUTO_RESUME);\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_snps_hsphy_resume(struct qcom_snps_hsphy *hsphy)\n{\n\tdev_dbg(&hsphy->phy->dev, \"Resume QCOM SNPS PHY, mode\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused qcom_snps_hsphy_runtime_suspend(struct device *dev)\n{\n\tstruct qcom_snps_hsphy *hsphy = dev_get_drvdata(dev);\n\n\tif (!hsphy->phy_initialized)\n\t\treturn 0;\n\n\treturn qcom_snps_hsphy_suspend(hsphy);\n}\n\nstatic int __maybe_unused qcom_snps_hsphy_runtime_resume(struct device *dev)\n{\n\tstruct qcom_snps_hsphy *hsphy = dev_get_drvdata(dev);\n\n\tif (!hsphy->phy_initialized)\n\t\treturn 0;\n\n\treturn qcom_snps_hsphy_resume(hsphy);\n}\n\nstatic int qcom_snps_hsphy_set_mode(struct phy *phy, enum phy_mode mode,\n\t\t\t\t    int submode)\n{\n\tstruct qcom_snps_hsphy *hsphy = phy_get_drvdata(phy);\n\n\thsphy->mode = mode;\n\treturn 0;\n}\n\nstatic const struct override_param hs_disconnect_sc7280[] = {\n\t{ -272, 0 },\n\t{ 0, 1 },\n\t{ 317, 2 },\n\t{ 630, 3 },\n\t{ 973, 4 },\n\t{ 1332, 5 },\n\t{ 1743, 6 },\n\t{ 2156, 7 },\n};\n\nstatic const struct override_param squelch_det_threshold_sc7280[] = {\n\t{ -2090, 7 },\n\t{ -1560, 6 },\n\t{ -1030, 5 },\n\t{ -530, 4 },\n\t{ 0, 3 },\n\t{ 530, 2 },\n\t{ 1060, 1 },\n\t{ 1590, 0 },\n};\n\nstatic const struct override_param hs_amplitude_sc7280[] = {\n\t{ -660, 0 },\n\t{ -440, 1 },\n\t{ -220, 2 },\n\t{ 0, 3 },\n\t{ 230, 4 },\n\t{ 440, 5 },\n\t{ 650, 6 },\n\t{ 890, 7 },\n\t{ 1110, 8 },\n\t{ 1330, 9 },\n\t{ 1560, 10 },\n\t{ 1780, 11 },\n\t{ 2000, 12 },\n\t{ 2220, 13 },\n\t{ 2430, 14 },\n\t{ 2670, 15 },\n};\n\nstatic const struct override_param preemphasis_duration_sc7280[] = {\n\t{ 10000, 1 },\n\t{ 20000, 0 },\n};\n\nstatic const struct override_param preemphasis_amplitude_sc7280[] = {\n\t{ 10000, 1 },\n\t{ 20000, 2 },\n\t{ 30000, 3 },\n\t{ 40000, 0 },\n};\n\nstatic const struct override_param hs_rise_fall_time_sc7280[] = {\n\t{ -4100, 3 },\n\t{ 0, 2 },\n\t{ 2810, 1 },\n\t{ 5430, 0 },\n};\n\nstatic const struct override_param hs_crossover_voltage_sc7280[] = {\n\t{ -31000, 1 },\n\t{ 0, 3 },\n\t{ 28000, 2 },\n};\n\nstatic const struct override_param hs_output_impedance_sc7280[] = {\n\t{ -2300000, 3 },\n\t{ 0, 2 },\n\t{ 2600000, 1 },\n\t{ 6100000, 0 },\n};\n\nstatic const struct override_param ls_fs_output_impedance_sc7280[] = {\n\t{ -1053, 15 },\n\t{ -557, 7 },\n\t{ 0, 3 },\n\t{ 612, 1 },\n\t{ 1310, 0 },\n};\n\nstatic const struct override_param_map sc7280_snps_7nm_phy[] = {\n\t{\n\t\t\"qcom,hs-disconnect-bp\",\n\t\ths_disconnect_sc7280,\n\t\tARRAY_SIZE(hs_disconnect_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X0,\n\t\tHS_DISCONNECT_MASK\n\t},\n\t{\n\t\t\"qcom,squelch-detector-bp\",\n\t\tsquelch_det_threshold_sc7280,\n\t\tARRAY_SIZE(squelch_det_threshold_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X0,\n\t\tSQUELCH_DETECTOR_MASK\n\t},\n\t{\n\t\t\"qcom,hs-amplitude-bp\",\n\t\ths_amplitude_sc7280,\n\t\tARRAY_SIZE(hs_amplitude_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X1,\n\t\tHS_AMPLITUDE_MASK\n\t},\n\t{\n\t\t\"qcom,pre-emphasis-duration-bp\",\n\t\tpreemphasis_duration_sc7280,\n\t\tARRAY_SIZE(preemphasis_duration_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X1,\n\t\tPREEMPHASIS_DURATION_MASK,\n\t},\n\t{\n\t\t\"qcom,pre-emphasis-amplitude-bp\",\n\t\tpreemphasis_amplitude_sc7280,\n\t\tARRAY_SIZE(preemphasis_amplitude_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X1,\n\t\tPREEMPHASIS_AMPLITUDE_MASK,\n\t},\n\t{\n\t\t\"qcom,hs-rise-fall-time-bp\",\n\t\ths_rise_fall_time_sc7280,\n\t\tARRAY_SIZE(hs_rise_fall_time_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X2,\n\t\tHS_RISE_FALL_MASK\n\t},\n\t{\n\t\t\"qcom,hs-crossover-voltage-microvolt\",\n\t\ths_crossover_voltage_sc7280,\n\t\tARRAY_SIZE(hs_crossover_voltage_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X2,\n\t\tHS_CROSSOVER_VOLTAGE_MASK\n\t},\n\t{\n\t\t\"qcom,hs-output-impedance-micro-ohms\",\n\t\ths_output_impedance_sc7280,\n\t\tARRAY_SIZE(hs_output_impedance_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X2,\n\t\tHS_OUTPUT_IMPEDANCE_MASK,\n\t},\n\t{\n\t\t\"qcom,ls-fs-output-impedance-bp\",\n\t\tls_fs_output_impedance_sc7280,\n\t\tARRAY_SIZE(ls_fs_output_impedance_sc7280),\n\t\tUSB2_PHY_USB_PHY_HS_PHY_OVERRIDE_X3,\n\t\tLS_FS_OUTPUT_IMPEDANCE_MASK,\n\t},\n\t{},\n};\n\nstatic int qcom_snps_hsphy_init(struct phy *phy)\n{\n\tstruct qcom_snps_hsphy *hsphy = phy_get_drvdata(phy);\n\tint ret, i;\n\n\tdev_vdbg(&phy->dev, \"%s(): Initializing SNPS HS phy\\n\", __func__);\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(hsphy->vregs), hsphy->vregs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(hsphy->num_clks, hsphy->clks);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"failed to enable clocks, %d\\n\", ret);\n\t\tgoto poweroff_phy;\n\t}\n\n\tret = reset_control_assert(hsphy->phy_reset);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"failed to assert phy_reset, %d\\n\", ret);\n\t\tgoto disable_clks;\n\t}\n\n\tusleep_range(100, 150);\n\n\tret = reset_control_deassert(hsphy->phy_reset);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"failed to de-assert phy_reset, %d\\n\", ret);\n\t\tgoto disable_clks;\n\t}\n\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_CFG0,\n\t\t\t\t\tUTMI_PHY_CMN_CTRL_OVERRIDE_EN,\n\t\t\t\t\tUTMI_PHY_CMN_CTRL_OVERRIDE_EN);\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_UTMI_CTRL5,\n\t\t\t\t\t\t\tPOR, POR);\n\tqcom_snps_hsphy_write_mask(hsphy->base,\n\t\t\t\t\tUSB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON0,\n\t\t\t\t\tFSEL_MASK, 0);\n\tqcom_snps_hsphy_write_mask(hsphy->base,\n\t\t\t\t\tUSB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON1,\n\t\t\t\t\tPLLBTUNE, PLLBTUNE);\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_REFCLK_CTRL,\n\t\t\t\t\tREFCLK_SEL_DEFAULT, REFCLK_SEL_MASK);\n\tqcom_snps_hsphy_write_mask(hsphy->base,\n\t\t\t\t\tUSB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON1,\n\t\t\t\t\tVBUSVLDEXTSEL0, VBUSVLDEXTSEL0);\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL1,\n\t\t\t\t\tVBUSVLDEXT0, VBUSVLDEXT0);\n\n\tfor (i = 0; i < ARRAY_SIZE(hsphy->update_seq_cfg); i++) {\n\t\tif (hsphy->update_seq_cfg[i].need_update)\n\t\t\tqcom_snps_hsphy_write_mask(hsphy->base,\n\t\t\t\t\thsphy->update_seq_cfg[i].offset,\n\t\t\t\t\thsphy->update_seq_cfg[i].mask,\n\t\t\t\t\thsphy->update_seq_cfg[i].value);\n\t}\n\n\tqcom_snps_hsphy_write_mask(hsphy->base,\n\t\t\t\t\tUSB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON2,\n\t\t\t\t\tVREGBYPASS, VREGBYPASS);\n\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL2,\n\t\t\t\t\tUSB2_SUSPEND_N_SEL | USB2_SUSPEND_N,\n\t\t\t\t\tUSB2_SUSPEND_N_SEL | USB2_SUSPEND_N);\n\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_UTMI_CTRL0,\n\t\t\t\t\tSLEEPM, SLEEPM);\n\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON0,\n\t\t\t\t   SIDDQ, 0);\n\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_UTMI_CTRL5,\n\t\t\t\t\tPOR, 0);\n\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL2,\n\t\t\t\t\tUSB2_SUSPEND_N_SEL, 0);\n\n\tqcom_snps_hsphy_write_mask(hsphy->base, USB2_PHY_USB_PHY_CFG0,\n\t\t\t\t\tUTMI_PHY_CMN_CTRL_OVERRIDE_EN, 0);\n\n\thsphy->phy_initialized = true;\n\n\treturn 0;\n\ndisable_clks:\n\tclk_bulk_disable_unprepare(hsphy->num_clks, hsphy->clks);\npoweroff_phy:\n\tregulator_bulk_disable(ARRAY_SIZE(hsphy->vregs), hsphy->vregs);\n\n\treturn ret;\n}\n\nstatic int qcom_snps_hsphy_exit(struct phy *phy)\n{\n\tstruct qcom_snps_hsphy *hsphy = phy_get_drvdata(phy);\n\n\treset_control_assert(hsphy->phy_reset);\n\tclk_bulk_disable_unprepare(hsphy->num_clks, hsphy->clks);\n\tregulator_bulk_disable(ARRAY_SIZE(hsphy->vregs), hsphy->vregs);\n\thsphy->phy_initialized = false;\n\n\treturn 0;\n}\n\nstatic const struct phy_ops qcom_snps_hsphy_gen_ops = {\n\t.init\t\t= qcom_snps_hsphy_init,\n\t.exit\t\t= qcom_snps_hsphy_exit,\n\t.set_mode\t= qcom_snps_hsphy_set_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id qcom_snps_hsphy_of_match_table[] = {\n\t{ .compatible\t= \"qcom,sm8150-usb-hs-phy\", },\n\t{ .compatible\t= \"qcom,usb-snps-hs-5nm-phy\", },\n\t{\n\t\t.compatible\t= \"qcom,usb-snps-hs-7nm-phy\",\n\t\t.data\t\t= &sc7280_snps_7nm_phy,\n\t},\n\t{ .compatible\t= \"qcom,usb-snps-femto-v2-phy\",\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_snps_hsphy_of_match_table);\n\nstatic const struct dev_pm_ops qcom_snps_hsphy_pm_ops = {\n\tSET_RUNTIME_PM_OPS(qcom_snps_hsphy_runtime_suspend,\n\t\t\t   qcom_snps_hsphy_runtime_resume, NULL)\n};\n\nstatic void qcom_snps_hsphy_override_param_update_val(\n\t\t\tconst struct override_param_map map,\n\t\t\ts32 dt_val, struct phy_override_seq *seq_entry)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < map.table_size - 1; i++) {\n\t\tif (map.param_table[i].value == dt_val)\n\t\t\tbreak;\n\t}\n\n\tseq_entry->need_update = true;\n\tseq_entry->offset = map.reg_offset;\n\tseq_entry->mask = map.param_mask;\n\tseq_entry->value = map.param_table[i].reg_val << __ffs(map.param_mask);\n}\n\nstatic void qcom_snps_hsphy_read_override_param_seq(struct device *dev)\n{\n\tstruct device_node *node = dev->of_node;\n\ts32 val;\n\tint ret, i;\n\tstruct qcom_snps_hsphy *hsphy;\n\tconst struct override_param_map *cfg = of_device_get_match_data(dev);\n\n\tif (!cfg)\n\t\treturn;\n\n\thsphy = dev_get_drvdata(dev);\n\n\tfor (i = 0; cfg[i].prop_name != NULL; i++) {\n\t\tret = of_property_read_s32(node, cfg[i].prop_name, &val);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tqcom_snps_hsphy_override_param_update_val(cfg[i], val,\n\t\t\t\t\t&hsphy->update_seq_cfg[i]);\n\t\tdev_dbg(&hsphy->phy->dev, \"Read param: %s dt_val: %d reg_val: 0x%x\\n\",\n\t\t\tcfg[i].prop_name, val, hsphy->update_seq_cfg[i].value);\n\n\t}\n}\n\nstatic int qcom_snps_hsphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_snps_hsphy *hsphy;\n\tstruct phy_provider *phy_provider;\n\tstruct phy *generic_phy;\n\tint ret, i;\n\tint num;\n\n\thsphy = devm_kzalloc(dev, sizeof(*hsphy), GFP_KERNEL);\n\tif (!hsphy)\n\t\treturn -ENOMEM;\n\n\thsphy->dev = dev;\n\n\thsphy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hsphy->base))\n\t\treturn PTR_ERR(hsphy->base);\n\n\tret = qcom_snps_hsphy_clk_init(hsphy);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to initialize clocks\\n\");\n\n\thsphy->phy_reset = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(hsphy->phy_reset)) {\n\t\tdev_err(dev, \"failed to get phy core reset\\n\");\n\t\treturn PTR_ERR(hsphy->phy_reset);\n\t}\n\n\tnum = ARRAY_SIZE(hsphy->vregs);\n\tfor (i = 0; i < num; i++)\n\t\thsphy->vregs[i].supply = qcom_snps_hsphy_vreg_names[i];\n\n\tret = devm_regulator_bulk_get(dev, num, hsphy->vregs);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to get regulator supplies\\n\");\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\t \n\tpm_runtime_forbid(dev);\n\n\tgeneric_phy = devm_phy_create(dev, NULL, &qcom_snps_hsphy_gen_ops);\n\tif (IS_ERR(generic_phy)) {\n\t\tret = PTR_ERR(generic_phy);\n\t\tdev_err(dev, \"failed to create phy, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\thsphy->phy = generic_phy;\n\n\tdev_set_drvdata(dev, hsphy);\n\tphy_set_drvdata(generic_phy, hsphy);\n\tqcom_snps_hsphy_read_override_param_seq(dev);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (!IS_ERR(phy_provider))\n\t\tdev_dbg(dev, \"Registered Qcom-SNPS HS phy\\n\");\n\telse\n\t\tpm_runtime_disable(dev);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver qcom_snps_hsphy_driver = {\n\t.probe\t\t= qcom_snps_hsphy_probe,\n\t.driver = {\n\t\t.name\t= \"qcom-snps-hs-femto-v2-phy\",\n\t\t.pm = &qcom_snps_hsphy_pm_ops,\n\t\t.of_match_table = qcom_snps_hsphy_of_match_table,\n\t},\n};\n\nmodule_platform_driver(qcom_snps_hsphy_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm SNPS FEMTO USB HS PHY V2 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}