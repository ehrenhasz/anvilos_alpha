{
  "module_name": "phy-qcom-pcie2.c",
  "hash_id": "9e1e46c02f04d33a2f4b9ac53c381d78de4be5ba2aced97b2149d55da22d4748",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/qualcomm/phy-qcom-pcie2.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <dt-bindings/phy/phy.h>\n\n#define PCIE20_PARF_PHY_STTS         0x3c\n#define PCIE2_PHY_RESET_CTRL         0x44\n#define PCIE20_PARF_PHY_REFCLK_CTRL2 0xa0\n#define PCIE20_PARF_PHY_REFCLK_CTRL3 0xa4\n#define PCIE20_PARF_PCS_SWING_CTRL1  0x88\n#define PCIE20_PARF_PCS_SWING_CTRL2  0x8c\n#define PCIE20_PARF_PCS_DEEMPH1      0x74\n#define PCIE20_PARF_PCS_DEEMPH2      0x78\n#define PCIE20_PARF_PCS_DEEMPH3      0x7c\n#define PCIE20_PARF_CONFIGBITS       0x84\n#define PCIE20_PARF_PHY_CTRL3        0x94\n#define PCIE20_PARF_PCS_CTRL         0x80\n\n#define TX_AMP_VAL                   120\n#define PHY_RX0_EQ_GEN1_VAL          0\n#define PHY_RX0_EQ_GEN2_VAL          4\n#define TX_DEEMPH_GEN1_VAL           24\n#define TX_DEEMPH_GEN2_3_5DB_VAL     26\n#define TX_DEEMPH_GEN2_6DB_VAL       36\n#define PHY_TX0_TERM_OFFST_VAL       0\n\nstruct qcom_phy {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\n\tstruct regulator_bulk_data vregs[2];\n\n\tstruct reset_control *phy_reset;\n\tstruct reset_control *pipe_reset;\n\tstruct clk *pipe_clk;\n};\n\nstatic int qcom_pcie2_phy_init(struct phy *phy)\n{\n\tstruct qcom_phy *qphy = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = reset_control_deassert(qphy->phy_reset);\n\tif (ret) {\n\t\tdev_err(qphy->dev, \"cannot deassert pipe reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(qphy->vregs), qphy->vregs);\n\tif (ret)\n\t\treset_control_assert(qphy->phy_reset);\n\n\treturn ret;\n}\n\nstatic int qcom_pcie2_phy_power_on(struct phy *phy)\n{\n\tstruct qcom_phy *qphy = phy_get_drvdata(phy);\n\tint ret;\n\tu32 val;\n\n\t \n\tval = readl(qphy->base + PCIE20_PARF_PHY_REFCLK_CTRL2);\n\tval &= ~BIT(1);\n\twritel(val, qphy->base + PCIE20_PARF_PHY_REFCLK_CTRL2);\n\n\tusleep_range(1000, 2000);\n\n\t \n\tval = readl(qphy->base + PCIE20_PARF_PHY_REFCLK_CTRL2);\n\tval &= ~BIT(0);\n\twritel(val, qphy->base + PCIE20_PARF_PHY_REFCLK_CTRL2);\n\n\t \n\tval = readl(qphy->base + PCIE20_PARF_PHY_REFCLK_CTRL3);\n\tval |= BIT(0);\n\twritel(val, qphy->base + PCIE20_PARF_PHY_REFCLK_CTRL3);\n\n\tusleep_range(1000, 2000);\n\n\t \n\tval = readl(qphy->base + PCIE2_PHY_RESET_CTRL);\n\tval |= BIT(0);\n\twritel(val, qphy->base + PCIE2_PHY_RESET_CTRL);\n\n\t \n\tval = readl(qphy->base + PCIE20_PARF_PCS_SWING_CTRL1);\n\tval &= ~0x7f;\n\tval |= TX_AMP_VAL;\n\twritel(val, qphy->base + PCIE20_PARF_PCS_SWING_CTRL1);\n\n\tval = readl(qphy->base + PCIE20_PARF_PCS_SWING_CTRL2);\n\tval &= ~0x7f;\n\tval |= TX_AMP_VAL;\n\twritel(val, qphy->base + PCIE20_PARF_PCS_SWING_CTRL2);\n\n\t \n\tval = readl(qphy->base + PCIE20_PARF_PCS_DEEMPH1);\n\tval &= ~0x3f;\n\tval |= TX_DEEMPH_GEN2_6DB_VAL;\n\twritel(val, qphy->base + PCIE20_PARF_PCS_DEEMPH1);\n\n\tval = readl(qphy->base + PCIE20_PARF_PCS_DEEMPH2);\n\tval &= ~0x3f;\n\tval |= TX_DEEMPH_GEN2_3_5DB_VAL;\n\twritel(val, qphy->base + PCIE20_PARF_PCS_DEEMPH2);\n\n\tval = readl(qphy->base + PCIE20_PARF_PCS_DEEMPH3);\n\tval &= ~0x3f;\n\tval |= TX_DEEMPH_GEN1_VAL;\n\twritel(val, qphy->base + PCIE20_PARF_PCS_DEEMPH3);\n\n\t \n\tval = readl(qphy->base + PCIE20_PARF_CONFIGBITS);\n\tval &= ~0x7;\n\tval |= PHY_RX0_EQ_GEN2_VAL;\n\twritel(val, qphy->base + PCIE20_PARF_CONFIGBITS);\n\n\t \n\tval = readl(qphy->base + PCIE20_PARF_PHY_CTRL3);\n\tval &= ~0x1f;\n\tval |= PHY_TX0_TERM_OFFST_VAL;\n\twritel(val, qphy->base + PCIE20_PARF_PHY_CTRL3);\n\n\t \n\tval = readl(qphy->base + PCIE20_PARF_PCS_CTRL);\n\tval &= ~BIT(1);\n\twritel(val, qphy->base + PCIE20_PARF_PCS_CTRL);\n\n\t \n\tval = readl(qphy->base + PCIE2_PHY_RESET_CTRL);\n\tval &= ~BIT(0);\n\twritel(val, qphy->base + PCIE2_PHY_RESET_CTRL);\n\n\tusleep_range(1000, 2000);\n\n\tret = reset_control_deassert(qphy->pipe_reset);\n\tif (ret) {\n\t\tdev_err(qphy->dev, \"cannot deassert pipe reset\\n\");\n\t\tgoto out;\n\t}\n\n\tclk_set_rate(qphy->pipe_clk, 250000000);\n\n\tret = clk_prepare_enable(qphy->pipe_clk);\n\tif (ret) {\n\t\tdev_err(qphy->dev, \"failed to enable pipe clock\\n\");\n\t\tgoto out;\n\t}\n\n\tret = readl_poll_timeout(qphy->base + PCIE20_PARF_PHY_STTS, val,\n\t\t\t\t !(val & BIT(0)), 1000, 10);\n\tif (ret)\n\t\tdev_err(qphy->dev, \"phy initialization failed\\n\");\n\nout:\n\treturn ret;\n}\n\nstatic int qcom_pcie2_phy_power_off(struct phy *phy)\n{\n\tstruct qcom_phy *qphy = phy_get_drvdata(phy);\n\tu32 val;\n\n\tval = readl(qphy->base + PCIE2_PHY_RESET_CTRL);\n\tval |= BIT(0);\n\twritel(val, qphy->base + PCIE2_PHY_RESET_CTRL);\n\n\tclk_disable_unprepare(qphy->pipe_clk);\n\treset_control_assert(qphy->pipe_reset);\n\n\treturn 0;\n}\n\nstatic int qcom_pcie2_phy_exit(struct phy *phy)\n{\n\tstruct qcom_phy *qphy = phy_get_drvdata(phy);\n\n\tregulator_bulk_disable(ARRAY_SIZE(qphy->vregs), qphy->vregs);\n\treset_control_assert(qphy->phy_reset);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops qcom_pcie2_ops = {\n\t.init = qcom_pcie2_phy_init,\n\t.power_on = qcom_pcie2_phy_power_on,\n\t.power_off = qcom_pcie2_phy_power_off,\n\t.exit = qcom_pcie2_phy_exit,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic int phy_pipe_clksrc_register(struct qcom_phy *qphy)\n{\n\tstruct device_node *np = qphy->dev->of_node;\n\tstruct clk_fixed_rate *fixed;\n\tstruct clk_init_data init = { };\n\tint ret;\n\n\tret = of_property_read_string(np, \"clock-output-names\", &init.name);\n\tif (ret) {\n\t\tdev_err(qphy->dev, \"%s: No clock-output-names\\n\", np->name);\n\t\treturn ret;\n\t}\n\n\tfixed = devm_kzalloc(qphy->dev, sizeof(*fixed), GFP_KERNEL);\n\tif (!fixed)\n\t\treturn -ENOMEM;\n\n\tinit.ops = &clk_fixed_rate_ops;\n\n\t \n\tfixed->fixed_rate = 250000000;\n\tfixed->hw.init = &init;\n\n\tret = devm_clk_hw_register(qphy->dev, &fixed->hw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_of_clk_add_hw_provider(qphy->dev, of_clk_hw_simple_get, &fixed->hw);\n}\n\nstatic int qcom_pcie2_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct qcom_phy *qphy;\n\tstruct device *dev = &pdev->dev;\n\tstruct phy *phy;\n\tint ret;\n\n\tqphy = devm_kzalloc(dev, sizeof(*qphy), GFP_KERNEL);\n\tif (!qphy)\n\t\treturn -ENOMEM;\n\n\tqphy->dev = dev;\n\tqphy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qphy->base))\n\t\treturn PTR_ERR(qphy->base);\n\n\tret = phy_pipe_clksrc_register(qphy);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register pipe_clk\\n\");\n\t\treturn ret;\n\t}\n\n\tqphy->vregs[0].supply = \"vdda-vp\";\n\tqphy->vregs[1].supply = \"vdda-vph\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(qphy->vregs), qphy->vregs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tqphy->pipe_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(qphy->pipe_clk)) {\n\t\tdev_err(dev, \"failed to acquire pipe clock\\n\");\n\t\treturn PTR_ERR(qphy->pipe_clk);\n\t}\n\n\tqphy->phy_reset = devm_reset_control_get_exclusive(dev, \"phy\");\n\tif (IS_ERR(qphy->phy_reset)) {\n\t\tdev_err(dev, \"failed to acquire phy reset\\n\");\n\t\treturn PTR_ERR(qphy->phy_reset);\n\t}\n\n\tqphy->pipe_reset = devm_reset_control_get_exclusive(dev, \"pipe\");\n\tif (IS_ERR(qphy->pipe_reset)) {\n\t\tdev_err(dev, \"failed to acquire pipe reset\\n\");\n\t\treturn PTR_ERR(qphy->pipe_reset);\n\t}\n\n\tphy = devm_phy_create(dev, dev->of_node, &qcom_pcie2_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"failed to create phy\\n\");\n\t\treturn PTR_ERR(phy);\n\t}\n\n\tphy_set_drvdata(phy, qphy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(phy_provider))\n\t\tdev_err(dev, \"failed to register phy provider\\n\");\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct of_device_id qcom_pcie2_phy_match_table[] = {\n\t{ .compatible = \"qcom,pcie2-phy\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_pcie2_phy_match_table);\n\nstatic struct platform_driver qcom_pcie2_phy_driver = {\n\t.probe = qcom_pcie2_phy_probe,\n\t.driver = {\n\t\t.name = \"phy-qcom-pcie2\",\n\t\t.of_match_table = qcom_pcie2_phy_match_table,\n\t},\n};\n\nmodule_platform_driver(qcom_pcie2_phy_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm PCIe PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}