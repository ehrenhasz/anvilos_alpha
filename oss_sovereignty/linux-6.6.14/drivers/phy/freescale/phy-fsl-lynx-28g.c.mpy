{
  "module_name": "phy-fsl-lynx-28g.c",
  "hash_id": "b428600bdd74d5be8e87fda8fab4c46af55bbf2eff3dd33bbfd1146e4f571c35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/freescale/phy-fsl-lynx-28g.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n\n#define LYNX_28G_NUM_LANE\t\t\t8\n#define LYNX_28G_NUM_PLL\t\t\t2\n\n \n#define LYNX_28G_PCC8\t\t\t\t0x10a0\n#define LYNX_28G_PCC8_SGMII\t\t\t0x1\n#define LYNX_28G_PCC8_SGMII_DIS\t\t\t0x0\n\n#define LYNX_28G_PCCC\t\t\t\t0x10b0\n#define LYNX_28G_PCCC_10GBASER\t\t\t0x9\n#define LYNX_28G_PCCC_USXGMII\t\t\t0x1\n#define LYNX_28G_PCCC_SXGMII_DIS\t\t0x0\n\n#define LYNX_28G_LNa_PCC_OFFSET(lane)\t\t(4 * (LYNX_28G_NUM_LANE - (lane->id) - 1))\n\n \n#define LYNX_28G_PLLnRSTCTL(pll)\t\t(0x400 + (pll) * 0x100 + 0x0)\n#define LYNX_28G_PLLnRSTCTL_DIS(rstctl)\t\t(((rstctl) & BIT(24)) >> 24)\n#define LYNX_28G_PLLnRSTCTL_LOCK(rstctl)\t(((rstctl) & BIT(23)) >> 23)\n\n#define LYNX_28G_PLLnCR0(pll)\t\t\t(0x400 + (pll) * 0x100 + 0x4)\n#define LYNX_28G_PLLnCR0_REFCLK_SEL(cr0)\t(((cr0) & GENMASK(20, 16)))\n#define LYNX_28G_PLLnCR0_REFCLK_SEL_100MHZ\t0x0\n#define LYNX_28G_PLLnCR0_REFCLK_SEL_125MHZ\t0x10000\n#define LYNX_28G_PLLnCR0_REFCLK_SEL_156MHZ\t0x20000\n#define LYNX_28G_PLLnCR0_REFCLK_SEL_150MHZ\t0x30000\n#define LYNX_28G_PLLnCR0_REFCLK_SEL_161MHZ\t0x40000\n\n#define LYNX_28G_PLLnCR1(pll)\t\t\t(0x400 + (pll) * 0x100 + 0x8)\n#define LYNX_28G_PLLnCR1_FRATE_SEL(cr1)\t\t(((cr1) & GENMASK(28, 24)))\n#define LYNX_28G_PLLnCR1_FRATE_5G_10GVCO\t0x0\n#define LYNX_28G_PLLnCR1_FRATE_5G_25GVCO\t0x10000000\n#define LYNX_28G_PLLnCR1_FRATE_10G_20GVCO\t0x6000000\n\n \n \n#define LYNX_28G_LNaGCR0(lane)\t\t\t(0x800 + (lane) * 0x100 + 0x0)\n#define LYNX_28G_LNaGCR0_PROTO_SEL_MSK\t\tGENMASK(7, 3)\n#define LYNX_28G_LNaGCR0_PROTO_SEL_SGMII\t0x8\n#define LYNX_28G_LNaGCR0_PROTO_SEL_XFI\t\t0x50\n#define LYNX_28G_LNaGCR0_IF_WIDTH_MSK\t\tGENMASK(2, 0)\n#define LYNX_28G_LNaGCR0_IF_WIDTH_10_BIT\t0x0\n#define LYNX_28G_LNaGCR0_IF_WIDTH_20_BIT\t0x2\n\n \n#define LYNX_28G_LNaTRSTCTL(lane)\t\t(0x800 + (lane) * 0x100 + 0x20)\n#define LYNX_28G_LNaTRSTCTL_HLT_REQ\t\tBIT(27)\n#define LYNX_28G_LNaTRSTCTL_RST_DONE\t\tBIT(30)\n#define LYNX_28G_LNaTRSTCTL_RST_REQ\t\tBIT(31)\n\n \n#define LYNX_28G_LNaTGCR0(lane)\t\t\t(0x800 + (lane) * 0x100 + 0x24)\n#define LYNX_28G_LNaTGCR0_USE_PLLF\t\t0x0\n#define LYNX_28G_LNaTGCR0_USE_PLLS\t\tBIT(28)\n#define LYNX_28G_LNaTGCR0_USE_PLL_MSK\t\tBIT(28)\n#define LYNX_28G_LNaTGCR0_N_RATE_FULL\t\t0x0\n#define LYNX_28G_LNaTGCR0_N_RATE_HALF\t\t0x1000000\n#define LYNX_28G_LNaTGCR0_N_RATE_QUARTER\t0x2000000\n#define LYNX_28G_LNaTGCR0_N_RATE_MSK\t\tGENMASK(26, 24)\n\n#define LYNX_28G_LNaTECR0(lane)\t\t\t(0x800 + (lane) * 0x100 + 0x30)\n\n \n#define LYNX_28G_LNaRRSTCTL(lane)\t\t(0x800 + (lane) * 0x100 + 0x40)\n#define LYNX_28G_LNaRRSTCTL_HLT_REQ\t\tBIT(27)\n#define LYNX_28G_LNaRRSTCTL_RST_DONE\t\tBIT(30)\n#define LYNX_28G_LNaRRSTCTL_RST_REQ\t\tBIT(31)\n#define LYNX_28G_LNaRRSTCTL_CDR_LOCK\t\tBIT(12)\n\n \n#define LYNX_28G_LNaRGCR0(lane)\t\t\t(0x800 + (lane) * 0x100 + 0x44)\n#define LYNX_28G_LNaRGCR0_USE_PLLF\t\t0x0\n#define LYNX_28G_LNaRGCR0_USE_PLLS\t\tBIT(28)\n#define LYNX_28G_LNaRGCR0_USE_PLL_MSK\t\tBIT(28)\n#define LYNX_28G_LNaRGCR0_N_RATE_MSK\t\tGENMASK(26, 24)\n#define LYNX_28G_LNaRGCR0_N_RATE_FULL\t\t0x0\n#define LYNX_28G_LNaRGCR0_N_RATE_HALF\t\t0x1000000\n#define LYNX_28G_LNaRGCR0_N_RATE_QUARTER\t0x2000000\n#define LYNX_28G_LNaRGCR0_N_RATE_MSK\t\tGENMASK(26, 24)\n\n#define LYNX_28G_LNaRGCR1(lane)\t\t\t(0x800 + (lane) * 0x100 + 0x48)\n\n#define LYNX_28G_LNaRECR0(lane)\t\t\t(0x800 + (lane) * 0x100 + 0x50)\n#define LYNX_28G_LNaRECR1(lane)\t\t\t(0x800 + (lane) * 0x100 + 0x54)\n#define LYNX_28G_LNaRECR2(lane)\t\t\t(0x800 + (lane) * 0x100 + 0x58)\n\n#define LYNX_28G_LNaRSCCR0(lane)\t\t(0x800 + (lane) * 0x100 + 0x74)\n\n#define LYNX_28G_LNaPSS(lane)\t\t\t(0x1000 + (lane) * 0x4)\n#define LYNX_28G_LNaPSS_TYPE(pss)\t\t(((pss) & GENMASK(30, 24)) >> 24)\n#define LYNX_28G_LNaPSS_TYPE_SGMII\t\t0x4\n#define LYNX_28G_LNaPSS_TYPE_XFI\t\t0x28\n\n#define LYNX_28G_SGMIIaCR1(lane)\t\t(0x1804 + (lane) * 0x10)\n#define LYNX_28G_SGMIIaCR1_SGPCS_EN\t\tBIT(11)\n#define LYNX_28G_SGMIIaCR1_SGPCS_DIS\t\t0x0\n#define LYNX_28G_SGMIIaCR1_SGPCS_MSK\t\tBIT(11)\n\nstruct lynx_28g_priv;\n\nstruct lynx_28g_pll {\n\tstruct lynx_28g_priv *priv;\n\tu32 rstctl, cr0, cr1;\n\tint id;\n\tDECLARE_PHY_INTERFACE_MASK(supported);\n};\n\nstruct lynx_28g_lane {\n\tstruct lynx_28g_priv *priv;\n\tstruct phy *phy;\n\tbool powered_up;\n\tbool init;\n\tunsigned int id;\n\tphy_interface_t interface;\n};\n\nstruct lynx_28g_priv {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\t \n\tspinlock_t pcc_lock;\n\tstruct lynx_28g_pll pll[LYNX_28G_NUM_PLL];\n\tstruct lynx_28g_lane lane[LYNX_28G_NUM_LANE];\n\n\tstruct delayed_work cdr_check;\n};\n\nstatic void lynx_28g_rmw(struct lynx_28g_priv *priv, unsigned long off,\n\t\t\t u32 val, u32 mask)\n{\n\tvoid __iomem *reg = priv->base + off;\n\tu32 orig, tmp;\n\n\torig = ioread32(reg);\n\ttmp = orig & ~mask;\n\ttmp |= val;\n\tiowrite32(tmp, reg);\n}\n\n#define lynx_28g_lane_rmw(lane, reg, val, mask)\t\\\n\tlynx_28g_rmw((lane)->priv, LYNX_28G_##reg(lane->id), \\\n\t\t     LYNX_28G_##reg##_##val, LYNX_28G_##reg##_##mask)\n#define lynx_28g_lane_read(lane, reg)\t\t\t\\\n\tioread32((lane)->priv->base + LYNX_28G_##reg((lane)->id))\n#define lynx_28g_pll_read(pll, reg)\t\t\t\\\n\tioread32((pll)->priv->base + LYNX_28G_##reg((pll)->id))\n\nstatic bool lynx_28g_supports_interface(struct lynx_28g_priv *priv, int intf)\n{\n\tint i;\n\n\tfor (i = 0; i < LYNX_28G_NUM_PLL; i++) {\n\t\tif (LYNX_28G_PLLnRSTCTL_DIS(priv->pll[i].rstctl))\n\t\t\tcontinue;\n\n\t\tif (test_bit(intf, priv->pll[i].supported))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct lynx_28g_pll *lynx_28g_pll_get(struct lynx_28g_priv *priv,\n\t\t\t\t\t     phy_interface_t intf)\n{\n\tstruct lynx_28g_pll *pll;\n\tint i;\n\n\tfor (i = 0; i < LYNX_28G_NUM_PLL; i++) {\n\t\tpll = &priv->pll[i];\n\n\t\tif (LYNX_28G_PLLnRSTCTL_DIS(pll->rstctl))\n\t\t\tcontinue;\n\n\t\tif (test_bit(intf, pll->supported))\n\t\t\treturn pll;\n\t}\n\n\treturn NULL;\n}\n\nstatic void lynx_28g_lane_set_nrate(struct lynx_28g_lane *lane,\n\t\t\t\t    struct lynx_28g_pll *pll,\n\t\t\t\t    phy_interface_t intf)\n{\n\tswitch (LYNX_28G_PLLnCR1_FRATE_SEL(pll->cr1)) {\n\tcase LYNX_28G_PLLnCR1_FRATE_5G_10GVCO:\n\tcase LYNX_28G_PLLnCR1_FRATE_5G_25GVCO:\n\t\tswitch (intf) {\n\t\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\t\tlynx_28g_lane_rmw(lane, LNaTGCR0, N_RATE_QUARTER, N_RATE_MSK);\n\t\t\tlynx_28g_lane_rmw(lane, LNaRGCR0, N_RATE_QUARTER, N_RATE_MSK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase LYNX_28G_PLLnCR1_FRATE_10G_20GVCO:\n\t\tswitch (intf) {\n\t\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\t\tlynx_28g_lane_rmw(lane, LNaTGCR0, N_RATE_FULL, N_RATE_MSK);\n\t\t\tlynx_28g_lane_rmw(lane, LNaRGCR0, N_RATE_FULL, N_RATE_MSK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void lynx_28g_lane_set_pll(struct lynx_28g_lane *lane,\n\t\t\t\t  struct lynx_28g_pll *pll)\n{\n\tif (pll->id == 0) {\n\t\tlynx_28g_lane_rmw(lane, LNaTGCR0, USE_PLLF, USE_PLL_MSK);\n\t\tlynx_28g_lane_rmw(lane, LNaRGCR0, USE_PLLF, USE_PLL_MSK);\n\t} else {\n\t\tlynx_28g_lane_rmw(lane, LNaTGCR0, USE_PLLS, USE_PLL_MSK);\n\t\tlynx_28g_lane_rmw(lane, LNaRGCR0, USE_PLLS, USE_PLL_MSK);\n\t}\n}\n\nstatic void lynx_28g_cleanup_lane(struct lynx_28g_lane *lane)\n{\n\tu32 lane_offset = LYNX_28G_LNa_PCC_OFFSET(lane);\n\tstruct lynx_28g_priv *priv = lane->priv;\n\n\t \n\tswitch (lane->interface) {\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tlynx_28g_rmw(priv, LYNX_28G_PCCC,\n\t\t\t     LYNX_28G_PCCC_SXGMII_DIS << lane_offset,\n\t\t\t     GENMASK(3, 0) << lane_offset);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tlynx_28g_rmw(priv, LYNX_28G_PCC8,\n\t\t\t     LYNX_28G_PCC8_SGMII_DIS << lane_offset,\n\t\t\t     GENMASK(3, 0) << lane_offset);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void lynx_28g_lane_set_sgmii(struct lynx_28g_lane *lane)\n{\n\tu32 lane_offset = LYNX_28G_LNa_PCC_OFFSET(lane);\n\tstruct lynx_28g_priv *priv = lane->priv;\n\tstruct lynx_28g_pll *pll;\n\n\tlynx_28g_cleanup_lane(lane);\n\n\t \n\tlynx_28g_rmw(priv, LYNX_28G_PCC8,\n\t\t     LYNX_28G_PCC8_SGMII << lane_offset,\n\t\t     GENMASK(3, 0) << lane_offset);\n\n\t \n\tlynx_28g_lane_rmw(lane, LNaGCR0, PROTO_SEL_SGMII, PROTO_SEL_MSK);\n\tlynx_28g_lane_rmw(lane, LNaGCR0, IF_WIDTH_10_BIT, IF_WIDTH_MSK);\n\n\t \n\tpll = lynx_28g_pll_get(priv, PHY_INTERFACE_MODE_SGMII);\n\tlynx_28g_lane_set_pll(lane, pll);\n\n\t \n\tlynx_28g_lane_set_nrate(lane, pll, PHY_INTERFACE_MODE_SGMII);\n\n\t \n\tlynx_28g_lane_rmw(lane, SGMIIaCR1, SGPCS_EN, SGPCS_MSK);\n\n\t \n\tiowrite32(0x00808006, priv->base + LYNX_28G_LNaTECR0(lane->id));\n\tiowrite32(0x04310000, priv->base + LYNX_28G_LNaRGCR1(lane->id));\n\tiowrite32(0x9f800000, priv->base + LYNX_28G_LNaRECR0(lane->id));\n\tiowrite32(0x001f0000, priv->base + LYNX_28G_LNaRECR1(lane->id));\n\tiowrite32(0x00000000, priv->base + LYNX_28G_LNaRECR2(lane->id));\n\tiowrite32(0x00000000, priv->base + LYNX_28G_LNaRSCCR0(lane->id));\n}\n\nstatic void lynx_28g_lane_set_10gbaser(struct lynx_28g_lane *lane)\n{\n\tu32 lane_offset = LYNX_28G_LNa_PCC_OFFSET(lane);\n\tstruct lynx_28g_priv *priv = lane->priv;\n\tstruct lynx_28g_pll *pll;\n\n\tlynx_28g_cleanup_lane(lane);\n\n\t \n\tlynx_28g_rmw(priv, LYNX_28G_PCCC,\n\t\t     LYNX_28G_PCCC_10GBASER << lane_offset,\n\t\t     GENMASK(3, 0) << lane_offset);\n\n\t \n\tlynx_28g_lane_rmw(lane, LNaGCR0, PROTO_SEL_XFI, PROTO_SEL_MSK);\n\tlynx_28g_lane_rmw(lane, LNaGCR0, IF_WIDTH_20_BIT, IF_WIDTH_MSK);\n\n\t \n\tpll = lynx_28g_pll_get(priv, PHY_INTERFACE_MODE_10GBASER);\n\tlynx_28g_lane_set_pll(lane, pll);\n\n\t \n\tlynx_28g_lane_set_nrate(lane, pll, PHY_INTERFACE_MODE_10GBASER);\n\n\t \n\tlynx_28g_lane_rmw(lane, SGMIIaCR1, SGPCS_DIS, SGPCS_MSK);\n\n\t \n\tiowrite32(0x10808307, priv->base + LYNX_28G_LNaTECR0(lane->id));\n\tiowrite32(0x10000000, priv->base + LYNX_28G_LNaRGCR1(lane->id));\n\tiowrite32(0x00000000, priv->base + LYNX_28G_LNaRECR0(lane->id));\n\tiowrite32(0x001f0000, priv->base + LYNX_28G_LNaRECR1(lane->id));\n\tiowrite32(0x81000020, priv->base + LYNX_28G_LNaRECR2(lane->id));\n\tiowrite32(0x00002000, priv->base + LYNX_28G_LNaRSCCR0(lane->id));\n}\n\nstatic int lynx_28g_power_off(struct phy *phy)\n{\n\tstruct lynx_28g_lane *lane = phy_get_drvdata(phy);\n\tu32 trstctl, rrstctl;\n\n\tif (!lane->powered_up)\n\t\treturn 0;\n\n\t \n\tlynx_28g_lane_rmw(lane, LNaTRSTCTL, HLT_REQ, HLT_REQ);\n\tlynx_28g_lane_rmw(lane, LNaRRSTCTL, HLT_REQ, HLT_REQ);\n\n\t \n\tdo {\n\t\ttrstctl = lynx_28g_lane_read(lane, LNaTRSTCTL);\n\t\trrstctl = lynx_28g_lane_read(lane, LNaRRSTCTL);\n\t} while ((trstctl & LYNX_28G_LNaTRSTCTL_HLT_REQ) ||\n\t\t (rrstctl & LYNX_28G_LNaRRSTCTL_HLT_REQ));\n\n\tlane->powered_up = false;\n\n\treturn 0;\n}\n\nstatic int lynx_28g_power_on(struct phy *phy)\n{\n\tstruct lynx_28g_lane *lane = phy_get_drvdata(phy);\n\tu32 trstctl, rrstctl;\n\n\tif (lane->powered_up)\n\t\treturn 0;\n\n\t \n\tlynx_28g_lane_rmw(lane, LNaTRSTCTL, RST_REQ, RST_REQ);\n\tlynx_28g_lane_rmw(lane, LNaRRSTCTL, RST_REQ, RST_REQ);\n\n\t \n\tdo {\n\t\ttrstctl = lynx_28g_lane_read(lane, LNaTRSTCTL);\n\t\trrstctl = lynx_28g_lane_read(lane, LNaRRSTCTL);\n\t} while (!(trstctl & LYNX_28G_LNaTRSTCTL_RST_DONE) ||\n\t\t !(rrstctl & LYNX_28G_LNaRRSTCTL_RST_DONE));\n\n\tlane->powered_up = true;\n\n\treturn 0;\n}\n\nstatic int lynx_28g_set_mode(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tstruct lynx_28g_lane *lane = phy_get_drvdata(phy);\n\tstruct lynx_28g_priv *priv = lane->priv;\n\tint powered_up = lane->powered_up;\n\tint err = 0;\n\n\tif (mode != PHY_MODE_ETHERNET)\n\t\treturn -EOPNOTSUPP;\n\n\tif (lane->interface == PHY_INTERFACE_MODE_NA)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!lynx_28g_supports_interface(priv, submode))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (powered_up)\n\t\tlynx_28g_power_off(phy);\n\n\tspin_lock(&priv->pcc_lock);\n\n\tswitch (submode) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tlynx_28g_lane_set_sgmii(lane);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tlynx_28g_lane_set_10gbaser(lane);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tlane->interface = submode;\n\nout:\n\tspin_unlock(&priv->pcc_lock);\n\n\t \n\tif (powered_up)\n\t\tlynx_28g_power_on(phy);\n\n\treturn err;\n}\n\nstatic int lynx_28g_validate(struct phy *phy, enum phy_mode mode, int submode,\n\t\t\t     union phy_configure_opts *opts __always_unused)\n{\n\tstruct lynx_28g_lane *lane = phy_get_drvdata(phy);\n\tstruct lynx_28g_priv *priv = lane->priv;\n\n\tif (mode != PHY_MODE_ETHERNET)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!lynx_28g_supports_interface(priv, submode))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int lynx_28g_init(struct phy *phy)\n{\n\tstruct lynx_28g_lane *lane = phy_get_drvdata(phy);\n\n\t \n\tlane->init = true;\n\n\t \n\tlane->powered_up = true;\n\tlynx_28g_power_off(phy);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops lynx_28g_ops = {\n\t.init\t\t= lynx_28g_init,\n\t.power_on\t= lynx_28g_power_on,\n\t.power_off\t= lynx_28g_power_off,\n\t.set_mode\t= lynx_28g_set_mode,\n\t.validate\t= lynx_28g_validate,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void lynx_28g_pll_read_configuration(struct lynx_28g_priv *priv)\n{\n\tstruct lynx_28g_pll *pll;\n\tint i;\n\n\tfor (i = 0; i < LYNX_28G_NUM_PLL; i++) {\n\t\tpll = &priv->pll[i];\n\t\tpll->priv = priv;\n\t\tpll->id = i;\n\n\t\tpll->rstctl = lynx_28g_pll_read(pll, PLLnRSTCTL);\n\t\tpll->cr0 = lynx_28g_pll_read(pll, PLLnCR0);\n\t\tpll->cr1 = lynx_28g_pll_read(pll, PLLnCR1);\n\n\t\tif (LYNX_28G_PLLnRSTCTL_DIS(pll->rstctl))\n\t\t\tcontinue;\n\n\t\tswitch (LYNX_28G_PLLnCR1_FRATE_SEL(pll->cr1)) {\n\t\tcase LYNX_28G_PLLnCR1_FRATE_5G_10GVCO:\n\t\tcase LYNX_28G_PLLnCR1_FRATE_5G_25GVCO:\n\t\t\t \n\t\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, pll->supported);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_SGMII, pll->supported);\n\t\t\tbreak;\n\t\tcase LYNX_28G_PLLnCR1_FRATE_10G_20GVCO:\n\t\t\t \n\t\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, pll->supported);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n#define work_to_lynx(w) container_of((w), struct lynx_28g_priv, cdr_check.work)\n\nstatic void lynx_28g_cdr_lock_check(struct work_struct *work)\n{\n\tstruct lynx_28g_priv *priv = work_to_lynx(work);\n\tstruct lynx_28g_lane *lane;\n\tu32 rrstctl;\n\tint i;\n\n\tfor (i = 0; i < LYNX_28G_NUM_LANE; i++) {\n\t\tlane = &priv->lane[i];\n\n\t\tmutex_lock(&lane->phy->mutex);\n\n\t\tif (!lane->init || !lane->powered_up) {\n\t\t\tmutex_unlock(&lane->phy->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\trrstctl = lynx_28g_lane_read(lane, LNaRRSTCTL);\n\t\tif (!(rrstctl & LYNX_28G_LNaRRSTCTL_CDR_LOCK)) {\n\t\t\tlynx_28g_lane_rmw(lane, LNaRRSTCTL, RST_REQ, RST_REQ);\n\t\t\tdo {\n\t\t\t\trrstctl = lynx_28g_lane_read(lane, LNaRRSTCTL);\n\t\t\t} while (!(rrstctl & LYNX_28G_LNaRRSTCTL_RST_DONE));\n\t\t}\n\n\t\tmutex_unlock(&lane->phy->mutex);\n\t}\n\tqueue_delayed_work(system_power_efficient_wq, &priv->cdr_check,\n\t\t\t   msecs_to_jiffies(1000));\n}\n\nstatic void lynx_28g_lane_read_configuration(struct lynx_28g_lane *lane)\n{\n\tu32 pss, protocol;\n\n\tpss = lynx_28g_lane_read(lane, LNaPSS);\n\tprotocol = LYNX_28G_LNaPSS_TYPE(pss);\n\tswitch (protocol) {\n\tcase LYNX_28G_LNaPSS_TYPE_SGMII:\n\t\tlane->interface = PHY_INTERFACE_MODE_SGMII;\n\t\tbreak;\n\tcase LYNX_28G_LNaPSS_TYPE_XFI:\n\t\tlane->interface = PHY_INTERFACE_MODE_10GBASER;\n\t\tbreak;\n\tdefault:\n\t\tlane->interface = PHY_INTERFACE_MODE_NA;\n\t}\n}\n\nstatic struct phy *lynx_28g_xlate(struct device *dev,\n\t\t\t\t  struct of_phandle_args *args)\n{\n\tstruct lynx_28g_priv *priv = dev_get_drvdata(dev);\n\tint idx = args->args[0];\n\n\tif (WARN_ON(idx >= LYNX_28G_NUM_LANE))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn priv->lane[idx].phy;\n}\n\nstatic int lynx_28g_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *provider;\n\tstruct lynx_28g_priv *priv;\n\tint i;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dev = &pdev->dev;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tlynx_28g_pll_read_configuration(priv);\n\n\tfor (i = 0; i < LYNX_28G_NUM_LANE; i++) {\n\t\tstruct lynx_28g_lane *lane = &priv->lane[i];\n\t\tstruct phy *phy;\n\n\t\tmemset(lane, 0, sizeof(*lane));\n\n\t\tphy = devm_phy_create(&pdev->dev, NULL, &lynx_28g_ops);\n\t\tif (IS_ERR(phy))\n\t\t\treturn PTR_ERR(phy);\n\n\t\tlane->priv = priv;\n\t\tlane->phy = phy;\n\t\tlane->id = i;\n\t\tphy_set_drvdata(phy, lane);\n\t\tlynx_28g_lane_read_configuration(lane);\n\t}\n\n\tdev_set_drvdata(dev, priv);\n\n\tspin_lock_init(&priv->pcc_lock);\n\tINIT_DELAYED_WORK(&priv->cdr_check, lynx_28g_cdr_lock_check);\n\n\tqueue_delayed_work(system_power_efficient_wq, &priv->cdr_check,\n\t\t\t   msecs_to_jiffies(1000));\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\tprovider = devm_of_phy_provider_register(&pdev->dev, lynx_28g_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}\n\nstatic void lynx_28g_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct lynx_28g_priv *priv = dev_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&priv->cdr_check);\n}\n\nstatic const struct of_device_id lynx_28g_of_match_table[] = {\n\t{ .compatible = \"fsl,lynx-28g\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lynx_28g_of_match_table);\n\nstatic struct platform_driver lynx_28g_driver = {\n\t.probe\t= lynx_28g_probe,\n\t.remove_new = lynx_28g_remove,\n\t.driver\t= {\n\t\t.name = \"lynx-28g\",\n\t\t.of_match_table = lynx_28g_of_match_table,\n\t},\n};\nmodule_platform_driver(lynx_28g_driver);\n\nMODULE_AUTHOR(\"Ioana Ciornei <ioana.ciornei@nxp.com>\");\nMODULE_DESCRIPTION(\"Lynx 28G SerDes PHY driver for Layerscape SoCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}