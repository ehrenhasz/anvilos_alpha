{
  "module_name": "phy-fsl-imx8mq-usb.c",
  "hash_id": "0b6096376e6b21b4260cb70eec8ce0a24820f941a83a31990de02f6bf05eade2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/freescale/phy-fsl-imx8mq-usb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#define PHY_CTRL0\t\t\t0x0\n#define PHY_CTRL0_REF_SSP_EN\t\tBIT(2)\n#define PHY_CTRL0_FSEL_MASK\t\tGENMASK(10, 5)\n#define PHY_CTRL0_FSEL_24M\t\t0x2a\n\n#define PHY_CTRL1\t\t\t0x4\n#define PHY_CTRL1_RESET\t\t\tBIT(0)\n#define PHY_CTRL1_COMMONONN\t\tBIT(1)\n#define PHY_CTRL1_ATERESET\t\tBIT(3)\n#define PHY_CTRL1_VDATSRCENB0\t\tBIT(19)\n#define PHY_CTRL1_VDATDETENB0\t\tBIT(20)\n\n#define PHY_CTRL2\t\t\t0x8\n#define PHY_CTRL2_TXENABLEN0\t\tBIT(8)\n#define PHY_CTRL2_OTG_DISABLE\t\tBIT(9)\n\n#define PHY_CTRL3\t\t\t0xc\n#define PHY_CTRL3_COMPDISTUNE_MASK\tGENMASK(2, 0)\n#define PHY_CTRL3_TXPREEMP_TUNE_MASK\tGENMASK(16, 15)\n#define PHY_CTRL3_TXRISE_TUNE_MASK\tGENMASK(21, 20)\n#define PHY_CTRL3_TXVREF_TUNE_MASK\tGENMASK(25, 22)\n#define PHY_CTRL3_TX_VBOOST_LEVEL_MASK\tGENMASK(31, 29)\n\n#define PHY_CTRL4\t\t\t0x10\n#define PHY_CTRL4_PCS_TX_DEEMPH_3P5DB_MASK\tGENMASK(20, 15)\n\n#define PHY_CTRL5\t\t\t0x14\n#define PHY_CTRL5_DMPWD_OVERRIDE_SEL\tBIT(23)\n#define PHY_CTRL5_DMPWD_OVERRIDE\tBIT(22)\n#define PHY_CTRL5_DPPWD_OVERRIDE_SEL\tBIT(21)\n#define PHY_CTRL5_DPPWD_OVERRIDE\tBIT(20)\n#define PHY_CTRL5_PCS_TX_SWING_FULL_MASK\tGENMASK(6, 0)\n\n#define PHY_CTRL6\t\t\t0x18\n#define PHY_CTRL6_ALT_CLK_EN\t\tBIT(1)\n#define PHY_CTRL6_ALT_CLK_SEL\t\tBIT(0)\n\n#define PHY_TUNE_DEFAULT\t\t0xffffffff\n\nstruct imx8mq_usb_phy {\n\tstruct phy *phy;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tstruct regulator *vbus;\n\tu32 pcs_tx_swing_full;\n\tu32 pcs_tx_deemph_3p5db;\n\tu32 tx_vref_tune;\n\tu32 tx_rise_tune;\n\tu32 tx_preemp_amp_tune;\n\tu32 tx_vboost_level;\n\tu32 comp_dis_tune;\n};\n\nstatic u32 phy_tx_vref_tune_from_property(u32 percent)\n{\n\tpercent = clamp(percent, 94U, 124U);\n\n\treturn DIV_ROUND_CLOSEST(percent - 94U, 2);\n}\n\nstatic u32 phy_tx_rise_tune_from_property(u32 percent)\n{\n\tswitch (percent) {\n\tcase 0 ... 98:\n\t\treturn 3;\n\tcase 99:\n\t\treturn 2;\n\tcase 100 ... 101:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u32 phy_tx_preemp_amp_tune_from_property(u32 microamp)\n{\n\tmicroamp = min(microamp, 1800U);\n\n\treturn microamp / 600;\n}\n\nstatic u32 phy_tx_vboost_level_from_property(u32 microvolt)\n{\n\tswitch (microvolt) {\n\tcase 0 ... 960:\n\t\treturn 0;\n\tcase 961 ... 1160:\n\t\treturn 2;\n\tdefault:\n\t\treturn 3;\n\t}\n}\n\nstatic u32 phy_pcs_tx_deemph_3p5db_from_property(u32 decibel)\n{\n\treturn min(decibel, 36U);\n}\n\nstatic u32 phy_comp_dis_tune_from_property(u32 percent)\n{\n\tswitch (percent) {\n\tcase 0 ... 92:\n\t\treturn 0;\n\tcase 93 ... 95:\n\t\treturn 1;\n\tcase 96 ... 97:\n\t\treturn 2;\n\tcase 98 ... 102:\n\t\treturn 3;\n\tcase 103 ... 105:\n\t\treturn 4;\n\tcase 106 ... 109:\n\t\treturn 5;\n\tcase 110 ... 113:\n\t\treturn 6;\n\tdefault:\n\t\treturn 7;\n\t}\n}\nstatic u32 phy_pcs_tx_swing_full_from_property(u32 percent)\n{\n\tpercent = min(percent, 100U);\n\n\treturn (percent * 127) / 100;\n}\n\nstatic void imx8m_get_phy_tuning_data(struct imx8mq_usb_phy *imx_phy)\n{\n\tstruct device *dev = imx_phy->phy->dev.parent;\n\n\tif (device_property_read_u32(dev, \"fsl,phy-tx-vref-tune-percent\",\n\t\t\t\t     &imx_phy->tx_vref_tune))\n\t\timx_phy->tx_vref_tune = PHY_TUNE_DEFAULT;\n\telse\n\t\timx_phy->tx_vref_tune =\n\t\t\tphy_tx_vref_tune_from_property(imx_phy->tx_vref_tune);\n\n\tif (device_property_read_u32(dev, \"fsl,phy-tx-rise-tune-percent\",\n\t\t\t\t     &imx_phy->tx_rise_tune))\n\t\timx_phy->tx_rise_tune = PHY_TUNE_DEFAULT;\n\telse\n\t\timx_phy->tx_rise_tune =\n\t\t\tphy_tx_rise_tune_from_property(imx_phy->tx_rise_tune);\n\n\tif (device_property_read_u32(dev, \"fsl,phy-tx-preemp-amp-tune-microamp\",\n\t\t\t\t     &imx_phy->tx_preemp_amp_tune))\n\t\timx_phy->tx_preemp_amp_tune = PHY_TUNE_DEFAULT;\n\telse\n\t\timx_phy->tx_preemp_amp_tune =\n\t\t\tphy_tx_preemp_amp_tune_from_property(imx_phy->tx_preemp_amp_tune);\n\n\tif (device_property_read_u32(dev, \"fsl,phy-tx-vboost-level-microvolt\",\n\t\t\t\t     &imx_phy->tx_vboost_level))\n\t\timx_phy->tx_vboost_level = PHY_TUNE_DEFAULT;\n\telse\n\t\timx_phy->tx_vboost_level =\n\t\t\tphy_tx_vboost_level_from_property(imx_phy->tx_vboost_level);\n\n\tif (device_property_read_u32(dev, \"fsl,phy-comp-dis-tune-percent\",\n\t\t\t\t     &imx_phy->comp_dis_tune))\n\t\timx_phy->comp_dis_tune = PHY_TUNE_DEFAULT;\n\telse\n\t\timx_phy->comp_dis_tune =\n\t\t\tphy_comp_dis_tune_from_property(imx_phy->comp_dis_tune);\n\n\tif (device_property_read_u32(dev, \"fsl,pcs-tx-deemph-3p5db-attenuation-db\",\n\t\t\t\t     &imx_phy->pcs_tx_deemph_3p5db))\n\t\timx_phy->pcs_tx_deemph_3p5db = PHY_TUNE_DEFAULT;\n\telse\n\t\timx_phy->pcs_tx_deemph_3p5db =\n\t\t\tphy_pcs_tx_deemph_3p5db_from_property(imx_phy->pcs_tx_deemph_3p5db);\n\n\tif (device_property_read_u32(dev, \"fsl,phy-pcs-tx-swing-full-percent\",\n\t\t\t\t     &imx_phy->pcs_tx_swing_full))\n\t\timx_phy->pcs_tx_swing_full = PHY_TUNE_DEFAULT;\n\telse\n\t\timx_phy->pcs_tx_swing_full =\n\t\t\tphy_pcs_tx_swing_full_from_property(imx_phy->pcs_tx_swing_full);\n}\n\nstatic void imx8m_phy_tune(struct imx8mq_usb_phy *imx_phy)\n{\n\tu32 value;\n\n\t \n\tif (imx_phy->pcs_tx_deemph_3p5db != PHY_TUNE_DEFAULT) {\n\t\tvalue = readl(imx_phy->base + PHY_CTRL4);\n\t\tvalue &= ~PHY_CTRL4_PCS_TX_DEEMPH_3P5DB_MASK;\n\t\tvalue |= FIELD_PREP(PHY_CTRL4_PCS_TX_DEEMPH_3P5DB_MASK,\n\t\t\t\t   imx_phy->pcs_tx_deemph_3p5db);\n\t\twritel(value, imx_phy->base + PHY_CTRL4);\n\t}\n\n\tif (imx_phy->pcs_tx_swing_full != PHY_TUNE_DEFAULT) {\n\t\tvalue = readl(imx_phy->base + PHY_CTRL5);\n\t\tvalue |= FIELD_PREP(PHY_CTRL5_PCS_TX_SWING_FULL_MASK,\n\t\t\t\t   imx_phy->pcs_tx_swing_full);\n\t\twritel(value, imx_phy->base + PHY_CTRL5);\n\t}\n\n\tif ((imx_phy->tx_vref_tune & imx_phy->tx_rise_tune &\n\t     imx_phy->tx_preemp_amp_tune & imx_phy->comp_dis_tune &\n\t     imx_phy->tx_vboost_level) == PHY_TUNE_DEFAULT)\n\t\t \n\t\treturn;\n\n\tvalue = readl(imx_phy->base + PHY_CTRL3);\n\n\tif (imx_phy->tx_vref_tune != PHY_TUNE_DEFAULT) {\n\t\tvalue &= ~PHY_CTRL3_TXVREF_TUNE_MASK;\n\t\tvalue |= FIELD_PREP(PHY_CTRL3_TXVREF_TUNE_MASK,\n\t\t\t\t   imx_phy->tx_vref_tune);\n\t}\n\n\tif (imx_phy->tx_rise_tune != PHY_TUNE_DEFAULT) {\n\t\tvalue &= ~PHY_CTRL3_TXRISE_TUNE_MASK;\n\t\tvalue |= FIELD_PREP(PHY_CTRL3_TXRISE_TUNE_MASK,\n\t\t\t\t    imx_phy->tx_rise_tune);\n\t}\n\n\tif (imx_phy->tx_preemp_amp_tune != PHY_TUNE_DEFAULT) {\n\t\tvalue &= ~PHY_CTRL3_TXPREEMP_TUNE_MASK;\n\t\tvalue |= FIELD_PREP(PHY_CTRL3_TXPREEMP_TUNE_MASK,\n\t\t\t\timx_phy->tx_preemp_amp_tune);\n\t}\n\n\tif (imx_phy->comp_dis_tune != PHY_TUNE_DEFAULT) {\n\t\tvalue &= ~PHY_CTRL3_COMPDISTUNE_MASK;\n\t\tvalue |= FIELD_PREP(PHY_CTRL3_COMPDISTUNE_MASK,\n\t\t\t\t    imx_phy->comp_dis_tune);\n\t}\n\n\tif (imx_phy->tx_vboost_level != PHY_TUNE_DEFAULT) {\n\t\tvalue &= ~PHY_CTRL3_TX_VBOOST_LEVEL_MASK;\n\t\tvalue |= FIELD_PREP(PHY_CTRL3_TX_VBOOST_LEVEL_MASK,\n\t\t\t\t    imx_phy->tx_vboost_level);\n\t}\n\n\twritel(value, imx_phy->base + PHY_CTRL3);\n}\n\nstatic int imx8mq_usb_phy_init(struct phy *phy)\n{\n\tstruct imx8mq_usb_phy *imx_phy = phy_get_drvdata(phy);\n\tu32 value;\n\n\tvalue = readl(imx_phy->base + PHY_CTRL1);\n\tvalue &= ~(PHY_CTRL1_VDATSRCENB0 | PHY_CTRL1_VDATDETENB0 |\n\t\t   PHY_CTRL1_COMMONONN);\n\tvalue |= PHY_CTRL1_RESET | PHY_CTRL1_ATERESET;\n\twritel(value, imx_phy->base + PHY_CTRL1);\n\n\tvalue = readl(imx_phy->base + PHY_CTRL0);\n\tvalue |= PHY_CTRL0_REF_SSP_EN;\n\twritel(value, imx_phy->base + PHY_CTRL0);\n\n\tvalue = readl(imx_phy->base + PHY_CTRL2);\n\tvalue |= PHY_CTRL2_TXENABLEN0;\n\twritel(value, imx_phy->base + PHY_CTRL2);\n\n\tvalue = readl(imx_phy->base + PHY_CTRL1);\n\tvalue &= ~(PHY_CTRL1_RESET | PHY_CTRL1_ATERESET);\n\twritel(value, imx_phy->base + PHY_CTRL1);\n\n\treturn 0;\n}\n\nstatic int imx8mp_usb_phy_init(struct phy *phy)\n{\n\tstruct imx8mq_usb_phy *imx_phy = phy_get_drvdata(phy);\n\tu32 value;\n\n\t \n\tvalue = readl(imx_phy->base + PHY_CTRL0);\n\tvalue &= ~PHY_CTRL0_FSEL_MASK;\n\tvalue |= FIELD_PREP(PHY_CTRL0_FSEL_MASK, PHY_CTRL0_FSEL_24M);\n\twritel(value, imx_phy->base + PHY_CTRL0);\n\n\t \n\tvalue = readl(imx_phy->base + PHY_CTRL6);\n\tvalue &= ~(PHY_CTRL6_ALT_CLK_SEL | PHY_CTRL6_ALT_CLK_EN);\n\twritel(value, imx_phy->base + PHY_CTRL6);\n\n\tvalue = readl(imx_phy->base + PHY_CTRL1);\n\tvalue &= ~(PHY_CTRL1_VDATSRCENB0 | PHY_CTRL1_VDATDETENB0);\n\tvalue |= PHY_CTRL1_RESET | PHY_CTRL1_ATERESET;\n\twritel(value, imx_phy->base + PHY_CTRL1);\n\n\tvalue = readl(imx_phy->base + PHY_CTRL0);\n\tvalue |= PHY_CTRL0_REF_SSP_EN;\n\twritel(value, imx_phy->base + PHY_CTRL0);\n\n\tvalue = readl(imx_phy->base + PHY_CTRL2);\n\tvalue |= PHY_CTRL2_TXENABLEN0 | PHY_CTRL2_OTG_DISABLE;\n\twritel(value, imx_phy->base + PHY_CTRL2);\n\n\tudelay(10);\n\n\tvalue = readl(imx_phy->base + PHY_CTRL1);\n\tvalue &= ~(PHY_CTRL1_RESET | PHY_CTRL1_ATERESET);\n\twritel(value, imx_phy->base + PHY_CTRL1);\n\n\timx8m_phy_tune(imx_phy);\n\n\treturn 0;\n}\n\nstatic int imx8mq_phy_power_on(struct phy *phy)\n{\n\tstruct imx8mq_usb_phy *imx_phy = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = regulator_enable(imx_phy->vbus);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clk_prepare_enable(imx_phy->clk);\n}\n\nstatic int imx8mq_phy_power_off(struct phy *phy)\n{\n\tstruct imx8mq_usb_phy *imx_phy = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(imx_phy->clk);\n\tregulator_disable(imx_phy->vbus);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops imx8mq_usb_phy_ops = {\n\t.init\t\t= imx8mq_usb_phy_init,\n\t.power_on\t= imx8mq_phy_power_on,\n\t.power_off\t= imx8mq_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct phy_ops imx8mp_usb_phy_ops = {\n\t.init\t\t= imx8mp_usb_phy_init,\n\t.power_on\t= imx8mq_phy_power_on,\n\t.power_off\t= imx8mq_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct of_device_id imx8mq_usb_phy_of_match[] = {\n\t{.compatible = \"fsl,imx8mq-usb-phy\",\n\t .data = &imx8mq_usb_phy_ops,},\n\t{.compatible = \"fsl,imx8mp-usb-phy\",\n\t .data = &imx8mp_usb_phy_ops,},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, imx8mq_usb_phy_of_match);\n\nstatic int imx8mq_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct imx8mq_usb_phy *imx_phy;\n\tconst struct phy_ops *phy_ops;\n\n\timx_phy = devm_kzalloc(dev, sizeof(*imx_phy), GFP_KERNEL);\n\tif (!imx_phy)\n\t\treturn -ENOMEM;\n\n\timx_phy->clk = devm_clk_get(dev, \"phy\");\n\tif (IS_ERR(imx_phy->clk)) {\n\t\tdev_err(dev, \"failed to get imx8mq usb phy clock\\n\");\n\t\treturn PTR_ERR(imx_phy->clk);\n\t}\n\n\timx_phy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(imx_phy->base))\n\t\treturn PTR_ERR(imx_phy->base);\n\n\tphy_ops = of_device_get_match_data(dev);\n\tif (!phy_ops)\n\t\treturn -EINVAL;\n\n\timx_phy->phy = devm_phy_create(dev, NULL, phy_ops);\n\tif (IS_ERR(imx_phy->phy))\n\t\treturn PTR_ERR(imx_phy->phy);\n\n\timx_phy->vbus = devm_regulator_get(dev, \"vbus\");\n\tif (IS_ERR(imx_phy->vbus))\n\t\treturn dev_err_probe(dev, PTR_ERR(imx_phy->vbus), \"failed to get vbus\\n\");\n\n\tphy_set_drvdata(imx_phy->phy, imx_phy);\n\n\timx8m_get_phy_tuning_data(imx_phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver imx8mq_usb_phy_driver = {\n\t.probe\t= imx8mq_usb_phy_probe,\n\t.driver = {\n\t\t.name\t= \"imx8mq-usb-phy\",\n\t\t.of_match_table\t= imx8mq_usb_phy_of_match,\n\t}\n};\nmodule_platform_driver(imx8mq_usb_phy_driver);\n\nMODULE_DESCRIPTION(\"FSL IMX8MQ USB PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}