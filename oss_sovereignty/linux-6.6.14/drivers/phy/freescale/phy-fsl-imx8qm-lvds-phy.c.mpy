{
  "module_name": "phy-fsl-imx8qm-lvds-phy.c",
  "hash_id": "391c9723edfddc39b5b9d23f21470bb3291e7f7056d5fe8c855d3e984d8ab83e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/freescale/phy-fsl-imx8qm-lvds-phy.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/units.h>\n\n#define REG_SET\t\t0x4\n#define REG_CLR\t\t0x8\n\n#define PHY_CTRL\t0x0\n#define  M_MASK\t\tGENMASK(18, 17)\n#define  M(n)\t\tFIELD_PREP(M_MASK, (n))\n#define  CCM_MASK\tGENMASK(16, 14)\n#define  CCM(n)\t\tFIELD_PREP(CCM_MASK, (n))\n#define  CA_MASK\tGENMASK(13, 11)\n#define  CA(n)\t\tFIELD_PREP(CA_MASK, (n))\n#define  TST_MASK\tGENMASK(10, 5)\n#define  TST(n)\t\tFIELD_PREP(TST_MASK, (n))\n#define  CH_EN(id)\tBIT(3 + (id))\n#define  NB\t\tBIT(2)\n#define  RFB\t\tBIT(1)\n#define  PD\t\tBIT(0)\n\n \n#define  CTRL_RESET_VAL\t(M(0x0) | CCM(0x4) | CA(0x4) | TST(0x25))\n\n \n#define  CTRL_INIT_MASK\t(M_MASK | CCM_MASK | CA_MASK | TST_MASK | NB | RFB)\n#define  CTRL_INIT_VAL\t(M(0x0) | CCM(0x5) | CA(0x4) | TST(0x25) | RFB)\n\n#define PHY_STATUS\t0x10\n#define  LOCK\t\tBIT(0)\n\n#define PHY_NUM\t\t2\n\n#define MIN_CLKIN_FREQ\t(25 * MEGA)\n#define MAX_CLKIN_FREQ\t(165 * MEGA)\n\n#define PLL_LOCK_SLEEP\t\t10\n#define PLL_LOCK_TIMEOUT\t1000\n\nstruct mixel_lvds_phy {\n\tstruct phy *phy;\n\tstruct phy_configure_opts_lvds cfg;\n\tunsigned int id;\n};\n\nstruct mixel_lvds_phy_priv {\n\tstruct regmap *regmap;\n\tstruct mutex lock;\t \n\tstruct clk *phy_ref_clk;\n\tstruct mixel_lvds_phy *phys[PHY_NUM];\n};\n\nstatic int mixel_lvds_phy_init(struct phy *phy)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(phy->dev.parent);\n\n\tmutex_lock(&priv->lock);\n\tregmap_update_bits(priv->regmap,\n\t\t\t   PHY_CTRL, CTRL_INIT_MASK, CTRL_INIT_VAL);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int mixel_lvds_phy_power_on(struct phy *phy)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(phy->dev.parent);\n\tstruct mixel_lvds_phy *lvds_phy = phy_get_drvdata(phy);\n\tstruct mixel_lvds_phy *companion = priv->phys[lvds_phy->id ^ 1];\n\tstruct phy_configure_opts_lvds *cfg = &lvds_phy->cfg;\n\tu32 val = 0;\n\tu32 locked;\n\tint ret;\n\n\t \n\tif (cfg->is_slave)\n\t\treturn 0;\n\n\tret = clk_prepare_enable(priv->phy_ref_clk);\n\tif (ret < 0) {\n\t\tdev_err(&phy->dev,\n\t\t\t\"failed to enable PHY reference clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&priv->lock);\n\tif (cfg->bits_per_lane_and_dclk_cycle == 7) {\n\t\tif (cfg->differential_clk_rate < 44000000)\n\t\t\tval |= M(0x2);\n\t\telse if (cfg->differential_clk_rate < 90000000)\n\t\t\tval |= M(0x1);\n\t\telse\n\t\t\tval |= M(0x0);\n\t} else {\n\t\tval = NB;\n\n\t\tif (cfg->differential_clk_rate < 32000000)\n\t\t\tval |= M(0x2);\n\t\telse if (cfg->differential_clk_rate < 63000000)\n\t\t\tval |= M(0x1);\n\t\telse\n\t\t\tval |= M(0x0);\n\t}\n\tregmap_update_bits(priv->regmap, PHY_CTRL, M_MASK | NB, val);\n\n\t \n\tif (companion->cfg.is_slave)\n\t\tval = CH_EN(0) | CH_EN(1);\n\telse\n\t\tval = CH_EN(lvds_phy->id);\n\tregmap_write(priv->regmap, PHY_CTRL + REG_SET, val);\n\n\tret = regmap_read_poll_timeout(priv->regmap, PHY_STATUS, locked,\n\t\t\t\t       locked, PLL_LOCK_SLEEP,\n\t\t\t\t       PLL_LOCK_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&phy->dev, \"failed to get PHY lock: %d\\n\", ret);\n\t\tclk_disable_unprepare(priv->phy_ref_clk);\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int mixel_lvds_phy_power_off(struct phy *phy)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(phy->dev.parent);\n\tstruct mixel_lvds_phy *lvds_phy = phy_get_drvdata(phy);\n\tstruct mixel_lvds_phy *companion = priv->phys[lvds_phy->id ^ 1];\n\tstruct phy_configure_opts_lvds *cfg = &lvds_phy->cfg;\n\n\t \n\tif (cfg->is_slave)\n\t\treturn 0;\n\n\tmutex_lock(&priv->lock);\n\tif (companion->cfg.is_slave)\n\t\tregmap_write(priv->regmap, PHY_CTRL + REG_CLR,\n\t\t\t     CH_EN(0) | CH_EN(1));\n\telse\n\t\tregmap_write(priv->regmap, PHY_CTRL + REG_CLR,\n\t\t\t     CH_EN(lvds_phy->id));\n\tmutex_unlock(&priv->lock);\n\n\tclk_disable_unprepare(priv->phy_ref_clk);\n\n\treturn 0;\n}\n\nstatic int mixel_lvds_phy_configure(struct phy *phy,\n\t\t\t\t    union phy_configure_opts *opts)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(phy->dev.parent);\n\tstruct phy_configure_opts_lvds *cfg = &opts->lvds;\n\tint ret;\n\n\tret = clk_set_rate(priv->phy_ref_clk, cfg->differential_clk_rate);\n\tif (ret)\n\t\tdev_err(&phy->dev, \"failed to set PHY reference clock rate(%lu): %d\\n\",\n\t\t\tcfg->differential_clk_rate, ret);\n\n\treturn ret;\n}\n\n \nstatic int mixel_lvds_phy_check_slave(struct phy *slave_phy)\n{\n\tstruct device *dev = &slave_phy->dev;\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(dev->parent);\n\tstruct mixel_lvds_phy *slv = phy_get_drvdata(slave_phy);\n\tstruct mixel_lvds_phy *mst = priv->phys[slv->id ^ 1];\n\tstruct phy_configure_opts_lvds *mst_cfg = &mst->cfg;\n\tstruct phy_configure_opts_lvds *slv_cfg = &slv->cfg;\n\n\tif (mst_cfg->bits_per_lane_and_dclk_cycle !=\n\t    slv_cfg->bits_per_lane_and_dclk_cycle) {\n\t\tdev_err(dev, \"number bits mismatch(mst: %u vs slv: %u)\\n\",\n\t\t\tmst_cfg->bits_per_lane_and_dclk_cycle,\n\t\t\tslv_cfg->bits_per_lane_and_dclk_cycle);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mst_cfg->differential_clk_rate !=\n\t    slv_cfg->differential_clk_rate) {\n\t\tdev_err(dev, \"dclk rate mismatch(mst: %lu vs slv: %lu)\\n\",\n\t\t\tmst_cfg->differential_clk_rate,\n\t\t\tslv_cfg->differential_clk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mst_cfg->lanes != slv_cfg->lanes) {\n\t\tdev_err(dev, \"lanes mismatch(mst: %u vs slv: %u)\\n\",\n\t\t\tmst_cfg->lanes, slv_cfg->lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mst_cfg->is_slave == slv_cfg->is_slave) {\n\t\tdev_err(dev, \"master PHY is not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mixel_lvds_phy_validate(struct phy *phy, enum phy_mode mode,\n\t\t\t\t   int submode, union phy_configure_opts *opts)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(phy->dev.parent);\n\tstruct mixel_lvds_phy *lvds_phy = phy_get_drvdata(phy);\n\tstruct phy_configure_opts_lvds *cfg = &opts->lvds;\n\tint ret = 0;\n\n\tif (mode != PHY_MODE_LVDS) {\n\t\tdev_err(&phy->dev, \"invalid PHY mode(%d)\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->bits_per_lane_and_dclk_cycle != 7 &&\n\t    cfg->bits_per_lane_and_dclk_cycle != 10) {\n\t\tdev_err(&phy->dev, \"invalid bits per data lane(%u)\\n\",\n\t\t\tcfg->bits_per_lane_and_dclk_cycle);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->lanes != 4 && cfg->lanes != 3) {\n\t\tdev_err(&phy->dev, \"invalid data lanes(%u)\\n\", cfg->lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->differential_clk_rate < MIN_CLKIN_FREQ ||\n\t    cfg->differential_clk_rate > MAX_CLKIN_FREQ) {\n\t\tdev_err(&phy->dev, \"invalid differential clock rate(%lu)\\n\",\n\t\t\tcfg->differential_clk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&priv->lock);\n\t \n\tmemcpy(&lvds_phy->cfg, cfg, sizeof(*cfg));\n\n\tif (cfg->is_slave) {\n\t\tret = mixel_lvds_phy_check_slave(phy);\n\t\tif (ret)\n\t\t\tdev_err(&phy->dev, \"failed to check slave PHY: %d\\n\", ret);\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic const struct phy_ops mixel_lvds_phy_ops = {\n\t.init = mixel_lvds_phy_init,\n\t.power_on = mixel_lvds_phy_power_on,\n\t.power_off = mixel_lvds_phy_power_off,\n\t.configure = mixel_lvds_phy_configure,\n\t.validate = mixel_lvds_phy_validate,\n\t.owner = THIS_MODULE,\n};\n\nstatic int mixel_lvds_phy_reset(struct device *dev)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get PM runtime: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap_write(priv->regmap, PHY_CTRL, CTRL_RESET_VAL);\n\n\tret = pm_runtime_put(dev);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to put PM runtime: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct phy *mixel_lvds_phy_xlate(struct device *dev,\n\t\t\t\t\tstruct of_phandle_args *args)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(dev);\n\tunsigned int phy_id;\n\n\tif (args->args_count != 1) {\n\t\tdev_err(dev,\n\t\t\t\"invalid argument number(%d) for 'phys' property\\n\",\n\t\t\targs->args_count);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tphy_id = args->args[0];\n\n\tif (phy_id >= PHY_NUM) {\n\t\tdev_err(dev, \"invalid PHY index(%d)\\n\", phy_id);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn priv->phys[phy_id]->phy;\n}\n\nstatic int mixel_lvds_phy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *phy_provider;\n\tstruct mixel_lvds_phy_priv *priv;\n\tstruct mixel_lvds_phy *lvds_phy;\n\tstruct phy *phy;\n\tint i;\n\tint ret;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = syscon_node_to_regmap(dev->of_node->parent);\n\tif (IS_ERR(priv->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->regmap),\n\t\t\t\t     \"failed to get regmap\\n\");\n\n\tpriv->phy_ref_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->phy_ref_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->phy_ref_clk),\n\t\t\t\t     \"failed to get PHY reference clock\\n\");\n\n\tmutex_init(&priv->lock);\n\n\tdev_set_drvdata(dev, priv);\n\n\tpm_runtime_enable(dev);\n\n\tret = mixel_lvds_phy_reset(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to do POR reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < PHY_NUM; i++) {\n\t\tlvds_phy = devm_kzalloc(dev, sizeof(*lvds_phy), GFP_KERNEL);\n\t\tif (!lvds_phy) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tphy = devm_phy_create(dev, NULL, &mixel_lvds_phy_ops);\n\t\tif (IS_ERR(phy)) {\n\t\t\tret = PTR_ERR(phy);\n\t\t\tdev_err(dev, \"failed to create PHY for channel%d: %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlvds_phy->phy = phy;\n\t\tlvds_phy->id = i;\n\t\tpriv->phys[i] = lvds_phy;\n\n\t\tphy_set_drvdata(phy, lvds_phy);\n\t}\n\n\tphy_provider = devm_of_phy_provider_register(dev, mixel_lvds_phy_xlate);\n\tif (IS_ERR(phy_provider)) {\n\t\tret = PTR_ERR(phy_provider);\n\t\tdev_err(dev, \"failed to register PHY provider: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void mixel_lvds_phy_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused mixel_lvds_phy_runtime_suspend(struct device *dev)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(dev);\n\n\t \n\tmutex_lock(&priv->lock);\n\tregmap_write(priv->regmap, PHY_CTRL + REG_SET, PD);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mixel_lvds_phy_runtime_resume(struct device *dev)\n{\n\tstruct mixel_lvds_phy_priv *priv = dev_get_drvdata(dev);\n\n\t \n\tmutex_lock(&priv->lock);\n\tregmap_update_bits(priv->regmap, PHY_CTRL,\n\t\t\t   CTRL_INIT_MASK | PD, CTRL_INIT_VAL);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mixel_lvds_phy_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mixel_lvds_phy_runtime_suspend,\n\t\t\t   mixel_lvds_phy_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id mixel_lvds_phy_of_match[] = {\n\t{ .compatible = \"fsl,imx8qm-lvds-phy\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mixel_lvds_phy_of_match);\n\nstatic struct platform_driver mixel_lvds_phy_driver = {\n\t.probe\t= mixel_lvds_phy_probe,\n\t.remove_new = mixel_lvds_phy_remove,\n\t.driver = {\n\t\t.pm = &mixel_lvds_phy_pm_ops,\n\t\t.name = \"mixel-lvds-phy\",\n\t\t.of_match_table\t= mixel_lvds_phy_of_match,\n\t}\n};\nmodule_platform_driver(mixel_lvds_phy_driver);\n\nMODULE_DESCRIPTION(\"Mixel LVDS PHY driver\");\nMODULE_AUTHOR(\"Liu Ying <victor.liu@nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}