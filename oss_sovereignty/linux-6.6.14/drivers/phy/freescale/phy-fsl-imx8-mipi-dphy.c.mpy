{
  "module_name": "phy-fsl-imx8-mipi-dphy.c",
  "hash_id": "7f066e47b82afa5fdaf63067b85c480f1769b6d6730e0adb277049d9fecfe240",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/freescale/phy-fsl-imx8-mipi-dphy.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/firmware/imx/ipc.h>\n#include <linux/firmware/imx/svc/misc.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <dt-bindings/firmware/imx/rsrc.h>\n\n \n#define PHY_CTRL\t\t\t0x00\n#define  CCM_MASK\t\t\tGENMASK(7, 5)\n#define  CCM(n)\t\t\t\tFIELD_PREP(CCM_MASK, (n))\n#define  CCM_1_2V\t\t\t0x5\n#define  CA_MASK\t\t\tGENMASK(4, 2)\n#define  CA_3_51MA\t\t\t0x4\n#define  CA(n)\t\t\t\tFIELD_PREP(CA_MASK, (n))\n#define  RFB\t\t\t\tBIT(1)\n#define  LVDS_EN\t\t\tBIT(0)\n\n \n#define DPHY_PD_DPHY\t\t\t0x00\n#define DPHY_M_PRG_HS_PREPARE\t\t0x04\n#define DPHY_MC_PRG_HS_PREPARE\t\t0x08\n#define DPHY_M_PRG_HS_ZERO\t\t0x0c\n#define DPHY_MC_PRG_HS_ZERO\t\t0x10\n#define DPHY_M_PRG_HS_TRAIL\t\t0x14\n#define DPHY_MC_PRG_HS_TRAIL\t\t0x18\n#define DPHY_PD_PLL\t\t\t0x1c\n#define DPHY_TST\t\t\t0x20\n#define DPHY_CN\t\t\t\t0x24\n#define DPHY_CM\t\t\t\t0x28\n#define DPHY_CO\t\t\t\t0x2c\n#define DPHY_LOCK\t\t\t0x30\n#define DPHY_LOCK_BYP\t\t\t0x34\n#define DPHY_REG_BYPASS_PLL\t\t0x4C\n\n#define MBPS(x) ((x) * 1000000)\n\n#define DATA_RATE_MAX_SPEED MBPS(1500)\n#define DATA_RATE_MIN_SPEED MBPS(80)\n\n#define PLL_LOCK_SLEEP 10\n#define PLL_LOCK_TIMEOUT 1000\n\n#define CN_BUF\t0xcb7a89c0\n#define CO_BUF\t0x63\n#define CM(x)\t(\t\t\t\t  \\\n\t\t((x) <\t32) ? 0xe0 | ((x) - 16) : \\\n\t\t((x) <\t64) ? 0xc0 | ((x) - 32) : \\\n\t\t((x) < 128) ? 0x80 | ((x) - 64) : \\\n\t\t((x) - 128))\n#define CN(x)\t(((x) == 1) ? 0x1f : (((CN_BUF) >> ((x) - 1)) & 0x1f))\n#define CO(x)\t((CO_BUF) >> (8 - (x)) & 0x03)\n\n \n#define PWR_ON\t0\n#define PWR_OFF\t1\n\n#define MIN_VCO_FREQ 640000000\n#define MAX_VCO_FREQ 1500000000\n\n#define MIN_LVDS_REFCLK_FREQ 24000000\n#define MAX_LVDS_REFCLK_FREQ 150000000\n\nenum mixel_dphy_devtype {\n\tMIXEL_IMX8MQ,\n\tMIXEL_IMX8QXP,\n};\n\nstruct mixel_dphy_devdata {\n\tu8 reg_tx_rcal;\n\tu8 reg_auto_pd_en;\n\tu8 reg_rxlprp;\n\tu8 reg_rxcdrp;\n\tu8 reg_rxhs_settle;\n\tbool is_combo;\t \n};\n\nstatic const struct mixel_dphy_devdata mixel_dphy_devdata[] = {\n\t[MIXEL_IMX8MQ] = {\n\t\t.reg_tx_rcal = 0x38,\n\t\t.reg_auto_pd_en = 0x3c,\n\t\t.reg_rxlprp = 0x40,\n\t\t.reg_rxcdrp = 0x44,\n\t\t.reg_rxhs_settle = 0x48,\n\t\t.is_combo = false,\n\t},\n\t[MIXEL_IMX8QXP] = {\n\t\t.is_combo = true,\n\t},\n};\n\nstruct mixel_dphy_cfg {\n\t \n\tu32 cm;\n\tu32 cn;\n\tu32 co;\n\t \n\tu8 mc_prg_hs_prepare;\n\tu8 m_prg_hs_prepare;\n\tu8 mc_prg_hs_zero;\n\tu8 m_prg_hs_zero;\n\tu8 mc_prg_hs_trail;\n\tu8 m_prg_hs_trail;\n\tu8 rxhs_settle;\n};\n\nstruct mixel_dphy_priv {\n\tstruct mixel_dphy_cfg cfg;\n\tstruct regmap *regmap;\n\tstruct regmap *lvds_regmap;\n\tstruct clk *phy_ref_clk;\n\tconst struct mixel_dphy_devdata *devdata;\n\tstruct imx_sc_ipc *ipc_handle;\n\tbool is_slave;\n\tint id;\n};\n\nstatic const struct regmap_config mixel_dphy_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = DPHY_REG_BYPASS_PLL,\n\t.name = \"mipi-dphy\",\n};\n\nstatic int phy_write(struct phy *phy, u32 value, unsigned int reg)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = regmap_write(priv->regmap, reg, value);\n\tif (ret < 0)\n\t\tdev_err(&phy->dev, \"Failed to write DPHY reg %d: %d\\n\", reg,\n\t\t\tret);\n\treturn ret;\n}\n\n \nstatic void get_best_ratio(u32 *pnum, u32 *pdenom, u32 max_n, u32 max_d)\n{\n\tu32 a = *pnum;\n\tu32 b = *pdenom;\n\tu32 c;\n\tu32 n[] = {0, 1};\n\tu32 d[] = {1, 0};\n\tu32 whole;\n\tunsigned int i = 1;\n\n\twhile (b) {\n\t\ti ^= 1;\n\t\twhole = a / b;\n\t\tn[i] += (n[i ^ 1] * whole);\n\t\td[i] += (d[i ^ 1] * whole);\n\t\tif ((n[i] > max_n) || (d[i] > max_d)) {\n\t\t\ti ^= 1;\n\t\t\tbreak;\n\t\t}\n\t\tc = a - (b * whole);\n\t\ta = b;\n\t\tb = c;\n\t}\n\t*pnum = n[i];\n\t*pdenom = d[i];\n}\n\nstatic int mixel_dphy_config_from_opts(struct phy *phy,\n\t       struct phy_configure_opts_mipi_dphy *dphy_opts,\n\t       struct mixel_dphy_cfg *cfg)\n{\n\tstruct mixel_dphy_priv *priv = dev_get_drvdata(phy->dev.parent);\n\tunsigned long ref_clk = clk_get_rate(priv->phy_ref_clk);\n\tu32 lp_t, numerator, denominator;\n\tunsigned long long tmp;\n\tu32 n;\n\tint i;\n\n\tif (dphy_opts->hs_clk_rate > DATA_RATE_MAX_SPEED ||\n\t    dphy_opts->hs_clk_rate < DATA_RATE_MIN_SPEED)\n\t\treturn -EINVAL;\n\n\tnumerator = dphy_opts->hs_clk_rate;\n\tdenominator = ref_clk;\n\tget_best_ratio(&numerator, &denominator, 255, 256);\n\tif (!numerator || !denominator) {\n\t\tdev_err(&phy->dev, \"Invalid %d/%d for %ld/%ld\\n\",\n\t\t\tnumerator, denominator,\n\t\t\tdphy_opts->hs_clk_rate, ref_clk);\n\t\treturn -EINVAL;\n\t}\n\n\twhile ((numerator < 16) && (denominator <= 128)) {\n\t\tnumerator <<= 1;\n\t\tdenominator <<= 1;\n\t}\n\t \n\ti = __ffs(denominator);\n\tif (i > 3)\n\t\ti = 3;\n\tcfg->cn = denominator >> i;\n\tcfg->co = 1 << i;\n\tcfg->cm = numerator;\n\n\tif (cfg->cm < 16 || cfg->cm > 255 ||\n\t    cfg->cn < 1 || cfg->cn > 32 ||\n\t    cfg->co < 1 || cfg->co > 8) {\n\t\tdev_err(&phy->dev, \"Invalid CM/CN/CO values: %u/%u/%u\\n\",\n\t\t\tcfg->cm, cfg->cn, cfg->co);\n\t\tdev_err(&phy->dev, \"for hs_clk/ref_clk=%ld/%ld ~ %d/%d\\n\",\n\t\t\tdphy_opts->hs_clk_rate, ref_clk,\n\t\t\tnumerator, denominator);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&phy->dev, \"hs_clk/ref_clk=%ld/%ld ~ %d/%d\\n\",\n\t\tdphy_opts->hs_clk_rate, ref_clk, numerator, denominator);\n\n\t \n\ttmp = 1000000000000LL;\n\tdo_div(tmp, dphy_opts->lp_clk_rate);  \n\tif (tmp > ULONG_MAX)\n\t\treturn -EINVAL;\n\n\tlp_t = tmp;\n\tdev_dbg(&phy->dev, \"LP clock %lu, period: %u ps\\n\",\n\t\tdphy_opts->lp_clk_rate, lp_t);\n\n\t \n\tif (2 * dphy_opts->hs_prepare > 5 * lp_t) {\n\t\tdev_err(&phy->dev,\n\t\t\t\"hs_prepare (%u) > 2.5 * lp clock period (%u)\\n\",\n\t\t\tdphy_opts->hs_prepare, lp_t);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (dphy_opts->hs_prepare < lp_t) {\n\t\tn = 0;\n\t} else {\n\t\ttmp = 2 * (dphy_opts->hs_prepare - lp_t);\n\t\tdo_div(tmp, lp_t);\n\t\tn = tmp;\n\t}\n\tcfg->m_prg_hs_prepare = n;\n\n\t \n\tif (2 * dphy_opts->clk_prepare > 3 * lp_t) {\n\t\tdev_err(&phy->dev,\n\t\t\t\"clk_prepare (%u) > 1.5 * lp clock period (%u)\\n\",\n\t\t\tdphy_opts->clk_prepare, lp_t);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcfg->mc_prg_hs_prepare = dphy_opts->clk_prepare > lp_t ? 1 : 0;\n\n\t \n\tn = (144 * (dphy_opts->hs_clk_rate / 1000000) - 47500) / 10000;\n\tcfg->m_prg_hs_zero = n < 1 ? 1 : n;\n\n\t \n\tn = (34 * (dphy_opts->hs_clk_rate / 1000000) - 2500) / 1000;\n\tcfg->mc_prg_hs_zero = n < 1 ? 1 : n;\n\n\t \n\tn = (103 * (dphy_opts->hs_clk_rate / 1000000) + 10000) / 10000;\n\tif (n > 15)\n\t\tn = 15;\n\tif (n < 1)\n\t\tn = 1;\n\tcfg->m_prg_hs_trail = n;\n\tcfg->mc_prg_hs_trail = n;\n\n\t \n\tif (dphy_opts->hs_clk_rate < MBPS(80))\n\t\tcfg->rxhs_settle = 0x0d;\n\telse if (dphy_opts->hs_clk_rate < MBPS(90))\n\t\tcfg->rxhs_settle = 0x0c;\n\telse if (dphy_opts->hs_clk_rate < MBPS(125))\n\t\tcfg->rxhs_settle = 0x0b;\n\telse if (dphy_opts->hs_clk_rate < MBPS(150))\n\t\tcfg->rxhs_settle = 0x0a;\n\telse if (dphy_opts->hs_clk_rate < MBPS(225))\n\t\tcfg->rxhs_settle = 0x09;\n\telse if (dphy_opts->hs_clk_rate < MBPS(500))\n\t\tcfg->rxhs_settle = 0x08;\n\telse\n\t\tcfg->rxhs_settle = 0x07;\n\n\tdev_dbg(&phy->dev, \"phy_config: %u %u %u %u %u %u %u\\n\",\n\t\tcfg->m_prg_hs_prepare, cfg->mc_prg_hs_prepare,\n\t\tcfg->m_prg_hs_zero, cfg->mc_prg_hs_zero,\n\t\tcfg->m_prg_hs_trail, cfg->mc_prg_hs_trail,\n\t\tcfg->rxhs_settle);\n\n\treturn 0;\n}\n\nstatic void mixel_phy_set_hs_timings(struct phy *phy)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\n\tphy_write(phy, priv->cfg.m_prg_hs_prepare, DPHY_M_PRG_HS_PREPARE);\n\tphy_write(phy, priv->cfg.mc_prg_hs_prepare, DPHY_MC_PRG_HS_PREPARE);\n\tphy_write(phy, priv->cfg.m_prg_hs_zero, DPHY_M_PRG_HS_ZERO);\n\tphy_write(phy, priv->cfg.mc_prg_hs_zero, DPHY_MC_PRG_HS_ZERO);\n\tphy_write(phy, priv->cfg.m_prg_hs_trail, DPHY_M_PRG_HS_TRAIL);\n\tphy_write(phy, priv->cfg.mc_prg_hs_trail, DPHY_MC_PRG_HS_TRAIL);\n\tphy_write(phy, priv->cfg.rxhs_settle, priv->devdata->reg_rxhs_settle);\n}\n\nstatic int mixel_dphy_set_pll_params(struct phy *phy)\n{\n\tstruct mixel_dphy_priv *priv = dev_get_drvdata(phy->dev.parent);\n\n\tif (priv->cfg.cm < 16 || priv->cfg.cm > 255 ||\n\t    priv->cfg.cn < 1 || priv->cfg.cn > 32 ||\n\t    priv->cfg.co < 1 || priv->cfg.co > 8) {\n\t\tdev_err(&phy->dev, \"Invalid CM/CN/CO values! (%u/%u/%u)\\n\",\n\t\t\tpriv->cfg.cm, priv->cfg.cn, priv->cfg.co);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(&phy->dev, \"Using CM:%u CN:%u CO:%u\\n\",\n\t\tpriv->cfg.cm, priv->cfg.cn, priv->cfg.co);\n\tphy_write(phy, CM(priv->cfg.cm), DPHY_CM);\n\tphy_write(phy, CN(priv->cfg.cn), DPHY_CN);\n\tphy_write(phy, CO(priv->cfg.co), DPHY_CO);\n\treturn 0;\n}\n\nstatic int\nmixel_dphy_configure_mipi_dphy(struct phy *phy, union phy_configure_opts *opts)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\tstruct mixel_dphy_cfg cfg = { 0 };\n\tint ret;\n\n\tret = mixel_dphy_config_from_opts(phy, &opts->mipi_dphy, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmemcpy(&priv->cfg, &cfg, sizeof(struct mixel_dphy_cfg));\n\n\tphy_write(phy, 0x00, DPHY_LOCK_BYP);\n\tphy_write(phy, 0x01, priv->devdata->reg_tx_rcal);\n\tphy_write(phy, 0x00, priv->devdata->reg_auto_pd_en);\n\tphy_write(phy, 0x02, priv->devdata->reg_rxlprp);\n\tphy_write(phy, 0x02, priv->devdata->reg_rxcdrp);\n\tphy_write(phy, 0x25, DPHY_TST);\n\n\tmixel_phy_set_hs_timings(phy);\n\tret = mixel_dphy_set_pll_params(phy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nmixel_dphy_configure_lvds_phy(struct phy *phy, union phy_configure_opts *opts)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\tstruct phy_configure_opts_lvds *lvds_opts = &opts->lvds;\n\tunsigned long data_rate;\n\tunsigned long fvco;\n\tu32 rsc;\n\tu32 co;\n\tint ret;\n\n\tpriv->is_slave = lvds_opts->is_slave;\n\n\t \n\tregmap_write(priv->lvds_regmap, PHY_CTRL,\n\t\t     CCM(CCM_1_2V) | CA(CA_3_51MA) | RFB);\n\n\t \n\trsc = priv->id ? IMX_SC_R_MIPI_1 : IMX_SC_R_MIPI_0;\n\tret = imx_sc_misc_set_control(priv->ipc_handle, rsc, IMX_SC_C_DUAL_MODE,\n\t\t\t\t      lvds_opts->is_slave);\n\tif (ret) {\n\t\tdev_err(&phy->dev, \"Failed to configure MODE8: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tdata_rate = 7 * lvds_opts->differential_clk_rate;\n\tfor (co = 1; co <= 8; co *= 2) {\n\t\tfvco = data_rate * co;\n\n\t\tif (fvco >= MIN_VCO_FREQ)\n\t\t\tbreak;\n\t}\n\n\tif (fvco < MIN_VCO_FREQ || fvco > MAX_VCO_FREQ) {\n\t\tdev_err(&phy->dev, \"VCO frequency %lu is out of range\\n\", fvco);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tphy_write(phy, __ffs(co), DPHY_CO);\n\n\t \n\tclk_set_rate(priv->phy_ref_clk, lvds_opts->differential_clk_rate);\n\n\treturn ret;\n}\n\nstatic int mixel_dphy_configure(struct phy *phy, union phy_configure_opts *opts)\n{\n\tif (!opts) {\n\t\tdev_err(&phy->dev, \"No configuration options\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (phy->attrs.mode == PHY_MODE_MIPI_DPHY)\n\t\treturn mixel_dphy_configure_mipi_dphy(phy, opts);\n\telse if (phy->attrs.mode == PHY_MODE_LVDS)\n\t\treturn mixel_dphy_configure_lvds_phy(phy, opts);\n\n\tdev_err(&phy->dev,\n\t\t\"Failed to configure PHY with invalid PHY mode: %d\\n\", phy->attrs.mode);\n\n\treturn -EINVAL;\n}\n\nstatic int\nmixel_dphy_validate_lvds_phy(struct phy *phy, union phy_configure_opts *opts)\n{\n\tstruct phy_configure_opts_lvds *lvds_cfg = &opts->lvds;\n\n\tif (lvds_cfg->bits_per_lane_and_dclk_cycle != 7) {\n\t\tdev_err(&phy->dev, \"Invalid bits per LVDS data lane: %u\\n\",\n\t\t\tlvds_cfg->bits_per_lane_and_dclk_cycle);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lvds_cfg->lanes != 4) {\n\t\tdev_err(&phy->dev, \"Invalid LVDS data lanes: %u\\n\", lvds_cfg->lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lvds_cfg->differential_clk_rate < MIN_LVDS_REFCLK_FREQ ||\n\t    lvds_cfg->differential_clk_rate > MAX_LVDS_REFCLK_FREQ) {\n\t\tdev_err(&phy->dev,\n\t\t\t\"Invalid LVDS differential clock rate: %lu\\n\",\n\t\t\tlvds_cfg->differential_clk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mixel_dphy_validate(struct phy *phy, enum phy_mode mode, int submode,\n\t\t\t       union phy_configure_opts *opts)\n{\n\tif (mode == PHY_MODE_MIPI_DPHY) {\n\t\tstruct mixel_dphy_cfg mipi_dphy_cfg = { 0 };\n\n\t\treturn mixel_dphy_config_from_opts(phy, &opts->mipi_dphy,\n\t\t\t\t\t\t   &mipi_dphy_cfg);\n\t} else if (mode == PHY_MODE_LVDS) {\n\t\treturn mixel_dphy_validate_lvds_phy(phy, opts);\n\t}\n\n\tdev_err(&phy->dev,\n\t\t\"Failed to validate PHY with invalid PHY mode: %d\\n\", mode);\n\treturn -EINVAL;\n}\n\nstatic int mixel_dphy_init(struct phy *phy)\n{\n\tphy_write(phy, PWR_OFF, DPHY_PD_PLL);\n\tphy_write(phy, PWR_OFF, DPHY_PD_DPHY);\n\n\treturn 0;\n}\n\nstatic int mixel_dphy_exit(struct phy *phy)\n{\n\tphy_write(phy, 0, DPHY_CM);\n\tphy_write(phy, 0, DPHY_CN);\n\tphy_write(phy, 0, DPHY_CO);\n\n\treturn 0;\n}\n\nstatic int mixel_dphy_power_on_mipi_dphy(struct phy *phy)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\tu32 locked;\n\tint ret;\n\n\tphy_write(phy, PWR_ON, DPHY_PD_PLL);\n\tret = regmap_read_poll_timeout(priv->regmap, DPHY_LOCK, locked,\n\t\t\t\t       locked, PLL_LOCK_SLEEP,\n\t\t\t\t       PLL_LOCK_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&phy->dev, \"Could not get DPHY lock (%d)!\\n\", ret);\n\t\treturn ret;\n\t}\n\tphy_write(phy, PWR_ON, DPHY_PD_DPHY);\n\n\treturn 0;\n}\n\nstatic int mixel_dphy_power_on_lvds_phy(struct phy *phy)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\tu32 locked;\n\tint ret;\n\n\tregmap_update_bits(priv->lvds_regmap, PHY_CTRL, LVDS_EN, LVDS_EN);\n\n\tphy_write(phy, PWR_ON, DPHY_PD_DPHY);\n\tphy_write(phy, PWR_ON, DPHY_PD_PLL);\n\n\t \n\tif (priv->is_slave)\n\t\treturn 0;\n\n\tret = regmap_read_poll_timeout(priv->regmap, DPHY_LOCK, locked,\n\t\t\t\t       locked, PLL_LOCK_SLEEP,\n\t\t\t\t       PLL_LOCK_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&phy->dev, \"Could not get LVDS PHY lock (%d)!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mixel_dphy_power_on(struct phy *phy)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->phy_ref_clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (phy->attrs.mode == PHY_MODE_MIPI_DPHY) {\n\t\tret = mixel_dphy_power_on_mipi_dphy(phy);\n\t} else if (phy->attrs.mode == PHY_MODE_LVDS) {\n\t\tret = mixel_dphy_power_on_lvds_phy(phy);\n\t} else {\n\t\tdev_err(&phy->dev,\n\t\t\t\"Failed to power on PHY with invalid PHY mode: %d\\n\",\n\t\t\t\t\t\t\tphy->attrs.mode);\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto clock_disable;\n\n\treturn 0;\nclock_disable:\n\tclk_disable_unprepare(priv->phy_ref_clk);\n\treturn ret;\n}\n\nstatic int mixel_dphy_power_off(struct phy *phy)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\n\tphy_write(phy, PWR_OFF, DPHY_PD_PLL);\n\tphy_write(phy, PWR_OFF, DPHY_PD_DPHY);\n\n\tif (phy->attrs.mode == PHY_MODE_LVDS)\n\t\tregmap_update_bits(priv->lvds_regmap, PHY_CTRL, LVDS_EN, 0);\n\n\tclk_disable_unprepare(priv->phy_ref_clk);\n\n\treturn 0;\n}\n\nstatic int mixel_dphy_set_mode(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tstruct mixel_dphy_priv *priv = phy_get_drvdata(phy);\n\tint ret;\n\n\tif (priv->devdata->is_combo && mode != PHY_MODE_LVDS) {\n\t\tdev_err(&phy->dev, \"Failed to set PHY mode for combo PHY\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!priv->devdata->is_combo && mode != PHY_MODE_MIPI_DPHY) {\n\t\tdev_err(&phy->dev, \"Failed to set PHY mode to MIPI DPHY\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->devdata->is_combo) {\n\t\tu32 rsc = priv->id ? IMX_SC_R_MIPI_1 : IMX_SC_R_MIPI_0;\n\n\t\tret = imx_sc_misc_set_control(priv->ipc_handle,\n\t\t\t\t\t      rsc, IMX_SC_C_MODE,\n\t\t\t\t\t      mode == PHY_MODE_LVDS);\n\t\tif (ret) {\n\t\t\tdev_err(&phy->dev,\n\t\t\t\t\"Failed to set PHY mode via SCU ipc: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct phy_ops mixel_dphy_phy_ops = {\n\t.init = mixel_dphy_init,\n\t.exit = mixel_dphy_exit,\n\t.power_on = mixel_dphy_power_on,\n\t.power_off = mixel_dphy_power_off,\n\t.set_mode = mixel_dphy_set_mode,\n\t.configure = mixel_dphy_configure,\n\t.validate = mixel_dphy_validate,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id mixel_dphy_of_match[] = {\n\t{ .compatible = \"fsl,imx8mq-mipi-dphy\",\n\t  .data = &mixel_dphy_devdata[MIXEL_IMX8MQ] },\n\t{ .compatible = \"fsl,imx8qxp-mipi-dphy\",\n\t  .data = &mixel_dphy_devdata[MIXEL_IMX8QXP] },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mixel_dphy_of_match);\n\nstatic int mixel_dphy_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct phy_provider *phy_provider;\n\tstruct mixel_dphy_priv *priv;\n\tstruct phy *phy;\n\tvoid __iomem *base;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->devdata = of_device_get_match_data(&pdev->dev);\n\tif (!priv->devdata)\n\t\treturn -EINVAL;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t     &mixel_dphy_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(dev, \"Couldn't create the DPHY regmap\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tpriv->phy_ref_clk = devm_clk_get(&pdev->dev, \"phy_ref\");\n\tif (IS_ERR(priv->phy_ref_clk)) {\n\t\tdev_err(dev, \"No phy_ref clock found\\n\");\n\t\treturn PTR_ERR(priv->phy_ref_clk);\n\t}\n\tdev_dbg(dev, \"phy_ref clock rate: %lu\\n\",\n\t\tclk_get_rate(priv->phy_ref_clk));\n\n\tif (priv->devdata->is_combo) {\n\t\tpriv->lvds_regmap =\n\t\t\tsyscon_regmap_lookup_by_phandle(np, \"fsl,syscon\");\n\t\tif (IS_ERR(priv->lvds_regmap)) {\n\t\t\tret = PTR_ERR(priv->lvds_regmap);\n\t\t\tdev_err_probe(dev, ret, \"Failed to get LVDS regmap\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tpriv->id = of_alias_get_id(np, \"mipi_dphy\");\n\t\tif (priv->id < 0) {\n\t\t\tdev_err(dev, \"Failed to get phy node alias id: %d\\n\",\n\t\t\t\tpriv->id);\n\t\t\treturn priv->id;\n\t\t}\n\n\t\tret = imx_scu_get_handle(&priv->ipc_handle);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret,\n\t\t\t\t      \"Failed to get SCU ipc handle\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_set_drvdata(dev, priv);\n\n\tphy = devm_phy_create(dev, np, &mixel_dphy_phy_ops);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(dev, \"Failed to create phy %ld\\n\", PTR_ERR(phy));\n\t\treturn PTR_ERR(phy);\n\t}\n\tphy_set_drvdata(phy, priv);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver mixel_dphy_driver = {\n\t.probe\t= mixel_dphy_probe,\n\t.driver = {\n\t\t.name = \"mixel-mipi-dphy\",\n\t\t.of_match_table\t= mixel_dphy_of_match,\n\t}\n};\nmodule_platform_driver(mixel_dphy_driver);\n\nMODULE_AUTHOR(\"NXP Semiconductor\");\nMODULE_DESCRIPTION(\"Mixel MIPI-DSI PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}