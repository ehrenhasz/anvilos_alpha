{
  "module_name": "phy-fsl-imx8m-pcie.c",
  "hash_id": "bdfb29b3a3779c48b576c40edfad95b49c0fb8b9753498d208418359701e137b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/freescale/phy-fsl-imx8m-pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/imx7-iomuxc-gpr.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <dt-bindings/phy/phy-imx8-pcie.h>\n\n#define IMX8MM_PCIE_PHY_CMN_REG061\t0x184\n#define  ANA_PLL_CLK_OUT_TO_EXT_IO_EN\tBIT(0)\n#define IMX8MM_PCIE_PHY_CMN_REG062\t0x188\n#define  ANA_PLL_CLK_OUT_TO_EXT_IO_SEL\tBIT(3)\n#define IMX8MM_PCIE_PHY_CMN_REG063\t0x18C\n#define  AUX_PLL_REFCLK_SEL_SYS_PLL\tGENMASK(7, 6)\n#define IMX8MM_PCIE_PHY_CMN_REG064\t0x190\n#define  ANA_AUX_RX_TX_SEL_TX\t\tBIT(7)\n#define  ANA_AUX_RX_TERM_GND_EN\t\tBIT(3)\n#define  ANA_AUX_TX_TERM\t\tBIT(2)\n#define IMX8MM_PCIE_PHY_CMN_REG065\t0x194\n#define  ANA_AUX_RX_TERM\t\t(BIT(7) | BIT(4))\n#define  ANA_AUX_TX_LVL\t\t\tGENMASK(3, 0)\n#define IMX8MM_PCIE_PHY_CMN_REG075\t0x1D4\n#define  ANA_PLL_DONE\t\t\t0x3\n#define PCIE_PHY_TRSV_REG5\t\t0x414\n#define PCIE_PHY_TRSV_REG6\t\t0x418\n\n#define IMX8MM_GPR_PCIE_REF_CLK_SEL\tGENMASK(25, 24)\n#define IMX8MM_GPR_PCIE_REF_CLK_PLL\tFIELD_PREP(IMX8MM_GPR_PCIE_REF_CLK_SEL, 0x3)\n#define IMX8MM_GPR_PCIE_REF_CLK_EXT\tFIELD_PREP(IMX8MM_GPR_PCIE_REF_CLK_SEL, 0x2)\n#define IMX8MM_GPR_PCIE_AUX_EN\t\tBIT(19)\n#define IMX8MM_GPR_PCIE_CMN_RST\t\tBIT(18)\n#define IMX8MM_GPR_PCIE_POWER_OFF\tBIT(17)\n#define IMX8MM_GPR_PCIE_SSC_EN\t\tBIT(16)\n#define IMX8MM_GPR_PCIE_AUX_EN_OVERRIDE\tBIT(9)\n\nenum imx8_pcie_phy_type {\n\tIMX8MM,\n\tIMX8MP,\n};\n\nstruct imx8_pcie_phy_drvdata {\n\tconst\tchar\t\t\t*gpr;\n\tenum\timx8_pcie_phy_type\tvariant;\n};\n\nstruct imx8_pcie_phy {\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tstruct phy\t\t*phy;\n\tstruct regmap\t\t*iomuxc_gpr;\n\tstruct reset_control\t*perst;\n\tstruct reset_control\t*reset;\n\tu32\t\t\trefclk_pad_mode;\n\tu32\t\t\ttx_deemph_gen1;\n\tu32\t\t\ttx_deemph_gen2;\n\tbool\t\t\tclkreq_unused;\n\tconst struct imx8_pcie_phy_drvdata\t*drvdata;\n};\n\nstatic int imx8_pcie_phy_power_on(struct phy *phy)\n{\n\tint ret;\n\tu32 val, pad_mode;\n\tstruct imx8_pcie_phy *imx8_phy = phy_get_drvdata(phy);\n\n\tpad_mode = imx8_phy->refclk_pad_mode;\n\tswitch (imx8_phy->drvdata->variant) {\n\tcase IMX8MM:\n\t\treset_control_assert(imx8_phy->reset);\n\n\t\t \n\t\tif (imx8_phy->tx_deemph_gen1)\n\t\t\twritel(imx8_phy->tx_deemph_gen1,\n\t\t\t       imx8_phy->base + PCIE_PHY_TRSV_REG5);\n\t\tif (imx8_phy->tx_deemph_gen2)\n\t\t\twritel(imx8_phy->tx_deemph_gen2,\n\t\t\t       imx8_phy->base + PCIE_PHY_TRSV_REG6);\n\t\tbreak;\n\tcase IMX8MP:  \n\t\tbreak;\n\t}\n\n\tif (pad_mode == IMX8_PCIE_REFCLK_PAD_INPUT ||\n\t    pad_mode == IMX8_PCIE_REFCLK_PAD_UNUSED) {\n\t\t \n\t\tval = readl(imx8_phy->base + IMX8MM_PCIE_PHY_CMN_REG061);\n\t\twritel(val & ~ANA_PLL_CLK_OUT_TO_EXT_IO_EN,\n\t\t       imx8_phy->base + IMX8MM_PCIE_PHY_CMN_REG061);\n\t} else {\n\t\t \n\t\twritel(ANA_PLL_CLK_OUT_TO_EXT_IO_EN,\n\t\t       imx8_phy->base + IMX8MM_PCIE_PHY_CMN_REG061);\n\t}\n\n\tif (pad_mode == IMX8_PCIE_REFCLK_PAD_OUTPUT ||\n\t    pad_mode == IMX8_PCIE_REFCLK_PAD_UNUSED) {\n\t\t \n\t\twritel(ANA_PLL_CLK_OUT_TO_EXT_IO_SEL,\n\t\t       imx8_phy->base + IMX8MM_PCIE_PHY_CMN_REG062);\n\t\twritel(AUX_PLL_REFCLK_SEL_SYS_PLL,\n\t\t       imx8_phy->base + IMX8MM_PCIE_PHY_CMN_REG063);\n\t\tval = ANA_AUX_RX_TX_SEL_TX | ANA_AUX_TX_TERM;\n\t\twritel(val | ANA_AUX_RX_TERM_GND_EN,\n\t\t       imx8_phy->base + IMX8MM_PCIE_PHY_CMN_REG064);\n\t\twritel(ANA_AUX_RX_TERM | ANA_AUX_TX_LVL,\n\t\t       imx8_phy->base + IMX8MM_PCIE_PHY_CMN_REG065);\n\t}\n\n\t \n\tregmap_update_bits(imx8_phy->iomuxc_gpr, IOMUXC_GPR14,\n\t\t\t   IMX8MM_GPR_PCIE_AUX_EN_OVERRIDE,\n\t\t\t   imx8_phy->clkreq_unused ?\n\t\t\t   0 : IMX8MM_GPR_PCIE_AUX_EN_OVERRIDE);\n\tregmap_update_bits(imx8_phy->iomuxc_gpr, IOMUXC_GPR14,\n\t\t\t   IMX8MM_GPR_PCIE_AUX_EN,\n\t\t\t   IMX8MM_GPR_PCIE_AUX_EN);\n\tregmap_update_bits(imx8_phy->iomuxc_gpr, IOMUXC_GPR14,\n\t\t\t   IMX8MM_GPR_PCIE_POWER_OFF, 0);\n\tregmap_update_bits(imx8_phy->iomuxc_gpr, IOMUXC_GPR14,\n\t\t\t   IMX8MM_GPR_PCIE_SSC_EN, 0);\n\n\tregmap_update_bits(imx8_phy->iomuxc_gpr, IOMUXC_GPR14,\n\t\t\t   IMX8MM_GPR_PCIE_REF_CLK_SEL,\n\t\t\t   pad_mode == IMX8_PCIE_REFCLK_PAD_INPUT ?\n\t\t\t   IMX8MM_GPR_PCIE_REF_CLK_EXT :\n\t\t\t   IMX8MM_GPR_PCIE_REF_CLK_PLL);\n\tusleep_range(100, 200);\n\n\t \n\tregmap_update_bits(imx8_phy->iomuxc_gpr, IOMUXC_GPR14,\n\t\t\t   IMX8MM_GPR_PCIE_CMN_RST,\n\t\t\t   IMX8MM_GPR_PCIE_CMN_RST);\n\n\tswitch (imx8_phy->drvdata->variant) {\n\tcase IMX8MP:\n\t\treset_control_deassert(imx8_phy->perst);\n\t\tfallthrough;\n\tcase IMX8MM:\n\t\treset_control_deassert(imx8_phy->reset);\n\t\tusleep_range(200, 500);\n\t\tbreak;\n\t}\n\n\t \n\tret = readl_poll_timeout(imx8_phy->base + IMX8MM_PCIE_PHY_CMN_REG075,\n\t\t\t\t val, val == ANA_PLL_DONE, 10, 20000);\n\treturn ret;\n}\n\nstatic int imx8_pcie_phy_init(struct phy *phy)\n{\n\tstruct imx8_pcie_phy *imx8_phy = phy_get_drvdata(phy);\n\n\treturn clk_prepare_enable(imx8_phy->clk);\n}\n\nstatic int imx8_pcie_phy_exit(struct phy *phy)\n{\n\tstruct imx8_pcie_phy *imx8_phy = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(imx8_phy->clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops imx8_pcie_phy_ops = {\n\t.init\t\t= imx8_pcie_phy_init,\n\t.exit\t\t= imx8_pcie_phy_exit,\n\t.power_on\t= imx8_pcie_phy_power_on,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct imx8_pcie_phy_drvdata imx8mm_drvdata = {\n\t.gpr = \"fsl,imx8mm-iomuxc-gpr\",\n\t.variant = IMX8MM,\n};\n\nstatic const struct imx8_pcie_phy_drvdata imx8mp_drvdata = {\n\t.gpr = \"fsl,imx8mp-iomuxc-gpr\",\n\t.variant = IMX8MP,\n};\n\nstatic const struct of_device_id imx8_pcie_phy_of_match[] = {\n\t{.compatible = \"fsl,imx8mm-pcie-phy\", .data = &imx8mm_drvdata, },\n\t{.compatible = \"fsl,imx8mp-pcie-phy\", .data = &imx8mp_drvdata, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, imx8_pcie_phy_of_match);\n\nstatic int imx8_pcie_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct imx8_pcie_phy *imx8_phy;\n\n\timx8_phy = devm_kzalloc(dev, sizeof(*imx8_phy), GFP_KERNEL);\n\tif (!imx8_phy)\n\t\treturn -ENOMEM;\n\n\timx8_phy->drvdata = of_device_get_match_data(dev);\n\n\t \n\tof_property_read_u32(np, \"fsl,refclk-pad-mode\",\n\t\t\t     &imx8_phy->refclk_pad_mode);\n\n\tif (of_property_read_u32(np, \"fsl,tx-deemph-gen1\",\n\t\t\t\t &imx8_phy->tx_deemph_gen1))\n\t\timx8_phy->tx_deemph_gen1 = 0;\n\n\tif (of_property_read_u32(np, \"fsl,tx-deemph-gen2\",\n\t\t\t\t &imx8_phy->tx_deemph_gen2))\n\t\timx8_phy->tx_deemph_gen2 = 0;\n\n\tif (of_property_read_bool(np, \"fsl,clkreq-unsupported\"))\n\t\timx8_phy->clkreq_unused = true;\n\telse\n\t\timx8_phy->clkreq_unused = false;\n\n\timx8_phy->clk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(imx8_phy->clk)) {\n\t\tdev_err(dev, \"failed to get imx pcie phy clock\\n\");\n\t\treturn PTR_ERR(imx8_phy->clk);\n\t}\n\n\t \n\timx8_phy->iomuxc_gpr =\n\t\t syscon_regmap_lookup_by_compatible(imx8_phy->drvdata->gpr);\n\tif (IS_ERR(imx8_phy->iomuxc_gpr)) {\n\t\tdev_err(dev, \"unable to find iomuxc registers\\n\");\n\t\treturn PTR_ERR(imx8_phy->iomuxc_gpr);\n\t}\n\n\timx8_phy->reset = devm_reset_control_get_exclusive(dev, \"pciephy\");\n\tif (IS_ERR(imx8_phy->reset)) {\n\t\tdev_err(dev, \"Failed to get PCIEPHY reset control\\n\");\n\t\treturn PTR_ERR(imx8_phy->reset);\n\t}\n\n\tif (imx8_phy->drvdata->variant == IMX8MP) {\n\t\timx8_phy->perst =\n\t\t\tdevm_reset_control_get_exclusive(dev, \"perst\");\n\t\tif (IS_ERR(imx8_phy->perst))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(imx8_phy->perst),\n\t\t\t\t      \"Failed to get PCIE PHY PERST control\\n\");\n\t}\n\n\timx8_phy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(imx8_phy->base))\n\t\treturn PTR_ERR(imx8_phy->base);\n\n\timx8_phy->phy = devm_phy_create(dev, NULL, &imx8_pcie_phy_ops);\n\tif (IS_ERR(imx8_phy->phy))\n\t\treturn PTR_ERR(imx8_phy->phy);\n\n\tphy_set_drvdata(imx8_phy->phy, imx8_phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic struct platform_driver imx8_pcie_phy_driver = {\n\t.probe\t= imx8_pcie_phy_probe,\n\t.driver = {\n\t\t.name\t= \"imx8-pcie-phy\",\n\t\t.of_match_table\t= imx8_pcie_phy_of_match,\n\t}\n};\nmodule_platform_driver(imx8_pcie_phy_driver);\n\nMODULE_DESCRIPTION(\"FSL IMX8 PCIE PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}