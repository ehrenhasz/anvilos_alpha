{
  "module_name": "phy-lgm-usb.c",
  "hash_id": "893bedaaa4c57cace1cfc055ff3c8cd8947db5ac880bb0ca7e4ec1cc2d909955",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/phy-lgm-usb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/usb/phy.h>\n#include <linux/workqueue.h>\n\n#define CTRL1_OFFSET\t\t0x14\n#define SRAM_EXT_LD_DONE\tBIT(25)\n#define SRAM_INIT_DONE\t\tBIT(26)\n\n#define TCPC_OFFSET\t\t0x1014\n#define TCPC_MUX_CTL\t\tGENMASK(1, 0)\n#define MUX_NC\t\t\t0\n#define MUX_USB\t\t\t1\n#define MUX_DP\t\t\t2\n#define MUX_USBDP\t\t3\n#define TCPC_FLIPPED\t\tBIT(2)\n#define TCPC_LOW_POWER_EN\tBIT(3)\n#define TCPC_VALID\t\tBIT(4)\n#define TCPC_CONN\t\t\\\n\t(TCPC_VALID | FIELD_PREP(TCPC_MUX_CTL, MUX_USB))\n#define TCPC_DISCONN\t\t\\\n\t(TCPC_VALID | FIELD_PREP(TCPC_MUX_CTL, MUX_NC) | TCPC_LOW_POWER_EN)\n\nstatic const char *const PHY_RESETS[] = { \"phy31\", \"phy\", };\nstatic const char *const CTL_RESETS[] = { \"apb\", \"ctrl\", };\n\nstruct tca_apb {\n\tstruct reset_control *resets[ARRAY_SIZE(PHY_RESETS)];\n\tstruct regulator *vbus;\n\tstruct work_struct wk;\n\tstruct usb_phy phy;\n\n\tbool regulator_enabled;\n\tbool phy_initialized;\n\tbool connected;\n};\n\nstatic int get_flipped(struct tca_apb *ta, bool *flipped)\n{\n\tunion extcon_property_value property;\n\tint ret;\n\n\tret = extcon_get_property(ta->phy.edev, EXTCON_USB_HOST,\n\t\t\t\t  EXTCON_PROP_USB_TYPEC_POLARITY, &property);\n\tif (ret) {\n\t\tdev_err(ta->phy.dev, \"no polarity property from extcon\\n\");\n\t\treturn ret;\n\t}\n\n\t*flipped = property.intval;\n\n\treturn 0;\n}\n\nstatic int phy_init(struct usb_phy *phy)\n{\n\tstruct tca_apb *ta = container_of(phy, struct tca_apb, phy);\n\tvoid __iomem *ctrl1 = phy->io_priv + CTRL1_OFFSET;\n\tint val, ret, i;\n\n\tif (ta->phy_initialized)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(PHY_RESETS); i++)\n\t\treset_control_deassert(ta->resets[i]);\n\n\tret = readl_poll_timeout(ctrl1, val, val & SRAM_INIT_DONE, 10, 10 * 1000);\n\tif (ret) {\n\t\tdev_err(ta->phy.dev, \"SRAM init failed, 0x%x\\n\", val);\n\t\treturn ret;\n\t}\n\n\twritel(readl(ctrl1) | SRAM_EXT_LD_DONE, ctrl1);\n\n\tta->phy_initialized = true;\n\tif (!ta->phy.edev) {\n\t\twritel(TCPC_CONN, ta->phy.io_priv + TCPC_OFFSET);\n\t\treturn phy->set_vbus(phy, true);\n\t}\n\n\tschedule_work(&ta->wk);\n\n\treturn ret;\n}\n\nstatic void phy_shutdown(struct usb_phy *phy)\n{\n\tstruct tca_apb *ta = container_of(phy, struct tca_apb, phy);\n\tint i;\n\n\tif (!ta->phy_initialized)\n\t\treturn;\n\n\tta->phy_initialized = false;\n\tflush_work(&ta->wk);\n\tta->phy.set_vbus(&ta->phy, false);\n\n\tta->connected = false;\n\twritel(TCPC_DISCONN, ta->phy.io_priv + TCPC_OFFSET);\n\n\tfor (i = 0; i < ARRAY_SIZE(PHY_RESETS); i++)\n\t\treset_control_assert(ta->resets[i]);\n}\n\nstatic int phy_set_vbus(struct usb_phy *phy, int on)\n{\n\tstruct tca_apb *ta = container_of(phy, struct tca_apb, phy);\n\tint ret;\n\n\tif (!!on == ta->regulator_enabled)\n\t\treturn 0;\n\n\tif (on)\n\t\tret = regulator_enable(ta->vbus);\n\telse\n\t\tret = regulator_disable(ta->vbus);\n\n\tif (!ret)\n\t\tta->regulator_enabled = on;\n\n\tdev_dbg(ta->phy.dev, \"set vbus: %d\\n\", on);\n\treturn ret;\n}\n\nstatic void tca_work(struct work_struct *work)\n{\n\tstruct tca_apb *ta = container_of(work, struct tca_apb, wk);\n\tbool connected;\n\tbool flipped = false;\n\tu32 val;\n\tint ret;\n\n\tret = get_flipped(ta, &flipped);\n\tif (ret)\n\t\treturn;\n\n\tconnected = extcon_get_state(ta->phy.edev, EXTCON_USB_HOST);\n\tif (connected == ta->connected)\n\t\treturn;\n\n\tta->connected = connected;\n\tif (connected) {\n\t\tval = TCPC_CONN;\n\t\tif (flipped)\n\t\t\tval |= TCPC_FLIPPED;\n\t\tdev_dbg(ta->phy.dev, \"connected%s\\n\", flipped ? \" flipped\" : \"\");\n\t} else {\n\t\tval = TCPC_DISCONN;\n\t\tdev_dbg(ta->phy.dev, \"disconnected\\n\");\n\t}\n\n\twritel(val, ta->phy.io_priv + TCPC_OFFSET);\n\n\tret = ta->phy.set_vbus(&ta->phy, connected);\n\tif (ret)\n\t\tdev_err(ta->phy.dev, \"failed to set VBUS\\n\");\n}\n\nstatic int id_notifier(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct tca_apb *ta = container_of(nb, struct tca_apb, phy.id_nb);\n\n\tif (ta->phy_initialized)\n\t\tschedule_work(&ta->wk);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int vbus_notifier(struct notifier_block *nb, unsigned long evnt, void *ptr)\n{\n\treturn NOTIFY_DONE;\n}\n\nstatic int phy_probe(struct platform_device *pdev)\n{\n\tstruct reset_control *resets[ARRAY_SIZE(CTL_RESETS)];\n\tstruct device *dev = &pdev->dev;\n\tstruct usb_phy *phy;\n\tstruct tca_apb *ta;\n\tint i;\n\n\tta = devm_kzalloc(dev, sizeof(*ta), GFP_KERNEL);\n\tif (!ta)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ta);\n\tINIT_WORK(&ta->wk, tca_work);\n\n\tphy = &ta->phy;\n\tphy->dev = dev;\n\tphy->label = dev_name(dev);\n\tphy->type = USB_PHY_TYPE_USB3;\n\tphy->init = phy_init;\n\tphy->shutdown = phy_shutdown;\n\tphy->set_vbus = phy_set_vbus;\n\tphy->id_nb.notifier_call = id_notifier;\n\tphy->vbus_nb.notifier_call = vbus_notifier;\n\n\tphy->io_priv = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(phy->io_priv))\n\t\treturn PTR_ERR(phy->io_priv);\n\n\tta->vbus = devm_regulator_get(dev, \"vbus\");\n\tif (IS_ERR(ta->vbus))\n\t\treturn PTR_ERR(ta->vbus);\n\n\tfor (i = 0; i < ARRAY_SIZE(CTL_RESETS); i++) {\n\t\tresets[i] = devm_reset_control_get_exclusive(dev, CTL_RESETS[i]);\n\t\tif (IS_ERR(resets[i])) {\n\t\t\tdev_err(dev, \"%s reset not found\\n\", CTL_RESETS[i]);\n\t\t\treturn PTR_ERR(resets[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(PHY_RESETS); i++) {\n\t\tta->resets[i] = devm_reset_control_get_exclusive(dev, PHY_RESETS[i]);\n\t\tif (IS_ERR(ta->resets[i])) {\n\t\t\tdev_err(dev, \"%s reset not found\\n\", PHY_RESETS[i]);\n\t\t\treturn PTR_ERR(ta->resets[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(CTL_RESETS); i++)\n\t\treset_control_assert(resets[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(PHY_RESETS); i++)\n\t\treset_control_assert(ta->resets[i]);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(CTL_RESETS); i++)\n\t\treset_control_deassert(resets[i]);\n\n\t \n\tusleep_range(20, 100);\n\n\treturn usb_add_phy_dev(phy);\n}\n\nstatic void phy_remove(struct platform_device *pdev)\n{\n\tstruct tca_apb *ta = platform_get_drvdata(pdev);\n\n\tusb_remove_phy(&ta->phy);\n}\n\nstatic const struct of_device_id intel_usb_phy_dt_ids[] = {\n\t{ .compatible = \"intel,lgm-usb-phy\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, intel_usb_phy_dt_ids);\n\nstatic struct platform_driver lgm_phy_driver = {\n\t.driver = {\n\t\t.name = \"lgm-usb-phy\",\n\t\t.of_match_table = intel_usb_phy_dt_ids,\n\t},\n\t.probe = phy_probe,\n\t.remove_new = phy_remove,\n};\n\nmodule_platform_driver(lgm_phy_driver);\n\nMODULE_DESCRIPTION(\"Intel LGM USB PHY driver\");\nMODULE_AUTHOR(\"Li Yin <yin1.li@intel.com>\");\nMODULE_AUTHOR(\"Vadivel Murugan R <vadivel.muruganx.ramuthevar@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}