{
  "module_name": "cdns-dphy.c",
  "hash_id": "7ad2928d75aa9434058e0042ccb25be1a3f609b897584ba352e00de4bece38ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/cadence/cdns-dphy.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-mipi-dphy.h>\n\n#define REG_WAKEUP_TIME_NS\t\t800\n#define DPHY_PLL_RATE_HZ\t\t108000000\n#define POLL_TIMEOUT_US\t\t\t1000\n\n \n#define DPHY_PMA_CMN(reg)\t\t(reg)\n#define DPHY_PMA_LCLK(reg)\t\t(0x100 + (reg))\n#define DPHY_PMA_LDATA(lane, reg)\t(0x200 + ((lane) * 0x100) + (reg))\n#define DPHY_PMA_RCLK(reg)\t\t(0x600 + (reg))\n#define DPHY_PMA_RDATA(lane, reg)\t(0x700 + ((lane) * 0x100) + (reg))\n#define DPHY_PCS(reg)\t\t\t(0xb00 + (reg))\n\n#define DPHY_CMN_SSM\t\t\tDPHY_PMA_CMN(0x20)\n#define DPHY_CMN_SSM_EN\t\t\tBIT(0)\n#define DPHY_CMN_TX_MODE_EN\t\tBIT(9)\n\n#define DPHY_CMN_PWM\t\t\tDPHY_PMA_CMN(0x40)\n#define DPHY_CMN_PWM_DIV(x)\t\t((x) << 20)\n#define DPHY_CMN_PWM_LOW(x)\t\t((x) << 10)\n#define DPHY_CMN_PWM_HIGH(x)\t\t(x)\n\n#define DPHY_CMN_FBDIV\t\t\tDPHY_PMA_CMN(0x4c)\n#define DPHY_CMN_FBDIV_VAL(low, high)\t(((high) << 11) | ((low) << 22))\n#define DPHY_CMN_FBDIV_FROM_REG\t\t(BIT(10) | BIT(21))\n\n#define DPHY_CMN_OPIPDIV\t\tDPHY_PMA_CMN(0x50)\n#define DPHY_CMN_IPDIV_FROM_REG\t\tBIT(0)\n#define DPHY_CMN_IPDIV(x)\t\t((x) << 1)\n#define DPHY_CMN_OPDIV_FROM_REG\t\tBIT(6)\n#define DPHY_CMN_OPDIV(x)\t\t((x) << 7)\n\n#define DPHY_BAND_CFG\t\t\tDPHY_PCS(0x0)\n#define DPHY_BAND_CFG_LEFT_BAND\t\tGENMASK(4, 0)\n#define DPHY_BAND_CFG_RIGHT_BAND\tGENMASK(9, 5)\n\n#define DPHY_PSM_CFG\t\t\tDPHY_PCS(0x4)\n#define DPHY_PSM_CFG_FROM_REG\t\tBIT(0)\n#define DPHY_PSM_CLK_DIV(x)\t\t((x) << 1)\n\n#define DSI_HBP_FRAME_OVERHEAD\t\t12\n#define DSI_HSA_FRAME_OVERHEAD\t\t14\n#define DSI_HFP_FRAME_OVERHEAD\t\t6\n#define DSI_HSS_VSS_VSE_FRAME_OVERHEAD\t4\n#define DSI_BLANKING_FRAME_OVERHEAD\t6\n#define DSI_NULL_FRAME_OVERHEAD\t\t6\n#define DSI_EOT_PKT_SIZE\t\t4\n\n#define DPHY_TX_J721E_WIZ_PLL_CTRL\t0xF04\n#define DPHY_TX_J721E_WIZ_STATUS\t0xF08\n#define DPHY_TX_J721E_WIZ_RST_CTRL\t0xF0C\n#define DPHY_TX_J721E_WIZ_PSM_FREQ\t0xF10\n\n#define DPHY_TX_J721E_WIZ_IPDIV\t\tGENMASK(4, 0)\n#define DPHY_TX_J721E_WIZ_OPDIV\t\tGENMASK(13, 8)\n#define DPHY_TX_J721E_WIZ_FBDIV\t\tGENMASK(25, 16)\n#define DPHY_TX_J721E_WIZ_LANE_RSTB\tBIT(31)\n#define DPHY_TX_WIZ_PLL_LOCK\t\tBIT(31)\n#define DPHY_TX_WIZ_O_CMN_READY\t\tBIT(31)\n\nstruct cdns_dphy_cfg {\n\tu8 pll_ipdiv;\n\tu8 pll_opdiv;\n\tu16 pll_fbdiv;\n\tunsigned int nlanes;\n};\n\nenum cdns_dphy_clk_lane_cfg {\n\tDPHY_CLK_CFG_LEFT_DRIVES_ALL = 0,\n\tDPHY_CLK_CFG_LEFT_DRIVES_RIGHT = 1,\n\tDPHY_CLK_CFG_LEFT_DRIVES_LEFT = 2,\n\tDPHY_CLK_CFG_RIGHT_DRIVES_ALL = 3,\n};\n\nstruct cdns_dphy;\nstruct cdns_dphy_ops {\n\tint (*probe)(struct cdns_dphy *dphy);\n\tvoid (*remove)(struct cdns_dphy *dphy);\n\tvoid (*set_psm_div)(struct cdns_dphy *dphy, u8 div);\n\tvoid (*set_clk_lane_cfg)(struct cdns_dphy *dphy,\n\t\t\t\t enum cdns_dphy_clk_lane_cfg cfg);\n\tvoid (*set_pll_cfg)(struct cdns_dphy *dphy,\n\t\t\t    const struct cdns_dphy_cfg *cfg);\n\tunsigned long (*get_wakeup_time_ns)(struct cdns_dphy *dphy);\n};\n\nstruct cdns_dphy {\n\tstruct cdns_dphy_cfg cfg;\n\tvoid __iomem *regs;\n\tstruct clk *psm_clk;\n\tstruct clk *pll_ref_clk;\n\tconst struct cdns_dphy_ops *ops;\n\tstruct phy *phy;\n};\n\n \nstatic const unsigned int tx_bands[] = {\n\t80, 100, 120, 160, 200, 240, 320, 390, 450, 510, 560, 640, 690, 770,\n\t870, 950, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2500\n};\n\nstatic int cdns_dsi_get_dphy_pll_cfg(struct cdns_dphy *dphy,\n\t\t\t\t     struct cdns_dphy_cfg *cfg,\n\t\t\t\t     struct phy_configure_opts_mipi_dphy *opts,\n\t\t\t\t     unsigned int *dsi_hfp_ext)\n{\n\tunsigned long pll_ref_hz = clk_get_rate(dphy->pll_ref_clk);\n\tu64 dlane_bps;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\tif (pll_ref_hz < 9600000 || pll_ref_hz >= 150000000)\n\t\treturn -EINVAL;\n\telse if (pll_ref_hz < 19200000)\n\t\tcfg->pll_ipdiv = 1;\n\telse if (pll_ref_hz < 38400000)\n\t\tcfg->pll_ipdiv = 2;\n\telse if (pll_ref_hz < 76800000)\n\t\tcfg->pll_ipdiv = 4;\n\telse\n\t\tcfg->pll_ipdiv = 8;\n\n\tdlane_bps = opts->hs_clk_rate;\n\n\tif (dlane_bps > 2500000000UL || dlane_bps < 160000000UL)\n\t\treturn -EINVAL;\n\telse if (dlane_bps >= 1250000000)\n\t\tcfg->pll_opdiv = 1;\n\telse if (dlane_bps >= 630000000)\n\t\tcfg->pll_opdiv = 2;\n\telse if (dlane_bps >= 320000000)\n\t\tcfg->pll_opdiv = 4;\n\telse if (dlane_bps >= 160000000)\n\t\tcfg->pll_opdiv = 8;\n\n\tcfg->pll_fbdiv = DIV_ROUND_UP_ULL(dlane_bps * 2 * cfg->pll_opdiv *\n\t\t\t\t\t  cfg->pll_ipdiv,\n\t\t\t\t\t  pll_ref_hz);\n\n\treturn 0;\n}\n\nstatic int cdns_dphy_setup_psm(struct cdns_dphy *dphy)\n{\n\tunsigned long psm_clk_hz = clk_get_rate(dphy->psm_clk);\n\tunsigned long psm_div;\n\n\tif (!psm_clk_hz || psm_clk_hz > 100000000)\n\t\treturn -EINVAL;\n\n\tpsm_div = DIV_ROUND_CLOSEST(psm_clk_hz, 1000000);\n\tif (dphy->ops->set_psm_div)\n\t\tdphy->ops->set_psm_div(dphy, psm_div);\n\n\treturn 0;\n}\n\nstatic void cdns_dphy_set_clk_lane_cfg(struct cdns_dphy *dphy,\n\t\t\t\t       enum cdns_dphy_clk_lane_cfg cfg)\n{\n\tif (dphy->ops->set_clk_lane_cfg)\n\t\tdphy->ops->set_clk_lane_cfg(dphy, cfg);\n}\n\nstatic void cdns_dphy_set_pll_cfg(struct cdns_dphy *dphy,\n\t\t\t\t  const struct cdns_dphy_cfg *cfg)\n{\n\tif (dphy->ops->set_pll_cfg)\n\t\tdphy->ops->set_pll_cfg(dphy, cfg);\n}\n\nstatic unsigned long cdns_dphy_get_wakeup_time_ns(struct cdns_dphy *dphy)\n{\n\treturn dphy->ops->get_wakeup_time_ns(dphy);\n}\n\nstatic unsigned long cdns_dphy_ref_get_wakeup_time_ns(struct cdns_dphy *dphy)\n{\n\t \n\treturn 800;\n}\n\nstatic void cdns_dphy_ref_set_pll_cfg(struct cdns_dphy *dphy,\n\t\t\t\t      const struct cdns_dphy_cfg *cfg)\n{\n\tu32 fbdiv_low, fbdiv_high;\n\n\tfbdiv_low = (cfg->pll_fbdiv / 4) - 2;\n\tfbdiv_high = cfg->pll_fbdiv - fbdiv_low - 2;\n\n\twritel(DPHY_CMN_IPDIV_FROM_REG | DPHY_CMN_OPDIV_FROM_REG |\n\t       DPHY_CMN_IPDIV(cfg->pll_ipdiv) |\n\t       DPHY_CMN_OPDIV(cfg->pll_opdiv),\n\t       dphy->regs + DPHY_CMN_OPIPDIV);\n\twritel(DPHY_CMN_FBDIV_FROM_REG |\n\t       DPHY_CMN_FBDIV_VAL(fbdiv_low, fbdiv_high),\n\t       dphy->regs + DPHY_CMN_FBDIV);\n\twritel(DPHY_CMN_PWM_HIGH(6) | DPHY_CMN_PWM_LOW(0x101) |\n\t       DPHY_CMN_PWM_DIV(0x8),\n\t       dphy->regs + DPHY_CMN_PWM);\n}\n\nstatic void cdns_dphy_ref_set_psm_div(struct cdns_dphy *dphy, u8 div)\n{\n\twritel(DPHY_PSM_CFG_FROM_REG | DPHY_PSM_CLK_DIV(div),\n\t       dphy->regs + DPHY_PSM_CFG);\n}\n\nstatic unsigned long cdns_dphy_j721e_get_wakeup_time_ns(struct cdns_dphy *dphy)\n{\n\t \n\treturn 1000000;\n}\n\nstatic void cdns_dphy_j721e_set_pll_cfg(struct cdns_dphy *dphy,\n\t\t\t\t\tconst struct cdns_dphy_cfg *cfg)\n{\n\tu32 status;\n\n\t \n\twritel(DPHY_CMN_PWM_HIGH(6) | DPHY_CMN_PWM_LOW(0x101) |\n\t       DPHY_CMN_PWM_DIV(0x8),\n\t       dphy->regs + DPHY_CMN_PWM);\n\n\twritel((FIELD_PREP(DPHY_TX_J721E_WIZ_IPDIV, cfg->pll_ipdiv) |\n\t\tFIELD_PREP(DPHY_TX_J721E_WIZ_OPDIV, cfg->pll_opdiv) |\n\t\tFIELD_PREP(DPHY_TX_J721E_WIZ_FBDIV, cfg->pll_fbdiv)),\n\t\tdphy->regs + DPHY_TX_J721E_WIZ_PLL_CTRL);\n\n\twritel(DPHY_TX_J721E_WIZ_LANE_RSTB,\n\t       dphy->regs + DPHY_TX_J721E_WIZ_RST_CTRL);\n\n\treadl_poll_timeout(dphy->regs + DPHY_TX_J721E_WIZ_PLL_CTRL, status,\n\t\t\t   (status & DPHY_TX_WIZ_PLL_LOCK), 0, POLL_TIMEOUT_US);\n\n\treadl_poll_timeout(dphy->regs + DPHY_TX_J721E_WIZ_STATUS, status,\n\t\t\t   (status & DPHY_TX_WIZ_O_CMN_READY), 0,\n\t\t\t   POLL_TIMEOUT_US);\n}\n\nstatic void cdns_dphy_j721e_set_psm_div(struct cdns_dphy *dphy, u8 div)\n{\n\twritel(div, dphy->regs + DPHY_TX_J721E_WIZ_PSM_FREQ);\n}\n\n \nstatic const struct cdns_dphy_ops ref_dphy_ops = {\n\t.get_wakeup_time_ns = cdns_dphy_ref_get_wakeup_time_ns,\n\t.set_pll_cfg = cdns_dphy_ref_set_pll_cfg,\n\t.set_psm_div = cdns_dphy_ref_set_psm_div,\n};\n\nstatic const struct cdns_dphy_ops j721e_dphy_ops = {\n\t.get_wakeup_time_ns = cdns_dphy_j721e_get_wakeup_time_ns,\n\t.set_pll_cfg = cdns_dphy_j721e_set_pll_cfg,\n\t.set_psm_div = cdns_dphy_j721e_set_psm_div,\n};\n\nstatic int cdns_dphy_config_from_opts(struct phy *phy,\n\t\t\t\t      struct phy_configure_opts_mipi_dphy *opts,\n\t\t\t\t      struct cdns_dphy_cfg *cfg)\n{\n\tstruct cdns_dphy *dphy = phy_get_drvdata(phy);\n\tunsigned int dsi_hfp_ext = 0;\n\tint ret;\n\n\tret = phy_mipi_dphy_config_validate(opts);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cdns_dsi_get_dphy_pll_cfg(dphy, cfg,\n\t\t\t\t\topts, &dsi_hfp_ext);\n\tif (ret)\n\t\treturn ret;\n\n\topts->wakeup = cdns_dphy_get_wakeup_time_ns(dphy) / 1000;\n\n\treturn 0;\n}\n\nstatic int cdns_dphy_tx_get_band_ctrl(unsigned long hs_clk_rate)\n{\n\tunsigned int rate;\n\tint i;\n\n\trate = hs_clk_rate / 1000000UL;\n\n\tif (rate < tx_bands[0])\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < ARRAY_SIZE(tx_bands) - 1; i++) {\n\t\tif (rate >= tx_bands[i] && rate < tx_bands[i + 1])\n\t\t\treturn i;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cdns_dphy_validate(struct phy *phy, enum phy_mode mode, int submode,\n\t\t\t      union phy_configure_opts *opts)\n{\n\tstruct cdns_dphy_cfg cfg = { 0 };\n\n\tif (mode != PHY_MODE_MIPI_DPHY)\n\t\treturn -EINVAL;\n\n\treturn cdns_dphy_config_from_opts(phy, &opts->mipi_dphy, &cfg);\n}\n\nstatic int cdns_dphy_configure(struct phy *phy, union phy_configure_opts *opts)\n{\n\tstruct cdns_dphy *dphy = phy_get_drvdata(phy);\n\tstruct cdns_dphy_cfg cfg = { 0 };\n\tint ret, band_ctrl;\n\tunsigned int reg;\n\n\tret = cdns_dphy_config_from_opts(phy, &opts->mipi_dphy, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cdns_dphy_setup_psm(dphy);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcdns_dphy_set_clk_lane_cfg(dphy, DPHY_CLK_CFG_LEFT_DRIVES_LEFT);\n\n\t \n\tcdns_dphy_set_pll_cfg(dphy, &cfg);\n\n\tband_ctrl = cdns_dphy_tx_get_band_ctrl(opts->mipi_dphy.hs_clk_rate);\n\tif (band_ctrl < 0)\n\t\treturn band_ctrl;\n\n\treg = FIELD_PREP(DPHY_BAND_CFG_LEFT_BAND, band_ctrl) |\n\t      FIELD_PREP(DPHY_BAND_CFG_RIGHT_BAND, band_ctrl);\n\twritel(reg, dphy->regs + DPHY_BAND_CFG);\n\n\treturn 0;\n}\n\nstatic int cdns_dphy_power_on(struct phy *phy)\n{\n\tstruct cdns_dphy *dphy = phy_get_drvdata(phy);\n\n\tclk_prepare_enable(dphy->psm_clk);\n\tclk_prepare_enable(dphy->pll_ref_clk);\n\n\t \n\twritel(DPHY_CMN_SSM_EN | DPHY_CMN_TX_MODE_EN,\n\t       dphy->regs + DPHY_CMN_SSM);\n\n\treturn 0;\n}\n\nstatic int cdns_dphy_power_off(struct phy *phy)\n{\n\tstruct cdns_dphy *dphy = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(dphy->pll_ref_clk);\n\tclk_disable_unprepare(dphy->psm_clk);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops cdns_dphy_ops = {\n\t.configure\t= cdns_dphy_configure,\n\t.validate\t= cdns_dphy_validate,\n\t.power_on\t= cdns_dphy_power_on,\n\t.power_off\t= cdns_dphy_power_off,\n};\n\nstatic int cdns_dphy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct cdns_dphy *dphy;\n\tint ret;\n\n\tdphy = devm_kzalloc(&pdev->dev, sizeof(*dphy), GFP_KERNEL);\n\tif (!dphy)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(&pdev->dev, dphy);\n\n\tdphy->ops = of_device_get_match_data(&pdev->dev);\n\tif (!dphy->ops)\n\t\treturn -EINVAL;\n\n\tdphy->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dphy->regs))\n\t\treturn PTR_ERR(dphy->regs);\n\n\tdphy->psm_clk = devm_clk_get(&pdev->dev, \"psm\");\n\tif (IS_ERR(dphy->psm_clk))\n\t\treturn PTR_ERR(dphy->psm_clk);\n\n\tdphy->pll_ref_clk = devm_clk_get(&pdev->dev, \"pll_ref\");\n\tif (IS_ERR(dphy->pll_ref_clk))\n\t\treturn PTR_ERR(dphy->pll_ref_clk);\n\n\tif (dphy->ops->probe) {\n\t\tret = dphy->ops->probe(dphy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdphy->phy = devm_phy_create(&pdev->dev, NULL, &cdns_dphy_ops);\n\tif (IS_ERR(dphy->phy)) {\n\t\tdev_err(&pdev->dev, \"failed to create PHY\\n\");\n\t\tif (dphy->ops->remove)\n\t\t\tdphy->ops->remove(dphy);\n\t\treturn PTR_ERR(dphy->phy);\n\t}\n\n\tphy_set_drvdata(dphy->phy, dphy);\n\tphy_provider = devm_of_phy_provider_register(&pdev->dev,\n\t\t\t\t\t\t     of_phy_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic void cdns_dphy_remove(struct platform_device *pdev)\n{\n\tstruct cdns_dphy *dphy = dev_get_drvdata(&pdev->dev);\n\n\tif (dphy->ops->remove)\n\t\tdphy->ops->remove(dphy);\n}\n\nstatic const struct of_device_id cdns_dphy_of_match[] = {\n\t{ .compatible = \"cdns,dphy\", .data = &ref_dphy_ops },\n\t{ .compatible = \"ti,j721e-dphy\", .data = &j721e_dphy_ops },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, cdns_dphy_of_match);\n\nstatic struct platform_driver cdns_dphy_platform_driver = {\n\t.probe\t\t= cdns_dphy_probe,\n\t.remove_new\t= cdns_dphy_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"cdns-mipi-dphy\",\n\t\t.of_match_table\t= cdns_dphy_of_match,\n\t},\n};\nmodule_platform_driver(cdns_dphy_platform_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@bootlin.com>\");\nMODULE_DESCRIPTION(\"Cadence MIPI D-PHY Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}