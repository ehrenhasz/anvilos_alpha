{
  "module_name": "cdns-dphy-rx.c",
  "hash_id": "bdac82edbcbd97b526ea77e415a40212de467d8492767383b2a08b318d150b67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/cadence/cdns-dphy-rx.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-mipi-dphy.h>\n#include <linux/platform_device.h>\n#include <linux/sys_soc.h>\n\n#define DPHY_PMA_CMN(reg)\t\t(reg)\n#define DPHY_PCS(reg)\t\t\t(0xb00 + (reg))\n#define DPHY_ISO(reg)\t\t\t(0xc00 + (reg))\n#define DPHY_WRAP(reg)\t\t\t(0x1000 + (reg))\n\n#define DPHY_CMN_SSM\t\t\tDPHY_PMA_CMN(0x20)\n#define DPHY_CMN_RX_MODE_EN\t\tBIT(10)\n#define DPHY_CMN_RX_BANDGAP_TIMER_MASK\tGENMASK(8, 1)\n#define DPHY_CMN_SSM_EN\t\t\tBIT(0)\n\n#define DPHY_CMN_RX_BANDGAP_TIMER\t0x14\n\n#define DPHY_BAND_CFG\t\t\tDPHY_PCS(0x0)\n#define DPHY_BAND_CFG_RIGHT_BAND\tGENMASK(9, 5)\n#define DPHY_BAND_CFG_LEFT_BAND\t\tGENMASK(4, 0)\n\n#define DPHY_POWER_ISLAND_EN_DATA\tDPHY_PCS(0x8)\n#define DPHY_POWER_ISLAND_EN_DATA_VAL\t0xaaaaaaaa\n\n#define DPHY_POWER_ISLAND_EN_CLK\tDPHY_PCS(0xc)\n#define DPHY_POWER_ISLAND_EN_CLK_VAL\t0xaa\n\n#define DPHY_LANE\t\t\tDPHY_WRAP(0x0)\n#define DPHY_LANE_RESET_CMN_EN\t\tBIT(23)\n\n#define DPHY_ISO_CL_CTRL_L\t\tDPHY_ISO(0x10)\n#define DPHY_ISO_DL_CTRL_L0\t\tDPHY_ISO(0x14)\n#define DPHY_ISO_DL_CTRL_L1\t\tDPHY_ISO(0x20)\n#define DPHY_ISO_DL_CTRL_L2\t\tDPHY_ISO(0x30)\n#define DPHY_ISO_DL_CTRL_L3\t\tDPHY_ISO(0x3c)\n\n#define DPHY_ISO_LANE_READY_BIT\t\t0\n#define DPHY_ISO_LANE_READY_TIMEOUT_MS\t100UL\n\n#define DPHY_LANES_MIN\t\t\t1\n#define DPHY_LANES_MAX\t\t\t4\n\nstruct cdns_dphy_rx {\n\tvoid __iomem *regs;\n\tstruct device *dev;\n\tstruct phy *phy;\n};\n\nstruct cdns_dphy_rx_band {\n\t \n\tunsigned int min_rate;\n\tunsigned int max_rate;\n};\n\nstruct cdns_dphy_soc_data {\n\tbool has_hw_cmn_rstb;\n};\n\n \nstatic const struct cdns_dphy_rx_band bands[] = {\n\t{ 80, 100 }, { 100, 120 }, { 120, 160 }, { 160, 200 }, { 200, 240 },\n\t{ 240, 280 }, { 280, 320 }, { 320, 360 }, { 360, 400 }, { 400, 480 },\n\t{ 480, 560 }, { 560, 640 }, { 640, 720 }, { 720, 800 }, { 800, 880 },\n\t{ 880, 1040 }, { 1040, 1200 }, { 1200, 1350 }, { 1350, 1500 },\n\t{ 1500, 1750 }, { 1750, 2000 }, { 2000, 2250 }, { 2250, 2500 }\n};\n\nstatic int cdns_dphy_rx_power_on(struct phy *phy)\n{\n\tstruct cdns_dphy_rx *dphy = phy_get_drvdata(phy);\n\n\t \n\twritel(DPHY_CMN_SSM_EN | DPHY_CMN_RX_MODE_EN |\n\t       FIELD_PREP(DPHY_CMN_RX_BANDGAP_TIMER_MASK,\n\t\t\t  DPHY_CMN_RX_BANDGAP_TIMER),\n\t       dphy->regs + DPHY_CMN_SSM);\n\n\treturn 0;\n}\n\nstatic int cdns_dphy_rx_power_off(struct phy *phy)\n{\n\tstruct cdns_dphy_rx *dphy = phy_get_drvdata(phy);\n\n\twritel(0, dphy->regs + DPHY_CMN_SSM);\n\n\treturn 0;\n}\n\nstatic int cdns_dphy_rx_get_band_ctrl(unsigned long hs_clk_rate)\n{\n\tunsigned int rate, i;\n\n\trate = hs_clk_rate / 1000000UL;\n\t \n\trate *= 2;\n\n\tif (rate < bands[0].min_rate)\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < ARRAY_SIZE(bands); i++)\n\t\tif (rate < bands[i].max_rate)\n\t\t\treturn i;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int cdns_dphy_rx_wait_for_bit(void __iomem *addr,\n\t\t\t\t\t    unsigned int bit)\n{\n\tu32 val;\n\n\treturn readl_relaxed_poll_timeout(addr, val, val & BIT(bit), 10,\n\t\t\t\t\t  DPHY_ISO_LANE_READY_TIMEOUT_MS * 1000);\n}\n\nstatic int cdns_dphy_rx_wait_lane_ready(struct cdns_dphy_rx *dphy,\n\t\t\t\t\tunsigned int lanes)\n{\n\tstatic const u32 data_lane_ctrl[] = {DPHY_ISO_DL_CTRL_L0,\n\t\t\t\t\t     DPHY_ISO_DL_CTRL_L1,\n\t\t\t\t\t     DPHY_ISO_DL_CTRL_L2,\n\t\t\t\t\t     DPHY_ISO_DL_CTRL_L3};\n\tvoid __iomem *reg = dphy->regs;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tret = cdns_dphy_rx_wait_for_bit(reg + DPHY_ISO_CL_CTRL_L,\n\t\t\t\t\tDPHY_ISO_LANE_READY_BIT);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < lanes; i++) {\n\t\tret = cdns_dphy_rx_wait_for_bit(reg + data_lane_ctrl[i],\n\t\t\t\t\t\tDPHY_ISO_LANE_READY_BIT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct cdns_dphy_soc_data j721e_soc_data = {\n\t.has_hw_cmn_rstb = true,\n};\n\nstatic const struct soc_device_attribute cdns_dphy_socinfo[] = {\n\t{\n\t\t.family = \"J721E\",\n\t\t.revision = \"SR1.0\",\n\t\t.data = &j721e_soc_data,\n\t},\n\t{ }\n};\n\nstatic int cdns_dphy_rx_configure(struct phy *phy,\n\t\t\t\t  union phy_configure_opts *opts)\n{\n\tstruct cdns_dphy_rx *dphy = phy_get_drvdata(phy);\n\tunsigned int reg, lanes = opts->mipi_dphy.lanes;\n\tconst struct cdns_dphy_soc_data *soc_data = NULL;\n\tconst struct soc_device_attribute *soc;\n\tint band_ctrl, ret;\n\n\tsoc = soc_device_match(cdns_dphy_socinfo);\n\tif (soc && soc->data)\n\t\tsoc_data = soc->data;\n\tif (!soc || (soc_data && !soc_data->has_hw_cmn_rstb)) {\n\t\treg = DPHY_LANE_RESET_CMN_EN;\n\t\twritel(reg, dphy->regs + DPHY_LANE);\n\t}\n\n\t \n\tif (lanes < DPHY_LANES_MIN || lanes > DPHY_LANES_MAX)\n\t\treturn -EINVAL;\n\n\tband_ctrl = cdns_dphy_rx_get_band_ctrl(opts->mipi_dphy.hs_clk_rate);\n\tif (band_ctrl < 0)\n\t\treturn band_ctrl;\n\n\treg = FIELD_PREP(DPHY_BAND_CFG_LEFT_BAND, band_ctrl) |\n\t      FIELD_PREP(DPHY_BAND_CFG_RIGHT_BAND, band_ctrl);\n\twritel(reg, dphy->regs + DPHY_BAND_CFG);\n\n\t \n\treg = DPHY_POWER_ISLAND_EN_DATA_VAL;\n\twritel(reg, dphy->regs + DPHY_POWER_ISLAND_EN_DATA);\n\treg = DPHY_POWER_ISLAND_EN_CLK_VAL;\n\twritel(reg, dphy->regs + DPHY_POWER_ISLAND_EN_CLK);\n\n\tret = cdns_dphy_rx_wait_lane_ready(dphy, lanes);\n\tif (ret) {\n\t\tdev_err(dphy->dev, \"DPHY wait for lane ready timeout\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_dphy_rx_validate(struct phy *phy, enum phy_mode mode,\n\t\t\t\t int submode, union phy_configure_opts *opts)\n{\n\tint ret;\n\n\tif (mode != PHY_MODE_MIPI_DPHY)\n\t\treturn -EINVAL;\n\n\tret = cdns_dphy_rx_get_band_ctrl(opts->mipi_dphy.hs_clk_rate);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_mipi_dphy_config_validate(&opts->mipi_dphy);\n}\n\nstatic const struct phy_ops cdns_dphy_rx_ops = {\n\t.power_on = cdns_dphy_rx_power_on,\n\t.power_off = cdns_dphy_rx_power_off,\n\t.configure = cdns_dphy_rx_configure,\n\t.validate = cdns_dphy_rx_validate,\n};\n\nstatic int cdns_dphy_rx_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct phy_provider *provider;\n\tstruct cdns_dphy_rx *dphy;\n\n\tdphy = devm_kzalloc(dev, sizeof(*dphy), GFP_KERNEL);\n\tif (!dphy)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, dphy);\n\tdphy->dev = dev;\n\n\tdphy->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dphy->regs))\n\t\treturn PTR_ERR(dphy->regs);\n\n\tdphy->phy = devm_phy_create(dev, NULL, &cdns_dphy_rx_ops);\n\tif (IS_ERR(dphy->phy)) {\n\t\tdev_err(dev, \"Failed to create PHY: %ld\\n\", PTR_ERR(dphy->phy));\n\t\treturn PTR_ERR(dphy->phy);\n\t}\n\n\tphy_set_drvdata(dphy->phy, dphy);\n\tprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\tif (IS_ERR(provider)) {\n\t\tdev_err(dev, \"Failed to register PHY provider: %ld\\n\",\n\t\t\tPTR_ERR(provider));\n\t\treturn PTR_ERR(provider);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cdns_dphy_rx_of_match[] = {\n\t{ .compatible = \"cdns,dphy-rx\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, cdns_dphy_rx_of_match);\n\nstatic struct platform_driver cdns_dphy_rx_platform_driver = {\n\t.probe\t\t= cdns_dphy_rx_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"cdns-mipi-dphy-rx\",\n\t\t.of_match_table\t= cdns_dphy_rx_of_match,\n\t},\n};\nmodule_platform_driver(cdns_dphy_rx_platform_driver);\n\nMODULE_AUTHOR(\"Pratyush Yadav <p.yadav@ti.com>\");\nMODULE_DESCRIPTION(\"Cadence D-PHY Rx Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}