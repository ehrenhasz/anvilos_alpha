{
  "module_name": "phy-cadence-salvo.c",
  "hash_id": "cb5c1353920f6a21f904dbaa9cd74840d5613c99000325b6b144d00656c31f9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/cadence/phy-cadence-salvo.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n\n#define USB3_PHY_OFFSET\t\t\t0x0\n#define USB2_PHY_OFFSET\t\t\t0x38000\n \n#define PHY_PMA_CMN_CTRL1\t\t\t0xC800\n#define TB_ADDR_CMN_DIAG_HSCLK_SEL\t\t0x01e0\n#define TB_ADDR_CMN_PLL0_VCOCAL_INIT_TMR\t0x0084\n#define TB_ADDR_CMN_PLL0_VCOCAL_ITER_TMR\t0x0085\n#define TB_ADDR_CMN_PLL0_INTDIV\t                0x0094\n#define TB_ADDR_CMN_PLL0_FRACDIV\t\t0x0095\n#define TB_ADDR_CMN_PLL0_HIGH_THR\t\t0x0096\n#define TB_ADDR_CMN_PLL0_SS_CTRL1\t\t0x0098\n#define TB_ADDR_CMN_PLL0_SS_CTRL2\t\t0x0099\n#define TB_ADDR_CMN_PLL0_DSM_DIAG\t\t0x0097\n#define TB_ADDR_CMN_DIAG_PLL0_OVRD\t\t0x01c2\n#define TB_ADDR_CMN_DIAG_PLL0_FBH_OVRD\t\t0x01c0\n#define TB_ADDR_CMN_DIAG_PLL0_FBL_OVRD\t\t0x01c1\n#define TB_ADDR_CMN_DIAG_PLL0_V2I_TUNE          0x01C5\n#define TB_ADDR_CMN_DIAG_PLL0_CP_TUNE           0x01C6\n#define TB_ADDR_CMN_DIAG_PLL0_LF_PROG           0x01C7\n#define TB_ADDR_CMN_DIAG_PLL0_TEST_MODE\t\t0x01c4\n#define TB_ADDR_CMN_PSM_CLK_CTRL\t\t0x0061\n#define TB_ADDR_XCVR_DIAG_RX_LANE_CAL_RST_TMR\t0x40ea\n#define TB_ADDR_XCVR_PSM_RCTRL\t                0x4001\n#define TB_ADDR_TX_PSC_A0\t\t        0x4100\n#define TB_ADDR_TX_PSC_A1\t\t        0x4101\n#define TB_ADDR_TX_PSC_A2\t\t        0x4102\n#define TB_ADDR_TX_PSC_A3\t\t        0x4103\n#define TB_ADDR_TX_DIAG_ECTRL_OVRD\t\t0x41f5\n#define TB_ADDR_TX_PSC_CAL\t\t        0x4106\n#define TB_ADDR_TX_PSC_RDY\t\t        0x4107\n#define TB_ADDR_RX_PSC_A0\t                0x8000\n#define TB_ADDR_RX_PSC_A1\t                0x8001\n#define TB_ADDR_RX_PSC_A2\t                0x8002\n#define TB_ADDR_RX_PSC_A3\t                0x8003\n#define TB_ADDR_RX_PSC_CAL\t                0x8006\n#define TB_ADDR_RX_PSC_RDY\t                0x8007\n#define TB_ADDR_TX_TXCC_MGNLS_MULT_000\t\t0x4058\n#define TB_ADDR_TX_DIAG_BGREF_PREDRV_DELAY\t0x41e7\n#define TB_ADDR_RX_SLC_CU_ITER_TMR\t\t0x80e3\n#define TB_ADDR_RX_SIGDET_HL_FILT_TMR\t\t0x8090\n#define TB_ADDR_RX_SAMP_DAC_CTRL\t\t0x8058\n#define TB_ADDR_RX_DIAG_SIGDET_TUNE\t\t0x81dc\n#define TB_ADDR_RX_DIAG_LFPSDET_TUNE2\t\t0x81df\n#define TB_ADDR_RX_DIAG_BS_TM\t                0x81f5\n#define TB_ADDR_RX_DIAG_DFE_CTRL1\t\t0x81d3\n#define TB_ADDR_RX_DIAG_ILL_IQE_TRIM4\t\t0x81c7\n#define TB_ADDR_RX_DIAG_ILL_E_TRIM0\t\t0x81c2\n#define TB_ADDR_RX_DIAG_ILL_IQ_TRIM0\t\t0x81c1\n#define TB_ADDR_RX_DIAG_ILL_IQE_TRIM6\t\t0x81c9\n#define TB_ADDR_RX_DIAG_RXFE_TM3\t\t0x81f8\n#define TB_ADDR_RX_DIAG_RXFE_TM4\t\t0x81f9\n#define TB_ADDR_RX_DIAG_LFPSDET_TUNE\t\t0x81dd\n#define TB_ADDR_RX_DIAG_DFE_CTRL3\t\t0x81d5\n#define TB_ADDR_RX_DIAG_SC2C_DELAY\t\t0x81e1\n#define TB_ADDR_RX_REE_VGA_GAIN_NODFE\t\t0x81bf\n#define TB_ADDR_XCVR_PSM_CAL_TMR\t\t0x4002\n#define TB_ADDR_XCVR_PSM_A0BYP_TMR\t\t0x4004\n#define TB_ADDR_XCVR_PSM_A0IN_TMR\t\t0x4003\n#define TB_ADDR_XCVR_PSM_A1IN_TMR\t\t0x4005\n#define TB_ADDR_XCVR_PSM_A2IN_TMR\t\t0x4006\n#define TB_ADDR_XCVR_PSM_A3IN_TMR\t\t0x4007\n#define TB_ADDR_XCVR_PSM_A4IN_TMR\t\t0x4008\n#define TB_ADDR_XCVR_PSM_A5IN_TMR\t\t0x4009\n#define TB_ADDR_XCVR_PSM_A0OUT_TMR\t\t0x400a\n#define TB_ADDR_XCVR_PSM_A1OUT_TMR\t\t0x400b\n#define TB_ADDR_XCVR_PSM_A2OUT_TMR\t\t0x400c\n#define TB_ADDR_XCVR_PSM_A3OUT_TMR\t\t0x400d\n#define TB_ADDR_XCVR_PSM_A4OUT_TMR\t\t0x400e\n#define TB_ADDR_XCVR_PSM_A5OUT_TMR\t\t0x400f\n#define TB_ADDR_TX_RCVDET_EN_TMR\t        0x4122\n#define TB_ADDR_TX_RCVDET_ST_TMR\t        0x4123\n#define TB_ADDR_XCVR_DIAG_LANE_FCM_EN_MGN_TMR\t0x40f2\n#define TB_ADDR_TX_RCVDETSC_CTRL\t        0x4124\n\n \n#define UTMI_REG15\t\t\t\t0xaf\n#define UTMI_AFE_RX_REG0\t\t\t0x0d\n#define UTMI_AFE_RX_REG5\t\t\t0x12\n#define UTMI_AFE_BC_REG4\t\t\t0x29\n\n \nenum usb2_disconn_threshold {\n\tUSB2_DISCONN_THRESHOLD_575 = 0x0,\n\tUSB2_DISCONN_THRESHOLD_610 = 0x1,\n\tUSB2_DISCONN_THRESHOLD_645 = 0x3,\n};\n\n#define RX_USB2_DISCONN_MASK\t\t\tGENMASK(7, 6)\n\n \n#define RXDET_IN_P3_32KHZ\t\t\tBIT(0)\n \n#define TXVALID_GATE_THRESHOLD_HS_MASK\t\t(BIT(4) | BIT(5))\n \n#define TXVALID_GATE_THRESHOLD_HS_0US\t\t(BIT(4) | BIT(5))\n\n#define SET_B_SESSION_VALID\t\t\t(BIT(6) | BIT(5))\n#define CLR_B_SESSION_VALID\t\t\t(BIT(6))\n\nstruct cdns_reg_pairs {\n\tu16 val;\n\tu32 off;\n};\n\nstruct cdns_salvo_data {\n\tu8 reg_offset_shift;\n\tconst struct cdns_reg_pairs *init_sequence_val;\n\tu8 init_sequence_length;\n};\n\nstruct cdns_salvo_phy {\n\tstruct phy *phy;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tstruct cdns_salvo_data *data;\n\tenum usb2_disconn_threshold usb2_disconn;\n};\n\nstatic const struct of_device_id cdns_salvo_phy_of_match[];\nstatic const struct cdns_salvo_data cdns_nxp_salvo_data;\n\nstatic bool cdns_is_nxp_phy(struct cdns_salvo_phy *salvo_phy)\n{\n\treturn salvo_phy->data == &cdns_nxp_salvo_data;\n}\n\nstatic u16 cdns_salvo_read(struct cdns_salvo_phy *salvo_phy, u32 offset, u32 reg)\n{\n\treturn (u16)readl(salvo_phy->base + offset +\n\t\treg * (1 << salvo_phy->data->reg_offset_shift));\n}\n\nstatic void cdns_salvo_write(struct cdns_salvo_phy *salvo_phy, u32 offset,\n\t\t\t     u32 reg, u16 val)\n{\n\twritel(val, salvo_phy->base + offset +\n\t\treg * (1 << salvo_phy->data->reg_offset_shift));\n}\n\n \nstatic const struct cdns_reg_pairs cdns_nxp_sequence_pair[] = {\n\t{0x0830, PHY_PMA_CMN_CTRL1},\n\t{0x0010, TB_ADDR_CMN_DIAG_HSCLK_SEL},\n\t{0x00f0, TB_ADDR_CMN_PLL0_VCOCAL_INIT_TMR},\n\t{0x0018, TB_ADDR_CMN_PLL0_VCOCAL_ITER_TMR},\n\t{0x00d0, TB_ADDR_CMN_PLL0_INTDIV},\n\t{0x4aaa, TB_ADDR_CMN_PLL0_FRACDIV},\n\t{0x0034, TB_ADDR_CMN_PLL0_HIGH_THR},\n\t{0x01ee, TB_ADDR_CMN_PLL0_SS_CTRL1},\n\t{0x7f03, TB_ADDR_CMN_PLL0_SS_CTRL2},\n\t{0x0020, TB_ADDR_CMN_PLL0_DSM_DIAG},\n\t{0x0000, TB_ADDR_CMN_DIAG_PLL0_OVRD},\n\t{0x0000, TB_ADDR_CMN_DIAG_PLL0_FBH_OVRD},\n\t{0x0000, TB_ADDR_CMN_DIAG_PLL0_FBL_OVRD},\n\t{0x0007, TB_ADDR_CMN_DIAG_PLL0_V2I_TUNE},\n\t{0x0027, TB_ADDR_CMN_DIAG_PLL0_CP_TUNE},\n\t{0x0008, TB_ADDR_CMN_DIAG_PLL0_LF_PROG},\n\t{0x0022, TB_ADDR_CMN_DIAG_PLL0_TEST_MODE},\n\t{0x000a, TB_ADDR_CMN_PSM_CLK_CTRL},\n\t{0x0139, TB_ADDR_XCVR_DIAG_RX_LANE_CAL_RST_TMR},\n\t{0xbefc, TB_ADDR_XCVR_PSM_RCTRL},\n\n\t{0x7799, TB_ADDR_TX_PSC_A0},\n\t{0x7798, TB_ADDR_TX_PSC_A1},\n\t{0x509b, TB_ADDR_TX_PSC_A2},\n\t{0x0003, TB_ADDR_TX_DIAG_ECTRL_OVRD},\n\t{0x509b, TB_ADDR_TX_PSC_A3},\n\t{0x2090, TB_ADDR_TX_PSC_CAL},\n\t{0x2090, TB_ADDR_TX_PSC_RDY},\n\n\t{0xA6FD, TB_ADDR_RX_PSC_A0},\n\t{0xA6FD, TB_ADDR_RX_PSC_A1},\n\t{0xA410, TB_ADDR_RX_PSC_A2},\n\t{0x2410, TB_ADDR_RX_PSC_A3},\n\n\t{0x23FF, TB_ADDR_RX_PSC_CAL},\n\t{0x2010, TB_ADDR_RX_PSC_RDY},\n\n\t{0x0020, TB_ADDR_TX_TXCC_MGNLS_MULT_000},\n\t{0x00ff, TB_ADDR_TX_DIAG_BGREF_PREDRV_DELAY},\n\t{0x0002, TB_ADDR_RX_SLC_CU_ITER_TMR},\n\t{0x0013, TB_ADDR_RX_SIGDET_HL_FILT_TMR},\n\t{0x0000, TB_ADDR_RX_SAMP_DAC_CTRL},\n\t{0x1004, TB_ADDR_RX_DIAG_SIGDET_TUNE},\n\t{0x4041, TB_ADDR_RX_DIAG_LFPSDET_TUNE2},\n\t{0x0480, TB_ADDR_RX_DIAG_BS_TM},\n\t{0x8006, TB_ADDR_RX_DIAG_DFE_CTRL1},\n\t{0x003f, TB_ADDR_RX_DIAG_ILL_IQE_TRIM4},\n\t{0x543f, TB_ADDR_RX_DIAG_ILL_E_TRIM0},\n\t{0x543f, TB_ADDR_RX_DIAG_ILL_IQ_TRIM0},\n\t{0x0000, TB_ADDR_RX_DIAG_ILL_IQE_TRIM6},\n\t{0x8000, TB_ADDR_RX_DIAG_RXFE_TM3},\n\t{0x0003, TB_ADDR_RX_DIAG_RXFE_TM4},\n\t{0x2408, TB_ADDR_RX_DIAG_LFPSDET_TUNE},\n\t{0x05ca, TB_ADDR_RX_DIAG_DFE_CTRL3},\n\t{0x0258, TB_ADDR_RX_DIAG_SC2C_DELAY},\n\t{0x1fff, TB_ADDR_RX_REE_VGA_GAIN_NODFE},\n\n\t{0x02c6, TB_ADDR_XCVR_PSM_CAL_TMR},\n\t{0x0002, TB_ADDR_XCVR_PSM_A0BYP_TMR},\n\t{0x02c6, TB_ADDR_XCVR_PSM_A0IN_TMR},\n\t{0x0010, TB_ADDR_XCVR_PSM_A1IN_TMR},\n\t{0x0010, TB_ADDR_XCVR_PSM_A2IN_TMR},\n\t{0x0010, TB_ADDR_XCVR_PSM_A3IN_TMR},\n\t{0x0010, TB_ADDR_XCVR_PSM_A4IN_TMR},\n\t{0x0010, TB_ADDR_XCVR_PSM_A5IN_TMR},\n\n\t{0x0002, TB_ADDR_XCVR_PSM_A0OUT_TMR},\n\t{0x0002, TB_ADDR_XCVR_PSM_A1OUT_TMR},\n\t{0x0002, TB_ADDR_XCVR_PSM_A2OUT_TMR},\n\t{0x0002, TB_ADDR_XCVR_PSM_A3OUT_TMR},\n\t{0x0002, TB_ADDR_XCVR_PSM_A4OUT_TMR},\n\t{0x0002, TB_ADDR_XCVR_PSM_A5OUT_TMR},\n\t \n\t{0x0960, TB_ADDR_TX_RCVDET_EN_TMR},\n\t{0x01e0, TB_ADDR_TX_RCVDET_ST_TMR},\n\t{0x0090, TB_ADDR_XCVR_DIAG_LANE_FCM_EN_MGN_TMR},\n};\n\nstatic int cdns_salvo_phy_init(struct phy *phy)\n{\n\tstruct cdns_salvo_phy *salvo_phy = phy_get_drvdata(phy);\n\tstruct cdns_salvo_data *data = salvo_phy->data;\n\tint ret, i;\n\tu16 value;\n\n\tret = clk_prepare_enable(salvo_phy->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < data->init_sequence_length; i++) {\n\t\tconst struct cdns_reg_pairs *reg_pair = data->init_sequence_val + i;\n\n\t\tcdns_salvo_write(salvo_phy, USB3_PHY_OFFSET, reg_pair->off, reg_pair->val);\n\t}\n\n\t \n\tvalue = cdns_salvo_read(salvo_phy, USB3_PHY_OFFSET, TB_ADDR_TX_RCVDETSC_CTRL);\n\tvalue |= RXDET_IN_P3_32KHZ;\n\tcdns_salvo_write(salvo_phy, USB3_PHY_OFFSET, TB_ADDR_TX_RCVDETSC_CTRL,\n\t\t\t RXDET_IN_P3_32KHZ);\n\n\tvalue = cdns_salvo_read(salvo_phy, USB2_PHY_OFFSET, UTMI_REG15);\n\tvalue &= ~TXVALID_GATE_THRESHOLD_HS_MASK;\n\tcdns_salvo_write(salvo_phy, USB2_PHY_OFFSET, UTMI_REG15,\n\t\t\t value | TXVALID_GATE_THRESHOLD_HS_0US);\n\n\tcdns_salvo_write(salvo_phy, USB2_PHY_OFFSET, UTMI_AFE_RX_REG5, 0x5);\n\n\tvalue = cdns_salvo_read(salvo_phy, USB2_PHY_OFFSET, UTMI_AFE_RX_REG0);\n\tvalue &= ~RX_USB2_DISCONN_MASK;\n\tvalue = FIELD_PREP(RX_USB2_DISCONN_MASK, salvo_phy->usb2_disconn);\n\tcdns_salvo_write(salvo_phy, USB2_PHY_OFFSET, UTMI_AFE_RX_REG0, value);\n\n\tudelay(10);\n\n\tclk_disable_unprepare(salvo_phy->clk);\n\n\treturn ret;\n}\n\nstatic int cdns_salvo_phy_power_on(struct phy *phy)\n{\n\tstruct cdns_salvo_phy *salvo_phy = phy_get_drvdata(phy);\n\n\treturn clk_prepare_enable(salvo_phy->clk);\n}\n\nstatic int cdns_salvo_phy_power_off(struct phy *phy)\n{\n\tstruct cdns_salvo_phy *salvo_phy = phy_get_drvdata(phy);\n\n\tclk_disable_unprepare(salvo_phy->clk);\n\n\treturn 0;\n}\n\nstatic int cdns_salvo_set_mode(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tstruct cdns_salvo_phy *salvo_phy = phy_get_drvdata(phy);\n\n\tif (!cdns_is_nxp_phy(salvo_phy))\n\t\treturn 0;\n\n\tif (mode == PHY_MODE_USB_DEVICE)\n\t\tcdns_salvo_write(salvo_phy, USB2_PHY_OFFSET, UTMI_AFE_BC_REG4,\n\t\t\t SET_B_SESSION_VALID);\n\telse\n\t\tcdns_salvo_write(salvo_phy, USB2_PHY_OFFSET, UTMI_AFE_BC_REG4,\n\t\t\t CLR_B_SESSION_VALID);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops cdns_salvo_phy_ops = {\n\t.init\t\t= cdns_salvo_phy_init,\n\t.power_on\t= cdns_salvo_phy_power_on,\n\t.power_off\t= cdns_salvo_phy_power_off,\n\t.owner\t\t= THIS_MODULE,\n\t.set_mode\t= cdns_salvo_set_mode,\n};\n\nstatic int cdns_salvo_phy_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *phy_provider;\n\tstruct device *dev = &pdev->dev;\n\tstruct cdns_salvo_phy *salvo_phy;\n\tstruct cdns_salvo_data *data;\n\tu32 val;\n\n\tdata = (struct cdns_salvo_data *)of_device_get_match_data(dev);\n\tsalvo_phy = devm_kzalloc(dev, sizeof(*salvo_phy), GFP_KERNEL);\n\tif (!salvo_phy)\n\t\treturn -ENOMEM;\n\n\tsalvo_phy->data = data;\n\tsalvo_phy->clk = devm_clk_get_optional(dev, \"salvo_phy_clk\");\n\tif (IS_ERR(salvo_phy->clk))\n\t\treturn PTR_ERR(salvo_phy->clk);\n\n\tif (of_property_read_u32(dev->of_node, \"cdns,usb2-disconnect-threshold-microvolt\", &val))\n\t\tval = 575;\n\n\tif (val < 610)\n\t\tsalvo_phy->usb2_disconn = USB2_DISCONN_THRESHOLD_575;\n\telse if (val < 645)\n\t\tsalvo_phy->usb2_disconn = USB2_DISCONN_THRESHOLD_610;\n\telse\n\t\tsalvo_phy->usb2_disconn = USB2_DISCONN_THRESHOLD_645;\n\n\tsalvo_phy->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(salvo_phy->base))\n\t\treturn PTR_ERR(salvo_phy->base);\n\n\tsalvo_phy->phy = devm_phy_create(dev, NULL, &cdns_salvo_phy_ops);\n\tif (IS_ERR(salvo_phy->phy))\n\t\treturn PTR_ERR(salvo_phy->phy);\n\n\tphy_set_drvdata(salvo_phy->phy, salvo_phy);\n\n\tphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(phy_provider);\n}\n\nstatic const struct cdns_salvo_data cdns_nxp_salvo_data = {\n\t2,\n\tcdns_nxp_sequence_pair,\n\tARRAY_SIZE(cdns_nxp_sequence_pair),\n};\n\nstatic const struct of_device_id cdns_salvo_phy_of_match[] = {\n\t{\n\t\t.compatible = \"nxp,salvo-phy\",\n\t\t.data = &cdns_nxp_salvo_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cdns_salvo_phy_of_match);\n\nstatic struct platform_driver cdns_salvo_phy_driver = {\n\t.probe\t= cdns_salvo_phy_probe,\n\t.driver = {\n\t\t.name\t= \"cdns-salvo-phy\",\n\t\t.of_match_table\t= cdns_salvo_phy_of_match,\n\t}\n};\nmodule_platform_driver(cdns_salvo_phy_driver);\n\nMODULE_AUTHOR(\"Peter Chen <peter.chen@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Cadence SALVO PHY Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}