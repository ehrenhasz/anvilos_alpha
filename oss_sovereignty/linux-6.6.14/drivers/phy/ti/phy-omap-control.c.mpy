{
  "module_name": "phy-omap-control.c",
  "hash_id": "da340138339da732d9522074206ca0d9290d6f666acc7f9ef7459a81c2333516",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ti/phy-omap-control.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/phy/omap_control_phy.h>\n\n \nvoid omap_control_pcie_pcs(struct device *dev, u8 delay)\n{\n\tu32 val;\n\tstruct omap_control_phy\t*control_phy;\n\n\tif (IS_ERR_OR_NULL(dev)) {\n\t\tpr_err(\"%s: invalid device\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcontrol_phy = dev_get_drvdata(dev);\n\tif (!control_phy) {\n\t\tdev_err(dev, \"%s: invalid control phy device\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (control_phy->type != OMAP_CTRL_TYPE_PCIE) {\n\t\tdev_err(dev, \"%s: unsupported operation\\n\", __func__);\n\t\treturn;\n\t}\n\n\tval = readl(control_phy->pcie_pcs);\n\tval &= ~(OMAP_CTRL_PCIE_PCS_MASK <<\n\t\tOMAP_CTRL_PCIE_PCS_DELAY_COUNT_SHIFT);\n\tval |= (delay << OMAP_CTRL_PCIE_PCS_DELAY_COUNT_SHIFT);\n\twritel(val, control_phy->pcie_pcs);\n}\nEXPORT_SYMBOL_GPL(omap_control_pcie_pcs);\n\n \nvoid omap_control_phy_power(struct device *dev, int on)\n{\n\tu32 val;\n\tunsigned long rate;\n\tstruct omap_control_phy\t*control_phy;\n\n\tif (IS_ERR_OR_NULL(dev)) {\n\t\tpr_err(\"%s: invalid device\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcontrol_phy = dev_get_drvdata(dev);\n\tif (!control_phy) {\n\t\tdev_err(dev, \"%s: invalid control phy device\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (control_phy->type == OMAP_CTRL_TYPE_OTGHS)\n\t\treturn;\n\n\tval = readl(control_phy->power);\n\n\tswitch (control_phy->type) {\n\tcase OMAP_CTRL_TYPE_USB2:\n\t\tif (on)\n\t\t\tval &= ~OMAP_CTRL_DEV_PHY_PD;\n\t\telse\n\t\t\tval |= OMAP_CTRL_DEV_PHY_PD;\n\t\tbreak;\n\n\tcase OMAP_CTRL_TYPE_PCIE:\n\tcase OMAP_CTRL_TYPE_PIPE3:\n\t\trate = clk_get_rate(control_phy->sys_clk);\n\t\trate = rate/1000000;\n\n\t\tif (on) {\n\t\t\tval &= ~(OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_MASK |\n\t\t\t\tOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_FREQ_MASK);\n\t\t\tval |= OMAP_CTRL_PIPE3_PHY_TX_RX_POWERON <<\n\t\t\t\tOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT;\n\t\t\tval |= rate <<\n\t\t\t\tOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_FREQ_SHIFT;\n\t\t} else {\n\t\t\tval &= ~OMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_MASK;\n\t\t\tval |= OMAP_CTRL_PIPE3_PHY_TX_RX_POWEROFF <<\n\t\t\t\tOMAP_CTRL_PIPE3_PHY_PWRCTL_CLK_CMD_SHIFT;\n\t\t}\n\t\tbreak;\n\n\tcase OMAP_CTRL_TYPE_DRA7USB2:\n\t\tif (on)\n\t\t\tval &= ~OMAP_CTRL_USB2_PHY_PD;\n\t\telse\n\t\t\tval |= OMAP_CTRL_USB2_PHY_PD;\n\t\tbreak;\n\n\tcase OMAP_CTRL_TYPE_AM437USB2:\n\t\tif (on) {\n\t\t\tval &= ~(AM437X_CTRL_USB2_PHY_PD |\n\t\t\t\t\tAM437X_CTRL_USB2_OTG_PD);\n\t\t\tval |= (AM437X_CTRL_USB2_OTGVDET_EN |\n\t\t\t\t\tAM437X_CTRL_USB2_OTGSESSEND_EN);\n\t\t} else {\n\t\t\tval &= ~(AM437X_CTRL_USB2_OTGVDET_EN |\n\t\t\t\t\tAM437X_CTRL_USB2_OTGSESSEND_EN);\n\t\t\tval |= (AM437X_CTRL_USB2_PHY_PD |\n\t\t\t\t\t AM437X_CTRL_USB2_OTG_PD);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s: type %d not recognized\\n\",\n\t\t\t__func__, control_phy->type);\n\t\tbreak;\n\t}\n\n\twritel(val, control_phy->power);\n}\nEXPORT_SYMBOL_GPL(omap_control_phy_power);\n\n \nstatic void omap_control_usb_host_mode(struct omap_control_phy *ctrl_phy)\n{\n\tu32 val;\n\n\tval = readl(ctrl_phy->otghs_control);\n\tval &= ~(OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_SESSEND);\n\tval |= OMAP_CTRL_DEV_AVALID | OMAP_CTRL_DEV_VBUSVALID;\n\twritel(val, ctrl_phy->otghs_control);\n}\n\n \nstatic void omap_control_usb_device_mode(struct omap_control_phy *ctrl_phy)\n{\n\tu32 val;\n\n\tval = readl(ctrl_phy->otghs_control);\n\tval &= ~OMAP_CTRL_DEV_SESSEND;\n\tval |= OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_AVALID |\n\t\tOMAP_CTRL_DEV_VBUSVALID;\n\twritel(val, ctrl_phy->otghs_control);\n}\n\n \nstatic void omap_control_usb_set_sessionend(struct omap_control_phy *ctrl_phy)\n{\n\tu32 val;\n\n\tval = readl(ctrl_phy->otghs_control);\n\tval &= ~(OMAP_CTRL_DEV_AVALID | OMAP_CTRL_DEV_VBUSVALID);\n\tval |= OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_SESSEND;\n\twritel(val, ctrl_phy->otghs_control);\n}\n\n \nvoid omap_control_usb_set_mode(struct device *dev,\n\tenum omap_control_usb_mode mode)\n{\n\tstruct omap_control_phy\t*ctrl_phy;\n\n\tif (IS_ERR_OR_NULL(dev))\n\t\treturn;\n\n\tctrl_phy = dev_get_drvdata(dev);\n\tif (!ctrl_phy) {\n\t\tdev_err(dev, \"Invalid control phy device\\n\");\n\t\treturn;\n\t}\n\n\tif (ctrl_phy->type != OMAP_CTRL_TYPE_OTGHS)\n\t\treturn;\n\n\tswitch (mode) {\n\tcase USB_MODE_HOST:\n\t\tomap_control_usb_host_mode(ctrl_phy);\n\t\tbreak;\n\tcase USB_MODE_DEVICE:\n\t\tomap_control_usb_device_mode(ctrl_phy);\n\t\tbreak;\n\tcase USB_MODE_DISCONNECT:\n\t\tomap_control_usb_set_sessionend(ctrl_phy);\n\t\tbreak;\n\tdefault:\n\t\tdev_vdbg(dev, \"invalid omap control usb mode\\n\");\n\t}\n}\nEXPORT_SYMBOL_GPL(omap_control_usb_set_mode);\n\nstatic const enum omap_control_phy_type otghs_data = OMAP_CTRL_TYPE_OTGHS;\nstatic const enum omap_control_phy_type usb2_data = OMAP_CTRL_TYPE_USB2;\nstatic const enum omap_control_phy_type pipe3_data = OMAP_CTRL_TYPE_PIPE3;\nstatic const enum omap_control_phy_type pcie_data = OMAP_CTRL_TYPE_PCIE;\nstatic const enum omap_control_phy_type dra7usb2_data = OMAP_CTRL_TYPE_DRA7USB2;\nstatic const enum omap_control_phy_type am437usb2_data = OMAP_CTRL_TYPE_AM437USB2;\n\nstatic const struct of_device_id omap_control_phy_id_table[] = {\n\t{\n\t\t.compatible = \"ti,control-phy-otghs\",\n\t\t.data = &otghs_data,\n\t},\n\t{\n\t\t.compatible = \"ti,control-phy-usb2\",\n\t\t.data = &usb2_data,\n\t},\n\t{\n\t\t.compatible = \"ti,control-phy-pipe3\",\n\t\t.data = &pipe3_data,\n\t},\n\t{\n\t\t.compatible = \"ti,control-phy-pcie\",\n\t\t.data = &pcie_data,\n\t},\n\t{\n\t\t.compatible = \"ti,control-phy-usb2-dra7\",\n\t\t.data = &dra7usb2_data,\n\t},\n\t{\n\t\t.compatible = \"ti,control-phy-usb2-am437\",\n\t\t.data = &am437usb2_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_control_phy_id_table);\n\nstatic int omap_control_phy_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id;\n\tstruct omap_control_phy *control_phy;\n\n\tof_id = of_match_device(omap_control_phy_id_table, &pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tcontrol_phy = devm_kzalloc(&pdev->dev, sizeof(*control_phy),\n\t\tGFP_KERNEL);\n\tif (!control_phy)\n\t\treturn -ENOMEM;\n\n\tcontrol_phy->dev = &pdev->dev;\n\tcontrol_phy->type = *(enum omap_control_phy_type *)of_id->data;\n\n\tif (control_phy->type == OMAP_CTRL_TYPE_OTGHS) {\n\t\tcontrol_phy->otghs_control =\n\t\t\tdevm_platform_ioremap_resource_byname(pdev, \"otghs_control\");\n\t\tif (IS_ERR(control_phy->otghs_control))\n\t\t\treturn PTR_ERR(control_phy->otghs_control);\n\t} else {\n\t\tcontrol_phy->power =\n\t\t\tdevm_platform_ioremap_resource_byname(pdev, \"power\");\n\t\tif (IS_ERR(control_phy->power)) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't get power register\\n\");\n\t\t\treturn PTR_ERR(control_phy->power);\n\t\t}\n\t}\n\n\tif (control_phy->type == OMAP_CTRL_TYPE_PIPE3 ||\n\t    control_phy->type == OMAP_CTRL_TYPE_PCIE) {\n\t\tcontrol_phy->sys_clk = devm_clk_get(control_phy->dev,\n\t\t\t\"sys_clkin\");\n\t\tif (IS_ERR(control_phy->sys_clk)) {\n\t\t\tpr_err(\"%s: unable to get sys_clkin\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (control_phy->type == OMAP_CTRL_TYPE_PCIE) {\n\t\tcontrol_phy->pcie_pcs =\n\t\t\tdevm_platform_ioremap_resource_byname(pdev, \"pcie_pcs\");\n\t\tif (IS_ERR(control_phy->pcie_pcs))\n\t\t\treturn PTR_ERR(control_phy->pcie_pcs);\n\t}\n\n\tdev_set_drvdata(control_phy->dev, control_phy);\n\n\treturn 0;\n}\n\nstatic struct platform_driver omap_control_phy_driver = {\n\t.probe\t\t= omap_control_phy_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"omap-control-phy\",\n\t\t.of_match_table = omap_control_phy_id_table,\n\t},\n};\n\nstatic int __init omap_control_phy_init(void)\n{\n\treturn platform_driver_register(&omap_control_phy_driver);\n}\nsubsys_initcall(omap_control_phy_init);\n\nstatic void __exit omap_control_phy_exit(void)\n{\n\tplatform_driver_unregister(&omap_control_phy_driver);\n}\nmodule_exit(omap_control_phy_exit);\n\nMODULE_ALIAS(\"platform:omap_control_phy\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_DESCRIPTION(\"OMAP Control Module PHY Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}