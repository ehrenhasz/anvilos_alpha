{
  "module_name": "phy-gmii-sel.c",
  "hash_id": "64c45dbea4ae00fe1e254dee957ddf46f5d0389df1bade85a2fb267b35b25157",
  "original_prompt": "Ingested from linux-6.6.14/drivers/phy/ti/phy-gmii-sel.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n\n \n#define AM33XX_GMII_SEL_MODE_MII\t0\n#define AM33XX_GMII_SEL_MODE_RMII\t1\n#define AM33XX_GMII_SEL_MODE_RGMII\t2\n\n \n#define J72XX_GMII_SEL_MODE_SGMII\t3\n#define J72XX_GMII_SEL_MODE_QSGMII\t4\n#define J72XX_GMII_SEL_MODE_USXGMII\t5\n#define J72XX_GMII_SEL_MODE_QSGMII_SUB\t6\n\n#define PHY_GMII_PORT(n)\tBIT((n) - 1)\n\nenum {\n\tPHY_GMII_SEL_PORT_MODE = 0,\n\tPHY_GMII_SEL_RGMII_ID_MODE,\n\tPHY_GMII_SEL_RMII_IO_CLK_EN,\n\tPHY_GMII_SEL_LAST,\n};\n\nstruct phy_gmii_sel_phy_priv {\n\tstruct phy_gmii_sel_priv *priv;\n\tu32\t\tid;\n\tstruct phy\t*if_phy;\n\tint\t\trmii_clock_external;\n\tint\t\tphy_if_mode;\n\tstruct regmap_field *fields[PHY_GMII_SEL_LAST];\n};\n\nstruct phy_gmii_sel_soc_data {\n\tu32 num_ports;\n\tu32 features;\n\tconst struct reg_field (*regfields)[PHY_GMII_SEL_LAST];\n\tbool use_of_data;\n\tu64 extra_modes;\n\tu32 num_qsgmii_main_ports;\n};\n\nstruct phy_gmii_sel_priv {\n\tstruct device *dev;\n\tconst struct phy_gmii_sel_soc_data *soc_data;\n\tstruct regmap *regmap;\n\tstruct phy_provider *phy_provider;\n\tstruct phy_gmii_sel_phy_priv *if_phys;\n\tu32 num_ports;\n\tu32 reg_offset;\n\tu32 qsgmii_main_ports;\n\tbool no_offset;\n};\n\nstatic int phy_gmii_sel_mode(struct phy *phy, enum phy_mode mode, int submode)\n{\n\tstruct phy_gmii_sel_phy_priv *if_phy = phy_get_drvdata(phy);\n\tconst struct phy_gmii_sel_soc_data *soc_data = if_phy->priv->soc_data;\n\tstruct device *dev = if_phy->priv->dev;\n\tstruct regmap_field *regfield;\n\tint ret, rgmii_id = 0;\n\tu32 gmii_sel_mode = 0;\n\n\tif (mode != PHY_MODE_ETHERNET)\n\t\treturn -EINVAL;\n\n\tswitch (submode) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tgmii_sel_mode = AM33XX_GMII_SEL_MODE_RMII;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tgmii_sel_mode = AM33XX_GMII_SEL_MODE_RGMII;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tgmii_sel_mode = AM33XX_GMII_SEL_MODE_RGMII;\n\t\trgmii_id = 1;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\tgmii_sel_mode = AM33XX_GMII_SEL_MODE_MII;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\tif (!(soc_data->extra_modes & BIT(PHY_INTERFACE_MODE_QSGMII)))\n\t\t\tgoto unsupported;\n\t\tif (if_phy->priv->qsgmii_main_ports & BIT(if_phy->id - 1))\n\t\t\tgmii_sel_mode = J72XX_GMII_SEL_MODE_QSGMII;\n\t\telse\n\t\t\tgmii_sel_mode = J72XX_GMII_SEL_MODE_QSGMII_SUB;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tif (!(soc_data->extra_modes & BIT(PHY_INTERFACE_MODE_SGMII)))\n\t\t\tgoto unsupported;\n\t\telse\n\t\t\tgmii_sel_mode = J72XX_GMII_SEL_MODE_SGMII;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\tif (!(soc_data->extra_modes & BIT(PHY_INTERFACE_MODE_USXGMII)))\n\t\t\tgoto unsupported;\n\t\telse\n\t\t\tgmii_sel_mode = J72XX_GMII_SEL_MODE_USXGMII;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto unsupported;\n\t}\n\n\tif_phy->phy_if_mode = submode;\n\n\tdev_dbg(dev, \"%s id:%u mode:%u rgmii_id:%d rmii_clk_ext:%d\\n\",\n\t\t__func__, if_phy->id, submode, rgmii_id,\n\t\tif_phy->rmii_clock_external);\n\n\tregfield = if_phy->fields[PHY_GMII_SEL_PORT_MODE];\n\tret = regmap_field_write(regfield, gmii_sel_mode);\n\tif (ret) {\n\t\tdev_err(dev, \"port%u: set mode fail %d\", if_phy->id, ret);\n\t\treturn ret;\n\t}\n\n\tif (soc_data->features & BIT(PHY_GMII_SEL_RGMII_ID_MODE) &&\n\t    if_phy->fields[PHY_GMII_SEL_RGMII_ID_MODE]) {\n\t\tregfield = if_phy->fields[PHY_GMII_SEL_RGMII_ID_MODE];\n\t\tret = regmap_field_write(regfield, rgmii_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (soc_data->features & BIT(PHY_GMII_SEL_RMII_IO_CLK_EN) &&\n\t    if_phy->fields[PHY_GMII_SEL_RMII_IO_CLK_EN]) {\n\t\tregfield = if_phy->fields[PHY_GMII_SEL_RMII_IO_CLK_EN];\n\t\tret = regmap_field_write(regfield,\n\t\t\t\t\t if_phy->rmii_clock_external);\n\t}\n\n\treturn 0;\n\nunsupported:\n\tdev_warn(dev, \"port%u: unsupported mode: \\\"%s\\\"\\n\",\n\t\t if_phy->id, phy_modes(submode));\n\treturn -EINVAL;\n}\n\nstatic const\nstruct reg_field phy_gmii_sel_fields_am33xx[][PHY_GMII_SEL_LAST] = {\n\t{\n\t\t[PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x650, 0, 1),\n\t\t[PHY_GMII_SEL_RGMII_ID_MODE] = REG_FIELD(0x650, 4, 4),\n\t\t[PHY_GMII_SEL_RMII_IO_CLK_EN] = REG_FIELD(0x650, 6, 6),\n\t},\n\t{\n\t\t[PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x650, 2, 3),\n\t\t[PHY_GMII_SEL_RGMII_ID_MODE] = REG_FIELD(0x650, 5, 5),\n\t\t[PHY_GMII_SEL_RMII_IO_CLK_EN] = REG_FIELD(0x650, 7, 7),\n\t},\n};\n\nstatic const\nstruct phy_gmii_sel_soc_data phy_gmii_sel_soc_am33xx = {\n\t.num_ports = 2,\n\t.features = BIT(PHY_GMII_SEL_RGMII_ID_MODE) |\n\t\t    BIT(PHY_GMII_SEL_RMII_IO_CLK_EN),\n\t.regfields = phy_gmii_sel_fields_am33xx,\n};\n\nstatic const\nstruct reg_field phy_gmii_sel_fields_dra7[][PHY_GMII_SEL_LAST] = {\n\t{\n\t\t[PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x554, 0, 1),\n\t},\n\t{\n\t\t[PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x554, 4, 5),\n\t},\n};\n\nstatic const\nstruct phy_gmii_sel_soc_data phy_gmii_sel_soc_dra7 = {\n\t.num_ports = 2,\n\t.regfields = phy_gmii_sel_fields_dra7,\n};\n\nstatic const\nstruct phy_gmii_sel_soc_data phy_gmii_sel_soc_dm814 = {\n\t.num_ports = 2,\n\t.features = BIT(PHY_GMII_SEL_RGMII_ID_MODE),\n\t.regfields = phy_gmii_sel_fields_am33xx,\n};\n\nstatic const\nstruct reg_field phy_gmii_sel_fields_am654[][PHY_GMII_SEL_LAST] = {\n\t{ [PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x0, 0, 2), },\n\t{ [PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x4, 0, 2), },\n\t{ [PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x8, 0, 2), },\n\t{ [PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0xC, 0, 2), },\n\t{ [PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x10, 0, 2), },\n\t{ [PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x14, 0, 2), },\n\t{ [PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x18, 0, 2), },\n\t{ [PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x1C, 0, 2), },\n};\n\nstatic const\nstruct phy_gmii_sel_soc_data phy_gmii_sel_soc_am654 = {\n\t.use_of_data = true,\n\t.regfields = phy_gmii_sel_fields_am654,\n};\n\nstatic const\nstruct phy_gmii_sel_soc_data phy_gmii_sel_cpsw5g_soc_j7200 = {\n\t.use_of_data = true,\n\t.regfields = phy_gmii_sel_fields_am654,\n\t.extra_modes = BIT(PHY_INTERFACE_MODE_QSGMII) | BIT(PHY_INTERFACE_MODE_SGMII),\n\t.num_ports = 4,\n\t.num_qsgmii_main_ports = 1,\n};\n\nstatic const\nstruct phy_gmii_sel_soc_data phy_gmii_sel_cpsw9g_soc_j721e = {\n\t.use_of_data = true,\n\t.regfields = phy_gmii_sel_fields_am654,\n\t.extra_modes = BIT(PHY_INTERFACE_MODE_QSGMII) | BIT(PHY_INTERFACE_MODE_SGMII),\n\t.num_ports = 8,\n\t.num_qsgmii_main_ports = 2,\n};\n\nstatic const\nstruct phy_gmii_sel_soc_data phy_gmii_sel_cpsw9g_soc_j784s4 = {\n\t.use_of_data = true,\n\t.regfields = phy_gmii_sel_fields_am654,\n\t.extra_modes = BIT(PHY_INTERFACE_MODE_QSGMII) |\n\t\t       BIT(PHY_INTERFACE_MODE_USXGMII),\n\t.num_ports = 8,\n\t.num_qsgmii_main_ports = 2,\n};\n\nstatic const struct of_device_id phy_gmii_sel_id_table[] = {\n\t{\n\t\t.compatible\t= \"ti,am3352-phy-gmii-sel\",\n\t\t.data\t\t= &phy_gmii_sel_soc_am33xx,\n\t},\n\t{\n\t\t.compatible\t= \"ti,dra7xx-phy-gmii-sel\",\n\t\t.data\t\t= &phy_gmii_sel_soc_dra7,\n\t},\n\t{\n\t\t.compatible\t= \"ti,am43xx-phy-gmii-sel\",\n\t\t.data\t\t= &phy_gmii_sel_soc_am33xx,\n\t},\n\t{\n\t\t.compatible\t= \"ti,dm814-phy-gmii-sel\",\n\t\t.data\t\t= &phy_gmii_sel_soc_dm814,\n\t},\n\t{\n\t\t.compatible\t= \"ti,am654-phy-gmii-sel\",\n\t\t.data\t\t= &phy_gmii_sel_soc_am654,\n\t},\n\t{\n\t\t.compatible\t= \"ti,j7200-cpsw5g-phy-gmii-sel\",\n\t\t.data\t\t= &phy_gmii_sel_cpsw5g_soc_j7200,\n\t},\n\t{\n\t\t.compatible\t= \"ti,j721e-cpsw9g-phy-gmii-sel\",\n\t\t.data\t\t= &phy_gmii_sel_cpsw9g_soc_j721e,\n\t},\n\t{\n\t\t.compatible\t= \"ti,j784s4-cpsw9g-phy-gmii-sel\",\n\t\t.data\t\t= &phy_gmii_sel_cpsw9g_soc_j784s4,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, phy_gmii_sel_id_table);\n\nstatic const struct phy_ops phy_gmii_sel_ops = {\n\t.set_mode\t= phy_gmii_sel_mode,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct phy *phy_gmii_sel_of_xlate(struct device *dev,\n\t\t\t\t\t struct of_phandle_args *args)\n{\n\tstruct phy_gmii_sel_priv *priv = dev_get_drvdata(dev);\n\tint phy_id = args->args[0];\n\n\tif (args->args_count < 1)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!priv || !priv->if_phys)\n\t\treturn ERR_PTR(-ENODEV);\n\tif (priv->soc_data->features & BIT(PHY_GMII_SEL_RMII_IO_CLK_EN) &&\n\t    args->args_count < 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (phy_id > priv->num_ports)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (phy_id != priv->if_phys[phy_id - 1].id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tphy_id--;\n\tif (priv->soc_data->features & BIT(PHY_GMII_SEL_RMII_IO_CLK_EN))\n\t\tpriv->if_phys[phy_id].rmii_clock_external = args->args[1];\n\tdev_dbg(dev, \"%s id:%u ext:%d\\n\", __func__,\n\t\tpriv->if_phys[phy_id].id, args->args[1]);\n\n\treturn priv->if_phys[phy_id].if_phy;\n}\n\nstatic int phy_gmii_init_phy(struct phy_gmii_sel_priv *priv, int port,\n\t\t\t     struct phy_gmii_sel_phy_priv *if_phy)\n{\n\tconst struct phy_gmii_sel_soc_data *soc_data = priv->soc_data;\n\tstruct device *dev = priv->dev;\n\tconst struct reg_field *fields;\n\tstruct regmap_field *regfield;\n\tstruct reg_field field;\n\tint ret;\n\n\tif_phy->id = port;\n\tif_phy->priv = priv;\n\n\tfields = soc_data->regfields[port - 1];\n\tfield = *fields++;\n\tfield.reg += priv->reg_offset;\n\tdev_dbg(dev, \"%s field %x %d %d\\n\", __func__,\n\t\tfield.reg, field.msb, field.lsb);\n\n\tregfield = devm_regmap_field_alloc(dev, priv->regmap, field);\n\tif (IS_ERR(regfield))\n\t\treturn PTR_ERR(regfield);\n\tif_phy->fields[PHY_GMII_SEL_PORT_MODE] = regfield;\n\n\tfield = *fields++;\n\tfield.reg += priv->reg_offset;\n\tif (soc_data->features & BIT(PHY_GMII_SEL_RGMII_ID_MODE)) {\n\t\tregfield = devm_regmap_field_alloc(dev,\n\t\t\t\t\t\t   priv->regmap,\n\t\t\t\t\t\t   field);\n\t\tif (IS_ERR(regfield))\n\t\t\treturn PTR_ERR(regfield);\n\t\tif_phy->fields[PHY_GMII_SEL_RGMII_ID_MODE] = regfield;\n\t\tdev_dbg(dev, \"%s field %x %d %d\\n\", __func__,\n\t\t\tfield.reg, field.msb, field.lsb);\n\t}\n\n\tfield = *fields;\n\tfield.reg += priv->reg_offset;\n\tif (soc_data->features & BIT(PHY_GMII_SEL_RMII_IO_CLK_EN)) {\n\t\tregfield = devm_regmap_field_alloc(dev,\n\t\t\t\t\t\t   priv->regmap,\n\t\t\t\t\t\t   field);\n\t\tif (IS_ERR(regfield))\n\t\t\treturn PTR_ERR(regfield);\n\t\tif_phy->fields[PHY_GMII_SEL_RMII_IO_CLK_EN] = regfield;\n\t\tdev_dbg(dev, \"%s field %x %d %d\\n\", __func__,\n\t\t\tfield.reg, field.msb, field.lsb);\n\t}\n\n\tif_phy->if_phy = devm_phy_create(dev,\n\t\t\t\t\t priv->dev->of_node,\n\t\t\t\t\t &phy_gmii_sel_ops);\n\tif (IS_ERR(if_phy->if_phy)) {\n\t\tret = PTR_ERR(if_phy->if_phy);\n\t\tdev_err(dev, \"Failed to create phy%d %d\\n\", port, ret);\n\t\treturn ret;\n\t}\n\tphy_set_drvdata(if_phy->if_phy, if_phy);\n\n\treturn 0;\n}\n\nstatic int phy_gmii_sel_init_ports(struct phy_gmii_sel_priv *priv)\n{\n\tconst struct phy_gmii_sel_soc_data *soc_data = priv->soc_data;\n\tstruct phy_gmii_sel_phy_priv *if_phys;\n\tstruct device *dev = priv->dev;\n\tint i, ret;\n\n\tif (soc_data->use_of_data) {\n\t\tconst __be32 *offset;\n\t\tu64 size;\n\n\t\toffset = of_get_address(dev->of_node, 0, &size, NULL);\n\t\tif (!offset)\n\t\t\treturn -EINVAL;\n\t\tpriv->num_ports = size / sizeof(u32);\n\t\tif (!priv->num_ports)\n\t\t\treturn -EINVAL;\n\t\tif (!priv->no_offset)\n\t\t\tpriv->reg_offset = __be32_to_cpu(*offset);\n\t}\n\n\tif_phys = devm_kcalloc(dev, priv->num_ports,\n\t\t\t       sizeof(*if_phys), GFP_KERNEL);\n\tif (!if_phys)\n\t\treturn -ENOMEM;\n\tdev_dbg(dev, \"%s %d\\n\", __func__, priv->num_ports);\n\n\tfor (i = 0; i < priv->num_ports; i++) {\n\t\tret = phy_gmii_init_phy(priv, i + 1, &if_phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpriv->if_phys = if_phys;\n\treturn 0;\n}\n\nstatic int phy_gmii_sel_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct phy_gmii_sel_soc_data *soc_data;\n\tstruct device_node *node = dev->of_node;\n\tconst struct of_device_id *of_id;\n\tstruct phy_gmii_sel_priv *priv;\n\tu32 main_ports = 1;\n\tint ret;\n\tu32 i;\n\n\tof_id = of_match_node(phy_gmii_sel_id_table, pdev->dev.of_node);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tpriv->soc_data = of_id->data;\n\tsoc_data = priv->soc_data;\n\tpriv->num_ports = priv->soc_data->num_ports;\n\tpriv->qsgmii_main_ports = 0;\n\n\t \n\tfor (i = 0; i < soc_data->num_qsgmii_main_ports; i++) {\n\t\tof_property_read_u32_index(node, \"ti,qsgmii-main-ports\", i, &main_ports);\n\t\t \n\t\tif (main_ports < 1 || main_ports > soc_data->num_ports) {\n\t\t\tdev_err(dev, \"Invalid qsgmii main port provided\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->qsgmii_main_ports |= PHY_GMII_PORT(main_ports);\n\t}\n\n\tpriv->regmap = syscon_node_to_regmap(node->parent);\n\tif (IS_ERR(priv->regmap)) {\n\t\tpriv->regmap = device_node_to_regmap(node);\n\t\tif (IS_ERR(priv->regmap)) {\n\t\t\tret = PTR_ERR(priv->regmap);\n\t\t\tdev_err(dev, \"Failed to get syscon %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tpriv->no_offset = true;\n\t}\n\n\tret = phy_gmii_sel_init_ports(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tpriv->phy_provider =\n\t\tdevm_of_phy_provider_register(dev,\n\t\t\t\t\t      phy_gmii_sel_of_xlate);\n\tif (IS_ERR(priv->phy_provider)) {\n\t\tret = PTR_ERR(priv->phy_provider);\n\t\tdev_err(dev, \"Failed to create phy provider %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver phy_gmii_sel_driver = {\n\t.probe\t\t= phy_gmii_sel_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"phy-gmii-sel\",\n\t\t.of_match_table = phy_gmii_sel_id_table,\n\t},\n};\nmodule_platform_driver(phy_gmii_sel_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Grygorii Strashko <grygorii.strashko@ti.com>\");\nMODULE_DESCRIPTION(\"TI CPSW Port's PHY Interface Mode selection Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}